<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>尼采般地抒情</title>
  <icon>https://www.wztlink1013.com/favicon.ico</icon>
  <subtitle>什么都不舍弃，什么也改变不了</subtitle>
  <link href="https://www.wztlink1013.com/atom.xml" rel="self"/>
  
  <link href="https://www.wztlink1013.com/"/>
  <updated>2024-11-16T19:50:36.000Z</updated>
  <id>https://www.wztlink1013.com/</id>
  
  <author>
    <name>尼采般地抒情</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Array.sort方法对象数组按照对象多个属性自定义排序</title>
    <link href="https://www.wztlink1013.com/blog/zc9z0brbpges03gt/"/>
    <id>https://www.wztlink1013.com/blog/zc9z0brbpges03gt/</id>
    <published>2024-11-12T01:15:24.000Z</published>
    <updated>2024-11-16T19:50:36.000Z</updated>
    
    <content type="html"><![CDATA[<div class="lake-content" typography="classic"><pre data-language="javascript" id="ZdrYM" class="ne-codeblock language-javascript"><code>data.sort((a, b) =&gt; &#123;  // 属性优先级依次比较  for (const s of sortListData) &#123;    if (!s.sortField || !s.sortOrder) continue;    const aValue = a[s.sortField];    const bValue = b[s.sortField];    if (aValue == bValue) continue;    // 值不相等时 使用mini内置排序进行排序    const sortFun = grid._dataSource._getSortFnByField(s.sortField, 'string', s.sortOrder === 'desc');    return sortFun(a, b);  &#125;  return 0;&#125;);</code></pre><ul class="ne-ul"><li id="u923b8825" data-lake-index-type="0"><span class="ne-text">grid._dataSource._getSortFnByField：一个指定排序规则，并且只返回1和-1，所以需要第五行和第六行的判断代码</span></li></ul></div>]]></content>
    
    
      
      
        
        
    <summary type="html">

&lt;div class=&quot;lake-content&quot; typography=&quot;classic&quot;&gt;&lt;pre data-language=&quot;javascript&quot; id=&quot;ZdrYM&quot; class=&quot;ne-codeblock</summary>
        
      
    
    
    
    <category term="Web开发" scheme="https://www.wztlink1013.com/categories/Web%E5%BC%80%E5%8F%91/"/>
    
    <category term="JavaScript" scheme="https://www.wztlink1013.com/categories/Web%E5%BC%80%E5%8F%91/JavaScript/"/>
    
    <category term="ECMAScript" scheme="https://www.wztlink1013.com/categories/Web%E5%BC%80%E5%8F%91/JavaScript/ECMAScript/"/>
    
    
  </entry>
  
  <entry>
    <title>SPA项目首屏优化</title>
    <link href="https://www.wztlink1013.com/blog/xtipoqq45ui63kh6/"/>
    <id>https://www.wztlink1013.com/blog/xtipoqq45ui63kh6/</id>
    <published>2024-11-07T23:42:35.000Z</published>
    <updated>2024-11-16T19:50:36.000Z</updated>
    
    <content type="html"><![CDATA[<div class="lake-content" typography="classic"><ol class="ne-ol"><li id="ud70d8baa" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">产生原因<br>react是单页面应用，html靠js生成，如果首屏需要加载很大的js文件(app.js)，所以当网络不好的时候会有一段时间的白屏现象。</span></li><li id="u4746c1ee" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">解决方法</span></li></ol><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="u50ac17f4" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">优化webpack减少模块打包体积，按需加载。</span></li><li id="u27f4c811" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">使用ssr服务端渲染，在服务端事先拼装好首页所需的html【对服务器资源消耗大】</span></li><li id="udc74c026" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">首页加loading（正好可以是广告时间）或骨架屏</span></li><li id="uff8c7a14" data-lake-index-type="0"><strong><span class="ne-text" style="font-size: 16px; color: #DF2A3F">使用首屏SSR+跳转SPA方式来优化。【只是在首页使用ssr】</span></strong></li><li id="u537fd6a2" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">使用CDN加载资源。</span><a href="https://www.jianshu.com/p/1dae6e1680ff" data-href="https://www.jianshu.com/p/1dae6e1680ff" target="_blank" class="ne-link"><span class="ne-text" style="font-size: 16px">cdn加速原理</span></a><a href="https://www.cnblogs.com/crazylqy/p/7110357.html" data-href="https://www.cnblogs.com/crazylqy/p/7110357.html" target="_blank" class="ne-link"><span class="ne-text" style="font-size: 16px">DNS过程</span></a></li><li id="u2cd4671e" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">服务器开启gizp加速。</span></li><li id="u3217f519" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px; color: #DF2A3F">改单页应用为多页应用。</span></li><li id="u4cebb8d9" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">图片压缩小图标用雪碧图，优先使用webp格式。图片懒加载等等</span></li><li id="u37083231" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">合理使用缓存。</span></li><li id="uccd24921" data-lake-index-type="0"><span class="ne-text" style="font-size: 16px">优化代码逻辑，把主要的js和次要js分开来。</span></li></ul></ul></div>]]></content>
    
    
      
      
        
        
    <summary type="html">

&lt;div class=&quot;lake-content&quot; typography=&quot;classic&quot;&gt;&lt;ol class=&quot;ne-ol&quot;&gt;&lt;li id=&quot;ud70d8baa&quot; data-lake-index-type=&quot;0&quot;&gt;&lt;span class=&quot;ne-text&quot;</summary>
        
      
    
    
    
    <category term="Web开发" scheme="https://www.wztlink1013.com/categories/Web%E5%BC%80%E5%8F%91/"/>
    
    <category term="前端性能优化" scheme="https://www.wztlink1013.com/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    
  </entry>
  
  <entry>
    <title>serve：一个简单的静态文件服务器</title>
    <link href="https://www.wztlink1013.com/blog/le2wy264p9sm8vem/"/>
    <id>https://www.wztlink1013.com/blog/le2wy264p9sm8vem/</id>
    <published>2024-11-03T21:52:22.000Z</published>
    <updated>2024-11-16T19:50:36.000Z</updated>
    
    <content type="html"><![CDATA[<div class="lake-content" typography="classic"><ul class="ne-ul"><li id="u5a657014" data-lake-index-type="0"><a href="https://www.npmjs.com/package/serve" data-href="https://www.npmjs.com/package/serve" target="_blank" class="ne-link"><span class="ne-text">https://www.npmjs.com/package/serve</span></a></li></ul><pre data-language="bash" id="S3Ooj" class="ne-codeblock language-bash"><code>npm install --global serve</code></pre><ul class="ne-ul"><li id="u09b4e296" data-lake-index-type="0"><span class="ne-text">在文件夹下输入启动命令</span></li></ul><pre data-language="bash" id="KOSP9" class="ne-codeblock language-bash"><code>serve</code></pre><p id="u24aaaf8b" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2024/png/1484158/1730699721153-e2baf7c4-f014-46d9-89d5-0d4bab38a445.png" width="960" id="ua3bc2309" class="ne-image"></p></div>]]></content>
    
    
      
      
        
        
    <summary type="html">

&lt;div class=&quot;lake-content&quot; typography=&quot;classic&quot;&gt;&lt;ul class=&quot;ne-ul&quot;&gt;&lt;li id=&quot;u5a657014&quot; data-lake-index-type=&quot;0&quot;&gt;&lt;a</summary>
        
      
    
    
    
    <category term="Web开发" scheme="https://www.wztlink1013.com/categories/Web%E5%BC%80%E5%8F%91/"/>
    
    <category term="Node.js" scheme="https://www.wztlink1013.com/categories/Web%E5%BC%80%E5%8F%91/Node-js/"/>
    
    
  </entry>
  
  <entry>
    <title>FATAL ERROR: Reached heap limit Allocation failed - JavaScript heap out of memory</title>
    <link href="https://www.wztlink1013.com/blog/wsm9wflpwozi8hdx/"/>
    <id>https://www.wztlink1013.com/blog/wsm9wflpwozi8hdx/</id>
    <published>2024-11-02T17:59:07.000Z</published>
    <updated>2024-11-16T19:50:36.000Z</updated>
    
    <content type="html"><![CDATA[<div class="lake-content" typography="classic"><p id="uea5afc15" class="ne-p"><span class="ne-text">GitHub Actions 执行Node命令打包一个项目，报错</span><code class="ne-code"><span class="ne-text">FATAL ERROR: Reached heap limit Allocation failed - JavaScript heap out of memory</span></code></p><p id="u1030fef5" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2024/png/1484158/1730599267347-28e41456-1148-4db4-8a48-b371a8c89e8b.png" width="1504.5454219353107" id="u34989fb4" class="ne-image"></p><p id="u7de9bd7c" class="ne-p"><span class="ne-text">原因：GitHub Actions Nodejs运行时环境使用内存是有大小限制的，64位系统约为1.4GB，32位系统约为0.7GB，该次构建内存使用超出了默认大小</span></p><p id="uab764f01" class="ne-p"><span class="ne-text"></span></p><p id="uf9b586f7" class="ne-p"><span class="ne-text">解决：</span><code class="ne-code"><span class="ne-text">export NODE_OPTIONS="--max-old-space-size=4096"</span></code></p><p id="u57d72947" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2024/png/1484158/1730599355754-28c9c22a-1bb2-41aa-97e3-cead4b74871c.png" width="713.6363481687124" id="uc86e10ca" class="ne-image"></p></div>]]></content>
    
    
      
      
        
        
    <summary type="html">

&lt;div class=&quot;lake-content&quot; typography=&quot;classic&quot;&gt;&lt;p id=&quot;uea5afc15&quot; class=&quot;ne-p&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;GitHub Actions</summary>
        
      
    
    
    
    <category term="Web开发" scheme="https://www.wztlink1013.com/categories/Web%E5%BC%80%E5%8F%91/"/>
    
    <category term="Node.js" scheme="https://www.wztlink1013.com/categories/Web%E5%BC%80%E5%8F%91/Node-js/"/>
    
    
  </entry>
  
  <entry>
    <title>UTC格式时间及其dayjs相关封装</title>
    <link href="https://www.wztlink1013.com/blog/izghbc3thbmzv6al/"/>
    <id>https://www.wztlink1013.com/blog/izghbc3thbmzv6al/</id>
    <published>2024-10-29T21:58:35.000Z</published>
    <updated>2024-11-16T19:50:36.000Z</updated>
    
    <content type="html"><![CDATA[<div class="lake-content" typography="classic"><ul class="ne-ul"><li id="ube69d6f8" data-lake-index-type="0"><code class="ne-code"><span class="ne-text">2024-09-03T16:00:00.000Z</span></code><span class="ne-text">这种格式是UTC格式</span></li><li id="ud0345811" data-lake-index-type="0"><span class="ne-text">北京时间比UTC格式时间快8小时</span></li><li id="u27854b5f" data-lake-index-type="0"><span class="ne-text">国际化的Web APP需要用户设置地区，以此来正确显示自己地区的位置时间</span></li></ul><h2 id="aNrMk"><span class="ne-text">使用dayjs库</span></h2><h3 id="Jo9Nn"><span class="ne-text">国际化</span></h3><ul class="ne-ul"><li id="u052574b3" data-lake-index-type="0"><span class="ne-text">首先需要引入静态资源：</span><a href="https://github.com/wztlink1013/lyrics/blob/5cd479b933dbfed4b4ca1ce682fa6219a8db5b94/apps/lyrics-client/src/locales/i18n.ts#L6" data-href="https://github.com/wztlink1013/lyrics/blob/5cd479b933dbfed4b4ca1ce682fa6219a8db5b94/apps/lyrics-client/src/locales/i18n.ts#L6" target="_blank" class="ne-link"><span class="ne-text">https://github.com/wztlink1013/lyrics/blob/5cd479b933dbfed4b4ca1ce682fa6219a8db5b94/apps/lyrics-client/src/locales/i18n.ts#L6</span></a></li><li id="u3fe86f5d" data-lake-index-type="0"><span class="ne-text">跟随Web应用进行国际化切换：</span><a href="https://day.js.org/docs/zh-CN/i18n/loading-into-nodejs" data-href="https://day.js.org/docs/zh-CN/i18n/loading-into-nodejs" target="_blank" class="ne-link"><span class="ne-text">https://day.js.org/docs/zh-CN/i18n/loading-into-nodejs</span></a></li></ul><h3 id="fsQBw"><span class="ne-text">默认UTC+使用地区插件展示</span></h3><ul class="ne-ul"><li id="u17adbaa9" data-lake-index-type="0"><a href="https://github.com/wztlink1013/lyrics/blob/5cd479b933dbfed4b4ca1ce682fa6219a8db5b94/apps/lyrics-client/src/locales/i18n.ts#L18" data-href="https://github.com/wztlink1013/lyrics/blob/5cd479b933dbfed4b4ca1ce682fa6219a8db5b94/apps/lyrics-client/src/locales/i18n.ts#L18" target="_blank" class="ne-link"><span class="ne-text">https://github.com/wztlink1013/lyrics/blob/5cd479b933dbfed4b4ca1ce682fa6219a8db5b94/apps/lyrics-client/src/locales/i18n.ts#L18</span></a></li></ul><pre data-language="typescript" id="OUCCY" class="ne-codeblock language-typescript"><code>import utc from 'dayjs/plugin/utc';import timezone from 'dayjs/plugin/timezone';dayjs.extend(utc);dayjs.extend(timezone);</code></pre><p id="u5ec727f1" class="ne-p"><span class="ne-text">这两行代码是使用 </span><code class="ne-code"><span class="ne-text">dayjs</span></code><span class="ne-text"> 这个日期处理库时的扩展功能。</span></p><ol class="ne-ol"><li id="u89de3775" data-lake-index-type="0"><code class="ne-code"><span class="ne-text">dayjs.extend(utc);</span></code><span class="ne-text">：</span></li></ol><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="u9e8139e8" data-lake-index-type="0"><span class="ne-text">这一行代码引入了 </span><code class="ne-code"><span class="ne-text">dayjs</span></code><span class="ne-text"> 的 </span><code class="ne-code"><span class="ne-text">utc</span></code><span class="ne-text"> 插件，使得 </span><code class="ne-code"><span class="ne-text">dayjs</span></code><span class="ne-text"> 能够支持 UTC 时间的处理。通过这个插件，可以方便地进行 UTC 时间和本地时间之间的转换。</span></li></ul></ul><ol start="2" class="ne-ol"><li id="u6229f247" data-lake-index-type="0"><code class="ne-code"><span class="ne-text">dayjs.extend(timezone);</span></code><span class="ne-text">：</span></li></ol><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="u37ca31d1" data-lake-index-type="0"><span class="ne-text">这一行代码引入了 </span><code class="ne-code"><span class="ne-text">dayjs</span></code><span class="ne-text"> 的 </span><code class="ne-code"><span class="ne-text">timezone</span></code><span class="ne-text"> 插件，它允许在不同的时区之间进行时间转换。这个插件可以根据指定的时区处理时间，使得显示和计算更加灵活。</span></li></ul></ul><p id="u98ade03b" class="ne-p"><span class="ne-text">总的来说，这两行代码的目的是增强 </span><code class="ne-code"><span class="ne-text">dayjs</span></code><span class="ne-text"> 库，使其能够处理 UTC 和不同的时区，从而更好地支持国际化和跨时区的时间管理。</span></p><p id="u9fe7725e" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2024/png/1484158/1730269588568-d36c14f7-2652-4496-8d3b-2625d3490e25.png" width="677" id="u0cc49a87" class="ne-image"></p><p id="u83b399f2" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2024/png/1484158/1730269601607-37256249-4248-411d-b93d-c639c8300057.png" width="104" id="u8ebfb9eb" class="ne-image"></p><h3 id="kW45Q"><span class="ne-text">格式化UTC字符串为指定地区指定格式</span></h3><p id="u7339b7fe" class="ne-p"><span class="ne-text">其中</span><code class="ne-code"><span class="ne-text">'Asia/Shanghai'</span></code><span class="ne-text">应该设置为一个配置</span></p><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="ua129c0d6" data-lake-index-type="0"><a href="https://github.com/wztlink1013/lyrics/blob/5cd479b933dbfed4b4ca1ce682fa6219a8db5b94/apps/lyrics-client/src/components/Doc/EditorView.tsx#L517" data-href="https://github.com/wztlink1013/lyrics/blob/5cd479b933dbfed4b4ca1ce682fa6219a8db5b94/apps/lyrics-client/src/components/Doc/EditorView.tsx#L517" target="_blank" class="ne-link"><span class="ne-text">https://github.com/wztlink1013/lyrics/blob/5cd479b933dbfed4b4ca1ce682fa6219a8db5b94/apps/lyrics-client/src/components/Doc/EditorView.tsx#L517</span></a></li></ul></ul><pre data-language="typescript" id="OspIH" class="ne-codeblock language-typescript"><code>dayjs  .utc(updatedAtStr)  .tz('Asia/Shanghai')  .format('YYYY-MM-DD HH:mm:ss')</code></pre><h3 id="YEHxa"><span class="ne-text">封装</span></h3><pre data-language="typescript" id="Hd4HU" class="ne-codeblock language-typescript"><code>import dayjs from 'dayjs';import utc from 'dayjs/plugin/utc';import timezone from 'dayjs/plugin/timezone';import isSameOrAfter from 'dayjs/plugin/isSameOrAfter';import isSameOrBefore from 'dayjs/plugin/isSameOrBefore';import customParseFormat from 'dayjs/plugin/customParseFormat';import weekOfYear from 'dayjs/plugin/weekOfYear';// timezonedayjs.extend(utc);dayjs.extend(timezone);// first and lastdayjs.extend(isSameOrAfter);dayjs.extend(isSameOrBefore);dayjs.extend(customParseFormat);dayjs.extend(weekOfYear);const TIMEZONE = 'Asia/Shanghai';/** * get date string with UTC datasource and assign timezone * @param str UTC time string * @param template dayjs format string * @param option other params * @param option.timezone assign timezone * @returns format string */const getFormatTime = (  str: string,  template = '',  option?: &#123;    timezone?: string;  &#125;) =&gt; &#123;  return dayjs(str)    .utc()    .tz(option?.timezone || TIMEZONE)    .format(template);&#125;;enum TimeBoundaryType &#123;  MONTH = 'month',  WEEK = 'week',&#125;type TimeWeekStart = 1 | 2 | 3 | 4 | 5 | 6 | 7;/** * get date string's month boundary * @param str time string * @param isStart true -&gt; month first day; false -&gt; month last day; * @param option other params * @param option.showHMS show h m s * @param option.weekStart when boundaryType is week, week first day * @returns format string */const getTimeMonthBoundary = (  str: string,  isStart = true,  option?: &#123;    showHMS?: boolean;    boundaryType?: TimeBoundaryType;    weekStart?: TimeWeekStart;  &#125;) =&gt; &#123;  return `$&#123;dayjs(str)    [isStart ? 'startOf' : 'endOf'](option?.boundaryType || 'month')    .add(      option?.boundaryType === 'week' &amp;&amp; option?.weekStart        ? option.weekStart        : 0,      'day'    )    .format('YYYY-MM-DD')&#125;$&#123;    option?.showHMS ? (isStart ? ' 00:00:00' : ' 23:59:59') : ''  &#125;`;&#125;;</code></pre><pre data-language="typescript" id="ZQax6" class="ne-codeblock language-typescript"><code>const dateStr = '2024-09-30T00:22:25.218Z';const formatDateStr = getFormatTime(dateStr, 'YYYY-MM-DD HH:mm:ss');const mStart = getTimeMonthBoundary(formatDateStr, true, &#123;  showHMS: true,  boundaryType: TimeBoundaryType.WEEK,  weekStart: 1,&#125;);const mEnd = getTimeMonthBoundary(formatDateStr, false, &#123;  showHMS: true,  boundaryType: TimeBoundaryType.WEEK,  weekStart: 1,&#125;);console.info('[info]', &#123; dateStr, formatDateStr, mStart, mEnd &#125;);</code></pre><p id="u7bab4c62" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2024/png/1484158/1730273367448-9324b728-813a-429a-b931-701b8a5fa6bb.png" width="427" id="u8700ef09" class="ne-image"></p></div>]]></content>
    
    
      
      
        
        
    <summary type="html">

&lt;div class=&quot;lake-content&quot; typography=&quot;classic&quot;&gt;&lt;ul class=&quot;ne-ul&quot;&gt;&lt;li id=&quot;ube69d6f8&quot; data-lake-index-type=&quot;0&quot;&gt;&lt;code class=&quot;ne-code&quot;&gt;&lt;span</summary>
        
      
    
    
    
    <category term="Web开发" scheme="https://www.wztlink1013.com/categories/Web%E5%BC%80%E5%8F%91/"/>
    
    <category term="前端业务解决方案" scheme="https://www.wztlink1013.com/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E4%B8%9A%E5%8A%A1%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    
    
  </entry>
  
  <entry>
    <title>Next Route</title>
    <link href="https://www.wztlink1013.com/blog/ere3ox6yqqqt46i4/"/>
    <id>https://www.wztlink1013.com/blog/ere3ox6yqqqt46i4/</id>
    <published>2024-10-21T23:39:26.000Z</published>
    <updated>2024-11-19T05:50:12.000Z</updated>
    
    <content type="html"><![CDATA[<div class="lake-content" typography="classic"><h2 id="M6Hgw"><span class="ne-text">特殊路由文件</span></h2><h3 id="DMzBp"><span class="ne-text">布局结构有关</span></h3><p id="u3640c967" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2024/png/1484158/1729603955959-757c0f34-0131-4acf-8de9-b781df8374a1.png" width="819.0908913375921" id="u69de0a53" class="ne-image"></p><h3 id="bQsYr"><span class="ne-text">组件按需加载而不是重新加载整个页面</span></h3><p id="u72bd6090" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2024/png/1484158/1729604088141-ec001e1e-91d1-4f29-aa34-c8be393580e4.png" width="1159.0908839682907" id="u8098e449" class="ne-image"></p><h3 id="tInaa"><span class="ne-text">边界处理</span></h3><p id="u4d8ceed0" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2024/png/1484158/1729604165136-dc922fdc-f3ee-45f6-95fa-0180dbd9b743.png" width="579.0908965394519" id="u3139dc96" class="ne-image"></p><h3 id="v76G0"><span class="ne-text">重定向配置</span></h3><p id="u99878a82" class="ne-p"><a href="https://nextjs.org/docs/app/building-your-application/routing/redirecting" data-href="https://nextjs.org/docs/app/building-your-application/routing/redirecting" target="_blank" class="ne-link"><span class="ne-text">https://nextjs.org/docs/app/building-your-application/routing/redirecting</span></a></p><p id="ub4301e1f" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2024/png/1484158/1729613573978-6fea88b5-8530-49a4-b2a8-8fd9be06d1ab.png" width="514.5454433929824" id="uf18f848e" class="ne-image"></p><h2 id="bOxo1"><span class="ne-text">路由</span></h2><p id="u12328168" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2024/png/1484158/1729613630468-bcef25a1-46b9-4c3c-b442-cd20a682afea.png" width="453.6363538040605" id="u2cfa2681" class="ne-image"></p><ul class="ne-ul"><li id="uf68f17f1" data-lake-index-type="0"><span class="ne-text">page.tsx、route.tsx等一些其他指定文件名的文件路由是实际路由，其他的文件都充当不了路由（</span><a href="https://nextjs.org/docs/app/building-your-application/routing/colocation#safe-colocation-by-default" data-href="https://nextjs.org/docs/app/building-your-application/routing/colocation#safe-colocation-by-default" target="_blank" class="ne-link"><span class="ne-text">https://nextjs.org/docs/app/building-your-application/routing/colocation#safe-colocation-by-default</span></a><span class="ne-text">）</span></li><li id="u435abbb3" data-lake-index-type="0"><span class="ne-text">下划线开头的文件夹访问不了</span></li></ul><h3 id="dabzk"><span class="ne-text">page.tsx和roue.tsx分别构建页面和数据源(API接口)</span></h3><p id="u1561430e" class="ne-p"><br></p><h3 id="Ssjqj"><span class="ne-text">预渲染构建</span></h3><ul class="ne-ul"><li id="uff8186cd" data-lake-index-type="0"><span class="ne-text">当阅读同类型文件时，类似于将接口数据缓存下来，然后切换路由直接替换数据即可</span></li></ul><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="u950d109f" data-lake-index-type="0"><a href="https://nextjs.org/docs/app/building-your-application/routing/dynamic-routes#generating-static-params" data-href="https://nextjs.org/docs/app/building-your-application/routing/dynamic-routes#generating-static-params" target="_blank" class="ne-link"><span class="ne-text">https://nextjs.org/docs/app/building-your-application/routing/dynamic-routes#generating-static-params</span></a></li></ul></ul><p id="u3246ca17" class="ne-p"><span class="ne-text">在 Next.js 中，生成静态参数（Generating Static Params）是指在使用动态路由时，为每个动态路径生成静态参数，以便在构建时预先渲染这些页面。这可以提升性能，因为预渲染的页面可以直接服务于用户，而无需在请求时进行服务器端渲染。</span></p><p id="u91f84bf3" class="ne-p"><span class="ne-text" style="color: #DF2A3F">主要概念</span></p><ol class="ne-ol"><li id="uefd63a53" data-lake-index-type="0"><strong><span class="ne-text">动态路由</span></strong><span class="ne-text">：</span></li></ol><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="u2c0dce17" data-lake-index-type="0"><span class="ne-text">通过方括号定义动态路由，例如 </span><code class="ne-code"><span class="ne-text">[id]</span></code><span class="ne-text">，表示这个路由是动态的，可以接收不同的参数。</span></li></ul></ul><ol start="2" class="ne-ol"><li id="uc2955fae" data-lake-index-type="0"><strong><span class="ne-text">生成静态参数</span></strong><span class="ne-text">:</span></li></ol><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="u62b1f5de" data-lake-index-type="0"><span class="ne-text">使用 </span><code class="ne-code"><span class="ne-text">getStaticPaths</span></code><span class="ne-text"> 方法在构建时获取所有可能的动态参数。这个方法返回一个对象，包含所有要预渲染的动态路径。</span></li></ul></ul><ol start="3" class="ne-ol"><li id="u9b0218d7" data-lake-index-type="0"><strong><span class="ne-text">示例</span></strong><span class="ne-text">:</span></li></ol><pre data-language="typescript" id="u46s8" class="ne-codeblock language-typescript"><code>export async function getStaticPaths() &#123;  const posts = await fetch('https://api.example.com/posts');  const paths = posts.map(post =&gt; (&#123; params: &#123; id: post.id &#125; &#125;));  return &#123; paths, fallback: false &#125;;&#125;</code></pre><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="ubadb56fa" data-lake-index-type="0"><span class="ne-text">假设你有一个文章页面，路径为 </span><code class="ne-code"><span class="ne-text">/posts/[id]</span></code><span class="ne-text">。在 </span><code class="ne-code"><span class="ne-text">getStaticPaths</span></code><span class="ne-text"> 中，你可以定义所有要生成的文章 ID：</span></li></ul></ul><ol start="4" class="ne-ol"><li id="ue4aaca11" data-lake-index-type="0"><strong><span class="ne-text">优点</span></strong><span class="ne-text">:</span></li></ol><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="u43a9f782" data-lake-index-type="0"><span class="ne-text">预渲染的页面可以在用户请求时快速响应，减少服务器负载，提高性能。</span></li><li id="u388162f6" data-lake-index-type="0"><span class="ne-text">有利于 SEO，因为搜索引擎可以更容易地抓取预渲染的内容。</span></li></ul></ul><p id="ue895591e" class="ne-p"><span class="ne-text" style="color: #DF2A3F">结论</span></p><p id="u1d8436f6" class="ne-p"><span class="ne-text">生成静态参数是一种优化技术，使动态路由在构建时生成可静态服务的页面，提升性能和用户体验。这在处理大量动态内容时尤其重要。</span></p><h3 id="eR5wU"><span class="ne-text">单中括号和双中括号</span></h3><ul class="ne-ul"><li id="u299b6342" data-lake-index-type="0"><span class="ne-text">区别于没有路径参数时是否渲染页面</span></li></ul><p id="u918633e9" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2024/png/1484158/1729613081751-d411b498-2a50-4678-9983-9f4fd999fd91.png" width="907.272707608121" id="u4e8e653c" class="ne-image"></p><h3 id="T2G2w"><span class="ne-text">平行路由（@开头的文件夹）</span></h3><ul class="ne-ul"><li id="u63ccf502" data-lake-index-type="0"><a href="https://nextjs.org/docs/app/building-your-application/routing/parallel-routes" data-href="https://nextjs.org/docs/app/building-your-application/routing/parallel-routes" target="_blank" class="ne-link"><span class="ne-text">https://nextjs.org/docs/app/building-your-application/routing/parallel-routes</span></a></li><li id="uacb519e2" data-lake-index-type="0"><a href="https://nextjs.net.cn/docs/app/building-your-application/routing/parallel-routes" data-href="https://nextjs.net.cn/docs/app/building-your-application/routing/parallel-routes" target="_blank" class="ne-link"><span class="ne-text">https://nextjs.net.cn/docs/app/building-your-application/routing/parallel-routes</span></a></li><li id="u559315cf" data-lake-index-type="0"><span class="ne-text">好处：可以渲染各自的状态（加载中或错误处理等），还可以通过角色来判断渲染哪类路由：</span><a href="https://yuxuetr.com/wiki/nextjs/parallel-routes" data-href="https://yuxuetr.com/wiki/nextjs/parallel-routes" target="_blank" class="ne-link"><span class="ne-text">https://yuxuetr.com/wiki/nextjs/parallel-routes</span></a></li><li id="u885c44f3" data-lake-index-type="0"><span class="ne-text">实现条件路由</span></li><li id="u18de36e5" data-lake-index-type="0"><span class="ne-text">实现模态路由</span></li></ul><h3 id="GRMFW"><span class="ne-text">拦截路由模态（(.)写法）</span></h3><p id="u42357724" class="ne-p"><a href="https://nextjs.org/docs/app/building-your-application/routing/intercepting-routes" data-href="https://nextjs.org/docs/app/building-your-application/routing/intercepting-routes" target="_blank" class="ne-link"><span class="ne-text">https://nextjs.org/docs/app/building-your-application/routing/intercepting-routes</span></a></p><h3 id="YoyqV"><span class="ne-text">TODO: 处理请求与响应请求</span></h3><h2 id="dhSa2"></h2><p id="u84f438a3" class="ne-p"><br></p><p id="u3ae9a8bf" class="ne-p"><br></p><p id="u32924e9e" class="ne-p"><br></p><p id="u1d3ce715" class="ne-p"><br></p><p id="u6d9e25ed" class="ne-p"><br></p></div>]]></content>
    
    
      
      
        
        
    <summary type="html">

&lt;div class=&quot;lake-content&quot; typography=&quot;classic&quot;&gt;&lt;h2 id=&quot;M6Hgw&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;特殊路由文件&lt;/span&gt;&lt;/h2&gt;&lt;h3 id=&quot;DMzBp&quot;&gt;&lt;span</summary>
        
      
    
    
    
    <category term="Web开发" scheme="https://www.wztlink1013.com/categories/Web%E5%BC%80%E5%8F%91/"/>
    
    <category term="Next.js" scheme="https://www.wztlink1013.com/categories/Web%E5%BC%80%E5%8F%91/Next-js/"/>
    
    
  </entry>
  
  <entry>
    <title>[ChatGPT] Vue和React的diff算法</title>
    <link href="https://www.wztlink1013.com/blog/ug01qnk1txsegqfy/"/>
    <id>https://www.wztlink1013.com/blog/ug01qnk1txsegqfy/</id>
    <published>2024-10-13T23:07:37.000Z</published>
    <updated>2024-11-16T19:50:36.000Z</updated>
    
    <content type="html"><![CDATA[<div class="lake-content" typography="classic"><p id="u0dd4c899" class="ne-p"><span class="ne-text">Vue 和 React 的 diff 算法都是为了解决虚拟 DOM 更新的问题，它们都使用了 </span><strong><span class="ne-text">Diffing</span></strong><span class="ne-text"> 技术来优化 DOM 渲染。虽然两者有相似的思想，但实现上存在一些差异。</span></p><h3 id="DbnV2"><span class="ne-text">1. </span><strong><span class="ne-text">React 的 Diff 算法</span></strong></h3><p id="ua7dc5f42" class="ne-p"><span class="ne-text">React 使用了一种 </span><strong><span class="ne-text">O(n)</span></strong><span class="ne-text"> 复杂度的 Diff 算法，这被称为 </span><strong><span class="ne-text">Fiber</span></strong><span class="ne-text">。该算法主要分为两部分：</span><strong><span class="ne-text">reconciliation（调和过程）</span></strong><span class="ne-text"> 和 </span><strong><span class="ne-text">rendering（渲染过程）</span></strong><span class="ne-text">。</span></p><h4 id="qG5fd"><span class="ne-text">核心思想</span></h4><ul class="ne-ul"><li id="u8c9ae04b" data-lake-index-type="0"><strong><span class="ne-text">分层比较（树分层比较）</span></strong><span class="ne-text">：React 不会进行整个虚拟 DOM 树的逐个节点对比，而是将树分为不同层，逐层进行比较。这大幅降低了时间复杂度。</span></li><li id="ufafd5a35" data-lake-index-type="0"><strong><span class="ne-text">组件类型不同，直接替换</span></strong><span class="ne-text">：如果新旧虚拟 DOM 的类型不同（比如 </span><code class="ne-code"><span class="ne-text">&lt;div&gt;</span></code><span class="ne-text"> 换成了 </span><code class="ne-code"><span class="ne-text">&lt;span&gt;</span></code><span class="ne-text">，或者是不同的组件类型），React 不会去做深入比较，而是直接删除旧节点，创建新节点。</span></li><li id="ua58c8422" data-lake-index-type="0"><strong><span class="ne-text">key 优化</span></strong><span class="ne-text">：React 使用 </span><code class="ne-code"><span class="ne-text">key</span></code><span class="ne-text"> 属性来标识列表中的节点。当同级列表元素的 </span><code class="ne-code"><span class="ne-text">key</span></code><span class="ne-text"> 发生变化时，React 会尝试优化节点的重排，而不是逐个删除和重建。没有 </span><code class="ne-code"><span class="ne-text">key</span></code><span class="ne-text"> 的列表会引发性能问题，因为 React 会进行位置的逐个比对。</span></li></ul><h4 id="Hkruy"><span class="ne-text">更新流程</span></h4><ol class="ne-ol"><li id="u874e1cb3" data-lake-index-type="0"><span class="ne-text">React 会从根节点开始比较每一层的虚拟 DOM。</span></li><li id="u7ad0411d" data-lake-index-type="0"><span class="ne-text">如果节点类型相同（如 </span><code class="ne-code"><span class="ne-text">&lt;div&gt;</span></code><span class="ne-text"> 对比 </span><code class="ne-code"><span class="ne-text">&lt;div&gt;</span></code><span class="ne-text">），则对比其属性和子节点。</span></li><li id="ua1bb18a3" data-lake-index-type="0"><span class="ne-text">如果节点类型不同，则直接删除旧节点，创建新节点。</span></li><li id="u9a7614aa" data-lake-index-type="0"><span class="ne-text">对于列表，React 会优先查找 </span><code class="ne-code"><span class="ne-text">key</span></code><span class="ne-text"> 值相同的节点，避免不必要的删除和创建。</span></li></ol><h4 id="NF2EK"><span class="ne-text">优化策略</span></h4><p id="u545535f7" class="ne-p"><span class="ne-text">React 的算法设计思路是通过 </span><strong><span class="ne-text">浅层对比</span></strong><span class="ne-text"> 来加速渲染，优先保证渲染性能，而不是精确地对每个节点进行深层次比对。</span></p><h3 id="aB5kz"><span class="ne-text">2. </span><strong><span class="ne-text">Vue 的 Diff 算法</span></strong></h3><p id="u97f1712a" class="ne-p"><span class="ne-text">Vue 2 和 Vue 3 都使用了 </span><strong><span class="ne-text">O(n)</span></strong><span class="ne-text"> 的 Diff 算法，核心基于 </span><code class="ne-code"><span class="ne-text">snabbdom</span></code><span class="ne-text"> 的实现，特别是在 Vue 3 中，diff 算法进行了优化，追求高效且轻量的更新过程。</span></p><h4 id="RcSjF"><span class="ne-text">核心思想</span></h4><ul class="ne-ul"><li id="u7f06da5b" data-lake-index-type="0"><strong><span class="ne-text">双端比较</span></strong><span class="ne-text">：Vue 采用了 </span><strong><span class="ne-text">双端比较</span></strong><span class="ne-text"> 策略，即分别从新旧虚拟 DOM 的两端进行对比，直到遇到不同的节点。这样可以快速确定相同的节点，减少中间节点的比对。</span></li><li id="uffcec6d8" data-lake-index-type="0"><strong><span class="ne-text">patch 函数</span></strong><span class="ne-text">：Vue 使用 </span><code class="ne-code"><span class="ne-text">patch</span></code><span class="ne-text"> 函数递归地比较新旧虚拟 DOM 树，通过 </span><strong><span class="ne-text">最小化修改</span></strong><span class="ne-text"> 的方式更新真实 DOM。</span></li><li id="u383b6ea7" data-lake-index-type="0"><strong><span class="ne-text">静态节点优化</span></strong><span class="ne-text">：Vue 会在模板编译时对静态节点进行标记，这样在更新时可以跳过对静态节点的比对，从而提高性能。</span></li><li id="u7b3fa3ac" data-lake-index-type="0"><strong><span class="ne-text">key 优化</span></strong><span class="ne-text">：和 React 类似，Vue 也会使用 </span><code class="ne-code"><span class="ne-text">key</span></code><span class="ne-text"> 来优化列表的节点更新，确保节点重用和位置变化的高效处理。</span></li></ul><h4 id="QG5uG"><span class="ne-text">更新流程</span></h4><ol class="ne-ol"><li id="u56a7e6b6" data-lake-index-type="0"><span class="ne-text">Vue 会从根节点开始对比新旧虚拟 DOM。</span></li><li id="u4e3b5fd8" data-lake-index-type="0"><span class="ne-text">对比节点类型和属性：</span></li></ol><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="uc1efe140" data-lake-index-type="0"><span class="ne-text">如果节点类型不同，直接替换。</span></li><li id="u903a3fc9" data-lake-index-type="0"><span class="ne-text">如果节点类型相同，则继续比较属性和子节点。</span></li></ul></ul><ol start="3" class="ne-ol"><li id="u00bb598e" data-lake-index-type="0"><span class="ne-text">如果是列表，Vue 会基于双端比较算法对列表进行最小化的更新操作。</span></li><li id="u2a7de034" data-lake-index-type="0"><span class="ne-text">对于静态内容的优化，Vue 会跳过不必要的更新。</span></li></ol><h4 id="pV0fu"><span class="ne-text">Vue 3 的优化</span></h4><ul class="ne-ul"><li id="u55a9c8e5" data-lake-index-type="0"><strong><span class="ne-text">编译阶段优化</span></strong><span class="ne-text">：Vue 3 在模板编译阶段会标记哪些部分是静态的，这样在更新时，Vue 可以直接跳过这些静态部分，进一步提升性能。</span></li><li id="uf013a7c8" data-lake-index-type="0"><strong><span class="ne-text">更轻量的结构</span></strong><span class="ne-text">：Vue 3 引入了 Proxy 和更简洁的响应式系统，使得状态更新过程更高效，和 Diff 算法配合得更好。</span></li></ul><h3 id="E0ZLx"><span class="ne-text">3. </span><strong><span class="ne-text">对比总结</span></strong></h3><table id="Hkfm6" class="ne-table" style="width: 750px"><tbody><tr style="height: 33px"><td width="250"><p id="ue2ab7066" class="ne-p"><span class="ne-text">特性</span></p></td><td width="250"><p id="u7d334a08" class="ne-p"><span class="ne-text">React</span></p></td><td width="250"><p id="ue0e6ae01" class="ne-p"><span class="ne-text">Vue</span></p></td></tr><tr style="height: 33px"><td width="250"><p id="u6ff22eb2" class="ne-p"><span class="ne-text">Diff 核心算法</span></p></td><td width="250"><p id="u30e7d9ea" class="ne-p"><span class="ne-text">O(n) 的 Fiber 架构，按层次比较</span></p></td><td width="250"><p id="ud8bfd42d" class="ne-p"><span class="ne-text">O(n) 的双端比较，使用 snabbdom 的 patch</span></p></td></tr><tr style="height: 33px"><td width="250"><p id="u1098601a" class="ne-p"><span class="ne-text">key 优化</span></p></td><td width="250"><p id="u621b2214" class="ne-p"><span class="ne-text">通过 key 优化列表更新</span></p></td><td width="250"><p id="ua36ba29c" class="ne-p"><span class="ne-text">同样使用 key 来优化列表的节点重用</span></p></td></tr><tr style="height: 33px"><td width="250"><p id="u7bfe3f84" class="ne-p"><span class="ne-text">静态节点优化</span></p></td><td width="250"><p id="u176358ba" class="ne-p"><span class="ne-text">通过 diff 对比逐层更新</span></p></td><td width="250"><p id="uce236f49" class="ne-p"><span class="ne-text">编译时标记静态节点，跳过不必要的更新</span></p></td></tr><tr style="height: 33px"><td width="250"><p id="u043a7ecb" class="ne-p"><span class="ne-text">更新策略</span></p></td><td width="250"><p id="u010ce4f5" class="ne-p"><span class="ne-text">分层比较，不同类型节点直接替换</span></p></td><td width="250"><p id="u5f50c839" class="ne-p"><span class="ne-text">双端比较，动态跳过不必要的更新</span></p></td></tr><tr style="height: 33px"><td width="250"><p id="u02a2a9e7" class="ne-p"><span class="ne-text">性能侧重点</span></p></td><td width="250"><p id="ua1cc5abd" class="ne-p"><span class="ne-text">浅层快速对比，提升性能</span></p></td><td width="250"><p id="ufe6abedc" class="ne-p"><span class="ne-text">通过最小化修改和静态节点优化提升性能</span></p></td></tr></tbody></table><p id="u24a568df" class="ne-p"><span class="ne-text">总结来看，React 和 Vue 都在 Diff 算法中采用了 O(n) 的复杂度优化，不过 React 更关注通过 Fiber 分层进行调和和渲染，而 Vue 则通过双端比较和静态节点优化来提高渲染效率。两者都在不断优化虚拟 DOM 的更新过程，以确保在复杂应用中的性能表现。</span></p></div>]]></content>
    
    
      
      
        
        
    <summary type="html">

&lt;div class=&quot;lake-content&quot; typography=&quot;classic&quot;&gt;&lt;p id=&quot;u0dd4c899&quot; class=&quot;ne-p&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;Vue 和 React 的 diff 算法都是为了解决虚拟 DOM</summary>
        
      
    
    
    
    <category term="Web开发" scheme="https://www.wztlink1013.com/categories/Web%E5%BC%80%E5%8F%91/"/>
    
    <category term="Vue" scheme="https://www.wztlink1013.com/categories/Web%E5%BC%80%E5%8F%91/Vue/"/>
    
    
  </entry>
  
  <entry>
    <title>React函数组件及其相关hooks</title>
    <link href="https://www.wztlink1013.com/blog/heq3u9id8tz3izdu/"/>
    <id>https://www.wztlink1013.com/blog/heq3u9id8tz3izdu/</id>
    <published>2024-10-07T19:53:12.000Z</published>
    <updated>2024-11-19T07:25:00.000Z</updated>
    
    <content type="html"><![CDATA[<div class="lake-content" typography="classic"><blockquote data-type="info" class="ne-alert" style="background-color: rgba(192, 221, 252, 0.5); border: 1px solid transparent; margin: 4px 0px; padding: 10px; border-radius: 4px;"><p id="u09f32c06" class="ne-p"><span class="ne-text">官方文档：</span><a href="https://react.docschina.org/" data-href="https://react.docschina.org/" class="ne-link"><span class="ne-text">React 官方中文文档</span></a></p></blockquote><h2 id="tG6gs"><span class="ne-text">📌</span><span class="ne-text">变量相关</span></h2><h3 id="oCcis"><span class="ne-text">useState</span></h3><p id="u6d0a5e75" class="ne-p"><span class="ne-text">普通定义的变量每次组件渲染都是所定义的值，如果我们需要在每次re-render都记住一个状态的最新值，那就需要使用useState hook</span></p><pre data-language="tsx" id="wHRGw" class="ne-codeblock language-tsx"><code>import &#123; useState &#125; from 'React'const A = () =&gt; &#123;  const [a, setA] = useState('a')  return &lt;div&gt;a value: &#123;a&#125;&lt;/div&gt;&#125;</code></pre><p id="u5c324387" class="ne-p"><span class="ne-text">和类组件的差异</span></p><ol class="ne-ol"><li id="u157ea2c5" data-lake-index-type="0"><span class="ne-text">改变值的时候不会merge，而是覆盖</span></li><li id="ue3b27c3a" data-lake-index-type="0"><span class="ne-text">初始值可以是回调函数，但不能是函数否则每次改变都会重新执行一遍该函数，影响性能</span></li></ol><pre data-language="tsx" id="OAx4j" class="ne-codeblock language-tsx"><code>import &#123; Button &#125; from 'antd';export default () =&gt; &#123;  const [count, setCount] = useState(    [1, 2, 3].reduce((curr, prev) =&gt; &#123;      // eslint-disable-next-line no-param-reassign      curr += prev;      console.info('&gt;&gt;&gt; init run &gt;&gt;&gt;');      return curr;    &#125;, 0),  );  const addCount = () =&gt; &#123;    setCount(count + 1);    setCount(count + 1);    setCount(count + 1);  &#125;;  return (    &lt;div className="p-14"&gt;      &lt;Button onClick=&#123;addCount&#125;&gt;count: &#123;count&#125;&lt;/Button&gt;    &lt;/div&gt;  );&#125;;</code></pre><p id="u0b9fc139" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2024/png/1484158/1722953034766-4c5c7561-a6fb-4398-bdde-348a9afd35bc.png" width="322.72726573234763" id="u5597c488" class="ne-image"><img src="https://cdn.nlark.com/yuque/0/2024/png/1484158/1722953054284-46fa8f0f-97d2-4850-93b0-74fcbad206a2.png" width="173.6363598728969" id="u5d110e01" class="ne-image"></p><ol start="3" class="ne-ol"><li id="ubf97f0c2" data-lake-index-type="0"><span class="ne-text">同样存在批处理</span></li></ol><p id="uea8f40f7" class="ne-p"><span class="ne-text" style="color: #DF2A3F">【useState返回的set函数并不会立刻更新状态值，而是会批量更新，所以在set函数执行后，状态可能还是原始值，需要等到下次render值才会更新，addA结果还是+1】</span></p><pre data-language="tsx" id="NvrAB" class="ne-codeblock language-tsx"><code>import &#123; Button &#125; from 'antd';export default () =&gt; &#123;  const [count, setCount] = useState(0);  const addCount = () =&gt; &#123;    setCount(count + 1);    setCount(count + 1);    setCount(count + 1);  &#125;;  return (    &lt;div className="p-14"&gt;      &lt;Button onClick=&#123;addCount&#125;&gt;count: &#123;count&#125;&lt;/Button&gt;    &lt;/div&gt;  );&#125;;</code></pre><p id="ua30641ec" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2024/gif/1484158/1722952555120-5cf64dda-d4b5-4d93-89cb-fb970a40b91a.gif" width="502" id="u459444e4" class="ne-image"></p><ol start="4" class="ne-ol"><li id="u832252b4" data-lake-index-type="0"><span class="ne-text" style="color: #DF2A3F">传入的是值，渲染前会存在覆盖情况，如果传入的是函数，则会保留上一次的状态值计算</span></li></ol><pre data-language="tsx" id="IEUTD" class="ne-codeblock language-tsx"><code>import &#123; Button &#125; from 'antd';export default () =&gt; &#123;  const [count, setCount] = useState(0);  const addCount = () =&gt; &#123;    setCount(count =&gt; count + 1);    setCount(count =&gt; count + 1);    setCount(count =&gt; count + 1);  &#125;;  return (    &lt;div className="p-14"&gt;      &lt;Button onClick=&#123;addCount&#125;&gt;count: &#123;count&#125;&lt;/Button&gt;    &lt;/div&gt;  );&#125;;</code></pre><p id="u1bb563d3" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2024/gif/1484158/1722953158493-00240227-da21-4d58-b84f-29005d53a940.gif" width="502" id="u453f8617" class="ne-image"></p><h3 id="FkFb5"><span class="ne-text">useRef和forwardRef</span></h3><p id="u9b795523" class="ne-p"><span class="ne-text">文档：</span><a href="https://zh-hans.react.dev/learn/escape-hatches" data-href="https://zh-hans.react.dev/learn/escape-hatches" class="ne-link"><span class="ne-text">脱围机制 – React 中文文档</span></a></p><h4 id="U3X7l"><span class="ne-text">模拟生命周期/缓存变量</span></h4><p id="u7d672ec7" class="ne-p"><span class="ne-text">利用useRef创建的普通变量，可以具备“</span><strong><span class="ne-text">记忆</span></strong><span class="ne-text">”功能，类似于类的实例属性。利用这一点可以设置一个flag来实现组件</span><span class="ne-text" style="color: #DF2A3F">仅更新时触发的代码执行时机（所定义的变量与UI无关）</span></p><pre data-language="tsx" id="DDbbD" class="ne-codeblock language-tsx"><code>import &#123; Button &#125; from 'antd';export default () =&gt; &#123;  const [count, setCount] = useState(0);  const flag = useRef(false);  useEffect(() =&gt; &#123;    if (flag.current) &#123;      console.info('&gt;&gt;&gt; only update &gt;&gt;&gt;');    &#125;  &#125;, [count]);  const addCount = () =&gt; &#123;    setCount(count =&gt; count + 1);    setCount(count =&gt; count + 1);    setCount(count =&gt; count + 1);    flag.current = true;  &#125;;  return (    &lt;div className="p-14 text-right"&gt;      &lt;Button onClick=&#123;addCount&#125;&gt;count: &#123;count&#125;&lt;/Button&gt;    &lt;/div&gt;  );&#125;;</code></pre><p id="u8159526a" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2024/gif/1484158/1722953544781-cbbe70d4-990d-4eef-8baf-dab93a0d6c82.gif" width="606" id="sRmeX" class="ne-image"></p><h4 id="qeIFW"><span class="ne-text">作用在DOM上</span></h4><p id="ua4b76358" class="ne-p"><span class="ne-text">且为useRef函数，则为带有键为current值为DOM本身的对象</span></p><div class="ne-quote"><p id="u8bdc72f1" class="ne-p"><span class="ne-text">也可以作用在DOM上的一个函数</span></p></div><pre data-language="tsx" id="B7fJl" class="ne-codeblock language-tsx"><code>import &#123; Button &#125; from 'antd';export default () =&gt; &#123;  const btn = useRef(null);  return (    &lt;div className="p-14 text-right"&gt;      &lt;Button        onClick=&#123;() =&gt; &#123;          console.log(btn);        &#125;&#125;      &gt;        &lt;button ref=&#123;btn&#125;&gt;+++&lt;/button&gt;      &lt;/Button&gt;    &lt;/div&gt;  );&#125;;</code></pre><p id="u9bc2f0f3" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2024/gif/1484158/1722953901046-07727d18-605a-439f-8013-c3e9a145206a.gif" width="606" id="ud5fcd269" class="ne-image"></p><h4 id="NsV5T"><span class="ne-text">作用在组件上</span></h4><p id="u7d6cdc8c" class="ne-p"><span class="ne-text">useRef不可以作用在组件上，但是子组件有React.forwardRef（组件转发）可以</span></p><div class="ne-quote"><p id="u74205b6f" class="ne-p"><a href="https://zh-hans.react.dev/learn/manipulating-the-dom-with-refs#accessing-another-components-dom-nodes" data-href="https://zh-hans.react.dev/learn/manipulating-the-dom-with-refs#accessing-another-components-dom-nodes" class="ne-link"><span class="ne-text">使用 ref 操作 DOM – React 中文文档</span></a></p></div><pre data-language="tsx" id="ACuZT" class="ne-codeblock language-tsx"><code>import &#123; useRef &#125; from 'React'const Son = React.forwardRef((props, ref) =&gt; &#123;  return &lt;div&gt;&lt;input type="text" ref=&#123;ref&#125; /&gt;&lt;/div&gt;&#125;)const A = () =&gt; &#123;  const obj = useRef()  // obj =&gt; &#123; current: inputDOM &#125;  return &lt;Son ref=&#123;obj&#125; /&gt;&#125;</code></pre><h4 id="fze30"><span class="ne-text">useImperativeHandle</span></h4><blockquote data-type="info" class="ne-alert" style="background-color: rgba(192, 221, 252, 0.5); border: 1px solid transparent; margin: 4px 0px; padding: 10px; border-radius: 4px;"><p id="u95428e1b" class="ne-p"><span class="ne-text">传递多个ref可以使用useImperativeHandle</span></p></blockquote><p id="u8a9a358e" class="ne-p"><strong><span class="ne-text">父组件：</span></strong></p><p id="ub86ad3f5" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2024/png/1484158/1728359332696-d91f61e4-679d-49a4-ae46-d2091cc590af.png" width="315" id="ub9408f4c" class="ne-image"></p><p id="uf7663504" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2024/png/1484158/1728359286923-4942332f-562b-4536-b122-9241e0f88457.png" width="809" id="ue1dcb0e5" class="ne-image"></p><p id="u054e7213" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2024/png/1484158/1728359313668-6b32e40e-29ea-4c90-9693-bc7c084d4e90.png" width="448" id="u747e696b" class="ne-image"></p><p id="u790cdb3d" class="ne-p"><strong><span class="ne-text">子组件：</span></strong></p><p id="ubfd2e2bc" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2024/png/1484158/1728359321316-f443c580-71f2-4b85-ab41-2a610173ab61.png" width="447" id="u263334cf" class="ne-image"></p><h2 id="a8K2t"><span class="ne-text">💥</span><span class="ne-text">副作用相关</span></h2><h3 id="Vitaw"><span class="ne-text">useEffect</span></h3><p id="uc0c75b9d" class="ne-p"><span class="ne-text">渲染完成再执行</span></p><ol class="ne-ol"><li id="u28b6342c" data-lake-index-type="0"><span class="ne-text">模拟各个生命周期的执行时机</span></li></ol><pre data-language="tsx" id="kODBQ" class="ne-codeblock language-tsx"><code>import &#123; Button &#125; from 'antd';export default () =&gt; &#123;  const [count, setCount] = useState(0);  useEffect(() =&gt; &#123;    console.log('&gt;&gt;&gt; mount or update &gt;&gt;&gt;');    return () =&gt; &#123;      console.log('&gt;&gt;&gt; unmount or before update &gt;&gt;&gt;');    &#125;;  &#125;, [count]);  const addCount = () =&gt; &#123;    setCount(count =&gt; count + 1);    setCount(count =&gt; count + 1);    setCount(count =&gt; count + 1);  &#125;;  return (    &lt;div className="p-14 text-right"&gt;      &lt;Button onClick=&#123;addCount&#125;&gt;count: &#123;count&#125;&lt;/Button&gt;    &lt;/div&gt;  );&#125;;</code></pre><p id="u3521ec46" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2024/gif/1484158/1722954439473-5fa2ff19-ec35-423c-a971-9770fa0c3630.gif" width="606" id="u2299f624" class="ne-image"></p><ol start="2" class="ne-ol"><li id="u8886765a" data-lake-index-type="0"><span class="ne-text">关于第二个数组参数</span></li></ol><ol class="ne-list-wrap"><ol ne-level="1" class="ne-ol"><li id="u29eccab1" data-lake-index-type="0"><span class="ne-text">如果不设置，那么在update时期都会执行</span></li><li id="uaa101652" data-lake-index-type="0"><span class="ne-text">如果设置空数组（且回调函数中没有响应式变量），则只在mount时期执行一次</span></li><li id="u54d7662f" data-lake-index-type="0"><span class="ne-text">如果useEffect回调函数中存在响应式变量，那么第二个参数数组中应当有该响应式变量</span></li></ol></ol><h3 id="tIaOs"><span class="ne-text">useLayoutEffect</span></h3><ul class="ne-ul"><li id="uced42dc0" data-lake-index-type="0"><span class="ne-text">useEffect：渲染并绘制到屏幕之后执行，异步</span></li><li id="uec771d52" data-lake-index-type="0"><span class="ne-text">useLayoutEffect：</span><span class="ne-text" style="color: #DF2A3F">渲染之后，但绘制到屏幕之前执行，同步</span></li><li id="u35d81fb4" data-lake-index-type="0"><span class="ne-text" style="color: #DF2A3F">一般如果回调函数中有DOM的相关操作并且会改变样式，用后者，避免DOM渲染闪屏/白屏，但前者性能方面更好</span></li></ul><h1 id="civf8"><span class="ne-text">✨</span><span class="ne-text">渲染优化</span></h1><p id="u55cea460" class="ne-p"><span class="ne-text">首先明确react组件重渲染的触发条件：</span></p><ol class="ne-ol"><li id="u6632789a" data-lake-index-type="0"><span class="ne-text">props或者state发生改变触发组件重渲染</span></li><li id="udd834e06" data-lake-index-type="0"><span class="ne-text">父组件的重渲染触发子组件的重渲染</span></li></ol><p id="u81cee48c" class="ne-p"><span class="ne-text">参考：</span></p><ul class="ne-ul"><li id="u4f49a05e" data-lake-index-type="0"><a href="https://fe.azhubaby.com/React/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96.html" data-href="https://fe.azhubaby.com/React/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96.html" class="ne-link"><span class="ne-text">五年前端三年面试 - Johnny 的前端知识地图</span></a></li><li id="u30beddec" data-lake-index-type="0"><a href="https://juejin.cn/post/6935584878071119885" data-href="https://juejin.cn/post/6935584878071119885" class="ne-link"><span class="ne-text">React 性能优化 | 包括原理、技巧、Demo、工具使用</span></a></li></ul><h2 id="y0AhM"><span class="ne-text">1 [非渲染层面] 组件结构设计</span></h2><h3 id="OOZwL"><span class="ne-text">分离组件和状态</span></h3><ul class="ne-ul"><li id="u24265b51" data-lake-index-type="0"><strong><span class="ne-text">拆分组件</span></strong><span class="ne-text">：将大组件拆分成多个小组件，每个小组件只关注自己需要的状态。这可以减少状态变化时影响的范围，避免整个大组件的重新渲染。</span></li><li id="ub346b3e2" data-lake-index-type="0"><strong><span class="ne-text">提升状态</span></strong><span class="ne-text">：如果多个组件共享同一份状态，可以考虑将状态提升到它们的共同祖先组件，然后通过 props 传递状态。</span></li></ul><h3 id="fzXsa"><span class="ne-text">使用条件渲染</span></h3><p id="u362a592d" class="ne-p"><code class="ne-code"><span class="ne-text">&#123;msg &amp;&amp; (&lt;Child msg=&#123;msg&#125; onClick=&#123;onChildClick&#125; /&gt;)&#125;</span></code></p><h3 id="u9hP9"><span class="ne-text">使用 Fragment 减少不必要的 DOM 节点</span></h3><h3 id="BdJyp"><span class="ne-text">lazy（API）Suspense（API）</span></h3><p id="u97d3662a" class="ne-p"><span class="ne-text">当模块化引入（import）组件，但在实际代码中未使用到，代码内部逻辑仍会执行，这个时候可以利用lazy使组件异步化加载，从而达到性能优化效果</span></p><pre data-language="tsx" id="SPcmc" class="ne-codeblock language-tsx"><code>import &#123; lazy &#125; from 'react';const AuthRoute = lazy(() =&gt; import('./AuthRoute'));const ErrorPage = lazy(() =&gt; import('@/components/ErrorBoundary'));const NotFound = lazy(() =&gt; import('@/pages/404'));</code></pre><p id="u58cf40e3" class="ne-p"><span class="ne-text">Suspense则作为中间过渡态</span></p><h3 id="LaG9J"><span class="ne-text">开发者工具分析</span></h3><h4 id="o1klT"><span class="ne-text">Profiler标签</span></h4><ul class="ne-ul"><li id="u096a476a" data-lake-index-type="0"><span class="ne-text">使用 React 开发者工具的 “Profiler” 标签来分析组件的渲染次数和性能瓶颈，进而优化代码。</span></li></ul><pre data-language="typescript" id="JHXqX" class="ne-codeblock language-typescript"><code>const onRenderCallback = (  id: string,  phase: string,  actualDuration: number,  baseDuration: number,  startTime: number,  commitTime: number,) =&gt; &#123;  console.log(&#123; id, phase, actualDuration, baseDuration, startTime, commitTime &#125;);&#125;;</code></pre><pre data-language="tsx" id="UaeTD" class="ne-codeblock language-tsx"><code>&lt;Profiler id="App" onRender=&#123;onRenderCallback&#125;&gt;  &lt;div style=&#123;&#123;  marginTop: '200px',  textAlign: 'right'&#125;&#125;&gt;    &lt;button onClick=&#123;onAppClick&#125;&gt;      count is &#123;count&#125;    &lt;/button&gt;    &#123;msg &amp;&amp; (  &lt;Suspense fallback=&#123;&lt;div&gt;Loading...&lt;/div&gt;&#125;&gt;    &lt;Child msg=&#123;msg&#125; onClick=&#123;onChildClick&#125; /&gt;  &lt;/Suspense&gt;)&#125;  &lt;/div&gt;&lt;/Profiler&gt;</code></pre><h2 id="j8Zrq"><span class="ne-text">2 [render阶段] 跳过不必要的组件更新</span></h2><h3 id="mP7zV"><span class="ne-text">memo优化子组件</span></h3><p id="u37eebeeb" class="ne-p"><span class="ne-text">未使用memo的渲染, 当父组件重新渲染，即使子组件未发生变化, 子组件也会重新渲染</span></p><pre data-language="tsx" id="Uol8q" class="ne-codeblock language-tsx"><code>import &#123; Button &#125; from 'antd';const Child = () =&gt; &#123;  console.log('&gt;&gt;&gt; child component render &gt;&gt;&gt;');  return &lt;div&gt;child component&lt;/div&gt;;&#125;;export default () =&gt; &#123;  const [count, setCount] = useState(0);  const addCount = () =&gt; &#123;    setCount(count =&gt; count + 1);    setCount(count =&gt; count + 1);    setCount(count =&gt; count + 1);  &#125;;  return (    &lt;div className="p-14 text-right"&gt;      &lt;Button onClick=&#123;addCount&#125;&gt;count: &#123;count&#125;&lt;/Button&gt;      &lt;Child /&gt;    &lt;/div&gt;  );&#125;;</code></pre><p id="u6e4b1ff5" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2024/gif/1484158/1722955261333-678efd2a-dc1d-453f-b284-c449cdefaa3c.gif" width="606" id="u1aeb3c6d" class="ne-image"></p><p id="u8f7f8983" class="ne-p"><span class="ne-text">memo类似类组件中的</span><code class="ne-code"><span class="ne-text">PureComponent</span></code><span class="ne-text">性能优化组件</span></p><ol class="ne-ol"><li id="u69dda7d6" data-lake-index-type="0"><span class="ne-text" style="color: #DF2A3F">对传入的 props 进行浅比较，如果 props 没有变化，则不会重新渲染组件</span></li><li id="u993d2be2" data-lake-index-type="0"><span class="ne-text">函数组件中当响应变量的值没有发生改变，不会重新渲染，和类组件不一样</span></li><li id="u110c7560" data-lake-index-type="0"><span class="ne-text">当组件的值发生改变才进行render，反之不进行render</span></li></ol><pre data-language="tsx" id="QmU14" class="ne-codeblock language-tsx"><code>import &#123; Button &#125; from 'antd';const Child = memo((props: any) =&gt; &#123;  console.log('&gt;&gt;&gt; child component render &gt;&gt;&gt;');  return &lt;div&gt;child component &#123;props.child&#125;&lt;/div&gt;;&#125;);export default () =&gt; &#123;  const [count, setCount] = useState(0);  const [child, setChild] = useState(0);  const addCount = () =&gt; &#123;    setCount(count =&gt; count + 1);    setCount(count =&gt; count + 1);    setCount(count =&gt; count + 1);  &#125;;  return (    &lt;div className="p-14 text-right"&gt;      &lt;Button onClick=&#123;addCount&#125;&gt;not change: &#123;count&#125;&lt;/Button&gt;      &lt;Button        onClick=&#123;() =&gt; &#123;          setChild(child =&gt; child + 1);        &#125;&#125;      &gt;        change: &#123;child&#125;      &lt;/Button&gt;      &lt;Child child=&#123;child&#125; /&gt;    &lt;/div&gt;  );&#125;;</code></pre><p id="uadfcf1b0" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2024/gif/1484158/1722955626527-53f742ae-2a86-4f79-b54c-15b7511f4eb7.gif" width="606" id="u1fbd8dee" class="ne-image"></p><h3 id="j6mrP"><span class="ne-text">避免匿名函数和对象的重新创建</span></h3><pre data-language="tsx" id="evZDX" class="ne-codeblock language-tsx"><code>import React, &#123; useState &#125; from 'react'const Child = React.memo((props?: &#123;  msg?: string  onClick?: () =&gt; void&#125;) =&gt; &#123;  console.info('[child render]')  return (    &lt;div&gt;      &#123;props?.msg || 'child default msg value'&#125;    &lt;/div&gt;  )&#125;)function App() &#123;  console.info('[App render]')  const [count, setCount] = useState(0);  const [msg, setMsg] = useState('hello');  return (      &lt;div style=&#123;&#123;        marginTop: '200px',        textAlign: 'right'      &#125;&#125;&gt;        &lt;button onClick=&#123;() =&gt; setCount((count) =&gt; count + 1)&#125;&gt;          count is &#123;count&#125;        &lt;/button&gt;        &lt;Child msg=&#123;msg&#125; onClick=&#123;() =&gt; console.log('test lambda function rerender too.')&#125; /&gt;      &lt;/div&gt;  )&#125;export default App</code></pre><p id="ua34a7728" class="ne-p"><span class="ne-text">比如这种情况即便Child组件用了memo，但是每次App重新渲染，Child也会跟着重新渲染。因为匿名函数的引用发生了变化</span></p><pre data-language="plain" id="DMc9t" class="ne-codeblock language-plain"><code>[App render][child render]</code></pre><h4 id="KdxTg"><span class="ne-text">为什么要避免匿名函数和对象？</span></h4><p id="u0886cb58" class="ne-p"><span class="ne-text">每次组件重新渲染时，</span><span class="ne-text" style="text-decoration: underline">JavaScript 会重新创建这些匿名函数和对象</span><span class="ne-text">。这些新创建的函数和对象在内存中是不同的，即使它们的内容相同。这会导致以下问题：</span></p><ol class="ne-ol"><li id="u15bbe06f" data-lake-index-type="0"><strong><span class="ne-text">导致子组件不必要的重新渲染</span></strong><span class="ne-text">： 当子组件接收到新的匿名函数或对象作为 props 时，即使这些 props 的内容没有变化，React 仍然认为这些 props 发生了变化，因为它们是新的引用，进而导致子组件重新渲染。</span></li><li id="u375b5b37" data-lake-index-type="0"><strong><span class="ne-text">性能问题</span></strong><span class="ne-text">： 频繁创建新的函数和对象会增加内存使用和垃圾回收的负担，尤其是在组件频繁更新的情况下，这会对性能产生负面影响。</span></li></ol><h3 id="Nmukg"><span class="ne-text">useMemo和useCallback</span></h3><p id="u146035fb" class="ne-p"><span class="ne-text">React函数式组件在重新渲染时候，代码执行会将函数体重新执行，即便结果不是重新更新DOM。如果函数体的代码逻辑复杂会带来不小的性能损耗，如果能够对这过程中的部分“量”进行“记忆”，则会较大提升性能。</span></p><p id="u89b5266b" class="ne-p"><span class="ne-text">响应式变量内部会自动进行记忆，但是如果是非响应式变量，比如一个对象或是一个函数传入组件，这其实也是改变了的，原因是对象的引用改变，依然会引起DOM的重新渲染，而利用useMemo或是useCallback创建的对象（对象、数组、函数）则会保留记忆功能。</span></p><h4 id="IzAwu"><span class="ne-text" style="color: #DF2A3F">useCallback</span></h4><p id="uaccf8151" class="ne-p"><span class="ne-text">useCallback 缓存函数</span></p><p id="u9f6987fa" class="ne-p"><span class="ne-text">未使用前</span></p><pre data-language="tsx" id="uA0FL" class="ne-codeblock language-tsx"><code>import &#123; Button &#125; from 'antd';const Child = memo((props: any) =&gt; &#123;  console.log('&gt;&gt;&gt; child component render &gt;&gt;&gt;');  return &lt;div&gt;child component &#123;props.child&#125;&lt;/div&gt;;&#125;);export default () =&gt; &#123;  const [count, setCount] = useState(0);  const [child, setChild] = useState(0);  const addCount = () =&gt; &#123;    setCount(count =&gt; count + 1);    setCount(count =&gt; count + 1);    setCount(count =&gt; count + 1);  &#125;;  const changeChild = () =&gt; &#123;    setChild(child =&gt; child + 1);  &#125;;  return (    &lt;div className="p-14 text-right"&gt;      &lt;Button onClick=&#123;addCount&#125;&gt;parent count: &#123;count&#125;&lt;/Button&gt;      &lt;Child child=&#123;child&#125; click=&#123;changeChild&#125; /&gt;    &lt;/div&gt;  );&#125;;</code></pre><p id="ud6102f84" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2024/gif/1484158/1722957686616-b1556796-d66a-4c53-874f-35d0fb3231ed.gif" width="606" id="ub823e853" class="ne-image"></p><p id="u86342f12" class="ne-p"><span class="ne-text">使用后</span></p><pre data-language="tsx" id="MD10Y" class="ne-codeblock language-tsx"><code>import &#123; Button &#125; from 'antd';const Child = memo((props: any) =&gt; &#123;  console.log('&gt;&gt;&gt; child component render &gt;&gt;&gt;');  return &lt;div&gt;child component &#123;props.child&#125;&lt;/div&gt;;&#125;);export default () =&gt; &#123;  const [count, setCount] = useState(0);  const [child, setChild] = useState(0);  const addCount = () =&gt; &#123;    setCount(count =&gt; count + 1);    setCount(count =&gt; count + 1);    setCount(count =&gt; count + 1);  &#125;;  const changeChild = useCallback(() =&gt; &#123;    setChild(child =&gt; child + 1);  &#125;, []);  return (    &lt;div className="p-14 text-right"&gt;      &lt;Button onClick=&#123;addCount&#125;&gt;parent count: &#123;count&#125;&lt;/Button&gt;      &lt;Child child=&#123;child&#125; click=&#123;changeChild&#125; /&gt;    &lt;/div&gt;  );&#125;;</code></pre><p id="u88a27b39" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2024/gif/1484158/1722957793630-76dbba53-8e2e-47bc-be4e-e6b43747c67f.gif" width="606" id="u416d0989" class="ne-image"></p><h4 id="p7jw0"><span class="ne-text" style="color: #DF2A3F">useMemo</span></h4><p id="u6522a270" class="ne-p"><span class="ne-text">useMemo 缓存（复杂）值</span></p><p id="ua8e6cbf9" class="ne-p"><span class="ne-text">传入一个必须带有返回值的函数</span></p><pre data-language="tsx" id="vxFRC" class="ne-codeblock language-tsx"><code>import &#123; Button &#125; from 'antd';const Child = memo((props: any) =&gt; &#123;  const sum = useMemo(    () =&gt;      [1, 2, 3, 4, 5, 6, 7, 8, 9, 10].reduce((acc, cur) =&gt; &#123;        // eslint-disable-next-line no-param-reassign        acc += cur;        console.info('&gt;&gt;&gt; calculate sum &gt;&gt;&gt;');        return acc;      &#125;, 0),    [],  );  console.log('&gt;&gt;&gt; child component render &gt;&gt;&gt;', sum);  return &lt;div&gt;child component &#123;props.child&#125;&lt;/div&gt;;&#125;);export default () =&gt; &#123;  const [count, setCount] = useState(0);  const [child, setChild] = useState(0);  const addCount = () =&gt; &#123;    setCount(count =&gt; count + 1);    setCount(count =&gt; count + 1);    setCount(count =&gt; count + 1);  &#125;;  return (    &lt;div className="p-14 text-right"&gt;      &lt;Button onClick=&#123;addCount&#125;&gt;not change: &#123;count&#125;&lt;/Button&gt;      &lt;Button        onClick=&#123;() =&gt; &#123;          setChild(child =&gt; child + 1);        &#125;&#125;      &gt;        change: &#123;child&#125;      &lt;/Button&gt;      &lt;Child child=&#123;child&#125; /&gt;    &lt;/div&gt;  );&#125;;</code></pre><p id="u12e02f70" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2024/gif/1484158/1722957265079-bfac1074-653e-45de-b1d1-515e844a8fa3.gif" width="606" id="uc653f80f" class="ne-image"></p><p id="u759c1e0d" class="ne-p"><span class="ne-text">如果不使用useMemo，那么每次child渲染都会执行一遍sum的计算函数，也就是多了十次calculate sum打印</span></p><ol class="ne-ol"><li id="u18b45d54" data-lake-index-type="0"><span class="ne-text">两者的第二个参数都是依赖数组，同useEffect</span></li></ol><pre data-language="tsx" id="HiqQ8" class="ne-codeblock language-tsx"><code>import &#123; useCallback, useMemo &#125; from 'React'const A = () =&gt; &#123;  // 1. every render -&gt; run  const fun = () =&gt; &#123;&#125;  // 2. useCallback (ignore const error...)  const fun = useCallback(() =&gt; &#123;&#125;, [])  // 3. useMemo (ignore const error...)  const fun = useMemo(() =&gt; () =&gt; &#123;&#125;, [])  const a = useMemo(() =&gt; [1, 2, 3], [])    return &lt;div onClick=&#123;fun&#125; a=&#123;a&#125;&gt;&lt;/div&gt;&#125;</code></pre><h2 id="QPxQG"><span class="ne-text">3 [commit阶段] 减少提交耗时</span></h2><h3 id="lF7Xw"><span class="ne-text">批量状态更新</span></h3><p id="u1ad1a4d7" class="ne-p"><span class="ne-text">批量更新是指 React 将多次 state 更新进行合并处理，最终只进行一次渲染，以获得更好的性能。</span></p><p id="u808cbbe9" class="ne-p"><span class="ne-text">例如，如果在同一个点击事件中有两个状态更新，React 总是会把它们批量处理成一个重新渲染。</span></p><p id="ubea297dc" class="ne-p"><span class="ne-text" style="text-decoration: underline">从 React 18 的 createRoot 开始，不论在哪里， 所有更新都将自动进行批量更新。</span></p><p id="u0c808730" class="ne-p"><span class="ne-text">这意味着 setTimeout、promises、原生事件处理函数或其他任何事件的批量更新都将与 React 事件一样，以相同的方式进行批量更新。</span></p><p id="uec0fa77e" class="ne-p"><span class="ne-text">比如下面这个组件，在React 18之前会渲染两次，但是React 18可以自动批处理</span></p><pre data-language="tsx" id="nYvKn" class="ne-codeblock language-tsx"><code>function App() &#123;  console.info('[App render]')  const [count, setCount] = useState(0);  const [msg, setMsg] = useState('hello');  const onChildClick = useCallback(() =&gt; &#123;    console.log('test lambda function rerender too.')  &#125;, [])  const onAppClick = () =&gt; &#123;    fetch(`https://api.github.com/repos/vuejs/core/commits?per_page=3&amp;sha=main`)    .then(res =&gt; res.json())    .then(data =&gt; &#123;      console.info('&gt;&gt;&gt; fetch data &gt;&gt;&gt;', data)      setCount((count) =&gt; count + 1)      setMsg('hello world')    &#125;)  &#125;  return (      &lt;div style=&#123;&#123;        marginTop: '200px',        textAlign: 'right'      &#125;&#125;&gt;        &lt;button onClick=&#123;onAppClick&#125;&gt;          count is &#123;count&#125;        &lt;/button&gt;        &#123;msg &amp;&amp; (&lt;Child msg=&#123;msg&#125; onClick=&#123;onChildClick&#125; /&gt;)&#125;      &lt;/div&gt;  )&#125;</code></pre><p id="u9183faf6" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2024/gif/1484158/1724210023557-19c1854b-9368-476e-8932-c1c163e4131b.gif" width="601" id="ud36afdbe" class="ne-image"></p><p id="u8d014e2b" class="ne-p"><span class="ne-text">如果想取消批处理</span></p><pre data-language="tsx" id="mwpjO" class="ne-codeblock language-tsx"><code>function App() &#123;  console.info('[App render]')  const [count, setCount] = useState(0);  const [msg, setMsg] = useState('hello');  const onChildClick = useCallback(() =&gt; &#123;    console.log('test lambda function rerender too.')  &#125;, [])  const onAppClick = () =&gt; &#123;    fetch(`https://api.github.com/repos/vuejs/core/commits?per_page=3&amp;sha=main`)    .then(res =&gt; res.json())    .then(data =&gt; &#123;      console.info('&gt;&gt;&gt; fetch data &gt;&gt;&gt;', data)      flushSync(() =&gt; &#123;        setCount((count) =&gt; count + 1)      &#125;);      flushSync(() =&gt; &#123;        setMsg('hello world')      &#125;);    &#125;)  &#125;  return (      &lt;div style=&#123;&#123;        marginTop: '200px',        textAlign: 'right'      &#125;&#125;&gt;        &lt;button onClick=&#123;onAppClick&#125;&gt;          count is &#123;count&#125;        &lt;/button&gt;        &#123;msg &amp;&amp; (&lt;Child msg=&#123;msg&#125; onClick=&#123;onChildClick&#125; /&gt;)&#125;      &lt;/div&gt;  )&#125;</code></pre><p id="u3fea0a7e" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2024/gif/1484158/1724210142265-f1d60b88-97ee-4dcd-91d9-47115ab86615.gif" width="601" id="u16daebe5" class="ne-image"></p><p id="uc949ada4" class="ne-p"><span class="ne-text">可以看到多执行了一次</span><code class="ne-code"><span class="ne-text">[App render]</span></code></p><p id="ubdf78d0c" class="ne-p"><a href="https://juejin.cn/post/6982433531792195621" data-href="https://juejin.cn/post/6982433531792195621" target="_blank" class="ne-link"><span class="ne-text">https://juejin.cn/post/6982433531792195621</span></a></p><h3 id="jMG4f"><span class="ne-text">避免不必要的 Context 重新渲染</span></h3><ul class="ne-ul"><li id="ufdd1ae4f" data-lake-index-type="0"><span class="ne-text">Context 是非常强大的工具，但不慎使用可能导致不必要的重新渲染。将 Context 提供者尽量拆分成多个小的上下文，或者在必要时使用 </span><code class="ne-code"><span class="ne-text">useMemo</span></code><span class="ne-text"> 缓存 Context 值。</span></li></ul><pre data-language="tsx" id="hyKWK" class="ne-codeblock language-tsx"><code>const value = useMemo(() =&gt; (&#123; state, dispatch &#125;), [state, dispatch]);return (  &lt;MyContext.Provider value=&#123;value&#125;&gt;    &#123;children&#125;  &lt;/MyContext.Provider&gt;);</code></pre><p id="ua33b3b17" class="ne-p"><br></p><h1 id="aqLAy"><span class="ne-text">🎈</span><span class="ne-text">其他Hooks</span></h1><h3 id="sJ7E2"><span class="ne-text">useContext和createContext（API）</span></h3><p id="u0ab2b1cf" class="ne-p"><span class="ne-text">跨组件通信</span></p><pre data-language="tsx" id="WFHKk" class="ne-codeblock language-tsx"><code>import &#123; useContext, createContext &#125; from 'React'// not Provider value -&gt; render default valueconst C = createContext('default value...')const GSon = () =&gt; &#123;  const value = useContext(C)  // value -&gt; something...  return &lt;div&gt;GSon template...&lt;/div&gt;&#125;const Son = () =&gt; &#123;  return &lt;GSon /&gt;&#125;const A = () =&gt; &#123;  return (    &lt;C.Provider value='something...'&gt;    &lt;Son ref=&#123;obj&#125; /&gt;    &lt;/C.Provider&gt;  )&#125;</code></pre><h3 id="ejO8u"><span class="ne-text">useReducer</span></h3><p id="u76ab5b03" class="ne-p"><span class="ne-text">管理多个有关联的响应式变量</span></p><pre data-language="tsx" id="DGPnc" class="ne-codeblock language-tsx"><code>import &#123; useReducer &#125; from 'Reactconst loginState = &#123; isLogin: true, isLogout: false &#125;const loginReducer = (state, action) =&gt; &#123;  switch(action.type) &#123;    case 'login':      return &#123; isLogin: true, isLogout: false &#125;    case 'logout':      return &#123; isLogin: false, isLogout: true &#125;    default:      return new Error()  &#125;&#125;const A = () =&gt; &#123;  const [state, LoginDispatch] = useReducer(loginReducer, loginState)  const clickEvent = () =&gt; &#123;    loginDispatch(&#123; type: state.isLogin ? 'logout' : 'login' &#125;)   &#125;  return (    &lt;button onClick=&#123;clickEvent&#125;&gt;&#123;state.isLogin ? 'login', 'logout'&#125;&lt;/button&gt;  )&#125;</code></pre><h3 id="KY90y"><span class="ne-text">并发模式</span></h3><ol class="ne-ol"><li id="uf47bf115" data-lake-index-type="0"><span class="ne-text">React18之前，渲染是一个单一的、不间断的、同步的事务，一旦渲染开始，就不能被中断</span></li><li id="ufee7a81a" data-lake-index-type="0"><span class="ne-text">React18引入并发模式，它允许你将更新作为一个transitions，这会告诉React他们可以被中断执行。这样可以把紧急的任务先更新你，不紧急的任务后更新</span></li></ol><h3 id="JrEY1"><span class="ne-text">startTransition（API）</span></h3><pre data-language="tsx" id="mCdB8" class="ne-codeblock language-tsx"><code>import &#123; startTransition &#125; from 'React'const A = () =&gt; &#123;  ...  const fun = () =&gt; &#123;    // 紧急任务    setA('')    // 不紧急任务（将内部的任何非紧急状态更新标记为 Transition）    startTransition(() =&gt; setB(''))  &#125;  return &lt;div&gt;&lt;/div&gt;&#125;</code></pre><h3 id="J0AC9"><span class="ne-text">useTransition和useDeferredValue</span></h3><ol class="ne-ol"><li id="ubb651c66" data-lake-index-type="0"><span class="ne-text">useTransition返回一个状态值表示过渡任务的等待状态，以及一个启动该过渡任务的函数</span></li></ol><pre data-language="tsx" id="BihZN" class="ne-codeblock language-tsx"><code>import &#123; useTransition &#125; from 'React'const A = () =&gt; &#123;  ...  const [pending, startTransition] = useTransition()  const fun = () =&gt; &#123;    // 紧急任务    setA('')    // 不紧急任务（将内部的任何非紧急状态更新标记为 Transition）    startTransition(() =&gt; setB(''))  &#125;  return &lt;div&gt;&lt;/div&gt;&#125;</code></pre><ol start="2" class="ne-ol"><li id="u279291ea" data-lake-index-type="0"><span class="ne-text">useDeferredValue接受一个值，并返回该值的新副本，该副本将推迟到更紧急地更新之后</span></li></ol><pre data-language="tsx" id="wpppu" class="ne-codeblock language-tsx"><code>import &#123; useDeferredValue, useState &#125; from 'React'const A = () =&gt; &#123;  const [a, setA] = useState('')  // aD =&gt; 不紧急时候的值（同a），也就是延迟之后的值  const aD = useDeferredValue(a)  ...  return &lt;div&gt;&lt;/div&gt;&#125;</code></pre><h3 id="e3VEY"><span class="ne-text">自定义hook</span></h3><ol class="ne-ol"><li id="ue75e76dd" data-lake-index-type="0"><span class="ne-text">命名通常使用use开头</span></li><li id="u2bce0e3e" data-lake-index-type="0"><span class="ne-text">eg：</span></li></ol><pre data-language="tsx" id="bzPAC" class="ne-codeblock language-tsx"><code>import &#123; useState, useEffect &#125; from 'React'const useMouseXY = () =&gt; &#123;  const [x, setX] = usestate(0)  const [y, setY] = usestate(0)  useEffect(() =&gt; &#123;    function move(e) &#123;      setX(e.pageX)      setY(e.pageY)    &#125;    document.addEventListener('mousemove', move)    return () =&gt; document.removeEventListener('mousemove', move)  &#125;, [])    return &#123; x, y &#125;&#125;// use const &#123; x, y &#125; = useMouseXY()</code></pre><h3 id="l7U2I"><span class="ne-text">Suspense</span></h3><p id="ueed27788" class="ne-p"><span class="ne-text">组件加载中或是切换过程中的“中间态”</span></p><pre data-language="tsx" id="A9bB5" class="ne-codeblock language-tsx"><code>import &#123; Suspense, useState &#125; from 'react';import &#123; RouterProvider &#125; from 'react-router-dom';import router from '@/router/index';import Loading from '@/components/Loading';function MyApp() &#123;  const [show, setShow] = useState(true)  const clickEvent = () =&gt; setShow(!show)  return (    &lt;&gt;      &lt;button onClick=&#123;clickEvent&#125;&gt;btn&lt;/button&gt;      &lt;Suspense fallback=&#123;&lt;Loading /&gt;&#125;&gt;        &#123;show ? &lt;RouterProvider router=&#123;router&#125; /&gt; : &lt;&gt;other template&lt;/&gt;&#125;      &lt;/Suspense&gt;    &lt;/&gt;  );&#125;export default MyApp;</code></pre><p id="ud8c681f0" class="ne-p"><span class="ne-text">结合startTransition使用：</span></p><p id="uad00f696" class="ne-p"><span class="ne-text">如果需要切换过程中不展示loading的加载态，则将上述代码中的切换逻辑转为并发异步即可</span></p><pre data-language="tsx" id="CrYvA" class="ne-codeblock language-tsx"><code>const clickEvent = () =&gt; startTransition(() =&gt; setShow(!show))</code></pre><h3 id="D6zkm"><span class="ne-text">错误边界捕获</span></h3><p id="uce23988c" class="ne-p"><span class="ne-text">如果编写的组件内部报错，那么react渲染会清除根节点DOM，React官方文档暂时只有类组件编写的示例代码。其核心逻辑在类组件上支持关键的生命周期方法getDerivedStateFromError()和componentDidCatch()，无法将错误边界编写为函数式组件，同时以下几种错误情况，也捕获不到：</span></p><ol class="ne-ol"><li id="u153d38e4" data-lake-index-type="0"><span class="ne-text">异步代码</span></li><li id="u5764c7ba" data-lake-index-type="0"><span class="ne-text">事件处理函数</span></li><li id="ubdf3f9b1" data-lake-index-type="0"><span class="ne-text">服务器组件</span></li><li id="uae94c9a5" data-lake-index-type="0"><span class="ne-text">Error Boundary自身</span></li></ol><p id="u01d1627d" class="ne-p"><span class="ne-text">具体的完整封装 TODO: </span></p><h1 id="MuBiq"><span class="ne-text">🎈</span><span class="ne-text">ReactDOM</span></h1><h3 id="SHFHy"><span class="ne-text">createPortal</span></h3><ol class="ne-ol"><li id="u729bc8ae" data-lake-index-type="0"><span class="ne-text">可以指定节点挂载到指定目标DOM节点</span></li></ol><pre data-language="tsx" id="TbQEn" class="ne-codeblock language-tsx"><code>// templateconst A = () =&gt; ReactDOM.createPortal(&lt;div&gt;info&lt;/div&gt;, document.body)</code></pre><ol start="2" class="ne-ol"><li id="u21e16b5d" data-lake-index-type="0"><span class="ne-text">对于一些全局组件（message），DOM的挂在可能不在root根节点内，自定义挂在指定DOM节点，除了上述createPortal方式，还有react的createRoot方式</span></li></ol><h3 id="JcFgv"><span class="ne-text">flushSync</span></h3><pre data-language="tsx" id="b1wUu" class="ne-codeblock language-tsx"><code>import &#123; useState &#125; from 'React'import &#123; flushSync &#125; from 'ReactDDOM'const A = () =&gt; &#123;  const [a, setA] = useState(1)  const [b, setB] = useState('b')  const addA = () =&gt; &#123;    setA(a + 1)    setA(a + 1)    setA(a + 1)  &#125;  flushSync(() =&gt; &#123;    setA(a + 1)  &#125;)  flushSync(() =&gt; &#123;    setB('bb')  &#125;)  return &lt;div onClick=&#123;addA&#125;&gt;a value: &#123;a&#125;&lt;/div&gt;&#125;</code></pre><h1 id="Z7LG9"><span class="ne-text">🎈</span><span class="ne-text">Others</span></h1><h3 id="OSkL5"><span class="ne-text">hooks</span></h3><ol class="ne-ol"><li id="u788f32a8" data-lake-index-type="0"><span class="ne-text" style="background-color: #FCE75A">use</span><span class="ne-text">：react18中的处理异步资源的一种方式，可解析Promise等，使用前提为服务端渲染或者开启异步的客户端</span></li><li id="u36a4991a" data-lake-index-type="0"><span class="ne-text">useDebugValue</span></li><li id="u9105ac7b" data-lake-index-type="0"><span class="ne-text">useId：生成唯一id，比如一个页面需要调用两个相同组件，并且需要给各自组件一个唯一id，useId就很适用</span></li><li id="u598cfe0c" data-lake-index-type="0"><span class="ne-text">useImperativeHandle</span></li><li id="u92b53f9f" data-lake-index-type="0"><span class="ne-text">useInsertionEffect：适用于CSS-in-JS相关场景</span></li><li id="ufc9310f0" data-lake-index-type="0"><span class="ne-text" style="background-color: #FBDE28">useOptimistic</span><span class="ne-text">：过渡态，有点类似Vue中的Suspense</span></li><li id="u52d3cf14" data-lake-index-type="0"><span class="ne-text">useSyncExternalStore</span></li></ol><h3 id="lMQGb"><span class="ne-text">组件</span></h3><ol class="ne-ol"><li id="ue6803775" data-lake-index-type="0"><span class="ne-text">&lt;Profiler&gt;：测量组件渲染性能</span></li><li id="u7fb3e3ac" data-lake-index-type="0" style="text-align: left"><span class="ne-text">&lt;StrictMode&gt;：严格模式，常用于开发环境再开发过程中就发现错误，但是会多执行组件渲染一次</span></li></ol></div>]]></content>
    
    
      
      
        
        
    <summary type="html">

&lt;div class=&quot;lake-content&quot; typography=&quot;classic&quot;&gt;&lt;blockquote data-type=&quot;info&quot; class=&quot;ne-alert&quot; style=&quot;background-color: rgba(192, 221, 252,</summary>
        
      
    
    
    
    <category term="Web开发" scheme="https://www.wztlink1013.com/categories/Web%E5%BC%80%E5%8F%91/"/>
    
    <category term="React" scheme="https://www.wztlink1013.com/categories/Web%E5%BC%80%E5%8F%91/React/"/>
    
    
  </entry>
  
  <entry>
    <title>MongoDB开启事务</title>
    <link href="https://www.wztlink1013.com/blog/uq766nlmm1cuh7kk/"/>
    <id>https://www.wztlink1013.com/blog/uq766nlmm1cuh7kk/</id>
    <published>2024-08-27T09:16:42.000Z</published>
    <updated>2024-11-16T19:50:36.000Z</updated>
    
    <content type="html"><![CDATA[<div class="lake-content" typography="classic"><p id="u25867f14" class="ne-p"><span class="ne-text">前置条件：下载MongoDB：</span><a href="https://www.mongodb.com/try/download/community-kubernetes-operator" data-href="https://www.mongodb.com/try/download/community-kubernetes-operator" target="_blank" class="ne-link"><span class="ne-text">https://www.mongodb.com/try/download/community-kubernetes-operator</span></a></p><p id="u424b79f4" class="ne-p" style="text-align: center"><strong><span class="ne-text" style="color: #DF2A3F">---------- 开启事务 ----------</span></strong></p><p id="u41886116" class="ne-p"><span class="ne-text">改配置文件</span></p><p id="u235b9d0c" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2024/png/1484158/1724779029642-5d8867f7-34f0-489d-8880-be7746dc89e0.png" width="701.8181666066827" id="u8b73b5a6" class="ne-image"></p><p id="uacbbd41d" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2024/png/1484158/1724779047217-5fa3b080-4dd0-4277-b25f-8cc956e30c7c.png" width="705.4545301642303" id="uf06c519d" class="ne-image"></p><p id="uedb9d6be" class="ne-p"><span class="ne-text">重新启动mongodb服务</span></p><p id="u9f901c03" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2024/png/1484158/1724779249047-8b4cfe26-d714-470f-9b73-2ac077569edf.png" width="768.181801531926" id="u9c7be902" class="ne-image"></p><p id="u56361093" class="ne-p"><span class="ne-text">新版mondodb没有可执行的bash，所以需要下一个mongosh（</span><a href="https://www.mongodb.com/try/download/shell" data-href="https://www.mongodb.com/try/download/shell" target="_blank" class="ne-link"><span class="ne-text">https://www.mongodb.com/try/download/shell</span></a><span class="ne-text">）</span></p><p id="uccb99e42" class="ne-p"><span class="ne-text">cmd中输入mongosh</span></p><p id="u0f49920f" class="ne-p"><span class="ne-text">然后输入rs.initiate()</span></p><p id="u971ec363" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2024/png/1484158/1724779149651-a2a94509-bd4f-4a24-a68f-86cd5381a84c.png" width="1011.8181598876138" id="RgwTV" class="ne-image"></p><p id="u85dfe517" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2024/png/1484158/1724779201995-71147800-146f-44d9-a120-1e2f1c25a98a.png" width="1011.8181598876138" id="u5023dbad" class="ne-image"></p><p id="u79fbc486" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2024/png/1484158/1724779216195-61505658-b65c-4fec-98f1-fab1fac79f19.png" width="1011.8181598876138" id="ua2dbe8cb" class="ne-image"><span class="ne-text">有这个说明设置正确</span></p></div>]]></content>
    
    
      
      
        
        
    <summary type="html">

&lt;div class=&quot;lake-content&quot; typography=&quot;classic&quot;&gt;&lt;p id=&quot;u25867f14&quot; class=&quot;ne-p&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;前置条件：下载MongoDB：&lt;/span&gt;&lt;a</summary>
        
      
    
    
    
    <category term="Web开发" scheme="https://www.wztlink1013.com/categories/Web%E5%BC%80%E5%8F%91/"/>
    
    <category term="DataBase" scheme="https://www.wztlink1013.com/categories/Web%E5%BC%80%E5%8F%91/DataBase/"/>
    
    
  </entry>
  
  <entry>
    <title>Vue3源码debugger：响应式变量值变化执行流程</title>
    <link href="https://www.wztlink1013.com/blog/khg4u3f89ozvkuta/"/>
    <id>https://www.wztlink1013.com/blog/khg4u3f89ozvkuta/</id>
    <published>2024-08-22T22:19:37.000Z</published>
    <updated>2024-11-16T19:50:36.000Z</updated>
    
    <content type="html"><![CDATA[<div class="lake-content" typography="classic"><h2 id="ZInLD"><span class="ne-text">响应式变量赋值</span></h2><p id="u0dd506fb" class="ne-p"><span class="ne-text">响应式变量commits首次赋值接口所返回的数据</span></p><p id="ub497ee64" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2024/png/1484158/1724654176733-c4bf03bc-1cda-44c9-bd2e-a06c0455b152.png" width="690" id="u077bd02b" class="ne-image"></p><p id="u1d2e6444" class="ne-p"><br></p><p id="ue05c8c2f" class="ne-p"><span class="ne-text">进入触发Proxy的set拦截【在createApp的实例化的过程中，就已经将data选项响应化，可以参考之前的文章】</span></p><p id="ua0b47a01" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2024/png/1484158/1724394084509-5821f367-a7ec-4083-952d-f9946487f725.png" width="1656" id="EBhF6" class="ne-image"></p><p id="uaa02f888" class="ne-p"><span class="ne-text"></span></p><p id="ud9e1c7d6" class="ne-p"><span class="ne-text">最终进入trigger函数</span></p><p id="u84bb2451" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2024/png/1484158/1724394327576-b64a6b93-64a6-44cd-9213-917e0fcb7182.png" width="1661" id="ubc198d8a" class="ne-image"></p><ul class="ne-ul"><li id="u298edc8a" data-lake-index-type="0"><span class="ne-text">174行：触发副作用</span></li><li id="u9de3109a" data-lake-index-type="0"><span class="ne-text">177行：利用Reflect返回所赋值的内容，具体可查看（</span><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/Proxy/set" data-href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/Proxy/set" target="_blank" class="ne-link"><span class="ne-text">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/Proxy/set</span></a><span class="ne-text">）</span></li></ul><h2 id="u59PG"><span class="ne-text">trigger</span></h2><p id="u6db26817" class="ne-p"><span class="ne-text">进入trigger内部</span></p><p id="u5bebbe2e" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2024/png/1484158/1724394939956-4ccb1953-3f06-4352-9f31-104e5c849267.png" width="1230" id="u60c1a4a4" class="ne-image"></p><ul class="ne-ul"><li id="uab2f9e33" data-lake-index-type="0"><span class="ne-text">target实际上是选项式中的data</span></li><li id="u97783b7d" data-lake-index-type="0"><strong><span class="ne-text">targetMap是从一开始注册响应化就收集的响应映射表</span></strong></li></ul><h3 id="Pcy42"><span class="ne-text">执行trigger</span></h3><p id="u573fd450" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2024/png/1484158/1724654451358-19007aae-128d-4dc4-a160-d5e9643c71de.png" width="1589" id="ue0329fe8" class="ne-image"></p><ul class="ne-ul"><li id="ubb3f36a4" data-lake-index-type="0"><code class="ne-code"><span class="ne-text" style="color: var(--md-box-samantha-normal-text-color) !important; font-size: 16px">startBatch()</span></code><span class="ne-text" style="color: var(--md-box-samantha-normal-text-color) !important; font-size: 16px">和</span><code class="ne-code"><span class="ne-text" style="color: var(--md-box-samantha-normal-text-color) !important; font-size: 16px">endBatch()</span></code><span class="ne-text" style="color: var(--md-box-samantha-normal-text-color) !important; font-size: 16px">：</span></li></ul><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="uc720a402" data-lake-index-type="0"><code class="ne-code"><span class="ne-text" style="color: initial; font-size: 14px">startBatch()</span></code><span class="ne-text" style="color: initial; font-size: 16px">用于开启一个批量更新的阶段。在这个阶段中，响应式数据的变化不会立即触发依赖的更新，而是会被收集起来，等到</span><code class="ne-code"><span class="ne-text" style="color: initial; font-size: 14px">endBatch()</span></code><span class="ne-text" style="color: initial; font-size: 16px">被调用后再统一进行处理。这样做的好处是可以避免在短时间内频繁地触发更新，从而提高性能。例如，在一个循环中多次修改响应式数据时，可以使用批量更新来减少不必要的重复更新操作。</span></li></ul></ul><ul class="ne-ul"><li id="u9896a69c" data-lake-index-type="0"><span class="ne-text" style="color: initial; font-size: 16px">__DEV__：开发环境下传入数据信息便于调试</span></li><li id="ue5b0e614" data-lake-index-type="0"><span class="ne-text" style="color: initial; font-size: 16px">dep.trigger()：触发依赖更新</span></li></ul><p id="u28a61200" class="ne-p"><span class="ne-text">trigger下又执行notify</span></p><p id="ue0a473e3" class="ne-p"><span class="ne-text" style="color: initial; font-size: 16px">封装在</span><img src="https://cdn.nlark.com/yuque/0/2024/png/1484158/1724654522704-0d8ab60d-c703-44b0-a40f-73b74855a77e.png" width="587" id="ua57f0646" class="ne-image"></p><h3 id="tNols"><span class="ne-text">notify</span></h3><p id="ud301b71d" class="ne-p"><span class="ne-text">通过遍历订阅链表（subsHead），执行订阅事件，也就是“副作用”，简而言之的理解就是通知订阅者更新</span></p><p id="ub142d2fd" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2024/png/1484158/1724395543939-5231eb2e-a79e-457d-a68d-d02ed08a559d.png" width="837" id="ud0255935" class="ne-image"></p><ul class="ne-ul"><li id="udb977797" data-lake-index-type="0"><code class="ne-code"><span class="ne-text">link.sub.notify()</span></code></li></ul><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="u9df9804e" data-lake-index-type="0"><strong><span class="ne-text">作用</span></strong><span class="ne-text">：通知每个订阅者执行其副作用。</span></li><li id="u3da83814" data-lake-index-type="0"><strong><span class="ne-text">解释</span></strong><span class="ne-text">：每个订阅者都有一个 </span><code class="ne-code"><span class="ne-text">notify</span></code><span class="ne-text"> 方法，调用它会触发该订阅者的副作用执行。因为是从尾到头通知，所以确保了所有的依赖在批处理内按顺序执行。</span></li></ul></ul><p id="u70883d6e" class="ne-p"><span class="ne-text">当trigger执行完，同时Proxy的set流程也结束。</span></p><p id="u14d6430c" class="ne-p"><span class="ne-text">下一步执行到PublicInstanceProxyHandlers</span></p><h2 id="pZ0kG"><span class="ne-text">PublicInstanceProxyHandlers</span></h2><p id="u092fb73f" class="ne-p"><span class="ne-text">这个是组件实例行为的封装，上述响应式变量赋值完成，然后进入当前的组件实例属性设置</span></p><p id="u3458adca" class="ne-p"><code class="ne-code"><span class="ne-text">set</span></code><span class="ne-text"> 方法用于拦截和处理对组件实例属性的修改操作  </span></p><p id="u8f60a1be" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2024/png/1484158/1724396098652-00faed94-469d-4b61-9f77-a20ec73049c7.png" width="800" id="u784063f1" class="ne-image"></p><h2 id="s8RBZ"><span class="ne-text">主线程工作结束</span></h2><p id="u42bf9e38" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2024/png/1484158/1724396266488-fe4d1ae9-870a-4f43-87d8-3fe03c34c37b.png" width="523" id="u15c91d7a" class="ne-image"></p><h2 id="zp4dR"><span class="ne-text">微任务flushJobs</span></h2><p id="u23a81d85" class="ne-p"><span class="ne-text">执行异步的flushJobs</span></p><p id="u929d3f95" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2024/png/1484158/1724403602240-595eb2a9-013f-4f9c-8192-15bb17223709.png" width="933" id="u62df03f8" class="ne-image"></p><p id="ufd4b2823" class="ne-p"><code class="ne-code"><span class="ne-text">flushJobs</span></code><span class="ne-text"> 是一个用于刷新调度队列的函数，它会执行所有被调度的任务（如组件更新、计算属性的重新计算等）  </span></p><ul class="ne-ul"><li id="udd02e48e" data-lake-index-type="0"><strong><span class="ne-text">调度器调度任务</span></strong><span class="ne-text">：</span></li><li id="ubac44c6c" data-lake-index-type="0"><span class="ne-text">Vue 3 的调度器会负责管理这个调度队列。调度器会尝试合并重复的任务，确保每个任务只执行一次，并且按照一定的顺序（如父组件先于子组件，先更新计算属性再更新渲染函数）进行调度。</span></li><li id="uc9a965da" data-lake-index-type="0"><code class="ne-code"><strong><span class="ne-text">queueFlush</span></strong></code><strong><span class="ne-text"> 触发</span></strong><span class="ne-text">：</span></li><li id="u1571470d" data-lake-index-type="0"><span class="ne-text">当有新的任务被添加到调度队列时，调度器会调用 </span><code class="ne-code"><span class="ne-text">queueFlush</span></code><span class="ne-text"> 函数，将刷新任务安排到下一个微任务（microtask）中执行。</span></li><li id="uebda4fcc" data-lake-index-type="0"><span class="ne-text">这通常是通过 </span><code class="ne-code"><span class="ne-text">Promise.resolve().then(flushJobs)</span></code><span class="ne-text"> 来实现的。</span><code class="ne-code"><span class="ne-text">Promise.resolve().then(...)</span></code><span class="ne-text"> 会创建一个新的微任务，在当前同步任务结束后立即执行。这样做的好处是保证所有的同步任务（如多个响应式数据的 </span><code class="ne-code"><span class="ne-text">set</span></code><span class="ne-text"> 操作）都完成之后，再一次性执行批量更新操作。</span></li><li id="u114b0ad0" data-lake-index-type="0"><strong><span class="ne-text">执行 </span></strong><code class="ne-code"><strong><span class="ne-text">flushJobs</span></strong></code><span class="ne-text">：</span></li><li id="u1e9084d3" data-lake-index-type="0"><span class="ne-text">一旦所有的同步操作完成，事件循环进入到微任务队列，</span><code class="ne-code"><span class="ne-text">flushJobs</span></code><span class="ne-text"> 函数被调用。</span><code class="ne-code"><span class="ne-text">flushJobs</span></code><span class="ne-text"> 会遍历调度队列，并依次执行每个调度任务（如重新渲染组件、重新计算计算属性等）。</span></li><li id="u17a6f212" data-lake-index-type="0"><span class="ne-text">在这个阶段，所有的 </span><code class="ne-code"><span class="ne-text">effect</span></code><span class="ne-text"> 被重新执行，更新视图、计算新的值等等。</span></li></ul></div>]]></content>
    
    
      
      
        
        
    <summary type="html">

&lt;div class=&quot;lake-content&quot; typography=&quot;classic&quot;&gt;&lt;h2 id=&quot;ZInLD&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;响应式变量赋值&lt;/span&gt;&lt;/h2&gt;&lt;p id=&quot;u0dd506fb&quot;</summary>
        
      
    
    
    
    <category term="Web开发" scheme="https://www.wztlink1013.com/categories/Web%E5%BC%80%E5%8F%91/"/>
    
    <category term="Vue" scheme="https://www.wztlink1013.com/categories/Web%E5%BC%80%E5%8F%91/Vue/"/>
    
    
  </entry>
  
</feed>
