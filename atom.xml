<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>尼采般地抒情</title>
  <icon>https://www.wztlink1013.com/favicon.ico</icon>
  <subtitle>什么都不舍弃，什么也改变不了</subtitle>
  <link href="https://www.wztlink1013.com/atom.xml" rel="self"/>
  
  <link href="https://www.wztlink1013.com/"/>
  <updated>2024-04-22T07:16:27.000Z</updated>
  <id>https://www.wztlink1013.com/</id>
  
  <author>
    <name>尼采般地抒情</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>前后端实现简单上传功能</title>
    <link href="https://www.wztlink1013.com/blog/2024-04-21-16-20-30/"/>
    <id>https://www.wztlink1013.com/blog/2024-04-21-16-20-30/</id>
    <published>2024-04-21T08:20:33.000Z</published>
    <updated>2024-04-22T07:16:27.000Z</updated>
    
    <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="u3fb2f3b9" class="ne-p"><span class="ne-text" style="color: rgba(0, 0, 0, 0.9); font-size: 16px">前言：本文讲述前后端实现图片上传功能，首先简述JavaScript中的Blob和File对象，并给出base64、blob、url、file四者相互之间的转换，最后给出一个简单的前后端代码demo实例。</span></p><h2 id="CxSoe" style="text-align: justify"><span class="ne-text" style="color: rgba(0, 0, 0, 0.9)">一、JavaScript文件相关API</span></h2><h3 id="hMtFj" style="text-align: justify"><span class="ne-text" style="color: rgba(0, 0, 0, 0.9)">1.1 Blob</span></h3><p id="u71770806" class="ne-p" style="text-align: justify"><span class="ne-text" style="color: rgba(0, 0, 0, 0.9); font-size: 16px">Blob（二进制大对象）是一个可以存储大量二进制数据的对象。主要用途包括但不限于存储文件内容、图片、视频等类型的数据。Blob对象可以用来在前端技术中处理文件上传、下载、图像处理等多种场景。</span></p><div data-type="info" class="ne-alert"><p id="uf393c110" class="ne-p" style="text-align: justify"><span class="ne-text" style="color: rgb(51, 51, 51)">详细使用参考：</span></p><p id="ua555d7fc" class="ne-p" style="text-align: justify"><a href="详细使用参考：  https://developer.mozilla.org/zh-CN/docs/Web/API/Blob" data-href="详细使用参考：  https://developer.mozilla.org/zh-CN/docs/Web/API/Blob" class="ne-link"><span class="ne-text">https://developer.mozilla.org/zh-CN/docs/Web/API/Blob</span></a></p></div><pre><code><code>&lt;script&gt;  const data = new Blob([1, 2, 3, 4, 5], &#123; type: 'application/octet-stream' &#125;)  console.log('blob data: ', data)&lt;/script&gt;</code></code></pre><p id="u32287017" class="ne-p" style="text-align: justify"><img src="https://cdn.nlark.com/yuque/0/2024/png/1484158/1713754881085-6f1924a2-c346-4997-b7b6-409d6cdba5c1.png" width="517" id="uaced79e7" class="ne-image"></p><h3 id="HxvPb" style="text-align: justify"><span class="ne-text" style="color: rgba(0, 0, 0, 0.9)">1.2 File</span></h3><p id="u558129f1" class="ne-p" style="text-align: justify"><span class="ne-text" style="color: rgba(0, 0, 0, 0.9); font-size: 16px">File是Blob的子类，包含文件更多信息（文件的类型和其他属性等）</span></p><div data-type="info" class="ne-alert"><p id="u2b5a434e" class="ne-p"><span class="ne-text">File的构造函数接受三个参数</span></p><ol class="ne-ol"><li id="u8afb96d6" data-lake-index-type="0"><span class="ne-text">一个包含数据的数组，这个数组可以是包含文本、二进制数据或其他 Blob 对象的数组。</span></li><li id="u23ad8b99" data-lake-index-type="0"><span class="ne-text">文件名，用于表示文件的名称，通常包括文件扩展名。</span></li><li id="udbf4a44d" data-lake-index-type="0"><span class="ne-text">可选的文件选项对象，用于指定文件的类型和其他属性</span></li></ol></div><p id="u0d05ee3f" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2024/png/1484158/1713755178673-a0d2eda8-d14a-4e40-be03-fb69ef378fcf.png" width="512" id="u00312bf0" class="ne-image"></p><h2 id="jPGuQ" style="text-align: justify"><span class="ne-text" style="color: rgba(0, 0, 0, 0.9)">二、base64、blob、url、file相关转换</span></h2><p id="u8233f324" class="ne-p" style="text-align: justify"><span class="ne-text" style="color: rgba(0, 0, 0, 0.9); font-size: 16px">以下代码实现了base64、blob、url、file四者之间的相互转换。</span></p><pre><code><code>&lt;img id=&quot;test-img&quot;&gt;&lt;script&gt;  // base64  const base64Data = `data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABcAAAAYCAIAAACeHvEiAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAAEXRFWHRTb2Z0d2FyZQBTbmlwYXN0ZV0Xzt0AAAETSURBVDiN3ZQxqoNAEIbXYKWNAUFLQQuLdN7BSiw8gViIreIVYuUB7G0srT2DvcuCaKUnWBRBfYVgfBpekpcmZKr9Z5jvH5hhiXmewdtxeh/xlRRypxFCfd+v8nK5nE6PnW6UcRxd10UIbcuqqnqe9wKlbVuEkCzLiqIsmTzPsyxjGMayrL8pxHovdV07jmMYhm3bSwZj7Pt+VVXHNoqidF03TXM/yzFomg6CIAzDYRh2paZpkiTRNI1l2TuUaZq28nw+X6/Xo0EURWmadl23yE+6l++j3HZEkiQAAEIYx/HDtqIo1pZfFJ7nBUGAEEIIn/GXJInjuOVNbP86jHFZls8gAACiKNI0fYfy7/ikHX0S5QdklWFq9EOtGAAAAABJRU5ErkJggg==`  // base64 -&gt; blob  const convertBase64UrlToBlob = (urlData) =&gt; &#123;    // 去掉url的头，并转换为byte    let bytes = window.atob(urlData.split(',')[1]),      // 处理异常,将ascii码小于0的转换为大于0      ab = new ArrayBuffer(bytes.length),      ia = new Uint8Array(ab);    for (let i = 0; i &lt; bytes.length; i++) ia[i] = bytes.charCodeAt(i);    return new Blob([ab], &#123; type: 'image/png' &#125;);  &#125;  const blobWithBase64 = convertBase64UrlToBlob(base64Data)  // blob -&gt; url  const urlWithObjectURLBlob = URL.createObjectURL(blobWithBase64);  // blob -&gt; file  const fileWithBlob = new File([blobWithBase64], 'test.png', &#123; type: 'image/png' &#125;)  // file -&gt; base64  const reader = new FileReader();  let base64WithFile = '';  reader.readAsDataURL(fileWithBlob)  reader.onload = function () &#123;    base64WithFile = reader.result    console.log(&#123; base64Data, blobWithBase64, fileWithBlob, base64WithFile, urlWithObjectURLBlob &#125;)    document.getElementById('test-img').src = urlWithObjectURLBlob  &#125;  // get blob data -&gt; download file  const downloadFile = (url, fileName) =&gt; &#123;    var x = new XMLHttpRequest();    x.open(&quot;GET&quot;, url, true);    x.responseType = 'blob';    x.onload = function (e) &#123;      url = window.URL.createObjectURL(x.response)      var a = document.createElement('a');      a.href = url      a.download = fileName;      a.target = '_blank';      a.click()    &#125;    x.send();  &#125;&lt;/script&gt;</code></code></pre><h2 id="tZQ9L" style="text-align: justify"><span class="ne-text" style="color: rgba(0, 0, 0, 0.9)">三、前后端实现</span></h2><h3 id="aIxxy" style="text-align: justify"><span class="ne-text" style="color: rgba(0, 0, 0, 0.9)">3.1 客户端代码</span></h3><p id="u26795152" class="ne-p" style="text-align: justify"><span class="ne-text" style="color: rgba(0, 0, 0, 0.9); font-size: 16px">客户端利用表单来进行上传文件，并将文件信息调用接口</span></p><pre><code><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;<p>  &lt;head&gt;<br>    &lt;meta charset=&quot;UTF-8&quot;&gt;<br>    &lt;title&gt;File Upload&lt;/title&gt;<br>    &lt;script&gt;<br>      // 上传本地文件<br>      const uploadFile = () =&gt; &#123;<br>        const formData = new FormData();<br>        const file = document.getElementById(‘file’).files[0];<br>        formData.append(&quot;file&quot;, file);<br>        console.log(‘upload file: ‘, formData, file)<br>        fetch(‘<a href="http://localhost:3005/upload&#39;">http://localhost:3005/upload&#39;</a>, &#123;<br>          method: ‘POST’,<br>          body: formData<br>        &#125;)<br>          .then(response =&gt; response.json())<br>          .then(data =&gt; console.log(data))<br>          .catch(error =&gt; console.error(‘Error:’, error));<br>      &#125;<br>    &lt;/script&gt;<br>  &lt;/head&gt;</p><p>  &lt;body&gt;<br>    &lt;form onsubmit=&quot;event.preventDefault(); uploadFile();&quot;&gt;<br>      &lt;input type=&quot;file&quot; id=&quot;file&quot; name=&quot;file&quot;&gt;<br>      &lt;button type=&quot;submit&quot;&gt;Upload&lt;/button&gt;<br>    &lt;/form&gt;<br>  &lt;/body&gt;</p><p>&lt;/html&gt;</code><br></code></pre></p><p id="u196b78f3" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2024/png/1484158/1713796494878-644c6b6f-c799-4c1e-ac62-0a65a0be0363.png" width="435.83331601487333" id="u24ddf599" class="ne-image"></p><h3 id="jfENa" style="text-align: justify"><span class="ne-text" style="color: rgba(0, 0, 0, 0.9)">3.2 服务端代码</span></h3><p id="u0cefd7d7" class="ne-p" style="text-align: justify"><span class="ne-text" style="color: rgba(0, 0, 0, 0.9); font-size: 16px">利用multer中间件来进行文件相关操作，express搭建一个简单的接口。</span></p><div data-type="info" class="ne-alert"><p id="u2a00c498" class="ne-p"><span class="ne-text">Multer是一个Node.js中间件，用于处理multipart/form-data类型的表单数据，它主要用于上传文件。</span></p><p id="u38cab78a" class="ne-p"><a href="https://github.com/expressjs/multer" data-href="https://github.com/expressjs/multer" target="_blank" class="ne-link"><span class="ne-text">https://github.com/expressjs/multer</span></a></p></div><pre><code><code>const express = require('express');const multer = require('multer');const cors = require('cors');const app = express();<p>app.use(cors());<br>const port = 3005;</p><p>const storage = multer.diskStorage(&#123;<br>  destination: function (req, file, cb) &#123;<br>    cb(null, ‘uploads/‘)<br>  &#125;,<br>  filename: function (req, file, cb) &#123;<br>    cb(null, file.fieldname + ‘-‘ + Date.now() + ‘.’ + file.originalname.split(‘.’).pop())<br>  &#125;<br>&#125;);</p><p>const upload = multer(&#123; storage: storage &#125;);</p><p>app.post(‘/upload’, upload.single(‘file’), (req, res) =&gt; &#123;<br>  res.json(&#123; message: ‘File uploaded successfully’, file: req.file.path &#125;);<br>&#125;);</p><p>app.listen(port, () =&gt; &#123;<br>  console.log(<code>Server running at http://localhost:$&#123;port&#125;/</code>);<br>});</code><br></code></pre></p><p id="ube7cc006" class="ne-p"><span class="ne-text" style="color: rgba(0, 0, 0, 0.9); font-size: 16px">服务端写了一个简单的接口，用来处理前端表单所上传的文件信息，并且将文件保存至指定文件夹</span></p><p id="u5530dabe" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2024/png/1484158/1713796464967-25c6ef6f-7d92-4ffc-af32-566e7c2e0f51.png" width="492.49998042980906" id="u614b0edc" class="ne-image"></p><div data-type="success" class="ne-alert"><p id="u6b257bd1" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51)">一个比较简单的demo就完成了</span></p><p id="u57719ce1" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2024/png/1484158/1713798928640-89584e70-4ba8-4777-ba23-9ce5575adc14.png" width="302.49998797973046" id="ue0476ec3" class="ne-image"></p></div></div>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;!doctype html&gt;&lt;div class=&quot;lake-content&quot; typography=&quot;classic&quot;&gt;&lt;p id=&quot;u3fb2f3b9&quot; class=&quot;ne-p&quot;&gt;&lt;span class=&quot;ne-text&quot; style=&quot;color: rgba(0, 0,</summary>
        
      
    
    
    
    <category term="Web开发" scheme="https://www.wztlink1013.com/categories/Web%E5%BC%80%E5%8F%91/"/>
    
    <category term="前端业务解决方案" scheme="https://www.wztlink1013.com/categories/Web%E5%BC%80%E5%8F%91/%E5%89%8D%E7%AB%AF%E4%B8%9A%E5%8A%A1%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    
    
  </entry>
  
  <entry>
    <title>前端工程化：模块化基础</title>
    <link href="https://www.wztlink1013.com/blog/psazge/"/>
    <id>https://www.wztlink1013.com/blog/psazge/</id>
    <published>2024-04-21T02:16:39.000Z</published>
    <updated>2024-04-21T02:17:20.000Z</updated>
    
    <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="u9dfc8a71" class="ne-p"><span class="ne-text">前言：本文讲述前端代码从脚本全局函数时代到现代化模块引入时代的发展历程，再介绍构建工具对代码予以指定条件下的打包构建，最后利用vite打包工具打包一个可供多个环境使用的SDK的例子。</span></p><p id="ua273ed45" class="ne-p"><span class="ne-text"></span></p><h2 id="Mois5"><span class="ne-text">一、模块化演变历程</span></h2><h3 id="Rj0X5"><span class="ne-text">1.1 脚本全局函数</span></h3><div data-type="success" class="ne-alert"><p id="u733dbba2" class="ne-p"><span class="ne-text">在HTML页面所引入的脚本中定义函数，在浏览器执行脚本则可以使用脚本中所定义的全局函数</span></p></div><pre><code><code>&lt;body&gt;  &lt;script&gt;    const globalFun = () =&gt; &#123;      console.warn('this is globalFun');    &#125;;  &lt;/script&gt;&lt;/body&gt;</code></code></pre><p id="udc6e94fe" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2024/png/1484158/1713682888934-ccbdc852-0125-4796-becb-deca844aad58.png" width="279.9999888738001" id="u44daa269" class="ne-image"></p><div data-type="danger" class="ne-alert"><p id="u534153bc" class="ne-p"><span class="ne-text">缺点： 污染全局命名空间, 容易引起命名冲突或数据不安全，而且模块成员之间看不出直接关系  </span></p></div><h3 id="YqDub"><span class="ne-text">1.2 namespace模式</span></h3><div data-type="success" class="ne-alert"><p id="u015d1aa4" class="ne-p"><span class="ne-text">通过命名空间来解决上述命名冲突的问题</span></p></div><pre><code><code>&lt;body&gt;  &lt;script&gt;    const globalNameSpaceTest = &#123;      fun: () =&gt; &#123;        console.warn('this is globalNameSpaceTest');      &#125;,    &#125;;  &lt;/script&gt;&lt;/body&gt;</code></code></pre><p id="u2f933c3c" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2024/png/1484158/1713683164533-8a11c85b-caf3-48f1-a0d8-d3634a06ff87.png" width="400.83331740564836" id="u7f1a83e2" class="ne-image"></p><div data-type="danger" class="ne-alert"><p id="u88484269" class="ne-p"><span class="ne-text">缺点：</span></p><ul class="ne-ul"><li id="u2a74f41c" data-lake-index-type="0"><span class="ne-text">外部可以更改内部状态</span></li><li id="u08770818" data-lake-index-type="0"><span class="ne-text">所有模块代码都被暴露在外</span></li></ul></div><h3 id="B5VtJ"><span class="ne-text">1.3 IIFE (立即调用的函数表达式)</span></h3><p id="u3f177135" class="ne-p"><span class="ne-text">在JavaScript语言中，有一个立即执行函数，当脚本加载成功则执行所定义的函数。</span></p><pre><code><code>&lt;body&gt;  &lt;script&gt;    (function () &#123;      console.warn('IIFE code...');      console.info(this);      globalThis.IIFETestMoudle = &#123;        fun: () =&gt; &#123;          console.warn('some logic...');        &#125;,      &#125;;    &#125;)();  &lt;/script&gt;&lt;/body&gt;</code></code></pre><p id="ud34a902e" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2024/png/1484158/1713683818953-4b3c0b5f-fab8-4877-8b3a-4ec34ab5f5b6.png" width="389.16665120257335" id="u8d2c58c4" class="ne-image"></p><div data-type="success" class="ne-alert"><p id="u452732e2" class="ne-p"><span class="ne-text">通过这种形式创建的模块可以自己独立的私有作用域</span></p></div><div data-type="danger" class="ne-alert"><p id="uf21edfa7" class="ne-p"><span class="ne-text">缺点：</span></p><ol class="ne-ol"><li id="u06d97ded" data-lake-index-type="0"><span class="ne-text">模块之间的依赖依旧不明确，依旧是挂载到全局宿主环境上</span></li></ol></div><h3 id="vxrce"><span class="ne-text">1.4 Commonjs</span></h3><p id="ubd46c94a" class="ne-p"><span class="ne-text">CommonJS是Node.js环境下的模块化规范</span></p><h4 id="YJf3k"><span class="ne-text">两种导出方式</span></h4><p id="ue38e07b7" class="ne-p"><span class="ne-text">第一种导出方式：</span></p><pre><code><code>const fun = () =&gt; &#123;  console.warn(&quot;cjs fun...&quot;);&#125;;module.exports = fun;</code></code></pre><pre><code><code>const moduleTest = require(&quot;./module-test&quot;);console.log(moduleTest);</code></code></pre><p id="u3f8151f3" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2024/png/1484158/1713684727768-49bf85de-e18b-4246-8533-e7425833b351.png" width="477.4999810258555" id="u8b0798a6" class="ne-image"></p><p id="u11bec7f2" class="ne-p"><span class="ne-text">第二种方式：</span></p><pre><code><code>const fun = () =&gt; &#123;  console.warn(&quot;cjs fun...&quot;);&#125;;module.exports.fun = fun;</code></code></pre><p id="ub0afcd13" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2024/png/1484158/1713684784746-a07ea600-35ce-4c6c-b3a3-ebd64f5fd551.png" width="487.49998062849124" id="uccdf9a15" class="ne-image"></p><div data-type="info" class="ne-alert"><p id="uf0ae6bca" class="ne-p"><span class="ne-text">上述两种方式都是对</span><code class="ne-code"><span class="ne-text">module.exports</span></code><span class="ne-text">赋值或是添加属性的形式来进行模块导出，那么对于在</span><code class="ne-code"><span class="ne-text">nodejs</span></code><span class="ne-text">当中，</span><code class="ne-code"><span class="ne-text">module</span></code><span class="ne-text">是什么呢？由截图可以看出当前文件模块可以依赖的</span><code class="ne-code"><span class="ne-text">nodejs</span></code><span class="ne-text">模块及其一些其他信息，其中：</span></p><ul class="ne-ul"><li id="u1ad50e53" data-lake-index-type="0"><code class="ne-code"><span class="ne-text">exports</span></code><span class="ne-text">：当前模块导出的部分</span></li><li id="uc7cc432d" data-lake-index-type="0"><code class="ne-code"><span class="ne-text">loaded</span></code><span class="ne-text">：当前模块是否加载完毕</span></li><li id="u59c97e8a" data-lake-index-type="0"><code class="ne-code"><span class="ne-text">paths</span></code><span class="ne-text">：模块查找路径</span></li></ul><p id="ua1f788a2" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2024/png/1484158/1713685048043-00c1c479-fd6b-4d9f-93d7-209db8213256.png" width="1324.1666140490129" id="u80d44c04" class="ne-image"></p></div><h4 id="r3GKa"><span class="ne-text">特点</span></h4><ul class="ne-ul"><li id="ufc8cb866" data-lake-index-type="0"><span class="ne-text">模块的加载是运行时同步加载的，所以在导入时会阻塞执行</span></li><li id="u3e1d725d" data-lake-index-type="0"><span class="ne-text">模块的加载实际上对是所引入对象的一种深拷贝</span></li></ul><p id="u46a75a1d" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2024/png/1484158/1713686002849-f16325a6-7e91-4ac9-8fa5-9d835ce2ad42.png" width="1554.1666049096343" id="ue322ee10" class="ne-image"></p><h4 id="brOua"><span class="ne-text">模块加载机制</span></h4><ol class="ne-ol"><li id="ua1c6f01d" data-lake-index-type="0"><span class="ne-text" style="color: inherit">模块定义：</span><span class="ne-text" style="color: rgb(13, 13, 13); font-size: 16px">在 CommonJS 规范中，每个文件被视为一个独立的模块。模块内部的变量都是局部变量，不会泄露到全局作用域。一个模块可以通过 </span><strong><span class="ne-text" style="color: var(--tw-prose-code); font-size: 16px">require</span></strong><span class="ne-text" style="color: rgb(13, 13, 13); font-size: 16px"> 函数来加载另一个模块，并通过 </span><strong><span class="ne-text" style="color: var(--tw-prose-code); font-size: 16px">module.exports</span></strong><span class="ne-text" style="color: rgb(13, 13, 13); font-size: 16px"> 或 </span><strong><span class="ne-text" style="color: var(--tw-prose-code); font-size: 16px">exports</span></strong><span class="ne-text" style="color: rgb(13, 13, 13); font-size: 16px"> 对象来导出功能。</span></li><li id="ufb5ea875" data-lake-index-type="0"><span class="ne-text" style="color: inherit">模块加载：</span><span class="ne-text" style="color: rgb(13, 13, 13); font-size: 16px">当一个模块需要使用另一个模块时，它会使用 </span><strong><span class="ne-text" style="color: var(--tw-prose-code); font-size: 16px">require</span></strong><span class="ne-text" style="color: rgb(13, 13, 13); font-size: 16px"> 函数来加载目标模块。</span><strong><span class="ne-text" style="color: var(--tw-prose-code); font-size: 16px">require</span></strong><span class="ne-text" style="color: rgb(13, 13, 13); font-size: 16px"> 函数接受一个模块标识符（通常是文件的路径或者模块的名称）作为参数，并返回该模块导出的对象。</span></li><li id="u18e47d65" data-lake-index-type="0"><span class="ne-text" style="color: inherit">模块解析：</span><span class="ne-text" style="color: rgb(13, 13, 13); font-size: 16px">当调用 </span><strong><span class="ne-text" style="color: var(--tw-prose-code); font-size: 16px">require</span></strong><span class="ne-text" style="color: rgb(13, 13, 13); font-size: 16px"> 函数时，Node.js 会按照以下步骤解析和加载模块：</span></li></ol><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="u341f6250" data-lake-index-type="0"><span class="ne-text" style="color: var(--tw-prose-bold); font-size: 16px">路径分析</span><span class="ne-text" style="color: rgb(13, 13, 13); font-size: 16px">：首先检查模块标识符是否是内置模块（如 </span><span class="ne-text" style="color: var(--tw-prose-code); font-size: 16px">fs</span><span class="ne-text" style="color: rgb(13, 13, 13); font-size: 16px">、</span><span class="ne-text" style="color: var(--tw-prose-code); font-size: 16px">http</span><span class="ne-text" style="color: rgb(13, 13, 13); font-size: 16px"> 等）。如果不是，Node.js 会解析相对或绝对路径。</span></li><li id="u0e529b7e" data-lake-index-type="0"><span class="ne-text" style="color: var(--tw-prose-bold); font-size: 16px">文件定位</span><span class="ne-text" style="color: rgb(13, 13, 13); font-size: 16px">：Node.js 会根据路径查找 </span><strong><span class="ne-text" style="color: var(--tw-prose-code); font-size: 16px">.js</span></strong><span class="ne-text" style="color: rgb(13, 13, 13); font-size: 16px">、</span><strong><span class="ne-text" style="color: var(--tw-prose-code); font-size: 16px">.json</span></strong><span class="ne-text" style="color: rgb(13, 13, 13); font-size: 16px"> 或 </span><strong><span class="ne-text" style="color: var(--tw-prose-code); font-size: 16px">.node</span></strong><span class="ne-text" style="color: rgb(13, 13, 13); font-size: 16px"> 文件。如果路径没有文件扩展名，Node.js 会尝试加载支持的文件类型。</span></li><li id="u6dcdf6d5" data-lake-index-type="0"><span class="ne-text" style="color: var(--tw-prose-bold); font-size: 16px">目录分析和包处理</span><span class="ne-text" style="color: rgb(13, 13, 13); font-size: 16px">：如果模块标识符是一个目录，Node.js 将查找该目录下的 </span><strong><span class="ne-text" style="color: var(--tw-prose-code); font-size: 16px">package.json</span></strong><span class="ne-text" style="color: rgb(13, 13, 13); font-size: 16px"> 文件，解析它并查找 </span><strong><span class="ne-text" style="color: var(--tw-prose-code); font-size: 16px">main</span></strong><span class="ne-text" style="color: rgb(13, 13, 13); font-size: 16px"> 属性指定的文件。如果没有 </span><strong><span class="ne-text" style="color: var(--tw-prose-code); font-size: 16px">package.json</span></strong><span class="ne-text" style="color: rgb(13, 13, 13); font-size: 16px"> 或 </span><strong><span class="ne-text" style="color: var(--tw-prose-code); font-size: 16px">main</span></strong><span class="ne-text" style="color: rgb(13, 13, 13); font-size: 16px"> 属性，Node.js 将尝试加载目录下的 </span><strong><span class="ne-text" style="color: var(--tw-prose-code); font-size: 16px">index.js</span></strong><span class="ne-text" style="color: rgb(13, 13, 13); font-size: 16px">。</span></li></ul></ul><ol start="4" class="ne-ol"><li id="ud869670e" data-lake-index-type="0"><strong><span class="ne-text" style="color: inherit">模块缓存：</span></strong><strong><span class="ne-text" style="color: rgb(13, 13, 13); text-decoration: underline; font-size: 16px">每个模块在第一次加载后都会被缓存</span></strong><strong><span class="ne-text" style="color: rgb(13, 13, 13); font-size: 16px">。这意味着无论 </span></strong><strong><span class="ne-text" style="color: var(--tw-prose-code); font-size: 16px">require</span></strong><strong><span class="ne-text" style="color: rgb(13, 13, 13); font-size: 16px"> 函数被调用多少次，模块都只会被执行一次，之后每次调用 </span></strong><strong><span class="ne-text" style="color: var(--tw-prose-code); font-size: 16px">require</span></strong><strong><span class="ne-text" style="color: rgb(13, 13, 13); font-size: 16px"> 都会返回相同的导出对象。这可以提高模块加载的效率并避免重复执行。</span></strong></li></ol><p id="ub8bd2792" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2024/png/1484158/1713686856056-e09f1385-f077-41ce-9654-35df227642e8.png" width="1051.6666248771896" id="ucca5dfe5" class="ne-image"></p><div data-type="success" class="ne-alert"><p id="u2578cb94" class="ne-p"><span class="ne-text">如果真有这种情况，可以手动清除缓存</span></p></div><p id="u79fbadea" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2024/png/1484158/1713687108307-31bb50b5-e8a7-408c-bff9-e0ba303edfdc.png" width="1179.9999531110147" id="u492b4df9" class="ne-image"></p><h3 id="R2Rv5"><span class="ne-text">1.5 ESM</span></h3><p id="u42e70505" class="ne-p"><span class="ne-text">ES模块（</span><code class="ne-code"><span class="ne-text">ECMAScript Modules</span></code><span class="ne-text">），通常简称为</span><code class="ne-code"><span class="ne-text">ESM</span></code><span class="ne-text">，是</span><code class="ne-code"><span class="ne-text">JavaScript</span></code><span class="ne-text">的官方标准模块系统。自</span><code class="ne-code"><span class="ne-text">ES6</span></code><span class="ne-text">（</span><code class="ne-code"><span class="ne-text">ECMAScript 2015</span></code><span class="ne-text">）开始，</span><code class="ne-code"><span class="ne-text">JavaScript</span></code><span class="ne-text">语言本身就内置了对模块的支持。</span></p><h4 id="ILTnS"><span class="ne-text">导入导出</span></h4><pre><code><code>const sum = (a, b) =&gt; a + b;export &#123; sum &#125;;</code></code></pre><pre><code><code>&lt;body&gt;  &lt;script type=&quot;module&quot;&gt;    import &#123; sum &#125; from &quot;./module-es.js&quot;;    console.warn(sum(2, 3));  &lt;/script&gt;&lt;/body&gt;</code></code></pre><h4 id="yXBi7"><span class="ne-text">模块加载机制</span></h4><ul class="ne-ul"><li id="ua71ecd45" data-lake-index-type="0"><span class="ne-text">静态结构：ES模块的一个关键特点是它们具有静态结构。这意味着import和export语句必须位于模块的顶层作用域，且不能动态生成或条件性地执行。这种静态结构使得模块的依赖关系在代码运行之前就已经确定，允许JavaScript引擎优化模块加载、解析和编译。</span></li><li id="ue67ee264" data-lake-index-type="0"><span class="ne-text">加载：浏览器环境，如果是结构化项目，可以直接引入，如果是script脚本引入需要添加type字段如上述例子；如果在nodejs环境，也需要在package.json文件中设置type字段，才能识别es模块的加载语法</span></li><li id="u5a313596" data-lake-index-type="0"><span class="ne-text">ES模块的加载是异步的。当模块被import时，它并不会立即执行，而是首先完成加载和解析过程，然后按照需要的顺序执行。这种方式适用于浏览器环境，因为它允许非阻塞的并行加载。</span></li></ul><pre><code><code>// 报错import &#123; 'f' + 'oo' &#125; from 'my_module';// 报错let module = 'my_module';import &#123; foo &#125; from module;// 报错if (x === 1) &#123;  import &#123; foo &#125; from 'module1';&#125; else &#123;  import &#123; foo &#125; from 'module2';&#125;</code></code></pre><p id="u2ad0417b" class="ne-p"><span class="ne-text" style="text-decoration: underline">那么怎么才能实现动态加载呢？</span></p><h4 id="zPPtV"><span class="ne-text">动态引入</span></h4><ol class="ne-ol"><li id="u4655a3ff" data-lake-index-type="0"><span class="ne-text" style="color: var(--tw-prose-bold); font-size: 16px">条件加载</span><span class="ne-text" style="color: rgb(13, 13, 13); font-size: 16px">：可以根据运行时条件来决定是否导入某个模块，这对于减少首次加载时间和优化性能非常有用。</span></li><li id="ue0dcbdca" data-lake-index-type="0"><span class="ne-text" style="color: var(--tw-prose-bold); font-size: 16px">代码分割和懒加载</span><span class="ne-text" style="color: rgb(13, 13, 13); font-size: 16px">：结合现代前端构建工具（如Webpack、Rollup或Parcel），</span><span class="ne-text" style="color: var(--tw-prose-code); font-size: 16px">import()</span><span class="ne-text" style="color: rgb(13, 13, 13); font-size: 16px">可以用于实现代码分割，按需加载模块，从而提高应用的启动速度和响应性。</span></li><li id="u8ac88f3d" data-lake-index-type="0"><span class="ne-text" style="color: var(--tw-prose-bold); font-size: 16px">与其他API和模块化功能集成</span><span class="ne-text" style="color: rgb(13, 13, 13); font-size: 16px">：</span><span class="ne-text" style="color: var(--tw-prose-code); font-size: 16px">import()</span><span class="ne-text" style="color: rgb(13, 13, 13); font-size: 16px">函数可以和其他Web API结合使用，如Service Workers、Web Workers、caches等。</span></li></ol><pre><code><code>&lt;body&gt;  &lt;script type=&quot;module&quot;&gt;    const loadModule = async () =&gt; &#123;      try &#123;        const module = await import(&quot;./module-es.js&quot;);        console.warn(module.sum(2, 3));      &#125; catch (error) &#123;        console.error(&quot;Module loading failed: &quot;, error);      &#125;    &#125;;    setTimeout(() =&gt; loadModule(), 3000);  &lt;/script&gt;&lt;/body&gt;</code></code></pre><h3 id="Gr6tE"><span class="ne-text">1.6 ESM 与 CommonJS 的差异</span></h3><ol class="ne-ol"><li id="u02b42acb" data-lake-index-type="0"><span class="ne-text">CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。</span></li></ol><ol class="ne-list-wrap"><ol ne-level="1" class="ne-ol"><li id="u8e67da09" data-lake-index-type="0"><span class="ne-text">CommonJS 模块输出的是值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。</span></li><li id="u8c698345" data-lake-index-type="0"><span class="ne-text">ES6 模块的运行机制与 CommonJS 不一样。JS 引擎对脚本静态分析的时候，遇到模块加载命令 import，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。因此，ES6 模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。</span></li></ol></ol><ol start="2" class="ne-ol"><li id="u037d88f1" data-lake-index-type="0"><span class="ne-text">CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。</span></li></ol><ol class="ne-list-wrap"><ol ne-level="1" class="ne-ol"><li id="u3aa7478b" data-lake-index-type="0"><span class="ne-text">运行时加载: CommonJS 模块就是对象；即在输入时是先加载整个模块，生成一个对象，然后再从这个对象上面读取方法，这种加载称为“运行时加载”。</span></li><li id="u046ab421" data-lake-index-type="0"><span class="ne-text">编译时加载: ES6 模块不是对象，而是通过 export 命令显式指定输出的代码， import 时采用静态命令的形式。即在 import 时可以指定加载某个输出值，而不是加载整个模块，这种加载称为“编译时加载”。</span></li></ol></ol><p id="u8962a1d8" class="ne-p"><span class="ne-text">CommonJS 加载的是一个对象（即 module.exports 属性），该对象只有在脚本运行完才会生成。而ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。</span></p><h2 id="LCC3F"><span class="ne-text">二、打包构建</span></h2><h3 id="o9csE"><span class="ne-text">2.1 构建工具</span></h3><p id="u57e8119b" class="ne-p"><span class="ne-text">实现各种环境下都能使用模块化代码，需要使用打包工具来对一套代码进行打包，打包工具主流有：</span></p><ol class="ne-ol"><li id="ubd0fe9cd" data-lake-index-type="0"><span class="ne-text">webpack：适合应用类打包，可以进行详细配置和复杂构建过程的大型项目</span></li><li id="u098a1915" data-lake-index-type="0"><span class="ne-text">vite：适合工具类以及SDK打包，更加适合现代化web应用</span></li></ol><p id="u57cd382c" class="ne-p"><span class="ne-text">本文暂不详述webpack和vite的差异，只针对模块化构建目标做一个概括，所以选用vite来构建一个在所有环境可使用的一个SDK。</span></p><div data-type="info" class="ne-alert"><p id="u58e47bfd" class="ne-p"><span class="ne-text">UMD：并不是一种全新的模块系统，而是整合了无模块化、AMD、CommonJS三种模块规范，其可以在任何环境下工作</span></p></div><h3 id="nf2o8"><span class="ne-text">2.2 利用Vite构建一个SDK</span></h3><p id="u2ee246c1" class="ne-p"><span class="ne-text">目标构建一个node环境和浏览器环境都可以使用的sdk</span></p><p id="u0fd32f7a" class="ne-p"><span class="ne-text"></span></p><p id="u6a1c05c0" class="ne-p"><code class="ne-code"><span class="ne-text">src/inde.js</span></code></p><pre><code><code>const sum = (a, b) =&gt; a + b;export default sum;</code></code></pre><p id="u9ea52a2c" class="ne-p"><code class="ne-code"><span class="ne-text">vite.config.js</span></code></p><pre><code><code>import &#123; defineConfig &#125; from &quot;vite&quot;;import path from &quot;path&quot;;export default defineConfig(&#123;  build: &#123;    lib: &#123;      entry: path.resolve(__dirname, &quot;src/index.js&quot;),      formats: [&quot;es&quot;, &quot;cjs&quot;, &quot;umd&quot;],      name: &quot;sdk&quot;,      fileName: (format) =&gt; `sdk.$&#123;format&#125;.js`,    &#125;,  &#125;,&#125;);</code></code></pre><div data-type="info" class="ne-alert"><p id="ua4d209c5" class="ne-p"><span class="ne-text">在vite中构建多环境依赖只需要上述少量代码即可配置，配置了输出sdk的全局命名以及文件命名等配置，更多配置：</span></p><p id="u6ba9fe8a" class="ne-p"><a href="https://cn.vitejs.dev/config/build-options.html" data-href="https://cn.vitejs.dev/config/build-options.html" target="_blank" class="ne-link"><span class="ne-text">https://cn.vitejs.dev/config/build-options.html</span></a></p></div><p id="u91a8b9a8" class="ne-p"><span class="ne-text">上述代码打包后的结果：</span></p><p id="u6184151b" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2024/png/1484158/1713692148011-07df10e5-bdee-497e-b34e-6567dcbdeccf.png" width="468.3333147234394" id="u51639301" class="ne-image"></p><h3 id="NFWW6"><span class="ne-text">2.3 在不同环境使用SDK</span></h3><p id="u77c9515f" class="ne-p"><span class="ne-text">浏览器环境使用：</span></p><pre><code><code>&lt;body&gt;  &lt;script src=&quot;./dist/sdk.umd.js&quot;&gt;&lt;/script&gt;  &lt;script&gt;    console.info(sdk);    console.warn(sdk(1, 2));  &lt;/script&gt;&lt;/body&gt;</code></code></pre><p id="u8951749c" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2024/png/1484158/1713692332909-7b8a8817-4d75-4d6c-96e6-c533b07278b8.png" width="209.99999165535007" id="u0d704305" class="ne-image"></p><p id="u6a4086e8" class="ne-p"><code class="ne-code"><span class="ne-text">node</span></code><span class="ne-text">环境使用：</span></p><pre><code><code>const sum = require(&quot;./dist/sdk.cjs.js&quot;);console.warn(sum(1, 2));</code></code></pre><p id="u7daf9451" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2024/png/1484158/1713692473725-cf5a5b43-38f1-4b73-ac8e-683f72e521cb.png" width="484.16664742761265" id="u1c2df2db" class="ne-image"></p><p id="u078824a5" class="ne-p"><code class="ne-code"><span class="ne-text">node</span></code><span class="ne-text">环境（根目录package.json文件中指定</span><code class="ne-code"><span class="ne-text">type</span></code><span class="ne-text">字段为</span><code class="ne-code"><span class="ne-text">module</span></code><span class="ne-text">）使用：</span></p><pre><code><code>import sum from &quot;./dist/sdk.es.js&quot;;console.warn(sum(1, 2));</code></code></pre><p id="u58d842aa" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2024/png/1484158/1713692593519-9b05da4c-323a-4dfb-b2b8-61d97506aab3.png" width="485.8333140280519" id="u098f7f53" class="ne-image"></p></div>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;!doctype html&gt;&lt;div class=&quot;lake-content&quot; typography=&quot;classic&quot;&gt;&lt;p id=&quot;u9dfc8a71&quot; class=&quot;ne-p&quot;&gt;&lt;span</summary>
        
      
    
    
    
    <category term="Web开发" scheme="https://www.wztlink1013.com/categories/Web%E5%BC%80%E5%8F%91/"/>
    
    <category term="Node.js" scheme="https://www.wztlink1013.com/categories/Web%E5%BC%80%E5%8F%91/Node-js/"/>
    
    
  </entry>
  
  <entry>
    <title>Vue3源码debugger：reactivity响应式原理</title>
    <link href="https://www.wztlink1013.com/blog/iy7gxmvmskcnwupd/"/>
    <id>https://www.wztlink1013.com/blog/iy7gxmvmskcnwupd/</id>
    <published>2024-04-02T16:52:34.000Z</published>
    <updated>2024-04-07T17:22:56.000Z</updated>
    
    <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="u267dc279" class="ne-p"><span class="ne-text">前言：本文讲述vue源码中的reactivity模块，也就是响应式核心模块。</span></p><div data-type="color1" class="ne-alert"><p id="ua4a1beec" class="ne-p"><span class="ne-text">建议先看如下文章：</span></p><ul class="ne-ul"><li id="u3fee6312" data-lake-index-type="0"><a href="https://www.yuque.com/wztlink1013/blog/wfb1ntb84h9g0g67" data-href="https://www.yuque.com/wztlink1013/blog/wfb1ntb84h9g0g67" class="ne-link"><span class="ne-text">Vue3源码debugger：createApp以及mount挂载</span></a></li></ul></div><h2 id="XOvda"><span class="ne-text">applyOptions</span></h2><p id="u86228361" class="ne-p"><span class="ne-text">在组件的一系列初始化之后，来到参数初始化（applyOptions）</span></p><p id="u2109307d" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2024/png/1484158/1712125601076-cbdf8b73-ab8a-4692-b49a-827da275adfe.png" width="598" id="ua022304f" class="ne-image"></p><p id="u7d0c79e1" class="ne-p"><code class="ne-code"><span class="ne-text">applyOptions</span></code><span class="ne-text">方法中，将传入的各个“选项”进行初始化构建，负责将组件的各种选项（如data、computed、methods、生命周期等）应用到组件实例上</span></p><p id="ue43be8ca" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2024/png/1484158/1712481080603-7a8683c8-af1e-441d-aed2-870e14d1f2ae.png" width="1418" id="ub9df671c" class="ne-image"></p><p id="u35648f9d" class="ne-p"><span class="ne-text">我们例子是一个选项式API的代码，按照上面截图的代码，传入的“data选项”就被</span><code class="ne-code"><span class="ne-text">reactive</span></code><span class="ne-text">响应化了，下面具体看下</span><code class="ne-code"><span class="ne-text">reactive</span></code><span class="ne-text">内部的构建逻辑。</span></p><h2 id="RgUMZ"><span class="ne-text">reactive</span></h2><p id="u1db45c2f" class="ne-p"><span class="ne-text">然后debugger进入</span><code class="ne-code"><span class="ne-text">reactive</span></code><span class="ne-text">方法中，看看到底是如何响应式构建的。</span></p><p id="u023a7598" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2024/png/1484158/1712106836226-d2186038-5589-4d60-926f-ea39e064d1b2.png" width="850" id="u6db9d80a" class="ne-image"></p><ul class="ne-ul"><li id="uc36a192f" data-lake-index-type="0"><span class="ne-text">首先判断上述传入的值是否为只读类型（也就是通过</span><code class="ne-code"><span class="ne-text">readonly()</span></code><span class="ne-text">设置的变量</span><a href="https://cn.vuejs.org/api/reactivity-core.html#readonly" data-href="https://cn.vuejs.org/api/reactivity-core.html#readonly" target="_blank" class="ne-link"><span class="ne-text">https://cn.vuejs.org/api/reactivity-core.html#readonly</span></a><span class="ne-text">）</span></li><li id="u1ec8f271" data-lake-index-type="0"><span class="ne-text">上述所传入的参数中，第三第四个都是代理处理函数，最后一个参数是全局Map依赖，具体如下</span></li></ul><p id="ub002dc6e" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2024/png/1484158/1712108451471-b932cd7c-42c9-478f-ae28-d57592f91226.png" width="811" id="u9f11633f" class="ne-image"></p><h2 id="OnY8T"><span class="ne-text">createReactiveObject</span></h2><p id="u1a8b3167" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2024/png/1484158/1712107099097-e9ff57db-3195-4fbc-9dd7-30c1d45345cd.png" width="1673" id="u8b7fcb39" class="ne-image"></p><p id="u98e5fe07" class="ne-p"><span class="ne-text">上述</span><code class="ne-code"><span class="ne-text">createReactiveObject</span></code><span class="ne-text">方法就是构建核心代码，具体看看内部逻辑</span></p><div data-type="info" class="ne-alert"><p id="u152e04d4" class="ne-p"><code class="ne-code"><span class="ne-text">Proxy</span></code><span class="ne-text">是一个JavaScript全局方法，代理一个对象，简单理解就是当获取这个对象的属性值或者给这个对象设置值都可以拦截二次处理，详细可以查看以下文档：</span></p><p id="uefacf100" class="ne-p"><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy" data-href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy" target="_blank" class="ne-link"><span class="ne-text">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy</span></a></p></div><ul class="ne-ul"><li id="uaabd1b1d" data-lake-index-type="0"><span class="ne-text">275行代码是响应式核心：条件判断的两个函数，这两个是对</span><code class="ne-code"><span class="ne-text">data</span></code><span class="ne-text">原对象的代理拦截处理方法</span></li></ul><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="uf0327407" data-lake-index-type="0"><code class="ne-code"><span class="ne-text">collectionHandlers</span></code><span class="ne-text"></span></li><li id="u7c3ec960" data-lake-index-type="0"><code class="ne-code"><span class="ne-text">baseHandlers</span></code><span class="ne-text"></span></li></ul></ul><ul class="ne-ul"><li id="ubd917d68" data-lake-index-type="0"><span class="ne-text">277行代码中的</span><code class="ne-code"><span class="ne-text">proxyMap</span></code><span class="ne-text">，也就是</span><code class="ne-code"><span class="ne-text">reactive</span></code><span class="ne-text">主文件下的一个全局Map，主要用于依赖收集等工作</span></li></ul><p id="ue221d7ae" class="ne-p"><span class="ne-text">这个函数执行完以后，响应式的初始化构建就完成了（选项式API中的data），接下来具体看下上述的两个代理拦截处理方法。</span></p><h3 id="HRMHY"><span class="ne-text">baseHandlers</span></h3><p id="u0692cae4" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2024/png/1484158/1712109045560-dbc61208-6344-46a4-95f6-dd7db134006b.png" width="226" id="uca8df99d" class="ne-image"><img src="https://cdn.nlark.com/yuque/0/2024/png/1484158/1712109081362-04e18dfe-e5d9-428d-ac77-94460e57fd7e.png" width="578" id="u41c4ea48" class="ne-image"></p><p id="u06c312e5" class="ne-p"><span class="ne-text">根据上述判断条件，我们先分析</span><code class="ne-code"><span class="ne-text">baseHandlers</span></code><span class="ne-text">拦截方法</span></p><p id="u0e658ce9" class="ne-p"><span class="ne-text">Proxy内部进不去，所以我们直接在</span><code class="ne-code"><span class="ne-text">baseHandlers</span></code><span class="ne-text">方法中设置断点</span></p><p id="uc9a8f13e" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2024/png/1484158/1712109304983-b9112da4-55c9-4c2f-9feb-61be6d61d997.png" width="1576" id="u27e5f549" class="ne-image"></p><p id="u065fdab2" class="ne-p"><span class="ne-text">具体的</span><code class="ne-code"><span class="ne-text">MutableReactiveHandler</span></code><span class="ne-text">类如下：</span></p><p id="ufe5a7d5f" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2024/png/1484158/1712109633440-fac53b9e-da5d-4ab1-b071-fb221d9513c7.png" width="769" id="u361eb6cd" class="ne-image"></p><div data-type="info" class="ne-alert"><p id="u382fb7d3" class="ne-p"><code class="ne-code"><span class="ne-text">Reflect</span></code><span class="ne-text">可以简单理解为操作对象，可以设置值，取值等操作，具体详见：</span></p><p id="uda42b8f5" class="ne-p"><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect" data-href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect" target="_blank" class="ne-link"><span class="ne-text">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect</span></a></p></div><h4 id="oMkd3"><span class="ne-text">get（依赖收集（track））</span></h4><p id="ucb400434" class="ne-p"><span class="ne-text">在</span><code class="ne-code"><span class="ne-text">BaseReactiveHandler</span></code><span class="ne-text">中的</span><code class="ne-code"><span class="ne-text">get</span></code><span class="ne-text">方法中：</span></p><p id="u94723c1a" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2024/png/1484158/1712125173379-4254091b-85aa-4faa-8ab2-83123ccf68e5.png" width="692" id="I87oN" class="ne-image"></p><ul class="ne-ul"><li id="u535b20fc" data-lake-index-type="0"><span class="ne-text">159行代码递归实现深层对象的响应化：</span><strong><span class="ne-text">当对象是一个深层嵌套对象，在这行代码则使用了递归来实现，当然，vue通过对当前代理是否为只读状态（</span></strong><code class="ne-code"><strong><span class="ne-text">isReadonly</span></strong></code><strong><span class="ne-text">）来优化是否继续递归</span></strong></li><li id="udabb0544" data-lake-index-type="0"><span class="ne-text">143行代码依赖收集（track）：是父类get方法里面的依赖收集方法，它记录下当前执行的副作用函数依赖了哪些数据。这是通过全局的</span><code class="ne-code"><span class="ne-text">activeEffect</span></code><span class="ne-text">和数据特定的依赖列表（Dep）来实现的。每当副作用函数访问一个响应式数据时，就会将这个副作用函数添加到该数据的依赖列表中。</span></li></ul><p id="uce1b757e" class="ne-p"><span class="ne-text">同样进入track函数：</span></p><p id="ud45bf4ec" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2024/png/1484158/1712538587293-69fc1f1e-b101-4e4a-b647-34457cc5bec1.png" width="1296" id="u67747caf" class="ne-image"></p><ul class="ne-ul"><li id="ue5e6eba7" data-lake-index-type="0"><span class="ne-text">获取或创建依赖集合（</span><code class="ne-code"><span class="ne-text">dep</span></code><span class="ne-text">）：接着，尝试从</span><code class="ne-code"><span class="ne-text">depsMap</span></code><span class="ne-text">中获取当前属性的依赖集合。如果这个属性还没有对应的依赖集合，就创建一个新的</span><code class="ne-code"><span class="ne-text">Set</span></code><span class="ne-text">来存储依赖于这个属性的所有副作用，并将其添加到</span><code class="ne-code"><span class="ne-text">depsMap</span></code><span class="ne-text">中。</span></li></ul><p id="ued0a673d" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2024/png/1484158/1712116379335-0b15e042-19b4-4aab-94b4-220688557cea.png" width="1021" id="zI7cR" class="ne-image"></p><ul class="ne-ul"><li id="u9208150f" data-lake-index-type="0"><span class="ne-text">跟踪副作用：最后，调用</span><code class="ne-code"><span class="ne-text">trackEffect</span></code><span class="ne-text">函数将当前的</span><code class="ne-code"><span class="ne-text">activeEffect</span></code><span class="ne-text">添加到dep中。这表明当前正在执行的副作用函数依赖于访问的属性。</span><code class="ne-code"><span class="ne-text">trackEffect</span></code><span class="ne-text">函数还负责处理一些额外的逻辑，比如避免重复跟踪同一个副作用，以及在开发模式下提供额外的调试信息。</span></li></ul><h4 id="KaKaJ"><span class="ne-text">set（触发更新（trigger））</span></h4><p id="u12bc462e" class="ne-p"><strong><span class="ne-text">当响应式变量被改变会走该部分代码</span></strong></p><p id="u0ffe5b53" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2024/png/1484158/1712111387194-124f7f2b-4b20-4139-a31c-2dd4cd26276d.png" width="796" id="u9d9262b8" class="ne-image"></p><ul class="ne-ul"><li id="uf5e32962" data-lake-index-type="0"><span class="ne-text">触发更新（</span><code class="ne-code"><span class="ne-text">trigger</span></code><span class="ne-text">）：核心是上面204行代码（新增）和206行代码（更新），可以理解成副作用函数，当响应式变量更新或者新增响应式变量，会查找该数据的依赖列表，找到所有依赖于这个数据的副作用函数，并重新执行它们，以响应数据的变化，比如组件的渲染函数或计算属性，</span><code class="ne-code"><span class="ne-text">trigger</span></code><span class="ne-text">确保了当数据更新时，所有依赖于这些数据的视图或计算值也会相应地被更新</span></li></ul><p id="u12490039" class="ne-p"><span class="ne-text"></span></p><p id="u6fa67540" class="ne-p"><span class="ne-text">我们通过试图改变这个响应式变量，点击</span><code class="ne-code"><span class="ne-text">v2-compat</span></code><span class="ne-text">选项通过试图改变响应式变量，会走进206代码的debugger</span></p><p id="uddcb71e2" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2024/png/1484158/1712113682383-f4c9c0a6-0c7d-45c9-a40d-aabbf0e869ba.png" width="1058" id="u2b614618" class="ne-image"></p><p id="u7339b617" class="ne-p"><span class="ne-text">贴上对应视图层源码部分</span></p><p id="uaaac86b2" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2024/png/1484158/1712114126294-4d9deaa8-8870-4e8b-a26d-280a724136ec.png" width="914" id="uad81ad94" class="ne-image"></p><p id="ucf1f7802" class="ne-p"><span class="ne-text">然后</span><code class="ne-code"><span class="ne-text">F9</span></code><span class="ne-text">走进以下的</span><code class="ne-code"><span class="ne-text">trigger</span></code><span class="ne-text">函数中看下源码</span></p><p id="u949725d4" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2024/png/1484158/1712114217954-d0fb0800-4ca7-47e0-90e6-c0c5a4dae0eb.png" width="1384" id="u84fe7c87" class="ne-image"></p><ul class="ne-ul"><li id="ucb92e793" data-lake-index-type="0"><span class="ne-text">参数部分</span></li></ul><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="u111a7450" data-lake-index-type="0"><code class="ne-code"><span class="ne-text">target</span></code><span class="ne-text">：触发更新的响应式对象</span></li><li id="u10050c48" data-lake-index-type="0"><code class="ne-code"><span class="ne-text">type</span></code><span class="ne-text">：触发更新的操作类型，在这里是</span><code class="ne-code"><span class="ne-text">set</span></code></li><li id="ud36bffdb" data-lake-index-type="0"><code class="ne-code"><span class="ne-text">key</span></code><span class="ne-text">：被操作的目标属性的键</span></li><li id="u77e98877" data-lake-index-type="0"><code class="ne-code"><span class="ne-text">newValue</span></code><span class="ne-text">：新值</span></li><li id="ua3e09cc9" data-lake-index-type="0"><code class="ne-code"><span class="ne-text">oldValue</span></code><span class="ne-text">：旧值</span></li><li id="u9f02901a" data-lake-index-type="0"><code class="ne-code"><span class="ne-text">oldTarget</span></code><span class="ne-text">：暂不知道这旧集合对象的用处(TODO: )</span></li></ul></ul><ul class="ne-ul"><li id="u8509782a" data-lake-index-type="0"><span class="ne-text">73行代码：获取依赖映射</span></li></ul><p id="u31a46695" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2024/png/1484158/1712114667271-99122359-5f7b-4ca4-9332-bc6aa86b6b70.png" width="458" id="ua3663b13" class="ne-image"></p><ul class="ne-ul"><li id="u2a9f6530" data-lake-index-type="0"><span class="ne-text">79行代码：定义需要被触发的依赖集合</span><code class="ne-code"><span class="ne-text">deps</span></code></li><li id="u3251a2c2" data-lake-index-type="0"><span class="ne-text">80行到124行代码：最终确定依赖集合</span></li></ul><p id="u6af2d321" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2024/png/1484158/1712115187468-775e092c-84ce-470d-b239-881f2f1660c9.png" width="613" id="u97545722" class="ne-image"></p><ul class="ne-ul"><li id="u2c3a2042" data-lake-index-type="0"><span class="ne-text">其中126行代码和145行代码的</span><code class="ne-code"><span class="ne-text">pauseScheduling</span></code><span class="ne-text">和</span><code class="ne-code"><span class="ne-text">resetScheduling</span></code><span class="ne-text">函数：用于控制副作用（</span><code class="ne-code"><span class="ne-text">effects</span></code><span class="ne-text">）触发的调度行为，设计目的是为了提高性能和避免不必要的重复计算，尤其是在一次性执行多个响应式状态更新时。它们通过暂停和重置调度器（</span><code class="ne-code"><span class="ne-text">scheduler</span></code><span class="ne-text">）的运行状态，允许Vue批量处理响应式状态的更新，然后统一触发副作用的执行。</span></li><li id="u977a605c" data-lake-index-type="0"><span class="ne-text">127行代码：触发副作用，核心则是</span><code class="ne-code"><span class="ne-text">triggerEffects</span></code><span class="ne-text">方法</span></li></ul><p id="u6b290106" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2024/png/1484158/1712480506600-5282da50-5673-4b70-81b4-9e69a7897fb1.png" width="523" id="u4baded74" class="ne-image"></p><h4 id="FCMu8"><span class="ne-text">deleteProperty，has，ownKeys</span></h4><p id="u49cc84b7" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2024/png/1484158/1712122038151-18fab429-445f-48e9-98df-10147c0f7efe.png" width="664" id="u2a6c9620" class="ne-image"></p><p id="u8bce6e1d" class="ne-p"><span class="ne-text">这三个方法分别用于拦截对象属性的删除、属性检查和键的枚举操作，具体也就是二次添加了触发更新/依赖收集的处理拦截方法，比如：</span></p><pre><code><code>const &#123; reactive, effect &#125; = Vue;<p>const obj = reactive(&#123;<br>  name: ‘Vue’,<br>  version: ‘3.0’<br>&#125;);</p><p>effect(() =&gt; &#123;<br>  console.log(<code>The name is: $&#123;obj.name&#125;</code>);<br>});</p><p>// 删除属性前，effect 会打印: &quot;The name is: Vue&quot;<br>delete obj.name;<br>// 删除属性后，由于响应式系统的deleteProperty拦截，effect 会再次执行<br>// 打印: &quot;The name is: undefined&quot;</code><br></code></pre></p><h3 id="wXhQi"><span class="ne-text">collectionHandlers</span></h3><p id="u28ab6446" class="ne-p"><span class="ne-text">回到</span><code class="ne-code"><span class="ne-text">createReactiveObject</span></code><span class="ne-text">方法中，上面调用</span><code class="ne-code"><span class="ne-text">baseHandlers</span></code><span class="ne-text">是一个简单的选项式api下的</span><code class="ne-code"><span class="ne-text">data</span></code><span class="ne-text">数据，那么什么情况下会执行</span><code class="ne-code"><span class="ne-text">collectionHandlers</span></code><span class="ne-text">拦截方法呢？</span></p><p id="u40ef15dc" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2024/png/1484158/1712122854863-5fcc4745-1f88-4772-8dff-687b560cc92d.png" width="693" id="u7434eda4" class="ne-image"></p><p id="uaf3f5dea" class="ne-p"><span class="ne-text">可以看到上述269行代码，貌似是获取target的类型</span></p><p id="ucb8cd467" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2024/png/1484158/1712123056396-8c0fe707-2ecf-4c15-a5e3-2b7a98077115.png" width="507" id="u8d0c141b" class="ne-image"></p><p id="u0d2adca5" class="ne-p"><span class="ne-text">所以我们得到：collectionHandlers是专门用于处理Map、Set、WeakMap和WeakSet这类集合类型的响应式操作的处理程序集。这些处理程序通过代理（Proxy）机制拦截对这些集合的操作，如添加、删除元素，以及遍历集合等操作，从而使得集合的操作也成为响应式的。</span></p><p id="ue1197d67" class="ne-p"><span class="ne-text">具体进入到</span><code class="ne-code"><span class="ne-text">collectionHandlers</span></code><span class="ne-text">方法中：</span></p><p id="u46d3d07e" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2024/png/1484158/1712123383020-783683e3-ec13-44ac-845e-71a936181125.png" width="674" id="u4ba2e40c" class="ne-image"></p><p id="u289de11b" class="ne-p"><code class="ne-code"><span class="ne-text">collectionHandlers</span></code><span class="ne-text">的执行时机与集合类型的响应式代理创建和集合操作紧密相关，它确保了集合的响应式操作能够触发视图更新和副作用函数的执行，是Vue 3响应式系统支持集合类型的关键机制</span></p><ul class="ne-ul"><li id="u26b51a09" data-lake-index-type="0"><span class="ne-text">340行代码参数部分</span></li></ul><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="u696ac196" data-lake-index-type="0"><span class="ne-text">isReadonly：如果为true，则创建的响应式代理将是只读的，否则是可写的</span></li><li id="uf02cede3" data-lake-index-type="0"><span class="ne-text">shallow：如果为true，则创建的响应式代理将是浅响应式的，否则是深响应式的</span></li></ul></ul><ul class="ne-ul"><li id="ub236528d" data-lake-index-type="0"><span class="ne-text">341行代码根据340行的两个参数最终得到的</span><code class="ne-code"><span class="ne-text">instrumentations</span></code><span class="ne-text">对象，这个就是最后实现的代理函数</span></li></ul><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="u751c11e1" data-lake-index-type="0"><span class="ne-text">可以从截图看到这种类型的代理实现比普通对象来的简单</span></li></ul></ul><p id="uc8b184ee" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2024/png/1484158/1712123921661-cdebabc4-5d61-43f0-a8f0-f067ebcf6126.png" width="296" id="u7598f194" class="ne-image"></p><ul class="ne-ul"><li id="u1c832036" data-lake-index-type="0"><span class="ne-text">372行代码</span><code class="ne-code"><span class="ne-text">collectionHandlers</span></code><span class="ne-text">通过</span><code class="ne-code"><span class="ne-text">createInstrumentationGetter</span></code><span class="ne-text">函数生成的get拦截器管理了对集合的响应式访问和修改</span></li></ul><h2 id="TN9El"><span class="ne-text">end</span></h2><p id="u93f82dfa" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2024/png/1484158/1712124133588-a93136c8-de0f-49c1-b874-998302accc50.png" width="884" id="uf631d520" class="ne-image"></p><p id="u3abc1797" class="ne-p"><span class="ne-text">至此，响应式对象的构建流程就结束了。</span></p><div class="ne-quote"><p id="ud42d130f" class="ne-p"><span class="ne-text">上述的很多细节（方法的具体实现）以及暴露出去的接口（computed、watch等）还可以进一步分析代码。</span></p></div><p id="u733faba7" class="ne-p"><span class="ne-text"></span></p><p id="uf4f69eb9" class="ne-p"><span class="ne-text"></span></p><p id="uc8cf6790" class="ne-p"><span class="ne-text"></span></p><p id="u30614a0b" class="ne-p"><span class="ne-text"></span></p><p id="u30516c83" class="ne-p"><span class="ne-text"></span></p><p id="uaf4e111b" class="ne-p"><span class="ne-text"></span></p><p id="ua9329610" class="ne-p"><span class="ne-text"></span></p><p id="ud3ca6f66" class="ne-p"><span class="ne-text"></span></p><p id="u0028496a" class="ne-p"><span class="ne-text"></span></p><p id="u991c8018" class="ne-p"><span class="ne-text"></span></p></div>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;!doctype html&gt;&lt;div class=&quot;lake-content&quot; typography=&quot;classic&quot;&gt;&lt;p id=&quot;u267dc279&quot; class=&quot;ne-p&quot;&gt;&lt;span</summary>
        
      
    
    
    
    <category term="Web开发" scheme="https://www.wztlink1013.com/categories/Web%E5%BC%80%E5%8F%91/"/>
    
    <category term="Vue" scheme="https://www.wztlink1013.com/categories/Web%E5%BC%80%E5%8F%91/Vue/"/>
    
    
  </entry>
  
  <entry>
    <title>Vue3源码debugger：createApp以及mount挂载</title>
    <link href="https://www.wztlink1013.com/blog/wfb1ntb84h9g0g67/"/>
    <id>https://www.wztlink1013.com/blog/wfb1ntb84h9g0g67/</id>
    <published>2024-04-02T06:03:31.000Z</published>
    <updated>2024-04-06T17:48:23.000Z</updated>
    
    <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="ua2aa3cc8" class="ne-p"><span class="ne-text">前言：本文探讨Vue3框架中createApp函数与mount方法的大致工作机制。首先介绍深入源码的工具和方式，而后介绍vue源码项目架构，最后详述vue创建实例应用的大致流程。</span></p><h2 id="XUC4H"><span class="ne-text">一、前序</span></h2><h3 id="bdmeL"><span class="ne-text">调试准备</span></h3><p id="uc4287a82" class="ne-p"><span class="ne-text">拒绝采用花里胡哨的调试方法，通过浏览器debugger调试的第一视角，了解代码的执行机制：</span></p><ol class="ne-ol"><li id="u7fd7ab92" data-lake-index-type="0"><span class="ne-text" style="color: #333333; font-size: 16px">vue3源码地址：</span><a href="https://github.com/vuejs/core" data-href="https://github.com/vuejs/core" target="_blank" class="ne-link"><span class="ne-text">https://github.com/vuejs/core</span></a><span class="ne-text">，</span><code class="ne-code"><span class="ne-text">git clone</span></code><span class="ne-text">到本地，然后执行下面命令即可</span></li></ol><pre><code><code>pnpm ipnpm dev</code></code></pre><ol start="2" class="ne-ol"><li id="u479a56e7" data-lake-index-type="0"><code class="ne-code"><span class="ne-text">Live Server</span></code><span class="ne-text">：vscode下这个插件，目的是运行html文件并提供热更新作用</span></li></ol><p id="u10a05f2a" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2024/png/1484158/1712371463292-ef435c64-0cc5-4c23-9151-f3fd932699ca.png" width="404.1666506065269" id="u12350374" class="ne-image"></p><ol start="3" class="ne-ol"><li id="u114b4ffe" data-lake-index-type="0"><span class="ne-text">会使用浏览器debugger功能，比较常用的有以下几点</span></li></ol><ol class="ne-list-wrap"><ol ne-level="1" class="ne-ol"><li id="u081e25a3" data-lake-index-type="0"><span class="ne-text">定位源码区域，可以自行设置断点</span></li><li id="ufc510439" data-lake-index-type="0"><span class="ne-text">变量区域，可以了解执行区域函数里面的具体变量值</span></li><li id="u26f75b8d" data-lake-index-type="0"><span class="ne-text">调用栈，可以回溯调用</span></li><li id="uc9496830" data-lake-index-type="0"><span class="ne-text">命令调试</span></li></ol></ol><div data-type="color1" class="ne-alert"><p id="ue57dc0c8" class="ne-p"><strong><span class="ne-text">F8：下一个断点处</span></strong></p><p id="u6b3024c2" class="ne-p"><strong><span class="ne-text">F9：下一步如果是调用函数，则进入函数内</span></strong></p><p id="u7ed85631" class="ne-p"><strong><span class="ne-text">F10：下一步如果是调用函数，则跳过函数</span></strong></p><p id="ua90b5cbd" class="ne-p"><span class="ne-text">F11：和F9作用几乎一致，执行异步代码会进入，F9不会</span></p><p id="uf092a500" class="ne-p"><strong><span class="ne-text">Shift+F11：跳出当前函数</span></strong></p></div><p id="u075f15b6" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2024/png/1484158/1712371618094-f1eacbc7-8667-48f9-97ba-07e3810ffb21.png" width="1358.3332793580182" id="u5fb360d2" class="ne-image"></p><h3 id="lwGN6"><span class="ne-text">源码结构</span></h3><p id="u45dd5718" class="ne-p"><span class="ne-text" style="color: #333333; font-size: 16px">项目结构为</span><code class="ne-code"><span class="ne-text" style="color: #333333; font-size: 16px">monorepo</span></code><span class="ne-text" style="color: #333333; font-size: 16px">架构方式，更加合理组织项目核心模块</span></p><p id="u54a5988c" class="ne-p" style="text-align: left"><img src="https://cdn.nlark.com/yuque/0/2024/png/1484158/1712216905265-36301738-43aa-445e-b377-064c3ea501c9.png" width="529.999978939693" id="u95b68d9b" class="ne-image"></p><ol class="ne-ol"><li id="u572c439a" data-lake-index-type="0" style="text-align: left"><span class="ne-text">compiler模块：编译</span></li></ol><ol class="ne-list-wrap"><ol ne-level="1" class="ne-ol"><li id="ua2c4efbe" data-lake-index-type="0" style="text-align: left"><span class="ne-text">compiler-core：核心编译模块</span></li><li id="udf95f21f" data-lake-index-type="0" style="text-align: left"><span class="ne-text">compiler-dom：依赖compiler-core，处理template标签的，将template内容编译成render函数</span></li><li id="ue3ca0ea1" data-lake-index-type="0" style="text-align: left"><span class="ne-text">compiler-sfc：解析vue文件</span></li><li id="ue53f176a" data-lake-index-type="0" style="text-align: left"><span class="ne-text">compiler-ssr：服务端编译相关</span></li></ol></ol><ol start="2" class="ne-ol"><li id="u62f7c44d" data-lake-index-type="0" style="text-align: left"><span class="ne-text">reactivity模块：响应式核心。（通过子包的形式，可以脱离vue环境，单独使用）</span></li><li id="u301ffb19" data-lake-index-type="0" style="text-align: left"><span class="ne-text">runtime模块：运行时</span></li><li id="ucca470d1" data-lake-index-type="0" style="text-align: left"><span class="ne-text">server-renderer：服务端渲染相关</span></li><li id="uc01253fd" data-lake-index-type="0" style="text-align: left"><span class="ne-text">temaplate-explorer：查看模板编译结果</span></li><li id="u4358586e" data-lake-index-type="0" style="text-align: left"><span class="ne-text">shared：公共方法</span></li><li id="u11d7ffa3" data-lake-index-type="0" style="text-align: left"><span class="ne-text">vue：框架集成入口</span></li></ol><h2 id="DsMHQ"><span class="ne-text" style="color: #333333">二、创建应用</span></h2><p id="uc56819f0" class="ne-p"><span class="ne-text">vue选项式api创建一个应用</span></p><p id="u4737487f" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2024/png/1484158/1712126896383-f745e671-d552-4063-9fe7-0c82b12813bc.png" width="265" id="ua27dc0b4" class="ne-image"></p><p id="u1865a270" class="ne-p" style="text-align: left"><span class="ne-text" style="color: #333333; font-size: 16px">Vue通过</span><code class="ne-code"><span class="ne-text" style="color: #333333; font-size: 16px">createApp</span></code><span class="ne-text" style="color: #333333; font-size: 16px">初始化一个Vue实例，然后通过实例方法</span><code class="ne-code"><span class="ne-text" style="color: #333333; font-size: 16px">mount</span></code><span class="ne-text" style="color: #333333; font-size: 16px">挂载组件。</span></p><p id="ub1e9b32a" class="ne-p" style="text-align: left"><span class="ne-text" style="color: #333333; font-size: 16px">通过debugger可以走到该部分代码</span></p><p id="ua21530dc" class="ne-p" style="text-align: left"><img src="https://cdn.nlark.com/yuque/0/2024/png/1484158/1712066661279-67a212a3-7055-4047-9870-258311886d02.png" width="1596" id="uf8060ed4" class="ne-image"></p><h3 id="vyWsN"><span class="ne-text">ensureRenderer</span></h3><p id="uf7db06bc" class="ne-p"><span class="ne-text">F9进入</span><code class="ne-code"><span class="ne-text">ensureRenderer</span></code><span class="ne-text">函数内部：</span></p><p id="u0f3298b0" class="ne-p" style="text-align: left"><img src="https://cdn.nlark.com/yuque/0/2024/png/1484158/1712066661237-4175bb01-c00e-4ba1-932d-fe888212f4f0.png" width="965" id="u0c42554b" class="ne-image"></p><p id="u2ab53ed1" class="ne-p"><span class="ne-text" style="color: #333333; font-size: 16px">其主要功能就是核心渲染相关，负责根据当前运行环境创建一个适合的渲染器：</span></p><ul class="ne-ul"><li id="u14613e6c" data-lake-index-type="0" style="text-align: left"><span class="ne-text" style="color: #333333; font-size: 16px">39行和46行代码：</span><code class="ne-code"><span class="ne-text" style="color: #333333; font-size: 16px">ensureRenderer</span></code><span class="ne-text" style="color: #333333; font-size: 16px">方法只初始化一次</span></li><li id="uf2af7ac3" data-lake-index-type="0" style="text-align: left"><span class="ne-text" style="color: #333333; font-size: 16px">60行和68行也就是</span><code class="ne-code"><span class="ne-text" style="color: #333333; font-size: 16px">ensureRenderer</span></code><span class="ne-text" style="color: #333333; font-size: 16px">方法向外暴露出去的接口（</span><code class="ne-code"><span class="ne-text" style="color: #333333; font-size: 16px">render</span></code><span class="ne-text" style="color: #333333; font-size: 16px">和</span><code class="ne-code"><span class="ne-text" style="color: #333333; font-size: 16px">createApp</span></code><span class="ne-text" style="color: #333333; font-size: 16px">）</span></li></ul><h3 id="cbYwM"><span class="ne-text">createApp（ensureRenderer所暴露出来的）</span></h3><p id="u71ae6210" class="ne-p" style="text-align: left"><span class="ne-text" style="color: #333333; font-size: 16px">根据</span><code class="ne-code"><span class="ne-text" style="color: #333333; font-size: 16px">ensureRenderer</span></code><span class="ne-text" style="color: #333333; font-size: 16px">所返回的渲染器执行</span><code class="ne-code"><span class="ne-text" style="color: #333333; font-size: 16px">createApp</span></code><span class="ne-text" style="color: #333333; font-size: 16px">方法创建一个实例，也就是创建Vue实例对象的核心逻辑所在。</span></p><p id="u62887df3" class="ne-p" style="text-align: left"><span class="ne-text" style="color: #333333; font-size: 16px">F9进入</span><code class="ne-code"><span class="ne-text" style="color: #333333; font-size: 16px">createApp</span></code><span class="ne-text" style="color: #333333; font-size: 16px">函数内部：</span></p><p id="uec44733d" class="ne-p" style="text-align: left"><img src="https://cdn.nlark.com/yuque/0/2024/png/1484158/1712066661299-de3e049b-1998-473a-b363-f0f4e323cae0.png" width="1596" id="u22aa0e3b" class="ne-image"></p><ul class="ne-ul"><li id="u47e5b7ca" data-lake-index-type="0" style="text-align: left"><span class="ne-text" style="color: #333333; font-size: 16px">参数部分：</span></li></ul><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="uffd5b4ea" data-lake-index-type="0" style="text-align: left"><code class="ne-code"><span class="ne-text" style="color: #333333; font-size: 16px">rootComponent</span></code><span class="ne-text" style="color: #333333; font-size: 16px">：也就是我们所写的选项式API的“选项”</span></li></ul></ul><ul class="ne-ul"><li id="u45436cfa" data-lake-index-type="0" style="text-align: left"><span class="ne-text" style="color: #333333; font-size: 16px">215行代码：</span><code class="ne-code"><span class="ne-text" style="color: #333333; font-size: 16px">context</span></code><span class="ne-text" style="color: #333333; font-size: 16px">是用于记录组件的属性</span></li><li id="uc834700c" data-lake-index-type="0" style="text-align: left"><span class="ne-text" style="color: #333333; font-size: 16px">238行代码到384行代码：定义了我们常见的一些</span><code class="ne-code"><span class="ne-text" style="color: #333333; font-size: 16px">API</span></code></li></ul><h3 id="fim3G"><span class="ne-text" style="color: #333333">mount方法的重写</span></h3><p id="u2295f747" class="ne-p"><span class="ne-text" style="font-size: 16px">经过</span><code class="ne-code"><span class="ne-text" style="font-size: 16px">ensureRenderer</span></code><span class="ne-text" style="font-size: 16px">方法和</span><code class="ne-code"><span class="ne-text" style="font-size: 16px">createApp</span></code><span class="ne-text" style="font-size: 16px">方法所得到的实例对象</span><code class="ne-code"><span class="ne-text" style="font-size: 16px">app</span></code><span class="ne-text" style="font-size: 16px">，还会经过一次mount的重写，这是为什么呢？</span></p><p id="u0b9281b7" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2024/png/1484158/1712127167542-ff98d5b1-c242-48b8-bcf5-1ed2f5190081.png" width="1679" id="u0650520b" class="ne-image"></p><div data-type="success" class="ne-alert"><p id="u193862cc" class="ne-p"><span class="ne-text" style="color: #333333; font-size: 16px">通过解构出上述返回的</span><code class="ne-code"><span class="ne-text" style="color: #333333; font-size: 16px">app</span></code><span class="ne-text" style="color: #333333; font-size: 16px">对象中的</span><code class="ne-code"><span class="ne-text" style="color: #333333; font-size: 16px">mount</span></code><span class="ne-text" style="color: #333333; font-size: 16px">，重写了</span><code class="ne-code"><span class="ne-text" style="color: #333333; font-size: 16px">app.mount</span></code><span class="ne-text" style="color: #333333; font-size: 16px">方法，这个和不同类型的渲染有关，比如说服务端渲染可能需要不同的挂载逻辑。通过重写</span><code class="ne-code"><span class="ne-text" style="color: #333333; font-size: 16px">mount</span></code><span class="ne-text" style="color: #333333; font-size: 16px">，可以提供一个统一的API接口，</span><strong><span class="ne-text" style="color: #333333; font-size: 16px">这一点也体现了Vue的灵活所在。</span></strong></p></div><ul class="ne-ul"><li id="u8a78a8ef" data-lake-index-type="0" style="text-align: left"><span class="ne-text" style="color: #333333; font-size: 16px">77行到103行代码：根据传进的需要挂载的</span><code class="ne-code"><span class="ne-text" style="color: #333333; font-size: 16px">DOM</span></code><span class="ne-text" style="color: #333333; font-size: 16px"> </span><code class="ne-code"><span class="ne-text" style="color: #333333; font-size: 16px">id</span></code><span class="ne-text" style="color: #333333; font-size: 16px">值，读取</span><code class="ne-code"><span class="ne-text" style="color: #333333; font-size: 16px">DOM</span></code><span class="ne-text" style="color: #333333; font-size: 16px">处理前的内容将其编译为供后续生成</span><code class="ne-code"><span class="ne-text" style="color: #333333; font-size: 16px">DOM</span></code><span class="ne-text" style="color: #333333; font-size: 16px">需要的</span><code class="ne-code"><span class="ne-text" style="color: #333333; font-size: 16px">component</span></code><span class="ne-text" style="color: #333333; font-size: 16px">对象</span></li></ul><p id="u77acbc16" class="ne-p" style="text-align: left"><img src="https://cdn.nlark.com/yuque/0/2024/png/1484158/1712066661643-9446aac2-3b83-4e5e-bb35-2b0ad75051a3.png" width="687" id="aJy6c" class="ne-image"></p><h4 id="T1Kub"><span class="ne-text" style="color: #1a1a1a">深入应用实例mount方法</span></h4><p id="u859fb7c7" class="ne-p" style="text-align: left"><code class="ne-code"><span class="ne-text" style="color: #333333; font-size: 16px">F9</span></code><span class="ne-text" style="color: #333333; font-size: 16px">上述104行代码中的</span><code class="ne-code"><span class="ne-text" style="color: #333333; font-size: 16px">mount</span></code><span class="ne-text" style="color: #333333; font-size: 16px">内部，了解一下</span><code class="ne-code"><span class="ne-text" style="color: #333333; font-size: 16px">mount</span></code><span class="ne-text" style="color: #333333; font-size: 16px">挂载全过程：</span></p><p id="uaceb32b4" class="ne-p" style="text-align: left"><img src="https://cdn.nlark.com/yuque/0/2024/png/1484158/1712066661261-480a9012-955b-479f-8588-22fb226de988.png" width="842" id="u943ac1dd" class="ne-image"></p><ul class="ne-ul"><li id="ub5262b98" data-lake-index-type="0" style="text-align: left"><span class="ne-text" style="color: #333333; font-size: 16px">310行代码：实例挂载只能挂载一次</span></li><li id="uc193c61b" data-lake-index-type="0" style="text-align: left"><span class="ne-text" style="color: #333333; font-size: 16px">319行代码：根据“选项” 生成虚拟节点（</span><code class="ne-code"><span class="ne-text" style="color: #333333; font-size: 16px">vnode</span></code><span class="ne-text" style="color: #333333; font-size: 16px">），同时将上述的</span><code class="ne-code"><span class="ne-text" style="color: #333333; font-size: 16px">context</span></code><span class="ne-text" style="color: #333333; font-size: 16px">赋值给虚拟节点，至此，我们常说的虚拟节点到渲染真是节点的虚拟节点部分完成了</span></li><li id="u88c24ef5" data-lake-index-type="0" style="text-align: left"><span class="ne-text" style="color: #333333; font-size: 16px">343行代码：</span><code class="ne-code"><span class="ne-text" style="color: #333333; font-size: 16px">if</span></code><span class="ne-text" style="color: #333333; font-size: 16px">条件里面是服务端渲染相关，暂不考虑，走到</span><code class="ne-code"><span class="ne-text" style="color: #333333; font-size: 16px">else</span></code><span class="ne-text" style="color: #333333; font-size: 16px">的真实</span><code class="ne-code"><span class="ne-text" style="color: #333333; font-size: 16px">DOM</span></code><span class="ne-text" style="color: #333333; font-size: 16px">渲染逻辑，也就是</span><code class="ne-code"><span class="ne-text" style="color: #333333; font-size: 16px">render</span></code><span class="ne-text" style="color: #333333; font-size: 16px">逻辑</span></li><li id="u0cad42ae" data-lake-index-type="0" style="text-align: left"><span class="ne-text" style="color: #333333; font-size: 16px">349行代码：最后记录挂载的容器信息：</span><code class="ne-code"><span class="ne-text" style="color: #333333; font-size: 16px">_container</span></code></li></ul><h4 id="k6Ou3"><span class="ne-text" style="color: #333333">render</span></h4><p id="uaf16db84" class="ne-p"><code class="ne-code"><span class="ne-text" style="font-size: 16px">mount</span></code><span class="ne-text" style="font-size: 16px">方法内部会调用</span><code class="ne-code"><span class="ne-text" style="font-size: 16px">render</span></code><span class="ne-text" style="font-size: 16px">函数来将传入的模板（</span><code class="ne-code"><span class="ne-text" style="font-size: 16px">template</span></code><span class="ne-text" style="font-size: 16px">或者</span><code class="ne-code"><span class="ne-text" style="font-size: 16px">render</span></code><span class="ne-text" style="font-size: 16px">函数构建）生成虚拟</span><code class="ne-code"><span class="ne-text" style="font-size: 16px">DOM</span></code><span class="ne-text" style="font-size: 16px">，然后通过对虚拟</span><code class="ne-code"><span class="ne-text" style="font-size: 16px">DOM</span></code><span class="ne-text" style="font-size: 16px">的处理将其转换成实际的</span><code class="ne-code"><span class="ne-text" style="font-size: 16px">DOM</span></code><span class="ne-text" style="font-size: 16px">结构并插入到页面中</span></p><p id="ud3a894f3" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2024/png/1484158/1712128485525-3606db5d-6644-4554-874c-9347ccef01a3.png" width="1200" id="u91f39318" class="ne-image"></p><p id="u7af909d1" class="ne-p"><code class="ne-code"><span class="ne-text">F9</span></code><span class="ne-text">走进</span><code class="ne-code"><span class="ne-text">render</span></code><span class="ne-text">函数内部：</span></p><p id="u2b92bec4" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2024/png/1484158/1712130343377-55542f8c-fb3f-4bf8-a8ef-6c32230b324a.png" width="909" id="ubfa0062c" class="ne-image"></p><ul class="ne-ul"><li id="u4627e4d5" data-lake-index-type="0"><span class="ne-text">参数部分</span></li></ul><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="u6bf543d6" data-lake-index-type="0"><span class="ne-text">vnode：待渲染的虚拟节点</span></li><li id="ub2c4da0c" data-lake-index-type="0"><span class="ne-text">container：页面挂载容器</span></li><li id="u8b45edd4" data-lake-index-type="0"><span class="ne-text">namespace：（暂时不知道有什么用···）</span></li></ul></ul><ul class="ne-ul"><li id="u88bb598d" data-lake-index-type="0"><span class="ne-text">2362行代码：</span><strong><span class="ne-text">转换的核心逻辑，其主要逻辑就是对两个虚拟节点进行</span></strong><code class="ne-code"><strong><span class="ne-text">diff</span></strong></code><strong><span class="ne-text">比较，比较出差异部分再按需更新真实</span></strong><code class="ne-code"><strong><span class="ne-text">DOM</span></strong></code><strong><span class="ne-text">节点</span></strong><span class="ne-text">。部分</span><code class="ne-code"><span class="ne-text">render</span></code><span class="ne-text">函数代码如下：</span></li></ul><p id="ue178c5c4" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2024/png/1484158/1712130605500-8a795835-244e-411f-969e-260514990174.png" width="926" id="u724c45d2" class="ne-image"></p><h3 id="mHmgh"><span class="ne-text" style="color: #333333">挂载前后对比</span></h3><p id="u65acb88f" class="ne-p" style="text-align: left"><span class="ne-text" style="color: #333333; font-size: 16px">以下就是通过vue渲染前后的对比页面</span></p><p id="u5f007994" class="ne-p" style="text-align: left"><img src="https://cdn.nlark.com/yuque/0/2024/png/1484158/1712066661225-f4c751f7-9bc3-47d6-987c-6757f6502dce.png" width="602" id="u2a63c7db" class="ne-image"></p><p id="uab7fcd71" class="ne-p" style="text-align: left"><img src="https://cdn.nlark.com/yuque/0/2024/png/1484158/1712066661619-70258131-b2aa-4877-9060-fff5b76249bd.png" width="607" id="u42129f0d" class="ne-image"></p><p id="uaa0544f6" class="ne-p"><br></p></div>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;!doctype html&gt;&lt;div class=&quot;lake-content&quot; typography=&quot;classic&quot;&gt;&lt;p id=&quot;ua2aa3cc8&quot; class=&quot;ne-p&quot;&gt;&lt;span</summary>
        
      
    
    
    
    <category term="Web开发" scheme="https://www.wztlink1013.com/categories/Web%E5%BC%80%E5%8F%91/"/>
    
    <category term="Vue" scheme="https://www.wztlink1013.com/categories/Web%E5%BC%80%E5%8F%91/Vue/"/>
    
    
  </entry>
  
  <entry>
    <title>三分钟彻底搞懂函数柯里化</title>
    <link href="https://www.wztlink1013.com/blog/qgal86h5p9molvfm/"/>
    <id>https://www.wztlink1013.com/blog/qgal86h5p9molvfm/</id>
    <published>2024-03-23T23:31:39.000Z</published>
    <updated>2024-03-24T01:46:35.000Z</updated>
    
    <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="uc6daf56e" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2024/png/1484158/1711273591832-5a637ee2-c41d-416b-b586-05e609bf0eb2.png" width="1678" id="ub3d0835a" class="ne-image"></p><p id="u514099e4" class="ne-p"><span class="ne-text">前言：函数柯里化属于一种代码设计模式，可以理解成将一个函数在参数传递上做出优化，使得函数的应用变得更加灵活。本文先讲述什么是柯里化以及柯里化有什么用途，最后封装一个将函数柯里化的函数。</span></p><h3 id="mX2Ze"><span class="ne-text">一、什么是函数柯里化</span></h3><p id="u3e1c0d19" class="ne-p"><span class="ne-text">函数柯里化就是把接受多个参数的函数变成可连续接收单个参数的函数。三个之和函数的柯里化例子如下：</span></p><pre><code><code>const sum = (a, b, c) =&gt; a + b + c;console.log(sum(1, 2, 3));<p>// curry<br>const sum1 = (a) =&gt; (b) =&gt; (c) =&gt; a + b + c;<br>console.log(sum1(1)(2)(3));</code><br></code></pre></p><div data-type="success" class="ne-alert"><p id="u985b563c" class="ne-p"><span class="ne-text">💥</span><span class="ne-text">也可以实现类似</span><code class="ne-code"><span class="ne-text">sum(1,2)(3)</span></code><span class="ne-text">这种形式的柯里化，柯里化（</span><a href="https://en.wikipedia.org/wiki/Currying" data-href="https://en.wikipedia.org/wiki/Currying" target="_blank" class="ne-link"><span class="ne-text">https://en.wikipedia.org/wiki/Currying</span></a><span class="ne-text">）实际上是一种计算机科学中的通用方法，在实际编程中可以有多种实现或是变化。</span></p></div><h3 id="N4RPN"><span class="ne-text">二、函数柯里化有什么用</span></h3><p id="ue666b0eb" class="ne-p"><span class="ne-text">函数柯里化在具体代码中只是一种代码设计模式，优化代码质量，具体好处有以下几点：</span></p><p id="ua91d0c29" class="ne-p"><span class="ne-text">参数复用。如下类型校验的例子</span></p><pre><code><code>const checkByRegExp = (regExp, str) =&gt; regExp.test(str);// 校验手机号console.log(checkByRegExp(/^1\d&#123;10&#125;$/, &quot;12345678910&quot;));// 校验邮箱console.log(checkByRegExp(/^(\w)+(\.\w+)*@(\w)+((\.\w+)+)$/, &quot;test@163.com&quot;));</code></code></pre><p id="u712511d4" class="ne-p"><span class="ne-text">可以简易柯里化</span></p><pre><code><code>const curryingCheckByRegExp = (regExp) =&gt; (str) =&gt; regExp.test(str);// 校验手机const checkPhone = curryingCheckByRegExp(/^1\d&#123;10&#125;$/);// 校验邮箱const checkEmail = curryingCheckByRegExp(/^(\w)+(\.\w+)*@(\w)+((\.\w+)+)$/);<p>console.log(checkPhone(&quot;15152525634&quot;));<br>console.log(checkPhone(&quot;13456574566&quot;));<br>console.log(checkEmail(&quot;<a href="mailto:&#102;&#115;&#x64;&#115;&#64;&#49;&#x36;&#51;&#x2e;&#99;&#x6f;&#109;">&#102;&#115;&#x64;&#115;&#64;&#49;&#x36;&#51;&#x2e;&#99;&#x6f;&#109;</a>&quot;));<br>console.log(checkEmail(&quot;<a href="mailto:&#x66;&#100;&#115;&#x66;&#x40;&#x71;&#113;&#x2e;&#x63;&#111;&#109;">&#x66;&#100;&#115;&#x66;&#x40;&#x71;&#113;&#x2e;&#x63;&#111;&#109;</a>&quot;));</code><br></code></pre></p><div data-type="success" class="ne-alert"><p id="u1099b0b3" class="ne-p"><strong><span class="ne-text">核心的使用场景就是将多个按逻辑层划分的函数组装使用，这样代码逻辑层设置的更加合理，在很多SDK源码中经常见到</span></strong><span class="ne-text">（eg：</span><a href="https://github.com/ueberdosis/tiptap/tree/main/packages/core" data-href="https://github.com/ueberdosis/tiptap/tree/main/packages/core" target="_blank" class="ne-link"><span class="ne-text">https://github.com/ueberdosis/tiptap/tree/main/packages/core</span></a><span class="ne-text">）</span></p></div><h3 id="hJCFx"><span class="ne-text">三、函数柯里化的封装</span></h3><p id="u7a012b04" class="ne-p"><span class="ne-text">上述两个例子都各自实现一套函数柯里化的函数代码，也可以封装一个</span><code class="ne-code"><span class="ne-text">curry</span></code><span class="ne-text">函数来对传入的函数进行封装柯里化。具体可以根据传入的函数形参个数来进行设计。</span></p><pre><code><code>function _curry(fn, len, ...args) &#123;  return function (...params) &#123;    const _args = [...args, ...params];    return _args.length &gt;= len      ? fn.apply(this, _args)      : _curry.call(this, fn, len, ..._args);  &#125;;&#125;const curry = (fn, len = fn.length) =&gt; _curry.call(this, fn, len);</code></code></pre><p id="uae376752" class="ne-p"><span class="ne-text">上述三数之和例子可以改写如下：</span></p><pre><code><code>const result = curry(sum);console.log(result(1)(2)(3));</code></code></pre><p id="u10067ade" class="ne-p"><span class="ne-text">上述校验逻辑代码可以改写如下：</span></p><pre><code><code>const curryPhone = curry(checkByRegExp)(/^1\d&#123;10&#125;$/);const curryEmail = curry(checkByRegExp)(/^(\w)+(\.\w+)*@(\w)+((\.\w+)+)$/);console.log(curryPhone(&quot;12345678910&quot;));console.log(curryEmail(&quot;test@qq.com&quot;));</code></code></pre><p id="u5a6b5a55" class="ne-p"><br></p></div>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;!doctype html&gt;&lt;div class=&quot;lake-content&quot; typography=&quot;classic&quot;&gt;&lt;p id=&quot;uc6daf56e&quot; class=&quot;ne-p&quot;&gt;&lt;img</summary>
        
      
    
    
    
    <category term="Web开发" scheme="https://www.wztlink1013.com/categories/Web%E5%BC%80%E5%8F%91/"/>
    
    <category term="JavaScript" scheme="https://www.wztlink1013.com/categories/Web%E5%BC%80%E5%8F%91/JavaScript/"/>
    
    <category term="ECMAScript" scheme="https://www.wztlink1013.com/categories/Web%E5%BC%80%E5%8F%91/JavaScript/ECMAScript/"/>
    
    
  </entry>
  
  <entry>
    <title>JavaScript事件循环机制和异步编程（Promise、async和await）</title>
    <link href="https://www.wztlink1013.com/blog/lz7xgx/"/>
    <id>https://www.wztlink1013.com/blog/lz7xgx/</id>
    <published>2024-03-22T23:47:01.000Z</published>
    <updated>2024-03-23T03:37:01.000Z</updated>
    
    <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="u811cb54a" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1653573417541-44275572-06ee-41fc-ab54-6683e2510450.png" width="1960" id="ude4d9e36" class="ne-image"></p><p id="ud5f3a522" class="ne-p"><span class="ne-text">前言：JavaScript的事件循环机制或是异步编程是具体代码编写的重点，JavaScript语言的单线程执行特点以及同步任务和异步任务，由这些语言特性共同有一套事件循环执行机制也就是异步代码的预期执行效果。</span></p><h2 id="bAXj8"><span class="ne-text">一、JS代码执行机制</span></h2><h3 id="YbZ5l"><span class="ne-text">JavaScript的单线程</span></h3><p id="b785073ad0b4241b17542f923c68bd89" class="ne-p"><span class="ne-text">单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。如果前一个任务耗时很长，后一个任务就不得不一直等着。这样所导致的问题是： 如果 JS 执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞的感觉。</span></p><h3 id="IF7ut"><span class="ne-text">同步任务和异步任务</span></h3><p id="175d9c82a2892ec08ad8c92559dfbb4e" class="ne-p"><span class="ne-text">单线程导致的问题就是后面的任务等待前面任务完成，如果前面任务很耗时（比如读取网络数据），后面任务不得不一直等待。为了解决这个问题，利用多核 CPU 的计算能力，HTML5 提出 Web Worker 标准，允许 JavaScript 脚本创建多个线程，但是子线程完全受主线程控制。于是JS 中出现了同步任务和异步任务。</span></p><p id="u09384c3b" class="ne-p"><span class="ne-text">JS中所有任务可以分成两种，一种是同步任务（synchronous），另一种是异步任务（asynchronous）。</span></p><ul class="ne-ul"><li id="ub267d26f" data-lake-index-type="0"><strong><span class="ne-text">【同步任务】</span></strong><span class="ne-text">指的是：在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务；</span></li><li id="u8624ac1a" data-lake-index-type="0"><strong><span class="ne-text">【异步任务】</span></strong><span class="ne-text">指的是：不进入主线程、而进入</span><strong><span class="ne-text">“任务队列”</span></strong><span class="ne-text">的任务，当主线程中的任务运行完了，才会将异步任务相关的回调函数从”任务队列”取出异步任务放入主线程执行。</span></li></ul><div data-type="warning" class="ne-alert"><p id="ud8b66a6f" class="ne-p"><span class="ne-text">异步任务又分为宏任务和微任务</span></p><p id="u058036d7" class="ne-p"><strong><span class="ne-text">常见的宏任务有：</span></strong></p><ol class="ne-ol"><li id="u1652333c" data-lake-index-type="0"><span class="ne-text">setTimeout</span></li><li id="u30d4ea96" data-lake-index-type="0"><span class="ne-text">setInterval</span></li><li id="u2d340e59" data-lake-index-type="0"><span class="ne-text">I/O（磁盘读写、网络通信···）</span></li><li id="uf13a1bdb" data-lake-index-type="0"><span class="ne-text">setImmediate</span><span class="ne-text" style="text-decoration: underline">（浏览器环境没有、Nodejs环境有）</span></li><li id="u6a49c6b9" data-lake-index-type="0"><span class="ne-text">requestAnimationFrame</span><span class="ne-text" style="text-decoration: underline">（浏览器环境有、Nodejs环境没有）</span></li></ol><p id="ub77f1171" class="ne-p"><strong><span class="ne-text">常见的微任务有：</span></strong></p><ol class="ne-ol"><li id="ud152fcc2" data-lake-index-type="0"><span class="ne-text">Promise</span></li><li id="ua2074ecf" data-lake-index-type="0"><span class="ne-text">Object.observe</span></li><li id="ue17e45d8" data-lake-index-type="0"><span class="ne-text">process.nextTick </span><span class="ne-text" style="text-decoration: underline">（浏览器环境没有、Nodejs环境有）</span></li><li id="u0e1ffa38" data-lake-index-type="0"><span class="ne-text">MutationObserver</span><span class="ne-text" style="text-decoration: underline">（浏览器环境有、Nodejs环境没有）</span></li></ol></div><h3 id="tDUjC"><span class="ne-text">事件循环机制</span></h3><p id="u5553772e" class="ne-p"><span class="ne-text">事件循环机制则是按照上面所描述的JavaScript特性，当即有同步任务又有异步任务情况下，代码的执行先后顺序。</span></p><img src="https://cdn.nlark.com/yuque/0/2024/jpeg/1484158/1711193306174-b481a2cd-57aa-4d8c-af84-274a9ef13aff.jpeg" id="LwsNE" style="display: block; width: 100%"><ol class="ne-ol"><li id="u4bb87b57" data-lake-index-type="0"><span class="ne-text">碰到同步任务，就先执行执行栈中的同步任务</span></li></ol><div class="ne-quote"><p id="ucec7015d" class="ne-p"><span class="ne-text">遇到函数的嵌套调用就把函数压入栈内再依次“剥洋葱”</span></p></div><ol start="2" class="ne-ol"><li id="u7048d5b0" data-lake-index-type="0"><span class="ne-text">碰到异步任务就压入任务队列（异步任务分为宏任务和微任务）</span></li><li id="u8ac10e88" data-lake-index-type="0"><span class="ne-text">当前执行栈中的所有同步任务执行完毕，就将执行异步任务，异步任务执行原则“先微后宏”</span></li></ol><p id="u245b5a71" class="ne-p"><strong><span class="ne-text" style="color: #E8323C">由于主线程不断地重复获得任务、执行任务、再获取任务、再执行……，这种机制被称为事件循环（Event Loop）</span></strong></p><h2 id="IvbMB"><span class="ne-text">二、一些例子</span></h2><p id="u68b25ff2" class="ne-p"><span class="ne-text">通过一些实际代码例子及其运行的结果来加深对事件循环机制的理解</span></p><h3 id="TLtJm"><span class="ne-text">同步代码+Promise</span></h3><pre><code><code>const promise = new Promise((resolve, reject) =&gt; &#123;  console.log(1);  resolve(&quot;success&quot;);  console.log(2);&#125;);promise.then((data) =&gt; &#123;  console.log(data);  console.log(3);&#125;);console.log(4);</code></code></pre><p id="u4f52f25f" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2024/png/1484158/1711177509945-b8a191e2-75b6-4ea8-ae12-cc5d4a6f1d9c.png" width="147.49999413887684" id="u60800e7b" class="ne-image"></p><pre><code><code>const promise1 = new Promise((resolve, reject) =&gt; &#123;  console.log(&quot;promise1&quot;);  resolve(&quot;resolve1&quot;);&#125;);const promise2 = promise1.then((res) =&gt; &#123;  console.log(res);&#125;);console.log(&quot;1&quot;, promise1);console.log(&quot;2&quot;, promise2);</code></code></pre><p id="u79e4c6cb" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2024/png/1484158/1711177590883-9c151a19-b11f-40f8-9378-9f878c7e1b58.png" width="273.33332247204294" id="u3ae9bd10" class="ne-image"></p><h3 id="oa0ag"><span class="ne-text">同步代码+setTimeout+Promise</span></h3><pre><code><code>console.log(1);setTimeout(() =&gt; &#123;  console.log(2);  Promise.resolve().then(() =&gt; &#123;    console.log(3);  &#125;);&#125;);console.log(4);new Promise((resolve, reject) =&gt; &#123;  console.log(5);  resolve();&#125;)  .then(() =&gt; &#123;    console.log(6);    setTimeout(() =&gt; &#123;      console.log(7);    &#125;);  &#125;)  .catch(() =&gt; &#123;    console.log(9);  &#125;);console.log(8);</code></code></pre><p id="uaadaee80" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2024/png/1484158/1711176750519-95ae6d7b-9aff-4713-80f3-eefc48238c22.png" width="231.6666574610608" id="u086e6f8d" class="ne-image"></p><pre><code><code>setTimeout(() =&gt; &#123;  console.log(1);&#125;, 0);console.log(2);const p = new Promise((resolve) =&gt; &#123;  console.log(3);  resolve();&#125;)  .then(() =&gt; &#123;    console.log(4);  &#125;)  .then(() =&gt; &#123;    console.log(5);  &#125;);console.log(6);</code></code></pre><p id="ue162ba1c" class="ne-p"><strong><span class="ne-text">then的连续回调都属于一个微任务</span></strong></p><p id="u320ca539" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2024/png/1484158/1711177325508-9e71bcee-c292-4c9b-a389-5309e517b79d.png" width="275.83332237270184" id="u4e58c1af" class="ne-image"></p><pre><code><code>new Promise((resolve,reject)=&gt;&#123;  console.log(1)  resolve()&#125;).then(()=&gt;&#123;  console.log(2)  new Promise((resolve,reject)=&gt;&#123;    console.log(3)    resolve()  &#125;).then(()=&gt;&#123;    console.log(4)  &#125;).then(()=&gt;&#123;    console.log(5)  &#125;)&#125;).then(()=&gt;&#123;  console.log(6)&#125;)</code></code></pre><p id="ucc5c1474" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2024/png/1484158/1711177827154-2f41dd48-96bc-4cf8-af9e-9693a46f6efc.png" width="299.9999880790715" id="h2U7V" class="ne-image"></p><pre><code><code>new Promise((resolve, reject) =&gt; &#123;  console.log(1);  resolve();&#125;)  .then(() =&gt; &#123;    console.log(2);    return new Promise((resolve, reject) =&gt; &#123;      console.log(3);      resolve();    &#125;)      .then(() =&gt; &#123;        console.log(4);      &#125;)      .then(() =&gt; &#123;        console.log(5);      &#125;);  &#125;)  .then(() =&gt; &#123;    console.log(6);  &#125;);</code></code></pre><p id="ue19e7715" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2024/png/1484158/1711178047803-bdb99d1a-6071-4fe4-8a30-3896c37aea90.png" width="223.33332445886435" id="u487e8573" class="ne-image"></p><pre><code><code>new Promise((resolve, reject) =&gt; &#123;  console.log(1)  resolve()&#125;).then(() =&gt; &#123;  console.log(2)  new Promise((resolve, reject) =&gt; &#123;    console.log(3)    resolve()  &#125;).then(() =&gt; &#123;    console.log(4)  &#125;).then(() =&gt; &#123;    console.log(5)  &#125;)&#125;).then(() =&gt; &#123;  console.log(6)&#125;)new Promise((resolve, reject) =&gt; &#123;  console.log(7)  resolve()&#125;).then(() =&gt; &#123;  console.log(8)&#125;)</code></code></pre><p id="udc697973" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2024/png/1484158/1711178391841-707dfb36-30a0-40e1-8e79-3cd07976f635.png" width="184.99999264876078" id="uc0fa6ac2" class="ne-image"></p><h3 id="zCwWK"><span class="ne-text">同步代码+async await+Promise</span></h3><p id="u7526ecaf" class="ne-p"><span class="ne-text">await可以看成是Promise的语法糖（实际上是Generate的语法糖），效果和Promise的回调地狱一样，只是代码书写起来类似同步执行代码。</span></p><pre><code><code>async function async1() &#123;  console.log(1);  await async2();  console.log(2);&#125;async function async2() &#123;  console.log(3);&#125;console.log(4);setTimeout(function () &#123;  console.log(5);&#125;);async1();new Promise(function (resolve, reject) &#123;  console.log(6);  resolve();&#125;).then(function () &#123;  console.log(7);&#125;);console.log(8);</code></code></pre><p id="uccfecfa9" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2024/png/1484158/1711179143994-f25a4728-f05b-48bb-9d46-4fef205c4bcb.png" width="201.66665865315363" id="ue5d90719" class="ne-image"></p><h3 id="X8bdj"><span class="ne-text">综合例子</span></h3><pre><code><code>async function a1() &#123;  console.log('a1 start')  await a2()  console.log('a1 end')&#125;async function a2() &#123;  console.log('a2')&#125;<p>console.log(‘script start’)</p><p>setTimeout(() =&gt; &#123;<br>  console.log(‘setTimeout’)<br>&#125;, 0)</p><p>Promise.resolve().then(() =&gt; &#123;<br>  console.log(‘promise1’)<br>&#125;)</p><p>a1()</p><p>let promise2 = new Promise(resolve =&gt; &#123;<br>  resolve(‘promise2.then’)<br>  console.log(‘promise2’)<br>&#125;)</p><p>promise2.then(res =&gt; &#123;<br>  console.log(res)<br>  Promise.resolve().then(() =&gt; &#123;<br>    console.log(‘promise3’)<br>  &#125;)<br>&#125;)<br>console.log(‘script end’)</code><br></code></pre></p><p id="u7ad89b7d" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2024/png/1484158/1711179267786-9e7bf14c-58e3-4dae-811b-ac8fda627250.png" width="217.49999135732685" id="u8442b701" class="ne-image"></p></div>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;!doctype html&gt;&lt;div class=&quot;lake-content&quot; typography=&quot;classic&quot;&gt;&lt;p id=&quot;u811cb54a&quot; class=&quot;ne-p&quot; style=&quot;text-align: center&quot;&gt;&lt;img</summary>
        
      
    
    
    
    <category term="Web开发" scheme="https://www.wztlink1013.com/categories/Web%E5%BC%80%E5%8F%91/"/>
    
    <category term="JavaScript" scheme="https://www.wztlink1013.com/categories/Web%E5%BC%80%E5%8F%91/JavaScript/"/>
    
    <category term="ECMAScript" scheme="https://www.wztlink1013.com/categories/Web%E5%BC%80%E5%8F%91/JavaScript/ECMAScript/"/>
    
    
  </entry>
  
  <entry>
    <title>三分钟掌握JS中事件冒泡、捕获机制和事件委托设计模式</title>
    <link href="https://www.wztlink1013.com/blog/ywgyk067zbsx46io/"/>
    <id>https://www.wztlink1013.com/blog/ywgyk067zbsx46io/</id>
    <published>2024-03-11T22:33:16.000Z</published>
    <updated>2024-03-11T22:50:42.000Z</updated>
    
    <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="uf6be57fa" class="ne-p"><span class="ne-text">前言：js里面事件就是指用户执行某些行为（本文以点击行为为例）后，浏览器会发出相应的事件响应，而用户可以捕获这些事件，并在其中写相应的逻辑代码。本文详细介绍浏览器对事件的传播机制（事件冒泡、事件捕获），以及事件委托（代理）一种代码设计模式。</span></p><h3 id="hG206"><span class="ne-text">一、事件冒泡</span></h3><p id="ub8a21f1d" class="ne-p"><span class="ne-text">嵌套的DOM结果，如果点击子元素，会触发父元素的点击行为</span></p><pre><code><code>&lt;body&gt;  &lt;div id=&quot;outside&quot;&gt;    outside    &lt;div id=&quot;center&quot;&gt;      center      &lt;div id=&quot;inside&quot;&gt;inside&lt;/div&gt;    &lt;/div&gt;  &lt;/div&gt;  &lt;script&gt;    const inside = document.getElementById(&quot;inside&quot;);    const center = document.getElementById(&quot;center&quot;);    const outside = document.getElementById(&quot;outside&quot;);    inside.addEventListener(&quot;click&quot;, () =&gt; &#123;      console.log(&quot;inside&quot;);    &#125;);    center.addEventListener(&quot;click&quot;, () =&gt; &#123;      console.log(&quot;center&quot;);    &#125;);    outside.addEventListener(&quot;click&quot;, () =&gt; &#123;      console.log(&quot;outside&quot;);    &#125;);  &lt;/script&gt;&lt;/body&gt;</code></code></pre><p id="u8f98b592" class="ne-p"><span class="ne-text">如果点击inside区域，会出现如下效果，这就是事件冒泡</span></p><p id="ub177e678" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2024/png/1484158/1710221274477-0ec76e52-e452-4d4c-b9ab-40531e7f0838.png" width="310.8333209819269" id="u19ff0e82" class="ne-image"></p><p id="u1b56b0ff" class="ne-p"><strong><span class="ne-text">停止冒泡</span></strong></p><p id="ucf4681bf" class="ne-p"><span class="ne-text">如果需要停止上述冒泡行为，可以将处理函数修改如下</span></p><pre><code><code>inside.addEventListener(&quot;click&quot;, (e) =&gt; &#123;  e.stopPropagation();  console.log(&quot;inside&quot;);&#125;);</code></code></pre><p id="u9a4fc357" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2024/png/1484158/1710221421292-0c1c8d19-5079-4614-9e12-df9569d3147d.png" width="288.3333218759965" id="u7e8825f8" class="ne-image"></p><h3 id="x1F3I"><span class="ne-text">二、事件捕获</span></h3><p id="u5387116c" class="ne-p"><span class="ne-text">浏览器对事件响应的整个阶段如下（window -&gt; document省略，只从DOM树分析）</span></p><img src="https://cdn.nlark.com/yuque/0/2024/jpeg/1484158/1710222317829-d52061bd-4c57-4195-a7cf-ac2bcc308fd6.jpeg" id="fCE1u" style="display: block; width: 100%"><p id="ub57e3b7f" class="ne-p"><span class="ne-text">事件冒泡阶段只是浏览器对事件响应整个阶段的后半部分，前面还有事件捕获阶段，这阶段的代码修改为如下：</span></p><pre><code><code>inside.addEventListener(  &quot;click&quot;,  (e) =&gt; &#123;    console.log(&quot;inside&quot;);  &#125;,  true);</code></code></pre><p id="u0fcd6d63" class="ne-p"><span class="ne-text">或者</span></p><pre><code><code>inside.addEventListener(  &quot;click&quot;,  (e) =&gt; &#123;    console.log(&quot;inside&quot;);  &#125;,  &#123; capture: true &#125;);</code></code></pre><h3 id="NMJeR"><span class="ne-text">三、事件委托/代理</span></h3><p id="ub562538d" class="ne-p"><span class="ne-text">事件委托可以理解称一种代码设计模式，比如上述例子三个DOM分别注册了点击事件，如果嵌套（或者扁平化）了更多的DOM，一个个注册事件在代码逻辑上较为重复且在性能会有所损耗（绑定事件越多，浏览器内存占用越大）。</span><strong><span class="ne-text">事件委托</span></strong><span class="ne-text">则是利用事件捕获机制，在这些DOM的一个父元素上只注册一个点击事件即可，上述例子利用事件委托可以写成</span></p><pre><code><code>&lt;body&gt;  &lt;div id=&quot;outside&quot;&gt;    outside    &lt;div id=&quot;center&quot;&gt;      center      &lt;div id=&quot;inside&quot;&gt;inside&lt;/div&gt;    &lt;/div&gt;  &lt;/div&gt;  &lt;script&gt;    <pre><code>document.querySelector(&amp;quot;body&amp;quot;).addEventListener(&amp;quot;click&amp;quot;, (e) =&amp;gt; &#123;  console.log(e.target.id);&#125;);</code></pre><p>  &lt;/script&gt;<br>&lt;/body&gt;</code><br></code></pre></p><div data-type="warning" class="ne-alert"><p id="u4829c1eb" class="ne-p"><span class="ne-text">❗</span><span class="ne-text">实际代码不要用body作为父元素</span></p></div><p id="u3310c298" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2024/png/1484158/1710223556542-9deba808-4965-4177-a782-b1299c409015.png" width="329.166653586759" id="ue749ff64" class="ne-image"></p><p id="ub47e7afc" class="ne-p"><br></p><p id="ub29b3637" class="ne-p" style="text-align: center"><span class="ne-text">哥们也做一回标题党</span><img src="https://cdn.nlark.com/yuque/0/2024/jpeg/1484158/1710225564950-b3f001ff-070c-4056-8db9-c6b985f9a44b.jpeg" width="35.9921875" id="uc11aa205" class="ne-image"></p></div>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;!doctype html&gt;&lt;div class=&quot;lake-content&quot; typography=&quot;classic&quot;&gt;&lt;p id=&quot;uf6be57fa&quot; class=&quot;ne-p&quot;&gt;&lt;span</summary>
        
      
    
    
    
    <category term="Web开发" scheme="https://www.wztlink1013.com/categories/Web%E5%BC%80%E5%8F%91/"/>
    
    <category term="JavaScript" scheme="https://www.wztlink1013.com/categories/Web%E5%BC%80%E5%8F%91/JavaScript/"/>
    
    <category term="ECMAScript" scheme="https://www.wztlink1013.com/categories/Web%E5%BC%80%E5%8F%91/JavaScript/ECMAScript/"/>
    
    
  </entry>
  
  <entry>
    <title>项目使用all-contributors-cli生成贡献者名单</title>
    <link href="https://www.wztlink1013.com/blog/wgervpvkdaoc42ml/"/>
    <id>https://www.wztlink1013.com/blog/wgervpvkdaoc42ml/</id>
    <published>2024-02-29T19:17:53.000Z</published>
    <updated>2024-03-13T22:50:40.000Z</updated>
    
    <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="ue1444cdc" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2024/png/1484158/1709262142751-6bca1311-c71b-464a-b603-c4d4d89a6f88.png" width="899.9999642372145" id="wtp7K" class="ne-image"></p><p id="ue531d0e9" class="ne-p"><span class="ne-text">前言：all-contributors用于管理和展示项目的贡献者列表，展示贡献者的贡献类型和基础个人信息（头像和昵称）在README.md文件中。</span></p><h3 id="NIt7l"><span class="ne-text">一、初始化all-contributors</span></h3><p id="u226282a0" class="ne-p"><span class="ne-text">项目安装all-contributors-cli</span></p><pre><code><code>pnpm i all-contributors-cli</code></code></pre><p id="u6f44d18e" class="ne-p"><span class="ne-text">项目初始化all-contributors-cli</span></p><pre><code><code>./node_modules/.bin/all-contributors init</code></code></pre><p id="u117ff10e" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2024/png/1484158/1709259194099-6aefe00d-2ad6-4066-8ca7-4ffdb8cf65b9.png" width="808.3333129882812" id="SqJU9" class="ne-image"></p><p id="ud585018e" class="ne-p"><span class="ne-text">初始化完之后，项目的一些文件会自动发生变化：</span></p><ol class="ne-ol"><li id="u16c87012" data-lake-index-type="0"><span class="ne-text">生成</span><code class="ne-code"><span class="ne-text">.all-contributorsrc</span></code><span class="ne-text">文件</span></li></ol><pre><code><code>&#123;  &quot;projectName&quot;: &quot;kittyui&quot;,  &quot;projectOwner&quot;: &quot;wztlink1013&quot;,  &quot;repoType&quot;: &quot;github&quot;,  &quot;repoHost&quot;: &quot;https://github.com&quot;,  &quot;files&quot;: [    &quot;README.md&quot;  ],  &quot;imageSize&quot;: 100,  &quot;commit&quot;: true,  &quot;commitConvention&quot;: &quot;eslint&quot;,  &quot;contributors&quot;: [],  &quot;contributorsPerLine&quot;: 7,  &quot;linkToUsage&quot;: true&#125;</code></code></pre><ol start="2" class="ne-ol"><li id="u451466e9" data-lake-index-type="0"><code class="ne-code"><span class="ne-text">README.md</span></code><span class="ne-text">会在开头和结尾自动添加allcontributors文本展示内容</span></li></ol><pre><code><code>&lt;!-- ALL-CONTRIBUTORS-BADGE:START - Do not remove or modify this section --&gt;<p><a href="#contributors-"><img src="https://img.shields.io/badge/all_contributors-0-orange.svg?style=flat-square" alt="All Contributors"></a></p><p>&lt;!– ALL-CONTRIBUTORS-BADGE:END –&gt;</p><h2 id="Contributors-✨"><a href="#Contributors-✨" class="headerlink" title="Contributors ✨"></a>Contributors ✨</h2><p>Thanks goes to these wonderful people (<a href="https://allcontributors.org/docs/en/emoji-key">emoji key</a>):</p><p>&lt;!– ALL-CONTRIBUTORS-LIST:START - Do not remove or modify this section –&gt;<br>&lt;!– prettier-ignore-start –&gt;<br>&lt;!– markdownlint-disable –&gt;<br>&lt;!– markdownlint-restore –&gt;<br>&lt;!– prettier-ignore-end –&gt;</p><p>&lt;!– ALL-CONTRIBUTORS-LIST:END –&gt;</p><p>This project follows the <a href="https://github.com/all-contributors/all-contributors">all-contributors</a> specification. Contributions of any kind welcome!<br></code><br></code></pre></p><p id="u76f459a3" class="ne-p"><span class="ne-text">效果如下：</span></p><p id="u4cd61ad1" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2024/png/1484158/1709259753769-1124031a-03b2-46d3-9a6f-51f2619b668f.png" width="895.8332977361164" id="u7793f912" class="ne-image"></p><h3 id="PxGg4"><span class="ne-text">二、添加项目开发协作者</span></h3><p id="uad1a54ce" class="ne-p"><span class="ne-text">添加方式有两种：</span></p><ol class="ne-ol"><li id="u99820ece" data-lake-index-type="0"><span class="ne-text">命令行方式添加</span></li><li id="u39e4dc98" data-lake-index-type="0"><span class="ne-text">仓库机器人方式添加：协作者利用</span><code class="ne-code"><span class="ne-text">issues</span></code><span class="ne-text">或者</span><code class="ne-code"><span class="ne-text">pull request</span></code><span class="ne-text">拉取请求方式申请添加</span></li></ol><h4 id="d2jcn"><span class="ne-text">命令行方式添加</span></h4><p id="u7b491dee" class="ne-p"><span class="ne-text">添加用户</span></p><pre><code><code># 添加做出了 &lt;contribution&gt; 类型贡献的贡献者 &lt;username&gt;, # ./node_modules/.bin/all-contributors add &lt;username&gt; &lt;contribution&gt;<p>./node_modules/.bin/all-contributors add wztlink1013 &quot;code,doc&quot;</code><br></code></pre></p><p id="ue9386363" class="ne-p"><span class="ne-text">生成展示表格（自动更新</span><code class="ne-code"><span class="ne-text">README.md</span></code><span class="ne-text">文件）</span></p><pre><code><code>./node_modules/.bin/all-contributors generate</code></code></pre><p id="u61f7d48e" class="ne-p"><span class="ne-text">上述两个命令执行完会自动更新</span><code class="ne-code"><span class="ne-text">.all-contributorsrc</span></code><span class="ne-text">文件和</span><code class="ne-code"><span class="ne-text">README.md</span></code><span class="ne-text">文件</span></p><p id="ue3ad0498" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2024/png/1484158/1709260794169-7a790b49-7e72-4e28-a8b8-3bd7917e5cd3.png" width="900.8332975374342" id="u8cb20852" class="ne-image"></p><h4 id="VRut0"><span class="ne-text">仓库机器人方式添加</span></h4><p id="u3e012659" class="ne-p"><span class="ne-text">添加仓库机器人：</span></p><ul class="ne-ul"><li id="u7d0db2cd" data-lake-index-type="0"><span class="ne-text">GitHub Bot下载：</span><a href="https://github.com/apps/allcontributors/installations/select_target" data-href="https://github.com/apps/allcontributors/installations/select_target" target="_blank" class="ne-link"><span class="ne-text">https://github.com/apps/allcontributors/installations/select_target</span></a></li></ul><p id="u96cff878" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2024/png/1484158/1709261083635-11a66e62-f4a0-4d6f-a4a1-661e58d39f39.png" width="490.8333138293698" id="ub978da08" class="ne-image"></p><p id="u6c6b1f1b" class="ne-p"><span class="ne-text"></span></p><p id="u4dca5414" class="ne-p"><span class="ne-text">发起</span><code class="ne-code"><span class="ne-text">issues</span></code><span class="ne-text">或者</span><code class="ne-code"><span class="ne-text">pull request</span></code><span class="ne-text">请求加入协作者</span></p><p id="uf8fe5fe4" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2024/png/1484158/1709261947692-5df9b5bb-c3e1-42ed-b58c-d53e7c3a3ea9.png" width="770.8333027031699" id="u8bf5b0ab" class="ne-image"></p><p id="uccc5429a" class="ne-p"><span class="ne-text">然后会有一个合并新协作者的</span><code class="ne-code"><span class="ne-text">pull request</span></code><span class="ne-text">被创建，merge即可。</span></p><p id="ua1b3edf5" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2024/png/1484158/1709262058313-e1380c4e-ac76-450d-887d-b41632b99d79.png" width="1045.833291775652" id="ufebc37c4" class="ne-image"></p><h3 id="xDQ9h"><span class="ne-text">三、最终效果</span></h3><p id="uc797f4e9" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2024/png/1484158/1709262142751-6bca1311-c71b-464a-b603-c4d4d89a6f88.png" width="899.9999642372145" id="uf08c90b7" class="ne-image"></p><h3 id="AD8dV"><span class="ne-text">四、参考</span></h3><ul class="ne-ul"><li id="ucf112a8d" data-lake-index-type="0"><a href="https://allcontributors.org/" data-href="https://allcontributors.org/" target="_blank" class="ne-link"><span class="ne-text">https://allcontributors.org/</span></a></li><li id="u4d49a7c1" data-lake-index-type="0"><span class="ne-text">贡献类型：</span><a href="https://allcontributors.org/docs/en/emoji-key" data-href="https://allcontributors.org/docs/en/emoji-key" target="_blank" class="ne-link"><span class="ne-text">https://allcontributors.org/docs/en/emoji-key</span></a></li></ul></div>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;!doctype html&gt;&lt;div class=&quot;lake-content&quot; typography=&quot;classic&quot;&gt;&lt;p id=&quot;ue1444cdc&quot; class=&quot;ne-p&quot;&gt;&lt;img</summary>
        
      
    
    
    
    <category term="计算机素养" scheme="https://www.wztlink1013.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B4%A0%E5%85%BB/"/>
    
    <category term="软件工程" scheme="https://www.wztlink1013.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B4%A0%E5%85%BB/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>Github Actions自动部署项目到云服务器</title>
    <link href="https://www.wztlink1013.com/blog/cgo5a1ofo4g7612b/"/>
    <id>https://www.wztlink1013.com/blog/cgo5a1ofo4g7612b/</id>
    <published>2024-02-28T22:27:42.000Z</published>
    <updated>2024-03-13T22:47:59.000Z</updated>
    
    <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="ue2cb4a43" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2024/png/1484158/1709186151285-0873ba2c-2ec2-49c1-a9f7-91971c51460f.png" width="1579.1666039162237" id="uc3d67a17" class="ne-image"></p><p id="uf4d7e961" class="ne-p"><span class="ne-text">前言：项目部署至服务器，一般而言，只需要将打包后的静态代码上传到服务器指定位置，如果配置的是nginx web服务器，再执行刷新相关命令即可。本文记录1panel运维管理面板下，结合GitHub Action自动化部署项目打包代码至云服务器的脚本编写逻辑。</span></p><h3 id="ikwbc"><span class="ne-text">一、GitHub Actions环境准备</span></h3><p id="uf7143646" class="ne-p"><span class="ne-text">GitHub Actions脚本的执行涉及一些敏感变量，在GitHub仓库中可以设置隐形变量防止暴露在外，只有在 GitHub Actions 中才能使用到</span></p><p id="ua08b3c13" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2024/png/1484158/1709183847317-5c3b51ab-6524-4443-88eb-3c361a32e1cc.png" width="1111.6666224930038" id="u294f3f6d" class="ne-image"></p><p id="u197af0e8" class="ne-p"><span class="ne-text">环境变量含义：</span></p><ol class="ne-ol"><li id="uf855a872" data-lake-index-type="0"><span class="ne-text">KEY（密钥）</span></li><li id="ub493d228" data-lake-index-type="0"><span class="ne-text">PASSPHRASE（加密私钥的密码）</span></li><li id="udd55ac46" data-lake-index-type="0"><span class="ne-text">SERVER_IP（云服务器公网IP）</span></li><li id="udc38e6a5" data-lake-index-type="0"><span class="ne-text">USERNAME（云服务器登录用户名， 通常为root）</span></li></ol><div data-type="color2" class="ne-alert"><p id="u75ef5804" class="ne-p"><span class="ne-text">📌</span><span class="ne-text"> </span><code class="ne-code"><span class="ne-text">KEY</span></code><span class="ne-text">和</span><code class="ne-code"><span class="ne-text">PASSPHRASE</span></code><span class="ne-text">分别为下面截图中的2和1</span></p></div><p id="u99f5b2c5" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2024/png/1484158/1708961842486-da9a4392-86a2-4f32-92ef-06702be0a712.png" width="986.9921875" id="ub4020674" class="ne-image"></p><h3 id="LqgtN"><span class="ne-text">二、GitHub Actions脚本编写</span></h3><p id="uda06d594" class="ne-p"><span class="ne-text">脚本需要做的事情有如下几点：</span></p><ol class="ne-ol"><li id="uf66054c0" data-lake-index-type="0"><span class="ne-text">项目打包成静态文件</span></li><li id="u3e5cf593" data-lake-index-type="0"><span class="ne-text">将打包后的静态文件上传至云服务器指定文件夹</span></li></ol><h4 id="liMcO"><span class="ne-text">打包成静态文件</span></h4><p id="u5407fa59" class="ne-p"><span class="ne-text">执行项目打包命令</span></p><pre><code><code>- name: Use Node.js $&#123;&#123; matrix.node-version &#125;&#125;  uses: actions/setup-node@v4  with:    node-version: $&#123;&#123; matrix.node-version &#125;&#125;    cache: 'pnpm'- run: |    pnpm install    pnpm build    mv apps/test-project/dist/ ./dist/</code></code></pre><h4 id="cUm29"><span class="ne-text">上传服务器</span></h4><p id="uf88c8467" class="ne-p"><span class="ne-text">利用scp-action将指定文件夹上传至服务器目标文件夹</span></p><pre><code><code>- name: Scp file to aliyun  uses: appleboy/scp-action@v0.1.7  with:    host: $&#123;&#123; secrets.SERVER_IP &#125;&#125;    username: $&#123;&#123; secrets.USERNAME &#125;&#125;    key: $&#123;&#123; secrets.KEY &#125;&#125;    passphrase: $&#123;&#123; secrets.PASSPHRASE &#125;&#125;    tar_dereference: true    rm: true    source: 'dist/*'    target: '/opt/1panel/apps/openresty/openresty/www/sites/test.com/index'</code></code></pre><p id="u01903c90" class="ne-p"><span class="ne-text">上述脚本代码只是上传，不能在服务器进行相关命令操作文件，还需要利用ssh-action添加如下脚本：</span></p><pre><code><code>- name: executing remote ssh commands using key  uses: appleboy/ssh-action@v1.0.3  with:    host: $&#123;&#123; secrets.SERVER_IP &#125;&#125;    username: $&#123;&#123; secrets.USERNAME &#125;&#125;    key: $&#123;&#123; secrets.KEY &#125;&#125;    passphrase: $&#123;&#123; secrets.PASSPHRASE &#125;&#125;    script: |      mv /opt/1panel/apps/openresty/openresty/www/sites/test.com/index/dist/* /opt/1panel/apps/openresty/openresty/www/sites/test.com/index/</code></code></pre><p id="u404b835b" class="ne-p"><span class="ne-text">这个脚本主要作用是将文件内容层级提升</span></p><div data-type="color2" class="ne-alert"><p id="u8cb3c33d" class="ne-p"><strong><span class="ne-text">因为本文章记录的是基于集成环境前端项目部署，只是打包后静态文件的替换，所以不涉及重启相关命令操作。</span></strong></p><p id="u181eb354" class="ne-p"><strong><span class="ne-text">如果你的环境不是继承运维面板（1panel/宝塔 等）的web服务器，而是手动搭建web服务器，则在这里可以写一些相关命令，比如nginx重启、node重启、docker重启指定容器……</span></strong></p><p id="ue84e02ee" class="ne-p"><strong><span class="ne-text">eg：</span></strong><code class="ne-code"><strong><span class="ne-text">docker restart project-name</span></strong></code></p></div><h3 id="m2XDQ"><span class="ne-text">三、最终代码</span></h3><ul class="ne-ul"><li id="u4b51c945" data-lake-index-type="0"><span class="ne-text">在GitHub仓库内添加文件</span><code class="ne-code"><span class="ne-text">.github/workflows/server.yml</span></code></li><li id="uccbf07d8" data-lake-index-type="0"><span class="ne-text">结合上述各个步骤的子代码，再添加部分GitHub Actions触发条件逻辑代码，整个脚本文件就完成了。</span></li></ul><pre><code><code>name: Aliyun Server Deployon:  push:    tags:      - release-**<p>jobs:<br>  deploy_job:<br>    runs-on: ubuntu-latest<br>    name: build<br>    steps:<br>      - uses: actions/checkout@v4<br>      - uses: pnpm/action-setup@v2<br>        with:<br>          version: 8<br>      - name: Use Node.js $&#123;&#123; matrix.node-version &#125;&#125;<br>        uses: actions/setup-node@v4<br>        with:<br>          node-version: $&#123;&#123; matrix.node-version &#125;&#125;<br>          cache: ‘pnpm’<br>      - run: |<br>          pnpm install<br>          pnpm build<br>          mv apps/test-project/dist/ ./dist/</p><pre><code>  - name: Scp file to aliyun    uses: appleboy/scp-action@v0.1.7    with:      host: $&#123;&#123; secrets.SERVER_IP &#125;&#125;      username: $&#123;&#123; secrets.USERNAME &#125;&#125;      key: $&#123;&#123; secrets.KEY &#125;&#125;      passphrase: $&#123;&#123; secrets.PASSPHRASE &#125;&#125;      tar_dereference: true      rm: true      source: &#39;dist/*&#39;      target: &#39;/opt/1panel/apps/openresty/openresty/www/sites/test.com/index&#39;  - name: executing remote ssh commands using key    uses: appleboy/ssh-action@v1.0.3    with:      host: $&#123;&#123; secrets.SERVER_IP &#125;&#125;      username: $&#123;&#123; secrets.USERNAME &#125;&#125;      key: $&#123;&#123; secrets.KEY &#125;&#125;      passphrase: $&#123;&#123; secrets.PASSPHRASE &#125;&#125;      script: |        mv /opt/1panel/apps/openresty/openresty/www/sites/test.com/index/dist/* /opt/1panel/apps/openresty/openresty/www/sites/test.com/index/&lt;/code&gt;</code></pre><p></code></pre></p><h3 id="JO08d"><span class="ne-text">四、参考</span></h3><ul class="ne-ul"><li id="ubd920933" data-lake-index-type="0"><a href="https://github.com/appleboy/scp-action" data-href="https://github.com/appleboy/scp-action" target="_blank" class="ne-link"><span class="ne-text">https://github.com/appleboy/scp-action</span></a></li><li id="u45a62d3b" data-lake-index-type="0"><a href="https://github.com/appleboy/ssh-action" data-href="https://github.com/appleboy/ssh-action" target="_blank" class="ne-link"><span class="ne-text">https://github.com/appleboy/ssh-action</span></a></li><li id="u94d8d882" data-lake-index-type="0"><a href="https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows" data-href="https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows" target="_blank" class="ne-link"><span class="ne-text">https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows</span></a></li></ul></div>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;!doctype html&gt;&lt;div class=&quot;lake-content&quot; typography=&quot;classic&quot;&gt;&lt;p id=&quot;ue2cb4a43&quot; class=&quot;ne-p&quot;&gt;&lt;img</summary>
        
      
    
    
    
    <category term="Web开发" scheme="https://www.wztlink1013.com/categories/Web%E5%BC%80%E5%8F%91/"/>
    
    <category term="DevOps" scheme="https://www.wztlink1013.com/categories/Web%E5%BC%80%E5%8F%91/DevOps/"/>
    
    
  </entry>
  
  <entry>
    <title>Hexo优化网站SEO</title>
    <link href="https://www.wztlink1013.com/blog/ymz4rr2wyxrxktqd/"/>
    <id>https://www.wztlink1013.com/blog/ymz4rr2wyxrxktqd/</id>
    <published>2024-01-14T02:06:51.000Z</published>
    <updated>2024-01-14T03:50:24.000Z</updated>
    
    <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="ub944b1e4" class="ne-p"><span class="ne-text">前言：提高搜索引擎对网站的抓取质量，从以下两个文件入手：</span></p><ol class="ne-ol"><li id="u9472c50c" data-lake-index-type="0"><span class="ne-text">sitemap文件</span></li><li id="u3a99adbb" data-lake-index-type="0"><span class="ne-text">Robots.txt</span></li></ol><h3 id="DwDU8"><span class="ne-text">sitemap</span></h3><p id="u88ae2110" class="ne-p"><span class="ne-text">sitemap是一种包含网站所有页面URL的文件，有助于搜索引擎更快地索引和发现您的网站，其格式有xml或txt。在Hexo中，可以利用</span><a href="https://github.com/hexojs/hexo-generator-sitemap" data-href="https://github.com/hexojs/hexo-generator-sitemap" target="_blank" class="ne-link"><span class="ne-text">hexo-generator-sitemap</span></a><span class="ne-text">插件生成sitemap文件。</span></p><h4 id="xAlnz"><span class="ne-text">基本使用</span></h4><pre><code><code>npm i hexo-generator-sitemap --save</code></code></pre><p id="ud9d657b1" class="ne-p"><span class="ne-text">参数配置，具体使用参考文档：</span><a href="https://github.com/hexojs/hexo-generator-sitemap/tree/master?tab=readme-ov-file#options" data-href="https://github.com/hexojs/hexo-generator-sitemap/tree/master?tab=readme-ov-file#options" target="_blank" class="ne-link"><span class="ne-text">https://github.com/hexojs/hexo-generator-sitemap/tree/master?tab=readme-ov-file#options</span></a></p><pre><code><code>sitemap:  path: sitemap.xml  tags: false  categories: false  template: ./template/sitemap.xml</code></code></pre><p id="u06f186d4" class="ne-p"><span class="ne-text">生成后的sitemap文件如下：</span></p><pre><code><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;urlset xmlns=&quot;http://www.sitemaps.org/schemas/sitemap/0.9&quot;&gt;  &lt;url&gt;    &lt;loc&gt;https://www.wztlink1013.com/blog/tttk33/&lt;/loc&gt;    &lt;lastmod&gt;2024-01-14&lt;/lastmod&gt;    &lt;changefreq&gt;weekly&lt;/changefreq&gt;    &lt;priority&gt;0.8&lt;/priority&gt;  &lt;/url&gt;  &lt;url&gt;    &lt;loc&gt;https://www.wztlink1013.com/&lt;/loc&gt;    &lt;lastmod&gt;2024-01-14&lt;/lastmod&gt;    &lt;changefreq&gt;daily&lt;/changefreq&gt;    &lt;priority&gt;1.0&lt;/priority&gt;  &lt;/url&gt;&lt;/urlset&gt;</code></code></pre><ul class="ne-ul"><li id="uca43eeff" data-lake-index-type="0"><span class="ne-text">loc：抓取的网站子页url</span></li><li id="u1b2973d2" data-lake-index-type="0"><span class="ne-text">lastmod：改子页最新一次更新时间</span></li><li id="uc5f01609" data-lake-index-type="0"><span class="ne-text">changefreq：改子页更新频率</span></li><li id="u77e95919" data-lake-index-type="0"><span class="ne-text">priority：在该站点的抓取优先级权重</span></li></ul><h4 id="SEC0C"><span class="ne-text">自定义生成模板</span></h4><p id="u44db15c2" class="ne-p"><span class="ne-text" style="background-color: #FBDE28"></span><span class="ne-text">在项目根路径创建</span><code class="ne-code"><span class="ne-text">template/sitemap.xml</span></code><span class="ne-text">文件，并写入下面代码</span></p><pre><code><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;urlset xmlns=&quot;http://www.sitemaps.org/schemas/sitemap/0.9&quot;&gt;  &#123;% for post in posts %&#125;  &lt;url&gt;    &lt;loc&gt;&#123;&#123; post.permalink | uriencode &#125;&#125;&lt;/loc&gt;&#123;% if post.updated %&#125;    &lt;lastmod&gt;&#123;&#123; post.updated | formatDate &#125;&#125;&lt;/lastmod&gt;&#123;% elif post.date %&#125;    &lt;lastmod&gt;&#123;&#123; post.date | formatDate &#125;&#125;&lt;/lastmod&gt;&#123;% endif %&#125;    &lt;changefreq&gt;weekly&lt;/changefreq&gt;    &lt;priority&gt;0.8&lt;/priority&gt;  &lt;/url&gt;  &#123;% endfor %&#125;<p>  &lt;url&gt;<br>    &lt;loc&gt;&#123;&#123; config.url | uriencode &#125;&#125;&lt;/loc&gt;<br>    &lt;lastmod&gt;&#123;&#123; sNow | formatDate &#125;&#125;&lt;/lastmod&gt;<br>    &lt;changefreq&gt;daily&lt;/changefreq&gt;<br>    &lt;priority&gt;1.0&lt;/priority&gt;<br>  &lt;/url&gt;</p>  &#123;% for tag in tags %&#125;  &lt;url&gt;    &lt;loc&gt;&#123;&#123; tag.permalink | uriencode &#125;&#125;&lt;/loc&gt;    &lt;lastmod&gt;&#123;&#123; sNow | formatDate &#125;&#125;&lt;/lastmod&gt;    &lt;changefreq&gt;weekly&lt;/changefreq&gt;    &lt;priority&gt;0.2&lt;/priority&gt;  &lt;/url&gt;  &#123;% endfor %&#125;  &#123;% for cat in categories %&#125;  &lt;url&gt;    &lt;loc&gt;&#123;&#123; cat.permalink | uriencode &#125;&#125;&lt;/loc&gt;    &lt;lastmod&gt;&#123;&#123; sNow | formatDate &#125;&#125;&lt;/lastmod&gt;    &lt;changefreq&gt;weekly&lt;/changefreq&gt;    &lt;priority&gt;0.2&lt;/priority&gt;  &lt;/url&gt;  &#123;% endfor %&#125;<p>&lt;/urlset&gt;</code><br></code></pre></p><h4 id="kvZtE"><span class="ne-text">指定页面跳过sitemap收录</span></h4><p id="u0be81d58" class="ne-p"><span class="ne-text">在hexo中的文章或是页面，可以如下配置：</span></p><pre><code><code>---title: 隐藏文章date: 2024-01-14sitemap: false---</code></code></pre><h3 id="qE3ji"><span class="ne-text">robots.txt</span></h3><p id="u9a756fc4" class="ne-p"><span class="ne-text">robots文件是一个文本文件，用于向搜索引擎指示哪些页面可以访问和索引，哪些页面应该被忽略。通过优化 robots文件，可以提高网站在搜索引擎中的排名和曝光度。</span></p><pre><code><code># https://www.wztlink1013.comUser-agent: *Disallow: /Sitemap: https://www.wztlink1013.com/sitemap.xml</code></code></pre><ul class="ne-ul"><li id="u7e1ac461" data-lake-index-type="0"><span class="ne-text">User-agent：* 表示允许所有搜索引擎访问您的网站，如果限定的话，则键入 </span><code class="ne-code"><span class="ne-text">[搜索引擎名称]</span></code></li><li id="ue346fd0f" data-lake-index-type="0"><span class="ne-text">Sitemap：说明sitemap文件url</span></li><li id="udac61ea6" data-lake-index-type="0"><span class="ne-text">Disallow：</span><code class="ne-code"><span class="ne-text">/</span></code><span class="ne-text">表示禁止该搜索引擎访问您的网站中所有页面和文件</span></li></ul><div class="ne-quote"><ul class="ne-ul"><li id="ub8c27d16" data-lake-index-type="0"><span class="ne-text">检测自己写的robots文件是否生效：</span><a href="https://ziyuan.baidu.com/robots/intro" data-href="https://ziyuan.baidu.com/robots/intro" target="_blank" class="ne-link"><span class="ne-text">https://ziyuan.baidu.com/robots/intro</span></a><span class="ne-text"></span></li><li id="ub1d1e5aa" data-lake-index-type="0"><span class="ne-text">语法规则：</span><a href="https://ziyuan.baidu.com/college/courseinfo?id=267&amp;page=13" data-href="https://ziyuan.baidu.com/college/courseinfo?id=267&amp;page=13" target="_blank" class="ne-link"><span class="ne-text">https://ziyuan.baidu.com/college/courseinfo?id=267&amp;page=13</span></a></li></ul></div><p id="ufb489ca3" class="ne-p"><br></p><h3 id="NzJnY"><span class="ne-text">❗</span><span class="ne-text">百度不再允许大多数站点提交sitemap文件</span></h3><p id="u7080f3da" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2024/png/1484158/1705232927775-66b2b6e8-1f1c-40aa-a427-c3e9b59d680d.png" width="1098.3332896894897" id="u41efa066" class="ne-image"></p><p id="uadbf9159" class="ne-p"><span class="ne-text">如果之前没有提交过sitemap链接的，貌似没有办法提交sitemap链接了，如果之前提交过应该不受影响。。。</span></p></div>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;!doctype html&gt;&lt;div class=&quot;lake-content&quot; typography=&quot;classic&quot;&gt;&lt;p id=&quot;ub944b1e4&quot; class=&quot;ne-p&quot;&gt;&lt;span</summary>
        
      
    
    
    
    <category term="Web开发" scheme="https://www.wztlink1013.com/categories/Web%E5%BC%80%E5%8F%91/"/>
    
    <category term="博客技术" scheme="https://www.wztlink1013.com/categories/Web%E5%BC%80%E5%8F%91/%E5%8D%9A%E5%AE%A2%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
</feed>
