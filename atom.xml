<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>尼采般地抒情</title>
  <icon>https://www.wztlink1013.com/favicon.ico</icon>
  <subtitle>什么都不舍弃，什么也改变不了</subtitle>
  <link href="https://www.wztlink1013.com/atom.xml" rel="self"/>
  
  <link href="https://www.wztlink1013.com/"/>
  <updated>2024-01-10T21:12:03.000Z</updated>
  <id>https://www.wztlink1013.com/</id>
  
  <author>
    <name>尼采般地抒情</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>React系统学习（三）组件通信</title>
    <link href="https://www.wztlink1013.com/blog/ugugf75zazxyxy8t/"/>
    <id>https://www.wztlink1013.com/blog/ugugf75zazxyxy8t/</id>
    <published>2024-01-02T16:35:41.000Z</published>
    <updated>2024-01-10T21:12:03.000Z</updated>
    
    <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h3 id="Hp11O"><span class="ne-text">父传子（Props）</span></h3><p id="u33a79e2b" class="ne-p"><span class="ne-text">利用props传值</span></p><ol class="ne-ol"><li id="u1fc1373b" data-lake-index-type="0"><span class="ne-text">组件默认值的写法</span></li></ol><ol start="2" class="ne-ol"><li id="u65cf9e83" data-lake-index-type="0"><span class="ne-text">点标记写法就相当于组件作为一个对象值</span></li></ol><pre><code><code>const Son = (props: any) =&gt; &#123;  console.log('parent to son: ', props);  return &lt;div&gt;son&lt;/div&gt;;&#125;;// Son default propsSon.defaultProps = &#123;  msg: 'son-default-msg',&#125;;<p>export default () =&gt; &#123;<br>  const [parentMsg, setParentMsg] = useState(‘parent-msg’);<br>  return (<br>    &lt;&gt;<br>      &lt;h1&gt;react-message&lt;/h1&gt;<br>      parent<br>      &lt;Son msg=&#123;parentMsg&#125; /&gt;<br>    &lt;/&gt;<br>  );<br>&#125;;<br></code><br></code></pre></p><h3 id="hSjM1"><span class="ne-text">子传父</span></h3><p id="u10d5d71a" class="ne-p"><span class="ne-text"> 在父组件定义响应式变量，同时传递一个回调函数参数给子组件，子组件再利用调用回调函数给便父组件所定义的响应式变量</span></p><pre><code><code>const Son = (props: any) =&gt; &#123;  console.log('parent to son: ', props.msg);  const sonToParentClick = () =&gt; &#123;    props.getSonValue('son-to-parent-msg');  &#125;;  return (    &lt;div&gt;      son&lt;button onClick=&#123;sonToParentClick&#125;&gt;son-to-parent&lt;/button&gt;    &lt;/div&gt;  );&#125;;Son.defaultProps = &#123;  msg: 'son-default-msg',&#125;;<p>export default () =&gt; &#123;<br>  const [parentToSonMsg, setParentToSonMsg] = useState(‘parent-to-son-msg’);<br>  const [getSonMsg, setGetSonMsg] = useState(‘’);<br>  const getSonValue = (msg: string) =&gt; &#123;<br>    console.log(‘son-to-parent-msg: ‘, msg);<br>    setGetSonMsg(msg);<br>  &#125;;<br>  return (<br>    &lt;&gt;<br>      &lt;h1&gt;react-message&lt;/h1&gt;<br>      parent<br>      &lt;Son msg=&#123;parentToSonMsg&#125; getSonValue=&#123;getSonValue&#125; /&gt;<br>    &lt;/&gt;<br>  );<br>&#125;;<br></code><br></code></pre></p><h3 id="C0st3"><span class="ne-text">爷传后代</span></h3><h4 id="XjAnb"><span class="ne-text">爷传孙</span></h4><ol class="ne-ol"><li id="u2c9e1c20" data-lake-index-type="0"><span class="ne-text">第一种方式就是利用剩余参数爷传子，子再传孙，不过这种方式繁琐且不便维护</span></li><li id="ub393f0aa" data-lake-index-type="0"><span class="ne-text">利用下面的透传方式</span></li></ol><h4 id="NgI5A"><span class="ne-text">透传（Context）</span></h4><pre><code><code>import &#123; createContext &#125; from 'react';<p>const Context = createContext(&#123;&#125;);</p><p>const Son = (props: any) =&gt; &#123;<br>  console.log(‘parent to son: ‘, props.msg);<br>  const sonToParentClick = () =&gt; &#123;<br>    props.getSonValue(‘son-to-parent-msg’);<br>  &#125;;<br>  return (<br>    &lt;&gt;<br>      &lt;div&gt;<br>        son&lt;button onClick=&#123;sonToParentClick&#125;&gt;son-to-parent&lt;/button&gt;<br>      &lt;/div&gt;<br>      &lt;GradeSon /&gt;<br>    &lt;/&gt;<br>  );<br>&#125;;<br>Son.defaultProps = &#123;<br>  msg: ‘son-default-msg’,<br>&#125;;</p><p>const GradeSon = () =&gt; &#123;<br>  const getGrandFather = useContext(Context);<br>  console.log(‘get-grand-father: ‘, getGrandFather);<br>  return &lt;div&gt;GradeSon&lt;/div&gt;;<br>&#125;;</p><p>export default () =&gt; &#123;<br>  const [parentToSonMsg, setParentToSonMsg] = useState(‘parent-to-son-msg’);<br>  const [parentToGradeSonMsg, setParentToGradeSonMsg] = useState(&#123; a: 11, b: 22 &#125;);<br>  const [getSonMsg, setGetSonMsg] = useState(‘’);<br>  const getSonValue = (msg: string) =&gt; &#123;<br>    console.log(‘son-to-parent-msg: ‘, msg);<br>    setGetSonMsg(msg);<br>  &#125;;<br>  return (<br>    &lt;Context.Provider value=&#123;parentToGradeSonMsg&#125;&gt;<br>      &lt;h1&gt;react-message&lt;/h1&gt;<br>      parent<br>      &lt;Son msg=&#123;parentToSonMsg&#125; getSonValue=&#123;getSonValue&#125; /&gt;<br>    &lt;/Context.Provider&gt;<br>  );<br>&#125;;<br></code><br></code></pre></p><h3 id="kPf70"><span class="ne-text">EventBus</span></h3><p id="u56c51230" class="ne-p"><span class="ne-text">事件总线的方式，其实这属于前端通用的一种设计模式，在线编辑器常用的一种代码设计模式</span></p><ol class="ne-ol"><li id="ue47632f0" data-lake-index-type="0"><span class="ne-text">事件封装：只封装了on、emit、off事件，实际上封装形式不一，也可以使用三方库等</span></li></ol><pre><code><code>type StringKeyOf&lt;T&gt; = Extract&lt;keyof T, string&gt;;type CallbackType&lt;  T extends Record&lt;string, any&gt;,  EventName extends StringKeyOf&lt;T&gt;,&gt; = T[EventName] extends any[] ? T[EventName] : [T[EventName]];type CallbackFunction&lt;T extends Record&lt;string, any&gt;, EventName extends StringKeyOf&lt;T&gt;&gt; = (  ...props: CallbackType&lt;T, EventName&gt;) =&gt; any;<p>export class EventEmitter&lt;T extends Record&lt;string, any&gt;&gt; &#123;<br>  private callbacks: &#123; [key: string]: Function[] &#125; = &#123;&#125;;</p><p>  public on&lt;EventName extends StringKeyOf&lt;T&gt;&gt;(<br>    event: EventName,<br>    fn: CallbackFunction&lt;T, EventName&gt;,<br>  ): this &#123;<br>    if (!this.callbacks[event]) &#123;<br>      this.callbacks[event] = [];<br>    &#125;</p><pre><code>this.callbacks[event].push(fn);return this;</code></pre><p>  }</p><p>  public emit&lt;EventName extends StringKeyOf&lt;T&gt;&gt;(<br>    event: EventName,<br>    …args: CallbackType&lt;T, EventName&gt;<br>  ): this {<br>    const callbacks = this.callbacks[event];</p><pre><code>if (callbacks) &#123;  callbacks.forEach(callback =&amp;gt; callback.apply(this, args));&#125;return this;</code></pre><p>  }</p><p>  public off&lt;EventName extends StringKeyOf&lt;T&gt;&gt;(<br>    event: EventName,<br>    fn?: CallbackFunction&lt;T, EventName&gt;,<br>  ): this {<br>    const callbacks = this.callbacks[event];</p><pre><code>if (callbacks) &#123;  if (fn) &#123;    this.callbacks[event] = callbacks.filter(callback =&amp;gt; callback !== fn);  &#125; else &#123;    delete this.callbacks[event];  &#125;&#125;return this;</code></pre><p>  }</p><p>  protected removeAllListeners(): void {<br>    this.callbacks = {};<br>  }<br>}</p><p>const EventBus = new EventEmitter();<br>export default EventBus;</code><br></code></pre></p><ol start="2" class="ne-ol"><li id="uc993bf4f" data-lake-index-type="0"><span class="ne-text">使用</span></li></ol><ol class="ne-list-wrap"><ol ne-level="1" class="ne-ol"><li id="uaaccabd0" data-lake-index-type="0"><span class="ne-text">Daughter组件定义，Son组件触发</span></li><li id="u16a192b3" data-lake-index-type="0"><span class="ne-text">有注册就要有注销，不然内存中会出现重复事件逻辑多次执行的问题</span></li></ol></ol><pre><code><code>import &#123; createContext &#125; from 'react';import EventBus from '@/utils/eventEmitter';<p>const Context = createContext(&#123;&#125;);</p><p>const Son = (props: any) =&gt; &#123;<br>  console.log(‘parent to son: ‘, props.msg);<br>  const sonToParentClick = () =&gt; &#123;<br>    props.getSonValue(‘son-to-parent-msg’);<br>    EventBus.emit(‘daughterEvent’, &#123;<br>      msg: ‘son-to-daughter-msg’,<br>    &#125;);<br>  &#125;;<br>  return (<br>    &lt;&gt;<br>      &lt;div&gt;<br>        son&lt;button onClick=&#123;sonToParentClick&#125;&gt;son-to-parent&lt;/button&gt;<br>      &lt;/div&gt;<br>      &lt;GradeSon /&gt;<br>    &lt;/&gt;<br>  );<br>&#125;;<br>Son.defaultProps = &#123;<br>  msg: ‘son-default-msg’,<br>&#125;;</p><p>const Daughter = () =&gt; &#123;<br>  useEffect(() =&gt; &#123;<br>    function daughterEvent(data: any) &#123;<br>      console.warn(‘daughter event: ‘, data);<br>    &#125;<br>    EventBus.on(‘daughterEvent’, daughterEvent);<br>    return () =&gt; &#123;<br>      EventBus.off(‘daughterEvent’, daughterEvent);<br>    &#125;;<br>  &#125;, []);<br>  return &lt;div&gt;Daughter&lt;/div&gt;;<br>&#125;;</p><p>const GradeSon = () =&gt; &#123;<br>  const getGrandFather = useContext(Context);<br>  console.log(‘get-grand-father: ‘, getGrandFather);<br>  return &lt;div&gt;GradeSon&lt;/div&gt;;<br>&#125;;</p><p>export default () =&gt; &#123;<br>  const [parentToSonMsg, setParentToSonMsg] = useState(‘parent-to-son-msg’);<br>  const [parentToGradeSonMsg, setParentToGradeSonMsg] = useState(&#123; a: 11, b: 22 &#125;);<br>  const [getSonMsg, setGetSonMsg] = useState(‘’);<br>  const getSonValue = (msg: string) =&gt; &#123;<br>    console.log(‘son-to-parent-msg: ‘, msg);<br>    setGetSonMsg(msg);<br>  &#125;;<br>  return (<br>    &lt;&gt;<br>      &lt;Context.Provider value=&#123;parentToGradeSonMsg&#125;&gt;<br>        &lt;h1&gt;react-message&lt;/h1&gt;<br>        parent<br>        &lt;Son msg=&#123;parentToSonMsg&#125; getSonValue=&#123;getSonValue&#125; /&gt;<br>      &lt;/Context.Provider&gt;<br>      &lt;Daughter /&gt;<br>    &lt;/&gt;<br>  );<br>&#125;;<br></code><br></code></pre></p><h3 id="DYES7"><span class="ne-text">状态管理</span></h3><p id="u2c679f4e" class="ne-p"><span class="ne-text">状态管理所定义的Module变化，所使用到的组件也会响应式更新，不做详细记录。</span></p></div>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;!doctype html&gt;&lt;div class=&quot;lake-content&quot; typography=&quot;classic&quot;&gt;&lt;h3 id=&quot;Hp11O&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;父传子（Props）&lt;/span&gt;&lt;/h3&gt;&lt;p id=&quot;u33a79e2b&quot;</summary>
        
      
    
    
    
    <category term="Web开发" scheme="https://www.wztlink1013.com/categories/Web%E5%BC%80%E5%8F%91/"/>
    
    <category term="React" scheme="https://www.wztlink1013.com/categories/Web%E5%BC%80%E5%8F%91/React/"/>
    
    
  </entry>
  
  <entry>
    <title>React系统学习（二）生态链</title>
    <link href="https://www.wztlink1013.com/blog/okaxuuoq9kqk5hv3/"/>
    <id>https://www.wztlink1013.com/blog/okaxuuoq9kqk5hv3/</id>
    <published>2024-01-01T22:34:41.000Z</published>
    <updated>2024-01-03T23:17:03.000Z</updated>
    
    <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="uf81223da" class="ne-p"><span class="ne-text">生态系统有服务端渲染等，暂只对路由以及状态管理做部分记录。</span></p><h3 id="RG1RA"><span class="ne-text">路由Router</span></h3><ol class="ne-ol"><li id="u8de104d9" data-lake-index-type="0"><span class="ne-text">useParams：获取动态路由的路径值</span></li><li id="u5450e7cd" data-lake-index-type="0"><span class="ne-text">&lt;NavLink /&gt;：带样式的声明式路由</span></li><li id="u4f82b40a" data-lake-index-type="0"><span class="ne-text">useNavigate：编程式路由</span></li></ol><ol class="ne-list-wrap"><ol ne-level="1" class="ne-ol"><li id="uf612b599" data-lake-index-type="0"><span class="ne-text">第一个参数：跳转路径</span></li><li id="ude9b2662" data-lake-index-type="0"><span class="ne-text">第二个参数（state）：携带信息对象</span></li></ol></ol><ol start="4" class="ne-ol"><li id="u918edaba" data-lake-index-type="0"><span class="ne-text">useLocation</span></li><li id="ue0f4492b" data-lake-index-type="0"><span class="ne-text">useSearchParams：可以结构，同useState，第二个参数同样可以设置浏览器地址栏的url params </span></li><li id="u859c95b4" data-lake-index-type="0"><span class="ne-text">lodaer：路由表的字段，路由跳转前的处理函数，支持异步，这里做调取权限查询接口等逻辑</span></li></ol><ol class="ne-list-wrap"><ol ne-level="1" class="ne-ol"><li id="ua7441b4e" data-lake-index-type="0"><span class="ne-text">如果返回值需要重定向指定url -&gt; </span><code class="ne-code"><span class="ne-text">return redirect('login')</span></code></li></ol></ol><ol start="7" class="ne-ol"><li id="u28cc1c98" data-lake-index-type="0"><span class="ne-text">meta：自定义元信息</span></li></ol><ol class="ne-list-wrap"><ol ne-level="1" class="ne-ol"><li id="u167efcc8" data-lake-index-type="0"><span class="ne-text">组件中获取元信息：matchRoutes和useLocation</span></li></ol></ol><span style="margin-left: 2em"><pre><code><code>const location = useLocation()const matchs = matchRoutes(routes, location)const meta = matchs[matchs.length - 1].route.meta</code></code></pre></span><h3 id="Cavfr"><span class="ne-text">状态管理Redux</span></h3><p id="ubbcb0f40" class="ne-p"><span class="ne-text">Redux是一个独立的状态管理的库。</span></p><ol class="ne-ol"><li id="u916db48f" data-lake-index-type="0"><span class="ne-text">react-redux：对于redux封装至更符合react理念的库</span></li></ol><ol class="ne-list-wrap"><ol ne-level="1" class="ne-ol"><li id="u056b4da4" data-lake-index-type="0"><span class="ne-text">useSelector</span></li><li id="ua86b158c" data-lake-index-type="0"><span class="ne-text">useDispatch</span></li></ol></ol><ol start="2" class="ne-ol"><li id="u7b50b918" data-lake-index-type="0"><span class="ne-text">Redux-Toolkit：</span></li></ol><ol class="ne-list-wrap"><ol ne-level="1" class="ne-ol"><li id="ucbbfbb0c" data-lake-index-type="0"><span class="ne-text">封装redux的大多数操作</span></li><li id="u4f0fc676" data-lake-index-type="0"><span class="ne-text">优化异步处理createAsyncThunk</span></li></ol></ol><ol start="3" class="ne-ol"><li id="u728fa4d6" data-lake-index-type="0"><span class="ne-text">redux-persist：数据持久化处理</span></li></ol><p id="ub8fac65f" class="ne-p"><span class="ne-text"></span></p><p id="uab0de432" class="ne-p"><span class="ne-text"></span></p><p id="u2486779b" class="ne-p"><span class="ne-text"></span></p><p id="u7573cf56" class="ne-p"><span class="ne-text"></span></p><p id="u10ec026e" class="ne-p"><span class="ne-text"></span></p><p id="u5e88c3f6" class="ne-p"><span class="ne-text"></span></p><p id="u4e1d4445" class="ne-p"><span class="ne-text"></span></p><p id="ue1c440ca" class="ne-p"><span class="ne-text"></span></p><p id="uf7d94f98" class="ne-p"><span class="ne-text"></span></p></div>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;!doctype html&gt;&lt;div class=&quot;lake-content&quot; typography=&quot;classic&quot;&gt;&lt;p id=&quot;uf81223da&quot; class=&quot;ne-p&quot;&gt;&lt;span</summary>
        
      
    
    
    
    <category term="Web开发" scheme="https://www.wztlink1013.com/categories/Web%E5%BC%80%E5%8F%91/"/>
    
    <category term="React" scheme="https://www.wztlink1013.com/categories/Web%E5%BC%80%E5%8F%91/React/"/>
    
    
  </entry>
  
  <entry>
    <title>React系统学习（一）类组件和函数组件</title>
    <link href="https://www.wztlink1013.com/blog/wnb93ckult99ixhg/"/>
    <id>https://www.wztlink1013.com/blog/wnb93ckult99ixhg/</id>
    <published>2023-12-23T05:22:20.000Z</published>
    <updated>2024-01-04T05:04:12.000Z</updated>
    
    <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h3 id="xVmON"><span class="ne-text">虚拟DOM以及React挂载DOM的方式</span></h3><ol class="ne-ol"><li id="u0893e863" data-lake-index-type="0"><span class="ne-text">利用JavaScript脚本操作DOM的行为是性能损耗的大头，故产生虚拟DOM的概念。初始化在内存中得到相应的虚拟DOM树，然后将该结果一次性作用于真实DOM，逻辑层的变动导致部分视图层的改变这渲染逻辑也是经过虚拟DOM加上diff得到一次性结果然后作用于真实DOM，在这里Vue和React都是一样的。</span></li><li id="u7537df37" data-lake-index-type="0"><span class="ne-text">可以简单理解：react模块旨在完成虚拟dom的相关逻辑，react-dom模块旨在完成真实DOM和diff的处理</span></li></ol><pre><code><code>// mount containerrootReactDOM.createRoot(document.querySelector('#root'))// create VDOMconst data = React.createElement('div', &#123;&#125;, 'data')// VDOM -&gt; true DOMroot.render(data)</code></code></pre><h3 id="vL2nu"><span class="ne-text">JSX</span></h3><p id="u20bc5507" class="ne-p"><span class="ne-text">上述ReactDOM生成虚拟DOM的方式，实际编写代码不方便，于是出现了类似JSX来简化视图层的代码编写（Vue中利用Template模板来完成相同视图层的逻辑构建）</span></p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/1484158/1703514464788-2de399dc-93ec-4dec-aa38-e6b6c706f0ea.jpeg" id="iIrkc" style="display: block; width: 100%"><ol start="2" class="ne-ol"><li id="uec638825" data-lake-index-type="0"><span class="ne-text">JSX的识别要么在jsx后缀文件书写相关代码逻辑，要么利用babel工具来进行代码转义..</span></li></ol><pre><code><code>const data = (  &lt;div&gt;    content&lt;span&gt;something...&lt;/span&gt;  &lt;/div&gt;)root.render(data)</code></code></pre><ol start="3" class="ne-ol"><li id="u5676031e" data-lake-index-type="0"><span class="ne-text">模板语法：</span><code class="ne-code"><span class="ne-text">&#123;&#125;</span></code><span class="ne-text">，Vue是是</span><code class="ne-code"><span class="ne-text">&#123;&#123;&#125;&#125;</span></code></li></ol><ol class="ne-list-wrap"><ol ne-level="1" class="ne-ol"><li id="u9c91fce8" data-lake-index-type="0"><span class="ne-text">注释：</span><code class="ne-code"><span class="ne-text">&#123;/* */&#125;</span></code></li><li id="ubb6f0de2" data-lake-index-type="0"><span class="ne-text">内容可以变量、函数、JSX嵌套 ······</span></li></ol></ol><ol start="4" class="ne-ol"><li id="u77d43f1f" data-lake-index-type="0"><span class="ne-text">JSX注意事项</span></li></ol><ol class="ne-list-wrap"><ol ne-level="1" class="ne-ol"><li id="u8c6babba" data-lake-index-type="0"><span class="ne-text">严格单标签（</span><code class="ne-code"><span class="ne-text">&lt;Tab /&gt;</span></code><span class="ne-text">）</span></li><li id="ub546b2eb" data-lake-index-type="0"><span class="ne-text">标签名小写</span></li><li id="u0a3d772d" data-lake-index-type="0"><span class="ne-text">唯一根节点 -&gt; </span><code class="ne-code"><span class="ne-text">&lt;&gt;&lt;/&gt;</span></code><span class="ne-text"> 或 </span><code class="ne-code"><span class="ne-text">React.Fragment</span></code></li><li id="u3a39620f" data-lake-index-type="0"><span class="ne-text">部分HTML属性名变动：</span><code class="ne-code"><span class="ne-text">class -&gt; className</span></code><span class="ne-text">; </span><code class="ne-code"><span class="ne-text">for -&gt; htmlFor</span></code><span class="ne-text"> ······</span></li><li id="u70ef716d" data-lake-index-type="0"><span class="ne-text">多单词属性用驼峰方式书写，dataset除外</span></li></ol></ol><h3 id="E1Lfq"><span class="ne-text">理解类组件</span></h3><ol class="ne-ol"><li id="ud1f196e0" data-lake-index-type="0"><span class="ne-text">组件的概念也就是模块的拆分、抽象和复用，和Vue组件一致，React的组件编写有两种，</span><strong><span class="ne-text">类组件</span></strong><span class="ne-text">和</span><strong><span class="ne-text">函数组件</span></strong><span class="ne-text">，实际编写代码，React18函数式组件编写更为推崇，但是理解上以类组件会更好。</span></li><li id="u73a8c970" data-lake-index-type="0"><span class="ne-text">具体类组件的编写，其实就是在面向对象编程，给你一个已知类React.Component，写具体逻辑时，遵照所继承的类的一些规则来扩展业务代码。</span></li></ol><h4 id="qjAcc"><span class="ne-text">简单的父子通信</span></h4><pre><code><code>// A componentclass A extends React.Component &#123;  constructor(props) &#123;    super(props)    this.props = props  &#125;  render &#123;    this.props.getData('data')    return (      &lt;div&gt;A component &#123;this.props.info&#125; &lt;/div&gt;    )  &#125;&#125;// B componentconst getData = (data) =&gt; &#123;  // result -&gt; data&#125;const data = &lt;div&gt;content &lt;A info='something' getData=&#123;getData&#125; /&gt; &lt;/div&gt;</code></code></pre><h4 id="Mh3VX"><span class="ne-text">props相关事项</span></h4><ol class="ne-ol"><li id="u64411e8a" data-lake-index-type="0"><span class="ne-text">传入组件的参数可以用扩展运算符来传入</span></li></ol><pre><code><code>const data = &#123;  info: 'something,  getData: (data) =&gt; &#123;&#125;,&#125;const data = &lt;div&gt;&lt;A &#123;...data&#125; /&gt;&lt;/div&gt;</code></code></pre><ol start="2" class="ne-ol"><li id="u855e1be4" data-lake-index-type="0"><span class="ne-text">单独属性值为true</span></li><li id="uf093ffd6" data-lake-index-type="0"><span class="ne-text">类组件的默认值</span></li></ol><pre><code><code>// A componentclass A extends React.Component &#123;  static defaultProps = &#123;    info: 'default info',  &#125;  constructor(props) &#123;    super(props)    this.props = props  &#125;  render &#123;    this.props.getData('data')    return (      &lt;div&gt;A component &#123;this.props.info&#125; &lt;/div&gt;    )  &#125;&#125;</code></code></pre><h4 id="PV0r6"><span class="ne-text">响应式变量</span></h4><p id="uc9c5250a" class="ne-p"><span class="ne-text">前端框架必须具体的一个能力就是响应式变量的构造，以及内部实现的动态渲染，react的响应式变量就是构造类的一个私有变量state，再利用其规定指定的方法setState方法来实现响应式</span></p><pre><code><code>class A extends React.Component &#123;  state &#123;    a: 1,  &#125;  static defaultProps = &#123;    info: 'default info',  &#125;  constructor(props) &#123;    super(props)    this.props = props  &#125;  render &#123;    this.props.getData('data')    return (      &lt;div&gt;A component &#123;this.props.info&#125; &lt;/div&gt;    )  &#125;handleMethod() &#123;    this.setState(&#123; a: 2 &#125;)&#125;&#125;</code></code></pre><div data-type="info" class="ne-alert"><p id="ub5f23f2f" class="ne-p"><span class="ne-text">如果响应式的值为数组呢？</span></p></div><ol class="ne-ol"><li id="ued321890" data-lake-index-type="0"><span class="ne-text">react里面的响应式的值为不可变数据集合，比较简单的情况可以利用剩余参数来解决该问题。</span></li></ol><pre><code><code>class A extends React.Component &#123;  state =&#123;    a: [1, 2, 3]  &#125;  ···  handleMethod() &#123;    this.setState(&#123; a: [...a, 4] &#125;)  &#125;&#125;</code></code></pre><ol start="2" class="ne-ol"><li id="ubcbe280c" data-lake-index-type="0"><span class="ne-text">深拷贝</span></li></ol><p id="uee425f9f" class="ne-p"><span class="ne-text">（TODO:  应该有更好的解决方式）</span></p><h4 id="xfck5"><span class="ne-text">批处理</span></h4><p id="ufd1bdefd" class="ne-p"><span class="ne-text">响应式处理，内部会一次性收集当前变化的量，进入一个处理队列，最终得到一个最终态来进行渲染，避免状态改变多次渲染的情况。</span></p><ol class="ne-ol"><li id="u0706a769" data-lake-index-type="0"><span class="ne-text">React18之前，在一些函数执行时机下，不会进行批处理，React18之后解决了这个问题。具体有：Promise、setTimeout、原生事件下</span></li><li id="u4bc7f994" data-lake-index-type="0"><span class="ne-text">React提供了防止批处理的函数</span></li></ol><pre><code><code>class A extends React.Component &#123;  state =&#123;    a: 1  &#125;  ···  handleMethod() &#123;    ReactDOM.flushSync(() =&gt; &#123;      this.setState(&#123; a: this.state.a + 1 &#125;)      this.setState(&#123; a: this.state.a + 1 &#125;)    &#125;)    // result: run twice render method...  &#125;  render &#123;    console.info('react render.')    return (      &lt;div&gt;A component &#123;this.props.info&#125; &lt;/div&gt;    )  &#125;&#125;</code></code></pre><ol start="3" class="ne-ol"><li id="uc4f4442b" data-lake-index-type="0"><span class="ne-text">setState是一个一个异步函数，其第二个参数可以传入回调函数，以便写状态改变之后的相关业务逻辑</span></li><li id="uc0538438" data-lake-index-type="0"><span class="ne-text">如果传入setState的值是对象，那么会在响应式内部所收集变化的量里面进行覆盖，如果需要实时根据最新变化的量做逻辑处理，则需要传入一个参数为state的回调函数</span></li></ol><pre><code><code>class A extends React.Component &#123;  state =&#123;    a: 1  &#125;  ···  handleMethod() &#123;    // 1. cover state    this.setState(&#123; a: this.state.a + 1 &#125;)    this.setState(&#123; a: this.state.a + 1 &#125;)    // result: a -&gt; 2    // 2. real time state    this.setState((state) =&gt; &#123; a: this.state.a + 1 &#125;)    this.setState((state) =&gt; &#123; a: this.state.a + 1 &#125;)    // result: a -&gt; 3  &#125;&#125;</code></code></pre><h4 id="ZhZcD"><span class="ne-text">PureComponent shouldComponentUpdate</span></h4><p id="u1410dea8" class="ne-p"><span class="ne-text">下面代码，因响应式变量变化，所以会执行一次render渲染</span></p><pre><code><code>class A extends React.Component &#123;  state =&#123;    a: 1  &#125;  ···  handleMethod() &#123;    this.setState(&#123; a: 1 &#125;)  &#125;  render &#123;    console.info('react render.')    return (      &lt;div&gt;A component &#123;this.props.info&#125; &lt;/div&gt;    )  &#125;&#125;</code></code></pre><p id="u17863ce9" class="ne-p"><span class="ne-text">上面情况其实响应式的结果都是a变为1，所以从渲染结果上看其实可以优化掉该种情况的渲染，react提供的渲染优化方式有两种：</span></p><p id="u185cfd38" class="ne-p"><span class="ne-text"></span></p><ol class="ne-ol"><li id="ub05164da" data-lake-index-type="0"><span class="ne-text">PureComponent优化组件</span></li></ol><pre><code><code>class A extends React.PureComponent &#123;  ···&#125;</code></code></pre><ol start="2" class="ne-ol"><li id="u79b67ec0" data-lake-index-type="0"><span class="ne-text">shouldComponentUpdate生命周期函数</span></li></ol><pre><code><code>class A extends React.Component &#123;  state =&#123;    a: 1  &#125;  ···  shouldComponentUpdate = (nextProps, nextState) =&gt; &#123;    if (nextState.a === this.state.a)    return false // not render    return true // run render  &#125;  render &#123;    console.info('react render.')    return (      &lt;div&gt;A component &#123;this.props.info&#125; &lt;/div&gt;    )  &#125;&#125;</code></code></pre><h4 id="pQyxA"><span class="ne-text">Refs</span></h4><p id="ub19f3212" class="ne-p"><span class="ne-text">框架只是对渲染dom的前置操作做了一层封装，比如先构造虚拟dom或是渲染时机的优化等，但有些时候需要在业务代码里面直接获取dom进行操作，比如input标签的自动聚焦（focus）</span></p><ol class="ne-ol"><li id="u0cc8c58c" data-lake-index-type="0"><span class="ne-text">变量</span></li></ol><pre><code><code>// A componentclass A extends React.Component &#123;  inputRef = React.createRef()  // this.inputRef.current // -&gt; Input DOM  render &#123;    return (      &lt;div&gt;      A component        &lt;input ref=&#123;inputRef&#125; /&gt;      &lt;/div&gt;    )  &#125;&#125;</code></code></pre><ol start="2" class="ne-ol"><li id="u2a7e01e5" data-lake-index-type="0"><span class="ne-text">回调函数</span></li></ol><pre><code><code>// A componentclass A extends React.Component &#123;  inputRef = (dom) =&gt; &#123;    dom.focus()  &#125;  // this.inputRef.current // -&gt; Input DOM  render &#123;    return (      &lt;div&gt;      A component        &lt;input ref=&#123;inputRef&#125; /&gt;      &lt;/div&gt;    )  &#125;&#125;</code></code></pre><ol start="3" class="ne-ol"><li id="u4ef7dd4c" data-lake-index-type="0"><span class="ne-text">除了可以得到DOM，也可以得到类组件的实例对象</span></li></ol><pre><code><code>// A componentclass A extends React.Component &#123;···&#125;// B componentclass B extends React.Component &#123;refData = React.createRef()   render() &#123;    return &lt;div&gt;content &lt;A ref=&#123;refData&#125; /&gt; &lt;/div&gt;  &#125;&#125;</code></code></pre><h4 id="Q0460"><span class="ne-text">生命周期</span></h4><p id="u55e5dd6b" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2023/png/1484158/1703663129914-06e9fada-b622-489d-813f-9d0ed1dbba41.png" width="1511.6666065984325" id="ud7af5c92" class="ne-image"></p><h4 id="oH5uK"><span class="ne-text">组件模式：RenderProps</span></h4><pre><code><code>class A extends React.Component &#123;  state = &#123;    x: 0,    y: 0,  &#125;  constructor(props) &#123;    super(props)    this.props = props  &#125;  componentDidMount = () =&gt; &#123;    document.addEventListener('mousemove', this.move)  &#125;  componentWillUnMount = () =&gt; &#123;    document.removeEventListener('mousemove', this.move)  &#125;  move = (e) =&gt; &#123;    this.setState(&#123;      x: e.pageX,      y: e.pageY,    &#125;)  &#125;render() &#123;    return (      &lt;React.Fragment&gt;      &#123; this.props.render(this.state.x, this.state.y)&#125;      &lt;/React.Fragment&gt;    )  &#125;&#125;class B extends React.Component &#123;render() &#123;    return &lt;A render=&#123;(x, y) =&gt; &#123;      &lt;div&gt;&#123;x&#125;, &#123;y&#125;&lt;/div&gt;    &#125;&#125; /&gt;  &#125;&#125;</code></code></pre><h4 id="G0eUR"><span class="ne-text">组件模式：HOC</span></h4><p id="u7d429497" class="ne-p"><span class="ne-text">参数为组件，返回新组件</span></p><pre><code><code>function hocFun(WithComponent) &#123;  return class extends React.Component &#123;    state = &#123;      x: 0,      y: 0,    &#125;    componentDidMount = () =&gt; &#123;      document.addEventListener('mousemove', this.move)    &#125;    componentWillUnMount = () =&gt; &#123;      document.removeEventListener('mousemove', this.move)    &#125;    move = (e) =&gt; &#123;      this.setState(&#123;        x: e.pageX,        y: e.pageY,      &#125;)    &#125;      render() &#123;      return &lt;WithComponent &#123;...this.state&#125; /&gt;    &#125;  &#125;&#125;class A extends React.Component &#123;  render() &#123;    return (      &lt;div&gt;          &#123;this.props.x&#125;, &#123;this.props.y&#125;      &lt;/div&gt;    )  &#125;&#125;const C = hocFun(A)class B extends React.Component &#123;    render() &#123;    return &lt;C /&gt;  &#125;&#125;</code></code></pre><h4 id="L9n58"><span class="ne-text">Context通信</span></h4><pre><code><code>const ContextData = React.createContext()<p>class A extends React.Component &#123;<br>  state = &#123;<br>    info: ‘something’<br>  &#125;<br>  render() &#123;<br>    return (<br>      A<br>      &lt;ContextData.Provider value=&#123;this.state.info&#125;&gt;<br>          &lt;B /&gt;<br>      &lt;/ContextData.Provider&gt;<br>    )<br>  &#125;<br>&#125;<br>class B extends React.Component &#123;<br>    render() &#123;<br>    return (<br>      B&lt;C /&gt;<br>    )<br>  &#125;<br>&#125;<br>class C extends React.Component &#123;<br>  static contextType = ContextData<br>  componentDidMount = () =&gt; &#123;<br>    console.lof(this.context)<br>  &#125;<br>    render() &#123;<br>    return (<br>      C<br>      &lt;ContextData.Consumer&gt;&#123; value =&gt; value &#125;&lt;/ContextData.Consumer&gt;<br>    )<br>  &#125;<br>&#125;<br>// render -&gt; ABCsomething</code><br></code></pre></p><h3 id="NZSgh"><span class="ne-text">函数组件</span></h3><h4 id="QmOfo"><span class="ne-text">useState</span></h4><p id="uc98a614a" class="ne-p"><span class="ne-text">响应式变量的声明和改变</span></p><pre><code><code>import &#123; useState &#125; from 'React'const A = () =&gt; &#123;  const [a, setA] = useState('a')  return &lt;div&gt;a value: &#123;a&#125;&lt;/div&gt;&#125;</code></code></pre><p id="u5c324387" class="ne-p"><span class="ne-text">和类组件的差异</span></p><ol class="ne-ol"><li id="u157ea2c5" data-lake-index-type="0"><span class="ne-text">改变值的时候不会merge，而是覆盖</span></li><li id="ue3b27c3a" data-lake-index-type="0"><span class="ne-text">初始值可以值回调函数，但不能是函数否则每次改变都会重新执行一遍该函数</span></li><li id="ubf97f0c2" data-lake-index-type="0"><span class="ne-text">同样存在批处理，也有防止批处理的函数</span></li></ol><pre><code><code>import &#123; useState &#125; from 'React'import &#123; flushSync &#125; from 'ReactDDOM'const A = () =&gt; &#123;  const [a, setA] = useState('a')  const [b, setB] = useState('b')  flushSync(() =&gt; &#123;    setA('aa')  &#125;)    flushSync(() =&gt; &#123;    setB('bb')  &#125;)  return &lt;div&gt;a value: &#123;a&#125;&lt;/div&gt;&#125;</code></code></pre><ol start="4" class="ne-ol"><li id="u832252b4" data-lake-index-type="0"><span class="ne-text">传入的是值，渲染前会存在覆盖情况，如果传入的是函数，则会保留上一次的状态值计算</span></li></ol><h4 id="tIoMO"><span class="ne-text">useEffect</span></h4><p id="u5ed09388" class="ne-p"><span class="ne-text">副作用Hook</span></p><ol class="ne-ol"><li id="u28b6342c" data-lake-index-type="0"><span class="ne-text">模拟各个生命周期的执行时机</span></li></ol><pre><code><code>import &#123; useState, useEffect &#125; from 'React'const A = () =&gt; &#123;  useEffect(() =&gt; &#123;    // mount || update    return () =&gt; &#123;      // beforeUpdate || unMount      // clear sider function...    &#125;  &#125;)  return &lt;div&gt;a value: &#123;a&#125;&lt;/div&gt;&#125;</code></code></pre><ol start="2" class="ne-ol"><li id="u8886765a" data-lake-index-type="0"><span class="ne-text">关于第二个数组参数</span></li></ol><ol class="ne-list-wrap"><ol ne-level="1" class="ne-ol"><li id="u29eccab1" data-lake-index-type="0"><span class="ne-text">如果不设置，那么在update时期都会执行</span></li><li id="uaa101652" data-lake-index-type="0"><span class="ne-text">如果设置空数组（且回调函数中没有响应式变量），则只在mount时期执行一次</span></li><li id="u54d7662f" data-lake-index-type="0"><span class="ne-text">如果useEffect回调函数中存在响应式变量，那么第二个参数数组中应当有该响应式变量</span></li></ol></ol><ol start="3" class="ne-ol"><li id="u22c20e06" data-lake-index-type="0"><span class="ne-text">useLayoutEffect</span></li></ol><ol class="ne-list-wrap"><ol ne-level="1" class="ne-ol"><li id="u4977ceef" data-lake-index-type="0"><span class="ne-text">useEffect：渲染并绘制到屏幕之后执行，异步</span></li><li id="u97c48e0a" data-lake-index-type="0"><span class="ne-text">useLayoutEffect：渲染之后，但绘制到屏幕之前执行，同步</span></li><li id="u95a58cbe" data-lake-index-type="0"><span class="ne-text">一般如果回调函数中有DOM的相关操作并且会改变样式，用后者，避免DOM渲染闪屏/白屏，但前者性能方面更好</span></li></ol></ol><h4 id="Y3UvK"><span class="ne-text">useRef</span></h4><ol class="ne-ol"><li id="u32714bac" data-lake-index-type="0"><span class="ne-text">作用在DOM上的回调函数，则为DOM实例</span></li></ol><pre><code><code>const A = () =&gt; &#123;  const elementFun = (dom) =&gt; &#123;    // dom -&gt; input DOM  &#125;  return &lt;div&gt;&lt;input type=&quot;text&quot; ref=&#123;elementFun&#125; /&gt;&lt;/div&gt;&#125;</code></code></pre><ol start="2" class="ne-ol"><li id="ub1ccc233" data-lake-index-type="0"><span class="ne-text">作用在DOM上且为useRef函数，则为带有键为current值为DOM本身的对象</span></li></ol><pre><code><code>import &#123; useRef &#125; from 'React'const A = () =&gt; &#123;  const obj = useRef()  // obj =&gt; &#123; current: inputDOM &#125;  return &lt;div&gt;&lt;input type=&quot;text&quot; ref=&#123;obj&#125; /&gt;&lt;/div&gt;&#125;</code></code></pre><ol start="3" class="ne-ol"><li id="ucebe1755" data-lake-index-type="0"><span class="ne-text">不可以作用在组件上，但是子组件有React.forwardRef（组件转发）可以</span></li></ol><pre><code><code>import &#123; useRef &#125; from 'React'const Son = React.forwardRef((props, ref) =&gt; &#123;  return &lt;div&gt;&lt;input type=&quot;text&quot; ref=&#123;ref&#125; /&gt;&lt;/div&gt;&#125;)const A = () =&gt; &#123;  const obj = useRef()  // obj =&gt; &#123; current: inputDOM &#125;  return &lt;Son ref=&#123;obj&#125; /&gt;&#125;</code></code></pre><ol start="4" class="ne-ol"><li id="udbc656f8" data-lake-index-type="0"><span class="ne-text">利用useRef创建的普通变量，可以具备“记忆”功能，类似于类的实例属性。利用这一点可以设置一个flag来实现组件仅更新时触发的代码执行时机</span></li></ol><pre><code><code>import &#123; useRef, useEffect &#125; from 'React'const A = () =&gt; &#123;  const obj = useRef(false)  const inputOnClick = () =&gt; &#123;    obj.current = true  &#125;  useEffect(() =&gt; &#123;    if (obj.current) &#123;      // only update -&gt; run...    &#125;  &#125;)  return &lt;div&gt;&lt;input type=&quot;text&quot; onClick=&#123;inputOnClick&#125; /&gt;&lt;/div&gt;&#125;</code></code></pre><h4 id="o3MJh"><span class="ne-text">useContext</span></h4><p id="u816841d0" class="ne-p"><span class="ne-text">跨组件通信</span></p><pre><code><code>import &#123; useContext, createContext &#125; from 'React'<p>// not Provider value -&gt; render default value<br>const C = createContext(‘default value…’)</p><p>const GSon = () =&gt; &#123;<br>  const value = useContext(C)<br>  // value -&gt; something…<br>  return &lt;div&gt;GSon template…&lt;/div&gt;<br>&#125;<br>const Son = () =&gt; &#123;<br>  return &lt;GSon /&gt;<br>&#125;</p><p>const A = () =&gt; &#123;</p><p>  return (<br>    &lt;C.Provider value=’something…’&gt;<br>        &lt;Son ref=&#123;obj&#125; /&gt;<br>    &lt;/C.Provider&gt;<br>  )<br>&#125;</code><br></code></pre></p><h4 id="Sc8WH"><span class="ne-text">memo</span></h4><p id="u8f7f8983" class="ne-p"><span class="ne-text">类似类组件中的</span><code class="ne-code"><span class="ne-text">PureComponent</span></code><span class="ne-text">性能优化组件</span></p><ol class="ne-ol"><li id="u993d2be2" data-lake-index-type="0"><span class="ne-text">函数组件中当响应变量的值没有发生改变，不会重新渲染，和类组件不一样</span></li><li id="u110c7560" data-lake-index-type="0"><span class="ne-text">当组件的值发生改变才进行render，反之不进行render</span></li></ol><pre><code><code>import &#123; useState, memo &#125; from 'React'<p>const Son = memo(() =&gt; &#123;<br>  return &lt;div&gt;son&lt;/div&gt;<br>&#125;)</p><p>// continue click -&gt; continue run ↓<br>// const Son = () =&gt; &#123;<br>//   return &lt;div&gt;son&lt;/div&gt;<br>// &#125;</p><p>const A = () =&gt; &#123;<br>  const [count, setCount] = useState(0)<br>  const clickEvent = () =&gt; &#123;<br>    setCount(1)<br>  &#125;<br>  return (<br>    &lt;div&gt;<br>        &lt;button onClick=&#123;clickEvent&#125; &gt;click&lt;/button&gt;<br>        &lt;Son count=&#123;count&#125; /&gt;<br>    &lt;/div&gt;<br>  )<br>&#125;</code><br></code></pre></p><h4 id="hEQq3"><span class="ne-text">useMemo和useCallback</span></h4><p id="u146035fb" class="ne-p"><span class="ne-text">React函数式组件在重新渲染时候，代码执行会将函数体重新执行，即便结果不是重新更新DOM。如果函数体的代码逻辑复杂会带来不小的性能损耗，如果能够对这过程中的部分“量”进行“记忆”，则会较大提升性能。</span></p><p id="u89b5266b" class="ne-p"><span class="ne-text">响应式变量内部会自动进行记忆，但是如果是非响应式变量，比如一个对象或是一个函数传入组件，这其实也是改变了的，原因是对象的引用改变，依然会引起DOM的重新渲染，而利用useMemo或是useCallback创建的对象（对象、数组、函数）则会保留记忆功能。</span></p><ol class="ne-ol"><li id="u5de4e990" data-lake-index-type="0"><span class="ne-text">useCallback：传入回调函数</span></li><li id="u618a838d" data-lake-index-type="0"><span class="ne-text">useMemo：传入一个必须带有返回值的函数</span></li><li id="u18b45d54" data-lake-index-type="0"><span class="ne-text">两者的第二个参数都是依赖数组，同useEffect</span></li></ol><pre><code><code>import &#123; useCallback, useMemo &#125; from 'React'const A = () =&gt; &#123;  // 1. every render -&gt; run  const fun = () =&gt; &#123;&#125;  // 2. useCallback (ignore const error...)  const fun = useCallback(() =&gt; &#123;&#125;, [])  // 3. useMemo (ignore const error...)  const fun = useMemo(() =&gt; () =&gt; &#123;&#125;, [])  const a = useMemo(() =&gt; [1, 2, 3], [])  <p>  return &lt;div onClick=&#123;fun&#125; a=&#123;a&#125;&gt;&lt;/div&gt;<br>&#125;</code><br></code></pre></p><h4 id="zUHaR"><span class="ne-text">useReducer</span></h4><p id="u76ab5b03" class="ne-p"><span class="ne-text">管理多个有关联的响应式变量</span></p><pre><code><code>import &#123; useReducer &#125; from 'React<p>const loginState = &#123; isLogin: true, isLogout: false &#125;<br>const loginReducer = (state, action) =&gt; &#123;<br>  switch(action.type) &#123;<br>    case ‘login’:<br>      return &#123; isLogin: true, isLogout: false &#125;<br>    case ‘logout’:<br>      return &#123; isLogin: false, isLogout: true &#125;<br>    default:<br>      return new Error()<br>  &#125;<br>&#125;</p><p>const A = () =&gt; &#123;<br>  const [state, LoginDispatch] = useReducer(loginReducer, loginState)<br>  const clickEvent = () =&gt; &#123;<br>    loginDispatch(&#123; type: state.isLogin ? ‘logout’ : ‘login’ &#125;)<br>  &#125;</p><p>  return (<br>    &lt;button onClick=&#123;clickEvent&#125;&gt;&#123;state.isLogin ? ‘login’, ‘logout’&#125;&lt;/button&gt;<br>  )<br>&#125;</code><br></code></pre></p><h4 id="ZHgiq"><span class="ne-text">并发模式</span></h4><ol class="ne-ol"><li id="uf47bf115" data-lake-index-type="0"><span class="ne-text">React18之前，渲染是一个单一的、不间断的、同步的事务，一旦渲染开始，就不能被中断</span></li><li id="ufee7a81a" data-lake-index-type="0"><span class="ne-text">React18引入并发模式，它允许你将更新作为一个transitions，这会告诉React他们可以被中断执行。这样可以把紧急的任务先更新你，不紧急的任务后更新</span></li></ol><h4 id="SV5XT"><span class="ne-text">startTransition</span></h4><pre><code><code>import &#123; startTransition &#125; from 'React'const A = () =&gt; &#123;  ...  const fun = () =&gt; &#123;    // 紧急任务    setA('')    // 不紧急任务（将内部的任何非紧急状态更新标记为 Transition）    startTransition(() =&gt; setB(''))  &#125;  return &lt;div&gt;&lt;/div&gt;&#125;</code></code></pre><h4 id="LHIKS"><span class="ne-text">useTransition和useDeferredValue</span></h4><ol class="ne-ol"><li id="ubb651c66" data-lake-index-type="0"><span class="ne-text">useTransition返回一个状态值表示过渡任务的等待状态，以及一个启动该过渡任务的函数</span></li></ol><pre><code><code>import &#123; useTransition &#125; from 'React'const A = () =&gt; &#123;  ...  const [pending, startTransition] = useTransition()  const fun = () =&gt; &#123;    // 紧急任务    setA('')    // 不紧急任务（将内部的任何非紧急状态更新标记为 Transition）    startTransition(() =&gt; setB(''))  &#125;  return &lt;div&gt;&lt;/div&gt;&#125;</code></code></pre><ol start="2" class="ne-ol"><li id="u279291ea" data-lake-index-type="0"><span class="ne-text">useDeferredValue接受一个值，并返回该值的新副本，该副本将推迟到更紧急地更新之后</span></li></ol><pre><code><code>import &#123; useDeferredValue, useState &#125; from 'React'const A = () =&gt; &#123;  const [a, setA] = useState('')  // aD =&gt; 不紧急时候的值（同a），也就是延迟之后的值  const aD = useDeferredValue(a)  ...  return &lt;div&gt;&lt;/div&gt;&#125;</code></code></pre><h4 id="FnTQp"><span class="ne-text">自定义hook</span></h4><ol class="ne-ol"><li id="ue75e76dd" data-lake-index-type="0"><span class="ne-text">命名通常使用use开头</span></li><li id="u2bce0e3e" data-lake-index-type="0"><span class="ne-text"></span></li></ol><pre><code><code>import &#123; useState, useEffect &#125; from 'React'<p>const useMouseXY = () =&gt; &#123;<br>  const [x, setX] = usestate(0)<br>  const [y, setY] = usestate(0)</p><p>  useEffect(() =&gt; &#123;<br>    function move(e) &#123;<br>      setX(e.pageX)<br>      setY(e.pageY)<br>    &#125;<br>    document.addEventListener(‘mousemove’, move)<br>    return () =&gt; document.removeEventListener(‘mousemove’, move)<br>  &#125;, [])</p><p>  return &#123; x, y &#125;<br>&#125;</p><p>// use<br>const &#123; x, y &#125; = useMouseXY()</code><br></code></pre></p><h4 id="JPBEq"><span class="ne-text">lazy</span></h4><p id="udc1f9642" class="ne-p"><span class="ne-text">当模块化引入（import）组件，但在实际代码中未使用到，代码内部逻辑仍会执行，这个时候可以利用lazy使组件异步化加载，从而达到性能优化效果</span></p><pre><code><code>import &#123; lazy &#125; from 'react';<p>const AuthRoute = lazy(() =&gt; import(‘./AuthRoute’));<br>const ErrorPage = lazy(() =&gt; import(‘@/components/ErrorBoundary’));<br>const NotFound = lazy(() =&gt; import(‘@/pages/404’));</code><br></code></pre></p><h4 id="zYL5T"><span class="ne-text">Suspense</span></h4><p id="ueed27788" class="ne-p"><span class="ne-text">组件加载中或是切换过程中的“中间态”</span></p><pre><code><code>import &#123; Suspense, useState &#125; from 'react';import &#123; RouterProvider &#125; from 'react-router-dom';import router from '@/router/index';import Loading from '@/components/Loading';<p>function MyApp() &#123;<br>  const [show, setShow] = useState(true)<br>  const clickEvent = () =&gt; setShow(!show)<br>  return (<br>    &lt;&gt;<br>      &lt;button onClick=&#123;clickEvent&#125;&gt;btn&lt;/button&gt;<br>      &lt;Suspense fallback=&#123;&lt;Loading /&gt;&#125;&gt;<br>        &#123;show ? &lt;RouterProvider router=&#123;router&#125; /&gt; : &lt;&gt;other template&lt;/&gt;&#125;<br>      &lt;/Suspense&gt;<br>    &lt;/&gt;<br>  );<br>&#125;</p><p>export default MyApp;</code><br></code></pre></p><p id="ud8c681f0" class="ne-p"><span class="ne-text">结合startTransition使用：</span></p><p id="uad00f696" class="ne-p"><span class="ne-text">如果需要切换过程中不展示loading的加载态，则将上述代码中的切换逻辑转为并发异步即可</span></p><pre><code><code>const clickEvent = () =&gt; startTransition(() =&gt; setShow(!show))</code></code></pre><h4 id="vA6LY"><span class="ne-text">错误边界捕获</span></h4><p id="uce23988c" class="ne-p"><span class="ne-text">如果编写的组件内部报错，那么react渲染会清除根节点DOM，React官方文档暂时只有类组件编写的示例代码。其核心逻辑在类组件上支持关键的生命周期方法getDerivedStateFromError()和componentDidCatch()，无法将错误边界编写为函数式组件，同时以下几种错误情况，也捕获不到：</span></p><ol class="ne-ol"><li id="u153d38e4" data-lake-index-type="0"><span class="ne-text">异步代码</span></li><li id="u5764c7ba" data-lake-index-type="0"><span class="ne-text">事件处理函数</span></li><li id="ubdf3f9b1" data-lake-index-type="0"><span class="ne-text">服务器组件</span></li><li id="uae94c9a5" data-lake-index-type="0"><span class="ne-text">Error Boundary自身</span></li></ol><p id="u01d1627d" class="ne-p"><span class="ne-text">具体的完整封装 TODO: </span></p><h3 id="RG1RA"><span class="ne-text">ReactDOM</span></h3><h4 id="xAPZX"><span class="ne-text">createPortal</span></h4><ol class="ne-ol"><li id="u729bc8ae" data-lake-index-type="0"><span class="ne-text">可以指定节点挂载到指定目标DOM节点</span></li></ol><pre><code><code>// templateconst A = () =&gt; ReactDOM.createPortal(&lt;div&gt;info&lt;/div&gt;, document.body)</code></code></pre><ol start="2" class="ne-ol"><li id="u21e16b5d" data-lake-index-type="0"><span class="ne-text">对于一些全局组件（message），DOM的挂在可能不在root根节点内，自定义挂在指定DOM节点，除了上述createPortal方式，还有react的createRoot方式</span></li></ol></div>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;!doctype html&gt;&lt;div class=&quot;lake-content&quot; typography=&quot;classic&quot;&gt;&lt;h3 id=&quot;xVmON&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;虚拟DOM以及React挂载DOM的方式&lt;/span&gt;&lt;/h3&gt;&lt;ol</summary>
        
      
    
    
    
    <category term="Web开发" scheme="https://www.wztlink1013.com/categories/Web%E5%BC%80%E5%8F%91/"/>
    
    <category term="React" scheme="https://www.wztlink1013.com/categories/Web%E5%BC%80%E5%8F%91/React/"/>
    
    
  </entry>
  
  <entry>
    <title>TypeScript系统学习</title>
    <link href="https://www.wztlink1013.com/blog/torv9p4z2b79494z/"/>
    <id>https://www.wztlink1013.com/blog/torv9p4z2b79494z/</id>
    <published>2023-12-23T00:10:27.000Z</published>
    <updated>2024-01-03T22:52:50.000Z</updated>
    
    <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h4 id="DMAyy"><span class="ne-text">基础使用</span></h4><ol class="ne-ol"><li id="u662263d7" data-lake-index-type="0"><span class="ne-text">既是变量声明空间，也是类型声明空间</span></li><li id="u0d4282f1" data-lake-index-type="0"><span class="ne-text">类型分类：</span></li></ol><ol class="ne-list-wrap"><ol ne-level="1" class="ne-ol"><li id="u42e9bb1d" data-lake-index-type="0"><span class="ne-text">基本类型：也就是JavaScript中的七种基本类型</span></li><li id="u717293e5" data-lake-index-type="0"><span class="ne-text">对象类型：对象、数组、函数</span></li><li id="u7cfbb6db" data-lake-index-type="0"><span class="ne-text">typescript新增类型：any, never, void, unknown, enum</span></li></ol></ol><ol start="3" class="ne-ol"><li id="u8b1c9efb" data-lake-index-type="0"><span class="ne-text">联合类型和交叉类型：类型间的或跟与</span></li><li id="u61315403" data-lake-index-type="0"><span class="ne-text">断言（as）非空断言（!.）</span></li><li id="u13adc4e0" data-lake-index-type="0"><span class="ne-text">数组类型定义：type[]，Array&lt;string&gt;</span></li><li id="ua418feb9" data-lake-index-type="0"><span class="ne-text">元组类型定义：形式上类似JavaScript中的解构赋值</span></li></ol><span style="margin-left: 2em"><pre><code><code>let arr: [number, string] = [1, 'str'];arr[2] = 'test'; // ts error</code></code></pre></span><ol start="7" class="ne-ol"><li id="ub2d7406e" data-lake-index-type="0"><span class="ne-text">索引签名：</span></li></ol><ol class="ne-list-wrap"><ol ne-level="1" class="ne-ol"><li id="uabde14d8" data-lake-index-type="0"><span class="ne-text">比如后端返回的数据，字段不可能枚举完全</span></li></ol></ol><span style="margin-left: 2em"><pre><code><code>type ObjType = &#123;  a: string  b: number  [index: string]: any&#125;const obj: ObjType = &#123;  a: '11',  b: 22,  c: false,&#125;</code></code></pre></span><ol class="ne-list-wrap"><ol start="2" ne-level="1" class="ne-ol"><li id="u88d48f1f" data-lake-index-type="0"><span class="ne-text">也可以给数组设置类型</span></li></ol></ol><span style="margin-left: 2em"><pre><code><code>type ArrayType = &#123;  [index: number]: any&#125;const arr: ArrayType = ['111', 222, false]</code></code></pre></span><ol start="8" class="ne-ol"><li id="ubdb9547b" data-lake-index-type="0"><span class="ne-text">函数重载和可调用注解</span></li></ol><span style="margin-left: 2em"><pre><code><code>type FunType = &#123;  (n: number): number  key?: string&#125;let fun: FunType = (n) =&gt; nfun.key = 'test'</code></code></pre></span><ol start="9" class="ne-ol"><li id="u854e2d24" data-lake-index-type="0"><span class="ne-text">枚举类型（enum）：自定义枚举变量，优化代码可读性，其本质也是一个包装的JavaScript对象</span></li><li id="u339c427d" data-lake-index-type="0"><span class="ne-text">一般在交叉类型的具体内部逻辑中，需要判断实际变量所属类型，利用利用typeof、instanceof、in或是字面量类型来进行判断</span></li></ol><h4 id="EfHth"><span class="ne-text">接口</span></h4><ul class="ne-ul"><li id="u6f775147" data-lake-index-type="0"><span class="ne-text">接口和类型的差异</span></li></ul><ol class="ne-list-wrap"><ol ne-level="1" class="ne-ol"><li id="ua06d3aa0" data-lake-index-type="0"><span class="ne-text">接口的目标只能用在对象当中</span></li><li id="u5e246c5a" data-lake-index-type="0"><span class="ne-text">接口可以合并</span></li><li id="u3cc008e6" data-lake-index-type="0"><span class="ne-text">接口具备继承能力（和Java抽象类差不多）</span></li><li id="u18ff22ec" data-lake-index-type="0"><span class="ne-text">接口不能映射</span></li></ol></ol><h4 id="WiFCE"><span class="ne-text">字面量类型 keyof typeof</span></h4><ul class="ne-ul"><li id="u65329c6c" data-lake-index-type="0"><span class="ne-text">type的值可以直接存储为一种类型，比如h标签的所有类型值</span></li></ul><pre><code><code>type HTYPE = 'h1' | 'h2' | 'h3' | 'h4' | 'h5' | 'h6' |</code></code></pre><ul class="ne-ul"><li id="u9da9f0e8" data-lake-index-type="0"><span class="ne-text">keyof可以获取一个对象类型的所有关键字</span></li></ul><pre><code><code>interface A &#123;  a: string;  b: number&#125;const v: keyof A = // 'a' | 'b'</code></code></pre><pre><code><code>const obj = &#123;  a: '111',  b: 222,&#125;const v: keyof typeof obj = // 'a' | 'b'</code></code></pre><h4 id="P07Tb"><span class="ne-text">泛型</span></h4><ol class="ne-ol"><li id="u5f9ef2bc" data-lake-index-type="0"><span class="ne-text">函数和接口结合使用</span></li></ol><pre><code><code>interface A&lt;T&gt; &#123;  (n?: T): n  default?: T&#125;<p>const fun1: A&lt;string&gt; = (n) =&gt; n</p><p>fun1(‘111’)<br>fun1.default = ‘222’</code><br></code></pre></p><ol start="2" class="ne-ol"><li id="uc2890d23" data-lake-index-type="0"><span class="ne-text">类（class）中使用</span></li></ol><pre><code><code>class A&lt;T&gt; &#123;  public n!: T&#125;<p>const instance = new A&lt;string&gt;()<br>instance.n = ‘111’</code><br></code></pre></p><ol start="3" class="ne-ol"><li id="u425efa73" data-lake-index-type="0"><span class="ne-text">泛型约束</span></li></ol><p id="ufbcaea02" class="ne-p"><span class="ne-text">很多时候，泛型的“T”是已经知道的集中范围内的，就可以对泛型加以约束（extends）</span></p><pre><code><code>type I = string<p>class A&lt;T extends I&gt; &#123;<br>  public n!: T<br>&#125;</p><p>const instance = new A&lt;string&gt;()<br>instance.n = ‘111’</code><br></code></pre></p><h4 id="pUon2"><span class="ne-text">类</span></h4><ol class="ne-ol"><li id="u3d088ef4" data-lake-index-type="0"><span class="ne-text">接口（implements）</span></li></ol><pre><code><code>interface A &#123;  a: string  b: number  fun: (c: string, d: number) =&gt; void&#125;<p>class B implements A &#123;<br>  a!: string<br>  b!: number<br>  fun: (c: string, d: number) =&gt; &#123;&#125;<br>&#125;</code><br></code></pre></p><ol start="2" class="ne-ol"><li id="u328e816a" data-lake-index-type="0"><span class="ne-text">结合泛型</span></li></ol><pre><code><code>class A&lt;T&gt; &#123;  a: T  constructor(a: T) &#123;    this.a = a  &#125;&#125;<p>new A&lt;string&gt;(‘aaa’)</code><br></code></pre></p><pre><code><code>interface A&lt;T&gt; &#123;  a: T  b: number  fun: (c: T, d: number) =&gt; void&#125;class B implements A&lt;string&gt; &#123;  a!: string  b!: number  fun: (c: string, d: number) =&gt; &#123;&#125;&#125;</code></code></pre><h4 id="Gymk9"><span class="ne-text">映射</span></h4><p id="u80a1a45b" class="ne-p"><span class="ne-text">类似于对一个已有类型的“二次开发”</span></p><ol class="ne-ol"><li id="u08291f1b" data-lake-index-type="0"><span class="ne-text">一个例子：对一个已有类型对象的值都设置为只读的</span></li></ol><pre><code><code>type A = &#123;  a: string  b: string&#125;<p>type B&lt;T&gt; = &#123;<br>  readonly [P in keyof T]: T[P]<br>&#125;</p><p>type C = B&lt;A&gt;</code><br></code></pre></p><ol start="2" class="ne-ol"><li id="ub4542434" data-lake-index-type="0"><span class="ne-text">一个例子：对于DOM自带的DOMRect类型进行二次自定义</span></li></ol><pre><code><code>/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/DOMRectReadOnly) */interface DOMRectReadOnly &#123;  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/DOMRectReadOnly/bottom) */  readonly bottom: number;  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/DOMRectReadOnly/height) */  readonly height: number;  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/DOMRectReadOnly/left) */  readonly left: number;  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/DOMRectReadOnly/right) */  readonly right: number;  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/DOMRectReadOnly/top) */  readonly top: number;  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/DOMRectReadOnly/width) */  readonly width: number;  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/DOMRectReadOnly/x) */  readonly x: number;  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/DOMRectReadOnly/y) */  readonly y: number;  toJSON(): any;&#125;/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/DOMRect) */interface DOMRect extends DOMRectReadOnly &#123;  height: number;  width: number;  x: number;  y: number;&#125;</code></code></pre><pre><code><code>// - remove assign value (-readonlu or -?)...type EditableDOMRect = &#123;  -readonly [K in keyof DOMRect]: DOMRect[K];&#125;;// EditableDOMRect === ↓type EditableDOMRect = &#123;  height: number;  width: number;  x: number;  y: number;  bottom: number;  left: number;  right: number;  top: number;  toJSON: () =&gt; any;&#125;</code></code></pre><h4 id="EXNeJ"><span class="ne-text">条件类型 infer</span></h4><pre><code><code>type C = A extends B ? &#123;&#125; : []type Exclude&lt;T, U&gt; = T extends U ? never : T</code></code></pre><h4 id="OW0TC"><span class="ne-text">内置工具类型</span></h4><p id="uc0bd97b2" class="ne-p"><span class="ne-text">typescript内置部分类型（具体可以利用编辑器转到定义处查看）</span></p><p id="ue6815fcd" class="ne-p"><span class="ne-text">比如完成上述映射第一个例子可以写成</span></p><pre><code><code>type D = Readonly&lt;A&gt;</code></code></pre><p id="u1558878f" class="ne-p"><span class="ne-text">常用的如下：</span></p><table id="JMQIq" class="ne-table" style="width: 636px"><tbody><tr style="height: 33px"><td width="318"><p id="u0db44a55" class="ne-p"><span class="ne-text">Partial</span></p></td><td width="318"><ul class="ne-ul"><li id="u0de61c6b" data-lake-index-type="0"><span class="ne-text">可选</span></li></ul><pre><code><code>type B = Partial&lt;A&gt;</code></code></pre></td></tr><tr style="height: 33px"><td width="318"><p id="u9624db74" class="ne-p"><span class="ne-text">Readonly</span></p></td><td width="318"><ul class="ne-ul"><li id="u292ea66d" data-lake-index-type="0"><span class="ne-text">只读</span></li></ul><pre><code><code>type B = Readonly&lt;A&gt;</code></code></pre></td></tr><tr style="height: 33px"><td width="318"><p id="u31f84b39" class="ne-p"><span class="ne-text">Pick</span></p></td><td width="318"><ul class="ne-ul"><li id="uacea44be" data-lake-index-type="0"><span class="ne-text">筛选指定项</span></li></ul><pre><code><code>type B = Pick&lt;A, 'a' | 'b'&gt;</code></code></pre></td></tr><tr style="height: 33px"><td width="318"><p id="u3ee0494b" class="ne-p"><span class="ne-text">Record</span></p></td><td width="318"><ul class="ne-ul"><li id="u9efccf89" data-lake-index-type="0"><span class="ne-text">指定字段为指定类型</span></li></ul><pre><code><code>type A = Record&lt;'a' | 'b', string&gt;type A = Record&lt;keyof C, string&gt;</code></code></pre></td></tr><tr style="height: 33px"><td width="318"><p id="u67a37fee" class="ne-p"><span class="ne-text">Required</span></p></td><td width="318"><ul class="ne-ul"><li id="uaf8032bb" data-lake-index-type="0"><span class="ne-text">将可选字段转为必选字段</span></li></ul><pre><code><code>type B = Required&lt;A&gt;</code></code></pre></td></tr><tr style="height: 33px"><td width="318"><p id="u1a1da710" class="ne-p"><span class="ne-text">Omit</span></p></td><td width="318"><ul class="ne-ul"><li id="u78dd2ad3" data-lake-index-type="0"><span class="ne-text">移除指定项</span></li></ul><pre><code><code>type B = Omit&lt;A, 'a' | 'b'&gt;</code></code></pre></td></tr><tr style="height: 33px"><td width="318"><p id="ue047fc96" class="ne-p"><span class="ne-text">Exclude</span></p></td><td width="318"><ul class="ne-ul"><li id="u814a1afa" data-lake-index-type="0"><span class="ne-text">排除</span></li></ul><pre><code><code>type B = Exclude&lt;string | number, string&gt;</code></code></pre></td></tr><tr style="height: 33px"><td width="318"><p id="u555524d6" class="ne-p"><span class="ne-text">Extract</span></p></td><td width="318"><ul class="ne-ul"><li id="u3566469d" data-lake-index-type="0"><span class="ne-text">择取</span></li></ul><pre><code><code>type B = Extract&lt;string | number, string&gt;</code></code></pre></td></tr><tr style="height: 33px"><td width="318"><p id="u7ee55ba0" class="ne-p"><span class="ne-text">NonNullable</span></p></td><td width="318"><ul class="ne-ul"><li id="u8247e26e" data-lake-index-type="0"><span class="ne-text">去除“空”类型</span></li></ul><pre><code><code>type B = NonNullable&lt;string | null | undefined&gt;// B -&gt; string</code></code></pre></td></tr><tr style="height: 33px"><td width="318"><p id="u7f47e0cf" class="ne-p"><span class="ne-text">Parameters</span></p></td><td width="318"><ul class="ne-ul"><li id="ud5251af7" data-lake-index-type="0"><span class="ne-text">得到函数参数元组</span></li></ul><pre><code><code>type FUN = (n: string, m: number) =&gt; voidtype A = Parameters&lt;FUN&gt;<p>const test: A = [‘111’, 222];</code><br></code></pre></p></td></tr><tr style="height: 33px"><td width="318"><p id="u71bcf350" class="ne-p"><span class="ne-text">ReturnType</span></p></td><td width="318"><ul class="ne-ul"><li id="u7f9d26b9" data-lake-index-type="0"><span class="ne-text">得到函数返回值类型</span></li></ul><pre><code><code>type FUN = (n: string, m: number) =&gt; voidtype A = ReturnType&lt;FUN&gt;<p>const test: A = // void</code><br></code></pre></p></td></tr></tbody></table><ol class="ne-ol"><li id="udf359230" data-lake-index-type="0"><span class="ne-text">infer关键字 extends关键字</span></li></ol><p id="uf8802929" class="ne-p"><span class="ne-text">推断类型</span></p><pre><code><code>type A&lt;T&gt; = T extends Array&lt;infer U&gt; ? U : T<p>type B = A&lt;Array&lt;string&gt;&gt; // string<br>type C = A&lt;number&gt; // number</code><br></code></pre></p></div>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;!doctype html&gt;&lt;div class=&quot;lake-content&quot; typography=&quot;classic&quot;&gt;&lt;h4 id=&quot;DMAyy&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;基础使用&lt;/span&gt;&lt;/h4&gt;&lt;ol class=&quot;ne-ol&quot;&gt;&lt;li</summary>
        
      
    
    
    
    <category term="Web开发" scheme="https://www.wztlink1013.com/categories/Web%E5%BC%80%E5%8F%91/"/>
    
    <category term="JavaScript" scheme="https://www.wztlink1013.com/categories/Web%E5%BC%80%E5%8F%91/JavaScript/"/>
    
    <category term="TypeScript" scheme="https://www.wztlink1013.com/categories/Web%E5%BC%80%E5%8F%91/JavaScript/TypeScript/"/>
    
    
  </entry>
  
  <entry>
    <title>CSS选择器中的:has()和:not()伪类</title>
    <link href="https://www.wztlink1013.com/blog/etxgze472uzh7t1i/"/>
    <id>https://www.wztlink1013.com/blog/etxgze472uzh7t1i/</id>
    <published>2023-09-03T00:33:09.000Z</published>
    <updated>2023-12-10T18:04:48.000Z</updated>
    
    <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="ub2dd044b" class="ne-p"><span class="ne-text">前言: 本文记录一下CSS3中逻辑选择器中的has和not, has相当于根据子代条件来选择父代, not类似过滤条件. </span><strong><span class="ne-text">使用前先检查代码运行的浏览器环境是否符合如下截图条件</span></strong></p><p id="u4debc8a1" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2023/png/1484158/1693729315664-7752ef04-8503-42b0-b271-a4adffed81ec.png" width="540.328125" id="u310bdcce" class="ne-image"></p><h3 id="C7n01"><span class="ne-text">not</span></h3><p id="u9b72f6e5" class="ne-p"><span class="ne-text">对当前节点的过滤筛选</span></p><pre><code><code>&lt;html&gt;  &lt;head&gt;    &lt;title&gt;css&lt;/title&gt;    &lt;style&gt;      div.parent:not(.not-parent) &#123;        border: 1px red solid;      &#125;    &lt;/style&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;div class=&quot;parent not-parent&quot;&gt;0000&lt;/div&gt;    &lt;div class=&quot;parent&quot;&gt;      &lt;div&gt;1111&lt;/div&gt;      &lt;div&gt;        &lt;div class=&quot;active&quot;&gt;2222&lt;/div&gt;      &lt;/div&gt;    &lt;/div&gt;    &lt;div class=&quot;parent&quot;&gt;      &lt;div&gt;3333&lt;/div&gt;      &lt;div&gt;4444&lt;/div&gt;    &lt;/div&gt;    &lt;p&gt;&lt;/p&gt;  &lt;/body&gt;&lt;/html&gt;</code></code></pre><p id="ubf0f5013" class="ne-p" style="text-align: left"><img src="https://cdn.nlark.com/yuque/0/2023/png/1484158/1693728187545-dc666922-bd28-4c9d-b63e-824c8b0476f0.png" width="257.03705519478797" id="u46b8367d" class="ne-image"></p><h3 id="bNc8z"><span class="ne-text">has</span></h3><p id="u11a3e0cd" class="ne-p"><span class="ne-text">has选择器: </span><strong><span class="ne-text">根据子是否符合条件来选择父级</span></strong></p><p id="uaf7bd836" class="ne-p"><span class="ne-text">设置子代中有active类的parent类名div的样式</span></p><pre><code><code>&lt;html&gt;  &lt;head&gt;    &lt;title&gt;css&lt;/title&gt;    &lt;style&gt;      div.parent:has(.active) &#123;        border: 1px red solid;      &#125;    &lt;/style&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;div class=&quot;parent&quot;&gt;      &lt;div&gt;1111&lt;/div&gt;      &lt;div&gt;        &lt;div class=&quot;active&quot;&gt;2222&lt;/div&gt;      &lt;/div&gt;    &lt;/div&gt;    &lt;div class=&quot;parent&quot;&gt;      &lt;div&gt;3333&lt;/div&gt;      &lt;div&gt;4444&lt;/div&gt;    &lt;/div&gt;    &lt;p&gt;&lt;/p&gt;  &lt;/body&gt;&lt;/html&gt;</code></code></pre><p id="u1eafcd36" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2023/png/1484158/1693726768953-ae1aa08f-87bd-45d1-ad03-bf4a73538bdc.png" width="257.03705519478797" id="u1ceb6584" class="ne-image"></p><p id="ued6d7945" class="ne-p"><span class="ne-text">如果将上面css改为, 边框则消失</span></p><pre><code><code>div.parent:has(&gt; .active) &#123;  border: 1px red solid;&#125;</code></code></pre><p id="u08a49d4c" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2023/png/1484158/1693727448672-f90d3002-6437-4d65-9b1b-ea889429bd06.png" width="257.03705519478797" id="udd9054cc" class="ne-image"></p><p id="u56d25e80" class="ne-p"><span class="ne-text">还可以表示兄弟跟随关系</span></p><pre><code><code>div.parent:has(+ p) &#123;  border: 1px red solid;&#125;</code></code></pre><p id="u3dc38aeb" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2023/png/1484158/1693727414288-eb1381c5-ce55-44b2-bea6-0e7dad844aba.png" width="257.03705519478797" id="u977486b6" class="ne-image"></p><p id="u3b65a87a" class="ne-p"><span class="ne-text">和not搭配使用, 如下表示不包含active后代的div.parent的标签</span></p><pre><code><code>div.parent:not(:has(.active)) &#123;  border: 1px red solid;&#125;</code></code></pre><p id="u12be46f2" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2023/png/1484158/1693727684199-12da436d-df79-4580-ad37-527bb3a9dc48.png" width="257.03705519478797" id="u860533e4" class="ne-image"></p><p id="u0872252b" class="ne-p"><span class="ne-text">上述not和has位置互换表示的意思不一样</span></p><pre><code><code>div.parent:has(:not(.active)) &#123;  border: 1px red solid;&#125;</code></code></pre><p id="u65f722ad" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2023/png/1484158/1693727825016-f0ae7f89-7fb6-4e74-9d40-32e2727079d5.png" width="257.03705519478797" id="u3f9eacb2" class="ne-image"></p><p id="u0f0fe764" class="ne-p"><span class="ne-text">和表单一些元素搭配使用</span></p><pre><code><code>&lt;html&gt;  &lt;head&gt;    &lt;title&gt;css&lt;/title&gt;    &lt;style&gt;      div:has(input:focus) &#123;        border: 1px red solid;      &#125;    &lt;/style&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;div&gt;      &lt;input type=&quot;text&quot; value=&quot;111&quot; /&gt;    &lt;/div&gt;    &lt;div&gt;      &lt;input type=&quot;text&quot; value=&quot;222&quot; /&gt;    &lt;/div&gt;  &lt;/body&gt;&lt;/html&gt;</code></code></pre><p id="uda31529e" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2023/png/1484158/1693728587821-b90111c9-a13f-4ecc-907e-d1c5d26f3a3d.png" width="257.03705519478797" id="u17090981" class="ne-image"></p><hr id="nIJig" class="ne-hr"><p id="u5dcb7170" class="ne-p" style="text-align: center"><span class="ne-text">一些常规使用CSS选择器可以参考另一篇文章:  </span><a href="https://www.wztlink1013.com/blog/01_html5css3_day01/" data-href="https://www.wztlink1013.com/blog/01_html5css3_day01/" class="ne-link"><span class="ne-text">CSS/CSS3选择器总结 | 尼采般地抒情</span></a></p></div>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;!doctype html&gt;&lt;div class=&quot;lake-content&quot; typography=&quot;classic&quot;&gt;&lt;p id=&quot;ub2dd044b&quot; class=&quot;ne-p&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;前言:</summary>
        
      
    
    
    
    <category term="Web开发" scheme="https://www.wztlink1013.com/categories/Web%E5%BC%80%E5%8F%91/"/>
    
    <category term="HTML+CSS" scheme="https://www.wztlink1013.com/categories/Web%E5%BC%80%E5%8F%91/HTML-CSS/"/>
    
    
  </entry>
  
  <entry>
    <title>YApi内网部署</title>
    <link href="https://www.wztlink1013.com/blog/eil6hmfg5ip4tdh7/"/>
    <id>https://www.wztlink1013.com/blog/eil6hmfg5ip4tdh7/</id>
    <published>2023-05-06T07:19:03.000Z</published>
    <updated>2024-01-10T02:53:54.000Z</updated>
    
    <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="u0f0c809d" class="ne-p" style="text-align: justify"><span class="ne-text">前言：使用yapi系统来管理个人项目接口，目标是在个人电脑上而非服务器上搭建一个yapi系统，开机自启动或者手动启动。一开始是使用官网推荐的yapi-cli来搭建，但是坑比较多，node限制在12x，这个显然影响本机环境。然后采用直接运行YApi的源码，利用pm2来运行node服务，最后可以达到预期效果，但是pm2设置了开机自启动影响电脑性能。最后采用docker容器部署，需要的时候手动启动即可，而且部署起来感觉更加简洁，故本文将docker作为推荐部署方式。</span></p><h2 id="dNVSw"><span class="ne-text">一、pm2部署</span></h2><p id="uc4b387b0" class="ne-p"><span class="ne-text">使用pm2来运行YApi node程序。</span></p><h3 id="G0lZ0"><span class="ne-text">下载Yapi源码以及配置Yapi</span></h3><ul class="ne-ul"><li id="u990e7ac7" data-lake-index-type="0"><span class="ne-text">先将node版本切换到</span><code class="ne-code"><span class="ne-text">12.18.2</span></code><span class="ne-text">，因为过高版本的node不能使用（个人试过高于14.17.就不能使用）。</span></li></ul><p id="u3b02a4a6" class="ne-p" style="text-align: center"><strong><span class="ne-text">关于如何切换node版本，参考之前文章nvm的使用</span></strong></p><p id="ucd24bba0" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1646102278163-10a8b55f-5fe8-46c3-8e0d-39bdd8f69d00.png" width="649.166640871102" id="u320f9d7e" class="ne-image"></p><ul class="ne-ul"><li id="ufc97e1d2" data-lake-index-type="0"><span class="ne-text">然后下载cnpm </span><code class="ne-code"><span class="ne-text">npm install -g cnpm --registry=</span><a href="https://registry.npm.taobao.org" data-href="https://registry.npm.taobao.org" target="_blank" class="ne-link"><span class="ne-text">https://registry.npm.taobao.org</span></a></code></li><li id="ucd48f741" data-lake-index-type="0"><span class="ne-text">然后下载yapi：</span></li></ul><pre><code>cnpm install -g yapi-cli</code></pre><ul class="ne-ul"><li id="u9de97657" data-lake-index-type="0"><span class="ne-text">在文件夹中执行如下命令：</span></li></ul><pre><code>yapi server</code></pre><ul class="ne-ul"><li id="ue4cb8925" data-lake-index-type="0"><span class="ne-text" style="color: rgb(33, 37, 41); font-size: 16px">访问localhost:9090，将页面配置填上即可：</span></li></ul><p id="ub4ad9a50" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1646033850542-bdbeef58-d2ac-44d5-ad34-28c5752cd54f.png" width="1572.4999375144666" id="cBXHi" class="ne-image"></p><p id="u47e2bff1" class="ne-p"><span class="ne-text">安装成功会有如下信息：</span></p><pre><code>初始化管理员账号成功,账号名：&quot;admin@admin.com&quot;，密码：&quot;ymfe.org&quot;部署成功，请切换到部署目录，输入： &quot;node vendors/server/app.js&quot; 指令启动服务器, 然后在浏览器打开 http://127.0.0.1:3000 访问</code></pre><ul class="ne-ul"><li id="u9f3d461e" data-lake-index-type="0"><span class="ne-text">然后访问：</span><a href="http://127.0.0.1:3000" data-href="http://127.0.0.1:3000" target="_blank" class="ne-link"><span class="ne-text">http://127.0.0.1:3000</span></a></li></ul><h3 id="H6qIN"><span class="ne-text">创建本地MongoDB数据库</span></h3><pre><code>db.createUser(&#123;user: 'root',pwd: 'root',roles:[&#123;role: 'root',db: 'admin'&#125;]&#125;)</code></pre><pre><code>&gt; use adminswitched to db admin&gt; db.createUser(&#123;user: 'root',pwd: 'root',roles:[&#123;role: 'root',db: 'admin'&#125;]&#125;)Successfully added user: &#123;        &quot;user&quot; : &quot;root&quot;,        &quot;roles&quot; : [                &#123;                        &quot;role&quot; : &quot;root&quot;,                        &quot;db&quot; : &quot;admin&quot;                &#125;        ]&#125;&gt; show users&#123;        &quot;_id&quot; : &quot;admin.root&quot;,        &quot;userId&quot; : UUID(&quot;f47c99bb-2df6-410c-bde1-2f424d0258d3&quot;),        &quot;user&quot; : &quot;root&quot;,        &quot;db&quot; : &quot;admin&quot;,        &quot;roles&quot; : [                &#123;                        &quot;role&quot; : &quot;root&quot;,                        &quot;db&quot; : &quot;admin&quot;                &#125;        ],        &quot;mechanisms&quot; : [                &quot;SCRAM-SHA-1&quot;,                &quot;SCRAM-SHA-256&quot;        ]&#125;</code></pre><p id="ucb07af7e" class="ne-p"><span class="ne-text">找到 MongoDB 安装目录，打开 mongod.cfg文件修改</span></p><p id="u4c975e0d" class="ne-p"><span class="ne-text">重启mongodb</span></p><pre><code>C:\Users\wztli&gt;mongoMongoDB shell version v5.0.5connecting to: mongodb://127.0.0.1:27017/?compressors=disabled&amp;gssapiServiceName=mongodbImplicit session: session &#123; &quot;id&quot; : UUID(&quot;6ff518c1-21c7-4d6f-98ce-23b12c925321&quot;) &#125;MongoDB server version: 5.0.5================Warning: the &quot;mongo&quot; shell has been superseded by &quot;mongosh&quot;,which delivers improved usability and compatibility.The &quot;mongo&quot; shell has been deprecated and will be removed inan upcoming release.For installation instructions, seehttps://docs.mongodb.com/mongodb-shell/install/================&gt; use adminswitched to db admin&gt; db.auth('root','root')1</code></pre><p id="u01a88216" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1646098577475-dfd39936-36f1-4cf4-b61d-682957334517.png" width="254.83071899414062" id="ue6b55d01" class="ne-image"></p><h3 id="wxjuG"><span class="ne-text">YApi node程序运行成功</span></h3><p id="u1904299f" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1646099210899-717632b0-b65f-4e28-9199-9061a306254c.png" width="839.1666333211806" id="XphSR" class="ne-image"></p><h3 id="isIb9"><span class="ne-text">pm2后台管理Yapi进程</span></h3><p id="u2ef2c275" class="ne-p"><span class="ne-text">pm2就相当于之前服务器使用的screen，新开一个进程，就算关掉cmd也能进行操作</span></p><p id="uf2083388" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1646102724248-270ad78b-b70d-4682-8732-c902c277bda2.png" width="784.9999688069038" id="u0bebbfc6" class="ne-image"></p><p id="u6fc0c6a7" class="ne-p"><span class="ne-text">这样就是在本地电脑上，可以把项目关掉，但是该项目还处于运行当中，当然了，重启电脑还是要重新执行上面的pm2命令的，也可以进行pm2开机自启动一些项目，具体参考上面的教程链接。</span></p><h3 id="ZAjnn"><span class="ne-text">pm2设置开机自启动服务</span></h3><p id="u9840df8c" class="ne-p"><span class="ne-text">目的是电脑一开机就会自动重启该服务：</span></p><pre><code>cnpm i -g pm2-windows-service</code></pre><p id="ua5f80609" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1646118390666-51bc2220-c6ce-473e-a6c8-e1c88a338ac8.png" width="714.9999715884538" id="ua5b9348d" class="ne-image"></p><h3 id="jycMa"><span class="ne-text">相关报错</span></h3><h4 id="Zz2GM"><span class="ne-text">Error:  (node:2304) Warning: Accessing non-existent property……</span></h4><pre><code>Error:  (node:2304) Warning: Accessing non-existent property 'count' of module exports inside circular dependency(Use `node --trace-warnings ...` to show where the warning was created)</code></pre><ul class="ne-ul"><li id="u927ff03a" data-lake-index-type="0"><span class="ne-text">原因node版本过高：</span><a href="https://github.com/YMFE/yapi/issues/1736" data-href="https://github.com/YMFE/yapi/issues/1736" target="_blank" class="ne-link"><span class="ne-text">https://github.com/YMFE/yapi/issues/1736</span></a></li></ul><h4 id="Af03x"><span class="ne-text">events.js:292 throw er; // Unhandled 'error' event</span></h4><p id="ua131e8fa" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1646034833437-db75cee7-0157-41eb-ac4c-cfd27f3db1e1.png" width="272.33331298828125" id="AJW0o" class="ne-image"></p><p id="u4961a57d" class="ne-p"><span class="ne-text">下载gyp试试，需要电脑上的环境参考：</span><a href="https://github.com/nodejs/node-gyp#on-windows" data-href="https://github.com/nodejs/node-gyp#on-windows" target="_blank" class="ne-link"><span class="ne-text">https://github.com/nodejs/node-gyp#on-windows</span></a></p><pre><code>cnpm install -g node-gyp</code></pre><h4 id="oNDgw"><span class="ne-text">Error: Can‘t find Python executable “python“, you can set the PYTHON env variable</span></h4><p id="u595d1a18" class="ne-p"><span class="ne-text">成功安装之后，cnpm i 会有一个报错：</span></p><p id="u365ce299" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1646035557382-7fcc59de-05ca-45f5-90ef-a2e24f70f6d1.png" width="209.5" id="aHtry" class="ne-image"></p><p id="ua245b67d" class="ne-p"><span class="ne-text"></span></p><p id="uf44429f7" class="ne-p"><span class="ne-text">解决参考：</span></p><ul class="ne-ul"><li id="u8dee6132" data-lake-index-type="0"><span class="ne-text"></span><a href="https://blog.51cto.com/u_15301254/3924342" data-href="https://blog.51cto.com/u_15301254/3924342" target="_blank" class="ne-link"><span class="ne-text">【Bug解决】Error: Can‘t find Python executable “python“, you can set the PYTHON env variable</span></a></li></ul><p id="u7fff91cd" class="ne-p"><span class="ne-text">下载：</span></p><pre><code>npm install --global --production windows-build-tools</code></pre><h4 id="zhObf"><span class="ne-text">MongoNetworkError: Authentication failed., mongodb Authentication failed</span></h4><ul class="ne-ul"><li id="uc8539557" data-lake-index-type="0"><a href="https://github.com/fjc0k/docker-YApi/issues/32" data-href="https://github.com/fjc0k/docker-YApi/issues/32" target="_blank" class="ne-link"><span class="ne-text">https://github.com/fjc0k/docker-YApi/issues/32</span></a></li></ul><p id="ucfef198f" class="ne-p"><span class="ne-text">添加admin值即可</span></p><h2 id="YlpJX"><span class="ne-text">二、docker部署</span></h2><p id="u87363657" class="ne-p"><span class="ne-text">docker部署主要参考：</span><a href="https://github.com/fjc0k/docker-YApi#readme" data-href="https://github.com/fjc0k/docker-YApi#readme" target="_blank" class="ne-link"><span class="ne-text">https://github.com/fjc0k/docker-YApi#readme</span></a><span class="ne-text">，不过有几个需要注意的点：</span></p><ul class="ne-ul"><li id="ua7fd6bda" data-lake-index-type="0"><span class="ne-text">redeme提到的Docker 和 Docker Compose版本不能太久</span></li><li id="ucf81c10c" data-lake-index-type="0"><span class="ne-text">MongoDB如果是</span><a href="https://www.mongodb.com/" data-href="https://www.mongodb.com/" target="_blank" class="ne-link"><span class="ne-text">在线数据库</span></a><span class="ne-text">，配置方式采用集群配置字段更加便捷：</span></li></ul><pre><code>version: '3'<p>services:<br>  yapi-web:<br>    image: jayfong/yapi:latest<br>    container_name: yapi-web<br>    ports:<br>      - 40001:3000<br>    environment:<br>      - YAPI_ADMIN_ACCOUNT=xxxxxx<br>      - YAPI_ADMIN_PASSWORD=xxxxxx<br>      - YAPI_CLOSE_REGISTER=true<br>      - YAPI_DB_CONNECT_STRING=mongodb+srv://name:password@url/databasename?retryWrites=true&amp;w=majority<br>      - YAPI_MAIL_ENABLE=false<br>      - YAPI_LDAP_LOGIN_ENABLE=false<br>      - YAPI_PLUGINS=[]<br>    depends_on:<br>        ···<br></code></pre></p><h2 id="LBMyr"><span class="ne-text">三、相关链接</span></h2><p id="u7de33e87" class="ne-p"><span class="ne-text">YApi参考：</span></p><ul class="ne-ul"><li id="u0ce203b2" data-lake-index-type="0"><span class="ne-text">yapi文档以及安装文档：</span><a href="https://hellosean1025.github.io/yapi/" data-href="https://hellosean1025.github.io/yapi/" target="_blank" class="ne-link"><span class="ne-text">https://hellosean1025.github.io/yapi/</span></a></li><li id="u088fb7d1" data-lake-index-type="0"><span class="ne-text">YApi 安装可能会出现的问题：</span><a href="https://github.com/YMFE/yapi/issues/16" data-href="https://github.com/YMFE/yapi/issues/16" target="_blank" class="ne-link"><span class="ne-text">https://github.com/YMFE/yapi/issues/16</span></a></li><li id="u84bae2c3" data-lake-index-type="0"><span class="ne-text">docker参考：</span><a href="https://github.com/fjc0k/docker-YApi" data-href="https://github.com/fjc0k/docker-YApi" target="_blank" class="ne-link"><span class="ne-text">https://github.com/fjc0k/docker-YApi</span></a></li><li id="u89ae9669" data-lake-index-type="0"><a href="https://segmentfault.com/a/1190000020534539" data-href="https://segmentfault.com/a/1190000020534539" target="_blank" class="ne-link"><span class="ne-text">Yapi 本地部署</span></a></li></ul><p id="ua003c847" class="ne-p"><span class="ne-text">本地MongoDB创建参考：</span></p><ul class="ne-ul"><li id="u00ab0a5f" data-lake-index-type="0"><a href="https://blog.csdn.net/qq_42583263/article/details/121403125" data-href="https://blog.csdn.net/qq_42583263/article/details/121403125" class="ne-link"><span class="ne-text">MongoDB 设置用户名密码和数据库连接_mongodb 连接数据库带用户名和密码_大胖东的博客-CSDN博客</span></a></li></ul><p id="u630c7d71" class="ne-p"><span class="ne-text">pm2相关参考：</span></p><ul class="ne-ul"><li id="u01e9bc43" data-lake-index-type="0"><a href="https://www.cnblogs.com/chyingp/p/pm2-documentation.html" data-href="https://www.cnblogs.com/chyingp/p/pm2-documentation.html" target="_blank" class="ne-link"><span class="ne-text">PM2实用入门指南 </span></a></li><li id="u2b10dbc2" data-lake-index-type="0"><a href="https://www.jianshu.com/p/5f808762a71a" data-href="https://www.jianshu.com/p/5f808762a71a" class="ne-link"><span class="ne-text">pm2 使用教程</span></a></li></ul><ul class="ne-ul"><li id="ubf1b94b0" data-lake-index-type="0"><a href="https://www.jianshu.com/p/6cb523c0ced8" data-href="https://www.jianshu.com/p/6cb523c0ced8" target="_blank" class="ne-link"><span class="ne-text">Window 设置pm2开机自启动服务</span></a></li><li id="u1e2423fd" data-lake-index-type="0"><a href="https://www.cnblogs.com/wuqilang/p/12794972.html" data-href="https://www.cnblogs.com/wuqilang/p/12794972.html" target="_blank" class="ne-link"><span class="ne-text">Window 设置pm2开机自启动服务</span></a></li></ul></div>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;!doctype html&gt;&lt;div class=&quot;lake-content&quot; typography=&quot;classic&quot;&gt;&lt;p id=&quot;u0f0c809d&quot; class=&quot;ne-p&quot; style=&quot;text-align: justify&quot;&gt;&lt;span</summary>
        
      
    
    
    
    <category term="Web开发" scheme="https://www.wztlink1013.com/categories/Web%E5%BC%80%E5%8F%91/"/>
    
    <category term="DevOps" scheme="https://www.wztlink1013.com/categories/Web%E5%BC%80%E5%8F%91/DevOps/"/>
    
    
  </entry>
  
  <entry>
    <title>『我的团长我的团』</title>
    <link href="https://www.wztlink1013.com/essay/wugt39mh6cgg3676/"/>
    <id>https://www.wztlink1013.com/essay/wugt39mh6cgg3676/</id>
    <published>2023-04-05T05:38:36.000Z</published>
    <updated>2023-04-05T06:02:05.000Z</updated>
    
    <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="uc38dc866" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2023/webp/1484158/1680703167469-355c8435-dec9-4430-819c-476f8994958d.webp" width="270" id="u416ba344" class="ne-image"></p><p id="u33f28100" class="ne-p"><span class="ne-text">前言：士兵突击的原班人马拍摄的一部电视剧，兰晓龙笔下的炮灰团和草原上的五班，将底层描绘的淋漓尽致，又将绝望中的希望演绎在文字或者影视中。</span></p><h3 id="fpTSn"><span class="ne-text">摘录</span></h3><p id="u7bafe72e" class="ne-p"><span class="ne-text">岂曰无衣，与子同袍。</span></p><p id="u2cb70538" class="ne-p"><span class="ne-text"></span></p><p id="u4c7c6da5" class="ne-p"><span class="ne-text">中国鬼死于听天由命和漫不经心。</span></p><p id="u175607de" class="ne-p"><span class="ne-text"></span></p><p id="u1f90b392" class="ne-p"><span class="ne-text">死都不怕，就怕安逸。</span></p><p id="u24fe66b2" class="ne-p"><span class="ne-text"></span></p><p id="u3425eb31" class="ne-p"><span class="ne-text">国难当头，忠字已经很掺水了，在孝字上就不能再打马虎眼了。</span></p><p id="u5dd9b714" class="ne-p"><span class="ne-text"></span></p><p id="u99525e99" class="ne-p"><span class="ne-text">人生在世，怎么可能像裁缝铺里做衣服，处处都按照你的身材。</span></p><p id="ubdbfaa19" class="ne-p"><span class="ne-text"></span></p><p id="u348f2c18" class="ne-p"><span class="ne-text">有个信着的东西，你是不知道活得有多舒服。</span></p><p id="ube9126c9" class="ne-p"><span class="ne-text"></span></p><p id="u65cb6657" class="ne-p"><span class="ne-text">覆巢之下，岂有完卵。</span></p><p id="u963aca0c" class="ne-p"><span class="ne-text"></span></p><p id="uceb12a81" class="ne-p"><span class="ne-text">你骗我们有了不该有的希望。</span></p><p id="ub3a2a576" class="ne-p"><span class="ne-text"></span></p><p id="ud1bd03f9" class="ne-p"><span class="ne-text">我是伤心而死的。</span></p><p id="uee3f72ec" class="ne-p"><span class="ne-text"></span></p><p id="u5d0787a7" class="ne-p"><span class="ne-text"></span></p></div>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;!doctype html&gt;&lt;div class=&quot;lake-content&quot; typography=&quot;classic&quot;&gt;&lt;p id=&quot;uc38dc866&quot; class=&quot;ne-p&quot; style=&quot;text-align: center&quot;&gt;&lt;img</summary>
        
      
    
    
    
    <category term="影视" scheme="https://www.wztlink1013.com/categories/%E5%BD%B1%E8%A7%86/"/>
    
    
  </entry>
  
  <entry>
    <title>2022年 | 平淡却又魔幻</title>
    <link href="https://www.wztlink1013.com/essay/lwozgzgirrhne6ro/"/>
    <id>https://www.wztlink1013.com/essay/lwozgzgirrhne6ro/</id>
    <published>2022-12-30T16:48:16.000Z</published>
    <updated>2023-12-27T07:35:45.000Z</updated>
    
    <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="u7c001e7f" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/1484158/1672578936177-3e40667b-6cc1-4140-865e-cf55bdcb2658.jpeg" width="3840" id="GE6Xs" class="ne-image"></p><p id="uf699b7c3" class="ne-p"><br></p><p id="ud04fa625" class="ne-p"><span class="ne-text">前言：2022年，平淡的生活中夹杂着一丝魔幻的经历。</span></p><h3 id="sq448"><span class="ne-text">最后的学生时代</span></h3><p id="u9f5f0f39" class="ne-p"><span class="ne-text">仿佛读了好久好久的书，久到我记忆中难忘的事都是夹杂在学业之中。</span></p><p id="ucc30dd02" class="ne-p"><span class="ne-text">去年的这个时候我结束了在外公司的实习之旅，转向学校，一切都像是被安排好的流程，校内实习、毕设、答辩、拍毕业照、毕业…相比起我的中学阶段，我的大学要平淡的多，可能是这易于伤感的年纪不再憧憬与彷徨。</span></p><h3 id="P02dA"><span class="ne-text">可那是兴趣爱好</span></h3><p id="u6f2cb3bc" class="ne-p"><span class="ne-text">我应该是一手好牌却打得不怎么样的一个学生。大三下我几乎就把学分修满，理论上我是有最多的时间去准备就业的那一批人，但是我错过秋招和春招，封校没有紧迫感是一方面，但是更多的是我的毕设，那是我的兴趣，我只想写好我所设计的代码，那种热爱的冲动不再让我去超过所有人竞争些什么，即便那是个好机会。</span></p><p id="ud41458a1" class="ne-p"><span class="ne-text">五月往后，连春招都过了，我才开始找工作，不过凭借技术老本也拿到一些offer，选择当中有更好的，但最后我还是选了一个和我毕设几乎一样的岗位。我想以后我可能会变得功利起来，但现在不是未来。比较讽刺的是，这一年人情景事都在变，唯独兴趣爱好一直在，从爱好到毕设再到工作，载体不同，但做的都一样。</span></p><h3 id="ZHY8Q"><span class="ne-text">厦门</span></h3><p id="ucead1e49" class="ne-p"><span class="ne-text">原本意向工作地点是深圳，因为一些原因，来到厦门工作了。在一个陌生的海滨城市也是一个不错的经历体验，上一次的海滨之行是在珠海。</span></p><h3 id="Yd3cg"><span class="ne-text">疫情下的颠沛流离</span></h3><p id="ua27c9de0" class="ne-p"><span class="ne-text">上半年学校解封之际伴随着成片的花海，我原以为那会是疫情这个故事的终章，年底，国家重新定义了新冠的所属类别为“乙类甲管”，政策变之后，朋友圈每天都会更新一批又一批的阳康转阴等字眼。</span></p><h3 id="qrizm"><span class="ne-text">规则的成长</span></h3><p id="u7c422ca4" class="ne-p"><span class="ne-text">工作之后，看小说和追番没有在学校时候的那种氛围了，我觉得这可能就是成长带来的副作用吧，人们都以铺天盖地般地形式想要达成某种结果来取得某种成绩。技术上，不论是深度还是广度，都只是浅尝辄止，自己要做的、要总结的、要实践的还有很多很多，自己也要被迫地以最佳的状态在技术层面上提升一个层次。</span></p><p id="u470c3a4c" class="ne-p"><span class="ne-text">一千个人眼中有一千个哈姆雷特，而在我眼里，成长是虚无的，因为每个人总是以一种无形的规则成长，就像是竹林中的嫩竹子从一出生的小笋就笔直地向阳生长，不偏离之后的任何轨迹。</span></p><h3 id="az3a1"><span class="ne-text">2023</span></h3><p id="u40186f6b" class="ne-p"><span class="ne-text">对自己的2023年没有太多任务式的念想，唯独多读点书这一点多督促自己，在此对自己算是立下个flag吧，多读书多思考多记录。</span></p></div>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;!doctype html&gt;&lt;div class=&quot;lake-content&quot; typography=&quot;classic&quot;&gt;&lt;p id=&quot;u7c001e7f&quot; class=&quot;ne-p&quot;&gt;&lt;img</summary>
        
      
    
    
    
    <category term="随笔" scheme="https://www.wztlink1013.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
  <entry>
    <title>《你的夏天还好吗》小记</title>
    <link href="https://www.wztlink1013.com/essay/wmsytg138tcz629a/"/>
    <id>https://www.wztlink1013.com/essay/wmsytg138tcz629a/</id>
    <published>2022-12-07T23:02:13.000Z</published>
    <updated>2023-01-01T02:29:19.000Z</updated>
    
    <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="ua9751299" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/1484158/1670483122786-7c51c1ab-5445-4adc-905b-4c5d407d25e0.jpeg" width="330" id="Igzgd" class="ne-image"></p><h2 id="O4mrv"><span class="ne-text">你的夏天还好吗？</span></h2><p id="u980df92f" class="ne-p"><span class="ne-text">青涩的喜欢和热烈的喜欢，或许在真心付出面前才能得出答案，你义无反顾去喜欢去爱去付出的人，可能在你意识到对方利用你的感情，那一瞬间让你突然想到多年前一个夏天护着你的那个人，普通且纯粹…以前有个问题：“一个你很喜欢的人和一个很喜欢你的人，你会选谁？”，成长可能就是一个人多多少少的经历而孕育出人潜意识选择的微妙变化。</span></p><h2 id="UGRKc"><span class="ne-text">虫子</span></h2><p id="uf08ebd89" class="ne-p"><span class="ne-text">一个男人对于一个女人有多爱，应该在女人怀有身孕的那个阶段，男人给予女人多少的照顾来衡量。</span></p><p id="u831af1b5" class="ne-p"><span class="ne-text">什么是照顾，可能就是半夜赶走妻子身边的蚊虫就是一种照顾…</span></p><h2 id="DgykL"><span class="ne-text">水中的歌利亚</span></h2><p id="ub455e1e9" class="ne-p"><span class="ne-text">不久前父亲的离去，再在一场大雨不断的天气下，母亲也糖尿休克了，一时间对于亲人的这般离去，作者只知道在洪水中把母亲的尸体绑在木板上作为小船拖去抢救，即便最后尸体也不知道飘向何处…作者最后在塔吊避雨，想起了父亲在工作时的焊接火花射到脸上，想起了父亲教作者游泳潜水，想起了将母亲缠绕在木板上的绿色胶带…</span></p><h2 id="CcIvf"><span class="ne-text">那里是夜，这里有歌</span></h2><p id="ud6ffdc42" class="ne-p"><span class="ne-text">龙大就像是『夏洛特烦恼』中的大傻春。</span></p><p id="u5a0352cf" class="ne-p"><span class="ne-text">“认识你很高兴”，我想这是明华对龙大寄托的另一种情感。</span></p><p id="ub0a131cf" class="ne-p"><span class="ne-text">这世界上总有一些简单纯粹的人活得那么用力。</span></p><h2 id="Uo58d"><span class="ne-text">一天的轴</span></h2><p id="u6ad2873d" class="ne-p"><span class="ne-text">机场是个很容易让人感伤的地方，无数来来往往的陌生面孔总会让你心里觉得平淡而又恍惚。琪玉女士只是个机场保洁工作的一名普通人，失去爱人，孩子也在退伍之际做出一些错事而入狱，想着儿子总想去国外进修…一天的轴或许就是念想里为了某个人总想去坚持做点什么的事。</span></p><p id="u3220ec89" class="ne-p"><span class="ne-text">机场和车站不一样，机场更多是让人感到感伤，而绿皮车和高铁给人以寄托。我还怀念每次回学校，下午四五点飞下机，夕阳洒满遥墙机场的每个角落，机场的边界是一些树，小森林一般，看着那些树，每次总让想起家乡的景色，安安静静的一个小城，安安静静的行人。求学的意义是什么呢？至今没有一个确切让我自己信服的借口，可能那也是我的轴罢了。</span></p><h2 id="X7XHC"><span class="ne-text">角质层</span></h2><p id="u229f9c29" class="ne-p"><span class="ne-text">受宠若惊般地小心翼翼，却也掩饰不了一个人的简单纯粹。</span></p><p id="u46db2972" class="ne-p"><span class="ne-text">可是谁又知道这样的小心翼翼，却是在一个在艰难环境下经历那个年纪本不该承受的经历换来的坚强。</span></p><h2 id="qOfeR"><span class="ne-text">尼克塔酒店</span></h2><p id="u96324f7f" class="ne-p"><span class="ne-text">一段旅行，从一开始就应该决定好同行的人，是否相处得来，否则很容易产生矛盾甚至中途散场，即便对方是曾经很要好的朋友或发小，随着时间的推移，人也是会变的。旅行和人生都是如此。</span></p><h2 id="hgsUN"><span class="ne-text">三十岁</span></h2><p id="ubb655d91" class="ne-p"><span class="ne-text">一个人的成长很多时候是这个世界上另一些生命的救赎，谁都应该努力地活着。</span></p></div>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;!doctype html&gt;&lt;div class=&quot;lake-content&quot; typography=&quot;classic&quot;&gt;&lt;p id=&quot;ua9751299&quot; class=&quot;ne-p&quot; style=&quot;text-align: center&quot;&gt;&lt;img</summary>
        
      
    
    
    
    <category term="阅读" scheme="https://www.wztlink1013.com/categories/%E9%98%85%E8%AF%BB/"/>
    
    
  </entry>
  
  <entry>
    <title>一个梦——新学期</title>
    <link href="https://www.wztlink1013.com/essay/shdnxh6ya6pgbh1n/"/>
    <id>https://www.wztlink1013.com/essay/shdnxh6ya6pgbh1n/</id>
    <published>2022-11-23T14:12:36.000Z</published>
    <updated>2022-11-24T05:25:20.000Z</updated>
    
    <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="u3fe3baad" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/1484158/1669244059061-5269cc7d-fa21-4467-a750-5aa43184f583.jpeg" width="600" id="ZLXlO" class="ne-image"></p><p id="uc8d73b3a" class="ne-p"><span class="ne-text">下学期开学了，位置是我初中的那个学校，教室是最初的靠近大门的高排宿舍那里，那里本来是一排宿舍，不知怎么改为教室了。</span></p><p id="u76d5ec95" class="ne-p"><span class="ne-text">新学期开学，我还是一如既往去的很晚，教室里面坐满了人，我看着第三排还是第四排边上有个空位，就坐了过去，第一堂课是数学，具体讲的我忘了，不过记得讲的是一种新型运算，打破传统运算的那种…</span></p><p id="ucb3b5036" class="ne-p"><span class="ne-text">我的同桌告诉我待会可能按照成绩分位置，我一脸懵，不知道有什么成绩…</span></p><p id="u1912f2dc" class="ne-p"><span class="ne-text">然后快下课的前十分钟，班主任进来了，她说报一下上次数学考试排名，我记得我排第五还是第六，分数是我高考数学成绩，同学把我的试卷递给我。老师说这次新班级数学超过1xx的有十个，讲完，我便醒了（冻醒）……</span></p><p id="u8a72d38f" class="ne-p"><span class="ne-text">后记:</span></p><p id="u727b7420" class="ne-p"><span class="ne-text">那个位置不是靠窗的，可我上课还是喜欢看着外面，看那个一排排自行车的地方。</span></p><p id="u62d08c65" class="ne-p"><span class="ne-text">新学期的第一堂课，一如既往般地身边所有同学都很聚精会神，但我却很出神……</span></p><p id="u6a799471" class="ne-p"><span class="ne-text">其实我一直都不喜欢新学期，特别是大学之前的小学初中，一切都太新了，那种氛围感有点让人窒息抑郁…直到大学，我几乎只坐最后一排靠窗，我喜欢在上课的时候看小说，尤其是所有人都在认真听课的时候，记得大三有一个学期中的两个礼拜的所有离散数学课，我全都用来看《平凡的世界》了……</span></p><p id="u4fc2e318" class="ne-p"><span class="ne-text">梦醒的那一刻，一大堆记忆涌入脑海:上大学了…大学毕业了…工作上班了…我还在睡觉…待会起来上班……</span></p></div>]]></content>
    
    
      
      
        
        
    <summary type="html">&lt;!doctype html&gt;&lt;div class=&quot;lake-content&quot; typography=&quot;classic&quot;&gt;&lt;p id=&quot;u3fe3baad&quot; class=&quot;ne-p&quot; style=&quot;text-align: center&quot;&gt;&lt;img</summary>
        
      
    
    
    
    <category term="异世界" scheme="https://www.wztlink1013.com/categories/%E5%BC%82%E4%B8%96%E7%95%8C/"/>
    
    
  </entry>
  
</feed>
