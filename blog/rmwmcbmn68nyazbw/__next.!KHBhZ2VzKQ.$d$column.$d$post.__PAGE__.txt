1:"$Sreact.fragment"
2:I[99897,["/_next/static/chunks/4eaa70fe861e9598.js","/_next/static/chunks/946bdd2e6c9b7c49.js","/_next/static/chunks/6dd6809ee42e252f.js","/_next/static/chunks/f2b800ca7ae14e96.js","/_next/static/chunks/e121db38c98deeb4.js","/_next/static/chunks/0973dd923ca2781d.js","/_next/static/chunks/b397c2fd2abb1207.js","/_next/static/chunks/11dff99839ab5ba0.js"],"MotionPreset"]
3:I[22016,["/_next/static/chunks/4eaa70fe861e9598.js","/_next/static/chunks/946bdd2e6c9b7c49.js","/_next/static/chunks/6dd6809ee42e252f.js","/_next/static/chunks/f2b800ca7ae14e96.js","/_next/static/chunks/e121db38c98deeb4.js","/_next/static/chunks/0973dd923ca2781d.js","/_next/static/chunks/b397c2fd2abb1207.js","/_next/static/chunks/11dff99839ab5ba0.js"],""]
4:I[48347,["/_next/static/chunks/4eaa70fe861e9598.js","/_next/static/chunks/946bdd2e6c9b7c49.js","/_next/static/chunks/6dd6809ee42e252f.js","/_next/static/chunks/f2b800ca7ae14e96.js","/_next/static/chunks/e121db38c98deeb4.js","/_next/static/chunks/0973dd923ca2781d.js","/_next/static/chunks/b397c2fd2abb1207.js","/_next/static/chunks/11dff99839ab5ba0.js"],"default"]
5:I[72436,["/_next/static/chunks/4eaa70fe861e9598.js","/_next/static/chunks/946bdd2e6c9b7c49.js","/_next/static/chunks/6dd6809ee42e252f.js","/_next/static/chunks/f2b800ca7ae14e96.js","/_next/static/chunks/e121db38c98deeb4.js","/_next/static/chunks/0973dd923ca2781d.js","/_next/static/chunks/b397c2fd2abb1207.js","/_next/static/chunks/11dff99839ab5ba0.js"],"Separator"]
c:I[97367,["/_next/static/chunks/ff1a16fafef87110.js","/_next/static/chunks/7340adf74ff47ec0.js"],"OutletBoundary"]
d:"$Sreact.suspense"
6:T2aa2,<!doctype html><div class="lake-content" typography="classic"><p id="u7ed90616" class="ne-p"><span class="ne-text">Vue 3 采用了 </span><code class="ne-code"><span class="ne-text">Proxy</span></code><span class="ne-text"> 来实现响应式系统，主要是为了克服 Vue 2 使用的 </span><code class="ne-code"><span class="ne-text">Object.defineProperty</span></code><span class="ne-text"> 的局限性，并提高响应式数据的灵活性和性能。</span></p><h3 id="aGAX1"><span class="ne-text">原因包括以下几点：</span></h3><ol class="ne-ol"><li id="ub3d77372" data-lake-index-type="0"><strong><span class="ne-text">监听数组与对象的动态属性</span></strong><span class="ne-text">：</span></li></ol><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="ud5ed1330" data-lake-index-type="0"><span class="ne-text">在 Vue 2 中，</span><code class="ne-code"><span class="ne-text">Object.defineProperty</span></code><span class="ne-text"> 只能监听对象已有的属性，无法直接检测新增加的属性，或者删除属性。对于数组，也只能监控特定的变更操作。</span></li><li id="u2a6f0c05" data-lake-index-type="0"><code class="ne-code"><span class="ne-text">Proxy</span></code><span class="ne-text"> 则可以直接监听对象属性的增加、删除操作，并且能够监控数组索引变化。</span></li></ul></ul><ol start="2" class="ne-ol"><li id="u89735285" data-lake-index-type="0"><strong><span class="ne-text">对整个对象的深度拦截</span></strong><span class="ne-text">：</span></li></ol><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="ucefc7144" data-lake-index-type="0"><code class="ne-code"><span class="ne-text">Proxy</span></code><span class="ne-text"> 可以对整个对象进行深度拦截，包括读取属性、设置属性、删除属性等操作，而不需要遍历对象的每个属性。</span></li><li id="ud3bc9058" data-lake-index-type="0"><span class="ne-text">这使得 Vue 3 在处理复杂的数据结构时，性能更好，代码也更加简洁。</span></li></ul></ul><ol start="3" class="ne-ol"><li id="uc09eaedb" data-lake-index-type="0"><strong><span class="ne-text">更好的性能</span></strong><span class="ne-text">：</span></li></ol><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="u4375e856" data-lake-index-type="0"><code class="ne-code"><span class="ne-text">Proxy</span></code><span class="ne-text"> 在某些场景下比 </span><code class="ne-code"><span class="ne-text">Object.defineProperty</span></code><span class="ne-text"> 更高效。例如，Vue 2 需要对每个属性进行单独的处理，而 Vue 3 使用 </span><code class="ne-code"><span class="ne-text">Proxy</span></code><span class="ne-text"> 后，只需要为整个对象设置拦截器，减少了对数据结构的操作和维护成本。</span></li></ul></ul><ol start="4" class="ne-ol"><li id="u02b99247" data-lake-index-type="0"><strong><span class="ne-text">支持更多操作</span></strong><span class="ne-text">：</span></li></ol><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="u691d9548" data-lake-index-type="0"><code class="ne-code"><span class="ne-text">Proxy</span></code><span class="ne-text"> 支持更丰富的操作拦截，比如 </span><code class="ne-code"><span class="ne-text">in</span></code><span class="ne-text"> 操作符、属性枚举、</span><code class="ne-code"><span class="ne-text">has</span></code><span class="ne-text"> 操作符、</span><code class="ne-code"><span class="ne-text">Reflect</span></code><span class="ne-text"> API 等，这些都是 </span><code class="ne-code"><span class="ne-text">Object.defineProperty</span></code><span class="ne-text"> 无法做到的。</span></li></ul></ul><ol start="5" class="ne-ol"><li id="u838df38d" data-lake-index-type="0"><strong><span class="ne-text">简化代码维护</span></strong><span class="ne-text">：</span></li></ol><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="u38a47355" data-lake-index-type="0"><span class="ne-text">由于 </span><code class="ne-code"><span class="ne-text">Proxy</span></code><span class="ne-text"> 可以直接拦截对象的所有操作，Vue 3 的响应式系统实现逻辑相对 Vue 2 更为简单和一致，减少了在 Vue 2 中为了处理特殊情况所做的额外逻辑。</span></li></ul></ul><p id="u08bc3e3b" class="ne-p"><span class="ne-text">总结来说，Vue 3 选择 </span><code class="ne-code"><span class="ne-text">Proxy</span></code><span class="ne-text"> 主要是为了弥补 </span><code class="ne-code"><span class="ne-text">Object.defineProperty</span></code><span class="ne-text"> 的局限性，提供更强大的功能、更好的性能和更简化的实现，提升框架的响应式体验。</span></p><p id="uef9d4db2" class="ne-p"><span class="ne-text"></span></p><p id="u3a44b510" class="ne-p"><span class="ne-text">Vue 3 使用 </span><code class="ne-code"><span class="ne-text">Proxy</span></code><span class="ne-text"> 主要是为了实现响应式系统的更强大和灵活性，替代了 Vue 2 中的 </span><code class="ne-code"><span class="ne-text">Object.defineProperty</span></code><span class="ne-text">。</span><code class="ne-code"><span class="ne-text">Proxy</span></code><span class="ne-text"> 提供了更多的能力和更好的性能优化，以下是 Vue 3 使用 </span><code class="ne-code"><span class="ne-text">Proxy</span></code><span class="ne-text"> 的主要原因：</span></p><ol class="ne-ol"><li id="u74a1dd7e" data-lake-index-type="0"><strong><span class="ne-text">对所有属性的完整支持</span></strong><span class="ne-text">：</span></li></ol><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="ue21cb255" data-lake-index-type="0"><span class="ne-text">Vue 2 使用 </span><code class="ne-code"><span class="ne-text">Object.defineProperty</span></code><span class="ne-text"> 实现响应式，但它只能监听对象现有属性的读取和修改。如果给对象动态添加新属性或者删除属性，Vue 2 无法跟踪到这些变化，用户需要通过 </span><code class="ne-code"><span class="ne-text">Vue.set</span></code><span class="ne-text"> 或 </span><code class="ne-code"><span class="ne-text">Vue.delete</span></code><span class="ne-text"> 来手动处理。而 </span><code class="ne-code"><span class="ne-text">Proxy</span></code><span class="ne-text"> 可以拦截几乎所有操作（如新增、删除、读取、写入等），使响应式系统可以监听对象属性的增删改查，无需特殊方法。</span></li></ul></ul><ol start="2" class="ne-ol"><li id="uc8468352" data-lake-index-type="0"><strong><span class="ne-text">支持数组、Map、Set 等更复杂的数据类型</span></strong><span class="ne-text">：</span></li></ol><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="u05297962" data-lake-index-type="0"><code class="ne-code"><span class="ne-text">Object.defineProperty</span></code><span class="ne-text"> 只能对普通对象和数组进行响应式处理，而 </span><code class="ne-code"><span class="ne-text">Proxy</span></code><span class="ne-text"> 可以直接处理 </span><code class="ne-code"><span class="ne-text">Map</span></code><span class="ne-text">、</span><code class="ne-code"><span class="ne-text">Set</span></code><span class="ne-text">、</span><code class="ne-code"><span class="ne-text">WeakMap</span></code><span class="ne-text"> 和 </span><code class="ne-code"><span class="ne-text">WeakSet</span></code><span class="ne-text"> 等数据结构，使这些更复杂的数据结构也能够响应式化，提升了框架的灵活性。</span></li></ul></ul><ol start="3" class="ne-ol"><li id="uf0a10924" data-lake-index-type="0"><strong><span class="ne-text">性能提升</span></strong><span class="ne-text">：</span></li></ol><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="ua7dc6849" data-lake-index-type="0"><span class="ne-text">Vue 2 的响应式系统需要递归遍历对象的所有属性来进行深度监听，性能消耗较大。Vue 3 使用 </span><code class="ne-code"><span class="ne-text">Proxy</span></code><span class="ne-text"> 可以按需代理属性，减少不必要的性能开销，因为 </span><code class="ne-code"><span class="ne-text">Proxy</span></code><span class="ne-text"> 可以在属性访问时动态拦截操作，只有在访问属性时才会进行监听。</span></li></ul></ul><ol start="4" class="ne-ol"><li id="ub6d284d5" data-lake-index-type="0"><strong><span class="ne-text">更好的语言支持</span></strong><span class="ne-text">：</span></li></ol><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="u2b1b506b" data-lake-index-type="0"><code class="ne-code"><span class="ne-text">Proxy</span></code><span class="ne-text"> 允许拦截很多不同类型的操作，如属性的 </span><code class="ne-code"><span class="ne-text">get</span></code><span class="ne-text">、</span><code class="ne-code"><span class="ne-text">set</span></code><span class="ne-text">、</span><code class="ne-code"><span class="ne-text">has</span></code><span class="ne-text">、</span><code class="ne-code"><span class="ne-text">deleteProperty</span></code><span class="ne-text"> 等。这意味着 Vue 3 可以更精确地处理响应式需求，避免很多边界情况，同时提供了更清晰、可扩展的架构。</span></li></ul></ul><h3 id="qmPPM"><span class="ne-text">示例：</span></h3><p id="u4961e550" class="ne-p"><span class="ne-text">在 Vue 3 中，创建响应式对象非常简单，可以通过 </span><code class="ne-code"><span class="ne-text">reactive</span></code><span class="ne-text"> 函数：</span></p><pre data-language="javascript" id="F3nQD" class="ne-codeblock language-javascript"><code>import { reactive } from 'vue'

const state = reactive({
  count: 0,
  items: []
})

// Vue 3 中可以直接添加新属性或修改属性
state.newProperty = 'New Value'</code></pre><p id="u46252ff4" class="ne-p"><span class="ne-text">在 Vue 2 中则需要使用 </span><code class="ne-code"><span class="ne-text">Vue.set</span></code><span class="ne-text"> 来添加新属性：</span></p><pre data-language="javascript" id="AHzGT" class="ne-codeblock language-javascript"><code>// Vue 2
this.$set(this.state, 'newProperty', 'New Value')</code></pre><p id="ub8fa3d1b" class="ne-p"><code class="ne-code"><span class="ne-text">Proxy</span></code><span class="ne-text"> 提供了一个更一致的 API，避免了 Vue 2 中的一些陷阱和局限性。</span></p><p id="uef4d5808" class="ne-p"><span class="ne-text">总结来说，Vue 3 使用 </span><code class="ne-code"><span class="ne-text">Proxy</span></code><span class="ne-text"> 是为了克服 Vue 2 的一些技术限制，提升开发体验和框架的灵活性与性能。</span></p></div>0:{"buildId":"2u9SFv74KBoU-OjNq8QW0","rsc":["$","$1","c",{"children":[["$","section",null,{"className":"relative","children":["$","$L2",null,{"fade":true,"blur":true,"transition":{"duration":0.5},"delay":0.1,"className":"relative overflow-hidden border-y xl:flex","children":[["$","div",null,{"className":"m-6 w-full flex-1 bg-[radial-gradient(circle_at_center,color-mix(in_oklab,var(--primary)_15%,transparent)_2px,transparent_2px)] bg-size-[18px_18px] max-xl:hidden"}],["$","div",null,{"className":"mx-auto w-full max-w-6xl flex-none space-y-8 px-4 py-8 min-[1158px]:border-x sm:px-6 sm:py-12 lg:px-8","children":[["$","$L2",null,{"fade":true,"blur":true,"slide":{"direction":"down","offset":30},"transition":{"duration":0.4},"children":["$","$L3",null,{"href":"/blog","className":"text-muted-foreground hover:text-foreground inline-flex items-center gap-2 text-sm transition-colors","children":[["$","svg",null,{"xmlns":"http://www.w3.org/2000/svg","width":24,"height":24,"viewBox":"0 0 24 24","fill":"none","stroke":"currentColor","strokeWidth":2,"strokeLinecap":"round","strokeLinejoin":"round","className":"lucide lucide-arrow-left h-4 w-4","aria-hidden":"true","children":[["$","path","1l729n",{"d":"m12 19-7-7 7-7"}],["$","path","x3x0zl",{"d":"M19 12H5"}],"$undefined"]}],"返回","技术博客"]}]}],["$","article",null,{"className":"mx-auto max-w-4xl","children":[["$","header",null,{"className":"mb-8 space-y-6","children":["",["$","$L2",null,{"delay":0.3,"transition":{"duration":0.5},"children":["$","h1",null,{"className":"text-2xl font-bold tracking-tight sm:text-3xl md:text-4xl","children":["$","$L4",null,{"text":"[AI] Vue3为什么要用proxy","delay":30,"animateBy":"words","direction":"bottom"}]}]}],["$","$L2",null,{"fade":true,"blur":true,"slide":{"direction":"down","offset":30},"delay":0.4,"transition":{"duration":0.5},"children":["$","p",null,{"className":"text-muted-foreground text-lg","children":"Vue 3 采用了 Proxy 来实现响应式系统，主要是为了克服 Vue 2 使用的 Object.defineProperty 的局限性，并提高响应式数据的灵活性和性能。原因包括以下几点：监听数组与对象的动态属性：在 Vue 2 中，Object.defineProperty 只能监听对象已..."}]}],["$","$L2",null,{"fade":true,"blur":true,"slide":{"direction":"down","offset":30},"delay":0.5,"transition":{"duration":0.5},"children":["$","div",null,{"className":"text-muted-foreground flex flex-wrap items-center gap-4 text-sm","children":[["$","div",null,{"className":"flex items-center gap-1","children":[["$","svg",null,{"xmlns":"http://www.w3.org/2000/svg","width":24,"height":24,"viewBox":"0 0 24 24","fill":"none","stroke":"currentColor","strokeWidth":2,"strokeLinecap":"round","strokeLinejoin":"round","className":"lucide lucide-calendar h-4 w-4","aria-hidden":"true","children":[["$","path","1cmpym",{"d":"M8 2v4"}],["$","path","4m81vk",{"d":"M16 2v4"}],["$","rect","1hopcy",{"width":"18","height":"18","x":"3","y":"4","rx":"2"}],["$","path","8toen8",{"d":"M3 10h18"}],"$undefined"]}],["$","span",null,{"children":"2024年10月14日"}]]}],["$","div",null,{"className":"flex items-center gap-1","children":[["$","svg",null,{"xmlns":"http://www.w3.org/2000/svg","width":24,"height":24,"viewBox":"0 0 24 24","fill":"none","stroke":"currentColor","strokeWidth":2,"strokeLinecap":"round","strokeLinejoin":"round","className":"lucide lucide-clock h-4 w-4","aria-hidden":"true","children":[["$","path","mmk7yg",{"d":"M12 6v6l4 2"}],["$","circle","1mglay",{"cx":"12","cy":"12","r":"10"}],"$undefined"]}],["$","span",null,{"children":"1.1千字"}]]}],false,false,false]}]}],false]}],["$","$L2",null,{"delay":0.6,"fade":true,"blur":true,"transition":{"duration":0.6},"className":"-mx-4 sm:-mx-6 lg:-mx-8","children":["$","$L5",null,{}]}],["$","$L2",null,{"fade":true,"blur":true,"slide":{"direction":"up","offset":50},"delay":0.7,"transition":{"duration":0.6},"children":["$","div",null,{"className":"prose prose-neutral dark:prose-invert mt-8 max-w-none","dangerouslySetInnerHTML":{"__html":"$6"}}]}],"$L7","$L8"]}]]}],"$L9"]}]}],["$La"],"$Lb"]}],"loading":null,"isPartial":false}
7:["$","$L2",null,{"delay":0.8,"fade":true,"blur":true,"transition":{"duration":0.6},"className":"-mx-4 mt-12 sm:-mx-6 lg:-mx-8","children":["$","$L5",null,{}]}]
8:["$","$L2",null,{"fade":true,"blur":true,"slide":{"direction":"up","offset":30},"delay":0.9,"transition":{"duration":0.5},"children":["$","nav",null,{"className":"mt-8 grid gap-4 md:grid-cols-2","children":[["$","$L3",null,{"href":"/blog/ug01qnk1txsegqfy","className":"hover:bg-muted group flex flex-col rounded-lg border p-4 transition-colors","children":[["$","span",null,{"className":"text-muted-foreground mb-2 text-sm","children":"上一篇"}],["$","span",null,{"className":"group-hover:text-primary line-clamp-2 font-medium transition-colors","children":"[AI] Vue和React的diff算法"}]]}],["$","$L3",null,{"href":"/blog/pp0501bl4i0nrwld","className":"hover:bg-muted group flex flex-col rounded-lg border p-4 text-right transition-colors md:text-right","children":[["$","span",null,{"className":"text-muted-foreground mb-2 text-sm","children":"下一篇"}],["$","span",null,{"className":"group-hover:text-primary line-clamp-2 font-medium transition-colors","children":"注释规范"}]]}]]}]}]
9:["$","div",null,{"className":"m-6 w-full flex-1 bg-[radial-gradient(circle_at_center,color-mix(in_oklab,var(--primary)_15%,transparent)_2px,transparent_2px)] bg-size-[18px_18px] max-xl:hidden"}]
a:["$","script","script-0",{"src":"/_next/static/chunks/11dff99839ab5ba0.js","async":true}]
b:["$","$Lc",null,{"children":["$","$d",null,{"name":"Next.MetadataOutlet","children":"$@e"}]}]
e:null
