1:"$Sreact.fragment"
2:I[99897,["/_next/static/chunks/4eaa70fe861e9598.js","/_next/static/chunks/946bdd2e6c9b7c49.js","/_next/static/chunks/6dd6809ee42e252f.js","/_next/static/chunks/f2b800ca7ae14e96.js","/_next/static/chunks/e121db38c98deeb4.js","/_next/static/chunks/0973dd923ca2781d.js","/_next/static/chunks/b397c2fd2abb1207.js","/_next/static/chunks/11dff99839ab5ba0.js"],"MotionPreset"]
3:I[22016,["/_next/static/chunks/4eaa70fe861e9598.js","/_next/static/chunks/946bdd2e6c9b7c49.js","/_next/static/chunks/6dd6809ee42e252f.js","/_next/static/chunks/f2b800ca7ae14e96.js","/_next/static/chunks/e121db38c98deeb4.js","/_next/static/chunks/0973dd923ca2781d.js","/_next/static/chunks/b397c2fd2abb1207.js","/_next/static/chunks/11dff99839ab5ba0.js"],""]
4:I[85437,["/_next/static/chunks/4eaa70fe861e9598.js","/_next/static/chunks/946bdd2e6c9b7c49.js","/_next/static/chunks/6dd6809ee42e252f.js","/_next/static/chunks/f2b800ca7ae14e96.js","/_next/static/chunks/e121db38c98deeb4.js","/_next/static/chunks/0973dd923ca2781d.js","/_next/static/chunks/b397c2fd2abb1207.js","/_next/static/chunks/11dff99839ab5ba0.js"],"Image"]
5:I[48347,["/_next/static/chunks/4eaa70fe861e9598.js","/_next/static/chunks/946bdd2e6c9b7c49.js","/_next/static/chunks/6dd6809ee42e252f.js","/_next/static/chunks/f2b800ca7ae14e96.js","/_next/static/chunks/e121db38c98deeb4.js","/_next/static/chunks/0973dd923ca2781d.js","/_next/static/chunks/b397c2fd2abb1207.js","/_next/static/chunks/11dff99839ab5ba0.js"],"default"]
6:I[72436,["/_next/static/chunks/4eaa70fe861e9598.js","/_next/static/chunks/946bdd2e6c9b7c49.js","/_next/static/chunks/6dd6809ee42e252f.js","/_next/static/chunks/f2b800ca7ae14e96.js","/_next/static/chunks/e121db38c98deeb4.js","/_next/static/chunks/0973dd923ca2781d.js","/_next/static/chunks/b397c2fd2abb1207.js","/_next/static/chunks/11dff99839ab5ba0.js"],"Separator"]
d:I[97367,["/_next/static/chunks/ff1a16fafef87110.js","/_next/static/chunks/7340adf74ff47ec0.js"],"OutletBoundary"]
e:"$Sreact.suspense"
7:T41d5,<!doctype html><div class="lake-content" typography="classic"><div data-type="info" class="ne-alert"><p id="u09f32c06" class="ne-p"><span class="ne-text">官方文档：</span><a href="https://react.docschina.org/" data-href="https://react.docschina.org/" class="ne-link"><span class="ne-text">React 官方中文文档</span></a></p></div><h2 id="uj1IA"><span class="ne-text">虚拟DOM以及React挂载DOM的方式</span></h2><ol class="ne-ol"><li id="u0893e863" data-lake-index-type="0"><span class="ne-text" style="color: #DF2A3F">利用JavaScript脚本操作DOM的行为是性能损耗的大头</span><span class="ne-text">，故产生虚拟DOM的概念。初始化在内存中得到相应的虚拟DOM树，然后将该结果一次性作用于真实DOM，逻辑层的变动导致部分视图层的改变这渲染逻辑也是经过虚拟DOM加上diff得到一次性结果然后作用于真实DOM，在这里Vue和React都是一样的。</span></li><li id="u7537df37" data-lake-index-type="0"><span class="ne-text">可以简单理解：react模块旨在完成虚拟dom的相关逻辑，react-dom模块旨在完成真实DOM和diff的处理</span></li></ol><pre data-language="tsx" id="HUpnc" class="ne-codeblock language-tsx"><code>// mount container
rootReactDOM.createRoot(document.querySelector('#root'))
// create VDOM
const data = React.createElement('div', {}, 'data')
// VDOM -&gt; true DOM
root.render(data)</code></pre><h2 id="tnGV9"><span class="ne-text">JSX</span></h2><p id="u20bc5507" class="ne-p"><span class="ne-text">上述ReactDOM生成虚拟DOM的方式，实际编写代码不方便，于是出现了类似JSX来简化视图层的代码编写（Vue中利用Template模板来完成相同视图层的逻辑构建）</span></p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/1484158/1703514464788-2de399dc-93ec-4dec-aa38-e6b6c706f0ea.jpeg" id="iIrkc" style="display: block; width: 100%"><ol start="2" class="ne-ol"><li id="uec638825" data-lake-index-type="0"><span class="ne-text">JSX的识别要么在jsx后缀文件书写相关代码逻辑，要么利用babel工具来进行代码转义..</span></li></ol><pre data-language="tsx" id="A2QjJ" class="ne-codeblock language-tsx"><code>const data = (
  &lt;div&gt;
    content&lt;span&gt;something...&lt;/span&gt;
  &lt;/div&gt;
)
root.render(data)</code></pre><ol start="3" class="ne-ol"><li id="u5676031e" data-lake-index-type="0"><span class="ne-text">模板语法：</span><code class="ne-code"><span class="ne-text">{}</span></code><span class="ne-text">，Vue是是</span><code class="ne-code"><span class="ne-text">{{}}</span></code></li></ol><ol class="ne-list-wrap"><ol ne-level="1" class="ne-ol"><li id="u9c91fce8" data-lake-index-type="0"><span class="ne-text">注释：</span><code class="ne-code"><span class="ne-text">{/* */}</span></code></li><li id="ubb6f0de2" data-lake-index-type="0"><span class="ne-text">内容可以变量、函数、JSX嵌套 ······</span></li></ol></ol><ol start="4" class="ne-ol"><li id="u77d43f1f" data-lake-index-type="0"><span class="ne-text">JSX注意事项</span></li></ol><ol class="ne-list-wrap"><ol ne-level="1" class="ne-ol"><li id="u8c6babba" data-lake-index-type="0"><span class="ne-text">严格单标签（</span><code class="ne-code"><span class="ne-text">&lt;Tab /&gt;</span></code><span class="ne-text">）</span></li><li id="ub546b2eb" data-lake-index-type="0"><span class="ne-text">标签名小写</span></li><li id="u0a3d772d" data-lake-index-type="0"><span class="ne-text">唯一根节点 -&gt; </span><code class="ne-code"><span class="ne-text">&lt;&gt;&lt;/&gt;</span></code><span class="ne-text"> 或 </span><code class="ne-code"><span class="ne-text">React.Fragment</span></code></li><li id="u3a39620f" data-lake-index-type="0"><span class="ne-text">部分HTML属性名变动：</span><code class="ne-code"><span class="ne-text">class -&gt; className</span></code><span class="ne-text">; </span><code class="ne-code"><span class="ne-text">for -&gt; htmlFor</span></code><span class="ne-text"> ······</span></li><li id="u70ef716d" data-lake-index-type="0"><span class="ne-text">多单词属性用驼峰方式书写，dataset除外</span></li></ol></ol><h2 id="R4VaM"><span class="ne-text">类组件</span></h2><ol class="ne-ol"><li id="ud1f196e0" data-lake-index-type="0"><span class="ne-text">组件的概念也就是模块的拆分、抽象和复用，和Vue组件一致，React的组件编写有两种，</span><strong><span class="ne-text">类组件</span></strong><span class="ne-text">和</span><strong><span class="ne-text">函数组件</span></strong><span class="ne-text">，实际编写代码，React18函数式组件编写更为推崇，但是理解上以类组件会更好。</span></li><li id="u73a8c970" data-lake-index-type="0"><span class="ne-text">具体类组件的编写，其实就是在面向对象编程，给你一个已知类React.Component，写具体逻辑时，遵照所继承的类的一些规则来扩展业务代码。</span></li></ol><h4 id="qjAcc"><span class="ne-text">简单的父子通信</span></h4><pre data-language="tsx" id="WO9hs" class="ne-codeblock language-tsx"><code>// A component
class A extends React.Component {
  constructor(props) {
    super(props)
    this.props = props
  }
  render {
  this.props.getData('data')
  return (
    &lt;div&gt;A component {this.props.info} &lt;/div&gt;
  )
}
}

// B component
const getData = (data) =&gt; {
  // result -&gt; data
}
const data = &lt;div&gt;content &lt;A info='something' getData={getData} /&gt; &lt;/div&gt;</code></pre><h4 id="Mh3VX"><span class="ne-text">props相关事项</span></h4><ol class="ne-ol"><li id="u64411e8a" data-lake-index-type="0"><span class="ne-text">传入组件的参数可以用扩展运算符来传入</span></li></ol><pre data-language="tsx" id="wB3RS" class="ne-codeblock language-tsx"><code>const data = {
  info: 'something,
    getData: (data) =&gt; {},
  }
const data = &lt;div&gt;&lt;A {...data} /&gt;&lt;/div&gt;</code></pre><ol start="2" class="ne-ol"><li id="u855e1be4" data-lake-index-type="0"><span class="ne-text">单独属性值为true</span></li><li id="uf093ffd6" data-lake-index-type="0"><span class="ne-text">类组件的默认值</span></li></ol><pre data-language="tsx" id="cWN2u" class="ne-codeblock language-tsx"><code>// A component
class A extends React.Component {
  static defaultProps = {
    info: 'default info',
  }
  constructor(props) {
    super(props)
    this.props = props
  }
  render {
  this.props.getData('data')
  return (
    &lt;div&gt;A component {this.props.info} &lt;/div&gt;
  )
}
}
</code></pre><h4 id="PV0r6"><span class="ne-text">响应式变量</span></h4><p id="uc9c5250a" class="ne-p"><span class="ne-text">前端框架必须具体的一个能力就是响应式变量的构造，以及内部实现的动态渲染，react的响应式变量就是构造类的一个私有变量state，再利用其规定指定的方法setState方法来实现响应式</span></p><pre data-language="tsx" id="oEZtS" class="ne-codeblock language-tsx"><code>class A extends React.Component {
  state {
  a: 1,
    }
static defaultProps = {
  info: 'default info',
}
constructor(props) {
  super(props)
  this.props = props
}
render {
  this.props.getData('data')
  return (
    &lt;div&gt;A component {this.props.info} &lt;/div&gt;
  )
}
handleMethod() {
  this.setState({ a: 2 })
}
}</code></pre><div data-type="info" class="ne-alert"><p id="ub5f23f2f" class="ne-p"><span class="ne-text">如果响应式的值为数组呢？</span></p></div><ol class="ne-ol"><li id="ued321890" data-lake-index-type="0"><span class="ne-text">react里面的响应式的值为不可变数据集合，比较简单的情况可以利用剩余参数来解决该问题。</span></li></ol><pre data-language="tsx" id="ofs4H" class="ne-codeblock language-tsx"><code>class A extends React.Component {
  state ={
    a: [1, 2, 3]
  }
  ···
  handleMethod() {
    this.setState({ a: [...a, 4] })
  }
}</code></pre><ol start="2" class="ne-ol"><li id="ubcbe280c" data-lake-index-type="0"><span class="ne-text">深拷贝</span></li></ol><p id="uee425f9f" class="ne-p"><span class="ne-text">（TODO:  应该有更好的解决方式）</span></p><h4 id="xfck5"><span class="ne-text">批处理</span></h4><p id="ufd1bdefd" class="ne-p"><span class="ne-text">响应式处理，内部会一次性收集当前变化的量，进入一个处理队列，最终得到一个最终态来进行渲染，避免状态改变多次渲染的情况。</span></p><ol class="ne-ol"><li id="u0706a769" data-lake-index-type="0"><span class="ne-text">React18之前，在一些函数执行时机下，不会进行批处理，React18之后解决了这个问题。具体有：Promise、setTimeout、原生事件下</span></li><li id="u4bc7f994" data-lake-index-type="0"><span class="ne-text">React提供了防止批处理的函数</span></li></ol><pre data-language="tsx" id="JwAPb" class="ne-codeblock language-tsx"><code>class A extends React.Component {
  state ={
    a: 1
  }
  ···
  handleMethod() {
    ReactDOM.flushSync(() =&gt; {
      this.setState({ a: this.state.a + 1 })
      this.setState({ a: this.state.a + 1 })
    })
    // result: run twice render method...
  }
  render {
  console.info('react render.')
  return (
    &lt;div&gt;A component {this.props.info} &lt;/div&gt;
  )
}
}</code></pre><ol start="3" class="ne-ol"><li id="uc4f4442b" data-lake-index-type="0"><span class="ne-text">setState是一个一个异步函数，其第二个参数可以传入回调函数，以便写状态改变之后的相关业务逻辑</span></li><li id="uc0538438" data-lake-index-type="0"><span class="ne-text">如果传入setState的值是对象，那么会在响应式内部所收集变化的量里面进行覆盖，如果需要实时根据最新变化的量做逻辑处理，则需要传入一个参数为state的回调函数</span></li></ol><pre data-language="tsx" id="AQJAF" class="ne-codeblock language-tsx"><code>class A extends React.Component {
  state ={
    a: 1
  }
  ···
  handleMethod() {
    // 1. cover state
    this.setState({ a: this.state.a + 1 })
    this.setState({ a: this.state.a + 1 })
    // result: a -&gt; 2

    // 2. real time state
    this.setState((state) =&gt; { a: this.state.a + 1 })
    this.setState((state) =&gt; { a: this.state.a + 1 })
    // result: a -&gt; 3
  }
}</code></pre><h4 id="ZhZcD"><span class="ne-text">PureComponent shouldComponentUpdate</span></h4><p id="u1410dea8" class="ne-p"><span class="ne-text">下面代码，因响应式变量变化，所以会执行一次render渲染</span></p><pre data-language="tsx" id="H1yhY" class="ne-codeblock language-tsx"><code>class A extends React.Component {
  state ={
    a: 1
  }
  ···
  handleMethod() {
    this.setState({ a: 1 })
  }
  render {
  console.info('react render.')
  return (
    &lt;div&gt;A component {this.props.info} &lt;/div&gt;
  )
}
}</code></pre><p id="u17863ce9" class="ne-p"><span class="ne-text">上面情况其实响应式的结果都是a变为1，所以从渲染结果上看其实可以优化掉该种情况的渲染，react提供的渲染优化方式有两种：</span></p><p id="u185cfd38" class="ne-p"><span class="ne-text"></span></p><ol class="ne-ol"><li id="ub05164da" data-lake-index-type="0"><span class="ne-text">PureComponent优化组件</span></li></ol><pre data-language="tsx" id="cIkUp" class="ne-codeblock language-tsx"><code>class A extends React.PureComponent {
  ···
}</code></pre><ol start="2" class="ne-ol"><li id="u79b67ec0" data-lake-index-type="0"><span class="ne-text">shouldComponentUpdate生命周期函数</span></li></ol><pre data-language="tsx" id="qlPAC" class="ne-codeblock language-tsx"><code>class A extends React.Component {
  state ={
    a: 1
  }
  ···
  shouldComponentUpdate = (nextProps, nextState) =&gt; {
    if (nextState.a === this.state.a)
      return false // not render
    return true // run render
  }
  render {
  console.info('react render.')
  return (
    &lt;div&gt;A component {this.props.info} &lt;/div&gt;
  )
}
}</code></pre><h4 id="pQyxA"><span class="ne-text">Refs</span></h4><p id="ub19f3212" class="ne-p"><span class="ne-text">框架只是对渲染dom的前置操作做了一层封装，比如先构造虚拟dom或是渲染时机的优化等，但有些时候需要在业务代码里面直接获取dom进行操作，比如input标签的自动聚焦（focus）</span></p><ol class="ne-ol"><li id="u0cc8c58c" data-lake-index-type="0"><span class="ne-text">变量</span></li></ol><pre data-language="tsx" id="Gtxxq" class="ne-codeblock language-tsx"><code>// A component
class A extends React.Component {
  inputRef = React.createRef()
  // this.inputRef.current // -&gt; Input DOM
  render {
  return (
    &lt;div&gt;
      A component
      &lt;input ref={inputRef} /&gt;
    &lt;/div&gt;
  )
}
}</code></pre><ol start="2" class="ne-ol"><li id="u2a7e01e5" data-lake-index-type="0"><span class="ne-text">回调函数</span></li></ol><pre data-language="tsx" id="HxEjk" class="ne-codeblock language-tsx"><code>// A component
class A extends React.Component {
  inputRef = (dom) =&gt; {
    dom.focus()
  }
  // this.inputRef.current // -&gt; Input DOM
  render {
  return (
    &lt;div&gt;
      A component
      &lt;input ref={inputRef} /&gt;
    &lt;/div&gt;
  )
}
}</code></pre><ol start="3" class="ne-ol"><li id="u4ef7dd4c" data-lake-index-type="0"><span class="ne-text">除了可以得到DOM，也可以得到类组件的实例对象</span></li></ol><pre data-language="tsx" id="uJj8I" class="ne-codeblock language-tsx"><code>// A component
class A extends React.Component {
  ···
}

// B component
class B extends React.Component {
  refData = React.createRef() 
  render() {
    return &lt;div&gt;content &lt;A ref={refData} /&gt; &lt;/div&gt;
  }
}</code></pre><h4 id="Q0460"><span class="ne-text">生命周期</span></h4><p id="u55e5dd6b" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2023/png/1484158/1703663129914-06e9fada-b622-489d-813f-9d0ed1dbba41.png" width="1511.6666065984325" title="https://github.com/wojtekmaj/react-lifecycle-methods-diagram" crop="0,0,1,1" id="ud7af5c92" class="ne-image"></p><h4 id="oH5uK"><span class="ne-text">组件模式：RenderProps</span></h4><pre data-language="tsx" id="LQmaO" class="ne-codeblock language-tsx"><code>class A extends React.Component {
  state = {
    x: 0,
    y: 0,
  }
  constructor(props) {
    super(props)
    this.props = props
  }
  componentDidMount = () =&gt; {
    document.addEventListener('mousemove', this.move)
  }
  componentWillUnMount = () =&gt; {
    document.removeEventListener('mousemove', this.move)
  }
  move = (e) =&gt; {
    this.setState({
      x: e.pageX,
      y: e.pageY,
    })
  }
  render() {
    return (
      &lt;React.Fragment&gt;
        { this.props.render(this.state.x, this.state.y)}
      &lt;/React.Fragment&gt;
    )
  }
}
class B extends React.Component {
  render() {
    return &lt;A render={(x, y) =&gt; {
      &lt;div&gt;{x}, {y}&lt;/div&gt;
    }} /&gt;
  }
}</code></pre><h4 id="G0eUR"><span class="ne-text">组件模式：HOC</span></h4><p id="u7d429497" class="ne-p"><span class="ne-text">参数为组件，返回新组件</span></p><pre data-language="tsx" id="fqqW1" class="ne-codeblock language-tsx"><code>function hocFun(WithComponent) {
  return class extends React.Component {
    state = {
      x: 0,
      y: 0,
    }
    componentDidMount = () =&gt; {
      document.addEventListener('mousemove', this.move)
    }
    componentWillUnMount = () =&gt; {
      document.removeEventListener('mousemove', this.move)
    }
    move = (e) =&gt; {
      this.setState({
        x: e.pageX,
        y: e.pageY,
      })
    }
    render() {
      return &lt;WithComponent {...this.state} /&gt;
    }
  }
}
class A extends React.Component {
  render() {
    return (
      &lt;div&gt;
        {this.props.x}, {this.props.y}
      &lt;/div&gt;
    )
  }
}
const C = hocFun(A)
class B extends React.Component {
  render() {
    return &lt;C /&gt;
  }
}</code></pre><h4 id="L9n58"><span class="ne-text">Context通信</span></h4><pre data-language="tsx" id="kRpyC" class="ne-codeblock language-tsx"><code>const ContextData = React.createContext()

class A extends React.Component {
  state = {
    info: 'something'
  }
  render() {
    return (
      A
      &lt;ContextData.Provider value={this.state.info}&gt;
      &lt;B /&gt;
      &lt;/ContextData.Provider&gt;
    )
  }
}
class B extends React.Component {
  render() {
    return (
      B&lt;C /&gt;
    )
  }
}
class C extends React.Component {
  static contextType = ContextData
  componentDidMount = () =&gt; {
    console.lof(this.context)
  }
  render() {
    return (
      C
      &lt;ContextData.Consumer&gt;{ value =&gt; value }&lt;/ContextData.Consumer&gt;
    )
  }
}
// render -&gt; ABCsomething</code></pre></div>0:{"buildId":"mcIhXKXgSeJcHJ-IdbQok","rsc":["$","$1","c",{"children":[["$","section",null,{"className":"relative","children":["$","$L2",null,{"fade":true,"blur":true,"transition":{"duration":0.5},"delay":0.1,"className":"relative overflow-hidden border-y xl:flex","children":[["$","div",null,{"className":"m-6 w-full flex-1 bg-[radial-gradient(circle_at_center,color-mix(in_oklab,var(--primary)_15%,transparent)_2px,transparent_2px)] bg-size-[18px_18px] max-xl:hidden"}],["$","div",null,{"className":"mx-auto w-full max-w-6xl flex-none space-y-8 px-4 py-8 min-[1158px]:border-x sm:px-6 sm:py-12 lg:px-8","children":[["$","$L2",null,{"fade":true,"blur":true,"slide":{"direction":"down","offset":30},"transition":{"duration":0.4},"children":["$","$L3",null,{"href":"/blog","className":"text-muted-foreground hover:text-foreground inline-flex items-center gap-2 text-sm transition-colors","children":[["$","svg",null,{"xmlns":"http://www.w3.org/2000/svg","width":24,"height":24,"viewBox":"0 0 24 24","fill":"none","stroke":"currentColor","strokeWidth":2,"strokeLinecap":"round","strokeLinejoin":"round","className":"lucide lucide-arrow-left h-4 w-4","aria-hidden":"true","children":[["$","path","1l729n",{"d":"m12 19-7-7 7-7"}],["$","path","x3x0zl",{"d":"M19 12H5"}],"$undefined"]}],"返回","技术博客"]}]}],["$","article",null,{"className":"mx-auto max-w-4xl","children":[["$","header",null,{"className":"mb-8 space-y-6","children":[["$","$L2",null,{"fade":true,"blur":true,"slide":{"direction":"up","offset":50},"delay":0.2,"transition":{"duration":0.6},"children":["$","div",null,{"className":"relative aspect-video overflow-hidden rounded-xl","children":["$","$L4",null,{"src":"https://cdn.nlark.com/yuque/0/2023/jpeg/1484158/1703514464788-2de399dc-93ec-4dec-aa38-e6b6c706f0ea.jpeg","alt":"React类组件理解","fill":true,"className":"object-cover","unoptimized":true}]}]}],["$","$L2",null,{"delay":0.3,"transition":{"duration":0.5},"children":["$","h1",null,{"className":"text-2xl font-bold tracking-tight sm:text-3xl md:text-4xl","children":["$","$L5",null,{"text":"React类组件理解","delay":30,"animateBy":"words","direction":"bottom"}]}]}],["$","$L2",null,{"fade":true,"blur":true,"slide":{"direction":"down","offset":30},"delay":0.4,"transition":{"duration":0.5},"children":["$","p",null,{"className":"text-muted-foreground text-lg","children":"官方文档：React 官方中文文档虚拟DOM以及React挂载DOM的方式利用JavaScript脚本操作DOM的行为是性能损耗的大头，故产生虚拟DOM的概念。初始化在内存中得到相应的虚拟DOM树，然后将该结果一次性作用于真实DOM，逻辑层的变动导致部分视图层的改变这渲染逻辑也是经过虚拟DOM..."}]}],["$","$L2",null,{"fade":true,"blur":true,"slide":{"direction":"down","offset":30},"delay":0.5,"transition":{"duration":0.5},"children":["$","div",null,{"className":"text-muted-foreground flex flex-wrap items-center gap-4 text-sm","children":[["$","div",null,{"className":"flex items-center gap-1","children":[["$","svg",null,{"xmlns":"http://www.w3.org/2000/svg","width":24,"height":24,"viewBox":"0 0 24 24","fill":"none","stroke":"currentColor","strokeWidth":2,"strokeLinecap":"round","strokeLinejoin":"round","className":"lucide lucide-calendar h-4 w-4","aria-hidden":"true","children":[["$","path","1cmpym",{"d":"M8 2v4"}],["$","path","4m81vk",{"d":"M16 2v4"}],["$","rect","1hopcy",{"width":"18","height":"18","x":"3","y":"4","rx":"2"}],["$","path","8toen8",{"d":"M3 10h18"}],"$undefined"]}],["$","span",null,{"children":"2023年12月23日"}]]}],["$","div",null,{"className":"flex items-center gap-1","children":[["$","svg",null,{"xmlns":"http://www.w3.org/2000/svg","width":24,"height":24,"viewBox":"0 0 24 24","fill":"none","stroke":"currentColor","strokeWidth":2,"strokeLinecap":"round","strokeLinejoin":"round","className":"lucide lucide-clock h-4 w-4","aria-hidden":"true","children":[["$","path","mmk7yg",{"d":"M12 6v6l4 2"}],["$","circle","1mglay",{"cx":"12","cy":"12","r":"10"}],"$undefined"]}],["$","span",null,{"children":"1.9千字"}]]}],["$","div",null,{"className":"flex items-center gap-1","children":[["$","svg",null,{"xmlns":"http://www.w3.org/2000/svg","width":24,"height":24,"viewBox":"0 0 24 24","fill":"none","stroke":"currentColor","strokeWidth":2,"strokeLinecap":"round","strokeLinejoin":"round","className":"lucide lucide-eye h-4 w-4","aria-hidden":"true","children":[["$","path","1nclc0",{"d":"M2.062 12.348a1 1 0 0 1 0-.696 10.75 10.75 0 0 1 19.876 0 1 1 0 0 1 0 .696 10.75 10.75 0 0 1-19.876 0"}],["$","circle","1v7zrd",{"cx":"12","cy":"12","r":"3"}],"$undefined"]}],["$","span",null,{"children":[7," 阅读"]}]]}],false,false]}]}],false]}],["$","$L2",null,{"delay":0.6,"fade":true,"blur":true,"transition":{"duration":0.6},"className":"-mx-4 sm:-mx-6 lg:-mx-8","children":["$","$L6",null,{}]}],["$","$L2",null,{"fade":true,"blur":true,"slide":{"direction":"up","offset":50},"delay":0.7,"transition":{"duration":0.6},"children":["$","div",null,{"className":"prose prose-neutral dark:prose-invert mt-8 max-w-none","dangerouslySetInnerHTML":{"__html":"$7"}}]}],"$L8","$L9"]}]]}],"$La"]}]}],["$Lb"],"$Lc"]}],"loading":null,"isPartial":false}
8:["$","$L2",null,{"delay":0.8,"fade":true,"blur":true,"transition":{"duration":0.6},"className":"-mx-4 mt-12 sm:-mx-6 lg:-mx-8","children":["$","$L6",null,{}]}]
9:["$","$L2",null,{"fade":true,"blur":true,"slide":{"direction":"up","offset":30},"delay":0.9,"transition":{"duration":0.5},"children":["$","nav",null,{"className":"mt-8 grid gap-4 md:grid-cols-2","children":[["$","$L3",null,{"href":"/blog/okaxuuoq9kqk5hv3","className":"hover:bg-muted group flex flex-col rounded-lg border p-4 transition-colors","children":[["$","span",null,{"className":"text-muted-foreground mb-2 text-sm","children":"上一篇"}],["$","span",null,{"className":"group-hover:text-primary line-clamp-2 font-medium transition-colors","children":"React部分生态链"}]]}],["$","$L3",null,{"href":"/blog/torv9p4z2b79494z","className":"hover:bg-muted group flex flex-col rounded-lg border p-4 text-right transition-colors md:text-right","children":[["$","span",null,{"className":"text-muted-foreground mb-2 text-sm","children":"下一篇"}],["$","span",null,{"className":"group-hover:text-primary line-clamp-2 font-medium transition-colors","children":"TypeScript系统学习"}]]}]]}]}]
a:["$","div",null,{"className":"m-6 w-full flex-1 bg-[radial-gradient(circle_at_center,color-mix(in_oklab,var(--primary)_15%,transparent)_2px,transparent_2px)] bg-size-[18px_18px] max-xl:hidden"}]
b:["$","script","script-0",{"src":"/_next/static/chunks/11dff99839ab5ba0.js","async":true}]
c:["$","$Ld",null,{"children":["$","$e",null,{"name":"Next.MetadataOutlet","children":"$@f"}]}]
f:null
