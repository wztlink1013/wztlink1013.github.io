1:"$Sreact.fragment"
2:I[99897,["/_next/static/chunks/4eaa70fe861e9598.js","/_next/static/chunks/946bdd2e6c9b7c49.js","/_next/static/chunks/6dd6809ee42e252f.js","/_next/static/chunks/f2b800ca7ae14e96.js","/_next/static/chunks/e121db38c98deeb4.js","/_next/static/chunks/0973dd923ca2781d.js","/_next/static/chunks/b397c2fd2abb1207.js","/_next/static/chunks/11dff99839ab5ba0.js"],"MotionPreset"]
3:I[22016,["/_next/static/chunks/4eaa70fe861e9598.js","/_next/static/chunks/946bdd2e6c9b7c49.js","/_next/static/chunks/6dd6809ee42e252f.js","/_next/static/chunks/f2b800ca7ae14e96.js","/_next/static/chunks/e121db38c98deeb4.js","/_next/static/chunks/0973dd923ca2781d.js","/_next/static/chunks/b397c2fd2abb1207.js","/_next/static/chunks/11dff99839ab5ba0.js"],""]
4:I[85437,["/_next/static/chunks/4eaa70fe861e9598.js","/_next/static/chunks/946bdd2e6c9b7c49.js","/_next/static/chunks/6dd6809ee42e252f.js","/_next/static/chunks/f2b800ca7ae14e96.js","/_next/static/chunks/e121db38c98deeb4.js","/_next/static/chunks/0973dd923ca2781d.js","/_next/static/chunks/b397c2fd2abb1207.js","/_next/static/chunks/11dff99839ab5ba0.js"],"Image"]
5:I[48347,["/_next/static/chunks/4eaa70fe861e9598.js","/_next/static/chunks/946bdd2e6c9b7c49.js","/_next/static/chunks/6dd6809ee42e252f.js","/_next/static/chunks/f2b800ca7ae14e96.js","/_next/static/chunks/e121db38c98deeb4.js","/_next/static/chunks/0973dd923ca2781d.js","/_next/static/chunks/b397c2fd2abb1207.js","/_next/static/chunks/11dff99839ab5ba0.js"],"default"]
6:I[72436,["/_next/static/chunks/4eaa70fe861e9598.js","/_next/static/chunks/946bdd2e6c9b7c49.js","/_next/static/chunks/6dd6809ee42e252f.js","/_next/static/chunks/f2b800ca7ae14e96.js","/_next/static/chunks/e121db38c98deeb4.js","/_next/static/chunks/0973dd923ca2781d.js","/_next/static/chunks/b397c2fd2abb1207.js","/_next/static/chunks/11dff99839ab5ba0.js"],"Separator"]
e:I[97367,["/_next/static/chunks/ff1a16fafef87110.js","/_next/static/chunks/7340adf74ff47ec0.js"],"OutletBoundary"]
f:"$Sreact.suspense"
0:{"buildId":"fgnevoCcv3TjAYBn9b4Wj","rsc":["$","$1","c",{"children":[["$","section",null,{"className":"relative","children":["$","$L2",null,{"fade":true,"blur":true,"transition":{"duration":0.5},"delay":0.1,"className":"relative overflow-hidden border-y xl:flex","children":[["$","div",null,{"className":"m-6 w-full flex-1 bg-[radial-gradient(circle_at_center,color-mix(in_oklab,var(--primary)_15%,transparent)_2px,transparent_2px)] bg-size-[18px_18px] max-xl:hidden"}],["$","div",null,{"className":"mx-auto w-full max-w-6xl flex-none space-y-8 px-4 py-8 min-[1158px]:border-x sm:px-6 sm:py-12 lg:px-8","children":[["$","$L2",null,{"fade":true,"blur":true,"slide":{"direction":"down","offset":30},"transition":{"duration":0.4},"children":["$","$L3",null,{"href":"/blog","className":"text-muted-foreground hover:text-foreground inline-flex items-center gap-2 text-sm transition-colors","children":[["$","svg",null,{"xmlns":"http://www.w3.org/2000/svg","width":24,"height":24,"viewBox":"0 0 24 24","fill":"none","stroke":"currentColor","strokeWidth":2,"strokeLinecap":"round","strokeLinejoin":"round","className":"lucide lucide-arrow-left h-4 w-4","aria-hidden":"true","children":[["$","path","1l729n",{"d":"m12 19-7-7 7-7"}],["$","path","x3x0zl",{"d":"M19 12H5"}],"$undefined"]}],"返回","技术博客"]}]}],["$","article",null,{"className":"mx-auto max-w-4xl","children":[["$","header",null,{"className":"mb-8 space-y-6","children":[["$","$L2",null,{"fade":true,"blur":true,"slide":{"direction":"up","offset":50},"delay":0.2,"transition":{"duration":0.6},"children":["$","div",null,{"className":"relative aspect-video overflow-hidden rounded-xl","children":["$","$L4",null,{"src":"https://cdn.nlark.com/yuque/0/2021/png/1484158/1621306847349-d85dfd1a-1580-4dbe-800d-b4b4461ed159.png","alt":"图的遍历——DFS（深度优先）、BFS（广度优先）","fill":true,"className":"object-cover","unoptimized":true}]}]}],["$","$L2",null,{"delay":0.3,"transition":{"duration":0.5},"children":["$","h1",null,{"className":"text-2xl font-bold tracking-tight sm:text-3xl md:text-4xl","children":["$","$L5",null,{"text":"图的遍历——DFS（深度优先）、BFS（广度优先）","delay":30,"animateBy":"words","direction":"bottom"}]}]}],["$","$L2",null,{"fade":true,"blur":true,"slide":{"direction":"down","offset":30},"delay":0.4,"transition":{"duration":0.5},"children":["$","p",null,{"className":"text-muted-foreground text-lg","children":"前言：用邻接矩阵和邻接表两种图的存储形式实现DFS、BFS算法，并附例子实现。总的来说，邻接矩阵比较好处理，没有邻接表处理那么复杂，但是数组永远不能规避的一个缺点就是内存的占用较邻接表高。一、深度优先搜索算法（Depth-First-Search）算法说明访问步骤：访问顶点v；依次从v的未被访..."}]}],["$","$L2",null,{"fade":true,"blur":true,"slide":{"direction":"down","offset":30},"delay":0.5,"transition":{"duration":0.5},"children":["$","div",null,{"className":"text-muted-foreground flex flex-wrap items-center gap-4 text-sm","children":[["$","div",null,{"className":"flex items-center gap-1","children":[["$","svg",null,{"xmlns":"http://www.w3.org/2000/svg","width":24,"height":24,"viewBox":"0 0 24 24","fill":"none","stroke":"currentColor","strokeWidth":2,"strokeLinecap":"round","strokeLinejoin":"round","className":"lucide lucide-calendar h-4 w-4","aria-hidden":"true","children":[["$","path","1cmpym",{"d":"M8 2v4"}],["$","path","4m81vk",{"d":"M16 2v4"}],["$","rect","1hopcy",{"width":"18","height":"18","x":"3","y":"4","rx":"2"}],["$","path","8toen8",{"d":"M3 10h18"}],"$undefined"]}],["$","span",null,{"children":"2022年4月30日"}]]}],["$","div",null,{"className":"flex items-center gap-1","children":[["$","svg",null,{"xmlns":"http://www.w3.org/2000/svg","width":24,"height":24,"viewBox":"0 0 24 24","fill":"none","stroke":"currentColor","strokeWidth":2,"strokeLinecap":"round","strokeLinejoin":"round","className":"lucide lucide-clock h-4 w-4","aria-hidden":"true","children":[["$","path","mmk7yg",{"d":"M12 6v6l4 2"}],["$","circle","1mglay",{"cx":"12","cy":"12","r":"10"}],"$undefined"]}],["$","span",null,{"children":"3.5千字"}]]}],["$","div",null,{"className":"flex items-center gap-1","children":[["$","svg",null,{"xmlns":"http://www.w3.org/2000/svg","width":24,"height":24,"viewBox":"0 0 24 24","fill":"none","stroke":"currentColor","strokeWidth":2,"strokeLinecap":"round","strokeLinejoin":"round","className":"lucide lucide-eye h-4 w-4","aria-hidden":"true","children":[["$","path","1nclc0",{"d":"M2.062 12.348a1 1 0 0 1 0-.696 10.75 10.75 0 0 1 19.876 0 1 1 0 0 1 0 .696 10.75 10.75 0 0 1-19.876 0"}],["$","circle","1v7zrd",{"cx":"12","cy":"12","r":"3"}],"$undefined"]}],["$","span",null,{"children":[14," 阅读"]}]]}],false,false]}]}],false]}],["$","$L2",null,{"delay":0.6,"fade":true,"blur":true,"transition":{"duration":0.6},"className":"-mx-4 sm:-mx-6 lg:-mx-8","children":["$","$L6",null,{}]}],["$","$L2",null,{"fade":true,"blur":true,"slide":{"direction":"up","offset":50},"delay":0.7,"transition":{"duration":0.6},"children":"$L7"}],"$L8","$L9"]}]]}],"$La"]}]}],["$Lb"],"$Lc"]}],"loading":null,"isPartial":false}
d:T5bfa,<!doctype html><div class="lake-content" typography="classic"><p id="c4377b9c5907fc32e4dd3a3ec889224d" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1621307069176-74d6900b-6edd-4e7a-b761-789df7a17cfe.png" width="563" id="W9sKH" class="ne-image"></p><p id="aeba3ae9fd44225e4bcdfd6b1387df74" class="ne-p"><br></p><div data-type="info" class="ne-alert"><p id="8602641d8bcd30fd83b83906a84c1786" class="ne-p"><span class="ne-text">前言：用邻接矩阵和邻接表两种图的存储形式实现DFS、BFS算法，并附例子实现。</span></p><p id="a2a30595325972cce3bffd75dcc31f68" class="ne-p"><span class="ne-text">总的来说，邻接矩阵比较好处理，没有邻接表处理那么复杂，但是数组永远不能规避的一个缺点就是内存的占用较邻接表高。</span></p></div><p id="905ea7f782ba98d5a209da0f35f5c203" class="ne-p"><br></p><h2 id="QOJfe"><span class="ne-text">一、深度优先搜索算法（Depth-First-Search）</span></h2><h3 id="MZ0vA"><span class="ne-text">算法说明</span></h3><p id="4e097c10f9608f768b643efb77ddac9f" class="ne-p"><strong><span class="ne-text">访问步骤：</span></strong></p><div class="ne-quote"><ul class="ne-ul"><li id="7a87afee8efc50a1215b2c73dee1007c"><span class="ne-text">访问顶点v；</span></li><li id="75fd425f477a5edfe8e8f42d7362ada1"><span class="ne-text">依次从v的未被访问的邻接点出发，对图进行深度优先遍历；直至图中和v有路径相通的顶点都被访问；</span></li><li id="fd5afc9bef88cbee4ece89b7a4b042f5"><span class="ne-text">若此时图中尚有顶点未被访问，则从一个未被访问的顶点出发，重新进行深度优先遍历，直到图中所有顶点均被访问过为止。</span></li></ul></div><p id="ba6b093d11719b506938b7131380d8ac" class="ne-p"><br></p><p id="0aab1d1b162418f9bf49863d35a32fda" class="ne-p"><strong><span class="ne-text">核心代码就是利用递归，以及标志数组的设定，每次访问数组元素的那一行，对那行链表进行遍历，每遍历一个链表结点，就将“其”所在的那个数组元素“点亮”。如果标志数组里面的所有元素都被访问了，说明遍历完了</span></strong></p><p id="b12a3d4a70976459fc1d9bcab1a7ff25" class="ne-p" style="text-indent: 2em"><br></p><p id="ccdd034b8bc976b98a833b1b3a4480f7" class="ne-p"><strong><span class="ne-text">深度优先搜索类似于树里面遍历算法当中的先序遍历。</span></strong></p><h3 id="ZU5Ew"><span class="ne-text">邻接矩阵的DFS代码</span></h3><p id="0c7fc91bebbf033661b0d2f0e2755bb3" class="ne-p"><span class="ne-text">以这个无向图为例</span></p><p id="e91496d0133f08a7c583147a966ce5cb" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1621329549870-b2fd8a63-a532-4860-8e46-a79cc52a7e0f.png" width="197" id="Xvwlk" class="ne-image"></p><p id="f5a357efd0ac30dc1a34889c7258c8c8" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1621329584016-32d023fe-dc14-4c0d-90e1-7afe6fcc9cd2.png" width="227.5" id="XY5Cd" class="ne-image"></p><pre data-language="cpp" id="Z8wpM" class="ne-codeblock language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;

#define MVNum 100
#define MaxInt 32767

typedef char VerTexType;
typedef int ArcType;

/**
 * 邻接矩阵存储形式
 */
typedef struct {
    /* data */
    VerTexType vexs[MVNum]; //顶点表
    ArcType arcs[MVNum][MVNum]; //邻接矩阵
    int vexnum, arcnum; //图的当前顶点和边数
}AMGraph;

/**
 * 确定v在G中的位置，即顶点数组的下标
 */
int LocateVex(AMGraph &amp;G, char v) {
    for (int i = 0; i &lt; G.vexnum;i++) {
        if (v == G.vexs[i]){
            return i;
        }
    }
}

/**
 * 如果创建无向图   
 */
void CreateUDN(AMGraph &amp;G) {
    // 采用邻接矩阵表示法，创建无向图G
    cout &lt;&lt; &quot;请输入顶点数和边数：&quot; &lt;&lt; endl;
    cin &gt;&gt; G.vexnum &gt;&gt; G.arcnum; //输入顶点数和边数
    // 初始化顶点
    for (int i = 0; i &lt; G.vexnum;i++){
        cout &lt;&lt; &quot;请输入第&quot; &lt;&lt; i &lt;&lt; &quot;个顶点值&quot; &lt;&lt; endl;
        cin &gt;&gt; G.vexs[i];
    }
    // 初始化邻接矩阵的边的权值为最大值
    for (int i = 0; i &lt; G.vexnum;i++) {
        for (int j = 0; j &lt; G.vexnum;j++) {
            G.arcs[i][j] = 0;
        }
    }
    // 构造邻接矩阵
    for (int k = 0; k &lt; G.arcnum;k++) {
        cout &lt;&lt; &quot;请输入每条边所依附的顶点：&quot; &lt;&lt; endl;
        char v1, v2;
        int w = 1; //一条边所依附的顶点和权值
        cin &gt;&gt; v1 &gt;&gt; v2;
        int i = LocateVex(G, v1);
        int j = LocateVex(G, v2);
        G.arcs[i][j] = w;
        G.arcs[j][i] = w;
    }
}

/**
 * 打印输出图
 */
void Display(AMGraph &amp;G) {
    for (int i = 0; i &lt; G.vexnum;i++) {
        for (int j = 0; j &lt; G.vexnum;j++) {
            cout &lt;&lt; G.arcs[i][j] &lt;&lt; &quot; &quot;;
        }
        cout &lt;&lt; endl;
    }
}




//----邻接矩阵的DFS遍历----

//访问标志数组，其初值为false
bool visited[MVNum]; 

/**
 * 图G为邻接矩阵类型，从第v个顶点出发深度优先搜索遍历图G
 */
void DFS_AM(AMGraph &amp;G, int v) {
    //访问第v个顶点，并置访问标志数组相应分量值为true
    cout&lt;&lt;v;  
    visited[v] = true;
    //依次检查邻接矩阵v所在的行
    for(int w = 0; w &lt; G.vexnum; w++)  
        //G.arcs[v][w] != 0表示w是v的邻接点，!visited[w]表示未访问到
        if((G.arcs[v][w] != 0) &amp;&amp; (!visited[w]))  
            DFS_AM(G, w);    //递归调用DFS_AM
}

/**
 * 图G的储存类型任意，对非连通图G做深度优先遍历
 */
void DFSTraverse(AMGraph &amp;G) {
    //访问标志数组初始化
    for(int v = 0; v &lt; G.vexnum; v++)  
        visited[v] = false;
    //循环调用DFS
    for(int v = 0; v &lt; G.vexnum; v++)  
        if(!visited[v])
            DFS_AM(G, v); //对尚未访问的顶点调用DFS
}




int main() {
    AMGraph test;
    CreateUDN(test);
    Display(test);
    DFSTraverse(test);
    return 0;
}
</pre><h3 id="yoSIg"><span class="ne-text">邻接表的DFS代码</span></h3><p id="0185257cc5891b4779bd509a36e4bf08" class="ne-p"><span class="ne-text">举之前上课的一张PPT例子（元素插入为后插法）</span></p><p id="8f0f1b106f7dee1d8b9124d39e708517" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1621333199678-46b6841b-415b-46e8-b0f6-0d0407284b15.png" width="554" id="HmOsr" class="ne-image"></p><p id="7d9b1ab0ddea1a0b1cc6919a63753b20" class="ne-p"><span class="ne-text">结果</span></p><p id="87a60371c70d6ef42ae0b5733953742a" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1621333246481-117ec0ea-ab95-43be-ac13-75712fdf1e2b.png" width="222" id="KjOYY" class="ne-image"></p><pre data-language="cpp" id="5Kw5x" class="ne-codeblock language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;

#define MVNum 100
#define MaxInt 32767

typedef char VerTexType;
typedef int OtherInfo;

/**
 * 邻接表存储
 */

/**
 * 存储结构
 */
typedef struct ArcNode {  //边结点                    
    int adjvex;  //该边所指向的结点的位置
    struct ArcNode *nextarc; //指向下一条边的指针
    OtherInfo info;   //和边相关的其他信息
}ArcNode;

typedef struct VNode {   //顶点信息
    VerTexType data;  //数据域，存放顶点vi的名称或其他有关信息
    ArcNode *firstarc;  //指向第一条依附该顶点的边的指针
}VNode, AdjList[MVNum]; //AdjList表示邻接表的类型

typedef struct {
    AdjList vertices;
    int vexnum, arcnum; //图当前的顶点数和边数
}ALGragh; //邻接表（Adjacency List）


/**
 * 找到v顶点在图的顶点数组中的位置
 */
int LocateVex(ALGragh &amp;G, char v) {
    for (int i = 0; i &lt; G.vexnum;i++) {
        if (v == G.vertices[i].data) {
            return i;
        }
    }
}

/**
 * 邻接表创建无向图
 */
void CreateUDG(ALGragh &amp;G) {
    cout &lt;&lt; &quot;请输入顶点数和边数：&quot; &lt;&lt; endl;
    cin &gt;&gt; G.vexnum &gt;&gt; G.arcnum; // 邻接表的顶点数和边数
    // 初始化顶点数组
    for (int i = 0; i &lt; G.vexnum;i++) {
        cin &gt;&gt; G.vertices[i].data; // 初始化顶点数组里面的结点data
        G.vertices[i].firstarc = NULL; // 初始化顶点数组里面的结点next域
    }
    // 初始化所有的边
    for (int k = 0; k &lt; G.arcnum;k++) {
        char v1, v2;
        cout &lt;&lt; &quot;请输入每条边所依附的顶点：&quot; &lt;&lt; endl;
        cin &gt;&gt; v1 &gt;&gt; v2;
        int i = LocateVex(G, v1); // 找到v1在顶点数组的下标
        int j = LocateVex(G, v2); // 找到v2在顶点数组的下标
        // 下面建立p1和p2是因为无向图，如果是有向图就没必要了只需要p1
        // 前插
        ArcNode *p1 = new ArcNode;
        p1-&gt;adjvex = j;
        p1-&gt;nextarc = G.vertices[i].firstarc;
        G.vertices[i].firstarc = p1;
        ArcNode *p2 = new ArcNode;
        p2-&gt;adjvex = i;
        p2-&gt;nextarc = G.vertices[j].firstarc;
        G.vertices[j].firstarc = p2;
    }
}

/**
 * 打印输出图
 */
void Display(ALGragh &amp;G) {
    for (int i = 0; i &lt; G.vexnum;i++) {
        cout &lt;&lt; &quot;结点&quot; &lt;&lt; i &lt;&lt; &quot;：&quot;;
        // 复制选中的节点数组中的结点
        VNode p;
        p = G.vertices[i];
        if (p.firstarc != NULL){
            ArcNode *temp;
            temp = G.vertices[i].firstarc;
            while (temp != NULL) {
                cout &lt;&lt; temp-&gt;adjvex&lt;&lt;&quot; &quot;;
                temp = temp-&gt;nextarc;
            }
            cout &lt;&lt; &quot;\n&quot;;
        }
    }
}



//----邻接表的DFS遍历----
bool visited[MVNum];                                                    //访问标志数组，其初值为false

void DFS_AL(ALGragh G, int v)               
{//图G为邻接表类型，从从第v个顶点出发深度优先搜索遍历图G
    cout&lt;&lt;v;                                                            //访问第v个顶点，并置访问标志数组相应分量值为true
    visited[v] = true;
    ArcNode *p;                                                         
    p = G.vertices[v].firstarc;                                         //p指向v的边链表的第一个边结点
    while(p != NULL)
    {
       int w = p-&gt;adjvex;                                               //w是v的邻接点
        if(!visited[w])                                                 //如果w未访问
            DFS_AL(G, w);                                               //递归调用DFS_AL
        p = p-&gt;nextarc;                                                 //p指向下一个结点
    }
}

void DFSTraverse(ALGragh G)
{//图G的储存类型任意，对非连通图G做深度优先遍历
    for(int v = 0; v &lt; G.vexnum; v++)                                   //访问标志数组初始化
        visited[v] = false;
    for(int v = 0; v &lt; G.vexnum; v++)                                   //循环调用DFS
        if(!visited[v])
            DFS_AL(G, v);                                                  //对尚未访问的顶点调用DFS
}


int main() {
    ALGragh test;
    CreateUDG(test);
    // Display(test);
    DFSTraverse(test);
}</pre><h2 id="QXnap"><span class="ne-text">二、广度优先搜索算法（Breadth-First-Search）</span></h2><h3 id="G0xbz"><span class="ne-text">算法说明</span></h3><p id="94b96fd18f6299a92edb0bbb0104497e" class="ne-p"><span class="ne-text">从某个顶点V0出发，并在访问此顶点之后依次访问V0的所有未被访问过的邻接点，之后按这些顶点被访问的先后次序依次访问它们的邻接点，直至图中所有和V0有路径相通的顶点都被访问到。</span></p><p id="79c6bc4660da95e5eb3a4d3b82f0c95d" class="ne-p"><span class="ne-text"></span></p><p id="7d0dd6f76b33ab2e7809089c7833daa9" class="ne-p"><span class="ne-text">若此时图中尚有顶点未被访问，则另选图中一个未曾被访问的顶点作起始点，重复上述过程，直至图中所有顶点都被访问到为止。</span></p><p id="c994dac6d6ea729bf4c53d5e56f6b638" class="ne-p"><br></p><p id="5603100122d38ec5f9e050b858b65d40" class="ne-p"><strong><span class="ne-text">在树遍历中类似层次遍历。</span></strong></p><p id="cec298b23684b1046e1e7ced82785774" class="ne-p"><strong><span class="ne-text"></span></strong></p><h3 id="tX0WF"><span class="ne-text">邻接矩阵的BFS代码</span></h3><p id="2c79fedd6fba3d1dc3fa877ec630c8b4" class="ne-p"><span class="ne-text">还是这个例子</span></p><p id="4182bef26913ccb9daaf8020669dfc2f" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1621329549870-b2fd8a63-a532-4860-8e46-a79cc52a7e0f.png" width="197" id="bbWIn" class="ne-image"></p><p id="aee9ada2779b6772f70229266531e473" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1621338913834-3f2453f3-c56d-4401-9e26-2de805587a04.png" width="228.5" id="hRiOt" class="ne-image"></p><pre data-language="cpp" id="yEEtQ" class="ne-codeblock language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;

#define MVNum 100
#define MaxInt 32767

typedef char VerTexType;
typedef int ArcType;

/**
 * 邻接矩阵的bfs代码
 */
typedef struct {
    /* data */
    VerTexType vexs[MVNum]; //顶点表
    ArcType arcs[MVNum][MVNum]; //邻接矩阵
    int vexnum, arcnum; //图的当前顶点和边数
}AMGraph;

/**
 * 确定v在G中的位置，即顶点数组的下标
 */
int LocateVex(AMGraph &amp;G, char v) {
    for (int i = 0; i &lt; G.vexnum;i++) {
        if (v == G.vexs[i]){
            return i;
        }
    }
}

/**
 * 创建无向网
 * 如果创建无向图   
 */
void CreateUDN(AMGraph &amp;G) {
    // 采用邻接矩阵表示法，创建无向图G
    cout &lt;&lt; &quot;请输入顶点数和边数：&quot; &lt;&lt; endl;
    cin &gt;&gt; G.vexnum &gt;&gt; G.arcnum; //输入顶点数和边数
    // 初始化顶点
    for (int i = 0; i &lt; G.vexnum;i++){
        cout &lt;&lt; &quot;请输入第&quot; &lt;&lt; i &lt;&lt; &quot;个顶点值&quot; &lt;&lt; endl;
        cin &gt;&gt; G.vexs[i];
    }
    // 初始化邻接矩阵的边的权值为最大值
    for (int i = 0; i &lt; G.vexnum;i++) {
        for (int j = 0; j &lt; G.vexnum;j++) {
            G.arcs[i][j] = 0;
        }
    }
    // 构造邻接矩阵
    for (int k = 0; k &lt; G.arcnum;k++) {
        cout &lt;&lt; &quot;请输入每条边所依附的顶点：&quot; &lt;&lt; endl;
        char v1, v2;
        int w = 1; //一条边所依附的顶点和权值
        cin &gt;&gt; v1 &gt;&gt; v2;
        int i = LocateVex(G, v1);
        int j = LocateVex(G, v2);
        G.arcs[i][j] = w;
        G.arcs[j][i] = w;
    }
}

/**
 * 打印输出图
 */
void Display(AMGraph &amp;G) {
    for (int i = 0; i &lt; G.vexnum;i++) {
        for (int j = 0; j &lt; G.vexnum;j++) {
            cout &lt;&lt; G.arcs[i][j] &lt;&lt; &quot; &quot;;
        }
        cout &lt;&lt; endl;
    }
}




//----邻接矩阵的BFS遍历----

bool visited[MVNum]; 

void BFS_AM(AMGraph G, int v)
{//按广度优先非递归遍历连通图G
    cout&lt;&lt;v;
    visited[v] = true; //访问第v个顶点，并置访问标志数组相应分量值为true
    queue&lt;int&gt; Q;
    Q.push(v);
    while(!Q.empty())
    {
        int u = Q.front(); //队头元素出队并置为u
        Q.pop();
        for(int w = 0; w &lt; G.vexnum; w++)
            if((G.arcs[u][w] != 0) &amp;&amp; (!visited[w])) //G.arcs[v][w] != 0表示w是v的邻接点，!visited[w]表示未访问到                                            //w为u的尚未访问的邻接顶点
            {
                cout&lt;&lt;w;
                visited[w] = true; //访问w，并置访问标志数组相应分量值为true
                Q.push(w); //w进队
            }
    }
}

void BFSTraverse(AMGraph &amp;G) {
    //访问标志数组初始化
    for(int v = 0; v &lt; G.vexnum; v++)  
        visited[v] = false;
    //循环调用BFS
    for(int v = 0; v &lt; G.vexnum; v++)  
        if(!visited[v])
            BFS_AM(G, v); //对尚未访问的顶点调用BFS
}


int main() {
    AMGraph test;
    CreateUDN(test);
    Display(test);
    // DFSTraverse(test);
    BFSTraverse(test);
    return 0;
}
</pre><h3 id="1RjxQ"><span class="ne-text">邻接表的BFS代码</span></h3><p id="19d60bf6aae1fc1f2364707c8a4a32c7" class="ne-p"><span class="ne-text">还用和DFS一样的例子</span></p><p id="2f63b2855bb2a7ced47b120060177ab5" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1621339344717-55530db9-253b-451d-af57-b591ff17353e.png" width="417" id="I73u9" class="ne-image"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1621390194148-da12a2e4-1f85-491b-9e53-3848ac4e4a4c.png" width="167" id="iul50" class="ne-image"></p><p id="5b8a5022ed1fcec1eef4bd087d6293fa" class="ne-p"><br></p><p id="44e1f9ec1603ae99eb545fd108578a1c" class="ne-p"><br></p><pre data-language="cpp" id="oXGJ9" class="ne-codeblock language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;

#define MVNum 100
#define MaxInt 32767

typedef char VerTexType;
typedef int OtherInfo;

/**
 * 邻接表的bfs代码
 */

/**
 * 存储结构
 */
typedef struct ArcNode {  //边结点                    
    int adjvex;  //该边所指向的结点的位置
    struct ArcNode *nextarc; //指向下一条边的指针
    OtherInfo info;   //和边相关的其他信息
}ArcNode;

typedef struct VNode {   //顶点信息
    VerTexType data;  //数据域，存放顶点vi的名称或其他有关信息
    ArcNode *firstarc;  //指向第一条依附该顶点的边的指针
}VNode, AdjList[MVNum]; //AdjList表示邻接表的类型

typedef struct {
    AdjList vertices;
    int vexnum, arcnum; //图当前的顶点数和边数
}ALGraph; //邻接表（Adjacency List）


/**
 * 找到v顶点在图的顶点数组中的位置
 */
int LocateVex(ALGraph &amp;G, char v) {
    for (int i = 0; i &lt; G.vexnum;i++) {
        if (v == G.vertices[i].data) {
            return i;
        }
    }
}

/**
 * 邻接表创建无向图
 */
void CreateUDG(ALGraph &amp;G) {
    cout &lt;&lt; &quot;请输入顶点数和边数：&quot; &lt;&lt; endl;
    cin &gt;&gt; G.vexnum &gt;&gt; G.arcnum; // 邻接表的顶点数和边数
    // 初始化顶点数组
    for (int i = 0; i &lt; G.vexnum;i++) {
        cin &gt;&gt; G.vertices[i].data; // 初始化顶点数组里面的结点data
        G.vertices[i].firstarc = NULL; // 初始化顶点数组里面的结点next域
    }
    // 初始化所有的边
    for (int k = 0; k &lt; G.arcnum;k++) {
        char v1, v2;
        cout &lt;&lt; &quot;请输入每条边所依附的顶点：&quot; &lt;&lt; endl;
        cin &gt;&gt; v1 &gt;&gt; v2;
        int i = LocateVex(G, v1); // 找到v1在顶点数组的下标
        int j = LocateVex(G, v2); // 找到v2在顶点数组的下标
        // 下面建立p1和p2是因为无向图，如果是有向图就没必要了只需要p1
        // 前插
        ArcNode *p1 = new ArcNode;
        p1-&gt;adjvex = j;
        p1-&gt;nextarc = G.vertices[i].firstarc;
        G.vertices[i].firstarc = p1;
        ArcNode *p2 = new ArcNode;
        p2-&gt;adjvex = i;
        p2-&gt;nextarc = G.vertices[j].firstarc;
        G.vertices[j].firstarc = p2;
    }
}

/**
 * 打印输出图
 */
void Display(ALGraph &amp;G) {
    for (int i = 0; i &lt; G.vexnum;i++) {
        cout &lt;&lt; &quot;结点&quot; &lt;&lt; i &lt;&lt; &quot;：&quot;;
        // 复制选中的节点数组中的结点
        VNode p;
        p = G.vertices[i];
        if (p.firstarc != NULL){
            ArcNode *temp;
            temp = G.vertices[i].firstarc;
            while (temp != NULL) {
                cout &lt;&lt; temp-&gt;adjvex&lt;&lt;&quot; &quot;;
                temp = temp-&gt;nextarc;
            }
            cout &lt;&lt; &quot;\n&quot;;
        }
    }
}



//----邻接表的BFS遍历----

bool visited[MVNum];

int FirstAdjvex(ALGraph&amp; G, int u)
{
    int w = G.vertices[u].firstarc-&gt;adjvex;
    return w;
}
int NextAdjVex(ALGraph&amp; G, int u, int w)
{
    ArcNode *temp = G.vertices[u].firstarc;
    while (temp-&gt;adjvex != w)
    {
        temp = temp-&gt;nextarc;
    }
    if (temp-&gt;nextarc)
        return temp-&gt;nextarc-&gt;adjvex;
    else 
        return -1;
    delete temp;
}
void BFS_AL(ALGraph&amp; G, int v){
    cout &lt;&lt; v;
    visited[v] = true;
    queue&lt;int&gt; Q;
    Q.push(v);
    int u = v;
    while (!Q.empty()){
        u = Q.front();
        Q.pop();
        for (int w = FirstAdjvex(G, u); w &gt;= 0; w = NextAdjVex(G, u, w)){
            if (!visited[w]){
                cout &lt;&lt;w; 
                visited[w] = true;
                Q.push(w);
            }
        }
    }
}

void BFSTraverse(ALGraph &amp;G) {
    //访问标志数组初始化
    for(int v = 0; v &lt; G.vexnum; v++)  
        visited[v] = false;
    //循环调用BFS
    for(int v = 0; v &lt; G.vexnum; v++)  
        if(!visited[v])
            BFS_AL(G, v); //对尚未访问的顶点调用BFS
}

int main() {
    ALGraph test;
    CreateUDG(test);
    Display(test);
    BFSTraverse(test);
}</pre><p id="c606f86cc011bbd8daff4fdf8fde78ee" class="ne-p"><span class="ne-text"></span></p><div data-type="danger" class="ne-alert"><p id="0ef6670727161ceae2b2fd7611579ede" class="ne-p"><span class="ne-text">【插眼】为啥我写的一个函数不需要队列也可以？？？直接将顶点数组的一个元素后面接的链表遍历不就好了，然后再遍历标志数组元素值部位true的不就好了。。。为啥要压队列呀？</span></p><p id="40e16d77d4f0ef5fa0dd607f4ef45ee1" class="ne-p"><span class="ne-text">莫不是哪里有隐藏的bug，插个眼！！！</span></p></div><p id="e6f8995f72a0e332e6921816bb8d07b0" class="ne-p"><span class="ne-text"></span></p><p id="410e780ff2dc9b2b7265d7357bed6936" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/gif/1484158/1621340205400-d534997e-4b20-4f0e-8db6-4a91e39c68b6.gif" width="218" id="Ivn4n" class="ne-image"></p><p id="87461184d6165e71f83ee3ca2c47cee8" class="ne-p"><span class="ne-text"></span></p><div data-type="success" class="ne-alert"><p id="4555a876fb667c46816df66773c5e6e1" class="ne-p"><span class="ne-text">【拔眼】这样是一种特殊情况，只适合图的各个结点是按照层次标号的，并且放入标志数组也是按照顺序放入的……</span></p></div><p id="1cf117f18c823349567e5d7b36a5ff7b" class="ne-p"><br></p><p id="0f6e52a1f536ea9359c2494c19ca0529" class="ne-p"><span class="ne-text">插眼代码如下：</span></p><pre data-language="cpp" id="8k1hc" class="ne-codeblock language-cpp">void BFS_AL(ALGraph &amp;G, int v)
{//按广度优先非递归遍历连通图G
    cout&lt;&lt;v;
    visited[v] = true;    //访问第v个顶点，并置访问标志数组相应分量值为true
    ArcNode *p;
    p = G.vertices[v].firstarc;
    if (p != NULL) {
        while(p != NULL) {
            if (!visited[p-&gt;adjvex]){
                cout &lt;&lt; p-&gt;adjvex;
            }
            visited[p-&gt;adjvex] = true;
            p = p-&gt;nextarc;
        }
    }
}</pre><p id="ae0f5d621f99ca5480d74bece56a5520" class="ne-p"><span class="ne-text"></span></p></div>7:["$","div",null,{"className":"prose prose-neutral dark:prose-invert mt-8 max-w-none","dangerouslySetInnerHTML":{"__html":"$d"}}]
8:["$","$L2",null,{"delay":0.8,"fade":true,"blur":true,"transition":{"duration":0.6},"className":"-mx-4 mt-12 sm:-mx-6 lg:-mx-8","children":["$","$L6",null,{}]}]
9:["$","$L2",null,{"fade":true,"blur":true,"slide":{"direction":"up","offset":30},"delay":0.9,"transition":{"duration":0.5},"children":["$","nav",null,{"className":"mt-8 grid gap-4 md:grid-cols-2","children":[["$","$L3",null,{"href":"/blog/rxx0ab","className":"hover:bg-muted group flex flex-col rounded-lg border p-4 transition-colors","children":[["$","span",null,{"className":"text-muted-foreground mb-2 text-sm","children":"上一篇"}],["$","span",null,{"className":"group-hover:text-primary line-clamp-2 font-medium transition-colors","children":"最短路径算法（Dijkstra+Floyd）"}]]}],["$","$L3",null,{"href":"/blog/gqpli5","className":"hover:bg-muted group flex flex-col rounded-lg border p-4 text-right transition-colors md:text-right","children":[["$","span",null,{"className":"text-muted-foreground mb-2 text-sm","children":"下一篇"}],["$","span",null,{"className":"group-hover:text-primary line-clamp-2 font-medium transition-colors","children":"图的术语、存储、应用综述"}]]}]]}]}]
a:["$","div",null,{"className":"m-6 w-full flex-1 bg-[radial-gradient(circle_at_center,color-mix(in_oklab,var(--primary)_15%,transparent)_2px,transparent_2px)] bg-size-[18px_18px] max-xl:hidden"}]
b:["$","script","script-0",{"src":"/_next/static/chunks/11dff99839ab5ba0.js","async":true}]
c:["$","$Le",null,{"children":["$","$f",null,{"name":"Next.MetadataOutlet","children":"$@10"}]}]
10:null
