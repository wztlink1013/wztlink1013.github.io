<!DOCTYPE html><!--ojCF045NjSCdIX953ggig--><html lang="zh-CN" class="inter_2835ecbf-module__TsU-8G__variable geist_mono_8d43a2aa-module__8Li5zG__variable relative flex min-h-full w-full scroll-smooth antialiased"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="preload" href="/_next/static/media/797e433ab948586e-s.p.dbea232f.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="preload" href="/_next/static/media/83afe278b6a6bb3c-s.p.3a6ba036.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="preload" as="image" href="/logo.png"/><link rel="stylesheet" href="/_next/static/chunks/4f409435d31fc1ca.css" data-precedence="next"/><link rel="stylesheet" href="/_next/static/chunks/ca3b7ea61b268a33.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/a1b55b20c0e4c4bd.js"/><script src="/_next/static/chunks/eb87c87a89f31e5b.js" async=""></script><script src="/_next/static/chunks/30ea11065999f7ac.js" async=""></script><script src="/_next/static/chunks/9f8fab379d1cd10d.js" async=""></script><script src="/_next/static/chunks/turbopack-3b6b8845719237cd.js" async=""></script><script src="/_next/static/chunks/4eaa70fe861e9598.js" async=""></script><script src="/_next/static/chunks/ff1a16fafef87110.js" async=""></script><script src="/_next/static/chunks/7340adf74ff47ec0.js" async=""></script><script src="/_next/static/chunks/fa1a8f8830b9bf3a.js" async=""></script><script src="/_next/static/chunks/6dd6809ee42e252f.js" async=""></script><script src="/_next/static/chunks/f2b800ca7ae14e96.js" async=""></script><script src="/_next/static/chunks/e121db38c98deeb4.js" async=""></script><script src="/_next/static/chunks/6d971f5a9c16d0c2.js" async=""></script><script src="/_next/static/chunks/b397c2fd2abb1207.js" async=""></script><script src="/_next/static/chunks/11dff99839ab5ba0.js" async=""></script><meta name="next-size-adjust" content=""/><title>[转]操作系统核心知识点 | 尼采般地抒情</title><meta name="description" content="本文转载自：5万字、97 张图总结操作系统核心知识点 - 程序员cxuan - 博客园部分内容自行添加这不是一篇教你如何创建一个操作系统的文章，相反，这是一篇指导性文章，教你从几个方面来理解操作系统。首先你需要知道你为什么要看这篇文章以及为什么要学习操作系统。搞清楚几个问题首先你要搞明白你学习..."/><link rel="manifest" href="/manifest.json"/><meta name="keywords" content="portfolio,creative portfolio,web developer,designer,next.js portfolio,尼采般地抒情 portfolio,projects showcase,professional services,web design,ui/ux design,landing page,modern portfolio"/><meta name="referrer" content="no-referrer"/><meta name="robots" content="index,follow"/><meta property="og:title" content="[转]操作系统核心知识点 | 尼采般地抒情"/><meta property="og:description" content="本文转载自：5万字、97 张图总结操作系统核心知识点 - 程序员cxuan - 博客园部分内容自行添加这不是一篇教你如何创建一个操作系统的文章，相反，这是一篇指导性文章，教你从几个方面来理解操作系统。首先你需要知道你为什么要看这篇文章以及为什么要学习操作系统。搞清楚几个问题首先你要搞明白你学习..."/><meta property="og:image" content="https://cdn.nlark.com/yuque/0/2021/svg/1484158/1609726829272-e77b939e-eefd-4282-8f0a-68c97aa7dfe5.svg"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:title" content="尼采般地抒情"/><meta name="twitter:description" content="Explore my creative portfolio showcasing innovative projects, design work, and professional services. Built with Next.js and modern web technologies for an exceptional user experience."/><meta name="twitter:image" content="https://cdn.nlark.com/yuque/0/2021/svg/1484158/1609726829272-e77b939e-eefd-4282-8f0a-68c97aa7dfe5.svg"/><link rel="icon" href="/favicon/favicon-16x16.png" sizes="16x16" type="image/png"/><link rel="icon" href="/favicon/favicon-32x32.png" sizes="32x32" type="image/png"/><link rel="icon" href="/favicon/favicon.ico" sizes="48x48" type="image/x-icon"/><link rel="apple-touch-icon" href="/favicon/apple-touch-icon.png" sizes="180x180" type="image/png"/><link rel="icon" href="/favicon/android-chrome-192x192.png" sizes="192x192" type="image/png"/><link rel="icon" href="/favicon/android-chrome-512x512.png" sizes="512x512" type="image/png"/><script src="/_next/static/chunks/a6dad97d9634a72d.js" noModule=""></script></head><body class="relative flex min-h-full w-full flex-auto flex-col"><div hidden=""><!--$--><!--/$--></div><script>((a,b,c,d,e,f,g,h)=>{let i=document.documentElement,j=["light","dark"];function k(b){var c;(Array.isArray(a)?a:[a]).forEach(a=>{let c="class"===a,d=c&&f?e.map(a=>f[a]||a):e;c?(i.classList.remove(...d),i.classList.add(f&&f[b]?f[b]:b)):i.setAttribute(a,b)}),c=b,h&&j.includes(c)&&(i.style.colorScheme=c)}if(d)k(d);else try{let a=localStorage.getItem(b)||c,d=g&&"system"===a?window.matchMedia("(prefers-color-scheme: dark)").matches?"dark":"light":a;k(d)}catch(a){}})("class","theme","light",null,["light","dark"],null,false,true)</script><div class="flex flex-col"><header class="sticky top-0 z-50 h-16 w-full border-b transition-all duration-300" style="filter:blur(10px);opacity:0"><div class="mx-auto flex h-full max-w-6xl items-center justify-between gap-4 px-4 min-[1147px]:border-x sm:px-6 lg:px-8"><a class="flex items-center gap-3" href="/"><div class="flex items-center gap-3"><img src="/logo.png" alt="Logo" class="size-8.5"/><span class="text-primary text-[20px] font-semibold uppercase">尼采般地抒情</span></div></a><div class="flex gap-3"><nav aria-label="Main" data-orientation="horizontal" dir="ltr" data-slot="navigation-menu" data-viewport="false" class="group/navigation-menu relative max-w-max flex-1 items-center justify-center hidden min-[920px]:block grow [&amp;_[data-slot=&quot;navigation-menu-list&quot;]]:gap-1"><div style="position:relative"><ul data-orientation="horizontal" data-slot="navigation-menu-list" class="group flex flex-1 list-none items-center justify-center gap-1 gap-6!" dir="ltr"><li data-slot="navigation-menu-item" class="relative"><a data-active="false" data-slot="navigation-menu-link" class="data-[active=true]:focus:bg-accent data-[active=true]:hover:bg-accent data-[active=true]:bg-accent/50 data-[active=true]:text-accent-foreground [&amp;_svg:not([class*=&#x27;text-&#x27;])]:text-muted-foreground flex-col gap-1 p-2 [&amp;_svg:not([class*=&#x27;size-&#x27;])]:size-4 group bg-background hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground data-[state=open]:hover:bg-accent data-[state=open]:text-accent-foreground data-[state=open]:focus:bg-accent data-[state=open]:bg-accent/50 focus-visible:ring-ring/50 inline-flex h-9 w-max items-center justify-center rounded-md px-4 py-2 transition-[color,box-shadow] outline-none focus-visible:ring-[3px] focus-visible:outline-1 disabled:pointer-events-none disabled:opacity-50 text-muted-foreground data-[active=true]:text-primary! bg-transparent! p-0! text-base font-medium" data-radix-collection-item="" href="/blog">技术博客</a></li><li data-slot="navigation-menu-item" class="relative"><a data-active="false" data-slot="navigation-menu-link" class="data-[active=true]:focus:bg-accent data-[active=true]:hover:bg-accent data-[active=true]:bg-accent/50 data-[active=true]:text-accent-foreground [&amp;_svg:not([class*=&#x27;text-&#x27;])]:text-muted-foreground flex-col gap-1 p-2 [&amp;_svg:not([class*=&#x27;size-&#x27;])]:size-4 group bg-background hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground data-[state=open]:hover:bg-accent data-[state=open]:text-accent-foreground data-[state=open]:focus:bg-accent data-[state=open]:bg-accent/50 focus-visible:ring-ring/50 inline-flex h-9 w-max items-center justify-center rounded-md px-4 py-2 transition-[color,box-shadow] outline-none focus-visible:ring-[3px] focus-visible:outline-1 disabled:pointer-events-none disabled:opacity-50 text-muted-foreground data-[active=true]:text-primary! bg-transparent! p-0! text-base font-medium" data-radix-collection-item="" href="/essay">生活随笔</a></li><li data-slot="navigation-menu-item" class="relative"><a data-active="false" data-slot="navigation-menu-link" class="data-[active=true]:focus:bg-accent data-[active=true]:hover:bg-accent data-[active=true]:bg-accent/50 data-[active=true]:text-accent-foreground [&amp;_svg:not([class*=&#x27;text-&#x27;])]:text-muted-foreground flex-col gap-1 p-2 [&amp;_svg:not([class*=&#x27;size-&#x27;])]:size-4 group bg-background hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground data-[state=open]:hover:bg-accent data-[state=open]:text-accent-foreground data-[state=open]:focus:bg-accent data-[state=open]:bg-accent/50 focus-visible:ring-ring/50 inline-flex h-9 w-max items-center justify-center rounded-md px-4 py-2 transition-[color,box-shadow] outline-none focus-visible:ring-[3px] focus-visible:outline-1 disabled:pointer-events-none disabled:opacity-50 text-muted-foreground data-[active=true]:text-primary! bg-transparent! p-0! text-base font-medium" data-radix-collection-item="" href="/archives">归档</a></li><li data-slot="navigation-menu-item" class="relative"><a data-active="false" data-slot="navigation-menu-link" class="data-[active=true]:focus:bg-accent data-[active=true]:hover:bg-accent data-[active=true]:bg-accent/50 data-[active=true]:text-accent-foreground [&amp;_svg:not([class*=&#x27;text-&#x27;])]:text-muted-foreground flex-col gap-1 p-2 [&amp;_svg:not([class*=&#x27;size-&#x27;])]:size-4 group bg-background hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground data-[state=open]:hover:bg-accent data-[state=open]:text-accent-foreground data-[state=open]:focus:bg-accent data-[state=open]:bg-accent/50 focus-visible:ring-ring/50 inline-flex h-9 w-max items-center justify-center rounded-md px-4 py-2 transition-[color,box-shadow] outline-none focus-visible:ring-[3px] focus-visible:outline-1 disabled:pointer-events-none disabled:opacity-50 text-muted-foreground data-[active=true]:text-primary! bg-transparent! p-0! text-base font-medium" data-radix-collection-item="" href="/category">分类</a></li><li data-slot="navigation-menu-item" class="relative"><a data-active="false" data-slot="navigation-menu-link" class="data-[active=true]:focus:bg-accent data-[active=true]:hover:bg-accent data-[active=true]:bg-accent/50 data-[active=true]:text-accent-foreground [&amp;_svg:not([class*=&#x27;text-&#x27;])]:text-muted-foreground flex-col gap-1 p-2 [&amp;_svg:not([class*=&#x27;size-&#x27;])]:size-4 group bg-background hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground data-[state=open]:hover:bg-accent data-[state=open]:text-accent-foreground data-[state=open]:focus:bg-accent data-[state=open]:bg-accent/50 focus-visible:ring-ring/50 inline-flex h-9 w-max items-center justify-center rounded-md px-4 py-2 transition-[color,box-shadow] outline-none focus-visible:ring-[3px] focus-visible:outline-1 disabled:pointer-events-none disabled:opacity-50 text-muted-foreground data-[active=true]:text-primary! bg-transparent! p-0! text-base font-medium" data-radix-collection-item="" href="/friends">友链</a></li><li data-slot="navigation-menu-item" class="relative"><a data-active="false" data-slot="navigation-menu-link" class="data-[active=true]:focus:bg-accent data-[active=true]:hover:bg-accent data-[active=true]:bg-accent/50 data-[active=true]:text-accent-foreground [&amp;_svg:not([class*=&#x27;text-&#x27;])]:text-muted-foreground flex-col gap-1 p-2 [&amp;_svg:not([class*=&#x27;size-&#x27;])]:size-4 group bg-background hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground data-[state=open]:hover:bg-accent data-[state=open]:text-accent-foreground data-[state=open]:focus:bg-accent data-[state=open]:bg-accent/50 focus-visible:ring-ring/50 inline-flex h-9 w-max items-center justify-center rounded-md px-4 py-2 transition-[color,box-shadow] outline-none focus-visible:ring-[3px] focus-visible:outline-1 disabled:pointer-events-none disabled:opacity-50 text-muted-foreground data-[active=true]:text-primary! bg-transparent! p-0! text-base font-medium" data-radix-collection-item="" href="/message">留言</a></li><li data-slot="navigation-menu-item" class="relative"><a data-active="false" data-slot="navigation-menu-link" class="data-[active=true]:focus:bg-accent data-[active=true]:hover:bg-accent data-[active=true]:bg-accent/50 data-[active=true]:text-accent-foreground [&amp;_svg:not([class*=&#x27;text-&#x27;])]:text-muted-foreground flex-col gap-1 p-2 [&amp;_svg:not([class*=&#x27;size-&#x27;])]:size-4 group bg-background hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground data-[state=open]:hover:bg-accent data-[state=open]:text-accent-foreground data-[state=open]:focus:bg-accent data-[state=open]:bg-accent/50 focus-visible:ring-ring/50 inline-flex h-9 w-max items-center justify-center rounded-md px-4 py-2 transition-[color,box-shadow] outline-none focus-visible:ring-[3px] focus-visible:outline-1 disabled:pointer-events-none disabled:opacity-50 text-muted-foreground data-[active=true]:text-primary! bg-transparent! p-0! text-base font-medium" data-radix-collection-item="" href="/about">关于</a></li></ul></div></nav><button data-slot="button" data-variant="outline" data-size="icon" class="focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive inline-flex shrink-0 items-center justify-center gap-2 text-sm font-medium whitespace-nowrap transition-all outline-none focus-visible:ring-[3px] disabled:pointer-events-none disabled:opacity-50 [&amp;_svg]:pointer-events-none [&amp;_svg]:shrink-0 [&amp;_svg:not([class*=&#x27;size-&#x27;])]:size-4 bg-background hover:bg-accent hover:text-accent-foreground dark:bg-input/30 dark:border-input dark:hover:bg-input/50 border shadow-xs size-9 relative rounded-full"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-moon-star scale-100 dark:scale-0" aria-hidden="true"><path d="M18 5h4"></path><path d="M20 3v4"></path><path d="M20.985 12.486a9 9 0 1 1-9.473-9.472c.405-.022.617.46.402.803a6 6 0 0 0 8.268 8.268c.344-.215.825-.004.803.401"></path></svg><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-sun absolute scale-0 dark:scale-100" aria-hidden="true"><circle cx="12" cy="12" r="4"></circle><path d="M12 2v2"></path><path d="M12 20v2"></path><path d="m4.93 4.93 1.41 1.41"></path><path d="m17.66 17.66 1.41 1.41"></path><path d="M2 12h2"></path><path d="M20 12h2"></path><path d="m6.34 17.66-1.41 1.41"></path><path d="m19.07 4.93-1.41 1.41"></path></svg><span class="sr-only">Toggle theme</span></button><a data-slot="button" data-variant="outline" data-size="default" class="focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive inline-flex shrink-0 items-center justify-center gap-2 text-sm font-medium whitespace-nowrap transition-all outline-none focus-visible:ring-[3px] disabled:pointer-events-none disabled:opacity-50 [&amp;_svg]:pointer-events-none [&amp;_svg]:shrink-0 [&amp;_svg:not([class*=&#x27;size-&#x27;])]:size-4 bg-background hover:bg-accent hover:text-accent-foreground dark:bg-input/30 dark:border-input dark:hover:bg-input/50 border shadow-xs h-9 px-4 py-2 has-[&gt;svg]:px-3 rounded-full px-4! max-sm:hidden" href="/contact-me">联系我 <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-message-square-more" aria-hidden="true"><path d="M22 17a2 2 0 0 1-2 2H6.828a2 2 0 0 0-1.414.586l-2.202 2.202A.71.71 0 0 1 2 21.286V5a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2z"></path><path d="M12 11h.01"></path><path d="M16 11h.01"></path><path d="M8 11h.01"></path></svg></a><a data-slot="tooltip-trigger" data-variant="outline" data-size="icon" class="focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive inline-flex shrink-0 items-center justify-center gap-2 text-sm font-medium whitespace-nowrap transition-all outline-none focus-visible:ring-[3px] disabled:pointer-events-none disabled:opacity-50 [&amp;_svg]:pointer-events-none [&amp;_svg]:shrink-0 [&amp;_svg:not([class*=&#x27;size-&#x27;])]:size-4 bg-background hover:bg-accent hover:text-accent-foreground dark:bg-input/30 dark:border-input dark:hover:bg-input/50 border shadow-xs size-9 rounded-full px-4! sm:hidden" data-state="closed" href="/contact-me"><span class="sr-only">联系我</span><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-message-square-more" aria-hidden="true"><path d="M22 17a2 2 0 0 1-2 2H6.828a2 2 0 0 0-1.414.586l-2.202 2.202A.71.71 0 0 1 2 21.286V5a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2z"></path><path d="M12 11h.01"></path><path d="M16 11h.01"></path><path d="M8 11h.01"></path></svg></a><button data-slot="sheet-trigger" data-variant="default" data-size="icon" class="focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive shrink-0 items-center justify-center gap-2 text-sm font-medium whitespace-nowrap transition-all outline-none focus-visible:ring-[3px] disabled:pointer-events-none disabled:opacity-50 [&amp;_svg]:pointer-events-none [&amp;_svg]:shrink-0 [&amp;_svg:not([class*=&#x27;size-&#x27;])]:size-4 bg-primary text-primary-foreground hover:bg-primary/90 size-9 inline-flex rounded-full min-[920px]:hidden" data-state="closed" type="button" aria-haspopup="dialog" aria-expanded="false" aria-controls="radix-_R_5lmbtb_"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-menu" aria-hidden="true"><path d="M4 5h16"></path><path d="M4 12h16"></path><path d="M4 19h16"></path></svg><span class="sr-only">Menu</span></button></div></div></header><main class="relative flex flex-col overflow-x-clip *:scroll-mt-15.5"><section class="relative"><div class="relative overflow-hidden border-y xl:flex" style="filter:blur(10px);opacity:0"><div class="m-6 w-full flex-1 bg-[radial-gradient(circle_at_center,color-mix(in_oklab,var(--primary)_15%,transparent)_2px,transparent_2px)] bg-size-[18px_18px] max-xl:hidden"></div><div class="mx-auto w-full max-w-6xl flex-none space-y-8 px-4 py-8 min-[1158px]:border-x sm:px-6 sm:py-12 lg:px-8"><div style="filter:blur(10px);opacity:0;transform:translateY(30px)"><a class="text-muted-foreground hover:text-foreground inline-flex items-center gap-2 text-sm transition-colors" href="/blog"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-arrow-left h-4 w-4" aria-hidden="true"><path d="m12 19-7-7 7-7"></path><path d="M19 12H5"></path></svg>返回<!-- -->技术博客</a></div><article class="mx-auto max-w-4xl"><header class="mb-8 space-y-6"><div style="filter:blur(10px);opacity:0;transform:translateY(-50px)"><div class="relative aspect-video overflow-hidden rounded-xl"><img alt="[转]操作系统核心知识点" loading="lazy" decoding="async" data-nimg="fill" class="object-cover" style="position:absolute;height:100%;width:100%;left:0;top:0;right:0;bottom:0;color:transparent" src="https://cdn.nlark.com/yuque/0/2021/svg/1484158/1609726829272-e77b939e-eefd-4282-8f0a-68c97aa7dfe5.svg"/></div></div><div><h1 class="text-2xl font-bold tracking-tight sm:text-3xl md:text-4xl"><p class="blur-text flex flex-wrap"><span style="display:inline-block;will-change:transform, filter, opacity;filter:blur(10px);opacity:0;transform:translateY(50px)">[转]操作系统核心知识点</span></p></h1></div><div style="filter:blur(10px);opacity:0;transform:translateY(30px)"><p class="text-muted-foreground text-lg">本文转载自：5万字、97 张图总结操作系统核心知识点 - 程序员cxuan - 博客园部分内容自行添加这不是一篇教你如何创建一个操作系统的文章，相反，这是一篇指导性文章，教你从几个方面来理解操作系统。首先你需要知道你为什么要看这篇文章以及为什么要学习操作系统。搞清楚几个问题首先你要搞明白你学习...</p></div><div style="filter:blur(10px);opacity:0;transform:translateY(30px)"><div class="text-muted-foreground flex flex-wrap items-center gap-4 text-sm"><div class="flex items-center gap-1"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-calendar h-4 w-4" aria-hidden="true"><path d="M8 2v4"></path><path d="M16 2v4"></path><rect width="18" height="18" x="3" y="4" rx="2"></rect><path d="M3 10h18"></path></svg><span>2020年8月29日</span></div><div class="flex items-center gap-1"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-clock h-4 w-4" aria-hidden="true"><path d="M12 6v6l4 2"></path><circle cx="12" cy="12" r="10"></circle></svg><span>4.5万字</span></div><div class="flex items-center gap-1"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-eye h-4 w-4" aria-hidden="true"><path d="M2.062 12.348a1 1 0 0 1 0-.696 10.75 10.75 0 0 1 19.876 0 1 1 0 0 1 0 .696 10.75 10.75 0 0 1-19.876 0"></path><circle cx="12" cy="12" r="3"></circle></svg><span>16<!-- --> 阅读</span></div></div></div></header><div class="-mx-4 sm:-mx-6 lg:-mx-8" style="filter:blur(10px);opacity:0"><div data-orientation="horizontal" role="none" data-slot="separator" class="bg-border shrink-0 data-[orientation=horizontal]:h-px data-[orientation=horizontal]:w-full data-[orientation=vertical]:h-full data-[orientation=vertical]:w-px"></div></div><div style="filter:blur(10px);opacity:0;transform:translateY(-50px)"><div class="prose prose-neutral dark:prose-invert mt-8 max-w-none"><!doctype html><div class="lake-content" typography="classic"><div class="ne-quote"><ul class="ne-ul"><li id="78c70b8dd6e7969e68cc2270cf0b875c"><span class="ne-text">本文转载自：</span><a href="https://www.cnblogs.com/cxuanBlog/p/13297199.html" data-href="https://www.cnblogs.com/cxuanBlog/p/13297199.html" target="_blank" class="ne-link"><span class="ne-text">5万字、97 张图总结操作系统核心知识点 - 程序员cxuan - 博客园</span></a></li></ul></div><div class="ne-quote"><ul class="ne-ul"><li id="f1f3650356a7da2355a3c9411b72ce03"><span class="ne-text">部分内容自行添加</span></li></ul></div><p id="e09cae7512bb1e7e65e0b987a5ca3c8a" class="ne-p"><br></p><p id="931bb607447da06d6f3bed0cd017ed4c" class="ne-p"><span class="ne-text">这不是一篇教你如何创建一个操作系统的文章，相反，这是一篇指导性文章，教你从几个方面来理解操作系统。首先你需要知道你为什么要看这篇文章以及为什么要学习操作系统。</span></p><h2 id="61749910"><span class="ne-text">搞清楚几个问题</span></h2><p id="cd8943ed3bdff3713c416af18dcb5bc9" class="ne-p"><br></p><p id="25252fec79848d7bbc0a038fde638496" class="ne-p"><span class="ne-text">首先你要搞明白你学习操作系统的目的是什么？操作系统的重要性如何？学习操作系统会给我带来什么？下面我会从这几个方面为你回答下。</span></p><p id="8b7d10816f8e53284531845daf551ca3" class="ne-p"><br></p><p id="e6f1da87c780159f3f7de45053402efa" class="ne-p"><span class="ne-text">操作系统也是一种软件，但是操作系统是一种非常复杂的软件。操作系统提供了几种抽象模型</span></p><p id="8c1a07ee6be4f495dd752ea6d4f3b020" class="ne-p"><br></p><ul class="ne-ul"><li id="217f42e4058efed81e8bad4607e4acfd"><span class="ne-text">文件：对 I/O 设备的抽象</span></li><li id="22715eb1c834fc55bf11ecf2484d0865"><span class="ne-text">虚拟内存：对程序存储器的抽象</span></li></ul><ul class="ne-ul"><li id="205178dc0bcb920fd8c85c7c3b010b77"><span class="ne-text">进程：对一个正在运行程序的抽象</span></li><li id="d622cbce3a4c328a2322c48ec279ab56"><span class="ne-text">虚拟机：对整个操作系统的抽象</span></li></ul><p id="657df5130cb382aef2c3c6c91108272c" class="ne-p"><br></p><p id="e59e93c8b78c17b38240227d505e21cc" class="ne-p"><span class="ne-text">这些抽象和我们的日常开发息息相关。搞清楚了操作系统是如何抽象的，才能培养我们的抽象性思维和开发思路。</span></p><p id="49e331b04cc221ab606f3858c8793691" class="ne-p"><br></p><p id="a96f950d10e2e4820afcebed6cf4e11a" class="ne-p"><span class="ne-text">很多问题都和操作系统相关，操作系统是解决这些问题的基础。如果你不学习操作系统，可能会想着从框架层面来解决，那是你了解的还不够深入，当你学习了操作系统后，能够培养你的全局性思维。</span></p><p id="ce485e2ee746cb7a676b02e43c98539b" class="ne-p"><br></p><p id="ec2f957b8d14b5f67e2d5112d8c194f2" class="ne-p"><span class="ne-text">学习操作系统我们能够有效的解决</span><code class="ne-code"><span class="ne-text">并发</span></code><span class="ne-text">问题，并发几乎是互联网的重中之重了，这也从侧面说明了学习操作系统的重要性。</span></p><p id="b149befad325016fc7e10b44f43be20d" class="ne-p"><br></p><p id="30f71f05e85cb30d12e23064ca8a482b" class="ne-p"><span class="ne-text">学习操作系统的重点不是让你从头制造一个操作系统，而是告诉你</span><strong><span class="ne-text">操作系统是如何工作的</span></strong><span class="ne-text">，能够让你对计算机底层有所了解，打实你的基础。</span></p><p id="08806088071147ea10f99421320d32a2" class="ne-p"><br></p><p id="58b941ab309d9181cde3a97a32dc6d0f" class="ne-p"><span class="ne-text">相信你一定清楚什么是编程</span></p><p id="f44e3319e6f321d74f1c7f6d708cc27b" class="ne-p"><br></p><p id="ce7a48bbdff10a0f0748d43a4fee9e90" class="ne-p"><strong><span class="ne-text">Data structures + Algorithms = Programming</span></strong></p><p id="175f4024cc2c962517efb5997682de75" class="ne-p"><br></p><p id="f80de5c67c6431f2afbd24dbb2aee176" class="ne-p"><span class="ne-text">操作系统内部会涉及到众多的数据结构和算法描述，能够让你了解算法的基础上，让你编写更优秀的程序。</span></p><p id="5986e2d6bb54fb966e95673f071c0621" class="ne-p"><br></p><p id="0ed49e5e0331cad434e0b8915d4b5cdc" class="ne-p"><span class="ne-text">我认为可以把计算机比作一栋楼</span></p><p id="8c2a4868810afe3b9525b76e29ed5d78" class="ne-p"><br></p><p id="1988bafa6f22a0fcc069c82a692373b7" class="ne-p"><span class="ne-text">计算机的底层相当于就是楼的根基，计算机应用相当于就是楼的外形，而操作系统就相当于是告诉你大楼的构造原理，编写高质量的软件就相当于是告诉你构建一个稳定的房子。</span></p><p id="7014f45e7cc9e806853372bde37b2cfd" class="ne-p"><br></p><h2 id="5e0a7a49"><span class="ne-text">认识操作系统</span></h2><p id="60374c1e79cb4d4843a09fd94637d612" class="ne-p"><br></p><p id="e93269cf41ced53553d81ffb79f9eb8d" class="ne-p"><span class="ne-text">在了解操作系统前，你需要先知道一下什么是计算机系统：现代计算机系统由</span><strong><span class="ne-text">一个或多个处理器、主存、打印机、键盘、鼠标、显示器、网络接口以及各种输入/输出设备构成的系统</span></strong><span class="ne-text">。这些都属于</span><code class="ne-code"><span class="ne-text">硬件</span></code><span class="ne-text">的范畴。我们程序员不会直接和这些硬件打交道，并且每位程序员不可能会掌握所有计算机系统的细节。</span></p><p id="65640a6ae74714a11395c1618a7fc89d" class="ne-p"><br></p><p id="3b4307743edbac97da76c836b32da301" class="ne-p"><span class="ne-text">所以计算机科学家在硬件的基础之上，安装了一层软件，这层软件能够根据用户输入的指令达到控制硬件的效果，从而满足用户的需求，这样的软件称为 </span><code class="ne-code"><span class="ne-text">操作系统</span></code><span class="ne-text">，它的任务就是为用户程序提供一个更好、更简单、更清晰的计算机模型。也就是说，操作系统相当于是一个中间层，为用户层和硬件提供各自的借口，屏蔽了不同应用和硬件之间的差异，达到统一标准的作用。</span></p><p id="fd9511ee26ef4adfd5ce0d2019b4f14e" class="ne-p"><br></p><p id="17ca944a6947bc0c3d6a5de1a9445a06" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829342-133c5955-ce6b-4c7a-9b0e-74e4a24c0f14.png" width="698" id="ahwEU" class="ne-image"></p><p id="6b6913492663205e0e2997de2b4a2e49" class="ne-p"><br></p><p id="f876d76748832add56dda94beed6921e" class="ne-p"><span class="ne-text">上面一个操作系统的简化图，最底层是硬件，硬件包括</span><strong><span class="ne-text">芯片、电路板、磁盘、键盘、显示器</span></strong><span class="ne-text">等我们上面提到的设备，在硬件之上是软件。大部分计算机有两种运行模式：</span><code class="ne-code"><span class="ne-text">内核态</span></code><span class="ne-text"> 和 </span><code class="ne-code"><span class="ne-text">用户态</span></code><span class="ne-text">，软件中最基础的部分是</span><code class="ne-code"><span class="ne-text">操作系统</span></code><span class="ne-text">，它运行在 </span><code class="ne-code"><span class="ne-text">内核态</span></code><span class="ne-text"> 中。操作系统具有硬件的访问权，可以执行机器能够运行的任何指令。软件的其余部分运行在 </span><code class="ne-code"><span class="ne-text">用户态</span></code><span class="ne-text"> 下。</span></p><p id="ebbba497f9d6ba190aa46822d3e0cc7a" class="ne-p"><br></p><p id="d02cfd23d8b7a7af003461286a9cda5e" class="ne-p"><span class="ne-text">在大概了解到操作系统之后，我们先来认识一下硬件都有哪些</span></p><p id="05876b94be1f5d0bd06294890520ce08" class="ne-p"><br></p><h2 id="7f56845d"><span class="ne-text">计算机硬件</span></h2><p id="cce8b5dc91c592c0a00cafe91abb32e9" class="ne-p"><br></p><p id="01ff293d3d3a521947f1a8dd38dcb947" class="ne-p"><span class="ne-text">计算机硬件是计算机的重要组成部分，其中包含了 5 个重要的组成部分：</span><strong><span class="ne-text">运算器、控制器、存储器、输入设备、输出设备</span></strong><span class="ne-text">。</span></p><p id="47deb5600e522c817edbe7abbee25e00" class="ne-p"><br></p><ul class="ne-ul"><li id="23c0ff48cfcf83bd619a8d1744e4fb5c"><code class="ne-code"><span class="ne-text">运算器</span></code><span class="ne-text">：运算器最主要的功能是对数据和信息进行加工和运算。它是计算机中执行算数和各种逻辑运算的部件。运算器的基本运算包括加、减、乘、除、移位等操作，这些是由 </span><code class="ne-code"><span class="ne-text">算术逻辑单元(Arithmetic&amp;logical Unit)</span></code><span class="ne-text"> 实现的。而运算器主要由算数逻辑单元和寄存器构成。</span></li><li id="fbc8179c7d070a8101707bce37bcf93c"><code class="ne-code"><span class="ne-text">控制器</span></code><span class="ne-text">：指按照指定顺序改变主电路或控制电路的部件，它主要起到了控制命令执行的作用，完成协调和指挥整个计算机系统的操作。控制器是由程序计数器、指令寄存器、解码译码器等构成。</span></li></ul><p id="e2a465bc1d98db155979301524d750b7" class="ne-p"><br></p><div class="ne-quote"><p id="68e4847b9cac4d5690f4fe3ddad81505" class="ne-p"><span class="ne-text">运算器和控制器共同组成了 CPU</span></p></div><p id="f40393f314f00082df3f5dac5390d54d" class="ne-p"><br></p><ul class="ne-ul"><li id="d14c467ef32e45959a85f7540068eec0"><code class="ne-code"><span class="ne-text">存储器</span></code><span class="ne-text">：存储器就是计算机的</span><code class="ne-code"><span class="ne-text">记忆设备</span></code><span class="ne-text">，顾名思义，存储器可以保存信息。存储器分为两种，一种是主存，也就是内存，它是 CPU 主要交互对象，还有一种是外存，比如硬盘软盘等。下面是现代计算机系统的存储架构</span></li><li id="0109b65dcc8a312766f7aff0577f9186"><code class="ne-code"><span class="ne-text">输入设备</span></code><span class="ne-text">：输入设备是给计算机获取外部信息的设备，它主要包括键盘和鼠标。</span></li></ul><ul class="ne-ul"><li id="9c9570d30438ade57fc34f62ed6f8d37"><code class="ne-code"><span class="ne-text">输出设备</span></code><span class="ne-text">：输出设备是给用户呈现根据输入设备获取的信息经过一系列的计算后得到显示的设备，它主要包括显示器、打印机等。</span></li></ul><p id="1dce3c1a02c140ec91fee67be8e36769" class="ne-p"><br></p><p id="835a282fa628ddcb34e19f76a5ef697a" class="ne-p"><span class="ne-text">这五部分也是冯诺伊曼的体系结构，它认为计算机必须具有如下功能：</span></p><p id="ad40a6a3aaf0578f66a2c4e20a5720ea" class="ne-p"><br></p><p id="2bbfd0566e38489f15096e54e9a0a614" class="ne-p"><span class="ne-text">把需要的程序和数据送至计算机中。必须具有长期记忆程序、数据、中间结果及最终运算结果的能力。能够完成各种算术、逻辑运算和数据传送等数据加工处理的能力。能够根据需要控制程序走向，并能根据指令控制机器的各部件协调操作。能够按照要求将处理结果输出给用户。</span></p><p id="e1452348578beeb6a16c16494dc88fe4" class="ne-p"><br></p><p id="02f40d52bf1660ca14fc7d9e3ef3826c" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829342-9ed0fc8c-06fb-431d-8db6-2caaca0abc0f.png" width="721" id="qMDVd" class="ne-image"></p><p id="800c9b83462be50fcb8a3f3cdd6e3b94" class="ne-p"><br></p><p id="c4403308930ab6ac5ceca26c06a272c8" class="ne-p"><span class="ne-text">下面是一张 intel 家族产品图，是一个详细的计算机硬件分类，我们在根据图中涉及到硬件进行介绍</span></p><p id="5b37e26e7636153b562b485458fc5ef1" class="ne-p"><br></p><p id="e0fb51cbe771fc7ec497266795295f0e" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829351-810b3b3e-2849-45d3-96c8-62280633f4a6.png" width="747" id="ZSJw7" class="ne-image"></p><p id="48dffd0496d4e7ac46311057c1da3964" class="ne-p"><br></p><ul class="ne-ul"><li id="4edfeb0a52189d8edd1c42763577ee9e"><code class="ne-code"><span class="ne-text">总线(Buses)</span></code><span class="ne-text">：在整个系统中运行的是称为总线的电气管道的集合，这些总线在组件之间来回传输字节信息。通常总线被设计成传送定长的字节块，也就是 </span><code class="ne-code"><span class="ne-text">字(word)</span></code><span class="ne-text">。字中的字节数（字长）是一个基本的系统参数，各个系统中都不尽相同。现在大部分的字都是 4 个字节（32 位）或者 8 个字节（64 位）。</span></li></ul><p id="8722f36b77845d4b9ad537bf6958cb52" class="ne-p"><br></p><p id="c153395442fe97613ef51a62e92903b8" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829372-677cad04-111e-4904-a865-109bf7e95c9c.png" width="731" id="GR4Q2" class="ne-image"></p><p id="56abdc5d1e5b29b2c23b1d995808d341" class="ne-p"><br></p><ul class="ne-ul"><li id="314397e76b319606a6f50e9bc4e4d686"><code class="ne-code"><span class="ne-text">I/O 设备(I/O Devices)</span></code><span class="ne-text">：Input/Output 设备是系统和外部世界的连接。上图中有四类 I/O 设备：用于用户输入的键盘和鼠标，用于用户输出的显示器，一个磁盘驱动用来长时间的保存数据和程序。刚开始的时候，可执行程序就保存在磁盘上。<br /></span><span class="ne-text">每个I/O 设备连接 I/O 总线都被称为</span><code class="ne-code"><span class="ne-text">控制器(controller)</span></code><span class="ne-text"> 或者是 </span><code class="ne-code"><span class="ne-text">适配器(Adapter)</span></code><span class="ne-text">。控制器和适配器之间的主要区别在于封装方式。控制器是 I/O 设备本身或者系统的主印制板电路（通常称作主板）上的芯片组。而适配器则是一块插在主板插槽上的卡。无论组织形式如何，它们的最终目的都是彼此交换信息。</span></li><li id="5ed03e7dde30479bc8253a8f0657526c"><code class="ne-code"><span class="ne-text">主存(Main Memory)</span></code><span class="ne-text">，主存是一个</span><code class="ne-code"><span class="ne-text">临时存储设备</span></code><span class="ne-text">，而不是永久性存储，磁盘是 </span><code class="ne-code"><span class="ne-text">永久性存储</span></code><span class="ne-text"> 的设备。主存既保存程序，又保存处理器执行流程所处理的数据。从物理组成上说，主存是由一系列 </span><code class="ne-code"><span class="ne-text">DRAM(dynamic random access memory)</span></code><span class="ne-text"> 动态随机存储构成的集合。逻辑上说，内存就是一个线性的字节数组，有它唯一的地址编号，从 0 开始。一般来说，组成程序的每条机器指令都由不同数量的字节构成，C 程序变量相对应的数据项的大小根据类型进行变化。比如，在 Linux 的 x86-64 机器上，short 类型的数据需要 2 个字节，int 和 float 需要 4 个字节，而 long 和 double 需要 8 个字节。</span></li></ul><ul class="ne-ul"><li id="78a508a67b0570af15a3f2a6cd9321a0"><code class="ne-code"><span class="ne-text">处理器(Processor)</span></code><span class="ne-text">，</span><code class="ne-code"><span class="ne-text">CPU(central processing unit)</span></code><span class="ne-text"> 或者简单的处理器，是解释（并执行）存储在主存储器中的指令的引擎。处理器的核心大小为一个字的存储设备（或寄存器），称为</span><code class="ne-code"><span class="ne-text">程序计数器(PC)</span></code><span class="ne-text">。在任何时刻，PC 都指向主存中的某条机器语言指令（即含有该条指令的地址）。<br /></span><span class="ne-text">从系统通电开始，直到系统断电，处理器一直在不断地执行程序计数器指向的指令，再更新程序计数器，使其指向下一条指令。处理器根据其指令集体系结构定义的指令模型进行操作。在这个模型中，指令按照严格的顺序执行，执行一条指令涉及执行一系列的步骤。处理器从程序计数器指向的内存中读取指令，解释指令中的位，执行该指令指示的一些简单操作，然后更新程序计数器以指向下一条指令。指令与指令之间可能连续，可能不连续（比如 jmp 指令就不会顺序读取）</span></li></ul><p id="3a4a2a641d1a1c2de5ad66377fca1a30" class="ne-p"><br></p><p id="954dbf0f9e583d9fe45125eabf87296d" class="ne-p"><span class="ne-text">下面是 CPU 可能执行简单操作的几个步骤</span></p><p id="0e7c003044e5b5185d07ad8a3a2b10dc" class="ne-p"><br></p><ul class="ne-ul"><li id="62092432619e0a8617a85dc65506af1f"><code class="ne-code"><span class="ne-text">加载(Load)</span></code><span class="ne-text">：从主存中拷贝一个字节或者一个字到内存中，覆盖寄存器先前的内容</span></li><li id="d70e3efbed128cede95336b4ab29b2c8"><code class="ne-code"><span class="ne-text">存储(Store)</span></code><span class="ne-text">：将寄存器中的字节或字复制到主存储器中的某个位置，从而覆盖该位置的先前内容</span></li></ul><ul class="ne-ul"><li id="34ef14e8474868fc664a6a7a93da783c"><code class="ne-code"><span class="ne-text">操作(Operate)</span></code><span class="ne-text">：把两个寄存器的内容复制到 </span><code class="ne-code"><span class="ne-text">ALU(Arithmetic logic unit)</span></code><span class="ne-text"> 。把两个字进行算术运算，并把结果存储在寄存器中，重写寄存器先前的内容。</span></li></ul><p id="b0921cf26e6a7ca068ba0fe5f7503a34" class="ne-p"><br></p><div class="ne-quote"><p id="24027a2585b5d271d4a70016b7d63879" class="ne-p"><span class="ne-text">算术逻辑单元（ALU）是对数字二进制数执行算术和按位运算的组合数字电子电路。</span></p></div><p id="8875ee2f15790a01020ed498f5331bbf" class="ne-p"><br></p><ul class="ne-ul"><li id="04e09f85f3b9c8a6b2b2cb9643a334b0"><code class="ne-code"><span class="ne-text">跳转(jump)</span></code><span class="ne-text">：从指令中抽取一个字，把这个字复制到</span><code class="ne-code"><span class="ne-text">程序计数器(PC)</span></code><span class="ne-text"> 中，覆盖原来的值</span></li></ul><p id="40564caba44243a15803ea8ea3df1185" class="ne-p"><br></p><h2 id="e5b00e3a"><span class="ne-text">进程和线程</span></h2><p id="89e59462cf5e42126bf7fd69ec455e43" class="ne-p"><br></p><p id="279db931dc6baec0f7e3d4b21b009845" class="ne-p"><span class="ne-text">关于进程和线程，你需要理解下面这张脑图中的重点</span></p><p id="cd6805c2765d2ea297065d329755927f" class="ne-p"><br></p><p id="1d9db861bcf8b6d42bd30feae4ef59ef" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829389-4c3de174-e023-4600-b910-b01112bd2f4c.png" width="734" id="tvXh9" class="ne-image"></p><p id="7b1432c8b72204ee4b825e861b12f98e" class="ne-p"><br></p><h2 id="f88522cf"><span class="ne-text">进程</span></h2><p id="558402d93b3b4cb15182048bf1d22ac0" class="ne-p"><br></p><p id="0989e50fff0d7132d77a4dc9d000527a" class="ne-p"><span class="ne-text">操作系统中最核心的概念就是 </span><code class="ne-code"><span class="ne-text">进程</span></code><span class="ne-text">，进程是对正在运行中的程序的一个抽象。操作系统的其他所有内容都是围绕着进程展开的。</span></p><p id="9858e22f7b813dbde0def60216102845" class="ne-p"><br></p><p id="c6c622877f50d6ecedc29825038afaef" class="ne-p"><span class="ne-text">在多道程序处理的系统中，CPU 会在</span><code class="ne-code"><span class="ne-text">进程</span></code><span class="ne-text">间快速切换，使每个程序运行几十或者几百毫秒。然而，严格意义来说，在某一个瞬间，CPU 只能运行一个进程，然而我们如果把时间定位为 1 秒内的话，它可能运行多个进程。这样就会让我们产生</span><code class="ne-code"><span class="ne-text">并行</span></code><span class="ne-text">的错觉。因为 CPU 执行速度很快，进程间的换进换出也非常迅速，因此我们很难对多个并行进程进行跟踪。所以，操作系统的设计者开发了用于描述并行的一种概念模型（顺序进程），使得并行更加容易理解和分析。</span></p><p id="7ebadc22ea804dc3ce1f6cb4f1faa79a" class="ne-p"><br></p><h3 id="db1832c3"><span class="ne-text">进程模型</span></h3><p id="d840b450465be09e434df4a3dd9a3f21" class="ne-p"><br></p><p id="0f48d95b096b20bbe4d780741e4b7c54" class="ne-p"><span class="ne-text">一个进程就是一个正在执行的程序的实例，进程也包括程序计数器、寄存器和变量的当前值。从概念上来说，每个进程都有各自的虚拟 CPU，但是实际情况是 CPU 会在各个进程之间进行来回切换。</span></p><p id="864056155c24e8395f096ca45cc118d3" class="ne-p"><br></p><p id="89fb82994d781ae23159ddf581f8535e" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829609-9880b940-5163-45d4-8ef6-b559ab53b55d.png" width="455" id="XCIWa" class="ne-image"></p><p id="503dfc349a03926ac40238c181049013" class="ne-p"><br></p><p id="e44e9da7ec98c3c4fe1fdbf7978527ea" class="ne-p"><span class="ne-text">如上图所示，这是一个具有 4 个程序的多道处理程序，在进程不断切换的过程中，程序计数器也在不同的变化。</span></p><p id="8b5b1883046bf13d25c14fb35e4516bb" class="ne-p"><br></p><p id="bbcf34ef348ae4a397c45691442445a7" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829415-2d4059be-d447-4abf-8e77-2df51d6cc6a1.png" width="647" id="CNsvU" class="ne-image"></p><p id="13790759d024503953e9acbb6b0b7ab3" class="ne-p"><br></p><p id="1df3a5508dff94ecadd151924567d3b5" class="ne-p"><span class="ne-text">在上图中，这 4 道程序被抽象为 4 个拥有各自控制流程（即每个自己的程序计数器）的进程，并且每个程序都独立的运行。当然，实际上只有一个物理程序计数器，每个程序要运行时，其逻辑程序计数器会装载到物理程序计数器中。当程序运行结束后，其物理程序计数器就会是真正的程序计数器，然后再把它放回进程的逻辑计数器中。</span></p><p id="ee92f5f090955049ed874d170f8164cb" class="ne-p"><br></p><p id="01f2e5a8184ecf5d05233123e72d116d" class="ne-p"><span class="ne-text">从下图我们可以看到，在观察足够长的一段时间后，所有的进程都运行了，</span><strong><span class="ne-text">但在任何一个给定的瞬间仅有一个进程真正运行</span></strong><span class="ne-text">。</span></p><p id="d183af70e6d683798bd87e78de114558" class="ne-p"><br></p><p id="c50a4b4a34d3cd79990b212d4fbfc543" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829611-a49b5e88-0d0e-42c3-a103-485b6e5c984b.png" width="578" id="Zm8OZ" class="ne-image"></p><p id="77943fe667db14d2a7a7af237a686d74" class="ne-p"><br></p><p id="04d2c0652dedc050608799739b401859" class="ne-p"><span class="ne-text">因此，当我们说一个 CPU 只能真正一次运行一个进程的时候，即使有 2 个核（或 CPU），</span><strong><span class="ne-text">每一个核也只能一次运行一个线程</span></strong><span class="ne-text">。</span></p><p id="5f3805e43ab58c9f9b1421c309983a93" class="ne-p"><br></p><p id="caa82774fc8116b9bb58bada934ea47c" class="ne-p"><span class="ne-text">由于 CPU 会在各个进程之间来回快速切换，所以每个进程在 CPU 中的运行时间是无法确定的。并且当同一个进程再次在 CPU 中运行时，其在 CPU 内部的运行时间往往也是不固定的。</span></p><p id="3833fb1e45d8a553449ff36ab59e4177" class="ne-p"><br></p><p id="802684c9e995650755383da022afcbb1" class="ne-p"><span class="ne-text">这里的关键思想是</span><code class="ne-code"><span class="ne-text">认识到一个进程所需的条件</span></code><span class="ne-text">，进程是某一类特定活动的总和，它有程序、输入输出以及状态。</span></p><p id="2d8841ff912ecc1480e38c0ace860c22" class="ne-p"><br></p><h3 id="ef174e29"><span class="ne-text">进程的创建</span></h3><p id="b69f4a48539edd2c438341715747400d" class="ne-p"><br></p><p id="34e9aef6755ca9dc3103ca25f2c1b94c" class="ne-p"><span class="ne-text">操作系统需要一些方式来创建进程。下面是一些创建进程的方式</span></p><p id="7f056f7e3d9ba5170e3d973201d6e577" class="ne-p"><br></p><ul class="ne-ul"><li id="5525a064edc2a71505894af900e9ae6d"><span class="ne-text">系统初始化（init）：启动操作系统时，通常会创建若干个进程。</span></li><li id="655f909b3a436f6c5d0b2f6ce577f1eb"><span class="ne-text">正在运行的程序执行了创建进程的系统调用（比如 fork）</span></li></ul><ul class="ne-ul"><li id="15f97be6f701a9d2e285ce067dcaa4f5"><span class="ne-text">用户请求创建一个新进程：在许多交互式系统中，输入一个命令或者双击图标就可以启动程序，以上任意一种操作都可以选择开启一个新的进程，在基本的 UNIX 系统中运行 X，新进程将接管启动它的窗口。</span></li><li id="9cbc72a5195fe8f27a433e2cf1537410"><span class="ne-text">初始化一个批处理工作</span></li></ul><p id="734b1131d138309cb8f6e8751b24b0ca" class="ne-p"><br></p><p id="36bcfdf4e40be363d8ec64c87f794ea4" class="ne-p"><span class="ne-text">从技术上讲，在所有这些情况下，让现有流程执行流程是通过创建系统调用来创建新流程的。该进程可能是正在运行的用户进程，是从键盘或鼠标调用的系统进程或批处理程序。这些就是系统调用创建新进程的过程。该系统调用告诉操作系统创建一个新进程，并直接或间接指示在其中运行哪个程序。</span></p><p id="e244fe98d07fe53d8b8b074500bbdbf0" class="ne-p"><br></p><p id="90057922d3b14889ff144902ccb57016" class="ne-p"><span class="ne-text">在 UNIX 中，仅有一个系统调用来创建一个新的进程，这个系统调用就是 </span><code class="ne-code"><span class="ne-text">fork</span></code><span class="ne-text">。这个调用会创建一个与调用进程相关的副本。在 fork 后，一个父进程和子进程会有相同的</span><code class="ne-code"><span class="ne-text">内存映像</span></code><span class="ne-text">，相同的环境字符串和相同的打开文件。</span></p><p id="40b362f7c35397f6ed004f88fc15b256" class="ne-p"><br></p><p id="8ca0bc63e686352cfce2b4e04f846f34" class="ne-p"><span class="ne-text">在 Windows 中，情况正相反，一个简单的 Win32 功能调用 </span><code class="ne-code"><span class="ne-text">CreateProcess</span></code><span class="ne-text">，会处理流程创建并将正确的程序加载到新的进程中。这个调用会有 10 个参数，包括了需要执行的程序、输入给程序的命令行参数、各种安全属性、有关打开的文件是否继承控制位、优先级信息、进程所需要创建的窗口规格以及指向一个结构的指针，在该结构中新创建进程的信息被返回给调用者。</span><strong><span class="ne-text">在 Windows 中，从一开始父进程的地址空间和子进程的地址空间就是不同的</span></strong><span class="ne-text">。</span></p><p id="c760fc897fd7f21d634e5d2c5ab8dd50" class="ne-p"><br></p><h3 id="24ee23f9"><span class="ne-text">进程的终止</span></h3><p id="2a356a15e9c85c0d5ea48bee53e3ee53" class="ne-p"><br></p><p id="a0bc37496955070caffd70767e9fccca" class="ne-p"><span class="ne-text">进程在创建之后，它就开始运行并做完成任务。然而，没有什么事儿是永不停歇的，包括进程也一样。进程早晚会发生终止，但是通常是由于以下情况触发的</span></p><p id="1785949fd41d177bee8df659bfa2541e" class="ne-p"><br></p><ul class="ne-ul"><li id="aef294d171fb8cac4c656d092ad0efd6"><code class="ne-code"><span class="ne-text">正常退出(自愿的)</span></code><span class="ne-text"> ： 多数进程是由于完成了工作而终止。当编译器完成了所给定程序的编译之后，编译器会执行一个系统调用告诉操作系统它完成了工作。这个调用在 UNIX 中是 </span><code class="ne-code"><span class="ne-text">exit</span></code><span class="ne-text"> ，在 Windows 中是 </span><code class="ne-code"><span class="ne-text">ExitProcess</span></code><span class="ne-text">。</span></li><li id="64851a07fdbb717aabe3e48e41e69418"><code class="ne-code"><span class="ne-text">错误退出(自愿的)</span></code><span class="ne-text">：比如执行一条不存在的命令，于是编译器就会提醒并退出。</span></li></ul><ul class="ne-ul"><li id="7cdd5fd1594ea716be38ce11cb3a10e2"><code class="ne-code"><span class="ne-text">严重错误(非自愿的)</span></code></li><li id="6babe1237002ef73948160629e13b605"><code class="ne-code"><span class="ne-text">被其他进程杀死(非自愿的)</span></code><span class="ne-text"> ： 某个进程执行系统调用告诉操作系统杀死某个进程。在 UNIX 中，这个系统调用是 kill。在 Win32 中对应的函数是 </span><code class="ne-code"><span class="ne-text">TerminateProcess</span></code><span class="ne-text">（注意不是系统调用）。</span></li></ul><p id="5bd73c750876718c6aca8ef216af6b54" class="ne-p"><br></p><h3 id="59a65ba2"><span class="ne-text">进程的层次结构</span></h3><p id="0bb47166b3c322ba29b0f204223d5fd0" class="ne-p"><br></p><p id="7f07789281882e50c0fc300b3ca03f9c" class="ne-p"><span class="ne-text">在一些系统中，当一个进程创建了其他进程后，父进程和子进程就会以某种方式进行关联。子进程它自己就会创建更多进程，从而形成一个进程层次结构。</span></p><p id="829195fa901cce4553d63f442daebea8" class="ne-p"><br></p><h4 id="9a0a3bf9"><span class="ne-text">UNIX 进程体系</span></h4><p id="1c753e33d5a50d5c91e575f5f321a978" class="ne-p"><br></p><p id="71620443f7be78f9d927a3e3caee47a6" class="ne-p"><span class="ne-text">在 UNIX 中，进程和它的所有子进程以及子进程的子进程共同组成一个进程组。当用户从键盘中发出一个信号后，该信号被发送给当前与键盘相关的进程组中的所有成员（它们通常是在当前窗口创建的所有活动进程）。每个进程可以分别捕获该信号、忽略该信号或采取默认的动作，即被信号 kill 掉。整个操作系统中所有的进程都隶属于一个单个以 init 为根的进程树。</span></p><p id="dcf543e13cb6e080adafb4af20eb2588" class="ne-p"><br></p><p id="c4605dff5b082200add96857699ecbb3" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829468-bff503cb-cf97-4853-aca3-35db5bb67312.png" width="615" id="TUggO" class="ne-image"></p><p id="3fa2c3bfabb4e38822ab985e931554cb" class="ne-p"><br></p><h4 id="5d016720"><span class="ne-text">Windows 进程体系</span></h4><p id="fb9194b7b563522aaf65f5e7877f5d9d" class="ne-p"><br></p><p id="45b7deda743f60e53beed2089b218a3c" class="ne-p"><span class="ne-text">相反，Windows 中没有进程层次的概念，Windows 中所有进程都是平等的，唯一类似于层次结构的是在创建进程的时候，父进程得到一个特别的令牌（称为句柄），该句柄可以用来控制子进程。然而，这个令牌可能也会移交给别的操作系统，这样就不存在层次结构了。而在 UNIX 中，进程不能剥夺其子进程的 </span><code class="ne-code"><span class="ne-text">进程权</span></code><span class="ne-text">。（这样看来，还是 Windows 比较</span><code class="ne-code"><span class="ne-text">渣</span></code><span class="ne-text">）。</span></p><p id="248c55e3f445201dd7dbeca56a3f9b00" class="ne-p"><br></p><h3 id="fe290ad3"><span class="ne-text">进程状态</span></h3><p id="ad4ee3dd92ab5c79b1c5cbc43c5a3dba" class="ne-p"><br></p><p id="4d829862b4033af7e64e431f9c777402" class="ne-p"><span class="ne-text">尽管每个进程是一个独立的实体，有其自己的程序计数器和内部状态，但是，进程之间仍然需要相互帮助。当一个进程开始运行时，它可能会经历下面这几种状态</span></p><p id="a7817b1f61e8d565b373c264359e44f9" class="ne-p"><br></p><p id="c8b03ba9b3b2b9903b85c39e72dd8a91" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829472-6b2e277f-f4b9-4f38-805d-e9ac73f33129.png" width="734" id="nVHjc" class="ne-image"></p><p id="08028f8436803d51ec1e716d72fe2310" class="ne-p"><br></p><p id="82bce743c56b29faca92df0ac4052b5e" class="ne-p"><span class="ne-text">图中会涉及三种状态</span></p><p id="9f699dbeb42df9e8d0551ca5d9171c73" class="ne-p"><br></p><ol class="ne-ol"><li id="aec08485f34560a4b7b6abadb75ef79d"><code class="ne-code"><span class="ne-text">运行态</span></code><span class="ne-text">，运行态指的就是进程实际占用 CPU 时间片运行时</span></li><li id="381d58aae0b72332585ff6985de97c5e"><code class="ne-code"><span class="ne-text">就绪态</span></code><span class="ne-text">，就绪态指的是可运行，但因为其他进程正在运行而处于就绪状态</span></li></ol><ol start="3" class="ne-ol"><li id="65a92d0ec3b2adb54401c8528d0e23b6"><code class="ne-code"><span class="ne-text">阻塞态</span></code><span class="ne-text">，除非某种外部事件发生，否则进程不能运行</span></li></ol><p id="081c0d4cc15fd01c6d95209ecec0c1e0" class="ne-p"><br></p><h3 id="27fe55d6"><span class="ne-text">进程的实现</span></h3><p id="92b3b630daddd7d1ddb5cf95b49e523c" class="ne-p"><br></p><p id="7837b0696feedfcbb97df8ce125c1217" class="ne-p"><span class="ne-text">操作系统为了执行进程间的切换，会维护着一张表，这张表就是 </span><code class="ne-code"><span class="ne-text">进程表(process table)</span></code><span class="ne-text">。每个进程占用一个进程表项。该表项包含了进程状态的重要信息，包括程序计数器、堆栈指针、内存分配状况、所打开文件的状态、账号和调度信息，以及其他在进程由运行态转换到就绪态或阻塞态时所必须保存的信息。</span></p><p id="d3d512edb88e5511bf9ce1530b15e0f8" class="ne-p"><br></p><p id="650b4ebec7f6635f2b6ff4cc027a95fe" class="ne-p"><span class="ne-text">下面展示了一个典型系统中的关键字段</span></p><p id="023ffbba17dc27adc6ff1d21fb9e45cf" class="ne-p"><br></p><p id="abf3e59185ee55f8fe152e201cecaf06" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829487-6d8a6e92-d068-48a8-b5a0-9e5b74f9ab3f.png" width="749" id="Sr874" class="ne-image"></p><p id="4c8283b21ecd2b4d4d8121fed458946c" class="ne-p"><br></p><p id="4fe136f6a62abb9ab8066e3c6085988c" class="ne-p"><span class="ne-text">第一列内容与</span><code class="ne-code"><span class="ne-text">进程管理</span></code><span class="ne-text">有关，第二列内容与 </span><code class="ne-code"><span class="ne-text">存储管理</span></code><span class="ne-text">有关，第三列内容与</span><code class="ne-code"><span class="ne-text">文件管理</span></code><span class="ne-text">有关。</span></p><p id="93ffa9020d0b8573b25e9ad3d4211dbc" class="ne-p"><br></p><p id="6a6879f2608015b94561ab03cca29275" class="ne-p"><span class="ne-text">现在我们应该对进程表有个大致的了解了，就可以在对单个 CPU 上如何运行多个顺序进程的错觉做更多的解释。与每一 I/O 类相关联的是一个称作 </span><code class="ne-code"><span class="ne-text">中断向量(interrupt vector)</span></code><span class="ne-text"> 的位置（靠近内存底部的固定区域）。它包含中断服务程序的入口地址。假设当一个磁盘中断发生时，用户进程 3 正在运行，则中断硬件将程序计数器、程序状态字、有时还有一个或多个寄存器压入堆栈，计算机随即跳转到中断向量所指示的地址。这就是硬件所做的事情。然后软件就随即接管一切剩余的工作。</span></p><p id="d944c12bcb8d1fb777afe0c76b5d4dfe" class="ne-p"><br></p><p id="67925a50acf5cec75da68f7c4fa97604" class="ne-p"><span class="ne-text">当中断结束后，操作系统会调用一个 C 程序来处理中断剩下的工作。在完成剩下的工作后，会使某些进程就绪，接着调用调度程序，决定随后运行哪个进程。然后将控制权转移给一段汇编语言代码，为当前的进程装入寄存器值以及内存映射并启动该进程运行，下面显示了中断处理和调度的过程。</span></p><p id="e9c2e6a19d20c8e9d745ba1ede98bda0" class="ne-p"><br></p><ol class="ne-ol"><li id="bcfd5526252f62185fad5607256d5a21"><span class="ne-text">硬件压入堆栈程序计数器等</span></li><li id="7fe994f519b0faf5566db73640fc6be1"><span class="ne-text">硬件从中断向量装入新的程序计数器</span></li></ol><ol start="3" class="ne-ol"><li id="c934d43af74c443845b28312159ee1ac"><span class="ne-text">汇编语言过程保存寄存器的值</span></li><li id="82e923138b451b98f625e89cbd0b6bca"><span class="ne-text">汇编语言过程设置新的堆栈</span></li></ol><ol start="5" class="ne-ol"><li id="4f5334e81f1d5a5f1e64fda967d5fca0"><span class="ne-text">C 中断服务器运行（典型的读和缓存写入）</span></li><li id="94f7067d3f873488b2a017df5a72d5ce"><span class="ne-text">调度器决定下面哪个程序先运行</span></li></ol><ol start="7" class="ne-ol"><li id="eff3e73d42a5e05ab6c5e185f9a05120"><span class="ne-text">C 过程返回至汇编代码</span></li><li id="724b882cbe84a93d767c38842f66357b"><span class="ne-text">汇编语言过程开始运行新的当前进程</span></li></ol><p id="60ef497df3321edea7d108cdcc4053d3" class="ne-p"><br></p><p id="38f27f3718510227db767b00debb1939" class="ne-p"><span class="ne-text">一个进程在执行过程中可能被中断数千次，但关键每次中断后，被中断的进程都返回到与中断发生前完全相同的状态。</span></p><p id="51999800e2ccce806ac92346816458e4" class="ne-p"><br></p><h2 id="d276123c"><span class="ne-text">线程</span></h2><p id="9f602f2dc988af4bde245a6ccdf7ff13" class="ne-p"><br></p><p id="55772d1f565f2ecbfcfc09a8bc616c44" class="ne-p"><span class="ne-text">在传统的操作系统中，每个进程都有一个地址空间和一个控制线程。事实上，这是大部分进程的定义。不过，在许多情况下，经常存在同一地址空间中运行多个控制线程的情形，这些线程就像是分离的进程。下面我们就着重探讨一下什么是线程</span></p><p id="ea8fb1edc20cb64f1273a9310aa3751d" class="ne-p"><br></p><h3 id="b2c46474"><span class="ne-text">线程的使用</span></h3><p id="ab116c151e8ba219bf8ae6f68ab5ede4" class="ne-p"><br></p><p id="1ce2c19e90381851b1534560e92b51d3" class="ne-p"><span class="ne-text">或许这个疑问也是你的疑问，为什么要在进程的基础上再创建一个线程的概念，准确的说，这其实是进程模型和线程模型的讨论，回答这个问题，可能需要分三步来回答</span></p><p id="e8a5e2e598ab662e0607b58901d9758e" class="ne-p"><br></p><ul class="ne-ul"><li id="a68004fabbe64f1be4294491ce6943cc"><span class="ne-text">多线程之间会共享同一块地址空间和所有可用数据的能力，这是进程所不具备的</span></li><li id="c16d784bb6036482a74a4f2816dcd734"><span class="ne-text">线程要比进程</span><code class="ne-code"><span class="ne-text">更轻量级</span></code><span class="ne-text">，由于线程更轻，所以它比进程更容易创建，也更容易撤销。在许多系统中，创建一个线程要比创建一个进程快 10 - 100 倍。</span></li></ul><ul class="ne-ul"><li id="124456cced3a6934d0dbc4c8b6e588fa"><span class="ne-text">第三个原因可能是性能方面的探讨，如果多个线程都是 CPU 密集型的，那么并不能获得性能上的增强，但是如果存在着大量的计算和大量的 I/O 处理，拥有多个线程能在这些活动中彼此重叠进行，从而会加快应用程序的执行速度</span></li></ul><p id="969485792d07970e248a25c707ae81c3" class="ne-p"><br></p><h3 id="eb3f9151"><span class="ne-text">经典的线程模型</span></h3><p id="0f4cd5ac358f2cd5d9e6305faa1d2f19" class="ne-p"><br></p><p id="f4399e0137f899b35f0a99796f458cee" class="ne-p"><span class="ne-text">进程中拥有一个执行的线程，通常简写为 </span><code class="ne-code"><span class="ne-text">线程(thread)</span></code><span class="ne-text">。线程会有程序计数器，用来记录接着要执行哪一条指令；线程实际上 CPU 上调度执行的实体。</span></p><p id="9f6e4eaf1534a378bf8231492af63f4b" class="ne-p"><br></p><p id="cf636b0793325e7d330a7e6769b03700" class="ne-p"><span class="ne-text">下图我们可以看到三个传统的进程，每个进程有自己的地址空间和单个控制线程。每个线程都在不同的地址空间中运行</span></p><p id="90ee1e4c78f7c3f9bacfeddf50cce64c" class="ne-p"><br></p><p id="6caf3b47091b19d6f3453533334c3136" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829491-73cfd311-e3e5-4381-886b-f904f3c8ca5c.png" width="658" id="lfuB1" class="ne-image"></p><p id="8ba295dcb96dca3a3572f16973748711" class="ne-p"><br></p><p id="1644b4a344140948fb4c97c0bd2cd7df" class="ne-p"><span class="ne-text">下图中，我们可以看到有一个进程三个线程的情况。每个线程都在相同的地址空间中运行。</span></p><p id="a6c4bee1d01b8aa5be0eadc12cbe618b" class="ne-p"><br></p><p id="af6501c631d07365f00006589b930913" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829501-7e5370fc-b9ec-4804-a862-9c86e00bf231.png" width="640" id="uVJR7" class="ne-image"></p><p id="181be89a9207f89b1c00524cbbab1e00" class="ne-p"><br></p><p id="39810993b510056e76c4a3b570b37cd2" class="ne-p"><span class="ne-text">线程不像是进程那样具备较强的独立性。同一个进程中的所有线程都会有完全一样的地址空间，这意味着它们也共享同样的全局变量。由于每个线程都可以访问进程地址空间内每个内存地址，</span><strong><span class="ne-text">因此一个线程可以读取、写入甚至擦除另一个线程的堆栈</span></strong><span class="ne-text">。线程之间除了共享同一内存空间外，还具有如下不同的内容</span></p><p id="e6b58ebee8ff091f855004f3afe8523d" class="ne-p"><br></p><p id="9cf3875d0759c13afa2efc6cbceea3c6" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829530-1ce4e3bb-f3b4-4fae-bd6b-2a09cb86e2d3.png" width="583" id="GpbmQ" class="ne-image"></p><p id="5d5826853af545f770aa24d16ca10997" class="ne-p"><br></p><p id="33ecc512185771f5ff75d82ee58a1d69" class="ne-p"><span class="ne-text">上图左边的是同一个进程中</span><code class="ne-code"><span class="ne-text">每个线程共享</span></code><span class="ne-text">的内容，上图右边是</span><code class="ne-code"><span class="ne-text">每个线程</span></code><span class="ne-text">中的内容。也就是说左边的列表是进程的属性，右边的列表是线程的属性。</span></p><p id="ad5fb01708e084b0184f6e5dc56062b2" class="ne-p"><br></p><p id="1e26ec6c5f413fc1bd832038d6fce9ce" class="ne-p"><strong><span class="ne-text">线程之间的状态转换和进程之间的状态转换是一样的</span></strong><span class="ne-text">。</span></p><p id="7c1105577d60fc2e15dc30ee4592d372" class="ne-p"><br></p><p id="f4511cae93abe3026efa2cf3757360d5" class="ne-p"><span class="ne-text">每个线程都会有自己的堆栈，如下图所示</span></p><p id="8adbcedd049bb3edc3764bede487c847" class="ne-p"><br></p><p id="27f1bbcde67b84d60351835e8ce7750b" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829586-41932660-4ab5-42e2-bbb1-bbd660b183f6.png" width="682" id="WnFPn" class="ne-image"></p><p id="0e816dfec54ca3e832073ef02dbeeb6b" class="ne-p"><br></p><h4 id="6632fae6"><span class="ne-text">线程系统调用</span></h4><p id="8626c74ea022a987992b0c1fbdb792b3" class="ne-p"><br></p><p id="eef4b592177acc7598b410c9dcbd2692" class="ne-p"><span class="ne-text">进程通常会从当前的某个单线程开始，然后这个线程通过调用一个库函数（比如 </span><code class="ne-code"><span class="ne-text">thread_create</span></code><span class="ne-text"> ）创建新的线程。线程创建的函数会要求指定新创建线程的名称。创建的线程通常都返回一个线程标识符，该标识符就是新线程的名字。</span></p><p id="699815b2cc0f7cb21f43b7de2be07cdf" class="ne-p"><br></p><p id="a7c9a0127beb8b9c706078fde4ff4ee2" class="ne-p"><span class="ne-text">当一个线程完成工作后，可以通过调用一个函数（比如 </span><code class="ne-code"><span class="ne-text">thread_exit</span></code><span class="ne-text">）来退出。紧接着线程消失，状态变为终止，不能再进行调度。在某些线程的运行过程中，可以通过调用函数例如 </span><code class="ne-code"><span class="ne-text">thread_join</span></code><span class="ne-text"> ，表示一个线程可以等待另一个线程退出。这个过程阻塞调用线程直到等待特定的线程退出。在这种情况下，线程的创建和终止非常类似于进程的创建和终止。</span></p><p id="f4a5500946aabb17ea44c2558f19c2ca" class="ne-p"><br></p><p id="9629c5ac74f429f3955418e20f72cec0" class="ne-p"><span class="ne-text">另一个常见的线程是调用 </span><code class="ne-code"><span class="ne-text">thread_yield</span></code><span class="ne-text">，它允许线程自动放弃 CPU 从而让另一个线程运行。这样一个调用还是很重要的，因为不同于进程，线程是无法利用时钟中断强制让线程让出 CPU 的。</span></p><p id="8fdc0d7830858c997bfd188739ed7afc" class="ne-p"><br></p><h3 id="b1d15c6e"><span class="ne-text">POSIX 线程</span></h3><p id="db401dc44303ec105e67be5c2fc389c4" class="ne-p"><br></p><p id="dfd97f521bd61893a8aeabdb0535fa87" class="ne-p"><code class="ne-code"><span class="ne-text">POSIX 线程 通常称为 pthreads</span></code><span class="ne-text">是一种独立于语言而存在的执行模型，以及并行执行模型。</span></p><p id="1bf64c399339628fb7957855f494f71f" class="ne-p"><br></p><p id="e49542eca979134cc9c9f75f2f329a24" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829568-3bded50a-8029-4644-9e42-c2c6ddf60ca1.png" width="639" id="ZELdp" class="ne-image"></p><p id="fe7cfff22c57936dee6dd54e80f17015" class="ne-p"><br></p><p id="c50783d2ba22cd47838f774866f90191" class="ne-p"><span class="ne-text">它允许程序控制时间上重叠的多个不同的工作流程。每个工作流程都称为一个线程，可以通过调用 POSIX Threads API 来实现对这些流程的创建和控制。可以把它理解为线程的标准。</span></p><p id="6ae632f03f369eff8d56f27dbe210647" class="ne-p"><br></p><div class="ne-quote"><p id="cd16084d7837c5073a2fa1c2189d0c10" class="ne-p"><span class="ne-text">POSIX Threads 的实现在许多类似且符合POSIX的操作系统上可用，例如 </span><strong><span class="ne-text">FreeBSD、NetBSD、OpenBSD、Linux、macOS、Android、Solaris</span></strong><span class="ne-text">，它在现有 Windows API 之上实现了</span><strong><span class="ne-text">pthread</span></strong><span class="ne-text">。</span></p><p id="4bb522cf8ceadf992cc37fe01affca2b" class="ne-p"><span class="ne-text">IEEE 是世界上最大的技术专业组织，致力于为人类的利益而发展技术。</span></p></div><table id="d6ca4def" class="ne-table" style="width: 750px"><tbody><tr style="height: 33px"><td width="375"><p id="uf5bca78d" class="ne-p"><span class="ne-text">线程调用</span></p></td><td width="375"><p id="u066f4fdf" class="ne-p"><span class="ne-text">描述</span></p></td></tr><tr style="height: 33px"><td width="375"><p id="u96230ab3" class="ne-p"><span class="ne-text">pthread_create</span></p></td><td width="375"><p id="uff601278" class="ne-p"><span class="ne-text">创建一个新线程</span></p></td></tr><tr style="height: 33px"><td width="375"><p id="ucb6f1a7c" class="ne-p"><span class="ne-text">pthread_exit</span></p></td><td width="375"><p id="u2c6ae04a" class="ne-p"><span class="ne-text">结束调用的线程</span></p></td></tr><tr style="height: 33px"><td width="375"><p id="u2219439b" class="ne-p"><span class="ne-text">pthread_join</span></p></td><td width="375"><p id="ub02eaf4e" class="ne-p"><span class="ne-text">等待一个特定的线程退出</span></p></td></tr><tr style="height: 33px"><td width="375"><p id="u2804c355" class="ne-p"><span class="ne-text">pthread_yield</span></p></td><td width="375"><p id="u60922575" class="ne-p"><span class="ne-text">释放 CPU 来运行另外一个线程</span></p></td></tr><tr style="height: 33px"><td width="375"><p id="u9eb11640" class="ne-p"><span class="ne-text">pthread_attr_init</span></p></td><td width="375"><p id="ue5ad1df6" class="ne-p"><span class="ne-text">创建并初始化一个线程的属性结构</span></p></td></tr><tr style="height: 33px"><td width="375"><p id="u1ea06b78" class="ne-p"><span class="ne-text">pthread_attr_destory</span></p></td><td width="375"><p id="ub04e7306" class="ne-p"><span class="ne-text">删除一个线程的属性结构</span></p></td></tr></tbody></table><p id="f6a1a765e184a87a3cf062bd79112ab3" class="ne-p"><br></p><p id="964bff2b1f299a8123c4564cf6c32159" class="ne-p"><span class="ne-text">所有的 Pthreads 都有特定的属性，每一个都含有标识符、一组寄存器（包括程序计数器）和一组存储在结构中的属性。这个属性包括堆栈大小、调度参数以及其他线程需要的项目。</span></p><p id="8557a0d1a9c2d19f43f23a025b5b1e9d" class="ne-p"><br></p><h3 id="15ab0a3d"><span class="ne-text">线程实现</span></h3><p id="5e3030d48820fc3f997c9fc07867d415" class="ne-p"><br></p><p id="bfec13543c9248ed01602aac8986d3b1" class="ne-p"><span class="ne-text">主要有三种实现方式</span></p><p id="6ca771c1e461f72989e0d3259a67f52e" class="ne-p"><br></p><ul class="ne-ul"><li id="7c27924bef969657528fcdaaa609f955"><span class="ne-text">在用户空间中实现线程；</span></li><li id="600f350c1424b2986a7804ec78dc04b3"><span class="ne-text">在内核空间中实现线程；</span></li></ul><ul class="ne-ul"><li id="edbb0a2cf6d6e63294285f0299dda3fc"><span class="ne-text">在用户和内核空间中混合实现线程。</span></li></ul><p id="4c6f55a17135de2b2291efc72cead4d1" class="ne-p"><br></p><p id="83eff6a3553c469021aa6db1dceec0d9" class="ne-p"><span class="ne-text">下面我们分开讨论一下</span></p><p id="9572d3617e09301baa3ee984f1c92f5c" class="ne-p"><br></p><h4 id="9f307c8e"><span class="ne-text">在用户空间中实现线程</span></h4><p id="42e095da41230932ab0833eed35e4a62" class="ne-p"><br></p><p id="95fe62305076810bbdbc0548d37541ba" class="ne-p"><span class="ne-text">第一种方法是把整个线程包放在用户空间中，内核对线程一无所知，它不知道线程的存在。所有的这类实现都有同样的通用结构</span></p><p id="276d2eb1fdc4a41e4173ea11b35f5cc2" class="ne-p"><br></p><p id="7a5fa3aa9f73d81d2fb09d64a02e4f3b" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829565-1733358e-dbe8-4e1e-ab32-50b95d98a6e3.png" width="599" id="uVF3u" class="ne-image"></p><p id="994599839f8a0493163453339bc36bf1" class="ne-p"><br></p><p id="eff4df6ded311edd97d79b039f96d79d" class="ne-p"><span class="ne-text">线程在运行时系统之上运行，运行时系统是管理线程过程的集合，包括前面提到的四个过程： pthread_create, pthread_exit, pthread_join 和 pthread_yield。</span></p><p id="9f01a3a063f4e73adb15e108ca6a7eea" class="ne-p"><br></p><h3 id="78ffb122"><span class="ne-text">在内核中实现线程</span></h3><p id="c1f41f5788707afdebb1adada6659535" class="ne-p"><br></p><p id="31823d31c3e4c8a1d3e9c4053e65166f" class="ne-p"><span class="ne-text">当某个线程希望创建一个新线程或撤销一个已有线程时，它会进行一个系统调用，这个系统调用通过对线程表的更新来完成线程创建或销毁工作。</span></p><p id="70941018fd44652b5554c9be911f4bb4" class="ne-p"><br></p><p id="74b4ad9f0cf425a882479e7b9fccc210" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829600-91569966-c35c-4db1-858b-f7fcae7729c3.png" width="600" id="hh20v" class="ne-image"></p><p id="9be5d4ee6254ece2371dae576e1ce5ed" class="ne-p"><br></p><p id="ca2c3a358734c3ac5a68fd4da8a6f6d1" class="ne-p"><span class="ne-text">内核中的线程表持有每个线程的寄存器、状态和其他信息。这些信息和用户空间中的线程信息相同，但是位置却被放在了内核中而不是用户空间中。另外，内核还维护了一张进程表用来跟踪系统状态。</span></p><p id="5d51544c741cef09fd2074b01c87b917" class="ne-p"><br></p><p id="446a4e049bb4f8b4e6d08161a35277b5" class="ne-p"><span class="ne-text">所有能够阻塞的调用都会通过系统调用的方式来实现，当一个线程阻塞时，内核可以进行选择，是运行在同一个进程中的另一个线程（如果有就绪线程的话）还是运行一个另一个进程中的线程。但是在用户实现中，运行时系统始终运行自己的线程，直到内核剥夺它的 CPU 时间片（或者没有可运行的线程存在了）为止。</span></p><p id="15f0ff35b5546621cdfa2a7240307b67" class="ne-p"><br></p><h3 id="26e17fd6"><span class="ne-text">混合实现</span></h3><p id="b5ee17fce17b6cdbe43273512e22ecb9" class="ne-p"><br></p><p id="63976c7cc6bac642a93b4f69c61c73b7" class="ne-p"><span class="ne-text">结合用户空间和内核空间的优点，设计人员采用了一种</span><code class="ne-code"><span class="ne-text">内核级线程</span></code><span class="ne-text">的方式，然后将用户级线程与某些或者全部内核线程多路复用起来</span></p><p id="a817d6cedfd6372e5126592d084db2cd" class="ne-p"><br></p><p id="065866846bc241326c1231ae19b4e8c3" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829624-481cc859-db6d-4516-8dc4-6ea9f958c022.png" width="647" id="z1E6R" class="ne-image"></p><p id="80cc0ff3caab76b5b04463be351d36e6" class="ne-p"><br></p><p id="46d3024237e6c858dddb4620413c3f9d" class="ne-p"><span class="ne-text">在这种模型中，编程人员可以自由控制用户线程和内核线程的数量，具有很大的灵活度。采用这种方法，内核只识别内核级线程，并对其进行调度。其中一些内核级线程会被多个用户级线程多路复用。</span></p><p id="cafd9a2584fc98d82c47a69f4eb4a44a" class="ne-p"><br></p><h2 id="13747cb9"><span class="ne-text">进程间通信</span></h2><p id="89f23068c1d014c8ae7379c1ee4ff256" class="ne-p"><br></p><p id="ae233faa7b8916909e1f871f4d9ceb06" class="ne-p"><span class="ne-text">进程是需要频繁的和其他进程进行交流的。下面我们会一起讨论有关 </span><code class="ne-code"><span class="ne-text">进程间通信(Inter Process Communication, IPC)</span></code><span class="ne-text"> 的问题。大致来说，进程间的通信机制可以分为 6 种</span></p><p id="dfe97806c12fe7f893011f144d1a8165" class="ne-p"><br></p><p id="bc4ca741dee963edba6ac3cea886b95e" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829616-22b9e251-36fa-4a65-8102-204b899c01ca.png" width="772" id="WxiTX" class="ne-image"></p><p id="13d5bccfbad5a2bc08c0ae4830359792" class="ne-p"><br></p><p id="2cc0c61db915799a3dab5663db6d75de" class="ne-p"><span class="ne-text">下面我们分别对其进行概述</span></p><p id="7666fa53af51829ddb54296233381012" class="ne-p"><br></p><h3 id="cf09c6fb"><span class="ne-text">信号 signal</span></h3><p id="f2d6f42f7be9db0ef2e31f6e6bec3b21" class="ne-p"><br></p><p id="f56f26bead6812e39ebd085c6282a029" class="ne-p"><span class="ne-text">信号是 UNIX 系统最先开始使用的进程间通信机制，因为 Linux 是继承于 UNIX 的，所以 Linux 也支持信号机制，通过向一个或多个进程发送</span><code class="ne-code"><span class="ne-text">异步事件信号</span></code><span class="ne-text">来实现，信号可以从键盘或者访问不存在的位置等地方产生；信号通过 shell 将任务发送给子进程。</span></p><p id="77a00de06ad8a313624bebd7197daab0" class="ne-p"><br></p><p id="c3a46e2f457eb12ac07b2735125ed640" class="ne-p"><span class="ne-text">你可以在 Linux 系统上输入 </span><code class="ne-code"><span class="ne-text">kill -l</span></code><span class="ne-text"> 来列出系统使用的信号，下面是我提供的一些信号</span></p><p id="b6d3f3b7ee125b00a6385d6a05e9c790" class="ne-p"><br></p><p id="c332f05576b8b21614e769f51765e046" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829652-e25e8aaa-523f-49e7-91a6-13af7872483a.png" width="736" id="iFTA7" class="ne-image"></p><p id="e94793bcd68a9f5383857361c260794e" class="ne-p"><br></p><p id="1e0b0c18d976e2cb412fe31f463b0b70" class="ne-p"><span class="ne-text">进程可以选择忽略发送过来的信号，但是有两个是不能忽略的：</span><code class="ne-code"><span class="ne-text">SIGSTOP</span></code><span class="ne-text"> 和 </span><code class="ne-code"><span class="ne-text">SIGKILL</span></code><span class="ne-text"> 信号。SIGSTOP 信号会通知当前正在运行的进程执行关闭操作，SIGKILL 信号会通知当前进程应该被杀死。除此之外，进程可以选择它想要处理的信号，进程也可以选择阻止信号，如果不阻止，可以选择自行处理，也可以选择进行内核处理。如果选择交给内核进行处理，那么就执行默认处理。</span></p><p id="f463e7202028da7ee34fa86439d2d0bc" class="ne-p"><br></p><p id="97307b7fc6bb2a3d3a6c7415c2d1a58f" class="ne-p"><span class="ne-text">操作系统会中断目标程序的进程来向其发送信号、在任何非原子指令中，执行都可以中断，如果进程已经注册了新号处理程序，那么就执行进程，如果没有注册，将采用默认处理的方式。</span></p><p id="f0d78f86dcc225fbef3bc7ca4b9c2eae" class="ne-p"><br></p><h3 id="79c52210"><span class="ne-text">管道 pipe</span></h3><p id="e581372206c587ee595cd8880c7fe68c" class="ne-p"><br></p><p id="7d6b1edbc43ab03cd76e374db13b3d79" class="ne-p"><span class="ne-text">Linux 系统中的进程可以通过建立管道 pipe 进行通信</span></p><p id="8ccfe4d2fc3be296206ee867a830076f" class="ne-p"><br></p><p id="e4d7d6e07cdeb822a190325504719442" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829658-0cfbf5f9-97b3-4972-8205-7953cdab82b7.png" width="729" id="UyA6r" class="ne-image"></p><p id="b1d8ec45d3bd885ef634b40206c6be13" class="ne-p"><br></p><p id="94564611bd47217e8819b4129456507f" class="ne-p"><span class="ne-text">在两个进程之间，可以建立一个通道，一个进程向这个通道里写入字节流，另一个进程从这个管道中读取字节流。管道是同步的，当进程尝试从空管道读取数据时，该进程会被阻塞，直到有可用数据为止。shell 中的</span><code class="ne-code"><span class="ne-text">管线 pipelines</span></code><span class="ne-text"> 就是用管道实现的，当 shell 发现输出</span></p><p id="f6df0669510949bc580d81d8ca93eb12" class="ne-p"><br></p><pre data-language="null" id="8f337cd0" class="ne-codeblock language-null">sort &lt;f | head</pre><p id="41e8a4181b2a6e81046de5357f803804" class="ne-p"><br></p><p id="b87e76fec29ab8fc296c13120144f137" class="ne-p"><span class="ne-text">它会创建两个进程，一个是 sort，一个是 head，sort，会在这两个应用程序之间建立一个管道使得 sort 进程的标准输出作为 head 程序的标准输入。sort 进程产生的输出就不用写到文件中了，如果管道满了系统会停止 sort 以等待 head 读出数据</span></p><p id="2dde603cd64cf50dcaf8d9d7df59a61f" class="ne-p"><br></p><p id="5e1bfd07d47f7ada8a6d809c79141d39" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829684-0f55014e-302f-4dbe-9ea8-9ee4d6c9fdeb.png" width="488" id="irplH" class="ne-image"></p><p id="5e74f9a53149c90944e0bad4389f82c3" class="ne-p"><br></p><p id="57493598a8059c5e29d760919d110090" class="ne-p"><span class="ne-text">管道实际上就是 </span><code class="ne-code"><span class="ne-text">|</span></code><span class="ne-text">，两个应用程序不知道有管道的存在，一切都是由 shell 管理和控制的。</span></p><p id="9135a0a2091dee1a4cfbf8c684405913" class="ne-p"><br></p><h3 id="72b83631"><span class="ne-text">共享内存 shared memory</span></h3><p id="b441fd0f50991bc8fbdb133ed2bfecc1" class="ne-p"><br></p><p id="5c9437460a98ec5c1b1963be737e891a" class="ne-p"><span class="ne-text">两个进程之间还可以通过共享内存进行进程间通信，其中两个或者多个进程可以访问公共内存空间。两个进程的共享工作是通过共享内存完成的，一个进程所作的修改可以对另一个进程可见(很像线程间的通信)。</span></p><p id="3b7e81fdce6f289a7b5b128d1c5890be" class="ne-p"><br></p><p id="84515a95f3770ad7ac1586bd0d382886" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829708-7158a6ec-203c-42aa-96bb-7946e3fb959a.png" width="659" id="WYSoT" class="ne-image"></p><p id="d4fb40df164d63a65f225277e42634fa" class="ne-p"><br></p><p id="caab3879748d4be435662e13c24b3335" class="ne-p"><span class="ne-text">在使用共享内存前，需要经过一系列的调用流程，流程如下</span></p><p id="c59ad6e8a32a354abe821f6b1d455495" class="ne-p"><br></p><ul class="ne-ul"><li id="eaf12986b718d744584491248cd9ad59"><span class="ne-text">创建共享内存段或者使用已创建的共享内存段</span><code class="ne-code"><span class="ne-text">(shmget())</span></code></li><li id="07722001603dcec1909ffeebbc9bbba5"><span class="ne-text">将进程附加到已经创建的内存段中</span><code class="ne-code"><span class="ne-text">(shmat())</span></code></li></ul><ul class="ne-ul"><li id="c08827f8c1685d8ec2163aebf19295b9"><span class="ne-text">从已连接的共享内存段分离进程</span><code class="ne-code"><span class="ne-text">(shmdt())</span></code></li><li id="8cd7c3fb9d858dcc81002e015465844d"><span class="ne-text">对共享内存段执行控制操作</span><code class="ne-code"><span class="ne-text">(shmctl())</span></code></li></ul><p id="8b6f722bbcdffe424e246ed3a95b9cec" class="ne-p"><br></p><h3 id="c4f8f8c1"><span class="ne-text">先入先出队列 FIFO</span></h3><p id="52767acac0b583fa16bd52993f2cff1a" class="ne-p"><br></p><p id="a66eca62deab14281ed14fd5255e4c7c" class="ne-p"><span class="ne-text">先入先出队列 FIFO 通常被称为 </span><code class="ne-code"><span class="ne-text">命名管道(Named Pipes)</span></code><span class="ne-text">，命名管道的工作方式与常规管道非常相似，但是确实有一些明显的区别。未命名的管道没有备份文件：操作系统负责维护内存中的缓冲区，用来将字节从写入器传输到读取器。一旦写入或者输出终止的话，缓冲区将被回收，传输的数据会丢失。相比之下，命名管道具有支持文件和独特 API ，命名管道在文件系统中作为设备的专用文件存在。当所有的进程通信完成后，命名管道将保留在文件系统中以备后用。命名管道具有严格的 FIFO 行为</span></p><p id="4c4130835544d2e4037541a399c00274" class="ne-p"><br></p><p id="518b30630e1757de83724356bf420c6f" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829713-f872efe8-5031-4f02-89ad-8c8351a854c7.png" width="584" id="gHPi1" class="ne-image"></p><p id="64556edd5c72d351442d4c215bd78afa" class="ne-p"><br></p><p id="ad02a68ae4b9a278228e0e65be24c577" class="ne-p"><span class="ne-text">写入的第一个字节是读取的第一个字节，写入的第二个字节是读取的第二个字节，依此类推。</span></p><p id="cacfa57508b4cbca4112ae43dda31420" class="ne-p"><br></p><h3 id="cf4ddbc3"><span class="ne-text">消息队列 Message Queue</span></h3><p id="f3a9949035996a711f2acc9e1cb8a548" class="ne-p"><br></p><p id="502aac7079420863be2b507a816dad7f" class="ne-p"><span class="ne-text">一听到消息队列这个名词你可能不知道是什么意思，消息队列是用来描述内核寻址空间内的内部链接列表。可以按几种不同的方式将消息按顺序发送到队列并从队列中检索消息。每个消息队列由 IPC 标识符唯一标识。消息队列有两种模式，一种是</span><code class="ne-code"><span class="ne-text">严格模式</span></code><span class="ne-text">， 严格模式就像是 FIFO 先入先出队列似的，消息顺序发送，顺序读取。还有一种模式是 </span><code class="ne-code"><span class="ne-text">非严格模式</span></code><span class="ne-text">，消息的顺序性不是非常重要。</span></p><p id="76610295702efeb67524a09a51ca022c" class="ne-p"><br></p><h3 id="fbaf7bbe"><span class="ne-text">套接字 Socket</span></h3><p id="9f141557fe97223eea8773c539b9552a" class="ne-p"><br></p><p id="28af2f3a58533de88a523266b8f66673" class="ne-p"><span class="ne-text">还有一种管理两个进程间通信的是使用 </span><code class="ne-code"><span class="ne-text">socket</span></code><span class="ne-text">，socket 提供端到端的双相通信。一个套接字可以与一个或多个进程关联。就像管道有命令管道和未命名管道一样，套接字也有两种模式，套接字一般用于两个进程之间的网络通信，网络套接字需要来自诸如</span><code class="ne-code"><span class="ne-text">TCP（传输控制协议）</span></code><span class="ne-text">或较低级别</span><code class="ne-code"><span class="ne-text">UDP（用户数据报协议）</span></code><span class="ne-text">等基础协议的支持。</span></p><p id="8c6d6b235890be26598ba16ff7a067fe" class="ne-p"><br></p><p id="203016d407ce5eb34e08849dadb79d88" class="ne-p"><span class="ne-text">套接字有以下几种分类</span></p><p id="854024933d86bf7a4d7c66a6b9ea755a" class="ne-p"><br></p><ul class="ne-ul"><li id="d8b2232e1900fd6705f4245543d5376b"><code class="ne-code"><span class="ne-text">顺序包套接字(Sequential Packet Socket)</span></code><span class="ne-text">： 此类套接字为最大长度固定的数据报提供可靠的连接。此连接是双向的并且是顺序的。</span></li><li id="d95a76dd1ca1ff9e7882c7f123319b54"><code class="ne-code"><span class="ne-text">数据报套接字(Datagram Socket)</span></code><span class="ne-text">：数据包套接字支持双向数据流。数据包套接字接受消息的顺序与发送者可能不同。</span></li></ul><ul class="ne-ul"><li id="055798b0b774376247582b29b38e9e51"><code class="ne-code"><span class="ne-text">流式套接字(Stream Socket)</span></code><span class="ne-text">：流套接字的工作方式类似于电话对话，提供双向可靠的数据流。</span></li><li id="485881b289944fc9644438d0af5b2bab"><code class="ne-code"><span class="ne-text">原始套接字(Raw Socket)</span></code><span class="ne-text">： 可以使用原始套接字访问基础通信协议。</span></li></ul><p id="06fb91a72234b4c3fa8fe3c525213a6c" class="ne-p"><br></p><h2 id="b088138c"><span class="ne-text">调度</span></h2><p id="db46aa2e41d292eabf878a29ae6e1eb9" class="ne-p"><br></p><p id="ac80db1c477dc4d61938c67e1e24cf4e" class="ne-p"><span class="ne-text">当一个计算机是多道程序设计系统时，会频繁的有很多进程或者线程来同时竞争 CPU 时间片。当两个或两个以上的进程/线程处于就绪状态时，就会发生这种情况。如果只有一个 CPU 可用，那么必须选择接下来哪个进程/线程可以运行。操作系统中有一个叫做 </span><code class="ne-code"><span class="ne-text">调度程序(scheduler)</span></code><span class="ne-text"> 的角色存在，它就是做这件事儿的，该程序使用的算法叫做 </span><code class="ne-code"><span class="ne-text">调度算法(scheduling algorithm)</span></code><span class="ne-text"> 。</span></p><p id="1ff7123ceb621d6eaa21f166661d48b5" class="ne-p"><br></p><h3 id="3b22ed94"><span class="ne-text">调度算法的分类</span></h3><p id="0536eab6c3f4f86d8c9e1eb4c2caa9ce" class="ne-p"><br></p><p id="50c7a2aa3ff0a2a07aaaabc9d81745d1" class="ne-p"><span class="ne-text">毫无疑问，不同的环境下需要不同的调度算法。之所以出现这种情况，是因为不同的应用程序和不同的操作系统有不同的目标。也就是说，在不同的系统中，调度程序的优化也是不同的。这里有必要划分出三种环境</span></p><p id="df6c20d6e0a6232273f0d1601c76cabd" class="ne-p"><br></p><ul class="ne-ul"><li id="0d3206be3b8ae11db093294df323407e"><code class="ne-code"><span class="ne-text">批处理(Batch)</span></code><span class="ne-text"> : 商业领域</span></li><li id="e9309e368b52d8797ac81aed29cd060e"><code class="ne-code"><span class="ne-text">交互式(Interactive)</span></code><span class="ne-text"> ： 交互式用户环境</span></li></ul><ul class="ne-ul"><li id="efe0fd41056503e2ca46a96cc1fbf80a"><code class="ne-code"><span class="ne-text">实时(Real time)</span></code></li></ul><p id="630e123e440c743aa695a6f16637ef25" class="ne-p"><br></p><h3 id="cc6a2057"><span class="ne-text">批处理中的调度</span></h3><p id="337455c979553991e97c1bdf5f17b0ec" class="ne-p"><br></p><p id="abd9e19e95f4d0564da8037374dd3741" class="ne-p"><span class="ne-text">现在让我们把目光从一般性的调度转换为特定的调度算法。下面我们会探讨在批处理中的调度。</span></p><p id="7dc9c8578156af1d69a73bd6804b3cdf" class="ne-p"><br></p><h4 id="400c234c"><span class="ne-text">先来先服务</span></h4><p id="50d75b4163179fa5fa7fc840e8287dc1" class="ne-p"><br></p><p id="52ddec5249cbe7ff90aa61f7d024e8d0" class="ne-p"><span class="ne-text">最简单的非抢占式调度算法的设计就是 </span><code class="ne-code"><span class="ne-text">先来先服务(first-come,first-serverd)</span></code><span class="ne-text">。当第一个任务从外部进入系统时，将会立即启动并允许运行任意长的时间。它不会因为运行时间太长而中断。当其他作业进入时，它们排到就绪队列尾部。当正在运行的进程阻塞，处于等待队列的第一个进程就开始运行。当一个阻塞的进程重新处于就绪态时，它会像一个新到达的任务，会排在队列的末尾，即排在所有进程最后。</span></p><p id="16c8c47a7ed1c45b2de1234c1bb04c16" class="ne-p"><br></p><p id="95d765b412db9d37d883066bcc827d68" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829697-a9e6978f-5f26-4491-8a57-4691ea81546b.png" width="709" id="fZNys" class="ne-image"></p><p id="d04f25840bac9f45b0816d3340b83e6f" class="ne-p"><br></p><p id="366e0b92b10f32bf06f3957591c4d306" class="ne-p"><span class="ne-text">这个算法的强大之处在于易于理解和编程，在这个算法中，一个单链表记录了所有就绪进程。要选取一个进程运行，只要从该队列的头部移走一个进程即可；要添加一个新的作业或者阻塞一个进程，只要把这个作业或进程附加在队列的末尾即可。这是很简单的一种实现。</span></p><p id="c90bc0690170107bb9cc1bfcf44a1869" class="ne-p"><br></p><h4 id="6b3d276b"><span class="ne-text">最短作业优先</span></h4><p id="7ae3f2475901cff482d976aea0dcce3d" class="ne-p"><br></p><p id="468e7a05528290bbd0be1d2d98c139b5" class="ne-p"><span class="ne-text">批处理中，第二种调度算法是 </span><code class="ne-code"><span class="ne-text">最短作业优先(Shortest Job First)</span></code><span class="ne-text">，我们假设运行时间已知。例如，一家保险公司，因为每天要做类似的工作，所以人们可以相当精确地预测处理 1000 个索赔的一批作业需要多长时间。当输入队列中有若干个同等重要的作业被启动时，调度程序应使用最短优先作业算法</span></p><p id="bbea4d15d597e1b2dbbcb2ec89f4bb11" class="ne-p"><br></p><p id="a517b18d42d12e1b8a78a7509be7885f" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829752-b3677366-5828-45be-9c62-d182dce0a26e.png" width="695" id="LgBd9" class="ne-image"></p><p id="f1c689fa90494cf32bd7f6aec4ba09af" class="ne-p"><br></p><div class="ne-quote"><p id="b6c055d28c6fdd14f00876b918817a67" class="ne-p"><span class="ne-text">需要注意的是，在所有的进程都可以运行的情况下，最短作业优先的算法才是最优的。</span></p></div><p id="3a11d311f7f2e5161f91e1442bf04adc" class="ne-p"><br></p><h4 id="0333fbb6"><span class="ne-text">最短剩余时间优先</span></h4><p id="92ead72ad4d93735b706d26474e6a2e4" class="ne-p"><br></p><p id="de6d4308827fa52aa18b1fc1eb0c02db" class="ne-p"><span class="ne-text">最短作业优先的抢占式版本被称作为 </span><code class="ne-code"><span class="ne-text">最短剩余时间优先(Shortest Remaining Time Next)</span></code><span class="ne-text"> 算法。使用这个算法，调度程序总是选择剩余运行时间最短的那个进程运行。</span></p><p id="b3ae427a7dda06a6f658ab859d284ec9" class="ne-p"><br></p><h3 id="3741716d"><span class="ne-text">交互式系统中的调度</span></h3><p id="422ebaab9625add00d44934dd813586f" class="ne-p"><br></p><p id="5137e8748df6e262c0ad40bc23d1ac26" class="ne-p"><span class="ne-text">交互式系统中在个人计算机、服务器和其他系统中都是很常用的，所以有必要来探讨一下交互式调度</span></p><p id="b7b5379045dd5e6e2189718effe74ae0" class="ne-p"><br></p><h4 id="8bea3bc8"><span class="ne-text">轮询调度</span></h4><p id="c5e4cc242c8c1a6b1a380f5ffb966ab1" class="ne-p"><br></p><p id="26df182ec60081d548dae5cbd53321de" class="ne-p"><span class="ne-text">一种最古老、最简单、最公平并且最广泛使用的算法就是 </span><code class="ne-code"><span class="ne-text">轮询算法(round-robin)</span></code><span class="ne-text">。每个进程都会被分配一个时间段，称为</span><code class="ne-code"><span class="ne-text">时间片(quantum)</span></code><span class="ne-text">，在这个时间片内允许进程运行。如果时间片结束时进程还在运行的话，则抢占一个 CPU 并将其分配给另一个进程。如果进程在时间片结束前阻塞或结束，则 CPU 立即进行切换。轮询算法比较容易实现。调度程序所做的就是维护一个可运行进程的列表，就像下图中的 a，当一个进程用完时间片后就被移到队列的末尾，就像下图的 b。</span></p><p id="2a48ba8c954dab1a6cbe6acc552135f3" class="ne-p"><br></p><p id="ad704eaa039166852e0fd5cd8ee74b31" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829772-8a1f4a69-9934-4cf9-b1bd-80a69f410e13.png" width="724" id="Zwr0C" class="ne-image"></p><p id="a0dd0fcd6b9dfa625206206a78e03ac6" class="ne-p"><br></p><h4 id="88650772"><span class="ne-text">优先级调度</span></h4><p id="59456b117bfb3b8f23d61c02b4b66490" class="ne-p"><br></p><p id="2286b41a5fbc982ed667d87f5fb1518f" class="ne-p"><span class="ne-text">轮询调度假设了所有的进程是同等重要的。但事实情况可能不是这样。例如，在一所大学中的等级制度，首先是院长，然后是教授、秘书、后勤人员，最后是学生。这种将外部情况考虑在内就实现了</span><code class="ne-code"><span class="ne-text">优先级调度(priority scheduling)</span></code></p><p id="a4784b0754fc345730f6757657160021" class="ne-p"><br></p><p id="c011fa04b7f2812398f076cb4e99b1fd" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829781-669962be-9966-4de1-be47-f3e9822459eb.png" width="678" id="Lt9Nc" class="ne-image"></p><p id="417688711448227baa00b80a4ddecb3f" class="ne-p"><br></p><p id="c6dc6554e74b480c52c7a694b6a90a73" class="ne-p"><span class="ne-text">它的基本思想很明确，每个进程都被赋予一个优先级，优先级高的进程优先运行。</span></p><p id="9121719585434ff2f0a1fca66a3e46d5" class="ne-p"><br></p><h4 id="edc1014b"><span class="ne-text">多级队列</span></h4><p id="6e60cd02590664c4b1a39db6543af092" class="ne-p"><br></p><p id="017210b6aad11b943d3912c5cffa57e5" class="ne-p"><span class="ne-text">最早使用优先级调度的系统是 </span><code class="ne-code"><span class="ne-text">CTSS(Compatible TimeSharing System)</span></code><span class="ne-text">。CTSS 在每次切换前都需要将当前进程换出到磁盘，并从磁盘上读入一个新进程。为 CPU 密集型进程设置较长的时间片比频繁地分给他们很短的时间要更有效（减少交换次数）。另一方面，如前所述，长时间片的进程又会影响到响应时间，解决办法是设置优先级类。属于最高优先级的进程运行一个时间片，次高优先级进程运行 2 个时间片，再下面一级运行 4 个时间片，以此类推。当一个进程用完分配的时间片后，它被移到下一类。</span></p><p id="bae603c7682382f7e3af58359797cb99" class="ne-p"><br></p><h4 id="9e5db475"><span class="ne-text">最短进程优先</span></h4><p id="d3fd5aec5606c3f51805ab6ba705c676" class="ne-p"><br></p><p id="c1612c156911dcadfd48e601dc6cff0a" class="ne-p"><span class="ne-text">最短进程优先是根据进程过去的行为进行推测，并执行估计运行时间最短的那一个。假设每个终端上每条命令的预估运行时间为 </span><code class="ne-code"><span class="ne-text">T0</span></code><span class="ne-text">，现在假设测量到其下一次运行时间为 </span><code class="ne-code"><span class="ne-text">T1</span></code><span class="ne-text">，可以用两个值的加权来改进估计时间，即</span><code class="ne-code"><span class="ne-text">aT0+ (1- 1)T1</span></code><span class="ne-text">。通过选择 a 的值，可以决定是尽快忘掉老的运行时间，还是在一段长时间内始终记住它们。当 a = 1/2 时，可以得到下面这个序列</span></p><p id="6769b00d23ae9769141733ed8b1fcd6d" class="ne-p"><br></p><p id="091226d35ecf107e9b32444780d14bcc" class="ne-p"><span class="ne-text">![image-20200220120452410](/Users/mr.l/Library/Application Support/typora-user-images/image-20200220120452410.png)</span></p><p id="c46a33578ba15bf3a896acf4a7439d4b" class="ne-p"><br></p><p id="b84ae544ee7149cb676643c21f7c4002" class="ne-p"><span class="ne-text">可以看到，在三轮过后，T0 在新的估计值中所占比重下降至 1/8。</span></p><p id="a1f413692778469baa56acbd5ffcf6d0" class="ne-p"><br></p><h4 id="5abf2b05"><span class="ne-text">保证调度</span></h4><p id="01ce9b320999207d18ddc9192f428dbc" class="ne-p"><br></p><p id="8a68e211434a7f5613ac4f8218909916" class="ne-p"><span class="ne-text">一种完全不同的调度方法是对用户做出明确的性能保证。一种实际而且容易实现的保证是：若用户工作时有 n 个用户登录，则每个用户将获得 CPU 处理能力的 1/n。类似地，在一个有 n 个进程运行的单用户系统中，若所有的进程都等价，则每个进程将获得 1/n 的 CPU 时间。</span></p><p id="bad28048c33e866f65513743c9071379" class="ne-p"><br></p><h4 id="6d170350"><span class="ne-text">彩票调度</span></h4><p id="1ec63cbf9f419d479434f9b178b91ee5" class="ne-p"><br></p><p id="c994c1728228b0f8690b76ebfde67d27" class="ne-p"><span class="ne-text">对用户进行承诺并在随后兑现承诺是一件好事，不过很难实现。但是存在着一种简单的方式，有一种既可以给出预测结果而又有一种比较简单的实现方式的算法，就是 </span><code class="ne-code"><span class="ne-text">彩票调度(lottery scheduling)</span></code><span class="ne-text">算法。</span></p><p id="7a64ea69d571753adc711f3065ec5eb9" class="ne-p"><br></p><p id="009f3b9dc6647cecef4e0f5e64e84e09" class="ne-p"><span class="ne-text">其基本思想是为进程提供各种系统资源（例如 CPU 时间）的彩票。当做出一个调度决策的时候，就随机抽出一张彩票，拥有彩票的进程将获得该资源。在应用到 CPU 调度时，系统可以每秒持有 50 次抽奖，每个中奖者将获得比如 20 毫秒的 CPU 时间作为奖励。</span></p><p id="21e629b1eaa9fcd18efe030f5360b954" class="ne-p"><br></p><h4 id="f52d1789"><span class="ne-text">公平分享调度</span></h4><p id="454ce166479faf6b0bac6a5a1d950fc0" class="ne-p"><br></p><p id="3e7328aa85fbda7ea81e5451ecd63f55" class="ne-p"><span class="ne-text">到目前为止，我们假设被调度的都是各个进程自身，而不用考虑该进程的拥有者是谁。结果是，如果用户 1 启动了 9 个进程，而用户 2 启动了一个进程，使用轮转或相同优先级调度算法，那么用户 1 将得到 90 % 的 CPU 时间，而用户 2 将之得到 10 % 的 CPU 时间。</span></p><p id="247ab6cb450a5c6c2432cec96ed7ec6e" class="ne-p"><br></p><p id="a8997400e66c5b2d256fccc7ea3776bf" class="ne-p"><span class="ne-text">为了阻止这种情况的出现，一些系统在调度前会把进程的拥有者考虑在内。在这种模型下，每个用户都会分配一些CPU 时间，而调度程序会选择进程并强制执行。因此如果两个用户每个都会有 50% 的 CPU 时间片保证，那么无论一个用户有多少个进程，都将获得相同的 CPU 份额。</span></p><p id="25cfa5c1dd3833edf698f7172bb0cd48" class="ne-p"><br></p><p id="8a2de1e6a6957d4a3a1cd8ddd4f15cf3" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829805-f1649640-92c0-4cc0-9d11-d33091868df3.png" width="681" id="s6DG8" class="ne-image"></p><p id="a71b4648e92abc3a0a98e890305bbfc7" class="ne-p"><br></p><h3 id="e87fdf39"><span class="ne-text">实时系统中的调度</span></h3><p id="65e73472811dc36880ee811fac3bfc94" class="ne-p"><br></p><p id="2f7c753cdac04c87a34af91ae1219692" class="ne-p"><code class="ne-code"><span class="ne-text">实时系统(real-time)</span></code><span class="ne-text"> 是一个时间扮演了重要作用的系统。实时系统可以分为两类，</span><code class="ne-code"><span class="ne-text">硬实时(hard real time)</span></code><span class="ne-text"> 和 </span><code class="ne-code"><span class="ne-text">软实时(soft real time)</span></code><span class="ne-text"> 系统，前者意味着必须要满足绝对的截止时间；后者的含义是虽然不希望偶尔错失截止时间，但是可以容忍。</span></p><p id="670523a1b5511e2dbbe7df30ea900b9d" class="ne-p"><br></p><p id="f974b8ccc4e8617c2d30cf67ec750345" class="ne-p"><span class="ne-text">实时系统中的事件可以按照响应方式进一步分类为</span><code class="ne-code"><span class="ne-text">周期性(以规则的时间间隔发生)</span></code><span class="ne-text">事件或 </span><code class="ne-code"><span class="ne-text">非周期性(发生时间不可预知)</span></code><span class="ne-text">事件。一个系统可能要响应多个周期性事件流，根据每个事件处理所需的时间，可能甚至无法处理所有事件。例如，如果有 m 个周期事件，事件 i 以周期 Pi 发生，并需要 Ci 秒 CPU 时间处理一个事件，那么可以处理负载的条件是</span></p><p id="d8cf2cf43fb9725d8547f64247372780" class="ne-p"><br></p><p id="0d5983b3ee8a785dc8f03c345ec7a943" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829813-d541b483-e6c2-4e61-b29d-faf9719ce83f.png" width="180" id="ufEZW" class="ne-image"></p><p id="97acdb638c547195b6ef846c1e51b89f" class="ne-p"><br></p><p id="ef8f27436da7fb3f3e483c323e3bf505" class="ne-p"><span class="ne-text">只有满足这个条件的实时系统称为</span><code class="ne-code"><span class="ne-text">可调度的</span></code><span class="ne-text">，这意味着它实际上能够被实现。一个不满足此检验标准的进程不能被调度，因为这些进程共同需要的 CPU 时间总和大于 CPU 能提供的时间。</span></p><p id="253e9dd88734332a7e277657f4bbe7aa" class="ne-p"><br></p><p id="84fb8043025bc72a7a331f4b2038fec9" class="ne-p"><span class="ne-text">下面我们来了解一下内存管理，你需要知道的知识点如下</span></p><p id="be344a47b1bc97136a272661dcae26ab" class="ne-p"><br></p><p id="08d4a9f1f09106f5567bc8cd8ce5f2ea" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829871-ad9be6cd-aa53-4acc-b245-5dd76199a6ba.png" width="742" id="qZ8YJ" class="ne-image"></p><p id="897f56e4266d6ddefb7a80f14fdc066f" class="ne-p"><br></p><h2 id="f8c25083"><span class="ne-text">地址空间</span></h2><p id="bde8f9f383388c601478c74a93453ac7" class="ne-p"><br></p><p id="ec6517c213e0ba8f57072f457233836a" class="ne-p"><span class="ne-text">如果要使多个应用程序同时运行在内存中，必须要解决两个问题：</span><code class="ne-code"><span class="ne-text">保护</span></code><span class="ne-text">和 </span><code class="ne-code"><span class="ne-text">重定位</span></code><span class="ne-text">。第一种解决方式是用</span><code class="ne-code"><span class="ne-text">保护密钥标记内存块</span></code><span class="ne-text">，并将执行过程的密钥与提取的每个存储字的密钥进行比较。这种方式只能解决第一种问题（破坏操作系统），但是不能解决多进程在内存中同时运行的问题。</span></p><p id="5a59697a4c5abbfa70470c3bd42ae884" class="ne-p"><br></p><p id="edaf48dfdb5c68281fed3d81ca91c83e" class="ne-p"><span class="ne-text">还有一种更好的方式是创造一个存储器抽象：</span><code class="ne-code"><span class="ne-text">地址空间(the address space)</span></code><span class="ne-text">。就像进程的概念创建了一种抽象的 CPU 来运行程序，地址空间也创建了一种抽象内存供程序使用。</span></p><p id="8b864388ad7cbe940f6df98cf8047f40" class="ne-p"><br></p><h4 id="dc58b76e"><span class="ne-text">基址寄存器和变址寄存器</span></h4><p id="688b9c8ffedbb24b760571665f734e30" class="ne-p"><br></p><p id="34958411ca47c301b7e17928791bbede" class="ne-p"><span class="ne-text">最简单的办法是使用</span><code class="ne-code"><span class="ne-text">动态重定位(dynamic relocation)</span></code><span class="ne-text">技术，它就是通过一种简单的方式将每个进程的地址空间映射到物理内存的不同区域。还有一种方式是使用基址寄存器和变址寄存器。</span></p><p id="aa38b2f5d51810e34c165ded7b78d47d" class="ne-p"><br></p><ul class="ne-ul"><li id="e880fdf6fcd3d032a4341180b8593207"><span class="ne-text">基址寄存器：存储数据内存的起始位置</span></li><li id="d832ace055abe375212e5ebc6c6de94c"><span class="ne-text">变址寄存器：存储应用程序的长度。</span></li></ul><p id="85d454c1417111a0069356a762f1ad16" class="ne-p"><br></p><p id="c96b02a131713a5288237b39959a7848" class="ne-p"><span class="ne-text">每当进程引用内存以获取指令或读取、写入数据时，CPU 都会自动将</span><code class="ne-code"><span class="ne-text">基址值</span></code><span class="ne-text">添加到进程生成的地址中，然后再将其发送到内存总线上。同时，它检查程序提供的地址是否大于或等于</span><code class="ne-code"><span class="ne-text">变址寄存器</span></code><span class="ne-text"> 中的值。如果程序提供的地址要超过变址寄存器的范围，那么会产生错误并中止访问。</span></p><p id="657477406dfb1d962867bf48ef305165" class="ne-p"><br></p><h3 id="4c736ad5"><span class="ne-text">交换技术</span></h3><p id="2fc583f502358c13597da6fff3de80fd" class="ne-p"><br></p><p id="8c95f9eaf3a6186e888348475003c367" class="ne-p"><span class="ne-text">在程序运行过程中，经常会出现内存不足的问题。</span></p><p id="ddf8522ed4c5cc50a55556b7984536bc" class="ne-p"><br></p><p id="8938c8e1fd6a3f0862e0a2c359b11055" class="ne-p"><span class="ne-text">针对上面内存不足的问题，提出了两种处理方式：最简单的一种方式就是</span><code class="ne-code"><span class="ne-text">交换(swapping)</span></code><span class="ne-text">技术，即把一个进程完整的调入内存，然后再内存中运行一段时间，再把它放回磁盘。空闲进程会存储在磁盘中，所以这些进程在没有运行时不会占用太多内存。另外一种策略叫做</span><code class="ne-code"><span class="ne-text">虚拟内存(virtual memory)</span></code><span class="ne-text">，虚拟内存技术能够允许应用程序部分的运行在内存中。下面我们首先先探讨一下交换</span></p><p id="3ad35936eb8cb28c5c2fa936042097bd" class="ne-p"><br></p><h4 id="7e402db3"><span class="ne-text">交换过程</span></h4><p id="4d79d791ebde11eac836417d99a83a32" class="ne-p"><br></p><p id="de4f76e258b0deaab8ec99cb01bfa6ef" class="ne-p"><span class="ne-text">下面是一个交换过程</span></p><p id="716222faf1c7f3ed190c4114812ce6f8" class="ne-p"><br></p><p id="6ccc90eceb94b75a14c9d216c722138a" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829844-31f0d41e-db06-4f4a-86d4-15250999e2dd.png" width="724" id="PM0yA" class="ne-image"></p><p id="dc7cc2c39c8d3f304020512f8ff9b9bc" class="ne-p"><br></p><p id="996bc77c0dba2ac7b6d7396b4b5ca492" class="ne-p"><span class="ne-text">刚开始的时候，只有进程 A 在内存中，然后从创建进程 B 和进程 C 或者从磁盘中把它们换入内存，然后在图 d 中，A 被换出内存到磁盘中，最后 A 重新进来。因为图 g 中的进程 A 现在到了不同的位置，所以在装载过程中需要被重新定位，或者在交换程序时通过软件来执行；或者在程序执行期间通过硬件来重定位。基址寄存器和变址寄存器就适用于这种情况。</span></p><p id="85a1527560367b27f342301a635faa1d" class="ne-p"><br></p><p id="25bb57681bc250f1818434d7d35b4930" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829879-4fde9a55-0c36-4d7d-948a-49841539d0c8.png" width="696" id="SC4tr" class="ne-image"></p><p id="4acee99ad01bb62a54a2e2bd553446b8" class="ne-p"><br></p><p id="2d984474d589be5f5955c2ce294ec16e" class="ne-p"><span class="ne-text">交换在内存创建了多个 </span><code class="ne-code"><span class="ne-text">空闲区(hole)</span></code><span class="ne-text">，内存会把所有的空闲区尽可能向下移动合并成为一个大的空闲区。这项技术称为</span><code class="ne-code"><span class="ne-text">内存紧缩(memory compaction)</span></code><span class="ne-text">。但是这项技术通常不会使用，因为这项技术会消耗很多 CPU 时间。</span></p><p id="b28c8d2e8428888c6adf339dc61047f2" class="ne-p"><br></p><h3 id="6bbc8b2f"><span class="ne-text">空闲内存管理</span></h3><p id="6fd3637e0cb8f6d3d237425a70b8067f" class="ne-p"><br></p><p id="2050198cea7f2d6fa1fddd5ac13c4444" class="ne-p"><span class="ne-text">在进行内存动态分配时，操作系统必须对其进行管理。大致上说，有两种监控内存使用的方式</span></p><p id="79f8b96bcfca73171c3a49ff9cfbf205" class="ne-p"><br></p><ul class="ne-ul"><li id="e72421e316cd2ca7ca62cdeb089ee797"><code class="ne-code"><span class="ne-text">位图(bitmap)</span></code></li><li id="363344e59979446380ae415574aa7cd0"><code class="ne-code"><span class="ne-text">空闲列表(free lists)</span></code></li></ul><p id="b610fbf0037c478e4c50c66707220a71" class="ne-p"><br></p><h4 id="bcd570ff"><span class="ne-text">使用位图的存储管理</span></h4><p id="1b793a00e7d2c49c89beb25f52ff969b" class="ne-p"><br></p><p id="01106bad7b2d039f9d53f44c574b3c78" class="ne-p"><span class="ne-text">使用位图方法时，内存可能被划分为小到几个字或大到几千字节的分配单元。每个分配单元对应于位图中的一位，0 表示空闲， 1 表示占用（或者相反）。一块内存区域和其对应的位图如下</span></p><p id="f9fd09e0470dab41be4f170ebe495874" class="ne-p"><br></p><p id="d2fd7e81e8fd6d19e6bc81d1ea9dbb09" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829887-83af6188-e02c-4437-8739-40021e8a2957.png" width="734" id="uirOM" class="ne-image"></p><p id="6579c3b5ec2bf6680f8a53ad590b2b3f" class="ne-p"><br></p><p id="0bad0d7b6f984dfeb8fb7d633878dc75" class="ne-p"><code class="ne-code"><span class="ne-text">位图</span></code><span class="ne-text">提供了一种简单的方法在固定大小的内存中跟踪内存的使用情况，因为</span><strong><span class="ne-text">位图的大小取决于内存和分配单元的大小</span></strong><span class="ne-text">。这种方法有一个问题是，当决定为把具有 k 个分配单元的进程放入内存时，</span><code class="ne-code"><span class="ne-text">内容管理器(memory manager)</span></code><span class="ne-text"> 必须搜索位图，在位图中找出能够运行 k 个连续 0 位的串。在位图中找出制定长度的连续 0 串是一个很耗时的操作，这是位图的缺点。（可以简单理解为在杂乱无章的数组中，找出具有一大长串空闲的数组单元）</span></p><p id="eb3f59ae4a980fa5ed18835d708de977" class="ne-p"><br></p><h4 id="467e29df"><span class="ne-text">使用链表进行管理</span></h4><p id="0ba53562a3e5d7f756273229624888b1" class="ne-p"><br></p><p id="65daec3f55e2fb306b3bd1ea1f8ec09e" class="ne-p"><span class="ne-text">另一种记录内存使用情况的方法是，维护一个记录已分配内存段和空闲内存段的链表，段会包含进程或者是两个进程的空闲区域。可用上面的图 c </span><strong><span class="ne-text">来表示内存的使用情况</span></strong><span class="ne-text">。链表中的每一项都可以代表一个 </span><code class="ne-code"><span class="ne-text">空闲区(H)</span></code><span class="ne-text"> 或者是</span><code class="ne-code"><span class="ne-text">进程(P)</span></code><span class="ne-text">的起始标志，长度和下一个链表项的位置。</span></p><p id="7492aba8e2e2a0b00bddc1bba083dec4" class="ne-p"><br></p><p id="2f92da5d9f5567454cc1afc04526ce0b" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829908-832c7960-d7cc-45fc-a029-b803b86a6bf9.png" width="695" id="ZQMqP" class="ne-image"></p><p id="f407fecb833a46515b987fd8965b5866" class="ne-p"><br></p><p id="0dbfeeb82b221eef296e1b1d55fac093" class="ne-p"><span class="ne-text">当按照地址顺序在链表中存放进程和空闲区时，有几种算法可以为创建的进程（或者从磁盘中换入的进程）分配内存。我们先假设内存管理器知道应该分配多少内存，最简单的算法是使用 </span><code class="ne-code"><span class="ne-text">首次适配(first fit)</span></code><span class="ne-text">。内存管理器会沿着段列表进行扫描，直到找个一个足够大的空闲区为止。 除非空闲区大小和要分配的空间大小一样，否则将空闲区分为两部分，一部分供进程使用；一部分生成新的空闲区。首次适配算法是一种速度很快的算法，因为它会尽可能的搜索链表。</span></p><p id="750c592d1471e8b63a925fb723ea5093" class="ne-p"><br></p><p id="b4c3aa0ee2ac733daa864079298d1186" class="ne-p"><span class="ne-text">首次适配的一个小的变体是 </span><code class="ne-code"><span class="ne-text">下次适配(next fit)</span></code><span class="ne-text">。它和首次匹配的工作方式相同，只有一个不同之处那就是下次适配在每次找到合适的空闲区时就会记录当时的位置，以便下次寻找空闲区时从上次结束的地方开始搜索，而不是像首次匹配算法那样每次都会从头开始搜索。</span></p><p id="a21e47b580db1794269936af697ac5b6" class="ne-p"><br></p><p id="154349d0e6d25598125edd960c601f1a" class="ne-p"><span class="ne-text">另外一个著名的并且广泛使用的算法是 </span><code class="ne-code"><span class="ne-text">最佳适配(best fit)</span></code><span class="ne-text">。最佳适配会从头到尾寻找整个链表，找出能够容纳进程的最小空闲区。</span></p><p id="c0239fb5654f6172a04ffc454db60829" class="ne-p"><br></p><h2 id="84429675"><span class="ne-text">虚拟内存</span></h2><p id="a52e80a7a17362a2071a9ac3d43c6331" class="ne-p"><br></p><p id="a3b16b4a43fc377a78e20e68d2604a84" class="ne-p"><span class="ne-text">尽管基址寄存器和变址寄存器用来创建地址空间的抽象，但是这有一个其他的问题需要解决：</span><code class="ne-code"><span class="ne-text">管理软件的不断增大(managing bloatware)</span></code><span class="ne-text">。虚拟内存的基本思想是，每个程序都有自己的地址空间，这个地址空间被划分为多个称为</span><code class="ne-code"><span class="ne-text">页面(page)</span></code><span class="ne-text">的块。每一页都是连续的地址范围。这些页被映射到物理内存，但并不是所有的页都必须在内存中才能运行程序。当程序引用到一部分在物理内存中的地址空间时，硬件会立刻执行必要的映射。当程序引用到一部分不在物理内存中的地址空间时，由操作系统负责将缺失的部分装入物理内存并重新执行失败的指令。</span></p><p id="cfc9dd2da74bf0ac8eb66cdcb2922008" class="ne-p"><br></p><h3 id="3862626c"><span class="ne-text">分页</span></h3><p id="ad408dc123ddf88a8c25c2e8c88dae85" class="ne-p"><br></p><p id="4066a9b0016b34734e2fbf3e8f54723b" class="ne-p"><span class="ne-text">大部分使用虚拟内存的系统中都会使用一种 </span><code class="ne-code"><span class="ne-text">分页(paging)</span></code><span class="ne-text"> 技术。在任何一台计算机上，程序会引用使用一组内存地址。当程序执行</span></p><p id="d759b00624e8ef1625c86e6add1eddcb" class="ne-p"><br></p><pre data-language="assembly" id="d0a4f960" class="ne-codeblock language-assembly">MOV REG,1000</pre><p id="89add3c3374d8e28c840c7bccca4a7e5" class="ne-p"><br></p><p id="96c2f3af046d1e1074a249ed5b62d8d1" class="ne-p"><span class="ne-text">这条指令时，它会把内存地址为 1000 的内存单元的内容复制到 REG 中（或者相反，这取决于计算机）。地址可以通过索引、基址寄存器、段寄存器或其他方式产生。</span></p><p id="d4405ed4f3767b04521138e8ae125763" class="ne-p"><br></p><p id="bb0d8776d1f68b804c2256cb8e6a8782" class="ne-p"><span class="ne-text">这些程序生成的地址被称为 </span><code class="ne-code"><span class="ne-text">虚拟地址(virtual addresses)</span></code><span class="ne-text"> 并形成</span><code class="ne-code"><span class="ne-text">虚拟地址空间(virtual address space)</span></code><span class="ne-text">，在没有虚拟内存的计算机上，系统直接将虚拟地址送到内存中线上，读写操作都使用同样地址的物理内存。</span><strong><span class="ne-text">在使用虚拟内存时，虚拟地址不会直接发送到内存总线上</span></strong><span class="ne-text">。相反，会使用 </span><code class="ne-code"><span class="ne-text">MMU(Memory Management Unit)</span></code><span class="ne-text"> 内存管理单元把</span><strong><span class="ne-text">虚拟地址映射为物理内存地址</span></strong><span class="ne-text">，像下图这样</span></p><p id="7af393fea8b22c962a02bb238a51bfcf" class="ne-p"><br></p><p id="26978d8cd99d410a14326508c2a49c82" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829902-6db577d7-0921-4635-82f1-62f7fe723b48.png" width="710" id="DPfTF" class="ne-image"></p><p id="920e1606a09ad135a916cc1d8ea86734" class="ne-p"><br></p><p id="d01e804e8a33f6a675e0545fe9f7dde7" class="ne-p"><span class="ne-text">下面这幅图展示了这种映射是如何工作的</span></p><p id="5aceabff0e61c0d5d5d970315896fe1e" class="ne-p"><br></p><p id="70d3b873e0804fdcc75108174659a7b5" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829922-b5a208d9-6807-4201-b95a-50c300ec3f1e.png" width="701" id="jEXGv" class="ne-image"></p><p id="b96f2dce14d08fbe8bbb54b56cb574bf" class="ne-p"><br></p><p id="dc3ab02bd9504ce5467860296b9a74d2" class="ne-p"><span class="ne-text">页表给出虚拟地址与物理内存地址之间的映射关系。每一页起始于 4096 的倍数位置，结束于 4095 的位置，所以 4K 到 8K 实际为 4096 - 8191 ，8K - 12K 就是 8192 - 12287</span></p><p id="bc7ed89c32cb3a181312532bc488d2e0" class="ne-p"><br></p><p id="a2f11223fc6e7fd34aab2e859e41b4f3" class="ne-p"><span class="ne-text">在这个例子中，我们可能有一个 16 位地址的计算机，地址从 0 - 64 K - 1，这些是</span><code class="ne-code"><span class="ne-text">虚拟地址</span></code><span class="ne-text">。然而只有 32 KB 的物理地址。所以虽然可以编写 64 KB 的程序，但是程序无法全部调入内存运行，在磁盘上必须有一个最多 64 KB 的程序核心映像的完整副本，以保证程序片段在需要时被调入内存。</span></p><p id="9596f00592eb949c69c63cbdb69b8643" class="ne-p"><br></p><h3 id="48de0fdd"><span class="ne-text">页表</span></h3><p id="857f37982ab15377827623d3d741445c" class="ne-p"><br></p><p id="3fa7e03ff8c37017d8d9354b20f1a7f6" class="ne-p"><span class="ne-text">虚拟页号可作为页表的索引用来找到虚拟页中的内容。由页表项可以找到页框号（如果有的话）。然后把页框号拼接到偏移量的高位端，以替换掉虚拟页号，形成物理地址。</span></p><p id="b804d0484cc73b4e42e4c1a16cf433bf" class="ne-p"><br></p><p id="97e874b55d764de49c180df820f441ac" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829940-3af1fa95-4f53-459f-88e6-dc9540fc58fa.png" width="726" id="gDLPK" class="ne-image"></p><p id="7d73b7251105220113cfc0e95b4dae9e" class="ne-p"><br></p><p id="063ec3cf1870ce7283f1ec520bf8725e" class="ne-p"><span class="ne-text">因此，页表的目的是把虚拟页映射到页框中。从数学上说，页表是一个函数，它的参数是虚拟页号，结果是物理页框号。</span></p><p id="7c5451128fbe624fd69dc56c6324aa00" class="ne-p"><br></p><p id="ecc02083465bab9e94b190db907b78cf" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829970-f9085cee-e3ce-49a6-a175-31095f33b104.png" width="549" id="r6cAl" class="ne-image"></p><p id="f4cbe70227438afd44c6da369ae27783" class="ne-p"><br></p><p id="ecc882e5c8595768f3b9b1a82f95c800" class="ne-p"><span class="ne-text">通过这个函数可以把虚拟地址中的虚拟页转换为页框，从而形成物理地址。</span></p><p id="d5a128f20cf5882f3e7639970691078c" class="ne-p"><br></p><h4 id="ebc1ec9d"><span class="ne-text">页表项的结构</span></h4><p id="8580345f352bef3704c4f0cfb0671d79" class="ne-p"><br></p><p id="e0361fcd123e7c408a1410e6cc45439c" class="ne-p"><span class="ne-text">下面我们探讨一下页表项的具体结构，上面你知道了页表项的大致构成，是由页框号和在/不在位构成的，现在我们来具体探讨一下页表项的构成</span></p><p id="47984eb3ee2b2f2dfa132deed0eb8316" class="ne-p"><br></p><p id="cc5c2e897e5e7b5827cdd4c67abaaa77" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829994-5ecf9cda-4a6f-418e-b786-bf4a2a05e7c3.png" width="701" id="PVew4" class="ne-image"></p><p id="4cbaab2ba9647f14311ad1df919f070b" class="ne-p"><br></p><p id="a0482db6a2673a73d8ea3e3348c44e1e" class="ne-p"><span class="ne-text">页表项的结构是与机器相关的，但是不同机器上的页表项大致相同。上面是一个页表项的构成，不同计算机的页表项可能不同，但是一般来说都是 32 位的。页表项中最重要的字段就是</span><code class="ne-code"><span class="ne-text">页框号(Page frame number)</span></code><span class="ne-text">。毕竟，页表到页框最重要的一步操作就是要把此值映射过去。下一个比较重要的就是</span><code class="ne-code"><span class="ne-text">在/不在</span></code><span class="ne-text">位，如果此位上的值是 1，那么页表项是有效的并且能够被</span><code class="ne-code"><span class="ne-text">使用</span></code><span class="ne-text">。如果此值是 0 的话，则表示该页表项对应的虚拟页面</span><code class="ne-code"><span class="ne-text">不在</span></code><span class="ne-text">内存中，访问该页面会引起一个</span><code class="ne-code"><span class="ne-text">缺页异常(page fault)</span></code><span class="ne-text">。</span></p><p id="1538e61821a53e91fd6c621fea99050c" class="ne-p"><br></p><p id="07e2267978cae7258a9ac4111b0bfac6" class="ne-p"><code class="ne-code"><span class="ne-text">保护位(Protection)</span></code><span class="ne-text"> 告诉我们哪一种访问是允许的，啥意思呢？最简单的表示形式是这个域只有一位，</span><strong><span class="ne-text">0 表示可读可写，1 表示的是只读</span></strong><span class="ne-text">。</span></p><p id="cd5113de44f663e8dcda2e73383b485f" class="ne-p"><br></p><p id="2f956dc3258cb003ac6dc16c55871787" class="ne-p"><code class="ne-code"><span class="ne-text">修改位(Modified)</span></code><span class="ne-text"> 和 </span><code class="ne-code"><span class="ne-text">访问位(Referenced)</span></code><span class="ne-text"> 会跟踪页面的使用情况。当一个页面被写入时，硬件会自动的设置修改位。修改位在页面重新分配页框时很有用。如果一个页面已经被修改过（即它是 </span><code class="ne-code"><span class="ne-text">脏</span></code><span class="ne-text"> 的），则必须把它写回磁盘。如果一个页面没有被修改过（即它是 </span><code class="ne-code"><span class="ne-text">干净</span></code><span class="ne-text">的），那么重新分配时这个页框会被直接丢弃，因为磁盘上的副本仍然是有效的。这个位有时也叫做 </span><code class="ne-code"><span class="ne-text">脏位(dirty bit)</span></code><span class="ne-text">，因为它反映了页面的状态。</span></p><p id="b79e431bca8c6a4061cff3e6e2cd7e33" class="ne-p"><br></p><p id="e4dfca25e9150ba09532a333d26042ad" class="ne-p"><code class="ne-code"><span class="ne-text">访问位(Referenced)</span></code><span class="ne-text"> 在页面被访问时被设置，不管是读还是写。这个值能够帮助操作系统在发生缺页中断时选择要淘汰的页。不再使用的页要比正在使用的页更适合被淘汰。这个位在后面要讨论的</span><code class="ne-code"><span class="ne-text">页面置换</span></code><span class="ne-text">算法中作用很大。</span></p><p id="3c02b4c632833430510ae67ff9ed4e16" class="ne-p"><br></p><p id="dbc93bd44ac1087b64e0b1d023ba34c3" class="ne-p"><span class="ne-text">最后一位用于禁止该页面被高速缓存，这个功能对于映射到设备寄存器还是内存中起到了关键作用。通过这一位可以禁用高速缓存。具有独立的 I/O 空间而不是用内存映射 I/O 的机器来说，并不需要这一位。</span></p><p id="befcfc4e20c5082a05f87de19bcd7503" class="ne-p"><br></p><h2 id="62ce86fe"><span class="ne-text">页面置换算法</span></h2><p id="dd4394f57b4886240b2c215cdd1e4631" class="ne-p"><br></p><p id="4f6a92a94c2e30c6050bfb462299a22b" class="ne-p"><span class="ne-text">下面我们就来探讨一下有哪些页面置换算法。</span></p><p id="a1b1f01ba8c41e23d328afe683dd334c" class="ne-p"><br></p><h3 id="62592cf3"><span class="ne-text">最优页面置换算法</span></h3><p id="0e512837e885309b4830226205348edd" class="ne-p"><br></p><p id="9213075cee522577cc3a7c72861ccedd" class="ne-p"><span class="ne-text">最优的页面置换算法的工作流程如下：在缺页中断发生时，这些页面之一将在下一条指令（包含该指令的页面）上被引用。其他页面则可能要到 10、100 或者 1000 条指令后才会被访问。每个页面都可以用在该页首次被访问前所要执行的指令数作为标记。</span></p><p id="60569c4b121798a3dfa3559723a85c22" class="ne-p"><br></p><p id="f652c71e4c322ab28275da1eef94b0bb" class="ne-p"><span class="ne-text">最优化的页面算法表明应该标记最大的页面。如果一个页面在 800 万条指令内不会被使用，另外一个页面在 600 万条指令内不会被使用，则置换前一个页面，从而把需要调入这个页面而发生的缺页中断推迟。计算机也像人类一样，会把不愿意做的事情尽可能的往后拖。</span></p><p id="933341d07fd0cb969e37b2921a21a1b4" class="ne-p"><br></p><p id="0b6aa11ee462069a41c30975c1369ec7" class="ne-p"><span class="ne-text">这个算法最大的问题时无法实现。当缺页中断发生时，操作系统无法知道各个页面的下一次将在什么时候被访问。这种算法在实际过程中根本不会使用。</span></p><p id="7cccf369523448e9ea1adb8b38b19c65" class="ne-p"><br></p><h3 id="f3900d0e"><span class="ne-text">最近未使用页面置换算法</span></h3><p id="84094ac7292da84c018fa4aa4de731a1" class="ne-p"><br></p><p id="48785f09a7c92dc9c6b7cb0413f2955c" class="ne-p"><span class="ne-text">为了能够让操作系统收集页面使用信息，大部分使用虚拟地址的计算机都有两个状态位，R 和 M，来和每个页面进行关联。</span><strong><span class="ne-text">每当引用页面（读入或写入）时都设置 R，写入（即修改）页面时设置 M</span></strong><span class="ne-text">，这些位包含在每个页表项中，就像下面所示</span></p><p id="893a0cfa909ed56729e771832bca703f" class="ne-p"><br></p><p id="a4c3f7d5b620ee72ed1f39cf3b0f2f9c" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830000-886bdae7-531d-42ce-86c1-970d3c0fd287.png" width="644" id="GjVza" class="ne-image"></p><p id="d91a668fe44efebe3f6df1f790f756b6" class="ne-p"><br></p><p id="cd2436ef675270bdeb27defe9bb4a987" class="ne-p"><span class="ne-text">因为每次访问时都会更新这些位，因此由</span><code class="ne-code"><span class="ne-text">硬件</span></code><span class="ne-text">来设置它们非常重要。一旦某个位被设置为 1，就会一直保持 1 直到操作系统下次来修改此位。</span></p><p id="e7a4fdba97874bdf3ba1bbbcc25d17b6" class="ne-p"><br></p><p id="cc2fe27785e322231e1760788dacd2e8" class="ne-p"><span class="ne-text">如果硬件没有这些位，那么可以使用操作系统的</span><code class="ne-code"><span class="ne-text">缺页中断</span></code><span class="ne-text">和</span><code class="ne-code"><span class="ne-text">时钟中断</span></code><span class="ne-text">机制来进行模拟。当启动一个进程时，将其所有的页面都标记为</span><code class="ne-code"><span class="ne-text">不在内存</span></code><span class="ne-text">；一旦访问任何一个页面就会引发一次缺页中断，此时操作系统就可以设置 </span><code class="ne-code"><span class="ne-text">R 位(在它的内部表中)</span></code><span class="ne-text">，修改页表项使其指向正确的页面，并设置为 </span><code class="ne-code"><span class="ne-text">READ ONLY</span></code><span class="ne-text"> 模式，然后重新启动引起缺页中断的指令。如果页面随后被修改，就会发生另一个缺页异常。从而允许操作系统设置 M 位并把页面的模式设置为 </span><code class="ne-code"><span class="ne-text">READ/WRITE</span></code><span class="ne-text">。</span></p><p id="1cdfab7830fe96b8bd64eba745fa4f54" class="ne-p"><br></p><p id="8dac468a9941b20f7d32592bf3233e15" class="ne-p"><span class="ne-text">可以用 R 位和 M 位来构造一个简单的页面置换算法：当启动一个进程时，操作系统将其所有页面的两个位都设置为 0。R 位定期的被清零（在每个时钟中断）。用来将最近未引用的页面和已引用的页面分开。</span></p><p id="6f7fbf64554353465ff29f99860787b3" class="ne-p"><br></p><p id="39bab2fdc8db36d5ebb838bbc9610a1e" class="ne-p"><span class="ne-text">当出现缺页中断后，操作系统会检查所有的页面，并根据它们的 R 位和 M 位将当前值分为四类：</span></p><p id="abc034f6c92699f9fbdd74ea4d336581" class="ne-p"><br></p><ul class="ne-ul"><li id="7f488d4df8b3c78c1612b6b90607a6ec"><span class="ne-text">第 0 类：没有引用 R，没有修改 M</span></li><li id="6e0da38d60df8303cdfb64d30e7ae9f9"><span class="ne-text">第 1 类：没有引用 R，已修改 M</span></li></ul><ul class="ne-ul"><li id="e52f9551f8862c020d85a689e7669461"><span class="ne-text">第 2 类：引用 R ，没有修改 M</span></li><li id="2098c1e2e0738f1af205e33bac18f3f8"><span class="ne-text">第 3 类：已被访问 R，已被修改 M</span></li></ul><p id="19ca51f0ab68b170e6b85ceff4a1422c" class="ne-p"><br></p><p id="55b6e4fc2dcc6d749c16ef21258bf769" class="ne-p"><span class="ne-text">尽管看起来好像无法实现第一类页面，但是当第三类页面的 R 位被时钟中断清除时，它们就会发生。时钟中断不会清除 M 位，因为需要这个信息才能知道是否写回磁盘中。清除 R 但不清除 M 会导致出现一类页面。</span></p><p id="19f438a3cf1ce096f4968e4f66c24d05" class="ne-p"><br></p><p id="3639cbe3d0887d2760c552159b6ac088" class="ne-p"><code class="ne-code"><span class="ne-text">NRU(Not Recently Used)</span></code><span class="ne-text"> 算法从编号最小的非空类中随机删除一个页面。此算法隐含的思想是，在一个时钟内（约 20 ms）淘汰一个已修改但是没有被访问的页面要比一个大量引用的未修改页面好，NRU 的主要优点是</span><strong><span class="ne-text">易于理解并且能够有效的实现</span></strong><span class="ne-text">。</span></p><p id="e69f0a756fab88cc1ab941d6eb5f0429" class="ne-p"><br></p><h3 id="ef992930"><span class="ne-text">先进先出页面置换算法</span></h3><p id="b54cfe45e7d8a2900b5ab6e37cac9c7d" class="ne-p"><br></p><p id="cedbd31bfca554665ded81b0817e03ff" class="ne-p"><span class="ne-text">另一种开销较小的方式是使用 </span><code class="ne-code"><span class="ne-text">FIFO(First-In,First-Out)</span></code><span class="ne-text"> 算法，这种类型的数据结构也适用在页面置换算法中。由操作系统维护一个所有在当前内存中的页面的链表，最早进入的放在表头，最新进入的页面放在表尾。在发生缺页异常时，会把头部的页移除并且把新的页添加到表尾。</span></p><p id="017b429504dba6c1df0a023aed81995c" class="ne-p"><br></p><h3 id="fbe44333"><span class="ne-text">第二次机会页面置换算法</span></h3><p id="dec3701d79739bc3cf2072c3170b98e4" class="ne-p"><br></p><p id="b0f6d433a3bf62769df7a29957f2f42f" class="ne-p"><span class="ne-text">我们上面学到的 FIFO 链表页面有个</span><code class="ne-code"><span class="ne-text">缺陷</span></code><span class="ne-text">，那就是出链和入链并不会进行 check </span><code class="ne-code"><span class="ne-text">检查</span></code><span class="ne-text">，这样就会容易把经常使用的页面置换出去，为了避免这一问题，我们对该算法做一个简单的修改：我们检查最老页面的 </span><code class="ne-code"><span class="ne-text">R 位</span></code><span class="ne-text">，如果是 0 ，那么这个页面就是最老的而且没有被使用，那么这个页面就会被立刻换出。如果 R 位是 1，那么就清除此位，此页面会被放在链表的尾部，修改它的装入时间就像刚放进来的一样。然后继续搜索。</span></p><p id="d6333e220f33af321d74ec854f04b55a" class="ne-p"><br></p><p id="089f8f24e153eee75e5e435a679afa1e" class="ne-p"><span class="ne-text">这种算法叫做 </span><code class="ne-code"><span class="ne-text">第二次机会(second chance)</span></code><span class="ne-text">算法，就像下面这样，我们看到页面 A 到 H 保留在链表中，并按到达内存的时间排序。</span></p><p id="a28bcb1486944b773b50fcf51df4749c" class="ne-p"><br></p><p id="fde6e179989ecc6f697670c740914dce" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830001-d17523cc-7d04-4aa5-9b91-7cb47cc26508.png" width="731" id="fCBHb" class="ne-image"></p><p id="57038d8271d2c901cbf3b2f205aa4536" class="ne-p"><br></p><p id="c231a3eb1c1ffe613e927adb3cc23dfc" class="ne-p"><span class="ne-text">a）按照先进先出的方法排列的页面；b）在时刻 20 处发生缺页异常中断并且 A 的 R 位已经设置时的页面链表。</span></p><p id="dfb82b03a7f6557807ac7332498453cc" class="ne-p"><br></p><p id="6071f4976010720b318f23a5435af7c9" class="ne-p"><span class="ne-text">假设缺页异常发生在时刻 20 处，这时最老的页面是 A ，它是在 0 时刻到达的。如果 A 的 R 位是 0，那么它将被淘汰出内存，或者把它写回磁盘（如果它已经被修改过），或者只是简单的放弃（如果它是未被修改过）。另一方面，如果它的 R 位已经设置了，则将 A 放到链表的尾部并且重新设置</span><code class="ne-code"><span class="ne-text">装入时间</span></code><span class="ne-text">为当前时刻（20 处），然后清除 R 位。然后从 B 页面开始继续搜索合适的页面。</span></p><p id="9254e5ee7d07b1644978e8fae8815ee4" class="ne-p"><br></p><p id="213128048d32400dc1be31f0854dccca" class="ne-p"><span class="ne-text">寻找第二次机会的是在最近的时钟间隔中未被访问过的页面。如果所有的页面都被访问过，该算法就会被简化为单纯的 </span><code class="ne-code"><span class="ne-text">FIFO 算法</span></code><span class="ne-text">。具体来说，假设图 a 中所有页面都设置了 R 位。操作系统将页面依次移到链表末尾，每次都在添加到末尾时清除 R 位。最后，算法又会回到页面 A，此时的 R 位已经被清除，那么页面 A 就会被执行出链处理，因此算法能够正常结束。</span></p><p id="006bfd0eee72f06883aeacf0049fb0e5" class="ne-p"><br></p><h3 id="77c3ba6e"><span class="ne-text">时钟页面置换算法</span></h3><p id="ad9e64b0208686171b28fcdaa3269f69" class="ne-p"><br></p><p id="6753b55523ed6e4fbb740e4d95f05fec" class="ne-p"><span class="ne-text">一种比较好的方式是把所有的页面都保存在一个类似钟面的环形链表中，一个表针指向最老的页面。如下图所示</span></p><p id="8ab484c60155725d209fbb22b51d2566" class="ne-p"><br></p><p id="52032f6515f4f45cee8fedf418227902" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830029-543aeeff-242c-4b6f-a9a4-87fa9b101280.png" width="669" id="Xw06o" class="ne-image"></p><p id="a537643cb2a9b195c3c6ed6460bb4427" class="ne-p"><br></p><p id="34c47bdd9eccecfd23ed6a6c98202f9e" class="ne-p"><span class="ne-text">当缺页错误出现时，算法首先检查表针指向的页面，如果它的 R 位是 0 就淘汰该页面，并把新的页面插入到这个位置，然后把表针向前移动一位；如果 R 位是 1 就清除 R 位并把表针前移一个位置。重复这个过程直到找到了一个 R 位为 0 的页面位置。了解这个算法的工作方式，就明白为什么它被称为 </span><code class="ne-code"><span class="ne-text">时钟(clokc)</span></code><span class="ne-text">算法了。</span></p><p id="2bb310c9d960a15e936ed5cd9874ca22" class="ne-p"><br></p><h3 id="a918bb5b"><span class="ne-text">最近最少使用页面置换算法</span></h3><p id="dcd37ab4af6b75e405921bbc1c037e68" class="ne-p"><br></p><p id="205663d914713ca94cf7dee4abb58f3b" class="ne-p"><span class="ne-text">在前面几条指令中频繁使用的页面和可能在后面的几条指令中被使用。反过来说，已经很久没有使用的页面有可能在未来一段时间内仍不会被使用。这个思想揭示了一个可以实现的算法：在缺页中断时，置换未使用时间最长的页面。这个策略称为 </span><code class="ne-code"><span class="ne-text">LRU(Least Recently Used)</span></code><span class="ne-text"> ，最近最少使用页面置换算法。</span></p><p id="7b1a47269ade45a6f9b444a5e67e2b4a" class="ne-p"><br></p><p id="9e365e147cef6fb0ce851d48e6498ae7" class="ne-p"><span class="ne-text">虽然 LRU 在理论上是可以实现的，但是从长远看来代价比较高。为了完全实现 LRU，会在内存中维护一个所有页面的链表，最频繁使用的页位于表头，最近最少使用的页位于表尾。困难的是在每次内存引用时更新整个链表。在链表中找到一个页面，删除它，然后把它移动到表头是一个非常耗时的操作，即使使用</span><code class="ne-code"><span class="ne-text">硬件</span></code><span class="ne-text">来实现也是一样的费时。</span></p><p id="ce5addf295db9d862f1c198299520382" class="ne-p"><br></p><h3 id="3d8761a9"><span class="ne-text">用软件模拟 LRU</span></h3><p id="37d6bfe86f6fcc86a602d5597f75e357" class="ne-p"><br></p><p id="6061c314c4be9623fa92455e73227ba8" class="ne-p"><span class="ne-text">尽管上面的 LRU 算法在原则上是可以实现的，</span><strong><span class="ne-text">但是很少有机器能够拥有那些特殊的硬件</span></strong><span class="ne-text">。上面是硬件的实现方式，那么现在考虑要用</span><code class="ne-code"><span class="ne-text">软件</span></code><span class="ne-text">来实现 LRU 。一种可以实现的方案是 </span><code class="ne-code"><span class="ne-text">NFU(Not Frequently Used，最不常用)</span></code><span class="ne-text">算法。它需要一个软件计数器来和每个页面关联，初始化的时候是 0 。在每个时钟中断时，操作系统会浏览内存中的所有页，会将每个页面的 R 位（0 或 1）加到它的计数器上。这个计数器大体上跟踪了各个页面访问的频繁程度。当缺页异常出现时，则置换计数器值最小的页面。</span></p><p id="2a6159adb02ff3cc9bce97cd9579d42e" class="ne-p"><br></p><p id="a7be3c75d28420ac502d39512cf7dc74" class="ne-p"><span class="ne-text">只需要对 NFU 做一个简单的修改就可以让它模拟 LRU，这个修改有两个步骤</span></p><p id="a1f2097df3061d1fd3dbb757d747437f" class="ne-p"><br></p><ul class="ne-ul"><li id="4bbd7f83857962a0edf2928dd13577f4"><span class="ne-text">首先，在 R 位被添加进来之前先把计数器右移一位；</span></li><li id="4583a5fcd17a9fe4311405a164d135ef"><span class="ne-text">第二步，R 位被添加到最左边的位而不是最右边的位。</span></li></ul><p id="b2717e6278239c301fbc4d9e32bb5ba8" class="ne-p"><br></p><p id="6a60486aae78656f5b1415e75528cf92" class="ne-p"><span class="ne-text">修改以后的算法称为 </span><code class="ne-code"><span class="ne-text">老化(aging)</span></code><span class="ne-text"> 算法，下图解释了老化算法是如何工作的。</span></p><p id="0e45535a1d54c69288a3c65fdd3f9eda" class="ne-p"><br></p><p id="17f0818b86d3528d2d965e22f418a75b" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830078-9cab6ac9-f2fa-4395-b8d5-57b61a80e6d3.png" width="747" id="kzyJK" class="ne-image"></p><p id="f34b569fc53d87a9b00b7727cfc529dd" class="ne-p"><br></p><p id="c81d065239846ddb58479859917fabc9" class="ne-p"><span class="ne-text">我们假设在第一个时钟周期内页面 0 - 5 的 R 位依次是 1，0，1，0，1，1，（也就是页面 0 是 1，页面 1 是 0，页面 2 是 1 这样类推）。也就是说，</span><strong><span class="ne-text">在 0 个时钟周期到 1 个时钟周期之间，0，2，4，5 都被引用了</span></strong><span class="ne-text">，从而把它们的 R 位设置为 1，剩下的设置为 0 。在相关的六个计数器被右移之后 R 位被添加到 </span><code class="ne-code"><span class="ne-text">左侧</span></code><span class="ne-text"> ，就像上图中的 a。剩下的四列显示了接下来的四个时钟周期内的六个计数器变化。</span></p><p id="499a1052524254f8661e3f408cf21aa3" class="ne-p"><br></p><div class="ne-quote"><p id="129f113f3de0adc28d4390fd9db25563" class="ne-p"><span class="ne-text">CPU正在以某个频率前进，该频率的周期称为</span><code class="ne-code"><span class="ne-text">时钟滴答</span></code><span class="ne-text">或</span><code class="ne-code"><span class="ne-text">时钟周期</span></code><span class="ne-text">。一个 100Mhz 的处理器每秒将接收100,000,000个时钟滴答。</span></p></div><p id="eaca1a1c1cedd12caea8a55b7023c5df" class="ne-p"><br></p><p id="22915b2fc6fa12c8e3283015a6e73231" class="ne-p"><span class="ne-text">当缺页异常出现时，将</span><code class="ne-code"><span class="ne-text">置换（就是移除）</span></code><span class="ne-text">计数器值最小的页面。如果一个页面在前面 4 个时钟周期内都没有被访问过，那么它的计数器应该会有四个连续的 0 ，因此它的值肯定要比前面 3 个时钟周期内都没有被访问过的页面的计数器小。</span></p><p id="6ac140bf2daf5bfd92cfe42f2385f2ff" class="ne-p"><br></p><p id="dcf4a0b873c335c26afd35584ae48010" class="ne-p"><span class="ne-text">这个算法与 LRU 算法有两个重要的区别：看一下上图中的 </span><code class="ne-code"><span class="ne-text">e</span></code><span class="ne-text">，第三列和第五列</span></p><p id="b83cb567bda1ff21e9c305d5e47b6dc1" class="ne-p"><br></p><p id="67b39e8eb31df20830950dcf649331c2" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830053-3463258f-69af-41f6-94ed-94a15761844e.png" width="763" id="BE7AZ" class="ne-image"></p><p id="0673d7e6e35f4f09d2394193508d2a05" class="ne-p"><br></p><h3 id="3b91d1a3"><span class="ne-text">工作集时钟页面置换算法</span></h3><p id="63abd06159f80e0e075790bb08d4ffed" class="ne-p"><br></p><p id="73bb03fe3aaa4adac274dc16a8d05404" class="ne-p"><span class="ne-text">当缺页异常发生后，需要扫描整个页表才能确定被淘汰的页面，因此基本工作集算法还是比较浪费时间的。一个对基本工作集算法的提升是基于时钟算法但是却使用工作集的信息，这种算法称为</span><code class="ne-code"><span class="ne-text">WSClock(工作集时钟)</span></code><span class="ne-text">。由于它的实现简单并且具有高性能，因此在实践中被广泛应用。</span></p><p id="d58ba8b46f716fecbc53ecbc4210e48b" class="ne-p"><br></p><p id="3944528a9e5d2af730bcc21a6fcbc8ab" class="ne-p"><span class="ne-text">与时钟算法一样，所需的数据结构是一个以页框为元素的循环列表，就像下面这样</span></p><p id="01d5cdf75a341e23abd1d6d52c38226f" class="ne-p"><br></p><p id="a2e7cd58c23ca108b5363f7a00477f63" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830081-e96444ca-dda9-4c3f-9af5-e0db74d03a6f.png" width="705" id="tl5hI" class="ne-image"></p><p id="2d178410b1a9f1db6d542c7530824d29" class="ne-p"><br></p><p id="de674762efef1a1d31d2a2f9116a6360" class="ne-p"><span class="ne-text"> 工作集时钟页面置换算法的操作：a) 和 b) 给出 R = 1 时所发生的情形；c) 和 d) 给出 R = 0 的例子</span></p><p id="376ca02884d8a1d9619e3a218afdf8b0" class="ne-p"><br></p><p id="63fe0e0e76165313969aad9b5a52a257" class="ne-p"><span class="ne-text">最初的时候，该表是空的。当装入第一个页面后，把它加载到该表中。随着更多的页面的加入，它们形成一个环形结构。每个表项包含来自基本工作集算法的上次使用时间，以及 R 位（已标明）和 M 位（未标明）。</span></p><p id="7e3a6f2fed60f5194bfd204102e2952d" class="ne-p"><br></p><p id="957756ce70967b23ea6854a4f43d3a03" class="ne-p"><span class="ne-text">与时钟算法一样，在每个缺页异常时，首先检查指针指向的页面。如果 R 位被是设置为 1，该页面在当前时钟周期内就被使用过，那么该页面就不适合被淘汰。然后把该页面的 R 位置为 0，指针指向下一个页面，并重复该算法。该事件序列化后的状态参见图 b。</span></p><p id="660512e597b1be7f79759c859c5ad630" class="ne-p"><br></p><p id="3131acf40f8b8061433775a713b92569" class="ne-p"><span class="ne-text">现在考虑指针指向的页面 R = 0 时会发生什么，参见图 c，如果页面的使用期限大于 t 并且页面为被访问过，那么这个页面就不会在工作集中，并且在磁盘上会有一个此页面的副本。申请重新调入一个新的页面，并把新的页面放在其中，如图 d 所示。另一方面，如果页面被修改过，就不能重新申请页面，因为这个页面在磁盘上没有有效的副本。为了避免由于调度写磁盘操作引起的进程切换，指针继续向前走，算法继续对下一个页面进行操作。毕竟，有可能存在一个老的，没有被修改过的页面可以立即使用。</span></p><p id="259f8e1c415f1f342157b2c74fa8531d" class="ne-p"><br></p><p id="c3a7464fe9b882ee84c2133203efbc8f" class="ne-p"><span class="ne-text">原则上来说，所有的页面都有可能因为</span><code class="ne-code"><span class="ne-text">磁盘I/O</span></code><span class="ne-text"> 在某个时钟周期内被调度。为了降低磁盘阻塞，需要设置一个限制，即最大只允许写回 n 个页面。一旦达到该限制，就不允许调度新的写操作。</span></p><p id="14bb94ec4633fd27809f92c905c5c4a0" class="ne-p"><br></p><p id="6b5f609cfef9d1be84780092687527ed" class="ne-p"><span class="ne-text">那么就有个问题，指针会绕一圈回到原点的，如果回到原点，它的起始点会发生什么？这里有两种情况：</span></p><p id="af605baae7a6291209d87aad111ebdde" class="ne-p"><br></p><ul class="ne-ul"><li id="be710c9c234ad6ebc9bb28abb8befd14"><span class="ne-text">至少调度了一次写操作</span></li><li id="1f5761b8fa6436255d40db750cdca12c"><span class="ne-text">没有调度过写操作</span></li></ul><p id="d327ffc3f06f2f92e3638b05eb18f99f" class="ne-p"><br></p><p id="f279a05a1c84ac5f4f42f1b687ca65e9" class="ne-p"><span class="ne-text">在第一种情况中，指针仅仅是不停的移动，寻找一个未被修改过的页面。由于已经调度了一个或者多个写操作，最终会有某个写操作完成，它的页面会被标记为未修改。置换遇到的第一个未被修改过的页面，这个页面不一定是第一个被调度写操作的页面，因为硬盘驱动程序为了优化性能可能会把写操作重排序。</span></p><p id="f975c09f26fb82689584d8824d592a03" class="ne-p"><br></p><p id="9a686c8455f99d36ff56e36cb6856304" class="ne-p"><span class="ne-text">对于第二种情况，所有的页面都在工作集中，否则将至少调度了一个写操作。由于缺乏额外的信息，最简单的方法就是置换一个未被修改的页面来使用，扫描中需要记录未被修改的页面的位置，如果不存在未被修改的页面，就选定当前页面并把它写回磁盘。</span></p><p id="22bc054ec4116393b13ced80f5f13f97" class="ne-p"><br></p><h3 id="88464125"><span class="ne-text">页面置换算法小结</span></h3><p id="c76fb75fa6f7d1c2e423f6396b4d785a" class="ne-p"><br></p><p id="a4a73b9727c0408ace20acf41c243df7" class="ne-p"><span class="ne-text">我们到现在已经研究了各种页面置换算法，现在我们来一个简单的总结，算法的总结归纳如下</span></p><table id="1b009b27" class="ne-table" style="width: 750px"><tbody><tr style="height: 33px"><td width="375"><p id="u8155d1fa" class="ne-p"><span class="ne-text">算法</span></p></td><td width="375"><p id="ub91c6a44" class="ne-p"><span class="ne-text">注释</span></p></td></tr><tr style="height: 33px"><td width="375"><p id="u9675e649" class="ne-p"><span class="ne-text">最优算法</span></p></td><td width="375"><p id="ua39abb97" class="ne-p"><span class="ne-text">不可实现，但可以用作基准</span></p></td></tr><tr style="height: 33px"><td width="375"><p id="u394e510f" class="ne-p"><span class="ne-text">NRU(最近未使用) 算法</span></p></td><td width="375"><p id="uf3d6826a" class="ne-p"><span class="ne-text">和 LRU 算法很相似</span></p></td></tr><tr style="height: 33px"><td width="375"><p id="u26c74d8a" class="ne-p"><span class="ne-text">FIFO(先进先出) 算法</span></p></td><td width="375"><p id="u7ac53964" class="ne-p"><span class="ne-text">有可能会抛弃重要的页面</span></p></td></tr><tr style="height: 33px"><td width="375"><p id="ubd2f9fd7" class="ne-p"><span class="ne-text">第二次机会算法</span></p></td><td width="375"><p id="u74ec06bd" class="ne-p"><span class="ne-text">比 FIFO 有较大的改善</span></p></td></tr><tr style="height: 33px"><td width="375"><p id="ueb91d76a" class="ne-p"><span class="ne-text">时钟算法</span></p></td><td width="375"><p id="u34def58d" class="ne-p"><span class="ne-text">实际使用</span></p></td></tr><tr style="height: 33px"><td width="375"><p id="uff3a1852" class="ne-p"><span class="ne-text">LRU(最近最少)算法</span></p></td><td width="375"><p id="u5613a15a" class="ne-p"><span class="ne-text">比较优秀，但是很难实现</span></p></td></tr><tr style="height: 33px"><td width="375"><p id="u7a5e614f" class="ne-p"><span class="ne-text">NFU(最不经常食用)算法</span></p></td><td width="375"><p id="uc4d42f56" class="ne-p"><span class="ne-text">和 LRU 很类似</span></p></td></tr><tr style="height: 33px"><td width="375"><p id="u97c1197a" class="ne-p"><span class="ne-text">老化算法</span></p></td><td width="375"><p id="u1102fb4d" class="ne-p"><span class="ne-text">近似 LRU 的高效算法</span></p></td></tr><tr style="height: 33px"><td width="375"><p id="udcc054bf" class="ne-p"><span class="ne-text">工作集算法</span></p></td><td width="375"><p id="u04210cf5" class="ne-p"><span class="ne-text">实施起来开销很大</span></p></td></tr><tr style="height: 33px"><td width="375"><p id="u9cb6c78e" class="ne-p"><span class="ne-text">工作集时钟算法</span></p></td><td width="375"><p id="uac13bd4a" class="ne-p"><span class="ne-text">比较有效的算法</span></p></td></tr></tbody></table><p id="95ce7ac6c96f2836c1da1058696564f2" class="ne-p"><br></p><ul class="ne-ul"><li id="706a0737a142822991e3b2d4119a9f68"><code class="ne-code"><span class="ne-text">最优算法</span></code><span class="ne-text">在当前页面中置换最后要访问的页面。不幸的是，没有办法来判定哪个页面是最后一个要访问的，</span><code class="ne-code"><span class="ne-text">因此实际上该算法不能使用</span></code><span class="ne-text">。然而，它可以作为衡量其他算法的标准。</span></li><li id="234dd392c4e9dd0ebf9e661f94d080f5"><code class="ne-code"><span class="ne-text">NRU</span></code><span class="ne-text"> 算法根据 R 位和 M 位的状态将页面氛围四类。从编号最小的类别中随机选择一个页面。NRU 算法易于实现，但是性能不是很好。存在更好的算法。</span></li></ul><ul class="ne-ul"><li id="c8f6c0a7d8a9df2355aa867a989f0b49"><code class="ne-code"><span class="ne-text">FIFO</span></code><span class="ne-text"> 会跟踪页面加载进入内存中的顺序，并把页面放入一个链表中。有可能删除存在时间最长但是还在使用的页面，因此这个算法也不是一个很好的选择。</span></li><li id="7fbec0a11e860f50edfed9e85c41b9f8"><code class="ne-code"><span class="ne-text">第二次机会</span></code><span class="ne-text">算法是对 FIFO 的一个修改，它会在删除页面之前检查这个页面是否仍在使用。如果页面正在使用，就会进行保留。这个改进大大提高了性能。</span></li></ul><ul class="ne-ul"><li id="ab0708a3d3cf4e9100075a87c9844641"><code class="ne-code"><span class="ne-text">时钟</span></code><span class="ne-text"> 算法是第二次机会算法的另外一种实现形式，时钟算法和第二次算法的性能差不多，但是会花费更少的时间来执行算法。</span></li><li id="416499a4e283e26c762f68ae643534cb"><code class="ne-code"><span class="ne-text">LRU</span></code><span class="ne-text"> 算法是一个非常优秀的算法，但是没有</span><code class="ne-code"><span class="ne-text">特殊的硬件(TLB)</span></code><span class="ne-text">很难实现。如果没有硬件，就不能使用 LRU 算法。</span></li></ul><ul class="ne-ul"><li id="0f2459808b7e2868c13dcbefd2ac7590"><code class="ne-code"><span class="ne-text">NFU</span></code><span class="ne-text"> 算法是一种近似于 LRU 的算法，它的性能不是非常好。</span></li><li id="f620cb928c9ef81c30cec4bd9400d7ce"><code class="ne-code"><span class="ne-text">老化</span></code><span class="ne-text"> 算法是一种更接近 LRU 算法的实现，并且可以更好的实现，因此是一个很好的选择</span></li></ul><ul class="ne-ul"><li id="69318a6d572af791c360d57906970f77"><span class="ne-text">最后两种算法都使用了工作集算法。工作集算法提供了合理的性能开销，但是它的实现比较复杂。</span><code class="ne-code"><span class="ne-text">WSClock</span></code><span class="ne-text"> 是另外一种变体，它不仅能够提供良好的性能，而且可以高效地实现。</span></li></ul><p id="d21cffc43ac7dcbfeeae73c897933787" class="ne-p"><br></p><p id="943b2ac9ccdf5bcd3ad85d6c44db2f03" class="ne-p"><span class="ne-text">总之，</span><strong><span class="ne-text">最好的算法是老化算法和WSClock算法</span></strong><span class="ne-text">。他们分别是基于 LRU 和工作集算法。他们都具有良好的性能并且能够被有效的实现。还存在其他一些好的算法，但实际上这两个可能是最重要的。</span></p><p id="70262061a374bbe6c590cdc622d20dd3" class="ne-p"><br></p><p id="318317ce1479c23add8291c2bdd17d4c" class="ne-p"><span class="ne-text">下面来聊一聊文件系统，你需要知道下面这些知识点</span></p><p id="54b70121bb60e581d442d6b45ec1f775" class="ne-p"><br></p><p id="0626228031f054313c8c68db9c55566d" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830114-09f30aaf-25b8-44c3-992a-577e4c3a833c.png" width="721" id="MOs6Q" class="ne-image"></p><p id="68aa5203572adaa78a2cacc78c181478" class="ne-p"><br></p><h2 id="2a0c4740"><span class="ne-text">文件</span></h2><p id="0e1a4d0a2da43ff7a64f39e8a2ccc002" class="ne-p"><br></p><h3 id="42b5d073"><span class="ne-text">文件命名</span></h3><p id="39eaa5bb7eaee0059fc8f8ab050013c3" class="ne-p"><br></p><p id="ac843df76f1fa5996bb18f7b8f3abeff" class="ne-p"><span class="ne-text">文件是一种抽象机制，它提供了一种方式用来存储信息以及在后面进行读取。可能任何一种机制最重要的特性就是管理对象的命名方式。在创建一个文件后，它会给文件一个命名。当进程终止时，文件会继续存在，并且其他进程可以使用</span><code class="ne-code"><span class="ne-text">名称访问该文件</span></code><span class="ne-text">。</span></p><p id="7a4f2e6c93c769b7b830ce3a98164e0a" class="ne-p"><br></p><p id="1aa170f1d7914802b5f71c9fa09eea8c" class="ne-p"><span class="ne-text">文件命名规则对于不同的操作系统来说是不一样的，但是所有现代操作系统都允许使用 1 - 8 个字母的字符串作为合法文件名。</span></p><p id="549e424671eb70506667316221ea0b6a" class="ne-p"><br></p><p id="947a29553feb4fed91e398dd0b909941" class="ne-p"><span class="ne-text">某些文件区分大小写字母，而大多数则不区分。</span><code class="ne-code"><span class="ne-text">UNIX</span></code><span class="ne-text"> 属于第一类；历史悠久的 </span><code class="ne-code"><span class="ne-text">MS-DOS</span></code><span class="ne-text"> 属于第二类（顺便说一句，尽管 MS-DOS 历史悠久，但 MS-DOS 仍在嵌入式系统中非常广泛地使用，因此它绝不是过时的）；因此，UNIX 系统会有三种不同的命名文件：</span><code class="ne-code"><span class="ne-text">maria</span></code><span class="ne-text">、</span><code class="ne-code"><span class="ne-text">Maria</span></code><span class="ne-text">、</span><code class="ne-code"><span class="ne-text">MARIA</span></code><span class="ne-text"> 。在 MS-DOS ，所有这些命名都属于相同的文件。</span></p><p id="ca90743de49e769fc630a186e1284fae" class="ne-p"><br></p><p id="a406e7618fc08a6827c4aef95651a84b" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830120-5ba4f13c-ee71-46f2-a110-e2eaf1dbf324.png" width="691" id="JHfwL" class="ne-image"></p><p id="afc97bceb18793a83e8a6d91c9533dfc" class="ne-p"><br></p><p id="6ae582e29691ea6d28dfb309f8a33d63" class="ne-p"><span class="ne-text">许多操作系统支持两部分的文件名，它们之间用 </span><code class="ne-code"><span class="ne-text">.</span></code><span class="ne-text"> 分隔开，比如文件名 </span><code class="ne-code"><span class="ne-text">prog.c</span></code><span class="ne-text">。原点后面的文件称为 </span><code class="ne-code"><span class="ne-text">文件扩展名(file extension)</span></code><span class="ne-text"> ，文件扩展名通常表示文件的一些信息。一些常用的文件扩展名以及含义如下图所示</span></p><table id="7f756c92" class="ne-table" style="width: 750px"><tbody><tr style="height: 33px"><td width="375"><p id="u86bcac8e" class="ne-p"><span class="ne-text">扩展名</span></p></td><td width="375"><p id="u7fa179fd" class="ne-p"><span class="ne-text">含义</span></p></td></tr><tr style="height: 33px"><td width="375"><p id="u3c31ee67" class="ne-p"><span class="ne-text">bak</span></p></td><td width="375"><p id="ub1009dae" class="ne-p"><span class="ne-text">备份文件</span></p></td></tr><tr style="height: 33px"><td width="375"><p id="u8e21211b" class="ne-p"><span class="ne-text">c</span></p></td><td width="375"><p id="ub7814047" class="ne-p"><span class="ne-text">c 源程序文件</span></p></td></tr><tr style="height: 33px"><td width="375"><p id="u60b4b5ca" class="ne-p"><span class="ne-text">gif</span></p></td><td width="375"><p id="uc630794d" class="ne-p"><span class="ne-text">符合图形交换格式的图像文件</span></p></td></tr><tr style="height: 33px"><td width="375"><p id="u8fc5ed2b" class="ne-p"><span class="ne-text">hlp</span></p></td><td width="375"><p id="u4100d4e1" class="ne-p"><span class="ne-text">帮助文件</span></p></td></tr><tr style="height: 33px"><td width="375"><p id="u126c4c61" class="ne-p"><span class="ne-text">html</span></p></td><td width="375"><p id="u6d6dd5e8" class="ne-p"><span class="ne-text">WWW 超文本标记语言文档</span></p></td></tr><tr style="height: 33px"><td width="375"><p id="uaf121ed5" class="ne-p"><span class="ne-text">jpg</span></p></td><td width="375"><p id="ud8de46a6" class="ne-p"><span class="ne-text">符合 JPEG 编码标准的静态图片</span></p></td></tr><tr style="height: 33px"><td width="375"><p id="udab5f881" class="ne-p"><span class="ne-text">mp3</span></p></td><td width="375"><p id="uaefb3290" class="ne-p"><span class="ne-text">符合 MP3 音频编码格式的音乐文件</span></p></td></tr><tr style="height: 33px"><td width="375"><p id="u6f6a8cf4" class="ne-p"><span class="ne-text">mpg</span></p></td><td width="375"><p id="u4e9b5a7a" class="ne-p"><span class="ne-text">符合 MPEG 编码标准的电影</span></p></td></tr><tr style="height: 33px"><td width="375"><p id="u17182b2f" class="ne-p"><span class="ne-text">o</span></p></td><td width="375"><p id="uba61755c" class="ne-p"><span class="ne-text">目标文件（编译器输出格式，尚未链接）</span></p></td></tr><tr style="height: 33px"><td width="375"><p id="uc827d007" class="ne-p"><span class="ne-text">pdf</span></p></td><td width="375"><p id="u490abaca" class="ne-p"><span class="ne-text">pdf 格式的文件</span></p></td></tr><tr style="height: 33px"><td width="375"><p id="u8deec9bc" class="ne-p"><span class="ne-text">ps</span></p></td><td width="375"><p id="u480b1c6a" class="ne-p"><span class="ne-text">PostScript 文件</span></p></td></tr><tr style="height: 33px"><td width="375"><p id="u3341c4b9" class="ne-p"><span class="ne-text">tex</span></p></td><td width="375"><p id="uef7e717f" class="ne-p"><span class="ne-text">为 TEX 格式化程序准备的输入文件</span></p></td></tr><tr style="height: 33px"><td width="375"><p id="u563e6d6d" class="ne-p"><span class="ne-text">txt</span></p></td><td width="375"><p id="u230821ad" class="ne-p"><span class="ne-text">文本文件</span></p></td></tr><tr style="height: 33px"><td width="375"><p id="u77e32004" class="ne-p"><span class="ne-text">zip</span></p></td><td width="375"><p id="u599395eb" class="ne-p"><span class="ne-text">压缩文件</span></p></td></tr></tbody></table><p id="c6ab14359737194a972479d8287c47a1" class="ne-p"><br></p><p id="4549bf524aabfd45c2fa83047348e305" class="ne-p"><span class="ne-text">在 UNIX 系统中，文件扩展名只是一种约定，操作系统并不强制采用。</span></p><p id="d4f6ff6d0e62a25ca2d68a7c83d9af63" class="ne-p"><br></p><h3 id="68d96662"><span class="ne-text">文件结构</span></h3><p id="e267d3840df18b33c8d7169b8089f9f5" class="ne-p"><br></p><p id="aab7d13a47a4100ca4968738f5dec9af" class="ne-p"><span class="ne-text">文件的构造有多种方式。下图列出了常用的三种构造方式</span></p><p id="05b429377a0f05d00edcba9ad1341ff3" class="ne-p"><br></p><p id="0eeb7da1658a82bc57977ae24dd2c8e8" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830179-1cd3ea7b-cf21-432f-a8e4-c2d8f317e0ff.png" width="728" id="HSm1k" class="ne-image"></p><p id="66e04dd599052b4626cdb9aedfdd4ce2" class="ne-p"><br></p><p id="84f276b301ae3859ddde1903c0c2b706" class="ne-p"><span class="ne-text"> 三种不同的文件。 a) 字节序列 。b) 记录序列。c) 树</span></p><p id="0e82b2e8eb49dec1dc54c30359b708b0" class="ne-p"><br></p><p id="a970ad933a1746cea41087c5b928095b" class="ne-p"><span class="ne-text">上图中的 a 是一种无结构的字节序列，操作系统不关心序列的内容是什么，操作系统能看到的就是</span><code class="ne-code"><span class="ne-text">字节(bytes)</span></code><span class="ne-text">。其文件内容的任何含义只在用户程序中进行解释。UNIX 和 Windows 都采用这种办法。</span></p><p id="715200795b1099f573c996fc4f5ade2c" class="ne-p"><br></p><p id="e40d5e148ce0e55c7c15939cc5e60d7c" class="ne-p"><span class="ne-text">图 b 表示在文件结构上的第一部改进。在这个模型中，文件是具有固定长度记录的序列，每个记录都有其内部结构。 把文件作为记录序列的核心思想是：</span><strong><span class="ne-text">读操作返回一个记录，而写操作重写或者追加一个记录</span></strong><span class="ne-text">。第三种文件结构如上图 c 所示。在这种组织结构中，文件由一颗</span><code class="ne-code"><span class="ne-text">记录树</span></code><span class="ne-text">构成，记录树的长度不一定相同，每个记录树都在记录中的固定位置包含一个</span><code class="ne-code"><span class="ne-text">key</span></code><span class="ne-text"> 字段。这棵树按 key 进行排序，从而可以对特定的 key 进行快速查找。</span></p><p id="a3805c0b27de6eb1994037fb394c695d" class="ne-p"><br></p><h3 id="28b988ce"><span class="ne-text">文件类型</span></h3><p id="dd0277dd6c9510a4288d26904622fa34" class="ne-p"><br></p><p id="700a86aaacacb207860a5ef065bfc842" class="ne-p"><span class="ne-text">很多操作系统支持多种文件类型。例如，UNIX（同样包括 OS X）和 Windows 都具有常规的文件和目录。除此之外，UNIX 还具有</span><code class="ne-code"><span class="ne-text">字符特殊文件(character special file)</span></code><span class="ne-text"> 和 </span><code class="ne-code"><span class="ne-text">块特殊文件(block special file)</span></code><span class="ne-text">。</span><code class="ne-code"><span class="ne-text">常规文件(Regular files)</span></code><span class="ne-text"> 是包含有用户信息的文件。用户一般使用的文件大都是常规文件，常规文件一般包括 </span><strong><span class="ne-text">可执行文件、文本文件、图像文件</span></strong><span class="ne-text">，从常规文件读取数据或将数据写入时，内核会根据文件系统的规则执行操作，是写入可能被延迟，记录日志或者接受其他操作。</span></p><p id="d803466fc9fe85690453543577916782" class="ne-p"><br></p><h3 id="2ca5dd51"><span class="ne-text">文件访问</span></h3><p id="1eea59f4629deed14c4bbefdb9ff560d" class="ne-p"><br></p><p id="b132fe515bd7dd759ef63c37eb082a61" class="ne-p"><span class="ne-text">早期的操作系统只有一种访问方式：</span><code class="ne-code"><span class="ne-text">序列访问(sequential access)</span></code><span class="ne-text">。在这些系统中，进程可以按照顺序读取所有的字节或文件中的记录，但是不能跳过并乱序执行它们。顺序访问文件是可以返回到起点的，需要时可以多次读取该文件。当存储介质是磁带而不是磁盘时，顺序访问文件很方便。</span></p><p id="2149db0b1f4aef60c803eb241beaceb9" class="ne-p"><br></p><p id="dce71c7fccbf2fc8964d659038be9e03" class="ne-p"><span class="ne-text">在使用磁盘来存储文件时，可以不按照顺序读取文件中的字节或者记录，或者按照关键字而不是位置来访问记录。这种能够以任意次序进行读取的称为</span><code class="ne-code"><span class="ne-text">随机访问文件(random access file)</span></code><span class="ne-text">。许多应用程序都需要这种方式。</span></p><p id="4f74717aa95a17e1fcd34889477b996a" class="ne-p"><br></p><p id="008ff964469f0ec53c27329344f05020" class="ne-p"><span class="ne-text">随机访问文件对许多应用程序来说都必不可少，例如，数据库系统。如果乘客打电话预定某航班机票，订票程序必须能够直接访问航班记录，而不必先读取其他航班的成千上万条记录。</span></p><p id="53807ed6cd70ab7d582f3dcdc0fc14c0" class="ne-p"><br></p><p id="af6c758e0caff2e1a559f009fefe473e" class="ne-p"><span class="ne-text">有两种方法可以指示从何处开始读取文件。第一种方法是直接使用 </span><code class="ne-code"><span class="ne-text">read</span></code><span class="ne-text"> 从头开始读取。另一种是用一个特殊的 </span><code class="ne-code"><span class="ne-text">seek</span></code><span class="ne-text"> 操作设置当前位置，在 seek 操作后，从这个当前位置顺序地开始读文件。UNIX 和 Windows 使用的是后面一种方式。</span></p><p id="8020d0101a5f3dcbb54621b955f23d0b" class="ne-p"><br></p><h3 id="0b81772b"><span class="ne-text">文件属性</span></h3><p id="8062f25c30a983560cb8b3e049ade111" class="ne-p"><br></p><p id="3b59c2728b8366a73b1922e7adf5feb0" class="ne-p"><span class="ne-text">文件包括文件名和数据。除此之外，所有的操作系统还会保存其他与文件相关的信息，如文件创建的日期和时间、文件大小。我们可以称这些为文件的</span><code class="ne-code"><span class="ne-text">属性(attributes)</span></code><span class="ne-text">。有些人也喜欢把它们称作 </span><code class="ne-code"><span class="ne-text">元数据(metadata)</span></code><span class="ne-text">。文件的属性在不同的系统中差别很大。文件的属性只有两种状态：</span><code class="ne-code"><span class="ne-text">设置(set)</span></code><span class="ne-text"> 和 </span><code class="ne-code"><span class="ne-text">清除(clear)</span></code><span class="ne-text">。</span></p><p id="ff3234edb116466cf8feb1acf75da02b" class="ne-p"><br></p><h3 id="52cefcb2"><span class="ne-text">文件操作</span></h3><p id="1e779b7cc62a0d85bd60f607a32dfe08" class="ne-p"><br></p><p id="de771a10ee395dd67ec222bec5fdecb7" class="ne-p"><span class="ne-text">使用文件的目的是用来存储信息并方便以后的检索。对于存储和检索，不同的系统提供了不同的操作。以下是与文件有关的最常用的一些系统调用：</span></p><p id="c0724f0565ae49c0d6b6cc475b6ac846" class="ne-p"><br></p><ol class="ne-ol"><li id="504ecd73fd5ceecb12f3932e3f9b2ca1"><code class="ne-code"><span class="ne-text">Create</span></code><span class="ne-text">，创建不包含任何数据的文件。调用的目的是表示文件即将建立，并对文件设置一些属性。</span></li><li id="179ee01cd008860de8a7a253e9d18249"><code class="ne-code"><span class="ne-text">Delete</span></code><span class="ne-text">，当文件不再需要，必须删除它以释放内存空间。为此总会有一个系统调用来删除文件。</span></li></ol><ol start="3" class="ne-ol"><li id="328a4d096282ef0c9bd3f349be56947f"><code class="ne-code"><span class="ne-text">Open</span></code><span class="ne-text">，在使用文件之前，必须先打开文件。这个调用的目的是允许系统将属性和磁盘地址列表保存到主存中，用来以后的快速访问。</span></li><li id="7c85b0b657768dc1ce22864b71e5a08e"><code class="ne-code"><span class="ne-text">Close</span></code><span class="ne-text">，当所有进程完成时，属性和磁盘地址不再需要，因此应关闭文件以释放表空间。很多系统限制进程打开文件的个数，以此达到鼓励用户关闭不再使用的文件。磁盘以块为单位写入，关闭文件时会强制写入最后一</span><code class="ne-code"><span class="ne-text">块</span></code><span class="ne-text">，即使这个块空间内部还不满。</span></li></ol><ol start="5" class="ne-ol"><li id="50bfb078134ebd8dff44c5657d8994e7"><code class="ne-code"><span class="ne-text">Read</span></code><span class="ne-text">，数据从文件中读取。通常情况下，读取的数据来自文件的当前位置。调用者必须指定需要读取多少数据，并且提供存放这些数据的缓冲区。</span></li><li id="43384bb690645e13a262e1955f177b7a"><code class="ne-code"><span class="ne-text">Write</span></code><span class="ne-text">，向文件写数据，写操作一般也是从文件的当前位置开始进行。如果当前位置是文件的末尾，则会直接追加进行写入。如果当前位置在文件中，则现有数据被覆盖，并且永远消失。</span></li></ol><ol start="7" class="ne-ol"><li id="e3f6ff74f235e372c8bbf5609d277cd8"><code class="ne-code"><span class="ne-text">append</span></code><span class="ne-text">，使用 append 只能向文件末尾添加数据。</span></li><li id="b9c24d0c6b35e2bb0b54f846c2f3cbe2"><code class="ne-code"><span class="ne-text">seek</span></code><span class="ne-text">，对于随机访问的文件，要指定从何处开始获取数据。通常的方法是用 seek 系统调用把当前位置指针指向文件中的特定位置。seek 调用结束后，就可以从指定位置开始读写数据了。</span></li></ol><ol start="9" class="ne-ol"><li id="922b6108cf62d8263fbd88c8d5498241"><code class="ne-code"><span class="ne-text">get attributes</span></code><span class="ne-text">，进程运行时通常需要读取文件属性。</span></li><li id="8c8e3ceb23d3a616b99b8b941b08aa52"><code class="ne-code"><span class="ne-text">set attributes</span></code><span class="ne-text">，用户可以自己设置一些文件属性，甚至是在文件创建之后，实现该功能的是 set attributes 系统调用。</span></li></ol><ol start="11" class="ne-ol"><li id="e72eb2d85f14c3f7ac4d9fd59c6888b7"><code class="ne-code"><span class="ne-text">rename</span></code><span class="ne-text">，用户可以自己更改已有文件的名字，rename 系统调用用于这一目的。</span></li></ol><p id="a87343eaf9d3450efabef778da123d99" class="ne-p"><br></p><h2 id="767fa455"><span class="ne-text">目录</span></h2><p id="b9343aee17ca89896a9c0199f20a54f1" class="ne-p"><br></p><p id="3c356aca639851aa2446430e0cf3733e" class="ne-p"><span class="ne-text">文件系统通常提供</span><code class="ne-code"><span class="ne-text">目录(directories)</span></code><span class="ne-text"> 或者 </span><code class="ne-code"><span class="ne-text">文件夹(folders)</span></code><span class="ne-text"> 用于记录文件的位置，在很多系统中目录本身也是文件，下面我们会讨论关于文件，他们的组织形式、属性和可以对文件进行的操作。</span></p><p id="dff0717322930d1c24e5ab4609400092" class="ne-p"><br></p><h3 id="007929bd"><span class="ne-text">一级目录系统</span></h3><p id="34540bcb72c35b535e539c2292febbbb" class="ne-p"><br></p><p id="54065234453c67a62e92fdfbb18d6e66" class="ne-p"><span class="ne-text">目录系统最简单的形式是有一个能够包含所有文件的目录。这种目录被称为</span><code class="ne-code"><span class="ne-text">根目录(root directory)</span></code><span class="ne-text">，由于根目录的唯一性，所以其名称并不重要。在最早期的个人计算机中，这种系统很常见，部分原因是因为只有一个用户。下面是一个单层目录系统的例子</span></p><p id="608cd64c499251753f32da03fb38243a" class="ne-p"><br></p><p id="487deb8f9d390dd52747ae3a2d276448" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830155-ca95d416-207a-46d6-89dd-77c398a175d3.png" width="500" id="LyUcX" class="ne-image"></p><p id="45f33aa4b012163e958412625f737ea8" class="ne-p"><br></p><p id="888aed0ab34181e2ca6fdb1bf464feae" class="ne-p"><span class="ne-text"> 含有四个文件的单层目录系统</span></p><p id="6c96f97c55ea84f77c4863a07950cfa6" class="ne-p"><br></p><p id="06c45b31715829537869cc1e51ceae82" class="ne-p"><span class="ne-text">该目录中有四个文件。这种设计的优点在于简单，并且能够快速定位文件，毕竟只有一个地方可以检索。这种目录组织形式现在一般用于简单的嵌入式设备（如数码相机和某些便携式音乐播放器）上使用。</span></p><p id="05cc9579be20bd8d9cd8382cc614bdd7" class="ne-p"><br></p><h3 id="17225630"><span class="ne-text">层次目录系统</span></h3><p id="a2f4aec9d46fbfd0fca6e2d7fbefc82e" class="ne-p"><br></p><p id="7a7f44ac2994c611f0b66c4e87c0d70e" class="ne-p"><span class="ne-text">对于简单的应用而言，一般都用单层目录方式，但是这种组织形式并不适合于现代计算机，因为现代计算机含有成千上万个文件和文件夹。如果都放在根目录下，查找起来会非常困难。为了解决这一问题，出现了</span><code class="ne-code"><span class="ne-text">层次目录系统(Hierarchical Directory Systems)</span></code><span class="ne-text">，也称为</span><code class="ne-code"><span class="ne-text">目录树</span></code><span class="ne-text">。通过这种方式，可以用很多目录把文件进行分组。进而，如果多个用户共享同一个文件服务器，比如公司的网络系统，每个用户可以为自己的目录树拥有自己的私人根目录。这种方式的组织结构如下</span></p><p id="dbf72bf64d673a9ed4ac556da2b03fc5" class="ne-p"><br></p><p id="8fd241c376d25d675006401b0450d10d" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830190-cdcd48b8-b7ca-4597-b41d-d61089e0250d.png" width="699" id="eyi1a" class="ne-image"></p><p id="595388086341aaf9ea0cc4f986c5f072" class="ne-p"><br></p><p id="1facfc7d32c49c743af569c6eac8ba13" class="ne-p"><span class="ne-text">根目录含有目录 A、B 和 C ，分别属于不同的用户，其中两个用户个字创建了</span><code class="ne-code"><span class="ne-text">子目录</span></code><span class="ne-text">。用户可以创建任意数量的子目录，现代文件系统都是按照这种方式组织的。</span></p><p id="9606d66d6cd5e0bfc4b92e125dce83ca" class="ne-p"><br></p><h3 id="26f36dea"><span class="ne-text">路径名</span></h3><p id="3c68cf4eceb1aebdebb0636d38b6d630" class="ne-p"><br></p><p id="20cf84ba39d49bdb319108dd01bd8f7c" class="ne-p"><span class="ne-text">当目录树组织文件系统时，需要有某种方法指明文件名。常用的方法有两种，第一种方式是每个文件都会用一个</span><code class="ne-code"><span class="ne-text">绝对路径名(absolute path name)</span></code><span class="ne-text">，它由根目录到文件的路径组成。</span></p><p id="7375343f1d5a3e86bc7693dec3e4e850" class="ne-p"><br></p><p id="1864d899922b43e08ec349f3b9185a11" class="ne-p"><span class="ne-text">另外一种指定文件名的方法是 </span><code class="ne-code"><span class="ne-text">相对路径名(relative path name)</span></code><span class="ne-text">。它常常和 </span><code class="ne-code"><span class="ne-text">工作目录(working directory)</span></code><span class="ne-text"> （也称作 </span><code class="ne-code"><span class="ne-text">当前目录(current directory)</span></code><span class="ne-text">）一起使用。用户可以指定一个目录作为当前工作目录。例如，如果当前目录是 </span><code class="ne-code"><span class="ne-text">/usr/ast</span></code><span class="ne-text">，那么绝对路径 </span><code class="ne-code"><span class="ne-text">/usr/ast/mailbox</span></code><span class="ne-text">可以直接使用 </span><code class="ne-code"><span class="ne-text">mailbox</span></code><span class="ne-text"> 来引用。</span></p><p id="4d86e51488f9e3357b3d1c7316d4d4ee" class="ne-p"><br></p><h3 id="20731fe2"><span class="ne-text">目录操作</span></h3><p id="72f0e76f51955e4fd5747f7f47125254" class="ne-p"><br></p><p id="5a42d88e3de5412699ce7ef46d8b0754" class="ne-p"><span class="ne-text">不同文件中管理目录的系统调用的差别比管理文件的系统调用差别大。为了了解这些系统调用有哪些以及它们怎样工作，下面给出一个例子（取自 UNIX）。</span></p><p id="40bbdad75c7cc6d07a2763e60ee386b6" class="ne-p"><br></p><ol class="ne-ol"><li id="b514136adfffb03de670ef5af862b47c"><code class="ne-code"><span class="ne-text">Create</span></code><span class="ne-text">，创建目录，除了目录项 </span><code class="ne-code"><span class="ne-text">.</span></code><span class="ne-text"> 和 </span><code class="ne-code"><span class="ne-text">..</span></code><span class="ne-text"> 外，目录内容为空。</span></li><li id="b11a83b53464bd86401aa01c73f5c27f"><code class="ne-code"><span class="ne-text">Delete</span></code><span class="ne-text">，删除目录，只有空目录可以删除。只包含 </span><code class="ne-code"><span class="ne-text">.</span></code><span class="ne-text"> 和 </span><code class="ne-code"><span class="ne-text">..</span></code><span class="ne-text"> 的目录被认为是空目录，这两个目录项通常不能删除</span></li></ol><ol start="3" class="ne-ol"><li id="963fdf6f08b50d63286bc505dffbf5fb"><code class="ne-code"><span class="ne-text">opendir</span></code><span class="ne-text">，目录内容可被读取。例如，未列出目录中的全部文件，程序必须先打开该目录，然后读其中全部文件的文件名。与打开和读文件相同，在读目录前，必须先打开文件。</span></li><li id="c74b7a45eea8a24a9f1c8549c7864719"><code class="ne-code"><span class="ne-text">closedir</span></code><span class="ne-text">，读目录结束后，应该关闭目录用于释放内部表空间。</span></li></ol><ol start="5" class="ne-ol"><li id="17dd041b9516a40a3358c45b1362d7ec"><code class="ne-code"><span class="ne-text">readdir</span></code><span class="ne-text">，系统调用 readdir 返回打开目录的下一个目录项。以前也采用 read 系统调用来读取目录，但是这种方法有一个缺点：程序员必须了解和处理目录的内部结构。相反，不论采用哪一种目录结构，readdir 总是以标准格式返回一个目录项。</span></li><li id="4f848d51acdd481545cb2cb86b2d4a9b"><code class="ne-code"><span class="ne-text">rename</span></code><span class="ne-text">，在很多方面目录和文件都相似。文件可以更换名称，目录也可以。</span></li></ol><ol start="7" class="ne-ol"><li id="edbace6607fb3be4e1b637a1dd9aa171"><code class="ne-code"><span class="ne-text">link</span></code><span class="ne-text">，链接技术允许在多个目录中出现同一个文件。这个系统调用指定一个存在的文件和一个路径名，并建立从该文件到路径所指名字的链接。这样，可以在多个目录中出现同一个文件。有时也被称为</span><code class="ne-code"><span class="ne-text">硬链接(hard link)</span></code><span class="ne-text">。</span></li><li id="2cc1cbbf1be79fb5e132a02d030c0afc"><code class="ne-code"><span class="ne-text">unlink</span></code><span class="ne-text">，删除目录项。如果被解除链接的文件只出现在一个目录中，则将它从文件中删除。如果它出现在多个目录中，则只删除指定路径名的链接，依然保留其他路径名的链接。在 UNIX 中，用于删除文件的系统调用就是 unlink。</span></li></ol><p id="885d73b5a39a7c004346a847d1440b8a" class="ne-p"><br></p><h2 id="f7f29532"><span class="ne-text">文件系统的实现</span></h2><p id="ec714890f3489b939201876f99912a34" class="ne-p"><br></p><h3 id="063a94b5"><span class="ne-text">文件系统布局</span></h3><p id="4a9f73122edec1e3f247798ed5bb6ed5" class="ne-p"><br></p><p id="861f46d91942e981cc98ea26967493e0" class="ne-p"><span class="ne-text">文件系统存储在</span><code class="ne-code"><span class="ne-text">磁盘</span></code><span class="ne-text">中。大部分的磁盘能够划分出一到多个分区，叫做</span><code class="ne-code"><span class="ne-text">磁盘分区(disk partitioning)</span></code><span class="ne-text"> 或者是</span><code class="ne-code"><span class="ne-text">磁盘分片(disk slicing)</span></code><span class="ne-text">。每个分区都有独立的文件系统，每块分区的文件系统可以不同。磁盘的 0 号分区称为 </span><code class="ne-code"><span class="ne-text">主引导记录(Master Boot Record, MBR)</span></code><span class="ne-text">，用来</span><code class="ne-code"><span class="ne-text">引导(boot)</span></code><span class="ne-text"> 计算机。在 MBR 的结尾是</span><code class="ne-code"><span class="ne-text">分区表(partition table)</span></code><span class="ne-text">。每个分区表给出每个分区由开始到结束的地址。</span></p><p id="0721c038245fb84b7719e05e8f622ff2" class="ne-p"><br></p><p id="9a6cf1225520c728351597ee0e399155" class="ne-p"><span class="ne-text">当计算机开始引 boot 时，BIOS 读入并执行 MBR。</span></p><p id="75737c56aefb3c7fffd13019a2a1d831" class="ne-p"><br></p><h4 id="740649ac"><span class="ne-text">引导块</span></h4><p id="79156822d8503698dc82e2138c609266" class="ne-p"><br></p><p id="3ff3214b74c0925029bca92abe9ea54e" class="ne-p"><span class="ne-text">MBR 做的第一件事就是</span><code class="ne-code"><span class="ne-text">确定活动分区</span></code><span class="ne-text">，读入它的第一个块，称为</span><code class="ne-code"><span class="ne-text">引导块(boot block)</span></code><span class="ne-text"> 并执行。引导块中的程序将加载分区中的操作系统。为了一致性，每个分区都会从引导块开始，即使引导块不包含操作系统。引导块占据文件系统的前 4096 个字节，从磁盘上的字节偏移量 0 开始。引导块可用于启动操作系统。</span></p><p id="cc963be5f996c475d719d40c4fa10893" class="ne-p"><br></p><p id="4eff089b1ed72dbedc26da706d2b576c" class="ne-p"><span class="ne-text">除了从引导块开始之外，磁盘分区的布局是随着文件系统的不同而变化的。通常文件系统会包含一些属性，如下</span></p><p id="418b125edcf82ba1123e87efba837f9e" class="ne-p"><br></p><p id="6e21b01c67c9de127bae097535ad2d34" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830178-416c1399-355d-4e11-aaad-360c3071d651.png" width="725" id="WO5Ij" class="ne-image"></p><p id="802ba5c7e2c81d6c079467b487a35ee2" class="ne-p"><br></p><p id="70b4cab1c421609e38e9318a8e29f8ed" class="ne-p"><span class="ne-text"> 文件系统布局</span></p><p id="bc19ea1c5561802b619f7862b16edf7e" class="ne-p"><br></p><h4 id="0f7ddcc2"><span class="ne-text">超级块</span></h4><p id="a899d94ff2d728d47e586dc99a20e67d" class="ne-p"><br></p><p id="87b2599a79fc028dca72250f4bb1b6c9" class="ne-p"><span class="ne-text">紧跟在引导块后面的是 </span><code class="ne-code"><span class="ne-text">超级块(Superblock)</span></code><span class="ne-text">，超级块 的大小为 4096 字节，从磁盘上的字节偏移 4096 开始。超级块包含文件系统的所有关键参数</span></p><p id="1476e552c3b10f8582475439b1afb325" class="ne-p"><br></p><ul class="ne-ul"><li id="e4948c5816657ad07b16d2106062394d"><span class="ne-text">文件系统的大小</span></li><li id="8d63325fca6fd5dd7c277423a3ee972d"><span class="ne-text">文件系统中的数据块数</span></li></ul><ul class="ne-ul"><li id="587353c806d7ddc766494832594e262c"><span class="ne-text">指示文件系统状态的标志</span></li><li id="cc7684fc661626e2319cfe80411a56cc"><span class="ne-text">分配组大小</span></li></ul><p id="2a9a7c180f2ee41597fc75f3099404ed" class="ne-p"><br></p><p id="e5bdce31d9d48389f4afd8a853074c25" class="ne-p"><span class="ne-text">在计算机启动或者文件系统首次使用时，超级块会被读入内存。</span></p><p id="cdfd564f630ad7e23f32c907e7be4764" class="ne-p"><br></p><h4 id="d1ac35a8"><span class="ne-text">空闲空间块</span></h4><p id="6c535e1a3405fed739b7db4477fcfe06" class="ne-p"><br></p><p id="e75d427462705c57bc53dcb068c3ec3f" class="ne-p"><span class="ne-text">接着是文件系统中</span><code class="ne-code"><span class="ne-text">空闲块</span></code><span class="ne-text">的信息，例如，可以用位图或者指针列表的形式给出。</span></p><p id="310d3be16358713f214a0b655e726d8f" class="ne-p"><br></p><p id="277b5380d1da751428660b1bcedfa5ff" class="ne-p"><strong><span class="ne-text">BitMap 位图或者 Bit vector 位向量</span></strong></p><p id="d4f7482f58816535906052b8e6a7d87e" class="ne-p"><br></p><p id="55cffd4813169a9f5d4e6c6b2c0e7ec4" class="ne-p"><span class="ne-text">位图或位向量是一系列位或位的集合，其中每个位对应一个磁盘块，该位可以采用两个值：0和1，0表示已分配该块，而1表示一个空闲块。下图中的磁盘上给定的磁盘块实例（分配了绿色块）可以用16位的位图表示为：0000111000000110。</span></p><p id="0af159c768142dd2b260c453127538c0" class="ne-p"><br></p><p id="093caab837a37d141b3925293bf9714d" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830202-8aab8dd3-4293-45ca-ab73-fdf893584edc.png" width="395" id="NJVi8" class="ne-image"></p><p id="8705f7dfac212aab78bf0ab7417d616e" class="ne-p"><br></p><p id="f331be17432c09b9a9f2000d393d383a" class="ne-p"><strong><span class="ne-text">使用链表进行管理</span></strong></p><p id="ae280515e910cb48e7500b5ab206df39" class="ne-p"><br></p><p id="a1ef494d8b253a9a5c23a588a613ec9b" class="ne-p"><span class="ne-text">在这种方法中，空闲磁盘块链接在一起，即一个空闲块包含指向下一个空闲块的指针。第一个磁盘块的块号存储在磁盘上的单独位置，也缓存在内存中。</span></p><p id="7161779eddc824e1d1133e5170bb19c8" class="ne-p"><br></p><p id="1e7553f5324ffb7c2a2dc274b3f94e7b" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830218-bc0ef6e9-c0df-4495-9a7f-4bd5161d4bef.png" width="432" id="dvjrg" class="ne-image"></p><p id="63945d94feb7a4c5fb0b41b6083864f8" class="ne-p"><br></p><h4 id="4f0b14f4"><span class="ne-text">碎片</span></h4><p id="75254f59dc781b72e779b3fe96e7a629" class="ne-p"><br></p><p id="e541583744244097bd2f9fa7b3bb37c5" class="ne-p"><span class="ne-text">这里不得不提一个叫做</span><code class="ne-code"><span class="ne-text">碎片(fragment)</span></code><span class="ne-text">的概念，也称为片段。一般零散的单个数据通常称为片段。 磁盘块可以进一步分为固定大小的分配单元，片段只是在驱动器上彼此不相邻的文件片段。</span></p><p id="3f26e24c7f974df5bffef64b27e565d5" class="ne-p"><br></p><h4 id="inode"><span class="ne-text">inode</span></h4><p id="6fc1903ad5e0e3115581a601fdd7564b" class="ne-p"><br></p><p id="8363cd64eb86a68613f21c83f735a113" class="ne-p"><span class="ne-text">然后在后面是一个 </span><code class="ne-code"><span class="ne-text">inode(index node)</span></code><span class="ne-text">，也称作索引节点。它是一个数组的结构，每个文件有一个 inode，inode 非常重要，它说明了文件的方方面面。每个索引节点都存储对象数据的属性和磁盘块位置</span></p><p id="c4e25dd9c42034d98f8d6ead66069b73" class="ne-p"><br></p><p id="78b35dea2fbf0caa97c6a0e4d341729f" class="ne-p"><span class="ne-text">有一种简单的方法可以找到它们 </span><code class="ne-code"><span class="ne-text">ls -lai</span></code><span class="ne-text"> 命令。让我们看一下根文件系统：</span></p><p id="f73d13b715b79dd4b9d2a3973799f1b2" class="ne-p"><br></p><p id="23fc4b493a2a8cacfd956a7a12ea18fa" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830231-757b0e6a-7a82-4ec8-9a1c-15b9999e0185.png" width="725" id="dyXmP" class="ne-image"></p><p id="7cdc062285235cfe9cc6d010d78172ec" class="ne-p"><br></p><p id="1a3a5b8a310886a6d1c3ee8aa40ca65a" class="ne-p"><span class="ne-text">inode 节点主要包括了以下信息</span></p><p id="0f214c2c872e0efbb561a09eee7fd193" class="ne-p"><br></p><ul class="ne-ul"><li id="4e0fc36ad25bba57c6c83faee15237e8"><span class="ne-text">模式/权限（保护）</span></li><li id="823d04a8b16ecce489446613644eb5f3"><span class="ne-text">所有者 ID</span></li></ul><ul class="ne-ul"><li id="36a513e2056edf128f901912bdd5844a"><span class="ne-text">组 ID</span></li><li id="546b99bab3f0efe6dd65374f82ea512f"><span class="ne-text">文件大小</span></li></ul><ul class="ne-ul"><li id="ca587e18e953730b595535a6d2c2a52e"><span class="ne-text">文件的硬链接数</span></li><li id="d902e80175e84a5d6d169458079df074"><span class="ne-text">上次访问时间</span></li></ul><ul class="ne-ul"><li id="c4df7d4c30aeed369984820d84d672ae"><span class="ne-text">最后修改时间</span></li><li id="4cf9ad6d8fd4f59667245e548904693e"><span class="ne-text">inode 上次修改时间</span></li></ul><p id="63d51221d1e89f15fef8cf8046b41c7f" class="ne-p"><br></p><p id="edba86612d73fee8953765e5d1e71604" class="ne-p"><span class="ne-text">文件分为两部分，索引节点和块。一旦创建后，每种类型的块数是固定的。你不能增加分区上 inode 的数量，也不能增加磁盘块的数量。</span></p><p id="bab0d6d8fdb7ade0c409c63b794198cd" class="ne-p"><br></p><p id="257f76d41594956d4e6f434c94fcd48f" class="ne-p"><span class="ne-text">紧跟在 inode 后面的是根目录，它存放的是文件系统目录树的根部。最后，磁盘的其他部分存放了其他所有的目录和文件。</span></p><p id="07384bc2838ccc280811305a814ac5ae" class="ne-p"><br></p><h3 id="2fa1f996"><span class="ne-text">文件的实现</span></h3><p id="99b6ccd02eb7d36b23ac87b3d23be908" class="ne-p"><br></p><p id="520d4f89043e0d3ef94e335ae502c537" class="ne-p"><span class="ne-text">最重要的问题是记录各个文件分别用到了哪些磁盘块。不同的系统采用了不同的方法。下面我们会探讨一下这些方式。分配背后的主要思想是</span><code class="ne-code"><span class="ne-text">有效利用文件空间</span></code><span class="ne-text">和</span><code class="ne-code"><span class="ne-text">快速访问文件</span></code><span class="ne-text"> ，主要有三种分配方案</span></p><p id="d5bcaa062d84a2587d7983f841a8bb43" class="ne-p"><br></p><ul class="ne-ul"><li id="bd6f72f15903e819e6825d6a4c7d5066"><span class="ne-text">连续分配</span></li><li id="73e9c7cdab99a93a7b5d1cff4ce5bee3"><span class="ne-text">链表分配</span></li></ul><ul class="ne-ul"><li id="6c8d5f5e0b3f6cbb9bedb283610e1607"><span class="ne-text">索引分配</span></li></ul><p id="272e01376fc108d16c05972efeddd7b6" class="ne-p"><br></p><h4 id="72b53a95"><span class="ne-text">连续分配</span></h4><p id="bb7d19bc0a00fea5cb03d6b986da98b5" class="ne-p"><br></p><p id="739ceabf45e4e532ceaee28804bd6747" class="ne-p"><span class="ne-text">最简单的分配方案是把每个文件作为一连串连续数据块存储在磁盘上。因此，在具有 1KB 块的磁盘上，将为 50 KB 文件分配 50 个连续块。</span></p><p id="57e7fce6afec06f7bac3cc1f758e706a" class="ne-p"><br></p><p id="f485071b361eacaef97f0d6bc93d38d0" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830290-96589d90-fa12-43fb-a38a-8ece59db8fcd.png" width="708" id="DEFjo" class="ne-image"></p><p id="149d6540bff10fd348ccf39a548b4008" class="ne-p"><br></p><p id="ad710f4df53ff897f898e195d3474ef4" class="ne-p"><span class="ne-text"> 使用连续空间存储文件</span></p><p id="6e62bb3ca3c03233a13af4af40a1e434" class="ne-p"><br></p><p id="4409e41335edde0a0d4bead916ef1d10" class="ne-p"><span class="ne-text">上面展示了 40 个连续的内存块。从最左侧的 0 块开始。初始状态下，还没有装载文件，因此磁盘是空的。接着，从磁盘开始处（块 0 ）处开始写入占用 4 块长度的内存 A 。然后是一个占用 6 块长度的内存 B，会直接在 A 的末尾开始写。</span></p><p id="eb491f935999b43456e0680eb86056c0" class="ne-p"><br></p><p id="1dbb3a5ff9f7fb7ded0538273ec30ec5" class="ne-p"><span class="ne-text">注意每个文件都会在新的文件块开始写，所以如果文件 A 只占用了 </span><code class="ne-code"><span class="ne-text">3 又 1/2</span></code><span class="ne-text"> 个块，那么最后一个块的部分内存会被浪费。在上面这幅图中，总共展示了 7 个文件，每个文件都会从上个文件的末尾块开始写新的文件块。</span></p><p id="4d302f7f8ae1e2e3584289e94f7b7ee2" class="ne-p"><br></p><p id="ea5e53beccedfc7b48a72979c05ce798" class="ne-p"><span class="ne-text">连续的磁盘空间分配有两个优点。</span></p><p id="429ef5981f289b4d48278e8e51438334" class="ne-p"><br></p><ul class="ne-ul"><li id="07797a0fdd2cc4666f9a5e4a2b80175a"><span class="ne-text">第一，连续文件存储实现起来比较简单，只需要记住两个数字就可以：一个是第一个块的文件地址和文件的块数量。给定第一个块的编号，可以通过简单的加法找到任何其他块的编号。</span></li><li id="40dc07731b88d5bc4e9f39dbda642ece"><span class="ne-text">第二点是读取性能比较强，可以通过一次操作从文件中读取整个文件。只需要一次寻找第一个块。后面就不再需要寻道时间和旋转延迟，所以数据会以全带宽进入磁盘。</span></li></ul><p id="fb5eddf328615cd7b667cd0f76ed8064" class="ne-p"><br></p><p id="c211a55fb8333594f2910711c0080375" class="ne-p"><span class="ne-text">因此，连续的空间分配具有</span><code class="ne-code"><span class="ne-text">实现简单</span></code><span class="ne-text">、</span><code class="ne-code"><span class="ne-text">高性能</span></code><span class="ne-text">的特点。</span></p><p id="226cf8984f3e14ad2f869b70b0ae3d25" class="ne-p"><br></p><p id="584d3adf6df424e0caad8d640306ac6f" class="ne-p"><span class="ne-text">不幸的是，连续空间分配也有很明显的不足。随着时间的推移，磁盘会变得很零碎。下图解释了这种现象</span></p><p id="beb6289ffd948b913ab42f89fc806491" class="ne-p"><br></p><p id="3ca05927b2bc30ed4efbcbe0009b626d" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830262-ef7ce9d8-c4b9-488c-a2d3-48d7888ffe1f.png" width="700" id="AWBOd" class="ne-image"></p><p id="da80c0e171d6555b328959c948dd63da" class="ne-p"><br></p><p id="665c27cdd3d5d092fa41038401e02f09" class="ne-p"><span class="ne-text">这里有两个文件 D 和 F 被删除了。当删除一个文件时，此文件所占用的块也随之释放，就会在磁盘空间中留下一些空闲块。磁盘并不会在这个位置挤压掉空闲块，因为这会复制空闲块之后的所有文件，可能会有上百万的块，这个量级就太大了。</span></p><p id="516ce272d9891eb30c2670ca8fd9c815" class="ne-p"><br></p><h4 id="3d0c6331"><span class="ne-text">链表分配</span></h4><p id="b3b68de304c1d67898de10b8a645632c" class="ne-p"><br></p><p id="8ee621e84c761779bda7b9527721198f" class="ne-p"><span class="ne-text">第二种存储文件的方式是为每个文件构造磁盘块链表，每个文件都是磁盘块的链接列表，就像下面所示</span></p><p id="9d34cfd049bd058c018f3fbe6541ec1d" class="ne-p"><br></p><p id="4433a4082a45a23ee4f93af4c0102214" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830296-9199d50b-5e5b-43f4-a62b-dc0b1ef02d6d.png" width="739" id="UEy0O" class="ne-image"></p><p id="7f14e16ff0324beb9815b3ee276388d4" class="ne-p"><br></p><p id="308a2bb2be459b1d5455d81efb421ceb" class="ne-p"><span class="ne-text"> 以磁盘块的链表形式存储文件</span></p><p id="dc594ff5bca4f75526a34525758f6cf8" class="ne-p"><br></p><p id="60e8ab8b1ba0ea6828d0b8e832d4aabf" class="ne-p"><span class="ne-text">每个块的第一个字作为指向下一块的指针，块的其他部分存放数据。如果上面这张图你看的不是很清楚的话，可以看看整个的链表分配方案</span></p><p id="f2cd47fbd794262b99b108f78818a186" class="ne-p"><br></p><p id="6d43d1117b2ffa2b376514a9bdfbb5c3" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830272-99171e3f-0aae-4fa7-b127-e43f64daed7d.png" width="717" id="MV6v4" class="ne-image"></p><p id="a211e6d69c7bbfb39749b7bec6679328" class="ne-p"><br></p><p id="1763c1572bf74bab8443b0251b0cab48" class="ne-p"><span class="ne-text">与连续分配方案不同，这一方法可以充分利用每个磁盘块。除了最后一个磁盘块外，不会因为磁盘碎片而浪费存储空间。同样，在目录项中，只要存储了第一个文件块，那么其他文件块也能够被找到。</span></p><p id="f61320e6d20a47449e2034136f13b99e" class="ne-p"><br></p><p id="7c4e5c49d0f6e1ea08c9347e50f2d9cc" class="ne-p"><span class="ne-text">另一方面，在链表的分配方案中，尽管顺序读取非常方便，但是随机访问却很困难（这也是数组和链表数据结构的一大区别）。</span></p><p id="4dfa5bc9fab85a3f79ba645a4de63d55" class="ne-p"><br></p><p id="ff5cd3412028401a7eb6f6907edfe384" class="ne-p"><span class="ne-text">还有一个问题是，由于指针会占用一些字节，每个磁盘块实际存储数据的字节数并不再是 2 的整数次幂。虽然这个问题并不会很严重，但是这种方式降低了程序运行效率。许多程序都是以长度为 2 的整数次幂来读写磁盘，由于每个块的前几个字节被指针所使用，所以要读出一个完成的块大小信息，就需要当前块的信息和下一块的信息拼凑而成，因此就引发了查找和拼接的开销。</span></p><p id="5c501728e8545b3abf2ebd585e59e40a" class="ne-p"><br></p><h4 id="e7754cf3"><span class="ne-text">使用内存表进行链表分配</span></h4><p id="f55bd6034ba134163728e11d790728db" class="ne-p"><br></p><p id="fa31a2161c19438020b78c4e5edcff77" class="ne-p"><span class="ne-text">由于连续分配和链表分配都有其不可忽视的缺点。所以提出了使用内存中的表来解决分配问题。取出每个磁盘块的指针字，把它们放在内存的一个表中，就可以解决上述链表的两个不足之处。下面是一个例子</span></p><p id="c62141cbec45e806125f66c6443b2cae" class="ne-p"><br></p><p id="5294fd0f6ea2c7bd340fe04e8f683dfe" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830309-8180ae56-d298-4224-a60b-d472bd7dff53.png" width="499" id="qB40I" class="ne-image"></p><p id="8a73dddf92c308f55531792c78bc4c17" class="ne-p"><br></p><p id="3231eff73ea3778fa27bf38cee3b7593" class="ne-p"><span class="ne-text">上图表示了链表形成的磁盘块的内容。这两个图中都有两个文件，文件 A 依次使用了磁盘块地址 </span><strong><span class="ne-text">4、7、 2、 10、 12</span></strong><span class="ne-text">，文件 B 使用了</span><strong><span class="ne-text">6、3、11 和 14</span></strong><span class="ne-text">。也就是说，文件 A 从地址 4 处开始，顺着链表走就能找到文件 A 的全部磁盘块。同样，从第 6 块开始，顺着链走到最后，也能够找到文件 B 的全部磁盘块。你会发现，这两个链表都以不属于有效磁盘编号的特殊标记（-1）结束。内存中的这种表格称为 </span><code class="ne-code"><span class="ne-text">文件分配表(File Application Table,FAT)</span></code><span class="ne-text">。</span></p><p id="679e35092915fc206d463659b3246031" class="ne-p"><br></p><h3 id="507a4c82"><span class="ne-text">目录的实现</span></h3><p id="229b6f0552c8dcf4c69d5168f63a9eeb" class="ne-p"><br></p><p id="8db380cc3bd619deb9e5ee87c2dcc678" class="ne-p"><span class="ne-text">文件只有打开后才能够被读取。在文件打开后，操作系统会使用用户提供的路径名来定位磁盘中的目录。目录项提供了查找文件磁盘块所需要的信息。根据系统的不同，提供的信息也不同，可能提供的信息是整个文件的磁盘地址，或者是第一个块的数量（两个链表方案）或 inode的数量。不过不管用那种情况，目录系统的主要功能就是 </span><strong><span class="ne-text">将文件的 ASCII 码的名称映射到定位数据所需的信息上</span></strong><span class="ne-text">。</span></p><p id="c245ee3f18a5371b2e919276ff42e4d6" class="ne-p"><br></p><h3 id="7378a354"><span class="ne-text">共享文件</span></h3><p id="0d90e5167a61cad90103ab57542ccd79" class="ne-p"><br></p><p id="a010daa0deac86c6117411cf1b76ee1c" class="ne-p"><span class="ne-text">当多个用户在同一个项目中工作时，他们通常需要共享文件。如果这个共享文件同时出现在多个用户目录下，那么他们协同工作起来就很方便。下面的这张图我们在上面提到过，但是有一个更改的地方，就是 </span><strong><span class="ne-text">C 的一个文件也出现在了 B 的目录下</span></strong><span class="ne-text">。</span></p><p id="4ea8ea0f7dce1ab59600bb31b7fde121" class="ne-p"><br></p><p id="3f9712fc94bd87bc5bce05ab31700a90" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830321-b6391c5b-3b64-4089-9c4e-9a9afd09875c.png" width="743" id="wJKZ9" class="ne-image"></p><p id="1516e5428216ce2d70a3848a9e18d8b7" class="ne-p"><br></p><p id="84f511f5e2da2d65639ae5e4c5f08116" class="ne-p"><span class="ne-text">如果按照如上图的这种组织方式而言，那么 B 的目录与该共享文件的联系称为 </span><code class="ne-code"><span class="ne-text">链接(link)</span></code><span class="ne-text">。那么文件系统现在就是一个 </span><code class="ne-code"><span class="ne-text">有向无环图(Directed Acyclic Graph, 简称 DAG)</span></code><span class="ne-text">，而不是一棵树了。</span></p><p id="dedd40e6c19976b91159210337187cb3" class="ne-p"><br></p><h3 id="062d38ab"><span class="ne-text">日志结构文件系统</span></h3><p id="7d7ce6ffa46d0b80b05b4fa7cf88eb72" class="ne-p"><br></p><p id="0c348de3e61e1b6861d79e122967c6a9" class="ne-p"><span class="ne-text">技术的改变会给当前的文件系统带来压力。这种情况下，CPU 会变得越来越快，磁盘会变得越来越大并且越来越便宜（但不会越来越快）。内存容量也是以指数级增长。但是磁盘的寻道时间（除了固态盘，因为固态盘没有寻道时间）并没有获得提高。</span></p><p id="615e318cbe6ce685b317cedee5ce3166" class="ne-p"><br></p><p id="dc3ac711f3172e557139794ff56c713e" class="ne-p"><span class="ne-text">为此，</span><code class="ne-code"><span class="ne-text">Berkeley</span></code><span class="ne-text"> 设计了一种全新的文件系统，试图缓解这个问题，这个文件系统就是 </span><code class="ne-code"><span class="ne-text">日志结构文件系统(Log-structured File System, LFS)</span></code><span class="ne-text">。旨在解决以下问题。</span></p><p id="0c98bd5354523a99fdbae6022075672f" class="ne-p"><br></p><ul class="ne-ul"><li id="155a7907a5e3bdd0310a98218fdc334b"><span class="ne-text">不断增长的系统内存</span></li><li id="3b38564d520640464c2205c9486261b4"><span class="ne-text">顺序 I/O 性能胜过随机 I/O 性能</span></li></ul><ul class="ne-ul"><li id="32b086adb43b911b202b70e5aff36de8"><span class="ne-text">现有低效率的文件系统</span></li><li id="f7a37a133cbda2e36cf91ffdbee4d115"><span class="ne-text">文件系统不支持 RAID（虚拟化）</span></li></ul><p id="cf17037d9f08713ca3eeb4ace7b47ca8" class="ne-p"><br></p><p id="297fb6753d11f490d126e727b7c09c48" class="ne-p"><span class="ne-text">另一方面，当时的文件系统不论是 UNIX 还是 FFS，都有大量的随机读写（在 FFS 中创建一个新文件至少需要5次随机写），因此成为整个系统的性能瓶颈。同时因为 </span><code class="ne-code"><span class="ne-text">Page cache</span></code><span class="ne-text"> 的存在，作者认为随机读不是主要问题：随着越来越大的内存，大部分的读操作都能被 cache，因此 LFS 主要要解决的是减少对硬盘的随机写操作。</span></p><p id="1bad16ccaa3347ac4cfab1786828e972" class="ne-p"><br></p><p id="d005e77189b514affc9db35092a8db48" class="ne-p"><span class="ne-text">在这种设计中，inode 甚至具有与 UNIX 中相同的结构，但是现在它们分散在整个日志中，而不是位于磁盘上的固定位置。所以，inode 很定位。为了能够找到 inode ，维护了一个由 inode 索引的 </span><code class="ne-code"><span class="ne-text">inode map(inode 映射)</span></code><span class="ne-text">。表项 i 指向磁盘中的第 i 个 inode 。这个映射保存在磁盘中，但是也保存在缓存中，因此，使用最频繁的部分大部分时间都在内存中。</span></p><p id="a624918a0a3ce7dd4dc1ac14978eae8c" class="ne-p"><br></p><p id="268c06eaa913f22f2d46aba8d7868764" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830360-ead8d1cc-da6e-40bc-896b-4350498bf5c8.png" width="732" id="qxML0" class="ne-image"></p><p id="135f1d10729c89da15b349f4f1a6f674" class="ne-p"><br></p><p id="d3439b4c32b9a597fdf5c3f4980e183c" class="ne-p"><span class="ne-text">到目前为止，所有写入最初都缓存在</span><code class="ne-code"><span class="ne-text">内存</span></code><span class="ne-text">中，并且追加在</span><code class="ne-code"><span class="ne-text">日志末尾</span></code><span class="ne-text">，所有缓存的写入都定期在单个段中写入磁盘。所以，现在打开文件也就意味着用映射定位文件的索引节点。一旦 inode 被定位后，磁盘块的地址就能够被找到。所有这些块本身都将位于日志中某处的分段中。</span></p><p id="4deeb5cc8765dcdcffc2051d29dd889c" class="ne-p"><br></p><p id="1da2cd86f605c95cfd9b33b6424b03a8" class="ne-p"><span class="ne-text">真实情况下的磁盘容量是有限的，所以最终日志会占满整个磁盘空间，这种情况下就会出现没有新的磁盘块被写入到日志中。幸运的是，许多现有段可能具有不再需要的块。例如，如果一个文件被覆盖了，那么它的 inode 将被指向新的块，但是旧的磁盘块仍在先前写入的段中占据着空间。</span></p><p id="f7cc586edf59e28b51595cb2d99969e4" class="ne-p"><br></p><p id="b252ea9c8d9887d0749eca891ee9370a" class="ne-p"><span class="ne-text">为了处理这个问题，LFS 有一个</span><code class="ne-code"><span class="ne-text">清理(clean)</span></code><span class="ne-text">线程，它会循环扫描日志并对日志进行压缩。首先，通过查看日志中第一部分的信息来查看其中存在哪些索引节点和文件。它会检查当前 inode 的映射来查看 inode 否在在当前块中，是否仍在被使用。如果不是，该信息将被丢弃。如果仍然在使用，那么 inode 和块就会进入内存等待写回到下一个段中。然后原来的段被标记为空闲，以便日志可以用来存放新的数据。用这种方法，清理线程遍历日志，从后面移走旧的段，然后将有效的数据放入内存等待写到下一个段中。由此一来整个磁盘会形成一个大的</span><code class="ne-code"><span class="ne-text">环形缓冲区</span></code><span class="ne-text">，写线程将新的段写在前面，而清理线程则清理后面的段。</span></p><p id="d882117f7dd0d9016cd4efa5d88f836b" class="ne-p"><br></p><p id="4cb4c6428aac735024f7bd8e7b3df742" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830348-81e32c04-1184-4cdb-8403-2efeeb68787c.png" width="631" id="A4Ev0" class="ne-image"></p><p id="254c2fb97c081e7566ee59c417621dc6" class="ne-p"><br></p><h3 id="97a9825e"><span class="ne-text">日志文件系统</span></h3><p id="54c993a6b70774346a7e6a74670bd65d" class="ne-p"><br></p><p id="15ef008aa02d98f6108fd2b0045ad8ce" class="ne-p"><span class="ne-text">虽然日志结构系统的设计很优雅，但是由于它们和现有的文件系统不相匹配，因此还没有广泛使用。不过，从日志文件结构系统衍生出来一种新的日志系统，叫做</span><code class="ne-code"><span class="ne-text">日志文件系统</span></code><span class="ne-text">，它会记录系统下一步将要做什么的日志。微软的 </span><code class="ne-code"><span class="ne-text">NTFS</span></code><span class="ne-text"> 文件系统、Linux 的 </span><code class="ne-code"><span class="ne-text">ext3</span></code><span class="ne-text"> 就使用了此日志。 </span><code class="ne-code"><span class="ne-text">OS X</span></code><span class="ne-text"> 将日志系统作为可供选项。为了看清它是如何工作的，我们下面讨论一个例子，比如 </span><code class="ne-code"><span class="ne-text">移除文件</span></code><span class="ne-text"> ，这个操作在 UNIX 中需要三个步骤完成：</span></p><p id="542c202aaf8ebf265f4cb616c83eb215" class="ne-p"><br></p><ul class="ne-ul"><li id="67d6fbc0f368e73ec0ae0cd1ae302ca0"><span class="ne-text">在目录中删除文件</span></li><li id="a89a87cfde0f907da93ba98949232c61"><span class="ne-text">释放 inode 到空闲 inode 池</span></li></ul><ul class="ne-ul"><li id="9d7a41e6c40debc886ece1919154c122"><span class="ne-text">将所有磁盘块归还给空闲磁盘池。</span></li></ul><p id="0373ab5b606fbc4ea64ceb3e16560a81" class="ne-p"><br></p><h3 id="85c5a550"><span class="ne-text">虚拟文件系统</span></h3><p id="290a38b2c6595805459b83e5d9efd348" class="ne-p"><br></p><p id="fa0fd762b6f480ec670bc0caaa659d75" class="ne-p"><span class="ne-text">UNIX 操作系统使用一种 </span><code class="ne-code"><span class="ne-text">虚拟文件系统(Virtual File System, VFS)</span></code><span class="ne-text"> 来尝试将多种文件系统构成一个有序的结构。关键的思想是抽象出所有文件系统都共有的部分，并将这部分代码放在一层，这一层再调用具体文件系统来管理数据。下面是一个 VFS 的系统结构</span></p><p id="adaba32ebb0cc75090b68328c3028b7b" class="ne-p"><br></p><p id="a3c0af3bdad2c2390baf7ba0b99cc521" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830356-635b72b4-bcf2-434f-9719-c83b191da6cf.png" width="675" id="zWieH" class="ne-image"></p><p id="d59ed70f4605a2d10f29fbf5243a3add" class="ne-p"><br></p><p id="db2b2f4f03009dfb83d4c4702f1c8bce" class="ne-p"><span class="ne-text">还是那句经典的话，在计算机世界中，任何解决不了的问题都可以加个</span><code class="ne-code"><span class="ne-text">代理</span></code><span class="ne-text">来解决。所有和文件相关的系统调用在最初的处理上都指向虚拟文件系统。这些来自用户进程的调用，都是标准的 </span><code class="ne-code"><span class="ne-text">POSIX 系统调用</span></code><span class="ne-text">，比如 open、read、write 和 seek 等。VFS 对用户进程有一个 </span><code class="ne-code"><span class="ne-text">上层</span></code><span class="ne-text"> 接口，这个接口就是著名的 POSIX 接口。</span></p><p id="b00daf97b264c2c2bbe03d1961ade40f" class="ne-p"><br></p><h2 id="9bc5cc8b"><span class="ne-text">文件系统的管理和优化</span></h2><p id="e52554121a51cb24a7d18cea51ff1273" class="ne-p"><br></p><p id="a457d363aece63ffafdc7a21b8ea5bda" class="ne-p"><span class="ne-text">能够使文件系统工作是一回事，能够使文件系统高效、稳定的工作是另一回事，下面我们就来探讨一下文件系统的管理和优化。</span></p><p id="7427320717087557ca6baac5f2f4e9e6" class="ne-p"><br></p><h3 id="36f7581f"><span class="ne-text">磁盘空间管理</span></h3><p id="2ddbfc7d676fa2fb7e22874efb2691cf" class="ne-p"><br></p><p id="72ecbbb431e26da743b3582748db5218" class="ne-p"><span class="ne-text">文件通常存在磁盘中，所以如何管理磁盘空间是一个操作系统的设计者需要考虑的问题。在文件上进行存有两种策略：</span><strong><span class="ne-text">分配 n 个字节的连续磁盘空间；或者把文件拆分成多个并不一定连续的块</span></strong><span class="ne-text">。在存储管理系统中，主要有</span><code class="ne-code"><span class="ne-text">分段管理</span></code><span class="ne-text">和 </span><code class="ne-code"><span class="ne-text">分页管理</span></code><span class="ne-text"> 两种方式。</span></p><p id="dd7036c30b5429f0012e299634b76e92" class="ne-p"><br></p><p id="67ddc9963643581de7e3a7a9dc7fc649" class="ne-p"><span class="ne-text">正如我们所看到的，按</span><code class="ne-code"><span class="ne-text">连续字节序列</span></code><span class="ne-text">存储文件有一个明显的问题，当文件扩大时，有可能需要在磁盘上移动文件。内存中分段也有同样的问题。不同的是，相对于把文件从磁盘的一个位置移动到另一个位置，内存中段的移动操作要快很多。因此，几乎所有的文件系统都把文件分割成固定大小的块来存储。</span></p><p id="344a106798ca8fae42c7928b5ec1fc77" class="ne-p"><br></p><h4 id="e30f1fa9"><span class="ne-text">块大小</span></h4><p id="38509e646d595c8ff6d9a8436e3eedaf" class="ne-p"><br></p><p id="547a3489e12fa9b51d40fb6441101da0" class="ne-p"><span class="ne-text">一旦把文件分为固定大小的块来存储，就会出现问题，块的大小是多少？按照</span><strong><span class="ne-text">磁盘组织方式，扇区、磁道和柱面显然都可以作为分配单位</span></strong><span class="ne-text">。在分页系统中，分页大小也是主要因素。</span></p><p id="eef07e9a93ba53842388a4f3930178df" class="ne-p"><br></p><p id="db7ed5c40d46b10feac962743c5d08dc" class="ne-p"><span class="ne-text">拥有大的块尺寸意味着每个文件，甚至 1 字节文件，都要占用一个柱面空间，也就是说小文件浪费了大量的磁盘空间。另一方面，小块意味着大部分文件将会跨越多个块，因此需要多次搜索和旋转延迟才能读取它们，从而降低了性能。因此，如果分配的块</span><code class="ne-code"><span class="ne-text">太大</span></code><span class="ne-text">会浪费</span><code class="ne-code"><span class="ne-text">空间</span></code><span class="ne-text">；分配的块</span><code class="ne-code"><span class="ne-text">太小</span></code><span class="ne-text">会浪费</span><code class="ne-code"><span class="ne-text">时间</span></code><span class="ne-text">。</span></p><p id="c2835cdef3fed7ded33775fbb7ca6297" class="ne-p"><br></p><h4 id="295e0480"><span class="ne-text">记录空闲块</span></h4><p id="edd1908809f46d895dc025e523270a52" class="ne-p"><br></p><p id="dd215e9d3aec5bd07fefcbb6ef543dc8" class="ne-p"><span class="ne-text">一旦指定了块大小，下一个问题就是怎样跟踪空闲块。有两种方法被广泛采用，如下图所示</span></p><p id="47accf180646908f7be85a16c3d72875" class="ne-p"><br></p><p id="96bc7041bf4c1a86d46bb5c63cefd992" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830365-86ca166a-5dd1-4e96-b9b4-2966e2d87565.png" width="753" id="CTgLy" class="ne-image"></p><p id="2051479c114a6b22e965758e8797badf" class="ne-p"><br></p><p id="ca2834028031ca00495c9ea1276d53aa" class="ne-p"><span class="ne-text">第一种方法是采用</span><code class="ne-code"><span class="ne-text">磁盘块链表</span></code><span class="ne-text">，链表的每个块中包含极可能多的空闲磁盘块号。对于 1 KB 的块和 32 位的磁盘块号，空闲表中每个块包含有 255 个空闲的块号。考虑 1 TB 的硬盘，拥有大概十亿个磁盘块。为了存储全部地址块号，如果每块可以保存 255 个块号，则需要将近 400 万个块。通常，空闲块用于保存空闲列表，因此存储基本上是空闲的。</span></p><p id="5f10f38fe901cd0eb895dbc49f3e37f0" class="ne-p"><br></p><p id="56b4758c79b155d6ba6436edeba4ba04" class="ne-p"><span class="ne-text">另一种空闲空间管理的技术是</span><code class="ne-code"><span class="ne-text">位图(bitmap)</span></code><span class="ne-text">，n 个块的磁盘需要 n 位位图。在位图中，空闲块用 1 表示，已分配的块用 0 表示。对于 1 TB 硬盘的例子，需要 10 亿位表示，即需要大约 130 000 个 1 KB 块存储。很明显，和 32 位链表模型相比，位图需要的空间更少，因为每个块使用 1 位。只有当磁盘快满的时候，链表需要的块才会比位图少。</span></p><p id="7e0bf942bbab56b06289c8725066eb20" class="ne-p"><br></p><h3 id="4facddb8"><span class="ne-text">磁盘配额</span></h3><p id="032a35f5bc36753dde6f1497ca87082d" class="ne-p"><br></p><p id="215d7a97d62c80293c9847906f762497" class="ne-p"><span class="ne-text">为了防止一些用户占用太多的磁盘空间，多用户操作通常提供一种</span><code class="ne-code"><span class="ne-text">磁盘配额(enforcing disk quotas)</span></code><span class="ne-text">的机制。系统管理员为每个用户分配</span><strong><span class="ne-text">最大的文件和块分配</span></strong><span class="ne-text">，并且操作系统确保用户不会超过其配额。我们下面会谈到这一机制。</span></p><p id="2ee4b6ff9b5bf884af9208e43d278aa6" class="ne-p"><br></p><p id="c20140937b0c58800dec7ed9cd67e95b" class="ne-p"><span class="ne-text">在用户打开一个文件时，操作系统会找到</span><code class="ne-code"><span class="ne-text">文件属性</span></code><span class="ne-text">和</span><code class="ne-code"><span class="ne-text">磁盘地址</span></code><span class="ne-text">，并把它们送入内存中的打开文件表。其中一个属性告诉</span><code class="ne-code"><span class="ne-text">文件所有者</span></code><span class="ne-text">是谁。任何有关文件的增加都会记到所有者的配额中。</span></p><p id="b1cacad06963157173172584f9db8096" class="ne-p"><br></p><p id="3c665c8af9fb07bcf153caa4b682fe95" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830397-dc14e657-f7ce-4c0e-a2fc-dae37cdce37e.png" width="681" id="Oo3ow" class="ne-image"></p><p id="c7a9e9f8b0a5997c4e2a3e6dbc31775a" class="ne-p"><br></p><p id="43b46d497e9c436b2f556aa5c66e2c43" class="ne-p"><span class="ne-text"> 配额表中记录了每个用户的配额</span></p><p id="0f9f915845b742eeb1c89f50a592a657" class="ne-p"><br></p><p id="c5a0b6749f84d9c09a768bf537638a09" class="ne-p"><span class="ne-text">第二张表包含了每个用户当前打开文件的配额记录，即使是其他人打开该文件也一样。如上图所示，该表的内容是从被打开文件的所有者的磁盘配额文件中提取出来的。当所有文件关闭时，该记录被写回配额文件。</span></p><p id="1ee6d826e9a005489809f6cdbc1f74fd" class="ne-p"><br></p><p id="9e3b6aa356a538a1f623df8fbfee0caf" class="ne-p"><span class="ne-text">当在打开文件表中建立一新表项时，会产生一个指向所有者配额记录的指针。每次向文件中添加一个块时，文件所有者所用数据块的总数也随之增加，并会同时增加</span><code class="ne-code"><span class="ne-text">硬限制</span></code><span class="ne-text">和</span><code class="ne-code"><span class="ne-text">软限制</span></code><span class="ne-text">的检查。可以超出软限制，但硬限制不可以超出。当已达到硬限制时，再往文件中添加内容将引发错误。同样，对文件数目也存在类似的检查。</span></p><p id="9dfa42d3b8bda31015aff60e6402447b" class="ne-p"><br></p><h3 id="448f0b53"><span class="ne-text">文件系统备份</span></h3><p id="ffdfb3c549d5e57f21be4e05a1a2db62" class="ne-p"><br></p><p id="113ba2fa14d2438cead2475b7b39a27e" class="ne-p"><span class="ne-text">做文件备份很耗费时间而且也很浪费空间，这会引起下面几个问题。首先，是要</span><strong><span class="ne-text">备份整个文件还是仅备份一部分呢</span></strong><span class="ne-text">？一般来说，只是备份特定目录及其下的全部文件，而不是备份整个文件系统。</span></p><p id="46fadd39621ab910d498dbceb75c70a5" class="ne-p"><br></p><p id="aa6bac235f93e3c65c678e094392adca" class="ne-p"><span class="ne-text">其次，对上次未修改过的文件再进行备份是一种浪费，因而产生了一种</span><code class="ne-code"><span class="ne-text">增量转储(incremental dumps)</span></code><span class="ne-text"> 的思想。最简单的增量转储的形式就是</span><code class="ne-code"><span class="ne-text">周期性</span></code><span class="ne-text">的做全面的备份，而每天只对增量转储完成后发生变化的文件做单个备份。</span></p><p id="bd26f462660acfa584c45424f992c0d3" class="ne-p"><br></p><p id="d7a48a9530c54662113424a7892a7643" class="ne-p"><span class="ne-text">稍微好一点的方式是只备份最近一次转储以来更改过的文件。当然，这种做法极大的缩减了转储时间，但恢复起来却更复杂，因为</span><strong><span class="ne-text">最近的全面转储先要全部恢复，随后按逆序进行增量转储</span></strong><span class="ne-text">。为了方便恢复，人们往往使用更复杂的转储模式。</span></p><p id="51edae20809214a4ee16554d2b0d6c6e" class="ne-p"><br></p><p id="fc00c1f85af8e54127292c60f1ce58f2" class="ne-p"><span class="ne-text">第三，既然待转储的往往是海量数据，那么在将其写入磁带之前对文件进行压缩就很有必要。但是，如果在备份过程中出现了文件损坏的情况，就会导致破坏压缩算法，从而使整个磁带无法读取。所以在备份前是否进行文件压缩需慎重考虑。</span></p><p id="48064cf8ac09f37c3e9fb90da4bd86f6" class="ne-p"><br></p><p id="eae33460e594d4ace436ad41cdee09bb" class="ne-p"><span class="ne-text">第四，对正在使用的文件系统做备份是很难的。如果在转储过程中要添加，删除和修改文件和目录，则转储结果可能不一致。因此，因为转储过程中需要花费数个小时的时间，所以有必要在晚上将系统脱机进行备份，然而这种方式的接受程度并不高。所以，人们修改了转储算法，记下文件系统的</span><code class="ne-code"><span class="ne-text">瞬时快照</span></code><span class="ne-text">，即复制关键的数据结构，然后需要把将来对文件和目录所做的修改复制到块中，而不是到处更新他们。</span></p><p id="30c5145da5c3daf19f6a6c121ac3cd34" class="ne-p"><br></p><p id="b0fcc685273d71a66e54ea23168256e7" class="ne-p"><span class="ne-text">磁盘转储到备份磁盘上有两种方案：</span><strong><span class="ne-text">物理转储和逻辑转储</span></strong><span class="ne-text">。</span><code class="ne-code"><span class="ne-text">物理转储(physical dump)</span></code><span class="ne-text"> 是从磁盘的 0 块开始，依次将所有磁盘块按照顺序写入到输出磁盘，并在复制最后一个磁盘时停止。这种程序的万无一失性是其他程序所不具备的。</span></p><p id="16f52d5c94af08b8399b7f00fde02baf" class="ne-p"><br></p><p id="a4280007245d6cde87091ae5723b514f" class="ne-p"><span class="ne-text">第二个需要考虑的是</span><strong><span class="ne-text">坏块的转储</span></strong><span class="ne-text">。制造大型磁盘而没有瑕疵是不可能的，所以也会存在一些</span><code class="ne-code"><span class="ne-text">坏块(bad blocks)</span></code><span class="ne-text">。有时进行低级格式化后，坏块会被检测出来并进行标记，这种情况的解决办法是用磁盘末尾的一些空闲块所替换。</span></p><p id="d3a520d2dc75e3c048f1f7be7a3b1521" class="ne-p"><br></p><p id="9e3a9f3c7ea68c671fba5541ec778315" class="ne-p"><span class="ne-text">然而，一些块在格式化后会变坏，在这种情况下操作系统可以检测到它们。通常情况下，它可以通过创建一个由所有坏块组成的</span><code class="ne-code"><span class="ne-text">文件</span></code><span class="ne-text">来解决问题，确保它们不会出现在空闲池中并且永远不会被分配。</span><strong><span class="ne-text">那么此文件是完全不可读的</span></strong><span class="ne-text">。如果磁盘控制器将所有的坏块重新映射，物理转储还是能够正常工作的。</span></p><p id="079669c0c544c835fd273273a33afdd7" class="ne-p"><br></p><p id="f5aa458d6a0327dcf235ab0f937d1e5b" class="ne-p"><span class="ne-text">Windows 系统有</span><code class="ne-code"><span class="ne-text">分页文件(paging files)</span></code><span class="ne-text"> 和 </span><code class="ne-code"><span class="ne-text">休眠文件(hibernation files)</span></code><span class="ne-text"> 。它们在文件还原时不发挥作用，同时也不应该在第一时间进行备份。</span></p><p id="7cec7ef194f71a4845069c7b2467ba86" class="ne-p"><br></p><h3 id="7bf7e71c"><span class="ne-text">文件系统的一致性</span></h3><p id="82c29f8de3c1d8f9d3e3a242854aea5a" class="ne-p"><br></p><p id="95f468ed0b314583e7bb1b5d96463a0d" class="ne-p"><span class="ne-text">影响可靠性的一个因素是文件系统的一致性。许多文件系统读取磁盘块、修改磁盘块、再把它们写回磁盘。如果系统在所有块写入之前崩溃，文件系统就会处于一种</span><code class="ne-code"><span class="ne-text">不一致(inconsistent)</span></code><span class="ne-text">的状态。如果某些尚未写回的块是索引节点块，目录块或包含空闲列表的块，则此问题是很严重的。</span></p><p id="aa1b70a4eed4630530233add037539f3" class="ne-p"><br></p><p id="964d4c4e15c95803c23efa7ae10be9e2" class="ne-p"><span class="ne-text">为了处理文件系统一致性问题，大部分计算机都会有应用程序来检查文件系统的一致性。例如，UNIX 有 </span><code class="ne-code"><span class="ne-text">fsck</span></code><span class="ne-text">；Windows 有 </span><code class="ne-code"><span class="ne-text">sfc</span></code><span class="ne-text">，每当引导系统时（尤其是在崩溃后），都可以运行该程序。</span></p><p id="48ab85b18d500f6f09aae6694c153193" class="ne-p"><br></p><p id="f69a8abc58586e91d81d5e78464cf3d0" class="ne-p"><span class="ne-text">可以进行两种一致性检查：</span><strong><span class="ne-text">块的一致性检查和文件的一致性检查</span></strong><span class="ne-text">。为了检查块的一致性，应用程序会建立两张表，每个包含一个计数器的块，最初设置为 0 。第一个表中的计数器跟踪该块在文件中出现的次数，第二张表中的计数器记录每个块在空闲列表、空闲位图中出现的频率。</span></p><p id="6aef6c93e388526281d0ccfabc109e56" class="ne-p"><br></p><h3 id="1813df07"><span class="ne-text">文件系统性能</span></h3><p id="d3fb5bbd9e1d7c87c8abc3f98dad08fa" class="ne-p"><br></p><p id="1b317a6725a77f944c82f795f51802c4" class="ne-p"><span class="ne-text">访问磁盘的效率要比内存满的多，是时候又祭出这张图了</span></p><p id="e65e5e0ed7603e2c50058d08807f17fe" class="ne-p"><br></p><p id="1a1e743c356c1915686f30c85dd8837e" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830422-af95403a-f195-4d9e-8125-0d05ec7651ff.png" width="711" id="oMNVY" class="ne-image"></p><p id="b50a79ed6fb74211ac37fdda653d5b8f" class="ne-p"><br></p><p id="859c470037440cdd28efa0d26f3ef0a6" class="ne-p"><span class="ne-text">从内存读一个 32 位字大概是 10ns，从硬盘上读的速率大概是 100MB/S，对每个 32 位字来说，效率会慢了四倍，另外，还要加上 5 - 10 ms 的寻道时间等其他损耗，如果只访问一个字，内存要比磁盘快百万数量级。所以磁盘优化是很有必要的，下面我们会讨论几种优化方式</span></p><p id="f08d65d53f1351340cdb0ecf65f4e735" class="ne-p"><br></p><h4 id="cdde49bb"><span class="ne-text">高速缓存</span></h4><p id="a88faf1cb721a77ececf2015cf53efa9" class="ne-p"><br></p><p id="7c675dc314d14c2ae799ed6640c9d2e9" class="ne-p"><span class="ne-text">最常用的减少磁盘访问次数的技术是使用 </span><code class="ne-code"><span class="ne-text">块高速缓存(block cache)</span></code><span class="ne-text"> 或者 </span><code class="ne-code"><span class="ne-text">缓冲区高速缓存(buffer cache)</span></code><span class="ne-text">。高速缓存指的是一系列的块，它们在逻辑上属于磁盘，但实际上基于性能的考虑被保存在内存中。</span></p><p id="b17a6714b13a17563901344d07462477" class="ne-p"><br></p><p id="dc154ad0b420fd4f3673118cc516d2e6" class="ne-p"><span class="ne-text">管理高速缓存有不同的算法，常用的算法是：检查全部的读请求，查看在高速缓存中是否有所需要的块。如果存在，可执行读操作而无须访问磁盘。如果检查块不再高速缓存中，那么首先把它读入高速缓存，再复制到所需的地方。之后，对同一个块的请求都通过</span><code class="ne-code"><span class="ne-text">高速缓存</span></code><span class="ne-text">来完成。</span></p><p id="c25b8162bb8c3e4f67a87ba9bac5a070" class="ne-p"><br></p><p id="6c386979476c9d66e19b2d612c66328f" class="ne-p"><span class="ne-text">高速缓存的操作如下图所示</span></p><p id="3d3a4d92696219f66d8742c69e570752" class="ne-p"><br></p><p id="24044650b0ba67c609c1fd504c6288be" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830486-9b7cd7d5-cd58-485e-8fb9-7c5f918fb69a.png" width="733" id="w4gdw" class="ne-image"></p><p id="e9c3294259bbd6241a38558088b3ebd6" class="ne-p"><br></p><p id="6eca2ec60272b982b11ff45c7220cf1c" class="ne-p"><span class="ne-text">由于在高速缓存中有许多块，所以需要某种方法快速确定所需的块是否存在。常用方法是将设备和磁盘地址进行散列操作，然后，在散列表中查找结果。具有相同散列值的块在一个链表中连接在一起（这个数据结构是不是很像 HashMap?），这样就可以沿着冲突链查找其他块。</span></p><p id="d484a308c97ec7ef8cadad561dd451b0" class="ne-p"><br></p><p id="de071a26c813ef0d71da3b2b2adce651" class="ne-p"><span class="ne-text">如果高速缓存</span><code class="ne-code"><span class="ne-text">已满</span></code><span class="ne-text">，此时需要调入新的块，则要把原来的某一块调出高速缓存，如果要调出的块在上次调入后已经被修改过，则需要把它写回磁盘。</span></p><p id="d2cb85bba04c34338b74daba699247a5" class="ne-p"><br></p><h4 id="66d87443"><span class="ne-text">块提前读</span></h4><p id="30c57914a283b1c14a9a70972a449fdc" class="ne-p"><br></p><p id="deeccda0a50582f53cf9c6007fc28d76" class="ne-p"><span class="ne-text">第二个明显提高文件系统的性能是，在需要用到块之前，试图</span><code class="ne-code"><span class="ne-text">提前</span></code><span class="ne-text">将其写入高速缓存，从而</span><code class="ne-code"><span class="ne-text">提高命中率</span></code><span class="ne-text">。许多文件都是顺序读取。如果请求文件系统在某个文件中生成块 k，文件系统执行相关操作并且在完成之后，会检查高速缓存，以便确定块 k + 1 是否已经在高速缓存。如果不在，文件系统会为 k + 1 安排一个预读取，因为文件希望在用到该块的时候能够直接从高速缓存中读取。</span></p><p id="8a69c495fe7bb783b79dbf75485864bc" class="ne-p"><br></p><p id="808c596082fdff6eaae697cd580903a8" class="ne-p"><span class="ne-text">当然，块提前读取策略只适用于实际顺序读取的文件。对随机访问的文件，提前读丝毫不起作用。甚至还会造成阻碍。</span></p><p id="5b78528d1ba45c2104816c3e8e709aff" class="ne-p"><br></p><h4 id="aa9dd989"><span class="ne-text">减少磁盘臂运动</span></h4><p id="d09f4491931761a8ce0444d664eebb7a" class="ne-p"><br></p><p id="fb7b8c5c382a9dee9c90ffe1a4934f58" class="ne-p"><span class="ne-text">高速缓存和块提前读并不是提高文件系统性能的唯一方法。另一种重要的技术是</span><strong><span class="ne-text">把有可能顺序访问的块放在一起，当然最好是在同一个柱面上，从而减少磁盘臂的移动次数</span></strong><span class="ne-text">。当写一个输出文件时，文件系统就必须按照要求一次一次地分配磁盘块。如果用位图来记录空闲块，并且整个位图在内存中，那么选择与前一块最近的空闲块是很容易的。如果用空闲表，并且链表的一部分存在磁盘上，要分配紧邻的空闲块就会困难很多。</span></p><p id="fb9ea860feeaa3264df8728b7749755f" class="ne-p"><br></p><h4 id="67e3ff13"><span class="ne-text">磁盘碎片整理</span></h4><p id="ba79cd85e1dad3bed9f2216b2b7253b1" class="ne-p"><br></p><p id="41c56da85159758040baae19181247c8" class="ne-p"><span class="ne-text">在初始安装操作系统后，文件就会被不断的创建和清除，于是磁盘会产生很多的碎片，在创建一个文件时，它使用的块会散布在整个磁盘上，降低性能。删除文件后，回收磁盘块，可能会造成空穴。</span></p><p id="b1d265b54391b9395004a22d89f3381d" class="ne-p"><br></p><p id="408e532833df6ecd00374e3714b691a6" class="ne-p"><span class="ne-text">磁盘性能可以通过如下方式恢复：移动文件使它们相互挨着，并把所有的至少是大部分的空闲空间放在一个或多个大的连续区域内。Windows 有一个程序 </span><code class="ne-code"><span class="ne-text">defrag</span></code><span class="ne-text"> 就是做这个事儿的。Windows 用户会经常使用它，SSD 除外。</span></p><p id="2b171a55d46f2e7b316bfa4dca7e1d30" class="ne-p"><br></p><p id="0a13d2e5ecaea758dd489d8b3f708327" class="ne-p"><span class="ne-text">磁盘碎片整理程序会在让文件系统上很好地运行。Linux 文件系统（特别是 ext2 和 ext3）由于其选择磁盘块的方式，在磁盘碎片整理上一般不会像 Windows 一样困难，因此很少需要手动的磁盘碎片整理。而且，固态硬盘并不受磁盘碎片的影响，事实上，在固态硬盘上做磁盘碎片整理反倒是多此一举，不仅没有提高性能，反而磨损了固态硬盘。所以碎片整理只会缩短固态硬盘的寿命。</span></p><p id="e7ebcf76e9e7e212ad0bcdf32a78971d" class="ne-p"><br></p><p id="89ca27714a847f6e1742fe7c23d34046" class="ne-p"><span class="ne-text">下面我们来探讨一下 I/O 流程问题。</span></p><p id="1cef0573f6ef4eb8042d81ad743c2c6e" class="ne-p"><br></p><p id="55fa1a1e6692073f30600efec9761a8f" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830481-2693434c-6334-4f5a-a152-75454e91d275.png" width="752" id="Nh8lv" class="ne-image"></p><p id="dab506072acfbe1a65ea20b5d8f20187" class="ne-p"><br></p><h2 id="ccf866bd"><span class="ne-text">I/O 设备</span></h2><p id="fef21a68cfbbf3d40c8c42db7160f3fc" class="ne-p"><br></p><p id="a11a667a8e08d786f9df34bbf650bf3d" class="ne-p"><span class="ne-text">什么是 I/O 设备？I/O 设备又叫做输入/输出设备，它是人类用来和计算机进行通信的外部硬件。输入/输出设备能够向计算机</span><code class="ne-code"><span class="ne-text">发送数据（输出）</span></code><span class="ne-text">并从计算机</span><code class="ne-code"><span class="ne-text">接收数据（输入）</span></code><span class="ne-text">。</span></p><p id="c552565b432c8f2328937d605d16b55f" class="ne-p"><br></p><p id="36a413dde5afb50347686b041abb2194" class="ne-p"><code class="ne-code"><span class="ne-text">I/O 设备(I/O devices)</span></code><span class="ne-text">可以分成两种：</span><code class="ne-code"><span class="ne-text">块设备(block devices)</span></code><span class="ne-text"> 和 </span><code class="ne-code"><span class="ne-text">字符设备(character devices)</span></code><span class="ne-text">。</span></p><p id="041f671ef3cc121c9abd0eb87bea40ce" class="ne-p"><br></p><h4 id="b0737d59"><span class="ne-text">块设备</span></h4><p id="85b0d1db3e51529ae28eb21531dbabc9" class="ne-p"><br></p><p id="6791ea347b3b675b23d8b71834de784d" class="ne-p"><span class="ne-text">块设备是一个能存储</span><code class="ne-code"><span class="ne-text">固定大小块</span></code><span class="ne-text">信息的设备，它支持</span><strong><span class="ne-text">以固定大小的块，扇区或群集读取和（可选）写入数据</span></strong><span class="ne-text">。每个块都有自己的</span><code class="ne-code"><span class="ne-text">物理地址</span></code><span class="ne-text">。通常块的大小在 512 - 65536 之间。所有传输的信息都会以</span><code class="ne-code"><span class="ne-text">连续</span></code><span class="ne-text">的块为单位。块设备的基本特征是每个块都较为对立，能够独立的进行读写。常见的块设备有 </span><strong><span class="ne-text">硬盘、蓝光光盘、USB 盘</span></strong></p><p id="b52171cdae8af1f376f27c40ad67ac26" class="ne-p"><br></p><p id="cf77f280837dfa3d5315eadc8011a27d" class="ne-p"><span class="ne-text">与字符设备相比，块设备通常需要较少的引脚。</span></p><p id="7ecf223db6465ee23234ff197ee6a09c" class="ne-p"><br></p><p id="7acf3702619a1520d671342f2aa55ce2" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830476-de4c28f8-7881-487b-9bc3-11bf81770f23.png" width="700" id="pm6J2" class="ne-image"></p><p id="0e9ec415e4a41b3d94d858c66fadaad5" class="ne-p"><br></p><h4 id="4946a116"><span class="ne-text">块设备的缺点</span></h4><p id="f6b824a5b70558096a86b0e599ace532" class="ne-p"><br></p><p id="7e18a2c7272bc8e4a6f3a6ab2944d1e1" class="ne-p"><span class="ne-text">基于给定固态存储器的块设备比基于相同类型的存储器的字节寻址要慢一些，因为必须在块的开头开始读取或写入。所以，要读取该块的任何部分，必须寻找到该块的开始，读取整个块，如果不使用该块，则将其丢弃。要写入块的一部分，必须寻找到块的开始，将整个块读入内存，修改数据，再次寻找到块的开头处，然后将整个块写回设备。</span></p><p id="b56f0082d6f7228e3d6e2ccca060af64" class="ne-p"><br></p><h4 id="d4ea5237"><span class="ne-text">字符设备</span></h4><p id="029c7023153fa023483fe82decdea68f" class="ne-p"><br></p><p id="43cd71445d951e98def6564f4fb90e2f" class="ne-p"><span class="ne-text">另一类 I/O 设备是</span><code class="ne-code"><span class="ne-text">字符设备</span></code><span class="ne-text">。字符设备以</span><code class="ne-code"><span class="ne-text">字符</span></code><span class="ne-text">为单位发送或接收一个字符流，而不考虑任何块结构。字符设备是不可寻址的，也没有任何寻道操作。常见的字符设备有 </span><strong><span class="ne-text">打印机、网络设备、鼠标、以及大多数与磁盘不同的设备</span></strong><span class="ne-text">。</span></p><p id="28e05ffc9309d60a2e6a8be0504cb2b6" class="ne-p"><br></p><p id="1613d0fe5c97aa26e6cc98547e4b3f5e" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830510-e704b09f-ae66-45ce-bde4-66fd175dc769.png" width="703" id="ZC93B" class="ne-image"></p><p id="45829f5e3fd12814f44a925a42257add" class="ne-p"><br></p><h3 id="9881f730"><span class="ne-text">设备控制器</span></h3><p id="42cfb8373d43692de4cab682355d0267" class="ne-p"><br></p><p id="01c9dcd39c0617edea3fe8743f8387e7" class="ne-p"><span class="ne-text">设备控制器是处理 CPU 传入和传出信号的系统。设备通过插头和插座连接到计算机，并且插座连接到设备控制器。设备控制器从连接的设备处接收数据，并将其存储在控制器内部的一些</span><code class="ne-code"><span class="ne-text">特殊目的寄存器(special purpose registers)</span></code><span class="ne-text"> 也就是本地缓冲区中。</span></p><p id="e8d0510ece8b2837f0fe7c0812240fab" class="ne-p"><br></p><p id="c5350ce1c360c31d9f02ded8ad634464" class="ne-p"><span class="ne-text">每个设备控制器都会有一个应用程序与之对应，设备控制器通过应用程序的接口通过中断与操作系统进行通信。设备控制器是硬件，而设备驱动程序是软件。</span></p><p id="ee7e18cfd23f391533dba522b7fb2d17" class="ne-p"><br></p><h3 id="2b21e7c0"><span class="ne-text">内存映射 I/O</span></h3><p id="478fcce32a2fb12395f5979c573146eb" class="ne-p"><br></p><p id="de6bab2e6473dcb8f55d739b5d01be84" class="ne-p"><span class="ne-text">每个控制器都会有几个寄存器用来和 CPU 进行通信。通过写入这些寄存器，操作系统可以命令设备发送数据，接收数据、开启或者关闭设备等。通过从这些寄存器中读取信息，操作系统能够知道设备的状态，是否准备接受一个新命令等。</span></p><p id="49d135f8526a65aa9126b14668ee49ed" class="ne-p"><br></p><p id="8c5d7f345d34f8b2c41baab490473318" class="ne-p"><span class="ne-text">为了控制</span><code class="ne-code"><span class="ne-text">寄存器</span></code><span class="ne-text">，许多设备都会有</span><code class="ne-code"><span class="ne-text">数据缓冲区(data buffer)</span></code><span class="ne-text">，来供系统进行读写。</span></p><p id="a5a4118b957e027328e237a6e1a992f3" class="ne-p"><br></p><p id="b2afa8b116e5e0ca2d07bb3a17bd3fa2" class="ne-p"><span class="ne-text">那么问题来了，CPU 如何与设备寄存器和设备数据缓冲区进行通信呢？存在两个可选的方式。第一种方法是，每个控制寄存器都被分配一个 </span><code class="ne-code"><span class="ne-text">I/O 端口(I/O port)</span></code><span class="ne-text">号，这是一个 8 位或 16 位的整数。所有 I/O 端口的集合形成了受保护的 I/O 端口空间，以便普通用户程序无法访问它（只有操作系统可以访问）。使用特殊的 I/O 指令像是</span></p><p id="765a4ca508a5115b78ed2925e14838d8" class="ne-p"><br></p><pre data-language="assembly" id="3877d554" class="ne-codeblock language-assembly">IN REG,PORT</pre><p id="d488b29580542c9583338320551ab3c6" class="ne-p"><br></p><p id="08ce542e0db8dcd660e9764cb17b670f" class="ne-p"><span class="ne-text">CPU 可以读取控制寄存器 PORT 的内容并将结果放在 CPU 寄存器 REG 中。类似的，使用</span></p><p id="862fabda27bff31f4481f0fbb1841f04" class="ne-p"><br></p><pre data-language="assembly" id="41a56928" class="ne-codeblock language-assembly">OUT PORT,REG</pre><p id="2af22811e69fd5e8ed8a16f28179a129" class="ne-p"><br></p><p id="bded26b72586207ef1db5725a5279922" class="ne-p"><span class="ne-text">CPU 可以将 REG 的内容写到控制寄存器中。大多数早期计算机，包括几乎所有大型主机，如 IBM 360 及其所有后续机型，都是以这种方式工作的。</span></p><p id="726bebd6ef6b472edc3181572bdfa656" class="ne-p"><br></p><p id="473bae0048dd7032999f2251d5a662b7" class="ne-p"><span class="ne-text">第二个方法是 PDP-11 引入的，它将</span><strong><span class="ne-text">所有控制寄存器映射到内存空间</span></strong><span class="ne-text">中。</span></p><p id="55f1ecf17cdddd5693acbda0af158993" class="ne-p"><br></p><h3 id="71380d9f"><span class="ne-text">直接内存访问</span></h3><p id="1cec9d2a2b4a37680ebefd6565e21175" class="ne-p"><br></p><p id="ce6e80a93dc12dcb9aa9d664ffadc5fa" class="ne-p"><span class="ne-text">无论一个 CPU 是否具有内存映射 I/O，它都需要寻址设备控制器以便与它们交换数据。CPU 可以从 I/O 控制器每次请求一个字节的数据，但是这么做会浪费 CPU 时间，所以经常会用到一种称为</span><code class="ne-code"><span class="ne-text">直接内存访问(Direct Memory Access)</span></code><span class="ne-text"> 的方案。为了简化，我们假设 CPU 通过单一的系统总线访问所有的设备和内存，该总线连接 CPU 、内存和 I/O 设备，如下图所示</span></p><p id="009027f46496d3f8f2bcb165a348c8df" class="ne-p"><br></p><p id="85b72b01debce0ace6ba07e6e9e6c0aa" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830508-9d21c036-35f6-4f66-a119-b33cd2ebffa9.png" width="720" id="s3oNe" class="ne-image"></p><p id="fff67c6d75a8f701088870489a68703b" class="ne-p"><br></p><p id="b6f73292094a29c64c123bc26d8c3f35" class="ne-p"><span class="ne-text"> DMA 传送操作</span></p><p id="2e9984b3603d69feb8670dc2a1da4da7" class="ne-p"><br></p><p id="fa3070dc88798a6ad84f66d79849c409" class="ne-p"><span class="ne-text">现代操作系统实际更为复杂，但是原理是相同的。如果硬件有 </span><code class="ne-code"><span class="ne-text">DMA 控制器</span></code><span class="ne-text">，那么操作系统只能使用 DMA。有时这个控制器会集成到磁盘控制器和其他控制器中，但这种设计需要在每个设备上都装有一个分离的 DMA 控制器。单个的 DMA 控制器可用于向多个设备传输，这种传输往往同时进行。</span></p><p id="9872ff0e8287271e0167ad5fe4904890" class="ne-p"><br></p><h4 id="fb19257e"><span class="ne-text">DMA 工作原理</span></h4><p id="a03e5cbf85c29f2523e00aebff3be168" class="ne-p"><br></p><p id="83ad54a6486153ef6c842a3d2356ce33" class="ne-p"><span class="ne-text">首先 CPU 通过设置 DMA 控制器的寄存器对它进行编程，所以 DMA 控制器知道将什么数据传送到什么地方。DMA 控制器还要向磁盘控制器发出一个命令，通知它从磁盘读数据到其内部的缓冲区并检验校验和。当有效数据位于磁盘控制器的缓冲区中时，DMA 就可以开始了。</span></p><p id="988a05fc57bbc139ee60ade19db59775" class="ne-p"><br></p><p id="a747f027f15ed77d2cb1885a1e205177" class="ne-p"><span class="ne-text">DMA 控制器通过在总线上发出一个</span><code class="ne-code"><span class="ne-text">读请求</span></code><span class="ne-text">到磁盘控制器而发起 DMA 传送，这是第二步。这个读请求就像其他读请求一样，磁盘控制器并不知道或者并不关心它是来自 CPU 还是来自 DMA 控制器。通常情况下，要写的内存地址在总线的地址线上，所以当磁盘控制器去匹配下一个字时，它知道将该字写到什么地方。写到内存就是另外一个总线循环了，这是第三步。当写操作完成时，磁盘控制器在总线上发出一个应答信号到 DMA 控制器，这是第四步。</span></p><p id="07fa0e231d1e259cf61d47eec043f097" class="ne-p"><br></p><p id="5db6af288a1595b279c38f3dfc63fbe9" class="ne-p"><span class="ne-text">然后，DMA 控制器会增加内存地址并减少字节数量。如果字节数量仍然大于 0 ，就会循环步骤 2 - 步骤 4 ，直到字节计数变为 0 。此时，DMA 控制器会打断 CPU 并告诉它传输已经完成了。</span></p><p id="9e6195abe1061d23e1d4d22ae3d6afa8" class="ne-p"><br></p><h3 id="88738ca6"><span class="ne-text">重温中断</span></h3><p id="7c3f61ac5e50355d43deec6eb171c4b3" class="ne-p"><br></p><p id="48c3b8a5650e6a887fa2b72a2b529060" class="ne-p"><span class="ne-text">在一台个人计算机体系结构中，中断结构会如下所示</span></p><p id="95bd47e829d0671f561d6b370de02cea" class="ne-p"><br></p><p id="5dd6ab905cdc97ae2993d6f60bcc7ead" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830529-8f149c71-9817-4096-a8df-b613c0308a0c.png" width="719" id="iOWO2" class="ne-image"></p><p id="10d79c44f0beaa13fc3f7bbeb5749849" class="ne-p"><br></p><p id="601484c465041f9864201581aa71a5bd" class="ne-p"><span class="ne-text"> 中断是怎样发生的</span></p><p id="7c3e2170d94eae6e8bb1e7ed99cf48eb" class="ne-p"><br></p><p id="de5270978abbc6bac17d8b32c4827722" class="ne-p"><span class="ne-text">当一个 I/O 设备完成它的工作后，它就会产生一个中断（默认操作系统已经开启中断），它通过在总线上声明已分配的信号来实现此目的。主板上的中断控制器芯片会检测到这个信号，然后执行中断操作。</span></p><p id="d54426721eeb0af5700de3ec951f31f3" class="ne-p"><br></p><h4 id="a032d055"><span class="ne-text">精确中断和不精确中断</span></h4><p id="0373af03e43a5a5ef1859377c0c633d9" class="ne-p"><br></p><p id="91b406cc3a3758fb324eb8607af4e8f2" class="ne-p"><span class="ne-text">使机器处于良好状态的中断称为</span><code class="ne-code"><span class="ne-text">精确中断(precise interrupt)</span></code><span class="ne-text">。这样的中断具有四个属性：</span></p><p id="48b23acc0c3fe244343225c69bafd081" class="ne-p"><br></p><ul class="ne-ul"><li id="8fd4c3bc25c5fe2966bbd8a70be45152"><span class="ne-text">PC （程序计数器）保存在一个已知的地方</span></li><li id="9e17123cbba8fae7fe1a9991e2dd410d"><span class="ne-text">PC 所指向的指令之前所有的指令已经完全执行</span></li></ul><ul class="ne-ul"><li id="340dcd019fc2ddbb3832064d9c975248"><span class="ne-text">PC 所指向的指令之后所有的指令都没有执行</span></li><li id="65e37ac7f0148917395ea4dde0172c57"><span class="ne-text">PC 所指向的指令的执行状态是已知的</span></li></ul><p id="e4c96ab14cd240a871b7845132f1d548" class="ne-p"><br></p><p id="660407a271fb6d3cfc3717ddc6ee834d" class="ne-p"><span class="ne-text">不满足以上要求的中断称为 </span><code class="ne-code"><span class="ne-text">不精确中断(imprecise interrupt)</span></code><span class="ne-text">，不精确中断让人很头疼。上图描述了不精确中断的现象。指令的执行时序和完成度具有不确定性，而且恢复起来也非常麻烦。</span></p><p id="e3e336a043b7c00394ea46bfc5cfd46c" class="ne-p"><br></p><h2 id="bd465b75"><span class="ne-text">IO 软件原理</span></h2><p id="9805805a9a255a10c1f4cb4e0d0c05a7" class="ne-p"><br></p><h3 id="4d234768"><span class="ne-text">I/O 软件目标</span></h3><p id="f96764b4ab266d91c2222e0ddc8d698e" class="ne-p"><br></p><h4 id="e0ddd7b0"><span class="ne-text">设备独立性</span></h4><p id="fb7a0820cadbc5c77f90763e0c7b7ee1" class="ne-p"><br></p><p id="cae2b2b1223c280ab808cd070ae929d4" class="ne-p"><span class="ne-text">I/O 软件设计一个很重要的目标就是</span><code class="ne-code"><span class="ne-text">设备独立性(device independence)</span></code><span class="ne-text">。这意味着</span><strong><span class="ne-text">我们能够编写访问任何设备的应用程序，而不用事先指定特定的设备</span></strong><span class="ne-text">。</span></p><p id="d82bc7d1671e4c56ae19ad479cb3d7f2" class="ne-p"><br></p><p id="1d54ad5122b27da8853c8b013cd174a5" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830529-e4825574-4e1c-43fa-adf0-519f0ea1c7f7.png" width="500" id="GdxNy" class="ne-image"></p><p id="f68ad4f4e9d3b73f17102d65ba3e55e8" class="ne-p"><br></p><h4 id="6a8bef7b"><span class="ne-text">错误处理</span></h4><p id="d1f2e4f1a31eed63e226fd56b6613183" class="ne-p"><br></p><p id="a7884712cfe85b529bebc4d2be5e0cf4" class="ne-p"><span class="ne-text">除了</span><code class="ne-code"><span class="ne-text">设备独立性</span></code><span class="ne-text">外，I/O 软件实现的第二个重要的目标就是</span><code class="ne-code"><span class="ne-text">错误处理(error handling)</span></code><span class="ne-text">。通常情况下来说，错误应该交给</span><code class="ne-code"><span class="ne-text">硬件</span></code><span class="ne-text">层面去处理。如果设备控制器发现了读错误的话，它会尽可能的去修复这个错误。如果设备控制器处理不了这个问题，那么设备驱动程序应该进行处理，设备驱动程序会再次尝试读取操作，很多错误都是偶然性的，如果设备驱动程序无法处理这个错误，才会把错误向上抛到硬件层面（上层）进行处理，很多时候，上层并不需要知道下层是如何解决错误的。</span></p><p id="9e170e1f0fd449f4dd2137e7394a5814" class="ne-p"><br></p><h4 id="11e7c14a"><span class="ne-text">同步和异步传输</span></h4><p id="53f8dc2f75dd7561fb001a400b5bc1e2" class="ne-p"><br></p><p id="3ac6b21c213e53b332d365fd3c462651" class="ne-p"><span class="ne-text">I/O 软件实现的第三个目标就是 </span><code class="ne-code"><span class="ne-text">同步(synchronous)</span></code><span class="ne-text"> 和 </span><code class="ne-code"><span class="ne-text">异步(asynchronous，即中断驱动)</span></code><span class="ne-text">传输。这里先说一下同步和异步是怎么回事吧。</span></p><p id="6600d3b4dbf1a21ab257c236aaf74890" class="ne-p"><br></p><p id="8a81b17161a0891783a1e47bafccc87a" class="ne-p"><span class="ne-text">同步传输中数据通常以块或帧的形式发送。发送方和接收方在数据传输之前应该具有</span><code class="ne-code"><span class="ne-text">同步时钟</span></code><span class="ne-text">。而在异步传输中，数据通常以字节或者字符的形式发送，异步传输则不需要同步时钟，但是会在传输之前向数据添加</span><code class="ne-code"><span class="ne-text">奇偶校验位</span></code><span class="ne-text">。大部分</span><code class="ne-code"><span class="ne-text">物理IO(physical I/O)</span></code><span class="ne-text"> 是异步的。物理 I/O 中的 CPU 是很聪明的，CPU 传输完成后会转而做其他事情，它和中断心灵相通，等到中断发生后，CPU 才会回到传输这件事情上来。</span></p><p id="13f056d30c7563c88922db85f5bfa65b" class="ne-p"><br></p><h4 id="beeaff4e"><span class="ne-text">缓冲</span></h4><p id="695396bd0e3da1432e28a9ec7ad67c44" class="ne-p"><br></p><p id="d694cf6a6b725b199182eab1999db6af" class="ne-p"><span class="ne-text">I/O 软件的最后一个问题是</span><code class="ne-code"><span class="ne-text">缓冲(buffering)</span></code><span class="ne-text">。通常情况下，从一个设备发出的数据不会直接到达最后的设备。其间会经过一系列的校验、检查、缓冲等操作才能到达。</span></p><p id="6d8f5e80ec7671a409b3349aeafa4e84" class="ne-p"><br></p><h4 id="f1ccad80"><span class="ne-text">共享和独占</span></h4><p id="c08f1179ba4ca61d0259277331999928" class="ne-p"><br></p><p id="431707a6eac38d978e9d7b60547c75ec" class="ne-p"><span class="ne-text">I/O 软件引起的最后一个问题就是共享设备和独占设备的问题。有些 I/O 设备能够被许多用户共同使用。一些设备比如磁盘，让多个用户使用一般不会产生什么问题，但是某些设备必须具有独占性，即只允许单个用户使用完成后才能让其他用户使用。</span></p><p id="bcb812bfa70e5469e62fda4e1664762d" class="ne-p"><br></p><p id="fdb189d5793fe92aaecbae65c33c9d60" class="ne-p"><span class="ne-text">一共有三种控制 I/O 设备的方法</span></p><p id="3ac081282b49c86ef8508659ef7bae3c" class="ne-p"><br></p><ul class="ne-ul"><li id="0b7a67c756d4dfb9d85b4a1e274e5cf8"><span class="ne-text">使用程序控制 I/O</span></li><li id="1d1393ce94ebf7d064d3f95fa243aac4"><span class="ne-text">使用中断驱动 I/O</span></li></ul><ul class="ne-ul"><li id="2280839d3c18c5d4110059dbf95d31b0"><span class="ne-text">使用 DMA 驱动 I/O</span></li></ul><p id="efc9fb3091302ca297ac8fd3ebf94a6f" class="ne-p"><br></p><h2 id="ad10edaf"><span class="ne-text">I/O 层次结构</span></h2><p id="62f867ad46d621ab0a552b8ce4d2a9fb" class="ne-p"><br></p><p id="68dfa1c9e4977f08396c1a2cfac6b2ee" class="ne-p"><span class="ne-text">I/O 软件通常组织成四个层次，它们的大致结构如下图所示</span></p><p id="7929e287e6be90fb05c7f6eda9e795c6" class="ne-p"><br></p><p id="3c94fa0cf4df1135075bdba9d69394e4" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830546-fa05a772-fc02-4957-ba1d-1e5a82d78de2.png" width="733" id="la9lz" class="ne-image"></p><p id="367071aef5c7e0cb28661020c6ec67ea" class="ne-p"><br></p><p id="fa33c7104d42e131152f9d0133c0bd34" class="ne-p"><span class="ne-text">下面我们具体的来探讨一下上面的层次结构</span></p><p id="453f272b64d2fca31d28de214c7af40f" class="ne-p"><br></p><h3 id="6b8ce92c"><span class="ne-text">中断处理程序</span></h3><p id="969295b5c2e73885da41f57f47ef9de7" class="ne-p"><br></p><p id="c27f88832c6acafb20ddebaa70764997" class="ne-p"><span class="ne-text">在计算机系统中，中断就像女人的脾气一样无时无刻都在产生，中断的出现往往是让人很不爽的。中断处理程序又被称为</span><code class="ne-code"><span class="ne-text">中断服务程序</span></code><span class="ne-text"> 或者是 </span><code class="ne-code"><span class="ne-text">ISR(Interrupt Service Routines)</span></code><span class="ne-text">，它是最靠近硬件的一层。中断处理程序由硬件中断、软件中断或者是软件异常启动产生的中断，用于实现设备驱动程序或受保护的操作模式（例如系统调用）之间的转换。</span></p><p id="90650cff08428997dffa1476c683dc7d" class="ne-p"><br></p><p id="fb6ef6915c1d6c5b6dc560331811403c" class="ne-p"><span class="ne-text">中断处理程序负责处理中断发生时的所有操作，操作完成后阻塞，然后启动中断驱动程序来解决阻塞。通常会有三种通知方式，依赖于不同的具体实现</span></p><p id="ad18698c37cb1386d4706b9bbd1f4b18" class="ne-p"><br></p><ul class="ne-ul"><li id="d0bf3529fd768e31495ed16c17aff466"><span class="ne-text">信号量实现中：在信号量上使用 </span><code class="ne-code"><span class="ne-text">up</span></code><span class="ne-text"> 进行通知；</span></li><li id="270d701c94d64a8cac75bef7a1a8005c"><span class="ne-text">管程实现：对管程中的条件变量执行 </span><code class="ne-code"><span class="ne-text">signal</span></code><span class="ne-text"> 操作</span></li></ul><ul class="ne-ul"><li id="a5a1d1b1aca07b60a91e3c1ff266e036"><span class="ne-text">还有一些情况是发送一些消息</span></li></ul><p id="e31a7428eaec4de703b54c063801fb8d" class="ne-p"><br></p><h3 id="62e973ec"><span class="ne-text">设备驱动程序</span></h3><p id="72c1ffdc38a4bc2a1e7f08037f01f10f" class="ne-p"><br></p><p id="ff158f09e0c7d71bdd01b66caa4a81b7" class="ne-p"><span class="ne-text">每个连接到计算机的 I/O 设备都需要有某些特定设备的代码对其进行控制。这些提供 I/O 设备到设备控制器转换的过程的代码称为 </span><code class="ne-code"><span class="ne-text">设备驱动程序(Device driver)</span></code><span class="ne-text">。</span></p><p id="ec30527260057319b095d7f987af51b2" class="ne-p"><br></p><p id="c44d98b89a8cb33f62b8d0170aba3810" class="ne-p"><span class="ne-text">设备控制器的主要功能有下面这些</span></p><p id="a8ef9058a6e1d341ecda61b3859848f2" class="ne-p"><br></p><ul class="ne-ul"><li id="03e25f8eb054ac95ed4d49b5e64491fb"><span class="ne-text">接收和识别命令：设备控制器可以接受来自 CPU 的指令，并进行识别。设备控制器内部也会有寄存器，用来存放指令和参数</span></li><li id="9b58f4a82cbcbee09a8c32dbae5e5a4b"><span class="ne-text">进行数据交换：CPU、控制器和设备之间会进行数据的交换，CPU 通过总线把指令发送给控制器，或从控制器中并行地读出数据；控制器将数据写入指定设备。</span></li></ul><ul class="ne-ul"><li id="cee546a33ac12989b6ae397dd0e2575f"><span class="ne-text">地址识别：每个硬件设备都有自己的地址，设备控制器能够识别这些不同的地址，来达到控制硬件的目的，此外，为使 CPU 能向寄存器中写入或者读取数据，这些寄存器都应具有唯一的地址。</span></li><li id="663801b37deb964c633d23a86521b554"><span class="ne-text">差错检测：设备控制器还具有对设备传递过来的数据进行检测的功能。</span></li></ul><p id="186d2e5b3c69f4cc63090482bc71d034" class="ne-p"><br></p><p id="918cc521f50cf3d9e06f10a4209a52a2" class="ne-p"><span class="ne-text">在这种情况下，设备控制器会阻塞，直到中断来解除阻塞状态。还有一种情况是操作是可以无延迟的完成，所以驱动程序不需要阻塞。在第一种情况下，操作系统可能被中断唤醒；第二种情况下操作系统不会被休眠。</span></p><p id="4dc6d4e2af5d94415071e30bbf4dedd3" class="ne-p"><br></p><p id="1921ce376109381d2b798c1d0d33e21e" class="ne-p"><span class="ne-text">设备驱动程序必须是</span><code class="ne-code"><span class="ne-text">可重入</span></code><span class="ne-text">的，因为设备驱动程序会阻塞和唤醒然后再次阻塞。驱动程序不允许进行系统调用，但是它们通常需要与内核的其余部分进行交互。</span></p><p id="b14ceef4943a55f53f523e4cce258b4d" class="ne-p"><br></p><h3 id="e3bc39ca"><span class="ne-text">与设备无关的 I/O 软件</span></h3><p id="10f8fed94d32fc074de365780434ded0" class="ne-p"><br></p><p id="ebda650d821c17681ecaf27bac82b100" class="ne-p"><span class="ne-text">I/O 软件有两种，一种是我们上面介绍过的基于特定设备的，还有一种是</span><code class="ne-code"><span class="ne-text">设备无关性</span></code><span class="ne-text">的，设备无关性也就是不需要特定的设备。设备驱动程序与设备无关的软件之间的界限取决于具体的系统。下面显示的功能由设备无关的软件实现</span></p><p id="0738bab2eec34e7d51f649716df70129" class="ne-p"><br></p><p id="0f127c6454010b4bb99d4d0e7ed1f1ba" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830586-059b4da8-ea81-4a5a-b884-3377ca39d976.png" width="428" id="qRr1F" class="ne-image"></p><p id="5e72fbe3b21aa9f1140fb098efa4b1ce" class="ne-p"><br></p><p id="7d6498e221ca9dbc841a87b949759de7" class="ne-p"><span class="ne-text">与设备无关的软件的基本功能是对所有设备执行公共的 I/O 功能，并且向用户层软件提供一个统一的接口。</span></p><p id="2147c0bb4a536252e4e10fe043856497" class="ne-p"><br></p><h4 id="beeaff4e-1"><span class="ne-text">缓冲</span></h4><p id="70b3be0dccb8514110943a6e97648b17" class="ne-p"><br></p><p id="af82636aa6623d48560a80e60ca7a455" class="ne-p"><span class="ne-text">无论是对于块设备还是字符设备来说，缓冲都是一个非常重要的考量标准。缓冲技术应用广泛，但它也有缺点。如果数据被缓冲次数太多，会影响性能。</span></p><p id="14ca5e8726df30d891d845d39491b86f" class="ne-p"><br></p><h4 id="6a8bef7b-1"><span class="ne-text">错误处理</span></h4><p id="1bd1dadfd62e3af3a1173bcb759bfb94" class="ne-p"><br></p><p id="b09255dfe1fe9917fbddf39e9aa593de" class="ne-p"><span class="ne-text">在 I/O 中，出错是一种再正常不过的情况了。当出错发生时，操作系统必须尽可能处理这些错误。有一些错误是只有特定的设备才能处理，有一些是由框架进行处理，这些错误和特定的设备无关。</span></p><p id="965a674df58190d1b05557392745253b" class="ne-p"><br></p><p id="ee5331138dfc8e986ea7badf7ba49ce5" class="ne-p"><span class="ne-text">I/O 错误的一类是程序员</span><code class="ne-code"><span class="ne-text">编程</span></code><span class="ne-text">错误，比如还没有打开文件前就读流，或者不关闭流导致内存溢出等等。这类问题由程序员处理；另外一类是实际的 I/O 错误，例如向一个磁盘坏块写入数据，无论怎么写都写入不了。这类问题由驱动程序处理，驱动程序处理不了交给硬件处理，这个我们上面也说过。</span></p><p id="522aff626808aa1e8c176163d925a242" class="ne-p"><br></p><h4 id="4e16fdac"><span class="ne-text">设备驱动程序统一接口</span></h4><p id="b4d2e1f579a5150b9d5d256369497333" class="ne-p"><br></p><p id="26833baca0c0963e267e4649428f43be" class="ne-p"><span class="ne-text">我们在操作系统概述中说到，操作系统一个非常重要的功能就是屏蔽了硬件和软件的差异性，为硬件和软件提供了统一的标准，这个标准还体现在为设备驱动程序提供统一的接口，因为不同的硬件和厂商编写的设备驱动程序不同，所以如果为每个驱动程序都单独提供接口的话，这样没法搞，所以必须统一。</span></p><p id="bbde6811238d412e5b62ea43f1d18f97" class="ne-p"><br></p><h4 id="c74ca274"><span class="ne-text">分配和释放</span></h4><p id="4aba2ddd488b12a50616973441385c40" class="ne-p"><br></p><p id="dfe10ac47170d60e5e6d5d9b24b9c827" class="ne-p"><span class="ne-text">一些设备例如打印机，它只能由一个进程来使用，这就需要操作系统根据实际情况判断是否能够对设备的请求进行检查，判断是否能够接受其他请求，一种比较简单直接的方式是在特殊文件上执行 </span><code class="ne-code"><span class="ne-text">open</span></code><span class="ne-text">操作。如果设备不可用，那么直接 open 会导致失败。还有一种方式是不直接导致失败，而是让其阻塞，等到另外一个进程释放资源后，在进行 open 打开操作。这种方式就把选择权交给了用户，由用户判断是否应该等待。</span></p><p id="510e44b2f5b8f53eaa9a17d6fbf08d28" class="ne-p"><br></p><h4 id="5dae479a"><span class="ne-text">设备无关的块</span></h4><p id="cdbefea531e399d091ad67a9c010a18e" class="ne-p"><br></p><p id="97f7a0d77ba330bf8aa1481f43e9db01" class="ne-p"><span class="ne-text">不同的磁盘会具有不同的扇区大小，但是软件不会关心扇区大小，只管存储就是了。一些字符设备可以一次一个字节的交付数据，而其他的设备则以较大的单位交付数据，这些差异也可以隐藏起来。</span></p><p id="7c1bb67a7692b24f169e8ed1c7dd6425" class="ne-p"><br></p><h3 id="6d8fb3eb"><span class="ne-text">用户空间的 I/O 软件</span></h3><p id="22e1a0b547c5bcd83b395670c5dfbddf" class="ne-p"><br></p><p id="b44115534de48afe22f229f049c4dd3d" class="ne-p"><span class="ne-text">虽然大部分 I/O 软件都在内核结构中，但是还有一些在用户空间实现的 I/O 软件，凡事没有绝对。一些 I/O 软件和库过程在用户空间存在，然后以提供系统调用的方式实现。</span></p><p id="daf9ee811684e122a58c85cb4e3d1ab8" class="ne-p"><br></p><h2 id="ff4efcaf"><span class="ne-text">盘</span></h2><p id="f670bd979c27b25d4c7d4fc8220167b5" class="ne-p"><br></p><p id="46790dad61b28c8d412e582e4b59070a" class="ne-p"><span class="ne-text">盘可以说是硬件里面比较简单的构造了，同时也是最重要的。下面我们从盘谈起，聊聊它的物理构造</span></p><p id="6f9f8e17698ca692669e1ed2b80c6402" class="ne-p"><br></p><h3 id="6f7147b6"><span class="ne-text">盘硬件</span></h3><p id="881f0a078f484235fe35102fd05a5fcc" class="ne-p"><br></p><p id="410790e052c1df4a2afe5f919551a676" class="ne-p"><span class="ne-text">盘会有很多种类型。其中最简单的构造就是</span><code class="ne-code"><span class="ne-text">磁盘(magnetic hard disks)</span></code><span class="ne-text">， 也被称为 </span><code class="ne-code"><span class="ne-text">hard disk,HDD</span></code><span class="ne-text">等。磁盘通常与安装在磁臂上的磁头配对，磁头可将数据读取或者将数据写入磁盘，因此磁盘的读写速度都同样快。在磁盘中，数据是随机访问的，这也就说明可以通过任意的顺序来</span><code class="ne-code"><span class="ne-text">存储</span></code><span class="ne-text">和</span><code class="ne-code"><span class="ne-text">检索</span></code><span class="ne-text">单个数据块，所以你可以在任意位置放置磁盘来让磁头读取，磁盘是一种</span><code class="ne-code"><span class="ne-text">非易失性</span></code><span class="ne-text">的设备，即使断电也能永久保留。</span></p><p id="7697974a6ae1d7204b416004062d2c44" class="ne-p"><br></p><h4 id="4f5537dd"><span class="ne-text">磁盘</span></h4><p id="a7ccf8203470d7449eecb013543925cd" class="ne-p"><br></p><p id="99c3228c34d08b56f9e4be97cf06b550" class="ne-p"><span class="ne-text">为了组织和检索数据，会将磁盘组织成特定的结构，这些特定的结构就是</span><strong><span class="ne-text">磁道、扇区和柱面</span></strong></p><p id="4aef88f0b558db891f24c06feed2859c" class="ne-p"><br></p><p id="1ffcc406a94d9db392fcc0964818d5f3" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830596-8b2a7f11-b5c9-4a00-b0c9-436889b099a8.png" width="498" id="XlRJ3" class="ne-image"></p><p id="6b06d914be3bc7c54870e83b6c07bc5f" class="ne-p"><br></p><p id="37a4261fd1b90279efe2e7508794d558" class="ne-p"><span class="ne-text">磁盘被组织成柱面形式，每个盘用轴相连，每一个柱面包含若干磁道，每个磁道由若干扇区组成。软盘上大约每个磁道有 8 - 32 个扇区，硬盘上每条磁道上扇区的数量可达几百个，磁头大约是 1 - 16 个。</span></p><p id="97b0132a4dc0ae7ea912969bd55fd30b" class="ne-p"><br></p><p id="81575d25682d5751d39b94b88d20e861" class="ne-p"><span class="ne-text">对于磁盘驱动程序来说，一个非常重要的特性就是控制器是否能够同时控制两个或者多个驱动器进行磁道寻址，这就是</span><code class="ne-code"><span class="ne-text">重叠寻道(overlapped seek)</span></code><span class="ne-text">。对于控制器来说，它能够控制一个磁盘驱动程序完成寻道操作，同时让其他驱动程序等待寻道结束。控制器也可以在一个驱动程序上进行读写草哦做，与此同时让另外的驱动器进行寻道操作，但是软盘控制器不能在两个驱动器上进行读写操作。</span></p><p id="62b66fc124bdd060dc868e7aac33e6d7" class="ne-p"><br></p><h4 id="RAID"><span class="ne-text">RAID</span></h4><p id="ffaba10a54eaac5469b3370e3b57ec33" class="ne-p"><br></p><p id="06399267d1efd2f5ec1beb76f23a781c" class="ne-p"><span class="ne-text">RAID 称为 </span><code class="ne-code"><span class="ne-text">磁盘冗余阵列</span></code><span class="ne-text">，简称 </span><code class="ne-code"><span class="ne-text">磁盘阵列</span></code><span class="ne-text">。利用虚拟化技术把多个硬盘结合在一起，成为一个或多个磁盘阵列组，目的是提升性能或数据冗余。</span></p><p id="e603443b78b137065f5838e183e64ae6" class="ne-p"><br></p><p id="d99b54a84a692f29ff775f8d078930b0" class="ne-p"><span class="ne-text">RAID 有不同的级别</span></p><p id="006985b2d9a124508177b0fe9a97e3d8" class="ne-p"><br></p><ul class="ne-ul"><li id="fc7b26a623451b45652560652f0ce2dc"><span class="ne-text">RAID 0 - 无容错的条带化磁盘阵列</span></li><li id="608dcc8c4da9da1cc93901fce2f72bd4"><span class="ne-text">RAID 1 - 镜像和双工</span></li></ul><ul class="ne-ul"><li id="e2f271c87c776d795773644ce782a5be"><span class="ne-text">RAID 2 - 内存式纠错码</span></li><li id="b865a2f4bbc441c2d6c00230b77ba8a6"><span class="ne-text">RAID 3 - 比特交错奇偶校验</span></li></ul><ul class="ne-ul"><li id="ffd5c142e5fbb5f5caeb8ad4d2df93a9"><span class="ne-text">RAID 4 - 块交错奇偶校验</span></li><li id="b27145d5ca28e12929413d476ca9d1d4"><span class="ne-text">RAID 5 - 块交错分布式奇偶校验</span></li></ul><ul class="ne-ul"><li id="44edb52008f1699295a33a01674147e4"><span class="ne-text">RAID 6 - P + Q冗余</span></li></ul><p id="e0dd1db8bb6fec97312e991f0c0702d6" class="ne-p"><br></p><h4 id="a0c9482b"><span class="ne-text">磁盘格式化</span></h4><p id="603ffce150e2fc1d987dcfd88ae12f0e" class="ne-p"><br></p><p id="2892a91ceec697d1af55116f4eed65ed" class="ne-p"><span class="ne-text">磁盘由一堆铝的、合金或玻璃的盘片组成，磁盘刚被创建出来后，没有任何信息。磁盘在使用前必须经过</span><code class="ne-code"><span class="ne-text">低级格式化(low-levvel format)</span></code><span class="ne-text">，下面是一个扇区的格式</span></p><p id="237635b0cde6098f7edf3d17b16c4fb5" class="ne-p"><br></p><p id="9eb9a9e1de2f4cd41c8c10489509b3f3" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830611-1b106d56-fbdb-4e79-b2b5-e5bd2778a387.png" width="638" id="LU06a" class="ne-image"></p><p id="0c16920b767cb6ec4ea66f9992882f6b" class="ne-p"><br></p><p id="0666a317b3e567ada28b40a2ae4678b7" class="ne-p"><span class="ne-text">前导码相当于是标示扇区的开始位置，通常以位模式开始，前导码还包括</span><code class="ne-code"><span class="ne-text">柱面号</span></code><span class="ne-text">、</span><code class="ne-code"><span class="ne-text">扇区号</span></code><span class="ne-text">等一些其他信息。紧随前导码后面的是数据区，数据部分的大小由低级格式化程序来确定。大部分磁盘使用 512 字节的扇区。数据区后面是 ECC，ECC 的全称是 </span><strong><span class="ne-text">error correction code</span></strong><span class="ne-text"> ，</span><code class="ne-code"><span class="ne-text">数据纠错码</span></code><span class="ne-text">，它与普通的错误检测不同，ECC 还可以用于恢复读错误。ECC 阶段的大小由不同的磁盘制造商实现。ECC 大小的设计标准取决于</span><strong><span class="ne-text">设计者愿意牺牲多少磁盘空间来提高可靠性</span></strong><span class="ne-text">，以及程序可以处理的 ECC 的复杂程度。通常情况下 ECC 是 16 位，除此之外，硬盘一般具有一定数量的备用扇区，用于替换制造缺陷的扇区。</span></p><p id="7528fe0235fd15d3595da91dcbfc864d" class="ne-p"><br></p><h3 id="760df63f"><span class="ne-text">磁盘臂调度算法</span></h3><p id="b6278a03e824428f665cec4c6e256f50" class="ne-p"><br></p><p id="03e011ea5a88d0387736e681d5ce4617" class="ne-p"><span class="ne-text">下面我们来探讨一下关于影响磁盘读写的算法，一般情况下，影响磁盘快读写的时间由下面几个因素决定</span></p><p id="314b5126105ededa2a365cf439adc99f" class="ne-p"><br></p><ul class="ne-ul"><li id="7462d9403fc3252905f5a028434ad7c1"><span class="ne-text">寻道时间 - 寻道时间指的就是将磁盘臂移动到需要读取磁盘块上的时间</span></li><li id="5f7257bc3d72ff601be446ec912b45ca"><span class="ne-text">旋转延迟 - 等待合适的扇区旋转到磁头下所需的时间</span></li></ul><ul class="ne-ul"><li id="2be1b7ef29e9defa9d00b39f69ec3494"><span class="ne-text">实际数据的读取或者写入时间</span></li></ul><p id="2b370356fac399fe05f109995162a179" class="ne-p"><br></p><p id="0dc67d0cf7fad6f14c4ad3b58f27915e" class="ne-p"><span class="ne-text">这三种时间参数也是磁盘寻道的过程。一般情况下，寻道时间对总时间的影响最大，所以，有效的降低寻道时间能够提高磁盘的读取速度。</span></p><p id="91c6c8ce16ce7b9388de0e43ef253a37" class="ne-p"><br></p><p id="8d11395ec1947cc3a0b7ab12754b4328" class="ne-p"><span class="ne-text">如果磁盘驱动程序每次接收一个请求并按照接收顺序完成请求，这种处理方式也就是 </span><code class="ne-code"><span class="ne-text">先来先服务(First-Come, First-served, FCFS)</span></code><span class="ne-text"> ，这种方式很难优化寻道时间。因为每次都会按照顺序处理，不管顺序如何，有可能这次读完后需要等待一个磁盘旋转一周才能继续读取，而其他柱面能够马上进行读取，这种情况下每次请求也会排队。</span></p><p id="7d18009d76c74dd7b8db33951c729bd5" class="ne-p"><br></p><p id="c10ff5cc598f273b4133beab2f7333d7" class="ne-p"><span class="ne-text">通常情况下，磁盘在进行寻道时，其他进程会产生其他的磁盘请求。磁盘驱动程序会维护一张表，表中会记录着柱面号当作索引，每个柱面未完成的请求会形成链表，链表头存放在表的相应表项中。</span></p><p id="e046aef3abb66ef5daf5fc38d4c7ca3e" class="ne-p"><br></p><p id="6a69ca5623a5c553a4153757cc235dc8" class="ne-p"><span class="ne-text">一种对先来先服务的算法改良的方案是使用 </span><code class="ne-code"><span class="ne-text">最短路径优先(SSF)</span></code><span class="ne-text"> 算法，下面描述了这个算法。</span></p><p id="32b5296ec1d24eb2a7d5a6939088ad43" class="ne-p"><br></p><p id="9b84f8da5378b036c6c206344a7a7154" class="ne-p"><span class="ne-text">假如我们在对磁道 6 号进行寻址时，同时发生了对 11 , 2 , 4, 14, 8, 15, 3 的请求，如果采用先来先服务的原则，如下图所示</span></p><p id="807006c94eac31f179e807c72677c14d" class="ne-p"><br></p><p id="139b589cb34fee0e242e2a53b569c729" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830646-2dfee703-9a35-47c9-880c-2c620d64464a.png" width="762" id="GIQle" class="ne-image"></p><p id="852c3cef391fcf30dcbc45d68ead84cb" class="ne-p"><br></p><p id="07318c6d578eb7970403c2e9c0200380" class="ne-p"><span class="ne-text">我们可以计算一下磁盘臂所跨越的磁盘数量为 5 + 9 + 2 + 10 + 6 + 7 + 12 = 51，相当于是跨越了 51 次盘面，如果使用最短路径优先，我们来计算一下跨越的盘面</span></p><p id="9251d4187ee9e3955d98e126f5a61b7b" class="ne-p"><br></p><p id="f7750d7e03767b8fb7464af21e31e096" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830629-e3cda6d4-2317-438b-a377-9e5dc5a3a802.png" width="709" id="k9irp" class="ne-image"></p><p id="33fc7e528d1fb915ae0e5eb381f979a1" class="ne-p"><br></p><p id="a31730f3fb60b31dd1c442e0b3c89ff8" class="ne-p"><span class="ne-text">跨越的磁盘数量为 4 + 1 + 1 + 4 + 3 + 3 + 1 = 17 ，相比 51 足足省了两倍的时间。</span></p><p id="aeb569eb1e81c5ef30132a4f118513d6" class="ne-p"><br></p><p id="bbe4e798ae04ba9181c1b53f7030014c" class="ne-p"><span class="ne-text">但是，最短路径优先的算法也不是完美无缺的，这种算法照样存在问题，那就是</span><code class="ne-code"><span class="ne-text">优先级</span></code><span class="ne-text"> 问题，</span></p><p id="33bbdf6c3903be454a5434c1b4b45129" class="ne-p"><br></p><p id="753770733d67a5f8ee48a11ff1bbe27a" class="ne-p"><span class="ne-text">这里有一个原型可以参考就是我们日常生活中的电梯，电梯使用一种</span><code class="ne-code"><span class="ne-text">电梯算法(elevator algorithm)</span></code><span class="ne-text"> 来进行调度，从而满足协调效率和公平性这两个相互冲突的目标。电梯一般会保持向一个方向移动，直到在那个方向上没有请求为止，然后改变方向。</span></p><p id="58e3089c129557a6025b4b2e291be8e5" class="ne-p"><br></p><p id="6148ba2cda1c3131d27d57b6737daef0" class="ne-p"><span class="ne-text">电梯算法需要维护一个</span><code class="ne-code"><span class="ne-text">二进制位</span></code><span class="ne-text">，也就是当前的方向位：</span><code class="ne-code"><span class="ne-text">UP(向上)</span></code><span class="ne-text">或者是 </span><code class="ne-code"><span class="ne-text">DOWN(向下)</span></code><span class="ne-text">。当一个请求处理完成后，磁盘或电梯的驱动程序会检查该位，如果此位是 UP 位，磁盘臂或者电梯仓移到下一个更高跌未完成的请求。如果高位没有未完成的请求，则取相反方向。当方向位是 </span><code class="ne-code"><span class="ne-text">DOWN</span></code><span class="ne-text"> 时，同时存在一个低位的请求，磁盘臂会转向该点。如果不存在的话，那么它只是停止并等待。</span></p><p id="e90c80069ca940c4dccc45414d988aa6" class="ne-p"><br></p><p id="2e5464096db15e05287322aedc930903" class="ne-p"><span class="ne-text">我们举个例子来描述一下电梯算法，比如各个柱面得到服务的顺序是 4，7，10，14，9，6，3，1 ，那么它的流程图如下</span></p><p id="f8c4a980d7ccbf906215cfae641fb9de" class="ne-p"><br></p><p id="9db3b630e1e92fea3c4e594885ac701c" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830648-6e8afe9c-f2fd-4c64-8db9-7f68930d0a27.png" width="710" id="qkkaP" class="ne-image"></p><p id="c0843a5f92d2fd7b0137831f7a66b398" class="ne-p"><br></p><p id="56a54c492ce1f8a483ad07c078eedaa6" class="ne-p"><span class="ne-text">所以电梯算法需要跨越的盘面数量是 3 + 3 + 4 + 5 + 3 + 3 + 1 = 22</span></p><p id="6537fc8bf8f453295d6a455f604979f3" class="ne-p"><br></p><p id="67c0f7b60aa67bfebb7ad608b2d9b80e" class="ne-p"><span class="ne-text">电梯算法通常情况下不如 SSF 算法。</span></p><p id="6cdbd3e42df5f443f82a300371150d79" class="ne-p"><br></p><h3 id="6a8bef7b-2"><span class="ne-text">错误处理</span></h3><p id="cd448c76eee05090052f87c787370093" class="ne-p"><br></p><p id="e35a9d1da80fb23de9e8c755ab4375f7" class="ne-p"><span class="ne-text">一般坏块有两种处理办法，一种是在控制器中进行处理；一种是在操作系统层面进行处理。</span></p><p id="f72cda08c63f4925bb58c1e69dc98731" class="ne-p"><br></p><p id="efe36e8265e3ea31c5ca3acbbd4d2419" class="ne-p"><span class="ne-text">这两种方法经常替换使用，比如一个具有 30 个数据扇区和两个备用扇区的磁盘，其中扇区 4 是有瑕疵的。</span></p><p id="46e08dedb1f01e545beee9d410b8ca30" class="ne-p"><br></p><p id="973a0923ca8878b60159e1381d2db988" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830690-4489f1b3-d4a8-49d6-bd29-1becb143d418.png" width="423" id="j9QM3" class="ne-image"></p><p id="efc58b0eaccde5c29602b247280b7659" class="ne-p"><br></p><p id="c04a32c0f9c7869487d8bf460b2af6f0" class="ne-p"><span class="ne-text">控制器能做的事情就是将备用扇区之一重新映射。</span></p><p id="b409a58389fcff3598c331a89f6dbeb2" class="ne-p"><br></p><p id="4da899689af489cd2c870ae6658c4290" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830735-2f51c8ae-a37f-4673-9781-a2519263c63f.png" width="500" id="BSem5" class="ne-image"></p><p id="8e494cf7453125ff435eff2d552fb41d" class="ne-p"><br></p><p id="e6f45bb62550a08872dea21674e5c005" class="ne-p"><span class="ne-text">还有一种处理方式是将所有的扇区都向上移动一个扇区</span></p><p id="c46a73b199e28b719c907ef92d49b313" class="ne-p"><br></p><p id="48f0cc7b31fc216b96308193861a1900" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830717-1dc1be76-6eff-4891-8d89-843a7110e6a8.png" width="497" id="OZ9U3" class="ne-image"></p><p id="c3abc09db901f9b310fad8ef6cdb5415" class="ne-p"><br></p><p id="1559044f1c5e9c73aff061102d26bd29" class="ne-p"><span class="ne-text">上面这这两种情况下控制器都必须知道哪个扇区，可以通过内部的表来跟踪这一信息，或者通过重写前导码来给出重新映射的扇区号。如果是重写前导码，那么涉及移动的方式必须重写后面所有的前导码，但是最终会提供良好的性能。</span></p><p id="f15e6f8229cb758b7b0c9e8ebb12edd8" class="ne-p"><br></p><h3 id="dd4fb2cb"><span class="ne-text">稳定存储器</span></h3><p id="4ad899cab1ab97a5aabbaf01a5be34cf" class="ne-p"><br></p><p id="58e282adac0cb4419208d340a02153a8" class="ne-p"><span class="ne-text">磁盘经常会出现错误，导致好的扇区会变成坏扇区，驱动程序也有可能挂掉。RAID 可以对扇区出错或者是驱动器崩溃提出保护，然而 RAID 却不能对坏数据中的写错误提供保护，也不能对写操作期间的崩溃提供保护，这样就会破坏原始数据。</span></p><p id="473a78fd5112572f75a9b22ad7bf64eb" class="ne-p"><br></p><p id="27763f1b1c4778a17eba274ab07dbeec" class="ne-p"><span class="ne-text">我们期望磁盘能够准确无误的工作，但是事实情况是不可能的，但是我们能够知道的是，一个磁盘子系统具有如下特性：当一个写命令发给它时，磁盘要么正确地写数据，要么什么也不做，让现有的数据完整无误的保留。这样的系统称为 </span><code class="ne-code"><span class="ne-text">稳定存储器(stable storage)</span></code><span class="ne-text">。 稳定存储器的目标就是不惜一切代价保证磁盘的一致性。</span></p><p id="e0bbd24c6e2eac90bc9bef03d023565c" class="ne-p"><br></p><p id="23c65e8ec21c9f98369932ed2ca149d8" class="ne-p"><span class="ne-text">稳定存储器使用两个一对相同的磁盘，对应的块一同工作形成一个无差别的块。稳定存储器为了实现这个目的，定义了下面三种操作：</span></p><p id="5fb6db8f32f3839372d1c236a3e8bf98" class="ne-p"><br></p><ul class="ne-ul"><li id="11e13f4166e70f36fb7c87fb739dea9c"><code class="ne-code"><span class="ne-text">稳定写(stable write)</span></code></li><li id="895c72d40eb8c8f6b8d1b19066db9933"><code class="ne-code"><span class="ne-text">稳定读(stable read)</span></code></li></ul><ul class="ne-ul"><li id="da686324dfe297329016a5be43c1141d"><code class="ne-code"><span class="ne-text">崩溃恢复(crash recovery)</span></code></li></ul><p id="3bf3c6998eede59026606fee3cbb805a" class="ne-p"><br></p><h2 id="751437d1"><span class="ne-text">时钟</span></h2><p id="42bfc7cc58126df175de0804edb625f1" class="ne-p"><br></p><p id="275f2f33e6f9a41aaf0f1af466175266" class="ne-p"><code class="ne-code"><span class="ne-text">时钟(Clocks)</span></code><span class="ne-text"> 也被称为</span><code class="ne-code"><span class="ne-text">定时器(timers)</span></code><span class="ne-text">，时钟/定时器对任何程序系统来说都是必不可少的。时钟负责维护时间、防止一个进程长期占用 CPU 时间等其他功能。</span><code class="ne-code"><span class="ne-text">时钟软件(clock software)</span></code><span class="ne-text"> 也是一种设备驱动的方式。下面我们就来对时钟进行介绍，一般都是先讨论硬件再介绍软件，采用由下到上的方式，也是告诉你，底层是最重要的。</span></p><p id="53b9aa404a3a4a083622863777556273" class="ne-p"><br></p><h3 id="e8a4fb9a"><span class="ne-text">时钟硬件</span></h3><p id="2a655f87074ad58d9ef984e79932a319" class="ne-p"><br></p><p id="8ef96daa1f5875a499646dd402188b1f" class="ne-p"><span class="ne-text">在计算机中有两种类型的时钟，这些时钟与现实生活中使用的时钟完全不一样。</span></p><p id="2e4a913ade7c6d01a0f32f2a434d095c" class="ne-p"><br></p><ul class="ne-ul"><li id="55f7695ceccc219d7810683c20403f2f"><span class="ne-text">比较简单的一种时钟被连接到 110 V 或 220 V 的电源线上，这样每个</span><code class="ne-code"><span class="ne-text">电压周期</span></code><span class="ne-text">会产生一个中断，大概是 50 - 60 HZ。这些时钟过去一直占据支配地位。</span></li><li id="cf9376a6328b7c2eb22a1a93c6f08aa6"><span class="ne-text">另外的一种时钟由晶体振荡器、计数器和寄存器组成，示意图如下所示</span></li></ul><p id="439d4fe21f5ac9db8fcc1898d175e44d" class="ne-p"><br></p><p id="58e69eb2dd1d8030de36ab796376c1f3" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830741-6daaaf06-0552-44b1-bf19-85729fd25288.png" width="627" id="VUI1p" class="ne-image"></p><p id="138cdebd4b5315b038710c7d2442d19c" class="ne-p"><br></p><p id="fed5845bb86ffee727f4ec21c1f3305b" class="ne-p"><span class="ne-text">这种时钟称为</span><code class="ne-code"><span class="ne-text">可编程时钟</span></code><span class="ne-text"> ，可编程时钟有两种模式，一种是 </span><code class="ne-code"><span class="ne-text">一键式(one-shot mode)</span></code><span class="ne-text">，当时钟启动时，会把存储器中的值复制到计数器中，然后，每次晶体的振荡器的脉冲都会使计数器 -1。当计数器变为 0 时，会产生一个中断，并停止工作，直到软件再一次显示启动。还有一种模式时 </span><code class="ne-code"><span class="ne-text">方波(square-wave mode)</span></code><span class="ne-text"> 模式，在这种模式下，当计数器变为 0 并产生中断后，存储寄存器的值会自动复制到计数器中，这种周期性的中断称为一个时钟周期。</span></p><p id="bda3a730c41682e58599382a899dcd60" class="ne-p"><br></p><h3 id="b173f2cb"><span class="ne-text">时钟软件</span></h3><p id="d8bdf65c9a5135888a2497a3439f7145" class="ne-p"><br></p><p id="b00c628ad58f5b5dce23e9850a61c034" class="ne-p"><span class="ne-text">时钟硬件所做的工作只是根据已知的时间间隔产生中断，而其他的工作都是由</span><code class="ne-code"><span class="ne-text">时钟软件</span></code><span class="ne-text">来完成，一般操作系统的不同，时钟软件的具体实现也不同，但是一般都会包括以下这几点</span></p><p id="c9f6a7282375ba50967103b96e0fa187" class="ne-p"><br></p><ul class="ne-ul"><li id="87f3966c7f38a21ec3de2e00caa8c495"><span class="ne-text">维护一天的时间</span></li><li id="83f9eb2354f6857b43e402f24d895af3"><span class="ne-text">阻止进程运行的时间超过其指定时间</span></li></ul><ul class="ne-ul"><li id="b15f932d0660dfeed727e20b42edf52d"><span class="ne-text">统计 CPU 的使用情况</span></li><li id="5b41149ddbaee4b2dc5216e16149e38a"><span class="ne-text">处理用户进程的警告系统调用</span></li></ul><ul class="ne-ul"><li id="3e1b60c00fc9f9f5bc20bfc979ef00a2"><span class="ne-text">为系统各个部分提供看门狗定时器</span></li><li id="d2276a0cd1af25e63d9f08f9fe7ee549"><span class="ne-text">完成概要剖析，监视和信息收集</span></li></ul><p id="9e1dabd93c76dcfad0d1beab34188d56" class="ne-p"><br></p><h3 id="b91fda0e"><span class="ne-text">软定时器</span></h3><p id="95ae8d930b294e9c0fbf9c4a05ebbc55" class="ne-p"><br></p><p id="a5c4252cb21d8d6068043a7afe3d314c" class="ne-p"><span class="ne-text">时钟软件也被称为可编程时钟，可以设置它以程序需要的任何速率引发中断。时钟软件触发的中断是一种硬中断，但是某些应用程序对于硬中断来说是不可接受的。</span></p><p id="f79ba5cf1321c60b2dc29763e734e1ac" class="ne-p"><br></p><p id="e6dfdfd7167d693006ca2a8a105d7c9b" class="ne-p"><span class="ne-text">这时候就需要一种</span><code class="ne-code"><span class="ne-text">软定时器(soft timer)</span></code><span class="ne-text"> 避免了中断，无论何时当内核因为某种原因呢在运行时，它返回用户态之前都会检查时钟来了解软定时器是否到期。如果软定时器到期，则执行被调度的事件也无需切换到内核态，因为本身已经处于内核态中。这种方式避免了频繁的内核态和用户态之前的切换，提高了程序运行效率。</span></p><p id="4d84d77fd04a9489fe535b3daa4f7b69" class="ne-p"><br></p><p id="d50c55b092a1800b5a7f27a4dc606790" class="ne-p"><span class="ne-text">软定时器因为不同的原因切换进入内核态的速率不同，原因主要有</span></p><p id="b15053b7084f5d35f327aba23c558ddd" class="ne-p"><br></p><ul class="ne-ul"><li id="e896c450129d2ead85b0eb99d11bb5eb"><span class="ne-text">系统调用</span></li><li id="0c1a4062ca9907469cc5b5a914f250ef"><span class="ne-text">TLB 未命中</span></li></ul><ul class="ne-ul"><li id="f984a4635683adf2eff00aa2764aae22"><span class="ne-text">缺页异常</span></li><li id="1e8fa7b36d7c84263c14a105f9d8a40a"><span class="ne-text">I/O 中断</span></li></ul><ul class="ne-ul"><li id="8584034cbecc7bed86a6ce92b0021351"><span class="ne-text">CPU 变得空闲</span></li></ul><p id="8c1b12bc4cb14f1332748c06db0e8a82" class="ne-p"><br></p><p id="20bd0c60869e5232c1a9da4f41bc3362" class="ne-p"><span class="ne-text">死锁问题也是操作系统非常重要的一类问题</span></p><p id="d8b84eaac214a26402cf69e0457896cb" class="ne-p"><br></p><p id="2e47e39e0877ecee085aa3aa086c4bd7" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830748-305133ff-5324-4e46-b119-74609aedd401.png" width="721" id="WK6xj" class="ne-image"></p><p id="a9d7734a1e890759c5b156cdd8f82011" class="ne-p"><br></p><h2 id="eee83a92"><span class="ne-text">资源</span></h2><p id="d7231e68daee7dc7da7271048e9e2f43" class="ne-p"><br></p><p id="9478bc370ebcfa642d99c1b1d4e681fa" class="ne-p"><span class="ne-text">大部分的死锁都和资源有关，在进程对设备、文件具有独占性（排他性）时会产生死锁。我们把这类需要排他性使用的对象称为</span><code class="ne-code"><span class="ne-text">资源(resource)</span></code><span class="ne-text">。资源主要分为 </span><strong><span class="ne-text">可抢占资源和不可抢占资源</span></strong></p><p id="3eac1e4d117abd05087b36175c975155" class="ne-p"><br></p><h3 id="27201743"><span class="ne-text">可抢占资源和不可抢占资源</span></h3><p id="72ec56e9b234da0b742fc02a6cabc6f5" class="ne-p"><br></p><p id="aca2fb281a7bd5541bea22c94bd6b33a" class="ne-p"><span class="ne-text">资源主要有可抢占资源和不可抢占资源。</span><code class="ne-code"><span class="ne-text">可抢占资源(preemptable resource)</span></code><span class="ne-text"> 可以从拥有它的进程中抢占而不会造成其他影响，内存就是一种可抢占性资源，任何进程都能够抢先获得内存的使用权。</span></p><p id="5b8beb8ea2c4de6036320fcc924dcf57" class="ne-p"><br></p><p id="e1b275fbf0b76f9c98f8612371b35e35" class="ne-p"><code class="ne-code"><span class="ne-text">不可抢占资源(nonpreemtable resource)</span></code><span class="ne-text"> 指的是除非引起错误或者异常，否则进程无法抢占指定资源，这种不可抢占的资源比如有光盘，在进程执行调度的过程中，其他进程是不能得到该资源的。</span></p><p id="1bb4f502e68b522ee9f808e108067db3" class="ne-p"><br></p><h2 id="60461afa"><span class="ne-text">死锁</span></h2><p id="fb62f7163749f731b9eea44242c66117" class="ne-p"><br></p><p id="fd64352b74e15c5119d31f2d078fa99f" class="ne-p"><span class="ne-text">如果要对死锁进行一个定义的话，下面的定义比较贴切</span></p><p id="481b22ddedf0cdb8abca22a089108ce4" class="ne-p"><br></p><p id="baae47f87c55b321b1a847755d5bd5a2" class="ne-p"><strong><span class="ne-text">如果一组进程中的每个进程都在等待一个事件，而这个事件只能由该组中的另一个进程触发，这种情况会导致死锁</span></strong><span class="ne-text">。</span></p><p id="cd3b049f801c785902aa2ee9f5537659" class="ne-p"><br></p><h3 id="a4ffc042"><span class="ne-text">资源死锁的条件</span></h3><p id="8cf2cde31de59698515b56ec5a49c581" class="ne-p"><br></p><p id="7bf9ec1a4e71c2362bc024c611a36dab" class="ne-p"><span class="ne-text">针对我们上面的描述，资源死锁可能出现的情况主要有</span></p><p id="d2965e8c80a02d9f6ae8ad4dd9741a6c" class="ne-p"><br></p><ul class="ne-ul"><li id="2461cac20ec655f2ce5216f716ed970d"><span class="ne-text">互斥条件：每个资源都被分配给了一个进程或者资源是可用的</span></li><li id="b59b3d4339b30dbbd1d4c840019f29fa"><span class="ne-text">保持和等待条件：已经获取资源的进程被认为能够获取新的资源</span></li></ul><ul class="ne-ul"><li id="c83defcb158380ae745008f1ce2e7b4b"><span class="ne-text">不可抢占条件：分配给一个进程的资源不能强制的从其他进程抢占资源，它只能由占有它的进程显示释放</span></li><li id="24871dfae1e4208085188d6d4dffdce3"><span class="ne-text">循环等待：死锁发生时，系统中一定有两个或者两个以上的进程组成一个循环，循环中的每个进程都在等待下一个进程释放的资源。</span></li></ul><p id="57e7bca96f378b5215fc1af485de28e6" class="ne-p"><br></p><p id="ec8baeee4c99e209781933e1f1514ea9" class="ne-p"><span class="ne-text">发生死锁时，上面的情况必须同时会发生。如果其中任意一个条件不会成立，死锁就不会发生。可以通过破坏其中任意一个条件来破坏死锁，下面这些破坏条件就是我们探讨的重点</span></p><p id="1df908aa8bf7935a457c9c552b0fea44" class="ne-p"><br></p><h3 id="2ba04a66"><span class="ne-text">死锁模型</span></h3><p id="a04f8c5e84de9684afc27ae414a6d779" class="ne-p"><br></p><p id="85b83d0ed4eb6aa01bc52b5c0e6916ca" class="ne-p"><span class="ne-text">Holt 在 1972 年提出对死锁进行建模，建模的标准如下：</span></p><p id="35efa46631e12a3613067329ef47eaa6" class="ne-p"><br></p><ul class="ne-ul"><li id="5c6ff301023c6b32a75add616a9f195a"><span class="ne-text">圆形表示进程</span></li><li id="8fd6eb48acae20dc5052e40e62d39242"><span class="ne-text">方形表示资源</span></li></ul><p id="76e680e1ac67826c1904b922f2508207" class="ne-p"><br></p><p id="0eb57a1be3e1c45d5a9d5d78b3855fb1" class="ne-p"><span class="ne-text">从资源节点到进程节点表示资源已经被进程占用，如下图所示</span></p><p id="59962074ed9fa78004d8f206555aeb1c" class="ne-p"><br></p><p id="e23a383dff53004dac74daaebfa5cf62" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830760-e22f0a74-94ab-4be7-9b39-3f611c32823a.png" width="331" id="BjL47" class="ne-image"></p><p id="0a2f8ae870c3bb8c95857ace4b4c3e73" class="ne-p"><br></p><p id="cdfcbee5b6e9b6948f037308db4d7622" class="ne-p"><span class="ne-text">在上图中表示当前资源 R 正在被 A 进程所占用</span></p><p id="67676b8c22e281f016c0d0b1e01204e0" class="ne-p"><br></p><p id="1fb8a54214e882e963e6db8825977fc4" class="ne-p"><span class="ne-text">由进程节点到资源节点的有向图表示当前进程正在请求资源，并且该进程已经被阻塞，处于等待这个资源的状态</span></p><p id="bb1747bacfa748ab9f5f396430510658" class="ne-p"><br></p><p id="53fdec97a470c1c990d4c19da34a87c2" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830813-2b57251b-055b-4664-b040-89f60d1d43c4.png" width="345" id="u51ZN" class="ne-image"></p><p id="fc7fcab5e87f8354278b202646ce6bb8" class="ne-p"><br></p><p id="2ca0e28dee5d52b527286b9f49dc14da" class="ne-p"><span class="ne-text">在上图中，表示的含义是进程 B 正在请求资源 S 。Holt 认为，死锁的描述应该如下</span></p><p id="3f72668bb9a949d52e87791eae34010b" class="ne-p"><br></p><p id="51082e3beb38f015ef3ac95212b138d2" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830811-a3afe75e-0c48-40b9-8fa4-e74d132d9b58.png" width="485" id="bhef4" class="ne-image"></p><p id="01f74cd30421be5cf72c44619b12477f" class="ne-p"><br></p><p id="01f565a83434d718c7ae59fd03de6811" class="ne-p"><span class="ne-text">这是一个死锁的过程，进程 C 等待资源 T 的释放，资源 T 却已经被进程 D 占用，进程 D 等待请求占用资源 U ，资源 U 却已经被线程 C 占用，从而形成环。</span></p><p id="b237901b2be04c14ea3abad0df23223c" class="ne-p"><br></p><p id="d3950d5ac640dba2723c9ce141487292" class="ne-p"><span class="ne-text">有四种处理死锁的策略：</span></p><p id="9c28eb93725ce1026b8e57cbdc9d884a" class="ne-p"><br></p><ul class="ne-ul"><li id="f02059d209937e043cc91b3202332b45"><span class="ne-text">忽略死锁带来的影响（惊呆了）</span></li><li id="7ed0ecd020c81e768cc3daddc64d269c"><span class="ne-text">检测死锁并回复死锁，死锁发生时对其进行检测，一旦发生死锁后，采取行动解决问题</span></li></ul><ul class="ne-ul"><li id="15d6f899a7a219f73c9f9c5d3d84284a"><span class="ne-text">通过仔细分配资源来避免死锁</span></li><li id="3480f5545cb59921ddc8cce5bb380e7e"><span class="ne-text">通过破坏死锁产生的四个条件之一来避免死锁</span></li></ul><p id="01bc1144b78631aef94e579fa8d1d912" class="ne-p"><br></p><p id="495a1907b5f77a040cb025c261a0dde9" class="ne-p"><span class="ne-text">下面我们分别介绍一下这四种方法</span></p><p id="364bc81ab84b40122e907de1d02cf761" class="ne-p"><br></p><h2 id="445e7ac3"><span class="ne-text">鸵鸟算法</span></h2><p id="036b75a65beb0a6e2c2ca45ebd1bf297" class="ne-p"><br></p><p id="e6043383dfd449422770da6892dcea16" class="ne-p"><span class="ne-text">最简单的解决办法就是使用</span><code class="ne-code"><span class="ne-text">鸵鸟算法(ostrich algorithm)</span></code><span class="ne-text">，把头埋在沙子里，假装问题根本没有发生。每个人看待这个问题的反应都不同。数学家认为死锁是不可接受的，必须通过有效的策略来防止死锁的产生。工程师想要知道问题发生的频次，系统因为其他原因崩溃的次数和死锁带来的严重后果。如果死锁发生的频次很低，而经常会由于硬件故障、编译器错误等其他操作系统问题导致系统崩溃，那么大多数工程师不会修复死锁。</span></p><p id="52f6db636d5ff751b26f95bdd338d289" class="ne-p"><br></p><h2 id="c34052de"><span class="ne-text">死锁检测和恢复</span></h2><p id="225135e8a2070f389de38812717eb75d" class="ne-p"><br></p><p id="f06571b2cb07e67da53eb1f9ae46f666" class="ne-p"><span class="ne-text">第二种技术是死锁的检测和恢复。这种解决方式不会尝试去阻止死锁的出现。相反，这种解决方案会希望死锁尽可能的出现，在监测到死锁出现后，对其进行恢复。下面我们就来探讨一下死锁的检测和恢复的几种方式</span></p><p id="14ee619ccacc077fbb0ab230f795ff08" class="ne-p"><br></p><h3 id="845b19bd"><span class="ne-text">每种类型一个资源的死锁检测方式</span></h3><p id="8856acadce3e4be26400996c75037a18" class="ne-p"><br></p><p id="1dce1bbff3adfcf55a761b49b459a9a9" class="ne-p"><span class="ne-text">每种资源类型都有一个资源是什么意思？我们经常提到的打印机就是这样的，资源只有打印机，但是设备都不会超过一个。</span></p><p id="7aa26a189549bf96df754b2f1ace77ae" class="ne-p"><br></p><p id="ae3dd6af307505c10b0eb562a80986f1" class="ne-p"><span class="ne-text">可以通过构造一张资源分配表来检测这种错误，比如我们上面提到的</span></p><p id="57bb0ac633cecdfa908fa75afa54cbdc" class="ne-p"><br></p><p id="ad5e4cd721b90f28101f2acd23afe3bb" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830848-f4bc59e7-89e2-4e78-909c-e8dcd1718ebe.png" width="475" id="TYPR7" class="ne-image"></p><p id="2745a826110fc96a2b6216f300175397" class="ne-p"><br></p><p id="32c152b4a1b42accb3ee8f73ca42fd9a" class="ne-p"><span class="ne-text">如果这张图包含了一个或一个以上的环，那么死锁就存在，处于这个环中任意一个进程都是死锁的进程。</span></p><p id="00db8fb2a967b493da00c952b7385bb2" class="ne-p"><br></p><h3 id="0e6d1847"><span class="ne-text">每种类型多个资源的死锁检测方式</span></h3><p id="feab24bd3b82d2799e2dac6d56957450" class="ne-p"><br></p><p id="8675e27ef21c4d6f4e3c390a9039463d" class="ne-p"><span class="ne-text">如果有多种相同的资源存在，就需要采用另一种方法来检测死锁。可以通过构造一个矩阵来检测从 P1 -&gt; Pn 这 n 个进程中的死锁。</span></p><p id="04fc31dd56db424542188c800706797c" class="ne-p"><br></p><p id="a24b641ae3e9651167024af87187bf28" class="ne-p"><span class="ne-text">现在我们提供一种基于矩阵的算法来检测从 P1 到 Pn 这 n 个进程中的死锁。假设资源类型为 m，E1 代表资源类型1，E2 表示资源类型 2 ，Ei 代表资源类型 i (1 &lt;= i &lt;= m)。E 表示的是 </span><code class="ne-code"><span class="ne-text">现有资源向量(existing resource vector)</span></code><span class="ne-text">，代表每种已存在的资源总数。</span></p><p id="9d26e86025397b8d6319268fa76a93a3" class="ne-p"><br></p><p id="41f401b08793431302caeb310f9f5076" class="ne-p"><span class="ne-text">现在我们就需要构造两个数组：C 表示的是</span><code class="ne-code"><span class="ne-text">当前分配矩阵(current allocation matrix)</span></code><span class="ne-text"> ，R 表示的是 </span><code class="ne-code"><span class="ne-text">请求矩阵(request matrix)</span></code><span class="ne-text">。Ci 表示的是 Pi 持有每一种类型资源的资源数。所以，Cij 表示 Pi 持有资源 j 的数量。Rij 表示 Pi 所需要获得的资源 j 的数量</span></p><p id="66cca3aac1c7c3a268bcf0cbe528756c" class="ne-p"><br></p><p id="92630dcca8243665dde0564f6c12e1cd" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830847-d4f0a077-7abd-4507-a720-337bc99b121e.png" width="686" id="JZ0fA" class="ne-image"></p><p id="56bc171dc0bf324243530e635d5bab68" class="ne-p"><br></p><p id="423bab2c70172066263bee3d30dad1f7" class="ne-p"><span class="ne-text">一般来说，已分配资源 j 的数量加起来再和所有可供使用的资源数相加 = 该类资源的总数。</span></p><p id="77aae0d262cefbaa04162ad431e28520" class="ne-p"><br></p><p id="6c93735bd020f34c0a7d4addc689ef08" class="ne-p"><span class="ne-text">死锁的检测就是基于向量的比较。每个进程起初都是没有被标记过的，算法会开始对进程做标记，进程被标记后说明进程被执行了，不会进入死锁，当算法结束时，任何没有被标记过的进程都会被判定为死锁进程。</span></p><p id="14e91ed8d03af86ca1b09968d2699d12" class="ne-p"><br></p><p id="124b222886574ccd5653fc831d93cb96" class="ne-p"><span class="ne-text">上面我们探讨了两种检测死锁的方式，那么现在你知道怎么检测后，你何时去做死锁检测呢？一般来说，有两个考量标准：</span></p><p id="1a40a355ed7a5a9fea8130b2e3e33388" class="ne-p"><br></p><ul class="ne-ul"><li id="ee8c565c1201d24a8441c6fbb77ece7b"><span class="ne-text">每当有资源请求时就去检测，这种方式会占用昂贵的 CPU 时间。</span></li><li id="afc8b082824e82774c1c3be31d74ac3e"><span class="ne-text">每隔 k 分钟检测一次，或者当 CPU 使用率降低到某个标准下去检测。考虑到 CPU 效率的原因，如果死锁进程达到一定数量，就没有多少进程可以运行，所以 CPU 会经常空闲。</span></li></ul><p id="6488c6772dd853d8292d2e105a388286" class="ne-p"><br></p><h3 id="95bdbdb5"><span class="ne-text">从死锁中恢复</span></h3><p id="a374c9f6b0536b99e76dc7d380d5ad4d" class="ne-p"><br></p><p id="6c6fa66bb994f4b13767e0758e7bc15b" class="ne-p"><span class="ne-text">上面我们探讨了如何检测进程死锁，我们最终的目的肯定是想让程序能够正常的运行下去，所以针对检测出来的死锁，我们要对其进行恢复，下面我们会探讨几种死锁的恢复方式</span></p><p id="17c663707ef8dd6df4ca3362d812f340" class="ne-p"><br></p><h4 id="82459936"><span class="ne-text">通过抢占进行恢复</span></h4><p id="8611e726a4b51bbc2a2a73b2584f2cf4" class="ne-p"><br></p><p id="b09a07bd4466a6494cae3cb7b5f3487c" class="ne-p"><span class="ne-text">在某些情况下，可能会临时将某个资源从它的持有者转移到另一个进程。比如在不通知原进程的情况下，将某个资源从进程中强制取走给其他进程使用，使用完后又送回。这种恢复方式一般比较困难而且有些简单粗暴，并不可取。</span></p><p id="9db11e547d3327df9fd8150582728d11" class="ne-p"><br></p><h4 id="48c12fe7"><span class="ne-text">通过回滚进行恢复</span></h4><p id="7c6c5b54d8c697c690324a6fa94cdf41" class="ne-p"><br></p><p id="718e20e97011e6148925c731421cd028" class="ne-p"><span class="ne-text">如果系统设计者和机器操作员知道有可能发生死锁，那么就可以定期检查流程。进程的检测点意味着进程的状态可以被写入到文件以便后面进行恢复。检测点不仅包含</span><code class="ne-code"><span class="ne-text">存储映像(memory image)</span></code><span class="ne-text">，还包含</span><code class="ne-code"><span class="ne-text">资源状态(resource state)</span></code><span class="ne-text">。一种更有效的解决方式是不要覆盖原有的检测点，而是每出现一个检测点都要把它写入到文件中，这样当进程执行时，就会有一系列的检查点文件被累积起来。</span></p><p id="339f29e4c95b23688e573aa6483a9909" class="ne-p"><br></p><p id="600363987ac3776bc472e109917d4090" class="ne-p"><span class="ne-text">为了进行恢复，要从上一个较早的检查点上开始，这样所需要资源的进程会回滚到上一个时间点，在这个时间点上，死锁进程还没有获取所需要的资源，可以在此时对其进行资源分配。</span></p><p id="2d8e54e18dce59911f57770e4ea8f824" class="ne-p"><br></p><h4 id="ec735624"><span class="ne-text">杀死进程恢复</span></h4><p id="b10cebb135de327c0a84909c0003ab1f" class="ne-p"><br></p><p id="1c29d7da30e23b9c755589852bb6efe3" class="ne-p"><span class="ne-text">最简单有效的解决方案是直接杀死一个死锁进程。但是杀死一个进程可能照样行不通，这时候就需要杀死别的资源进行恢复。</span></p><p id="4665eae3b27d917878b8ac71b95d7352" class="ne-p"><br></p><p id="b4068288f1099860bf4bef3010a9cc89" class="ne-p"><span class="ne-text">另外一种方式是选择一个环外的进程作为牺牲品来释放进程资源。</span></p><p id="1bb34cd91b0412e04dc1a611adbc6be6" class="ne-p"><br></p><h2 id="9f401114"><span class="ne-text">死锁避免</span></h2><p id="d96231a65e2b63d55b620a5f9679a5f5" class="ne-p"><br></p><p id="460e408b4f85f86b4fc5ffc9c3cabaaa" class="ne-p"><span class="ne-text">我们上面讨论的是如何检测出现死锁和如何恢复死锁，下面我们探讨几种规避死锁的方式</span></p><p id="e2769cc5a198cfa247c1b1e14580c945" class="ne-p"><br></p><h3 id="221804d8"><span class="ne-text">单个资源的银行家算法</span></h3><p id="e89b2e891d5b7f70257c4553152b1789" class="ne-p"><br></p><p id="59b8da1dc357e739ca2d3879ad6138c5" class="ne-p"><span class="ne-text">银行家算法是 Dijkstra 在 1965 年提出的一种调度算法，它本身是一种死锁的调度算法。它的模型是基于一个城镇中的银行家，银行家向城镇中的客户承诺了一定数量的贷款额度。算法要做的就是判断请求是否会进入一种不安全的状态。如果是，就拒绝请求，如果请求后系统是安全的，就接受该请求。</span></p><p id="41faefa6584da64f07618f4036a158d8" class="ne-p"><br></p><p id="7507faed5c63e725af97d762eaec96b0" class="ne-p"><span class="ne-text">类似的，还有多个资源的银行家算法，读者可以自行了解。</span></p><p id="c6c2f8962b34bd84d67b6adae75e4c47" class="ne-p"><br></p><h2 id="1c662b9c"><span class="ne-text">破坏死锁</span></h2><p id="1042b3632351757a6665bfb3b2cab55c" class="ne-p"><br></p><p id="614019792c2d83e0b74de617146216f2" class="ne-p"><span class="ne-text">死锁本质上是无法避免的，因为它需要获得未知的资源和请求，但是死锁是满足四个条件后才出现的，它们分别是</span></p><p id="342083631481cc21a58439f88448ba23" class="ne-p"><br></p><ul class="ne-ul"><li id="7f073eb63fdf3296f66785047892f3da"><span class="ne-text">互斥</span></li><li id="8ec9e0fc4c8a1ce01e825d8cb74487f5"><span class="ne-text">保持和等待</span></li></ul><ul class="ne-ul"><li id="3243ef42ffbe01b313da032f2182b94e"><span class="ne-text">不可抢占</span></li><li id="d45e0cad6dc74d87e3c08fec2ee0f8d8"><span class="ne-text">循环等待</span></li></ul><p id="fe59f031b5ed305654906780fa2edef6" class="ne-p"><br></p><p id="7177a34bdca01a41d03870d15ba1e6a8" class="ne-p"><span class="ne-text">我们分别对这四个条件进行讨论，按理说破坏其中的任意一个条件就能够破坏死锁</span></p><p id="c27bcda5e1b8bdec4067b11fcc6c05d8" class="ne-p"><br></p><h3 id="48c312fb"><span class="ne-text">破坏互斥条件</span></h3><p id="26613ade80fc258b9f36f537ecc823f0" class="ne-p"><br></p><p id="d10c8076c6a1afdc5be18d3da29045a0" class="ne-p"><span class="ne-text">我们首先考虑的就是</span><strong><span class="ne-text">破坏互斥使用条件</span></strong><span class="ne-text">。如果资源不被一个进程独占，那么死锁肯定不会产生。如果两个打印机同时使用一个资源会造成混乱，打印机的解决方式是使用 </span><code class="ne-code"><span class="ne-text">假脱机打印机(spooling printer)</span></code><span class="ne-text"> ，这项技术可以允许多个进程同时产生输出，在这种模型中，实际请求打印机的唯一进程是打印机守护进程，也称为后台进程。后台进程不会请求其他资源。我们可以消除打印机的死锁。</span></p><p id="0075a1624d67b11ba8d15ed77b0e1b7b" class="ne-p"><br></p><p id="4bf1551f195c5c46cf38ed105690a369" class="ne-p"><span class="ne-text">后台进程通常被编写为能够输出完整的文件后才能打印，假如两个进程都占用了假脱机空间的一半，而这两个进程都没有完成全部的输出，就会导致死锁。</span></p><p id="fa76008afa94ebc89b5a16b2f22cd27c" class="ne-p"><br></p><p id="4709a3f6c7bb8468e3d0556402b77cd3" class="ne-p"><span class="ne-text">因此，尽量做到尽可能少的进程可以请求资源。</span></p><p id="95cb9bb0e7f02afb35945ffbb03cb13b" class="ne-p"><br></p><h3 id="1ce8619b"><span class="ne-text">破坏保持等待的条件</span></h3><p id="a0402a5e468f049bcea75885f6bdb094" class="ne-p"><br></p><p id="59a68622dc4bdac082e2cf8505d3a8a3" class="ne-p"><span class="ne-text">第二种方式是如果我们能阻止持有资源的进程请求其他资源，我们就能够消除死锁。一种实现方式是让所有的进程开始执行前请求全部的资源。如果所需的资源可用，进程会完成资源的分配并运行到结束。如果有任何一个资源处于频繁分配的情况，那么没有分配到资源的进程就会等待。</span></p><p id="cc80a0d7d7adc5e15d896ab15932e1d9" class="ne-p"><br></p><p id="44f4b6bc44f660cc6ec2cb66a0dcab09" class="ne-p"><span class="ne-text">很多进程</span><strong><span class="ne-text">无法在执行完成前就知道到底需要多少资源</span></strong><span class="ne-text">，如果知道的话，就可以使用银行家算法；还有一个问题是这样</span><strong><span class="ne-text">无法合理有效利用资源</span></strong><span class="ne-text">。</span></p><p id="cb584b7d098165ccd9f854d4403c81a7" class="ne-p"><br></p><p id="e4c08e27eb55f0691ba9869f7d983987" class="ne-p"><span class="ne-text">还有一种方式是进程在请求其他资源时，先释放所占用的资源，然后再尝试一次获取全部的资源。</span></p><p id="b1b1836523c7189c11cdf7b4a834cab5" class="ne-p"><br></p><h3 id="d83055ce"><span class="ne-text">破坏不可抢占条件</span></h3><p id="83056be73110a576565be358f73dc447" class="ne-p"><br></p><p id="d095796526d11fc7b3a879f40f8b76af" class="ne-p"><span class="ne-text">破坏不可抢占条件也是可以的。可以通过虚拟化的方式来避免这种情况。</span></p><p id="595c68731aa3abbd5a09a8c780c2c6fb" class="ne-p"><br></p><h3 id="75513240"><span class="ne-text">破坏循环等待条件</span></h3><p id="2cce5860fcb20508493132ff4d52c8e7" class="ne-p"><br></p><p id="6bd78a1878c0b44133e8615952a7b6cd" class="ne-p"><span class="ne-text">现在就剩最后一个条件了，循环等待条件可以通过多种方法来破坏。一种方式是制定一个标准，一个进程在任何时候只能使用一种资源。如果需要另外一种资源，必须释放当前资源。对于需要将大文件从磁带复制到打印机的过程，此限制是不可接受的。</span></p><p id="3e6e2f47972b8cfddb751b8b98fd4e57" class="ne-p"><br></p><p id="ff2b35f6c8e9a28f1b38326659b83623" class="ne-p"><span class="ne-text">另一种方式是将所有的资源统一编号，如下图所示</span></p><p id="c009095ac315c19ae85c392536222bb8" class="ne-p"><br></p><p id="719cfd06171e090674e6588ea72e2514" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830860-d72b0344-264f-4bfe-91f7-43d5b4121f58.png" width="419" id="Nm5h1" class="ne-image"></p><p id="378b45679e11bbc4ae4cbb1bb07f051b" class="ne-p"><br></p><p id="4d406e8ec640206937c30f4f87d1e0df" class="ne-p"><span class="ne-text">进程可以在任何时间提出请求，但是所有的请求都必须按照资源的顺序提出。如果按照此分配规则的话，那么资源分配之间不会出现环。</span></p><p id="33a3a40e0e4503fb2a58f13489a613ad" class="ne-p"><br></p><p id="d0388e319759e7f357c45d4e95179c2e" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830858-19d66189-e808-4999-879e-3e2e8d4273f0.png" width="423" id="xulHt" class="ne-image"></p><p id="8c42c0e89584a6d912c13ee84ca0d1da" class="ne-p"><br></p><p id="998a94d4e63eda812da79b5f56e93eea" class="ne-p"><span class="ne-text">尽管通过这种方式来消除死锁，但是编号的顺序不可能让每个进程都会接受。</span></p><p id="65f5a9bf2b2f3359e44646086bf6db51" class="ne-p"><br></p><h2 id="bf52b411"><span class="ne-text">其他问题</span></h2><p id="3b41d963203b64c7498fc565603991b5" class="ne-p"><br></p><p id="d91adc7b4ff6e74ed3b09939b40132d8" class="ne-p"><span class="ne-text">下面我们来探讨一下其他问题，包括 </span><strong><span class="ne-text">通信死锁、活锁是什么、饥饿问题和两阶段加锁</span></strong></p><p id="48288ba7fbb610cf326cedc0d9f0f6d7" class="ne-p"><br></p><h3 id="e8230499"><span class="ne-text">两阶段加锁</span></h3><p id="1e34b78f13fa6ccb27f3e79ce5525ea9" class="ne-p"><br></p><p id="9a404aeba16fe407449e9620f8e60b5a" class="ne-p"><span class="ne-text">虽然很多情况下死锁的避免和预防都能处理，但是效果并不好。随着时间的推移，提出了很多优秀的算法用来处理死锁。例如在数据库系统中，一个经常发生的操作是请求锁住一些记录，然后更新所有锁定的记录。当同时有多个进程运行时，就会有死锁的风险。</span></p><p id="31bbdd311778f49d2f23e1b5f99582fb" class="ne-p"><br></p><p id="6a87b8d5f0df4dfddf9222397284816e" class="ne-p"><span class="ne-text">一种解决方式是使用 </span><code class="ne-code"><span class="ne-text">两阶段提交(two-phase locking)</span></code><span class="ne-text">。顾名思义分为两个阶段，一阶段是进程尝试一次锁定它需要的所有记录。如果成功后，才会开始第二阶段，第二阶段是执行更新并释放锁。第一阶段并不做真正有意义的工作。</span></p><p id="5b1b66cb117a5aa66675875203023dc1" class="ne-p"><br></p><p id="d0a72b442ed8f3bf7c655ddef2038559" class="ne-p"><span class="ne-text">如果在第一阶段某个进程所需要的记录已经被加锁，那么该进程会释放所有锁定的记录并重新开始第一阶段。从某种意义上来说，这种方法类似于预先请求所有必需的资源或者是在进行一些不可逆的操作之前请求所有的资源。</span></p><p id="6d0daef74b5849a82b735e9072ff2277" class="ne-p"><br></p><p id="40ca79e448a5b8410caca0b328fa6ae5" class="ne-p"><span class="ne-text">不过在一般的应用场景中，两阶段加锁的策略并不通用。如果一个进程缺少资源就会半途中断并重新开始的方式是不可接受的。</span></p><p id="a93254cb959a97f440ed888fe197b863" class="ne-p"><br></p><h3 id="44d2b9b0"><span class="ne-text">通信死锁</span></h3><p id="2130ade79d2e280cb7ddd6f93f606bae" class="ne-p"><br></p><p id="64776094a4eeb9c963f8960bfdd20280" class="ne-p"><span class="ne-text">我们上面一直讨论的是资源死锁，资源死锁是一种死锁类型，但并不是唯一类型，还有通信死锁，也就是两个或多个进程在发送消息时出现的死锁。进程 A 给进程 B 发了一条消息，然后进程 A 阻塞直到进程 B 返回响应。假设请求消息丢失了，那么进程 A 在一直等着回复，进程 B 也会阻塞等待请求消息到来，这时候就产生</span><code class="ne-code"><span class="ne-text">死锁</span></code><span class="ne-text">。</span></p><p id="7b2dca72612d5432be0e4378ee44b636" class="ne-p"><br></p><p id="40989330fbee6643a7ebeab9d1b7f7e8" class="ne-p"><span class="ne-text">尽管会产生死锁，但是这并不是一个资源死锁，因为 A 并没有占据 B 的资源。事实上，通信死锁并没有完全可见的资源。根据死锁的定义来说：每个进程因为等待其他进程引起的事件而产生阻塞，这就是一种死锁。相较于最常见的通信死锁，我们把上面这种情况称为</span><code class="ne-code"><span class="ne-text">通信死锁(communication deadlock)</span></code><span class="ne-text">。</span></p><p id="0cde873bd73f03c66e1e81dfabb9ecff" class="ne-p"><br></p><p id="14dbb722a2f2fd6709732ca83eedd397" class="ne-p"><span class="ne-text">通信死锁不能通过调度的方式来避免，但是可以使用通信中一个非常重要的概念来避免：</span><code class="ne-code"><span class="ne-text">超时(timeout)</span></code><span class="ne-text">。在通信过程中，只要一个信息被发出后，发送者就会启动一个定时器，定时器会记录消息的超时时间，如果超时时间到了但是消息还没有返回，就会认为消息已经丢失并重新发送，通过这种方式，可以避免通信死锁。</span></p><p id="05e534c4b272054adbc3e743bbb87ed5" class="ne-p"><br></p><p id="ebad5559c5e8228b7c32bd7e22a53fcc" class="ne-p"><span class="ne-text">但是并非所有网络通信发生的死锁都是通信死锁，也存在资源死锁，下面就是一个典型的资源死锁。</span></p><p id="43db3302928da79ca9d4847a52057335" class="ne-p"><br></p><p id="d2066eecb8a130f79bde31d4bc952698" class="ne-p"><span class="ne-text">当一个数据包从主机进入路由器时，会被放入一个缓冲区，然后再传输到另外一个路由器，再到另一个，以此类推直到目的地。缓冲区都是资源并且数量有限。如下图所示，每个路由器都有 10 个缓冲区（实际上有很多）。</span></p><p id="fd8d6b4496f962959fbda6d31e8fe14a" class="ne-p"><br></p><p id="4605b8d7affea0247962f50ca34605a0" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830887-98d92f9c-72d1-4710-a487-1bd4dc953b7c.png" width="702" id="JN6QA" class="ne-image"></p><p id="3cc175c53ce850923dd266c70fa2d2da" class="ne-p"><br></p><p id="404a0deda9c033b83ccdd5f1e1085499" class="ne-p"><span class="ne-text">假如路由器 A 的所有数据需要发送到 B ，B 的所有数据包需要发送到 D，然后 D 的所有数据包需要发送到 A 。没有数据包可以移动，因为在另一端没有缓冲区可用，这就是一个典型的资源死锁。</span></p><p id="c619f7fb9d739d143fbd13aed16af5e1" class="ne-p"><br></p><h3 id="94c14e72"><span class="ne-text">活锁</span></h3><p id="d58bf9c2b4a5f6bbecbf4b7136473e80" class="ne-p"><br></p><p id="4cf25a1c790a47e1298e729b06421709" class="ne-p"><span class="ne-text">某些情况下，当进程意识到它不能获取所需要的下一个锁时，就会尝试礼貌的释放已经获得的锁，然后等待非常短的时间再次尝试获取。可以想像一下这个场景：当两个人在狭路相逢的时候，都想给对方让路，相同的步调会导致双方都无法前进。</span></p><p id="65625d90055aa1173e9f493729a8a70a" class="ne-p"><br></p><p id="38424978488c1ad9578cd5c604bd379c" class="ne-p"><span class="ne-text">现在假想有一对并行的进程用到了两个资源。它们分别尝试获取另一个锁失败后，两个进程都会释放自己持有的锁，再次进行尝试，这个过程会一直进行重复。很明显，这个过程中没有进程阻塞，但是进程仍然不会向下执行，这种状况我们称之为 </span><code class="ne-code"><span class="ne-text">活锁(livelock)</span></code><span class="ne-text">。</span></p><p id="2772a3ba2c19ab0d95902ec3f6f3fc3d" class="ne-p"><br></p><h3 id="48073fce"><span class="ne-text">饥饿</span></h3><p id="d44dc6d0b955b9b3194082ba392239a7" class="ne-p"><br></p><p id="d089c608be88bd00f0435afcf9fedf5b" class="ne-p"><span class="ne-text">与死锁和活锁的一个非常相似的问题是 </span><code class="ne-code"><span class="ne-text">饥饿(starvvation)</span></code><span class="ne-text">。想象一下你什么时候会饿？一段时间不吃东西是不是会饿？对于进程来讲，最重要的就是资源，如果一段时间没有获得资源，那么进程会产生饥饿，这些进程会永远得不到服务。</span></p><p id="2cbb310b9cbe820deb2a9140fd73b7b2" class="ne-p"><br></p><p id="2ae27778a42bd6691929243288b93f65" class="ne-p"><span class="ne-text">我们假设打印机的分配方案是每次都会分配给最小文件的进程，那么要打印大文件的进程会永远得不到服务，导致进程饥饿，进程会无限制的推后，虽然它没有阻塞。</span></p><p id="31731cb931d8de3f4bb18fd8da9bc111" class="ne-p"><br></p></div></div></div><div class="-mx-4 mt-12 sm:-mx-6 lg:-mx-8" style="filter:blur(10px);opacity:0"><div data-orientation="horizontal" role="none" data-slot="separator" class="bg-border shrink-0 data-[orientation=horizontal]:h-px data-[orientation=horizontal]:w-full data-[orientation=vertical]:h-full data-[orientation=vertical]:w-px"></div></div><div style="filter:blur(10px);opacity:0;transform:translateY(-30px)"><nav class="mt-8 grid gap-4 md:grid-cols-2"><a class="hover:bg-muted group flex flex-col rounded-lg border p-4 transition-colors" href="/blog/apohu8"><span class="text-muted-foreground mb-2 text-sm">上一篇</span><span class="group-hover:text-primary line-clamp-2 font-medium transition-colors">ANN神经网络</span></a><a class="hover:bg-muted group flex flex-col rounded-lg border p-4 text-right transition-colors md:text-right" href="/blog/nvlr2g"><span class="text-muted-foreground mb-2 text-sm">下一篇</span><span class="group-hover:text-primary line-clamp-2 font-medium transition-colors">常用软件快捷键/CMD/Linux命令及其他使用</span></a></nav></div></article></div><div class="m-6 w-full flex-1 bg-[radial-gradient(circle_at_center,color-mix(in_oklab,var(--primary)_15%,transparent)_2px,transparent_2px)] bg-size-[18px_18px] max-xl:hidden"></div></div></section><!--$--><!--/$--></main><footer class="relative h-60"><div class="mx-auto flex max-w-6xl justify-center border-x px-8 py-7" style="filter:blur(10px);opacity:0"><a class="flex flex-col items-center gap-3" href="/"><img src="/logo.png" alt="Logo" class="size-12.5"/><span class="text-xl font-semibold uppercase">尼采般地抒情</span></a></div><div style="filter:blur(10px);opacity:0"><div data-orientation="horizontal" role="none" data-slot="separator" class="bg-border shrink-0 data-[orientation=horizontal]:h-px data-[orientation=horizontal]:w-full data-[orientation=vertical]:h-full data-[orientation=vertical]:w-px"></div></div><div class="mx-auto flex max-w-6xl flex-wrap items-center justify-center gap-3 border-x px-8 py-7" style="filter:blur(10px);opacity:0"><a class="text-muted-foreground link-animated hover:text-foreground text-lg transition-colors duration-300" href="/about">关于我</a></div><div style="filter:blur(10px);opacity:0"><div data-orientation="horizontal" role="none" data-slot="separator" class="bg-border shrink-0 data-[orientation=horizontal]:h-px data-[orientation=horizontal]:w-full data-[orientation=vertical]:h-full data-[orientation=vertical]:w-px"></div></div><div class="mx-auto flex max-w-6xl items-center justify-center gap-4 border-x px-8 py-7" style="filter:blur(10px);opacity:0"><div class="contents"><a target="_blank" rel="noopener noreferrer" aria-label="GitHub" href="https://github.com/wztlink1013"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-github size-5" aria-hidden="true"><path d="M15 22v-4a4.8 4.8 0 0 0-1-3.5c3 0 6-2 6-5.5.08-1.25-.27-2.48-1-3.5.28-1.15.28-2.35 0-3.5 0 0-1 0-3 1.5-2.64-.5-5.36-.5-8 0C6 2 5 2 5 2c-.3 1.15-.3 2.35 0 3.5A5.403 5.403 0 0 0 4 9c0 3.5 3 5.5 6 5.5-.39.49-.68 1.05-.85 1.65-.17.6-.22 1.23-.15 1.85v4"></path><path d="M9 18c-4.51 2-5-2-7-2"></path></svg></a><div data-orientation="vertical" role="none" data-slot="separator" class="bg-border shrink-0 data-[orientation=horizontal]:h-px data-[orientation=horizontal]:w-full data-[orientation=vertical]:w-px data-[orientation=vertical]:h-4"></div></div><div class="contents"><a target="_blank" rel="noopener noreferrer" aria-label="X (Twitter)" href="https://x.com/wztlink1013"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-twitter size-5 text-amber-600 dark:text-amber-400" aria-hidden="true"><path d="M22 4s-.7 2.1-2 3.4c1.6 10-9.4 17.3-18 11.6 2.2.1 4.4-.6 6-2C3 15.5.5 9.6 3 5c2.2 2.6 5.6 4.1 9 4-.9-4.2 4-6.6 7-3.8 1.1 0 3-1.2 3-1.2z"></path></svg></a><div data-orientation="vertical" role="none" data-slot="separator" class="bg-border shrink-0 data-[orientation=horizontal]:h-px data-[orientation=horizontal]:w-full data-[orientation=vertical]:w-px data-[orientation=vertical]:h-4"></div></div><div class="contents"><a aria-label="邮箱" href="mailto:wztlink1013@163.com"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-mail size-5" aria-hidden="true"><path d="m22 7-8.991 5.727a2 2 0 0 1-2.009 0L2 7"></path><rect x="2" y="4" width="20" height="16" rx="2"></rect></svg></a></div></div></footer></div><script src="/_next/static/chunks/a1b55b20c0e4c4bd.js" id="_R_" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0])</script><script>self.__next_f.push([1,"1:\"$Sreact.fragment\"\n2:I[27423,[\"/_next/static/chunks/4eaa70fe861e9598.js\"],\"ThemeProvider\"]\n3:I[39756,[\"/_next/static/chunks/ff1a16fafef87110.js\",\"/_next/static/chunks/7340adf74ff47ec0.js\"],\"default\"]\n4:I[37457,[\"/_next/static/chunks/ff1a16fafef87110.js\",\"/_next/static/chunks/7340adf74ff47ec0.js\"],\"default\"]\n6e:I[68027,[\"/_next/static/chunks/ff1a16fafef87110.js\",\"/_next/static/chunks/7340adf74ff47ec0.js\"],\"default\"]\n:HL[\"/_next/static/chunks/4f409435d31fc1ca.css\",\"style\"]\n:HL[\"/_next/static/chunks/ca3b7ea61b268a33.css\",\"style\"]\n:HL[\"/_next/static/media/797e433ab948586e-s.p.dbea232f.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n:HL[\"/_next/static/media/83afe278b6a6bb3c-s.p.3a6ba036.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n"])</script><script>self.__next_f.push([1,"0:{\"P\":null,\"b\":\"ojCF045NjSCdIX953ggig\",\"c\":[\"\",\"blog\",\"spobqi\"],\"q\":\"\",\"i\":false,\"f\":[[[\"\",{\"children\":[\"(pages)\",{\"children\":[[\"column\",\"blog\",\"d\"],{\"children\":[[\"post\",\"spobqi\",\"d\"],{\"children\":[\"__PAGE__\",{}]}]}]}]},\"$undefined\",\"$undefined\",true],[[\"$\",\"$1\",\"c\",{\"children\":[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/chunks/4f409435d31fc1ca.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}],[\"$\",\"link\",\"1\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/chunks/ca3b7ea61b268a33.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}],[\"$\",\"script\",\"script-0\",{\"src\":\"/_next/static/chunks/4eaa70fe861e9598.js\",\"async\":true,\"nonce\":\"$undefined\"}]],[\"$\",\"html\",null,{\"lang\":\"zh-CN\",\"className\":\"inter_2835ecbf-module__TsU-8G__variable geist_mono_8d43a2aa-module__8Li5zG__variable relative flex min-h-full w-full scroll-smooth antialiased\",\"suppressHydrationWarning\":true,\"children\":[\"$\",\"body\",null,{\"className\":\"relative flex min-h-full w-full flex-auto flex-col\",\"children\":[\"$\",\"$L2\",null,{\"attribute\":\"class\",\"enableSystem\":false,\"disableTransitionOnChange\":true,\"children\":[\"$\",\"$L3\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L4\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[[\"$\",\"div\",null,{\"className\":\"flex h-screen w-screen flex-col items-center justify-center gap-9 p-6\",\"children\":[[\"$\",\"svg\",null,{\"width\":\"1.21325em\",\"height\":\"1em\",\"viewBox\":\"0 0 586 483\",\"fill\":\"none\",\"xmlns\":\"http://www.w3.org/2000/svg\",\"className\":\"h-auto w-full sm:h-120 sm:w-146\",\"children\":[[\"$\",\"path\",null,{\"d\":\"M207.891 275.994H145.943C144.721 275.994 143.729 275.003 143.729 273.782C143.729 272.559 144.721 271.57 145.943 271.57H207.891C209.113 271.57 210.104 272.559 210.104 273.782C210.104 275.003 209.113 275.994 207.891 275.994Z\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.5\"}],[\"$\",\"path\",null,{\"d\":\"M138 275.994C134.043 275.994 130.821 272.775 130.819 268.819L130.813 262.514C130.812 261.291 131.803 260.301 133.025 260.299C134.247 260.299 135.237 261.289 135.239 262.51L135.244 268.815C135.245 270.334 136.481 271.57 138 271.57C139.223 271.57 140.213 272.559 140.213 273.782C140.213 275.003 139.223 275.994 138 275.994Z\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.4\"}],[\"$\",\"path\",null,{\"d\":\"M135.512 255.3C135.226 255.3 134.934 255.244 134.652 255.125C133.527 254.651 132.999 253.353 133.475 252.227L161.388 186.077C161.864 184.951 163.162 184.423 164.288 184.899C165.414 185.375 165.94 186.672 165.466 187.799L137.551 253.948C137.195 254.792 136.375 255.3 135.512 255.3Z\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.1\"}],[\"$\",\"path\",null,{\"d\":\"M193.483 200.724C192.261 200.724 191.271 199.735 191.271 198.514L191.227 138.55C191.227 137.911 190.977 137.311 190.527 136.862C190.076 136.411 189.476 136.163 188.839 136.163H188.837C187.875 136.164 187.012 136.736 186.64 137.622L170.917 174.879C170.443 176.004 169.144 176.531 168.019 176.058C166.893 175.583 166.365 174.284 166.841 173.158L182.563 135.902C183.628 133.374 186.091 131.739 188.835 131.738H188.839C190.656 131.738 192.367 132.446 193.652 133.73C194.94 135.015 195.651 136.726 195.652 138.546L195.696 198.51C195.696 199.732 194.704 200.723 193.483 200.724Z\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.5\"}],[\"$\",\"path\",null,{\"d\":\"M193.526 260.989C192.304 260.989 191.314 259.999 191.314 258.778L191.278 211.335C191.276 210.113 192.267 209.122 193.488 209.121H193.491C194.711 209.121 195.702 210.11 195.703 211.331L195.738 258.774C195.739 259.997 194.75 260.989 193.527 260.989H193.526Z\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.6\"}],[\"$\",\"path\",null,{\"d\":\"M191.104 333.895C180.45 333.895 171.778 325.231 171.77 314.575L171.758 296.83L131.31 296.86H131.295C119.475 296.86 109.855 287.248 109.847 275.427C109.846 274.204 110.835 273.214 112.057 273.212H112.059C113.281 273.212 114.271 274.202 114.271 275.423C114.278 284.806 121.914 292.434 131.295 292.434H131.307L173.966 292.404H173.967C174.554 292.404 175.116 292.636 175.531 293.05C175.947 293.466 176.181 294.028 176.181 294.615L176.195 314.571C176.2 322.788 182.888 329.47 191.104 329.471H191.115L196.367 329.467C204.588 329.46 211.272 322.767 211.266 314.546L211.251 294.59C211.251 293.367 212.242 292.375 213.463 292.375H213.465C214.686 292.375 215.676 293.366 215.676 294.587L215.691 314.543C215.699 325.203 207.033 333.883 196.371 333.891L191.119 333.895H191.104Z\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.2\"}],\"$L5\",\"$L6\",\"$L7\",\"$L8\",\"$L9\",\"$La\",\"$Lb\",\"$Lc\",\"$Ld\",\"$Le\",\"$Lf\",\"$L10\",\"$L11\",\"$L12\",\"$L13\",\"$L14\",\"$L15\",\"$L16\",\"$L17\",\"$L18\",\"$L19\",\"$L1a\",\"$L1b\",\"$L1c\",\"$L1d\",\"$L1e\",\"$L1f\",\"$L20\",\"$L21\",\"$L22\",\"$L23\",\"$L24\",\"$L25\",\"$L26\",\"$L27\",\"$L28\",\"$L29\",\"$L2a\",\"$L2b\",\"$L2c\",\"$L2d\",\"$L2e\",\"$L2f\",\"$L30\",\"$L31\",\"$L32\",\"$L33\",\"$L34\",\"$L35\",\"$L36\",\"$L37\",\"$L38\",\"$L39\",\"$L3a\",\"$L3b\",\"$L3c\",\"$L3d\",\"$L3e\",\"$L3f\",\"$L40\",\"$L41\",\"$L42\",\"$L43\",\"$L44\",\"$L45\",\"$L46\",\"$L47\",\"$L48\",\"$L49\",\"$L4a\",\"$L4b\",\"$L4c\",\"$L4d\",\"$L4e\",\"$L4f\",\"$L50\",\"$L51\",\"$L52\",\"$L53\",\"$L54\",\"$L55\",\"$L56\",\"$L57\",\"$L58\",\"$L59\",\"$L5a\",\"$L5b\",\"$L5c\",\"$L5d\",\"$L5e\",\"$L5f\",\"$L60\",\"$L61\",\"$L62\",\"$L63\",\"$L64\",\"$L65\",\"$L66\",\"$L67\"]}],\"$L68\"]}],[]],\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]}]}]}]]}],{\"children\":[\"$L69\",{\"children\":[\"$L6a\",{\"children\":[\"$L6b\",{\"children\":[\"$L6c\",{},null,false,false]},null,false,false]},null,false,false]},null,false,false]},null,false,false],\"$L6d\",false]],\"m\":\"$undefined\",\"G\":[\"$6e\",[]],\"S\":true}\n"])</script><script>self.__next_f.push([1,"73:I[22016,[\"/_next/static/chunks/4eaa70fe861e9598.js\",\"/_next/static/chunks/fa1a8f8830b9bf3a.js\",\"/_next/static/chunks/6dd6809ee42e252f.js\",\"/_next/static/chunks/f2b800ca7ae14e96.js\",\"/_next/static/chunks/e121db38c98deeb4.js\",\"/_next/static/chunks/6d971f5a9c16d0c2.js\",\"/_next/static/chunks/b397c2fd2abb1207.js\",\"/_next/static/chunks/11dff99839ab5ba0.js\"],\"\"]\n74:I[45872,[\"/_next/static/chunks/4eaa70fe861e9598.js\",\"/_next/static/chunks/fa1a8f8830b9bf3a.js\",\"/_next/static/chunks/6dd6809ee42e252f.js\",\"/_next/static/chunks/f2b800ca7ae14e96.js\",\"/_next/static/chunks/e121db38c98deeb4.js\",\"/_next/static/chunks/6d971f5a9c16d0c2.js\",\"/_next/static/chunks/b397c2fd2abb1207.js\"],\"default\"]\ndd:I[97367,[\"/_next/static/chunks/ff1a16fafef87110.js\",\"/_next/static/chunks/7340adf74ff47ec0.js\"],\"OutletBoundary\"]\nde:\"$Sreact.suspense\"\ne0:I[97367,[\"/_next/static/chunks/ff1a16fafef87110.js\",\"/_next/static/chunks/7340adf74ff47ec0.js\"],\"ViewportBoundary\"]\ne2:I[97367,[\"/_next/static/chunks/ff1a16fafef87110.js\",\"/_next/static/chunks/7340adf74ff47ec0.js\"],\"MetadataBoundary\"]\n5:[\"$\",\"path\",null,{\"d\":\"M228.639 282.92C227.417 282.92 226.428 281.931 226.427 280.71L226.409 261.81C226.407 257.682 223.047 254.326 218.92 254.326H218.915L213.435 254.33H213.433C212.847 254.33 212.284 254.096 211.869 253.682C211.455 253.267 211.221 252.704 211.221 252.116V243.01C211.221 241.788 212.212 240.798 213.433 240.798C214.656 240.798 215.645 241.788 215.645 243.01V249.902L218.912 249.9H218.92C225.487 249.9 230.831 255.239 230.835 261.807L230.852 280.706C230.853 281.928 229.863 282.919 228.641 282.92H228.639Z\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.5\"}]\n6:[\"$\",\"path\",null,{\"d\":\"M213.416 212.608C212.194 212.608 211.204 211.618 211.202 210.397L211.141 139.09C211.14 137.868 212.13 136.877 213.352 136.876H213.353C214.576 136.876 215.565 137.865 215.566 139.086L215.628 210.393C215.629 211.614 214.64 212.608 213.417 212.608H213.416Z\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.4\"}]\n7:[\"$\",\"path\",null,{\"d\":\"M213.339 132.149C212.116 132.149 211.127 131.158 211.127 129.936V120.657C211.124 118.22 209.14 116.237 206.701 116.237H206.699L176.973 116.26C175.192 116.26 173.592 117.321 172.9 118.964L169.015 128.169C168.54 129.294 167.243 129.822 166.116 129.346C164.991 128.872 164.463 127.574 164.939 126.448L168.823 117.242C170.208 113.96 173.407 111.836 176.971 111.834L206.695 111.813H206.701C211.579 111.813 215.548 115.778 215.552 120.656V129.936C215.552 131.158 214.561 132.149 213.339 132.149Z\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.5\"}]\n8:[\"$\",\"path\",null,{\"d\":\"M115.532 251.431C115.246 251.431 114.954 251.375 114.672 251.257C113.547 250.782 113.019 249.485 113.495 248.358L160.728 136.425C161.203 135.298 162.502 134.769 163.627 135.246C164.754 135.721 165.28 137.018 164.806 138.145L117.571 250.079C117.215 250.923 116.394 251.431 115.532 251.431Z\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.1\"}]\n9:[\"$\",\"path\",null,{\"d\":\"M211.557 283.526H200.201C198.98 283.526 197.989 282.536 197.989 281.313C197.989 280.092 198.98 279.101 200.201 279.101H211.556C211.98 279.101 212.38 278.934 212.68 278.634C212.981 278.333 213.146 277.933 213.146 277.506L213.14 269.197C213.14 268.32 212.425 267.605 211.546 267.605L206.808 267.609H206.801C204.44 267.609 202.218 266.69 200.548 265.021C198.874 263.35 197.953 261.129 197.95 258.765L197.898 185.256C197.897 184.034 198.888 183.042 200.109 183.042H200.11C201.332 183.042 202.322 184.032 202.324 185.253L202.376 258.762C202.377 261.201 204.362 263.184 206.801 263.184H206.804L211.542 263.181H211.546C214.862 263.181 217.562 265.877 217.565 269.194L217.572 277.504C217.573 279.11 216.948 280.624 215.812 281.761C214.676 282.898 213.165 283.525 211.557 283.526Z\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.1\"}]\n6f:T54a,M193.729 320.618C191.411 320.618 189.231 319.716 187.591 318.079C185.95 316.439 185.045 314.258 185.043 311.939L185.026 287.971C185.025 285.532 183.039 283.548 180.601 283.548H180.598L137.643 283.579H137.633C129.633 283.58 123.122 277.075 123.117 269.075L123.111 260.164C123.111 259.868 123.17 259.576 123.285 259.303L179.342 126.458C179.689 125.639 180.49 125."])</script><script>self.__next_f.push([1,"106 181.379 125.106L194.965 125.096H194.971C196.922 125.096 198.757 125.855 200.139 127.235C201.522 128.615 202.283 130.451 202.285 132.404L202.309 162.106C202.31 163.327 201.319 164.319 200.098 164.319H200.095C198.875 164.319 197.885 163.33 197.883 162.108L197.861 132.408C197.859 131.636 197.558 130.911 197.011 130.366C196.466 129.82 195.741 129.522 194.97 129.522L182.85 129.53L127.535 260.611L127.542 269.071C127.546 274.632 132.071 279.155 137.633 279.155H137.641L180.594 279.123H180.601C185.478 279.123 189.447 283.09 189.451 287.968L189.469 311.935C189.469 313.074 189.913 314.144 190.718 314.947C191.522 315.751 192.591 316.194 193.729 316.194H193.731C194.87 316.192 195.939 315.748 196.743 314.943C197.547 314.138 197.99 313.067 197.989 311.93L197.973 287.962C197.971 286.739 198.961 285.748 200.182 285.747H200.185C201.406 285.747 202.395 286.736 202.397 287.958L202.414 311.926C202.415 314.247 201.514 316.428 199.874 318.07C198.235 319.711 196.055 320.616 193.735 320.618H193.729Za:[\"$\",\"path\",null,{\"d\":\"$6f\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.2\"}]\nb:[\"$\",\"path\",null,{\"d\":\"M156.11 225.068C155.823 225.068 155.532 225.012 155.251 224.895C154.126 224.42 153.598 223.123 154.072 221.996L185.179 148.145C185.654 147.02 186.948 146.492 188.076 146.965C189.202 147.44 189.731 148.737 189.256 149.864L158.15 223.713C157.794 224.56 156.972 225.068 156.11 225.068Z\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.4\"}]\nc:[\"$\",\"path\",null,{\"d\":\"M148.172 267.651C145.2 267.651 142.445 266.174 140.801 263.699C139.156 261.222 138.862 258.107 140.016 255.366L149.121 233.749C149.596 232.623 150.892 232.094 152.02 232.569C153.145 233.043 153.673 234.341 153.2 235.467L144.094 257.083C143.517 258.454 143.664 260.011 144.486 261.25C145.309 262.487 146.686 263.226 148.172 263.226H148.174L180.584 263.203C181.765 263.202 182.876 262.741 183.712 261.905C184.546 261.069 185.005 259.957 185.005 258.775L184.949 181.989C184.949 180.767 185.938 179.775 187.161 179.775C188.382 179.775 189.374 180.765 189.374 181.986L189.43 258.771C189.433 263.651 185.466 267.625 180.586 267.627L148.178 267.651H148.172Z\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.2\"}]\nd:[\"$\",\"path\",null,{\"d\":\"M192.489 327.257C184.728 327.258 178.412 320.946 178.406 313.185L178.388 295.044C178.386 293.822 179.377 292.832 180.598 292.83H180.601C181.822 292.83 182.812 293.818 182.813 295.04L182.832 313.18C182.836 318.505 187.168 322.833 192.489 322.833H192.496L194.977 322.83C200.302 322.826 204.632 318.492 204.628 313.166C204.626 311.945 205.617 310.952 206.838 310.952C208.06 310.952 209.052 311.942 209.053 313.162C209.058 320.928 202.745 327.249 194.981 327.256L192.498 327.257H192.489Z\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.1\"}]\ne:[\"$\",\"path\",null,{\"d\":\"M206.834 304.112C205.612 304.112 204.622 303.123 204.622 301.902L204.61 287.958C204.61 287.37 204.842 286.807 205.256 286.391C205.671 285.976 206.234 285.743 206.82 285.743L214.588 285.738C217.456 285.735 219.788 283.4 219.786 280.532L219.776 266.164C219.774 263.296 217.44 260.966 214.575 260.966H214.571L206.803 260.972C206.216 260.972 205.652 260.739 205.238 260.324C204.822 259.91 204.588 259.347 204.588 258.76L204.494 126.978C204.492 124.716 202.652 122.879 200.391 122.879H200.39L178.444 122.895L164.83 155.16C164.355 156.286 163.056 156.814 161.931 156.338C160.806 155.863 160.278 154.566 160.752 153.439L174.939 119.823C175.284 119.004 176.086 118.472 176.975 118.471L200.387 118.454H200.391C205.091 118.454 208.915 122.275 208.919 126.974L209.012 256.544L214.567 256.54H214.575C219.879 256.54 224.196 260.855 224.2 266.16L224.211 280.528C224.215 285.836 219.9 290.158 214.592 290.162L209.036 290.166L209.047 301.898C209.047 303.12 208.056 304.111 206.834 304.112Z\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.6\"}]\nf:[\"$\",\"path\",null,{\"d\":\"M144.424 200.037C144.137 200.037 143.845 199.981 143.564 199.862C142.439 199.388 141.911 198.09 142.387 196.964L158.196 159.497C158.672 158.37 159.971 157.842 161.095 158.319C162.221 158.794 162.748 160.091 162.273 161.218L146.463 198.685C146.107 199.529 145.287 200.037 144.424 200.037Z\",\"fill\":\"var(--primary)\",\"fillOpac"])</script><script>self.__next_f.push([1,"ity\":\"0.5\"}]\n10:[\"$\",\"path\",null,{\"d\":\"M135.422 290.219C124.984 290.219 116.488 281.731 116.48 271.292L116.472 258.824C116.472 258.528 116.531 258.235 116.646 257.962L134.125 216.539C134.6 215.414 135.899 214.886 137.024 215.36C138.149 215.836 138.678 217.134 138.203 218.26L120.898 259.27L120.906 271.288C120.912 279.288 127.423 285.794 135.422 285.794H135.432L158.172 285.778C159.393 285.778 160.385 286.767 160.387 287.988C160.388 289.21 159.397 290.202 158.176 290.202L135.436 290.219H135.422Z\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.6\"}]\n11:[\"$\",\"path\",null,{\"d\":\"M178.32 192.926L151.613 256.33C151.601 256.358 151.575 256.422 151.629 256.505C151.684 256.586 151.759 256.586 151.784 256.586L176.708 256.567C177.623 256.567 178.365 255.823 178.365 254.909L178.32 192.926ZM151.784 261.011C150.236 261.011 148.8 260.242 147.944 258.953C147.087 257.662 146.935 256.039 147.536 254.613L175.275 188.757C176.001 187.031 177.793 186.087 179.625 186.455C181.46 186.825 182.741 188.391 182.743 190.262L182.791 254.905C182.792 258.259 180.065 260.99 176.711 260.993L151.787 261.011H151.784Z\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.6\"}]\n12:[\"$\",\"path\",null,{\"d\":\"M193.546 313.947C192.324 313.947 191.334 312.958 191.334 311.736L191.312 282.104C191.312 280.882 192.302 279.891 193.523 279.89C194.745 279.89 195.738 280.879 195.738 282.1L195.759 311.732C195.759 312.955 194.769 313.946 193.547 313.947H193.546Z\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.4\"}]\n13:[\"$\",\"path\",null,{\"d\":\"M215.599 219.049C215.599 220.266 214.613 221.251 213.395 221.251C212.179 221.251 211.193 220.266 211.193 219.049C211.193 217.831 212.179 216.846 213.395 216.846C214.613 216.846 215.599 217.831 215.599 219.049Z\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.4\"}]\n14:[\"$\",\"path\",null,{\"d\":\"M195.729 265.439C195.729 266.656 194.742 267.641 193.526 267.641C192.309 267.641 191.322 266.656 191.322 265.439C191.322 264.221 192.309 263.236 193.526 263.236C194.742 263.236 195.729 264.221 195.729 265.439Z\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.6\"}]\n15:[\"$\",\"path\",null,{\"d\":\"M230.842 289.323C230.842 290.539 229.855 291.526 228.639 291.526C227.422 291.526 226.435 290.539 226.435 289.323C226.435 288.106 227.422 287.119 228.639 287.119C229.855 287.119 230.842 288.106 230.842 289.323Z\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.5\"}]\n16:[\"$\",\"path\",null,{\"d\":\"M114.262 266.539C114.262 267.756 113.275 268.742 112.059 268.742C110.842 268.742 109.855 267.756 109.855 266.539C109.855 265.322 110.842 264.336 112.059 264.336C113.275 264.336 114.262 265.322 114.262 266.539Z\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.1\"}]\n17:[\"$\",\"path\",null,{\"d\":\"M142.101 208.625C142.101 209.843 141.114 210.828 139.898 210.828C138.681 210.828 137.694 209.843 137.694 208.625C137.694 207.408 138.681 206.423 139.898 206.423C141.114 206.423 142.101 207.408 142.101 208.625Z\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.5\"}]\n18:[\"$\",\"path\",null,{\"d\":\"M168.259 180.777C168.259 181.994 167.272 182.98 166.056 182.98C164.839 182.98 163.852 181.994 163.852 180.777C163.852 179.56 164.839 178.574 166.056 178.574C167.272 178.574 168.259 179.56 168.259 180.777Z\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.5\"}]\n19:[\"$\",\"path\",null,{\"d\":\"M168.782 288.023C168.782 289.239 167.795 290.225 166.579 290.225C165.362 290.225 164.375 289.239 164.375 288.023C164.375 286.805 165.362 285.819 166.579 285.819C167.795 285.819 168.782 286.805 168.782 288.023Z\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.6\"}]\n1a:[\"$\",\"path\",null,{\"d\":\"M202.489 175.354C202.489 176.571 201.503 177.557 200.285 177.557C199.069 177.557 198.083 176.571 198.083 175.354C198.083 174.137 199.069 173.151 200.285 173.151C201.503 173.151 202.489 174.137 202.489 175.354Z\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.1\"}]\n1b:[\"$\",\"path\",null,{\"d\":\"M187.217 176.231C185.994 176.231 185.005 175.241 185.005 174.019V169.845C185.005 168.622 185.994 167.631 187.217 167.631C188.44 167.631 189.43 168.622 189.43 169.845V174.019C189.43 175.241 188.44 176.231 187.217 176.231Z\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.4\"}]\n1c:[\"$\",\"path\",null,{\"d\":\"M213.339 236.36C212.116 236.36 211.127 235.37 211.127 234.148V22"])</script><script>self.__next_f.push([1,"7.544C211.127 226.323 212.116 225.332 213.339 225.332C214.561 225.332 215.552 226.323 215.552 227.544V234.148C215.552 235.37 214.561 236.36 213.339 236.36Z\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.4\"}]\n1d:[\"$\",\"path\",null,{\"d\":\"M260.605 327.422C260.229 327.422 259.849 327.328 259.5 327.125C244.798 318.624 237.026 302.432 237.026 280.294V196.306C237.026 195.084 238.017 194.093 239.24 194.093C240.461 194.093 241.452 195.084 241.452 196.306V280.294C241.452 300.761 248.458 315.629 261.716 323.294C262.772 323.905 263.134 325.258 262.522 326.317C262.113 327.026 261.369 327.422 260.605 327.422Z\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.1\"}]\n1e:[\"$\",\"path\",null,{\"d\":\"M287.996 333.892C286.774 333.892 285.783 332.902 285.783 331.68C285.783 330.458 286.774 329.467 287.996 329.467C318.012 329.467 334.542 312.003 334.542 280.295C334.542 279.072 335.531 278.083 336.754 278.083C337.975 278.083 338.967 279.072 338.967 280.295C338.967 314.358 320.388 333.892 287.996 333.892Z\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.2\"}]\n1f:[\"$\",\"path\",null,{\"d\":\"M336.754 247.479C335.532 247.479 334.542 246.488 334.542 245.267V180.777C334.542 179.555 335.532 178.564 336.754 178.564C337.976 178.564 338.966 179.555 338.966 180.777V245.267C338.966 246.488 337.976 247.479 336.754 247.479Z\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.2\"}]\n20:[\"$\",\"path\",null,{\"d\":\"M336.754 167.631C335.532 167.631 334.542 166.64 334.542 165.419C334.542 133.709 318.012 116.245 287.997 116.245C257.981 116.245 241.452 133.709 241.452 165.419C241.452 166.64 240.461 167.631 239.24 167.631C238.017 167.631 237.028 166.64 237.028 165.419C237.028 131.356 255.605 111.82 287.997 111.82C320.389 111.82 338.966 131.356 338.966 165.419C338.966 166.64 337.976 167.631 336.754 167.631Z\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.6\"}]\n21:[\"$\",\"path\",null,{\"d\":\"M255.629 270.851C255.629 272.068 254.642 273.053 253.425 273.053C252.209 273.053 251.222 272.068 251.222 270.851C251.222 269.633 252.209 268.648 253.425 268.648C254.642 268.648 255.629 269.633 255.629 270.851Z\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.6\"}]\n22:[\"$\",\"path\",null,{\"d\":\"M338.957 173.097C338.957 174.315 337.971 175.3 336.755 175.3C335.537 175.3 334.551 174.315 334.551 173.097C334.551 171.88 335.537 170.895 336.755 170.895C337.971 170.895 338.957 171.88 338.957 173.097Z\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.6\"}]\n23:[\"$\",\"path\",null,{\"d\":\"M316.991 159.019C316.991 160.237 316.004 161.222 314.788 161.222C313.571 161.222 312.583 160.237 312.583 159.019C312.583 157.802 313.571 156.817 314.788 156.817C316.004 156.817 316.991 157.802 316.991 159.019Z\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.2\"}]\n24:[\"$\",\"path\",null,{\"d\":\"M260.973 131.566C260.973 132.783 259.986 133.769 258.77 133.769C257.553 133.769 256.566 132.783 256.566 131.566C256.566 130.349 257.553 129.363 258.77 129.363C259.986 129.363 260.973 130.349 260.973 131.566Z\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.2\"}]\n25:[\"$\",\"path\",null,{\"d\":\"M273.517 329.679C273.517 330.895 272.53 331.881 271.314 331.881C270.097 331.881 269.11 330.895 269.11 329.679C269.11 328.461 270.097 327.476 271.314 327.476C272.53 327.476 273.517 328.461 273.517 329.679Z\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.1\"}]\n26:[\"$\",\"path\",null,{\"d\":\"M287.996 326.203C260.062 326.203 244.04 309.362 244.04 279.998V239.222C244.04 238.001 245.031 237.01 246.252 237.01C247.475 237.01 248.466 238.001 248.466 239.222V279.998C248.466 306.941 262.504 321.779 287.996 321.779C313.488 321.779 327.527 306.941 327.527 279.998V165.714C327.527 152.634 324.271 142.384 317.851 135.248C317.032 134.34 317.107 132.939 318.016 132.122C318.924 131.305 320.323 131.378 321.139 132.288C328.314 140.26 331.952 151.508 331.952 165.714V279.998C331.952 309.362 315.931 326.203 287.996 326.203Z\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.4\"}]\n27:[\"$\",\"path\",null,{\"d\":\"M313.066 130.472C312.65 130.472 312.229 130.355 311.856 130.111C305.598 126.012 297.572 123.934 287.996 123.934C279.15 123.934 271.609 125.712 265.581 129.219C264.525 129.834 263.17 129.475 262.556 128.419C261.941 127.363 262.3 126.008 263.356 125.394C270.069 121.49 278.36 119.51 287.996"])</script><script>self.__next_f.push([1," 119.51C298.446 119.51 307.29 121.831 314.28 126.408C315.302 127.078 315.588 128.45 314.92 129.472C314.493 130.12 313.786 130.472 313.066 130.472Z\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.1\"}]\n28:[\"$\",\"path\",null,{\"d\":\"M246.253 230.403C245.03 230.403 244.041 229.413 244.041 228.191V165.714C244.041 154.437 246.363 144.95 250.946 137.518C251.589 136.479 252.951 136.155 253.99 136.797C255.03 137.438 255.354 138.801 254.713 139.841C250.567 146.563 248.466 155.269 248.466 165.714V228.191C248.466 229.413 247.475 230.403 246.253 230.403Z\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.2\"}]\n29:[\"$\",\"path\",null,{\"d\":\"M253.425 264.724C252.203 264.724 251.213 263.734 251.213 262.511V165.798C251.213 141.236 264.62 127.15 287.996 127.15C311.372 127.15 324.78 141.236 324.78 165.798V205.42C324.78 206.642 323.789 207.632 322.567 207.632C321.345 207.632 320.355 206.642 320.355 205.42V165.798C320.355 143.728 308.864 131.575 287.996 131.575C267.129 131.575 255.639 143.728 255.639 165.798V262.511C255.639 263.734 254.648 264.724 253.425 264.724Z\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.5\"}]\n2a:[\"$\",\"path\",null,{\"d\":\"M287.996 318.563C264.62 318.563 251.214 304.478 251.214 279.916C251.214 278.694 252.203 277.703 253.426 277.703C254.647 277.703 255.638 278.694 255.638 279.916C255.638 301.983 267.13 314.138 287.996 314.138C293.956 314.138 299.215 313.151 303.627 311.206C304.744 310.712 306.051 311.219 306.543 312.338C307.036 313.456 306.53 314.76 305.412 315.255C300.435 317.45 294.575 318.563 287.996 318.563Z\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.6\"}]\n2b:[\"$\",\"path\",null,{\"d\":\"M314.422 308.202C313.909 308.202 313.393 308.023 312.974 307.662C312.051 306.861 311.95 305.463 312.75 304.541C317.795 298.717 320.354 290.431 320.354 279.915V240.879C320.354 239.658 321.345 238.667 322.566 238.667C323.789 238.667 324.781 239.658 324.781 240.879V279.915C324.781 291.526 321.857 300.786 316.095 307.438C315.658 307.943 315.042 308.202 314.422 308.202Z\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.6\"}]\n2c:[\"$\",\"path\",null,{\"d\":\"M287.996 310.642C284.29 310.642 280.843 310.198 277.748 309.321C276.572 308.988 275.89 307.765 276.223 306.589C276.556 305.413 277.78 304.732 278.955 305.062C281.658 305.829 284.699 306.218 287.996 306.218C304.231 306.218 313.172 296.753 313.172 279.565V166.146C313.172 164.925 314.162 163.934 315.384 163.934C316.606 163.934 317.596 164.925 317.596 166.146V279.565C317.596 299.316 306.807 310.642 287.996 310.642Z\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.1\"}]\n2d:[\"$\",\"path\",null,{\"d\":\"M260.609 206.086C259.386 206.086 258.396 205.096 258.396 203.873V166.146C258.396 146.397 269.185 135.07 287.997 135.07C301.484 135.07 310.865 140.792 315.125 151.614C315.573 152.752 315.013 154.036 313.877 154.484C312.737 154.932 311.454 154.373 311.008 153.236C307.469 144.248 299.512 139.496 287.997 139.496C271.762 139.496 262.821 148.961 262.821 166.146V203.873C262.821 205.096 261.832 206.086 260.609 206.086Z\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.2\"}]\n2e:[\"$\",\"path\",null,{\"d\":\"M268.332 303.78C267.776 303.78 267.222 303.572 266.791 303.154C261.222 297.746 258.396 289.808 258.396 279.566V213.376C258.396 212.155 259.387 211.164 260.61 211.164C261.831 211.164 262.822 212.155 262.822 213.376V279.566C262.822 288.567 265.194 295.435 269.874 299.98C270.751 300.832 270.771 302.232 269.919 303.11C269.486 303.555 268.91 303.78 268.332 303.78Z\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.1\"}]\n2f:[\"$\",\"path\",null,{\"d\":\"M308.185 256.33C306.962 256.33 305.973 255.339 305.973 254.118V193.251C305.973 192.03 306.962 191.039 308.185 191.039C309.406 191.039 310.397 192.03 310.397 193.251V254.118C310.397 255.339 309.406 256.33 308.185 256.33Z\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.2\"}]\n30:[\"$\",\"path\",null,{\"d\":\"M308.185 186.514C306.962 186.514 305.973 185.523 305.973 184.302V167.125C305.973 154.653 299.757 148.059 287.996 148.059C276.236 148.059 270.02 154.653 270.02 167.125C270.02 168.347 269.03 169.337 267.808 169.337C266.585 169.337 265.596 168.347 265.596 167.125C265.596 152.197 273.76 143.634 287.996 143.634C302.232 143.634 310.397 152.197 310.397 167.125V184.302C310.397 "])</script><script>self.__next_f.push([1,"185.523 309.406 186.514 308.185 186.514Z\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.6\"}]\n31:[\"$\",\"path\",null,{\"d\":\"M267.807 248.211C266.585 248.211 265.595 247.22 265.595 245.997V180.777C265.595 179.555 266.585 178.564 267.807 178.564C269.03 178.564 270.021 179.555 270.021 180.777V245.997C270.021 247.22 269.03 248.211 267.807 248.211Z\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.4\"}]\n32:[\"$\",\"path\",null,{\"d\":\"M287.996 302.077C273.76 302.077 265.595 293.516 265.595 278.588V254.584C265.595 253.361 266.586 252.372 267.807 252.372C269.03 252.372 270.02 253.361 270.02 254.584V278.588C270.02 291.06 276.236 297.653 287.996 297.653C299.756 297.653 305.972 291.06 305.972 278.588V264.121C305.972 262.899 306.963 261.908 308.186 261.908C309.407 261.908 310.398 262.899 310.398 264.121V278.588C310.398 293.516 302.232 302.077 287.996 302.077Z\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.6\"}]\n33:[\"$\",\"path\",null,{\"d\":\"M287.996 156.826C280.907 156.826 277.311 160.655 277.311 168.206V277.934C277.311 285.485 280.907 289.313 287.996 289.313C295.086 289.313 298.682 285.485 298.682 277.934V168.206C298.682 160.655 295.086 156.826 287.996 156.826ZM287.996 293.739C278.535 293.739 272.886 287.83 272.886 277.934V168.206C272.886 158.309 278.535 152.401 287.996 152.401C297.458 152.401 303.106 158.309 303.106 168.206V277.934C303.106 287.83 297.458 293.739 287.996 293.739Z\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.5\"}]\n34:[\"$\",\"path\",null,{\"d\":\"M239.239 190.089C238.016 190.089 237.027 189.098 237.027 187.876V174.02C237.027 172.797 238.016 171.806 239.239 171.806C240.462 171.806 241.452 172.797 241.452 174.02V187.876C241.452 189.098 240.462 190.089 239.239 190.089Z\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.6\"}]\n35:[\"$\",\"path\",null,{\"d\":\"M336.754 273.339C335.532 273.339 334.542 272.348 334.542 271.127V256.355C334.542 255.132 335.532 254.143 336.754 254.143C337.976 254.143 338.966 255.132 338.966 256.355V271.127C338.966 272.348 337.976 273.339 336.754 273.339Z\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.2\"}]\n36:[\"$\",\"path\",null,{\"d\":\"M322.566 231.442C321.345 231.442 320.354 230.451 320.354 229.23V214.164C320.354 212.942 321.345 211.951 322.566 211.951C323.789 211.951 324.78 212.942 324.78 214.164V229.23C324.78 230.451 323.789 231.442 322.566 231.442Z\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.5\"}]\n37:[\"$\",\"path\",null,{\"d\":\"M439.175 275.994H387.248C386.027 275.994 385.036 275.003 385.036 273.782C385.036 272.559 386.027 271.57 387.248 271.57H439.175C440.397 271.57 441.387 272.559 441.387 273.782C441.387 275.003 440.397 275.994 439.175 275.994Z\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.5\"}]\n38:[\"$\",\"path\",null,{\"d\":\"M371.836 275.994C367.297 275.994 363.603 272.302 363.599 267.765L363.595 262.514C363.595 261.546 363.785 260.605 364.16 259.715L388.091 203.006C388.567 201.879 389.864 201.353 390.989 201.827C392.116 202.302 392.643 203.601 392.168 204.726L368.237 261.435C368.092 261.777 368.02 262.139 368.02 262.513L368.024 267.761C368.027 269.861 369.736 271.57 371.836 271.57C373.057 271.57 374.048 272.559 374.048 273.782C374.048 275.003 373.057 275.994 371.836 275.994Z\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.6\"}]\n39:[\"$\",\"path\",null,{\"d\":\"M427.348 231.442C426.127 231.442 425.136 230.452 425.136 229.231L425.072 138.55C425.071 137.232 424 136.163 422.684 136.163C421.723 136.164 420.859 136.736 420.484 137.623L396.648 194.112C396.172 195.238 394.875 195.764 393.748 195.29C392.623 194.815 392.096 193.518 392.569 192.391L416.407 135.902C417.475 133.374 419.936 131.739 422.679 131.738H422.684C426.437 131.738 429.495 134.791 429.497 138.546L429.56 229.227C429.561 230.45 428.572 231.442 427.349 231.442H427.348Z\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.5\"}]\n3a:[\"$\",\"path\",null,{\"d\":\"M427.371 267.651C426.15 267.651 425.159 266.662 425.158 265.441L425.139 239.81C425.139 238.589 426.129 237.597 427.35 237.595H427.353C428.574 237.595 429.565 238.586 429.566 239.807L429.583 265.437C429.585 266.659 428.595 267.651 427.373 267.651H427.371Z\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.4\"}]\n70:T422,M424.949 333.895C414.295 333.895 405.624 325.231 405.616 314.575L405.603 296.83L365.155 2"])</script><script>self.__next_f.push([1,"96.86H365.14C359.416 296.86 354.035 294.632 349.984 290.588C345.931 286.54 343.696 281.155 343.692 275.427V264.698C343.692 263.475 344.683 262.484 345.904 262.484C347.127 262.484 348.116 263.475 348.116 264.698V275.424C348.12 279.971 349.893 284.244 353.111 287.456C356.325 290.667 360.597 292.434 365.14 292.434H365.152L407.811 292.404C409.032 292.404 410.025 293.394 410.027 294.615L410.04 314.571C410.047 322.788 416.735 329.47 424.949 329.471H424.96L430.212 329.467C438.433 329.46 445.117 322.767 445.112 314.546L445.096 294.59C445.096 294.003 445.329 293.439 445.745 293.024C446.157 292.608 446.721 292.375 447.308 292.375L451.049 292.372C456.139 292.368 460.275 288.226 460.271 283.139L460.256 263.547C460.255 262.324 461.245 261.334 462.468 261.332C463.689 261.332 464.68 262.322 464.681 263.543L464.696 283.135C464.7 290.663 458.581 296.792 451.053 296.798L449.524 296.799L449.536 314.543C449.544 325.203 440.877 333.883 430.216 333.891L424.964 333.895H424.949Z3b:[\"$\",\"path\",null,{\"d\":\"$70\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.6\"}]\n3c:[\"$\",\"path\",null,{\"d\":\"M447.279 251.431C446.058 251.431 445.067 250.441 445.067 249.218V225.869C445.067 224.647 446.058 223.655 447.279 223.655C448.502 223.655 449.492 224.647 449.492 225.869V249.218C449.492 250.441 448.502 251.431 447.279 251.431Z\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.4\"}]\n3d:[\"$\",\"path\",null,{\"d\":\"M447.261 211.942C446.041 211.942 445.05 210.952 445.049 209.731L444.986 141.222C444.986 140 445.975 139.01 447.197 139.008H447.199C448.419 139.008 449.41 139.998 449.411 141.219L449.474 209.727C449.474 210.948 448.485 211.94 447.263 211.942H447.261Z\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.4\"}]\n3e:[\"$\",\"path\",null,{\"d\":\"M365.021 214.358C364.735 214.358 364.443 214.302 364.163 214.184C363.037 213.709 362.509 212.412 362.984 211.285L402.667 117.242C404.053 113.96 407.253 111.836 410.816 111.833L440.541 111.812H440.548C442.909 111.812 445.129 112.73 446.801 114.4C448.473 116.07 449.395 118.292 449.397 120.656V132.725C449.397 133.946 448.407 134.937 447.184 134.937C445.963 134.937 444.972 133.946 444.972 132.725V120.657C444.971 119.477 444.511 118.366 443.673 117.53C442.837 116.696 441.727 116.237 440.548 116.237H440.545L410.82 116.258C409.037 116.26 407.437 117.321 406.745 118.964L367.061 213.005C366.705 213.85 365.884 214.358 365.021 214.358Z\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.5\"}]\n3f:[\"$\",\"path\",null,{\"d\":\"M349.378 251.431C349.09 251.431 348.799 251.375 348.518 251.257C347.392 250.782 346.864 249.485 347.34 248.358L358.464 221.993C358.94 220.867 360.239 220.338 361.363 220.814C362.49 221.29 363.016 222.587 362.543 223.713L351.416 250.079C351.06 250.923 350.239 251.431 349.378 251.431Z\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.4\"}]\n40:[\"$\",\"path\",null,{\"d\":\"M433.964 201.474C432.742 201.474 431.752 200.485 431.752 199.264L431.725 163.086C431.725 161.864 432.714 160.873 433.936 160.872H433.938C435.158 160.872 436.15 161.862 436.152 163.084L436.176 199.26C436.177 200.482 435.188 201.474 433.965 201.474H433.964Z\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.5\"}]\n71:T87e,"])</script><script>self.__next_f.push([1,"M427.573 320.618C425.256 320.618 423.076 319.716 421.436 318.079C419.794 316.439 418.889 314.258 418.889 311.938L418.872 287.971C418.869 285.532 416.884 283.548 414.445 283.548H414.442L371.489 283.579H371.478C367.604 283.579 363.962 282.072 361.22 279.336C358.477 276.595 356.965 272.951 356.962 269.074L356.956 260.166C356.956 259.868 357.014 259.576 357.129 259.303L413.188 126.458C413.534 125.639 414.337 125.106 415.225 125.106L428.601 125.096H428.608C430.614 125.096 432.502 125.876 433.924 127.295C435.345 128.715 436.129 130.603 436.13 132.614L436.141 147.984C436.142 149.207 435.153 150.199 433.932 150.199H433.929C432.708 150.199 431.717 149.21 431.716 147.988L431.705 132.616C431.705 131.788 431.381 131.011 430.797 130.426C430.212 129.842 429.434 129.522 428.608 129.522H428.605L416.696 129.53L361.38 260.611L361.386 269.071C361.389 271.767 362.44 274.3 364.348 276.204C366.253 278.107 368.784 279.155 371.478 279.155H371.486L414.438 279.123H414.446C419.324 279.123 423.292 283.09 423.297 287.967L423.314 311.935C423.316 313.074 423.758 314.144 424.564 314.947C425.368 315.751 426.436 316.194 427.573 316.194H427.577C428.714 316.192 429.785 315.748 430.59 314.943C431.393 314.138 431.834 313.068 431.833 311.93L431.818 287.962C431.816 285.598 432.733 283.374 434.404 281.702C436.074 280.028 438.297 279.107 440.66 279.104L443.92 279.103C445.613 279.102 446.99 277.722 446.99 276.027L446.986 270.678C446.986 269.856 446.665 269.086 446.085 268.506C445.505 267.926 444.734 267.607 443.914 267.607H443.912L440.653 267.61H440.646C435.768 267.61 431.8 263.643 431.796 258.766L431.76 207.86C431.758 206.638 432.748 205.647 433.969 205.646H433.972C435.193 205.646 436.182 206.635 436.184 207.856L436.221 258.762C436.222 261.2 438.209 263.184 440.648 263.184H440.65L443.908 263.182H443.914C445.914 263.182 447.796 263.96 449.212 265.374C450.629 266.79 451.41 268.672 451.412 270.675L451.416 276.024C451.418 280.158 448.056 283.524 443.922 283.528L440.664 283.53C439.482 283.531 438.372 283.992 437.536 284.828C436.701 285.664 436.241 286.776 436.242 287.958L436.26 311.926C436.262 314.247 435.36 316.427 433.72 318.07C432.081 319.711 429.9 320.616 427.58 320.618H427.573Z"])</script><script>self.__next_f.push([1,"41:[\"$\",\"path\",null,{\"d\":\"$71\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.2\"}]\n42:[\"$\",\"path\",null,{\"d\":\"M382.017 267.651C379.045 267.651 376.29 266.174 374.646 263.699C373 261.222 372.708 258.107 373.861 255.366L406.213 178.557C406.688 177.43 407.982 176.902 409.11 177.375C410.237 177.85 410.766 179.149 410.29 180.274L377.938 257.083C377.362 258.454 377.508 260.011 378.33 261.25C379.154 262.487 380.532 263.226 382.017 263.226H382.02L404.946 263.21C406.168 263.21 407.16 264.199 407.16 265.421C407.161 266.643 406.172 267.634 404.949 267.635L382.024 267.651H382.017Z\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.2\"}]\n43:[\"$\",\"path\",null,{\"d\":\"M414.43 267.628C413.209 267.628 412.219 266.639 412.218 265.417C412.217 264.195 413.206 263.204 414.429 263.203C416.869 263.201 418.851 261.215 418.85 258.775L418.794 154.615C418.793 153.392 419.785 152.401 421.007 152.401C422.229 152.401 423.219 153.391 423.221 154.612L423.275 258.772C423.279 263.652 419.311 267.625 414.433 267.628H414.43Z\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.6\"}]\n72:T6a4,"])</script><script>self.__next_f.push([1,"M426.335 327.257C422.576 327.257 419.043 325.794 416.383 323.14C413.721 320.481 412.255 316.946 412.252 313.185L412.237 293.594C412.237 291.716 410.707 290.186 408.828 290.186H404.195C402.972 290.186 401.98 289.196 401.98 287.974C401.98 286.752 402.972 285.761 404.195 285.761H408.828C413.145 285.761 416.66 289.274 416.663 293.592L416.677 313.181C416.681 318.505 421.012 322.833 426.335 322.833H426.34L428.823 322.83C434.147 322.826 438.476 318.492 438.473 313.166L438.457 291.925C438.457 290.274 439.097 288.721 440.264 287.553C441.431 286.385 442.983 285.741 444.635 285.74L448.372 285.737C449.779 285.736 451.099 285.188 452.092 284.193C453.084 283.2 453.632 281.877 453.631 280.472L453.621 266.223C453.619 263.323 451.257 260.966 448.359 260.966H448.356L440.647 260.971H440.645C440.06 260.971 439.497 260.738 439.083 260.325C438.668 259.91 438.433 259.347 438.433 258.761L438.339 127.017C438.337 125.91 437.907 124.871 437.124 124.09C436.343 123.31 435.304 122.879 434.197 122.879H434.196L412.291 122.896L405.267 139.54C404.792 140.666 403.492 141.193 402.368 140.717C401.243 140.242 400.715 138.945 401.189 137.818L408.783 119.824C409.129 119.005 409.931 118.473 410.82 118.471L434.192 118.454H434.197C436.483 118.454 438.633 119.343 440.252 120.958C441.869 122.575 442.761 124.726 442.763 127.014L442.857 256.545L448.352 256.541H448.36C453.696 256.541 458.041 260.881 458.045 266.221L458.056 280.468C458.057 283.056 457.052 285.489 455.224 287.32C453.396 289.152 450.964 290.161 448.376 290.162L444.637 290.165C444.168 290.166 443.727 290.348 443.396 290.68C443.064 291.01 442.883 291.452 442.883 291.921L442.899 313.162C442.904 320.928 436.591 327.249 428.825 327.256L426.344 327.257H426.335Z"])</script><script>self.__next_f.push([1,"44:[\"$\",\"path\",null,{\"d\":\"$72\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.1\"}]\n45:[\"$\",\"path\",null,{\"d\":\"M392.089 167.287C391.802 167.287 391.51 167.231 391.229 167.113C390.103 166.638 389.577 165.341 390.051 164.214L397.618 146.278C398.095 145.153 399.393 144.625 400.518 145.101C401.645 145.575 402.171 146.873 401.697 147.999L394.127 165.935C393.771 166.779 392.95 167.287 392.089 167.287Z\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.6\"}]\n46:[\"$\",\"path\",null,{\"d\":\"M354.94 255.321C354.652 255.321 354.362 255.265 354.08 255.147C352.955 254.672 352.427 253.375 352.903 252.248L386.799 171.921C387.275 170.795 388.574 170.267 389.696 170.743C390.823 171.217 391.351 172.516 390.876 173.641L356.979 253.968C356.623 254.813 355.802 255.321 354.94 255.321Z\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.6\"}]\n47:[\"$\",\"path\",null,{\"d\":\"M369.267 290.219C364.212 290.219 359.46 288.252 355.883 284.68C352.303 281.106 350.33 276.351 350.327 271.291L350.319 265.775C350.316 264.552 351.306 263.56 352.527 263.559H352.531C353.751 263.559 354.742 264.548 354.743 265.77L354.751 271.287C354.754 275.166 356.267 278.81 359.01 281.55C361.751 284.287 365.394 285.794 369.267 285.794H369.278L392.016 285.778C393.238 285.778 394.231 286.767 394.231 287.988C394.232 289.21 393.242 290.202 392.02 290.202L369.28 290.219H369.267Z\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.5\"}]\n48:[\"$\",\"path\",null,{\"d\":\"M412.164 192.926L385.51 256.21C385.495 256.243 385.454 256.345 385.532 256.465C385.614 256.586 385.703 256.569 385.758 256.586L409.762 256.569C410.415 256.567 411.031 256.313 411.492 255.85C411.955 255.387 412.208 254.771 412.208 254.118L412.164 192.926ZM385.756 261.01C384.182 261.01 382.72 260.227 381.848 258.914C380.974 257.601 380.819 255.947 381.431 254.493L411.074 184.119C411.61 182.847 412.927 182.149 414.283 182.421C415.636 182.694 416.583 183.849 416.584 185.23L416.635 254.114C416.635 255.95 415.92 257.677 414.624 258.977C413.327 260.277 411.6 260.991 409.764 260.993L385.762 261.01H385.756Z\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.1\"}]\n49:[\"$\",\"path\",null,{\"d\":\"M427.391 304.788C426.169 304.788 425.179 303.8 425.179 302.579L425.157 282.104C425.156 280.883 426.145 279.891 427.367 279.889H427.369C428.591 279.889 429.583 280.879 429.583 282.1L429.603 302.573C429.604 303.796 428.615 304.788 427.393 304.788H427.391Z\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.4\"}]\n4a:[\"$\",\"path\",null,{\"d\":\"M449.444 218.057C449.444 219.274 448.458 220.26 447.242 220.26C446.024 220.26 445.038 219.274 445.038 218.057C445.038 216.84 446.024 215.854 447.242 215.854C448.458 215.854 449.444 216.84 449.444 218.057Z\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.4\"}]\n4b:[\"$\",\"path\",null,{\"d\":\"M464.686 254.584C464.686 255.802 463.7 256.787 462.484 256.787C461.266 256.787 460.28 255.802 460.28 254.584C460.28 253.367 461.266 252.382 462.484 252.382C463.7 252.382 464.686 253.367 464.686 254.584Z\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.6\"}]\n4c:[\"$\",\"path\",null,{\"d\":\"M429.583 310.633C429.583 311.849 428.598 312.836 427.381 312.836C426.165 312.836 425.177 311.849 425.177 310.633C425.177 309.416 426.165 308.429 427.381 308.429C428.598 308.429 429.583 309.416 429.583 310.633Z\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.4\"}]\n4d:[\"$\",\"path\",null,{\"d\":\"M381.348 273.782C381.348 274.999 380.361 275.984 379.145 275.984C377.928 275.984 376.941 274.999 376.941 273.782C376.941 272.564 377.928 271.579 379.145 271.579C380.361 271.579 381.348 272.564 381.348 273.782Z\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.6\"}]\n4e:[\"$\",\"path\",null,{\"d\":\"M354.94 259.998C354.94 261.215 353.955 262.2 352.738 262.2C351.522 262.2 350.534 261.215 350.534 259.998C350.534 258.78 351.522 257.795 352.738 257.795C353.955 257.795 354.94 258.78 354.94 259.998Z\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.5\"}]\n4f:[\"$\",\"path\",null,{\"d\":\"M414.501 170.579C414.501 171.796 413.515 172.781 412.299 172.781C411.081 172.781 410.095 171.796 410.095 170.579C410.095 169.361 411.081 168.376 412.299 168.376C413.515 168.376 414.501 169.361 414.501 170.579Z\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.2\"}]\n50:[\"$\",\"path\",null,{\"d\":\"M436.333 154.613C436.333 155.83 435.348 "])</script><script>self.__next_f.push([1,"156.816 434.131 156.816C432.915 156.816 431.927 155.83 431.927 154.613C431.927 153.396 432.915 152.41 434.131 152.41C435.348 152.41 436.333 153.396 436.333 154.613Z\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.5\"}]\n51:[\"$\",\"path\",null,{\"d\":\"M465.702 242.975C465.135 242.975 464.57 242.759 464.138 242.327L457.701 235.89C456.837 235.026 456.837 233.624 457.701 232.76C458.565 231.896 459.965 231.896 460.83 232.76L467.266 239.198C468.13 240.062 468.13 241.463 467.266 242.327C466.835 242.759 466.269 242.975 465.702 242.975Z\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.5\"}]\n52:[\"$\",\"path\",null,{\"d\":\"M459.264 242.975C458.699 242.975 458.132 242.759 457.7 242.327C456.836 241.463 456.836 240.062 457.7 239.198L464.138 232.76C465.002 231.896 466.403 231.896 467.266 232.76C468.13 233.624 468.13 235.026 467.266 235.89L460.83 242.327C460.398 242.759 459.831 242.975 459.264 242.975Z\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.5\"}]\n53:[\"$\",\"path\",null,{\"d\":\"M454.735 348.767C454.735 350.601 453.249 352.086 451.416 352.086C449.583 352.086 448.096 350.601 448.096 348.767C448.096 346.934 449.583 345.449 451.416 345.449C453.249 345.449 454.735 346.934 454.735 348.767Z\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.5\"}]\n54:[\"$\",\"path\",null,{\"d\":\"M87.1143 158.144C87.1143 159.977 85.6276 161.464 83.7956 161.464C81.9623 161.464 80.4756 159.977 80.4756 158.144C80.4756 156.31 81.9623 154.825 83.7956 154.825C85.6276 154.825 87.1143 156.31 87.1143 158.144Z\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.5\"}]\n55:[\"$\",\"path\",null,{\"d\":\"M13.6924 375.948C13.6924 377.782 12.207 379.267 10.3737 379.267C8.54038 379.267 7.05371 377.782 7.05371 375.948C7.05371 374.115 8.54038 372.63 10.3737 372.63C12.207 372.63 13.6924 374.115 13.6924 375.948Z\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.4\"}]\n56:[\"$\",\"path\",null,{\"d\":\"M532.978 14.2342C532.978 16.0675 531.493 17.5528 529.659 17.5528C527.826 17.5528 526.339 16.0675 526.339 14.2342C526.339 12.4008 527.826 10.9142 529.659 10.9142C531.493 10.9142 532.978 12.4008 532.978 14.2342Z\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.4\"}]\n57:[\"$\",\"path\",null,{\"d\":\"M244.041 472.295C244.041 474.128 242.555 475.613 240.722 475.613C238.889 475.613 237.402 474.128 237.402 472.295C237.402 470.461 238.889 468.976 240.722 468.976C242.555 468.976 244.041 470.461 244.041 472.295Z\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.4\"}]\n58:[\"$\",\"path\",null,{\"d\":\"M160.742 82.4873L162.367 80.862C163.216 80.0127 163.216 78.6353 162.367 77.7873C161.519 76.938 160.142 76.938 159.292 77.7873L157.667 79.4127L156.042 77.7873C155.192 76.938 153.815 76.938 152.967 77.7873C152.118 78.6353 152.118 80.0127 152.967 80.862L154.592 82.4873L152.967 84.1127C152.118 84.962 152.118 86.3393 152.967 87.1873C153.391 87.6127 153.947 87.8247 154.504 87.8247C155.06 87.8247 155.618 87.6127 156.042 87.1873L157.667 85.562L159.292 87.1873C159.716 87.6127 160.274 87.8247 160.83 87.8247C161.386 87.8247 161.943 87.6127 162.367 87.1873C163.216 86.3393 163.216 84.962 162.367 84.1127L160.742 82.4873Z\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.2\"}]\n59:[\"$\",\"path\",null,{\"d\":\"M582.051 301.921L584.395 299.577C585.619 298.353 585.619 296.369 584.395 295.145C583.169 293.921 581.187 293.921 579.963 295.145L577.619 297.489L575.275 295.145C574.051 293.921 572.068 293.921 570.843 295.145C569.619 296.369 569.619 298.353 570.843 299.577L573.187 301.921L570.843 304.265C569.619 305.489 569.619 307.472 570.843 308.697C571.455 309.309 572.256 309.616 573.059 309.616C573.86 309.616 574.663 309.309 575.275 308.697L577.619 306.353L579.963 308.697C580.575 309.309 581.376 309.616 582.179 309.616C582.98 309.616 583.783 309.309 584.395 308.697C585.619 307.472 585.619 305.489 584.395 304.265L582.051 301.921Z\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.1\"}]\n5a:[\"$\",\"path\",null,{\"d\":\"M259.209 8.21385L261.701 5.72185C263.003 4.42051 263.003 2.30985 261.701 1.00852C260.401 -0.294151 258.289 -0.294151 256.987 1.00852L254.495 3.50052L252.003 1.00852C250.702 -0.294151 248.59 -0.294151 247.29 1.00852C245.987 2.30985 245.987 4.42051 247.29 5.72185L249.782 8.21385L247.29 10.7058C245.987 12.0072 245.987 14.1178 247.29 15.4192C247.939 16.0712 "])</script><script>self.__next_f.push([1,"248.793 16.3965 249.646 16.3965C250.499 16.3965 251.353 16.0712 252.003 15.4192L254.495 12.9272L256.987 15.4192C257.638 16.0712 258.491 16.3965 259.345 16.3965C260.198 16.3965 261.05 16.0712 261.701 15.4192C263.003 14.1178 263.003 12.0072 261.701 10.7058L259.209 8.21385Z\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.1\"}]\n5b:[\"$\",\"path\",null,{\"d\":\"M112.432 413.007L114.416 411.023C115.453 409.985 115.453 408.307 114.416 407.268C113.38 406.232 111.699 406.232 110.663 407.268L108.679 409.253L106.693 407.268C105.657 406.232 103.976 406.232 102.94 407.268C101.904 408.307 101.904 409.985 102.94 411.023L104.925 413.007L102.94 414.991C101.904 416.028 101.904 417.707 102.94 418.745C103.459 419.263 104.137 419.523 104.817 419.523C105.496 419.523 106.176 419.263 106.693 418.745L108.679 416.76L110.663 418.745C111.181 419.263 111.86 419.523 112.54 419.523C113.219 419.523 113.899 419.263 114.416 418.745C115.453 417.707 115.453 416.028 114.416 414.991L112.432 413.007Z\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.5\"}]\n5c:[\"$\",\"path\",null,{\"d\":\"M148.308 477.631L149.933 476.005C150.783 475.157 150.783 473.779 149.933 472.931C149.084 472.082 147.708 472.082 146.859 472.931L145.233 474.555L143.608 472.931C142.759 472.082 141.383 472.082 140.533 472.931C139.684 473.779 139.684 475.157 140.533 476.005L142.159 477.631L140.533 479.257C139.684 480.106 139.684 481.482 140.533 482.331C140.957 482.757 141.513 482.969 142.071 482.969C142.627 482.969 143.183 482.757 143.608 482.331L145.233 480.706L146.859 482.331C147.283 482.757 147.84 482.969 148.396 482.969C148.952 482.969 149.508 482.757 149.933 482.331C150.783 481.482 150.783 480.106 149.933 479.257L148.308 477.631Z\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.6\"}]\n5d:[\"$\",\"path\",null,{\"d\":\"M506.861 412.675L509.353 410.183C510.656 408.88 510.656 406.771 509.353 405.469C508.052 404.167 505.942 404.167 504.64 405.469L502.148 407.961L499.656 405.469C498.353 404.167 496.244 404.167 494.942 405.469C493.64 406.771 493.64 408.88 494.942 410.183L497.434 412.675L494.942 415.167C493.64 416.469 493.64 418.579 494.942 419.88C495.593 420.532 496.445 420.857 497.298 420.857C498.152 420.857 499.004 420.532 499.656 419.88L502.148 417.388L504.64 419.88C505.29 420.532 506.144 420.857 506.997 420.857C507.849 420.857 508.702 420.532 509.353 419.88C510.656 418.579 510.656 416.469 509.353 415.167L506.861 412.675Z\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.2\"}]\n5e:[\"$\",\"path\",null,{\"d\":\"M220.265 375.948L222.757 373.456C224.06 372.155 224.06 370.044 222.759 368.743C221.456 367.44 219.345 367.44 218.044 368.743L215.551 371.236L213.059 368.743C211.757 367.44 209.647 367.44 208.345 368.743C207.043 370.044 207.043 372.155 208.345 373.456L210.837 375.948L208.345 378.44C207.043 379.741 207.043 381.852 208.345 383.153C208.996 383.805 209.849 384.131 210.703 384.131C211.555 384.131 212.408 383.805 213.059 383.153L215.551 380.661L218.044 383.153C218.695 383.805 219.548 384.131 220.401 384.131C221.253 384.131 222.107 383.805 222.759 383.153C224.06 381.852 224.06 379.741 222.757 378.44L220.265 375.948Z\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.4\"}]\n5f:[\"$\",\"path\",null,{\"d\":\"M67.4747 305.565C65.6161 305.565 64.1054 307.077 64.1054 308.935C64.1054 310.793 65.6161 312.305 67.4747 312.305C69.3334 312.305 70.8441 310.793 70.8441 308.935C70.8441 307.077 69.3334 305.565 67.4747 305.565ZM67.4747 317.932C62.5134 317.932 58.4761 313.896 58.4761 308.935C58.4761 303.975 62.5134 299.936 67.4747 299.936C72.4361 299.936 76.4734 303.975 76.4734 308.935C76.4734 313.896 72.4361 317.932 67.4747 317.932Z\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.6\"}]\n60:[\"$\",\"path\",null,{\"d\":\"M11.7073 191.394C11.7073 194.437 9.24059 196.904 6.19792 196.904C3.15392 196.904 0.687256 194.437 0.687256 191.394C0.687256 188.352 3.15392 185.885 6.19792 185.885C9.24059 185.885 11.7073 188.352 11.7073 191.394Z\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.2\"}]\n61:[\"$\",\"path\",null,{\"d\":\"M565.722 101.94C565.722 104.983 563.254 107.45 560.211 107.45C557.168 107.45 554.7 104.983 554.7 101.94C554.7 98.8977 557.168 96.4311 560.211 96.4311C563.254 96.4311 565.722 98.8977 565.722 101.94Z\",\"fill\":\"va"])</script><script>self.__next_f.push([1,"r(--primary)\",\"fillOpacity\":\"0.6\"}]\n62:[\"$\",\"path\",null,{\"d\":\"M392.343 463.466C392.343 466.509 389.877 468.976 386.833 468.976C383.79 468.976 381.323 466.509 381.323 463.466C381.323 460.424 383.79 457.956 386.833 457.956C389.877 457.956 392.343 460.424 392.343 463.466Z\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.1\"}]\n63:[\"$\",\"path\",null,{\"d\":\"M60.6096 410.003C60.6096 413.046 58.1429 415.514 55.1003 415.514C52.0563 415.514 49.5896 413.046 49.5896 410.003C49.5896 406.961 52.0563 404.493 55.1003 404.493C58.1429 404.493 60.6096 406.961 60.6096 410.003Z\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.6\"}]\n64:[\"$\",\"path\",null,{\"d\":\"M372.275 57.6508C370.58 57.6508 369.199 59.0295 369.199 60.7255C369.199 62.4215 370.58 63.8015 372.275 63.8015C373.97 63.8015 375.351 62.4215 375.351 60.7255C375.351 59.0295 373.97 57.6508 372.275 57.6508ZM372.275 68.9375C367.747 68.9375 364.063 65.2535 364.063 60.7255C364.063 56.1975 367.747 52.5135 372.275 52.5135C376.803 52.5135 380.487 56.1975 380.487 60.7255C380.487 65.2535 376.803 68.9375 372.275 68.9375Z\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.4\"}]\n65:[\"$\",\"path\",null,{\"d\":\"M522.195 198.33C520.461 198.33 519.051 199.74 519.051 201.474C519.051 203.208 520.461 204.619 522.195 204.619C523.929 204.619 525.338 203.208 525.338 201.474C525.338 199.74 523.929 198.33 522.195 198.33ZM522.195 209.871C517.565 209.871 513.798 206.104 513.798 201.474C513.798 196.844 517.565 193.078 522.195 193.078C526.825 193.078 530.591 196.844 530.591 201.474C530.591 206.104 526.825 209.871 522.195 209.871Z\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.2\"}]\n66:[\"$\",\"path\",null,{\"d\":\"M316.992 362.107C315.405 362.107 314.113 363.399 314.113 364.986C314.113 366.574 315.405 367.864 316.992 367.864C318.579 367.864 319.871 366.574 319.871 364.986C319.871 363.399 318.579 362.107 316.992 362.107ZM316.992 372.672C312.753 372.672 309.305 369.224 309.305 364.986C309.305 360.747 312.753 357.3 316.992 357.3C321.231 357.3 324.679 360.747 324.679 364.986C324.679 369.224 321.231 372.672 316.992 372.672Z\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.1\"}]\n67:[\"$\",\"path\",null,{\"d\":\"M38.2497 22.9105C36.6551 22.9105 35.3564 24.2079 35.3564 25.8039C35.3564 27.3985 36.6551 28.6959 38.2497 28.6959C39.8444 28.6959 41.1431 27.3985 41.1431 25.8039C41.1431 24.2079 39.8444 22.9105 38.2497 22.9105ZM38.2497 33.5292C33.9897 33.5292 30.5244 30.0639 30.5244 25.8039C30.5244 21.5439 33.9897 18.0772 38.2497 18.0772C42.5097 18.0772 45.9751 21.5439 45.9751 25.8039C45.9751 30.0639 42.5097 33.5292 38.2497 33.5292Z\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.5\"}]\n68:[\"$\",\"div\",null,{\"className\":\"flex flex-col items-center gap-4 text-center\",\"children\":[[\"$\",\"p\",null,{\"className\":\"text-muted-foreground text-xl sm:text-2xl\",\"children\":\"We couldn't find the page you are looking for\"}],[\"$\",\"$L73\",null,{\"href\":\"/\",\"children\":\"Go back to home\",\"data-slot\":\"button\",\"data-variant\":\"default\",\"data-size\":\"default\",\"className\":\"focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive inline-flex shrink-0 items-center justify-center gap-2 text-sm font-medium whitespace-nowrap transition-all outline-none focus-visible:ring-[3px] disabled:pointer-events-none disabled:opacity-50 [\u0026_svg]:pointer-events-none [\u0026_svg]:shrink-0 [\u0026_svg:not([class*='size-'])]:size-4 bg-primary text-primary-foreground hover:bg-primary/90 h-9 px-4 py-2 has-[\u003esvg]:px-3 rounded-full\",\"ref\":null}]]}]\n"])</script><script>self.__next_f.push([1,"69:[\"$\",\"$1\",\"c\",{\"children\":[[[\"$\",\"script\",\"script-0\",{\"src\":\"/_next/static/chunks/fa1a8f8830b9bf3a.js\",\"async\":true,\"nonce\":\"$undefined\"}],[\"$\",\"script\",\"script-1\",{\"src\":\"/_next/static/chunks/6dd6809ee42e252f.js\",\"async\":true,\"nonce\":\"$undefined\"}],[\"$\",\"script\",\"script-2\",{\"src\":\"/_next/static/chunks/f2b800ca7ae14e96.js\",\"async\":true,\"nonce\":\"$undefined\"}],[\"$\",\"script\",\"script-3\",{\"src\":\"/_next/static/chunks/e121db38c98deeb4.js\",\"async\":true,\"nonce\":\"$undefined\"}],[\"$\",\"script\",\"script-4\",{\"src\":\"/_next/static/chunks/6d971f5a9c16d0c2.js\",\"async\":true,\"nonce\":\"$undefined\"}],[\"$\",\"script\",\"script-5\",{\"src\":\"/_next/static/chunks/b397c2fd2abb1207.js\",\"async\":true,\"nonce\":\"$undefined\"}]],[\"$\",\"div\",null,{\"className\":\"flex flex-col\",\"children\":[[\"$\",\"$L74\",null,{\"navigationData\":[{\"title\":\"技术博客\",\"href\":\"/blog\",\"description\":\"技术博客专栏\",\"icon\":[\"$\",\"svg\",null,{\"ref\":\"$undefined\",\"xmlns\":\"http://www.w3.org/2000/svg\",\"width\":24,\"height\":24,\"viewBox\":\"0 0 24 24\",\"fill\":\"none\",\"stroke\":\"currentColor\",\"strokeWidth\":2,\"strokeLinecap\":\"round\",\"strokeLinejoin\":\"round\",\"className\":\"lucide lucide-book-open size-4.5!\",\"aria-hidden\":\"true\",\"children\":[[\"$\",\"path\",\"1akyts\",{\"d\":\"M12 7v14\"}],[\"$\",\"path\",\"ruj8y\",{\"d\":\"M3 18a1 1 0 0 1-1-1V4a1 1 0 0 1 1-1h5a4 4 0 0 1 4 4 4 4 0 0 1 4-4h5a1 1 0 0 1 1 1v13a1 1 0 0 1-1 1h-6a3 3 0 0 0-3 3 3 3 0 0 0-3-3z\"}],\"$undefined\"]}]},{\"title\":\"生活随笔\",\"href\":\"/essay\",\"description\":\"生活随笔专栏\",\"icon\":[\"$\",\"svg\",null,{\"ref\":\"$undefined\",\"xmlns\":\"http://www.w3.org/2000/svg\",\"width\":24,\"height\":24,\"viewBox\":\"0 0 24 24\",\"fill\":\"none\",\"stroke\":\"currentColor\",\"strokeWidth\":2,\"strokeLinecap\":\"round\",\"strokeLinejoin\":\"round\",\"className\":\"lucide lucide-book-open size-4.5!\",\"aria-hidden\":\"true\",\"children\":[[\"$\",\"path\",\"1akyts\",{\"d\":\"M12 7v14\"}],[\"$\",\"path\",\"ruj8y\",{\"d\":\"M3 18a1 1 0 0 1-1-1V4a1 1 0 0 1 1-1h5a4 4 0 0 1 4 4 4 4 0 0 1 4-4h5a1 1 0 0 1 1 1v13a1 1 0 0 1-1 1h-6a3 3 0 0 0-3 3 3 3 0 0 0-3-3z\"}],\"$undefined\"]}]},{\"title\":\"归档\",\"href\":\"/archives\"},{\"title\":\"分类\",\"href\":\"/category\"},{\"title\":\"友链\",\"href\":\"/friends\"},{\"title\":\"留言\",\"href\":\"/message\"},{\"title\":\"关于\",\"href\":\"/about\"}]}],[\"$\",\"main\",null,{\"className\":\"relative flex flex-col overflow-x-clip *:scroll-mt-15.5\",\"children\":[\"$\",\"$L3\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L4\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[[\"$\",\"div\",null,{\"className\":\"flex h-screen w-screen flex-col items-center justify-center gap-9 p-6\",\"children\":[[\"$\",\"svg\",null,{\"width\":\"1.21325em\",\"height\":\"1em\",\"viewBox\":\"0 0 586 483\",\"fill\":\"none\",\"xmlns\":\"http://www.w3.org/2000/svg\",\"className\":\"h-auto w-full sm:h-120 sm:w-146\",\"children\":[[\"$\",\"path\",null,{\"d\":\"M207.891 275.994H145.943C144.721 275.994 143.729 275.003 143.729 273.782C143.729 272.559 144.721 271.57 145.943 271.57H207.891C209.113 271.57 210.104 272.559 210.104 273.782C210.104 275.003 209.113 275.994 207.891 275.994Z\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.5\"}],[\"$\",\"path\",null,{\"d\":\"M138 275.994C134.043 275.994 130.821 272.775 130.819 268.819L130.813 262.514C130.812 261.291 131.803 260.301 133.025 260.299C134.247 260.299 135.237 261.289 135.239 262.51L135.244 268.815C135.245 270.334 136.481 271.57 138 271.57C139.223 271.57 140.213 272.559 140.213 273.782C140.213 275.003 139.223 275.994 138 275.994Z\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.4\"}],[\"$\",\"path\",null,{\"d\":\"M135.512 255.3C135.226 255.3 134.934 255.244 134.652 255.125C133.527 254.651 132.999 253.353 133.475 252.227L161.388 186.077C161.864 184.951 163.162 184.423 164.288 184.899C165.414 185.375 165.94 186.672 165.466 187.799L137.551 253.948C137.195 254.792 136.375 255.3 135.512 255.3Z\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.1\"}],[\"$\",\"path\",null,{\"d\":\"M193.483 200.724C192.261 200.724 191.271 199.735 191.271 198.514L191.227 138.55C191.227 137.911 190.977 137.311 190.527 136.862C190.076 136.411 189.476 136.163 188.839 136.163H188.837C187.875 136.164 187.012 136.736 186.64 137.622L170.917 174.879C170.443 176.004 169.144 176.531 168.019 176.058C166.893 175.583 166.365 174.284 166.841 173.158L182.563 135.902C183.628 133.374 186.091 131.739 188.835 131.738H188.839C190.656 131.738 192.367 132.446 193.652 133.73C194.94 135.015 195.651 136.726 195.652 138.546L195.696 198.51C195.696 199.732 194.704 200.723 193.483 200.724Z\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.5\"}],\"$L75\",\"$L76\",\"$L77\",\"$L78\",\"$L79\",\"$L7a\",\"$L7b\",\"$L7c\",\"$L7d\",\"$L7e\",\"$L7f\",\"$L80\",\"$L81\",\"$L82\",\"$L83\",\"$L84\",\"$L85\",\"$L86\",\"$L87\",\"$L88\",\"$L89\",\"$L8a\",\"$L8b\",\"$L8c\",\"$L8d\",\"$L8e\",\"$L8f\",\"$L90\",\"$L91\",\"$L92\",\"$L93\",\"$L94\",\"$L95\",\"$L96\",\"$L97\",\"$L98\",\"$L99\",\"$L9a\",\"$L9b\",\"$L9c\",\"$L9d\",\"$L9e\",\"$L9f\",\"$La0\",\"$La1\",\"$La2\",\"$La3\",\"$La4\",\"$La5\",\"$La6\",\"$La7\",\"$La8\",\"$La9\",\"$Laa\",\"$Lab\",\"$Lac\",\"$Lad\",\"$Lae\",\"$Laf\",\"$Lb0\",\"$Lb1\",\"$Lb2\",\"$Lb3\",\"$Lb4\",\"$Lb5\",\"$Lb6\",\"$Lb7\",\"$Lb8\",\"$Lb9\",\"$Lba\",\"$Lbb\",\"$Lbc\",\"$Lbd\",\"$Lbe\",\"$Lbf\",\"$Lc0\",\"$Lc1\",\"$Lc2\",\"$Lc3\",\"$Lc4\",\"$Lc5\",\"$Lc6\",\"$Lc7\",\"$Lc8\",\"$Lc9\",\"$Lca\",\"$Lcb\",\"$Lcc\",\"$Lcd\",\"$Lce\",\"$Lcf\",\"$Ld0\",\"$Ld1\",\"$Ld2\",\"$Ld3\",\"$Ld4\",\"$Ld5\",\"$Ld6\",\"$Ld7\",\"$Ld8\",\"$Ld9\"]}],\"$Lda\"]}],[]],\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]}],\"$Ldb\"]}]]}]\n"])</script><script>self.__next_f.push([1,"6a:[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L3\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L4\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}]\n6b:[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L3\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L4\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}]\n6c:[\"$\",\"$1\",\"c\",{\"children\":[\"$Ldc\",[[\"$\",\"script\",\"script-0\",{\"src\":\"/_next/static/chunks/11dff99839ab5ba0.js\",\"async\":true,\"nonce\":\"$undefined\"}]],[\"$\",\"$Ldd\",null,{\"children\":[\"$\",\"$de\",null,{\"name\":\"Next.MetadataOutlet\",\"children\":\"$@df\"}]}]]}]\n6d:[\"$\",\"$1\",\"h\",{\"children\":[null,[\"$\",\"$Le0\",null,{\"children\":\"$Le1\"}],[\"$\",\"div\",null,{\"hidden\":true,\"children\":[\"$\",\"$Le2\",null,{\"children\":[\"$\",\"$de\",null,{\"name\":\"Next.Metadata\",\"children\":\"$Le3\"}]}]}],[\"$\",\"meta\",null,{\"name\":\"next-size-adjust\",\"content\":\"\"}]]}]\n"])</script><script>self.__next_f.push([1,"e8:I[6541,[\"/_next/static/chunks/4eaa70fe861e9598.js\",\"/_next/static/chunks/fa1a8f8830b9bf3a.js\",\"/_next/static/chunks/6dd6809ee42e252f.js\",\"/_next/static/chunks/f2b800ca7ae14e96.js\",\"/_next/static/chunks/e121db38c98deeb4.js\",\"/_next/static/chunks/6d971f5a9c16d0c2.js\",\"/_next/static/chunks/b397c2fd2abb1207.js\"],\"default\"]\n75:[\"$\",\"path\",null,{\"d\":\"M193.526 260.989C192.304 260.989 191.314 259.999 191.314 258.778L191.278 211.335C191.276 210.113 192.267 209.122 193.488 209.121H193.491C194.711 209.121 195.702 210.11 195.703 211.331L195.738 258.774C195.739 259.997 194.75 260.989 193.527 260.989H193.526Z\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.6\"}]\n76:[\"$\",\"path\",null,{\"d\":\"M191.104 333.895C180.45 333.895 171.778 325.231 171.77 314.575L171.758 296.83L131.31 296.86H131.295C119.475 296.86 109.855 287.248 109.847 275.427C109.846 274.204 110.835 273.214 112.057 273.212H112.059C113.281 273.212 114.271 274.202 114.271 275.423C114.278 284.806 121.914 292.434 131.295 292.434H131.307L173.966 292.404H173.967C174.554 292.404 175.116 292.636 175.531 293.05C175.947 293.466 176.181 294.028 176.181 294.615L176.195 314.571C176.2 322.788 182.888 329.47 191.104 329.471H191.115L196.367 329.467C204.588 329.46 211.272 322.767 211.266 314.546L211.251 294.59C211.251 293.367 212.242 292.375 213.463 292.375H213.465C214.686 292.375 215.676 293.366 215.676 294.587L215.691 314.543C215.699 325.203 207.033 333.883 196.371 333.891L191.119 333.895H191.104Z\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.2\"}]\n77:[\"$\",\"path\",null,{\"d\":\"M228.639 282.92C227.417 282.92 226.428 281.931 226.427 280.71L226.409 261.81C226.407 257.682 223.047 254.326 218.92 254.326H218.915L213.435 254.33H213.433C212.847 254.33 212.284 254.096 211.869 253.682C211.455 253.267 211.221 252.704 211.221 252.116V243.01C211.221 241.788 212.212 240.798 213.433 240.798C214.656 240.798 215.645 241.788 215.645 243.01V249.902L218.912 249.9H218.92C225.487 249.9 230.831 255.239 230.835 261.807L230.852 280.706C230.853 281.928 229.863 282.919 228.641 282.92H228.639Z\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.5\"}]\n78:[\"$\",\"path\",null,{\"d\":\"M213.416 212.608C212.194 212.608 211.204 211.618 211.202 210.397L211.141 139.09C211.14 137.868 212.13 136.877 213.352 136.876H213.353C214.576 136.876 215.565 137.865 215.566 139.086L215.628 210.393C215.629 211.614 214.64 212.608 213.417 212.608H213.416Z\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.4\"}]\n79:[\"$\",\"path\",null,{\"d\":\"M213.339 132.149C212.116 132.149 211.127 131.158 211.127 129.936V120.657C211.124 118.22 209.14 116.237 206.701 116.237H206.699L176.973 116.26C175.192 116.26 173.592 117.321 172.9 118.964L169.015 128.169C168.54 129.294 167.243 129.822 166.116 129.346C164.991 128.872 164.463 127.574 164.939 126.448L168.823 117.242C170.208 113.96 173.407 111.836 176.971 111.834L206.695 111.813H206.701C211.579 111.813 215.548 115.778 215.552 120.656V129.936C215.552 131.158 214.561 132.149 213.339 132.149Z\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.5\"}]\n7a:[\"$\",\"path\",null,{\"d\":\"M115.532 251.431C115.246 251.431 114.954 251.375 114.672 251.257C113.547 250.782 113.019 249.485 113.495 248.358L160.728 136.425C161.203 135.298 162.502 134.769 163.627 135.246C164.754 135.721 165.28 137.018 164.806 138.145L117.571 250.079C117.215 250.923 116.394 251.431 115.532 251.431Z\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.1\"}]\n7b:[\"$\",\"path\",null,{\"d\":\"M211.557 283.526H200.201C198.98 283.526 197.989 282.536 197.989 281.313C197.989 280.092 198.98 279.101 200.201 279.101H211.556C211.98 279.101 212.38 278.934 212.68 278.634C212.981 278.333 213.146 277.933 213.146 277.506L213.14 269.197C213.14 268.32 212.425 267.605 211.546 267.605L206.808 267.609H206.801C204.44 267.609 202.218 266.69 200.548 265.021C198.874 263.35 197.953 261.129 197.95 258.765L197.898 185.256C197.897 184.034 198.888 183.042 200.109 183.042H200.11C201.332 183.042 202.322 184.032 202.324 185.253L202.376 258.762C202.377 261.201 204.362 263.184 206.801 263.184H206.804L211.542 263.181H211.546C214.862 263.181 217.562 265.877 217.565 269.194L217.572 277.504C217.573 279.11 216.948 280.624 215.812 281.761C214.676 282.898 213.165 283.525"])</script><script>self.__next_f.push([1," 211.557 283.526Z\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.1\"}]\ne4:T54a,M193.729 320.618C191.411 320.618 189.231 319.716 187.591 318.079C185.95 316.439 185.045 314.258 185.043 311.939L185.026 287.971C185.025 285.532 183.039 283.548 180.601 283.548H180.598L137.643 283.579H137.633C129.633 283.58 123.122 277.075 123.117 269.075L123.111 260.164C123.111 259.868 123.17 259.576 123.285 259.303L179.342 126.458C179.689 125.639 180.49 125.106 181.379 125.106L194.965 125.096H194.971C196.922 125.096 198.757 125.855 200.139 127.235C201.522 128.615 202.283 130.451 202.285 132.404L202.309 162.106C202.31 163.327 201.319 164.319 200.098 164.319H200.095C198.875 164.319 197.885 163.33 197.883 162.108L197.861 132.408C197.859 131.636 197.558 130.911 197.011 130.366C196.466 129.82 195.741 129.522 194.97 129.522L182.85 129.53L127.535 260.611L127.542 269.071C127.546 274.632 132.071 279.155 137.633 279.155H137.641L180.594 279.123H180.601C185.478 279.123 189.447 283.09 189.451 287.968L189.469 311.935C189.469 313.074 189.913 314.144 190.718 314.947C191.522 315.751 192.591 316.194 193.729 316.194H193.731C194.87 316.192 195.939 315.748 196.743 314.943C197.547 314.138 197.99 313.067 197.989 311.93L197.973 287.962C197.971 286.739 198.961 285.748 200.182 285.747H200.185C201.406 285.747 202.395 286.736 202.397 287.958L202.414 311.926C202.415 314.247 201.514 316.428 199.874 318.07C198.235 319.711 196.055 320.616 193.735 320.618H193.729Z7c:[\"$\",\"path\",null,{\"d\":\"$e4\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.2\"}]\n7d:[\"$\",\"path\",null,{\"d\":\"M156.11 225.068C155.823 225.068 155.532 225.012 155.251 224.895C154.126 224.42 153.598 223.123 154.072 221.996L185.179 148.145C185.654 147.02 186.948 146.492 188.076 146.965C189.202 147.44 189.731 148.737 189.256 149.864L158.15 223.713C157.794 224.56 156.972 225.068 156.11 225.068Z\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.4\"}]\n7e:[\"$\",\"path\",null,{\"d\":\"M148.172 267.651C145.2 267.651 142.445 266.174 140.801 263.699C139.156 261.222 138.862 258.107 140.016 255.366L149.121 233.749C149.596 232.623 150.892 232.094 152.02 232.569C153.145 233.043 153.673 234.341 153.2 235.467L144.094 257.083C143.517 258.454 143.664 260.011 144.486 261.25C145.309 262.487 146.686 263.226 148.172 263.226H148.174L180.584 263.203C181.765 263.202 182.876 262.741 183.712 261.905C184.546 261.069 185.005 259.957 185.005 258.775L184.949 181.989C184.949 180.767 185.938 179.775 187.161 179.775C188.382 179.775 189.374 180.765 189.374 181.986L189.43 258.771C189.433 263.651 185.466 267.625 180.586 267.627L148.178 267.651H148.172Z\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.2\"}]\n7f:[\"$\",\"path\",null,{\"d\":\"M192.489 327.257C184.728 327.258 178.412 320.946 178.406 313.185L178.388 295.044C178.386 293.822 179.377 292.832 180.598 292.83H180.601C181.822 292.83 182.812 293.818 182.813 295.04L182.832 313.18C182.836 318.505 187.168 322.833 192.489 322.833H192.496L194.977 322.83C200.302 322.826 204.632 318.492 204.628 313.166C204.626 311.945 205.617 310.952 206.838 310.952C208.06 310.952 209.052 311.942 209.053 313.162C209.058 320.928 202.745 327.249 194.981 327.256L192.498 327.257H192.489Z\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.1\"}]\n80:[\"$\",\"path\",null,{\"d\":\"M206.834 304.112C205.612 304.112 204.622 303.123 204.622 301.902L204.61 287.958C204.61 287.37 204.842 286.807 205.256 286.391C205.671 285.976 206.234 285.743 206.82 285.743L214.588 285.738C217.456 285.735 219.788 283.4 219.786 280.532L219.776 266.164C219.774 263.296 217.44 260.966 214.575 260.966H214.571L206.803 260.972C206.216 260.972 205.652 260.739 205.238 260.324C204.822 259.91 204.588 259.347 204.588 258.76L204.494 126.978C204.492 124.716 202.652 122.879 200.391 122.879H200.39L178.444 122.895L164.83 155.16C164.355 156.286 163.056 156.814 161.931 156.338C160.806 155.863 160.278 154.566 160.752 153.439L174.939 119.823C175.284 119.004 176.086 118.472 176.975 118.471L200.387 118.454H200.391C205.091 118.454 208.915 122.275 208.919 126.974L209.012 256.544L214.567 256.54H214.575C219.879 256.54 224.196 260.855 224.2 266.16L224.211 280.528C224.215 285.836 219.9 290.158 214.592 290.162L209.036 290.166L209.047 301.898C209"])</script><script>self.__next_f.push([1,".047 303.12 208.056 304.111 206.834 304.112Z\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.6\"}]\n81:[\"$\",\"path\",null,{\"d\":\"M144.424 200.037C144.137 200.037 143.845 199.981 143.564 199.862C142.439 199.388 141.911 198.09 142.387 196.964L158.196 159.497C158.672 158.37 159.971 157.842 161.095 158.319C162.221 158.794 162.748 160.091 162.273 161.218L146.463 198.685C146.107 199.529 145.287 200.037 144.424 200.037Z\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.5\"}]\n82:[\"$\",\"path\",null,{\"d\":\"M135.422 290.219C124.984 290.219 116.488 281.731 116.48 271.292L116.472 258.824C116.472 258.528 116.531 258.235 116.646 257.962L134.125 216.539C134.6 215.414 135.899 214.886 137.024 215.36C138.149 215.836 138.678 217.134 138.203 218.26L120.898 259.27L120.906 271.288C120.912 279.288 127.423 285.794 135.422 285.794H135.432L158.172 285.778C159.393 285.778 160.385 286.767 160.387 287.988C160.388 289.21 159.397 290.202 158.176 290.202L135.436 290.219H135.422Z\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.6\"}]\n83:[\"$\",\"path\",null,{\"d\":\"M178.32 192.926L151.613 256.33C151.601 256.358 151.575 256.422 151.629 256.505C151.684 256.586 151.759 256.586 151.784 256.586L176.708 256.567C177.623 256.567 178.365 255.823 178.365 254.909L178.32 192.926ZM151.784 261.011C150.236 261.011 148.8 260.242 147.944 258.953C147.087 257.662 146.935 256.039 147.536 254.613L175.275 188.757C176.001 187.031 177.793 186.087 179.625 186.455C181.46 186.825 182.741 188.391 182.743 190.262L182.791 254.905C182.792 258.259 180.065 260.99 176.711 260.993L151.787 261.011H151.784Z\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.6\"}]\n84:[\"$\",\"path\",null,{\"d\":\"M193.546 313.947C192.324 313.947 191.334 312.958 191.334 311.736L191.312 282.104C191.312 280.882 192.302 279.891 193.523 279.89C194.745 279.89 195.738 280.879 195.738 282.1L195.759 311.732C195.759 312.955 194.769 313.946 193.547 313.947H193.546Z\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.4\"}]\n85:[\"$\",\"path\",null,{\"d\":\"M215.599 219.049C215.599 220.266 214.613 221.251 213.395 221.251C212.179 221.251 211.193 220.266 211.193 219.049C211.193 217.831 212.179 216.846 213.395 216.846C214.613 216.846 215.599 217.831 215.599 219.049Z\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.4\"}]\n86:[\"$\",\"path\",null,{\"d\":\"M195.729 265.439C195.729 266.656 194.742 267.641 193.526 267.641C192.309 267.641 191.322 266.656 191.322 265.439C191.322 264.221 192.309 263.236 193.526 263.236C194.742 263.236 195.729 264.221 195.729 265.439Z\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.6\"}]\n87:[\"$\",\"path\",null,{\"d\":\"M230.842 289.323C230.842 290.539 229.855 291.526 228.639 291.526C227.422 291.526 226.435 290.539 226.435 289.323C226.435 288.106 227.422 287.119 228.639 287.119C229.855 287.119 230.842 288.106 230.842 289.323Z\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.5\"}]\n88:[\"$\",\"path\",null,{\"d\":\"M114.262 266.539C114.262 267.756 113.275 268.742 112.059 268.742C110.842 268.742 109.855 267.756 109.855 266.539C109.855 265.322 110.842 264.336 112.059 264.336C113.275 264.336 114.262 265.322 114.262 266.539Z\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.1\"}]\n89:[\"$\",\"path\",null,{\"d\":\"M142.101 208.625C142.101 209.843 141.114 210.828 139.898 210.828C138.681 210.828 137.694 209.843 137.694 208.625C137.694 207.408 138.681 206.423 139.898 206.423C141.114 206.423 142.101 207.408 142.101 208.625Z\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.5\"}]\n8a:[\"$\",\"path\",null,{\"d\":\"M168.259 180.777C168.259 181.994 167.272 182.98 166.056 182.98C164.839 182.98 163.852 181.994 163.852 180.777C163.852 179.56 164.839 178.574 166.056 178.574C167.272 178.574 168.259 179.56 168.259 180.777Z\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.5\"}]\n8b:[\"$\",\"path\",null,{\"d\":\"M168.782 288.023C168.782 289.239 167.795 290.225 166.579 290.225C165.362 290.225 164.375 289.239 164.375 288.023C164.375 286.805 165.362 285.819 166.579 285.819C167.795 285.819 168.782 286.805 168.782 288.023Z\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.6\"}]\n8c:[\"$\",\"path\",null,{\"d\":\"M202.489 175.354C202.489 176.571 201.503 177.557 200.285 177.557C199.069 177.557 198.083 176.571 198.083 175.354C198.083 174.137 199.069 173.151 200.285 173.151C201.503 173.151 202.489 174.137 202.489 "])</script><script>self.__next_f.push([1,"175.354Z\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.1\"}]\n8d:[\"$\",\"path\",null,{\"d\":\"M187.217 176.231C185.994 176.231 185.005 175.241 185.005 174.019V169.845C185.005 168.622 185.994 167.631 187.217 167.631C188.44 167.631 189.43 168.622 189.43 169.845V174.019C189.43 175.241 188.44 176.231 187.217 176.231Z\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.4\"}]\n8e:[\"$\",\"path\",null,{\"d\":\"M213.339 236.36C212.116 236.36 211.127 235.37 211.127 234.148V227.544C211.127 226.323 212.116 225.332 213.339 225.332C214.561 225.332 215.552 226.323 215.552 227.544V234.148C215.552 235.37 214.561 236.36 213.339 236.36Z\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.4\"}]\n8f:[\"$\",\"path\",null,{\"d\":\"M260.605 327.422C260.229 327.422 259.849 327.328 259.5 327.125C244.798 318.624 237.026 302.432 237.026 280.294V196.306C237.026 195.084 238.017 194.093 239.24 194.093C240.461 194.093 241.452 195.084 241.452 196.306V280.294C241.452 300.761 248.458 315.629 261.716 323.294C262.772 323.905 263.134 325.258 262.522 326.317C262.113 327.026 261.369 327.422 260.605 327.422Z\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.1\"}]\n90:[\"$\",\"path\",null,{\"d\":\"M287.996 333.892C286.774 333.892 285.783 332.902 285.783 331.68C285.783 330.458 286.774 329.467 287.996 329.467C318.012 329.467 334.542 312.003 334.542 280.295C334.542 279.072 335.531 278.083 336.754 278.083C337.975 278.083 338.967 279.072 338.967 280.295C338.967 314.358 320.388 333.892 287.996 333.892Z\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.2\"}]\n91:[\"$\",\"path\",null,{\"d\":\"M336.754 247.479C335.532 247.479 334.542 246.488 334.542 245.267V180.777C334.542 179.555 335.532 178.564 336.754 178.564C337.976 178.564 338.966 179.555 338.966 180.777V245.267C338.966 246.488 337.976 247.479 336.754 247.479Z\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.2\"}]\n92:[\"$\",\"path\",null,{\"d\":\"M336.754 167.631C335.532 167.631 334.542 166.64 334.542 165.419C334.542 133.709 318.012 116.245 287.997 116.245C257.981 116.245 241.452 133.709 241.452 165.419C241.452 166.64 240.461 167.631 239.24 167.631C238.017 167.631 237.028 166.64 237.028 165.419C237.028 131.356 255.605 111.82 287.997 111.82C320.389 111.82 338.966 131.356 338.966 165.419C338.966 166.64 337.976 167.631 336.754 167.631Z\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.6\"}]\n93:[\"$\",\"path\",null,{\"d\":\"M255.629 270.851C255.629 272.068 254.642 273.053 253.425 273.053C252.209 273.053 251.222 272.068 251.222 270.851C251.222 269.633 252.209 268.648 253.425 268.648C254.642 268.648 255.629 269.633 255.629 270.851Z\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.6\"}]\n94:[\"$\",\"path\",null,{\"d\":\"M338.957 173.097C338.957 174.315 337.971 175.3 336.755 175.3C335.537 175.3 334.551 174.315 334.551 173.097C334.551 171.88 335.537 170.895 336.755 170.895C337.971 170.895 338.957 171.88 338.957 173.097Z\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.6\"}]\n95:[\"$\",\"path\",null,{\"d\":\"M316.991 159.019C316.991 160.237 316.004 161.222 314.788 161.222C313.571 161.222 312.583 160.237 312.583 159.019C312.583 157.802 313.571 156.817 314.788 156.817C316.004 156.817 316.991 157.802 316.991 159.019Z\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.2\"}]\n96:[\"$\",\"path\",null,{\"d\":\"M260.973 131.566C260.973 132.783 259.986 133.769 258.77 133.769C257.553 133.769 256.566 132.783 256.566 131.566C256.566 130.349 257.553 129.363 258.77 129.363C259.986 129.363 260.973 130.349 260.973 131.566Z\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.2\"}]\n97:[\"$\",\"path\",null,{\"d\":\"M273.517 329.679C273.517 330.895 272.53 331.881 271.314 331.881C270.097 331.881 269.11 330.895 269.11 329.679C269.11 328.461 270.097 327.476 271.314 327.476C272.53 327.476 273.517 328.461 273.517 329.679Z\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.1\"}]\n98:[\"$\",\"path\",null,{\"d\":\"M287.996 326.203C260.062 326.203 244.04 309.362 244.04 279.998V239.222C244.04 238.001 245.031 237.01 246.252 237.01C247.475 237.01 248.466 238.001 248.466 239.222V279.998C248.466 306.941 262.504 321.779 287.996 321.779C313.488 321.779 327.527 306.941 327.527 279.998V165.714C327.527 152.634 324.271 142.384 317.851 135.248C317.032 134.34 317.107 132.939 318.016 132.122C318.924 131.305 320.323 131.378 321.139 132.288C328.314 140.26 331.952 15"])</script><script>self.__next_f.push([1,"1.508 331.952 165.714V279.998C331.952 309.362 315.931 326.203 287.996 326.203Z\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.4\"}]\n99:[\"$\",\"path\",null,{\"d\":\"M313.066 130.472C312.65 130.472 312.229 130.355 311.856 130.111C305.598 126.012 297.572 123.934 287.996 123.934C279.15 123.934 271.609 125.712 265.581 129.219C264.525 129.834 263.17 129.475 262.556 128.419C261.941 127.363 262.3 126.008 263.356 125.394C270.069 121.49 278.36 119.51 287.996 119.51C298.446 119.51 307.29 121.831 314.28 126.408C315.302 127.078 315.588 128.45 314.92 129.472C314.493 130.12 313.786 130.472 313.066 130.472Z\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.1\"}]\n9a:[\"$\",\"path\",null,{\"d\":\"M246.253 230.403C245.03 230.403 244.041 229.413 244.041 228.191V165.714C244.041 154.437 246.363 144.95 250.946 137.518C251.589 136.479 252.951 136.155 253.99 136.797C255.03 137.438 255.354 138.801 254.713 139.841C250.567 146.563 248.466 155.269 248.466 165.714V228.191C248.466 229.413 247.475 230.403 246.253 230.403Z\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.2\"}]\n9b:[\"$\",\"path\",null,{\"d\":\"M253.425 264.724C252.203 264.724 251.213 263.734 251.213 262.511V165.798C251.213 141.236 264.62 127.15 287.996 127.15C311.372 127.15 324.78 141.236 324.78 165.798V205.42C324.78 206.642 323.789 207.632 322.567 207.632C321.345 207.632 320.355 206.642 320.355 205.42V165.798C320.355 143.728 308.864 131.575 287.996 131.575C267.129 131.575 255.639 143.728 255.639 165.798V262.511C255.639 263.734 254.648 264.724 253.425 264.724Z\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.5\"}]\n9c:[\"$\",\"path\",null,{\"d\":\"M287.996 318.563C264.62 318.563 251.214 304.478 251.214 279.916C251.214 278.694 252.203 277.703 253.426 277.703C254.647 277.703 255.638 278.694 255.638 279.916C255.638 301.983 267.13 314.138 287.996 314.138C293.956 314.138 299.215 313.151 303.627 311.206C304.744 310.712 306.051 311.219 306.543 312.338C307.036 313.456 306.53 314.76 305.412 315.255C300.435 317.45 294.575 318.563 287.996 318.563Z\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.6\"}]\n9d:[\"$\",\"path\",null,{\"d\":\"M314.422 308.202C313.909 308.202 313.393 308.023 312.974 307.662C312.051 306.861 311.95 305.463 312.75 304.541C317.795 298.717 320.354 290.431 320.354 279.915V240.879C320.354 239.658 321.345 238.667 322.566 238.667C323.789 238.667 324.781 239.658 324.781 240.879V279.915C324.781 291.526 321.857 300.786 316.095 307.438C315.658 307.943 315.042 308.202 314.422 308.202Z\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.6\"}]\n9e:[\"$\",\"path\",null,{\"d\":\"M287.996 310.642C284.29 310.642 280.843 310.198 277.748 309.321C276.572 308.988 275.89 307.765 276.223 306.589C276.556 305.413 277.78 304.732 278.955 305.062C281.658 305.829 284.699 306.218 287.996 306.218C304.231 306.218 313.172 296.753 313.172 279.565V166.146C313.172 164.925 314.162 163.934 315.384 163.934C316.606 163.934 317.596 164.925 317.596 166.146V279.565C317.596 299.316 306.807 310.642 287.996 310.642Z\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.1\"}]\n9f:[\"$\",\"path\",null,{\"d\":\"M260.609 206.086C259.386 206.086 258.396 205.096 258.396 203.873V166.146C258.396 146.397 269.185 135.07 287.997 135.07C301.484 135.07 310.865 140.792 315.125 151.614C315.573 152.752 315.013 154.036 313.877 154.484C312.737 154.932 311.454 154.373 311.008 153.236C307.469 144.248 299.512 139.496 287.997 139.496C271.762 139.496 262.821 148.961 262.821 166.146V203.873C262.821 205.096 261.832 206.086 260.609 206.086Z\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.2\"}]\na0:[\"$\",\"path\",null,{\"d\":\"M268.332 303.78C267.776 303.78 267.222 303.572 266.791 303.154C261.222 297.746 258.396 289.808 258.396 279.566V213.376C258.396 212.155 259.387 211.164 260.61 211.164C261.831 211.164 262.822 212.155 262.822 213.376V279.566C262.822 288.567 265.194 295.435 269.874 299.98C270.751 300.832 270.771 302.232 269.919 303.11C269.486 303.555 268.91 303.78 268.332 303.78Z\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.1\"}]\na1:[\"$\",\"path\",null,{\"d\":\"M308.185 256.33C306.962 256.33 305.973 255.339 305.973 254.118V193.251C305.973 192.03 306.962 191.039 308.185 191.039C309.406 191.039 310.397 192.03 310.397 193.251V254.118C310.397 255.339 309.406 256.33 308.185 256.33Z\",\"fil"])</script><script>self.__next_f.push([1,"l\":\"var(--primary)\",\"fillOpacity\":\"0.2\"}]\na2:[\"$\",\"path\",null,{\"d\":\"M308.185 186.514C306.962 186.514 305.973 185.523 305.973 184.302V167.125C305.973 154.653 299.757 148.059 287.996 148.059C276.236 148.059 270.02 154.653 270.02 167.125C270.02 168.347 269.03 169.337 267.808 169.337C266.585 169.337 265.596 168.347 265.596 167.125C265.596 152.197 273.76 143.634 287.996 143.634C302.232 143.634 310.397 152.197 310.397 167.125V184.302C310.397 185.523 309.406 186.514 308.185 186.514Z\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.6\"}]\na3:[\"$\",\"path\",null,{\"d\":\"M267.807 248.211C266.585 248.211 265.595 247.22 265.595 245.997V180.777C265.595 179.555 266.585 178.564 267.807 178.564C269.03 178.564 270.021 179.555 270.021 180.777V245.997C270.021 247.22 269.03 248.211 267.807 248.211Z\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.4\"}]\na4:[\"$\",\"path\",null,{\"d\":\"M287.996 302.077C273.76 302.077 265.595 293.516 265.595 278.588V254.584C265.595 253.361 266.586 252.372 267.807 252.372C269.03 252.372 270.02 253.361 270.02 254.584V278.588C270.02 291.06 276.236 297.653 287.996 297.653C299.756 297.653 305.972 291.06 305.972 278.588V264.121C305.972 262.899 306.963 261.908 308.186 261.908C309.407 261.908 310.398 262.899 310.398 264.121V278.588C310.398 293.516 302.232 302.077 287.996 302.077Z\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.6\"}]\na5:[\"$\",\"path\",null,{\"d\":\"M287.996 156.826C280.907 156.826 277.311 160.655 277.311 168.206V277.934C277.311 285.485 280.907 289.313 287.996 289.313C295.086 289.313 298.682 285.485 298.682 277.934V168.206C298.682 160.655 295.086 156.826 287.996 156.826ZM287.996 293.739C278.535 293.739 272.886 287.83 272.886 277.934V168.206C272.886 158.309 278.535 152.401 287.996 152.401C297.458 152.401 303.106 158.309 303.106 168.206V277.934C303.106 287.83 297.458 293.739 287.996 293.739Z\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.5\"}]\na6:[\"$\",\"path\",null,{\"d\":\"M239.239 190.089C238.016 190.089 237.027 189.098 237.027 187.876V174.02C237.027 172.797 238.016 171.806 239.239 171.806C240.462 171.806 241.452 172.797 241.452 174.02V187.876C241.452 189.098 240.462 190.089 239.239 190.089Z\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.6\"}]\na7:[\"$\",\"path\",null,{\"d\":\"M336.754 273.339C335.532 273.339 334.542 272.348 334.542 271.127V256.355C334.542 255.132 335.532 254.143 336.754 254.143C337.976 254.143 338.966 255.132 338.966 256.355V271.127C338.966 272.348 337.976 273.339 336.754 273.339Z\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.2\"}]\na8:[\"$\",\"path\",null,{\"d\":\"M322.566 231.442C321.345 231.442 320.354 230.451 320.354 229.23V214.164C320.354 212.942 321.345 211.951 322.566 211.951C323.789 211.951 324.78 212.942 324.78 214.164V229.23C324.78 230.451 323.789 231.442 322.566 231.442Z\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.5\"}]\na9:[\"$\",\"path\",null,{\"d\":\"M439.175 275.994H387.248C386.027 275.994 385.036 275.003 385.036 273.782C385.036 272.559 386.027 271.57 387.248 271.57H439.175C440.397 271.57 441.387 272.559 441.387 273.782C441.387 275.003 440.397 275.994 439.175 275.994Z\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.5\"}]\naa:[\"$\",\"path\",null,{\"d\":\"M371.836 275.994C367.297 275.994 363.603 272.302 363.599 267.765L363.595 262.514C363.595 261.546 363.785 260.605 364.16 259.715L388.091 203.006C388.567 201.879 389.864 201.353 390.989 201.827C392.116 202.302 392.643 203.601 392.168 204.726L368.237 261.435C368.092 261.777 368.02 262.139 368.02 262.513L368.024 267.761C368.027 269.861 369.736 271.57 371.836 271.57C373.057 271.57 374.048 272.559 374.048 273.782C374.048 275.003 373.057 275.994 371.836 275.994Z\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.6\"}]\nab:[\"$\",\"path\",null,{\"d\":\"M427.348 231.442C426.127 231.442 425.136 230.452 425.136 229.231L425.072 138.55C425.071 137.232 424 136.163 422.684 136.163C421.723 136.164 420.859 136.736 420.484 137.623L396.648 194.112C396.172 195.238 394.875 195.764 393.748 195.29C392.623 194.815 392.096 193.518 392.569 192.391L416.407 135.902C417.475 133.374 419.936 131.739 422.679 131.738H422.684C426.437 131.738 429.495 134.791 429.497 138.546L429.56 229.227C429.561 230.45 428.572 231.442 427.349 231.442H427.348Z\",\"fill\":\"var(--primary)\",\"fillOp"])</script><script>self.__next_f.push([1,"acity\":\"0.5\"}]\nac:[\"$\",\"path\",null,{\"d\":\"M427.371 267.651C426.15 267.651 425.159 266.662 425.158 265.441L425.139 239.81C425.139 238.589 426.129 237.597 427.35 237.595H427.353C428.574 237.595 429.565 238.586 429.566 239.807L429.583 265.437C429.585 266.659 428.595 267.651 427.373 267.651H427.371Z\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.4\"}]\ne5:T422,M424.949 333.895C414.295 333.895 405.624 325.231 405.616 314.575L405.603 296.83L365.155 296.86H365.14C359.416 296.86 354.035 294.632 349.984 290.588C345.931 286.54 343.696 281.155 343.692 275.427V264.698C343.692 263.475 344.683 262.484 345.904 262.484C347.127 262.484 348.116 263.475 348.116 264.698V275.424C348.12 279.971 349.893 284.244 353.111 287.456C356.325 290.667 360.597 292.434 365.14 292.434H365.152L407.811 292.404C409.032 292.404 410.025 293.394 410.027 294.615L410.04 314.571C410.047 322.788 416.735 329.47 424.949 329.471H424.96L430.212 329.467C438.433 329.46 445.117 322.767 445.112 314.546L445.096 294.59C445.096 294.003 445.329 293.439 445.745 293.024C446.157 292.608 446.721 292.375 447.308 292.375L451.049 292.372C456.139 292.368 460.275 288.226 460.271 283.139L460.256 263.547C460.255 262.324 461.245 261.334 462.468 261.332C463.689 261.332 464.68 262.322 464.681 263.543L464.696 283.135C464.7 290.663 458.581 296.792 451.053 296.798L449.524 296.799L449.536 314.543C449.544 325.203 440.877 333.883 430.216 333.891L424.964 333.895H424.949Zad:[\"$\",\"path\",null,{\"d\":\"$e5\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.6\"}]\nae:[\"$\",\"path\",null,{\"d\":\"M447.279 251.431C446.058 251.431 445.067 250.441 445.067 249.218V225.869C445.067 224.647 446.058 223.655 447.279 223.655C448.502 223.655 449.492 224.647 449.492 225.869V249.218C449.492 250.441 448.502 251.431 447.279 251.431Z\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.4\"}]\naf:[\"$\",\"path\",null,{\"d\":\"M447.261 211.942C446.041 211.942 445.05 210.952 445.049 209.731L444.986 141.222C444.986 140 445.975 139.01 447.197 139.008H447.199C448.419 139.008 449.41 139.998 449.411 141.219L449.474 209.727C449.474 210.948 448.485 211.94 447.263 211.942H447.261Z\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.4\"}]\nb0:[\"$\",\"path\",null,{\"d\":\"M365.021 214.358C364.735 214.358 364.443 214.302 364.163 214.184C363.037 213.709 362.509 212.412 362.984 211.285L402.667 117.242C404.053 113.96 407.253 111.836 410.816 111.833L440.541 111.812H440.548C442.909 111.812 445.129 112.73 446.801 114.4C448.473 116.07 449.395 118.292 449.397 120.656V132.725C449.397 133.946 448.407 134.937 447.184 134.937C445.963 134.937 444.972 133.946 444.972 132.725V120.657C444.971 119.477 444.511 118.366 443.673 117.53C442.837 116.696 441.727 116.237 440.548 116.237H440.545L410.82 116.258C409.037 116.26 407.437 117.321 406.745 118.964L367.061 213.005C366.705 213.85 365.884 214.358 365.021 214.358Z\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.5\"}]\nb1:[\"$\",\"path\",null,{\"d\":\"M349.378 251.431C349.09 251.431 348.799 251.375 348.518 251.257C347.392 250.782 346.864 249.485 347.34 248.358L358.464 221.993C358.94 220.867 360.239 220.338 361.363 220.814C362.49 221.29 363.016 222.587 362.543 223.713L351.416 250.079C351.06 250.923 350.239 251.431 349.378 251.431Z\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.4\"}]\nb2:[\"$\",\"path\",null,{\"d\":\"M433.964 201.474C432.742 201.474 431.752 200.485 431.752 199.264L431.725 163.086C431.725 161.864 432.714 160.873 433.936 160.872H433.938C435.158 160.872 436.15 161.862 436.152 163.084L436.176 199.26C436.177 200.482 435.188 201.474 433.965 201.474H433.964Z\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.5\"}]\ne6:T87e,"])</script><script>self.__next_f.push([1,"M427.573 320.618C425.256 320.618 423.076 319.716 421.436 318.079C419.794 316.439 418.889 314.258 418.889 311.938L418.872 287.971C418.869 285.532 416.884 283.548 414.445 283.548H414.442L371.489 283.579H371.478C367.604 283.579 363.962 282.072 361.22 279.336C358.477 276.595 356.965 272.951 356.962 269.074L356.956 260.166C356.956 259.868 357.014 259.576 357.129 259.303L413.188 126.458C413.534 125.639 414.337 125.106 415.225 125.106L428.601 125.096H428.608C430.614 125.096 432.502 125.876 433.924 127.295C435.345 128.715 436.129 130.603 436.13 132.614L436.141 147.984C436.142 149.207 435.153 150.199 433.932 150.199H433.929C432.708 150.199 431.717 149.21 431.716 147.988L431.705 132.616C431.705 131.788 431.381 131.011 430.797 130.426C430.212 129.842 429.434 129.522 428.608 129.522H428.605L416.696 129.53L361.38 260.611L361.386 269.071C361.389 271.767 362.44 274.3 364.348 276.204C366.253 278.107 368.784 279.155 371.478 279.155H371.486L414.438 279.123H414.446C419.324 279.123 423.292 283.09 423.297 287.967L423.314 311.935C423.316 313.074 423.758 314.144 424.564 314.947C425.368 315.751 426.436 316.194 427.573 316.194H427.577C428.714 316.192 429.785 315.748 430.59 314.943C431.393 314.138 431.834 313.068 431.833 311.93L431.818 287.962C431.816 285.598 432.733 283.374 434.404 281.702C436.074 280.028 438.297 279.107 440.66 279.104L443.92 279.103C445.613 279.102 446.99 277.722 446.99 276.027L446.986 270.678C446.986 269.856 446.665 269.086 446.085 268.506C445.505 267.926 444.734 267.607 443.914 267.607H443.912L440.653 267.61H440.646C435.768 267.61 431.8 263.643 431.796 258.766L431.76 207.86C431.758 206.638 432.748 205.647 433.969 205.646H433.972C435.193 205.646 436.182 206.635 436.184 207.856L436.221 258.762C436.222 261.2 438.209 263.184 440.648 263.184H440.65L443.908 263.182H443.914C445.914 263.182 447.796 263.96 449.212 265.374C450.629 266.79 451.41 268.672 451.412 270.675L451.416 276.024C451.418 280.158 448.056 283.524 443.922 283.528L440.664 283.53C439.482 283.531 438.372 283.992 437.536 284.828C436.701 285.664 436.241 286.776 436.242 287.958L436.26 311.926C436.262 314.247 435.36 316.427 433.72 318.07C432.081 319.711 429.9 320.616 427.58 320.618H427.573Z"])</script><script>self.__next_f.push([1,"b3:[\"$\",\"path\",null,{\"d\":\"$e6\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.2\"}]\nb4:[\"$\",\"path\",null,{\"d\":\"M382.017 267.651C379.045 267.651 376.29 266.174 374.646 263.699C373 261.222 372.708 258.107 373.861 255.366L406.213 178.557C406.688 177.43 407.982 176.902 409.11 177.375C410.237 177.85 410.766 179.149 410.29 180.274L377.938 257.083C377.362 258.454 377.508 260.011 378.33 261.25C379.154 262.487 380.532 263.226 382.017 263.226H382.02L404.946 263.21C406.168 263.21 407.16 264.199 407.16 265.421C407.161 266.643 406.172 267.634 404.949 267.635L382.024 267.651H382.017Z\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.2\"}]\nb5:[\"$\",\"path\",null,{\"d\":\"M414.43 267.628C413.209 267.628 412.219 266.639 412.218 265.417C412.217 264.195 413.206 263.204 414.429 263.203C416.869 263.201 418.851 261.215 418.85 258.775L418.794 154.615C418.793 153.392 419.785 152.401 421.007 152.401C422.229 152.401 423.219 153.391 423.221 154.612L423.275 258.772C423.279 263.652 419.311 267.625 414.433 267.628H414.43Z\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.6\"}]\ne7:T6a4,"])</script><script>self.__next_f.push([1,"M426.335 327.257C422.576 327.257 419.043 325.794 416.383 323.14C413.721 320.481 412.255 316.946 412.252 313.185L412.237 293.594C412.237 291.716 410.707 290.186 408.828 290.186H404.195C402.972 290.186 401.98 289.196 401.98 287.974C401.98 286.752 402.972 285.761 404.195 285.761H408.828C413.145 285.761 416.66 289.274 416.663 293.592L416.677 313.181C416.681 318.505 421.012 322.833 426.335 322.833H426.34L428.823 322.83C434.147 322.826 438.476 318.492 438.473 313.166L438.457 291.925C438.457 290.274 439.097 288.721 440.264 287.553C441.431 286.385 442.983 285.741 444.635 285.74L448.372 285.737C449.779 285.736 451.099 285.188 452.092 284.193C453.084 283.2 453.632 281.877 453.631 280.472L453.621 266.223C453.619 263.323 451.257 260.966 448.359 260.966H448.356L440.647 260.971H440.645C440.06 260.971 439.497 260.738 439.083 260.325C438.668 259.91 438.433 259.347 438.433 258.761L438.339 127.017C438.337 125.91 437.907 124.871 437.124 124.09C436.343 123.31 435.304 122.879 434.197 122.879H434.196L412.291 122.896L405.267 139.54C404.792 140.666 403.492 141.193 402.368 140.717C401.243 140.242 400.715 138.945 401.189 137.818L408.783 119.824C409.129 119.005 409.931 118.473 410.82 118.471L434.192 118.454H434.197C436.483 118.454 438.633 119.343 440.252 120.958C441.869 122.575 442.761 124.726 442.763 127.014L442.857 256.545L448.352 256.541H448.36C453.696 256.541 458.041 260.881 458.045 266.221L458.056 280.468C458.057 283.056 457.052 285.489 455.224 287.32C453.396 289.152 450.964 290.161 448.376 290.162L444.637 290.165C444.168 290.166 443.727 290.348 443.396 290.68C443.064 291.01 442.883 291.452 442.883 291.921L442.899 313.162C442.904 320.928 436.591 327.249 428.825 327.256L426.344 327.257H426.335Z"])</script><script>self.__next_f.push([1,"b6:[\"$\",\"path\",null,{\"d\":\"$e7\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.1\"}]\nb7:[\"$\",\"path\",null,{\"d\":\"M392.089 167.287C391.802 167.287 391.51 167.231 391.229 167.113C390.103 166.638 389.577 165.341 390.051 164.214L397.618 146.278C398.095 145.153 399.393 144.625 400.518 145.101C401.645 145.575 402.171 146.873 401.697 147.999L394.127 165.935C393.771 166.779 392.95 167.287 392.089 167.287Z\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.6\"}]\nb8:[\"$\",\"path\",null,{\"d\":\"M354.94 255.321C354.652 255.321 354.362 255.265 354.08 255.147C352.955 254.672 352.427 253.375 352.903 252.248L386.799 171.921C387.275 170.795 388.574 170.267 389.696 170.743C390.823 171.217 391.351 172.516 390.876 173.641L356.979 253.968C356.623 254.813 355.802 255.321 354.94 255.321Z\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.6\"}]\nb9:[\"$\",\"path\",null,{\"d\":\"M369.267 290.219C364.212 290.219 359.46 288.252 355.883 284.68C352.303 281.106 350.33 276.351 350.327 271.291L350.319 265.775C350.316 264.552 351.306 263.56 352.527 263.559H352.531C353.751 263.559 354.742 264.548 354.743 265.77L354.751 271.287C354.754 275.166 356.267 278.81 359.01 281.55C361.751 284.287 365.394 285.794 369.267 285.794H369.278L392.016 285.778C393.238 285.778 394.231 286.767 394.231 287.988C394.232 289.21 393.242 290.202 392.02 290.202L369.28 290.219H369.267Z\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.5\"}]\nba:[\"$\",\"path\",null,{\"d\":\"M412.164 192.926L385.51 256.21C385.495 256.243 385.454 256.345 385.532 256.465C385.614 256.586 385.703 256.569 385.758 256.586L409.762 256.569C410.415 256.567 411.031 256.313 411.492 255.85C411.955 255.387 412.208 254.771 412.208 254.118L412.164 192.926ZM385.756 261.01C384.182 261.01 382.72 260.227 381.848 258.914C380.974 257.601 380.819 255.947 381.431 254.493L411.074 184.119C411.61 182.847 412.927 182.149 414.283 182.421C415.636 182.694 416.583 183.849 416.584 185.23L416.635 254.114C416.635 255.95 415.92 257.677 414.624 258.977C413.327 260.277 411.6 260.991 409.764 260.993L385.762 261.01H385.756Z\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.1\"}]\nbb:[\"$\",\"path\",null,{\"d\":\"M427.391 304.788C426.169 304.788 425.179 303.8 425.179 302.579L425.157 282.104C425.156 280.883 426.145 279.891 427.367 279.889H427.369C428.591 279.889 429.583 280.879 429.583 282.1L429.603 302.573C429.604 303.796 428.615 304.788 427.393 304.788H427.391Z\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.4\"}]\nbc:[\"$\",\"path\",null,{\"d\":\"M449.444 218.057C449.444 219.274 448.458 220.26 447.242 220.26C446.024 220.26 445.038 219.274 445.038 218.057C445.038 216.84 446.024 215.854 447.242 215.854C448.458 215.854 449.444 216.84 449.444 218.057Z\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.4\"}]\nbd:[\"$\",\"path\",null,{\"d\":\"M464.686 254.584C464.686 255.802 463.7 256.787 462.484 256.787C461.266 256.787 460.28 255.802 460.28 254.584C460.28 253.367 461.266 252.382 462.484 252.382C463.7 252.382 464.686 253.367 464.686 254.584Z\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.6\"}]\nbe:[\"$\",\"path\",null,{\"d\":\"M429.583 310.633C429.583 311.849 428.598 312.836 427.381 312.836C426.165 312.836 425.177 311.849 425.177 310.633C425.177 309.416 426.165 308.429 427.381 308.429C428.598 308.429 429.583 309.416 429.583 310.633Z\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.4\"}]\nbf:[\"$\",\"path\",null,{\"d\":\"M381.348 273.782C381.348 274.999 380.361 275.984 379.145 275.984C377.928 275.984 376.941 274.999 376.941 273.782C376.941 272.564 377.928 271.579 379.145 271.579C380.361 271.579 381.348 272.564 381.348 273.782Z\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.6\"}]\nc0:[\"$\",\"path\",null,{\"d\":\"M354.94 259.998C354.94 261.215 353.955 262.2 352.738 262.2C351.522 262.2 350.534 261.215 350.534 259.998C350.534 258.78 351.522 257.795 352.738 257.795C353.955 257.795 354.94 258.78 354.94 259.998Z\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.5\"}]\nc1:[\"$\",\"path\",null,{\"d\":\"M414.501 170.579C414.501 171.796 413.515 172.781 412.299 172.781C411.081 172.781 410.095 171.796 410.095 170.579C410.095 169.361 411.081 168.376 412.299 168.376C413.515 168.376 414.501 169.361 414.501 170.579Z\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.2\"}]\nc2:[\"$\",\"path\",null,{\"d\":\"M436.333 154.613C436.333 155.83 435.348 "])</script><script>self.__next_f.push([1,"156.816 434.131 156.816C432.915 156.816 431.927 155.83 431.927 154.613C431.927 153.396 432.915 152.41 434.131 152.41C435.348 152.41 436.333 153.396 436.333 154.613Z\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.5\"}]\nc3:[\"$\",\"path\",null,{\"d\":\"M465.702 242.975C465.135 242.975 464.57 242.759 464.138 242.327L457.701 235.89C456.837 235.026 456.837 233.624 457.701 232.76C458.565 231.896 459.965 231.896 460.83 232.76L467.266 239.198C468.13 240.062 468.13 241.463 467.266 242.327C466.835 242.759 466.269 242.975 465.702 242.975Z\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.5\"}]\nc4:[\"$\",\"path\",null,{\"d\":\"M459.264 242.975C458.699 242.975 458.132 242.759 457.7 242.327C456.836 241.463 456.836 240.062 457.7 239.198L464.138 232.76C465.002 231.896 466.403 231.896 467.266 232.76C468.13 233.624 468.13 235.026 467.266 235.89L460.83 242.327C460.398 242.759 459.831 242.975 459.264 242.975Z\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.5\"}]\nc5:[\"$\",\"path\",null,{\"d\":\"M454.735 348.767C454.735 350.601 453.249 352.086 451.416 352.086C449.583 352.086 448.096 350.601 448.096 348.767C448.096 346.934 449.583 345.449 451.416 345.449C453.249 345.449 454.735 346.934 454.735 348.767Z\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.5\"}]\nc6:[\"$\",\"path\",null,{\"d\":\"M87.1143 158.144C87.1143 159.977 85.6276 161.464 83.7956 161.464C81.9623 161.464 80.4756 159.977 80.4756 158.144C80.4756 156.31 81.9623 154.825 83.7956 154.825C85.6276 154.825 87.1143 156.31 87.1143 158.144Z\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.5\"}]\nc7:[\"$\",\"path\",null,{\"d\":\"M13.6924 375.948C13.6924 377.782 12.207 379.267 10.3737 379.267C8.54038 379.267 7.05371 377.782 7.05371 375.948C7.05371 374.115 8.54038 372.63 10.3737 372.63C12.207 372.63 13.6924 374.115 13.6924 375.948Z\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.4\"}]\nc8:[\"$\",\"path\",null,{\"d\":\"M532.978 14.2342C532.978 16.0675 531.493 17.5528 529.659 17.5528C527.826 17.5528 526.339 16.0675 526.339 14.2342C526.339 12.4008 527.826 10.9142 529.659 10.9142C531.493 10.9142 532.978 12.4008 532.978 14.2342Z\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.4\"}]\nc9:[\"$\",\"path\",null,{\"d\":\"M244.041 472.295C244.041 474.128 242.555 475.613 240.722 475.613C238.889 475.613 237.402 474.128 237.402 472.295C237.402 470.461 238.889 468.976 240.722 468.976C242.555 468.976 244.041 470.461 244.041 472.295Z\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.4\"}]\nca:[\"$\",\"path\",null,{\"d\":\"M160.742 82.4873L162.367 80.862C163.216 80.0127 163.216 78.6353 162.367 77.7873C161.519 76.938 160.142 76.938 159.292 77.7873L157.667 79.4127L156.042 77.7873C155.192 76.938 153.815 76.938 152.967 77.7873C152.118 78.6353 152.118 80.0127 152.967 80.862L154.592 82.4873L152.967 84.1127C152.118 84.962 152.118 86.3393 152.967 87.1873C153.391 87.6127 153.947 87.8247 154.504 87.8247C155.06 87.8247 155.618 87.6127 156.042 87.1873L157.667 85.562L159.292 87.1873C159.716 87.6127 160.274 87.8247 160.83 87.8247C161.386 87.8247 161.943 87.6127 162.367 87.1873C163.216 86.3393 163.216 84.962 162.367 84.1127L160.742 82.4873Z\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.2\"}]\ncb:[\"$\",\"path\",null,{\"d\":\"M582.051 301.921L584.395 299.577C585.619 298.353 585.619 296.369 584.395 295.145C583.169 293.921 581.187 293.921 579.963 295.145L577.619 297.489L575.275 295.145C574.051 293.921 572.068 293.921 570.843 295.145C569.619 296.369 569.619 298.353 570.843 299.577L573.187 301.921L570.843 304.265C569.619 305.489 569.619 307.472 570.843 308.697C571.455 309.309 572.256 309.616 573.059 309.616C573.86 309.616 574.663 309.309 575.275 308.697L577.619 306.353L579.963 308.697C580.575 309.309 581.376 309.616 582.179 309.616C582.98 309.616 583.783 309.309 584.395 308.697C585.619 307.472 585.619 305.489 584.395 304.265L582.051 301.921Z\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.1\"}]\ncc:[\"$\",\"path\",null,{\"d\":\"M259.209 8.21385L261.701 5.72185C263.003 4.42051 263.003 2.30985 261.701 1.00852C260.401 -0.294151 258.289 -0.294151 256.987 1.00852L254.495 3.50052L252.003 1.00852C250.702 -0.294151 248.59 -0.294151 247.29 1.00852C245.987 2.30985 245.987 4.42051 247.29 5.72185L249.782 8.21385L247.29 10.7058C245.987 12.0072 245.987 14.1178 247.29 15.4192C247.939 16.0712 "])</script><script>self.__next_f.push([1,"248.793 16.3965 249.646 16.3965C250.499 16.3965 251.353 16.0712 252.003 15.4192L254.495 12.9272L256.987 15.4192C257.638 16.0712 258.491 16.3965 259.345 16.3965C260.198 16.3965 261.05 16.0712 261.701 15.4192C263.003 14.1178 263.003 12.0072 261.701 10.7058L259.209 8.21385Z\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.1\"}]\ncd:[\"$\",\"path\",null,{\"d\":\"M112.432 413.007L114.416 411.023C115.453 409.985 115.453 408.307 114.416 407.268C113.38 406.232 111.699 406.232 110.663 407.268L108.679 409.253L106.693 407.268C105.657 406.232 103.976 406.232 102.94 407.268C101.904 408.307 101.904 409.985 102.94 411.023L104.925 413.007L102.94 414.991C101.904 416.028 101.904 417.707 102.94 418.745C103.459 419.263 104.137 419.523 104.817 419.523C105.496 419.523 106.176 419.263 106.693 418.745L108.679 416.76L110.663 418.745C111.181 419.263 111.86 419.523 112.54 419.523C113.219 419.523 113.899 419.263 114.416 418.745C115.453 417.707 115.453 416.028 114.416 414.991L112.432 413.007Z\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.5\"}]\nce:[\"$\",\"path\",null,{\"d\":\"M148.308 477.631L149.933 476.005C150.783 475.157 150.783 473.779 149.933 472.931C149.084 472.082 147.708 472.082 146.859 472.931L145.233 474.555L143.608 472.931C142.759 472.082 141.383 472.082 140.533 472.931C139.684 473.779 139.684 475.157 140.533 476.005L142.159 477.631L140.533 479.257C139.684 480.106 139.684 481.482 140.533 482.331C140.957 482.757 141.513 482.969 142.071 482.969C142.627 482.969 143.183 482.757 143.608 482.331L145.233 480.706L146.859 482.331C147.283 482.757 147.84 482.969 148.396 482.969C148.952 482.969 149.508 482.757 149.933 482.331C150.783 481.482 150.783 480.106 149.933 479.257L148.308 477.631Z\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.6\"}]\ncf:[\"$\",\"path\",null,{\"d\":\"M506.861 412.675L509.353 410.183C510.656 408.88 510.656 406.771 509.353 405.469C508.052 404.167 505.942 404.167 504.64 405.469L502.148 407.961L499.656 405.469C498.353 404.167 496.244 404.167 494.942 405.469C493.64 406.771 493.64 408.88 494.942 410.183L497.434 412.675L494.942 415.167C493.64 416.469 493.64 418.579 494.942 419.88C495.593 420.532 496.445 420.857 497.298 420.857C498.152 420.857 499.004 420.532 499.656 419.88L502.148 417.388L504.64 419.88C505.29 420.532 506.144 420.857 506.997 420.857C507.849 420.857 508.702 420.532 509.353 419.88C510.656 418.579 510.656 416.469 509.353 415.167L506.861 412.675Z\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.2\"}]\nd0:[\"$\",\"path\",null,{\"d\":\"M220.265 375.948L222.757 373.456C224.06 372.155 224.06 370.044 222.759 368.743C221.456 367.44 219.345 367.44 218.044 368.743L215.551 371.236L213.059 368.743C211.757 367.44 209.647 367.44 208.345 368.743C207.043 370.044 207.043 372.155 208.345 373.456L210.837 375.948L208.345 378.44C207.043 379.741 207.043 381.852 208.345 383.153C208.996 383.805 209.849 384.131 210.703 384.131C211.555 384.131 212.408 383.805 213.059 383.153L215.551 380.661L218.044 383.153C218.695 383.805 219.548 384.131 220.401 384.131C221.253 384.131 222.107 383.805 222.759 383.153C224.06 381.852 224.06 379.741 222.757 378.44L220.265 375.948Z\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.4\"}]\nd1:[\"$\",\"path\",null,{\"d\":\"M67.4747 305.565C65.6161 305.565 64.1054 307.077 64.1054 308.935C64.1054 310.793 65.6161 312.305 67.4747 312.305C69.3334 312.305 70.8441 310.793 70.8441 308.935C70.8441 307.077 69.3334 305.565 67.4747 305.565ZM67.4747 317.932C62.5134 317.932 58.4761 313.896 58.4761 308.935C58.4761 303.975 62.5134 299.936 67.4747 299.936C72.4361 299.936 76.4734 303.975 76.4734 308.935C76.4734 313.896 72.4361 317.932 67.4747 317.932Z\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.6\"}]\nd2:[\"$\",\"path\",null,{\"d\":\"M11.7073 191.394C11.7073 194.437 9.24059 196.904 6.19792 196.904C3.15392 196.904 0.687256 194.437 0.687256 191.394C0.687256 188.352 3.15392 185.885 6.19792 185.885C9.24059 185.885 11.7073 188.352 11.7073 191.394Z\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.2\"}]\nd3:[\"$\",\"path\",null,{\"d\":\"M565.722 101.94C565.722 104.983 563.254 107.45 560.211 107.45C557.168 107.45 554.7 104.983 554.7 101.94C554.7 98.8977 557.168 96.4311 560.211 96.4311C563.254 96.4311 565.722 98.8977 565.722 101.94Z\",\"fill\":\"va"])</script><script>self.__next_f.push([1,"r(--primary)\",\"fillOpacity\":\"0.6\"}]\nd4:[\"$\",\"path\",null,{\"d\":\"M392.343 463.466C392.343 466.509 389.877 468.976 386.833 468.976C383.79 468.976 381.323 466.509 381.323 463.466C381.323 460.424 383.79 457.956 386.833 457.956C389.877 457.956 392.343 460.424 392.343 463.466Z\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.1\"}]\nd5:[\"$\",\"path\",null,{\"d\":\"M60.6096 410.003C60.6096 413.046 58.1429 415.514 55.1003 415.514C52.0563 415.514 49.5896 413.046 49.5896 410.003C49.5896 406.961 52.0563 404.493 55.1003 404.493C58.1429 404.493 60.6096 406.961 60.6096 410.003Z\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.6\"}]\nd6:[\"$\",\"path\",null,{\"d\":\"M372.275 57.6508C370.58 57.6508 369.199 59.0295 369.199 60.7255C369.199 62.4215 370.58 63.8015 372.275 63.8015C373.97 63.8015 375.351 62.4215 375.351 60.7255C375.351 59.0295 373.97 57.6508 372.275 57.6508ZM372.275 68.9375C367.747 68.9375 364.063 65.2535 364.063 60.7255C364.063 56.1975 367.747 52.5135 372.275 52.5135C376.803 52.5135 380.487 56.1975 380.487 60.7255C380.487 65.2535 376.803 68.9375 372.275 68.9375Z\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.4\"}]\nd7:[\"$\",\"path\",null,{\"d\":\"M522.195 198.33C520.461 198.33 519.051 199.74 519.051 201.474C519.051 203.208 520.461 204.619 522.195 204.619C523.929 204.619 525.338 203.208 525.338 201.474C525.338 199.74 523.929 198.33 522.195 198.33ZM522.195 209.871C517.565 209.871 513.798 206.104 513.798 201.474C513.798 196.844 517.565 193.078 522.195 193.078C526.825 193.078 530.591 196.844 530.591 201.474C530.591 206.104 526.825 209.871 522.195 209.871Z\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.2\"}]\nd8:[\"$\",\"path\",null,{\"d\":\"M316.992 362.107C315.405 362.107 314.113 363.399 314.113 364.986C314.113 366.574 315.405 367.864 316.992 367.864C318.579 367.864 319.871 366.574 319.871 364.986C319.871 363.399 318.579 362.107 316.992 362.107ZM316.992 372.672C312.753 372.672 309.305 369.224 309.305 364.986C309.305 360.747 312.753 357.3 316.992 357.3C321.231 357.3 324.679 360.747 324.679 364.986C324.679 369.224 321.231 372.672 316.992 372.672Z\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.1\"}]\nd9:[\"$\",\"path\",null,{\"d\":\"M38.2497 22.9105C36.6551 22.9105 35.3564 24.2079 35.3564 25.8039C35.3564 27.3985 36.6551 28.6959 38.2497 28.6959C39.8444 28.6959 41.1431 27.3985 41.1431 25.8039C41.1431 24.2079 39.8444 22.9105 38.2497 22.9105ZM38.2497 33.5292C33.9897 33.5292 30.5244 30.0639 30.5244 25.8039C30.5244 21.5439 33.9897 18.0772 38.2497 18.0772C42.5097 18.0772 45.9751 21.5439 45.9751 25.8039C45.9751 30.0639 42.5097 33.5292 38.2497 33.5292Z\",\"fill\":\"var(--primary)\",\"fillOpacity\":\"0.5\"}]\nda:[\"$\",\"div\",null,{\"className\":\"flex flex-col items-center gap-4 text-center\",\"children\":[[\"$\",\"p\",null,{\"className\":\"text-muted-foreground text-xl sm:text-2xl\",\"children\":\"We couldn't find the page you are looking for\"}],[\"$\",\"$L73\",null,{\"href\":\"/\",\"children\":\"Go back to home\",\"data-slot\":\"button\",\"data-variant\":\"default\",\"data-size\":\"default\",\"className\":\"focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive inline-flex shrink-0 items-center justify-center gap-2 text-sm font-medium whitespace-nowrap transition-all outline-none focus-visible:ring-[3px] disabled:pointer-events-none disabled:opacity-50 [\u0026_svg]:pointer-events-none [\u0026_svg]:shrink-0 [\u0026_svg:not([class*='size-'])]:size-4 bg-primary text-primary-foreground hover:bg-primary/90 h-9 px-4 py-2 has-[\u003esvg]:px-3 rounded-full\",\"ref\":null}]]}]\ndb:[\"$\",\"$Le8\",null,{}]\n"])</script><script>self.__next_f.push([1,"e9:I[99897,[\"/_next/static/chunks/4eaa70fe861e9598.js\",\"/_next/static/chunks/fa1a8f8830b9bf3a.js\",\"/_next/static/chunks/6dd6809ee42e252f.js\",\"/_next/static/chunks/f2b800ca7ae14e96.js\",\"/_next/static/chunks/e121db38c98deeb4.js\",\"/_next/static/chunks/6d971f5a9c16d0c2.js\",\"/_next/static/chunks/b397c2fd2abb1207.js\",\"/_next/static/chunks/11dff99839ab5ba0.js\"],\"MotionPreset\"]\nea:I[85437,[\"/_next/static/chunks/4eaa70fe861e9598.js\",\"/_next/static/chunks/fa1a8f8830b9bf3a.js\",\"/_next/static/chunks/6dd6809ee42e252f.js\",\"/_next/static/chunks/f2b800ca7ae14e96.js\",\"/_next/static/chunks/e121db38c98deeb4.js\",\"/_next/static/chunks/6d971f5a9c16d0c2.js\",\"/_next/static/chunks/b397c2fd2abb1207.js\",\"/_next/static/chunks/11dff99839ab5ba0.js\"],\"Image\"]\neb:I[48347,[\"/_next/static/chunks/4eaa70fe861e9598.js\",\"/_next/static/chunks/fa1a8f8830b9bf3a.js\",\"/_next/static/chunks/6dd6809ee42e252f.js\",\"/_next/static/chunks/f2b800ca7ae14e96.js\",\"/_next/static/chunks/e121db38c98deeb4.js\",\"/_next/static/chunks/6d971f5a9c16d0c2.js\",\"/_next/static/chunks/b397c2fd2abb1207.js\",\"/_next/static/chunks/11dff99839ab5ba0.js\"],\"default\"]\nec:I[72436,[\"/_next/static/chunks/4eaa70fe861e9598.js\",\"/_next/static/chunks/fa1a8f8830b9bf3a.js\",\"/_next/static/chunks/6dd6809ee42e252f.js\",\"/_next/static/chunks/f2b800ca7ae14e96.js\",\"/_next/static/chunks/e121db38c98deeb4.js\",\"/_next/static/chunks/6d971f5a9c16d0c2.js\",\"/_next/static/chunks/b397c2fd2abb1207.js\",\"/_next/static/chunks/11dff99839ab5ba0.js\"],\"Separator\"]\ned:T4caa6,"])</script><script>self.__next_f.push([1,"\u003c!doctype html\u003e\u003cdiv class=\"lake-content\" typography=\"classic\"\u003e\u003cdiv class=\"ne-quote\"\u003e\u003cul class=\"ne-ul\"\u003e\u003cli id=\"78c70b8dd6e7969e68cc2270cf0b875c\"\u003e\u003cspan class=\"ne-text\"\u003e本文转载自：\u003c/span\u003e\u003ca href=\"https://www.cnblogs.com/cxuanBlog/p/13297199.html\" data-href=\"https://www.cnblogs.com/cxuanBlog/p/13297199.html\" target=\"_blank\" class=\"ne-link\"\u003e\u003cspan class=\"ne-text\"\u003e5万字、97 张图总结操作系统核心知识点 - 程序员cxuan - 博客园\u003c/span\u003e\u003c/a\u003e\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e\u003cdiv class=\"ne-quote\"\u003e\u003cul class=\"ne-ul\"\u003e\u003cli id=\"f1f3650356a7da2355a3c9411b72ce03\"\u003e\u003cspan class=\"ne-text\"\u003e部分内容自行添加\u003c/span\u003e\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e\u003cp id=\"e09cae7512bb1e7e65e0b987a5ca3c8a\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"931bb607447da06d6f3bed0cd017ed4c\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e这不是一篇教你如何创建一个操作系统的文章，相反，这是一篇指导性文章，教你从几个方面来理解操作系统。首先你需要知道你为什么要看这篇文章以及为什么要学习操作系统。\u003c/span\u003e\u003c/p\u003e\u003ch2 id=\"61749910\"\u003e\u003cspan class=\"ne-text\"\u003e搞清楚几个问题\u003c/span\u003e\u003c/h2\u003e\u003cp id=\"cd8943ed3bdff3713c416af18dcb5bc9\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"25252fec79848d7bbc0a038fde638496\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e首先你要搞明白你学习操作系统的目的是什么？操作系统的重要性如何？学习操作系统会给我带来什么？下面我会从这几个方面为你回答下。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"8b7d10816f8e53284531845daf551ca3\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"e6f1da87c780159f3f7de45053402efa\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e操作系统也是一种软件，但是操作系统是一种非常复杂的软件。操作系统提供了几种抽象模型\u003c/span\u003e\u003c/p\u003e\u003cp id=\"8c1a07ee6be4f495dd752ea6d4f3b020\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cul class=\"ne-ul\"\u003e\u003cli id=\"217f42e4058efed81e8bad4607e4acfd\"\u003e\u003cspan class=\"ne-text\"\u003e文件：对 I/O 设备的抽象\u003c/span\u003e\u003c/li\u003e\u003cli id=\"22715eb1c834fc55bf11ecf2484d0865\"\u003e\u003cspan class=\"ne-text\"\u003e虚拟内存：对程序存储器的抽象\u003c/span\u003e\u003c/li\u003e\u003c/ul\u003e\u003cul class=\"ne-ul\"\u003e\u003cli id=\"205178dc0bcb920fd8c85c7c3b010b77\"\u003e\u003cspan class=\"ne-text\"\u003e进程：对一个正在运行程序的抽象\u003c/span\u003e\u003c/li\u003e\u003cli id=\"d622cbce3a4c328a2322c48ec279ab56\"\u003e\u003cspan class=\"ne-text\"\u003e虚拟机：对整个操作系统的抽象\u003c/span\u003e\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"657df5130cb382aef2c3c6c91108272c\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"e59e93c8b78c17b38240227d505e21cc\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e这些抽象和我们的日常开发息息相关。搞清楚了操作系统是如何抽象的，才能培养我们的抽象性思维和开发思路。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"49e331b04cc221ab606f3858c8793691\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"a96f950d10e2e4820afcebed6cf4e11a\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e很多问题都和操作系统相关，操作系统是解决这些问题的基础。如果你不学习操作系统，可能会想着从框架层面来解决，那是你了解的还不够深入，当你学习了操作系统后，能够培养你的全局性思维。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"ce485e2ee746cb7a676b02e43c98539b\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"ec2f957b8d14b5f67e2d5112d8c194f2\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e学习操作系统我们能够有效的解决\u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e并发\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e问题，并发几乎是互联网的重中之重了，这也从侧面说明了学习操作系统的重要性。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"b149befad325016fc7e10b44f43be20d\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"30f71f05e85cb30d12e23064ca8a482b\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e学习操作系统的重点不是让你从头制造一个操作系统，而是告诉你\u003c/span\u003e\u003cstrong\u003e\u003cspan class=\"ne-text\"\u003e操作系统是如何工作的\u003c/span\u003e\u003c/strong\u003e\u003cspan class=\"ne-text\"\u003e，能够让你对计算机底层有所了解，打实你的基础。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"08806088071147ea10f99421320d32a2\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"58b941ab309d9181cde3a97a32dc6d0f\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e相信你一定清楚什么是编程\u003c/span\u003e\u003c/p\u003e\u003cp id=\"f44e3319e6f321d74f1c7f6d708cc27b\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"ce7a48bbdff10a0f0748d43a4fee9e90\" class=\"ne-p\"\u003e\u003cstrong\u003e\u003cspan class=\"ne-text\"\u003eData structures + Algorithms = Programming\u003c/span\u003e\u003c/strong\u003e\u003c/p\u003e\u003cp id=\"175f4024cc2c962517efb5997682de75\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"f80de5c67c6431f2afbd24dbb2aee176\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e操作系统内部会涉及到众多的数据结构和算法描述，能够让你了解算法的基础上，让你编写更优秀的程序。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"5986e2d6bb54fb966e95673f071c0621\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"0ed49e5e0331cad434e0b8915d4b5cdc\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e我认为可以把计算机比作一栋楼\u003c/span\u003e\u003c/p\u003e\u003cp id=\"8c2a4868810afe3b9525b76e29ed5d78\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"1988bafa6f22a0fcc069c82a692373b7\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e计算机的底层相当于就是楼的根基，计算机应用相当于就是楼的外形，而操作系统就相当于是告诉你大楼的构造原理，编写高质量的软件就相当于是告诉你构建一个稳定的房子。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"7014f45e7cc9e806853372bde37b2cfd\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003ch2 id=\"5e0a7a49\"\u003e\u003cspan class=\"ne-text\"\u003e认识操作系统\u003c/span\u003e\u003c/h2\u003e\u003cp id=\"60374c1e79cb4d4843a09fd94637d612\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"e93269cf41ced53553d81ffb79f9eb8d\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e在了解操作系统前，你需要先知道一下什么是计算机系统：现代计算机系统由\u003c/span\u003e\u003cstrong\u003e\u003cspan class=\"ne-text\"\u003e一个或多个处理器、主存、打印机、键盘、鼠标、显示器、网络接口以及各种输入/输出设备构成的系统\u003c/span\u003e\u003c/strong\u003e\u003cspan class=\"ne-text\"\u003e。这些都属于\u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e硬件\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e的范畴。我们程序员不会直接和这些硬件打交道，并且每位程序员不可能会掌握所有计算机系统的细节。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"65640a6ae74714a11395c1618a7fc89d\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"3b4307743edbac97da76c836b32da301\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e所以计算机科学家在硬件的基础之上，安装了一层软件，这层软件能够根据用户输入的指令达到控制硬件的效果，从而满足用户的需求，这样的软件称为 \u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e操作系统\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e，它的任务就是为用户程序提供一个更好、更简单、更清晰的计算机模型。也就是说，操作系统相当于是一个中间层，为用户层和硬件提供各自的借口，屏蔽了不同应用和硬件之间的差异，达到统一标准的作用。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"fd9511ee26ef4adfd5ce0d2019b4f14e\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"17ca944a6947bc0c3d6a5de1a9445a06\" class=\"ne-p\"\u003e\u003cimg src=\"https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829342-133c5955-ce6b-4c7a-9b0e-74e4a24c0f14.png\" width=\"698\" id=\"ahwEU\" class=\"ne-image\"\u003e\u003c/p\u003e\u003cp id=\"6b6913492663205e0e2997de2b4a2e49\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"f876d76748832add56dda94beed6921e\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e上面一个操作系统的简化图，最底层是硬件，硬件包括\u003c/span\u003e\u003cstrong\u003e\u003cspan class=\"ne-text\"\u003e芯片、电路板、磁盘、键盘、显示器\u003c/span\u003e\u003c/strong\u003e\u003cspan class=\"ne-text\"\u003e等我们上面提到的设备，在硬件之上是软件。大部分计算机有两种运行模式：\u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e内核态\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e 和 \u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e用户态\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e，软件中最基础的部分是\u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e操作系统\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e，它运行在 \u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e内核态\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e 中。操作系统具有硬件的访问权，可以执行机器能够运行的任何指令。软件的其余部分运行在 \u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e用户态\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e 下。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"ebbba497f9d6ba190aa46822d3e0cc7a\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"d02cfd23d8b7a7af003461286a9cda5e\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e在大概了解到操作系统之后，我们先来认识一下硬件都有哪些\u003c/span\u003e\u003c/p\u003e\u003cp id=\"05876b94be1f5d0bd06294890520ce08\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003ch2 id=\"7f56845d\"\u003e\u003cspan class=\"ne-text\"\u003e计算机硬件\u003c/span\u003e\u003c/h2\u003e\u003cp id=\"cce8b5dc91c592c0a00cafe91abb32e9\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"01ff293d3d3a521947f1a8dd38dcb947\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e计算机硬件是计算机的重要组成部分，其中包含了 5 个重要的组成部分：\u003c/span\u003e\u003cstrong\u003e\u003cspan class=\"ne-text\"\u003e运算器、控制器、存储器、输入设备、输出设备\u003c/span\u003e\u003c/strong\u003e\u003cspan class=\"ne-text\"\u003e。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"47deb5600e522c817edbe7abbee25e00\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cul class=\"ne-ul\"\u003e\u003cli id=\"23c0ff48cfcf83bd619a8d1744e4fb5c\"\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e运算器\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e：运算器最主要的功能是对数据和信息进行加工和运算。它是计算机中执行算数和各种逻辑运算的部件。运算器的基本运算包括加、减、乘、除、移位等操作，这些是由 \u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e算术逻辑单元(Arithmetic\u0026amp;logical Unit)\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e 实现的。而运算器主要由算数逻辑单元和寄存器构成。\u003c/span\u003e\u003c/li\u003e\u003cli id=\"fbc8179c7d070a8101707bce37bcf93c\"\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e控制器\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e：指按照指定顺序改变主电路或控制电路的部件，它主要起到了控制命令执行的作用，完成协调和指挥整个计算机系统的操作。控制器是由程序计数器、指令寄存器、解码译码器等构成。\u003c/span\u003e\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"e2a465bc1d98db155979301524d750b7\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cdiv class=\"ne-quote\"\u003e\u003cp id=\"68e4847b9cac4d5690f4fe3ddad81505\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e运算器和控制器共同组成了 CPU\u003c/span\u003e\u003c/p\u003e\u003c/div\u003e\u003cp id=\"f40393f314f00082df3f5dac5390d54d\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cul class=\"ne-ul\"\u003e\u003cli id=\"d14c467ef32e45959a85f7540068eec0\"\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e存储器\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e：存储器就是计算机的\u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e记忆设备\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e，顾名思义，存储器可以保存信息。存储器分为两种，一种是主存，也就是内存，它是 CPU 主要交互对象，还有一种是外存，比如硬盘软盘等。下面是现代计算机系统的存储架构\u003c/span\u003e\u003c/li\u003e\u003cli id=\"0109b65dcc8a312766f7aff0577f9186\"\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e输入设备\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e：输入设备是给计算机获取外部信息的设备，它主要包括键盘和鼠标。\u003c/span\u003e\u003c/li\u003e\u003c/ul\u003e\u003cul class=\"ne-ul\"\u003e\u003cli id=\"9c9570d30438ade57fc34f62ed6f8d37\"\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e输出设备\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e：输出设备是给用户呈现根据输入设备获取的信息经过一系列的计算后得到显示的设备，它主要包括显示器、打印机等。\u003c/span\u003e\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"1dce3c1a02c140ec91fee67be8e36769\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"835a282fa628ddcb34e19f76a5ef697a\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e这五部分也是冯诺伊曼的体系结构，它认为计算机必须具有如下功能：\u003c/span\u003e\u003c/p\u003e\u003cp id=\"ad40a6a3aaf0578f66a2c4e20a5720ea\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"2bbfd0566e38489f15096e54e9a0a614\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e把需要的程序和数据送至计算机中。必须具有长期记忆程序、数据、中间结果及最终运算结果的能力。能够完成各种算术、逻辑运算和数据传送等数据加工处理的能力。能够根据需要控制程序走向，并能根据指令控制机器的各部件协调操作。能够按照要求将处理结果输出给用户。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"e1452348578beeb6a16c16494dc88fe4\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"02f40d52bf1660ca14fc7d9e3ef3826c\" class=\"ne-p\"\u003e\u003cimg src=\"https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829342-9ed0fc8c-06fb-431d-8db6-2caaca0abc0f.png\" width=\"721\" id=\"qMDVd\" class=\"ne-image\"\u003e\u003c/p\u003e\u003cp id=\"800c9b83462be50fcb8a3f3cdd6e3b94\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"c4403308930ab6ac5ceca26c06a272c8\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e下面是一张 intel 家族产品图，是一个详细的计算机硬件分类，我们在根据图中涉及到硬件进行介绍\u003c/span\u003e\u003c/p\u003e\u003cp id=\"5b37e26e7636153b562b485458fc5ef1\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"e0fb51cbe771fc7ec497266795295f0e\" class=\"ne-p\"\u003e\u003cimg src=\"https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829351-810b3b3e-2849-45d3-96c8-62280633f4a6.png\" width=\"747\" id=\"ZSJw7\" class=\"ne-image\"\u003e\u003c/p\u003e\u003cp id=\"48dffd0496d4e7ac46311057c1da3964\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cul class=\"ne-ul\"\u003e\u003cli id=\"4edfeb0a52189d8edd1c42763577ee9e\"\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e总线(Buses)\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e：在整个系统中运行的是称为总线的电气管道的集合，这些总线在组件之间来回传输字节信息。通常总线被设计成传送定长的字节块，也就是 \u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e字(word)\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e。字中的字节数（字长）是一个基本的系统参数，各个系统中都不尽相同。现在大部分的字都是 4 个字节（32 位）或者 8 个字节（64 位）。\u003c/span\u003e\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"8722f36b77845d4b9ad537bf6958cb52\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"c153395442fe97613ef51a62e92903b8\" class=\"ne-p\"\u003e\u003cimg src=\"https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829372-677cad04-111e-4904-a865-109bf7e95c9c.png\" width=\"731\" id=\"GR4Q2\" class=\"ne-image\"\u003e\u003c/p\u003e\u003cp id=\"56abdc5d1e5b29b2c23b1d995808d341\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cul class=\"ne-ul\"\u003e\u003cli id=\"314397e76b319606a6f50e9bc4e4d686\"\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003eI/O 设备(I/O Devices)\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e：Input/Output 设备是系统和外部世界的连接。上图中有四类 I/O 设备：用于用户输入的键盘和鼠标，用于用户输出的显示器，一个磁盘驱动用来长时间的保存数据和程序。刚开始的时候，可执行程序就保存在磁盘上。\u003cbr /\u003e\u003c/span\u003e\u003cspan class=\"ne-text\"\u003e每个I/O 设备连接 I/O 总线都被称为\u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e控制器(controller)\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e 或者是 \u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e适配器(Adapter)\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e。控制器和适配器之间的主要区别在于封装方式。控制器是 I/O 设备本身或者系统的主印制板电路（通常称作主板）上的芯片组。而适配器则是一块插在主板插槽上的卡。无论组织形式如何，它们的最终目的都是彼此交换信息。\u003c/span\u003e\u003c/li\u003e\u003cli id=\"5ed03e7dde30479bc8253a8f0657526c\"\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e主存(Main Memory)\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e，主存是一个\u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e临时存储设备\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e，而不是永久性存储，磁盘是 \u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e永久性存储\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e 的设备。主存既保存程序，又保存处理器执行流程所处理的数据。从物理组成上说，主存是由一系列 \u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003eDRAM(dynamic random access memory)\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e 动态随机存储构成的集合。逻辑上说，内存就是一个线性的字节数组，有它唯一的地址编号，从 0 开始。一般来说，组成程序的每条机器指令都由不同数量的字节构成，C 程序变量相对应的数据项的大小根据类型进行变化。比如，在 Linux 的 x86-64 机器上，short 类型的数据需要 2 个字节，int 和 float 需要 4 个字节，而 long 和 double 需要 8 个字节。\u003c/span\u003e\u003c/li\u003e\u003c/ul\u003e\u003cul class=\"ne-ul\"\u003e\u003cli id=\"78a508a67b0570af15a3f2a6cd9321a0\"\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e处理器(Processor)\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e，\u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003eCPU(central processing unit)\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e 或者简单的处理器，是解释（并执行）存储在主存储器中的指令的引擎。处理器的核心大小为一个字的存储设备（或寄存器），称为\u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e程序计数器(PC)\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e。在任何时刻，PC 都指向主存中的某条机器语言指令（即含有该条指令的地址）。\u003cbr /\u003e\u003c/span\u003e\u003cspan class=\"ne-text\"\u003e从系统通电开始，直到系统断电，处理器一直在不断地执行程序计数器指向的指令，再更新程序计数器，使其指向下一条指令。处理器根据其指令集体系结构定义的指令模型进行操作。在这个模型中，指令按照严格的顺序执行，执行一条指令涉及执行一系列的步骤。处理器从程序计数器指向的内存中读取指令，解释指令中的位，执行该指令指示的一些简单操作，然后更新程序计数器以指向下一条指令。指令与指令之间可能连续，可能不连续（比如 jmp 指令就不会顺序读取）\u003c/span\u003e\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"3a4a2a641d1a1c2de5ad66377fca1a30\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"954dbf0f9e583d9fe45125eabf87296d\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e下面是 CPU 可能执行简单操作的几个步骤\u003c/span\u003e\u003c/p\u003e\u003cp id=\"0e7c003044e5b5185d07ad8a3a2b10dc\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cul class=\"ne-ul\"\u003e\u003cli id=\"62092432619e0a8617a85dc65506af1f\"\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e加载(Load)\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e：从主存中拷贝一个字节或者一个字到内存中，覆盖寄存器先前的内容\u003c/span\u003e\u003c/li\u003e\u003cli id=\"d70e3efbed128cede95336b4ab29b2c8\"\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e存储(Store)\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e：将寄存器中的字节或字复制到主存储器中的某个位置，从而覆盖该位置的先前内容\u003c/span\u003e\u003c/li\u003e\u003c/ul\u003e\u003cul class=\"ne-ul\"\u003e\u003cli id=\"34ef14e8474868fc664a6a7a93da783c\"\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e操作(Operate)\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e：把两个寄存器的内容复制到 \u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003eALU(Arithmetic logic unit)\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e 。把两个字进行算术运算，并把结果存储在寄存器中，重写寄存器先前的内容。\u003c/span\u003e\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"b0921cf26e6a7ca068ba0fe5f7503a34\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cdiv class=\"ne-quote\"\u003e\u003cp id=\"24027a2585b5d271d4a70016b7d63879\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e算术逻辑单元（ALU）是对数字二进制数执行算术和按位运算的组合数字电子电路。\u003c/span\u003e\u003c/p\u003e\u003c/div\u003e\u003cp id=\"8875ee2f15790a01020ed498f5331bbf\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cul class=\"ne-ul\"\u003e\u003cli id=\"04e09f85f3b9c8a6b2b2cb9643a334b0\"\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e跳转(jump)\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e：从指令中抽取一个字，把这个字复制到\u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e程序计数器(PC)\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e 中，覆盖原来的值\u003c/span\u003e\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"40564caba44243a15803ea8ea3df1185\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003ch2 id=\"e5b00e3a\"\u003e\u003cspan class=\"ne-text\"\u003e进程和线程\u003c/span\u003e\u003c/h2\u003e\u003cp id=\"89e59462cf5e42126bf7fd69ec455e43\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"279db931dc6baec0f7e3d4b21b009845\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e关于进程和线程，你需要理解下面这张脑图中的重点\u003c/span\u003e\u003c/p\u003e\u003cp id=\"cd6805c2765d2ea297065d329755927f\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"1d9db861bcf8b6d42bd30feae4ef59ef\" class=\"ne-p\"\u003e\u003cimg src=\"https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829389-4c3de174-e023-4600-b910-b01112bd2f4c.png\" width=\"734\" id=\"tvXh9\" class=\"ne-image\"\u003e\u003c/p\u003e\u003cp id=\"7b1432c8b72204ee4b825e861b12f98e\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003ch2 id=\"f88522cf\"\u003e\u003cspan class=\"ne-text\"\u003e进程\u003c/span\u003e\u003c/h2\u003e\u003cp id=\"558402d93b3b4cb15182048bf1d22ac0\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"0989e50fff0d7132d77a4dc9d000527a\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e操作系统中最核心的概念就是 \u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e进程\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e，进程是对正在运行中的程序的一个抽象。操作系统的其他所有内容都是围绕着进程展开的。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"9858e22f7b813dbde0def60216102845\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"c6c622877f50d6ecedc29825038afaef\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e在多道程序处理的系统中，CPU 会在\u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e进程\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e间快速切换，使每个程序运行几十或者几百毫秒。然而，严格意义来说，在某一个瞬间，CPU 只能运行一个进程，然而我们如果把时间定位为 1 秒内的话，它可能运行多个进程。这样就会让我们产生\u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e并行\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e的错觉。因为 CPU 执行速度很快，进程间的换进换出也非常迅速，因此我们很难对多个并行进程进行跟踪。所以，操作系统的设计者开发了用于描述并行的一种概念模型（顺序进程），使得并行更加容易理解和分析。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"7ebadc22ea804dc3ce1f6cb4f1faa79a\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003ch3 id=\"db1832c3\"\u003e\u003cspan class=\"ne-text\"\u003e进程模型\u003c/span\u003e\u003c/h3\u003e\u003cp id=\"d840b450465be09e434df4a3dd9a3f21\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"0f48d95b096b20bbe4d780741e4b7c54\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e一个进程就是一个正在执行的程序的实例，进程也包括程序计数器、寄存器和变量的当前值。从概念上来说，每个进程都有各自的虚拟 CPU，但是实际情况是 CPU 会在各个进程之间进行来回切换。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"864056155c24e8395f096ca45cc118d3\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"89fb82994d781ae23159ddf581f8535e\" class=\"ne-p\"\u003e\u003cimg src=\"https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829609-9880b940-5163-45d4-8ef6-b559ab53b55d.png\" width=\"455\" id=\"XCIWa\" class=\"ne-image\"\u003e\u003c/p\u003e\u003cp id=\"503dfc349a03926ac40238c181049013\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"e44e9da7ec98c3c4fe1fdbf7978527ea\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e如上图所示，这是一个具有 4 个程序的多道处理程序，在进程不断切换的过程中，程序计数器也在不同的变化。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"8b5b1883046bf13d25c14fb35e4516bb\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"bbcf34ef348ae4a397c45691442445a7\" class=\"ne-p\"\u003e\u003cimg src=\"https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829415-2d4059be-d447-4abf-8e77-2df51d6cc6a1.png\" width=\"647\" id=\"CNsvU\" class=\"ne-image\"\u003e\u003c/p\u003e\u003cp id=\"13790759d024503953e9acbb6b0b7ab3\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"1df3a5508dff94ecadd151924567d3b5\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e在上图中，这 4 道程序被抽象为 4 个拥有各自控制流程（即每个自己的程序计数器）的进程，并且每个程序都独立的运行。当然，实际上只有一个物理程序计数器，每个程序要运行时，其逻辑程序计数器会装载到物理程序计数器中。当程序运行结束后，其物理程序计数器就会是真正的程序计数器，然后再把它放回进程的逻辑计数器中。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"ee92f5f090955049ed874d170f8164cb\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"01f2e5a8184ecf5d05233123e72d116d\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e从下图我们可以看到，在观察足够长的一段时间后，所有的进程都运行了，\u003c/span\u003e\u003cstrong\u003e\u003cspan class=\"ne-text\"\u003e但在任何一个给定的瞬间仅有一个进程真正运行\u003c/span\u003e\u003c/strong\u003e\u003cspan class=\"ne-text\"\u003e。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"d183af70e6d683798bd87e78de114558\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"c50a4b4a34d3cd79990b212d4fbfc543\" class=\"ne-p\"\u003e\u003cimg src=\"https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829611-a49b5e88-0d0e-42c3-a103-485b6e5c984b.png\" width=\"578\" id=\"Zm8OZ\" class=\"ne-image\"\u003e\u003c/p\u003e\u003cp id=\"77943fe667db14d2a7a7af237a686d74\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"04d2c0652dedc050608799739b401859\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e因此，当我们说一个 CPU 只能真正一次运行一个进程的时候，即使有 2 个核（或 CPU），\u003c/span\u003e\u003cstrong\u003e\u003cspan class=\"ne-text\"\u003e每一个核也只能一次运行一个线程\u003c/span\u003e\u003c/strong\u003e\u003cspan class=\"ne-text\"\u003e。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"5f3805e43ab58c9f9b1421c309983a93\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"caa82774fc8116b9bb58bada934ea47c\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e由于 CPU 会在各个进程之间来回快速切换，所以每个进程在 CPU 中的运行时间是无法确定的。并且当同一个进程再次在 CPU 中运行时，其在 CPU 内部的运行时间往往也是不固定的。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"3833fb1e45d8a553449ff36ab59e4177\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"802684c9e995650755383da022afcbb1\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e这里的关键思想是\u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e认识到一个进程所需的条件\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e，进程是某一类特定活动的总和，它有程序、输入输出以及状态。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"2d8841ff912ecc1480e38c0ace860c22\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003ch3 id=\"ef174e29\"\u003e\u003cspan class=\"ne-text\"\u003e进程的创建\u003c/span\u003e\u003c/h3\u003e\u003cp id=\"b69f4a48539edd2c438341715747400d\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"34e9aef6755ca9dc3103ca25f2c1b94c\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e操作系统需要一些方式来创建进程。下面是一些创建进程的方式\u003c/span\u003e\u003c/p\u003e\u003cp id=\"7f056f7e3d9ba5170e3d973201d6e577\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cul class=\"ne-ul\"\u003e\u003cli id=\"5525a064edc2a71505894af900e9ae6d\"\u003e\u003cspan class=\"ne-text\"\u003e系统初始化（init）：启动操作系统时，通常会创建若干个进程。\u003c/span\u003e\u003c/li\u003e\u003cli id=\"655f909b3a436f6c5d0b2f6ce577f1eb\"\u003e\u003cspan class=\"ne-text\"\u003e正在运行的程序执行了创建进程的系统调用（比如 fork）\u003c/span\u003e\u003c/li\u003e\u003c/ul\u003e\u003cul class=\"ne-ul\"\u003e\u003cli id=\"15f97be6f701a9d2e285ce067dcaa4f5\"\u003e\u003cspan class=\"ne-text\"\u003e用户请求创建一个新进程：在许多交互式系统中，输入一个命令或者双击图标就可以启动程序，以上任意一种操作都可以选择开启一个新的进程，在基本的 UNIX 系统中运行 X，新进程将接管启动它的窗口。\u003c/span\u003e\u003c/li\u003e\u003cli id=\"9cbc72a5195fe8f27a433e2cf1537410\"\u003e\u003cspan class=\"ne-text\"\u003e初始化一个批处理工作\u003c/span\u003e\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"734b1131d138309cb8f6e8751b24b0ca\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"36bcfdf4e40be363d8ec64c87f794ea4\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e从技术上讲，在所有这些情况下，让现有流程执行流程是通过创建系统调用来创建新流程的。该进程可能是正在运行的用户进程，是从键盘或鼠标调用的系统进程或批处理程序。这些就是系统调用创建新进程的过程。该系统调用告诉操作系统创建一个新进程，并直接或间接指示在其中运行哪个程序。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"e244fe98d07fe53d8b8b074500bbdbf0\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"90057922d3b14889ff144902ccb57016\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e在 UNIX 中，仅有一个系统调用来创建一个新的进程，这个系统调用就是 \u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003efork\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e。这个调用会创建一个与调用进程相关的副本。在 fork 后，一个父进程和子进程会有相同的\u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e内存映像\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e，相同的环境字符串和相同的打开文件。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"40b362f7c35397f6ed004f88fc15b256\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"8ca0bc63e686352cfce2b4e04f846f34\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e在 Windows 中，情况正相反，一个简单的 Win32 功能调用 \u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003eCreateProcess\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e，会处理流程创建并将正确的程序加载到新的进程中。这个调用会有 10 个参数，包括了需要执行的程序、输入给程序的命令行参数、各种安全属性、有关打开的文件是否继承控制位、优先级信息、进程所需要创建的窗口规格以及指向一个结构的指针，在该结构中新创建进程的信息被返回给调用者。\u003c/span\u003e\u003cstrong\u003e\u003cspan class=\"ne-text\"\u003e在 Windows 中，从一开始父进程的地址空间和子进程的地址空间就是不同的\u003c/span\u003e\u003c/strong\u003e\u003cspan class=\"ne-text\"\u003e。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"c760fc897fd7f21d634e5d2c5ab8dd50\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003ch3 id=\"24ee23f9\"\u003e\u003cspan class=\"ne-text\"\u003e进程的终止\u003c/span\u003e\u003c/h3\u003e\u003cp id=\"2a356a15e9c85c0d5ea48bee53e3ee53\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"a0bc37496955070caffd70767e9fccca\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e进程在创建之后，它就开始运行并做完成任务。然而，没有什么事儿是永不停歇的，包括进程也一样。进程早晚会发生终止，但是通常是由于以下情况触发的\u003c/span\u003e\u003c/p\u003e\u003cp id=\"1785949fd41d177bee8df659bfa2541e\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cul class=\"ne-ul\"\u003e\u003cli id=\"aef294d171fb8cac4c656d092ad0efd6\"\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e正常退出(自愿的)\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e ： 多数进程是由于完成了工作而终止。当编译器完成了所给定程序的编译之后，编译器会执行一个系统调用告诉操作系统它完成了工作。这个调用在 UNIX 中是 \u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003eexit\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e ，在 Windows 中是 \u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003eExitProcess\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e。\u003c/span\u003e\u003c/li\u003e\u003cli id=\"64851a07fdbb717aabe3e48e41e69418\"\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e错误退出(自愿的)\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e：比如执行一条不存在的命令，于是编译器就会提醒并退出。\u003c/span\u003e\u003c/li\u003e\u003c/ul\u003e\u003cul class=\"ne-ul\"\u003e\u003cli id=\"7cdd5fd1594ea716be38ce11cb3a10e2\"\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e严重错误(非自愿的)\u003c/span\u003e\u003c/code\u003e\u003c/li\u003e\u003cli id=\"6babe1237002ef73948160629e13b605\"\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e被其他进程杀死(非自愿的)\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e ： 某个进程执行系统调用告诉操作系统杀死某个进程。在 UNIX 中，这个系统调用是 kill。在 Win32 中对应的函数是 \u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003eTerminateProcess\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e（注意不是系统调用）。\u003c/span\u003e\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"5bd73c750876718c6aca8ef216af6b54\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003ch3 id=\"59a65ba2\"\u003e\u003cspan class=\"ne-text\"\u003e进程的层次结构\u003c/span\u003e\u003c/h3\u003e\u003cp id=\"0bb47166b3c322ba29b0f204223d5fd0\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"7f07789281882e50c0fc300b3ca03f9c\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e在一些系统中，当一个进程创建了其他进程后，父进程和子进程就会以某种方式进行关联。子进程它自己就会创建更多进程，从而形成一个进程层次结构。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"829195fa901cce4553d63f442daebea8\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003ch4 id=\"9a0a3bf9\"\u003e\u003cspan class=\"ne-text\"\u003eUNIX 进程体系\u003c/span\u003e\u003c/h4\u003e\u003cp id=\"1c753e33d5a50d5c91e575f5f321a978\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"71620443f7be78f9d927a3e3caee47a6\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e在 UNIX 中，进程和它的所有子进程以及子进程的子进程共同组成一个进程组。当用户从键盘中发出一个信号后，该信号被发送给当前与键盘相关的进程组中的所有成员（它们通常是在当前窗口创建的所有活动进程）。每个进程可以分别捕获该信号、忽略该信号或采取默认的动作，即被信号 kill 掉。整个操作系统中所有的进程都隶属于一个单个以 init 为根的进程树。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"dcf543e13cb6e080adafb4af20eb2588\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"c4605dff5b082200add96857699ecbb3\" class=\"ne-p\"\u003e\u003cimg src=\"https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829468-bff503cb-cf97-4853-aca3-35db5bb67312.png\" width=\"615\" id=\"TUggO\" class=\"ne-image\"\u003e\u003c/p\u003e\u003cp id=\"3fa2c3bfabb4e38822ab985e931554cb\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003ch4 id=\"5d016720\"\u003e\u003cspan class=\"ne-text\"\u003eWindows 进程体系\u003c/span\u003e\u003c/h4\u003e\u003cp id=\"fb9194b7b563522aaf65f5e7877f5d9d\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"45b7deda743f60e53beed2089b218a3c\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e相反，Windows 中没有进程层次的概念，Windows 中所有进程都是平等的，唯一类似于层次结构的是在创建进程的时候，父进程得到一个特别的令牌（称为句柄），该句柄可以用来控制子进程。然而，这个令牌可能也会移交给别的操作系统，这样就不存在层次结构了。而在 UNIX 中，进程不能剥夺其子进程的 \u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e进程权\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e。（这样看来，还是 Windows 比较\u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e渣\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e）。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"248c55e3f445201dd7dbeca56a3f9b00\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003ch3 id=\"fe290ad3\"\u003e\u003cspan class=\"ne-text\"\u003e进程状态\u003c/span\u003e\u003c/h3\u003e\u003cp id=\"ad4ee3dd92ab5c79b1c5cbc43c5a3dba\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"4d829862b4033af7e64e431f9c777402\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e尽管每个进程是一个独立的实体，有其自己的程序计数器和内部状态，但是，进程之间仍然需要相互帮助。当一个进程开始运行时，它可能会经历下面这几种状态\u003c/span\u003e\u003c/p\u003e\u003cp id=\"a7817b1f61e8d565b373c264359e44f9\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"c8b03ba9b3b2b9903b85c39e72dd8a91\" class=\"ne-p\"\u003e\u003cimg src=\"https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829472-6b2e277f-f4b9-4f38-805d-e9ac73f33129.png\" width=\"734\" id=\"nVHjc\" class=\"ne-image\"\u003e\u003c/p\u003e\u003cp id=\"08028f8436803d51ec1e716d72fe2310\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"82bce743c56b29faca92df0ac4052b5e\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e图中会涉及三种状态\u003c/span\u003e\u003c/p\u003e\u003cp id=\"9f699dbeb42df9e8d0551ca5d9171c73\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003col class=\"ne-ol\"\u003e\u003cli id=\"aec08485f34560a4b7b6abadb75ef79d\"\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e运行态\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e，运行态指的就是进程实际占用 CPU 时间片运行时\u003c/span\u003e\u003c/li\u003e\u003cli id=\"381d58aae0b72332585ff6985de97c5e\"\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e就绪态\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e，就绪态指的是可运行，但因为其他进程正在运行而处于就绪状态\u003c/span\u003e\u003c/li\u003e\u003c/ol\u003e\u003col start=\"3\" class=\"ne-ol\"\u003e\u003cli id=\"65a92d0ec3b2adb54401c8528d0e23b6\"\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e阻塞态\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e，除非某种外部事件发生，否则进程不能运行\u003c/span\u003e\u003c/li\u003e\u003c/ol\u003e\u003cp id=\"081c0d4cc15fd01c6d95209ecec0c1e0\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003ch3 id=\"27fe55d6\"\u003e\u003cspan class=\"ne-text\"\u003e进程的实现\u003c/span\u003e\u003c/h3\u003e\u003cp id=\"92b3b630daddd7d1ddb5cf95b49e523c\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"7837b0696feedfcbb97df8ce125c1217\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e操作系统为了执行进程间的切换，会维护着一张表，这张表就是 \u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e进程表(process table)\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e。每个进程占用一个进程表项。该表项包含了进程状态的重要信息，包括程序计数器、堆栈指针、内存分配状况、所打开文件的状态、账号和调度信息，以及其他在进程由运行态转换到就绪态或阻塞态时所必须保存的信息。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"d3d512edb88e5511bf9ce1530b15e0f8\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"650b4ebec7f6635f2b6ff4cc027a95fe\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e下面展示了一个典型系统中的关键字段\u003c/span\u003e\u003c/p\u003e\u003cp id=\"023ffbba17dc27adc6ff1d21fb9e45cf\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"abf3e59185ee55f8fe152e201cecaf06\" class=\"ne-p\"\u003e\u003cimg src=\"https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829487-6d8a6e92-d068-48a8-b5a0-9e5b74f9ab3f.png\" width=\"749\" id=\"Sr874\" class=\"ne-image\"\u003e\u003c/p\u003e\u003cp id=\"4c8283b21ecd2b4d4d8121fed458946c\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"4fe136f6a62abb9ab8066e3c6085988c\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e第一列内容与\u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e进程管理\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e有关，第二列内容与 \u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e存储管理\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e有关，第三列内容与\u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e文件管理\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e有关。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"93ffa9020d0b8573b25e9ad3d4211dbc\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"6a6879f2608015b94561ab03cca29275\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e现在我们应该对进程表有个大致的了解了，就可以在对单个 CPU 上如何运行多个顺序进程的错觉做更多的解释。与每一 I/O 类相关联的是一个称作 \u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e中断向量(interrupt vector)\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e 的位置（靠近内存底部的固定区域）。它包含中断服务程序的入口地址。假设当一个磁盘中断发生时，用户进程 3 正在运行，则中断硬件将程序计数器、程序状态字、有时还有一个或多个寄存器压入堆栈，计算机随即跳转到中断向量所指示的地址。这就是硬件所做的事情。然后软件就随即接管一切剩余的工作。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"d944c12bcb8d1fb777afe0c76b5d4dfe\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"67925a50acf5cec75da68f7c4fa97604\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e当中断结束后，操作系统会调用一个 C 程序来处理中断剩下的工作。在完成剩下的工作后，会使某些进程就绪，接着调用调度程序，决定随后运行哪个进程。然后将控制权转移给一段汇编语言代码，为当前的进程装入寄存器值以及内存映射并启动该进程运行，下面显示了中断处理和调度的过程。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"e9c2e6a19d20c8e9d745ba1ede98bda0\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003col class=\"ne-ol\"\u003e\u003cli id=\"bcfd5526252f62185fad5607256d5a21\"\u003e\u003cspan class=\"ne-text\"\u003e硬件压入堆栈程序计数器等\u003c/span\u003e\u003c/li\u003e\u003cli id=\"7fe994f519b0faf5566db73640fc6be1\"\u003e\u003cspan class=\"ne-text\"\u003e硬件从中断向量装入新的程序计数器\u003c/span\u003e\u003c/li\u003e\u003c/ol\u003e\u003col start=\"3\" class=\"ne-ol\"\u003e\u003cli id=\"c934d43af74c443845b28312159ee1ac\"\u003e\u003cspan class=\"ne-text\"\u003e汇编语言过程保存寄存器的值\u003c/span\u003e\u003c/li\u003e\u003cli id=\"82e923138b451b98f625e89cbd0b6bca\"\u003e\u003cspan class=\"ne-text\"\u003e汇编语言过程设置新的堆栈\u003c/span\u003e\u003c/li\u003e\u003c/ol\u003e\u003col start=\"5\" class=\"ne-ol\"\u003e\u003cli id=\"4f5334e81f1d5a5f1e64fda967d5fca0\"\u003e\u003cspan class=\"ne-text\"\u003eC 中断服务器运行（典型的读和缓存写入）\u003c/span\u003e\u003c/li\u003e\u003cli id=\"94f7067d3f873488b2a017df5a72d5ce\"\u003e\u003cspan class=\"ne-text\"\u003e调度器决定下面哪个程序先运行\u003c/span\u003e\u003c/li\u003e\u003c/ol\u003e\u003col start=\"7\" class=\"ne-ol\"\u003e\u003cli id=\"eff3e73d42a5e05ab6c5e185f9a05120\"\u003e\u003cspan class=\"ne-text\"\u003eC 过程返回至汇编代码\u003c/span\u003e\u003c/li\u003e\u003cli id=\"724b882cbe84a93d767c38842f66357b\"\u003e\u003cspan class=\"ne-text\"\u003e汇编语言过程开始运行新的当前进程\u003c/span\u003e\u003c/li\u003e\u003c/ol\u003e\u003cp id=\"60ef497df3321edea7d108cdcc4053d3\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"38f27f3718510227db767b00debb1939\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e一个进程在执行过程中可能被中断数千次，但关键每次中断后，被中断的进程都返回到与中断发生前完全相同的状态。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"51999800e2ccce806ac92346816458e4\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003ch2 id=\"d276123c\"\u003e\u003cspan class=\"ne-text\"\u003e线程\u003c/span\u003e\u003c/h2\u003e\u003cp id=\"9f602f2dc988af4bde245a6ccdf7ff13\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"55772d1f565f2ecbfcfc09a8bc616c44\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e在传统的操作系统中，每个进程都有一个地址空间和一个控制线程。事实上，这是大部分进程的定义。不过，在许多情况下，经常存在同一地址空间中运行多个控制线程的情形，这些线程就像是分离的进程。下面我们就着重探讨一下什么是线程\u003c/span\u003e\u003c/p\u003e\u003cp id=\"ea8fb1edc20cb64f1273a9310aa3751d\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003ch3 id=\"b2c46474\"\u003e\u003cspan class=\"ne-text\"\u003e线程的使用\u003c/span\u003e\u003c/h3\u003e\u003cp id=\"ab116c151e8ba219bf8ae6f68ab5ede4\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"1ce2c19e90381851b1534560e92b51d3\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e或许这个疑问也是你的疑问，为什么要在进程的基础上再创建一个线程的概念，准确的说，这其实是进程模型和线程模型的讨论，回答这个问题，可能需要分三步来回答\u003c/span\u003e\u003c/p\u003e\u003cp id=\"e8a5e2e598ab662e0607b58901d9758e\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cul class=\"ne-ul\"\u003e\u003cli id=\"a68004fabbe64f1be4294491ce6943cc\"\u003e\u003cspan class=\"ne-text\"\u003e多线程之间会共享同一块地址空间和所有可用数据的能力，这是进程所不具备的\u003c/span\u003e\u003c/li\u003e\u003cli id=\"c16d784bb6036482a74a4f2816dcd734\"\u003e\u003cspan class=\"ne-text\"\u003e线程要比进程\u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e更轻量级\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e，由于线程更轻，所以它比进程更容易创建，也更容易撤销。在许多系统中，创建一个线程要比创建一个进程快 10 - 100 倍。\u003c/span\u003e\u003c/li\u003e\u003c/ul\u003e\u003cul class=\"ne-ul\"\u003e\u003cli id=\"124456cced3a6934d0dbc4c8b6e588fa\"\u003e\u003cspan class=\"ne-text\"\u003e第三个原因可能是性能方面的探讨，如果多个线程都是 CPU 密集型的，那么并不能获得性能上的增强，但是如果存在着大量的计算和大量的 I/O 处理，拥有多个线程能在这些活动中彼此重叠进行，从而会加快应用程序的执行速度\u003c/span\u003e\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"969485792d07970e248a25c707ae81c3\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003ch3 id=\"eb3f9151\"\u003e\u003cspan class=\"ne-text\"\u003e经典的线程模型\u003c/span\u003e\u003c/h3\u003e\u003cp id=\"0f4cd5ac358f2cd5d9e6305faa1d2f19\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"f4399e0137f899b35f0a99796f458cee\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e进程中拥有一个执行的线程，通常简写为 \u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e线程(thread)\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e。线程会有程序计数器，用来记录接着要执行哪一条指令；线程实际上 CPU 上调度执行的实体。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"9f6e4eaf1534a378bf8231492af63f4b\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"cf636b0793325e7d330a7e6769b03700\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e下图我们可以看到三个传统的进程，每个进程有自己的地址空间和单个控制线程。每个线程都在不同的地址空间中运行\u003c/span\u003e\u003c/p\u003e\u003cp id=\"90ee1e4c78f7c3f9bacfeddf50cce64c\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"6caf3b47091b19d6f3453533334c3136\" class=\"ne-p\"\u003e\u003cimg src=\"https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829491-73cfd311-e3e5-4381-886b-f904f3c8ca5c.png\" width=\"658\" id=\"lfuB1\" class=\"ne-image\"\u003e\u003c/p\u003e\u003cp id=\"8ba295dcb96dca3a3572f16973748711\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"1644b4a344140948fb4c97c0bd2cd7df\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e下图中，我们可以看到有一个进程三个线程的情况。每个线程都在相同的地址空间中运行。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"a6c4bee1d01b8aa5be0eadc12cbe618b\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"af6501c631d07365f00006589b930913\" class=\"ne-p\"\u003e\u003cimg src=\"https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829501-7e5370fc-b9ec-4804-a862-9c86e00bf231.png\" width=\"640\" id=\"uVJR7\" class=\"ne-image\"\u003e\u003c/p\u003e\u003cp id=\"181be89a9207f89b1c00524cbbab1e00\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"39810993b510056e76c4a3b570b37cd2\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e线程不像是进程那样具备较强的独立性。同一个进程中的所有线程都会有完全一样的地址空间，这意味着它们也共享同样的全局变量。由于每个线程都可以访问进程地址空间内每个内存地址，\u003c/span\u003e\u003cstrong\u003e\u003cspan class=\"ne-text\"\u003e因此一个线程可以读取、写入甚至擦除另一个线程的堆栈\u003c/span\u003e\u003c/strong\u003e\u003cspan class=\"ne-text\"\u003e。线程之间除了共享同一内存空间外，还具有如下不同的内容\u003c/span\u003e\u003c/p\u003e\u003cp id=\"e6b58ebee8ff091f855004f3afe8523d\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"9cf3875d0759c13afa2efc6cbceea3c6\" class=\"ne-p\"\u003e\u003cimg src=\"https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829530-1ce4e3bb-f3b4-4fae-bd6b-2a09cb86e2d3.png\" width=\"583\" id=\"GpbmQ\" class=\"ne-image\"\u003e\u003c/p\u003e\u003cp id=\"5d5826853af545f770aa24d16ca10997\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"33ecc512185771f5ff75d82ee58a1d69\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e上图左边的是同一个进程中\u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e每个线程共享\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e的内容，上图右边是\u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e每个线程\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e中的内容。也就是说左边的列表是进程的属性，右边的列表是线程的属性。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"ad5fb01708e084b0184f6e5dc56062b2\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"1e26ec6c5f413fc1bd832038d6fce9ce\" class=\"ne-p\"\u003e\u003cstrong\u003e\u003cspan class=\"ne-text\"\u003e线程之间的状态转换和进程之间的状态转换是一样的\u003c/span\u003e\u003c/strong\u003e\u003cspan class=\"ne-text\"\u003e。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"7c1105577d60fc2e15dc30ee4592d372\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"f4511cae93abe3026efa2cf3757360d5\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e每个线程都会有自己的堆栈，如下图所示\u003c/span\u003e\u003c/p\u003e\u003cp id=\"8adbcedd049bb3edc3764bede487c847\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"27f1bbcde67b84d60351835e8ce7750b\" class=\"ne-p\"\u003e\u003cimg src=\"https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829586-41932660-4ab5-42e2-bbb1-bbd660b183f6.png\" width=\"682\" id=\"WnFPn\" class=\"ne-image\"\u003e\u003c/p\u003e\u003cp id=\"0e816dfec54ca3e832073ef02dbeeb6b\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003ch4 id=\"6632fae6\"\u003e\u003cspan class=\"ne-text\"\u003e线程系统调用\u003c/span\u003e\u003c/h4\u003e\u003cp id=\"8626c74ea022a987992b0c1fbdb792b3\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"eef4b592177acc7598b410c9dcbd2692\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e进程通常会从当前的某个单线程开始，然后这个线程通过调用一个库函数（比如 \u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003ethread_create\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e ）创建新的线程。线程创建的函数会要求指定新创建线程的名称。创建的线程通常都返回一个线程标识符，该标识符就是新线程的名字。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"699815b2cc0f7cb21f43b7de2be07cdf\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"a7c9a0127beb8b9c706078fde4ff4ee2\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e当一个线程完成工作后，可以通过调用一个函数（比如 \u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003ethread_exit\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e）来退出。紧接着线程消失，状态变为终止，不能再进行调度。在某些线程的运行过程中，可以通过调用函数例如 \u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003ethread_join\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e ，表示一个线程可以等待另一个线程退出。这个过程阻塞调用线程直到等待特定的线程退出。在这种情况下，线程的创建和终止非常类似于进程的创建和终止。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"f4a5500946aabb17ea44c2558f19c2ca\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"9629c5ac74f429f3955418e20f72cec0\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e另一个常见的线程是调用 \u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003ethread_yield\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e，它允许线程自动放弃 CPU 从而让另一个线程运行。这样一个调用还是很重要的，因为不同于进程，线程是无法利用时钟中断强制让线程让出 CPU 的。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"8fdc0d7830858c997bfd188739ed7afc\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003ch3 id=\"b1d15c6e\"\u003e\u003cspan class=\"ne-text\"\u003ePOSIX 线程\u003c/span\u003e\u003c/h3\u003e\u003cp id=\"db401dc44303ec105e67be5c2fc389c4\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"dfd97f521bd61893a8aeabdb0535fa87\" class=\"ne-p\"\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003ePOSIX 线程 通常称为 pthreads\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e是一种独立于语言而存在的执行模型，以及并行执行模型。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"1bf64c399339628fb7957855f494f71f\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"e49542eca979134cc9c9f75f2f329a24\" class=\"ne-p\"\u003e\u003cimg src=\"https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829568-3bded50a-8029-4644-9e42-c2c6ddf60ca1.png\" width=\"639\" id=\"ZELdp\" class=\"ne-image\"\u003e\u003c/p\u003e\u003cp id=\"fe7cfff22c57936dee6dd54e80f17015\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"c50783d2ba22cd47838f774866f90191\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e它允许程序控制时间上重叠的多个不同的工作流程。每个工作流程都称为一个线程，可以通过调用 POSIX Threads API 来实现对这些流程的创建和控制。可以把它理解为线程的标准。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"6ae632f03f369eff8d56f27dbe210647\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cdiv class=\"ne-quote\"\u003e\u003cp id=\"cd16084d7837c5073a2fa1c2189d0c10\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003ePOSIX Threads 的实现在许多类似且符合POSIX的操作系统上可用，例如 \u003c/span\u003e\u003cstrong\u003e\u003cspan class=\"ne-text\"\u003eFreeBSD、NetBSD、OpenBSD、Linux、macOS、Android、Solaris\u003c/span\u003e\u003c/strong\u003e\u003cspan class=\"ne-text\"\u003e，它在现有 Windows API 之上实现了\u003c/span\u003e\u003cstrong\u003e\u003cspan class=\"ne-text\"\u003epthread\u003c/span\u003e\u003c/strong\u003e\u003cspan class=\"ne-text\"\u003e。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"4bb522cf8ceadf992cc37fe01affca2b\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003eIEEE 是世界上最大的技术专业组织，致力于为人类的利益而发展技术。\u003c/span\u003e\u003c/p\u003e\u003c/div\u003e\u003ctable id=\"d6ca4def\" class=\"ne-table\" style=\"width: 750px\"\u003e\u003ctbody\u003e\u003ctr style=\"height: 33px\"\u003e\u003ctd width=\"375\"\u003e\u003cp id=\"uf5bca78d\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e线程调用\u003c/span\u003e\u003c/p\u003e\u003c/td\u003e\u003ctd width=\"375\"\u003e\u003cp id=\"u066f4fdf\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e描述\u003c/span\u003e\u003c/p\u003e\u003c/td\u003e\u003c/tr\u003e\u003ctr style=\"height: 33px\"\u003e\u003ctd width=\"375\"\u003e\u003cp id=\"u96230ab3\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003epthread_create\u003c/span\u003e\u003c/p\u003e\u003c/td\u003e\u003ctd width=\"375\"\u003e\u003cp id=\"uff601278\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e创建一个新线程\u003c/span\u003e\u003c/p\u003e\u003c/td\u003e\u003c/tr\u003e\u003ctr style=\"height: 33px\"\u003e\u003ctd width=\"375\"\u003e\u003cp id=\"ucb6f1a7c\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003epthread_exit\u003c/span\u003e\u003c/p\u003e\u003c/td\u003e\u003ctd width=\"375\"\u003e\u003cp id=\"u2c6ae04a\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e结束调用的线程\u003c/span\u003e\u003c/p\u003e\u003c/td\u003e\u003c/tr\u003e\u003ctr style=\"height: 33px\"\u003e\u003ctd width=\"375\"\u003e\u003cp id=\"u2219439b\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003epthread_join\u003c/span\u003e\u003c/p\u003e\u003c/td\u003e\u003ctd width=\"375\"\u003e\u003cp id=\"ub02eaf4e\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e等待一个特定的线程退出\u003c/span\u003e\u003c/p\u003e\u003c/td\u003e\u003c/tr\u003e\u003ctr style=\"height: 33px\"\u003e\u003ctd width=\"375\"\u003e\u003cp id=\"u2804c355\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003epthread_yield\u003c/span\u003e\u003c/p\u003e\u003c/td\u003e\u003ctd width=\"375\"\u003e\u003cp id=\"u60922575\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e释放 CPU 来运行另外一个线程\u003c/span\u003e\u003c/p\u003e\u003c/td\u003e\u003c/tr\u003e\u003ctr style=\"height: 33px\"\u003e\u003ctd width=\"375\"\u003e\u003cp id=\"u9eb11640\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003epthread_attr_init\u003c/span\u003e\u003c/p\u003e\u003c/td\u003e\u003ctd width=\"375\"\u003e\u003cp id=\"ue5ad1df6\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e创建并初始化一个线程的属性结构\u003c/span\u003e\u003c/p\u003e\u003c/td\u003e\u003c/tr\u003e\u003ctr style=\"height: 33px\"\u003e\u003ctd width=\"375\"\u003e\u003cp id=\"u1ea06b78\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003epthread_attr_destory\u003c/span\u003e\u003c/p\u003e\u003c/td\u003e\u003ctd width=\"375\"\u003e\u003cp id=\"ub04e7306\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e删除一个线程的属性结构\u003c/span\u003e\u003c/p\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003cp id=\"f6a1a765e184a87a3cf062bd79112ab3\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"964bff2b1f299a8123c4564cf6c32159\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e所有的 Pthreads 都有特定的属性，每一个都含有标识符、一组寄存器（包括程序计数器）和一组存储在结构中的属性。这个属性包括堆栈大小、调度参数以及其他线程需要的项目。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"8557a0d1a9c2d19f43f23a025b5b1e9d\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003ch3 id=\"15ab0a3d\"\u003e\u003cspan class=\"ne-text\"\u003e线程实现\u003c/span\u003e\u003c/h3\u003e\u003cp id=\"5e3030d48820fc3f997c9fc07867d415\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"bfec13543c9248ed01602aac8986d3b1\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e主要有三种实现方式\u003c/span\u003e\u003c/p\u003e\u003cp id=\"6ca771c1e461f72989e0d3259a67f52e\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cul class=\"ne-ul\"\u003e\u003cli id=\"7c27924bef969657528fcdaaa609f955\"\u003e\u003cspan class=\"ne-text\"\u003e在用户空间中实现线程；\u003c/span\u003e\u003c/li\u003e\u003cli id=\"600f350c1424b2986a7804ec78dc04b3\"\u003e\u003cspan class=\"ne-text\"\u003e在内核空间中实现线程；\u003c/span\u003e\u003c/li\u003e\u003c/ul\u003e\u003cul class=\"ne-ul\"\u003e\u003cli id=\"edbb0a2cf6d6e63294285f0299dda3fc\"\u003e\u003cspan class=\"ne-text\"\u003e在用户和内核空间中混合实现线程。\u003c/span\u003e\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"4c6f55a17135de2b2291efc72cead4d1\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"83eff6a3553c469021aa6db1dceec0d9\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e下面我们分开讨论一下\u003c/span\u003e\u003c/p\u003e\u003cp id=\"9572d3617e09301baa3ee984f1c92f5c\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003ch4 id=\"9f307c8e\"\u003e\u003cspan class=\"ne-text\"\u003e在用户空间中实现线程\u003c/span\u003e\u003c/h4\u003e\u003cp id=\"42e095da41230932ab0833eed35e4a62\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"95fe62305076810bbdbc0548d37541ba\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e第一种方法是把整个线程包放在用户空间中，内核对线程一无所知，它不知道线程的存在。所有的这类实现都有同样的通用结构\u003c/span\u003e\u003c/p\u003e\u003cp id=\"276d2eb1fdc4a41e4173ea11b35f5cc2\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"7a5fa3aa9f73d81d2fb09d64a02e4f3b\" class=\"ne-p\"\u003e\u003cimg src=\"https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829565-1733358e-dbe8-4e1e-ab32-50b95d98a6e3.png\" width=\"599\" id=\"uVF3u\" class=\"ne-image\"\u003e\u003c/p\u003e\u003cp id=\"994599839f8a0493163453339bc36bf1\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"eff4df6ded311edd97d79b039f96d79d\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e线程在运行时系统之上运行，运行时系统是管理线程过程的集合，包括前面提到的四个过程： pthread_create, pthread_exit, pthread_join 和 pthread_yield。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"9f01a3a063f4e73adb15e108ca6a7eea\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003ch3 id=\"78ffb122\"\u003e\u003cspan class=\"ne-text\"\u003e在内核中实现线程\u003c/span\u003e\u003c/h3\u003e\u003cp id=\"c1f41f5788707afdebb1adada6659535\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"31823d31c3e4c8a1d3e9c4053e65166f\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e当某个线程希望创建一个新线程或撤销一个已有线程时，它会进行一个系统调用，这个系统调用通过对线程表的更新来完成线程创建或销毁工作。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"70941018fd44652b5554c9be911f4bb4\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"74b4ad9f0cf425a882479e7b9fccc210\" class=\"ne-p\"\u003e\u003cimg src=\"https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829600-91569966-c35c-4db1-858b-f7fcae7729c3.png\" width=\"600\" id=\"hh20v\" class=\"ne-image\"\u003e\u003c/p\u003e\u003cp id=\"9be5d4ee6254ece2371dae576e1ce5ed\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"ca2c3a358734c3ac5a68fd4da8a6f6d1\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e内核中的线程表持有每个线程的寄存器、状态和其他信息。这些信息和用户空间中的线程信息相同，但是位置却被放在了内核中而不是用户空间中。另外，内核还维护了一张进程表用来跟踪系统状态。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"5d51544c741cef09fd2074b01c87b917\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"446a4e049bb4f8b4e6d08161a35277b5\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e所有能够阻塞的调用都会通过系统调用的方式来实现，当一个线程阻塞时，内核可以进行选择，是运行在同一个进程中的另一个线程（如果有就绪线程的话）还是运行一个另一个进程中的线程。但是在用户实现中，运行时系统始终运行自己的线程，直到内核剥夺它的 CPU 时间片（或者没有可运行的线程存在了）为止。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"15f0ff35b5546621cdfa2a7240307b67\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003ch3 id=\"26e17fd6\"\u003e\u003cspan class=\"ne-text\"\u003e混合实现\u003c/span\u003e\u003c/h3\u003e\u003cp id=\"b5ee17fce17b6cdbe43273512e22ecb9\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"63976c7cc6bac642a93b4f69c61c73b7\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e结合用户空间和内核空间的优点，设计人员采用了一种\u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e内核级线程\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e的方式，然后将用户级线程与某些或者全部内核线程多路复用起来\u003c/span\u003e\u003c/p\u003e\u003cp id=\"a817d6cedfd6372e5126592d084db2cd\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"065866846bc241326c1231ae19b4e8c3\" class=\"ne-p\"\u003e\u003cimg src=\"https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829624-481cc859-db6d-4516-8dc4-6ea9f958c022.png\" width=\"647\" id=\"z1E6R\" class=\"ne-image\"\u003e\u003c/p\u003e\u003cp id=\"80cc0ff3caab76b5b04463be351d36e6\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"46d3024237e6c858dddb4620413c3f9d\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e在这种模型中，编程人员可以自由控制用户线程和内核线程的数量，具有很大的灵活度。采用这种方法，内核只识别内核级线程，并对其进行调度。其中一些内核级线程会被多个用户级线程多路复用。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"cafd9a2584fc98d82c47a69f4eb4a44a\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003ch2 id=\"13747cb9\"\u003e\u003cspan class=\"ne-text\"\u003e进程间通信\u003c/span\u003e\u003c/h2\u003e\u003cp id=\"89f23068c1d014c8ae7379c1ee4ff256\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"ae233faa7b8916909e1f871f4d9ceb06\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e进程是需要频繁的和其他进程进行交流的。下面我们会一起讨论有关 \u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e进程间通信(Inter Process Communication, IPC)\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e 的问题。大致来说，进程间的通信机制可以分为 6 种\u003c/span\u003e\u003c/p\u003e\u003cp id=\"dfe97806c12fe7f893011f144d1a8165\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"bc4ca741dee963edba6ac3cea886b95e\" class=\"ne-p\"\u003e\u003cimg src=\"https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829616-22b9e251-36fa-4a65-8102-204b899c01ca.png\" width=\"772\" id=\"WxiTX\" class=\"ne-image\"\u003e\u003c/p\u003e\u003cp id=\"13d5bccfbad5a2bc08c0ae4830359792\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"2cc0c61db915799a3dab5663db6d75de\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e下面我们分别对其进行概述\u003c/span\u003e\u003c/p\u003e\u003cp id=\"7666fa53af51829ddb54296233381012\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003ch3 id=\"cf09c6fb\"\u003e\u003cspan class=\"ne-text\"\u003e信号 signal\u003c/span\u003e\u003c/h3\u003e\u003cp id=\"f2d6f42f7be9db0ef2e31f6e6bec3b21\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"f56f26bead6812e39ebd085c6282a029\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e信号是 UNIX 系统最先开始使用的进程间通信机制，因为 Linux 是继承于 UNIX 的，所以 Linux 也支持信号机制，通过向一个或多个进程发送\u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e异步事件信号\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e来实现，信号可以从键盘或者访问不存在的位置等地方产生；信号通过 shell 将任务发送给子进程。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"77a00de06ad8a313624bebd7197daab0\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"c3a46e2f457eb12ac07b2735125ed640\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e你可以在 Linux 系统上输入 \u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003ekill -l\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e 来列出系统使用的信号，下面是我提供的一些信号\u003c/span\u003e\u003c/p\u003e\u003cp id=\"b6d3f3b7ee125b00a6385d6a05e9c790\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"c332f05576b8b21614e769f51765e046\" class=\"ne-p\"\u003e\u003cimg src=\"https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829652-e25e8aaa-523f-49e7-91a6-13af7872483a.png\" width=\"736\" id=\"iFTA7\" class=\"ne-image\"\u003e\u003c/p\u003e\u003cp id=\"e94793bcd68a9f5383857361c260794e\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"1e0b0c18d976e2cb412fe31f463b0b70\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e进程可以选择忽略发送过来的信号，但是有两个是不能忽略的：\u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003eSIGSTOP\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e 和 \u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003eSIGKILL\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e 信号。SIGSTOP 信号会通知当前正在运行的进程执行关闭操作，SIGKILL 信号会通知当前进程应该被杀死。除此之外，进程可以选择它想要处理的信号，进程也可以选择阻止信号，如果不阻止，可以选择自行处理，也可以选择进行内核处理。如果选择交给内核进行处理，那么就执行默认处理。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"f463e7202028da7ee34fa86439d2d0bc\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"97307b7fc6bb2a3d3a6c7415c2d1a58f\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e操作系统会中断目标程序的进程来向其发送信号、在任何非原子指令中，执行都可以中断，如果进程已经注册了新号处理程序，那么就执行进程，如果没有注册，将采用默认处理的方式。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"f0d78f86dcc225fbef3bc7ca4b9c2eae\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003ch3 id=\"79c52210\"\u003e\u003cspan class=\"ne-text\"\u003e管道 pipe\u003c/span\u003e\u003c/h3\u003e\u003cp id=\"e581372206c587ee595cd8880c7fe68c\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"7d6b1edbc43ab03cd76e374db13b3d79\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003eLinux 系统中的进程可以通过建立管道 pipe 进行通信\u003c/span\u003e\u003c/p\u003e\u003cp id=\"8ccfe4d2fc3be296206ee867a830076f\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"e4d7d6e07cdeb822a190325504719442\" class=\"ne-p\"\u003e\u003cimg src=\"https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829658-0cfbf5f9-97b3-4972-8205-7953cdab82b7.png\" width=\"729\" id=\"UyA6r\" class=\"ne-image\"\u003e\u003c/p\u003e\u003cp id=\"b1d8ec45d3bd885ef634b40206c6be13\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"94564611bd47217e8819b4129456507f\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e在两个进程之间，可以建立一个通道，一个进程向这个通道里写入字节流，另一个进程从这个管道中读取字节流。管道是同步的，当进程尝试从空管道读取数据时，该进程会被阻塞，直到有可用数据为止。shell 中的\u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e管线 pipelines\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e 就是用管道实现的，当 shell 发现输出\u003c/span\u003e\u003c/p\u003e\u003cp id=\"f6df0669510949bc580d81d8ca93eb12\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cpre data-language=\"null\" id=\"8f337cd0\" class=\"ne-codeblock language-null\"\u003esort \u0026lt;f | head\u003c/pre\u003e\u003cp id=\"41e8a4181b2a6e81046de5357f803804\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"b87e76fec29ab8fc296c13120144f137\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e它会创建两个进程，一个是 sort，一个是 head，sort，会在这两个应用程序之间建立一个管道使得 sort 进程的标准输出作为 head 程序的标准输入。sort 进程产生的输出就不用写到文件中了，如果管道满了系统会停止 sort 以等待 head 读出数据\u003c/span\u003e\u003c/p\u003e\u003cp id=\"2dde603cd64cf50dcaf8d9d7df59a61f\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"5e1bfd07d47f7ada8a6d809c79141d39\" class=\"ne-p\"\u003e\u003cimg src=\"https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829684-0f55014e-302f-4dbe-9ea8-9ee4d6c9fdeb.png\" width=\"488\" id=\"irplH\" class=\"ne-image\"\u003e\u003c/p\u003e\u003cp id=\"5e74f9a53149c90944e0bad4389f82c3\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"57493598a8059c5e29d760919d110090\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e管道实际上就是 \u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e|\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e，两个应用程序不知道有管道的存在，一切都是由 shell 管理和控制的。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"9135a0a2091dee1a4cfbf8c684405913\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003ch3 id=\"72b83631\"\u003e\u003cspan class=\"ne-text\"\u003e共享内存 shared memory\u003c/span\u003e\u003c/h3\u003e\u003cp id=\"b441fd0f50991bc8fbdb133ed2bfecc1\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"5c9437460a98ec5c1b1963be737e891a\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e两个进程之间还可以通过共享内存进行进程间通信，其中两个或者多个进程可以访问公共内存空间。两个进程的共享工作是通过共享内存完成的，一个进程所作的修改可以对另一个进程可见(很像线程间的通信)。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"3b7e81fdce6f289a7b5b128d1c5890be\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"84515a95f3770ad7ac1586bd0d382886\" class=\"ne-p\"\u003e\u003cimg src=\"https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829708-7158a6ec-203c-42aa-96bb-7946e3fb959a.png\" width=\"659\" id=\"WYSoT\" class=\"ne-image\"\u003e\u003c/p\u003e\u003cp id=\"d4fb40df164d63a65f225277e42634fa\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"caab3879748d4be435662e13c24b3335\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e在使用共享内存前，需要经过一系列的调用流程，流程如下\u003c/span\u003e\u003c/p\u003e\u003cp id=\"c59ad6e8a32a354abe821f6b1d455495\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cul class=\"ne-ul\"\u003e\u003cli id=\"eaf12986b718d744584491248cd9ad59\"\u003e\u003cspan class=\"ne-text\"\u003e创建共享内存段或者使用已创建的共享内存段\u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e(shmget())\u003c/span\u003e\u003c/code\u003e\u003c/li\u003e\u003cli id=\"07722001603dcec1909ffeebbc9bbba5\"\u003e\u003cspan class=\"ne-text\"\u003e将进程附加到已经创建的内存段中\u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e(shmat())\u003c/span\u003e\u003c/code\u003e\u003c/li\u003e\u003c/ul\u003e\u003cul class=\"ne-ul\"\u003e\u003cli id=\"c08827f8c1685d8ec2163aebf19295b9\"\u003e\u003cspan class=\"ne-text\"\u003e从已连接的共享内存段分离进程\u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e(shmdt())\u003c/span\u003e\u003c/code\u003e\u003c/li\u003e\u003cli id=\"8cd7c3fb9d858dcc81002e015465844d\"\u003e\u003cspan class=\"ne-text\"\u003e对共享内存段执行控制操作\u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e(shmctl())\u003c/span\u003e\u003c/code\u003e\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"8b6f722bbcdffe424e246ed3a95b9cec\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003ch3 id=\"c4f8f8c1\"\u003e\u003cspan class=\"ne-text\"\u003e先入先出队列 FIFO\u003c/span\u003e\u003c/h3\u003e\u003cp id=\"52767acac0b583fa16bd52993f2cff1a\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"a66eca62deab14281ed14fd5255e4c7c\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e先入先出队列 FIFO 通常被称为 \u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e命名管道(Named Pipes)\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e，命名管道的工作方式与常规管道非常相似，但是确实有一些明显的区别。未命名的管道没有备份文件：操作系统负责维护内存中的缓冲区，用来将字节从写入器传输到读取器。一旦写入或者输出终止的话，缓冲区将被回收，传输的数据会丢失。相比之下，命名管道具有支持文件和独特 API ，命名管道在文件系统中作为设备的专用文件存在。当所有的进程通信完成后，命名管道将保留在文件系统中以备后用。命名管道具有严格的 FIFO 行为\u003c/span\u003e\u003c/p\u003e\u003cp id=\"4c4130835544d2e4037541a399c00274\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"518b30630e1757de83724356bf420c6f\" class=\"ne-p\"\u003e\u003cimg src=\"https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829713-f872efe8-5031-4f02-89ad-8c8351a854c7.png\" width=\"584\" id=\"gHPi1\" class=\"ne-image\"\u003e\u003c/p\u003e\u003cp id=\"64556edd5c72d351442d4c215bd78afa\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"ad02a68ae4b9a278228e0e65be24c577\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e写入的第一个字节是读取的第一个字节，写入的第二个字节是读取的第二个字节，依此类推。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"cacfa57508b4cbca4112ae43dda31420\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003ch3 id=\"cf4ddbc3\"\u003e\u003cspan class=\"ne-text\"\u003e消息队列 Message Queue\u003c/span\u003e\u003c/h3\u003e\u003cp id=\"f3a9949035996a711f2acc9e1cb8a548\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"502aac7079420863be2b507a816dad7f\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e一听到消息队列这个名词你可能不知道是什么意思，消息队列是用来描述内核寻址空间内的内部链接列表。可以按几种不同的方式将消息按顺序发送到队列并从队列中检索消息。每个消息队列由 IPC 标识符唯一标识。消息队列有两种模式，一种是\u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e严格模式\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e， 严格模式就像是 FIFO 先入先出队列似的，消息顺序发送，顺序读取。还有一种模式是 \u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e非严格模式\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e，消息的顺序性不是非常重要。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"76610295702efeb67524a09a51ca022c\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003ch3 id=\"fbaf7bbe\"\u003e\u003cspan class=\"ne-text\"\u003e套接字 Socket\u003c/span\u003e\u003c/h3\u003e\u003cp id=\"9f141557fe97223eea8773c539b9552a\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"28af2f3a58533de88a523266b8f66673\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e还有一种管理两个进程间通信的是使用 \u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003esocket\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e，socket 提供端到端的双相通信。一个套接字可以与一个或多个进程关联。就像管道有命令管道和未命名管道一样，套接字也有两种模式，套接字一般用于两个进程之间的网络通信，网络套接字需要来自诸如\u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003eTCP（传输控制协议）\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e或较低级别\u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003eUDP（用户数据报协议）\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e等基础协议的支持。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"8c6d6b235890be26598ba16ff7a067fe\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"203016d407ce5eb34e08849dadb79d88\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e套接字有以下几种分类\u003c/span\u003e\u003c/p\u003e\u003cp id=\"854024933d86bf7a4d7c66a6b9ea755a\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cul class=\"ne-ul\"\u003e\u003cli id=\"d8b2232e1900fd6705f4245543d5376b\"\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e顺序包套接字(Sequential Packet Socket)\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e： 此类套接字为最大长度固定的数据报提供可靠的连接。此连接是双向的并且是顺序的。\u003c/span\u003e\u003c/li\u003e\u003cli id=\"d95a76dd1ca1ff9e7882c7f123319b54\"\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e数据报套接字(Datagram Socket)\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e：数据包套接字支持双向数据流。数据包套接字接受消息的顺序与发送者可能不同。\u003c/span\u003e\u003c/li\u003e\u003c/ul\u003e\u003cul class=\"ne-ul\"\u003e\u003cli id=\"055798b0b774376247582b29b38e9e51\"\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e流式套接字(Stream Socket)\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e：流套接字的工作方式类似于电话对话，提供双向可靠的数据流。\u003c/span\u003e\u003c/li\u003e\u003cli id=\"485881b289944fc9644438d0af5b2bab\"\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e原始套接字(Raw Socket)\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e： 可以使用原始套接字访问基础通信协议。\u003c/span\u003e\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"06fb91a72234b4c3fa8fe3c525213a6c\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003ch2 id=\"b088138c\"\u003e\u003cspan class=\"ne-text\"\u003e调度\u003c/span\u003e\u003c/h2\u003e\u003cp id=\"db46aa2e41d292eabf878a29ae6e1eb9\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"ac80db1c477dc4d61938c67e1e24cf4e\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e当一个计算机是多道程序设计系统时，会频繁的有很多进程或者线程来同时竞争 CPU 时间片。当两个或两个以上的进程/线程处于就绪状态时，就会发生这种情况。如果只有一个 CPU 可用，那么必须选择接下来哪个进程/线程可以运行。操作系统中有一个叫做 \u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e调度程序(scheduler)\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e 的角色存在，它就是做这件事儿的，该程序使用的算法叫做 \u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e调度算法(scheduling algorithm)\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e 。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"1ff7123ceb621d6eaa21f166661d48b5\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003ch3 id=\"3b22ed94\"\u003e\u003cspan class=\"ne-text\"\u003e调度算法的分类\u003c/span\u003e\u003c/h3\u003e\u003cp id=\"0536eab6c3f4f86d8c9e1eb4c2caa9ce\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"50c7a2aa3ff0a2a07aaaabc9d81745d1\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e毫无疑问，不同的环境下需要不同的调度算法。之所以出现这种情况，是因为不同的应用程序和不同的操作系统有不同的目标。也就是说，在不同的系统中，调度程序的优化也是不同的。这里有必要划分出三种环境\u003c/span\u003e\u003c/p\u003e\u003cp id=\"df6c20d6e0a6232273f0d1601c76cabd\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cul class=\"ne-ul\"\u003e\u003cli id=\"0d3206be3b8ae11db093294df323407e\"\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e批处理(Batch)\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e : 商业领域\u003c/span\u003e\u003c/li\u003e\u003cli id=\"e9309e368b52d8797ac81aed29cd060e\"\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e交互式(Interactive)\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e ： 交互式用户环境\u003c/span\u003e\u003c/li\u003e\u003c/ul\u003e\u003cul class=\"ne-ul\"\u003e\u003cli id=\"efe0fd41056503e2ca46a96cc1fbf80a\"\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e实时(Real time)\u003c/span\u003e\u003c/code\u003e\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"630e123e440c743aa695a6f16637ef25\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003ch3 id=\"cc6a2057\"\u003e\u003cspan class=\"ne-text\"\u003e批处理中的调度\u003c/span\u003e\u003c/h3\u003e\u003cp id=\"337455c979553991e97c1bdf5f17b0ec\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"abd9e19e95f4d0564da8037374dd3741\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e现在让我们把目光从一般性的调度转换为特定的调度算法。下面我们会探讨在批处理中的调度。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"7dc9c8578156af1d69a73bd6804b3cdf\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003ch4 id=\"400c234c\"\u003e\u003cspan class=\"ne-text\"\u003e先来先服务\u003c/span\u003e\u003c/h4\u003e\u003cp id=\"50d75b4163179fa5fa7fc840e8287dc1\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"52ddec5249cbe7ff90aa61f7d024e8d0\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e最简单的非抢占式调度算法的设计就是 \u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e先来先服务(first-come,first-serverd)\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e。当第一个任务从外部进入系统时，将会立即启动并允许运行任意长的时间。它不会因为运行时间太长而中断。当其他作业进入时，它们排到就绪队列尾部。当正在运行的进程阻塞，处于等待队列的第一个进程就开始运行。当一个阻塞的进程重新处于就绪态时，它会像一个新到达的任务，会排在队列的末尾，即排在所有进程最后。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"16c8c47a7ed1c45b2de1234c1bb04c16\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"95d765b412db9d37d883066bcc827d68\" class=\"ne-p\"\u003e\u003cimg src=\"https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829697-a9e6978f-5f26-4491-8a57-4691ea81546b.png\" width=\"709\" id=\"fZNys\" class=\"ne-image\"\u003e\u003c/p\u003e\u003cp id=\"d04f25840bac9f45b0816d3340b83e6f\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"366e0b92b10f32bf06f3957591c4d306\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e这个算法的强大之处在于易于理解和编程，在这个算法中，一个单链表记录了所有就绪进程。要选取一个进程运行，只要从该队列的头部移走一个进程即可；要添加一个新的作业或者阻塞一个进程，只要把这个作业或进程附加在队列的末尾即可。这是很简单的一种实现。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"c90bc0690170107bb9cc1bfcf44a1869\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003ch4 id=\"6b3d276b\"\u003e\u003cspan class=\"ne-text\"\u003e最短作业优先\u003c/span\u003e\u003c/h4\u003e\u003cp id=\"7ae3f2475901cff482d976aea0dcce3d\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"468e7a05528290bbd0be1d2d98c139b5\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e批处理中，第二种调度算法是 \u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e最短作业优先(Shortest Job First)\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e，我们假设运行时间已知。例如，一家保险公司，因为每天要做类似的工作，所以人们可以相当精确地预测处理 1000 个索赔的一批作业需要多长时间。当输入队列中有若干个同等重要的作业被启动时，调度程序应使用最短优先作业算法\u003c/span\u003e\u003c/p\u003e\u003cp id=\"bbea4d15d597e1b2dbbcb2ec89f4bb11\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"a517b18d42d12e1b8a78a7509be7885f\" class=\"ne-p\"\u003e\u003cimg src=\"https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829752-b3677366-5828-45be-9c62-d182dce0a26e.png\" width=\"695\" id=\"LgBd9\" class=\"ne-image\"\u003e\u003c/p\u003e\u003cp id=\"f1c689fa90494cf32bd7f6aec4ba09af\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cdiv class=\"ne-quote\"\u003e\u003cp id=\"b6c055d28c6fdd14f00876b918817a67\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e需要注意的是，在所有的进程都可以运行的情况下，最短作业优先的算法才是最优的。\u003c/span\u003e\u003c/p\u003e\u003c/div\u003e\u003cp id=\"3a11d311f7f2e5161f91e1442bf04adc\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003ch4 id=\"0333fbb6\"\u003e\u003cspan class=\"ne-text\"\u003e最短剩余时间优先\u003c/span\u003e\u003c/h4\u003e\u003cp id=\"92ead72ad4d93735b706d26474e6a2e4\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"de6d4308827fa52aa18b1fc1eb0c02db\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e最短作业优先的抢占式版本被称作为 \u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e最短剩余时间优先(Shortest Remaining Time Next)\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e 算法。使用这个算法，调度程序总是选择剩余运行时间最短的那个进程运行。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"b3ae427a7dda06a6f658ab859d284ec9\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003ch3 id=\"3741716d\"\u003e\u003cspan class=\"ne-text\"\u003e交互式系统中的调度\u003c/span\u003e\u003c/h3\u003e\u003cp id=\"422ebaab9625add00d44934dd813586f\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"5137e8748df6e262c0ad40bc23d1ac26\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e交互式系统中在个人计算机、服务器和其他系统中都是很常用的，所以有必要来探讨一下交互式调度\u003c/span\u003e\u003c/p\u003e\u003cp id=\"b7b5379045dd5e6e2189718effe74ae0\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003ch4 id=\"8bea3bc8\"\u003e\u003cspan class=\"ne-text\"\u003e轮询调度\u003c/span\u003e\u003c/h4\u003e\u003cp id=\"c5e4cc242c8c1a6b1a380f5ffb966ab1\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"26df182ec60081d548dae5cbd53321de\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e一种最古老、最简单、最公平并且最广泛使用的算法就是 \u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e轮询算法(round-robin)\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e。每个进程都会被分配一个时间段，称为\u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e时间片(quantum)\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e，在这个时间片内允许进程运行。如果时间片结束时进程还在运行的话，则抢占一个 CPU 并将其分配给另一个进程。如果进程在时间片结束前阻塞或结束，则 CPU 立即进行切换。轮询算法比较容易实现。调度程序所做的就是维护一个可运行进程的列表，就像下图中的 a，当一个进程用完时间片后就被移到队列的末尾，就像下图的 b。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"2a48ba8c954dab1a6cbe6acc552135f3\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"ad704eaa039166852e0fd5cd8ee74b31\" class=\"ne-p\"\u003e\u003cimg src=\"https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829772-8a1f4a69-9934-4cf9-b1bd-80a69f410e13.png\" width=\"724\" id=\"Zwr0C\" class=\"ne-image\"\u003e\u003c/p\u003e\u003cp id=\"a0dd0fcd6b9dfa625206206a78e03ac6\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003ch4 id=\"88650772\"\u003e\u003cspan class=\"ne-text\"\u003e优先级调度\u003c/span\u003e\u003c/h4\u003e\u003cp id=\"59456b117bfb3b8f23d61c02b4b66490\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"2286b41a5fbc982ed667d87f5fb1518f\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e轮询调度假设了所有的进程是同等重要的。但事实情况可能不是这样。例如，在一所大学中的等级制度，首先是院长，然后是教授、秘书、后勤人员，最后是学生。这种将外部情况考虑在内就实现了\u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e优先级调度(priority scheduling)\u003c/span\u003e\u003c/code\u003e\u003c/p\u003e\u003cp id=\"a4784b0754fc345730f6757657160021\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"c011fa04b7f2812398f076cb4e99b1fd\" class=\"ne-p\"\u003e\u003cimg src=\"https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829781-669962be-9966-4de1-be47-f3e9822459eb.png\" width=\"678\" id=\"Lt9Nc\" class=\"ne-image\"\u003e\u003c/p\u003e\u003cp id=\"417688711448227baa00b80a4ddecb3f\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"c6dc6554e74b480c52c7a694b6a90a73\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e它的基本思想很明确，每个进程都被赋予一个优先级，优先级高的进程优先运行。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"9121719585434ff2f0a1fca66a3e46d5\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003ch4 id=\"edc1014b\"\u003e\u003cspan class=\"ne-text\"\u003e多级队列\u003c/span\u003e\u003c/h4\u003e\u003cp id=\"6e60cd02590664c4b1a39db6543af092\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"017210b6aad11b943d3912c5cffa57e5\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e最早使用优先级调度的系统是 \u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003eCTSS(Compatible TimeSharing System)\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e。CTSS 在每次切换前都需要将当前进程换出到磁盘，并从磁盘上读入一个新进程。为 CPU 密集型进程设置较长的时间片比频繁地分给他们很短的时间要更有效（减少交换次数）。另一方面，如前所述，长时间片的进程又会影响到响应时间，解决办法是设置优先级类。属于最高优先级的进程运行一个时间片，次高优先级进程运行 2 个时间片，再下面一级运行 4 个时间片，以此类推。当一个进程用完分配的时间片后，它被移到下一类。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"bae603c7682382f7e3af58359797cb99\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003ch4 id=\"9e5db475\"\u003e\u003cspan class=\"ne-text\"\u003e最短进程优先\u003c/span\u003e\u003c/h4\u003e\u003cp id=\"d3fd5aec5606c3f51805ab6ba705c676\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"c1612c156911dcadfd48e601dc6cff0a\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e最短进程优先是根据进程过去的行为进行推测，并执行估计运行时间最短的那一个。假设每个终端上每条命令的预估运行时间为 \u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003eT0\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e，现在假设测量到其下一次运行时间为 \u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003eT1\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e，可以用两个值的加权来改进估计时间，即\u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003eaT0+ (1- 1)T1\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e。通过选择 a 的值，可以决定是尽快忘掉老的运行时间，还是在一段长时间内始终记住它们。当 a = 1/2 时，可以得到下面这个序列\u003c/span\u003e\u003c/p\u003e\u003cp id=\"6769b00d23ae9769141733ed8b1fcd6d\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"091226d35ecf107e9b32444780d14bcc\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e![image-20200220120452410](/Users/mr.l/Library/Application Support/typora-user-images/image-20200220120452410.png)\u003c/span\u003e\u003c/p\u003e\u003cp id=\"c46a33578ba15bf3a896acf4a7439d4b\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"b84ae544ee7149cb676643c21f7c4002\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e可以看到，在三轮过后，T0 在新的估计值中所占比重下降至 1/8。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"a1f413692778469baa56acbd5ffcf6d0\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003ch4 id=\"5abf2b05\"\u003e\u003cspan class=\"ne-text\"\u003e保证调度\u003c/span\u003e\u003c/h4\u003e\u003cp id=\"01ce9b320999207d18ddc9192f428dbc\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"8a68e211434a7f5613ac4f8218909916\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e一种完全不同的调度方法是对用户做出明确的性能保证。一种实际而且容易实现的保证是：若用户工作时有 n 个用户登录，则每个用户将获得 CPU 处理能力的 1/n。类似地，在一个有 n 个进程运行的单用户系统中，若所有的进程都等价，则每个进程将获得 1/n 的 CPU 时间。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"bad28048c33e866f65513743c9071379\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003ch4 id=\"6d170350\"\u003e\u003cspan class=\"ne-text\"\u003e彩票调度\u003c/span\u003e\u003c/h4\u003e\u003cp id=\"1ec63cbf9f419d479434f9b178b91ee5\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"c994c1728228b0f8690b76ebfde67d27\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e对用户进行承诺并在随后兑现承诺是一件好事，不过很难实现。但是存在着一种简单的方式，有一种既可以给出预测结果而又有一种比较简单的实现方式的算法，就是 \u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e彩票调度(lottery scheduling)\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e算法。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"7a64ea69d571753adc711f3065ec5eb9\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"009f3b9dc6647cecef4e0f5e64e84e09\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e其基本思想是为进程提供各种系统资源（例如 CPU 时间）的彩票。当做出一个调度决策的时候，就随机抽出一张彩票，拥有彩票的进程将获得该资源。在应用到 CPU 调度时，系统可以每秒持有 50 次抽奖，每个中奖者将获得比如 20 毫秒的 CPU 时间作为奖励。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"21e629b1eaa9fcd18efe030f5360b954\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003ch4 id=\"f52d1789\"\u003e\u003cspan class=\"ne-text\"\u003e公平分享调度\u003c/span\u003e\u003c/h4\u003e\u003cp id=\"454ce166479faf6b0bac6a5a1d950fc0\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"3e7328aa85fbda7ea81e5451ecd63f55\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e到目前为止，我们假设被调度的都是各个进程自身，而不用考虑该进程的拥有者是谁。结果是，如果用户 1 启动了 9 个进程，而用户 2 启动了一个进程，使用轮转或相同优先级调度算法，那么用户 1 将得到 90 % 的 CPU 时间，而用户 2 将之得到 10 % 的 CPU 时间。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"247ab6cb450a5c6c2432cec96ed7ec6e\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"a8997400e66c5b2d256fccc7ea3776bf\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e为了阻止这种情况的出现，一些系统在调度前会把进程的拥有者考虑在内。在这种模型下，每个用户都会分配一些CPU 时间，而调度程序会选择进程并强制执行。因此如果两个用户每个都会有 50% 的 CPU 时间片保证，那么无论一个用户有多少个进程，都将获得相同的 CPU 份额。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"25cfa5c1dd3833edf698f7172bb0cd48\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"8a2de1e6a6957d4a3a1cd8ddd4f15cf3\" class=\"ne-p\"\u003e\u003cimg src=\"https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829805-f1649640-92c0-4cc0-9d11-d33091868df3.png\" width=\"681\" id=\"s6DG8\" class=\"ne-image\"\u003e\u003c/p\u003e\u003cp id=\"a71b4648e92abc3a0a98e890305bbfc7\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003ch3 id=\"e87fdf39\"\u003e\u003cspan class=\"ne-text\"\u003e实时系统中的调度\u003c/span\u003e\u003c/h3\u003e\u003cp id=\"65e73472811dc36880ee811fac3bfc94\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"2f7c753cdac04c87a34af91ae1219692\" class=\"ne-p\"\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e实时系统(real-time)\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e 是一个时间扮演了重要作用的系统。实时系统可以分为两类，\u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e硬实时(hard real time)\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e 和 \u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e软实时(soft real time)\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e 系统，前者意味着必须要满足绝对的截止时间；后者的含义是虽然不希望偶尔错失截止时间，但是可以容忍。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"670523a1b5511e2dbbe7df30ea900b9d\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"f974b8ccc4e8617c2d30cf67ec750345\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e实时系统中的事件可以按照响应方式进一步分类为\u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e周期性(以规则的时间间隔发生)\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e事件或 \u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e非周期性(发生时间不可预知)\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e事件。一个系统可能要响应多个周期性事件流，根据每个事件处理所需的时间，可能甚至无法处理所有事件。例如，如果有 m 个周期事件，事件 i 以周期 Pi 发生，并需要 Ci 秒 CPU 时间处理一个事件，那么可以处理负载的条件是\u003c/span\u003e\u003c/p\u003e\u003cp id=\"d8cf2cf43fb9725d8547f64247372780\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"0d5983b3ee8a785dc8f03c345ec7a943\" class=\"ne-p\"\u003e\u003cimg src=\"https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829813-d541b483-e6c2-4e61-b29d-faf9719ce83f.png\" width=\"180\" id=\"ufEZW\" class=\"ne-image\"\u003e\u003c/p\u003e\u003cp id=\"97acdb638c547195b6ef846c1e51b89f\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"ef8f27436da7fb3f3e483c323e3bf505\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e只有满足这个条件的实时系统称为\u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e可调度的\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e，这意味着它实际上能够被实现。一个不满足此检验标准的进程不能被调度，因为这些进程共同需要的 CPU 时间总和大于 CPU 能提供的时间。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"253e9dd88734332a7e277657f4bbe7aa\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"84fb8043025bc72a7a331f4b2038fec9\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e下面我们来了解一下内存管理，你需要知道的知识点如下\u003c/span\u003e\u003c/p\u003e\u003cp id=\"be344a47b1bc97136a272661dcae26ab\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"08d4a9f1f09106f5567bc8cd8ce5f2ea\" class=\"ne-p\"\u003e\u003cimg src=\"https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829871-ad9be6cd-aa53-4acc-b245-5dd76199a6ba.png\" width=\"742\" id=\"qZ8YJ\" class=\"ne-image\"\u003e\u003c/p\u003e\u003cp id=\"897f56e4266d6ddefb7a80f14fdc066f\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003ch2 id=\"f8c25083\"\u003e\u003cspan class=\"ne-text\"\u003e地址空间\u003c/span\u003e\u003c/h2\u003e\u003cp id=\"bde8f9f383388c601478c74a93453ac7\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"ec6517c213e0ba8f57072f457233836a\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e如果要使多个应用程序同时运行在内存中，必须要解决两个问题：\u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e保护\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e和 \u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e重定位\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e。第一种解决方式是用\u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e保护密钥标记内存块\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e，并将执行过程的密钥与提取的每个存储字的密钥进行比较。这种方式只能解决第一种问题（破坏操作系统），但是不能解决多进程在内存中同时运行的问题。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"5a59697a4c5abbfa70470c3bd42ae884\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"edaf48dfdb5c68281fed3d81ca91c83e\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e还有一种更好的方式是创造一个存储器抽象：\u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e地址空间(the address space)\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e。就像进程的概念创建了一种抽象的 CPU 来运行程序，地址空间也创建了一种抽象内存供程序使用。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"8b864388ad7cbe940f6df98cf8047f40\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003ch4 id=\"dc58b76e\"\u003e\u003cspan class=\"ne-text\"\u003e基址寄存器和变址寄存器\u003c/span\u003e\u003c/h4\u003e\u003cp id=\"688b9c8ffedbb24b760571665f734e30\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"34958411ca47c301b7e17928791bbede\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e最简单的办法是使用\u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e动态重定位(dynamic relocation)\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e技术，它就是通过一种简单的方式将每个进程的地址空间映射到物理内存的不同区域。还有一种方式是使用基址寄存器和变址寄存器。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"aa38b2f5d51810e34c165ded7b78d47d\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cul class=\"ne-ul\"\u003e\u003cli id=\"e880fdf6fcd3d032a4341180b8593207\"\u003e\u003cspan class=\"ne-text\"\u003e基址寄存器：存储数据内存的起始位置\u003c/span\u003e\u003c/li\u003e\u003cli id=\"d832ace055abe375212e5ebc6c6de94c\"\u003e\u003cspan class=\"ne-text\"\u003e变址寄存器：存储应用程序的长度。\u003c/span\u003e\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"85d454c1417111a0069356a762f1ad16\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"c96b02a131713a5288237b39959a7848\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e每当进程引用内存以获取指令或读取、写入数据时，CPU 都会自动将\u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e基址值\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e添加到进程生成的地址中，然后再将其发送到内存总线上。同时，它检查程序提供的地址是否大于或等于\u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e变址寄存器\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e 中的值。如果程序提供的地址要超过变址寄存器的范围，那么会产生错误并中止访问。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"657477406dfb1d962867bf48ef305165\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003ch3 id=\"4c736ad5\"\u003e\u003cspan class=\"ne-text\"\u003e交换技术\u003c/span\u003e\u003c/h3\u003e\u003cp id=\"2fc583f502358c13597da6fff3de80fd\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"8c95f9eaf3a6186e888348475003c367\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e在程序运行过程中，经常会出现内存不足的问题。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"ddf8522ed4c5cc50a55556b7984536bc\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"8938c8e1fd6a3f0862e0a2c359b11055\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e针对上面内存不足的问题，提出了两种处理方式：最简单的一种方式就是\u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e交换(swapping)\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e技术，即把一个进程完整的调入内存，然后再内存中运行一段时间，再把它放回磁盘。空闲进程会存储在磁盘中，所以这些进程在没有运行时不会占用太多内存。另外一种策略叫做\u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e虚拟内存(virtual memory)\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e，虚拟内存技术能够允许应用程序部分的运行在内存中。下面我们首先先探讨一下交换\u003c/span\u003e\u003c/p\u003e\u003cp id=\"3ad35936eb8cb28c5c2fa936042097bd\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003ch4 id=\"7e402db3\"\u003e\u003cspan class=\"ne-text\"\u003e交换过程\u003c/span\u003e\u003c/h4\u003e\u003cp id=\"4d79d791ebde11eac836417d99a83a32\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"de4f76e258b0deaab8ec99cb01bfa6ef\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e下面是一个交换过程\u003c/span\u003e\u003c/p\u003e\u003cp id=\"716222faf1c7f3ed190c4114812ce6f8\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"6ccc90eceb94b75a14c9d216c722138a\" class=\"ne-p\"\u003e\u003cimg src=\"https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829844-31f0d41e-db06-4f4a-86d4-15250999e2dd.png\" width=\"724\" id=\"PM0yA\" class=\"ne-image\"\u003e\u003c/p\u003e\u003cp id=\"dc7cc2c39c8d3f304020512f8ff9b9bc\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"996bc77c0dba2ac7b6d7396b4b5ca492\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e刚开始的时候，只有进程 A 在内存中，然后从创建进程 B 和进程 C 或者从磁盘中把它们换入内存，然后在图 d 中，A 被换出内存到磁盘中，最后 A 重新进来。因为图 g 中的进程 A 现在到了不同的位置，所以在装载过程中需要被重新定位，或者在交换程序时通过软件来执行；或者在程序执行期间通过硬件来重定位。基址寄存器和变址寄存器就适用于这种情况。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"85a1527560367b27f342301a635faa1d\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"25bb57681bc250f1818434d7d35b4930\" class=\"ne-p\"\u003e\u003cimg src=\"https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829879-4fde9a55-0c36-4d7d-948a-49841539d0c8.png\" width=\"696\" id=\"SC4tr\" class=\"ne-image\"\u003e\u003c/p\u003e\u003cp id=\"4acee99ad01bb62a54a2e2bd553446b8\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"2d984474d589be5f5955c2ce294ec16e\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e交换在内存创建了多个 \u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e空闲区(hole)\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e，内存会把所有的空闲区尽可能向下移动合并成为一个大的空闲区。这项技术称为\u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e内存紧缩(memory compaction)\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e。但是这项技术通常不会使用，因为这项技术会消耗很多 CPU 时间。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"b28c8d2e8428888c6adf339dc61047f2\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003ch3 id=\"6bbc8b2f\"\u003e\u003cspan class=\"ne-text\"\u003e空闲内存管理\u003c/span\u003e\u003c/h3\u003e\u003cp id=\"6fd3637e0cb8f6d3d237425a70b8067f\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"2050198cea7f2d6fa1fddd5ac13c4444\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e在进行内存动态分配时，操作系统必须对其进行管理。大致上说，有两种监控内存使用的方式\u003c/span\u003e\u003c/p\u003e\u003cp id=\"79f8b96bcfca73171c3a49ff9cfbf205\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cul class=\"ne-ul\"\u003e\u003cli id=\"e72421e316cd2ca7ca62cdeb089ee797\"\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e位图(bitmap)\u003c/span\u003e\u003c/code\u003e\u003c/li\u003e\u003cli id=\"363344e59979446380ae415574aa7cd0\"\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e空闲列表(free lists)\u003c/span\u003e\u003c/code\u003e\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"b610fbf0037c478e4c50c66707220a71\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003ch4 id=\"bcd570ff\"\u003e\u003cspan class=\"ne-text\"\u003e使用位图的存储管理\u003c/span\u003e\u003c/h4\u003e\u003cp id=\"1b793a00e7d2c49c89beb25f52ff969b\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"01106bad7b2d039f9d53f44c574b3c78\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e使用位图方法时，内存可能被划分为小到几个字或大到几千字节的分配单元。每个分配单元对应于位图中的一位，0 表示空闲， 1 表示占用（或者相反）。一块内存区域和其对应的位图如下\u003c/span\u003e\u003c/p\u003e\u003cp id=\"f9fd09e0470dab41be4f170ebe495874\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"d2fd7e81e8fd6d19e6bc81d1ea9dbb09\" class=\"ne-p\"\u003e\u003cimg src=\"https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829887-83af6188-e02c-4437-8739-40021e8a2957.png\" width=\"734\" id=\"uirOM\" class=\"ne-image\"\u003e\u003c/p\u003e\u003cp id=\"6579c3b5ec2bf6680f8a53ad590b2b3f\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"0bad0d7b6f984dfeb8fb7d633878dc75\" class=\"ne-p\"\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e位图\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e提供了一种简单的方法在固定大小的内存中跟踪内存的使用情况，因为\u003c/span\u003e\u003cstrong\u003e\u003cspan class=\"ne-text\"\u003e位图的大小取决于内存和分配单元的大小\u003c/span\u003e\u003c/strong\u003e\u003cspan class=\"ne-text\"\u003e。这种方法有一个问题是，当决定为把具有 k 个分配单元的进程放入内存时，\u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e内容管理器(memory manager)\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e 必须搜索位图，在位图中找出能够运行 k 个连续 0 位的串。在位图中找出制定长度的连续 0 串是一个很耗时的操作，这是位图的缺点。（可以简单理解为在杂乱无章的数组中，找出具有一大长串空闲的数组单元）\u003c/span\u003e\u003c/p\u003e\u003cp id=\"eb3f59ae4a980fa5ed18835d708de977\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003ch4 id=\"467e29df\"\u003e\u003cspan class=\"ne-text\"\u003e使用链表进行管理\u003c/span\u003e\u003c/h4\u003e\u003cp id=\"0ba53562a3e5d7f756273229624888b1\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"65daec3f55e2fb306b3bd1ea1f8ec09e\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e另一种记录内存使用情况的方法是，维护一个记录已分配内存段和空闲内存段的链表，段会包含进程或者是两个进程的空闲区域。可用上面的图 c \u003c/span\u003e\u003cstrong\u003e\u003cspan class=\"ne-text\"\u003e来表示内存的使用情况\u003c/span\u003e\u003c/strong\u003e\u003cspan class=\"ne-text\"\u003e。链表中的每一项都可以代表一个 \u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e空闲区(H)\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e 或者是\u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e进程(P)\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e的起始标志，长度和下一个链表项的位置。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"7492aba8e2e2a0b00bddc1bba083dec4\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"2f92da5d9f5567454cc1afc04526ce0b\" class=\"ne-p\"\u003e\u003cimg src=\"https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829908-832c7960-d7cc-45fc-a029-b803b86a6bf9.png\" width=\"695\" id=\"ZQMqP\" class=\"ne-image\"\u003e\u003c/p\u003e\u003cp id=\"f407fecb833a46515b987fd8965b5866\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"0dbfeeb82b221eef296e1b1d55fac093\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e当按照地址顺序在链表中存放进程和空闲区时，有几种算法可以为创建的进程（或者从磁盘中换入的进程）分配内存。我们先假设内存管理器知道应该分配多少内存，最简单的算法是使用 \u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e首次适配(first fit)\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e。内存管理器会沿着段列表进行扫描，直到找个一个足够大的空闲区为止。 除非空闲区大小和要分配的空间大小一样，否则将空闲区分为两部分，一部分供进程使用；一部分生成新的空闲区。首次适配算法是一种速度很快的算法，因为它会尽可能的搜索链表。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"750c592d1471e8b63a925fb723ea5093\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"b4c3aa0ee2ac733daa864079298d1186\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e首次适配的一个小的变体是 \u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e下次适配(next fit)\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e。它和首次匹配的工作方式相同，只有一个不同之处那就是下次适配在每次找到合适的空闲区时就会记录当时的位置，以便下次寻找空闲区时从上次结束的地方开始搜索，而不是像首次匹配算法那样每次都会从头开始搜索。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"a21e47b580db1794269936af697ac5b6\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"154349d0e6d25598125edd960c601f1a\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e另外一个著名的并且广泛使用的算法是 \u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e最佳适配(best fit)\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e。最佳适配会从头到尾寻找整个链表，找出能够容纳进程的最小空闲区。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"c0239fb5654f6172a04ffc454db60829\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003ch2 id=\"84429675\"\u003e\u003cspan class=\"ne-text\"\u003e虚拟内存\u003c/span\u003e\u003c/h2\u003e\u003cp id=\"a52e80a7a17362a2071a9ac3d43c6331\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"a3b16b4a43fc377a78e20e68d2604a84\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e尽管基址寄存器和变址寄存器用来创建地址空间的抽象，但是这有一个其他的问题需要解决：\u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e管理软件的不断增大(managing bloatware)\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e。虚拟内存的基本思想是，每个程序都有自己的地址空间，这个地址空间被划分为多个称为\u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e页面(page)\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e的块。每一页都是连续的地址范围。这些页被映射到物理内存，但并不是所有的页都必须在内存中才能运行程序。当程序引用到一部分在物理内存中的地址空间时，硬件会立刻执行必要的映射。当程序引用到一部分不在物理内存中的地址空间时，由操作系统负责将缺失的部分装入物理内存并重新执行失败的指令。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"cfc9dd2da74bf0ac8eb66cdcb2922008\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003ch3 id=\"3862626c\"\u003e\u003cspan class=\"ne-text\"\u003e分页\u003c/span\u003e\u003c/h3\u003e\u003cp id=\"ad408dc123ddf88a8c25c2e8c88dae85\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"4066a9b0016b34734e2fbf3e8f54723b\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e大部分使用虚拟内存的系统中都会使用一种 \u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e分页(paging)\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e 技术。在任何一台计算机上，程序会引用使用一组内存地址。当程序执行\u003c/span\u003e\u003c/p\u003e\u003cp id=\"d759b00624e8ef1625c86e6add1eddcb\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cpre data-language=\"assembly\" id=\"d0a4f960\" class=\"ne-codeblock language-assembly\"\u003eMOV REG,1000\u003c/pre\u003e\u003cp id=\"89add3c3374d8e28c840c7bccca4a7e5\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"96c2f3af046d1e1074a249ed5b62d8d1\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e这条指令时，它会把内存地址为 1000 的内存单元的内容复制到 REG 中（或者相反，这取决于计算机）。地址可以通过索引、基址寄存器、段寄存器或其他方式产生。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"d4405ed4f3767b04521138e8ae125763\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"bb0d8776d1f68b804c2256cb8e6a8782\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e这些程序生成的地址被称为 \u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e虚拟地址(virtual addresses)\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e 并形成\u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e虚拟地址空间(virtual address space)\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e，在没有虚拟内存的计算机上，系统直接将虚拟地址送到内存中线上，读写操作都使用同样地址的物理内存。\u003c/span\u003e\u003cstrong\u003e\u003cspan class=\"ne-text\"\u003e在使用虚拟内存时，虚拟地址不会直接发送到内存总线上\u003c/span\u003e\u003c/strong\u003e\u003cspan class=\"ne-text\"\u003e。相反，会使用 \u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003eMMU(Memory Management Unit)\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e 内存管理单元把\u003c/span\u003e\u003cstrong\u003e\u003cspan class=\"ne-text\"\u003e虚拟地址映射为物理内存地址\u003c/span\u003e\u003c/strong\u003e\u003cspan class=\"ne-text\"\u003e，像下图这样\u003c/span\u003e\u003c/p\u003e\u003cp id=\"7af393fea8b22c962a02bb238a51bfcf\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"26978d8cd99d410a14326508c2a49c82\" class=\"ne-p\"\u003e\u003cimg src=\"https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829902-6db577d7-0921-4635-82f1-62f7fe723b48.png\" width=\"710\" id=\"DPfTF\" class=\"ne-image\"\u003e\u003c/p\u003e\u003cp id=\"920e1606a09ad135a916cc1d8ea86734\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"d01e804e8a33f6a675e0545fe9f7dde7\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e下面这幅图展示了这种映射是如何工作的\u003c/span\u003e\u003c/p\u003e\u003cp id=\"5aceabff0e61c0d5d5d970315896fe1e\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"70d3b873e0804fdcc75108174659a7b5\" class=\"ne-p\"\u003e\u003cimg src=\"https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829922-b5a208d9-6807-4201-b95a-50c300ec3f1e.png\" width=\"701\" id=\"jEXGv\" class=\"ne-image\"\u003e\u003c/p\u003e\u003cp id=\"b96f2dce14d08fbe8bbb54b56cb574bf\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"dc3ab02bd9504ce5467860296b9a74d2\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e页表给出虚拟地址与物理内存地址之间的映射关系。每一页起始于 4096 的倍数位置，结束于 4095 的位置，所以 4K 到 8K 实际为 4096 - 8191 ，8K - 12K 就是 8192 - 12287\u003c/span\u003e\u003c/p\u003e\u003cp id=\"bc7ed89c32cb3a181312532bc488d2e0\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"a2f11223fc6e7fd34aab2e859e41b4f3\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e在这个例子中，我们可能有一个 16 位地址的计算机，地址从 0 - 64 K - 1，这些是\u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e虚拟地址\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e。然而只有 32 KB 的物理地址。所以虽然可以编写 64 KB 的程序，但是程序无法全部调入内存运行，在磁盘上必须有一个最多 64 KB 的程序核心映像的完整副本，以保证程序片段在需要时被调入内存。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"9596f00592eb949c69c63cbdb69b8643\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003ch3 id=\"48de0fdd\"\u003e\u003cspan class=\"ne-text\"\u003e页表\u003c/span\u003e\u003c/h3\u003e\u003cp id=\"857f37982ab15377827623d3d741445c\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"3fa7e03ff8c37017d8d9354b20f1a7f6\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e虚拟页号可作为页表的索引用来找到虚拟页中的内容。由页表项可以找到页框号（如果有的话）。然后把页框号拼接到偏移量的高位端，以替换掉虚拟页号，形成物理地址。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"b804d0484cc73b4e42e4c1a16cf433bf\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"97e874b55d764de49c180df820f441ac\" class=\"ne-p\"\u003e\u003cimg src=\"https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829940-3af1fa95-4f53-459f-88e6-dc9540fc58fa.png\" width=\"726\" id=\"gDLPK\" class=\"ne-image\"\u003e\u003c/p\u003e\u003cp id=\"7d73b7251105220113cfc0e95b4dae9e\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"063ec3cf1870ce7283f1ec520bf8725e\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e因此，页表的目的是把虚拟页映射到页框中。从数学上说，页表是一个函数，它的参数是虚拟页号，结果是物理页框号。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"7c5451128fbe624fd69dc56c6324aa00\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"ecc02083465bab9e94b190db907b78cf\" class=\"ne-p\"\u003e\u003cimg src=\"https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829970-f9085cee-e3ce-49a6-a175-31095f33b104.png\" width=\"549\" id=\"r6cAl\" class=\"ne-image\"\u003e\u003c/p\u003e\u003cp id=\"f4cbe70227438afd44c6da369ae27783\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"ecc882e5c8595768f3b9b1a82f95c800\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e通过这个函数可以把虚拟地址中的虚拟页转换为页框，从而形成物理地址。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"d5a128f20cf5882f3e7639970691078c\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003ch4 id=\"ebc1ec9d\"\u003e\u003cspan class=\"ne-text\"\u003e页表项的结构\u003c/span\u003e\u003c/h4\u003e\u003cp id=\"8580345f352bef3704c4f0cfb0671d79\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"e0361fcd123e7c408a1410e6cc45439c\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e下面我们探讨一下页表项的具体结构，上面你知道了页表项的大致构成，是由页框号和在/不在位构成的，现在我们来具体探讨一下页表项的构成\u003c/span\u003e\u003c/p\u003e\u003cp id=\"47984eb3ee2b2f2dfa132deed0eb8316\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"cc5c2e897e5e7b5827cdd4c67abaaa77\" class=\"ne-p\"\u003e\u003cimg src=\"https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829994-5ecf9cda-4a6f-418e-b786-bf4a2a05e7c3.png\" width=\"701\" id=\"PVew4\" class=\"ne-image\"\u003e\u003c/p\u003e\u003cp id=\"4cbaab2ba9647f14311ad1df919f070b\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"a0482db6a2673a73d8ea3e3348c44e1e\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e页表项的结构是与机器相关的，但是不同机器上的页表项大致相同。上面是一个页表项的构成，不同计算机的页表项可能不同，但是一般来说都是 32 位的。页表项中最重要的字段就是\u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e页框号(Page frame number)\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e。毕竟，页表到页框最重要的一步操作就是要把此值映射过去。下一个比较重要的就是\u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e在/不在\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e位，如果此位上的值是 1，那么页表项是有效的并且能够被\u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e使用\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e。如果此值是 0 的话，则表示该页表项对应的虚拟页面\u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e不在\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e内存中，访问该页面会引起一个\u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e缺页异常(page fault)\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"1538e61821a53e91fd6c621fea99050c\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"07e2267978cae7258a9ac4111b0bfac6\" class=\"ne-p\"\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e保护位(Protection)\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e 告诉我们哪一种访问是允许的，啥意思呢？最简单的表示形式是这个域只有一位，\u003c/span\u003e\u003cstrong\u003e\u003cspan class=\"ne-text\"\u003e0 表示可读可写，1 表示的是只读\u003c/span\u003e\u003c/strong\u003e\u003cspan class=\"ne-text\"\u003e。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"cd5113de44f663e8dcda2e73383b485f\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"2f956dc3258cb003ac6dc16c55871787\" class=\"ne-p\"\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e修改位(Modified)\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e 和 \u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e访问位(Referenced)\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e 会跟踪页面的使用情况。当一个页面被写入时，硬件会自动的设置修改位。修改位在页面重新分配页框时很有用。如果一个页面已经被修改过（即它是 \u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e脏\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e 的），则必须把它写回磁盘。如果一个页面没有被修改过（即它是 \u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e干净\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e的），那么重新分配时这个页框会被直接丢弃，因为磁盘上的副本仍然是有效的。这个位有时也叫做 \u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e脏位(dirty bit)\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e，因为它反映了页面的状态。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"b79e431bca8c6a4061cff3e6e2cd7e33\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"e4dfca25e9150ba09532a333d26042ad\" class=\"ne-p\"\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e访问位(Referenced)\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e 在页面被访问时被设置，不管是读还是写。这个值能够帮助操作系统在发生缺页中断时选择要淘汰的页。不再使用的页要比正在使用的页更适合被淘汰。这个位在后面要讨论的\u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e页面置换\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e算法中作用很大。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"3c02b4c632833430510ae67ff9ed4e16\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"dbc93bd44ac1087b64e0b1d023ba34c3\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e最后一位用于禁止该页面被高速缓存，这个功能对于映射到设备寄存器还是内存中起到了关键作用。通过这一位可以禁用高速缓存。具有独立的 I/O 空间而不是用内存映射 I/O 的机器来说，并不需要这一位。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"befcfc4e20c5082a05f87de19bcd7503\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003ch2 id=\"62ce86fe\"\u003e\u003cspan class=\"ne-text\"\u003e页面置换算法\u003c/span\u003e\u003c/h2\u003e\u003cp id=\"dd4394f57b4886240b2c215cdd1e4631\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"4f6a92a94c2e30c6050bfb462299a22b\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e下面我们就来探讨一下有哪些页面置换算法。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"a1b1f01ba8c41e23d328afe683dd334c\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003ch3 id=\"62592cf3\"\u003e\u003cspan class=\"ne-text\"\u003e最优页面置换算法\u003c/span\u003e\u003c/h3\u003e\u003cp id=\"0e512837e885309b4830226205348edd\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"9213075cee522577cc3a7c72861ccedd\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e最优的页面置换算法的工作流程如下：在缺页中断发生时，这些页面之一将在下一条指令（包含该指令的页面）上被引用。其他页面则可能要到 10、100 或者 1000 条指令后才会被访问。每个页面都可以用在该页首次被访问前所要执行的指令数作为标记。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"60569c4b121798a3dfa3559723a85c22\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"f652c71e4c322ab28275da1eef94b0bb\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e最优化的页面算法表明应该标记最大的页面。如果一个页面在 800 万条指令内不会被使用，另外一个页面在 600 万条指令内不会被使用，则置换前一个页面，从而把需要调入这个页面而发生的缺页中断推迟。计算机也像人类一样，会把不愿意做的事情尽可能的往后拖。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"933341d07fd0cb969e37b2921a21a1b4\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"0b6aa11ee462069a41c30975c1369ec7\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e这个算法最大的问题时无法实现。当缺页中断发生时，操作系统无法知道各个页面的下一次将在什么时候被访问。这种算法在实际过程中根本不会使用。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"7cccf369523448e9ea1adb8b38b19c65\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003ch3 id=\"f3900d0e\"\u003e\u003cspan class=\"ne-text\"\u003e最近未使用页面置换算法\u003c/span\u003e\u003c/h3\u003e\u003cp id=\"84094ac7292da84c018fa4aa4de731a1\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"48785f09a7c92dc9c6b7cb0413f2955c\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e为了能够让操作系统收集页面使用信息，大部分使用虚拟地址的计算机都有两个状态位，R 和 M，来和每个页面进行关联。\u003c/span\u003e\u003cstrong\u003e\u003cspan class=\"ne-text\"\u003e每当引用页面（读入或写入）时都设置 R，写入（即修改）页面时设置 M\u003c/span\u003e\u003c/strong\u003e\u003cspan class=\"ne-text\"\u003e，这些位包含在每个页表项中，就像下面所示\u003c/span\u003e\u003c/p\u003e\u003cp id=\"893a0cfa909ed56729e771832bca703f\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"a4c3f7d5b620ee72ed1f39cf3b0f2f9c\" class=\"ne-p\"\u003e\u003cimg src=\"https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830000-886bdae7-531d-42ce-86c1-970d3c0fd287.png\" width=\"644\" id=\"GjVza\" class=\"ne-image\"\u003e\u003c/p\u003e\u003cp id=\"d91a668fe44efebe3f6df1f790f756b6\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"cd2436ef675270bdeb27defe9bb4a987\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e因为每次访问时都会更新这些位，因此由\u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e硬件\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e来设置它们非常重要。一旦某个位被设置为 1，就会一直保持 1 直到操作系统下次来修改此位。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"e7a4fdba97874bdf3ba1bbbcc25d17b6\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"cc2fe27785e322231e1760788dacd2e8\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e如果硬件没有这些位，那么可以使用操作系统的\u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e缺页中断\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e和\u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e时钟中断\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e机制来进行模拟。当启动一个进程时，将其所有的页面都标记为\u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e不在内存\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e；一旦访问任何一个页面就会引发一次缺页中断，此时操作系统就可以设置 \u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003eR 位(在它的内部表中)\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e，修改页表项使其指向正确的页面，并设置为 \u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003eREAD ONLY\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e 模式，然后重新启动引起缺页中断的指令。如果页面随后被修改，就会发生另一个缺页异常。从而允许操作系统设置 M 位并把页面的模式设置为 \u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003eREAD/WRITE\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"1cdfab7830fe96b8bd64eba745fa4f54\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"8dac468a9941b20f7d32592bf3233e15\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e可以用 R 位和 M 位来构造一个简单的页面置换算法：当启动一个进程时，操作系统将其所有页面的两个位都设置为 0。R 位定期的被清零（在每个时钟中断）。用来将最近未引用的页面和已引用的页面分开。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"6f7fbf64554353465ff29f99860787b3\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"39bab2fdc8db36d5ebb838bbc9610a1e\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e当出现缺页中断后，操作系统会检查所有的页面，并根据它们的 R 位和 M 位将当前值分为四类：\u003c/span\u003e\u003c/p\u003e\u003cp id=\"abc034f6c92699f9fbdd74ea4d336581\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cul class=\"ne-ul\"\u003e\u003cli id=\"7f488d4df8b3c78c1612b6b90607a6ec\"\u003e\u003cspan class=\"ne-text\"\u003e第 0 类：没有引用 R，没有修改 M\u003c/span\u003e\u003c/li\u003e\u003cli id=\"6e0da38d60df8303cdfb64d30e7ae9f9\"\u003e\u003cspan class=\"ne-text\"\u003e第 1 类：没有引用 R，已修改 M\u003c/span\u003e\u003c/li\u003e\u003c/ul\u003e\u003cul class=\"ne-ul\"\u003e\u003cli id=\"e52f9551f8862c020d85a689e7669461\"\u003e\u003cspan class=\"ne-text\"\u003e第 2 类：引用 R ，没有修改 M\u003c/span\u003e\u003c/li\u003e\u003cli id=\"2098c1e2e0738f1af205e33bac18f3f8\"\u003e\u003cspan class=\"ne-text\"\u003e第 3 类：已被访问 R，已被修改 M\u003c/span\u003e\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"19ca51f0ab68b170e6b85ceff4a1422c\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"55b6e4fc2dcc6d749c16ef21258bf769\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e尽管看起来好像无法实现第一类页面，但是当第三类页面的 R 位被时钟中断清除时，它们就会发生。时钟中断不会清除 M 位，因为需要这个信息才能知道是否写回磁盘中。清除 R 但不清除 M 会导致出现一类页面。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"19f438a3cf1ce096f4968e4f66c24d05\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"3639cbe3d0887d2760c552159b6ac088\" class=\"ne-p\"\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003eNRU(Not Recently Used)\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e 算法从编号最小的非空类中随机删除一个页面。此算法隐含的思想是，在一个时钟内（约 20 ms）淘汰一个已修改但是没有被访问的页面要比一个大量引用的未修改页面好，NRU 的主要优点是\u003c/span\u003e\u003cstrong\u003e\u003cspan class=\"ne-text\"\u003e易于理解并且能够有效的实现\u003c/span\u003e\u003c/strong\u003e\u003cspan class=\"ne-text\"\u003e。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"e69f0a756fab88cc1ab941d6eb5f0429\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003ch3 id=\"ef992930\"\u003e\u003cspan class=\"ne-text\"\u003e先进先出页面置换算法\u003c/span\u003e\u003c/h3\u003e\u003cp id=\"b54cfe45e7d8a2900b5ab6e37cac9c7d\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"cedbd31bfca554665ded81b0817e03ff\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e另一种开销较小的方式是使用 \u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003eFIFO(First-In,First-Out)\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e 算法，这种类型的数据结构也适用在页面置换算法中。由操作系统维护一个所有在当前内存中的页面的链表，最早进入的放在表头，最新进入的页面放在表尾。在发生缺页异常时，会把头部的页移除并且把新的页添加到表尾。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"017b429504dba6c1df0a023aed81995c\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003ch3 id=\"fbe44333\"\u003e\u003cspan class=\"ne-text\"\u003e第二次机会页面置换算法\u003c/span\u003e\u003c/h3\u003e\u003cp id=\"dec3701d79739bc3cf2072c3170b98e4\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"b0f6d433a3bf62769df7a29957f2f42f\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e我们上面学到的 FIFO 链表页面有个\u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e缺陷\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e，那就是出链和入链并不会进行 check \u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e检查\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e，这样就会容易把经常使用的页面置换出去，为了避免这一问题，我们对该算法做一个简单的修改：我们检查最老页面的 \u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003eR 位\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e，如果是 0 ，那么这个页面就是最老的而且没有被使用，那么这个页面就会被立刻换出。如果 R 位是 1，那么就清除此位，此页面会被放在链表的尾部，修改它的装入时间就像刚放进来的一样。然后继续搜索。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"d6333e220f33af321d74ec854f04b55a\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"089f8f24e153eee75e5e435a679afa1e\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e这种算法叫做 \u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e第二次机会(second chance)\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e算法，就像下面这样，我们看到页面 A 到 H 保留在链表中，并按到达内存的时间排序。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"a28bcb1486944b773b50fcf51df4749c\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"fde6e179989ecc6f697670c740914dce\" class=\"ne-p\"\u003e\u003cimg src=\"https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830001-d17523cc-7d04-4aa5-9b91-7cb47cc26508.png\" width=\"731\" id=\"fCBHb\" class=\"ne-image\"\u003e\u003c/p\u003e\u003cp id=\"57038d8271d2c901cbf3b2f205aa4536\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"c231a3eb1c1ffe613e927adb3cc23dfc\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003ea）按照先进先出的方法排列的页面；b）在时刻 20 处发生缺页异常中断并且 A 的 R 位已经设置时的页面链表。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"dfb82b03a7f6557807ac7332498453cc\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"6071f4976010720b318f23a5435af7c9\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e假设缺页异常发生在时刻 20 处，这时最老的页面是 A ，它是在 0 时刻到达的。如果 A 的 R 位是 0，那么它将被淘汰出内存，或者把它写回磁盘（如果它已经被修改过），或者只是简单的放弃（如果它是未被修改过）。另一方面，如果它的 R 位已经设置了，则将 A 放到链表的尾部并且重新设置\u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e装入时间\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e为当前时刻（20 处），然后清除 R 位。然后从 B 页面开始继续搜索合适的页面。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"9254e5ee7d07b1644978e8fae8815ee4\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"213128048d32400dc1be31f0854dccca\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e寻找第二次机会的是在最近的时钟间隔中未被访问过的页面。如果所有的页面都被访问过，该算法就会被简化为单纯的 \u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003eFIFO 算法\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e。具体来说，假设图 a 中所有页面都设置了 R 位。操作系统将页面依次移到链表末尾，每次都在添加到末尾时清除 R 位。最后，算法又会回到页面 A，此时的 R 位已经被清除，那么页面 A 就会被执行出链处理，因此算法能够正常结束。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"006bfd0eee72f06883aeacf0049fb0e5\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003ch3 id=\"77c3ba6e\"\u003e\u003cspan class=\"ne-text\"\u003e时钟页面置换算法\u003c/span\u003e\u003c/h3\u003e\u003cp id=\"ad9e64b0208686171b28fcdaa3269f69\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"6753b55523ed6e4fbb740e4d95f05fec\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e一种比较好的方式是把所有的页面都保存在一个类似钟面的环形链表中，一个表针指向最老的页面。如下图所示\u003c/span\u003e\u003c/p\u003e\u003cp id=\"8ab484c60155725d209fbb22b51d2566\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"52032f6515f4f45cee8fedf418227902\" class=\"ne-p\"\u003e\u003cimg src=\"https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830029-543aeeff-242c-4b6f-a9a4-87fa9b101280.png\" width=\"669\" id=\"Xw06o\" class=\"ne-image\"\u003e\u003c/p\u003e\u003cp id=\"a537643cb2a9b195c3c6ed6460bb4427\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"34c47bdd9eccecfd23ed6a6c98202f9e\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e当缺页错误出现时，算法首先检查表针指向的页面，如果它的 R 位是 0 就淘汰该页面，并把新的页面插入到这个位置，然后把表针向前移动一位；如果 R 位是 1 就清除 R 位并把表针前移一个位置。重复这个过程直到找到了一个 R 位为 0 的页面位置。了解这个算法的工作方式，就明白为什么它被称为 \u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e时钟(clokc)\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e算法了。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"2bb310c9d960a15e936ed5cd9874ca22\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003ch3 id=\"a918bb5b\"\u003e\u003cspan class=\"ne-text\"\u003e最近最少使用页面置换算法\u003c/span\u003e\u003c/h3\u003e\u003cp id=\"dcd37ab4af6b75e405921bbc1c037e68\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"205663d914713ca94cf7dee4abb58f3b\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e在前面几条指令中频繁使用的页面和可能在后面的几条指令中被使用。反过来说，已经很久没有使用的页面有可能在未来一段时间内仍不会被使用。这个思想揭示了一个可以实现的算法：在缺页中断时，置换未使用时间最长的页面。这个策略称为 \u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003eLRU(Least Recently Used)\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e ，最近最少使用页面置换算法。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"7b1a47269ade45a6f9b444a5e67e2b4a\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"9e365e147cef6fb0ce851d48e6498ae7\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e虽然 LRU 在理论上是可以实现的，但是从长远看来代价比较高。为了完全实现 LRU，会在内存中维护一个所有页面的链表，最频繁使用的页位于表头，最近最少使用的页位于表尾。困难的是在每次内存引用时更新整个链表。在链表中找到一个页面，删除它，然后把它移动到表头是一个非常耗时的操作，即使使用\u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e硬件\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e来实现也是一样的费时。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"ce5addf295db9d862f1c198299520382\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003ch3 id=\"3d8761a9\"\u003e\u003cspan class=\"ne-text\"\u003e用软件模拟 LRU\u003c/span\u003e\u003c/h3\u003e\u003cp id=\"37d6bfe86f6fcc86a602d5597f75e357\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"6061c314c4be9623fa92455e73227ba8\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e尽管上面的 LRU 算法在原则上是可以实现的，\u003c/span\u003e\u003cstrong\u003e\u003cspan class=\"ne-text\"\u003e但是很少有机器能够拥有那些特殊的硬件\u003c/span\u003e\u003c/strong\u003e\u003cspan class=\"ne-text\"\u003e。上面是硬件的实现方式，那么现在考虑要用\u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e软件\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e来实现 LRU 。一种可以实现的方案是 \u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003eNFU(Not Frequently Used，最不常用)\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e算法。它需要一个软件计数器来和每个页面关联，初始化的时候是 0 。在每个时钟中断时，操作系统会浏览内存中的所有页，会将每个页面的 R 位（0 或 1）加到它的计数器上。这个计数器大体上跟踪了各个页面访问的频繁程度。当缺页异常出现时，则置换计数器值最小的页面。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"2a6159adb02ff3cc9bce97cd9579d42e\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"a7be3c75d28420ac502d39512cf7dc74\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e只需要对 NFU 做一个简单的修改就可以让它模拟 LRU，这个修改有两个步骤\u003c/span\u003e\u003c/p\u003e\u003cp id=\"a1f2097df3061d1fd3dbb757d747437f\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cul class=\"ne-ul\"\u003e\u003cli id=\"4bbd7f83857962a0edf2928dd13577f4\"\u003e\u003cspan class=\"ne-text\"\u003e首先，在 R 位被添加进来之前先把计数器右移一位；\u003c/span\u003e\u003c/li\u003e\u003cli id=\"4583a5fcd17a9fe4311405a164d135ef\"\u003e\u003cspan class=\"ne-text\"\u003e第二步，R 位被添加到最左边的位而不是最右边的位。\u003c/span\u003e\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"b2717e6278239c301fbc4d9e32bb5ba8\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"6a60486aae78656f5b1415e75528cf92\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e修改以后的算法称为 \u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e老化(aging)\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e 算法，下图解释了老化算法是如何工作的。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"0e45535a1d54c69288a3c65fdd3f9eda\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"17f0818b86d3528d2d965e22f418a75b\" class=\"ne-p\"\u003e\u003cimg src=\"https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830078-9cab6ac9-f2fa-4395-b8d5-57b61a80e6d3.png\" width=\"747\" id=\"kzyJK\" class=\"ne-image\"\u003e\u003c/p\u003e\u003cp id=\"f34b569fc53d87a9b00b7727cfc529dd\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"c81d065239846ddb58479859917fabc9\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e我们假设在第一个时钟周期内页面 0 - 5 的 R 位依次是 1，0，1，0，1，1，（也就是页面 0 是 1，页面 1 是 0，页面 2 是 1 这样类推）。也就是说，\u003c/span\u003e\u003cstrong\u003e\u003cspan class=\"ne-text\"\u003e在 0 个时钟周期到 1 个时钟周期之间，0，2，4，5 都被引用了\u003c/span\u003e\u003c/strong\u003e\u003cspan class=\"ne-text\"\u003e，从而把它们的 R 位设置为 1，剩下的设置为 0 。在相关的六个计数器被右移之后 R 位被添加到 \u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e左侧\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e ，就像上图中的 a。剩下的四列显示了接下来的四个时钟周期内的六个计数器变化。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"499a1052524254f8661e3f408cf21aa3\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cdiv class=\"ne-quote\"\u003e\u003cp id=\"129f113f3de0adc28d4390fd9db25563\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003eCPU正在以某个频率前进，该频率的周期称为\u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e时钟滴答\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e或\u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e时钟周期\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e。一个 100Mhz 的处理器每秒将接收100,000,000个时钟滴答。\u003c/span\u003e\u003c/p\u003e\u003c/div\u003e\u003cp id=\"eaca1a1c1cedd12caea8a55b7023c5df\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"22915b2fc6fa12c8e3283015a6e73231\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e当缺页异常出现时，将\u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e置换（就是移除）\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e计数器值最小的页面。如果一个页面在前面 4 个时钟周期内都没有被访问过，那么它的计数器应该会有四个连续的 0 ，因此它的值肯定要比前面 3 个时钟周期内都没有被访问过的页面的计数器小。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"6ac140bf2daf5bfd92cfe42f2385f2ff\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"dcf4a0b873c335c26afd35584ae48010\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e这个算法与 LRU 算法有两个重要的区别：看一下上图中的 \u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003ee\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e，第三列和第五列\u003c/span\u003e\u003c/p\u003e\u003cp id=\"b83cb567bda1ff21e9c305d5e47b6dc1\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"67b39e8eb31df20830950dcf649331c2\" class=\"ne-p\"\u003e\u003cimg src=\"https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830053-3463258f-69af-41f6-94ed-94a15761844e.png\" width=\"763\" id=\"BE7AZ\" class=\"ne-image\"\u003e\u003c/p\u003e\u003cp id=\"0673d7e6e35f4f09d2394193508d2a05\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003ch3 id=\"3b91d1a3\"\u003e\u003cspan class=\"ne-text\"\u003e工作集时钟页面置换算法\u003c/span\u003e\u003c/h3\u003e\u003cp id=\"63abd06159f80e0e075790bb08d4ffed\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"73bb03fe3aaa4adac274dc16a8d05404\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e当缺页异常发生后，需要扫描整个页表才能确定被淘汰的页面，因此基本工作集算法还是比较浪费时间的。一个对基本工作集算法的提升是基于时钟算法但是却使用工作集的信息，这种算法称为\u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003eWSClock(工作集时钟)\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e。由于它的实现简单并且具有高性能，因此在实践中被广泛应用。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"d58ba8b46f716fecbc53ecbc4210e48b\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"3944528a9e5d2af730bcc21a6fcbc8ab\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e与时钟算法一样，所需的数据结构是一个以页框为元素的循环列表，就像下面这样\u003c/span\u003e\u003c/p\u003e\u003cp id=\"01d5cdf75a341e23abd1d6d52c38226f\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"a2e7cd58c23ca108b5363f7a00477f63\" class=\"ne-p\"\u003e\u003cimg src=\"https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830081-e96444ca-dda9-4c3f-9af5-e0db74d03a6f.png\" width=\"705\" id=\"tl5hI\" class=\"ne-image\"\u003e\u003c/p\u003e\u003cp id=\"2d178410b1a9f1db6d542c7530824d29\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"de674762efef1a1d31d2a2f9116a6360\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e 工作集时钟页面置换算法的操作：a) 和 b) 给出 R = 1 时所发生的情形；c) 和 d) 给出 R = 0 的例子\u003c/span\u003e\u003c/p\u003e\u003cp id=\"376ca02884d8a1d9619e3a218afdf8b0\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"63fe0e0e76165313969aad9b5a52a257\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e最初的时候，该表是空的。当装入第一个页面后，把它加载到该表中。随着更多的页面的加入，它们形成一个环形结构。每个表项包含来自基本工作集算法的上次使用时间，以及 R 位（已标明）和 M 位（未标明）。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"7e3a6f2fed60f5194bfd204102e2952d\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"957756ce70967b23ea6854a4f43d3a03\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e与时钟算法一样，在每个缺页异常时，首先检查指针指向的页面。如果 R 位被是设置为 1，该页面在当前时钟周期内就被使用过，那么该页面就不适合被淘汰。然后把该页面的 R 位置为 0，指针指向下一个页面，并重复该算法。该事件序列化后的状态参见图 b。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"660512e597b1be7f79759c859c5ad630\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"3131acf40f8b8061433775a713b92569\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e现在考虑指针指向的页面 R = 0 时会发生什么，参见图 c，如果页面的使用期限大于 t 并且页面为被访问过，那么这个页面就不会在工作集中，并且在磁盘上会有一个此页面的副本。申请重新调入一个新的页面，并把新的页面放在其中，如图 d 所示。另一方面，如果页面被修改过，就不能重新申请页面，因为这个页面在磁盘上没有有效的副本。为了避免由于调度写磁盘操作引起的进程切换，指针继续向前走，算法继续对下一个页面进行操作。毕竟，有可能存在一个老的，没有被修改过的页面可以立即使用。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"259f8e1c415f1f342157b2c74fa8531d\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"c3a7464fe9b882ee84c2133203efbc8f\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e原则上来说，所有的页面都有可能因为\u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e磁盘I/O\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e 在某个时钟周期内被调度。为了降低磁盘阻塞，需要设置一个限制，即最大只允许写回 n 个页面。一旦达到该限制，就不允许调度新的写操作。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"14bb94ec4633fd27809f92c905c5c4a0\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"6b5f609cfef9d1be84780092687527ed\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e那么就有个问题，指针会绕一圈回到原点的，如果回到原点，它的起始点会发生什么？这里有两种情况：\u003c/span\u003e\u003c/p\u003e\u003cp id=\"af605baae7a6291209d87aad111ebdde\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cul class=\"ne-ul\"\u003e\u003cli id=\"be710c9c234ad6ebc9bb28abb8befd14\"\u003e\u003cspan class=\"ne-text\"\u003e至少调度了一次写操作\u003c/span\u003e\u003c/li\u003e\u003cli id=\"1f5761b8fa6436255d40db750cdca12c\"\u003e\u003cspan class=\"ne-text\"\u003e没有调度过写操作\u003c/span\u003e\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"d327ffc3f06f2f92e3638b05eb18f99f\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"f279a05a1c84ac5f4f42f1b687ca65e9\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e在第一种情况中，指针仅仅是不停的移动，寻找一个未被修改过的页面。由于已经调度了一个或者多个写操作，最终会有某个写操作完成，它的页面会被标记为未修改。置换遇到的第一个未被修改过的页面，这个页面不一定是第一个被调度写操作的页面，因为硬盘驱动程序为了优化性能可能会把写操作重排序。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"f975c09f26fb82689584d8824d592a03\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"9a686c8455f99d36ff56e36cb6856304\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e对于第二种情况，所有的页面都在工作集中，否则将至少调度了一个写操作。由于缺乏额外的信息，最简单的方法就是置换一个未被修改的页面来使用，扫描中需要记录未被修改的页面的位置，如果不存在未被修改的页面，就选定当前页面并把它写回磁盘。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"22bc054ec4116393b13ced80f5f13f97\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003ch3 id=\"88464125\"\u003e\u003cspan class=\"ne-text\"\u003e页面置换算法小结\u003c/span\u003e\u003c/h3\u003e\u003cp id=\"c76fb75fa6f7d1c2e423f6396b4d785a\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"a4a73b9727c0408ace20acf41c243df7\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e我们到现在已经研究了各种页面置换算法，现在我们来一个简单的总结，算法的总结归纳如下\u003c/span\u003e\u003c/p\u003e\u003ctable id=\"1b009b27\" class=\"ne-table\" style=\"width: 750px\"\u003e\u003ctbody\u003e\u003ctr style=\"height: 33px\"\u003e\u003ctd width=\"375\"\u003e\u003cp id=\"u8155d1fa\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e算法\u003c/span\u003e\u003c/p\u003e\u003c/td\u003e\u003ctd width=\"375\"\u003e\u003cp id=\"ub91c6a44\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e注释\u003c/span\u003e\u003c/p\u003e\u003c/td\u003e\u003c/tr\u003e\u003ctr style=\"height: 33px\"\u003e\u003ctd width=\"375\"\u003e\u003cp id=\"u9675e649\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e最优算法\u003c/span\u003e\u003c/p\u003e\u003c/td\u003e\u003ctd width=\"375\"\u003e\u003cp id=\"ua39abb97\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e不可实现，但可以用作基准\u003c/span\u003e\u003c/p\u003e\u003c/td\u003e\u003c/tr\u003e\u003ctr style=\"height: 33px\"\u003e\u003ctd width=\"375\"\u003e\u003cp id=\"u394e510f\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003eNRU(最近未使用) 算法\u003c/span\u003e\u003c/p\u003e\u003c/td\u003e\u003ctd width=\"375\"\u003e\u003cp id=\"uf3d6826a\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e和 LRU 算法很相似\u003c/span\u003e\u003c/p\u003e\u003c/td\u003e\u003c/tr\u003e\u003ctr style=\"height: 33px\"\u003e\u003ctd width=\"375\"\u003e\u003cp id=\"u26c74d8a\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003eFIFO(先进先出) 算法\u003c/span\u003e\u003c/p\u003e\u003c/td\u003e\u003ctd width=\"375\"\u003e\u003cp id=\"u7ac53964\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e有可能会抛弃重要的页面\u003c/span\u003e\u003c/p\u003e\u003c/td\u003e\u003c/tr\u003e\u003ctr style=\"height: 33px\"\u003e\u003ctd width=\"375\"\u003e\u003cp id=\"ubd2f9fd7\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e第二次机会算法\u003c/span\u003e\u003c/p\u003e\u003c/td\u003e\u003ctd width=\"375\"\u003e\u003cp id=\"u74ec06bd\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e比 FIFO 有较大的改善\u003c/span\u003e\u003c/p\u003e\u003c/td\u003e\u003c/tr\u003e\u003ctr style=\"height: 33px\"\u003e\u003ctd width=\"375\"\u003e\u003cp id=\"ueb91d76a\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e时钟算法\u003c/span\u003e\u003c/p\u003e\u003c/td\u003e\u003ctd width=\"375\"\u003e\u003cp id=\"u34def58d\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e实际使用\u003c/span\u003e\u003c/p\u003e\u003c/td\u003e\u003c/tr\u003e\u003ctr style=\"height: 33px\"\u003e\u003ctd width=\"375\"\u003e\u003cp id=\"uff3a1852\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003eLRU(最近最少)算法\u003c/span\u003e\u003c/p\u003e\u003c/td\u003e\u003ctd width=\"375\"\u003e\u003cp id=\"u5613a15a\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e比较优秀，但是很难实现\u003c/span\u003e\u003c/p\u003e\u003c/td\u003e\u003c/tr\u003e\u003ctr style=\"height: 33px\"\u003e\u003ctd width=\"375\"\u003e\u003cp id=\"u7a5e614f\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003eNFU(最不经常食用)算法\u003c/span\u003e\u003c/p\u003e\u003c/td\u003e\u003ctd width=\"375\"\u003e\u003cp id=\"uc4d42f56\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e和 LRU 很类似\u003c/span\u003e\u003c/p\u003e\u003c/td\u003e\u003c/tr\u003e\u003ctr style=\"height: 33px\"\u003e\u003ctd width=\"375\"\u003e\u003cp id=\"u97c1197a\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e老化算法\u003c/span\u003e\u003c/p\u003e\u003c/td\u003e\u003ctd width=\"375\"\u003e\u003cp id=\"u1102fb4d\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e近似 LRU 的高效算法\u003c/span\u003e\u003c/p\u003e\u003c/td\u003e\u003c/tr\u003e\u003ctr style=\"height: 33px\"\u003e\u003ctd width=\"375\"\u003e\u003cp id=\"udcc054bf\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e工作集算法\u003c/span\u003e\u003c/p\u003e\u003c/td\u003e\u003ctd width=\"375\"\u003e\u003cp id=\"u04210cf5\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e实施起来开销很大\u003c/span\u003e\u003c/p\u003e\u003c/td\u003e\u003c/tr\u003e\u003ctr style=\"height: 33px\"\u003e\u003ctd width=\"375\"\u003e\u003cp id=\"u9cb6c78e\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e工作集时钟算法\u003c/span\u003e\u003c/p\u003e\u003c/td\u003e\u003ctd width=\"375\"\u003e\u003cp id=\"uac13bd4a\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e比较有效的算法\u003c/span\u003e\u003c/p\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003cp id=\"95ce7ac6c96f2836c1da1058696564f2\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cul class=\"ne-ul\"\u003e\u003cli id=\"706a0737a142822991e3b2d4119a9f68\"\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e最优算法\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e在当前页面中置换最后要访问的页面。不幸的是，没有办法来判定哪个页面是最后一个要访问的，\u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e因此实际上该算法不能使用\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e。然而，它可以作为衡量其他算法的标准。\u003c/span\u003e\u003c/li\u003e\u003cli id=\"234dd392c4e9dd0ebf9e661f94d080f5\"\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003eNRU\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e 算法根据 R 位和 M 位的状态将页面氛围四类。从编号最小的类别中随机选择一个页面。NRU 算法易于实现，但是性能不是很好。存在更好的算法。\u003c/span\u003e\u003c/li\u003e\u003c/ul\u003e\u003cul class=\"ne-ul\"\u003e\u003cli id=\"c8f6c0a7d8a9df2355aa867a989f0b49\"\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003eFIFO\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e 会跟踪页面加载进入内存中的顺序，并把页面放入一个链表中。有可能删除存在时间最长但是还在使用的页面，因此这个算法也不是一个很好的选择。\u003c/span\u003e\u003c/li\u003e\u003cli id=\"7fbec0a11e860f50edfed9e85c41b9f8\"\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e第二次机会\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e算法是对 FIFO 的一个修改，它会在删除页面之前检查这个页面是否仍在使用。如果页面正在使用，就会进行保留。这个改进大大提高了性能。\u003c/span\u003e\u003c/li\u003e\u003c/ul\u003e\u003cul class=\"ne-ul\"\u003e\u003cli id=\"ab0708a3d3cf4e9100075a87c9844641\"\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e时钟\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e 算法是第二次机会算法的另外一种实现形式，时钟算法和第二次算法的性能差不多，但是会花费更少的时间来执行算法。\u003c/span\u003e\u003c/li\u003e\u003cli id=\"416499a4e283e26c762f68ae643534cb\"\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003eLRU\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e 算法是一个非常优秀的算法，但是没有\u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e特殊的硬件(TLB)\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e很难实现。如果没有硬件，就不能使用 LRU 算法。\u003c/span\u003e\u003c/li\u003e\u003c/ul\u003e\u003cul class=\"ne-ul\"\u003e\u003cli id=\"0f2459808b7e2868c13dcbefd2ac7590\"\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003eNFU\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e 算法是一种近似于 LRU 的算法，它的性能不是非常好。\u003c/span\u003e\u003c/li\u003e\u003cli id=\"f620cb928c9ef81c30cec4bd9400d7ce\"\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e老化\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e 算法是一种更接近 LRU 算法的实现，并且可以更好的实现，因此是一个很好的选择\u003c/span\u003e\u003c/li\u003e\u003c/ul\u003e\u003cul class=\"ne-ul\"\u003e\u003cli id=\"69318a6d572af791c360d57906970f77\"\u003e\u003cspan class=\"ne-text\"\u003e最后两种算法都使用了工作集算法。工作集算法提供了合理的性能开销，但是它的实现比较复杂。\u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003eWSClock\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e 是另外一种变体，它不仅能够提供良好的性能，而且可以高效地实现。\u003c/span\u003e\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"d21cffc43ac7dcbfeeae73c897933787\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"943b2ac9ccdf5bcd3ad85d6c44db2f03\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e总之，\u003c/span\u003e\u003cstrong\u003e\u003cspan class=\"ne-text\"\u003e最好的算法是老化算法和WSClock算法\u003c/span\u003e\u003c/strong\u003e\u003cspan class=\"ne-text\"\u003e。他们分别是基于 LRU 和工作集算法。他们都具有良好的性能并且能够被有效的实现。还存在其他一些好的算法，但实际上这两个可能是最重要的。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"70262061a374bbe6c590cdc622d20dd3\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"318317ce1479c23add8291c2bdd17d4c\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e下面来聊一聊文件系统，你需要知道下面这些知识点\u003c/span\u003e\u003c/p\u003e\u003cp id=\"54b70121bb60e581d442d6b45ec1f775\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"0626228031f054313c8c68db9c55566d\" class=\"ne-p\"\u003e\u003cimg src=\"https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830114-09f30aaf-25b8-44c3-992a-577e4c3a833c.png\" width=\"721\" id=\"MOs6Q\" class=\"ne-image\"\u003e\u003c/p\u003e\u003cp id=\"68aa5203572adaa78a2cacc78c181478\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003ch2 id=\"2a0c4740\"\u003e\u003cspan class=\"ne-text\"\u003e文件\u003c/span\u003e\u003c/h2\u003e\u003cp id=\"0e1a4d0a2da43ff7a64f39e8a2ccc002\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003ch3 id=\"42b5d073\"\u003e\u003cspan class=\"ne-text\"\u003e文件命名\u003c/span\u003e\u003c/h3\u003e\u003cp id=\"39eaa5bb7eaee0059fc8f8ab050013c3\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"ac843df76f1fa5996bb18f7b8f3abeff\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e文件是一种抽象机制，它提供了一种方式用来存储信息以及在后面进行读取。可能任何一种机制最重要的特性就是管理对象的命名方式。在创建一个文件后，它会给文件一个命名。当进程终止时，文件会继续存在，并且其他进程可以使用\u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e名称访问该文件\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"7a4f2e6c93c769b7b830ce3a98164e0a\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"1aa170f1d7914802b5f71c9fa09eea8c\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e文件命名规则对于不同的操作系统来说是不一样的，但是所有现代操作系统都允许使用 1 - 8 个字母的字符串作为合法文件名。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"549e424671eb70506667316221ea0b6a\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"947a29553feb4fed91e398dd0b909941\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e某些文件区分大小写字母，而大多数则不区分。\u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003eUNIX\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e 属于第一类；历史悠久的 \u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003eMS-DOS\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e 属于第二类（顺便说一句，尽管 MS-DOS 历史悠久，但 MS-DOS 仍在嵌入式系统中非常广泛地使用，因此它绝不是过时的）；因此，UNIX 系统会有三种不同的命名文件：\u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003emaria\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e、\u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003eMaria\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e、\u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003eMARIA\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e 。在 MS-DOS ，所有这些命名都属于相同的文件。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"ca90743de49e769fc630a186e1284fae\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"a406e7618fc08a6827c4aef95651a84b\" class=\"ne-p\"\u003e\u003cimg src=\"https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830120-5ba4f13c-ee71-46f2-a110-e2eaf1dbf324.png\" width=\"691\" id=\"JHfwL\" class=\"ne-image\"\u003e\u003c/p\u003e\u003cp id=\"afc97bceb18793a83e8a6d91c9533dfc\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"6ae582e29691ea6d28dfb309f8a33d63\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e许多操作系统支持两部分的文件名，它们之间用 \u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e.\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e 分隔开，比如文件名 \u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003eprog.c\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e。原点后面的文件称为 \u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e文件扩展名(file extension)\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e ，文件扩展名通常表示文件的一些信息。一些常用的文件扩展名以及含义如下图所示\u003c/span\u003e\u003c/p\u003e\u003ctable id=\"7f756c92\" class=\"ne-table\" style=\"width: 750px\"\u003e\u003ctbody\u003e\u003ctr style=\"height: 33px\"\u003e\u003ctd width=\"375\"\u003e\u003cp id=\"u86bcac8e\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e扩展名\u003c/span\u003e\u003c/p\u003e\u003c/td\u003e\u003ctd width=\"375\"\u003e\u003cp id=\"u7fa179fd\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e含义\u003c/span\u003e\u003c/p\u003e\u003c/td\u003e\u003c/tr\u003e\u003ctr style=\"height: 33px\"\u003e\u003ctd width=\"375\"\u003e\u003cp id=\"u3c31ee67\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003ebak\u003c/span\u003e\u003c/p\u003e\u003c/td\u003e\u003ctd width=\"375\"\u003e\u003cp id=\"ub1009dae\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e备份文件\u003c/span\u003e\u003c/p\u003e\u003c/td\u003e\u003c/tr\u003e\u003ctr style=\"height: 33px\"\u003e\u003ctd width=\"375\"\u003e\u003cp id=\"u8e21211b\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003ec\u003c/span\u003e\u003c/p\u003e\u003c/td\u003e\u003ctd width=\"375\"\u003e\u003cp id=\"ub7814047\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003ec 源程序文件\u003c/span\u003e\u003c/p\u003e\u003c/td\u003e\u003c/tr\u003e\u003ctr style=\"height: 33px\"\u003e\u003ctd width=\"375\"\u003e\u003cp id=\"u60b4b5ca\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003egif\u003c/span\u003e\u003c/p\u003e\u003c/td\u003e\u003ctd width=\"375\"\u003e\u003cp id=\"uc630794d\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e符合图形交换格式的图像文件\u003c/span\u003e\u003c/p\u003e\u003c/td\u003e\u003c/tr\u003e\u003ctr style=\"height: 33px\"\u003e\u003ctd width=\"375\"\u003e\u003cp id=\"u8fc5ed2b\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003ehlp\u003c/span\u003e\u003c/p\u003e\u003c/td\u003e\u003ctd width=\"375\"\u003e\u003cp id=\"u4100d4e1\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e帮助文件\u003c/span\u003e\u003c/p\u003e\u003c/td\u003e\u003c/tr\u003e\u003ctr style=\"height: 33px\"\u003e\u003ctd width=\"375\"\u003e\u003cp id=\"u126c4c61\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003ehtml\u003c/span\u003e\u003c/p\u003e\u003c/td\u003e\u003ctd width=\"375\"\u003e\u003cp id=\"u6d6dd5e8\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003eWWW 超文本标记语言文档\u003c/span\u003e\u003c/p\u003e\u003c/td\u003e\u003c/tr\u003e\u003ctr style=\"height: 33px\"\u003e\u003ctd width=\"375\"\u003e\u003cp id=\"uaf121ed5\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003ejpg\u003c/span\u003e\u003c/p\u003e\u003c/td\u003e\u003ctd width=\"375\"\u003e\u003cp id=\"ud8de46a6\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e符合 JPEG 编码标准的静态图片\u003c/span\u003e\u003c/p\u003e\u003c/td\u003e\u003c/tr\u003e\u003ctr style=\"height: 33px\"\u003e\u003ctd width=\"375\"\u003e\u003cp id=\"udab5f881\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003emp3\u003c/span\u003e\u003c/p\u003e\u003c/td\u003e\u003ctd width=\"375\"\u003e\u003cp id=\"uaefb3290\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e符合 MP3 音频编码格式的音乐文件\u003c/span\u003e\u003c/p\u003e\u003c/td\u003e\u003c/tr\u003e\u003ctr style=\"height: 33px\"\u003e\u003ctd width=\"375\"\u003e\u003cp id=\"u6f6a8cf4\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003empg\u003c/span\u003e\u003c/p\u003e\u003c/td\u003e\u003ctd width=\"375\"\u003e\u003cp id=\"u4e9b5a7a\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e符合 MPEG 编码标准的电影\u003c/span\u003e\u003c/p\u003e\u003c/td\u003e\u003c/tr\u003e\u003ctr style=\"height: 33px\"\u003e\u003ctd width=\"375\"\u003e\u003cp id=\"u17182b2f\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003eo\u003c/span\u003e\u003c/p\u003e\u003c/td\u003e\u003ctd width=\"375\"\u003e\u003cp id=\"uba61755c\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e目标文件（编译器输出格式，尚未链接）\u003c/span\u003e\u003c/p\u003e\u003c/td\u003e\u003c/tr\u003e\u003ctr style=\"height: 33px\"\u003e\u003ctd width=\"375\"\u003e\u003cp id=\"uc827d007\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003epdf\u003c/span\u003e\u003c/p\u003e\u003c/td\u003e\u003ctd width=\"375\"\u003e\u003cp id=\"u490abaca\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003epdf 格式的文件\u003c/span\u003e\u003c/p\u003e\u003c/td\u003e\u003c/tr\u003e\u003ctr style=\"height: 33px\"\u003e\u003ctd width=\"375\"\u003e\u003cp id=\"u8deec9bc\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003eps\u003c/span\u003e\u003c/p\u003e\u003c/td\u003e\u003ctd width=\"375\"\u003e\u003cp id=\"u480b1c6a\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003ePostScript 文件\u003c/span\u003e\u003c/p\u003e\u003c/td\u003e\u003c/tr\u003e\u003ctr style=\"height: 33px\"\u003e\u003ctd width=\"375\"\u003e\u003cp id=\"u3341c4b9\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003etex\u003c/span\u003e\u003c/p\u003e\u003c/td\u003e\u003ctd width=\"375\"\u003e\u003cp id=\"uef7e717f\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e为 TEX 格式化程序准备的输入文件\u003c/span\u003e\u003c/p\u003e\u003c/td\u003e\u003c/tr\u003e\u003ctr style=\"height: 33px\"\u003e\u003ctd width=\"375\"\u003e\u003cp id=\"u563e6d6d\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003etxt\u003c/span\u003e\u003c/p\u003e\u003c/td\u003e\u003ctd width=\"375\"\u003e\u003cp id=\"u230821ad\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e文本文件\u003c/span\u003e\u003c/p\u003e\u003c/td\u003e\u003c/tr\u003e\u003ctr style=\"height: 33px\"\u003e\u003ctd width=\"375\"\u003e\u003cp id=\"u77e32004\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003ezip\u003c/span\u003e\u003c/p\u003e\u003c/td\u003e\u003ctd width=\"375\"\u003e\u003cp id=\"u599395eb\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e压缩文件\u003c/span\u003e\u003c/p\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003cp id=\"c6ab14359737194a972479d8287c47a1\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"4549bf524aabfd45c2fa83047348e305\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e在 UNIX 系统中，文件扩展名只是一种约定，操作系统并不强制采用。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"d4f6ff6d0e62a25ca2d68a7c83d9af63\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003ch3 id=\"68d96662\"\u003e\u003cspan class=\"ne-text\"\u003e文件结构\u003c/span\u003e\u003c/h3\u003e\u003cp id=\"e267d3840df18b33c8d7169b8089f9f5\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"aab7d13a47a4100ca4968738f5dec9af\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e文件的构造有多种方式。下图列出了常用的三种构造方式\u003c/span\u003e\u003c/p\u003e\u003cp id=\"05b429377a0f05d00edcba9ad1341ff3\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"0eeb7da1658a82bc57977ae24dd2c8e8\" class=\"ne-p\"\u003e\u003cimg src=\"https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830179-1cd3ea7b-cf21-432f-a8e4-c2d8f317e0ff.png\" width=\"728\" id=\"HSm1k\" class=\"ne-image\"\u003e\u003c/p\u003e\u003cp id=\"66e04dd599052b4626cdb9aedfdd4ce2\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"84f276b301ae3859ddde1903c0c2b706\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e 三种不同的文件。 a) 字节序列 。b) 记录序列。c) 树\u003c/span\u003e\u003c/p\u003e\u003cp id=\"0e82b2e8eb49dec1dc54c30359b708b0\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"a970ad933a1746cea41087c5b928095b\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e上图中的 a 是一种无结构的字节序列，操作系统不关心序列的内容是什么，操作系统能看到的就是\u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e字节(bytes)\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e。其文件内容的任何含义只在用户程序中进行解释。UNIX 和 Windows 都采用这种办法。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"715200795b1099f573c996fc4f5ade2c\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"e40d5e148ce0e55c7c15939cc5e60d7c\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e图 b 表示在文件结构上的第一部改进。在这个模型中，文件是具有固定长度记录的序列，每个记录都有其内部结构。 把文件作为记录序列的核心思想是：\u003c/span\u003e\u003cstrong\u003e\u003cspan class=\"ne-text\"\u003e读操作返回一个记录，而写操作重写或者追加一个记录\u003c/span\u003e\u003c/strong\u003e\u003cspan class=\"ne-text\"\u003e。第三种文件结构如上图 c 所示。在这种组织结构中，文件由一颗\u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e记录树\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e构成，记录树的长度不一定相同，每个记录树都在记录中的固定位置包含一个\u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003ekey\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e 字段。这棵树按 key 进行排序，从而可以对特定的 key 进行快速查找。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"a3805c0b27de6eb1994037fb394c695d\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003ch3 id=\"28b988ce\"\u003e\u003cspan class=\"ne-text\"\u003e文件类型\u003c/span\u003e\u003c/h3\u003e\u003cp id=\"dd0277dd6c9510a4288d26904622fa34\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"700a86aaacacb207860a5ef065bfc842\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e很多操作系统支持多种文件类型。例如，UNIX（同样包括 OS X）和 Windows 都具有常规的文件和目录。除此之外，UNIX 还具有\u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e字符特殊文件(character special file)\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e 和 \u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e块特殊文件(block special file)\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e。\u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e常规文件(Regular files)\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e 是包含有用户信息的文件。用户一般使用的文件大都是常规文件，常规文件一般包括 \u003c/span\u003e\u003cstrong\u003e\u003cspan class=\"ne-text\"\u003e可执行文件、文本文件、图像文件\u003c/span\u003e\u003c/strong\u003e\u003cspan class=\"ne-text\"\u003e，从常规文件读取数据或将数据写入时，内核会根据文件系统的规则执行操作，是写入可能被延迟，记录日志或者接受其他操作。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"d803466fc9fe85690453543577916782\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003ch3 id=\"2ca5dd51\"\u003e\u003cspan class=\"ne-text\"\u003e文件访问\u003c/span\u003e\u003c/h3\u003e\u003cp id=\"1eea59f4629deed14c4bbefdb9ff560d\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"b132fe515bd7dd759ef63c37eb082a61\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e早期的操作系统只有一种访问方式：\u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e序列访问(sequential access)\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e。在这些系统中，进程可以按照顺序读取所有的字节或文件中的记录，但是不能跳过并乱序执行它们。顺序访问文件是可以返回到起点的，需要时可以多次读取该文件。当存储介质是磁带而不是磁盘时，顺序访问文件很方便。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"2149db0b1f4aef60c803eb241beaceb9\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"dce71c7fccbf2fc8964d659038be9e03\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e在使用磁盘来存储文件时，可以不按照顺序读取文件中的字节或者记录，或者按照关键字而不是位置来访问记录。这种能够以任意次序进行读取的称为\u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e随机访问文件(random access file)\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e。许多应用程序都需要这种方式。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"4f74717aa95a17e1fcd34889477b996a\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"008ff964469f0ec53c27329344f05020\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e随机访问文件对许多应用程序来说都必不可少，例如，数据库系统。如果乘客打电话预定某航班机票，订票程序必须能够直接访问航班记录，而不必先读取其他航班的成千上万条记录。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"53807ed6cd70ab7d582f3dcdc0fc14c0\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"af6c758e0caff2e1a559f009fefe473e\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e有两种方法可以指示从何处开始读取文件。第一种方法是直接使用 \u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003eread\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e 从头开始读取。另一种是用一个特殊的 \u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003eseek\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e 操作设置当前位置，在 seek 操作后，从这个当前位置顺序地开始读文件。UNIX 和 Windows 使用的是后面一种方式。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"8020d0101a5f3dcbb54621b955f23d0b\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003ch3 id=\"0b81772b\"\u003e\u003cspan class=\"ne-text\"\u003e文件属性\u003c/span\u003e\u003c/h3\u003e\u003cp id=\"8062f25c30a983560cb8b3e049ade111\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"3b59c2728b8366a73b1922e7adf5feb0\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e文件包括文件名和数据。除此之外，所有的操作系统还会保存其他与文件相关的信息，如文件创建的日期和时间、文件大小。我们可以称这些为文件的\u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e属性(attributes)\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e。有些人也喜欢把它们称作 \u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e元数据(metadata)\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e。文件的属性在不同的系统中差别很大。文件的属性只有两种状态：\u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e设置(set)\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e 和 \u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e清除(clear)\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"ff3234edb116466cf8feb1acf75da02b\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003ch3 id=\"52cefcb2\"\u003e\u003cspan class=\"ne-text\"\u003e文件操作\u003c/span\u003e\u003c/h3\u003e\u003cp id=\"1e779b7cc62a0d85bd60f607a32dfe08\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"de771a10ee395dd67ec222bec5fdecb7\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e使用文件的目的是用来存储信息并方便以后的检索。对于存储和检索，不同的系统提供了不同的操作。以下是与文件有关的最常用的一些系统调用：\u003c/span\u003e\u003c/p\u003e\u003cp id=\"c0724f0565ae49c0d6b6cc475b6ac846\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003col class=\"ne-ol\"\u003e\u003cli id=\"504ecd73fd5ceecb12f3932e3f9b2ca1\"\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003eCreate\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e，创建不包含任何数据的文件。调用的目的是表示文件即将建立，并对文件设置一些属性。\u003c/span\u003e\u003c/li\u003e\u003cli id=\"179ee01cd008860de8a7a253e9d18249\"\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003eDelete\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e，当文件不再需要，必须删除它以释放内存空间。为此总会有一个系统调用来删除文件。\u003c/span\u003e\u003c/li\u003e\u003c/ol\u003e\u003col start=\"3\" class=\"ne-ol\"\u003e\u003cli id=\"328a4d096282ef0c9bd3f349be56947f\"\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003eOpen\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e，在使用文件之前，必须先打开文件。这个调用的目的是允许系统将属性和磁盘地址列表保存到主存中，用来以后的快速访问。\u003c/span\u003e\u003c/li\u003e\u003cli id=\"7c85b0b657768dc1ce22864b71e5a08e\"\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003eClose\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e，当所有进程完成时，属性和磁盘地址不再需要，因此应关闭文件以释放表空间。很多系统限制进程打开文件的个数，以此达到鼓励用户关闭不再使用的文件。磁盘以块为单位写入，关闭文件时会强制写入最后一\u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e块\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e，即使这个块空间内部还不满。\u003c/span\u003e\u003c/li\u003e\u003c/ol\u003e\u003col start=\"5\" class=\"ne-ol\"\u003e\u003cli id=\"50bfb078134ebd8dff44c5657d8994e7\"\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003eRead\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e，数据从文件中读取。通常情况下，读取的数据来自文件的当前位置。调用者必须指定需要读取多少数据，并且提供存放这些数据的缓冲区。\u003c/span\u003e\u003c/li\u003e\u003cli id=\"43384bb690645e13a262e1955f177b7a\"\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003eWrite\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e，向文件写数据，写操作一般也是从文件的当前位置开始进行。如果当前位置是文件的末尾，则会直接追加进行写入。如果当前位置在文件中，则现有数据被覆盖，并且永远消失。\u003c/span\u003e\u003c/li\u003e\u003c/ol\u003e\u003col start=\"7\" class=\"ne-ol\"\u003e\u003cli id=\"e3f6ff74f235e372c8bbf5609d277cd8\"\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003eappend\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e，使用 append 只能向文件末尾添加数据。\u003c/span\u003e\u003c/li\u003e\u003cli id=\"b9c24d0c6b35e2bb0b54f846c2f3cbe2\"\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003eseek\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e，对于随机访问的文件，要指定从何处开始获取数据。通常的方法是用 seek 系统调用把当前位置指针指向文件中的特定位置。seek 调用结束后，就可以从指定位置开始读写数据了。\u003c/span\u003e\u003c/li\u003e\u003c/ol\u003e\u003col start=\"9\" class=\"ne-ol\"\u003e\u003cli id=\"922b6108cf62d8263fbd88c8d5498241\"\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003eget attributes\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e，进程运行时通常需要读取文件属性。\u003c/span\u003e\u003c/li\u003e\u003cli id=\"8c8e3ceb23d3a616b99b8b941b08aa52\"\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003eset attributes\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e，用户可以自己设置一些文件属性，甚至是在文件创建之后，实现该功能的是 set attributes 系统调用。\u003c/span\u003e\u003c/li\u003e\u003c/ol\u003e\u003col start=\"11\" class=\"ne-ol\"\u003e\u003cli id=\"e72eb2d85f14c3f7ac4d9fd59c6888b7\"\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003erename\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e，用户可以自己更改已有文件的名字，rename 系统调用用于这一目的。\u003c/span\u003e\u003c/li\u003e\u003c/ol\u003e\u003cp id=\"a87343eaf9d3450efabef778da123d99\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003ch2 id=\"767fa455\"\u003e\u003cspan class=\"ne-text\"\u003e目录\u003c/span\u003e\u003c/h2\u003e\u003cp id=\"b9343aee17ca89896a9c0199f20a54f1\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"3c356aca639851aa2446430e0cf3733e\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e文件系统通常提供\u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e目录(directories)\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e 或者 \u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e文件夹(folders)\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e 用于记录文件的位置，在很多系统中目录本身也是文件，下面我们会讨论关于文件，他们的组织形式、属性和可以对文件进行的操作。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"dff0717322930d1c24e5ab4609400092\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003ch3 id=\"007929bd\"\u003e\u003cspan class=\"ne-text\"\u003e一级目录系统\u003c/span\u003e\u003c/h3\u003e\u003cp id=\"34540bcb72c35b535e539c2292febbbb\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"54065234453c67a62e92fdfbb18d6e66\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e目录系统最简单的形式是有一个能够包含所有文件的目录。这种目录被称为\u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e根目录(root directory)\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e，由于根目录的唯一性，所以其名称并不重要。在最早期的个人计算机中，这种系统很常见，部分原因是因为只有一个用户。下面是一个单层目录系统的例子\u003c/span\u003e\u003c/p\u003e\u003cp id=\"608cd64c499251753f32da03fb38243a\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"487deb8f9d390dd52747ae3a2d276448\" class=\"ne-p\"\u003e\u003cimg src=\"https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830155-ca95d416-207a-46d6-89dd-77c398a175d3.png\" width=\"500\" id=\"LyUcX\" class=\"ne-image\"\u003e\u003c/p\u003e\u003cp id=\"45f33aa4b012163e958412625f737ea8\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"888aed0ab34181e2ca6fdb1bf464feae\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e 含有四个文件的单层目录系统\u003c/span\u003e\u003c/p\u003e\u003cp id=\"6c96f97c55ea84f77c4863a07950cfa6\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"06c45b31715829537869cc1e51ceae82\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e该目录中有四个文件。这种设计的优点在于简单，并且能够快速定位文件，毕竟只有一个地方可以检索。这种目录组织形式现在一般用于简单的嵌入式设备（如数码相机和某些便携式音乐播放器）上使用。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"05cc9579be20bd8d9cd8382cc614bdd7\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003ch3 id=\"17225630\"\u003e\u003cspan class=\"ne-text\"\u003e层次目录系统\u003c/span\u003e\u003c/h3\u003e\u003cp id=\"a2f4aec9d46fbfd0fca6e2d7fbefc82e\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"7a7f44ac2994c611f0b66c4e87c0d70e\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e对于简单的应用而言，一般都用单层目录方式，但是这种组织形式并不适合于现代计算机，因为现代计算机含有成千上万个文件和文件夹。如果都放在根目录下，查找起来会非常困难。为了解决这一问题，出现了\u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e层次目录系统(Hierarchical Directory Systems)\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e，也称为\u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e目录树\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e。通过这种方式，可以用很多目录把文件进行分组。进而，如果多个用户共享同一个文件服务器，比如公司的网络系统，每个用户可以为自己的目录树拥有自己的私人根目录。这种方式的组织结构如下\u003c/span\u003e\u003c/p\u003e\u003cp id=\"dbf72bf64d673a9ed4ac556da2b03fc5\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"8fd241c376d25d675006401b0450d10d\" class=\"ne-p\"\u003e\u003cimg src=\"https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830190-cdcd48b8-b7ca-4597-b41d-d61089e0250d.png\" width=\"699\" id=\"eyi1a\" class=\"ne-image\"\u003e\u003c/p\u003e\u003cp id=\"595388086341aaf9ea0cc4f986c5f072\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"1facfc7d32c49c743af569c6eac8ba13\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e根目录含有目录 A、B 和 C ，分别属于不同的用户，其中两个用户个字创建了\u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e子目录\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e。用户可以创建任意数量的子目录，现代文件系统都是按照这种方式组织的。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"9606d66d6cd5e0bfc4b92e125dce83ca\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003ch3 id=\"26f36dea\"\u003e\u003cspan class=\"ne-text\"\u003e路径名\u003c/span\u003e\u003c/h3\u003e\u003cp id=\"3c68cf4eceb1aebdebb0636d38b6d630\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"20cf84ba39d49bdb319108dd01bd8f7c\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e当目录树组织文件系统时，需要有某种方法指明文件名。常用的方法有两种，第一种方式是每个文件都会用一个\u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e绝对路径名(absolute path name)\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e，它由根目录到文件的路径组成。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"7375343f1d5a3e86bc7693dec3e4e850\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"1864d899922b43e08ec349f3b9185a11\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e另外一种指定文件名的方法是 \u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e相对路径名(relative path name)\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e。它常常和 \u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e工作目录(working directory)\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e （也称作 \u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e当前目录(current directory)\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e）一起使用。用户可以指定一个目录作为当前工作目录。例如，如果当前目录是 \u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e/usr/ast\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e，那么绝对路径 \u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e/usr/ast/mailbox\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e可以直接使用 \u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003emailbox\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e 来引用。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"4d86e51488f9e3357b3d1c7316d4d4ee\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003ch3 id=\"20731fe2\"\u003e\u003cspan class=\"ne-text\"\u003e目录操作\u003c/span\u003e\u003c/h3\u003e\u003cp id=\"72f0e76f51955e4fd5747f7f47125254\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"5a42d88e3de5412699ce7ef46d8b0754\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e不同文件中管理目录的系统调用的差别比管理文件的系统调用差别大。为了了解这些系统调用有哪些以及它们怎样工作，下面给出一个例子（取自 UNIX）。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"40bbdad75c7cc6d07a2763e60ee386b6\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003col class=\"ne-ol\"\u003e\u003cli id=\"b514136adfffb03de670ef5af862b47c\"\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003eCreate\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e，创建目录，除了目录项 \u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e.\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e 和 \u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e..\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e 外，目录内容为空。\u003c/span\u003e\u003c/li\u003e\u003cli id=\"b11a83b53464bd86401aa01c73f5c27f\"\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003eDelete\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e，删除目录，只有空目录可以删除。只包含 \u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e.\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e 和 \u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e..\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e 的目录被认为是空目录，这两个目录项通常不能删除\u003c/span\u003e\u003c/li\u003e\u003c/ol\u003e\u003col start=\"3\" class=\"ne-ol\"\u003e\u003cli id=\"963fdf6f08b50d63286bc505dffbf5fb\"\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003eopendir\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e，目录内容可被读取。例如，未列出目录中的全部文件，程序必须先打开该目录，然后读其中全部文件的文件名。与打开和读文件相同，在读目录前，必须先打开文件。\u003c/span\u003e\u003c/li\u003e\u003cli id=\"c74b7a45eea8a24a9f1c8549c7864719\"\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003eclosedir\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e，读目录结束后，应该关闭目录用于释放内部表空间。\u003c/span\u003e\u003c/li\u003e\u003c/ol\u003e\u003col start=\"5\" class=\"ne-ol\"\u003e\u003cli id=\"17dd041b9516a40a3358c45b1362d7ec\"\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003ereaddir\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e，系统调用 readdir 返回打开目录的下一个目录项。以前也采用 read 系统调用来读取目录，但是这种方法有一个缺点：程序员必须了解和处理目录的内部结构。相反，不论采用哪一种目录结构，readdir 总是以标准格式返回一个目录项。\u003c/span\u003e\u003c/li\u003e\u003cli id=\"4f848d51acdd481545cb2cb86b2d4a9b\"\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003erename\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e，在很多方面目录和文件都相似。文件可以更换名称，目录也可以。\u003c/span\u003e\u003c/li\u003e\u003c/ol\u003e\u003col start=\"7\" class=\"ne-ol\"\u003e\u003cli id=\"edbace6607fb3be4e1b637a1dd9aa171\"\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003elink\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e，链接技术允许在多个目录中出现同一个文件。这个系统调用指定一个存在的文件和一个路径名，并建立从该文件到路径所指名字的链接。这样，可以在多个目录中出现同一个文件。有时也被称为\u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e硬链接(hard link)\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e。\u003c/span\u003e\u003c/li\u003e\u003cli id=\"2cc1cbbf1be79fb5e132a02d030c0afc\"\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003eunlink\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e，删除目录项。如果被解除链接的文件只出现在一个目录中，则将它从文件中删除。如果它出现在多个目录中，则只删除指定路径名的链接，依然保留其他路径名的链接。在 UNIX 中，用于删除文件的系统调用就是 unlink。\u003c/span\u003e\u003c/li\u003e\u003c/ol\u003e\u003cp id=\"885d73b5a39a7c004346a847d1440b8a\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003ch2 id=\"f7f29532\"\u003e\u003cspan class=\"ne-text\"\u003e文件系统的实现\u003c/span\u003e\u003c/h2\u003e\u003cp id=\"ec714890f3489b939201876f99912a34\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003ch3 id=\"063a94b5\"\u003e\u003cspan class=\"ne-text\"\u003e文件系统布局\u003c/span\u003e\u003c/h3\u003e\u003cp id=\"4a9f73122edec1e3f247798ed5bb6ed5\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"861f46d91942e981cc98ea26967493e0\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e文件系统存储在\u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e磁盘\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e中。大部分的磁盘能够划分出一到多个分区，叫做\u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e磁盘分区(disk partitioning)\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e 或者是\u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e磁盘分片(disk slicing)\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e。每个分区都有独立的文件系统，每块分区的文件系统可以不同。磁盘的 0 号分区称为 \u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e主引导记录(Master Boot Record, MBR)\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e，用来\u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e引导(boot)\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e 计算机。在 MBR 的结尾是\u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e分区表(partition table)\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e。每个分区表给出每个分区由开始到结束的地址。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"0721c038245fb84b7719e05e8f622ff2\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"9a6cf1225520c728351597ee0e399155\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e当计算机开始引 boot 时，BIOS 读入并执行 MBR。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"75737c56aefb3c7fffd13019a2a1d831\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003ch4 id=\"740649ac\"\u003e\u003cspan class=\"ne-text\"\u003e引导块\u003c/span\u003e\u003c/h4\u003e\u003cp id=\"79156822d8503698dc82e2138c609266\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"3ff3214b74c0925029bca92abe9ea54e\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003eMBR 做的第一件事就是\u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e确定活动分区\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e，读入它的第一个块，称为\u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e引导块(boot block)\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e 并执行。引导块中的程序将加载分区中的操作系统。为了一致性，每个分区都会从引导块开始，即使引导块不包含操作系统。引导块占据文件系统的前 4096 个字节，从磁盘上的字节偏移量 0 开始。引导块可用于启动操作系统。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"cc963be5f996c475d719d40c4fa10893\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"4eff089b1ed72dbedc26da706d2b576c\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e除了从引导块开始之外，磁盘分区的布局是随着文件系统的不同而变化的。通常文件系统会包含一些属性，如下\u003c/span\u003e\u003c/p\u003e\u003cp id=\"418b125edcf82ba1123e87efba837f9e\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"6e21b01c67c9de127bae097535ad2d34\" class=\"ne-p\"\u003e\u003cimg src=\"https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830178-416c1399-355d-4e11-aaad-360c3071d651.png\" width=\"725\" id=\"WO5Ij\" class=\"ne-image\"\u003e\u003c/p\u003e\u003cp id=\"802ba5c7e2c81d6c079467b487a35ee2\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"70b4cab1c421609e38e9318a8e29f8ed\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e 文件系统布局\u003c/span\u003e\u003c/p\u003e\u003cp id=\"bc19ea1c5561802b619f7862b16edf7e\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003ch4 id=\"0f7ddcc2\"\u003e\u003cspan class=\"ne-text\"\u003e超级块\u003c/span\u003e\u003c/h4\u003e\u003cp id=\"a899d94ff2d728d47e586dc99a20e67d\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"87b2599a79fc028dca72250f4bb1b6c9\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e紧跟在引导块后面的是 \u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e超级块(Superblock)\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e，超级块 的大小为 4096 字节，从磁盘上的字节偏移 4096 开始。超级块包含文件系统的所有关键参数\u003c/span\u003e\u003c/p\u003e\u003cp id=\"1476e552c3b10f8582475439b1afb325\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cul class=\"ne-ul\"\u003e\u003cli id=\"e4948c5816657ad07b16d2106062394d\"\u003e\u003cspan class=\"ne-text\"\u003e文件系统的大小\u003c/span\u003e\u003c/li\u003e\u003cli id=\"8d63325fca6fd5dd7c277423a3ee972d\"\u003e\u003cspan class=\"ne-text\"\u003e文件系统中的数据块数\u003c/span\u003e\u003c/li\u003e\u003c/ul\u003e\u003cul class=\"ne-ul\"\u003e\u003cli id=\"587353c806d7ddc766494832594e262c\"\u003e\u003cspan class=\"ne-text\"\u003e指示文件系统状态的标志\u003c/span\u003e\u003c/li\u003e\u003cli id=\"cc7684fc661626e2319cfe80411a56cc\"\u003e\u003cspan class=\"ne-text\"\u003e分配组大小\u003c/span\u003e\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"2a9a7c180f2ee41597fc75f3099404ed\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"e5bdce31d9d48389f4afd8a853074c25\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e在计算机启动或者文件系统首次使用时，超级块会被读入内存。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"cdfd564f630ad7e23f32c907e7be4764\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003ch4 id=\"d1ac35a8\"\u003e\u003cspan class=\"ne-text\"\u003e空闲空间块\u003c/span\u003e\u003c/h4\u003e\u003cp id=\"6c535e1a3405fed739b7db4477fcfe06\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"e75d427462705c57bc53dcb068c3ec3f\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e接着是文件系统中\u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e空闲块\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e的信息，例如，可以用位图或者指针列表的形式给出。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"310d3be16358713f214a0b655e726d8f\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"277b5380d1da751428660b1bcedfa5ff\" class=\"ne-p\"\u003e\u003cstrong\u003e\u003cspan class=\"ne-text\"\u003eBitMap 位图或者 Bit vector 位向量\u003c/span\u003e\u003c/strong\u003e\u003c/p\u003e\u003cp id=\"d4f7482f58816535906052b8e6a7d87e\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"55cffd4813169a9f5d4e6c6b2c0e7ec4\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e位图或位向量是一系列位或位的集合，其中每个位对应一个磁盘块，该位可以采用两个值：0和1，0表示已分配该块，而1表示一个空闲块。下图中的磁盘上给定的磁盘块实例（分配了绿色块）可以用16位的位图表示为：0000111000000110。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"0af159c768142dd2b260c453127538c0\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"093caab837a37d141b3925293bf9714d\" class=\"ne-p\"\u003e\u003cimg src=\"https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830202-8aab8dd3-4293-45ca-ab73-fdf893584edc.png\" width=\"395\" id=\"NJVi8\" class=\"ne-image\"\u003e\u003c/p\u003e\u003cp id=\"8705f7dfac212aab78bf0ab7417d616e\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"f331be17432c09b9a9f2000d393d383a\" class=\"ne-p\"\u003e\u003cstrong\u003e\u003cspan class=\"ne-text\"\u003e使用链表进行管理\u003c/span\u003e\u003c/strong\u003e\u003c/p\u003e\u003cp id=\"ae280515e910cb48e7500b5ab206df39\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"a1ef494d8b253a9a5c23a588a613ec9b\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e在这种方法中，空闲磁盘块链接在一起，即一个空闲块包含指向下一个空闲块的指针。第一个磁盘块的块号存储在磁盘上的单独位置，也缓存在内存中。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"7161779eddc824e1d1133e5170bb19c8\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"1e7553f5324ffb7c2a2dc274b3f94e7b\" class=\"ne-p\"\u003e\u003cimg src=\"https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830218-bc0ef6e9-c0df-4495-9a7f-4bd5161d4bef.png\" width=\"432\" id=\"dvjrg\" class=\"ne-image\"\u003e\u003c/p\u003e\u003cp id=\"63945d94feb7a4c5fb0b41b6083864f8\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003ch4 id=\"4f0b14f4\"\u003e\u003cspan class=\"ne-text\"\u003e碎片\u003c/span\u003e\u003c/h4\u003e\u003cp id=\"75254f59dc781b72e779b3fe96e7a629\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"e541583744244097bd2f9fa7b3bb37c5\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e这里不得不提一个叫做\u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e碎片(fragment)\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e的概念，也称为片段。一般零散的单个数据通常称为片段。 磁盘块可以进一步分为固定大小的分配单元，片段只是在驱动器上彼此不相邻的文件片段。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"3f26e24c7f974df5bffef64b27e565d5\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003ch4 id=\"inode\"\u003e\u003cspan class=\"ne-text\"\u003einode\u003c/span\u003e\u003c/h4\u003e\u003cp id=\"6fc1903ad5e0e3115581a601fdd7564b\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"8363cd64eb86a68613f21c83f735a113\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e然后在后面是一个 \u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003einode(index node)\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e，也称作索引节点。它是一个数组的结构，每个文件有一个 inode，inode 非常重要，它说明了文件的方方面面。每个索引节点都存储对象数据的属性和磁盘块位置\u003c/span\u003e\u003c/p\u003e\u003cp id=\"c4e25dd9c42034d98f8d6ead66069b73\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"78b35dea2fbf0caa97c6a0e4d341729f\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e有一种简单的方法可以找到它们 \u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003els -lai\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e 命令。让我们看一下根文件系统：\u003c/span\u003e\u003c/p\u003e\u003cp id=\"f73d13b715b79dd4b9d2a3973799f1b2\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"23fc4b493a2a8cacfd956a7a12ea18fa\" class=\"ne-p\"\u003e\u003cimg src=\"https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830231-757b0e6a-7a82-4ec8-9a1c-15b9999e0185.png\" width=\"725\" id=\"dyXmP\" class=\"ne-image\"\u003e\u003c/p\u003e\u003cp id=\"7cdc062285235cfe9cc6d010d78172ec\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"1a3a5b8a310886a6d1c3ee8aa40ca65a\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003einode 节点主要包括了以下信息\u003c/span\u003e\u003c/p\u003e\u003cp id=\"0f214c2c872e0efbb561a09eee7fd193\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cul class=\"ne-ul\"\u003e\u003cli id=\"4e0fc36ad25bba57c6c83faee15237e8\"\u003e\u003cspan class=\"ne-text\"\u003e模式/权限（保护）\u003c/span\u003e\u003c/li\u003e\u003cli id=\"823d04a8b16ecce489446613644eb5f3\"\u003e\u003cspan class=\"ne-text\"\u003e所有者 ID\u003c/span\u003e\u003c/li\u003e\u003c/ul\u003e\u003cul class=\"ne-ul\"\u003e\u003cli id=\"36a513e2056edf128f901912bdd5844a\"\u003e\u003cspan class=\"ne-text\"\u003e组 ID\u003c/span\u003e\u003c/li\u003e\u003cli id=\"546b99bab3f0efe6dd65374f82ea512f\"\u003e\u003cspan class=\"ne-text\"\u003e文件大小\u003c/span\u003e\u003c/li\u003e\u003c/ul\u003e\u003cul class=\"ne-ul\"\u003e\u003cli id=\"ca587e18e953730b595535a6d2c2a52e\"\u003e\u003cspan class=\"ne-text\"\u003e文件的硬链接数\u003c/span\u003e\u003c/li\u003e\u003cli id=\"d902e80175e84a5d6d169458079df074\"\u003e\u003cspan class=\"ne-text\"\u003e上次访问时间\u003c/span\u003e\u003c/li\u003e\u003c/ul\u003e\u003cul class=\"ne-ul\"\u003e\u003cli id=\"c4df7d4c30aeed369984820d84d672ae\"\u003e\u003cspan class=\"ne-text\"\u003e最后修改时间\u003c/span\u003e\u003c/li\u003e\u003cli id=\"4cf9ad6d8fd4f59667245e548904693e\"\u003e\u003cspan class=\"ne-text\"\u003einode 上次修改时间\u003c/span\u003e\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"63d51221d1e89f15fef8cf8046b41c7f\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"edba86612d73fee8953765e5d1e71604\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e文件分为两部分，索引节点和块。一旦创建后，每种类型的块数是固定的。你不能增加分区上 inode 的数量，也不能增加磁盘块的数量。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"bab0d6d8fdb7ade0c409c63b794198cd\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"257f76d41594956d4e6f434c94fcd48f\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e紧跟在 inode 后面的是根目录，它存放的是文件系统目录树的根部。最后，磁盘的其他部分存放了其他所有的目录和文件。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"07384bc2838ccc280811305a814ac5ae\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003ch3 id=\"2fa1f996\"\u003e\u003cspan class=\"ne-text\"\u003e文件的实现\u003c/span\u003e\u003c/h3\u003e\u003cp id=\"99b6ccd02eb7d36b23ac87b3d23be908\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"520d4f89043e0d3ef94e335ae502c537\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e最重要的问题是记录各个文件分别用到了哪些磁盘块。不同的系统采用了不同的方法。下面我们会探讨一下这些方式。分配背后的主要思想是\u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e有效利用文件空间\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e和\u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e快速访问文件\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e ，主要有三种分配方案\u003c/span\u003e\u003c/p\u003e\u003cp id=\"d5bcaa062d84a2587d7983f841a8bb43\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cul class=\"ne-ul\"\u003e\u003cli id=\"bd6f72f15903e819e6825d6a4c7d5066\"\u003e\u003cspan class=\"ne-text\"\u003e连续分配\u003c/span\u003e\u003c/li\u003e\u003cli id=\"73e9c7cdab99a93a7b5d1cff4ce5bee3\"\u003e\u003cspan class=\"ne-text\"\u003e链表分配\u003c/span\u003e\u003c/li\u003e\u003c/ul\u003e\u003cul class=\"ne-ul\"\u003e\u003cli id=\"6c8d5f5e0b3f6cbb9bedb283610e1607\"\u003e\u003cspan class=\"ne-text\"\u003e索引分配\u003c/span\u003e\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"272e01376fc108d16c05972efeddd7b6\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003ch4 id=\"72b53a95\"\u003e\u003cspan class=\"ne-text\"\u003e连续分配\u003c/span\u003e\u003c/h4\u003e\u003cp id=\"bb7d19bc0a00fea5cb03d6b986da98b5\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"739ceabf45e4e532ceaee28804bd6747\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e最简单的分配方案是把每个文件作为一连串连续数据块存储在磁盘上。因此，在具有 1KB 块的磁盘上，将为 50 KB 文件分配 50 个连续块。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"57e7fce6afec06f7bac3cc1f758e706a\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"f485071b361eacaef97f0d6bc93d38d0\" class=\"ne-p\"\u003e\u003cimg src=\"https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830290-96589d90-fa12-43fb-a38a-8ece59db8fcd.png\" width=\"708\" id=\"DEFjo\" class=\"ne-image\"\u003e\u003c/p\u003e\u003cp id=\"149d6540bff10fd348ccf39a548b4008\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"ad710f4df53ff897f898e195d3474ef4\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e 使用连续空间存储文件\u003c/span\u003e\u003c/p\u003e\u003cp id=\"6e62bb3ca3c03233a13af4af40a1e434\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"4409e41335edde0a0d4bead916ef1d10\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e上面展示了 40 个连续的内存块。从最左侧的 0 块开始。初始状态下，还没有装载文件，因此磁盘是空的。接着，从磁盘开始处（块 0 ）处开始写入占用 4 块长度的内存 A 。然后是一个占用 6 块长度的内存 B，会直接在 A 的末尾开始写。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"eb491f935999b43456e0680eb86056c0\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"1dbb3a5ff9f7fb7ded0538273ec30ec5\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e注意每个文件都会在新的文件块开始写，所以如果文件 A 只占用了 \u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e3 又 1/2\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e 个块，那么最后一个块的部分内存会被浪费。在上面这幅图中，总共展示了 7 个文件，每个文件都会从上个文件的末尾块开始写新的文件块。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"4d302f7f8ae1e2e3584289e94f7b7ee2\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"ea5e53beccedfc7b48a72979c05ce798\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e连续的磁盘空间分配有两个优点。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"429ef5981f289b4d48278e8e51438334\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cul class=\"ne-ul\"\u003e\u003cli id=\"07797a0fdd2cc4666f9a5e4a2b80175a\"\u003e\u003cspan class=\"ne-text\"\u003e第一，连续文件存储实现起来比较简单，只需要记住两个数字就可以：一个是第一个块的文件地址和文件的块数量。给定第一个块的编号，可以通过简单的加法找到任何其他块的编号。\u003c/span\u003e\u003c/li\u003e\u003cli id=\"40dc07731b88d5bc4e9f39dbda642ece\"\u003e\u003cspan class=\"ne-text\"\u003e第二点是读取性能比较强，可以通过一次操作从文件中读取整个文件。只需要一次寻找第一个块。后面就不再需要寻道时间和旋转延迟，所以数据会以全带宽进入磁盘。\u003c/span\u003e\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"fb5eddf328615cd7b667cd0f76ed8064\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"c211a55fb8333594f2910711c0080375\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e因此，连续的空间分配具有\u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e实现简单\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e、\u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e高性能\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e的特点。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"226cf8984f3e14ad2f869b70b0ae3d25\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"584d3adf6df424e0caad8d640306ac6f\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e不幸的是，连续空间分配也有很明显的不足。随着时间的推移，磁盘会变得很零碎。下图解释了这种现象\u003c/span\u003e\u003c/p\u003e\u003cp id=\"beb6289ffd948b913ab42f89fc806491\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"3ca05927b2bc30ed4efbcbe0009b626d\" class=\"ne-p\"\u003e\u003cimg src=\"https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830262-ef7ce9d8-c4b9-488c-a2d3-48d7888ffe1f.png\" width=\"700\" id=\"AWBOd\" class=\"ne-image\"\u003e\u003c/p\u003e\u003cp id=\"da80c0e171d6555b328959c948dd63da\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"665c27cdd3d5d092fa41038401e02f09\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e这里有两个文件 D 和 F 被删除了。当删除一个文件时，此文件所占用的块也随之释放，就会在磁盘空间中留下一些空闲块。磁盘并不会在这个位置挤压掉空闲块，因为这会复制空闲块之后的所有文件，可能会有上百万的块，这个量级就太大了。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"516ce272d9891eb30c2670ca8fd9c815\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003ch4 id=\"3d0c6331\"\u003e\u003cspan class=\"ne-text\"\u003e链表分配\u003c/span\u003e\u003c/h4\u003e\u003cp id=\"b3b68de304c1d67898de10b8a645632c\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"8ee621e84c761779bda7b9527721198f\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e第二种存储文件的方式是为每个文件构造磁盘块链表，每个文件都是磁盘块的链接列表，就像下面所示\u003c/span\u003e\u003c/p\u003e\u003cp id=\"9d34cfd049bd058c018f3fbe6541ec1d\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"4433a4082a45a23ee4f93af4c0102214\" class=\"ne-p\"\u003e\u003cimg src=\"https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830296-9199d50b-5e5b-43f4-a62b-dc0b1ef02d6d.png\" width=\"739\" id=\"UEy0O\" class=\"ne-image\"\u003e\u003c/p\u003e\u003cp id=\"7f14e16ff0324beb9815b3ee276388d4\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"308a2bb2be459b1d5455d81efb421ceb\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e 以磁盘块的链表形式存储文件\u003c/span\u003e\u003c/p\u003e\u003cp id=\"dc594ff5bca4f75526a34525758f6cf8\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"60e8ab8b1ba0ea6828d0b8e832d4aabf\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e每个块的第一个字作为指向下一块的指针，块的其他部分存放数据。如果上面这张图你看的不是很清楚的话，可以看看整个的链表分配方案\u003c/span\u003e\u003c/p\u003e\u003cp id=\"f2cd47fbd794262b99b108f78818a186\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"6d43d1117b2ffa2b376514a9bdfbb5c3\" class=\"ne-p\"\u003e\u003cimg src=\"https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830272-99171e3f-0aae-4fa7-b127-e43f64daed7d.png\" width=\"717\" id=\"MV6v4\" class=\"ne-image\"\u003e\u003c/p\u003e\u003cp id=\"a211e6d69c7bbfb39749b7bec6679328\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"1763c1572bf74bab8443b0251b0cab48\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e与连续分配方案不同，这一方法可以充分利用每个磁盘块。除了最后一个磁盘块外，不会因为磁盘碎片而浪费存储空间。同样，在目录项中，只要存储了第一个文件块，那么其他文件块也能够被找到。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"f61320e6d20a47449e2034136f13b99e\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"7c4e5c49d0f6e1ea08c9347e50f2d9cc\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e另一方面，在链表的分配方案中，尽管顺序读取非常方便，但是随机访问却很困难（这也是数组和链表数据结构的一大区别）。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"4dfa5bc9fab85a3f79ba645a4de63d55\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"ff5cd3412028401a7eb6f6907edfe384\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e还有一个问题是，由于指针会占用一些字节，每个磁盘块实际存储数据的字节数并不再是 2 的整数次幂。虽然这个问题并不会很严重，但是这种方式降低了程序运行效率。许多程序都是以长度为 2 的整数次幂来读写磁盘，由于每个块的前几个字节被指针所使用，所以要读出一个完成的块大小信息，就需要当前块的信息和下一块的信息拼凑而成，因此就引发了查找和拼接的开销。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"5c501728e8545b3abf2ebd585e59e40a\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003ch4 id=\"e7754cf3\"\u003e\u003cspan class=\"ne-text\"\u003e使用内存表进行链表分配\u003c/span\u003e\u003c/h4\u003e\u003cp id=\"f55bd6034ba134163728e11d790728db\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"fa31a2161c19438020b78c4e5edcff77\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e由于连续分配和链表分配都有其不可忽视的缺点。所以提出了使用内存中的表来解决分配问题。取出每个磁盘块的指针字，把它们放在内存的一个表中，就可以解决上述链表的两个不足之处。下面是一个例子\u003c/span\u003e\u003c/p\u003e\u003cp id=\"c62141cbec45e806125f66c6443b2cae\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"5294fd0f6ea2c7bd340fe04e8f683dfe\" class=\"ne-p\"\u003e\u003cimg src=\"https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830309-8180ae56-d298-4224-a60b-d472bd7dff53.png\" width=\"499\" id=\"qB40I\" class=\"ne-image\"\u003e\u003c/p\u003e\u003cp id=\"8a73dddf92c308f55531792c78bc4c17\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"3231eff73ea3778fa27bf38cee3b7593\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e上图表示了链表形成的磁盘块的内容。这两个图中都有两个文件，文件 A 依次使用了磁盘块地址 \u003c/span\u003e\u003cstrong\u003e\u003cspan class=\"ne-text\"\u003e4、7、 2、 10、 12\u003c/span\u003e\u003c/strong\u003e\u003cspan class=\"ne-text\"\u003e，文件 B 使用了\u003c/span\u003e\u003cstrong\u003e\u003cspan class=\"ne-text\"\u003e6、3、11 和 14\u003c/span\u003e\u003c/strong\u003e\u003cspan class=\"ne-text\"\u003e。也就是说，文件 A 从地址 4 处开始，顺着链表走就能找到文件 A 的全部磁盘块。同样，从第 6 块开始，顺着链走到最后，也能够找到文件 B 的全部磁盘块。你会发现，这两个链表都以不属于有效磁盘编号的特殊标记（-1）结束。内存中的这种表格称为 \u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e文件分配表(File Application Table,FAT)\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"679e35092915fc206d463659b3246031\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003ch3 id=\"507a4c82\"\u003e\u003cspan class=\"ne-text\"\u003e目录的实现\u003c/span\u003e\u003c/h3\u003e\u003cp id=\"229b6f0552c8dcf4c69d5168f63a9eeb\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"8db380cc3bd619deb9e5ee87c2dcc678\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e文件只有打开后才能够被读取。在文件打开后，操作系统会使用用户提供的路径名来定位磁盘中的目录。目录项提供了查找文件磁盘块所需要的信息。根据系统的不同，提供的信息也不同，可能提供的信息是整个文件的磁盘地址，或者是第一个块的数量（两个链表方案）或 inode的数量。不过不管用那种情况，目录系统的主要功能就是 \u003c/span\u003e\u003cstrong\u003e\u003cspan class=\"ne-text\"\u003e将文件的 ASCII 码的名称映射到定位数据所需的信息上\u003c/span\u003e\u003c/strong\u003e\u003cspan class=\"ne-text\"\u003e。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"c245ee3f18a5371b2e919276ff42e4d6\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003ch3 id=\"7378a354\"\u003e\u003cspan class=\"ne-text\"\u003e共享文件\u003c/span\u003e\u003c/h3\u003e\u003cp id=\"0d90e5167a61cad90103ab57542ccd79\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"a010daa0deac86c6117411cf1b76ee1c\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e当多个用户在同一个项目中工作时，他们通常需要共享文件。如果这个共享文件同时出现在多个用户目录下，那么他们协同工作起来就很方便。下面的这张图我们在上面提到过，但是有一个更改的地方，就是 \u003c/span\u003e\u003cstrong\u003e\u003cspan class=\"ne-text\"\u003eC 的一个文件也出现在了 B 的目录下\u003c/span\u003e\u003c/strong\u003e\u003cspan class=\"ne-text\"\u003e。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"4ea8ea0f7dce1ab59600bb31b7fde121\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"3f9712fc94bd87bc5bce05ab31700a90\" class=\"ne-p\"\u003e\u003cimg src=\"https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830321-b6391c5b-3b64-4089-9c4e-9a9afd09875c.png\" width=\"743\" id=\"wJKZ9\" class=\"ne-image\"\u003e\u003c/p\u003e\u003cp id=\"1516e5428216ce2d70a3848a9e18d8b7\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"84f511f5e2da2d65639ae5e4c5f08116\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e如果按照如上图的这种组织方式而言，那么 B 的目录与该共享文件的联系称为 \u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e链接(link)\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e。那么文件系统现在就是一个 \u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e有向无环图(Directed Acyclic Graph, 简称 DAG)\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e，而不是一棵树了。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"dedd40e6c19976b91159210337187cb3\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003ch3 id=\"062d38ab\"\u003e\u003cspan class=\"ne-text\"\u003e日志结构文件系统\u003c/span\u003e\u003c/h3\u003e\u003cp id=\"7d7ce6ffa46d0b80b05b4fa7cf88eb72\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"0c348de3e61e1b6861d79e122967c6a9\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e技术的改变会给当前的文件系统带来压力。这种情况下，CPU 会变得越来越快，磁盘会变得越来越大并且越来越便宜（但不会越来越快）。内存容量也是以指数级增长。但是磁盘的寻道时间（除了固态盘，因为固态盘没有寻道时间）并没有获得提高。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"615e318cbe6ce685b317cedee5ce3166\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"dc3ac711f3172e557139794ff56c713e\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e为此，\u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003eBerkeley\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e 设计了一种全新的文件系统，试图缓解这个问题，这个文件系统就是 \u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e日志结构文件系统(Log-structured File System, LFS)\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e。旨在解决以下问题。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"0c98bd5354523a99fdbae6022075672f\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cul class=\"ne-ul\"\u003e\u003cli id=\"155a7907a5e3bdd0310a98218fdc334b\"\u003e\u003cspan class=\"ne-text\"\u003e不断增长的系统内存\u003c/span\u003e\u003c/li\u003e\u003cli id=\"3b38564d520640464c2205c9486261b4\"\u003e\u003cspan class=\"ne-text\"\u003e顺序 I/O 性能胜过随机 I/O 性能\u003c/span\u003e\u003c/li\u003e\u003c/ul\u003e\u003cul class=\"ne-ul\"\u003e\u003cli id=\"32b086adb43b911b202b70e5aff36de8\"\u003e\u003cspan class=\"ne-text\"\u003e现有低效率的文件系统\u003c/span\u003e\u003c/li\u003e\u003cli id=\"f7a37a133cbda2e36cf91ffdbee4d115\"\u003e\u003cspan class=\"ne-text\"\u003e文件系统不支持 RAID（虚拟化）\u003c/span\u003e\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"cf17037d9f08713ca3eeb4ace7b47ca8\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"297fb6753d11f490d126e727b7c09c48\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e另一方面，当时的文件系统不论是 UNIX 还是 FFS，都有大量的随机读写（在 FFS 中创建一个新文件至少需要5次随机写），因此成为整个系统的性能瓶颈。同时因为 \u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003ePage cache\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e 的存在，作者认为随机读不是主要问题：随着越来越大的内存，大部分的读操作都能被 cache，因此 LFS 主要要解决的是减少对硬盘的随机写操作。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"1bad16ccaa3347ac4cfab1786828e972\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"d005e77189b514affc9db35092a8db48\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e在这种设计中，inode 甚至具有与 UNIX 中相同的结构，但是现在它们分散在整个日志中，而不是位于磁盘上的固定位置。所以，inode 很定位。为了能够找到 inode ，维护了一个由 inode 索引的 \u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003einode map(inode 映射)\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e。表项 i 指向磁盘中的第 i 个 inode 。这个映射保存在磁盘中，但是也保存在缓存中，因此，使用最频繁的部分大部分时间都在内存中。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"a624918a0a3ce7dd4dc1ac14978eae8c\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"268c06eaa913f22f2d46aba8d7868764\" class=\"ne-p\"\u003e\u003cimg src=\"https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830360-ead8d1cc-da6e-40bc-896b-4350498bf5c8.png\" width=\"732\" id=\"qxML0\" class=\"ne-image\"\u003e\u003c/p\u003e\u003cp id=\"135f1d10729c89da15b349f4f1a6f674\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"d3439b4c32b9a597fdf5c3f4980e183c\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e到目前为止，所有写入最初都缓存在\u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e内存\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e中，并且追加在\u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e日志末尾\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e，所有缓存的写入都定期在单个段中写入磁盘。所以，现在打开文件也就意味着用映射定位文件的索引节点。一旦 inode 被定位后，磁盘块的地址就能够被找到。所有这些块本身都将位于日志中某处的分段中。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"4deeb5cc8765dcdcffc2051d29dd889c\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"1da2cd86f605c95cfd9b33b6424b03a8\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e真实情况下的磁盘容量是有限的，所以最终日志会占满整个磁盘空间，这种情况下就会出现没有新的磁盘块被写入到日志中。幸运的是，许多现有段可能具有不再需要的块。例如，如果一个文件被覆盖了，那么它的 inode 将被指向新的块，但是旧的磁盘块仍在先前写入的段中占据着空间。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"f7cc586edf59e28b51595cb2d99969e4\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"b252ea9c8d9887d0749eca891ee9370a\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e为了处理这个问题，LFS 有一个\u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e清理(clean)\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e线程，它会循环扫描日志并对日志进行压缩。首先，通过查看日志中第一部分的信息来查看其中存在哪些索引节点和文件。它会检查当前 inode 的映射来查看 inode 否在在当前块中，是否仍在被使用。如果不是，该信息将被丢弃。如果仍然在使用，那么 inode 和块就会进入内存等待写回到下一个段中。然后原来的段被标记为空闲，以便日志可以用来存放新的数据。用这种方法，清理线程遍历日志，从后面移走旧的段，然后将有效的数据放入内存等待写到下一个段中。由此一来整个磁盘会形成一个大的\u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e环形缓冲区\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e，写线程将新的段写在前面，而清理线程则清理后面的段。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"d882117f7dd0d9016cd4efa5d88f836b\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"4cb4c6428aac735024f7bd8e7b3df742\" class=\"ne-p\"\u003e\u003cimg src=\"https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830348-81e32c04-1184-4cdb-8403-2efeeb68787c.png\" width=\"631\" id=\"A4Ev0\" class=\"ne-image\"\u003e\u003c/p\u003e\u003cp id=\"254c2fb97c081e7566ee59c417621dc6\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003ch3 id=\"97a9825e\"\u003e\u003cspan class=\"ne-text\"\u003e日志文件系统\u003c/span\u003e\u003c/h3\u003e\u003cp id=\"54c993a6b70774346a7e6a74670bd65d\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"15ef008aa02d98f6108fd2b0045ad8ce\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e虽然日志结构系统的设计很优雅，但是由于它们和现有的文件系统不相匹配，因此还没有广泛使用。不过，从日志文件结构系统衍生出来一种新的日志系统，叫做\u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e日志文件系统\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e，它会记录系统下一步将要做什么的日志。微软的 \u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003eNTFS\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e 文件系统、Linux 的 \u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003eext3\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e 就使用了此日志。 \u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003eOS X\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e 将日志系统作为可供选项。为了看清它是如何工作的，我们下面讨论一个例子，比如 \u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e移除文件\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e ，这个操作在 UNIX 中需要三个步骤完成：\u003c/span\u003e\u003c/p\u003e\u003cp id=\"542c202aaf8ebf265f4cb616c83eb215\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cul class=\"ne-ul\"\u003e\u003cli id=\"67d6fbc0f368e73ec0ae0cd1ae302ca0\"\u003e\u003cspan class=\"ne-text\"\u003e在目录中删除文件\u003c/span\u003e\u003c/li\u003e\u003cli id=\"a89a87cfde0f907da93ba98949232c61\"\u003e\u003cspan class=\"ne-text\"\u003e释放 inode 到空闲 inode 池\u003c/span\u003e\u003c/li\u003e\u003c/ul\u003e\u003cul class=\"ne-ul\"\u003e\u003cli id=\"9d7a41e6c40debc886ece1919154c122\"\u003e\u003cspan class=\"ne-text\"\u003e将所有磁盘块归还给空闲磁盘池。\u003c/span\u003e\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"0373ab5b606fbc4ea64ceb3e16560a81\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003ch3 id=\"85c5a550\"\u003e\u003cspan class=\"ne-text\"\u003e虚拟文件系统\u003c/span\u003e\u003c/h3\u003e\u003cp id=\"290a38b2c6595805459b83e5d9efd348\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"fa0fd762b6f480ec670bc0caaa659d75\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003eUNIX 操作系统使用一种 \u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e虚拟文件系统(Virtual File System, VFS)\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e 来尝试将多种文件系统构成一个有序的结构。关键的思想是抽象出所有文件系统都共有的部分，并将这部分代码放在一层，这一层再调用具体文件系统来管理数据。下面是一个 VFS 的系统结构\u003c/span\u003e\u003c/p\u003e\u003cp id=\"adaba32ebb0cc75090b68328c3028b7b\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"a3c0af3bdad2c2390baf7ba0b99cc521\" class=\"ne-p\"\u003e\u003cimg src=\"https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830356-635b72b4-bcf2-434f-9719-c83b191da6cf.png\" width=\"675\" id=\"zWieH\" class=\"ne-image\"\u003e\u003c/p\u003e\u003cp id=\"d59ed70f4605a2d10f29fbf5243a3add\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"db2b2f4f03009dfb83d4c4702f1c8bce\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e还是那句经典的话，在计算机世界中，任何解决不了的问题都可以加个\u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e代理\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e来解决。所有和文件相关的系统调用在最初的处理上都指向虚拟文件系统。这些来自用户进程的调用，都是标准的 \u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003ePOSIX 系统调用\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e，比如 open、read、write 和 seek 等。VFS 对用户进程有一个 \u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e上层\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e 接口，这个接口就是著名的 POSIX 接口。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"b00daf97b264c2c2bbe03d1961ade40f\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003ch2 id=\"9bc5cc8b\"\u003e\u003cspan class=\"ne-text\"\u003e文件系统的管理和优化\u003c/span\u003e\u003c/h2\u003e\u003cp id=\"e52554121a51cb24a7d18cea51ff1273\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"a457d363aece63ffafdc7a21b8ea5bda\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e能够使文件系统工作是一回事，能够使文件系统高效、稳定的工作是另一回事，下面我们就来探讨一下文件系统的管理和优化。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"7427320717087557ca6baac5f2f4e9e6\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003ch3 id=\"36f7581f\"\u003e\u003cspan class=\"ne-text\"\u003e磁盘空间管理\u003c/span\u003e\u003c/h3\u003e\u003cp id=\"2ddbfc7d676fa2fb7e22874efb2691cf\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"72ecbbb431e26da743b3582748db5218\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e文件通常存在磁盘中，所以如何管理磁盘空间是一个操作系统的设计者需要考虑的问题。在文件上进行存有两种策略：\u003c/span\u003e\u003cstrong\u003e\u003cspan class=\"ne-text\"\u003e分配 n 个字节的连续磁盘空间；或者把文件拆分成多个并不一定连续的块\u003c/span\u003e\u003c/strong\u003e\u003cspan class=\"ne-text\"\u003e。在存储管理系统中，主要有\u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e分段管理\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e和 \u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e分页管理\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e 两种方式。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"dd7036c30b5429f0012e299634b76e92\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"67ddc9963643581de7e3a7a9dc7fc649\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e正如我们所看到的，按\u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e连续字节序列\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e存储文件有一个明显的问题，当文件扩大时，有可能需要在磁盘上移动文件。内存中分段也有同样的问题。不同的是，相对于把文件从磁盘的一个位置移动到另一个位置，内存中段的移动操作要快很多。因此，几乎所有的文件系统都把文件分割成固定大小的块来存储。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"344a106798ca8fae42c7928b5ec1fc77\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003ch4 id=\"e30f1fa9\"\u003e\u003cspan class=\"ne-text\"\u003e块大小\u003c/span\u003e\u003c/h4\u003e\u003cp id=\"38509e646d595c8ff6d9a8436e3eedaf\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"547a3489e12fa9b51d40fb6441101da0\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e一旦把文件分为固定大小的块来存储，就会出现问题，块的大小是多少？按照\u003c/span\u003e\u003cstrong\u003e\u003cspan class=\"ne-text\"\u003e磁盘组织方式，扇区、磁道和柱面显然都可以作为分配单位\u003c/span\u003e\u003c/strong\u003e\u003cspan class=\"ne-text\"\u003e。在分页系统中，分页大小也是主要因素。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"eef07e9a93ba53842388a4f3930178df\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"db7ed5c40d46b10feac962743c5d08dc\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e拥有大的块尺寸意味着每个文件，甚至 1 字节文件，都要占用一个柱面空间，也就是说小文件浪费了大量的磁盘空间。另一方面，小块意味着大部分文件将会跨越多个块，因此需要多次搜索和旋转延迟才能读取它们，从而降低了性能。因此，如果分配的块\u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e太大\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e会浪费\u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e空间\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e；分配的块\u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e太小\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e会浪费\u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e时间\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"c2835cdef3fed7ded33775fbb7ca6297\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003ch4 id=\"295e0480\"\u003e\u003cspan class=\"ne-text\"\u003e记录空闲块\u003c/span\u003e\u003c/h4\u003e\u003cp id=\"edd1908809f46d895dc025e523270a52\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"dd215e9d3aec5bd07fefcbb6ef543dc8\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e一旦指定了块大小，下一个问题就是怎样跟踪空闲块。有两种方法被广泛采用，如下图所示\u003c/span\u003e\u003c/p\u003e\u003cp id=\"47accf180646908f7be85a16c3d72875\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"96bc7041bf4c1a86d46bb5c63cefd992\" class=\"ne-p\"\u003e\u003cimg src=\"https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830365-86ca166a-5dd1-4e96-b9b4-2966e2d87565.png\" width=\"753\" id=\"CTgLy\" class=\"ne-image\"\u003e\u003c/p\u003e\u003cp id=\"2051479c114a6b22e965758e8797badf\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"ca2834028031ca00495c9ea1276d53aa\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e第一种方法是采用\u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e磁盘块链表\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e，链表的每个块中包含极可能多的空闲磁盘块号。对于 1 KB 的块和 32 位的磁盘块号，空闲表中每个块包含有 255 个空闲的块号。考虑 1 TB 的硬盘，拥有大概十亿个磁盘块。为了存储全部地址块号，如果每块可以保存 255 个块号，则需要将近 400 万个块。通常，空闲块用于保存空闲列表，因此存储基本上是空闲的。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"5f10f38fe901cd0eb895dbc49f3e37f0\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"56b4758c79b155d6ba6436edeba4ba04\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e另一种空闲空间管理的技术是\u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e位图(bitmap)\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e，n 个块的磁盘需要 n 位位图。在位图中，空闲块用 1 表示，已分配的块用 0 表示。对于 1 TB 硬盘的例子，需要 10 亿位表示，即需要大约 130 000 个 1 KB 块存储。很明显，和 32 位链表模型相比，位图需要的空间更少，因为每个块使用 1 位。只有当磁盘快满的时候，链表需要的块才会比位图少。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"7e0bf942bbab56b06289c8725066eb20\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003ch3 id=\"4facddb8\"\u003e\u003cspan class=\"ne-text\"\u003e磁盘配额\u003c/span\u003e\u003c/h3\u003e\u003cp id=\"032a35f5bc36753dde6f1497ca87082d\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"215d7a97d62c80293c9847906f762497\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e为了防止一些用户占用太多的磁盘空间，多用户操作通常提供一种\u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e磁盘配额(enforcing disk quotas)\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e的机制。系统管理员为每个用户分配\u003c/span\u003e\u003cstrong\u003e\u003cspan class=\"ne-text\"\u003e最大的文件和块分配\u003c/span\u003e\u003c/strong\u003e\u003cspan class=\"ne-text\"\u003e，并且操作系统确保用户不会超过其配额。我们下面会谈到这一机制。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"2ee4b6ff9b5bf884af9208e43d278aa6\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"c20140937b0c58800dec7ed9cd67e95b\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e在用户打开一个文件时，操作系统会找到\u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e文件属性\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e和\u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e磁盘地址\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e，并把它们送入内存中的打开文件表。其中一个属性告诉\u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e文件所有者\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e是谁。任何有关文件的增加都会记到所有者的配额中。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"b1cacad06963157173172584f9db8096\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"3c665c8af9fb07bcf153caa4b682fe95\" class=\"ne-p\"\u003e\u003cimg src=\"https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830397-dc14e657-f7ce-4c0e-a2fc-dae37cdce37e.png\" width=\"681\" id=\"Oo3ow\" class=\"ne-image\"\u003e\u003c/p\u003e\u003cp id=\"c7a9e9f8b0a5997c4e2a3e6dbc31775a\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"43b46d497e9c436b2f556aa5c66e2c43\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e 配额表中记录了每个用户的配额\u003c/span\u003e\u003c/p\u003e\u003cp id=\"0f9f915845b742eeb1c89f50a592a657\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"c5a0b6749f84d9c09a768bf537638a09\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e第二张表包含了每个用户当前打开文件的配额记录，即使是其他人打开该文件也一样。如上图所示，该表的内容是从被打开文件的所有者的磁盘配额文件中提取出来的。当所有文件关闭时，该记录被写回配额文件。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"1ee6d826e9a005489809f6cdbc1f74fd\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"9e3b6aa356a538a1f623df8fbfee0caf\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e当在打开文件表中建立一新表项时，会产生一个指向所有者配额记录的指针。每次向文件中添加一个块时，文件所有者所用数据块的总数也随之增加，并会同时增加\u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e硬限制\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e和\u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e软限制\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e的检查。可以超出软限制，但硬限制不可以超出。当已达到硬限制时，再往文件中添加内容将引发错误。同样，对文件数目也存在类似的检查。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"9dfa42d3b8bda31015aff60e6402447b\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003ch3 id=\"448f0b53\"\u003e\u003cspan class=\"ne-text\"\u003e文件系统备份\u003c/span\u003e\u003c/h3\u003e\u003cp id=\"ffdfb3c549d5e57f21be4e05a1a2db62\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"113ba2fa14d2438cead2475b7b39a27e\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e做文件备份很耗费时间而且也很浪费空间，这会引起下面几个问题。首先，是要\u003c/span\u003e\u003cstrong\u003e\u003cspan class=\"ne-text\"\u003e备份整个文件还是仅备份一部分呢\u003c/span\u003e\u003c/strong\u003e\u003cspan class=\"ne-text\"\u003e？一般来说，只是备份特定目录及其下的全部文件，而不是备份整个文件系统。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"46fadd39621ab910d498dbceb75c70a5\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"aa6bac235f93e3c65c678e094392adca\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e其次，对上次未修改过的文件再进行备份是一种浪费，因而产生了一种\u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e增量转储(incremental dumps)\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e 的思想。最简单的增量转储的形式就是\u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e周期性\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e的做全面的备份，而每天只对增量转储完成后发生变化的文件做单个备份。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"bd26f462660acfa584c45424f992c0d3\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"d7a48a9530c54662113424a7892a7643\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e稍微好一点的方式是只备份最近一次转储以来更改过的文件。当然，这种做法极大的缩减了转储时间，但恢复起来却更复杂，因为\u003c/span\u003e\u003cstrong\u003e\u003cspan class=\"ne-text\"\u003e最近的全面转储先要全部恢复，随后按逆序进行增量转储\u003c/span\u003e\u003c/strong\u003e\u003cspan class=\"ne-text\"\u003e。为了方便恢复，人们往往使用更复杂的转储模式。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"51edae20809214a4ee16554d2b0d6c6e\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"fc00c1f85af8e54127292c60f1ce58f2\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e第三，既然待转储的往往是海量数据，那么在将其写入磁带之前对文件进行压缩就很有必要。但是，如果在备份过程中出现了文件损坏的情况，就会导致破坏压缩算法，从而使整个磁带无法读取。所以在备份前是否进行文件压缩需慎重考虑。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"48064cf8ac09f37c3e9fb90da4bd86f6\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"eae33460e594d4ace436ad41cdee09bb\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e第四，对正在使用的文件系统做备份是很难的。如果在转储过程中要添加，删除和修改文件和目录，则转储结果可能不一致。因此，因为转储过程中需要花费数个小时的时间，所以有必要在晚上将系统脱机进行备份，然而这种方式的接受程度并不高。所以，人们修改了转储算法，记下文件系统的\u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e瞬时快照\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e，即复制关键的数据结构，然后需要把将来对文件和目录所做的修改复制到块中，而不是到处更新他们。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"30c5145da5c3daf19f6a6c121ac3cd34\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"b0fcc685273d71a66e54ea23168256e7\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e磁盘转储到备份磁盘上有两种方案：\u003c/span\u003e\u003cstrong\u003e\u003cspan class=\"ne-text\"\u003e物理转储和逻辑转储\u003c/span\u003e\u003c/strong\u003e\u003cspan class=\"ne-text\"\u003e。\u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e物理转储(physical dump)\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e 是从磁盘的 0 块开始，依次将所有磁盘块按照顺序写入到输出磁盘，并在复制最后一个磁盘时停止。这种程序的万无一失性是其他程序所不具备的。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"16f52d5c94af08b8399b7f00fde02baf\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"a4280007245d6cde87091ae5723b514f\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e第二个需要考虑的是\u003c/span\u003e\u003cstrong\u003e\u003cspan class=\"ne-text\"\u003e坏块的转储\u003c/span\u003e\u003c/strong\u003e\u003cspan class=\"ne-text\"\u003e。制造大型磁盘而没有瑕疵是不可能的，所以也会存在一些\u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e坏块(bad blocks)\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e。有时进行低级格式化后，坏块会被检测出来并进行标记，这种情况的解决办法是用磁盘末尾的一些空闲块所替换。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"d3a520d2dc75e3c048f1f7be7a3b1521\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"9e3a9f3c7ea68c671fba5541ec778315\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e然而，一些块在格式化后会变坏，在这种情况下操作系统可以检测到它们。通常情况下，它可以通过创建一个由所有坏块组成的\u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e文件\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e来解决问题，确保它们不会出现在空闲池中并且永远不会被分配。\u003c/span\u003e\u003cstrong\u003e\u003cspan class=\"ne-text\"\u003e那么此文件是完全不可读的\u003c/span\u003e\u003c/strong\u003e\u003cspan class=\"ne-text\"\u003e。如果磁盘控制器将所有的坏块重新映射，物理转储还是能够正常工作的。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"079669c0c544c835fd273273a33afdd7\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"f5aa458d6a0327dcf235ab0f937d1e5b\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003eWindows 系统有\u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e分页文件(paging files)\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e 和 \u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e休眠文件(hibernation files)\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e 。它们在文件还原时不发挥作用，同时也不应该在第一时间进行备份。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"7cec7ef194f71a4845069c7b2467ba86\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003ch3 id=\"7bf7e71c\"\u003e\u003cspan class=\"ne-text\"\u003e文件系统的一致性\u003c/span\u003e\u003c/h3\u003e\u003cp id=\"82c29f8de3c1d8f9d3e3a242854aea5a\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"95f468ed0b314583e7bb1b5d96463a0d\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e影响可靠性的一个因素是文件系统的一致性。许多文件系统读取磁盘块、修改磁盘块、再把它们写回磁盘。如果系统在所有块写入之前崩溃，文件系统就会处于一种\u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e不一致(inconsistent)\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e的状态。如果某些尚未写回的块是索引节点块，目录块或包含空闲列表的块，则此问题是很严重的。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"aa1b70a4eed4630530233add037539f3\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"964d4c4e15c95803c23efa7ae10be9e2\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e为了处理文件系统一致性问题，大部分计算机都会有应用程序来检查文件系统的一致性。例如，UNIX 有 \u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003efsck\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e；Windows 有 \u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003esfc\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e，每当引导系统时（尤其是在崩溃后），都可以运行该程序。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"48ab85b18d500f6f09aae6694c153193\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"f69a8abc58586e91d81d5e78464cf3d0\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e可以进行两种一致性检查：\u003c/span\u003e\u003cstrong\u003e\u003cspan class=\"ne-text\"\u003e块的一致性检查和文件的一致性检查\u003c/span\u003e\u003c/strong\u003e\u003cspan class=\"ne-text\"\u003e。为了检查块的一致性，应用程序会建立两张表，每个包含一个计数器的块，最初设置为 0 。第一个表中的计数器跟踪该块在文件中出现的次数，第二张表中的计数器记录每个块在空闲列表、空闲位图中出现的频率。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"6aef6c93e388526281d0ccfabc109e56\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003ch3 id=\"1813df07\"\u003e\u003cspan class=\"ne-text\"\u003e文件系统性能\u003c/span\u003e\u003c/h3\u003e\u003cp id=\"d3fb5bbd9e1d7c87c8abc3f98dad08fa\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"1b317a6725a77f944c82f795f51802c4\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e访问磁盘的效率要比内存满的多，是时候又祭出这张图了\u003c/span\u003e\u003c/p\u003e\u003cp id=\"e65e5e0ed7603e2c50058d08807f17fe\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"1a1e743c356c1915686f30c85dd8837e\" class=\"ne-p\"\u003e\u003cimg src=\"https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830422-af95403a-f195-4d9e-8125-0d05ec7651ff.png\" width=\"711\" id=\"oMNVY\" class=\"ne-image\"\u003e\u003c/p\u003e\u003cp id=\"b50a79ed6fb74211ac37fdda653d5b8f\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"859c470037440cdd28efa0d26f3ef0a6\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e从内存读一个 32 位字大概是 10ns，从硬盘上读的速率大概是 100MB/S，对每个 32 位字来说，效率会慢了四倍，另外，还要加上 5 - 10 ms 的寻道时间等其他损耗，如果只访问一个字，内存要比磁盘快百万数量级。所以磁盘优化是很有必要的，下面我们会讨论几种优化方式\u003c/span\u003e\u003c/p\u003e\u003cp id=\"f08d65d53f1351340cdb0ecf65f4e735\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003ch4 id=\"cdde49bb\"\u003e\u003cspan class=\"ne-text\"\u003e高速缓存\u003c/span\u003e\u003c/h4\u003e\u003cp id=\"a88faf1cb721a77ececf2015cf53efa9\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"7c675dc314d14c2ae799ed6640c9d2e9\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e最常用的减少磁盘访问次数的技术是使用 \u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e块高速缓存(block cache)\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e 或者 \u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e缓冲区高速缓存(buffer cache)\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e。高速缓存指的是一系列的块，它们在逻辑上属于磁盘，但实际上基于性能的考虑被保存在内存中。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"b17a6714b13a17563901344d07462477\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"dc154ad0b420fd4f3673118cc516d2e6\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e管理高速缓存有不同的算法，常用的算法是：检查全部的读请求，查看在高速缓存中是否有所需要的块。如果存在，可执行读操作而无须访问磁盘。如果检查块不再高速缓存中，那么首先把它读入高速缓存，再复制到所需的地方。之后，对同一个块的请求都通过\u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e高速缓存\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e来完成。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"c25b8162bb8c3e4f67a87ba9bac5a070\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"6c386979476c9d66e19b2d612c66328f\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e高速缓存的操作如下图所示\u003c/span\u003e\u003c/p\u003e\u003cp id=\"3d3a4d92696219f66d8742c69e570752\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"24044650b0ba67c609c1fd504c6288be\" class=\"ne-p\"\u003e\u003cimg src=\"https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830486-9b7cd7d5-cd58-485e-8fb9-7c5f918fb69a.png\" width=\"733\" id=\"w4gdw\" class=\"ne-image\"\u003e\u003c/p\u003e\u003cp id=\"e9c3294259bbd6241a38558088b3ebd6\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"6eca2ec60272b982b11ff45c7220cf1c\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e由于在高速缓存中有许多块，所以需要某种方法快速确定所需的块是否存在。常用方法是将设备和磁盘地址进行散列操作，然后，在散列表中查找结果。具有相同散列值的块在一个链表中连接在一起（这个数据结构是不是很像 HashMap?），这样就可以沿着冲突链查找其他块。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"d484a308c97ec7ef8cadad561dd451b0\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"de071a26c813ef0d71da3b2b2adce651\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e如果高速缓存\u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e已满\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e，此时需要调入新的块，则要把原来的某一块调出高速缓存，如果要调出的块在上次调入后已经被修改过，则需要把它写回磁盘。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"d2cb85bba04c34338b74daba699247a5\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003ch4 id=\"66d87443\"\u003e\u003cspan class=\"ne-text\"\u003e块提前读\u003c/span\u003e\u003c/h4\u003e\u003cp id=\"30c57914a283b1c14a9a70972a449fdc\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"deeccda0a50582f53cf9c6007fc28d76\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e第二个明显提高文件系统的性能是，在需要用到块之前，试图\u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e提前\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e将其写入高速缓存，从而\u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e提高命中率\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e。许多文件都是顺序读取。如果请求文件系统在某个文件中生成块 k，文件系统执行相关操作并且在完成之后，会检查高速缓存，以便确定块 k + 1 是否已经在高速缓存。如果不在，文件系统会为 k + 1 安排一个预读取，因为文件希望在用到该块的时候能够直接从高速缓存中读取。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"8a69c495fe7bb783b79dbf75485864bc\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"808c596082fdff6eaae697cd580903a8\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e当然，块提前读取策略只适用于实际顺序读取的文件。对随机访问的文件，提前读丝毫不起作用。甚至还会造成阻碍。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"5b78528d1ba45c2104816c3e8e709aff\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003ch4 id=\"aa9dd989\"\u003e\u003cspan class=\"ne-text\"\u003e减少磁盘臂运动\u003c/span\u003e\u003c/h4\u003e\u003cp id=\"d09f4491931761a8ce0444d664eebb7a\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"fb7b8c5c382a9dee9c90ffe1a4934f58\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e高速缓存和块提前读并不是提高文件系统性能的唯一方法。另一种重要的技术是\u003c/span\u003e\u003cstrong\u003e\u003cspan class=\"ne-text\"\u003e把有可能顺序访问的块放在一起，当然最好是在同一个柱面上，从而减少磁盘臂的移动次数\u003c/span\u003e\u003c/strong\u003e\u003cspan class=\"ne-text\"\u003e。当写一个输出文件时，文件系统就必须按照要求一次一次地分配磁盘块。如果用位图来记录空闲块，并且整个位图在内存中，那么选择与前一块最近的空闲块是很容易的。如果用空闲表，并且链表的一部分存在磁盘上，要分配紧邻的空闲块就会困难很多。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"fb9ea860feeaa3264df8728b7749755f\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003ch4 id=\"67e3ff13\"\u003e\u003cspan class=\"ne-text\"\u003e磁盘碎片整理\u003c/span\u003e\u003c/h4\u003e\u003cp id=\"ba79cd85e1dad3bed9f2216b2b7253b1\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"41c56da85159758040baae19181247c8\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e在初始安装操作系统后，文件就会被不断的创建和清除，于是磁盘会产生很多的碎片，在创建一个文件时，它使用的块会散布在整个磁盘上，降低性能。删除文件后，回收磁盘块，可能会造成空穴。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"b1d265b54391b9395004a22d89f3381d\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"408e532833df6ecd00374e3714b691a6\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e磁盘性能可以通过如下方式恢复：移动文件使它们相互挨着，并把所有的至少是大部分的空闲空间放在一个或多个大的连续区域内。Windows 有一个程序 \u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003edefrag\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e 就是做这个事儿的。Windows 用户会经常使用它，SSD 除外。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"2b171a55d46f2e7b316bfa4dca7e1d30\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"0a13d2e5ecaea758dd489d8b3f708327\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e磁盘碎片整理程序会在让文件系统上很好地运行。Linux 文件系统（特别是 ext2 和 ext3）由于其选择磁盘块的方式，在磁盘碎片整理上一般不会像 Windows 一样困难，因此很少需要手动的磁盘碎片整理。而且，固态硬盘并不受磁盘碎片的影响，事实上，在固态硬盘上做磁盘碎片整理反倒是多此一举，不仅没有提高性能，反而磨损了固态硬盘。所以碎片整理只会缩短固态硬盘的寿命。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"e7ebcf76e9e7e212ad0bcdf32a78971d\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"89ca27714a847f6e1742fe7c23d34046\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e下面我们来探讨一下 I/O 流程问题。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"1cef0573f6ef4eb8042d81ad743c2c6e\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"55fa1a1e6692073f30600efec9761a8f\" class=\"ne-p\"\u003e\u003cimg src=\"https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830481-2693434c-6334-4f5a-a152-75454e91d275.png\" width=\"752\" id=\"Nh8lv\" class=\"ne-image\"\u003e\u003c/p\u003e\u003cp id=\"dab506072acfbe1a65ea20b5d8f20187\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003ch2 id=\"ccf866bd\"\u003e\u003cspan class=\"ne-text\"\u003eI/O 设备\u003c/span\u003e\u003c/h2\u003e\u003cp id=\"fef21a68cfbbf3d40c8c42db7160f3fc\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"a11a667a8e08d786f9df34bbf650bf3d\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e什么是 I/O 设备？I/O 设备又叫做输入/输出设备，它是人类用来和计算机进行通信的外部硬件。输入/输出设备能够向计算机\u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e发送数据（输出）\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e并从计算机\u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e接收数据（输入）\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"c552565b432c8f2328937d605d16b55f\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"36a413dde5afb50347686b041abb2194\" class=\"ne-p\"\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003eI/O 设备(I/O devices)\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e可以分成两种：\u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e块设备(block devices)\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e 和 \u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e字符设备(character devices)\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"041f671ef3cc121c9abd0eb87bea40ce\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003ch4 id=\"b0737d59\"\u003e\u003cspan class=\"ne-text\"\u003e块设备\u003c/span\u003e\u003c/h4\u003e\u003cp id=\"85b0d1db3e51529ae28eb21531dbabc9\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"6791ea347b3b675b23d8b71834de784d\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e块设备是一个能存储\u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e固定大小块\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e信息的设备，它支持\u003c/span\u003e\u003cstrong\u003e\u003cspan class=\"ne-text\"\u003e以固定大小的块，扇区或群集读取和（可选）写入数据\u003c/span\u003e\u003c/strong\u003e\u003cspan class=\"ne-text\"\u003e。每个块都有自己的\u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e物理地址\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e。通常块的大小在 512 - 65536 之间。所有传输的信息都会以\u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e连续\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e的块为单位。块设备的基本特征是每个块都较为对立，能够独立的进行读写。常见的块设备有 \u003c/span\u003e\u003cstrong\u003e\u003cspan class=\"ne-text\"\u003e硬盘、蓝光光盘、USB 盘\u003c/span\u003e\u003c/strong\u003e\u003c/p\u003e\u003cp id=\"b52171cdae8af1f376f27c40ad67ac26\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"cf77f280837dfa3d5315eadc8011a27d\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e与字符设备相比，块设备通常需要较少的引脚。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"7ecf223db6465ee23234ff197ee6a09c\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"7acf3702619a1520d671342f2aa55ce2\" class=\"ne-p\"\u003e\u003cimg src=\"https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830476-de4c28f8-7881-487b-9bc3-11bf81770f23.png\" width=\"700\" id=\"pm6J2\" class=\"ne-image\"\u003e\u003c/p\u003e\u003cp id=\"0e9ec415e4a41b3d94d858c66fadaad5\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003ch4 id=\"4946a116\"\u003e\u003cspan class=\"ne-text\"\u003e块设备的缺点\u003c/span\u003e\u003c/h4\u003e\u003cp id=\"f6b824a5b70558096a86b0e599ace532\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"7e18a2c7272bc8e4a6f3a6ab2944d1e1\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e基于给定固态存储器的块设备比基于相同类型的存储器的字节寻址要慢一些，因为必须在块的开头开始读取或写入。所以，要读取该块的任何部分，必须寻找到该块的开始，读取整个块，如果不使用该块，则将其丢弃。要写入块的一部分，必须寻找到块的开始，将整个块读入内存，修改数据，再次寻找到块的开头处，然后将整个块写回设备。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"b56f0082d6f7228e3d6e2ccca060af64\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003ch4 id=\"d4ea5237\"\u003e\u003cspan class=\"ne-text\"\u003e字符设备\u003c/span\u003e\u003c/h4\u003e\u003cp id=\"029c7023153fa023483fe82decdea68f\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"43cd71445d951e98def6564f4fb90e2f\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e另一类 I/O 设备是\u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e字符设备\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e。字符设备以\u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e字符\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e为单位发送或接收一个字符流，而不考虑任何块结构。字符设备是不可寻址的，也没有任何寻道操作。常见的字符设备有 \u003c/span\u003e\u003cstrong\u003e\u003cspan class=\"ne-text\"\u003e打印机、网络设备、鼠标、以及大多数与磁盘不同的设备\u003c/span\u003e\u003c/strong\u003e\u003cspan class=\"ne-text\"\u003e。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"28e05ffc9309d60a2e6a8be0504cb2b6\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"1613d0fe5c97aa26e6cc98547e4b3f5e\" class=\"ne-p\"\u003e\u003cimg src=\"https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830510-e704b09f-ae66-45ce-bde4-66fd175dc769.png\" width=\"703\" id=\"ZC93B\" class=\"ne-image\"\u003e\u003c/p\u003e\u003cp id=\"45829f5e3fd12814f44a925a42257add\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003ch3 id=\"9881f730\"\u003e\u003cspan class=\"ne-text\"\u003e设备控制器\u003c/span\u003e\u003c/h3\u003e\u003cp id=\"42cfb8373d43692de4cab682355d0267\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"01c9dcd39c0617edea3fe8743f8387e7\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e设备控制器是处理 CPU 传入和传出信号的系统。设备通过插头和插座连接到计算机，并且插座连接到设备控制器。设备控制器从连接的设备处接收数据，并将其存储在控制器内部的一些\u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e特殊目的寄存器(special purpose registers)\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e 也就是本地缓冲区中。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"e8d0510ece8b2837f0fe7c0812240fab\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"c5350ce1c360c31d9f02ded8ad634464\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e每个设备控制器都会有一个应用程序与之对应，设备控制器通过应用程序的接口通过中断与操作系统进行通信。设备控制器是硬件，而设备驱动程序是软件。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"ee7e18cfd23f391533dba522b7fb2d17\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003ch3 id=\"2b21e7c0\"\u003e\u003cspan class=\"ne-text\"\u003e内存映射 I/O\u003c/span\u003e\u003c/h3\u003e\u003cp id=\"478fcce32a2fb12395f5979c573146eb\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"de6bab2e6473dcb8f55d739b5d01be84\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e每个控制器都会有几个寄存器用来和 CPU 进行通信。通过写入这些寄存器，操作系统可以命令设备发送数据，接收数据、开启或者关闭设备等。通过从这些寄存器中读取信息，操作系统能够知道设备的状态，是否准备接受一个新命令等。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"49d135f8526a65aa9126b14668ee49ed\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"8c5d7f345d34f8b2c41baab490473318\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e为了控制\u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e寄存器\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e，许多设备都会有\u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e数据缓冲区(data buffer)\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e，来供系统进行读写。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"a5a4118b957e027328e237a6e1a992f3\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"b2afa8b116e5e0ca2d07bb3a17bd3fa2\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e那么问题来了，CPU 如何与设备寄存器和设备数据缓冲区进行通信呢？存在两个可选的方式。第一种方法是，每个控制寄存器都被分配一个 \u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003eI/O 端口(I/O port)\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e号，这是一个 8 位或 16 位的整数。所有 I/O 端口的集合形成了受保护的 I/O 端口空间，以便普通用户程序无法访问它（只有操作系统可以访问）。使用特殊的 I/O 指令像是\u003c/span\u003e\u003c/p\u003e\u003cp id=\"765a4ca508a5115b78ed2925e14838d8\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cpre data-language=\"assembly\" id=\"3877d554\" class=\"ne-codeblock language-assembly\"\u003eIN REG,PORT\u003c/pre\u003e\u003cp id=\"d488b29580542c9583338320551ab3c6\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"08ce542e0db8dcd660e9764cb17b670f\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003eCPU 可以读取控制寄存器 PORT 的内容并将结果放在 CPU 寄存器 REG 中。类似的，使用\u003c/span\u003e\u003c/p\u003e\u003cp id=\"862fabda27bff31f4481f0fbb1841f04\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cpre data-language=\"assembly\" id=\"41a56928\" class=\"ne-codeblock language-assembly\"\u003eOUT PORT,REG\u003c/pre\u003e\u003cp id=\"2af22811e69fd5e8ed8a16f28179a129\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"bded26b72586207ef1db5725a5279922\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003eCPU 可以将 REG 的内容写到控制寄存器中。大多数早期计算机，包括几乎所有大型主机，如 IBM 360 及其所有后续机型，都是以这种方式工作的。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"726bebd6ef6b472edc3181572bdfa656\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"473bae0048dd7032999f2251d5a662b7\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e第二个方法是 PDP-11 引入的，它将\u003c/span\u003e\u003cstrong\u003e\u003cspan class=\"ne-text\"\u003e所有控制寄存器映射到内存空间\u003c/span\u003e\u003c/strong\u003e\u003cspan class=\"ne-text\"\u003e中。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"55f1ecf17cdddd5693acbda0af158993\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003ch3 id=\"71380d9f\"\u003e\u003cspan class=\"ne-text\"\u003e直接内存访问\u003c/span\u003e\u003c/h3\u003e\u003cp id=\"1cec9d2a2b4a37680ebefd6565e21175\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"ce6e80a93dc12dcb9aa9d664ffadc5fa\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e无论一个 CPU 是否具有内存映射 I/O，它都需要寻址设备控制器以便与它们交换数据。CPU 可以从 I/O 控制器每次请求一个字节的数据，但是这么做会浪费 CPU 时间，所以经常会用到一种称为\u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e直接内存访问(Direct Memory Access)\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e 的方案。为了简化，我们假设 CPU 通过单一的系统总线访问所有的设备和内存，该总线连接 CPU 、内存和 I/O 设备，如下图所示\u003c/span\u003e\u003c/p\u003e\u003cp id=\"009027f46496d3f8f2bcb165a348c8df\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"85b72b01debce0ace6ba07e6e9e6c0aa\" class=\"ne-p\"\u003e\u003cimg src=\"https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830508-9d21c036-35f6-4f66-a119-b33cd2ebffa9.png\" width=\"720\" id=\"s3oNe\" class=\"ne-image\"\u003e\u003c/p\u003e\u003cp id=\"fff67c6d75a8f701088870489a68703b\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"b6f73292094a29c64c123bc26d8c3f35\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e DMA 传送操作\u003c/span\u003e\u003c/p\u003e\u003cp id=\"2e9984b3603d69feb8670dc2a1da4da7\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"fa3070dc88798a6ad84f66d79849c409\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e现代操作系统实际更为复杂，但是原理是相同的。如果硬件有 \u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003eDMA 控制器\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e，那么操作系统只能使用 DMA。有时这个控制器会集成到磁盘控制器和其他控制器中，但这种设计需要在每个设备上都装有一个分离的 DMA 控制器。单个的 DMA 控制器可用于向多个设备传输，这种传输往往同时进行。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"9872ff0e8287271e0167ad5fe4904890\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003ch4 id=\"fb19257e\"\u003e\u003cspan class=\"ne-text\"\u003eDMA 工作原理\u003c/span\u003e\u003c/h4\u003e\u003cp id=\"a03e5cbf85c29f2523e00aebff3be168\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"83ad54a6486153ef6c842a3d2356ce33\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e首先 CPU 通过设置 DMA 控制器的寄存器对它进行编程，所以 DMA 控制器知道将什么数据传送到什么地方。DMA 控制器还要向磁盘控制器发出一个命令，通知它从磁盘读数据到其内部的缓冲区并检验校验和。当有效数据位于磁盘控制器的缓冲区中时，DMA 就可以开始了。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"988a05fc57bbc139ee60ade19db59775\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"a747f027f15ed77d2cb1885a1e205177\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003eDMA 控制器通过在总线上发出一个\u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e读请求\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e到磁盘控制器而发起 DMA 传送，这是第二步。这个读请求就像其他读请求一样，磁盘控制器并不知道或者并不关心它是来自 CPU 还是来自 DMA 控制器。通常情况下，要写的内存地址在总线的地址线上，所以当磁盘控制器去匹配下一个字时，它知道将该字写到什么地方。写到内存就是另外一个总线循环了，这是第三步。当写操作完成时，磁盘控制器在总线上发出一个应答信号到 DMA 控制器，这是第四步。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"07fa0e231d1e259cf61d47eec043f097\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"5db6af288a1595b279c38f3dfc63fbe9\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e然后，DMA 控制器会增加内存地址并减少字节数量。如果字节数量仍然大于 0 ，就会循环步骤 2 - 步骤 4 ，直到字节计数变为 0 。此时，DMA 控制器会打断 CPU 并告诉它传输已经完成了。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"9e6195abe1061d23e1d4d22ae3d6afa8\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003ch3 id=\"88738ca6\"\u003e\u003cspan class=\"ne-text\"\u003e重温中断\u003c/span\u003e\u003c/h3\u003e\u003cp id=\"7c3f61ac5e50355d43deec6eb171c4b3\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"48c3b8a5650e6a887fa2b72a2b529060\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e在一台个人计算机体系结构中，中断结构会如下所示\u003c/span\u003e\u003c/p\u003e\u003cp id=\"95bd47e829d0671f561d6b370de02cea\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"5dd6ab905cdc97ae2993d6f60bcc7ead\" class=\"ne-p\"\u003e\u003cimg src=\"https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830529-8f149c71-9817-4096-a8df-b613c0308a0c.png\" width=\"719\" id=\"iOWO2\" class=\"ne-image\"\u003e\u003c/p\u003e\u003cp id=\"10d79c44f0beaa13fc3f7bbeb5749849\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"601484c465041f9864201581aa71a5bd\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e 中断是怎样发生的\u003c/span\u003e\u003c/p\u003e\u003cp id=\"7c3e2170d94eae6e8bb1e7ed99cf48eb\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"de5270978abbc6bac17d8b32c4827722\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e当一个 I/O 设备完成它的工作后，它就会产生一个中断（默认操作系统已经开启中断），它通过在总线上声明已分配的信号来实现此目的。主板上的中断控制器芯片会检测到这个信号，然后执行中断操作。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"d54426721eeb0af5700de3ec951f31f3\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003ch4 id=\"a032d055\"\u003e\u003cspan class=\"ne-text\"\u003e精确中断和不精确中断\u003c/span\u003e\u003c/h4\u003e\u003cp id=\"0373af03e43a5a5ef1859377c0c633d9\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"91b406cc3a3758fb324eb8607af4e8f2\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e使机器处于良好状态的中断称为\u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e精确中断(precise interrupt)\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e。这样的中断具有四个属性：\u003c/span\u003e\u003c/p\u003e\u003cp id=\"48b23acc0c3fe244343225c69bafd081\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cul class=\"ne-ul\"\u003e\u003cli id=\"8fd4c3bc25c5fe2966bbd8a70be45152\"\u003e\u003cspan class=\"ne-text\"\u003ePC （程序计数器）保存在一个已知的地方\u003c/span\u003e\u003c/li\u003e\u003cli id=\"9e17123cbba8fae7fe1a9991e2dd410d\"\u003e\u003cspan class=\"ne-text\"\u003ePC 所指向的指令之前所有的指令已经完全执行\u003c/span\u003e\u003c/li\u003e\u003c/ul\u003e\u003cul class=\"ne-ul\"\u003e\u003cli id=\"340dcd019fc2ddbb3832064d9c975248\"\u003e\u003cspan class=\"ne-text\"\u003ePC 所指向的指令之后所有的指令都没有执行\u003c/span\u003e\u003c/li\u003e\u003cli id=\"65e37ac7f0148917395ea4dde0172c57\"\u003e\u003cspan class=\"ne-text\"\u003ePC 所指向的指令的执行状态是已知的\u003c/span\u003e\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"e4c96ab14cd240a871b7845132f1d548\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"660407a271fb6d3cfc3717ddc6ee834d\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e不满足以上要求的中断称为 \u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e不精确中断(imprecise interrupt)\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e，不精确中断让人很头疼。上图描述了不精确中断的现象。指令的执行时序和完成度具有不确定性，而且恢复起来也非常麻烦。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"e3e336a043b7c00394ea46bfc5cfd46c\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003ch2 id=\"bd465b75\"\u003e\u003cspan class=\"ne-text\"\u003eIO 软件原理\u003c/span\u003e\u003c/h2\u003e\u003cp id=\"9805805a9a255a10c1f4cb4e0d0c05a7\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003ch3 id=\"4d234768\"\u003e\u003cspan class=\"ne-text\"\u003eI/O 软件目标\u003c/span\u003e\u003c/h3\u003e\u003cp id=\"f96764b4ab266d91c2222e0ddc8d698e\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003ch4 id=\"e0ddd7b0\"\u003e\u003cspan class=\"ne-text\"\u003e设备独立性\u003c/span\u003e\u003c/h4\u003e\u003cp id=\"fb7a0820cadbc5c77f90763e0c7b7ee1\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"cae2b2b1223c280ab808cd070ae929d4\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003eI/O 软件设计一个很重要的目标就是\u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e设备独立性(device independence)\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e。这意味着\u003c/span\u003e\u003cstrong\u003e\u003cspan class=\"ne-text\"\u003e我们能够编写访问任何设备的应用程序，而不用事先指定特定的设备\u003c/span\u003e\u003c/strong\u003e\u003cspan class=\"ne-text\"\u003e。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"d82bc7d1671e4c56ae19ad479cb3d7f2\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"1d54ad5122b27da8853c8b013cd174a5\" class=\"ne-p\"\u003e\u003cimg src=\"https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830529-e4825574-4e1c-43fa-adf0-519f0ea1c7f7.png\" width=\"500\" id=\"GdxNy\" class=\"ne-image\"\u003e\u003c/p\u003e\u003cp id=\"f68ad4f4e9d3b73f17102d65ba3e55e8\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003ch4 id=\"6a8bef7b\"\u003e\u003cspan class=\"ne-text\"\u003e错误处理\u003c/span\u003e\u003c/h4\u003e\u003cp id=\"d1f2e4f1a31eed63e226fd56b6613183\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"a7884712cfe85b529bebc4d2be5e0cf4\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e除了\u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e设备独立性\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e外，I/O 软件实现的第二个重要的目标就是\u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e错误处理(error handling)\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e。通常情况下来说，错误应该交给\u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e硬件\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e层面去处理。如果设备控制器发现了读错误的话，它会尽可能的去修复这个错误。如果设备控制器处理不了这个问题，那么设备驱动程序应该进行处理，设备驱动程序会再次尝试读取操作，很多错误都是偶然性的，如果设备驱动程序无法处理这个错误，才会把错误向上抛到硬件层面（上层）进行处理，很多时候，上层并不需要知道下层是如何解决错误的。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"9e170e1f0fd449f4dd2137e7394a5814\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003ch4 id=\"11e7c14a\"\u003e\u003cspan class=\"ne-text\"\u003e同步和异步传输\u003c/span\u003e\u003c/h4\u003e\u003cp id=\"53f8dc2f75dd7561fb001a400b5bc1e2\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"3ac6b21c213e53b332d365fd3c462651\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003eI/O 软件实现的第三个目标就是 \u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e同步(synchronous)\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e 和 \u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e异步(asynchronous，即中断驱动)\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e传输。这里先说一下同步和异步是怎么回事吧。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"6600d3b4dbf1a21ab257c236aaf74890\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"8a81b17161a0891783a1e47bafccc87a\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e同步传输中数据通常以块或帧的形式发送。发送方和接收方在数据传输之前应该具有\u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e同步时钟\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e。而在异步传输中，数据通常以字节或者字符的形式发送，异步传输则不需要同步时钟，但是会在传输之前向数据添加\u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e奇偶校验位\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e。大部分\u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e物理IO(physical I/O)\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e 是异步的。物理 I/O 中的 CPU 是很聪明的，CPU 传输完成后会转而做其他事情，它和中断心灵相通，等到中断发生后，CPU 才会回到传输这件事情上来。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"13f056d30c7563c88922db85f5bfa65b\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003ch4 id=\"beeaff4e\"\u003e\u003cspan class=\"ne-text\"\u003e缓冲\u003c/span\u003e\u003c/h4\u003e\u003cp id=\"695396bd0e3da1432e28a9ec7ad67c44\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"d694cf6a6b725b199182eab1999db6af\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003eI/O 软件的最后一个问题是\u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e缓冲(buffering)\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e。通常情况下，从一个设备发出的数据不会直接到达最后的设备。其间会经过一系列的校验、检查、缓冲等操作才能到达。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"6d8f5e80ec7671a409b3349aeafa4e84\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003ch4 id=\"f1ccad80\"\u003e\u003cspan class=\"ne-text\"\u003e共享和独占\u003c/span\u003e\u003c/h4\u003e\u003cp id=\"c08f1179ba4ca61d0259277331999928\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"431707a6eac38d978e9d7b60547c75ec\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003eI/O 软件引起的最后一个问题就是共享设备和独占设备的问题。有些 I/O 设备能够被许多用户共同使用。一些设备比如磁盘，让多个用户使用一般不会产生什么问题，但是某些设备必须具有独占性，即只允许单个用户使用完成后才能让其他用户使用。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"bcb812bfa70e5469e62fda4e1664762d\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"fdb189d5793fe92aaecbae65c33c9d60\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e一共有三种控制 I/O 设备的方法\u003c/span\u003e\u003c/p\u003e\u003cp id=\"3ac081282b49c86ef8508659ef7bae3c\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cul class=\"ne-ul\"\u003e\u003cli id=\"0b7a67c756d4dfb9d85b4a1e274e5cf8\"\u003e\u003cspan class=\"ne-text\"\u003e使用程序控制 I/O\u003c/span\u003e\u003c/li\u003e\u003cli id=\"1d1393ce94ebf7d064d3f95fa243aac4\"\u003e\u003cspan class=\"ne-text\"\u003e使用中断驱动 I/O\u003c/span\u003e\u003c/li\u003e\u003c/ul\u003e\u003cul class=\"ne-ul\"\u003e\u003cli id=\"2280839d3c18c5d4110059dbf95d31b0\"\u003e\u003cspan class=\"ne-text\"\u003e使用 DMA 驱动 I/O\u003c/span\u003e\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"efc9fb3091302ca297ac8fd3ebf94a6f\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003ch2 id=\"ad10edaf\"\u003e\u003cspan class=\"ne-text\"\u003eI/O 层次结构\u003c/span\u003e\u003c/h2\u003e\u003cp id=\"62f867ad46d621ab0a552b8ce4d2a9fb\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"68dfa1c9e4977f08396c1a2cfac6b2ee\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003eI/O 软件通常组织成四个层次，它们的大致结构如下图所示\u003c/span\u003e\u003c/p\u003e\u003cp id=\"7929e287e6be90fb05c7f6eda9e795c6\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"3c94fa0cf4df1135075bdba9d69394e4\" class=\"ne-p\"\u003e\u003cimg src=\"https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830546-fa05a772-fc02-4957-ba1d-1e5a82d78de2.png\" width=\"733\" id=\"la9lz\" class=\"ne-image\"\u003e\u003c/p\u003e\u003cp id=\"367071aef5c7e0cb28661020c6ec67ea\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"fa33c7104d42e131152f9d0133c0bd34\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e下面我们具体的来探讨一下上面的层次结构\u003c/span\u003e\u003c/p\u003e\u003cp id=\"453f272b64d2fca31d28de214c7af40f\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003ch3 id=\"6b8ce92c\"\u003e\u003cspan class=\"ne-text\"\u003e中断处理程序\u003c/span\u003e\u003c/h3\u003e\u003cp id=\"969295b5c2e73885da41f57f47ef9de7\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"c27f88832c6acafb20ddebaa70764997\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e在计算机系统中，中断就像女人的脾气一样无时无刻都在产生，中断的出现往往是让人很不爽的。中断处理程序又被称为\u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e中断服务程序\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e 或者是 \u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003eISR(Interrupt Service Routines)\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e，它是最靠近硬件的一层。中断处理程序由硬件中断、软件中断或者是软件异常启动产生的中断，用于实现设备驱动程序或受保护的操作模式（例如系统调用）之间的转换。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"90650cff08428997dffa1476c683dc7d\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"fb6ef6915c1d6c5b6dc560331811403c\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e中断处理程序负责处理中断发生时的所有操作，操作完成后阻塞，然后启动中断驱动程序来解决阻塞。通常会有三种通知方式，依赖于不同的具体实现\u003c/span\u003e\u003c/p\u003e\u003cp id=\"ad18698c37cb1386d4706b9bbd1f4b18\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cul class=\"ne-ul\"\u003e\u003cli id=\"d0bf3529fd768e31495ed16c17aff466\"\u003e\u003cspan class=\"ne-text\"\u003e信号量实现中：在信号量上使用 \u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003eup\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e 进行通知；\u003c/span\u003e\u003c/li\u003e\u003cli id=\"270d701c94d64a8cac75bef7a1a8005c\"\u003e\u003cspan class=\"ne-text\"\u003e管程实现：对管程中的条件变量执行 \u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003esignal\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e 操作\u003c/span\u003e\u003c/li\u003e\u003c/ul\u003e\u003cul class=\"ne-ul\"\u003e\u003cli id=\"a5a1d1b1aca07b60a91e3c1ff266e036\"\u003e\u003cspan class=\"ne-text\"\u003e还有一些情况是发送一些消息\u003c/span\u003e\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"e31a7428eaec4de703b54c063801fb8d\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003ch3 id=\"62e973ec\"\u003e\u003cspan class=\"ne-text\"\u003e设备驱动程序\u003c/span\u003e\u003c/h3\u003e\u003cp id=\"72c1ffdc38a4bc2a1e7f08037f01f10f\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"ff158f09e0c7d71bdd01b66caa4a81b7\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e每个连接到计算机的 I/O 设备都需要有某些特定设备的代码对其进行控制。这些提供 I/O 设备到设备控制器转换的过程的代码称为 \u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e设备驱动程序(Device driver)\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"ec30527260057319b095d7f987af51b2\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"c44d98b89a8cb33f62b8d0170aba3810\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e设备控制器的主要功能有下面这些\u003c/span\u003e\u003c/p\u003e\u003cp id=\"a8ef9058a6e1d341ecda61b3859848f2\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cul class=\"ne-ul\"\u003e\u003cli id=\"03e25f8eb054ac95ed4d49b5e64491fb\"\u003e\u003cspan class=\"ne-text\"\u003e接收和识别命令：设备控制器可以接受来自 CPU 的指令，并进行识别。设备控制器内部也会有寄存器，用来存放指令和参数\u003c/span\u003e\u003c/li\u003e\u003cli id=\"9b58f4a82cbcbee09a8c32dbae5e5a4b\"\u003e\u003cspan class=\"ne-text\"\u003e进行数据交换：CPU、控制器和设备之间会进行数据的交换，CPU 通过总线把指令发送给控制器，或从控制器中并行地读出数据；控制器将数据写入指定设备。\u003c/span\u003e\u003c/li\u003e\u003c/ul\u003e\u003cul class=\"ne-ul\"\u003e\u003cli id=\"cee546a33ac12989b6ae397dd0e2575f\"\u003e\u003cspan class=\"ne-text\"\u003e地址识别：每个硬件设备都有自己的地址，设备控制器能够识别这些不同的地址，来达到控制硬件的目的，此外，为使 CPU 能向寄存器中写入或者读取数据，这些寄存器都应具有唯一的地址。\u003c/span\u003e\u003c/li\u003e\u003cli id=\"663801b37deb964c633d23a86521b554\"\u003e\u003cspan class=\"ne-text\"\u003e差错检测：设备控制器还具有对设备传递过来的数据进行检测的功能。\u003c/span\u003e\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"186d2e5b3c69f4cc63090482bc71d034\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"918cc521f50cf3d9e06f10a4209a52a2\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e在这种情况下，设备控制器会阻塞，直到中断来解除阻塞状态。还有一种情况是操作是可以无延迟的完成，所以驱动程序不需要阻塞。在第一种情况下，操作系统可能被中断唤醒；第二种情况下操作系统不会被休眠。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"4dc6d4e2af5d94415071e30bbf4dedd3\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"1921ce376109381d2b798c1d0d33e21e\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e设备驱动程序必须是\u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e可重入\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e的，因为设备驱动程序会阻塞和唤醒然后再次阻塞。驱动程序不允许进行系统调用，但是它们通常需要与内核的其余部分进行交互。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"b14ceef4943a55f53f523e4cce258b4d\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003ch3 id=\"e3bc39ca\"\u003e\u003cspan class=\"ne-text\"\u003e与设备无关的 I/O 软件\u003c/span\u003e\u003c/h3\u003e\u003cp id=\"10f8fed94d32fc074de365780434ded0\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"ebda650d821c17681ecaf27bac82b100\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003eI/O 软件有两种，一种是我们上面介绍过的基于特定设备的，还有一种是\u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e设备无关性\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e的，设备无关性也就是不需要特定的设备。设备驱动程序与设备无关的软件之间的界限取决于具体的系统。下面显示的功能由设备无关的软件实现\u003c/span\u003e\u003c/p\u003e\u003cp id=\"0738bab2eec34e7d51f649716df70129\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"0f127c6454010b4bb99d4d0e7ed1f1ba\" class=\"ne-p\"\u003e\u003cimg src=\"https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830586-059b4da8-ea81-4a5a-b884-3377ca39d976.png\" width=\"428\" id=\"qRr1F\" class=\"ne-image\"\u003e\u003c/p\u003e\u003cp id=\"5e72fbe3b21aa9f1140fb098efa4b1ce\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"7d6498e221ca9dbc841a87b949759de7\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e与设备无关的软件的基本功能是对所有设备执行公共的 I/O 功能，并且向用户层软件提供一个统一的接口。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"2147c0bb4a536252e4e10fe043856497\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003ch4 id=\"beeaff4e-1\"\u003e\u003cspan class=\"ne-text\"\u003e缓冲\u003c/span\u003e\u003c/h4\u003e\u003cp id=\"70b3be0dccb8514110943a6e97648b17\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"af82636aa6623d48560a80e60ca7a455\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e无论是对于块设备还是字符设备来说，缓冲都是一个非常重要的考量标准。缓冲技术应用广泛，但它也有缺点。如果数据被缓冲次数太多，会影响性能。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"14ca5e8726df30d891d845d39491b86f\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003ch4 id=\"6a8bef7b-1\"\u003e\u003cspan class=\"ne-text\"\u003e错误处理\u003c/span\u003e\u003c/h4\u003e\u003cp id=\"1bd1dadfd62e3af3a1173bcb759bfb94\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"b09255dfe1fe9917fbddf39e9aa593de\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e在 I/O 中，出错是一种再正常不过的情况了。当出错发生时，操作系统必须尽可能处理这些错误。有一些错误是只有特定的设备才能处理，有一些是由框架进行处理，这些错误和特定的设备无关。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"965a674df58190d1b05557392745253b\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"ee5331138dfc8e986ea7badf7ba49ce5\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003eI/O 错误的一类是程序员\u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e编程\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e错误，比如还没有打开文件前就读流，或者不关闭流导致内存溢出等等。这类问题由程序员处理；另外一类是实际的 I/O 错误，例如向一个磁盘坏块写入数据，无论怎么写都写入不了。这类问题由驱动程序处理，驱动程序处理不了交给硬件处理，这个我们上面也说过。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"522aff626808aa1e8c176163d925a242\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003ch4 id=\"4e16fdac\"\u003e\u003cspan class=\"ne-text\"\u003e设备驱动程序统一接口\u003c/span\u003e\u003c/h4\u003e\u003cp id=\"b4d2e1f579a5150b9d5d256369497333\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"26833baca0c0963e267e4649428f43be\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e我们在操作系统概述中说到，操作系统一个非常重要的功能就是屏蔽了硬件和软件的差异性，为硬件和软件提供了统一的标准，这个标准还体现在为设备驱动程序提供统一的接口，因为不同的硬件和厂商编写的设备驱动程序不同，所以如果为每个驱动程序都单独提供接口的话，这样没法搞，所以必须统一。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"bbde6811238d412e5b62ea43f1d18f97\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003ch4 id=\"c74ca274\"\u003e\u003cspan class=\"ne-text\"\u003e分配和释放\u003c/span\u003e\u003c/h4\u003e\u003cp id=\"4aba2ddd488b12a50616973441385c40\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"dfe10ac47170d60e5e6d5d9b24b9c827\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e一些设备例如打印机，它只能由一个进程来使用，这就需要操作系统根据实际情况判断是否能够对设备的请求进行检查，判断是否能够接受其他请求，一种比较简单直接的方式是在特殊文件上执行 \u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003eopen\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e操作。如果设备不可用，那么直接 open 会导致失败。还有一种方式是不直接导致失败，而是让其阻塞，等到另外一个进程释放资源后，在进行 open 打开操作。这种方式就把选择权交给了用户，由用户判断是否应该等待。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"510e44b2f5b8f53eaa9a17d6fbf08d28\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003ch4 id=\"5dae479a\"\u003e\u003cspan class=\"ne-text\"\u003e设备无关的块\u003c/span\u003e\u003c/h4\u003e\u003cp id=\"cdbefea531e399d091ad67a9c010a18e\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"97f7a0d77ba330bf8aa1481f43e9db01\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e不同的磁盘会具有不同的扇区大小，但是软件不会关心扇区大小，只管存储就是了。一些字符设备可以一次一个字节的交付数据，而其他的设备则以较大的单位交付数据，这些差异也可以隐藏起来。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"7c1bb67a7692b24f169e8ed1c7dd6425\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003ch3 id=\"6d8fb3eb\"\u003e\u003cspan class=\"ne-text\"\u003e用户空间的 I/O 软件\u003c/span\u003e\u003c/h3\u003e\u003cp id=\"22e1a0b547c5bcd83b395670c5dfbddf\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"b44115534de48afe22f229f049c4dd3d\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e虽然大部分 I/O 软件都在内核结构中，但是还有一些在用户空间实现的 I/O 软件，凡事没有绝对。一些 I/O 软件和库过程在用户空间存在，然后以提供系统调用的方式实现。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"daf9ee811684e122a58c85cb4e3d1ab8\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003ch2 id=\"ff4efcaf\"\u003e\u003cspan class=\"ne-text\"\u003e盘\u003c/span\u003e\u003c/h2\u003e\u003cp id=\"f670bd979c27b25d4c7d4fc8220167b5\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"46790dad61b28c8d412e582e4b59070a\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e盘可以说是硬件里面比较简单的构造了，同时也是最重要的。下面我们从盘谈起，聊聊它的物理构造\u003c/span\u003e\u003c/p\u003e\u003cp id=\"6f9f8e17698ca692669e1ed2b80c6402\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003ch3 id=\"6f7147b6\"\u003e\u003cspan class=\"ne-text\"\u003e盘硬件\u003c/span\u003e\u003c/h3\u003e\u003cp id=\"881f0a078f484235fe35102fd05a5fcc\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"410790e052c1df4a2afe5f919551a676\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e盘会有很多种类型。其中最简单的构造就是\u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e磁盘(magnetic hard disks)\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e， 也被称为 \u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003ehard disk,HDD\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e等。磁盘通常与安装在磁臂上的磁头配对，磁头可将数据读取或者将数据写入磁盘，因此磁盘的读写速度都同样快。在磁盘中，数据是随机访问的，这也就说明可以通过任意的顺序来\u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e存储\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e和\u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e检索\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e单个数据块，所以你可以在任意位置放置磁盘来让磁头读取，磁盘是一种\u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e非易失性\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e的设备，即使断电也能永久保留。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"7697974a6ae1d7204b416004062d2c44\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003ch4 id=\"4f5537dd\"\u003e\u003cspan class=\"ne-text\"\u003e磁盘\u003c/span\u003e\u003c/h4\u003e\u003cp id=\"a7ccf8203470d7449eecb013543925cd\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"99c3228c34d08b56f9e4be97cf06b550\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e为了组织和检索数据，会将磁盘组织成特定的结构，这些特定的结构就是\u003c/span\u003e\u003cstrong\u003e\u003cspan class=\"ne-text\"\u003e磁道、扇区和柱面\u003c/span\u003e\u003c/strong\u003e\u003c/p\u003e\u003cp id=\"4aef88f0b558db891f24c06feed2859c\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"1ffcc406a94d9db392fcc0964818d5f3\" class=\"ne-p\"\u003e\u003cimg src=\"https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830596-8b2a7f11-b5c9-4a00-b0c9-436889b099a8.png\" width=\"498\" id=\"XlRJ3\" class=\"ne-image\"\u003e\u003c/p\u003e\u003cp id=\"6b06d914be3bc7c54870e83b6c07bc5f\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"37a4261fd1b90279efe2e7508794d558\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e磁盘被组织成柱面形式，每个盘用轴相连，每一个柱面包含若干磁道，每个磁道由若干扇区组成。软盘上大约每个磁道有 8 - 32 个扇区，硬盘上每条磁道上扇区的数量可达几百个，磁头大约是 1 - 16 个。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"97b0132a4dc0ae7ea912969bd55fd30b\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"81575d25682d5751d39b94b88d20e861\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e对于磁盘驱动程序来说，一个非常重要的特性就是控制器是否能够同时控制两个或者多个驱动器进行磁道寻址，这就是\u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e重叠寻道(overlapped seek)\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e。对于控制器来说，它能够控制一个磁盘驱动程序完成寻道操作，同时让其他驱动程序等待寻道结束。控制器也可以在一个驱动程序上进行读写草哦做，与此同时让另外的驱动器进行寻道操作，但是软盘控制器不能在两个驱动器上进行读写操作。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"62b66fc124bdd060dc868e7aac33e6d7\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003ch4 id=\"RAID\"\u003e\u003cspan class=\"ne-text\"\u003eRAID\u003c/span\u003e\u003c/h4\u003e\u003cp id=\"ffaba10a54eaac5469b3370e3b57ec33\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"06399267d1efd2f5ec1beb76f23a781c\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003eRAID 称为 \u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e磁盘冗余阵列\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e，简称 \u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e磁盘阵列\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e。利用虚拟化技术把多个硬盘结合在一起，成为一个或多个磁盘阵列组，目的是提升性能或数据冗余。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"e603443b78b137065f5838e183e64ae6\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"d99b54a84a692f29ff775f8d078930b0\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003eRAID 有不同的级别\u003c/span\u003e\u003c/p\u003e\u003cp id=\"006985b2d9a124508177b0fe9a97e3d8\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cul class=\"ne-ul\"\u003e\u003cli id=\"fc7b26a623451b45652560652f0ce2dc\"\u003e\u003cspan class=\"ne-text\"\u003eRAID 0 - 无容错的条带化磁盘阵列\u003c/span\u003e\u003c/li\u003e\u003cli id=\"608dcc8c4da9da1cc93901fce2f72bd4\"\u003e\u003cspan class=\"ne-text\"\u003eRAID 1 - 镜像和双工\u003c/span\u003e\u003c/li\u003e\u003c/ul\u003e\u003cul class=\"ne-ul\"\u003e\u003cli id=\"e2f271c87c776d795773644ce782a5be\"\u003e\u003cspan class=\"ne-text\"\u003eRAID 2 - 内存式纠错码\u003c/span\u003e\u003c/li\u003e\u003cli id=\"b865a2f4bbc441c2d6c00230b77ba8a6\"\u003e\u003cspan class=\"ne-text\"\u003eRAID 3 - 比特交错奇偶校验\u003c/span\u003e\u003c/li\u003e\u003c/ul\u003e\u003cul class=\"ne-ul\"\u003e\u003cli id=\"ffd5c142e5fbb5f5caeb8ad4d2df93a9\"\u003e\u003cspan class=\"ne-text\"\u003eRAID 4 - 块交错奇偶校验\u003c/span\u003e\u003c/li\u003e\u003cli id=\"b27145d5ca28e12929413d476ca9d1d4\"\u003e\u003cspan class=\"ne-text\"\u003eRAID 5 - 块交错分布式奇偶校验\u003c/span\u003e\u003c/li\u003e\u003c/ul\u003e\u003cul class=\"ne-ul\"\u003e\u003cli id=\"44edb52008f1699295a33a01674147e4\"\u003e\u003cspan class=\"ne-text\"\u003eRAID 6 - P + Q冗余\u003c/span\u003e\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"e0dd1db8bb6fec97312e991f0c0702d6\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003ch4 id=\"a0c9482b\"\u003e\u003cspan class=\"ne-text\"\u003e磁盘格式化\u003c/span\u003e\u003c/h4\u003e\u003cp id=\"603ffce150e2fc1d987dcfd88ae12f0e\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"2892a91ceec697d1af55116f4eed65ed\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e磁盘由一堆铝的、合金或玻璃的盘片组成，磁盘刚被创建出来后，没有任何信息。磁盘在使用前必须经过\u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e低级格式化(low-levvel format)\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e，下面是一个扇区的格式\u003c/span\u003e\u003c/p\u003e\u003cp id=\"237635b0cde6098f7edf3d17b16c4fb5\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"9eb9a9e1de2f4cd41c8c10489509b3f3\" class=\"ne-p\"\u003e\u003cimg src=\"https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830611-1b106d56-fbdb-4e79-b2b5-e5bd2778a387.png\" width=\"638\" id=\"LU06a\" class=\"ne-image\"\u003e\u003c/p\u003e\u003cp id=\"0c16920b767cb6ec4ea66f9992882f6b\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"0666a317b3e567ada28b40a2ae4678b7\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e前导码相当于是标示扇区的开始位置，通常以位模式开始，前导码还包括\u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e柱面号\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e、\u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e扇区号\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e等一些其他信息。紧随前导码后面的是数据区，数据部分的大小由低级格式化程序来确定。大部分磁盘使用 512 字节的扇区。数据区后面是 ECC，ECC 的全称是 \u003c/span\u003e\u003cstrong\u003e\u003cspan class=\"ne-text\"\u003eerror correction code\u003c/span\u003e\u003c/strong\u003e\u003cspan class=\"ne-text\"\u003e ，\u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e数据纠错码\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e，它与普通的错误检测不同，ECC 还可以用于恢复读错误。ECC 阶段的大小由不同的磁盘制造商实现。ECC 大小的设计标准取决于\u003c/span\u003e\u003cstrong\u003e\u003cspan class=\"ne-text\"\u003e设计者愿意牺牲多少磁盘空间来提高可靠性\u003c/span\u003e\u003c/strong\u003e\u003cspan class=\"ne-text\"\u003e，以及程序可以处理的 ECC 的复杂程度。通常情况下 ECC 是 16 位，除此之外，硬盘一般具有一定数量的备用扇区，用于替换制造缺陷的扇区。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"7528fe0235fd15d3595da91dcbfc864d\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003ch3 id=\"760df63f\"\u003e\u003cspan class=\"ne-text\"\u003e磁盘臂调度算法\u003c/span\u003e\u003c/h3\u003e\u003cp id=\"b6278a03e824428f665cec4c6e256f50\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"03e011ea5a88d0387736e681d5ce4617\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e下面我们来探讨一下关于影响磁盘读写的算法，一般情况下，影响磁盘快读写的时间由下面几个因素决定\u003c/span\u003e\u003c/p\u003e\u003cp id=\"314b5126105ededa2a365cf439adc99f\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cul class=\"ne-ul\"\u003e\u003cli id=\"7462d9403fc3252905f5a028434ad7c1\"\u003e\u003cspan class=\"ne-text\"\u003e寻道时间 - 寻道时间指的就是将磁盘臂移动到需要读取磁盘块上的时间\u003c/span\u003e\u003c/li\u003e\u003cli id=\"5f7257bc3d72ff601be446ec912b45ca\"\u003e\u003cspan class=\"ne-text\"\u003e旋转延迟 - 等待合适的扇区旋转到磁头下所需的时间\u003c/span\u003e\u003c/li\u003e\u003c/ul\u003e\u003cul class=\"ne-ul\"\u003e\u003cli id=\"2be1b7ef29e9defa9d00b39f69ec3494\"\u003e\u003cspan class=\"ne-text\"\u003e实际数据的读取或者写入时间\u003c/span\u003e\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"2b370356fac399fe05f109995162a179\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"0dc67d0cf7fad6f14c4ad3b58f27915e\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e这三种时间参数也是磁盘寻道的过程。一般情况下，寻道时间对总时间的影响最大，所以，有效的降低寻道时间能够提高磁盘的读取速度。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"91c6c8ce16ce7b9388de0e43ef253a37\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"8d11395ec1947cc3a0b7ab12754b4328\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e如果磁盘驱动程序每次接收一个请求并按照接收顺序完成请求，这种处理方式也就是 \u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e先来先服务(First-Come, First-served, FCFS)\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e ，这种方式很难优化寻道时间。因为每次都会按照顺序处理，不管顺序如何，有可能这次读完后需要等待一个磁盘旋转一周才能继续读取，而其他柱面能够马上进行读取，这种情况下每次请求也会排队。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"7d18009d76c74dd7b8db33951c729bd5\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"c10ff5cc598f273b4133beab2f7333d7\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e通常情况下，磁盘在进行寻道时，其他进程会产生其他的磁盘请求。磁盘驱动程序会维护一张表，表中会记录着柱面号当作索引，每个柱面未完成的请求会形成链表，链表头存放在表的相应表项中。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"e046aef3abb66ef5daf5fc38d4c7ca3e\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"6a69ca5623a5c553a4153757cc235dc8\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e一种对先来先服务的算法改良的方案是使用 \u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e最短路径优先(SSF)\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e 算法，下面描述了这个算法。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"32b5296ec1d24eb2a7d5a6939088ad43\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"9b84f8da5378b036c6c206344a7a7154\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e假如我们在对磁道 6 号进行寻址时，同时发生了对 11 , 2 , 4, 14, 8, 15, 3 的请求，如果采用先来先服务的原则，如下图所示\u003c/span\u003e\u003c/p\u003e\u003cp id=\"807006c94eac31f179e807c72677c14d\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"139b589cb34fee0e242e2a53b569c729\" class=\"ne-p\"\u003e\u003cimg src=\"https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830646-2dfee703-9a35-47c9-880c-2c620d64464a.png\" width=\"762\" id=\"GIQle\" class=\"ne-image\"\u003e\u003c/p\u003e\u003cp id=\"852c3cef391fcf30dcbc45d68ead84cb\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"07318c6d578eb7970403c2e9c0200380\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e我们可以计算一下磁盘臂所跨越的磁盘数量为 5 + 9 + 2 + 10 + 6 + 7 + 12 = 51，相当于是跨越了 51 次盘面，如果使用最短路径优先，我们来计算一下跨越的盘面\u003c/span\u003e\u003c/p\u003e\u003cp id=\"9251d4187ee9e3955d98e126f5a61b7b\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"f7750d7e03767b8fb7464af21e31e096\" class=\"ne-p\"\u003e\u003cimg src=\"https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830629-e3cda6d4-2317-438b-a377-9e5dc5a3a802.png\" width=\"709\" id=\"k9irp\" class=\"ne-image\"\u003e\u003c/p\u003e\u003cp id=\"33fc7e528d1fb915ae0e5eb381f979a1\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"a31730f3fb60b31dd1c442e0b3c89ff8\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e跨越的磁盘数量为 4 + 1 + 1 + 4 + 3 + 3 + 1 = 17 ，相比 51 足足省了两倍的时间。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"aeb569eb1e81c5ef30132a4f118513d6\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"bbe4e798ae04ba9181c1b53f7030014c\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e但是，最短路径优先的算法也不是完美无缺的，这种算法照样存在问题，那就是\u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e优先级\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e 问题，\u003c/span\u003e\u003c/p\u003e\u003cp id=\"33bbdf6c3903be454a5434c1b4b45129\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"753770733d67a5f8ee48a11ff1bbe27a\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e这里有一个原型可以参考就是我们日常生活中的电梯，电梯使用一种\u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e电梯算法(elevator algorithm)\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e 来进行调度，从而满足协调效率和公平性这两个相互冲突的目标。电梯一般会保持向一个方向移动，直到在那个方向上没有请求为止，然后改变方向。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"58e3089c129557a6025b4b2e291be8e5\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"6148ba2cda1c3131d27d57b6737daef0\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e电梯算法需要维护一个\u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e二进制位\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e，也就是当前的方向位：\u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003eUP(向上)\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e或者是 \u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003eDOWN(向下)\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e。当一个请求处理完成后，磁盘或电梯的驱动程序会检查该位，如果此位是 UP 位，磁盘臂或者电梯仓移到下一个更高跌未完成的请求。如果高位没有未完成的请求，则取相反方向。当方向位是 \u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003eDOWN\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e 时，同时存在一个低位的请求，磁盘臂会转向该点。如果不存在的话，那么它只是停止并等待。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"e90c80069ca940c4dccc45414d988aa6\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"2e5464096db15e05287322aedc930903\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e我们举个例子来描述一下电梯算法，比如各个柱面得到服务的顺序是 4，7，10，14，9，6，3，1 ，那么它的流程图如下\u003c/span\u003e\u003c/p\u003e\u003cp id=\"f8c4a980d7ccbf906215cfae641fb9de\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"9db3b630e1e92fea3c4e594885ac701c\" class=\"ne-p\"\u003e\u003cimg src=\"https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830648-6e8afe9c-f2fd-4c64-8db9-7f68930d0a27.png\" width=\"710\" id=\"qkkaP\" class=\"ne-image\"\u003e\u003c/p\u003e\u003cp id=\"c0843a5f92d2fd7b0137831f7a66b398\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"56a54c492ce1f8a483ad07c078eedaa6\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e所以电梯算法需要跨越的盘面数量是 3 + 3 + 4 + 5 + 3 + 3 + 1 = 22\u003c/span\u003e\u003c/p\u003e\u003cp id=\"6537fc8bf8f453295d6a455f604979f3\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"67c0f7b60aa67bfebb7ad608b2d9b80e\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e电梯算法通常情况下不如 SSF 算法。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"6cdbd3e42df5f443f82a300371150d79\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003ch3 id=\"6a8bef7b-2\"\u003e\u003cspan class=\"ne-text\"\u003e错误处理\u003c/span\u003e\u003c/h3\u003e\u003cp id=\"cd448c76eee05090052f87c787370093\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"e35a9d1da80fb23de9e8c755ab4375f7\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e一般坏块有两种处理办法，一种是在控制器中进行处理；一种是在操作系统层面进行处理。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"f72cda08c63f4925bb58c1e69dc98731\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"efe36e8265e3ea31c5ca3acbbd4d2419\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e这两种方法经常替换使用，比如一个具有 30 个数据扇区和两个备用扇区的磁盘，其中扇区 4 是有瑕疵的。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"46e08dedb1f01e545beee9d410b8ca30\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"973a0923ca8878b60159e1381d2db988\" class=\"ne-p\"\u003e\u003cimg src=\"https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830690-4489f1b3-d4a8-49d6-bd29-1becb143d418.png\" width=\"423\" id=\"j9QM3\" class=\"ne-image\"\u003e\u003c/p\u003e\u003cp id=\"efc58b0eaccde5c29602b247280b7659\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"c04a32c0f9c7869487d8bf460b2af6f0\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e控制器能做的事情就是将备用扇区之一重新映射。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"b409a58389fcff3598c331a89f6dbeb2\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"4da899689af489cd2c870ae6658c4290\" class=\"ne-p\"\u003e\u003cimg src=\"https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830735-2f51c8ae-a37f-4673-9781-a2519263c63f.png\" width=\"500\" id=\"BSem5\" class=\"ne-image\"\u003e\u003c/p\u003e\u003cp id=\"8e494cf7453125ff435eff2d552fb41d\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"e6f45bb62550a08872dea21674e5c005\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e还有一种处理方式是将所有的扇区都向上移动一个扇区\u003c/span\u003e\u003c/p\u003e\u003cp id=\"c46a73b199e28b719c907ef92d49b313\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"48f0cc7b31fc216b96308193861a1900\" class=\"ne-p\"\u003e\u003cimg src=\"https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830717-1dc1be76-6eff-4891-8d89-843a7110e6a8.png\" width=\"497\" id=\"OZ9U3\" class=\"ne-image\"\u003e\u003c/p\u003e\u003cp id=\"c3abc09db901f9b310fad8ef6cdb5415\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"1559044f1c5e9c73aff061102d26bd29\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e上面这这两种情况下控制器都必须知道哪个扇区，可以通过内部的表来跟踪这一信息，或者通过重写前导码来给出重新映射的扇区号。如果是重写前导码，那么涉及移动的方式必须重写后面所有的前导码，但是最终会提供良好的性能。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"f15e6f8229cb758b7b0c9e8ebb12edd8\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003ch3 id=\"dd4fb2cb\"\u003e\u003cspan class=\"ne-text\"\u003e稳定存储器\u003c/span\u003e\u003c/h3\u003e\u003cp id=\"4ad899cab1ab97a5aabbaf01a5be34cf\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"58e282adac0cb4419208d340a02153a8\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e磁盘经常会出现错误，导致好的扇区会变成坏扇区，驱动程序也有可能挂掉。RAID 可以对扇区出错或者是驱动器崩溃提出保护，然而 RAID 却不能对坏数据中的写错误提供保护，也不能对写操作期间的崩溃提供保护，这样就会破坏原始数据。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"473a78fd5112572f75a9b22ad7bf64eb\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"27763f1b1c4778a17eba274ab07dbeec\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e我们期望磁盘能够准确无误的工作，但是事实情况是不可能的，但是我们能够知道的是，一个磁盘子系统具有如下特性：当一个写命令发给它时，磁盘要么正确地写数据，要么什么也不做，让现有的数据完整无误的保留。这样的系统称为 \u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e稳定存储器(stable storage)\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e。 稳定存储器的目标就是不惜一切代价保证磁盘的一致性。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"e0bbd24c6e2eac90bc9bef03d023565c\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"23c65e8ec21c9f98369932ed2ca149d8\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e稳定存储器使用两个一对相同的磁盘，对应的块一同工作形成一个无差别的块。稳定存储器为了实现这个目的，定义了下面三种操作：\u003c/span\u003e\u003c/p\u003e\u003cp id=\"5fb6db8f32f3839372d1c236a3e8bf98\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cul class=\"ne-ul\"\u003e\u003cli id=\"11e13f4166e70f36fb7c87fb739dea9c\"\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e稳定写(stable write)\u003c/span\u003e\u003c/code\u003e\u003c/li\u003e\u003cli id=\"895c72d40eb8c8f6b8d1b19066db9933\"\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e稳定读(stable read)\u003c/span\u003e\u003c/code\u003e\u003c/li\u003e\u003c/ul\u003e\u003cul class=\"ne-ul\"\u003e\u003cli id=\"da686324dfe297329016a5be43c1141d\"\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e崩溃恢复(crash recovery)\u003c/span\u003e\u003c/code\u003e\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"3bf3c6998eede59026606fee3cbb805a\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003ch2 id=\"751437d1\"\u003e\u003cspan class=\"ne-text\"\u003e时钟\u003c/span\u003e\u003c/h2\u003e\u003cp id=\"42bfc7cc58126df175de0804edb625f1\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"275f2f33e6f9a41aaf0f1af466175266\" class=\"ne-p\"\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e时钟(Clocks)\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e 也被称为\u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e定时器(timers)\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e，时钟/定时器对任何程序系统来说都是必不可少的。时钟负责维护时间、防止一个进程长期占用 CPU 时间等其他功能。\u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e时钟软件(clock software)\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e 也是一种设备驱动的方式。下面我们就来对时钟进行介绍，一般都是先讨论硬件再介绍软件，采用由下到上的方式，也是告诉你，底层是最重要的。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"53b9aa404a3a4a083622863777556273\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003ch3 id=\"e8a4fb9a\"\u003e\u003cspan class=\"ne-text\"\u003e时钟硬件\u003c/span\u003e\u003c/h3\u003e\u003cp id=\"2a655f87074ad58d9ef984e79932a319\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"8ef96daa1f5875a499646dd402188b1f\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e在计算机中有两种类型的时钟，这些时钟与现实生活中使用的时钟完全不一样。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"2e4a913ade7c6d01a0f32f2a434d095c\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cul class=\"ne-ul\"\u003e\u003cli id=\"55f7695ceccc219d7810683c20403f2f\"\u003e\u003cspan class=\"ne-text\"\u003e比较简单的一种时钟被连接到 110 V 或 220 V 的电源线上，这样每个\u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e电压周期\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e会产生一个中断，大概是 50 - 60 HZ。这些时钟过去一直占据支配地位。\u003c/span\u003e\u003c/li\u003e\u003cli id=\"cf9376a6328b7c2eb22a1a93c6f08aa6\"\u003e\u003cspan class=\"ne-text\"\u003e另外的一种时钟由晶体振荡器、计数器和寄存器组成，示意图如下所示\u003c/span\u003e\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"439d4fe21f5ac9db8fcc1898d175e44d\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"58e69eb2dd1d8030de36ab796376c1f3\" class=\"ne-p\"\u003e\u003cimg src=\"https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830741-6daaaf06-0552-44b1-bf19-85729fd25288.png\" width=\"627\" id=\"VUI1p\" class=\"ne-image\"\u003e\u003c/p\u003e\u003cp id=\"138cdebd4b5315b038710c7d2442d19c\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"fed5845bb86ffee727f4ec21c1f3305b\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e这种时钟称为\u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e可编程时钟\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e ，可编程时钟有两种模式，一种是 \u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e一键式(one-shot mode)\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e，当时钟启动时，会把存储器中的值复制到计数器中，然后，每次晶体的振荡器的脉冲都会使计数器 -1。当计数器变为 0 时，会产生一个中断，并停止工作，直到软件再一次显示启动。还有一种模式时 \u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e方波(square-wave mode)\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e 模式，在这种模式下，当计数器变为 0 并产生中断后，存储寄存器的值会自动复制到计数器中，这种周期性的中断称为一个时钟周期。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"bda3a730c41682e58599382a899dcd60\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003ch3 id=\"b173f2cb\"\u003e\u003cspan class=\"ne-text\"\u003e时钟软件\u003c/span\u003e\u003c/h3\u003e\u003cp id=\"d8bdf65c9a5135888a2497a3439f7145\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"b00c628ad58f5b5dce23e9850a61c034\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e时钟硬件所做的工作只是根据已知的时间间隔产生中断，而其他的工作都是由\u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e时钟软件\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e来完成，一般操作系统的不同，时钟软件的具体实现也不同，但是一般都会包括以下这几点\u003c/span\u003e\u003c/p\u003e\u003cp id=\"c9f6a7282375ba50967103b96e0fa187\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cul class=\"ne-ul\"\u003e\u003cli id=\"87f3966c7f38a21ec3de2e00caa8c495\"\u003e\u003cspan class=\"ne-text\"\u003e维护一天的时间\u003c/span\u003e\u003c/li\u003e\u003cli id=\"83f9eb2354f6857b43e402f24d895af3\"\u003e\u003cspan class=\"ne-text\"\u003e阻止进程运行的时间超过其指定时间\u003c/span\u003e\u003c/li\u003e\u003c/ul\u003e\u003cul class=\"ne-ul\"\u003e\u003cli id=\"b15f932d0660dfeed727e20b42edf52d\"\u003e\u003cspan class=\"ne-text\"\u003e统计 CPU 的使用情况\u003c/span\u003e\u003c/li\u003e\u003cli id=\"5b41149ddbaee4b2dc5216e16149e38a\"\u003e\u003cspan class=\"ne-text\"\u003e处理用户进程的警告系统调用\u003c/span\u003e\u003c/li\u003e\u003c/ul\u003e\u003cul class=\"ne-ul\"\u003e\u003cli id=\"3e1b60c00fc9f9f5bc20bfc979ef00a2\"\u003e\u003cspan class=\"ne-text\"\u003e为系统各个部分提供看门狗定时器\u003c/span\u003e\u003c/li\u003e\u003cli id=\"d2276a0cd1af25e63d9f08f9fe7ee549\"\u003e\u003cspan class=\"ne-text\"\u003e完成概要剖析，监视和信息收集\u003c/span\u003e\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"9e1dabd93c76dcfad0d1beab34188d56\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003ch3 id=\"b91fda0e\"\u003e\u003cspan class=\"ne-text\"\u003e软定时器\u003c/span\u003e\u003c/h3\u003e\u003cp id=\"95ae8d930b294e9c0fbf9c4a05ebbc55\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"a5c4252cb21d8d6068043a7afe3d314c\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e时钟软件也被称为可编程时钟，可以设置它以程序需要的任何速率引发中断。时钟软件触发的中断是一种硬中断，但是某些应用程序对于硬中断来说是不可接受的。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"f79ba5cf1321c60b2dc29763e734e1ac\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"e6dfdfd7167d693006ca2a8a105d7c9b\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e这时候就需要一种\u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e软定时器(soft timer)\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e 避免了中断，无论何时当内核因为某种原因呢在运行时，它返回用户态之前都会检查时钟来了解软定时器是否到期。如果软定时器到期，则执行被调度的事件也无需切换到内核态，因为本身已经处于内核态中。这种方式避免了频繁的内核态和用户态之前的切换，提高了程序运行效率。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"4d84d77fd04a9489fe535b3daa4f7b69\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"d50c55b092a1800b5a7f27a4dc606790\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e软定时器因为不同的原因切换进入内核态的速率不同，原因主要有\u003c/span\u003e\u003c/p\u003e\u003cp id=\"b15053b7084f5d35f327aba23c558ddd\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cul class=\"ne-ul\"\u003e\u003cli id=\"e896c450129d2ead85b0eb99d11bb5eb\"\u003e\u003cspan class=\"ne-text\"\u003e系统调用\u003c/span\u003e\u003c/li\u003e\u003cli id=\"0c1a4062ca9907469cc5b5a914f250ef\"\u003e\u003cspan class=\"ne-text\"\u003eTLB 未命中\u003c/span\u003e\u003c/li\u003e\u003c/ul\u003e\u003cul class=\"ne-ul\"\u003e\u003cli id=\"f984a4635683adf2eff00aa2764aae22\"\u003e\u003cspan class=\"ne-text\"\u003e缺页异常\u003c/span\u003e\u003c/li\u003e\u003cli id=\"1e8fa7b36d7c84263c14a105f9d8a40a\"\u003e\u003cspan class=\"ne-text\"\u003eI/O 中断\u003c/span\u003e\u003c/li\u003e\u003c/ul\u003e\u003cul class=\"ne-ul\"\u003e\u003cli id=\"8584034cbecc7bed86a6ce92b0021351\"\u003e\u003cspan class=\"ne-text\"\u003eCPU 变得空闲\u003c/span\u003e\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"8c1b12bc4cb14f1332748c06db0e8a82\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"20bd0c60869e5232c1a9da4f41bc3362\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e死锁问题也是操作系统非常重要的一类问题\u003c/span\u003e\u003c/p\u003e\u003cp id=\"d8b84eaac214a26402cf69e0457896cb\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"2e47e39e0877ecee085aa3aa086c4bd7\" class=\"ne-p\"\u003e\u003cimg src=\"https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830748-305133ff-5324-4e46-b119-74609aedd401.png\" width=\"721\" id=\"WK6xj\" class=\"ne-image\"\u003e\u003c/p\u003e\u003cp id=\"a9d7734a1e890759c5b156cdd8f82011\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003ch2 id=\"eee83a92\"\u003e\u003cspan class=\"ne-text\"\u003e资源\u003c/span\u003e\u003c/h2\u003e\u003cp id=\"d7231e68daee7dc7da7271048e9e2f43\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"9478bc370ebcfa642d99c1b1d4e681fa\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e大部分的死锁都和资源有关，在进程对设备、文件具有独占性（排他性）时会产生死锁。我们把这类需要排他性使用的对象称为\u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e资源(resource)\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e。资源主要分为 \u003c/span\u003e\u003cstrong\u003e\u003cspan class=\"ne-text\"\u003e可抢占资源和不可抢占资源\u003c/span\u003e\u003c/strong\u003e\u003c/p\u003e\u003cp id=\"3eac1e4d117abd05087b36175c975155\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003ch3 id=\"27201743\"\u003e\u003cspan class=\"ne-text\"\u003e可抢占资源和不可抢占资源\u003c/span\u003e\u003c/h3\u003e\u003cp id=\"72ec56e9b234da0b742fc02a6cabc6f5\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"aca2fb281a7bd5541bea22c94bd6b33a\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e资源主要有可抢占资源和不可抢占资源。\u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e可抢占资源(preemptable resource)\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e 可以从拥有它的进程中抢占而不会造成其他影响，内存就是一种可抢占性资源，任何进程都能够抢先获得内存的使用权。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"5b8beb8ea2c4de6036320fcc924dcf57\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"e1b275fbf0b76f9c98f8612371b35e35\" class=\"ne-p\"\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e不可抢占资源(nonpreemtable resource)\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e 指的是除非引起错误或者异常，否则进程无法抢占指定资源，这种不可抢占的资源比如有光盘，在进程执行调度的过程中，其他进程是不能得到该资源的。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"1bb4f502e68b522ee9f808e108067db3\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003ch2 id=\"60461afa\"\u003e\u003cspan class=\"ne-text\"\u003e死锁\u003c/span\u003e\u003c/h2\u003e\u003cp id=\"fb62f7163749f731b9eea44242c66117\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"fd64352b74e15c5119d31f2d078fa99f\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e如果要对死锁进行一个定义的话，下面的定义比较贴切\u003c/span\u003e\u003c/p\u003e\u003cp id=\"481b22ddedf0cdb8abca22a089108ce4\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"baae47f87c55b321b1a847755d5bd5a2\" class=\"ne-p\"\u003e\u003cstrong\u003e\u003cspan class=\"ne-text\"\u003e如果一组进程中的每个进程都在等待一个事件，而这个事件只能由该组中的另一个进程触发，这种情况会导致死锁\u003c/span\u003e\u003c/strong\u003e\u003cspan class=\"ne-text\"\u003e。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"cd3b049f801c785902aa2ee9f5537659\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003ch3 id=\"a4ffc042\"\u003e\u003cspan class=\"ne-text\"\u003e资源死锁的条件\u003c/span\u003e\u003c/h3\u003e\u003cp id=\"8cf2cde31de59698515b56ec5a49c581\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"7bf9ec1a4e71c2362bc024c611a36dab\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e针对我们上面的描述，资源死锁可能出现的情况主要有\u003c/span\u003e\u003c/p\u003e\u003cp id=\"d2965e8c80a02d9f6ae8ad4dd9741a6c\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cul class=\"ne-ul\"\u003e\u003cli id=\"2461cac20ec655f2ce5216f716ed970d\"\u003e\u003cspan class=\"ne-text\"\u003e互斥条件：每个资源都被分配给了一个进程或者资源是可用的\u003c/span\u003e\u003c/li\u003e\u003cli id=\"b59b3d4339b30dbbd1d4c840019f29fa\"\u003e\u003cspan class=\"ne-text\"\u003e保持和等待条件：已经获取资源的进程被认为能够获取新的资源\u003c/span\u003e\u003c/li\u003e\u003c/ul\u003e\u003cul class=\"ne-ul\"\u003e\u003cli id=\"c83defcb158380ae745008f1ce2e7b4b\"\u003e\u003cspan class=\"ne-text\"\u003e不可抢占条件：分配给一个进程的资源不能强制的从其他进程抢占资源，它只能由占有它的进程显示释放\u003c/span\u003e\u003c/li\u003e\u003cli id=\"24871dfae1e4208085188d6d4dffdce3\"\u003e\u003cspan class=\"ne-text\"\u003e循环等待：死锁发生时，系统中一定有两个或者两个以上的进程组成一个循环，循环中的每个进程都在等待下一个进程释放的资源。\u003c/span\u003e\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"57e7bca96f378b5215fc1af485de28e6\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"ec8baeee4c99e209781933e1f1514ea9\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e发生死锁时，上面的情况必须同时会发生。如果其中任意一个条件不会成立，死锁就不会发生。可以通过破坏其中任意一个条件来破坏死锁，下面这些破坏条件就是我们探讨的重点\u003c/span\u003e\u003c/p\u003e\u003cp id=\"1df908aa8bf7935a457c9c552b0fea44\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003ch3 id=\"2ba04a66\"\u003e\u003cspan class=\"ne-text\"\u003e死锁模型\u003c/span\u003e\u003c/h3\u003e\u003cp id=\"a04f8c5e84de9684afc27ae414a6d779\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"85b83d0ed4eb6aa01bc52b5c0e6916ca\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003eHolt 在 1972 年提出对死锁进行建模，建模的标准如下：\u003c/span\u003e\u003c/p\u003e\u003cp id=\"35efa46631e12a3613067329ef47eaa6\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cul class=\"ne-ul\"\u003e\u003cli id=\"5c6ff301023c6b32a75add616a9f195a\"\u003e\u003cspan class=\"ne-text\"\u003e圆形表示进程\u003c/span\u003e\u003c/li\u003e\u003cli id=\"8fd6eb48acae20dc5052e40e62d39242\"\u003e\u003cspan class=\"ne-text\"\u003e方形表示资源\u003c/span\u003e\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"76e680e1ac67826c1904b922f2508207\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"0eb57a1be3e1c45d5a9d5d78b3855fb1\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e从资源节点到进程节点表示资源已经被进程占用，如下图所示\u003c/span\u003e\u003c/p\u003e\u003cp id=\"59962074ed9fa78004d8f206555aeb1c\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"e23a383dff53004dac74daaebfa5cf62\" class=\"ne-p\"\u003e\u003cimg src=\"https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830760-e22f0a74-94ab-4be7-9b39-3f611c32823a.png\" width=\"331\" id=\"BjL47\" class=\"ne-image\"\u003e\u003c/p\u003e\u003cp id=\"0a2f8ae870c3bb8c95857ace4b4c3e73\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"cdfcbee5b6e9b6948f037308db4d7622\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e在上图中表示当前资源 R 正在被 A 进程所占用\u003c/span\u003e\u003c/p\u003e\u003cp id=\"67676b8c22e281f016c0d0b1e01204e0\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"1fb8a54214e882e963e6db8825977fc4\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e由进程节点到资源节点的有向图表示当前进程正在请求资源，并且该进程已经被阻塞，处于等待这个资源的状态\u003c/span\u003e\u003c/p\u003e\u003cp id=\"bb1747bacfa748ab9f5f396430510658\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"53fdec97a470c1c990d4c19da34a87c2\" class=\"ne-p\"\u003e\u003cimg src=\"https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830813-2b57251b-055b-4664-b040-89f60d1d43c4.png\" width=\"345\" id=\"u51ZN\" class=\"ne-image\"\u003e\u003c/p\u003e\u003cp id=\"fc7fcab5e87f8354278b202646ce6bb8\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"2ca0e28dee5d52b527286b9f49dc14da\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e在上图中，表示的含义是进程 B 正在请求资源 S 。Holt 认为，死锁的描述应该如下\u003c/span\u003e\u003c/p\u003e\u003cp id=\"3f72668bb9a949d52e87791eae34010b\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"51082e3beb38f015ef3ac95212b138d2\" class=\"ne-p\"\u003e\u003cimg src=\"https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830811-a3afe75e-0c48-40b9-8fa4-e74d132d9b58.png\" width=\"485\" id=\"bhef4\" class=\"ne-image\"\u003e\u003c/p\u003e\u003cp id=\"01f74cd30421be5cf72c44619b12477f\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"01f565a83434d718c7ae59fd03de6811\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e这是一个死锁的过程，进程 C 等待资源 T 的释放，资源 T 却已经被进程 D 占用，进程 D 等待请求占用资源 U ，资源 U 却已经被线程 C 占用，从而形成环。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"b237901b2be04c14ea3abad0df23223c\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"d3950d5ac640dba2723c9ce141487292\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e有四种处理死锁的策略：\u003c/span\u003e\u003c/p\u003e\u003cp id=\"9c28eb93725ce1026b8e57cbdc9d884a\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cul class=\"ne-ul\"\u003e\u003cli id=\"f02059d209937e043cc91b3202332b45\"\u003e\u003cspan class=\"ne-text\"\u003e忽略死锁带来的影响（惊呆了）\u003c/span\u003e\u003c/li\u003e\u003cli id=\"7ed0ecd020c81e768cc3daddc64d269c\"\u003e\u003cspan class=\"ne-text\"\u003e检测死锁并回复死锁，死锁发生时对其进行检测，一旦发生死锁后，采取行动解决问题\u003c/span\u003e\u003c/li\u003e\u003c/ul\u003e\u003cul class=\"ne-ul\"\u003e\u003cli id=\"15d6f899a7a219f73c9f9c5d3d84284a\"\u003e\u003cspan class=\"ne-text\"\u003e通过仔细分配资源来避免死锁\u003c/span\u003e\u003c/li\u003e\u003cli id=\"3480f5545cb59921ddc8cce5bb380e7e\"\u003e\u003cspan class=\"ne-text\"\u003e通过破坏死锁产生的四个条件之一来避免死锁\u003c/span\u003e\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"01bc1144b78631aef94e579fa8d1d912\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"495a1907b5f77a040cb025c261a0dde9\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e下面我们分别介绍一下这四种方法\u003c/span\u003e\u003c/p\u003e\u003cp id=\"364bc81ab84b40122e907de1d02cf761\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003ch2 id=\"445e7ac3\"\u003e\u003cspan class=\"ne-text\"\u003e鸵鸟算法\u003c/span\u003e\u003c/h2\u003e\u003cp id=\"036b75a65beb0a6e2c2ca45ebd1bf297\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"e6043383dfd449422770da6892dcea16\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e最简单的解决办法就是使用\u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e鸵鸟算法(ostrich algorithm)\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e，把头埋在沙子里，假装问题根本没有发生。每个人看待这个问题的反应都不同。数学家认为死锁是不可接受的，必须通过有效的策略来防止死锁的产生。工程师想要知道问题发生的频次，系统因为其他原因崩溃的次数和死锁带来的严重后果。如果死锁发生的频次很低，而经常会由于硬件故障、编译器错误等其他操作系统问题导致系统崩溃，那么大多数工程师不会修复死锁。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"52f6db636d5ff751b26f95bdd338d289\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003ch2 id=\"c34052de\"\u003e\u003cspan class=\"ne-text\"\u003e死锁检测和恢复\u003c/span\u003e\u003c/h2\u003e\u003cp id=\"225135e8a2070f389de38812717eb75d\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"f06571b2cb07e67da53eb1f9ae46f666\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e第二种技术是死锁的检测和恢复。这种解决方式不会尝试去阻止死锁的出现。相反，这种解决方案会希望死锁尽可能的出现，在监测到死锁出现后，对其进行恢复。下面我们就来探讨一下死锁的检测和恢复的几种方式\u003c/span\u003e\u003c/p\u003e\u003cp id=\"14ee619ccacc077fbb0ab230f795ff08\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003ch3 id=\"845b19bd\"\u003e\u003cspan class=\"ne-text\"\u003e每种类型一个资源的死锁检测方式\u003c/span\u003e\u003c/h3\u003e\u003cp id=\"8856acadce3e4be26400996c75037a18\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"1dce1bbff3adfcf55a761b49b459a9a9\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e每种资源类型都有一个资源是什么意思？我们经常提到的打印机就是这样的，资源只有打印机，但是设备都不会超过一个。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"7aa26a189549bf96df754b2f1ace77ae\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"ae3dd6af307505c10b0eb562a80986f1\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e可以通过构造一张资源分配表来检测这种错误，比如我们上面提到的\u003c/span\u003e\u003c/p\u003e\u003cp id=\"57bb0ac633cecdfa908fa75afa54cbdc\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"ad5e4cd721b90f28101f2acd23afe3bb\" class=\"ne-p\"\u003e\u003cimg src=\"https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830848-f4bc59e7-89e2-4e78-909c-e8dcd1718ebe.png\" width=\"475\" id=\"TYPR7\" class=\"ne-image\"\u003e\u003c/p\u003e\u003cp id=\"2745a826110fc96a2b6216f300175397\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"32c152b4a1b42accb3ee8f73ca42fd9a\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e如果这张图包含了一个或一个以上的环，那么死锁就存在，处于这个环中任意一个进程都是死锁的进程。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"00db8fb2a967b493da00c952b7385bb2\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003ch3 id=\"0e6d1847\"\u003e\u003cspan class=\"ne-text\"\u003e每种类型多个资源的死锁检测方式\u003c/span\u003e\u003c/h3\u003e\u003cp id=\"feab24bd3b82d2799e2dac6d56957450\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"8675e27ef21c4d6f4e3c390a9039463d\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e如果有多种相同的资源存在，就需要采用另一种方法来检测死锁。可以通过构造一个矩阵来检测从 P1 -\u0026gt; Pn 这 n 个进程中的死锁。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"04fc31dd56db424542188c800706797c\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"a24b641ae3e9651167024af87187bf28\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e现在我们提供一种基于矩阵的算法来检测从 P1 到 Pn 这 n 个进程中的死锁。假设资源类型为 m，E1 代表资源类型1，E2 表示资源类型 2 ，Ei 代表资源类型 i (1 \u0026lt;= i \u0026lt;= m)。E 表示的是 \u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e现有资源向量(existing resource vector)\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e，代表每种已存在的资源总数。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"9d26e86025397b8d6319268fa76a93a3\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"41f401b08793431302caeb310f9f5076\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e现在我们就需要构造两个数组：C 表示的是\u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e当前分配矩阵(current allocation matrix)\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e ，R 表示的是 \u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e请求矩阵(request matrix)\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e。Ci 表示的是 Pi 持有每一种类型资源的资源数。所以，Cij 表示 Pi 持有资源 j 的数量。Rij 表示 Pi 所需要获得的资源 j 的数量\u003c/span\u003e\u003c/p\u003e\u003cp id=\"66cca3aac1c7c3a268bcf0cbe528756c\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"92630dcca8243665dde0564f6c12e1cd\" class=\"ne-p\"\u003e\u003cimg src=\"https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830847-d4f0a077-7abd-4507-a720-337bc99b121e.png\" width=\"686\" id=\"JZ0fA\" class=\"ne-image\"\u003e\u003c/p\u003e\u003cp id=\"56bc171dc0bf324243530e635d5bab68\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"423bab2c70172066263bee3d30dad1f7\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e一般来说，已分配资源 j 的数量加起来再和所有可供使用的资源数相加 = 该类资源的总数。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"77aae0d262cefbaa04162ad431e28520\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"6c93735bd020f34c0a7d4addc689ef08\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e死锁的检测就是基于向量的比较。每个进程起初都是没有被标记过的，算法会开始对进程做标记，进程被标记后说明进程被执行了，不会进入死锁，当算法结束时，任何没有被标记过的进程都会被判定为死锁进程。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"14e91ed8d03af86ca1b09968d2699d12\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"124b222886574ccd5653fc831d93cb96\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e上面我们探讨了两种检测死锁的方式，那么现在你知道怎么检测后，你何时去做死锁检测呢？一般来说，有两个考量标准：\u003c/span\u003e\u003c/p\u003e\u003cp id=\"1a40a355ed7a5a9fea8130b2e3e33388\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cul class=\"ne-ul\"\u003e\u003cli id=\"ee8c565c1201d24a8441c6fbb77ece7b\"\u003e\u003cspan class=\"ne-text\"\u003e每当有资源请求时就去检测，这种方式会占用昂贵的 CPU 时间。\u003c/span\u003e\u003c/li\u003e\u003cli id=\"afc8b082824e82774c1c3be31d74ac3e\"\u003e\u003cspan class=\"ne-text\"\u003e每隔 k 分钟检测一次，或者当 CPU 使用率降低到某个标准下去检测。考虑到 CPU 效率的原因，如果死锁进程达到一定数量，就没有多少进程可以运行，所以 CPU 会经常空闲。\u003c/span\u003e\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"6488c6772dd853d8292d2e105a388286\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003ch3 id=\"95bdbdb5\"\u003e\u003cspan class=\"ne-text\"\u003e从死锁中恢复\u003c/span\u003e\u003c/h3\u003e\u003cp id=\"a374c9f6b0536b99e76dc7d380d5ad4d\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"6c6fa66bb994f4b13767e0758e7bc15b\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e上面我们探讨了如何检测进程死锁，我们最终的目的肯定是想让程序能够正常的运行下去，所以针对检测出来的死锁，我们要对其进行恢复，下面我们会探讨几种死锁的恢复方式\u003c/span\u003e\u003c/p\u003e\u003cp id=\"17c663707ef8dd6df4ca3362d812f340\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003ch4 id=\"82459936\"\u003e\u003cspan class=\"ne-text\"\u003e通过抢占进行恢复\u003c/span\u003e\u003c/h4\u003e\u003cp id=\"8611e726a4b51bbc2a2a73b2584f2cf4\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"b09a07bd4466a6494cae3cb7b5f3487c\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e在某些情况下，可能会临时将某个资源从它的持有者转移到另一个进程。比如在不通知原进程的情况下，将某个资源从进程中强制取走给其他进程使用，使用完后又送回。这种恢复方式一般比较困难而且有些简单粗暴，并不可取。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"9db11e547d3327df9fd8150582728d11\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003ch4 id=\"48c12fe7\"\u003e\u003cspan class=\"ne-text\"\u003e通过回滚进行恢复\u003c/span\u003e\u003c/h4\u003e\u003cp id=\"7c6c5b54d8c697c690324a6fa94cdf41\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"718e20e97011e6148925c731421cd028\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e如果系统设计者和机器操作员知道有可能发生死锁，那么就可以定期检查流程。进程的检测点意味着进程的状态可以被写入到文件以便后面进行恢复。检测点不仅包含\u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e存储映像(memory image)\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e，还包含\u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e资源状态(resource state)\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e。一种更有效的解决方式是不要覆盖原有的检测点，而是每出现一个检测点都要把它写入到文件中，这样当进程执行时，就会有一系列的检查点文件被累积起来。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"339f29e4c95b23688e573aa6483a9909\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"600363987ac3776bc472e109917d4090\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e为了进行恢复，要从上一个较早的检查点上开始，这样所需要资源的进程会回滚到上一个时间点，在这个时间点上，死锁进程还没有获取所需要的资源，可以在此时对其进行资源分配。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"2d8e54e18dce59911f57770e4ea8f824\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003ch4 id=\"ec735624\"\u003e\u003cspan class=\"ne-text\"\u003e杀死进程恢复\u003c/span\u003e\u003c/h4\u003e\u003cp id=\"b10cebb135de327c0a84909c0003ab1f\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"1c29d7da30e23b9c755589852bb6efe3\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e最简单有效的解决方案是直接杀死一个死锁进程。但是杀死一个进程可能照样行不通，这时候就需要杀死别的资源进行恢复。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"4665eae3b27d917878b8ac71b95d7352\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"b4068288f1099860bf4bef3010a9cc89\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e另外一种方式是选择一个环外的进程作为牺牲品来释放进程资源。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"1bb34cd91b0412e04dc1a611adbc6be6\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003ch2 id=\"9f401114\"\u003e\u003cspan class=\"ne-text\"\u003e死锁避免\u003c/span\u003e\u003c/h2\u003e\u003cp id=\"d96231a65e2b63d55b620a5f9679a5f5\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"460e408b4f85f86b4fc5ffc9c3cabaaa\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e我们上面讨论的是如何检测出现死锁和如何恢复死锁，下面我们探讨几种规避死锁的方式\u003c/span\u003e\u003c/p\u003e\u003cp id=\"e2769cc5a198cfa247c1b1e14580c945\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003ch3 id=\"221804d8\"\u003e\u003cspan class=\"ne-text\"\u003e单个资源的银行家算法\u003c/span\u003e\u003c/h3\u003e\u003cp id=\"e89b2e891d5b7f70257c4553152b1789\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"59b8da1dc357e739ca2d3879ad6138c5\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e银行家算法是 Dijkstra 在 1965 年提出的一种调度算法，它本身是一种死锁的调度算法。它的模型是基于一个城镇中的银行家，银行家向城镇中的客户承诺了一定数量的贷款额度。算法要做的就是判断请求是否会进入一种不安全的状态。如果是，就拒绝请求，如果请求后系统是安全的，就接受该请求。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"41faefa6584da64f07618f4036a158d8\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"7507faed5c63e725af97d762eaec96b0\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e类似的，还有多个资源的银行家算法，读者可以自行了解。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"c6c2f8962b34bd84d67b6adae75e4c47\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003ch2 id=\"1c662b9c\"\u003e\u003cspan class=\"ne-text\"\u003e破坏死锁\u003c/span\u003e\u003c/h2\u003e\u003cp id=\"1042b3632351757a6665bfb3b2cab55c\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"614019792c2d83e0b74de617146216f2\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e死锁本质上是无法避免的，因为它需要获得未知的资源和请求，但是死锁是满足四个条件后才出现的，它们分别是\u003c/span\u003e\u003c/p\u003e\u003cp id=\"342083631481cc21a58439f88448ba23\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cul class=\"ne-ul\"\u003e\u003cli id=\"7f073eb63fdf3296f66785047892f3da\"\u003e\u003cspan class=\"ne-text\"\u003e互斥\u003c/span\u003e\u003c/li\u003e\u003cli id=\"8ec9e0fc4c8a1ce01e825d8cb74487f5\"\u003e\u003cspan class=\"ne-text\"\u003e保持和等待\u003c/span\u003e\u003c/li\u003e\u003c/ul\u003e\u003cul class=\"ne-ul\"\u003e\u003cli id=\"3243ef42ffbe01b313da032f2182b94e\"\u003e\u003cspan class=\"ne-text\"\u003e不可抢占\u003c/span\u003e\u003c/li\u003e\u003cli id=\"d45e0cad6dc74d87e3c08fec2ee0f8d8\"\u003e\u003cspan class=\"ne-text\"\u003e循环等待\u003c/span\u003e\u003c/li\u003e\u003c/ul\u003e\u003cp id=\"fe59f031b5ed305654906780fa2edef6\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"7177a34bdca01a41d03870d15ba1e6a8\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e我们分别对这四个条件进行讨论，按理说破坏其中的任意一个条件就能够破坏死锁\u003c/span\u003e\u003c/p\u003e\u003cp id=\"c27bcda5e1b8bdec4067b11fcc6c05d8\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003ch3 id=\"48c312fb\"\u003e\u003cspan class=\"ne-text\"\u003e破坏互斥条件\u003c/span\u003e\u003c/h3\u003e\u003cp id=\"26613ade80fc258b9f36f537ecc823f0\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"d10c8076c6a1afdc5be18d3da29045a0\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e我们首先考虑的就是\u003c/span\u003e\u003cstrong\u003e\u003cspan class=\"ne-text\"\u003e破坏互斥使用条件\u003c/span\u003e\u003c/strong\u003e\u003cspan class=\"ne-text\"\u003e。如果资源不被一个进程独占，那么死锁肯定不会产生。如果两个打印机同时使用一个资源会造成混乱，打印机的解决方式是使用 \u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e假脱机打印机(spooling printer)\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e ，这项技术可以允许多个进程同时产生输出，在这种模型中，实际请求打印机的唯一进程是打印机守护进程，也称为后台进程。后台进程不会请求其他资源。我们可以消除打印机的死锁。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"0075a1624d67b11ba8d15ed77b0e1b7b\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"4bf1551f195c5c46cf38ed105690a369\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e后台进程通常被编写为能够输出完整的文件后才能打印，假如两个进程都占用了假脱机空间的一半，而这两个进程都没有完成全部的输出，就会导致死锁。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"fa76008afa94ebc89b5a16b2f22cd27c\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"4709a3f6c7bb8468e3d0556402b77cd3\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e因此，尽量做到尽可能少的进程可以请求资源。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"95cb9bb0e7f02afb35945ffbb03cb13b\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003ch3 id=\"1ce8619b\"\u003e\u003cspan class=\"ne-text\"\u003e破坏保持等待的条件\u003c/span\u003e\u003c/h3\u003e\u003cp id=\"a0402a5e468f049bcea75885f6bdb094\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"59a68622dc4bdac082e2cf8505d3a8a3\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e第二种方式是如果我们能阻止持有资源的进程请求其他资源，我们就能够消除死锁。一种实现方式是让所有的进程开始执行前请求全部的资源。如果所需的资源可用，进程会完成资源的分配并运行到结束。如果有任何一个资源处于频繁分配的情况，那么没有分配到资源的进程就会等待。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"cc80a0d7d7adc5e15d896ab15932e1d9\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"44f4b6bc44f660cc6ec2cb66a0dcab09\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e很多进程\u003c/span\u003e\u003cstrong\u003e\u003cspan class=\"ne-text\"\u003e无法在执行完成前就知道到底需要多少资源\u003c/span\u003e\u003c/strong\u003e\u003cspan class=\"ne-text\"\u003e，如果知道的话，就可以使用银行家算法；还有一个问题是这样\u003c/span\u003e\u003cstrong\u003e\u003cspan class=\"ne-text\"\u003e无法合理有效利用资源\u003c/span\u003e\u003c/strong\u003e\u003cspan class=\"ne-text\"\u003e。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"cb584b7d098165ccd9f854d4403c81a7\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"e4c08e27eb55f0691ba9869f7d983987\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e还有一种方式是进程在请求其他资源时，先释放所占用的资源，然后再尝试一次获取全部的资源。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"b1b1836523c7189c11cdf7b4a834cab5\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003ch3 id=\"d83055ce\"\u003e\u003cspan class=\"ne-text\"\u003e破坏不可抢占条件\u003c/span\u003e\u003c/h3\u003e\u003cp id=\"83056be73110a576565be358f73dc447\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"d095796526d11fc7b3a879f40f8b76af\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e破坏不可抢占条件也是可以的。可以通过虚拟化的方式来避免这种情况。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"595c68731aa3abbd5a09a8c780c2c6fb\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003ch3 id=\"75513240\"\u003e\u003cspan class=\"ne-text\"\u003e破坏循环等待条件\u003c/span\u003e\u003c/h3\u003e\u003cp id=\"2cce5860fcb20508493132ff4d52c8e7\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"6bd78a1878c0b44133e8615952a7b6cd\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e现在就剩最后一个条件了，循环等待条件可以通过多种方法来破坏。一种方式是制定一个标准，一个进程在任何时候只能使用一种资源。如果需要另外一种资源，必须释放当前资源。对于需要将大文件从磁带复制到打印机的过程，此限制是不可接受的。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"3e6e2f47972b8cfddb751b8b98fd4e57\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"ff2b35f6c8e9a28f1b38326659b83623\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e另一种方式是将所有的资源统一编号，如下图所示\u003c/span\u003e\u003c/p\u003e\u003cp id=\"c009095ac315c19ae85c392536222bb8\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"719cfd06171e090674e6588ea72e2514\" class=\"ne-p\"\u003e\u003cimg src=\"https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830860-d72b0344-264f-4bfe-91f7-43d5b4121f58.png\" width=\"419\" id=\"Nm5h1\" class=\"ne-image\"\u003e\u003c/p\u003e\u003cp id=\"378b45679e11bbc4ae4cbb1bb07f051b\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"4d406e8ec640206937c30f4f87d1e0df\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e进程可以在任何时间提出请求，但是所有的请求都必须按照资源的顺序提出。如果按照此分配规则的话，那么资源分配之间不会出现环。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"33a3a40e0e4503fb2a58f13489a613ad\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"d0388e319759e7f357c45d4e95179c2e\" class=\"ne-p\"\u003e\u003cimg src=\"https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830858-19d66189-e808-4999-879e-3e2e8d4273f0.png\" width=\"423\" id=\"xulHt\" class=\"ne-image\"\u003e\u003c/p\u003e\u003cp id=\"8c42c0e89584a6d912c13ee84ca0d1da\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"998a94d4e63eda812da79b5f56e93eea\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e尽管通过这种方式来消除死锁，但是编号的顺序不可能让每个进程都会接受。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"65f5a9bf2b2f3359e44646086bf6db51\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003ch2 id=\"bf52b411\"\u003e\u003cspan class=\"ne-text\"\u003e其他问题\u003c/span\u003e\u003c/h2\u003e\u003cp id=\"3b41d963203b64c7498fc565603991b5\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"d91adc7b4ff6e74ed3b09939b40132d8\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e下面我们来探讨一下其他问题，包括 \u003c/span\u003e\u003cstrong\u003e\u003cspan class=\"ne-text\"\u003e通信死锁、活锁是什么、饥饿问题和两阶段加锁\u003c/span\u003e\u003c/strong\u003e\u003c/p\u003e\u003cp id=\"48288ba7fbb610cf326cedc0d9f0f6d7\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003ch3 id=\"e8230499\"\u003e\u003cspan class=\"ne-text\"\u003e两阶段加锁\u003c/span\u003e\u003c/h3\u003e\u003cp id=\"1e34b78f13fa6ccb27f3e79ce5525ea9\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"9a404aeba16fe407449e9620f8e60b5a\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e虽然很多情况下死锁的避免和预防都能处理，但是效果并不好。随着时间的推移，提出了很多优秀的算法用来处理死锁。例如在数据库系统中，一个经常发生的操作是请求锁住一些记录，然后更新所有锁定的记录。当同时有多个进程运行时，就会有死锁的风险。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"31bbdd311778f49d2f23e1b5f99582fb\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"6a87b8d5f0df4dfddf9222397284816e\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e一种解决方式是使用 \u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e两阶段提交(two-phase locking)\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e。顾名思义分为两个阶段，一阶段是进程尝试一次锁定它需要的所有记录。如果成功后，才会开始第二阶段，第二阶段是执行更新并释放锁。第一阶段并不做真正有意义的工作。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"5b1b66cb117a5aa66675875203023dc1\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"d0a72b442ed8f3bf7c655ddef2038559\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e如果在第一阶段某个进程所需要的记录已经被加锁，那么该进程会释放所有锁定的记录并重新开始第一阶段。从某种意义上来说，这种方法类似于预先请求所有必需的资源或者是在进行一些不可逆的操作之前请求所有的资源。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"6d0daef74b5849a82b735e9072ff2277\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"40ca79e448a5b8410caca0b328fa6ae5\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e不过在一般的应用场景中，两阶段加锁的策略并不通用。如果一个进程缺少资源就会半途中断并重新开始的方式是不可接受的。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"a93254cb959a97f440ed888fe197b863\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003ch3 id=\"44d2b9b0\"\u003e\u003cspan class=\"ne-text\"\u003e通信死锁\u003c/span\u003e\u003c/h3\u003e\u003cp id=\"2130ade79d2e280cb7ddd6f93f606bae\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"64776094a4eeb9c963f8960bfdd20280\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e我们上面一直讨论的是资源死锁，资源死锁是一种死锁类型，但并不是唯一类型，还有通信死锁，也就是两个或多个进程在发送消息时出现的死锁。进程 A 给进程 B 发了一条消息，然后进程 A 阻塞直到进程 B 返回响应。假设请求消息丢失了，那么进程 A 在一直等着回复，进程 B 也会阻塞等待请求消息到来，这时候就产生\u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e死锁\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"7b2dca72612d5432be0e4378ee44b636\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"40989330fbee6643a7ebeab9d1b7f7e8\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e尽管会产生死锁，但是这并不是一个资源死锁，因为 A 并没有占据 B 的资源。事实上，通信死锁并没有完全可见的资源。根据死锁的定义来说：每个进程因为等待其他进程引起的事件而产生阻塞，这就是一种死锁。相较于最常见的通信死锁，我们把上面这种情况称为\u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e通信死锁(communication deadlock)\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"0cde873bd73f03c66e1e81dfabb9ecff\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"14dbb722a2f2fd6709732ca83eedd397\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e通信死锁不能通过调度的方式来避免，但是可以使用通信中一个非常重要的概念来避免：\u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e超时(timeout)\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e。在通信过程中，只要一个信息被发出后，发送者就会启动一个定时器，定时器会记录消息的超时时间，如果超时时间到了但是消息还没有返回，就会认为消息已经丢失并重新发送，通过这种方式，可以避免通信死锁。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"05e534c4b272054adbc3e743bbb87ed5\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"ebad5559c5e8228b7c32bd7e22a53fcc\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e但是并非所有网络通信发生的死锁都是通信死锁，也存在资源死锁，下面就是一个典型的资源死锁。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"43db3302928da79ca9d4847a52057335\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"d2066eecb8a130f79bde31d4bc952698\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e当一个数据包从主机进入路由器时，会被放入一个缓冲区，然后再传输到另外一个路由器，再到另一个，以此类推直到目的地。缓冲区都是资源并且数量有限。如下图所示，每个路由器都有 10 个缓冲区（实际上有很多）。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"fd8d6b4496f962959fbda6d31e8fe14a\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"4605b8d7affea0247962f50ca34605a0\" class=\"ne-p\"\u003e\u003cimg src=\"https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830887-98d92f9c-72d1-4710-a487-1bd4dc953b7c.png\" width=\"702\" id=\"JN6QA\" class=\"ne-image\"\u003e\u003c/p\u003e\u003cp id=\"3cc175c53ce850923dd266c70fa2d2da\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"404a0deda9c033b83ccdd5f1e1085499\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e假如路由器 A 的所有数据需要发送到 B ，B 的所有数据包需要发送到 D，然后 D 的所有数据包需要发送到 A 。没有数据包可以移动，因为在另一端没有缓冲区可用，这就是一个典型的资源死锁。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"c619f7fb9d739d143fbd13aed16af5e1\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003ch3 id=\"94c14e72\"\u003e\u003cspan class=\"ne-text\"\u003e活锁\u003c/span\u003e\u003c/h3\u003e\u003cp id=\"d58bf9c2b4a5f6bbecbf4b7136473e80\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"4cf25a1c790a47e1298e729b06421709\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e某些情况下，当进程意识到它不能获取所需要的下一个锁时，就会尝试礼貌的释放已经获得的锁，然后等待非常短的时间再次尝试获取。可以想像一下这个场景：当两个人在狭路相逢的时候，都想给对方让路，相同的步调会导致双方都无法前进。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"65625d90055aa1173e9f493729a8a70a\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"38424978488c1ad9578cd5c604bd379c\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e现在假想有一对并行的进程用到了两个资源。它们分别尝试获取另一个锁失败后，两个进程都会释放自己持有的锁，再次进行尝试，这个过程会一直进行重复。很明显，这个过程中没有进程阻塞，但是进程仍然不会向下执行，这种状况我们称之为 \u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e活锁(livelock)\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"2772a3ba2c19ab0d95902ec3f6f3fc3d\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003ch3 id=\"48073fce\"\u003e\u003cspan class=\"ne-text\"\u003e饥饿\u003c/span\u003e\u003c/h3\u003e\u003cp id=\"d44dc6d0b955b9b3194082ba392239a7\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"d089c608be88bd00f0435afcf9fedf5b\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e与死锁和活锁的一个非常相似的问题是 \u003c/span\u003e\u003ccode class=\"ne-code\"\u003e\u003cspan class=\"ne-text\"\u003e饥饿(starvvation)\u003c/span\u003e\u003c/code\u003e\u003cspan class=\"ne-text\"\u003e。想象一下你什么时候会饿？一段时间不吃东西是不是会饿？对于进程来讲，最重要的就是资源，如果一段时间没有获得资源，那么进程会产生饥饿，这些进程会永远得不到服务。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"2cbb310b9cbe820deb2a9140fd73b7b2\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003cp id=\"2ae27778a42bd6691929243288b93f65\" class=\"ne-p\"\u003e\u003cspan class=\"ne-text\"\u003e我们假设打印机的分配方案是每次都会分配给最小文件的进程，那么要打印大文件的进程会永远得不到服务，导致进程饥饿，进程会无限制的推后，虽然它没有阻塞。\u003c/span\u003e\u003c/p\u003e\u003cp id=\"31731cb931d8de3f4bb18fd8da9bc111\" class=\"ne-p\"\u003e\u003cbr\u003e\u003c/p\u003e\u003c/div\u003e"])</script><script>self.__next_f.push([1,"dc:[\"$\",\"section\",null,{\"className\":\"relative\",\"children\":[\"$\",\"$Le9\",null,{\"fade\":true,\"blur\":true,\"transition\":{\"duration\":0.5},\"delay\":0.1,\"className\":\"relative overflow-hidden border-y xl:flex\",\"children\":[[\"$\",\"div\",null,{\"className\":\"m-6 w-full flex-1 bg-[radial-gradient(circle_at_center,color-mix(in_oklab,var(--primary)_15%,transparent)_2px,transparent_2px)] bg-size-[18px_18px] max-xl:hidden\"}],[\"$\",\"div\",null,{\"className\":\"mx-auto w-full max-w-6xl flex-none space-y-8 px-4 py-8 min-[1158px]:border-x sm:px-6 sm:py-12 lg:px-8\",\"children\":[[\"$\",\"$Le9\",null,{\"fade\":true,\"blur\":true,\"slide\":{\"direction\":\"down\",\"offset\":30},\"transition\":{\"duration\":0.4},\"children\":[\"$\",\"$L73\",null,{\"href\":\"/blog\",\"className\":\"text-muted-foreground hover:text-foreground inline-flex items-center gap-2 text-sm transition-colors\",\"children\":[[\"$\",\"svg\",null,{\"ref\":\"$undefined\",\"xmlns\":\"http://www.w3.org/2000/svg\",\"width\":24,\"height\":24,\"viewBox\":\"0 0 24 24\",\"fill\":\"none\",\"stroke\":\"currentColor\",\"strokeWidth\":2,\"strokeLinecap\":\"round\",\"strokeLinejoin\":\"round\",\"className\":\"lucide lucide-arrow-left h-4 w-4\",\"aria-hidden\":\"true\",\"children\":[[\"$\",\"path\",\"1l729n\",{\"d\":\"m12 19-7-7 7-7\"}],[\"$\",\"path\",\"x3x0zl\",{\"d\":\"M19 12H5\"}],\"$undefined\"]}],\"返回\",\"技术博客\"]}]}],[\"$\",\"article\",null,{\"className\":\"mx-auto max-w-4xl\",\"children\":[[\"$\",\"header\",null,{\"className\":\"mb-8 space-y-6\",\"children\":[[\"$\",\"$Le9\",null,{\"fade\":true,\"blur\":true,\"slide\":{\"direction\":\"up\",\"offset\":50},\"delay\":0.2,\"transition\":{\"duration\":0.6},\"children\":[\"$\",\"div\",null,{\"className\":\"relative aspect-video overflow-hidden rounded-xl\",\"children\":[\"$\",\"$Lea\",null,{\"src\":\"https://cdn.nlark.com/yuque/0/2021/svg/1484158/1609726829272-e77b939e-eefd-4282-8f0a-68c97aa7dfe5.svg\",\"alt\":\"[转]操作系统核心知识点\",\"fill\":true,\"className\":\"object-cover\",\"unoptimized\":true}]}]}],[\"$\",\"$Le9\",null,{\"delay\":0.3,\"transition\":{\"duration\":0.5},\"children\":[\"$\",\"h1\",null,{\"className\":\"text-2xl font-bold tracking-tight sm:text-3xl md:text-4xl\",\"children\":[\"$\",\"$Leb\",null,{\"text\":\"[转]操作系统核心知识点\",\"delay\":30,\"animateBy\":\"words\",\"direction\":\"bottom\"}]}]}],[\"$\",\"$Le9\",null,{\"fade\":true,\"blur\":true,\"slide\":{\"direction\":\"down\",\"offset\":30},\"delay\":0.4,\"transition\":{\"duration\":0.5},\"children\":[\"$\",\"p\",null,{\"className\":\"text-muted-foreground text-lg\",\"children\":\"本文转载自：5万字、97 张图总结操作系统核心知识点 - 程序员cxuan - 博客园部分内容自行添加这不是一篇教你如何创建一个操作系统的文章，相反，这是一篇指导性文章，教你从几个方面来理解操作系统。首先你需要知道你为什么要看这篇文章以及为什么要学习操作系统。搞清楚几个问题首先你要搞明白你学习...\"}]}],[\"$\",\"$Le9\",null,{\"fade\":true,\"blur\":true,\"slide\":{\"direction\":\"down\",\"offset\":30},\"delay\":0.5,\"transition\":{\"duration\":0.5},\"children\":[\"$\",\"div\",null,{\"className\":\"text-muted-foreground flex flex-wrap items-center gap-4 text-sm\",\"children\":[[\"$\",\"div\",null,{\"className\":\"flex items-center gap-1\",\"children\":[[\"$\",\"svg\",null,{\"ref\":\"$undefined\",\"xmlns\":\"http://www.w3.org/2000/svg\",\"width\":24,\"height\":24,\"viewBox\":\"0 0 24 24\",\"fill\":\"none\",\"stroke\":\"currentColor\",\"strokeWidth\":2,\"strokeLinecap\":\"round\",\"strokeLinejoin\":\"round\",\"className\":\"lucide lucide-calendar h-4 w-4\",\"aria-hidden\":\"true\",\"children\":[[\"$\",\"path\",\"1cmpym\",{\"d\":\"M8 2v4\"}],[\"$\",\"path\",\"4m81vk\",{\"d\":\"M16 2v4\"}],[\"$\",\"rect\",\"1hopcy\",{\"width\":\"18\",\"height\":\"18\",\"x\":\"3\",\"y\":\"4\",\"rx\":\"2\"}],[\"$\",\"path\",\"8toen8\",{\"d\":\"M3 10h18\"}],\"$undefined\"]}],[\"$\",\"span\",null,{\"children\":\"2020年8月29日\"}]]}],[\"$\",\"div\",null,{\"className\":\"flex items-center gap-1\",\"children\":[[\"$\",\"svg\",null,{\"ref\":\"$undefined\",\"xmlns\":\"http://www.w3.org/2000/svg\",\"width\":24,\"height\":24,\"viewBox\":\"0 0 24 24\",\"fill\":\"none\",\"stroke\":\"currentColor\",\"strokeWidth\":2,\"strokeLinecap\":\"round\",\"strokeLinejoin\":\"round\",\"className\":\"lucide lucide-clock h-4 w-4\",\"aria-hidden\":\"true\",\"children\":[[\"$\",\"path\",\"mmk7yg\",{\"d\":\"M12 6v6l4 2\"}],[\"$\",\"circle\",\"1mglay\",{\"cx\":\"12\",\"cy\":\"12\",\"r\":\"10\"}],\"$undefined\"]}],[\"$\",\"span\",null,{\"children\":\"4.5万字\"}]]}],[\"$\",\"div\",null,{\"className\":\"flex items-center gap-1\",\"children\":[[\"$\",\"svg\",null,{\"ref\":\"$undefined\",\"xmlns\":\"http://www.w3.org/2000/svg\",\"width\":24,\"height\":24,\"viewBox\":\"0 0 24 24\",\"fill\":\"none\",\"stroke\":\"currentColor\",\"strokeWidth\":2,\"strokeLinecap\":\"round\",\"strokeLinejoin\":\"round\",\"className\":\"lucide lucide-eye h-4 w-4\",\"aria-hidden\":\"true\",\"children\":[[\"$\",\"path\",\"1nclc0\",{\"d\":\"M2.062 12.348a1 1 0 0 1 0-.696 10.75 10.75 0 0 1 19.876 0 1 1 0 0 1 0 .696 10.75 10.75 0 0 1-19.876 0\"}],[\"$\",\"circle\",\"1v7zrd\",{\"cx\":\"12\",\"cy\":\"12\",\"r\":\"3\"}],\"$undefined\"]}],[\"$\",\"span\",null,{\"children\":[16,\" 阅读\"]}]]}],false,false]}]}],false]}],[\"$\",\"$Le9\",null,{\"delay\":0.6,\"fade\":true,\"blur\":true,\"transition\":{\"duration\":0.6},\"className\":\"-mx-4 sm:-mx-6 lg:-mx-8\",\"children\":[\"$\",\"$Lec\",null,{}]}],[\"$\",\"$Le9\",null,{\"fade\":true,\"blur\":true,\"slide\":{\"direction\":\"up\",\"offset\":50},\"delay\":0.7,\"transition\":{\"duration\":0.6},\"children\":[\"$\",\"div\",null,{\"className\":\"prose prose-neutral dark:prose-invert mt-8 max-w-none\",\"dangerouslySetInnerHTML\":{\"__html\":\"$ed\"}}]}],\"$Lee\",\"$Lef\"]}]]}],\"$Lf0\"]}]}]\n"])</script><script>self.__next_f.push([1,"ee:[\"$\",\"$Le9\",null,{\"delay\":0.8,\"fade\":true,\"blur\":true,\"transition\":{\"duration\":0.6},\"className\":\"-mx-4 mt-12 sm:-mx-6 lg:-mx-8\",\"children\":[\"$\",\"$Lec\",null,{}]}]\nef:[\"$\",\"$Le9\",null,{\"fade\":true,\"blur\":true,\"slide\":{\"direction\":\"up\",\"offset\":30},\"delay\":0.9,\"transition\":{\"duration\":0.5},\"children\":[\"$\",\"nav\",null,{\"className\":\"mt-8 grid gap-4 md:grid-cols-2\",\"children\":[[\"$\",\"$L73\",null,{\"href\":\"/blog/apohu8\",\"className\":\"hover:bg-muted group flex flex-col rounded-lg border p-4 transition-colors\",\"children\":[[\"$\",\"span\",null,{\"className\":\"text-muted-foreground mb-2 text-sm\",\"children\":\"上一篇\"}],[\"$\",\"span\",null,{\"className\":\"group-hover:text-primary line-clamp-2 font-medium transition-colors\",\"children\":\"ANN神经网络\"}]]}],[\"$\",\"$L73\",null,{\"href\":\"/blog/nvlr2g\",\"className\":\"hover:bg-muted group flex flex-col rounded-lg border p-4 text-right transition-colors md:text-right\",\"children\":[[\"$\",\"span\",null,{\"className\":\"text-muted-foreground mb-2 text-sm\",\"children\":\"下一篇\"}],[\"$\",\"span\",null,{\"className\":\"group-hover:text-primary line-clamp-2 font-medium transition-colors\",\"children\":\"常用软件快捷键/CMD/Linux命令及其他使用\"}]]}]]}]}]\nf0:[\"$\",\"div\",null,{\"className\":\"m-6 w-full flex-1 bg-[radial-gradient(circle_at_center,color-mix(in_oklab,var(--primary)_15%,transparent)_2px,transparent_2px)] bg-size-[18px_18px] max-xl:hidden\"}]\n"])</script><script>self.__next_f.push([1,"e1:[[\"$\",\"meta\",\"0\",{\"charSet\":\"utf-8\"}],[\"$\",\"meta\",\"1\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}]]\n"])</script><script>self.__next_f.push([1,"f1:I[27201,[\"/_next/static/chunks/ff1a16fafef87110.js\",\"/_next/static/chunks/7340adf74ff47ec0.js\"],\"IconMark\"]\ndf:null\n"])</script><script>self.__next_f.push([1,"e3:[[\"$\",\"title\",\"0\",{\"children\":\"[转]操作系统核心知识点 | 尼采般地抒情\"}],[\"$\",\"meta\",\"1\",{\"name\":\"description\",\"content\":\"本文转载自：5万字、97 张图总结操作系统核心知识点 - 程序员cxuan - 博客园部分内容自行添加这不是一篇教你如何创建一个操作系统的文章，相反，这是一篇指导性文章，教你从几个方面来理解操作系统。首先你需要知道你为什么要看这篇文章以及为什么要学习操作系统。搞清楚几个问题首先你要搞明白你学习...\"}],[\"$\",\"link\",\"2\",{\"rel\":\"manifest\",\"href\":\"/manifest.json\",\"crossOrigin\":\"$undefined\"}],[\"$\",\"meta\",\"3\",{\"name\":\"keywords\",\"content\":\"portfolio,creative portfolio,web developer,designer,next.js portfolio,尼采般地抒情 portfolio,projects showcase,professional services,web design,ui/ux design,landing page,modern portfolio\"}],[\"$\",\"meta\",\"4\",{\"name\":\"referrer\",\"content\":\"no-referrer\"}],[\"$\",\"meta\",\"5\",{\"name\":\"robots\",\"content\":\"index,follow\"}],[\"$\",\"meta\",\"6\",{\"property\":\"og:title\",\"content\":\"[转]操作系统核心知识点 | 尼采般地抒情\"}],[\"$\",\"meta\",\"7\",{\"property\":\"og:description\",\"content\":\"本文转载自：5万字、97 张图总结操作系统核心知识点 - 程序员cxuan - 博客园部分内容自行添加这不是一篇教你如何创建一个操作系统的文章，相反，这是一篇指导性文章，教你从几个方面来理解操作系统。首先你需要知道你为什么要看这篇文章以及为什么要学习操作系统。搞清楚几个问题首先你要搞明白你学习...\"}],[\"$\",\"meta\",\"8\",{\"property\":\"og:image\",\"content\":\"https://cdn.nlark.com/yuque/0/2021/svg/1484158/1609726829272-e77b939e-eefd-4282-8f0a-68c97aa7dfe5.svg\"}],[\"$\",\"meta\",\"9\",{\"name\":\"twitter:card\",\"content\":\"summary_large_image\"}],[\"$\",\"meta\",\"10\",{\"name\":\"twitter:title\",\"content\":\"尼采般地抒情\"}],[\"$\",\"meta\",\"11\",{\"name\":\"twitter:description\",\"content\":\"Explore my creative portfolio showcasing innovative projects, design work, and professional services. Built with Next.js and modern web technologies for an exceptional user experience.\"}],[\"$\",\"meta\",\"12\",{\"name\":\"twitter:image\",\"content\":\"https://cdn.nlark.com/yuque/0/2021/svg/1484158/1609726829272-e77b939e-eefd-4282-8f0a-68c97aa7dfe5.svg\"}],[\"$\",\"link\",\"13\",{\"rel\":\"icon\",\"href\":\"/favicon/favicon-16x16.png\",\"sizes\":\"16x16\",\"type\":\"image/png\"}],[\"$\",\"link\",\"14\",{\"rel\":\"icon\",\"href\":\"/favicon/favicon-32x32.png\",\"sizes\":\"32x32\",\"type\":\"image/png\"}],[\"$\",\"link\",\"15\",{\"rel\":\"icon\",\"href\":\"/favicon/favicon.ico\",\"sizes\":\"48x48\",\"type\":\"image/x-icon\"}],[\"$\",\"link\",\"16\",{\"rel\":\"apple-touch-icon\",\"href\":\"/favicon/apple-touch-icon.png\",\"sizes\":\"180x180\",\"type\":\"image/png\"}],[\"$\",\"link\",\"17\",{\"rel\":\"icon\",\"href\":\"/favicon/android-chrome-192x192.png\",\"sizes\":\"192x192\",\"type\":\"image/png\"}],[\"$\",\"link\",\"18\",{\"rel\":\"icon\",\"href\":\"/favicon/android-chrome-512x512.png\",\"sizes\":\"512x512\",\"type\":\"image/png\"}],[\"$\",\"$Lf1\",\"19\",{}]]\n"])</script></body></html>