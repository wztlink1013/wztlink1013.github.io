1:"$Sreact.fragment"
2:I[99897,["/_next/static/chunks/4eaa70fe861e9598.js","/_next/static/chunks/fa1a8f8830b9bf3a.js","/_next/static/chunks/6dd6809ee42e252f.js","/_next/static/chunks/f2b800ca7ae14e96.js","/_next/static/chunks/e121db38c98deeb4.js","/_next/static/chunks/6d971f5a9c16d0c2.js","/_next/static/chunks/b397c2fd2abb1207.js","/_next/static/chunks/11dff99839ab5ba0.js"],"MotionPreset"]
3:I[22016,["/_next/static/chunks/4eaa70fe861e9598.js","/_next/static/chunks/fa1a8f8830b9bf3a.js","/_next/static/chunks/6dd6809ee42e252f.js","/_next/static/chunks/f2b800ca7ae14e96.js","/_next/static/chunks/e121db38c98deeb4.js","/_next/static/chunks/6d971f5a9c16d0c2.js","/_next/static/chunks/b397c2fd2abb1207.js","/_next/static/chunks/11dff99839ab5ba0.js"],""]
4:I[85437,["/_next/static/chunks/4eaa70fe861e9598.js","/_next/static/chunks/fa1a8f8830b9bf3a.js","/_next/static/chunks/6dd6809ee42e252f.js","/_next/static/chunks/f2b800ca7ae14e96.js","/_next/static/chunks/e121db38c98deeb4.js","/_next/static/chunks/6d971f5a9c16d0c2.js","/_next/static/chunks/b397c2fd2abb1207.js","/_next/static/chunks/11dff99839ab5ba0.js"],"Image"]
5:I[48347,["/_next/static/chunks/4eaa70fe861e9598.js","/_next/static/chunks/fa1a8f8830b9bf3a.js","/_next/static/chunks/6dd6809ee42e252f.js","/_next/static/chunks/f2b800ca7ae14e96.js","/_next/static/chunks/e121db38c98deeb4.js","/_next/static/chunks/6d971f5a9c16d0c2.js","/_next/static/chunks/b397c2fd2abb1207.js","/_next/static/chunks/11dff99839ab5ba0.js"],"default"]
6:I[72436,["/_next/static/chunks/4eaa70fe861e9598.js","/_next/static/chunks/fa1a8f8830b9bf3a.js","/_next/static/chunks/6dd6809ee42e252f.js","/_next/static/chunks/f2b800ca7ae14e96.js","/_next/static/chunks/e121db38c98deeb4.js","/_next/static/chunks/6d971f5a9c16d0c2.js","/_next/static/chunks/b397c2fd2abb1207.js","/_next/static/chunks/11dff99839ab5ba0.js"],"Separator"]
d:I[97367,["/_next/static/chunks/ff1a16fafef87110.js","/_next/static/chunks/7340adf74ff47ec0.js"],"OutletBoundary"]
e:"$Sreact.suspense"
7:T66b2,<!doctype html><div class="lake-content" typography="classic"><p id="u9dfc8a71" class="ne-p"><span class="ne-text">前言：本文讲述前端代码从脚本全局函数时代到现代化模块引入时代的发展历程，再介绍构建工具对代码予以指定条件下的打包构建，最后利用vite打包工具打包一个可供多个环境使用的SDK的例子。</span></p><p id="ua273ed45" class="ne-p"><span class="ne-text"></span></p><h2 id="Mois5"><span class="ne-text">一、模块化演变历程</span></h2><h3 id="Rj0X5"><span class="ne-text">1.1 脚本全局函数</span></h3><div data-type="success" class="ne-alert"><p id="u733dbba2" class="ne-p"><span class="ne-text">在HTML页面所引入的脚本中定义函数，在浏览器执行脚本则可以使用脚本中所定义的全局函数</span></p></div><pre data-language="html" id="vCsmJ" class="ne-codeblock language-html"><code>&lt;body&gt;
  &lt;script&gt;
    const globalFun = () =&gt; {
      console.warn('this is globalFun');
    };
  &lt;/script&gt;
&lt;/body&gt;</code></pre><p id="udc6e94fe" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2024/png/1484158/1713682888934-ccbdc852-0125-4796-becb-deca844aad58.png" width="279.9999888738001" id="u44daa269" class="ne-image"></p><div data-type="danger" class="ne-alert"><p id="u534153bc" class="ne-p"><span class="ne-text">缺点： 污染全局命名空间, 容易引起命名冲突或数据不安全，而且模块成员之间看不出直接关系  </span></p></div><h3 id="YqDub"><span class="ne-text">1.2 namespace模式</span></h3><div data-type="success" class="ne-alert"><p id="u015d1aa4" class="ne-p"><span class="ne-text">通过命名空间来解决上述命名冲突的问题</span></p></div><pre data-language="html" id="LFYbk" class="ne-codeblock language-html"><code>&lt;body&gt;
  &lt;script&gt;
    const globalNameSpaceTest = {
      fun: () =&gt; {
        console.warn('this is globalNameSpaceTest');
      },
    };
  &lt;/script&gt;
&lt;/body&gt;</code></pre><p id="u2f933c3c" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2024/png/1484158/1713683164533-8a11c85b-caf3-48f1-a0d8-d3634a06ff87.png" width="400.83331740564836" id="u7f1a83e2" class="ne-image"></p><div data-type="danger" class="ne-alert"><p id="u88484269" class="ne-p"><span class="ne-text">缺点：</span></p><ul class="ne-ul"><li id="u2a74f41c" data-lake-index-type="0"><span class="ne-text">外部可以更改内部状态</span></li><li id="u08770818" data-lake-index-type="0"><span class="ne-text">所有模块代码都被暴露在外</span></li></ul></div><h3 id="B5VtJ"><span class="ne-text">1.3 IIFE (立即调用的函数表达式)</span></h3><p id="u3f177135" class="ne-p"><span class="ne-text">在JavaScript语言中，有一个立即执行函数，当脚本加载成功则执行所定义的函数。</span></p><pre data-language="html" id="m0r87" class="ne-codeblock language-html"><code>&lt;body&gt;
  &lt;script&gt;
    (function () {
      console.warn('IIFE code...');
      console.info(this);
      globalThis.IIFETestMoudle = {
        fun: () =&gt; {
          console.warn('some logic...');
        },
      };
    })();
  &lt;/script&gt;
&lt;/body&gt;</code></pre><p id="ud34a902e" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2024/png/1484158/1713683818953-4b3c0b5f-fab8-4877-8b3a-4ec34ab5f5b6.png" width="389.16665120257335" id="u8d2c58c4" class="ne-image"></p><div data-type="success" class="ne-alert"><p id="u452732e2" class="ne-p"><span class="ne-text">通过这种形式创建的模块可以自己独立的私有作用域</span></p></div><div data-type="danger" class="ne-alert"><p id="uf21edfa7" class="ne-p"><span class="ne-text">缺点：</span></p><ol class="ne-ol"><li id="u06d97ded" data-lake-index-type="0"><span class="ne-text">模块之间的依赖依旧不明确，依旧是挂载到全局宿主环境上</span></li></ol></div><h3 id="vxrce"><span class="ne-text">1.4 Commonjs</span></h3><p id="ubd46c94a" class="ne-p"><span class="ne-text">CommonJS是Node.js环境下的模块化规范</span></p><h4 id="YJf3k"><span class="ne-text">两种导出方式</span></h4><p id="ue38e07b7" class="ne-p"><span class="ne-text">第一种导出方式：</span></p><pre data-language="javascript" id="GBWiT" class="ne-codeblock language-javascript"><code>const fun = () =&gt; {
  console.warn(&quot;cjs fun...&quot;);
};
module.exports = fun;</code></pre><pre data-language="javascript" id="KjaGB" class="ne-codeblock language-javascript"><code>const moduleTest = require(&quot;./module-test&quot;);
console.log(moduleTest);</code></pre><p id="u3f8151f3" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2024/png/1484158/1713684727768-49bf85de-e18b-4246-8533-e7425833b351.png" width="477.4999810258555" id="u8b0798a6" class="ne-image"></p><p id="u11bec7f2" class="ne-p"><span class="ne-text">第二种方式：</span></p><pre data-language="javascript" id="P409p" class="ne-codeblock language-javascript"><code>const fun = () =&gt; {
  console.warn(&quot;cjs fun...&quot;);
};
module.exports.fun = fun;</code></pre><p id="ub0afcd13" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2024/png/1484158/1713684784746-a07ea600-35ce-4c6c-b3a3-ebd64f5fd551.png" width="487.49998062849124" id="uccdf9a15" class="ne-image"></p><div data-type="info" class="ne-alert"><p id="uf0ae6bca" class="ne-p"><span class="ne-text">上述两种方式都是对</span><code class="ne-code"><span class="ne-text">module.exports</span></code><span class="ne-text">赋值或是添加属性的形式来进行模块导出，那么对于在</span><code class="ne-code"><span class="ne-text">nodejs</span></code><span class="ne-text">当中，</span><code class="ne-code"><span class="ne-text">module</span></code><span class="ne-text">是什么呢？由截图可以看出当前文件模块可以依赖的</span><code class="ne-code"><span class="ne-text">nodejs</span></code><span class="ne-text">模块及其一些其他信息，其中：</span></p><ul class="ne-ul"><li id="u1ad50e53" data-lake-index-type="0"><code class="ne-code"><span class="ne-text">exports</span></code><span class="ne-text">：当前模块导出的部分</span></li><li id="uc7cc432d" data-lake-index-type="0"><code class="ne-code"><span class="ne-text">loaded</span></code><span class="ne-text">：当前模块是否加载完毕</span></li><li id="u59c97e8a" data-lake-index-type="0"><code class="ne-code"><span class="ne-text">paths</span></code><span class="ne-text">：模块查找路径</span></li></ul><p id="ua1f788a2" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2024/png/1484158/1713685048043-00c1c479-fd6b-4d9f-93d7-209db8213256.png" width="1324.1666140490129" id="u80d44c04" class="ne-image"></p></div><h4 id="r3GKa"><span class="ne-text">特点</span></h4><ul class="ne-ul"><li id="ufc8cb866" data-lake-index-type="0"><span class="ne-text">模块的加载是运行时同步加载的，所以在导入时会阻塞执行</span></li><li id="u3e1d725d" data-lake-index-type="0"><span class="ne-text">模块的加载实际上对是所引入对象的一种深拷贝</span></li></ul><p id="u46a75a1d" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2024/png/1484158/1713686002849-f16325a6-7e91-4ac9-8fa5-9d835ce2ad42.png" width="1554.1666049096343" id="ue322ee10" class="ne-image"></p><h4 id="brOua"><span class="ne-text">模块加载机制</span></h4><ol class="ne-ol"><li id="ua1c6f01d" data-lake-index-type="0"><span class="ne-text" style="color: inherit">模块定义：</span><span class="ne-text" style="color: rgb(13, 13, 13); font-size: 16px">在 CommonJS 规范中，每个文件被视为一个独立的模块。模块内部的变量都是局部变量，不会泄露到全局作用域。一个模块可以通过 </span><strong><span class="ne-text" style="color: var(--tw-prose-code); font-size: 16px">require</span></strong><span class="ne-text" style="color: rgb(13, 13, 13); font-size: 16px"> 函数来加载另一个模块，并通过 </span><strong><span class="ne-text" style="color: var(--tw-prose-code); font-size: 16px">module.exports</span></strong><span class="ne-text" style="color: rgb(13, 13, 13); font-size: 16px"> 或 </span><strong><span class="ne-text" style="color: var(--tw-prose-code); font-size: 16px">exports</span></strong><span class="ne-text" style="color: rgb(13, 13, 13); font-size: 16px"> 对象来导出功能。</span></li><li id="ufb5ea875" data-lake-index-type="0"><span class="ne-text" style="color: inherit">模块加载：</span><span class="ne-text" style="color: rgb(13, 13, 13); font-size: 16px">当一个模块需要使用另一个模块时，它会使用 </span><strong><span class="ne-text" style="color: var(--tw-prose-code); font-size: 16px">require</span></strong><span class="ne-text" style="color: rgb(13, 13, 13); font-size: 16px"> 函数来加载目标模块。</span><strong><span class="ne-text" style="color: var(--tw-prose-code); font-size: 16px">require</span></strong><span class="ne-text" style="color: rgb(13, 13, 13); font-size: 16px"> 函数接受一个模块标识符（通常是文件的路径或者模块的名称）作为参数，并返回该模块导出的对象。</span></li><li id="u18e47d65" data-lake-index-type="0"><span class="ne-text" style="color: inherit">模块解析：</span><span class="ne-text" style="color: rgb(13, 13, 13); font-size: 16px">当调用 </span><strong><span class="ne-text" style="color: var(--tw-prose-code); font-size: 16px">require</span></strong><span class="ne-text" style="color: rgb(13, 13, 13); font-size: 16px"> 函数时，Node.js 会按照以下步骤解析和加载模块：</span></li></ol><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="u341f6250" data-lake-index-type="0"><span class="ne-text" style="color: var(--tw-prose-bold); font-size: 16px">路径分析</span><span class="ne-text" style="color: rgb(13, 13, 13); font-size: 16px">：首先检查模块标识符是否是内置模块（如 </span><span class="ne-text" style="color: var(--tw-prose-code); font-size: 16px">fs</span><span class="ne-text" style="color: rgb(13, 13, 13); font-size: 16px">、</span><span class="ne-text" style="color: var(--tw-prose-code); font-size: 16px">http</span><span class="ne-text" style="color: rgb(13, 13, 13); font-size: 16px"> 等）。如果不是，Node.js 会解析相对或绝对路径。</span></li><li id="u0e529b7e" data-lake-index-type="0"><span class="ne-text" style="color: var(--tw-prose-bold); font-size: 16px">文件定位</span><span class="ne-text" style="color: rgb(13, 13, 13); font-size: 16px">：Node.js 会根据路径查找 </span><strong><span class="ne-text" style="color: var(--tw-prose-code); font-size: 16px">.js</span></strong><span class="ne-text" style="color: rgb(13, 13, 13); font-size: 16px">、</span><strong><span class="ne-text" style="color: var(--tw-prose-code); font-size: 16px">.json</span></strong><span class="ne-text" style="color: rgb(13, 13, 13); font-size: 16px"> 或 </span><strong><span class="ne-text" style="color: var(--tw-prose-code); font-size: 16px">.node</span></strong><span class="ne-text" style="color: rgb(13, 13, 13); font-size: 16px"> 文件。如果路径没有文件扩展名，Node.js 会尝试加载支持的文件类型。</span></li><li id="u6dcdf6d5" data-lake-index-type="0"><span class="ne-text" style="color: var(--tw-prose-bold); font-size: 16px">目录分析和包处理</span><span class="ne-text" style="color: rgb(13, 13, 13); font-size: 16px">：如果模块标识符是一个目录，Node.js 将查找该目录下的 </span><strong><span class="ne-text" style="color: var(--tw-prose-code); font-size: 16px">package.json</span></strong><span class="ne-text" style="color: rgb(13, 13, 13); font-size: 16px"> 文件，解析它并查找 </span><strong><span class="ne-text" style="color: var(--tw-prose-code); font-size: 16px">main</span></strong><span class="ne-text" style="color: rgb(13, 13, 13); font-size: 16px"> 属性指定的文件。如果没有 </span><strong><span class="ne-text" style="color: var(--tw-prose-code); font-size: 16px">package.json</span></strong><span class="ne-text" style="color: rgb(13, 13, 13); font-size: 16px"> 或 </span><strong><span class="ne-text" style="color: var(--tw-prose-code); font-size: 16px">main</span></strong><span class="ne-text" style="color: rgb(13, 13, 13); font-size: 16px"> 属性，Node.js 将尝试加载目录下的 </span><strong><span class="ne-text" style="color: var(--tw-prose-code); font-size: 16px">index.js</span></strong><span class="ne-text" style="color: rgb(13, 13, 13); font-size: 16px">。</span></li></ul></ul><ol start="4" class="ne-ol"><li id="ud869670e" data-lake-index-type="0"><strong><span class="ne-text" style="color: inherit">模块缓存：</span></strong><strong><span class="ne-text" style="color: rgb(13, 13, 13); text-decoration: underline; font-size: 16px">每个模块在第一次加载后都会被缓存</span></strong><strong><span class="ne-text" style="color: rgb(13, 13, 13); font-size: 16px">。这意味着无论 </span></strong><strong><span class="ne-text" style="color: var(--tw-prose-code); font-size: 16px">require</span></strong><strong><span class="ne-text" style="color: rgb(13, 13, 13); font-size: 16px"> 函数被调用多少次，模块都只会被执行一次，之后每次调用 </span></strong><strong><span class="ne-text" style="color: var(--tw-prose-code); font-size: 16px">require</span></strong><strong><span class="ne-text" style="color: rgb(13, 13, 13); font-size: 16px"> 都会返回相同的导出对象。这可以提高模块加载的效率并避免重复执行。</span></strong></li></ol><p id="ub8bd2792" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2024/png/1484158/1713686856056-e09f1385-f077-41ce-9654-35df227642e8.png" width="1051.6666248771896" id="ucca5dfe5" class="ne-image"></p><div data-type="success" class="ne-alert"><p id="u2578cb94" class="ne-p"><span class="ne-text">如果真有这种情况，可以手动清除缓存</span></p></div><p id="u79fbadea" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2024/png/1484158/1713687108307-31bb50b5-e8a7-408c-bff9-e0ba303edfdc.png" width="1179.9999531110147" id="u492b4df9" class="ne-image"></p><h3 id="R2Rv5"><span class="ne-text">1.5 ESM</span></h3><p id="u42e70505" class="ne-p"><span class="ne-text">ES模块（</span><code class="ne-code"><span class="ne-text">ECMAScript Modules</span></code><span class="ne-text">），通常简称为</span><code class="ne-code"><span class="ne-text">ESM</span></code><span class="ne-text">，是</span><code class="ne-code"><span class="ne-text">JavaScript</span></code><span class="ne-text">的官方标准模块系统。自</span><code class="ne-code"><span class="ne-text">ES6</span></code><span class="ne-text">（</span><code class="ne-code"><span class="ne-text">ECMAScript 2015</span></code><span class="ne-text">）开始，</span><code class="ne-code"><span class="ne-text">JavaScript</span></code><span class="ne-text">语言本身就内置了对模块的支持。</span></p><h4 id="ILTnS"><span class="ne-text">导入导出</span></h4><pre data-language="javascript" id="KA08t" class="ne-codeblock language-javascript"><code>const sum = (a, b) =&gt; a + b;
export { sum };</code></pre><pre data-language="html" id="SU8ub" class="ne-codeblock language-html"><code>&lt;body&gt;
  &lt;script type=&quot;module&quot;&gt;
    import { sum } from &quot;./module-es.js&quot;;
    console.warn(sum(2, 3));
  &lt;/script&gt;
&lt;/body&gt;</code></pre><h4 id="yXBi7"><span class="ne-text">模块加载机制</span></h4><ul class="ne-ul"><li id="ua71ecd45" data-lake-index-type="0"><span class="ne-text">静态结构：ES模块的一个关键特点是它们具有静态结构。这意味着import和export语句必须位于模块的顶层作用域，且不能动态生成或条件性地执行。这种静态结构使得模块的依赖关系在代码运行之前就已经确定，允许JavaScript引擎优化模块加载、解析和编译。</span></li><li id="ue67ee264" data-lake-index-type="0"><span class="ne-text">加载：浏览器环境，如果是结构化项目，可以直接引入，如果是script脚本引入需要添加type字段如上述例子；如果在nodejs环境，也需要在package.json文件中设置type字段，才能识别es模块的加载语法</span></li><li id="u5a313596" data-lake-index-type="0"><span class="ne-text">ES模块的加载是异步的。当模块被import时，它并不会立即执行，而是首先完成加载和解析过程，然后按照需要的顺序执行。这种方式适用于浏览器环境，因为它允许非阻塞的并行加载。</span></li></ul><pre data-language="javascript" id="WAdpZ" class="ne-codeblock language-javascript"><code>// 报错
import { 'f' + 'oo' } from 'my_module';
// 报错
let module = 'my_module';
import { foo } from module;
// 报错
if (x === 1) {
  import { foo } from 'module1';
} else {
  import { foo } from 'module2';
}</code></pre><p id="u2ad0417b" class="ne-p"><span class="ne-text" style="text-decoration: underline">那么怎么才能实现动态加载呢？</span></p><h4 id="zPPtV"><span class="ne-text">动态引入</span></h4><ol class="ne-ol"><li id="u4655a3ff" data-lake-index-type="0"><span class="ne-text" style="color: var(--tw-prose-bold); font-size: 16px">条件加载</span><span class="ne-text" style="color: rgb(13, 13, 13); font-size: 16px">：可以根据运行时条件来决定是否导入某个模块，这对于减少首次加载时间和优化性能非常有用。</span></li><li id="ue0dcbdca" data-lake-index-type="0"><span class="ne-text" style="color: var(--tw-prose-bold); font-size: 16px">代码分割和懒加载</span><span class="ne-text" style="color: rgb(13, 13, 13); font-size: 16px">：结合现代前端构建工具（如Webpack、Rollup或Parcel），</span><span class="ne-text" style="color: var(--tw-prose-code); font-size: 16px">import()</span><span class="ne-text" style="color: rgb(13, 13, 13); font-size: 16px">可以用于实现代码分割，按需加载模块，从而提高应用的启动速度和响应性。</span></li><li id="u8ac88f3d" data-lake-index-type="0"><span class="ne-text" style="color: var(--tw-prose-bold); font-size: 16px">与其他API和模块化功能集成</span><span class="ne-text" style="color: rgb(13, 13, 13); font-size: 16px">：</span><span class="ne-text" style="color: var(--tw-prose-code); font-size: 16px">import()</span><span class="ne-text" style="color: rgb(13, 13, 13); font-size: 16px">函数可以和其他Web API结合使用，如Service Workers、Web Workers、caches等。</span></li></ol><pre data-language="html" id="zxsjn" class="ne-codeblock language-html"><code>&lt;body&gt;
  &lt;script type=&quot;module&quot;&gt;
    const loadModule = async () =&gt; {
      try {
        const module = await import(&quot;./module-es.js&quot;);
        console.warn(module.sum(2, 3));
      } catch (error) {
        console.error(&quot;Module loading failed: &quot;, error);
      }
    };
    setTimeout(() =&gt; loadModule(), 3000);
  &lt;/script&gt;
&lt;/body&gt;</code></pre><h3 id="Gr6tE"><span class="ne-text">1.6 ESM 与 CommonJS 的差异</span></h3><ol class="ne-ol"><li id="u02b42acb" data-lake-index-type="0"><span class="ne-text">CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。</span></li></ol><ol class="ne-list-wrap"><ol ne-level="1" class="ne-ol"><li id="u8e67da09" data-lake-index-type="0"><span class="ne-text">CommonJS 模块输出的是值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。</span></li><li id="u8c698345" data-lake-index-type="0"><span class="ne-text">ES6 模块的运行机制与 CommonJS 不一样。JS 引擎对脚本静态分析的时候，遇到模块加载命令 import，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。因此，ES6 模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。</span></li></ol></ol><ol start="2" class="ne-ol"><li id="u037d88f1" data-lake-index-type="0"><span class="ne-text">CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。</span></li></ol><ol class="ne-list-wrap"><ol ne-level="1" class="ne-ol"><li id="u3aa7478b" data-lake-index-type="0"><span class="ne-text">运行时加载: CommonJS 模块就是对象；即在输入时是先加载整个模块，生成一个对象，然后再从这个对象上面读取方法，这种加载称为“运行时加载”。</span></li><li id="u046ab421" data-lake-index-type="0"><span class="ne-text">编译时加载: ES6 模块不是对象，而是通过 export 命令显式指定输出的代码， import 时采用静态命令的形式。即在 import 时可以指定加载某个输出值，而不是加载整个模块，这种加载称为“编译时加载”。</span></li></ol></ol><p id="u8962a1d8" class="ne-p"><span class="ne-text">CommonJS 加载的是一个对象（即 module.exports 属性），该对象只有在脚本运行完才会生成。而ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。</span></p><h2 id="LCC3F"><span class="ne-text">二、打包构建</span></h2><h3 id="o9csE"><span class="ne-text">2.1 构建工具</span></h3><p id="u57e8119b" class="ne-p"><span class="ne-text">实现各种环境下都能使用模块化代码，需要使用打包工具来对一套代码进行打包，打包工具主流有：</span></p><ol class="ne-ol"><li id="ubd0fe9cd" data-lake-index-type="0"><span class="ne-text">webpack：适合应用类打包，可以进行详细配置和复杂构建过程的大型项目</span></li><li id="u098a1915" data-lake-index-type="0"><span class="ne-text">vite：适合工具类以及SDK打包，更加适合现代化web应用</span></li></ol><p id="u57cd382c" class="ne-p"><span class="ne-text">本文暂不详述webpack和vite的差异，只针对模块化构建目标做一个概括，所以选用vite来构建一个在所有环境可使用的一个SDK。</span></p><div data-type="info" class="ne-alert"><p id="u58e47bfd" class="ne-p"><span class="ne-text">UMD：并不是一种全新的模块系统，而是整合了无模块化、AMD、CommonJS三种模块规范，其可以在任何环境下工作</span></p></div><h3 id="nf2o8"><span class="ne-text">2.2 利用Vite构建一个SDK</span></h3><p id="u2ee246c1" class="ne-p"><span class="ne-text">目标构建一个node环境和浏览器环境都可以使用的sdk</span></p><p id="u0fd32f7a" class="ne-p"><span class="ne-text"></span></p><p id="u6a1c05c0" class="ne-p"><code class="ne-code"><span class="ne-text">src/inde.js</span></code></p><pre data-language="javascript" id="eHbkY" class="ne-codeblock language-javascript"><code>const sum = (a, b) =&gt; a + b;
export default sum;</code></pre><p id="u9ea52a2c" class="ne-p"><code class="ne-code"><span class="ne-text">vite.config.js</span></code></p><pre data-language="javascript" id="rBEpZ" class="ne-codeblock language-javascript"><code>import { defineConfig } from &quot;vite&quot;;
import path from &quot;path&quot;;
export default defineConfig({
  build: {
    lib: {
      entry: path.resolve(__dirname, &quot;src/index.js&quot;),
      formats: [&quot;es&quot;, &quot;cjs&quot;, &quot;umd&quot;],
      name: &quot;sdk&quot;,
      fileName: (format) =&gt; `sdk.${format}.js`,
    },
  },
});
</code></pre><div data-type="info" class="ne-alert"><p id="ua4d209c5" class="ne-p"><span class="ne-text">在vite中构建多环境依赖只需要上述少量代码即可配置，配置了输出sdk的全局命名以及文件命名等配置，更多配置：</span></p><p id="u6ba9fe8a" class="ne-p"><a href="https://cn.vitejs.dev/config/build-options.html" data-href="https://cn.vitejs.dev/config/build-options.html" target="_blank" class="ne-link"><span class="ne-text">https://cn.vitejs.dev/config/build-options.html</span></a></p></div><p id="u91a8b9a8" class="ne-p"><span class="ne-text">上述代码打包后的结果：</span></p><p id="u6184151b" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2024/png/1484158/1713692148011-07df10e5-bdee-497e-b34e-6567dcbdeccf.png" width="468.3333147234394" id="u51639301" class="ne-image"></p><h3 id="NFWW6"><span class="ne-text">2.3 在不同环境使用SDK</span></h3><p id="u77c9515f" class="ne-p"><span class="ne-text">浏览器环境使用：</span></p><pre data-language="html" id="UG343" class="ne-codeblock language-html"><code>&lt;body&gt;
  &lt;script src=&quot;./dist/sdk.umd.js&quot;&gt;&lt;/script&gt;
  &lt;script&gt;
    console.info(sdk);
    console.warn(sdk(1, 2));
  &lt;/script&gt;
&lt;/body&gt;</code></pre><p id="u8951749c" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2024/png/1484158/1713692332909-7b8a8817-4d75-4d6c-96e6-c533b07278b8.png" width="209.99999165535007" id="u0d704305" class="ne-image"></p><p id="u6a4086e8" class="ne-p"><code class="ne-code"><span class="ne-text">node</span></code><span class="ne-text">环境使用：</span></p><pre data-language="javascript" id="rCr12" class="ne-codeblock language-javascript"><code>const sum = require(&quot;./dist/sdk.cjs.js&quot;);
console.warn(sum(1, 2));</code></pre><p id="u7daf9451" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2024/png/1484158/1713692473725-cf5a5b43-38f1-4b73-ac8e-683f72e521cb.png" width="484.16664742761265" id="u1c2df2db" class="ne-image"></p><p id="u078824a5" class="ne-p"><code class="ne-code"><span class="ne-text">node</span></code><span class="ne-text">环境（根目录package.json文件中指定</span><code class="ne-code"><span class="ne-text">type</span></code><span class="ne-text">字段为</span><code class="ne-code"><span class="ne-text">module</span></code><span class="ne-text">）使用：</span></p><pre data-language="javascript" id="kmYDl" class="ne-codeblock language-javascript"><code>import sum from &quot;./dist/sdk.es.js&quot;;
console.warn(sum(1, 2));</code></pre><p id="u58d842aa" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2024/png/1484158/1713692593519-9b05da4c-323a-4dfb-b2b8-61d97506aab3.png" width="485.8333140280519" id="u098f7f53" class="ne-image"></p></div>0:{"buildId":"ojCF045NjSCdIX953ggig","rsc":["$","$1","c",{"children":[["$","section",null,{"className":"relative","children":["$","$L2",null,{"fade":true,"blur":true,"transition":{"duration":0.5},"delay":0.1,"className":"relative overflow-hidden border-y xl:flex","children":[["$","div",null,{"className":"m-6 w-full flex-1 bg-[radial-gradient(circle_at_center,color-mix(in_oklab,var(--primary)_15%,transparent)_2px,transparent_2px)] bg-size-[18px_18px] max-xl:hidden"}],["$","div",null,{"className":"mx-auto w-full max-w-6xl flex-none space-y-8 px-4 py-8 min-[1158px]:border-x sm:px-6 sm:py-12 lg:px-8","children":[["$","$L2",null,{"fade":true,"blur":true,"slide":{"direction":"down","offset":30},"transition":{"duration":0.4},"children":["$","$L3",null,{"href":"/blog","className":"text-muted-foreground hover:text-foreground inline-flex items-center gap-2 text-sm transition-colors","children":[["$","svg",null,{"xmlns":"http://www.w3.org/2000/svg","width":24,"height":24,"viewBox":"0 0 24 24","fill":"none","stroke":"currentColor","strokeWidth":2,"strokeLinecap":"round","strokeLinejoin":"round","className":"lucide lucide-arrow-left h-4 w-4","aria-hidden":"true","children":[["$","path","1l729n",{"d":"m12 19-7-7 7-7"}],["$","path","x3x0zl",{"d":"M19 12H5"}],"$undefined"]}],"返回","技术博客"]}]}],["$","article",null,{"className":"mx-auto max-w-4xl","children":[["$","header",null,{"className":"mb-8 space-y-6","children":[["$","$L2",null,{"fade":true,"blur":true,"slide":{"direction":"up","offset":50},"delay":0.2,"transition":{"duration":0.6},"children":["$","div",null,{"className":"relative aspect-video overflow-hidden rounded-xl","children":["$","$L4",null,{"src":"https://cdn.nlark.com/yuque/0/2024/png/1484158/1713682888934-ccbdc852-0125-4796-becb-deca844aad58.png","alt":"前端工程化：模块化基础","fill":true,"className":"object-cover","unoptimized":true}]}]}],["$","$L2",null,{"delay":0.3,"transition":{"duration":0.5},"children":["$","h1",null,{"className":"text-2xl font-bold tracking-tight sm:text-3xl md:text-4xl","children":["$","$L5",null,{"text":"前端工程化：模块化基础","delay":30,"animateBy":"words","direction":"bottom"}]}]}],["$","$L2",null,{"fade":true,"blur":true,"slide":{"direction":"down","offset":30},"delay":0.4,"transition":{"duration":0.5},"children":["$","p",null,{"className":"text-muted-foreground text-lg","children":"前言：本文讲述前端代码从脚本全局函数时代到现代化模块引入时代的发展历程，再介绍构建工具对代码予以指定条件下的打包构建，最后利用vite打包工具打包一个可供多个环境使用的SDK的例子。一、模块化演变历程1.1 脚本全局函数在HTML页面所引入的脚本中定义函数，在浏览器执行脚本则可以使用脚本中所定..."}]}],["$","$L2",null,{"fade":true,"blur":true,"slide":{"direction":"down","offset":30},"delay":0.5,"transition":{"duration":0.5},"children":["$","div",null,{"className":"text-muted-foreground flex flex-wrap items-center gap-4 text-sm","children":[["$","div",null,{"className":"flex items-center gap-1","children":[["$","svg",null,{"xmlns":"http://www.w3.org/2000/svg","width":24,"height":24,"viewBox":"0 0 24 24","fill":"none","stroke":"currentColor","strokeWidth":2,"strokeLinecap":"round","strokeLinejoin":"round","className":"lucide lucide-calendar h-4 w-4","aria-hidden":"true","children":[["$","path","1cmpym",{"d":"M8 2v4"}],["$","path","4m81vk",{"d":"M16 2v4"}],["$","rect","1hopcy",{"width":"18","height":"18","x":"3","y":"4","rx":"2"}],["$","path","8toen8",{"d":"M3 10h18"}],"$undefined"]}],["$","span",null,{"children":"2024年4月21日"}]]}],["$","div",null,{"className":"flex items-center gap-1","children":[["$","svg",null,{"xmlns":"http://www.w3.org/2000/svg","width":24,"height":24,"viewBox":"0 0 24 24","fill":"none","stroke":"currentColor","strokeWidth":2,"strokeLinecap":"round","strokeLinejoin":"round","className":"lucide lucide-clock h-4 w-4","aria-hidden":"true","children":[["$","path","mmk7yg",{"d":"M12 6v6l4 2"}],["$","circle","1mglay",{"cx":"12","cy":"12","r":"10"}],"$undefined"]}],["$","span",null,{"children":"2.5千字"}]]}],["$","div",null,{"className":"flex items-center gap-1","children":[["$","svg",null,{"xmlns":"http://www.w3.org/2000/svg","width":24,"height":24,"viewBox":"0 0 24 24","fill":"none","stroke":"currentColor","strokeWidth":2,"strokeLinecap":"round","strokeLinejoin":"round","className":"lucide lucide-eye h-4 w-4","aria-hidden":"true","children":[["$","path","1nclc0",{"d":"M2.062 12.348a1 1 0 0 1 0-.696 10.75 10.75 0 0 1 19.876 0 1 1 0 0 1 0 .696 10.75 10.75 0 0 1-19.876 0"}],["$","circle","1v7zrd",{"cx":"12","cy":"12","r":"3"}],"$undefined"]}],["$","span",null,{"children":[1," 阅读"]}]]}],false,false]}]}],false]}],["$","$L2",null,{"delay":0.6,"fade":true,"blur":true,"transition":{"duration":0.6},"className":"-mx-4 sm:-mx-6 lg:-mx-8","children":["$","$L6",null,{}]}],["$","$L2",null,{"fade":true,"blur":true,"slide":{"direction":"up","offset":50},"delay":0.7,"transition":{"duration":0.6},"children":["$","div",null,{"className":"prose prose-neutral dark:prose-invert mt-8 max-w-none","dangerouslySetInnerHTML":{"__html":"$7"}}]}],"$L8","$L9"]}]]}],"$La"]}]}],["$Lb"],"$Lc"]}],"loading":null,"isPartial":false}
8:["$","$L2",null,{"delay":0.8,"fade":true,"blur":true,"transition":{"duration":0.6},"className":"-mx-4 mt-12 sm:-mx-6 lg:-mx-8","children":["$","$L6",null,{}]}]
9:["$","$L2",null,{"fade":true,"blur":true,"slide":{"direction":"up","offset":30},"delay":0.9,"transition":{"duration":0.5},"children":["$","nav",null,{"className":"mt-8 grid gap-4 md:grid-cols-2","children":[["$","$L3",null,{"href":"/blog/2024-04-21-16-20-30","className":"hover:bg-muted group flex flex-col rounded-lg border p-4 transition-colors","children":[["$","span",null,{"className":"text-muted-foreground mb-2 text-sm","children":"上一篇"}],["$","span",null,{"className":"group-hover:text-primary line-clamp-2 font-medium transition-colors","children":"前后端实现简单上传功能"}]]}],["$","$L3",null,{"href":"/blog/iy7gxmvmskcnwupd","className":"hover:bg-muted group flex flex-col rounded-lg border p-4 text-right transition-colors md:text-right","children":[["$","span",null,{"className":"text-muted-foreground mb-2 text-sm","children":"下一篇"}],["$","span",null,{"className":"group-hover:text-primary line-clamp-2 font-medium transition-colors","children":"Vue3源码：reactivity响应式原理"}]]}]]}]}]
a:["$","div",null,{"className":"m-6 w-full flex-1 bg-[radial-gradient(circle_at_center,color-mix(in_oklab,var(--primary)_15%,transparent)_2px,transparent_2px)] bg-size-[18px_18px] max-xl:hidden"}]
b:["$","script","script-0",{"src":"/_next/static/chunks/11dff99839ab5ba0.js","async":true}]
c:["$","$Ld",null,{"children":["$","$e",null,{"name":"Next.MetadataOutlet","children":"$@f"}]}]
f:null
