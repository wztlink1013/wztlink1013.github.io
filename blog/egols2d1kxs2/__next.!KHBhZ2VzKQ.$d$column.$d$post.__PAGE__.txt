1:"$Sreact.fragment"
2:I[99897,["/_next/static/chunks/4eaa70fe861e9598.js","/_next/static/chunks/946bdd2e6c9b7c49.js","/_next/static/chunks/6dd6809ee42e252f.js","/_next/static/chunks/f2b800ca7ae14e96.js","/_next/static/chunks/e121db38c98deeb4.js","/_next/static/chunks/0973dd923ca2781d.js","/_next/static/chunks/b397c2fd2abb1207.js","/_next/static/chunks/11dff99839ab5ba0.js"],"MotionPreset"]
3:I[22016,["/_next/static/chunks/4eaa70fe861e9598.js","/_next/static/chunks/946bdd2e6c9b7c49.js","/_next/static/chunks/6dd6809ee42e252f.js","/_next/static/chunks/f2b800ca7ae14e96.js","/_next/static/chunks/e121db38c98deeb4.js","/_next/static/chunks/0973dd923ca2781d.js","/_next/static/chunks/b397c2fd2abb1207.js","/_next/static/chunks/11dff99839ab5ba0.js"],""]
4:I[85437,["/_next/static/chunks/4eaa70fe861e9598.js","/_next/static/chunks/946bdd2e6c9b7c49.js","/_next/static/chunks/6dd6809ee42e252f.js","/_next/static/chunks/f2b800ca7ae14e96.js","/_next/static/chunks/e121db38c98deeb4.js","/_next/static/chunks/0973dd923ca2781d.js","/_next/static/chunks/b397c2fd2abb1207.js","/_next/static/chunks/11dff99839ab5ba0.js"],"Image"]
5:I[48347,["/_next/static/chunks/4eaa70fe861e9598.js","/_next/static/chunks/946bdd2e6c9b7c49.js","/_next/static/chunks/6dd6809ee42e252f.js","/_next/static/chunks/f2b800ca7ae14e96.js","/_next/static/chunks/e121db38c98deeb4.js","/_next/static/chunks/0973dd923ca2781d.js","/_next/static/chunks/b397c2fd2abb1207.js","/_next/static/chunks/11dff99839ab5ba0.js"],"default"]
6:I[72436,["/_next/static/chunks/4eaa70fe861e9598.js","/_next/static/chunks/946bdd2e6c9b7c49.js","/_next/static/chunks/6dd6809ee42e252f.js","/_next/static/chunks/f2b800ca7ae14e96.js","/_next/static/chunks/e121db38c98deeb4.js","/_next/static/chunks/0973dd923ca2781d.js","/_next/static/chunks/b397c2fd2abb1207.js","/_next/static/chunks/11dff99839ab5ba0.js"],"Separator"]
e:I[97367,["/_next/static/chunks/ff1a16fafef87110.js","/_next/static/chunks/7340adf74ff47ec0.js"],"OutletBoundary"]
f:"$Sreact.suspense"
0:{"buildId":"mcIhXKXgSeJcHJ-IdbQok","rsc":["$","$1","c",{"children":[["$","section",null,{"className":"relative","children":["$","$L2",null,{"fade":true,"blur":true,"transition":{"duration":0.5},"delay":0.1,"className":"relative overflow-hidden border-y xl:flex","children":[["$","div",null,{"className":"m-6 w-full flex-1 bg-[radial-gradient(circle_at_center,color-mix(in_oklab,var(--primary)_15%,transparent)_2px,transparent_2px)] bg-size-[18px_18px] max-xl:hidden"}],["$","div",null,{"className":"mx-auto w-full max-w-6xl flex-none space-y-8 px-4 py-8 min-[1158px]:border-x sm:px-6 sm:py-12 lg:px-8","children":[["$","$L2",null,{"fade":true,"blur":true,"slide":{"direction":"down","offset":30},"transition":{"duration":0.4},"children":["$","$L3",null,{"href":"/blog","className":"text-muted-foreground hover:text-foreground inline-flex items-center gap-2 text-sm transition-colors","children":[["$","svg",null,{"xmlns":"http://www.w3.org/2000/svg","width":24,"height":24,"viewBox":"0 0 24 24","fill":"none","stroke":"currentColor","strokeWidth":2,"strokeLinecap":"round","strokeLinejoin":"round","className":"lucide lucide-arrow-left h-4 w-4","aria-hidden":"true","children":[["$","path","1l729n",{"d":"m12 19-7-7 7-7"}],["$","path","x3x0zl",{"d":"M19 12H5"}],"$undefined"]}],"返回","技术博客"]}]}],["$","article",null,{"className":"mx-auto max-w-4xl","children":[["$","header",null,{"className":"mb-8 space-y-6","children":[["$","$L2",null,{"fade":true,"blur":true,"slide":{"direction":"up","offset":50},"delay":0.2,"transition":{"duration":0.6},"children":["$","div",null,{"className":"relative aspect-video overflow-hidden rounded-xl","children":["$","$L4",null,{"src":"https://cdn.nlark.com/yuque/0/2021/png/1484158/1616073749902-49fdebb3-2bad-451c-8fe8-fbd97158ada6.png","alt":"JavaScript函数及this不同场景下的指向","fill":true,"className":"object-cover","unoptimized":true}]}]}],["$","$L2",null,{"delay":0.3,"transition":{"duration":0.5},"children":["$","h1",null,{"className":"text-2xl font-bold tracking-tight sm:text-3xl md:text-4xl","children":["$","$L5",null,{"text":"JavaScript函数及this不同场景下的指向","delay":30,"animateBy":"words","direction":"bottom"}]}]}],["$","$L2",null,{"fade":true,"blur":true,"slide":{"direction":"down","offset":30},"delay":0.4,"transition":{"duration":0.5},"children":["$","p",null,{"className":"text-muted-foreground text-lg","children":"前言：基本上和之前学过的语言一样，return语句、continue语句、break语句、函数的传参用法基本都一样，记录一下js的特征用法一、函数函数定义及使用不像之前的C++、JAVA那样需要一个返回值来声明，JavaScript里面直接一个关键字就搞定了，如果里面有return就返回ret..."}]}],["$","$L2",null,{"fade":true,"blur":true,"slide":{"direction":"down","offset":30},"delay":0.5,"transition":{"duration":0.5},"children":["$","div",null,{"className":"text-muted-foreground flex flex-wrap items-center gap-4 text-sm","children":[["$","div",null,{"className":"flex items-center gap-1","children":[["$","svg",null,{"xmlns":"http://www.w3.org/2000/svg","width":24,"height":24,"viewBox":"0 0 24 24","fill":"none","stroke":"currentColor","strokeWidth":2,"strokeLinecap":"round","strokeLinejoin":"round","className":"lucide lucide-calendar h-4 w-4","aria-hidden":"true","children":[["$","path","1cmpym",{"d":"M8 2v4"}],["$","path","4m81vk",{"d":"M16 2v4"}],["$","rect","1hopcy",{"width":"18","height":"18","x":"3","y":"4","rx":"2"}],["$","path","8toen8",{"d":"M3 10h18"}],"$undefined"]}],["$","span",null,{"children":"2021年3月18日"}]]}],["$","div",null,{"className":"flex items-center gap-1","children":[["$","svg",null,{"xmlns":"http://www.w3.org/2000/svg","width":24,"height":24,"viewBox":"0 0 24 24","fill":"none","stroke":"currentColor","strokeWidth":2,"strokeLinecap":"round","strokeLinejoin":"round","className":"lucide lucide-clock h-4 w-4","aria-hidden":"true","children":[["$","path","mmk7yg",{"d":"M12 6v6l4 2"}],["$","circle","1mglay",{"cx":"12","cy":"12","r":"10"}],"$undefined"]}],["$","span",null,{"children":"3.9千字"}]]}],["$","div",null,{"className":"flex items-center gap-1","children":[["$","svg",null,{"xmlns":"http://www.w3.org/2000/svg","width":24,"height":24,"viewBox":"0 0 24 24","fill":"none","stroke":"currentColor","strokeWidth":2,"strokeLinecap":"round","strokeLinejoin":"round","className":"lucide lucide-eye h-4 w-4","aria-hidden":"true","children":[["$","path","1nclc0",{"d":"M2.062 12.348a1 1 0 0 1 0-.696 10.75 10.75 0 0 1 19.876 0 1 1 0 0 1 0 .696 10.75 10.75 0 0 1-19.876 0"}],["$","circle","1v7zrd",{"cx":"12","cy":"12","r":"3"}],"$undefined"]}],["$","span",null,{"children":[16," 阅读"]}]]}],false,false]}]}],false]}],["$","$L2",null,{"delay":0.6,"fade":true,"blur":true,"transition":{"duration":0.6},"className":"-mx-4 sm:-mx-6 lg:-mx-8","children":["$","$L6",null,{}]}],["$","$L2",null,{"fade":true,"blur":true,"slide":{"direction":"up","offset":50},"delay":0.7,"transition":{"duration":0.6},"children":"$L7"}],"$L8","$L9"]}]]}],"$La"]}]}],["$Lb"],"$Lc"]}],"loading":null,"isPartial":false}
d:T8fa7,<!doctype html><div class="lake-content" typography="classic"><p id="ueac13956" class="ne-p"><span class="ne-text">前言：基本上和之前学过的语言一样，return语句、continue语句、break语句、函数的传参用法基本都一样，记录一下js的特征用法</span></p><h1 id="EEH6p"><span class="ne-text">一、函数</span></h1><h2 id="X8waC"><span class="ne-text">函数定义及使用</span></h2><p id="72f9191dd6c40f9c957d08a6a4fb5fa6" class="ne-p"><span class="ne-text">不像之前的C++、JAVA那样需要一个返回值来声明，JavaScript里面直接一个关键字就搞定了，如果里面有return就返回return的值，没有则返回undefined。下面记录一下js里面的三种函数声明方式和不同情况下的使用场景。</span></p><h3 id="C0pXG"><span class="ne-text">function关键字</span></h3><div class="ne-quote"><p id="cac310a57f721c495201fd8f43fd717a" class="ne-p"><span class="ne-text">自定义函数方式(命名函数)利用函数关键字 function 自定义函数方式</span></p></div><pre data-language="javascript" id="BIKBs" class="ne-codeblock language-javascript"><code>// 声明定义方式
function fn() {...}
// 调用  
fn();</code></pre><ul class="ne-ul"><li id="f79542d89be6709192b07b467ab1226b" data-lake-index-type="0"><span class="ne-text">调用函数的代码既可以放到声明函数的前面，也可以放在声明函数的后面</span></li></ul><h3 id="LMsru"><span class="ne-text">匿名函数表达式</span></h3><p id="uf48c7914" class="ne-p"><span class="ne-text">函数表达式方式(匿名函数）</span></p><div class="ne-quote"><p id="d040539e6b580f6af5b43432e1718261" class="ne-p"><span class="ne-text">【C++11里面也有匿名函数的用法，基本上就是</span><strong><span class="ne-text">匿名函数表达式</span></strong><span class="ne-text">】</span></p></div><pre data-language="javascript" id="5BO64" class="ne-codeblock language-javascript"><code>// 这是函数表达式写法，匿名函数后面跟分号结束
var fn = function(){...};
// 调用的方式，函数调用必须写到函数体下面
fn();</code></pre><ul class="ne-ul"><li id="d283d6025aa0cb9c95c9e5d6432ca365" data-lake-index-type="0"><span class="ne-text">这个fn 里面存储的是一个函数</span></li><li id="5426ae5b14dc2793b18c9f79bb1cf86b" data-lake-index-type="0"><span class="ne-text">函数表达式方式原理跟声明变量方式是一致的</span></li><li id="80bea0e7c9c366bf13aed839abfac9c2" data-lake-index-type="0"><span class="ne-text">函数调用的代码必须写到函数体后面</span></li></ul><h3 id="RafLV"><span class="ne-text">构造函数</span></h3><ul class="ne-ul"><li id="aeb9c9b1aab71e3be3ce5b0910474db7" data-lake-index-type="0"><span class="ne-text">所有函数都是Function的对象，函数也是对象</span></li></ul><pre data-language="javascript" id="YARYs" class="ne-codeblock language-javascript"><code>var f = new Function('a', 'b', 'console.log(a + b)');
f(1, 2);
var fn = new Function('参数1','参数2'..., '函数体')</code></pre><p id="u336b8edc" class="ne-p"><br></p><h2 id="xa3mE"><span class="ne-text">函数参数</span></h2><h3 id="zek5T"><span class="ne-text">剩余参数和arguments</span></h3><p id="ub8a6c694" class="ne-p"><strong><span class="ne-text">剩余参数</span></strong></p><ul class="ne-ul"><li id="uc2f0ccbb" data-lake-index-type="0"><span class="ne-text">数组</span></li></ul><p id="ufd13170c" class="ne-p"><strong><span class="ne-text">arguments</span></strong></p><p id="uc6d02b4d" class="ne-p"><br></p><p id="f311e77fa167c8ab1de5f667408fff32" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1617851666624-a963acb7-8a97-43bc-9998-35738a1a1a7f.png" width="467.5" title="" crop="0,0,1,1" id="OVrKI" class="ne-image"></p><p id="d6a5429b661f0a926663653c08d5a96f" class="ne-p"><strong><span class="ne-text">当不确定有多少个参数传递的时候，可以用 arguments 来获取</span></strong><span class="ne-text">。JavaScript 中，arguments实际上它是当前函数的一个内置对象。所有函数都内置了一个 arguments 对象，arguments 对象中存储了传递的所有实参。arguments展示形式是一个伪数组，因此可以进行遍历。伪数组具有以下特点：</span></p><ul class="ne-ul"><li id="8843827210f3e42e9156792599a0c118" data-lake-index-type="0"><span class="ne-text">具有 length 属性</span></li><li id="b11e149419c70d416f470742d52ad2ea" data-lake-index-type="0"><span class="ne-text">按索引方式储存数据</span></li><li id="af2df2e4345f47f3086f4e9675aa2d5e" data-lake-index-type="0"><span class="ne-text">不具有数组的 push , pop 等方法<br /></span><span class="ne-text">注意：在函数内部使用该对象，用此对象获取函数调用时传的实参。</span></li></ul><pre data-language="javascript" id="P9Ylt" class="ne-codeblock language-javascript"><code>function sum(a, ...argus) {
  console.log(argus)
  console.log(arguments)
  return a + b + c + d;
}

sum(1, 2, 3, 4)</code></pre><p id="u8980aee3" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2024/png/1484158/1712627709786-80b0e5de-0e09-478e-a73e-57e4bd7b6d56.png" width="669" title="" crop="0,0,1,1" id="u84ad2bee" class="ne-image"></p><h3 id="tJe43"><span class="ne-text">箭头函数中arguments不可用</span></h3><p id="d00f8bade49b871e8239cf73671daa98" class="ne-p"><span class="ne-text">es6的箭头函数用起来很方便，但是一个不方便的就是在这里面</span><span class="ne-text">arguments 不能用了</span></p><p id="a1d8c49b30b7ae2677e321044c51a114" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1617852137156-ea361bcf-a64d-40e7-9ad4-de9ad5a2789d.png" width="464" title="" crop="0,0,1,1" id="FOFeI" class="ne-image"></p><p id="46c2b14c2b66de8578ce1092cd594b13" class="ne-p"><span class="ne-text">如果非要用的化，将这个箭头函数放在一个普通函数里面，让箭头函数接受这个普通函数的参数</span></p><p id="494bcad7a1c0a199d65391a31a8e438e" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1617852218090-65cab2f5-0088-41e5-95fa-0845a253fcbd.png" width="377" title="" crop="0,0,1,1" id="kFJpX" class="ne-image"></p><h3 id="YcdT5"><span class="ne-text">关于值传递</span></h3><p id="828ba1738a54a70ab3e620409dd3bde3" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1617852230127-5b2394d1-82c0-48a4-8bbb-385f5d27760b.png" width="406.5" title="" crop="0,0,1,1" id="Iq2ke" class="ne-image"></p><h2 id="iPHty"><span class="ne-text">简单/复杂数据类型传参</span></h2><ul class="ne-ul"><li id="u7e7dc6da" data-lake-index-type="0"><span class="ne-text"></span><strong><span class="ne-text">简单类型</span></strong><span class="ne-text">（</span><strong><span class="ne-text">基本数据类型</span></strong><span class="ne-text">、</span><strong><span class="ne-text">值类型</span></strong><span class="ne-text">）：在存储时变量中存储的是值本身，包括string ，number，boolean，undefined，null</span></li><li id="u1e4d266a" data-lake-index-type="0"><span class="ne-text"></span><strong><span class="ne-text">复杂数据类型（引用类型）</span></strong><span class="ne-text">：在存储时变量中存储的仅仅是地址（引用），通过 new 关键字创建的对象（系统对象、自定义对象），如 Object、Array、Date等；</span></li></ul><h3 id="NyCmw"><span class="ne-text">堆栈存储区别</span></h3><p id="uac14d1ad" class="ne-p"><span class="ne-text">堆栈空间分配区别：</span></p><p id="u0d4c51a5" class="ne-p"><span class="ne-text">1、栈（操作系统）：由操作系统自动分配释放存放函数的参数值、局部变量的值等。其操作方式类似于数据结构中的栈；</span></p><p id="ud59709bd" class="ne-p"><span class="ne-text">简单数据类型存放到栈里面</span></p><p id="ufb2855d4" class="ne-p"><span class="ne-text">2、堆（操作系统）：存储复杂类型(对象)，一般由程序员分配释放，若程序员不释放，由垃圾回收机制回收。</span></p><p id="ue7c0d4a8" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611885075555-12234777-10f8-4df1-8a9f-e61078298520.png" width="238" title="" crop="0,0,1,1" id="OjtFR" class="ne-image"></p><p id="ub0f3ed76" class="ne-p"><span class="ne-text">简单数据类型的存储方式：值类型变量的数据直接存放在变量（栈空间）中</span></p><p id="ucd1e1316" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611885085102-7ebb3c36-ffc2-4a5b-af50-c8e377f92cef.png" width="394.5" title="" crop="0,0,1,1" id="IeCaI" class="ne-image"></p><p id="uddc1f7fd" class="ne-p"><span class="ne-text">复杂数据类型的存储方式：引用类型变量（栈空间）里存放的是地址，真正的对象实例存放在堆空间中</span></p><p id="uc55c772d" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611885116525-3f8ac293-e955-40f9-bbff-1aa589b53efa.png" width="279" title="" crop="0,0,1,1" id="jlWv9" class="ne-image"></p><h3 id="ABgTS"><span class="ne-text">简单类型传参</span></h3><p id="u90c5491d" class="ne-p"><span class="ne-text">函数的形参也可以看做是一个变量，当我们把一个</span><strong><span class="ne-text">值类型变量</span></strong><span class="ne-text">作为参数传给函数的形参时，其实是把变量在栈空间里的值</span><strong><span class="ne-text">复制了一份给形参</span></strong><span class="ne-text">，那么在方法内部对形参做任何修改，都不会影响到的外部变量。</span></p><pre data-language="javascript" id="LxOqP" class="ne-codeblock language-javascript"><code>let some = 111;
const change = (o) =&gt; {
  o = 222;
};
console.log(some); // 111
change(some);
console.log(some); // 111</code></pre><h3 id="LhYgy"><span class="ne-text">复杂数据类型传参</span></h3><p id="ud7624fb8" class="ne-p"><span class="ne-text">函数的形参也可以看做是一个变量，当我们把引用类型变量传给形参时，其实是把变量在栈空间里保存的堆地址复制给了形参，形参和实参其实保存的是同一个堆地址，所以操作的是同一个对象。</span></p><pre data-language="javascript" id="wNCqi" class="ne-codeblock language-javascript"><code>const obj = {
  x: 111,
};
const change = (o) =&gt; {
  o.x = 222;
};
console.log(obj.x); // 111
change(obj);
console.log(obj.x); // 222</code></pre><h1 id="t0M8K"><span class="ne-text">二、this</span></h1><h2 id="uG7dX"><span class="ne-text">几个常用this指向</span></h2><ul class="ne-ul"><li id="u10c6706b" data-lake-index-type="0"><span class="ne-text">箭头函数</span></li></ul><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="uc756729a" data-lake-index-type="0"><span class="ne-text">箭头函数没有自己的this。它们会捕获其所在上下文的this值，即词法this。</span></li><li id="u2bce5664" data-lake-index-type="0"><span class="ne-text">传统函数有自己的this值，这个值取决于函数是如何被调用的。</span></li></ul></ul><pre data-language="javascript" id="HHIS0" class="ne-codeblock language-javascript"><code>dom.addEventListener(&quot;click&quot;, () =&gt; {
  setTimeout(() =&gt; {
    console.log(this); // window
  }, 0);
});

dom.addEventListener(&quot;click&quot;, function () {
  setTimeout(() =&gt; {
    console.log(this); // dom
  }, 0);
});</code></pre><ul class="ne-ul"><li id="b12db0c1b44a96c0860ec712b67838a8" data-lake-index-type="0"><span class="ne-text">全局作用域或者普通函数中this指向全局对象window（定时器里面的this指向window）</span></li></ul><pre data-language="javascript" id="Qgdi5" class="ne-codeblock language-javascript"><code>function fn() {
  console.log(this); // Window
}
fn();
setTimeout(function () {
  console.log(this); // Window
}, 1000);</code></pre><ul class="ne-ul"><li id="d940230ffea7da43e23a70b95c5abe22" data-lake-index-type="0"><span class="ne-text">方法调用中谁调用this指向谁</span></li></ul><pre data-language="javascript" id="MHwWR" class="ne-codeblock language-javascript"><code>var o = {
  sayHi: function () {
    console.log(this); // this指向的是 o 这个对象
  },
};
o.sayHi();</code></pre><p id="u83d3980c" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1668946804214-60fa4a1f-3e55-4376-b6e0-9edfe81b9acd.png" width="129.6" title="" crop="0,0,1,1" id="udc71e238" class="ne-image"></p><pre data-language="javascript" id="OYVHu" class="ne-codeblock language-javascript"><code>var btn = document.querySelector(&quot;button&quot;);
btn.addEventListener(&quot;click&quot;, function () {
  console.log(this); // 事件处理函数中的this指向的是btn这个按钮对象
});</code></pre><p id="u49a7f530" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1668946866999-00e9175c-7986-4596-83ed-9c420904b214.png" width="167.2" title="" crop="0,0,1,1" id="uebc3722c" class="ne-image"></p><ul class="ne-ul"><li id="3d0a596a8316330855355f25214d49d7" data-lake-index-type="0"><span class="ne-text">构造函数中this指向构造函数的实例</span></li></ul><pre data-language="javascript" id="xNxBj" class="ne-codeblock language-javascript"><code>function Fun() {
  console.log(this); // this 指向的是fun 实例对象
}
var fun = new Fun();</code></pre><p id="ub91c4c50" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1668946751737-3b11c194-1db4-4353-9d1a-f17f78355fa8.png" width="159.2" title="" crop="0,0,1,1" id="u05e77006" class="ne-image"></p><h2 id="sUQvc"><span class="ne-text">改变函数内部this指向</span></h2><p id="uf7ff9938" class="ne-p"><span class="ne-text">这些 this 的指向，是当我们调用函数的时候确定的。调用方式的不同决定了this 的指向不同</span></p><p id="u3a0b5eb4" class="ne-p"><span class="ne-text">一般指向我们的调用者.</span></p><h3 id="oTowG"><span class="ne-text">call方法</span></h3><p id="80cca7746d6e3f6ddfbe0d0a13db64e5" class="ne-p"><span class="ne-text">call()方法调用一个对象。简单理解为调用函数的方式，但是它可以改变函数的 this 指向</span></p><p id="7d682c1147cd95a30b2a202e05e6d44a" class="ne-p"><span class="ne-text">应用场景:  经常做继承.</span></p><pre data-language="javascript" id="yt6VQ" class="ne-codeblock language-javascript"><code>var o = {
  name: 'andy'
}
function fn(a, b) {
  console.log(this);
  console.log(a+b)
};
fn(1,2)// 此时的this指向的是window 运行结果为3
fn.call(o,1,2)//此时的this指向的是对象o,参数使用逗号隔开,运行结果为3</code></pre><p id="u5c5b4fa2" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2024/png/1484158/1710227433060-1632b7e0-4aff-4034-b37a-e442547ea704.png" width="613.3333089616573" title="" crop="0,0,1,1" id="u6a44d3ea" class="ne-image"></p><h3 id="SYKcd"><span class="ne-text">apply方法</span></h3><p id="73b1a29ae377fe1ddecf267dd75876bc" class="ne-p"><span class="ne-text">apply() 方法调用一个函数。简单理解为调用函数的方式，但是它可以改变函数的 this 指向。</span></p><p id="dd98af2b8f1c5e1042c608d46e2719dc" class="ne-p"><span class="ne-text">应用场景:  经常跟数组有关系</span></p><pre data-language="javascript" id="gPrtf" class="ne-codeblock language-javascript"><code>var o = {
  name: 'andy'
}
function fn(a, b) {
  console.log(this);
  console.log(a+b)
};
fn(1, 2)// 此时的this指向的是window 运行结果为3
fn.apply(o,[1,2])//此时的this指向的是对象o,参数使用数组传递 运行结果为3</code></pre><p id="uea901bb2" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2024/png/1484158/1710227463899-e91a2c42-3843-4472-b855-6e17f5e4328b.png" width="634.999974767368" title="" crop="0,0,1,1" id="uc8e5b6a4" class="ne-image"></p><h3 id="qVFN0"><span class="ne-text">bind方法</span></h3><p id="8f2d73d4ff5434244e4816d57d2cb70f" class="ne-p"><span class="ne-text">bind() 方法不会调用函数,但是能改变函数内部this 指向,返回的是原函数改变this之后产生的新函数</span></p><p id="ba3ad094ba0a2a1de54306a05a4b328d" class="ne-p"><span class="ne-text">如果只是想改变 this 指向，并且不想调用这个函数的时候，可以使用bind</span></p><p id="8b4f288bfc20dcaa6db7eb9f1f5a02c5" class="ne-p"><span class="ne-text">应用场景:不调用函数,但是还想改变this指向</span></p><pre data-language="javascript" id="b7gTh" class="ne-codeblock language-javascript"><code>var o = {
  name: 'andy'
};
function fn(a, b) {
  console.log(this);
  console.log(a + b);
};
var f = fn.bind(o, 1, 2); //此处的f是bind返回的新函数
f();//调用新函数  this指向的是对象o 参数使用逗号隔开</code></pre><p id="u2a24220f" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2024/png/1484158/1710227486072-da39e3bf-22e7-4b3b-a466-b55271245ce6.png" width="220.83332455820542" title="" crop="0,0,1,1" id="u292ed02f" class="ne-image"></p><h3 id="c1uzr"><span class="ne-text">call、apply、bind三者的异同</span></h3><ul class="ne-ul"><li id="837bea232f7b27b17dfc1aad61300dca" data-lake-index-type="0"><span class="ne-text">共同点 : 都可以改变this指向</span></li><li id="a9e715db538e1cdabc5c18c1fa0b36bc" data-lake-index-type="0"><span class="ne-text">不同点:</span></li></ul><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="19a7e4c1e6fc48212336c8fef1dac5ad" data-lake-index-type="0"><span class="ne-text">call 和 apply  会调用函数, 并且改变函数内部this指向.</span></li><li id="466f286b25babfe9a43ac9c4a313764e" data-lake-index-type="0"><span class="ne-text">call 和 apply传递的参数不一样,</span><span class="ne-text" style="color: #DF2A3F">call</span><span class="ne-text">传递参数</span><span class="ne-text" style="color: #DF2A3F">使用逗号隔开</span><span class="ne-text">，</span><span class="ne-text" style="color: #DF2A3F">apply</span><span class="ne-text">传递参数</span><span class="ne-text" style="color: #E4495B">使用数组传递</span></li><li id="06600e50bdef14fb975e1c3fa12d4f53" data-lake-index-type="0"><strong><span class="ne-text" style="color: #E4495B">bind  不会调用函数</span></strong><span class="ne-text">, 可以改变函数内部this指向.</span></li></ul></ul><ul class="ne-ul"><li id="6da2dd93023b14ff4a91066c042741e8" data-lake-index-type="0"><span class="ne-text">应用场景</span></li></ul><ol class="ne-list-wrap"><ol ne-level="1" class="ne-ol"><li id="8b224e2fbc010eec2cfde9212337b809" data-lake-index-type="0"><span class="ne-text">call 经常做继承.</span></li><li id="40e7f61a43b0d91c0459283a016ca67d" data-lake-index-type="0"><span class="ne-text">apply经常跟数组有关系.  比如借助于数学对象实现数组最大值最小值</span></li><li id="83fdbccdc3765ef1b5c93004952744e1" data-lake-index-type="0"><span class="ne-text">bind  不调用函数,但是还想改变this指向. 比如改变定时器内部的this指向.</span></li></ol></ol><h2 id="oALIH"><span class="ne-text">setTimeout和setInterval中的this</span></h2><pre data-language="javascript" id="gcBG2" class="ne-codeblock language-javascript"><code>setTimeOut(function () {
  // this...
})</code></pre><p id="ud51af3d9" class="ne-p" style="text-align: justify"><span class="ne-text" style="color: rgb(77, 77, 77); font-size: 16px">在</span><code class="ne-code"><span class="ne-text" style="color: rgb(77, 77, 77); font-size: 16px">setTimeOut()</span></code><span class="ne-text" style="color: rgb(77, 77, 77); font-size: 16px">或</span><code class="ne-code"><span class="ne-text" style="color: rgb(77, 77, 77); font-size: 16px">setInterval()</span></code><span class="ne-text" style="color: rgb(77, 77, 77); font-size: 16px">这样的方法中，如果传入的函数包含</span><code class="ne-code"><span class="ne-text" style="color: rgb(77, 77, 77); font-size: 16px">this</span></code><span class="ne-text" style="color: rgb(77, 77, 77); font-size: 16px">, 那么，默认情况下，函数中的</span><code class="ne-code"><span class="ne-text" style="color: rgb(77, 77, 77); font-size: 16px">this</span></code><span class="ne-text" style="color: rgb(77, 77, 77); font-size: 16px">会指向</span><code class="ne-code"><span class="ne-text" style="color: rgb(77, 77, 77); font-size: 16px">window</span></code><span class="ne-text" style="color: rgb(77, 77, 77); font-size: 16px">对象。这是由于</span><code class="ne-code"><span class="ne-text" style="color: rgb(77, 77, 77); font-size: 16px">setTimeout()</span></code><span class="ne-text" style="color: rgb(77, 77, 77); font-size: 16px">调用的代码运行在与所在函数完全分离的执行环境上。这会导致这些代码中包含的 this 关键字会指向 </span><code class="ne-code"><span class="ne-text" style="color: rgb(77, 77, 77); font-size: 16px">window</span></code><span class="ne-text" style="color: rgb(77, 77, 77); font-size: 16px"> (或全局)对象。有以下几种方式可以正确</span><code class="ne-code"><span class="ne-text" style="color: rgb(77, 77, 77); font-size: 16px">this</span></code><span class="ne-text" style="color: rgb(77, 77, 77); font-size: 16px">指向：</span></p><h3 id="NshPR"><span class="ne-text" style="color: rgb(79, 79, 79)">方法1：将目标对象的this存为一个变量</span></h3><p id="ufc8a20a2" class="ne-p"><span class="ne-text" style="color: rgb(77, 77, 77); font-size: 16px">定时器内部的函数来访问到这个变量，此时的this，就指向了当前对象</span></p><pre data-language="javascript" id="n8aqb" class="ne-codeblock language-javascript"><code>function doClick(){
  var that = this;
  setInterval(function() {
    console.log(that.msg);
  }, 1000);
}</code></pre><h3 id="YqOau"><span class="ne-text" style="color: rgb(79, 79, 79)">方法2：利用bind()方法</span></h3><pre data-language="javascript" id="bXQwM" class="ne-codeblock language-javascript"><code>function doClick(){
  setInterval(function() {
    console.log(this.msg);
  }.bind(this), 1000);  //利用bind()将this绑定到这个函数上
}</code></pre><h3 id="sOgXx"><span class="ne-text" style="color: rgb(79, 79, 79)">方法3：ES6的箭头函数</span></h3><p id="u9d5a1d2a" class="ne-p"><span class="ne-text" style="color: rgb(77, 77, 77); font-size: 16px">ES6中的箭头函数, this总是指向词法作用域，也就是外层调用者obj，因此利用箭头函数就可以轻松解决这个问题</span></p><pre data-language="javascript" id="hVA2V" class="ne-codeblock language-javascript"><code>function doClick(){
  setInterval(() =&gt; {
    console.log(this.msg);
  }, 100);
},</code></pre><h2 id="g0WFc"><span class="ne-text" style="color: rgb(77, 77, 77)">如何准确判断 this 指向的是什么？</span></h2><ol class="ne-ol"><li id="u52767a52" data-lake-index-type="0"><span class="ne-text" style="color: rgb(77, 77, 77); font-size: 16px">函数是否在 new 中调用 (new 绑定)，如果是，那么 this 绑定的是新创建的对象。</span></li><li id="u7d785062" data-lake-index-type="0"><span class="ne-text" style="color: rgb(77, 77, 77); font-size: 16px">函数是否通过 call,apply 调用，或者使用了 bind(即硬绑定)，如果是，那么 this 绑定的就是指定的对象。</span></li><li id="u2b7ef61a" data-lake-index-type="0"><span class="ne-text" style="color: rgb(77, 77, 77); font-size: 16px">函数是否在某个上下文对象中调用 (隐式绑定)，如果是的话，this 绑定的是那个上下文对象。一般是 obj.foo()。</span></li><li id="ua0127edc" data-lake-index-type="0"><span class="ne-text" style="color: rgb(77, 77, 77); font-size: 16px">如果以上都不是，那么使用默认绑定。如果在严格模式下，则绑定到 undefined，否则绑定到全局对象。</span></li><li id="ub6cad697" data-lake-index-type="0"><span class="ne-text" style="color: #E4495B; font-size: 16px">如果把 Null 或者 undefined 作为 this 的绑定对象传入 call、apply 或者 bind，这些值在调用时会被忽略，实际应用的是默认绑定规则</span><span class="ne-text" style="color: rgb(77, 77, 77); font-size: 16px">。</span></li><li id="ud7f7dca0" data-lake-index-type="0"><span class="ne-text" style="color: rgb(77, 77, 77); font-size: 16px">如果是箭头函数，箭头函数的 this 继承的是外层代码块的 this，执行时的调用者。</span></li></ol><h1 id="LeD6H"><span class="ne-text">三、闭包</span></h1><p id="76c889831aab9d05eb52cec950336aca" class="ne-p"><span class="ne-text">闭包（closure）指有权访问另一个函数作用域中变量的函数。简单理解就是 ，一个作用域可以访问另外一个函数内部的局部变量。</span></p><p id="u638e55a3" class="ne-p"><span class="ne-text">闭包保存状态是指闭包能够</span><span class="ne-text" style="color: #DF2A3F">捕获并持久化其外部函数作用域中的变量</span><span class="ne-text">，使得这些变量的值在多次调用闭包时得以保留和更新</span></p><h2 id="xs7BF"><span class="ne-text">闭包的作用</span></h2><p id="63e908510a6aff59e9327379faa2435c" class="ne-p"><span class="ne-text">作用：延伸变量的作用范围。</span></p><pre data-language="javascript" id="NySmI" class="ne-codeblock language-javascript"><code>function outer() {
  let count = 0; // 外部变量
  return function inner() {
    count++;
    return count;
  };
}
const counter = outer();
console.log(counter()); // 1
console.log(counter()); // 2</code></pre><h2 id="vzrZP"><span class="ne-text">闭包的案例</span></h2><ol class="ne-ol"><li id="ue1645b0a" data-lake-index-type="0"><span class="ne-text">缓存记忆</span></li></ol><pre data-language="javascript" id="tEbRG" class="ne-codeblock language-javascript"><code>function createBankAccount(initial) {
  let balance = initial; // 私有变量
  return {
    deposit: (amount) =&gt; {
      balance += amount
      console.info('余额：', balance)
    },
    withdraw: (amount) =&gt; {
      balance -= amount
      console.info('余额：', balance)
    },
    check: () =&gt; balance
  };
}

const account = createBankAccount(100);
account.deposit(50); // 余额150
account.withdraw(30); // 余额120</code></pre><ol start="2" class="ne-ol"><li id="u02b77fa2" data-lake-index-type="0"><span class="ne-text">实现私有变量（模块模式）</span></li></ol><pre data-language="javascript" id="V267n" class="ne-codeblock language-javascript"><code>var Yideng = (function () {
  // 这样声明为模块私有变量，外界无法直接访问
  var foo = 0;

  function Yideng() {}
  Yideng.prototype.bar = function bar() {
    return foo;
  };
  return Yideng;
}());</code></pre><ol start="3" class="ne-ol"><li id="a3a8e47a2abddf99014bff26562b3108" data-lake-index-type="0"><span class="ne-text">利用闭包的方式得到当前li 的索引号</span></li></ol><pre data-language="javascript" id="RIEd9" class="ne-codeblock language-javascript"><code>for (var i = 0; i &lt; lis.length; i++) {
  // 利用for循环创建了4个立即执行函数
  // 立即执行函数也成为小闭包因为立即执行函数里面的任何一个函数都可以使用它的i这变量
  (function(i) {
    lis[i].onclick = function() {
      console.log(i);
    }
  })(i);
}</code></pre><ol start="4" class="ne-ol"><li id="e23058120f4f4379a7b8c6e3ee120611" data-lake-index-type="0"><span class="ne-text">闭包应用-3秒钟之后,打印所有li元素的内容</span></li></ol><pre data-language="javascript" id="NyWEd" class="ne-codeblock language-javascript"><code>for (var i = 0; i &lt; lis.length; i++) {
  (function(i) {
    setTimeout(function() {
      console.log(lis[i].innerHTML);
    }, 3000)
  })(i);
}</code></pre><p id="98b2a169a1398d289874189535e94975" class="ne-p"><br></p><pre data-language="javascript" id="1WZWK" class="ne-codeblock language-javascript"><code>var name = &quot;The Window&quot;;
var object = {
  name: &quot;My Object&quot;,
  getNameFunc: function() {
    return function() {
      return this.name;
    };
  }
};
console.log(object.getNameFunc()())
// -----------------------------------------------------------------------------------
var name = &quot;The Window&quot;;　　
var object = {　　　　
  name: &quot;My Object&quot;,
  getNameFunc: function() {
    var that = this;
    return function() {
      return that.name;
    };
  }
};
console.log(object.getNameFunc()())</code></pre><p id="9d3b3410f572bb95a27cf75f4bc16f5d" class="ne-p"><br></p><h1 id="WkFNQ"><span class="ne-text">四、特殊功能性函数</span></h1><h2 id="NODez"><span class="ne-text">立即调用函数</span></h2><div data-type="info" class="ne-alert"><p id="u5f839dec" class="ne-p"><span class="ne-text">两种表达方式</span></p></div><pre data-language="javascript" id="ss3Ik" class="ne-codeblock language-javascript"><code>(function(){})()  
(function(){}())</code></pre><div data-type="info" class="ne-alert"><p id="u5a3b6c49" class="ne-p"><span class="ne-text">立即执行函数与位运算混合</span></p></div><p id="u1c9222f1" class="ne-p"><span class="ne-text">与立即执行函数相关的知识还有在函数前面加上一些符号（！、~、+……）会对函数的返回值进行相应的操作，其中加上~的意思是对返回值进行按位取反的操作，具体参考下面的参考资料</span></p><p id="ua9a270d6" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1617956106484-c021320c-100a-49b5-a668-99928bf3a720.png" width="472.98846435546875" title="" crop="0,0,1,1" id="uWasL" class="ne-image"></p><pre data-language="javascript" id="aEVOt" class="ne-codeblock language-javascript"><code>console.warn(
  !(function (aaa) {
    return aaa;
  })(777)
);
// false</code></pre><div data-type="info" class="ne-alert"><p id="u016e9612" class="ne-p"><span class="ne-text">立即执行函数传参有什么意义？（chatgpt答）</span></p></div><p id="uf07aef02" class="ne-p"><span class="ne-text">立即执行函数（Immediately Invoked Function Expression，IIFE）是一种 JavaScript 设计模式，用于创建一个函数并立即调用它。传递参数给立即执行函数可以为一些特定的情况提供更灵活的解决方案。</span></p><p id="ue8621f48" class="ne-p"><br></p><p id="ucb4f0a30" class="ne-p"><span class="ne-text">下面是一些传递参数给立即执行函数的情况和意义：</span></p><p id="uf19a1ce0" class="ne-p"><br></p><ol class="ne-ol"><li id="u275bed42" data-lake-index-type="0"><span class="ne-text"> </span><strong><span class="ne-text">隔离作用域</span></strong><span class="ne-text">：传递参数可以帮助在函数内创建一个局部作用域，防止变量污染全局命名空间。这在大型项目中特别有用，以避免变量名冲突和不必要的耦合。 </span></li><li id="u88f911ff" data-lake-index-type="0"><span class="ne-text"> </span><strong><span class="ne-text">模块化</span></strong><span class="ne-text">：传递参数可以用于模块化开发。你可以将依赖项作为参数传递给模块函数，从而使模块更加可配置和可重用。 </span></li><li id="ubf220271" data-lake-index-type="0"><span class="ne-text"> </span><strong><span class="ne-text">参数配置</span></strong><span class="ne-text">：通过传递参数，你可以配置函数的行为。这种方式可以使函数更加通用，因为你可以根据需要动态地调整函数的行为。 </span></li><li id="u7fe22580" data-lake-index-type="0"><span class="ne-text"> </span><strong><span class="ne-text">私有状态</span></strong><span class="ne-text">：通过传递参数，你可以将状态信息传递给函数，并在函数内部维护该状态。这种方式可以实现一些私有状态，使函数更加封装和安全。 </span></li><li id="ua421c82c" data-lake-index-type="0"><span class="ne-text"> </span><strong><span class="ne-text">提高性能</span></strong><span class="ne-text">：在一些情况下，传递参数可以减少函数内部的变量查找时间，从而提高性能。因为传递参数可以将特定值直接传递给函数，而不需要在函数内部查找全局变量或外部作用域。 </span></li></ol><p id="ua84ff9a3" class="ne-p"><br></p><p id="uaad38770" class="ne-p"><span class="ne-text">总之，传递参数给立即执行函数可以使代码更加灵活、模块化和可配置，同时也有助于提高性能和安全性。</span></p><h2 id="drews"><span class="ne-text">生成器函数</span></h2><p id="uc723bf0c" class="ne-p"><span class="ne-text">类似于nodejs的express框架的中间件</span></p><p id="uce53102b" class="ne-p"><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/function*" data-href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/function*" target="_blank" class="ne-link"><span class="ne-text">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/function*</span></a></p><pre data-language="javascript" id="OR6FB" class="ne-codeblock language-javascript"><code>const gen = (function* () {
  yield 111;
  yield 222;
})()
console.log(gen.next())
console.log(gen.next())
console.log(gen.next())</code></pre><p id="uffa8611e" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2024/png/1484158/1712626934608-9e7953b6-f106-4853-8541-6960f94d4cd7.png" width="278" title="" crop="0,0,1,1" id="u0fdd3347" class="ne-image"></p><h2 id="aT35S"><span class="ne-text">方法函数</span></h2><ul class="ne-ul"><li id="u97254a2c" data-lake-index-type="0"><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Method_definitions" data-href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Method_definitions" target="_blank" class="ne-link"><span class="ne-text">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Method_definitions</span></a></li></ul><pre data-language="javascript" id="x3CNb" class="ne-codeblock language-javascript"><code>const obj = {
  a: 'dd',
  foo() {
    return 'bar';
  },
  some: () =&gt; {
    return 'something.'
  }
};

console.log(obj.a, obj.foo(), obj.some()); // &quot;dd&quot; &quot;bar&quot; &quot;something.&quot;</code></pre><h2 id="gUXRQ"><span class="ne-text">get set函数</span></h2><p id="uc1cacfad" class="ne-p"><span class="ne-text">对象中可以定义get和set函数来完成更好的访问和修改对象属性值逻辑。</span></p><ul class="ne-ul"><li id="uc7d87134" data-lake-index-type="0"><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/get" data-href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/get" target="_blank" class="ne-link"><span class="ne-text">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/get</span></a></li><li id="udf868282" data-lake-index-type="0"><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/set" data-href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/set" target="_blank" class="ne-link"><span class="ne-text">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/set</span></a></li></ul><pre data-language="javascript" id="TmyGK" class="ne-codeblock language-javascript"><code>const obj = {
  data: [1, 2, 3],
  get getData() {
    return this.data.map(_ =&gt; String(_))
  }
}
console.warn(obj)</code></pre><p id="udfc25859" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2024/png/1484158/1712626102485-4a9dc634-5ea7-4768-8a1e-4e3c62dff1d0.png" width="423" title="" crop="0,0,1,1" id="u404d0409" class="ne-image"></p><pre data-language="javascript" id="jiQnH" class="ne-codeblock language-javascript"><code>const obj = {
  data: [1, 2, 3],
  get getData() {
    return this.data.map(_ =&gt; String(_))
  },
  /**
         * @param {number} data
         */
  set addData(data) {
    this.data.push(data)
  }
}
obj.addData = 4
console.warn(obj)</code></pre><p id="u82f3bd95" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2024/png/1484158/1712626281491-00ef586c-4690-47ca-b0b7-a8740c88cf56.png" width="429" title="" crop="0,0,1,1" id="uce42abbd" class="ne-image"></p></div>7:["$","div",null,{"className":"prose prose-neutral dark:prose-invert mt-8 max-w-none","dangerouslySetInnerHTML":{"__html":"$d"}}]
8:["$","$L2",null,{"delay":0.8,"fade":true,"blur":true,"transition":{"duration":0.6},"className":"-mx-4 mt-12 sm:-mx-6 lg:-mx-8","children":["$","$L6",null,{}]}]
9:["$","$L2",null,{"fade":true,"blur":true,"slide":{"direction":"up","offset":30},"delay":0.9,"transition":{"duration":0.5},"children":["$","nav",null,{"className":"mt-8 grid gap-4 md:grid-cols-2","children":[["$","$L3",null,{"href":"/blog/wgzidzz85o76","className":"hover:bg-muted group flex flex-col rounded-lg border p-4 transition-colors","children":[["$","span",null,{"className":"text-muted-foreground mb-2 text-sm","children":"上一篇"}],["$","span",null,{"className":"group-hover:text-primary line-clamp-2 font-medium transition-colors","children":"DOM事件"}]]}],["$","$L3",null,{"href":"/blog/zfpg9dfgehog","className":"hover:bg-muted group flex flex-col rounded-lg border p-4 text-right transition-colors md:text-right","children":[["$","span",null,{"className":"text-muted-foreground mb-2 text-sm","children":"下一篇"}],["$","span",null,{"className":"group-hover:text-primary line-clamp-2 font-medium transition-colors","children":"JavaScript面向对象体系及对象内置属性和方法"}]]}]]}]}]
a:["$","div",null,{"className":"m-6 w-full flex-1 bg-[radial-gradient(circle_at_center,color-mix(in_oklab,var(--primary)_15%,transparent)_2px,transparent_2px)] bg-size-[18px_18px] max-xl:hidden"}]
b:["$","script","script-0",{"src":"/_next/static/chunks/11dff99839ab5ba0.js","async":true}]
c:["$","$Le",null,{"children":["$","$f",null,{"name":"Next.MetadataOutlet","children":"$@10"}]}]
10:null
