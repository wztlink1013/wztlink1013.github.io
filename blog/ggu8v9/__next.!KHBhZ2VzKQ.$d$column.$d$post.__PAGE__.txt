1:"$Sreact.fragment"
2:I[99897,["/_next/static/chunks/4eaa70fe861e9598.js","/_next/static/chunks/fa1a8f8830b9bf3a.js","/_next/static/chunks/6dd6809ee42e252f.js","/_next/static/chunks/f2b800ca7ae14e96.js","/_next/static/chunks/e121db38c98deeb4.js","/_next/static/chunks/6d971f5a9c16d0c2.js","/_next/static/chunks/b397c2fd2abb1207.js","/_next/static/chunks/11dff99839ab5ba0.js"],"MotionPreset"]
3:I[22016,["/_next/static/chunks/4eaa70fe861e9598.js","/_next/static/chunks/fa1a8f8830b9bf3a.js","/_next/static/chunks/6dd6809ee42e252f.js","/_next/static/chunks/f2b800ca7ae14e96.js","/_next/static/chunks/e121db38c98deeb4.js","/_next/static/chunks/6d971f5a9c16d0c2.js","/_next/static/chunks/b397c2fd2abb1207.js","/_next/static/chunks/11dff99839ab5ba0.js"],""]
4:I[85437,["/_next/static/chunks/4eaa70fe861e9598.js","/_next/static/chunks/fa1a8f8830b9bf3a.js","/_next/static/chunks/6dd6809ee42e252f.js","/_next/static/chunks/f2b800ca7ae14e96.js","/_next/static/chunks/e121db38c98deeb4.js","/_next/static/chunks/6d971f5a9c16d0c2.js","/_next/static/chunks/b397c2fd2abb1207.js","/_next/static/chunks/11dff99839ab5ba0.js"],"Image"]
5:I[48347,["/_next/static/chunks/4eaa70fe861e9598.js","/_next/static/chunks/fa1a8f8830b9bf3a.js","/_next/static/chunks/6dd6809ee42e252f.js","/_next/static/chunks/f2b800ca7ae14e96.js","/_next/static/chunks/e121db38c98deeb4.js","/_next/static/chunks/6d971f5a9c16d0c2.js","/_next/static/chunks/b397c2fd2abb1207.js","/_next/static/chunks/11dff99839ab5ba0.js"],"default"]
6:I[72436,["/_next/static/chunks/4eaa70fe861e9598.js","/_next/static/chunks/fa1a8f8830b9bf3a.js","/_next/static/chunks/6dd6809ee42e252f.js","/_next/static/chunks/f2b800ca7ae14e96.js","/_next/static/chunks/e121db38c98deeb4.js","/_next/static/chunks/6d971f5a9c16d0c2.js","/_next/static/chunks/b397c2fd2abb1207.js","/_next/static/chunks/11dff99839ab5ba0.js"],"Separator"]
d:I[97367,["/_next/static/chunks/ff1a16fafef87110.js","/_next/static/chunks/7340adf74ff47ec0.js"],"OutletBoundary"]
e:"$Sreact.suspense"
7:T1ceb,<!doctype html><div class="lake-content" typography="classic"><h2 id="sgeWE"><span class="ne-text">问题描述</span></h2><p id="9e986f8b518aa874e5488365b4e318ad" class="ne-p"><span class="ne-text">压缩算法，目的就是根据字母的出现频率来“按需分配”编码来优化编码方式。</span></p><p id="077c62ae4385fc6d47f65957345e17f5" class="ne-p"><span class="ne-text">比如：给出一串字母   </span><code class="ne-code"><span class="ne-text">Huffman Coding</span></code><span class="ne-text">   ，按照计算机处理形式，会根据ascll码将这串字符编码，具体形式（十进制）就是104 117 102 102 109 97 110 32 67 111 100 105 110 103，然后转换成二进制，最后会得到需要97个比特来存储。</span></p><h2 id="CaJgL"><span class="ne-text">算法描述</span></h2><p id="7e72a7f72a1ef85799d8e92db7d33404" class="ne-p"><span class="ne-text">算法角度来讲对上述问题ascll编码方式是浪费空间的，优化方向是改变编码方式，根据字母出现的频率来“按需分配”进制位。</span></p><p id="7bcb792f84491e892aa6eec4fe5ff850" class="ne-p"><br></p><p id="3568172be7d1c8656b762c0d960074ad" class="ne-p" style="text-align: left"><span class="ne-text">给出下面所给出的字母，以及出现的频率，来得到哈夫曼编码</span></p><p id="6ccb77d085739e1dd8a502fd7145d98b" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1605340774734-5ec5e8f1-0fae-47ff-8ded-dccf9611a3ad.png" width="205.5" id="pbDsY" class="ne-image"></p><p id="08528f8a11c5d0ecc0cd3bae97773b5b" class="ne-p" style="text-align: left"><span class="ne-text">先提出将频率小的依次加入。d和h组合权值为9(或者说A只是称呼方便)，然后将这个9“替换d和h”代入整个序列，在进行插入树操作，</span></p><div class="ne-quote"><p id="a5e27cd3dfd648344330915cf07369d8" class="ne-p" style="text-align: left"><span class="ne-text">过程中，遵循数字大的在左数字小的在右原则（互换也没关系，只不过换的是二进制的0和1）</span></p></div><p id="80aefeec8f8b6ab08a4c6c02bfb68c36" class="ne-p"><span class="ne-text">在进行到E的时候，此时的队列应该为120 107 42 37，所以此时需要重新调整队列，然后进行到结束。</span></p><p id="e68706c149a6ec04640e3cad07d51c50" class="ne-p" style="text-align: left"><br></p><p id="c8e68bfc6996011d2dc03f21a12bb5f5" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1605340899720-d8867a90-d01c-4bf6-8ec7-ca0e812a99dd.png" width="188" id="vJM66" class="ne-image"></p><p id="4ef66678373379b55daca8b336a95124" class="ne-p" style="text-align: left"><span class="ne-text">最后的编码结果为：</span></p><p id="05a0e15b6dd3480361d88674d68f7b0d" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1605341313840-61587c86-135d-4ba0-96aa-844868de1d56.png" width="82.5" id="ENEj4" class="ne-image"></p><h2 id="3eVEL"><span class="ne-text">编码实现</span></h2><pre data-language="cpp" id="rNy23" class="ne-codeblock language-cpp">#include &lt;stdio.h&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
namespace NS_HuffmanCoding {
using namespace std;
void BuildHuffmanTree();
void Initialization(vector&lt;pair&lt;char, int&gt;&gt; chars);
void Finalization();
struct HFMNode {
  char Ch; int Freq;
  HFMNode* Left, * Right;
  HFMNode(char pCh, int pFreq, HFMNode* pLeft, HFMNode* pRight)
    : Ch(pCh), Freq(pFreq), Left(pLeft), Right(pRight) {}
  HFMNode(char pCh, int pFreq)
    : HFMNode(pCh, pFreq, NULL, NULL) {}
};
void MinHeapify(vector&lt;HFMNode*&gt;&amp; H);
void InsertH(vector&lt;HFMNode*&gt;&amp; H, HFMNode* node);
void SiftDown(vector&lt;HFMNode*&gt;&amp; H, int i);
void SiftUp(vector&lt;HFMNode*&gt;&amp; H, int i);
HFMNode* ExtractMin(vector&lt;HFMNode*&gt;&amp; H);
void DeleteANode(HFMNode* node);
void ShowInput(vector&lt;pair&lt;char, int&gt;&gt; chars);
void Output();
static vector&lt;HFMNode*&gt; Q;
void HuffmanCodingCaller(vector&lt;pair&lt;char, int&gt;&gt; chars)
{
  ShowInput(chars);
  Initialization(chars);
  BuildHuffmanTree();
  Output();
  Finalization();
}
void BuildHuffmanTree()
{
  char C = 'A';
  while (Q.size() &gt; 1)
  {
    HFMNode* x = ExtractMin(Q);
    HFMNode* y = ExtractMin(Q);
    HFMNode* z = new HFMNode(C++, x-&gt;Freq + y-&gt;Freq, x, y);
    InsertH(Q, z);
  }
}
HFMNode* ExtractMin(vector&lt;HFMNode*&gt;&amp; H)
{
  swap(H.front(), H.back());
  HFMNode* p = H.back();
  H.pop_back();
  if (!H.empty())
    SiftDown(H, 0);
  return p;
}
void SiftDown(vector&lt;HFMNode*&gt;&amp; H, int i)
{
    while ((i = (i &lt;&lt; 1) + 1) &lt; H.size()) {
        if ((i + 1 &lt; H.size()) &amp;&amp; (H[i + 1]-&gt;Freq &lt; H[i]-&gt;Freq))
            i = i + 1;
        if (H[(i - 1) &gt;&gt; 1]-&gt;Freq &gt; H[i]-&gt;Freq)
            swap(H[(i - 1) &gt;&gt; 1], H[i]);
        else break;
    }
}
void InsertH(vector&lt;HFMNode*&gt;&amp; H, HFMNode* node)
{
  H.push_back(node);
  SiftUp(H, H.size() - 1);
}
void SiftUp(vector&lt;HFMNode*&gt;&amp; H, int i)
{
  while (i &gt; 0 &amp;&amp; H[i]-&gt;Freq &lt; H[(i - 1) &gt;&gt; 1]-&gt;Freq) {
    swap(H[i], H[(i - 1) &gt;&gt; 1]);
    i = (i - 1) &gt;&gt; 1;
  }
}
void MinHeapify(vector&lt;HFMNode*&gt;&amp; H)
{
  for (int i = (H.size() &gt;&gt; 1) - 1; i &gt;= 0; i--) {
    SiftDown(H, i);
  }
}

void Initialization(vector&lt;pair&lt;char, int&gt;&gt; chars)
{
  Q.clear();
  for (auto ch : chars)
    Q.push_back(new HFMNode(ch.first, ch.second));
  MinHeapify(Q);
}
void Finalization()
{
  DeleteANode(Q[0]);
}
void DeleteANode(HFMNode* node)
{
  if (node-&gt;Left)
  {
    DeleteANode(node-&gt;Left);
    DeleteANode(node-&gt;Right);
  }
  delete node;
}
void ShowInput(vector&lt;pair&lt;char, int&gt;&gt; chars)
{
  printf(&quot;Huffman coding input: \n&quot;);
  for (auto c : chars)
    printf(&quot;%c,%d; &quot;, c.first, c.second);
  printf(&quot;\n&quot;);
}
static vector&lt;char&gt; coding;
static vector&lt;pair&lt;char, vector&lt;char&gt;&gt;&gt; codingList;
void GetHuffmanCoding(HFMNode* node)
{
  if (node-&gt;Left)
  {
    coding.push_back('0');
    GetHuffmanCoding(node-&gt;Left);
    coding.pop_back();
    coding.push_back('1');
    GetHuffmanCoding(node-&gt;Right);
    coding.pop_back();
  }
  else
  {
    codingList.push_back(pair&lt;char, 
      vector&lt;char&gt;&gt;(node-&gt;Ch, coding));
  }
}
void Output()
{
  printf(&quot;Huffman coding:\n&quot;);
  coding.clear();
  codingList.clear();
  GetHuffmanCoding(Q[0]);
  sort(codingList.begin(), codingList.end());
  for (auto c1 : codingList)
  {
    printf(&quot;  %c: &quot;, c1.first);
    for (auto c2 : c1.second)
      printf(&quot;%c&quot;, c2);
    printf(&quot;\n&quot;);
  }
  printf(&quot;\n&quot;);
}
} //namespace NS_HuffmanCoding
using namespace NS_HuffmanCoding;
void TestHuffmanCoding()
{
  vector&lt;vector&lt;pair&lt;char, int&gt;&gt;&gt; charLists = {
      //Introduction to Algorithms
     {
        { {'a',40}, {'b',13}, {'c',12}, 
          {'d',16}, {'e',9}, {'f',5} },
     },
     //ÑÏÎµÃô
     {
        { {'a',5}, {'b',29}, {'c',7}, {'d',8}, 
          {'e',14}, {'f',23}, {'g',3}, {'h',11} },
     },
  };
  int n = charLists.size();
  for (int i = 0; i &lt; n; i++)
  {
    HuffmanCodingCaller(charLists[i]);
  }
}</pre></div>0:{"buildId":"f0cdySSxBr_ZaI2KML5of","rsc":["$","$1","c",{"children":[["$","section",null,{"className":"relative","children":["$","$L2",null,{"fade":true,"blur":true,"transition":{"duration":0.5},"delay":0.1,"className":"relative overflow-hidden border-y xl:flex","children":[["$","div",null,{"className":"m-6 w-full flex-1 bg-[radial-gradient(circle_at_center,color-mix(in_oklab,var(--primary)_15%,transparent)_2px,transparent_2px)] bg-size-[18px_18px] max-xl:hidden"}],["$","div",null,{"className":"mx-auto w-full max-w-6xl flex-none space-y-8 px-4 py-8 min-[1158px]:border-x sm:px-6 sm:py-12 lg:px-8","children":[["$","$L2",null,{"fade":true,"blur":true,"slide":{"direction":"down","offset":30},"transition":{"duration":0.4},"children":["$","$L3",null,{"href":"/blog","className":"text-muted-foreground hover:text-foreground inline-flex items-center gap-2 text-sm transition-colors","children":[["$","svg",null,{"xmlns":"http://www.w3.org/2000/svg","width":24,"height":24,"viewBox":"0 0 24 24","fill":"none","stroke":"currentColor","strokeWidth":2,"strokeLinecap":"round","strokeLinejoin":"round","className":"lucide lucide-arrow-left h-4 w-4","aria-hidden":"true","children":[["$","path","1l729n",{"d":"m12 19-7-7 7-7"}],["$","path","x3x0zl",{"d":"M19 12H5"}],"$undefined"]}],"返回","技术博客"]}]}],["$","article",null,{"className":"mx-auto max-w-4xl","children":[["$","header",null,{"className":"mb-8 space-y-6","children":[["$","$L2",null,{"fade":true,"blur":true,"slide":{"direction":"up","offset":50},"delay":0.2,"transition":{"duration":0.6},"children":["$","div",null,{"className":"relative aspect-video overflow-hidden rounded-xl","children":["$","$L4",null,{"src":"https://cdn.nlark.com/yuque/0/2020/png/1484158/1605340774734-5ec5e8f1-0fae-47ff-8ded-dccf9611a3ad.png","alt":"Huffman编码算法","fill":true,"className":"object-cover","unoptimized":true}]}]}],["$","$L2",null,{"delay":0.3,"transition":{"duration":0.5},"children":["$","h1",null,{"className":"text-2xl font-bold tracking-tight sm:text-3xl md:text-4xl","children":["$","$L5",null,{"text":"Huffman编码算法","delay":30,"animateBy":"words","direction":"bottom"}]}]}],["$","$L2",null,{"fade":true,"blur":true,"slide":{"direction":"down","offset":30},"delay":0.4,"transition":{"duration":0.5},"children":["$","p",null,{"className":"text-muted-foreground text-lg","children":"问题描述压缩算法，目的就是根据字母的出现频率来“按需分配”编码来优化编码方式。比如：给出一串字母   Huffman Coding   ，按照计算机处理形式，会根据ascll码将这串字符编码，具体形式（十进制）就是104 117 102 102 109 97 110 32 67 111 100..."}]}],["$","$L2",null,{"fade":true,"blur":true,"slide":{"direction":"down","offset":30},"delay":0.5,"transition":{"duration":0.5},"children":["$","div",null,{"className":"text-muted-foreground flex flex-wrap items-center gap-4 text-sm","children":[["$","div",null,{"className":"flex items-center gap-1","children":[["$","svg",null,{"xmlns":"http://www.w3.org/2000/svg","width":24,"height":24,"viewBox":"0 0 24 24","fill":"none","stroke":"currentColor","strokeWidth":2,"strokeLinecap":"round","strokeLinejoin":"round","className":"lucide lucide-calendar h-4 w-4","aria-hidden":"true","children":[["$","path","1cmpym",{"d":"M8 2v4"}],["$","path","4m81vk",{"d":"M16 2v4"}],["$","rect","1hopcy",{"width":"18","height":"18","x":"3","y":"4","rx":"2"}],["$","path","8toen8",{"d":"M3 10h18"}],"$undefined"]}],["$","span",null,{"children":"2020年11月14日"}]]}],["$","div",null,{"className":"flex items-center gap-1","children":[["$","svg",null,{"xmlns":"http://www.w3.org/2000/svg","width":24,"height":24,"viewBox":"0 0 24 24","fill":"none","stroke":"currentColor","strokeWidth":2,"strokeLinecap":"round","strokeLinejoin":"round","className":"lucide lucide-clock h-4 w-4","aria-hidden":"true","children":[["$","path","mmk7yg",{"d":"M12 6v6l4 2"}],["$","circle","1mglay",{"cx":"12","cy":"12","r":"10"}],"$undefined"]}],["$","span",null,{"children":"815字"}]]}],["$","div",null,{"className":"flex items-center gap-1","children":[["$","svg",null,{"xmlns":"http://www.w3.org/2000/svg","width":24,"height":24,"viewBox":"0 0 24 24","fill":"none","stroke":"currentColor","strokeWidth":2,"strokeLinecap":"round","strokeLinejoin":"round","className":"lucide lucide-eye h-4 w-4","aria-hidden":"true","children":[["$","path","1nclc0",{"d":"M2.062 12.348a1 1 0 0 1 0-.696 10.75 10.75 0 0 1 19.876 0 1 1 0 0 1 0 .696 10.75 10.75 0 0 1-19.876 0"}],["$","circle","1v7zrd",{"cx":"12","cy":"12","r":"3"}],"$undefined"]}],["$","span",null,{"children":[13," 阅读"]}]]}],false,false]}]}],false]}],["$","$L2",null,{"delay":0.6,"fade":true,"blur":true,"transition":{"duration":0.6},"className":"-mx-4 sm:-mx-6 lg:-mx-8","children":["$","$L6",null,{}]}],["$","$L2",null,{"fade":true,"blur":true,"slide":{"direction":"up","offset":50},"delay":0.7,"transition":{"duration":0.6},"children":["$","div",null,{"className":"prose prose-neutral dark:prose-invert mt-8 max-w-none","dangerouslySetInnerHTML":{"__html":"$7"}}]}],"$L8","$L9"]}]]}],"$La"]}]}],["$Lb"],"$Lc"]}],"loading":null,"isPartial":false}
8:["$","$L2",null,{"delay":0.8,"fade":true,"blur":true,"transition":{"duration":0.6},"className":"-mx-4 mt-12 sm:-mx-6 lg:-mx-8","children":["$","$L6",null,{}]}]
9:["$","$L2",null,{"fade":true,"blur":true,"slide":{"direction":"up","offset":30},"delay":0.9,"transition":{"duration":0.5},"children":["$","nav",null,{"className":"mt-8 grid gap-4 md:grid-cols-2","children":[["$","$L3",null,{"href":"/blog/uq89oe","className":"hover:bg-muted group flex flex-col rounded-lg border p-4 transition-colors","children":[["$","span",null,{"className":"text-muted-foreground mb-2 text-sm","children":"上一篇"}],["$","span",null,{"className":"group-hover:text-primary line-clamp-2 font-medium transition-colors","children":"C++匿名函数"}]]}],["$","$L3",null,{"href":"/blog/ghf568","className":"hover:bg-muted group flex flex-col rounded-lg border p-4 text-right transition-colors md:text-right","children":[["$","span",null,{"className":"text-muted-foreground mb-2 text-sm","children":"下一篇"}],["$","span",null,{"className":"group-hover:text-primary line-clamp-2 font-medium transition-colors","children":"最小生成树算法（Prim+Kruskal）"}]]}]]}]}]
a:["$","div",null,{"className":"m-6 w-full flex-1 bg-[radial-gradient(circle_at_center,color-mix(in_oklab,var(--primary)_15%,transparent)_2px,transparent_2px)] bg-size-[18px_18px] max-xl:hidden"}]
b:["$","script","script-0",{"src":"/_next/static/chunks/11dff99839ab5ba0.js","async":true}]
c:["$","$Ld",null,{"children":["$","$e",null,{"name":"Next.MetadataOutlet","children":"$@f"}]}]
f:null
