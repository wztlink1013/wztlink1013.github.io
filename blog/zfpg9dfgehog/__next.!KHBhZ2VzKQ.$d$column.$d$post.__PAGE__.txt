1:"$Sreact.fragment"
2:I[99897,["/_next/static/chunks/4eaa70fe861e9598.js","/_next/static/chunks/946bdd2e6c9b7c49.js","/_next/static/chunks/6dd6809ee42e252f.js","/_next/static/chunks/f2b800ca7ae14e96.js","/_next/static/chunks/e121db38c98deeb4.js","/_next/static/chunks/0973dd923ca2781d.js","/_next/static/chunks/b397c2fd2abb1207.js","/_next/static/chunks/11dff99839ab5ba0.js"],"MotionPreset"]
3:I[22016,["/_next/static/chunks/4eaa70fe861e9598.js","/_next/static/chunks/946bdd2e6c9b7c49.js","/_next/static/chunks/6dd6809ee42e252f.js","/_next/static/chunks/f2b800ca7ae14e96.js","/_next/static/chunks/e121db38c98deeb4.js","/_next/static/chunks/0973dd923ca2781d.js","/_next/static/chunks/b397c2fd2abb1207.js","/_next/static/chunks/11dff99839ab5ba0.js"],""]
4:I[85437,["/_next/static/chunks/4eaa70fe861e9598.js","/_next/static/chunks/946bdd2e6c9b7c49.js","/_next/static/chunks/6dd6809ee42e252f.js","/_next/static/chunks/f2b800ca7ae14e96.js","/_next/static/chunks/e121db38c98deeb4.js","/_next/static/chunks/0973dd923ca2781d.js","/_next/static/chunks/b397c2fd2abb1207.js","/_next/static/chunks/11dff99839ab5ba0.js"],"Image"]
5:I[48347,["/_next/static/chunks/4eaa70fe861e9598.js","/_next/static/chunks/946bdd2e6c9b7c49.js","/_next/static/chunks/6dd6809ee42e252f.js","/_next/static/chunks/f2b800ca7ae14e96.js","/_next/static/chunks/e121db38c98deeb4.js","/_next/static/chunks/0973dd923ca2781d.js","/_next/static/chunks/b397c2fd2abb1207.js","/_next/static/chunks/11dff99839ab5ba0.js"],"default"]
6:I[72436,["/_next/static/chunks/4eaa70fe861e9598.js","/_next/static/chunks/946bdd2e6c9b7c49.js","/_next/static/chunks/6dd6809ee42e252f.js","/_next/static/chunks/f2b800ca7ae14e96.js","/_next/static/chunks/e121db38c98deeb4.js","/_next/static/chunks/0973dd923ca2781d.js","/_next/static/chunks/b397c2fd2abb1207.js","/_next/static/chunks/11dff99839ab5ba0.js"],"Separator"]
e:I[97367,["/_next/static/chunks/ff1a16fafef87110.js","/_next/static/chunks/7340adf74ff47ec0.js"],"OutletBoundary"]
f:"$Sreact.suspense"
0:{"buildId":"mcIhXKXgSeJcHJ-IdbQok","rsc":["$","$1","c",{"children":[["$","section",null,{"className":"relative","children":["$","$L2",null,{"fade":true,"blur":true,"transition":{"duration":0.5},"delay":0.1,"className":"relative overflow-hidden border-y xl:flex","children":[["$","div",null,{"className":"m-6 w-full flex-1 bg-[radial-gradient(circle_at_center,color-mix(in_oklab,var(--primary)_15%,transparent)_2px,transparent_2px)] bg-size-[18px_18px] max-xl:hidden"}],["$","div",null,{"className":"mx-auto w-full max-w-6xl flex-none space-y-8 px-4 py-8 min-[1158px]:border-x sm:px-6 sm:py-12 lg:px-8","children":[["$","$L2",null,{"fade":true,"blur":true,"slide":{"direction":"down","offset":30},"transition":{"duration":0.4},"children":["$","$L3",null,{"href":"/blog","className":"text-muted-foreground hover:text-foreground inline-flex items-center gap-2 text-sm transition-colors","children":[["$","svg",null,{"xmlns":"http://www.w3.org/2000/svg","width":24,"height":24,"viewBox":"0 0 24 24","fill":"none","stroke":"currentColor","strokeWidth":2,"strokeLinecap":"round","strokeLinejoin":"round","className":"lucide lucide-arrow-left h-4 w-4","aria-hidden":"true","children":[["$","path","1l729n",{"d":"m12 19-7-7 7-7"}],["$","path","x3x0zl",{"d":"M19 12H5"}],"$undefined"]}],"返回","技术博客"]}]}],["$","article",null,{"className":"mx-auto max-w-4xl","children":[["$","header",null,{"className":"mb-8 space-y-6","children":[["$","$L2",null,{"fade":true,"blur":true,"slide":{"direction":"up","offset":50},"delay":0.2,"transition":{"duration":0.6},"children":["$","div",null,{"className":"relative aspect-video overflow-hidden rounded-xl","children":["$","$L4",null,{"src":"https://cdn.nlark.com/yuque/0/2021/png/1484158/1616073749469-3b46e582-24d9-4ec1-8f51-ce0e86328cec.png","alt":"JavaScript面向对象体系及对象内置属性和方法","fill":true,"className":"object-cover","unoptimized":true}]}]}],["$","$L2",null,{"delay":0.3,"transition":{"duration":0.5},"children":["$","h1",null,{"className":"text-2xl font-bold tracking-tight sm:text-3xl md:text-4xl","children":["$","$L5",null,{"text":"JavaScript面向对象体系及对象内置属性和方法","delay":30,"animateBy":"words","direction":"bottom"}]}]}],["$","$L2",null,{"fade":true,"blur":true,"slide":{"direction":"down","offset":30},"delay":0.4,"transition":{"duration":0.5},"children":["$","p",null,{"className":"text-muted-foreground text-lg","children":"前言：JavaScript首先在ES6没有出来之前，利用一个叫原型的一系列机制来用一段很长的代码来实现类的继承，说白了就是在函数里面默认给你加个一个叫原型的对象属性，再利用一系列指向来完成继承。在ES6之后，才有了形式上的类class及其对象，以及一个单词extends就搞定的继承，虽说搞定，..."}]}],["$","$L2",null,{"fade":true,"blur":true,"slide":{"direction":"down","offset":30},"delay":0.5,"transition":{"duration":0.5},"children":["$","div",null,{"className":"text-muted-foreground flex flex-wrap items-center gap-4 text-sm","children":[["$","div",null,{"className":"flex items-center gap-1","children":[["$","svg",null,{"xmlns":"http://www.w3.org/2000/svg","width":24,"height":24,"viewBox":"0 0 24 24","fill":"none","stroke":"currentColor","strokeWidth":2,"strokeLinecap":"round","strokeLinejoin":"round","className":"lucide lucide-calendar h-4 w-4","aria-hidden":"true","children":[["$","path","1cmpym",{"d":"M8 2v4"}],["$","path","4m81vk",{"d":"M16 2v4"}],["$","rect","1hopcy",{"width":"18","height":"18","x":"3","y":"4","rx":"2"}],["$","path","8toen8",{"d":"M3 10h18"}],"$undefined"]}],["$","span",null,{"children":"2021年3月18日"}]]}],["$","div",null,{"className":"flex items-center gap-1","children":[["$","svg",null,{"xmlns":"http://www.w3.org/2000/svg","width":24,"height":24,"viewBox":"0 0 24 24","fill":"none","stroke":"currentColor","strokeWidth":2,"strokeLinecap":"round","strokeLinejoin":"round","className":"lucide lucide-clock h-4 w-4","aria-hidden":"true","children":[["$","path","mmk7yg",{"d":"M12 6v6l4 2"}],["$","circle","1mglay",{"cx":"12","cy":"12","r":"10"}],"$undefined"]}],["$","span",null,{"children":"2.4千字"}]]}],["$","div",null,{"className":"flex items-center gap-1","children":[["$","svg",null,{"xmlns":"http://www.w3.org/2000/svg","width":24,"height":24,"viewBox":"0 0 24 24","fill":"none","stroke":"currentColor","strokeWidth":2,"strokeLinecap":"round","strokeLinejoin":"round","className":"lucide lucide-eye h-4 w-4","aria-hidden":"true","children":[["$","path","1nclc0",{"d":"M2.062 12.348a1 1 0 0 1 0-.696 10.75 10.75 0 0 1 19.876 0 1 1 0 0 1 0 .696 10.75 10.75 0 0 1-19.876 0"}],["$","circle","1v7zrd",{"cx":"12","cy":"12","r":"3"}],"$undefined"]}],["$","span",null,{"children":[12," 阅读"]}]]}],false,false]}]}],false]}],["$","$L2",null,{"delay":0.6,"fade":true,"blur":true,"transition":{"duration":0.6},"className":"-mx-4 sm:-mx-6 lg:-mx-8","children":["$","$L6",null,{}]}],["$","$L2",null,{"fade":true,"blur":true,"slide":{"direction":"up","offset":50},"delay":0.7,"transition":{"duration":0.6},"children":"$L7"}],"$L8","$L9"]}]]}],"$La"]}]}],["$Lb"],"$Lc"]}],"loading":null,"isPartial":false}
d:T5047,<!doctype html><div class="lake-content" typography="classic"><p id="u9f2794ef" class="ne-p" style="text-indent: 2em"><span class="ne-text">前言：JavaScript首先在ES6没有出来之前，利用一个叫原型的一系列机制来用一段很长的代码来实现类的继承，说白了就是在函数里面默认给你加个一个叫原型的对象属性，再利用一系列指向来完成继承。在ES6之后，才有了形式上的类class及其对象，以及一个单词extends就搞定的继承，虽说搞定，但这里面的机制还是原型相关知识，记录学习一下。</span></p><p id="udc8e4c2c" class="ne-p" style="text-indent: 2em"><span class="ne-text">不管是原型也好，新加的class也罢，就一个目的——为了实现面向对象。从两个体系来展开详述。</span></p><h2 id="yj3wW"><span class="ne-text">体系一：原型+原型链</span></h2><ul class="ne-ul"><li id="u3d362539" data-lake-index-type="0"><span class="ne-text">讲解的很透彻：</span><a href="https://www.bilibili.com/video/BV1Q64y1v7fW" data-href="https://www.bilibili.com/video/BV1Q64y1v7fW" target="_blank" class="ne-link"><span class="ne-text">https://www.bilibili.com/video/BV1Q64y1v7fW</span></a></li></ul><h3 id="LnxeQ"><span class="ne-text">隐式原型__proto__</span></h3><p id="ud0a1f80e" class="ne-p"><span class="ne-text" style="text-decoration: underline">每个对象里面都有__proto__属性</span><span class="ne-text">，这个叫对象原型，这个玩意指向</span><strong><span class="ne-text">构造函数的prototype对象</span></strong></p><div class="ne-quote"><p id="u5184b156" class="ne-p"><span class="ne-text">__proto__对象原型的意义就在于为对象的查找机制提供一个方向，或者说一条路线，但是它是一个非标准属性，因此实际开发中，不可以使用这个属性，它只是内部指向原型对象 prototype</span></p></div><p id="u9a75c883" class="ne-p"><span class="ne-text">比如说，有一个Person类，有一个Student类，Student类继承自Person类，Student有一个实例student_1，那么student_1会有__proto__对象属性，并且展开该__proto__，会发现里面是Person类的方法和属性</span></p><h3 id="CLRny"><span class="ne-text">显式原型prototype</span></h3><p id="7c59d55d4430a46b8ffc2c7b51f1e256" class="ne-p"><span class="ne-text" style="text-decoration: underline">每个构造函数里面都有一个属性，这个属性叫prototype，</span><strong><span class="ne-text" style="text-decoration: underline">指向另一个对象</span></strong><span class="ne-text" style="text-decoration: underline">（</span><span class="ne-text">有什么用？在后面原型链就会发现有用了），并且这个属性是一个对象，叫做构造函数原型</span></p><div class="ne-quote"><p id="66d8017956949710921f46829a08c3d8" class="ne-p"><span class="ne-text">这样可以解决一个问题，就是创建不同实例，这些事例所用的方法都是同一个内存下的方法，实现共享</span></p></div><h3 id="w9Uhl"><span class="ne-text">constructor构造函数</span></h3><ol class="ne-ol"><li id="fccf204ee8c9f63131ce572e4bd9135c" data-lake-index-type="0"><span class="ne-text">对象原型（ __proto__）和构造函数（prototype）原型对象里面都有一个属性 constructor 属性 ，constructor 我们称为构造函数，因为它</span><strong><span class="ne-text" style="text-decoration: underline">指回构造函数本身</span></strong><span class="ne-text">。</span></li><li id="43bf14b0a19dae4f626eb4be000d8fce" data-lake-index-type="0"><span class="ne-text">constructor 主要用于记录该对象引用于哪个构造函数，它可以让原型对象重新指向原来的构造函数。</span></li><li id="052026097e14bd2660b57547591740ee" data-lake-index-type="0"><span class="ne-text">一般情况下，对象的方法都在构造函数的原型对象中设置。如果有多个对象的方法，我们可以给原型对象采取对象形式赋值，但是这样就会覆盖构造函数原型对象原来的内容，这样修改后的原型对象 constructor  就不再指向当前构造函数了。此时，我们可以在修改后的原型对象中，添加一个 constructor 指向原来的构造函数。</span></li></ol><h3 id="zGyP9"><span class="ne-text">instanceof</span></h3><p id="ucbd81d9b" class="ne-p"><span class="ne-text">a instanceof b</span></p><p id="uff532746" class="ne-p"><span class="ne-text">判断是true还是false</span></p><p id="ub45967b4" class="ne-p"><span class="ne-text">看a的constructor是什么</span></p><p id="uea8ad4ec" class="ne-p"><span class="ne-text">当b为   a的constructor或a的__proto__的constructor……</span></p><p id="u574656e6" class="ne-p"><span class="ne-text">结果都是true</span></p><h3 id="y8vLN"><span class="ne-text">原型链和成员查找机制</span></h3><p id="u5702aa15" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1651672328368-25e71aa6-4015-4469-9a67-5d841645aebe.png" width="1268.333282934297" id="ue6601372" class="ne-image"></p><p id="4598fd72a5cc5f9d913bdf73126385d4" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1622632967349-b2adf38c-b51f-445b-b4c8-7d0408e96390.png" width="501" id="B3Eo8" class="ne-image"></p><h3 id="V8jhV"><span class="ne-text">原型体系中的继承</span></h3><p id="512dd492c06f7b4ac69269f1b091b237" class="ne-p"><span class="ne-text">call方法可以改变一个函数的指向</span></p><ol class="ne-ol"><li id="344c83abd47ab0a088a47b2c6337455d" data-lake-index-type="0"><span class="ne-text">继承父构造函数里面的属性</span></li></ol><pre data-language="javascript" id="ngHQt" class="ne-codeblock language-javascript"><code>// 1. 父构造函数
 function Father(uname, age) {
   // this 指向父构造函数的对象实例
   this.uname = uname;
   this.age = age;
 }
  // 2 .子构造函数 
function Son(uname, age, score) {
  // this 指向子构造函数的对象实例
  // 3.使用call方式实现子继承父的属性
  Father.call(this, uname, age);
  this.score = score;
}
var son = new Son('刘德华', 18, 100);
console.log(son);</code></pre><ol start="2" class="ne-ol"><li id="a3855cf3ab3a5f5c35c51d1dd654cb4f" data-lake-index-type="0"><span class="ne-text">继承方法</span></li></ol><pre data-language="javascript" id="AbSOK" class="ne-codeblock language-javascript"><code>// 1. 父构造函数
function Father(uname, age) {
  // this 指向父构造函数的对象实例
  this.uname = uname;
  this.age = age;
}
Father.prototype.money = function() {
  console.log(100000);
 };
 // 2 .子构造函数 
  function Son(uname, age, score) {
      // this 指向子构造函数的对象实例
      Father.call(this, uname, age);
      this.score = score;
  }
// Son.prototype = Father.prototype;  这样直接赋值会有问题,如果修改了子原型对象,父原型对象也会跟着一起变化
  Son.prototype = new Father();
  // 如果利用对象的形式修改了原型对象,别忘了利用constructor 指回原来的构造函数
  Son.prototype.constructor = Son;
  // 这个是子构造函数专门的方法
  Son.prototype.exam = function() {
    console.log('孩子要考试');
  }
  var son = new Son('刘德华', 18, 100);
  console.log(son);</code></pre><h2 id="2AkCh"><span class="ne-text">体系二：类(class)【ES6】</span></h2><p id="cad140a8200f42428c7a238d32d88835" class="ne-p"><span class="ne-text">在 ES6 中新增加了类的概念，可以使用 class 关键字声明一个类，之后以这个类来实例化对象。类抽象了对象的公共部分，它泛指某一大类（class）对象特指某一个，通过类实例化一个具体的对象。其创建的方式和之前学过的语言很类似。</span></p><p id="u12d357f4" class="ne-p"><span class="ne-text"></span></p><p id="u0a5bbe48" class="ne-p"><span class="ne-text">在 ES6 中类没有变量或是函数提升概念，所以必须先定义类，才能通过类实例化对象，这也是类和函数最大的不同。</span></p><h3 id="cMF3s"><span class="ne-text">原型方法和原型字段声明</span></h3><p id="u87ac43e1" class="ne-p"><span class="ne-text">原型方法：</span></p><ol class="ne-ol"><li id="uba4c9294" data-lake-index-type="0"><span class="ne-text">构造函数方法</span></li><li id="uc9b3df1c" data-lake-index-type="0"><span class="ne-text">get set</span></li><li id="u04200080" data-lake-index-type="0"><span class="ne-text">静态方法：通常作为类的工具函数</span></li><li id="u7247d342" data-lake-index-type="0"><span class="ne-text">普通方法</span></li></ol><p id="uc6eb4120" class="ne-p"><br></p><p id="u29912692" class="ne-p"><span class="ne-text">原型字段：</span></p><ol class="ne-ol"><li id="u3bfea643" data-lake-index-type="0"><span class="ne-text">私有字段</span></li><li id="u55109b6c" data-lake-index-type="0"><span class="ne-text">公有字段</span></li></ol><pre data-language="javascript" id="j3sCm" class="ne-codeblock language-javascript"><code>class Tooltip {
  #test1 = 111; // 私有成员
  test2 = 222; // 公有成员
  static test3 = 333; // 静态成员（类内部不能访问 相当于类的属性）
  static fun1(a, b) {
    // 静态方法（类内部不能访问 相当于类的属性）
    return a + b;
  }
  constructor() {
    console.log('private member test1: ', ++this.#test1);
    console.log('public member test2: ', ++this.test2);
    console.log('origin class: ', this);
  }
}

class TextTooltip extends Tooltip {
  constructor(quill, options) {
    super(quill, options.bounds);
  }
}

this.textToolTip = new TextTooltip(quill, options);
console.log(this.textToolTip, 
            Tooltip.test3,
            TextTooltip.test3, 
            TextTooltip.fun1(333, 333));


export default TextTooltipToolbar;
</code></pre><h3 id="EQmnS"><span class="ne-text">继承</span></h3><pre data-language="javascript" id="kZ21w" class="ne-codeblock language-javascript"><code>// 奥特曼类
class Aoteman {
    // 构造函数里面放共有属性、方法
    constructor(name, age) {
        this.name = name;
        this.age = age;
    }
    Ability(abi) {
        console.log(this.name + &quot; can &quot; + abi);
    }
}

// 假 继承 奥特曼
class Jia extends Aoteman {
    constructor (x, y) {
        // 继承父类的构造函数
        super(x,y); 
        // 方便写自己的函数
        this.x = x;
        this.y = y;
    }
    // 自己内部的函数
    Chuiniu() {
        console.log(this.x + &quot; chuiniu&quot;);
    }

}


// 创建迪迦对象
let dijia = new Aoteman('dijia', 100);
console.log(dijia);
dijia.Ability(&quot;X-ray&quot;);
let dijia_jia = new Jia(&quot;dijia_jia&quot;, 50);
dijia_jia.Ability(&quot;xxx&quot;);
dijia_jia.Chuiniu();</code></pre><p id="cb14a18ef0b052581ff2c955bf1a0ffc" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1622622728600-59f47873-c895-4686-b771-f1f538198f26.png" width="441" id="JN882" class="ne-image"></p><h3 id="UyaIK"><span class="ne-text">多重继承</span></h3><p id="u3310e98b" class="ne-p"><span class="ne-text">JavaScript对象的继承只能继承一个父类，因为继承的根本实现是基于原型链的，所以继承不能同时指向多个对象，所以实现多重继承有两个思路：</span></p><ol class="ne-ol"><li id="u52a6832e" data-lake-index-type="0"><span class="ne-text">父类链式继承</span></li></ol><pre data-language="javascript" id="zYTiI" class="ne-codeblock language-javascript"><code>class Parent1 extends Parent2 {}
class Parent2 extends Parent3 {}
class Child extends Parent1 {}</code></pre><ol start="2" class="ne-ol"><li id="ube418643" data-lake-index-type="0"><span class="ne-text">实现Mixin来继承</span></li></ol><pre data-language="javascript" id="i78Nf" class="ne-codeblock language-javascript"><code>function mixin(...mixins) {
  class Mixin {
    constructor(...args) {
      mixins.forEach(
        mixin =&gt; copyProperties(this, new mixin(...args)) // 拷贝实例属性
      ) 
    }
  }
  mixins.forEach(
    mixin =&gt; {
      copyProperties(Mixin, mixin); // 拷贝静态属性
      copyProperties(Mixin.prototype, mixin.prototype); // 拷贝原型属性
    }
  )

  return Mixin;
}

function copyProperties(target, source) {
  for (let key of Reflect.ownKeys(source)) {
    if (['constructor', 'prototype', 'name'].indexOf(key) &lt; 0) {
      let desc = Object.getOwnPropertyDescriptor(source, key);
      Object.defineProperty(target, key, desc);
    }
  }
}</code></pre><pre data-language="javascript" id="uoHBI" class="ne-codeblock language-javascript"><code>class Child extends mixin(Parent1, Parent2, Parent3) {}</code></pre><h2 id="Pieyx"><span class="ne-text">对象的各种创建方式</span></h2><h3 id="zit4E"><span class="ne-text">字面量</span></h3><p id="083a4934aac2b8be69b10cc6f6d4f323" class="ne-p"><span class="ne-text">属性和方法的调用：</span></p><p id="36235a6d55d24a73c9da43f5eef64605" class="ne-p"><span class="ne-text">属性可以用&quot;.&quot;和[&quot;属性名&quot;]来调用</span></p><p id="60c09abb79feb2bc609b8822c6ece536" class="ne-p"><span class="ne-text">方法用&quot;.&quot;来调用</span></p><h3 id="qieAE"><span class="ne-text">模式工厂</span></h3><p id="12f03a76db50bccfcb65ebd419d35599" class="ne-p"><span class="ne-text">new一个空对象，</span><code class="ne-code"><span class="ne-text">let obj = new Object();</span></code></p><p id="76e77acf462c0d5fc6711fe41458c5b8" class="ne-p"><span class="ne-text">然后利用&quot;.&quot;的方式给其添加属性和方法</span></p><p id="9a7c3df6d0ab8823ad10b9d56da71806" class="ne-p"><span class="ne-text">内置的Object()构造函数</span></p><p id="c1e35870ec274c5a60120cec9b6a71c8" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1622623002064-1297005b-76a6-4d94-9b12-a83cf709e3a1.png" width="529.5" id="hDM2I" class="ne-image"></p><h3 id="6Kx17"><span class="ne-text">构造函数</span></h3><div class="ne-quote"><p id="4bb010f534c4432e61c5acfc8ed7f78d" class="ne-p"><span class="ne-text">构造函数：是一种特殊的函数，主要用来初始化对象，即为对象成员变量赋初始值，它总与 new 运算符一起使用。我们可以把对象中一些公共的属性和方法抽取出来，然后封装到这个函数里面。</span></p></div><pre data-language="javascript" id="hTLsM" class="ne-codeblock language-javascript"><code>function 构造函数名(形参1,形参2,形参3) {
     this.属性名1 = 参数1;
     this.属性名2 = 参数2;
     this.属性名3 = 参数3;
     this.方法名 = 函数体;
}

let obj = new 构造函数名(实参1，实参2，实参3)</code></pre><p id="4c6617820231460b3d1a5ba0052650cc" class="ne-p"><br></p><ul class="ne-ul"><li id="42ddfc91739b54f0db3ad2360bfa2a11" data-lake-index-type="0"><span class="ne-text">构造函数约定</span><strong><span class="ne-text">首字母大写</span></strong><span class="ne-text">。</span></li><li id="107ab55d6bdb5fc8852a8ba09058c242" data-lake-index-type="0"><span class="ne-text">函数内的属性和方法前面需要添加 </span><strong><span class="ne-text">this</span></strong><span class="ne-text"> ，表示当前对象的属性和方法。</span></li><li id="a40659a6a97972cbe2892ca3ba220606" data-lake-index-type="0"><span class="ne-text">构造函数中</span><strong><span class="ne-text">不需要 return 返回结果</span></strong><span class="ne-text">。</span></li><li id="d5ada7fd51b068d3faab947354a6172c" data-lake-index-type="0"><span class="ne-text">当我们创建对象的时候，</span><strong><span class="ne-text">必须用 new 来调用构造函数</span></strong><span class="ne-text">。</span></li></ul><h3 id="1QZhm"><span class="ne-text">原型模式</span></h3><p id="70c37cafa4ed06b8de783a9a800765ed" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1622623181327-bd4b5d09-8525-4c59-b550-9af381526f23.png" width="529.5" id="qBvgN" class="ne-image"></p><p id="cab84c8c6b9a31635a96b6562e393404" class="ne-p"><span class="ne-text">下面详述什么是原型</span></p><h2 id="sxsBG"><span class="ne-text">对象的内置方法</span></h2><p id="u82c051d5" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2024/png/1484158/1723441463675-8c8b2161-e7f9-4ac1-b313-bb7fbd161fbd.png" width="962" id="u72e49db8" class="ne-image"></p><h3 id="Pe1XQ"><span class="ne-text">defineProperty</span></h3><p id="e403193d89184c9e7039f12f52d5c627" class="ne-p"><code class="ne-code"><span class="ne-text">Object.defineProperty</span></code><span class="ne-text">设置或修改对象中的属性</span></p><pre data-language="typescript" id="hiwmH" class="ne-codeblock language-typescript"><code>interface PropertyDescriptor {
  configurable?: boolean;
  enumerable?: boolean;
  value?: any;
  writable?: boolean;
  get?(): any;
  set?(v: any): void;
}</code></pre><h3 id="lQpR4"><span class="ne-text">删除对象属性</span></h3><ul class="ne-ul"><li id="ue8b0d3cd" data-lake-index-type="0"><span class="ne-text">直接用delete，暴力简单</span></li><li id="uc28fcad7" data-lake-index-type="0"><span class="ne-text">也可以参考：</span><a href="https://segmentfault.com/q/1010000013891861" data-href="https://segmentfault.com/q/1010000013891861" target="_blank" class="ne-link"><span class="ne-text">如何优雅的删除对象中的指定属性？</span></a></li></ul><h3 id="Aliaq"><span class="ne-text">assign()</span></h3><ul class="ne-ul"><li id="u4c6a6bde" data-lake-index-type="0"><span class="ne-text">Object.assign后者覆盖前者，再返回前者</span></li><li id="u33bd510a" data-lake-index-type="0"><span class="ne-text">常用于深拷贝浅拷贝数据，如果对象的值是引用类型的数据，那么是浅拷贝</span><a href="https://www.yuque.com/wztlink1013/blog/lwi9wr" data-href="https://www.yuque.com/wztlink1013/blog/lwi9wr" class="ne-link"><span class="ne-text">https://www.yuque.com/wztlink1013/blog/lwi9wr</span></a></li></ul><h2 id="vJuVU"><span class="ne-text">对象的遍历</span></h2><p id="u9c1d2e21" class="ne-p"><a href="https://blog.csdn.net/loveoobaby/article/details/127165722" data-href="https://blog.csdn.net/loveoobaby/article/details/127165722" target="_blank" class="ne-link"><span class="ne-text">https://blog.csdn.net/loveoobaby/article/details/127165722</span></a></p><p id="u757bb833" class="ne-p"><a href="https://blog.csdn.net/loveoobaby/article/details/127165722" data-href="https://blog.csdn.net/loveoobaby/article/details/127165722" target="_blank" class="ne-link"><span class="ne-text">https://blog.csdn.net/loveoobaby/article/details/127165722</span></a></p><h3 id="yyCtR"><span class="ne-text">for...in </span></h3><div data-type="info" class="ne-alert"><p id="u49da1b9d" class="ne-p"><span class="ne-text" style="background-color: #E8F7FF">语句用于对数组或者对象的属性进行循环操作。</span></p></div><p id="uc155870c" class="ne-p"><span class="ne-text">其语法如下：</span></p><pre data-language="javascript" id="iRrmU" class="ne-codeblock language-javascript"><code>for (变量 in 对象名字) {
    // 在此执行代码
}</code></pre><ul class="ne-ul"><li id="ud155867e" data-lake-index-type="0"><span class="ne-text">语法中的变量是自定义的，它需要符合命名规范，通常我们会将这个变量写为 k 或者 key。书里面建议用const来加持。</span></li></ul><pre data-language="javascript" id="PAVgB" class="ne-codeblock language-javascript"><code>for (let k in obj) {
    console.log(k);      // 这里的 k 是属性名
    console.log(obj[k]); // 这里的 obj[k] 是属性值
}</code></pre><h3 id="Thzwk"><span class="ne-text">Object.keys(obj)</span></h3><div data-type="info" class="ne-alert"><p id="u1ab14861" class="ne-p"><span class="ne-text" style="background-color: #E8F7FF">获取属性名</span></p></div><pre data-language="javascript" id="W93F9" class="ne-codeblock language-javascript"><code>var obj = {
     id: 1,
     pname: '小米',
     price: 1999,
     num: 2000
};
var result = Object.keys(obj)
console.log(result)//[id，pname,price,num]</code></pre><h2 id="qrXFP"><span class="ne-text">参考</span></h2><ul class="ne-ul"><li id="u63206bdc" data-lake-index-type="0"><a href="https://github.com/yinguangyao/blog" data-href="https://github.com/yinguangyao/blog" class="ne-link"><span class="ne-text">https://github.com/yinguangyao/blog</span></a></li></ul></div>7:["$","div",null,{"className":"prose prose-neutral dark:prose-invert mt-8 max-w-none","dangerouslySetInnerHTML":{"__html":"$d"}}]
8:["$","$L2",null,{"delay":0.8,"fade":true,"blur":true,"transition":{"duration":0.6},"className":"-mx-4 mt-12 sm:-mx-6 lg:-mx-8","children":["$","$L6",null,{}]}]
9:["$","$L2",null,{"fade":true,"blur":true,"slide":{"direction":"up","offset":30},"delay":0.9,"transition":{"duration":0.5},"children":["$","nav",null,{"className":"mt-8 grid gap-4 md:grid-cols-2","children":[["$","$L3",null,{"href":"/blog/egols2d1kxs2","className":"hover:bg-muted group flex flex-col rounded-lg border p-4 transition-colors","children":[["$","span",null,{"className":"text-muted-foreground mb-2 text-sm","children":"上一篇"}],["$","span",null,{"className":"group-hover:text-primary line-clamp-2 font-medium transition-colors","children":"JavaScript函数及this不同场景下的指向"}]]}],["$","$L3",null,{"href":"/blog/3_day03_jquery","className":"hover:bg-muted group flex flex-col rounded-lg border p-4 text-right transition-colors md:text-right","children":[["$","span",null,{"className":"text-muted-foreground mb-2 text-sm","children":"下一篇"}],["$","span",null,{"className":"group-hover:text-primary line-clamp-2 font-medium transition-colors","children":"jQuery事件+插件"}]]}]]}]}]
a:["$","div",null,{"className":"m-6 w-full flex-1 bg-[radial-gradient(circle_at_center,color-mix(in_oklab,var(--primary)_15%,transparent)_2px,transparent_2px)] bg-size-[18px_18px] max-xl:hidden"}]
b:["$","script","script-0",{"src":"/_next/static/chunks/11dff99839ab5ba0.js","async":true}]
c:["$","$Le",null,{"children":["$","$f",null,{"name":"Next.MetadataOutlet","children":"$@10"}]}]
10:null
