1:"$Sreact.fragment"
2:I[99897,["/_next/static/chunks/4eaa70fe861e9598.js","/_next/static/chunks/946bdd2e6c9b7c49.js","/_next/static/chunks/6dd6809ee42e252f.js","/_next/static/chunks/f2b800ca7ae14e96.js","/_next/static/chunks/e121db38c98deeb4.js","/_next/static/chunks/0973dd923ca2781d.js","/_next/static/chunks/b397c2fd2abb1207.js","/_next/static/chunks/11dff99839ab5ba0.js"],"MotionPreset"]
3:I[22016,["/_next/static/chunks/4eaa70fe861e9598.js","/_next/static/chunks/946bdd2e6c9b7c49.js","/_next/static/chunks/6dd6809ee42e252f.js","/_next/static/chunks/f2b800ca7ae14e96.js","/_next/static/chunks/e121db38c98deeb4.js","/_next/static/chunks/0973dd923ca2781d.js","/_next/static/chunks/b397c2fd2abb1207.js","/_next/static/chunks/11dff99839ab5ba0.js"],""]
4:I[85437,["/_next/static/chunks/4eaa70fe861e9598.js","/_next/static/chunks/946bdd2e6c9b7c49.js","/_next/static/chunks/6dd6809ee42e252f.js","/_next/static/chunks/f2b800ca7ae14e96.js","/_next/static/chunks/e121db38c98deeb4.js","/_next/static/chunks/0973dd923ca2781d.js","/_next/static/chunks/b397c2fd2abb1207.js","/_next/static/chunks/11dff99839ab5ba0.js"],"Image"]
5:I[48347,["/_next/static/chunks/4eaa70fe861e9598.js","/_next/static/chunks/946bdd2e6c9b7c49.js","/_next/static/chunks/6dd6809ee42e252f.js","/_next/static/chunks/f2b800ca7ae14e96.js","/_next/static/chunks/e121db38c98deeb4.js","/_next/static/chunks/0973dd923ca2781d.js","/_next/static/chunks/b397c2fd2abb1207.js","/_next/static/chunks/11dff99839ab5ba0.js"],"default"]
6:I[72436,["/_next/static/chunks/4eaa70fe861e9598.js","/_next/static/chunks/946bdd2e6c9b7c49.js","/_next/static/chunks/6dd6809ee42e252f.js","/_next/static/chunks/f2b800ca7ae14e96.js","/_next/static/chunks/e121db38c98deeb4.js","/_next/static/chunks/0973dd923ca2781d.js","/_next/static/chunks/b397c2fd2abb1207.js","/_next/static/chunks/11dff99839ab5ba0.js"],"Separator"]
d:I[97367,["/_next/static/chunks/ff1a16fafef87110.js","/_next/static/chunks/7340adf74ff47ec0.js"],"OutletBoundary"]
e:"$Sreact.suspense"
7:T2d70,<!doctype html><div class="lake-content" typography="classic"><p id="598fe76c79cf4220ab7c32e59463c547" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1625064781047-2f12af3a-ce5c-4280-b387-38a40f307b45.jpeg" width="4961" id="yeGww" class="ne-image"></p><p id="f4799e2e37bd6cff1a774b72530e172e" class="ne-p"><br></p><p id="a4c64971ad367882801c73ec3d3dc979" class="ne-p"><span class="ne-text">前言：排序按照所占用的计算机内部存储设备，可以分为：</span><strong><span class="ne-text">内部排序</span></strong><span class="ne-text">和</span><strong><span class="ne-text">外部排序</span></strong></p><ul class="ne-ul"><li id="4b0aba3fe82521f2629e180cf11c0c74" data-lake-index-type="0"><strong><span class="ne-text">内部排序：</span></strong><span class="ne-text">占用的是内存，待排序序列全部放在内存加以排序处理</span></li><li id="ce7426ba9e5f35c43ed4f0e90104c7b8" data-lake-index-type="0"><strong><span class="ne-text">外部排序：</span></strong><span class="ne-text">占用的是外存，数据量比较大，内存空间不足以一次性全部容纳数据的情况</span></li></ul><p id="7f749a6f10609a76ec5fd0b57e19dd42" class="ne-p"><br></p><p id="8a996d904321b45f997b52fd816b00df" class="ne-p"><span class="ne-text">本文章 通过</span><a href="https://leetcode.cn/problems/sort-an-array/" data-href="https://leetcode.cn/problems/sort-an-array/" class="ne-link"><span class="ne-text">912. 排序数组</span></a><span class="ne-text"> 题目，以此来总结内部排序的各种排序算法。</span></p><p id="c9527610c382b4e6629792750a2166da" class="ne-p"><br></p><p id="7da58a290fd9cd6f0c506cf3e1747b3d" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1623667337022-44c54af8-5961-43d6-8fa4-46ef3f6ec71f.png" width="746" id="zJx4v" class="ne-image"></p><h2 id="qzpnY"><span class="ne-text">一、插入类排序</span></h2><p id="1c913d93d2cc9eff048644211658bd5c" class="ne-p"><span class="ne-text">将无序的子序列插入到有序序列中</span></p><h3 id="etEGl"><span class="ne-text">✅</span><span class="ne-text">直接插入</span></h3><p id="f1f5744d5e0ed7b62a44cfdc3abd8e30" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/gif/1484158/1625014050650-261f0307-6356-440f-b06a-12e264344572.gif" width="813" id="pZjWF" class="ne-image"></p><p id="d5d5ac06f356ce66f8e428f2f3582506" class="ne-p"><span class="ne-text">将元素序列走一遍，走到某个元素时，将其插入到已走过的已排序序列中，这样可以保证走完所有元素，然后所有的元素都是排序好的。</span></p><p id="94537a784913cd4dce7e158543975878" class="ne-p"><span class="ne-text">数据结构选用的时顺序表</span></p><pre data-language="javascript" id="VLea7" class="ne-codeblock language-javascript"><code>var sortArray = function (nums) {
  for (let i = 0; i &lt; nums.length; i++) {
    let flag = i
    for (let j = flag - 1; j &gt;= 0; j--) {
      if (nums[flag] &lt; nums[j]) {
        let temp = nums[j]
        nums[j] = nums[flag]
        nums[flag] = temp
        flag--
      }
    }
  }
  return nums
};</code></pre><h3 id="thpnK"><span class="ne-text">优化：折半插入</span></h3><p id="c3ffa5c0de2325e5e10b036617fee982" class="ne-p"><span class="ne-text">在直接插入的过程中，找到一个元素，然后再需要从后往前依次查找“该在”的位置，对其查找进行了折半优化</span></p><pre data-language="cpp" id="pPqb5" class="ne-codeblock language-cpp"><code>/* 折半插入排序 */
void BinsertSort(SqList &amp;S) {
    for (int i = 2; i &lt;= S.length;i++) {
        S.data[0] = S.data[i];
        int low = 1;
        int high = i - 1;
        while (low &lt;= high) {
            int m = (low + high) / 2;
            if (S.data[0]&lt;S.data[m]) high = m - 1;
            else low = m + 1;
        }
        int j;
        for (j = i - 1; j &gt;= high + 1;--j)
            S.data[j + 1] = S.data[j];
        S.data[high + 1] = S.data[0];
    }
}</code></pre><h3 id="gP6SY"><span class="ne-text">优化：希尔排序</span></h3><p id="29eea55fa2a785edf01487c47c16eabc" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/gif/1484158/1625015190376-d54ed111-aa4a-41cf-9dde-6593a6aaf4e0.gif" width="665" id="KmYb4" class="ne-image"></p><pre data-language="cpp" id="YKDS3" class="ne-codeblock language-cpp"><code>/* 希尔排序 */
void ShellInsert (SqList &amp;L, int dk) {
    for (int i = dk + 1; i &lt;= L.length;++i) {
        if (L.data[i]&lt;L.data[i-dk]) {
            L.data[0] = L.data[i];
            int j;
            for (j = i - dk; j &gt; 0 &amp;&amp; L.data[0] &lt; L.data[j]; j -= dk)
                L.data[j + dk] = L.data[j];
            L.data[j + dk] = L.data[0];
        }
    }
}
void ShellSort (SqList &amp;L, int dt[],int t) {
    for (int k = 0; k &lt; t;++k) {
        ShellInsert(L, dt[k]);
    }
}</code></pre><h2 id="B3KXE"><span class="ne-text">二、交换类排序</span></h2><h3 id="qHXfT"><span class="ne-text">✅</span><span class="ne-text">冒泡排序</span></h3><p id="38bd96910e0a0454a5262c26035fe738" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/gif/1484158/1625013969954-b7310256-1c0a-4b3c-b45b-a7b33eca8e5c.gif" width="813" id="bVJVg" class="ne-image"></p><pre data-language="typescript" id="ee8f3" class="ne-codeblock language-typescript"><code>function sortArray(nums: number[]): number[] {
  for (let i = 0; i &lt; nums.length - 1; i++) {
    for (let j = 0; j &lt; nums.length - 1 - i; j++) {
      if (nums[j] &gt; nums[j + 1]) {
        const temp = nums[j]
        nums[j] = nums[j + 1]
        nums[j + 1] = temp
      }

    }
  }
  return nums
};</code></pre><pre data-language="javascript" id="S5h81" class="ne-codeblock language-javascript"><code>var sortArray = function(nums) {
    for (let i = nums.length - 1; i&gt;0; i--) {
        for (let j = 0; j&lt;i; j++) {
            if (nums[j] &gt; nums[j+1]) {
                let temp = nums[j]
                nums[j] = nums[j+1]
                nums[j+1] = temp
            }
        }
    }
    return nums
};</code></pre><h3 id="tjRbu"><span class="ne-text">✅</span><span class="ne-text">快速排序</span></h3><p id="2abcad580b30aa89bbac80e2f52ce1d6" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/gif/1484158/1625017709918-661c5cd4-fd2a-49a0-be80-bb59b791ed8f.gif" width="811" id="jCV3S" class="ne-image"></p><pre data-language="typescript" id="Jm3De" class="ne-codeblock language-typescript"><code>function sortArray(nums: number[]): number[] {
  const rec = (arr: number[]) =&gt; {
    if (arr.length &lt;= 1) return arr
    const left = []
    const mid = arr[0]
    const right = []
    for (let i = 1; i &lt; arr.length; i++)
      (arr[i] &lt; mid ? left : right).push(arr[i])
    return [...rec(left), mid, ...rec(right)]
  }
  return rec(nums)
};</code></pre><pre data-language="cpp" id="v4tMm" class="ne-codeblock language-cpp"><code>/* 快速排序 */
int Partition (SqList &amp;L, int low, int high) {
    L.data[0] = L.data[low];
    int pivotkey = L.data[low];
    while (low &lt; high) {
        while (low&lt;high &amp;&amp; L.data[high]&gt;=pivotkey)
            --high;
        L.data[low] = L.data[high];
        while (low&lt;high &amp;&amp; L.data[low]&lt;=pivotkey)
            ++low;
        L.data[high] = L.data[low];
    }
    L.data[low] = L.data[0];
    return low;
}
void Qsort(SqList &amp;L, int low, int high) {
    if (low&lt;high){
        int pivoloc = Partition(L, low, high);
        Qsort(L, low, pivoloc - 1);
        Qsort(L, pivoloc + 1, high);
    }
}
void QuickSort(SqList &amp;L) {
    Qsort(L, 1, L.length);
}</code></pre><h2 id="vqepg"><span class="ne-text">三、选择类排序</span></h2><h3 id="Vrp7T"><span class="ne-text">✅</span><span class="ne-text">简单选择排序</span></h3><p id="d5b876da9ea6683382d3772e8c2ad53a" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/gif/1484158/1625014017576-1b58bc2d-d46b-48e8-a307-6fc6f4ee8f0a.gif" width="813" id="FeuYg" class="ne-image"></p><pre data-language="javascript" id="UCc3U" class="ne-codeblock language-javascript"><code>var sortArray = function (nums) {
  for (let i = 0; i &lt; nums.length - 1; i++) {
    for (let j = i + 1; j &lt; nums.length; j++) {
      if (nums[i] &gt; nums[j]) {
        const temp = nums[j]
        nums[j] = nums[i]
        nums[i] = temp
      }
    }
  }
  return nums
};</code></pre><h3 id="8Zesn"><span class="ne-text">树形选择排序</span></h3><p id="96b4ae1229b083e76e8eb148c07e0084" class="ne-p"><br></p><h3 id="Ry3ha"><span class="ne-text">堆排序</span></h3><p id="27bd8e77d511f4282b5bf855ef57d576" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/gif/1484158/1625021691601-c1572503-c54d-4d12-8d3e-97da2ae0aa38.gif" width="547" id="b5jeQ" class="ne-image"></p><h2 id="wYfdM"><span class="ne-text">四、归并排序</span></h2><h3 id="iJ1Mt"><span class="ne-text">✅</span><span class="ne-text">直接归并</span></h3><div id="u4d8c4ad6-99cc-4906-ab3c-95df4d8706c" class="ne-bookmark"><a href="https://www.yuque.com/wztlink1013/blog/ab9fkt" target="_blank">https://www.yuque.com/wztlink1013/blog/ab9fkt</a></div><pre data-language="javascript" id="m6IPt" class="ne-codeblock language-javascript"><code>var sortArray = function (nums) {
  const rec = (arr) =&gt; {
    if (arr.length === 1) return arr
    const mid = Math.floor(arr.length / 2)
    const left = arr.slice(0, mid)
    const right = arr.slice(mid, mid.length)
    const orderLeft = rec(left)
    const orderRight = rec(right)
    const res = []
    while (orderLeft.length || orderRight.length) {
      if (orderLeft.length &amp;&amp; orderRight.length) {
        res.push(orderLeft[0] &gt; orderRight[0] ? orderRight.shift() : orderLeft.shift())
      } else if (orderLeft.length) {
        res.push(orderLeft.shift())
      } else if (orderRight.length) {
        res.push(orderRight.shift())
      }
    }
    return res
  }
  return rec(nums)
};</code></pre><h3 id="NMBwV"><span class="ne-text">2-路归并排序</span></h3><p id="ea33608f775147ff8f17087962c9765e" class="ne-p"><span class="ne-text">给定一个序列，从左往右两两子序列进行归并</span></p><p id="6c0a75ff9d8bbfc8288fa678954e5fc6" class="ne-p"><br></p><p id="b8819e93c9172046b1309ff544c4fe6f" class="ne-p"><span class="ne-text">子序列归并的算法：加入有两个靠着的a、b序列，由上面可知，a、b各自都是有序序列，现在就是将这两个合并为一个有序序列k，将a和b序列的各个元素进行比较，小的依次放入k序列，当a、b两个中有一个序列为空了，就将那个不为空的序列直接加入到k序列即可，最后k序列就是目的序列。</span></p><p id="557d9af01136329dd59b2fa7244f3275" class="ne-p"><br></p><p id="461f6d5fc01208d120906ab21346aa22" class="ne-p"><br></p><h2 id="FZipi"><span class="ne-text">五、分配类排序</span></h2><h3 id="Qx2Q5"><span class="ne-text">基数排序</span></h3><p id="353887e2cdc59884fedc11e96e262efc" class="ne-p"><span class="ne-text">TODO: 扑克牌的花色排序</span></p><h2 id="HtSzO"><span class="ne-text">TODO: 六、外部排序</span></h2><h3 id="CTOql"><span class="ne-text">基本方法</span></h3><h3 id="69w00"><span class="ne-text">多路平衡归并</span></h3><p id="862b47dd7bfc84c631f63adff5eb7698" class="ne-p"><span class="ne-text">基本思想是内部排序中的2-路归并排序</span></p><h3 id="MbQii"><span class="ne-text">置换-选择排序</span></h3><h3 id="AFobc"><span class="ne-text">最佳归并树</span></h3></div>0:{"buildId":"fgnevoCcv3TjAYBn9b4Wj","rsc":["$","$1","c",{"children":[["$","section",null,{"className":"relative","children":["$","$L2",null,{"fade":true,"blur":true,"transition":{"duration":0.5},"delay":0.1,"className":"relative overflow-hidden border-y xl:flex","children":[["$","div",null,{"className":"m-6 w-full flex-1 bg-[radial-gradient(circle_at_center,color-mix(in_oklab,var(--primary)_15%,transparent)_2px,transparent_2px)] bg-size-[18px_18px] max-xl:hidden"}],["$","div",null,{"className":"mx-auto w-full max-w-6xl flex-none space-y-8 px-4 py-8 min-[1158px]:border-x sm:px-6 sm:py-12 lg:px-8","children":[["$","$L2",null,{"fade":true,"blur":true,"slide":{"direction":"down","offset":30},"transition":{"duration":0.4},"children":["$","$L3",null,{"href":"/blog","className":"text-muted-foreground hover:text-foreground inline-flex items-center gap-2 text-sm transition-colors","children":[["$","svg",null,{"xmlns":"http://www.w3.org/2000/svg","width":24,"height":24,"viewBox":"0 0 24 24","fill":"none","stroke":"currentColor","strokeWidth":2,"strokeLinecap":"round","strokeLinejoin":"round","className":"lucide lucide-arrow-left h-4 w-4","aria-hidden":"true","children":[["$","path","1l729n",{"d":"m12 19-7-7 7-7"}],["$","path","x3x0zl",{"d":"M19 12H5"}],"$undefined"]}],"返回","技术博客"]}]}],["$","article",null,{"className":"mx-auto max-w-4xl","children":[["$","header",null,{"className":"mb-8 space-y-6","children":[["$","$L2",null,{"fade":true,"blur":true,"slide":{"direction":"up","offset":50},"delay":0.2,"transition":{"duration":0.6},"children":["$","div",null,{"className":"relative aspect-video overflow-hidden rounded-xl","children":["$","$L4",null,{"src":"https://cdn.nlark.com/yuque/0/2021/png/1484158/1623667337022-44c54af8-5961-43d6-8fa4-46ef3f6ec71f.png","alt":"各类排序算法汇总","fill":true,"className":"object-cover","unoptimized":true}]}]}],["$","$L2",null,{"delay":0.3,"transition":{"duration":0.5},"children":["$","h1",null,{"className":"text-2xl font-bold tracking-tight sm:text-3xl md:text-4xl","children":["$","$L5",null,{"text":"各类排序算法汇总","delay":30,"animateBy":"words","direction":"bottom"}]}]}],["$","$L2",null,{"fade":true,"blur":true,"slide":{"direction":"down","offset":30},"delay":0.4,"transition":{"duration":0.5},"children":["$","p",null,{"className":"text-muted-foreground text-lg","children":"前言：排序按照所占用的计算机内部存储设备，可以分为：内部排序和外部排序内部排序：占用的是内存，待排序序列全部放在内存加以排序处理外部排序：占用的是外存，数据量比较大，内存空间不足以一次性全部容纳数据的情况本文章 通过912. 排序数组 题目，以此来总结内部排序的各种排序算法。一、插入类排序将无..."}]}],["$","$L2",null,{"fade":true,"blur":true,"slide":{"direction":"down","offset":30},"delay":0.5,"transition":{"duration":0.5},"children":["$","div",null,{"className":"text-muted-foreground flex flex-wrap items-center gap-4 text-sm","children":[["$","div",null,{"className":"flex items-center gap-1","children":[["$","svg",null,{"xmlns":"http://www.w3.org/2000/svg","width":24,"height":24,"viewBox":"0 0 24 24","fill":"none","stroke":"currentColor","strokeWidth":2,"strokeLinecap":"round","strokeLinejoin":"round","className":"lucide lucide-calendar h-4 w-4","aria-hidden":"true","children":[["$","path","1cmpym",{"d":"M8 2v4"}],["$","path","4m81vk",{"d":"M16 2v4"}],["$","rect","1hopcy",{"width":"18","height":"18","x":"3","y":"4","rx":"2"}],["$","path","8toen8",{"d":"M3 10h18"}],"$undefined"]}],["$","span",null,{"children":"2024年1月21日"}]]}],["$","div",null,{"className":"flex items-center gap-1","children":[["$","svg",null,{"xmlns":"http://www.w3.org/2000/svg","width":24,"height":24,"viewBox":"0 0 24 24","fill":"none","stroke":"currentColor","strokeWidth":2,"strokeLinecap":"round","strokeLinejoin":"round","className":"lucide lucide-clock h-4 w-4","aria-hidden":"true","children":[["$","path","mmk7yg",{"d":"M12 6v6l4 2"}],["$","circle","1mglay",{"cx":"12","cy":"12","r":"10"}],"$undefined"]}],["$","span",null,{"children":"1.2千字"}]]}],["$","div",null,{"className":"flex items-center gap-1","children":[["$","svg",null,{"xmlns":"http://www.w3.org/2000/svg","width":24,"height":24,"viewBox":"0 0 24 24","fill":"none","stroke":"currentColor","strokeWidth":2,"strokeLinecap":"round","strokeLinejoin":"round","className":"lucide lucide-eye h-4 w-4","aria-hidden":"true","children":[["$","path","1nclc0",{"d":"M2.062 12.348a1 1 0 0 1 0-.696 10.75 10.75 0 0 1 19.876 0 1 1 0 0 1 0 .696 10.75 10.75 0 0 1-19.876 0"}],["$","circle","1v7zrd",{"cx":"12","cy":"12","r":"3"}],"$undefined"]}],["$","span",null,{"children":[9," 阅读"]}]]}],false,false]}]}],false]}],["$","$L2",null,{"delay":0.6,"fade":true,"blur":true,"transition":{"duration":0.6},"className":"-mx-4 sm:-mx-6 lg:-mx-8","children":["$","$L6",null,{}]}],["$","$L2",null,{"fade":true,"blur":true,"slide":{"direction":"up","offset":50},"delay":0.7,"transition":{"duration":0.6},"children":["$","div",null,{"className":"prose prose-neutral dark:prose-invert mt-8 max-w-none","dangerouslySetInnerHTML":{"__html":"$7"}}]}],"$L8","$L9"]}]]}],"$La"]}]}],["$Lb"],"$Lc"]}],"loading":null,"isPartial":false}
8:["$","$L2",null,{"delay":0.8,"fade":true,"blur":true,"transition":{"duration":0.6},"className":"-mx-4 mt-12 sm:-mx-6 lg:-mx-8","children":["$","$L6",null,{}]}]
9:["$","$L2",null,{"fade":true,"blur":true,"slide":{"direction":"up","offset":30},"delay":0.9,"transition":{"duration":0.5},"children":["$","nav",null,{"className":"mt-8 grid gap-4 md:grid-cols-2","children":[["$","$L3",null,{"href":"/blog/tn3fhp","className":"hover:bg-muted group flex flex-col rounded-lg border p-4 transition-colors","children":[["$","span",null,{"className":"text-muted-foreground mb-2 text-sm","children":"上一篇"}],["$","span",null,{"className":"group-hover:text-primary line-clamp-2 font-medium transition-colors","children":"数字电路总结"}]]}],["$","$L3",null,{"href":"/blog/rxx0ab","className":"hover:bg-muted group flex flex-col rounded-lg border p-4 text-right transition-colors md:text-right","children":[["$","span",null,{"className":"text-muted-foreground mb-2 text-sm","children":"下一篇"}],["$","span",null,{"className":"group-hover:text-primary line-clamp-2 font-medium transition-colors","children":"最短路径算法（Dijkstra+Floyd）"}]]}]]}]}]
a:["$","div",null,{"className":"m-6 w-full flex-1 bg-[radial-gradient(circle_at_center,color-mix(in_oklab,var(--primary)_15%,transparent)_2px,transparent_2px)] bg-size-[18px_18px] max-xl:hidden"}]
b:["$","script","script-0",{"src":"/_next/static/chunks/11dff99839ab5ba0.js","async":true}]
c:["$","$Ld",null,{"children":["$","$e",null,{"name":"Next.MetadataOutlet","children":"$@f"}]}]
f:null
