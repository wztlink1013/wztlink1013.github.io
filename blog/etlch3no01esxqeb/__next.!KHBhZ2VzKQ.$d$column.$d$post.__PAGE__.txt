1:"$Sreact.fragment"
2:I[99897,["/_next/static/chunks/4eaa70fe861e9598.js","/_next/static/chunks/946bdd2e6c9b7c49.js","/_next/static/chunks/6dd6809ee42e252f.js","/_next/static/chunks/f2b800ca7ae14e96.js","/_next/static/chunks/e121db38c98deeb4.js","/_next/static/chunks/0973dd923ca2781d.js","/_next/static/chunks/b397c2fd2abb1207.js","/_next/static/chunks/11dff99839ab5ba0.js"],"MotionPreset"]
3:I[22016,["/_next/static/chunks/4eaa70fe861e9598.js","/_next/static/chunks/946bdd2e6c9b7c49.js","/_next/static/chunks/6dd6809ee42e252f.js","/_next/static/chunks/f2b800ca7ae14e96.js","/_next/static/chunks/e121db38c98deeb4.js","/_next/static/chunks/0973dd923ca2781d.js","/_next/static/chunks/b397c2fd2abb1207.js","/_next/static/chunks/11dff99839ab5ba0.js"],""]
4:I[48347,["/_next/static/chunks/4eaa70fe861e9598.js","/_next/static/chunks/946bdd2e6c9b7c49.js","/_next/static/chunks/6dd6809ee42e252f.js","/_next/static/chunks/f2b800ca7ae14e96.js","/_next/static/chunks/e121db38c98deeb4.js","/_next/static/chunks/0973dd923ca2781d.js","/_next/static/chunks/b397c2fd2abb1207.js","/_next/static/chunks/11dff99839ab5ba0.js"],"default"]
5:I[72436,["/_next/static/chunks/4eaa70fe861e9598.js","/_next/static/chunks/946bdd2e6c9b7c49.js","/_next/static/chunks/6dd6809ee42e252f.js","/_next/static/chunks/f2b800ca7ae14e96.js","/_next/static/chunks/e121db38c98deeb4.js","/_next/static/chunks/0973dd923ca2781d.js","/_next/static/chunks/b397c2fd2abb1207.js","/_next/static/chunks/11dff99839ab5ba0.js"],"Separator"]
c:I[97367,["/_next/static/chunks/ff1a16fafef87110.js","/_next/static/chunks/7340adf74ff47ec0.js"],"OutletBoundary"]
d:"$Sreact.suspense"
6:T2a0c,<!doctype html><div class="lake-content" typography="classic"><p id="u45147d29" class="ne-p"><span class="ne-text">响应式</span></p><ul class="ne-ul"><li id="udc10b1c5" data-lake-index-type="0"><span class="ne-text">vue通过响应式机制来进行更新</span></li><li id="u0f2c0474" data-lake-index-type="0"><span class="ne-text">react需要手动setState进行状态变化</span></li></ul><p id="uaab9f63e" class="ne-p"><span class="ne-text">单向数据流：两者都遵循，只不过vue有相关实现的语法糖</span></p><ul class="ne-ul"><li id="u74676cb3" data-lake-index-type="0"><span class="ne-text">vue会有v-modal的语法糖来自实现双向绑定（props+$emits）</span></li><li id="u0f2d9329" data-lake-index-type="0"><span class="ne-text">而react没有官方实现，如需实现也是通过props+onValueChange回调函数实现</span></li></ul><p id="ufbaf3212" class="ne-p"><span class="ne-text">不可变数据</span></p><ul class="ne-ul"><li id="u7bf9c200" data-lake-index-type="0"><span class="ne-text">都不能直接修改对象内容</span></li></ul><p id="u1dcd0d41" class="ne-p"><span class="ne-text"></span></p><p id="u02f411b3" class="ne-p"><span class="ne-text">以下是Vue3和React18在具体使用层面的核心技巧对比，结合两者最新特性及最佳实践进行总结：</span></p><hr id="bsgRJ" class="ne-hr"><h3 id="vzGAN"><strong><span class="ne-text">一、Vue3高效开发技巧</span></strong></h3><h4 id="dgCbi"><strong><span class="ne-text">1. 组合式API + script setup语法</span></strong></h4><ul class="ne-ul"><li id="u7cc495e2" data-lake-index-type="0"><strong><span class="ne-text">技巧</span></strong><span class="ne-text">：使用</span><code class="ne-code"><span class="ne-text">&lt;script setup&gt;</span></code><span class="ne-text">语法糖简化组件定义，自动暴露顶层变量和方法，减少样板代码。  </span></li></ul><pre data-language="vue" id="cwpnO" class="ne-codeblock language-vue"><code>&lt;script setup&gt;
import { ref } from 'vue'
const count = ref(0)
const increment = () =&gt; count.value++
&lt;/script&gt;
</code></pre><ul class="ne-ul"><li id="u3219fd94" data-lake-index-type="0"><strong><span class="ne-text">优势</span></strong><span class="ne-text">：代码更简洁，逻辑复用更灵活（通过Hooks封装）。</span></li></ul><h4 id="mWpvc"><strong><span class="ne-text">2. 响应式数据解构与优化</span></strong></h4><ul class="ne-ul"><li id="u94b274a1" data-lake-index-type="0"><strong><span class="ne-text">技巧</span></strong><span class="ne-text">：使用</span><code class="ne-code"><span class="ne-text">toRefs</span></code><span class="ne-text">解构响应式对象，避免丢失响应性。  </span></li></ul><pre data-language="javascript" id="T5sQD" class="ne-codeblock language-javascript"><code>const state = reactive({ a: 1, b: 2 })
const { a, b } = toRefs(state) // 保持响应式</code></pre><ul class="ne-ul"><li id="ua75df96a" data-lake-index-type="0"><strong><span class="ne-text">场景</span></strong><span class="ne-text">：父组件传递props时解构后仍可响应。</span></li></ul><h4 id="Ok2BE"><strong><span class="ne-text">3. 事件叠加透传</span></strong></h4><ul class="ne-ul"><li id="u95bfe2b0" data-lake-index-type="0"><strong><span class="ne-text">技巧</span></strong><span class="ne-text">：多层嵌套组件中，子组件通过</span><code class="ne-code"><span class="ne-text">v-bind=&quot;$attrs&quot;</span></code><span class="ne-text">透传事件，无需逐层</span><code class="ne-code"><span class="ne-text">emit</span></code><span class="ne-text">。  </span></li></ul><pre data-language="vue" id="y6YHZ" class="ne-codeblock language-vue"><code>&lt;!-- 父组件 --&gt;
&lt;Child @click=&quot;handleClick&quot; /&gt;
&lt;!-- 子组件无需声明emit，直接透传 --&gt;
&lt;GrandChild v-bind=&quot;$attrs&quot; /&gt;</code></pre><ul class="ne-ul"><li id="uab8681c7" data-lake-index-type="0"><strong><span class="ne-text">适用</span></strong><span class="ne-text">：二次封装基础组件（如表格、弹窗）时减少代码量。</span></li></ul><h4 id="ZmfQ8"><strong><span class="ne-text">4. 组件DOM操作优化</span></strong></h4><ul class="ne-ul"><li id="u2ffcdf8e" data-lake-index-type="0"><strong><span class="ne-text">技巧</span></strong><span class="ne-text">：利用</span><code class="ne-code"><span class="ne-text">Teleport</span></code><span class="ne-text">将组件渲染到任意DOM节点，解决层叠上下文问题。  </span></li></ul><pre data-language="vue" id="PopIv" class="ne-codeblock language-vue"><code>&lt;Teleport to=&quot;body&quot;&gt;
  &lt;Modal v-if=&quot;show&quot; /&gt;
&lt;/Teleport&gt;
</code></pre><ul class="ne-ul"><li id="u1660e044" data-lake-index-type="0"><strong><span class="ne-text">场景</span></strong><span class="ne-text">：全局弹窗、通知提示等。</span></li></ul><hr id="cFV3P" class="ne-hr"><h3 id="UrphX"><strong><span class="ne-text">二、React18性能优化技巧</span></strong></h3><h4 id="qXtIU"><strong><span class="ne-text">1. 并发模式与优先级控制</span></strong></h4><ul class="ne-ul"><li id="u63d54fe2" data-lake-index-type="0"><strong><span class="ne-text">技巧</span></strong><span class="ne-text">：使用</span><code class="ne-code"><span class="ne-text">startTransition</span></code><span class="ne-text">标记非紧急更新，避免界面卡顿。  </span></li></ul><pre data-language="javascript" id="CzNaA" class="ne-codeblock language-javascript"><code>import { startTransition } from 'react';
const handleInput = (e) =&gt; {
  setInputValue(e.target.value); // 紧急更新
  startTransition(() =&gt; {
    setSearchResults(filterData(e.target.value)); // 非紧急更新
  });
};</code></pre><ul class="ne-ul"><li id="ufa971e0f" data-lake-index-type="0"><strong><span class="ne-text">优势</span></strong><span class="ne-text">：优先响应用户交互，提升流畅度。</span></li></ul><h4 id="AwzNT"><strong><span class="ne-text">2. 自动批处理减少渲染次数</span></strong></h4><ul class="ne-ul"><li id="u68af5152" data-lake-index-type="0"><strong><span class="ne-text">技巧</span></strong><span class="ne-text">：React18默认对异步操作（如Promise、setTimeout）中的状态更新进行批处理。  </span></li></ul><pre data-language="javascript" id="MT7cT" class="ne-codeblock language-javascript"><code>fetchData().then(() =&gt; {
  setA(1);
  setB(2); // 仅触发一次渲染
});</code></pre><ul class="ne-ul"><li id="uc967962e" data-lake-index-type="0"><strong><span class="ne-text">例外</span></strong><span class="ne-text">：需立即更新时可使用</span><code class="ne-code"><span class="ne-text">flushSync</span></code><span class="ne-text">强制同步渲染。</span></li></ul><h4 id="NVvP9"><strong><span class="ne-text">3. Suspense异步加载优化</span></strong></h4><ul class="ne-ul"><li id="u3b17e9d1" data-lake-index-type="0"><strong><span class="ne-text">技巧</span></strong><span class="ne-text">：配合</span><code class="ne-code"><span class="ne-text">lazy</span></code><span class="ne-text">实现代码分割，展示加载状态。  </span></li></ul><pre data-language="javascript" id="hlwEn" class="ne-codeblock language-javascript"><code>const LazyComponent = lazy(() =&gt; import('./Component'));
function App() {
  return (
    &lt;Suspense fallback={&lt;Loading /&gt;}&gt;
      &lt;LazyComponent /&gt;
    &lt;/Suspense&gt;
  );
}</code></pre><ul class="ne-ul"><li id="u056a1abd" data-lake-index-type="0"><strong><span class="ne-text">适用</span></strong><span class="ne-text">：路由懒加载、动态导入模块。</span></li></ul><h4 id="gqCqT"><strong><span class="ne-text">4. 新API提升开发体验</span></strong></h4><ul class="ne-ul"><li id="ua707207e" data-lake-index-type="0"><strong><span class="ne-text">useId</span></strong><span class="ne-text">：生成唯一ID避免服务端/客户端渲染不一致。  </span></li></ul><pre data-language="javascript" id="RLV54" class="ne-codeblock language-javascript"><code>const id = useId(); // 输出类似 :r1:</code></pre><ul class="ne-ul"><li id="u31767675" data-lake-index-type="0"><strong><span class="ne-text">useDeferredValue</span></strong><span class="ne-text">：延迟更新非关键UI，如搜索联想词。</span></li></ul><hr id="n24aO" class="ne-hr"><h3 id="WqgSE"><strong><span class="ne-text">三、框架选择建议</span></strong></h3><table id="Tnn37" class="ne-table" style="width: 750px"><tbody><tr style="height: 33px"><td width="250"><p id="u07c8ce27" class="ne-p"><strong><span class="ne-text">场景</span></strong></p></td><td width="250"><p id="udf0e040d" class="ne-p"><strong><span class="ne-text">推荐框架</span></strong></p></td><td width="250"><p id="u20c7d195" class="ne-p"><strong><span class="ne-text">核心理由</span></strong></p></td></tr><tr style="height: 33px"><td width="250"><p id="ue9a69559" class="ne-p"><span class="ne-text">快速开发中小型项目</span></p></td><td width="250"><p id="u067a3ee2" class="ne-p"><span class="ne-text">Vue3</span></p></td><td width="250"><p id="u6422b404" class="ne-p"><span class="ne-text">语法简洁，响应式系统开箱即用</span></p></td></tr><tr style="height: 37px"><td width="250"><p id="u9e6fef0d" class="ne-p"><span class="ne-text">复杂状态管理与高并发场景</span></p></td><td width="250"><p id="u8da290c2" class="ne-p"><span class="ne-text">React18</span></p></td><td width="250"><p id="u6d964629" class="ne-p"><span class="ne-text">并发渲染、精细优先级控制</span></p></td></tr><tr style="height: 33px"><td width="250"><p id="u107d2564" class="ne-p"><span class="ne-text">跨平台开发需求</span></p></td><td width="250"><p id="ud3bb07f6" class="ne-p"><span class="ne-text">React18</span></p></td><td width="250"><p id="uefb91d85" class="ne-p"><span class="ne-text">React Native生态成熟</span></p></td></tr></tbody></table><hr id="j6DuB" class="ne-hr"><h3 id="pHi7v"><strong><span class="ne-text">总结</span></strong></h3><ul class="ne-ul"><li id="u9bbe4f7e" data-lake-index-type="0"><strong><span class="ne-text">Vue3</span></strong><span class="ne-text">：通过组合式API和语法糖提升开发效率，适合快速迭代；  </span></li><li id="u23cea69a" data-lake-index-type="0"><strong><span class="ne-text">React18</span></strong><span class="ne-text">：以并发模式为核心优化性能，适合大型复杂应用。<br />两者技巧差异本质是设计哲学的体现：Vue强调约定简化，React追求灵活控制。实际开发中可结合项目需求选择，甚至混合使用（如Vue项目引入React Native）。</span></li></ul></div>0:{"buildId":"fgnevoCcv3TjAYBn9b4Wj","rsc":["$","$1","c",{"children":[["$","section",null,{"className":"relative","children":["$","$L2",null,{"fade":true,"blur":true,"transition":{"duration":0.5},"delay":0.1,"className":"relative overflow-hidden border-y xl:flex","children":[["$","div",null,{"className":"m-6 w-full flex-1 bg-[radial-gradient(circle_at_center,color-mix(in_oklab,var(--primary)_15%,transparent)_2px,transparent_2px)] bg-size-[18px_18px] max-xl:hidden"}],["$","div",null,{"className":"mx-auto w-full max-w-6xl flex-none space-y-8 px-4 py-8 min-[1158px]:border-x sm:px-6 sm:py-12 lg:px-8","children":[["$","$L2",null,{"fade":true,"blur":true,"slide":{"direction":"down","offset":30},"transition":{"duration":0.4},"children":["$","$L3",null,{"href":"/blog","className":"text-muted-foreground hover:text-foreground inline-flex items-center gap-2 text-sm transition-colors","children":[["$","svg",null,{"xmlns":"http://www.w3.org/2000/svg","width":24,"height":24,"viewBox":"0 0 24 24","fill":"none","stroke":"currentColor","strokeWidth":2,"strokeLinecap":"round","strokeLinejoin":"round","className":"lucide lucide-arrow-left h-4 w-4","aria-hidden":"true","children":[["$","path","1l729n",{"d":"m12 19-7-7 7-7"}],["$","path","x3x0zl",{"d":"M19 12H5"}],"$undefined"]}],"返回","技术博客"]}]}],["$","article",null,{"className":"mx-auto max-w-4xl","children":[["$","header",null,{"className":"mb-8 space-y-6","children":["",["$","$L2",null,{"delay":0.3,"transition":{"duration":0.5},"children":["$","h1",null,{"className":"text-2xl font-bold tracking-tight sm:text-3xl md:text-4xl","children":["$","$L4",null,{"text":"vue和react部分使用技巧","delay":30,"animateBy":"words","direction":"bottom"}]}]}],["$","$L2",null,{"fade":true,"blur":true,"slide":{"direction":"down","offset":30},"delay":0.4,"transition":{"duration":0.5},"children":["$","p",null,{"className":"text-muted-foreground text-lg","children":"响应式vue通过响应式机制来进行更新react需要手动setState进行状态变化单向数据流：两者都遵循，只不过vue有相关实现的语法糖vue会有v-modal的语法糖来自实现双向绑定（props+$emits）而react没有官方实现，如需实现也是通过props+onValueChange回..."}]}],["$","$L2",null,{"fade":true,"blur":true,"slide":{"direction":"down","offset":30},"delay":0.5,"transition":{"duration":0.5},"children":["$","div",null,{"className":"text-muted-foreground flex flex-wrap items-center gap-4 text-sm","children":[["$","div",null,{"className":"flex items-center gap-1","children":[["$","svg",null,{"xmlns":"http://www.w3.org/2000/svg","width":24,"height":24,"viewBox":"0 0 24 24","fill":"none","stroke":"currentColor","strokeWidth":2,"strokeLinecap":"round","strokeLinejoin":"round","className":"lucide lucide-calendar h-4 w-4","aria-hidden":"true","children":[["$","path","1cmpym",{"d":"M8 2v4"}],["$","path","4m81vk",{"d":"M16 2v4"}],["$","rect","1hopcy",{"width":"18","height":"18","x":"3","y":"4","rx":"2"}],["$","path","8toen8",{"d":"M3 10h18"}],"$undefined"]}],["$","span",null,{"children":"2025年3月21日"}]]}],["$","div",null,{"className":"flex items-center gap-1","children":[["$","svg",null,{"xmlns":"http://www.w3.org/2000/svg","width":24,"height":24,"viewBox":"0 0 24 24","fill":"none","stroke":"currentColor","strokeWidth":2,"strokeLinecap":"round","strokeLinejoin":"round","className":"lucide lucide-clock h-4 w-4","aria-hidden":"true","children":[["$","path","mmk7yg",{"d":"M12 6v6l4 2"}],["$","circle","1mglay",{"cx":"12","cy":"12","r":"10"}],"$undefined"]}],["$","span",null,{"children":"951字"}]]}],false,false,false]}]}],false]}],["$","$L2",null,{"delay":0.6,"fade":true,"blur":true,"transition":{"duration":0.6},"className":"-mx-4 sm:-mx-6 lg:-mx-8","children":["$","$L5",null,{}]}],["$","$L2",null,{"fade":true,"blur":true,"slide":{"direction":"up","offset":50},"delay":0.7,"transition":{"duration":0.6},"children":["$","div",null,{"className":"prose prose-neutral dark:prose-invert mt-8 max-w-none","dangerouslySetInnerHTML":{"__html":"$6"}}]}],"$L7","$L8"]}]]}],"$L9"]}]}],["$La"],"$Lb"]}],"loading":null,"isPartial":false}
7:["$","$L2",null,{"delay":0.8,"fade":true,"blur":true,"transition":{"duration":0.6},"className":"-mx-4 mt-12 sm:-mx-6 lg:-mx-8","children":["$","$L5",null,{}]}]
8:["$","$L2",null,{"fade":true,"blur":true,"slide":{"direction":"up","offset":30},"delay":0.9,"transition":{"duration":0.5},"children":["$","nav",null,{"className":"mt-8 grid gap-4 md:grid-cols-2","children":[["$","$L3",null,{"href":"/blog/kxrg5vchoxo30zgf","className":"hover:bg-muted group flex flex-col rounded-lg border p-4 transition-colors","children":[["$","span",null,{"className":"text-muted-foreground mb-2 text-sm","children":"上一篇"}],["$","span",null,{"className":"group-hover:text-primary line-clamp-2 font-medium transition-colors","children":"vue源码新调试方式"}]]}],["$","$L3",null,{"href":"/blog/yigw1rdewgietgr8","className":"hover:bg-muted group flex flex-col rounded-lg border p-4 text-right transition-colors md:text-right","children":[["$","span",null,{"className":"text-muted-foreground mb-2 text-sm","children":"下一篇"}],["$","span",null,{"className":"group-hover:text-primary line-clamp-2 font-medium transition-colors","children":"vscode和edge浏览器等鼠标输入光标变透明"}]]}]]}]}]
9:["$","div",null,{"className":"m-6 w-full flex-1 bg-[radial-gradient(circle_at_center,color-mix(in_oklab,var(--primary)_15%,transparent)_2px,transparent_2px)] bg-size-[18px_18px] max-xl:hidden"}]
a:["$","script","script-0",{"src":"/_next/static/chunks/11dff99839ab5ba0.js","async":true}]
b:["$","$Lc",null,{"children":["$","$d",null,{"name":"Next.MetadataOutlet","children":"$@e"}]}]
e:null
