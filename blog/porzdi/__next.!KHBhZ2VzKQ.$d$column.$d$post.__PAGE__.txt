1:"$Sreact.fragment"
2:I[99897,["/_next/static/chunks/4eaa70fe861e9598.js","/_next/static/chunks/fa1a8f8830b9bf3a.js","/_next/static/chunks/6dd6809ee42e252f.js","/_next/static/chunks/f2b800ca7ae14e96.js","/_next/static/chunks/e121db38c98deeb4.js","/_next/static/chunks/6d971f5a9c16d0c2.js","/_next/static/chunks/b397c2fd2abb1207.js","/_next/static/chunks/11dff99839ab5ba0.js"],"MotionPreset"]
3:I[22016,["/_next/static/chunks/4eaa70fe861e9598.js","/_next/static/chunks/fa1a8f8830b9bf3a.js","/_next/static/chunks/6dd6809ee42e252f.js","/_next/static/chunks/f2b800ca7ae14e96.js","/_next/static/chunks/e121db38c98deeb4.js","/_next/static/chunks/6d971f5a9c16d0c2.js","/_next/static/chunks/b397c2fd2abb1207.js","/_next/static/chunks/11dff99839ab5ba0.js"],""]
4:I[85437,["/_next/static/chunks/4eaa70fe861e9598.js","/_next/static/chunks/fa1a8f8830b9bf3a.js","/_next/static/chunks/6dd6809ee42e252f.js","/_next/static/chunks/f2b800ca7ae14e96.js","/_next/static/chunks/e121db38c98deeb4.js","/_next/static/chunks/6d971f5a9c16d0c2.js","/_next/static/chunks/b397c2fd2abb1207.js","/_next/static/chunks/11dff99839ab5ba0.js"],"Image"]
5:I[48347,["/_next/static/chunks/4eaa70fe861e9598.js","/_next/static/chunks/fa1a8f8830b9bf3a.js","/_next/static/chunks/6dd6809ee42e252f.js","/_next/static/chunks/f2b800ca7ae14e96.js","/_next/static/chunks/e121db38c98deeb4.js","/_next/static/chunks/6d971f5a9c16d0c2.js","/_next/static/chunks/b397c2fd2abb1207.js","/_next/static/chunks/11dff99839ab5ba0.js"],"default"]
6:I[72436,["/_next/static/chunks/4eaa70fe861e9598.js","/_next/static/chunks/fa1a8f8830b9bf3a.js","/_next/static/chunks/6dd6809ee42e252f.js","/_next/static/chunks/f2b800ca7ae14e96.js","/_next/static/chunks/e121db38c98deeb4.js","/_next/static/chunks/6d971f5a9c16d0c2.js","/_next/static/chunks/b397c2fd2abb1207.js","/_next/static/chunks/11dff99839ab5ba0.js"],"Separator"]
d:I[97367,["/_next/static/chunks/ff1a16fafef87110.js","/_next/static/chunks/7340adf74ff47ec0.js"],"OutletBoundary"]
e:"$Sreact.suspense"
7:Ta8e5,<!doctype html><div class="lake-content" typography="classic"><div class="ne-quote"><p id="b174f416224bd7d428d5952653d786f8" class="ne-p"><span class="ne-text">大部分文字内容转载自：</span><a href="https://blog.csdn.net/weixin_43844677/article/details/104902417" data-href="https://blog.csdn.net/weixin_43844677/article/details/104902417" target="_blank" class="ne-link"><span class="ne-text">竞赛常用STL容器详解</span></a></p><p id="u869b6a94" class="ne-p"><span class="ne-text">部分内容个人修改补充。</span></p></div><p id="e5c401f15f8c481887594e6e60a99c11" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1626175209711-5b013be3-5942-4a0a-b9ce-529a73668d94.jpeg" width="360" id="rFa1j" class="ne-image"></p><h2 id="FsIvq"><span class="ne-text">一、 概述</span></h2><p id="9325e5cb1f074bb346e4d4351260b24c" class="ne-p"><span class="ne-text">在算法竞赛中，使用C++语言的占很大比例，而几乎没有人使用C语言，其中核心的原因就是C++包含STL容器库，能够极大地减少选手在赛场上为了一些基础数据结构而浪费的时间。诚然，花一两分钟实现一个stack、queue甚至priority_queue都不是什么大问题，但如果需要实现BBST（Balanced Binary Search Tree）的情况呢？如果可以的话，我们总是希望不要手写红黑树、动态数组的。那么STL容器库的出现就像雪中送炭一样了。它们覆盖了竞赛中最基础的需要（张昆玮树、主席树这种东西肯定不会包含的），让你在面对非数据结构题的时候能够不因数据结构部分的代码而分心。</span></p><p id="46bd6ff3ccf301afd671dccb15832982" class="ne-p"><span class="ne-text"></span></p><p id="97da7fcd9472789cd12c279999442d4a" class="ne-p"><span class="ne-text">关于STL容器的相关问题非常细，经常成为面试中的考题，这里我们仅讨论一些必须的内容，然后只谈论在竞赛中的具体使用。</span></p><p id="551c7c831a7c03907effea19f85d8815" class="ne-p"><span class="ne-text"></span></p><p id="748f546e2cfa7dea162504441128383a" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1621221298404-a6bf5daf-fd5b-4504-a4d0-f80b17dc5899.png" width="1778" id="Rv9rY" class="ne-image"></p><p id="bc9da56b08501be44ab80c74871f3bcd" class="ne-p"><span class="ne-text">首先给出一张表格（来自cppreference）：</span></p><p id="b909ffb1c2645000a3fadf53bc7da1d2" class="ne-p"><span class="ne-text"></span></p><p id="89ffba3ee54d7d59bf99a47309fdc95d" class="ne-p"><span class="ne-text">这张表格中给出了各种容器支持的成员函数，在大多数停留在C++14和C++11版本的测试平台中，只有紫色、绿色部分是可用的。</span></p><p id="44ccc4a9adf75f8e0042b43b33fd83de" class="ne-p"><span class="ne-text"></span></p><p id="f29d38316edbbf61104ff268d8cf1503" class="ne-p"><span class="ne-text">在考察具体的容器的时候，出于竞赛中的需要，我们不会涵盖以上的全部，而是着重关注以下几点：</span></p><ol class="ne-ol"><li id="e3a45c83635d297ccda38ddb9d6dd721"><strong><span class="ne-text">随机访问</span></strong></li><li id="69bfa84b70d960e6323b085550f2cea4"><strong><span class="ne-text">插入和删除</span></strong></li><li id="59ba20d870115f04dc50335bc7c94948"><strong><span class="ne-text">端点访问</span></strong></li><li id="336e884d20f34f99decfeadc5641e490"><strong><span class="ne-text">迭代器类型（总结以上几点）</span></strong></li><li id="c498b0f5613aba11c9e457ae6c842ffd"><strong><span class="ne-text">时间复杂度</span></strong></li></ol><p id="99b0d09fab938a21cb2754647d420082" class="ne-p"><strong><span class="ne-text"></span></strong></p><p id="a3e5165a16b1bae8fdf91219d525dd61" class="ne-p"><span class="ne-text">事实上，综合以上几点，就可以得出一个容器的作用。容器的作用是由它支持的操作及其时间复杂度决定的，并不是说，容器的名字叫做set我就一定把它当作集合来用。从ADT的角度来说，</span><strong><span class="ne-text">数据结构=接口+接口的复杂度</span></strong><span class="ne-text">。而从另一个角度来看，容器内部支持的逻辑操作决定了它能够使用的迭代器类型，而这决定了外部可能存在哪些接口，因此也可以说</span><strong><span class="ne-text">数据结构=内部存储+迭代器</span></strong><span class="ne-text">。这样两种观点，能够在使用的层面加强我们对于STL容器的理解。</span></p><p id="2991cf1395bfdc1d38f67bdc19b84e7d" class="ne-p"><span class="ne-text"></span></p><p id="cf86b02f332a87d38750352809652a2f" class="ne-p"><span class="ne-text">方便起见，这里先列出一个汇总的表格，包含了竞赛中常用的几种数据结构：</span></p><p id="fc2f072711b55b1880c821933e0952cb" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1621221298080-23300f65-22c0-48b6-895a-324e3793fed5.png" width="857" id="PnAJG" class="ne-image"></p><p id="ef4077071ca1b74312af73b195c64fe0" class="ne-p"><span class="ne-text"></span></p><p id="17aab6c9586e8902c6fd2078e0858e61" class="ne-p"><span class="ne-text">这里的表格只给出了很简单的内容，本文末尾会给出两个总结性的表格，给出具体操作的函数名和时间复杂度。</span></p><p id="e40afaabd6286f809dee5c382de4cf66" class="ne-p"><span class="ne-text"></span></p><h2 id="Xuzkh"><span class="ne-text">二、 迭代器</span></h2><h3 id="xshvx"><span class="ne-text">迭代器与遍历</span></h3><p id="074397d1269d9d82ce8b72aee49ddc7b" class="ne-p"><span class="ne-text">操作一个容器，无法脱离它提供的工具——</span><strong><span class="ne-text">迭代器</span></strong><span class="ne-text">。即使没有使用过容器，我们也一定使用过最基本的方式遍历一个数组：</span></p><pre data-language="cpp" id="kBuLl" class="ne-codeblock language-cpp">for (int i = 0; i &lt;n;i++)
	//......</pre><p id="bef551f9c032825e8f863bf429c15fd2" class="ne-p"><span class="ne-text"></span></p><p id="351c9dc6e6e7f8e8f6940e80a257906a" class="ne-p"><span class="ne-text">不严格地说，这里的”i”就可以视作一个最原始的迭代器。事实上，对于藉由它，我们可以访问一个容器内的全部内容——这就是我们所说的“遍历”，这能够让我们对内部数据进行基于元素的操作。</span></p><p id="e3d177960f3a9710f3f6e20420be6ddc" class="ne-p"><span class="ne-text"></span></p><p id="88a1bf253f2267bb88accb386ed229d7" class="ne-p"><span class="ne-text">事实上，一个真正的迭代器需要符合很多要求。STL容器所配备的迭代器都属于C++迭代器库规定的六种之一，它们是：</span></p><ol class="ne-ol"><li id="a0a508f956a7f7422c0ead00ef730792"><strong><span class="ne-text">遗留输入迭代器</span></strong></li><li id="9f854f20bfdb6d2e1286977be28fe7a4"><strong><span class="ne-text">遗留向前迭代器</span></strong></li><li id="0a72a21e2d5642f1eff31bb9d583ba50"><strong><span class="ne-text">遗留双向迭代器</span></strong></li><li id="3c95bdede059dce4c441b09a86225a2a"><strong><span class="ne-text">遗留随机访问迭代器</span></strong></li><li id="ed66347e7daafc2a005be826efaa4cfe"><strong><span class="ne-text">遗留输出迭代器</span></strong></li><li id="c5d7514d16d7b3c2dc4b549670e87ddb"><strong><span class="ne-text">遗留连续迭代器</span></strong></li></ol><p id="e20cdf4f8c8c6e24ed84a0a4f496f6c2" class="ne-p"><span class="ne-text">这些名字看起来很唬人，让我们来一点一点解释。</span></p><p id="10f96e2fae647322cc53935b4ded4772" class="ne-p"><span class="ne-text">首先，它们都是“</span><strong><span class="ne-text">遗留迭代器</span></strong><span class="ne-text">”，这意味着它们都：（以下假设i是迭代器）</span></p><ul class="ne-ul"><li id="b3a4a9484fce4dba2ca346bf763aabb9"><span class="ne-text">可</span><strong><span class="ne-text">解引用</span></strong><span class="ne-text">（*i得到元素）</span></li><li id="77ffa0ff535587adbc30033b9e4bfc29"><span class="ne-text">可</span><strong><span class="ne-text">前自增</span></strong><span class="ne-text">（++i得到下一位置）</span></li></ul><p id="6287f35ce511723066defafead41e55d" class="ne-p"><span class="ne-text">这也就是为何我们能藉由迭代器来完成遍历容器内元素的操作。</span></p><p id="bd99dd12ea8e1576f52b59606c2761d1" class="ne-p"><span class="ne-text">下面给出上文提到的六种迭代器的实际含义，虽然大多数情况下竞赛中用不到这些原理，但偶尔会有基于手动遍历的技巧性操作，这时候也许需要你对迭代器有一定的认知：</span></p><p id="97f18ee5233fecadc9d2c10b132ade08" class="ne-p"><strong><span class="ne-text">遗留输入迭代器：</span></strong></p><p id="3ecf3a7b5df6db5f69c312daffa5ce32" class="ne-p"><span class="ne-text">在</span><strong><span class="ne-text">遗留迭代器</span></strong><span class="ne-text">的基础上，</span></p><ul class="ne-ul"><li id="04a52d75fbd1399b41b2a89b1046b15e"><span class="ne-text">可</span><strong><span class="ne-text">不等比较</span></strong><span class="ne-text">（i!=j有定义）</span></li><li id="003b47a543740051e9a5b4afe8408af3"><span class="ne-text">可</span><strong><span class="ne-text">后自增</span></strong><span class="ne-text">（i++有定义）</span></li></ul><p id="ef8ef9ebbdec97b920d878dc57c1fcdc" class="ne-p"><span class="ne-text">但：**自增后，先前值可能失效。**也就是说，当你访问第1个元素时，可能无法通过这个迭代器的拷贝访问第0个元素。</span></p><p id="2c669df7fb5c7ea71f8d787d0626292c" class="ne-p"><strong><span class="ne-text">遗留向前迭代器：</span></strong></p><p id="549b249d7366005f6663910166b92d71" class="ne-p"><span class="ne-text">在</span><strong><span class="ne-text">遗留输入迭代器</span></strong><span class="ne-text">的基础上，</span></p><ul class="ne-ul"><li id="2148cf7e33ed970a529e0971a7fa763a"><strong><span class="ne-text">自增后保证先前值不失效。</span></strong></li></ul><p id="a7efa65b859d944ac6cfb118f9a01a0c" class="ne-p"><strong><span class="ne-text">遗留双向迭代器：</span></strong></p><p id="27fa68639706c4eef6b49d6cf96de5ef" class="ne-p"><span class="ne-text">在</span><strong><span class="ne-text">遗留向前迭代器</span></strong><span class="ne-text">的基础上，</span></p><ul class="ne-ul"><li id="3062dfba061363d314e7404df219a293"><span class="ne-text">可</span><strong><span class="ne-text">前自减</span></strong><span class="ne-text">（–i有定义）</span></li><li id="4407856a0ce5d1429e52ef999251e8e2"><span class="ne-text">可</span><strong><span class="ne-text">后自减</span></strong><span class="ne-text">（i–有定义）</span></li></ul><p id="f981fa9738a21332add68b7616f568af" class="ne-p"><strong><span class="ne-text">遗留随机访问迭代器：</span></strong></p><p id="6d11fae78ee405d0e50b53a45c33579e" class="ne-p"><span class="ne-text">在</span><strong><span class="ne-text">遗留双向迭代器</span></strong><span class="ne-text">的基础上，</span></p><ul class="ne-ul"><li id="60fd749ae9531b0f615604e6af9edf5b"><span class="ne-text">有</span><strong><span class="ne-text">下标</span></strong><span class="ne-text">运算符（i[n]有定义）</span></li><li id="7189f291e63823ee6538353ceaa4d920"><span class="ne-text">有</span><strong><span class="ne-text">比较</span></strong><span class="ne-text">运算符（&gt;、&lt;、&gt;=、&lt;=有定义）</span></li><li id="a86c22e9b5a39cbca0f00050bd5d264a"><span class="ne-text">可按</span><strong><span class="ne-text">增量移动</span></strong><span class="ne-text">（+、-、+=、-=有定义）</span></li></ul><p id="00031be3672384a249e470a5a5805156" class="ne-p"><span class="ne-text">且：</span><strong><span class="ne-text">迭代器移动只耗费常数时间。</span></strong></p><p id="b1c9abdd70ae2a110b1dab135c960e37" class="ne-p"><em><span class="ne-text">若以上迭代器满足</span></em><strong><em><span class="ne-text">遗留输出迭代器</span></em></strong><em><span class="ne-text">的标准，那么称它们是“可变迭代器”。</span></em></p><p id="ad9fae9b279b18048b52b3558422d6ae" class="ne-p"><strong><span class="ne-text">遗留输出迭代器：</span></strong></p><p id="220355b273fa9687e963738aab9533ca" class="ne-p"><span class="ne-text">在</span><strong><span class="ne-text">遗留迭代器</span></strong><span class="ne-text">的基础上：</span></p><ul class="ne-ul"><li id="e95b5efedf1430da2c01bcbcc61a83ca"><span class="ne-text">可</span><strong><span class="ne-text">赋值</span></strong><span class="ne-text">（*i=something有定义）</span></li><li id="82be7c34f1fafff53248888851e35de9"><span class="ne-text">可</span><strong><span class="ne-text">后自增</span></strong></li></ul><p id="7b6ba705789cd5611d237dab96a66335" class="ne-p"><em><span class="ne-text">若以上迭代器满足</span></em><strong><em><span class="ne-text">遗留连续迭代器</span></em></strong><em><span class="ne-text">的标准，那么称它们是“连续迭代器”。</span></em></p><p id="f6407a21d18d62bfede55dbdce19796b" class="ne-p"><strong><span class="ne-text">遗留连续迭代器：</span></strong></p><p id="966927bf45388048f32c753c5dc97e02" class="ne-p"><span class="ne-text">在</span><strong><span class="ne-text">遗留迭代器</span></strong><span class="ne-text">的基础上：</span></p><ul class="ne-ul"><li id="295aa1c5a2c7abf01d1c8a89fd4a2a34"><span class="ne-text">逻辑相邻元素在内存中也相邻，</span></li><li id="5505a0d35f145ed1be5b9704e1c4021d"><span class="ne-text">即：</span><code class="ne-code"><span class="ne-text">*(i + n)</span></code><span class="ne-text"> 等价于 </span><code class="ne-code"><span class="ne-text">*(std::addressof(*i) + n)</span></code></li></ul><p id="582a156458fbccb1ec63aa622e34b058" class="ne-p"><span class="ne-text">以上涉及的运算，不仅需要定义，并且需要符合功能要求。同时，部分操作有特例存在。例如，即使迭代器可解引用，也无法对尾后迭代器或孤立迭代器解引用。</span></p><p id="e99c167444924f0b4082b4bb007fd382" class="ne-p"><span class="ne-text">那么，如果知道某个容器的迭代器类型，对比一下它们支持的操作，你就能知道自己的一些奇思妙想能否实现了。例如：两头向中间访问、一次跳过多个元素、多个迭代器同时访问……</span></p><p id="7aeb1f2b98528f9ea4648524c956fa92" class="ne-p"><span class="ne-text">那么，在复杂的环境下，例如访问的同时涉及插入和删除，这些操作还能按照我的意图运行吗？这就是我们要讨论的下一个问题了。如果说以上内容更偏向于实务开发，那么这个问题在竞赛中就更加常见了，它就是“迭代器失效”问题。</span></p><h3 id="UeT7t"><span class="ne-text">迭代器失效</span></h3><p id="47f4069d0f6796748f6ff291a6db7aa7" class="ne-p"><span class="ne-text">容器的一些操作会使得先前声明的迭代器失去它应有的作用，这种限制来自于容器底层的实现。例如在vector中，即使在尾部插入一个新元素也可能因为导致空间达到临界值而使得数据全部被移动到新空间，从而使全部迭代器失效。</span></p><p id="495c9d23522fa234f80177a2bacdeeac" class="ne-p"><span class="ne-text"></span></p><p id="90bb6dd65a4b4938a8261adeb97d1a18" class="ne-p"><span class="ne-text">大体来说，删除总会使得迭代器失效，而插入有些情况会使其失效。具体的情形见下表：（同样来自cppreference）</span></p><p id="e337efacc6b6c67eddb05a168c1b18d4" class="ne-p"><span class="ne-text"></span></p><p id="e489e1368915645afa8777bf8467f447" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1621221298154-92c7bf87-74b3-4fd5-9f62-d7ab6e5aa25b.png" width="982" id="N6O99" class="ne-image"></p><p id="d205f6a916045701debe1e97841744d1" class="ne-p"><span class="ne-text"></span></p><p id="6cd9b94d46196c0f14adc7af20025543" class="ne-p"><span class="ne-text">除此之外，尾后迭代器有一些特殊情形需要考虑，例如vector的尾后迭代器总是会被非法化、除了删除首元素外的修改操作都会非法化deque的尾后迭代器，等等。</span></p><h3 id="xSEPM"><span class="ne-text">尾后迭代器</span></h3><p id="f647c83d4c6e493b67419f5f8160b665" class="ne-p"><span class="ne-text">另一个要注意的点是，一般来说一个容器的begin()返回的是指向容器内首个元素的迭代器，而end()指向的却不是尾部元素，而是</span><strong><span class="ne-text">尾后</span></strong><span class="ne-text">——一个不存在的元素，我们也常常把这种位置称为“哨兵”。这一点好像恰好和其他参数为一个区间的函数，如sort(), substr()等，对应了起来——似乎编程中所有涉及区间的操作，都是使用左开右闭区间来表示的——也就是说，end()表示尾后。这是为什么呢？</span></p><p id="3e39e9ba14e44104b73621d2592b67c5" class="ne-p"><span class="ne-text">考虑对一个具有</span><strong><span class="ne-text">普通遗留迭代器</span></strong><span class="ne-text">的容器进行迭代，应当怎么写呢？似乎很简单：</span></p><pre data-language="plain" id="yYKwZ" class="ne-codeblock language-plain">for (auto i = x.begin(); i != x.end(); i++)</pre><p id="f50449d8125daae28412eb40bda2df91" class="ne-p"><span class="ne-text">看到这里，你应当已经明白了：大多数容器不具有遗留连续迭代器的性质，那就不存在像</span><code class="ne-code"><span class="ne-text">i &lt; x.end()</span></code><span class="ne-text">这种操作，因此无法像迭代一个数组一样以一个偏序比较作为条件，那么就必须有一个哨兵作为实际可以访问到的截止位，这个哨兵就是end()。</span></p><h3 id="T5IXM"><span class="ne-text">其他补充</span></h3><p id="3e5bcbf022fee73947a9cebc6bbbd284" class="ne-p"><span class="ne-text">在自写模板的时候，需要加上关键字</span><code class="ne-code"><span class="ne-text">typename</span></code></p><pre data-language="cpp" id="f9Bth" class="ne-codeblock language-cpp">typename list&lt;T&gt;::iterator p;</pre><h2 id="5nJdZ"><span class="ne-text">三、容器</span></h2><h3 id="EIqvD"><span class="ne-text">Vector</span></h3><h4 id="FLeAQ"><span class="ne-text">总览</span></h4><p id="8da9b17972578457ab1b8ac68711eab1" class="ne-p"><span class="ne-text">那么，我们就开始讲每个具体的容器了。在各节中，我们会依次介绍每个容器的用途、迭代器类型、插查删操作及其复杂度，有必要的时候，我们还会介绍一些其他的小trick。</span></p><p id="90864959b211b66ce9b82c10490b466a" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1621221298034-6e429607-ece3-4c15-bd6a-e02efaf4d4f6.png" width="669" id="STppH" class="ne-image"></p><p id="bd5baafee5b7d487116c4d04df613fe2" class="ne-p"><span class="ne-text">我们看到，Vector与其他STL容器最大的区别就在于，只要元素不为bool类型（bool类型因内存对齐而不连续），它是唯一使用</span><strong><span class="ne-text">连续迭代器</span></strong><span class="ne-text">的，即使对于全部情况，它也符合遗留随机访问迭代器，从而支持以常数复杂度通过下标运算符随机访问。这使得我们可以直接将其作为升级版的数组使用——数组的功能全部被它继承，而它又自带了其他一些便捷的函数——因此vector又被称为 </span><strong><span class="ne-text">“动态数组”</span></strong><span class="ne-text"> 。</span></p><p id="68ba6e696a07e5feb42e1f9197e58ee8" class="ne-p"><span class="ne-text">它底层的数据结构使用的是静态数组，实现动态扩容的奥秘在于，它在每一次容量占用达到阈值时就进行一次翻倍扩容，从而保证了均摊 O ( 1 ) O(1) </span><span class="ne-text">O</span><span class="ne-text">(</span><span class="ne-text">1</span><span class="ne-text">)</span><span class="ne-text">的时间复杂度，而又能节省空间。</span></p><h4 id="1nRvr"><span class="ne-text">常见用法</span></h4><p id="40d49aa8a2ae98495eef68ae7a560d8b" class="ne-p"><span class="ne-text">在C++11中，在具有begin()和end()的范围上进行迭代，有一种简便写法，那就是</span></p><pre data-language="plain" id="YZ0qw" class="ne-codeblock language-plain">for (auto&amp; v : container)</pre><p id="8f3f53ff952f027921f5bd7bc5c5d305" class="ne-p"><span class="ne-text">它等价于</span></p><pre data-language="plain" id="CQTHT" class="ne-codeblock language-plain">for (auto&amp; v = container.begin(); v != container.end(); v++)</pre><p id="f99b96a4b658ddef8216895c2cb93089" class="ne-p"><span class="ne-text">这里的auto利用了C++11的另一个特性——类型推导，这只是一个语法糖，它使我们不必写上container::iterator这一串复杂的类型，而在程序运行中与完整键入的并无区别。而auto后面加的&amp;代表v是一个左值引用，那么我们就可以通过v来修改容器中的元素。而如果我们想避免这种修改，可以去掉&amp;，这时v就是一个右值拷贝。</span></p><p id="5ea6aa09545d180fe8500bb40dc1e3f8" class="ne-p"><span class="ne-text">以一个int类型动态数组为例，我们可以这样输出：</span></p><pre data-language="plain" id="7o49C" class="ne-codeblock language-plain">vector&lt;int&gt; arr;
for (auto v : arr)
	cout&lt;&lt;v;</pre><p id="4e7db535eb1db00d7da248ffd0162de4" class="ne-p"><span class="ne-text">而读入可以这样写：</span></p><pre data-language="plain" id="9HlfB" class="ne-codeblock language-plain">for (int i = 1; i &lt;= n; i++)
{
    
	cin&gt;&gt;temp;
	arr.push_back(temp);
}</pre><p id="666266c9dbc2b7a3d18471334ffb3fbf" class="ne-p"><span class="ne-text">当然，同程序员们默认的一样，它的下标是从0开始的。</span></p><p id="c8f2191dc38184e07be9cbf4e62fd167" class="ne-p"><span class="ne-text">vector是否可以写高维数组呢？如果你经常在Leetcode上刷题，应当见过二维数组的这种写法：</span><code class="ne-code"><span class="ne-text">vector&lt;vector&lt;int&gt;&gt;</span></code><span class="ne-text">。高维数组以此类推即可。在访问上，这种写法与</span><code class="ne-code"><span class="ne-text">int arr[][]</span></code><span class="ne-text">没有任何区别。</span></p><h3 id="DGKQN"><span class="ne-text">List</span></h3><p id="1acbcecc2af052496c684194e713ae79" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1621221298094-bbd53e64-b82a-4b51-aa3a-f354b3bd7023.png" width="669" id="D1lAx" class="ne-image"></p><p id="d63f691f3f345af2bf77c6e3f79f136d" class="ne-p"><span class="ne-text">可以看到，list实际上就是一个</span><strong><span class="ne-text">双向链表</span></strong><span class="ne-text">，因此对于插入和删除的操作具有优秀的时间表现。当然也很容易想到，list是无法实现常数时间随机访问的，insert和erase看起来时间复杂度为 O ( 1 ) O(1) </span><span class="ne-text">O</span><span class="ne-text">(</span><span class="ne-text">1</span><span class="ne-text">)</span><span class="ne-text">，但在实际应用中，找到插入位置往往就需要 O ( n ) O(n) </span><span class="ne-text">O</span><span class="ne-text">(</span><span class="ne-text">n</span><span class="ne-text">)</span><span class="ne-text">的时间。</span></p><p id="d32940f3fd463a51dc7ea65729be9260" class="ne-p"><span class="ne-text">与list相似的，STL中还存在一个单向链表forward_list。由于不需要反向链，它的空间占用有所减小，不过这一点在竞赛中不怎么需要，所以那种结构了解即可。</span></p><h3 id="rolg4"><span class="ne-text">Stack</span></h3><h4 id="kAXMV"><span class="ne-text">总览</span></h4><p id="3ef016234adc4e2ac63f435d07edfb7f" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1621221298067-e4b7c1aa-ec7e-4535-a505-59440ac713db.png" width="669" id="Sfmf5" class="ne-image"></p><p id="876d6e559924ae58ddc7a67716f7c38c" class="ne-p"><span class="ne-text">相比于精心构造的数据结构，stack似乎更应当被称为一种“包装器”，它在底层实现的基础上屏蔽掉了一些功能，从而使自身表现得更像一个物理栈。对于它和queue，我们不需要多费口舌，也许这是仅有的两种我们可以自己实现而不会使代码冗长的数据结构了。但无论怎么说，有一个构造好的容器使用总是好的，它可以防止我们在底层的操作上犯一些愚蠢的错误。</span></p><h4 id="PHE4D"><span class="ne-text">常见用法</span></h4><p id="2db55f94404cd8b7f985357ba12bf50a" class="ne-p"><span class="ne-text">那么，这里就实际给出使用stack完成DFS的过程，以下是一段代码片段：</span></p><pre data-language="plain" id="uVATJ" class="ne-codeblock language-plain">vector&lt;int&gt; edges[N];
	stack&lt;int&gt; dfs;
	/*............*/
	dfs.push(v0);
	vis[v0] = true;
	while (!dfs.empty())
	{
    
		bool tag = false;
		int now = dfs.top();
		prt.push_back(now);
		for (auto v : edges[now])
			if (!vis[v])
			{
    
				dfs.push(v);
				vis[v] = true;
				tag = true;
				break;
			}
		if (!tag)
			dfs.pop();
	}</pre><h3 id="55tfW"><span class="ne-text">Deque及其延伸</span></h3><h4 id="nzjq9"><span class="ne-text">Deque</span></h4><p id="2bbed1a65109b74243d276980a437a1b" class="ne-p"><span class="ne-text">虽然实际使用时很少见，但deque是很多STL容器的基础，stack和queue都由它封装而来，它也支持相当多的操作，详见下表：</span></p><p id="7c1538f25f54b9cb6eef0f1277000c7a" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1621221298045-e627f316-cc63-4992-817c-f8025c1474df.png" width="669" id="yw0ii" class="ne-image"></p><p id="e4c286b966d21b0cde6e4afb055e06d5" class="ne-p"><span class="ne-text">值得注意的是，该容器的迭代器非法化情形比较有趣，其原理也是面试题常考的内容，建议结合STL源码深入分析。</span></p><p id="50074c6f4b501f0f0b3d31f55a9f4d92" class="ne-p"><span class="ne-text">结合上表，发现它与List的区别主要在于，它能够实现常数时间随机访问，但内部插入、删除却需要线性时间，这也符合他们底层实现：链表和数组的区别，也正是这一点使得它们的迭代器一个是双向而另一个是随机访问。多进行这种思考，由</span><strong><span class="ne-text">底层实现——容器——迭代器——操作</span></strong><span class="ne-text">转为</span><strong><span class="ne-text">底层实现——迭代器——操作</span></strong><span class="ne-text">，是一名程序员获得抽象思维的重要方式。</span></p><h4 id="6rbAT"><span class="ne-text">Queue</span></h4><p id="3909376590ae0222a94ca9c7692afde7" class="ne-p"><span class="ne-text">总览</span></p><p id="cdee1d85330f92001b29a84a305488fe" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1621221298045-979ccd1c-9d0c-4971-8323-beeb278dfecb.png" width="669" id="LTTqa" class="ne-image"></p><p id="ec3bf6075f1a314469dd41c85550556d" class="ne-p"><span class="ne-text">queue就是我们常说的</span><strong><span class="ne-text">队列</span></strong><span class="ne-text">了。同stack一样，它是很常见而且简单的数据结构，同样由deque封装得来。当然，由于deque和list都满足它的底层实现的要求，因此你可以指明换用list作为你的queue的底层实现：</span></p><pre data-language="plain" id="7Qp71" class="ne-codeblock language-plain">queue&lt;int, list&lt;int&gt;&gt; myQue;</pre><p id="b3e401d6e594a0ed43953b2bf0cee848" class="ne-p"><span class="ne-text">由于STL容器都使用模板类，因此在实际开发中，你完全可以将所有容器的分配器、底层容器自主实现。</span></p><p id="2b75de0ad67e1676f0db8df3cdadd680" class="ne-p"><span class="ne-text">6.2.2.常见用法</span></p><p id="7d2eb183e468080fbbedee2f802bb948" class="ne-p"><span class="ne-text">queue用来实现BFS应该是最常见的用法了，以下和stack一样给出一个代码片段：</span></p><pre data-language="plain" id="fBJAs" class="ne-codeblock language-plain">queue&lt;int&gt; que;
	while (!que.empty())
	{
    
		int now = que.front();
		que.pop();
		if (success(pos[now]))
			return true;
		for (int i = 0; i &lt; n; i++)
			if (!vis[i] &amp;&amp; dis[now][i] &lt;= limit)
			{
    
				que.push(i);
				vis[i] = true;
			}
	}</pre><h4 id="nq54Y"><span class="ne-text">Priority_Queue</span></h4><p id="f8bba081079bb648ee52b2800fa424d1" class="ne-p"><span class="ne-text">6.3.1.总览</span></p><p id="73c8082ad9bcb477ced5371c8f482918" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1621221298072-4aa3333f-4fe3-4f4e-8f10-212345e22947.png" width="669" id="Qei4g" class="ne-image"></p><p id="b1a64cf544310cf445ace3e2c776c0b2" class="ne-p"><span class="ne-text">priority_queue实现了优先队列这一ADT，也就是我们常说的 </span><strong><span class="ne-text">“堆”</span></strong><span class="ne-text"> 。但要明晰的是，优先队列是一种ADT，而堆是它的一种具体实现。在默认状态下，priority_queue实现的是大根堆，但你可以通过模板特化从而实现小根堆，甚至是自己定义的规则。</span></p><p id="18bee2c7c8a3ef343a4a01fb476dc32f" class="ne-p"><span class="ne-text"></span></p><p id="2625d01610d99818430568d7dc76a179" class="ne-p"><span class="ne-text">6.3.2.常见用法</span></p><p id="fc64dc42e1cfe0f73f54117301683f43" class="ne-p"><span class="ne-text">实现小根堆的方式很简单:</span></p><pre data-language="plain" id="mHZto" class="ne-codeblock language-plain">priority_queue&lt;int, vector&lt;int&gt;, std::greater&lt;int&gt;&gt; myHeap;</pre><p id="b33ef558e9c550cef931703739fb90fd" class="ne-p"><span class="ne-text">其中第一个参数为元素类型，第二个类型为底层实现，默认为vector，但STL库中的deque也符合要求。第三个参数为你的比较类型。priority_queue会按照这一比较偏序将</span><strong><span class="ne-text">最末序</span></strong><span class="ne-text">的元素作为“最大元素”。</span></p><p id="4417a73f75ce3889eaf3285c2868f150" class="ne-p"><span class="ne-text">在sort函数中自己构造函数对象以指定排序方式的写法非常基础，但其实在优先队列中指定排序方式的写法也并不困难。在sort中，我们传入一个函数指针，sort函数调用这个函数，获得它的返回值，从而得到元素之间的偏序。而在模板类中，由于</span><strong><span class="ne-text">需要在编译期就特化类</span></strong><span class="ne-text">，所以我们无法传入一个函数，而必须传入一个</span><strong><span class="ne-text">类</span></strong><span class="ne-text">。堆在排序时会</span><strong><span class="ne-text">调用其构造函数</span></strong><span class="ne-text">，获得构造函数的返回值，这整体上与我们给sort传参无异。</span></p><p id="165ef316ded3d73eba745a367532c747" class="ne-p"><span class="ne-text">大多数情况下，我们可以使用STL提供的编译器函数库中的比较运算，例如小于是less，大于等于是greater_equal，等等。上面用于实现小根堆的greater源码如下：</span></p><pre data-language="plain" id="NrZfO" class="ne-codeblock language-plain">template&lt;typename _Tp&gt;
	struct greater : public binary_function&lt;_Tp, _Tp, bool&gt;
	{
    
		bool
		operator()(const _Tp&amp; __x, const _Tp&amp; __y) const
		{
     return __x &gt; __y; }
	};</pre><p id="a78f9ba03c7b071ed994cf16d4234a6d" class="ne-p"><span class="ne-text">然而观察这一函数，它最终还是要调用具体类型的比较运算。那么如果我们给容器的类不具有偏序，或者我们需要特别指定偏序怎么办呢？下面给出一个实例。</span></p><p id="e8d6aadcbc80e9b16463d5e5cb8f57a8" class="ne-p"><span class="ne-text">例如，在图的搜索中我们需要存储点和它到源点的距离，那么我们的元素可能是这样的：</span></p><pre data-language="plain" id="l318F" class="ne-codeblock language-plain">typename int Vertex;
typename int Distance;
typename pair&lt;Vertex, Distance&gt; Dest;</pre><p id="fdac6754ddac46a7c32775d34f405a56" class="ne-p"><span class="ne-text">在Dijkstra算法中，用堆优化时我们需要建立边权的小根堆，那么就可以这样自建比较类型（我们知道自己要使用的类型，就不需要写成模板类了）：</span></p><pre data-language="plain" id="Dpu9d" class="ne-codeblock language-plain">struct myGreater : public binary_function&lt;Dest, Dest, bool&gt;
{
    
	bool operator() (const Dest &amp;lhs, const Dest &amp;rhs) const
	{
     return lhs.second &gt; rhs.second; }
}</pre><p id="abcbbae7b6f64f631f2ef577d5b39fea" class="ne-p"><span class="ne-text">于是就可以这样建立基于边权的小根堆：</span></p><pre data-language="plain" id="9s5Ws" class="ne-codeblock language-plain">priority_queue&lt;Dest, vector&lt;Dest&gt;, myGreater&gt; myHeap;</pre><h3 id="UVR8t"><span class="ne-text">Set及Multiset</span></h3><h4 id="0ldEU"><span class="ne-text">总览</span></h4><p id="37cd991762e49138a54b07d2185a183a" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1621221298126-cd7b73e2-055e-4325-8270-dadc26949011.png" width="669" id="fntg7" class="ne-image"></p><p id="460933e07cace91c2d79850aa732d841" class="ne-p"><span class="ne-text">set对应的ADT是</span><strong><span class="ne-text">集合</span></strong><span class="ne-text">：它支持元素的存储和查找，同时符合抽象意义上的集合要求——</span><strong><span class="ne-text">不允许出现重复元素</span></strong><span class="ne-text">。</span></p><h4 id="eJ0my"><span class="ne-text">常见用法</span></h4><p id="608b3b42ab2d86d2318893fb566ca7a6" class="ne-p"><span class="ne-text">set的一个重要用途就是</span><strong><span class="ne-text">排序同时去重</span></strong><span class="ne-text">。在BST家族中，理论表现最好的是Fibonacci-heap，但由于常数过大，实际表现最好的数据结构其实是set所采用的底层结构红黑树。如果说排序去重可以通过使用一个sort函数加手工来完成，那么需要</span><strong><span class="ne-text">支持插入和查找</span></strong><span class="ne-text">的题目呢？莫非我们要手写RBT吗？这时候，一个深受考验的set无疑是广大竞赛选手的福音。</span></p><p id="67486a4a9e1734a9fe7de395f24fbb50" class="ne-p"><span class="ne-text">当然，在更多的情况下，我们需要</span><strong><span class="ne-text">允许数据中出现重复</span></strong><span class="ne-text">的元素，那么</span><strong><span class="ne-text">可以使用multiset</span></strong><span class="ne-text">这种数据结构，它在其他地方与set无异，唯一的区别在于它允许重复元素的出现。</span></p><p id="6328a682fa5e63b882187edf744a94b1" class="ne-p"><span class="ne-text">在容器中，find函数在找不到对象的时候一般会返回end，那么查找可以写作：</span></p><pre data-language="plain" id="oiRk0" class="ne-codeblock language-plain">if (c.find(x) != c.end())
	//do something...</pre><h3 id="KnVnr"><span class="ne-text">Map</span></h3><h4 id="fGies"><span class="ne-text">总览</span></h4><p id="11714e03628efdbd418962483353ea3c" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1621221298068-5d1c0d5a-095f-44a8-92cd-fa4bc119ab01.png" width="669" id="dyk1Y" class="ne-image"></p><h4 id="Brk2P"><span class="ne-text">常见用法</span></h4><p id="6b7f1567e7734cb156957c66f7742e78" class="ne-p"><span class="ne-text">map和set非常类似，只不过它的数据是</span><strong><span class="ne-text">键值对</span></strong><span class="ne-text">而非一个单独的键，而</span><strong><span class="ne-text">键是唯一的</span></strong><span class="ne-text">。如果给它的用途举个例子，可以是存储源点到所有可达点的访问记录。</span></p><p id="8512a19455a672ebcd5cffe914270d06" class="ne-p"><span class="ne-text">当然，同map一样，它也有允许键不唯一的版本，那就是</span><strong><span class="ne-text">multimap</span></strong><span class="ne-text">。本质上，</span><code class="ne-code"><span class="ne-text">multimap&lt;Key, T&gt;</span></code><span class="ne-text">等价于</span><code class="ne-code"><span class="ne-text">multiset&lt;pair&lt;Key, T&gt;, Comp&lt;pair&lt;Key, T&gt;&gt;, std::allocator&lt;std::pair&lt;Key, T&gt;&gt;&gt;</span></code><span class="ne-text">，其中Comp是自主实现的依据Key的比较类型。</span></p><p id="54a78d612f66c46942d22fae55ef4be8" class="ne-p"><span class="ne-text">也就是说，map和set和priority_queue一样，支持特化比较类型，特化的方式也是一样的。只不过实际使用的时候，不要忘记最后一个模板参数，那是用于生成元素空间的分配器。</span></p><h2 id="MeMEn"><span class="ne-text">四、算法</span></h2><p id="6901abc61810e97f08b225965a3331a0" class="ne-p"><span class="ne-text">STL里面有一些常用的函数模板，可以在平常使用。</span></p><p id="4343e03862a3774dcea7257894b11748" class="ne-p"><span class="ne-text"></span></p><div class="ne-quote"><p id="24ddbcb123cfa0ba4c14afd8e23a1491" class="ne-p"><span class="ne-text">参考这个链接：</span><a href="https://segmentfault.com/a/1190000021581714" data-href="https://segmentfault.com/a/1190000021581714" target="_blank" class="ne-link"><span class="ne-text">https://segmentfault.com/a/1190000021581714</span></a></p></div><h2 id="Muzfm"><span class="ne-text">五、总结</span></h2><p id="56eba145a4c02cfa4a011954a67d1c6d" class="ne-p"><span class="ne-text">本文最后，给出一个表格以供检索，相比于cppreference的总结，这里只列出了竞赛中常用的一些操作及其复杂度。begin()和end()虽然较为常用，不过由于是全体容器必备的，所以不再列出。</span></p><p id="156aed03e46ea7de2b27acae470d0b92" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1621221298131-b854f40d-40b6-42fb-a901-467032ef3583.png" width="1321" id="Pt0mu" class="ne-image"></p><p id="9e767f6fca48577ae56528e10dd311e8" class="ne-p"><span class="ne-text">这样，这篇文章也就基本结束了。可以看到，为了照顾特定的使用需求，本文对容器具体的实现未做过多探讨，反而对通常不太重视的迭代器部分做了一定的讲解。在竞赛中掌握这些内容，已经能够满足几乎全部的需求了。但在实际应用中，掌握这些内容甚至不足以通过一个大厂的面试。例如，deque的若是对容器原理有兴趣，可以找市面上评价较好的STL源码解读类书籍学习。</span></p><p id="51b6ea6eb3ea297d2531b1a174409218" class="ne-p"><span class="ne-text"></span></p><div data-type="tips" class="ne-alert"><p id="0c4773046d8106f57ad18705b5021e76" class="ne-p"><span class="ne-text">补充：头文件#include&lt;bits/stdc.h&gt;（最常用，特别是OJ刷题）的内容如下</span></p></div><p id="83b015f0947ebeaea02152032cc3da8d" class="ne-p"><br></p><pre data-language="cpp" id="S3LLo" class="ne-codeblock language-cpp">// C++ includes used for precompiling -*- C++ -*-
 
// Copyright (C) 2003-2013 Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 3, or (at your option)
// any later version.
 
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
 
// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.
 
// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// &lt;Licenses - GNU Project - Free Software Foundation&gt;.
 
/** @file stdc++.h
 *  This is an implementation file for a precompiled header.
 */
 
// 17.4.1.2 Headers
 
// C
#ifndef _GLIBCXX_NO_ASSERT
#include &lt;cassert&gt;
#endif
#include &lt;cctype&gt;
#include &lt;cerrno&gt;
#include &lt;cfloat&gt;
#include &lt;ciso646&gt;
#include &lt;climits&gt;
#include &lt;clocale&gt;
#include &lt;cmath&gt;
#include &lt;csetjmp&gt;
#include &lt;csignal&gt;
#include &lt;cstdarg&gt;
#include &lt;cstddef&gt;
#include &lt;cstdio&gt;
#include &lt;cstdlib&gt;
#include &lt;cstring&gt;
#include &lt;ctime&gt;
 
#if __cplusplus &gt;= 201103L
#include &lt;ccomplex&gt;
#include &lt;cfenv&gt;
#include &lt;cinttypes&gt;
#include &lt;cstdalign&gt;
#include &lt;cstdbool&gt;
#include &lt;cstdint&gt;
#include &lt;ctgmath&gt;
#include &lt;cwchar&gt;
#include &lt;cwctype&gt;
#endif
 
// C++
#include &lt;algorithm&gt;
#include &lt;bitset&gt;
#include &lt;complex&gt;
#include &lt;deque&gt;
#include &lt;exception&gt;
#include &lt;fstream&gt;
#include &lt;functional&gt;
#include &lt;iomanip&gt;
#include &lt;ios&gt;
#include &lt;iosfwd&gt;
#include &lt;iostream&gt;
#include &lt;istream&gt;
#include &lt;iterator&gt;
#include &lt;limits&gt;
#include &lt;list&gt;
#include &lt;locale&gt;
#include &lt;map&gt;
#include &lt;memory&gt;
#include &lt;new&gt;
#include &lt;numeric&gt;
#include &lt;ostream&gt;
#include &lt;queue&gt;
#include &lt;set&gt;
#include &lt;sstream&gt;
#include &lt;stack&gt;
#include &lt;stdexcept&gt;
#include &lt;streambuf&gt;
#include &lt;string&gt;
#include &lt;typeinfo&gt;
#include &lt;utility&gt;
#include &lt;valarray&gt;
#include &lt;vector&gt;
 
#if __cplusplus &gt;= 201103L
#include &lt;array&gt;
#include &lt;atomic&gt;
#include &lt;chrono&gt;
#include &lt;condition_variable&gt;
#include &lt;forward_list&gt;
#include &lt;future&gt;
#include &lt;initializer_list&gt;
#include &lt;mutex&gt;
#include &lt;random&gt;
#include &lt;ratio&gt;
#include &lt;regex&gt;
#include &lt;scoped_allocator&gt;
#include &lt;system_error&gt;
#include &lt;thread&gt;
#include &lt;tuple&gt;
#include &lt;typeindex&gt;
#include &lt;type_traits&gt;
#include &lt;unordered_map&gt;
#include &lt;unordered_set&gt;
#endif</pre></div>0:{"buildId":"f0cdySSxBr_ZaI2KML5of","rsc":["$","$1","c",{"children":[["$","section",null,{"className":"relative","children":["$","$L2",null,{"fade":true,"blur":true,"transition":{"duration":0.5},"delay":0.1,"className":"relative overflow-hidden border-y xl:flex","children":[["$","div",null,{"className":"m-6 w-full flex-1 bg-[radial-gradient(circle_at_center,color-mix(in_oklab,var(--primary)_15%,transparent)_2px,transparent_2px)] bg-size-[18px_18px] max-xl:hidden"}],["$","div",null,{"className":"mx-auto w-full max-w-6xl flex-none space-y-8 px-4 py-8 min-[1158px]:border-x sm:px-6 sm:py-12 lg:px-8","children":[["$","$L2",null,{"fade":true,"blur":true,"slide":{"direction":"down","offset":30},"transition":{"duration":0.4},"children":["$","$L3",null,{"href":"/blog","className":"text-muted-foreground hover:text-foreground inline-flex items-center gap-2 text-sm transition-colors","children":[["$","svg",null,{"xmlns":"http://www.w3.org/2000/svg","width":24,"height":24,"viewBox":"0 0 24 24","fill":"none","stroke":"currentColor","strokeWidth":2,"strokeLinecap":"round","strokeLinejoin":"round","className":"lucide lucide-arrow-left h-4 w-4","aria-hidden":"true","children":[["$","path","1l729n",{"d":"m12 19-7-7 7-7"}],["$","path","x3x0zl",{"d":"M19 12H5"}],"$undefined"]}],"返回","技术博客"]}]}],["$","article",null,{"className":"mx-auto max-w-4xl","children":[["$","header",null,{"className":"mb-8 space-y-6","children":[["$","$L2",null,{"fade":true,"blur":true,"slide":{"direction":"up","offset":50},"delay":0.2,"transition":{"duration":0.6},"children":["$","div",null,{"className":"relative aspect-video overflow-hidden rounded-xl","children":["$","$L4",null,{"src":"https://cdn.nlark.com/yuque/0/2021/png/1484158/1621221298404-a6bf5daf-fd5b-4504-a4d0-f80b17dc5899.png","alt":"[转]竞赛常用STL容器详解","fill":true,"className":"object-cover","unoptimized":true}]}]}],["$","$L2",null,{"delay":0.3,"transition":{"duration":0.5},"children":["$","h1",null,{"className":"text-2xl font-bold tracking-tight sm:text-3xl md:text-4xl","children":["$","$L5",null,{"text":"[转]竞赛常用STL容器详解","delay":30,"animateBy":"words","direction":"bottom"}]}]}],["$","$L2",null,{"fade":true,"blur":true,"slide":{"direction":"down","offset":30},"delay":0.4,"transition":{"duration":0.5},"children":["$","p",null,{"className":"text-muted-foreground text-lg","children":"大部分文字内容转载自：竞赛常用STL容器详解部分内容个人修改补充。一、 概述在算法竞赛中，使用C++语言的占很大比例，而几乎没有人使用C语言，其中核心的原因就是C++包含STL容器库，能够极大地减少选手在赛场上为了一些基础数据结构而浪费的时间。诚然，花一两分钟实现一个stack、queue甚至..."}]}],["$","$L2",null,{"fade":true,"blur":true,"slide":{"direction":"down","offset":30},"delay":0.5,"transition":{"duration":0.5},"children":["$","div",null,{"className":"text-muted-foreground flex flex-wrap items-center gap-4 text-sm","children":[["$","div",null,{"className":"flex items-center gap-1","children":[["$","svg",null,{"xmlns":"http://www.w3.org/2000/svg","width":24,"height":24,"viewBox":"0 0 24 24","fill":"none","stroke":"currentColor","strokeWidth":2,"strokeLinecap":"round","strokeLinejoin":"round","className":"lucide lucide-calendar h-4 w-4","aria-hidden":"true","children":[["$","path","1cmpym",{"d":"M8 2v4"}],["$","path","4m81vk",{"d":"M16 2v4"}],["$","rect","1hopcy",{"width":"18","height":"18","x":"3","y":"4","rx":"2"}],["$","path","8toen8",{"d":"M3 10h18"}],"$undefined"]}],["$","span",null,{"children":"2021年5月17日"}]]}],["$","div",null,{"className":"flex items-center gap-1","children":[["$","svg",null,{"xmlns":"http://www.w3.org/2000/svg","width":24,"height":24,"viewBox":"0 0 24 24","fill":"none","stroke":"currentColor","strokeWidth":2,"strokeLinecap":"round","strokeLinejoin":"round","className":"lucide lucide-clock h-4 w-4","aria-hidden":"true","children":[["$","path","mmk7yg",{"d":"M12 6v6l4 2"}],["$","circle","1mglay",{"cx":"12","cy":"12","r":"10"}],"$undefined"]}],["$","span",null,{"children":"5.9千字"}]]}],["$","div",null,{"className":"flex items-center gap-1","children":[["$","svg",null,{"xmlns":"http://www.w3.org/2000/svg","width":24,"height":24,"viewBox":"0 0 24 24","fill":"none","stroke":"currentColor","strokeWidth":2,"strokeLinecap":"round","strokeLinejoin":"round","className":"lucide lucide-eye h-4 w-4","aria-hidden":"true","children":[["$","path","1nclc0",{"d":"M2.062 12.348a1 1 0 0 1 0-.696 10.75 10.75 0 0 1 19.876 0 1 1 0 0 1 0 .696 10.75 10.75 0 0 1-19.876 0"}],["$","circle","1v7zrd",{"cx":"12","cy":"12","r":"3"}],"$undefined"]}],["$","span",null,{"children":[12," 阅读"]}]]}],false,false]}]}],false]}],["$","$L2",null,{"delay":0.6,"fade":true,"blur":true,"transition":{"duration":0.6},"className":"-mx-4 sm:-mx-6 lg:-mx-8","children":["$","$L6",null,{}]}],["$","$L2",null,{"fade":true,"blur":true,"slide":{"direction":"up","offset":50},"delay":0.7,"transition":{"duration":0.6},"children":["$","div",null,{"className":"prose prose-neutral dark:prose-invert mt-8 max-w-none","dangerouslySetInnerHTML":{"__html":"$7"}}]}],"$L8","$L9"]}]]}],"$La"]}]}],["$Lb"],"$Lc"]}],"loading":null,"isPartial":false}
8:["$","$L2",null,{"delay":0.8,"fade":true,"blur":true,"transition":{"duration":0.6},"className":"-mx-4 mt-12 sm:-mx-6 lg:-mx-8","children":["$","$L6",null,{}]}]
9:["$","$L2",null,{"fade":true,"blur":true,"slide":{"direction":"up","offset":30},"delay":0.9,"transition":{"duration":0.5},"children":["$","nav",null,{"className":"mt-8 grid gap-4 md:grid-cols-2","children":[["$","$L3",null,{"href":"/blog/gqpli5","className":"hover:bg-muted group flex flex-col rounded-lg border p-4 transition-colors","children":[["$","span",null,{"className":"text-muted-foreground mb-2 text-sm","children":"上一篇"}],["$","span",null,{"className":"group-hover:text-primary line-clamp-2 font-medium transition-colors","children":"图的术语、存储、应用综述"}]]}],["$","$L3",null,{"href":"/blog/wr3hmo","className":"hover:bg-muted group flex flex-col rounded-lg border p-4 text-right transition-colors md:text-right","children":[["$","span",null,{"className":"text-muted-foreground mb-2 text-sm","children":"下一篇"}],["$","span",null,{"className":"group-hover:text-primary line-clamp-2 font-medium transition-colors","children":"视频的无伤切割"}]]}]]}]}]
a:["$","div",null,{"className":"m-6 w-full flex-1 bg-[radial-gradient(circle_at_center,color-mix(in_oklab,var(--primary)_15%,transparent)_2px,transparent_2px)] bg-size-[18px_18px] max-xl:hidden"}]
b:["$","script","script-0",{"src":"/_next/static/chunks/11dff99839ab5ba0.js","async":true}]
c:["$","$Ld",null,{"children":["$","$e",null,{"name":"Next.MetadataOutlet","children":"$@f"}]}]
f:null
