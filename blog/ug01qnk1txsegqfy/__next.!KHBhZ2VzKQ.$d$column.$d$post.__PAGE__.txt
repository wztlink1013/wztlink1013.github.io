1:"$Sreact.fragment"
2:I[99897,["/_next/static/chunks/4eaa70fe861e9598.js","/_next/static/chunks/946bdd2e6c9b7c49.js","/_next/static/chunks/6dd6809ee42e252f.js","/_next/static/chunks/f2b800ca7ae14e96.js","/_next/static/chunks/e121db38c98deeb4.js","/_next/static/chunks/0973dd923ca2781d.js","/_next/static/chunks/b397c2fd2abb1207.js","/_next/static/chunks/11dff99839ab5ba0.js"],"MotionPreset"]
3:I[22016,["/_next/static/chunks/4eaa70fe861e9598.js","/_next/static/chunks/946bdd2e6c9b7c49.js","/_next/static/chunks/6dd6809ee42e252f.js","/_next/static/chunks/f2b800ca7ae14e96.js","/_next/static/chunks/e121db38c98deeb4.js","/_next/static/chunks/0973dd923ca2781d.js","/_next/static/chunks/b397c2fd2abb1207.js","/_next/static/chunks/11dff99839ab5ba0.js"],""]
4:I[48347,["/_next/static/chunks/4eaa70fe861e9598.js","/_next/static/chunks/946bdd2e6c9b7c49.js","/_next/static/chunks/6dd6809ee42e252f.js","/_next/static/chunks/f2b800ca7ae14e96.js","/_next/static/chunks/e121db38c98deeb4.js","/_next/static/chunks/0973dd923ca2781d.js","/_next/static/chunks/b397c2fd2abb1207.js","/_next/static/chunks/11dff99839ab5ba0.js"],"default"]
5:I[72436,["/_next/static/chunks/4eaa70fe861e9598.js","/_next/static/chunks/946bdd2e6c9b7c49.js","/_next/static/chunks/6dd6809ee42e252f.js","/_next/static/chunks/f2b800ca7ae14e96.js","/_next/static/chunks/e121db38c98deeb4.js","/_next/static/chunks/0973dd923ca2781d.js","/_next/static/chunks/b397c2fd2abb1207.js","/_next/static/chunks/11dff99839ab5ba0.js"],"Separator"]
c:I[97367,["/_next/static/chunks/ff1a16fafef87110.js","/_next/static/chunks/7340adf74ff47ec0.js"],"OutletBoundary"]
d:"$Sreact.suspense"
6:T294a,<!doctype html><div class="lake-content" typography="classic"><p id="u0dd4c899" class="ne-p"><span class="ne-text">Vue 和 React 的 diff 算法都是为了解决虚拟 DOM 更新的问题，它们都使用了 </span><strong><span class="ne-text">Diffing</span></strong><span class="ne-text"> 技术来优化 DOM 渲染。虽然两者有相似的思想，但实现上存在一些差异。</span></p><h3 id="DbnV2"><span class="ne-text">1. </span><strong><span class="ne-text">React 的 Diff 算法</span></strong></h3><p id="ua7dc5f42" class="ne-p"><span class="ne-text">React 使用了一种 </span><strong><span class="ne-text">O(n)</span></strong><span class="ne-text"> 复杂度的 Diff 算法，这被称为 </span><strong><span class="ne-text">Fiber</span></strong><span class="ne-text">。该算法主要分为两部分：</span><strong><span class="ne-text">reconciliation（调和过程）</span></strong><span class="ne-text"> 和 </span><strong><span class="ne-text">rendering（渲染过程）</span></strong><span class="ne-text">。</span></p><h4 id="qG5fd"><span class="ne-text">核心思想</span></h4><ul class="ne-ul"><li id="u8c9ae04b" data-lake-index-type="0"><strong><span class="ne-text" style="color: #DF2A3F">分层比较（树分层比较）</span></strong><span class="ne-text">：React 不会进行整个虚拟 DOM 树的逐个节点对比，而是将树分为不同层，逐层进行比较。这大幅降低了时间复杂度。</span></li><li id="ufafd5a35" data-lake-index-type="0"><strong><span class="ne-text" style="color: #DF2A3F">组件类型不同，直接替换</span></strong><span class="ne-text">：如果新旧虚拟 DOM 的类型不同（比如 </span><code class="ne-code"><span class="ne-text">&lt;div&gt;</span></code><span class="ne-text"> 换成了 </span><code class="ne-code"><span class="ne-text">&lt;span&gt;</span></code><span class="ne-text">，或者是不同的组件类型），React 不会去做深入比较，而是直接删除旧节点，创建新节点。</span></li><li id="ua58c8422" data-lake-index-type="0"><strong><span class="ne-text" style="color: #DF2A3F">key 优化</span></strong><span class="ne-text">：React 使用 </span><code class="ne-code"><span class="ne-text">key</span></code><span class="ne-text"> 属性来标识列表中的节点。当同级列表元素的 </span><code class="ne-code"><span class="ne-text">key</span></code><span class="ne-text"> 发生变化时，React 会尝试优化节点的重排，而不是逐个删除和重建。没有 </span><code class="ne-code"><span class="ne-text">key</span></code><span class="ne-text"> 的列表会引发性能问题，因为 React 会进行位置的逐个比对。</span></li></ul><h4 id="Hkruy"><span class="ne-text">更新流程</span></h4><ol class="ne-ol"><li id="u874e1cb3" data-lake-index-type="0"><span class="ne-text">React 会从根节点开始比较每一层的虚拟 DOM。</span></li><li id="u7ad0411d" data-lake-index-type="0"><span class="ne-text">如果节点类型相同（如 </span><code class="ne-code"><span class="ne-text">&lt;div&gt;</span></code><span class="ne-text"> 对比 </span><code class="ne-code"><span class="ne-text">&lt;div&gt;</span></code><span class="ne-text">），则对比其属性和子节点。</span></li><li id="ua1bb18a3" data-lake-index-type="0"><span class="ne-text">如果节点类型不同，则直接删除旧节点，创建新节点。</span></li><li id="u9a7614aa" data-lake-index-type="0"><span class="ne-text">对于列表，React 会优先查找 </span><code class="ne-code"><span class="ne-text">key</span></code><span class="ne-text"> 值相同的节点，避免不必要的删除和创建。</span></li></ol><h4 id="NF2EK"><span class="ne-text">优化策略</span></h4><p id="u545535f7" class="ne-p"><span class="ne-text">React 的算法设计思路是通过 </span><strong><span class="ne-text">浅层对比</span></strong><span class="ne-text"> 来加速渲染，优先保证渲染性能，而不是精确地对每个节点进行深层次比对。</span></p><h3 id="aB5kz"><span class="ne-text">2. </span><strong><span class="ne-text">Vue 的 Diff 算法</span></strong></h3><p id="u97f1712a" class="ne-p"><span class="ne-text">Vue 2 和 Vue 3 都使用了 </span><strong><span class="ne-text">O(n)</span></strong><span class="ne-text"> 的 Diff 算法，核心基于 </span><code class="ne-code"><span class="ne-text">snabbdom</span></code><span class="ne-text"> 的实现，特别是在 Vue 3 中，diff 算法进行了优化，追求高效且轻量的更新过程。</span></p><h4 id="RcSjF"><span class="ne-text">核心思想</span></h4><ul class="ne-ul"><li id="u7f06da5b" data-lake-index-type="0"><strong><span class="ne-text" style="color: #DF2A3F">双端比较</span></strong><span class="ne-text">：Vue 采用了 </span><strong><span class="ne-text">双端比较</span></strong><span class="ne-text"> 策略，即分别从新旧虚拟 DOM 的两端进行对比，直到遇到不同的节点。这样可以快速确定相同的节点，减少中间节点的比对。</span></li><li id="uffcec6d8" data-lake-index-type="0"><strong><span class="ne-text">patch 函数</span></strong><span class="ne-text">：Vue 使用 </span><code class="ne-code"><span class="ne-text">patch</span></code><span class="ne-text"> 函数递归地比较新旧虚拟 DOM 树，通过 </span><strong><span class="ne-text">最小化修改</span></strong><span class="ne-text"> 的方式更新真实 DOM。</span></li><li id="u383b6ea7" data-lake-index-type="0"><strong><span class="ne-text">静态节点优化</span></strong><span class="ne-text">：Vue 会在模板编译时对静态节点进行标记，这样在更新时可以跳过对静态节点的比对，从而提高性能。</span></li><li id="u7b3fa3ac" data-lake-index-type="0"><strong><span class="ne-text">key 优化</span></strong><span class="ne-text">：和 React 类似，Vue 也会使用 </span><code class="ne-code"><span class="ne-text">key</span></code><span class="ne-text"> 来优化列表的节点更新，确保节点重用和位置变化的高效处理。</span></li></ul><h4 id="QG5uG"><span class="ne-text">更新流程</span></h4><ol class="ne-ol"><li id="u56a7e6b6" data-lake-index-type="0"><span class="ne-text">Vue 会从根节点开始对比新旧虚拟 DOM。</span></li><li id="u4e3b5fd8" data-lake-index-type="0"><span class="ne-text">对比节点类型和属性：</span></li></ol><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="uc1efe140" data-lake-index-type="0"><span class="ne-text">如果节点类型不同，直接替换。</span></li><li id="u903a3fc9" data-lake-index-type="0"><span class="ne-text">如果节点类型相同，则继续比较属性和子节点。</span></li></ul></ul><ol start="3" class="ne-ol"><li id="u00bb598e" data-lake-index-type="0"><span class="ne-text">如果是列表，Vue 会基于双端比较算法对列表进行最小化的更新操作。</span></li><li id="u2a7de034" data-lake-index-type="0"><span class="ne-text">对于静态内容的优化，Vue 会跳过不必要的更新。</span></li></ol><h4 id="pV0fu"><span class="ne-text">Vue 3 的优化</span></h4><ul class="ne-ul"><li id="u55a9c8e5" data-lake-index-type="0"><strong><span class="ne-text">编译阶段优化</span></strong><span class="ne-text">：Vue 3 在模板编译阶段会标记哪些部分是静态的，这样在更新时，Vue 可以直接跳过这些静态部分，进一步提升性能。</span></li><li id="uf013a7c8" data-lake-index-type="0"><strong><span class="ne-text">更轻量的结构</span></strong><span class="ne-text">：Vue 3 引入了 Proxy 和更简洁的响应式系统，使得状态更新过程更高效，和 Diff 算法配合得更好。</span></li></ul><h3 id="E0ZLx"><span class="ne-text">3. </span><strong><span class="ne-text">对比总结</span></strong></h3><table id="Hkfm6" class="ne-table" style="width: 750px"><tbody><tr style="height: 33px"><td width="250"><p id="ue2ab7066" class="ne-p"><span class="ne-text">特性</span></p></td><td width="250"><p id="u7d334a08" class="ne-p"><span class="ne-text">React</span></p></td><td width="250"><p id="ue0e6ae01" class="ne-p"><span class="ne-text">Vue</span></p></td></tr><tr style="height: 33px"><td width="250"><p id="u6ff22eb2" class="ne-p"><span class="ne-text">Diff 核心算法</span></p></td><td width="250"><p id="u30e7d9ea" class="ne-p"><span class="ne-text">O(n) 的 Fiber 架构，按层次比较</span></p></td><td width="250"><p id="ud8bfd42d" class="ne-p"><span class="ne-text">O(n) 的双端比较，使用 snabbdom 的 patch</span></p></td></tr><tr style="height: 33px"><td width="250"><p id="u1098601a" class="ne-p"><span class="ne-text">key 优化</span></p></td><td width="250"><p id="u621b2214" class="ne-p"><span class="ne-text">通过 key 优化列表更新</span></p></td><td width="250"><p id="ua36ba29c" class="ne-p"><span class="ne-text">同样使用 key 来优化列表的节点重用</span></p></td></tr><tr style="height: 33px"><td width="250"><p id="u7bfe3f84" class="ne-p"><span class="ne-text">静态节点优化</span></p></td><td width="250"><p id="u176358ba" class="ne-p"><span class="ne-text">通过 diff 对比逐层更新</span></p></td><td width="250"><p id="uce236f49" class="ne-p"><span class="ne-text">编译时标记静态节点，跳过不必要的更新</span></p></td></tr><tr style="height: 33px"><td width="250"><p id="u043a7ecb" class="ne-p"><span class="ne-text">更新策略</span></p></td><td width="250"><p id="u010ce4f5" class="ne-p"><span class="ne-text">分层比较，不同类型节点直接替换</span></p></td><td width="250"><p id="u5f50c839" class="ne-p"><span class="ne-text">双端比较，动态跳过不必要的更新</span></p></td></tr><tr style="height: 33px"><td width="250"><p id="u02a2a9e7" class="ne-p"><span class="ne-text">性能侧重点</span></p></td><td width="250"><p id="ua1cc5abd" class="ne-p"><span class="ne-text">浅层快速对比，提升性能</span></p></td><td width="250"><p id="ufe6abedc" class="ne-p"><span class="ne-text">通过最小化修改和静态节点优化提升性能</span></p></td></tr></tbody></table><p id="u24a568df" class="ne-p"><span class="ne-text">总结来看，React 和 Vue 都在 Diff 算法中采用了 O(n) 的复杂度优化，不过 React 更关注通过 Fiber 分层进行调和和渲染，而 Vue 则通过双端比较和静态节点优化来提高渲染效率。两者都在不断优化虚拟 DOM 的更新过程，以确保在复杂应用中的性能表现。</span></p></div>0:{"buildId":"fgnevoCcv3TjAYBn9b4Wj","rsc":["$","$1","c",{"children":[["$","section",null,{"className":"relative","children":["$","$L2",null,{"fade":true,"blur":true,"transition":{"duration":0.5},"delay":0.1,"className":"relative overflow-hidden border-y xl:flex","children":[["$","div",null,{"className":"m-6 w-full flex-1 bg-[radial-gradient(circle_at_center,color-mix(in_oklab,var(--primary)_15%,transparent)_2px,transparent_2px)] bg-size-[18px_18px] max-xl:hidden"}],["$","div",null,{"className":"mx-auto w-full max-w-6xl flex-none space-y-8 px-4 py-8 min-[1158px]:border-x sm:px-6 sm:py-12 lg:px-8","children":[["$","$L2",null,{"fade":true,"blur":true,"slide":{"direction":"down","offset":30},"transition":{"duration":0.4},"children":["$","$L3",null,{"href":"/blog","className":"text-muted-foreground hover:text-foreground inline-flex items-center gap-2 text-sm transition-colors","children":[["$","svg",null,{"xmlns":"http://www.w3.org/2000/svg","width":24,"height":24,"viewBox":"0 0 24 24","fill":"none","stroke":"currentColor","strokeWidth":2,"strokeLinecap":"round","strokeLinejoin":"round","className":"lucide lucide-arrow-left h-4 w-4","aria-hidden":"true","children":[["$","path","1l729n",{"d":"m12 19-7-7 7-7"}],["$","path","x3x0zl",{"d":"M19 12H5"}],"$undefined"]}],"返回","技术博客"]}]}],["$","article",null,{"className":"mx-auto max-w-4xl","children":[["$","header",null,{"className":"mb-8 space-y-6","children":["",["$","$L2",null,{"delay":0.3,"transition":{"duration":0.5},"children":["$","h1",null,{"className":"text-2xl font-bold tracking-tight sm:text-3xl md:text-4xl","children":["$","$L4",null,{"text":"[AI] Vue和React的diff算法","delay":30,"animateBy":"words","direction":"bottom"}]}]}],["$","$L2",null,{"fade":true,"blur":true,"slide":{"direction":"down","offset":30},"delay":0.4,"transition":{"duration":0.5},"children":["$","p",null,{"className":"text-muted-foreground text-lg","children":"Vue 和 React 的 diff 算法都是为了解决虚拟 DOM 更新的问题，它们都使用了 Diffing 技术来优化 DOM 渲染。虽然两者有相似的思想，但实现上存在一些差异。1. React 的 Diff 算法React 使用了一种 O(n) 复杂度的 Diff 算法，这被称为 Fibe..."}]}],["$","$L2",null,{"fade":true,"blur":true,"slide":{"direction":"down","offset":30},"delay":0.5,"transition":{"duration":0.5},"children":["$","div",null,{"className":"text-muted-foreground flex flex-wrap items-center gap-4 text-sm","children":[["$","div",null,{"className":"flex items-center gap-1","children":[["$","svg",null,{"xmlns":"http://www.w3.org/2000/svg","width":24,"height":24,"viewBox":"0 0 24 24","fill":"none","stroke":"currentColor","strokeWidth":2,"strokeLinecap":"round","strokeLinejoin":"round","className":"lucide lucide-calendar h-4 w-4","aria-hidden":"true","children":[["$","path","1cmpym",{"d":"M8 2v4"}],["$","path","4m81vk",{"d":"M16 2v4"}],["$","rect","1hopcy",{"width":"18","height":"18","x":"3","y":"4","rx":"2"}],["$","path","8toen8",{"d":"M3 10h18"}],"$undefined"]}],["$","span",null,{"children":"2025年2月17日"}]]}],["$","div",null,{"className":"flex items-center gap-1","children":[["$","svg",null,{"xmlns":"http://www.w3.org/2000/svg","width":24,"height":24,"viewBox":"0 0 24 24","fill":"none","stroke":"currentColor","strokeWidth":2,"strokeLinecap":"round","strokeLinejoin":"round","className":"lucide lucide-clock h-4 w-4","aria-hidden":"true","children":[["$","path","mmk7yg",{"d":"M12 6v6l4 2"}],["$","circle","1mglay",{"cx":"12","cy":"12","r":"10"}],"$undefined"]}],["$","span",null,{"children":"1.2千字"}]]}],false,false,false]}]}],false]}],["$","$L2",null,{"delay":0.6,"fade":true,"blur":true,"transition":{"duration":0.6},"className":"-mx-4 sm:-mx-6 lg:-mx-8","children":["$","$L5",null,{}]}],["$","$L2",null,{"fade":true,"blur":true,"slide":{"direction":"up","offset":50},"delay":0.7,"transition":{"duration":0.6},"children":["$","div",null,{"className":"prose prose-neutral dark:prose-invert mt-8 max-w-none","dangerouslySetInnerHTML":{"__html":"$6"}}]}],"$L7","$L8"]}]]}],"$L9"]}]}],["$La"],"$Lb"]}],"loading":null,"isPartial":false}
7:["$","$L2",null,{"delay":0.8,"fade":true,"blur":true,"transition":{"duration":0.6},"className":"-mx-4 mt-12 sm:-mx-6 lg:-mx-8","children":["$","$L5",null,{}]}]
8:["$","$L2",null,{"fade":true,"blur":true,"slide":{"direction":"up","offset":30},"delay":0.9,"transition":{"duration":0.5},"children":["$","nav",null,{"className":"mt-8 grid gap-4 md:grid-cols-2","children":[["$","$L3",null,{"href":"/blog/yv525gyibqzx53c9","className":"hover:bg-muted group flex flex-col rounded-lg border p-4 transition-colors","children":[["$","span",null,{"className":"text-muted-foreground mb-2 text-sm","children":"上一篇"}],["$","span",null,{"className":"group-hover:text-primary line-clamp-2 font-medium transition-colors","children":"至少有一个属性存在/数组长度不为0"}]]}],["$","$L3",null,{"href":"/blog/rmwmcbmn68nyazbw","className":"hover:bg-muted group flex flex-col rounded-lg border p-4 text-right transition-colors md:text-right","children":[["$","span",null,{"className":"text-muted-foreground mb-2 text-sm","children":"下一篇"}],["$","span",null,{"className":"group-hover:text-primary line-clamp-2 font-medium transition-colors","children":"[AI] Vue3为什么要用proxy"}]]}]]}]}]
9:["$","div",null,{"className":"m-6 w-full flex-1 bg-[radial-gradient(circle_at_center,color-mix(in_oklab,var(--primary)_15%,transparent)_2px,transparent_2px)] bg-size-[18px_18px] max-xl:hidden"}]
a:["$","script","script-0",{"src":"/_next/static/chunks/11dff99839ab5ba0.js","async":true}]
b:["$","$Lc",null,{"children":["$","$d",null,{"name":"Next.MetadataOutlet","children":"$@e"}]}]
e:null
