1:"$Sreact.fragment"
2:I[99897,["/_next/static/chunks/4eaa70fe861e9598.js","/_next/static/chunks/fa1a8f8830b9bf3a.js","/_next/static/chunks/6dd6809ee42e252f.js","/_next/static/chunks/f2b800ca7ae14e96.js","/_next/static/chunks/e121db38c98deeb4.js","/_next/static/chunks/6d971f5a9c16d0c2.js","/_next/static/chunks/b397c2fd2abb1207.js","/_next/static/chunks/11dff99839ab5ba0.js"],"MotionPreset"]
3:I[22016,["/_next/static/chunks/4eaa70fe861e9598.js","/_next/static/chunks/fa1a8f8830b9bf3a.js","/_next/static/chunks/6dd6809ee42e252f.js","/_next/static/chunks/f2b800ca7ae14e96.js","/_next/static/chunks/e121db38c98deeb4.js","/_next/static/chunks/6d971f5a9c16d0c2.js","/_next/static/chunks/b397c2fd2abb1207.js","/_next/static/chunks/11dff99839ab5ba0.js"],""]
4:I[85437,["/_next/static/chunks/4eaa70fe861e9598.js","/_next/static/chunks/fa1a8f8830b9bf3a.js","/_next/static/chunks/6dd6809ee42e252f.js","/_next/static/chunks/f2b800ca7ae14e96.js","/_next/static/chunks/e121db38c98deeb4.js","/_next/static/chunks/6d971f5a9c16d0c2.js","/_next/static/chunks/b397c2fd2abb1207.js","/_next/static/chunks/11dff99839ab5ba0.js"],"Image"]
5:I[48347,["/_next/static/chunks/4eaa70fe861e9598.js","/_next/static/chunks/fa1a8f8830b9bf3a.js","/_next/static/chunks/6dd6809ee42e252f.js","/_next/static/chunks/f2b800ca7ae14e96.js","/_next/static/chunks/e121db38c98deeb4.js","/_next/static/chunks/6d971f5a9c16d0c2.js","/_next/static/chunks/b397c2fd2abb1207.js","/_next/static/chunks/11dff99839ab5ba0.js"],"default"]
6:I[72436,["/_next/static/chunks/4eaa70fe861e9598.js","/_next/static/chunks/fa1a8f8830b9bf3a.js","/_next/static/chunks/6dd6809ee42e252f.js","/_next/static/chunks/f2b800ca7ae14e96.js","/_next/static/chunks/e121db38c98deeb4.js","/_next/static/chunks/6d971f5a9c16d0c2.js","/_next/static/chunks/b397c2fd2abb1207.js","/_next/static/chunks/11dff99839ab5ba0.js"],"Separator"]
e:I[97367,["/_next/static/chunks/ff1a16fafef87110.js","/_next/static/chunks/7340adf74ff47ec0.js"],"OutletBoundary"]
f:"$Sreact.suspense"
0:{"buildId":"2Uf-0k87jGUS-VSwdLfXo","rsc":["$","$1","c",{"children":[["$","section",null,{"className":"relative","children":["$","$L2",null,{"fade":true,"blur":true,"transition":{"duration":0.5},"delay":0.1,"className":"relative overflow-hidden border-y xl:flex","children":[["$","div",null,{"className":"m-6 w-full flex-1 bg-[radial-gradient(circle_at_center,color-mix(in_oklab,var(--primary)_15%,transparent)_2px,transparent_2px)] bg-size-[18px_18px] max-xl:hidden"}],["$","div",null,{"className":"mx-auto w-full max-w-6xl flex-none space-y-8 px-4 py-8 min-[1158px]:border-x sm:px-6 sm:py-12 lg:px-8","children":[["$","$L2",null,{"fade":true,"blur":true,"slide":{"direction":"down","offset":30},"transition":{"duration":0.4},"children":["$","$L3",null,{"href":"/blog","className":"text-muted-foreground hover:text-foreground inline-flex items-center gap-2 text-sm transition-colors","children":[["$","svg",null,{"xmlns":"http://www.w3.org/2000/svg","width":24,"height":24,"viewBox":"0 0 24 24","fill":"none","stroke":"currentColor","strokeWidth":2,"strokeLinecap":"round","strokeLinejoin":"round","className":"lucide lucide-arrow-left h-4 w-4","aria-hidden":"true","children":[["$","path","1l729n",{"d":"m12 19-7-7 7-7"}],["$","path","x3x0zl",{"d":"M19 12H5"}],"$undefined"]}],"返回","技术博客"]}]}],["$","article",null,{"className":"mx-auto max-w-4xl","children":[["$","header",null,{"className":"mb-8 space-y-6","children":[["$","$L2",null,{"fade":true,"blur":true,"slide":{"direction":"up","offset":50},"delay":0.2,"transition":{"duration":0.6},"children":["$","div",null,{"className":"relative aspect-video overflow-hidden rounded-xl","children":["$","$L4",null,{"src":"https://cdn.nlark.com/yuque/0/2020/png/1484158/1605320252853-c5d445e4-aa0e-4279-b9fd-7477f23b1bc1.png","alt":"最小生成树算法（Prim+Kruskal）","fill":true,"className":"object-cover","unoptimized":true}]}]}],["$","$L2",null,{"delay":0.3,"transition":{"duration":0.5},"children":["$","h1",null,{"className":"text-2xl font-bold tracking-tight sm:text-3xl md:text-4xl","children":["$","$L5",null,{"text":"最小生成树算法（Prim+Kruskal）","delay":30,"animateBy":"words","direction":"bottom"}]}]}],["$","$L2",null,{"fade":true,"blur":true,"slide":{"direction":"down","offset":30},"delay":0.4,"transition":{"duration":0.5},"children":["$","p",null,{"className":"text-muted-foreground text-lg","children":"贪心算法四个字总结：目前最优图的一些概念具体看先前的一篇文章https://www.wztlink1013.com/blog/gqpli5/连通图在图论中，连通图基于连通的概念。在一个无向图 G 中，若从顶点i到顶点j有路径相连（当然从j到i也一定有路径），则称i和j是连通的。如果 G 是有向..."}]}],["$","$L2",null,{"fade":true,"blur":true,"slide":{"direction":"down","offset":30},"delay":0.5,"transition":{"duration":0.5},"children":["$","div",null,{"className":"text-muted-foreground flex flex-wrap items-center gap-4 text-sm","children":[["$","div",null,{"className":"flex items-center gap-1","children":[["$","svg",null,{"xmlns":"http://www.w3.org/2000/svg","width":24,"height":24,"viewBox":"0 0 24 24","fill":"none","stroke":"currentColor","strokeWidth":2,"strokeLinecap":"round","strokeLinejoin":"round","className":"lucide lucide-calendar h-4 w-4","aria-hidden":"true","children":[["$","path","1cmpym",{"d":"M8 2v4"}],["$","path","4m81vk",{"d":"M16 2v4"}],["$","rect","1hopcy",{"width":"18","height":"18","x":"3","y":"4","rx":"2"}],["$","path","8toen8",{"d":"M3 10h18"}],"$undefined"]}],["$","span",null,{"children":"2020年11月14日"}]]}],["$","div",null,{"className":"flex items-center gap-1","children":[["$","svg",null,{"xmlns":"http://www.w3.org/2000/svg","width":24,"height":24,"viewBox":"0 0 24 24","fill":"none","stroke":"currentColor","strokeWidth":2,"strokeLinecap":"round","strokeLinejoin":"round","className":"lucide lucide-clock h-4 w-4","aria-hidden":"true","children":[["$","path","mmk7yg",{"d":"M12 6v6l4 2"}],["$","circle","1mglay",{"cx":"12","cy":"12","r":"10"}],"$undefined"]}],["$","span",null,{"children":"1.2千字"}]]}],["$","div",null,{"className":"flex items-center gap-1","children":[["$","svg",null,{"xmlns":"http://www.w3.org/2000/svg","width":24,"height":24,"viewBox":"0 0 24 24","fill":"none","stroke":"currentColor","strokeWidth":2,"strokeLinecap":"round","strokeLinejoin":"round","className":"lucide lucide-eye h-4 w-4","aria-hidden":"true","children":[["$","path","1nclc0",{"d":"M2.062 12.348a1 1 0 0 1 0-.696 10.75 10.75 0 0 1 19.876 0 1 1 0 0 1 0 .696 10.75 10.75 0 0 1-19.876 0"}],["$","circle","1v7zrd",{"cx":"12","cy":"12","r":"3"}],"$undefined"]}],["$","span",null,{"children":[11," 阅读"]}]]}],false,false]}]}],false]}],["$","$L2",null,{"delay":0.6,"fade":true,"blur":true,"transition":{"duration":0.6},"className":"-mx-4 sm:-mx-6 lg:-mx-8","children":["$","$L6",null,{}]}],["$","$L2",null,{"fade":true,"blur":true,"slide":{"direction":"up","offset":50},"delay":0.7,"transition":{"duration":0.6},"children":"$L7"}],"$L8","$L9"]}]]}],"$La"]}]}],["$Lb"],"$Lc"]}],"loading":null,"isPartial":false}
d:T342d,<!doctype html><div class="lake-content" typography="classic"><div data-type="info" class="ne-alert"><p id="5e0adbd3c4d03c372bc5bdbf949fc59c" class="ne-p"><span class="ne-text" style="background-color: #E8F7FF">贪心算法四个字总结：目前最优</span></p></div><h2 id="nHUEx"><span class="ne-text">图的一些概念</span></h2><p id="be7203f2c5e3cc70ac3430a06137165d" class="ne-p"><span class="ne-text">具体看先前的一篇文章</span><a href="https://www.wztlink1013.com/blog/gqpli5/" data-href="https://www.wztlink1013.com/blog/gqpli5/" target="_blank" class="ne-link"><span class="ne-text">https://www.wztlink1013.com/blog/gqpli5/</span></a></p><p id="5898cb029323a7e7bcde68a749655cea" class="ne-p"><span class="ne-text"></span></p><p id="0efe0efc44dc0dc883b9f397c6ac1ab9" class="ne-p"><strong><span class="ne-text">连通图</span></strong></p><div class="ne-quote"><p id="8380f5d22f1a9a91b06b0c585ee37581" class="ne-p"><span class="ne-text" style="color: #333333; font-size: 14px">在</span><a href="https://baike.baidu.com/item/%E5%9B%BE%E8%AE%BA/1433806" data-href="https://baike.baidu.com/item/%E5%9B%BE%E8%AE%BA/1433806" target="_blank" class="ne-link"><span class="ne-text">图论</span></a><span class="ne-text" style="color: #333333; font-size: 14px">中，连通图基于连通的概念。在一个</span><a href="https://baike.baidu.com/item/%E6%97%A0%E5%90%91%E5%9B%BE/1680427" data-href="https://baike.baidu.com/item/%E6%97%A0%E5%90%91%E5%9B%BE/1680427" target="_blank" class="ne-link"><span class="ne-text">无向图</span></a><span class="ne-text" style="color: #333333; font-size: 14px"> G 中，若从</span><a href="https://baike.baidu.com/item/%E9%A1%B6%E7%82%B9/11030118" data-href="https://baike.baidu.com/item/%E9%A1%B6%E7%82%B9/11030118" target="_blank" class="ne-link"><span class="ne-text">顶点</span></a><span class="ne-text" style="color: #333333; font-size: 14px">i到顶点j有路径相连（当然从j到i也一定有路径），则称i和j是连通的。如果 G 是</span><a href="https://baike.baidu.com/item/%E6%9C%89%E5%90%91%E5%9B%BE" data-href="https://baike.baidu.com/item/%E6%9C%89%E5%90%91%E5%9B%BE" target="_blank" class="ne-link"><span class="ne-text">有向图</span></a><span class="ne-text" style="color: #333333; font-size: 14px">，那么连接i和j的路径中所有的边都必须同向。如果图中任意两点都是连通的，那么图被称作连通图。如果此图是有向图，则称为强连通图（注意：需要双向都有路径）。图的</span><a href="https://baike.baidu.com/item/%E8%BF%9E%E9%80%9A%E6%80%A7/6688865" data-href="https://baike.baidu.com/item/%E8%BF%9E%E9%80%9A%E6%80%A7/6688865" target="_blank" class="ne-link"><span class="ne-text">连通性</span></a><span class="ne-text" style="color: #333333; font-size: 14px">是图的基本性质。</span></p></div><p id="665951f6ed45e95795596091ea37cb43" class="ne-p"><strong><span class="ne-text">生成树</span></strong></p><div class="ne-quote"><p id="10112c33ae37e9de266d7dc9ad43da3e" class="ne-p"><span class="ne-text">包含图的全部顶点，边数最少的连通子图</span></p></div><p id="bf98f96271e09d1bf20e8fafda285603" class="ne-p"><strong><span class="ne-text">最小生成树</span></strong></p><div class="ne-quote"><p id="3826220ba76c178c35683068e2ab02a8" class="ne-p"><span class="ne-text">总权值最小的生成树</span></p></div><p id="b7c6c94ca874bae05cd003d128c1f69e" class="ne-p"><span class="ne-text">常见问题（该算法）就是求最小生成树。</span></p><p id="3ad4e5b28974402730ddf0a7a6c9a765" class="ne-p"><strong><span class="ne-text">并查集</span></strong></p><div class="ne-quote"><p id="fb49f1af56a20258b0994e05a5bd822f" class="ne-p"><span class="ne-text">是一个数据结构，功能有查找a和b是否为同一组；将a和b合并为同一组。</span></p></div><h2 id="Vz5Jg"><span class="ne-text">Prim算法思路</span></h2><p id="63b94f88c91d418b3a5ea7c1d40eb1c1" class="ne-p"><code class="ne-code"><span class="ne-text">Prim——普里姆算法</span></code></p><p id="57e1c39936058ab0cf89190777c671eb" class="ne-p"><span class="ne-text"></span></p><p id="65c9dddc9466daf1f87f622ae9013e7e" class="ne-p"><span class="ne-text">类似于图的深度优先遍历一样，在遍历到一个结点的时候，在此根据该节点所连通的各边权值，取最小的，以此往复</span></p><p id="cbff9ebe6415e49d40421bd46dcadcad" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1625102662437-05ab5a6e-fcc3-46d5-8c2d-666c9c23fa9a.png" width="388" id="Qjspy" class="ne-image"></p><h2 id="PFbmU"><span class="ne-text">Kruskal算法</span><span class="ne-text">思路</span></h2><p id="bc1fd8840968eaa8cd942c02348006fc" class="ne-p"><code class="ne-code"><span class="ne-text">Kruskal——克鲁斯卡尔算法</span></code></p><p id="5d99ae9579b08eceffe5b7ad59c14ee2" class="ne-p"><br></p><p id="7a889ea78b39c7c9c9904fcebe169343" class="ne-p"><span class="ne-text">把所有边按照权值全部按数值大小拿出来，然后按顺序选取每条边，利用并查集的思想，如果这条边的两个端点不属于同一集合，那么就将它们合并，直到所有的点都属于同一个集合为止。</span></p><p id="26e6db5a49dd1bdcfc6be897e96f7c38" class="ne-p"><br></p><p id="bb2fe010dc25de5f292f2c92b428fe68" class="ne-p"><span class="ne-text">比如有如下这么一个图：</span></p><p id="6e2e9f3149f755d4f53fdad50964b38b" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1605320252853-c5d445e4-aa0e-4279-b9fd-7477f23b1bc1.png" width="219" id="Hx7aL" class="ne-image"></p><p id="aac64b9ab680edd476d18b367cb142ba" class="ne-p" style="text-align: left"><span class="ne-text">单独分析①②边和③④边情况下，两个不在一个集合里面，</span></p><p id="39ba58d75802638e8beb1aeb08e5f2b4" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1605320331669-51ec03dc-caf6-449d-9e8b-e4e62b9f35a6.png" width="384.5" id="PuNRa" class="ne-image"></p><p id="c55b6b173dedc37838a3ebc2021f673d" class="ne-p"><span class="ne-text">不断重复，不断判断是否为同一个集合，不在同一个集合的话，就合并，持续如此。比方说当一直操作到权值为3的时候，此时就需要将左右两个集合合并了</span></p><p id="90ebd57d6561894820dc28eb8dba77c2" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1605320497092-00097419-4852-44c4-884e-febd4d37eb65.png" width="374" id="wsUam" class="ne-image"></p><p id="997a98f28e94a25540a4893a96c5098d" class="ne-p" style="text-align: left"><span class="ne-text">最后的结果样式就为如下</span></p><p id="fd9a3ee6d2a2bf0a101c0dfb8cb7eb03" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1605320612085-d893c759-4ef1-410c-976e-8f32ddfe6321.png" width="390" id="adOCr" class="ne-image"></p><p id="91b40a459460ec5d2efb79ae1d139a58" class="ne-p" style="text-align: center"><br></p><h2 id="9kZiP"><span class="ne-text">代码实现</span></h2><h3 id="YPhZh"><span class="ne-text">Kruskal算法代码</span></h3><pre data-language="cpp" id="ViSvq" class="ne-codeblock language-cpp">#include &lt;stdio.h&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
namespace NS_KruskalMST {
using namespace std;
void KruskalMST();
int FindSet(int u);
void UnionSets(int u, int v);
void Initialization();
void GenEdges();
void MakeSets();
void Output(int v0);
#define INF INT_MAX
static int n;
static vector&lt;vector&lt;int&gt;&gt; WMatrix;
static vector&lt;pair&lt;pair&lt;int, int&gt;, int&gt;&gt; Edges;
//Node struct for the disjoint set
struct DJSNode {
    int Parent; int Rank;
    DJSNode(int p) : Parent(p), Rank(0) {}
};
static vector&lt;DJSNode&gt; DisjointSet;
static vector&lt;pair&lt;int, int&gt;&gt; MST;
//The adjacency list for MST
static vector&lt;vector&lt;int&gt;&gt; MSTList;
static vector&lt;int&gt; Prev;
void KruskalMSTCaller(int an, 
    vector&lt;vector&lt;int&gt;&gt; &amp;wMatrix, int v0)
{
    n = an;
    WMatrix = wMatrix;
    Initialization();
    KruskalMST();
    Output(v0);
}
void KruskalMST()
{
    for (auto &amp;e: Edges)
    {
        int u = e.first.first;
        int v = e.first.second;
        int setU = FindSet(u);
        int setV = FindSet(v);
        if (setU != setV)
        {
            MST.push_back(e.first);
            if (MST.size() == n - 1)
                break;
            UnionSets(setU, setV);
        }
    }
}
int FindSet(int u)
{
    while (u != DisjointSet[u].Parent)
        u = DisjointSet[u].Parent;
        //For path compression:
        //DisjointSet[u].Parent = 
        //    FindSet(DisjointSet[u].Parent);
    return u;
}
void UnionSets(int u, int v)
{
    if (DisjointSet[u].Rank &gt;= DisjointSet[v].Rank)
        DisjointSet[v].Parent = u;
    else
        DisjointSet[u].Parent = v;
    if (DisjointSet[u].Rank == DisjointSet[v].Rank)
        DisjointSet[u].Rank++;
}
void Initialization()
{
    GenEdges();
    sort(Edges.begin(), Edges.end(), 
        [](pair&lt;pair&lt;int, int&gt;, int&gt;a, 
            pair&lt;pair&lt;int, int&gt;, int&gt;b)
        {return a.second &lt; b.second; });
    MakeSets();
    MST.clear();
}
void GenEdges()
{
    Edges.clear();
    //Traverse the upper triangle of WMatrix
    for (int i = 0; i &lt; n - 1; i++)
    {
        for (int j = i + 1; j &lt; n; j++)
            if (WMatrix[i][j] != INF)
                Edges.push_back({ {i, j},
                    WMatrix[i][j] });
    }
}
void MakeSets()
{
    DisjointSet.clear();
    for (int i = 0; i &lt; n; i++)
        DisjointSet.push_back(DJSNode(i));
}
void OutputWMatrix()
{
    printf(&quot;n = %d\n&quot;, n);
    printf(&quot;The weight matrix:\n&quot;);
    printf(&quot;%3c&quot;, ' ');
    for (int j = 0; j &lt; n; j++)
        printf(&quot;%3d&quot;, j + 1);
    printf(&quot;\n&quot;);
    for (int i = 0; i &lt; n; i++)
    {
        printf(&quot;%3d&quot;, i + 1);
        for (auto j : WMatrix[i])
            if (j &lt; INF)
                printf(&quot;%3d&quot;, j);
            else
                printf(&quot;%3c&quot;, '*');
        printf(&quot;\n&quot;);
    }
}
void OutputPath(int u)
{
    if (Prev[u] == -1)
        printf(&quot;%d&quot;, u + 1);
    else
    {
        OutputPath(Prev[u]);
        printf(&quot;-%d&quot;, u + 1);
    }
}
void GenMSTList()
{
    MSTList.clear();
    MSTList.resize(n);
    for (auto &amp;e: MST)
    {
        MSTList[e.first].push_back(e.second);
        MSTList[e.second].push_back(e.first);
    }
}
void GenPrev(int v)
{
    for (auto &amp;u : MSTList[v])
        if (u != -1)
        {
            Prev[u] = v;
            auto w = find(MSTList[u].begin(), 
                MSTList[u].end(), v);
            MSTList[u][w - MSTList[u].begin()] = -1;
            GenPrev(u);
        }
}
void Output(int v0)
{
    printf(&quot;Kruskal's MST algorithm\n&quot;);
    OutputWMatrix();
    int wSum = 0;
    for (int i = 0; i &lt; n - 1; i++)
        wSum += WMatrix[MST[i].first][MST[i].second];
    GenMSTList();
    Prev.clear();
    Prev.resize(n);
    Prev[v0] = -1;
    GenPrev(v0);
    printf(&quot;The MST edges:\n&quot;);
    printf(&quot;Edge Weight\n&quot;);
    for (auto &amp;e : MST)
        printf(&quot; %d-%d  %d\n&quot;, e.first + 1, e.second + 1,
            WMatrix[e.first][e.second]);
    printf(&quot;Total MST weight: %d\n&quot;, wSum);
    printf(&quot;The MST paths from vertex %d:\n&quot;, v0 + 1);
    for (int u = 0; u &lt; n; u++)
        if (u != v0)
        {
            printf(&quot;%3d: &quot;, u + 1);
            OutputPath(u);
            printf(&quot;\n&quot;);
        }
    printf(&quot;\n&quot;);
}
} //namespace NS_KruskalMST
using namespace NS_KruskalMST;
void TestKruskalMST(int v0 = 0)
{
    vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt; w = {
        //https://www.geeksforgeeks.org/
        //prims-minimum-spanning-tree-mst-greedy-algo-5/
        {
            {   0,  2,INF,  6,INF },
            {   2,  0,  3,  8,  5 },
            { INF,  3,  0,INF,  7 },
            {   6,  8,INF,  0,  9 },
            { INF,  5,  7,  9,  0 }
        },
        // Dijkstra's algorithm on Wikipedia
        {
            {   0,  7,  9,INF,INF, 14 },
            {   7,  0, 10, 15,INF,INF },
            {   9, 10,  0, 11,INF,  2 },
            { INF, 15, 11,  0,  6,INF },
            { INF,INF,INF,  6,  0,  9 },
            {  14,INF,  2,INF,  9,  0 },
        },
        //https://www.geeksforgeeks.org/
        //kruskals-minimum-spanning-tree-using-stl-in-c/
        {
            {   0,  4,INF,INF,INF,INF,INF,  8,INF },
            {   4,  0,  8,INF,INF,INF,INF, 11,INF },
            { INF,  8,  0,  7,INF,  4,INF,INF,  2 },
            { INF,INF,  7,  0,  9, 14,INF,INF,INF },
            { INF,INF,INF,  9,  0, 10,INF,INF,INF },
            { INF,INF,  4, 14, 10,  0,  2,INF,INF },
            { INF,INF,INF,INF,INF,  2,  0,  1,  6 },
            {   8, 11,INF,INF,INF,INF,  1,  0,  7 },
            { INF,INF,  2,INF,INF,INF,  6,  7,  0 },
        },
    };
    int k = w.size();
    for (int i = 0; i &lt; k; i++)
    {
      if (v0 &gt; w[i].size() - 1)
        v0 = w[i].size() - 1;
      KruskalMSTCaller(w[i].size(), w[i], v0);
    }
}</pre></div>7:["$","div",null,{"className":"prose prose-neutral dark:prose-invert mt-8 max-w-none","dangerouslySetInnerHTML":{"__html":"$d"}}]
8:["$","$L2",null,{"delay":0.8,"fade":true,"blur":true,"transition":{"duration":0.6},"className":"-mx-4 mt-12 sm:-mx-6 lg:-mx-8","children":["$","$L6",null,{}]}]
9:["$","$L2",null,{"fade":true,"blur":true,"slide":{"direction":"up","offset":30},"delay":0.9,"transition":{"duration":0.5},"children":["$","nav",null,{"className":"mt-8 grid gap-4 md:grid-cols-2","children":[["$","$L3",null,{"href":"/blog/ggu8v9","className":"hover:bg-muted group flex flex-col rounded-lg border p-4 transition-colors","children":[["$","span",null,{"className":"text-muted-foreground mb-2 text-sm","children":"上一篇"}],["$","span",null,{"className":"group-hover:text-primary line-clamp-2 font-medium transition-colors","children":"Huffman编码算法"}]]}],["$","$L3",null,{"href":"/blog/lezklv","className":"hover:bg-muted group flex flex-col rounded-lg border p-4 text-right transition-colors md:text-right","children":[["$","span",null,{"className":"text-muted-foreground mb-2 text-sm","children":"下一篇"}],["$","span",null,{"className":"group-hover:text-primary line-clamp-2 font-medium transition-colors","children":"Git提交规范"}]]}]]}]}]
a:["$","div",null,{"className":"m-6 w-full flex-1 bg-[radial-gradient(circle_at_center,color-mix(in_oklab,var(--primary)_15%,transparent)_2px,transparent_2px)] bg-size-[18px_18px] max-xl:hidden"}]
b:["$","script","script-0",{"src":"/_next/static/chunks/11dff99839ab5ba0.js","async":true}]
c:["$","$Le",null,{"children":["$","$f",null,{"name":"Next.MetadataOutlet","children":"$@10"}]}]
10:null
