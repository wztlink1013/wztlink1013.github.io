<?xml version="1.0" encoding="utf-8"?><?xml-stylesheet type="text/css" href="/public/css/rss.css" ?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title><![CDATA[尼采般地抒情]]></title>
    <link>https://yun.wztlink1013.com/</link>
    <script xmlns="http://www.w3.org/1999/xhtml" src="/public/js/rss.js"></script>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    <description><![CDATA[什么都无法舍弃，什么也改变不了]]></description>
    <pubDate>Mon Oct 26 2020 22:17:22 GMT+0800 (GMT+08:00)</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title><![CDATA[test文本]]></title>
      <link>https://yun.wztlink1013.com/blog/2020/07/18/test/</link>
      <guid>https://yun.wztlink1013.com/blog/2020/07/18/test/</guid>
      <pubDate>Sat Jul 18 2020 14:19:00 GMT+0800 (GMT+08:00)</pubDate>
      <description>
      <![CDATA[这是摘要]]>
      
      </description>
      <content:encoded><![CDATA[<p>不管是大公司还是小公司，你都可以看见这类主管：他不断地从外面接活儿进来，然后排好时间、分好任务指派给你。在这样的主管下，你的角色更像是一个单纯的执行者，稍微好一点的情况是，他会给你安排大块的事情，糟糕一点的情况是，他指派给你的任务特别离散，不聚焦，让你东搞一下西搞一下。</p>
<p><img src="http://www.barretlee.com/blogimgs/2019/07/18/to_be_your_self_in_company.png" alt="破局"></p>
<p>明白自己处境的人，会忧虑，不明白的人，还觉得自己很充实。如果你恰好有这样的感觉，我可以告诉你几个破局的思路。</p>
<h4 id="1、不要把自己当成执行者"><a href="#1、不要把自己当成执行者" class="headerlink" title="1、不要把自己当成执行者"></a>1、不要把自己当成执行者</h4><p>很大一部分原因还是因为，你自己把自己当成了执行者，你不愿意去分析需求或者不懂得如何去分析需求，你没有一个长期的聚焦的目标，结果就是你的主管会帮你做好这一切，他会根据团队今年的目标分析出几件核心的事情，然后将事情细化之后分派给团队的同学，如果你有一定的规划能力，他可能会把一整件事情交给你，如果没有，那大概率就是东边人手不足把你推过去，西边时间紧急把你拉回来。</p>
<p>提升自己的主观能动性，主动去 Owner 一块事情，给出详细的规划和落地方案，不断找主管和合作伙伴对焦，自然而然你的规划力就显露出来了。不要把自己当成执行者，而是 Owner。</p>
<h4 id="2、帮助你的主管认识到自己的问题"><a href="#2、帮助你的主管认识到自己的问题" class="headerlink" title="2、帮助你的主管认识到自己的问题"></a>2、帮助你的主管认识到自己的问题</h4><p>很显然，把下属当做执行者也是主管的问题，任何一个人都是可培养的，否则当初也不会把你招进来，你可以找主管沟通，告诉他你最近处于什么状态，其实很可能在给你委派零散需求这件事情上，他并没有意识到会不利于你的成长，你需要吐露自己的心声，告诉主管你想得到什么，而现在的工作方式可能让你拿不到想要的结果。</p>
<p>主管也有能力强和能力弱的，对于没有太多管理经验的主管，他做事可能依然是当初个人作战时的风格，关注的是事情，没有考虑到人的成长。</p>
<h4 id="3、搞清楚团队的目标和个人的目标"><a href="#3、搞清楚团队的目标和个人的目标" class="headerlink" title="3、搞清楚团队的目标和个人的目标"></a>3、搞清楚团队的目标和个人的目标</h4><p>一个没有目标的团队是难以凝聚到一起的，在定义个人目标之前，你首先需要知道团队的目标是什么，说得直白一点，你需要知道主管今年的目标是什么，想一想自己承担了主管目标的哪个部分，偏离的太多肯定是不行的，个人的核心目标一定要与团队目标进行对焦。</p>
<p>目标一定是有挑战的，也是能拿到结果的，当你在执行任务的时候，可以去想一想，我手头的事情是否是完成个人目标的必做事项，如果不是，你就得想办法做取舍，至少得排个优先级。</p>
<h4 id="4、敢于-Say-No"><a href="#4、敢于-Say-No" class="headerlink" title="4、敢于 Say No"></a>4、敢于 Say No</h4><p>有的人敢跟需求方怼，但是在主管面前却毫无勇气，原因是主管会给你打绩效，他会影响你未来一年的涨薪、晋升等，所以对主管会言听计从。这显然是不对的。你是团队的一份子，你今年拿不到结果，也就意味着今年团队有一部分的结果堪忧，所以你在团队里无时无刻都扮演着重要的角色。</p>
<p>遇到不合理的需求，即使是主管指派的任务，你也要勇敢地站出来，告诉他，你错了，指出主管的错误，是为了自己好，更是为了团队好，你指出的问题越多，团队走偏的可能性就越低，你一定要明白这个道理。</p>
]]></content:encoded>
      <comments>https://yun.wztlink1013.com/blog/2020/07/18/test/#comments</comments>
    </item>
    
    <item>
      <title><![CDATA[work-life balance]]></title>
      <link>https://yun.wztlink1013.com/blog/2020/07/10/work-life-balance/</link>
      <guid>https://yun.wztlink1013.com/blog/2020/07/10/work-life-balance/</guid>
      <pubDate>Fri Jul 10 2020 22:55:00 GMT+0800 (GMT+08:00)</pubDate>
      <description>
      <![CDATA[小胡子哥的个人网站]]>
      
      </description>
      <content:encoded><![CDATA[<p>最近几天加班比较多，起得晚，所以晨课停了几天，后续还是得恢复习惯，保持下去。</p>
<p>就聊一聊为啥最近比较忙吧。</p>
<p>转岗来蚂蚁金服的语雀团队差不多一个半月了，由于之前在淘宝团队呆过五年，换到阿里另一个大团队，就像是换了个项目组，没啥特别明显的高原反应。适应环境对我来说是一件再轻松不过的事情了，可能最大的不一样是，又有机会去接触一批优秀的同学，找到几个有意思的灵魂。</p>
<p>如果你好奇为什么我可以快速适应，下面也可以简单聊一下：</p>
<ul>
<li><strong>首先，从业务中找到归属感</strong>，大家认识你最快的渠道并不是面对面的聊天，在一个项目组里，大家了解你的最快渠道就是看你对业务的思考和贡献，所以我一直逼着自己去思考，业务当中的问题，以及我能做什么；</li>
<li><strong>找到痛点问题，快速解决，快速拿结果，</strong>一个项目发育到一定的周期后，一定有些年久失修的内容，而且不同的角色遇到的问题都会有差异，跟不同的角色都聊一聊，找到与自己岗位相关的部分，去解决它；</li>
<li><strong>最难的一点是去找到自己在团队中的位置，</strong>团队之中的所有人，各司其职，都有分派好的工作内容，你在团队中需要长期负责哪一块？这也是我近一个多月想的最多的问题。</li>
</ul>
<p>把这几件事情做好，需要耗费不好的精力，复杂的倒不是执行，而是找到对的事情，以及想到好的策略。</p>
<p>Work-life balance，这个问题在网上经常看到，也曾经有人问过我，当时也是话未多说，大家相觑一笑。作为一个身上扛着房贷、车贷，有家、有室、有父母需要赡养的 80 后、90 后，真的很难摆脱这个魔咒，朝九晚五的平衡简直就是一种奢望。</p>
<p><strong>所以重点应该还是放在工作的效率和生活的质量上。</strong>自从有了孩子以后，我周末是坚决不会打开电脑的，任何事情，只要不给我打电话，坚决不处理。这其实是对自己的要求变高了，如果周一到周五的工作不够完善，你是很难避免周末接到电话的。</p>
<p>记得在五年陈典礼上，一位阿里合伙人分享了他平衡生活和工作的经验，我觉得很有道理。<strong>想把生活和工作平衡好是很难的，我们能做的、应该做的，就是认真对待每一件事情，在工作的时候，好好工作，回到家里，好好陪陪家人，陪伴的时长我们无法保障，那就把陪伴的质量提高上去。</strong>好好带孩子，耐心的跟她玩，用她听得懂的话跟她解释所有的疑问，也让她走进大人的世界，看看爸爸妈妈在忙什么，了解的多了，她理解的也就多了。</p>
<p>最近看到一篇公众号文章<a href="https://mp.weixin.qq.com/s/w5iSYaP9Wwma_mQVekdaHA" target="_blank" rel="noopener">《儿子出生后，我给自己立下三条育儿规矩》</a>，第二点提到的有效陪伴中，给出了一个有意思的思路，</p>
<blockquote>
<p>我给自己定下的第二条规矩就是，无论多忙，都要给孩子有效的陪伴。有效陪伴，指在陪孩子的过程中，父亲是专注的，而不是心无旁骛地玩手机，或处理其他事务。</p>
<p><strong>具体来看，从孩子出生到上大学，我决定跟他一起，干100件“大事”。</strong></p>
<ul>
<li>选一个国家，跟孩子一起待上至少一个月，一起探索异国文化；</li>
<li>一起学习一门外语，可能是我熟悉的英语，也可能是我正在学的日语，也可能是我也不熟悉的西班牙语或法语；</li>
<li>传授一些记忆术给孩子，免得他走死记硬背的老路；</li>
<li>带孩子学会篮球（我最喜欢的户外运动），如果他也喜欢的话；</li>
<li>也可以是台球，我曾经最喜欢的室内运动；</li>
<li>跟孩子一起写一本书吧，写书其实没那么困难；</li>
<li>冥想，不知道孩子是否喜欢，但值得一起实践一次；</li>
<li>一起深度研读一本小说；</li>
<li>一起深度了解一部电影，而不是简单看一遍；</li>
<li>一起去医院逛一次，从产科，到肿瘤科，都走一遍；（估计要孩子十岁之后做这事）</li>
<li>一起去老家的坟墓走走，或者去城市的殡仪馆看看；（孩子十五岁后吧）</li>
<li>……</li>
</ul>
</blockquote>
<p>这是一种把陪伴进行量化的有效措施，我觉得非常好，我也打算这么做，虽然不能达到生活和工作的时间平衡，但是一定程度上可以有强烈的心理平衡。</p>
]]></content:encoded>
      <comments>https://yun.wztlink1013.com/blog/2020/07/10/work-life-balance/#comments</comments>
    </item>
    
    <item>
      <title><![CDATA[给自己找个导师]]></title>
      <link>https://yun.wztlink1013.com/blog/2020/07/01/find-yourself-a-mentor/</link>
      <guid>https://yun.wztlink1013.com/blog/2020/07/01/find-yourself-a-mentor/</guid>
      <pubDate>Wed Jul 01 2020 22:54:00 GMT+0800 (GMT+08:00)</pubDate>
      <description>
      <![CDATA[小胡子哥的个人网站]]>
      
      </description>
      <content:encoded><![CDATA[<p>端午节那几天，与国外的几个朋友约了两场 video chat，一场是输出，一场是半输入半输出，感觉还是挺不错的，沟通的过程中，还了解了不少 Facebook 的绩效考核制度和公司文化，说实在的，感觉跟自己还蛮契合，要不是暂时不想出国，可能都会尝试投投简历，😄</p>
<p>印象最深刻的是，Facebook 的 mentor 文化，<strong>什么是 mentor，可以简单地理解成引路人、导师，一般这个人在综合能力和视野上比你优秀一些，他可以在你职业发展之路上提供有用的建议和帮助</strong>。</p>
<p>事实上，我在阿里这几年，也在不断地为自己找 mentor，甚至也会尝试成为他人的 mentor，最近思考了一下，感觉整个操作还是不太规范化，缺乏更多的有效性。</p>
<h3 id="寻找导师"><a href="#寻找导师" class="headerlink" title="寻找导师"></a>寻找导师</h3><p>走进一个偌大的林子里，谁是老鸟，谁是雏儿，仅凭声音你是听不出来的，当你刚踏进一家公司的时候，人生地不熟，社交圈子就身边的几个人，如何去找到一位能够帮助你，并且愿意帮助你的人，似乎并不是那么容易。</p>
<p><strong>导师，并不需要他每天在你身边晃来晃去，保持一个中短期的低密度联系即可</strong>，3~6 个月时间，或者 1 年左右，因为你的阶段性成长和沉淀一般也需要这么长的周期拿到结果；当然，你也可以跟导师建立深厚的友谊，让这个关系保持得更久一些。</p>
<p>那么，如何去寻找适合自己的导师呢？</p>
<p><strong>首先，你的 Leader 一定是你最好的导师</strong>，你们是一个利益共同体，他有义务对你的职业发展负责，而你也可以毫无顾忌地向他发起求助，另外，你们之间最有可能发展出深刻的友谊关系。但是 Leader 的两个局限性是：</p>
<ul>
<li>他是局中人，你跟 Leader 之间发现的问题具有同质性，视野是有限的</li>
<li>他可能很忙，作为一个 Leader，需要对每个下属负责，他的精力很可能不够用，你不好一直打扰他</li>
</ul>
<p>如果你觉得 Leader 给你的帮助还不够的话，你需要跳出团队，从外部寻求帮助，哪些人可以成为你的导师呢？另外一个挖掘点是，<strong>你的 Leader（或者你熟悉的与 Leader 平级的 Leader）的人脉</strong>，他们在公司的时间一般会更久一些，接触过的人会比较多，而且他们已经积累了一定的信誉，<strong>可以帮助你引荐更多不错的人。</strong></p>
<p>有些公司的职级是公开的，你也可以<strong>从公司的通讯录中找到那些职级比自己高一两级的人，甚至高三四级的人</strong>，跟他们聊一聊，根据我的经验，大部分人还是比较乐意跟你聊的，但，是否能成为你的导师，还需要看你自己的表现，以及他们的时间安排。</p>
<p><strong>另外，你还可以从各种分享会、交流会、业务沟通会，甚至是技术文章、Code Review 的沟通等渠道找到优秀的人</strong>，聪明的你应该不乏找到这些人的方法，关键在于，找到了之后，怎么去建立联系，并保持长久的关系？</p>
<h3 id="保持关系"><a href="#保持关系" class="headerlink" title="保持关系"></a>保持关系</h3><p>优秀的人更喜欢跟优秀的人在一起，我想这个道理，大家都是明白的，如果你想找到一位优秀的 mentor，你首先需要做的一件事情就是，表现出自己有足够的潜力成为优秀的人，因为谁也不想去尝试把一块烂泥巴扶上墙。值得注意的是，<strong>导师也只是个助力点火的角色，不要想着有了导师，就觉得自己可以“躺着成长”，你还是得奔跑，甚至更快速、更猛烈地奔跑</strong>。</p>
<p><strong>当发现自己成长的速度太慢的时候，需要先做一个自我诊断</strong>，列出自己的职业规划或者项目计划，对内容做分析，然后去比对期望值，看看自己还缺乏哪方面的知识、经验和能力。拿着你的分析，再去寻找导师寻求帮助。</p>
<p>当然，职场新人可能连自己想要什么都不知道，这个时候也可以去找导师聊一聊，<strong>询问一下那些优秀的人的成长经历是怎么样的，如果你也想成为那样的人，需要经历哪些阶段</strong>，慢慢的去找到适合自己的职业规划。</p>
<p>导师持续向你输出帮助的动力在于，<strong>他期望通过对你的帮助让你飞快地提升，一方面提升他的影响力，一方面从中获得成就感</strong>。Facebook 在这方面拿到的成果是可以纳入个人考核的，所以你会发现，在这家公司，你不用特别主动地去找 mentor，也会有 mentor 主动上门询问你是需要获得帮助，这样的氛围是不是挺有意思的~ 😄</p>
<p>给自己制定一个 3 个月到半年的详细规划，其中包含明确的目标、里程碑计划、每个阶段的衡量指标，以及每个阶段你可能会遇到的问题和风险，<strong>拿着这个规划，每半月或者一个月与导师对焦，让他给你的项目、个人发展、职业规范等各方面提出建议</strong>，在这个过程中，可以适当聊聊工作之外的事情，不断加深与导师之间的关系。</p>
<h3 id="导师的职责"><a href="#导师的职责" class="headerlink" title="导师的职责"></a>导师的职责</h3><p>优秀且有社交欲望的导师，会同时去给好多人提供帮助，这对导师来说，也是一种历练，有一个职业叫做 career coach，跟导师的工作内容就比较贴切了，只不过 career coach 是收费的，你跟他们之间通过物质利益输送保持稳定关系，这对发展潜力不够突出的人来说，或许是个快速找到导师的渠道。</p>
<p>有个词叫做因地制宜，什么样的土壤培育出什么样的种子，有的导师会习惯性地将你引导到他熟悉的路上，但这条路可能并不适合你，而导师的说服力一般都会特别强，在跟他沟通的过程中，你似乎很难拒绝不走他为你选择的路，这一点就十分尴尬了。</p>
<p>所以，<strong>作为导师，也需要在沟通中掌握更多的信息，结合学生的个人需求和个人特征，在长期目标上达成一致性。</strong>当然，有的时候，导师的判断是对的，只不过学生不想踏出舒适区，这就需要更多的情感支撑，帮助对方走过难关。</p>
<p>导师，本身就是个挺难驾驭的角色，并不是人人都能做好。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>开篇提到自己也有很多的操作不规范，更多的是过去给自己找导师的时候，缺少更多的规划性，都是讨论大方向问题，或者情感的倾诉，导师在我这里更多的是安慰剂或者强心剂，并没有起到长期辅助个人成长的作用。这一点是需要改进的。</p>
<p>写的匆忙，这次的早课分享就写到这里吧，大家有啥疑问可以提出来，后续再做更多的讨论。</p>
<p>以上，希望对有帮助。</p>
]]></content:encoded>
      <comments>https://yun.wztlink1013.com/blog/2020/07/01/find-yourself-a-mentor/#comments</comments>
    </item>
    
    <item>
      <title><![CDATA[今天你无效社交了么？]]></title>
      <link>https://yun.wztlink1013.com/blog/2020/06/28/useless-social-work/</link>
      <guid>https://yun.wztlink1013.com/blog/2020/06/28/useless-social-work/</guid>
      <pubDate>Sun Jun 28 2020 22:52:00 GMT+0800 (GMT+08:00)</pubDate>
      <description>
      <![CDATA[小胡子哥的个人网站]]>
      
      </description>
      <content:encoded><![CDATA[<p>不知道有多少人跟我一样，觉得社交——跟别人沟通和交流——是一件很有趣的事情，因此在过去的几年里，我花了大量时间在社交这件事情上。最近半年我在反思，我为什么要去社交？为什么我需要花费这么多时间去社交？我有多少时间的社交是有价值的？</p>
<h3 id="识别无效社交"><a href="#识别无效社交" class="headerlink" title="识别无效社交"></a>识别无效社交</h3><p>在网络上找到了一段对无效社交的定义：</p>
<blockquote>
<p>无效社交是指那种无法给你的精神、感情、工作、生活带来任何愉悦感和进步的社交活动。</p>
</blockquote>
<p>这种定义还是过于书面化，而且它并不准确，任何社交行为都会对人产生正面或者负面的影响，而这个影响到底是促使人进步还是毫无效果是很难直接衡量的。这就好比有人对你说，“打游戏、看小说是在浪费时间，没有意义”，事实上，你徜徉在游戏和小说的世界里可以不断地丰富自己的想象力，这难道不是促进作用么 🐶。</p>
<p><strong>社交的过程是一个信息交换的过程，如果在彼此的信息交换过程中，可以给对方带来一些新思路，或者解决了一些实际问题，我认为这就是有效的社交。</strong>简单来说，有效的社交就是会产生价值增量，只不过这里的增量有大也有小。</p>
<p>有了互联网以后，人们的信息触达面更广泛了，能够收到的反馈也会更多，当信息量达到一定程度后，我们就需要投入大量的时间去聆听、阅读、回复以及其他交互，这个过程中充斥了无效社交。为了分析在哪些环节会长生无效社交，我们不妨将社交行为做一个简单的分类：</p>
<p><img src="http://www.barretlee.com/blogimgs/2020/06/28/useless-socialization.png" alt="upload successful"></p>
<p>线上的社交分为阻塞式和异步式，比如打电话、发视频以及“钉一下”功能，基本都要求我们放下手头的工作，而微信和邮件都是可以换个时间去阅读和回复的。从社交的对象数量也可以分为，一对一，一对多和多对多等模式。</p>
<p>我们日常的社交行为十分丰富，举几个社交中经常遇到的的场景：</p>
<ul>
<li>在一个水军群里，看别人扯淡，你也凑合进去发表几句，聊着聊着还聊起劲了</li>
<li>看到一个人很厉害的样子，跑过去寒暄几句，凑个脸熟</li>
<li>在朋友圈宣泄几句，收到了不少人的反馈和点赞，接着在评论区跟人唠起来</li>
<li>在知乎看到了一个杠精，觉得他的观点太幼稚，跑过去义正言辞地跟人家聊/怼了起来</li>
<li>过年了，写一条祝福语，给所有的认识的不认识的朋友都发一次</li>
<li>……</li>
</ul>
<p>注意，以上场景，我并没有说它是无效社交。那么，接下来就要给出无效社交的定义了。</p>
<p><strong>每个人心中都有一把尺子，这个尺子可以衡量一件事物的价值，你觉得有意义的事情他觉得无意义，反之亦然，所以无效社交就是先确定好心中这把尺子的度量衡，在价值上低于度量衡的便是无效社交。</strong><br><strong><br>你可以把自己心中的尺子拿出来，对着上面几个场景量一量，就可以量出你心中的无效社交。</strong>当然，这么做会显得有些功利主义，但是你得搞清楚，如果无效社交占据了你大量的时间，那么可以真正被用来做事情的时间便会越来越少。**</p>
<h3 id="提升社交的质量"><a href="#提升社交的质量" class="headerlink" title="提升社交的质量"></a>提升社交的质量</h3><p>靠自律，可以减少一定的无效社交，比如你可以不混水军群，不去吐槽，不做键盘侠，少接触人等等，但是这么做也会让自己变得很无趣，而且失去了很多原有的高质量社交场景。该如何做呢？</p>
<p><strong>建议 首先，你要想清楚，为什么需要社交？</strong>是因为想获得某个人的帮助，还是想泡上哪个女孩，是为了扩大自己的社交圈，还是为了变成一个健谈的人？社交可以分为主动社交和被动社交，大部分的社交行为，都是双方各占据一个角色，</p>
<ul>
<li>如果你是主动社交，你需要想清楚，你期望他帮助你解决什么问题，他能够帮助么？他愿意帮助么？</li>
<li>如果你是被动社交，你需要想清楚，你能帮助他么？你需要帮助他么？是不是还会衍生会延续的社交内容？</li>
</ul>
<p>当然，以上都是趋于功利主义的分析，但<strong>这样的分析方式，可以让你的社交更具备目的性，心怀“互利共赢”四个字，这样才能产生更大的有效性社交。</strong><br><strong>
</strong>建议 然后，你需要思考，怎样的社交是最有效率的？**我们经常可以看到这样的场景：</p>
<ul>
<li>寒暄了半天，结果跑题了，扯了半天陈年往事，正准备聊正事儿，人家说要去吃个午饭了</li>
<li>遇到了问题，找到 A，结果让去找 B，找了 B 让去找 C，找了一圈，最后还是自己去解决的</li>
</ul>
<p>直击痛点和重点是一门艺术，它能够反映一个人的抽象能力和分析能力。有效的社交需要过滤信息杂音，彼此之间最快达到共识；有效社交也需要你擦亮眼睛，看清楚人和事之间的枢纽关系，找到最合适的对象沟通。</p>
<p><strong>建议 为你的下次社交活动埋个好的伏笔。</strong>人情是个很好的东西，今天你帮了我，明天我就会帮助你，大家在相互帮助中让自己期望达成的事情更有效率地达成，本身就是有利于社会发展的好事。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>想获得好的社交，可以尝试不断地置换身边交流的人，让负面的声音、消极的身影和低质量的信息从自己的视线里减少，慢慢的，你的社交质量就上来了。</p>
<p><strong>遵从自己的内心，真诚、友善、和谐地社交，也会赢得更多的高质量的社交。</strong></p>
]]></content:encoded>
      <comments>https://yun.wztlink1013.com/blog/2020/06/28/useless-social-work/#comments</comments>
    </item>
    
    <item>
      <title><![CDATA[为什么无法突破到下一个层级？]]></title>
      <link>https://yun.wztlink1013.com/blog/2020/06/18/why-promotion-is-a-difficult-thing/</link>
      <guid>https://yun.wztlink1013.com/blog/2020/06/18/why-promotion-is-a-difficult-thing/</guid>
      <pubDate>Thu Jun 18 2020 22:50:00 GMT+0800 (GMT+08:00)</pubDate>
      <description>
      <![CDATA[小胡子哥的个人网站]]>
      
      </description>
      <content:encoded><![CDATA[<p>在阿里工作了五六年，见过很多优秀的工程师和合作伙伴，同时也看到了不少同学因为无法突破到下一个层级，而选择了放弃，或者泄气。</p>
<p>很多事情看起来是特别清晰的，一步、两步、三步，把这几个步骤走完了，事情也就结束了；与其说清晰，还不如说简单吧，特别是业务性的工作，真的是一眼可以望到尽头。我们必须承认，工作很多时候是需要用点蛮力的，你拥有再多的技能，在受限的环境下，也难以施展开来。**所谓的脏活、苦活、累活，你不想去做，但是也得去做，因为那是成就你的一部分内容，可能你的运气好一点，这种活有人替你扛下来了。</p>
<p>如何在看似恶劣的环境中存活下来，然后逐步拔高呢？下面我列举了几个常规性问题和操作，以促进思考：</p>
<p><strong>1、思考不足</strong></p>
<p>在工作中的执行属性过强，对问题缺乏深度的思考，简单点说，就是问「为什么」问的太少了，在问题过来的时候，我们必须搞清楚为什么背后的为什么，打破砂锅问到底。写作是一个很好的弥补措施，thinking in writing，写的过程就会促使自己去整理和思考。</p>
<p><strong>2、视野不够</strong></p>
<p>只能看到自己的问题，只能看到当下的问题，缺乏横向和纵向的比较。遇到问题，多看看别人是怎么处理的，想一想自己做的东西别人可以如何利用，既要走出去又要领进来。</p>
<p><strong>3、底蕴不强</strong></p>
<p>解决的大多数问题都是简单问题，挥一挥手打个补丁就结束了，很少去思考共性问题，缺乏服务意识和产品化能力。这一点并不难突破，在多思考和总结的基础上，多一些耐心，咬定青山不放松，在难啃的骨头上多啃几下，很多事情就可以拨开云雾见青天了。</p>
<hr>
<p><strong>上限和下限</strong></p>
<p>最近看到一个不错的观点，说<strong>努力决定你的下限，而选择决定了你的上限</strong>，我觉得说的有一定的道理。</p>
<p>作为一个技术人，扎实的基础和丰富的经验是行业立命之本，在这一块是绝对虚不得的，必须花费大把的努力，让自己的根基更加夯实。</p>
<p>而选择，伴随了太多的不确定性，运气显得有点重要，但是我想说的是，<strong>尽可能地提升自己，让自己成为别人的首选项，才能给自己争取更多的议价能力</strong>，坑有的时候就那么几个，争取让自己成为萝卜。</p>
]]></content:encoded>
      <comments>https://yun.wztlink1013.com/blog/2020/06/18/why-promotion-is-a-difficult-thing/#comments</comments>
    </item>
    
    <item>
      <title><![CDATA[心理契约的打破过程]]></title>
      <link>https://yun.wztlink1013.com/blog/2020/06/17/break-contract/</link>
      <guid>https://yun.wztlink1013.com/blog/2020/06/17/break-contract/</guid>
      <pubDate>Wed Jun 17 2020 22:48:00 GMT+0800 (GMT+08:00)</pubDate>
      <description>
      <![CDATA[小胡子哥的个人网站]]>
      
      </description>
      <content:encoded><![CDATA[<p>契约说的简单一点，就是双方对责任和义务的一个纸面陈述，你付出什么内容，帮助对方达成某种期望的同时，也对你有所回报。而这里要说的心理契约，它是不会落到纸面上的，比如口头的一个承诺，或者对某件事情双方都会满意的一个心理预期，你需要为这个承诺和心理预期付出努力。</p>
<p>心理契约经常出现在工作之中，举个例子，你的能力比较突出，超过了周边人的平均水平，那么老板对你的心理预期就会略高一些，如果你最后拿到的结果跟其他人差不多，你就没有达成这种心理契约，事实上，你和老板最终都能比较明确地感知出来。</p>
<p>在组织行为学里，对心理契约有一个比较标准的定义：<strong>任何时刻都存在于个体与组织之间的一系列没有明文规定的期望。</strong>那么通常我们是如何打破心理契约的呢？</p>
<p><strong>1、理解不一致</strong></p>
<p>你以为自己很厉害，但是老板觉得你不行；老板以为你很厉害，但是你自己觉得不行。或者老板觉得你想拿到 A+，但是你目标只是 B+。</p>
<p>一旦出现理解不一致，那么最后的结果，一定是让人不满意的。实际上，这是对目标定义的问题，我们需要把心理契约一部分显式落地在纸面上，让双方都清楚彼此的底线和预期。</p>
<p><strong>2、未及时响应变化</strong></p>
<p>随着时间的变化，每个人的中、短期目标也在发生调整，对一件事情的预期自然也是在变化的，如果双方没有对焦过程，很容易就会出现理解偏差。</p>
<p>最常见的一种情况是，当你在工作中有明显成长的时候，组织对你的要求也会趋向于提高到你几乎不能胜任的状态，说的简单一点，组织对你的要求提高了，如果你仍然保持当初对自己的要求，那么很快，你就会陷入无力兑现承诺的状态。</p>
<p>其实这个时候，需要学会抛出问题，也抛出自己的真实想法。双方都进行心理契约的微调，或者巩固。</p>
<p><strong>3、契约对象改变</strong></p>
<p>当你和另一个组织有了心理契约以后，大概率你会主动违背当前的契约，这种情况一般是难以挽救的，契约人会逐步弱化这种契约关系，慢慢的，放弃。</p>
<hr>
<p>很多时候，心理契约比落在纸面上的合同要有效的多，因为它包含了一种隐性的默契，大家没有敞开了说透，但是心里都跟明镜似的。与人建立这种契约关系，并且不断的调整契约内容，是可以很好的帮助人和组织之间相处得更加融洽的。</p>
<p><strong>与自己的心理契约</strong></p>
<p>另外，我想说的一点是，跟自己的心理契约。</p>
<p>这是一种为了达成某种期望，在心底与自己建立的隐性条约，需要非常强大的自律精神才能兑现。因为这种隐藏在心里，只有自己知道的内容，是很容易因为主客观环境的改变而立刻被改变的。除了自律以外，内心还需要有执念，或者说信念吧。</p>
<p><strong>能够跟自己建立心理契约的人，都是内心强大的人。</strong></p>
]]></content:encoded>
      <comments>https://yun.wztlink1013.com/blog/2020/06/17/break-contract/#comments</comments>
    </item>
    
    <item>
      <title><![CDATA[用未来的视角来看今天]]></title>
      <link>https://yun.wztlink1013.com/blog/2020/06/16/look-from-future/</link>
      <guid>https://yun.wztlink1013.com/blog/2020/06/16/look-from-future/</guid>
      <pubDate>Tue Jun 16 2020 22:46:00 GMT+0800 (GMT+08:00)</pubDate>
      <description>
      <![CDATA[小胡子哥的个人网站]]>
      
      </description>
      <content:encoded><![CDATA[<p>无数次听到有人说“迷茫”了，我自己也是如此，太多次感觉到不知所措，似乎前路总是罩着一层面纱，让人捉摸不透。</p>
<p>渐渐地，我想明白了，目光还是瞄得太近。<strong>想想五年后的自己会是什么样，再看看现在自己做的事情，或许会有更多的想法。</strong>当我们用未来的视角来看待今天的自己时，很多问题都会暴露出来。</p>
<p><strong>1、 今天正在忍受很多委屈？</strong></p>
<p>想一想过去五年自己的变化，再想一想未来五年你可能的变化，今天的这点委屈算什么？不过是一粒尘埃飘进了眼里，揉一揉也就干净了。那些动不动就跳楼自杀的人，我只想问一句，你能不能等到明天再跳，后天行不行呢？<strong>等一等，事情就会有转机。</strong></p>
<p><strong>2、今天的自己在哪里？</strong></p>
<p>想一想未来的自己想去到哪里，能走到哪里，再看看自己站在什么位置，大抵就明白了，现在的自己还缺少太多的属性，还无法匹配所畅想的未来的那个位置。这个时候也可以多问问自己，现在的路走偏了么？我是不是掉到坑里了，这个坑是需要被填平还是尽早弃坑？<strong>对待自己的成长，我们需要有一点功利主义。</strong></p>
<p><strong>3、未来的路该怎么走？</strong></p>
<p>每天都需要面临一大堆的选择，午餐到底是吃麻辣火锅还是重庆小面，手上的 offer 要不要接，出门应该穿裙子还是短裤，到底是去海南度假还是爬武当山，等等，大大小小的选择，选择一个也就等于放弃了另外一个，在诸多的选择中，我们有了自己的选择公式，我们懂得了断舍离，懂得了把复杂的人生搞的简单，懂得了**未来的路其实就是不断的做减法，让杂音更少，让自己的精力更加聚焦。</p>
<hr>
<p>说几句题外话。</p>
<p>有人问，不同层级的人的区别是什么，我觉得高年级的同学，总是能比低年级的同学看得高、看得远、看得深。</p>
<p>为什么会出现这样的差异，我觉得有两点，一是实战经验，二是不断学习。优秀的人往往会有更多的机会获得更优质的资源，进步自然也会更快，而进步快则会变得更加优秀，知道更多别人不知道的道理和心得。</p>
<p>大家最初都站在同一个起跑线上，有的人刚开始很卖力走到了前头，得到了更好的资源，于是就有了更多一帆风顺、平步青云的可能性。</p>
<p><strong>其实，任何时候开始努力都不算晚，你总有机会在某个方向走在大多数人前列。</strong></p>
]]></content:encoded>
      <comments>https://yun.wztlink1013.com/blog/2020/06/16/look-from-future/#comments</comments>
    </item>
    
    <item>
      <title><![CDATA[一篇写给从未编程过的人的入门教程]]></title>
      <link>https://yun.wztlink1013.com/blog/2020/06/05/programming-course-for-newbee/</link>
      <guid>https://yun.wztlink1013.com/blog/2020/06/05/programming-course-for-newbee/</guid>
      <pubDate>Fri Jun 05 2020 22:44:00 GMT+0800 (GMT+08:00)</pubDate>
      <description>
      <![CDATA[小胡子哥的个人网站]]>
      
      </description>
      <content:encoded><![CDATA[<p>昨天我分享了一篇<a href="https://www.yuque.com/barretlee/yuque/aabh67" target="_blank" rel="noopener">如何使用 PlantUML 这门简单的语言来绘制复杂</a>的活动图、流程图和组件图等，有的同学看到了以后，询问我，“外行需要多长时间才能学会这玩意儿呀？”，这个问题不知道该如何回答，因为我并不认同“外行”这个词。我始终认为，<strong>在编程这件事情上，每个人都是内行，每个人也都是外行</strong>。事实上，从不了解 PlantUML 到能够参考文档绘制出复杂的流程图，我也就学了一个上午，边学习、边实践、边分享，于是就会了。</p>
<p>学会编程没有你想象中的那么复杂。</p>
<h3 id="编程是什么？"><a href="#编程是什么？" class="headerlink" title="编程是什么？"></a>编程是什么？</h3><p>编程，说的简单一点，就是通过一系列逻辑将你想做的事情或者想描述的物体表达清楚，然后让它展现出来，或者运动起来。说的专业一点：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">编程 = 算法 + 数据结构</span><br></pre></td></tr></table></figure>
<p><strong>什么是算法？就是解决问题的办法，或者说通过几个步骤来解决一个问题的过程描述</strong>；那么什么是数据结构呢？咱们在解决问题的时候经常需要去放置一些物件，比如把书放到书架上，那么书架就是一种数据结构，把书放到柜子里，柜子就是一种数据结构，书架和柜子就是数据的不同呈现/储存方式。</p>
<p>其实，每个人对编程都不陌生，你进过厨房吧，17:00 回到家，怎么让家人在 18:30 之前吃上饭？这里头的算法就多了去了，你可以先煮上饭然后去买菜，也可以买完菜再回来煮饭，那么哪种方式更好呢？下面我们用程序语言来分析这道题：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">编程问题： <span class="number">17</span>:<span class="number">00</span> 回到家，怎么让家人在 <span class="number">18</span>:<span class="number">30</span> 之前吃上饭？</span><br><span class="line">算法一：先煮上饭然后去买菜</span><br><span class="line">算法二：买完菜再回来煮饭</span><br></pre></td></tr></table></figure>
<p>这里的做饭是一个程序实体，它包含了煮饭、买菜、切菜、做菜，这个程序实体的表达方式是：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">做饭 = &#123;</span><br><span class="line">  煮饭() &#123;&#125;,</span><br><span class="line">  买菜() &#123;&#125;,</span><br><span class="line">  切菜() &#123;&#125;,</span><br><span class="line">  做菜() &#123;&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>把中文换成英文不就是你平时看到的程序代码么？所以说呀，编程对你其实并不陌生，它也没你想象中的那么复杂。</p>
<h3 id="编程的核心是什么？"><a href="#编程的核心是什么？" class="headerlink" title="编程的核心是什么？"></a>编程的核心是什么？</h3><p>为什么人跟人之间编写出来的代码有这么大的差异，或者说，为什么存在小白和专家的区别？编程确实不复杂，复杂的原因是很多人不能把问题思考周全，我举个例子你就知道了：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">做饭 = &#123;</span><br><span class="line">  开始() &#123;</span><br><span class="line">    煮饭(); 买菜(); 切菜(); 做菜();</span><br><span class="line">  &#125;,</span><br><span class="line">  煮饭() &#123;&#125;,</span><br><span class="line">  买菜() &#123;&#125;,</span><br><span class="line">  切菜() &#123;&#125;,</span><br><span class="line">  做菜() &#123;</span><br><span class="line">    <span class="keyword">if</span> (家里没有油了) &#123; 买油(); 炒菜(); &#125; </span><br><span class="line">    <span class="keyword">else</span> &#123; 炒菜(); &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">做饭-&gt;开始();</span><br></pre></td></tr></table></figure>
<p>我们定义了一个程序实体叫做「做饭」，包含了几个步骤，开始、煮饭、买菜、切菜和做菜，在编程语言里头，我们把「做饭」称之为对象，这几个步骤称之为方法，「做饭」这个对象拥有 5 个方法，我们可以一个个地调用它。首先我们调用了「开始」方法，在这个方法里，又依次调用了「煮饭」、「买菜」、「切菜」和「做菜」。</p>
<p>在「做菜」方法里，我们看到了一个细节，那就是“家里没油了”，咋整，这个人是这么考虑的：先去「买油」，然后回来「炒菜」。很显然，这人不靠谱，你看，菜都要下锅了，才想起没有油。但是下面这个人就不一样了：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">做饭 = &#123;</span><br><span class="line">  开始() &#123;</span><br><span class="line">    煮饭(); </span><br><span class="line">    检查结果 = 检查();</span><br><span class="line">    买菜(检查结果); 切菜(); 做菜();</span><br><span class="line">  &#125;,</span><br><span class="line">  检查() &#123;</span><br><span class="line">    <span class="keyword">if</span> (家里没有油了) &#123; 买菜的时候要买油  &#125; </span><br><span class="line">    <span class="keyword">if</span> (家里没有辣椒了) &#123; 买菜的时候要买辣椒  &#125; </span><br><span class="line">  &#125;,</span><br><span class="line">  煮饭() &#123;&#125;,</span><br><span class="line">  买菜() &#123;&#125;,</span><br><span class="line">  切菜() &#123;&#125;,</span><br><span class="line">  做菜() &#123;&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">做饭-&gt;开始();</span><br></pre></td></tr></table></figure>
<p>他的程序里多了个步骤叫做「检查」，在出门买菜之前，先在家里扫一眼，缺了什么，用小本本记下来，然后「买菜」的时候，带上这个小本本，这样「买菜」就不会有遗漏了。</p>
<p><strong>你看，这就是我们所谓的小白和专家，他们的区别就是后者能够把事情想得更加周全，在解决问题的时候，不遗留任何细节，并且呢，能够让事情可以更流畅、更快、更好地得到解决，消耗的资源最少，解决的问题最多。</strong></p>
<h3 id="编程的复杂性"><a href="#编程的复杂性" class="headerlink" title="编程的复杂性"></a>编程的复杂性</h3><p>不要以为我上面写的东西不是代码，稍微调整下细节，这串代码是可以在电脑上真实跑起来的，是不是特别简单啊？你还敢说自己不懂编程么？还会惧怕编程么？</p>
<p>但是也不要把编程想的太简单了，上面的程序表达的只是一个十分粗略的做饭过程，或者说一个做饭的思路，真正要把做饭的程序实现出来，还要考虑很多的问题，比如如何在程序中表达我要做辣椒炒肉、红烧狮子头、剁椒鱼头等等好几个菜呢？这里就涉及到“抽象”的概念，我们需要把很多相似的步骤都抽象成一种行为，然后不断重复这种行为：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">做饭 = &#123;</span><br><span class="line">  开始(菜单) &#123;</span><br><span class="line">    煮饭();</span><br><span class="line">    买菜(菜单);</span><br><span class="line">    菜单-&gt;逐一(做菜);</span><br><span class="line">  &#125;,</span><br><span class="line">  买菜() &#123;&#125;,</span><br><span class="line">  煮饭() &#123;&#125;,</span><br><span class="line">  做菜(菜品) &#123;</span><br><span class="line">     洗菜(菜品);</span><br><span class="line">     切菜(菜品);</span><br><span class="line">     炒菜(菜品);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">菜单 = 辣椒炒肉、红烧狮子头、剁椒鱼头;</span><br><span class="line">做饭-&gt;开始(菜单);</span><br></pre></td></tr></table></figure>
<p>好了，上面的代码相信也不是很难理解，我们把做饭分为三个事情，「煮饭」、「买菜」和「做菜」，首先我们想好了一个“菜单”，然后抽象了一个「做菜」的方法，这个方法里面包含了「洗菜」、「切菜」和「炒菜」三个步骤，每一道菜都会执行这三个步骤。</p>
<p>如果没有这层抽象会有什么问题？你会发现你的代码是这么写的：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">做饭 = &#123;</span><br><span class="line">  煮饭() &#123;&#125;,</span><br><span class="line">  买菜() &#123;&#125;,</span><br><span class="line">  洗菜() &#123;&#125;,</span><br><span class="line">  切菜() &#123;&#125;,</span><br><span class="line">  做菜() &#123;&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">做饭-&gt;煮饭();</span><br><span class="line">做饭-&gt;买菜();</span><br><span class="line"></span><br><span class="line">做饭-&gt;洗菜(辣椒炒肉);</span><br><span class="line">做饭-&gt;切菜(辣椒炒肉);</span><br><span class="line">做饭-&gt;炒菜(辣椒炒肉);</span><br><span class="line"></span><br><span class="line">做饭-&gt;洗菜(红烧狮子头);</span><br><span class="line">做饭-&gt;切菜(红烧狮子头);</span><br><span class="line">做饭-&gt;炒菜(红烧狮子头);</span><br><span class="line"></span><br><span class="line">做饭-&gt;洗菜(剁椒鱼头);</span><br><span class="line">做饭-&gt;切菜(剁椒鱼头);</span><br><span class="line">做饭-&gt;炒菜(剁椒鱼头);</span><br></pre></td></tr></table></figure>
<p>代码本身没有什么问题，但是看起来会十分冗长，如果你今天要做 10 个菜，那么代码就得写 10 遍；可如果你用到了抽象思维，你就只需要去扩展“菜单”就行了，因为在程序里有一个叫做 「逐一」的逻辑。<br><strong>程序里面涉及到的逻辑并不多，诸如「条件判断」、「循环」、「遍历/逐一」等，很少，但是也就是这么几个少量的逻辑，构筑了丰富多彩的网络世界。</strong></p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>好了，本文并不是想教会你如何编程，而是想告诉你，编程是一件十分简单的事情，但是想写出好的程序却是一件无比有难度的事情，这需要你想出足够好的算法，同时也需要你对程序的执行环境有基本的了解，知道怎么写程序跑的快、怎么写程序会很卡，等等。</p>
<p><strong>当然，作为程序员最苦恼的事情，并不是编程本身，而是需求的变化。</strong>比如当你做好了这顿饭，却发现家人在外面吃过了，此时的你就只能含着泪，一个人吃完这桌难以下咽的饭菜了。</p>
]]></content:encoded>
      <comments>https://yun.wztlink1013.com/blog/2020/06/05/programming-course-for-newbee/#comments</comments>
    </item>
    
    <item>
      <title><![CDATA[聊聊《三国志·战略版》]]></title>
      <link>https://yun.wztlink1013.com/blog/2020/05/13/sanguozhi-game/</link>
      <guid>https://yun.wztlink1013.com/blog/2020/05/13/sanguozhi-game/</guid>
      <pubDate>Wed May 13 2020 14:07:00 GMT+0800 (GMT+08:00)</pubDate>
      <description>
      <![CDATA[三国志·战略版这款游戏玩了大概两个月，基本上体验了游戏的各个细节，本来以为自己只是一个小氪玩家，没想到玩到最后也累积成了中大氪😅。在收手之前，分享下自己玩这款游戏的一点心得，也算是对这两个月做一点小结。]]>
      
      </description>
      <content:encoded><![CDATA[<p>三国志·战略版这款游戏玩了大概两个月，基本上体验了游戏的各个细节，本来以为自己只是一个小氪玩家，没想到玩到最后也累积成了中大氪😅。在收手之前，分享下自己玩这款游戏的一点心得，也算是对这两个月做一点小结。</p>
<h3 id="这是一款什么样的游戏？"><a href="#这是一款什么样的游戏？" class="headerlink" title="这是一款什么样的游戏？"></a>这是一款什么样的游戏？</h3><p>这款游戏有意思的地方就是复原了三国群雄争斗的真实情景，整个游戏版图由几个州拼合而成，州与州之前有关隘，州由多个郡组成，每个郡都会有几座等级不一样的城池，地图上四处都是木材、铁矿、石料、粮食、铜矿等可被占领的不同类型不同等级的资源地块，还有山川、河流等等不可占领和穿越的地块。</p>
<p>每个人进入游戏后都会有一座主城，主城内有很多可升级的设施，分为内政、军事和守备三部分，也有几支等级很低的作战队伍。你可以自己成立一个盟，附近的人会加入进来，也可以加入到别人成立的盟中，盟成员之间可以相互扶持，一起策划天下大事。</p>
<p><img src="http://www.barretlee.com/blogimgs/2020/05/13/sanguozhi-01.png" alt="游戏地图"></p>
<p>在这个游戏里，一切故事都因土地而起。并非所有的地块都可以直接占领，你只能占领与自己或盟友地块相连的地块，如果你出生的位置资源丰富，那么你就可以很快地打下很多资源，从而变得更强，否则你就需要向外发展，发展的过程中就免不了土地冲突，也免不了人和人之间的冲突、盟和盟之间的冲突，甚至后续国与国之间的冲突。</p>
<h3 id="游戏成长瓶颈"><a href="#游戏成长瓶颈" class="headerlink" title="游戏成长瓶颈"></a>游戏成长瓶颈</h3><p>这是一款烧脑的游戏，对个人而言烧脑，对盟里主事的人也烧脑。</p>
<p>地块等级分为 1 到 10 级，每个人可以建立一个分城，分城和主城都可以养 5 支队伍，每支队伍有一名主将和两名副将，每个将领自带一个战法技能，另外还有两个战法槽，用于附加其他技能，将领的等级是 1 到 50 级，技能的等级是 1 到 10 级，每个将领根据等级可以对应数量的兵。</p>
<p><img src="http://www.barretlee.com/blogimgs/2020/05/13/sanguozhi-02.png" alt="桃园队"></p>
<p>将领也分武将和政将，政将一般放在主城内从事政务，武将一般参与作战，每个将领有 6 个属性，分别是与战斗相关的武力、统率、智力、速度，和与政务相关的政治、魅力。将领分为橙将、紫将和其他质量更低的将领，一般好的将领每次等级提升，其属性增加值也更加可观。每种将领都有 5 中兵种适应性，橙色最强，紫色次之，其他颜色就表示比较弱了，战斗时，如果选择橙色兵种，会有战斗力加成，其他颜色可能会削弱。</p>
<p><img src="http://www.barretlee.com/blogimgs/2020/05/13/sanguozhi-03.png" alt="关羽"></p>
<p>游戏的成长瓶颈就相当多了，我列举一些：</p>
<ol>
<li>橙将难求，每天有一两次免费的抽卡，可以从成百上千将领中抽取卡片，脸黑情况抽 10 天也抽不到一个橙将，紫将也不好出</li>
<li>战法技能难求，一个武将自带一个技能，也可以销毁卡片兑换一个对应的固定技能（传承），没有好的卡片自然就没有好的技能</li>
<li>战法激活困难，就算你有用了了一个橙将的传承技能，也不能立马使用，还必须消耗 10 个甚至更多紫将来激活它</li>
<li>战法升级困难，战法升级需要战法点，抽到的低质量将领可以兑换成战法点，你需要抽到一箩筐将领才能兑换足够的战法点升级战法</li>
<li>第三战法槽开启困难，需要第一战法达到 20 级后，才能通过消耗两个橙将开启第三战法槽</li>
<li>武将等级提升困难，需要不停地战斗，才能获得经验，足够的经验才能让等级+1，越升越困难</li>
<li>武将搭配困难，考虑兵种、战法搭配，想配一支战斗力极强的队伍是非常有挑战的</li>
</ol>
<p>另外还有其他让人头大的限制：</p>
<p>每个武将都有一个「御」的属性值，初始队伍三个将领的御之和不能超过 13，而提升御则需要升级城池等级。城池等级的提升需要大量的资源，这就要求玩家通过占领地块来提升资源产量，而「占领」是需要战斗的，刚开始的队伍配置都很低，需要消耗大量的兵来打仗占领土地，而征兵也是需要资源的！</p>
<p>城池内还有几十个可以升级的设施，每个设施的升级都需要消耗大量资源，有的是让队伍更强的，有的是可以提升资源获取效率的，有的是可以提升城池守备的。</p>
<p><img src="http://www.barretlee.com/blogimgs/2020/05/13/sanguozhi-04.png" alt="内政"></p>
<p>所以这个游戏，就是逼着你，不断地去触碰游戏设定的「土地矛盾」，在你发育的过程中，很快就会接触到其他玩家，也会接触到「盟」，然后接触到国家（盟到达一定等级后可以立国）的发展大计，不断感受游戏的新乐趣。</p>
<h3 id="游戏公平性"><a href="#游戏公平性" class="headerlink" title="游戏公平性"></a>游戏公平性</h3><p>总体来说，这个游戏还是比较公平的，将领的获取有两个渠道，一个是抽卡，这是游戏唯一可以付费的地方，抽卡很贵，你砸一万块钱进去，脸黑的情况可能也就抽到二三十个橙将，运气好的话，可以抽到七八十个，平均一个橙将 200 块 RMB 的样子，当然，在付费抽卡的过程中，可以得到不少紫将，每天有一两次免费抽卡的机会；另外一个渠道就是铜币抽卡，铜矿打得越多每天的铜币产量也就越多，只不过铜币只能抽到紫将。</p>
<p><img src="http://www.barretlee.com/blogimgs/2020/05/13/sanguozhi-05.png" alt="满红大佬"></p>
<p>上面这张图，一看就会知道，一定是位氪金大佬，没个三、五万 RMB（甚至更多）拿不到这样的卡片，诸葛亮、赵云本就是很难抽到的将领，他这个诸葛亮还抽到了 6 个（每进阶一次会消耗一个，然后会多一个红点）。玩这个游戏，一毛不拔的应该特别少，所以你能够在网络上看到铺天盖地的广告，因为游戏方有这么多财神供着，根本不缺钱！！！</p>
<p>好的将领打仗厉害，消耗兵少，可以快速获得高级地，从而更快速度提升资源获取效率，这是一个循环的过程；同样，即便你的将领一般，如果你前期可以很快地打下一波资源地，也可以尝到资源复利的甜头。下面就来分享下，如何在游戏中让自己占到上风。</p>
<p>游戏的公平性还体现在战斗上，队伍有兵种属性，枪兵克制骑兵，弓兵克制枪兵，盾兵克制弓兵，骑兵克制盾兵，就算你手里有很好的橙将，一旦遇到克制的兵种，也会遭遇很大的损失，这也是平民玩家能够玩下去的一个重要游戏规则支柱。</p>
<h3 id="前期发展"><a href="#前期发展" class="headerlink" title="前期发展"></a>前期发展</h3><p>关于前期如何快速发展，网络上有很多很多的攻略，但是大多数攻略实在是不适合普通玩家，因为普通玩家没有好的将领，没有好的战法，组出来的队伍也都弱爆了，打地损失超级大。在这里主要是给大家一些建议和思路。</p>
<p>首先你需要明确，在游戏过程中，即便你是普通玩家，你手里头也会慢慢攒一些不错的橙将，橙将才你重点需要培育的对象，刚开始的次将升级升到二三十就差不多了，对于氪金玩家来说，建议前期一次性多氪一点，先砸个一两千把你想要的几个橙将砸出来，然后再开始玩游戏。一般氪金玩家，氪个一两千都是很正常的数目了，稍大一点的，应该上万了，大氪玩家七八万的也有，比较少。</p>
<p>如果你的出生地附近五级、六级资源地过少，建议直接东山再起，重新选择出生地，否则发育一两天后，你会非常痛苦，需要跑很远的路打地；如果发现身边有高战，也赶紧东山再起，因为附近的高级地会提前被他打光，他吃肉，你只能喝汤。</p>
<p>什么是前期？对你来说，在能够打下七级地之前，都可以称之为前期。很多人在六级地以后就发育十分缓慢了，因为手上的队伍实力太弱，每次战斗都是巨大的兵损。</p>
<p>前期打地，想发育快，就必须控制兵损，要以几乎不损兵的情况下打仗，比如打五级地兵损控制在一千，打六级地兵损控制在三千；当你能打六级地的时候，整个版图都已经发育到一定的阶段了，慢慢会进入资源不够用的情况，土地矛盾也会十分明显，这个时候就免不了跟人打架，或者被盟里要求一起去攻城拔寨，参与团战。</p>
<p><img src="/blogimgs/sanguozhi-06.png" alt="夏侯惇" width="300"></p>
<p>有一个小小的经验可以分享下，赵云和夏侯惇在战斗中是可以触发群攻的，如果你有这类似的将领，这个优势可以好好利用下，培养到 25 级可以单刷五级地，35级可以单刷六级地。战法配置策略也很简单，回血+洞察+群攻/反击，比如夏侯惇可以加鲁莽（A级战法）和后发制人（A级战法），赵云自带洞察，可以加急救（B级战法）和后发制人。</p>
<p>当夏侯惇或者赵云到了三四十级以后，就可以带将练级了，比如夏侯惇带一个副将，副将给一个兵，带着去打六级地，这样这个副将就可以飞速提升等级。</p>
<h3 id="关于战法配置"><a href="#关于战法配置" class="headerlink" title="关于战法配置"></a>关于战法配置</h3><p>这可能是游戏里最烧脑的部分，当你良将如云，战法一堆的时候，如何搭配一队战斗力强的队伍，是一件十分有挑战的事情。如果你是大氪玩家，根本不用多想，去网上搜寻一下 T1 梯队的配置，保证打架强悍。</p>
<p>但是你大概率是这样的，组件 T1 梯队，缺一个将或者缺某种战法，或者有些战法已经给了另外的队伍，当前的队伍配置只能更换思路。庆幸的是，这个游戏根本不存在最好的配置，因为总是可以找到一堆比较克制你的队伍，关键在于如何利用技能触发的概率，最大程度打出伤害，以及降低受到的伤害。</p>
<p>武将的战法大致可以分为：控制系、增益系和输出系，控制包含不让普通攻击（缴械）、不让发动战法技能（技穷）、不让输出（震慑）、不让行动（虚弱）、见人就打含自己人（混乱）等等，增益包含输出增强、受到伤害降低、回血、避免被控（洞察）等，输出包含多次输出、输出加成、群体攻击、多类输出等。</p>
<p>在配置的时候，尝试多个战法组合不断寻求最大化输出，如使用包含输出和增益的杯蛇鬼车战法，使用所向披靡这种群攻战法，或者利用某个将领的猛烈输出，如使用锋矢阵、藤甲、曹操的乱世奸雄辅助徐晃打出成吨高额伤害等等。</p>
<p><img src="http://www.barretlee.com/blogimgs/2020/05/13/sanguozhi-08.png" alt="曹操"></p>
<p>首先要去看一个将的特征，比如曹操，他的智力增长和统率增长都是很高的，可以考虑让他做肉盾，比如加一个嘲讽技能，让敌军的所有普通攻击都打在他身上，以保护我方另外两个将领拥有良好的输出环境，</p>
<p><img src="http://www.barretlee.com/blogimgs/2020/05/13/sanguozhi-09.png" alt="曹操技能"></p>
<p>曹操为主将则具备吸血能力，自动回血，如果为副将，就需要为他配置降低伤害或者回血的技能。</p>
<p><img src="http://www.barretlee.com/blogimgs/2020/05/13/sanguozhi-10.png" alt="夏侯渊"></p>
<p>再比如夏侯渊，武力成长性不错，适合输出，</p>
<p><img src="http://www.barretlee.com/blogimgs/2020/05/13/sanguozhi-11.png" alt="夏侯渊技能"></p>
<p>而且他的战法「将行其疾」，是在普通攻击后再发起一次攻击，如果打中了主将，还能控制对方，那么第二、三技能就应该强化他的属性，可以配置「强攻」、「兵锋」等，让他触发多次普通攻击（每个将领每回合有一次普通攻击）。</p>
<p>除了知道将领擅长什么，还是去思考他害怕什么，比如夏侯渊就害怕缴械（无法普通攻击），为了让他不要被缴械，可以让郭嘉为他提供洞察，也可以让夏侯渊的速度变得更快，让他比敌军更早发动技能，还可以在队伍中配置其他武将，一旦夏侯渊被缴械，还能保证队伍持续有伤害输出。</p>
<p>为什么那些 T1 队伍都很强，就是因为 T1 队伍使用的每个技能都具备 1~3 个效果，要么控制对方，要么群体输出，要么奶量很大（回血能力强），综合配置下来，就是一支抗揍、能打还不怕控制的队伍了。</p>
<h3 id="游戏的社交性"><a href="#游戏的社交性" class="headerlink" title="游戏的社交性"></a>游戏的社交性</h3><p>不得不说，这款游戏的社交性非常强，战争的胜败不仅仅取决于盟里有多少个高战，更重要的是，在一起打仗的人，出生入死久了，有了袍泽情谊，愿意一起去执行一项有挑战的任务，愿意守卫疆土，保家卫国。也会在持续的战报秀中，不断尝试和学习提升自己的战法技能、优化配置策略。</p>
<p>小到一个分队，大到一个国家，大家的畅聊声中，有炫耀、有吐槽、有郁闷、有开心、有满足、有失望、有惊喜；打仗的时候，盟里统一调令、统一指挥，也会有紧张感，一对精心培养的队伍到底能够穿几队，能不能打赢对方的高战，等等，时刻都能感受到血脉膨胀、心跳加速。</p>
<p>不同的盟，管理风格差异特别的，有的松散而不失整齐，有的朝令夕改意气用事。内奸、反叛、转匪、俘虏，各种操作和角色，都让人和人之间的交流变得频繁而有趣。</p>
<p>如果你有时间，也愿意花点小钱，不妨尝试玩一玩这款策略性游戏，能够带来不少趣味~</p>
]]></content:encoded>
      <comments>https://yun.wztlink1013.com/blog/2020/05/13/sanguozhi-game/#comments</comments>
    </item>
    
    <item>
      <title><![CDATA[浅谈价值表达]]></title>
      <link>https://yun.wztlink1013.com/blog/2019/12/17/the-value-of-expression/</link>
      <guid>https://yun.wztlink1013.com/blog/2019/12/17/the-value-of-expression/</guid>
      <pubDate>Tue Dec 17 2019 13:25:00 GMT+0800 (GMT+08:00)</pubDate>
      <description>
      <![CDATA[还记得刚踏入职场时，最大的困惑是不清楚未来的成长路径是怎样的，在职场上，我的未来是什么？未来的路该怎么走？业界的那些大牛，到底有多牛？我离他们有多远？对此完全没有概念。]]>
      
      </description>
      <content:encoded><![CDATA[<p>领英中国近期推出了一个年度行家的榜单，关注我的朋友可能知道，我有幸入了榜。领英对行家的定义是，在自己的领域中，根据自身经验和知识，为他人答疑解惑，分享行业洞察，提供经验干货。简单来说，所谓的行家，就是善于思考，乐于发声的人。</p>
<p>我想，领英不乏这样的人，整个互联网更是不乏这样的人，我之所以能够进入这个榜单，还是因为当前领英在中国仍在发育阶段，现阶段在这个平台上表达的人偏少，所以才显得我这个活跃的人是个“行家”吧。</p>
<p>本文想跟大家分享几件事情，分别是：</p>
<ul>
<li>我在进入职场时所面临的的困惑，以及我的心态是如何转变的</li>
<li>在社交媒体上进行“表达”，我的看法和经历</li>
<li>分享下“不善言辞”的技术人如何进行职场表达</li>
</ul>
<h3 id="一、走出困惑"><a href="#一、走出困惑" class="headerlink" title="一、走出困惑"></a>一、走出困惑</h3><p>还记得刚踏入职场时，最大的困惑是不清楚未来的成长路径是怎样的，在职场上，我的未来是什么？未来的路该怎么走？业界的那些大牛，到底有多牛？我离他们有多远？对此完全没有概念。</p>
<p>相信很多人起初跟我一样，都会有类似的困惑，事实上，这几年在社交平台上也经常会收了不少朋友的私信，询问这方面的问题。究其原因，我认为有如下几点：</p>
<ul>
<li><strong>[自身问题] 涉猎不足。</strong> 刚刚走进职场，工作经验不足，遇到的问题少，踩过的坑偏少，因此看不清领域全貌</li>
<li><strong>[自身问题] 缺少沟通。</strong> 与市场、业务、团队和社区的互动不足，甚至缺失，信息摄入渠道单一，对领域的综合理解不够，缺少对领域发展风向的判断</li>
<li><strong>[行业问题] 发展过快。</strong> 技术的迭代十分迅速，技术栈更替快，经常给人一种学不过来的感觉，给新人的压力大</li>
<li><strong>[行业问题] 成长梯度不清晰。</strong> 前端是一个新兴领域，出现时间不长，在行业的沉淀也比较薄，这不利于新人找准下一个层级的位置</li>
</ul>
<p>过去几年时间，我从未停止学习和思考，不断从技术底层去理解新事物的诞生，同时结合业务去思考技术的价值，持续地思考和输出，几年下来让我不断对行业和技术有了更深的理解。当我得到了公司和同行认可的时候，当初的很多困惑也就消失了，心态也跟着转变了。</p>
<p>市场的竞争是恶劣的，对人的要求也在不断地提升，这就要求我们必须不断地改变自己来适应新的环境。相比刚踏入职场，如今的我淡定了许多。<strong>很多有难度的事情会放到五年这个跨度来看，不急于求成，稳稳的去拿每个阶段的结果，控制好风险，这样下来，事情大概率就会按照自己的预期发展了。</strong></p>
<h3 id="二、从技术表达到职场表达"><a href="#二、从技术表达到职场表达" class="headerlink" title="二、从技术表达到职场表达"></a>二、从技术表达到职场表达</h3><p>我是一个技术人，从 13 年开始就拿起笔杆子在网络上写作，那个时候还属于个人博客比较流行的阶段。由于长期深入浅出地写前端领域的技术博文，吸引了不少围观的群众和志同道合的工程师，慢慢地，也在这个领域越走越远。后来个人博客不怎么流行了，应该说互联网信息泛滥了，长篇内容铺天盖地，传播周期也越来越短，再加上技术内容同质化比较严重，慢慢地，我在社交媒体上的表达就从长篇转向了短篇和中长篇，表达平台从个人博客转战到了微博，当然，分享的内容了也有了比较多的变化，更加侧重于资源的分享和观点的输出。</p>
<p><strong>时间</strong></p>
<p>有人问我，每天在社交媒体上花费多少时间？其实，<strong>表达不需要很多时间，表达背后的思考需要</strong>。我是一个乐于分享的人，在平时的工作和生活中看到问题，我都会去思考问题的本质是什么，然后把思考的内容梳理出来，发布到社交平台上。有些内容会引发较多的讨论，阅读评论和互动比较占用时间。</p>
<p><strong>坚持表达</strong></p>
<p>我粗略地统计了下，近五年产出了长篇博文（含技术研究）约 300 篇，中篇思考约 500 篇，短微博（含技术分享）约 5000 条。这几年，我一直逼着自己去思考，而且是逼着自己产出有见地的内容，长期下来，很明显地感觉到，思辨能力有了质的提升，写作、沟通能力也大幅提升了。顺道值得一提的是，同时还在全网收获了六七万的关注量。</p>
<p><strong>坚持有价值的表达</strong></p>
<p>什么样的表达是有价值的？我认为，能够给我带来价值的分享，有两类，<strong>一类是消除知识势差</strong>，对工作和思考有帮助的知识，辨识度很高，我会关注一些能够持续产出有高性价比知识的博主，所谓高性价比，就是他们分享的内容可以被直接应用到我的工作上，或者对我认识某个领域起到很大的作用；<strong>另一类是消除认知偏差</strong>，能够站在一个较高的维度或者较宽的视野下，从宏观角度解释现象，而且还会凝练一些方法论，这种内容往往可以引发二次思考，很有价值。</p>
<p>个人在分享的时候，也会尽量表达这两类内容，而不是做纯粹的知识搬运工。</p>
<p><strong>表达后的信息反馈</strong></p>
<p>在输出的过程中，也会经常收到有价值的反馈，从而让我更进一步地思考；在思考的过程中，我会阅读大量的素材以提高思考的深度和广度，也认识了一帮志同道合的朋友。</p>
<p>就拿前几天的事儿来说吧，我在 LinkedIn 发了一个观点，讨论“为什么 PWA 技术在国内不愠不火”，有一位在国外有过调研和实践的网友回复了他掌握到的讯息，让我知道了这个技术为什么在某些国家可以火起来，以及如何在这类国家火起来，很有启发性。</p>
<p>事实上，像这样，在社交平台上因为表达而让自己觉得有进步的故事还挺多的。</p>
<p><strong>职场表达</strong></p>
<p>LinkedIn，我在上头活跃了一年，在这里表达让我认识了一帮前端领域圈子之外的朋友，应该算是意外的收获吧。</p>
<p>起初我只是把它当做一个职场表达的自留地，吐槽吐槽一些显得不够专业的猎头，喷一喷在厂里看到的不好的现象，也偶尔分析一些问题背后的本质，没想过有人会看我写的东西，不过坚持一年后，发现关注我的人越来越多，慢慢的，也就聊的多了。</p>
<p>我觉得领英是一个比较好的职场表达空间，只要是有价值或有见解的观点，很容易被同行和相关行业的人注意到，而且有深度的互动也可以促进和提升自己对于行业的理解，这很有价值。</p>
<h3 id="三、技术人表达"><a href="#三、技术人表达" class="headerlink" title="三、技术人表达"></a>三、技术人表达</h3><p>行外人对程序员的第一印象可能是，“不善言语、Geek、修电脑”，这不是没有道理的。程序员善于通过程序来表达想法，他们追求简单、高效和极致，可能因为长期理性表达的缘故，技术上的输出很有力道，但职场上的表达就显得比较脆弱了。</p>
<p>如何缓解这个问题？我觉得可以多在网络上与不同的人交流，也多在现实生活中与不同的人交流，保持开放的心态。同时，在持续表达和交流的过程中，建立稳定的输出渠道，打造自己的受众基础，不断收集外部对自己的有效反馈，形成一个健康稳定的正向循环。</p>
<p>交流是一门艺术，不同的人口味不一样，风格也不一样，对于沟通，有几点建议：</p>
<ul>
<li><strong>简洁且全面地表达。</strong> 日常的沟通过程中，使用凝练的内容表达自己的想法，让人可以最短时间内了解意图</li>
<li><strong>交流而非索取。</strong> 信息势差是存在的，使用交流的方式相互分享和探讨，而不是为了降低信息势差一味地索取信息</li>
<li><strong>多交流观点。</strong> 上等讨论是交流观点，中等讨论是谈论事件，低等讨论是评判个人</li>
</ul>
<h3 id="四、小结"><a href="#四、小结" class="headerlink" title="四、小结"></a>四、小结</h3><p><strong>表达不是目的，价值表达才是目的。</strong> 在这个信息已经开始泛滥的互联网之中，我们可以输出更多有价值、有深度的内容，因为我们所在的平台、所在的环境，会因为我们这些微小的改变而变得更加美好。</p>
]]></content:encoded>
      <comments>https://yun.wztlink1013.com/blog/2019/12/17/the-value-of-expression/#comments</comments>
    </item>
    
    <item>
      <title><![CDATA[Coding 五年，我在阿里“啃”了块硬骨头]]></title>
      <link>https://yun.wztlink1013.com/blog/2019/11/30/life-and-work-in-alibaba/</link>
      <guid>https://yun.wztlink1013.com/blog/2019/11/30/life-and-work-in-alibaba/</guid>
      <pubDate>Sat Nov 30 2019 13:25:00 GMT+0800 (GMT+08:00)</pubDate>
      <description>
      <![CDATA[在阿里的日子过得太快，转瞬间已在指尖和键盘的 Coding 声中溜走了五年，这五年，我从青涩的小伙转身成为一个女娃娃的爹，也从略带内向的毕业生进化成了既能码又能撕的“胡子大叔”。]]>
      
      </description>
      <content:encoded><![CDATA[<p>大家好，我叫李靖，来自淘系技术部，是一名前端工程师。</p>
<p>在阿里的日子过得太快，转瞬间已在指尖和键盘的 Coding 声中溜走了五年，这五年，我从青涩的小伙转身成为一个女娃娃的爹，也从略带内向的毕业生进化成了既能码又能撕的“胡子大叔”。</p>
<h3 id="人可以累，心不能累"><a href="#人可以累，心不能累" class="headerlink" title="人可以累，心不能累"></a>人可以累，心不能累</h3><p>刚入职时，作为一名技术新人，负责 PC 版的淘宝首页，这块业务很特殊，它的受众很多，每天都有上亿的流量，系统的复杂度虽不是很高，但是风险特别大，而且需要与很多很多很多人交涉，我接手之时业务发生了一些变化，作业量很大，压力也很大，有来自业务方的压力，也有技术上的挑战，那段时间，连续一两个月，加班到晚上 1 点左右回家，而且 1 点以后还有可能收到业务方的电话。</p>
<p>有一天晚上，大概 11 点钟，整层楼只剩下我和我的主管，在优化一个技术细节问题，他其实已经陪我快一个星期了。多日的疲惫感让我一下子爆发了出来，那天晚上，我哽咽了，哭了，最后泣不成声，主管在旁边，他话不多，等我哭的差不多的时候，他告诉我，“成长是很累，但是人可以累，心不能累”。</p>
<p>这几年，我一直记着这段往事，也把那句话深深地刻在了心里。从那以后，不管是工作，还是生活，我都会尽量保持良好的心态，每每感觉心累的时候，都会想办法调节自己。</p>
<p>当工作和生活交织在一起的时候，也很容易把生活中的情绪带到工作上来，心中的不如意会像病毒一样占据大脑，压垮我们的心理防线。学会站得远一点来看待眼前，其实一切都会消逝，生活和工作都不会因为一点小事而变得黯淡无光，远方的路还很长。</p>
<h3 id="你相信吗？"><a href="#你相信吗？" class="headerlink" title="你相信吗？"></a>你相信吗？</h3><p>看不清前路的时候，鞭策自己的就是“相信”二字。</p>
<p>依稀记得刚来阿里的一两年，前头总有个师兄领着，完全不用担心迷路的事情，可不知道从什么时候开始，师兄好像成为了一团烟雾，弥散在了眼前，这才意识到，前方的路，需要自己去走。需要思考的问题越来越多，能得到的输入越来越少，我已经数不清自己有多少回看不清前路了，但每每看到一丝希望，都会紧紧地抓住，走下去。</p>
<p>做店铺业务的那年，我们团队人少事多，我负责的是 ISV 开放相关的技术支撑，旧的技术体系要过渡，新的方向要探索。在做规划的那段时间，我连闭上眼睛都能看到一堆让人头疼的问题在脑子里转来转去，后来我们决定把开发者的体验做上去，选择了一个非常难啃的技术领域——IDE 编辑器。当初我的内心是拒绝的，我认为自己搞不定，可实在也没有太多的路可以选择。</p>
<p>转岗吧，但回头一想，如果这块骨头不啃碎，ISV 技术支撑的体验很难有质的突破，团队的压力也会更大；另外再想一想，其实“好做”的事情都已经做得差不多了，大家都进入了深水区，没有那么多好啃的骨头。几个深呼吸以后，我决定，提起勇气，扎扎实实地干它一场。</p>
<p>那半年，时而痛苦，时而兴奋。庆幸的是，如期地帮助 ISV 解决了一些实际场景的问题。</p>
<p>当然，相信也是有条件的，当我把事情列清楚了，我多了一份相信；当我做出了一点点效果，又多了一份相信；当我得到了兄弟团队的关注和寻求合作的意向，我知道，当初的坚守是对的。大胆思考，小心求证，稳步向前地相信，前路才会越来越清晰。</p>
<h3 id="赋予工作多一点意义"><a href="#赋予工作多一点意义" class="headerlink" title="赋予工作多一点意义"></a>赋予工作多一点意义</h3><p>一线的研发工作，并不是每时每刻都充满着趣味和挑战，可以说日常的大部分时间都在处理琐碎的看似不起眼的脏活、苦活、累活。思维没打开，就好像囚禁在笼子里，看不清上下游关系，也看不到做这件事情的价值和意义。</p>
<p>工作的意义从来都不是别人赋予的，而是自我赋予。内心被人说服了，所以去做；看到了问题，所以去做；经历过痛苦产生了共情，所以去做。每一行代码、每一次优化、每一个变更，都期望能够让我们的用户更爽一点，用户爽了，我们的心里也就爽了。</p>
<p>近期的工作是解决前端工程相关的研发体验和效率问题，几乎每天都会听到来自不同 bu 的研发同学的声音，听到了他们的抱怨，也听到了他们的赞许，很多心声他们并不会全部吐露出来，但顺着反馈去看看是什么让他们爱不释手，是什么让他们痛不欲生，进而做出一些改变，这或许就是我给工作赋予的更多意义；而不是像不是一颗螺丝钉般，成天机械地解决来自用户、主管、合作伙伴提过来的各种需求。</p>
<p>世界没有太多的变化，但是用不一样的眼光去看待这个世界，可能会大大的不一样。</p>
<h3 id="五年，五味杂陈"><a href="#五年，五味杂陈" class="headerlink" title="五年，五味杂陈"></a>五年，五味杂陈</h3><p>在我们的人生中，有好多个五年，不长也不短。在这里，我度过了工作后的第一个五年，内容很丰富，这也让我意识到，未来需要以更长的跨度来规划阶段性的人生。</p>
<p>感谢这五年，感谢身边的人，也感谢阿里巴巴，让我受益良多~</p>
]]></content:encoded>
      <comments>https://yun.wztlink1013.com/blog/2019/11/30/life-and-work-in-alibaba/#comments</comments>
    </item>
    
    <item>
      <title><![CDATA[解密 VS Code 断点调试的原理]]></title>
      <link>https://yun.wztlink1013.com/blog/2019/11/15/vscode-study-03-debug-protocol/</link>
      <guid>https://yun.wztlink1013.com/blog/2019/11/15/vscode-study-03-debug-protocol/</guid>
      <pubDate>Fri Nov 15 2019 13:25:00 GMT+0800 (GMT+08:00)</pubDate>
      <description>
      <![CDATA[小胡子哥的个人网站]]>
      
      </description>
      <content:encoded><![CDATA[<p>VS Code 相关系列的文章，近段时间已经写过三篇（<a href="https://www.barretlee.com/blog/2019/08/03/vscode-source-code-reading-notes/" target="_blank" rel="noopener">启动过程</a>，<a href="https://www.barretlee.com/blog/2019/10/23/vscode-study-01-start/" target="_blank" rel="noopener">安装</a>，<a href="https://www.barretlee.com/blog/2019/11/01/vscode-study-02-debugging/" target="_blank" rel="noopener">开发和调试</a>）了，后续还会在研究和学习的过程中持续输出，希望对感兴趣的读者带来一些帮助。</p>
<blockquote>
<p>我的文章风格一般都是持续挖掘底层原理，打破砂锅问到底，一直挖掘到大众能都理解的深度才会罢休，所以在做介绍的时候偶尔会跑个题讲讲其他相关的技术，主要也是为了给读者理解做好铺垫。</p>
</blockquote>
<p>平时我们经常会使用 Chrome 进行 JS 的断点调试，你是否有去思考过，为什么我打下一个断点，程序就会停下来，为什么在 VS Code 上不需要 Chrome Devtool 也能够断点，它背后是如何实现的？这就是文本要带你搞懂的东西。</p>
<h3 id="Node-js-的调试"><a href="#Node-js-的调试" class="headerlink" title="Node.js 的调试"></a>Node.js 的调试</h3><p>VS Code 上可以调试很多语言，安装对应的调试包即可，本文以 Node.js 为例，读者可以依葫芦画瓢，尝试下其他语言的调试，原理搞明白了，剩下的很多都是体力活。</p>
<p>首先，我们来看一看 Node.js 是如何被调试的，事实上本博客已经介绍过好多次了，这一次再更深入地探讨一下。</p>
<h4 id="连接-Node-js-的-Debugger"><a href="#连接-Node-js-的-Debugger" class="headerlink" title="连接 Node.js 的 Debugger"></a>连接 Node.js 的 Debugger</h4><p>在 6.3 版本以前的 Node.js，调试工具是比较单一的，社区比较活跃的调试工具叫 <code>node-inspector</code>，这玩意儿是个什么原理呢，为啥可以实现调试，我们可以通过几行简单的代码实现一个功能单一的 <code>node-inspector</code>，如下方是待调试的代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// file: test.js</span></span><br><span class="line"><span class="keyword">let</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> server = http.createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  res.write(<span class="string">'hello\n'</span>);</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">debugger</span>;</span><br><span class="line">    res.end(<span class="string">'world'</span>);</span><br><span class="line">  &#125;, <span class="number">0</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.listen(<span class="number">8888</span>, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'start server'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>通过 <code>node --debug test.js</code> 启动程序，我们启动了一个 8888 端口的 HTTP Server。</p>
<blockquote>
<p>此处请通过 nvm 将 node 的版本号切换到 6.3 以下，如 <code>v6.2.2</code> 这个版本，后面会讲旧版 Node 和 v6.3+ 版本 Node 的区别。</p>
</blockquote>
<p>然后通过如下方式发起请求：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜ curl 127.0.0.1:8888</span><br></pre></td></tr></table></figure>
<p>你会看到命令行只输出了 <code>hello\n</code>，然后就进入了 pending 状态，我们来分步理解下，为啥会这样：</p>
<ul>
<li>通过 <code>--debug</code> 参数启动 Node.js，程序会开启一个内置的 <code>Debugger</code> 模块</li>
<li>由于我们没有指定参数，<code>--debug=PORT</code>，默认使用的是 5858 端口，此时的 <code>Debugger</code> 模块会监听 5858 端口</li>
<li>在发起请求的时候，遇到 <code>debugger</code> 关键词，程序会暂停执行，直到收到“继续到下一步”的指令</li>
</ul>
<blockquote>
<p>Demo 的源码地址：<a href="https://github.com/barretlee/node-legacy-debug" target="_blank" rel="noopener">barretlee/node-legacy-debug</a></p>
</blockquote>
<p>我们可以编写一个程序看看 <code>Debugger</code> 模块具体干了什么：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// File: debugClient.js</span></span><br><span class="line"><span class="keyword">const</span> net = <span class="built_in">require</span>(<span class="string">'net'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> socket = net.createConnection(<span class="number">5858</span>, <span class="string">'127.0.0.1'</span>);</span><br><span class="line">socket.on(<span class="string">'data'</span>, (data) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data.toString())</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">process.stdin.on(<span class="string">'data'</span>, (data) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> json = data.toString();</span><br><span class="line">  <span class="keyword">const</span> msg = <span class="string">`Content-Length: <span class="subst">$&#123;Buffer.byteLength(json, <span class="string">'utf8'</span>)&#125;</span>\r\n\r\n<span class="subst">$&#123;json&#125;</span>`</span>;</span><br><span class="line">  socket.write(msg, <span class="string">'utf8'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>我们通过 <code>Net</code> 模块连接到刚才程序在 5858 端口开启的监听，刚连接上的时候，它会打印如下信息：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">Type:</span> <span class="string">connect</span></span><br><span class="line"><span class="attr">V8-Version:</span> <span class="number">5.0</span><span class="number">.71</span><span class="number">.52</span></span><br><span class="line"><span class="attr">Protocol-Version:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">Embedding-Host:</span> <span class="string">node</span> <span class="string">v6.2.2</span></span><br><span class="line"><span class="attr">Content-Length:</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>意思是告诉你，你尝试与 Debugger 模块连接，已经连接成功了，当前 debug 的程序所使用的 V8 版本号是 <code>5.0.71.52</code>，使用的协议版本是 <code>1</code>，Node 的版本号是 <code>v6.2.2</code>，这个信息其实就是在告诉你，该使用什么协议与调试程序进行通讯，<code>v6.2.2</code> 的版本所用到的协议是 <a href="https://github.com/buggerjs/bugger-v8-client/blob/master/PROTOCOL.md" target="_blank" rel="noopener">V8 Debugger Protocol</a>。</p>
<blockquote>
<p>为了打印全面的信息，注意操作的次序，先使用 debug 模块启动程序 test.js，然后启动 debugClient.js，最后再执行 curl 发起请求。</p>
</blockquote>
<p>在 curl 发起请求的时候，Debugger 会给 debugClient 发送一个消息：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">Content-Length: 283</span><br><span class="line"></span><br><span class="line">&#123;<span class="attr">"seq"</span>:<span class="number">0</span>,<span class="attr">"type"</span>:<span class="string">"event"</span>,<span class="attr">"event"</span>:<span class="string">"break"</span>,<span class="attr">"body"</span>:&#123;<span class="attr">"invocationText"</span>:<span class="string">"#&lt;Timeout&gt;._onTimeout()"</span>,<span class="attr">"sourceLine"</span>:<span class="number">9</span>,<span class="attr">"sourceColumn"</span>:<span class="number">4</span>,<span class="attr">"sourceLineText"</span>:<span class="string">"    debugger;"</span>,<span class="attr">"script"</span>:&#123;<span class="attr">"id"</span>:<span class="number">59</span>,<span class="attr">"name"</span>:<span class="string">"/path/to/test.js"</span>,<span class="attr">"lineOffset"</span>:<span class="number">0</span>,<span class="attr">"columnOffset"</span>:<span class="number">0</span>,<span class="attr">"lineCount"</span>:<span class="number">18</span>&#125;&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>刚才的 <code>curl</code> 不是进入 pending 了么，我们尝试给 Debugger 发一个指令（参考<a href="https://github.com/buggerjs/bugger-v8-client/blob/master/PROTOCOL.md#request-continue---continuerequest_" target="_blank" rel="noopener">协议内容</a>），告诉它进入下一个断点，内容为：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;<span class="attr">"seq"</span>:<span class="number">1</span>,<span class="attr">"type"</span>:<span class="string">"request"</span>,<span class="attr">"command"</span>:<span class="string">"continue"</span>&#125;</span><br></pre></td></tr></table></figure>
<p>在 debugClient 中我们监听了 <code>process.stdin</code>，所以可以直接将上述内容粘贴到命令行回车即可，同时你也会看到 Debugger 发过来的反馈：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;<span class="attr">"seq"</span>:<span class="number">1</span>,<span class="attr">"request_seq"</span>:<span class="number">1</span>,<span class="attr">"type"</span>:<span class="string">"response"</span>,<span class="attr">"command"</span>:<span class="string">"continue"</span>,<span class="attr">"success"</span>:<span class="literal">true</span>,<span class="attr">"running"</span>:<span class="literal">true</span>&#125;</span><br></pre></td></tr></table></figure>
<p>告诉你，已经成功进入到了下一个断点，此时，你也会看到 curl 已经把 <code>world</code> 给输出了。</p>
<p>上面的程序，你可以在命令行输入其他指令，比如在暂停的时候查询 req 的 url 的值：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;<span class="attr">"seq"</span>:<span class="number">2</span>,<span class="attr">"type"</span>:<span class="string">"request"</span>,<span class="attr">"command"</span>:<span class="string">"evaluate"</span>,<span class="attr">"arguments"</span>:&#123;<span class="attr">"expression"</span>:<span class="string">"req.url"</span>&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>你会收到如下回复：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">Content-Length: 177</span><br><span class="line"></span><br><span class="line">&#123;<span class="attr">"seq"</span>:<span class="number">3</span>,<span class="attr">"request_seq"</span>:<span class="number">2</span>,<span class="attr">"type"</span>:<span class="string">"response"</span>,<span class="attr">"command"</span>:<span class="string">"evaluate"</span>,<span class="attr">"success"</span>:<span class="literal">true</span>,<span class="attr">"body"</span>:&#123;<span class="attr">"handle"</span>:<span class="number">150</span>,<span class="attr">"type"</span>:<span class="string">"string"</span>,<span class="attr">"value"</span>:<span class="string">"/"</span>,<span class="attr">"length"</span>:<span class="number">1</span>,<span class="attr">"text"</span>:<span class="string">"/"</span>&#125;,<span class="attr">"refs"</span>:[],<span class="attr">"running"</span>:<span class="literal">false</span>&#125;</span><br></pre></td></tr></table></figure>
<p>在你的脑海中是不是已经出现了平时调试 Node.js 的画面了，没错，它的原理就是这样的。</p>
<h4 id="node-inspector，调试代理"><a href="#node-inspector，调试代理" class="headerlink" title="node-inspector，调试代理"></a>node-inspector，调试代理</h4><p>调试原理大概已经弄明白了，但是我相信没有几个人愿意通过上面的方式来调试程序，因为那实在是太麻烦了，不仅得知道各种指令的名称，还得知道指令的参数、协议的规范、sequence 的计数等等，因此就有了 <code>node-inspector</code>，它可以帮助我们在 Chrome Devtool 上可视化地调试 Node.js 程序，那么它干了什么事情呢？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">                                   +-----------------+</span><br><span class="line">                                   |  Node Program   |</span><br><span class="line">                                   +---------+-------+</span><br><span class="line">                                             ^</span><br><span class="line">                                             |</span><br><span class="line">+-----------------+                +---------+-------+</span><br><span class="line">|  Chrome Devtool |                | Node.js Debugger|</span><br><span class="line">+--------+--------+                +---------+-------+</span><br><span class="line">         |                                   ^</span><br><span class="line">         |                                   |</span><br><span class="line">       CRDP                                 V8DP</span><br><span class="line">         |      +-------------------+        |</span><br><span class="line">         +-----&gt;+   node inspector  +--------+</span><br><span class="line">                +-------------------+</span><br><span class="line"></span><br><span class="line">CRDP: Chrome Remote Debugging Protocol</span><br><span class="line">V8DP: V8 Debugging Protocol</span><br></pre></td></tr></table></figure>
<p>简单来说，<code>node inspector</code> 通过 Chrome 的 <code>Remote Debugging Protocol</code> 与 Chrome Devtool 建立了通道，然后通过 <code>V8 Debugging Protocol</code> 与程序的 <code>Debugger</code> 模块建立了连接，于是开发者就可以在 Chrome 上通过可视化操作来实现 Node.js 的调试了，所以我称它为“调试代理”，就是一个协议中转服务。</p>
<p>由于 <code>node-inspector</code> 很大程度提升了 Node 的调试体验，在 v6.3 的时候，Node.js 官方直接把这个能力给整合了进去。你会看到使用 v6.3+ 的 Node.js 中调试程序时，它会打印一个适配了 CRDP 协议的 webscoket 链接：</p>
<figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">➜ node --<span class="keyword">inspect</span> <span class="keyword">test</span>.js</span><br><span class="line">Debugger listening <span class="keyword">on</span> ws:<span class="comment">//127.0.0.1:9229/db309268-623a-4abe-b19a-c4407ed8998d</span></span><br><span class="line"><span class="keyword">For</span> <span class="keyword">help</span> see https:<span class="comment">//nodejs.org/en/docs/inspector</span></span><br></pre></td></tr></table></figure>
<p>我们可以直接在 Chrome Devtool 上配置这个地址进入可视化调试，于是整个链路就变成了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+------------------+       +----------------+</span><br><span class="line">|                  |       |                |</span><br><span class="line">|  Chrome Devtool  |       |  Node Program  |</span><br><span class="line">|                  |       |           +-----------+</span><br><span class="line">+--------+---------+       +-----------+  Debugger |</span><br><span class="line">         |                             +-----+-----+</span><br><span class="line">         |                                   ^</span><br><span class="line">         |               CRDP                |</span><br><span class="line">         +-----------------------------------+</span><br></pre></td></tr></table></figure>
<p>少了调试代理的接入，开发者使用起来会轻松很多，而且 CRDP 规范在社区使用非常频繁，实现上有很多代码可以参考。</p>
<p>讲到这里，如果我们要自己实现一个可视化调试的界面，是不是就有点清晰了，：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+-----------------+        +----------------+</span><br><span class="line">|                 |        |                |</span><br><span class="line">|     My IDE      |        |  Node Program  |</span><br><span class="line">|      +----------+---+    |           +----+------+</span><br><span class="line">+------| Debug Client |    +-----------+  Debugger |</span><br><span class="line">       +----------+---+                +-----+-----+</span><br><span class="line">                  |                          ^</span><br><span class="line">                  |            CRDP          |</span><br><span class="line">                  +--------------------------+</span><br></pre></td></tr></table></figure>
<p>只需要实现下图的 <code>Debug Client</code> 部分，以及 <code>Debug Client</code> 与 IDE 的视图进行联动，就可以实现自定义的可视化的调试了。</p>
<blockquote>
<p>如果你的需求是自定义 Node.js 的可视化调试，本文看到这里就可以结束了，相信你利用上面学到的知识完全有能力去实现一个调试界面。但是在 VS Code 中，我们有必要再展开更多的篇幅。</p>
</blockquote>
<h3 id="Debug-Adaptor-Protocol"><a href="#Debug-Adaptor-Protocol" class="headerlink" title="Debug Adaptor Protocol"></a>Debug Adaptor Protocol</h3><p>实现一个 Debug Client 其实成本挺高的，你需要吃透所有的调试协议，如 V8 Debugging Protocol，包含了几十个指令，每个指令都需要进行通讯适配和 UI 适配，这还只是一种语言，如果你的 IDE 面向多种语言，你就需要适配多种调试协议，不同协议之前的差异可能还挺大的，这些工作完全会让你崩溃。</p>
<p>另外，站在社区的角度，这种建设是可以被抽象的，试想一下，Atom 调试 Node.js 需要自己实现一个 Debug Client，Sublime Text 如此、VS Code 如此，你自建 IDE 也是如此，是不是完全没必要，因此就有了 <code>Debug Adaptor Protocol</code>，它是微软提出的一套 <a href="https://microsoft.github.io/debug-adapter-protocol/" target="_blank" rel="noopener">通用调试协议</a>，目前已经成为了社区的事实标准。</p>
<p>那这个 DAP 在调试的哪一层呢？我们可以看看这张图（<a href="https://microsoft.github.io/debug-adapter-protocol/overview" target="_blank" rel="noopener">来源</a>）：</p>
<p><img src="http://www.barretlee.com/blogimgs/2019/11/15/dap.png" alt="DAP"></p>
<p>在 IDE 上仅实现一次对 DAP 协议的通讯和 UI 适配，就可以调试所有的语言，你需要做的只有：</p>
<ul>
<li>社区有目标语言的 DAP 实现么，如果有，直接拿过来用，可以快速适配，搞定调试</li>
<li>如果没有，利用上面我们学到的知识，实现一个 DA，贡献给社区</li>
</ul>
<p>这套协议规范了 5 块内容：</p>
<ul>
<li><code>Base Protocol</code>，描述了请求、响应、事件、出错等通讯格式</li>
<li><code>Events</code>，描述了初始化、完成配置、输出、断点、停止等十几种事件标准</li>
<li><code>Request</code>，描述了调试的各种指令的请求格式</li>
<li><code>Response</code>，描述了调试的各种指令的响应格式</li>
<li><code>Types</code>，描述了以上各种内容中涉及到的类型和接口描述</li>
</ul>
<p>原则上，规范中提到的内容都需要在 DA 中实现，即便语言的底层引擎中没有这种能力，也应该抛一个错误出来，这样才能保证一致性。</p>
<h3 id="实现一个-Node-js-的调试器"><a href="#实现一个-Node-js-的调试器" class="headerlink" title="实现一个 Node.js 的调试器"></a>实现一个 Node.js 的调试器</h3><p>为了搞懂上面提到的几个协议，我动手写了一个 DEMO，实现了一个最简单的操作：展示当前 Debug 的堆栈信息，如下图所示：</p>
<p><img src="http://www.barretlee.com/blogimgs/2019/11/15/debug-tracker.png" alt="Debug Demo"></p>
<blockquote>
<p>仓库地址是：<a href="https://github.com/barretlee/node-debug" target="_blank" rel="noopener">barretlee/node-debug</a></p>
</blockquote>
<p>可以下载下来跑一下，下载依赖后启动即可：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">npm <span class="built_in">run</span> init;</span><br><span class="line">npm <span class="built_in">run</span> start;</span><br><span class="line"><span class="built_in">open</span> http:<span class="comment">//127.0.0.1:4445</span></span><br></pre></td></tr></table></figure>
<p>这个 Demo 的完成度很低，而且关键环节都是 Mock 的，只是为了帮助自己理解整个过程，理解以后就没有继续去完善细节了，感兴趣的同学可以研究下。</p>
<p>我没有自己去实现完整一个 Node.js Debug Adaptor，倒不是因为复杂，直接去研究了下 VS Code 开源了两个 Adaptor，分别是：</p>
<ul>
<li><a href="https://github.com/microsoft/vscode-node-debug.git" target="_blank" rel="noopener">vscode-node-debug</a>，这个是对 v6.3 以下版本的实现</li>
<li><a href="https://github.com/microsoft/vscode-node-debug2.git" target="_blank" rel="noopener">vscode-node-debug2</a>，这个是对 v6.3 及以上版本的实现</li>
</ul>
<p>根据连接时返回的 <code>Embedding-Host</code> 信息来选择使用哪个版本，VS Code 好像会默认安装这两个包。整体思路跟我上面提到的是一样的。</p>
<h3 id="VS-Code-的具体实现"><a href="#VS-Code-的具体实现" class="headerlink" title="VS Code 的具体实现"></a>VS Code 的具体实现</h3><p>调试程序有两种方式，一种是调试已经启动的程序，另一种是调试未启动的程序，前者 VS Code 会直接 <code>attach</code> 上去，后者会先 fork 一个进程 <code>launch</code> 程序，这里只稍微介绍 VS Code 实际操作过程中的几个知识点：</p>
<h4 id="程序启动时没有带-debug-参数"><a href="#程序启动时没有带-debug-参数" class="headerlink" title="程序启动时没有带 debug 参数"></a>程序启动时没有带 debug 参数</h4><p>如果 Node.js 程序在启动的时候没有带 <code>--debug</code> 或者 <code>--inspect</code> 参数，默认情况下 Node.js 的 Debugger 模块是不会启动的，这种情况下并非就不能调试了，我们可以手动来启动调试模块：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 找到对应的 Node.js 进程的 PID</span></span><br><span class="line">➜ ps -aux | grep <span class="string">'node'</span></span><br><span class="line"><span class="comment"># 给这个 PID 发送 SIGUSR1 信号</span></span><br><span class="line">➜ <span class="built_in">kill</span> -SIGUSR1 NODE_PID</span><br></pre></td></tr></table></figure>
<h4 id="stopOnEntry"><a href="#stopOnEntry" class="headerlink" title="stopOnEntry"></a>stopOnEntry</h4><p>在 fork 一个 Node.js 进程进行调试的时候，有两类入参：</p>
<ul>
<li><code>--debug</code> 和 <code>--inspect</code>，默认执行程序</li>
<li><code>--debug-brk</code> 和 <code>--inspect-brk</code>，默认在第一行直接断点</li>
</ul>
<p>一般来说我们都会选择第一种，如果你的程序会直接执行完成，速度很快，可以考虑第二种方式进行调试。</p>
<h4 id="VS-Code-连接-Node-js-调试进程的方式"><a href="#VS-Code-连接-Node-js-调试进程的方式" class="headerlink" title="VS Code 连接 Node.js 调试进程的方式"></a>VS Code 连接 Node.js 调试进程的方式</h4><p>VS Code 调试 Node.js 的 Debug Adaptor 核心内容在 <a href="https://github.com/microsoft/vscode-chrome-debug-core" target="_blank" rel="noopener">vscode-chrome-debug-core</a> 这个包中，它实际上是一个 Chrome Remote Debugging Protocol 的具体实现，<em>内部逻辑很多，看起来有点吃力</em>。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>好吧，先写到这里，还有很多细节问题就不一一叙述了，价值不大，写这篇文章做了不少前期工作，对 DAP 和 Node.js 的 Debugger 研究了好几个晚上，不过总算是搞的比较明白了，如果你在测试的时候遇到什么疑问，欢迎在 <a href="#comment">下方</a> 留言。</p>
]]></content:encoded>
      <comments>https://yun.wztlink1013.com/blog/2019/11/15/vscode-study-03-debug-protocol/#comments</comments>
    </item>
    
    <item>
      <title><![CDATA[一个刚毕业的计算机相关专业学生，简历上有哪些经历会加分？]]></title>
      <link>https://yun.wztlink1013.com/blog/2019/11/07/resume-writing/</link>
      <guid>https://yun.wztlink1013.com/blog/2019/11/07/resume-writing/</guid>
      <pubDate>Thu Nov 07 2019 12:01:00 GMT+0800 (GMT+08:00)</pubDate>
      <description>
      <![CDATA[有同学问我如何让简历加分，事实上这个问题之前分享过，再总结一下。下面的描述更多的是偏向于社招，不过对学生而言也有一定的参考价值。]]>
      
      </description>
      <content:encoded><![CDATA[<p>有同学问我如何让简历加分，事实上这个问题之前分享过，再总结一下。<strong>下面的描述更多的是偏向于社招，不过对学生而言也有一定的参考价值。</strong></p>
<p>首先简历这个东西，只是一个敲门砖，我们的目的是让面试官看上去产生好感，然后给我们一个面试的机会，简历不需要表达全部的自己，面试官一定是从面试中获取大量的情报来深入了解你。所以简历写到什么程度，我们的目标是相当明确的。</p>
<p><strong>如何从简历中让人看出你【做成了】什么，以及你未来【可能做成】什么，以下几点可以参考</strong>：</p>
<ul>
<li>表达一件有挑战的完整的事情，比如实现了一个平台的架构推导和落地，再如使用三个月时间经历四轮优化将系统的整体性能提升了 1.5 倍等等；而不是我写了某个网站的前端，沉淀了五个通用组件等等；</li>
<li>展示你跨专业的特性，比如作为前端工程师，我在运维工作上做了比较突出的贡献；在图形图像方面有深入研究和良好产出；曾并发管理 5 个中型项目并保证准时交付等等；</li>
<li>从业务价值的角度去发现问题和分析问题，比如通过融合两个相似系统后，降低了运营的成本，提高了数据从线下到线上展示的效率等；而不是简单地说，实现了数据层的合并，统一了前台交互等这种纯技术的表达；</li>
</ul>
<p><strong>说到底，还是需要让面试官看到你这几方面的能力</strong>：</p>
<ol>
<li>技术综合能力/学习能力（硬实力）</li>
<li>业务洞察力（理解力）</li>
<li>拿结果的能力（执行力）</li>
</ol>
<p><strong>看过不少简历，优秀的人大概都有这么一些特征（具备两三条甚至更多）</strong>：</p>
<ol>
<li>名企呆过，有大厂背书</li>
<li>参与的项目非常有震撼力</li>
<li>在技术领域跨度大的项目有成绩</li>
<li>有门槛的技术领域里有沉淀</li>
<li>技术产出对团队/业务有突出的影响</li>
<li>接二连三的专利</li>
<li>拿过一些很难拿到的奖项</li>
<li>非常好的韧劲，某一/几件事情上坚持不懈</li>
<li>思考力惊人，行动力惊人</li>
<li>思维敏捷且逻辑无比严谨</li>
<li>具备一定的社区影响力</li>
</ol>
<p>希望对你有些帮助。</p>
]]></content:encoded>
      <comments>https://yun.wztlink1013.com/blog/2019/11/07/resume-writing/#comments</comments>
    </item>
    
    <item>
      <title><![CDATA[带你开发和调试 VS Code 源码]]></title>
      <link>https://yun.wztlink1013.com/blog/2019/11/01/vscode-study-02-debugging/</link>
      <guid>https://yun.wztlink1013.com/blog/2019/11/01/vscode-study-02-debugging/</guid>
      <pubDate>Fri Nov 01 2019 17:43:00 GMT+0800 (GMT+08:00)</pubDate>
      <description>
      <![CDATA[小胡子哥的个人网站]]>
      
      </description>
      <content:encoded><![CDATA[<p><a href="https://www.barretlee.com/blog/2019/10/23/vscode-study-01-start/" target="_blank" rel="noopener">上文</a> 给大家介绍了如何在本地从源码启动 VS Code，笔者在更换电脑后重新安装依赖时又遇到了文中插曲里提到的问题，VS Code 依赖的很多资源都在 Github 上，而且有好几个模块都需要下载源码重新编译，安装依赖失败的概率还是略大的。</p>
<p>如果依赖的包构建失败，不用担心，等到启动的时候它会提示详细错误：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">[<span class="number">92850</span>:<span class="number">1031</span>/<span class="number">221458.947969</span>:INFO:CONSOLE(<span class="number">17</span>)] </span><br><span class="line"><span class="comment">"Error: The module '~/vscode/node_modules/spdlog/build/Release/spdlog.node'</span></span><br><span class="line">was compiled against <span class="keyword">a</span> different Node.js <span class="keyword">version</span> using</span><br><span class="line">NODE_MODULE_VERSION <span class="number">73</span>. This <span class="keyword">version</span> of Node.js requires</span><br><span class="line">NODE_MODULE_VERSION <span class="number">69</span>. Please <span class="keyword">try</span> re-compiling <span class="built_in">or</span> re-installing</span><br></pre></td></tr></table></figure>
<p>如上，是 <code>spdlog</code> 安装失败了，可以通过 <code>yarn add spdlog</code> 重新安装，如果一直报错，请注意 Node.js 的版本，我使用的是 <code>v10.6.0</code>，编译的是 tag 为 <code>1.39.2</code> 的 VS Code 源码，没遇到问题。</p>
<blockquote>
<p>测试过几次，当我切换 VS Code 的版本（git tag）时，似乎 spdlog 和 vscode-sqlite3 这两个包的安装总是存在问题，按照上述方式重新安装和编译下就行了。</p>
</blockquote>
<h3 id="Main-和-Renderer"><a href="#Main-和-Renderer" class="headerlink" title="Main 和 Renderer"></a>Main 和 Renderer</h3><p>倘若你之前没有 Electron 的开发经验，这个段落不容错过。</p>
<blockquote>
<p>如果你可以建一个网站，你就可以建一个桌面应用程序。 Electron 是一个使用 JavaScript, HTML 和 CSS 等 Web 技术创建原生程序的框架，它负责比较难搞的部分，你只需把精力放在你的应用的核心上即可。</p>
</blockquote>
<p>Electron 是个什么东西？官方对它的定义是：“使用 JavaScript, HTML 和 CSS 构建跨平台的桌面应用”。</p>
<p><img src="http://www.barretlee.com/blogimgs/2019/11/01/electreon-structure.png" alt="Electron Structure"></p>
<p>打开 Electron 的 <a href="https://electronjs.org/docs" target="_blank" rel="noopener">文档</a>，从文档目录中，你大致就能够知道 Electron 可以做什么。Electron 有两大模块，<code>Main Process</code> 和 <code>Renderer Process</code>，暴露出来的上层 API 并不多，我数了一下，约摸 30 个。搞懂这 30 个 API 可能不是什么难事，但是在搞清楚 API 之前，我们需要先知道这两大模块之间是如何交互和协作的，以帮助我们更好地理解。</p>
<p>打开官方的 quick start demo：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/electron/electron-quick-start</span><br><span class="line"><span class="comment"># 进入仓库</span></span><br><span class="line">$ <span class="built_in">cd</span> electron-quick-start</span><br><span class="line"><span class="comment"># 安装依赖库</span></span><br><span class="line">$ npm install</span><br><span class="line"><span class="comment"># 运行应用</span></span><br><span class="line">$ npm start</span><br></pre></td></tr></table></figure>
<p>你会看到两个核心文件，一个是 <code>main.js</code>，另外一个是 <code>index.html</code>，你完全可以这么理解：前者跑的是 Main Process，它的执行环境是一个 <code>Node</code> 环境；后者跑的是 Renderer Process，它的执行环境是一个 <code>Chromium + Node</code> 环境，也就是说，我们写的 <code>index.html</code> 中可以去调用 Node.js 的模块，这也是 Electron 与普通浏览器的主要差别。</p>
<p>Main 进程中可以通过 <code>BrowserWindow</code> 实例化多个 Renderer 进程，且每个 Renderer 进程相关独立，在复杂的项目中会涉及到了很多通信问题，比如 Main-Renderer 通讯，Renderer-Main 通讯，Renderer-Renderer 通讯，VS Code 中就有很多这类问题的优秀解决方案，不过不在我们今天的讨论范畴中。</p>
<p>Main 和 Renderer 之间的关系，可以用这种图来形容（<a href="http://jlord.us/essential-electron/" target="_blank" rel="noopener">图片来源</a>）：</p>
<p><img src="http://www.barretlee.com/blogimgs/2019/11/01/main-and-renderer.png" alt="Main and Renderer"></p>
<p>对于 Electron，先了解这么多知识，如果你期望了解更多，可以移步 <a href="https://electronjs.org/docs" target="_blank" rel="noopener">Electron 官方文档</a>。</p>
<h3 id="初识-VS-Code"><a href="#初识-VS-Code" class="headerlink" title="初识 VS Code"></a>初识 VS Code</h3><p>很多同学对 VS Code 已经熟悉得不能再熟悉了，谈不上初识，不过我们这里说的“初识”是针对它的架构和源码，相信对大多数人来说，它依然是陌生的。</p>
<p>先看看项目的整体目录结果，过滤了几个次要项：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── azure-pipelines.yml</span><br><span class="line">├── build/</span><br><span class="line">├── extensions/</span><br><span class="line">├── gulpfile.js</span><br><span class="line">├── out/</span><br><span class="line">├── package.json</span><br><span class="line">├── product.json</span><br><span class="line">├── resources/</span><br><span class="line">├── scripts/</span><br><span class="line">├── src/</span><br><span class="line">│   ├── main.js</span><br><span class="line">│   └── vs</span><br><span class="line">│       ├── base/</span><br><span class="line">│       ├── code/</span><br><span class="line">│            ├── browser/</span><br><span class="line">│                 ├── workbench.ts</span><br><span class="line">│                 └── workbench/workbench.html</span><br><span class="line">│            ├── electron-browser/</span><br><span class="line">│                 ├── workbench.js</span><br><span class="line">│                 └── workbench/workbench.html</span><br><span class="line">│            └── electron-main/</span><br><span class="line">│                 ├── main.ts</span><br><span class="line">│                 └── window.ts</span><br><span class="line">│       ├── editor/</span><br><span class="line">│       ├── platform/</span><br><span class="line">│       ├── server/</span><br><span class="line">│       └── workbench/</span><br><span class="line">└── test/</span><br></pre></td></tr></table></figure>
<p>上面这一坨看起来有点多，不过捋清楚了，也就好理解了，下面我们就一个一个地解释下：</p>
<ul>
<li><code>azure-pipelines.yml</code>，看名字就知道是啥意思，它是一个 CI/CD 的配置，自动测试、构建、打包</li>
<li><code>build/</code>，这里面放的是 VS Code 项目的构建工具，相对来说还是比较复杂的，主要是因为它顾及了 Linux/Mac/Windows 三个平台</li>
<li><code>extensions/</code>，VS Code 的内置模块，包含各种语言高亮的 LSP 相关模块</li>
<li><code>gulpfile.js</code>，构建脚本，暂时不用细看，可以关注 <code>package.json</code> 的 scripts，里面放着一些程序的快捷启动方式，而且针对内存溢出做了防御，如 <code>--max_old_space_size=4095</code></li>
<li><code>out/</code>，构建的结果都放在这个目录下</li>
<li><code>package.json</code>，需要着重看看 <code>main</code> 和 <code>scripts</code> 两个字段</li>
<li><code>product.json</code>，如果你想根据 VS Code 进行二次开发，建立自己的品牌，建议搞懂这个文件，因为你需要修改它</li>
<li><code>resource/</code>，打包构建生成安装包（exe/dmg/deb 等）的时候需要依赖的额外资源</li>
<li><code>scripts/</code>，开发过程各种会用到的脚本，用的比较多的可能是 <code>./scripts/code.sh</code></li>
<li><code>test/</code>，放的是各种自动化、冒烟、UI 测试脚本，这里值得学习和研究下</li>
<li><code>src/</code>，核心源码，入口是 <code>main.js</code><ul>
<li>Main Process 的实际调用路径是 <code>main.js -&gt; vs/code/electron-main/main.ts -&gt; vs/code/electron-main/window.ts</code>，在 <code>window.ts</code> 启动了一个 <code>BrowserWindow</code> 加载了 <code>vs/code/electron-browser/workbench/workbench.html</code></li>
<li>Renderer Process 的实际路径是 <code>vs/code/electron-browser/workbench/workbench.html -&gt; vs/code/electron-browser/workbench/workbench.js</code>，核心逻辑在 <code>workbench.js</code> 中</li>
<li>而 src 下还有一个核心目录 <code>browser</code>，它是 Web 版本的启动入口</li>
</ul>
</li>
</ul>
<p>VS Code 的复杂度，有好几块，分别是构建、IoC 机制、RPC 设计、ExtensionHost 环境等，再加上 Electron 本身的各种坑，后续我们可以一一进行探讨。</p>
<h3 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h3><p>在玩转 VS Code 架构设计之前，我们需要先搞清楚代码的大致执行流程，还要学会在遇到问题时调试它的代码，光靠通扫几遍源码你是很难完全理解的。</p>
<p>VS Code 的使用文档写的非常棒，但是架构和设计文档只能从代码中自己探索，这是可以理解的，VS Code 目前还在高速发展中，内部架构设计调整也十分频繁，而且他们可能倡导的是“代码即文档”，通过一些规范化约束来帮助开发者理解架构设计。</p>
<p>不过没关系，既然开源了，就自己研究好了。下面我们先看看如何对 VS Code 的各块代码进行有效调试。</p>
<p>说到调试，有几个基础知识不得不提一提，不解释清楚，很多同学是无法理解为什么在工具上点几下就会进入调试的。</p>
<h4 id="Node-js-调试"><a href="#Node-js-调试" class="headerlink" title="Node.js 调试"></a>Node.js 调试</h4><p>Electron 的 <code>Main Process</code> 本质就是一个 Node.js 进程，你可以执行如下命令看看 Electron 的 bin 文件内容：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">npm <span class="keyword">install</span> -g electron</span><br><span class="line"><span class="keyword">head</span> -n <span class="number">5</span> $(<span class="keyword">where</span> electron | <span class="keyword">head</span> -n <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>打印出来的结果是：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env node</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> electron = <span class="built_in">require</span>(<span class="string">'./'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> proc = <span class="built_in">require</span>(<span class="string">'child_process'</span>)</span><br></pre></td></tr></table></figure>
<p>对 Node.js 的调试，可以看看我四年前写的 <a href="https://www.barretlee.com/blog/2015/10/07/debug-nodejs-in-command-line/" target="_blank" rel="noopener">《NodeJS 的代码调试和性能调优》</a>，时间有点久了，不过调试原理并没有啥变化。</p>
<blockquote>
<p>简单来说，就是启动 Node 时增加了一个 <code>--debug-brk</code> 入参（新版是 <code>--inspect-brk</code>），开启一个可供外部断点调试的端口，然后在外部使用各类工具连接端口，发送指令进行调试。</p>
</blockquote>
<h4 id="Chrome-调试"><a href="#Chrome-调试" class="headerlink" title="Chrome 调试"></a>Chrome 调试</h4><p>Chromium 在启动的时候有一个可选参数 <code>--remote-debugging-port</code>, 加上这个参数以后，它会开启远程调试模式，如：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">/Applications/</span>Google\ Chrome.app<span class="regexp">/Contents/</span>MacOS<span class="regexp">/Google\ Chrome -remote-debugging-port=9222</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果你的 Chrome 已经启动，上面的命令不会有效果，可以考虑下载一个 Google Chrome Canary</p>
</blockquote>
<p>通过 <code>http://127.0.0.1:9222/json</code> 可以看到当前 Chrome 打开了哪些页面，并且它还会把 DevTools 的 ws 地址也展示出来：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">[&#123;</span><br><span class="line">   <span class="attr">"description"</span>: <span class="string">""</span>,</span><br><span class="line">   <span class="attr">"devtoolsFrontendUrl"</span>: <span class="string">"/devtools/inspector.html?ws=127.0.0.1:9222/devtools/page/3CFC..."</span>,</span><br><span class="line">   <span class="attr">"id"</span>: <span class="string">"3CFC338A39A4CF1F31F0CB499D94C071"</span>,</span><br><span class="line">   <span class="attr">"title"</span>: <span class="string">"新标签页"</span>,</span><br><span class="line">   <span class="attr">"type"</span>: <span class="string">"page"</span>,</span><br><span class="line">   <span class="attr">"url"</span>: <span class="string">"chrome://newtab/"</span>,</span><br><span class="line">   <span class="attr">"webSocketDebuggerUrl"</span>: <span class="string">"ws://127.0.0.1:9222/devtools/page/3CFC..."</span></span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure>
<p>我们来做一个小小的实验，上面打开了一个 Chrome，并且展示了一个空标签页，我们尝试使用 websocket 连接它，然后控制它：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> wsUrl = <span class="string">"ws://127.0.0.1:9222/devtools/page/3CFC..."</span>;</span><br><span class="line"><span class="keyword">let</span> ws = <span class="keyword">new</span> WebSocket(wsUrl);</span><br><span class="line">ws.onmessage = <span class="function"><span class="params">data</span> =&gt;</span> <span class="built_in">console</span>.log(data);</span><br><span class="line">ws.onclose = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'closed'</span>);</span><br><span class="line">ws.onopen = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'opened'</span>);</span><br></pre></td></tr></table></figure>
<p>随便找个浏览器的控制台执行这段脚本，会看到打印出来了 <code>opened</code>，然后我们尝试让这个 “新标签页” 跳转到我的博客首页，发送几句命令：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 开启网络功能</span></span><br><span class="line">ws.send(<span class="string">`&#123;</span></span><br><span class="line"><span class="string">  "id":1,</span></span><br><span class="line"><span class="string">  "method":"Network.enable"</span></span><br><span class="line"><span class="string">&#125;`</span>)；</span><br><span class="line"><span class="comment">// 跳转页面</span></span><br><span class="line">ws.send(<span class="string">`&#123;</span></span><br><span class="line"><span class="string">  "id": 1,</span></span><br><span class="line"><span class="string">  "method": "Page.navigate",</span></span><br><span class="line"><span class="string">  "params": &#123; "url": "https://www.barretlee.com" &#125;</span></span><br><span class="line"><span class="string">&#125;`</span>);</span><br></pre></td></tr></table></figure>
<p>你会看到，通过命令行打开的 Chrome 的默认页已经自动跳转到了 <code>https://www.barretlee.com</code>，看到这里你应该已经可以理解了，所谓的调试，其实就是通过连接 Chrome 内部的 DevTools 工具，然后利用 RPC 的方式进行通讯，事实上，这里用到的是 <a href="https://chromedevtools.github.io/devtools-protocol/" target="_blank" rel="noopener">Remote Debugging Protocol</a> 进行的通讯。</p>
<blockquote>
<p>大名鼎鼎的 <a href="https://github.com/GoogleChrome/puppeteer" target="_blank" rel="noopener">Puppeteer</a> 就是基于这层协议做的封装。</p>
</blockquote>
<p>好了，为了让你理解 VS Code 的调试原理，已经做了很多铺垫了，事实上，在 VS Code 上进行调试的操作是十分简单的，下面就带着你一起演示下。</p>
<h3 id="软件调试"><a href="#软件调试" class="headerlink" title="软件调试"></a>软件调试</h3><p>使用 VS Code 打开 VS Code 的源码，点开左侧 sidebar 的 Debug Tab，你会看到调试区域存在很多个调试选项：</p>
<p><img src="http://www.barretlee.com/blogimgs/2019/11/01/vscode-debug-panel.png" alt="VSCode Debug Panel"></p>
<p>这里的所有调试配置，都对应着项目中 <code>.vscode/launch.json</code> 的内容，我之前写过一篇关于 <code>launch.json</code> 的 <a href="https://www.barretlee.com/blog/2019/03/18/debugging-in-vscode-tutorial/" target="_blank" rel="noopener">文章</a>，在这里我们又有机会用到了。</p>
<p>软件的调试分为两个部分，一个是 Main 进程的调试，一个是 Renderer 进程的调试。</p>
<blockquote>
<p>开始调试之前，请先把 VS Code Dev 的监听模式打开，项目目录下执行 <code>yarn watch</code></p>
</blockquote>
<h4 id="Main-进程调试"><a href="#Main-进程调试" class="headerlink" title="Main 进程调试"></a>Main 进程调试</h4><p>先进入到一个 Main 进程会执行到的代码区域，打一个断点，如 <code>vs/code/electron-main/main.ts:404:0</code>，然后选择 <code>launch.json</code> 中的 <code>Launch VS Code (Main Process)</code> 配置：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"type"</span>: <span class="string">"node"</span>,</span><br><span class="line">  <span class="attr">"request"</span>: <span class="string">"launch"</span>,</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"Launch VS Code (Main Process)"</span>,</span><br><span class="line">  <span class="attr">"runtimeExecutable"</span>: <span class="string">"$&#123;workspaceFolder&#125;/scripts/code.sh"</span>,</span><br><span class="line">  <span class="attr">"windows"</span>: &#123;</span><br><span class="line">    <span class="attr">"runtimeExecutable"</span>: <span class="string">"$&#123;workspaceFolder&#125;/scripts/code.bat"</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"runtimeArgs"</span>: [</span><br><span class="line">    <span class="string">"--no-cached-data"</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">"outFiles"</span>: [</span><br><span class="line">    <span class="string">"$&#123;workspaceFolder&#125;/out/**/*.js"</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>启动的默认端口是 <code>5875</code>，点击开始调试按钮，或者按下快捷键 <code>F5</code>，便会进入调试模块，在 VS Code 上也有体现：</p>
<p><img src="http://www.barretlee.com/blogimgs/2019/11/01/vscode-node-debugging.png" alt="VSCode Node Debugging"></p>
<p>可以看到我们打点的位置也已经亮了起来，阻塞了 VS Code Dev 的启动：</p>
<p><img src="http://www.barretlee.com/blogimgs/2019/11/01/vscode-node-deubgging-demo.png" alt="VSCode Node Debugging Demo"></p>
<p>好了，现在可以开始你的 Main 进程代码探索之旅了。</p>
<blockquote>
<p>需要注意，在调试 Main Process 的时候，不要把断点打到 Renderer 进程里去了，否则你永远也进不了断点；也不要打到 Main Process 不会执行的代码区域，这就要求你对 VS Code 的目录结构有一定的了解了，可以参考“初识 VS Code”章节的介绍</p>
</blockquote>
<p>另外，再给你留了一道作业题：</p>
<blockquote>
<p>尝试使用其他工具，如 node-inspector 或者 Webstorm 调试 Main 进程。</p>
</blockquote>
<h4 id="Renderer-进程的调试"><a href="#Renderer-进程的调试" class="headerlink" title="Renderer 进程的调试"></a>Renderer 进程的调试</h4><p>Renderer 进程的调试，本质就是通过外部工具连接 Electron 中 Chromium 打开的一个 DevTools Server，使用 WebSocket 建立连接，然后发送和接受各种指令。</p>
<p>选择 <code>launch.json</code> 中的 <code>Launch VS Code</code>，它的内容是：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"type"</span>: <span class="string">"chrome"</span>,</span><br><span class="line">  <span class="attr">"request"</span>: <span class="string">"launch"</span>,</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"Launch VS Code"</span>,</span><br><span class="line">  <span class="attr">"windows"</span>: &#123;</span><br><span class="line">    <span class="attr">"runtimeExecutable"</span>: <span class="string">"$&#123;workspaceFolder&#125;/scripts/code.bat"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"osx"</span>: &#123;</span><br><span class="line">    <span class="attr">"runtimeExecutable"</span>: <span class="string">"$&#123;workspaceFolder&#125;/scripts/code.sh"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"linux"</span>: &#123;</span><br><span class="line">    <span class="attr">"runtimeExecutable"</span>: <span class="string">"$&#123;workspaceFolder&#125;/scripts/code.sh"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"timeout"</span>: <span class="number">20000</span>,</span><br><span class="line">  <span class="attr">"env"</span>: &#123;</span><br><span class="line">    <span class="attr">"VSCODE_EXTHOST_WILL_SEND_SOCKET"</span>: <span class="literal">null</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"breakOnLoad"</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">"urlFilter"</span>: <span class="string">"*workbench.html*"</span>,</span><br><span class="line">  <span class="attr">"runtimeArgs"</span>: [</span><br><span class="line">    <span class="string">"--inspect=5875"</span>,</span><br><span class="line">    <span class="string">"--no-cached-data"</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">"webRoot"</span>: <span class="string">"$&#123;workspaceFolder&#125;"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样，开启调试后，找个 Renderer 进程会执行到的代码块进行断点，如 <code>vs/code/workbench/workbench.desktop.main.ts</code>，如果你的 VS Code Dev 已经启动了，可以在 VS Code Dev 的界面中按下 <code>cmd+r</code>，它会自动刷新 Renderer 进程（刷新页面），重新进入你的断点：</p>
<p><img src="http://www.barretlee.com/blogimgs/2019/11/01/vscode-chrome-deubgging.png" alt="VSCode Chrome Debugging"></p>
<p>怎么样，看到这里，是不是对开发 VS Code 的源码已经有信心了。</p>
<blockquote>
<p>需要注意的是，如果你是通过 <code>./script/code.sh</code> 在控制台手动启动的 VS Code Dev，<code>launch.json</code> 中的 <code>Attach to VS Code</code> 是无效的，因为在启动的时候，不会默认添加 –remote-debugging-port 入参</p>
</blockquote>
<h3 id="构建脚本调试"><a href="#构建脚本调试" class="headerlink" title="构建脚本调试"></a>构建脚本调试</h3><p>知道了如何对软件本身的代码进行调试，大部分情况下已经够用了，但是如果你在启动 VS Code 的时候失败了，报了个错，或者当你打包 VS Code 的时候，抛出个异常，需要怎么排查问题呢？</p>
<p>这里，我们可以了解下构建脚本的调试，虽说构建脚本我们可以随时写一句 <code>console.log</code> 打印日志，但是 VS Code 的 <code>build</code> 脚本是非常多，而且每一次的构建都特别漫长，还是更加推荐你使用它提供的构建脚本调试能力进行 Debug，在 <code>launch.json</code> 中有一个 <code>Gulp Build</code> 配置：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"type"</span>: <span class="string">"node"</span>,</span><br><span class="line">  <span class="attr">"request"</span>: <span class="string">"launch"</span>,</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"Gulp Build"</span>,</span><br><span class="line">  <span class="attr">"program"</span>: <span class="string">"$&#123;workspaceFolder&#125;/node_modules/gulp/bin/gulp.js"</span>,</span><br><span class="line">  <span class="attr">"stopOnEntry"</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">"args"</span>: [</span><br><span class="line">    <span class="string">"hygiene"</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过这个配置启动 gulp，这样就可以对构建脚本进行断点了，由于配置中加了 <code>stopOnEntry</code>，当进入调试的时候，第一行就会断住：</p>
<p><img src="http://www.barretlee.com/blogimgs/2019/11/01/debug-grulp.png" alt="VSCode Gulp Debugging"></p>
<p>你也可以去掉这个参数，不过需要你在执行 gulp 之前在程序中提前断一个点：</p>
<p><img src="http://www.barretlee.com/blogimgs/2019/11/01/debug-gulp-file.png" alt="VSCode Gulp Debugging"></p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>好了，VS Code 源码的调试教程就写到这里，希望你读完这篇文章以后，可以自己动手去尝试，很多比较细节的点我没有写全面，所以实践过程中你可能还会遇到一些坑，当你躺平了这些坑，相信你就可以完全理解这些调试的基本原理了。</p>
<p>后续将带着大家看一看 VS Code 的整体执行链路，其实上次我已经写过一篇类似的 <a href="https://www.barretlee.com/blog/2019/08/03/vscode-source-code-reading-notes/" target="_blank" rel="noopener">文章</a>了，行文比较粗糙，下次将带着大家一边调试一边看代码和执行链路。</p>
]]></content:encoded>
      <comments>https://yun.wztlink1013.com/blog/2019/11/01/vscode-study-02-debugging/#comments</comments>
    </item>
    
    <item>
      <title><![CDATA[Github 的 Go to Definition 功能实现剖析]]></title>
      <link>https://yun.wztlink1013.com/blog/2019/10/31/github-go-to-definition/</link>
      <guid>https://yun.wztlink1013.com/blog/2019/10/31/github-go-to-definition/</guid>
      <pubDate>Thu Oct 31 2019 23:58:00 GMT+0800 (GMT+08:00)</pubDate>
      <description>
      <![CDATA[Github 的源码阅读已经支持 Go to Definition 了，目前还在 beta 阶段，且需要用户手动开启，仔细研究了下它的实现方式，从逻辑上看是存在 bug 的，整体策略大概是：]]>
      
      </description>
      <content:encoded><![CDATA[<p>Github 的源码阅读已经支持 Go to Definition 了，目前还在 beta 阶段，且需要用户手动开启，仔细研究了下它的实现方式，从逻辑上看是存在 bug 的，整体策略大概是：</p>
<p><img src="http://www.barretlee.com/blogimgs/2019/10/31/go-to-definition.png" alt="Go to Definition"></p>
<ol>
<li>仓库进入 Navigation 模式（initialization），Github Server 端对该版本（取 commit hash）的源码进行词法分析，保存关键 token 信息，并记录关键 token 的初始定义位置和被引用的位置；</li>
<li>用户进入网页，若 initialization 未完成则无效果；否则启动 Navigation 模式；</li>
<li>探测用户鼠标 hover 事件，当 hover 到 textNode 节点时，取出节点位置，这里用到的是一个新的 API：document.caretRangeFromPoint；</li>
<li>步骤 3 中拿到的只是 offset，它是个位置数值信息，通过正则 /\w+[!?]?/g 匹配出 hover 到的目标文本，然后将信息发送到 Server，入参包括文本、文件路径、commit hash 和语言类型；</li>
<li>Server 端返回步骤 1 中生成的 token 元数据，并直接解析成 HTML，前端展示</li>
</ol>
<p>这里的 bug 就出现在第 5 步，如果某个变量在两个子作用域中定义，那么 Server 端是无法识别它的 Definition 属于哪个作用域的（我没测试，从理论上讲，应该有这个 bug），另外它 hover 到任何单词都会发送请求，但是后台却只对 function 做了识别，其他类型都是无返回的。</p>
<p>简单来说，这个 beta 功能可以满足部分场景的需要，但并不能完全覆盖且准确地识别所有类型。真要完整识别，应该只能在浏览器端通过 LSP 协议来做，不过这么做的话，对网络 IO 和本地 CPU 都是一个巨大的挑战，Web 版的 VS Code 会有这个能力，我估计 Github 网页上不会提供。</p>
]]></content:encoded>
      <comments>https://yun.wztlink1013.com/blog/2019/10/31/github-go-to-definition/#comments</comments>
    </item>
    
    <item>
      <title><![CDATA[Google 的 Code Review 实践经验]]></title>
      <link>https://yun.wztlink1013.com/blog/2019/10/30/google-code-review-practice/</link>
      <guid>https://yun.wztlink1013.com/blog/2019/10/30/google-code-review-practice/</guid>
      <pubDate>Wed Oct 30 2019 12:42:00 GMT+0800 (GMT+08:00)</pubDate>
      <description>
      <![CDATA[Google 的 Code Review 目标是不断提高 codebase 的质量，同时要求审阅者在代码的高质量和业务的推进之间做好权衡，两边的极端都不要走，并给出了一些实战经验，下面我总结了下：]]>
      
      </description>
      <content:encoded><![CDATA[<p>Google 的 Code Review 目标是不断提高 codebase 的质量，同时要求审阅者在代码的高质量和业务的推进之间做好权衡，两边的极端都不要走，并给出了一些 <a href="https://google.github.io/eng-practices/review/reviewer/looking-for.html" target="_blank" rel="noopener">实战经验</a>，下面我总结了下：</p>
<p><strong>1. 设计</strong></p>
<p>新增的几块代码是否有意义？代码的结构是否合理，应该放在 codebase 里还是抽离成组件？对系统的持续集成是否会造成印象？等等。</p>
<p><strong>2. 功能</strong></p>
<p>站在用户的角度和开发者的角度，从功能和代码块上去审阅功能的合理性，除此之外，还要考虑单从代码上看不到的问题，比如并发问题、UI 交互问题、死锁问题等等。</p>
<p><strong>3. 复杂度</strong></p>
<p>审查是否存在工程上的过度设计，鼓励解决当下的问题，不要对未来做过多的设计，因为未来（业务）充满了不确定性。</p>
<p><strong>4. 测试</strong></p>
<p>除非是紧急上线，一般情况下，都要求提交的代码有单元测试、集成测试和端对端测试，要确保测试用例正确、有意义、有效果。</p>
<p><strong>5. 命名</strong></p>
<p>开发者是否给所有的变量都准确命名？一个好的命名不应太长也不可过短，刚好让人看懂的长度最好了。</p>
<p><strong>6. 注释</strong></p>
<p>开发者写的注释除了他自己外其他看得懂么？所有的注释是否是有意义的？是否描述清楚了代码是干啥的？有一点需要强调：对于正则以及复杂的逻辑是必须加注释的。</p>
<p><strong>7. 格式</strong></p>
<p>这一块我觉得他讲的并不好，格式主要在工具层面通过 lint 来纠正，只不过格式之外会有一些团队的约定，需要人为去判断或者不好工具检测的部分，可以在 Code Review 的时候提出来。</p>
<p><strong>8. 文档</strong></p>
<p>相关的 README 或者文档自动生成工具是否补全，废弃的代码、文档是否删除等。</p>
<p><strong>9. 每一行</strong></p>
<p>确保每一行都仔细审阅，包括数据文件、自动生成的文件、大的数据结构描述等等，如果代码很难阅读，你应该提前告诉开发者注意这方面的问题，难阅读的代码，对任何人都是一样难阅读的，这种代码应该尽量避免出现。</p>
<p><strong>10. 上下文</strong></p>
<p>Code Review 工具一般只会展示 diff 的内容，有的时候，你需要阅读整个文件，以确保开发者的逻辑是有用的，站在系统层面去考虑，这段代码是否会带来复杂度，是否是健康的，等等。</p>
<p><strong>11. 好的内容</strong></p>
<p>如果你看到开发者写的内容不错，不要吝啬的赞美和鼓励。</p>
]]></content:encoded>
      <comments>https://yun.wztlink1013.com/blog/2019/10/30/google-code-review-practice/#comments</comments>
    </item>
    
    <item>
      <title><![CDATA[换一种视角理解 awk 命令]]></title>
      <link>https://yun.wztlink1013.com/blog/2019/10/29/awk/</link>
      <guid>https://yun.wztlink1013.com/blog/2019/10/29/awk/</guid>
      <pubDate>Tue Oct 29 2019 14:49:00 GMT+0800 (GMT+08:00)</pubDate>
      <description>
      <![CDATA[awk 是使用频度非常高的一个超级有用的命令，如果你做过应用的线上运维，想必已经是十分熟悉了，但是对大多数人来说，它仍然是个陌生的东西，即便看过很多次文档，依然记不住它的模样，还是得翻文档、查 Google。下面我就带着你，换一种视角重新理解下 awk。]]>
      
      </description>
      <content:encoded><![CDATA[<p>awk 是使用频度非常高的一个超级有用的命令，如果你做过应用的线上运维，想必已经是十分熟悉了，但是对大多数人来说，它仍然是个陌生的东西，即便看过很多次文档，依然记不住它的模样，还是得翻文档、查 Google。下面我就带着你，换一种视角重新理解 awk。</p>
<p><img src="http://www.barretlee.com/blogimgs/2019/10/29/awk.jpg" alt="AWK"></p>
<p>它是什么？我觉得它就是一个表单筛选工具，往下看。</p>
<h3 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h3><p>下面是我截取 <code>cat /etc/passwd</code> 的部分内容，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root:x:0:0:root:/root:/bin/bash</span><br><span class="line">daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin</span><br><span class="line">bin:x:2:2:bin:/bin:/usr/sbin/nologin</span><br><span class="line">sys:x:3:3:sys:/dev:/usr/sbin/nologin</span><br><span class="line">sync:x:4:65534:sync:/bin:/bin/sync</span><br><span class="line">games:x:5:60:games:/usr/games:/usr/sbin/nologin</span><br><span class="line">man:x:6:12:man:/var/cache/man:/usr/sbin/nologin</span><br><span class="line">lp:x:7:7:lp:/var/spool/lpd:/usr/sbin/nologin</span><br><span class="line">mail:x:8:8:mail:/var/mail:/usr/sbin/nologin</span><br><span class="line">news:x:9:9:news:/var/spool/news:/usr/sbin/nologin</span><br></pre></td></tr></table></figure>
<p>保存为 <code>1.txt</code>，然后执行如下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat 1.txt | awk -F : <span class="string">' BEGIN\</span></span><br><span class="line"><span class="string"> &#123; print "No. R1 R3 R4"; count = 0 &#125;\</span></span><br><span class="line"><span class="string"> $3 &gt; 5 &amp;&amp; $3 &lt; 50 &amp;&amp;\</span></span><br><span class="line"><span class="string"> $1 !~ /root/\</span></span><br><span class="line"><span class="string"> &#123; count += 1; print NR, $1, $3, $4&#125; END\</span></span><br><span class="line"><span class="string"> &#123; print "total " count " lines" &#125; '</span></span><br></pre></td></tr></table></figure>
<p>输入的内容是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">No. R1 R3 R4</span><br><span class="line">7 man 6 12</span><br><span class="line">8 lp 7 7</span><br><span class="line">9 mail 8 8</span><br><span class="line">10 news 9 9</span><br><span class="line">total 4 lines</span><br></pre></td></tr></table></figure>
<p>看起来好像很复杂的样子，下面我们进行分解动作，一步一步带你认识 awk 的世界。</p>
<h3 id="获取表单"><a href="#获取表单" class="headerlink" title="获取表单"></a>获取表单</h3><p>例子里的数据是结构化的，每一行有 7 条数据，使用 <code>:</code> 连接符合并成一行，总共 10 行，所以你看到的就是一个无表头的 10 行 7 列数据，我们可以通过如下命令对表单进行整理：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat 1.txt | awk -F : <span class="string">' &#123; print $1, $2, $3, $4, $5, $6, $7 &#125; '</span></span><br></pre></td></tr></table></figure>
<p><code>-F</code> 是分隔符标识，默认 awk 命令以空格作为分隔符，在这个例子中，我们需要告诉程序 <code>:</code> 为列分隔符。这条命令执行的结果是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root x 0 0 root /root /bin/bash</span><br><span class="line">daemon x 1 1 daemon /usr/sbin /usr/sbin/nologin</span><br><span class="line">bin x 2 2 bin /bin /usr/sbin/nologin</span><br><span class="line">sys x 3 3 sys /dev /usr/sbin/nologin</span><br><span class="line">sync x 4 65534 sync /bin /bin/sync</span><br><span class="line">games x 5 60 games /usr/games /usr/sbin/nologin</span><br><span class="line">man x 6 12 man /var/cache/man /usr/sbin/nologin</span><br><span class="line">lp x 7 7 lp /var/spool/lpd /usr/sbin/nologin</span><br><span class="line">mail x 8 8 mail /var/mail /usr/sbin/nologin</span><br><span class="line">news x 9 9 news /var/spool/news /usr/sbin/nologin</span><br></pre></td></tr></table></figure>
<p><code>$0</code> 会打印整行数据，<code>$1</code> 表示第一列数据，同理，我们将七列数据都打印了出来，<code>$1</code> 到 <code>$7</code> 都是 <code>print</code> 函数的入参，事实上，它与这种写法是一个意思：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat 1.txt | awk -F : <span class="string">' &#123; print($1, $2, $3, $4, $5, $6, $7) &#125; '</span></span><br></pre></td></tr></table></figure>
<h3 id="添加表头"><a href="#添加表头" class="headerlink" title="添加表头"></a>添加表头</h3><p>由于我们提供的数据没有表头，我们给它加上：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat 1.txt | awk -F : <span class="string">' BEGIN &#123;\</span></span><br><span class="line"><span class="string">  print("No.", "R1", "R2", "R3", "R4", "R5", "R6", "R7")\</span></span><br><span class="line"><span class="string">&#125; &#123;\</span></span><br><span class="line"><span class="string">  print(NR, $1, $2, $3, $4, $5, $6, $7)\</span></span><br><span class="line"><span class="string">&#125; '</span></span><br></pre></td></tr></table></figure>
<p>在原来的基础上，我们增加了 <code>BEGIN { }</code> 段落，为此我们就给内容提供了表头：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">No. R1 R2 R3 R4 R5 R6 R7</span><br><span class="line">1 root x 0 0 root /root /bin/bash</span><br><span class="line">2 daemon x 1 1 daemon /usr/sbin /usr/sbin/nologin</span><br><span class="line">3 bin x 2 2 bin /bin /usr/sbin/nologin</span><br><span class="line">4 sys x 3 3 sys /dev /usr/sbin/nologin</span><br><span class="line">5 sync x 4 65534 sync /bin /bin/sync</span><br><span class="line">6 games x 5 60 games /usr/games /usr/sbin/nologin</span><br><span class="line">7 man x 6 12 man /var/cache/man /usr/sbin/nologin</span><br><span class="line">8 lp x 7 7 lp /var/spool/lpd /usr/sbin/nologin</span><br><span class="line">9 mail x 8 8 mail /var/mail /usr/sbin/nologin</span><br><span class="line">10 news x 9 9 news /var/spool/news /usr/sbin/nologin</span><br></pre></td></tr></table></figure>
<p><code>NR</code> 是行号的意思，为了让它好看一点，我们使用 <code>printf</code> 函数进行格式化打印：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat 1.txt | awk -F : <span class="string">' BEGIN &#123;\</span></span><br><span class="line"><span class="string">  printf("%8s %5s %5s %5s %5s %5s %15s %20s\n", "No.", "R1", "R2", "R3", "R4", "R5", "R6", "R7")\</span></span><br><span class="line"><span class="string">&#125; &#123;\</span></span><br><span class="line"><span class="string">  printf("%5s %8s %5s %5s %5s %5s %15s %20s\n", NR, $1, $2, $3, $4, $5, $6, $7)\</span></span><br><span class="line"><span class="string">&#125; '</span></span><br></pre></td></tr></table></figure>
<p>打印的结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  No.    R1    R2    R3    R4    R5              R6                   R7</span><br><span class="line"> 1     root     x     0     0  root           /root            /bin/bash</span><br><span class="line"> 2   daemon     x     1     1 daemon       /usr/sbin    /usr/sbin/nologin</span><br><span class="line"> 3      bin     x     2     2   bin            /bin    /usr/sbin/nologin</span><br><span class="line"> 4      sys     x     3     3   sys            /dev    /usr/sbin/nologin</span><br><span class="line"> 5     sync     x     4 65534  sync            /bin            /bin/sync</span><br><span class="line"> 6    games     x     5    60 games      /usr/games    /usr/sbin/nologin</span><br><span class="line"> 7      man     x     6    12   man  /var/cache/man    /usr/sbin/nologin</span><br><span class="line"> 8       lp     x     7     7    lp  /var/spool/lpd    /usr/sbin/nologin</span><br><span class="line"> 9     mail     x     8     8  mail       /var/mail    /usr/sbin/nologin</span><br><span class="line">10     news     x     9     9  news /var/spool/news    /usr/sbin/nologin</span><br></pre></td></tr></table></figure>
<p>怎么样，这个表单看起来就很自然了吧！</p>
<h3 id="表单筛选"><a href="#表单筛选" class="headerlink" title="表单筛选"></a>表单筛选</h3><p>想象一下，拿到手里的是一个 Excel 表格，我们要对表格进行分析，比如，我要隐藏 R2、R3、R4 这几栏，十分简单，打印的时候不写出来就行了，</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat 1.txt | awk -F : <span class="string">' BEGIN &#123;\</span></span><br><span class="line"><span class="string">  printf("%8s %5s %5s %15s %20s\n", "No.", "R1", "R5", "R6", "R7")\</span></span><br><span class="line"><span class="string">&#125; &#123;\</span></span><br><span class="line"><span class="string">  printf("%5s %5s %5s %15s %20s\n", NR, $1, $5, $6, $7)\</span></span><br><span class="line"><span class="string">&#125; '</span></span><br></pre></td></tr></table></figure>
<p>结果是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  No.    R1    R5              R6                   R7</span><br><span class="line"> 1  root  root           /root            /bin/bash</span><br><span class="line"> 2 daemon daemon       /usr/sbin    /usr/sbin/nologin</span><br><span class="line"> 3   bin   bin            /bin    /usr/sbin/nologin</span><br><span class="line"> 4   sys   sys            /dev    /usr/sbin/nologin</span><br><span class="line"> 5  sync  sync            /bin            /bin/sync</span><br><span class="line"> 6 games games      /usr/games    /usr/sbin/nologin</span><br><span class="line"> 7   man   man  /var/cache/man    /usr/sbin/nologin</span><br><span class="line"> 8    lp    lp  /var/spool/lpd    /usr/sbin/nologin</span><br><span class="line"> 9  mail  mail       /var/mail    /usr/sbin/nologin</span><br><span class="line">10  news  news /var/spool/news    /usr/sbin/nologin</span><br></pre></td></tr></table></figure>
<p>再比如，我们想拿到第六列包含 var 的内容，正则过滤下就行了</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat 1.txt | awk -F : <span class="string">' $6 ~ /var/ &#123;\</span></span><br><span class="line"><span class="string">  printf("%5s %5s %5s %15s %20s\n", NR, $1, $5, $6, $7)\</span></span><br><span class="line"><span class="string">&#125; '</span></span><br></pre></td></tr></table></figure>
<p>执行结果是：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"> 7   man   man  /var/cache/man    /usr/sbin/nologin</span><br><span class="line"> 8    lp    lp  /var/spool/lpd    /usr/sbin/nologin</span><br><span class="line"> 9  mail  mail       /var/mail    /usr/sbin/nologin</span><br><span class="line">10  news  news /var/spool/news    /usr/sbin/nologin</span><br></pre></td></tr></table></figure>
<p>再来个复杂点的，我们想拿到 R4 范围在 0~5，并且不包含 Root 的数据：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat 1.txt | awk -F : <span class="string">' $4 &gt;= 0 &amp;&amp; $4 &lt;= 5 &amp;&amp;\</span></span><br><span class="line"><span class="string">  $1 !~ /root/ &#123;\</span></span><br><span class="line"><span class="string">    printf("%5s %5s %5s %15s %20s\n", NR, $1, $5, $6, $7)\</span></span><br><span class="line"><span class="string">  &#125; '</span></span><br></pre></td></tr></table></figure>
<p>筛选结果出来了：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">2 daemon daemon       /usr/sbin    /usr/sbin/nologin</span><br><span class="line">3   bin   bin            /bin    /usr/sbin/nologin</span><br><span class="line">4   sys   sys            /dev    /usr/sbin/nologin</span><br></pre></td></tr></table></figure>
<p>相关的筛选功能还有很多，这里就不一一枚举了，上述几个筛选其实也已经可以满足大部分的条件了。</p>
<h3 id="增加表尾"><a href="#增加表尾" class="headerlink" title="增加表尾"></a>增加表尾</h3><p>我们想统计 R7 包含 <code>nologin</code> 信息的条目数量，展示在表尾，稍微复杂一点，这里会用到一点编程知识：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat 1.txt | awk -F : <span class="string">' BEGIN &#123;\</span></span><br><span class="line"><span class="string">  count = 0\</span></span><br><span class="line"><span class="string">&#125; &#123;\</span></span><br><span class="line"><span class="string">  if ($7 ~ /nologin/)&#123; count = count + 1; &#125;\</span></span><br><span class="line"><span class="string">  printf("%5s %8s %5s %5s %5s %5s %15s %20s\n", NR, $1, $2, $3, $4, $5, $6, $7)\</span></span><br><span class="line"><span class="string">&#125; END &#123;\</span></span><br><span class="line"><span class="string">  printf("total %s items with nologin", count)\</span></span><br><span class="line"><span class="string">&#125;'</span></span><br></pre></td></tr></table></figure>
<p>看到的结果是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    1     root     x     0     0  root           /root            /bin/bash</span><br><span class="line">    2   daemon     x     1     1 daemon       /usr/sbin    /usr/sbin/nologin</span><br><span class="line">    3      bin     x     2     2   bin            /bin    /usr/sbin/nologin</span><br><span class="line">    4      sys     x     3     3   sys            /dev    /usr/sbin/nologin</span><br><span class="line">    5     sync     x     4 65534  sync            /bin            /bin/sync</span><br><span class="line">    6    games     x     5    60 games      /usr/games    /usr/sbin/nologin</span><br><span class="line">    7      man     x     6    12   man  /var/cache/man    /usr/sbin/nologin</span><br><span class="line">    8       lp     x     7     7    lp  /var/spool/lpd    /usr/sbin/nologin</span><br><span class="line">    9     mail     x     8     8  mail       /var/mail    /usr/sbin/nologin</span><br><span class="line">   10     news     x     9     9  news /var/spool/news    /usr/sbin/nologin</span><br><span class="line">total 8 items with nologin</span><br></pre></td></tr></table></figure>
<p>结尾多了一行，我们来分析下这句命令，总共分为三段：</p>
<ul>
<li><code>BEGIN { count = 0 }</code>，声明计数器</li>
<li><code>{ if ($7 ~ /nologin/){ count = count + 1; } printf(...) }</code>，判断并计数</li>
<li><code>END { printf(&quot;total %s items with nologin&quot;, count)}</code>，打印结果</li>
</ul>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>以上，揭开了 awk 的面纱以后，你会发现它并没有那么复杂。当然，awk 也远不是上面我们看到的这么简单，它的使用可以变得非常复杂只不过在日常的运维过程中我们用不上而已。</p>
<p>把 awk 当做表单处理工具来理解，我相信你一定可以轻松记住它的所有命令，就算记不住，以后看到一长串命令也能够很快地理解它。更多资料可以看这个手册：<a href="http://www.gnu.org/software/gawk/manual/gawk.html" target="_blank" rel="noopener">The GNU Awk User’s Guide</a>。</p>
]]></content:encoded>
      <comments>https://yun.wztlink1013.com/blog/2019/10/29/awk/#comments</comments>
    </item>
    
    <item>
      <title><![CDATA[Git 约定式提交规范实践]]></title>
      <link>https://yun.wztlink1013.com/blog/2019/10/28/commit-convention/</link>
      <guid>https://yun.wztlink1013.com/blog/2019/10/28/commit-convention/</guid>
      <pubDate>Mon Oct 28 2019 15:14:00 GMT+0800 (GMT+08:00)</pubDate>
      <description>
      <![CDATA[小胡子哥的个人网站]]>
      
      </description>
      <content:encoded><![CDATA[<p><a href="https://www.conventionalcommits.org/en/v1.0.0/" target="_blank" rel="noopener">约定式提交规范</a> 提供了一个轻量级的提交历史编写规则，它的内容十分简单：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">&lt;<span class="keyword">type</span>&gt;[<span class="keyword">optional</span> scope]: &lt;description&gt;</span><br><span class="line"></span><br><span class="line">[<span class="keyword">optional</span> body]</span><br><span class="line"></span><br><span class="line">[<span class="keyword">optional</span> footer(s)]</span><br></pre></td></tr></table></figure>
<p>举个简单的例子：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">feat(config): 允许<span class="built_in"> config </span>对象直接从其他<span class="built_in"> config </span>继承</span><br><span class="line"></span><br><span class="line">BREAKING CHANGE: 在<span class="built_in"> config </span>对象中增加 `extends` 字段，用于从其他继承 config</span><br><span class="line"></span><br><span class="line">close issue #23</span><br></pre></td></tr></table></figure>
<p>在 git commit 时，如果你想进行多行 commit 编辑，可以通过 <code>git commit -a</code> 进入编辑界面；如果是单行，可以直接 <code>git commit -a -m &#39;COMMIT MESSAGE&#39;</code> 完成提交。</p>
<h3 id="更多的约定"><a href="#更多的约定" class="headerlink" title="更多的约定"></a>更多的约定</h3><p>约定式规范与 <a href="http://semver.org/" target="_blank" rel="noopener">SemVer</a> 的设计是相吻合的，</p>
<figure class="highlight elm"><table><tr><td class="code"><pre><span class="line"><span class="type">PATCH</span> -&gt; <span class="keyword">type</span>(fix)</span><br><span class="line"><span class="type">MINOR</span> -&gt; <span class="keyword">type</span>(feat)</span><br><span class="line"><span class="type">MAJOR</span> -&gt; <span class="type">BREAKING</span> <span class="type">CHNAGE</span></span><br></pre></td></tr></table></figure>
<p>大部分的提交中，我们都会使用 fix 和 feat 来描述本次修改的类型，当然也包含其他类型，如 <code>chore/docs/reflector/improvement/perf/test/style</code>，值得注意的是：</p>
<ul>
<li>一般不用写 <code>body</code> 部分的内容，除非存在 <code>BREAKING CHANGE</code></li>
<li><code>description</code> 的内容要相当简明扼要，用简单的语句把修改点直接说出来</li>
<li>一般不建议将多次修改放在一次提交中，尤其是一次半（第二个修改只完成了一部分）的情况</li>
<li><code>scope</code> 可以是一个文件的地址，如 <code>/lib/utils</code>；也可以是某个功能点 <code>parser</code>，不建议超过两个单词</li>
</ul>
<h3 id="一些技巧"><a href="#一些技巧" class="headerlink" title="一些技巧"></a>一些技巧</h3><p><strong>合并多次提交</strong></p>
<p>如果你上次修改的内容存在 bug 或未完成，本次提交的内容与上次几乎一样，建议使用 <code>git rebase -i</code> 进行提交的合并，如</p>
<figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">git rebase -i HEAD~<span class="number">3</span> # 展示最近 <span class="number">3</span> 次修改</span><br></pre></td></tr></table></figure>
<p>输出如下：</p>
<figure class="highlight gcode"><table><tr><td class="code"><pre><span class="line">pick <span class="number">0291959</span> chore<span class="comment">(blog)</span>: 清理无关项</span><br><span class="line">pick <span class="number">1</span>ef<span class="number">8</span>f<span class="number">31</span> chore<span class="comment">(blog)</span>: 清理无关项</span><br><span class="line">pick <span class="number">36</span>a<span class="number">91</span>db fix<span class="comment">(post)</span>: 格式化 post 的 meta 数据格式,增加 --- 开始符</span><br></pre></td></tr></table></figure>
<p>可以将第二行的 <code>pick</code> 修改为 <code>squash</code>，表示保留 commit 但将本次修改合并到上次，相关的操作可以看 <a href="https://www.barretlee.com/blog/2018/11/26/git-%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/" target="_blank" rel="noopener">这篇文章</a>。</p>
<p><strong>关闭 ISSUE</strong></p>
<p>在 github/gitlab 中，如果 commit message 中带有 <code>Fix #23</code> 诸如此类的信息，当 commit 被 push 到 repo 后，会自动关闭编号为 23 的 issue。</p>
<p><strong>自动生成 CHANGELOG</strong></p>
<p>在写日报或者周报，或者在项目发版时，我们可以很轻松地从提交日志中看到自己或者团队干了些什么事情：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">alias</span> git-changelog=<span class="string">'git log --oneline --decorate'</span>;</span><br></pre></td></tr></table></figure>
<p>当然也可以使用开源的工程自动生成结构化更强的 CHANGELOG 日志，如 <a href="https://github.com/CookPete/auto-changelog" target="_blank" rel="noopener">auto-changelog</a>，它提供了可自定义的 CHANGELOG 模板。</p>
<h3 id="项目配置"><a href="#项目配置" class="headerlink" title="项目配置"></a>项目配置</h3><p>约定如果没有工具来辅助和约束，大概率就成了一纸空文，毫无意义。在项目实战中，我们可以做如下配置让项目成员强制进行约定式提交。</p>
<p><strong>1. 安装工具</strong></p>
<p>推荐使用 <code>@commitlint/cli</code> 进行检测，安装方式：</p>
<figure class="highlight coffeescript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">npm</span> install @commitlint/cli --save-dev</span><br></pre></td></tr></table></figure>
<p><strong>2. 配置约定</strong></p>
<p>在 <code>@commitlint</code> 工具包中有一个规则比较强的检测规范：<code>@commitlint/config-conventional</code>，也安装到项目中：</p>
<figure class="highlight coffeescript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">npm</span> install @commitlint/config-conventional --save-dev</span><br></pre></td></tr></table></figure>
<p>安装完成后，需要显式地配置，在项目中增加 <code>commitlint.config.js</code>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123; </span><br><span class="line">  extends: [</span><br><span class="line">    <span class="string">'@commitlint/config-conventional'</span></span><br><span class="line">  ] </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>config-conventional</code> 中允许类型有 <code>build/chore/ci/docs/feat/fix/perf/refactor/revert/style/test</code>。</p>
<p><strong>3. 提交时执行检查</strong></p>
<p>推荐使用 <code>husky</code> 这个工具，它会帮助我们自动配置 commit hooks，只需在项目中添加 <code>.huskyrc.json</code> 文件：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"hooks"</span>: &#123;</span><br><span class="line">    <span class="attr">"pre-commit"</span>: <span class="string">"node ./node_modules/@commitlint/cli/lib/cli.js -E HUSKY_GIT_PARAMS"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然也可以直接在 package.json 中配置 <code>husky</code> 字段，具体可以查看 <a href="https://github.com/typicode/husky" target="_blank" rel="noopener">文档</a>。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>整洁的提交记录并不仅仅意味着开发者自动生成 CHANGELOG，遵守约定可以给项目沉淀一个结构化的提交历史，再加上一些 emoji，生成出来的文档简直就是一篇生动的项目发展史，它有助于我们向公众传达变化的性质，同时对继续集成也会带来一定的好处，比如我们可以根据 type 触发不同的构建和部署流程。</p>
]]></content:encoded>
      <comments>https://yun.wztlink1013.com/blog/2019/10/28/commit-convention/#comments</comments>
    </item>
    
    <item>
      <title><![CDATA[本博客的配置和发布]]></title>
      <link>https://yun.wztlink1013.com/blog/2019/10/27/blog-config/</link>
      <guid>https://yun.wztlink1013.com/blog/2019/10/27/blog-config/</guid>
      <pubDate>Sun Oct 27 2019 23:54:00 GMT+0800 (GMT+08:00)</pubDate>
      <description>
      <![CDATA[小胡子哥的个人网站]]>
      
      </description>
      <content:encoded><![CDATA[<p>分享下我个人博客（<a href="https://www.barretlee.com" target="_blank" rel="noopener">https://www.barretlee.com</a>）的配置和发布：</p>
<h3 id="1-域名"><a href="#1-域名" class="headerlink" title="1. 域名"></a>1. 域名</h3><p>在 DNSPod 上配置的域名，默认解析到 coding pages，国外解析到 github pages，DNSPod 支持 D 监控，当域名不可用时会邮件警报。</p>
<p>coding 支持绑定多个域名，也支持给所有绑定的域名自动配置证书，github 只能绑定一个域名，这就会导致 <a href="http://www.barretlee.com" target="_blank" rel="noopener">www.barretlee.com</a> 和 barretlee.com 只能有一个是 https，比较坑，貌似 Google 的 DNS 解析服务能够解决这个问题，国内的似乎都不行。</p>
<h3 id="2-开发"><a href="#2-开发" class="headerlink" title="2. 开发"></a>2. 开发</h3><p>使用 hexo 构建，由于文章比较多，超过 300 篇，构建时长约 6min，很慢；hexo 支持多 git 仓库部署，我配置了 coding 和 github 两个。</p>
<p>使用了不少 hexo 的插件，但是很多都不满足需求，不满足需求的插件都重新改写了。平时使用改写的 hexo-admin 在本地编辑内容。</p>
<p><img src="http://www.barretlee.com/blogimgs/2019/10/27/blog-config-admin.png" alt="blog config admin"></p>
<h3 id="3-部署"><a href="#3-部署" class="headerlink" title="3. 部署"></a>3. 部署</h3><p>以前每次都是本地编辑文章，然后构建发布，发现错别字，又回到本地编辑、构建、发布，体验十分差，所以近两年都懒得写文章了，宁愿发长微博。</p>
<p>本周末折腾了一番，接入了 travis-ci，发现还挺好用，只是配置的时候需要注意点 git 仓库权限问题，可以参考 <a href="https://github.com/barretlee/blog/blob/master/.travis.yml" target="_blank" rel="noopener">https://github.com/barretlee/blog/blob/master/.travis.yml</a> 解决问题，后续写文章应该会直接走 github 网页新建文件。</p>
<p><img src="http://www.barretlee.com/blogimgs/2019/10/27/blog-config-travis.png" alt="blog config travis"></p>
<h3 id="4-评论"><a href="#4-评论" class="headerlink" title="4. 评论"></a>4. 评论</h3><p>从多说到畅言到 github issue，估计不会再继续折腾了，看了两个开源的 github issue 评论组件，gitment 和 gitalk ，这两个工具都有点像半成品，感觉还有很大的优化空间，由于 gitalk UI 稍微看得舒服点，将就着用了，效果如图四。历史评论就懒得迁移了。</p>
<p><img src="http://www.barretlee.com/blogimgs/2019/10/27/blog-config-comment.png" alt="blog config comment"></p>
<p>周末把博客 UI 的部分细节做了调整，估计后续三五年都不会再折腾博客设计了。</p>
]]></content:encoded>
      <comments>https://yun.wztlink1013.com/blog/2019/10/27/blog-config/#comments</comments>
    </item>
    
    <item>
      <title><![CDATA[让 VSCode 在本地 Run 起来]]></title>
      <link>https://yun.wztlink1013.com/blog/2019/10/23/vscode-study-01-start/</link>
      <guid>https://yun.wztlink1013.com/blog/2019/10/23/vscode-study-01-start/</guid>
      <pubDate>Wed Oct 23 2019 19:38:00 GMT+0800 (GMT+08:00)</pubDate>
      <description>
      <![CDATA[小胡子哥的个人网站]]>
      
      </description>
      <content:encoded><![CDATA[<p>Visual Studio Code 是微软推出的一款轻量级编辑器，与它一起在市场争锋的相似软件还有 Atom 和 Sublime Text，面世第二年的它只占据 7% 左右的市场，后来在短短三年时间雄踞了半壁江山，不可谓不哇塞。</p>
<p><img src="http://www.barretlee.com/blogimgs/2019/10/23/vscode-snapshot.png" alt="vscode-snapshot"></p>
<p>发育如此强势的软件，背后到底是如何设计的，未来一段时间，我将带着你一点一点拨开她的面纱，再撩开她的裙摆。</p>
<h3 id="下载源码"><a href="#下载源码" class="headerlink" title="下载源码"></a>下载源码</h3><p>Visual Studio Code 简称 VSCode，需要注意的是，平时我们使用的 VSCode 那是产品，而下面我们要介绍的是源码，产品是源码的构建结果；源码使用的 <a href="https://github.com/microsoft/vscode/blob/master/LICENSE.txt" target="_blank" rel="noopener">MIT License</a>，而产品使用的是这个 <a href="https://code.visualstudio.com/License" target="_blank" rel="noopener">MICROSOFT SOFTWARE LICENSE TERMS</a>，如果你想把 VSCode 用于商用，建议从源码构建出新的产品，而不是直接使用人家官网上提供下载链接的 VSCode Product。</p>
<ul>
<li>官网地址是 <a href="https://code.visualstudio.com/" target="_blank" rel="noopener">https://code.visualstudio.com/</a></li>
<li>源码在这里：<a href="https://github.com/microsoft/vscode" target="_blank" rel="noopener">https://github.com/microsoft/vscode</a>。</li>
</ul>
<p>我们先把源码 down 下来：</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">git <span class="keyword">clone</span> <span class="title">--depth</span> <span class="number">1</span> https://github.com/microsoft/vscode.git</span><br></pre></td></tr></table></figure>
<p>由于 VSCode 项目过于活跃，提交量非常庞大，到目前为止，已经有 <code>56,092</code> 次提交了，建议在下载源码的时候加了一句 <code>--depth 1</code>，意思就是只现在最近一次 commit 的代码。</p>
<p>30s 后……71M，不慢。</p>
<h3 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h3><p>在安装依赖之前，我们不妨稍微分析下 VSCode 的项目结构，</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  vscode (master) tree -L 1</span><br><span class="line">.</span><br><span class="line">├── CONTRIBUTING.md</span><br><span class="line">├── LICENSE.txt</span><br><span class="line">├── README.md</span><br><span class="line">├── ThirdPartyNotices.txt</span><br><span class="line">├── azure-pipelines.yml</span><br><span class="line">├── build/</span><br><span class="line">├── cglicenses.json</span><br><span class="line">├── cgmanifest.json</span><br><span class="line">├── extensions/</span><br><span class="line">├── gulpfile.js</span><br><span class="line">├── package.json</span><br><span class="line">├── product.json</span><br><span class="line">├── remote/</span><br><span class="line">├── resources/</span><br><span class="line">├── scripts/</span><br><span class="line">├── src/</span><br><span class="line">├── <span class="built_in">test</span>/</span><br><span class="line">├── tsfmt.json</span><br><span class="line">├── tslint.json</span><br><span class="line">└── yarn.lock</span><br></pre></td></tr></table></figure>
<p>未来我们需要重点关注的是 <code>src/</code> 和 <code>extensions/</code> 两个目录，前者放的是 VSCode 的核心源码，后者放的是 VSCode 的内置插件。</p>
<p>眼神再晃动一下，应该还会看到几个熟悉的关键词，<code>build/</code>,<code>gulpfile.js</code>,<code>package.json</code>,<code>tslint.json</code> 和 <code>yarn.lock</code>，由此，我们基本可以断定，这个仓库是一个用 TypeScript 开发，用 yarn 管理依赖，用 gulp 进行打包的 Node.js 项目，事实上她也是一个 <a href="https://electronjs.org/" target="_blank" rel="noopener">Electron</a> 项目。</p>
<p>好了，目录就看到这里，接着开始安装漫长的依赖安装：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  vscode (master) yarn</span><br></pre></td></tr></table></figure>
<p>执行 yarn 后，VSCode 会干三件事情：</p>
<ul>
<li>preinstall 脚本中对 yarn 的版本做判断<ul>
<li>要求必须 &gt;=1.10.1</li>
<li>并且只允许使用 yarn 来安装依赖，npm 安装会弹个错误</li>
</ul>
</li>
<li>安装 package.json 中描述的各个依赖<ul>
<li>很多依赖都需要重新编译，而编译过程经常会失败</li>
<li>失败了怎么办？看错误提示，如果流程没中断，就让它一直跑下去</li>
<li>一直卡着，好像不跑了怎么办？<code>ctrl-c</code> 终止进程后重新执行 <code>yarn</code></li>
</ul>
</li>
<li>postinstall 挨个安装 build/remote/test/extensions 等目录中的依赖<ul>
<li>extension 的安装比较特殊，安装的过程中又会执行 <code>updateGrammar</code> 脚本</li>
</ul>
</li>
</ul>
<p>整个安装过程十分的慢，可以考虑泡杯咖啡打开电视剧……   </p>
<p>执行了 yarn 整个安装并没有结束，剩下几步 VSCode 会在你执行 gulp 相关脚本的时候做检测，倘若资源不存在便会安装，由于很多资源都在墙外，我们还是分解下动作，分步手动下载：</p>
<p><strong>1. 把 Electron 安装下来：</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  vscode (master) yarn electron</span><br></pre></td></tr></table></figure>
<p>如果下载太慢，建议在命令行开下代理：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  vscode (master) proxychains4 yarn electron</span><br></pre></td></tr></table></figure>
<p>这里附加一个小插曲，</p>
<blockquote>
<p>安装到半途时更换了下代理，应该是 gulp-vinyl-zip 这个包处理 buffer 异常，导致下次下载断点续传 buffer 位置对不上，然后每次执行 yarn electron 就直接退出进程，应该是个 bug；解决办法是，在这个包的 <code>open()</code> 方法里打个 log，把 path 打印出来，然后把打印出来的资源删掉就行了。</p>
</blockquote>
<p>一小时后……</p>
<p>我已经不能忍了，电视剧都看了一集了，还是没下载完，其实 <code>electron-v6.0.12-darwin-x64</code> 这个文件只有 66.2M。</p>
<p>为了完成 electron 的安装，不得不附加第二个插曲，</p>
<blockquote>
<p>还是得翻源码解决问题：之前可以通过全局配置 ELECTRON_MIRROR 的地址来选择 Electron 下载源，而最新版 VSCode 的 Electron 是直接从 github 上下载的，从 gulp-atom-electron 这个包的源码里断点找到了 asset 和 assetPath，手动将 asset 下载下来后放到 assetPath，解决了问题。</p>
</blockquote>
<p><strong>2. 把内置的几个依赖插件安装下来：</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  vscode (master) yarn download-builtin-extensions</span><br></pre></td></tr></table></figure>
<p>历时差不多一个小时，终于把依赖下载完成了，这是我安装依赖花的时间最长的一次，家里的网络还是比不上厂里自带翻墙功能的网络，衰……</p>
<h3 id="构建程序"><a href="#构建程序" class="headerlink" title="构建程序"></a>构建程序</h3><p>由于启动一次构建花费的时间太长，1~5min 不等（看机器性能和人品），所以我建议你使用 <code>yarn watch</code> 来构建，它会完成一次构建并监听文件的变化，后续不用重新构建。</p>
<p>构建完成以后，就可以执行命令打开 VSCode 的界面了，不过在打开之前，我意外地在 package.json 的 scripts 中发现，VSCode 竟然已经有 Web 版本了！！！</p>
<p><img src="http://www.barretlee.com/blogimgs/2019/10/23/vscode-web.png" alt="VSCode Web"></p>
<p>这比我之前的预期要早了很多，很早就听说他们内部团队在搞 Web 版本了，没想到这么快就要面世了。社区上有一个基于 VSCode 搞的 Web 版，叫 <a href="https://github.com/cdr/code-server" target="_blank" rel="noopener">Code-Server</a>，Star 量有好几万，估计官方的 Web 版出来以后，code-server 就要凉凉了。</p>
<p>哦，把 web 版本跑起来的方式是：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># gulp watch 完成后执行</span></span><br><span class="line">➜  vscode (master) yarn web</span><br></pre></td></tr></table></figure>
<p>会自动弹开一个地址：<a href="http://localhost:8080/" target="_blank" rel="noopener">http://localhost:8080/</a>，目前 Web 版的功能还不完备，比如插件部分就没有适配，应该还在研发状态，连 inside 版本都没进。这也算是我写这个教程的第一个意外惊喜吧，看来我得重新研究下 VSCode 的源码了。</p>
<p>执行如下脚本，可以打开 VSCode 的客户端：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  vscode (master) ./scripts/code.sh</span><br></pre></td></tr></table></figure>
<p>然后你就可以看到这样的界面了：</p>
<p><img src="http://www.barretlee.com/blogimgs/2019/10/23/vscode-client.png" alt="VSCode Client"></p>
<p>如果你是 windows 系统，执行的脚本应该是 <code>./script/code.bat</code>。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>好了，本文的扫盲就到这里。</p>
<p>本文主要通过傻瓜式地教学，给大家演示了下，如何将源码变成我们熟悉的 VSCode 客户端，相信同学们在动手的过程中还会遇到各种依赖安装问题，不要灰心，实在不行就 <code>rm -rf node_modules</code>，然后重试。</p>
<p>下回再给大家讲述 <a href="https://www.barretlee.com/blog/2019/11/01/vscode-study-02-debugging/" target="_blank" rel="noopener">如何开发和调试 VSCode 的源码</a>。</p>
]]></content:encoded>
      <comments>https://yun.wztlink1013.com/blog/2019/10/23/vscode-study-01-start/#comments</comments>
    </item>
    
    <item>
      <title><![CDATA[VSCode 是怎么运行起来的？]]></title>
      <link>https://yun.wztlink1013.com/blog/2019/08/03/vscode-source-code-reading-notes/</link>
      <guid>https://yun.wztlink1013.com/blog/2019/08/03/vscode-source-code-reading-notes/</guid>
      <pubDate>Sat Aug 03 2019 23:52:00 GMT+0800 (GMT+08:00)</pubDate>
      <description>
      <![CDATA[小胡子哥的个人网站]]>
      
      </description>
      <content:encoded><![CDATA[<p>之前有基于 VSCode 做二次开发的经验，约摸全投入持续了 5 个多月，开发了一个 <a href="https://isv.taobao.com/ide" target="_blank" rel="noopener">Editor</a>，算是超级魔改吧，虽然保留了 VSCode 的样子，但是整个板块都有比较大的调整，新增了 Webview 预览面板、Devtool 调试工具、顶部控制区、插件市场等等。</p>
<p>当时由于需求的实现不需要了解全部的 VSCode 源码，但是也把大部分的源码啃得差不多了，包括：</p>
<ul>
<li>整个项目的工程部分，包括项目结构、软件构建、插件构建、持续集成等等</li>
<li>Workbench 部分的所有逻辑，整个窗体 UI 部分的实现</li>
<li>插件的实现，插件市场的逻辑，当时单独做了一个新的插件市场体系，插件的下载在自己的服务器管理</li>
<li>Language Service Protocol 的基本原理</li>
</ul>
<p>但是也有很多内容没有掌握，应该说没有太多兴趣和时间了解，包括：</p>
<ul>
<li>功能模块的测试和 UI 自动化测试</li>
<li>CommandRegistry 的内部机制，对应的是 IPCServer 的交互逻辑</li>
<li>IoC 实现的详细逻辑</li>
<li>SharedProcess 的基础逻辑</li>
<li>ExtensionHost 的运行机制</li>
</ul>
<p>这两天突然来了兴致，把之前没了解的部分源码通读了一遍，当然，仍然有一些疑惑，也仍然有一些不感兴趣的部分，后续空了会有更多的梳理，下面先贴上这两天的阅读笔记。其实我应该画图来帮助读者理解，不过以下主要是个人笔记，就懒得整理了，感兴趣的读者将就着看。</p>
<blockquote>
<p>阅读的版本是 <code>v1.37.0</code>，是目前 VSCode 源码仓库 master 分支最新的代码。</p>
</blockquote>
<h3 id="InstantiationService"><a href="#InstantiationService" class="headerlink" title="InstantiationService"></a>InstantiationService</h3><p>基本就是 IoC 的实现原理，以及 Service 的全局管理机制。</p>
<h4 id="服务注册为可被使用的-Decorator"><a href="#服务注册为可被使用的-Decorator" class="headerlink" title="服务注册为可被使用的 Decorator"></a>服务注册为可被使用的 Decorator</h4><p>提供了一个泛型装饰器 <code>createDecorator</code>，入参是 ServiceName 和 IService，后者是泛型入参：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createDecorator</span>&lt;<span class="title">IService</span>&gt;(<span class="params">'service'</span>): <span class="title">ServiceIdentifier</span>&lt;<span class="title">IService</span>&gt; </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>内部对 <code>service</code> 的实际处理是：</p>
<ul>
<li>记录，下次请求，若存在直接从缓存送出</li>
<li>记录的方式是：生成一个装饰器，装饰器的作用只判断入参是否是一个 <code>parameter</code>，意思是在类中 <code>method</code> 不允许被它装饰；并将装饰器的 toString 函数置为 <code>service</code> 这个 String</li>
</ul>
<p>返回的 <code>ServiceIdentifier</code>，格式为：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> ServiceIdentifier&lt;T&gt; &#123;</span><br><span class="line">    (...args: <span class="built_in">any</span>[]): <span class="built_in">void</span>;</span><br><span class="line">    <span class="keyword">type</span>: T;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="全局服务管理"><a href="#全局服务管理" class="headerlink" title="全局服务管理"></a>全局服务管理</h4><ul>
<li>注册一个管理服务的容器 <code>ServiceCollection</code>，它是一个 Map 类型，储存格式为：<code>&lt;ServiceIdentifier, instanceOrDescriptor&gt;[]</code></li>
<li>然后将服务容器挂在到全局 <code>instantiationService</code> 服务上，实际上是挂在 <code>instantiationService</code> 的私有成员变量 <code>_services</code> 上</li>
<li>同时也通过 <code>this._services.set(IInstantiationService, this)</code> 把自己装进了服务容器</li>
</ul>
<h4 id="服务的调用"><a href="#服务的调用" class="headerlink" title="服务的调用"></a>服务的调用</h4><ul>
<li>提供了一个 <code>Trace</code> 方法，记录了每次调用的耗时</li>
<li><strong>此处看的比较粗糙，InstantiationService.invokeFunction</strong>，通过分析 Service 的依赖，把所有的依赖项目都加载进来</li>
<li>其中考虑到了循环依赖的问题，直接报错，检测方式是递归查询深度超过 100</li>
<li>最终通过 <code>IdleValue</code> 类返回了一个 Proxy 对象，只有真正用到的时候才执行返回服务实例</li>
</ul>
<h3 id="入口分析"><a href="#入口分析" class="headerlink" title="入口分析"></a>入口分析</h3><p>看看 VSCode 在启动前和启动时都做了哪些事情。</p>
<h4 id="Code-Application-启动之前"><a href="#Code-Application-启动之前" class="headerlink" title="Code Application 启动之前"></a>Code Application 启动之前</h4><p>VSCode 的入口启动文件是 <code>./out/main.js</code>，对应源文件目录是 <code>./src/vs/main.ts</code>。</p>
<ul>
<li><code>vs/base/common/performance</code>，通过数组记录，每两项为一个数据单元，<code>[name, timestamp, ...]</code>，兼容 amd/cmd</li>
<li><code>vs/base/node/languagePacks</code>，将大量 fs 操作 Promise 化后，提供一个查、写 <code>NLSConfiguration</code> 的方法，兼容 amd/cmd</li>
<li><code>./bootstrap</code><ul>
<li><code>injectNodeModuleLookupPath</code>，注入一个 node_modules 的查询路径</li>
<li><code>enableASARSupport</code>，同上，注入 <code>.asar</code> 路径</li>
<li><code>uriFromPath</code>，一个兼容 win/mac 的将 path 路径转换成磁盘 uri 的方法</li>
</ul>
</li>
<li>AMD 方式加载入口文件<ul>
<li><code>./bootstrap-amd</code><ul>
<li>AMD Loader 配置，<code>github:Microsoft/vscode-loader</code>,</li>
<li>将 Electron 的 fs 替换成 Node 原生的 fs</li>
</ul>
</li>
<li><code>vs/code/electron-main/main</code><ul>
<li><code>main</code><ul>
<li><code>setUnexpectedErrorHandler</code>，避免 Electron 底层报错，上层进行劫持</li>
<li><code>validatePaths</code> 入参验证</li>
</ul>
</li>
<li><code>startup -&gt; createServices,doStartup</code><ul>
<li>初始化一个日志服务，<code>bufferLogService</code></li>
<li>初始化两个重要的服务：<code>instantiationService, instanceEnvironment</code><ul>
<li>通过 <code>ServiceCollection</code> 记录所有注册的服务，它是一个单纯的 Map，记录的是 <code>&lt;ServiceIdentifier, instanceOrDescriptor&gt;[]</code></li>
<li>初始化的服务包括：<code>environmentService/logService/configurationService/lifecycleService/stateService/requestService/themeMainService/signService</code></li>
<li>将 <code>ServiceCollection</code> 挂载到 <code>instantiationService</code>，作为 <code>_services</code> 私有成员</li>
<li>同时将 <code>instantiationService</code> 挂在到 <code>_services</code> 私有成员上，相当于依然使用 <code>ServiceCollection</code> 管理</li>
</ul>
</li>
<li>完成 <code>environmentService/configurationService/stateService</code> 的初始化</li>
<li>初始化 <code>mainIpcServer</code>，并连接 <code>sharedIpcServer</code><ul>
<li>创建一个 <code>mainIpcServer</code>，入参是 <code>environmentService</code> 中记录的 <code>mainIPCHandle</code> 地址</li>
<li>如果创建失败，非 <code>EADDRINUSE</code> 错误，检查是否已经存在了一个 IPCHandler，如果存在则直接连接，连接失败会重试 1 次</li>
</ul>
</li>
<li>初始化 <strong>CodeApplication</strong>，将 mainIpcServer 和 instanceEnvironment 作为依赖服务挂载上去</li>
<li>调用 CodeApplication 的 <code>startup</code> 方法启动</li>
</ul>
</li>
<li>过程中如果有报错，则直接退出</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="Code-Application-启动"><a href="#Code-Application-启动" class="headerlink" title="Code Application 启动"></a>Code Application 启动</h4><p>入口文件是 <code>./src/vs/code/electron-main/app.ts</code>，对应的类为 <code>CodeApplication</code>，实例化的时候做了两件事情</p>
<ul>
<li>注册一些与 Electron 相关的事件，大多都是禁用一些底层、涉及安全或影响 VSCode 上层交互的事件</li>
<li>执行 <code>startup</code> 启动<ul>
<li>启动一个 <code>ElectronIPCServer</code><ul>
<li>通过 <code>ipcMain</code> 监听 <code>ipc:hello</code> 事件，通过 <code>webContents.id</code> 标记 Client 身份 </li>
<li>每次有一个新的 Client 进来都开始监听 <code>ipc:message</code> 和 <code>ipc:disconnect</code> 事件</li>
</ul>
</li>
<li>获取 MachineId（其实就是 Mac Address 的 hash 处理，降级方案是 uuid），启动一个 <code>SharedProcess</code><ul>
<li>创建一个不展示（show: false）的 <code>BrowserWindow</code>，启用了 <code>nodeIntegration</code></li>
<li>加载 <code>vs/code/electron-browser/sharedProcess/sharedProcess.html?config=${config}</code>，通过 url 传参</li>
<li>新 BrowserWindow 的 ipcRenderer 与 ipcMain 进行三次握手<ul>
<li>ipcMain 将 <code>sharedIPCHandle</code> 的值传递给 <code>SharedProcess</code></li>
<li><code>SharedProcess</code> 创建一个 IPCServer</li>
<li>通过一个新的 CollectionService 生成服务容器，将各种服务通过新注册的 ipc channel 对接到 <code>IPCServer</code></li>
</ul>
</li>
<li><code>MainProcess</code> 连接到 <code>SharedProcess</code> 的 IPCServer</li>
</ul>
</li>
<li>将 Application 的附加 Service 作为 childService 添加到全局 <code>CollectionService</code> 容器</li>
<li><strong>这里没看太懂</strong>，如果存在 <code>driverHandle</code>，则新建一个 Dirver 的 IPCServer</li>
<li><strong>这里没看太懂</strong>，注入了一个 <code>ProxyAuth</code> 模块，不知道哪里会用到，内容很简单，就是一个输入账号密码的 <code>BrowserWindow</code> 弹窗</li>
<li>然后调用 <code>openFirstWindow</code> 打开 VSCode 主界面<ul>
<li>注册了主进程 IPC 服务：<code>launchService</code></li>
<li>注册了 Electron IPC 服务：<code>updateChannel/issueChannel/workspaceChannel/windowsChannel/menubarChannel/urlChannel/storageChannel</code> 等</li>
<li>通过 <code>windowsMainService(windowManager)</code> 打开界面</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="MainIpcServer"><a href="#MainIpcServer" class="headerlink" title="MainIpcServer"></a>MainIpcServer</h3><p>IPCServer 的大致原理，细节非常多，下面只是列了提纲，主要是实现了一套序列化和反序列化的协议，以及 <code>call</code> 调用和 <code>listen</code> 监听的两大逻辑。</p>
<h4 id="创建-Server"><a href="#创建-Server" class="headerlink" title="创建 Server"></a>创建 Server</h4><ul>
<li>建立 <code>net server</code>，通过 <code>mainIPCHandle</code> 文件句柄进行监听</li>
<li>基于 <code>netSocket</code> 封装了 <code>NodeSocket</code>，并绑定了通讯协议 <code>Protocol</code></li>
<li>创建失败，说明 socket 已经存在，直接连接 Server</li>
</ul>
<figure class="highlight gherkin"><table><tr><td class="code"><pre><span class="line">/-------------------------------|<span class="string">------\</span></span><br><span class="line">|<span class="string">             HEADER            </span>|<span class="string">      </span>|</span><br><span class="line">|<span class="string">-------------------------------</span>|<span class="string"> DATA </span>|</span><br><span class="line">|<span class="string"> TYPE </span>|<span class="string"> ID </span>|<span class="string"> ACK </span>|<span class="string"> DATA_LENGTH </span>|<span class="string">      </span>|</span><br><span class="line">\-------------------------------|<span class="string">------/</span></span><br></pre></td></tr></table></figure>
<h4 id="连接-Server"><a href="#连接-Server" class="headerlink" title="连接 Server"></a>连接 Server</h4><ul>
<li>连接到 <code>net socket</code> 后，将 <code>netSocket</code> 同上包装两层，<code>NodeSocket + Protocol</code></li>
<li>指定 <code>ctx</code> 为 <code>main</code>，创建 <code>IPCClient</code>，<code>IPCClient</code> 既是一个  <code>client</code> 也是一个 <code>server</code>，共享一个 socket，通过 Protocol 协议进行通讯<ul>
<li>创建 <code>ChannelClient</code>，维护一个通讯的 handlers 管理器<ul>
<li>发起一个远程命令执行请求，将 <code>requestId</code> 和 <code>responseHandler</code> 写入管理器，通过 <code>protocal.send</code> 将请求发出</li>
<li>监听 <code>protocal.onMessage</code>，通过 <code>requestId</code> 匹配 <code>responseHandler</code> 处理结果</li>
</ul>
</li>
<li>创建 <code>ChannelServer</code>，指定 ctx 为 <code>main</code>（写入 ctx 的值）<ul>
<li>通过 <code>onRawMessage</code> 监听消息，解析 header 和 body 后，选择对应的 <code>channel</code>，执行 <code>channel.call</code>，执行结果通过 <code>protocal.send</code> 返回</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>以上的分析过程，对读者的作用可能并不大，主要是逻辑过于冗长，防止自己读着读着开始迷失，把觉得比较核心的逻辑记录了下来。</p>
<p>如果读者想了解 VSCode 的全盘代码，有几处是必须全部理解的：</p>
<ol>
<li>InstantiationService 设计</li>
<li>IPC Protocol 设计</li>
<li>ExtensionHost 设计</li>
<li>Workbench Layout 设计</li>
<li>VSCode 的打包机制</li>
<li>Electron 的几乎所有 API</li>
</ol>
<p>后续空闲，我还会结合单测和自动化测试，熟悉 VSCode 整体架构，等有了内容再来分享。</p>
]]></content:encoded>
      <comments>https://yun.wztlink1013.com/blog/2019/08/03/vscode-source-code-reading-notes/#comments</comments>
    </item>
    
    <item>
      <title><![CDATA[两个月减 10kg，聊聊这件事]]></title>
      <link>https://yun.wztlink1013.com/blog/2019/07/28/my-way-to-lose-weight/</link>
      <guid>https://yun.wztlink1013.com/blog/2019/07/28/my-way-to-lose-weight/</guid>
      <pubDate>Sun Jul 28 2019 00:16:00 GMT+0800 (GMT+08:00)</pubDate>
      <description>
      <![CDATA[小胡子哥的个人网站]]>
      
      </description>
      <content:encoded><![CDATA[<p>还记得刚进大学的时候也就 120 斤，那会儿还不到 18 岁，身体处于自然增长阶段，可能与生活不规律有点关系吧，四年下来，增重也有 25 斤，一米七四的个头，倒也显得还好，不胖不瘦。</p>
<p>毕业的随后四年里，依旧保持着极度不良好的生活作息和饮食习惯，体重一路飙升到 167 斤，肚子和脸蛋都开始圆了起来，因此也有了我常年使用的圆咕噜嘟的头像。</p>
<p>说起 <a href="/blogimgs/avatar.png">我的头像</a>，大概是三年多前，淘宝绘画兴趣小组的一次绘画课程中，我作为模特，同事亚城帮我绘制的，其实是个半成品，很多细节还没有处理完（那堂课只教这么多，囧），不过因为画得实在是贴切，就求了版权，拿了过来。当时的脸并没有画中那么胖，毕竟卡通人物的绘制都会适当加点夸张手法，<strong>但随着时间的推移，脸型越来越接近这张图像……</strong></p>
<h3 id="一个念头"><a href="#一个念头" class="headerlink" title="一个念头"></a>一个念头</h3><p>估计是因为大块的肥肉藏在了肚子和内脏里，165+ 的体重倒也没有显得特别胖，可带来的各种问题就多了，</p>
<ul>
<li>首先是身体上的问题，经常这儿有点疼，那儿有点痛，血压偏高，稍微运动心跳特别快，胡吃海喝，也特别容易油腻；</li>
<li>更麻烦的是心理上的问题，<strong>整个人就跟得了懒癌一样</strong>，周末不想动，能不走路的不走路，能不起身的不起身，由于这种心态，很多事情也会拖拖拉拉，感觉整个人都在与内心仅剩的那点斗志抗争。</li>
</ul>
<p>对于一个胖子而言，三天两头就会蹦出减肥的念头。但是，你应该能懂的，什么节食啊、健身啊，那都是三天打鱼两天晒网，哦，不，应该是三十天晒网。少吃东西带来的饥饿感，以及健身的痛苦感，让我无数次地轻松说服自己，“别减啦！”，每次说服都那么的管用……</p>
<p>每每看见身边有人减肥成功都赞叹不已，心中也会不禁感叹，“此人必是个狠角色！”，而把竖起的大拇指收回的那一瞬间，减肥的念头也便跟着一起散去了。毕竟，身上掉几十斤肉是我连想都不敢想的事情，那该是多大的痛苦呀！直到参加了上次团队安排的 <a href="/blog/2019/05/29/traveling-in-the-desert/">内蒙古沙漠之旅</a> ……</p>
<p>在沙漠徒步闲聊的时候，了解到身边有一个小伙伴，最近正在减肥，而且效果十分明显，已经掉了 30 斤了，我问他，你每天都去健身运动么？他说，一周也就一两回，不过吃草倒是吃了好几个月了。看着他在沙漠中只身穿行毫不喘气的身影，再看看一身装备的自己，却还像条狼狈的胖犬，耷拉着舌头，大口地呼吸着炙热的空气，心想，“要不咱也瘦一回试试？”</p>
<p>团建结束第二天，发了一条朋友圈，立下了一个 Flag，目标瘦身 10kg。与往常不一样的是，执行时间不是从明天开始，而是<strong>「今天」</strong>。</p>
<h3 id="两个月，10kg"><a href="#两个月，10kg" class="headerlink" title="两个月，10kg"></a>两个月，10kg</h3><p>那段时间的体重在 163~167 之间波动，权且就把 165 当做了起点，目标瞄准 145，回到离开校园时的水位。</p>
<p>减肥这件事情，倒不是一点经验都没有，曾几何时也是跟着身边的胖子们一起减过的，只不过没能坚持下去，这一次权且把自己的身体当作试验品，一点一点的尝试之前试过的、听过的、看过的一些方子，慢慢找到自己比较能接受的减肥方案。</p>
<h4 id="阻力"><a href="#阻力" class="headerlink" title="阻力"></a>阻力</h4><p>减肥的时候有三件事情绝不能在我身上发生，否则大概率坚持不下去，估计大部分胖子都是如此：</p>
<p><strong>1、不能饿着</strong></p>
<p>饥饿带来的痛苦感，加上美食带来的诱惑，绝对可以摧毁一个胖子减肥的决心，所以饿肯定是不行的，当然我也尝试过保持饥饿，结果就是一天下来整个人昏昏沉沉的，不仅办事效率下去了，体重的变化还不明显，最重要的是，这个法子没法在第二天坚持下去，因为实在是坚持不下去=。 =</p>
<p><strong>2、不能运动太多</strong></p>
<p>强运动是一件特别不靠谱的事情，内心触动的时候能够坚持一两天，等到意志略微消沉断了一天，那第二天也没便啥心思运动了，往后几天也因为第二天的不坚持直接破罐子破摔了……另外，如果不控制饮食，即便连续运动一两周效果也不会明显，最后剩下的也只有绝望和放弃了。</p>
<p><strong>3、不能准备太多</strong></p>
<p>前期减肥，重点还是要管住嘴，七分靠吃三分靠练，但是如果吃的东西准备的太复杂，或者准备需要花费的时间太多，那肯定也是没办法坚持下去的。试想一下，早上起床以后（甚至提前一天）还得跑去厨房准备各种食材，还得准备好中午吃的东西，打包带去公司，与我而言，那是万万做不到的。</p>
<p>上面三点，听起来似乎胖子们就没救了？下面就来说一说我是如何坚持下去的。</p>
<h4 id="记录"><a href="#记录" class="headerlink" title="记录"></a>记录</h4><p>首先需要了解一个简单的道理，要想让体重下去，每天摄入的能量，一定要小于每天消耗的能量，所以我们需要做的第一件事情就是找一个 APP 记录自己每天摄入的能量。为啥一定要找一个 APP 来记录呢？有这么一堆原因：</p>
<ul>
<li><strong>你不知道食物的能量有多少</strong>，比如酸奶，你知道一盒酸奶有多少能量么？你知道一根牛肉干的能量有多高么？你知道食物的碳水、蛋白质、脂肪等情况么？我估计你一点概念都没有，没关系，APP 知道；</li>
<li><strong>你记不住吃了多少</strong>，去一趟食堂，阿姨往你的盘子里打了一堆东西，你记得住自己吃了几块肥肉，几片火腿肠，几根青椒，几块萝卜，几口汤么？你记不住，记住了你也算不清楚，没关系，APP 算得清楚；</li>
<li><strong>你不知道食物的配比是否正确</strong>，早上吃了两个包子，中午吃了一块牛肉，晚上又吃了几盒水果，今天摄入的蛋白质够不够，碳水是不是偏多，你不知道，没关系，APP 可以告诉你。</li>
</ul>
<p>如果你自信自己可以算清楚每天的摄入量，我依然建议你使用 APP 记录，通过数据观察自己每天的摄入情况，对比体重的变化，可以更好、更快地找到适合自己的饮食结构。</p>
<h4 id="计算"><a href="#计算" class="headerlink" title="计算"></a>计算</h4><p>下面我来详细从数字上解释下，如何合理地控制饮食。</p>
<p>首先，你得知道每天不吃不喝不动也会存在消耗，这个消耗是人体的基本消耗，咱不搞什么复杂的算法，记住下面这个公式（统一使用千卡做单位，千卡又称大卡，亦称卡路里，下面简称卡）：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">每日的基本消耗（卡）~= 你的体重（斤） * <span class="number">12</span></span><br></pre></td></tr></table></figure>
<p>比如我减肥前的基本消耗大概为 1980 卡，这个算法比较粗暴，不算很准确，主要我觉得没必要算那么清楚，知道大致的就行了，如果你有运动的话，消耗量会大一点：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如走五六千步或者跑两三公里</span></span><br><span class="line">运动（卡）~= 体重（斤）* <span class="number">14</span></span><br></pre></td></tr></table></figure>
<p>运动消耗大概 2310 卡，这个也不准确，不过没关系，大致了解这个数值就行了，搞这么简单是为了好记。基本所有的食品包装袋上都会标注能量表，大部分会采用千焦耳做单位，它与卡路里的换算公式为：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> 卡 = <span class="number">4.18</span> 千焦耳 <span class="comment">// 简单一点，4 倍关系</span></span><br></pre></td></tr></table></figure>
<p>以后看到食品包装袋上标注的焦耳数值，除以 4，大概就是摄入的卡路里能量值。如果我想要减肥，每天摄入的能量就必须保证低于 1980 卡，你知道这个能量大概是多少么？</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> 个肉包 = <span class="number">210</span> 卡</span><br><span class="line"><span class="number">1</span> 碗米饭 = <span class="number">232</span> 卡</span><br><span class="line"><span class="number">1</span> 份五花肉 = <span class="number">426</span> 卡</span><br><span class="line"><span class="number">1</span> 盒酸奶 = <span class="number">180</span> 卡</span><br><span class="line"><span class="number">1</span> 个肉松面包 = <span class="number">391</span> 卡</span><br></pre></td></tr></table></figure>
<p>随便早餐一盒酸奶+一个包子，午餐一碗米饭+两个菜，晚饭一碗米饭+一个菜，就会达到 2100+ 卡了；更不用说，还会吃几盒水果，外加一点零食，还有夜宵，或者偶尔吃个火锅、烧烤等等，随随便便就 2500+ 甚至三四千卡。</p>
<p>看到上面这些数字，是不是已经找到自己持续长肉的源头啦？</p>
<h4 id="定制"><a href="#定制" class="headerlink" title="定制"></a>定制</h4><p>初期减肥时，一定要与米饭、肉类、油水等食物 Say Bye，随便找个 APP 查询下就会知道，碳水和脂肪类的能量都太高了，而且碳水还有个问题，能量高且容易消耗，简单来说，你吃两碗米饭，稍微动一动就又饿了。</p>
<p>当然，食堂基本也不要想着再去了，不管是自助餐厅还是阿姨给你打菜的那种食堂，都很难计算卡路里，各种食物掺杂在一起，加上还不知道菜里放了多少油，随便一顿下去，可能一整天的卡路里预算就花光了。</p>
<p>我的计划是每天吃 5 顿，早中晚三餐不能少，上午和下午各加餐一顿，基本上只补充碳水和蛋白质，不碰脂肪类食物。三个时间段的能量配比大概是 4:4:2，如果当天有运动的话，大概是 3:4:3，总摄入量一般建议是：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">每日总摄入能量（卡） = 基本消耗（卡） - <span class="number">500</span>~<span class="number">800</span>（卡）</span><br></pre></td></tr></table></figure>
<p>初期我是直接减 1000 卡，也就是总摄入量在 1000 卡左右（基本消耗约 1980 卡），属于有点猛烈的，正常配比大概是：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">上午（早餐 + 上午加餐）：<span class="number">400</span> 卡</span><br><span class="line">中午（午餐 + 中午加餐）：<span class="number">400</span> 卡</span><br><span class="line">晚上（晚餐 + 晚上加餐）：<span class="number">200</span> 卡</span><br></pre></td></tr></table></figure>
<p>晚上如果不是特别饿的话，不会加餐，如果当天有运动，总摄入量可能会调整到 1200~1400 卡。保持这个比例，然后不断的挖掘和适应自己最喜欢的食物和配餐。</p>
<p><strong>上午餐</strong></p>
<p>我的早餐比较固定，一般就是 <code>一大碗脱脂牛奶 + 麦片</code>，不到 300 卡，或者吃 <code>一个玉米 + 一个鸡蛋白</code>。每次加餐补充 200 卡，大概就是 <code>一个苹果 + 一个香蕉</code> 或者 <code>一个玉米 + 一个鸡蛋白</code> 的能量。</p>
<p>前两个月用的脱脂牛奶，后面用的鲜牛奶（主要是附近超市好像不提供脱脂牛奶了），牛奶和麦片随便就能买到，而且容易做，基本两分钟就能搞定（凉牛奶微波炉加热一分半），三分钟能吃完，一点都不耽误时间。偶尔起的早，会煮玉米和鸡蛋，或者去公司的超市购买。</p>
<p>麦片我不建议买燕麦片，太难吃，我买的是水果麦片。你会发现，我的配餐都是很容易凑齐，而且也是我喜欢吃的。一定得找自己喜欢吃的，否则，你想想，你如何坚持几个月？</p>
<p><strong>中午餐</strong></p>
<p>午餐基本就是吃沙拉，前一个月一点肉都没有，后来实在是坚持不下去了，加了点鸡胸肉、牛肉、鱼肉之类蛋白含量比较高的食物。再后来，我发现午餐超标吃一点「非健康」食物似乎也不怎么影响体重的下降，于是就改成了帕尼尼、吐司等等，不过我还是建议你先多吃水果蔬菜，等体重有了一点变化后，再加点料。</p>
<p>沙拉很多人都不爱吃，我也一样，所以我会尽量吃自己喜欢的，比如海带多一点的，或者小番茄多一点的沙拉。能够坚持吃一个月纯蔬菜沙拉的，都是牛人，比如我，哈哈，我自己都佩服我自己 ；）</p>
<p>下午我会去水果店买点自己喜欢的水果，或者继续补充点蛋白，吃些牛肉干或者鸡蛋白。上次从内蒙回来，我带了两袋子牛肉干，一根牛肉干大拇指那么粗，比筷子还长，大概也就 50g，能量大概 200+ 卡的样子，比较适合作为加餐食物。在家，吃牛肉干比较多；在公司，去水果店和甘其食比较多，还可以多走几步路，来回也有一两千步。</p>
<p><strong>晚上餐</strong></p>
<p>晚上就很简单了，基本就是黄瓜、小番茄、水果之类的，多吃一点问题也不大，基本就是保证 200 卡左右的摄入，如果有运动的话，会适当补充蛋白质。</p>
<p>我还挺喜欢吃鸡蛋番茄汤的，有一段时间，我会特意早早回家，给自己做一碗鸡蛋番茄汤，不放油。一般汤水放的挺多，一大碗下去，肚子都会很撑…</p>
<h4 id="自由日"><a href="#自由日" class="headerlink" title="自由日"></a>自由日</h4><p>如果一直保持低能量摄入，一段时间后，身体可能会适应这种环境，慢慢地，基础代谢会降低，每日的基础能耗也会降低，如果想继续维持体重的下降，便只能继续降低摄入量，长期如此对身体肯定是有害的，<strong>所以身体需要每周有一天或者至少有一餐是正常甚至过量摄入的，这是一顿欺骗餐，欺骗身体还有正常的摄入，基础消耗请不要降低。</strong></p>
<p>我一般把周六当做自由日，这一天中午，我会自己做一顿饭，下重油，敞开了吃，或者直接下馆子，整点烧烤、火锅之类。</p>
<p>这里需要注意的是，一般自由日过去后，体重会回升 2~5 斤，这是正常的，在下一周的周二、周三就会回落到之前水平。保持如此，前一个多月，我每周会减重 2~3 斤。</p>
<p>掉肉十五六斤的时候，我放宽了自由日的定义，每周会有 3~4 次在外面胡吃海喝，当然，结果就是花半个月才能掉 2~3 斤。虽然是胡吃海喝，但是吃的时候还是挺注意的，首先，我不吃米饭，然后就是只摄入高蛋白食物，尽量不碰油脂。</p>
<p>几个月下来，我戒掉了碳水。以前只要肚子饿，首先想到的是辛辣的美食，然后心中就会冒出两个字「下饭」+ 流口水，现在已经没啥感觉了。</p>
<h4 id="运动"><a href="#运动" class="headerlink" title="运动"></a>运动</h4><p>刚开始没怎么运动，等到身体从 16x 突破到 15x 的时候，热情高涨，血脉澎湃，每周都会破天荒地有 1~3 次的室内跑步，每次运动大概 15~30 min，保证全身湿透才会停下。要知道以前三个月能跑一次都是很奢侈的事情。</p>
<p>两个多月下来，体重下降 10kg，小米体脂秤的综合分从 60 分变成了如今的 81 分；之前有轻微的脂肪肝，现在应该没有了；肚子上的肉也不明显了，甚至还出现了一点点肌肉的痕迹；三下巴现在也消失了，现在只剩下一点点双下巴的痕迹。</p>
<p>其实结实的胖子减完肥，效果并没有那么明显，比如我，看起来也就是脸小了一点。只有自己能感觉到，整个身体轻松了很多，人也健康了不少。</p>
<p>由于 20 斤的目标已经达成，为了保持这种身材以及瘦身的心态，我决定，将当初的目标调整为 15kg，也就是说未来 2 个月的时间，我还会瘦 5kg，但是后续的减肥，我会尽量通过运动来控制，五分靠练五分靠吃，甚至六分靠练四分靠吃，今年的总体目标是 <strong>不限制自己的嘴巴，找到运动（拳击也好、游泳也好、撸铁也好）的乐趣，然后继续保持体重的稳定。</strong></p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>以上，啰啰嗦嗦说了一堆了，大概就是我最近两个月的所有减肥心得了。</p>
<p>后续，我应该会通过同样的方式 <code>目标 - 定制 - 行动 - 调整</code>，从运动而非饮食的角度让自己变得更加健康，这个阶段的摸索周期可能会更长一点，不过最近好像已经有了努力的方向，等我有了更多靠谱的经验，再跟大家分享吧~</p>
]]></content:encoded>
      <comments>https://yun.wztlink1013.com/blog/2019/07/28/my-way-to-lose-weight/#comments</comments>
    </item>
    
    <item>
      <title><![CDATA[破局 - 纯粹的执行者]]></title>
      <link>https://yun.wztlink1013.com/blog/2019/07/18/to-be-yourself-in-company/</link>
      <guid>https://yun.wztlink1013.com/blog/2019/07/18/to-be-yourself-in-company/</guid>
      <pubDate>Thu Jul 18 2019 14:19:00 GMT+0800 (GMT+08:00)</pubDate>
      <description>
      <![CDATA[小胡子哥的个人网站]]>
      
      </description>
      <content:encoded><![CDATA[<p>不管是大公司还是小公司，你都可以看见这类主管：他不断地从外面接活儿进来，然后排好时间、分好任务指派给你。在这样的主管下，你的角色更像是一个单纯的执行者，稍微好一点的情况是，他会给你安排大块的事情，糟糕一点的情况是，他指派给你的任务特别离散，不聚焦，让你东搞一下西搞一下。</p>
<p><img src="http://www.barretlee.com/blogimgs/2019/07/18/to_be_your_self_in_company.png" alt="破局"></p>
<p>明白自己处境的人，会忧虑，不明白的人，还觉得自己很充实。如果你恰好有这样的感觉，我可以告诉你几个破局的思路。</p>
<h4 id="1、不要把自己当成执行者"><a href="#1、不要把自己当成执行者" class="headerlink" title="1、不要把自己当成执行者"></a>1、不要把自己当成执行者</h4><p>很大一部分原因还是因为，你自己把自己当成了执行者，你不愿意去分析需求或者不懂得如何去分析需求，你没有一个长期的聚焦的目标，结果就是你的主管会帮你做好这一切，他会根据团队今年的目标分析出几件核心的事情，然后将事情细化之后分派给团队的同学，如果你有一定的规划能力，他可能会把一整件事情交给你，如果没有，那大概率就是东边人手不足把你推过去，西边时间紧急把你拉回来。</p>
<p>提升自己的主观能动性，主动去 Owner 一块事情，给出详细的规划和落地方案，不断找主管和合作伙伴对焦，自然而然你的规划力就显露出来了。不要把自己当成执行者，而是 Owner。</p>
<h4 id="2、帮助你的主管认识到自己的问题"><a href="#2、帮助你的主管认识到自己的问题" class="headerlink" title="2、帮助你的主管认识到自己的问题"></a>2、帮助你的主管认识到自己的问题</h4><p>很显然，把下属当做执行者也是主管的问题，任何一个人都是可培养的，否则当初也不会把你招进来，你可以找主管沟通，告诉他你最近处于什么状态，其实很可能在给你委派零散需求这件事情上，他并没有意识到会不利于你的成长，你需要吐露自己的心声，告诉主管你想得到什么，而现在的工作方式可能让你拿不到想要的结果。</p>
<p>主管也有能力强和能力弱的，对于没有太多管理经验的主管，他做事可能依然是当初个人作战时的风格，关注的是事情，没有考虑到人的成长。</p>
<h4 id="3、搞清楚团队的目标和个人的目标"><a href="#3、搞清楚团队的目标和个人的目标" class="headerlink" title="3、搞清楚团队的目标和个人的目标"></a>3、搞清楚团队的目标和个人的目标</h4><p>一个没有目标的团队是难以凝聚到一起的，在定义个人目标之前，你首先需要知道团队的目标是什么，说得直白一点，你需要知道主管今年的目标是什么，想一想自己承担了主管目标的哪个部分，偏离的太多肯定是不行的，个人的核心目标一定要与团队目标进行对焦。</p>
<p>目标一定是有挑战的，也是能拿到结果的，当你在执行任务的时候，可以去想一想，我手头的事情是否是完成个人目标的必做事项，如果不是，你就得想办法做取舍，至少得排个优先级。</p>
<h4 id="4、敢于-Say-No"><a href="#4、敢于-Say-No" class="headerlink" title="4、敢于 Say No"></a>4、敢于 Say No</h4><p>有的人敢跟需求方怼，但是在主管面前却毫无勇气，原因是主管会给你打绩效，他会影响你未来一年的涨薪、晋升等，所以对主管会言听计从。这显然是不对的。你是团队的一份子，你今年拿不到结果，也就意味着今年团队有一部分的结果堪忧，所以你在团队里无时无刻都扮演着重要的角色。</p>
<p>遇到不合理的需求，即使是主管指派的任务，你也要勇敢地站出来，告诉他，你错了，指出主管的错误，是为了自己好，更是为了团队好，你指出的问题越多，团队走偏的可能性就越低，你一定要明白这个道理。</p>
]]></content:encoded>
      <comments>https://yun.wztlink1013.com/blog/2019/07/18/to-be-yourself-in-company/#comments</comments>
    </item>
    
  </channel>
</rss>
