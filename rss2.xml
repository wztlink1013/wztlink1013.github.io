<?xml version="1.0" encoding="utf-8"?><?xml-stylesheet type="text/css" href="/public/css/rss.css" ?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title><![CDATA[尼采般地抒情]]></title>
    <link>https://www.wztlink1013.com/</link>
    <script xmlns="http://www.w3.org/1999/xhtml" src="/public/js/rss.js"></script>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    <description><![CDATA[尼采般地抒情个人网站，本科CS，大学期间开始撰写技术博客、个人生活随笔，这个兴趣爱好会一直延续下去……坚信什么都不舍弃，什么也改变不了！]]></description>
    <pubDate>Fri Mar 26 2021 15:10:29 GMT+0000 (Coordinated Universal Time)</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title><![CDATA[CSS预处理器stylus]]></title>
      <link>https://www.wztlink1013.com/blog/zsiw5e/</link>
      <guid>https://www.wztlink1013.com/blog/zsiw5e/</guid>
      <pubDate>Thu Mar 25 2021 03:16:41 GMT+0000 (Coordinated Universal Time)</pubDate>
      <description>
      <![CDATA[<hr>
<p>categories: Language</p>
<p>—success<br>CSS 的预处理器，给 CSS 添加了可编程的特性，也就是说，在 stylus 中可以使用变量、函数、判断、循环一系列 CSS 没有的东西来编写样式文件，这个文件可编译成 CSS 文件]]>
      </description>
      <content:encoded><![CDATA[<hr>
<p>categories: Language</p>
<p>—success<br>CSS 的预处理器，给 CSS 添加了可编程的特性，也就是说，在 stylus 中可以使用变量、函数、判断、循环一系列 CSS 没有的东西来编写样式文件，这个文件可编译成 CSS 文件</p>
<h2 id="note"><a href="#note" class="headerlink" title="note"></a>note</h2><ul>
<li>“[]”：中括号内容，是定义属性的方式</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://www.zhangxinxu.com/jq/stylus/" target="_blank" rel="noopener">stylus 中文版参考文档之综述——张鑫旭</a></li>
<li><a href="https://stylus.bootcss.com/" target="_blank" rel="noopener">富于表现力、动态的、健壮的 CSS</a></li>
</ul>
]]></content:encoded>
      <comments>https://www.wztlink1013.com/blog/zsiw5e/#comments</comments>
    </item>
    
    <item>
      <title><![CDATA[CSS的媒体查询]]></title>
      <link>https://www.wztlink1013.com/blog/mio9h2/</link>
      <guid>https://www.wztlink1013.com/blog/mio9h2/</guid>
      <pubDate>Thu Mar 25 2021 03:12:01 GMT+0000 (Coordinated Universal Time)</pubDate>
      <description>
      <![CDATA[<h3 id="媒体查询（CSS3）"><a href="#媒体查询（CSS3）" class="headerlink" title="媒体查询（CSS3）"></a>媒体查询（CSS3）</h3><div style="background: #E8F7FF;padding:1]]>
      </description>
      <content:encoded><![CDATA[<h3 id="媒体查询（CSS3）"><a href="#媒体查询（CSS3）" class="headerlink" title="媒体查询（CSS3）"></a>媒体查询（CSS3）</h3><div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">@media：注意@符号</div>

<pre><code class="css">@media mediatype and|not|only (media feature) {
    CSS-Code;
}
</code></pre>
<h3 id="mediatype-查询类型"><a href="#mediatype-查询类型" class="headerlink" title="mediatype 查询类型"></a>mediatype 查询类型</h3><div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">将不同的终端设备划分成不同的类型，称为媒体类型</div><br><img src="https://cdn.nlark.com/yuque/0/2021/jpg/1484158/1615360325196-c449a080-4612-4814-b5da-5a61b1da1c0b.jpg#align=left&amp;display=inline&amp;height=193&amp;margin=%5Bobject%20Object%5D&amp;originHeight=193&amp;originWidth=915&amp;status=done&amp;style=stroke&amp;width=915" alt><br><br>### 关键字<br><br><div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">关键字将媒体类型或多个媒体特性连接到一起做为媒体查询的条件。</div>

<ul>
<li>and：可以将多个媒体特性连接到一起，相当于“且”的意思。</li>
<li>not：排除某个媒体类型，相当于“非”的意思，可以省略。</li>
<li>only：指定某个特定的媒体类型，可以省略。</li>
</ul>
<h3 id="媒体特性"><a href="#媒体特性" class="headerlink" title="媒体特性"></a>媒体特性</h3><p><div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">每种媒体类型都具体各自不同的特性，根据不同媒体类型的媒体特性设置不同的展示风格。我们暂且了解三个。</div><br><img src="https://cdn.nlark.com/yuque/0/2021/jpg/1484158/1615360325364-d6cd0d1a-1ec7-4bd1-a67e-3fadde7c4381.jpg#align=left&amp;display=inline&amp;height=195&amp;margin=%5Bobject%20Object%5D&amp;originHeight=195&amp;originWidth=918&amp;status=done&amp;style=stroke&amp;width=918" alt></p>
<h3 id="媒体查询书写规则"><a href="#媒体查询书写规则" class="headerlink" title="媒体查询书写规则"></a>媒体查询书写规则</h3><p><div style="background: #FFF3F3;padding:10px;border: 1px solid #DEB8BE;border-radius:5px;margin-bottom:5px;">为了防止混乱，媒体查询我们要按照从小到大或者从大到小的顺序来写,但是我们最喜欢的还是从小到大来写，这样代码更简洁</div><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1615360325484-f6620522-776e-4e30-a997-8641577a1218.png#align=left&amp;display=inline&amp;height=445&amp;margin=%5Bobject%20Object%5D&amp;originHeight=445&amp;originWidth=1034&amp;status=done&amp;style=stroke&amp;width=1034" alt></p>
]]></content:encoded>
      <comments>https://www.wztlink1013.com/blog/mio9h2/#comments</comments>
    </item>
    
    <item>
      <title><![CDATA[GitHub基于Issue的软件项目管理]]></title>
      <link>https://www.wztlink1013.com/blog/hgbehz/</link>
      <guid>https://www.wztlink1013.com/blog/hgbehz/</guid>
      <pubDate>Wed Mar 24 2021 19:33:01 GMT+0000 (Coordinated Universal Time)</pubDate>
      <description>
      <![CDATA[<p><div style="background: #FFFBE6;padding:10px;border: 1px solid #C3C3C3;border-radius:5px;margin-bottom:5px;">在进行GitHub项目开发过程中，途中会有一些新想法，遇]]>
      </description>
      <content:encoded><![CDATA[<p><div style="background: #FFFBE6;padding:10px;border: 1px solid #C3C3C3;border-radius:5px;margin-bottom:5px;">在进行GitHub项目开发过程中，途中会有一些新想法，遇见的新bug等问题，提出的一些新灵感等等都可以利用GitHub每个项目自带的issues（议题）来进行管理、跟踪并且加以解决。<br>传统的软件项目管理还有Milestones（里程碑）、Projects（画板）来一并进行项目的开发，GitHub在2020年还新增加了Discussion（讨论区）模块，进一步提高软件项目的管理工作。</div><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616655875686-d8387a58-3c42-4442-b6b5-1cd2b0c68a5f.png#align=left&amp;display=inline&amp;height=129&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=258&amp;originWidth=1893&amp;size=52796&amp;status=done&amp;style=stroke&amp;width=946.5" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616656006240-dd9c58bd-6675-487e-aab0-58878e9fcb29.png#align=left&amp;display=inline&amp;height=128&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=255&amp;originWidth=1895&amp;size=48535&amp;status=done&amp;style=stroke&amp;width=947.5" alt="image.png"></p>
<h2 id="Issue-标签类型总结"><a href="#Issue-标签类型总结" class="headerlink" title="Issue 标签类型总结"></a>Issue 标签类型总结</h2><p><div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">GitHub默认的标签</div><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616658286733-087798b9-606d-48f6-858d-0e51eb4e3882.png#align=left&amp;display=inline&amp;height=264&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=528&amp;originWidth=981&amp;size=60465&amp;status=done&amp;style=stroke&amp;width=490.5" alt="image.png"></p>
<table>
<thead>
<tr>
<th>bug</th>
<th>提出一个 bug</th>
<th>颜色默认</th>
</tr>
</thead>
<tbody>
<tr>
<td>documentation</td>
<td>详查文档</td>
<td>颜色默认</td>
</tr>
<tr>
<td>duplicate</td>
<td>这是个重复的问题</td>
<td>颜色默认</td>
</tr>
<tr>
<td>enhancement</td>
<td>增强和改进</td>
<td>颜色默认</td>
</tr>
<tr>
<td>good first issue</td>
<td>好的想法/灵感</td>
<td>颜色默认</td>
</tr>
<tr>
<td>help wanted</td>
<td>使用过程中不明白的地方</td>
<td>颜色默认</td>
</tr>
<tr>
<td>invalid</td>
<td>该问题看起来没有意义</td>
<td>颜色默认</td>
</tr>
<tr>
<td>question</td>
<td>请提供进一步资料</td>
<td>颜色默认</td>
</tr>
<tr>
<td>wontfix</td>
<td>项目设计初衷如此</td>
<td>颜色默认</td>
</tr>
</tbody>
</table>
<p><div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">自需添加的</div><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616658483326-cdf325c4-d662-4c48-ab61-c2df5c784446.png#align=left&amp;display=inline&amp;height=67&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=133&amp;originWidth=988&amp;size=10338&amp;status=done&amp;style=none&amp;width=494" alt="image.png"></p>
<table>
<thead>
<tr>
<th>debugging</th>
<th>正在调试</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>fixed</td>
<td>已被修复</td>
</tr>
</tbody>
</table>
<blockquote>
<p>持续更新……</p>
</blockquote>
<h2 id="Discussion-的新革新"><a href="#Discussion-的新革新" class="headerlink" title="Discussion 的新革新"></a>Discussion 的新革新</h2><p>传统的流程是提出 issues 之后，根据不同的 issue 来跟进画板（Project）的内容。</p>
<p>上面的做法其实有一个思维上的 bug，一些灵感之类的不好放上去，使用 Discussion 之后，可以在 Discussion 里面放上想法、灵感等，实际开发从这里面的一个的一个具体的评论转换到实际的 issue 里面</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://www.ruanyifeng.com/blog/2017/08/issue.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2017/08/issue.html</a></li>
<li><a href="https://github.com/volantis-x/hexo-theme-volantis/" target="_blank" rel="noopener">https://github.com/volantis-x/hexo-theme-volantis/</a></li>
</ul>
]]></content:encoded>
      <comments>https://www.wztlink1013.com/blog/hgbehz/#comments</comments>
    </item>
    
    <item>
      <title><![CDATA[Git push出(10054)/(port 443：time out)错]]></title>
      <link>https://www.wztlink1013.com/blog/tttk33/</link>
      <guid>https://www.wztlink1013.com/blog/tttk33/</guid>
      <pubDate>Tue Mar 23 2021 17:24:46 GMT+0000 (Coordinated Universal Time)</pubDate>
      <description>
      <![CDATA[<div style="background: #FFF3F3;padding:10px;border: 1px solid #DEB8BE;border-radius:5px;margin-bottom:5px;">Git push出(10054)/(port 443：time]]>
      </description>
      <content:encoded><![CDATA[<div style="background: #FFF3F3;padding:10px;border: 1px solid #DEB8BE;border-radius:5px;margin-bottom:5px;">Git push出(10054)/(port 443：time out)错</div>

<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1615710474939-e30bb4c2-806b-4db3-a467-09ca14264ebd.png#align=left&amp;display=inline&amp;height=330&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=659&amp;originWidth=1172&amp;size=785473&amp;status=done&amp;style=none&amp;width=586" alt="image.png"></p>
<pre><code class="bash">//10054复制下面的
git config http.postBuffer 524288000

//443复制下面的
git config --global --unset http.proxy

git config --global --unset https.proxy
</code></pre>
]]></content:encoded>
      <comments>https://www.wztlink1013.com/blog/tttk33/#comments</comments>
    </item>
    
    <item>
      <title><![CDATA[C++链表设计]]></title>
      <link>https://www.wztlink1013.com/blog/gu92gu/</link>
      <guid>https://www.wztlink1013.com/blog/gu92gu/</guid>
      <pubDate>Tue Mar 23 2021 03:37:03 GMT+0000 (Coordinated Universal Time)</pubDate>
      <description>
      <![CDATA[<h2 id="实验报告要求"><a href="#实验报告要求" class="headerlink" title="实验报告要求"></a>实验报告要求</h2><blockquote>
<p>1、建立一个顺序表，输入 n 个元素并输出；<br>2、查找线性表中的最大元素并输]]>
      </description>
      <content:encoded><![CDATA[<h2 id="实验报告要求"><a href="#实验报告要求" class="headerlink" title="实验报告要求"></a>实验报告要求</h2><blockquote>
<p>1、建立一个顺序表，输入 n 个元素并输出；<br>2、查找线性表中的最大元素并输出；<br>3、在线性表的第 i 个元素前插入一个正整数 x；<br>4、删除线性表中的第 j 个元素；<br>5、将线性表中的元素按升序排列；<br>*6、将线性表中的元素就地逆序（只允许用一个暂存单元）；</p>
</blockquote>
<h2 id="概念理解"><a href="#概念理解" class="headerlink" title="概念理解"></a>概念理解</h2><h3 id="链表数据结构"><a href="#链表数据结构" class="headerlink" title="链表数据结构"></a>链表数据结构</h3><p>链表是一种数据结构，和<strong>数组同级</strong>。之前 JAVA 里面的 ArrayList 数据结构，其实现原理是数组，而 JAVA 的 LinkedList 的实现原理就是链表了。链表在进行循环遍历时效率不高，但是插入和删除时优势明显，其实 C/C++抑或是 JAVA 这些数据结构都一样——地址……引用……</p>
<p>单向链表是一种线性表，实际上是由<strong>节点（Node）</strong>组成的，一个链表拥有不定数量的节点。其数据在<strong>内存中存储是不连续的</strong>，它存储的数据分散在内存中，每个结点只能也只有它能知道下一个结点的存储位置。由 N 各节点（Node）组成单向链表，每一个 Node 记录本 Node 的数据及下一个 Node。向外暴露的只有一个头节点（Head），<strong>我们对链表的所有操作，都是直接或者间接地通过其头节点来进行的。</strong><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1603194076184-195f3044-1083-4244-9eeb-d86c96a37e6f.png#align=left&amp;display=inline&amp;height=98&amp;margin=%5Bobject%20Object%5D&amp;originHeight=98&amp;originWidth=491&amp;size=0&amp;status=done&amp;style=shadow&amp;width=491" alt><br>上图中最左边的节点即为头结点（Head），但是添加节点的顺序是从右向左的，添加的新节点会被作为新节点。最先添加的节点对下一节点的引用可以为空。引用是引用下一个节点而非下一个节点的对象。因为有着不断的引用，所以<strong>头节点就可以操作所有节点</strong>了。<br>下图描述了单向链表存储情况。存储是分散的，每一个节点只要记录下一节点，就把所有数据串了起来，形成了一个单向链表。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1603194105521-d31f8e78-7f2a-4c60-8838-57e15707e27b.png#align=left&amp;display=inline&amp;height=219&amp;margin=%5Bobject%20Object%5D&amp;originHeight=219&amp;originWidth=195&amp;size=0&amp;status=done&amp;style=stroke&amp;width=195" alt><br>节点（Node）是由一个需要储存的对象及对下一个节点的引用组成的。也就是说，节点拥有两个成员：储存的对象、对下一个节点的引用。下面图是具体的说明：<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1603194124335-fc6fc00c-35fb-44e1-a01c-de4b8b5531af.png#align=left&amp;display=inline&amp;height=207&amp;margin=%5Bobject%20Object%5D&amp;originHeight=207&amp;originWidth=370&amp;size=0&amp;status=done&amp;style=stroke&amp;width=370" alt></p>
<h3 id="首元节点、头节点、头指针"><a href="#首元节点、头节点、头指针" class="headerlink" title="首元节点、头节点、头指针"></a>首元节点、头节点、头指针</h3><blockquote>
<p>一些概念</p>
</blockquote>
<ul>
<li>首元结点：第一个有元素的结点</li>
<li>头结点：一般不放元素，“L”</li>
<li>头指针：指向链表的第一个结点，有头结点则为头结点的指针，反之，指向首元结点的指针<blockquote>
<p>参考资料：<a href="https://www.jianshu.com/p/73d56c3d228c" target="_blank" rel="noopener">https://www.jianshu.com/p/73d56c3d228c</a></p>
</blockquote>
</li>
</ul>
<h3 id="关于链表的指向"><a href="#关于链表的指向" class="headerlink" title="关于链表的指向"></a>关于链表的指向</h3><blockquote>
<p>【1】何为指向？</p>
</blockquote>
<p>个人觉得链表的相关问题及操作就是理解链表的<strong>“指向”</strong>这么个概念，先明确以下几点</p>
<ul>
<li>每个节点的<strong>next</strong>用来存放<strong>下一个节点的“地址”</strong></li>
<li><strong>每个节点的自身就是地址</strong>，相当于 C 语言中数组的数组名就是本数组的地址</li>
</ul>
<blockquote>
<p>【2】谁指向谁？</p>
</blockquote>
<p><strong>总结：</strong><br><strong>做题用我的下面总结的方法，绝对好用</strong><br><strong><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1616501415627-ee5d1008-a07d-4acb-821b-e227b5cb7ad8.jpeg#align=left&amp;display=inline&amp;height=59&amp;margin=%5Bobject%20Object%5D&amp;name=huaji1558a846ddf2e12b.jpeg&amp;originHeight=59&amp;originWidth=55&amp;size=703&amp;status=done&amp;style=stroke&amp;width=55" alt="huaji1558a846ddf2e12b.jpeg"></strong></p>
<ul>
<li><strong>读的时候：从左往右读，一般左边是某某的 next 域，右边是具体的结点</strong></li>
<li><strong>画的时候：在图中表示为等号左边指向等号右边</strong></li>
</ul>
<p><strong><br>比如：① <code>node.next = prev.next;</code> ②<code>prev.next = node</code><br>①“node 的 next 指向 prev 的下一个结点”<br>（用指针的概念通俗地说，其实就是 prev 的下一个结点的地址由 prev 的指针域里面赋值给了 node 的 next 指针域里面）<br>②“prev 的 next 指向 node 这个结点”<br>（还可以这么说：将 node 赋值给 prev 的 next，也就是说 prev 的下一个结点是 node）
</strong></p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1599309003706-ad779a14-1678-4d0c-86f2-b147752bd252.png#align=left&amp;display=inline&amp;height=204&amp;margin=%5Bobject%20Object%5D&amp;originHeight=594&amp;originWidth=955&amp;size=0&amp;status=done&amp;style=stroke&amp;width=328" alt><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1599309003751-ffeee4d8-9662-416e-8f46-5cf5edf03114.png#align=left&amp;display=inline&amp;height=250&amp;margin=%5Bobject%20Object%5D&amp;originHeight=725&amp;originWidth=938&amp;size=0&amp;status=done&amp;style=stroke&amp;width=324" alt><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1599309003658-46b3e7db-e6dc-4d13-baea-e7e44075e8bc.png#align=left&amp;display=inline&amp;height=221&amp;margin=%5Bobject%20Object%5D&amp;originHeight=626&amp;originWidth=975&amp;size=0&amp;status=done&amp;style=stroke&amp;width=344" alt></p>
<blockquote>
<p>【3】指向错位？</p>
</blockquote>
<p><strong>关注第一个元素节点是不是 head，因为有的链表不声明头节点（head），直接就是第一个结点就是元素结点</strong></p>
<h3 id="关于-p-L-的理解"><a href="#关于-p-L-的理解" class="headerlink" title="关于 p=L 的理解"></a>关于 p=L 的理解</h3><p>写代码的时候，还经常遇到下面的情况<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616501697301-b63e6312-d8f9-4130-8d25-2d3becd75038.png#align=left&amp;display=inline&amp;height=53&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=106&amp;originWidth=466&amp;size=9439&amp;status=done&amp;style=none&amp;width=233" alt="image.png"><br>p、L 就是指向结点的指针类型，将 L 的值赋给 p，也就是 p、L 指向同一个结点。具体理解可以用下面一个例子来说明：<br>下面图片这个函数就是在一个单链表中，功能就是指定 i 位置插入 e 值。下图箭头处如果 TraverseList 返回的是 p 那么得出的链表结果就是从插入的那个元素往后这样一个部分链表，返回的是 L 就是想要的结果，p 的功能有点类似在 L 的中间做了手脚……<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616501856348-955542eb-258d-473f-b003-c53881275937.png#align=left&amp;display=inline&amp;height=331&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=662&amp;originWidth=740&amp;size=62693&amp;status=done&amp;style=none&amp;width=370" alt="image.png"></p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="实验报告代码"><a href="#实验报告代码" class="headerlink" title="实验报告代码"></a>实验报告代码</h3><pre><code class="cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;

typedef struct LNode {
    int data;
    struct LNode *next;
}Lnode, *LinkList;

LinkList L;

void InitList(LinkList &amp;L) {
    L = new LNode;
    L-&gt;next = NULL;
}

void CreateList_H(LinkList &amp;L) {
    InitList(L);
    int n;
    cout &lt;&lt; &quot;请输入要使用前插法插入的元素个数：&quot;;
    cin &gt;&gt; n;
    for (int i = 0; i &lt; n; i++){
        LNode *p = new LNode;
        cin &gt;&gt; p-&gt;data;
        p-&gt;next = L-&gt;next;
        L-&gt;next = p;
    }
}
void TraverseList(LinkList &amp;L){
    LNode *p = new LNode;
    p = L-&gt;next;
    cout &lt;&lt; &quot;此链表打印的结果为：&quot;&lt;&lt;&quot;\n&quot;;
    while (p != NULL){
        cout &lt;&lt; p-&gt;data &lt;&lt; &quot; &quot;;
        p = p-&gt;next;
    }
    cout &lt;&lt; &quot;\n&quot;;
}
void GetElem(LinkList &amp;L) {
    int n;
    cout &lt;&lt; &quot;请输入要查询的链表中第i个数：&quot;;
    cin &gt;&gt; n;
    LNode *p = new LNode;
    p = L;
    for (int i = 0; i &lt; n;i++){
        p = p-&gt;next;
    }
    cout &lt;&lt; &quot;查询的结果为：&quot; &lt;&lt; p-&gt;data&lt;&lt;&quot;\n&quot;;
}
void ListInsert(LinkList &amp;L){
    LNode *p = new LNode;
    p = L;
    int n;
    int e;
    cout &lt;&lt; &quot;请分别输入要在第n个位置插入的e值：&quot;;
    cin &gt;&gt; n&gt;&gt; e ;
    for (int i = 0; i &lt; n;i++) {
        if (n == i+1){
            LNode *temp = new LNode;
            temp-&gt;data = e;
            temp-&gt;next = p-&gt;next;
            p-&gt;next = temp;
            break;
        }
        p = p-&gt;next;
    }
    TraverseList(L); // 直接返回L就可以了，之前返回p是不可以的！！！唉，大意了~
}
void ListDelete(LinkList &amp;L){
    cout &lt;&lt; &quot;请输入要删除的第j个位置的j值：&quot;;
    LNode *p = new LNode;
    p = L;
    int j;
    cin &gt;&gt; j;
    for (int i = 0; i &lt; j;i++) {
        if (j == i+1) {
            p-&gt;next = p-&gt;next-&gt;next;
            break;
        }
        p = p-&gt;next;
    }
    TraverseList(L);
}
void ReverseList(LinkList &amp;L) {
    LNode *p = L-&gt;next;
    L-&gt;next = NULL;
    while(p)
    {
        LNode *q = p-&gt;next;
        p-&gt;next = L-&gt;next;
        L-&gt;next = p;
        p = q;
    }
    cout &lt;&lt; &quot;通过逆置之后……&quot;;
    TraverseList(L);
}

int main() {
    LNode *test = new LNode;
    CreateList_H(test);//1
    TraverseList(test);//1
    GetElem(test);//2
    ListInsert(test);//3
    ListDelete(test);//4
    ReverseList(test);//5
}
</code></pre>
<h3 id="尾插法的理解"><a href="#尾插法的理解" class="headerlink" title="尾插法的理解"></a>尾插法的理解</h3><ul>
<li><a href="https://blog.csdn.net/sinat_41721615/article/details/105031104" target="_blank" rel="noopener">https://blog.csdn.net/sinat_41721615/article/details/105031104</a></li>
<li><a href="https://zhidao.baidu.com/question/944472157933268532.html" target="_blank" rel="noopener">https://zhidao.baidu.com/question/944472157933268532.html</a></li>
</ul>
<h3 id="整体实现代码"><a href="#整体实现代码" class="headerlink" title="整体实现代码"></a>整体实现代码</h3><pre><code class="cpp">#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;iomanip&gt;
#include&lt;stdlib.h&gt;
using namespace std;


typedef struct LNode {
    int data; //结点的数据域
    struct LNode *next; //结点的指针域
}LNode, *LinkList; //LinkList为指向结构体LNode的指针类型

bool InitList_L(LinkList &amp;L)//构造一个空的单链表L//结构体指针类型变量做为函数的形式参数
{
    L=new LNode;     //生成新结点作为头结点，用头指针L指向头结点//变量名 = new 类型
    if(!L)
      return false;  //生成结点失败
    L-&gt;next=NULL;   //头结点的指针域置空
    return true;
}

void CreateList_H(LinkList &amp;L)//前插法创建单链表
{
    //输入n个元素的值，建立到头结点的单链表L
    int n;
    LinkList s; //定义一个所建立的结构体指针变量
    L=new LNode; //生成新结点作为头结点，用头指针L指向头结点
    L-&gt;next=NULL; //先建立一个带头结点的空链表
    cout &lt;&lt;&quot;请输入元素个数n：&quot; &lt;&lt; endl;
    cin&gt;&gt;n;
    cout &lt;&lt;&quot;请依次输入n个元素：&quot; &lt;&lt;endl;
    cout &lt;&lt;&quot;前插法创建单链表...&quot; &lt;&lt;endl;
    while(n--)
    {
        s=new LNode; //生成新结点s
        cin&gt;&gt;s-&gt;data; //输入元素值赋给新结点的数据域
        s-&gt;next=L-&gt;next;
        L-&gt;next=s; //将新结点s插入到头结点之后
    }
}

void CreateList_R(LinkList &amp;L)//尾插法创建单链表
{
    //输入n个元素的值，建立带表头结点的单链表L
    int n;
    LinkList s, r;
    L=new LNode;
    L-&gt;next=NULL; //先建立一个带头结点的空链表
    r=L; //尾指针r指向头结点
    cout &lt;&lt;&quot;请输入元素个数n：&quot; &lt;&lt;endl;
    cin&gt;&gt;n;
    cout &lt;&lt;&quot;请依次输入n个元素：&quot; &lt;&lt;endl;
    cout &lt;&lt;&quot;尾插法创建单链表...&quot; &lt;&lt;endl;
    while(n--)
    {
        s=new LNode;//生成新结点
        cin&gt;&gt;s-&gt;data; //输入元素值赋给新结点的数据域
        s-&gt;next=NULL;
        r-&gt;next=s;//将新结点s插入尾结点*r之后
        r=s;//r指向新的尾结点s
    }
}

bool GetElem_L(LinkList L, int i, int &amp;e)//单链表的取值
{
    //在带头结点的单链表L中查找第i个元素
    //用e记录L中第i个数据元素的值
    int j;
    LinkList p;
    p=L-&gt;next;//p指向首元结点
    j=1; //j为计数器
    while (j&lt;i &amp;&amp; p) //顺链域向后扫描，直到p指向第i个元素或p为空
    {
        p=p-&gt;next; //p指向下一个结点    类似结点的自加
        j++; //计数器j相应加1
    }
    if (!p || j&gt;i)
        return false; //i值不合法i＞n或i&lt;=0
    e=p-&gt;data; //取第i个结点的数据域
    return true;
}

bool LocateElem_L(LinkList L, int e) //按值查找
{
    //在带头结点的单链表L中查找值为e的元素
    LinkList p;
    p=L-&gt;next;
    while (p &amp;&amp; p-&gt;data!=e)//顺链域向后扫描，直到p为空或p所指结点的数据域等于e
        p=p-&gt;next; //p指向下一个结点
    if(!p)
        return false; //查找失败p为NULL
    return true;
}

bool ListInsert_L(LinkList &amp;L, int i, int e)//单链表的插入
{
    //在带头结点的单链表L中第i个位置插入值为e的新结点
    int j;
    LinkList p, s;
    p=L;
    j=0;
    while (p&amp;&amp;j&lt;i-1) //查找第i-1个结点，p指向该结点
    {
        p=p-&gt;next;
        j++;
    }
    if (!p || j&gt;i-1)//i＞n+1或者i＜1
        return false;
    s=new LNode;     //生成新结点
    s-&gt;data=e;       //将新结点的数据域置为e
    s-&gt;next=p-&gt;next; //将新结点的指针域指向结点ai
    p-&gt;next=s;       //将结点p的指针域指向结点s
    return true;
}

bool ListDelete_L(LinkList &amp;L, int i) //单链表的删除
{
    //在带头结点的单链表L中，删除第i个位置
    LinkList p, q;
    int j;
    p=L;
    j=0;
    while((p-&gt;next)&amp;&amp;(j&lt;i-1)) //查找第i-1个结点，p指向该结点
    {
        p=p-&gt;next;
        j++;
    }
    if (!(p-&gt;next)||(j&gt;i-1))//当i&gt;n或i&lt;1时，删除位置不合理
        return false;
    q=p-&gt;next;        //临时保存被删结点的地址以备释放空间
    p-&gt;next=q-&gt;next; //改变删除结点前驱结点的指针域
    delete q;        //释放被删除结点的空间
    return true;
}

void Listprint_L(LinkList L) //单链表的输出
{
    LinkList p;
    p=L-&gt;next;
    while (p)
    {
        cout&lt;&lt;p-&gt;data&lt;&lt;&quot;\t&quot;;
        p=p-&gt;next;
    }
    cout&lt;&lt;endl;
}

int main()
{
    int i,x,e,choose;
    LinkList L;
    cout &lt;&lt; &quot;1. 初始化\n&quot;;
    cout &lt;&lt; &quot;2. 创建单链表（前插法）\n&quot;;
    cout &lt;&lt; &quot;3. 创建单链表（尾插法）\n&quot;;
    cout &lt;&lt; &quot;4. 取值\n&quot;;
    cout &lt;&lt; &quot;5. 查找\n&quot;;
    cout &lt;&lt; &quot;6. 插入\n&quot;;
    cout &lt;&lt; &quot;7. 删除\n&quot;;
    cout &lt;&lt; &quot;8. 输出\n&quot;;
    cout &lt;&lt; &quot;0. 退出\n&quot;;
    choose=-1;
    while (choose!=0)
    {
        cout&lt;&lt;&quot;请输入数字选择:&quot;;
        cin&gt;&gt;choose;
        switch (choose)
        {
        case 1: //初始化一个空的单链表
            if (InitList_L(L))
                cout &lt;&lt; &quot;初始化一个空的单链表!\n&quot;;
            break;
        case 2: //创建单链表（前插法）
            CreateList_H(L);
            cout &lt;&lt; &quot;前插法创建单链表输出结果:\n&quot;;
            Listprint_L(L);
            break;
        case 3: //创建单链表（尾插法）
            CreateList_R(L);
            cout &lt;&lt; &quot;尾插法创建单链表输出结果:\n&quot;;
            Listprint_L(L);
            break;
        case 4: //单链表的按序号取值
            cout &lt;&lt; &quot;请输入一个位置i用来取值:&quot;;
            cin &gt;&gt; i;
            if (GetElem_L(L,i,e))
            {
                cout &lt;&lt; &quot;查找成功\n&quot;;
                cout &lt;&lt; &quot;第&quot; &lt;&lt; i &lt;&lt; &quot;个元素是：&quot;&lt;&lt;e&lt;&lt; endl;
            }
            else
                cout &lt;&lt; &quot;查找失败\n\n&quot;;
            break;
        case 5: //单链表的按值查找
            cout&lt;&lt;&quot;请输入所要查找元素x:&quot;;
            cin&gt;&gt;x;
            if (LocateElem_L(L,x))
                cout &lt;&lt; &quot;查找成功\n&quot;;
            else
                cout &lt;&lt; &quot;查找失败! &quot; &lt;&lt;endl;
            break;
        case 6: //单链表的插入
            cout &lt;&lt; &quot;请输入插入的位置和元素（用空格隔开）:&quot;;
            cin &gt;&gt; i;
            cin &gt;&gt; x;
            if (ListInsert_L(L, i, x))
                cout &lt;&lt; &quot;插入成功.\n\n&quot;;
            else
                cout &lt;&lt; &quot;插入失败!\n\n&quot;;
            break;
        case 7: //单链表的删除
            cout&lt;&lt;&quot;请输入所要删除的元素位置i:&quot;;
            cin&gt;&gt;i;
            if (ListDelete_L(L, i))
                cout&lt;&lt;&quot;删除成功!\n&quot;;
            else
                cout&lt;&lt;&quot;删除失败!\n&quot;;
            break;
        case 8: //单链表的输出
            cout &lt;&lt; &quot;当前单链表的数据元素分别为:\n&quot;;
            Listprint_L(L);
            cout &lt;&lt; endl;
            break;
        }
    }
    system(&quot;pause&quot;);
    return 0;
}
</code></pre>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://shangdixinxi.com/detail-1507915.html" target="_blank" rel="noopener">链表 p-&gt;next=q-&gt;next,q-&gt;next=p,q=p;的一些解释</a></li>
<li><a href="https://blog.csdn.net/weixin_44135282/article/details/90348885" target="_blank" rel="noopener">p-&gt;next=q 与 q=p-&gt;next 区分</a></li>
</ul>
]]></content:encoded>
      <comments>https://www.wztlink1013.com/blog/gu92gu/#comments</comments>
    </item>
    
    <item>
      <title><![CDATA[计算方法流程图汇总]]></title>
      <link>https://www.wztlink1013.com/blog/hizlew/</link>
      <guid>https://www.wztlink1013.com/blog/hizlew/</guid>
      <pubDate>Fri Mar 12 2021 07:07:57 GMT+0000 (Coordinated Universal Time)</pubDate>
      <description>
      <![CDATA[<blockquote>
<p>大三计算方法课程所有实验报告的流程图，做个存档，以备不时之需~~<img src="https://cdn.nlark.com/yuque/0/2021/gif/1484158/1616633908079-3d59dbee-c4dc-4c51-89]]>
      </description>
      <content:encoded><![CDATA[<blockquote>
<p>大三计算方法课程所有实验报告的流程图，做个存档，以备不时之需~~<img src="https://cdn.nlark.com/yuque/0/2021/gif/1484158/1616633908079-3d59dbee-c4dc-4c51-899f-0708e3570b0d.gif#align=left&amp;display=inline&amp;height=100&amp;margin=%5Bobject%20Object%5D&amp;name=A13E7D78C08B2131588EDD8D9F6FE5EB.gif&amp;originHeight=100&amp;originWidth=100&amp;size=10263&amp;status=done&amp;style=stroke&amp;width=100" alt="A13E7D78C08B2131588EDD8D9F6FE5EB.gif"><br>目录</p>
<ul>
<li>非线性方程的解法</li>
<li>线性方程组的解法</li>
<li>Hermite 插值</li>
<li>最小二乘算法</li>
<li>正态分布表复现</li>
</ul>
</blockquote>
<h2 id="非线性方程的解法"><a href="#非线性方程的解法" class="headerlink" title="非线性方程的解法"></a>非线性方程的解法</h2><p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1616633632638-fc4a4508-6a92-4c8e-ae80-6d7326f9e13a.jpeg#align=left&amp;display=inline&amp;height=555&amp;margin=%5Bobject%20Object%5D&amp;name=yuque_diagram.jpg&amp;originHeight=1728&amp;originWidth=1258&amp;size=109866&amp;status=done&amp;style=stroke&amp;width=404" alt="yuque_diagram.jpg"></p>
<h2 id="线性方程组的解法"><a href="#线性方程组的解法" class="headerlink" title="线性方程组的解法"></a>线性方程组的解法</h2><p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1616633672598-12d949b6-91f6-4b78-9825-21bd836c6dee.jpeg#align=left&amp;display=inline&amp;height=538&amp;margin=%5Bobject%20Object%5D&amp;name=yuque_diagram.jpg&amp;originHeight=2050&amp;originWidth=1697&amp;size=226328&amp;status=done&amp;style=stroke&amp;width=445" alt="yuque_diagram.jpg"></p>
<h2 id="Hermite-插值"><a href="#Hermite-插值" class="headerlink" title="Hermite 插值"></a>Hermite 插值</h2><p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1616633702383-7da5e39f-e899-4034-acdd-7e0c417a1487.jpeg#align=left&amp;display=inline&amp;height=667&amp;margin=%5Bobject%20Object%5D&amp;name=yuque_diagram.jpg&amp;originHeight=2610&amp;originWidth=1796&amp;size=225117&amp;status=done&amp;style=stroke&amp;width=459" alt="yuque_diagram.jpg"></p>
<h2 id="最小二乘算法"><a href="#最小二乘算法" class="headerlink" title="最小二乘算法"></a>最小二乘算法</h2><p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1616633760214-e8df0fdd-19f5-44a7-97dc-7d3e5b05e0d3.jpeg#align=left&amp;display=inline&amp;height=819&amp;margin=%5Bobject%20Object%5D&amp;name=yuque_diagram.jpg&amp;originHeight=2177&amp;originWidth=1380&amp;size=162211&amp;status=done&amp;style=stroke&amp;width=519" alt="yuque_diagram.jpg"></p>
<h2 id="正态分布表复现"><a href="#正态分布表复现" class="headerlink" title="正态分布表复现"></a>正态分布表复现</h2><p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1616633788535-61ef6425-b386-4a92-b3d8-44a136c3ee88.jpeg#align=left&amp;display=inline&amp;height=1027&amp;margin=%5Bobject%20Object%5D&amp;name=yuque_diagram.jpg&amp;originHeight=1748&amp;originWidth=708&amp;size=98744&amp;status=done&amp;style=stroke&amp;width=416" alt="yuque_diagram.jpg"></p>
]]></content:encoded>
      <comments>https://www.wztlink1013.com/blog/hizlew/#comments</comments>
    </item>
    
    <item>
      <title><![CDATA[布局之rem和响应式]]></title>
      <link>https://www.wztlink1013.com/blog/rm1i2lgosgh2/</link>
      <guid>https://www.wztlink1013.com/blog/rm1i2lgosgh2/</guid>
      <pubDate>Tue Mar 09 2021 23:12:06 GMT+0000 (Coordinated Universal Time)</pubDate>
      <description>
      <![CDATA[<h2 id="rem"><a href="#rem" class="headerlink" title="rem"></a>rem</h2><h3 id="rem-单位"><a href="#rem-单位" class="headerlink" title="rem 单位"><]]>
      </description>
      <content:encoded><![CDATA[<h2 id="rem"><a href="#rem" class="headerlink" title="rem"></a>rem</h2><h3 id="rem-单位"><a href="#rem-单位" class="headerlink" title="rem 单位"></a>rem 单位</h3><p>rem (root em)是一个相对单位，类似于 em，em 是父元素字体大小。</p>
<p><div style="background: #FFF3F3;padding:10px;border: 1px solid #DEB8BE;border-radius:5px;margin-bottom:5px;">不同的是rem的基准是相对于html元素的字体大小。</div><br>比如，根元素（html）设置font-size=12px; 非根元素设置width:2rem; 则换成px表示就是24px。</p>
<pre><code class="css">/* 根html 为 12px */
html {
   font-size: 12px;
}
/* 此时 div 的字体大小就是 24px */       
div {
    font-size: 2rem;
}
</code></pre>
<p>rem的优势：父元素文字大小可能不一致， 但是整个页面只有一个html，可以很好来控制整个页面的元素大小。</p>
<h3 id="rem-适配方案"><a href="#rem-适配方案" class="headerlink" title="rem 适配方案"></a>rem 适配方案</h3><p>1.让一些不能等比自适应的元素，达到当设备尺寸发生改变的时候，等比例适配当前设备。 2.使用媒体查询根据不同设备按比例设置 html 的字体大小，然后页面元素使用 rem 做尺寸单位，当 html 字体大小变化元素尺寸也会发生变化，从而达到等比缩放的适配。<br>技术方案：<br>1.less+rem+媒体查询<br>2.lflexible.js+rem<br>总结：<br>两种方案现在都存在。<br>方案 2 更简单，现阶段大家无需了解里面的 js 代码。</p>
<h3 id="rem-适配方案-1"><a href="#rem-适配方案-1" class="headerlink" title="rem 适配方案 1"></a>rem 适配方案 1</h3><p>① 假设设计稿是 750px<br>② 假设我们把整个屏幕划分为 15 等份（划分标准不一可以是 20 份也可以是 10 等份）<br>③ 每一份作为 html 字体大小，这里就是 50px<br>④ 那么在 320px 设备的时候，字体大小为 320/15 就是 21.33px<br>⑤ 用我们页面元素的大小除以不同的 html 字体大小会发现他们比例还是相同的<br>⑥ 比如我们以 750 为标准设计稿<br>⑦ 一个 100_100 像素的页面元素在 750 屏幕下， 就是 100/ 50 转换为 rem 是 2rem_2rem 比例是 1 比 1<br>⑧320 屏幕下， html 字体大小为 21.33 则 2rem= 42.66px 此时宽和高都是 42.66 但是宽和高的比例还是 1 比 1<br>⑨ 但是已经能实现不同屏幕下 页面元素盒子等比例缩放的效果<br>总结：<br>① 最后的公式：页面元素的 rem 值 = 页面元素值（px） / （屏幕宽度 / 划分的份数）<br>② 屏幕宽度/划分的份数就是 htmlfont-size 的大小<br>③ 或者：页面元素的 rem 值 = 页面元素值（px） / html font-size 字体大小</p>
<h3 id="苏宁首页"><a href="#苏宁首页" class="headerlink" title="苏宁首页"></a>苏宁首页</h3><p>苏宁首页地址 ：<a href="m.suning.com">苏宁首页</a><br>1、 技术选型<br>方案：我们采取单独制作移动页面方案<br>技术：布局采取 rem 适配布局（less + rem + 媒体查询）<br>设计图： 本设计图采用 750px 设计尺寸<br>2、搭建文件结构<br><img src="https://cdn.nlark.com/yuque/0/2021/jpg/1484158/1615360325682-7e3f3397-a6e1-47eb-9774-d632ea98c710.jpg#align=left&amp;display=inline&amp;height=263&amp;margin=%5Bobject%20Object%5D&amp;originHeight=263&amp;originWidth=466&amp;status=done&amp;style=stroke&amp;width=466" alt><br>3、设置视口标签以及引入初始化样式</p>
<pre><code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no,         initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt;
&lt;link rel=&quot;stylesheet&quot; href=&quot;css/normalize.css&quot;&gt;
</code></pre><p>4、设置公共 common.less 文件</p>
<ul>
<li>新建 common.less 设置好最常见的屏幕尺寸，利用媒体查询设置不同的 html 字体大小，因为除了首页其他页面也需要</li>
<li>我们关心的尺寸有 320px、360px、375px、384px、400px、414px、424px、480px、540px、720px、750px</li>
<li>划分的份数我们定为 15 等份</li>
<li>因为我们 pc 端也可以打开我们苏宁移动端首页，我们默认 html 字体大小为 50px，注意这句话写到最上面</li>
</ul>
<h3 id="rem-适配方案-2"><a href="#rem-适配方案-2" class="headerlink" title="rem 适配方案 2"></a>rem 适配方案 2</h3><p>手机淘宝团队出的简洁高效 移动端适配库<br>我们再也不需要在写不同屏幕的媒体查询，因为里面 js 做了处理<br>它的原理是把当前设备划分为 10 等份，但是不同设备下，比例还是一致的。<br>我们要做的，就是确定好我们当前设备的 html 文字大小就可以了<br>比如当前设计稿是 750px， 那么我们只需要把 html 文字大小设置为 75px(750px / 10) 就可以<br>里面页面元素 rem 值： 页面元素的 px 值 / 75<br>剩余的，让 flexible.js 来去算<br>github 地址：<a href="https://link.jianshu.com/?t=https://github.com/amfe/lib-flexible" target="_blank" rel="noopener">https://github.com/amfe/lib-flexible</a><br>总结：<br>因为 flexible 是默认将屏幕分为 10 等分<br>但是当屏幕大于 750 的时候希望不要再去重置 html 字体了<br>所以要自己通过媒体查询设置一下<br>并且要把权重提到最高<br>VSCode px 转换 rem 插件 cssrem<br>因为 cssrem 中 css 自动转化为 rem 是参照默认插件的 16 转换的所以需要自己配置<br><img src="https://cdn.nlark.com/yuque/0/2021/jpg/1484158/1615360325777-63efe343-7fb5-46ff-a976-757d50df3556.jpg#align=left&amp;display=inline&amp;height=536&amp;margin=%5Bobject%20Object%5D&amp;originHeight=536&amp;originWidth=713&amp;status=done&amp;style=stroke&amp;width=713" alt><img src="https://cdn.nlark.com/yuque/0/2021/jpg/1484158/1615360325891-a1820b7f-bdbf-47e8-b04b-723db8329cf8.jpg#align=left&amp;display=inline&amp;height=544&amp;margin=%5Bobject%20Object%5D&amp;originHeight=544&amp;originWidth=566&amp;status=done&amp;style=stroke&amp;width=566" alt></p>
<h2 id="响应式开发原理"><a href="#响应式开发原理" class="headerlink" title="响应式开发原理"></a>响应式开发原理</h2><h3 id="响应式开发原理success"><a href="#响应式开发原理success" class="headerlink" title="响应式开发原理success"></a>响应式开发原理success</h3><p>就是使用媒体查询针对不同宽度的设备进行布局和样式的设置，从而适配不同设备的目的<br>设备的划分情况</p>
<ul>
<li>小于 768 的为超小屏幕（手机）</li>
<li>768~992 之间的为小屏设备（平板）</li>
<li>992~1200 的中等屏幕（桌面显示器）</li>
<li>大于 1200 的宽屏设备（大桌面显示器）</li>
</ul>
<h3 id="响应式布局容器"><a href="#响应式布局容器" class="headerlink" title="响应式布局容器"></a>响应式布局容器</h3><p><div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">响应式需要一个父级做为布局容器，来配合子级元素来实现变化效果。<br>原理就是在不同屏幕下，通过媒体查询来改变这个布局容器的大小，再改变里面子元素的排列方式和大小，从而实现不同屏幕下，看到不同的页面布局和样式变化。</div><br>父容器版心的尺寸划分</p>
<ul>
<li>超小屏幕（手机，小于 768px）：设置宽度为 100%</li>
<li>小屏幕（平板，大于等于 768px）：设置宽度为 750px</li>
<li>中等屏幕（桌面显示器，大于等于 992px）：宽度设置为 970px</li>
<li>大屏幕（大桌面显示器，大于等于 1200px）：宽度设置为 1170px</li>
</ul>
<p>但是我们也可以根据实际情况自己定义划分</p>
]]></content:encoded>
      <comments>https://www.wztlink1013.com/blog/rm1i2lgosgh2/#comments</comments>
    </item>
    
    <item>
      <title><![CDATA[布局之flex]]></title>
      <link>https://www.wztlink1013.com/blog/ogynfghwtsa7/</link>
      <guid>https://www.wztlink1013.com/blog/ogynfghwtsa7/</guid>
      <pubDate>Tue Mar 09 2021 23:08:56 GMT+0000 (Coordinated Universal Time)</pubDate>
      <description>
      <![CDATA[<h2 id="1-0-传统布局和-flex-布局对比"><a href="#1-0-传统布局和-flex-布局对比" class="headerlink" title="1.0 传统布局和 flex 布局对比"></a>1.0 传统布局和 flex 布局对比</h2><h3 i]]>
      </description>
      <content:encoded><![CDATA[<h2 id="1-0-传统布局和-flex-布局对比"><a href="#1-0-传统布局和-flex-布局对比" class="headerlink" title="1.0 传统布局和 flex 布局对比"></a>1.0 传统布局和 flex 布局对比</h2><h3 id="1-1-传统布局"><a href="#1-1-传统布局" class="headerlink" title="1.1 传统布局"></a>1.1 传统布局</h3><ul>
<li>兼容性好</li>
<li>布局繁琐</li>
<li>局限性，不能再移动端很好的布局</li>
</ul>
<h3 id="1-2-flex-布局"><a href="#1-2-flex-布局" class="headerlink" title="1.2 flex 布局"></a>1.2 flex 布局</h3><ul>
<li>操作方便，布局极其简单，移动端使用比较广泛</li>
<li>pc 端浏览器支持情况比较差</li>
<li>IE11 或更低版本不支持 flex 或仅支持部分</li>
</ul>
<h3 id="1-3-建议"><a href="#1-3-建议" class="headerlink" title="1.3 建议"></a>1.3 建议</h3><ul>
<li>如果是 pc 端页面布局，还是采用传统方式</li>
<li>如果是移动端或者是不考虑兼容的 pc 则采用 flex</li>
</ul>
<h2 id="2-0-flex-布局原理"><a href="#2-0-flex-布局原理" class="headerlink" title="2.0 flex 布局原理"></a>2.0 flex 布局原理</h2><ul>
<li>flex 是 flexible Box 的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性，任何一个容器都可以指定为 flex 布局。</li>
<li>当我们为父盒子设为 flex 布局以后，子元素的 float、clear 和 vertical-align 属性将失效。</li>
<li>flex 布局又叫伸缩布局 、弹性布局 、伸缩盒布局 、弹性盒布局</li>
<li>采用 Flex 布局的元素，称为 Flex 容器（flex</li>
</ul>
<p>container），简称”容器”。它的所有子元素自动成为容器成员，称为 Flex 项目（flex<br>item），简称”项目”。<br><strong>总结</strong>：就是通过给父盒子添加 flex 属性，来控制子盒子的位置和排列方式</p>
<h2 id="3-0-父项常见属性"><a href="#3-0-父项常见属性" class="headerlink" title="3.0 父项常见属性"></a>3.0 父项常见属性</h2><ul>
<li>flex-direction：设置主轴的方向</li>
<li>justify-content：设置主轴上的子元素排列方式</li>
<li>flex-wrap：设置子元素是否换行</li>
<li>align-content：设置侧轴上的子元素的排列方式（多行）</li>
<li>align-items：设置侧轴上的子元素排列方式（单行）</li>
<li>flex-flow：复合属性，相当于同时设置了 flex-direction 和 flex-wrap</li>
</ul>
<h3 id="3-1-flex-direction-设置主轴的方向"><a href="#3-1-flex-direction-设置主轴的方向" class="headerlink" title="3.1 flex-direction 设置主轴的方向"></a>3.1 flex-direction 设置主轴的方向</h3><ul>
<li>在 flex 布局中，是分为主轴和侧轴两个方向，同样的叫法有 ： 行和列、x 轴和 y 轴</li>
<li>默认主轴方向就是 x 轴方向，水平向右</li>
<li>默认侧轴方向就是 y 轴方向，水平向下</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1615561167817-709457f2-58f3-47b2-82f2-36a27c5ffbac.png#align=left&amp;display=inline&amp;height=227&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=453&amp;originWidth=970&amp;size=44867&amp;status=done&amp;style=none&amp;width=485" alt="image.png"></p>
<ul>
<li>注意： 主轴和侧轴是会变化的，就看 flex-direction 设置谁为主轴，剩下的就是侧轴。而我们的子元素是跟着主轴来排列的</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1615561179498-b513941e-0741-403e-a156-bf3794692e74.png#align=left&amp;display=inline&amp;height=182&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=363&amp;originWidth=927&amp;size=149158&amp;status=done&amp;style=none&amp;width=463.5" alt="image.png"></p>
<h3 id="3-2-justify-content-设置主轴上的子元素排列方式"><a href="#3-2-justify-content-设置主轴上的子元素排列方式" class="headerlink" title="3.2 justify-content 设置主轴上的子元素排列方式"></a>3.2 justify-content 设置主轴上的子元素排列方式</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1615561189187-37fb2250-6a7a-4b7e-8da7-8bfbed134942.png#align=left&amp;display=inline&amp;height=216&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=432&amp;originWidth=1228&amp;size=383001&amp;status=done&amp;style=none&amp;width=614" alt="image.png"></p>
<h3 id="3-3-flex-wrap-设置是否换行"><a href="#3-3-flex-wrap-设置是否换行" class="headerlink" title="3.3 flex-wrap 设置是否换行"></a>3.3 flex-wrap 设置是否换行</h3><ul>
<li>默认情况下，项目都排在一条线（又称”轴线”）上。flex-wrap 属性定义，flex 布局中默认是不换行的。</li>
<li>nowrap 不换行</li>
<li>wrap 换行</li>
</ul>
<h3 id="3-4-align-items-设置侧轴上的子元素排列方式（单行-）"><a href="#3-4-align-items-设置侧轴上的子元素排列方式（单行-）" class="headerlink" title="3.4 align-items 设置侧轴上的子元素排列方式（单行 ）"></a>3.4 align-items 设置侧轴上的子元素排列方式（单行 ）</h3><ul>
<li>该属性是控制子项在侧轴（默认是 y 轴）上的排列方式 在子项为单项（单行）的时候使用</li>
<li>flex-start 从头部开始</li>
<li>flex-end 从尾部开始</li>
<li>center 居中显示</li>
<li>stretch 拉伸</li>
</ul>
<h3 id="3-5-align-content-设置侧轴上的子元素的排列方式（多行）"><a href="#3-5-align-content-设置侧轴上的子元素的排列方式（多行）" class="headerlink" title="3.5 align-content 设置侧轴上的子元素的排列方式（多行）"></a>3.5 align-content 设置侧轴上的子元素的排列方式（多行）</h3><p>设置子项在侧轴上的排列方式 并且只能用于子项出现 换行 的情况（多行），在单行下是没有效果的。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1615561203043-769de419-37f6-47ac-8a01-7353fb2fbcd4.png#align=left&amp;display=inline&amp;height=271&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=541&amp;originWidth=1084&amp;size=429763&amp;status=done&amp;style=none&amp;width=542" alt="image.png"></p>
<h3 id="3-6-align-content-和-align-items-区别"><a href="#3-6-align-content-和-align-items-区别" class="headerlink" title="3.6 align-content 和 align-items 区别"></a>3.6 align-content 和 align-items 区别</h3><ul>
<li>align-items 适用于单行情况下， 只有上对齐、下对齐、居中和 拉伸</li>
<li>align-content 适应于换行（多行）的情况下（单行情况下无效）， 可以设置 上对齐、下对齐、居中、拉伸以及平均分配剩余空间等属性值。</li>
<li>总结就是单行找 align-items 多行找 align-content</li>
</ul>
<h3 id="3-7-flex-flow-属性是-flex-direction-和-flex-wrap-属性的复合属性"><a href="#3-7-flex-flow-属性是-flex-direction-和-flex-wrap-属性的复合属性" class="headerlink" title="3.7 flex-flow 属性是 flex-direction 和 flex-wrap 属性的复合属性"></a>3.7 flex-flow 属性是 flex-direction 和 flex-wrap 属性的复合属性</h3><pre><code>flex-flow:row wrap;
</code></pre><h2 id="4-0-flex-布局子项常见属性"><a href="#4-0-flex-布局子项常见属性" class="headerlink" title="4.0 flex 布局子项常见属性"></a>4.0 flex 布局子项常见属性</h2><ul>
<li>flex 子项目占的份数</li>
<li>align-self 控制子项自己在侧轴的排列方式</li>
<li>order 属性定义子项的排列顺序（前后顺序）</li>
</ul>
<h3 id="4-1-flex-属性"><a href="#4-1-flex-属性" class="headerlink" title="4.1 flex 属性"></a>4.1 flex 属性</h3><p>flex 属性定义子项目分配剩余空间，用 flex 来表示占多少份数。</p>
<pre><code>.item {
    flex: &lt;number&gt;; /* 默认值 0 */
}
</code></pre><h3 id="4-2-align-self-控制子项自己在侧轴上的排列方式"><a href="#4-2-align-self-控制子项自己在侧轴上的排列方式" class="headerlink" title="4.2 align-self 控制子项自己在侧轴上的排列方式"></a>4.2 align-self 控制子项自己在侧轴上的排列方式</h3><p>align-self 属性允许单个项目有与其他项目不一样的对齐方式，可覆盖 align-items 属性。<br>默认值为 auto，表示继承父元素的 align-items 属性，如果没有父元素，则等同于 stretch。</p>
<pre><code>span:nth-child(2) {
      /* 设置自己在侧轴上的排列方式 */
      align-self: flex-end;
}
</code></pre><h3 id="4-3-order-属性定义项目的排列顺序"><a href="#4-3-order-属性定义项目的排列顺序" class="headerlink" title="4.3 order 属性定义项目的排列顺序"></a>4.3 order 属性定义项目的排列顺序</h3><p>数值越小，排列越靠前，默认为 0。<br>注意：和 z-index 不一样。</p>
<pre><code>.item {
    order: &lt;number&gt;;
}
</code></pre><h2 id="5-0-携程网首页案例制作"><a href="#5-0-携程网首页案例制作" class="headerlink" title="5.0 携程网首页案例制作"></a>5.0 携程网首页案例制作</h2><p>携程网链接：<a href="http://m.ctrip.com" target="_blank" rel="noopener">http://m.ctrip.com</a> 1.技术选型<br>方案：我们采取单独制作移动页面方案<br>技术：布局采取 flex 布局 2.搭建相关文件夹<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1615561216425-7cb96807-082c-4f58-a8e6-7fd089ad6c35.png#align=left&amp;display=inline&amp;height=140&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=279&amp;originWidth=388&amp;size=95052&amp;status=done&amp;style=none&amp;width=194" alt="image.png"> 3.设置视口标签以及引入初始化样式</p>
<pre><code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no,initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt;
&lt;link rel=&quot;stylesheet&quot; href=&quot;css/normalize.css&quot;&gt;
&lt;link rel=&quot;stylesheet&quot; href=&quot;css/index.css&quot;&gt;
</code></pre><p>4.常用初始化样式</p>
<pre><code>body {
  max-width: 540px;
  min-width: 320px;
  margin: 0 auto;
  font: normal 14px/1.5 Tahoma,&quot;Lucida Grande&quot;,Verdana,&quot;Microsoft Yahei&quot;,STXihei,hei;
  color: #000;
  background: #f2f2f2;
  overflow-x: hidden;
  -webkit-tap-highlight-color: transparent;
}
</code></pre><p>5.模块名字划分<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1615561231614-a9ccc256-3219-41a4-a610-588d72137519.png#align=left&amp;display=inline&amp;height=404&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=808&amp;originWidth=1035&amp;size=777724&amp;status=done&amp;style=none&amp;width=517.5" alt="image.png"></p>
]]></content:encoded>
      <comments>https://www.wztlink1013.com/blog/ogynfghwtsa7/#comments</comments>
    </item>
    
    <item>
      <title><![CDATA[布局之流式（百分比）]]></title>
      <link>https://www.wztlink1013.com/blog/oxqtosvrfeg8/</link>
      <guid>https://www.wztlink1013.com/blog/oxqtosvrfeg8/</guid>
      <pubDate>Tue Mar 09 2021 23:08:56 GMT+0000 (Coordinated Universal Time)</pubDate>
      <description>
      <![CDATA[<h3 id="移动端基础"><a href="#移动端基础" class="headerlink" title="移动端基础"></a>移动端基础</h3><h4 id="浏览器现状"><a href="#浏览器现状" class="headerlink" title="浏览器]]>
      </description>
      <content:encoded><![CDATA[<h3 id="移动端基础"><a href="#移动端基础" class="headerlink" title="移动端基础"></a>移动端基础</h3><h4 id="浏览器现状"><a href="#浏览器现状" class="headerlink" title="浏览器现状"></a>浏览器现状</h4><div style="background: #FFFBE6;padding:10px;border: 1px solid #C3C3C3;border-radius:5px;margin-bottom:5px;">手机浏览器大多都是根据Webkit修改过来的内核，国内尚无自主研发的内核，就像国内的手机操作系统都是基于Android修改开发的一样，<strong>兼容移动端主流浏览器，处理Webkit内核浏览器即可。</strong></div>

<h4 id="手机屏幕的现状"><a href="#手机屏幕的现状" class="headerlink" title="手机屏幕的现状"></a>手机屏幕的现状</h4><ul>
<li>移动端设备屏幕尺寸非常多，碎片化严重。</li>
<li>Android 设备有多种分辨率：480x800, 480x854, 540x960, 720x1280，1080x1920 等，还有传说中的 2K，4k 屏。</li>
<li>近年来 iPhone 的碎片化也加剧了，其设备的主要分辨率有：640x960, 640x1136, 750x1334, 1242x2208 等。</li>
<li>作为开发者无需关注这些分辨率，因为我们常用的尺寸单位是 px 。</li>
</ul>
<h4 id="常见移动端屏幕尺寸"><a href="#常见移动端屏幕尺寸" class="headerlink" title="常见移动端屏幕尺寸"></a>常见移动端屏幕尺寸</h4><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1615618625659-e44f28da-3b19-49cc-8379-9154b1274ccf.png#align=left&amp;display=inline&amp;height=220&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=439&amp;originWidth=711&amp;size=153953&amp;status=done&amp;style=none&amp;width=355.5" alt="image.png"></p>
<h4 id="移动端调试方法"><a href="#移动端调试方法" class="headerlink" title="移动端调试方法"></a>移动端调试方法</h4><ul>
<li>Chrome DevTools（谷歌浏览器）的模拟手机调试</li>
<li>搭建本地 web 服务器，手机和服务器一个局域网内，通过手机访问服务器</li>
<li>使用外网服务器，直接 IP 或域名访问</li>
</ul>
<h3 id="视口"><a href="#视口" class="headerlink" title="视口"></a>视口</h3><p>视口（viewport）就是浏览器显示页面内容的屏幕区域。 视口可以分为布局视口、视觉视口和理想视口</p>
<h4 id="布局视口-layout-viewport"><a href="#布局视口-layout-viewport" class="headerlink" title="布局视口 layout viewport"></a>布局视口 layout viewport</h4><p>一般移动设备的浏览器都默认设置了一个布局视口，用于解决早期的 PC 端页面在手机上显示的问题。<br>iOS, Android 基本都将这个视口分辨率设置为 980px，所以 PC 上的网页大多都能在手机上呈现，只不过元素看上去很小，一般默认可以通过手动缩放网页。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1615360134842-071e03d8-f513-4d2c-ba28-53f0bd738ea1.png#align=left&amp;display=inline&amp;height=285&amp;margin=%5Bobject%20Object%5D&amp;originHeight=285&amp;originWidth=336&amp;status=done&amp;style=none&amp;width=336" alt></p>
<h4 id="视觉视口-visual-viewport"><a href="#视觉视口-visual-viewport" class="headerlink" title="视觉视口 visual viewport"></a>视觉视口 visual viewport</h4><p>字面意思，它是用户正在看到的网站的区域。注意：是网站的区域。<br>我们可以通过缩放去操作视觉视口，但不会影响布局视口，布局视口仍保持原来的宽度。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1615360134917-2ac567e7-2ed8-4d14-8281-86c3d36db607.png#align=left&amp;display=inline&amp;height=292&amp;margin=%5Bobject%20Object%5D&amp;originHeight=292&amp;originWidth=323&amp;status=done&amp;style=none&amp;width=323" alt></p>
<h4 id="理想视口-ideal-viewport"><a href="#理想视口-ideal-viewport" class="headerlink" title="理想视口 ideal viewport"></a>理想视口 ideal viewport</h4><p>为了使网站在移动端有最理想的浏览和阅读宽度而设定<br>理想视口，对设备来讲，是最理想的视口尺寸<br>需要手动添写 meta 视口标签通知浏览器操作<br>meta 视口标签的主要目的：布局视口的宽度应该与理想视口的宽度一致，简单理解就是设备有多宽，我们布局的视口就多宽<br><strong>总结：我们开发最终会用理想视口，而理想视口就是将布局视口的宽度修改为视觉视口</strong></p>
<h4 id="meta-标签-viewport"><a href="#meta-标签-viewport" class="headerlink" title="meta 标签 viewport"></a>meta 标签 viewport</h4><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1615360134988-de179521-dfc1-419f-a1b6-5e45b5b40096.png#align=left&amp;display=inline&amp;height=451&amp;margin=%5Bobject%20Object%5D&amp;originHeight=451&amp;originWidth=1043&amp;status=done&amp;style=none&amp;width=1043" alt><br>最标准的 viewport 设置</p>
<ul>
<li>视口宽度和设备保持一致</li>
<li>视口的默认缩放比例 1.0</li>
<li>不允许用户自行缩放</li>
<li>最大允许的缩放比例 1.0</li>
<li>最小允许的缩放比例 1.0</li>
</ul>
<h3 id="二倍图"><a href="#二倍图" class="headerlink" title="二倍图"></a>二倍图</h3><h4 id="物理像素-amp-物理像素比"><a href="#物理像素-amp-物理像素比" class="headerlink" title="物理像素&amp;物理像素比"></a>物理像素&amp;物理像素比</h4><p>物理像素点指的是屏幕显示的最小颗粒，是物理真实存在的。这是厂商在出厂时就设置好了,比如苹果 6 是 750<em> 1334<br>我们开发时候的 1px 不是一定等于 1 个物理像素的<br>一个 px 的能显示的物理像素点的个数，称为物理像素比或屏幕像素比<br>如果把 1 张 100</em>100 的图片放到手机里面会按照物理像素比给我们缩放<br>lRetina（视网膜屏幕）是一种显示技术，可以将把更多的物理像素点压缩至一块屏幕里，从而达到更高的分辨率，并提高屏幕显示的细腻程度。<br>对于一张 50px * 50px 的图片,在手机或 Retina 屏中打开，按照刚才的物理像素比会放大倍数，这样会造成图片模糊<br>在标准的 viewport 设置中，使用倍图来提高图片质量，解决在高清设备中的模糊问题<br>通常使用二倍图， 因为 iPhone 6 的影响背景图片 注意缩放问题</p>
<h4 id="background-size"><a href="#background-size" class="headerlink" title="background-size"></a>background-size</h4><p>background-size 属性规定背景图像的尺寸</p>
<pre><code class="css">background-size: 背景图片宽度 背景图片高度;
</code></pre>
<p>单位： 长度|百分比|cover|contain;<br>cover 把背景图像扩展至足够大，以使背景图像完全覆盖背景区域。<br>contain 把图像图像扩展至最大尺寸，以使其宽度和高度完全适应内容区域</p>
<h2 id="移动开发选择和技术解决方案"><a href="#移动开发选择和技术解决方案" class="headerlink" title="移动开发选择和技术解决方案"></a>移动开发选择和技术解决方案</h2><h3 id="移动端主流方案"><a href="#移动端主流方案" class="headerlink" title="移动端主流方案"></a>移动端主流方案</h3><div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">单独制作移动端页面（主流）</div><br>通常情况下，网址域名前面加 m(mobile)<br>可以打开移动端。通过判断设备，如果是移动设备打开，则跳到移动端页面。<br>也就是说，PC端和移动端为两套网站，pc端是pc断的样式，移动端在写一套，专门针对移动端适配的一套网站<br><div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">响应式页面兼容移动端（其次）</div><br>响应式网站：即pc和移动端共用一套网站，只不过在不同屏幕下，样式会自动适配<br><br>### 移动端技术解决方案<br><br><div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">移动端浏览器兼容问题</div><br>移动端浏览器基本以 webkit 内核为主，因此我们就考虑webkit兼容性问题。<br>我们可以放心使用 H5 标签和 CSS3 样式。<br>同时我们浏览器的私有前缀我们只需要考虑添加 webkit 即可<br><div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">移动端公共样式</div><br>移动端 CSS 初始化推荐使用 normalize.css/<br>Normalize.css：保护了有价值的默认值<br>Normalize.css：修复了浏览器的bug<br>Normalize.css：是模块化的<br>Normalize.css：拥有详细的文档<br>官网地址： <a href="http://necolas.github.io/normalize.css/" target="_blank" rel="noopener">http://necolas.github.io/normalize.css/</a><br><br>### 大都使用 CSS3 盒子模型 box-sizing<br><br><div style="background: #FFF3F3;padding:10px;border: 1px solid #DEB8BE;border-radius:5px;margin-bottom:5px;">传统模式宽度计算：盒子的宽度 = CSS中设置的width + border + padding</div>success<br>CSS3盒子模型：盒子的宽度=  CSS中设置的宽度width 里面包含了 border 和 padding<br>也就是说，我们的CSS3中的盒子模型， padding 和 border 不会撑大盒子了<br><code>css
/*CSS3盒子模型*/
box-sizing: border-box;
/*传统盒子模型*/
box-sizing: content-box;</code><br>移动端可以全部CSS3 盒子模型<br><div style="background: #FFF3F3;padding:10px;border: 1px solid #DEB8BE;border-radius:5px;margin-bottom:5px;">PC端如果完全需要兼容，我们就用传统模式，如果不考虑兼容性，我们就选择 CSS3 盒子模型</div>

<h3 id="移动端特殊样式"><a href="#移动端特殊样式" class="headerlink" title="移动端特殊样式"></a>移动端特殊样式</h3><pre><code class="css">/*CSS3盒子模型*/
box-sizing: border-box;
-webkit-box-sizing: border-box;
/*点击高亮我们需要清除清除  设置为transparent 完成透明*/
-webkit-tap-highlight-color: transparent;
/*在移动端浏览器默认的外观在iOS上加上这个属性才能给按钮和输入框自定义样式*/
-webkit-appearance: none;
/*禁用长按页面时的弹出菜单*/
img,
a {
  -webkit-touch-callout: none;
}
</code></pre>
<h2 id="移动端常见布局"><a href="#移动端常见布局" class="headerlink" title="移动端常见布局"></a>移动端常见布局</h2><h3 id="移动端单独制作success"><a href="#移动端单独制作success" class="headerlink" title="移动端单独制作success"></a>移动端单独制作success</h3><p>流式布局（百分比布局）<br>流式布局，就是百分比布局，也称非固定像素布局。通过盒子的宽度设置成百分比来根据屏幕的宽度来进行伸缩，不受固定像素的限制，内容向两侧填充。流式布局方式是移动 web 开发使用的比较常见的布局方式。</p>
<div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">flex 弹性布局（强烈推荐）</div>

<div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">less+rem+媒体查询布局</div>

<div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">混合布局</div>

<h4 id="5-2-响应式"><a href="#5-2-响应式" class="headerlink" title="5.2 响应式"></a>5.2 响应式</h4><ul>
<li>媒体查询</li>
<li>bootstarp</li>
</ul>
]]></content:encoded>
      <comments>https://www.wztlink1013.com/blog/oxqtosvrfeg8/#comments</comments>
    </item>
    
    <item>
      <title><![CDATA[JAVA当中栈和队列常用方法]]></title>
      <link>https://www.wztlink1013.com/blog/oylyeh/</link>
      <guid>https://www.wztlink1013.com/blog/oylyeh/</guid>
      <pubDate>Tue Mar 09 2021 00:39:27 GMT+0000 (Coordinated Universal Time)</pubDate>
      <description>
      <![CDATA[<blockquote>
<p>Java 里有一个叫做 Stack 的类，却没有叫做 Queue 的类（它是个接口名字）。当需要使用栈时，Java 已不推荐使用 Stack，而是推荐使用更高效的 ArrayDeque；<br>既然 Queue 只是一个接口，当需要使用队列时也就首]]>
      </description>
      <content:encoded><![CDATA[<blockquote>
<p>Java 里有一个叫做 Stack 的类，却没有叫做 Queue 的类（它是个接口名字）。当需要使用栈时，Java 已不推荐使用 Stack，而是推荐使用更高效的 ArrayDeque；<br>既然 Queue 只是一个接口，当需要使用队列时也就首选 ArrayDeque 了（次选是 LinkedList）。</p>
</blockquote>
<h2 id="队列常用方法"><a href="#队列常用方法" class="headerlink" title="队列常用方法"></a>队列常用方法</h2><blockquote>
<p>初始化</p>
</blockquote>
<pre><code class="java">import java.util.LinkedList;
import java.util.Queue;

Queue&lt;Integer&gt; queue_input = new LinkedList&lt;&gt;();
</code></pre>
<table>
<thead>
<tr>
<th>Queue Method</th>
<th>Equivalent Deque Method</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>add(e)</td>
<td>addLast(e)</td>
<td>向队尾插入元素，失败则抛出异常</td>
</tr>
<tr>
<td>offer(e)</td>
<td>offerLast(e)</td>
<td>向队尾插入元素，失败则返回 false，offer(E e)操作是专为容量受限的队列实现而设计的，在大多数实现中，插入操作不会失败</td>
</tr>
<tr>
<td>remove()</td>
<td>removeFirst()</td>
<td>获取并删除队首元素，失败则抛出异常</td>
</tr>
<tr>
<td>poll()</td>
<td>pollFirst()</td>
<td>获取并删除队首元素，失败则返回 null</td>
</tr>
<tr>
<td>element()</td>
<td>getFirst()</td>
<td>获取但不删除队首元素，失败则抛出异常</td>
</tr>
<tr>
<td>peek()</td>
<td>peekFirst()</td>
<td>获取但不删除队首元素，失败则返回 null</td>
</tr>
</tbody>
</table>
<h2 id="栈常用方法"><a href="#栈常用方法" class="headerlink" title="栈常用方法"></a>栈常用方法</h2><table>
<thead>
<tr>
<th>Stack Method</th>
<th>Equivalent Deque Method</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>push(e)</td>
<td>addFirst(e)</td>
<td>向栈顶插入元素，失败则抛出异常</td>
</tr>
<tr>
<td>无</td>
<td>offerFirst(e)</td>
<td>向栈顶插入元素，失败则返回 false</td>
</tr>
<tr>
<td>pop()</td>
<td>removeFirst()</td>
<td>获取并删除栈顶元素，失败则抛出异常</td>
</tr>
<tr>
<td>无</td>
<td>pollFirst()</td>
<td>获取并删除栈顶元素，失败则返回 null</td>
</tr>
<tr>
<td>peek()</td>
<td>peekFirst()</td>
<td>获取但不删除栈顶元素，失败则抛出异常</td>
</tr>
<tr>
<td>无</td>
<td>peekFirst()</td>
<td>获取但不删除栈顶元素，失败则返回 null</td>
</tr>
</tbody>
</table>
<h2 id="关于-ArrayDeque"><a href="#关于-ArrayDeque" class="headerlink" title="关于 ArrayDeque"></a>关于 ArrayDeque</h2><blockquote>
<p>ArrayDeque 和 LinkedList 是 Deque 的两个通用实现，由于官方更推荐使用 AarryDeque 用作栈和队列，<br>从名字可以看出 ArrayDeque 底层通过数组实现，为了满足可以同时在数组两端插入或删除元素的需求，该数组还必须是循环的，即循环数组（circular array），也就是说数组的任何一点都可能被看作起点或者终点。ArrayDeque 是非线程安全的（not thread-safe），当多个线程同时使用的时候，需要程序员手动同步；另外，该容器不允许放入 null 元素。</p>
</blockquote>
<pre><code class="java">import java.util.*;

public class ArrayDequeStack {
    public static void main(String[] args) {
        ArrayDeque stack = new ArrayDeque();
        // 依次将三个元素push入“栈”，先进后出
        stack.push(&quot;疯狂Java讲义&quot;);
        stack.push(&quot;轻量级Java EE企业应用实战&quot;);
        stack.push(&quot;疯狂Android讲义&quot;);
        System.out.println(stack); // [疯狂Android讲义, 轻量级Java EE企业应用实战, 疯狂Java讲义]
        System.out.println(stack.peek()); // 疯狂Android讲义
        System.out.println(stack); // [疯狂Android讲义, 轻量级Java EE企业应用实战, 疯狂Java讲义]
        System.out.println(stack.pop()); // 疯狂Android讲义
        System.out.println(stack);//[轻量级Java EE企业应用实战, 疯狂Java讲义]

        // 当做队列来使用,先进先出
        ArrayDeque queue = new ArrayDeque();
        queue.offer(&quot;疯狂Java讲义&quot;);
        queue.offer(&quot;轻量级JavaEE企业应用实践&quot;);
        queue.offer(&quot;疯狂Android讲义&quot;);
        System.out.println(queue); //[疯狂Java讲义, 轻量级JavaEE企业应用实践, 疯狂Android讲义]
        // 访问队列头部元素，但不将其poll出队列
        System.out.println(queue.peek());
        System.out.println(queue);
        // poll出第一个元素
        System.out.println(queue.poll());
        System.out.println(queue);// [轻量级JavaEE企业应用实践, 疯狂Android讲义]
    }
}
</code></pre>
<pre><code>[疯狂Android讲义, 轻量级Java EE企业应用实战, 疯狂Java讲义]
疯狂Android讲义
[疯狂Android讲义, 轻量级Java EE企业应用实战, 疯狂Java讲义]
疯狂Android讲义
[轻量级Java EE企业应用实战, 疯狂Java讲义]
[疯狂Java讲义, 轻量级JavaEE企业应用实践, 疯狂Android讲义]
疯狂Java讲义
[疯狂Java讲义, 轻量级JavaEE企业应用实践, 疯狂Android讲义]
疯狂Java讲义
[轻量级JavaEE企业应用实践, 疯狂Android讲义]
</code></pre><p>例子参考：<a href="https://www.cnblogs.com/jiqing9006/p/6107491.html" target="_blank" rel="noopener">https://www.cnblogs.com/jiqing9006/p/6107491.html</a></p>
]]></content:encoded>
      <comments>https://www.wztlink1013.com/blog/oylyeh/#comments</comments>
    </item>
    
    <item>
      <title><![CDATA[P225P232. 队列和栈的相互实现]]></title>
      <link>https://www.wztlink1013.com/blog/le21wf/</link>
      <guid>https://www.wztlink1013.com/blog/le21wf/</guid>
      <pubDate>Tue Mar 09 2021 00:28:47 GMT+0000 (Coordinated Universal Time)</pubDate>
      <description>
      <![CDATA[<blockquote>
<p>简单实现一下，熟悉一下写题目，这几天找找状态……<img src="https://cdn.nlark.com/yuque/0/2021/gif/1484158/1615278756585-fb0d9f38-8031-472f-9a19-8545b]]>
      </description>
      <content:encoded><![CDATA[<blockquote>
<p>简单实现一下，熟悉一下写题目，这几天找找状态……<img src="https://cdn.nlark.com/yuque/0/2021/gif/1484158/1615278756585-fb0d9f38-8031-472f-9a19-8545be93a548.gif#align=left&amp;display=inline&amp;height=100&amp;margin=%5Bobject%20Object%5D&amp;name=huaji-6f8ff8999ff5ed9a.gif&amp;originHeight=100&amp;originWidth=100&amp;size=12637&amp;status=done&amp;style=none&amp;width=100" alt="huaji-6f8ff8999ff5ed9a.gif"></p>
</blockquote>
<h2 id="P232-栈实现队列"><a href="#P232-栈实现队列" class="headerlink" title="P232. 栈实现队列"></a>P232. 栈实现队列</h2><pre><code class="java">package com.wztlink1013.problems.leetcode.editor.cn;

// P232.用栈实现队列
// P232.implement-queue-using-stacks
//请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（push、pop、peek、empty）：
//
// 实现 MyQueue 类：
//
//
// void push(int x) 将元素 x 推到队列的末尾
// int pop() 从队列的开头移除并返回元素
// int peek() 返回队列开头的元素
// boolean empty() 如果队列为空，返回 true ；否则，返回 false
//
//
//
//
// 说明：
//
//
// 你只能使用标准的栈操作 —— 也就是只有 push to top, peek/pop from top, size, 和 is empty 操作是合法的。
//
// 你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。
//
//
//
//
// 进阶：
//
//
// 你能否实现每个操作均摊时间复杂度为 O(1) 的队列？换句话说，执行 n 个操作的总时间复杂度为 O(n) ，即使其中一个操作可能花费较长时间。
//
//
//
//
// 示例：
//
//
//输入：
//[&quot;MyQueue&quot;, &quot;push&quot;, &quot;push&quot;, &quot;peek&quot;, &quot;pop&quot;, &quot;empty&quot;]
//[[], [1], [2], [], [], []]
//输出：
//[null, null, null, 1, 1, false]
//
//解释：
//MyQueue myQueue = new MyQueue();
//myQueue.push(1); // queue is: [1]
//myQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue)
//myQueue.peek(); // return 1
//myQueue.pop(); // return 1, queue is [2]
//myQueue.empty(); // return false
//
//
//
//
//
//
//
// 提示：
//
//
// 1 &lt;= x &lt;= 9
// 最多调用 100 次 push、pop、peek 和 empty
// 假设所有操作都是有效的 （例如，一个空的队列不会调用 pop 或者 peek 操作）
//
// Related Topics 栈 设计
// 👍 361 👎 0

import java.util.Stack;

public class P232ImplementQueueUsingStacks{
    public void main(String[] args) {
        MyQueue myQueue = new MyQueue();
        //本地调试需要将MyQueue类和主函数加上静态static修饰字
        //具体解释：https://www.cnblogs.com/dolphin0520/p/3799052.html
        myQueue.push(1); // queue is: [1]
        myQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue)
        myQueue.pop();
        myQueue.peek();
//        myQueue.peek(); // return 1
//        myQueue.pop(); // return 1, queue is [2]
//        myQueue.empty(); // return false
//        System.out.println(myQueue);
    }

//leetcode submit region begin(Prohibit modification and deletion)
class MyQueue {
    Stack&lt;Integer&gt; stack_input = new Stack&lt;&gt;();
    Stack&lt;Integer&gt; stack_output = new Stack&lt;&gt;();
    /** Initialize your data structure here. */
    public MyQueue() {
//        Stack&lt;Integer&gt; stack_input = new Stack&lt;&gt;();
//        Stack&lt;Integer&gt; stack_output = new Stack&lt;&gt;();
    }

    /** Push element x to the back of queue. */
    public void push(int x) {
        stack_input.push(x);
        int temp = stack_input.size();
        if (stack_output.size() == 0) {
            for (int i=0; i&lt;temp; i++){
                stack_output.push(stack_input.pop());
            }
        }
    }

    /** Removes the element from in front of queue and returns that element. */
    public int pop() {
        int temp = stack_input.size();
        if (stack_output.size() == 0) {
            for (int i=0; i&lt;temp; i++){
                stack_output.push(stack_input.pop());
            }
        }
        return stack_output.pop();
    }

    /** Get the front element. */
    public int peek() {
        int temp = stack_input.size();
        if (stack_output.size() == 0) {
            for (int i=0; i&lt;temp; i++){
                stack_output.push(stack_input.pop());
            }
        }
        return stack_output.peek();
    }

    /** Returns whether the queue is empty. */
    public boolean empty() {
        if (stack_input.size() == 0 &amp;&amp; stack_output.size() == 0) {
            return true;
        }
        return false;
    }
}

/**
 * Your MyQueue object will be instantiated and called as such:
 * MyQueue obj = new MyQueue();
 * obj.push(x);
 * int param_2 = obj.pop();
 * int param_3 = obj.peek();
 * boolean param_4 = obj.empty();
 */
//leetcode submit region end(Prohibit modification and deletion)

}
</code></pre>
<h2 id="P225-队列实现栈"><a href="#P225-队列实现栈" class="headerlink" title="P225. 队列实现栈"></a>P225. 队列实现栈</h2><pre><code class="java">package com.wztlink1013.problems.leetcode.editor.cn;

// P225.用队列实现栈
// P225.implement-stack-using-queues
//请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通队列的全部四种操作（push、top、pop 和 empty）。
//
// 实现 MyStack 类：
//
//
// void push(int x) 将元素 x 压入栈顶。
// int pop() 移除并返回栈顶元素。
// int top() 返回栈顶元素。
// boolean empty() 如果栈是空的，返回 true ；否则，返回 false 。
//
//
//
//
// 注意：
//
//
// 你只能使用队列的基本操作 —— 也就是 push to back、peek/pop from front、size 和 is empty 这些操作。
// 你所使用的语言也许不支持队列。 你可以使用 list （列表）或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。
//
//
//
//
// 示例：
//
//
//输入：
//[&quot;MyStack&quot;, &quot;push&quot;, &quot;push&quot;, &quot;top&quot;, &quot;pop&quot;, &quot;empty&quot;]
//[[], [1], [2], [], [], []]
//输出：
//[null, null, null, 2, 2, false]
//
//解释：
//MyStack myStack = new MyStack();
//myStack.push(1);
//myStack.push(2);
//myStack.top(); // 返回 2
//myStack.pop(); // 返回 2
//myStack.empty(); // 返回 False
//
//
//
//
// 提示：
//
//
// 1 &lt;= x &lt;= 9
// 最多调用100 次 push、pop、top 和 empty
// 每次调用 pop 和 top 都保证栈不为空
//
//
//
//
// 进阶：你能否实现每种操作的均摊时间复杂度为 O(1) 的栈？换句话说，执行 n 个操作的总时间复杂度 O(n) ，尽管其中某个操作可能需要比其他操作更长的
//时间。你可以使用两个以上的队列。
// Related Topics 栈 设计
// 👍 291 👎 0


import java.util.LinkedList;
import java.util.Queue;

public class P225ImplementStackUsingQueues{
    public void main(String[] args) {
//        Solution solution = new P225ImplementStackUsingQueues().new Solution();

    }

//leetcode submit region begin(Prohibit modification and deletion)
class MyStack {
    Queue&lt;Integer&gt; queue_input = new LinkedList&lt;&gt;();
    Queue&lt;Integer&gt; queue_output = new LinkedList&lt;&gt;();
    /** Initialize your data structure here. */
    public MyStack() {

    }

    /** Push element x onto stack. */
    public void push(int x) {
        queue_input.add(x);
    }

    /** Removes the element on top of the stack and returns that element. */
    public int pop() {
        int temp_2 = queue_input.size();
        for (int i=0; i&lt;temp_2; i++) {
            queue_output.add(queue_input.remove());
        }
        int temp_3 = queue_output.size();
        for (int i=0; i&lt;temp_3-1; i++) {
            queue_input.add(queue_output.remove());
        }
        return queue_output.remove();
    }

    /** Get the top element. */
    public int top() {
        int top = 0;
        int temp_4 = queue_input.size();
        for (int i=0; i&lt;temp_4; i++) {
            queue_output.add(queue_input.remove());
        }
        int temp_5 = queue_output.size();
        for (int i=0; i&lt;temp_5; i++) {
            if (i == temp_5-1) {
                top = queue_output.element();
            }
            queue_input.add(queue_output.remove());
        }
        return top;
    }

    /** Returns whether the stack is empty. */
    public boolean empty() {
        if (queue_input.size() == 0 &amp;&amp; queue_output.size() == 0) {
            return true;
        }
        return false;
    }
}

/**
 * Your MyStack object will be instantiated and called as such:
 * MyStack obj = new MyStack();
 * obj.push(x);
 * int param_2 = obj.pop();
 * int param_3 = obj.top();
 * boolean param_4 = obj.empty();
 */
//leetcode submit region end(Prohibit modification and deletion)

}
</code></pre>
]]></content:encoded>
      <comments>https://www.wztlink1013.com/blog/le21wf/#comments</comments>
    </item>
    
    <item>
      <title><![CDATA[HTTPS较HTTP安全在哪？]]></title>
      <link>https://www.wztlink1013.com/blog/pl8gro/</link>
      <guid>https://www.wztlink1013.com/blog/pl8gro/</guid>
      <pubDate>Wed Feb 10 2021 07:15:00 GMT+0000 (Coordinated Universal Time)</pubDate>
      <description>
      <![CDATA[HTTPS较HTTP安全在哪？]]>
      
      </description>
      <content:encoded><![CDATA[<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612949716697-1ceb6a5c-fa5e-4129-9c0a-63e01ce75057.png#align=left&amp;display=inline&amp;height=51&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=56&amp;originWidth=615&amp;size=6666&amp;status=done&amp;style=shadow&amp;width=564" alt="image.png"></p>
<h2 id="HTTPS-的精妙之处"><a href="#HTTPS-的精妙之处" class="headerlink" title="HTTPS 的精妙之处"></a>HTTPS 的精妙之处</h2><p>在我写的算法相关文章里面，有一篇 RSA 相关的文章<a href="https://www.wztlink1013.com/blog/ccd10c/">https://www.wztlink1013.com/blog/ccd10c/</a>，里面解释了对称加密和的非对称加密</p>
<p>我觉得 HTTPS 的精妙之处就是在于它同时运用了<strong>对称加密（AES）</strong>和<strong>非对称加密（RSA）</strong>两种加密，下面我解释一下：</p>
<h2 id="HTTP-为何不安全？"><a href="#HTTP-为何不安全？" class="headerlink" title="HTTP 为何不安全？"></a>HTTP 为何不安全？</h2><p>客户端对服务端做出请求，然后服务端做出响应，这个大家都知道，但是 HTTP 是明文传输，我在<a href="https://www.wztlink1013.com/blog/bw80k6/">https://www.wztlink1013.com/blog/bw80k6/</a>这篇文章里面也详细抓包展示了 HTTP 的明文传输<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612946821326-d568e02e-1173-4af4-93c5-539275023ba3.png#align=left&amp;display=inline&amp;height=282&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=563&amp;originWidth=1544&amp;size=287151&amp;status=done&amp;style=stroke&amp;width=772" alt="image.png"><br>这样传输的信息就不安全，攻击者就能轻易得到，进一步讲，得到了就不安全吗？</p>
<ul>
<li>因为假如此时服务端响应给客户端的是很重要的诸如密码或者个人信息之类的敏感信息，就会被窃听</li>
<li>中途截取，将所传输的信息不完整等等</li>
</ul>
<h2 id="HTTPS-安全在哪？精妙之处！"><a href="#HTTPS-安全在哪？精妙之处！" class="headerlink" title="HTTPS 安全在哪？精妙之处！"></a>HTTPS 安全在哪？精妙之处！</h2><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612947167321-69c11c8d-9f8d-4f78-80a9-b2ee1c02e6b8.png#align=left&amp;display=inline&amp;height=259&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=517&amp;originWidth=992&amp;size=373859&amp;status=done&amp;style=stroke&amp;width=496" alt="image.png"><br>由上图所示，HTTPS 的协议栈相较 HTTP 协议栈多了安全层，也就是 SSL(安全套接层)或者 TSL(安全传输层)协议</p>
<ol>
<li><p>客户端向服务端发出一个 https 请求，其中端口位 443</p>
<blockquote>
<p>说明：采用 https 的网站都会有相应的 ssl 证书，在服务器那里，这个证书内容就是颁发的机构、到期时间……，而这个证书的形式就是以公钥的形式存在于服务器的。</p>
</blockquote>
</li>
<li><p>服务端响应给客户端这个证书（公钥的形式）</p>
</li>
<li>客户端解析响应来的公钥，因为需要验证这个 ssl 是不是伪造的还是过期了等等，假如验证不成功，就会如下：</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612948950125-219e56dd-b6cd-4245-8aa5-44ad8e6e381c.png#align=left&amp;display=inline&amp;height=38&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=75&amp;originWidth=605&amp;size=7708&amp;status=done&amp;style=stroke&amp;width=302.5" alt="image.png"></p>
<ol start="4">
<li>然后客户端（浏览器）利用这个公钥随机得出的私钥，然后将这个私钥发给服务端，以后客户端和服务端就可以利用这个密钥来解密双方传来传去的加密信息了<blockquote>
<p>说明：随机的出的私钥并不是那么“随机”，因为要保证不可攻破性，具体可以看我的 RSA 算法相关文章</p>
</blockquote>
</li>
</ol>
<hr>
<ol start="5">
<li>服务端将要展示给客户端的具体信息利用上述私钥来加密</li>
<li>客户端接收到服务端发过来的加密信息，用共同都有的私钥解密查看之<blockquote>
<p>整个过程对外人而言看到的都是加密后的信息，而不是明文</p>
</blockquote>
</li>
</ol>
<p>综上，56 条是采用了 AES 对称加密，而前面是利用 RSA 算法得到私钥</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li>这位博主（数据中心网络工程师）将 SSL 讲解的更加细致，可以常看：<a href="https://cshihong.github.io/2019/05/09/SSL%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/" target="_blank" rel="noopener">SSL/TLS 协议详解</a></li>
</ul>
]]></content:encoded>
      <comments>https://www.wztlink1013.com/blog/pl8gro/#comments</comments>
    </item>
    
    <item>
      <title><![CDATA[博客文章导航]]></title>
      <link>https://www.wztlink1013.com/blog/guide_post_blog/</link>
      <guid>https://www.wztlink1013.com/blog/guide_post_blog/</guid>
      <pubDate>Wed Feb 10 2021 03:58:27 GMT+0000 (Coordinated Universal Time)</pubDate>
      <description>
      <![CDATA[<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616511150992-84e08363-8c33-4ad9-9b64-fcecc6c7eb43.png#align=left&amp;display=in]]>
      </description>
      <content:encoded><![CDATA[<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616511150992-84e08363-8c33-4ad9-9b64-fcecc6c7eb43.png#align=left&amp;display=inline&amp;height=1049&amp;margin=%5Bobject%20Object%5D&amp;name=63045318_p0.png&amp;originHeight=1049&amp;originWidth=1500&amp;size=3119264&amp;status=done&amp;style=none&amp;width=1500" alt="63045318_p0.png"></p>
<blockquote>
<p><a href="https://www.wztlink1013.com/blog/">https://www.wztlink1013.com/blog/</a>本站点为我个人技术博客、学习笔记站点</p>
</blockquote>
<table>
<thead>
<tr>
<th>文章分类</th>
<th>分类描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>Bug</td>
<td>日常学习、工作过程中遇到的问题做一个解决的总结</td>
</tr>
<tr>
<td>Environment</td>
<td>Git、GitHub 等开发工具的使用；开发环境的搭建总结</td>
</tr>
<tr>
<td>Hexo</td>
<td>没少折腾的玩意 ~</td>
</tr>
<tr>
<td>数据科学</td>
<td>Python 数据分析</td>
</tr>
<tr>
<td>数据库</td>
<td>我觉得数据库的知识是一个必须要会的模块，所以单独一个模块</td>
</tr>
<tr>
<td>数据结构</td>
<td>数据结构</td>
</tr>
<tr>
<td>算法</td>
<td>算法</td>
</tr>
<tr>
<td>编程语言</td>
<td>语言只是一个工具，既然是工具，就应该放在一块</td>
</tr>
<tr>
<td>人工智能</td>
<td>机器学习入门时写的几篇文章</td>
</tr>
<tr>
<td>后期制作</td>
<td>大学课程的一些笔记，更新少</td>
</tr>
<tr>
<td>Web 开发</td>
<td>Web 开发技术文章，大多是针对新技术</td>
</tr>
<tr>
<td>计算机系统</td>
<td>计算机操作系统、计算机网络</td>
</tr>
<tr>
<td>计算机结构</td>
<td>计算机组成原理、编译原理</td>
</tr>
<tr>
<td>软件工程</td>
<td>软件工程</td>
</tr>
</tbody>
</table>
<p>**</p>
]]></content:encoded>
      <comments>https://www.wztlink1013.com/blog/guide_post_blog/#comments</comments>
    </item>
    
    <item>
      <title><![CDATA[RSA公钥密码算法]]></title>
      <link>https://www.wztlink1013.com/blog/ccd10c/</link>
      <guid>https://www.wztlink1013.com/blog/ccd10c/</guid>
      <pubDate>Wed Feb 10 2021 02:06:39 GMT+0000 (Coordinated Universal Time)</pubDate>
      <description>
      <![CDATA[<blockquote>
<p>最近利用自己曾经写过的一篇文章『<a href="https://www.wztlink1013.com/blog/bw80k6/">https://www.wztlink1013.com/blog/bw80k6/</a>』（利用一次抓包来复习学习]]>
      </description>
      <content:encoded><![CDATA[<blockquote>
<p>最近利用自己曾经写过的一篇文章『<a href="https://www.wztlink1013.com/blog/bw80k6/">https://www.wztlink1013.com/blog/bw80k6/</a>』（利用一次抓包来复习学习过的计网知识）</p>
</blockquote>
<p>在分析 HTTPS 和 HTTP 这两个协议之间的区别的时候，我感觉 HTTPS 的 SSL(Secure Sockets Layer 安全套接字协议)证书很类似之前老师讲过的 RSA 算法，做此篇文章复习下 RSA 算法和加深 HTTPS 的理解。</p>
<p>在密码学当中，由对称密钥和非对称密钥之分。</p>
<h2 id="对称密钥"><a href="#对称密钥" class="headerlink" title="对称密钥"></a>对称密钥</h2><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612943343546-b8330998-9019-40a1-9759-12b459d5379b.png#align=left&amp;display=inline&amp;height=345&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=690&amp;originWidth=982&amp;size=266245&amp;status=done&amp;style=stroke&amp;width=491" alt="image.png"><br>用一个简单的凯撒密码例子来讲解一下对称密钥：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612943823633-5283daed-a125-46fd-a785-93851daf5269.png#align=left&amp;display=inline&amp;height=325&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=650&amp;originWidth=957&amp;size=205858&amp;status=done&amp;style=stroke&amp;width=478.5" alt="image.png"><br>上图是凯撒密码的定义，先说一下怎么用：</p>
<p>假如张三和李四两个人之间需要传输一段密码 apple，他们之间共同约定使用密钥-3（再上图表示就为 e 字母编程 b 字母了，以此类推），而这个算法是基于<a href="https://zh.wikipedia.org/wiki/%E6%A8%A1%E9%99%A4" target="_blank" rel="noopener">mod 运算</a>（在这里看成是一种加密/解密机制）的。</p>
<p>张三利用 mod 运算加密机制（mod 运算）将 apple 转换位 xmmfb<br>李四利用 mod 运算解密机制（mod 运算）将 xmmfb 转换位 apple</p>
<blockquote>
<p>a 为什么到 x：（0-3）mod26 可以看成（23-26）mod26=23，所以 a 往后退三位还是 x</p>
</blockquote>
<p>上述例子的加密机制和解密机制算法一样（mod 运算），实际上也可以不一样，不做详述。但是可以说名对称加密的密钥都一样，该例子中表现为-3</p>
<h2 id="RSA-公钥密码算法"><a href="#RSA-公钥密码算法" class="headerlink" title="RSA 公钥密码算法"></a>RSA 公钥密码算法</h2><p>RSA 公钥密码算法是非对称加密。</p>
<p>先说一下和上面的对称密钥的不同，很简单，不同之处就是对称密钥只有一个密钥，而非对称密钥有两个（我觉得严谨来说可以有多个，但在这里先局限地说有两个），而且一个叫公钥，一个叫密钥。</p>
<p>还是上面的张三李四例子，就相当于张三这次用公钥来加密 apple 这个单词，加密成一段密文，这段密文<strong>只能由密钥来解密</strong>，即便是你有了公钥，也不能将其解密。</p>
<p>然后来抛出几个问题来分析之：</p>
<blockquote>
<p>【Q1】公钥和密钥怎么来规定呢？我要是一个网络攻击者，我利用公钥来推理出密钥，那我岂不是直接解密了？！</p>
</blockquote>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612945567958-1cd39a87-ba61-4dd8-955e-1a4fc130378d.png#align=left&amp;display=inline&amp;height=290&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=579&amp;originWidth=474&amp;size=117414&amp;status=done&amp;style=stroke&amp;width=237" alt="image.png"><br>具体的相关 mod 运算在此不做详述</p>
<blockquote>
<p>【Q2】算法可靠与否</p>
</blockquote>
<p>为了保证严谨，同时也证明了这种算法的</p>
<ul>
<li>可行性，所计算出来的算法复杂度最高是 4 次方，对计算机而言，可计算</li>
<li>不可攻破，在学界，大数因子分解不可行，或者说，如今的科技还不能轻易的破解</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612945767363-ee62dad7-357d-42d3-a932-78cc10d29866.png#align=left&amp;display=inline&amp;height=337&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=674&amp;originWidth=985&amp;size=269673&amp;status=done&amp;style=stroke&amp;width=492.5" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612945781929-bea0946c-3f24-472d-a4d4-3c40abd83ee3.png#align=left&amp;display=inline&amp;height=244&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=487&amp;originWidth=987&amp;size=177512&amp;status=done&amp;style=stroke&amp;width=493.5" alt="image.png"></p>
]]></content:encoded>
      <comments>https://www.wztlink1013.com/blog/ccd10c/#comments</comments>
    </item>
    
    <item>
      <title><![CDATA[IDEA环境下的Web开发bug汇总]]></title>
      <link>https://www.wztlink1013.com/blog/aiuif3/</link>
      <guid>https://www.wztlink1013.com/blog/aiuif3/</guid>
      <pubDate>Sun Feb 07 2021 23:10:31 GMT+0000 (Coordinated Universal Time)</pubDate>
      <description>
      <![CDATA[<h2 id="Unsupported-major-minor-version-52-0"><a href="#Unsupported-major-minor-version-52-0" class="headerlink" title="Unsupported major.mi]]>
      </description>
      <content:encoded><![CDATA[<h2 id="Unsupported-major-minor-version-52-0"><a href="#Unsupported-major-minor-version-52-0" class="headerlink" title="Unsupported major.minor version 52.0"></a>Unsupported major.minor version 52.0</h2><blockquote>
<p>版本过低</p>
</blockquote>
<pre><code class="java">[2021-02-07 08:25:52,537] Artifact javaweb-blog:war exploded: Error during artifact deployment. See server log for details.
</code></pre>
<pre><code class="java"> java.lang.UnsupportedClassVersionError: com/nic/filter/AdminFilter : Unsupported major.minor version 52.0 (unable to load class com.nic.filter.AdminFilter)
</code></pre>
<p>一直报错，网上找一直是说和 jdk 的版本有关，但是 jdk 的版本尝试更换几个都无效。事实上是 Tomcat 的版本问题，项目开始用的是 Tomcat8.1 升级至 8.5.34 即可（升级 Tomcat9 可以否？会对下兼容吗？trytry）</p>
<h2 id="org-apache-tomcat-util-descriptor-web-WebXml-setVersion-Unknown-version-string-4-0"><a href="#org-apache-tomcat-util-descriptor-web-WebXml-setVersion-Unknown-version-string-4-0" class="headerlink" title="org.apache.tomcat.util.descriptor.web.WebXml.setVersion Unknown version string [4.0]"></a>org.apache.tomcat.util.descriptor.web.WebXml.setVersion Unknown version string [4.0]</h2><blockquote>
<p>warning：4.0 太高</p>
</blockquote>
<pre><code class="java">org.apache.tomcat.util.descriptor.web.WebXml.setVersion Unknown version string [4.0]
</code></pre>
<ul>
<li>解决：<a href="https://blog.csdn.net/qq_32483145/article/details/80292463" target="_blank" rel="noopener">https://blog.csdn.net/qq_32483145/article/details/80292463</a></li>
</ul>
<h2 id="用到-servlet-的页面跳转-404"><a href="#用到-servlet-的页面跳转-404" class="headerlink" title="用到 servlet 的页面跳转 404"></a>用到 servlet 的页面跳转 404</h2><h3 id="web-xml-配置有误"><a href="#web-xml-配置有误" class="headerlink" title="web.xml 配置有误"></a>web.xml 配置有误</h3><p>页面能访问，也成功部署到 tomcat 下面的 weapps 文件夹下面，但是在进行页面跳转的过程中，会出现下面的 404 情况。分析之后是我这个项目是新建的一个空项目，然后代码是之前在 eclipse 下运行过的，而后直接将内容代码复制过来，却没复制 web.xml，导致现项目的 web.xml 是“空的”，无配置。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612753264339-b79c791c-6814-4c38-b42d-6b85bb9c1d5f.png#align=left&amp;display=inline&amp;height=144&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=288&amp;originWidth=1920&amp;size=37994&amp;status=done&amp;style=none&amp;width=960" alt="image.png"></p>
<h3 id="Tomcat-路径配置有误"><a href="#Tomcat-路径配置有误" class="headerlink" title="Tomcat 路径配置有误"></a>Tomcat 路径配置有误</h3><p>还有一种情况，就是 tomcat 配置过程中的那两个路径也要注意下<br>调整为如下配置，不然会出现访问/jsp-peojectname/jsp-peojectname/index.jsp 页面为 404 的情况<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612756924057-55c60ad3-85b8-4cf0-aa9d-6184bfbd296e.png#align=left&amp;display=inline&amp;height=78&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=156&amp;originWidth=1611&amp;size=17507&amp;status=done&amp;style=none&amp;width=805.5" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612756936656-72d837f5-46ef-4d35-8e39-e49d2c6f077d.png#align=left&amp;display=inline&amp;height=97&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=194&amp;originWidth=1611&amp;size=12795&amp;status=done&amp;style=none&amp;width=805.5" alt="image.png"></p>
<h3 id="其他类型错误"><a href="#其他类型错误" class="headerlink" title="其他类型错误"></a>其他类型错误</h3><p>可能还有其他类型错误，参考以下的总结</p>
<ul>
<li><a href="https://blog.csdn.net/DBC_121/article/details/79204340" target="_blank" rel="noopener">Web 开发：关于 Tomcat 出现 The origin server did not find a current representation for the target resourc…的问题</a></li>
</ul>
<h2 id="数据库报错"><a href="#数据库报错" class="headerlink" title="数据库报错"></a>数据库报错</h2><p>navicat 也不能查看该数据库</p>
<pre><code class="java">HTTP Status 500 – Internal Server Error
Type Exception Report

Message get connection error!

Description The server encountered an unexpected condition that prevented it from fulfilling the request.

Exception

java.lang.RuntimeException: get connection error!
    com.nic.util.JdbcUtil.getConnection(JdbcUtil.java:55)
    com.nic.dao.ArticleDao.findArticle(ArticleDao.java:56)
    com.nic.service.ArticleService.findArticle(ArticleService.java:20)
    com.nic.servlet.PostlistServlet.doGet(PostlistServlet.java:50)
    javax.servlet.http.HttpServlet.service(HttpServlet.java:635)
    javax.servlet.http.HttpServlet.service(HttpServlet.java:742)
    org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:52)
Root Cause

java.lang.ClassNotFoundException: com.mysql.jdbc.Driver
    org.apache.catalina.loader.WebappClassLoaderBase.loadClass(WebappClassLoaderBase.java:1309)
    org.apache.catalina.loader.WebappClassLoaderBase.loadClass(WebappClassLoaderBase.java:1137)
    java.lang.Class.forName0(Native Method)
    java.lang.Class.forName(Class.java:264)
    com.nic.util.JdbcUtil.getConnection(JdbcUtil.java:52)
    com.nic.dao.ArticleDao.findArticle(ArticleDao.java:56)
    com.nic.service.ArticleService.findArticle(ArticleService.java:20)
    com.nic.servlet.PostlistServlet.doGet(PostlistServlet.java:50)
    javax.servlet.http.HttpServlet.service(HttpServlet.java:635)
    javax.servlet.http.HttpServlet.service(HttpServlet.java:742)
    org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:52)
Note The full stack trace of the root cause is available in the server logs.

Apache Tomcat/8.5.34
</code></pre>
<p>初步分析是用的 phpstudy 里面的 mysql 数据库不能生效，删除电脑之前的 mysql，用 phpstudy 数据库恢复</p>
<hr>
<p>但是还会报错，判断应该是代码文件出错【不过不用将这个 jar 包导入到 lib 文件夹下（反而会报错），只需要将其导入到 tomcat 文件夹下的 lib 文件夹，即可】<br><a href="https://www.yuque.com/attachments/yuque/0/2021/jar/1484158/1612768356808-4c69cbaa-cbc7-4ebe-9232-423cad8ef54f.jar?_lake_card=%7B%22uid%22%3A%221612761483730-0%22%2C%22src%22%3A%22https%3A%2F%2Fwww.yuque.com%2Fattachments%2Fyuque%2F0%2F2021%2Fjar%2F1484158%2F1612768356808-4c69cbaa-cbc7-4ebe-9232-423cad8ef54f.jar%22%2C%22name%22%3A%22mysql-connector-java-5.1.49.jar%22%2C%22size%22%3A1006904%2C%22type%22%3A%22%22%2C%22ext%22%3A%22jar%22%2C%22progress%22%3A%7B%22percent%22%3A99%7D%2C%22status%22%3A%22done%22%2C%22percent%22%3A0%2C%22id%22%3A%22xrOhc%22%2C%22refSrc%22%3A%22https%3A%2F%2Fwww.yuque.com%2Fattachments%2Fyuque%2F0%2F2021%2Fjar%2F1484158%2F1612761486309-2d90c3e5-5a0c-4b57-95f5-5551ed944a23.jar%22%2C%22card%22%3A%22file%22%7D" target="_blank" rel="noopener">mysql-connector-java-5.1.49.jar</a>（或者直接上网搜再下载）<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612756117413-4649efa1-9274-4ae5-aa1a-463750acd571.png#align=left&amp;display=inline&amp;height=332&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=663&amp;originWidth=1291&amp;size=105075&amp;status=done&amp;style=shadow&amp;width=645.5" alt="image.png">~~</p>
]]></content:encoded>
      <comments>https://www.wztlink1013.com/blog/aiuif3/#comments</comments>
    </item>
    
    <item>
      <title><![CDATA[IDEA创建javaWeb项目]]></title>
      <link>https://www.wztlink1013.com/blog/qi1ddv/</link>
      <guid>https://www.wztlink1013.com/blog/qi1ddv/</guid>
      <pubDate>Sun Feb 07 2021 09:21:00 GMT+0000 (Coordinated Universal Time)</pubDate>
      <description>
      <![CDATA[IDEA创建javaWeb项目]]>
      
      </description>
      <content:encoded><![CDATA[<h2 id="一、Tomcat-下载"><a href="#一、Tomcat-下载" class="headerlink" title="一、Tomcat 下载"></a>一、Tomcat 下载</h2><h3 id="1-下载并安装"><a href="#1-下载并安装" class="headerlink" title="1. 下载并安装"></a>1. 下载并安装</h3><blockquote>
<p>假如不是集成开发环境（比如 phpstudy），电脑要有 jdk 环境</p>
</blockquote>
<p>【1】官网下载：<a href="http://tomcat.apache.org/" target="_blank" rel="noopener">http://tomcat.apache.org/</a></p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598787914511-a035ba93-0b7a-450b-b391-5d1452435ca7.png#align=left&amp;display=inline&amp;height=220&amp;margin=%5Bobject%20Object%5D&amp;originHeight=952&amp;originWidth=1842&amp;size=0&amp;status=done&amp;style=shadow&amp;width=425" alt><br>【2】下载并解压到自己的相应盘区，再检验是否成功<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598787914448-2ef2e1a1-2966-4d35-8bfe-82162aa1588b.png#align=left&amp;display=inline&amp;height=273&amp;margin=%5Bobject%20Object%5D&amp;originHeight=727&amp;originWidth=1147&amp;size=0&amp;status=done&amp;style=shadow&amp;width=431" alt><br>点击第二个框不出现闪退情况则证明成功<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598787914507-87063aec-884a-4180-b124-568478d81bc0.png#align=left&amp;display=inline&amp;height=222&amp;margin=%5Bobject%20Object%5D&amp;originHeight=639&amp;originWidth=1223&amp;size=0&amp;status=done&amp;style=shadow&amp;width=425" alt><br>【3】浏览器进入端口<a href="http://localhost:8080/" target="_blank" rel="noopener">http://localhost:8080/</a>上述配置成功则表明成功<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598787914624-248148e3-3f5f-45ca-ad93-c063216a7aff.png#align=left&amp;display=inline&amp;height=270&amp;margin=%5Bobject%20Object%5D&amp;originHeight=1030&amp;originWidth=1838&amp;size=0&amp;status=done&amp;style=shadow&amp;width=482" alt></p>
<h3 id="2-过程中可能会出现的问题"><a href="#2-过程中可能会出现的问题" class="headerlink" title="2. 过程中可能会出现的问题"></a>2. 过程中可能会出现的问题</h3><p>【1】点击 startup.bat 文件出现闪退</p>
<blockquote>
<p>电脑中 java jdk 有无（JAVA_HOME）</p>
</blockquote>
<p>【2】端口被占用</p>
<blockquote>
<p>进入 Tomcat 文件夹下的 conf 文件下的 server.xml 文件，用记事本查找 8080，下面复制一个新的初始端口<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598787914513-8083bc6e-4c6f-436e-b0b0-98d3d70b9dea.png#align=left&amp;display=inline&amp;height=80&amp;margin=%5Bobject%20Object%5D&amp;originHeight=80&amp;originWidth=557&amp;size=0&amp;status=done&amp;style=shadow&amp;width=557" alt></p>
</blockquote>
<h2 id="二、利用-IDEA-创建一个-JavaWeb-项目"><a href="#二、利用-IDEA-创建一个-JavaWeb-项目" class="headerlink" title="二、利用 IDEA 创建一个 JavaWeb 项目"></a>二、利用 IDEA 创建一个 JavaWeb 项目</h2><h3 id="1-创建新项目"><a href="#1-创建新项目" class="headerlink" title="1. 创建新项目"></a>1. 创建新项目</h3><p>依次点击：<code>File</code>-&gt; <code>New</code>-&gt; <code>Project</code><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612697874347-fef7ad38-7ff2-4567-89a9-f5d47a1f4824.png#align=left&amp;display=inline&amp;height=316&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=812&amp;originWidth=1202&amp;size=104672&amp;status=done&amp;style=none&amp;width=468" alt="image.png"></p>
<h3 id="2-项目工程配置"><a href="#2-项目工程配置" class="headerlink" title="2. 项目工程配置"></a>2. 项目工程配置</h3><p>【1】在<code>WEB-INF</code>下创建两个空文件夹 <code>classes</code> <code>lib</code></p>
<blockquote>
<p>目的：</p>
<ul>
<li>classes 文件夹用于存放编译后的 class 文件</li>
<li>lib 文件夹用于存放依赖的 jar 包</li>
</ul>
</blockquote>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612697966439-ab639870-61ab-429e-919a-4109c8cefdc5.png#align=left&amp;display=inline&amp;height=237&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=473&amp;originWidth=469&amp;size=29009&amp;status=done&amp;style=none&amp;width=234.5" alt="image.png"><br>【2】依次点击<code>file</code> -&gt; <code>Project Structure</code></p>
<blockquote>
<p>目的：将后面编译的 class 文件默认生成到刚刚新建的 classes 目录下</p>
</blockquote>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612698144393-24e78472-430b-47a4-b423-e091597bb4f3.png#align=left&amp;display=inline&amp;height=364&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=727&amp;originWidth=1535&amp;size=95789&amp;status=done&amp;style=none&amp;width=767.5" alt="image.png"><br>【3】依次点击<code>file</code> -&gt; <code>Project Structure</code></p>
<blockquote>
<p>目的：添加 jar 包依赖<br>（项目所需要的 jar 包都放到刚刚新建的 lib 文件夹）<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612698241583-99ff6441-6e2a-4776-addb-9f8f1eda6636.png#align=left&amp;display=inline&amp;height=268&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=535&amp;originWidth=1274&amp;size=68026&amp;status=done&amp;style=none&amp;width=637" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612698274993-98e1b314-c726-41e6-973e-1dbb07ef7312.png#align=left&amp;display=inline&amp;height=169&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=337&amp;originWidth=546&amp;size=22322&amp;status=done&amp;style=none&amp;width=273" alt="image.png"><br>【4】配置打包方式 Artifacts<br><del>点击 Artifacts 选项卡，IDEA 会为该项目自动创建一个名为“JavaWeb:war exploded”的打包方式，表示 打包成 war 包，并且是文件展开性的，输出路径为当前项目下的 out 文件夹，保持默认即可。另外勾选下“Build on make”，表示编译的时候就打包部署，勾选“Show content of elements”，表示显示详细的内容列表。</del></p>
</blockquote>
<p><em>如果按照上面说的，那么会发现发布的项目并没有在 tomcat 目录下的 webapps 目录下，如果项目以前在其他电脑抑或是其他环境下运行过，可能会导致项目的很多子页面默认 URL404。</em><br><del><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612711385355-7645f327-ad5c-40aa-a165-b975f957ebe3.png#align=left&amp;display=inline&amp;height=239&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=479&amp;originWidth=884&amp;size=112691&amp;status=done&amp;style=shadow&amp;width=442" alt="image.png"></del><br>正确解决办法：项目一开始依次点击<code>file</code> -&gt; <code>Project Structure</code></p>
<blockquote>
<p>1 区域：将 output 路径指定到<code>tomcat</code>的<code>webapps</code>下面（新建一个本项目的同名文件夹）<br>2 区域：Output Layout 就是配置这个路径里面生成的所有文件<br>3 区域：将右边的文件内容脱拉到左边的 3 区域即可</p>
</blockquote>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612763067214-29b72122-e8c6-4df1-a112-50ffb6c43084.png#align=left&amp;display=inline&amp;height=327&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=653&amp;originWidth=1535&amp;size=81034&amp;status=done&amp;style=none&amp;width=767.5" alt="image.png"></p>
<h3 id="3-Tomcat-配置"><a href="#3-Tomcat-配置" class="headerlink" title="3. Tomcat 配置"></a>3. Tomcat 配置</h3><p>【1】点击如下位置进入 tomcat 容器编辑板块<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612698536983-4544013a-5e2a-43d7-ae31-7aa5c871fb3a.png#align=left&amp;display=inline&amp;height=151&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=301&amp;originWidth=1920&amp;size=55468&amp;status=done&amp;style=none&amp;width=960" alt="image.png"><br>【2】默认会自动给我们生成一个 Tomcat 容器，基本上只需要配置<code>Deployment</code>即可，如果没有默认生成就新建一个。其中<code>Application server</code>填写本地 tomcat 的安装目录文件夹即可（因为一台电脑开发可能会有多个 tomcat 版本）<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612711521404-673143aa-f3fd-4b37-aed1-919d0ea1de1f.png#align=left&amp;display=inline&amp;height=370&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=740&amp;originWidth=1163&amp;size=152940&amp;status=done&amp;style=none&amp;width=581.5" alt="image.png"></p>
<blockquote>
<p>❗ ❗ ❗ 如果要换不同版本的 tomcat 来运行项目，改如下地方：</p>
<ol>
<li>先将上面图片<code>Application server</code>tomcat 版本更换至新的 tomcat 版本</li>
<li>去<code>2. 项目工程配置</code>步骤中，减去原先的 tomcat，加上新的 tomcat</li>
</ol>
</blockquote>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612698612335-158bfcb3-3016-478c-b86a-770ad57ad2a9.png#align=left&amp;display=inline&amp;height=511&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=1022&amp;originWidth=1611&amp;size=111169&amp;status=done&amp;style=none&amp;width=805.5" alt="image.png"></p>
<blockquote>
<p>此处的 Application context 是指定本工程的根目录</p>
</blockquote>
<h3 id="4-结果测试"><a href="#4-结果测试" class="headerlink" title="4. 结果测试"></a>4. 结果测试</h3><p>在<code>index.jsp</code>文件下添加显示代码<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612698732177-5bedf912-6a16-47d4-ab96-d5527b9567d1.png#align=left&amp;display=inline&amp;height=271&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=542&amp;originWidth=1879&amp;size=244164&amp;status=done&amp;style=none&amp;width=939.5" alt="image.png"><br>直接运行<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612698844575-2952fffc-3616-43f1-be90-138dbe0df86d.png#align=left&amp;display=inline&amp;height=128&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=256&amp;originWidth=1107&amp;size=40673&amp;status=done&amp;style=shadow&amp;width=553.5" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612698866551-55b0f5c6-fc7e-423a-8c59-2af2cbe08953.png#align=left&amp;display=inline&amp;height=152&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=303&amp;originWidth=827&amp;size=28375&amp;status=done&amp;style=shadow&amp;width=413.5" alt="image.png"></p>
<blockquote>
<p>如果在 Tomcat 配置过程中的部署路径为 <code>/</code> ，会出现下面第二张图的结果，都能访问，但是最好还是上面的方式，符合服务器“一个文件夹一个站点”的思想，路径访问的相关问题不会挖坑。</p>
</blockquote>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612698976241-4d798089-9581-4cdf-893b-dbbc11b18057.png#align=left&amp;display=inline&amp;height=511&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=1022&amp;originWidth=1611&amp;size=101904&amp;status=done&amp;style=none&amp;width=805.5" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612698989649-0fdabed2-a690-450a-b11f-3900a477a68a.png#align=left&amp;display=inline&amp;height=170&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=340&amp;originWidth=862&amp;size=27789&amp;status=done&amp;style=shadow&amp;width=431" alt="image.png"></p>
<h3 id="❗-JavaWeb-项目结构分析"><a href="#❗-JavaWeb-项目结构分析" class="headerlink" title="❗ JavaWeb 项目结构分析"></a>❗ JavaWeb 项目结构分析</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612752142869-4f7db98f-6d15-4ce5-be4b-1e0e13dcab08.png#align=left&amp;display=inline&amp;height=444&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=888&amp;originWidth=321&amp;size=43193&amp;status=done&amp;style=none&amp;width=160.5" alt="image.png"></p>
<ul>
<li>src 文件夹：编写的 java 代码，编译后会放到 WEB-INF 文件夹下的 classes 文件夹</li>
<li>web 文件夹：web 应用程序的根目录，web 应用程序所有的文件都在该目录下</li>
<li>WEB-INF：客户不能直接通过浏览器进行访问<ul>
<li>classes：存放 servlet 和其他有用的 class 文件（编译后的）</li>
<li>lib：存放 web 应用程序所需要的 jar 包</li>
<li>web.xml：存放部署和配置信息的文件（当前 WEB 项目的核心配置，Servlet2.5 必须有，3.0 以后可省略）</li>
</ul>
</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://blog.csdn.net/m0_37499059/article/details/78806617" target="_blank" rel="noopener">Intellij idea 创建 javaWeb 项目</a></li>
<li><a href="https://blog.csdn.net/c_little_white/article/details/89435646?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.control&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.control" target="_blank" rel="noopener">IDEA 启动 tomcat 不报错，tomcat 的 webapps 文件夹没有项目文件，项目的默认 URL404</a></li>
</ul>
]]></content:encoded>
      <comments>https://www.wztlink1013.com/blog/qi1ddv/#comments</comments>
    </item>
    
    <item>
      <title><![CDATA[CSS定位]]></title>
      <link>https://www.wztlink1013.com/blog/qfka5bkr6swg/</link>
      <guid>https://www.wztlink1013.com/blog/qfka5bkr6swg/</guid>
      <pubDate>Sun Jan 24 2021 20:39:20 GMT+0000 (Coordinated Universal Time)</pubDate>
      <description>
      <![CDATA[<h2 id="CSS-布局的三种机制"><a href="#CSS-布局的三种机制" class="headerlink" title="CSS 布局的三种机制"></a>CSS 布局的三种机制</h2><blockquote>
<p>网页布局的核心 —— 就是<strong>]]>
      </description>
      <content:encoded><![CDATA[<h2 id="CSS-布局的三种机制"><a href="#CSS-布局的三种机制" class="headerlink" title="CSS 布局的三种机制"></a>CSS 布局的三种机制</h2><blockquote>
<p>网页布局的核心 —— 就是<strong>用 CSS 来摆放盒子位置</strong>。<br>CSS 提供了 &gt; <strong>3 种机制</strong>来设置盒子的摆放位置，分别是&gt; <strong>普通流</strong>、&gt; <strong>浮动</strong>和&gt; <strong>定位</strong></p>
</blockquote>
<blockquote>
<p><strong>【1】普通流</strong>（<strong>标准流</strong>）</p>
</blockquote>
<p>可以让盒子上下排列或者左右排列的</p>
<ul>
<li><strong>块级元素</strong>会独占一行，<strong>从上向下</strong>顺序排列；<ul>
<li>常用元素：div、hr、p、h1~h6、ul、ol、dl、form、table</li>
</ul>
</li>
<li><p><strong>行内元素</strong>会按照顺序，<strong>从左到右</strong>顺序排列，碰到父元素边缘则自动换行；</p>
<ul>
<li>常用元素：span、a、i、em 等<blockquote>
<p><strong>【2】浮动</strong></p>
</blockquote>
</li>
</ul>
</li>
<li><p>让盒子从普通流中<strong>浮</strong>起来 —— <strong>让多个盒子(div)水平排列成一行</strong>。</p>
</li>
<li><p>可以让多个块级元素一行显示 或者 左右对齐盒子 浮动的盒子就是按照顺序左右排列</p>
<blockquote>
<p><strong>【3】定位</strong></p>
</blockquote>
</li>
<li><p>将盒子<strong>定</strong>在某一个<strong>位</strong>置 自由的漂浮在其他盒子的上面 —— CSS 离不开定位，特别是后面的 js 特效。</p>
</li>
<li>定位最大的特点是有层叠的概念，就是可以让多个盒子 前后 叠压来显示。 但是每个盒子需要测量数值。<blockquote>
<p><strong>【结论】</strong></p>
<ul>
<li>标准流在最底层</li>
<li>浮动的盒子在中间层</li>
<li>定位的盒子在最上层</li>
</ul>
</blockquote>
</li>
</ul>
<h2 id="定位详解"><a href="#定位详解" class="headerlink" title="定位详解"></a>定位详解</h2><p>定位也是用来布局的，它有两部分组成：</p>
<blockquote>
<p><code>定位 = 定位模式 + 边偏移</code></p>
</blockquote>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611552456483-b258a0b4-d5e2-43ab-af99-f6eef921bacb.png#align=left&amp;display=inline&amp;height=182&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=364&amp;originWidth=602&amp;size=24287&amp;status=done&amp;style=stroke&amp;width=301" alt="image.png"></p>
<h3 id="边偏移"><a href="#边偏移" class="headerlink" title="边偏移"></a>边偏移</h3><p>简单说， 我们定位的盒子，是通过边偏移来移动位置的。<br>在 CSS 中，通过 <code>top</code>、<code>bottom</code>、<code>left</code> 和 <code>right</code> 属性定义元素的<strong>边偏移</strong>：（方位名词）</p>
<table>
<thead>
<tr>
<th>边偏移属性</th>
<th style="text-align:left">示例</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>top</code></td>
<td style="text-align:left"><code>top: 80px</code></td>
<td><strong>顶端</strong>偏移量，定义元素相对于其父元素<strong>上边线的距离</strong>。</td>
</tr>
<tr>
<td><code>bottom</code></td>
<td style="text-align:left"><code>bottom: 80px</code></td>
<td><strong>底部</strong>偏移量，定义元素相对于其父元素<strong>下边线的距离</strong>。</td>
</tr>
<tr>
<td><code>left</code></td>
<td style="text-align:left"><code>left: 80px</code></td>
<td><strong>左侧</strong>偏移量，定义元素相对于其父元素<strong>左边线的距离</strong>。</td>
</tr>
<tr>
<td><code>right</code></td>
<td style="text-align:left"><code>right: 80px</code></td>
<td><strong>右侧</strong>偏移量，定义元素相对于其父元素<strong>右边线的距离</strong></td>
</tr>
</tbody>
</table>
<p>定位的盒子有了边偏移才有价值。 一般情况下，凡是有定位地方必定有边偏移。</p>
<h3 id="static"><a href="#static" class="headerlink" title="static"></a>static</h3><ul>
<li><strong>静态定位</strong>是元素的默认定位方式，无定位的意思。它相当于 border 里面的 none， 不要定位的时候用。</li>
<li>静态定位 按照标准流特性摆放位置，它没有边偏移。</li>
<li>静态定位在布局时我们几乎不用的</li>
</ul>
<h3 id="relative"><a href="#relative" class="headerlink" title="relative"></a>relative</h3><ul>
<li><strong>相对定位</strong>是元素<strong>相对</strong>于它原来在标准流中的位置 来说的。（自恋型）**</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611552470167-bd2f5289-4670-4b1f-9b22-1361f8cd58d0.png#align=left&amp;display=inline&amp;height=190&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=634&amp;originWidth=1216&amp;size=93835&amp;status=done&amp;style=stroke&amp;width=365" alt="image.png"><br>相对定位的特点：（务必记住）</p>
<ul>
<li>相对于 自己原来在标准流中位置来移动的</li>
<li>原来<strong>在标准流的区域继续占有</strong>，后面的盒子仍然以标准流的方式对待它。</li>
</ul>
<h3 id="absolute"><a href="#absolute" class="headerlink" title="absolute"></a>absolute</h3><blockquote>
<p><strong>【1】绝对定位</strong>是元素以带有定位的父级元素来移动位置 （拼爹型）</p>
</blockquote>
<ul>
<li><p><strong>完全脱标</strong>：完全不占位置，完全镂空</p>
</li>
<li><p><strong>父元素没有定位：</strong>则以<strong>浏览器</strong>为准定位（Document 文档）。</p>
</li>
<li><strong>父元素要有定位：</strong>将元素依据最近的已经定位（绝对、固定或相对定位）的父元素（祖先）进行定位。</li>
<li>绝对是以带有定位的父级元素来移动位置， 如果父级都没有定位，则以浏览器文档为准移动位置</li>
<li>不保留原来的位置，完全是脱标的。</li>
</ul>
<blockquote>
<p>【2】子级元素使用绝对定位时，父级元素就要用相对定位</p>
</blockquote>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611552541033-59cb288a-ccb1-4ccb-aa4c-e4550e99edf0.png#align=left&amp;display=inline&amp;height=459&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=918&amp;originWidth=1234&amp;size=93786&amp;status=done&amp;style=stroke&amp;width=617" alt="image.png"></p>
<blockquote>
<p><strong>分析</strong></p>
</blockquote>
<ul>
<li><strong>方向箭头</strong>叠加在其他图片上方，应该使用<strong>绝对定位</strong>，因为<strong>绝对定位完全脱标</strong>，完全不占位置。</li>
<li><strong>父级盒子</strong>应该使用<strong>相对定位</strong>，因为<strong>相对定位不脱标</strong>，后续盒子仍然以标准流的方式对待它。</li>
<li>如果父级盒子也使用<strong>绝对定位</strong>，会完全脱标，那么下方的<strong>广告盒子</strong>会上移，这显然不是我们想要的。</li>
</ul>
<h3 id="fixed"><a href="#fixed" class="headerlink" title="fixed"></a>fixed</h3><ul>
<li><strong>固定定位</strong>是<strong>绝对定位</strong>的一种特殊形式： （认死理型）</li>
<li><strong>完全脱标</strong> —— 完全不占位置；</li>
<li>只认<strong>浏览器的可视窗口</strong> —— <code>浏览器可视窗口 + 边偏移属性</code> 来设置元素的位置；<ul>
<li>跟父元素没有任何关系；单独使用的</li>
<li>不随滚动条滚动。<blockquote>
<p>案例演练：固定定位案例。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611552558881-329f4f76-7ace-4fdd-840d-40a651c628ad.png#align=left&amp;display=inline&amp;height=256&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=512&amp;originWidth=1221&amp;size=93480&amp;status=done&amp;style=stroke&amp;width=610.5" alt="image.png"><br><strong>提示</strong>：IE 6 等低版本浏览器不支持固定定位。</p>
<h3 id="Demo：轮播图"><a href="#Demo：轮播图" class="headerlink" title="Demo：轮播图"></a>Demo：轮播图</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616243009664-321f94d9-d92b-4503-9ff3-beaf87f2413e.png#align=left&amp;display=inline&amp;height=272&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=544&amp;originWidth=1920&amp;size=28507&amp;status=done&amp;style=stroke&amp;width=960" alt="image.png"></p>
<blockquote>
<p>圆角矩形设置 4 个角</p>
</blockquote>
<ul>
<li>圆角矩形可以为 4 个角分别设置圆度， 但是是有顺序的</li>
</ul>
<pre><code class="css">border-top-left-radius: 20px;
border-top-right-radius: 20px;
border-bottom-right-radius: 20px;
border-bottom-left-radius: 20px;
</code></pre>
<ul>
<li>如果 4 个角，数值相同</li>
</ul>
<pre><code class="css">border-radius: 15px;
</code></pre>
<ul>
<li>里面数值不同，我们也可以按照简写的形式，还是遵循的顺时针。</li>
</ul>
<pre><code class="css">border-radius: 左上角 右上角 右下角 左下角;
</code></pre>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot; /&gt;
    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;
    &lt;title&gt;Document&lt;/title&gt;
    &lt;style&gt;
      * {
        padding: 0;
        margin: 0;
      }
      li {
        list-style: none;
      }
      .box {
        width: 400px;
        height: 300px;
        background-color: tan;
        position: relative;
        margin: 0 auto;
      }
      .row_left {
        position: absolute;
        width: 20px;
        height: 30px;
        top: 50%;
        left: 0;
        margin-top: -15px;
        border: 1px darkgoldenrod solid;
        line-height: 30px;
        border-top-right-radius: 30px;
        border-bottom-right-radius: 30px;
        text-align: left;
      }
      .row_right {
        position: absolute;
        width: 20px;
        height: 30px;
        top: 50%;
        right: 0;
        margin-top: -15px;
        border: 1px darkgoldenrod solid;
        line-height: 30px;
        border-top-left-radius: 30px;
        border-bottom-left-radius: 30px;
        text-align: right;
      }
      .bottom_dots {
        position: absolute;
        width: 110px;
        height: 22px;
        bottom: 10px;
        left: 50%;
        margin-left: -50px;
        border: springgreen 1px solid;
        border-radius: 10px;
      }
      .row_left:hover,
      .row_right:hover {
        background-color: yellowgreen;
      }

      .bottom_dots li {
        float: left;
        width: 20px;
        height: 20px;
        border-radius: 50%;
        border: steelblue solid 1px;
      }
      .bottom_dots .current {
        background-color: tomato;
      }
    &lt;/style&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div class=&quot;box&quot;&gt;
      &lt;div class=&quot;row_left&quot;&gt;&lt;&lt;/div&gt;
      &lt;div class=&quot;row_right&quot;&gt;&gt;&lt;/div&gt;
      &lt;ul class=&quot;bottom_dots&quot;&gt;
        &lt;li&gt;&lt;/li&gt;
        &lt;li class=&quot;current&quot;&gt;&lt;/li&gt;
        &lt;li&gt;&lt;/li&gt;
        &lt;li&gt;&lt;/li&gt;
        &lt;li&gt;&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/div&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="Demo：网站右下角快捷功能"><a href="#Demo：网站右下角快捷功能" class="headerlink" title="Demo：网站右下角快捷功能"></a>Demo：网站右下角快捷功能</h3><ul>
<li><strong>注意</strong>：不要同时使用 <code>left</code> 和 <code>right</code> 和边偏移属性。**</li>
<li><strong>固定定位</strong>的应用场景：<strong>固定在浏览器可视窗口某个位置的布局</strong>；</li>
<li>在使用固定和绝对定位时，如果盒子中没有内容，需要指定宽度，下面的例子又宽度</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616239742720-28510068-3322-4b73-ad28-8a345ba5f8c6.png#align=left&amp;display=inline&amp;height=297&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=593&amp;originWidth=1920&amp;size=187411&amp;status=done&amp;style=stroke&amp;width=960" alt="image.png"></p>
<h2 id="定位的相关问题"><a href="#定位的相关问题" class="headerlink" title="定位的相关问题"></a>定位的相关问题</h2><h3 id="绝对定位的盒子居中"><a href="#绝对定位的盒子居中" class="headerlink" title="绝对定位的盒子居中"></a>绝对定位的盒子居中</h3><blockquote>
<p><strong>注意</strong>：<strong>绝对定位/固定定位的盒子</strong>不能通过设置 <code>margin: auto</code> 设置<strong>水平居中</strong>。</p>
</blockquote>
<p>在使用<strong>绝对定位</strong>时要想实现水平居中，可以按照下面的方法：</p>
<ol>
<li><code>left: 50%;</code>：让<strong>盒子的左侧</strong>移动到<strong>父级元素的水平中心位置</strong>；</li>
<li><code>margin-left: -100px;</code>：让盒子<strong>向左</strong>移动<strong>自身宽度的一半</strong>。</li>
</ol>
<p>整体居中如下设置<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616240730926-4415dd36-b842-4cc8-b0a2-49345b503a43.png#align=left&amp;display=inline&amp;height=892&amp;margin=%5Bobject%20Object%5D&amp;name=Snipaste_2021-03-20_19-44-47.png&amp;originHeight=892&amp;originWidth=1920&amp;size=76602&amp;status=done&amp;style=stroke&amp;width=1920" alt="Snipaste_2021-03-20_19-44-47.png"></p>
<h3 id="z-index"><a href="#z-index" class="headerlink" title="z-index"></a>z-index</h3><ul>
<li>在使用<strong>定位</strong>布局时，可能会<strong>出现盒子重叠的情况</strong>。</li>
<li>加了定位的盒子，默认<strong>后来者居上</strong>， 后面的盒子会压住前面的盒子。</li>
<li>应用 <code>z-index</code> 层叠等级属性可以<strong>调整盒子的堆叠顺序</strong>。如下图所示：</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611552609219-135cc13d-9a4e-411e-bac1-3b3fcad55d5e.png#align=left&amp;display=inline&amp;height=186&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=371&amp;originWidth=1245&amp;size=36112&amp;status=done&amp;style=stroke&amp;width=622.5" alt="image.png"></p>
<blockquote>
<p><code>z-index</code> 的特性如下：</p>
</blockquote>
<ul>
<li><strong>属性值</strong>：<strong>正整数</strong>、<strong>负整数</strong>或 <strong>0</strong>，默认值是 0，数值越大，盒子越靠上；</li>
<li>如果<strong>属性值相同</strong>，则按照书写顺序，<strong>后来居上</strong>；</li>
<li><strong>数字后面不能加单位</strong>。</li>
<li><strong>注意</strong>：<code>z-index</code> 只能应用于<strong>相对定位</strong>、<strong>绝对定位</strong>和<strong>固定定位</strong>的元素，其他<strong>标准流</strong>、<strong>浮动</strong>和<strong>静态定位</strong>无效。</li>
</ul>
<h3 id="定位改变-display-属性"><a href="#定位改变-display-属性" class="headerlink" title="定位改变 display 属性"></a>定位改变 display 属性</h3><p>前面我们讲过，display 是显示模式，可以改变显示模式有以下方式:</p>
<ul>
<li>可以用 inline-block 转换为行内块</li>
<li>可以用浮动 float 默认转换为行内块（类似，并不完全一样，因为浮动是脱标的）</li>
<li>绝对定位和固定定位也和浮动类似， 默认转换的特性转换为行内块。</li>
</ul>
<p>所以说， 一个行内的盒子，如果加了<strong>浮动</strong>、<strong>固定定位</strong>和<strong>绝对定位</strong>，不用转换，就可以给这个盒子直接设置宽度和高度等。</p>
<blockquote>
<p><strong>同时注意：</strong></p>
</blockquote>
<p>浮动元素、绝对定位(固定定位）元素的都不会触发外边距合并的问题。 （我们以前是用 padding border overflow 解决的）<br>也就是说，我们给盒子改为了浮动或者定位，就不会有垂直外边距合并的问题了。</p>
]]></content:encoded>
      <comments>https://www.wztlink1013.com/blog/qfka5bkr6swg/#comments</comments>
    </item>
    
    <item>
      <title><![CDATA[CSS浮动]]></title>
      <link>https://www.wztlink1013.com/blog/vgixv5vex3i8/</link>
      <guid>https://www.wztlink1013.com/blog/vgixv5vex3i8/</guid>
      <pubDate>Sun Jan 24 2021 20:39:18 GMT+0000 (Coordinated Universal Time)</pubDate>
      <description>
      <![CDATA[<h2 id="浮动详解"><a href="#浮动详解" class="headerlink" title="浮动详解"></a>浮动详解</h2><h3 id="为什么需要浮动"><a href="#为什么需要浮动" class="headerlink" title="为什么]]>
      </description>
      <content:encoded><![CDATA[<h2 id="浮动详解"><a href="#浮动详解" class="headerlink" title="浮动详解"></a>浮动详解</h2><h3 id="为什么需要浮动"><a href="#为什么需要浮动" class="headerlink" title="为什么需要浮动"></a>为什么需要浮动</h3><ul>
<li>多个盒子(div)水平排列成一行</li>
<li><p>实现盒子的左右对齐</p>
</li>
<li><p>行内块（inline-block）它可以实现多个元素一行显示，但是中间会有空白缝隙，不能满足以上第一个问题。</p>
</li>
<li>行内块（inline-block）不能实现以上第二个问题，盒子左右对齐</li>
</ul>
<h3 id="浮动特点"><a href="#浮动特点" class="headerlink" title="浮动特点"></a>浮动特点</h3><blockquote>
<p><strong>概念</strong>：元素的浮动是指<strong>设置了浮动属性的元素</strong>会</p>
</blockquote>
<ul>
<li>脱离标准普通流的控制</li>
<li><p>移动到指定位置</p>
<blockquote>
<p>作用</p>
</blockquote>
</li>
<li><p><strong>让多个盒子(div)水平排列成一行</strong>，使得浮动成为布局的重要手段。</p>
</li>
<li>可以实现盒子的左右对齐等等..</li>
<li>浮动最早是用来<strong>控制图片</strong>，实现<strong>文字环绕图片的效果</strong>。<blockquote>
<p>语法</p>
</blockquote>
</li>
</ul>
<pre><code class="css">选择器 {
  float: 属性值;
}
</code></pre>
<table>
<thead>
<tr>
<th>属性值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>none</strong></td>
<td>元素不浮动（<strong>默认值</strong>）</td>
</tr>
<tr>
<td><strong>left</strong></td>
<td>元素向<strong>左</strong>浮动</td>
</tr>
<tr>
<td><strong>right</strong></td>
<td>元素向<strong>右</strong>浮动</td>
</tr>
</tbody>
</table>
<blockquote>
<p>特点 1：浮</p>
</blockquote>
<ul>
<li>浮动——浮浮~~~漂浮在普通流的上面。 脱离标准流。 俗称 “脱标”</li>
<li><code>float</code> 属性会让盒子漂浮在标准流的上面，所以第二个标准流的盒子跑到浮动盒子的底下了。</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616233538999-0a7d098b-a897-491c-b25c-36f34eb7b193.png#align=left&amp;display=inline&amp;height=440&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=880&amp;originWidth=1920&amp;size=139927&amp;status=done&amp;style=stroke&amp;width=960" alt="image.png"></p>
<ul>
<li><p>上图问题 1 处出现文字被撑开的情况，似乎和预想的有一丢丢的不尽如意，原因是对于文本和行内元素来说依然是占用空间的</p>
<blockquote>
<p>特点 2：漏</p>
</blockquote>
</li>
<li><p>浮动——漏漏~ 浮动的盒子，把自己原来的位置漏给下面标准流的盒子，就是不占有原来位置，是脱离标准流的，我们俗称 “脱标”。</p>
<blockquote>
<p>特点 3：特</p>
</blockquote>
</li>
<li><p>浮动——特性 float 属性会改变元素 display 属性。</p>
</li>
<li>任何元素都可以浮动。浮动元素会生成一个块级框，而不论它本身是何种元素。 生成的块级框和我们前面的行内块极其相似，所以出现了上面浮里面的例子当中父元素里面的文字被撑开的情况</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616234017630-4391a0b4-6214-42ba-a1f2-cd44c1a99f94.png#align=left&amp;display=inline&amp;height=330&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=660&amp;originWidth=1920&amp;size=116474&amp;status=done&amp;style=stroke&amp;width=960" alt="image.png"></p>
<ul>
<li><strong>浮动的元素互相贴靠一起的，但是如果父级宽度装不下这些浮动的盒子， **</strong>多出的盒子会另起一行对齐**</li>
</ul>
<h3 id="Demo：浮动-标准流的布局"><a href="#Demo：浮动-标准流的布局" class="headerlink" title="Demo：浮动+标准流的布局"></a>Demo：浮动+标准流的布局</h3><blockquote>
<p>浮动和标准流的父盒子搭配</p>
</blockquote>
<p>我们知道，浮动是脱标的，会影响下面的标准流元素，此时，我们需要给浮动的元素添加一个标准流的父亲，这样，最大化的减小了对其他标准流的影响。**<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616236830103-21860906-bc1f-48a8-8fb1-a5011f02a551.png#align=left&amp;display=inline&amp;height=334&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=667&amp;originWidth=1920&amp;size=71026&amp;status=done&amp;style=stroke&amp;width=960" alt="image.png"></p>
<h2 id="浮动的相关问题"><a href="#浮动的相关问题" class="headerlink" title="浮动的相关问题"></a>浮动的相关问题</h2><h3 id="浮动元素与父盒子的关系"><a href="#浮动元素与父盒子的关系" class="headerlink" title="浮动元素与父盒子的关系"></a>浮动元素与父盒子的关系</h3><ul>
<li>子盒子的浮动参照父盒子对齐</li>
<li>不会与父盒子的边框重叠，也不会超过父盒子的内边距</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616237499108-fe82abe6-42c1-4f37-ad68-d45c3f78cd11.png#align=left&amp;display=inline&amp;height=152&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=303&amp;originWidth=1920&amp;size=33264&amp;status=done&amp;style=stroke&amp;width=960" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616237548311-79fb762c-6f7d-45c0-b316-14a12ba92098.png#align=left&amp;display=inline&amp;height=90&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=179&amp;originWidth=1920&amp;size=8431&amp;status=done&amp;style=stroke&amp;width=960" alt="image.png"></p>
<h3 id="浮动元素与兄弟盒子的关系"><a href="#浮动元素与兄弟盒子的关系" class="headerlink" title="浮动元素与兄弟盒子的关系"></a>浮动元素与兄弟盒子的关系</h3><p>在一个父级盒子中，如果<strong>前一个兄弟盒子</strong>是：</p>
<ul>
<li><strong>浮动</strong>的，那么<strong>当前盒子</strong>会与前一个盒子的顶部对齐；</li>
<li><strong>普通流</strong>的，那么<strong>当前盒子</strong>会显示在前一个兄弟盒子的下方。</li>
<li>浮动只会影响当前的或者是后面的标准流盒子，不会影响前面的标准流。</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2021/jpg/1484158/1611549557830-9fdd5350-af70-4793-8dba-cc3c06214b72.jpg#align=left&amp;display=inline&amp;height=553&amp;margin=%5Bobject%20Object%5D&amp;originHeight=553&amp;originWidth=486&amp;status=done&amp;style=stroke&amp;width=486" alt></p>
<ul>
<li><strong>如果一个盒子里面有多个子盒子，如果其中一个盒子浮动了，其他兄弟也应该浮动。防止引起问题</strong></li>
</ul>
<h3 id="为什么要清除浮动"><a href="#为什么要清除浮动" class="headerlink" title="为什么要清除浮动"></a>为什么要清除浮动</h3><ul>
<li>因为父级盒子很多情况下，不方便给高度，但是子盒子浮动就不占有位置，最后父级盒子高度为 0，就影响了下面的标准流盒子</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616238120449-097b5efe-31ea-43f9-b393-4e64e9836530.png#align=left&amp;display=inline&amp;height=135&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=270&amp;originWidth=1920&amp;size=32856&amp;status=done&amp;style=stroke&amp;width=960" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616238209810-a8b31f63-37b3-4289-a691-e52ab55f8203.png#align=left&amp;display=inline&amp;height=101&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=201&amp;originWidth=1920&amp;size=20171&amp;status=done&amp;style=stroke&amp;width=960" alt="image.png"></p>
<ul>
<li>总结：由于浮动元素不再占用原文档流的位置，所以它会对后面的元素排版产生影响，准确地说，并不是清除浮动，而是<strong>清除浮动后造成的影响</strong></li>
<li><strong>所以还是最好利用一个标准流为父盒子，里面套数个浮动盒子最为好用</strong><blockquote>
<p><strong>清除浮动本质：</strong> &gt; <strong>清除浮动主要为了解决父级元素因为子级浮动引起内部高度为 0 的问题</strong>&gt; <strong>。清除浮动之后， 父级就会根据浮动的子盒子自动检测高度。父级有了高度，就不会影响下面的标准流了</strong></p>
</blockquote>
</li>
</ul>
<h3 id="清除浮动的方法"><a href="#清除浮动的方法" class="headerlink" title="清除浮动的方法"></a>清除浮动的方法</h3><p>在 CSS 中，clear 属性用于清除浮动，在这里，我们先记住清除浮动的方法，具体的原理，等我们学完 css 会再回头分析。</p>
<ul>
<li>语法：</li>
</ul>
<pre><code class="css">选择器{clear:属性值;}   clear 清除
</code></pre>
<table>
<thead>
<tr>
<th>属性值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>left</td>
<td>不允许左侧有浮动元素（清除左侧浮动的影响）</td>
</tr>
<tr>
<td>right</td>
<td>不允许右侧有浮动元素（清除右侧浮动的影响）</td>
</tr>
<tr>
<td>both</td>
<td>同时清除左右两侧浮动的影响</td>
</tr>
</tbody>
</table>
<p>但是我们实际工作中， 几乎只用 clear: both;</p>
<h4 id="额外标签法-隔墙法"><a href="#额外标签法-隔墙法" class="headerlink" title="额外标签法(隔墙法)"></a>额外标签法(隔墙法)</h4><pre><code class="html">是W3C推荐的做法是通过在浮动元素末尾添加一个空的标签例如
&lt;div style=&quot;”clear:both”&quot;&gt;&lt;/div&gt;
，或则其他标签br等亦可。
</code></pre>
<ul>
<li>优点： 通俗易懂，书写方便</li>
<li>缺点： 添加许多无意义的标签，结构化较差。</li>
</ul>
<h4 id="父级添加-overflow-属性方法"><a href="#父级添加-overflow-属性方法" class="headerlink" title="父级添加 overflow 属性方法"></a>父级添加 overflow 属性方法</h4><pre><code class="css">可以给父级添加： overflow为 hidden| auto| scroll  都可以实现。
</code></pre>
<p>优点： 代码简洁<br>缺点： 内容增多时候容易造成不会自动换行导致内容被隐藏掉，无法显示需要溢出的元素。</p>
<h4 id="使用-after-伪元素清除浮动"><a href="#使用-after-伪元素清除浮动" class="headerlink" title="使用 after 伪元素清除浮动"></a>使用 after 伪元素清除浮动</h4><blockquote>
<p><strong>:after 方式为空元素额外标签法的升级版，好处是不用单独加标签了</strong></p>
</blockquote>
<p>使用方法：</p>
<pre><code class="css">.clearfix:after {
  content: &quot;&quot;;
  display: block;
  height: 0;
  clear: both;
  visibility: hidden;
}
.clearfix {
  *zoom: 1;
} /* IE6、7 专有 */
</code></pre>
<ul>
<li>优点： 符合闭合浮动思想 结构语义化正确</li>
<li>缺点： 由于 IE6-7 不支持:after，使用 zoom:1 触发 hasLayout。</li>
<li>代表网站： 百度、淘宝网、网易等</li>
</ul>
<h4 id="使用双伪元素清除浮动"><a href="#使用双伪元素清除浮动" class="headerlink" title="使用双伪元素清除浮动"></a>使用双伪元素清除浮动</h4><p>使用方法：</p>
<pre><code class="css">.clearfix:before,
.clearfix:after {
  content: &quot;&quot;;
  display: table;
}
.clearfix:after {
  clear: both;
}
.clearfix {
  *zoom: 1;
}
</code></pre>
<ul>
<li><p>优点： 代码更简洁</p>
</li>
<li><p>缺点： 由于 IE6-7 不支持:after，使用 zoom:1 触发 hasLayout。</p>
</li>
<li><p>代表网站： 小米、腾讯等</p>
</li>
</ul>
]]></content:encoded>
      <comments>https://www.wztlink1013.com/blog/vgixv5vex3i8/#comments</comments>
    </item>
    
    <item>
      <title><![CDATA[CSS盒模型]]></title>
      <link>https://www.wztlink1013.com/blog/dnp4byvzqz87/</link>
      <guid>https://www.wztlink1013.com/blog/dnp4byvzqz87/</guid>
      <pubDate>Sun Jan 24 2021 20:39:17 GMT+0000 (Coordinated Universal Time)</pubDate>
      <description>
      <![CDATA[<h2 id="border"><a href="#border" class="headerlink" title="border"></a>border</h2><h3 id="border-综合"><a href="#border-综合" class="headerlink]]>
      </description>
      <content:encoded><![CDATA[<h2 id="border"><a href="#border" class="headerlink" title="border"></a>border</h2><h3 id="border-综合"><a href="#border-综合" class="headerlink" title="border 综合"></a>border 综合</h3><table>
<thead>
<tr>
<th>属性</th>
<th style="text-align:center">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>border-width</td>
<td style="text-align:center">定义边框粗细，单位是 px</td>
</tr>
<tr>
<td>border-style</td>
<td style="text-align:center">边框的样式</td>
</tr>
<tr>
<td>border-color</td>
<td style="text-align:center">边框颜色</td>
</tr>
</tbody>
</table>
<blockquote>
<p>【1】border-style</p>
</blockquote>
<ul>
<li>none：没有边框即忽略所有边框的宽度（默认值）</li>
<li>solid：边框为单实线(最为常用的)</li>
<li>dashed：边框为虚线</li>
<li>dotted：边框为点线<blockquote>
<p>【2】综合设置：盒子边框写法总结表</p>
</blockquote>
</li>
</ul>
<pre><code class="css">border: 1px solid red;
</code></pre>
<blockquote>
<p>【3】很多情况下，我们不需要指定 4 个边框，我们是可以单独给 4 个边框分别指定的。</p>
</blockquote>
<table>
<thead>
<tr>
<th style="text-align:left">上边框</th>
<th style="text-align:left">下边框</th>
<th style="text-align:left">左边框</th>
<th style="text-align:left">右边框</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">border-top-style:样式;</td>
<td style="text-align:left">border-bottom-style:样式;</td>
<td style="text-align:left">border-left-style:样式;</td>
<td style="text-align:left">border-right-style:样式;</td>
</tr>
<tr>
<td style="text-align:left">border-top-width:宽度;</td>
<td style="text-align:left">border- bottom-width:宽度;</td>
<td style="text-align:left">border-left-width:宽度;</td>
<td style="text-align:left">border-right-width:宽度;</td>
</tr>
<tr>
<td style="text-align:left">border-top-color:颜色;</td>
<td style="text-align:left">border- bottom-color:颜色;</td>
<td style="text-align:left">border-left-color:颜色;</td>
<td style="text-align:left">border-right-color:颜色;</td>
</tr>
<tr>
<td style="text-align:left">border-top:宽度 样式 颜色;</td>
<td style="text-align:left">border-bottom:宽度 样式 颜色;</td>
<td style="text-align:left">border-left:宽度 样式 颜色;</td>
<td style="text-align:left">border-right:宽度 样式 颜色;</td>
</tr>
</tbody>
</table>
<blockquote>
<p>表格的细线边框</p>
</blockquote>
<ul>
<li><p>通过表格的<code>cellspacing=&quot;0&quot;</code>,将单元格与单元格之间的距离设置为 0，</p>
</li>
<li><p>但是两个单元格之间的边框会出现重叠，从而使边框变粗</p>
</li>
<li><p>通过 css 属性：</p>
</li>
</ul>
<pre><code>table{ border-collapse:collapse; }
</code></pre><ul>
<li>collapse 单词是合并的意思</li>
<li>border-collapse:collapse; 表示相邻边框合并在一起。</li>
</ul>
<pre><code class="css">&lt;style&gt;
    table {
        width: 500px;
        height: 300px;
        border: 1px solid red;
    }
    td {
        border: 1px solid red;
        text-align: center;
    }
    table, td {
        border-collapse: collapse;  /*合并相邻边框*/
    }
&lt;/style&gt;
</code></pre>
<h3 id="border-radius"><a href="#border-radius" class="headerlink" title="border-radius"></a>border-radius</h3><ul>
<li>语法：</li>
</ul>
<pre><code class="css">border-radius: length;
</code></pre>
<ul>
<li><p>其中每一个值可以为 数值或百分比的形式。</p>
</li>
<li><p>让一个正方形（让这个盒子 width 和 height 相等）变成圆圈</p>
</li>
</ul>
<pre><code class="css">border-radius: 50%;
</code></pre>
<ul>
<li>百分比会是表示高度和宽度的一半的情况</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616160100879-1ec56967-ea20-4bd2-8327-519c75d1367f.png#align=left&amp;display=inline&amp;height=345&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=689&amp;originWidth=1920&amp;size=1162765&amp;status=done&amp;style=stroke&amp;width=960" alt="image.png"></p>
<h3 id="box-shadow"><a href="#box-shadow" class="headerlink" title="box-shadow"></a>box-shadow</h3><ul>
<li>语法:</li>
</ul>
<pre><code class="css">box-shadow: 水平阴影 垂直阴影 模糊距离（虚实） 阴影尺寸（影子大小） 阴影颜色
  内/外阴影；;
</code></pre>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611549557136-9945210f-61eb-44df-af61-5eb070818e6f.png#align=left&amp;display=inline&amp;height=306&amp;margin=%5Bobject%20Object%5D&amp;originHeight=306&amp;originWidth=862&amp;status=done&amp;style=stroke&amp;width=862" alt></p>
<ul>
<li>前两个属性是必须写的。其余的可以省略。</li>
<li>外阴影 (outset) 是默认的 但是不能写 想要内阴影可以写 inset</li>
</ul>
<h2 id="padding"><a href="#padding" class="headerlink" title="padding"></a>padding</h2><blockquote>
<p>内边距：padding 属性用于设置内边距。 <strong>是指 边框与内容之间的距离。</strong></p>
</blockquote>
<h3 id="padding-综合"><a href="#padding-综合" class="headerlink" title="padding 综合"></a>padding 综合</h3><table>
<thead>
<tr>
<th>属性</th>
<th style="text-align:left">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>padding-left</td>
<td style="text-align:left">左内边距</td>
</tr>
<tr>
<td>padding-right</td>
<td style="text-align:left">右内边距</td>
</tr>
<tr>
<td>padding-top</td>
<td style="text-align:left">上内边距</td>
</tr>
<tr>
<td>padding-bottom</td>
<td style="text-align:left">下内边距</td>
</tr>
</tbody>
</table>
<p>当我们给盒子指定 padding 值之后， 发生了 2 件事情：</p>
<ol>
<li>内容和边框 有了距离，添加了内边距。</li>
<li>盒子会变大了。</li>
</ol>
<p><strong>注意： 后面跟几个数值表示的意思是不一样的。</strong><br>我们分开写有点麻烦，我们可以不可以简写呢？</p>
<table>
<thead>
<tr>
<th>值的个数</th>
<th>表达意思</th>
</tr>
</thead>
<tbody>
<tr>
<td>1 个值</td>
<td>padding：上下左右内边距;</td>
</tr>
<tr>
<td>2 个值</td>
<td>padding: 上下内边距 左右内边距 ；</td>
</tr>
<tr>
<td>3 个值</td>
<td>padding：上内边距 左右内边距 下内边距；</td>
</tr>
<tr>
<td>4 个值</td>
<td>padding: 上内边距 右内边距 下内边距 左内边距 ；</td>
</tr>
</tbody>
</table>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611552112041-a7ed9154-18bb-478e-867f-92e7837719ea.png#align=left&amp;display=inline&amp;height=152&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=303&amp;originWidth=409&amp;size=41892&amp;status=done&amp;style=stroke&amp;width=204.5" alt="image.png">**</p>
<h3 id="内盒尺寸计算（元素实际大小）"><a href="#内盒尺寸计算（元素实际大小）" class="headerlink" title="内盒尺寸计算（元素实际大小）"></a>内盒尺寸计算（元素实际大小）</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611552122666-74470517-33eb-4212-b483-430e2bbd0ee5.png#align=left&amp;display=inline&amp;height=154&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=308&amp;originWidth=347&amp;size=26383&amp;status=done&amp;style=stroke&amp;width=173.5" alt="image.png"></p>
<ul>
<li><p>宽度：Element Height = content height + padding + border （Height 为内容高度）</p>
</li>
<li><p>高度：Element Width = content width + padding + border （Width 为内容宽度）</p>
</li>
<li><p>盒子的实际的大小 = 内容的宽度和高度 + 内边距 + 边框</p>
</li>
</ul>
<h3 id="内边距撑大盒子的解决方案"><a href="#内边距撑大盒子的解决方案" class="headerlink" title="内边距撑大盒子的解决方案"></a>内边距撑大盒子的解决方案</h3><blockquote>
<p>问题：会撑大原来的盒子</p>
</blockquote>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611552148703-03f4e9a2-62c0-4ef6-bcc9-daca7a48972f.png#align=left&amp;display=inline&amp;height=187&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=602&amp;originWidth=1127&amp;size=112122&amp;status=done&amp;style=stroke&amp;width=350" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611552164629-96bb4847-362e-4c50-ad11-9bf86c3cd22e.png#align=left&amp;display=inline&amp;height=213&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=715&amp;originWidth=1186&amp;size=132784&amp;status=done&amp;style=stroke&amp;width=353" alt="image.png"></p>
<blockquote>
<p>解决方案【1】：通过给设置了宽高的盒子，减去相应的内边距的值，维持盒子原有的大小</p>
</blockquote>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611552179527-c1060669-e26e-4c16-b0eb-0fa78c03b45b.png#align=left&amp;display=inline&amp;height=215&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=610&amp;originWidth=1113&amp;size=111733&amp;status=done&amp;style=stroke&amp;width=393" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611552188919-c9493a98-9f8f-4ba4-942c-83d9fd2a033f.png#align=left&amp;display=inline&amp;height=238&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=687&amp;originWidth=1145&amp;size=127523&amp;status=done&amp;style=stroke&amp;width=397" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611552197848-242d4e3f-1cdd-4f31-b86b-e42b549e2094.png#align=left&amp;display=inline&amp;height=223&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=667&amp;originWidth=1189&amp;size=128129&amp;status=done&amp;style=stroke&amp;width=397" alt="image.png"><br>关于根据下列代码计算 盒子宽高下列说法正确的是（）</p>
<pre><code class="css">div {
  width: 200px;
  height: 200px;
  border: 1px solid #000000;
  border-top: 5px solid blue;
  padding: 50px;
  padding-left: 100px;
}
</code></pre>
<ul>
<li>(A) 宽度为 200px 高度为 200px</li>
<li>(B) 宽度为 352px 高度为 306px</li>
<li>(C) 宽度为 302px 高度为 307px</li>
<li>(D) 宽度为 302px 高度为 252px</li>
</ul>
<p>w 200 + 150 + 2 = 352<br>h 200 + 100 + 6 = 306</p>
<blockquote>
<p>解决方案【2】：设置 box-sizing 属性</p>
</blockquote>
<pre><code class="css">-moz-box-sizing: border-box; /*Firefox3.5+*/
-webkit-box-sizing: border-box; /*Safari3.2+*/
-o-box-sizing: border-box; /*Opera9.6*/
-ms-box-sizing: border-box; /*IE8*/
box-sizing: border-box; /*W3C标准(IE9+，Safari5.1+,Chrome10.0+,Opera10.6+都符合box-sizing的w3c标准语法)*/
</code></pre>
<p>注意：box-sizing 属性是 CSS3 的属性，IE 低版本不支持，注意兼容性<br>参考：</p>
<ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/box-sizing" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/CSS/box-sizing</a></li>
<li><a href="https://www.zhihu.com/question/31031251" target="_blank" rel="noopener">https://www.zhihu.com/question/31031251</a></li>
</ul>
<h3 id="内边距不影响盒子大小情况"><a href="#内边距不影响盒子大小情况" class="headerlink" title="内边距不影响盒子大小情况"></a>内边距不影响盒子大小情况</h3><blockquote>
<p>如果没有给一个盒子指定宽度， 此时，如果给这个盒子指定 padding， 则不会撑开盒子。</p>
</blockquote>
<h2 id="margin"><a href="#margin" class="headerlink" title="margin"></a>margin</h2><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611552211186-1bc52b3c-f2d9-418b-99d8-582718465af1.png#align=left&amp;display=inline&amp;height=250&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=500&amp;originWidth=950&amp;size=49287&amp;status=done&amp;style=stroke&amp;width=475" alt="image.png"><br>margin 属性用于设置外边距。 margin 就是控制<strong>盒子和盒子之间的距离</strong></p>
<h3 id="padding-综合-1"><a href="#padding-综合-1" class="headerlink" title="padding 综合"></a>padding 综合</h3><table>
<thead>
<tr>
<th>属性</th>
<th style="text-align:left">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>margin-left</td>
<td style="text-align:left">左外边距</td>
</tr>
<tr>
<td>margin-right</td>
<td style="text-align:left">右外边距</td>
</tr>
<tr>
<td>margin-top</td>
<td style="text-align:left">上外边距</td>
</tr>
<tr>
<td>margin-bottom</td>
<td style="text-align:left">下外边距</td>
</tr>
</tbody>
</table>
<p>margin 值的简写 （复合写法）代表意思 跟 padding 完全相同。</p>
<h2 id="display"><a href="#display" class="headerlink" title="display"></a>display</h2><h3 id="什么是标签显示模式"><a href="#什么是标签显示模式" class="headerlink" title="什么是标签显示模式"></a>什么是标签显示模式</h3><ul>
<li><p>什么是标签的显示模式？<br>标签以什么方式进行显示，比如 div 自己占一行， 比如 span 一行可以放很多个</p>
</li>
<li><p>作用：<br>我们网页的标签非常多，再不同地方会用到不同类型的标签，以便更好的完成我们的网页。</p>
</li>
<li><p>标签的类型(分类)<br>HTML 标签一般分为块标签和行内标签两种类型，它们也称块元素和行内元素。</p>
</li>
</ul>
<h3 id="块级元素-block-level"><a href="#块级元素-block-level" class="headerlink" title="块级元素(block-level)"></a>块级元素(block-level)</h3><ul>
<li>例：</li>
</ul>
<pre><code>常见的块元素有&lt;h1&gt;~&lt;h6&gt;、&lt;p&gt;、&lt;div&gt;、&lt;ul&gt;、&lt;ol&gt;、&lt;li&gt;等，其中&lt;div&gt;标签是最典型的块元素。
</code></pre><ul>
<li>块级元素的特点</li>
</ul>
<p>（1）比较霸道，自己独占一行<br>（2）高度，宽度、外边距以及内边距都可以控制。<br>（3）宽度默认是容器（父级宽度）的 100%<br>（4）是一个容器及盒子，里面可以放行内或者块级元素。</p>
<ul>
<li>只有 文字才 能组成段落 因此 p 里面不能放块级元素，特别是 p 不能放 div</li>
<li>同理还有这些标签 h1,h2,h3,h4,h5,h6,dt，他们都是文字类块级标签，里面不能放其他块级元素。</li>
</ul>
<h3 id="行内元素-inline-level"><a href="#行内元素-inline-level" class="headerlink" title="行内元素(inline-level)"></a>行内元素(inline-level)</h3><ul>
<li>例：</li>
</ul>
<pre><code>常见的行内元素有&lt;a&gt;、&lt;strong&gt;、&lt;b&gt;、&lt;em&gt;、&lt;i&gt;、&lt;del&gt;、&lt;s&gt;、&lt;ins&gt;、&lt;u&gt;、&lt;span&gt;等，其中&lt;span&gt;标签最典型的行内元素。有的地方也成内联元素
</code></pre><ul>
<li>行内元素的特点：</li>
</ul>
<p>（1）相邻行内元素在一行上，一行可以显示多个。<br>（2）高、宽直接设置是无效的。<br>（3）默认宽度就是它本身内容的宽度。<br>（4）<strong>行内元素只能容纳文本或则其他行内元素。</strong></p>
<ul>
<li>链接里面不能再放链接。</li>
<li>特殊情况 a 里面可以放块级元素，但是给 a 转换一下块级模式最安全。</li>
</ul>
<h3 id="行内块元素（inline-block）"><a href="#行内块元素（inline-block）" class="headerlink" title="行内块元素（inline-block）"></a>行内块元素（inline-block）</h3><ul>
<li>例：</li>
</ul>
<pre><code>在行内元素中有几个特殊的标签——&lt;img /&gt;、&lt;input /&gt;、&lt;td&gt;，可以对它们设置宽高和对齐属性，有些资料可能会称它们为行内块元素。
</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611551937533-f958d872-1942-4aee-8533-8671afa1dc82.png#align=left&amp;display=inline&amp;height=258&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=515&amp;originWidth=1217&amp;size=75676&amp;status=done&amp;style=stroke&amp;width=608.5" alt="image.png"></p>
<ul>
<li>行内块元素的特点：<br>（1）和相邻行内元素（行内块）在一行上,但是之间会有空白缝隙。一行可以显示多个<br>（2）默认宽度就是它本身内容的宽度。<br>（3）高度，行高、外边距以及内边距都可以控制。</li>
</ul>
<h3 id="display-1"><a href="#display-1" class="headerlink" title="display"></a>display</h3><ul>
<li>块转行内：display:inline;</li>
<li>行内转块：display:block;</li>
<li>块、行内元素转换为行内块： display: inline-block;</li>
</ul>
<p>此阶段，我们只需关心这三个，其他的是我们后面的工作。</p>
<h2 id="盒模型的相关问题"><a href="#盒模型的相关问题" class="headerlink" title="盒模型的相关问题"></a>盒模型的相关问题</h2><h3 id="块级盒子水平居中"><a href="#块级盒子水平居中" class="headerlink" title="块级盒子水平居中"></a>块级盒子水平居中</h3><ul>
<li>一个块级盒子实现水平居中必须：<ul>
<li>盒子必须指定了宽度（width）</li>
<li>然后就给<strong>左右的外边距都设置为 auto</strong>，</li>
</ul>
</li>
</ul>
<p>实际工作中常用这种方式进行网页布局，示例代码如下：</p>
<pre><code class="css">.header {
  width: 960px;
  margin: 0 auto;
}
</code></pre>
<p>常见的写法，以下下三种都可以。</p>
<ul>
<li>margin-left: auto; margin-right: auto;</li>
<li>margin: auto;</li>
<li>margin: 0 auto;</li>
</ul>
<h3 id="文字居中和盒子居中区别"><a href="#文字居中和盒子居中区别" class="headerlink" title="文字居中和盒子居中区别"></a>文字居中和盒子居中区别</h3><ol>
<li>盒子内的文字水平居中是 text-align: center, 而且还可以让行内元素和行内块居中对齐</li>
<li>块级盒子水平居中左右 margin 改为 auto</li>
</ol>
<pre><code class="css">text-align: center; /*  文字 行内元素 行内块元素水平居中 */
margin: 10px auto; /* 块级盒子水平居中  左右margin 改为 auto 就阔以了 上下margin都可以 */
</code></pre>
<h3 id="插入图片和背景图片区别"><a href="#插入图片和背景图片区别" class="headerlink" title="插入图片和背景图片区别"></a>插入图片和背景图片区别</h3><ol>
<li>插入图片 我们用的最多 比如产品展示类 移动位置只能靠盒模型 padding margin</li>
<li>背景图片我们一般用于小图标背景 或者 超大背景图片 背景图片 只能通过 background-position</li>
</ol>
<pre><code class="css">img {
  width: 200px; /* 插入图片更改大小 width 和 height */
  height: 210px;
  margin-top: 30px; /* 插入图片更改位置 可以用margin 或padding  盒模型 */
  margin-left: 50px; /* 插入当图片也是一个盒子 */
}
div {
  width: 400px;
  height: 400px;
  border: 1px solid purple;
  background: #fff url(images/sun.jpg) no-repeat;
  background-position: 30px 50px; /* 背景图片更改位置 我用 background-position */
}
</code></pre>
<h3 id="清除元素的默认内外边距"><a href="#清除元素的默认内外边距" class="headerlink" title="清除元素的默认内外边距"></a>清除元素的默认内外边距</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611552224242-7158d827-f872-4872-9c9d-598c846d74b9.png#align=left&amp;display=inline&amp;height=178&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=355&amp;originWidth=1075&amp;size=48809&amp;status=done&amp;style=stroke&amp;width=537.5" alt="image.png"><br>为了更灵活方便地控制网页中的元素，制作网页时，我们需要将元素的默认内外边距清除<br>代码：</p>
<pre><code class="css">* {
  padding: 0; /* 清除内边距 */
  margin: 0; /* 清除外边距 */
}
</code></pre>
<ul>
<li>行内元素为了照顾兼容性， 尽量只设置左右内外边距， 不要设置上下内外边距。</li>
</ul>
<h3 id="margin-塌陷问题"><a href="#margin-塌陷问题" class="headerlink" title="margin 塌陷问题"></a>margin 塌陷问题</h3><p>使用 margin 定义块元素的<strong>垂直外边距</strong>时，可能会出现外边距的合并。</p>
<blockquote>
<p>相邻块元素垂直外边距的合并</p>
</blockquote>
<ul>
<li>当上下相邻的两个块元素相遇时，如果上面的元素有下外边距 margin-bottom</li>
<li>下面的元素有上外边距 margin-top，则他们之间的垂直间距不是 margin-bottom 与 margin-top 之和</li>
<li><strong>取两个值中的较大者</strong>这种现象被称为相邻块元素垂直外边距的合并（也称外边距塌陷）。</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611549556832-735ecd9b-2e20-4413-a635-cedc3692442f.png#align=left&amp;display=inline&amp;height=309&amp;margin=%5Bobject%20Object%5D&amp;originHeight=309&amp;originWidth=504&amp;status=done&amp;style=stroke&amp;width=504" alt><br><strong>解决方案：**</strong>尽量给只给一个盒子添加 margin 值**。</p>
<blockquote>
<p>嵌套块元素垂直外边距的合并（塌陷）</p>
</blockquote>
<ul>
<li>对于两个嵌套关系的块元素，如果父元素没有上内边距及边框</li>
<li>父元素的上外边距会与子元素的上外边距发生合并</li>
<li>合并后的外边距为两者中的较大者</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611549556894-4dc0bcd3-d5ed-467c-b725-bf4477a4e93c.png#align=left&amp;display=inline&amp;height=195&amp;margin=%5Bobject%20Object%5D&amp;originHeight=195&amp;originWidth=504&amp;status=done&amp;style=stroke&amp;width=504" alt><br><strong>解决方案：</strong></p>
<ol>
<li>可以为父元素定义上边框。</li>
<li>可以为父元素定义上内边距</li>
<li>可以为父元素添加 overflow:hidden。</li>
</ol>
<p>还有其他方法，比如浮动、固定、绝对定位的盒子不会有问题，后面咱们再总结。。。</p>
<h3 id="盒子模型布局稳定性"><a href="#盒子模型布局稳定性" class="headerlink" title="盒子模型布局稳定性"></a>盒子模型布局稳定性</h3><ul>
<li>根据稳定性来分：按照 优先使用 宽度 （width） 其次 使用内边距（padding） 再次 外边距（margin）。</li>
<li>margin 会有外边距合并 还有 ie6 下面 margin 加倍的 bug（讨厌）所以最后使用。</li>
<li>padding 会影响盒子大小， 需要进行加减计算（麻烦） 其次使用。</li>
<li>width 没有问题，经常使用宽度剩余法 高度剩余法来做。</li>
</ul>
<h3 id="line-height-的问题"><a href="#line-height-的问题" class="headerlink" title="line-height 的问题"></a>line-height 的问题</h3><blockquote>
<p>【1】行高测量</p>
</blockquote>
<p>行高的测量方法：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611549555568-b660d3a6-0153-453f-ae22-fc831f79d659.png#align=left&amp;display=inline&amp;height=183&amp;margin=%5Bobject%20Object%5D&amp;originHeight=291&amp;originWidth=648&amp;status=done&amp;style=stroke&amp;width=407" alt><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611549555629-ba0bce7a-f7b1-49ff-89aa-c14496ccbcb6.png#align=left&amp;display=inline&amp;height=148&amp;margin=%5Bobject%20Object%5D&amp;originHeight=291&amp;originWidth=800&amp;status=done&amp;style=stroke&amp;width=408" alt></p>
<blockquote>
<p>【2】单行文本垂直居中</p>
</blockquote>
<p>行高我们利用最多的一个地方是： 可以让单行文本在盒子中垂直居中对齐。</p>
<blockquote>
<p><strong>文字的行高等于盒子的高度。</strong></p>
</blockquote>
<p>这里情况些许复杂，开始学习，我们可以先从简单地方入手学会。<br>行高 = 上距离 + 内容高度 + 下距离<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611549555695-02bf584b-9ece-45fe-a081-52aaf565d20d.png#align=left&amp;display=inline&amp;height=312&amp;margin=%5Bobject%20Object%5D&amp;originHeight=174&amp;originWidth=391&amp;status=done&amp;style=stroke&amp;width=700" alt><br>上距离和下距离总是相等的，因此文字看上去是垂直居中的。<br><strong>行高和高度的三种关系</strong></p>
<ul>
<li>如果 行高 等 高度 文字会 垂直居中</li>
<li>如果行高 大于 高度 文字会 偏下</li>
<li>如果行高小于高度 文字会 偏上</li>
</ul>
<p>###</p>
]]></content:encoded>
      <comments>https://www.wztlink1013.com/blog/dnp4byvzqz87/#comments</comments>
    </item>
    
    <item>
      <title><![CDATA[CSS字体和背景]]></title>
      <link>https://www.wztlink1013.com/blog/sideak09lpko/</link>
      <guid>https://www.wztlink1013.com/blog/sideak09lpko/</guid>
      <pubDate>Sun Jan 24 2021 20:39:14 GMT+0000 (Coordinated Universal Time)</pubDate>
      <description>
      <![CDATA[<h2 id="字体相关"><a href="#字体相关" class="headerlink" title="字体相关"></a>字体相关</h2><h3 id="font-size"><a href="#font-size" class="headerlink" title=]]>
      </description>
      <content:encoded><![CDATA[<h2 id="字体相关"><a href="#字体相关" class="headerlink" title="字体相关"></a>字体相关</h2><h3 id="font-size"><a href="#font-size" class="headerlink" title="font-size"></a>font-size</h3><ul>
<li>作用：<br>font-size 属性用于设置字号</li>
</ul>
<pre><code class="css">p {
  font-size: 20px;
}
</code></pre>
<ul>
<li>单位：<ul>
<li>可以使用相对长度单位，也可以使用绝对长度单位。</li>
<li>相对长度单位比较常用，推荐使用像素单位 px，绝对长度单位使用较少。</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611549554219-97b92fc6-0b55-4946-a903-080b2dfa44fa.png#align=left&amp;display=inline&amp;height=308&amp;margin=%5Bobject%20Object%5D&amp;originHeight=308&amp;originWidth=637&amp;status=done&amp;style=stroke&amp;width=637" alt><br><strong>注意：</strong></p>
<ul>
<li>我们文字大小以后，基本就用 px 了，其他单位很少使用</li>
<li>谷歌浏览器默认的文字大小为 16px</li>
<li>但是不同浏览器可能默认显示的字号大小不一致，我们尽量给一个明确值大小，不要默认大小。一般给 body 指定整个页面文字的大小</li>
</ul>
<h3 id="font-family"><a href="#font-family" class="headerlink" title="font-family"></a>font-family</h3><pre><code>p{ font-family:&quot;微软雅黑&quot;;}
</code></pre><ul>
<li>网页中常用的字体有宋体、微软雅黑、黑体等，例如将网页中所有段落文本的字体设置为微软雅黑</li>
<li>可以同时指定多个字体，中间以逗号隔开，表示如果浏览器不支持第一个字体，则会尝试下一个，直到找到合适的字体， 如果都没有，则以我们电脑默认的字体为准。</li>
</ul>
<pre><code>p{font-family: Arial,&quot;Microsoft Yahei&quot;, &quot;微软雅黑&quot;;}
</code></pre><blockquote>
<p>常用技巧：</p>
<ol>
<li>各种字体之间必须使用英文状态下的逗号隔开。</li>
<li>中文字体需要加英文状态下的引号，英文字体一般不需要加引号。当需要设置英文字体时，英文字体名必须位于中文字体名之前。</li>
<li>如果字体名中包含空格、#、$等符号，则该字体必须加英文状态下的单引号或双引号，例如 font-family: “Times New Roman”;。</li>
<li>尽量使用系统默认字体，保证在任何用户的浏览器中都能正确显示。</li>
</ol>
</blockquote>
<p>###</p>
<blockquote>
<p>CSS Unicode 字体</p>
</blockquote>
<ul>
<li>为什么使用 Unicode 字体<ul>
<li>在 CSS 中设置字体名称，直接写中文是可以的。但是在文件编码（GB2312、UTF-8 等）不匹配时会产生乱码的错误。</li>
<li>xp 系统不支持 类似微软雅黑的中文。</li>
</ul>
</li>
<li><p>解决方案一： 你可以使用英文来替代。 比如<code>font-family:&quot;Microsoft Yahei&quot;</code>。</p>
</li>
<li><p>解决方案二： 在 CSS 直接使用 Unicode 编码来写字体名称可以避免这些错误。使用 Unicode 写中文字体名称，浏览器是可以正确的解析的，记住！是在 CSS 里面</p>
</li>
</ul>
<pre><code class="css">font-family: &quot;\5FAE\8F6F\96C5\9ED1&quot;;   表示设置字体为“微软雅黑”。
</code></pre>
<table>
<thead>
<tr>
<th>字体名称</th>
<th>英文名称</th>
<th>Unicode 编码</th>
</tr>
</thead>
<tbody>
<tr>
<td>宋体</td>
<td>SimSun</td>
<td>\5B8B\4F53</td>
</tr>
<tr>
<td>新宋体</td>
<td>NSimSun</td>
<td>\65B0\5B8B\4F53</td>
</tr>
<tr>
<td>黑体</td>
<td>SimHei</td>
<td>\9ED1\4F53</td>
</tr>
<tr>
<td>微软雅黑</td>
<td>Microsoft YaHei</td>
<td>\5FAE\8F6F\96C5\9ED1</td>
</tr>
<tr>
<td>楷体_GB2312</td>
<td>KaiTi_GB2312</td>
<td>\6977\4F53_GB2312</td>
</tr>
<tr>
<td>隶书</td>
<td>LiSu</td>
<td>\96B6\4E66</td>
</tr>
<tr>
<td>幼园</td>
<td>YouYuan</td>
<td>\5E7C\5706</td>
</tr>
<tr>
<td>华文细黑</td>
<td>STXihei</td>
<td>\534E\6587\7EC6\9ED1</td>
</tr>
<tr>
<td>细明体</td>
<td>MingLiU</td>
<td>\7EC6\660E\4F53</td>
</tr>
<tr>
<td>新细明体</td>
<td>PMingLiU</td>
<td>\65B0\7EC6\660E\4F53</td>
</tr>
</tbody>
</table>
<p>为了照顾不同电脑的字体安装问题，我们尽量只使用宋体和微软雅黑中文字体</p>
<h3 id="font-weight"><a href="#font-weight" class="headerlink" title="font-weight"></a>font-weight</h3><ul>
<li>在 html 中使用 b 和 strong 标签是文本加粗。</li>
<li>可以使用 CSS 来实现，但是 CSS 是没有语义的。<br>| 属性值 | 描述 |<br>| — | :— |<br>| normal | 默认值（不加粗的） |<br>| bold | 定义粗体（加粗的） |<br>| 100~900 | 400 等同于 normal，而 700 等同于 bold  |</li>
</ul>
<h3 id="font-style"><a href="#font-style" class="headerlink" title="font-style"></a>font-style</h3><ul>
<li>在 html 中字体倾斜用 i 和 em 标签，</li>
<li>可以使用 CSS 来实现，但是 CSS 是没有语义的</li>
</ul>
<p>font-style 属性用于定义字体风格，如设置斜体、倾斜或正常字体，其可用属性值如下：</p>
<table>
<thead>
<tr>
<th>属性</th>
<th style="text-align:left">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>normal</td>
<td style="text-align:left">默认值，浏览器会显示标准的字体样式 font-style: normal;</td>
</tr>
<tr>
<td>italic</td>
<td style="text-align:left">浏览器会显示斜体的字体样式。</td>
</tr>
</tbody>
</table>
<h3 id="font-综合设置"><a href="#font-综合设置" class="headerlink" title="font 综合设置"></a>font 综合设置</h3><ul>
<li>基本语法格式如下：</li>
</ul>
<pre><code class="css">选择器 {
  font: font-style font-weight font-size/line-height font-family;
}
</code></pre>
<ul>
<li>使用 font 属性时，必须按上面语法格式中的顺序书写，不能更换顺序，各个属性以<strong>空格</strong>隔开。</li>
<li>其中不需要设置的属性可以省略（取默认值），但必须保留 font-size 和 font-family 属性，否则 font 属性将不起作用。</li>
</ul>
<h3 id="color"><a href="#color" class="headerlink" title="color"></a>color</h3><ul>
<li>作用：color 属性用于定义文本的颜色，</li>
<li>一般选用十六进制的</li>
<li>其取值方式有如下 3 种：</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:left">表示表示</th>
<th style="text-align:left">属性值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">预定义的颜色值</td>
<td style="text-align:left">red，green，blue，还有我们的御用色 pink</td>
</tr>
<tr>
<td style="text-align:left">十六进制</td>
<td style="text-align:left">#FF0000，#FF6600，#29D794</td>
</tr>
<tr>
<td style="text-align:left">RGB 代码</td>
<td style="text-align:left">rgb(255,0,0)或 rgb(100%,0%,0%)</td>
</tr>
</tbody>
</table>
<h3 id="text-align"><a href="#text-align" class="headerlink" title="text-align"></a>text-align</h3><ul>
<li><p>文本水平对齐方式：text-align 属性用于设置文本内容的水平对齐，相当于 html 中的 align 对齐属性</p>
</li>
<li><p>其可用属性值如下：</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>属性</th>
<th style="text-align:center">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>left</td>
<td style="text-align:center">左对齐（默认值）</td>
</tr>
<tr>
<td>right</td>
<td style="text-align:center">右对齐</td>
</tr>
<tr>
<td>center</td>
<td style="text-align:center">居中对齐</td>
</tr>
</tbody>
</table>
<ul>
<li>注意：<br>是让盒子里面的内容水平居中， 而不是让盒子居中对齐</li>
</ul>
<h3 id="TODO-line-height"><a href="#TODO-line-height" class="headerlink" title="TODO: line-height"></a>TODO: line-height</h3><ul>
<li><p>行间距：line-height 属性用于设置行间距，就是行与行之间的距离，即字符的垂直间距，一般称为行高。</p>
</li>
<li><p>单位：line-height 常用的属性值单位有三种，分别为像素 px，相对值 em 和百分比%，实际工作中使用最多的是像素 px</p>
</li>
</ul>
<pre><code>一般情况下，行距比字号大7.8像素左右就可以了。
line-height: 24px;
</code></pre><h3 id="text-indent"><a href="#text-indent" class="headerlink" title="text-indent"></a>text-indent</h3><ul>
<li><p>作用：text-indent 属性用于设置首行文本的缩进，</p>
</li>
<li><p>其属性值可为不同单位的数值、em 字符宽度的倍数、或相对于浏览器窗口宽度的百分比%，允许使用负值,</p>
</li>
<li>建议使用 em 作为设置单位，<strong>1em 就是一个字的宽度 如果是汉字的段落， 1em 就是一个汉字的宽度</strong></li>
</ul>
<pre><code class="css">p {
  /*行间距*/
  line-height: 25px;
  /*首行缩进2个字  em  1个em 就是1个字的大小*/
  text-indent: 2em;
}
</code></pre>
<h3 id="text-decoration"><a href="#text-decoration" class="headerlink" title="text-decoration"></a>text-decoration</h3><ul>
<li>text-decoration 通常我们用于给链接修改装饰效果<br>| 值 | 描述 |<br>| — | — |<br>| none | 默认。定义标准的文本。 取消下划线（最常用） |<br>| underline | 定义文本下的一条线。下划线 也是我们链接自带的（常用） |<br>| overline | 定义文本上的一条线。（不用） |<br>| line-through | 定义穿过文本下的一条线。（不常用） |</li>
</ul>
<h2 id="背景相关"><a href="#背景相关" class="headerlink" title="背景相关"></a>背景相关</h2><h3 id="background-color"><a href="#background-color" class="headerlink" title="background-color"></a>background-color</h3><ul>
<li>background-color: 颜色值;</li>
<li>默认的值是 transparent   透明的</li>
</ul>
<h3 id="background-image"><a href="#background-image" class="headerlink" title="background-image"></a>background-image</h3><ul>
<li>background-image : url(images/demo.png);</li>
<li>背景图片后面的地址，url 不要加引号。</li>
</ul>
<pre><code class="css">background-image: none | url (url);
</code></pre>
<table>
<thead>
<tr>
<th>参数</th>
<th style="text-align:center">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>none</td>
<td style="text-align:center">无背景图（默认的）</td>
</tr>
<tr>
<td>url</td>
<td style="text-align:center">使用绝对或相对地址指定背景图像</td>
</tr>
</tbody>
</table>
<h3 id="background-repeat"><a href="#background-repeat" class="headerlink" title="background-repeat"></a>background-repeat</h3><ul>
<li>语法：</li>
</ul>
<pre><code class="css">background-repeat: repeat | no-repeat | repeat-x | repeat-y;
</code></pre>
<table>
<thead>
<tr>
<th>参数</th>
<th style="text-align:center">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>repeat</td>
<td style="text-align:center">背景图像在纵向和横向上平铺（默认的）</td>
</tr>
<tr>
<td>no-repeat</td>
<td style="text-align:center">背景图像不平铺</td>
</tr>
<tr>
<td>repeat-x</td>
<td style="text-align:center">背景图像在横向上平铺</td>
</tr>
<tr>
<td>repeat-y</td>
<td style="text-align:center">背景图像在纵向平铺</td>
</tr>
</tbody>
</table>
<h3 id="background-position"><a href="#background-position" class="headerlink" title="background-position"></a>background-position</h3><ul>
<li>语法：</li>
</ul>
<pre><code class="css">background-position : length || length
background-position : position || position
</code></pre>
<ul>
<li><p>参数解释<br>| 参数 | 值 |<br>| — | :—: |<br>| length | 百分数 | 由浮点数字和单位标识符组成的长度值 |<br>| position | top | center | bottom | left | center | right 方位名词 |</p>
</li>
<li><p>必须先指定 background-image 属性</p>
</li>
<li>position 后面是 x 坐标和 y 坐标。 可以使用方位名词或者 精确单位。</li>
<li>如果指定两个值，两个值都是方位名字，则两个值前后顺序无关，比如 left top 和 top left 效果一致</li>
<li>如果只指定了一个方位名词，另一个值默认居中对齐。</li>
<li>如果 position 后面是精确坐标， 那么第一个，肯定是 x 第二的一定是 y</li>
<li>如果只指定一个数值,那该数值一定是 x 坐标，另一个默认垂直居中</li>
<li>如果指定的两个值是 精确单位和方位名字混合使用，则第一个值是 x 坐标，第二个值是 y 坐标</li>
<li><strong>实际工作用的最多的，就是背景图片居中对齐了。</strong></li>
</ul>
<h3 id="background-attachment"><a href="#background-attachment" class="headerlink" title="background-attachment"></a>background-attachment</h3><ul>
<li><p>背景附着就是解释背景是滚动的还是固定的</p>
</li>
<li><p>语法：</p>
</li>
</ul>
<pre><code class="css">background-attachment: scroll | fixed;
</code></pre>
<table>
<thead>
<tr>
<th>参数</th>
<th style="text-align:center">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>scroll</td>
<td style="text-align:center">背景图像是随对象内容滚动</td>
</tr>
<tr>
<td>fixed</td>
<td style="text-align:center">背景图像固定</td>
</tr>
</tbody>
</table>
<h3 id="背景简写"><a href="#背景简写" class="headerlink" title="背景简写"></a>背景简写</h3><ul>
<li>background：属性的值的书写顺序官方并没有强制标准的。</li>
<li>background: 背景颜色 背景图片地址 背景平铺 背景滚动 背景位置;</li>
<li>语法：</li>
</ul>
<pre><code class="css">background: blue url(image.jpg) repeat-y scroll center top;
</code></pre>
<h3 id="背景透明-CSS3"><a href="#背景透明-CSS3" class="headerlink" title="背景透明(CSS3)"></a>背景透明(CSS3)</h3><ul>
<li>语法：</li>
</ul>
<pre><code class="css">background: rgba(0, 0, 0, 0);
</code></pre>
<ul>
<li>最后一个参数是 alpha 透明度 取值范围 0~1 之间</li>
<li>我们习惯把 0.3 的 0 省略掉 这样写 background: rgba(0, 0, 0, .3);</li>
<li>注意： 背景半透明是指盒子背景半透明， 盒子里面的内容不受影响</li>
<li>因为是 CSS3 ，所以 低于 ie9 的版本是不支持的。</li>
</ul>
]]></content:encoded>
      <comments>https://www.wztlink1013.com/blog/sideak09lpko/#comments</comments>
    </item>
    
    <item>
      <title><![CDATA[HTML5总结]]></title>
      <link>https://www.wztlink1013.com/blog/vxz6aq7m0szt/</link>
      <guid>https://www.wztlink1013.com/blog/vxz6aq7m0szt/</guid>
      <pubDate>Sun Jan 24 2021 20:07:41 GMT+0000 (Coordinated Universal Time)</pubDate>
      <description>
      <![CDATA[<h2 id="HTML5"><a href="#HTML5" class="headerlink" title="HTML5"></a>HTML5</h2><div style="background: #E8F7FF;padding:10px;border: 1px soli]]>
      </description>
      <content:encoded><![CDATA[<h2 id="HTML5"><a href="#HTML5" class="headerlink" title="HTML5"></a>HTML5</h2><div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">新版本的 HTML 语言，定义了新的标签、特性和属性</div>

<h3 id="常用文档"><a href="#常用文档" class="headerlink" title="常用文档"></a>常用文档</h3><blockquote>
<p>W3C : <a href="http://www.w3school.com.cn/" target="_blank" rel="noopener">http://www.w3school.com.cn/</a><br>MDN: <a href="https://developer.mozilla.org/zh-CN/" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/</a><br>菜鸟：<a href="https://www.runoob.com/" target="_blank" rel="noopener">https://www.runoob.com/</a></p>
</blockquote>
<h3 id="扩展的内容"><a href="#扩展的内容" class="headerlink" title="扩展的内容"></a>扩展的内容</h3><ul>
<li>语义化标签</li>
<li>本地存储</li>
<li>兼容特性</li>
<li>2D、3D</li>
<li>动画、过渡</li>
<li>CSS3 特性</li>
<li>性能与集成</li>
</ul>
<h2 id="HTML5-文档结构-语义化标签"><a href="#HTML5-文档结构-语义化标签" class="headerlink" title="HTML5 文档结构/语义化标签"></a>HTML5 文档结构/语义化标签</h2><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616663386514-c6d53c70-d47f-4e40-b6f8-4a0f0596489b.png#align=left&amp;display=inline&amp;height=215&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=429&amp;originWidth=669&amp;size=51321&amp;status=done&amp;style=stroke&amp;width=334.5" alt="image.png"></p>
<ul>
<li><a href="https://www.jianshu.com/p/c41b88217834" target="_blank" rel="noopener">https://www.jianshu.com/p/c41b88217834</a></li>
<li><a href="https://juejin.cn/post/6844903544995184653" target="_blank" rel="noopener">https://juejin.cn/post/6844903544995184653</a></li>
</ul>
<h2 id="lt-DOCTYPE-gt"><a href="#lt-DOCTYPE-gt" class="headerlink" title="&lt;!DOCTYPE&gt;"></a>&lt;!DOCTYPE&gt;</h2><ul>
<li>html5 的文档类型声明：声明位于文档中的最前面的位置，处于 标签之前。此标签可告知浏览器文档使用哪种 HTML 或 XHTML 规范。</li>
<li>一些老网站可能用的还是老版本的文档类型比如 XHTML 之类的，但是我们学的是 HTML5,而且 HTML5 的文档类型兼容很好(向下兼容的原则)</li>
</ul>
<h2 id="charset"><a href="#charset" class="headerlink" title="charset"></a>charset</h2><ul>
<li>html5 文档编码格式的指定</li>
</ul>
<pre><code class="html">&lt;meta charset=&quot;UTF-8&quot; /&gt;
</code></pre>
<blockquote>
<p>字符集(Character set)是多个字符的集合。<br>计算机要准确的处理各种字符集文字，需要进行字符编码，以便计算机能够识别和存储各种文字。</p>
</blockquote>
<p>utf-8 是目前最常用的字符集编码方式，常用的字符集编码方式还有 gbk 和 gb2312。</p>
<ul>
<li>gb2312 简单中文 包括 6763 个汉字</li>
<li>BIG5 繁体中文 港澳台等用</li>
<li>GBK 包含全部中文字符 是 GB2312 的扩展，加入对繁体字的支持，兼容 GB2312</li>
<li>UTF-8 则基本包含全世界所有国家需要用到的字符</li>
</ul>
<h2 id="多媒体音频标签"><a href="#多媒体音频标签" class="headerlink" title="多媒体音频标签"></a>多媒体音频标签</h2><ol>
<li>多媒体标签有两个，分别是</li>
</ol>
<ul>
<li>音频  – <code>audio</code></li>
<li>视频  – <code>video</code></li>
</ul>
<ol start="2">
<li><code>audio</code> 标签说明</li>
</ol>
<ul>
<li>可以在不使用标签的情况下，也能够原生的支持音频格式文件的播放，</li>
<li>但是：播放格式是有限的</li>
</ul>
<ol start="3">
<li><p>audio 支持的音频格式</p>
<ul>
<li>audio 目前支持三种格式</li>
</ul>
</li>
<li><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1615560874331-7786480d-ad33-403e-976d-73e235a0f3ec.png#align=left&amp;display=inline&amp;height=130&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=260&amp;originWidth=1179&amp;size=48950&amp;status=done&amp;style=none&amp;width=589.5" alt="image.png"></p>
</li>
<li>audio 的参数<img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1615560883989-c202ee16-7e45-4c86-ac47-3e3ba07fc2a7.png#align=left&amp;display=inline&amp;height=210&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=420&amp;originWidth=1203&amp;size=105644&amp;status=done&amp;style=none&amp;width=601.5" alt="image.png"></li>
</ol>
<p>5、audio 代码演示</p>
<pre><code class="css">&lt;body&gt;
  &lt;!-- 注意：在 chrome 浏览器中已经禁用了 autoplay 属性 --&gt;
  &lt;!-- &lt;audio src=&quot;./media/snow.mp3&quot; controls autoplay&gt;&lt;/audio&gt; --&gt;
  &lt;!--
    因为不同浏览器支持不同的格式，所以我们采取的方案是这个音频准备多个文件
   --&gt;
  &lt;audio controls&gt;
    &lt;source src=&quot;./media/snow.mp3&quot; type=&quot;audio/mpeg&quot; /&gt;
  &lt;/audio&gt;
&lt;/body&gt;
</code></pre>
<h2 id="多媒体视频标签"><a href="#多媒体视频标签" class="headerlink" title="多媒体视频标签"></a>多媒体视频标签</h2><ol>
<li>video 视频标签<ul>
<li>目前支持三种格式</li>
</ul>
</li>
<li><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1615560894436-db88d851-871b-4758-9b78-9b9892711139.png#align=left&amp;display=inline&amp;height=141&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=281&amp;originWidth=1211&amp;size=137376&amp;status=done&amp;style=none&amp;width=605.5" alt="image.png"></li>
<li>语法格式</li>
</ol>
<pre><code class="html">&lt;video src=&quot;./media/video.mp4&quot; controls=&quot;controls&quot;&gt;&lt;/video&gt;
</code></pre>
<ol>
<li>video 参数<img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1615560905874-4a6cc88d-8941-4f8c-9c89-05ce01e229fb.png#align=left&amp;display=inline&amp;height=301&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=602&amp;originWidth=1193&amp;size=396225&amp;status=done&amp;style=none&amp;width=596.5" alt="image.png"></li>
<li>video 代码演示</li>
</ol>
<pre><code class="html">&lt;body&gt;
  &lt;!-- &lt;video src=&quot;./media/video.mp4&quot; controls=&quot;controls&quot;&gt;&lt;/video&gt; --&gt;
  &lt;!-- 谷歌浏览器禁用了自动播放功能，如果想自动播放，需要添加 muted 属性 --&gt;
  &lt;video controls=&quot;controls&quot; autoplay muted loop poster=&quot;./media/pig.jpg&quot;&gt;
    &lt;source src=&quot;./media/video.mp4&quot; type=&quot;video/mp4&quot; /&gt;
    &lt;source src=&quot;./media/video.ogg&quot; type=&quot;video/ogg&quot; /&gt;
  &lt;/video&gt;
&lt;/body&gt;
</code></pre>
<ol>
<li>多媒体标签总结</li>
</ol>
<ul>
<li>音频标签与视频标签使用基本一致</li>
<li>多媒体标签在不同浏览器下情况不同，存在兼容性问题</li>
<li>谷歌浏览器把音频和视频标签的自动播放都禁止了</li>
<li>谷歌浏览器中视频添加 muted 标签可以自己播放</li>
<li>注意：重点记住使用方法以及自动播放即可，其他属性可以在使用时查找对应的手册</li>
</ul>
<h2 id="新增-input-标签"><a href="#新增-input-标签" class="headerlink" title="新增 input 标签"></a>新增 input 标签</h2><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1615560920848-b6218b7e-57ed-4da9-889e-ff00dd8df1c2.png#align=left&amp;display=inline&amp;height=376&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=752&amp;originWidth=1259&amp;size=176698&amp;status=done&amp;style=none&amp;width=629.5" alt="image.png"></p>
<h2 id="新增表单属性"><a href="#新增表单属性" class="headerlink" title="新增表单属性"></a>新增表单属性</h2><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1615560931257-0c5b2693-9baf-4129-a502-e22ebc14c89e.png#align=left&amp;display=inline&amp;height=251&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=502&amp;originWidth=1217&amp;size=155890&amp;status=done&amp;style=none&amp;width=608.5" alt="image.png"></p>
]]></content:encoded>
      <comments>https://www.wztlink1013.com/blog/vxz6aq7m0szt/#comments</comments>
    </item>
    
    <item>
      <title><![CDATA[HTML总结]]></title>
      <link>https://www.wztlink1013.com/blog/vtwy70ohpnm5/</link>
      <guid>https://www.wztlink1013.com/blog/vtwy70ohpnm5/</guid>
      <pubDate>Sun Jan 24 2021 20:07:40 GMT+0000 (Coordinated Universal Time)</pubDate>
      <description>
      <![CDATA[<h2 id="常用文档"><a href="#常用文档" class="headerlink" title="常用文档"></a>常用文档</h2><blockquote>
<p>W3C : <a href="http://www.w3school.com.cn/" targe]]>
      </description>
      <content:encoded><![CDATA[<h2 id="常用文档"><a href="#常用文档" class="headerlink" title="常用文档"></a>常用文档</h2><blockquote>
<p>W3C : <a href="http://www.w3school.com.cn/" target="_blank" rel="noopener">http://www.w3school.com.cn/</a><br>MDN: <a href="https://developer.mozilla.org/zh-CN/" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/</a><br>菜鸟：<a href="https://www.runoob.com/" target="_blank" rel="noopener">https://www.runoob.com/</a></p>
</blockquote>
<h2 id="排版标签"><a href="#排版标签" class="headerlink" title="排版标签"></a>排版标签</h2><ul>
<li>h：标题</li>
<li>p：段落</li>
<li>hr（单）：横线</li>
<li>br（单）：换行</li>
<li>blockquote：引用</li>
<li>pre：预定义格式<blockquote>
<p>标签可定义预格式化的文本。 被包围在   标签 元素中的文本通常会保留空格和换行符。而文本也会呈现为等宽字体。</p>
</blockquote>
</li>
</ul>
<h2 id="文本格式化标签"><a href="#文本格式化标签" class="headerlink" title="文本格式化标签"></a>文本格式化标签</h2><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611547659083-2c64e035-b906-47c8-84e1-67b8e747e361.png#align=left&amp;display=inline&amp;height=434&amp;margin=%5Bobject%20Object%5D&amp;originHeight=434&amp;originWidth=1054&amp;status=done&amp;style=none&amp;width=1054" alt></p>
<ul>
<li>b 只是加粗 strong 除了可以加粗还有 强调的意思，语义更强烈。</li>
</ul>
<h2 id="img（单）"><a href="#img（单）" class="headerlink" title="img（单）"></a>img（单）</h2><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611547659339-b5fd80fe-ed24-42d9-8d70-ab9fe086449d.png#align=left&amp;display=inline&amp;height=439&amp;margin=%5Bobject%20Object%5D&amp;originHeight=439&amp;originWidth=997&amp;status=done&amp;style=none&amp;width=997" alt><br>border 后面我们会用 css 来做，这里童鞋们就记住这个 border 单词就好了<br><strong>注意: </strong></p>
<ol>
<li>标签可以拥有多个属性，必须写在开始标签中，位于标签名后面。</li>
<li>属性之间不分先后顺序，标签名与属性、属性与属性之间均以空格分开。</li>
<li>任何标签的属性都有默认值，省略该属性则取默认值。</li>
<li>采取 键值对 的格式 key=”value” 的格式</li>
</ol>
<p>比如:<br>此处有练习题<br><strong>重点掌握点：</strong></p>
<ul>
<li>请说出 图像标签那个属性是必须要写的？ img src 图片的路径</li>
<li>请说出 图像标签中 alt 和 title 属性区别？ alt 图片显示不出，文字就显示 title 鼠标经过图片的时候显示文字</li>
</ul>
<h2 id="a"><a href="#a" class="headerlink" title="a**"></a>a**</h2><ul>
<li>href：必须要的属性</li>
<li>target=“_blank”：新窗口打开</li>
</ul>
<h2 id="div-和-span"><a href="#div-和-span" class="headerlink" title="div 和 span"></a>div 和 span</h2><blockquote>
<p>标准流布局</p>
</blockquote>
<ul>
<li>div 标签 用来布局的，但是现在一行只能放一个 div</li>
<li>span 标签 用来布局的，一行上可以放好多个 span</li>
</ul>
<h2 id="base"><a href="#base" class="headerlink" title="base"></a>base</h2><ul>
<li>base 可以设置整体链接的打开状态<blockquote>
<p>最常用的就是<base target="_blank"></p>
</blockquote>
</li>
</ul>
<p>##</p>
<h2 id="lang"><a href="#lang" class="headerlink" title="lang"></a>lang</h2><pre><code class="html">&lt;html lang=&quot;en&quot;&gt;
  指定html 语言种类
&lt;/html&gt;
</code></pre>
<p>最常见的 2 个：</p>
<ol>
<li><code>en</code>定义语言为英语</li>
<li><code>zh-CN</code>定义语言为中文</li>
</ol>
<ul>
<li>指定该 html 标签 内容 所用的语言为中文**</li>
<li>简单来说，可能对于程序来说没有太大的作用，但是它可以告诉浏览器，搜索引擎，一些处理 Html 的程序对页面语言内容来做一些对应的处理或者事情。</li>
</ul>
<h2 id="table"><a href="#table" class="headerlink" title="table"></a>table</h2><h3 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h3><ul>
<li>展示数据</li>
<li>让数据显示整齐规范</li>
<li>表格属性需要注意的</li>
</ul>
<p>平时开发的我们这三个参数 border、cellpadding、cellspacing 为 0，但在 HTML5 里面，后两者属性设置无效，利用 <code>border-collapse: collapse;</code> 来设置，将 th 和 td 设置为 0</p>
<ul>
<li>浏览器会默认包裹 tbody 标签</li>
<li>HTML5 里面用 thead,tbody,tfoot 来标注内容，更加清晰**</li>
</ul>
<h3 id="合并单元格"><a href="#合并单元格" class="headerlink" title="合并单元格"></a>合并单元格</h3><p>合并单元格是我们比较常用的一个操作，但是不会合并的很复杂。</p>
<blockquote>
<p>【1】合并单元格 2 种方式</p>
</blockquote>
<ul>
<li>跨行合并：rowspan=”合并单元格的个数”</li>
<li>跨列合并：colspan=”合并单元格的个数”<blockquote>
<p>【2】合并单元格顺序<br><strong>合并的顺序我们按照 先上 后下 先左 后右 的顺序 </strong></p>
</blockquote>
</li>
</ul>
<p>跟我们以前学习汉字的书写顺序完全一致。</p>
<blockquote>
<p>【3】合并单元格三步曲</p>
</blockquote>
<ol>
<li>先确定是跨行还是跨列合并</li>
<li>根据 先上 后下 先左 后右的原则找到目标单元格 然后写上 合并方式 还有 要合并的单元格数量 比如 ：</li>
<li>删除多余的单元格 单元格</li>
</ol>
<h2 id="ul、ol、dl"><a href="#ul、ol、dl" class="headerlink" title="ul、ol、dl"></a>ul、ol、dl</h2><h3 id="去掉列表默认的样式"><a href="#去掉列表默认的样式" class="headerlink" title="去掉列表默认的样式"></a>去掉列表默认的样式</h3><p>无序和有序列表前面默认的列表样式，在不同浏览器显示效果不一样，而且也比较难看，所以，我们一般上来就直接去掉这些列表样式就行了。 代码如下</p>
<pre><code class="css">li {
  list-style: none;
}
</code></pre>
<h2 id="form"><a href="#form" class="headerlink" title="form"></a>form</h2><ul>
<li>表单目的是为了收集用户信息。</li>
</ul>
<p>在我们网页中， 我们也需要跟用户进行交互，收集用户资料，此时也需要表单。</p>
<blockquote>
<p>在 HTML 中，一个完整的表单通常由表单控件（也称为表单元素）、提示信息和表单域 3 个部分构成。</p>
</blockquote>
<ul>
<li><strong>表单控件： </strong>包含了具体的表单功能项，如单行文本输入框、密码输入框、复选框、提交按钮、重置按钮等。</li>
<li><strong>提示信息：</strong>一个表单中通常还需要包含一些说明性的文字，提示用户进行填写和操作。</li>
<li><strong>表单域：</strong>他相当于一个容器，用来容纳所有的表单控件和提示信息，可以通过他定义处理表单数据所用程序的 url 地址，以及数据提交到服务器的方法。如果不定义表单域，表单中的数据就无法传送到后台服务器。</li>
</ul>
<h3 id="input"><a href="#input" class="headerlink" title="input"></a>input</h3><ul>
<li>常用属性：</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611547661035-9721cb68-5232-4cbf-8bf5-01b447ed3f3f.png#align=left&amp;display=inline&amp;height=456&amp;margin=%5Bobject%20Object%5D&amp;originHeight=456&amp;originWidth=950&amp;status=done&amp;style=none&amp;width=950" alt></p>
<ul>
<li><p>value 默认的文本值。 有些表单想刚打开页面就默认显示几个文字，就可以通过这个 value 来设置。</p>
<blockquote>
<p>name 属性后面的值，是我们自己定义的。</p>
</blockquote>
</li>
<li><p>name 表单的名字， 这样，后台可以通过这个 name 属性找到这个表单。 页面中的表单很多，name 主要作用就是用于区别不同的表单。</p>
</li>
<li><p>radio 如果是一组，我们必须给他们命名相同的名字 name 这样就可以在同一个组里面多个选其中的一个</p>
</li>
<li><p>name 属性，我们现在用的较少， 但是，当我们学 ajax 和后台的时候，是必须的。</p>
<blockquote>
<p>checked 属性</p>
</blockquote>
</li>
<li><p>默认选中状态。 较常见于 单选按钮和复选按钮。</p>
</li>
</ul>
<h3 id="label"><a href="#label" class="headerlink" title="label"></a>label</h3><ul>
<li>用于绑定一个表单元素, 当点击 label 标签的时候, 被绑定的表单元素就会获得输入焦点。<blockquote>
<p>两种绑定方式</p>
</blockquote>
</li>
</ul>
<ol>
<li>第一种用法就是用 label 直接包括 input 表单。</li>
</ol>
<pre><code class="html">&lt;label&gt;
  用户名： &lt;input type=&quot;radio&quot; name=&quot;usename&quot; value=&quot;请输入用户名&quot; /&gt;
&lt;/label&gt;
</code></pre>
<p>适合单个表单选择</p>
<ol start="2">
<li>第二种用法 for 属性规定 label 与哪个表单元素绑定。</li>
</ol>
<pre><code class="html">&lt;label for=&quot;sex&quot;&gt;男&lt;/label&gt; &lt;input type=&quot;radio&quot; name=&quot;sex&quot; id=&quot;sex&quot; /&gt;
</code></pre>
<h3 id="textarea"><a href="#textarea" class="headerlink" title="textarea"></a>textarea</h3><h3 id="select"><a href="#select" class="headerlink" title="select**"></a>select**</h3><ul>
<li><select> 中至少包含一对 option</select></li>
<li>在 option 中定义 selected =” selected “时，当前项即为默认选中项。</li>
<li>但是我们实际开发会用的比较少</li>
</ul>
<h3 id="form-表单域"><a href="#form-表单域" class="headerlink" title="form 表单域"></a>form 表单域</h3><ul>
<li><p>收集的用户信息怎么传递给服务器：通过 form 表单域</p>
</li>
<li><p>目的：在 HTML 中，form 标签被用于定义表单域，以实现用户信息的收集和传递，form 中的所有内容都会被提交给服务器。</p>
</li>
</ul>
<pre><code class="html">&lt;form action=&quot;url地址&quot; method=&quot;提交方式&quot; name=&quot;表单名称&quot;&gt;各种表单控件&lt;/form&gt;
</code></pre>
<ul>
<li>每一个 form 至少含有一个 submit 类型的 input 标签（点击 submit 提交到 form 中的 action 地址当中），然后接收的 html 页面（服务端）利用类似以下的代码进行处理 url 得到前者页面所传过来的参数，以便在服务端进行利用</li>
</ul>
<pre><code class="javascript">&lt;script&gt;
  console.log(location.search); // ?uname=andy // 1.先去掉？
  substr(&#39;起始的位置&#39;，截取几个字符); var params = location.search.substr(1); //
  uname=andy console.log(params); // 2. 利用=把字符串分割为数组 split(&#39;=&#39;); var
  arr = params.split(&#39;=&#39;); console.log(arr); // [&quot;uname&quot;, &quot;ANDY&quot;] var div =
  document.querySelector(&#39;div&#39;); // 3.把数据写入div中 div.innerHTML = arr[1] +
  &#39;欢迎您&#39;;
&lt;/script&gt;
</code></pre>
<ul>
<li><p><strong>常用属性</strong><br>| 属性 | 属性值 | 作用 |<br>| — | :— | — |<br>| action | url 地址 | 用于指定接收并处理表单数据的服务器程序的 url 地址。 |<br>| method | get/post | 用于设置表单数据的提交方式，其取值为 get 或 post。 |<br>| name | 名称 | 用于指定表单的名称，以区分同一个页面中的多个表单。 |</p>
</li>
<li><p>每个表单都应该有自己表单域。我们现在做页面，不写看不到效果，但是 如果后面学 ajax 后台交互的时候，必须需要 form 表单域。</p>
</li>
</ul>
]]></content:encoded>
      <comments>https://www.wztlink1013.com/blog/vtwy70ohpnm5/#comments</comments>
    </item>
    
    <item>
      <title><![CDATA[P674. 最长连续递增序列]]></title>
      <link>https://www.wztlink1013.com/blog/guaorh/</link>
      <guid>https://www.wztlink1013.com/blog/guaorh/</guid>
      <pubDate>Sat Jan 23 2021 19:25:02 GMT+0000 (Coordinated Universal Time)</pubDate>
      <description>
      <![CDATA[<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><pre><code class="java">package com.wztlink1013.problems.leetcode]]>
      </description>
      <content:encoded><![CDATA[<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><pre><code class="java">package com.wztlink1013.problems.leetcode.editor.cn;

// P674.最长连续递增序列
// P674.longest-continuous-increasing-subsequence
//给定一个未经排序的整数数组，找到最长且 连续递增的子序列，并返回该序列的长度。
//
// 连续递增的子序列 可以由两个下标 l 和 r（l &lt; r）确定，如果对于每个 l &lt;= i &lt; r，都有 nums[i] &lt; nums[i + 1] ，那
//么子序列 [nums[l], nums[l + 1], ..., nums[r - 1], nums[r]] 就是连续递增子序列。
//
//
//
// 示例 1：
//
//
//输入：nums = [1,3,5,4,7]
//输出：3
//解释：最长连续递增序列是 [1,3,5], 长度为3。
//尽管 [1,3,5,7] 也是升序的子序列, 但它不是连续的，因为 5 和 7 在原数组里被 4 隔开。
//
//
// 示例 2：
//
//
//输入：nums = [2,2,2,2,2]
//输出：1
//解释：最长连续递增序列是 [2], 长度为1。
//
//
//
//
// 提示：
//
//
// 0 &lt;= nums.length &lt;= 104
// -109 &lt;= nums[i] &lt;= 109
//
// Related Topics 数组
// 👍 147 👎 0

public class P674LongestContinuousIncreasingSubsequence{
    public static void main(String[] args) {
        Solution solution = new P674LongestContinuousIncreasingSubsequence().new Solution();
        int [] nums = {1,3,5,7};
        int result = solution.findLengthOfLCIS(nums);
        System.out.println(result);
    }

//leetcode submit region begin(Prohibit modification and deletion)
class Solution {
    public int findLengthOfLCIS(int[] nums) {
        if (nums.length == 0) { return 0; }
        int result = 1;
        int count = 1;
        for (int i=0; i&lt;nums.length-1; i++) {
            if (nums[i] &lt; nums[i+1] ) {
                count++;
                if (result &lt; count) {result = count;}
            } else {
                if (result &lt; count) {result = count;}
                count = 1;
            }
        }
        return result;
    }
}
//leetcode submit region end(Prohibit modification and deletion)

}
</code></pre>
<h2 id="细节注意"><a href="#细节注意" class="headerlink" title="细节注意"></a>细节注意</h2><ul>
<li>56 行 count++</li>
<li>将 57 和 59 行代码删去，改为如下表达式赋值</li>
</ul>
<pre><code class="java">result = count &gt; result ? count : result;
</code></pre>
]]></content:encoded>
      <comments>https://www.wztlink1013.com/blog/guaorh/#comments</comments>
    </item>
    
    <item>
      <title><![CDATA[软件工程知识小结]]></title>
      <link>https://www.wztlink1013.com/blog/sc6tzq/</link>
      <guid>https://www.wztlink1013.com/blog/sc6tzq/</guid>
      <pubDate>Thu Dec 24 2020 09:55:00 GMT+0000 (Coordinated Universal Time)</pubDate>
      <description>
      <![CDATA[软件工程知识小结]]>
      
      </description>
      <content:encoded><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>软件工程生命周期</p>
</blockquote>
<ol>
<li>问题定义</li>
<li>可行性研究</li>
<li>需求分析</li>
<li>总体设计</li>
<li>详细设计</li>
<li>编码和单元测试</li>
<li>综合测试</li>
<li>软件维护</li>
</ol>
<h2 id="可行性研究"><a href="#可行性研究" class="headerlink" title="可行性研究"></a>可行性研究</h2><blockquote>
<p>在了解问题定义之后，将其模型抽离出来，然后对其进行可行性分析，探索若干种解法，对每种解法仔细研究其可行性，从下面几种方面来考虑</p>
</blockquote>
<ol>
<li>技术可行性：能否用现又技术实现？</li>
<li>经济可行性：软件带来的经济效益能否大于软件的开发成本？</li>
<li>操作可行性：在用户组织之间是否具有操作可行性？</li>
</ol>
<p>必要时还有从法律和社会效益来研究其可行性。</p>
<blockquote>
<p>系统流程图<br>数据流图</p>
</blockquote>
<blockquote>
<p>成本/效益分析</p>
</blockquote>
<p>成本估计的几种方法</p>
<ul>
<li>代码行技术：根据每行代码的平均成本乘以行数就是大概的成本</li>
<li>任务分解技术：将整个声明周期划分不同阶段，估计每个不同阶段所花费的成本，一般都是各阶段的人数诚意平均工资再加这般</li>
<li>自动估计成本：根据程序来估计，一般要用到大量数据，才能保证这个估计有效（大数据时代应该很吃香，可以利用所搜集的大量数据来进行建模）</li>
</ul>
<p>成本/效益分析的方法</p>
<ul>
<li>货币的时间价值：这里面有年利率的概念，就是过 n 年之后，你手中的钱在 n 年之后会提升</li>
</ul>
<p>F=P（1+n）^n （P 元钱在 n 年后的价值）</p>
<ul>
<li>投资回收期：你所赚的钱等于你所投资的资金所花费的时间越短越好</li>
<li>纯收入：整个生命周期内，赚的钱减去你投资的钱</li>
</ul>
<h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><blockquote>
<p>与用户沟通获取需求的方法</p>
</blockquote>
<ul>
<li>访谈</li>
<li>面向数据流自顶向下求精</li>
<li>简易的应用规格说明技术</li>
<li>快速建立软件模型</li>
</ul>
<blockquote>
<p>根据结构化分析准则，需求分析过程应该建立三种模型，它们分别是？以及他们所用到的工具？</p>
</blockquote>
<ul>
<li>数据模型——E-R 图：就是数据库里面学到的实体-联系图</li>
<li>功能模型——数据流图：描述数据在系统中的转换的逻辑过程</li>
<li>行为模型——状态转换图：作为外部事件结果的系统行为</li>
</ul>
<blockquote>
<p>其他的工具还有</p>
</blockquote>
<ul>
<li>层次方框图（树形结构）</li>
<li>Warnier 图{大括号包裹）</li>
<li>IPO 图（方框-箭头；表格形式）</li>
</ul>
<h2 id="形式化说明技术"><a href="#形式化说明技术" class="headerlink" title="形式化说明技术"></a>形式化说明技术</h2><blockquote>
<p>软件工程所使用的方法可划分为下面三种</p>
</blockquote>
<ul>
<li>非形式化方法：用自然语言描述就是典型的非形式化方法</li>
<li>半形式化方法：利用 E-R 图描述就是半形式化方法</li>
<li>形式化方法：用到数学的技术，也就是说，如果一种方法用到坚实的数学基础，那么他就是形式化方法</li>
</ul>
<h2 id="总体设计"><a href="#总体设计" class="headerlink" title="总体设计"></a>总体设计</h2><blockquote>
<p>总体设计又称之为概要设计、初步设计</p>
</blockquote>
<blockquote>
<p>由哪两阶段组成呢？</p>
</blockquote>
<ul>
<li>系统设计阶段：确定系统的具体实现方案</li>
<li>结构设计阶段：确定软件结构</li>
</ul>
<blockquote>
<p>设计原理</p>
</blockquote>
<p><strong>模块</strong>是由边界元素限定的相邻程序元素（数据说明，可执行的语句）的序列，而且有一个总体标识符代表它</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1608815946283-167d2edb-f25b-45de-ade4-6041bddf45c2.png#align=left&amp;display=inline&amp;height=258&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=516&amp;originWidth=694&amp;size=141087&amp;status=done&amp;style=shadow&amp;width=347" alt="image.png"></p>
<p>模块之间的<strong>独立程度</strong>有两个标准来度量，分别是：</p>
<p>耦合：度量<strong>模块间</strong>的互相依赖程度</p>
<p>内聚：度量<strong>模块内部元素间</strong>的结合程度</p>
<p><strong>尽量使用数据耦合，少用控制耦合和特征耦合，限制公共环境耦合的范围，完全不用内容耦合</strong><br>**<br>7 种内聚优劣评分：功能内聚（10 分）偶然内聚（0 分）</p>
<blockquote>
<p>描绘软件结构的图形工具</p>
</blockquote>
<ul>
<li>层次图（树状）和 HIPO 图（带编号的层次图）</li>
<li>结构图</li>
</ul>
<blockquote>
<p>面向数据流的设计方法</p>
</blockquote>
<p>概念：面向数据流的设计方法就是把信息流映射成软件结构，同时信息流的结构决定了映射的方法</p>
<ul>
<li>变换流</li>
<li>事务流</li>
<li>设计过程</li>
</ul>
<h2 id="详细设计"><a href="#详细设计" class="headerlink" title="详细设计"></a>详细设计</h2><blockquote>
<p>结构程序设计</p>
</blockquote>
<p>只用 3 种控制结构就能实现任何单入口单出口的程序，这三种结构分别是顺序结构、选择结构、循环结构</p>
<blockquote>
<p>人机界面设计的设计问题有：</p>
</blockquote>
<ul>
<li>系统响应时间</li>
<li>用户帮助实施</li>
<li>出错信息处理</li>
<li>命令交互</li>
</ul>
<blockquote>
<p>人机界面设计的设计指南：</p>
</blockquote>
<ul>
<li>一般交互指南</li>
<li>信息显示指南</li>
<li>数据输入指南</li>
</ul>
<blockquote>
<p>过程设计的工具【重要】</p>
</blockquote>
<ol>
<li>程序流程图</li>
<li>盒图（N-S 图）</li>
<li>PAD 图</li>
<li>判定表</li>
<li>判定树</li>
<li>过程设计语言</li>
</ol>
<blockquote>
<p>面向数据结构的设计方法</p>
</blockquote>
<p><strong>两个最著名的方法为：Jackson 方法和 Warnier 方法</strong><br>**</p>
<blockquote>
<p>Jackson 方法</p>
</blockquote>
<p>只有顺序、选择、重复三种结构</p>
<p>要会用伪代码表示</p>
<blockquote>
<p>程序复杂程度的定量度量有 McCabe 方法和 Halstead 方法，只介绍前者</p>
</blockquote>
<ol>
<li>流图（给出伪代码画流图）</li>
<li>计算环形复杂度的方法</li>
</ol>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h2 id="维护"><a href="#维护" class="headerlink" title="维护"></a>维护</h2>]]></content:encoded>
      <comments>https://www.wztlink1013.com/blog/sc6tzq/#comments</comments>
    </item>
    
    <item>
      <title><![CDATA[计算机组成原理知识点回顾]]></title>
      <link>https://www.wztlink1013.com/blog/pnf49g/</link>
      <guid>https://www.wztlink1013.com/blog/pnf49g/</guid>
      <pubDate>Wed Dec 23 2020 09:21:00 GMT+0000 (Coordinated Universal Time)</pubDate>
      <description>
      <![CDATA[计算机组成原理知识点回顾]]>
      
      </description>
      <content:encoded><![CDATA[<blockquote>
<p>利用一些基本的问题简单回顾一下这学期学的计组的基本知识点。</p>
</blockquote>
<h2 id="概论"><a href="#概论" class="headerlink" title="概论"></a>概论</h2><blockquote>
<p>电子数字计算机和电子模拟计算机的区别是什么？</p>
</blockquote>
<p>电子数字计算机处理的信息是<strong>离散</strong>的，运算过程是离散的<br>电子模拟计算机处理的信号时<strong>连续</strong>的，运算过程是连续的</p>
<blockquote>
<p>冯诺依曼计算机的特点是什么？其中最主要的一点是什么？</p>
</blockquote>
<ol>
<li>计算机由运算器、控制器、存储器、输入系统、输出系统<strong>五大部件</strong>组成（注意中央处理器是运算器和控制器的合称）</li>
<li>计算机内部由<strong>二进制编码</strong>指令和数据</li>
<li>将编好的数据和程序<strong>先放</strong>入存储器中，然后<strong>再启动</strong>计算机工作</li>
</ol>
<p>其中最主要的一点是第三点最主要！</p>
<h2 id="数据的机器层次表示"><a href="#数据的机器层次表示" class="headerlink" title="数据的机器层次表示"></a>数据的机器层次表示</h2><blockquote>
<p>机器数的原码+反码+补码表示</p>
</blockquote>
<p>定点小数表示：阶码：小数点位数；尾数：在小数那里编码即可</p>
<p>真值就是加正负所表现出来的</p>
<blockquote>
<p>给定计算机字长位数，知道各种情况下表示数值的范围</p>
</blockquote>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1608863188017-8f6c8d66-710e-4880-8559-af59c6e37609.png#align=left&amp;display=inline&amp;height=356&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=712&amp;originWidth=1315&amp;size=336629&amp;status=done&amp;style=shadow&amp;width=657.5" alt="image.png"></p>
<h2 id="数值的机器运算"><a href="#数值的机器运算" class="headerlink" title="数值的机器运算"></a>数值的机器运算</h2><blockquote>
<p>定点加减运算+判断结果是否溢出</p>
</blockquote>
<ol>
<li>先写出两个数的补码（减法运算转换为加法运算即可）</li>
<li>然后进行二进制加法运算（遵循 0+0=0，1+0=1，0+1=1，1+1=10 向高位进位）</li>
<li>判断是否溢出【00：结果为正无溢出；01：正溢；10：负溢；11 结果为负无溢出】</li>
<li>将[X+Y]补转换为[X+Y]真值<blockquote>
<p>定点乘法运算：原码一位乘法运算+补码一位乘法运算</p>
</blockquote>
</li>
</ol>
<p>原码一位乘法运算：</p>
<ol>
<li>先写出 X 和 Y 的绝对值|X|和|Y|</li>
<li>让 00.0……和|X|相加同时判断|Y|的最后一位（如果为 1 加|X|如果是 0 加 0）</li>
<li>加完之后右移一位，再判断，加了再判断，啥时候那个分隔符分没了，就好了……………</li>
<li>最后判断真值符号</li>
</ol>
<p>我写的个啥………………逃</p>
<p>补码一位乘法运算：</p>
<ol>
<li>写出[X]补[-X]补[Y]补</li>
<li>在[Y]补码尾巴后面加一个 0，判断最后两位，（00 加 0；10 加[-X]补；01 加[X]补；11 加 0）</li>
<li>让 00.000……加上上面判断的加上某某</li>
<li>又一直这样下去下去……</li>
<li>把补码换成原码即可……</li>
</ol>
<p>…………逃 🤣</p>
<h2 id="指令系统"><a href="#指令系统" class="headerlink" title="指令系统"></a>指令系统</h2><blockquote>
<p>什么叫主程序和子程序？调用子程序还可以采用哪几种方法保存返回地址？画出图说明调用子程序的过程。</p>
</blockquote>
<p>主程序：<strong>通常</strong>的程序<br><strong><br>子程序：可以被反复调用、</strong>公用<strong>的程序，只要知道其</strong>入口地址**，就可以调用之，其就是我们编程常写的函数</p>
<p>保存返回地址的方法：</p>
<ul>
<li>子程序的第一个<strong>子单元</strong>存放返回地址，然后从第二个字单元开始执行子程序</li>
<li><strong>寄存器</strong>存放</li>
<li><strong>堆栈</strong>保存</li>
</ul>
<p>以堆栈保存返回地址的方法来说明调用子程序的过程：<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1608774330112-3e8bf3df-1091-4476-aa72-e9757e36a3e6.png#align=left&amp;display=inline&amp;height=77&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=154&amp;originWidth=242&amp;size=22896&amp;status=done&amp;style=shadow&amp;width=121" alt="image.png"></p>
<blockquote>
<p>如果某计算机调用子程序保存返回地址是上个问题的第一种方式，有这么几个问题：</p>
<ol>
<li>为这种方法设计一条从子程序转到主程序的返回指令</li>
<li>怎么在主程序和子程序之间进行传参</li>
<li>可否用于子程序嵌套</li>
<li>可否用于子程序的递归</li>
<li>如果将该种方式改为第三种方式（堆栈方式），可否完成 4</li>
</ol>
</blockquote>
<ol>
<li>使用间接寻址方式</li>
</ol>
<table>
<thead>
<tr>
<th>JMP</th>
<th>@</th>
<th>子程序首地址</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<ol start="2">
<li>可以利用寄存器或主存单元进行主、子程序间的参数传递</li>
<li>可以。返回的地址都放在子程序的第一个单元</li>
<li>不可以。会破坏其内部结构</li>
<li>可以。因为堆栈具有后进先出功能</li>
</ol>
<h2 id="存储系统和结构"><a href="#存储系统和结构" class="headerlink" title="存储系统和结构"></a>存储系统和结构</h2><blockquote>
<p>如何区别存储器和寄存器？两者是一回事说法对吗？</p>
</blockquote>
<p>两者不是一回事。</p>
<p>存储器是在<strong>CPU</strong>外边，用来存放数据和程序的，访问存储器的<strong>速度</strong>较慢；</p>
<p>寄存器数据 CPU 的一部分，访问寄存器的速度很快。<br>**</p>
<blockquote>
<p>存储器的主要功能是什么？为什么把存储系统分成若干个不同层次？主要有那些层次？</p>
</blockquote>
<p>存储器的主要功能：存储数据和程序</p>
<p>存储系统是有几个<strong>容量、速度、价格</strong>不同的存储器用硬件、软件、软硬件相结合起来的系统。分成若干个不同层次是因为考虑到不同存储器的价格因素、存储速度、存储容量三个因素。</p>
<ol>
<li>高速缓存</li>
<li>主存</li>
<li>辅存</li>
</ol>
<p>其中 12 又称之为 Cache-主存存储层次，23 又称之为主存-辅存存储层次。</p>
<blockquote>
<p>动态 RAM 为什么要刷新？一般有几种刷新方式？各有什么优缺点？</p>
</blockquote>
<p><strong>为了维持 DRAM 的记忆单元的存储信息</strong></p>
<ul>
<li><strong>集中式</strong>刷新</li>
</ul>
<p>优点：<strong>读写操作</strong>不受刷新工作的影响，<strong>存取速度</strong>高</p>
<p>缺点：存储容量越大，死区越长</p>
<ul>
<li><strong>分散式</strong>刷新</li>
</ul>
<p>优点：没有死区</p>
<p>缺点：加长了系统的<strong>存取周期</strong>，降低了整机的速度，并且刷新过于频繁，没有充分利用允许的最大刷新间隔</p>
<ul>
<li><strong>异步式</strong>刷新</li>
</ul>
<p>异步式虽然有死区，但是比几种方式的<strong>死区小</strong>得多，而且<strong>减少了刷新次数</strong>，是比较实用的一种刷新方式。</p>
<h2 id="中央处理器"><a href="#中央处理器" class="headerlink" title="中央处理器"></a>中央处理器</h2><hr>
<blockquote>
<p>控制器有哪几种控制方式？各有何特点？</p>
</blockquote>
<ul>
<li><strong>同步</strong>控制方式</li>
</ul>
<p>该控制方式各项操作都由统一的<strong>时序信号</strong>完成，并且在每个及其周期中产生统一的<strong>节拍电位和工作脉冲</strong>。这种方式设计简单，但是对于许多<strong>单指令</strong>来说，有太多的<strong>空闲时间</strong>，造成时间浪费，影响指令执行速度。</p>
<ul>
<li><strong>异步</strong>控制方式</li>
</ul>
<p>该控制方式的各项操作都<strong>不由统一的时序信号</strong>完成，而是由指令本身或部件的具体情况决定，因此这种控制方式的效率高，时间能够合理利用，但是该控制方式也比较复杂。</p>
<ul>
<li><strong>联合</strong>控制方式</li>
</ul>
<p>是由上面的同步控制方式和异步控制方式相结合的方式。</p>
<hr>
<blockquote>
<p>什么是三级时序系统？</p>
</blockquote>
<p>三级时序系统是指<strong>机器周期</strong>、<strong>节拍</strong>、<strong>工作脉冲</strong></p>
<p>具体所属关系是：每个指令周期划分若干个机器周期，每个机器周期划分若干个节拍，每个节拍划分 1 个或几个工作脉冲。</p>
<hr>
<blockquote>
<p>控制器有哪些基本功能？可分为哪几类？分类的依据是什么？</p>
</blockquote>
<p>基本功能：</p>
<ul>
<li>从主存中<strong>取出一条指令</strong>，并指出下一跳指令在主存中的位置</li>
<li>对指令进行<strong>译码或是测试</strong>，产生相应的操作控制信号，以便启动规定的工作</li>
<li>指挥并控制<strong>CPU</strong>，主存和输入输出设备之间的<strong>数据流动</strong></li>
</ul>
<p>分类：</p>
<ul>
<li><strong>组合逻辑</strong>型</li>
<li><strong>存储逻辑</strong>型</li>
<li>组合逻辑和存储逻辑<strong>结合</strong>型</li>
</ul>
<p>分类的依据：<br>在于控制器的核心——<strong>微操作信号发生器的实现方法不同</strong>。</p>
<hr>
<blockquote>
<p>中央处理器有哪些功能？它是由那些基本部件构成的？</p>
</blockquote>
<p>构成：</p>
<ul>
<li>控制器</li>
<li>运算器</li>
</ul>
<p>功能：<br>对数据流和指令流在时间上和空间上进行正确的控制。当然，对于冯诺依曼结构的计算机而言，数据流是基于指令流的操作而驱动的。</p>
<hr>
<blockquote>
<p>中央处理器有哪几个主要寄存器？说说他们的结构和功能？</p>
</blockquote>
<p>寄存器的功能就是用来存放程序运行过程中的中间结果、最终结果以及控制、状态信息的。</p>
<ul>
<li>通用寄存器</li>
</ul>
<p>用来存放原始数据和运算结果，有的还可以作为变址寄存器、计数器、地址指针等</p>
<ul>
<li>专用寄存器</li>
</ul>
<p>是用来完成某些特定功能的寄存器：程序计数器（PC）、指令寄存器（IR）、存储器地址寄存器（MAR）、存储器数据寄存器（MDR）、程序状态字寄存器（PSWR）等</p>
<blockquote>
<p>以单指令为例，简要说明下列部件在计算机的取值周期和执行周期的作用。</p>
</blockquote>
<ul>
<li>程序计数器（PC）：存放指令地址</li>
<li>指令寄存器（IR）：存放当前指令</li>
<li>存储器地址寄存器（MAR）：进行算术逻辑运算</li>
<li>存储器数据寄存器（MDR）：存放写入或读出的数据/指令</li>
<li>程序状态字寄存器（PSWR）：存放写入或读出的数据/指令的地址</li>
</ul>
<hr>
<blockquote>
<p>什么是指令周期？什么是 CPU 周期？他们之间有什么关系？</p>
</blockquote>
<p>指令周期：指<strong>取指令</strong>、<strong>分析指令</strong>到<strong>执行指令</strong>所花费的所有时间</p>
<p>CPU 周期：也叫<strong>机器周期</strong>，是指完成一个基本操作所花费的时间<br>一个指令周期划分为多个 CPU 周期</p>
<hr>
<h2 id="【总线-外部设备】nothing"><a href="#【总线-外部设备】nothing" class="headerlink" title="【总线+外部设备】nothing"></a>【总线+外部设备】nothing</h2><h2 id="输入输出系统"><a href="#输入输出系统" class="headerlink" title="输入输出系统"></a>输入输出系统</h2><hr>
<blockquote>
<p>什么是计机的输入输出系统？输入输出设备有哪些编址方式？有什么特点？</p>
</blockquote>
<p>输入输出系统：包括输入输出<strong>接口</strong>和输入输出信息<strong>传送</strong>控制方式，是计算机系统中最具有<strong>多样性</strong>和<strong>复杂性</strong>的部分。</p>
<p>编址方式：</p>
<ul>
<li><strong>独立编址</strong></li>
</ul>
<p>优点：指令易于区分，译码简单，主存空间不会减少</p>
<p>缺点：增加了控制线 I/ORead 和 I/OWrite 信号</p>
<ul>
<li><strong>统一编址</strong></li>
</ul>
<p>优点：总线结构简单，全部访存类指令都可用于控制外设，可直接对外设寄存器进行各种运算</p>
<p>缺点：占用主存一部分地址，缩小了可用的主存空间</p>
<hr>
<blockquote>
<p>什么是 I/O 接口？I/O 接口有哪些特点和功能？接口有哪些类型？</p>
</blockquote>
<p>主机和外设之间的交接界面</p>
<p>特点：<br>实现信息交换</p>
<p>功能：</p>
<ul>
<li>实现主机和外设的通信联络控制</li>
<li>进行地址译码和设备选择</li>
<li>实现数据缓冲</li>
<li>完成数据格式的变换</li>
<li>传递控制命令和状态信息</li>
</ul>
<p>类型：</p>
<ul>
<li>串行接口</li>
<li>并行接口</li>
</ul>
<hr>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1608728980150-18e3d2ee-cc80-4187-b38c-14c78554e979.png#align=left&amp;display=inline&amp;height=152&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=198&amp;originWidth=766&amp;size=190453&amp;status=done&amp;style=none&amp;width=589" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1608729028676-c983dd94-3689-431d-bf54-76bbb5b01f75.png#align=left&amp;display=inline&amp;height=80&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=160&amp;originWidth=788&amp;size=111323&amp;status=done&amp;style=none&amp;width=394" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1608729049887-aee5cd74-e49d-44d1-88b2-bcdc511ff3c3.png#align=left&amp;display=inline&amp;height=107&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=214&amp;originWidth=968&amp;size=213320&amp;status=done&amp;style=none&amp;width=484" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1608729065956-47dc5b50-caaa-44a1-a54e-8e3f5ae2192a.png#align=left&amp;display=inline&amp;height=172&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=343&amp;originWidth=687&amp;size=119088&amp;status=done&amp;style=none&amp;width=343.5" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1608729081886-f27d6175-e541-4379-b158-0093a23b693d.png#align=left&amp;display=inline&amp;height=139&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=277&amp;originWidth=922&amp;size=156708&amp;status=done&amp;style=none&amp;width=461" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1608729097801-61fd270b-1608-48ab-b1fa-a951febba5d6.png#align=left&amp;display=inline&amp;height=87&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=173&amp;originWidth=907&amp;size=129678&amp;status=done&amp;style=none&amp;width=453.5" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1608729108461-95f5d6e5-efd6-4acf-a2c7-fb72f6052d25.png#align=left&amp;display=inline&amp;height=71&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=141&amp;originWidth=897&amp;size=100962&amp;status=done&amp;style=none&amp;width=448.5" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1608729131667-e6955db4-4b2c-4efb-ad1f-3acf8ccc5e48.png#align=left&amp;display=inline&amp;height=315&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=630&amp;originWidth=974&amp;size=493234&amp;status=done&amp;style=none&amp;width=487" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1608729144873-1a207e20-98d9-4e44-b40e-c1a81a54b667.png#align=left&amp;display=inline&amp;height=195&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=390&amp;originWidth=968&amp;size=379559&amp;status=done&amp;style=none&amp;width=484" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1608729157489-b3899992-00d9-405b-8f02-9619f08d9960.png#align=left&amp;display=inline&amp;height=193&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=386&amp;originWidth=938&amp;size=349548&amp;status=done&amp;style=none&amp;width=469" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1608729176250-7499ab5f-2a40-4514-92f3-afc46c739936.png#align=left&amp;display=inline&amp;height=275&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=549&amp;originWidth=1005&amp;size=475058&amp;status=done&amp;style=none&amp;width=502.5" alt="image.png"></p>
]]></content:encoded>
      <comments>https://www.wztlink1013.com/blog/pnf49g/#comments</comments>
    </item>
    
    <item>
      <title><![CDATA[VuePress初体验]]></title>
      <link>https://www.wztlink1013.com/blog/czl3oc/</link>
      <guid>https://www.wztlink1013.com/blog/czl3oc/</guid>
      <pubDate>Mon Dec 21 2020 09:21:00 GMT+0000 (Coordinated Universal Time)</pubDate>
      <description>
      <![CDATA[VuePress初体验]]>
      
      </description>
      <content:encoded><![CDATA[<h2 id="安装-Yarn"><a href="#安装-Yarn" class="headerlink" title="安装 Yarn"></a>安装 Yarn</h2><blockquote>
<p>Yarn 是为了弥补 npm 的一些缺陷而生的</p>
</blockquote>
<p>具体参考：<a href="https://zhuanlan.zhihu.com/p/27449990" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/27449990</a></p>
<h3 id="引导式安装"><a href="#引导式安装" class="headerlink" title="引导式安装"></a>引导式安装</h3><p><a href="https://classic.yarnpkg.com/zh-Hans/docs/install#windows-stable" target="_blank" rel="noopener">下载地址</a><br>使用 Windows 版的下载安装即可<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1608540352757-ed3ef592-f042-4262-9378-42aa9d053fcd.png#align=left&amp;display=inline&amp;height=35&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=69&amp;originWidth=433&amp;size=3803&amp;status=done&amp;style=none&amp;width=216.5" alt="image.png"></p>
<h3 id="bash-安装"><a href="#bash-安装" class="headerlink" title="bash 安装"></a>bash 安装</h3><p>在 bash 里面不能显示，在 bash 里面下载<br><code>npm install -g yarn</code> 即可</p>
<h2 id="将-VuePress-安装为本地依赖"><a href="#将-VuePress-安装为本地依赖" class="headerlink" title="将 VuePress 安装为本地依赖"></a>将 VuePress 安装为本地依赖</h2><h3 id="yarn-init"><a href="#yarn-init" class="headerlink" title="yarn init"></a>yarn init</h3><p>yarn init 出错</p>
<pre><code class="bash">error An unexpected error occurred: &quot;Can&#39;t answer a question unless a user TTY&quot;. info If you think t
</code></pre>
<p><strong>使用 cmd 或者 power shell 不要使用 bash</strong><br>**</p>
<h3 id="yarn-add-D-vuepress"><a href="#yarn-add-D-vuepress" class="headerlink" title="yarn add -D vuepress"></a>yarn add -D vuepress</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1608541125538-3124ff43-0574-4bfd-a290-908621b54644.png#align=left&amp;display=inline&amp;height=272&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=543&amp;originWidth=1920&amp;size=147908&amp;status=done&amp;style=none&amp;width=960" alt="image.png"></p>
<h3 id="创建一篇文章"><a href="#创建一篇文章" class="headerlink" title="创建一篇文章"></a>创建一篇文章</h3><p>在 bash 创建，在 powershell 里面创建会报错</p>
<pre><code class="bash">mkdir docs &amp;&amp; echo &#39;# Hello VuePress&#39; &gt; docs/README.md
</code></pre>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1608541380531-3ad1565f-0eef-4dac-bebf-64d1a131d7f3.png#align=left&amp;display=inline&amp;height=105&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=210&amp;originWidth=1160&amp;size=36343&amp;status=done&amp;style=none&amp;width=580" alt="image.png"></p>
<h3 id="添加脚本"><a href="#添加脚本" class="headerlink" title="添加脚本"></a>添加脚本</h3><pre><code class="json">{
  &quot;name&quot;: &quot;my-site&quot;,
  &quot;version&quot;: &quot;1.0.0&quot;,
  &quot;main&quot;: &quot;index.js&quot;,
  &quot;license&quot;: &quot;MIT&quot;,
  &quot;devDependencies&quot;: {
    &quot;vuepress&quot;: &quot;^1.7.1&quot;
  },
  &quot;scripts&quot;: {
    &quot;docs:dev&quot;: &quot;vuepress dev docs&quot;,
    &quot;docs:build&quot;: &quot;vuepress build docs&quot;
  }
}
</code></pre>
<h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1608541418296-b53b29dc-f6a9-480f-b65d-009a21c0d013.png#align=left&amp;display=inline&amp;height=237&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=474&amp;originWidth=951&amp;size=59046&amp;status=done&amp;style=none&amp;width=475.5" alt="image.png"><br>端口访问：<a href="http://localhost:8080/" target="_blank" rel="noopener">http://localhost:8080/</a></p>
]]></content:encoded>
      <comments>https://www.wztlink1013.com/blog/czl3oc/#comments</comments>
    </item>
    
    <item>
      <title><![CDATA[搭建“文本三巨头”环境]]></title>
      <link>https://www.wztlink1013.com/blog/yhxiep/</link>
      <guid>https://www.wztlink1013.com/blog/yhxiep/</guid>
      <pubDate>Sat Dec 19 2020 06:32:00 GMT+0000 (Coordinated Universal Time)</pubDate>
      <description>
      <![CDATA[搭建“文本三巨头”环境]]>
      
      </description>
      <content:encoded><![CDATA[<h2 id="Vim"><a href="#Vim" class="headerlink" title="Vim"></a>Vim</h2><h3 id="Vim-下载安装"><a href="#Vim-下载安装" class="headerlink" title="Vim 下载安装"></a>Vim 下载安装</h3><p><a href="https://www.vim.org/download.php" target="_blank" rel="noopener">下载地址</a><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1608357192619-ac3d093e-c4e4-49fa-9a3b-8ead607b2160.png#align=left&amp;display=inline&amp;height=299&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=598&amp;originWidth=1919&amp;size=248340&amp;status=done&amp;style=none&amp;width=959.5" alt="image.png"><br>下载完之后 next 安装即可</p>
<h3 id="Vim-环境变量配置"><a href="#Vim-环境变量配置" class="headerlink" title="Vim 环境变量配置"></a>Vim 环境变量配置</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1608357482468-e6a53bc3-991d-4eda-aa2e-c5643b9617b0.png#align=left&amp;display=inline&amp;height=89&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=177&amp;originWidth=602&amp;size=11434&amp;status=done&amp;style=none&amp;width=301" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1608357463679-c00baef1-4e21-4405-8e79-f65afabe0370.png#align=left&amp;display=inline&amp;height=469&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=938&amp;originWidth=976&amp;size=105454&amp;status=done&amp;style=none&amp;width=488" alt="image.png"></p>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1608357601712-bc8f6f5b-6038-4358-8699-a7201ce8223e.png#align=left&amp;display=inline&amp;height=112&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=225&amp;originWidth=1468&amp;size=22708&amp;status=done&amp;style=none&amp;width=734" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1608357572830-fd4043b2-f02a-4c32-b9e7-677c4918ec19.png#align=left&amp;display=inline&amp;height=383&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=766&amp;originWidth=1442&amp;size=64262&amp;status=done&amp;style=none&amp;width=721" alt="image.png"></p>
<h2 id="zsh"><a href="#zsh" class="headerlink" title="zsh"></a>zsh</h2><h3 id="安装-Linux-子系统"><a href="#安装-Linux-子系统" class="headerlink" title="安装 Linux 子系统"></a>安装 Linux 子系统</h3><p>查看之前写的文章：<a href="https://www.wztlink1013.com/blog/xnh83z/">搭建 Windows 子系统 Linux - 尼采般地抒情</a></p>
<h3 id="安装-ConEmu"><a href="#安装-ConEmu" class="headerlink" title="安装 ConEmu"></a>安装 ConEmu</h3><p><a href="https://www.fosshub.com/ConEmu.html" target="_blank" rel="noopener">https://www.fosshub.com/ConEmu.html</a><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1608358847174-3a3b7ba1-45e8-4951-a943-debd2a09de43.png#align=left&amp;display=inline&amp;height=217&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=434&amp;originWidth=1904&amp;size=80285&amp;status=done&amp;style=none&amp;width=952" alt="image.png"><br>设置如下：<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1608358926353-c172728f-978e-47f7-9ec5-34472219ccdb.png#align=left&amp;display=inline&amp;height=376&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=751&amp;originWidth=1143&amp;size=84693&amp;status=done&amp;style=none&amp;width=571.5" alt="image.png"><br>确定后会进入以下界面<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1608358964494-c12c30a4-4b04-4463-b3d6-3c5fc21b607f.png#align=left&amp;display=inline&amp;height=359&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=717&amp;originWidth=970&amp;size=40132&amp;status=done&amp;style=none&amp;width=485" alt="image.png"></p>
<h3 id="安装并配置-zsh"><a href="#安装并配置-zsh" class="headerlink" title="安装并配置 zsh"></a>安装并配置 zsh</h3><p>进入页面 <code>sudo apt-get install -y zsh</code> ，输入密码：<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1608359167583-80d5f5fd-77e6-417d-ac0c-279dbfb55776.png#align=left&amp;display=inline&amp;height=300&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=600&amp;originWidth=960&amp;size=64893&amp;status=done&amp;style=none&amp;width=480" alt="image.png"><br>安装成功界面如下：<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1608360612991-863a5a2e-77a2-4bd7-b1b9-4ef6a79dcb86.png#align=left&amp;display=inline&amp;height=456&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=912&amp;originWidth=1908&amp;size=196509&amp;status=done&amp;style=none&amp;width=954" alt="image.png"></p>
<h3 id="安装-oh-my-zsh"><a href="#安装-oh-my-zsh" class="headerlink" title="安装 oh-my-zsh"></a>安装 oh-my-zsh</h3><p>sh -c “$(curl -fsSL <a href="https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh" target="_blank" rel="noopener">https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)”</a>%22)<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1608360763102-d6886d61-c954-4c15-adfc-ca42c0daf337.png#align=left&amp;display=inline&amp;height=411&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=821&amp;originWidth=1908&amp;size=125769&amp;status=done&amp;style=none&amp;width=954" alt="image.png"><br>上述文件夹在这里： <code>C:\Users\wztli\AppData\Local\Packages\CanonicalGroupLimited.UbuntuonWindows_79rhkp1fndgsc\LocalState\rootfs\home\wztlink1013</code></p>
<h2 id="tmux"><a href="#tmux" class="headerlink" title="tmux"></a>tmux</h2><h3 id="安装运行"><a href="#安装运行" class="headerlink" title="安装运行"></a>安装运行</h3><p>Ubuntu 系统命令行界面输入： <code>sudo apt install tmux</code></p>
<p>在 Ubuntu 系统输入并执行”tmux”命令，会进入 tmux 窗口</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://www.jianshu.com/p/5f7b83ca3952" target="_blank" rel="noopener">https://www.jianshu.com/p/5f7b83ca3952</a></li>
<li><a href="https://post.smzdm.com/p/a5k6e033/" target="_blank" rel="noopener">https://post.smzdm.com/p/a5k6e033/</a></li>
<li><a href="https://blog.csdn.net/qq_2300688967/article/details/81774297" target="_blank" rel="noopener">https://blog.csdn.net/qq_2300688967/article/details/81774297</a></li>
</ul>
]]></content:encoded>
      <comments>https://www.wztlink1013.com/blog/yhxiep/#comments</comments>
    </item>
    
    <item>
      <title><![CDATA[P150.逆波兰表达式求值]]></title>
      <link>https://www.wztlink1013.com/blog/ewoap5/</link>
      <guid>https://www.wztlink1013.com/blog/ewoap5/</guid>
      <pubDate>Thu Dec 03 2020 05:25:52 GMT+0000 (Coordinated Universal Time)</pubDate>
      <description>
      <![CDATA[<h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>对所给字符串进行遍历，遇到数字字符就压入栈 stack 内，遇到+-*/符号就 pop 处栈的两个元素，进行该字符运算处理<]]>
      </description>
      <content:encoded><![CDATA[<h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>对所给字符串进行遍历，遇到数字字符就压入栈 stack 内，遇到+-*/符号就 pop 处栈的两个元素，进行该字符运算处理</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><pre><code class="java">package com.wztlink1013.problems.leetcode.editor.cn;

// P150.逆波兰表达式求值
// P150.evaluate-reverse-polish-notation
//根据 逆波兰表示法，求表达式的值。
//
// 有效的运算符包括 +, -, *, / 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。
//
//
//
// 说明：
//
//
// 整数除法只保留整数部分。
// 给定逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。
//
//
//
//
// 示例 1：
//
// 输入: [&quot;2&quot;, &quot;1&quot;, &quot;+&quot;, &quot;3&quot;, &quot;*&quot;]
//输出: 9
//解释: 该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) = 9
//
//
// 示例 2：
//
// 输入: [&quot;4&quot;, &quot;13&quot;, &quot;5&quot;, &quot;/&quot;, &quot;+&quot;]
//输出: 6
//解释: 该算式转化为常见的中缀算术表达式为：(4 + (13 / 5)) = 6
//
//
// 示例 3：
//
// 输入: [&quot;10&quot;, &quot;6&quot;, &quot;9&quot;, &quot;3&quot;, &quot;+&quot;, &quot;-11&quot;, &quot;*&quot;, &quot;/&quot;, &quot;*&quot;, &quot;17&quot;, &quot;+&quot;, &quot;5&quot;, &quot;+&quot;]
//输出: 22
//解释:
//该算式转化为常见的中缀算术表达式为：
//  ((10 * (6 / ((9 + 3) * -11))) + 17) + 5
//= ((10 * (6 / (12 * -11))) + 17) + 5
//= ((10 * (6 / -132)) + 17) + 5
//= ((10 * 0) + 17) + 5
//= (0 + 17) + 5
//= 17 + 5
//= 22
//
//
//
// 逆波兰表达式：
//
// 逆波兰表达式是一种后缀表达式，所谓后缀就是指算符写在后面。
//
//
// 平常使用的算式则是一种中缀表达式，如 ( 1 + 2 ) * ( 3 + 4 ) 。
// 该算式的逆波兰表达式写法为 ( ( 1 2 + ) ( 3 4 + ) * ) 。
//
//
// 逆波兰表达式主要有以下两个优点：
//
//
// 去掉括号后表达式无歧义，上式即便写成 1 2 + 3 4 + * 也可以依据次序计算出正确结果。
// 适合用栈操作运算：遇到数字则入栈；遇到算符则取出栈顶两个数字进行计算，并将结果压入栈中。
//
// Related Topics 栈
// 👍 213 👎 0


import java.util.Stack;

public class P150EvaluateReversePolishNotation{
    public static void main(String[] args) {
        Solution solution = new P150EvaluateReversePolishNotation().new Solution();
        String[] tokens_1 = {&quot;10&quot;, &quot;6&quot;, &quot;9&quot;, &quot;3&quot;, &quot;+&quot;, &quot;-11&quot;, &quot;*&quot;, &quot;/&quot;, &quot;*&quot;, &quot;17&quot;, &quot;+&quot;, &quot;5&quot;, &quot;+&quot;};
        int temp = solution.evalRPN(tokens_1);
        System.out.println(temp);

    }

//leetcode submit region begin(Prohibit modification and deletion)
class Solution {
    public int evalRPN(String[] tokens) {
        Stack&lt;String&gt; stack = new Stack&lt;&gt;();

        String temp = &quot;0&quot;;
        stack.push(temp);

        for (String token : tokens) {
            int sum = 0;
            if (token.equals(&quot;+&quot;)) {
                sum += Integer.parseInt(stack.pop()) + Integer.parseInt(stack.pop());
                String str = String.valueOf(sum);
                stack.push(str);
            } else if (token.equals(&quot;-&quot;)) {
                int i = Integer.parseInt(stack.pop());
                int j = Integer.parseInt(stack.pop());
                sum += j-i;
                String str = String.valueOf(sum);
                stack.push(str);
            } else if (token.equals(&quot;*&quot;)) {
                sum += Integer.parseInt(stack.pop()) * Integer.parseInt(stack.pop());
                String str = String.valueOf(sum);
                stack.push(str);
            } else if (token.equals(&quot;/&quot;)) {
                int i = Integer.parseInt(stack.pop());
                int j = Integer.parseInt(stack.pop());
                sum += j / i;
                String str = String.valueOf(sum);
                stack.push(str);
            } else {
                stack.push(token);
            }
        }
        int result = Integer.parseInt(stack.pop());
        return result;
    }
}
//leetcode submit region end(Prohibit modification and deletion)

}
</code></pre>
]]></content:encoded>
      <comments>https://www.wztlink1013.com/blog/ewoap5/#comments</comments>
    </item>
    
    <item>
      <title><![CDATA[hexo-部署出错at formatNunjucksError]]></title>
      <link>https://www.wztlink1013.com/blog/gw1d4z/</link>
      <guid>https://www.wztlink1013.com/blog/gw1d4z/</guid>
      <pubDate>Thu Dec 03 2020 03:04:36 GMT+0000 (Coordinated Universal Time)</pubDate>
      <description>
      <![CDATA[<h2 id="报错信息"><a href="#报错信息" class="headerlink" title="报错信息"></a>报错信息</h2><p>GitHub Actions 流程中 hexo g 出现错误，具体错误在“Vue 笔记”中那篇文章中，有个地方用到了大括号嵌]]>
      </description>
      <content:encoded><![CDATA[<h2 id="报错信息"><a href="#报错信息" class="headerlink" title="报错信息"></a>报错信息</h2><p>GitHub Actions 流程中 hexo g 出现错误，具体错误在“Vue 笔记”中那篇文章中，有个地方用到了大括号嵌套的情况。</p>
<pre><code class="bash">    =====             Context Dump Ends            =====
    at formatNunjucksError (/home/runner/work/website/website/node_modules/hexo/lib/extend/tag.js:102:13)
    at Promise.fromCallback.catch.err (/home/runner/work/website/website/node_modules/hexo/lib/extend/tag.js:124:34)
    at tryCatcher (/home/runner/work/website/website/node_modules/bluebird/js/release/util.js:16:23)
    at Promise._settlePromiseFromHandler (/home/runner/work/website/website/node_modules/bluebird/js/release/promise.js:547:31)
    at Promise._settlePromise (/home/runner/work/website/website/node_modules/bluebird/js/release/promise.js:604:18)
    at Promise._settlePromise0 (/home/runner/work/website/website/node_modules/bluebird/js/release/promise.js:649:10)
    at Promise._settlePromises (/home/runner/work/website/website/node_modules/bluebird/js/release/promise.js:725:18)
    at _drainQueueStep (/home/runner/work/website/website/node_modules/bluebird/js/release/async.js:93:12)
    at _drainQueue (/home/runner/work/website/website/node_modules/bluebird/js/release/async.js:86:9)
    at Async._drainQueues (/home/runner/work/website/website/node_modules/bluebird/js/release/async.js:102:5)
    at Immediate.Async.drainQueues [as _onImmediate] (/home/runner/work/website/website/node_modules/bluebird/js/release/async.js:15:14)
    at runCallback (timers.js:705:18)
    at tryOnImmediate (timers.js:676:5)
    at processImmediate (timers.js:658:5)
Error: Process completed with exit code 2.
</code></pre>
<h2 id="问题分析与解决"><a href="#问题分析与解决" class="headerlink" title="问题分析与解决"></a>问题分析与解决</h2><p>上述代码中第二行其实已经说的很明确 <code>at formatNunjucksError</code><br>但是 hexo 中，渲染过程中用到的是 Nunjucks，在 Nunjucks 中双大括号被视为语法，所以报错。</p>
<h2 id="小记"><a href="#小记" class="headerlink" title="小记"></a>小记</h2><p><a href="https://www.wztlink1013.com/blog/pxpix4/">https://www.wztlink1013.com/blog/pxpix4/</a></p>
<p>其实之前遇到过类似的问题……写的博客还是要经常回顾……</p>
]]></content:encoded>
      <comments>https://www.wztlink1013.com/blog/gw1d4z/#comments</comments>
    </item>
    
    <item>
      <title><![CDATA[GitHub多人协作功能Pull requests]]></title>
      <link>https://www.wztlink1013.com/blog/iwvugw/</link>
      <guid>https://www.wztlink1013.com/blog/iwvugw/</guid>
      <pubDate>Wed Dec 02 2020 05:03:36 GMT+0000 (Coordinated Universal Time)</pubDate>
      <description>
      <![CDATA[<h2 id="给出一个初始场景"><a href="#给出一个初始场景" class="headerlink" title="给出一个初始场景"></a>给出一个初始场景</h2><p>小吴和小王同时开发一个项目 project，该项目托管到 GitHub 上，假定该项目托管到]]>
      </description>
      <content:encoded><![CDATA[<h2 id="给出一个初始场景"><a href="#给出一个初始场景" class="headerlink" title="给出一个初始场景"></a>给出一个初始场景</h2><p>小吴和小王同时开发一个项目 project，该项目托管到 GitHub 上，假定该项目托管到小吴的 GitHub 上，小王要想同时开发这个 project，就必须要 fork 小吴的这个 project，最后两个人 GitHub 仓库是这个样子的：</p>
<p>小吴：xiaowu/project<br>小王：xiaowang/project</p>
<p>（需要明确一点，小吴小王各自的 project 仓库现在就相当各做各的事情了）</p>
<h2 id="具体工作场景"><a href="#具体工作场景" class="headerlink" title="具体工作场景"></a>具体工作场景</h2><p>小王的仓库 xiaowang/project 改了代码，想要 push 合并到小吴的仓库 xiaowu/project 中，这里分两种情况。</p>
<h3 id="第一种情况"><a href="#第一种情况" class="headerlink" title="第一种情况"></a>第一种情况</h3><p><strong>小王在从 fork 小吴仓库到现在这段期间，小吴没有对 xiaowu/project 做任何改动</strong></p>
<blockquote>
<p>处理方法：直接 Pull request<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1606915274704-123b219d-d7fe-4816-88c4-91ba11b5c466.png#align=left&amp;display=inline&amp;height=143&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=285&amp;originWidth=1917&amp;size=47997&amp;status=done&amp;style=shadow&amp;width=958.5" alt="image.png"> &gt; <img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1606915405152-c1e60a93-99fb-42d5-a7a5-87c564fe53d4.png#align=left&amp;display=inline&amp;height=270&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=540&amp;originWidth=1920&amp;size=80075&amp;status=done&amp;style=shadow&amp;width=960" alt="image.png"><br>可以看到 1 区域显示 Able to merge，表明这个 Pull request 对于双方是没有矛盾的</p>
</blockquote>
<h3 id="第二种情况"><a href="#第二种情况" class="headerlink" title="第二种情况"></a>第二种情况</h3><p><strong>小王在从 fork 小吴仓库到现在这段期间，小吴又在 xiaowu/project 里面做了改动，就相当于小王 fork 过后，两个人都对各自的仓库更新了，然后小王想将自己的改动推送到小吴那里</strong></p>
<blockquote>
<p><strong><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1606916524143-c5076532-2497-4923-986f-d442122e6de7.png#align=left&amp;display=inline&amp;height=287&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=574&amp;originWidth=1920&amp;size=91126&amp;status=done&amp;style=shadow&amp;width=960" alt="image.png"></strong> &gt; <strong>可以发现 1 处并没有那么顺利，因为产生了冲突，但是 2 处仍然可以新建一个 request 请求，先点击 2</strong> &gt; <strong><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1606916762342-e5215ae5-cf61-43ac-9051-f73c40de1fb1.png#align=left&amp;display=inline&amp;height=307&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=613&amp;originWidth=1191&amp;size=52688&amp;status=done&amp;style=shadow&amp;width=595.5" alt="image.png"></strong> &gt; <strong>点击之后会这样 👇</strong> &gt; <strong><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1606916826669-b406d584-50a7-49d5-9044-166bba4bc75f.png#align=left&amp;display=inline&amp;height=133&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=266&amp;originWidth=1284&amp;size=32978&amp;status=done&amp;style=shadow&amp;width=642" alt="image.png"></strong><br>1 处显示矛盾的文件（就是小吴和小王在各自的仓库都进行了更改）<br>我们点击 2 处<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1606916998671-6b369cf8-f6dc-4ad3-ba0b-d2f7006b7804.png#align=left&amp;display=inline&amp;height=198&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=396&amp;originWidth=1920&amp;size=65448&amp;status=done&amp;style=shadow&amp;width=960" alt="image.png"><br>接下来解决这个问题并且点击 Mark as resolved 按钮就可以了<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1606917076365-e79652f9-3c56-4259-87d4-b6e979af277d.png#align=left&amp;display=inline&amp;height=181&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=361&amp;originWidth=1920&amp;size=44612&amp;status=done&amp;style=shadow&amp;width=960" alt="image.png"> &gt; <img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1606917146702-bc316303-78f2-4746-94fa-72e4cda90dd0.png#align=left&amp;display=inline&amp;height=196&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=391&amp;originWidth=1920&amp;size=87061&amp;status=done&amp;style=shadow&amp;width=960" alt="image.png"><br>最后就会出现下面的图，接下来，小吴在他的 GitHub 上同意接受这个请求就可以了。（或者小王有权限小王自己接受也可以）<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1606917264180-37c25758-4db9-44f8-a3f6-0ca725d6c0fd.png#align=left&amp;display=inline&amp;height=435&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=869&amp;originWidth=1435&amp;size=132722&amp;status=done&amp;style=shadow&amp;width=717.5" alt="image.png"></p>
</blockquote>
]]></content:encoded>
      <comments>https://www.wztlink1013.com/blog/iwvugw/#comments</comments>
    </item>
    
  </channel>
</rss>
