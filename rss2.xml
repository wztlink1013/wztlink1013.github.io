<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>尼采般地抒情</title>
    <link>https://www.wztlink1013.com/</link>
    
    <image>
      <url>https://www.wztlink1013.com/favicon.ico</url>
      <title>尼采般地抒情</title>
      <link>https://www.wztlink1013.com/</link>
    </image>
    
    <atom:link href="https://www.wztlink1013.com/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>尼采般地抒情个人网站，本科CS，大学期间开始撰写技术博客、个人生活随笔，这个兴趣爱好会一直延续下去……坚信什么都不舍弃，什么也改变不了！</description>
    <pubDate>Thu, 29 Feb 2024 19:21:03 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>项目使用all-contributors-cli生成贡献者名单</title>
      <link>https://www.wztlink1013.com/blog/wgervpvkdaoc42ml/</link>
      <guid>https://www.wztlink1013.com/blog/wgervpvkdaoc42ml/</guid>
      <pubDate>Thu, 29 Feb 2024 19:17:53 GMT</pubDate>
      
        
        
          
          
      <description>&lt;!doctype html&gt;&lt;div class=&quot;lake-content&quot; typography=&quot;classic&quot;&gt;&lt;p id=&quot;ue1444cdc&quot; class=&quot;ne-p&quot;&gt;&lt;img</description>
          
        
      
      
      
      <content:encoded><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="ue1444cdc" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2024/png/1484158/1709262142751-6bca1311-c71b-464a-b603-c4d4d89a6f88.png" width="899.9999642372145" id="wtp7K" class="ne-image"></p><p id="ue531d0e9" class="ne-p"><span class="ne-text">前言：all-contributors用于管理和展示项目的贡献者列表，展示贡献者的贡献类型和基础个人信息（头像和昵称）在README.md文件中。</span></p><h3 id="NIt7l"><span class="ne-text">一、初始化all-contributors</span></h3><p id="u226282a0" class="ne-p"><span class="ne-text">项目安装all-contributors-cli</span></p><pre><code><code>pnpm i all-contributors-cli</code></code></pre><p id="u6f44d18e" class="ne-p"><span class="ne-text">项目初始化all-contributors-cli</span></p><pre><code><code>./node_modules/.bin/all-contributors init</code></code></pre><p id="u117ff10e" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2024/png/1484158/1709259194099-6aefe00d-2ad6-4066-8ca7-4ffdb8cf65b9.png" width="808.3333129882812" id="SqJU9" class="ne-image"></p><p id="ud585018e" class="ne-p"><span class="ne-text">初始化完之后，项目的一些文件会自动发生变化：</span></p><ol class="ne-ol"><li id="u16c87012" data-lake-index-type="0"><span class="ne-text">生成</span><code class="ne-code"><span class="ne-text">.all-contributorsrc</span></code><span class="ne-text">文件</span></li></ol><pre><code><code>&#123;  &quot;projectName&quot;: &quot;kittyui&quot;,  &quot;projectOwner&quot;: &quot;wztlink1013&quot;,  &quot;repoType&quot;: &quot;github&quot;,  &quot;repoHost&quot;: &quot;https://github.com&quot;,  &quot;files&quot;: [    &quot;README.md&quot;  ],  &quot;imageSize&quot;: 100,  &quot;commit&quot;: true,  &quot;commitConvention&quot;: &quot;eslint&quot;,  &quot;contributors&quot;: [],  &quot;contributorsPerLine&quot;: 7,  &quot;linkToUsage&quot;: true&#125;</code></code></pre><ol start="2" class="ne-ol"><li id="u451466e9" data-lake-index-type="0"><code class="ne-code"><span class="ne-text">README.md</span></code><span class="ne-text">会在开头和结尾自动添加allcontributors文本展示内容</span></li></ol><pre><code><code>&lt;!-- ALL-CONTRIBUTORS-BADGE:START - Do not remove or modify this section --&gt;<p><a href="#contributors-"><img src="https://img.shields.io/badge/all_contributors-0-orange.svg?style=flat-square" alt="All Contributors"></a></p><p>&lt;!– ALL-CONTRIBUTORS-BADGE:END –&gt;</p><h2 id="Contributors-✨"><a href="#Contributors-✨" class="headerlink" title="Contributors ✨"></a>Contributors ✨</h2><p>Thanks goes to these wonderful people (<a href="https://allcontributors.org/docs/en/emoji-key">emoji key</a>):</p><p>&lt;!– ALL-CONTRIBUTORS-LIST:START - Do not remove or modify this section –&gt;<br>&lt;!– prettier-ignore-start –&gt;<br>&lt;!– markdownlint-disable –&gt;<br>&lt;!– markdownlint-restore –&gt;<br>&lt;!– prettier-ignore-end –&gt;</p><p>&lt;!– ALL-CONTRIBUTORS-LIST:END –&gt;</p><p>This project follows the <a href="https://github.com/all-contributors/all-contributors">all-contributors</a> specification. Contributions of any kind welcome!<br></code><br></code></pre></p><p id="u76f459a3" class="ne-p"><span class="ne-text">效果如下：</span></p><p id="u4cd61ad1" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2024/png/1484158/1709259753769-1124031a-03b2-46d3-9a6f-51f2619b668f.png" width="895.8332977361164" id="u7793f912" class="ne-image"></p><h3 id="PxGg4"><span class="ne-text">二、添加项目开发协作者</span></h3><p id="uad1a54ce" class="ne-p"><span class="ne-text">添加方式有两种：</span></p><ol class="ne-ol"><li id="u99820ece" data-lake-index-type="0"><span class="ne-text">命令行方式添加</span></li><li id="u39e4dc98" data-lake-index-type="0"><span class="ne-text">仓库机器人方式添加：协作者利用</span><code class="ne-code"><span class="ne-text">issues</span></code><span class="ne-text">或者</span><code class="ne-code"><span class="ne-text">pull request</span></code><span class="ne-text">拉取请求方式申请添加</span></li></ol><h4 id="d2jcn"><span class="ne-text">命令行方式添加</span></h4><p id="u7b491dee" class="ne-p"><span class="ne-text">添加用户</span></p><pre><code><code># 添加做出了 &lt;contribution&gt; 类型贡献的贡献者 &lt;username&gt;, # ./node_modules/.bin/all-contributors add &lt;username&gt; &lt;contribution&gt;<p>./node_modules/.bin/all-contributors add wztlink1013 &quot;code,doc&quot;</code><br></code></pre></p><p id="ue9386363" class="ne-p"><span class="ne-text">生成展示表格（自动更新</span><code class="ne-code"><span class="ne-text">README.md</span></code><span class="ne-text">文件）</span></p><pre><code><code>./node_modules/.bin/all-contributors generate</code></code></pre><p id="u61f7d48e" class="ne-p"><span class="ne-text">上述两个命令执行完会自动更新</span><code class="ne-code"><span class="ne-text">.all-contributorsrc</span></code><span class="ne-text">文件和</span><code class="ne-code"><span class="ne-text">README.md</span></code><span class="ne-text">文件</span></p><p id="ue3ad0498" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2024/png/1484158/1709260794169-7a790b49-7e72-4e28-a8b8-3bd7917e5cd3.png" width="900.8332975374342" id="u8cb20852" class="ne-image"></p><h4 id="VRut0"><span class="ne-text">仓库机器人方式添加</span></h4><p id="u3e012659" class="ne-p"><span class="ne-text">添加仓库机器人：</span></p><ul class="ne-ul"><li id="u7d0db2cd" data-lake-index-type="0"><span class="ne-text">GitHub Bot下载：</span><a href="https://github.com/apps/allcontributors/installations/select_target" data-href="https://github.com/apps/allcontributors/installations/select_target" target="_blank" class="ne-link"><span class="ne-text">https://github.com/apps/allcontributors/installations/select_target</span></a></li></ul><p id="u96cff878" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2024/png/1484158/1709261083635-11a66e62-f4a0-4d6f-a4a1-661e58d39f39.png" width="490.8333138293698" id="ub978da08" class="ne-image"></p><p id="u6c6b1f1b" class="ne-p"><span class="ne-text"></span></p><p id="u4dca5414" class="ne-p"><span class="ne-text">发起</span><code class="ne-code"><span class="ne-text">issues</span></code><span class="ne-text">或者</span><code class="ne-code"><span class="ne-text">pull request</span></code><span class="ne-text">请求加入协作者</span></p><p id="uf8fe5fe4" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2024/png/1484158/1709261947692-5df9b5bb-c3e1-42ed-b58c-d53e7c3a3ea9.png" width="770.8333027031699" id="u8bf5b0ab" class="ne-image"></p><p id="uccc5429a" class="ne-p"><span class="ne-text">然后会有一个合并新协作者的</span><code class="ne-code"><span class="ne-text">pull request</span></code><span class="ne-text">被创建，merge即可。</span></p><p id="ua1b3edf5" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2024/png/1484158/1709262058313-e1380c4e-ac76-450d-887d-b41632b99d79.png" width="1045.833291775652" id="ufebc37c4" class="ne-image"></p><h3 id="xDQ9h"><span class="ne-text">三、最终效果</span></h3><p id="uc797f4e9" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2024/png/1484158/1709262142751-6bca1311-c71b-464a-b603-c4d4d89a6f88.png" width="899.9999642372145" id="uf08c90b7" class="ne-image"></p><h3 id="AD8dV"><span class="ne-text">四、参考</span></h3><ul class="ne-ul"><li id="ucf112a8d" data-lake-index-type="0"><a href="https://allcontributors.org/" data-href="https://allcontributors.org/" target="_blank" class="ne-link"><span class="ne-text">https://allcontributors.org/</span></a></li><li id="u4d49a7c1" data-lake-index-type="0"><span class="ne-text">贡献类型：</span><a href="https://allcontributors.org/docs/en/emoji-key" data-href="https://allcontributors.org/docs/en/emoji-key" target="_blank" class="ne-link"><span class="ne-text">https://allcontributors.org/docs/en/emoji-key</span></a></li></ul></div>]]></content:encoded>
      
      
      <category domain="https://www.wztlink1013.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B4%A0%E5%85%BB/">计算机素养</category>
      
      <category domain="https://www.wztlink1013.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B4%A0%E5%85%BB/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/">软件工程</category>
      
      
      
      <comments>https://www.wztlink1013.com/blog/wgervpvkdaoc42ml/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Github Actions自动部署项目到云服务器</title>
      <link>https://www.wztlink1013.com/blog/cgo5a1ofo4g7612b/</link>
      <guid>https://www.wztlink1013.com/blog/cgo5a1ofo4g7612b/</guid>
      <pubDate>Wed, 28 Feb 2024 22:27:42 GMT</pubDate>
      
        
        
          
          
      <description>&lt;!doctype html&gt;&lt;div class=&quot;lake-content&quot; typography=&quot;classic&quot;&gt;&lt;p id=&quot;ue2cb4a43&quot; class=&quot;ne-p&quot;&gt;&lt;img</description>
          
        
      
      
      
      <content:encoded><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="ue2cb4a43" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2024/png/1484158/1709186151285-0873ba2c-2ec2-49c1-a9f7-91971c51460f.png" width="1579.1666039162237" id="uc3d67a17" class="ne-image"></p><p id="uf4d7e961" class="ne-p"><span class="ne-text">前言：项目部署至服务器，一般而言，只需要将打包后的静态代码上传到服务器指定位置，如果配置的是nginx web服务器，再执行刷新相关命令即可。本文记录1panel运维管理面板下，结合GitHub Action自动化部署项目打包代码至云服务器的脚本编写逻辑。</span></p><h3 id="ikwbc"><span class="ne-text">一、GitHub Actions环境准备</span></h3><p id="uf7143646" class="ne-p"><span class="ne-text">GitHub Actions脚本的执行涉及一些敏感变量，在GitHub仓库中可以设置隐形变量防止暴露在外，只有在 GitHub Actions 中才能使用到</span></p><p id="ua08b3c13" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2024/png/1484158/1709183847317-5c3b51ab-6524-4443-88eb-3c361a32e1cc.png" width="1111.6666224930038" id="u294f3f6d" class="ne-image"></p><p id="u197af0e8" class="ne-p"><span class="ne-text">环境变量含义：</span></p><ol class="ne-ol"><li id="uf855a872" data-lake-index-type="0"><span class="ne-text">KEY（密钥）</span></li><li id="ub493d228" data-lake-index-type="0"><span class="ne-text">PASSPHRASE（加密私钥的密码）</span></li><li id="udd55ac46" data-lake-index-type="0"><span class="ne-text">SERVER_IP（云服务器公网IP）</span></li><li id="udc38e6a5" data-lake-index-type="0"><span class="ne-text">USERNAME（云服务器登录用户名， 通常为root）</span></li></ol><div data-type="color2" class="ne-alert"><p id="u75ef5804" class="ne-p"><span class="ne-text">📌</span><span class="ne-text"> </span><code class="ne-code"><span class="ne-text">KEY</span></code><span class="ne-text">和</span><code class="ne-code"><span class="ne-text">PASSPHRASE</span></code><span class="ne-text">分别为下面截图中的2和1</span></p></div><p id="u99f5b2c5" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2024/png/1484158/1708961842486-da9a4392-86a2-4f32-92ef-06702be0a712.png" width="986.9921875" id="ub4020674" class="ne-image"></p><h3 id="LqgtN"><span class="ne-text">二、GitHub Actions脚本编写</span></h3><p id="uda06d594" class="ne-p"><span class="ne-text">脚本需要做的事情有如下几点：</span></p><ol class="ne-ol"><li id="uf66054c0" data-lake-index-type="0"><span class="ne-text">项目打包成静态文件</span></li><li id="u3e5cf593" data-lake-index-type="0"><span class="ne-text">将打包后的静态文件上传至云服务器指定文件夹</span></li></ol><h4 id="liMcO"><span class="ne-text">打包成静态文件</span></h4><p id="u5407fa59" class="ne-p"><span class="ne-text">执行项目打包命令</span></p><pre><code><code>- name: Use Node.js $&#123;&#123; matrix.node-version &#125;&#125;  uses: actions/setup-node@v4  with:    node-version: $&#123;&#123; matrix.node-version &#125;&#125;    cache: 'pnpm'- run: |    pnpm install    pnpm build    mv apps/test-project/dist/ ./dist/</code></code></pre><h4 id="cUm29"><span class="ne-text">上传服务器</span></h4><p id="uf88c8467" class="ne-p"><span class="ne-text">利用scp-action将指定文件夹上传至服务器目标文件夹</span></p><pre><code><code>- name: Scp file to aliyun  uses: appleboy/scp-action@v0.1.7  with:    host: $&#123;&#123; secrets.SERVER_IP &#125;&#125;    username: $&#123;&#123; secrets.USERNAME &#125;&#125;    key: $&#123;&#123; secrets.KEY &#125;&#125;    passphrase: $&#123;&#123; secrets.PASSPHRASE &#125;&#125;    tar_dereference: true    rm: true    source: 'dist/*'    target: '/opt/1panel/apps/openresty/openresty/www/sites/test.com/index'</code></code></pre><p id="u01903c90" class="ne-p"><span class="ne-text">上述脚本代码只是上传，不能在服务器进行相关命令操作文件，还需要利用ssh-action添加如下脚本：</span></p><pre><code><code>- name: executing remote ssh commands using key  uses: appleboy/ssh-action@v1.0.3  with:    host: $&#123;&#123; secrets.SERVER_IP &#125;&#125;    username: $&#123;&#123; secrets.USERNAME &#125;&#125;    key: $&#123;&#123; secrets.KEY &#125;&#125;    passphrase: $&#123;&#123; secrets.PASSPHRASE &#125;&#125;    script: |      mv /opt/1panel/apps/openresty/openresty/www/sites/test.com/index/dist/* /opt/1panel/apps/openresty/openresty/www/sites/test.com/index/</code></code></pre><p id="u404b835b" class="ne-p"><span class="ne-text">这个脚本主要作用是将文件内容层级提升</span></p><div data-type="color2" class="ne-alert"><p id="u8cb3c33d" class="ne-p"><strong><span class="ne-text">因为本文章记录的是基于集成环境前端项目部署，只是打包后静态文件的替换，所以不涉及重启相关命令操作。</span></strong></p><p id="u181eb354" class="ne-p"><strong><span class="ne-text">如果你的环境不是继承运维面板（1panel/宝塔 等）的web服务器，而是手动搭建web服务器，则在这里可以写一些相关命令，比如nginx重启、node重启、docker重启指定容器……</span></strong></p><p id="ue84e02ee" class="ne-p"><strong><span class="ne-text">eg：</span></strong><code class="ne-code"><strong><span class="ne-text">docker restart project-name</span></strong></code></p></div><h3 id="m2XDQ"><span class="ne-text">三、最终代码</span></h3><ul class="ne-ul"><li id="u4b51c945" data-lake-index-type="0"><span class="ne-text">在GitHub仓库内添加文件</span><code class="ne-code"><span class="ne-text">.github/workflows/server.yml</span></code></li><li id="uccbf07d8" data-lake-index-type="0"><span class="ne-text">结合上述各个步骤的子代码，再添加部分GitHub Actions触发条件逻辑代码，整个脚本文件就完成了。</span></li></ul><pre><code><code>name: Aliyun Server Deployon:  push:    tags:      - release-**<p>jobs:<br>  deploy_job:<br>    runs-on: ubuntu-latest<br>    name: build<br>    steps:<br>      - uses: actions/checkout@v4<br>      - uses: pnpm/action-setup@v2<br>        with:<br>          version: 8<br>      - name: Use Node.js $&#123;&#123; matrix.node-version &#125;&#125;<br>        uses: actions/setup-node@v4<br>        with:<br>          node-version: $&#123;&#123; matrix.node-version &#125;&#125;<br>          cache: ‘pnpm’<br>      - run: |<br>          pnpm install<br>          pnpm build<br>          mv apps/test-project/dist/ ./dist/</p><pre><code>  - name: Scp file to aliyun    uses: appleboy/scp-action@v0.1.7    with:      host: $&#123;&#123; secrets.SERVER_IP &#125;&#125;      username: $&#123;&#123; secrets.USERNAME &#125;&#125;      key: $&#123;&#123; secrets.KEY &#125;&#125;      passphrase: $&#123;&#123; secrets.PASSPHRASE &#125;&#125;      tar_dereference: true      rm: true      source: &#39;dist/*&#39;      target: &#39;/opt/1panel/apps/openresty/openresty/www/sites/test.com/index&#39;  - name: executing remote ssh commands using key    uses: appleboy/ssh-action@v1.0.3    with:      host: $&#123;&#123; secrets.SERVER_IP &#125;&#125;      username: $&#123;&#123; secrets.USERNAME &#125;&#125;      key: $&#123;&#123; secrets.KEY &#125;&#125;      passphrase: $&#123;&#123; secrets.PASSPHRASE &#125;&#125;      script: |        mv /opt/1panel/apps/openresty/openresty/www/sites/test.com/index/dist/* /opt/1panel/apps/openresty/openresty/www/sites/test.com/index/&lt;/code&gt;</code></pre><p></code></pre></p><h3 id="JO08d"><span class="ne-text">四、参考</span></h3><ul class="ne-ul"><li id="ubd920933" data-lake-index-type="0"><a href="https://github.com/appleboy/scp-action" data-href="https://github.com/appleboy/scp-action" target="_blank" class="ne-link"><span class="ne-text">https://github.com/appleboy/scp-action</span></a></li><li id="u45a62d3b" data-lake-index-type="0"><a href="https://github.com/appleboy/ssh-action" data-href="https://github.com/appleboy/ssh-action" target="_blank" class="ne-link"><span class="ne-text">https://github.com/appleboy/ssh-action</span></a></li><li id="u94d8d882" data-lake-index-type="0"><a href="https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows" data-href="https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows" target="_blank" class="ne-link"><span class="ne-text">https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows</span></a></li></ul></div>]]></content:encoded>
      
      
      <category domain="https://www.wztlink1013.com/categories/Web%E5%BC%80%E5%8F%91/">Web开发</category>
      
      <category domain="https://www.wztlink1013.com/categories/Web%E5%BC%80%E5%8F%91/DevOps/">DevOps</category>
      
      
      
      <comments>https://www.wztlink1013.com/blog/cgo5a1ofo4g7612b/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Hexo优化网站SEO</title>
      <link>https://www.wztlink1013.com/blog/ymz4rr2wyxrxktqd/</link>
      <guid>https://www.wztlink1013.com/blog/ymz4rr2wyxrxktqd/</guid>
      <pubDate>Sun, 14 Jan 2024 02:06:51 GMT</pubDate>
      
        
        
          
          
      <description>&lt;!doctype html&gt;&lt;div class=&quot;lake-content&quot; typography=&quot;classic&quot;&gt;&lt;p id=&quot;ub944b1e4&quot; class=&quot;ne-p&quot;&gt;&lt;span</description>
          
        
      
      
      
      <content:encoded><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="ub944b1e4" class="ne-p"><span class="ne-text">前言：提高搜索引擎对网站的抓取质量，从以下两个文件入手：</span></p><ol class="ne-ol"><li id="u9472c50c" data-lake-index-type="0"><span class="ne-text">sitemap文件</span></li><li id="u3a99adbb" data-lake-index-type="0"><span class="ne-text">Robots.txt</span></li></ol><h3 id="DwDU8"><span class="ne-text">sitemap</span></h3><p id="u88ae2110" class="ne-p"><span class="ne-text">sitemap是一种包含网站所有页面URL的文件，有助于搜索引擎更快地索引和发现您的网站，其格式有xml或txt。在Hexo中，可以利用</span><a href="https://github.com/hexojs/hexo-generator-sitemap" data-href="https://github.com/hexojs/hexo-generator-sitemap" target="_blank" class="ne-link"><span class="ne-text">hexo-generator-sitemap</span></a><span class="ne-text">插件生成sitemap文件。</span></p><h4 id="xAlnz"><span class="ne-text">基本使用</span></h4><pre><code><code>npm i hexo-generator-sitemap --save</code></code></pre><p id="ud9d657b1" class="ne-p"><span class="ne-text">参数配置，具体使用参考文档：</span><a href="https://github.com/hexojs/hexo-generator-sitemap/tree/master?tab=readme-ov-file#options" data-href="https://github.com/hexojs/hexo-generator-sitemap/tree/master?tab=readme-ov-file#options" target="_blank" class="ne-link"><span class="ne-text">https://github.com/hexojs/hexo-generator-sitemap/tree/master?tab=readme-ov-file#options</span></a></p><pre><code><code>sitemap:  path: sitemap.xml  tags: false  categories: false  template: ./template/sitemap.xml</code></code></pre><p id="u06f186d4" class="ne-p"><span class="ne-text">生成后的sitemap文件如下：</span></p><pre><code><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;urlset xmlns=&quot;http://www.sitemaps.org/schemas/sitemap/0.9&quot;&gt;  &lt;url&gt;    &lt;loc&gt;https://www.wztlink1013.com/blog/tttk33/&lt;/loc&gt;    &lt;lastmod&gt;2024-01-14&lt;/lastmod&gt;    &lt;changefreq&gt;weekly&lt;/changefreq&gt;    &lt;priority&gt;0.8&lt;/priority&gt;  &lt;/url&gt;  &lt;url&gt;    &lt;loc&gt;https://www.wztlink1013.com/&lt;/loc&gt;    &lt;lastmod&gt;2024-01-14&lt;/lastmod&gt;    &lt;changefreq&gt;daily&lt;/changefreq&gt;    &lt;priority&gt;1.0&lt;/priority&gt;  &lt;/url&gt;&lt;/urlset&gt;</code></code></pre><ul class="ne-ul"><li id="uca43eeff" data-lake-index-type="0"><span class="ne-text">loc：抓取的网站子页url</span></li><li id="u1b2973d2" data-lake-index-type="0"><span class="ne-text">lastmod：改子页最新一次更新时间</span></li><li id="uc5f01609" data-lake-index-type="0"><span class="ne-text">changefreq：改子页更新频率</span></li><li id="u77e95919" data-lake-index-type="0"><span class="ne-text">priority：在该站点的抓取优先级权重</span></li></ul><h4 id="SEC0C"><span class="ne-text">自定义生成模板</span></h4><p id="u44db15c2" class="ne-p"><span class="ne-text" style="background-color: #FBDE28"></span><span class="ne-text">在项目根路径创建</span><code class="ne-code"><span class="ne-text">template/sitemap.xml</span></code><span class="ne-text">文件，并写入下面代码</span></p><pre><code><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;urlset xmlns=&quot;http://www.sitemaps.org/schemas/sitemap/0.9&quot;&gt;  &#123;% for post in posts %&#125;  &lt;url&gt;    &lt;loc&gt;&#123;&#123; post.permalink | uriencode &#125;&#125;&lt;/loc&gt;&#123;% if post.updated %&#125;    &lt;lastmod&gt;&#123;&#123; post.updated | formatDate &#125;&#125;&lt;/lastmod&gt;&#123;% elif post.date %&#125;    &lt;lastmod&gt;&#123;&#123; post.date | formatDate &#125;&#125;&lt;/lastmod&gt;&#123;% endif %&#125;    &lt;changefreq&gt;weekly&lt;/changefreq&gt;    &lt;priority&gt;0.8&lt;/priority&gt;  &lt;/url&gt;  &#123;% endfor %&#125;<p>  &lt;url&gt;<br>    &lt;loc&gt;&#123;&#123; config.url | uriencode &#125;&#125;&lt;/loc&gt;<br>    &lt;lastmod&gt;&#123;&#123; sNow | formatDate &#125;&#125;&lt;/lastmod&gt;<br>    &lt;changefreq&gt;daily&lt;/changefreq&gt;<br>    &lt;priority&gt;1.0&lt;/priority&gt;<br>  &lt;/url&gt;</p>  &#123;% for tag in tags %&#125;  &lt;url&gt;    &lt;loc&gt;&#123;&#123; tag.permalink | uriencode &#125;&#125;&lt;/loc&gt;    &lt;lastmod&gt;&#123;&#123; sNow | formatDate &#125;&#125;&lt;/lastmod&gt;    &lt;changefreq&gt;weekly&lt;/changefreq&gt;    &lt;priority&gt;0.2&lt;/priority&gt;  &lt;/url&gt;  &#123;% endfor %&#125;  &#123;% for cat in categories %&#125;  &lt;url&gt;    &lt;loc&gt;&#123;&#123; cat.permalink | uriencode &#125;&#125;&lt;/loc&gt;    &lt;lastmod&gt;&#123;&#123; sNow | formatDate &#125;&#125;&lt;/lastmod&gt;    &lt;changefreq&gt;weekly&lt;/changefreq&gt;    &lt;priority&gt;0.2&lt;/priority&gt;  &lt;/url&gt;  &#123;% endfor %&#125;<p>&lt;/urlset&gt;</code><br></code></pre></p><h4 id="kvZtE"><span class="ne-text">指定页面跳过sitemap收录</span></h4><p id="u0be81d58" class="ne-p"><span class="ne-text">在hexo中的文章或是页面，可以如下配置：</span></p><pre><code><code>---title: 隐藏文章date: 2024-01-14sitemap: false---</code></code></pre><h3 id="qE3ji"><span class="ne-text">robots.txt</span></h3><p id="u9a756fc4" class="ne-p"><span class="ne-text">robots文件是一个文本文件，用于向搜索引擎指示哪些页面可以访问和索引，哪些页面应该被忽略。通过优化 robots文件，可以提高网站在搜索引擎中的排名和曝光度。</span></p><pre><code><code># https://www.wztlink1013.comUser-agent: *Disallow: /Sitemap: https://www.wztlink1013.com/sitemap.xml</code></code></pre><ul class="ne-ul"><li id="u7e1ac461" data-lake-index-type="0"><span class="ne-text">User-agent：* 表示允许所有搜索引擎访问您的网站，如果限定的话，则键入 </span><code class="ne-code"><span class="ne-text">[搜索引擎名称]</span></code></li><li id="ue346fd0f" data-lake-index-type="0"><span class="ne-text">Sitemap：说明sitemap文件url</span></li><li id="udac61ea6" data-lake-index-type="0"><span class="ne-text">Disallow：</span><code class="ne-code"><span class="ne-text">/</span></code><span class="ne-text">表示禁止该搜索引擎访问您的网站中所有页面和文件</span></li></ul><div class="ne-quote"><ul class="ne-ul"><li id="ub8c27d16" data-lake-index-type="0"><span class="ne-text">检测自己写的robots文件是否生效：</span><a href="https://ziyuan.baidu.com/robots/intro" data-href="https://ziyuan.baidu.com/robots/intro" target="_blank" class="ne-link"><span class="ne-text">https://ziyuan.baidu.com/robots/intro</span></a><span class="ne-text"></span></li><li id="ub1d1e5aa" data-lake-index-type="0"><span class="ne-text">语法规则：</span><a href="https://ziyuan.baidu.com/college/courseinfo?id=267&amp;page=13" data-href="https://ziyuan.baidu.com/college/courseinfo?id=267&amp;page=13" target="_blank" class="ne-link"><span class="ne-text">https://ziyuan.baidu.com/college/courseinfo?id=267&amp;page=13</span></a></li></ul></div><p id="ufb489ca3" class="ne-p"><br></p><h3 id="NzJnY"><span class="ne-text">❗</span><span class="ne-text">百度不再允许大多数站点提交sitemap文件</span></h3><p id="u7080f3da" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2024/png/1484158/1705232927775-66b2b6e8-1f1c-40aa-a427-c3e9b59d680d.png" width="1098.3332896894897" id="u41efa066" class="ne-image"></p><p id="uadbf9159" class="ne-p"><span class="ne-text">如果之前没有提交过sitemap链接的，貌似没有办法提交sitemap链接了，如果之前提交过应该不受影响。。。</span></p></div>]]></content:encoded>
      
      
      <category domain="https://www.wztlink1013.com/categories/Web%E5%BC%80%E5%8F%91/">Web开发</category>
      
      <category domain="https://www.wztlink1013.com/categories/Web%E5%BC%80%E5%8F%91/%E5%8D%9A%E5%AE%A2%E6%8A%80%E6%9C%AF/">博客技术</category>
      
      
      
      <comments>https://www.wztlink1013.com/blog/ymz4rr2wyxrxktqd/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>2645. 构造有效字符串的最少插入数🔖DP🔖穷举</title>
      <link>https://www.wztlink1013.com/blog/lk1vbtcuw7ox57do/</link>
      <guid>https://www.wztlink1013.com/blog/lk1vbtcuw7ox57do/</guid>
      <pubDate>Sat, 13 Jan 2024 04:20:10 GMT</pubDate>
      
        
        
          
          
      <description>&lt;!doctype html&gt;&lt;div class=&quot;lake-content&quot; typography=&quot;classic&quot;&gt;&lt;ul class=&quot;ne-ul&quot;&gt;&lt;li id=&quot;u8c63af56&quot; data-lake-index-type=&quot;0&quot;&gt;&lt;span</description>
          
        
      
      
      
      <content:encoded><![CDATA[<!doctype html><div class="lake-content" typography="classic"><ul class="ne-ul"><li id="u8c63af56" data-lake-index-type="0"><span class="ne-text">题目：</span><a href="https://leetcode.cn/problems/minimum-additions-to-make-valid-string/" data-href="https://leetcode.cn/problems/minimum-additions-to-make-valid-string/" target="_blank" class="ne-link"><span class="ne-text">https://leetcode.cn/problems/minimum-additions-to-make-valid-string/</span></a></li></ul><p id="u805fc1c7" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2024/png/1484158/1705311894805-a68668b9-a6dc-4255-9eb8-11ab3d63453d.png" width="574.0741146281288" id="u153e480d" class="ne-image"></p><h3 id="gjP8I"><span class="ne-text">动态规划</span></h3><p id="u4c885b04" class="ne-p"><span class="ne-text">DP问题，两个步骤：</span></p><ol class="ne-ol"><li id="u67367468" data-lake-index-type="0"><span class="ne-text" style="background-color: #FBDE28">状态转移方程</span></li></ol><p id="u612b02d8" class="ne-p"><span class="ne-text">第一项作为边界情况，暂不考虑，从第二项往后看，三项之间的规律:</span></p><ul class="ne-ul"><li id="ue5e3da76" data-lake-index-type="0"><span class="ne-text">当</span><code class="ne-code"><span class="ne-text">i-1</span></code><span class="ne-text">项&gt;</span><code class="ne-code"><span class="ne-text">i-2</span></code><span class="ne-text">项：需要剪掉一个完整abc整体，即</span><code class="ne-code"><span class="ne-text">f(i) = f(i-1) - 1</span></code></li><li id="u303c6bc6" data-lake-index-type="0"><span class="ne-text">其余情况：</span><code class="ne-code"><span class="ne-text">f(i) = f(i-1) + 2</span></code></li></ul><ol start="2" class="ne-ol"><li id="u3bd15099" data-lake-index-type="0"><span class="ne-text" style="background-color: #FBDE28">初始状态</span></li></ol><p id="u10e133f3" class="ne-p"><span class="ne-text">第一项默认填充一个完整的abc</span></p><pre><code><code>function addMinimum(word: string): number &#123;  const n = word.length;  const arr = new Array(n + 1).fill(0);  for (let i = 1; i &lt;= n; i++)     arr[i] = i &gt; 1 &amp;&amp; word[i - 2] &lt; word[i - 1] ? arr[i - 1] - 1 : arr[i - 1] + 2  return arr[n]&#125;;</code></code></pre><h3 id="kXkn9"><span class="ne-text">穷举算法</span></h3><pre><code><code>function addMinimum(word: string): number &#123;  if (!word.replaceAll('abc', '').length) return 0  let count = 0;  for (let i = 0; i &lt; word.length; i++) &#123;    const curr = word[i]    const next = i + 1 !== word.length ? word[i + 1] : null    if (i === 0) &#123;      if (curr === 'b') &#123;        count = count + 1      &#125; else if (curr === 'c') &#123;        count = count + 2      &#125;    &#125;    if (next) &#123;      if (curr === 'a') &#123;        if (next === 'a')&#123;          count = count + 2        &#125; else if (next === 'c') &#123;          count = count + 1        &#125;      &#125; else if (curr === 'b') &#123;        if (next === 'a')&#123;          count = count + 1        &#125; else if (next === 'b') &#123;          count = count + 2        &#125;       &#125; else if (curr === 'c') &#123;        if (next === 'b') &#123;          count = count + 1        &#125; else if (next === 'c') &#123;          count = count + 2        &#125;      &#125;    &#125; else &#123;      if (curr === 'b') &#123;        count = count + 1      &#125; else if (curr === 'a') &#123;        count = count + 2      &#125;    &#125;  &#125;  return count&#125;;</code></code></pre></div>]]></content:encoded>
      
      
      <category domain="https://www.wztlink1013.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B4%A0%E5%85%BB/">计算机素养</category>
      
      <category domain="https://www.wztlink1013.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B4%A0%E5%85%BB/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</category>
      
      <category domain="https://www.wztlink1013.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B4%A0%E5%85%BB/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%F0%9F%94%A2%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AE%97%E6%B3%95/">🔢动态规划算法</category>
      
      
      
      <comments>https://www.wztlink1013.com/blog/lk1vbtcuw7ox57do/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>React系统学习（三）组件通信</title>
      <link>https://www.wztlink1013.com/blog/ugugf75zazxyxy8t/</link>
      <guid>https://www.wztlink1013.com/blog/ugugf75zazxyxy8t/</guid>
      <pubDate>Tue, 02 Jan 2024 16:35:41 GMT</pubDate>
      
        
        
          
          
      <description>&lt;!doctype html&gt;&lt;div class=&quot;lake-content&quot; typography=&quot;classic&quot;&gt;&lt;h3 id=&quot;Hp11O&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;父传子（Props）&lt;/span&gt;&lt;/h3&gt;&lt;p id=&quot;u33a79e2b&quot;</description>
          
        
      
      
      
      <content:encoded><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h3 id="Hp11O"><span class="ne-text">父传子（Props）</span></h3><p id="u33a79e2b" class="ne-p"><span class="ne-text">利用props传值</span></p><ol class="ne-ol"><li id="u1fc1373b" data-lake-index-type="0"><span class="ne-text">组件默认值的写法</span></li></ol><ol start="2" class="ne-ol"><li id="u65cf9e83" data-lake-index-type="0"><span class="ne-text">点标记写法就相当于组件作为一个对象值</span></li></ol><pre><code><code>const Son = (props: any) =&gt; &#123;  console.log('parent to son: ', props);  return &lt;div&gt;son&lt;/div&gt;;&#125;;// Son default propsSon.defaultProps = &#123;  msg: 'son-default-msg',&#125;;<p>export default () =&gt; &#123;<br>  const [parentMsg, setParentMsg] = useState(‘parent-msg’);<br>  return (<br>    &lt;&gt;<br>      &lt;h1&gt;react-message&lt;/h1&gt;<br>      parent<br>      &lt;Son msg=&#123;parentMsg&#125; /&gt;<br>    &lt;/&gt;<br>  );<br>&#125;;<br></code><br></code></pre></p><h3 id="hSjM1"><span class="ne-text">子传父</span></h3><p id="u10d5d71a" class="ne-p"><span class="ne-text"> 在父组件定义响应式变量，同时传递一个回调函数参数给子组件，子组件再利用调用回调函数给便父组件所定义的响应式变量</span></p><pre><code><code>const Son = (props: any) =&gt; &#123;  console.log('parent to son: ', props.msg);  const sonToParentClick = () =&gt; &#123;    props.getSonValue('son-to-parent-msg');  &#125;;  return (    &lt;div&gt;      son&lt;button onClick=&#123;sonToParentClick&#125;&gt;son-to-parent&lt;/button&gt;    &lt;/div&gt;  );&#125;;Son.defaultProps = &#123;  msg: 'son-default-msg',&#125;;<p>export default () =&gt; &#123;<br>  const [parentToSonMsg, setParentToSonMsg] = useState(‘parent-to-son-msg’);<br>  const [getSonMsg, setGetSonMsg] = useState(‘’);<br>  const getSonValue = (msg: string) =&gt; &#123;<br>    console.log(‘son-to-parent-msg: ‘, msg);<br>    setGetSonMsg(msg);<br>  &#125;;<br>  return (<br>    &lt;&gt;<br>      &lt;h1&gt;react-message&lt;/h1&gt;<br>      parent<br>      &lt;Son msg=&#123;parentToSonMsg&#125; getSonValue=&#123;getSonValue&#125; /&gt;<br>    &lt;/&gt;<br>  );<br>&#125;;<br></code><br></code></pre></p><h3 id="C0st3"><span class="ne-text">爷传后代</span></h3><h4 id="XjAnb"><span class="ne-text">爷传孙</span></h4><ol class="ne-ol"><li id="u2c9e1c20" data-lake-index-type="0"><span class="ne-text">第一种方式就是利用剩余参数爷传子，子再传孙，不过这种方式繁琐且不便维护</span></li><li id="ub393f0aa" data-lake-index-type="0"><span class="ne-text">利用下面的透传方式</span></li></ol><h4 id="NgI5A"><span class="ne-text">透传（Context）</span></h4><pre><code><code>import &#123; createContext &#125; from 'react';<p>const Context = createContext(&#123;&#125;);</p><p>const Son = (props: any) =&gt; &#123;<br>  console.log(‘parent to son: ‘, props.msg);<br>  const sonToParentClick = () =&gt; &#123;<br>    props.getSonValue(‘son-to-parent-msg’);<br>  &#125;;<br>  return (<br>    &lt;&gt;<br>      &lt;div&gt;<br>        son&lt;button onClick=&#123;sonToParentClick&#125;&gt;son-to-parent&lt;/button&gt;<br>      &lt;/div&gt;<br>      &lt;GradeSon /&gt;<br>    &lt;/&gt;<br>  );<br>&#125;;<br>Son.defaultProps = &#123;<br>  msg: ‘son-default-msg’,<br>&#125;;</p><p>const GradeSon = () =&gt; &#123;<br>  const getGrandFather = useContext(Context);<br>  console.log(‘get-grand-father: ‘, getGrandFather);<br>  return &lt;div&gt;GradeSon&lt;/div&gt;;<br>&#125;;</p><p>export default () =&gt; &#123;<br>  const [parentToSonMsg, setParentToSonMsg] = useState(‘parent-to-son-msg’);<br>  const [parentToGradeSonMsg, setParentToGradeSonMsg] = useState(&#123; a: 11, b: 22 &#125;);<br>  const [getSonMsg, setGetSonMsg] = useState(‘’);<br>  const getSonValue = (msg: string) =&gt; &#123;<br>    console.log(‘son-to-parent-msg: ‘, msg);<br>    setGetSonMsg(msg);<br>  &#125;;<br>  return (<br>    &lt;Context.Provider value=&#123;parentToGradeSonMsg&#125;&gt;<br>      &lt;h1&gt;react-message&lt;/h1&gt;<br>      parent<br>      &lt;Son msg=&#123;parentToSonMsg&#125; getSonValue=&#123;getSonValue&#125; /&gt;<br>    &lt;/Context.Provider&gt;<br>  );<br>&#125;;<br></code><br></code></pre></p><h3 id="kPf70"><span class="ne-text">EventBus</span></h3><p id="u56c51230" class="ne-p"><span class="ne-text">事件总线的方式，其实这属于前端通用的一种设计模式，在线编辑器常用的一种代码设计模式</span></p><ol class="ne-ol"><li id="ue47632f0" data-lake-index-type="0"><span class="ne-text">事件封装：只封装了on、emit、off事件，实际上封装形式不一，也可以使用三方库等</span></li></ol><pre><code><code>type StringKeyOf&lt;T&gt; = Extract&lt;keyof T, string&gt;;type CallbackType&lt;  T extends Record&lt;string, any&gt;,  EventName extends StringKeyOf&lt;T&gt;,&gt; = T[EventName] extends any[] ? T[EventName] : [T[EventName]];type CallbackFunction&lt;T extends Record&lt;string, any&gt;, EventName extends StringKeyOf&lt;T&gt;&gt; = (  ...props: CallbackType&lt;T, EventName&gt;) =&gt; any;<p>export class EventEmitter&lt;T extends Record&lt;string, any&gt;&gt; &#123;<br>  private callbacks: &#123; [key: string]: Function[] &#125; = &#123;&#125;;</p><p>  public on&lt;EventName extends StringKeyOf&lt;T&gt;&gt;(<br>    event: EventName,<br>    fn: CallbackFunction&lt;T, EventName&gt;,<br>  ): this &#123;<br>    if (!this.callbacks[event]) &#123;<br>      this.callbacks[event] = [];<br>    &#125;</p><pre><code>this.callbacks[event].push(fn);return this;</code></pre><p>  }</p><p>  public emit&lt;EventName extends StringKeyOf&lt;T&gt;&gt;(<br>    event: EventName,<br>    …args: CallbackType&lt;T, EventName&gt;<br>  ): this {<br>    const callbacks = this.callbacks[event];</p><pre><code>if (callbacks) &#123;  callbacks.forEach(callback =&amp;gt; callback.apply(this, args));&#125;return this;</code></pre><p>  }</p><p>  public off&lt;EventName extends StringKeyOf&lt;T&gt;&gt;(<br>    event: EventName,<br>    fn?: CallbackFunction&lt;T, EventName&gt;,<br>  ): this {<br>    const callbacks = this.callbacks[event];</p><pre><code>if (callbacks) &#123;  if (fn) &#123;    this.callbacks[event] = callbacks.filter(callback =&amp;gt; callback !== fn);  &#125; else &#123;    delete this.callbacks[event];  &#125;&#125;return this;</code></pre><p>  }</p><p>  protected removeAllListeners(): void {<br>    this.callbacks = {};<br>  }<br>}</p><p>const EventBus = new EventEmitter();<br>export default EventBus;</code><br></code></pre></p><ol start="2" class="ne-ol"><li id="uc993bf4f" data-lake-index-type="0"><span class="ne-text">使用</span></li></ol><ol class="ne-list-wrap"><ol ne-level="1" class="ne-ol"><li id="uaaccabd0" data-lake-index-type="0"><span class="ne-text">Daughter组件定义，Son组件触发</span></li><li id="u16a192b3" data-lake-index-type="0"><span class="ne-text">有注册就要有注销，不然内存中会出现重复事件逻辑多次执行的问题</span></li></ol></ol><pre><code><code>import &#123; createContext &#125; from 'react';import EventBus from '@/utils/eventEmitter';<p>const Context = createContext(&#123;&#125;);</p><p>const Son = (props: any) =&gt; &#123;<br>  console.log(‘parent to son: ‘, props.msg);<br>  const sonToParentClick = () =&gt; &#123;<br>    props.getSonValue(‘son-to-parent-msg’);<br>    EventBus.emit(‘daughterEvent’, &#123;<br>      msg: ‘son-to-daughter-msg’,<br>    &#125;);<br>  &#125;;<br>  return (<br>    &lt;&gt;<br>      &lt;div&gt;<br>        son&lt;button onClick=&#123;sonToParentClick&#125;&gt;son-to-parent&lt;/button&gt;<br>      &lt;/div&gt;<br>      &lt;GradeSon /&gt;<br>    &lt;/&gt;<br>  );<br>&#125;;<br>Son.defaultProps = &#123;<br>  msg: ‘son-default-msg’,<br>&#125;;</p><p>const Daughter = () =&gt; &#123;<br>  useEffect(() =&gt; &#123;<br>    function daughterEvent(data: any) &#123;<br>      console.warn(‘daughter event: ‘, data);<br>    &#125;<br>    EventBus.on(‘daughterEvent’, daughterEvent);<br>    return () =&gt; &#123;<br>      EventBus.off(‘daughterEvent’, daughterEvent);<br>    &#125;;<br>  &#125;, []);<br>  return &lt;div&gt;Daughter&lt;/div&gt;;<br>&#125;;</p><p>const GradeSon = () =&gt; &#123;<br>  const getGrandFather = useContext(Context);<br>  console.log(‘get-grand-father: ‘, getGrandFather);<br>  return &lt;div&gt;GradeSon&lt;/div&gt;;<br>&#125;;</p><p>export default () =&gt; &#123;<br>  const [parentToSonMsg, setParentToSonMsg] = useState(‘parent-to-son-msg’);<br>  const [parentToGradeSonMsg, setParentToGradeSonMsg] = useState(&#123; a: 11, b: 22 &#125;);<br>  const [getSonMsg, setGetSonMsg] = useState(‘’);<br>  const getSonValue = (msg: string) =&gt; &#123;<br>    console.log(‘son-to-parent-msg: ‘, msg);<br>    setGetSonMsg(msg);<br>  &#125;;<br>  return (<br>    &lt;&gt;<br>      &lt;Context.Provider value=&#123;parentToGradeSonMsg&#125;&gt;<br>        &lt;h1&gt;react-message&lt;/h1&gt;<br>        parent<br>        &lt;Son msg=&#123;parentToSonMsg&#125; getSonValue=&#123;getSonValue&#125; /&gt;<br>      &lt;/Context.Provider&gt;<br>      &lt;Daughter /&gt;<br>    &lt;/&gt;<br>  );<br>&#125;;<br></code><br></code></pre></p><h3 id="DYES7"><span class="ne-text">状态管理</span></h3><p id="u2c679f4e" class="ne-p"><span class="ne-text">状态管理所定义的Module变化，所使用到的组件也会响应式更新，不做详细记录。</span></p></div>]]></content:encoded>
      
      
      <category domain="https://www.wztlink1013.com/categories/Web%E5%BC%80%E5%8F%91/">Web开发</category>
      
      <category domain="https://www.wztlink1013.com/categories/Web%E5%BC%80%E5%8F%91/React/">React</category>
      
      
      
      <comments>https://www.wztlink1013.com/blog/ugugf75zazxyxy8t/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>React系统学习（二）生态链</title>
      <link>https://www.wztlink1013.com/blog/okaxuuoq9kqk5hv3/</link>
      <guid>https://www.wztlink1013.com/blog/okaxuuoq9kqk5hv3/</guid>
      <pubDate>Mon, 01 Jan 2024 22:34:41 GMT</pubDate>
      
        
        
          
          
      <description>&lt;!doctype html&gt;&lt;div class=&quot;lake-content&quot; typography=&quot;classic&quot;&gt;&lt;p id=&quot;uf81223da&quot; class=&quot;ne-p&quot;&gt;&lt;span</description>
          
        
      
      
      
      <content:encoded><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="uf81223da" class="ne-p"><span class="ne-text">生态系统有服务端渲染等，暂只对路由以及状态管理做部分记录。</span></p><h3 id="RG1RA"><span class="ne-text">路由Router</span></h3><ol class="ne-ol"><li id="u8de104d9" data-lake-index-type="0"><span class="ne-text">useParams：获取动态路由的路径值</span></li><li id="u5450e7cd" data-lake-index-type="0"><span class="ne-text">&lt;NavLink /&gt;：带样式的声明式路由</span></li><li id="u4f82b40a" data-lake-index-type="0"><span class="ne-text">useNavigate：编程式路由</span></li></ol><ol class="ne-list-wrap"><ol ne-level="1" class="ne-ol"><li id="uf612b599" data-lake-index-type="0"><span class="ne-text">第一个参数：跳转路径</span></li><li id="ude9b2662" data-lake-index-type="0"><span class="ne-text">第二个参数（state）：携带信息对象</span></li></ol></ol><ol start="4" class="ne-ol"><li id="u918edaba" data-lake-index-type="0"><span class="ne-text">useLocation</span></li><li id="ue0f4492b" data-lake-index-type="0"><span class="ne-text">useSearchParams：可以结构，同useState，第二个参数同样可以设置浏览器地址栏的url params </span></li><li id="u859c95b4" data-lake-index-type="0"><span class="ne-text">lodaer：路由表的字段，路由跳转前的处理函数，支持异步，这里做调取权限查询接口等逻辑</span></li></ol><ol class="ne-list-wrap"><ol ne-level="1" class="ne-ol"><li id="ua7441b4e" data-lake-index-type="0"><span class="ne-text">如果返回值需要重定向指定url -&gt; </span><code class="ne-code"><span class="ne-text">return redirect('login')</span></code></li></ol></ol><ol start="7" class="ne-ol"><li id="u28cc1c98" data-lake-index-type="0"><span class="ne-text">meta：自定义元信息</span></li></ol><ol class="ne-list-wrap"><ol ne-level="1" class="ne-ol"><li id="u167efcc8" data-lake-index-type="0"><span class="ne-text">组件中获取元信息：matchRoutes和useLocation</span></li></ol></ol><span style="margin-left: 2em"><pre><code><code>const location = useLocation()const matchs = matchRoutes(routes, location)const meta = matchs[matchs.length - 1].route.meta</code></code></pre></span><h3 id="Cavfr"><span class="ne-text">状态管理Redux</span></h3><p id="ubbcb0f40" class="ne-p"><span class="ne-text">Redux是一个独立的状态管理的库。</span></p><ol class="ne-ol"><li id="u916db48f" data-lake-index-type="0"><span class="ne-text">react-redux：对于redux封装至更符合react理念的库</span></li></ol><ol class="ne-list-wrap"><ol ne-level="1" class="ne-ol"><li id="u056b4da4" data-lake-index-type="0"><span class="ne-text">useSelector</span></li><li id="ua86b158c" data-lake-index-type="0"><span class="ne-text">useDispatch</span></li></ol></ol><ol start="2" class="ne-ol"><li id="u7b50b918" data-lake-index-type="0"><span class="ne-text">Redux-Toolkit：</span></li></ol><ol class="ne-list-wrap"><ol ne-level="1" class="ne-ol"><li id="ucbbfbb0c" data-lake-index-type="0"><span class="ne-text">封装redux的大多数操作</span></li><li id="u4f0fc676" data-lake-index-type="0"><span class="ne-text">优化异步处理createAsyncThunk</span></li></ol></ol><ol start="3" class="ne-ol"><li id="u728fa4d6" data-lake-index-type="0"><span class="ne-text">redux-persist：数据持久化处理</span></li></ol><p id="ub8fac65f" class="ne-p"><span class="ne-text"></span></p><p id="uab0de432" class="ne-p"><span class="ne-text"></span></p><p id="u2486779b" class="ne-p"><span class="ne-text"></span></p><p id="u7573cf56" class="ne-p"><span class="ne-text"></span></p><p id="u10ec026e" class="ne-p"><span class="ne-text"></span></p><p id="u5e88c3f6" class="ne-p"><span class="ne-text"></span></p><p id="u4e1d4445" class="ne-p"><span class="ne-text"></span></p><p id="ue1c440ca" class="ne-p"><span class="ne-text"></span></p><p id="uf7d94f98" class="ne-p"><span class="ne-text"></span></p></div>]]></content:encoded>
      
      
      <category domain="https://www.wztlink1013.com/categories/Web%E5%BC%80%E5%8F%91/">Web开发</category>
      
      <category domain="https://www.wztlink1013.com/categories/Web%E5%BC%80%E5%8F%91/React/">React</category>
      
      
      
      <comments>https://www.wztlink1013.com/blog/okaxuuoq9kqk5hv3/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>React系统学习（一）类组件和函数组件</title>
      <link>https://www.wztlink1013.com/blog/wnb93ckult99ixhg/</link>
      <guid>https://www.wztlink1013.com/blog/wnb93ckult99ixhg/</guid>
      <pubDate>Sat, 23 Dec 2023 05:22:20 GMT</pubDate>
      
        
        
          
          
      <description>&lt;!doctype html&gt;&lt;div class=&quot;lake-content&quot; typography=&quot;classic&quot;&gt;&lt;div data-type=&quot;info&quot; class=&quot;ne-alert&quot;&gt;&lt;p id=&quot;u09f32c06&quot; class=&quot;ne-p&quot;&gt;&lt;span</description>
          
        
      
      
      
      <content:encoded><![CDATA[<!doctype html><div class="lake-content" typography="classic"><div data-type="info" class="ne-alert"><p id="u09f32c06" class="ne-p"><span class="ne-text">官方文档：</span><a href="https://react.docschina.org/" data-href="https://react.docschina.org/" class="ne-link"><span class="ne-text">React 官方中文文档</span></a></p></div><h3 id="xVmON"><span class="ne-text">虚拟DOM以及React挂载DOM的方式</span></h3><ol class="ne-ol"><li id="u0893e863" data-lake-index-type="0"><span class="ne-text">利用JavaScript脚本操作DOM的行为是性能损耗的大头，故产生虚拟DOM的概念。初始化在内存中得到相应的虚拟DOM树，然后将该结果一次性作用于真实DOM，逻辑层的变动导致部分视图层的改变这渲染逻辑也是经过虚拟DOM加上diff得到一次性结果然后作用于真实DOM，在这里Vue和React都是一样的。</span></li><li id="u7537df37" data-lake-index-type="0"><span class="ne-text">可以简单理解：react模块旨在完成虚拟dom的相关逻辑，react-dom模块旨在完成真实DOM和diff的处理</span></li></ol><pre><code><code>// mount containerrootReactDOM.createRoot(document.querySelector('#root'))// create VDOMconst data = React.createElement('div', &#123;&#125;, 'data')// VDOM -&gt; true DOMroot.render(data)</code></code></pre><h3 id="vL2nu"><span class="ne-text">JSX</span></h3><p id="u20bc5507" class="ne-p"><span class="ne-text">上述ReactDOM生成虚拟DOM的方式，实际编写代码不方便，于是出现了类似JSX来简化视图层的代码编写（Vue中利用Template模板来完成相同视图层的逻辑构建）</span></p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/1484158/1703514464788-2de399dc-93ec-4dec-aa38-e6b6c706f0ea.jpeg" id="iIrkc" style="display: block; width: 100%"><ol start="2" class="ne-ol"><li id="uec638825" data-lake-index-type="0"><span class="ne-text">JSX的识别要么在jsx后缀文件书写相关代码逻辑，要么利用babel工具来进行代码转义..</span></li></ol><pre><code><code>const data = (  &lt;div&gt;    content&lt;span&gt;something...&lt;/span&gt;  &lt;/div&gt;)root.render(data)</code></code></pre><ol start="3" class="ne-ol"><li id="u5676031e" data-lake-index-type="0"><span class="ne-text">模板语法：</span><code class="ne-code"><span class="ne-text">&#123;&#125;</span></code><span class="ne-text">，Vue是是</span><code class="ne-code"><span class="ne-text">&#123;&#123;&#125;&#125;</span></code></li></ol><ol class="ne-list-wrap"><ol ne-level="1" class="ne-ol"><li id="u9c91fce8" data-lake-index-type="0"><span class="ne-text">注释：</span><code class="ne-code"><span class="ne-text">&#123;/* */&#125;</span></code></li><li id="ubb6f0de2" data-lake-index-type="0"><span class="ne-text">内容可以变量、函数、JSX嵌套 ······</span></li></ol></ol><ol start="4" class="ne-ol"><li id="u77d43f1f" data-lake-index-type="0"><span class="ne-text">JSX注意事项</span></li></ol><ol class="ne-list-wrap"><ol ne-level="1" class="ne-ol"><li id="u8c6babba" data-lake-index-type="0"><span class="ne-text">严格单标签（</span><code class="ne-code"><span class="ne-text">&lt;Tab /&gt;</span></code><span class="ne-text">）</span></li><li id="ub546b2eb" data-lake-index-type="0"><span class="ne-text">标签名小写</span></li><li id="u0a3d772d" data-lake-index-type="0"><span class="ne-text">唯一根节点 -&gt; </span><code class="ne-code"><span class="ne-text">&lt;&gt;&lt;/&gt;</span></code><span class="ne-text"> 或 </span><code class="ne-code"><span class="ne-text">React.Fragment</span></code></li><li id="u3a39620f" data-lake-index-type="0"><span class="ne-text">部分HTML属性名变动：</span><code class="ne-code"><span class="ne-text">class -&gt; className</span></code><span class="ne-text">; </span><code class="ne-code"><span class="ne-text">for -&gt; htmlFor</span></code><span class="ne-text"> ······</span></li><li id="u70ef716d" data-lake-index-type="0"><span class="ne-text">多单词属性用驼峰方式书写，dataset除外</span></li></ol></ol><h3 id="E1Lfq"><span class="ne-text">理解类组件</span></h3><ol class="ne-ol"><li id="ud1f196e0" data-lake-index-type="0"><span class="ne-text">组件的概念也就是模块的拆分、抽象和复用，和Vue组件一致，React的组件编写有两种，</span><strong><span class="ne-text">类组件</span></strong><span class="ne-text">和</span><strong><span class="ne-text">函数组件</span></strong><span class="ne-text">，实际编写代码，React18函数式组件编写更为推崇，但是理解上以类组件会更好。</span></li><li id="u73a8c970" data-lake-index-type="0"><span class="ne-text">具体类组件的编写，其实就是在面向对象编程，给你一个已知类React.Component，写具体逻辑时，遵照所继承的类的一些规则来扩展业务代码。</span></li></ol><h4 id="qjAcc"><span class="ne-text">简单的父子通信</span></h4><pre><code><code>// A componentclass A extends React.Component &#123;  constructor(props) &#123;    super(props)    this.props = props  &#125;  render &#123;    this.props.getData('data')    return (      &lt;div&gt;A component &#123;this.props.info&#125; &lt;/div&gt;    )  &#125;&#125;// B componentconst getData = (data) =&gt; &#123;  // result -&gt; data&#125;const data = &lt;div&gt;content &lt;A info='something' getData=&#123;getData&#125; /&gt; &lt;/div&gt;</code></code></pre><h4 id="Mh3VX"><span class="ne-text">props相关事项</span></h4><ol class="ne-ol"><li id="u64411e8a" data-lake-index-type="0"><span class="ne-text">传入组件的参数可以用扩展运算符来传入</span></li></ol><pre><code><code>const data = &#123;  info: 'something,  getData: (data) =&gt; &#123;&#125;,&#125;const data = &lt;div&gt;&lt;A &#123;...data&#125; /&gt;&lt;/div&gt;</code></code></pre><ol start="2" class="ne-ol"><li id="u855e1be4" data-lake-index-type="0"><span class="ne-text">单独属性值为true</span></li><li id="uf093ffd6" data-lake-index-type="0"><span class="ne-text">类组件的默认值</span></li></ol><pre><code><code>// A componentclass A extends React.Component &#123;  static defaultProps = &#123;    info: 'default info',  &#125;  constructor(props) &#123;    super(props)    this.props = props  &#125;  render &#123;    this.props.getData('data')    return (      &lt;div&gt;A component &#123;this.props.info&#125; &lt;/div&gt;    )  &#125;&#125;</code></code></pre><h4 id="PV0r6"><span class="ne-text">响应式变量</span></h4><p id="uc9c5250a" class="ne-p"><span class="ne-text">前端框架必须具体的一个能力就是响应式变量的构造，以及内部实现的动态渲染，react的响应式变量就是构造类的一个私有变量state，再利用其规定指定的方法setState方法来实现响应式</span></p><pre><code><code>class A extends React.Component &#123;  state &#123;    a: 1,  &#125;  static defaultProps = &#123;    info: 'default info',  &#125;  constructor(props) &#123;    super(props)    this.props = props  &#125;  render &#123;    this.props.getData('data')    return (      &lt;div&gt;A component &#123;this.props.info&#125; &lt;/div&gt;    )  &#125;handleMethod() &#123;    this.setState(&#123; a: 2 &#125;)&#125;&#125;</code></code></pre><div data-type="info" class="ne-alert"><p id="ub5f23f2f" class="ne-p"><span class="ne-text">如果响应式的值为数组呢？</span></p></div><ol class="ne-ol"><li id="ued321890" data-lake-index-type="0"><span class="ne-text">react里面的响应式的值为不可变数据集合，比较简单的情况可以利用剩余参数来解决该问题。</span></li></ol><pre><code><code>class A extends React.Component &#123;  state =&#123;    a: [1, 2, 3]  &#125;  ···  handleMethod() &#123;    this.setState(&#123; a: [...a, 4] &#125;)  &#125;&#125;</code></code></pre><ol start="2" class="ne-ol"><li id="ubcbe280c" data-lake-index-type="0"><span class="ne-text">深拷贝</span></li></ol><p id="uee425f9f" class="ne-p"><span class="ne-text">（TODO:  应该有更好的解决方式）</span></p><h4 id="xfck5"><span class="ne-text">批处理</span></h4><p id="ufd1bdefd" class="ne-p"><span class="ne-text">响应式处理，内部会一次性收集当前变化的量，进入一个处理队列，最终得到一个最终态来进行渲染，避免状态改变多次渲染的情况。</span></p><ol class="ne-ol"><li id="u0706a769" data-lake-index-type="0"><span class="ne-text">React18之前，在一些函数执行时机下，不会进行批处理，React18之后解决了这个问题。具体有：Promise、setTimeout、原生事件下</span></li><li id="u4bc7f994" data-lake-index-type="0"><span class="ne-text">React提供了防止批处理的函数</span></li></ol><pre><code><code>class A extends React.Component &#123;  state =&#123;    a: 1  &#125;  ···  handleMethod() &#123;    ReactDOM.flushSync(() =&gt; &#123;      this.setState(&#123; a: this.state.a + 1 &#125;)      this.setState(&#123; a: this.state.a + 1 &#125;)    &#125;)    // result: run twice render method...  &#125;  render &#123;    console.info('react render.')    return (      &lt;div&gt;A component &#123;this.props.info&#125; &lt;/div&gt;    )  &#125;&#125;</code></code></pre><ol start="3" class="ne-ol"><li id="uc4f4442b" data-lake-index-type="0"><span class="ne-text">setState是一个一个异步函数，其第二个参数可以传入回调函数，以便写状态改变之后的相关业务逻辑</span></li><li id="uc0538438" data-lake-index-type="0"><span class="ne-text">如果传入setState的值是对象，那么会在响应式内部所收集变化的量里面进行覆盖，如果需要实时根据最新变化的量做逻辑处理，则需要传入一个参数为state的回调函数</span></li></ol><pre><code><code>class A extends React.Component &#123;  state =&#123;    a: 1  &#125;  ···  handleMethod() &#123;    // 1. cover state    this.setState(&#123; a: this.state.a + 1 &#125;)    this.setState(&#123; a: this.state.a + 1 &#125;)    // result: a -&gt; 2    // 2. real time state    this.setState((state) =&gt; &#123; a: this.state.a + 1 &#125;)    this.setState((state) =&gt; &#123; a: this.state.a + 1 &#125;)    // result: a -&gt; 3  &#125;&#125;</code></code></pre><h4 id="ZhZcD"><span class="ne-text">PureComponent shouldComponentUpdate</span></h4><p id="u1410dea8" class="ne-p"><span class="ne-text">下面代码，因响应式变量变化，所以会执行一次render渲染</span></p><pre><code><code>class A extends React.Component &#123;  state =&#123;    a: 1  &#125;  ···  handleMethod() &#123;    this.setState(&#123; a: 1 &#125;)  &#125;  render &#123;    console.info('react render.')    return (      &lt;div&gt;A component &#123;this.props.info&#125; &lt;/div&gt;    )  &#125;&#125;</code></code></pre><p id="u17863ce9" class="ne-p"><span class="ne-text">上面情况其实响应式的结果都是a变为1，所以从渲染结果上看其实可以优化掉该种情况的渲染，react提供的渲染优化方式有两种：</span></p><p id="u185cfd38" class="ne-p"><span class="ne-text"></span></p><ol class="ne-ol"><li id="ub05164da" data-lake-index-type="0"><span class="ne-text">PureComponent优化组件</span></li></ol><pre><code><code>class A extends React.PureComponent &#123;  ···&#125;</code></code></pre><ol start="2" class="ne-ol"><li id="u79b67ec0" data-lake-index-type="0"><span class="ne-text">shouldComponentUpdate生命周期函数</span></li></ol><pre><code><code>class A extends React.Component &#123;  state =&#123;    a: 1  &#125;  ···  shouldComponentUpdate = (nextProps, nextState) =&gt; &#123;    if (nextState.a === this.state.a)    return false // not render    return true // run render  &#125;  render &#123;    console.info('react render.')    return (      &lt;div&gt;A component &#123;this.props.info&#125; &lt;/div&gt;    )  &#125;&#125;</code></code></pre><h4 id="pQyxA"><span class="ne-text">Refs</span></h4><p id="ub19f3212" class="ne-p"><span class="ne-text">框架只是对渲染dom的前置操作做了一层封装，比如先构造虚拟dom或是渲染时机的优化等，但有些时候需要在业务代码里面直接获取dom进行操作，比如input标签的自动聚焦（focus）</span></p><ol class="ne-ol"><li id="u0cc8c58c" data-lake-index-type="0"><span class="ne-text">变量</span></li></ol><pre><code><code>// A componentclass A extends React.Component &#123;  inputRef = React.createRef()  // this.inputRef.current // -&gt; Input DOM  render &#123;    return (      &lt;div&gt;      A component        &lt;input ref=&#123;inputRef&#125; /&gt;      &lt;/div&gt;    )  &#125;&#125;</code></code></pre><ol start="2" class="ne-ol"><li id="u2a7e01e5" data-lake-index-type="0"><span class="ne-text">回调函数</span></li></ol><pre><code><code>// A componentclass A extends React.Component &#123;  inputRef = (dom) =&gt; &#123;    dom.focus()  &#125;  // this.inputRef.current // -&gt; Input DOM  render &#123;    return (      &lt;div&gt;      A component        &lt;input ref=&#123;inputRef&#125; /&gt;      &lt;/div&gt;    )  &#125;&#125;</code></code></pre><ol start="3" class="ne-ol"><li id="u4ef7dd4c" data-lake-index-type="0"><span class="ne-text">除了可以得到DOM，也可以得到类组件的实例对象</span></li></ol><pre><code><code>// A componentclass A extends React.Component &#123;···&#125;// B componentclass B extends React.Component &#123;refData = React.createRef()   render() &#123;    return &lt;div&gt;content &lt;A ref=&#123;refData&#125; /&gt; &lt;/div&gt;  &#125;&#125;</code></code></pre><h4 id="Q0460"><span class="ne-text">生命周期</span></h4><p id="u55e5dd6b" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2023/png/1484158/1703663129914-06e9fada-b622-489d-813f-9d0ed1dbba41.png" width="1511.6666065984325" id="ud7af5c92" class="ne-image"></p><h4 id="oH5uK"><span class="ne-text">组件模式：RenderProps</span></h4><pre><code><code>class A extends React.Component &#123;  state = &#123;    x: 0,    y: 0,  &#125;  constructor(props) &#123;    super(props)    this.props = props  &#125;  componentDidMount = () =&gt; &#123;    document.addEventListener('mousemove', this.move)  &#125;  componentWillUnMount = () =&gt; &#123;    document.removeEventListener('mousemove', this.move)  &#125;  move = (e) =&gt; &#123;    this.setState(&#123;      x: e.pageX,      y: e.pageY,    &#125;)  &#125;render() &#123;    return (      &lt;React.Fragment&gt;      &#123; this.props.render(this.state.x, this.state.y)&#125;      &lt;/React.Fragment&gt;    )  &#125;&#125;class B extends React.Component &#123;render() &#123;    return &lt;A render=&#123;(x, y) =&gt; &#123;      &lt;div&gt;&#123;x&#125;, &#123;y&#125;&lt;/div&gt;    &#125;&#125; /&gt;  &#125;&#125;</code></code></pre><h4 id="G0eUR"><span class="ne-text">组件模式：HOC</span></h4><p id="u7d429497" class="ne-p"><span class="ne-text">参数为组件，返回新组件</span></p><pre><code><code>function hocFun(WithComponent) &#123;  return class extends React.Component &#123;    state = &#123;      x: 0,      y: 0,    &#125;    componentDidMount = () =&gt; &#123;      document.addEventListener('mousemove', this.move)    &#125;    componentWillUnMount = () =&gt; &#123;      document.removeEventListener('mousemove', this.move)    &#125;    move = (e) =&gt; &#123;      this.setState(&#123;        x: e.pageX,        y: e.pageY,      &#125;)    &#125;      render() &#123;      return &lt;WithComponent &#123;...this.state&#125; /&gt;    &#125;  &#125;&#125;class A extends React.Component &#123;  render() &#123;    return (      &lt;div&gt;          &#123;this.props.x&#125;, &#123;this.props.y&#125;      &lt;/div&gt;    )  &#125;&#125;const C = hocFun(A)class B extends React.Component &#123;    render() &#123;    return &lt;C /&gt;  &#125;&#125;</code></code></pre><h4 id="L9n58"><span class="ne-text">Context通信</span></h4><pre><code><code>const ContextData = React.createContext()<p>class A extends React.Component &#123;<br>  state = &#123;<br>    info: ‘something’<br>  &#125;<br>  render() &#123;<br>    return (<br>      A<br>      &lt;ContextData.Provider value=&#123;this.state.info&#125;&gt;<br>          &lt;B /&gt;<br>      &lt;/ContextData.Provider&gt;<br>    )<br>  &#125;<br>&#125;<br>class B extends React.Component &#123;<br>    render() &#123;<br>    return (<br>      B&lt;C /&gt;<br>    )<br>  &#125;<br>&#125;<br>class C extends React.Component &#123;<br>  static contextType = ContextData<br>  componentDidMount = () =&gt; &#123;<br>    console.lof(this.context)<br>  &#125;<br>    render() &#123;<br>    return (<br>      C<br>      &lt;ContextData.Consumer&gt;&#123; value =&gt; value &#125;&lt;/ContextData.Consumer&gt;<br>    )<br>  &#125;<br>&#125;<br>// render -&gt; ABCsomething</code><br></code></pre></p><h3 id="NZSgh"><span class="ne-text">函数组件</span></h3><h4 id="QmOfo"><span class="ne-text">useState</span></h4><p id="uc98a614a" class="ne-p"><span class="ne-text">响应式变量的声明和改变</span></p><pre><code><code>import &#123; useState &#125; from 'React'const A = () =&gt; &#123;  const [a, setA] = useState('a')  return &lt;div&gt;a value: &#123;a&#125;&lt;/div&gt;&#125;</code></code></pre><p id="u5c324387" class="ne-p"><span class="ne-text">和类组件的差异</span></p><ol class="ne-ol"><li id="u157ea2c5" data-lake-index-type="0"><span class="ne-text">改变值的时候不会merge，而是覆盖</span></li><li id="ue3b27c3a" data-lake-index-type="0"><span class="ne-text">初始值可以值回调函数，但不能是函数否则每次改变都会重新执行一遍该函数</span></li><li id="ubf97f0c2" data-lake-index-type="0"><span class="ne-text">同样存在批处理，也有防止批处理的函数</span></li></ol><pre><code><code>import &#123; useState &#125; from 'React'import &#123; flushSync &#125; from 'ReactDDOM'const A = () =&gt; &#123;  const [a, setA] = useState('a')  const [b, setB] = useState('b')  flushSync(() =&gt; &#123;    setA('aa')  &#125;)    flushSync(() =&gt; &#123;    setB('bb')  &#125;)  return &lt;div&gt;a value: &#123;a&#125;&lt;/div&gt;&#125;</code></code></pre><ol start="4" class="ne-ol"><li id="u832252b4" data-lake-index-type="0"><span class="ne-text">传入的是值，渲染前会存在覆盖情况，如果传入的是函数，则会保留上一次的状态值计算</span></li></ol><h4 id="tIoMO"><span class="ne-text">useEffect</span></h4><p id="u5ed09388" class="ne-p"><span class="ne-text">副作用Hook</span></p><ol class="ne-ol"><li id="u28b6342c" data-lake-index-type="0"><span class="ne-text">模拟各个生命周期的执行时机</span></li></ol><pre><code><code>import &#123; useState, useEffect &#125; from 'React'const A = () =&gt; &#123;  useEffect(() =&gt; &#123;    // mount || update    return () =&gt; &#123;      // beforeUpdate || unMount      // clear sider function...    &#125;  &#125;)  return &lt;div&gt;a value: &#123;a&#125;&lt;/div&gt;&#125;</code></code></pre><ol start="2" class="ne-ol"><li id="u8886765a" data-lake-index-type="0"><span class="ne-text">关于第二个数组参数</span></li></ol><ol class="ne-list-wrap"><ol ne-level="1" class="ne-ol"><li id="u29eccab1" data-lake-index-type="0"><span class="ne-text">如果不设置，那么在update时期都会执行</span></li><li id="uaa101652" data-lake-index-type="0"><span class="ne-text">如果设置空数组（且回调函数中没有响应式变量），则只在mount时期执行一次</span></li><li id="u54d7662f" data-lake-index-type="0"><span class="ne-text">如果useEffect回调函数中存在响应式变量，那么第二个参数数组中应当有该响应式变量</span></li></ol></ol><ol start="3" class="ne-ol"><li id="u22c20e06" data-lake-index-type="0"><span class="ne-text">useLayoutEffect</span></li></ol><ol class="ne-list-wrap"><ol ne-level="1" class="ne-ol"><li id="u4977ceef" data-lake-index-type="0"><span class="ne-text">useEffect：渲染并绘制到屏幕之后执行，异步</span></li><li id="u97c48e0a" data-lake-index-type="0"><span class="ne-text">useLayoutEffect：渲染之后，但绘制到屏幕之前执行，同步</span></li><li id="u95a58cbe" data-lake-index-type="0"><span class="ne-text">一般如果回调函数中有DOM的相关操作并且会改变样式，用后者，避免DOM渲染闪屏/白屏，但前者性能方面更好</span></li></ol></ol><h4 id="Y3UvK"><span class="ne-text">useRef</span></h4><ol class="ne-ol"><li id="u32714bac" data-lake-index-type="0"><span class="ne-text">作用在DOM上的回调函数，则为DOM实例</span></li></ol><pre><code><code>const A = () =&gt; &#123;  const elementFun = (dom) =&gt; &#123;    // dom -&gt; input DOM  &#125;  return &lt;div&gt;&lt;input type=&quot;text&quot; ref=&#123;elementFun&#125; /&gt;&lt;/div&gt;&#125;</code></code></pre><ol start="2" class="ne-ol"><li id="ub1ccc233" data-lake-index-type="0"><span class="ne-text">作用在DOM上且为useRef函数，则为带有键为current值为DOM本身的对象</span></li></ol><pre><code><code>import &#123; useRef &#125; from 'React'const A = () =&gt; &#123;  const obj = useRef()  // obj =&gt; &#123; current: inputDOM &#125;  return &lt;div&gt;&lt;input type=&quot;text&quot; ref=&#123;obj&#125; /&gt;&lt;/div&gt;&#125;</code></code></pre><ol start="3" class="ne-ol"><li id="ucebe1755" data-lake-index-type="0"><span class="ne-text">不可以作用在组件上，但是子组件有React.forwardRef（组件转发）可以</span></li></ol><pre><code><code>import &#123; useRef &#125; from 'React'const Son = React.forwardRef((props, ref) =&gt; &#123;  return &lt;div&gt;&lt;input type=&quot;text&quot; ref=&#123;ref&#125; /&gt;&lt;/div&gt;&#125;)const A = () =&gt; &#123;  const obj = useRef()  // obj =&gt; &#123; current: inputDOM &#125;  return &lt;Son ref=&#123;obj&#125; /&gt;&#125;</code></code></pre><ol start="4" class="ne-ol"><li id="udbc656f8" data-lake-index-type="0"><span class="ne-text">利用useRef创建的普通变量，可以具备“记忆”功能，类似于类的实例属性。利用这一点可以设置一个flag来实现组件仅更新时触发的代码执行时机</span></li></ol><pre><code><code>import &#123; useRef, useEffect &#125; from 'React'const A = () =&gt; &#123;  const obj = useRef(false)  const inputOnClick = () =&gt; &#123;    obj.current = true  &#125;  useEffect(() =&gt; &#123;    if (obj.current) &#123;      // only update -&gt; run...    &#125;  &#125;)  return &lt;div&gt;&lt;input type=&quot;text&quot; onClick=&#123;inputOnClick&#125; /&gt;&lt;/div&gt;&#125;</code></code></pre><h4 id="o3MJh"><span class="ne-text">useContext</span></h4><p id="u816841d0" class="ne-p"><span class="ne-text">跨组件通信</span></p><pre><code><code>import &#123; useContext, createContext &#125; from 'React'<p>// not Provider value -&gt; render default value<br>const C = createContext(‘default value…’)</p><p>const GSon = () =&gt; &#123;<br>  const value = useContext(C)<br>  // value -&gt; something…<br>  return &lt;div&gt;GSon template…&lt;/div&gt;<br>&#125;<br>const Son = () =&gt; &#123;<br>  return &lt;GSon /&gt;<br>&#125;</p><p>const A = () =&gt; &#123;</p><p>  return (<br>    &lt;C.Provider value=’something…’&gt;<br>        &lt;Son ref=&#123;obj&#125; /&gt;<br>    &lt;/C.Provider&gt;<br>  )<br>&#125;</code><br></code></pre></p><h4 id="Sc8WH"><span class="ne-text">memo</span></h4><p id="u8f7f8983" class="ne-p"><span class="ne-text">类似类组件中的</span><code class="ne-code"><span class="ne-text">PureComponent</span></code><span class="ne-text">性能优化组件</span></p><ol class="ne-ol"><li id="u993d2be2" data-lake-index-type="0"><span class="ne-text">函数组件中当响应变量的值没有发生改变，不会重新渲染，和类组件不一样</span></li><li id="u110c7560" data-lake-index-type="0"><span class="ne-text">当组件的值发生改变才进行render，反之不进行render</span></li></ol><pre><code><code>import &#123; useState, memo &#125; from 'React'<p>const Son = memo(() =&gt; &#123;<br>  return &lt;div&gt;son&lt;/div&gt;<br>&#125;)</p><p>// continue click -&gt; continue run ↓<br>// const Son = () =&gt; &#123;<br>//   return &lt;div&gt;son&lt;/div&gt;<br>// &#125;</p><p>const A = () =&gt; &#123;<br>  const [count, setCount] = useState(0)<br>  const clickEvent = () =&gt; &#123;<br>    setCount(1)<br>  &#125;<br>  return (<br>    &lt;div&gt;<br>        &lt;button onClick=&#123;clickEvent&#125; &gt;click&lt;/button&gt;<br>        &lt;Son count=&#123;count&#125; /&gt;<br>    &lt;/div&gt;<br>  )<br>&#125;</code><br></code></pre></p><h4 id="hEQq3"><span class="ne-text">useMemo和useCallback</span></h4><p id="u146035fb" class="ne-p"><span class="ne-text">React函数式组件在重新渲染时候，代码执行会将函数体重新执行，即便结果不是重新更新DOM。如果函数体的代码逻辑复杂会带来不小的性能损耗，如果能够对这过程中的部分“量”进行“记忆”，则会较大提升性能。</span></p><p id="u89b5266b" class="ne-p"><span class="ne-text">响应式变量内部会自动进行记忆，但是如果是非响应式变量，比如一个对象或是一个函数传入组件，这其实也是改变了的，原因是对象的引用改变，依然会引起DOM的重新渲染，而利用useMemo或是useCallback创建的对象（对象、数组、函数）则会保留记忆功能。</span></p><ol class="ne-ol"><li id="u5de4e990" data-lake-index-type="0"><span class="ne-text">useCallback：传入回调函数</span></li><li id="u618a838d" data-lake-index-type="0"><span class="ne-text">useMemo：传入一个必须带有返回值的函数</span></li><li id="u18b45d54" data-lake-index-type="0"><span class="ne-text">两者的第二个参数都是依赖数组，同useEffect</span></li></ol><pre><code><code>import &#123; useCallback, useMemo &#125; from 'React'const A = () =&gt; &#123;  // 1. every render -&gt; run  const fun = () =&gt; &#123;&#125;  // 2. useCallback (ignore const error...)  const fun = useCallback(() =&gt; &#123;&#125;, [])  // 3. useMemo (ignore const error...)  const fun = useMemo(() =&gt; () =&gt; &#123;&#125;, [])  const a = useMemo(() =&gt; [1, 2, 3], [])  <p>  return &lt;div onClick=&#123;fun&#125; a=&#123;a&#125;&gt;&lt;/div&gt;<br>&#125;</code><br></code></pre></p><h4 id="zUHaR"><span class="ne-text">useReducer</span></h4><p id="u76ab5b03" class="ne-p"><span class="ne-text">管理多个有关联的响应式变量</span></p><pre><code><code>import &#123; useReducer &#125; from 'React<p>const loginState = &#123; isLogin: true, isLogout: false &#125;<br>const loginReducer = (state, action) =&gt; &#123;<br>  switch(action.type) &#123;<br>    case ‘login’:<br>      return &#123; isLogin: true, isLogout: false &#125;<br>    case ‘logout’:<br>      return &#123; isLogin: false, isLogout: true &#125;<br>    default:<br>      return new Error()<br>  &#125;<br>&#125;</p><p>const A = () =&gt; &#123;<br>  const [state, LoginDispatch] = useReducer(loginReducer, loginState)<br>  const clickEvent = () =&gt; &#123;<br>    loginDispatch(&#123; type: state.isLogin ? ‘logout’ : ‘login’ &#125;)<br>  &#125;</p><p>  return (<br>    &lt;button onClick=&#123;clickEvent&#125;&gt;&#123;state.isLogin ? ‘login’, ‘logout’&#125;&lt;/button&gt;<br>  )<br>&#125;</code><br></code></pre></p><h4 id="ZHgiq"><span class="ne-text">并发模式</span></h4><ol class="ne-ol"><li id="uf47bf115" data-lake-index-type="0"><span class="ne-text">React18之前，渲染是一个单一的、不间断的、同步的事务，一旦渲染开始，就不能被中断</span></li><li id="ufee7a81a" data-lake-index-type="0"><span class="ne-text">React18引入并发模式，它允许你将更新作为一个transitions，这会告诉React他们可以被中断执行。这样可以把紧急的任务先更新你，不紧急的任务后更新</span></li></ol><h4 id="SV5XT"><span class="ne-text">startTransition</span></h4><pre><code><code>import &#123; startTransition &#125; from 'React'const A = () =&gt; &#123;  ...  const fun = () =&gt; &#123;    // 紧急任务    setA('')    // 不紧急任务（将内部的任何非紧急状态更新标记为 Transition）    startTransition(() =&gt; setB(''))  &#125;  return &lt;div&gt;&lt;/div&gt;&#125;</code></code></pre><h4 id="LHIKS"><span class="ne-text">useTransition和useDeferredValue</span></h4><ol class="ne-ol"><li id="ubb651c66" data-lake-index-type="0"><span class="ne-text">useTransition返回一个状态值表示过渡任务的等待状态，以及一个启动该过渡任务的函数</span></li></ol><pre><code><code>import &#123; useTransition &#125; from 'React'const A = () =&gt; &#123;  ...  const [pending, startTransition] = useTransition()  const fun = () =&gt; &#123;    // 紧急任务    setA('')    // 不紧急任务（将内部的任何非紧急状态更新标记为 Transition）    startTransition(() =&gt; setB(''))  &#125;  return &lt;div&gt;&lt;/div&gt;&#125;</code></code></pre><ol start="2" class="ne-ol"><li id="u279291ea" data-lake-index-type="0"><span class="ne-text">useDeferredValue接受一个值，并返回该值的新副本，该副本将推迟到更紧急地更新之后</span></li></ol><pre><code><code>import &#123; useDeferredValue, useState &#125; from 'React'const A = () =&gt; &#123;  const [a, setA] = useState('')  // aD =&gt; 不紧急时候的值（同a），也就是延迟之后的值  const aD = useDeferredValue(a)  ...  return &lt;div&gt;&lt;/div&gt;&#125;</code></code></pre><h4 id="FnTQp"><span class="ne-text">自定义hook</span></h4><ol class="ne-ol"><li id="ue75e76dd" data-lake-index-type="0"><span class="ne-text">命名通常使用use开头</span></li><li id="u2bce0e3e" data-lake-index-type="0"><span class="ne-text"></span></li></ol><pre><code><code>import &#123; useState, useEffect &#125; from 'React'<p>const useMouseXY = () =&gt; &#123;<br>  const [x, setX] = usestate(0)<br>  const [y, setY] = usestate(0)</p><p>  useEffect(() =&gt; &#123;<br>    function move(e) &#123;<br>      setX(e.pageX)<br>      setY(e.pageY)<br>    &#125;<br>    document.addEventListener(‘mousemove’, move)<br>    return () =&gt; document.removeEventListener(‘mousemove’, move)<br>  &#125;, [])</p><p>  return &#123; x, y &#125;<br>&#125;</p><p>// use<br>const &#123; x, y &#125; = useMouseXY()</code><br></code></pre></p><h4 id="JPBEq"><span class="ne-text">lazy</span></h4><p id="udc1f9642" class="ne-p"><span class="ne-text">当模块化引入（import）组件，但在实际代码中未使用到，代码内部逻辑仍会执行，这个时候可以利用lazy使组件异步化加载，从而达到性能优化效果</span></p><pre><code><code>import &#123; lazy &#125; from 'react';<p>const AuthRoute = lazy(() =&gt; import(‘./AuthRoute’));<br>const ErrorPage = lazy(() =&gt; import(‘@/components/ErrorBoundary’));<br>const NotFound = lazy(() =&gt; import(‘@/pages/404’));</code><br></code></pre></p><h4 id="zYL5T"><span class="ne-text">Suspense</span></h4><p id="ueed27788" class="ne-p"><span class="ne-text">组件加载中或是切换过程中的“中间态”</span></p><pre><code><code>import &#123; Suspense, useState &#125; from 'react';import &#123; RouterProvider &#125; from 'react-router-dom';import router from '@/router/index';import Loading from '@/components/Loading';<p>function MyApp() &#123;<br>  const [show, setShow] = useState(true)<br>  const clickEvent = () =&gt; setShow(!show)<br>  return (<br>    &lt;&gt;<br>      &lt;button onClick=&#123;clickEvent&#125;&gt;btn&lt;/button&gt;<br>      &lt;Suspense fallback=&#123;&lt;Loading /&gt;&#125;&gt;<br>        &#123;show ? &lt;RouterProvider router=&#123;router&#125; /&gt; : &lt;&gt;other template&lt;/&gt;&#125;<br>      &lt;/Suspense&gt;<br>    &lt;/&gt;<br>  );<br>&#125;</p><p>export default MyApp;</code><br></code></pre></p><p id="ud8c681f0" class="ne-p"><span class="ne-text">结合startTransition使用：</span></p><p id="uad00f696" class="ne-p"><span class="ne-text">如果需要切换过程中不展示loading的加载态，则将上述代码中的切换逻辑转为并发异步即可</span></p><pre><code><code>const clickEvent = () =&gt; startTransition(() =&gt; setShow(!show))</code></code></pre><h4 id="vA6LY"><span class="ne-text">错误边界捕获</span></h4><p id="uce23988c" class="ne-p"><span class="ne-text">如果编写的组件内部报错，那么react渲染会清除根节点DOM，React官方文档暂时只有类组件编写的示例代码。其核心逻辑在类组件上支持关键的生命周期方法getDerivedStateFromError()和componentDidCatch()，无法将错误边界编写为函数式组件，同时以下几种错误情况，也捕获不到：</span></p><ol class="ne-ol"><li id="u153d38e4" data-lake-index-type="0"><span class="ne-text">异步代码</span></li><li id="u5764c7ba" data-lake-index-type="0"><span class="ne-text">事件处理函数</span></li><li id="ubdf3f9b1" data-lake-index-type="0"><span class="ne-text">服务器组件</span></li><li id="uae94c9a5" data-lake-index-type="0"><span class="ne-text">Error Boundary自身</span></li></ol><p id="u01d1627d" class="ne-p"><span class="ne-text">具体的完整封装 TODO: </span></p><h3 id="RG1RA"><span class="ne-text">ReactDOM</span></h3><h4 id="xAPZX"><span class="ne-text">createPortal</span></h4><ol class="ne-ol"><li id="u729bc8ae" data-lake-index-type="0"><span class="ne-text">可以指定节点挂载到指定目标DOM节点</span></li></ol><pre><code><code>// templateconst A = () =&gt; ReactDOM.createPortal(&lt;div&gt;info&lt;/div&gt;, document.body)</code></code></pre><ol start="2" class="ne-ol"><li id="u21e16b5d" data-lake-index-type="0"><span class="ne-text">对于一些全局组件（message），DOM的挂在可能不在root根节点内，自定义挂在指定DOM节点，除了上述createPortal方式，还有react的createRoot方式</span></li></ol></div>]]></content:encoded>
      
      
      <category domain="https://www.wztlink1013.com/categories/Web%E5%BC%80%E5%8F%91/">Web开发</category>
      
      <category domain="https://www.wztlink1013.com/categories/Web%E5%BC%80%E5%8F%91/React/">React</category>
      
      
      
      <comments>https://www.wztlink1013.com/blog/wnb93ckult99ixhg/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>TypeScript系统学习</title>
      <link>https://www.wztlink1013.com/blog/torv9p4z2b79494z/</link>
      <guid>https://www.wztlink1013.com/blog/torv9p4z2b79494z/</guid>
      <pubDate>Sat, 23 Dec 2023 00:10:27 GMT</pubDate>
      
        
        
          
          
      <description>&lt;!doctype html&gt;&lt;div class=&quot;lake-content&quot; typography=&quot;classic&quot;&gt;&lt;h4 id=&quot;DMAyy&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;基础使用&lt;/span&gt;&lt;/h4&gt;&lt;ol class=&quot;ne-ol&quot;&gt;&lt;li</description>
          
        
      
      
      
      <content:encoded><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h4 id="DMAyy"><span class="ne-text">基础使用</span></h4><ol class="ne-ol"><li id="u662263d7" data-lake-index-type="0"><span class="ne-text">既是变量声明空间，也是类型声明空间</span></li><li id="u0d4282f1" data-lake-index-type="0"><span class="ne-text">类型分类：</span></li></ol><ol class="ne-list-wrap"><ol ne-level="1" class="ne-ol"><li id="u42e9bb1d" data-lake-index-type="0"><span class="ne-text">基本类型：也就是JavaScript中的七种基本类型</span></li><li id="u717293e5" data-lake-index-type="0"><span class="ne-text">对象类型：对象、数组、函数</span></li><li id="u7cfbb6db" data-lake-index-type="0"><span class="ne-text">typescript新增类型：any, never, void, unknown, enum</span></li></ol></ol><ol start="3" class="ne-ol"><li id="u8b1c9efb" data-lake-index-type="0"><span class="ne-text">联合类型和交叉类型：类型间的或跟与</span></li><li id="u61315403" data-lake-index-type="0"><span class="ne-text">断言（as）非空断言（!.）</span></li><li id="u13adc4e0" data-lake-index-type="0"><span class="ne-text">数组类型定义：type[]，Array&lt;string&gt;</span></li><li id="ua418feb9" data-lake-index-type="0"><span class="ne-text">元组类型定义：形式上类似JavaScript中的解构赋值</span></li></ol><span style="margin-left: 2em"><pre><code><code>let arr: [number, string] = [1, 'str'];arr[2] = 'test'; // ts error</code></code></pre></span><ol start="7" class="ne-ol"><li id="ub2d7406e" data-lake-index-type="0"><span class="ne-text">索引签名：</span></li></ol><ol class="ne-list-wrap"><ol ne-level="1" class="ne-ol"><li id="uabde14d8" data-lake-index-type="0"><span class="ne-text">比如后端返回的数据，字段不可能枚举完全</span></li></ol></ol><span style="margin-left: 2em"><pre><code><code>type ObjType = &#123;  a: string  b: number  [index: string]: any&#125;const obj: ObjType = &#123;  a: '11',  b: 22,  c: false,&#125;</code></code></pre></span><ol class="ne-list-wrap"><ol start="2" ne-level="1" class="ne-ol"><li id="u88d48f1f" data-lake-index-type="0"><span class="ne-text">也可以给数组设置类型</span></li></ol></ol><span style="margin-left: 2em"><pre><code><code>type ArrayType = &#123;  [index: number]: any&#125;const arr: ArrayType = ['111', 222, false]</code></code></pre></span><ol start="8" class="ne-ol"><li id="ubdb9547b" data-lake-index-type="0"><span class="ne-text">函数重载和可调用注解</span></li></ol><span style="margin-left: 2em"><pre><code><code>type FunType = &#123;  (n: number): number  key?: string&#125;let fun: FunType = (n) =&gt; nfun.key = 'test'</code></code></pre></span><ol start="9" class="ne-ol"><li id="u854e2d24" data-lake-index-type="0"><span class="ne-text">枚举类型（enum）：自定义枚举变量，优化代码可读性，其本质也是一个包装的JavaScript对象</span></li><li id="u339c427d" data-lake-index-type="0"><span class="ne-text">一般在交叉类型的具体内部逻辑中，需要判断实际变量所属类型，利用利用typeof、instanceof、in或是字面量类型来进行判断</span></li></ol><h4 id="EfHth"><span class="ne-text">接口</span></h4><ul class="ne-ul"><li id="u6f775147" data-lake-index-type="0"><span class="ne-text">接口和类型的差异</span></li></ul><ol class="ne-list-wrap"><ol ne-level="1" class="ne-ol"><li id="ua06d3aa0" data-lake-index-type="0"><span class="ne-text">接口的目标只能用在对象当中</span></li><li id="u5e246c5a" data-lake-index-type="0"><span class="ne-text">接口可以合并</span></li><li id="u3cc008e6" data-lake-index-type="0"><span class="ne-text">接口具备继承能力（和Java抽象类差不多）</span></li><li id="u18ff22ec" data-lake-index-type="0"><span class="ne-text">接口不能映射</span></li></ol></ol><h4 id="WiFCE"><span class="ne-text">字面量类型 keyof typeof</span></h4><ul class="ne-ul"><li id="u65329c6c" data-lake-index-type="0"><span class="ne-text">type的值可以直接存储为一种类型，比如h标签的所有类型值</span></li></ul><pre><code><code>type HTYPE = 'h1' | 'h2' | 'h3' | 'h4' | 'h5' | 'h6' |</code></code></pre><ul class="ne-ul"><li id="u9da9f0e8" data-lake-index-type="0"><span class="ne-text">keyof可以获取一个对象类型的所有关键字</span></li></ul><pre><code><code>interface A &#123;  a: string;  b: number&#125;const v: keyof A = // 'a' | 'b'</code></code></pre><pre><code><code>const obj = &#123;  a: '111',  b: 222,&#125;const v: keyof typeof obj = // 'a' | 'b'</code></code></pre><h4 id="P07Tb"><span class="ne-text">泛型</span></h4><ol class="ne-ol"><li id="u5f9ef2bc" data-lake-index-type="0"><span class="ne-text">函数和接口结合使用</span></li></ol><pre><code><code>interface A&lt;T&gt; &#123;  (n?: T): n  default?: T&#125;<p>const fun1: A&lt;string&gt; = (n) =&gt; n</p><p>fun1(‘111’)<br>fun1.default = ‘222’</code><br></code></pre></p><ol start="2" class="ne-ol"><li id="uc2890d23" data-lake-index-type="0"><span class="ne-text">类（class）中使用</span></li></ol><pre><code><code>class A&lt;T&gt; &#123;  public n!: T&#125;<p>const instance = new A&lt;string&gt;()<br>instance.n = ‘111’</code><br></code></pre></p><ol start="3" class="ne-ol"><li id="u425efa73" data-lake-index-type="0"><span class="ne-text">泛型约束</span></li></ol><p id="ufbcaea02" class="ne-p"><span class="ne-text">很多时候，泛型的“T”是已经知道的集中范围内的，就可以对泛型加以约束（extends）</span></p><pre><code><code>type I = string<p>class A&lt;T extends I&gt; &#123;<br>  public n!: T<br>&#125;</p><p>const instance = new A&lt;string&gt;()<br>instance.n = ‘111’</code><br></code></pre></p><h4 id="pUon2"><span class="ne-text">类</span></h4><ol class="ne-ol"><li id="u3d088ef4" data-lake-index-type="0"><span class="ne-text">接口（implements）</span></li></ol><pre><code><code>interface A &#123;  a: string  b: number  fun: (c: string, d: number) =&gt; void&#125;<p>class B implements A &#123;<br>  a!: string<br>  b!: number<br>  fun: (c: string, d: number) =&gt; &#123;&#125;<br>&#125;</code><br></code></pre></p><ol start="2" class="ne-ol"><li id="u328e816a" data-lake-index-type="0"><span class="ne-text">结合泛型</span></li></ol><pre><code><code>class A&lt;T&gt; &#123;  a: T  constructor(a: T) &#123;    this.a = a  &#125;&#125;<p>new A&lt;string&gt;(‘aaa’)</code><br></code></pre></p><pre><code><code>interface A&lt;T&gt; &#123;  a: T  b: number  fun: (c: T, d: number) =&gt; void&#125;class B implements A&lt;string&gt; &#123;  a!: string  b!: number  fun: (c: string, d: number) =&gt; &#123;&#125;&#125;</code></code></pre><h4 id="Gymk9"><span class="ne-text">映射</span></h4><p id="u80a1a45b" class="ne-p"><span class="ne-text">类似于对一个已有类型的“二次开发”</span></p><ol class="ne-ol"><li id="u08291f1b" data-lake-index-type="0"><span class="ne-text">一个例子：对一个已有类型对象的值都设置为只读的</span></li></ol><pre><code><code>type A = &#123;  a: string  b: string&#125;<p>type B&lt;T&gt; = &#123;<br>  readonly [P in keyof T]: T[P]<br>&#125;</p><p>type C = B&lt;A&gt;</code><br></code></pre></p><ol start="2" class="ne-ol"><li id="ub4542434" data-lake-index-type="0"><span class="ne-text">一个例子：对于DOM自带的DOMRect类型进行二次自定义</span></li></ol><pre><code><code>/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/DOMRectReadOnly) */interface DOMRectReadOnly &#123;  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/DOMRectReadOnly/bottom) */  readonly bottom: number;  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/DOMRectReadOnly/height) */  readonly height: number;  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/DOMRectReadOnly/left) */  readonly left: number;  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/DOMRectReadOnly/right) */  readonly right: number;  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/DOMRectReadOnly/top) */  readonly top: number;  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/DOMRectReadOnly/width) */  readonly width: number;  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/DOMRectReadOnly/x) */  readonly x: number;  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/DOMRectReadOnly/y) */  readonly y: number;  toJSON(): any;&#125;/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/DOMRect) */interface DOMRect extends DOMRectReadOnly &#123;  height: number;  width: number;  x: number;  y: number;&#125;</code></code></pre><pre><code><code>// - remove assign value (-readonlu or -?)...type EditableDOMRect = &#123;  -readonly [K in keyof DOMRect]: DOMRect[K];&#125;;// EditableDOMRect === ↓type EditableDOMRect = &#123;  height: number;  width: number;  x: number;  y: number;  bottom: number;  left: number;  right: number;  top: number;  toJSON: () =&gt; any;&#125;</code></code></pre><h4 id="EXNeJ"><span class="ne-text">条件类型 infer</span></h4><pre><code><code>type C = A extends B ? &#123;&#125; : []type Exclude&lt;T, U&gt; = T extends U ? never : T</code></code></pre><h4 id="OW0TC"><span class="ne-text">内置工具类型</span></h4><p id="uc0bd97b2" class="ne-p"><span class="ne-text">typescript内置部分类型（具体可以利用编辑器转到定义处查看）</span></p><p id="ue6815fcd" class="ne-p"><span class="ne-text">比如完成上述映射第一个例子可以写成</span></p><pre><code><code>type D = Readonly&lt;A&gt;</code></code></pre><p id="u1558878f" class="ne-p"><span class="ne-text">常用的如下：</span></p><table id="JMQIq" class="ne-table" style="width: 636px"><tbody><tr style="height: 33px"><td width="318"><p id="u0db44a55" class="ne-p"><span class="ne-text">Partial</span></p></td><td width="318"><ul class="ne-ul"><li id="u0de61c6b" data-lake-index-type="0"><span class="ne-text">可选</span></li></ul><pre><code><code>type B = Partial&lt;A&gt;</code></code></pre></td></tr><tr style="height: 33px"><td width="318"><p id="u9624db74" class="ne-p"><span class="ne-text">Readonly</span></p></td><td width="318"><ul class="ne-ul"><li id="u292ea66d" data-lake-index-type="0"><span class="ne-text">只读</span></li></ul><pre><code><code>type B = Readonly&lt;A&gt;</code></code></pre></td></tr><tr style="height: 33px"><td width="318"><p id="u31f84b39" class="ne-p"><span class="ne-text">Pick</span></p></td><td width="318"><ul class="ne-ul"><li id="uacea44be" data-lake-index-type="0"><span class="ne-text">筛选指定项</span></li></ul><pre><code><code>type B = Pick&lt;A, 'a' | 'b'&gt;</code></code></pre></td></tr><tr style="height: 33px"><td width="318"><p id="u3ee0494b" class="ne-p"><span class="ne-text">Record</span></p></td><td width="318"><ul class="ne-ul"><li id="u9efccf89" data-lake-index-type="0"><span class="ne-text">指定字段为指定类型</span></li></ul><pre><code><code>type A = Record&lt;'a' | 'b', string&gt;type A = Record&lt;keyof C, string&gt;</code></code></pre></td></tr><tr style="height: 33px"><td width="318"><p id="u67a37fee" class="ne-p"><span class="ne-text">Required</span></p></td><td width="318"><ul class="ne-ul"><li id="uaf8032bb" data-lake-index-type="0"><span class="ne-text">将可选字段转为必选字段</span></li></ul><pre><code><code>type B = Required&lt;A&gt;</code></code></pre></td></tr><tr style="height: 33px"><td width="318"><p id="u1a1da710" class="ne-p"><span class="ne-text">Omit</span></p></td><td width="318"><ul class="ne-ul"><li id="u78dd2ad3" data-lake-index-type="0"><span class="ne-text">移除指定项</span></li></ul><pre><code><code>type B = Omit&lt;A, 'a' | 'b'&gt;</code></code></pre></td></tr><tr style="height: 33px"><td width="318"><p id="ue047fc96" class="ne-p"><span class="ne-text">Exclude</span></p></td><td width="318"><ul class="ne-ul"><li id="u814a1afa" data-lake-index-type="0"><span class="ne-text">排除</span></li></ul><pre><code><code>type B = Exclude&lt;string | number, string&gt;</code></code></pre></td></tr><tr style="height: 33px"><td width="318"><p id="u555524d6" class="ne-p"><span class="ne-text">Extract</span></p></td><td width="318"><ul class="ne-ul"><li id="u3566469d" data-lake-index-type="0"><span class="ne-text">择取</span></li></ul><pre><code><code>type B = Extract&lt;string | number, string&gt;</code></code></pre></td></tr><tr style="height: 33px"><td width="318"><p id="u7ee55ba0" class="ne-p"><span class="ne-text">NonNullable</span></p></td><td width="318"><ul class="ne-ul"><li id="u8247e26e" data-lake-index-type="0"><span class="ne-text">去除“空”类型</span></li></ul><pre><code><code>type B = NonNullable&lt;string | null | undefined&gt;// B -&gt; string</code></code></pre></td></tr><tr style="height: 33px"><td width="318"><p id="u7f47e0cf" class="ne-p"><span class="ne-text">Parameters</span></p></td><td width="318"><ul class="ne-ul"><li id="ud5251af7" data-lake-index-type="0"><span class="ne-text">得到函数参数元组</span></li></ul><pre><code><code>type FUN = (n: string, m: number) =&gt; voidtype A = Parameters&lt;FUN&gt;<p>const test: A = [‘111’, 222];</code><br></code></pre></p></td></tr><tr style="height: 33px"><td width="318"><p id="u71bcf350" class="ne-p"><span class="ne-text">ReturnType</span></p></td><td width="318"><ul class="ne-ul"><li id="u7f9d26b9" data-lake-index-type="0"><span class="ne-text">得到函数返回值类型</span></li></ul><pre><code><code>type FUN = (n: string, m: number) =&gt; voidtype A = ReturnType&lt;FUN&gt;<p>const test: A = // void</code><br></code></pre></p></td></tr></tbody></table><ol class="ne-ol"><li id="udf359230" data-lake-index-type="0"><span class="ne-text">infer关键字 extends关键字</span></li></ol><p id="uf8802929" class="ne-p"><span class="ne-text">推断类型</span></p><pre><code><code>type A&lt;T&gt; = T extends Array&lt;infer U&gt; ? U : T<p>type B = A&lt;Array&lt;string&gt;&gt; // string<br>type C = A&lt;number&gt; // number</code><br></code></pre></p></div>]]></content:encoded>
      
      
      <category domain="https://www.wztlink1013.com/categories/Web%E5%BC%80%E5%8F%91/">Web开发</category>
      
      <category domain="https://www.wztlink1013.com/categories/Web%E5%BC%80%E5%8F%91/JavaScript/">JavaScript</category>
      
      <category domain="https://www.wztlink1013.com/categories/Web%E5%BC%80%E5%8F%91/JavaScript/TypeScript/">TypeScript</category>
      
      
      
      <comments>https://www.wztlink1013.com/blog/torv9p4z2b79494z/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>CSS选择器中的:has()和:not()伪类</title>
      <link>https://www.wztlink1013.com/blog/etxgze472uzh7t1i/</link>
      <guid>https://www.wztlink1013.com/blog/etxgze472uzh7t1i/</guid>
      <pubDate>Sun, 03 Sep 2023 00:33:09 GMT</pubDate>
      
        
        
          
          
      <description>&lt;!doctype html&gt;&lt;div class=&quot;lake-content&quot; typography=&quot;classic&quot;&gt;&lt;p id=&quot;ub2dd044b&quot; class=&quot;ne-p&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;前言:</description>
          
        
      
      
      
      <content:encoded><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="ub2dd044b" class="ne-p"><span class="ne-text">前言: 本文记录一下CSS3中逻辑选择器中的has和not, has相当于根据子代条件来选择父代, not类似过滤条件. </span><strong><span class="ne-text">使用前先检查代码运行的浏览器环境是否符合如下截图条件.</span></strong></p><p id="u4debc8a1" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2023/png/1484158/1693729315664-7752ef04-8503-42b0-b271-a4adffed81ec.png" width="540.328125" id="u310bdcce" class="ne-image"></p><h3 id="C7n01"><span class="ne-text">not</span></h3><p id="u9b72f6e5" class="ne-p"><span class="ne-text">对当前节点的过滤筛选</span></p><pre><code><code>&lt;html&gt;  &lt;head&gt;    &lt;title&gt;css&lt;/title&gt;    &lt;style&gt;      div.parent:not(.not-parent) &#123;        border: 1px red solid;      &#125;    &lt;/style&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;div class=&quot;parent not-parent&quot;&gt;0000&lt;/div&gt;    &lt;div class=&quot;parent&quot;&gt;      &lt;div&gt;1111&lt;/div&gt;      &lt;div&gt;        &lt;div class=&quot;active&quot;&gt;2222&lt;/div&gt;      &lt;/div&gt;    &lt;/div&gt;    &lt;div class=&quot;parent&quot;&gt;      &lt;div&gt;3333&lt;/div&gt;      &lt;div&gt;4444&lt;/div&gt;    &lt;/div&gt;    &lt;p&gt;&lt;/p&gt;  &lt;/body&gt;&lt;/html&gt;</code></code></pre><p id="ubf0f5013" class="ne-p" style="text-align: left"><img src="https://cdn.nlark.com/yuque/0/2023/png/1484158/1693728187545-dc666922-bd28-4c9d-b63e-824c8b0476f0.png" width="257.03705519478797" id="u46b8367d" class="ne-image"></p><h3 id="bNc8z"><span class="ne-text">has</span></h3><p id="u11a3e0cd" class="ne-p"><span class="ne-text">has选择器: </span><strong><span class="ne-text">根据子是否符合条件来选择父级</span></strong></p><p id="uaf7bd836" class="ne-p"><span class="ne-text">设置子代中有active类的parent类名div的样式</span></p><pre><code><code>&lt;html&gt;  &lt;head&gt;    &lt;title&gt;css&lt;/title&gt;    &lt;style&gt;      div.parent:has(.active) &#123;        border: 1px red solid;      &#125;    &lt;/style&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;div class=&quot;parent&quot;&gt;      &lt;div&gt;1111&lt;/div&gt;      &lt;div&gt;        &lt;div class=&quot;active&quot;&gt;2222&lt;/div&gt;      &lt;/div&gt;    &lt;/div&gt;    &lt;div class=&quot;parent&quot;&gt;      &lt;div&gt;3333&lt;/div&gt;      &lt;div&gt;4444&lt;/div&gt;    &lt;/div&gt;    &lt;p&gt;&lt;/p&gt;  &lt;/body&gt;&lt;/html&gt;</code></code></pre><p id="u1eafcd36" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2023/png/1484158/1693726768953-ae1aa08f-87bd-45d1-ad03-bf4a73538bdc.png" width="257.03705519478797" id="u1ceb6584" class="ne-image"></p><p id="ued6d7945" class="ne-p"><span class="ne-text">如果将上面css改为, 边框则消失</span></p><pre><code><code>div.parent:has(&gt; .active) &#123;  border: 1px red solid;&#125;</code></code></pre><p id="u08a49d4c" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2023/png/1484158/1693727448672-f90d3002-6437-4d65-9b1b-ea889429bd06.png" width="257.03705519478797" id="udd9054cc" class="ne-image"></p><p id="u56d25e80" class="ne-p"><span class="ne-text">还可以表示兄弟跟随关系</span></p><pre><code><code>div.parent:has(+ p) &#123;  border: 1px red solid;&#125;</code></code></pre><p id="u3dc38aeb" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2023/png/1484158/1693727414288-eb1381c5-ce55-44b2-bea6-0e7dad844aba.png" width="257.03705519478797" id="u977486b6" class="ne-image"></p><p id="u3b65a87a" class="ne-p"><span class="ne-text">和not搭配使用, 如下表示不包含active后代的div.parent的标签</span></p><pre><code><code>div.parent:not(:has(.active)) &#123;  border: 1px red solid;&#125;</code></code></pre><p id="u12be46f2" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2023/png/1484158/1693727684199-12da436d-df79-4580-ad37-527bb3a9dc48.png" width="257.03705519478797" id="u860533e4" class="ne-image"></p><p id="u0872252b" class="ne-p"><span class="ne-text">上述not和has位置互换表示的意思不一样</span></p><pre><code><code>div.parent:has(:not(.active)) &#123;  border: 1px red solid;&#125;</code></code></pre><p id="u65f722ad" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2023/png/1484158/1693727825016-f0ae7f89-7fb6-4e74-9d40-32e2727079d5.png" width="257.03705519478797" id="u3f9eacb2" class="ne-image"></p><p id="u0f0fe764" class="ne-p"><span class="ne-text">和表单一些元素搭配使用</span></p><pre><code><code>&lt;html&gt;  &lt;head&gt;    &lt;title&gt;css&lt;/title&gt;    &lt;style&gt;      div:has(input:focus) &#123;        border: 1px red solid;      &#125;    &lt;/style&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;div&gt;      &lt;input type=&quot;text&quot; value=&quot;111&quot; /&gt;    &lt;/div&gt;    &lt;div&gt;      &lt;input type=&quot;text&quot; value=&quot;222&quot; /&gt;    &lt;/div&gt;  &lt;/body&gt;&lt;/html&gt;</code></code></pre><p id="uda31529e" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2023/png/1484158/1693728587821-b90111c9-a13f-4ecc-907e-d1c5d26f3a3d.png" width="257.03705519478797" id="u17090981" class="ne-image"></p><hr id="nIJig" class="ne-hr"><p id="u5dcb7170" class="ne-p" style="text-align: center"><span class="ne-text">一些常规使用CSS选择器可以参考另一篇文章:  </span><a href="https://www.wztlink1013.com/blog/01_html5css3_day01/" data-href="https://www.wztlink1013.com/blog/01_html5css3_day01/" class="ne-link"><span class="ne-text">CSS/CSS3选择器总结 | 尼采般地抒情</span></a></p></div>]]></content:encoded>
      
      
      <category domain="https://www.wztlink1013.com/categories/Web%E5%BC%80%E5%8F%91/">Web开发</category>
      
      <category domain="https://www.wztlink1013.com/categories/Web%E5%BC%80%E5%8F%91/HTML-CSS/">HTML+CSS</category>
      
      
      
      <comments>https://www.wztlink1013.com/blog/etxgze472uzh7t1i/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>YApi内网部署</title>
      <link>https://www.wztlink1013.com/blog/eil6hmfg5ip4tdh7/</link>
      <guid>https://www.wztlink1013.com/blog/eil6hmfg5ip4tdh7/</guid>
      <pubDate>Sat, 06 May 2023 07:19:03 GMT</pubDate>
      
        
        
          
          
      <description>&lt;!doctype html&gt;&lt;div class=&quot;lake-content&quot; typography=&quot;classic&quot;&gt;&lt;p id=&quot;u0f0c809d&quot; class=&quot;ne-p&quot; style=&quot;text-align: justify&quot;&gt;&lt;span</description>
          
        
      
      
      
      <content:encoded><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="u0f0c809d" class="ne-p" style="text-align: justify"><span class="ne-text">前言：使用yapi系统来管理个人项目接口，目标是在个人电脑上而非服务器上搭建一个yapi系统，开机自启动或者手动启动。一开始是使用官网推荐的yapi-cli来搭建，但是坑比较多，node限制在12x，这个显然影响本机环境。然后采用直接运行YApi的源码，利用pm2来运行node服务，最后可以达到预期效果，但是pm2设置了开机自启动影响电脑性能。最后采用docker容器部署，需要的时候手动启动即可，而且部署起来感觉更加简洁，故本文将docker作为推荐部署方式。</span></p><h2 id="dNVSw"><span class="ne-text">一、pm2部署</span></h2><p id="uc4b387b0" class="ne-p"><span class="ne-text">使用pm2来运行YApi node程序。</span></p><h3 id="G0lZ0"><span class="ne-text">下载Yapi源码以及配置Yapi</span></h3><ul class="ne-ul"><li id="u990e7ac7" data-lake-index-type="0"><span class="ne-text">先将node版本切换到</span><code class="ne-code"><span class="ne-text">12.18.2</span></code><span class="ne-text">，因为过高版本的node不能使用（个人试过高于14.17.就不能使用）。</span></li></ul><p id="u3b02a4a6" class="ne-p" style="text-align: center"><strong><span class="ne-text">关于如何切换node版本，参考之前文章nvm的使用</span></strong></p><p id="ucd24bba0" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1646102278163-10a8b55f-5fe8-46c3-8e0d-39bdd8f69d00.png" width="649.166640871102" id="u320f9d7e" class="ne-image"></p><ul class="ne-ul"><li id="ufc97e1d2" data-lake-index-type="0"><span class="ne-text">然后下载cnpm </span><code class="ne-code"><span class="ne-text">npm install -g cnpm --registry=</span><a href="https://registry.npm.taobao.org" data-href="https://registry.npm.taobao.org" target="_blank" class="ne-link"><span class="ne-text">https://registry.npm.taobao.org</span></a></code></li><li id="ucd48f741" data-lake-index-type="0"><span class="ne-text">然后下载yapi：</span></li></ul><pre><code>cnpm install -g yapi-cli</code></pre><ul class="ne-ul"><li id="u9de97657" data-lake-index-type="0"><span class="ne-text">在文件夹中执行如下命令：</span></li></ul><pre><code>yapi server</code></pre><ul class="ne-ul"><li id="ue4cb8925" data-lake-index-type="0"><span class="ne-text" style="color: rgb(33, 37, 41); font-size: 16px">访问localhost:9090，将页面配置填上即可：</span></li></ul><p id="ub4ad9a50" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1646033850542-bdbeef58-d2ac-44d5-ad34-28c5752cd54f.png" width="1572.4999375144666" id="cBXHi" class="ne-image"></p><p id="u47e2bff1" class="ne-p"><span class="ne-text">安装成功会有如下信息：</span></p><pre><code>初始化管理员账号成功,账号名：&quot;admin@admin.com&quot;，密码：&quot;ymfe.org&quot;部署成功，请切换到部署目录，输入： &quot;node vendors/server/app.js&quot; 指令启动服务器, 然后在浏览器打开 http://127.0.0.1:3000 访问</code></pre><ul class="ne-ul"><li id="u9f3d461e" data-lake-index-type="0"><span class="ne-text">然后访问：</span><a href="http://127.0.0.1:3000" data-href="http://127.0.0.1:3000" target="_blank" class="ne-link"><span class="ne-text">http://127.0.0.1:3000</span></a></li></ul><h3 id="H6qIN"><span class="ne-text">创建本地MongoDB数据库</span></h3><pre><code>db.createUser(&#123;user: 'root',pwd: 'root',roles:[&#123;role: 'root',db: 'admin'&#125;]&#125;)</code></pre><pre><code>&gt; use adminswitched to db admin&gt; db.createUser(&#123;user: 'root',pwd: 'root',roles:[&#123;role: 'root',db: 'admin'&#125;]&#125;)Successfully added user: &#123;        &quot;user&quot; : &quot;root&quot;,        &quot;roles&quot; : [                &#123;                        &quot;role&quot; : &quot;root&quot;,                        &quot;db&quot; : &quot;admin&quot;                &#125;        ]&#125;&gt; show users&#123;        &quot;_id&quot; : &quot;admin.root&quot;,        &quot;userId&quot; : UUID(&quot;f47c99bb-2df6-410c-bde1-2f424d0258d3&quot;),        &quot;user&quot; : &quot;root&quot;,        &quot;db&quot; : &quot;admin&quot;,        &quot;roles&quot; : [                &#123;                        &quot;role&quot; : &quot;root&quot;,                        &quot;db&quot; : &quot;admin&quot;                &#125;        ],        &quot;mechanisms&quot; : [                &quot;SCRAM-SHA-1&quot;,                &quot;SCRAM-SHA-256&quot;        ]&#125;</code></pre><p id="ucb07af7e" class="ne-p"><span class="ne-text">找到 MongoDB 安装目录，打开 mongod.cfg文件修改</span></p><p id="u4c975e0d" class="ne-p"><span class="ne-text">重启mongodb</span></p><pre><code>C:\Users\wztli&gt;mongoMongoDB shell version v5.0.5connecting to: mongodb://127.0.0.1:27017/?compressors=disabled&amp;gssapiServiceName=mongodbImplicit session: session &#123; &quot;id&quot; : UUID(&quot;6ff518c1-21c7-4d6f-98ce-23b12c925321&quot;) &#125;MongoDB server version: 5.0.5================Warning: the &quot;mongo&quot; shell has been superseded by &quot;mongosh&quot;,which delivers improved usability and compatibility.The &quot;mongo&quot; shell has been deprecated and will be removed inan upcoming release.For installation instructions, seehttps://docs.mongodb.com/mongodb-shell/install/================&gt; use adminswitched to db admin&gt; db.auth('root','root')1</code></pre><p id="u01a88216" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1646098577475-dfd39936-36f1-4cf4-b61d-682957334517.png" width="254.83071899414062" id="ue6b55d01" class="ne-image"></p><h3 id="wxjuG"><span class="ne-text">YApi node程序运行成功</span></h3><p id="u1904299f" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1646099210899-717632b0-b65f-4e28-9199-9061a306254c.png" width="839.1666333211806" id="XphSR" class="ne-image"></p><h3 id="isIb9"><span class="ne-text">pm2后台管理Yapi进程</span></h3><p id="u2ef2c275" class="ne-p"><span class="ne-text">pm2就相当于之前服务器使用的screen，新开一个进程，就算关掉cmd也能进行操作</span></p><p id="uf2083388" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1646102724248-270ad78b-b70d-4682-8732-c902c277bda2.png" width="784.9999688069038" id="u0bebbfc6" class="ne-image"></p><p id="u6fc0c6a7" class="ne-p"><span class="ne-text">这样就是在本地电脑上，可以把项目关掉，但是该项目还处于运行当中，当然了，重启电脑还是要重新执行上面的pm2命令的，也可以进行pm2开机自启动一些项目，具体参考上面的教程链接。</span></p><h3 id="ZAjnn"><span class="ne-text">pm2设置开机自启动服务</span></h3><p id="u9840df8c" class="ne-p"><span class="ne-text">目的是电脑一开机就会自动重启该服务：</span></p><pre><code>cnpm i -g pm2-windows-service</code></pre><p id="ua5f80609" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1646118390666-51bc2220-c6ce-473e-a6c8-e1c88a338ac8.png" width="714.9999715884538" id="ua5b9348d" class="ne-image"></p><h3 id="jycMa"><span class="ne-text">相关报错</span></h3><h4 id="Zz2GM"><span class="ne-text">Error:  (node:2304) Warning: Accessing non-existent property……</span></h4><pre><code>Error:  (node:2304) Warning: Accessing non-existent property 'count' of module exports inside circular dependency(Use `node --trace-warnings ...` to show where the warning was created)</code></pre><ul class="ne-ul"><li id="u927ff03a" data-lake-index-type="0"><span class="ne-text">原因node版本过高：</span><a href="https://github.com/YMFE/yapi/issues/1736" data-href="https://github.com/YMFE/yapi/issues/1736" target="_blank" class="ne-link"><span class="ne-text">https://github.com/YMFE/yapi/issues/1736</span></a></li></ul><h4 id="Af03x"><span class="ne-text">events.js:292 throw er; // Unhandled 'error' event</span></h4><p id="ua131e8fa" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1646034833437-db75cee7-0157-41eb-ac4c-cfd27f3db1e1.png" width="272.33331298828125" id="AJW0o" class="ne-image"></p><p id="u4961a57d" class="ne-p"><span class="ne-text">下载gyp试试，需要电脑上的环境参考：</span><a href="https://github.com/nodejs/node-gyp#on-windows" data-href="https://github.com/nodejs/node-gyp#on-windows" target="_blank" class="ne-link"><span class="ne-text">https://github.com/nodejs/node-gyp#on-windows</span></a></p><pre><code>cnpm install -g node-gyp</code></pre><h4 id="oNDgw"><span class="ne-text">Error: Can‘t find Python executable “python“, you can set the PYTHON env variable</span></h4><p id="u595d1a18" class="ne-p"><span class="ne-text">成功安装之后，cnpm i 会有一个报错：</span></p><p id="u365ce299" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1646035557382-7fcc59de-05ca-45f5-90ef-a2e24f70f6d1.png" width="209.5" id="aHtry" class="ne-image"></p><p id="ua245b67d" class="ne-p"><span class="ne-text"></span></p><p id="uf44429f7" class="ne-p"><span class="ne-text">解决参考：</span></p><ul class="ne-ul"><li id="u8dee6132" data-lake-index-type="0"><span class="ne-text"></span><a href="https://blog.51cto.com/u_15301254/3924342" data-href="https://blog.51cto.com/u_15301254/3924342" target="_blank" class="ne-link"><span class="ne-text">【Bug解决】Error: Can‘t find Python executable “python“, you can set the PYTHON env variable</span></a></li></ul><p id="u7fff91cd" class="ne-p"><span class="ne-text">下载：</span></p><pre><code>npm install --global --production windows-build-tools</code></pre><h4 id="zhObf"><span class="ne-text">MongoNetworkError: Authentication failed., mongodb Authentication failed</span></h4><ul class="ne-ul"><li id="uc8539557" data-lake-index-type="0"><a href="https://github.com/fjc0k/docker-YApi/issues/32" data-href="https://github.com/fjc0k/docker-YApi/issues/32" target="_blank" class="ne-link"><span class="ne-text">https://github.com/fjc0k/docker-YApi/issues/32</span></a></li></ul><p id="ucfef198f" class="ne-p"><span class="ne-text">添加admin值即可</span></p><h2 id="YlpJX"><span class="ne-text">二、docker部署</span></h2><p id="u87363657" class="ne-p"><span class="ne-text">docker部署主要参考：</span><a href="https://github.com/fjc0k/docker-YApi#readme" data-href="https://github.com/fjc0k/docker-YApi#readme" target="_blank" class="ne-link"><span class="ne-text">https://github.com/fjc0k/docker-YApi#readme</span></a><span class="ne-text">，不过有几个需要注意的点：</span></p><ul class="ne-ul"><li id="ua7fd6bda" data-lake-index-type="0"><span class="ne-text">redeme提到的Docker 和 Docker Compose版本不能太久</span></li><li id="ucf81c10c" data-lake-index-type="0"><span class="ne-text">MongoDB如果是</span><a href="https://www.mongodb.com/" data-href="https://www.mongodb.com/" target="_blank" class="ne-link"><span class="ne-text">在线数据库</span></a><span class="ne-text">，配置方式采用集群配置字段更加便捷：</span></li></ul><pre><code>version: '3'<p>services:<br>  yapi-web:<br>    image: jayfong/yapi:latest<br>    container_name: yapi-web<br>    ports:<br>      - 40001:3000<br>    environment:<br>      - YAPI_ADMIN_ACCOUNT=xxxxxx<br>      - YAPI_ADMIN_PASSWORD=xxxxxx<br>      - YAPI_CLOSE_REGISTER=true<br>      - YAPI_DB_CONNECT_STRING=mongodb+srv://name:password@url/databasename?retryWrites=true&amp;w=majority<br>      - YAPI_MAIL_ENABLE=false<br>      - YAPI_LDAP_LOGIN_ENABLE=false<br>      - YAPI_PLUGINS=[]<br>    depends_on:<br>        ···<br></code></pre></p><h2 id="LBMyr"><span class="ne-text">三、相关链接</span></h2><p id="u7de33e87" class="ne-p"><span class="ne-text">YApi参考：</span></p><ul class="ne-ul"><li id="u0ce203b2" data-lake-index-type="0"><span class="ne-text">yapi文档以及安装文档：</span><a href="https://hellosean1025.github.io/yapi/" data-href="https://hellosean1025.github.io/yapi/" target="_blank" class="ne-link"><span class="ne-text">https://hellosean1025.github.io/yapi/</span></a></li><li id="u088fb7d1" data-lake-index-type="0"><span class="ne-text">YApi 安装可能会出现的问题：</span><a href="https://github.com/YMFE/yapi/issues/16" data-href="https://github.com/YMFE/yapi/issues/16" target="_blank" class="ne-link"><span class="ne-text">https://github.com/YMFE/yapi/issues/16</span></a></li><li id="u84bae2c3" data-lake-index-type="0"><span class="ne-text">docker参考：</span><a href="https://github.com/fjc0k/docker-YApi" data-href="https://github.com/fjc0k/docker-YApi" target="_blank" class="ne-link"><span class="ne-text">https://github.com/fjc0k/docker-YApi</span></a></li><li id="u89ae9669" data-lake-index-type="0"><a href="https://segmentfault.com/a/1190000020534539" data-href="https://segmentfault.com/a/1190000020534539" target="_blank" class="ne-link"><span class="ne-text">Yapi 本地部署</span></a></li></ul><p id="ua003c847" class="ne-p"><span class="ne-text">本地MongoDB创建参考：</span></p><ul class="ne-ul"><li id="u00ab0a5f" data-lake-index-type="0"><a href="https://blog.csdn.net/qq_42583263/article/details/121403125" data-href="https://blog.csdn.net/qq_42583263/article/details/121403125" class="ne-link"><span class="ne-text">MongoDB 设置用户名密码和数据库连接_mongodb 连接数据库带用户名和密码_大胖东的博客-CSDN博客</span></a></li></ul><p id="u630c7d71" class="ne-p"><span class="ne-text">pm2相关参考：</span></p><ul class="ne-ul"><li id="u01e9bc43" data-lake-index-type="0"><a href="https://www.cnblogs.com/chyingp/p/pm2-documentation.html" data-href="https://www.cnblogs.com/chyingp/p/pm2-documentation.html" target="_blank" class="ne-link"><span class="ne-text">PM2实用入门指南 </span></a></li><li id="u2b10dbc2" data-lake-index-type="0"><a href="https://www.jianshu.com/p/5f808762a71a" data-href="https://www.jianshu.com/p/5f808762a71a" class="ne-link"><span class="ne-text">pm2 使用教程</span></a></li></ul><ul class="ne-ul"><li id="ubf1b94b0" data-lake-index-type="0"><a href="https://www.jianshu.com/p/6cb523c0ced8" data-href="https://www.jianshu.com/p/6cb523c0ced8" target="_blank" class="ne-link"><span class="ne-text">Window 设置pm2开机自启动服务</span></a></li><li id="u1e2423fd" data-lake-index-type="0"><a href="https://www.cnblogs.com/wuqilang/p/12794972.html" data-href="https://www.cnblogs.com/wuqilang/p/12794972.html" target="_blank" class="ne-link"><span class="ne-text">Window 设置pm2开机自启动服务</span></a></li></ul></div>]]></content:encoded>
      
      
      <category domain="https://www.wztlink1013.com/categories/Web%E5%BC%80%E5%8F%91/">Web开发</category>
      
      <category domain="https://www.wztlink1013.com/categories/Web%E5%BC%80%E5%8F%91/DevOps/">DevOps</category>
      
      
      
      <comments>https://www.wztlink1013.com/blog/eil6hmfg5ip4tdh7/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
