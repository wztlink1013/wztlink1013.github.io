<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>尼采般地抒情</title>
    <link>https://www.wztlink1013.com/</link>
    
    <image>
      <url>https://www.wztlink1013.com/favicon.ico</url>
      <title>尼采般地抒情</title>
      <link>https://www.wztlink1013.com/</link>
    </image>
    
    <atom:link href="https://www.wztlink1013.com/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>尼采般地抒情个人网站，本科CS，大学期间开始撰写技术博客、个人生活随笔，这个兴趣爱好会一直延续下去……坚信什么都不舍弃，什么也改变不了！</description>
    <pubDate>Fri, 22 Mar 2024 23:47:35 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>JavaScript事件循环机制和异步编程（Promise、async和await）</title>
      <link>https://www.wztlink1013.com/blog/lz7xgx/</link>
      <guid>https://www.wztlink1013.com/blog/lz7xgx/</guid>
      <pubDate>Fri, 22 Mar 2024 23:47:01 GMT</pubDate>
      
        
        
          
          
      <description>&lt;!doctype html&gt;&lt;div class=&quot;lake-content&quot; typography=&quot;classic&quot;&gt;&lt;p id=&quot;u811cb54a&quot; class=&quot;ne-p&quot; style=&quot;text-align: center&quot;&gt;&lt;img</description>
          
        
      
      
      
      <content:encoded><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="u811cb54a" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1653573417541-44275572-06ee-41fc-ab54-6683e2510450.png" width="1960" id="ude4d9e36" class="ne-image"></p><p id="ud5f3a522" class="ne-p"><span class="ne-text">前言：JavaScript的事件循环机制或是异步编程是具体代码编写的重点，JavaScript语言的单线程执行特点以及同步任务和异步任务，由这些语言特性共同有一套事件循环执行机制也就是异步代码的预期执行效果。</span></p><h2 id="bAXj8"><span class="ne-text">一、JS代码执行机制</span></h2><h3 id="YbZ5l"><span class="ne-text">JavaScript的单线程</span></h3><p id="b785073ad0b4241b17542f923c68bd89" class="ne-p"><span class="ne-text">单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。如果前一个任务耗时很长，后一个任务就不得不一直等着。这样所导致的问题是： 如果 JS 执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞的感觉。</span></p><h3 id="IF7ut"><span class="ne-text">同步任务和异步任务</span></h3><p id="175d9c82a2892ec08ad8c92559dfbb4e" class="ne-p"><span class="ne-text">单线程导致的问题就是后面的任务等待前面任务完成，如果前面任务很耗时（比如读取网络数据），后面任务不得不一直等待。为了解决这个问题，利用多核 CPU 的计算能力，HTML5 提出 Web Worker 标准，允许 JavaScript 脚本创建多个线程，但是子线程完全受主线程控制。于是JS 中出现了同步任务和异步任务。</span></p><p id="u09384c3b" class="ne-p"><span class="ne-text">JS中所有任务可以分成两种，一种是同步任务（synchronous），另一种是异步任务（asynchronous）。</span></p><ul class="ne-ul"><li id="ub267d26f" data-lake-index-type="0"><strong><span class="ne-text">【同步任务】</span></strong><span class="ne-text">指的是：在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务；</span></li><li id="u8624ac1a" data-lake-index-type="0"><strong><span class="ne-text">【异步任务】</span></strong><span class="ne-text">指的是：不进入主线程、而进入</span><strong><span class="ne-text">“任务队列”</span></strong><span class="ne-text">的任务，当主线程中的任务运行完了，才会将异步任务相关的回调函数从”任务队列”取出异步任务放入主线程执行。</span></li></ul><div data-type="warning" class="ne-alert"><p id="ud8b66a6f" class="ne-p"><span class="ne-text">异步任务又分为宏任务和微任务</span></p><p id="u058036d7" class="ne-p"><strong><span class="ne-text">常见的宏任务有：</span></strong></p><ol class="ne-ol"><li id="u1652333c" data-lake-index-type="0"><span class="ne-text">setTimeout</span></li><li id="u30d4ea96" data-lake-index-type="0"><span class="ne-text">setInterval</span></li><li id="u2d340e59" data-lake-index-type="0"><span class="ne-text">I/O（磁盘读写、网络通信···）</span></li><li id="uf13a1bdb" data-lake-index-type="0"><span class="ne-text">setImmediate</span><span class="ne-text" style="text-decoration: underline">（浏览器环境没有、Nodejs环境有）</span></li><li id="u6a49c6b9" data-lake-index-type="0"><span class="ne-text">requestAnimationFrame</span><span class="ne-text" style="text-decoration: underline">（浏览器环境有、Nodejs环境没有）</span></li></ol><p id="ub77f1171" class="ne-p"><strong><span class="ne-text">常见的微任务有：</span></strong></p><ol class="ne-ol"><li id="ud152fcc2" data-lake-index-type="0"><span class="ne-text">Promise</span></li><li id="ua2074ecf" data-lake-index-type="0"><span class="ne-text">Object.observe</span></li><li id="ue17e45d8" data-lake-index-type="0"><span class="ne-text">process.nextTick </span><span class="ne-text" style="text-decoration: underline">（浏览器环境没有、Nodejs环境有）</span></li><li id="u0e1ffa38" data-lake-index-type="0"><span class="ne-text">MutationObserver</span><span class="ne-text" style="text-decoration: underline">（浏览器环境有、Nodejs环境没有）</span></li></ol></div><h3 id="tDUjC"><span class="ne-text">事件循环机制</span></h3><p id="u5553772e" class="ne-p"><span class="ne-text">事件循环机制则是按照上面所描述的JavaScript特性，当即有同步任务又有异步任务情况下，代码的执行先后顺序。</span></p><p id="ub559a1fb" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/webp/1484158/1657425246544-000fdb98-cba1-4b29-83eb-97efba576a6c.webp" width="1280" id="u7367241e" class="ne-image"></p><ol class="ne-ol"><li id="u4bb87b57" data-lake-index-type="0"><span class="ne-text">碰到同步任务，就先执行执行栈中的同步任务</span></li></ol><div class="ne-quote"><p id="ucec7015d" class="ne-p"><span class="ne-text">遇到函数的嵌套调用就把函数压入栈内再依次“剥洋葱”</span></p></div><ol start="2" class="ne-ol"><li id="u7048d5b0" data-lake-index-type="0"><span class="ne-text">碰到异步任务就压入任务队列（异步任务分为宏任务和微任务）</span></li><li id="u8ac10e88" data-lake-index-type="0"><span class="ne-text">当前执行栈中的所有同步任务执行完毕，就将执行异步任务，异步任务执行原则“先微后宏”</span></li></ol><p id="u245b5a71" class="ne-p"><strong><span class="ne-text" style="color: #E8323C">由于主线程不断地重复获得任务、执行任务、再获取任务、再执行……，这种机制被称为事件循环（Event Loop）</span></strong></p><h2 id="IvbMB"><span class="ne-text">二、一些例子</span></h2><p id="u68b25ff2" class="ne-p"><span class="ne-text">通过一些实际代码例子及其运行的结果来加深对事件循环机制的理解</span></p><h3 id="TLtJm"><span class="ne-text">同步代码+Promise</span></h3><pre><code><code>const promise = new Promise((resolve, reject) =&gt; &#123;  console.log(1);  resolve(&quot;success&quot;);  console.log(2);&#125;);promise.then((data) =&gt; &#123;  console.log(data);  console.log(3);&#125;);console.log(4);</code></code></pre><p id="u4f52f25f" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2024/png/1484158/1711177509945-b8a191e2-75b6-4ea8-ae12-cc5d4a6f1d9c.png" width="147.49999413887684" id="u60800e7b" class="ne-image"></p><pre><code><code>const promise1 = new Promise((resolve, reject) =&gt; &#123;  console.log(&quot;promise1&quot;);  resolve(&quot;resolve1&quot;);&#125;);const promise2 = promise1.then((res) =&gt; &#123;  console.log(res);&#125;);console.log(&quot;1&quot;, promise1);console.log(&quot;2&quot;, promise2);</code></code></pre><p id="u79e4c6cb" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2024/png/1484158/1711177590883-9c151a19-b11f-40f8-9378-9f878c7e1b58.png" width="273.33332247204294" id="u3ae9bd10" class="ne-image"></p><h3 id="oa0ag"><span class="ne-text">同步代码+setTimeout+Promise</span></h3><pre><code><code>console.log(1);setTimeout(() =&gt; &#123;  console.log(2);  Promise.resolve().then(() =&gt; &#123;    console.log(3);  &#125;);&#125;);console.log(4);new Promise((resolve, reject) =&gt; &#123;  console.log(5);  resolve();&#125;)  .then(() =&gt; &#123;    console.log(6);    setTimeout(() =&gt; &#123;      console.log(7);    &#125;);  &#125;)  .catch(() =&gt; &#123;    console.log(9);  &#125;);console.log(8);</code></code></pre><p id="uaadaee80" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2024/png/1484158/1711176750519-95ae6d7b-9aff-4713-80f3-eefc48238c22.png" width="231.6666574610608" id="u086e6f8d" class="ne-image"></p><pre><code><code>setTimeout(() =&gt; &#123;  console.log(1);&#125;, 0);console.log(2);const p = new Promise((resolve) =&gt; &#123;  console.log(3);  resolve();&#125;)  .then(() =&gt; &#123;    console.log(4);  &#125;)  .then(() =&gt; &#123;    console.log(5);  &#125;);console.log(6);</code></code></pre><p id="ue162ba1c" class="ne-p"><strong><span class="ne-text">then的连续回调都属于一个微任务</span></strong></p><p id="u320ca539" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2024/png/1484158/1711177325508-9e71bcee-c292-4c9b-a389-5309e517b79d.png" width="275.83332237270184" id="u4e58c1af" class="ne-image"></p><pre><code><code>new Promise((resolve,reject)=&gt;&#123;  console.log(1)  resolve()&#125;).then(()=&gt;&#123;  console.log(2)  new Promise((resolve,reject)=&gt;&#123;    console.log(3)    resolve()  &#125;).then(()=&gt;&#123;    console.log(4)  &#125;).then(()=&gt;&#123;    console.log(5)  &#125;)&#125;).then(()=&gt;&#123;  console.log(6)&#125;)</code></code></pre><p id="ucc5c1474" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2024/png/1484158/1711177827154-2f41dd48-96bc-4cf8-af9e-9693a46f6efc.png" width="299.9999880790715" id="h2U7V" class="ne-image"></p><pre><code><code>new Promise((resolve, reject) =&gt; &#123;  console.log(1);  resolve();&#125;)  .then(() =&gt; &#123;    console.log(2);    return new Promise((resolve, reject) =&gt; &#123;      console.log(3);      resolve();    &#125;)      .then(() =&gt; &#123;        console.log(4);      &#125;)      .then(() =&gt; &#123;        console.log(5);      &#125;);  &#125;)  .then(() =&gt; &#123;    console.log(6);  &#125;);</code></code></pre><p id="ue19e7715" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2024/png/1484158/1711178047803-bdb99d1a-6071-4fe4-8a30-3896c37aea90.png" width="223.33332445886435" id="u487e8573" class="ne-image"></p><pre><code><code>new Promise((resolve, reject) =&gt; &#123;  console.log(1)  resolve()&#125;).then(() =&gt; &#123;  console.log(2)  new Promise((resolve, reject) =&gt; &#123;    console.log(3)    resolve()  &#125;).then(() =&gt; &#123;    console.log(4)  &#125;).then(() =&gt; &#123;    console.log(5)  &#125;)&#125;).then(() =&gt; &#123;  console.log(6)&#125;)new Promise((resolve, reject) =&gt; &#123;  console.log(7)  resolve()&#125;).then(() =&gt; &#123;  console.log(8)&#125;)</code></code></pre><p id="udc697973" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2024/png/1484158/1711178391841-707dfb36-30a0-40e1-8e79-3cd07976f635.png" width="184.99999264876078" id="uc0fa6ac2" class="ne-image"></p><h3 id="zCwWK"><span class="ne-text">同步代码+async await+Promise</span></h3><p id="u7526ecaf" class="ne-p"><span class="ne-text">await可以看成是Promise的语法糖（实际上是Generate的语法糖），效果和Promise的回调地狱一样，只是代码书写起来类似同步执行代码。</span></p><pre><code><code>async function async1() &#123;  console.log(1);  await async2();  console.log(2);&#125;async function async2() &#123;  console.log(3);&#125;console.log(4);setTimeout(function () &#123;  console.log(5);&#125;);async1();new Promise(function (resolve, reject) &#123;  console.log(6);  resolve();&#125;).then(function () &#123;  console.log(7);&#125;);console.log(8);</code></code></pre><p id="uccfecfa9" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2024/png/1484158/1711179143994-f25a4728-f05b-48bb-9d46-4fef205c4bcb.png" width="201.66665865315363" id="ue5d90719" class="ne-image"></p><h3 id="X8bdj"><span class="ne-text">综合例子</span></h3><pre><code><code>async function a1() &#123;  console.log('a1 start')  await a2()  console.log('a1 end')&#125;async function a2() &#123;  console.log('a2')&#125;<p>console.log(‘script start’)</p><p>setTimeout(() =&gt; &#123;<br>  console.log(‘setTimeout’)<br>&#125;, 0)</p><p>Promise.resolve().then(() =&gt; &#123;<br>  console.log(‘promise1’)<br>&#125;)</p><p>a1()</p><p>let promise2 = new Promise(resolve =&gt; &#123;<br>  resolve(‘promise2.then’)<br>  console.log(‘promise2’)<br>&#125;)</p><p>promise2.then(res =&gt; &#123;<br>  console.log(res)<br>  Promise.resolve().then(() =&gt; &#123;<br>    console.log(‘promise3’)<br>  &#125;)<br>&#125;)<br>console.log(‘script end’)</code><br></code></pre></p><p id="u7ad89b7d" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2024/png/1484158/1711179267786-9e7bf14c-58e3-4dae-811b-ac8fda627250.png" width="217.49999135732685" id="u8442b701" class="ne-image"></p></div>]]></content:encoded>
      
      
      <category domain="https://www.wztlink1013.com/categories/Web%E5%BC%80%E5%8F%91/">Web开发</category>
      
      <category domain="https://www.wztlink1013.com/categories/Web%E5%BC%80%E5%8F%91/JavaScript/">JavaScript</category>
      
      <category domain="https://www.wztlink1013.com/categories/Web%E5%BC%80%E5%8F%91/JavaScript/ECMAScript/">ECMAScript</category>
      
      
      
      <comments>https://www.wztlink1013.com/blog/lz7xgx/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>三分钟掌握JS中事件冒泡、捕获机制和事件委托设计模式</title>
      <link>https://www.wztlink1013.com/blog/ywgyk067zbsx46io/</link>
      <guid>https://www.wztlink1013.com/blog/ywgyk067zbsx46io/</guid>
      <pubDate>Mon, 11 Mar 2024 22:33:16 GMT</pubDate>
      
        
        
          
          
      <description>&lt;!doctype html&gt;&lt;div class=&quot;lake-content&quot; typography=&quot;classic&quot;&gt;&lt;p id=&quot;uf6be57fa&quot; class=&quot;ne-p&quot;&gt;&lt;span</description>
          
        
      
      
      
      <content:encoded><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="uf6be57fa" class="ne-p"><span class="ne-text">前言：js里面事件就是指用户执行某些行为（本文以点击行为为例）后，浏览器会发出相应的事件响应，而用户可以捕获这些事件，并在其中写相应的逻辑代码。本文详细介绍浏览器对事件的传播机制（事件冒泡、事件捕获），以及事件委托（代理）一种代码设计模式。</span></p><h3 id="hG206"><span class="ne-text">一、事件冒泡</span></h3><p id="ub8a21f1d" class="ne-p"><span class="ne-text">嵌套的DOM结果，如果点击子元素，会触发父元素的点击行为</span></p><pre><code><code>&lt;body&gt;  &lt;div id=&quot;outside&quot;&gt;    outside    &lt;div id=&quot;center&quot;&gt;      center      &lt;div id=&quot;inside&quot;&gt;inside&lt;/div&gt;    &lt;/div&gt;  &lt;/div&gt;  &lt;script&gt;    const inside = document.getElementById(&quot;inside&quot;);    const center = document.getElementById(&quot;center&quot;);    const outside = document.getElementById(&quot;outside&quot;);    inside.addEventListener(&quot;click&quot;, () =&gt; &#123;      console.log(&quot;inside&quot;);    &#125;);    center.addEventListener(&quot;click&quot;, () =&gt; &#123;      console.log(&quot;center&quot;);    &#125;);    outside.addEventListener(&quot;click&quot;, () =&gt; &#123;      console.log(&quot;outside&quot;);    &#125;);  &lt;/script&gt;&lt;/body&gt;</code></code></pre><p id="u8f98b592" class="ne-p"><span class="ne-text">如果点击inside区域，会出现如下效果，这就是事件冒泡</span></p><p id="ub177e678" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2024/png/1484158/1710221274477-0ec76e52-e452-4d4c-b9ab-40531e7f0838.png" width="310.8333209819269" id="u19ff0e82" class="ne-image"></p><p id="u1b56b0ff" class="ne-p"><strong><span class="ne-text">停止冒泡</span></strong></p><p id="ucf4681bf" class="ne-p"><span class="ne-text">如果需要停止上述冒泡行为，可以将处理函数修改如下</span></p><pre><code><code>inside.addEventListener(&quot;click&quot;, (e) =&gt; &#123;  e.stopPropagation();  console.log(&quot;inside&quot;);&#125;);</code></code></pre><p id="u9a4fc357" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2024/png/1484158/1710221421292-0c1c8d19-5079-4614-9e12-df9569d3147d.png" width="288.3333218759965" id="u7e8825f8" class="ne-image"></p><h3 id="x1F3I"><span class="ne-text">二、事件捕获</span></h3><p id="u5387116c" class="ne-p"><span class="ne-text">浏览器对事件响应的整个阶段如下（window -&gt; document省略，只从DOM树分析）</span></p><img src="https://cdn.nlark.com/yuque/0/2024/jpeg/1484158/1710222317829-d52061bd-4c57-4195-a7cf-ac2bcc308fd6.jpeg" id="fCE1u" style="display: block; width: 100%"><p id="ub57e3b7f" class="ne-p"><span class="ne-text">事件冒泡阶段只是浏览器对事件响应整个阶段的后半部分，前面还有事件捕获阶段，这阶段的代码修改为如下：</span></p><pre><code><code>inside.addEventListener(  &quot;click&quot;,  (e) =&gt; &#123;    console.log(&quot;inside&quot;);  &#125;,  true);</code></code></pre><p id="u0fcd6d63" class="ne-p"><span class="ne-text">或者</span></p><pre><code><code>inside.addEventListener(  &quot;click&quot;,  (e) =&gt; &#123;    console.log(&quot;inside&quot;);  &#125;,  &#123; capture: true &#125;);</code></code></pre><h3 id="NMJeR"><span class="ne-text">三、事件委托/代理</span></h3><p id="ub562538d" class="ne-p"><span class="ne-text">事件委托可以理解称一种代码设计模式，比如上述例子三个DOM分别注册了点击事件，如果嵌套（或者扁平化）了更多的DOM，一个个注册事件在代码逻辑上较为重复且在性能会有所损耗（绑定事件越多，浏览器内存占用越大）。</span><strong><span class="ne-text">事件委托</span></strong><span class="ne-text">则是利用事件捕获机制，在这些DOM的一个父元素上只注册一个点击事件即可，上述例子利用事件委托可以写成</span></p><pre><code><code>&lt;body&gt;  &lt;div id=&quot;outside&quot;&gt;    outside    &lt;div id=&quot;center&quot;&gt;      center      &lt;div id=&quot;inside&quot;&gt;inside&lt;/div&gt;    &lt;/div&gt;  &lt;/div&gt;  &lt;script&gt;    <pre><code>document.querySelector(&amp;quot;body&amp;quot;).addEventListener(&amp;quot;click&amp;quot;, (e) =&amp;gt; &#123;  console.log(e.target.id);&#125;);</code></pre><p>  &lt;/script&gt;<br>&lt;/body&gt;</code><br></code></pre></p><div data-type="warning" class="ne-alert"><p id="u4829c1eb" class="ne-p"><span class="ne-text">❗</span><span class="ne-text">实际代码不要用body作为父元素</span></p></div><p id="u3310c298" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2024/png/1484158/1710223556542-9deba808-4965-4177-a782-b1299c409015.png" width="329.166653586759" id="ue749ff64" class="ne-image"></p><p id="ub47e7afc" class="ne-p"><br></p><p id="ub29b3637" class="ne-p" style="text-align: center"><span class="ne-text">哥们也做一回标题党</span><img src="https://cdn.nlark.com/yuque/0/2024/jpeg/1484158/1710225564950-b3f001ff-070c-4056-8db9-c6b985f9a44b.jpeg" width="35.9921875" id="uc11aa205" class="ne-image"></p></div>]]></content:encoded>
      
      
      <category domain="https://www.wztlink1013.com/categories/Web%E5%BC%80%E5%8F%91/">Web开发</category>
      
      <category domain="https://www.wztlink1013.com/categories/Web%E5%BC%80%E5%8F%91/JavaScript/">JavaScript</category>
      
      <category domain="https://www.wztlink1013.com/categories/Web%E5%BC%80%E5%8F%91/JavaScript/ECMAScript/">ECMAScript</category>
      
      
      
      <comments>https://www.wztlink1013.com/blog/ywgyk067zbsx46io/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>项目使用all-contributors-cli生成贡献者名单</title>
      <link>https://www.wztlink1013.com/blog/wgervpvkdaoc42ml/</link>
      <guid>https://www.wztlink1013.com/blog/wgervpvkdaoc42ml/</guid>
      <pubDate>Thu, 29 Feb 2024 19:17:53 GMT</pubDate>
      
        
        
          
          
      <description>&lt;!doctype html&gt;&lt;div class=&quot;lake-content&quot; typography=&quot;classic&quot;&gt;&lt;p id=&quot;ue1444cdc&quot; class=&quot;ne-p&quot;&gt;&lt;img</description>
          
        
      
      
      
      <content:encoded><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="ue1444cdc" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2024/png/1484158/1709262142751-6bca1311-c71b-464a-b603-c4d4d89a6f88.png" width="899.9999642372145" id="wtp7K" class="ne-image"></p><p id="ue531d0e9" class="ne-p"><span class="ne-text">前言：all-contributors用于管理和展示项目的贡献者列表，展示贡献者的贡献类型和基础个人信息（头像和昵称）在README.md文件中。</span></p><h3 id="NIt7l"><span class="ne-text">一、初始化all-contributors</span></h3><p id="u226282a0" class="ne-p"><span class="ne-text">项目安装all-contributors-cli</span></p><pre><code><code>pnpm i all-contributors-cli</code></code></pre><p id="u6f44d18e" class="ne-p"><span class="ne-text">项目初始化all-contributors-cli</span></p><pre><code><code>./node_modules/.bin/all-contributors init</code></code></pre><p id="u117ff10e" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2024/png/1484158/1709259194099-6aefe00d-2ad6-4066-8ca7-4ffdb8cf65b9.png" width="808.3333129882812" id="SqJU9" class="ne-image"></p><p id="ud585018e" class="ne-p"><span class="ne-text">初始化完之后，项目的一些文件会自动发生变化：</span></p><ol class="ne-ol"><li id="u16c87012" data-lake-index-type="0"><span class="ne-text">生成</span><code class="ne-code"><span class="ne-text">.all-contributorsrc</span></code><span class="ne-text">文件</span></li></ol><pre><code><code>&#123;  &quot;projectName&quot;: &quot;kittyui&quot;,  &quot;projectOwner&quot;: &quot;wztlink1013&quot;,  &quot;repoType&quot;: &quot;github&quot;,  &quot;repoHost&quot;: &quot;https://github.com&quot;,  &quot;files&quot;: [    &quot;README.md&quot;  ],  &quot;imageSize&quot;: 100,  &quot;commit&quot;: true,  &quot;commitConvention&quot;: &quot;eslint&quot;,  &quot;contributors&quot;: [],  &quot;contributorsPerLine&quot;: 7,  &quot;linkToUsage&quot;: true&#125;</code></code></pre><ol start="2" class="ne-ol"><li id="u451466e9" data-lake-index-type="0"><code class="ne-code"><span class="ne-text">README.md</span></code><span class="ne-text">会在开头和结尾自动添加allcontributors文本展示内容</span></li></ol><pre><code><code>&lt;!-- ALL-CONTRIBUTORS-BADGE:START - Do not remove or modify this section --&gt;<p><a href="#contributors-"><img src="https://img.shields.io/badge/all_contributors-0-orange.svg?style=flat-square" alt="All Contributors"></a></p><p>&lt;!– ALL-CONTRIBUTORS-BADGE:END –&gt;</p><h2 id="Contributors-✨"><a href="#Contributors-✨" class="headerlink" title="Contributors ✨"></a>Contributors ✨</h2><p>Thanks goes to these wonderful people (<a href="https://allcontributors.org/docs/en/emoji-key">emoji key</a>):</p><p>&lt;!– ALL-CONTRIBUTORS-LIST:START - Do not remove or modify this section –&gt;<br>&lt;!– prettier-ignore-start –&gt;<br>&lt;!– markdownlint-disable –&gt;<br>&lt;!– markdownlint-restore –&gt;<br>&lt;!– prettier-ignore-end –&gt;</p><p>&lt;!– ALL-CONTRIBUTORS-LIST:END –&gt;</p><p>This project follows the <a href="https://github.com/all-contributors/all-contributors">all-contributors</a> specification. Contributions of any kind welcome!<br></code><br></code></pre></p><p id="u76f459a3" class="ne-p"><span class="ne-text">效果如下：</span></p><p id="u4cd61ad1" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2024/png/1484158/1709259753769-1124031a-03b2-46d3-9a6f-51f2619b668f.png" width="895.8332977361164" id="u7793f912" class="ne-image"></p><h3 id="PxGg4"><span class="ne-text">二、添加项目开发协作者</span></h3><p id="uad1a54ce" class="ne-p"><span class="ne-text">添加方式有两种：</span></p><ol class="ne-ol"><li id="u99820ece" data-lake-index-type="0"><span class="ne-text">命令行方式添加</span></li><li id="u39e4dc98" data-lake-index-type="0"><span class="ne-text">仓库机器人方式添加：协作者利用</span><code class="ne-code"><span class="ne-text">issues</span></code><span class="ne-text">或者</span><code class="ne-code"><span class="ne-text">pull request</span></code><span class="ne-text">拉取请求方式申请添加</span></li></ol><h4 id="d2jcn"><span class="ne-text">命令行方式添加</span></h4><p id="u7b491dee" class="ne-p"><span class="ne-text">添加用户</span></p><pre><code><code># 添加做出了 &lt;contribution&gt; 类型贡献的贡献者 &lt;username&gt;, # ./node_modules/.bin/all-contributors add &lt;username&gt; &lt;contribution&gt;<p>./node_modules/.bin/all-contributors add wztlink1013 &quot;code,doc&quot;</code><br></code></pre></p><p id="ue9386363" class="ne-p"><span class="ne-text">生成展示表格（自动更新</span><code class="ne-code"><span class="ne-text">README.md</span></code><span class="ne-text">文件）</span></p><pre><code><code>./node_modules/.bin/all-contributors generate</code></code></pre><p id="u61f7d48e" class="ne-p"><span class="ne-text">上述两个命令执行完会自动更新</span><code class="ne-code"><span class="ne-text">.all-contributorsrc</span></code><span class="ne-text">文件和</span><code class="ne-code"><span class="ne-text">README.md</span></code><span class="ne-text">文件</span></p><p id="ue3ad0498" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2024/png/1484158/1709260794169-7a790b49-7e72-4e28-a8b8-3bd7917e5cd3.png" width="900.8332975374342" id="u8cb20852" class="ne-image"></p><h4 id="VRut0"><span class="ne-text">仓库机器人方式添加</span></h4><p id="u3e012659" class="ne-p"><span class="ne-text">添加仓库机器人：</span></p><ul class="ne-ul"><li id="u7d0db2cd" data-lake-index-type="0"><span class="ne-text">GitHub Bot下载：</span><a href="https://github.com/apps/allcontributors/installations/select_target" data-href="https://github.com/apps/allcontributors/installations/select_target" target="_blank" class="ne-link"><span class="ne-text">https://github.com/apps/allcontributors/installations/select_target</span></a></li></ul><p id="u96cff878" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2024/png/1484158/1709261083635-11a66e62-f4a0-4d6f-a4a1-661e58d39f39.png" width="490.8333138293698" id="ub978da08" class="ne-image"></p><p id="u6c6b1f1b" class="ne-p"><span class="ne-text"></span></p><p id="u4dca5414" class="ne-p"><span class="ne-text">发起</span><code class="ne-code"><span class="ne-text">issues</span></code><span class="ne-text">或者</span><code class="ne-code"><span class="ne-text">pull request</span></code><span class="ne-text">请求加入协作者</span></p><p id="uf8fe5fe4" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2024/png/1484158/1709261947692-5df9b5bb-c3e1-42ed-b58c-d53e7c3a3ea9.png" width="770.8333027031699" id="u8bf5b0ab" class="ne-image"></p><p id="uccc5429a" class="ne-p"><span class="ne-text">然后会有一个合并新协作者的</span><code class="ne-code"><span class="ne-text">pull request</span></code><span class="ne-text">被创建，merge即可。</span></p><p id="ua1b3edf5" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2024/png/1484158/1709262058313-e1380c4e-ac76-450d-887d-b41632b99d79.png" width="1045.833291775652" id="ufebc37c4" class="ne-image"></p><h3 id="xDQ9h"><span class="ne-text">三、最终效果</span></h3><p id="uc797f4e9" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2024/png/1484158/1709262142751-6bca1311-c71b-464a-b603-c4d4d89a6f88.png" width="899.9999642372145" id="uf08c90b7" class="ne-image"></p><h3 id="AD8dV"><span class="ne-text">四、参考</span></h3><ul class="ne-ul"><li id="ucf112a8d" data-lake-index-type="0"><a href="https://allcontributors.org/" data-href="https://allcontributors.org/" target="_blank" class="ne-link"><span class="ne-text">https://allcontributors.org/</span></a></li><li id="u4d49a7c1" data-lake-index-type="0"><span class="ne-text">贡献类型：</span><a href="https://allcontributors.org/docs/en/emoji-key" data-href="https://allcontributors.org/docs/en/emoji-key" target="_blank" class="ne-link"><span class="ne-text">https://allcontributors.org/docs/en/emoji-key</span></a></li></ul></div>]]></content:encoded>
      
      
      <category domain="https://www.wztlink1013.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B4%A0%E5%85%BB/">计算机素养</category>
      
      <category domain="https://www.wztlink1013.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B4%A0%E5%85%BB/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/">软件工程</category>
      
      
      
      <comments>https://www.wztlink1013.com/blog/wgervpvkdaoc42ml/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Github Actions自动部署项目到云服务器</title>
      <link>https://www.wztlink1013.com/blog/cgo5a1ofo4g7612b/</link>
      <guid>https://www.wztlink1013.com/blog/cgo5a1ofo4g7612b/</guid>
      <pubDate>Wed, 28 Feb 2024 22:27:42 GMT</pubDate>
      
        
        
          
          
      <description>&lt;!doctype html&gt;&lt;div class=&quot;lake-content&quot; typography=&quot;classic&quot;&gt;&lt;p id=&quot;ue2cb4a43&quot; class=&quot;ne-p&quot;&gt;&lt;img</description>
          
        
      
      
      
      <content:encoded><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="ue2cb4a43" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2024/png/1484158/1709186151285-0873ba2c-2ec2-49c1-a9f7-91971c51460f.png" width="1579.1666039162237" id="uc3d67a17" class="ne-image"></p><p id="uf4d7e961" class="ne-p"><span class="ne-text">前言：项目部署至服务器，一般而言，只需要将打包后的静态代码上传到服务器指定位置，如果配置的是nginx web服务器，再执行刷新相关命令即可。本文记录1panel运维管理面板下，结合GitHub Action自动化部署项目打包代码至云服务器的脚本编写逻辑。</span></p><h3 id="ikwbc"><span class="ne-text">一、GitHub Actions环境准备</span></h3><p id="uf7143646" class="ne-p"><span class="ne-text">GitHub Actions脚本的执行涉及一些敏感变量，在GitHub仓库中可以设置隐形变量防止暴露在外，只有在 GitHub Actions 中才能使用到</span></p><p id="ua08b3c13" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2024/png/1484158/1709183847317-5c3b51ab-6524-4443-88eb-3c361a32e1cc.png" width="1111.6666224930038" id="u294f3f6d" class="ne-image"></p><p id="u197af0e8" class="ne-p"><span class="ne-text">环境变量含义：</span></p><ol class="ne-ol"><li id="uf855a872" data-lake-index-type="0"><span class="ne-text">KEY（密钥）</span></li><li id="ub493d228" data-lake-index-type="0"><span class="ne-text">PASSPHRASE（加密私钥的密码）</span></li><li id="udd55ac46" data-lake-index-type="0"><span class="ne-text">SERVER_IP（云服务器公网IP）</span></li><li id="udc38e6a5" data-lake-index-type="0"><span class="ne-text">USERNAME（云服务器登录用户名， 通常为root）</span></li></ol><div data-type="color2" class="ne-alert"><p id="u75ef5804" class="ne-p"><span class="ne-text">📌</span><span class="ne-text"> </span><code class="ne-code"><span class="ne-text">KEY</span></code><span class="ne-text">和</span><code class="ne-code"><span class="ne-text">PASSPHRASE</span></code><span class="ne-text">分别为下面截图中的2和1</span></p></div><p id="u99f5b2c5" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2024/png/1484158/1708961842486-da9a4392-86a2-4f32-92ef-06702be0a712.png" width="986.9921875" id="ub4020674" class="ne-image"></p><h3 id="LqgtN"><span class="ne-text">二、GitHub Actions脚本编写</span></h3><p id="uda06d594" class="ne-p"><span class="ne-text">脚本需要做的事情有如下几点：</span></p><ol class="ne-ol"><li id="uf66054c0" data-lake-index-type="0"><span class="ne-text">项目打包成静态文件</span></li><li id="u3e5cf593" data-lake-index-type="0"><span class="ne-text">将打包后的静态文件上传至云服务器指定文件夹</span></li></ol><h4 id="liMcO"><span class="ne-text">打包成静态文件</span></h4><p id="u5407fa59" class="ne-p"><span class="ne-text">执行项目打包命令</span></p><pre><code><code>- name: Use Node.js $&#123;&#123; matrix.node-version &#125;&#125;  uses: actions/setup-node@v4  with:    node-version: $&#123;&#123; matrix.node-version &#125;&#125;    cache: 'pnpm'- run: |    pnpm install    pnpm build    mv apps/test-project/dist/ ./dist/</code></code></pre><h4 id="cUm29"><span class="ne-text">上传服务器</span></h4><p id="uf88c8467" class="ne-p"><span class="ne-text">利用scp-action将指定文件夹上传至服务器目标文件夹</span></p><pre><code><code>- name: Scp file to aliyun  uses: appleboy/scp-action@v0.1.7  with:    host: $&#123;&#123; secrets.SERVER_IP &#125;&#125;    username: $&#123;&#123; secrets.USERNAME &#125;&#125;    key: $&#123;&#123; secrets.KEY &#125;&#125;    passphrase: $&#123;&#123; secrets.PASSPHRASE &#125;&#125;    tar_dereference: true    rm: true    source: 'dist/*'    target: '/opt/1panel/apps/openresty/openresty/www/sites/test.com/index'</code></code></pre><p id="u01903c90" class="ne-p"><span class="ne-text">上述脚本代码只是上传，不能在服务器进行相关命令操作文件，还需要利用ssh-action添加如下脚本：</span></p><pre><code><code>- name: executing remote ssh commands using key  uses: appleboy/ssh-action@v1.0.3  with:    host: $&#123;&#123; secrets.SERVER_IP &#125;&#125;    username: $&#123;&#123; secrets.USERNAME &#125;&#125;    key: $&#123;&#123; secrets.KEY &#125;&#125;    passphrase: $&#123;&#123; secrets.PASSPHRASE &#125;&#125;    script: |      mv /opt/1panel/apps/openresty/openresty/www/sites/test.com/index/dist/* /opt/1panel/apps/openresty/openresty/www/sites/test.com/index/</code></code></pre><p id="u404b835b" class="ne-p"><span class="ne-text">这个脚本主要作用是将文件内容层级提升</span></p><div data-type="color2" class="ne-alert"><p id="u8cb3c33d" class="ne-p"><strong><span class="ne-text">因为本文章记录的是基于集成环境前端项目部署，只是打包后静态文件的替换，所以不涉及重启相关命令操作。</span></strong></p><p id="u181eb354" class="ne-p"><strong><span class="ne-text">如果你的环境不是继承运维面板（1panel/宝塔 等）的web服务器，而是手动搭建web服务器，则在这里可以写一些相关命令，比如nginx重启、node重启、docker重启指定容器……</span></strong></p><p id="ue84e02ee" class="ne-p"><strong><span class="ne-text">eg：</span></strong><code class="ne-code"><strong><span class="ne-text">docker restart project-name</span></strong></code></p></div><h3 id="m2XDQ"><span class="ne-text">三、最终代码</span></h3><ul class="ne-ul"><li id="u4b51c945" data-lake-index-type="0"><span class="ne-text">在GitHub仓库内添加文件</span><code class="ne-code"><span class="ne-text">.github/workflows/server.yml</span></code></li><li id="uccbf07d8" data-lake-index-type="0"><span class="ne-text">结合上述各个步骤的子代码，再添加部分GitHub Actions触发条件逻辑代码，整个脚本文件就完成了。</span></li></ul><pre><code><code>name: Aliyun Server Deployon:  push:    tags:      - release-**<p>jobs:<br>  deploy_job:<br>    runs-on: ubuntu-latest<br>    name: build<br>    steps:<br>      - uses: actions/checkout@v4<br>      - uses: pnpm/action-setup@v2<br>        with:<br>          version: 8<br>      - name: Use Node.js $&#123;&#123; matrix.node-version &#125;&#125;<br>        uses: actions/setup-node@v4<br>        with:<br>          node-version: $&#123;&#123; matrix.node-version &#125;&#125;<br>          cache: ‘pnpm’<br>      - run: |<br>          pnpm install<br>          pnpm build<br>          mv apps/test-project/dist/ ./dist/</p><pre><code>  - name: Scp file to aliyun    uses: appleboy/scp-action@v0.1.7    with:      host: $&#123;&#123; secrets.SERVER_IP &#125;&#125;      username: $&#123;&#123; secrets.USERNAME &#125;&#125;      key: $&#123;&#123; secrets.KEY &#125;&#125;      passphrase: $&#123;&#123; secrets.PASSPHRASE &#125;&#125;      tar_dereference: true      rm: true      source: &#39;dist/*&#39;      target: &#39;/opt/1panel/apps/openresty/openresty/www/sites/test.com/index&#39;  - name: executing remote ssh commands using key    uses: appleboy/ssh-action@v1.0.3    with:      host: $&#123;&#123; secrets.SERVER_IP &#125;&#125;      username: $&#123;&#123; secrets.USERNAME &#125;&#125;      key: $&#123;&#123; secrets.KEY &#125;&#125;      passphrase: $&#123;&#123; secrets.PASSPHRASE &#125;&#125;      script: |        mv /opt/1panel/apps/openresty/openresty/www/sites/test.com/index/dist/* /opt/1panel/apps/openresty/openresty/www/sites/test.com/index/&lt;/code&gt;</code></pre><p></code></pre></p><h3 id="JO08d"><span class="ne-text">四、参考</span></h3><ul class="ne-ul"><li id="ubd920933" data-lake-index-type="0"><a href="https://github.com/appleboy/scp-action" data-href="https://github.com/appleboy/scp-action" target="_blank" class="ne-link"><span class="ne-text">https://github.com/appleboy/scp-action</span></a></li><li id="u45a62d3b" data-lake-index-type="0"><a href="https://github.com/appleboy/ssh-action" data-href="https://github.com/appleboy/ssh-action" target="_blank" class="ne-link"><span class="ne-text">https://github.com/appleboy/ssh-action</span></a></li><li id="u94d8d882" data-lake-index-type="0"><a href="https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows" data-href="https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows" target="_blank" class="ne-link"><span class="ne-text">https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows</span></a></li></ul></div>]]></content:encoded>
      
      
      <category domain="https://www.wztlink1013.com/categories/Web%E5%BC%80%E5%8F%91/">Web开发</category>
      
      <category domain="https://www.wztlink1013.com/categories/Web%E5%BC%80%E5%8F%91/DevOps/">DevOps</category>
      
      
      
      <comments>https://www.wztlink1013.com/blog/cgo5a1ofo4g7612b/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Hexo优化网站SEO</title>
      <link>https://www.wztlink1013.com/blog/ymz4rr2wyxrxktqd/</link>
      <guid>https://www.wztlink1013.com/blog/ymz4rr2wyxrxktqd/</guid>
      <pubDate>Sun, 14 Jan 2024 02:06:51 GMT</pubDate>
      
        
        
          
          
      <description>&lt;!doctype html&gt;&lt;div class=&quot;lake-content&quot; typography=&quot;classic&quot;&gt;&lt;p id=&quot;ub944b1e4&quot; class=&quot;ne-p&quot;&gt;&lt;span</description>
          
        
      
      
      
      <content:encoded><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="ub944b1e4" class="ne-p"><span class="ne-text">前言：提高搜索引擎对网站的抓取质量，从以下两个文件入手：</span></p><ol class="ne-ol"><li id="u9472c50c" data-lake-index-type="0"><span class="ne-text">sitemap文件</span></li><li id="u3a99adbb" data-lake-index-type="0"><span class="ne-text">Robots.txt</span></li></ol><h3 id="DwDU8"><span class="ne-text">sitemap</span></h3><p id="u88ae2110" class="ne-p"><span class="ne-text">sitemap是一种包含网站所有页面URL的文件，有助于搜索引擎更快地索引和发现您的网站，其格式有xml或txt。在Hexo中，可以利用</span><a href="https://github.com/hexojs/hexo-generator-sitemap" data-href="https://github.com/hexojs/hexo-generator-sitemap" target="_blank" class="ne-link"><span class="ne-text">hexo-generator-sitemap</span></a><span class="ne-text">插件生成sitemap文件。</span></p><h4 id="xAlnz"><span class="ne-text">基本使用</span></h4><pre><code><code>npm i hexo-generator-sitemap --save</code></code></pre><p id="ud9d657b1" class="ne-p"><span class="ne-text">参数配置，具体使用参考文档：</span><a href="https://github.com/hexojs/hexo-generator-sitemap/tree/master?tab=readme-ov-file#options" data-href="https://github.com/hexojs/hexo-generator-sitemap/tree/master?tab=readme-ov-file#options" target="_blank" class="ne-link"><span class="ne-text">https://github.com/hexojs/hexo-generator-sitemap/tree/master?tab=readme-ov-file#options</span></a></p><pre><code><code>sitemap:  path: sitemap.xml  tags: false  categories: false  template: ./template/sitemap.xml</code></code></pre><p id="u06f186d4" class="ne-p"><span class="ne-text">生成后的sitemap文件如下：</span></p><pre><code><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;urlset xmlns=&quot;http://www.sitemaps.org/schemas/sitemap/0.9&quot;&gt;  &lt;url&gt;    &lt;loc&gt;https://www.wztlink1013.com/blog/tttk33/&lt;/loc&gt;    &lt;lastmod&gt;2024-01-14&lt;/lastmod&gt;    &lt;changefreq&gt;weekly&lt;/changefreq&gt;    &lt;priority&gt;0.8&lt;/priority&gt;  &lt;/url&gt;  &lt;url&gt;    &lt;loc&gt;https://www.wztlink1013.com/&lt;/loc&gt;    &lt;lastmod&gt;2024-01-14&lt;/lastmod&gt;    &lt;changefreq&gt;daily&lt;/changefreq&gt;    &lt;priority&gt;1.0&lt;/priority&gt;  &lt;/url&gt;&lt;/urlset&gt;</code></code></pre><ul class="ne-ul"><li id="uca43eeff" data-lake-index-type="0"><span class="ne-text">loc：抓取的网站子页url</span></li><li id="u1b2973d2" data-lake-index-type="0"><span class="ne-text">lastmod：改子页最新一次更新时间</span></li><li id="uc5f01609" data-lake-index-type="0"><span class="ne-text">changefreq：改子页更新频率</span></li><li id="u77e95919" data-lake-index-type="0"><span class="ne-text">priority：在该站点的抓取优先级权重</span></li></ul><h4 id="SEC0C"><span class="ne-text">自定义生成模板</span></h4><p id="u44db15c2" class="ne-p"><span class="ne-text" style="background-color: #FBDE28"></span><span class="ne-text">在项目根路径创建</span><code class="ne-code"><span class="ne-text">template/sitemap.xml</span></code><span class="ne-text">文件，并写入下面代码</span></p><pre><code><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;urlset xmlns=&quot;http://www.sitemaps.org/schemas/sitemap/0.9&quot;&gt;  &#123;% for post in posts %&#125;  &lt;url&gt;    &lt;loc&gt;&#123;&#123; post.permalink | uriencode &#125;&#125;&lt;/loc&gt;&#123;% if post.updated %&#125;    &lt;lastmod&gt;&#123;&#123; post.updated | formatDate &#125;&#125;&lt;/lastmod&gt;&#123;% elif post.date %&#125;    &lt;lastmod&gt;&#123;&#123; post.date | formatDate &#125;&#125;&lt;/lastmod&gt;&#123;% endif %&#125;    &lt;changefreq&gt;weekly&lt;/changefreq&gt;    &lt;priority&gt;0.8&lt;/priority&gt;  &lt;/url&gt;  &#123;% endfor %&#125;<p>  &lt;url&gt;<br>    &lt;loc&gt;&#123;&#123; config.url | uriencode &#125;&#125;&lt;/loc&gt;<br>    &lt;lastmod&gt;&#123;&#123; sNow | formatDate &#125;&#125;&lt;/lastmod&gt;<br>    &lt;changefreq&gt;daily&lt;/changefreq&gt;<br>    &lt;priority&gt;1.0&lt;/priority&gt;<br>  &lt;/url&gt;</p>  &#123;% for tag in tags %&#125;  &lt;url&gt;    &lt;loc&gt;&#123;&#123; tag.permalink | uriencode &#125;&#125;&lt;/loc&gt;    &lt;lastmod&gt;&#123;&#123; sNow | formatDate &#125;&#125;&lt;/lastmod&gt;    &lt;changefreq&gt;weekly&lt;/changefreq&gt;    &lt;priority&gt;0.2&lt;/priority&gt;  &lt;/url&gt;  &#123;% endfor %&#125;  &#123;% for cat in categories %&#125;  &lt;url&gt;    &lt;loc&gt;&#123;&#123; cat.permalink | uriencode &#125;&#125;&lt;/loc&gt;    &lt;lastmod&gt;&#123;&#123; sNow | formatDate &#125;&#125;&lt;/lastmod&gt;    &lt;changefreq&gt;weekly&lt;/changefreq&gt;    &lt;priority&gt;0.2&lt;/priority&gt;  &lt;/url&gt;  &#123;% endfor %&#125;<p>&lt;/urlset&gt;</code><br></code></pre></p><h4 id="kvZtE"><span class="ne-text">指定页面跳过sitemap收录</span></h4><p id="u0be81d58" class="ne-p"><span class="ne-text">在hexo中的文章或是页面，可以如下配置：</span></p><pre><code><code>---title: 隐藏文章date: 2024-01-14sitemap: false---</code></code></pre><h3 id="qE3ji"><span class="ne-text">robots.txt</span></h3><p id="u9a756fc4" class="ne-p"><span class="ne-text">robots文件是一个文本文件，用于向搜索引擎指示哪些页面可以访问和索引，哪些页面应该被忽略。通过优化 robots文件，可以提高网站在搜索引擎中的排名和曝光度。</span></p><pre><code><code># https://www.wztlink1013.comUser-agent: *Disallow: /Sitemap: https://www.wztlink1013.com/sitemap.xml</code></code></pre><ul class="ne-ul"><li id="u7e1ac461" data-lake-index-type="0"><span class="ne-text">User-agent：* 表示允许所有搜索引擎访问您的网站，如果限定的话，则键入 </span><code class="ne-code"><span class="ne-text">[搜索引擎名称]</span></code></li><li id="ue346fd0f" data-lake-index-type="0"><span class="ne-text">Sitemap：说明sitemap文件url</span></li><li id="udac61ea6" data-lake-index-type="0"><span class="ne-text">Disallow：</span><code class="ne-code"><span class="ne-text">/</span></code><span class="ne-text">表示禁止该搜索引擎访问您的网站中所有页面和文件</span></li></ul><div class="ne-quote"><ul class="ne-ul"><li id="ub8c27d16" data-lake-index-type="0"><span class="ne-text">检测自己写的robots文件是否生效：</span><a href="https://ziyuan.baidu.com/robots/intro" data-href="https://ziyuan.baidu.com/robots/intro" target="_blank" class="ne-link"><span class="ne-text">https://ziyuan.baidu.com/robots/intro</span></a><span class="ne-text"></span></li><li id="ub1d1e5aa" data-lake-index-type="0"><span class="ne-text">语法规则：</span><a href="https://ziyuan.baidu.com/college/courseinfo?id=267&amp;page=13" data-href="https://ziyuan.baidu.com/college/courseinfo?id=267&amp;page=13" target="_blank" class="ne-link"><span class="ne-text">https://ziyuan.baidu.com/college/courseinfo?id=267&amp;page=13</span></a></li></ul></div><p id="ufb489ca3" class="ne-p"><br></p><h3 id="NzJnY"><span class="ne-text">❗</span><span class="ne-text">百度不再允许大多数站点提交sitemap文件</span></h3><p id="u7080f3da" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2024/png/1484158/1705232927775-66b2b6e8-1f1c-40aa-a427-c3e9b59d680d.png" width="1098.3332896894897" id="u41efa066" class="ne-image"></p><p id="uadbf9159" class="ne-p"><span class="ne-text">如果之前没有提交过sitemap链接的，貌似没有办法提交sitemap链接了，如果之前提交过应该不受影响。。。</span></p></div>]]></content:encoded>
      
      
      <category domain="https://www.wztlink1013.com/categories/Web%E5%BC%80%E5%8F%91/">Web开发</category>
      
      <category domain="https://www.wztlink1013.com/categories/Web%E5%BC%80%E5%8F%91/%E5%8D%9A%E5%AE%A2%E6%8A%80%E6%9C%AF/">博客技术</category>
      
      
      
      <comments>https://www.wztlink1013.com/blog/ymz4rr2wyxrxktqd/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>2645. 构造有效字符串的最少插入数🔖DP🔖穷举</title>
      <link>https://www.wztlink1013.com/blog/lk1vbtcuw7ox57do/</link>
      <guid>https://www.wztlink1013.com/blog/lk1vbtcuw7ox57do/</guid>
      <pubDate>Sat, 13 Jan 2024 04:20:10 GMT</pubDate>
      
        
        
          
          
      <description>&lt;!doctype html&gt;&lt;div class=&quot;lake-content&quot; typography=&quot;classic&quot;&gt;&lt;ul class=&quot;ne-ul&quot;&gt;&lt;li id=&quot;u8c63af56&quot; data-lake-index-type=&quot;0&quot;&gt;&lt;span</description>
          
        
      
      
      
      <content:encoded><![CDATA[<!doctype html><div class="lake-content" typography="classic"><ul class="ne-ul"><li id="u8c63af56" data-lake-index-type="0"><span class="ne-text">题目：</span><a href="https://leetcode.cn/problems/minimum-additions-to-make-valid-string/" data-href="https://leetcode.cn/problems/minimum-additions-to-make-valid-string/" target="_blank" class="ne-link"><span class="ne-text">https://leetcode.cn/problems/minimum-additions-to-make-valid-string/</span></a></li></ul><p id="u805fc1c7" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2024/png/1484158/1705311894805-a68668b9-a6dc-4255-9eb8-11ab3d63453d.png" width="574.0741146281288" id="u153e480d" class="ne-image"></p><h3 id="gjP8I"><span class="ne-text">动态规划</span></h3><p id="u4c885b04" class="ne-p"><span class="ne-text">DP问题，两个步骤：</span></p><ol class="ne-ol"><li id="u67367468" data-lake-index-type="0"><span class="ne-text" style="background-color: #FBDE28">状态转移方程</span></li></ol><p id="u612b02d8" class="ne-p"><span class="ne-text">第一项作为边界情况，暂不考虑，从第二项往后看，三项之间的规律:</span></p><ul class="ne-ul"><li id="ue5e3da76" data-lake-index-type="0"><span class="ne-text">当</span><code class="ne-code"><span class="ne-text">i-1</span></code><span class="ne-text">项&gt;</span><code class="ne-code"><span class="ne-text">i-2</span></code><span class="ne-text">项：需要剪掉一个完整abc整体，即</span><code class="ne-code"><span class="ne-text">f(i) = f(i-1) - 1</span></code></li><li id="u303c6bc6" data-lake-index-type="0"><span class="ne-text">其余情况：</span><code class="ne-code"><span class="ne-text">f(i) = f(i-1) + 2</span></code></li></ul><ol start="2" class="ne-ol"><li id="u3bd15099" data-lake-index-type="0"><span class="ne-text" style="background-color: #FBDE28">初始状态</span></li></ol><p id="u10e133f3" class="ne-p"><span class="ne-text">第一项默认填充一个完整的abc</span></p><pre><code><code>function addMinimum(word: string): number &#123;  const n = word.length;  const arr = new Array(n + 1).fill(0);  for (let i = 1; i &lt;= n; i++)     arr[i] = i &gt; 1 &amp;&amp; word[i - 2] &lt; word[i - 1] ? arr[i - 1] - 1 : arr[i - 1] + 2  return arr[n]&#125;;</code></code></pre><h3 id="kXkn9"><span class="ne-text">穷举算法</span></h3><pre><code><code>function addMinimum(word: string): number &#123;  if (!word.replaceAll('abc', '').length) return 0  let count = 0;  for (let i = 0; i &lt; word.length; i++) &#123;    const curr = word[i]    const next = i + 1 !== word.length ? word[i + 1] : null    if (i === 0) &#123;      if (curr === 'b') &#123;        count = count + 1      &#125; else if (curr === 'c') &#123;        count = count + 2      &#125;    &#125;    if (next) &#123;      if (curr === 'a') &#123;        if (next === 'a')&#123;          count = count + 2        &#125; else if (next === 'c') &#123;          count = count + 1        &#125;      &#125; else if (curr === 'b') &#123;        if (next === 'a')&#123;          count = count + 1        &#125; else if (next === 'b') &#123;          count = count + 2        &#125;       &#125; else if (curr === 'c') &#123;        if (next === 'b') &#123;          count = count + 1        &#125; else if (next === 'c') &#123;          count = count + 2        &#125;      &#125;    &#125; else &#123;      if (curr === 'b') &#123;        count = count + 1      &#125; else if (curr === 'a') &#123;        count = count + 2      &#125;    &#125;  &#125;  return count&#125;;</code></code></pre></div>]]></content:encoded>
      
      
      <category domain="https://www.wztlink1013.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B4%A0%E5%85%BB/">计算机素养</category>
      
      <category domain="https://www.wztlink1013.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B4%A0%E5%85%BB/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</category>
      
      <category domain="https://www.wztlink1013.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B4%A0%E5%85%BB/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%F0%9F%94%A2%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AE%97%E6%B3%95/">🔢动态规划算法</category>
      
      
      
      <comments>https://www.wztlink1013.com/blog/lk1vbtcuw7ox57do/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>React系统学习（三）组件通信</title>
      <link>https://www.wztlink1013.com/blog/ugugf75zazxyxy8t/</link>
      <guid>https://www.wztlink1013.com/blog/ugugf75zazxyxy8t/</guid>
      <pubDate>Tue, 02 Jan 2024 16:35:41 GMT</pubDate>
      
        
        
          
          
      <description>&lt;!doctype html&gt;&lt;div class=&quot;lake-content&quot; typography=&quot;classic&quot;&gt;&lt;h3 id=&quot;Hp11O&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;父传子（Props）&lt;/span&gt;&lt;/h3&gt;&lt;p id=&quot;u33a79e2b&quot;</description>
          
        
      
      
      
      <content:encoded><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h3 id="Hp11O"><span class="ne-text">父传子（Props）</span></h3><p id="u33a79e2b" class="ne-p"><span class="ne-text">利用props传值</span></p><ol class="ne-ol"><li id="u1fc1373b" data-lake-index-type="0"><span class="ne-text">组件默认值的写法</span></li></ol><ol start="2" class="ne-ol"><li id="u65cf9e83" data-lake-index-type="0"><span class="ne-text">点标记写法就相当于组件作为一个对象值</span></li></ol><pre><code><code>const Son = (props: any) =&gt; &#123;  console.log('parent to son: ', props);  return &lt;div&gt;son&lt;/div&gt;;&#125;;// Son default propsSon.defaultProps = &#123;  msg: 'son-default-msg',&#125;;<p>export default () =&gt; &#123;<br>  const [parentMsg, setParentMsg] = useState(‘parent-msg’);<br>  return (<br>    &lt;&gt;<br>      &lt;h1&gt;react-message&lt;/h1&gt;<br>      parent<br>      &lt;Son msg=&#123;parentMsg&#125; /&gt;<br>    &lt;/&gt;<br>  );<br>&#125;;<br></code><br></code></pre></p><h3 id="hSjM1"><span class="ne-text">子传父</span></h3><p id="u10d5d71a" class="ne-p"><span class="ne-text"> 在父组件定义响应式变量，同时传递一个回调函数参数给子组件，子组件再利用调用回调函数给便父组件所定义的响应式变量</span></p><pre><code><code>const Son = (props: any) =&gt; &#123;  console.log('parent to son: ', props.msg);  const sonToParentClick = () =&gt; &#123;    props.getSonValue('son-to-parent-msg');  &#125;;  return (    &lt;div&gt;      son&lt;button onClick=&#123;sonToParentClick&#125;&gt;son-to-parent&lt;/button&gt;    &lt;/div&gt;  );&#125;;Son.defaultProps = &#123;  msg: 'son-default-msg',&#125;;<p>export default () =&gt; &#123;<br>  const [parentToSonMsg, setParentToSonMsg] = useState(‘parent-to-son-msg’);<br>  const [getSonMsg, setGetSonMsg] = useState(‘’);<br>  const getSonValue = (msg: string) =&gt; &#123;<br>    console.log(‘son-to-parent-msg: ‘, msg);<br>    setGetSonMsg(msg);<br>  &#125;;<br>  return (<br>    &lt;&gt;<br>      &lt;h1&gt;react-message&lt;/h1&gt;<br>      parent<br>      &lt;Son msg=&#123;parentToSonMsg&#125; getSonValue=&#123;getSonValue&#125; /&gt;<br>    &lt;/&gt;<br>  );<br>&#125;;<br></code><br></code></pre></p><h3 id="C0st3"><span class="ne-text">爷传后代</span></h3><h4 id="XjAnb"><span class="ne-text">爷传孙</span></h4><ol class="ne-ol"><li id="u2c9e1c20" data-lake-index-type="0"><span class="ne-text">第一种方式就是利用剩余参数爷传子，子再传孙，不过这种方式繁琐且不便维护</span></li><li id="ub393f0aa" data-lake-index-type="0"><span class="ne-text">利用下面的透传方式</span></li></ol><h4 id="NgI5A"><span class="ne-text">透传（Context）</span></h4><pre><code><code>import &#123; createContext &#125; from 'react';<p>const Context = createContext(&#123;&#125;);</p><p>const Son = (props: any) =&gt; &#123;<br>  console.log(‘parent to son: ‘, props.msg);<br>  const sonToParentClick = () =&gt; &#123;<br>    props.getSonValue(‘son-to-parent-msg’);<br>  &#125;;<br>  return (<br>    &lt;&gt;<br>      &lt;div&gt;<br>        son&lt;button onClick=&#123;sonToParentClick&#125;&gt;son-to-parent&lt;/button&gt;<br>      &lt;/div&gt;<br>      &lt;GradeSon /&gt;<br>    &lt;/&gt;<br>  );<br>&#125;;<br>Son.defaultProps = &#123;<br>  msg: ‘son-default-msg’,<br>&#125;;</p><p>const GradeSon = () =&gt; &#123;<br>  const getGrandFather = useContext(Context);<br>  console.log(‘get-grand-father: ‘, getGrandFather);<br>  return &lt;div&gt;GradeSon&lt;/div&gt;;<br>&#125;;</p><p>export default () =&gt; &#123;<br>  const [parentToSonMsg, setParentToSonMsg] = useState(‘parent-to-son-msg’);<br>  const [parentToGradeSonMsg, setParentToGradeSonMsg] = useState(&#123; a: 11, b: 22 &#125;);<br>  const [getSonMsg, setGetSonMsg] = useState(‘’);<br>  const getSonValue = (msg: string) =&gt; &#123;<br>    console.log(‘son-to-parent-msg: ‘, msg);<br>    setGetSonMsg(msg);<br>  &#125;;<br>  return (<br>    &lt;Context.Provider value=&#123;parentToGradeSonMsg&#125;&gt;<br>      &lt;h1&gt;react-message&lt;/h1&gt;<br>      parent<br>      &lt;Son msg=&#123;parentToSonMsg&#125; getSonValue=&#123;getSonValue&#125; /&gt;<br>    &lt;/Context.Provider&gt;<br>  );<br>&#125;;<br></code><br></code></pre></p><h3 id="kPf70"><span class="ne-text">EventBus</span></h3><p id="u56c51230" class="ne-p"><span class="ne-text">事件总线的方式，其实这属于前端通用的一种设计模式，在线编辑器常用的一种代码设计模式</span></p><ol class="ne-ol"><li id="ue47632f0" data-lake-index-type="0"><span class="ne-text">事件封装：只封装了on、emit、off事件，实际上封装形式不一，也可以使用三方库等</span></li></ol><pre><code><code>type StringKeyOf&lt;T&gt; = Extract&lt;keyof T, string&gt;;type CallbackType&lt;  T extends Record&lt;string, any&gt;,  EventName extends StringKeyOf&lt;T&gt;,&gt; = T[EventName] extends any[] ? T[EventName] : [T[EventName]];type CallbackFunction&lt;T extends Record&lt;string, any&gt;, EventName extends StringKeyOf&lt;T&gt;&gt; = (  ...props: CallbackType&lt;T, EventName&gt;) =&gt; any;<p>export class EventEmitter&lt;T extends Record&lt;string, any&gt;&gt; &#123;<br>  private callbacks: &#123; [key: string]: Function[] &#125; = &#123;&#125;;</p><p>  public on&lt;EventName extends StringKeyOf&lt;T&gt;&gt;(<br>    event: EventName,<br>    fn: CallbackFunction&lt;T, EventName&gt;,<br>  ): this &#123;<br>    if (!this.callbacks[event]) &#123;<br>      this.callbacks[event] = [];<br>    &#125;</p><pre><code>this.callbacks[event].push(fn);return this;</code></pre><p>  }</p><p>  public emit&lt;EventName extends StringKeyOf&lt;T&gt;&gt;(<br>    event: EventName,<br>    …args: CallbackType&lt;T, EventName&gt;<br>  ): this {<br>    const callbacks = this.callbacks[event];</p><pre><code>if (callbacks) &#123;  callbacks.forEach(callback =&amp;gt; callback.apply(this, args));&#125;return this;</code></pre><p>  }</p><p>  public off&lt;EventName extends StringKeyOf&lt;T&gt;&gt;(<br>    event: EventName,<br>    fn?: CallbackFunction&lt;T, EventName&gt;,<br>  ): this {<br>    const callbacks = this.callbacks[event];</p><pre><code>if (callbacks) &#123;  if (fn) &#123;    this.callbacks[event] = callbacks.filter(callback =&amp;gt; callback !== fn);  &#125; else &#123;    delete this.callbacks[event];  &#125;&#125;return this;</code></pre><p>  }</p><p>  protected removeAllListeners(): void {<br>    this.callbacks = {};<br>  }<br>}</p><p>const EventBus = new EventEmitter();<br>export default EventBus;</code><br></code></pre></p><ol start="2" class="ne-ol"><li id="uc993bf4f" data-lake-index-type="0"><span class="ne-text">使用</span></li></ol><ol class="ne-list-wrap"><ol ne-level="1" class="ne-ol"><li id="uaaccabd0" data-lake-index-type="0"><span class="ne-text">Daughter组件定义，Son组件触发</span></li><li id="u16a192b3" data-lake-index-type="0"><span class="ne-text">有注册就要有注销，不然内存中会出现重复事件逻辑多次执行的问题</span></li></ol></ol><pre><code><code>import &#123; createContext &#125; from 'react';import EventBus from '@/utils/eventEmitter';<p>const Context = createContext(&#123;&#125;);</p><p>const Son = (props: any) =&gt; &#123;<br>  console.log(‘parent to son: ‘, props.msg);<br>  const sonToParentClick = () =&gt; &#123;<br>    props.getSonValue(‘son-to-parent-msg’);<br>    EventBus.emit(‘daughterEvent’, &#123;<br>      msg: ‘son-to-daughter-msg’,<br>    &#125;);<br>  &#125;;<br>  return (<br>    &lt;&gt;<br>      &lt;div&gt;<br>        son&lt;button onClick=&#123;sonToParentClick&#125;&gt;son-to-parent&lt;/button&gt;<br>      &lt;/div&gt;<br>      &lt;GradeSon /&gt;<br>    &lt;/&gt;<br>  );<br>&#125;;<br>Son.defaultProps = &#123;<br>  msg: ‘son-default-msg’,<br>&#125;;</p><p>const Daughter = () =&gt; &#123;<br>  useEffect(() =&gt; &#123;<br>    function daughterEvent(data: any) &#123;<br>      console.warn(‘daughter event: ‘, data);<br>    &#125;<br>    EventBus.on(‘daughterEvent’, daughterEvent);<br>    return () =&gt; &#123;<br>      EventBus.off(‘daughterEvent’, daughterEvent);<br>    &#125;;<br>  &#125;, []);<br>  return &lt;div&gt;Daughter&lt;/div&gt;;<br>&#125;;</p><p>const GradeSon = () =&gt; &#123;<br>  const getGrandFather = useContext(Context);<br>  console.log(‘get-grand-father: ‘, getGrandFather);<br>  return &lt;div&gt;GradeSon&lt;/div&gt;;<br>&#125;;</p><p>export default () =&gt; &#123;<br>  const [parentToSonMsg, setParentToSonMsg] = useState(‘parent-to-son-msg’);<br>  const [parentToGradeSonMsg, setParentToGradeSonMsg] = useState(&#123; a: 11, b: 22 &#125;);<br>  const [getSonMsg, setGetSonMsg] = useState(‘’);<br>  const getSonValue = (msg: string) =&gt; &#123;<br>    console.log(‘son-to-parent-msg: ‘, msg);<br>    setGetSonMsg(msg);<br>  &#125;;<br>  return (<br>    &lt;&gt;<br>      &lt;Context.Provider value=&#123;parentToGradeSonMsg&#125;&gt;<br>        &lt;h1&gt;react-message&lt;/h1&gt;<br>        parent<br>        &lt;Son msg=&#123;parentToSonMsg&#125; getSonValue=&#123;getSonValue&#125; /&gt;<br>      &lt;/Context.Provider&gt;<br>      &lt;Daughter /&gt;<br>    &lt;/&gt;<br>  );<br>&#125;;<br></code><br></code></pre></p><h3 id="DYES7"><span class="ne-text">状态管理</span></h3><p id="u2c679f4e" class="ne-p"><span class="ne-text">状态管理所定义的Module变化，所使用到的组件也会响应式更新，不做详细记录。</span></p></div>]]></content:encoded>
      
      
      <category domain="https://www.wztlink1013.com/categories/Web%E5%BC%80%E5%8F%91/">Web开发</category>
      
      <category domain="https://www.wztlink1013.com/categories/Web%E5%BC%80%E5%8F%91/React/">React</category>
      
      
      
      <comments>https://www.wztlink1013.com/blog/ugugf75zazxyxy8t/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>React系统学习（二）生态链</title>
      <link>https://www.wztlink1013.com/blog/okaxuuoq9kqk5hv3/</link>
      <guid>https://www.wztlink1013.com/blog/okaxuuoq9kqk5hv3/</guid>
      <pubDate>Mon, 01 Jan 2024 22:34:41 GMT</pubDate>
      
        
        
          
          
      <description>&lt;!doctype html&gt;&lt;div class=&quot;lake-content&quot; typography=&quot;classic&quot;&gt;&lt;p id=&quot;uf81223da&quot; class=&quot;ne-p&quot;&gt;&lt;span</description>
          
        
      
      
      
      <content:encoded><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="uf81223da" class="ne-p"><span class="ne-text">生态系统有服务端渲染等，暂只对路由以及状态管理做部分记录。</span></p><h3 id="RG1RA"><span class="ne-text">路由Router</span></h3><ol class="ne-ol"><li id="u8de104d9" data-lake-index-type="0"><span class="ne-text">useParams：获取动态路由的路径值</span></li><li id="u5450e7cd" data-lake-index-type="0"><span class="ne-text">&lt;NavLink /&gt;：带样式的声明式路由</span></li><li id="u4f82b40a" data-lake-index-type="0"><span class="ne-text">useNavigate：编程式路由</span></li></ol><ol class="ne-list-wrap"><ol ne-level="1" class="ne-ol"><li id="uf612b599" data-lake-index-type="0"><span class="ne-text">第一个参数：跳转路径</span></li><li id="ude9b2662" data-lake-index-type="0"><span class="ne-text">第二个参数（state）：携带信息对象</span></li></ol></ol><ol start="4" class="ne-ol"><li id="u918edaba" data-lake-index-type="0"><span class="ne-text">useLocation</span></li><li id="ue0f4492b" data-lake-index-type="0"><span class="ne-text">useSearchParams：可以结构，同useState，第二个参数同样可以设置浏览器地址栏的url params </span></li><li id="u859c95b4" data-lake-index-type="0"><span class="ne-text">lodaer：路由表的字段，路由跳转前的处理函数，支持异步，这里做调取权限查询接口等逻辑</span></li></ol><ol class="ne-list-wrap"><ol ne-level="1" class="ne-ol"><li id="ua7441b4e" data-lake-index-type="0"><span class="ne-text">如果返回值需要重定向指定url -&gt; </span><code class="ne-code"><span class="ne-text">return redirect('login')</span></code></li></ol></ol><ol start="7" class="ne-ol"><li id="u28cc1c98" data-lake-index-type="0"><span class="ne-text">meta：自定义元信息</span></li></ol><ol class="ne-list-wrap"><ol ne-level="1" class="ne-ol"><li id="u167efcc8" data-lake-index-type="0"><span class="ne-text">组件中获取元信息：matchRoutes和useLocation</span></li></ol></ol><span style="margin-left: 2em"><pre><code><code>const location = useLocation()const matchs = matchRoutes(routes, location)const meta = matchs[matchs.length - 1].route.meta</code></code></pre></span><h3 id="Cavfr"><span class="ne-text">状态管理Redux</span></h3><p id="ubbcb0f40" class="ne-p"><span class="ne-text">Redux是一个独立的状态管理的库。</span></p><ol class="ne-ol"><li id="u916db48f" data-lake-index-type="0"><span class="ne-text">react-redux：对于redux封装至更符合react理念的库</span></li></ol><ol class="ne-list-wrap"><ol ne-level="1" class="ne-ol"><li id="u056b4da4" data-lake-index-type="0"><span class="ne-text">useSelector</span></li><li id="ua86b158c" data-lake-index-type="0"><span class="ne-text">useDispatch</span></li></ol></ol><ol start="2" class="ne-ol"><li id="u7b50b918" data-lake-index-type="0"><span class="ne-text">Redux-Toolkit：</span></li></ol><ol class="ne-list-wrap"><ol ne-level="1" class="ne-ol"><li id="ucbbfbb0c" data-lake-index-type="0"><span class="ne-text">封装redux的大多数操作</span></li><li id="u4f0fc676" data-lake-index-type="0"><span class="ne-text">优化异步处理createAsyncThunk</span></li></ol></ol><ol start="3" class="ne-ol"><li id="u728fa4d6" data-lake-index-type="0"><span class="ne-text">redux-persist：数据持久化处理</span></li></ol><p id="ub8fac65f" class="ne-p"><span class="ne-text"></span></p><p id="uab0de432" class="ne-p"><span class="ne-text"></span></p><p id="u2486779b" class="ne-p"><span class="ne-text"></span></p><p id="u7573cf56" class="ne-p"><span class="ne-text"></span></p><p id="u10ec026e" class="ne-p"><span class="ne-text"></span></p><p id="u5e88c3f6" class="ne-p"><span class="ne-text"></span></p><p id="u4e1d4445" class="ne-p"><span class="ne-text"></span></p><p id="ue1c440ca" class="ne-p"><span class="ne-text"></span></p><p id="uf7d94f98" class="ne-p"><span class="ne-text"></span></p></div>]]></content:encoded>
      
      
      <category domain="https://www.wztlink1013.com/categories/Web%E5%BC%80%E5%8F%91/">Web开发</category>
      
      <category domain="https://www.wztlink1013.com/categories/Web%E5%BC%80%E5%8F%91/React/">React</category>
      
      
      
      <comments>https://www.wztlink1013.com/blog/okaxuuoq9kqk5hv3/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>React系统学习（一）类组件和函数组件</title>
      <link>https://www.wztlink1013.com/blog/wnb93ckult99ixhg/</link>
      <guid>https://www.wztlink1013.com/blog/wnb93ckult99ixhg/</guid>
      <pubDate>Sat, 23 Dec 2023 05:22:20 GMT</pubDate>
      
        
        
          
          
      <description>&lt;!doctype html&gt;&lt;div class=&quot;lake-content&quot; typography=&quot;classic&quot;&gt;&lt;div data-type=&quot;info&quot; class=&quot;ne-alert&quot;&gt;&lt;p id=&quot;u09f32c06&quot; class=&quot;ne-p&quot;&gt;&lt;span</description>
          
        
      
      
      
      <content:encoded><![CDATA[<!doctype html><div class="lake-content" typography="classic"><div data-type="info" class="ne-alert"><p id="u09f32c06" class="ne-p"><span class="ne-text">官方文档：</span><a href="https://react.docschina.org/" data-href="https://react.docschina.org/" class="ne-link"><span class="ne-text">React 官方中文文档</span></a></p></div><h3 id="xVmON"><span class="ne-text">虚拟DOM以及React挂载DOM的方式</span></h3><ol class="ne-ol"><li id="u0893e863" data-lake-index-type="0"><span class="ne-text">利用JavaScript脚本操作DOM的行为是性能损耗的大头，故产生虚拟DOM的概念。初始化在内存中得到相应的虚拟DOM树，然后将该结果一次性作用于真实DOM，逻辑层的变动导致部分视图层的改变这渲染逻辑也是经过虚拟DOM加上diff得到一次性结果然后作用于真实DOM，在这里Vue和React都是一样的。</span></li><li id="u7537df37" data-lake-index-type="0"><span class="ne-text">可以简单理解：react模块旨在完成虚拟dom的相关逻辑，react-dom模块旨在完成真实DOM和diff的处理</span></li></ol><pre><code><code>// mount containerrootReactDOM.createRoot(document.querySelector('#root'))// create VDOMconst data = React.createElement('div', &#123;&#125;, 'data')// VDOM -&gt; true DOMroot.render(data)</code></code></pre><h3 id="vL2nu"><span class="ne-text">JSX</span></h3><p id="u20bc5507" class="ne-p"><span class="ne-text">上述ReactDOM生成虚拟DOM的方式，实际编写代码不方便，于是出现了类似JSX来简化视图层的代码编写（Vue中利用Template模板来完成相同视图层的逻辑构建）</span></p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/1484158/1703514464788-2de399dc-93ec-4dec-aa38-e6b6c706f0ea.jpeg" id="iIrkc" style="display: block; width: 100%"><ol start="2" class="ne-ol"><li id="uec638825" data-lake-index-type="0"><span class="ne-text">JSX的识别要么在jsx后缀文件书写相关代码逻辑，要么利用babel工具来进行代码转义..</span></li></ol><pre><code><code>const data = (  &lt;div&gt;    content&lt;span&gt;something...&lt;/span&gt;  &lt;/div&gt;)root.render(data)</code></code></pre><ol start="3" class="ne-ol"><li id="u5676031e" data-lake-index-type="0"><span class="ne-text">模板语法：</span><code class="ne-code"><span class="ne-text">&#123;&#125;</span></code><span class="ne-text">，Vue是是</span><code class="ne-code"><span class="ne-text">&#123;&#123;&#125;&#125;</span></code></li></ol><ol class="ne-list-wrap"><ol ne-level="1" class="ne-ol"><li id="u9c91fce8" data-lake-index-type="0"><span class="ne-text">注释：</span><code class="ne-code"><span class="ne-text">&#123;/* */&#125;</span></code></li><li id="ubb6f0de2" data-lake-index-type="0"><span class="ne-text">内容可以变量、函数、JSX嵌套 ······</span></li></ol></ol><ol start="4" class="ne-ol"><li id="u77d43f1f" data-lake-index-type="0"><span class="ne-text">JSX注意事项</span></li></ol><ol class="ne-list-wrap"><ol ne-level="1" class="ne-ol"><li id="u8c6babba" data-lake-index-type="0"><span class="ne-text">严格单标签（</span><code class="ne-code"><span class="ne-text">&lt;Tab /&gt;</span></code><span class="ne-text">）</span></li><li id="ub546b2eb" data-lake-index-type="0"><span class="ne-text">标签名小写</span></li><li id="u0a3d772d" data-lake-index-type="0"><span class="ne-text">唯一根节点 -&gt; </span><code class="ne-code"><span class="ne-text">&lt;&gt;&lt;/&gt;</span></code><span class="ne-text"> 或 </span><code class="ne-code"><span class="ne-text">React.Fragment</span></code></li><li id="u3a39620f" data-lake-index-type="0"><span class="ne-text">部分HTML属性名变动：</span><code class="ne-code"><span class="ne-text">class -&gt; className</span></code><span class="ne-text">; </span><code class="ne-code"><span class="ne-text">for -&gt; htmlFor</span></code><span class="ne-text"> ······</span></li><li id="u70ef716d" data-lake-index-type="0"><span class="ne-text">多单词属性用驼峰方式书写，dataset除外</span></li></ol></ol><h3 id="E1Lfq"><span class="ne-text">理解类组件</span></h3><ol class="ne-ol"><li id="ud1f196e0" data-lake-index-type="0"><span class="ne-text">组件的概念也就是模块的拆分、抽象和复用，和Vue组件一致，React的组件编写有两种，</span><strong><span class="ne-text">类组件</span></strong><span class="ne-text">和</span><strong><span class="ne-text">函数组件</span></strong><span class="ne-text">，实际编写代码，React18函数式组件编写更为推崇，但是理解上以类组件会更好。</span></li><li id="u73a8c970" data-lake-index-type="0"><span class="ne-text">具体类组件的编写，其实就是在面向对象编程，给你一个已知类React.Component，写具体逻辑时，遵照所继承的类的一些规则来扩展业务代码。</span></li></ol><h4 id="qjAcc"><span class="ne-text">简单的父子通信</span></h4><pre><code><code>// A componentclass A extends React.Component &#123;  constructor(props) &#123;    super(props)    this.props = props  &#125;  render &#123;    this.props.getData('data')    return (      &lt;div&gt;A component &#123;this.props.info&#125; &lt;/div&gt;    )  &#125;&#125;// B componentconst getData = (data) =&gt; &#123;  // result -&gt; data&#125;const data = &lt;div&gt;content &lt;A info='something' getData=&#123;getData&#125; /&gt; &lt;/div&gt;</code></code></pre><h4 id="Mh3VX"><span class="ne-text">props相关事项</span></h4><ol class="ne-ol"><li id="u64411e8a" data-lake-index-type="0"><span class="ne-text">传入组件的参数可以用扩展运算符来传入</span></li></ol><pre><code><code>const data = &#123;  info: 'something,  getData: (data) =&gt; &#123;&#125;,&#125;const data = &lt;div&gt;&lt;A &#123;...data&#125; /&gt;&lt;/div&gt;</code></code></pre><ol start="2" class="ne-ol"><li id="u855e1be4" data-lake-index-type="0"><span class="ne-text">单独属性值为true</span></li><li id="uf093ffd6" data-lake-index-type="0"><span class="ne-text">类组件的默认值</span></li></ol><pre><code><code>// A componentclass A extends React.Component &#123;  static defaultProps = &#123;    info: 'default info',  &#125;  constructor(props) &#123;    super(props)    this.props = props  &#125;  render &#123;    this.props.getData('data')    return (      &lt;div&gt;A component &#123;this.props.info&#125; &lt;/div&gt;    )  &#125;&#125;</code></code></pre><h4 id="PV0r6"><span class="ne-text">响应式变量</span></h4><p id="uc9c5250a" class="ne-p"><span class="ne-text">前端框架必须具体的一个能力就是响应式变量的构造，以及内部实现的动态渲染，react的响应式变量就是构造类的一个私有变量state，再利用其规定指定的方法setState方法来实现响应式</span></p><pre><code><code>class A extends React.Component &#123;  state &#123;    a: 1,  &#125;  static defaultProps = &#123;    info: 'default info',  &#125;  constructor(props) &#123;    super(props)    this.props = props  &#125;  render &#123;    this.props.getData('data')    return (      &lt;div&gt;A component &#123;this.props.info&#125; &lt;/div&gt;    )  &#125;handleMethod() &#123;    this.setState(&#123; a: 2 &#125;)&#125;&#125;</code></code></pre><div data-type="info" class="ne-alert"><p id="ub5f23f2f" class="ne-p"><span class="ne-text">如果响应式的值为数组呢？</span></p></div><ol class="ne-ol"><li id="ued321890" data-lake-index-type="0"><span class="ne-text">react里面的响应式的值为不可变数据集合，比较简单的情况可以利用剩余参数来解决该问题。</span></li></ol><pre><code><code>class A extends React.Component &#123;  state =&#123;    a: [1, 2, 3]  &#125;  ···  handleMethod() &#123;    this.setState(&#123; a: [...a, 4] &#125;)  &#125;&#125;</code></code></pre><ol start="2" class="ne-ol"><li id="ubcbe280c" data-lake-index-type="0"><span class="ne-text">深拷贝</span></li></ol><p id="uee425f9f" class="ne-p"><span class="ne-text">（TODO:  应该有更好的解决方式）</span></p><h4 id="xfck5"><span class="ne-text">批处理</span></h4><p id="ufd1bdefd" class="ne-p"><span class="ne-text">响应式处理，内部会一次性收集当前变化的量，进入一个处理队列，最终得到一个最终态来进行渲染，避免状态改变多次渲染的情况。</span></p><ol class="ne-ol"><li id="u0706a769" data-lake-index-type="0"><span class="ne-text">React18之前，在一些函数执行时机下，不会进行批处理，React18之后解决了这个问题。具体有：Promise、setTimeout、原生事件下</span></li><li id="u4bc7f994" data-lake-index-type="0"><span class="ne-text">React提供了防止批处理的函数</span></li></ol><pre><code><code>class A extends React.Component &#123;  state =&#123;    a: 1  &#125;  ···  handleMethod() &#123;    ReactDOM.flushSync(() =&gt; &#123;      this.setState(&#123; a: this.state.a + 1 &#125;)      this.setState(&#123; a: this.state.a + 1 &#125;)    &#125;)    // result: run twice render method...  &#125;  render &#123;    console.info('react render.')    return (      &lt;div&gt;A component &#123;this.props.info&#125; &lt;/div&gt;    )  &#125;&#125;</code></code></pre><ol start="3" class="ne-ol"><li id="uc4f4442b" data-lake-index-type="0"><span class="ne-text">setState是一个一个异步函数，其第二个参数可以传入回调函数，以便写状态改变之后的相关业务逻辑</span></li><li id="uc0538438" data-lake-index-type="0"><span class="ne-text">如果传入setState的值是对象，那么会在响应式内部所收集变化的量里面进行覆盖，如果需要实时根据最新变化的量做逻辑处理，则需要传入一个参数为state的回调函数</span></li></ol><pre><code><code>class A extends React.Component &#123;  state =&#123;    a: 1  &#125;  ···  handleMethod() &#123;    // 1. cover state    this.setState(&#123; a: this.state.a + 1 &#125;)    this.setState(&#123; a: this.state.a + 1 &#125;)    // result: a -&gt; 2    // 2. real time state    this.setState((state) =&gt; &#123; a: this.state.a + 1 &#125;)    this.setState((state) =&gt; &#123; a: this.state.a + 1 &#125;)    // result: a -&gt; 3  &#125;&#125;</code></code></pre><h4 id="ZhZcD"><span class="ne-text">PureComponent shouldComponentUpdate</span></h4><p id="u1410dea8" class="ne-p"><span class="ne-text">下面代码，因响应式变量变化，所以会执行一次render渲染</span></p><pre><code><code>class A extends React.Component &#123;  state =&#123;    a: 1  &#125;  ···  handleMethod() &#123;    this.setState(&#123; a: 1 &#125;)  &#125;  render &#123;    console.info('react render.')    return (      &lt;div&gt;A component &#123;this.props.info&#125; &lt;/div&gt;    )  &#125;&#125;</code></code></pre><p id="u17863ce9" class="ne-p"><span class="ne-text">上面情况其实响应式的结果都是a变为1，所以从渲染结果上看其实可以优化掉该种情况的渲染，react提供的渲染优化方式有两种：</span></p><p id="u185cfd38" class="ne-p"><span class="ne-text"></span></p><ol class="ne-ol"><li id="ub05164da" data-lake-index-type="0"><span class="ne-text">PureComponent优化组件</span></li></ol><pre><code><code>class A extends React.PureComponent &#123;  ···&#125;</code></code></pre><ol start="2" class="ne-ol"><li id="u79b67ec0" data-lake-index-type="0"><span class="ne-text">shouldComponentUpdate生命周期函数</span></li></ol><pre><code><code>class A extends React.Component &#123;  state =&#123;    a: 1  &#125;  ···  shouldComponentUpdate = (nextProps, nextState) =&gt; &#123;    if (nextState.a === this.state.a)    return false // not render    return true // run render  &#125;  render &#123;    console.info('react render.')    return (      &lt;div&gt;A component &#123;this.props.info&#125; &lt;/div&gt;    )  &#125;&#125;</code></code></pre><h4 id="pQyxA"><span class="ne-text">Refs</span></h4><p id="ub19f3212" class="ne-p"><span class="ne-text">框架只是对渲染dom的前置操作做了一层封装，比如先构造虚拟dom或是渲染时机的优化等，但有些时候需要在业务代码里面直接获取dom进行操作，比如input标签的自动聚焦（focus）</span></p><ol class="ne-ol"><li id="u0cc8c58c" data-lake-index-type="0"><span class="ne-text">变量</span></li></ol><pre><code><code>// A componentclass A extends React.Component &#123;  inputRef = React.createRef()  // this.inputRef.current // -&gt; Input DOM  render &#123;    return (      &lt;div&gt;      A component        &lt;input ref=&#123;inputRef&#125; /&gt;      &lt;/div&gt;    )  &#125;&#125;</code></code></pre><ol start="2" class="ne-ol"><li id="u2a7e01e5" data-lake-index-type="0"><span class="ne-text">回调函数</span></li></ol><pre><code><code>// A componentclass A extends React.Component &#123;  inputRef = (dom) =&gt; &#123;    dom.focus()  &#125;  // this.inputRef.current // -&gt; Input DOM  render &#123;    return (      &lt;div&gt;      A component        &lt;input ref=&#123;inputRef&#125; /&gt;      &lt;/div&gt;    )  &#125;&#125;</code></code></pre><ol start="3" class="ne-ol"><li id="u4ef7dd4c" data-lake-index-type="0"><span class="ne-text">除了可以得到DOM，也可以得到类组件的实例对象</span></li></ol><pre><code><code>// A componentclass A extends React.Component &#123;···&#125;// B componentclass B extends React.Component &#123;refData = React.createRef()   render() &#123;    return &lt;div&gt;content &lt;A ref=&#123;refData&#125; /&gt; &lt;/div&gt;  &#125;&#125;</code></code></pre><h4 id="Q0460"><span class="ne-text">生命周期</span></h4><p id="u55e5dd6b" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2023/png/1484158/1703663129914-06e9fada-b622-489d-813f-9d0ed1dbba41.png" width="1511.6666065984325" id="ud7af5c92" class="ne-image"></p><h4 id="oH5uK"><span class="ne-text">组件模式：RenderProps</span></h4><pre><code><code>class A extends React.Component &#123;  state = &#123;    x: 0,    y: 0,  &#125;  constructor(props) &#123;    super(props)    this.props = props  &#125;  componentDidMount = () =&gt; &#123;    document.addEventListener('mousemove', this.move)  &#125;  componentWillUnMount = () =&gt; &#123;    document.removeEventListener('mousemove', this.move)  &#125;  move = (e) =&gt; &#123;    this.setState(&#123;      x: e.pageX,      y: e.pageY,    &#125;)  &#125;render() &#123;    return (      &lt;React.Fragment&gt;      &#123; this.props.render(this.state.x, this.state.y)&#125;      &lt;/React.Fragment&gt;    )  &#125;&#125;class B extends React.Component &#123;render() &#123;    return &lt;A render=&#123;(x, y) =&gt; &#123;      &lt;div&gt;&#123;x&#125;, &#123;y&#125;&lt;/div&gt;    &#125;&#125; /&gt;  &#125;&#125;</code></code></pre><h4 id="G0eUR"><span class="ne-text">组件模式：HOC</span></h4><p id="u7d429497" class="ne-p"><span class="ne-text">参数为组件，返回新组件</span></p><pre><code><code>function hocFun(WithComponent) &#123;  return class extends React.Component &#123;    state = &#123;      x: 0,      y: 0,    &#125;    componentDidMount = () =&gt; &#123;      document.addEventListener('mousemove', this.move)    &#125;    componentWillUnMount = () =&gt; &#123;      document.removeEventListener('mousemove', this.move)    &#125;    move = (e) =&gt; &#123;      this.setState(&#123;        x: e.pageX,        y: e.pageY,      &#125;)    &#125;      render() &#123;      return &lt;WithComponent &#123;...this.state&#125; /&gt;    &#125;  &#125;&#125;class A extends React.Component &#123;  render() &#123;    return (      &lt;div&gt;          &#123;this.props.x&#125;, &#123;this.props.y&#125;      &lt;/div&gt;    )  &#125;&#125;const C = hocFun(A)class B extends React.Component &#123;    render() &#123;    return &lt;C /&gt;  &#125;&#125;</code></code></pre><h4 id="L9n58"><span class="ne-text">Context通信</span></h4><pre><code><code>const ContextData = React.createContext()<p>class A extends React.Component &#123;<br>  state = &#123;<br>    info: ‘something’<br>  &#125;<br>  render() &#123;<br>    return (<br>      A<br>      &lt;ContextData.Provider value=&#123;this.state.info&#125;&gt;<br>          &lt;B /&gt;<br>      &lt;/ContextData.Provider&gt;<br>    )<br>  &#125;<br>&#125;<br>class B extends React.Component &#123;<br>    render() &#123;<br>    return (<br>      B&lt;C /&gt;<br>    )<br>  &#125;<br>&#125;<br>class C extends React.Component &#123;<br>  static contextType = ContextData<br>  componentDidMount = () =&gt; &#123;<br>    console.lof(this.context)<br>  &#125;<br>    render() &#123;<br>    return (<br>      C<br>      &lt;ContextData.Consumer&gt;&#123; value =&gt; value &#125;&lt;/ContextData.Consumer&gt;<br>    )<br>  &#125;<br>&#125;<br>// render -&gt; ABCsomething</code><br></code></pre></p><h3 id="NZSgh"><span class="ne-text">函数组件</span></h3><h4 id="QmOfo"><span class="ne-text">useState</span></h4><p id="uc98a614a" class="ne-p"><span class="ne-text">响应式变量的声明和改变</span></p><pre><code><code>import &#123; useState &#125; from 'React'const A = () =&gt; &#123;  const [a, setA] = useState('a')  return &lt;div&gt;a value: &#123;a&#125;&lt;/div&gt;&#125;</code></code></pre><p id="u5c324387" class="ne-p"><span class="ne-text">和类组件的差异</span></p><ol class="ne-ol"><li id="u157ea2c5" data-lake-index-type="0"><span class="ne-text">改变值的时候不会merge，而是覆盖</span></li><li id="ue3b27c3a" data-lake-index-type="0"><span class="ne-text">初始值可以值回调函数，但不能是函数否则每次改变都会重新执行一遍该函数</span></li><li id="ubf97f0c2" data-lake-index-type="0"><span class="ne-text">同样存在批处理，也有防止批处理的函数</span></li></ol><pre><code><code>import &#123; useState &#125; from 'React'import &#123; flushSync &#125; from 'ReactDDOM'const A = () =&gt; &#123;  const [a, setA] = useState('a')  const [b, setB] = useState('b')  flushSync(() =&gt; &#123;    setA('aa')  &#125;)    flushSync(() =&gt; &#123;    setB('bb')  &#125;)  return &lt;div&gt;a value: &#123;a&#125;&lt;/div&gt;&#125;</code></code></pre><ol start="4" class="ne-ol"><li id="u832252b4" data-lake-index-type="0"><span class="ne-text">传入的是值，渲染前会存在覆盖情况，如果传入的是函数，则会保留上一次的状态值计算</span></li></ol><h4 id="tIoMO"><span class="ne-text">useEffect</span></h4><p id="u5ed09388" class="ne-p"><span class="ne-text">副作用Hook</span></p><ol class="ne-ol"><li id="u28b6342c" data-lake-index-type="0"><span class="ne-text">模拟各个生命周期的执行时机</span></li></ol><pre><code><code>import &#123; useState, useEffect &#125; from 'React'const A = () =&gt; &#123;  useEffect(() =&gt; &#123;    // mount || update    return () =&gt; &#123;      // beforeUpdate || unMount      // clear sider function...    &#125;  &#125;)  return &lt;div&gt;a value: &#123;a&#125;&lt;/div&gt;&#125;</code></code></pre><ol start="2" class="ne-ol"><li id="u8886765a" data-lake-index-type="0"><span class="ne-text">关于第二个数组参数</span></li></ol><ol class="ne-list-wrap"><ol ne-level="1" class="ne-ol"><li id="u29eccab1" data-lake-index-type="0"><span class="ne-text">如果不设置，那么在update时期都会执行</span></li><li id="uaa101652" data-lake-index-type="0"><span class="ne-text">如果设置空数组（且回调函数中没有响应式变量），则只在mount时期执行一次</span></li><li id="u54d7662f" data-lake-index-type="0"><span class="ne-text">如果useEffect回调函数中存在响应式变量，那么第二个参数数组中应当有该响应式变量</span></li></ol></ol><ol start="3" class="ne-ol"><li id="u22c20e06" data-lake-index-type="0"><span class="ne-text">useLayoutEffect</span></li></ol><ol class="ne-list-wrap"><ol ne-level="1" class="ne-ol"><li id="u4977ceef" data-lake-index-type="0"><span class="ne-text">useEffect：渲染并绘制到屏幕之后执行，异步</span></li><li id="u97c48e0a" data-lake-index-type="0"><span class="ne-text">useLayoutEffect：渲染之后，但绘制到屏幕之前执行，同步</span></li><li id="u95a58cbe" data-lake-index-type="0"><span class="ne-text">一般如果回调函数中有DOM的相关操作并且会改变样式，用后者，避免DOM渲染闪屏/白屏，但前者性能方面更好</span></li></ol></ol><h4 id="Y3UvK"><span class="ne-text">useRef</span></h4><ol class="ne-ol"><li id="u32714bac" data-lake-index-type="0"><span class="ne-text">作用在DOM上的回调函数，则为DOM实例</span></li></ol><pre><code><code>const A = () =&gt; &#123;  const elementFun = (dom) =&gt; &#123;    // dom -&gt; input DOM  &#125;  return &lt;div&gt;&lt;input type=&quot;text&quot; ref=&#123;elementFun&#125; /&gt;&lt;/div&gt;&#125;</code></code></pre><ol start="2" class="ne-ol"><li id="ub1ccc233" data-lake-index-type="0"><span class="ne-text">作用在DOM上且为useRef函数，则为带有键为current值为DOM本身的对象</span></li></ol><pre><code><code>import &#123; useRef &#125; from 'React'const A = () =&gt; &#123;  const obj = useRef()  // obj =&gt; &#123; current: inputDOM &#125;  return &lt;div&gt;&lt;input type=&quot;text&quot; ref=&#123;obj&#125; /&gt;&lt;/div&gt;&#125;</code></code></pre><ol start="3" class="ne-ol"><li id="ucebe1755" data-lake-index-type="0"><span class="ne-text">不可以作用在组件上，但是子组件有React.forwardRef（组件转发）可以</span></li></ol><pre><code><code>import &#123; useRef &#125; from 'React'const Son = React.forwardRef((props, ref) =&gt; &#123;  return &lt;div&gt;&lt;input type=&quot;text&quot; ref=&#123;ref&#125; /&gt;&lt;/div&gt;&#125;)const A = () =&gt; &#123;  const obj = useRef()  // obj =&gt; &#123; current: inputDOM &#125;  return &lt;Son ref=&#123;obj&#125; /&gt;&#125;</code></code></pre><ol start="4" class="ne-ol"><li id="udbc656f8" data-lake-index-type="0"><span class="ne-text">利用useRef创建的普通变量，可以具备“记忆”功能，类似于类的实例属性。利用这一点可以设置一个flag来实现组件仅更新时触发的代码执行时机</span></li></ol><pre><code><code>import &#123; useRef, useEffect &#125; from 'React'const A = () =&gt; &#123;  const obj = useRef(false)  const inputOnClick = () =&gt; &#123;    obj.current = true  &#125;  useEffect(() =&gt; &#123;    if (obj.current) &#123;      // only update -&gt; run...    &#125;  &#125;)  return &lt;div&gt;&lt;input type=&quot;text&quot; onClick=&#123;inputOnClick&#125; /&gt;&lt;/div&gt;&#125;</code></code></pre><h4 id="o3MJh"><span class="ne-text">useContext</span></h4><p id="u816841d0" class="ne-p"><span class="ne-text">跨组件通信</span></p><pre><code><code>import &#123; useContext, createContext &#125; from 'React'<p>// not Provider value -&gt; render default value<br>const C = createContext(‘default value…’)</p><p>const GSon = () =&gt; &#123;<br>  const value = useContext(C)<br>  // value -&gt; something…<br>  return &lt;div&gt;GSon template…&lt;/div&gt;<br>&#125;<br>const Son = () =&gt; &#123;<br>  return &lt;GSon /&gt;<br>&#125;</p><p>const A = () =&gt; &#123;</p><p>  return (<br>    &lt;C.Provider value=’something…’&gt;<br>        &lt;Son ref=&#123;obj&#125; /&gt;<br>    &lt;/C.Provider&gt;<br>  )<br>&#125;</code><br></code></pre></p><h4 id="Sc8WH"><span class="ne-text">memo</span></h4><p id="u8f7f8983" class="ne-p"><span class="ne-text">类似类组件中的</span><code class="ne-code"><span class="ne-text">PureComponent</span></code><span class="ne-text">性能优化组件</span></p><ol class="ne-ol"><li id="u993d2be2" data-lake-index-type="0"><span class="ne-text">函数组件中当响应变量的值没有发生改变，不会重新渲染，和类组件不一样</span></li><li id="u110c7560" data-lake-index-type="0"><span class="ne-text">当组件的值发生改变才进行render，反之不进行render</span></li></ol><pre><code><code>import &#123; useState, memo &#125; from 'React'<p>const Son = memo(() =&gt; &#123;<br>  return &lt;div&gt;son&lt;/div&gt;<br>&#125;)</p><p>// continue click -&gt; continue run ↓<br>// const Son = () =&gt; &#123;<br>//   return &lt;div&gt;son&lt;/div&gt;<br>// &#125;</p><p>const A = () =&gt; &#123;<br>  const [count, setCount] = useState(0)<br>  const clickEvent = () =&gt; &#123;<br>    setCount(1)<br>  &#125;<br>  return (<br>    &lt;div&gt;<br>        &lt;button onClick=&#123;clickEvent&#125; &gt;click&lt;/button&gt;<br>        &lt;Son count=&#123;count&#125; /&gt;<br>    &lt;/div&gt;<br>  )<br>&#125;</code><br></code></pre></p><h4 id="hEQq3"><span class="ne-text">useMemo和useCallback</span></h4><p id="u146035fb" class="ne-p"><span class="ne-text">React函数式组件在重新渲染时候，代码执行会将函数体重新执行，即便结果不是重新更新DOM。如果函数体的代码逻辑复杂会带来不小的性能损耗，如果能够对这过程中的部分“量”进行“记忆”，则会较大提升性能。</span></p><p id="u89b5266b" class="ne-p"><span class="ne-text">响应式变量内部会自动进行记忆，但是如果是非响应式变量，比如一个对象或是一个函数传入组件，这其实也是改变了的，原因是对象的引用改变，依然会引起DOM的重新渲染，而利用useMemo或是useCallback创建的对象（对象、数组、函数）则会保留记忆功能。</span></p><ol class="ne-ol"><li id="u5de4e990" data-lake-index-type="0"><span class="ne-text">useCallback：传入回调函数</span></li><li id="u618a838d" data-lake-index-type="0"><span class="ne-text">useMemo：传入一个必须带有返回值的函数</span></li><li id="u18b45d54" data-lake-index-type="0"><span class="ne-text">两者的第二个参数都是依赖数组，同useEffect</span></li></ol><pre><code><code>import &#123; useCallback, useMemo &#125; from 'React'const A = () =&gt; &#123;  // 1. every render -&gt; run  const fun = () =&gt; &#123;&#125;  // 2. useCallback (ignore const error...)  const fun = useCallback(() =&gt; &#123;&#125;, [])  // 3. useMemo (ignore const error...)  const fun = useMemo(() =&gt; () =&gt; &#123;&#125;, [])  const a = useMemo(() =&gt; [1, 2, 3], [])  <p>  return &lt;div onClick=&#123;fun&#125; a=&#123;a&#125;&gt;&lt;/div&gt;<br>&#125;</code><br></code></pre></p><h4 id="zUHaR"><span class="ne-text">useReducer</span></h4><p id="u76ab5b03" class="ne-p"><span class="ne-text">管理多个有关联的响应式变量</span></p><pre><code><code>import &#123; useReducer &#125; from 'React<p>const loginState = &#123; isLogin: true, isLogout: false &#125;<br>const loginReducer = (state, action) =&gt; &#123;<br>  switch(action.type) &#123;<br>    case ‘login’:<br>      return &#123; isLogin: true, isLogout: false &#125;<br>    case ‘logout’:<br>      return &#123; isLogin: false, isLogout: true &#125;<br>    default:<br>      return new Error()<br>  &#125;<br>&#125;</p><p>const A = () =&gt; &#123;<br>  const [state, LoginDispatch] = useReducer(loginReducer, loginState)<br>  const clickEvent = () =&gt; &#123;<br>    loginDispatch(&#123; type: state.isLogin ? ‘logout’ : ‘login’ &#125;)<br>  &#125;</p><p>  return (<br>    &lt;button onClick=&#123;clickEvent&#125;&gt;&#123;state.isLogin ? ‘login’, ‘logout’&#125;&lt;/button&gt;<br>  )<br>&#125;</code><br></code></pre></p><h4 id="ZHgiq"><span class="ne-text">并发模式</span></h4><ol class="ne-ol"><li id="uf47bf115" data-lake-index-type="0"><span class="ne-text">React18之前，渲染是一个单一的、不间断的、同步的事务，一旦渲染开始，就不能被中断</span></li><li id="ufee7a81a" data-lake-index-type="0"><span class="ne-text">React18引入并发模式，它允许你将更新作为一个transitions，这会告诉React他们可以被中断执行。这样可以把紧急的任务先更新你，不紧急的任务后更新</span></li></ol><h4 id="SV5XT"><span class="ne-text">startTransition</span></h4><pre><code><code>import &#123; startTransition &#125; from 'React'const A = () =&gt; &#123;  ...  const fun = () =&gt; &#123;    // 紧急任务    setA('')    // 不紧急任务（将内部的任何非紧急状态更新标记为 Transition）    startTransition(() =&gt; setB(''))  &#125;  return &lt;div&gt;&lt;/div&gt;&#125;</code></code></pre><h4 id="LHIKS"><span class="ne-text">useTransition和useDeferredValue</span></h4><ol class="ne-ol"><li id="ubb651c66" data-lake-index-type="0"><span class="ne-text">useTransition返回一个状态值表示过渡任务的等待状态，以及一个启动该过渡任务的函数</span></li></ol><pre><code><code>import &#123; useTransition &#125; from 'React'const A = () =&gt; &#123;  ...  const [pending, startTransition] = useTransition()  const fun = () =&gt; &#123;    // 紧急任务    setA('')    // 不紧急任务（将内部的任何非紧急状态更新标记为 Transition）    startTransition(() =&gt; setB(''))  &#125;  return &lt;div&gt;&lt;/div&gt;&#125;</code></code></pre><ol start="2" class="ne-ol"><li id="u279291ea" data-lake-index-type="0"><span class="ne-text">useDeferredValue接受一个值，并返回该值的新副本，该副本将推迟到更紧急地更新之后</span></li></ol><pre><code><code>import &#123; useDeferredValue, useState &#125; from 'React'const A = () =&gt; &#123;  const [a, setA] = useState('')  // aD =&gt; 不紧急时候的值（同a），也就是延迟之后的值  const aD = useDeferredValue(a)  ...  return &lt;div&gt;&lt;/div&gt;&#125;</code></code></pre><h4 id="FnTQp"><span class="ne-text">自定义hook</span></h4><ol class="ne-ol"><li id="ue75e76dd" data-lake-index-type="0"><span class="ne-text">命名通常使用use开头</span></li><li id="u2bce0e3e" data-lake-index-type="0"><span class="ne-text"></span></li></ol><pre><code><code>import &#123; useState, useEffect &#125; from 'React'<p>const useMouseXY = () =&gt; &#123;<br>  const [x, setX] = usestate(0)<br>  const [y, setY] = usestate(0)</p><p>  useEffect(() =&gt; &#123;<br>    function move(e) &#123;<br>      setX(e.pageX)<br>      setY(e.pageY)<br>    &#125;<br>    document.addEventListener(‘mousemove’, move)<br>    return () =&gt; document.removeEventListener(‘mousemove’, move)<br>  &#125;, [])</p><p>  return &#123; x, y &#125;<br>&#125;</p><p>// use<br>const &#123; x, y &#125; = useMouseXY()</code><br></code></pre></p><h4 id="JPBEq"><span class="ne-text">lazy</span></h4><p id="udc1f9642" class="ne-p"><span class="ne-text">当模块化引入（import）组件，但在实际代码中未使用到，代码内部逻辑仍会执行，这个时候可以利用lazy使组件异步化加载，从而达到性能优化效果</span></p><pre><code><code>import &#123; lazy &#125; from 'react';<p>const AuthRoute = lazy(() =&gt; import(‘./AuthRoute’));<br>const ErrorPage = lazy(() =&gt; import(‘@/components/ErrorBoundary’));<br>const NotFound = lazy(() =&gt; import(‘@/pages/404’));</code><br></code></pre></p><h4 id="zYL5T"><span class="ne-text">Suspense</span></h4><p id="ueed27788" class="ne-p"><span class="ne-text">组件加载中或是切换过程中的“中间态”</span></p><pre><code><code>import &#123; Suspense, useState &#125; from 'react';import &#123; RouterProvider &#125; from 'react-router-dom';import router from '@/router/index';import Loading from '@/components/Loading';<p>function MyApp() &#123;<br>  const [show, setShow] = useState(true)<br>  const clickEvent = () =&gt; setShow(!show)<br>  return (<br>    &lt;&gt;<br>      &lt;button onClick=&#123;clickEvent&#125;&gt;btn&lt;/button&gt;<br>      &lt;Suspense fallback=&#123;&lt;Loading /&gt;&#125;&gt;<br>        &#123;show ? &lt;RouterProvider router=&#123;router&#125; /&gt; : &lt;&gt;other template&lt;/&gt;&#125;<br>      &lt;/Suspense&gt;<br>    &lt;/&gt;<br>  );<br>&#125;</p><p>export default MyApp;</code><br></code></pre></p><p id="ud8c681f0" class="ne-p"><span class="ne-text">结合startTransition使用：</span></p><p id="uad00f696" class="ne-p"><span class="ne-text">如果需要切换过程中不展示loading的加载态，则将上述代码中的切换逻辑转为并发异步即可</span></p><pre><code><code>const clickEvent = () =&gt; startTransition(() =&gt; setShow(!show))</code></code></pre><h4 id="vA6LY"><span class="ne-text">错误边界捕获</span></h4><p id="uce23988c" class="ne-p"><span class="ne-text">如果编写的组件内部报错，那么react渲染会清除根节点DOM，React官方文档暂时只有类组件编写的示例代码。其核心逻辑在类组件上支持关键的生命周期方法getDerivedStateFromError()和componentDidCatch()，无法将错误边界编写为函数式组件，同时以下几种错误情况，也捕获不到：</span></p><ol class="ne-ol"><li id="u153d38e4" data-lake-index-type="0"><span class="ne-text">异步代码</span></li><li id="u5764c7ba" data-lake-index-type="0"><span class="ne-text">事件处理函数</span></li><li id="ubdf3f9b1" data-lake-index-type="0"><span class="ne-text">服务器组件</span></li><li id="uae94c9a5" data-lake-index-type="0"><span class="ne-text">Error Boundary自身</span></li></ol><p id="u01d1627d" class="ne-p"><span class="ne-text">具体的完整封装 TODO: </span></p><h3 id="RG1RA"><span class="ne-text">ReactDOM</span></h3><h4 id="xAPZX"><span class="ne-text">createPortal</span></h4><ol class="ne-ol"><li id="u729bc8ae" data-lake-index-type="0"><span class="ne-text">可以指定节点挂载到指定目标DOM节点</span></li></ol><pre><code><code>// templateconst A = () =&gt; ReactDOM.createPortal(&lt;div&gt;info&lt;/div&gt;, document.body)</code></code></pre><ol start="2" class="ne-ol"><li id="u21e16b5d" data-lake-index-type="0"><span class="ne-text">对于一些全局组件（message），DOM的挂在可能不在root根节点内，自定义挂在指定DOM节点，除了上述createPortal方式，还有react的createRoot方式</span></li></ol></div>]]></content:encoded>
      
      
      <category domain="https://www.wztlink1013.com/categories/Web%E5%BC%80%E5%8F%91/">Web开发</category>
      
      <category domain="https://www.wztlink1013.com/categories/Web%E5%BC%80%E5%8F%91/React/">React</category>
      
      
      
      <comments>https://www.wztlink1013.com/blog/wnb93ckult99ixhg/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>TypeScript系统学习</title>
      <link>https://www.wztlink1013.com/blog/torv9p4z2b79494z/</link>
      <guid>https://www.wztlink1013.com/blog/torv9p4z2b79494z/</guid>
      <pubDate>Sat, 23 Dec 2023 00:10:27 GMT</pubDate>
      
        
        
          
          
      <description>&lt;!doctype html&gt;&lt;div class=&quot;lake-content&quot; typography=&quot;classic&quot;&gt;&lt;h4 id=&quot;DMAyy&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;基础使用&lt;/span&gt;&lt;/h4&gt;&lt;ol class=&quot;ne-ol&quot;&gt;&lt;li</description>
          
        
      
      
      
      <content:encoded><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h4 id="DMAyy"><span class="ne-text">基础使用</span></h4><ol class="ne-ol"><li id="u662263d7" data-lake-index-type="0"><span class="ne-text">既是变量声明空间，也是类型声明空间</span></li><li id="u0d4282f1" data-lake-index-type="0"><span class="ne-text">类型分类：</span></li></ol><ol class="ne-list-wrap"><ol ne-level="1" class="ne-ol"><li id="u42e9bb1d" data-lake-index-type="0"><span class="ne-text">基本类型：也就是JavaScript中的七种基本类型</span></li><li id="u717293e5" data-lake-index-type="0"><span class="ne-text">对象类型：对象、数组、函数</span></li><li id="u7cfbb6db" data-lake-index-type="0"><span class="ne-text">typescript新增类型：any, never, void, unknown, enum</span></li></ol></ol><ol start="3" class="ne-ol"><li id="u8b1c9efb" data-lake-index-type="0"><span class="ne-text">联合类型和交叉类型：类型间的或跟与</span></li><li id="u61315403" data-lake-index-type="0"><span class="ne-text">断言（as）非空断言（!.）</span></li><li id="u13adc4e0" data-lake-index-type="0"><span class="ne-text">数组类型定义：type[]，Array&lt;string&gt;</span></li><li id="ua418feb9" data-lake-index-type="0"><span class="ne-text">元组类型定义：形式上类似JavaScript中的解构赋值</span></li></ol><span style="margin-left: 2em"><pre><code><code>let arr: [number, string] = [1, 'str'];arr[2] = 'test'; // ts error</code></code></pre></span><ol start="7" class="ne-ol"><li id="ub2d7406e" data-lake-index-type="0"><span class="ne-text">索引签名：</span></li></ol><ol class="ne-list-wrap"><ol ne-level="1" class="ne-ol"><li id="uabde14d8" data-lake-index-type="0"><span class="ne-text">比如后端返回的数据，字段不可能枚举完全</span></li></ol></ol><span style="margin-left: 2em"><pre><code><code>type ObjType = &#123;  a: string  b: number  [index: string]: any&#125;const obj: ObjType = &#123;  a: '11',  b: 22,  c: false,&#125;</code></code></pre></span><ol class="ne-list-wrap"><ol start="2" ne-level="1" class="ne-ol"><li id="u88d48f1f" data-lake-index-type="0"><span class="ne-text">也可以给数组设置类型</span></li></ol></ol><span style="margin-left: 2em"><pre><code><code>type ArrayType = &#123;  [index: number]: any&#125;const arr: ArrayType = ['111', 222, false]</code></code></pre></span><ol start="8" class="ne-ol"><li id="ubdb9547b" data-lake-index-type="0"><span class="ne-text">函数重载和可调用注解</span></li></ol><span style="margin-left: 2em"><pre><code><code>type FunType = &#123;  (n: number): number  key?: string&#125;let fun: FunType = (n) =&gt; nfun.key = 'test'</code></code></pre></span><ol start="9" class="ne-ol"><li id="u854e2d24" data-lake-index-type="0"><span class="ne-text">枚举类型（enum）：自定义枚举变量，优化代码可读性，其本质也是一个包装的JavaScript对象</span></li><li id="u339c427d" data-lake-index-type="0"><span class="ne-text">一般在交叉类型的具体内部逻辑中，需要判断实际变量所属类型，利用利用typeof、instanceof、in或是字面量类型来进行判断</span></li></ol><h4 id="EfHth"><span class="ne-text">接口</span></h4><ul class="ne-ul"><li id="u6f775147" data-lake-index-type="0"><span class="ne-text">接口和类型的差异</span></li></ul><ol class="ne-list-wrap"><ol ne-level="1" class="ne-ol"><li id="ua06d3aa0" data-lake-index-type="0"><span class="ne-text">接口的目标只能用在对象当中</span></li><li id="u5e246c5a" data-lake-index-type="0"><span class="ne-text">接口可以合并</span></li><li id="u3cc008e6" data-lake-index-type="0"><span class="ne-text">接口具备继承能力（和Java抽象类差不多）</span></li><li id="u18ff22ec" data-lake-index-type="0"><span class="ne-text">接口不能映射</span></li></ol></ol><h4 id="WiFCE"><span class="ne-text">字面量类型 keyof typeof</span></h4><ul class="ne-ul"><li id="u65329c6c" data-lake-index-type="0"><span class="ne-text">type的值可以直接存储为一种类型，比如h标签的所有类型值</span></li></ul><pre><code><code>type HTYPE = 'h1' | 'h2' | 'h3' | 'h4' | 'h5' | 'h6' |</code></code></pre><ul class="ne-ul"><li id="u9da9f0e8" data-lake-index-type="0"><span class="ne-text">keyof可以获取一个对象类型的所有关键字</span></li></ul><pre><code><code>interface A &#123;  a: string;  b: number&#125;const v: keyof A = // 'a' | 'b'</code></code></pre><pre><code><code>const obj = &#123;  a: '111',  b: 222,&#125;const v: keyof typeof obj = // 'a' | 'b'</code></code></pre><h4 id="P07Tb"><span class="ne-text">泛型</span></h4><ol class="ne-ol"><li id="u5f9ef2bc" data-lake-index-type="0"><span class="ne-text">函数和接口结合使用</span></li></ol><pre><code><code>interface A&lt;T&gt; &#123;  (n?: T): n  default?: T&#125;<p>const fun1: A&lt;string&gt; = (n) =&gt; n</p><p>fun1(‘111’)<br>fun1.default = ‘222’</code><br></code></pre></p><ol start="2" class="ne-ol"><li id="uc2890d23" data-lake-index-type="0"><span class="ne-text">类（class）中使用</span></li></ol><pre><code><code>class A&lt;T&gt; &#123;  public n!: T&#125;<p>const instance = new A&lt;string&gt;()<br>instance.n = ‘111’</code><br></code></pre></p><ol start="3" class="ne-ol"><li id="u425efa73" data-lake-index-type="0"><span class="ne-text">泛型约束</span></li></ol><p id="ufbcaea02" class="ne-p"><span class="ne-text">很多时候，泛型的“T”是已经知道的集中范围内的，就可以对泛型加以约束（extends）</span></p><pre><code><code>type I = string<p>class A&lt;T extends I&gt; &#123;<br>  public n!: T<br>&#125;</p><p>const instance = new A&lt;string&gt;()<br>instance.n = ‘111’</code><br></code></pre></p><h4 id="pUon2"><span class="ne-text">类</span></h4><ol class="ne-ol"><li id="u3d088ef4" data-lake-index-type="0"><span class="ne-text">接口（implements）</span></li></ol><pre><code><code>interface A &#123;  a: string  b: number  fun: (c: string, d: number) =&gt; void&#125;<p>class B implements A &#123;<br>  a!: string<br>  b!: number<br>  fun: (c: string, d: number) =&gt; &#123;&#125;<br>&#125;</code><br></code></pre></p><ol start="2" class="ne-ol"><li id="u328e816a" data-lake-index-type="0"><span class="ne-text">结合泛型</span></li></ol><pre><code><code>class A&lt;T&gt; &#123;  a: T  constructor(a: T) &#123;    this.a = a  &#125;&#125;<p>new A&lt;string&gt;(‘aaa’)</code><br></code></pre></p><pre><code><code>interface A&lt;T&gt; &#123;  a: T  b: number  fun: (c: T, d: number) =&gt; void&#125;class B implements A&lt;string&gt; &#123;  a!: string  b!: number  fun: (c: string, d: number) =&gt; &#123;&#125;&#125;</code></code></pre><h4 id="Gymk9"><span class="ne-text">映射</span></h4><p id="u80a1a45b" class="ne-p"><span class="ne-text">类似于对一个已有类型的“二次开发”</span></p><ol class="ne-ol"><li id="u08291f1b" data-lake-index-type="0"><span class="ne-text">一个例子：对一个已有类型对象的值都设置为只读的</span></li></ol><pre><code><code>type A = &#123;  a: string  b: string&#125;<p>type B&lt;T&gt; = &#123;<br>  readonly [P in keyof T]: T[P]<br>&#125;</p><p>type C = B&lt;A&gt;</code><br></code></pre></p><ol start="2" class="ne-ol"><li id="ub4542434" data-lake-index-type="0"><span class="ne-text">一个例子：对于DOM自带的DOMRect类型进行二次自定义</span></li></ol><pre><code><code>/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/DOMRectReadOnly) */interface DOMRectReadOnly &#123;  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/DOMRectReadOnly/bottom) */  readonly bottom: number;  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/DOMRectReadOnly/height) */  readonly height: number;  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/DOMRectReadOnly/left) */  readonly left: number;  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/DOMRectReadOnly/right) */  readonly right: number;  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/DOMRectReadOnly/top) */  readonly top: number;  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/DOMRectReadOnly/width) */  readonly width: number;  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/DOMRectReadOnly/x) */  readonly x: number;  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/DOMRectReadOnly/y) */  readonly y: number;  toJSON(): any;&#125;/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/DOMRect) */interface DOMRect extends DOMRectReadOnly &#123;  height: number;  width: number;  x: number;  y: number;&#125;</code></code></pre><pre><code><code>// - remove assign value (-readonlu or -?)...type EditableDOMRect = &#123;  -readonly [K in keyof DOMRect]: DOMRect[K];&#125;;// EditableDOMRect === ↓type EditableDOMRect = &#123;  height: number;  width: number;  x: number;  y: number;  bottom: number;  left: number;  right: number;  top: number;  toJSON: () =&gt; any;&#125;</code></code></pre><h4 id="EXNeJ"><span class="ne-text">条件类型 infer</span></h4><pre><code><code>type C = A extends B ? &#123;&#125; : []type Exclude&lt;T, U&gt; = T extends U ? never : T</code></code></pre><h4 id="OW0TC"><span class="ne-text">内置工具类型</span></h4><p id="uc0bd97b2" class="ne-p"><span class="ne-text">typescript内置部分类型（具体可以利用编辑器转到定义处查看）</span></p><p id="ue6815fcd" class="ne-p"><span class="ne-text">比如完成上述映射第一个例子可以写成</span></p><pre><code><code>type D = Readonly&lt;A&gt;</code></code></pre><p id="u1558878f" class="ne-p"><span class="ne-text">常用的如下：</span></p><table id="JMQIq" class="ne-table" style="width: 636px"><tbody><tr style="height: 33px"><td width="318"><p id="u0db44a55" class="ne-p"><span class="ne-text">Partial</span></p></td><td width="318"><ul class="ne-ul"><li id="u0de61c6b" data-lake-index-type="0"><span class="ne-text">可选</span></li></ul><pre><code><code>type B = Partial&lt;A&gt;</code></code></pre></td></tr><tr style="height: 33px"><td width="318"><p id="u9624db74" class="ne-p"><span class="ne-text">Readonly</span></p></td><td width="318"><ul class="ne-ul"><li id="u292ea66d" data-lake-index-type="0"><span class="ne-text">只读</span></li></ul><pre><code><code>type B = Readonly&lt;A&gt;</code></code></pre></td></tr><tr style="height: 33px"><td width="318"><p id="u31f84b39" class="ne-p"><span class="ne-text">Pick</span></p></td><td width="318"><ul class="ne-ul"><li id="uacea44be" data-lake-index-type="0"><span class="ne-text">筛选指定项</span></li></ul><pre><code><code>type B = Pick&lt;A, 'a' | 'b'&gt;</code></code></pre></td></tr><tr style="height: 33px"><td width="318"><p id="u3ee0494b" class="ne-p"><span class="ne-text">Record</span></p></td><td width="318"><ul class="ne-ul"><li id="u9efccf89" data-lake-index-type="0"><span class="ne-text">指定字段为指定类型</span></li></ul><pre><code><code>type A = Record&lt;'a' | 'b', string&gt;type A = Record&lt;keyof C, string&gt;</code></code></pre></td></tr><tr style="height: 33px"><td width="318"><p id="u67a37fee" class="ne-p"><span class="ne-text">Required</span></p></td><td width="318"><ul class="ne-ul"><li id="uaf8032bb" data-lake-index-type="0"><span class="ne-text">将可选字段转为必选字段</span></li></ul><pre><code><code>type B = Required&lt;A&gt;</code></code></pre></td></tr><tr style="height: 33px"><td width="318"><p id="u1a1da710" class="ne-p"><span class="ne-text">Omit</span></p></td><td width="318"><ul class="ne-ul"><li id="u78dd2ad3" data-lake-index-type="0"><span class="ne-text">移除指定项</span></li></ul><pre><code><code>type B = Omit&lt;A, 'a' | 'b'&gt;</code></code></pre></td></tr><tr style="height: 33px"><td width="318"><p id="ue047fc96" class="ne-p"><span class="ne-text">Exclude</span></p></td><td width="318"><ul class="ne-ul"><li id="u814a1afa" data-lake-index-type="0"><span class="ne-text">排除</span></li></ul><pre><code><code>type B = Exclude&lt;string | number, string&gt;</code></code></pre></td></tr><tr style="height: 33px"><td width="318"><p id="u555524d6" class="ne-p"><span class="ne-text">Extract</span></p></td><td width="318"><ul class="ne-ul"><li id="u3566469d" data-lake-index-type="0"><span class="ne-text">择取</span></li></ul><pre><code><code>type B = Extract&lt;string | number, string&gt;</code></code></pre></td></tr><tr style="height: 33px"><td width="318"><p id="u7ee55ba0" class="ne-p"><span class="ne-text">NonNullable</span></p></td><td width="318"><ul class="ne-ul"><li id="u8247e26e" data-lake-index-type="0"><span class="ne-text">去除“空”类型</span></li></ul><pre><code><code>type B = NonNullable&lt;string | null | undefined&gt;// B -&gt; string</code></code></pre></td></tr><tr style="height: 33px"><td width="318"><p id="u7f47e0cf" class="ne-p"><span class="ne-text">Parameters</span></p></td><td width="318"><ul class="ne-ul"><li id="ud5251af7" data-lake-index-type="0"><span class="ne-text">得到函数参数元组</span></li></ul><pre><code><code>type FUN = (n: string, m: number) =&gt; voidtype A = Parameters&lt;FUN&gt;<p>const test: A = [‘111’, 222];</code><br></code></pre></p></td></tr><tr style="height: 33px"><td width="318"><p id="u71bcf350" class="ne-p"><span class="ne-text">ReturnType</span></p></td><td width="318"><ul class="ne-ul"><li id="u7f9d26b9" data-lake-index-type="0"><span class="ne-text">得到函数返回值类型</span></li></ul><pre><code><code>type FUN = (n: string, m: number) =&gt; voidtype A = ReturnType&lt;FUN&gt;<p>const test: A = // void</code><br></code></pre></p></td></tr></tbody></table><ol class="ne-ol"><li id="udf359230" data-lake-index-type="0"><span class="ne-text">infer关键字 extends关键字</span></li></ol><p id="uf8802929" class="ne-p"><span class="ne-text">推断类型</span></p><pre><code><code>type A&lt;T&gt; = T extends Array&lt;infer U&gt; ? U : T<p>type B = A&lt;Array&lt;string&gt;&gt; // string<br>type C = A&lt;number&gt; // number</code><br></code></pre></p></div>]]></content:encoded>
      
      
      <category domain="https://www.wztlink1013.com/categories/Web%E5%BC%80%E5%8F%91/">Web开发</category>
      
      <category domain="https://www.wztlink1013.com/categories/Web%E5%BC%80%E5%8F%91/TypeScript/">TypeScript</category>
      
      
      
      <comments>https://www.wztlink1013.com/blog/torv9p4z2b79494z/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
