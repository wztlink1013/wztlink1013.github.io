<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Hexo优化网站SEO</title>
      <link href="/blog/ymz4rr2wyxrxktqd/"/>
      <url>/blog/ymz4rr2wyxrxktqd/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="ub944b1e4" class="ne-p"><span class="ne-text">前言：提高搜索引擎对网站的抓取质量，从以下两个文件入手：</span></p><ol class="ne-ol"><li id="u9472c50c" data-lake-index-type="0"><span class="ne-text">sitemap文件</span></li><li id="u3a99adbb" data-lake-index-type="0"><span class="ne-text">Robots.txt</span></li></ol><h3 id="DwDU8"><span class="ne-text">sitemap</span></h3><p id="u88ae2110" class="ne-p"><span class="ne-text">sitemap是一种包含网站所有页面URL的文件，有助于搜索引擎更快地索引和发现您的网站，其格式有xml或txt。在Hexo中，可以利用</span><a href="https://github.com/hexojs/hexo-generator-sitemap" data-href="https://github.com/hexojs/hexo-generator-sitemap" target="_blank" class="ne-link"><span class="ne-text">hexo-generator-sitemap</span></a><span class="ne-text">插件生成sitemap文件。</span></p><h4 id="xAlnz"><span class="ne-text">基本使用</span></h4><pre><code><code>npm i hexo-generator-sitemap --save</code></code></pre><p id="ud9d657b1" class="ne-p"><span class="ne-text">参数配置，具体使用参考文档：</span><a href="https://github.com/hexojs/hexo-generator-sitemap/tree/master?tab=readme-ov-file#options" data-href="https://github.com/hexojs/hexo-generator-sitemap/tree/master?tab=readme-ov-file#options" target="_blank" class="ne-link"><span class="ne-text">https://github.com/hexojs/hexo-generator-sitemap/tree/master?tab=readme-ov-file#options</span></a></p><pre><code><code>sitemap:  path: sitemap.xml  tags: false  categories: false  template: ./template/sitemap.xml</code></code></pre><p id="u06f186d4" class="ne-p"><span class="ne-text">生成后的sitemap文件如下：</span></p><pre><code><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;urlset xmlns=&quot;http://www.sitemaps.org/schemas/sitemap/0.9&quot;&gt;  &lt;url&gt;    &lt;loc&gt;https://www.wztlink1013.com/blog/tttk33/&lt;/loc&gt;    &lt;lastmod&gt;2024-01-14&lt;/lastmod&gt;    &lt;changefreq&gt;weekly&lt;/changefreq&gt;    &lt;priority&gt;0.8&lt;/priority&gt;  &lt;/url&gt;  &lt;url&gt;    &lt;loc&gt;https://www.wztlink1013.com/&lt;/loc&gt;    &lt;lastmod&gt;2024-01-14&lt;/lastmod&gt;    &lt;changefreq&gt;daily&lt;/changefreq&gt;    &lt;priority&gt;1.0&lt;/priority&gt;  &lt;/url&gt;&lt;/urlset&gt;</code></code></pre><ul class="ne-ul"><li id="uca43eeff" data-lake-index-type="0"><span class="ne-text">loc：抓取的网站子页url</span></li><li id="u1b2973d2" data-lake-index-type="0"><span class="ne-text">lastmod：改子页最新一次更新时间</span></li><li id="uc5f01609" data-lake-index-type="0"><span class="ne-text">changefreq：改子页更新频率</span></li><li id="u77e95919" data-lake-index-type="0"><span class="ne-text">priority：在该站点的抓取优先级权重</span></li></ul><h4 id="SEC0C"><span class="ne-text">自定义生成模板</span></h4><p id="u44db15c2" class="ne-p"><span class="ne-text" style="background-color: #FBDE28"></span><span class="ne-text">在项目根路径创建</span><code class="ne-code"><span class="ne-text">template/sitemap.xml</span></code><span class="ne-text">文件，并写入下面代码</span></p><pre><code><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;urlset xmlns=&quot;http://www.sitemaps.org/schemas/sitemap/0.9&quot;&gt;  &#123;% for post in posts %&#125;  &lt;url&gt;    &lt;loc&gt;&#123;&#123; post.permalink | uriencode &#125;&#125;&lt;/loc&gt;&#123;% if post.updated %&#125;    &lt;lastmod&gt;&#123;&#123; post.updated | formatDate &#125;&#125;&lt;/lastmod&gt;&#123;% elif post.date %&#125;    &lt;lastmod&gt;&#123;&#123; post.date | formatDate &#125;&#125;&lt;/lastmod&gt;&#123;% endif %&#125;    &lt;changefreq&gt;weekly&lt;/changefreq&gt;    &lt;priority&gt;0.8&lt;/priority&gt;  &lt;/url&gt;  &#123;% endfor %&#125;<p>  &lt;url&gt;<br>    &lt;loc&gt;&#123;&#123; config.url | uriencode &#125;&#125;&lt;/loc&gt;<br>    &lt;lastmod&gt;&#123;&#123; sNow | formatDate &#125;&#125;&lt;/lastmod&gt;<br>    &lt;changefreq&gt;daily&lt;/changefreq&gt;<br>    &lt;priority&gt;1.0&lt;/priority&gt;<br>  &lt;/url&gt;</p>  &#123;% for tag in tags %&#125;  &lt;url&gt;    &lt;loc&gt;&#123;&#123; tag.permalink | uriencode &#125;&#125;&lt;/loc&gt;    &lt;lastmod&gt;&#123;&#123; sNow | formatDate &#125;&#125;&lt;/lastmod&gt;    &lt;changefreq&gt;weekly&lt;/changefreq&gt;    &lt;priority&gt;0.2&lt;/priority&gt;  &lt;/url&gt;  &#123;% endfor %&#125;  &#123;% for cat in categories %&#125;  &lt;url&gt;    &lt;loc&gt;&#123;&#123; cat.permalink | uriencode &#125;&#125;&lt;/loc&gt;    &lt;lastmod&gt;&#123;&#123; sNow | formatDate &#125;&#125;&lt;/lastmod&gt;    &lt;changefreq&gt;weekly&lt;/changefreq&gt;    &lt;priority&gt;0.2&lt;/priority&gt;  &lt;/url&gt;  &#123;% endfor %&#125;<p>&lt;/urlset&gt;</code><br></code></pre></p><h4 id="kvZtE"><span class="ne-text">指定页面跳过sitemap收录</span></h4><p id="u0be81d58" class="ne-p"><span class="ne-text">在hexo中的文章或是页面，可以如下配置：</span></p><pre><code><code>---title: 隐藏文章date: 2024-01-14sitemap: false---</code></code></pre><h3 id="qE3ji"><span class="ne-text">robots.txt</span></h3><p id="u9a756fc4" class="ne-p"><span class="ne-text">robots文件是一个文本文件，用于向搜索引擎指示哪些页面可以访问和索引，哪些页面应该被忽略。通过优化 robots文件，可以提高网站在搜索引擎中的排名和曝光度。</span></p><pre><code><code># https://www.wztlink1013.comUser-agent: *Disallow: /Sitemap: https://www.wztlink1013.com/sitemap.xml</code></code></pre><ul class="ne-ul"><li id="u7e1ac461" data-lake-index-type="0"><span class="ne-text">User-agent：* 表示允许所有搜索引擎访问您的网站，如果限定的话，则键入 </span><code class="ne-code"><span class="ne-text">[搜索引擎名称]</span></code></li><li id="ue346fd0f" data-lake-index-type="0"><span class="ne-text">Sitemap：说明sitemap文件url</span></li><li id="udac61ea6" data-lake-index-type="0"><span class="ne-text">Disallow：</span><code class="ne-code"><span class="ne-text">/</span></code><span class="ne-text">表示禁止该搜索引擎访问您的网站中所有页面和文件</span></li></ul><div class="ne-quote"><ul class="ne-ul"><li id="ub8c27d16" data-lake-index-type="0"><span class="ne-text">检测自己写的robots文件是否生效：</span><a href="https://ziyuan.baidu.com/robots/intro" data-href="https://ziyuan.baidu.com/robots/intro" target="_blank" class="ne-link"><span class="ne-text">https://ziyuan.baidu.com/robots/intro</span></a><span class="ne-text"></span></li><li id="ub1d1e5aa" data-lake-index-type="0"><span class="ne-text">语法规则：</span><a href="https://ziyuan.baidu.com/college/courseinfo?id=267&amp;page=13" data-href="https://ziyuan.baidu.com/college/courseinfo?id=267&amp;page=13" target="_blank" class="ne-link"><span class="ne-text">https://ziyuan.baidu.com/college/courseinfo?id=267&amp;page=13</span></a></li></ul></div><p id="ufb489ca3" class="ne-p"><br></p><h3 id="NzJnY"><span class="ne-text">❗</span><span class="ne-text">百度不再允许大多数站点提交sitemap文件</span></h3><p id="u7080f3da" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2024/png/1484158/1705232927775-66b2b6e8-1f1c-40aa-a427-c3e9b59d680d.png" width="1098.3332896894897" id="u41efa066" class="ne-image"></p><p id="uadbf9159" class="ne-p"><span class="ne-text">如果之前没有提交过sitemap链接的，貌似没有办法提交sitemap链接了，如果之前提交过应该不受影响。。。</span></p></div>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
          <category> 博客技术 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2645. 构造有效字符串的最少插入数🔖DP🔖穷举</title>
      <link href="/blog/lk1vbtcuw7ox57do/"/>
      <url>/blog/lk1vbtcuw7ox57do/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><ul class="ne-ul"><li id="u8c63af56" data-lake-index-type="0"><span class="ne-text">题目：</span><a href="https://leetcode.cn/problems/minimum-additions-to-make-valid-string/" data-href="https://leetcode.cn/problems/minimum-additions-to-make-valid-string/" target="_blank" class="ne-link"><span class="ne-text">https://leetcode.cn/problems/minimum-additions-to-make-valid-string/</span></a></li></ul><p id="u805fc1c7" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2024/png/1484158/1705311894805-a68668b9-a6dc-4255-9eb8-11ab3d63453d.png" width="574.0741146281288" id="u153e480d" class="ne-image"></p><h3 id="gjP8I"><span class="ne-text">动态规划</span></h3><p id="u4c885b04" class="ne-p"><span class="ne-text">DP问题，两个步骤：</span></p><ol class="ne-ol"><li id="u67367468" data-lake-index-type="0"><span class="ne-text" style="background-color: #FBDE28">状态转移方程</span></li></ol><p id="u612b02d8" class="ne-p"><span class="ne-text">第一项作为边界情况，暂不考虑，从第二项往后看，三项之间的规律:</span></p><ul class="ne-ul"><li id="ue5e3da76" data-lake-index-type="0"><span class="ne-text">当</span><code class="ne-code"><span class="ne-text">i-1</span></code><span class="ne-text">项&gt;</span><code class="ne-code"><span class="ne-text">i-2</span></code><span class="ne-text">项：需要剪掉一个完整abc整体，即</span><code class="ne-code"><span class="ne-text">f(i) = f(i-1) - 1</span></code></li><li id="u303c6bc6" data-lake-index-type="0"><span class="ne-text">其余情况：</span><code class="ne-code"><span class="ne-text">f(i) = f(i-1) + 2</span></code></li></ul><ol start="2" class="ne-ol"><li id="u3bd15099" data-lake-index-type="0"><span class="ne-text" style="background-color: #FBDE28">初始状态</span></li></ol><p id="u10e133f3" class="ne-p"><span class="ne-text">第一项默认填充一个完整的abc</span></p><pre><code><code>function addMinimum(word: string): number &#123;  const n = word.length;  const arr = new Array(n + 1).fill(0);  for (let i = 1; i &lt;= n; i++)     arr[i] = i &gt; 1 &amp;&amp; word[i - 2] &lt; word[i - 1] ? arr[i - 1] - 1 : arr[i - 1] + 2  return arr[n]&#125;;</code></code></pre><h3 id="kXkn9"><span class="ne-text">穷举算法</span></h3><pre><code><code>function addMinimum(word: string): number &#123;  if (!word.replaceAll('abc', '').length) return 0  let count = 0;  for (let i = 0; i &lt; word.length; i++) &#123;    const curr = word[i]    const next = i + 1 !== word.length ? word[i + 1] : null    if (i === 0) &#123;      if (curr === 'b') &#123;        count = count + 1      &#125; else if (curr === 'c') &#123;        count = count + 2      &#125;    &#125;    if (next) &#123;      if (curr === 'a') &#123;        if (next === 'a')&#123;          count = count + 2        &#125; else if (next === 'c') &#123;          count = count + 1        &#125;      &#125; else if (curr === 'b') &#123;        if (next === 'a')&#123;          count = count + 1        &#125; else if (next === 'b') &#123;          count = count + 2        &#125;       &#125; else if (curr === 'c') &#123;        if (next === 'b') &#123;          count = count + 1        &#125; else if (next === 'c') &#123;          count = count + 2        &#125;      &#125;    &#125; else &#123;      if (curr === 'b') &#123;        count = count + 1      &#125; else if (curr === 'a') &#123;        count = count + 2      &#125;    &#125;  &#125;  return count&#125;;</code></code></pre></div>]]></content>
      
      
      <categories>
          
          <category> 计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 🔢动态规划算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>React系统学习（三）组件通信</title>
      <link href="/blog/ugugf75zazxyxy8t/"/>
      <url>/blog/ugugf75zazxyxy8t/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h3 id="Hp11O"><span class="ne-text">父传子（Props）</span></h3><p id="u33a79e2b" class="ne-p"><span class="ne-text">利用props传值</span></p><ol class="ne-ol"><li id="u1fc1373b" data-lake-index-type="0"><span class="ne-text">组件默认值的写法</span></li></ol><ol start="2" class="ne-ol"><li id="u65cf9e83" data-lake-index-type="0"><span class="ne-text">点标记写法就相当于组件作为一个对象值</span></li></ol><pre><code><code>const Son = (props: any) =&gt; &#123;  console.log('parent to son: ', props);  return &lt;div&gt;son&lt;/div&gt;;&#125;;// Son default propsSon.defaultProps = &#123;  msg: 'son-default-msg',&#125;;<p>export default () =&gt; &#123;<br>  const [parentMsg, setParentMsg] = useState(‘parent-msg’);<br>  return (<br>    &lt;&gt;<br>      &lt;h1&gt;react-message&lt;/h1&gt;<br>      parent<br>      &lt;Son msg=&#123;parentMsg&#125; /&gt;<br>    &lt;/&gt;<br>  );<br>&#125;;<br></code><br></code></pre></p><h3 id="hSjM1"><span class="ne-text">子传父</span></h3><p id="u10d5d71a" class="ne-p"><span class="ne-text"> 在父组件定义响应式变量，同时传递一个回调函数参数给子组件，子组件再利用调用回调函数给便父组件所定义的响应式变量</span></p><pre><code><code>const Son = (props: any) =&gt; &#123;  console.log('parent to son: ', props.msg);  const sonToParentClick = () =&gt; &#123;    props.getSonValue('son-to-parent-msg');  &#125;;  return (    &lt;div&gt;      son&lt;button onClick=&#123;sonToParentClick&#125;&gt;son-to-parent&lt;/button&gt;    &lt;/div&gt;  );&#125;;Son.defaultProps = &#123;  msg: 'son-default-msg',&#125;;<p>export default () =&gt; &#123;<br>  const [parentToSonMsg, setParentToSonMsg] = useState(‘parent-to-son-msg’);<br>  const [getSonMsg, setGetSonMsg] = useState(‘’);<br>  const getSonValue = (msg: string) =&gt; &#123;<br>    console.log(‘son-to-parent-msg: ‘, msg);<br>    setGetSonMsg(msg);<br>  &#125;;<br>  return (<br>    &lt;&gt;<br>      &lt;h1&gt;react-message&lt;/h1&gt;<br>      parent<br>      &lt;Son msg=&#123;parentToSonMsg&#125; getSonValue=&#123;getSonValue&#125; /&gt;<br>    &lt;/&gt;<br>  );<br>&#125;;<br></code><br></code></pre></p><h3 id="C0st3"><span class="ne-text">爷传后代</span></h3><h4 id="XjAnb"><span class="ne-text">爷传孙</span></h4><ol class="ne-ol"><li id="u2c9e1c20" data-lake-index-type="0"><span class="ne-text">第一种方式就是利用剩余参数爷传子，子再传孙，不过这种方式繁琐且不便维护</span></li><li id="ub393f0aa" data-lake-index-type="0"><span class="ne-text">利用下面的透传方式</span></li></ol><h4 id="NgI5A"><span class="ne-text">透传（Context）</span></h4><pre><code><code>import &#123; createContext &#125; from 'react';<p>const Context = createContext(&#123;&#125;);</p><p>const Son = (props: any) =&gt; &#123;<br>  console.log(‘parent to son: ‘, props.msg);<br>  const sonToParentClick = () =&gt; &#123;<br>    props.getSonValue(‘son-to-parent-msg’);<br>  &#125;;<br>  return (<br>    &lt;&gt;<br>      &lt;div&gt;<br>        son&lt;button onClick=&#123;sonToParentClick&#125;&gt;son-to-parent&lt;/button&gt;<br>      &lt;/div&gt;<br>      &lt;GradeSon /&gt;<br>    &lt;/&gt;<br>  );<br>&#125;;<br>Son.defaultProps = &#123;<br>  msg: ‘son-default-msg’,<br>&#125;;</p><p>const GradeSon = () =&gt; &#123;<br>  const getGrandFather = useContext(Context);<br>  console.log(‘get-grand-father: ‘, getGrandFather);<br>  return &lt;div&gt;GradeSon&lt;/div&gt;;<br>&#125;;</p><p>export default () =&gt; &#123;<br>  const [parentToSonMsg, setParentToSonMsg] = useState(‘parent-to-son-msg’);<br>  const [parentToGradeSonMsg, setParentToGradeSonMsg] = useState(&#123; a: 11, b: 22 &#125;);<br>  const [getSonMsg, setGetSonMsg] = useState(‘’);<br>  const getSonValue = (msg: string) =&gt; &#123;<br>    console.log(‘son-to-parent-msg: ‘, msg);<br>    setGetSonMsg(msg);<br>  &#125;;<br>  return (<br>    &lt;Context.Provider value=&#123;parentToGradeSonMsg&#125;&gt;<br>      &lt;h1&gt;react-message&lt;/h1&gt;<br>      parent<br>      &lt;Son msg=&#123;parentToSonMsg&#125; getSonValue=&#123;getSonValue&#125; /&gt;<br>    &lt;/Context.Provider&gt;<br>  );<br>&#125;;<br></code><br></code></pre></p><h3 id="kPf70"><span class="ne-text">EventBus</span></h3><p id="u56c51230" class="ne-p"><span class="ne-text">事件总线的方式，其实这属于前端通用的一种设计模式，在线编辑器常用的一种代码设计模式</span></p><ol class="ne-ol"><li id="ue47632f0" data-lake-index-type="0"><span class="ne-text">事件封装：只封装了on、emit、off事件，实际上封装形式不一，也可以使用三方库等</span></li></ol><pre><code><code>type StringKeyOf&lt;T&gt; = Extract&lt;keyof T, string&gt;;type CallbackType&lt;  T extends Record&lt;string, any&gt;,  EventName extends StringKeyOf&lt;T&gt;,&gt; = T[EventName] extends any[] ? T[EventName] : [T[EventName]];type CallbackFunction&lt;T extends Record&lt;string, any&gt;, EventName extends StringKeyOf&lt;T&gt;&gt; = (  ...props: CallbackType&lt;T, EventName&gt;) =&gt; any;<p>export class EventEmitter&lt;T extends Record&lt;string, any&gt;&gt; &#123;<br>  private callbacks: &#123; [key: string]: Function[] &#125; = &#123;&#125;;</p><p>  public on&lt;EventName extends StringKeyOf&lt;T&gt;&gt;(<br>    event: EventName,<br>    fn: CallbackFunction&lt;T, EventName&gt;,<br>  ): this &#123;<br>    if (!this.callbacks[event]) &#123;<br>      this.callbacks[event] = [];<br>    &#125;</p><pre><code>this.callbacks[event].push(fn);return this;</code></pre><p>  }</p><p>  public emit&lt;EventName extends StringKeyOf&lt;T&gt;&gt;(<br>    event: EventName,<br>    …args: CallbackType&lt;T, EventName&gt;<br>  ): this {<br>    const callbacks = this.callbacks[event];</p><pre><code>if (callbacks) &#123;  callbacks.forEach(callback =&amp;gt; callback.apply(this, args));&#125;return this;</code></pre><p>  }</p><p>  public off&lt;EventName extends StringKeyOf&lt;T&gt;&gt;(<br>    event: EventName,<br>    fn?: CallbackFunction&lt;T, EventName&gt;,<br>  ): this {<br>    const callbacks = this.callbacks[event];</p><pre><code>if (callbacks) &#123;  if (fn) &#123;    this.callbacks[event] = callbacks.filter(callback =&amp;gt; callback !== fn);  &#125; else &#123;    delete this.callbacks[event];  &#125;&#125;return this;</code></pre><p>  }</p><p>  protected removeAllListeners(): void {<br>    this.callbacks = {};<br>  }<br>}</p><p>const EventBus = new EventEmitter();<br>export default EventBus;</code><br></code></pre></p><ol start="2" class="ne-ol"><li id="uc993bf4f" data-lake-index-type="0"><span class="ne-text">使用</span></li></ol><ol class="ne-list-wrap"><ol ne-level="1" class="ne-ol"><li id="uaaccabd0" data-lake-index-type="0"><span class="ne-text">Daughter组件定义，Son组件触发</span></li><li id="u16a192b3" data-lake-index-type="0"><span class="ne-text">有注册就要有注销，不然内存中会出现重复事件逻辑多次执行的问题</span></li></ol></ol><pre><code><code>import &#123; createContext &#125; from 'react';import EventBus from '@/utils/eventEmitter';<p>const Context = createContext(&#123;&#125;);</p><p>const Son = (props: any) =&gt; &#123;<br>  console.log(‘parent to son: ‘, props.msg);<br>  const sonToParentClick = () =&gt; &#123;<br>    props.getSonValue(‘son-to-parent-msg’);<br>    EventBus.emit(‘daughterEvent’, &#123;<br>      msg: ‘son-to-daughter-msg’,<br>    &#125;);<br>  &#125;;<br>  return (<br>    &lt;&gt;<br>      &lt;div&gt;<br>        son&lt;button onClick=&#123;sonToParentClick&#125;&gt;son-to-parent&lt;/button&gt;<br>      &lt;/div&gt;<br>      &lt;GradeSon /&gt;<br>    &lt;/&gt;<br>  );<br>&#125;;<br>Son.defaultProps = &#123;<br>  msg: ‘son-default-msg’,<br>&#125;;</p><p>const Daughter = () =&gt; &#123;<br>  useEffect(() =&gt; &#123;<br>    function daughterEvent(data: any) &#123;<br>      console.warn(‘daughter event: ‘, data);<br>    &#125;<br>    EventBus.on(‘daughterEvent’, daughterEvent);<br>    return () =&gt; &#123;<br>      EventBus.off(‘daughterEvent’, daughterEvent);<br>    &#125;;<br>  &#125;, []);<br>  return &lt;div&gt;Daughter&lt;/div&gt;;<br>&#125;;</p><p>const GradeSon = () =&gt; &#123;<br>  const getGrandFather = useContext(Context);<br>  console.log(‘get-grand-father: ‘, getGrandFather);<br>  return &lt;div&gt;GradeSon&lt;/div&gt;;<br>&#125;;</p><p>export default () =&gt; &#123;<br>  const [parentToSonMsg, setParentToSonMsg] = useState(‘parent-to-son-msg’);<br>  const [parentToGradeSonMsg, setParentToGradeSonMsg] = useState(&#123; a: 11, b: 22 &#125;);<br>  const [getSonMsg, setGetSonMsg] = useState(‘’);<br>  const getSonValue = (msg: string) =&gt; &#123;<br>    console.log(‘son-to-parent-msg: ‘, msg);<br>    setGetSonMsg(msg);<br>  &#125;;<br>  return (<br>    &lt;&gt;<br>      &lt;Context.Provider value=&#123;parentToGradeSonMsg&#125;&gt;<br>        &lt;h1&gt;react-message&lt;/h1&gt;<br>        parent<br>        &lt;Son msg=&#123;parentToSonMsg&#125; getSonValue=&#123;getSonValue&#125; /&gt;<br>      &lt;/Context.Provider&gt;<br>      &lt;Daughter /&gt;<br>    &lt;/&gt;<br>  );<br>&#125;;<br></code><br></code></pre></p><h3 id="DYES7"><span class="ne-text">状态管理</span></h3><p id="u2c679f4e" class="ne-p"><span class="ne-text">状态管理所定义的Module变化，所使用到的组件也会响应式更新，不做详细记录。</span></p></div>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
          <category> React </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>React系统学习（二）生态链</title>
      <link href="/blog/okaxuuoq9kqk5hv3/"/>
      <url>/blog/okaxuuoq9kqk5hv3/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="uf81223da" class="ne-p"><span class="ne-text">生态系统有服务端渲染等，暂只对路由以及状态管理做部分记录。</span></p><h3 id="RG1RA"><span class="ne-text">路由Router</span></h3><ol class="ne-ol"><li id="u8de104d9" data-lake-index-type="0"><span class="ne-text">useParams：获取动态路由的路径值</span></li><li id="u5450e7cd" data-lake-index-type="0"><span class="ne-text">&lt;NavLink /&gt;：带样式的声明式路由</span></li><li id="u4f82b40a" data-lake-index-type="0"><span class="ne-text">useNavigate：编程式路由</span></li></ol><ol class="ne-list-wrap"><ol ne-level="1" class="ne-ol"><li id="uf612b599" data-lake-index-type="0"><span class="ne-text">第一个参数：跳转路径</span></li><li id="ude9b2662" data-lake-index-type="0"><span class="ne-text">第二个参数（state）：携带信息对象</span></li></ol></ol><ol start="4" class="ne-ol"><li id="u918edaba" data-lake-index-type="0"><span class="ne-text">useLocation</span></li><li id="ue0f4492b" data-lake-index-type="0"><span class="ne-text">useSearchParams：可以结构，同useState，第二个参数同样可以设置浏览器地址栏的url params </span></li><li id="u859c95b4" data-lake-index-type="0"><span class="ne-text">lodaer：路由表的字段，路由跳转前的处理函数，支持异步，这里做调取权限查询接口等逻辑</span></li></ol><ol class="ne-list-wrap"><ol ne-level="1" class="ne-ol"><li id="ua7441b4e" data-lake-index-type="0"><span class="ne-text">如果返回值需要重定向指定url -&gt; </span><code class="ne-code"><span class="ne-text">return redirect('login')</span></code></li></ol></ol><ol start="7" class="ne-ol"><li id="u28cc1c98" data-lake-index-type="0"><span class="ne-text">meta：自定义元信息</span></li></ol><ol class="ne-list-wrap"><ol ne-level="1" class="ne-ol"><li id="u167efcc8" data-lake-index-type="0"><span class="ne-text">组件中获取元信息：matchRoutes和useLocation</span></li></ol></ol><span style="margin-left: 2em"><pre><code><code>const location = useLocation()const matchs = matchRoutes(routes, location)const meta = matchs[matchs.length - 1].route.meta</code></code></pre></span><h3 id="Cavfr"><span class="ne-text">状态管理Redux</span></h3><p id="ubbcb0f40" class="ne-p"><span class="ne-text">Redux是一个独立的状态管理的库。</span></p><ol class="ne-ol"><li id="u916db48f" data-lake-index-type="0"><span class="ne-text">react-redux：对于redux封装至更符合react理念的库</span></li></ol><ol class="ne-list-wrap"><ol ne-level="1" class="ne-ol"><li id="u056b4da4" data-lake-index-type="0"><span class="ne-text">useSelector</span></li><li id="ua86b158c" data-lake-index-type="0"><span class="ne-text">useDispatch</span></li></ol></ol><ol start="2" class="ne-ol"><li id="u7b50b918" data-lake-index-type="0"><span class="ne-text">Redux-Toolkit：</span></li></ol><ol class="ne-list-wrap"><ol ne-level="1" class="ne-ol"><li id="ucbbfbb0c" data-lake-index-type="0"><span class="ne-text">封装redux的大多数操作</span></li><li id="u4f0fc676" data-lake-index-type="0"><span class="ne-text">优化异步处理createAsyncThunk</span></li></ol></ol><ol start="3" class="ne-ol"><li id="u728fa4d6" data-lake-index-type="0"><span class="ne-text">redux-persist：数据持久化处理</span></li></ol><p id="ub8fac65f" class="ne-p"><span class="ne-text"></span></p><p id="uab0de432" class="ne-p"><span class="ne-text"></span></p><p id="u2486779b" class="ne-p"><span class="ne-text"></span></p><p id="u7573cf56" class="ne-p"><span class="ne-text"></span></p><p id="u10ec026e" class="ne-p"><span class="ne-text"></span></p><p id="u5e88c3f6" class="ne-p"><span class="ne-text"></span></p><p id="u4e1d4445" class="ne-p"><span class="ne-text"></span></p><p id="ue1c440ca" class="ne-p"><span class="ne-text"></span></p><p id="uf7d94f98" class="ne-p"><span class="ne-text"></span></p></div>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
          <category> React </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>React系统学习（一）类组件和函数组件</title>
      <link href="/blog/wnb93ckult99ixhg/"/>
      <url>/blog/wnb93ckult99ixhg/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h3 id="xVmON"><span class="ne-text">虚拟DOM以及React挂载DOM的方式</span></h3><ol class="ne-ol"><li id="u0893e863" data-lake-index-type="0"><span class="ne-text">利用JavaScript脚本操作DOM的行为是性能损耗的大头，故产生虚拟DOM的概念。初始化在内存中得到相应的虚拟DOM树，然后将该结果一次性作用于真实DOM，逻辑层的变动导致部分视图层的改变这渲染逻辑也是经过虚拟DOM加上diff得到一次性结果然后作用于真实DOM，在这里Vue和React都是一样的。</span></li><li id="u7537df37" data-lake-index-type="0"><span class="ne-text">可以简单理解：react模块旨在完成虚拟dom的相关逻辑，react-dom模块旨在完成真实DOM和diff的处理</span></li></ol><pre><code><code>// mount containerrootReactDOM.createRoot(document.querySelector('#root'))// create VDOMconst data = React.createElement('div', &#123;&#125;, 'data')// VDOM -&gt; true DOMroot.render(data)</code></code></pre><h3 id="vL2nu"><span class="ne-text">JSX</span></h3><p id="u20bc5507" class="ne-p"><span class="ne-text">上述ReactDOM生成虚拟DOM的方式，实际编写代码不方便，于是出现了类似JSX来简化视图层的代码编写（Vue中利用Template模板来完成相同视图层的逻辑构建）</span></p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/1484158/1703514464788-2de399dc-93ec-4dec-aa38-e6b6c706f0ea.jpeg" id="iIrkc" style="display: block; width: 100%"><ol start="2" class="ne-ol"><li id="uec638825" data-lake-index-type="0"><span class="ne-text">JSX的识别要么在jsx后缀文件书写相关代码逻辑，要么利用babel工具来进行代码转义..</span></li></ol><pre><code><code>const data = (  &lt;div&gt;    content&lt;span&gt;something...&lt;/span&gt;  &lt;/div&gt;)root.render(data)</code></code></pre><ol start="3" class="ne-ol"><li id="u5676031e" data-lake-index-type="0"><span class="ne-text">模板语法：</span><code class="ne-code"><span class="ne-text">&#123;&#125;</span></code><span class="ne-text">，Vue是是</span><code class="ne-code"><span class="ne-text">&#123;&#123;&#125;&#125;</span></code></li></ol><ol class="ne-list-wrap"><ol ne-level="1" class="ne-ol"><li id="u9c91fce8" data-lake-index-type="0"><span class="ne-text">注释：</span><code class="ne-code"><span class="ne-text">&#123;/* */&#125;</span></code></li><li id="ubb6f0de2" data-lake-index-type="0"><span class="ne-text">内容可以变量、函数、JSX嵌套 ······</span></li></ol></ol><ol start="4" class="ne-ol"><li id="u77d43f1f" data-lake-index-type="0"><span class="ne-text">JSX注意事项</span></li></ol><ol class="ne-list-wrap"><ol ne-level="1" class="ne-ol"><li id="u8c6babba" data-lake-index-type="0"><span class="ne-text">严格单标签（</span><code class="ne-code"><span class="ne-text">&lt;Tab /&gt;</span></code><span class="ne-text">）</span></li><li id="ub546b2eb" data-lake-index-type="0"><span class="ne-text">标签名小写</span></li><li id="u0a3d772d" data-lake-index-type="0"><span class="ne-text">唯一根节点 -&gt; </span><code class="ne-code"><span class="ne-text">&lt;&gt;&lt;/&gt;</span></code><span class="ne-text"> 或 </span><code class="ne-code"><span class="ne-text">React.Fragment</span></code></li><li id="u3a39620f" data-lake-index-type="0"><span class="ne-text">部分HTML属性名变动：</span><code class="ne-code"><span class="ne-text">class -&gt; className</span></code><span class="ne-text">; </span><code class="ne-code"><span class="ne-text">for -&gt; htmlFor</span></code><span class="ne-text"> ······</span></li><li id="u70ef716d" data-lake-index-type="0"><span class="ne-text">多单词属性用驼峰方式书写，dataset除外</span></li></ol></ol><h3 id="E1Lfq"><span class="ne-text">理解类组件</span></h3><ol class="ne-ol"><li id="ud1f196e0" data-lake-index-type="0"><span class="ne-text">组件的概念也就是模块的拆分、抽象和复用，和Vue组件一致，React的组件编写有两种，</span><strong><span class="ne-text">类组件</span></strong><span class="ne-text">和</span><strong><span class="ne-text">函数组件</span></strong><span class="ne-text">，实际编写代码，React18函数式组件编写更为推崇，但是理解上以类组件会更好。</span></li><li id="u73a8c970" data-lake-index-type="0"><span class="ne-text">具体类组件的编写，其实就是在面向对象编程，给你一个已知类React.Component，写具体逻辑时，遵照所继承的类的一些规则来扩展业务代码。</span></li></ol><h4 id="qjAcc"><span class="ne-text">简单的父子通信</span></h4><pre><code><code>// A componentclass A extends React.Component &#123;  constructor(props) &#123;    super(props)    this.props = props  &#125;  render &#123;    this.props.getData('data')    return (      &lt;div&gt;A component &#123;this.props.info&#125; &lt;/div&gt;    )  &#125;&#125;// B componentconst getData = (data) =&gt; &#123;  // result -&gt; data&#125;const data = &lt;div&gt;content &lt;A info='something' getData=&#123;getData&#125; /&gt; &lt;/div&gt;</code></code></pre><h4 id="Mh3VX"><span class="ne-text">props相关事项</span></h4><ol class="ne-ol"><li id="u64411e8a" data-lake-index-type="0"><span class="ne-text">传入组件的参数可以用扩展运算符来传入</span></li></ol><pre><code><code>const data = &#123;  info: 'something,  getData: (data) =&gt; &#123;&#125;,&#125;const data = &lt;div&gt;&lt;A &#123;...data&#125; /&gt;&lt;/div&gt;</code></code></pre><ol start="2" class="ne-ol"><li id="u855e1be4" data-lake-index-type="0"><span class="ne-text">单独属性值为true</span></li><li id="uf093ffd6" data-lake-index-type="0"><span class="ne-text">类组件的默认值</span></li></ol><pre><code><code>// A componentclass A extends React.Component &#123;  static defaultProps = &#123;    info: 'default info',  &#125;  constructor(props) &#123;    super(props)    this.props = props  &#125;  render &#123;    this.props.getData('data')    return (      &lt;div&gt;A component &#123;this.props.info&#125; &lt;/div&gt;    )  &#125;&#125;</code></code></pre><h4 id="PV0r6"><span class="ne-text">响应式变量</span></h4><p id="uc9c5250a" class="ne-p"><span class="ne-text">前端框架必须具体的一个能力就是响应式变量的构造，以及内部实现的动态渲染，react的响应式变量就是构造类的一个私有变量state，再利用其规定指定的方法setState方法来实现响应式</span></p><pre><code><code>class A extends React.Component &#123;  state &#123;    a: 1,  &#125;  static defaultProps = &#123;    info: 'default info',  &#125;  constructor(props) &#123;    super(props)    this.props = props  &#125;  render &#123;    this.props.getData('data')    return (      &lt;div&gt;A component &#123;this.props.info&#125; &lt;/div&gt;    )  &#125;handleMethod() &#123;    this.setState(&#123; a: 2 &#125;)&#125;&#125;</code></code></pre><div data-type="info" class="ne-alert"><p id="ub5f23f2f" class="ne-p"><span class="ne-text">如果响应式的值为数组呢？</span></p></div><ol class="ne-ol"><li id="ued321890" data-lake-index-type="0"><span class="ne-text">react里面的响应式的值为不可变数据集合，比较简单的情况可以利用剩余参数来解决该问题。</span></li></ol><pre><code><code>class A extends React.Component &#123;  state =&#123;    a: [1, 2, 3]  &#125;  ···  handleMethod() &#123;    this.setState(&#123; a: [...a, 4] &#125;)  &#125;&#125;</code></code></pre><ol start="2" class="ne-ol"><li id="ubcbe280c" data-lake-index-type="0"><span class="ne-text">深拷贝</span></li></ol><p id="uee425f9f" class="ne-p"><span class="ne-text">（TODO:  应该有更好的解决方式）</span></p><h4 id="xfck5"><span class="ne-text">批处理</span></h4><p id="ufd1bdefd" class="ne-p"><span class="ne-text">响应式处理，内部会一次性收集当前变化的量，进入一个处理队列，最终得到一个最终态来进行渲染，避免状态改变多次渲染的情况。</span></p><ol class="ne-ol"><li id="u0706a769" data-lake-index-type="0"><span class="ne-text">React18之前，在一些函数执行时机下，不会进行批处理，React18之后解决了这个问题。具体有：Promise、setTimeout、原生事件下</span></li><li id="u4bc7f994" data-lake-index-type="0"><span class="ne-text">React提供了防止批处理的函数</span></li></ol><pre><code><code>class A extends React.Component &#123;  state =&#123;    a: 1  &#125;  ···  handleMethod() &#123;    ReactDOM.flushSync(() =&gt; &#123;      this.setState(&#123; a: this.state.a + 1 &#125;)      this.setState(&#123; a: this.state.a + 1 &#125;)    &#125;)    // result: run twice render method...  &#125;  render &#123;    console.info('react render.')    return (      &lt;div&gt;A component &#123;this.props.info&#125; &lt;/div&gt;    )  &#125;&#125;</code></code></pre><ol start="3" class="ne-ol"><li id="uc4f4442b" data-lake-index-type="0"><span class="ne-text">setState是一个一个异步函数，其第二个参数可以传入回调函数，以便写状态改变之后的相关业务逻辑</span></li><li id="uc0538438" data-lake-index-type="0"><span class="ne-text">如果传入setState的值是对象，那么会在响应式内部所收集变化的量里面进行覆盖，如果需要实时根据最新变化的量做逻辑处理，则需要传入一个参数为state的回调函数</span></li></ol><pre><code><code>class A extends React.Component &#123;  state =&#123;    a: 1  &#125;  ···  handleMethod() &#123;    // 1. cover state    this.setState(&#123; a: this.state.a + 1 &#125;)    this.setState(&#123; a: this.state.a + 1 &#125;)    // result: a -&gt; 2    // 2. real time state    this.setState((state) =&gt; &#123; a: this.state.a + 1 &#125;)    this.setState((state) =&gt; &#123; a: this.state.a + 1 &#125;)    // result: a -&gt; 3  &#125;&#125;</code></code></pre><h4 id="ZhZcD"><span class="ne-text">PureComponent shouldComponentUpdate</span></h4><p id="u1410dea8" class="ne-p"><span class="ne-text">下面代码，因响应式变量变化，所以会执行一次render渲染</span></p><pre><code><code>class A extends React.Component &#123;  state =&#123;    a: 1  &#125;  ···  handleMethod() &#123;    this.setState(&#123; a: 1 &#125;)  &#125;  render &#123;    console.info('react render.')    return (      &lt;div&gt;A component &#123;this.props.info&#125; &lt;/div&gt;    )  &#125;&#125;</code></code></pre><p id="u17863ce9" class="ne-p"><span class="ne-text">上面情况其实响应式的结果都是a变为1，所以从渲染结果上看其实可以优化掉该种情况的渲染，react提供的渲染优化方式有两种：</span></p><p id="u185cfd38" class="ne-p"><span class="ne-text"></span></p><ol class="ne-ol"><li id="ub05164da" data-lake-index-type="0"><span class="ne-text">PureComponent优化组件</span></li></ol><pre><code><code>class A extends React.PureComponent &#123;  ···&#125;</code></code></pre><ol start="2" class="ne-ol"><li id="u79b67ec0" data-lake-index-type="0"><span class="ne-text">shouldComponentUpdate生命周期函数</span></li></ol><pre><code><code>class A extends React.Component &#123;  state =&#123;    a: 1  &#125;  ···  shouldComponentUpdate = (nextProps, nextState) =&gt; &#123;    if (nextState.a === this.state.a)    return false // not render    return true // run render  &#125;  render &#123;    console.info('react render.')    return (      &lt;div&gt;A component &#123;this.props.info&#125; &lt;/div&gt;    )  &#125;&#125;</code></code></pre><h4 id="pQyxA"><span class="ne-text">Refs</span></h4><p id="ub19f3212" class="ne-p"><span class="ne-text">框架只是对渲染dom的前置操作做了一层封装，比如先构造虚拟dom或是渲染时机的优化等，但有些时候需要在业务代码里面直接获取dom进行操作，比如input标签的自动聚焦（focus）</span></p><ol class="ne-ol"><li id="u0cc8c58c" data-lake-index-type="0"><span class="ne-text">变量</span></li></ol><pre><code><code>// A componentclass A extends React.Component &#123;  inputRef = React.createRef()  // this.inputRef.current // -&gt; Input DOM  render &#123;    return (      &lt;div&gt;      A component        &lt;input ref=&#123;inputRef&#125; /&gt;      &lt;/div&gt;    )  &#125;&#125;</code></code></pre><ol start="2" class="ne-ol"><li id="u2a7e01e5" data-lake-index-type="0"><span class="ne-text">回调函数</span></li></ol><pre><code><code>// A componentclass A extends React.Component &#123;  inputRef = (dom) =&gt; &#123;    dom.focus()  &#125;  // this.inputRef.current // -&gt; Input DOM  render &#123;    return (      &lt;div&gt;      A component        &lt;input ref=&#123;inputRef&#125; /&gt;      &lt;/div&gt;    )  &#125;&#125;</code></code></pre><ol start="3" class="ne-ol"><li id="u4ef7dd4c" data-lake-index-type="0"><span class="ne-text">除了可以得到DOM，也可以得到类组件的实例对象</span></li></ol><pre><code><code>// A componentclass A extends React.Component &#123;···&#125;// B componentclass B extends React.Component &#123;refData = React.createRef()   render() &#123;    return &lt;div&gt;content &lt;A ref=&#123;refData&#125; /&gt; &lt;/div&gt;  &#125;&#125;</code></code></pre><h4 id="Q0460"><span class="ne-text">生命周期</span></h4><p id="u55e5dd6b" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2023/png/1484158/1703663129914-06e9fada-b622-489d-813f-9d0ed1dbba41.png" width="1511.6666065984325" id="ud7af5c92" class="ne-image"></p><h4 id="oH5uK"><span class="ne-text">组件模式：RenderProps</span></h4><pre><code><code>class A extends React.Component &#123;  state = &#123;    x: 0,    y: 0,  &#125;  constructor(props) &#123;    super(props)    this.props = props  &#125;  componentDidMount = () =&gt; &#123;    document.addEventListener('mousemove', this.move)  &#125;  componentWillUnMount = () =&gt; &#123;    document.removeEventListener('mousemove', this.move)  &#125;  move = (e) =&gt; &#123;    this.setState(&#123;      x: e.pageX,      y: e.pageY,    &#125;)  &#125;render() &#123;    return (      &lt;React.Fragment&gt;      &#123; this.props.render(this.state.x, this.state.y)&#125;      &lt;/React.Fragment&gt;    )  &#125;&#125;class B extends React.Component &#123;render() &#123;    return &lt;A render=&#123;(x, y) =&gt; &#123;      &lt;div&gt;&#123;x&#125;, &#123;y&#125;&lt;/div&gt;    &#125;&#125; /&gt;  &#125;&#125;</code></code></pre><h4 id="G0eUR"><span class="ne-text">组件模式：HOC</span></h4><p id="u7d429497" class="ne-p"><span class="ne-text">参数为组件，返回新组件</span></p><pre><code><code>function hocFun(WithComponent) &#123;  return class extends React.Component &#123;    state = &#123;      x: 0,      y: 0,    &#125;    componentDidMount = () =&gt; &#123;      document.addEventListener('mousemove', this.move)    &#125;    componentWillUnMount = () =&gt; &#123;      document.removeEventListener('mousemove', this.move)    &#125;    move = (e) =&gt; &#123;      this.setState(&#123;        x: e.pageX,        y: e.pageY,      &#125;)    &#125;      render() &#123;      return &lt;WithComponent &#123;...this.state&#125; /&gt;    &#125;  &#125;&#125;class A extends React.Component &#123;  render() &#123;    return (      &lt;div&gt;          &#123;this.props.x&#125;, &#123;this.props.y&#125;      &lt;/div&gt;    )  &#125;&#125;const C = hocFun(A)class B extends React.Component &#123;    render() &#123;    return &lt;C /&gt;  &#125;&#125;</code></code></pre><h4 id="L9n58"><span class="ne-text">Context通信</span></h4><pre><code><code>const ContextData = React.createContext()<p>class A extends React.Component &#123;<br>  state = &#123;<br>    info: ‘something’<br>  &#125;<br>  render() &#123;<br>    return (<br>      A<br>      &lt;ContextData.Provider value=&#123;this.state.info&#125;&gt;<br>          &lt;B /&gt;<br>      &lt;/ContextData.Provider&gt;<br>    )<br>  &#125;<br>&#125;<br>class B extends React.Component &#123;<br>    render() &#123;<br>    return (<br>      B&lt;C /&gt;<br>    )<br>  &#125;<br>&#125;<br>class C extends React.Component &#123;<br>  static contextType = ContextData<br>  componentDidMount = () =&gt; &#123;<br>    console.lof(this.context)<br>  &#125;<br>    render() &#123;<br>    return (<br>      C<br>      &lt;ContextData.Consumer&gt;&#123; value =&gt; value &#125;&lt;/ContextData.Consumer&gt;<br>    )<br>  &#125;<br>&#125;<br>// render -&gt; ABCsomething</code><br></code></pre></p><h3 id="NZSgh"><span class="ne-text">函数组件</span></h3><h4 id="QmOfo"><span class="ne-text">useState</span></h4><p id="uc98a614a" class="ne-p"><span class="ne-text">响应式变量的声明和改变</span></p><pre><code><code>import &#123; useState &#125; from 'React'const A = () =&gt; &#123;  const [a, setA] = useState('a')  return &lt;div&gt;a value: &#123;a&#125;&lt;/div&gt;&#125;</code></code></pre><p id="u5c324387" class="ne-p"><span class="ne-text">和类组件的差异</span></p><ol class="ne-ol"><li id="u157ea2c5" data-lake-index-type="0"><span class="ne-text">改变值的时候不会merge，而是覆盖</span></li><li id="ue3b27c3a" data-lake-index-type="0"><span class="ne-text">初始值可以值回调函数，但不能是函数否则每次改变都会重新执行一遍该函数</span></li><li id="ubf97f0c2" data-lake-index-type="0"><span class="ne-text">同样存在批处理，也有防止批处理的函数</span></li></ol><pre><code><code>import &#123; useState &#125; from 'React'import &#123; flushSync &#125; from 'ReactDDOM'const A = () =&gt; &#123;  const [a, setA] = useState('a')  const [b, setB] = useState('b')  flushSync(() =&gt; &#123;    setA('aa')  &#125;)    flushSync(() =&gt; &#123;    setB('bb')  &#125;)  return &lt;div&gt;a value: &#123;a&#125;&lt;/div&gt;&#125;</code></code></pre><ol start="4" class="ne-ol"><li id="u832252b4" data-lake-index-type="0"><span class="ne-text">传入的是值，渲染前会存在覆盖情况，如果传入的是函数，则会保留上一次的状态值计算</span></li></ol><h4 id="tIoMO"><span class="ne-text">useEffect</span></h4><p id="u5ed09388" class="ne-p"><span class="ne-text">副作用Hook</span></p><ol class="ne-ol"><li id="u28b6342c" data-lake-index-type="0"><span class="ne-text">模拟各个生命周期的执行时机</span></li></ol><pre><code><code>import &#123; useState, useEffect &#125; from 'React'const A = () =&gt; &#123;  useEffect(() =&gt; &#123;    // mount || update    return () =&gt; &#123;      // beforeUpdate || unMount      // clear sider function...    &#125;  &#125;)  return &lt;div&gt;a value: &#123;a&#125;&lt;/div&gt;&#125;</code></code></pre><ol start="2" class="ne-ol"><li id="u8886765a" data-lake-index-type="0"><span class="ne-text">关于第二个数组参数</span></li></ol><ol class="ne-list-wrap"><ol ne-level="1" class="ne-ol"><li id="u29eccab1" data-lake-index-type="0"><span class="ne-text">如果不设置，那么在update时期都会执行</span></li><li id="uaa101652" data-lake-index-type="0"><span class="ne-text">如果设置空数组（且回调函数中没有响应式变量），则只在mount时期执行一次</span></li><li id="u54d7662f" data-lake-index-type="0"><span class="ne-text">如果useEffect回调函数中存在响应式变量，那么第二个参数数组中应当有该响应式变量</span></li></ol></ol><ol start="3" class="ne-ol"><li id="u22c20e06" data-lake-index-type="0"><span class="ne-text">useLayoutEffect</span></li></ol><ol class="ne-list-wrap"><ol ne-level="1" class="ne-ol"><li id="u4977ceef" data-lake-index-type="0"><span class="ne-text">useEffect：渲染并绘制到屏幕之后执行，异步</span></li><li id="u97c48e0a" data-lake-index-type="0"><span class="ne-text">useLayoutEffect：渲染之后，但绘制到屏幕之前执行，同步</span></li><li id="u95a58cbe" data-lake-index-type="0"><span class="ne-text">一般如果回调函数中有DOM的相关操作并且会改变样式，用后者，避免DOM渲染闪屏/白屏，但前者性能方面更好</span></li></ol></ol><h4 id="Y3UvK"><span class="ne-text">useRef</span></h4><ol class="ne-ol"><li id="u32714bac" data-lake-index-type="0"><span class="ne-text">作用在DOM上的回调函数，则为DOM实例</span></li></ol><pre><code><code>const A = () =&gt; &#123;  const elementFun = (dom) =&gt; &#123;    // dom -&gt; input DOM  &#125;  return &lt;div&gt;&lt;input type=&quot;text&quot; ref=&#123;elementFun&#125; /&gt;&lt;/div&gt;&#125;</code></code></pre><ol start="2" class="ne-ol"><li id="ub1ccc233" data-lake-index-type="0"><span class="ne-text">作用在DOM上且为useRef函数，则为带有键为current值为DOM本身的对象</span></li></ol><pre><code><code>import &#123; useRef &#125; from 'React'const A = () =&gt; &#123;  const obj = useRef()  // obj =&gt; &#123; current: inputDOM &#125;  return &lt;div&gt;&lt;input type=&quot;text&quot; ref=&#123;obj&#125; /&gt;&lt;/div&gt;&#125;</code></code></pre><ol start="3" class="ne-ol"><li id="ucebe1755" data-lake-index-type="0"><span class="ne-text">不可以作用在组件上，但是子组件有React.forwardRef（组件转发）可以</span></li></ol><pre><code><code>import &#123; useRef &#125; from 'React'const Son = React.forwardRef((props, ref) =&gt; &#123;  return &lt;div&gt;&lt;input type=&quot;text&quot; ref=&#123;ref&#125; /&gt;&lt;/div&gt;&#125;)const A = () =&gt; &#123;  const obj = useRef()  // obj =&gt; &#123; current: inputDOM &#125;  return &lt;Son ref=&#123;obj&#125; /&gt;&#125;</code></code></pre><ol start="4" class="ne-ol"><li id="udbc656f8" data-lake-index-type="0"><span class="ne-text">利用useRef创建的普通变量，可以具备“记忆”功能，类似于类的实例属性。利用这一点可以设置一个flag来实现组件仅更新时触发的代码执行时机</span></li></ol><pre><code><code>import &#123; useRef, useEffect &#125; from 'React'const A = () =&gt; &#123;  const obj = useRef(false)  const inputOnClick = () =&gt; &#123;    obj.current = true  &#125;  useEffect(() =&gt; &#123;    if (obj.current) &#123;      // only update -&gt; run...    &#125;  &#125;)  return &lt;div&gt;&lt;input type=&quot;text&quot; onClick=&#123;inputOnClick&#125; /&gt;&lt;/div&gt;&#125;</code></code></pre><h4 id="o3MJh"><span class="ne-text">useContext</span></h4><p id="u816841d0" class="ne-p"><span class="ne-text">跨组件通信</span></p><pre><code><code>import &#123; useContext, createContext &#125; from 'React'<p>// not Provider value -&gt; render default value<br>const C = createContext(‘default value…’)</p><p>const GSon = () =&gt; &#123;<br>  const value = useContext(C)<br>  // value -&gt; something…<br>  return &lt;div&gt;GSon template…&lt;/div&gt;<br>&#125;<br>const Son = () =&gt; &#123;<br>  return &lt;GSon /&gt;<br>&#125;</p><p>const A = () =&gt; &#123;</p><p>  return (<br>    &lt;C.Provider value=’something…’&gt;<br>        &lt;Son ref=&#123;obj&#125; /&gt;<br>    &lt;/C.Provider&gt;<br>  )<br>&#125;</code><br></code></pre></p><h4 id="Sc8WH"><span class="ne-text">memo</span></h4><p id="u8f7f8983" class="ne-p"><span class="ne-text">类似类组件中的</span><code class="ne-code"><span class="ne-text">PureComponent</span></code><span class="ne-text">性能优化组件</span></p><ol class="ne-ol"><li id="u993d2be2" data-lake-index-type="0"><span class="ne-text">函数组件中当响应变量的值没有发生改变，不会重新渲染，和类组件不一样</span></li><li id="u110c7560" data-lake-index-type="0"><span class="ne-text">当组件的值发生改变才进行render，反之不进行render</span></li></ol><pre><code><code>import &#123; useState, memo &#125; from 'React'<p>const Son = memo(() =&gt; &#123;<br>  return &lt;div&gt;son&lt;/div&gt;<br>&#125;)</p><p>// continue click -&gt; continue run ↓<br>// const Son = () =&gt; &#123;<br>//   return &lt;div&gt;son&lt;/div&gt;<br>// &#125;</p><p>const A = () =&gt; &#123;<br>  const [count, setCount] = useState(0)<br>  const clickEvent = () =&gt; &#123;<br>    setCount(1)<br>  &#125;<br>  return (<br>    &lt;div&gt;<br>        &lt;button onClick=&#123;clickEvent&#125; &gt;click&lt;/button&gt;<br>        &lt;Son count=&#123;count&#125; /&gt;<br>    &lt;/div&gt;<br>  )<br>&#125;</code><br></code></pre></p><h4 id="hEQq3"><span class="ne-text">useMemo和useCallback</span></h4><p id="u146035fb" class="ne-p"><span class="ne-text">React函数式组件在重新渲染时候，代码执行会将函数体重新执行，即便结果不是重新更新DOM。如果函数体的代码逻辑复杂会带来不小的性能损耗，如果能够对这过程中的部分“量”进行“记忆”，则会较大提升性能。</span></p><p id="u89b5266b" class="ne-p"><span class="ne-text">响应式变量内部会自动进行记忆，但是如果是非响应式变量，比如一个对象或是一个函数传入组件，这其实也是改变了的，原因是对象的引用改变，依然会引起DOM的重新渲染，而利用useMemo或是useCallback创建的对象（对象、数组、函数）则会保留记忆功能。</span></p><ol class="ne-ol"><li id="u5de4e990" data-lake-index-type="0"><span class="ne-text">useCallback：传入回调函数</span></li><li id="u618a838d" data-lake-index-type="0"><span class="ne-text">useMemo：传入一个必须带有返回值的函数</span></li><li id="u18b45d54" data-lake-index-type="0"><span class="ne-text">两者的第二个参数都是依赖数组，同useEffect</span></li></ol><pre><code><code>import &#123; useCallback, useMemo &#125; from 'React'const A = () =&gt; &#123;  // 1. every render -&gt; run  const fun = () =&gt; &#123;&#125;  // 2. useCallback (ignore const error...)  const fun = useCallback(() =&gt; &#123;&#125;, [])  // 3. useMemo (ignore const error...)  const fun = useMemo(() =&gt; () =&gt; &#123;&#125;, [])  const a = useMemo(() =&gt; [1, 2, 3], [])  <p>  return &lt;div onClick=&#123;fun&#125; a=&#123;a&#125;&gt;&lt;/div&gt;<br>&#125;</code><br></code></pre></p><h4 id="zUHaR"><span class="ne-text">useReducer</span></h4><p id="u76ab5b03" class="ne-p"><span class="ne-text">管理多个有关联的响应式变量</span></p><pre><code><code>import &#123; useReducer &#125; from 'React<p>const loginState = &#123; isLogin: true, isLogout: false &#125;<br>const loginReducer = (state, action) =&gt; &#123;<br>  switch(action.type) &#123;<br>    case ‘login’:<br>      return &#123; isLogin: true, isLogout: false &#125;<br>    case ‘logout’:<br>      return &#123; isLogin: false, isLogout: true &#125;<br>    default:<br>      return new Error()<br>  &#125;<br>&#125;</p><p>const A = () =&gt; &#123;<br>  const [state, LoginDispatch] = useReducer(loginReducer, loginState)<br>  const clickEvent = () =&gt; &#123;<br>    loginDispatch(&#123; type: state.isLogin ? ‘logout’ : ‘login’ &#125;)<br>  &#125;</p><p>  return (<br>    &lt;button onClick=&#123;clickEvent&#125;&gt;&#123;state.isLogin ? ‘login’, ‘logout’&#125;&lt;/button&gt;<br>  )<br>&#125;</code><br></code></pre></p><h4 id="ZHgiq"><span class="ne-text">并发模式</span></h4><ol class="ne-ol"><li id="uf47bf115" data-lake-index-type="0"><span class="ne-text">React18之前，渲染是一个单一的、不间断的、同步的事务，一旦渲染开始，就不能被中断</span></li><li id="ufee7a81a" data-lake-index-type="0"><span class="ne-text">React18引入并发模式，它允许你将更新作为一个transitions，这会告诉React他们可以被中断执行。这样可以把紧急的任务先更新你，不紧急的任务后更新</span></li></ol><h4 id="SV5XT"><span class="ne-text">startTransition</span></h4><pre><code><code>import &#123; startTransition &#125; from 'React'const A = () =&gt; &#123;  ...  const fun = () =&gt; &#123;    // 紧急任务    setA('')    // 不紧急任务（将内部的任何非紧急状态更新标记为 Transition）    startTransition(() =&gt; setB(''))  &#125;  return &lt;div&gt;&lt;/div&gt;&#125;</code></code></pre><h4 id="LHIKS"><span class="ne-text">useTransition和useDeferredValue</span></h4><ol class="ne-ol"><li id="ubb651c66" data-lake-index-type="0"><span class="ne-text">useTransition返回一个状态值表示过渡任务的等待状态，以及一个启动该过渡任务的函数</span></li></ol><pre><code><code>import &#123; useTransition &#125; from 'React'const A = () =&gt; &#123;  ...  const [pending, startTransition] = useTransition()  const fun = () =&gt; &#123;    // 紧急任务    setA('')    // 不紧急任务（将内部的任何非紧急状态更新标记为 Transition）    startTransition(() =&gt; setB(''))  &#125;  return &lt;div&gt;&lt;/div&gt;&#125;</code></code></pre><ol start="2" class="ne-ol"><li id="u279291ea" data-lake-index-type="0"><span class="ne-text">useDeferredValue接受一个值，并返回该值的新副本，该副本将推迟到更紧急地更新之后</span></li></ol><pre><code><code>import &#123; useDeferredValue, useState &#125; from 'React'const A = () =&gt; &#123;  const [a, setA] = useState('')  // aD =&gt; 不紧急时候的值（同a），也就是延迟之后的值  const aD = useDeferredValue(a)  ...  return &lt;div&gt;&lt;/div&gt;&#125;</code></code></pre><h4 id="FnTQp"><span class="ne-text">自定义hook</span></h4><ol class="ne-ol"><li id="ue75e76dd" data-lake-index-type="0"><span class="ne-text">命名通常使用use开头</span></li><li id="u2bce0e3e" data-lake-index-type="0"><span class="ne-text"></span></li></ol><pre><code><code>import &#123; useState, useEffect &#125; from 'React'<p>const useMouseXY = () =&gt; &#123;<br>  const [x, setX] = usestate(0)<br>  const [y, setY] = usestate(0)</p><p>  useEffect(() =&gt; &#123;<br>    function move(e) &#123;<br>      setX(e.pageX)<br>      setY(e.pageY)<br>    &#125;<br>    document.addEventListener(‘mousemove’, move)<br>    return () =&gt; document.removeEventListener(‘mousemove’, move)<br>  &#125;, [])</p><p>  return &#123; x, y &#125;<br>&#125;</p><p>// use<br>const &#123; x, y &#125; = useMouseXY()</code><br></code></pre></p><h4 id="JPBEq"><span class="ne-text">lazy</span></h4><p id="udc1f9642" class="ne-p"><span class="ne-text">当模块化引入（import）组件，但在实际代码中未使用到，代码内部逻辑仍会执行，这个时候可以利用lazy使组件异步化加载，从而达到性能优化效果</span></p><pre><code><code>import &#123; lazy &#125; from 'react';<p>const AuthRoute = lazy(() =&gt; import(‘./AuthRoute’));<br>const ErrorPage = lazy(() =&gt; import(‘@/components/ErrorBoundary’));<br>const NotFound = lazy(() =&gt; import(‘@/pages/404’));</code><br></code></pre></p><h4 id="zYL5T"><span class="ne-text">Suspense</span></h4><p id="ueed27788" class="ne-p"><span class="ne-text">组件加载中或是切换过程中的“中间态”</span></p><pre><code><code>import &#123; Suspense, useState &#125; from 'react';import &#123; RouterProvider &#125; from 'react-router-dom';import router from '@/router/index';import Loading from '@/components/Loading';<p>function MyApp() &#123;<br>  const [show, setShow] = useState(true)<br>  const clickEvent = () =&gt; setShow(!show)<br>  return (<br>    &lt;&gt;<br>      &lt;button onClick=&#123;clickEvent&#125;&gt;btn&lt;/button&gt;<br>      &lt;Suspense fallback=&#123;&lt;Loading /&gt;&#125;&gt;<br>        &#123;show ? &lt;RouterProvider router=&#123;router&#125; /&gt; : &lt;&gt;other template&lt;/&gt;&#125;<br>      &lt;/Suspense&gt;<br>    &lt;/&gt;<br>  );<br>&#125;</p><p>export default MyApp;</code><br></code></pre></p><p id="ud8c681f0" class="ne-p"><span class="ne-text">结合startTransition使用：</span></p><p id="uad00f696" class="ne-p"><span class="ne-text">如果需要切换过程中不展示loading的加载态，则将上述代码中的切换逻辑转为并发异步即可</span></p><pre><code><code>const clickEvent = () =&gt; startTransition(() =&gt; setShow(!show))</code></code></pre><h4 id="vA6LY"><span class="ne-text">错误边界捕获</span></h4><p id="uce23988c" class="ne-p"><span class="ne-text">如果编写的组件内部报错，那么react渲染会清除根节点DOM，React官方文档暂时只有类组件编写的示例代码。其核心逻辑在类组件上支持关键的生命周期方法getDerivedStateFromError()和componentDidCatch()，无法将错误边界编写为函数式组件，同时以下几种错误情况，也捕获不到：</span></p><ol class="ne-ol"><li id="u153d38e4" data-lake-index-type="0"><span class="ne-text">异步代码</span></li><li id="u5764c7ba" data-lake-index-type="0"><span class="ne-text">事件处理函数</span></li><li id="ubdf3f9b1" data-lake-index-type="0"><span class="ne-text">服务器组件</span></li><li id="uae94c9a5" data-lake-index-type="0"><span class="ne-text">Error Boundary自身</span></li></ol><p id="u01d1627d" class="ne-p"><span class="ne-text">具体的完整封装 TODO: </span></p><h3 id="RG1RA"><span class="ne-text">ReactDOM</span></h3><h4 id="xAPZX"><span class="ne-text">createPortal</span></h4><ol class="ne-ol"><li id="u729bc8ae" data-lake-index-type="0"><span class="ne-text">可以指定节点挂载到指定目标DOM节点</span></li></ol><pre><code><code>// templateconst A = () =&gt; ReactDOM.createPortal(&lt;div&gt;info&lt;/div&gt;, document.body)</code></code></pre><ol start="2" class="ne-ol"><li id="u21e16b5d" data-lake-index-type="0"><span class="ne-text">对于一些全局组件（message），DOM的挂在可能不在root根节点内，自定义挂在指定DOM节点，除了上述createPortal方式，还有react的createRoot方式</span></li></ol></div>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
          <category> React </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>TypeScript系统学习</title>
      <link href="/blog/torv9p4z2b79494z/"/>
      <url>/blog/torv9p4z2b79494z/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h4 id="DMAyy"><span class="ne-text">基础使用</span></h4><ol class="ne-ol"><li id="u662263d7" data-lake-index-type="0"><span class="ne-text">既是变量声明空间，也是类型声明空间</span></li><li id="u0d4282f1" data-lake-index-type="0"><span class="ne-text">类型分类：</span></li></ol><ol class="ne-list-wrap"><ol ne-level="1" class="ne-ol"><li id="u42e9bb1d" data-lake-index-type="0"><span class="ne-text">基本类型：也就是JavaScript中的七种基本类型</span></li><li id="u717293e5" data-lake-index-type="0"><span class="ne-text">对象类型：对象、数组、函数</span></li><li id="u7cfbb6db" data-lake-index-type="0"><span class="ne-text">typescript新增类型：any, never, void, unknown, enum</span></li></ol></ol><ol start="3" class="ne-ol"><li id="u8b1c9efb" data-lake-index-type="0"><span class="ne-text">联合类型和交叉类型：类型间的或跟与</span></li><li id="u61315403" data-lake-index-type="0"><span class="ne-text">断言（as）非空断言（!.）</span></li><li id="u13adc4e0" data-lake-index-type="0"><span class="ne-text">数组类型定义：type[]，Array&lt;string&gt;</span></li><li id="ua418feb9" data-lake-index-type="0"><span class="ne-text">元组类型定义：形式上类似JavaScript中的解构赋值</span></li></ol><span style="margin-left: 2em"><pre><code><code>let arr: [number, string] = [1, 'str'];arr[2] = 'test'; // ts error</code></code></pre></span><ol start="7" class="ne-ol"><li id="ub2d7406e" data-lake-index-type="0"><span class="ne-text">索引签名：</span></li></ol><ol class="ne-list-wrap"><ol ne-level="1" class="ne-ol"><li id="uabde14d8" data-lake-index-type="0"><span class="ne-text">比如后端返回的数据，字段不可能枚举完全</span></li></ol></ol><span style="margin-left: 2em"><pre><code><code>type ObjType = &#123;  a: string  b: number  [index: string]: any&#125;const obj: ObjType = &#123;  a: '11',  b: 22,  c: false,&#125;</code></code></pre></span><ol class="ne-list-wrap"><ol start="2" ne-level="1" class="ne-ol"><li id="u88d48f1f" data-lake-index-type="0"><span class="ne-text">也可以给数组设置类型</span></li></ol></ol><span style="margin-left: 2em"><pre><code><code>type ArrayType = &#123;  [index: number]: any&#125;const arr: ArrayType = ['111', 222, false]</code></code></pre></span><ol start="8" class="ne-ol"><li id="ubdb9547b" data-lake-index-type="0"><span class="ne-text">函数重载和可调用注解</span></li></ol><span style="margin-left: 2em"><pre><code><code>type FunType = &#123;  (n: number): number  key?: string&#125;let fun: FunType = (n) =&gt; nfun.key = 'test'</code></code></pre></span><ol start="9" class="ne-ol"><li id="u854e2d24" data-lake-index-type="0"><span class="ne-text">枚举类型（enum）：自定义枚举变量，优化代码可读性，其本质也是一个包装的JavaScript对象</span></li><li id="u339c427d" data-lake-index-type="0"><span class="ne-text">一般在交叉类型的具体内部逻辑中，需要判断实际变量所属类型，利用利用typeof、instanceof、in或是字面量类型来进行判断</span></li></ol><h4 id="EfHth"><span class="ne-text">接口</span></h4><ul class="ne-ul"><li id="u6f775147" data-lake-index-type="0"><span class="ne-text">接口和类型的差异</span></li></ul><ol class="ne-list-wrap"><ol ne-level="1" class="ne-ol"><li id="ua06d3aa0" data-lake-index-type="0"><span class="ne-text">接口的目标只能用在对象当中</span></li><li id="u5e246c5a" data-lake-index-type="0"><span class="ne-text">接口可以合并</span></li><li id="u3cc008e6" data-lake-index-type="0"><span class="ne-text">接口具备继承能力（和Java抽象类差不多）</span></li><li id="u18ff22ec" data-lake-index-type="0"><span class="ne-text">接口不能映射</span></li></ol></ol><h4 id="WiFCE"><span class="ne-text">字面量类型 keyof typeof</span></h4><ul class="ne-ul"><li id="u65329c6c" data-lake-index-type="0"><span class="ne-text">type的值可以直接存储为一种类型，比如h标签的所有类型值</span></li></ul><pre><code><code>type HTYPE = 'h1' | 'h2' | 'h3' | 'h4' | 'h5' | 'h6' |</code></code></pre><ul class="ne-ul"><li id="u9da9f0e8" data-lake-index-type="0"><span class="ne-text">keyof可以获取一个对象类型的所有关键字</span></li></ul><pre><code><code>interface A &#123;  a: string;  b: number&#125;const v: keyof A = // 'a' | 'b'</code></code></pre><pre><code><code>const obj = &#123;  a: '111',  b: 222,&#125;const v: keyof typeof obj = // 'a' | 'b'</code></code></pre><h4 id="P07Tb"><span class="ne-text">泛型</span></h4><ol class="ne-ol"><li id="u5f9ef2bc" data-lake-index-type="0"><span class="ne-text">函数和接口结合使用</span></li></ol><pre><code><code>interface A&lt;T&gt; &#123;  (n?: T): n  default?: T&#125;<p>const fun1: A&lt;string&gt; = (n) =&gt; n</p><p>fun1(‘111’)<br>fun1.default = ‘222’</code><br></code></pre></p><ol start="2" class="ne-ol"><li id="uc2890d23" data-lake-index-type="0"><span class="ne-text">类（class）中使用</span></li></ol><pre><code><code>class A&lt;T&gt; &#123;  public n!: T&#125;<p>const instance = new A&lt;string&gt;()<br>instance.n = ‘111’</code><br></code></pre></p><ol start="3" class="ne-ol"><li id="u425efa73" data-lake-index-type="0"><span class="ne-text">泛型约束</span></li></ol><p id="ufbcaea02" class="ne-p"><span class="ne-text">很多时候，泛型的“T”是已经知道的集中范围内的，就可以对泛型加以约束（extends）</span></p><pre><code><code>type I = string<p>class A&lt;T extends I&gt; &#123;<br>  public n!: T<br>&#125;</p><p>const instance = new A&lt;string&gt;()<br>instance.n = ‘111’</code><br></code></pre></p><h4 id="pUon2"><span class="ne-text">类</span></h4><ol class="ne-ol"><li id="u3d088ef4" data-lake-index-type="0"><span class="ne-text">接口（implements）</span></li></ol><pre><code><code>interface A &#123;  a: string  b: number  fun: (c: string, d: number) =&gt; void&#125;<p>class B implements A &#123;<br>  a!: string<br>  b!: number<br>  fun: (c: string, d: number) =&gt; &#123;&#125;<br>&#125;</code><br></code></pre></p><ol start="2" class="ne-ol"><li id="u328e816a" data-lake-index-type="0"><span class="ne-text">结合泛型</span></li></ol><pre><code><code>class A&lt;T&gt; &#123;  a: T  constructor(a: T) &#123;    this.a = a  &#125;&#125;<p>new A&lt;string&gt;(‘aaa’)</code><br></code></pre></p><pre><code><code>interface A&lt;T&gt; &#123;  a: T  b: number  fun: (c: T, d: number) =&gt; void&#125;class B implements A&lt;string&gt; &#123;  a!: string  b!: number  fun: (c: string, d: number) =&gt; &#123;&#125;&#125;</code></code></pre><h4 id="Gymk9"><span class="ne-text">映射</span></h4><p id="u80a1a45b" class="ne-p"><span class="ne-text">类似于对一个已有类型的“二次开发”</span></p><ol class="ne-ol"><li id="u08291f1b" data-lake-index-type="0"><span class="ne-text">一个例子：对一个已有类型对象的值都设置为只读的</span></li></ol><pre><code><code>type A = &#123;  a: string  b: string&#125;<p>type B&lt;T&gt; = &#123;<br>  readonly [P in keyof T]: T[P]<br>&#125;</p><p>type C = B&lt;A&gt;</code><br></code></pre></p><ol start="2" class="ne-ol"><li id="ub4542434" data-lake-index-type="0"><span class="ne-text">一个例子：对于DOM自带的DOMRect类型进行二次自定义</span></li></ol><pre><code><code>/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/DOMRectReadOnly) */interface DOMRectReadOnly &#123;  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/DOMRectReadOnly/bottom) */  readonly bottom: number;  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/DOMRectReadOnly/height) */  readonly height: number;  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/DOMRectReadOnly/left) */  readonly left: number;  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/DOMRectReadOnly/right) */  readonly right: number;  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/DOMRectReadOnly/top) */  readonly top: number;  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/DOMRectReadOnly/width) */  readonly width: number;  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/DOMRectReadOnly/x) */  readonly x: number;  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/DOMRectReadOnly/y) */  readonly y: number;  toJSON(): any;&#125;/** [MDN Reference](https://developer.mozilla.org/docs/Web/API/DOMRect) */interface DOMRect extends DOMRectReadOnly &#123;  height: number;  width: number;  x: number;  y: number;&#125;</code></code></pre><pre><code><code>// - remove assign value (-readonlu or -?)...type EditableDOMRect = &#123;  -readonly [K in keyof DOMRect]: DOMRect[K];&#125;;// EditableDOMRect === ↓type EditableDOMRect = &#123;  height: number;  width: number;  x: number;  y: number;  bottom: number;  left: number;  right: number;  top: number;  toJSON: () =&gt; any;&#125;</code></code></pre><h4 id="EXNeJ"><span class="ne-text">条件类型 infer</span></h4><pre><code><code>type C = A extends B ? &#123;&#125; : []type Exclude&lt;T, U&gt; = T extends U ? never : T</code></code></pre><h4 id="OW0TC"><span class="ne-text">内置工具类型</span></h4><p id="uc0bd97b2" class="ne-p"><span class="ne-text">typescript内置部分类型（具体可以利用编辑器转到定义处查看）</span></p><p id="ue6815fcd" class="ne-p"><span class="ne-text">比如完成上述映射第一个例子可以写成</span></p><pre><code><code>type D = Readonly&lt;A&gt;</code></code></pre><p id="u1558878f" class="ne-p"><span class="ne-text">常用的如下：</span></p><table id="JMQIq" class="ne-table" style="width: 636px"><tbody><tr style="height: 33px"><td width="318"><p id="u0db44a55" class="ne-p"><span class="ne-text">Partial</span></p></td><td width="318"><ul class="ne-ul"><li id="u0de61c6b" data-lake-index-type="0"><span class="ne-text">可选</span></li></ul><pre><code><code>type B = Partial&lt;A&gt;</code></code></pre></td></tr><tr style="height: 33px"><td width="318"><p id="u9624db74" class="ne-p"><span class="ne-text">Readonly</span></p></td><td width="318"><ul class="ne-ul"><li id="u292ea66d" data-lake-index-type="0"><span class="ne-text">只读</span></li></ul><pre><code><code>type B = Readonly&lt;A&gt;</code></code></pre></td></tr><tr style="height: 33px"><td width="318"><p id="u31f84b39" class="ne-p"><span class="ne-text">Pick</span></p></td><td width="318"><ul class="ne-ul"><li id="uacea44be" data-lake-index-type="0"><span class="ne-text">筛选指定项</span></li></ul><pre><code><code>type B = Pick&lt;A, 'a' | 'b'&gt;</code></code></pre></td></tr><tr style="height: 33px"><td width="318"><p id="u3ee0494b" class="ne-p"><span class="ne-text">Record</span></p></td><td width="318"><ul class="ne-ul"><li id="u9efccf89" data-lake-index-type="0"><span class="ne-text">指定字段为指定类型</span></li></ul><pre><code><code>type A = Record&lt;'a' | 'b', string&gt;type A = Record&lt;keyof C, string&gt;</code></code></pre></td></tr><tr style="height: 33px"><td width="318"><p id="u67a37fee" class="ne-p"><span class="ne-text">Required</span></p></td><td width="318"><ul class="ne-ul"><li id="uaf8032bb" data-lake-index-type="0"><span class="ne-text">将可选字段转为必选字段</span></li></ul><pre><code><code>type B = Required&lt;A&gt;</code></code></pre></td></tr><tr style="height: 33px"><td width="318"><p id="u1a1da710" class="ne-p"><span class="ne-text">Omit</span></p></td><td width="318"><ul class="ne-ul"><li id="u78dd2ad3" data-lake-index-type="0"><span class="ne-text">移除指定项</span></li></ul><pre><code><code>type B = Omit&lt;A, 'a' | 'b'&gt;</code></code></pre></td></tr><tr style="height: 33px"><td width="318"><p id="ue047fc96" class="ne-p"><span class="ne-text">Exclude</span></p></td><td width="318"><ul class="ne-ul"><li id="u814a1afa" data-lake-index-type="0"><span class="ne-text">排除</span></li></ul><pre><code><code>type B = Exclude&lt;string | number, string&gt;</code></code></pre></td></tr><tr style="height: 33px"><td width="318"><p id="u555524d6" class="ne-p"><span class="ne-text">Extract</span></p></td><td width="318"><ul class="ne-ul"><li id="u3566469d" data-lake-index-type="0"><span class="ne-text">择取</span></li></ul><pre><code><code>type B = Extract&lt;string | number, string&gt;</code></code></pre></td></tr><tr style="height: 33px"><td width="318"><p id="u7ee55ba0" class="ne-p"><span class="ne-text">NonNullable</span></p></td><td width="318"><ul class="ne-ul"><li id="u8247e26e" data-lake-index-type="0"><span class="ne-text">去除“空”类型</span></li></ul><pre><code><code>type B = NonNullable&lt;string | null | undefined&gt;// B -&gt; string</code></code></pre></td></tr><tr style="height: 33px"><td width="318"><p id="u7f47e0cf" class="ne-p"><span class="ne-text">Parameters</span></p></td><td width="318"><ul class="ne-ul"><li id="ud5251af7" data-lake-index-type="0"><span class="ne-text">得到函数参数元组</span></li></ul><pre><code><code>type FUN = (n: string, m: number) =&gt; voidtype A = Parameters&lt;FUN&gt;<p>const test: A = [‘111’, 222];</code><br></code></pre></p></td></tr><tr style="height: 33px"><td width="318"><p id="u71bcf350" class="ne-p"><span class="ne-text">ReturnType</span></p></td><td width="318"><ul class="ne-ul"><li id="u7f9d26b9" data-lake-index-type="0"><span class="ne-text">得到函数返回值类型</span></li></ul><pre><code><code>type FUN = (n: string, m: number) =&gt; voidtype A = ReturnType&lt;FUN&gt;<p>const test: A = // void</code><br></code></pre></p></td></tr></tbody></table><ol class="ne-ol"><li id="udf359230" data-lake-index-type="0"><span class="ne-text">infer关键字 extends关键字</span></li></ol><p id="uf8802929" class="ne-p"><span class="ne-text">推断类型</span></p><pre><code><code>type A&lt;T&gt; = T extends Array&lt;infer U&gt; ? U : T<p>type B = A&lt;Array&lt;string&gt;&gt; // string<br>type C = A&lt;number&gt; // number</code><br></code></pre></p></div>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
          <category> JavaScript </category>
          
          <category> TypeScript </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CSS选择器中的:has()和:not()伪类</title>
      <link href="/blog/etxgze472uzh7t1i/"/>
      <url>/blog/etxgze472uzh7t1i/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="ub2dd044b" class="ne-p"><span class="ne-text">前言: 本文记录一下CSS3中逻辑选择器中的has和not, has相当于根据子代条件来选择父代, not类似过滤条件. </span><strong><span class="ne-text">使用前先检查代码运行的浏览器环境是否符合如下截图条件</span></strong></p><p id="u4debc8a1" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2023/png/1484158/1693729315664-7752ef04-8503-42b0-b271-a4adffed81ec.png" width="540.328125" id="u310bdcce" class="ne-image"></p><h3 id="C7n01"><span class="ne-text">not</span></h3><p id="u9b72f6e5" class="ne-p"><span class="ne-text">对当前节点的过滤筛选</span></p><pre><code><code>&lt;html&gt;  &lt;head&gt;    &lt;title&gt;css&lt;/title&gt;    &lt;style&gt;      div.parent:not(.not-parent) &#123;        border: 1px red solid;      &#125;    &lt;/style&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;div class=&quot;parent not-parent&quot;&gt;0000&lt;/div&gt;    &lt;div class=&quot;parent&quot;&gt;      &lt;div&gt;1111&lt;/div&gt;      &lt;div&gt;        &lt;div class=&quot;active&quot;&gt;2222&lt;/div&gt;      &lt;/div&gt;    &lt;/div&gt;    &lt;div class=&quot;parent&quot;&gt;      &lt;div&gt;3333&lt;/div&gt;      &lt;div&gt;4444&lt;/div&gt;    &lt;/div&gt;    &lt;p&gt;&lt;/p&gt;  &lt;/body&gt;&lt;/html&gt;</code></code></pre><p id="ubf0f5013" class="ne-p" style="text-align: left"><img src="https://cdn.nlark.com/yuque/0/2023/png/1484158/1693728187545-dc666922-bd28-4c9d-b63e-824c8b0476f0.png" width="257.03705519478797" id="u46b8367d" class="ne-image"></p><h3 id="bNc8z"><span class="ne-text">has</span></h3><p id="u11a3e0cd" class="ne-p"><span class="ne-text">has选择器: </span><strong><span class="ne-text">根据子是否符合条件来选择父级</span></strong></p><p id="uaf7bd836" class="ne-p"><span class="ne-text">设置子代中有active类的parent类名div的样式</span></p><pre><code><code>&lt;html&gt;  &lt;head&gt;    &lt;title&gt;css&lt;/title&gt;    &lt;style&gt;      div.parent:has(.active) &#123;        border: 1px red solid;      &#125;    &lt;/style&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;div class=&quot;parent&quot;&gt;      &lt;div&gt;1111&lt;/div&gt;      &lt;div&gt;        &lt;div class=&quot;active&quot;&gt;2222&lt;/div&gt;      &lt;/div&gt;    &lt;/div&gt;    &lt;div class=&quot;parent&quot;&gt;      &lt;div&gt;3333&lt;/div&gt;      &lt;div&gt;4444&lt;/div&gt;    &lt;/div&gt;    &lt;p&gt;&lt;/p&gt;  &lt;/body&gt;&lt;/html&gt;</code></code></pre><p id="u1eafcd36" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2023/png/1484158/1693726768953-ae1aa08f-87bd-45d1-ad03-bf4a73538bdc.png" width="257.03705519478797" id="u1ceb6584" class="ne-image"></p><p id="ued6d7945" class="ne-p"><span class="ne-text">如果将上面css改为, 边框则消失</span></p><pre><code><code>div.parent:has(&gt; .active) &#123;  border: 1px red solid;&#125;</code></code></pre><p id="u08a49d4c" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2023/png/1484158/1693727448672-f90d3002-6437-4d65-9b1b-ea889429bd06.png" width="257.03705519478797" id="udd9054cc" class="ne-image"></p><p id="u56d25e80" class="ne-p"><span class="ne-text">还可以表示兄弟跟随关系</span></p><pre><code><code>div.parent:has(+ p) &#123;  border: 1px red solid;&#125;</code></code></pre><p id="u3dc38aeb" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2023/png/1484158/1693727414288-eb1381c5-ce55-44b2-bea6-0e7dad844aba.png" width="257.03705519478797" id="u977486b6" class="ne-image"></p><p id="u3b65a87a" class="ne-p"><span class="ne-text">和not搭配使用, 如下表示不包含active后代的div.parent的标签</span></p><pre><code><code>div.parent:not(:has(.active)) &#123;  border: 1px red solid;&#125;</code></code></pre><p id="u12be46f2" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2023/png/1484158/1693727684199-12da436d-df79-4580-ad37-527bb3a9dc48.png" width="257.03705519478797" id="u860533e4" class="ne-image"></p><p id="u0872252b" class="ne-p"><span class="ne-text">上述not和has位置互换表示的意思不一样</span></p><pre><code><code>div.parent:has(:not(.active)) &#123;  border: 1px red solid;&#125;</code></code></pre><p id="u65f722ad" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2023/png/1484158/1693727825016-f0ae7f89-7fb6-4e74-9d40-32e2727079d5.png" width="257.03705519478797" id="u3f9eacb2" class="ne-image"></p><p id="u0f0fe764" class="ne-p"><span class="ne-text">和表单一些元素搭配使用</span></p><pre><code><code>&lt;html&gt;  &lt;head&gt;    &lt;title&gt;css&lt;/title&gt;    &lt;style&gt;      div:has(input:focus) &#123;        border: 1px red solid;      &#125;    &lt;/style&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;div&gt;      &lt;input type=&quot;text&quot; value=&quot;111&quot; /&gt;    &lt;/div&gt;    &lt;div&gt;      &lt;input type=&quot;text&quot; value=&quot;222&quot; /&gt;    &lt;/div&gt;  &lt;/body&gt;&lt;/html&gt;</code></code></pre><p id="uda31529e" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2023/png/1484158/1693728587821-b90111c9-a13f-4ecc-907e-d1c5d26f3a3d.png" width="257.03705519478797" id="u17090981" class="ne-image"></p><hr id="nIJig" class="ne-hr"><p id="u5dcb7170" class="ne-p" style="text-align: center"><span class="ne-text">一些常规使用CSS选择器可以参考另一篇文章:  </span><a href="https://www.wztlink1013.com/blog/01_html5css3_day01/" data-href="https://www.wztlink1013.com/blog/01_html5css3_day01/" class="ne-link"><span class="ne-text">CSS/CSS3选择器总结 | 尼采般地抒情</span></a></p></div>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
          <category> HTML+CSS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>YApi内网部署</title>
      <link href="/blog/eil6hmfg5ip4tdh7/"/>
      <url>/blog/eil6hmfg5ip4tdh7/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="u0f0c809d" class="ne-p" style="text-align: justify"><span class="ne-text">前言：使用yapi系统来管理个人项目接口，目标是在个人电脑上而非服务器上搭建一个yapi系统，开机自启动或者手动启动。一开始是使用官网推荐的yapi-cli来搭建，但是坑比较多，node限制在12x，这个显然影响本机环境。然后采用直接运行YApi的源码，利用pm2来运行node服务，最后可以达到预期效果，但是pm2设置了开机自启动影响电脑性能。最后采用docker容器部署，需要的时候手动启动即可，而且部署起来感觉更加简洁，故本文将docker作为推荐部署方式。</span></p><h2 id="dNVSw"><span class="ne-text">一、pm2部署</span></h2><p id="uc4b387b0" class="ne-p"><span class="ne-text">使用pm2来运行YApi node程序。</span></p><h3 id="G0lZ0"><span class="ne-text">下载Yapi源码以及配置Yapi</span></h3><ul class="ne-ul"><li id="u990e7ac7" data-lake-index-type="0"><span class="ne-text">先将node版本切换到</span><code class="ne-code"><span class="ne-text">12.18.2</span></code><span class="ne-text">，因为过高版本的node不能使用（个人试过高于14.17.就不能使用）。</span></li></ul><p id="u3b02a4a6" class="ne-p" style="text-align: center"><strong><span class="ne-text">关于如何切换node版本，参考之前文章nvm的使用</span></strong></p><p id="ucd24bba0" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1646102278163-10a8b55f-5fe8-46c3-8e0d-39bdd8f69d00.png" width="649.166640871102" id="u320f9d7e" class="ne-image"></p><ul class="ne-ul"><li id="ufc97e1d2" data-lake-index-type="0"><span class="ne-text">然后下载cnpm </span><code class="ne-code"><span class="ne-text">npm install -g cnpm --registry=</span><a href="https://registry.npm.taobao.org" data-href="https://registry.npm.taobao.org" target="_blank" class="ne-link"><span class="ne-text">https://registry.npm.taobao.org</span></a></code></li><li id="ucd48f741" data-lake-index-type="0"><span class="ne-text">然后下载yapi：</span></li></ul><pre><code>cnpm install -g yapi-cli</code></pre><ul class="ne-ul"><li id="u9de97657" data-lake-index-type="0"><span class="ne-text">在文件夹中执行如下命令：</span></li></ul><pre><code>yapi server</code></pre><ul class="ne-ul"><li id="ue4cb8925" data-lake-index-type="0"><span class="ne-text" style="color: rgb(33, 37, 41); font-size: 16px">访问localhost:9090，将页面配置填上即可：</span></li></ul><p id="ub4ad9a50" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1646033850542-bdbeef58-d2ac-44d5-ad34-28c5752cd54f.png" width="1572.4999375144666" id="cBXHi" class="ne-image"></p><p id="u47e2bff1" class="ne-p"><span class="ne-text">安装成功会有如下信息：</span></p><pre><code>初始化管理员账号成功,账号名：&quot;admin@admin.com&quot;，密码：&quot;ymfe.org&quot;部署成功，请切换到部署目录，输入： &quot;node vendors/server/app.js&quot; 指令启动服务器, 然后在浏览器打开 http://127.0.0.1:3000 访问</code></pre><ul class="ne-ul"><li id="u9f3d461e" data-lake-index-type="0"><span class="ne-text">然后访问：</span><a href="http://127.0.0.1:3000" data-href="http://127.0.0.1:3000" target="_blank" class="ne-link"><span class="ne-text">http://127.0.0.1:3000</span></a></li></ul><h3 id="H6qIN"><span class="ne-text">创建本地MongoDB数据库</span></h3><pre><code>db.createUser(&#123;user: 'root',pwd: 'root',roles:[&#123;role: 'root',db: 'admin'&#125;]&#125;)</code></pre><pre><code>&gt; use adminswitched to db admin&gt; db.createUser(&#123;user: 'root',pwd: 'root',roles:[&#123;role: 'root',db: 'admin'&#125;]&#125;)Successfully added user: &#123;        &quot;user&quot; : &quot;root&quot;,        &quot;roles&quot; : [                &#123;                        &quot;role&quot; : &quot;root&quot;,                        &quot;db&quot; : &quot;admin&quot;                &#125;        ]&#125;&gt; show users&#123;        &quot;_id&quot; : &quot;admin.root&quot;,        &quot;userId&quot; : UUID(&quot;f47c99bb-2df6-410c-bde1-2f424d0258d3&quot;),        &quot;user&quot; : &quot;root&quot;,        &quot;db&quot; : &quot;admin&quot;,        &quot;roles&quot; : [                &#123;                        &quot;role&quot; : &quot;root&quot;,                        &quot;db&quot; : &quot;admin&quot;                &#125;        ],        &quot;mechanisms&quot; : [                &quot;SCRAM-SHA-1&quot;,                &quot;SCRAM-SHA-256&quot;        ]&#125;</code></pre><p id="ucb07af7e" class="ne-p"><span class="ne-text">找到 MongoDB 安装目录，打开 mongod.cfg文件修改</span></p><p id="u4c975e0d" class="ne-p"><span class="ne-text">重启mongodb</span></p><pre><code>C:\Users\wztli&gt;mongoMongoDB shell version v5.0.5connecting to: mongodb://127.0.0.1:27017/?compressors=disabled&amp;gssapiServiceName=mongodbImplicit session: session &#123; &quot;id&quot; : UUID(&quot;6ff518c1-21c7-4d6f-98ce-23b12c925321&quot;) &#125;MongoDB server version: 5.0.5================Warning: the &quot;mongo&quot; shell has been superseded by &quot;mongosh&quot;,which delivers improved usability and compatibility.The &quot;mongo&quot; shell has been deprecated and will be removed inan upcoming release.For installation instructions, seehttps://docs.mongodb.com/mongodb-shell/install/================&gt; use adminswitched to db admin&gt; db.auth('root','root')1</code></pre><p id="u01a88216" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1646098577475-dfd39936-36f1-4cf4-b61d-682957334517.png" width="254.83071899414062" id="ue6b55d01" class="ne-image"></p><h3 id="wxjuG"><span class="ne-text">YApi node程序运行成功</span></h3><p id="u1904299f" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1646099210899-717632b0-b65f-4e28-9199-9061a306254c.png" width="839.1666333211806" id="XphSR" class="ne-image"></p><h3 id="isIb9"><span class="ne-text">pm2后台管理Yapi进程</span></h3><p id="u2ef2c275" class="ne-p"><span class="ne-text">pm2就相当于之前服务器使用的screen，新开一个进程，就算关掉cmd也能进行操作</span></p><p id="uf2083388" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1646102724248-270ad78b-b70d-4682-8732-c902c277bda2.png" width="784.9999688069038" id="u0bebbfc6" class="ne-image"></p><p id="u6fc0c6a7" class="ne-p"><span class="ne-text">这样就是在本地电脑上，可以把项目关掉，但是该项目还处于运行当中，当然了，重启电脑还是要重新执行上面的pm2命令的，也可以进行pm2开机自启动一些项目，具体参考上面的教程链接。</span></p><h3 id="ZAjnn"><span class="ne-text">pm2设置开机自启动服务</span></h3><p id="u9840df8c" class="ne-p"><span class="ne-text">目的是电脑一开机就会自动重启该服务：</span></p><pre><code>cnpm i -g pm2-windows-service</code></pre><p id="ua5f80609" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1646118390666-51bc2220-c6ce-473e-a6c8-e1c88a338ac8.png" width="714.9999715884538" id="ua5b9348d" class="ne-image"></p><h3 id="jycMa"><span class="ne-text">相关报错</span></h3><h4 id="Zz2GM"><span class="ne-text">Error:  (node:2304) Warning: Accessing non-existent property……</span></h4><pre><code>Error:  (node:2304) Warning: Accessing non-existent property 'count' of module exports inside circular dependency(Use `node --trace-warnings ...` to show where the warning was created)</code></pre><ul class="ne-ul"><li id="u927ff03a" data-lake-index-type="0"><span class="ne-text">原因node版本过高：</span><a href="https://github.com/YMFE/yapi/issues/1736" data-href="https://github.com/YMFE/yapi/issues/1736" target="_blank" class="ne-link"><span class="ne-text">https://github.com/YMFE/yapi/issues/1736</span></a></li></ul><h4 id="Af03x"><span class="ne-text">events.js:292 throw er; // Unhandled 'error' event</span></h4><p id="ua131e8fa" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1646034833437-db75cee7-0157-41eb-ac4c-cfd27f3db1e1.png" width="272.33331298828125" id="AJW0o" class="ne-image"></p><p id="u4961a57d" class="ne-p"><span class="ne-text">下载gyp试试，需要电脑上的环境参考：</span><a href="https://github.com/nodejs/node-gyp#on-windows" data-href="https://github.com/nodejs/node-gyp#on-windows" target="_blank" class="ne-link"><span class="ne-text">https://github.com/nodejs/node-gyp#on-windows</span></a></p><pre><code>cnpm install -g node-gyp</code></pre><h4 id="oNDgw"><span class="ne-text">Error: Can‘t find Python executable “python“, you can set the PYTHON env variable</span></h4><p id="u595d1a18" class="ne-p"><span class="ne-text">成功安装之后，cnpm i 会有一个报错：</span></p><p id="u365ce299" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1646035557382-7fcc59de-05ca-45f5-90ef-a2e24f70f6d1.png" width="209.5" id="aHtry" class="ne-image"></p><p id="ua245b67d" class="ne-p"><span class="ne-text"></span></p><p id="uf44429f7" class="ne-p"><span class="ne-text">解决参考：</span></p><ul class="ne-ul"><li id="u8dee6132" data-lake-index-type="0"><span class="ne-text"></span><a href="https://blog.51cto.com/u_15301254/3924342" data-href="https://blog.51cto.com/u_15301254/3924342" target="_blank" class="ne-link"><span class="ne-text">【Bug解决】Error: Can‘t find Python executable “python“, you can set the PYTHON env variable</span></a></li></ul><p id="u7fff91cd" class="ne-p"><span class="ne-text">下载：</span></p><pre><code>npm install --global --production windows-build-tools</code></pre><h4 id="zhObf"><span class="ne-text">MongoNetworkError: Authentication failed., mongodb Authentication failed</span></h4><ul class="ne-ul"><li id="uc8539557" data-lake-index-type="0"><a href="https://github.com/fjc0k/docker-YApi/issues/32" data-href="https://github.com/fjc0k/docker-YApi/issues/32" target="_blank" class="ne-link"><span class="ne-text">https://github.com/fjc0k/docker-YApi/issues/32</span></a></li></ul><p id="ucfef198f" class="ne-p"><span class="ne-text">添加admin值即可</span></p><h2 id="YlpJX"><span class="ne-text">二、docker部署</span></h2><p id="u87363657" class="ne-p"><span class="ne-text">docker部署主要参考：</span><a href="https://github.com/fjc0k/docker-YApi#readme" data-href="https://github.com/fjc0k/docker-YApi#readme" target="_blank" class="ne-link"><span class="ne-text">https://github.com/fjc0k/docker-YApi#readme</span></a><span class="ne-text">，不过有几个需要注意的点：</span></p><ul class="ne-ul"><li id="ua7fd6bda" data-lake-index-type="0"><span class="ne-text">redeme提到的Docker 和 Docker Compose版本不能太久</span></li><li id="ucf81c10c" data-lake-index-type="0"><span class="ne-text">MongoDB如果是</span><a href="https://www.mongodb.com/" data-href="https://www.mongodb.com/" target="_blank" class="ne-link"><span class="ne-text">在线数据库</span></a><span class="ne-text">，配置方式采用集群配置字段更加便捷：</span></li></ul><pre><code>version: '3'<p>services:<br>  yapi-web:<br>    image: jayfong/yapi:latest<br>    container_name: yapi-web<br>    ports:<br>      - 40001:3000<br>    environment:<br>      - YAPI_ADMIN_ACCOUNT=xxxxxx<br>      - YAPI_ADMIN_PASSWORD=xxxxxx<br>      - YAPI_CLOSE_REGISTER=true<br>      - YAPI_DB_CONNECT_STRING=mongodb+srv://name:password@url/databasename?retryWrites=true&amp;w=majority<br>      - YAPI_MAIL_ENABLE=false<br>      - YAPI_LDAP_LOGIN_ENABLE=false<br>      - YAPI_PLUGINS=[]<br>    depends_on:<br>        ···<br></code></pre></p><h2 id="LBMyr"><span class="ne-text">三、相关链接</span></h2><p id="u7de33e87" class="ne-p"><span class="ne-text">YApi参考：</span></p><ul class="ne-ul"><li id="u0ce203b2" data-lake-index-type="0"><span class="ne-text">yapi文档以及安装文档：</span><a href="https://hellosean1025.github.io/yapi/" data-href="https://hellosean1025.github.io/yapi/" target="_blank" class="ne-link"><span class="ne-text">https://hellosean1025.github.io/yapi/</span></a></li><li id="u088fb7d1" data-lake-index-type="0"><span class="ne-text">YApi 安装可能会出现的问题：</span><a href="https://github.com/YMFE/yapi/issues/16" data-href="https://github.com/YMFE/yapi/issues/16" target="_blank" class="ne-link"><span class="ne-text">https://github.com/YMFE/yapi/issues/16</span></a></li><li id="u84bae2c3" data-lake-index-type="0"><span class="ne-text">docker参考：</span><a href="https://github.com/fjc0k/docker-YApi" data-href="https://github.com/fjc0k/docker-YApi" target="_blank" class="ne-link"><span class="ne-text">https://github.com/fjc0k/docker-YApi</span></a></li><li id="u89ae9669" data-lake-index-type="0"><a href="https://segmentfault.com/a/1190000020534539" data-href="https://segmentfault.com/a/1190000020534539" target="_blank" class="ne-link"><span class="ne-text">Yapi 本地部署</span></a></li></ul><p id="ua003c847" class="ne-p"><span class="ne-text">本地MongoDB创建参考：</span></p><ul class="ne-ul"><li id="u00ab0a5f" data-lake-index-type="0"><a href="https://blog.csdn.net/qq_42583263/article/details/121403125" data-href="https://blog.csdn.net/qq_42583263/article/details/121403125" class="ne-link"><span class="ne-text">MongoDB 设置用户名密码和数据库连接_mongodb 连接数据库带用户名和密码_大胖东的博客-CSDN博客</span></a></li></ul><p id="u630c7d71" class="ne-p"><span class="ne-text">pm2相关参考：</span></p><ul class="ne-ul"><li id="u01e9bc43" data-lake-index-type="0"><a href="https://www.cnblogs.com/chyingp/p/pm2-documentation.html" data-href="https://www.cnblogs.com/chyingp/p/pm2-documentation.html" target="_blank" class="ne-link"><span class="ne-text">PM2实用入门指南 </span></a></li><li id="u2b10dbc2" data-lake-index-type="0"><a href="https://www.jianshu.com/p/5f808762a71a" data-href="https://www.jianshu.com/p/5f808762a71a" class="ne-link"><span class="ne-text">pm2 使用教程</span></a></li></ul><ul class="ne-ul"><li id="ubf1b94b0" data-lake-index-type="0"><a href="https://www.jianshu.com/p/6cb523c0ced8" data-href="https://www.jianshu.com/p/6cb523c0ced8" target="_blank" class="ne-link"><span class="ne-text">Window 设置pm2开机自启动服务</span></a></li><li id="u1e2423fd" data-lake-index-type="0"><a href="https://www.cnblogs.com/wuqilang/p/12794972.html" data-href="https://www.cnblogs.com/wuqilang/p/12794972.html" target="_blank" class="ne-link"><span class="ne-text">Window 设置pm2开机自启动服务</span></a></li></ul></div>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
          <category> DevOps </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>『我的团长我的团』</title>
      <link href="/essay/wugt39mh6cgg3676/"/>
      <url>/essay/wugt39mh6cgg3676/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="uc38dc866" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2023/webp/1484158/1680703167469-355c8435-dec9-4430-819c-476f8994958d.webp" width="270" id="u416ba344" class="ne-image"></p><p id="u33f28100" class="ne-p"><span class="ne-text">前言：士兵突击的原班人马拍摄的一部电视剧，兰晓龙笔下的炮灰团和草原上的五班，将底层描绘的淋漓尽致，又将绝望中的希望演绎在文字或者影视中。</span></p><h3 id="fpTSn"><span class="ne-text">摘录</span></h3><p id="u7bafe72e" class="ne-p"><span class="ne-text">岂曰无衣，与子同袍。</span></p><p id="u2cb70538" class="ne-p"><span class="ne-text"></span></p><p id="u4c7c6da5" class="ne-p"><span class="ne-text">中国鬼死于听天由命和漫不经心。</span></p><p id="u175607de" class="ne-p"><span class="ne-text"></span></p><p id="u1f90b392" class="ne-p"><span class="ne-text">死都不怕，就怕安逸。</span></p><p id="u24fe66b2" class="ne-p"><span class="ne-text"></span></p><p id="u3425eb31" class="ne-p"><span class="ne-text">国难当头，忠字已经很掺水了，在孝字上就不能再打马虎眼了。</span></p><p id="u5dd9b714" class="ne-p"><span class="ne-text"></span></p><p id="u99525e99" class="ne-p"><span class="ne-text">人生在世，怎么可能像裁缝铺里做衣服，处处都按照你的身材。</span></p><p id="ubdbfaa19" class="ne-p"><span class="ne-text"></span></p><p id="u348f2c18" class="ne-p"><span class="ne-text">有个信着的东西，你是不知道活得有多舒服。</span></p><p id="ube9126c9" class="ne-p"><span class="ne-text"></span></p><p id="u65cb6657" class="ne-p"><span class="ne-text">覆巢之下，岂有完卵。</span></p><p id="u963aca0c" class="ne-p"><span class="ne-text"></span></p><p id="uceb12a81" class="ne-p"><span class="ne-text">你骗我们有了不该有的希望。</span></p><p id="ub3a2a576" class="ne-p"><span class="ne-text"></span></p><p id="ud1bd03f9" class="ne-p"><span class="ne-text">我是伤心而死的。</span></p><p id="uee3f72ec" class="ne-p"><span class="ne-text"></span></p><p id="u5d0787a7" class="ne-p"><span class="ne-text"></span></p></div>]]></content>
      
      
      <categories>
          
          <category> 影视 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2022年 | 平淡却又魔幻</title>
      <link href="/essay/lwozgzgirrhne6ro/"/>
      <url>/essay/lwozgzgirrhne6ro/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="u7c001e7f" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/1484158/1672578936177-3e40667b-6cc1-4140-865e-cf55bdcb2658.jpeg" width="3840" id="GE6Xs" class="ne-image"></p><p id="uf699b7c3" class="ne-p"><br></p><p id="ud04fa625" class="ne-p"><span class="ne-text">前言：2022年，平淡的生活中夹杂着一丝魔幻的经历。</span></p><h3 id="sq448"><span class="ne-text">最后的学生时代</span></h3><p id="u9f5f0f39" class="ne-p"><span class="ne-text">仿佛读了好久好久的书，久到我记忆中难忘的事都是夹杂在学业之中。</span></p><p id="ucc30dd02" class="ne-p"><span class="ne-text">去年的这个时候我结束了在外公司的实习之旅，转向学校，一切都像是被安排好的流程，校内实习、毕设、答辩、拍毕业照、毕业…相比起我的中学阶段，我的大学要平淡的多，可能是这易于伤感的年纪不再憧憬与彷徨。</span></p><h3 id="P02dA"><span class="ne-text">可那是兴趣爱好</span></h3><p id="u6f2cb3bc" class="ne-p"><span class="ne-text">我应该是一手好牌却打得不怎么样的一个学生。大三下我几乎就把学分修满，理论上我是有最多的时间去准备就业的那一批人，但是我错过秋招和春招，封校没有紧迫感是一方面，但是更多的是我的毕设，那是我的兴趣，我只想写好我所设计的代码，那种热爱的冲动不再让我去超过所有人竞争些什么，即便那是个好机会。</span></p><p id="ud41458a1" class="ne-p"><span class="ne-text">五月往后，连春招都过了，我才开始找工作，不过凭借技术老本也拿到一些offer，选择当中有更好的，但最后我还是选了一个和我毕设几乎一样的岗位。我想以后我可能会变得功利起来，但现在不是未来。比较讽刺的是，这一年人情景事都在变，唯独兴趣爱好一直在，从爱好到毕设再到工作，载体不同，但做的都一样。</span></p><h3 id="ZHY8Q"><span class="ne-text">厦门</span></h3><p id="ucead1e49" class="ne-p"><span class="ne-text">原本意向工作地点是深圳，因为一些原因，来到厦门工作了。在一个陌生的海滨城市也是一个不错的经历体验，上一次的海滨之行是在珠海。</span></p><h3 id="Yd3cg"><span class="ne-text">疫情下的颠沛流离</span></h3><p id="ua27c9de0" class="ne-p"><span class="ne-text">上半年学校解封之际伴随着成片的花海，我原以为那会是疫情这个故事的终章，年底，国家重新定义了新冠的所属类别为“乙类甲管”，政策变之后，朋友圈每天都会更新一批又一批的阳康转阴等字眼。</span></p><h3 id="qrizm"><span class="ne-text">规则的成长</span></h3><p id="u7c422ca4" class="ne-p"><span class="ne-text">工作之后，看小说和追番没有在学校时候的那种氛围了，我觉得这可能就是成长带来的副作用吧，人们都以铺天盖地般地形式想要达成某种结果来取得某种成绩。技术上，不论是深度还是广度，都只是浅尝辄止，自己要做的、要总结的、要实践的还有很多很多，自己也要被迫地以最佳的状态在技术层面上提升一个层次。</span></p><p id="u470c3a4c" class="ne-p"><span class="ne-text">一千个人眼中有一千个哈姆雷特，而在我眼里，成长是虚无的，因为每个人总是以一种无形的规则成长，就像是竹林中的嫩竹子从一出生的小笋就笔直地向阳生长，不偏离之后的任何轨迹。</span></p><h3 id="az3a1"><span class="ne-text">2023</span></h3><p id="u40186f6b" class="ne-p"><span class="ne-text">对自己的2023年没有太多任务式的念想，唯独多读点书这一点多督促自己，在此对自己算是立下个flag吧，多读书多思考多记录。</span></p></div>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>《你的夏天还好吗》小记</title>
      <link href="/essay/wmsytg138tcz629a/"/>
      <url>/essay/wmsytg138tcz629a/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="ua9751299" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/1484158/1670483122786-7c51c1ab-5445-4adc-905b-4c5d407d25e0.jpeg" width="330" id="Igzgd" class="ne-image"></p><h2 id="O4mrv"><span class="ne-text">你的夏天还好吗？</span></h2><p id="u980df92f" class="ne-p"><span class="ne-text">青涩的喜欢和热烈的喜欢，或许在真心付出面前才能得出答案，你义无反顾去喜欢去爱去付出的人，可能在你意识到对方利用你的感情，那一瞬间让你突然想到多年前一个夏天护着你的那个人，普通且纯粹…以前有个问题：“一个你很喜欢的人和一个很喜欢你的人，你会选谁？”，成长可能就是一个人多多少少的经历而孕育出人潜意识选择的微妙变化。</span></p><h2 id="UGRKc"><span class="ne-text">虫子</span></h2><p id="uf08ebd89" class="ne-p"><span class="ne-text">一个男人对于一个女人有多爱，应该在女人怀有身孕的那个阶段，男人给予女人多少的照顾来衡量。</span></p><p id="u831af1b5" class="ne-p"><span class="ne-text">什么是照顾，可能就是半夜赶走妻子身边的蚊虫就是一种照顾…</span></p><h2 id="DgykL"><span class="ne-text">水中的歌利亚</span></h2><p id="ub455e1e9" class="ne-p"><span class="ne-text">不久前父亲的离去，再在一场大雨不断的天气下，母亲也糖尿休克了，一时间对于亲人的这般离去，作者只知道在洪水中把母亲的尸体绑在木板上作为小船拖去抢救，即便最后尸体也不知道飘向何处…作者最后在塔吊避雨，想起了父亲在工作时的焊接火花射到脸上，想起了父亲教作者游泳潜水，想起了将母亲缠绕在木板上的绿色胶带…</span></p><h2 id="CcIvf"><span class="ne-text">那里是夜，这里有歌</span></h2><p id="ud6ffdc42" class="ne-p"><span class="ne-text">龙大就像是『夏洛特烦恼』中的大傻春。</span></p><p id="u5a0352cf" class="ne-p"><span class="ne-text">“认识你很高兴”，我想这是明华对龙大寄托的另一种情感。</span></p><p id="ub0a131cf" class="ne-p"><span class="ne-text">这世界上总有一些简单纯粹的人活得那么用力。</span></p><h2 id="Uo58d"><span class="ne-text">一天的轴</span></h2><p id="u6ad2873d" class="ne-p"><span class="ne-text">机场是个很容易让人感伤的地方，无数来来往往的陌生面孔总会让你心里觉得平淡而又恍惚。琪玉女士只是个机场保洁工作的一名普通人，失去爱人，孩子也在退伍之际做出一些错事而入狱，想着儿子总想去国外进修…一天的轴或许就是念想里为了某个人总想去坚持做点什么的事。</span></p><p id="u3220ec89" class="ne-p"><span class="ne-text">机场和车站不一样，机场更多是让人感到感伤，而绿皮车和高铁给人以寄托。我还怀念每次回学校，下午四五点飞下机，夕阳洒满遥墙机场的每个角落，机场的边界是一些树，小森林一般，看着那些树，每次总让想起家乡的景色，安安静静的一个小城，安安静静的行人。求学的意义是什么呢？至今没有一个确切让我自己信服的借口，可能那也是我的轴罢了。</span></p><h2 id="X7XHC"><span class="ne-text">角质层</span></h2><p id="u229f9c29" class="ne-p"><span class="ne-text">受宠若惊般地小心翼翼，却也掩饰不了一个人的简单纯粹。</span></p><p id="u46db2972" class="ne-p"><span class="ne-text">可是谁又知道这样的小心翼翼，却是在一个在艰难环境下经历那个年纪本不该承受的经历换来的坚强。</span></p><h2 id="qOfeR"><span class="ne-text">尼克塔酒店</span></h2><p id="u96324f7f" class="ne-p"><span class="ne-text">一段旅行，从一开始就应该决定好同行的人，是否相处得来，否则很容易产生矛盾甚至中途散场，即便对方是曾经很要好的朋友或发小，随着时间的推移，人也是会变的。旅行和人生都是如此。</span></p><h2 id="hgsUN"><span class="ne-text">三十岁</span></h2><p id="ubb655d91" class="ne-p"><span class="ne-text">一个人的成长很多时候是这个世界上另一些生命的救赎，谁都应该努力地活着。</span></p></div>]]></content>
      
      
      <categories>
          
          <category> 阅读 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>一个梦——新学期</title>
      <link href="/essay/shdnxh6ya6pgbh1n/"/>
      <url>/essay/shdnxh6ya6pgbh1n/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="u3fe3baad" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/1484158/1669244059061-5269cc7d-fa21-4467-a750-5aa43184f583.jpeg" width="600" id="ZLXlO" class="ne-image"></p><p id="uc8d73b3a" class="ne-p"><span class="ne-text">下学期开学了，位置是我初中的那个学校，教室是最初的靠近大门的高排宿舍那里，那里本来是一排宿舍，不知怎么改为教室了。</span></p><p id="u76d5ec95" class="ne-p"><span class="ne-text">新学期开学，我还是一如既往去的很晚，教室里面坐满了人，我看着第三排还是第四排边上有个空位，就坐了过去，第一堂课是数学，具体讲的我忘了，不过记得讲的是一种新型运算，打破传统运算的那种…</span></p><p id="ucb3b5036" class="ne-p"><span class="ne-text">我的同桌告诉我待会可能按照成绩分位置，我一脸懵，不知道有什么成绩…</span></p><p id="u1912f2dc" class="ne-p"><span class="ne-text">然后快下课的前十分钟，班主任进来了，她说报一下上次数学考试排名，我记得我排第五还是第六，分数是我高考数学成绩，同学把我的试卷递给我。老师说这次新班级数学超过1xx的有十个，讲完，我便醒了（冻醒）……</span></p><p id="u8a72d38f" class="ne-p"><span class="ne-text">后记:</span></p><p id="u727b7420" class="ne-p"><span class="ne-text">那个位置不是靠窗的，可我上课还是喜欢看着外面，看那个一排排自行车的地方。</span></p><p id="u62d08c65" class="ne-p"><span class="ne-text">新学期的第一堂课，一如既往般地身边所有同学都很聚精会神，但我却很出神……</span></p><p id="u6a799471" class="ne-p"><span class="ne-text">其实我一直都不喜欢新学期，特别是大学之前的小学初中，一切都太新了，那种氛围感有点让人窒息抑郁…直到大学，我几乎只坐最后一排靠窗，我喜欢在上课的时候看小说，尤其是所有人都在认真听课的时候，记得大三有一个学期中的两个礼拜的所有离散数学课，我全都用来看《平凡的世界》了……</span></p><p id="u4fc2e318" class="ne-p"><span class="ne-text">梦醒的那一刻，一大堆记忆涌入脑海:上大学了…大学毕业了…工作上班了…我还在睡觉…待会起来上班……</span></p></div>]]></content>
      
      
      <categories>
          
          <category> 异世界 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CommonJS模块转ESM模块方法</title>
      <link href="/blog/fhxatr6exkaavb4k/"/>
      <url>/blog/fhxatr6exkaavb4k/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="ua2542a3a" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1668599149397-081cdc1f-3a12-445f-a1ee-077ecde12f33.png" width="240" id="ue9195258" class="ne-image"></p><p id="u22b00a16" class="ne-p"><span class="ne-text">前言：vite项目中，依赖包的加载都是基于esm模块加载的，有些依赖打包后不是esm而是CommonJS类型的，则需要由CommonJS转为esm类型。vite预构建可以默认将node_modules下的依赖包进行转换为esm类型并存放在node_modules文件夹下的.vite文件夹下，也可以自行添加路径来预构建（详见文档：</span><a href="https://cn.vitejs.dev/guide/dep-pre-bundling.html#customizing-the-behavior" data-href="https://cn.vitejs.dev/guide/dep-pre-bundling.html#customizing-the-behavior" target="_blank" class="ne-link"><span class="ne-text">https://cn.vitejs.dev/guide/dep-pre-bundling.html#customizing-the-behavior</span></a><span class="ne-text">）。</span></p><p id="ue3363f3f" class="ne-p"><span class="ne-text"></span></p><div data-type="info" class="ne-alert"><p id="ub42e1842" class="ne-p"><strong><span class="ne-text">前端模块化相关文章：</span></strong><a href="https://www.wztlink1013.com/blog/psazge/" data-href="https://www.wztlink1013.com/blog/psazge/" class="ne-link"><strong><span class="ne-text">前端代码模块及其工具化（Webpack,roolup.js）构建 | 尼采般地抒情</span></strong></a></p></div><p id="u4a983763" class="ne-p"><br></p><p id="ub9247581" class="ne-p"><span class="ne-text">对于一些老旧sdk，在vite项目中，利用pnpm link调试，就需要转包操作了。在此记录一下手动将CommonJS模块转为ESM模块的小demo。</span></p><p id="ua6dd2af8" class="ne-p"><span class="ne-text"></span></p><pre><code>&#123;  &quot;name&quot;: &quot;cjs_to_esm&quot;,  &quot;version&quot;: &quot;1.0.0&quot;,  &quot;description&quot;: &quot;&quot;,  &quot;type&quot;: &quot;module&quot;,  &quot;scripts&quot;: &#123;    &quot;build&quot;: &quot;rollup -c&quot;  &#125;,  &quot;keywords&quot;: [],  &quot;author&quot;: &quot;&quot;,  &quot;license&quot;: &quot;ISC&quot;,  &quot;devDependencies&quot;: &#123;    &quot;@rollup/plugin-commonjs&quot;: &quot;^23.0.2&quot;,    &quot;rollup&quot;: &quot;^3.2.5&quot;  &#125;&#125;<code>&#123;  &quot;name&quot;: &quot;cjs_to_esm&quot;,  &quot;version&quot;: &quot;1.0.0&quot;,  &quot;description&quot;: &quot;&quot;,  &quot;type&quot;: &quot;module&quot;,  &quot;scripts&quot;: &#123;    &quot;build&quot;: &quot;rollup -c&quot;  &#125;,  &quot;keywords&quot;: [],  &quot;author&quot;: &quot;&quot;,  &quot;license&quot;: &quot;ISC&quot;,  &quot;devDependencies&quot;: &#123;    &quot;@rollup/plugin-commonjs&quot;: &quot;^23.0.2&quot;,    &quot;rollup&quot;: &quot;^3.2.5&quot;  &#125;&#125;</code></code></pre><pre><code>import commonjs from '@rollup/plugin-commonjs';export default &#123;  input: 'src/test_cjs.js',  output: &#123;    file: 'output/test_esm.js',    format: 'es'  &#125;,  plugins: [commonjs()]&#125;;<code>import commonjs from '@rollup/plugin-commonjs';export default &#123;  input: 'src/test_cjs.js',  output: &#123;    file: 'output/test_esm.js',    format: 'es'  &#125;,  plugins: [commonjs()]&#125;;</code></code></pre></div>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
          <category> Node.js </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>一个梦——一个老人</title>
      <link href="/essay/gkc62n/"/>
      <url>/essay/gkc62n/</url>
      
        <content type="html"><![CDATA[<div class="yuque-hexo-lyrics-secret">这是加密文章！</div>]]></content>
      
      
      <categories>
          
          <category> 异世界 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Vue部分学习笔记</title>
      <link href="/blog/vdv6i5/"/>
      <url>/blog/vdv6i5/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h4 id="TqRTc"><span class="ne-text">Something</span></h4><ul class="ne-ul"><li id="u0b9a12c4" data-lake-index-type="0"><span class="ne-text">响应式变量是利用ES6的Proxy（Vue3）来实现的</span></li><li id="u27d82690" data-lake-index-type="0"><span class="ne-text">原生DOM事件传参（内部封装）</span></li></ul><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="u97a2e768" data-lake-index-type="0"><span class="ne-text">不传参数，只传递函数名，函数形参可传默认e</span></li><li id="u79084da4" data-lake-index-type="0"><span class="ne-text">fun($event, param)</span></li></ul></ul><ul class="ne-ul"><li id="u900e3eb9" data-lake-index-type="0"><span class="ne-text">计算属性和侦听器</span></li></ul><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="u0434c8d3" data-lake-index-type="0"><span class="ne-text">计算属性和方法之间，计算方法具备缓存能力，而方法不具备</span></li><li id="u436278c9" data-lake-index-type="0"><span class="ne-text">默认计算属性是只读的，不过可以对具体计算属性写成get set的形式组织</span></li><li id="u040a81d0" data-lake-index-type="0"><span class="ne-text">计算属性适合：多个值影响一个值的应用</span></li><li id="u3525bad4" data-lake-index-type="0"><span class="ne-text">侦听器适合：一个值影响多个值的应用</span></li><li id="u00bd3e9a" data-lake-index-type="0"><span class="ne-text">侦听器支持异步，计算属性不支持</span></li></ul></ul><ul class="ne-ul"><li id="u0c3ad476" data-lake-index-type="0"><span class="ne-text">自定义全局属性</span></li></ul><pre><code><code>app.config.globalProperties.$something = something</code></code></pre><h4 id="BRlLZ"><span class="ne-text">组件</span></h4><pre><code><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;  &lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot; /&gt;    &lt;title&gt;learn vue&lt;/title&gt;    &lt;script src=&quot;./vue.global.js&quot;&gt;&lt;/script&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;div id=&quot;app&quot;&gt;      &lt;div&gt;parent count: &#123;&#123;count&#125;&#125;&lt;/div&gt;      &lt;my-head        :title=&quot;headerTitle&quot;        @custom-event=&quot;handleCustomEvent&quot;        v-model=&quot;count&quot;        &gt;&lt;/my-head&gt;    &lt;/div&gt;    &lt;script&gt;      let app = Vue.createApp(&#123;        data() &#123;          return &#123;            headerTitle: &quot;header-title&quot;,            count: &quot;1&quot;,          &#125;;        &#125;,        methods: &#123;          handleCustomEvent(data) &#123;            console.log(data);          &#125;,        &#125;,      &#125;);      // local component      const HeaderLocalComponent = &#123;        template: `header-local-component`,      &#125;;      // global component      app.component(&quot;my-head&quot;, &#123;        props: &#123;          title: &#123;            type: String,          &#125;,          modelValue: &#123;            type: String,          &#125;,        &#125;, // or props: [&quot;title&quot;]        emits: [&quot;custom-event&quot;, &quot;update:modelValue&quot;],        template: `          &lt;header&gt;            &lt;h1&gt;&#123;&#123;headTitle&#125;&#125;&lt;/h1&gt;            &lt;p&gt;message: &#123;&#123;message&#125;&#125;&lt;/p&gt;            &lt;p&gt;reverse message: &#123;&#123;reverseMessage&#125;&#125;&lt;/p&gt;            &lt;header-local-component&gt;&lt;/header-local-component&gt;            &lt;input type=&quot;text&quot; :value=&quot;modelValue&quot; @input=&quot;handleInput&quot; /&gt;          &lt;/header&gt;        `,        components: &#123;          HeaderLocalComponent,        &#125;,        data() &#123;          return &#123;            message: &quot;hello world&quot;,            headTitle: this.title, // props data -&gt; responsive...          &#125;;        &#125;,        mounted() &#123;          setTimeout(() =&gt; &#123;            this.message = &quot;hello world2&quot;;            this.headTitle = &quot;head change self title...&quot;;            this.$emit(&quot;custom-event&quot;, &#123;              info: &quot;child to parent.&quot;,            &#125;);          &#125;, 2000);        &#125;,        computed: &#123;          // reverseMessage() &#123;          //   return this.message.split(&quot; &quot;).reverse().join(&quot; &quot;);          // &#125;,          reverseMessage: &#123;            get() &#123;              return this.message.split(&quot; &quot;).reverse().join(&quot; &quot;);            &#125;,            set(value) &#123;              this.message = value;            &#125;,          &#125;,        &#125;,        methods: &#123;          handleInput(e) &#123;            this.$emit(&quot;update:modelValue&quot;, e.target.value);          &#125;,        &#125;,        watch: &#123;          modelValue(newValue, oldValue) &#123;            console.log(&quot;modelValue change...&quot;, oldValue, newValue);          &#125;,        &#125;,      &#125;);      const vm = app.mount(&quot;#app&quot;);    &lt;/script&gt;  &lt;/body&gt;&lt;/html&gt;</code></code></pre><ol class="ne-ol"><li id="u4d328647" data-lake-index-type="0"><span class="ne-text">组件的注册以及使用</span></li><li id="ufd607490" data-lake-index-type="0"><span class="ne-text">根组件以及普通组件：根组件template比html结构中的子内容优先级更高（覆盖渲染）</span></li><li id="u8fa1744e" data-lake-index-type="0"><span class="ne-text">全局组件以及局部组件的选项式写法</span></li></ol><h4 id="MRrGb"><span class="ne-text">$attrs</span></h4><ol class="ne-ol"><li id="u58721946" data-lake-index-type="0"><span class="ne-text">组件默认传递属性，如果子组件没有接收，那么会作为默认属性添加到dom身上</span></li><li id="u83ef31fc" data-lake-index-type="0"><span class="ne-text">如果要去除上述的默认传递效果，可以添加inheritAttrs参数</span></li></ol><pre><code><code>app.component(&quot;my-head&quot;, &#123;  data() &#123;    return &#123;      message: &quot;hello world&quot;,    &#125;;  &#125;,  inheritAttrs: false  ···&#125;);</code></code></pre><ol start="3" class="ne-ol"><li id="ua9768288" data-lake-index-type="0"><span class="ne-text">如果添加了inheritAttrs参数，但又需要对指定dom添加自定义属性</span></li></ol><pre><code><code>&lt;h1 v-bind:info=&quot;$attrs.info&quot;&gt;&lt;/h1&gt;</code></code></pre><ol start="4" class="ne-ol"><li id="ub2d29799" data-lake-index-type="0"><span class="ne-text">this.$attrs也可以进行通信</span></li></ol><h4 id="TiE4b"><span class="ne-text">$refs</span></h4><ol class="ne-ol"><li id="u4817ecbb" data-lake-index-type="0"><span class="ne-text">ref属性作用在元素上，this.$refs.xxx获取的是原生DOM</span></li><li id="u8f48b247" data-lake-index-type="0"><span class="ne-text">ref属性作用在组件上，this.$refs.xxx获取的是组件实例对象，可以调用其方法或是响应式变量</span></li><li id="ua573eba6" data-lake-index-type="0"><span class="ne-text">可以间接进行组件间的通信</span></li></ol><h4 id="cEAJx"><span class="ne-text">$nextTick</span></h4><ol class="ne-ol"><li id="u3f784d7c" data-lake-index-type="0"><span class="ne-text">在DOM渲染之后的执行时机，同updated生命周期</span></li><li id="u456b5f83" data-lake-index-type="0"><span class="ne-text">有两种写法，一种是hook风格，另一种是Promise链式调用风格</span></li></ol><h4 id="JYOrd"><span class="ne-text">自定义指令</span></h4><p id="uf5282b09" class="ne-p"><span class="ne-text">自定义指令也是逻辑复用的常见形式之一，比如对节点赋予拖拽功能，基本语法如下：</span></p><pre><code><code>// globalapp.directive(name, (el, binding) =&gt; &#123;  // &#125;)<p>// template local<br>&#123;<br>  …<br>  directives() &#123;<br>    name: (el, binding) =&gt; &#123;<br>      //<br>    &#125;<br>  &#125;<br>&#125;</code><br></code></pre></p><h4 id="rZrHG"><span class="ne-text">mixins</span></h4><ul class="ne-ul"><li id="ucc09c277" data-lake-index-type="0"><span class="ne-text">一种复用逻辑的抽离的方式</span></li></ul><p id="ub3f17cf1" class="ne-p"><span class="ne-text"></span></p></div>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
          <category> Vue </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Axios实现重连机制</title>
      <link href="/blog/urrudl/"/>
      <url>/blog/urrudl/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="u719a7e4d" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1665819024337-8997802d-d9c9-4398-aa69-f7be2c45d02b.png" width="1347.499946455163" id="u1a5e26ad" class="ne-image"></p><p id="ub28fc1f7" class="ne-p"><span class="ne-text"></span></p><p id="uab8a1db5" class="ne-p"><span class="ne-text">前言：Vue项目中利用Axios封装接口的请求和响应过程中，请求的接口可能会出现本地网络情况抑或是服务端相关环境错误，如果需要接口配置重连机制，如下逻辑可以实现：</span></p><p id="u7c9e092e" class="ne-p"><br></p><pre><code>···service.interceptors.response.use(  (response) =&gt; &#123;    tryCloseLoading();    return response &amp;&amp; response.data;  &#125;,  (err) =&gt; &#123;    // 通用报错处理    if (err.response) &#123;      // 通用报错处理      ···      // 关闭加载中      tryCloseLoading();      // return Promise.reject(err.response.data);    &#125; else &#123;      const &#123; config &#125; = err;      if (!config || !config.retry) return Promise.reject(err);      config.retryCount = config.retryCount || 0;      // 检查是否已经达到重连总数      if (config.retryCount &gt;= config.retry) &#123;        message.error('当前网络异常');        tryCloseLoading();        return Promise.reject(err);      &#125;      config.retryCount += 1;      // 自动计算每次重试的延时，重试次数越多，延时越大      const retryDelay = (1 / 2) * (Math.pow(2, config.retryCount) - 1) * 1000;      // 创建新的 Promise 来发起请求      const backoff = new Promise((resolve) =&gt; &#123;        setTimeout(() =&gt; &#123;          resolve();        &#125;, retryDelay);      &#125;);      return backoff.then(() =&gt; &#123;        tryCloseLoading();        return service(config);      &#125;);    &#125;  &#125;,);···</code></pre></div>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
          <category> 前端业务解决方案 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>站点使用防盗链图片和百度统计Referer不一致的解决方案</title>
      <link href="/blog/ugwagn/"/>
      <url>/blog/ugwagn/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="uac5762ec" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1665124978469-51dce474-28f7-4372-9549-d55a6fd48098.png" width="874.1666319304056" id="udf2cdd49" class="ne-image"></p><p id="ue8a744ec" class="ne-p"><span class="ne-text">前言：个人网站使用的语雀外链图片和百度统计两者之间的referrer不一致的解决方案</span></p><hr id="kUABX" class="ne-hr"><p id="u1cbd0778" class="ne-p"><span class="ne-text">问题描述：防盗链图片不在所指定的白名单内，是不被允许访问的，比如语雀图片不能在非自己网站上渲染使用。</span></p><p id="u91b79cc2" class="ne-p"><span class="ne-text"></span></p><p id="uccfeeba5" class="ne-p"><span class="ne-text">常规解决思路：通过设置页面</span><code class="ne-code"><span class="ne-text">meta</span></code><span class="ne-text">标签的</span><code class="ne-code"><span class="ne-text">referrer</span></code><span class="ne-text">属性值为</span><code class="ne-code"><span class="ne-text">no-referrer</span></code><span class="ne-text">可以进行访问（</span><a href="https://blog.csdn.net/qq_53225741/article/details/125239106" data-href="https://blog.csdn.net/qq_53225741/article/details/125239106" class="ne-link"><span class="ne-text">Referer和Referrer Policy以及图片防盗链</span></a><span class="ne-text">）</span></p><pre><code><code>&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot; /&gt;</code></code></pre><p id="uf17ac2f5" class="ne-p"><span class="ne-text">设置上述referrer，可以在其他网站使用防盗链的图片，但是会存在一些副作用，比如对百度统计代码失效，因为百度统计需要携带请求网站的referr等信息才能进一步进行数据统计分析，所以这种解决办法属于取舍功能的方式。</span></p><p id="uaa9559de" class="ne-p"><br></p><p id="u41eb776c" class="ne-p"><span class="ne-text">最终解决思路：利用网页的代码执行顺序，动态对网站的referrer进行更改，设置网站初始referrer为</span><code class="ne-code"><span class="ne-text">no-referrer</span></code><span class="ne-text">，待网站所有外链防盗图片加载完成，再动态修改referrer为</span><code class="ne-code"><span class="ne-text">strict-origin-when-cross-origin</span></code><span class="ne-text">，再进行百度统计逻辑代码的执行。核心代码如下：</span></p><pre><code><code>const lyrics = document.getElementById(&quot;lyrics&quot;);if (!lyrics) return;<p>Promise.all(<br>  Array.from(lyrics.querySelectorAll(&quot;img&quot;) || [])<br>  .filter((img) =&gt;<br>    /^(https://cdn.nlark.com/yuque)/.test(img.src || &quot;&quot;)<br>         )<br>  .map((node) =&gt; &#123;<br>    return new Promise((resolve, reject) =&gt; &#123;<br>      node.setAttribute(&quot;referrerpolicy&quot;, &quot;no-referrer&quot;);<br>      let loadImg = new Image();<br>      loadImg.src = node.src;<br>      loadImg.onload = () =&gt; &#123;<br>        resolve(node);<br>      &#125;;<br>    &#125;);<br>  &#125;)<br>)<br>  .then(() =&gt; &#123;<br>    console.log(&quot;[lyrics yuque] set meta referrer success.&quot;);<br>    document<br>      .querySelector(‘meta[name=&quot;referrer&quot;]’)<br>      .setAttribute(&quot;content&quot;, &quot;strict-origin-when-cross-origin&quot;);<br>    var hm = document.createElement(&quot;script&quot;);<br>    hm.src = &quot;<a href="https://hm.baidu.com/hm.js?xxxxxxxx">https://hm.baidu.com/hm.js?xxxxxxxx</a>&quot;;<br>    var s = document.getElementsByTagName(&quot;script&quot;)[0];<br>    s.parentNode.insertBefore(hm, s);<br>  &#125;)<br>  .catch(() =&gt; &#123;<br>    console.warn(&quot;[lyrics yuque] set meta referrer error.&quot;);<br>  &#125;);</code><br></code></pre></p></div>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
          <category> 博客技术 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>站点添加雷姆live2d+看板模型</title>
      <link href="/blog/wrygmp/"/>
      <url>/blog/wrygmp/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="ubf72f4a0" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1665116739656-379177c2-ffa2-4cc4-b22c-38fb12c201e8.png" width="1599.1666031214952" id="u3f0332ae" class="ne-image"></p><p id="u2c3627c7" class="ne-p"><br></p><p id="u15698168" class="ne-p"><span class="ne-text">前言：为自己站点配置雷姆live2d，并在live2d模型的基础上附加添加看板功能。</span></p><h2 id="dTMUK"><span class="ne-text">安装hexo-helper-live2d</span></h2><ul class="ne-ul"><li id="ua238e076"><span class="ne-text">下载</span><code class="ne-code"><span class="ne-text">hexo-helper-live2d</span></code><span class="ne-text">（</span><a href="https://github.com/EYHN/hexo-helper-live2d" data-href="https://github.com/EYHN/hexo-helper-live2d" target="_blank" class="ne-link"><span class="ne-text">https://github.com/EYHN/hexo-helper-live2d</span></a><span class="ne-text">）</span></li></ul><pre><code>npm install --save hexo-helper-live2d</code></pre><h2 id="xTwII"><span class="ne-text">配置自定义蕾姆模型</span></h2><h3 id="LkS5r"><span class="ne-text">文件配置</span></h3><ul class="ne-ul"><li id="uba7ea8c6"><span class="ne-text">remu模型下载：</span><a href="https://onedrive.wztlink1013.com/zh-CN/live2d/" data-href="https://onedrive.wztlink1013.com/zh-CN/live2d/" target="_blank" class="ne-link"><span class="ne-text">https://onedrive.wztlink1013.com/zh-CN/live2d/</span></a><span class="ne-text"> 【密码：remu】</span></li><li id="u4c758308"><span class="ne-text">在hexo</span><strong><span class="ne-text">项目根目录</span></strong><span class="ne-text">新建</span><code class="ne-code"><span class="ne-text">live2d_models</span></code><span class="ne-text">文件夹，再将所下载的模型解压放入该文件夹</span></li></ul><p id="ub4f75940" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1665114888992-4037e056-a783-4827-9d0f-426fbc3e0107.png" width="548.3333115445251" id="u4879bd54" class="ne-image"></p><h3 id="RMXIc"><span class="ne-text">_config.yml配置</span></h3><ul class="ne-ul"><li id="ue2750c2f"><span class="ne-text">根目录_config.yml添加如下配置</span></li><li id="u1a142b41"><span class="ne-text">API文档：</span><a href="https://l2dwidget.js.org/docs/class/src/index.js~L2Dwidget.html#instance-method-init" data-href="https://l2dwidget.js.org/docs/class/src/index.js~L2Dwidget.html#instance-method-init" target="_blank" class="ne-link"><span class="ne-text">https://l2dwidget.js.org/docs/class/src/index.js~L2Dwidget.html#instance-method-init</span></a></li></ul><pre><code>## live2dlive2d:  enable: true # 是否开启live2d  scriptFrom: local # 脚本从本地引入  pluginRootPath: live2d/ # 插件在站点上的根目录(相对路径)  pluginJsPath: lib/ # 脚本文件相对与插件根目录路径  pluginModelPath: assets/ # 模型文件相对与插件根目录路径  tagMode: false # 标签模式, 是否仅替换 live2d tag标签而非插入到所有页面中  debug: false # 调试, 是否在控制台输出日志  model:    use: remu # 填写放进live2d_models文件夹中的模型文件夹名字    scale: 1 # canvas 模型与canvas的缩放  display:    width: 150 # 宽度    height: 300 # 高度    position: left # 显示位置    hOffset: 0 #水平偏移    vOffset: -12 #垂直偏移  mobile:    show: true # 手机端是否显示    scale: 1 # 移动设备上的缩放  react:    opacity: 1 # 透明度</code></pre><div data-type="info" class="ne-alert"><p id="u9c7aaaf6" class="ne-p"><span class="ne-text">PS：按需加载live2d标签</span></p><p id="u6dcae3e1" class="ne-p"><span class="ne-text">上述配置中</span><code class="ne-code"><span class="ne-text">tagMode: true</span></code><span class="ne-text">则代表需要在主题中单独给出需要显示的页面</span></p></div><h3 id="aCTih"><span class="ne-text">最终live2d效果</span></h3><p id="u79795e33" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1665115637123-4e5c7429-8a8e-4ae9-b38b-64fc9779a01f.png" width="1599.9999364217147" id="uf21a5c73" class="ne-image"></p><h2 id="dgYzR"><span class="ne-text">配置三方插件模型</span></h2><p id="ua70cfc9f" class="ne-p"><span class="ne-text">上述步骤是下载remu源文件然后自定义的remu模型，也可以下载社区封装好npm插件的模型，本文做自定义模型的说明，故不做该部分详述。相关参考如下：</span></p><ul class="ne-ul"><li id="ufdb404b2"><a href="https://github.com/xiazeyu/live2d-widget-models" data-href="https://github.com/xiazeyu/live2d-widget-models" target="_blank" class="ne-link"><span class="ne-text">https://github.com/xiazeyu/live2d-widget-models</span></a></li><li id="u4b8b184e"><a href="https://huaji8.top/post/live2d-plugin-2.0/" data-href="https://huaji8.top/post/live2d-plugin-2.0/" class="ne-link"><span class="ne-text">https://huaji8.top/post/live2d-plugin-2.0/</span></a></li></ul><h2 id="ayEhu"><span class="ne-text">附：给live2d添加看板功能</span></h2><p id="u85e2afa1" class="ne-p"><span class="ne-text">上述所有步骤完成live2d的安装配置，在此基础上还可以给live2d添加看板功能，就如本文第一张图片那种效果</span></p><h3 id="MW7kI"><span class="ne-text">添加看板样式</span></h3><p id="uc900e14f" class="ne-p"><span class="ne-text">添加静态样式即可：</span></p><details class="lake-collapse"><summary id="u319b4002"><span class="ne-text">_live2d/remu.styl</span></summary><pre><code>// 收缩之后的左下角的贴附样式#waifu-toggle &#123;  background-color: #3f51b5;  border-radius: 5px;  bottom: 66px;  color: #fff;  cursor: pointer;  font-size: 14px;  left: 5px;  margin-left: -90px;  padding: 5px 2px 5px 5px;  position: fixed;  transition: margin-left 1s;  width: 60px;  writing-mode: vertical-rl;&#125;<p>#waifu-toggle.waifu-toggle-active &#123;<br>  margin-left: -40px;<br>&#125;</p><p>#waifu-toggle.waifu-toggle-active:hover &#123;<br>  margin-left: -30px;<br>&#125;</p><p>// 容纳雷姆的盒子<br>#waifu &#123;<br>  bottom: -1000px;<br>  left: 0;<br>  line-height: 0;<br>  margin-bottom: -10px;<br>  position: fixed;<br>  transform: translateY(3px);<br>  transition: transform .3s ease-in-out, bottom 3s ease-in-out;<br>  z-index: 1;<br>&#125;</p><p>#waifu:hover &#123;<br>  transform: translateY(0);<br>&#125;</p><p>// 文字提示框<br>#waifu-tips &#123;<br>  animation: shake 50s ease-in-out 5s infinite;<br>  background-color: rgba(100,149,237, .5);<br>  border: 1px solid rgba(30,144,255, .62);<br>  border-radius: 12px;<br>  box-shadow: 0 3px 15px 2px rgba(191, 158, 118, .2);<br>  font-size: 14px;<br>  line-height: 24px;<br>  margin: -30px 20px;<br>  min-height: 70px;<br>  opacity: 0;<br>  overflow: hidden;<br>  padding: 5px 10px;<br>  position: absolute;<br>  text-overflow: ellipsis;<br>  transition: opacity 1s;<br>  width: 180px;<br>  word-break: break-all;<br>&#125;</p><p>#waifu-tips.waifu-tips-active &#123;<br>  opacity: 1;<br>  transition: opacity .2s;<br>&#125;</p><p>#waifu-tips span<br>color: rgba(0,0,255,.7); // 文字提示框中的重点字</p><p>// 容纳雷姆的外加小盒子<br>#waifu #live2d &#123;<br>  cursor: grab;<br>  height: 300px;<br>  position: relative;<br>  width: 200px;<br>&#125;</p><p>#waifu #live2d:active &#123;<br>  cursor: grabbing;<br>&#125;</p><p>// 小按钮组件<br>#waifu-tool &#123;<br>  color: #0684bd;<br>  opacity: 0.5;<br>  position: absolute;<br>  left: 5px<br>    top: 70px;<br>  transition: opacity 1s;<br>&#125;</p><p>#waifu:hover #waifu-tool &#123;<br>  opacity: 1;<br>&#125;</p><p>// 小按钮的span样式<br>#waifu-tool span &#123;<br>  color: #0684bd;<br>  cursor: pointer;<br>  display: block;<br>  line-height: 30px;<br>  text-align: center;<br>  transition: color .3s;<br>&#125;</p><p>#waifu-tool span:hover &#123;<br>  color: #0684bd; /* #34495e */<br>&#125;</p><p>@keyframes shake &#123;<br>  2% &#123;<br>    transform: translate(.5px, -1.5px) rotate(-.5deg);<br>  &#125;</p><p>  4% &#123;<br>    transform: translate(.5px, 1.5px) rotate(1.5deg);<br>  &#125;</p><p>  6% &#123;<br>    transform: translate(1.5px, 1.5px) rotate(1.5deg);<br>  &#125;</p><p>  8% &#123;<br>    transform: translate(2.5px, 1.5px) rotate(.5deg);<br>  &#125;</p><p>  10% &#123;<br>    transform: translate(.5px, 2.5px) rotate(.5deg);<br>  &#125;</p><p>  12% &#123;<br>    transform: translate(1.5px, 1.5px) rotate(.5deg);<br>  &#125;</p><p>  14% &#123;<br>    transform: translate(.5px, .5px) rotate(.5deg);<br>  &#125;</p><p>  16% &#123;<br>    transform: translate(-1.5px, -.5px) rotate(1.5deg);<br>  &#125;</p><p>  18% &#123;<br>    transform: translate(.5px, .5px) rotate(1.5deg);<br>  &#125;</p><p>  20% &#123;<br>    transform: translate(2.5px, 2.5px) rotate(1.5deg);<br>  &#125;</p><p>  22% &#123;<br>    transform: translate(.5px, -1.5px) rotate(1.5deg);<br>  &#125;</p><p>  24% &#123;<br>    transform: translate(-1.5px, 1.5px) rotate(-.5deg);<br>  &#125;</p><p>  26% &#123;<br>    transform: translate(1.5px, .5px) rotate(1.5deg);<br>  &#125;</p><p>  28% &#123;<br>    transform: translate(-.5px, -.5px) rotate(-.5deg);<br>  &#125;</p><p>  30% &#123;<br>    transform: translate(1.5px, -.5px) rotate(-.5deg);<br>  &#125;</p><p>  32% &#123;<br>    transform: translate(2.5px, -1.5px) rotate(1.5deg);<br>  &#125;</p><p>  34% &#123;<br>    transform: translate(2.5px, 2.5px) rotate(-.5deg);<br>  &#125;</p><p>  36% &#123;<br>    transform: translate(.5px, -1.5px) rotate(.5deg);<br>  &#125;</p><p>  38% &#123;<br>    transform: translate(2.5px, -.5px) rotate(-.5deg);<br>  &#125;</p><p>  40% &#123;<br>    transform: translate(-.5px, 2.5px) rotate(.5deg);<br>  &#125;</p><p>  42% &#123;<br>    transform: translate(-1.5px, 2.5px) rotate(.5deg);<br>  &#125;</p><p>  44% &#123;<br>    transform: translate(-1.5px, 1.5px) rotate(.5deg);<br>  &#125;</p><p>  46% &#123;<br>    transform: translate(1.5px, -.5px) rotate(-.5deg);<br>  &#125;</p><p>  48% &#123;<br>    transform: translate(2.5px, -.5px) rotate(.5deg);<br>  &#125;</p><p>  50% &#123;<br>    transform: translate(-1.5px, 1.5px) rotate(.5deg);<br>  &#125;</p><p>  52% &#123;<br>    transform: translate(-.5px, 1.5px) rotate(.5deg);<br>  &#125;</p><p>  54% &#123;<br>    transform: translate(-1.5px, 1.5px) rotate(.5deg);<br>  &#125;</p><p>  56% &#123;<br>    transform: translate(.5px, 2.5px) rotate(1.5deg);<br>  &#125;</p><p>  58% &#123;<br>    transform: translate(2.5px, 2.5px) rotate(.5deg);<br>  &#125;</p><p>  60% &#123;<br>    transform: translate(2.5px, -1.5px) rotate(1.5deg);<br>  &#125;</p><p>  62% &#123;<br>    transform: translate(-1.5px, .5px) rotate(1.5deg);<br>  &#125;</p><p>  64% &#123;<br>    transform: translate(-1.5px, 1.5px) rotate(1.5deg);<br>  &#125;</p><p>  66% &#123;<br>    transform: translate(.5px, 2.5px) rotate(1.5deg);<br>  &#125;</p><p>  68% &#123;<br>    transform: translate(2.5px, -1.5px) rotate(1.5deg);<br>  &#125;</p><p>  70% &#123;<br>    transform: translate(2.5px, 2.5px) rotate(.5deg);<br>  &#125;</p><p>  72% &#123;<br>    transform: translate(-.5px, -1.5px) rotate(1.5deg);<br>  &#125;</p><p>  74% &#123;<br>    transform: translate(-1.5px, 2.5px) rotate(1.5deg);<br>  &#125;</p><p>  76% &#123;<br>    transform: translate(-1.5px, 2.5px) rotate(1.5deg);<br>  &#125;</p><p>  78% &#123;<br>    transform: translate(-1.5px, 2.5px) rotate(.5deg);<br>  &#125;</p><p>  80% &#123;<br>    transform: translate(-1.5px, .5px) rotate(-.5deg);<br>  &#125;</p><p>  82% &#123;<br>    transform: translate(-1.5px, .5px) rotate(-.5deg);<br>  &#125;</p><p>  84% &#123;<br>    transform: translate(-.5px, .5px) rotate(1.5deg);<br>  &#125;</p><p>  86% &#123;<br>    transform: translate(2.5px, 1.5px) rotate(.5deg);<br>  &#125;</p><p>  88% &#123;<br>    transform: translate(-1.5px, .5px) rotate(1.5deg);<br>  &#125;</p><p>  90% &#123;<br>    transform: translate(-1.5px, -.5px) rotate(-.5deg);<br>  &#125;</p><p>  92% &#123;<br>    transform: translate(-1.5px, -1.5px) rotate(1.5deg);<br>  &#125;</p><p>  94% &#123;<br>    transform: translate(.5px, .5px) rotate(-.5deg);<br>  &#125;</p><p>  96% &#123;<br>    transform: translate(2.5px, -.5px) rotate(-.5deg);<br>  &#125;</p><p>  98% &#123;<br>    transform: translate(-1.5px, -1.5px) rotate(-.5deg);<br>  &#125;</p><p>  0%, 100% &#123;<br>    transform: translate(0, 0) rotate(0);<br>  &#125;<br>&#125;<br></code></pre></p></details><h3 id="ZDamL"><span class="ne-text">添加看板逻辑代码</span></h3><details class="lake-collapse"><summary id="ub489a590"><span class="ne-text">./part/live2d.js</span></summary><pre><code>function loadWidget(config) &#123;  let &#123; waifuPath, apiPath, cdnPath &#125; = config;  let useCDN = false, modelList;  if (typeof cdnPath === &quot;string&quot;) &#123;    useCDN = true;    if (!cdnPath.endsWith(&quot;/&quot;)) cdnPath += &quot;/&quot;;  &#125; else if (typeof apiPath === &quot;string&quot;) &#123;    if (!apiPath.endsWith(&quot;/&quot;)) apiPath += &quot;/&quot;;  &#125; else &#123;    console.error(&quot;Invalid initWidget argument!&quot;);    return;  &#125;  localStorage.removeItem(&quot;waifu-display&quot;);  sessionStorage.removeItem(&quot;waifu-text&quot;);  document.body.insertAdjacentHTML(&quot;beforeend&quot;, `&lt;div id=&quot;waifu&quot;&gt;                &lt;div id=&quot;waifu-tips&quot;&gt;&lt;/div&gt;                &lt;canvas id=&quot;live2d&quot;&gt;&lt;/canvas&gt;                &lt;div id=&quot;waifu-tool&quot;&gt;                    &lt;span class=&quot;fa fa-comments&quot;&gt;&lt;/span&gt;                    &lt;span class=&quot;fa fa-link&quot;&gt;&lt;/span&gt;                    &lt;span class=&quot;fa fa-compress&quot;&gt;&lt;/span&gt;                &lt;/div&gt;            &lt;/div&gt;`);  // https://stackoverflow.com/questions/24148403/trigger-css-transition-on-appended-element  setTimeout(() =&gt; &#123;    document.getElementById(&quot;waifu&quot;).style.bottom = 0;  &#125;, 0);<p>  function randomSelection(obj) &#123;<br>    return Array.isArray(obj) ? obj[Math.floor(Math.random() * obj.length)] : obj;<br>  &#125;<br>  // 检测用户活动状态，并在空闲时显示消息<br>  let userAction = false,<br>    userActionTimer,<br>    messageTimer,<br>    messageArray = [&quot;好久不见，日子过得好快呢……&quot;, &quot;嗨～欢迎访问该站点！&quot;, &quot;记得把小家加入 Adblock 白名单哦！&quot;];<br>  window.addEventListener(&quot;mousemove&quot;, () =&gt; userAction = true);<br>  window.addEventListener(&quot;keydown&quot;, () =&gt; userAction = true);<br>  setInterval(() =&gt; &#123;<br>    if (userAction) &#123;<br>      userAction = false;<br>      clearInterval(userActionTimer);<br>      userActionTimer = null;<br>    &#125; else if (!userActionTimer) &#123;<br>      userActionTimer = setInterval(() =&gt; &#123;<br>        showMessage(randomSelection(messageArray), 6000, 9);<br>      &#125;, 20000);<br>    &#125;<br>  &#125;, 1000);</p><p>  (function registerEventListener() &#123;<br>    // TODO: 第一个icon，说话<br>    document.querySelector(&quot;#waifu-tool .fa-comments&quot;).addEventListener(&quot;click&quot;, showHitokoto);<br>    // TODO: 第二个icon，貌似是什么游戏<br>    // document.querySelector(&quot;#waifu-tool .fa-paper-plane&quot;).addEventListener(&quot;click&quot;, () =&gt; &#123;<br>    //     if (window.Asteroids) &#123;<br>    //         if (!window.ASTEROIDSPLAYERS) window.ASTEROIDSPLAYERS = [];<br>    //         window.ASTEROIDSPLAYERS.push(new Asteroids());<br>    //     &#125; else &#123;<br>    //         const script = document.createElement(&quot;script&quot;);<br>    //         script.src = &quot;<a href="https://cdn.jsdelivr.net/gh/stevenjoezhang/asteroids/asteroids.js">https://cdn.jsdelivr.net/gh/stevenjoezhang/asteroids/asteroids.js</a>&quot;;<br>    //         document.head.appendChild(script);<br>    //     &#125;<br>    // &#125;);<br>    // TODO: 第三个icon，换人物<br>    // document.querySelector(&quot;#waifu-tool .fa-user-circle&quot;).addEventListener(&quot;click&quot;, loadOtherModel);<br>    // TODO: 第四个icon，应该是换装<br>    // document.querySelector(&quot;#waifu-tool .fa-street-view&quot;).addEventListener(&quot;click&quot;, loadRandModel);<br>    // TODO: 第五个icon，拍照<br>    // document.querySelector(&quot;#waifu-tool .fa-camera-retro&quot;).addEventListener(&quot;click&quot;, () =&gt; &#123;<br>    //     showMessage(&quot;照好了嘛，是不是很可爱呢？&quot;, 6000, 9);<br>    //     Live2D.captureName = &quot;photo.png&quot;;<br>    //     Live2D.captureFrame = true;<br>    // &#125;);<br>    // TODO: 第六个icon，原项目地址<br>    document.querySelector(&quot;#waifu-tool .fa-link&quot;).addEventListener(&quot;click&quot;, () =&gt; &#123;<br>      open(&quot;<a href="https://www.wztlink1013.com/about/">https://www.wztlink1013.com/about/</a>&quot;);<br>    &#125;);<br>    // TODO: 第七个icon，隐藏看板娘</p><pre><code>document.querySelector(&amp;quot;#waifu-tool .fa-compress&amp;quot;).addEventListener(&amp;quot;click&amp;quot;, () =&amp;gt; &#123;  localStorage.setItem(&amp;quot;waifu-display&amp;quot;, Date.now());  showMessage(&amp;quot;愿你有一天能与重要的人重逢。&amp;quot;, 2000, 11);  document.getElementById(&amp;quot;waifu&amp;quot;).style.bottom = &amp;quot;-500px&amp;quot;; // 隐藏大盒子  setTimeout(() =&amp;gt; &#123;    document.getElementById(&amp;quot;waifu&amp;quot;).style.display = &amp;quot;none&amp;quot;;    document.getElementById(&amp;quot;waifu-toggle&amp;quot;).classList.add(&amp;quot;waifu-toggle-active&amp;quot;);  &#125;, 3000);&#125;);window.addEventListener(&amp;quot;copy&amp;quot;, () =&amp;gt; &#123;  showMessage(&amp;quot;你都复制了些什么呀，转载要记得加上出处哦！&amp;quot;, 6000, 9);&#125;);window.addEventListener(&amp;quot;visibilitychange&amp;quot;, () =&amp;gt; &#123;  if (!document.hidden) showMessage(&amp;quot;哇，你终于回来了～&amp;quot;, 6000, 9);&#125;);</code></pre><p>  })();</p><p>  // 首页展示特定文字<br>  (function welcomeMessage() {<br>    let text;<br>    if (location.pathname === &quot;/&quot;) { // 如果是主页<br>      const now = new Date().getHours();<br>      if (now &gt; 5 &amp;&amp; now &lt;= 7) text = &quot;早上好！一日之计在于晨，美好的一天就要开始了。&quot;;<br>      else if (now &gt; 7 &amp;&amp; now &lt;= 11) text = &quot;上午好！工作顺利嘛，不要久坐，多起来走动走动哦！&quot;;<br>      else if (now &gt; 11 &amp;&amp; now &lt;= 13) text = &quot;中午了，工作了一个上午，现在是午餐时间！&quot;;<br>      else if (now &gt; 13 &amp;&amp; now &lt;= 17) text = &quot;午后很容易犯困呢，今天的运动目标完成了吗？&quot;;<br>      else if (now &gt; 17 &amp;&amp; now &lt;= 19) text = &quot;傍晚了！窗外夕阳的景色很美丽呢，最美不过夕阳红～&quot;;<br>      else if (now &gt; 19 &amp;&amp; now &lt;= 21) text = &quot;晚上好，今天过得怎么样？&quot;;<br>      else if (now &gt; 21 &amp;&amp; now &lt;= 23) text = [&quot;已经这么晚了呀，早点休息吧，晚安～&quot;, &quot;深夜时要爱护眼睛呀！&quot;];<br>      else text = &quot;你是夜猫子呀？这么晚还不睡觉，明天起的来嘛？&quot;;<br>    } else if (document.referrer !== &quot;&quot;) {<br>      const referrer = new URL(document.referrer),<br>        domain = referrer.hostname.split(&quot;.&quot;)[1];<br>      if (location.hostname === referrer.hostname) text = <code>欢迎阅读&amp;lt;span&amp;gt;「$&#123;document.title.split(&amp;quot; - &amp;quot;)[0]&#125;」&amp;lt;/span&amp;gt;</code>;<br>      else if (domain === &quot;baidu&quot;) text = <code>Hello！来自 百度搜索 的朋友&amp;lt;br&amp;gt;你是搜索 &amp;lt;span&amp;gt;$&#123;referrer.search.split(&amp;quot;&amp;amp;wd=&amp;quot;)[1].split(&amp;quot;&amp;amp;&amp;quot;)[0]&#125;&amp;lt;/span&amp;gt; 找到的我吗？</code>;<br>      else if (domain === &quot;so&quot;) text = <code>Hello！来自 360搜索 的朋友&amp;lt;br&amp;gt;你是搜索 &amp;lt;span&amp;gt;$&#123;referrer.search.split(&amp;quot;&amp;amp;q=&amp;quot;)[1].split(&amp;quot;&amp;amp;&amp;quot;)[0]&#125;&amp;lt;/span&amp;gt; 找到的我吗？</code>;<br>      else if (domain === &quot;google&quot;) text = <code>Hello！来自 谷歌搜索 的朋友&amp;lt;br&amp;gt;欢迎阅读&amp;lt;span&amp;gt;「$&#123;document.title.split(&amp;quot; - &amp;quot;)[0]&#125;」&amp;lt;/span&amp;gt;</code>;<br>      else text = <code>Hello！来自 &amp;lt;span&amp;gt;$&#123;referrer.hostname&#125;&amp;lt;/span&amp;gt; 的朋友</code>;<br>    } else {<br>      text = <code>欢迎阅读&amp;lt;span&amp;gt;「$&#123;document.title.split(&amp;quot; - &amp;quot;)[0]&#125;」&amp;lt;/span&amp;gt;</code>;<br>    }<br>    showMessage(text, 7000, 8);<br>  })();<br>  // TODO: 服务于第一个icon<br>  function showHitokoto() {<br>    // 增加 hitokoto.cn 的 API<br>    fetch(&quot;<a href="https://v1.hitokoto.cn/">https://v1.hitokoto.cn</a>&quot;)<br>      .then(response =&gt; response.json())<br>      .then(result =&gt; {<br>        const text = <code>这句一言来自 &amp;lt;span&amp;gt;「$&#123;result.from&#125;」&amp;lt;/span&amp;gt;，是 &amp;lt;span&amp;gt;$&#123;result.creator&#125;&amp;lt;/span&amp;gt; 在 hitokoto.cn 投稿的。</code>;<br>        showMessage(result.hitokoto, 6000, 9);<br>        setTimeout(() =&gt; {<br>          showMessage(text, 4000, 9);<br>        }, 6000);<br>      });<br>  }<br>  // 没有bug展示特定状态下的文字<br>  function showMessage(text, timeout, priority) {<br>    if (!text || (sessionStorage.getItem(&quot;waifu-text&quot;) &amp;&amp; sessionStorage.getItem(&quot;waifu-text&quot;) &gt; priority)) return;<br>    if (messageTimer) {<br>      clearTimeout(messageTimer);<br>      messageTimer = null;<br>    }<br>    text = randomSelection(text);<br>    sessionStorage.setItem(&quot;waifu-text&quot;, priority);<br>    const tips = document.getElementById(&quot;waifu-tips&quot;);<br>    tips.innerHTML = text;<br>    tips.classList.add(&quot;waifu-tips-active&quot;);<br>    messageTimer = setTimeout(() =&gt; {<br>      sessionStorage.removeItem(&quot;waifu-text&quot;);<br>      tips.classList.remove(&quot;waifu-tips-active&quot;);<br>    }, timeout);<br>  }</p><p>}<br>function initWidget(config, apiPath) {<br>  if (typeof config === &quot;string&quot;) config = { waifuPath: config, apiPath };<br>  document.body.insertAdjacentHTML(&quot;beforeend&quot;, <code>&amp;lt;div id=&amp;quot;waifu-toggle&amp;quot;&amp;gt;                 &amp;lt;span&amp;gt;雷姆&amp;lt;/span&amp;gt;             &amp;lt;/div&amp;gt;</code>);<br>  const toggle = document.getElementById(&quot;waifu-toggle&quot;);<br>  toggle.addEventListener(&quot;click&quot;, () =&gt; {<br>    toggle.classList.remove(&quot;waifu-toggle-active&quot;);<br>    if (toggle.getAttribute(&quot;first-time&quot;)) {<br>      loadWidget(config);<br>      toggle.removeAttribute(&quot;first-time&quot;);<br>    } else {<br>      localStorage.removeItem(&quot;waifu-display&quot;);<br>      document.getElementById(&quot;waifu&quot;).style.display = &quot;&quot;;<br>      setTimeout(() =&gt; {<br>        document.getElementById(&quot;waifu&quot;).style.bottom = 0;<br>      }, 0);<br>    }<br>    // TODO: 一开始判断是否隐藏雷姆代码</p><p>  });<br>  if (localStorage.getItem(&quot;waifu-display&quot;) &amp;&amp; Date.now() - localStorage.getItem(&quot;waifu-display&quot;) &lt;= 86400000) {<br>    toggle.setAttribute(&quot;first-time&quot;, true);<br>    setTimeout(() =&gt; {<br>      toggle.classList.add(&quot;waifu-toggle-active&quot;);<br>    }, 0);<br>  } else {<br>    loadWidget(config);<br>  }</p><p>}</p><p>export {<br>  initWidget, //导出对象<br>}</p><p></code></pre></p></details><p id="u09d47608" class="ne-p"><span class="ne-text">在base.js中初始化看板逻辑代码</span></p><pre><code>import &#123;initWidget&#125; from './part/live2d.js';<p>// live2d 初始化<br>initWidget(&#123;<br>  waifuPath: &quot;/data/remu.json&quot;,<br>  cdnPath: &quot;<a href="https://github.com/fghrsh/live2d_api/tree/1.0.1/">https://github.com/fghrsh/live2d_api/tree/1.0.1/</a>&quot;<br>&#125;);<br></code></pre></p><h3 id="kOl6b"><span class="ne-text">最终看板效果</span></h3><p id="u6ec1d33d" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1665116671351-7c3e9921-cb79-4902-822f-a09a3ce422ae.png" width="1599.9999364217147" id="u50ba46fe" class="ne-image"></p><h2 id="op5Lz"><span class="ne-text">参考</span></h2><ul class="ne-ul"><li id="u96f1ffee"><span class="ne-text">live2d API文档：</span><a href="https://l2dwidget.js.org/docs/class/src/index.js~L2Dwidget.html#instance-method-init" data-href="https://l2dwidget.js.org/docs/class/src/index.js~L2Dwidget.html#instance-method-init" target="_blank" class="ne-link"><span class="ne-text">https://l2dwidget.js.org/docs/class/src/index.js~L2Dwidget.html#instance-method-init</span></a></li><li id="uadc38fc5"><span class="ne-text">封装为npm插件模型：</span><a href="https://huaji8.top/post/live2d-plugin-2.0/" data-href="https://huaji8.top/post/live2d-plugin-2.0/" target="_blank" class="ne-link"><span class="ne-text">https://huaji8.top/post/live2d-plugin-2.0/</span></a></li><li id="0b0eccc822d2e4f83803798ba3120030"><span class="ne-text">自定义扩展模型：</span><a href="https://github.com/luanshizhimei/live2d_models_collect" data-href="https://github.com/luanshizhimei/live2d_models_collect" target="_blank" class="ne-link"><span class="ne-text">https://github.com/luanshizhimei/live2d_models_collect</span></a></li><li id="u845fdd61"><span class="ne-text">vscode live2d扩展：</span><a href="https://github.com/ezshine/vscode-rainbow-fart-waifu" data-href="https://github.com/ezshine/vscode-rainbow-fart-waifu" target="_blank" class="ne-link"><span class="ne-text">https://github.com/ezshine/vscode-rainbow-fart-waifu</span></a></li><li id="u1b0da9ef"><a href="https://github.com/fghrsh/live2d_api/tree/1.0.1/" data-href="https://github.com/fghrsh/live2d_api/tree/1.0.1/" target="_blank" class="ne-link"><span class="ne-text">https://github.com/fghrsh/live2d_api/tree/1.0.1/</span></a></li></ul><ul class="ne-tl"><li id="u57f3d399"><strong><span class="ne-text" style="background-color: #FADB14">TODO: </span></strong><span class="ne-text">优化资源加载方式，模型的静态资源使用外链的形式较为合理，以及插件每次在开发模式下都会编译文件，都会带来开发环境以及生产环境上的不便</span></li></ul></div>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
          <category> 博客技术 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Vue3项目中ts报错总结</title>
      <link href="/blog/ngt02r/"/>
      <url>/blog/ngt02r/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="u987b4e22" class="ne-p"><span class="ne-text">前言：总结Vue项目中ts常见报错及其解决方法。</span></p><h2 id="xQF2S"><span class="ne-text">TS7053: 元素隐式具有 &quot;any&quot; 类型，因为类型为 &quot;string&quot; 的表达式不能用于索引类型 &quot;{ doc_image: string; docx: string[]; }&quot;。ts(7053)</span></h2><ul class="ne-ul"><li id="u0fc1f849"><span class="ne-text">报错场景：</span></li></ul><pre><code>const MINE_TYPES = &#123;  doc_image: ['image/png', 'image/gif', 'image/jpeg', 'image/jpg'].join(','),&#125;;</code></pre><p id="u6dd3159d" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1660816279493-28f705da-2d60-432f-bbd4-20cfef128611.png" width="982" id="TAU1s" class="ne-image"></p><ul class="ne-ul"><li id="ub4f24491"><span class="ne-text">ts对于传入的apiType，编译器只知道为字符串而不是具体的doc_image或者docx，所以需要自行使用断言以及显示声明传入的值与这些值一致。</span></li></ul><pre><code>const accept = MINE_TYPES[apiType as keyof typeof MINE_TYPES] || '*';</code></pre><h2 id="hMqm1"><span class="ne-text">TS2531: Type ‘HTMLElement | null‘ is not assignable to type ‘HTMLElement‘</span></h2><ul class="ne-ul"><li id="u4c1bc5d4"><span class="ne-text">查找DOM这块，很有可能是找不到该DOM元素的，如下：</span></li></ul><p id="u8774d23b" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1660617254293-3d7d5a6c-3512-4c0a-84e4-4af68868f2df.png" width="623" id="GNuC9" class="ne-image"></p><p id="ub7348ded" class="ne-p"><span class="ne-text">很确定dom层一渲染dom树，使用断言</span></p><pre><code>// 点击按钮，返回顶部const handleBackToTop = () =&gt; &#123;  let page_content: HTMLElement = document.getElementById('file-page-content') as HTMLElement;  if (page_content !== null) &#123;    page_content.scrollTop = 0;  &#125;&#125;;</code></pre><h2 id="Lqyep"><span class="ne-text">TS2345: Typescript 'string | 类型的参数null' 不能分配给“字符串”类型的参数.类型 'null' 不能分配给类型 'string'</span></h2><p id="u0af4acf7" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1660632598192-4b5203c9-b02e-4277-bdae-321bfb3bc173.png" width="1018" id="haE8A" class="ne-image"></p><pre><code>const authorInfo = localStorage.getItem('LOGIN_USER')  ? JSON.parse(localStorage.getItem('LOGIN_USER') as string)  : null;</code></pre><h2 id="Mf6k2"><span class="ne-text">TS2307: 【找不到模块】或【ts导入js文件】</span></h2><div class="ne-quote"><p id="u75fe1cc9" class="ne-p"><span class="ne-text">可以归为一类问题，都是导入非ts模块 而报错，而ts的编译是需要有声明类型的</span></p></div><p id="ua6da90e1" class="ne-p"><span class="ne-text">这类报错一般有如下两种情况：</span></p><ol class="ne-ol"><li id="ua5deb70d"><span class="ne-text">import导入依赖包，但是提示找不到该包</span></li><li id="u688ca3e4"><span class="ne-text">ts文件中导入js文件</span></li></ol><p id="u07a5d9a7" class="ne-p"><span class="ne-text">原因：</span></p><ol class="ne-ol"><li id="u13a96ef4"><span class="ne-text">依赖包没有做ts化，没有声明文件，或者说暴露出来的接口，import不支持</span></li><li id="ubdd854de"><span class="ne-text">ts不能导入js，除非做一些配置文件的相关配置（但是尽量不要在ts项目存在js项目）</span></li></ol><p id="u700e1cdb" class="ne-p"><span class="ne-text">解决：</span></p><ul class="ne-ul"><li id="uc836f6e5"><span class="ne-text">国际化网站下载下来的是js文件，但是vite项目不能使用require来导入外部文件</span></li></ul><p id="u32bdd5fb" class="ne-p"><a href="https://www.cnblogs.com/fqh123/p/15820329.html" data-href="https://www.cnblogs.com/fqh123/p/15820329.html" class="ne-link"><span class="ne-text" style="text-decoration: line-through">vite无法使用require的替代方案 - 古墩古墩 - 博客园</span></a><span class="ne-text" style="text-decoration: line-through">，api已废弃</span></p><ul class="ne-tl"><li checked="true" id="u2557d297"><span class="ne-text">解决方法1：（无伤解决方法）类似声明非ts项目依赖一样，单独声明再使用（</span><a href="https://www.cnblogs.com/Blod/p/16185788.html" data-href="https://www.cnblogs.com/Blod/p/16185788.html" class="ne-link"><span class="ne-text">在ts中怎么引入js文件 - 冰中焱 - 博客园</span></a><span class="ne-text">）</span></li></ul><p id="u4d870acd" class="ne-p"><span class="ne-text">en.d.ts中添加</span></p><pre><code>···declare module '@/i18n/lang/zh.js';declare module '@/i18n/lang/en.js';···</code></pre><p id="uf566735f" class="ne-p"><span class="ne-text">然后再ts文件中直接导入使用即可</span></p><pre><code>import zh from '@/i18n/lang/zh.js';import en from '@/i18n/lang/en.js';···</code></pre><ul class="ne-ul"><li id="ufc211982"><span class="ne-text">解决方法2：直接在tsconfig中配置可以使用js的配置项，但是需要单独添加ts编译后的js目录，改动较大</span></li></ul><div class="ne-quote"><ul class="ne-ul"><li id="u5e51fc86"><a href="https://segmentfault.com/q/1010000019980246" data-href="https://segmentfault.com/q/1010000019980246" class="ne-link"><span class="ne-text">tsconfig.json 报错 无法写错写入文件 ，因为他会覆盖输入文件是怎么回事？ - SegmentFault 思否</span></a></li><li id="u2c7f8371"><a href="https://juejin.cn/post/6844904127131025416" data-href="https://juejin.cn/post/6844904127131025416" class="ne-link"><span class="ne-text">ts引用js文件（node包/自己写的文件） - 掘金</span></a></li></ul></div><h2 id="tT4L5"><span class="ne-text" style="color: rgb(77, 77, 77); font-size: 16px">TS2339: </span><span class="ne-text">Property 'replaceAll' does not exist on type 'string'</span></h2><ul class="ne-ul"><li id="uc593baff"><span class="ne-text">ts不能使用js中String的内置API：replaceAll方法</span></li><li id="u5431a587"><span class="ne-text">使用其他字符串api来达到该目的，</span><a href="https://stackoverflow.com/questions/63616486/property-replaceall-does-not-exist-on-type-string" data-href="https://stackoverflow.com/questions/63616486/property-replaceall-does-not-exist-on-type-string" target="_blank" class="ne-link"><span class="ne-text">https://stackoverflow.com/questions/63616486/property-replaceall-does-not-exist-on-type-string</span></a><span class="ne-text">，不推荐使用该方法</span></li></ul><ul class="ne-tl"><li checked="true" id="u8475e55e"><span class="ne-text">解决方法：默认 TypeScript 不支持某些 es6 polyfill 函数，在tsconfig.json配置中进行配置新版本的js语法</span></li></ul><pre><code>&#123;  ...,  &quot;compilerOptions&quot;: &#123;    ...,  &quot;lib&quot;: [    ...,  &quot;ES2021.String&quot;  ]&#125;&#125;</code></pre><h2 id="A8Glh"><span class="ne-text">TS2589: Type instantiation is excessively deep and possibly infinite.</span></h2><ul class="ne-tl"><li id="ub9e33958"><strong><span class="ne-text" style="color: #E8323C"></span></strong><span class="ne-text">如果使用js文件导入，那么在ts文件中使用就会报ts 2589错误。</span></li></ul><pre><code>src/utils/fetch.ts:63:55 - error TS2589: Type instantiation is excessively deep and possibly infinite.<p>63       message<a href="i18n.global.t(msg)">response.config.warnType as NoticeType</a>;<br></code></pre></p><p id="ueab1ee74" class="ne-p"><span class="ne-text">使用如下方式导入js导出来的js和json数据</span></p><pre><code>import &#123; createI18n &#125; from 'vue-i18n';import config from './config.json';import zh from '@/i18n/lang/zh.js';import en from '@/i18n/lang/en.js';import &#123; ref &#125; from 'vue';<p>let zh_obj = &#123;&#125;;<br>zh_obj = zh;<br>let en_obj = &#123;&#125;;<br>en_obj = en;<br>export const lang = ref(‘zh_obj’);</p><p>export const languages = config;</p><p>const i18n = createI18n(&#123;<br>  locale: lang.value,<br>  fallbackLocale: lang.value,<br>  messages: &#123;<br>    zh_obj,<br>    en_obj<br>  &#125;<br>&#125;);</p><p>export default i18n;<br></code></pre></p></div>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
          <category> JavaScript </category>
          
          <category> TypeScript </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>诺兰『蝙蝠侠』三部曲</title>
      <link href="/essay/lr2r4p/"/>
      <url>/essay/lr2r4p/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="ud0b8a1c9" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1659258590527-a4ac7156-1a4c-494f-8480-9609de27e2c6.png" width="1139.259339739435" id="uc1f00cef" class="ne-image"></p><h4 id="AZQqk"><span class="ne-text">恐惧继而愤怒</span></h4><p id="u8e0b4d48" class="ne-p"><span class="ne-text">害怕的事物终究成为自我救赎的武器</span></p><p id="u3c9b937f" class="ne-p"><span class="ne-text">害怕黑暗与黑暗中的蝙蝠，害怕所带来的恐惧与懦弱</span></p><p id="u833ac2f1" class="ne-p"><span class="ne-text">一个人越害怕一件事情，这件事情往往会再现自己的身边</span></p><p id="ua567b001" class="ne-p"><span class="ne-text">只不过对于布鲁斯·韦恩，这个失去的东西太沉重</span></p><p id="ua4be8f15" class="ne-p"><span class="ne-text">于是带着自责与愤怒逃离那个错误的城市···</span></p><p id="ua1b2d4ff" class="ne-p"><span class="ne-text"></span></p><h4 id="GwlsN"><span class="ne-text">愤怒但非犯罪</span></h4><p id="u9bf106bf" class="ne-p"><span class="ne-text">秉承着 惧怕驱使你行善或作恶的动力 信念的影武者联盟</span></p><p id="u045841c1" class="ne-p"><span class="ne-text">消除了内心的恐惧</span></p><p id="ub502277c" class="ne-p"><span class="ne-text">但是消除并不等于黑化</span></p><p id="uaa843634" class="ne-p"><span class="ne-text">于是误入歧途的前一刻坚守自己认为对的事情···</span></p><p id="u67bf7b28" class="ne-p"><span class="ne-text"></span></p><h4 id="vqGFP"><span class="ne-text">侠影与得失</span></h4><p id="uc99c173d" class="ne-p"><span class="ne-text">用一己之力纠正那些不对的事</span></p><p id="u3ff1b640" class="ne-p"><span class="ne-text">当认定要做一些常人难以做成的事情</span></p><p id="u913e6cd7" class="ne-p"><span class="ne-text">就势必会失去一些已有的事物，比如感情与名望···</span></p><p id="u0a14c2c5" class="ne-p"><span class="ne-text"></span></p><h4 id="RrHQ4"><span class="ne-text">原则</span></h4><p id="ud66d9e8b" class="ne-p"><span class="ne-text">世上所有的反派都不及一个精神病患者</span></p><p id="u783c4a39" class="ne-p"><span class="ne-text">人才辈出阿卡姆就有这么一个人才</span></p><p id="u0186c38b" class="ne-p"><span class="ne-text">什么都不想要，只想要毁灭，只仇视所谓正义的秩序者</span></p><p id="uc880c0d5" class="ne-p"><span class="ne-text">众所周知，疯子和天才只有一线之隔</span></p><p id="ua8d05fb3" class="ne-p"><span class="ne-text">小丑最擅长的就是拿捏人性，而且是每次都成功拿捏人性中的暗</span></p><p id="uf90a1a98" class="ne-p"><span class="ne-text">所以小丑所设计的几个犯罪案例都是结合人性的超高智商案例</span></p><p id="u0ff2b39e" class="ne-p"><span class="ne-text">小丑和蝙蝠侠都是同类人</span></p><p id="u1ca4d347" class="ne-p"><span class="ne-text">造成这个不同的结果就是小时候的教育···</span></p><p id="u57861ea6" class="ne-p"><span class="ne-text">所以与其说这是蝙蝠侠与小丑或是正义与邪恶之间的较量</span></p><p id="u7cfb9084" class="ne-p"><span class="ne-text">不如说是人性的光与暗之间的碰撞</span></p><p id="ue3e3804c" class="ne-p"><span class="ne-text"></span></p><h4 id="ARbHF"><span class="ne-text">黑暗骑士——无名</span></h4><p id="ue3faa0f9" class="ne-p"><span class="ne-text">最高光最封神的就是第二部中蝙蝠侠与戈登最后的对话</span></p><div class="ne-quote"><p id="u426a0640" class="ne-p"><span class="ne-text">要么舍生取义、流芳百世</span></p><p id="u11d91de1" class="ne-p"><span class="ne-text">要么苟活到目睹自己被逼成恶棍</span></p><p id="uba08d3ec" class="ne-p"><span class="ne-text">把这些事算到我头上</span></p><p id="ub8294670" class="ne-p"><span class="ne-text">因为我不是英雄 不像丹特</span></p><p id="ue45b20a3" class="ne-p"><span class="ne-text">我可以背负杀死他们的罪名</span></p><p id="ua99b18c2" class="ne-p"><span class="ne-text">哥谭需要我是什么样的 我就是什么样的</span></p></div><p id="u78c6401e" class="ne-p"><span class="ne-text">行走在黑暗中的骑士，从来都不需要流芳百世</span></p><p id="ub69ea752" class="ne-p"><span class="ne-text">背负诋毁与罪名，让人们生活在光明且充满希望的世界···</span></p><p id="uf8c20e54" class="ne-p"><span class="ne-text"></span></p><h4 id="T0wSf"><span class="ne-text">崛起</span></h4><p id="u185ccb90" class="ne-p"><span class="ne-text">蝙蝠侠崛起的不是布鲁斯·韦恩，而是蝙蝠侠这种侠影精神</span></p><p id="u6de2757b" class="ne-p"><span class="ne-text">最后的罗宾来到蝙蝠洞就证明这一点</span></p><p id="u1b3ec18e" class="ne-p"><span class="ne-text">英雄谢幕退场到原点，后来者继上···</span></p><p id="u6cf9a49d" class="ne-p"><span class="ne-text"></span></p><p id="ub842d2d1" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/1484158/1659258039316-a9a813e2-6189-439d-84f2-16980eabae9a.jpeg" width="2400" id="MrsZD" class="ne-image"></p><p id="uda87b3d3" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/1484158/1659258040513-acdc8cbd-0d02-441f-a5c5-e685e7b96a83.jpeg" width="2400" id="ovmsC" class="ne-image"></p><p id="uc410fc3e" class="ne-p"><br></p></div>]]></content>
      
      
      <categories>
          
          <category> 影视 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript实现并发控制且指定并发上限为concurrency</title>
      <link href="/blog/wboxcq/"/>
      <url>/blog/wboxcq/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="u5db88ede" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1658750399274-d7c6f4fd-a9ce-4f10-a771-b9567b84830d.png" width="255.5555736086509" id="u9eff5b76" class="ne-image"></p><p id="u336780ef" class="ne-p"><span class="ne-text">前言：使用Typescript编写如下函数功能 并发控制函数 要求控制任务执行的并发上限为concurrency</span></p><p id="ua4fed787" class="ne-p"><span class="ne-text"></span></p><pre><code>/* * @Author: wztlink1013 * @Date: 2022-07-25 19:57:09 * @LastEditTime: 2022-07-25 19:57:22 * @Description: */// Practice 1const test_1 = () =&gt; &#123;  return new Promise(resolve =&gt; &#123;    setTimeout(() =&gt; &#123;      console.log('2000')      let myDate = new Date()      console.log('---- ', myDate.toTimeString().substring(0, 8), ' ----')      resolve(2000)    &#125;, 2000)  &#125;)&#125;const test_2 = () =&gt; &#123;  return new Promise(resolve =&gt; &#123;    setTimeout(() =&gt; &#123;      console.log('3000')      let myDate = new Date()      console.log('---- ', myDate.toTimeString().substring(0, 8), ' ----')      resolve(3000)    &#125;, 3000)  &#125;)&#125;const test_3 = () =&gt; &#123;  return new Promise(resolve =&gt; &#123;    setTimeout(() =&gt; &#123;      console.log('4000')      let myDate = new Date()      console.log('---- ', myDate.toTimeString().substring(0, 8), ' ----')      resolve(4000)    &#125;, 4000)  &#125;)&#125;<p>let arr = [test_1, test_2, test_3]</p><p>async function parallel(<br>  tasks: (() =&gt; void)[],<br>  concurrency: number<br>): Promise&lt;void&gt; &#123;<br>  const ret: any[] = []<br>  const executing: any[] = []</p><p>  let myDate = new Date()<br>  console.log(‘—-start ‘, myDate.toTimeString().substring(0, 8), ‘ —-‘)</p><p>  for (const item of tasks) &#123;<br>    const p = Promise.resolve().then(item)<br>    ret.push(p)</p><pre><code>if (concurrency &amp;lt;= tasks.length) &#123;  const e: any = p.then(() =&amp;gt; executing.splice(executing.indexOf(e), 1))  executing.push(e)  if (executing.length &amp;gt;= concurrency) &#123;    await Promise.race(executing)  &#125;&#125;</code></pre><p>  }<br>  // return Promise.all(ret);<br>}<br>parallel(arr, 2)<br></code></pre></p><h2 id="lXmLO"><span class="ne-text">参考：</span></h2><ul class="ne-ul"><li id="u6fd14527"><a href="https://juejin.cn/post/6976028030770610213" data-href="https://juejin.cn/post/6976028030770610213" class="ne-link"><span class="ne-text">JavaScript 中如何实现并发控制？ - 掘金</span></a></li></ul></div>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
          <category> JavaScript </category>
          
          <category> ECMAScript </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>滚动穿透：抽屉层下的DOM跟随滚动</title>
      <link href="/blog/wwclae/"/>
      <url>/blog/wwclae/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="u10d9e989" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1665141885929-afd0c3cb-bdd4-4e82-95b3-8b6d2f7964b5.png" width="696.6666389836216" id="ubd08e735" class="ne-image"></p><p id="u46c516f8" class="ne-p"><span class="ne-text">前言：对网站做移动端适配，点击左上角弹出抽屉布局，其实现为fixed绝对定位，对其进行鼠标的上下滚动会造成抽屉层下面的dom元素也随之滚动，本文目的旨在解决该</span><strong><span class="ne-text">滚动穿透</span></strong><span class="ne-text">问题。</span></p><p id="u9432b897" class="ne-p"><span class="ne-text"></span></p><p id="u22e19627" class="ne-p"><span class="ne-text">思路</span></p><ul class="ne-ul"><li id="ub7820cc9"><span class="ne-text">网上思路较多，鼠标滚动也好，手指滑动也好，都属于Event事件，而后抽屉弹出禁用底部dom的默认事件思路，该思路可行，不过有点大材小用。</span></li></ul><ul class="ne-tl"><li checked="true" id="uf52d49e9"><span class="ne-text">只利用css解决该问题，当抽屉弹出，记录</span><code class="ne-code"><span class="ne-text">window.scrollY</span></code><span class="ne-text">的值，同时对底部dom进行绝对定位，当抽屉层关闭，底部dom清楚绝对定位及其相关属性，并且跳转刚刚记录的</span><code class="ne-code"><span class="ne-text">window.scrollY</span></code><span class="ne-text">值。部分代码如下：</span></li></ul><pre><code>let top = 0;// 点击左按钮btn_app_sider.click(function () &#123;  app_side_glass.css(&#123; display: &quot;block&quot; &#125;);  app_side_content.css(&#123; display: &quot;block&quot; &#125;);  // 阻止抽屉层下的滑动穿透  top = window.scrollY;  container.css(&#123; position: &quot;fixed&quot;, top: -top + &quot;px&quot; &#125;);&#125;);// 点击毛玻璃片app_side_glass.click(function () &#123;  app_side_glass.css(&#123; display: &quot;none&quot; &#125;);  app_side_content.css(&#123; display: &quot;none&quot; &#125;);  // 阻止抽屉层下的滑动穿透  container.css(&#123; position: &quot;&quot;, top: &quot;&quot; &#125;);  window.scrollTo(0, top);&#125;);</code></pre></div>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
          <category> HTML+CSS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>系统对比学习Vue2和Vue3</title>
      <link href="/blog/wg5n0g/"/>
      <url>/blog/wg5n0g/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="u5fc1e207" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1662219960321-86e09edc-e993-4ce0-88db-bebea0da263e.png" width="1507.4999400973343" id="u6d2cb89a" class="ne-image"></p><p id="u7483d19f" class="ne-p"><span class="ne-text"></span></p><p id="u3bbb6074" class="ne-p"><span class="ne-text">前言：对Vue3的初次接触是使用Vue3（</span><a href="https://cn.vuejs.org/" data-href="https://cn.vuejs.org/" class="ne-link"><span class="ne-text">Vue.js - 渐进式 JavaScript 框架 | Vue.js</span></a><span class="ne-text">）的 </span><a href="https://cn.vuejs.org/guide/introduction.html#api-styles" data-href="https://cn.vuejs.org/guide/introduction.html#api-styles" target="_blank" class="ne-link"><span class="ne-text">组合式API</span></a><span class="ne-text"> 编程风格来进行Vue2旧项目的重构。</span></p><p id="uf30994f1" class="ne-p"><br></p><p id="u11b5af03" class="ne-p"><span class="ne-text" style="color: rgb(36, 41, 47); font-size: 14px">基础变动：</span></p><ul class="ne-ul"><li id="u3d084571" data-lake-index-type="0"><span class="ne-text" style="color: rgb(36, 41, 47); font-size: 14px">setup语法糖 Vue3.2之后才能放到script里面</span></li><li id="u89b82f0b" data-lake-index-type="0"><span class="ne-text" style="color: rgb(36, 41, 47); font-size: 14px">data methods 都不再需要，也不再需要return出变量或是函数</span></li><li id="uec5a4d8c" data-lake-index-type="0"><span class="ne-text" style="color: rgb(36, 41, 47); font-size: 14px">路由相关知识，只注意</span><span class="ne-text" style="color: rgb(36, 41, 47); font-size: 12px">useRoute()</span><span class="ne-text" style="color: rgb(36, 41, 47); font-size: 14px"> </span><span class="ne-text" style="color: rgb(36, 41, 47); font-size: 12px">useRouter()</span><span class="ne-text" style="color: rgb(36, 41, 47); font-size: 14px">其余的，和之前自己写的lyrics前端路由就够用了</span></li><li id="u5e17a00e" data-lake-index-type="0"><span class="ne-text" style="color: rgb(36, 41, 47); font-size: 14px">Vue3 异步编程</span></li><li id="u46903163" data-lake-index-type="0"><span class="ne-text" style="color: rgb(36, 41, 47); font-size: 14px">provide 和 inject</span></li><li id="u4a3c5f1e" data-lake-index-type="0"><span class="ne-text" style="color: rgb(36, 41, 47); font-size: 14px">······</span></li></ul><p id="u642b3074" class="ne-p"><span class="ne-text">语法转换过程中，主要分几个大块：</span></p><ul class="ne-ul"><li id="u4a49a6cf" data-lake-index-type="0"><span class="ne-text">语法：框架自行的一些语法迁移（官网里面的</span><strong><span class="ne-text">基础</span></strong><span class="ne-text">）</span></li><li id="u3fb0af83" data-lake-index-type="0"><span class="ne-text">组件相关：尤其是组件之间的各类通信方式，以及封装组件的传参等，单独一篇文章总结。</span></li><li id="uca31ce98" data-lake-index-type="0"><span class="ne-text">编程风格/封装相关</span></li><li id="u9590c6a0" data-lake-index-type="0"><span class="ne-text">······</span></li></ul><h2 id="sXl99"><span class="ne-text">data</span></h2><h3 id="opEG9"><span class="ne-text">非响应式数据</span></h3><p id="uf7a0ca1e" class="ne-p"><span class="ne-text">需要注意的是，</span><strong><span class="ne-text">不是所有的数据都需要定义为响应的。</span></strong><span class="ne-text">比如SDK。</span></p><h3 id="u5iUn"><span class="ne-text">响应数据</span></h3><h4 id="Mp2Px"><span class="ne-text">ref</span></h4><pre><code><code>&lt;template&gt;  &lt;a-modal    v-model:visible=&quot;visible&quot;、    ···    &gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot;&gt;import &#123;ref&#125; from 'vue'const visible = ref&lt;boolean&gt;(false)&lt;/script&gt;</code></code></pre><h4 id="Q3CuW"><span class="ne-text">reactive</span></h4><p id="u6466c8ca" class="ne-p"><span class="ne-text">reactive这个更多使用在对象和数组类型的响应式定义数据，因为在vue2中，对于数组和对象是不能够完美响应式的，需要watch来监听实现，而在vue3中，以此作为优化来定义响应式数据。</span></p><p id="u3a6d13e2" class="ne-p"><span class="ne-text">但是直接使用ref也可以定义响应式数组或对象数据</span></p><ul class="ne-tl"><li checked="true" id="u0e7fb17d" data-lake-index-type="0"><span class="ne-text">reactive定义的数组不能实时渲染，用ref就完事了</span></li></ul><p id="uc2bb26ea" class="ne-p"><a href="https://blog.csdn.net/m0_46527751/article/details/124957269" data-href="https://blog.csdn.net/m0_46527751/article/details/124957269" class="ne-link"><span class="ne-text">Vue3异步请求获取数据在渲染时不显示的问题_s－010101的博客-CSDN博客_vue异步请求数据没渲染</span></a></p><p id="u1db3fe11" class="ne-p"><span class="ne-text">并不是生命周期的问题，而是数据定义的问题</span></p><p id="ubd0005f8" class="ne-p"><span class="ne-text">除了上述两种方式解决办法，还可以使用ts语法，接口，参照antdv中的表单相关实例代码</span></p><ul class="ne-tl"><li id="ua1955014" data-lake-index-type="0"><span class="ne-text">reactive不能渲染，更新名称子组件不能渲染</span></li><li checked="true" id="u984ead1f" data-lake-index-type="0"><span class="ne-text">FIXME: 重命名组件中，输入框值变化不能响应式</span></li></ul><p id="ua93986ed" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1661150516722-4068bc1d-d2e0-4f0c-ba9c-ee0970b4963c.png" width="265.9921875" id="lQR6v" class="ne-image"><span class="ne-text">同时对数据定义用ref不用reactive</span></p><ul class="ne-tl"><li id="ubbbdc775" data-lake-index-type="0"><a href="https://segmentfault.com/q/1010000039940940" data-href="https://segmentfault.com/q/1010000039940940" target="_blank" class="ne-link"><span class="ne-text">vue3中的reactive对象赋值问题</span></a></li></ul><h4 id="A8n7C"><span class="ne-text">如何在setup中使用data中的数据库？</span></h4><p id="u3c93ad52" class="ne-p"><span class="ne-text">在选项式的vue3代码中：</span></p><p id="ud3222ed5" class="ne-p"><span class="ne-text">按照以前vue2，直接使用this可以访问到data中定义的数据，但在vue3不行，因为setup()函数的执行要比created，oncrated函数都要早。</span></p><p id="u34d7ae55" class="ne-p"><span class="ne-text">具体使用以下小技巧可以访问到：</span></p><pre><code><code>&lt;div v-on:click=&quot;fun(testdata)&quot;&gt;&lt;/div&gt;<p>setup()&#123;<br>  const  fun=(i)=&gt;&#123;<br>    alert(i)<br>  &#125;<br>&#125;,<br>data()&#123;<br>  return&#123;<br>    testdata:1,<br>  &#125;<br>&#125;</code><br></code></pre></p><p id="u67e03fdc" class="ne-p"><span class="ne-text">也可以使用getCurrentInstance方法获取data内的数据</span><strong><span class="ne-text" style="color: #E8323C">（未验证）</span></strong></p><pre><code><code>&lt;script lang=&quot;ts&quot;&gt;import &#123; getCurrentInstance &#125; from &quot;vue&quot;;export default &#123;  data() &#123;    return &#123;      b: &quot;data数据&quot;,    &#125;;  &#125;,  setup() &#123;    const datab = getCurrentInstance();    async function getdata()&#123;        let dataa=datab.data.b;        console.log(dataa)    &#125;  &#125;,&#125;;&lt;/script&gt;</code></code></pre><h2 id="u0Iol"><span class="ne-text">computed，watch，methods</span></h2><h3 id="S2h2L"><span class="ne-text">三者对比</span></h3><p id="u7dfc51e9" class="ne-p"><span class="ne-text">计算属性（computed）和方法（methods）的区别</span></p><ul class="ne-ul"><li id="u15ab7bec" data-lake-index-type="0"><span class="ne-text">计算属性是基于他们的依赖来进行缓存的</span></li></ul><p id="u7ae90c12" class="ne-p"><span class="ne-text">“他们的依赖”指的是data数据域中的data数据，如果其变动，计算属性值才会变</span></p><ul class="ne-ul"><li id="u424a9f75" data-lake-index-type="0"><span class="ne-text">方法不存在缓存</span></li></ul><p id="u9a1a5ffb" class="ne-p"><span class="ne-text">计算属性（computed）和侦听器（watch）的使用</span></p><ul class="ne-ul"><li id="u029e3984" data-lake-index-type="0"><span class="ne-text">侦听器更用于异步或是开销较大的操作</span></li></ul><h3 id="b1d999af"><span class="ne-text">watch（侦听器）+computed（计算属性）+watchEffect</span></h3><ul class="ne-ul"><li id="u218599f2" data-lake-index-type="0"><span class="ne-text">watchEffect：只要在该函数引用声明式变量，那么就会执行该函数</span></li></ul><div class="ne-quote"><p id="ub95ff445" class="ne-p"><span class="ne-text">为了根据响应式状态自动应用和重新应用副作用，我们可以使用 watchEffect 函数。它立即执行传入的一个函数，同时响应式追踪其依赖，并在其依赖变更时重新运行该函数。</span></p></div><ul class="ne-ul"><li id="u39565fb8" data-lake-index-type="0"><span class="ne-text">watch：vue2中监听新值和旧值的一样使用（ref reactive 各有不同）</span></li><li id="uf22eca5e" data-lake-index-type="0"><span class="ne-text">computed </span></li></ul><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="u4b2042e5" data-lake-index-type="0"><span class="ne-text">注意Vue computed 的类型声明方式https://bytenote.net/article/121073339505573889 </span><a href="https://v3.cn.vuejs.org/api/computed-watch-api.html#computed" data-href="https://v3.cn.vuejs.org/api/computed-watch-api.html#computed" target="_blank" class="ne-link"><span class="ne-text">https://v3.cn.vuejs.org/api/computed-watch-api.html#computed</span></a></li><li id="u393ac6e2" data-lake-index-type="0"><span class="ne-text">不确定暂时先用any</span></li></ul></ul><ul class="ne-ul"><li id="u9c90f99c" data-lake-index-type="0"><span class="ne-text">动态监听数组，返回的新值打印出来都是数组元素逗号隔开，因为监听的是内部每一个数组元素</span></li></ul><details class="lake-collapse"><summary id="u0887aed0"><span class="ne-text">test code</span></summary><pre><code><code>&lt;template&gt;  &lt;button type=&quot;button&quot; @click=&quot;count++&quot;&gt;[watch watchEffect]ref 定义的 count is: &#123;&#123; count &#125;&#125;&lt;/button&gt;&lt;hr/&gt;  &lt;button type=&quot;button&quot; @click=&quot;numbers[0]++&quot;&gt;[watch watchEffect]reactive 定义的 numbers is: &#123;&#123; numbers &#125;&#125;&lt;/button&gt;&lt;hr/&gt;  &lt;button type=&quot;button&quot; &gt;[computed]ref 定义的 person_ref is: &#123;&#123; person_ref &#125;&#125;&lt;/button&gt;&lt;hr/&gt;  &lt;button type=&quot;button&quot; &gt;[computed]reactive 定义的 person_reactive is: &#123;&#123; person_reactive &#125;&#125;&lt;/button&gt;&lt;hr/&gt;  &lt;span&gt;动态参数绑定：&lt;/span&gt;&lt;a :href=&quot;getHrefValue()&quot;&gt;&#123;&#123;getHrefValue()&#125;&#125;&lt;/a&gt;&lt;hr/&gt;<p>&lt;/template&gt;</p><p>&lt;script setup lang=&quot;ts&quot;&gt;<br>import &#123; ref, watchEffect, watch, reactive, computed, Ref &#125; from ‘vue’</p><p>const count = ref(0)<br>const numbers = reactive([1, 2, 3, 4])<br>let person_ref = ref(‘wuzutao’)<br>let person_reactive = reactive(&#123;firstName:’wu’, lastName:’zutao’, fullName: ‘wu-zutao’&#125;)</p><p>let getHrefValue = () =&gt; &#123;<br>    return ‘<a href="http://www.wztlink1013.com&/#39;">www.wztlink1013.com&#39;</a><br>&#125;</p><p>// [watchEffect ref reactive]<br>watchEffect(()=&gt;&#123;<br>  const x1 = count.value<br>  const x2 = numbers[0]<br>  console.log(‘因为watchEffect里面调用了count/numbers[0] 所以watchEffect所指定的回调执行了’, x1, x2)<br>&#125;)<br>// [watch ref]<br>watch(count, (count, prevCount) =&gt; &#123;<br>    console.log(‘新值’, count)<br>    console.log(‘旧值’, prevCount)<br>&#125;)<br>// [watch reactive]<br>watch(<br>  () =&gt; […numbers],<br>  (numbers, prevNumbers) =&gt; &#123;<br>    console.log(‘numbers新值’,numbers)<br>    console.log(‘numbers旧值’,prevNumbers)<br>  &#125;<br>)<br>// [computed ref]<br>// const computed_ref = computed(() =&gt; &#123; // 简单式<br>//     person_ref.value = person_ref.value + ‘+’<br>// &#125;)<br>const computed_ref = computed&lt;any&gt;(&#123; // 复合式<br>  get: () =&gt; &#123;<br>    console.log(‘[ref]使用(get)该变量,就会调用’)<br>  &#125;,<br>  set: (val) =&gt; &#123;<br>    console.log(‘[ref]改变(set)该变量,就会调用’)<br>    person_ref.value = val + ‘-内部处理值-原始值’ + person_ref.value<br>  &#125;<br>&#125;)<br>// console.log(computed_ref.value) // 会打印undefined因为上面的get没有传参<br>computed_ref.value = ‘修改的目的值’</p><p>// [computed reactive]<br>// person[‘firstName’] = computed(()=&gt;&#123;<br>//     return person.firstName + ‘-‘ + person.lastName<br>//     &#125;)<br> const computed_reactive= computed&lt;any&gt;(&#123; // 完整写法<br>    get()&#123;<br>        // return person_reactive.firstName + ‘-‘ + person_reactive.lastName<br>        console.log(‘[reactive]使用(get)该变量,就会调用’)<br>    &#125;,<br>    set(value)&#123;<br>        console.log(‘[reactive]改变(set)该变量,就会调用’)<br>        const nameArr = value.split(‘-‘)<br>        person_reactive.fullName = value<br>        person_reactive.firstName = nameArr[0]<br>        person_reactive.lastName = nameArr[1]<br>    &#125;<br>&#125;)<br>computed_reactive.value = ‘wu+-zutao+’<br>&lt;/script&gt;</p><p>&lt;style scoped&gt;<br>a &#123;<br>  color: #42b983;<br>&#125;</p><p>label &#123;<br>  margin: 0 0.5em;<br>  font-weight: bold;<br>&#125;</p><p>code &#123;<br>  background-color: #eee;<br>  padding: 2px 4px;<br>  border-radius: 4px;<br>  color: #304455;<br>&#125;<br>&lt;/style&gt;</code><br></code></pre></p></details><h3 id="KW8mQ"><span class="ne-text">Vue2中侦听器(watch)注意事项</span></h3><ul class="ne-ul"><li id="u4800cbab" data-lake-index-type="0"><span class="ne-text">当监听的数据不是一个简单的基本类型，比如一个对象，一个数组，此时应该使用深度监听：deep:true；当想让监听器一启动就触发一次watch，应该使用： immediate: true。</span></li></ul><div class="ne-quote"><p id="ub31b8966" class="ne-p"><span class="ne-text">直接</span><code class="ne-code"><span class="ne-text">watch</span></code><span class="ne-text">监听对象内的是检测不到变化的，因为对象的指向并没有发生改变。Vue中的watch监听对象内属性的变动方案</span></p></div><h4 id="U7lp1"><span class="ne-text">使用deep属性</span></h4><pre><code><code>new Vue(&#123;  data: &#123;    count: 10，    blog:&#123;        title:'my-blog',        categories:[]    &#125;  &#125;,  watch: &#123;    blog:&#123;        handler(newVal,oldVal)&#123;            console.log(`new: $&#123;newVal&#125;, old: $&#123;oldVal&#125;`);        &#125;,    deep:true    &#125;  &#125;&#125;)</code></code></pre><p id="uc92302d5" class="ne-p"><span class="ne-text">里面的</span><code class="ne-code"><span class="ne-text">deep</span></code><span class="ne-text">设为了</span><code class="ne-code"><span class="ne-text">true</span></code><span class="ne-text">，这样的话，如果修改了这个</span><code class="ne-code"><span class="ne-text">blog</span></code><span class="ne-text">中的任何一个属性，都会执行</span><code class="ne-code"><span class="ne-text">handler</span></code><span class="ne-text">这个方法。不过这样会造成更多的性能开销，尤其是对象里面属性过多，结构嵌套过深的时候。而且有时候我们就只想关心这个对象中的某个特定属性，这个时候可以这样</span></p><h4 id="F2YBm"><span class="ne-text">用字符串来表示对象的属性调用</span></h4><pre><code><code>new Vue(&#123;  data: &#123;    count: 10，    blog:&#123;        title:'my-blog',        categories:[]    &#125;  &#125;,  watch: &#123;    'blog.categories'(newVal, oldVal) &#123;        console.log(`new:$&#123;newVal&#125;, old:$&#123;oldVal&#125;`);    &#125;,   &#125;&#125;)</code></code></pre><h4 id="aAOEA"><span class="ne-text">使用计算属性(computed)</span></h4><pre><code><code>new Vue(&#123;  data: &#123;    count: 10，    blog:&#123;        title:'my-blog',        categories:[]    &#125;  &#125;,  computed: &#123;    categories() &#123;      return this.blog.categories;    &#125;  &#125;,  watch: &#123;    categories(newVal, oldVal) &#123;      console.log(`new:$&#123;newVal&#125;, old:$&#123;oldVal&#125;`);    &#125;,   &#125;,&#125;)</code></code></pre><p id="u7e9d13d4" class="ne-p"><span class="ne-text">参考：</span><a href="https://segmentfault.com/a/1190000018080301" data-href="https://segmentfault.com/a/1190000018080301" target="_blank" class="ne-link"><span class="ne-text">https://segmentfault.com/a/1190000018080301</span></a></p><h2 id="uWCZt"><span class="ne-text">生命周期</span></h2><h3 id="B9ytB"><span class="ne-text">Vue2</span></h3><p id="uf12bf80a" class="ne-p" style="text-align: center"><span class="ne-text" style="color: #DF2A3F">初始化实例时触发</span></p><div data-type="info" class="ne-alert"><ol class="ne-ol"><li id="u8832ae06" data-lake-index-type="0"><span class="ne-text">beforeCreate：在实例初始化之后，数据观测和事件配置之前被调用</span></li></ol><ol class="ne-list-wrap"><ol ne-level="1" class="ne-ol"><li id="ue05e8c4f" data-lake-index-type="0"><span class="ne-text">响应式数据没有，dom未渲染</span></li></ol></ol><ol start="2" class="ne-ol"><li id="u7f6830af" data-lake-index-type="0"><span class="ne-text">created：在实例创建完成后被立即调用</span></li></ol><ol class="ne-list-wrap"><ol ne-level="1" class="ne-ol"><li id="u0e07f7dc" data-lake-index-type="0"><span class="ne-text">响应式数据有了，dom未渲染</span></li><li id="u1f5037dc" data-lake-index-type="0"><span class="ne-text">一般在这里异步请求初始化数据</span></li></ol></ol><ol start="3" class="ne-ol"><li id="u363a87ca" data-lake-index-type="0"><span class="ne-text">beforeMount：在挂载开始之前被调用</span></li></ol><ol class="ne-list-wrap"><ol ne-level="1" class="ne-ol"><li id="u8a067a53" data-lake-index-type="0"><span class="ne-text">响应式数据有了，dom未渲染</span></li></ol></ol><ol start="4" class="ne-ol"><li id="u8c6e7b07" data-lake-index-type="0"><span class="ne-text">mounted：el被新创建的vm.$el替换，并挂载到实例上去之后调用该钩子</span></li></ol><ol class="ne-list-wrap"><ol ne-level="1" class="ne-ol"><li id="uf3e38c0f" data-lake-index-type="0"><span class="ne-text">响应式数据有了，dom已渲染</span></li></ol></ol></div><ol class="ne-ol"><li id="u0def781a" data-lake-index-type="0"><span class="ne-text">activated</span></li><li id="u8e3115bf" data-lake-index-type="0"><span class="ne-text">deactivated</span></li></ol><p id="u3f7db976" class="ne-p" style="text-align: center"><span class="ne-text" style="color: #DF2A3F">更新数据时触发</span></p><div data-type="color2" class="ne-alert"><ol class="ne-ol"><li id="ub431174c" data-lake-index-type="0"><span class="ne-text">beforeUpdate：数据更新时调用，发生在虚拟DOM打补丁之前</span></li></ol><ol class="ne-list-wrap"><ol ne-level="1" class="ne-ol"><li id="u2a02905d" data-lake-index-type="0"><span class="ne-text">响应式数据变了，但是dom还没有更新</span></li></ol></ol><ol start="2" class="ne-ol"><li id="ud4c52258" data-lake-index-type="0"><span class="ne-text">updated：由于数据更改导致的虚拟DOM重新渲染和打补丁，在这之后会调用该钩子</span></li></ol><ol class="ne-list-wrap"><ol ne-level="1" class="ne-ol"><li id="u42a956cc" data-lake-index-type="0"><span class="ne-text">响应式数据变了，dom也更新了</span></li></ol></ol></div><p id="u8beae034" class="ne-p" style="text-align: center"><span class="ne-text" style="color: #DF2A3F">卸载实例时触发</span></p><div data-type="warning" class="ne-alert"><ol class="ne-ol"><li id="u5cb6441c" data-lake-index-type="0"><span class="ne-text">beforeDestroy：实例销毁之前调用</span></li></ol><ol class="ne-list-wrap"><ol ne-level="1" class="ne-ol"><li id="ub43a905e" data-lake-index-type="0"><span class="ne-text">响应式数据还有，dom也有</span></li></ol></ol><ol start="2" class="ne-ol"><li id="ue81310ec" data-lake-index-type="0"><span class="ne-text">destroyed：实例销毁后调用</span></li></ol><ol class="ne-list-wrap"><ol ne-level="1" class="ne-ol"><li id="u3b003791" data-lake-index-type="0"><span class="ne-text">响应式数据还有，dom没了</span></li></ol></ol></div><ol class="ne-ol"><li id="u680f5266" data-lake-index-type="0"><span class="ne-text">errorCaptured</span></li><li id="u39e3f3c1" data-lake-index-type="0"><span class="ne-text">renderTracked</span></li><li id="u7b524366" data-lake-index-type="0"><span class="ne-text">renderTriggered</span></li></ol><h3 id="M0NdT"><span class="ne-text">Vue3</span></h3><p id="u52d56997" class="ne-p"><span class="ne-text">在Vue3组合式API的生命周期里面，没有created阶段了，直接在setup里面了，也就是setup阶段是没有挂载真实DOM的，如果需要操作真实dom需要在onMounetd里面进行相应逻辑</span></p><pre><code><code>onMounted(() =&gt; &#123;  if (document.getElementById('test')) &#123;    console.log('exist #test DOM...');  &#125;&#125;);</code></code></pre><pre><code><code>&lt;script&gt;  setup() &#123;    console.log('----setup第一个执行----')    // vue3.x生命周期写在setup中    onBeforeMount(() =&gt; &#123;      console.log('------vue3中onBeforeMount-----')    &#125;)    onMounted(() =&gt; &#123;      console.log('------vue3中onMounted-----')    &#125;)    onRenderTriggered((event) =&gt; &#123;      console.log('------vue3中onRenderTriggered-----', event)    &#125;)  &#125;,  // vue2当中的  beforeCreate() &#123;    console.log('----vue2中beforeCreate第二个执行----')  &#125;,  // vue2当中的  created() &#123;    console.log('----vue2中created第三个执行----')  &#125;,&lt;/script&gt;</code></code></pre><p id="u20c2d491" class="ne-p"><span class="ne-text">执行结果如下：</span></p><p id="u9c80ce3d" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1644646841871-0aaeece1-c5dd-493e-bbfc-41f52925931a.png" width="792" id="ue1197c21" class="ne-image"></p><h2 id="amOyt"><span class="ne-text">具体使用</span></h2><h3 id="EL5JT"><span class="ne-text">router和route区别及使用</span></h3><p id="u7abd5330" class="ne-p"><span class="ne-text"> </span><a href="https://juejin.cn/post/7116720209502683172" data-href="https://juejin.cn/post/7116720209502683172" class="ne-link"><span class="ne-text">vue3中的useRoute（）和useRouter()； - 掘金</span></a></p><h3 id="OSYBy"><span class="ne-text">Vue3中使用Async Await</span></h3><ul class="ne-ul"><li id="ue00b3b0d" data-lake-index-type="0"><span class="ne-text">vue3的setup本就是一个async</span><span class="ne-text" style="text-decoration: line-through">，所以可以直接使用await（不可以）</span></li><li id="u4e6107bb" data-lake-index-type="0"><a href="https://www.cnblogs.com/shiazhen/p/14986454.html" data-href="https://www.cnblogs.com/shiazhen/p/14986454.html" class="ne-link"><span class="ne-text">vue3.0 中 如何在setup中使用async await - 阿臻 - 博客园</span></a></li></ul><pre><code><code>const handleLoginOut = async () =&gt; &#123;  emit('wsClosed');  const &#123; ret &#125; = await logout();  if (ret &gt; -1) &#123;    localStorage.clear();    onRedirect();  &#125;&#125;;</code></code></pre><h3 id="KYiG2"><span class="ne-text">emit使用</span></h3><ul class="ne-ul"><li id="ubc4be53c" data-lake-index-type="0"><a href="https://segmentfault.com/a/1190000041054210" data-href="https://segmentfault.com/a/1190000041054210" class="ne-link"><span class="ne-text">vue3 setup使用emit</span></a></li></ul><p id="u52cd0197" class="ne-p" style="text-align: left"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1660633907664-aa2576f8-129c-45e4-a747-0f5ce9f765cf.png" width="329.99542236328125" id="u9e932c10" class="ne-image"></p><h3 id="XK1pV"><span class="ne-text">slot使用</span></h3><p id="u4b93f37b" class="ne-p"><span class="ne-text">vue2：</span></p><pre><code><code>&lt;template&gt;  &lt;template slot=&quot;content&quot;&gt;    ···  &lt;/template&gt;&lt;/template&gt;</code></code></pre><p id="u2d76544d" class="ne-p"><span class="ne-text">vue3：</span></p><pre><code><code>&lt;template&gt;  &lt;slot name=&quot;content&quot;&gt;    ···  &lt;/slot&gt;&lt;/template&gt;</code></code></pre><h3 id="ZQBWT"><span class="ne-text">ref获取元素节点</span></h3><ul class="ne-ul"><li id="ub4539e16" data-lake-index-type="0"><a href="https://zhuanlan.zhihu.com/p/546041641" data-href="https://zhuanlan.zhihu.com/p/546041641" class="ne-link"><span class="ne-text">一文讲全Vue3中使用ref获取元素节点</span></a></li></ul><h3 id="wZVbK"><span class="ne-text">[取]函数式编程模式[弃]Mixin逻辑</span></h3><ul class="ne-ul"><li id="u737a443d" data-lake-index-type="0"><span class="ne-text">cooperation的Mixin代码较难抽离出来</span></li></ul><p id="uc4c1ed40" class="ne-p"><span class="ne-text">使用到较多的cooperation文件代码，Mixin逻辑，不再像Home组件中的上传逻辑一样直接放到一块，改用引用函数的方式，因为变量不多。</span></p><p id="u7d540e78" class="ne-p"><strong><span class="ne-text">ylCooperationSdkInstance变量在组件中使用较少，但是如果直接引用ts文件中的变量，是否会存在不再响应的问题</span></strong><span class="ne-text">。使用vue3推荐的组合式函数编程方式：</span></p><p id="u3d96f510" class="ne-p"><a href="https://cn.vuejs.org/guide/reusability/composables.html" data-href="https://cn.vuejs.org/guide/reusability/composables.html" target="_blank" class="ne-link"><span class="ne-text">https://cn.vuejs.org/guide/reusability/composables.html</span></a></p><ul class="ne-ul"><li id="u4138f1c6" data-lake-index-type="0"><span class="ne-text">上面的mixin文件代码全部放在ts文件中，然后在vue中导入ts文件，其仍然保留生命周期</span></li><li id="u58172690" data-lake-index-type="0"><span class="ne-text">单独ts文件是用不了全局变量</span></li></ul><p id="u42054b22" class="ne-p"><span class="ne-text">直接导入router文件，使用根源API</span></p><p id="ua53deb11" class="ne-p"><a href="https://cn.vuejs.org/guide/reusability/composables.html#vs-mixins" data-href="https://cn.vuejs.org/guide/reusability/composables.html#vs-mixins" target="_blank" class="ne-link"><span class="ne-text">https://cn.vuejs.org/guide/reusability/composables.html#vs-mixins</span></a></p><ul class="ne-tl"><li id="ucfbac137" data-lake-index-type="0"><span class="ne-text">将上传逻辑js代码转为ts代码，然后再全量导入Home/index.vue中</span></li><li id="u3d1d9606" data-lake-index-type="0"><span class="ne-text">data数据迁移</span></li></ul><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="u6f267da4" data-lake-index-type="0"><span class="ne-text">里面应该只有uploadedNum变量再vue组件中使用到了</span></li><li id="u7045ba9d" data-lake-index-type="0"><span class="ne-text">iconType变量两者都有</span></li></ul></ul><hr id="XrhMr" class="ne-hr"><ul class="ne-tl"><li checked="true" id="uec0bdb16" data-lake-index-type="0"><strong><span class="ne-text">uploadHandler.ts上传逻辑代码进行ts转换</span></strong><span class="ne-text">。并且将代码放到组件中</span></li></ul><p id="u138bcb53" class="ne-p"><span class="ne-text">在Home组件中，混合代码较多，其中，上传逻辑使用的是vue2.x的Minix混入方式，但是在vue3不再推荐该模式写代码，所以单独将上传逻辑js文件单独整理其逻辑，文件逻辑中，上传js代码和Home.vue组件两者相互又使用一些变量···</span></p><ul class="ne-ul"><li id="u121972f0" data-lake-index-type="0"><span class="ne-text">上传js代码中有6处使用vue中的变量</span></li><li id="u94ae31fe" data-lake-index-type="0"><span class="ne-text">vue中有2处使用js代码中变量</span></li></ul><div data-type="success" class="ne-alert"><p id="uccbb3b29" class="ne-p"><span class="ne-text">尝试方法1：因为两者多出混入变量使用，尝试将上传的ts代码全部放到Home组件中，虽然代码变长了，但是逻辑性提高了，先做出如下备份</span></p></div><h3 id="Dg53c"><span class="ne-text">vue3中不要命名冲突</span></h3><p id="u9e776dd7" class="ne-p"><span class="ne-text">会导致取值和预期取值不一样</span></p><p id="ub011d3d5" class="ne-p"><span class="ne-text">pagination对象类型，在首页的分页逻辑有误</span></p><p id="udba536aa" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1660899285052-ac9a2e6a-56f3-4a12-9b98-2d08b236aaf3.png" width="364" id="v8HpR" class="ne-image"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1660899292966-6f4b637e-1724-4691-9ea9-43073709682d.png" width="428" id="iFQc8" class="ne-image"></p><p id="u549774ab" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1661153296181-86029975-7753-4d85-b214-775ceba0d1cc.png" width="923" id="ude0118c7" class="ne-image"></p><p id="u8f10d885" class="ne-p"><br></p><h3 id="LqHwF"><span class="ne-text">vue3全局路由配置</span></h3><ul class="ne-ul"><li id="ua2ae1e5d" data-lake-index-type="0"><span class="ne-text">vue3路由全局匹配</span></li></ul><p id="uf8affa74" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1661333780817-83937643-c4b9-43f0-ad47-6db7487230e6.png" width="536" id="f9d06" class="ne-image"></p><p id="uf09f5f1c" class="ne-p"><a href="https://blog.csdn.net/Boale_H/article/details/118526941" data-href="https://blog.csdn.net/Boale_H/article/details/118526941" class="ne-link"><span class="ne-text">vue3配置路由报错Catch all routes (“*“) must now be defined using a param with a custom regexp._Boale_H的博客-CSDN博客</span></a></p><h3 id="HSZos"><span class="ne-text">js/ts文件使用相应vue中函数</span></h3><ul class="ne-ul"><li id="u65257d16" data-lake-index-type="0"><span class="ne-text">vue2：传递“this”：</span><a href="https://www.cnblogs.com/taohuaya/p/10765731.html" data-href="https://www.cnblogs.com/taohuaya/p/10765731.html" target="_blank" class="ne-link"><span class="ne-text">https://www.cnblogs.com/taohuaya/p/10765731.html</span></a></li><li id="u10603717" data-lake-index-type="0"><span class="ne-text">但是vue3没有this，利用传参</span></li></ul><p id="u5d3f8e2c" class="ne-p"><br></p><h3 id="Dznst"><span class="ne-text">全局变量的使用</span></h3><p id="u7bad40cd" class="ne-p"><span class="ne-text">vue3注册全局变量失去响应性</span></p><ul class="ne-tl"><li checked="true" id="u30cdb9c2" data-lake-index-type="0"><span class="ne-text">点击登录按钮，相应一个loading的状态，这个在之前项目中是利用全局注册的一个变量，vue3的全局注册变量方法</span></li></ul><ul class="ne-ul"><li id="u3074ce17" data-lake-index-type="0"><a href="https://blog.csdn.net/weixin_43090018/article/details/117222606" data-href="https://blog.csdn.net/weixin_43090018/article/details/117222606" target="_blank" class="ne-link"><span class="ne-text">https://blog.csdn.net/weixin_43090018/article/details/117222606</span></a></li><li id="u585d358a" data-lake-index-type="0"><a href="https://blog.csdn.net/XKFC1/article/details/123715354" data-href="https://blog.csdn.net/XKFC1/article/details/123715354" target="_blank" class="ne-link"><strong><span class="ne-text" style="text-decoration: underline">https://blog.csdn.net/XKFC1/article/details/123715354</span></strong></a></li><li id="u1c46c536" data-lake-index-type="0"><a href="https://blog.csdn.net/Jkssns/article/details/117369556" data-href="https://blog.csdn.net/Jkssns/article/details/117369556" class="ne-link"><span class="ne-text">vue3 怎么创建全局的响应式对象 创建简单的vuex_最有才的河南大汉的博客-CSDN博客</span></a></li><li id="u696bccca" data-lake-index-type="0"><strong><span class="ne-text">fetch文件中的axiosLoadingObj变量，在main.ts中注册为全局变量，Login.vue中使用，当fetch中axiosLoadingObj变量的值改变，Login.vue中使用该全局变量不会发生改变</span></strong><span class="ne-text">。</span></li></ul><ul class="ne-tl"><li checked="true" id="u88965f22" data-lake-index-type="0"><strong><span class="ne-text">接口 - loading 的全局变量迁移</span></strong></li></ul><div class="ne-quote"><p id="u79d31fbe" class="ne-p"><span class="ne-text">不能使用v3全局变量api getCurrentInstance 不能响应式，同时打包情况下</span></p></div><p id="u07af8264" class="ne-p"><span class="ne-text">直接导入ts文件，在ts文件中做变量导出，</span></p><p id="udf2d3f0f" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1661412605610-41df1509-a29d-413c-b416-35df368c1ea1.png" width="299" id="CCoRo" class="ne-image"></p><h3 id="hGeeF"><span class="ne-text">v-if/else branches must use unique keys.vue(29)</span></h3><ul class="ne-ul"><li id="u461d521b" data-lake-index-type="0"><span class="ne-text">官方解释：</span><a href="https://github.com/vuejs/core/issues/1712#issuecomment-665206103" data-href="https://github.com/vuejs/core/issues/1712#issuecomment-665206103" target="_blank" class="ne-link"><span class="ne-text">https://github.com/vuejs/core/issues/1712#issuecomment-665206103</span></a></li><li id="ub105d81b" data-lake-index-type="0"><span class="ne-text">解决参考：</span><a href="https://blog.csdn.net/Fine_Cui/article/details/124906140" data-href="https://blog.csdn.net/Fine_Cui/article/details/124906140" target="_blank" class="ne-link"><span class="ne-text">https://blog.csdn.net/Fine_Cui/article/details/124906140</span></a></li></ul><pre><code><code>&lt;template v-for=&quot;(item, index) in fileList&quot;&gt;  &lt;a-menu-divider v-if=&quot;item.isDivider&quot; :key=&quot;index&quot; /&gt;  &lt;a-menu-item    v-else    :key=&quot;item.value&quot;    class=&quot;create-button-menu-item&quot;    @click=&quot;handleMenuClick(item.value)&quot;  &gt;</code></code></pre><p id="u083015aa" class="ne-p"><span class="ne-text">将第五行代码中的index换成item.value，一是因为index在这里并没有传值的实际作用，而是解决key值相同问题</span></p><h3 id="R4NI3"><span class="ne-text">具名插槽</span></h3><ul class="ne-ul"><li id="u256fd8ea" data-lake-index-type="0"><span class="ne-text">vue3插槽使用方式和vue2不一样，不能使用template，而是slot标签，name属性</span></li><li id="u405399c1" data-lake-index-type="0"><span class="ne-text">具名插槽在vue2和vue3两者使用有差别</span></li></ul><p id="u14e51d6f" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1661134037087-4a944237-fc24-4400-a575-94a6d16c45e9.png" width="362" id="u1dba96bd" class="ne-image"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1661134050262-d9d14d5e-0a75-4653-aada-bc4ed4ed049e.png" width="470" id="u57e5a561" class="ne-image"></p><h3 id="Dtowl"><span class="ne-text">注释导致页面不能渲染</span></h3><p id="ud619e2be" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1661131638426-cfc30116-2d9a-48bd-a012-4e35ba5e05b0.png" width="819" id="u65bae636" class="ne-image"></p><p id="u61297059" class="ne-p"><span class="ne-text">上述箭头所标注的地方不要有注释，有注释会渲染不出来</span></p><h3 id="lByqY"><span class="ne-text">样式只在当前页面有效</span></h3><p id="u9daaaa0e" class="ne-p"><span class="ne-text">组件中style标签后面加上</span><code class="ne-code"><span class="ne-text">scoped</span></code><span class="ne-text">就可以</span></p><pre><code><code>&lt;style lang=&quot;less&quot; scoped&gt;&lt;/style&gt;</code></code></pre><h3 id="NWJql"><span class="ne-text">vue2获取dom节点自定义属性值</span></h3><p id="u8c71347d" class="ne-p"><a href="https://blog.csdn.net/qq_41854017/article/details/79653096" data-href="https://blog.csdn.net/qq_41854017/article/details/79653096" class="ne-link"><span class="ne-text">vue如何获取自定义元素属性参数值_lotSeed_5的博客-CSDN博客_vue获取元素的属性值</span></a></p><h3 id="O8eIn"><span class="ne-text">根据dom属性来动态改变css</span></h3><p id="u10c84f23" class="ne-p"><span class="ne-text">当给dom添加自定义属性，vue2和vue3实际渲染出来的不一样（如果是标签自身属性，vue3和vue2是一样的）</span></p><ul class="ne-ul"><li id="uaf70c49a" data-lake-index-type="0"><span class="ne-text">vue3</span></li></ul><pre><code><code>&lt;div :selected=&quot;true&quot;&gt;selected&lt;/div&gt;&lt;div :selected=&quot;false&quot;&gt;UnSlected&lt;/div&gt;</code></code></pre><p id="u188abf3d" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/webp/1484158/1662269390565-52d14982-b80a-441f-8c6c-db04807b1cf0.webp" width="301" id="u9cb11d77" class="ne-image"></p><ul class="ne-ul"><li id="ucd66fee6" data-lake-index-type="0"><span class="ne-text">vue2</span></li></ul><pre><code><code>&lt;div :selected=&quot;true&quot;&gt;selected&lt;/div&gt;&lt;div :selected=&quot;false&quot;&gt;UnSlected&lt;/div&gt;</code></code></pre><p id="u74d0c552" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/webp/1484158/1662269414261-8fcbcd09-3ca9-4d1c-b4d1-9e04602285d3.webp" width="251" id="u7e5c48ec" class="ne-image"></p><ul class="ne-ul"><li id="u71487448" data-lake-index-type="0"><span class="ne-text">根据以上不同，在css选择器使用有区别</span></li><li id="ua4cc1f9a" data-lake-index-type="0"><span class="ne-text">vue3</span></li></ul><pre><code><code>//  vue3div[selected=true] &#123;  color: red;&#125;</code></code></pre><ul class="ne-ul"><li id="u0822b525" data-lake-index-type="0"><span class="ne-text">vue2</span></li></ul><pre><code><code>// vue2div[selected] &#123;    color: red;&#125;</code></code></pre><h2 id="yT5Qx"><span class="ne-text">参考</span></h2><ul class="ne-ul"><li id="u9b3ec81f" data-lake-index-type="0"><a href="https://segmentfault.com/a/1190000041849882" data-href="https://segmentfault.com/a/1190000041849882" target="_blank" class="ne-link"><span class="ne-text">Vue3.2 setup语法糖总结</span></a></li></ul></div>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
          <category> Vue </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Vue3实现一个类微信聊天界面</title>
      <link href="/blog/yx51zf/"/>
      <url>/blog/yx51zf/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><ul class="ne-ul"><li id="u2703b449"><span class="ne-text">编写一个类微信聊天界面要求除了常规功能外，顶部有一个系统状态栏，显示当前时间，精确到秒</span></li></ul><ul class="ne-ul"><li id="u8dda41c6"><span class="ne-text" style="color: rgb(36, 41, 47); font-size: 14px">其中icon使用了</span><a href="http://www.fontawesome.com.cn/get-started/" data-href="http://www.fontawesome.com.cn/get-started/" target="_blank" class="ne-link"><span class="ne-text">http://www.fontawesome.com.cn/get-started/</span></a><span class="ne-text" style="color: rgb(36, 41, 47); font-size: 14px"> UI库（下图未放icon）</span></li></ul><p id="u3dc031bb" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1658750105722-3d6a1954-d707-48bd-8fe4-377aefe9fba7.png" width="407.99310302734375" id="u144640ca" class="ne-image"></p><p id="u1119cc0b" class="ne-p"><span class="ne-text" style="color: rgb(36, 41, 47); font-size: 14px"></span></p><pre><code>&lt;template&gt;<pre><code>&amp;lt;div class=&amp;quot;box&amp;quot;&amp;gt;    &amp;lt;div class=&amp;quot;header&amp;quot;&amp;gt;        &amp;lt;div class=&amp;quot;status&amp;quot;&amp;gt;            &amp;lt;span&amp;gt;                &amp;lt;i class=&amp;quot;fa fa-wifi&amp;quot; aria-hidden=&amp;quot;true&amp;quot;&amp;gt;&amp;lt;/i&amp;gt;            &amp;lt;/span&amp;gt;            &amp;lt;span style=&amp;quot;float: right&amp;quot;&amp;gt;                &amp;lt;i class=&amp;quot;fa fa-battery-quarter&amp;quot; aria-hidden=&amp;quot;true&amp;quot;&amp;gt;&amp;lt;/i&amp;gt;                &#123;&#123;timer&#125;&#125;            &amp;lt;/span&amp;gt;        &amp;lt;/div&amp;gt;        &amp;lt;div class=&amp;quot;info&amp;quot;&amp;gt;            &amp;lt;span style=&amp;quot;float: left;margin-left: 5px;&amp;quot;&amp;gt;                &amp;lt;i class=&amp;quot;fa fa-chevron-left&amp;quot; aria-hidden=&amp;quot;true&amp;quot;&amp;gt;&amp;lt;/i&amp;gt;            &amp;lt;/span&amp;gt;            &amp;lt;span&amp;gt;群聊1&amp;lt;/span&amp;gt;            &amp;lt;span style=&amp;quot;float: right;margin-right: 5px;&amp;quot;&amp;gt;                &amp;lt;i class=&amp;quot;fa fa-ellipsis-h&amp;quot; aria-hidden=&amp;quot;true&amp;quot;&amp;gt;&amp;lt;/i&amp;gt;            &amp;lt;/span&amp;gt;        &amp;lt;/div&amp;gt;    &amp;lt;/div&amp;gt;    &amp;lt;div class=&amp;quot;content&amp;quot;&amp;gt;        &amp;lt;div v-for=&amp;quot;item, index in news_items&amp;quot; class=&amp;quot;new_box&amp;quot;&amp;gt;            &amp;lt;div v-if=&amp;quot;item.isMe === true&amp;quot; style=&amp;quot;width: 100%;text-align: right;&amp;quot;&amp;gt;                &amp;lt;div style=&amp;quot;display: inline-block;margin-left: 10px&amp;quot;&amp;gt;                    &amp;lt;div class=&amp;quot;new_box_detail&amp;quot;&amp;gt;&#123;&#123;item.content&#125;&#125;&amp;lt;/div&amp;gt;                &amp;lt;/div&amp;gt;                &amp;lt;img :src=&#39;item.avatar&#39; alt=&amp;quot;&amp;quot;&amp;gt;            &amp;lt;/div&amp;gt;            &amp;lt;div v-if=&amp;quot;item.isMe === false&amp;quot;&amp;gt;                &amp;lt;img :src=&#39;item.avatar&#39; alt=&amp;quot;&amp;quot;&amp;gt;                &amp;lt;div style=&amp;quot;display: inline-block;margin-left: 10px;&amp;quot;&amp;gt;                    &amp;lt;span&amp;gt;&#123;&#123;item.name&#125;&#125;&amp;lt;/span&amp;gt;                    &amp;lt;br&amp;gt;                    &amp;lt;div class=&amp;quot;new_box_detail&amp;quot;&amp;gt;&#123;&#123;item.content&#125;&#125;&amp;lt;/div&amp;gt;                &amp;lt;/div&amp;gt;            &amp;lt;/div&amp;gt;        &amp;lt;/div&amp;gt;    &amp;lt;/div&amp;gt;    &amp;lt;div class=&amp;quot;input_box&amp;quot;&amp;gt;        &amp;lt;i class=&amp;quot;fa fa-commenting fa-2x&amp;quot; aria-hidden=&amp;quot;true&amp;quot; style=&amp;quot;margin: 10px&amp;quot;&amp;gt;&amp;lt;/i&amp;gt;        &amp;lt;span&amp;gt;&amp;lt;input type=&amp;quot;text&amp;quot; name=&amp;quot;input_content&amp;quot; @keyup.enter=&amp;quot;enterKeyDown&amp;quot; v-model=&amp;quot;new_info&amp;quot;&amp;gt;&amp;lt;/span&amp;gt;        &amp;lt;i class=&amp;quot;fa fa-smile-o fa-2x&amp;quot; aria-hidden=&amp;quot;true&amp;quot; style=&amp;quot;margin-left: 10px&amp;quot;&amp;gt;&amp;lt;/i&amp;gt;        &amp;lt;i class=&amp;quot;fa fa-plus-circle fa-2x&amp;quot; aria-hidden=&amp;quot;true&amp;quot;  style=&amp;quot;margin-left: 10px&amp;quot;&amp;gt;&amp;lt;/i&amp;gt;    &amp;lt;/div&amp;gt;&amp;lt;/div&amp;gt;</code></pre><p>&lt;/template&gt;</p><p>&lt;script setup lang=&quot;ts&quot;&gt;<br>import { reactive, ref } from ‘vue’</p><p>interface NewsItemsInterface {<br>  id: number<br>  avatar: string<br>  isMe: boolean<br>  content: string<br>  name: string<br>}</p><p>let news_items: NewsItemsInterface[] = reactive([<br>  {<br>    id: 1,<br>    avatar: ‘<a href="https://npm.elemecdn.com/cdn-pictures@0.0.0/avatar/pic/MilkTea.png&#39;">https://npm.elemecdn.com/cdn-pictures@0.0.0/avatar/pic/MilkTea.png&#39;</a>,<br>    content: ‘用户1消息’,<br>    name: ‘小王’,<br>    isMe: false<br>  },<br>  {<br>    id: 2,<br>    avatar: ‘<a href="https://npm.elemecdn.com/cdn-pictures@0.0.0/avatar/pic/MilkTea.png&#39;">https://npm.elemecdn.com/cdn-pictures@0.0.0/avatar/pic/MilkTea.png&#39;</a>,<br>    content: ‘我的消息’,<br>    name: ‘小吴’,<br>    isMe: true<br>  },<br>  {<br>    id: 3,<br>    avatar: ‘<a href="https://npm.elemecdn.com/cdn-pictures@0.0.0/avatar/pic/MilkTea.png&#39;">https://npm.elemecdn.com/cdn-pictures@0.0.0/avatar/pic/MilkTea.png&#39;</a>,<br>    content: ‘用户2消息用户2消息用户2消息’,<br>    name: ‘小李’,<br>    isMe: false<br>  },<br>])</p><p>let timer = ref(‘’)<br>let new_info = ref(‘’)</p><p>const toDateYMDHMS = () =&gt; {<br>  const date = new Date()<br>  const h = date.getHours() &lt; 10 ? <code>0$&#123;date.getHours()&#125;:</code> : date.getHours() + ‘:’<br>  const m = date.getMinutes() &lt; 10 ? <code>0$&#123;date.getMinutes()&#125;:</code> : date.getMinutes() + ‘:’<br>  const s = date.getSeconds() &lt; 10 ? <code>0$&#123;date.getSeconds()&#125;</code> : date.getSeconds()</p><p>  return h + m + s<br>}</p><p>setInterval(() =&gt; {<br>    timer.value = toDateYMDHMS()<br>}, 1000)</p><p>const enterKeyDown = () =&gt; {<br>    news_items.push({<br>        id: 2,<br>        avatar: ‘<a href="https://npm.elemecdn.com/cdn-pictures@0.0.0/avatar/pic/MilkTea.png&#39;">https://npm.elemecdn.com/cdn-pictures@0.0.0/avatar/pic/MilkTea.png&#39;</a>,<br>        content: new_info.value,<br>        name: ‘小吴’,<br>        isMe: true<br>    })<br>    new_info.value = ‘’<br>}<br>&lt;/script&gt;</p><p>&lt;style scoped&gt;<br>.box {<br>    margin: 0 auto;<br>    height: 100%;<br>    width: 60vw;<br>    border: 1px rgb(0, 0, 0) solid;</p><p>}<br>/* ————————————————————————- <em>/<br>.header {<br>    height: 80px;<br>    /</em> border: 1px cyan solid; <em>/<br>    background-color: rgb(231, 231, 231);<br>}<br>.header .status {<br>    height: 30px;<br>    line-height: 30px;<br>    vertical-align: middle;<br>}<br>.header .info {<br>    height: 50px;<br>    line-height: 50px;<br>    text-align: center;<br>}<br>/</em> ————————————————————————- <em>/<br>.content {<br>    /</em> border: 1px red solid; <em>/<br>    background-color: rgb(164, 201, 201);<br>    height: 75vh<br>}<br>.content .new_box img {<br>    width: 30px;<br>}<br>.content .new_box_detail {<br>    background-color: rgb(255, 255, 255);<br>    padding: 5px;<br>}<br>/</em> ————————————————————————- <em>/<br>.input_box {<br>    /</em> border: 1px blueviolet solid; */<br>    height: 60px;<br>    line-height: 60px;<br>    background-color: rgb(231, 231, 231);<br>}<br>.input_box input {<br>    width: 70%;<br>    border: none;<br>    outline: none;<br>    height: 60%;<br>}<br>.input_box input:focus {<br>    outline: none;<br>}<br>&lt;/style&gt;</p><p></code></pre></p><p id="u02ce1c89" class="ne-p"><br></p></div>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
          <category> Vue </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Vue3实现一个ButtonGroup组件</title>
      <link href="/blog/he31vw/"/>
      <url>/blog/he31vw/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="u2eccf227" class="ne-p"><span class="ne-text">编写一个ButtonGroup组件要求支持 单选、多选</span></p><p id="ud689e7b4" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1658749703167-7b9db556-0f22-411b-8adb-8289b5725b76.png" width="607.4074503162137" id="u4982b92e" class="ne-image"></p><p id="u04fd3e7b" class="ne-p"><span class="ne-text"></span></p><pre><code>&lt;template&gt;&lt;div style=&quot;text-align: center&quot;&gt;  &lt;div&gt;    &lt;p&gt;选择butonGroup的单选/多选类型：&lt;/p&gt;    &lt;label&gt;单选&lt;input type=&quot;radio&quot; v-model=&quot;gender&quot; value=&quot;single&quot; @click=&quot;clickSingleMulti&quot;/&gt;&lt;/label&gt;    &lt;label&gt;多选&lt;input type=&quot;radio&quot; v-model=&quot;gender&quot; value=&quot;multi&quot; @click=&quot;clickSingleMulti&quot; /&gt;&lt;/label&gt;    &lt;p&gt;已选类型：&#123;&#123;gender === 'single' ? '单选' : gender === 'multi' ? '多选' : ''&#125;&#125;&lt;/p&gt;  &lt;/div&gt;  &lt;hr&gt;  &lt;div v-for=&quot;item, index in button_items&quot;&gt;    &lt;button @click=&quot;clickFun(item, $event)&quot; :selected='item.select' :disabled=&quot;gender === ''&quot;&gt;      &#123;&#123;item.title&#125;&#125;    &lt;/button&gt;  &lt;/div&gt;&lt;/div&gt;<p>&lt;/template&gt;</p><p>&lt;script setup lang=&quot;ts&quot;&gt;<br>import &#123; reactive, ref &#125; from ‘vue’</p><p>interface ButtonItemsInterface &#123;<br>  id: number<br>  title: string<br>  select: boolean<br>&#125;</p><p>let button_items: ButtonItemsInterface[] = reactive([<br>  &#123;<br>    id: 1,<br>    title: ‘选项1’,<br>    select: false<br>  &#125;,<br>  &#123;<br>    id: 2,<br>    title: ‘选项2’,<br>    select: false<br>  &#125;,<br>  &#123;<br>    id: 3,<br>    title: ‘选项3’,<br>    select: false<br>  &#125;,<br>])<br>let result: any[] = reactive([])<br>let gender = ref(‘’)<br>// 置空函数，当切换单选多选，置空result数组<br>const clickSingleMulti = () =&gt; &#123;<br>  result = []<br>&#125;<br>const clickFun = (item: any, e: any) =&gt; &#123;<br>  if (gender.value === ‘multi’) &#123;<br>    if (e.target.getAttribute(‘selected’) === ‘true’) &#123;<br>        // 被选中<br>        let index = result.indexOf(item.id)<br>        if (index &gt; -1) &#123;<br>            result.splice(index,1);<br>        &#125;<br>    &#125; else &#123;<br>        // 未被选中<br>        result.push(item.id)<br>    &#125;<br>    item.select = !item.select<br>    console.log(‘单选选择的结果：’, result)<br>  &#125; else &#123;<br>    result = []<br>    result.push(item.id)<br>    console.log(‘多选选择的结果：’, result)<br>  &#125;</p><p>&#125;<br>&lt;/script&gt;</p><p>&lt;style scoped&gt;<br>button[selected=true] &#123;<br>    color: red;<br>&#125;<br>&lt;/style&gt;<br></code></pre></p></div>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
          <category> Vue </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Nodejs三方模块使用汇总</title>
      <link href="/blog/gf5tiw/"/>
      <url>/blog/gf5tiw/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/1484158/1665070666704-a55506d2-ea9e-4b25-b3f9-ecf371d0d453.jpeg" id="rnRA9" style="display: block; width: 100%"><p id="ub4dba476" class="ne-p"><span class="ne-text"></span></p><p id="u4f377b7d" class="ne-p"><span class="ne-text">前言：第三方模块的两种存在形式</span></p><ol class="ne-ol"><li id="uea902046" data-lake-index-type="0"><span class="ne-text">以js文件的形式存在，提供实现项目具体功能的API接口。比如使用jQuery，html中引入CDN超链接即可使用。</span></li><li id="ued707d01" data-lake-index-type="0"><span class="ne-text">以命令行工具形式存在，辅助项目开发。</span></li></ol><p id="u7246d05b" class="ne-p"><span class="ne-text">比如VUE-CLI工具。</span></p><div class="ne-quote"><p id="u9fdfbea6" class="ne-p"><span class="ne-text">npm是用来管理模块的一个node工具，它会伴随着node的下载而一同下载。</span></p></div><p id="ufbcd196a" class="ne-p"><br></p><p id="u886c8835" class="ne-p"><span class="ne-text">node生态的繁荣多益于很多优秀的三方模块的存在，具体可以查看 </span><a href="https://nodersurvey.github.io/reporters/index.html" data-href="https://nodersurvey.github.io/reporters/index.html" target="_blank" class="ne-link"><span class="ne-text">NoderSurvey 2021 年度报告</span></a><span class="ne-text"> 的相关统计与调研。在此记录一下在学习以及实际开发过程中自己所学习到的三方模块，特别地，express三方模块是一个web应用框架，需要学习的点较多，单独拿出来详细学习。</span></p><h3 id="svJmx"><span class="ne-text">cnpm</span></h3><p id="u527ed771" class="ne-p"><span class="ne-text">因为npm是处于国外的服务器，下载模块有时候可能会较慢，特别是文件比较多的模块。</span></p><ol class="ne-ol"><li id="u0d1cf399" data-lake-index-type="0"><span class="ne-text">方法1: 临时使用淘宝镜像下载的命令。</span></li></ol><pre><code><code>npm install --registry https://registry.npm.taobao.org</code></code></pre><ol start="2" class="ne-ol"><li id="ua2dd3b59" data-lake-index-type="0"><span class="ne-text">方法2: 更改npm镜像下载源</span></li></ol><pre><code><code># 配置镜像源npm config set registry https://registry.npmmirror.com# 下载npm i<p>######################################################</p><h1 id="解除镜像源"><a href="#解除镜像源" class="headerlink" title="解除镜像源"></a>解除镜像源</h1><p>npm config set registry <a href="https://registry.npmjs.org/">https://registry.npmjs.org/</a></p><h1 id="其他包管理也是一样"><a href="#其他包管理也是一样" class="headerlink" title="其他包管理也是一样"></a>其他包管理也是一样</h1><p>npm config set registry <a href="https://registry.npmmirror.com/">https://registry.npmmirror.com</a><br>yarn config set registry <a href="https://registry.npmmirror.com/">https://registry.npmmirror.com</a><br>pnpm config set registry <a href="https://registry.npmmirror.com/">https://registry.npmmirror.com</a></code><br></code></pre></p><ol start="3" class="ne-ol"><li id="u2ac17d18" data-lake-index-type="0"><span class="ne-text">方法3: 如果不想改变npm镜像源，可以使用cnpm</span><span class="ne-text" style="color: #DF2A3F">（推荐）</span></li></ol><pre><code><code>// download cnpmnpm install -g cnpm --registry=https://registry.npm.taobao.org<p>cnpm install</code><br></code></pre></p><hr id="kT7dF" class="ne-hr"><p id="u7e1b43a6" class="ne-p"><span class="ne-text">查看镜像源</span></p><pre><code><code>npm config get registrypnpm config get registrycnpm config get registry</code></code></pre><p id="u5cb64146" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2023/png/1484158/1693721898134-21b4ba2b-4179-4cfb-9502-3b63cacd9902.png" width="374.81484129268796" id="u68a62934" class="ne-image"></p><h3 id="ezaPQ"><span class="ne-text">nodemon</span></h3><pre><code><code>cnpm install nodemon –g</code></code></pre><p id="77b64508eb62a74429490cc85bb3d580" class="ne-p"><span class="ne-text">作用：在开发过程中，修改了文件，控制台命令行就会根据文件的修改自动运行</span></p><p id="d7ebe048620778843516822109d90a9e" class="ne-p"><span class="ne-text">使用方法：将运行命令中的node换成nodemon</span></p><h3 id="TqQTy"><span class="ne-text">gulp</span></h3><p id="1ac1057d577258f93e05b60382bfbee0" class="ne-p"><span class="ne-text">基于node平台开发的前端构建工具，将机械化操作编写成任务，想要执行机械化操作时执行一个命令行命令任务就能自动执行了，用机器代替手工，提高开发效率。</span></p><p id="ude5bb27b" class="ne-p"><span class="ne-text">具体的还有webpack，后续继续学习。</span></p><p id="9710a896a46943e194f42cee882559a2" class="ne-p"><br></p><p id="5ce68255f05a334bfc100c5fc86e9095" class="ne-p"><span class="ne-text">作用：</span></p><ul class="ne-ul"><li id="b8c516f632c3ccb2822f0eade960b320" data-lake-index-type="0"><span class="ne-text">项目上线，HTML、CSS、JS文件压缩合并</span></li><li id="6729897eaa4fff1e51427e6ab63ebe1a" data-lake-index-type="0"><span class="ne-text">语法转换（es6、less ...）</span></li><li id="ce83ec1bfaf4a135a60a2037cb367500" data-lake-index-type="0"><span class="ne-text">公共文件抽离</span></li><li id="8eb5fa1547b0b864f5385548a15c90f2" data-lake-index-type="0"><span class="ne-text">修改文件浏览器自动刷新</span></li></ul><p id="058615d0670c54f7b034065dfebd2c95" class="ne-p"><br></p><p id="2227bf834848ccf297622d3c5527848c" class="ne-p"><span class="ne-text">glup本身提供的api函数很少，官网到目前更新只有下面几个，具体使用方法，使用的时候去查</span></p><ul class="ne-ul"><li id="53491b21545dab643185de554b201e55" data-lake-index-type="0"><a href="https://github.com/gulpjs/gulp" data-href="https://github.com/gulpjs/gulp" target="_blank" class="ne-link"><span class="ne-text">https://github.com/gulpjs/gulp</span></a></li><li id="dd1aff95a8401b1918ac05a8549b6a9a" data-lake-index-type="0"><a href="https://gulpjs.com/docs/en/getting-started/quick-start" data-href="https://gulpjs.com/docs/en/getting-started/quick-start" target="_blank" class="ne-link"><span class="ne-text">https://gulpjs.com/docs/en/getting-started/quick-start</span></a><span class="ne-text"></span></li></ul><p id="1c646168bbaefd2634c677af0e29a0ba" class="ne-p"><br></p><p id="7a8349872f1c8ff64f06aacdd754bbab" class="ne-p"><span class="ne-text">gulp生态也有很多插件，根据插件下载相应需要的功能插件</span></p><ul class="ne-ul"><li id="2b6d96e782679dd6a14e43de42a2efe2" data-lake-index-type="0"><span class="ne-text">gulp-htmlmin ：html文件压缩</span></li><li id="2fb6cabb8d39f31b4ec63f466092027f" data-lake-index-type="0"><span class="ne-text">gulp-csso ：压缩css</span></li><li id="2590af36e2d20fc8af4017d8c8423ed8" data-lake-index-type="0"><span class="ne-text">gulp-babel ：JavaScript语法转化</span></li><li id="75ace6bedd13bf4569184a59c9a86e72" data-lake-index-type="0"><span class="ne-text">gulp-less: less语法转化</span></li><li id="37aa37302d2cda9ca969b28e81fcbbed" data-lake-index-type="0"><span class="ne-text">gulp-uglify ：压缩混淆JavaScript</span></li><li id="44d0eb8f741da42560a8e881421cf825" data-lake-index-type="0"><span class="ne-text">gulp-file-include 公共文件包含</span></li><li id="11764dcc7c9f1857a65577cb328be98b" data-lake-index-type="0"><span class="ne-text">browsersync 浏览器实时同步</span></li></ul><h3 id="m5eli"><span class="ne-text">cross-env</span></h3><p id="u9e9a3659" class="ne-p"><span class="ne-text">windows不支持NODE_ENV=development的设置方式</span></p><p id="u447e7abf" class="ne-p"><span class="ne-text">所以使用该模块来进行跨平台地使用环境变量，兼容各平台使用</span></p><h3 id="lbsH2"><span class="ne-text">sharedb</span></h3><p id="u936c3000" class="ne-p"><span class="ne-text">ShareDB 是一个整合了前后端的 OT 框架，可以很方便地自行搭建服务端和客户端。框架基于 Node.JS 实现。</span></p><p id="uda193c76" class="ne-p"><br></p><div class="ne-quote"><p id="u3f3ccd7e" class="ne-p"><span class="ne-text">OT（Operational transformation）是一种支持高级协作软件系统中的一系列协作功能的技术。OT 最初是为了在纯文本文档的协作编辑中实现一致性维护和并发控制而发明的。它的功能已得到扩展，其应用程序已扩展至包括组撤消、锁定、冲突解决、操作通知和压缩、组感知、HTML/XML 和树状结构文档编辑、协作办公生产力工具、应用程序共享和协作计算机- 辅助媒体设计工具。[1] 2009 年，OT 被采用为Apache Wave协作功能背后的核心技术和谷歌文档。</span></p></div><h3 id="mjgBJ"><span class="ne-text">sharedb-mongo</span></h3><h3 id="g4QEg"><span class="ne-text">uuid</span></h3><p id="uda44248d" class="ne-p"><span class="ne-text">生成唯一的一个字符串</span></p><ul class="ne-ul"><li id="u017203c1" data-lake-index-type="0"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">v3：基于名字的 用相同的名字，会生成相同的uuid出来</span></li></ul><p id="ud4e0d654" class="ne-p"><a href="https://juejin.cn/post/6844903708799533064" data-href="https://juejin.cn/post/6844903708799533064" target="_blank" class="ne-link"><span class="ne-text">npm的node-uuid和uuid</span></a></p><ul class="ne-ul"><li id="u73a40e55" data-lake-index-type="0"><span class="ne-text">官网配置教程：</span><a href="https://editor.aomao.com/zh-CN/config/ot#%E5%8D%8F%E5%90%8C%E6%95%B0%E6%8D%AE" data-href="https://editor.aomao.com/zh-CN/config/ot#%E5%8D%8F%E5%90%8C%E6%95%B0%E6%8D%AE" target="_blank" class="ne-link"><span class="ne-text">https://editor.aomao.com/zh-CN/config/ot</span></a></li><li id="u2be25db8" data-lake-index-type="0"><span class="ne-text">运行方式：将</span><code class="ne-code"><span class="ne-text">ot-server</span></code><span class="ne-text">文件夹复制到项目根目录，将其处于运行状态，然后再运行主项目（localhost实质上就是指向127.0.0.1这个本地IP地址。）</span></li></ul><h3 id="sHnMR"><span class="ne-text">nanoid</span></h3><p id="u2972908b" class="ne-p"><span class="ne-text">因为uuid生成的字符串太长，不便于作为url路径使用，所以使用nanoid来作为随机url路径</span></p><ul class="ne-ul"><li id="ueb682cd3" data-lake-index-type="0"><a href="https://www.npmjs.com/package/nanoid" data-href="https://www.npmjs.com/package/nanoid" target="_blank" class="ne-link"><span class="ne-text">https://www.npmjs.com/package/nanoid</span></a></li><li id="u5b5164c2" data-lake-index-type="0"><a href="https://github.com/ai/nanoid/blob/HEAD/README.zh-CN.md" data-href="https://github.com/ai/nanoid/blob/HEAD/README.zh-CN.md" target="_blank" class="ne-link"><span class="ne-text">https://github.com/ai/nanoid/blob/HEAD/README.zh-CN.md</span></a></li></ul><h3 id="hccPV"><span class="ne-text">mkdirp</span></h3><ul class="ne-ul"><li id="u789c19b4" data-lake-index-type="0"><a href="https://www.npmjs.com/package/mkdirp" data-href="https://www.npmjs.com/package/mkdirp" class="ne-link"><span class="ne-text">mkdirp</span></a></li></ul><pre><code><code>const mkdirp = require('mkdirp') <p>// return value is a Promise resolving to the first directory created<br>mkdirp(‘/tmp/foo/bar/baz’).then(made =&gt;<br>  console.log(<code>made directories, starting with $&#123;made&#125;</code>))</code><br></code></pre></p><h3 id="rwQV9"><span class="ne-text">ws</span></h3><p id="u87a52cc2" class="ne-p"><span class="ne-text">详见： </span><a href="https://www.wztlink1013.com/blog/wwclae" data-href="https://www.wztlink1013.com/blog/wwclae" target="_blank" class="ne-link"><span class="ne-text">https://www.wztlink1013.com/blog/wwclae</span></a></p><h3 id="fssxg"><span class="ne-text">lodash</span></h3><pre><code><code>npm i @types/lodash</code></code></pre><h3 id="mBf2c"><span class="ne-text">clipboard</span></h3><ul class="ne-tl"><li checked="true" id="u68f99f23" data-lake-index-type="0"><a href="https://blog.csdn.net/weixin_44440116/article/details/115398717" data-href="https://blog.csdn.net/weixin_44440116/article/details/115398717" class="ne-link"><span class="ne-text">vue3使用clipboard进行复制_weixin_44440116的博客-CSDN博客</span></a></li></ul><h3 id="AdFwE"><span class="ne-text">vueuse</span></h3><pre><code><code>&lt;template&gt;  &lt;h3&gt;Mouse: &#123;&#123; x &#125;&#125; x &#123;&#123; y &#125;&#125;&lt;/h3&gt;&lt;/template&gt;<p>&lt;script lang=&quot;ts&quot;&gt;<br>  import &#123; defineComponent &#125; from ‘vue’;<br>  import &#123; useMouse &#125; from ‘@vueuse/core’;</p><p>  export default defineComponent(&#123;<br>    name: ‘VueUse’,<br>    setup() &#123;<br>      const &#123; x, y &#125; = useMouse();</p><pre><code>  return &#123;    x,    y  &#125;;&#125;</code></pre><p>  });<br>&lt;/script&gt;<br></code><br></code></pre></p><h3 id="sMDSa"><span class="ne-text">js-base64</span></h3><pre><code><code>pnpm install --save js-base64</code></code></pre><h3 id="KY5LM"><span class="ne-text">moment</span></h3><h3 id="KGuSf"><span class="ne-text">html2canvas</span></h3></div>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
          <category> Node.js </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>炒莲藕</title>
      <link href="/essay/fi4c0o/"/>
      <url>/essay/fi4c0o/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="uff4b105c" class="ne-p" style="text-align: center"><span class="ne-text">辣椒炒莲藕</span></p><p id="u4b0dd2cb" class="ne-p" style="text-align: center"><span class="ne-text"></span></p><p id="ubd73c524" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/1484158/1656819779743-aa355d3d-1fc6-454d-bebc-9f0178742cc7.jpeg" width="2736" id="ued5f21b8" class="ne-image"></p></div>]]></content>
      
      
      <categories>
          
          <category> 料理 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>炒平菇</title>
      <link href="/essay/cgp1qa/"/>
      <url>/essay/cgp1qa/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="u45e432fb" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/1484158/1656819580848-fd5bd076-3c27-42ea-a245-7b61b3aaf83c.jpeg" width="2736" id="u739306bc" class="ne-image"></p><p id="ub9ff7f1d" class="ne-p"><span class="ne-text">辣椒炒平菇</span></p></div>]]></content>
      
      
      <categories>
          
          <category> 料理 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>煮挂面</title>
      <link href="/essay/zky9eg/"/>
      <url>/essay/zky9eg/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="u0fecea96" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/1484158/1656818758889-aaba7431-98fc-4cb0-b052-40ac338b3034.jpeg" width="431" id="QLQYX" class="ne-image"></p><p id="u9b997641" class="ne-p"><span class="ne-text">步骤：</span></p><ol class="ne-ol"><li id="ucfb13558" data-lake-index-type="0"><span class="ne-text">面条处理</span></li></ol><ol class="ne-list-wrap"><ol ne-level="1" class="ne-ol"><li id="ucb9d6eac" data-lake-index-type="0"><span class="ne-text">烧水至开始沸腾，然后放入面条，熟后放凉水中</span></li></ol></ol><ol start="2" class="ne-ol"><li id="u61a3cb19" data-lake-index-type="0"><span class="ne-text">配料处理</span></li></ol><ol class="ne-list-wrap"><ol ne-level="1" class="ne-ol"><li id="u1cf5a2e7" data-lake-index-type="0"><span class="ne-text">辣椒、蒜、姜、葱</span></li><li id="ubcd5c0dc" data-lake-index-type="0"><span class="ne-text" style="background-color: #FBDE28">肉片</span><span class="ne-text">：将肉切成肉片，然后放入适量盐、酱油、生抽等腌制待用</span></li></ol></ol><ol start="3" class="ne-ol"><li id="ua55b3d2a" data-lake-index-type="0"><span class="ne-text">煮</span></li></ol><ol class="ne-list-wrap"><ol ne-level="1" class="ne-ol"><li id="u7d0ef418" data-lake-index-type="0"><span class="ne-text">爆香：锅里面放油烧一会，然后把小料放进去爆香</span></li><li id="ufe4ab957" data-lake-index-type="0"><span class="ne-text">成汤：加点水成汤，等烧一会</span></li><li id="u54a7e3f2" data-lake-index-type="0"><span class="ne-text">上述稍微沸腾可以在此处加一个</span><span class="ne-text" style="background-color: #FBDE28">鸡蛋</span></li><li id="uf69d0f04" data-lake-index-type="0"><span class="ne-text">将凉水中的面条下到锅中</span></li><li id="u37b3fe0e" data-lake-index-type="0"><span class="ne-text">加入</span><span class="ne-text" style="background-color: #FBDE28">青菜</span><span class="ne-text">等轻量蔬菜</span></li><li id="u7ef1cf47" data-lake-index-type="0"><span class="ne-text">调味：盐、味精（鸡精）、十三香等调味制品</span></li></ol></ol></div>]]></content>
      
      
      <categories>
          
          <category> 料理 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>《山茶文具店》小记</title>
      <link href="/essay/tegfte/"/>
      <url>/essay/tegfte/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="u3a5582c3" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/1484158/1653571677209-7e72abde-e202-4913-b4fc-4e89285d0779.jpeg" width="270" id="u836fe5f8" class="ne-image"></p><p id="u063179c3" class="ne-p"><span class="ne-text">前言：书中的代笔文字还有文具店在四季所渲染的氛围，很能让人安静下来。另外很多场景都像是自己以前读书，独自的对生活感悟的别种形式的外露……</span></p><h2 id="d4b37c9f"><span class="ne-text">夏</span></h2><p id="u3dd36323" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/1484158/1653570370540-3d102396-6f1f-45ca-a7dd-5951a5c05a4d.jpeg" width="401.9907531738281" id="flM7L" class="ne-image"><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/1484158/1653570419276-697b6192-1806-4de2-9667-0743f020a122.jpeg" width="398.98614501953125" id="uf11d2c4e" class="ne-image"></p><p id="ua5387e97" class="ne-p"><span class="ne-text">真诚且坦诚……</span></p><p id="u6eea89c6" class="ne-p"><span class="ne-text"></span></p><div class="ne-quote"><p id="ufad10353" class="ne-p"><span class="ne-text">夏日的夕阳把门外的巷子染成一片橘色。</span></p></div><p id="u3065b135" class="ne-p"><span class="ne-text"></span></p><div class="ne-quote"><p id="u8cbd818a" class="ne-p"><span class="ne-text">夏蝉在白天聒噪地叫个不停，入夜后便安静下来，四周一片寂静，简直就像身处深山秘境，只不过仍然闷热不已。</span></p></div><p id="u4a900465" class="ne-p"><span class="ne-text"></span></p><div class="ne-quote"><p id="u043208f1" class="ne-p"><span class="ne-text">“因为我自己写的话，一下子就会看出是小孩子写的。我只要让老师知道我的心意就好。婆婆告诉我，这里的阿嬷可以帮人写很出色的信。”</span></p></div><p id="ud0ecec50" class="ne-p"><span class="ne-text"></span></p><div class="ne-quote"><p id="uf00df4c8" class="ne-p"><span class="ne-text">“她为我写了一封打动我老公的情书，所以我们才会结婚哦。”</span></p></div><p id="u571e3bcf" class="ne-p"><span class="ne-text">文字的浪漫……以至于我现在就想去二餐打印店买一纸山师信封，书写起浪漫情话……</span></p><p id="ucee381b6" class="ne-p"><span class="ne-text"></span></p><div class="ne-quote"><p id="uece9be26" class="ne-p"><span class="ne-text">我忍不住冷静思考，为什么在这么热的天气里，我还要刻苦练习这些自己根本不喜欢的书法？打从出生起便一直闷在内心的愤怒和疑问，就像岩浆般一口气喷了出来，就连我自己也无法阻止。</span></p></div><p id="ufe7f8245" class="ne-p"><br></p><p id="u8f507211" class="ne-p"><span class="ne-text">桀</span></p><div class="ne-quote"><p id="u404df461" class="ne-p"><span class="ne-text">敬致关爱我们的各位：夏阳高照的季节来临，镰仓的绿意也更加蓬勃。不知各位是否别来无恙？在鹤冈八幡宫举行婚礼至今，转眼已过十五载，不禁感叹时光流逝如此匆匆。能在各位的见证下，于樱花飘舞的庄严气氛中共结连理，堪称人生之大幸。平日，我们各自努力工作；假日，则常偕同前往海边或山野健行。生活虽然平淡，但夫妻共同享受了日常的平凡幸福，我们都希望能随着岁月的累积，加深彼此的理解和情感。虽然我们无缘得子，但也因此邂逅了爱犬汉娜，我们视她如己出，疼爱有加。回想起来，带着汉娜一起去冲绳旅行的时光，是我们一家人无可取代的美好回忆。此次提笔，是为了向各位报告一件遗憾的事：我们在七月底解除了夫妻关系，正式离婚。虽然我们花费很长时间沟通，摸索是否能找到继续相处的方法；也曾请亲密的友人提供协助，努力寻求最完善的方式，希望走向圆满的结局。但是，前妻希望能与新的伴侣共度未来的人生，无悔活出自我的意志也相当坚定。最后，我们决定分道扬镳，各奔前程。虽然我们无法携手相伴到白头，但仍将默默支持彼此的第二人生。因此，如蒙各位认为我们为了追求幸福的人生，做出富有勇气的决定，我们将深感万幸。各位温暖地守护我们夫妻，如今却辜负了各位的期待，为此着实深感痛苦。衷心感谢各位至今为止的亲切和关爱，有幸和各位结缘，带给我们莫大的鼓励和安慰。虽然我们决定迈向不同的人生，但仍希望能够维持与各位之间的缘分，这也是我们的共同心愿。希望有朝一日，能笑着谈论今天。满怀感恩之心。敬颂崇祺</span></p></div><p id="uda19d251" class="ne-p"><span class="ne-text"></span></p><h2 id="fdf31ff3"><span class="ne-text">秋</span></h2><div class="ne-quote"><p id="uc7781e82" class="ne-p"><span class="ne-text">最近的天空已经有了秋天的味道。山茶文具店也到了差不多该使用火炉的时候，否则太冷了。</span></p></div><p id="ue2c6964c" class="ne-p"><br></p><p id="uc97892b1" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/1484158/1653571236427-fb03c188-941e-4200-a318-c0bb40656720.jpeg" width="366" id="u6ce68298" class="ne-image"></p><p id="u3bd18e88" class="ne-p"><span class="ne-text">作为曾经许诺的对象，我想看到这的反应不是遗憾，反而是喜极而泣……</span></p><p id="u5420a3bc" class="ne-p"><br></p><div class="ne-quote"><p id="u6430457b" class="ne-p"><span class="ne-text">用几乎快超出信封的大字写得很有气势。</span></p></div><p id="uc42d71d4" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/1484158/1653571439352-fa11a7d7-e50a-4a87-b775-b5254b726155.jpeg" width="430" id="u95115f11" class="ne-image"></p><p id="u972f33e4" class="ne-p"><span class="ne-text">这个手写正楷字真的好看。</span></p><p id="ua3614e66" class="ne-p"><br></p><p id="u5b5ed240" class="ne-p"><span class="ne-text">读书期间，写字最好看的往往不是学习最好的，而学习极好的同学，反而写的字，不怎么样。。</span></p><div class="ne-quote"><p id="uad2e3e8d" class="ne-p"><span class="ne-text">我一直以为，字能够反映书写者的人品，但这种认识并不正确。有不少人像花莲小姐一样，即使下了苦功，仍然无法写出漂亮的字。如果认为因为心丑才会字丑，未免太武断了。</span></p></div><p id="uad196e47" class="ne-p"><span class="ne-text"></span></p><p id="u398430bf" class="ne-p"><span class="ne-text">代笔这个职业，突然让我想到日本很多影视里面神女这一角色，千恋万花</span></p><div class="ne-quote"><p id="u7ab224f9" class="ne-p"><span class="ne-text">接着用右手轻轻握住花莲小姐的右手，闭着眼睛，像深呼吸般在卡片上写字。</span></p><p id="u1c2fa90c" class="ne-p"><span class="ne-text">当我缓缓睁开眼睛时，发现卡片上的字很陌生，简直不像出自我的手。决定用圆珠笔写这张卡片是正确的决定，从这些文字中，可以感受到花莲小姐的恭谨有礼和纯洁。我把写好的卡片装进信封。</span></p><p id="ud5a18a74" class="ne-p"><span class="ne-text">晚上七点多，花莲小姐再度来到山茶文具店。看起来质料很好的深蓝色大衣和白色围巾在她身上很好看。</span></p><p id="uaf2136af" class="ne-p"><span class="ne-text">“我呈现了这样的感觉……”</span></p><p id="ub5723d0e" class="ne-p"><span class="ne-text">我战战兢兢地递上卡片。花莲小姐一看到卡片，立刻欢呼起来。</span></p><p id="u9bcc617e" class="ne-p"><span class="ne-text">“简直就像我自己写的！谢谢你！”</span></p><p id="u9c7d60e4" class="ne-p"><span class="ne-text">她像少女般兴奋不已。</span></p></div><p id="u115ee3ee" class="ne-p"><span class="ne-text"></span></p><p id="uf6346e17" class="ne-p"><span class="ne-text">这就是典型的“少女字体”了，我影响里面，初中我的后桌还有高中一同学写的字就是这类型的</span></p><div class="ne-quote"><p id="uc27297e0" class="ne-p"><span class="ne-text">“我一直想写这样的字。”</span></p></div><p id="ua2fcc069" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1653622953005-24a78b92-4ed4-477d-8d79-8ce1638244e6.png" width="329.7750244140625" id="u2e939874" class="ne-image"></p><h2 id="w6g2f"><span class="ne-text">冬</span></h2><p id="ua012243b" class="ne-p"><span class="ne-text"></span></p><p id="udb726e07" class="ne-p"><span class="ne-text">等到以后，我的小屋门外也要种一棵大树</span></p><p id="u5cb3a4cf" class="ne-p"><span class="ne-text"></span></p><div class="ne-quote"><p id="ud0e61f16" class="ne-p"><span class="ne-text">据说山茶文具店门口的那棵山茶树，是用由比若宫的山茶树树枝扦插而来的。不知道是上代还是上上代，把被台风吹断的树枝带回家，试着种在家门口，没想到它竟牢牢地扎了根、长成了大树。</span></p></div><p id="u64cfecf6" class="ne-p"><span class="ne-text"></span></p><p id="uc3b64e45" class="ne-p"><span class="ne-text">她深深地爱着她父亲，激动且神秘……</span></p><div class="ne-quote"><p id="u80343284" class="ne-p"><span class="ne-text">“所以她吵着要回去。看到她那样，我真的很难过，忍不住想象她总是背着年纪还小的我们去查看信箱的样子。我猜那是无法让我们姐弟看到的、秘密的爱。”</span></p></div><p id="ud98031d1" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1653626050743-85c10c68-abc6-4c21-9f53-bc5a8943e3a9.png" width="356.8125" id="VWBdz" class="ne-image"></p><p id="u3e327b4b" class="ne-p"><span class="ne-text">人会成长，所写出的字也会有所成长，虽然不好说这个成长是朝着好的还是邋遢的，但，总归是成长</span></p><div class="ne-quote"><p id="u3365484e" class="ne-p"><span class="ne-text">一个人写的字会随着年岁增长渐渐成熟。即便是同一个人，小学时写的字，和高中时写的字当然不一样；二十多岁时所写的字，和四十多岁时所写的字也不一样。到了七八十岁，差异就更大了。就算是十几岁时写字圆滚滚的少女，变成老太太之后，当然也不会再写那样的字。文字，也会随着年龄变化。</span></p></div><p id="u880ec97e" class="ne-p"><br></p><h2 id="MhZg1"><span class="ne-text">春</span></h2><p id="u8b33dafe" class="ne-p"><span class="ne-text"></span></p><p id="u9b3d697b" class="ne-p"><span class="ne-text">代笔</span></p><div class="ne-quote"><p id="ud8f8688c" class="ne-p"><span class="ne-text">但我内心很犹豫，觉得是否该拒绝这个委托。代笔工作是为了协助他人得到幸福，这是我身为代笔人的坚持。更何况，有必要写伤害对方的信吗？然而，工作就是工作。从另一个角度思考，代笔人这份工作并不是做义工，眼前这位匿名小姐是客人，只要她高兴，那又何妨呢？两种完全相反的想法在内心天人交战，发出咔嚓咔嚓的声音。</span></p></div><p id="u0fdcb288" class="ne-p"><span class="ne-text"></span></p><p id="ubd9d6186" class="ne-p"><span class="ne-text">失去的是妻子，后悔所说过的话，可是，庆幸的是女儿还在身旁，妻子已不再人世……</span></p><div class="ne-quote"><p id="udef19c2b" class="ne-p"><span class="ne-text">“与其苦苦追寻失去的东西，还不如好好珍惜自己眼前拥有的东西。”</span></p></div><p id="u5b75b5c3" class="ne-p"><span class="ne-text"></span></p><p id="u2b1cf01e" class="ne-p"><span class="ne-text">这个场景，和《世界上所有的夜晚》文末那个夜晚是同样的，夜景一样，思绪一样……</span></p><div class="ne-quote"><p id="ue38e9ff0" class="ne-p"><span class="ne-text">小小的亮光穿越黑暗。是萤火虫。没错，每年都有萤火虫在这条河边飞舞。许多人都站在小桥上看萤火虫。</span></p></div><p id="u943d789c" class="ne-p"><span class="ne-text"></span></p><p id="u90fb3804" class="ne-p"><span class="ne-text"></span></p></div>]]></content>
      
      
      <categories>
          
          <category> 阅读 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript事件循环和异步编程</title>
      <link href="/blog/lz7xgx/"/>
      <url>/blog/lz7xgx/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="u47c8e8b4" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1653573417541-44275572-06ee-41fc-ab54-6683e2510450.png" width="1960" id="ude4d9e36" class="ne-image"></p><h2 id="bAXj8"><span class="ne-text">一、JS代码执行机制</span></h2><h3 id="YbZ5l"><span class="ne-text">JavaScript的单线程</span></h3><p id="b785073ad0b4241b17542f923c68bd89" class="ne-p"><span class="ne-text">单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。如果前一个任务耗时很长，后一个任务就不得不一直等着。这样所导致的问题是： 如果 JS 执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞的感觉。</span></p><h3 id="IF7ut"><span class="ne-text">同步任务和异步任务</span></h3><p id="175d9c82a2892ec08ad8c92559dfbb4e" class="ne-p"><span class="ne-text">单线程导致的问题就是后面的任务等待前面任务完成，如果前面任务很耗时（比如读取网络数据），后面任务不得不一直等待！！</span></p><p id="7c83c84c2c296316bc3f3c1cf7756e53" class="ne-p"><span class="ne-text" style="color: #F5222D">为了解决这个问题，利用</span><strong><span class="ne-text" style="color: #F5222D">多核 CPU 的计算能力</span></strong><span class="ne-text" style="color: #F5222D">，HTML5 提出 Web Worker 标准，允许 JavaScript 脚本创建多个线程，但是子线程完全受主线程控制。于是，JS 中出现了</span><strong><span class="ne-text" style="color: #F5222D">同步任务</span></strong><span class="ne-text" style="color: #F5222D">和</span><strong><span class="ne-text" style="color: #F5222D">异步任务</span></strong><span class="ne-text" style="color: #F5222D">。</span></p><p id="117599905a41f3d8f10cacf311ff90ce" class="ne-p"><br></p><p id="u09384c3b" class="ne-p"><span class="ne-text">JS中所有任务可以分成两种，一种是同步任务（synchronous），另一种是异步任务（asynchronous）。</span></p><ul class="ne-ul"><li id="ub267d26f" data-lake-index-type="0"><strong><span class="ne-text">【同步任务】</span></strong><span class="ne-text">指的是：在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务；</span></li><li id="u8624ac1a" data-lake-index-type="0"><strong><span class="ne-text">【异步任务】</span></strong><span class="ne-text">指的是：不进入主线程、而进入</span><strong><span class="ne-text">“任务队列”</span></strong><span class="ne-text">的任务，当主线程中的任务运行完了，才会将异步任务相关的回调函数从”任务队列”取出异步任务放入主线程执行。</span></li></ul><p id="ud8b66a6f" class="ne-p"><span class="ne-text">异步任务又分为宏任务和微任务</span></p><p id="u058036d7" class="ne-p"><span class="ne-text">宏任务</span></p><ul class="ne-ul"><li id="ud688c363" data-lake-index-type="0"><span class="ne-text">主代码块</span></li><li id="uc0b63834" data-lake-index-type="0"><span class="ne-text">setTimeout</span></li><li id="u5966078e" data-lake-index-type="0"><span class="ne-text">setInterval</span></li></ul><p id="ub77f1171" class="ne-p"><span class="ne-text">微任务</span></p><ul class="ne-ul"><li id="u335c6cec" data-lake-index-type="0"><span class="ne-text">process.nextTick ()</span></li><li id="u4793fdc8" data-lake-index-type="0"><span class="ne-text">Promise</span></li><li id="u178c2fe5" data-lake-index-type="0"><span class="ne-text">Object.observe</span></li></ul><h3 id="tDUjC"><span class="ne-text">事件循环机制</span></h3><p id="ub559a1fb" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/webp/1484158/1657425246544-000fdb98-cba1-4b29-83eb-97efba576a6c.webp" width="1280" id="u7367241e" class="ne-image"></p><ol class="ne-ol"><li id="u4bb87b57" data-lake-index-type="0"><span class="ne-text">碰到同步任务，就先执行执行栈中的同步任务</span></li></ol><div class="ne-quote"><p id="ucec7015d" class="ne-p"><span class="ne-text">遇到函数的嵌套调用就把函数压入栈内再依次“剥洋葱”</span></p></div><ol start="2" class="ne-ol"><li id="u7048d5b0" data-lake-index-type="0"><span class="ne-text">碰到异步任务就压入任务队列（异步任务分为宏任务和微任务）</span></li><li id="u8ac10e88" data-lake-index-type="0"><span class="ne-text">当前执行栈中的所有同步任务执行完毕，就将执行异步任务，异步任务执行原则“先微后宏”</span></li></ol><p id="u245b5a71" class="ne-p"><strong><span class="ne-text" style="color: #E8323C">由于主线程不断地重复获得任务、执行任务、再获取任务、再执行……，这种机制被称为事件循环（Event Loop）</span></strong></p><h3 id="CkHxP"><span class="ne-text">实例</span></h3><pre><code><code>const promise = new Promise((resolve, reject) =&gt; &#123;  // new 先行  console.log(1);  resolve(&quot;success&quot;);  console.log(2);&#125;);promise.then((data) =&gt; &#123;  // 微任务  console.log(data);  console.log(3);&#125;);console.log(4);</code></code></pre><pre><code><code>124success3</code></code></pre><pre><code><code>const promise1 = new Promise((resolve, reject) =&gt; &#123;  console.log(&quot;promise1&quot;);  resolve(&quot;resolve1&quot;);&#125;);const promise2 = promise1.then((res) =&gt; &#123;  console.log(res);&#125;);console.log(&quot;1&quot;, promise1);console.log(&quot;2&quot;, promise2);</code></code></pre><pre><code><code>promise11 Promise &#123; 'resolve1' &#125;2 Promise &#123; &lt;pending&gt; &#125;resolve1</code></code></pre><details class="lake-collapse"><summary id="u0950fa51"><span class="ne-text">测试代码</span></summary><pre><code><code>// setTimeout(()=&gt;&#123;//     console.log(1)//   &#125;,0)// new Promise((resolve) =&gt;&#123;//     console.log(2)//     resolve()//   &#125;).then(()=&gt;&#123; // 此时将then的内容放到微任务队列，然后执行同步代码 5//     console.log(3)//   &#125;).then(()=&gt;&#123;//     console.log(4)//   &#125;)//   console.log(5)<p>// setTimeout(() =&gt; &#123;<br>//     console.log(‘timer1’);<br>//     setTimeout(() =&gt; &#123;<br>//       console.log(‘timer3’)<br>//     &#125;, 0)<br>//   &#125;, 0)<br>// setTimeout(() =&gt; &#123;<br>//     console.log(‘timer2’)<br>//   &#125;, 0)<br>// console.log(‘start’)</p><p>// setTimeout(() =&gt; &#123;<br>//     console.log(‘timer1’);<br>//     Promise.resolve().then(() =&gt; &#123;<br>//       console.log(‘promise’)<br>//     &#125;)<br>//   &#125;, 0)<br>// setTimeout(() =&gt; &#123;<br>//     console.log(‘timer2’)<br>//   &#125;, 0)<br>// console.log(‘start’)</p><p>// const first = () =&gt; (new Promise((resolve, reject) =&gt; &#123;<br>//     console.log(3)</p><p>//     let p = new Promise((resolve, reject) =&gt; &#123;<br>//       console.log(7)<br>//       setTimeout(() =&gt; &#123;<br>//         console.log(5)<br>//         resolve(6) // 状态只会改变一次<br>//       &#125;, 0)<br>//       resolve(1)<br>//     &#125;)</p><p>//     resolve(2)<br>//     p.then((arg) =&gt; &#123;<br>//       console.log(arg)<br>//     &#125;)<br>//   &#125;))</p><p>// first().then((arg) =&gt; &#123;<br>//     console.log(arg)<br>//   &#125;)</p><p>// console.log(4) // 在1 2 之前执行，此时1 2都在微任务队列里面</p><p>// setTimeout(() =&gt; &#123;<br>//     console.log(&quot;0&quot;)<br>//   &#125;, 0)</p><p>// new Promise((resolve,reject)=&gt;&#123;<br>//     console.log(&quot;1&quot;)<br>//     resolve()<br>//   &#125;).then(()=&gt;&#123; // then碰到then，就将其全部放到微任务队列，再细致考虑<br>//     console.log(&quot;2&quot;)<br>//     new Promise((resolve,reject)=&gt;&#123;<br>//       console.log(&quot;3&quot;)<br>//       resolve()<br>//     &#125;).then(()=&gt;&#123;<br>//       console.log(&quot;4&quot;) // 先5后4 “队列”<br>//     &#125;).then(()=&gt;&#123;<br>//       console.log(&quot;5&quot;)<br>//     &#125;)<br>//   &#125;).then(()=&gt;&#123;<br>//     console.log(&quot;6&quot;)<br>//   &#125;)</p><p>// new Promise((resolve,reject)=&gt;&#123;<br>//     console.log(&quot;7&quot;)<br>//     resolve() //2<br>//   &#125;).then(()=&gt;&#123;<br>//     console.log(&quot;8&quot;)<br>//   &#125;)</p><p>// Promise.resolve().then(() =&gt; &#123;<br>//     console.log(‘promise1’);<br>//     const timer2 = setTimeout(() =&gt; &#123;<br>//       console.log(‘timer2’)<br>//     &#125;, 0)<br>//   &#125;);</p><p>// const timer1 = setTimeout(() =&gt; &#123;<br>//     console.log(‘timer1’)<br>//     Promise.resolve().then(() =&gt; &#123;<br>//       console.log(‘promise2’)<br>//     &#125;)<br>//   &#125;, 0)</p><p>// console.log(‘start’);</p><p>// const promise1 = new Promise((resolve, reject) =&gt; &#123;<br>//     setTimeout(() =&gt; &#123;<br>//       resolve(‘success’)<br>//     &#125;, 1000)<br>//   &#125;)<br>// const promise2 = promise1.then(() =&gt; &#123;<br>//     throw new Error(‘error!!!’)<br>//   &#125;)</p><p>// console.log(‘promise1’, promise1)<br>// console.log(‘promise2’, promise2)</p><p>// setTimeout(() =&gt; &#123;<br>//     console.log(‘promise1’, promise1)<br>//     console.log(‘promise2’, promise2)<br>// &#125;, 2000)</code><br></code></pre></p></details><h2 id="TmnIc"><span class="ne-text">异步编程</span></h2><ul class="ne-ul"><li id="ub668edc1" data-lake-index-type="0"><span class="ne-text">参照这里面的题来测验：</span><a href="https://juejin.cn/post/7050637649123475487" data-href="https://juejin.cn/post/7050637649123475487" class="ne-link"><span class="ne-text">靠做题</span><span class="ne-text">📝</span><span class="ne-text">来掌握Promise/async/await</span></a></li><li id="u81ed278c" data-lake-index-type="0"><span class="ne-text"></span><a href="https://www.zhihu.com/question/554682475/answer/2759371197" data-href="https://www.zhihu.com/question/554682475/answer/2759371197" class="ne-link"><span class="ne-text">请问为啥前端现在喜欢用await了？ - siki学院的回答 - 知乎</span></a></li></ul><h3 id="UtGum"><span class="ne-text">Promise</span></h3><ul class="ne-tl"><li checked="true" id="u91c55651" data-lake-index-type="0"><span class="ne-text">理解并能准确判断代码执行时机</span></li></ul><details class="lake-collapse"><summary id="u97ab30cf"><span class="ne-text">测试代码</span></summary><pre><code><code>/** * Promise：resolve reject then catch finally */// let p1 = new Promise((resolve, reject) =&gt; &#123;//     setTimeout(() =&gt; &#123;//       resolve('success')//     &#125;,1000)//   &#125;)  <p>//   let p2 = new Promise((resolve, reject) =&gt; &#123;<br>//     setTimeout(() =&gt; &#123;<br>//       reject(‘failed’)<br>//     &#125;, 500)<br>//   &#125;)</p><p>//   Promise.race([p1, p2]).then((result) =&gt; &#123;<br>//     console.log(result)<br>//   &#125;).catch((error) =&gt; &#123;<br>//     console.log(error)  // 打开的是 ‘failed’<br>// &#125;)</p><p>// function test(resolve, reject) &#123;<br>//   let timeOut = Math.random() * 2;<br>//   console.log(‘set timeout to: ‘ + timeOut + ‘ seconds.’);<br>//   setTimeout(function () &#123;<br>//       if (timeOut &lt; 1) &#123;<br>//         console.log(‘call resolve()…’);<br>//         resolve(‘200 OK’);<br>//       &#125;<br>//       else &#123;<br>//         console.log(‘call reject()…’);<br>//         reject(‘timeout in ‘ + timeOut + ‘ seconds.’);<br>//       &#125;<br>//   &#125;, timeOut * 1000);<br>// &#125;</p><p>// let p1 = new Promise(test);<br>// let p2 = p1.then(function (result) &#123;<br>//     console.log(‘成功：’ + result);<br>// &#125;);<br>// let p3 = p2.catch(function (reason) &#123;<br>//     console.log(‘失败：’ + reason);<br>// &#125;);</p><p>// function test(resolve, reject) &#123;<br>//   let timeOut = Math.random() * 2;<br>//   console.log(‘set timeout to: ‘ + timeOut + ‘ seconds.’);<br>//   setTimeout(function () &#123;<br>//       if (timeOut &lt; 1) &#123;<br>//         console.log(‘call resolve()…’);<br>//         resolve(‘200 OK’);<br>//       &#125;<br>//       else &#123;<br>//         console.log(‘call reject()…’);<br>//         reject(‘timeout in ‘ + timeOut + ‘ seconds.’);<br>//       &#125;<br>//   &#125;, timeOut * 1000);<br>// &#125;</p><p>// new Promise(test)<br>// .then(function (result) &#123;<br>//   console.log(‘成功：’ + result);<br>// &#125;)<br>// .catch(function (reason) &#123;<br>//   console.log(‘失败：’ + reason);<br>// &#125;)</p><p>// const promise = new Promise((resolve, reject) =&gt; &#123;<br>//     reject(&quot;error&quot;);<br>//     resolve(&quot;success2&quot;); // 需要return才能传递结果<br>//   &#125;);<br>//   promise.then(res =&gt; &#123;<br>//       console.log(&quot;then1: &quot;, res); // 需要return才能往下传递结果<br>//   &#125;).then(res =&gt; &#123;<br>//       console.log(&quot;then2: &quot;, res);<br>//   &#125;).catch(err =&gt; &#123;<br>//       console.log(&quot;catch: &quot;, err);<br>//   &#125;).then(res =&gt; &#123;<br>//       console.log(&quot;then3: &quot;, res); // undefined catch也会返回promise对象<br>//   &#125;)</p><p>// Promise.resolve(1)<br>//   .then(res =&gt; &#123;<br>//     console.log(res);<br>//     return 2; // return 2会被包装成resolve(2)<br>//   &#125;)<br>//   .catch(err =&gt; &#123;<br>//     return 3;<br>//   &#125;)<br>//   .then(res =&gt; &#123;<br>//     console.log(res);<br>//   &#125;);</p><p>// const promise = new Promise((resolve, reject) =&gt; &#123;<br>//     setTimeout(() =&gt; &#123;<br>//       console.log(‘timer’)<br>//       resolve(‘success’)<br>//     &#125;, 1000)<br>//   &#125;)<br>//   const start = Date.now();<br>//   promise.then(res =&gt; &#123;<br>//     console.log(res, Date.now() - start)<br>//   &#125;)<br>//   promise.then(res =&gt; &#123;<br>//     console.log(res, Date.now() - start) // 两个字几乎一样，状态一旦改变，就不会在变动了<br>//   &#125;)</p><p>//   Promise.resolve().then(() =&gt; &#123;<br>//     return new Error(‘error!!!’) // 被包裹成了return Promise.resolve(new Error(‘error!!!’))<br>//   &#125;).then(res =&gt; &#123;<br>//     console.log(&quot;then: &quot;, res)<br>//   &#125;).catch(err =&gt; &#123;<br>//     console.log(&quot;catch: &quot;, err)<br>//   &#125;)<br></code><br></code></pre></p><p id="u3de07eae" class="ne-p"><br></p><pre><code><code>/** * then链式调用 */// function runAsync1()&#123;//   var p = new Promise(function(resolve, reject)&#123;//       //做一些异步操作//       setTimeout(function()&#123;//           console.log('异步任务1执行完成');//           resolve('随便什么数据1');//       &#125;, 2000);//   &#125;);//   return p;// &#125;// function runAsync2()&#123;//   var p = new Promise(function(resolve, reject)&#123;//       //做一些异步操作//       setTimeout(function()&#123;//           console.log('异步任务2执行完成');//           resolve('随便什么数据2');//       &#125;, 1000);//   &#125;);//   return p;// &#125;// function runAsync3()&#123;//   var p = new Promise(function(resolve, reject)&#123;//       //做一些异步操作//       setTimeout(function()&#123;//           console.log('异步任务3执行完成');//           resolve('随便什么数据3');//       &#125;, 1000);//   &#125;);//   return p;// &#125;<p>// runAsync1()<br>// .then(function(data)&#123;<br>//     console.log(data);<br>//     return runAsync2();<br>// &#125;)<br>// .then(function(data)&#123;<br>//     console.log(data);<br>//     return runAsync3();<br>// &#125;)<br>// .then(function(data)&#123;<br>//     console.log(data);<br>// &#125;);<br></code><br></code></pre></p><p id="uda568f1f" class="ne-p"><br></p><pre><code><code>/** * all: 所有异步任务完成执行then * race：执行快的直接跳出 *///  function runAsync (x) &#123;//     const p = new Promise(r =&gt; setTimeout(() =&gt; r(x, console.log(x)), 1000))//     return p// &#125;// Promise.all([runAsync(1), runAsync(2), runAsync(3)]) // 参数数组都是promise实例，如果不是强制包装//   .then(res =&gt; console.log(res))<p>//   function runAsync (x) &#123;<br>//     const p = new Promise(r =&gt; setTimeout(() =&gt; r(x, console.log(x)), 1000))<br>//     return p<br>//   &#125;<br>//   function runReject (x) &#123;<br>//     const p = new Promise((res, rej) =&gt; setTimeout(() =&gt; rej(<code>Error: $&#123;x&#125;</code>, console.log(x)), 1000 * x))<br>//     return p<br>//   }<br>//   Promise.all([runAsync(1), runReject(4), runAsync(3), runReject(2)])<br>//     .then(res =&gt; console.log(res))<br>//     .catch(err =&gt; console.log(err))</p><p>// let p1 = new Promise((resolve, reject) =&gt; {<br>//     setTimeout(() =&gt; {<br>//       resolve(‘success’)<br>//     },1000)<br>//   })</p><p>//   let p2 = new Promise((resolve, reject) =&gt; {<br>//     setTimeout(() =&gt; {<br>//       reject(‘failed’)<br>//     }, 3000)<br>//   })</p><p>//   Promise.race([p1, p2]).then((result) =&gt; {<br>//     console.log(result)<br>//   }).catch((error) =&gt; {<br>//     console.log(error)  // 打开的是 ‘success’<br>// })<br></code><br></code></pre></p></details><ul class="ne-tl"><li id="u390413e0" data-lake-index-type="0"><span class="ne-text">手写Promise api</span></li></ul><h3 id="zCwWK"><span class="ne-text">Async、await</span></h3><p id="ub9abef9d" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1665821781199-5e03f0f2-b6c3-405e-a5e9-6071e66be32d.png" width="1400" id="u884cd2d4" class="ne-image"></p><p id="u45cb7189" class="ne-p"><br></p><p id="u97cd96d5" class="ne-p"><span class="ne-text">前言：Vue请求接口多是异步操作数据，我们一般会用then、catch来进行链式获取接口数据，除此之外还可以使用Async、Await这个方式来执行异步代码，待接口数据请求完成，再进行下面的逻辑执行。但是上述情况一个是会陷入“回调地狱”，而且请求失败所获得的数据不好获取处理，这个时候使用Promise来封装返回的数据就很好用了，不仅如此，这种形式也有利于传递接口给SDK，具体代码如下：</span></p><p id="u8ecd33bf" class="ne-p"><span class="ne-text"></span></p><pre><code><code>async getData(id) &#123;  ···  return new Promise((resolve, reject) =&gt; &#123;    getInterfaceData(&#123; param: id &#125;)      .then((res) =&gt; &#123;        ···        resolve(res.data);      &#125;)      .catch((err) =&gt; &#123;        ···        reject(new Error(err));      &#125;);  &#125;);&#125;,<p>const data = getData(‘xxx’);</code><br></code></pre></p><p id="u7526ecaf" class="ne-p"><span class="ne-text">await可以看成是Promise的语法糖（实际上是Generate的语法糖），效果和Promise的回调地狱一样，只是代码看起来好看点。</span></p><details class="lake-collapse"><summary id="u7781ab15"><span class="ne-text">测试代码</span></summary><pre><code><code>/** * async await */<p>//  async function fn () &#123;<br>//     // return await 123<br>//     // 等同于<br>//     return 123<br>//   &#125;<br>//   fn().then(res =&gt; console.log(res))<br>//   console.log(fn)</p><p>// async function async1() &#123;<br>//     console.log(&quot;async1 start&quot;);<br>//     await async2();<br>//     console.log(&quot;async1 end&quot;);<br>//   &#125;<br>// async function async2() &#123;<br>//     console.log(&quot;async2&quot;);<br>//   &#125;<br>// async1();<br>// console.log(‘start’)</p><p>// async function async1() &#123;<br>//     console.log(&quot;async1 start&quot;);<br>//     await async2(); // 紧跟着await后面的语句相当于放到了new Promise中，下一行及之后的语句相当于放在Promise.then中<br>//     console.log(&quot;async1 end&quot;);<br>//   &#125;<br>// async function async2() &#123;<br>//     setTimeout(() =&gt; &#123;<br>//       console.log(‘timer’)<br>//     &#125;, 0)<br>//     console.log(&quot;async2&quot;);<br>//   &#125;<br>// async1();<br>// console.log(&quot;start&quot;</p><p>// async function async1() &#123;<br>//   console.log(&quot;async1 start&quot;);<br>//   await async2();<br>//   console.log(&quot;async1 end&quot;);<br>//   setTimeout(() =&gt; &#123;<br>//     console.log(‘timer1’)<br>//   &#125;, 0)<br>// &#125;</p><p>// async function async2() &#123;<br>//   setTimeout(() =&gt; &#123;<br>//     console.log(‘timer2’)<br>//   &#125;, 0)<br>//   console.log(&quot;async2&quot;);<br>// &#125;</p><p>// async1();</p><p>// setTimeout(() =&gt; &#123;<br>//   console.log(‘timer3’)<br>// &#125;, 0)</p><p>// console.log(&quot;start&quot;)<br></code><br></code></pre></p></details><h3 id="X8bdj"><span class="ne-text">综合</span></h3><pre><code><code>async function a1() &#123;  console.log('a1 start')  await a2()  console.log('a1 end')&#125;async function a2() &#123;  console.log('a2')&#125;<p>console.log(‘script start’)</p><p>setTimeout(() =&gt; &#123;<br>  console.log(‘setTimeout’)<br>&#125;, 0)</p><p>Promise.resolve().then(() =&gt; &#123;<br>  console.log(‘promise1’)<br>&#125;)</p><p>a1()</p><p>let promise2 = new Promise(resolve =&gt; &#123;<br>  resolve(‘promise2.then’)<br>  console.log(‘promise2’)<br>&#125;)</p><p>promise2.then(res =&gt; &#123;<br>  console.log(res)<br>  Promise.resolve().then(() =&gt; &#123;<br>    console.log(‘promise3’)<br>  &#125;)<br>&#125;)<br>console.log(‘script end’)</p><p>/** 第一次做错的结果<br>script start<br>a1 start<br>a2<br>promise1<br>a1 end<br>promise2<br>script end<br>promise2.then<br>promise3<br>setTimeout<br> */</p><p>/** 正确结果<br>script start<br>a1 start<br>a2<br>promise2<br>script end<br>promise1<br>a1 end<br>promise2.then<br>promise3<br>setTimeout<br> */</code><br></code></pre></p><h2 id="AaYEl"><span class="ne-text">参考</span></h2><ul class="ne-ul"><li id="ud7d904d0" data-lake-index-type="0"><a href="https://juejin.cn/post/6844903832388894727" data-href="https://juejin.cn/post/6844903832388894727" target="_blank" class="ne-link"><span class="ne-text">理解JavaScript概念系列--异步任务</span></a></li><li id="uf13c38a9" data-lake-index-type="0"><a href="https://juejin.cn/post/6844903760280420366" data-href="https://juejin.cn/post/6844903760280420366" target="_blank" class="ne-link"><span class="ne-text">JS 异步编程六种方案</span></a></li><li id="u6f67f941" data-lake-index-type="0"><a href="https://juejin.cn/post/6962312899960242213" data-href="https://juejin.cn/post/6962312899960242213" class="ne-link"><span class="ne-text">微任务/宏任务和同步/异步之间的关系</span></a></li><li id="u8a1e4f3c" data-lake-index-type="0"><a href="https://www.cnblogs.com/lvdabao/p/es6-promise-1.html" data-href="https://www.cnblogs.com/lvdabao/p/es6-promise-1.html" target="_blank" class="ne-link"><span class="ne-text">大白话讲解Promise（一）</span></a></li><li id="u4f9ab938" data-lake-index-type="0"><a href="https://www.bilibili.com/video/BV1kf4y1U7Ln" data-href="https://www.bilibili.com/video/BV1kf4y1U7Ln" class="ne-link"><span class="ne-text">2分钟了解 JavaScript Event Loop | 面试必备</span></a></li><li id="u4c2350d7" data-lake-index-type="0"><a href="https://juejin.cn/post/7050637649123475487" data-href="https://juejin.cn/post/7050637649123475487" class="ne-link"><span class="ne-text">靠做题</span><span class="ne-text">📝</span><span class="ne-text">来掌握Promise/async/await</span></a></li><li id="ufa03a3cb" data-lake-index-type="0"><a href="https://www.cnblogs.com/nana-share/p/9187997.html" data-href="https://www.cnblogs.com/nana-share/p/9187997.html" class="ne-link"><span class="ne-text">javascript 异步操作，串形执行，并行执行 - 小苏打00 - 博客园</span></a></li></ul></div>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
          <category> JavaScript </category>
          
          <category> ECMAScript </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>客户端检测</title>
      <link href="/blog/gnyhrv/"/>
      <url>/blog/gnyhrv/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="u0da261e9" class="ne-p"><span class="ne-text">前言：用于客户端检测的工具函数记录</span></p><h3 id="XNybz"><span class="ne-text">是否为IOS设备</span></h3><pre><code>let isIos = () =&gt; &#123;  var u = navigator.userAgent  if (u.indexOf('Android') &gt; -1 || u.indexOf('Linux') &gt; -1) &#123;    //安卓手机    // return &quot;Android&quot;;    return false  &#125; else if (u.indexOf('iPhone') &gt; -1) &#123;    //苹果手机    // return &quot;iPhone&quot;;    return true  &#125; else if (u.indexOf('iPad') &gt; -1) &#123;    //iPad    // return &quot;iPad&quot;;    return false  &#125; else if (u.indexOf('Windows Phone') &gt; -1) &#123;    //winphone手机    // return &quot;Windows Phone&quot;;    return false  &#125; else &#123;    return false  &#125;&#125;</code></pre><h3 id="Tp09f"><span class="ne-text">是否为PC设备</span></h3><pre><code>let isPC = () =&gt; &#123;  //是否为PC端  var userAgentInfo = navigator.userAgent  var Agents = [    'Android',    'iPhone',    'SymbianOS',    'Windows Phone',    'iPad',    'iPod',  ]  var flag = true  for (var v = 0; v &lt; Agents.length; v++) &#123;    if (userAgentInfo.indexOf(Agents[v]) &gt; 0) &#123;      flag = false      break    &#125;  &#125;  return flag&#125;</code></pre><h3 id="wNkaL"><span class="ne-text">浏览器类型</span></h3><pre><code>let browserType = () =&gt; &#123;  var userAgent = navigator.userAgent //取得浏览器的userAgent字符串  var isOpera = userAgent.indexOf('Opera') &gt; -1 //判断是否Opera浏览器  var isIE =      userAgent.indexOf('compatible') &gt; -1 &amp;&amp;      userAgent.indexOf('MSIE') &gt; -1 &amp;&amp;      !isOpera //判断是否IE浏览器  var isIE11 =      userAgent.indexOf('Trident') &gt; -1 &amp;&amp; userAgent.indexOf('rv:11.0') &gt; -1  var isEdge = userAgent.indexOf('Edge') &gt; -1 &amp;&amp; !isIE //判断是否IE的Edge浏览器  var isFF = userAgent.indexOf('Firefox') &gt; -1 //判断是否Firefox浏览器  var isSafari =      userAgent.indexOf('Safari') &gt; -1 &amp;&amp; userAgent.indexOf('Chrome') == -1 //判断是否Safari浏览器  var isChrome =      userAgent.indexOf('Chrome') &gt; -1 &amp;&amp; userAgent.indexOf('Safari') &gt; -1 //判断Chrome浏览器<p>  if (isIE) &#123;<br>    var reIE = new RegExp(‘MSIE (\d+\.\d+);’)<br>    reIE.test(userAgent)<br>    var fIEVersion = parseFloat(RegExp[‘$1’])<br>    if (fIEVersion == 7) return ‘IE7’<br>    else if (fIEVersion == 8) return ‘IE8’<br>    else if (fIEVersion == 9) return ‘IE9’<br>    else if (fIEVersion == 10) return ‘IE10’<br>    else return ‘IE7以下’ //IE版本过低<br>  &#125;<br>  if (isIE11) return ‘IE11’<br>  if (isEdge) return ‘Edge’<br>  if (isFF) return ‘FF’<br>  if (isOpera) return ‘Opera’<br>  if (isSafari) return ‘Safari’<br>  if (isChrome) return ‘Chrome’<br>&#125;<br></code></pre></p><p id="u03ce0130" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1653026051837-a36a45e0-2b92-48d9-8b88-63c35e2babd2.png" width="369.99998529752156" id="ucbd2b3d7" class="ne-image"></p></div>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
          <category> JavaScript </category>
          
          <category> BOM </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>小满：故人叹物</title>
      <link href="/essay/avyy9v/"/>
      <url>/essay/avyy9v/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="u4b0d8d20" class="ne-p"><strong><span class="ne-text">物质</span></strong></p><p id="ua70271b8" class="ne-p"><span class="ne-text">我好像对物质没有太多的追求</span></p><p id="u21579c9c" class="ne-p"><span class="ne-text">努力一份好工作，也只是让自己不成为一个无能的人罢了</span></p><p id="u3718dd8b" class="ne-p"><span class="ne-text">在家人朋友想要的时候，无能会让人变得无比遗憾</span></p><p id="u6261cdee" class="ne-p"><span class="ne-text">我不想让所有的不利因素都归咎于无能之下</span></p><p id="ub7baf720" class="ne-p"><span class="ne-text">没有太多的物质追求，只求爱我我爱的人过的开心就好</span></p><p id="u1dc90ba2" class="ne-p"><span class="ne-text"></span></p><p id="u3d941a94" class="ne-p"><strong><span class="ne-text">相处</span></strong></p><p id="uadbd427d" class="ne-p"><span class="ne-text"> 用到理科的取反、就简、取极限原则</span></p><p id="u739267d4" class="ne-p"><span class="ne-text">与人相处也可以定义成如何和你讨厌的人相处</span></p><p id="u231730c4" class="ne-p"><span class="ne-text">懂得了这个</span></p><p id="uda2bd5bf" class="ne-p"><span class="ne-text">很多事情就变得明朗起来了</span></p><p id="u8b509d99" class="ne-p"><span class="ne-text"></span></p><p id="u93a72975" class="ne-p"><strong><span class="ne-text">成长</span></strong></p><p id="uaa460629" class="ne-p"><span class="ne-text">很多时候，如果不是因为一件大事</span></p><p id="u8d704de3" class="ne-p"><span class="ne-text">一个人的成长确实是根据时间、环境来决定的</span></p><p id="u8ab0b2d2" class="ne-p"><span class="ne-text">很多时候我就会想成长和成熟的区别</span></p><p id="ubc1131ce" class="ne-p"><span class="ne-text">我的答案是：没有区别</span></p><p id="ub4dc793f" class="ne-p"><span class="ne-text">也可以说成两者互为充要条件吧</span></p><p id="uf2e5220c" class="ne-p"><span class="ne-text"></span></p><p id="u4469a85d" class="ne-p"><strong><span class="ne-text">没有意义的事情</span></strong></p><p id="u3644fc4b" class="ne-p"><span class="ne-text">如果你所做的所有事情都是没有意义的。</span></p><p id="ucc2ecd3f" class="ne-p"><span class="ne-text">当你做了一些事情，到了一定时候</span></p><p id="u7c5ab5e2" class="ne-p"><span class="ne-text">你发现</span></p><p id="ufa655cb3" class="ne-p"><span class="ne-text">你曾经做过的所有事情</span></p><p id="u90a28096" class="ne-p"><span class="ne-text">都是没有意义的</span></p><p id="u1428405f" class="ne-p"><span class="ne-text">是多么的孤寂</span></p><p id="uf9dc6c53" class="ne-p"><span class="ne-text"></span></p></div>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript浅拷贝深拷贝实现</title>
      <link href="/blog/lwi9wr/"/>
      <url>/blog/lwi9wr/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h2 id="sEWoQ"><span class="ne-text">原始值和引用值</span></h2><p id="be789bab58359dda0d9df532eb85cd7a" class="ne-p"><span class="ne-text">这里面Java和JavaScript都是只有引用的概念，但是在C/C++里面，就有指针的概念</span></p><p id="185ad2ff8b1c9fccb24c3ec65e95156f" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1617868682681-90191ec3-c5b2-415f-9e38-df2706301e0c.png" width="465.5" id="dmTBK" class="ne-image"></p><ul class="ne-ul"><li id="u7ae02f1b"><span class="ne-text">原始值： </span><strong><span class="ne-text">存储在栈中的简单数据段</span></strong><span class="ne-text">，即他们的值直接存储在变量访问的位置。</span></li></ul><p id="u4c8c2b5b" class="ne-p"><span class="ne-text">包括：undefined、null、boolean、number、string、symbol</span></p><p id="u2f8d3de3" class="ne-p"><span class="ne-text"></span></p><ul class="ne-ul"><li id="u1cc91305"><span class="ne-text">引用值：</span><strong><span class="ne-text">存储在堆中的对象</span></strong><span class="ne-text">，即存储在变量处的值是一个指针，只想存储对象的内存处。</span></li></ul><p id="uc6a34d30" class="ne-p"><span class="ne-text">包括：object、array、function等</span></p><p id="u602c0ed7" class="ne-p"><span class="ne-text"></span></p><ul class="ne-ul"><li id="ud38b6f2e"><span class="ne-text">两者的区别：</span></li></ul><p id="u02a3d07c" class="ne-p"><span class="ne-text">原始变量及他们的值储存在栈中，当把一个原始变量传递给另一个原始变量时，是把一个栈房间的东西复制到另一个栈房间，且这两个原始变量互不影响。</span><strong><span class="ne-text">引用值是把引用变量的名称储存在栈中，但是把其实际对象储存在堆中</span></strong><span class="ne-text">，且存在一个指针由变量名指向储存在堆中的实际对象，当把引用对象传递给另一个变量时，复制的其实是指向实际对象的指针，此时两者指向的是同一个数据，若通过方法改变其中一个变量的值，则访问另一个变量时，其值也会随之加以改变；但若不是通过方法而是通过重新赋值，此时，相当于重新开了一个房间，该值的原指针改变，则另外一个值不会随他的改变而改变。</span></p><pre><code>let s = '基本类型'let s_test = ss_test = '改变之后不影响s'console.log(s)console.log(s_test)<p>let arr = [‘原始数组值’]<br>arr_test = arr<br>arr_test[0] = ‘改变值’<br>console.log(arr)<br>console.log(arr_test)</p><p>//基本类型<br>//改变之后不影响s<br>//[ ‘改变值’ ]<br>//[ ‘改变值’ ]<br></code></pre></p><ul class="ne-ul"><li id="570fd75c2e87aa222daa905fbf6ce98d"><span class="ne-text">参考：</span><a href="https://blog.csdn.net/u012443286/article/details/79496742" data-href="https://blog.csdn.net/u012443286/article/details/79496742" target="_blank" class="ne-link"><span class="ne-text">谈谈JavaScript中的变量、指针和引用</span></a></li></ul><h2 id="iEowI"><span class="ne-text">深拷贝与浅拷贝 </span></h2><h3 id="ZYo3B"><span class="ne-text">区分概念</span></h3><ul class="ne-ul"><li id="ube942d08"><span class="ne-text">浅拷贝：直接赋值，还是指向同一个堆</span></li><li id="u9305c0f0"><span class="ne-text">深拷贝：相当于重新创建一个对象，新开存储空间</span></li><li id="u1bfcb188"><span class="ne-text">参考：</span><a href="https://segmentfault.com/a/1190000016440069" data-href="https://segmentfault.com/a/1190000016440069" class="ne-link"><span class="ne-text">js浅拷贝与深拷贝方法</span></a></li></ul><p id="ud233259a" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1651305177480-c971984f-5aa2-48af-9d4b-3eee50afffee.png" width="291" id="u19a4acf0" class="ne-image"><span class="ne-text">、</span></p><h3 id="UY983"><span class="ne-text">浅拷贝实现</span></h3><ol class="ne-ol"><li id="u6df7d29e"><span class="ne-text">直接等号赋值</span></li></ol><pre><code>let obj = &#123;  ss: 'ss',  hh: 'hh',&#125;<p>let obj_qian = obj<br>obj_qian.ss = ‘sss’<br>obj_qian.hh = ‘hhh’<br>console.log(obj) //&#123; ss: ‘sss’, hh: ‘hhh’ &#125;<br>console.log(obj_qian) //&#123; ss: ‘sss’, hh: ‘hhh’ &#125;<br></code></pre></p><h3 id="qhGMP"><span class="ne-text">深拷贝实现</span></h3><ol class="ne-ol"><li id="ubad15add"><span class="ne-text">直接创建一个同类型的数据结构，然后将原值一个个复制过来（数组）</span></li><li id="ue460b0a1"><span class="ne-text">JSON方法（对象）</span></li></ol><pre><code>let obj = &#123;  ss: 'ss',  hh: 'hh',&#125;<p>let obj_shen_JSON = JSON.parse(JSON.stringify(obj))<br>obj_shen_JSON.ss = ‘sssss’<br>obj_shen_JSON.hh = ‘hhhhh’<br>console.log(obj) //&#123; ss: ‘ss’, hh: ‘hh’ &#125;<br>console.log(obj_shen_JSON) // &#123; ss: ‘sssss’, hh: ‘hhhhh’ &#125;<br></code></pre></p><h3 id="uFYnE"><span class="ne-text">手写深拷贝</span></h3><pre><code>let clone = target =&gt; &#123;  if (typeof target === 'object') &#123;    let cloneTarget = Array.isArray(target) ? [] : &#123;&#125;    for (const key in target) &#123;      cloneTarget[key] = clone(target[key])    &#125;    return cloneTarget  &#125; else &#123;    return target  &#125;&#125;<p>let obj_1 = &#123;<br>  c: ‘c’,<br>  d: &#123;<br>    d1: ‘d1’,<br>    d2: ‘d2’,<br>  &#125;,<br>&#125;<br>let obj_my = clone(obj_1)<br>obj_1.c = ‘ccccccc’<br>obj_1.d.d1 = ‘dsdddddddd’<br>console.log(obj_1)<br>console.log(obj_my)<br></code></pre></p><p id="u7d570bdc" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1652416167805-60ef8c07-9bba-4d43-a2e2-349b986c3c35.png" width="454.1666486197055" id="u1714696c" class="ne-image"></p><h3 id="zkjl4"><span class="ne-text">Object.assign({}, obj)</span></h3><ul class="ne-ul"><li id="u2318572f"><strong><span class="ne-text">assign既可以是深拷贝，也可以是浅拷贝</span></strong></li></ul><ul class="ne-ul"><li id="ud6dd0dff"><span class="ne-text">Object.assign() 方法用于将所有可枚举属性的值从一个或多个源对象分配到目标对象。它将返回目标对象。</span></li><li id="u7f8ba952"><span class="ne-text">对于Object.assign()而言，如果对象的属性值为简单类型（string，number），通过Object.assign({},srcobj);得到的新对象为深拷贝；如果属性值为对象或其他引用类型，那对于这个对象而言其实是浅拷贝的</span></li></ul><pre><code>let obj = &#123;  a: 'a',  b: 'b',&#125;<p>let obj_deep = Object.assign(&#123;&#125;, obj)<br>obj.a = ‘aa’<br>console.log(obj)<br>console.log(obj_deep)</p><p>console.log(‘——————————–’)<br>let obj_obj = &#123;<br>  c: ‘c’,<br>  d: &#123;<br>    d1: ‘d1’,<br>    d2: ‘d2’,<br>  &#125;,<br>&#125;</p><p>let obj_qian = Object.assign(&#123;&#125;, obj_obj)<br>obj_obj.c = ‘cc’<br>obj_obj.d.d1 = ‘d1111’<br>console.log(obj_obj)<br>console.log(obj_qian)<br></code></pre></p><p id="u3956ee6e" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1652415857368-38e9203a-1178-4fc4-b53d-a6059c212ad0.png" width="421.6666499111394" id="u6b2eae5b" class="ne-image"></p></div>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
          <category> JavaScript </category>
          
          <category> ECMAScript </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>442. 数组中重复的数据🔖数组🔖哈希表</title>
      <link href="/blog/cp993p/"/>
      <url>/blog/cp993p/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><ul class="ne-ul"><li id="u76be6687"><a href="https://leetcode-cn.com/problems/find-all-duplicates-in-an-array/" data-href="https://leetcode-cn.com/problems/find-all-duplicates-in-an-array/" target="_blank" class="ne-link"><span class="ne-text">https://leetcode-cn.com/problems/find-all-duplicates-in-an-array/</span></a></li></ul><p id="ud3fca973" class="ne-p"><span class="ne-text"></span></p><h3 id="Q81xz"><span class="ne-text">暴力解法</span></h3><pre><code>/** * @param &#123;number[]&#125; nums * @return &#123;number[]&#125; */var findDuplicates = function(nums) &#123;    let arr =[]    let result =[]    nums.forEach(data=&gt;&#123;        arr.includes(data) ? result.push(data) : arr.push(data)    &#125;)    return result&#125;;</code></pre><p id="u4d402b58" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1652015297299-44ac1ea9-f775-483d-b762-d57c71ff32c9.png" width="629.9999749660502" id="u730a2960" class="ne-image"></p><h3 id="BCCAk"><span class="ne-text">哈希表</span></h3><pre><code>/** * @param &#123;number[]&#125; nums * @return &#123;number[]&#125; */var findDuplicates = function(nums) &#123;  const map = new Map()  const arr = []<p>  for(let i = 0; i &lt; nums.length; i++) &#123;<br>    if (map.has(nums[i])) &#123;<br>      arr.push(nums[i])<br>      map.delete(nums[i])<br>    &#125; else &#123;<br>      map.set(nums[i])<br>    &#125;<br>  &#125;</p><p>  return arr<br>&#125;;<br></code></pre></p><p id="u93e02786" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1652015256459-e3d10aa5-79a4-4ea5-b8c2-edb2ffd6abe1.png" width="626.6666417651716" id="ue83dc54e" class="ne-image"></p></div>]]></content>
      
      
      <categories>
          
          <category> 计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 📶线结构：字符串-数组-栈-队列 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>人鬼如梦</title>
      <link href="/essay/otaot9/"/>
      <url>/essay/otaot9/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="u79092823" class="ne-p"><span class="ne-text">不知什么时候，我特别喜欢梦这个意象</span></p><p id="u3e51b264" class="ne-p"><span class="ne-text">人鬼殊途，却是美好的意境</span></p><p id="u74a9daeb" class="ne-p"><span class="ne-text">醒来一无所有</span></p><p id="u64ba1061" class="ne-p"><span class="ne-text">我宁愿生活一个小小梦里面，快乐纯真的守护</span></p><p id="u20fa5a6b" class="ne-p"><span class="ne-text">只守护，不求功与名</span></p><p id="u338e73c1" class="ne-p"><span class="ne-text">只愿守护所爱</span></p><p id="u7a03d462" class="ne-p"><span class="ne-text">人鬼殊途，却也美好梦一场</span></p><p id="u067baa19" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/1484158/1651989959347-a078aca1-56b2-4421-a8cd-8e10516c166f.jpeg" width="1950" id="uef1688dd" class="ne-image"></p><p id="u00743ca7" class="ne-p"><span class="ne-text"></span></p></div>]]></content>
      
      
      <categories>
          
          <category> 异世界 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>1823. 找出游戏的获胜者🔖递归</title>
      <link href="/blog/ucz0sz/"/>
      <url>/blog/ucz0sz/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><ul class="ne-ul"><li id="u2561afec"><a href="https://leetcode-cn.com/problems/find-the-winner-of-the-circular-game/" data-href="https://leetcode-cn.com/problems/find-the-winner-of-the-circular-game/" target="_blank" class="ne-link"><span class="ne-text">https://leetcode-cn.com/problems/find-the-winner-of-the-circular-game/</span></a></li></ul><p id="ua1522be6" class="ne-p"><span class="ne-text"></span></p><p id="uc655ed76" class="ne-p"><span class="ne-text">其中12行代码是根据数学找规律得出来的（滑稽</span></p><p id="uee099d02" class="ne-p"><span class="ne-text"></span></p><p id="ud70ea673" class="ne-p"><span class="ne-text">感觉这个题目还有用循环链表，队列啥的写，但是力扣我至今还不知道他有没有预设这些js不内置的数据结构，一直都是题目有啥用啥……</span></p><pre><code>/** * @param &#123;number&#125; n * @param &#123;number&#125; k * @return &#123;number&#125; */var findTheWinner = function(n, k) &#123;    let arr = []    for (let i = 0; i&lt;n; i++) arr.push(i+1)    let searchP = (arr, k, pre) =&gt; &#123;        if (arr.length &gt; 1) &#123;            pre = k + pre - 1            while (pre &gt; arr.length-1) pre = pre - arr.length            arr.splice(pre, 1)            searchP(arr, k, pre)        &#125;    &#125;    searchP(arr, k, 0)    return arr[0]&#125;;</code></pre><p id="ue12db441" class="ne-p"><span class="ne-text"></span></p><p id="u378010d0" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1651647527838-774b7fe0-fbba-44d7-8fa2-b7a1af828bdb.png" width="670.8333066768128" id="u874494ca" class="ne-image"></p></div>]]></content>
      
      
      <categories>
          
          <category> 计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 🌌递归算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>905. 按奇偶排序数组🔖数组</title>
      <link href="/blog/sp649k/"/>
      <url>/blog/sp649k/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><ul class="ne-ul"><li id="u0934bc91"><a href="https://leetcode-cn.com/problems/sort-array-by-parity/" data-href="https://leetcode-cn.com/problems/sort-array-by-parity/" target="_blank" class="ne-link"><span class="ne-text">https://leetcode-cn.com/problems/sort-array-by-parity/</span></a></li></ul><p id="u4bbd8d43" class="ne-p"><span class="ne-text"></span></p><p id="ue01bb5d1" class="ne-p"><span class="ne-text">暴力解法</span></p><pre><code>/** * @param &#123;number[]&#125; nums * @return &#123;number[]&#125; */var sortArrayByParity = function(nums) &#123;    let arr = []    nums.forEach(data =&gt; &#123;data % 2 === 0 ? arr.unshift(data) : arr.push(data)&#125;)    return arr&#125;;</code></pre><p id="uc66ff315" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1651567846491-0c978678-9a40-4ee4-b77b-22dc5284ef37.png" width="617.4999754627555" id="ubb08a31d" class="ne-image"></p><p id="uceba6cc9" class="ne-p"><br></p></div>]]></content>
      
      
      <categories>
          
          <category> 计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 📶线结构：字符串-数组-栈-队列 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>908. 最小差值 I🔖数组</title>
      <link href="/blog/vmdef7/"/>
      <url>/blog/vmdef7/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><ul class="ne-ul"><li id="ueaf52d85" data-lake-index-type="0"><a href="https://leetcode-cn.com/problems/smallest-range-i/" data-href="https://leetcode-cn.com/problems/smallest-range-i/" target="_blank" class="ne-link"><span class="ne-text">https://leetcode-cn.com/problems/smallest-range-i/</span></a></li></ul><p id="ue34d2f17" class="ne-p"><span class="ne-text">主要分析出规律就好解了</span></p><ul class="ne-ul"><li id="ud251fd6e" data-lake-index-type="0"><span class="ne-text">对第一个和最后一个元素进行相减比较</span></li><li id="u1817570f" data-lake-index-type="0"><span class="ne-text">去重</span></li></ul><pre><code><code>/** * @param &#123;number[]&#125; nums * @param &#123;number&#125; k * @return &#123;number&#125; */var smallestRangeI = function(nums, k) &#123;    let arr = Array.from(new Set(nums.sort((a, b) =&gt; &#123;return a - b&#125;)))    if (arr.length === 1) return 0    return arr[arr.length - 1] - arr[0] - 2 * k &lt;= 0 ? 0 : arr[arr.length - 1] - arr[0] -2 * k&#125;;</code></code></pre></div>]]></content>
      
      
      <categories>
          
          <category> 计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 📶线结构：字符串-数组-栈-队列 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>1305. 两棵二叉搜索树中的所有元素🔖DFS🔖数组</title>
      <link href="/blog/rxfz11/"/>
      <url>/blog/rxfz11/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><ul class="ne-ul"><li id="u46abc578"><a href="https://leetcode-cn.com/problems/all-elements-in-two-binary-search-trees/" data-href="https://leetcode-cn.com/problems/all-elements-in-two-binary-search-trees/" target="_blank" class="ne-link"><span class="ne-text">https://leetcode-cn.com/problems/all-elements-in-two-binary-search-trees/</span></a></li></ul><p id="u6f0ad162" class="ne-p"><span class="ne-text"></span></p><pre><code>/** * Definition for a binary tree node. * function TreeNode(val, left, right) &#123; *     this.val = (val===undefined ? 0 : val) *     this.left = (left===undefined ? null : left) *     this.right = (right===undefined ? null : right) * &#125; *//** * @param &#123;TreeNode&#125; root1 * @param &#123;TreeNode&#125; root2 * @return &#123;number[]&#125; */var getAllElements = function(root1, root2) &#123;    let arr_left = []    let arr_right = []    let dfs = (data, arr) =&gt; &#123;        if (data) &#123;            dfs(data.left, arr)            dfs(data.right, arr)            arr.push(data.val)        &#125;    &#125;    dfs(root1, arr_left)    dfs(root2, arr_right)    return arr_left.concat(arr_right).sort((a, b) =&gt; &#123;return a - b&#125;)&#125;;</code></pre><p id="u25b22db4" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1651564651594-33c9e8d9-889d-4560-858a-8d9f15021e99.png" width="635.8333080675877" id="u429a9901" class="ne-image"></p></div>]]></content>
      
      
      <categories>
          
          <category> 计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 🌲树结构：二叉树-哈夫曼树 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>3. 无重复字符的最长子串</title>
      <link href="/blog/sutafh/"/>
      <url>/blog/sutafh/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><ul class="ne-ul"><li id="u742c0868"><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/" data-href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/" target="_blank" class="ne-link"><span class="ne-text">https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/</span></a></li></ul><p id="ub473188b" class="ne-p"><span class="ne-text">暴力解法</span></p><pre><code>/** * @param &#123;string&#125; s * @return &#123;number&#125; */var lengthOfLongestSubstring = function(s) &#123;    let result = 1    if (s.length === 0) return 0    if (s.length === 1) return 1    for(let i=0;i&lt;s.length-1;i++)&#123;        for(let j=i+1;j&lt;s.length;j++)&#123;            let arr = s.substr(i,j-i+1).split('')            let set = new Set(arr)<pre><code>        if(arr.length !==[...set].length)&#123;            break        &#125; else &#123;            result = result &amp;gt;= arr.length ? result : arr.length        &#125;    &#125;&#125;return result</code></pre><p>};<br></code></pre></p><p id="u41603835" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1651544911564-558d66b8-bbf2-4a53-9afe-c3c92e0b8051.png" width="634.999974767368" id="uf5f7c443" class="ne-image"></p><p id="udf417444" class="ne-p"><span class="ne-text">这个结果太拉跨了……</span></p><p id="ue8529b0c" class="ne-p"><strong><span class="ne-text">todo：滑动窗口</span></strong></p></div>]]></content>
      
      
      <categories>
          
          <category> 计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 🥢KMP类算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>70. 爬楼梯🔖DP</title>
      <link href="/blog/ik7g6a/"/>
      <url>/blog/ik7g6a/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><ul class="ne-ul"><li id="u104b6f47" data-lake-index-type="0"><a href="https://leetcode.cn/problems/climbing-stairs/" data-href="https://leetcode.cn/problems/climbing-stairs/" target="_blank" class="ne-link"><span class="ne-text">https://leetcode.cn/problems/climbing-stairs/</span></a></li></ul><h3 id="iq1Ux"><span class="ne-text">动态规划</span></h3><div data-type="info" class="ne-alert"><p id="uc65816a0" class="ne-p"><span class="ne-text">动态规划解题主要是解决两点：</span></p><ol class="ne-ol"><li id="u4af3f901" data-lake-index-type="0"><span class="ne-text">状态转移方程（定义子问题）</span></li><li id="uc1e7777f" data-lake-index-type="0"><span class="ne-text">初始状态</span></li></ol></div><ol class="ne-ol"><li id="uc8447c33" data-lake-index-type="0"><span class="ne-text" style="background-color: #FBDE28">状态转移方程</span><span class="ne-text"></span></li></ol><ul class="ne-ul"><li id="u1c103d2d" data-lake-index-type="0"><span class="ne-text">到达第n层阶梯的方式只有两种，走一步然后结束，或者走两步然后结束。</span></li><li id="u479b21ff" data-lake-index-type="0"><span class="ne-text">到达第n-1层阶梯的方式只有两种，走一步然后结束，或者走两步然后结束。</span></li><li id="u41ccc1f5" data-lake-index-type="0"><span class="ne-text">……</span></li></ul><p id="ud645fd5f" class="ne-p"><span class="ne-text">可以用数学函数表达如下式：</span></p><p id="uab9ec463" class="ne-p" style="text-align: center"><code class="ne-code"><span class="ne-text">f(n) = f(n-1) + f(n - 2)</span></code></p><ol start="2" class="ne-ol"><li id="uf3211371" data-lake-index-type="0"><span class="ne-text" style="background-color: #FBDE28">初始状态</span><span class="ne-text"></span></li></ol><ul class="ne-ul"><li id="u8c421703" data-lake-index-type="0"><span class="ne-text">从问题角度考虑：如果阶梯只有一层或者只有两层，显然上述公式不符合带入</span></li><li id="u369a9114" data-lake-index-type="0"><span class="ne-text">从数学函数角度考虑：函数f的定义域一定是大于0的</span></li></ul><p id="u9f8cf14d" class="ne-p"><span class="ne-text"></span></p><p id="uc760e233" class="ne-p"><span class="ne-text">所以函数模型可以抽象出来：</span></p><pre><code><code>f(1) = 1,(当n = 1)f(2) = 2,(当n = 2)f(n) = f(n-1) + f(n - 2)</code></code></pre><p id="uaaae7e1c" class="ne-p"><span class="ne-text"></span></p><pre><code><code>function climbStairs(n: number): number &#123;  if (n &lt;= 2) return n  const arr = new Array(n).fill(0)  arr[0] = 1  arr[1] = 2  for (let i = 2; i &lt; arr.length; i++)     arr[i] = arr[i-1] + arr[i-2]  return arr[n-1]&#125;;</code></code></pre><h3 id="lU6EC"><span class="ne-text">递归</span></h3><p id="uf44ae233" class="ne-p"><span class="ne-text" style="background-color: #FBDE28">不建议用，复杂度太高（指数级）</span><span class="ne-text">，只是因为和递归看起来有点像，所以写出来作为比较</span></p><pre><code><code>function climbStairs(n: number): number &#123;  if(n &lt;= 2) return n;  return climbStairs(n-1) + climbStairs(n-2);&#125;;</code></code></pre></div>]]></content>
      
      
      <categories>
          
          <category> 计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 🔢动态规划算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>63. 不同路径 II🔖DP</title>
      <link href="/blog/hny8e9/"/>
      <url>/blog/hny8e9/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><ul class="ne-ul"><li id="ue13427c7" data-lake-index-type="0"><a href="https://leetcode.cn/problems/unique-paths-ii" data-href="https://leetcode.cn/problems/unique-paths-ii" target="_blank" class="ne-link"><span class="ne-text">https://leetcode.cn/problems/unique-paths-ii</span></a></li></ul><h3 id="hUCCv"><span class="ne-text">动态规划</span></h3><p id="u92d00d53" class="ne-p"><a href="https://www.yuque.com/wztlink1013/blog/lc1dfa" data-href="https://www.yuque.com/wztlink1013/blog/lc1dfa" class="ne-link"><span class="ne-text">62. 不同路径</span><span class="ne-text">🔖</span><span class="ne-text">DP</span></a><span class="ne-text">题目的延申。</span></p><p id="u66991a78" class="ne-p"><span class="ne-text">这个题目的难点不是在状态转移方程的建立，而是初始状态的建立。</span></p><p id="u25288bc0" class="ne-p"><span class="ne-text"></span></p><p id="ua131736c" class="ne-p"><span class="ne-text">数据预处理说明，对障碍物或是走不通的格子都设置为0</span></p><ol class="ne-ol"><li id="u75d3e76b" data-lake-index-type="0"><span class="ne-text" style="background-color: #FBDE28">状态转移方程</span></li></ol><p id="ub6df2f32" class="ne-p"><span class="ne-text">不变。和</span><a href="https://www.yuque.com/wztlink1013/blog/lc1dfa" data-href="https://www.yuque.com/wztlink1013/blog/lc1dfa" class="ne-link"><span class="ne-text">62. 不同路径</span><span class="ne-text">🔖</span><span class="ne-text">DP</span></a><span class="ne-text">中的方程一样：</span><code class="ne-code"><span class="ne-text">f[i][j] = f[i-1][j] + f[i][j-1]</span></code></p><ol start="2" class="ne-ol"><li id="u58005b7e" data-lake-index-type="0"><span class="ne-text" style="background-color: #FBDE28">初始状态</span></li></ol><ol class="ne-list-wrap"><ol ne-level="1" class="ne-ol"><li id="u42e70446" data-lake-index-type="0"><span class="ne-text">上边界和左边界：不能单纯的全部设为1，如果有障碍物，那么后续的路（往右/往下）走不通</span></li><li id="u59aad87d" data-lake-index-type="0"><span class="ne-text">正式区域（非上/左边界）：遇到障碍物那么就是走不通，即0</span></li><li id="uba81e480" data-lake-index-type="0"><span class="ne-text">比较特殊的初始状态：</span></li></ol></ol><ol class="ne-list-wrap"><ol class="ne-list-wrap"><ol ne-level="2" class="ne-ol"><li id="u34fbf2dc" data-lake-index-type="0"><span class="ne-text">起点即终点</span></li><li id="u71727b37" data-lake-index-type="0"><span class="ne-text">起点为障碍物</span></li></ol></ol></ol><pre><code><code>function uniquePathsWithObstacles(obstacleGrid: number[][]): number &#123;  if (obstacleGrid[0][0]) return 0  const m = obstacleGrid.length  const n = obstacleGrid[0].length  for (let i = 0; i &lt; m; i++) &#123;    for (let j = 0; j &lt; n; j++) &#123;      const curr = obstacleGrid[i][j]      if (!i || !j) &#123;        if (!i &amp;&amp; !j) &#123;          obstacleGrid[i][j] = m === 1 &amp;&amp; n === 1 ? 1 : 0        &#125; else if (curr || (j &gt; 1 &amp;&amp; obstacleGrid[0][j - 1] === 0) || (i &gt; 1 &amp;&amp; obstacleGrid[i - 1][0] === 0)) &#123;          obstacleGrid[i][j] = 0        &#125; else &#123;          obstacleGrid[i][j] = 1        &#125;      &#125; else if (curr) &#123;        obstacleGrid[i][j] = 0      &#125; else &#123;        obstacleGrid[i][j] = obstacleGrid[i - 1][j] + obstacleGrid[i][j - 1]      &#125;    &#125;  &#125;  return obstacleGrid[m - 1][n - 1]&#125;;</code></code></pre></div>]]></content>
      
      
      <categories>
          
          <category> 计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 🔢动态规划算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>62. 不同路径🔖DP</title>
      <link href="/blog/lc1dfa/"/>
      <url>/blog/lc1dfa/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><ul class="ne-ul"><li id="ub6d0c2df" data-lake-index-type="0"><a href="https://leetcode-cn.com/problems/unique-paths/" data-href="https://leetcode-cn.com/problems/unique-paths/" target="_blank" class="ne-link"><span class="ne-text">https://leetcode-cn.com/problems/unique-paths/</span></a></li></ul><h3 id="Wwazx"><span class="ne-text">动态规划</span></h3><ul class="ne-ul"><li id="ua95065ea" data-lake-index-type="0"><span class="ne-text" style="background-color: #FBDE28">状态转移方程</span><span class="ne-text">：动态方程抽离问题的共同解决方程</span></li></ul><p id="u8c01dfba" class="ne-p"><span class="ne-text">在本问题中，走到某个格子，他的上一步一定是从左边格子走进来或是从上边走下来的，所以利用这一点可以写一个函数表达式</span><code class="ne-code"><span class="ne-text">f[i][j] = f[i-1][j] + f[i][j-1]</span></code></p><ul class="ne-ul"><li id="u942a84e5" data-lake-index-type="0"><span class="ne-text" style="background-color: #FBDE28">初始状态</span><span class="ne-text">：相当于对于上述动态方程的特殊情况的枚举</span></li></ul><p id="u30bca93f" class="ne-p"><span class="ne-text">上边界和左边界的赋值就是该问题的初始状态，这两种情况都只能是一种方式走进来，所以都赋值为1</span></p><p id="ucff68f71" class="ne-p"><code class="ne-code"><span class="ne-text">f[0][j] = 1</span></code></p><p id="u5e9a50b3" class="ne-p"><code class="ne-code"><span class="ne-text">f[i][0] = 1</span></code></p><p id="u28054997" class="ne-p"><br></p><pre><code><code>var uniquePaths = function(m, n) &#123;  let arr = new Array(m).fill(0).map(() =&gt; new Array(n).fill(0))  for (let i = 0; i&lt;m; i++) arr[i][0] = 1  for (let j = 0; j&lt;n; i++) arr[0][j] = 1  for (let i = 1; i&lt;m; i++) &#123;    for (let j = 1; j&lt;n; j++) &#123;      arr[i][j] = arr[i-1][j] + arr[i][j-1]    &#125;  &#125;  return arr[m-1][n-1]&#125;;</code></code></pre><p id="u014e65a9" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1652015457078-4895e20f-7f29-463d-aaa7-97715d3dcd54.png" width="628.333308365611" id="u516534aa" class="ne-image"></p></div>]]></content>
      
      
      <categories>
          
          <category> 计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 🔢动态规划算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>112. 路径总和🔖DFS</title>
      <link href="/blog/alrzw2/"/>
      <url>/blog/alrzw2/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><ul class="ne-ul"><li id="ua36bd7a2"><a href="https://leetcode-cn.com/problems/path-sum/" data-href="https://leetcode-cn.com/problems/path-sum/" target="_blank" class="ne-link"><span class="ne-text">https://leetcode-cn.com/problems/path-sum/</span></a></li></ul><p id="u349f23d1" class="ne-p"><span class="ne-text"></span></p><pre><code>/** * Definition for a binary tree node. * function TreeNode(val, left, right) &#123; *     this.val = (val===undefined ? 0 : val) *     this.left = (left===undefined ? null : left) *     this.right = (right===undefined ? null : right) * &#125; *//** * @param &#123;TreeNode&#125; root * @param &#123;number&#125; targetSum * @return &#123;boolean&#125; */var hasPathSum = function(root, targetSum) &#123;    let result = false    let dfs = (data, presum, tar) =&gt; &#123;        if (data) &#123;            presum = data.val + presum            if (!data.left &amp;&amp; !data.right) &#123;                if (presum == tar) &#123;                    result = true                &#125;            &#125;            dfs(data.left, presum, tar)            dfs(data.right, presum, tar)        &#125;    &#125;    dfs(root, 0, targetSum)    return result&#125;;</code></pre><p id="ubb6e5da4" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1651412804694-76d5dacc-2cbe-4170-a04f-4af28bfa1d6f.png" width="719.9999713897716" id="ud5bb75fc" class="ne-image"></p></div>]]></content>
      
      
      <categories>
          
          <category> 计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 🌲树结构：二叉树-哈夫曼树 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>100. 相同的树🔖BFS🔖DFS</title>
      <link href="/blog/imt8ld/"/>
      <url>/blog/imt8ld/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><ul class="ne-ul"><li id="u4caaba6d"><a href="https://leetcode-cn.com/problems/same-tree/" data-href="https://leetcode-cn.com/problems/same-tree/" target="_blank" class="ne-link"><span class="ne-text">https://leetcode-cn.com/problems/same-tree/</span></a></li></ul><p id="u88c6e409" class="ne-p"><span class="ne-text"></span></p><h3 id="h4eM0"><span class="ne-text">BFS</span></h3><pre><code>/** * Definition for a binary tree node. * function TreeNode(val, left, right) &#123; *     this.val = (val===undefined ? 0 : val) *     this.left = (left===undefined ? null : left) *     this.right = (right===undefined ? null : right) * &#125; *//** * @param &#123;TreeNode&#125; p * @param &#123;TreeNode&#125; q * @return &#123;boolean&#125; */var isSameTree = function(p, q) &#123;    if (p === null &amp;&amp; q === null) return true    if (p === null || q === null) return false    <pre><code>let que_1 = [p]let que_2 = [q]while(que_1.length !== 0) &#123;    let que_1_size = que_1.length    let que_2_size = que_2.length    if (que_1_size !== que_2_size) return false    for (let i = 0; i&amp;lt;que_1_size; i++) &#123;        let mp1 = que_1.shift()        let mp2 = que_2.shift()        if (mp1.val !== mp2.val) return false        if (mp1.left &amp;amp;&amp;amp; mp2.left) &#123;            que_1.push(mp1.left)            que_2.push(mp2.left)        &#125; else if(!mp1.left &amp;amp;&amp;amp; !mp2.left)&#123;&#125; else &#123;            return false        &#125;        if (mp1.right &amp;amp;&amp;amp; mp2.right) &#123;            que_1.push(mp1.right)            que_2.push(mp2.right)        &#125; else if(!mp1.right &amp;amp;&amp;amp; !mp2.right)&#123;&#125; else &#123;            return false        &#125;    &#125;&#125;return true</code></pre><p>};<br></code></pre></p><p id="u2a1b40a8" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1652015502900-ce25f41b-27ba-42d1-aba5-574187e8e2b8.png" width="630.8333082662698" id="u588d5535" class="ne-image"></p><h3 id="fOcqM"><span class="ne-text">DFS</span></h3><p id="ud9083096" class="ne-p"><span class="ne-text">肝不动了，直接暴力run ok就行</span></p><pre><code>/** * Definition for a binary tree node. * function TreeNode(val, left, right) &#123; *     this.val = (val===undefined ? 0 : val) *     this.left = (left===undefined ? null : left) *     this.right = (right===undefined ? null : right) * &#125; *//** * @param &#123;TreeNode&#125; p * @param &#123;TreeNode&#125; q * @return &#123;boolean&#125; */var isSameTree = function(p, q) &#123;    let result = true    if (p === null &amp;&amp; q === null) return result    if (p === null || q === null) return !result    let arr_1 = []    let arr_2 = []    let dfs = (data, arr) =&gt; &#123;        if (data) &#123;            arr.push(data.val)            if (data.left) &#123;                dfs(data.left, arr)            &#125; else &#123;                arr.push(99999)            &#125;            if (data.right) &#123;                dfs(data.right, arr)            &#125; else &#123;                arr.push(99999)            &#125;            <pre><code>    &#125; &#125;dfs(p, arr_1)dfs(q, arr_2)if (arr_1.length !== arr_2.length) result = falsearr_1.forEach((data, index) =&amp;gt; &#123;    if (data !== arr_2[index]) &#123;        result = false    &#125;&#125;)return result</code></pre><p>};<br></code></pre></p><p id="ufa7f6e11" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1652015520028-ccb54006-a5de-4448-8501-d6570716c111.png" width="636.6666413678073" id="u4ffec31d" class="ne-image"></p></div>]]></content>
      
      
      <categories>
          
          <category> 计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 🌲树结构：二叉树-哈夫曼树 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>102. 二叉树的层序遍历🔖BFS</title>
      <link href="/blog/by7bg0/"/>
      <url>/blog/by7bg0/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><ul class="ne-ul"><li id="u33c6c359"><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/" data-href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/" target="_blank" class="ne-link"><span class="ne-text">https://leetcode-cn.com/problems/binary-tree-level-order-traversal/</span></a></li></ul><p id="uf4f66dda" class="ne-p"><span class="ne-text">广度优先搜索</span></p><p id="u901c812d" class="ne-p"><span class="ne-text"></span></p><pre><code>/** * Definition for a binary tree node. * function TreeNode(val, left, right) &#123; *     this.val = (val===undefined ? 0 : val) *     this.left = (left===undefined ? null : left) *     this.right = (right===undefined ? null : right) * &#125; *//** * @param &#123;TreeNode&#125; root * @return &#123;number[][]&#125; */var levelOrder = function(root) &#123;    if(!root) return []    let result = []    let que = []    que.push(root)    while(que.length !== 0) &#123;        let init_size = que.length        let temp = []        for (let i = 0; i&lt;init_size; i++) &#123;            let mp = que.shift()            if(mp.left) que.push(mp.left)            if(mp.right) que.push(mp.right)            temp.push(mp.val)        &#125;        result.push(temp)    &#125;<pre><code>return result</code></pre><p>};<br></code></pre></p><p id="u50a3c995" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1652015568860-91161da1-00e3-41d8-9024-9d860fa22e9c.png" width="630.8333082662698" id="ucd610f2e" class="ne-image"></p></div>]]></content>
      
      
      <categories>
          
          <category> 计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 🌲树结构：二叉树-哈夫曼树 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>129. 求根节点到叶节点数字之和🔖DFS</title>
      <link href="/blog/thy7mx/"/>
      <url>/blog/thy7mx/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><ul class="ne-ul"><li id="u6a1cce50"><a href="https://leetcode-cn.com/problems/sum-root-to-leaf-numbers/" data-href="https://leetcode-cn.com/problems/sum-root-to-leaf-numbers/" target="_blank" class="ne-link"><span class="ne-text">https://leetcode-cn.com/problems/sum-root-to-leaf-numbers/</span></a></li></ul><p id="ufc5039cc" class="ne-p"><span class="ne-text"></span></p><h3 id="dyUoI"><span class="ne-text">dfs</span></h3><pre><code>/** * Definition for a binary tree node. * function TreeNode(val, left, right) &#123; *     this.val = (val===undefined ? 0 : val) *     this.left = (left===undefined ? null : left) *     this.right = (right===undefined ? null : right) * &#125; *//** * @param &#123;TreeNode&#125; root * @return &#123;number&#125; */var sumNumbers = function(root) &#123;    if (!root) return root    let arr = []    let result = 0    let dfs = (data, presum) =&gt; &#123;        if (data) &#123;            presum = data.val + presum * 10            if (!data.left &amp;&amp; !data.right)                arr.push(presum)            else &#123;                dfs(data.left, presum)                dfs(data.right, presum)            &#125;        &#125;    &#125;    dfs(root, 0)    result = arr.reduce((a, b) =&gt; &#123;return a + b&#125;)    return result&#125;;</code></pre><p id="u6922ddff" class="ne-p"><span class="ne-text">优化一下得到：</span></p><pre><code>/** * Definition for a binary tree node. * function TreeNode(val, left, right) &#123; *     this.val = (val===undefined ? 0 : val) *     this.left = (left===undefined ? null : left) *     this.right = (right===undefined ? null : right) * &#125; *//** * @param &#123;TreeNode&#125; root * @return &#123;number&#125; */var sumNumbers = function(root) &#123;    let dfs = (data, presum) =&gt; &#123;        if (data === null) return 0        presum = data.val + presum * 10        if (!data.left &amp;&amp; !data.right) &#123;            return presum        &#125;        return dfs(data.left, presum) + dfs(data.right, presum)    &#125;    return dfs(root, 0)&#125;;</code></pre><p id="ub2e4a533" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1652015642635-9c156952-829a-4fe0-9659-13773d03152d.png" width="620.8333086636342" id="u5238ad6b" class="ne-image"></p></div>]]></content>
      
      
      <categories>
          
          <category> 计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 🌲树结构：二叉树-哈夫曼树 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>222. 完全二叉树的节点个数🔖DFS</title>
      <link href="/blog/ktp9xg/"/>
      <url>/blog/ktp9xg/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><ul class="ne-ul"><li id="u07a8ac51"><a href="https://leetcode-cn.com/problems/count-complete-tree-nodes/" data-href="https://leetcode-cn.com/problems/count-complete-tree-nodes/" target="_blank" class="ne-link"><span class="ne-text">https://leetcode-cn.com/problems/count-complete-tree-nodes/</span></a></li></ul><p id="ub8a1fd4e" class="ne-p"><span class="ne-text"></span></p><p id="ua0193dda" class="ne-p"><span class="ne-text">思路：</span></p><p id="ude5f7034" class="ne-p"><span class="ne-text">通法就是递归，其他方法暂不考虑</span></p><pre><code>/** * Definition for a binary tree node. * function TreeNode(val, left, right) &#123; *     this.val = (val===undefined ? 0 : val) *     this.left = (left===undefined ? null : left) *     this.right = (right===undefined ? null : right) * &#125; *//** * @param &#123;TreeNode&#125; root * @return &#123;number&#125; */var countNodes = function(root) &#123;    let result = 0    let nodes = data =&gt; &#123;        if (data) &#123;                        nodes(data.left)            nodes(data.right)            result++        &#125;    &#125;    nodes(root)    return result&#125;;</code></pre><p id="u665d3829" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1652015619370-5b367d0f-0a6d-4017-92cd-d370355d74bc.png" width="628.333308365611" id="ud7655360" class="ne-image"></p></div>]]></content>
      
      
      <categories>
          
          <category> 计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 🌲树结构：二叉树-哈夫曼树 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>922. 按奇偶排序数组 II🔖暴力</title>
      <link href="/blog/hfqwr9/"/>
      <url>/blog/hfqwr9/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><ul class="ne-ul"><li id="ud64ba08c"><a href="https://leetcode-cn.com/problems/sort-array-by-parity-ii/" data-href="https://leetcode-cn.com/problems/sort-array-by-parity-ii/" target="_blank" class="ne-link"><span class="ne-text">https://leetcode-cn.com/problems/sort-array-by-parity-ii/</span></a></li></ul><p id="u964fd2bb" class="ne-p"><br></p><p id="u9d6469a0" class="ne-p"><span class="ne-text">思路：我特喵的直接暴力解法</span></p><p id="u019aab45" class="ne-p"><span class="ne-text"></span></p><pre><code>/** * @param &#123;number[]&#125; nums * @return &#123;number[]&#125; */var sortArrayByParityII = function(nums) &#123;    let arr = []    let arr_ou = []    let arr_ji = []    nums.forEach(data =&gt; &#123;        data % 2 === 0 ? arr_ou.push(data) : arr_ji.push(data)    &#125;)    for (let i = 0; i&lt;arr_ji.length ;i++) &#123;        arr[i * 2] = arr_ou[i]        arr[i * 2 + 1] = arr_ji[i]    &#125;    return arr&#125;;</code></pre><p id="u3219963b" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1651392122716-c4681176-5009-40b5-958f-e5221988a605.png" width="664.1666402750556" id="u4d6b42ad" class="ne-image"></p></div>]]></content>
      
      
      <categories>
          
          <category> 计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 📊查找排序算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>164. 最大间距🔖排序🔖array.sort🔖冒泡排序</title>
      <link href="/blog/szmcwf/"/>
      <url>/blog/szmcwf/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><ul class="ne-ul"><li id="u3630a41a"><a href="https://leetcode-cn.com/problems/maximum-gap/" data-href="https://leetcode-cn.com/problems/maximum-gap/" target="_blank" class="ne-link"><span class="ne-text">https://leetcode-cn.com/problems/maximum-gap/</span></a></li></ul><p id="u740a0366" class="ne-p"><span class="ne-text"></span></p><h3 id="liEvF"><span class="ne-text">array.sort</span></h3><pre><code>/** * @param &#123;number[]&#125; nums * @return &#123;number&#125; */var maximumGap = function(nums) &#123;    let result = 0    if(nums.length &lt; 2) return result    nums.sort((a, b) =&gt; &#123;return a - b&#125;).forEach((data, index) =&gt; &#123;        if (index &lt; nums.length - 1) &#123;            result = result &gt; nums[index + 1] - data ? result : nums[index + 1] - data        &#125;    &#125;)    return result&#125;;</code></pre><p id="u579e3795" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1651388338749-eedd3c62-5fa2-47c1-b44d-76a007fe023f.png" width="624.1666418645127" id="u4ad07262" class="ne-image"></p><h3 id="hoahQ"><span class="ne-text">冒泡排序</span></h3><p id="u0d4555f0" class="ne-p"><span class="ne-text">也可以利用冒泡排序，在最后两项排完，比较差值然后与result对比</span></p></div>]]></content>
      
      
      <categories>
          
          <category> 计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 📊查找排序算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>148. 排序链表🔖链表</title>
      <link href="/blog/cput4h/"/>
      <url>/blog/cput4h/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h3 id="fsJ6t"><span class="ne-text">148. 排序链表</span></h3><ul class="ne-ul"><li id="u102e7213" data-lake-index-type="0"><a href="https://leetcode-cn.com/problems/sort-list/" data-href="https://leetcode-cn.com/problems/sort-list/" target="_blank" class="ne-link"><span class="ne-text">https://leetcode-cn.com/problems/sort-list/</span></a></li></ul><pre><code><code>/** * Definition for singly-linked list. * function ListNode(val, next) &#123; *     this.val = (val===undefined ? 0 : val) *     this.next = (next===undefined ? null : next) * &#125; *//** * @param &#123;ListNode&#125; head * @return &#123;ListNode&#125; */var sortList = function(head) &#123;    if (head === null) return head    let arr = []    while (head !== null) &#123;        arr.push(head.val)        head = head.next    &#125;    let result = arr.sort((a, b) =&gt; &#123;return a - b&#125;)    let result_head = new ListNode(result[0], null)    let test = result_head    result.forEach((data, index) =&gt; &#123;        if (index !== 0) &#123;            let temp = new ListNode(data,null)            test.next = temp            test = temp        &#125;    &#125;)    return result_head&#125;;</code></code></pre></div>]]></content>
      
      
      <categories>
          
          <category> 计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 🔗线结构：链表 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>VScode集成ESLint和Prettier和Editorconfig代码校验格式化环境</title>
      <link href="/blog/mkn98t/"/>
      <url>/blog/mkn98t/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="u42209bd7" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1658395016294-08433da7-eb86-4b66-a9bb-21ff5fc5e075.png" width="205" id="ue65dcde3" class="ne-image"></p><p id="u7b0e332e" class="ne-p"><span class="ne-text">前言：</span></p><ul class="ne-ul"><li id="u1319ddec"><span class="ne-text">前三个是根据项目格式化配置来格式化</span></li><li id="u29540e3a"><span class="ne-text">第四个是vue2高亮</span></li><li id="u4ff4ebf1"><span class="ne-text">最后一个（Vue3推荐的）对代码格式化器二选一冲突</span></li></ul><ul class="ne-ul"><li id="ue4aec3f0"><span class="ne-text">vscode插件：eslint、prettier、Editorconfig</span></li></ul><h2 id="sFMfa"><span class="ne-text">vscode插件</span></h2><h3 id="h0Bj3"><span class="ne-text">ESLint</span></h3><p id="u4c54dfd4" class="ne-p"><span class="ne-text">格式化检测工具：会给出警告抑或是报错，但不会修改</span></p><h3 id="qq5f8"><span class="ne-text">Prettier - Code formatter</span></h3><p id="u2bc455ee" class="ne-p"><span class="ne-text">代码格式化插件：按照所需配置直接格式化代码</span></p><h2 id="o9fJW"><span class="ne-text">eslint插件（解决冲突）</span></h2><h3 id="EHhwf"><span class="ne-text">eslint-plugin-html</span></h3><p id="u84ebd259" class="ne-p"><span class="ne-text">目的是为了检测html文件中的js代码，全局下载，让设备非node项目也能使用</span></p><pre><code>npm install -g eslint-plugin-html</code></pre><p id="u43b1986c" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1640400558364-b89c0585-1302-4515-b27a-bdb053cf8701.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_47%2Ctext_5bC86YeH6Iis5Zyw5oqS5oOF%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10" width="828" id="uc4ceedb9" class="ne-image"></p><p id="u8bca4c3c" class="ne-p"><span class="ne-text">每次打开html，eslint就会报错：</span></p><pre><code>'plugins' doesn't add plugins to configuration to load. Please use the 'overrideConfig.plugins' option instead.</code></pre><p id="u075e0d78" class="ne-p"><span class="ne-text">官网issues </span><a href="https://github.com/microsoft/vscode-eslint/issues/1376" data-href="https://github.com/microsoft/vscode-eslint/issues/1376" target="_blank" class="ne-link"><span class="ne-text">https://github.com/microsoft/vscode-eslint/issues/1376</span></a><span class="ne-text"> 中貌似也并未给出根治方法，暂时禁用：</span></p><p id="uad85479a" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1640401735422-2e618454-6752-4b2e-9020-8788d0ad114d.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_21%2Ctext_5bC86YeH6Iis5Zyw5oqS5oOF%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10" width="365" id="u7b0c7db1" class="ne-image"></p></div>]]></content>
      
      
      <categories>
          
          <category> 计算机素养 </category>
          
          <category> 工具使用 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>阿里云云监控（CloudMonitor）使用</title>
      <link href="/blog/ebwpmq/"/>
      <url>/blog/ebwpmq/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="ua95b6f84" class="ne-p"><span class="ne-text">前言：首先的目的是是否能够监控API 网关中的调用收费情况，设置阈值，以免大面积付费情况。</span></p><ul class="ne-ul"><li id="u06f2f4c0"><span class="ne-text">官方文档：</span><a href="https://help.aliyun.com/product/28572.html" data-href="https://help.aliyun.com/product/28572.html" target="_blank" class="ne-link"><span class="ne-text">云监控</span></a></li></ul><h3 id="N0Jyc"><span class="ne-text">监控函数计算的资源使用量以便报警</span></h3><p id="ude03c315" class="ne-p"><span class="ne-text">监控函数计算的资源使用量以便报警给管理员</span></p><ul class="ne-ul"><li id="u35ac11c2"><span class="ne-text">关于报警字段，着重</span><code class="ne-code"><span class="ne-text">FunctionBillableInvocations</span></code><span class="ne-text"> ，这个字段就是</span><code class="ne-code"><span class="ne-text">函数调用次数</span></code><span class="ne-text">的意思，还有许多其他字段参考：</span><a href="https://help.aliyun.com/document_detail/164978.html" data-href="https://help.aliyun.com/document_detail/164978.html" target="_blank" class="ne-link"><span class="ne-text">函数计算的监控项</span></a><span class="ne-text">。</span></li><li id="u59bf3f71"><span class="ne-text">报警规则列表：</span><a href="https://cloudmonitornext.console.aliyun.com/newAlert/_all" data-href="https://cloudmonitornext.console.aliyun.com/newAlert/_all" target="_blank" class="ne-link"><span class="ne-text">https://cloudmonitornext.console.aliyun.com/newAlert/_all</span></a></li></ul><p id="u043f1d47" class="ne-p"><span class="ne-text">如果触发警报会发送短信以及邮件给你，如下所示：</span></p><p id="u2a8f5ee1" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1643016667910-187a5814-aee0-4eb5-88fa-c383460b0643.png" width="384" id="S7OP7" class="ne-image"></p><p id="u2f87f849" class="ne-p"><span class="ne-text">如果想在报警之后，触发一些什么行为的话，也是支持的，配置规则的地方放了一个回调地址，我们可以写一条禁止访问报警url的回调url。</span></p><p id="u94f1800d" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1643017141727-31c29a74-3faa-4f0c-9703-d3ee35bba2f5.png" width="424" id="ucb8603c1" class="ne-image"></p><h3 id="WUwdi"><span class="ne-text">监控腾讯云主机的的信息</span></h3><p id="u72786a51" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1643004168879-80661271-2aa7-4bee-9f41-5c2b87bfe88f.png" width="1920" id="u7a12bfba" class="ne-image"></p><p id="u6dd29d39" class="ne-p"><span class="ne-text">在腾讯云主机那边登录，然后输入如下命令即可：</span></p><pre><code>CMS_AGENT_ACCESSKEY=n7a6618qdl22s CMS_AGENT_SECRETKEY=qzUsESJGRpSMbggHmplyXw ARGUS_VERSION=3.5.5 /bin/bash -c &quot;$(curl -s http://cms-download.aliyun.com/Argus/agent_install_necs-1.5.sh)&quot;</code></pre><p id="u01862047" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1643004562362-3609ad7f-4d9a-4822-8034-d745fa0bcbb4.png" width="1920" id="u3b839cb1" class="ne-image"></p><p id="u2df04007" class="ne-p"><span class="ne-text">然后再回到阿里云云监控列表里面，就可以查看响应状态了。</span></p><p id="u1669c751" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1643004639199-6ed6c390-7854-4ce2-b81f-ebe9ebac6e0f.png" width="1912" id="u9ece6d39" class="ne-image"></p></div>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
          <category> DevOps </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>阿里云API网关使用</title>
      <link href="/blog/mzlgyp/"/>
      <url>/blog/mzlgyp/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="u7ba768ae" class="ne-p"><span class="ne-text">前言：API 网关（API Gateway）提供高性能、高可用的 API 托管服务。是阿里云的诸多产品之一，其API的制作可由很多方式编写而成，其中上述介绍的函数计算就可以搭建起一个后端API服务。</span></p><p id="u1926a043" class="ne-p"><span class="ne-text"></span></p><p id="u0b6de65b" class="ne-p"><span class="ne-text">在此记录一下API 网关官网文档中函数计算写API部分的细节（上述学习函数计算可能没有注意的点，比如签名认证等安全方面的考量），另外调用社区提供的免费API（墨迹天气）服务来熟悉该产品。</span></p><p id="u82104f74" class="ne-p"><span class="ne-text"></span></p><ul class="ne-ul"><li id="u961a7a3e"><span class="ne-text">官方文档：</span><a href="https://help.aliyun.com/product/29462.html" data-href="https://help.aliyun.com/product/29462.html" target="_blank" class="ne-link"><span class="ne-text">API 网关</span></a></li><li id="ud44cd580"><span class="ne-text">控制台入口：</span><a href="https://apigateway.console.aliyun.com/?spm=5176.12818093.products-recent.dapigateway.718e16d05FzxRX#/cn-hangzhou/overView/view" data-href="https://apigateway.console.aliyun.com/?spm=5176.12818093.products-recent.dapigateway.718e16d05FzxRX#/cn-hangzhou/overView/view" target="_blank" class="ne-link"><span class="ne-text">阿里云 API网关（API Gateway）</span></a></li></ul><h3 id="r21wP"><span class="ne-text">阿里云API服务 墨迹天气</span></h3><ul class="ne-ul"><li id="u4dedfd6f"><a href="https://market.aliyun.com/products/57096001/cmapi023656.html?accounttraceid=235b91fa4fc145eb8c2e539568143ea2arym#sku=yuncode1765600000" data-href="https://market.aliyun.com/products/57096001/cmapi023656.html?accounttraceid=235b91fa4fc145eb8c2e539568143ea2arym#sku=yuncode1765600000" target="_blank" class="ne-link"><span class="ne-text">阿里云 免费版气象天气服务（cityid）-墨迹天气</span></a></li><li id="u1bf51a22"><a href="https://market.console.aliyun.com/imageconsole/index.htm?#/bizlist?_k=81bb4q" data-href="https://market.console.aliyun.com/imageconsole/index.htm?#/bizlist?_k=81bb4q" target="_blank" class="ne-link"><span class="ne-text">免费版气象天气服务（cityid）-墨迹天气</span></a></li></ul><h3 id="mVA26"><span class="ne-text">阿里云API服务 手机号归属地查询</span></h3><div class="ne-quote"><p id="u71bc9ee9" class="ne-p"><span class="ne-text">搭建无服务器应用之手机号归属地查询</span></p></div><ul class="ne-ul"><li id="u302967ab"><span class="ne-text">购买完成列表：</span><a href="https://market.console.aliyun.com/imageconsole/index.htm?#/?_k=kjfw5f" data-href="https://market.console.aliyun.com/imageconsole/index.htm?#/?_k=kjfw5f" target="_blank" class="ne-link"><span class="ne-text">https://market.console.aliyun.com/imageconsole/index.htm?#/?_k=kjfw5f</span></a></li></ul><h3 id="Re7IT"><span class="ne-text">后端为函数计算的API</span></h3><p id="u48b3581e" class="ne-p"><span class="ne-text">上述学习的函数计算，本质上是利用</span><code class="ne-code"><span class="ne-text">http</span></code><span class="ne-text">/</span><code class="ne-code"><span class="ne-text">事件</span></code><span class="ne-text">来触发相应的函数，函数计算会将执行结果返回给API网关，所以API网关可以是接口最后的关卡。</span></p><p id="uc043bcc1" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1646182518547-03f483b8-51fe-45f9-b5f7-0df214689ca9.png" width="1336" id="u17b5c3e4" class="ne-image"></p><h4 id="o7LbN"><span class="ne-text">创建API分组及其分组内API</span></h4><ul class="ne-ul"><li id="u3adb2203"><span class="ne-text">官方教程：</span><a href="https://help.aliyun.com/document_detail/154725.html" data-href="https://help.aliyun.com/document_detail/154725.html" target="_blank" class="ne-link"><span class="ne-text">首页 &gt;API 网关 &gt;快速入门 &gt;创建后端为函数计算的API</span></a></li></ul><p id="u71d0cdea" class="ne-p"><span class="ne-text">按照这个教程，可以完成创建API分组，创建API，创建应用及为应用进行API授权，调试API</span></p><p id="ub58c1b54" class="ne-p"><span class="ne-text">（其中创建云函数就不再赘述）</span></p><h4 id="e6esX"><span class="ne-text">调用API网关中的API</span></h4><p id="u9e5fa137" class="ne-p"><span class="ne-text">终端使用curl进行调用如下命令：</span></p><pre><code>curl -i -X GET &quot;http://752cb9170bc644e58ae1e1a3ddf09f7e-cn-hangzhou.alicloudapi.com/&quot;  -H &quot;Authorization:APPCODE 6e4c5952fc92473496423eb079b526ec&quot;</code></pre><p id="u59a15423" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1642998257022-9c35aad7-0064-4a88-b7de-210e5a82d95c.png" width="1894" id="u321a8b7a" class="ne-image"></p><p id="u9534558c" class="ne-p"><span class="ne-text">其他形式调用参考：</span><a href="https://help.aliyun.com/document_detail/115437.html" data-href="https://help.aliyun.com/document_detail/115437.html" target="_blank" class="ne-link"><span class="ne-text">使用简单认证（AppCode）方式调用API</span></a></p><h4 id="UnLT3"><span class="ne-text">在API网关中添加自定义域名</span></h4><div class="ne-quote"><p id="u00b92f09" class="ne-p"><span class="ne-text">有限制，设置HTTPS默认域名（仅专享实例使用）</span></p></div><ul class="ne-ul"><li id="ucdc43b2e"><span class="ne-text">参考：</span><a href="https://help.aliyun.com/document_detail/155022.html" data-href="https://help.aliyun.com/document_detail/155022.html" target="_blank" class="ne-link"><span class="ne-text">https://help.aliyun.com/document_detail/155022.html</span></a></li><li id="uef3648e1"><span class="ne-text">专享实例呢？</span><a href="https://help.aliyun.com/document_detail/164793.html" data-href="https://help.aliyun.com/document_detail/164793.html" target="_blank" class="ne-link"><span class="ne-text">首页 &gt;API 网关 &gt;产品定价 &gt;专享实例</span></a></li></ul><p id="uc1c606fa" class="ne-p"><span class="ne-text">免费开通阿里云的API 网关产品的时候，会自动开通两个实例</span></p><p id="ue3333900" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1643002313148-20d44602-9732-4e0a-8a4c-57955760b046.png" width="642" id="ud3ff8d53" class="ne-image"></p><p id="ufc31a201" class="ne-p"><span class="ne-text">添加自定义域名成功之后，api中会显示</span></p><p id="u62dd4594" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1643002635414-b425f46f-5790-4020-8b42-06becae97da3.png" width="1392" id="u7e3f21d4" class="ne-image"></p><p id="u0c2e44c5" class="ne-p"><span class="ne-text">调试的时候也会更改为现在绑定的域名。</span></p><p id="u78b1675e" class="ne-p"><span class="ne-text">调试如下：</span></p><pre><code>curl -i -X GET &quot;http://apitest.wztlink1013.com/&quot;  -H &quot;Authorization:APPCODE 6e4c5952fc92473496423eb079b526ec&quot;</code></pre><p id="ud923ad3a" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1643002898910-4c6b6361-699a-4414-840b-517e3ba8fb31.png" width="1440" id="u83459d2f" class="ne-image"></p><h4 id="Chu2x"><span class="ne-text">换成自定义域名之后是否付费？</span></h4><p id="uec048b08" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1643002724184-a669c165-4432-4246-b34d-3be898b9f915.png" width="1156" id="u68b4c2e7" class="ne-image"></p></div>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
          <category> DevOps </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>阿里云Serverless技术搭建应用</title>
      <link href="/blog/zq36h4/"/>
      <url>/blog/zq36h4/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="ub32a4a35" class="ne-p"><span class="ne-text">前言：阿里云的Serverless实际开发过程中，有如下几种方式：</span></p><ul class="ne-ul"><li id="ubb43f501" data-lake-index-type="0"><span class="ne-text">通过命令行工具部署 Serverless Devs 工具（推荐）</span></li><li id="ueb16a9b9" data-lake-index-type="0"><span class="ne-text">通过控制台应用中心部署（小型项目较为推荐）</span></li><li id="u84b55fdc" data-lake-index-type="0"><span class="ne-text">桌面版本（不推荐）</span></li><li id="udaed7f2c" data-lake-index-type="0"><span class="ne-text">vscode插件（不推荐）</span></li><li id="ue7cf634e" data-lake-index-type="0"><span class="ne-text">TODO: 通过</span><a href="https://api.aliyun.com/new#/tutorial?action=git_open&amp;git_repo=https://github.com/devsapp/start-web-framework.git&amp;tutorial=example/todolist-app/cloudshell.md" data-href="https://api.aliyun.com/new#/tutorial?action=git_open&amp;git_repo=https://github.com/devsapp/start-web-framework.git&amp;tutorial=example/todolist-app/cloudshell.md" target="_blank" class="ne-link"><span class="ne-text">阿里云CloudShell</span></a><span class="ne-text">部署</span></li></ul><p id="u07dfd314" class="ne-p"><span class="ne-text">开发过程中，如果项目较大，我们一般不在阿里云官网中的云函数计算控制台编写逻辑代码，所以就需要搭建本地开发环境，在查看函数计算文档的过程中，发现了两种方式，一种是</span><a href="https://github.com/alibaba/serverless-vscode/blob/HEAD/README-zh.md" data-href="https://github.com/alibaba/serverless-vscode/blob/HEAD/README-zh.md" target="_blank" class="ne-link"><span class="ne-text">vscode插件</span></a><span class="ne-text">形式，另一种是Serverless Devs，后者还有</span><a href="https://serverlessdevs.resume.net.cn/zh-cn/docs/best-practice/restful.html" data-href="https://serverlessdevs.resume.net.cn/zh-cn/docs/best-practice/restful.html" target="_blank" class="ne-link"><span class="ne-text">桌面软件</span></a><span class="ne-text">和cli脚手架两种形式，在这三种方式中尝试，</span><strong><span class="ne-text">最后打算用Serverless Devs脚手架来本地开发</span></strong><span class="ne-text">，不管是较大的项目还是单一代码的编写，都还是比较适用的。</span></p><div class="ne-quote"><p id="u484a08ae" class="ne-p"><span class="ne-text">注意：此前其实还有一种本地开发方式，就是使用Funcraft来管理函数计算资源，但是官方已建议切换至Serverless Devs管理，并作出了不再维护的声明，故不对其进行讨论。</span></p></div><h3 id="WqRPy"><span class="ne-text">一、Serverless Devs脚手架下载</span></h3><pre><code><code>cnpm install @serverless-devs/s -g</code></code></pre><p id="u084c8146" class="ne-p"><span class="ne-text">查看是否安装成功</span></p><p id="u5d7129d1" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1642923767628-5874487b-f526-471c-903c-b69a001333e8.png" width="570" id="pR5OQ" class="ne-image"></p><h3 id="qnshS"><span class="ne-text">二、密钥配置</span></h3><h4 id="QhIip"><span class="ne-text">s config add</span></h4><p id="u83988206" class="ne-p"><span class="ne-text">添加阿里云相关配置</span></p><ul class="ne-ul"><li id="u82e9b9cf" data-lake-index-type="0"><a href="https://account.console.aliyun.com/v2/#/basic-info/index" data-href="https://account.console.aliyun.com/v2/#/basic-info/index" target="_blank" class="ne-link"><span class="ne-text">AccountId</span></a><span class="ne-text">：1554564564583</span></li><li id="ued666337" data-lake-index-type="0"><a href="https://usercenter.console.aliyun.com/#/manage/ak" data-href="https://usercenter.console.aliyun.com/#/manage/ak" target="_blank" class="ne-link"><span class="ne-text">AccessKey ID</span></a><span class="ne-text">：LTxxxw</span></li><li id="ua47a5f2d" data-lake-index-type="0"><a href="https://usercenter.console.aliyun.com/#/manage/ak" data-href="https://usercenter.console.aliyun.com/#/manage/ak" target="_blank" class="ne-link"><span class="ne-text">AccessKey Secret</span></a><span class="ne-text">：7Flfxxxxxxxxxxx'gjCRG</span></li></ul><p id="ufc46b2b6" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1642928349966-c7717956-8695-4c19-9704-fc8b3b06b34a.png" width="436" id="u9eadec83" class="ne-image"></p><h4 id="nu1en"><span class="ne-text">s config get</span></h4><p id="u22f7adfa" class="ne-p"><span class="ne-text">查看配置</span></p><p id="u507de976" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1642928516636-784b530d-4408-4fc0-b516-6acc9d48741a.png" width="469" id="u6d4edbaf" class="ne-image"></p><h3 id="OH5tX"><span class="ne-text">三、新建项目</span></h3><h4 id="N4xmy"><span class="ne-text">新建全新项目</span></h4><p id="u8a791e59" class="ne-p"><span class="ne-text">利用</span><code class="ne-code"><span class="ne-text">s init</span></code><span class="ne-text"> 初始化一个项目文件夹</span></p><p id="uc7318c1b" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1642928812906-960bb2b5-46ed-4dda-a825-ae385dda7862.png" width="594" id="ue330306c" class="ne-image"></p><p id="u09c6a218" class="ne-p"><span class="ne-text">然后会弹出是否部署，输入y进行部署。（也可以不部署，等本地开发完了再部署）</span></p><p id="ude91053c" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1642929155678-bf0d1222-07cf-4673-b7a6-5f50c83111ee.png" width="448" id="u052dd7be" class="ne-image"></p><h4 id="HQlz8"><span class="ne-text">基于模板应用二次开发</span></h4><ul class="ne-ul"><li id="u1960c3a6" data-lake-index-type="0"><a href="https://github.com/wztlink1013/serverless-todolist" data-href="https://github.com/wztlink1013/serverless-todolist" target="_blank" class="ne-link"><span class="ne-text">https://github.com/wztlink1013/serverless-todolist</span></a></li></ul><p id="uf79baaff" class="ne-p"><span class="ne-text">利用</span><code class="ne-code"><span class="ne-text">s init + 模板名称</span></code><span class="ne-text">来初始化应用</span></p><p id="ueb6c8a95" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1649748232668-4e495daa-eb0a-4ed4-90db-28392edffac2.png" width="296.3333282470703" id="Tobei" class="ne-image"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1649748869374-49f98f99-73f9-41a6-9b4a-edb7eea07bc9.png" width="248.5" id="f8nP0" class="ne-image"></p><h3 id="kkjw9"><span class="ne-text">四、项目结构</span></h3><p id="ue6e48b99" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1649760098051-50a4ec96-f155-40b4-ba76-5080ae4afb47.png" width="258.1666564941406" id="u70c804b9" class="ne-image"></p><h4 id="kQKFX"><span class="ne-text">s.yaml</span></h4><ul class="ne-ul"><li id="u7ca8eadf" data-lake-index-type="0"><span class="ne-text">参考：</span><a href="https://docs.serverless-devs.com/serverless-devs/yaml" data-href="https://docs.serverless-devs.com/serverless-devs/yaml" target="_blank" class="ne-link"><span class="ne-text">https://docs.serverless-devs.com/serverless-devs/yaml</span></a></li></ul><ul class="ne-ul"><li id="uf04429bf" data-lake-index-type="0"><span class="ne-text">配置文件</span><code class="ne-code"><span class="ne-text">s.yaml</span></code></li></ul><pre><code><code># ------------------------------------#   If you need English case, you can refer to [s_en.yaml] file# ------------------------------------#   欢迎您使用阿里云函数计算 FC 组件进行项目开发#   组件仓库地址：https://github.com/devsapp/fc#   组件帮助文档：https://www.serverless-devs.com/fc/readme#   Yaml参考文档：https://www.serverless-devs.com/fc/yaml/readme#   关于：#      - Serverless Devs和FC组件的关系、如何声明/部署多个函数、超过50M的代码包如何部署#      - 关于.fcignore使用方法、工具中.s目录是做什么、函数进行build操作之后如何处理build的产物#   等问题，可以参考文档：https://www.serverless-devs.com/fc/tips#   关于如何做CICD等问题，可以参考：https://www.serverless-devs.com/serverless-devs/cicd#   关于如何进行环境划分等问题，可以参考：https://www.serverless-devs.com/serverless-devs/extend#   更多函数计算案例，可参考：https://github.com/devsapp/awesome/#   有问题快来钉钉群问一下吧：33947367# ------------------------------------edition: 1.0.0name: serverless-todolist# access 是当前应用所需要的密钥信息配置：# 密钥配置可以参考：https://www.serverless-devs.com/serverless-devs/command/config# 密钥使用顺序可以参考：https://www.serverless-devs.com/serverless-devs/tool#密钥使用顺序与规范access: default<p>vars: # 全局变量<br>  region: cn-hangzhou<br>  service:<br>    name: learn-serverless<br>    description: ‘学习Serverless demo’</p><p>services:<br>  framework: # 业务名称/模块名称<br>    # 如果只想针对 framework 下面的业务进行相关操作，可以在命令行中加上 framework，例如：<br>    # 只对framework进行构建：s framework build<br>    # 如果不带有 framework ，而是直接执行 s build，工具则会对当前Yaml下，所有和 framework 平级的业务模块（如有其他平级的模块，例如下面注释的next-function），按照一定顺序进行 build 操作<br>    component: fc # 组件名称，Serverless Devs 工具本身类似于一种游戏机，不具备具体的业务能力，组件类似于游戏卡，用户通过向游戏机中插入不同的游戏卡实现不同的功能，即通过使用不同的组件实现不同的具体业务能力<br>    actions: # 自定义执行逻辑，关于actions 的使用，可以参考：<a href="https://www.serverless-devs.com/serverless-devs/yaml#%E8%A1%8C%E4%B8%BA%E6%8F%8F%E8%BF%B0">https://www.serverless-devs.com/serverless-devs/yaml#行为描述</a><br>      pre-deploy: # 在deploy之前运行<br>        - run: npm install –production # 要执行的系统命令，类似于一种钩子的形式<br>          path: ./code # 执行系统命令/钩子的路径<br>    #        - component: fc build –use-docker               # 要运行的组件，格式为【component: 组件名 命令 参数】（可以通过s cli registry search –type Component 获取组件列表）<br>    #        - plugin: myplugin                               # 与运行的插件 （可以通过s cli registry search –type Plugin 获取组件列表）<br>    #          args:                                          # 插件的参数信息<br>    #            testKey: testValue<br>    #      post-deploy: # 在deploy之后运行<br>    #        - component: fc versions publish # 要运行的命令行<br>    props: # 组件的属性值<br>      region: $&#123;vars.region&#125; # 关于变量的使用方法，可以参考：<a href="https://www.serverless-devs.com/serverless-devs/yaml#%E5%8F%98%E9%87%8F%E8%B5%8B%E5%80%BC">https://www.serverless-devs.com/serverless-devs/yaml#变量赋值</a><br>      service: $&#123;vars.service&#125;<br>      function:<br>        name: todolist<br>        description: ‘todolist主函数’<br>        runtime: nodejs12<br>        codeUri: ./code<br>        handler: index.handler<br>        memorySize: 256<br>        timeout: 60<br>      triggers:<br>        - name: httpTrigger<br>          type: http<br>          config:<br>            authType: anonymous<br>            methods:<br>              - GET<br>              - POST<br>      customDomains:<br>        - domainName: auto<br>          protocol: HTTP<br>          routeConfigs:<br>            - path: /*</p><h1 id="next-function-第二个函数的案例，仅供参考"><a href="#next-function-第二个函数的案例，仅供参考" class="headerlink" title="next-function: # 第二个函数的案例，仅供参考"></a>next-function: # 第二个函数的案例，仅供参考</h1><h1 id="如果在当前项目下执行-s-deploy，会同时部署模块："><a href="#如果在当前项目下执行-s-deploy，会同时部署模块：" class="headerlink" title="# 如果在当前项目下执行 s deploy，会同时部署模块："></a># 如果在当前项目下执行 s deploy，会同时部署模块：</h1><h1 id="helloworld：服务hello-world-service，函数cpp-event-function"><a href="#helloworld：服务hello-world-service，函数cpp-event-function" class="headerlink" title="#   helloworld：服务hello-world-service，函数cpp-event-function"></a>#   helloworld：服务hello-world-service，函数cpp-event-function</h1><h1 id="next-function：服务hello-world-service，函数next-function-example"><a href="#next-function：服务hello-world-service，函数next-function-example" class="headerlink" title="#   next-function：服务hello-world-service，函数next-function-example"></a>#   next-function：服务hello-world-service，函数next-function-example</h1><h1 id="如果想单独部署当前服务与函数，可以执行-s-模块名-业务名-deploy，例如：s-next-function-deploy"><a href="#如果想单独部署当前服务与函数，可以执行-s-模块名-业务名-deploy，例如：s-next-function-deploy" class="headerlink" title="# 如果想单独部署当前服务与函数，可以执行 s + 模块名/业务名 + deploy，例如：s next-function deploy"></a># 如果想单独部署当前服务与函数，可以执行 s + 模块名/业务名 + deploy，例如：s next-function deploy</h1><h1 id="如果想单独部署当前函数，可以执行-s-模块名-业务名-deploy-function，例如：s-next-function-deploy-function"><a href="#如果想单独部署当前函数，可以执行-s-模块名-业务名-deploy-function，例如：s-next-function-deploy-function" class="headerlink" title="# 如果想单独部署当前函数，可以执行 s + 模块名/业务名 + deploy function，例如：s next-function deploy function"></a># 如果想单独部署当前函数，可以执行 s + 模块名/业务名 + deploy function，例如：s next-function deploy function</h1><h1 id="更多命令可参考：https-www-serverless-devs-com-fc-readme-文档相关"><a href="#更多命令可参考：https-www-serverless-devs-com-fc-readme-文档相关" class="headerlink" title="# 更多命令可参考：https://www.serverless-devs.com/fc/readme#文档相关"></a># 更多命令可参考：<a href="https://www.serverless-devs.com/fc/readme#%E6%96%87%E6%A1%A3%E7%9B%B8%E5%85%B3">https://www.serverless-devs.com/fc/readme#文档相关</a></h1><h1 id="component-fc"><a href="#component-fc" class="headerlink" title="component: fc"></a>component: fc</h1><h1 id="props"><a href="#props" class="headerlink" title="props:"></a>props:</h1><h1 id="region-vars-region"><a href="#region-vars-region" class="headerlink" title="region: $&#123;vars.region&#125;"></a>region: $&#123;vars.region&#125;</h1><h1 id="service-vars-service-应用整体的服务配置"><a href="#service-vars-service-应用整体的服务配置" class="headerlink" title="service: $&#123;vars.service&#125; # 应用整体的服务配置"></a>service: $&#123;vars.service&#125; # 应用整体的服务配置</h1><h1 id="function-定义一个新的函数"><a href="#function-定义一个新的函数" class="headerlink" title="function: # 定义一个新的函数"></a>function: # 定义一个新的函数</h1><h1 id="name-test-next-function"><a href="#name-test-next-function" class="headerlink" title="name: test-next-function"></a>name: test-next-function</h1><h1 id="description-‘新建第二个函数’"><a href="#description-‘新建第二个函数’" class="headerlink" title="description: ‘新建第二个函数’"></a>description: ‘新建第二个函数’</code></h1><p></code></pre></p><h4 id="jWJfw"><span class="ne-text">代码文件夹</span></h4><p id="ubb2c3ba6" class="ne-p"><span class="ne-text">在s.yaml中函数计算的指定代码文件夹</span></p><ul class="ne-ul"><li id="u68776d56" data-lake-index-type="0"><span class="ne-text">code文件夹里面都是项目代码，可以指定</span></li></ul><h3 id="z9TZ5"><span class="ne-text">五、本地调试</span></h3><h4 id="egUfF"><span class="ne-text">s local start</span></h4><p id="u4d1f8141" class="ne-p"><span class="ne-text">本地调试，如果出现如下报错信息，则是电脑没有安装docker环境，因为该命令需要运行在docker环境下。</span></p><p id="u09714701" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1642932170183-4ee13590-0fcf-4f65-b93d-0de6013ec5a4.png" width="416" id="uc8a6e11c" class="ne-image"></p><p id="ufa60792a" class="ne-p"><span class="ne-text">解决方案：安装docker环境，再运行。（在安装docker环境过程中，电脑出现一些问题，下文记录）</span></p><hr id="oPq4F" class="ne-hr"><p id="u0f9025ea" class="ne-p"><span class="ne-text">成功本地运行的截图如下：</span></p><p id="udc73444e" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1642940513322-7aa538fb-3847-4998-bbab-9d0a243a2948.png" width="308" id="u1836d0f9" class="ne-image"></p><h3 id="ivUhP"><span class="ne-text">使用过程遇到的问题</span></h3><h4 id="HcEPb"><span class="ne-text">Win10安装Docker过程中的问题</span></h4><ul class="ne-ul"><li id="u41d4a1c2" data-lake-index-type="0"><span class="ne-text">docker下载地址：</span><a href="https://docs.docker.com/get-started/#download-and-install-docker" data-href="https://docs.docker.com/get-started/#download-and-install-docker" target="_blank" class="ne-link"><span class="ne-text">https://docs.docker.com/get-started/#download-and-install-docker</span></a></li><li id="udf80dc38" data-lake-index-type="0"><span class="ne-text">报错如下：</span></li></ul><p id="u5e7f95f4" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1642932982672-25d5c7c1-f24f-4da3-96a0-b800128ffd61.png" width="1034" id="u3f437936" class="ne-image"></p><p id="u69564d65" class="ne-p"><span class="ne-text">解决方案：</span></p><ul class="ne-ul"><li id="u485ade09" data-lake-index-type="0"><span class="ne-text">官方：</span><a href="https://www.yuque.com/wztlink1013/blog/xnh83z" data-href="https://www.yuque.com/wztlink1013/blog/xnh83z" target="_blank" class="ne-link"><span class="ne-text">https://www.yuque.com/wztlink1013/blog/xnh83z</span></a></li><li id="ubabf72a7" data-lake-index-type="0"><span class="ne-text">参考：</span><a href="https://blog.csdn.net/mythest/article/details/92999646" data-href="https://blog.csdn.net/mythest/article/details/92999646" target="_blank" class="ne-link"><span class="ne-text">https://blog.csdn.net/mythest/article/details/92999646</span></a></li></ul><p id="ua2601d5d" class="ne-p"><span class="ne-text">因为我的电脑Windows功能中的</span><code class="ne-code"><span class="ne-text">Windows 沙盒</span></code><span class="ne-text">选项禁用了，所以要去bios更改一下相关选项</span></p><p id="ub89f66c2" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1642935156494-c5b9300e-d5b9-4249-8ea2-acc6d088f60e.png" width="415" id="u00492e03" class="ne-image"></p><p id="u7afa1cda" class="ne-p"><span class="ne-text">进入bios将下面</span><code class="ne-code"><span class="ne-text">处理虚拟化技术</span></code><span class="ne-text">选项</span><code class="ne-code"><span class="ne-text">禁用</span></code><span class="ne-text">更改为</span><code class="ne-code"><span class="ne-text">启用</span></code><span class="ne-text">之后即可</span></p><div class="ne-quote"><p id="u3018c88a" class="ne-p"><span class="ne-text">如何进入电脑的bios可以参考我的重装系统一文 </span><a href="https://www.yuque.com/wztlink1013/blog/qq1dno" data-href="https://www.yuque.com/wztlink1013/blog/qq1dno" target="_blank" class="ne-link"><span class="ne-text">https://www.yuque.com/wztlink1013/blog/qq1dno</span></a></p></div><p id="u172b807d" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/1484158/1642983119154-846652a8-03d9-45eb-928c-bf98f31cb22c.jpeg" width="553" id="u5f6d0f08" class="ne-image"></p><p id="ucf5eb3a3" class="ne-p"><span class="ne-text"></span></p><p id="u8c99432e" class="ne-p"><br></p><p id="u187699bf" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1642937039611-98695935-2d8c-481a-ae90-ed7ae100aa6b.png" width="1034" id="u950026a6" class="ne-image"></p><p id="uf70e6a8d" class="ne-p"><span class="ne-text">解决方案：</span><a href="https://docs.microsoft.com/zh-cn/windows/wsl/install-manual#step-4---download-the-linux-kernel-update-package" data-href="https://docs.microsoft.com/zh-cn/windows/wsl/install-manual#step-4---download-the-linux-kernel-update-package" target="_blank" class="ne-link"><span class="ne-text">https://docs.microsoft.com/zh-cn/windows/wsl/install-manual#step-4---download-the-linux-kernel-update-package</span></a></p><p id="u8de0881a" class="ne-p"><span class="ne-text">按照上述微软官方更新为WSL2，即可</span></p><h4 id="RRoCj"><span class="ne-text">Node：找不到模块Error: Cannot find module</span></h4><ul class="ne-ul"><li id="u7d5885cc" data-lake-index-type="0"><span class="ne-text">不用cnpm下载，用npm下载（可能是因为我删除了package-lock.json的缘故）</span></li><li id="u7238da4f" data-lake-index-type="0"><span class="ne-text">关于一些其他情况的解决方案：</span><a href="https://www.lema.fun/post/how-to-resolve-cannot-find-module-in-nodejs--588asg184" data-href="https://www.lema.fun/post/how-to-resolve-cannot-find-module-in-nodejs--588asg184" target="_blank" class="ne-link"><span class="ne-text">如何解决Node.js里“Cannot find module”的错误？</span></a></li></ul><h3 id="dA1VQ"><span class="ne-text">参考资料</span></h3><h4 id="lUgxH"><span class="ne-text">官方链接</span></h4><p id="u511fc266" class="ne-p"><span class="ne-text">组织：</span></p><ul class="ne-ul"><li id="u8a6047bf" data-lake-index-type="0"><span class="ne-text"></span><a href="https://github.com/Serverless-Devs" data-href="https://github.com/Serverless-Devs" target="_blank" class="ne-link"><span class="ne-text">https://github.com/Serverless-Devs</span></a></li><li id="u147aed0f" data-lake-index-type="0"><a href="https://github.com/devsapp" data-href="https://github.com/devsapp" target="_blank" class="ne-link"><span class="ne-text">https://github.com/devsapp</span></a></li></ul><p id="u818d810d" class="ne-p"><span class="ne-text">文档</span></p><ul class="ne-ul"><li id="u5b73b518" data-lake-index-type="0"><span class="ne-text"></span><a href="https://www.serverless-devs.com/" data-href="https://www.serverless-devs.com/" target="_blank" class="ne-link"><span class="ne-text">https://www.serverless-devs.com/</span></a></li></ul><p id="u96248c5d" class="ne-p"><span class="ne-text">阿里云函数计算组件：</span></p><ul class="ne-ul"><li id="u3ef8095b" data-lake-index-type="0"><span class="ne-text">仓库：</span><a href="https://github.com/devsapp/fc" data-href="https://github.com/devsapp/fc" target="_blank" class="ne-link"><span class="ne-text">https://github.com/devsapp/fc</span></a></li><li id="u40f93875" data-lake-index-type="0"><span class="ne-text">帮助文档：</span><a href="https://www.serverless-devs.com/fc/readme" data-href="https://www.serverless-devs.com/fc/readme" target="_blank" class="ne-link"><span class="ne-text">https://www.serverless-devs.com/fc/readme</span></a></li></ul><p id="ue63fc630" class="ne-p"><a href="https://docs.serverless-devs.com/" data-href="https://docs.serverless-devs.com/" target="_blank" class="ne-link"><span class="ne-text"><br /></span></a></p><h4 id="Shcrt"><span class="ne-text">其他参考</span></h4><div class="ne-quote"><p id="u5bc998ec" class="ne-p"><span class="ne-text">使用阿里云函数计算 FC 组件进行项目开发</span></p></div><ul class="ne-ul"><li id="uc2acbbd8" data-lake-index-type="0" style="text-align: left"><span class="ne-text">主要参考：</span><a href="https://github.com/devsapp/fc" data-href="https://github.com/devsapp/fc" target="_blank" class="ne-link"><span class="ne-text">阿里云函数计算（FC）组件</span></a></li><li id="u186a9fe0" data-lake-index-type="0" style="text-align: left"><span class="ne-text">上述组件案例：</span><a href="https://github.com/devsapp/start-fc" data-href="https://github.com/devsapp/start-fc" target="_blank" class="ne-link"><span class="ne-text">阿里云函数计算：FC 案例</span></a></li></ul><h4 id="olHbt"><span class="ne-text">Serverless搭建博客相关</span></h4><ul class="ne-ul"><li id="u85b05ee0" data-lake-index-type="0"><span class="ne-text">Serverless开发发起人：</span><a href="https://bluo.cn/" data-href="https://bluo.cn/" target="_blank" class="ne-link"><span class="ne-text">https://bluo.cn/</span></a></li><li id="u6d67367b" data-lake-index-type="0"><a href="https://developer.aliyun.com/article/739608" data-href="https://developer.aliyun.com/article/739608" target="_blank" class="ne-link"><span class="ne-text">一元建站-基于函数计算 + wordpress 构建 serverless 网站</span></a></li><li id="u4d6390de" data-lake-index-type="0"><a href="https://www.tangruiping.com/post/serverless-wordpress-typecho.html" data-href="https://www.tangruiping.com/post/serverless-wordpress-typecho.html" target="_blank" class="ne-link"><span class="ne-text">Serverless云函数计算搭建Typecho和Wordpress网站</span></a></li><li id="u16daaadf" data-lake-index-type="0"><a href="https://www.nodejs.red/#/serverless/serverless-functions-using-node-and-aws" data-href="https://www.nodejs.red/#/serverless/serverless-functions-using-node-and-aws" target="_blank" class="ne-link"><span class="ne-text">使用 Node.js 快速开启 ServerLess Functions：入门实践指南</span></a></li></ul><div class="ne-quote"><p id="uf3538f88" class="ne-p"><span class="ne-text">不过不是用的阿里云函数，而是AWL的Serverless</span></p></div><ul class="ne-ul"><li id="uc3f66836" data-lake-index-type="0"><span class="ne-text">阿里云函数入口：</span><a href="https://fcnext.console.aliyun.com/cn-hangzhou/services" data-href="https://fcnext.console.aliyun.com/cn-hangzhou/services" target="_blank" class="ne-link"><span class="ne-text">https://fcnext.console.aliyun.com/cn-hangzhou/services</span></a></li></ul></div>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
          <category> DevOps </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CloudFlare的使用</title>
      <link href="/blog/nbnax6/"/>
      <url>/blog/nbnax6/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h3 id="tKHeH"><span class="ne-text">DNS服务器+域名解析</span></h3><p id="u8423e291" class="ne-p"><span class="ne-text" style="color: #E8323C">一个问题：一个域名的DNS服务器改变了，是不是说以后这个域名的解析就要在改变后的DNS服务器上解析？</span></p><p id="u95e08730" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1649580023871-008f8e44-5b25-4148-b870-2212019b02bf.png" width="1599.9999364217147" id="u9d9783b3" class="ne-image"></p><p id="ud902ac25" class="ne-p"><span class="ne-text">是的，需要将阿里云那边的所有域名解析全部迁移到CloudFlare里面。可能最初没有发现，在哪解析都一样，但是过了一两天，就会发现阿里云那边之前解析的域名全部失效。</span></p><h3 id="eQwvi"><span class="ne-text">SSL证书配置</span></h3><p id="u7c95db01" class="ne-p"><span class="ne-text">没在阿里云那边解析，一个不好的就是，不能一键部署阿里云的免费SSL证书。</span></p><p id="u60c57cbb" class="ne-p"><span class="ne-text">解决办法就是将阿里云申请的免费证书下载下来放到网站所在环境部署。</span></p><ul class="ne-ul"><li id="u2e20f580" data-lake-index-type="0"><span class="ne-text">阿里云免费证书连接：</span><a href="https://yundun.console.aliyun.com/?spm=5176.12818093.custom--ali--widget-home-product-recent.dfa1.6b2d16d0nUogIc&amp;p=cas#/certExtend/free" data-href="https://yundun.console.aliyun.com/?spm=5176.12818093.custom--ali--widget-home-product-recent.dfa1.6b2d16d0nUogIc&amp;p=cas#/certExtend/free" target="_blank" class="ne-link"><span class="ne-text">https://yundun.console.aliyun.com/?spm=5176.12818093.custom--ali--widget-home-product-recent.dfa1.6b2d16d0nUogIc&amp;p=cas#/certExtend/free</span></a></li></ul><ul class="ne-ul"><li id="u9d3f07a5" data-lake-index-type="0"><span class="ne-text">ssl证书是将阿里云那边的免费证书下载，放到服务器里面配合使用</span></li><li id="uaf663f48" data-lake-index-type="0"><span class="ne-text">admin.wztlink1013.com：下载的是apach版本的，crt用的是公钥</span></li><li id="ue1f6187c" data-lake-index-type="0"><span class="ne-text">lyrics.wztlink1013.com：</span><a href="https://segmentfault.com/a/1190000022673232" data-href="https://segmentfault.com/a/1190000022673232" target="_blank" class="ne-link"><span class="ne-text">Nginx 安装 SSL 配置 HTTPS 超详细完整全过程</span></a></li></ul><h3 id="pkNkk"><span class="ne-text">线路分流</span></h3><p id="u25413e90" class="ne-p"><span class="ne-text">在国内访问还是比较慢。参考：</span><a href="https://colsrch.cn/posts/56951997/" data-href="https://colsrch.cn/posts/56951997/" target="_blank" class="ne-link"><span class="ne-text">https://colsrch.cn/posts/56951997/</span></a></p><h3 id="JLdzK"><span class="ne-text">域名邮箱</span></h3><h3 id="ivqgA"><span class="ne-text">CF Workers使用</span></h3><ul class="ne-ul"><li id="u39f99f0c" data-lake-index-type="0"><span class="ne-text">控制台：</span><a href="https://dash.cloudflare.com/09b722278a2b7a8145ea9739657a14c3/workers/overview" data-href="https://dash.cloudflare.com/09b722278a2b7a8145ea9739657a14c3/workers/overview" target="_blank" class="ne-link"><span class="ne-text">https://dash.cloudflare.com/09b722278a2b7a8145ea9739657a14c3/workers/overview</span></a></li><li id="u4f9cc129" data-lake-index-type="0"><span class="ne-text">文档：</span><a href="https://developers.cloudflare.com/workers/" data-href="https://developers.cloudflare.com/workers/" target="_blank" class="ne-link"><span class="ne-text">https://developers.cloudflare.com/workers/</span></a></li></ul><p id="u03529488" class="ne-p"><span class="ne-text"></span></p><p id="ub38124da" class="ne-p"><code class="ne-code"><span class="ne-text">Cloudflare Workers</span></code><span class="ne-text">实际上就是Serverless架构平台，文档说明如下：</span></p><div class="ne-quote"><p id="u2029bfa8" class="ne-p"><span class="ne-text">Cloudflare Workers provides a serverless execution environment that allows you to create entirely new applications or augment existing ones without configuring or maintaining infrastructure.</span></p></div><p id="u9bca7479" class="ne-p"><span class="ne-text">实际上和之前自己探索的阿里云函数计算以及Serverless架构应用路子一样，但是这个其实在很久之前就已经存在了，有很多在使用，但是阿里云函数计算用的人以及网上参考都是很少，所以CF的这个还是用起来不错的。</span></p><h4 id="FymwV"><span class="ne-text">两者免费额度对比</span></h4><p id="u5b32674e" class="ne-p"><span class="ne-text">Workers免费额度</span></p><p id="u0deeaf3b" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1649593011981-a0bf0d20-3e2b-4365-a805-ec8fe5742199.png" width="348.14817274222" id="u3dbbefb3" class="ne-image"></p><p id="u9613dd88" class="ne-p"><span class="ne-text">阿里云函数计算FC</span></p><p id="u6ec6bbda" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1649593091455-d73d533f-70bb-4c5d-a6c1-f05f9036a45e.png" width="821.4815395130256" id="ufb4325a7" class="ne-image"></p><p id="u9181b3cd" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/gif/1484158/1649593157255-f1f69696-8815-40c4-8976-d306ad76ba5b.gif" width="45" id="pMs0l" class="ne-image"><span class="ne-text">果然还是CFWorker香</span></p><h4 id="KgJFl"><span class="ne-text">根域名301重定向www二级域名</span></h4><p id="uc9aac9c8" class="ne-p"><span class="ne-text">之前是利用阿里云云函数计算来写了一个程序来转向</span></p><p id="uf7f4234f" class="ne-p"><span class="ne-text">放到cf里面的workers</span></p><pre><code><code>addEventListener(&quot;fetch&quot;, (event) =&gt; &#123;  event.respondWith(    handleRequest(event.request).catch(      (err) =&gt; new Response(err.stack, &#123; status: 500 &#125;)    )  );&#125;);<p>/**</p><ul><li>Many more examples available at:</li><li>  <a href="https://developers.cloudflare.com/workers/examples">https://developers.cloudflare.com/workers/examples</a></li><li>@param &#123;Request&#125; request</li><li>@returns &#123;Promise&lt;Response&gt;&#125;</li><li>/<br>const base = ‘<a href="https://www.wztlink1013.com&/#39;">https://www.wztlink1013.com&#39;</a>;<br>const statusCode = 301;</li></ul><p>async function handleRequest(request) &#123;<br>  const url = new URL(request.url);<br>  const &#123; pathname, search &#125; = url;</p><p>  const destinationURL = base + pathname + search;</p><p>  return Response.redirect(destinationURL, statusCode);<br>&#125;</code><br></code></pre></p><h3 id="IOCfw"><span class="ne-text">CF Pages使用</span></h3><p id="u64c920b8" class="ne-p"><span class="ne-text">用其部署了tianxingjiuge-qinshimingyue项目，但是并没有成功预览，不知道是哪里出问题了</span></p><p id="uc8cf2545" class="ne-p"><span class="ne-text"></span></p><p id="u63e56c03" class="ne-p"><span class="ne-text"></span></p><p id="u7b865fb8" class="ne-p"><span class="ne-text"></span></p><p id="u36f9b05a" class="ne-p"><span class="ne-text"></span></p><p id="u254bf6de" class="ne-p"><span class="ne-text"></span></p><p id="ue3797c07" class="ne-p"><span class="ne-text"></span></p></div>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
          <category> 前端性能优化 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>维</title>
      <link href="/essay/hq3fcy/"/>
      <url>/essay/hq3fcy/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="u96c35fa4" class="ne-p"><span class="ne-text">意念是多维化的体现。</span></p><p id="uba8fa4b2" class="ne-p"><span class="ne-text"></span></p><p id="u2d275003" class="ne-p"><span class="ne-text">在宇宙的浩瀚星辰中，难以被人们所定义的是空间，空间的等价转化则是维度，换言之，维度是人类难以捕捉的而又不时出现在我们日常生活中。 </span></p><p id="u697a6245" class="ne-p"><span class="ne-text"></span></p><p id="ue16ebb28" class="ne-p"><span class="ne-text">冥想是即达多维空间目的地的不错选择，冥想让我们建立思维上的楼阁，看是虚无，实则通往多维空间。 </span></p><p id="u04a7864a" class="ne-p"><span class="ne-text"></span></p><p id="uc3a69b06" class="ne-p"><span class="ne-text">任何事物都需要沟通，人类文明创立以来，进制是创先河之例，打开了与计算机沟通的大门。其实此则不然，在永恒事物变相中，有一种沟通方式可以让万物联系——多维化零进制。</span></p><p id="u59bd2bab" class="ne-p"><span class="ne-text"></span></p><p id="u3189b74e" class="ne-p"><span class="ne-text">那是谁拾起探索的光辉？又是谁如先驱们般开始质疑身边的科学，一切的一切由维度引起——多维化平行宇宙空间……</span></p><p id="u7749951d" class="ne-p"><span class="ne-text"></span></p><p id="ude271eae" class="ne-p"><span class="ne-text"></span></p></div>]]></content>
      
      
      <categories>
          
          <category> 异世界 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>645. 错误的集合🔖数组</title>
      <link href="/blog/vvs5xy/"/>
      <url>/blog/vvs5xy/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><ul class="ne-ul"><li id="u8d9d555a" data-lake-index-type="0"><a href="https://leetcode-cn.com/problems/set-mismatch/" data-href="https://leetcode-cn.com/problems/set-mismatch/" target="_blank" class="ne-link"><span class="ne-text">https://leetcode-cn.com/problems/set-mismatch/</span></a></li></ul><pre><code><code>function findErrorNums(nums: number[]): number[] &#123;    let result: any = []    nums.sort((a: number, b:number) =&gt; &#123; return a - b &#125;)    nums.forEach((data: number, index: number) =&gt; &#123;        // 重复的值        if (data === nums[index - 1]) &#123;            result.unshift(data)            nums.splice(index, 1)            nums.push(0)            // 丢失的值            for (let i: number = 0; i &lt; nums.length; i++) &#123;                if(i + 1 !== nums[i]) &#123;                    result.push(i + 1)                    break                &#125;            &#125;        &#125;    &#125;)    return result&#125;;</code></code></pre></div>]]></content>
      
      
      <categories>
          
          <category> 计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 📶线结构：字符串-数组-栈-队列 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>TODO: 30. 串联所有单词的子串🔖递归</title>
      <link href="/blog/lgg15d/"/>
      <url>/blog/lgg15d/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><ul class="ne-ul"><li id="u923bba18"><a href="https://leetcode-cn.com/problems/substring-with-concatenation-of-all-words/" data-href="https://leetcode-cn.com/problems/substring-with-concatenation-of-all-words/" target="_blank" class="ne-link"><span class="ne-text">https://leetcode-cn.com/problems/substring-with-concatenation-of-all-words/</span></a></li></ul><p id="uc4ca95dc" class="ne-p"><span class="ne-text"></span></p><h3 id="eY8Jl"><span class="ne-text">思路</span></h3></div>]]></content>
      
      
      <categories>
          
          <category> 计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 🌌递归算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>93. 复原 IP 地址🔖递归</title>
      <link href="/blog/aucxuf/"/>
      <url>/blog/aucxuf/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><ul class="ne-ul"><li id="u548cf5a7"><a href="https://leetcode-cn.com/problems/restore-ip-addresses/" data-href="https://leetcode-cn.com/problems/restore-ip-addresses/" target="_blank" class="ne-link"><span class="ne-text">https://leetcode-cn.com/problems/restore-ip-addresses/</span></a></li></ul><p id="u300a127c" class="ne-p"><span class="ne-text"></span></p><h3 id="Uh8J5"><span class="ne-text">思路</span></h3><ul class="ne-ul"><li id="u123f0828"><span class="ne-text">长度为12位：最小单元位3</span></li><li id="u999a712f"><span class="ne-text">长度为11位：最小单元位2</span></li><li id="u00b89315"><span class="ne-text">其他情况的最小单元位有可能是1</span></li></ul><p id="u07aa0710" class="ne-p"><span class="ne-text"></span></p><h3 id="P81a3"><span class="ne-text">ts代码</span></h3><pre><code>function restoreIpAddresses(s: string): string[] &#123;  // 保存所有符合条件的IP地址  let r: any[] = []  // 分四步递归处理ip分段  let search = (cur: any, sub: any) =&gt; &#123;    if (sub.length &gt; 12) return    <pre><code>// 边界条件if (cur.length === 4 &amp;amp;&amp;amp; cur.join(&#39;&#39;) === s) &#123;  r.push(cur.join(&#39;.&#39;))&#125; else &#123;  // 正常的处理过程  for (let i = 0, len = Math.min(3, sub.length), tmp; i &amp;lt; len; i++) &#123;    tmp = sub.substr(0, i + 1)    if (tmp - 256 &amp;lt; 0) &#123;      // 转换下数据类型，如 01为1（LeetCode测试用例）      search(cur.concat([tmp * 1]), sub.substr(i + 1))    &#125;  &#125;&#125;</code></pre><p>  }<br>  search([], s)<br>  return r<br>}</p><p>console.log(restoreIpAddresses(‘101023’))<br></code></pre></p></div>]]></content>
      
      
      <categories>
          
          <category> 计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 🌌递归算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>TODO: 10. 正则表达式匹配🔖正则</title>
      <link href="/blog/qg73ng/"/>
      <url>/blog/qg73ng/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><ul class="ne-ul"><li id="u3ed91f86"><a href="https://leetcode-cn.com/problems/regular-expression-matching/" data-href="https://leetcode-cn.com/problems/regular-expression-matching/" target="_blank" class="ne-link"><span class="ne-text">https://leetcode-cn.com/problems/regular-expression-matching/</span></a></li></ul></div>]]></content>
      
      
      <categories>
          
          <category> 计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 📶线结构：字符串-数组-栈-队列 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>459. 重复的子字符串🔖正则🔖字符串</title>
      <link href="/blog/rqcfeh/"/>
      <url>/blog/rqcfeh/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><ul class="ne-ul"><li id="u683cc527"><a href="https://leetcode-cn.com/problems/repeated-substring-pattern/" data-href="https://leetcode-cn.com/problems/repeated-substring-pattern/" target="_blank" class="ne-link"><span class="ne-text">https://leetcode-cn.com/problems/repeated-substring-pattern/</span></a></li></ul><p id="ubdc16351" class="ne-p"><span class="ne-text"></span></p><h3 id="QfRo2"><span class="ne-text">思路</span></h3><p id="u85e94159" class="ne-p"><span class="ne-text">基本正则模式匹配</span></p><h3 id="uDb1q"><span class="ne-text">ts代码</span></h3><pre><code>function repeatedSubstringPattern(s: string): boolean &#123;  let reg: RegExp = /^(\w+)\1+$/  return reg.test(s)&#125;<p>console.log(repeatedSubstringPattern(‘abcabcabcabc’))<br></code></pre></p></div>]]></content>
      
      
      <categories>
          
          <category> 计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 📶线结构：字符串-数组-栈-队列 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>682. 棒球比赛🔖栈</title>
      <link href="/blog/srz8lz/"/>
      <url>/blog/srz8lz/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><ul class="ne-ul"><li id="u898cb1c6" data-lake-index-type="0"><a href="https://leetcode-cn.com/problems/baseball-game/" data-href="https://leetcode-cn.com/problems/baseball-game/" target="_blank" class="ne-link"><span class="ne-text">https://leetcode-cn.com/problems/baseball-game/</span></a></li></ul><p id="ua5f6f7e4" class="ne-p"><span class="ne-text"></span></p><h3 id="FFVha"><span class="ne-text">思路</span></h3><p id="uff6e69a2" class="ne-p"><span class="ne-text">js的栈实现是利用Array的push和pop……</span></p><p id="udae4c03c" class="ne-p"><span class="ne-text"></span></p><pre><code><code>function calPoints(ops: string[]): number &#123;  let sta: Array&lt;number&gt; = []  ops.forEach((data: string) =&gt; &#123;    switch (data) &#123;      case '+':        sta.push(sta[sta.length - 1] + sta[sta.length - 2])        break      case 'D':        sta.push(sta[sta.length - 1] * 2)        break      case 'C':        sta.pop()        break      default:        sta.push(Number(data))    &#125;  &#125;)<p>  return sta.reduce((result: number, index: number) =&gt; &#123;<br>    return result + index<br>  &#125;)<br>&#125;</p><p>console.log(calPoints([‘5’, ‘-2’, ‘4’, ‘C’, ‘D’, ‘9’, ‘+’, ‘+’]))</code><br></code></pre></p></div>]]></content>
      
      
      <categories>
          
          <category> 计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 📶线结构：字符串-数组-栈-队列 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>11. 盛最多水的容器🔖数组🔖双指针</title>
      <link href="/blog/amgx01/"/>
      <url>/blog/amgx01/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><ul class="ne-ul"><li id="ub9ee704f"><a href="https://leetcode-cn.com/problems/container-with-most-water/" data-href="https://leetcode-cn.com/problems/container-with-most-water/" target="_blank" class="ne-link"><span class="ne-text">https://leetcode-cn.com/problems/container-with-most-water/</span></a></li></ul><p id="ub4ceec83" class="ne-p"><span class="ne-text"></span></p><h3 id="wvuOt"><span class="ne-text">思路</span></h3><h4 id="zm5Lb"><span class="ne-text">暴力循环解决</span></h4><ul class="ne-ul"><li id="u9e4d4ab9"><span class="ne-text">对数组各个元素进行第一遍遍历，在此之中</span><strong><span class="ne-text">以该元素为基准</span></strong><span class="ne-text">对</span><strong><span class="ne-text">该元素后面的所有元素进行遍历</span></strong><span class="ne-text">，进行</span><code class="ne-code"><span class="ne-text">两者最短高度 * （后面元素下标 - 该元素下标）</span></code><span class="ne-text">运算，遍历完成即可得到上述值的最大值result。</span></li><li id="ub9c5a2fb"><span class="ne-text">该元素后面的所有元素进行遍历：这个循环是指定开始索引的位置往后进行的遍历，使用传统for循环或是for in循环</span></li></ul><p id="ub507a9bd" class="ne-p"><span class="ne-text"></span></p><p id="u3d71db66" class="ne-p"><span class="ne-text">这种解法会超时，写的时候我就感觉到了数组的双循环八成是超时，即便我是第二个循环不找全部元素，但还是超时n^2逃不掉</span><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/1484158/1648709054571-cb914e0d-2a17-4e20-bdb3-d0f105bec0fe.jpeg" width="52" id="u4K1n" class="ne-image"></p><pre><code>function maxArea(height: number[]): number &#123;  let result: number = 0  height.forEach((data: number, index: number) =&gt; &#123;    if (index !== height.length - 1) &#123;      for (let i: number = index + 1; i &lt; height.length; i++) &#123;        let result_temp = Math.min(height[i], data) * (i - index)        result &gt; result_temp ? (result = result) : (result = result_temp)      &#125;    &#125;  &#125;)  return result<p></code></pre></p><p id="u903f225f" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1648707457045-2a083f7a-faab-4354-91bf-7a6b9e45c867.png" width="1300.8332816428629" id="uc882220e" class="ne-image"></p><h4 id="bpe3H"><span class="ne-text">两端双指针移动解决</span></h4><ul class="ne-ul"><li id="u7385276d"><span class="ne-text">探究解决办法的规律来解决问题，利用双指针在首末端往中间靠，每次移动arr[指针]小的，然后在此次与result相比较。</span></li><li id="u3f46a4a7"><span class="ne-text">这样只需要遍历一遍即可，时间复杂度为n</span></li></ul><p id="u80e14356" class="ne-p"><span class="ne-text"></span></p><pre><code>function maxArea(height: number[]): number &#123;  let head: number = 0  let back: number = height.length - 1  const result_fun = (head: number, back: number): number =&gt; &#123;    return Math.min(height[head], height[back]) * (back - head)  &#125;  let result = result_fun(head, back)<p>  while (head !== back) &#123;<br>    height[head] &lt; height[back] ? head++ : back–<br>    if(result &lt;= result_fun(head, back) ) result = result_fun(head, back)<br>  &#125;</p><p>  return result<br>&#125;<br></code></pre></p><p id="u36e90195" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1648710814761-4255d705-1462-47ed-8a96-ad66c4bf25a6.png" width="599.999976158143" id="u401ae785" class="ne-image"></p><p id="u7cc03987" class="ne-p"><span class="ne-text"></span></p><p id="ucf47e7f1" class="ne-p"><span class="ne-text"></span></p><p id="u45d2fc7b" class="ne-p"><span class="ne-text"></span></p><p id="u85afaab6" class="ne-p"><span class="ne-text"></span></p><p id="u31ad7968" class="ne-p"><span class="ne-text"></span></p><p id="u3ea57d64" class="ne-p"><span class="ne-text"></span></p><p id="ucbf45dc3" class="ne-p"><span class="ne-text"></span></p><p id="u0d5526ac" class="ne-p"><span class="ne-text"></span></p><p id="ua16ce551" class="ne-p"><span class="ne-text"></span></p><p id="u1a516ef3" class="ne-p"><span class="ne-text"></span></p></div>]]></content>
      
      
      <categories>
          
          <category> 计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 📶线结构：字符串-数组-栈-队列 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>疫情下的空城与花海</title>
      <link href="/essay/gvzzcs/"/>
      <url>/essay/gvzzcs/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="ud8bce089" class="ne-p"><span class="ne-text">我们总喜欢作为旁观者去看待未能触及到自身的悲景，而这个世界上最悲观的身旁之物我想应该就是死亡了。</span></p><p id="u8d57e81f" class="ne-p"><span class="ne-text"></span></p><p id="u973b2519" class="ne-p"><strong><span class="ne-text">空城</span></strong></p><p id="u7c61ba01" class="ne-p"><span class="ne-text"></span></p><p id="ufb565da6" class="ne-p"><span class="ne-text">到现在已有两年之久的心冠疫情，或许就是近些年来让我们体会到死亡的传使者，生命变得消亡，聚集场所变得暗淡，像是给我们笼罩一层未能看见的阴霾，我很讨厌这么一个微小生生物为生活所带来的暗色调。</span></p><p id="u8fbaffd3" class="ne-p"><span class="ne-text"></span></p><p id="u4ec1ac32" class="ne-p"><span class="ne-text">东方航空MU5735的坠毁。在学校和家里的来往，我常坐飞机这一交通形式，我体验过飞机通过强气流带来的机体剧烈晃动，飞机失事的情况，我想，那几分钟是很绝望的，你只能坐在自己座椅上，被飞机下坠的惯性将自己身体硬拽在靠椅上，窗边呼啸的气流声，让你面无神色。我很讨厌大自然偶尔的霸道无理的脾气。</span></p><p id="u4140cd6c" class="ne-p"><span class="ne-text"></span></p><p id="uf876e599" class="ne-p"><strong><span class="ne-text">花海</span></strong></p><p id="ue1302591" class="ne-p"><span class="ne-text"></span></p><p id="u8508c042" class="ne-p"><span class="ne-text">学校的三月是一个有花的季节，成片的花香与色彩遍布整个校园。</span></p><p id="u2d0758a0" class="ne-p"><span class="ne-text">成片的花海是我22年觉得最美的一件事物，她将周围的灰色染成五彩斑斓的景色。</span></p><p id="u7d66b47e" class="ne-p"><span class="ne-text"></span></p><p id="uf6e113a6" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/1484158/1648700562531-b0b2bf77-4d97-40e1-a7b0-880d8d188c60.jpeg" width="1216" id="rGCAP" class="ne-image"></p><p id="u89ecd93d" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/1484158/1648700589001-880ca871-1ae5-4ab0-8093-5b09c50f8f63.jpeg" width="1216" id="yMKAc" class="ne-image"></p><p id="u7631b671" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/1484158/1648700686067-283184da-ffb4-4ff7-84b3-465dbcdfa76b.jpeg" width="1216" id="dblVL" class="ne-image"></p><p id="uf5316d82" class="ne-p"><span class="ne-text"></span></p><p id="u0296b290" class="ne-p"><span class="ne-text">花会枯萎，树会凋零，一瞬的美好终会陨落</span></p><p id="ue354674b" class="ne-p"><span class="ne-text">一瞬美好存于此的的意义会是什么呢</span></p><p id="u2e9b7c93" class="ne-p"><span class="ne-text">我不曾知道，也未曾想过</span></p><p id="ue4180be1" class="ne-p"><span class="ne-text">可是这些一个月的美丽都不曾保留的美丽，让我些许顿悟</span></p><p id="u3c7db598" class="ne-p"><span class="ne-text">美好的意义或许就是美好本身，她不需要太多的形容</span></p><p id="u86939c2e" class="ne-p"><span class="ne-text">你会因为她的绽放感到开心、感到愉悦、感到这世上原来还有这么美好的事物</span></p><p id="u98e389c4" class="ne-p"><span class="ne-text"></span></p><p id="ub40bc1ea" class="ne-p"><span class="ne-text">任何事物的存在都必然伴随着其存在的意义</span></p><p id="u28a79194" class="ne-p"><br></p></div>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>从输入 URL 到页面加载完成，发生了什么？在此流程中做优化！</title>
      <link href="/blog/lvs755/"/>
      <url>/blog/lvs755/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="u2fc17575" class="ne-p"><span class="ne-text">前言：从输入 URL 到页面加载完成，发生了什么？</span></p><p id="uddb4c6a5" class="ne-p"><span class="ne-text"></span></p><p id="uc5de653e" class="ne-p"><span class="ne-text">输入URL，浏览器会先处理输入的信息是搜索信息还是URL请求连接，这个过程需要浏览器的URL解析操作；然后我们需要通过 DNS（域名解析系统）将 URL 解析为对应的 IP 地址，然后与这个 IP 地址确定的那台服务器建立起 TCP 网络连接，随后我们向服务端抛出我们的 HTTP 请求，服务端处理完我们的请求之后，把目标数据放在 HTTP 响应里返回给客户端，拿到响应数据的浏览器就可以开始走一个渲染的流程。渲染完毕，页面便呈现给了用户，并时刻等待响应用户的操作。</span></p><p id="uc80a875b" class="ne-p"><span class="ne-text"></span></p><p id="u561ad2be" class="ne-p"><span class="ne-text">具体大致过程如下：</span></p><ol class="ne-ol"><li id="u067f5cbc"><span class="ne-text">URL解析</span></li><li id="uc53e72f2"><span class="ne-text">DNS解析</span></li><li id="u2b6e56f3"><span class="ne-text">TCP连接</span></li><li id="uce68944d"><span class="ne-text">客户端发送请求</span></li><li id="u46165cd2"><span class="ne-text">服务端处理请求，响应请求</span></li><li id="uae7019d8"><span class="ne-text">客户端和服务端断开连接</span></li><li id="u1a074c0e"><span class="ne-text">浏览器拿到响应数据，解析响应内容，把解析的结果渲染展示给用户</span></li></ol><p id="ub70b78cb" class="ne-p"><span class="ne-text"></span></p><p id="u01bae1f7" class="ne-p"><span class="ne-text">而前端性能优化，就是把这 5 个过程滴水不漏地考虑到自己的性能优化方案内、反复权衡，从而打磨出用户满意的速度。</span></p><p id="u19e8d619" class="ne-p"><span class="ne-text"></span></p><div class="ne-quote"><p id="u3c39882e" class="ne-p"><span class="ne-text">文章参考以下两个文章，基于以下文章并做出部分自己的修改：</span></p><ul class="ne-ul"><li id="u14c64fe7"><a href="https://www.kancloud.cn/sllyli/performance/1242194" data-href="https://www.kancloud.cn/sllyli/performance/1242194" target="_blank" class="ne-link"><span class="ne-text">前端性能优化原理与实践</span></a></li><li id="u66e796d7"><a href="https://juejin.cn/post/6844904194801926157" data-href="https://juejin.cn/post/6844904194801926157" class="ne-link"><span class="ne-text">从输入URL到渲染全过程</span></a></li><li id="ue1c40704"><a href="https://segmentfault.com/a/1190000017184701" data-href="https://segmentfault.com/a/1190000017184701" target="_blank" class="ne-link"><span class="ne-text">从URL输入到页面展现到底发生什么？</span></a></li></ul></div><h2 id="fkLx5"><span class="ne-text">一、URL解析与缓存检查</span></h2><h3 id="sBzKf"><span class="ne-text">地址解析和编码</span></h3><p id="ub827738a" class="ne-p"><span class="ne-text">我们输入URL后，浏览器会解析输入的字符串，判断是URL还是搜索关键字，如果是URL就开始编码。<br /></span></p><p id="udef58a97" class="ne-p"><span class="ne-text">一般来说URL只能使用英文字母、阿拉伯数字和某些标点符号，不能使用其他文字和符号，所以，如果URL中有文字就必须编码后使用。但是URL编码很混乱，不同的操作系统、浏览器、网页字符集，会导致不同的编码结果。所以我们需要使用JavaScript先对URL编码，然后提交给服务器，不给浏览器插手的机会。我们通常会使用encodeURI()函数或者encodeURIComponent()函数来编码URL</span></p><h3 id="IMnj6"><span class="ne-text">HSTS</span></h3><p id="uc5ae8a65" class="ne-p"><span class="ne-text">HSTS(HTTP Strict TransportSecurity)是一种新的Web安全协议，HSTS的作用是强制客户端使用HTTPS与服务器创建连接。比如你在地址栏输入http://xxx/，浏览器会自动将http转写成https，然后直接向</span><span class="ne-text">https://xxx/</span><span class="ne-text"> 发送请求。</span></p><h3 id="h3tJI"><span class="ne-text">缓存检查</span></h3><p id="uff4993aa" class="ne-p"><span class="ne-text">浏览器在发送请求之前先检查有没有缓存，过程如下： </span><img src="https://cdn.nlark.com/yuque/0/2022/webp/1484158/1653193882930-3c261c9c-875f-4ee5-994b-e8fcf22272ee.webp" width="556" id="ue084b2ed" class="ne-image"></p><p id="u9a262410" class="ne-p"><span class="ne-text">浏览器会先去查看强缓存（Expires和cache-control）判断是否过期，如果强缓存生效，直接从缓存中读取资源；若不生效则进行协商缓存(Last-Modified / If-Modified-Since和Etag/If-None-Match)，协商缓存由服务器决定是否使用缓存，若协商缓存失效，那么代表该请求的缓存失效，返回200，并重新返回资源和缓存标识，再次存入浏览器缓存中；生效则返回304，并从缓存中读取资源。（协商缓存之前要经过DNS域名解析，之后建立TCP链接）</span></p><p id="u05f4739d" class="ne-p"><span class="ne-text"></span></p><p id="u40bf2323" class="ne-p"><span class="ne-text">那么浏览器缓存的位置在哪呢？</span></p><ul class="ne-ul"><li id="u2a691d56"><span class="ne-text">Service Worker：浏览器独立线程进行缓存</span></li><li id="ub192ead7"><span class="ne-text">Memory Cache：内存缓存</span></li><li id="ue8f5ead7"><span class="ne-text">Disk Cache：硬盘缓存</span></li><li id="u7ec40f81"><span class="ne-text">Push Cache：推送缓存（HTTP/2中的）</span></li></ul><p id="u702a4534" class="ne-p"><span class="ne-text"></span></p><p id="uca2781b8" class="ne-p"><strong><span class="ne-text">注意</span></strong><span class="ne-text">：输入网址之后，会查找内存缓存，没有再找硬盘，都没有就发生网络请求。 普通刷新（F5）：因为TAB没有关闭，所以内存缓存可用，如果匹配上会被优先使用，其次是磁盘缓存 强制刷新（Ctrl+F5）：浏览器不使用缓存，因此发送的请求头均带有Cache-control：no-cache,服务器直接返回200和最新内容。</span></p><h2 id="rq2lt"><span class="ne-text">二、DNS解析</span></h2><h3 id="Ods3i"><span class="ne-text">DNS</span></h3><ul class="ne-ul"><li id="u366d3502"><span class="ne-text">DNS：把域名和ip地址相互映射分布式数据库，让用户能更方便的访问互联网，DNS协议运行在UDP协议之上</span></li><li id="u6affd3cd"><span class="ne-text">DNS解析：通过域名最终得到对应ip地址的过程。</span></li><li id="u18654d17"><span class="ne-text">DNS缓存：浏览器，操作系统，路由器，本地DNS，根域名服务器都会对DNS结果作出一定的缓存</span></li></ul><h3 id="qAZgt"><span class="ne-text">DNS解析过程</span></h3><ol class="ne-ol"><li id="u2ecc5cd1"><span class="ne-text">首先搜索浏览器自身的DNS缓存，有缓存直接返回;</span></li><li id="ue9619d95"><span class="ne-text">浏览器自身DNS不存在，浏览器就会调用一个类似gethostbyname的库函数,此函数会先去检测本地hosts文件，查看是否有对应ip。</span></li><li id="ub5969738"><span class="ne-text">如果本地hosts文件不存在映射关系，就会查询路由缓存，路由缓存不存在就去查找本地DNS服务器（一般TCP/IP参数里会设首选DNS服务器，通常是8.8.8.8)(客户端到本地DNS服务器是递归过程）</span></li><li id="ue13d369c"><span class="ne-text">如果本地DNS服务器还没找到就会向根服务器发出请求。（DNS服务器之间是迭代过程）</span></li></ol><p id="u9c37fde4" class="ne-p"><br></p><p id="ub4d0dd01" class="ne-p"><span class="ne-text">具体过程：<br /></span></p><ul class="ne-ul"><li id="u63850f02"><span class="ne-text">本地DNS服务器代我们的浏览器发起迭代DNS解析请求，首先它会找根域的DNS的IP地址（全球13台哟，可惜中国没有！）。找到根域的DNS地址,就会向其发起请求（请问www.baidu.com这个域名的IP地址是多少呀？）；<br /></span></li><li id="uc68a7e80"><span class="ne-text">根域发现这是一个顶级域com域的一个域名，于是告诉本地DNS服务器我不知道这个域名的IP地址,但是我知道com域的IP地址，你去找它去吧；<br /></span></li><li id="ua40604c7"><span class="ne-text">于是本地DNS服务器就得到了com域的IP地址，又向com域的IP地址发起了请求（请问www.baidu.com这个域名的IP地址是多少呀?）,于是com域服务器告诉本地DNS服务器我不知道www.baidu.com这个域名的IP地址，但是我知道baidu.com这个域的DNS地址，你去找它去;<br /></span></li><li id="ufaa1d0a0"><span class="ne-text">于是本地DNS服务器又向baidu.com这个域名的DNS地址（这个一般就是由域名注册商提供的，像万网，新网等）发起请求（请问www.baidu.com这个域名的IP地址是多少？），这个时候baidu.com域的DNS服务器一查，呀！果真在我这耶，于是就把找到的结果发送给本地DNS服务器;<br /></span></li><li id="u8cf01fe8"><span class="ne-text">这个时候本地DNS服务器就拿到了www.baidu.com这个域名对应的IP地址。</span></li></ul><p id="u0fbd0b32" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1653195503382-8d0d2c0b-904d-4f6f-ab2a-a41fde109da2.png" width="732" id="u07bfc271" class="ne-image"></p><h3 id="lkiXv"><span class="ne-text">DNS优化</span></h3><p id="u91118b2b" class="ne-p"><span class="ne-text">DNS也是开销，通常浏览器查找一个给定域名的IP地址要花费20~120毫秒，在完成域名解析之前，浏览器不能从服务器加载到任何东西。那么如何减少域名解析时间，加快页面加载速度呢？</span></p><ul class="ne-ul"><li id="ua58ce1cb"><span class="ne-text">减少DNS请求次数</span></li><li id="ufc2a45bc"><span class="ne-text">DNS预获取,DOM还没开始，浏览器预解析地址，把解析好的地址放在本地缓存里面，DOM树生成完，要加载图片类的发现DNS已经解析好了，再发送请求。&lt;link rel='dns-prefetch'href='//dfns.tanx.com'&gt;<br /></span><span class="ne-text">（主要对图片资源）</span></li><li id="u41a1cadd"><span class="ne-text">DNS 查询的过程经历了很多的步骤，如果每次都如此，会耗费太多的时间、资源。所以我们应该尽早的返回真实的IP地址:（减少查询过程，也就是DNS缓存。浏览器获取到IP地址后，一般都会缓存到浏览器的缓存中，本地的DNS缓存服务器，也可以去记录。另外，每天几亿网名的访问需求，一秒钟几千万的请求域名服务器如何满足？就是DNS负载均衡。通常我们的网站应用各种云服务，或者各种服务商提供类似的服务，由他们去帮我们处理这些问题。 DNS系统根据每台机器的负载量，地理位置的限制（长距离的传输效率）等等，去提供高效快速的 DNS 解析服务。</span></li><li id="ub53fb360"><span class="ne-text">当客户端DNS缓存（浏览器和操作系统）缓存为空时，DNS查找的数量与要加载的Web页面中唯一主机名的数量相同，包括页面URL、脚本、样式表、图片、Flash对象等的主机名。减少主机名的数量就可以减少DNS查找的数量；</span></li><li id="u27ac4863"><span class="ne-text">减少唯一主机名的数量会潜在减少页面中并行下载的数量（HTTP1.1规范建议从每个主机名并行下载两个组件，但实际上可以多个）；但是减少主机名和并行下载的方案会产生矛盾，需要大家自己权衡。建议将组件放到至少两个但不多于4个主机名下，减少DNS查找的同时也允许高度并行下载。</span></li></ul><p id="u9b351d9d" class="ne-p"><strong><span class="ne-text">DNS解析后会把域名的解析权交给cname()指向的内容分发（CDN）专用的DNS服务器。CDN专用的DNS服务器把CDN的全局负载均衡设备的ip地址返回给用户</span></strong><span class="ne-text">。</span></p><h3 id="eX2Gt"><span class="ne-text">CDN</span></h3><p id="u43c690d3" class="ne-p"><span class="ne-text">举个例子：以前坐火车买票，都要到火车站买，所有人都去火车站买票，火车站售票厅的压力可想而知有多大。</span></p><p id="ufa4b6417" class="ne-p"><span class="ne-text">后来火车票代售点出现了，分布在各个城市，城镇，我们只需要去距离我们最近的火车票售卖点买票就可以了。 卖火车票的代理售票点（缓存服务器），为买票者提供了方便，帮助他们在最近的地方（最近的CDN节点）， 用最短的时间（最短的请求时间）买到票（拿到资源）。减轻了售票大厅的压力（起到分流作用，减轻服务器负载压力）</span></p><h4 id="UZbAn"><span class="ne-text">CDN缓存</span></h4><p id="uf2a937d7" class="ne-p"><span class="ne-text">在浏览器本地缓存失效后，浏览器会像CDN边缘节点发起请求，类似浏览器缓存，CDN边缘节点也存在一套缓存机制，</span></p><ul class="ne-ul"><li id="uef250afb"><span class="ne-text">CDN边缘节点缓存策略因服务商不同而不同，通过http响应头中的cache-control：max-age字段设置CDN边缘节点数据缓存时间。</span></li><li id="u701c37ab"><span class="ne-text">当浏览器向CDN节点请求数据时，CDN节点会判断缓存数据是否过期，若缓存数据过期，CDN会向服务器发出回源请求，从服务器拉取最新数据，更新本地缓存，并将最新数据返回给客户端，CDN服务商一般会提供基于文件后缀，目录多个维度来指定CDN缓存时间，为用户提供更精细化的缓存管理。</span></li></ul><h4 id="S0HlG"><span class="ne-text">CDN工作方式</span></h4><p id="u748269ee" class="ne-p"><span class="ne-text">（1）、当你点击网站页面的url时，经过本DNS解析，DNS解析后会把域名的解析权交给cname()指向的内容分发专用的DNS服务器。内容分发专用的DNS服务器把内容分发的全局负载均衡（GSLB）设备的ip地址返回给用户。<br /></span><span class="ne-text">（2）、当你向CDN的全局负载均衡设备的ip地址发起url访问请求，CDN的全局负载均衡设备会为你选择一台合适的缓存服务器提供服务。<br /></span></p><ul class="ne-ul"><li id="u62d633c9"><span class="ne-text">选择的依据：用户的ip地址，判断哪台服务器距离用户最近，根据用户请求的url中携带的内容名称判断哪台服务器上有用户要的数据，查询各个服务器当前负载情况，判断哪台服务器有服务能力。<br /></span></li><li id="u55721196"><span class="ne-text">分配：基于这些条件综合分析后，区域负载均衡设备会向全局负载均衡设备请求返回一台缓存服务器的IP地址。全局负载均衡设备返回服务器IP地址，用户向缓存服务器发起请求，缓存服务器响应用户请求，将用户所需内容传送到用户终端，如果这台缓存服务器没有用户想要的内容，而区域均衡设备依然将它分配给了用户，那么这台服务器就要向它的上一级缓存服务器请求内容，直至追溯到网站的源服务器将内容拉到本地。域名解析服务器根据用户ip地址，把域名解析成相应节点的缓存服务器ip地址，实现用户就近访问，使用CDN服务的网站，只要将其域名解析权交给CDN的全局负载均衡设备，将需要分发的内容注入到CDN就可以实现内容加速了。</span></li></ul><h4 id="zodWC"><span class="ne-text">CDN优势</span></h4><p id="uec018701" class="ne-p"><span class="ne-text">（1）、CDN节点解决了跨运营商和跨地域访问的问题，访问延时大大降低；<br /></span><span class="ne-text">（2）、大部分请求在CDN边缘节点完成，CDN起到分流作用，减轻了源服务器的负载。</span></p><h4 id="toj6z"><span class="ne-text">CDN劣势</span></h4><p id="u72ad3543" class="ne-p"><span class="ne-text">（1）、当网站更新时，如果CDN节点上数据没有及时更新，即便用户在浏览器使用 Ctrl +F5 的方式使浏览器端的缓存失效，也会因为CDN边缘节点没有同步最新数据而导致用户访问异常。<br /></span><span class="ne-text">（2）、CDN不同的缓存时间会对“回源率”产生直接的影响：</span></p><ul class="ne-ul"><li id="ud3847853"><span class="ne-text">如果缓存时间短，CDN边缘节点的内容经常失效，导致频繁回源。不仅增加服务器压力，也增加了用户访问时间。</span></li><li id="u8134ca1a"><span class="ne-text">如果缓存时间长，数据更新了，边缘节点的内容都还没更新，开发者对特定的任务做特定的数据缓存时间管理。</span></li></ul><h4 id="r5Rk6"><span class="ne-text">CDN刷新缓存</span></h4><p id="u417fd3e2" class="ne-p"><span class="ne-text">CDN边缘节点对开发者是透明的，相比于浏览器Ctrl+F5的强制刷新来使浏览器本地缓存失效，开发者可以通过CDN服务商提供的“刷新缓存”接口来达到清理CDN边缘节点缓存的目的。这样开发者在更新数据后，可以使用“刷新缓存”功能来强制CDN节点上的数据缓存过期，保证客户端在访问时，拉取到最新的数据。 |</span></p><h4 id="volWx"><span class="ne-text">CDN优化</span></h4><p id="u94a8c92b" class="ne-p"><span class="ne-text">（1）、前端需要被加速的文件大致包括：</span></p><p id="u68ee3330" class="ne-p"><span class="ne-text">js、css、图片、视频、和页面等文件。页面文件有动态和静态之分。这些文件和页面（比如html）最大的区别是：这些文件都是静态的，改动比较小，这类静态文件适合做CDN加速。我们把这些静态文件通过CDN分发到世界各地的节点，用户可以在距离最近的边缘节点拿到需要的内容，从而提升内容下载速度加快网页打开速度。页面分为动态页面和静态页面，动态页面不适合做CDN缓存，因为页面是动态的话，内容的有效期就比较活跃。边缘节点的数据经常失效要回源，造成源服务器压力。</span></p><p id="ue916f043" class="ne-p"><span class="ne-text">（2）、减少资源请求的等待时间</span></p><p id="uc64d549d" class="ne-p"><span class="ne-text">不同浏览器的并发数量不一样：IE11 、IE10 、chrome、Firefox 的并发连接数是 6个，IE9是10个。如果页面静态资源（图片等）过多（大于6个）会存在资源请求等待的情况。目前现实状况是大多用户带宽越来越大，但是我们的静态资源并非那么大，很多文件都是几k或者几十k，6个文件加起来都小于带宽。这样就导致了资源的浪费。</span></p><ul class="ne-ul"><li id="u2f5c8e34"><span class="ne-text">解决方案是：用多个不同IP的服务器来存储这些文件，并在页面中通过绝对路径的方式引用（要求同一IP的文件不超过6个）。这样就可以尽可能的减少资源请求等待的情况。</span></li></ul><p id="u09f49834" class="ne-p"><strong><span class="ne-text"></span></strong></p><p id="ub2704e18" class="ne-p"><strong><span class="ne-text">至此，你已经获取到缓存服务器的IP地址，并且准备向这个IP地址发送请求了。</span></strong></p><p id="u22b1278d" class="ne-p"><span class="ne-text"></span></p><h2 id="C0RQK"><span class="ne-text">三、TCP连接</span></h2><h3 id="hloA5"><span class="ne-text">TCP</span></h3><ul class="ne-ul"><li id="ua56b69d6"><span class="ne-text">TCP是一种面向连接的，可靠的，基于字节流的传输层通信协议。</span></li><li id="u8d6b838e"><span class="ne-text">建立TCP连接需要进行三次握手。过程如下：</span></li></ul><p id="ubcd3106f" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/webp/1484158/1653194429604-83b7eccb-7572-4c7b-826e-c9b9fe62c4b4.webp" width="465.99542236328125" id="u757bb214" class="ne-image"></p><p id="u42b8f525" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/webp/1484158/1653194443274-6c98150b-79e8-4075-adb5-9f05ca79decb.webp" width="434.99542236328125" id="u1fd5e20c" class="ne-image"></p><h3 id="kqyTN"><span class="ne-text">TCP握手过程</span></h3><ol class="ne-ol"><li id="u12e06ce3"><span class="ne-text">客户端发送带有SYN标识（SYN=1，seq=x）的请求报文段，然后进入SYN_SEND状态，等待服务端确认;</span></li><li id="u1b40cbc8"><span class="ne-text">服务端接收到客户端SYN报文段后，需要发送ACK信息对这个SYN进行确认，同时还要发送自己的SYN信息（SYN=1，ACK=1，seq=y，ack=x+1）服务端把这些信息放在一个报文段中（（SYN+ACK报文段），一并发给客户端，此时客户端进入SYN_RECV状态;</span></li><li id="u9b0cb1c5"><span class="ne-text">客户端接收到服务端的SYN+ACK报文段后会向服务端发送ACK（ACK=1，seq=x+，ack=y+1）确认报文段，这个报文段发送后，客户端和服务端都进入ESTABLISHED状态，完成三次握手。</span></li></ol><p id="u825b3e7a" class="ne-p"><span class="ne-text"></span></p><ul class="ne-ul"><li id="ufbd5f6d3"><span class="ne-text">第一次握手： 客户端向服务端携带有客户端数据通讯初始序列号的报文，并进入SYN-SENT状态，当客户端收到数据时证明服务端知道：客户端的发送能力、服务端的接受能力正常。</span></li><li id="u03131e7d"><span class="ne-text">第二次握手： 服务端将响应客户端数据通讯初始序列号和服务端数据通讯初始序列号放入报文中一起发送给客户端。发送结束后服务端进入SYN-RECEIVED状态。当客户端接受到数据证明在客户端的角度上知道：客户端和服务端的发送、接收能力是正常的。</span></li><li id="u58ae2ea7"><span class="ne-text">第三次握手： 客户端向服务端发送一个确认应答，并进入ESTABLISHED状态，服务端收到应答后也进入ESTABLISHED状态完成三次握手。这时候在服务端知道：服务端的发送能力、客户端的接收能力正常。</span></li></ul><p id="ufaa3bb3d" class="ne-p"><span class="ne-text"></span></p><h3 id="saWty"><span class="ne-text" style="color: rgb(51, 51, 51)">为什么TCP建立是三次握手？</span></h3><ul class="ne-ul"><li id="u4bdbc399"><span class="ne-text">双方要明确对方接收能力都是正常的，（客户端发之后，服务端可以确定客户端发送能力正常，服务端发送给客户端，客户端可以确定服务端的接收和发送能力正常，最后客户端发送确认，来确定客户端的接收能力。</span></li><li id="udd590ea5"><strong><span class="ne-text">为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误</span></strong><span class="ne-text">。</span></li><li id="ue1d939b1"><span class="ne-text">第三次握手除了让服务端知道，服务端发送能力和客户端的接收能力正常之外，还可以防止数据报延迟带来的不必要的资源消耗：当客户端发起tcp第一次握手的请求时，因为网络问题滞留在网络中，这时候客户端因为等待太久没有响应所以自动重发了握手请求并完成了所有数据请求关闭了与服务端的链接，这时候服务端才接收到第一次滞留在网络中的握手请求，服务端会向客户端发送第二次握手并处于等待第3次握手状态，客户端接收到第二次握手请求后发现是过期的请求就可以通过停止发送第三次握手，服务端一段时间没接到第三次握手请求会自动关闭请求监听。</span></li></ul><h3 id="qlDE4"><span class="ne-text">TLS（HTTPS）</span></h3><ul class="ne-ul"><li id="ufc9b5ca0"><strong><span class="ne-text">如果是HTTP连接，三次握手成功后，便建立起链接，如果是HTTPS连接，还需要传输层安全性协议（TLS）</span></strong></li></ul><p id="u9212e87f" class="ne-p"><strong><span class="ne-text"></span></strong></p><p id="ub8934ba0" class="ne-p"><span class="ne-text">TLS工作于传输层之上，应用层之下，默认作用于服务端的443端口,在TLS中可以分成两种加密技术：</span></p><ul class="ne-ul"><li id="u953bb96d"><strong><span class="ne-text">对称性加密</span></strong><span class="ne-text">：客户端和服务端拥有相同的密钥，通过密钥对密文解密。用于密文通讯</span></li><li id="u22948b5f"><strong><span class="ne-text">非对称性加密</span></strong><span class="ne-text">：在该模式下，密钥分为公钥和私钥，用公钥加密的数据必须用私钥解密，用私钥加密的数据需要用公钥解密，公钥可以通过服务端发送给各个客户端，私钥则只由服务端持有，所有该模式主要用于传递对称性密钥阶段。</span><span class="ne-text">加密流程如下图：</span></li></ul><p id="uef1141f4" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/webp/1484158/1653195667430-9725fd8f-69c1-4691-acae-9aea61ff7e4a.webp" width="371.99542236328125" id="u62e8caf3" class="ne-image"></p><p id="u1beab470" class="ne-p"><span class="ne-text">其中数字证书是由服务端生成的非对称加密公钥和数字签名组成加密形成，数字签名是服务器在第三方机构注册校验服务器身份的数据，当客户端接收到数字证书是可以通过比对第三方机构注册的信息从而判断该报文是否是从目标服务器中传出来，从而确定公钥是否被调包。如果比对成功，客户端会生成对称性加密的密钥通过服务端派发的公钥进行加密传输给服务端，之后的信息传递就通过这个密钥进行对称性加密传输。</span></p><p id="uffe13a3e" class="ne-p"><span class="ne-text"></span></p><h2 id="cQNOT"><span class="ne-text">四、客户端发送请求</span></h2><p id="u26855b84" class="ne-p"><span class="ne-text">TCP三次握手建立连接成功后，客户端按照</span><strong><span class="ne-text">指定的格式</span></strong><span class="ne-text">开始向服务端发送HTTP请求。</span></p><h3 id="hds73"><span class="ne-text">请求报文结构</span></h3><p id="ud1d43de5" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1653196268394-7d03589e-0451-42d8-a460-7165186625a6.png" width="616" id="ua22d4039" class="ne-image"></p><h4 id="NPCpT"><span class="ne-text" style="color: rgb(33, 37, 41)">请求报头</span></h4><p id="u6604c20f" class="ne-p"><span class="ne-text" style="color: rgb(33, 37, 41); font-size: 16px">请求报头允许客户端向服务器传递请求的附加信息和客户端自身的信息。<br /></span><span class="ne-text" style="color: rgb(33, 37, 41); font-size: 16px">PS: 客户端不一定特指浏览器，有时候也可使用Linux下的CURL命令以及HTTP客户端测试工具等。<br /></span><span class="ne-text" style="color: rgb(33, 37, 41); font-size: 16px">常见的请求报头有: Accept, Accept-Charset, Accept-Encoding, Accept-Language, Content-Type, Authorization, Cookie, User-Agent等。</span></p><p id="uda7247c5" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1653196015114-144aaadd-3f62-429d-a4ad-ba31e48a49dd.png" width="381.99542236328125" id="u41a7308a" class="ne-image"></p><p id="ua7a5e432" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1653196053367-789ac83b-4ea6-4f5c-ab5b-71064638eaca.png" width="380.99542236328125" id="u1d78f2c8" class="ne-image"></p><p id="u84000e8c" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1653196074822-50723931-5917-4a05-ab3b-cffa30bcdc1d.png" width="377.99542236328125" id="udc2cc044" class="ne-image"></p><p id="u2873aeb8" class="ne-p"><span class="ne-text" style="color: rgb(33, 37, 41); font-size: 16px">从图中可以看出，请求报头中使用了Accept, Accept-Encoding, Accept-Language, Cache-Control, Connection, Cookie等字段。Accept用于指定客户端用于接受哪些类型的信息，Accept-Encoding与Accept类似，它用于指定接受的编码方式。Connection设置为Keep-alive用于告诉客户端本次HTTP请求结束之后并不需要关闭TCP连接，这样可以使下次HTTP请求使用相同的TCP通道，节省TCP连接建立的时间。</span></p><h4 id="E8Sxo"><span class="ne-text" style="color: rgb(33, 37, 41)">请求正文</span></h4><p id="ufd1f0e54" class="ne-p"><span class="ne-text" style="color: rgb(33, 37, 41); font-size: 16px">当使用POST, PUT等方法时，通常需要客户端向服务器传递数据。这些数据就储存在请求正文中。在请求包头中有一些与请求正文相关的信息，例如: 现在的Web应用通常采用Rest架构，请求的数据格式一般为json。这时就需要设置Content-Type: application/json。</span></p><h3 id="DqH1p"><span class="ne-text">请求过程优化</span></h3><p id="uf0e4804e" class="ne-p"><span class="ne-text">减少HTTP请求次数和请求资源大小</span></p><ul class="ne-ul"><li id="u02134826"><span class="ne-text">资源合并压缩</span></li><li id="u886220e4"><span class="ne-text">字体图标（精灵图基本不是好的优化方式了，不好维护）</span></li><li id="u8b151eb8"><span class="ne-text">base64</span></li><li id="ua7b8b235"><span class="ne-text">Gzip（一般文件能压缩60%）</span></li><li id="u99c5abac"><span class="ne-text">图片懒加载</span></li><li id="uc970e0e4"><span class="ne-text">数据延迟分批加载</span></li><li id="ufd8dc50e"><span class="ne-text">CDN资源</span></li></ul><h2 id="onDoy"><span class="ne-text">五、服务端响应请求</span></h2><p id="u9add36bd" class="ne-p"><span class="ne-text">服务器端收到请求后由web服务器（准确说应该是http服务器）处理请求，诸如Apache、Ngnix、IIS等。web服务器解析用户请求，了解了要调度哪些资源文件，再通过响应的资源文件处理用户请求和参数，并调用数据库信息，最后将结果通过web服务器返回给浏览器客户端。</span></p><h4 id="LLf4p"><span class="ne-text">响应报文</span></h4><p id="u04a9f76d" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1653196402673-6ece40f2-645b-4af5-b395-a715c756cbfc.png" width="407" id="u5b68bb44" class="ne-image"></p><p id="ua856dee2" class="ne-p"><span class="ne-text" style="color: rgb(85, 85, 85); font-size: 14px">(1) 响应行包含：协议版本，状态码，状态码描述</span></p><p id="uab81c005" class="ne-p"><span class="ne-text" style="color: rgb(85, 85, 85); font-size: 14px">状态码规则如下：</span></p><ul class="ne-ul"><li id="u4c4449bb"><span class="ne-text" style="color: rgb(85, 85, 85); font-size: 14px">1xx：指示信息–表示请求已接收，继续处理。</span></li><li id="u852e2b6d"><span class="ne-text" style="color: rgb(85, 85, 85); font-size: 14px">2xx：成功–表示请求已被成功接收、理解、接受。</span></li><li id="u565492be"><span class="ne-text" style="color: rgb(85, 85, 85); font-size: 14px">3xx：重定向–要完成请求必须进行更进一步的操作。</span></li><li id="u953abe37"><span class="ne-text" style="color: rgb(85, 85, 85); font-size: 14px">4xx：客户端错误–请求有语法错误或请求无法实现。</span></li><li id="ua9b5aa59"><span class="ne-text" style="color: rgb(85, 85, 85); font-size: 14px">5xx：服务器端错误–服务器未能实现合法的请求。</span></li></ul><p id="uebc59aa3" class="ne-p"><span class="ne-text" style="color: rgb(85, 85, 85); font-size: 14px">(2) 响应头部包含响应报文的附加信息，由 名/值 对组成</span></p><p id="u40542035" class="ne-p"><span class="ne-text" style="color: rgb(85, 85, 85); font-size: 14px">(3) 响应主体包含回车符、换行符和响应返回数据，并不是所有响应报文都有响应数据</span></p><h2 id="NehWg"><span class="ne-text">六、断开连接</span></h2><p id="u9d963443" class="ne-p"><span class="ne-text">服务器响应完客户端请求之后，解除TCP连接，释放过程（四次挥手过程）如下：</span></p><p id="u5e730653" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/webp/1484158/1653194694500-6c0090b0-4c78-407c-83df-3355a71b80f2.webp" width="553" id="u85962d21" class="ne-image"></p><h3 id="jtmls"><span class="ne-text">四次挥手过程</span></h3><ul class="ne-ul"><li id="uc2d8a23c"><span class="ne-text">客户端发送标记为FIN=1（finished的缩写，表示接收完成，请求释放连接），同时生成一个Seq=u的序列号，之后进入FIN-WAIT-1半关闭阶段（此时客户端到服务端发送数据的通道已经关闭，但是仍然可以接收服务端发过来的数据）；</span></li><li id="u247f273a"><span class="ne-text">服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。</span></li><li id="ue1ad1b6a"><span class="ne-text">客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。</span></li><li id="u463cbbe2"><span class="ne-text">服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。</span></li><li id="u63903dcf"><span class="ne-text">客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。</span></li><li id="u05d367ba"><span class="ne-text">服务器只要收到了客户端发出的确认，立即进入CLOSED状态，就结束了这次的TCP连接。</span></li></ul><h3 id="PQWm7"><span class="ne-text">为什么是四次挥手？</span></h3><p id="u2d321eec" class="ne-p"><span class="ne-text">因为建立一旦连接，双方既是发送方，又是接收方，为了保证在最后断开的时候，客户端发送的最后一个ACK报文段能够被服务器接收到。如果客户端在收到服务器给它的断开连接的请求之后，回应完服务器就直接断开连接的话，服务器就会因为一直没得到客户端响应而一直等待，所以客户端要等待两个最长报文段寿命的时间，以便于服务器没有收到请求之后重新发送请求。</span></p><h2 id="PuVWe"><span class="ne-text">七、浏览器解析并渲染响应内容</span></h2><p id="u6b3bcdf2" class="ne-p"><span class="ne-text">在这之前我们先来补充一点基础知识：</span></p><h3 id="Y3sRj"><span class="ne-text">浏览器的渲染引擎组成（列举的是基本组成）</span></h3><ul class="ne-ul"><li id="u4f5545dd"><span class="ne-text">HTML解析器:将HTML解析成DOM树。</span></li><li id="udf4937dd"><span class="ne-text">CSS解析器: 为DOM中各个元素对象计算出样式信息，为布局提供基础设施。</span></li><li id="udf477ef9"><span class="ne-text">JavaScript引擎:解析并执行javascript代码。</span></li><li id="ue875f9b1"><span class="ne-text">布局layout模块:在DOM树创建后，webkit需要将其中的元素对象同样式信息结合起来，计算他们的大小位置等布局信息，形成一个能表达这所有信息的模型。 </span></li><li id="uc18ad7e3"><span class="ne-text">绘图模块:使用图形库将布局计算后的各个网页的节点绘制成图像的结果。</span></li></ul><h3 id="C9lpK"><span class="ne-text">渲染过程</span></h3><ol class="ne-ol"><li id="u6c4588f4"><span class="ne-text">浏览器拿到文件后（拿到的是一些字节码）通过编码方式（一般是utf-8）转换为对应的字符。</span></li><li id="ub2d2ec6f"><span class="ne-text">浏览器至上而下解析文档，遇见HTML标记，调用HTML解析器解析为对应的tocken，tocken就是标签文本的序列号，将tocken按词法解析解析成具体的标记结构，这个过程已经构建出一颗有标签，有层级，有结构的DOM树（就是一块内存，这块内存实际就是一个个Tocken构成的）；</span></li><li id="u639829da"><span class="ne-text">遇见style/link标记，调用CSS解析器处理CSS标记并构建CSSOM样式树；</span></li><li id="u07b96400"><span class="ne-text">遇见script标记，调用javascript解析器处理，绑定事件、修改DOM树/CSS树等；</span></li><li id="ue58b131b"><span class="ne-text">将DOM树和CSSOM树合并成一颗render树（渲染树）。</span></li><li id="u73abb46c"><span class="ne-text">根据渲染树来渲染，计算每个节点的几何信息（这一过程要依赖图形库）；</span></li><li id="ub992e54d"><span class="ne-text">将各个节点绘制到屏幕上。 如果用户操作页面，会触发第（6）或者第（7）步骤，也就是重排和重绘</span></li></ol><h3 id="n0mqK"><span class="ne-text">阻塞渲染</span></h3><p id="u2490e0f2" class="ne-p"><span class="ne-text">（1）style标签的样式：<br /></span></p><ul class="ne-ul"><li id="ub2f903aa"><span class="ne-text">由HTML解析器解析(异步解析）；</span></li><li id="u86069d2d"><span class="ne-text">不阻塞浏览器渲染（可能会出现闪屏（解析一点，显示一点现象）；</span></li><li id="u4b62c3fd"><span class="ne-text">不阻塞DOM解析。<br /><br /></span></li></ul><p id="ub27776db" class="ne-p"><span class="ne-text">（2）link引入的外部css样式（推荐使用）<br /></span></p><ul class="ne-ul"><li id="uc1f96d69"><span class="ne-text">由CSS解析器解析（同步解析）；</span></li><li id="u442b235d"><span class="ne-text">阻塞浏览器渲染（可以利用这种阻塞避免闪屏);</span></li><li id="u2fc09f64"><span class="ne-text">阻塞其后js语句的执行：<br /></span></li></ul><p id="u0ded7235" class="ne-p"><strong><span class="ne-text">原因</span></strong><span class="ne-text">：如果后面js的内容是获取元素的样式，例如宽高等属性,如果不等样式解析完毕，后面的js就获得了错误的信息,由于浏览器也不知道后续js的具体内容，所以只好等前面所有样式解析完毕，再执行js。例如：firefox在样式加载和解析过程，会禁止所有脚本。（webkit内核的浏览器只会在js尝试访问样式属性或者可能受到未加载的样式影响时才会禁止脚本。<br /></span></p><ul class="ne-ul"><li id="u98e3fdcf"><span class="ne-text">不阻塞DOM的解析：<br /></span></li></ul><p id="uf65ebb4c" class="ne-p"><strong><span class="ne-text">原因</span></strong><span class="ne-text">：DOM解析和CSS解析是两个并行的线程。<br /></span></p><p id="ub8e95fc3" class="ne-p"><span class="ne-text">（3）、优化核心概念：尽可能快的提高外部css加载速度。<br /></span></p><ul class="ne-ul"><li id="u9f885f50"><span class="ne-text">使用CDN节点进行外部资源打包；<br /></span></li><li id="u7ad07643"><span class="ne-text">对css进行压缩（利用打包工具，比如webpack，glup等；<br /></span></li><li id="u55539e7b"><span class="ne-text">减少对http请求数量，将多个css文件合并；<br /></span></li><li id="u0a4d8d88"><span class="ne-text">优化样式的代码。<br /></span></li></ul><p id="ue451fcf6" class="ne-p"><span class="ne-text">（4）js阻塞：<br /></span></p><ul class="ne-ul"><li id="u9b069c20"><span class="ne-text">阻塞DOM解析：<br /></span></li></ul><p id="u45b8cf6d" class="ne-p"><strong><span class="ne-text">原因</span></strong><span class="ne-text">：浏览器不知道后续脚本的内容，如果先去解析了下面的DOM，而随后js删除了后面的所有DOM，做了无用功。浏览器无法预估脚本具体做了什么操作，索性全部暂停，等脚本执行完，浏览器再继续向下解析。<br /></span></p><ul class="ne-ul"><li id="u5b8e0121"><span class="ne-text">阻塞页面的渲染：<br /></span></li></ul><p id="ufded32f2" class="ne-p"><strong><span class="ne-text">原因</span></strong><span class="ne-text">：js中也可以给DOM设置样式，浏览器同样等该脚本执行完再继续干活，避免做无用功。<br /></span></p><ul class="ne-ul"><li id="ufde261d3"><span class="ne-text">阻塞后续js的执行：<br /></span></li></ul><p id="ua9990fc1" class="ne-p"><strong><span class="ne-text">原因</span></strong><span class="ne-text">：维护依赖关系，例如：必须先引入jQuery再引入bootstrap。<br /></span></p><ul class="ne-ul"><li id="u817784ec"><span class="ne-text">如果script脚本加了defer：浏览器会发送请求加载js，但是不会阻塞DOM解析，等DOM解析完，再执行js。</span></li><li id="uc0787f7b"><span class="ne-text">如果script加了async：浏览器会发送请求加载js，不阻塞DOM解析，等js加载过来了，就先停止DOM解析，去执行js（谁先回来先执行谁），等js执行完，继续DOM解析。</span></li></ul><h3 id="V1IES"><span class="ne-text">渲染过程优化</span></h3><p id="u6ce002c5" class="ne-p"><span class="ne-text">（1）标签语义化（使用合适的标签，如果不是w3c规定的标签，Tocken令牌和词法解析语法得识别分析，是不是wc3规定的）<br /></span><span class="ne-text">（2）减少标签嵌套（生成结构树嵌套太多，就得递归（在DOM树构建时候快可以一点）<br /></span><span class="ne-text">（3）样式尽可能少的层级嵌套（使用与编译器的时候，层级嵌套要慎用。CSS选择器渲染从右到左，.box a{}会 比a{} 慢<br /></span><span class="ne-text">（4）尽早把CSS下载到客户端（充分利用HTTP多请求并发机制）<br /></span><span class="ne-text">（5）避免阻塞js放在底部<br /></span><span class="ne-text">（6）减少回流<br /></span></p><ul class="ne-ul"><li id="u97bf37ab"><span class="ne-text">放弃传统操作DOM时代，基于vue/react开始数据影响试图模式<br /></span></li><li id="u81ab9b58"><span class="ne-text">样式集中改变<br /></span></li><li id="u4559a3fe"><span class="ne-text">缓存布局信息，<br /></span></li><li id="u480222f8"><span class="ne-text">动画效果应用到position属性为absolute或fixed的元素上（脱离文档流）</span></li><li id="u371676b0"><span class="ne-text">CSS3硬件加速（比起考虑如何减少回流重绘，更期望不要回流重绘：transform、opacity、filters这些属性会触发硬件加速，不会引发回流重绘（过多使用占用大量内存，性能消耗严重<br /></span></li><li id="uefa5351d"><span class="ne-text">避免使用table布局和使用css的js表达式</span></li></ul><p id="u8b1b1567" class="ne-p"><span class="ne-text"></span></p></div>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
          <category> 前端性能优化 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[转]浏览器工作原理</title>
      <link href="/blog/vkgoaq/"/>
      <url>/blog/vkgoaq/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="uc476a18c" class="ne-p"><span class="ne-text">参考：</span></p><ul class="ne-ul"><li id="u94f3a8a8"><a href="https://www.yuque.com/handshell/kygzse" data-href="https://www.yuque.com/handshell/kygzse" target="_blank" class="ne-link"><span class="ne-text">https://www.yuque.com/handshell/kygzse</span></a></li></ul><p id="ue45fdca2" class="ne-p"><span class="ne-text"></span></p><h1 id="GNXt0"><span class="ne-text" style="color: rgb(51, 51, 51)">简介</span></h1><p id="u15ad5d23" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">网络浏览器很可能是使用最广的软件。在这篇入门文章中，我将会介绍它们的幕后工作原理。我们会了解到，从您在地址栏输入 google.com 直到您在浏览器屏幕上看到 Google 首页的整个过程中都发生了些什么。</span></p><h2 id="p8KMY"><span class="ne-text" style="color: rgb(51, 51, 51)">浏览器的主要功能</span></h2><p id="uc37e486b" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">浏览器的主要功能就是向服务器发出请求，在浏览器窗口中展示您选择的网络资源。这里所说的资源一般是指 HTML 文档，也可以是 PDF、图片或其他的类型。资源的位置由用户使用 URI（统一资源标示符）指定。</span></p><p id="u8834f380" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">浏览器解释并显示 HTML 文件的方式是在 HTML 和 CSS 规范中指定的。这些规范由网络标准化组织 W3C（万维网联盟）进行维护。</span></p><p id="uc3d5ef38" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">多年以来，各浏览器都没有完全遵从这些规范，同时还在开发自己独有的扩展程序，这给网络开发人员带来了严重的兼容性问题。如今，大多数的浏览器都是或多或少地遵从规范。</span></p><p id="u2cd4c280" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">浏览器的用户界面有很多彼此相同的元素，其中包括：</span></p><ul class="ne-ul"><li id="uc9ec74bf"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">用来输入 URI 的地址栏</span></li><li id="u1bb410a5"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">前进和后退按钮</span></li><li id="u6734b820"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">书签设置选项</span></li><li id="u00a223f7"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">用于刷新和停止加载当前文档的刷新和停止按钮</span></li><li id="u2e86b7d9"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">用于返回主页的主页按钮</span></li></ul><p id="ua33b564a" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">奇怪的是，浏览器的用户界面并没有任何正式的规范，这是多年来的最佳实践自然发展以及彼此之间相互模仿的结果。HTML5 也没有定义浏览器必须具有的用户界面元素，但列出了一些通用的元素，例如地址栏、状态栏和工具栏等。当然，各浏览器也可以有自己独特的功能，比如 Firefox 的下载管理器。</span></p><h2 id="J3Aw2"><span class="ne-text" style="color: rgb(51, 51, 51)">浏览器的高层结构</span></h2><p id="u14837635" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">浏览器的主要组件为</span></p><ol class="ne-ol"><li id="ue247f201"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">用户界面 - 包括地址栏、前进/后退按钮、书签菜单等。除了浏览器主窗口显示的您请求的页面外，其他显示的各个部分都属于用户界面。</span></li><li id="u9c5271b0"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">浏览器引擎 - 在用户界面和呈现引擎之间传送指令。</span></li><li id="u1c8351af"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">呈现引擎 - 负责显示请求的内容。如果请求的内容是 HTML，它就负责解析 HTML 和 CSS 内容，并将解析后的内容显示在屏幕上。</span></li><li id="u97a55487"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">网络 - 用于网络调用，比如 HTTP 请求。其接口与平台无关，并为所有平台提供底层实现。</span></li><li id="uc6227a35"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">用户界面后端 - 用于绘制基本的窗口小部件，比如组合框和窗口。其公开了与平台无关的通用接口，而在底层使用操作系统的用户界面方法。</span></li><li id="ub7edcbcf"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">JavaScript 解释器。用于解析和执行 JavaScript 代码。</span></li><li id="ufe548681"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">数据存储。这是持久层。浏览器需要在硬盘上保存各种数据，例如 Cookie。新的 HTML 规范 (HTML5) 定义了“网络数据库”，这是一个完整（但是轻便）的浏览器内数据库。</span></li></ol><p id="u60d23fd6" class="ne-p"><a href="https://blog.towavephone.com/static/2021-07-20-01-39-18-4d2efb6ba6e0c185fa557cbfdc53ca2c-28759.png" target="_blank" id="u221cabc3" class="ne-image-link" style="color: rgb(210, 54, 105); font-size: 16px"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1647955363695-c77ab531-56d2-4703-b760-10b2a357e13e.png" width="500" class="ne-image"></a></p><p id="udb1c4838" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">值得注意的是，和大多数浏览器不同，Chrome 浏览器的每个标签页都分别对应一个呈现引擎实例。每个标签页都是一个独立的进程。</span></p><h1 id="zlQIi"><span class="ne-text" style="color: rgb(51, 51, 51)">呈现引擎</span></h1><p id="u03c20d1f" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">呈现引擎的作用就是在浏览器的屏幕上显示请求的内容。</span></p><p id="u8b873811" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">默认情况下，呈现引擎可显示 HTML 和 XML 文档与图片。通过插件（或浏览器扩展程序），还可以显示其他类型的内容；例如，使用 PDF 查看器插件就能显示 PDF 文档。但是在本章中，我们将集中介绍其主要用途：显示使用 CSS 格式化的 HTML 内容和图片。</span></p><p id="u6833104e" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">本文所讨论的浏览器（Firefox、Chrome 浏览器和 Safari）是基于两种呈现引擎构建的。Firefox 使用的是 Gecko，这是 Mozilla 公司“自制”的呈现引擎。而 Safari 和 Chrome 浏览器使用的都是 WebKit。</span></p><p id="ud73dbeda" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">WebKit 是一种开放源代码呈现引擎，起初用于 Linux 平台，随后由 Apple 公司进行修改，从而支持苹果机和 Windows。</span></p><h2 id="nhQGa"><span class="ne-text" style="color: rgb(51, 51, 51)">主流程</span></h2><p id="u3fe8d72f" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">呈现引擎一开始会从网络层获取请求文档的内容，内容的大小一般限制在 8000 个块以内。</span></p><p id="u98e4588f" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">然后进行如下所示的基本流程：</span></p><p id="u0c26b84e" class="ne-p"><a href="https://blog.towavephone.com/static/2021-07-20-01-41-38-dba2da5da3c0b45fb5977e4418996051-81a6c.png" target="_blank" id="uaff40621" class="ne-image-link" style="color: rgb(210, 54, 105); font-size: 16px"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1647955363670-09c68a6a-43bf-4918-bcec-1b15f46e982d.png" width="600" class="ne-image"></a></p><p id="u9ef421fe" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">呈现引擎将开始解析 HTML 文档，并将各标记逐个转化成“内容树”上的 DOM 节点。同时也会解析外部 CSS 文件以及样式元素中的样式数据。HTML 中这些带有视觉指令的样式信息将用于创建另一个树结构：呈现树。</span></p><p id="ueb8436dd" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">呈现树包含多个带有视觉属性（如颜色和尺寸）的矩形。这些矩形的排列顺序就是它们将在屏幕上显示的顺序。</span></p><p id="u782d810b" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">呈现树构建完毕之后，进入“布局”处理阶段，也就是为每个节点分配一个应出现在屏幕上的确切坐标。下一个阶段是绘制 - 呈现引擎会遍历呈现树，由用户界面后端层将每个节点绘制出来。</span></p><p id="uc5bf0356" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">需要着重指出的是，这是一个渐进的过程。为达到更好的用户体验，呈现引擎会力求尽快将内容显示在屏幕上。它不必等到整个 HTML 文档解析完毕之后，就会开始构建呈现树和设置布局。在不断接收和处理来自网络的其余内容的同时，呈现引擎会将部分内容解析并显示出来。</span></p><h2 id="f1Vdv"><span class="ne-text" style="color: rgb(51, 51, 51)">主流程示例</span></h2><p id="u70693807" class="ne-p"><a href="https://blog.towavephone.com/static/2021-07-20-01-43-09-b2b81d9cf1c9a7547a05e02c3d96d537-37d31.png" target="_blank" id="u8697360d" class="ne-image-link" style="color: rgb(210, 54, 105); font-size: 16px"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1647955363669-1f06ef06-1aff-4c66-9d0c-8a80cc24a0d2.png" width="624" class="ne-image"></a></p><p id="u449dd883" class="ne-p"><a href="https://blog.towavephone.com/static/2021-07-20-01-43-20-b62fa3cb50eec54e4215a86e1ce83f85-37d31.png" target="_blank" id="u1c601d5c" class="ne-image-link" style="color: rgb(210, 54, 105); font-size: 16px"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1647955363715-948ad36b-e794-4de4-aabd-c2d6ffd71247.png" width="624" class="ne-image"></a></p><p id="u2198ee71" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">可以看出，虽然 WebKit 和 Gecko 使用的术语略有不同，但整体流程是基本相同的。</span></p><p id="u0f1e60f2" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">Gecko 将视觉格式化元素组成的树称为“框架树”。每个元素都是一个框架。WebKit 使用的术语是“呈现树”，它由“呈现对象”组成。对于元素的放置，WebKit 使用的术语是“布局”，而 Gecko 称之为“重排”。</span></p><p id="u529b6783" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">对于连接 DOM 节点和可视化信息从而创建呈现树的过程，WebKit 使用的术语是“附加”。有一个细微的非语义差别，就是 Gecko 在 HTML 与 DOM 树之间还有一个称为“内容槽”的层，用于生成 DOM 元素。我们会逐一论述流程中的每一部分：</span></p></div>]]></content>
      
      
      <categories>
          
          <category> 计算机素养 </category>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>水平/垂直居中总结</title>
      <link href="/blog/dubn5y/"/>
      <url>/blog/dubn5y/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h2 id="Q1iqa"><span class="ne-text">水平居中</span></h2><p id="u1757acd2" class="ne-p"><br></p><h2 id="SBJoD"><span class="ne-text">垂直居中</span></h2><ul class="ne-ul"><li id="u19dac5dd"><a href="https://juejin.cn/post/6844903550909153287" data-href="https://juejin.cn/post/6844903550909153287" class="ne-link"><span class="ne-text">CSS垂直居中的12种实现方式 - 掘金</span></a></li><li id="u9ef7efc0"><a href="https://blog.csdn.net/pan_junbiao/article/details/92804198" data-href="https://blog.csdn.net/pan_junbiao/article/details/92804198" class="ne-link"><span class="ne-text">CSS让DIV上下左右居中的方法_pan_junbiao的博客-CSDN博客</span></a></li></ul></div>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
          <category> HTML+CSS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CSS实现上下浮动动画</title>
      <link href="/blog/pu2dxs/"/>
      <url>/blog/pu2dxs/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="ue09c7540" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1648018096319-db408c92-c6e3-4678-b773-bf084efbdc41.png" width="546.015625" id="u0cee8aad" class="ne-image"></p><p id="u6119638d" class="ne-p"><span class="ne-text">lyrics项目里面自己设计首页需要当前视窗高度有一个箭头上下浮动的效果，按照如下方式实现：</span></p><pre><code>  .home-row-foward &#123;    animation: heart 0.5s ease-in-out 2.7s infinite alternate;    height: 30px;    font-size: 25px;    color: #1890ff;    text-align: center;    position: relative;    bottom: 25px;  &#125;  @keyframes heart &#123;    from &#123;      transform: translate(0, 0);    &#125;    to &#123;      transform: translate(0, 15px);    &#125;  &#125;</code></pre></div>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
          <category> HTML+CSS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>前端代码模块及其工具化（Webpack,roolup.js）构建</title>
      <link href="/blog/psazge/"/>
      <url>/blog/psazge/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="ucc55b2a2" class="ne-p"><span class="ne-text">前言：本文讲述前端代码模块化发展历程，再介绍构建工具对代码予以指定条件下的打包构建。</span></p><p id="ua273ed45" class="ne-p"><span class="ne-text"></span></p><h2 id="Mois5"><span class="ne-text">一、前端模块化历程</span></h2><p id="u5e631bc2" class="ne-p" style="text-align: center"><strong><span class="ne-text">无模块化（入口函数加载）→ AMD → CommonJS → UMD → ES Module</span></strong></p><p id="u3110707b" class="ne-p" style="text-align: center"><strong><span class="ne-text"></span></strong></p><ul class="ne-ul"><li id="ua2ef18af"><span class="ne-text">无模块化：通过入口函数即可加载</span></li><li id="uf30d1f53"><span class="ne-text">CommonJS：Node.js环境下的模块引入方式</span></li><li id="uf4d54197"><span class="ne-text">UMD：并不是一种全新的模块系统，而是整合了无模块化、AMD、CommonJS三种模块规范，其可以在任何环境下工作</span></li></ul><ul class="ne-ul"><li id="uac0b70f8"><span class="ne-text">ES Module：ECMAScript 2015引入的模块化规范，部分浏览器支持，不支持该特性的浏览器需要使用构建工具来提供支持</span></li></ul><h3 id="vxrce"><span class="ne-text">Commonjs</span></h3><h4 id="l5vSh"><span class="ne-text">nodejs不能使用es6的模块导入导出</span></h4><p id="u312d8bca" class="ne-p"><span class="ne-text">node.js 使用 commonjs 规范，es6 module 的推出和完善，node 从 v13开始原生支持 es6 module。</span></p><p id="u100f9b67" class="ne-p"><br></p><p id="ue9391cbd" class="ne-p"><span class="ne-text">在node环境下是不能使用es6语法中import export导入导出语法的，解决办法有babel转义，或者如下面的一种新方法（需要Node.js 版本 13.x.x 以上），个人推荐最好还是用babel配置babel配置文件在转义，因为可以自行一些配置。</span></p><ul class="ne-ul"><li id="u6443d0ea"><span class="ne-text">解决方案一：Node.js 版本 13.x.x 以上的版本，使用 </span><a href="https://nodejs.org/api/esm.html#esm_enabling" data-href="https://nodejs.org/api/esm.html#esm_enabling" target="_blank" class="ne-link"><span class="ne-text">官方推荐的方法</span></a><span class="ne-text"> 在 </span><code class="ne-code"><span class="ne-text">package.json</span></code><span class="ne-text"> 文件中设置 </span><code class="ne-code"><span class="ne-text">&quot;type&quot;: &quot;module&quot;</span></code><span class="ne-text">。</span></li></ul><pre><code>&#123;  &quot;type&quot;: &quot;module&quot;&#125;</code></pre><ul class="ne-ul"><li id="u319e4cb6"><span class="ne-text">解决方案二：使用 </span><a href="https://babeljs.io/" data-href="https://babeljs.io/" target="_blank" class="ne-link"><span class="ne-text">babeljs</span></a><span class="ne-text"> ，然后在项目中添加相关配置即可，具体可以查阅相关教程。</span></li></ul><h4 id="s89sl"><span class="ne-text">导入导出</span></h4><p id="u09c450b4" class="ne-p"><strong><span class="ne-text">导出</span></strong></p><div class="ne-quote"><p id="u04277304" class="ne-p"><span class="ne-text">【</span><span class="ne-text">第一种方式</span><span class="ne-text">】</span></p></div><ul class="ne-ul"><li id="u37472444"><span class="ne-text">就是在模块里面定义好变量/方法，然后利用 </span><code class="ne-code"><span class="ne-text">exports.let_1= let_1;</span></code><span class="ne-text"> </span><code class="ne-code"><span class="ne-text">exports.fun_1 = fun_1;</span></code><span class="ne-text">这种形式，一个个导出</span></li></ul><p id="udd99f2b8" class="ne-p"><br></p><p id="u821e17e2" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1618149585979-d1ff5498-d0e1-46ce-b115-ceeadf7f0df9.png" width="432.5" id="ViMAf" class="ne-image"></p><div class="ne-quote"><p id="u1786a9d8" class="ne-p"><span class="ne-text">【</span><span class="ne-text">第二种方式</span><span class="ne-text">】module.exports.version = version;</span></p></div><p id="uab94ef11" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1618149597438-9300a103-0fd7-42df-9307-06079ef423c0.png" width="422" id="NFJOH" class="ne-image"></p><p id="ub6ffc99d" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1618149609536-ea32c674-9e2d-48fb-92bc-d2c7bf0d294c.png" width="465.5" id="hnFZE" class="ne-image"></p><p id="udd681584" class="ne-p"><strong><span class="ne-text">导入</span></strong></p><p id="u1e5fcea0" class="ne-p"><span class="ne-text">const a = require('文件路径');</span></p><h4 id="tDrVM"><span class="ne-text">模块的查找规则</span></h4><p id="u18115508" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1618118075531-995293d3-ee92-4f22-a49c-cb5114639b20.png" width="432" id="i6QRC" class="ne-image"></p><p id="u86218b6c" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1618118082503-8414faae-297b-4cd7-a304-c80f7a635a35.png" width="384.5" id="J3M0F" class="ne-image"></p><h3 id="R2Rv5"><span class="ne-text">ES Module</span></h3><ul class="ne-ul"><li id="u6c153730"><a href="https://zhuanlan.zhihu.com/p/60374345" data-href="https://zhuanlan.zhihu.com/p/60374345" target="_blank" class="ne-link"><span class="ne-text">ES6专题—class与模块化（10）</span></a></li></ul><h4 id="ILTnS"><span class="ne-text">export</span></h4><pre><code>const checkStr = (str, type) =&gt; &#123;  // 等内容&#125;<p>module.exports = &#123;<br>  checkStr,<br>&#125;<br></code></pre></p><pre><code>export const updateInfo: any = (data: any) =&gt; &#123;  return fetch(&#123;    method: 'post',    url: `/*****************`,    data: data,  &#125;)&#125;</code></pre><h4 id="tBIUG"><span class="ne-text">import</span></h4><pre><code>import fetch from '../utils/fetch'</code></pre><h4 id="ytshL"><span class="ne-text">与class结合</span></h4><pre><code>class StorageFn &#123;  ls: Storage  ss: Storage  constructor() &#123;    this.ls = window.localStorage    this.ss = window.sessionStorage  &#125;  /*设置cookie*/  setCookie(name: any, value: any, day: any) &#123;&#125;  // 等内容&#125;<p>export default StorageFn<br></code></pre></p><h2 id="LCC3F"><span class="ne-text">二、模块化实现方式</span></h2><p id="u57e8119b" class="ne-p"><span class="ne-text">实现各种环境下都能使用模块化代码，需要使用打包工具来对一套代码进行打包，打包工具主流有：</span></p><ol class="ne-ol"><li id="ubd0fe9cd"><span class="ne-text">Webpack：适合应用类打包</span></li><li id="u098a1915"><span class="ne-text">roolup.js：适合工具类以及SDK打包</span></li></ol><p id="u5600a0ba" class="ne-p"><span class="ne-text"></span></p><p id="ubca969a8" class="ne-p"><span class="ne-text">打包目标：</span></p><ul class="ne-ul"><li id="uc96121f9"><span class="ne-text">编写ECMAScript 2015及其之后版本的新特性代码</span></li><li id="u5cf60fb6"><span class="ne-text">兼容各种浏览器和Node.js环境运行</span></li><li id="u1d7242df"><span class="ne-text">输出各类模块规范</span></li><li id="u4496a801"><span class="ne-text">可以按需加载</span></li></ul><h3 id="k633M"><span class="ne-text">roolup.js打包</span></h3><ul class="ne-ul"><li id="u34ab7d23"><span class="ne-text">sideEffects：实现按需加载</span></li></ul><pre><code>&#123;  ···  &quot;main&quot;: &quot;dist/index.js&quot;,  &quot;jsnext:main&quot;: &quot;dist/index.esm.js&quot;,  &quot;module&quot;: &quot;dist/index.esm.js&quot;,  &quot;sideEffects&quot;: false,  &quot;scripts&quot;: &#123;    &quot;build:self&quot;: &quot;rollup -c config/rollup.config.js&quot;,    &quot;build:esm&quot;: &quot;rollup -c config/rollup.config.esm.js&quot;,    &quot;build:aio&quot;: &quot;rollup -c config/rollup.config.aio.js&quot;,    &quot;build&quot;: &quot;npm run build:self &amp;&amp; npm run build:esm &amp;&amp; npm run build:aio&quot;,  &#125;,  &quot;devDependencies&quot;: &#123;    &quot;@babel/core&quot;: &quot;^7.1.2&quot;,    &quot;@babel/plugin-transform-runtime&quot;: &quot;^7.1.0&quot;,    &quot;@babel/preset-env&quot;: &quot;^7.1.0&quot;,    &quot;rollup&quot;: &quot;^0.57.1&quot;,    &quot;rollup-plugin-babel&quot;: &quot;^4.0.3&quot;,    &quot;rollup-plugin-commonjs&quot;: &quot;^8.3.0&quot;,    &quot;rollup-plugin-node-resolve&quot;: &quot;^3.0.3&quot;  &#125;,  &quot;dependencies&quot;: &#123;    &quot;@babel/runtime-corejs2&quot;: &quot;^7.12.5&quot;,    &quot;@babel/runtime-corejs3&quot;: &quot;^7.12.5&quot;,    &quot;core-js&quot;: &quot;^3.7.0&quot;  &#125;  ···&#125;<p></code></pre></p><ul class="ne-ul"><li id="ub50dbee3"><span class="ne-text">banner：打包后的公共头部注释</span></li><li id="u3f4dacac"><span class="ne-text">输入</span><code class="ne-code"><span class="ne-text">npx browserslist</span></code><span class="ne-text">可查看浏览器版本支持情况</span></li></ul><pre><code>var babel = require(&quot;rollup-plugin-babel&quot;);<p>var pkg = require(&quot;../package.json&quot;);</p><p>var version = pkg.version;</p><p>var banner = `/*!</p><ul><li>$&#123;pkg.name&#125; $&#123;version&#125;</li><li>Licensed under MIT</li><li>/<br>`;</li></ul><p>function getCompiler(opt) &#123;<br>  return babel(&#123;<br>    babelrc: false,<br>    presets: [<br>      [<br>        &quot;@babel/preset-env&quot;,<br>        &#123;<br>          targets: &#123;<br>            browsers:<br>              &quot;last 2 versions, &gt; 1%, ie &gt;= 8, Chrome &gt;= 45, safari &gt;= 10&quot;,<br>            node: &quot;0.12&quot;,<br>          &#125;,<br>          modules: false,<br>          loose: false,<br>        &#125;,<br>      ],<br>    ],<br>    plugins: [<br>      [<br>        &quot;@babel/plugin-transform-runtime&quot;,<br>        &#123;<br>          corejs: 2,<br>          helpers: false,<br>          regenerator: false,<br>        &#125;,<br>      ],<br>    ],<br>    runtimeHelpers: true,<br>    exclude: &quot;node_modules/**&quot;,<br>  &#125;);<br>&#125;</p><p>exports.name = &quot;clone&quot;;<br>exports.banner = banner;<br>exports.getCompiler = getCompiler;</p><p></code></pre></p><pre><code>// commonjsvar common = require(&quot;./rollup.js&quot;);module.exports = &#123;  input: &quot;src/index.js&quot;,  output: &#123;    file: &quot;dist/index.js&quot;,    format: &quot;cjs&quot;,    // When export and export default are not used at the same time, set legacy to true.    // legacy: true,    banner: common.banner,  &#125;,  plugins: [common.getCompiler()],&#125;;</code></pre><pre><code>// ES outputvar common = require(&quot;./rollup.js&quot;);module.exports = &#123;  input: &quot;src/index.js&quot;,  output: &#123;    file: &quot;dist/index.esm.js&quot;,    format: &quot;es&quot;,    // When export and export default are not used at the same time, set legacy to true.    // legacy: true,    banner: common.banner,  &#125;,  plugins: [common.getCompiler()],&#125;;</code></pre><ul class="ne-ul"><li id="uae60f3e1"><span class="ne-text">roolup打包CommonJS需要配合插件来执行</span></li></ul><pre><code>// umdvar nodeResolve = require(&quot;rollup-plugin-node-resolve&quot;);var commonjs = require(&quot;rollup-plugin-commonjs&quot;);<p>var common = require(&quot;./rollup.js&quot;);</p><p>module.exports = &#123;<br>  input: &quot;src/index.js&quot;,<br>  output: &#123;<br>    file: &quot;dist/index.aio.js&quot;,<br>    format: &quot;umd&quot;,<br>    // When export and export default are not used at the same time, set legacy to true.<br>    // legacy: true,<br>    name: common.name,<br>    banner: common.banner,<br>  &#125;,<br>  plugins: [<br>    nodeResolve(&#123;<br>      main: true,<br>      extensions: [&quot;.js&quot;],<br>    &#125;),<br>    commonjs(&#123;<br>      include: &quot;node_modules/**&quot;,<br>    &#125;),<br>    common.getCompiler(),<br>  ],<br>&#125;;</p><p></code></pre></p><h2 id="BDJQG"><span class="ne-text">三、参考</span></h2><p id="u75ca9f85" class="ne-p"><span class="ne-text">模块化理解</span></p><ul class="ne-ul"><li id="ua4a74059"><span class="ne-text">分析组件库以及构建产物：</span><a href="https://zhuanlan.zhihu.com/p/502956467" data-href="https://zhuanlan.zhihu.com/p/502956467" target="_blank" class="ne-link"><span class="ne-text">https://zhuanlan.zhihu.com/p/502956467</span></a></li><li id="ue3fab7be"><span class="ne-text">这一次，我要弄懂javascript的模块化 - 掘金：</span><a href="https://juejin.cn/post/6844903636108066830" data-href="https://juejin.cn/post/6844903636108066830" target="_blank" class="ne-link"><span class="ne-text">https://juejin.cn/post/6844903636108066830</span></a></li></ul><p id="ud41175ce" class="ne-p"><span class="ne-text">模块化打包</span></p><ul class="ne-ul"><li id="u5fb98569"><span class="ne-text">vite的项目，使用rollup打包的方法：</span><a href="https://juejin.cn/post/7036207262414667790" data-href="https://juejin.cn/post/7036207262414667790" target="_blank" class="ne-link"><span class="ne-text">https://juejin.cn/post/7036207262414667790</span></a></li><li id="u1c70db70"><a href="https://q.shanyue.tech/engineering/753.html#%E4%B8%80%E4%BA%9B%E5%A4%8D%E6%9D%82%E7%9A%84%E8%BD%AC%E5%8C%96" data-href="https://q.shanyue.tech/engineering/753.html#%E4%B8%80%E4%BA%9B%E5%A4%8D%E6%9D%82%E7%9A%84%E8%BD%AC%E5%8C%96" target="_blank" class="ne-link"><span class="ne-text">如何将 CommonJS 转化为 ESM | 前端工程化三十八讲 | 大厂面试题每日一题</span></a></li><li id="ua620a111"><a href="https://github.com/rollup/plugins/tree/master/packages/commonjs" data-href="https://github.com/rollup/plugins/tree/master/packages/commonjs" target="_blank" class="ne-link"><span class="ne-text">https://github.com/rollup/plugins/tree/master/packages/commonjs</span></a></li><li id="u8a89dc03"><a href="https://juejin.cn/post/6844904058394771470" data-href="https://juejin.cn/post/6844904058394771470" target="_blank" class="ne-link"><span class="ne-text">Rollup打包工具的使用（超详细，超基础，附代码截图超简单） - 掘金</span></a></li><li id="u1e26f222"><a href="https://juejin.cn/post/7145090564801691684" data-href="https://juejin.cn/post/7145090564801691684" target="_blank" class="ne-link"><span class="ne-text">【实战篇】最详细的Rollup打包项目教程 - 掘金</span></a></li><li id="u196fd378"><a href="https://juejin.cn/post/7137488289488961549" data-href="https://juejin.cn/post/7137488289488961549" target="_blank" class="ne-link"><span class="ne-text">rollup打包一个工具库并发布到npm - 掘金</span></a></li></ul><p id="u92ea30f6" class="ne-p"><span class="ne-text">ts的模块导入导出</span></p><ul class="ne-ul"><li id="u630258bc"><a href="https://blog.csdn.net/qq_43340929/article/details/107034432" data-href="https://blog.csdn.net/qq_43340929/article/details/107034432" target="_blank" class="ne-link"><span class="ne-text">TypeScript模块导入终极解决方案</span></a></li></ul><p id="u4846d97f" class="ne-p"><br></p></div>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
          <category> Node.js </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>696. 计数二进制子串🔖字符串</title>
      <link href="/blog/sueiwv/"/>
      <url>/blog/sueiwv/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="u62f590fc" class="ne-p"><span class="ne-text">题目链接：</span></p><ul class="ne-ul"><li id="u79899ad5"><a href="https://leetcode-cn.com/problems/count-binary-substrings/" data-href="https://leetcode-cn.com/problems/count-binary-substrings/" target="_blank" class="ne-link"><span class="ne-text">https://leetcode-cn.com/problems/count-binary-substrings/</span></a></li></ul><h3 id="gs1qv"><span class="ne-text">解决思路</span></h3><ul class="ne-ul"><li id="u80a880bd"><span class="ne-text">数学规律就是将字符串按照</span><strong><span class="ne-text">一整个0或1</span></strong><span class="ne-text">切割开来，将其放入数组arr，然后arr中相邻的元素（字符串）进行字符串长度比较大小，取小的，最后所有相邻的元素比较后的所有相加就是所需结果</span></li><li id="u86427819"><span class="ne-text">将字符串按照</span><strong><span class="ne-text">一整个0或1</span></strong><span class="ne-text">切割开来：先对字符串遍历，找到异元素，记录其下标，存为数组arr；然后利用splice方法＋arr数组进行切割为目标数组</span></li></ul><h3 id="KZHav"><span class="ne-text">代码实现</span></h3><p id="u1b748dff" class="ne-p"><span class="ne-text">将上述解决思路用代码实现如下：</span></p><pre><code>function countBinarySubstrings(s: string): number &#123;  let flag: string = s[0]  let arr: number[] = []  let arr_target: string[] = []  for (let i: number = 0; i &lt; s.length; i++) &#123;    if (s[i] !== flag) &#123;      arr.push(i)      flag = s[i]    &#125;  &#125;  arr.forEach((data: number, index: number) =&gt; &#123;    if (index === 0) &#123;      arr_target.push(String(s.slice(0, data)))      // 分割数组只有一个元素情况下      if (arr.length === 1) arr_target.push(String(s.slice(data, s.length)))    &#125; else if (index === arr.length - 1) &#123;      arr_target.push(String(s.slice(arr[index - 1], data)))      arr_target.push(String(s.slice(data, s.length)))    &#125; else &#123;      arr_target.push(String(s.slice(arr[index - 1], data)))    &#125;  &#125;)  let result: number = 0  arr_target.forEach((data: string, index: number) =&gt; &#123;    if (index &lt; arr_target.length - 1)      result += Math.min(        String(data).length,        String(arr_target[index + 1]).length      )  &#125;)  return result&#125;<p>console.log(countBinarySubstrings(‘1100’))</p><p></code></pre></p><ul class="ne-ul"><li id="u239fffbf"><strong><span class="ne-text" style="color: #E8323C">对上述逻辑的小优化</span></strong><span class="ne-text">：上面是利用arr还转换为原只含0、1的数组，但是可以利用arr直接进行求算结果</span></li></ul><pre><code>function countBinarySubstrings(s: string): number &#123;  let flag: string = s[0]  let arr: number[] = []  let result: number = 0  for (let i: number = 0; i &lt; s.length; i++) &#123;    if (s[i] !== flag) &#123;      arr.push(i)      flag = s[i]    &#125;  &#125;  arr.forEach((data: number, index: number) =&gt; &#123;    if (index === 0) &#123;      arr.length === 1        ? (result += Math.min(data, s.length - data))        : (result += Math.min(data, arr[index + 1] - data))    &#125; else if (index === arr.length - 1) &#123;      result += Math.min(data - arr[index - 1], s.length - data)    &#125; else &#123;      result += Math.min(arr[index + 1] - data, data - arr[index - 1])    &#125;  &#125;)  return result&#125;</code></pre><p id="u2dadfbee" class="ne-p"><span class="ne-text">最后优化效果如下</span></p><p id="ueb92bbd2" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1647944556161-5866cbd8-f97b-4fdc-9e84-9d3dc2ebc571.png" width="699.9999721845002" id="u40ceee23" class="ne-image"></p><h3 id="FNmDD"><span class="ne-text">优化方案</span></h3><p id="u6015cfa7" class="ne-p"><span class="ne-text">在官网解决方案中，看到其他的解决方案：</span></p><h4 id="bouKe"><span class="ne-text">利用正则表达式来切换原字符串</span></h4><pre><code>s.match(/([1]+)|([0]+)/g)</code></pre><p id="u3bc26102" class="ne-p"><span class="ne-text">上面的正则表达式就能实现如下效果…………</span></p><pre><code>[ '00', '11', '00', '11' ]</code></pre><p id="u581d3060" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/1484158/1647945287324-1f4f1d3f-6731-4794-a023-ba9ebb97397c.jpeg" width="75" id="BFxC7" class="ne-image"><span class="ne-text">正则表达式太重要了！！</span></p><p id="u3fa4a566" class="ne-p"><span class="ne-text">得到上述数组再进行数组内相邻元素比较元素字符串长度取小值，然后相加，类似上面方法即可。</span></p></div>]]></content>
      
      
      <categories>
          
          <category> 计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 📶线结构：字符串-数组-栈-队列 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ts使用及注意事项</title>
      <link href="/blog/xigb8k/"/>
      <url>/blog/xigb8k/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h2 id="Pexq9"><span class="ne-text">使用</span></h2><p id="udcfaf747" class="ne-p"><span class="ne-text">安装：</span><code class="ne-code"><span class="ne-text">npm install -g typescript</span></code></p><p id="ue89624dc" class="ne-p"><span class="ne-text">编译：</span><code class="ne-code"><span class="ne-text">tsc helloworld.ts</span></code></p><h3 id="fqI6Q"><span class="ne-text">报错：tsc : 无法加载文件···</span></h3><p id="udc41684a" class="ne-p"><span class="ne-text">如果报如下错：</span></p><pre><code>tsc : 无法加载文件 D:\Program Files\nodejs\tsc.ps1，因为在此系统上禁止运行脚本。有关详细信息，请参阅 https:/go.microsoft.com/fwlink</code></pre><ol class="ne-ol"><li id="u05bfe0c4"><span class="ne-text">管理员身份运行vs code</span></li><li id="uf085bbb7"><span class="ne-text">在终端执行：get-ExecutionPolicy，显示Restricted</span></li><li id="u6c8f7fe1"><span class="ne-text">在终端执行：set-ExecutionPolicy RemoteSigned</span></li><li id="u10b6b7b8"><span class="ne-text">在终端执行：get-ExecutionPolicy，显示RemoteSigned</span></li></ol><h2 id="Iz9Bb"><span class="ne-text" style="color: rgb(37, 41, 51)">nodemon运行ts文件</span></h2><ul class="ne-ul"><li id="u1144f406"><span class="ne-text">参考：</span><a href="https://juejin.cn/post/7035637086451400734" data-href="https://juejin.cn/post/7035637086451400734" target="_blank" class="ne-link"><span class="ne-text">https://juejin.cn/post/7035637086451400734</span></a></li></ul><h3 id="A9CTY"><span class="ne-text">tsconfig.json</span></h3><h2 id="imsep"><span class="ne-text">ts遍历对象</span></h2><p id="udbfd75c6" class="ne-p"><span class="ne-text">ts遍历对象不要使用</span><code class="ne-code"><span class="ne-text">for···in</span></code><span class="ne-text">，使用</span><code class="ne-code"><span class="ne-text">for···of</span></code></p><ul class="ne-ul"><li id="u33f536a9"><span class="ne-text">理由：</span><a href="https://stackoverflow.com/questions/65300784/declare-key-type-of-for-in-loop-in-typescript" data-href="https://stackoverflow.com/questions/65300784/declare-key-type-of-for-in-loop-in-typescript" target="_blank" class="ne-link"><span class="ne-text">https://stackoverflow.com/questions/65300784/declare-key-type-of-for-in-loop-in-typescript</span></a></li><li id="u6f5fa005"><span class="ne-text">遍历的其他方式参考：</span><a href="https://juejin.cn/post/6844904147146260488" data-href="https://juejin.cn/post/6844904147146260488" target="_blank" class="ne-link"><span class="ne-text">TypeScript小状况之遍历对象属性</span></a></li></ul><pre><code>const disabled = computed(() =&gt; &#123;  let flag = true  for (const [key, val] of Object.entries(formState)) &#123;    if (!val) &#123;      flag = true      break    &#125; else &#123;      flag = false    &#125;  &#125;  return flag&#125;)</code></pre><p id="u22d9647f" class="ne-p"><br></p><h2 id="OlnAT"><span class="ne-text">参考</span></h2><p id="u8eb1d75d" class="ne-p"><span class="ne-text">学习网站：</span></p><ul class="ne-ul"><li id="u071afcc4"><a href="https://www.tslang.cn/docs/home.html" data-href="https://www.tslang.cn/docs/home.html" class="ne-link"><span class="ne-text">文档简介 · TypeScript中文网 · TypeScript——JavaScript的超集</span></a></li><li id="u82f8a6d4"><a href="https://ts.xcatliu.com/introduction/what-is-typescript.html" data-href="https://ts.xcatliu.com/introduction/what-is-typescript.html" class="ne-link"><span class="ne-text">什么是 TypeScript · TypeScript 入门教程</span></a></li><li id="uf6abac79"><a href="https://segmentfault.com/a/1190000038959316" data-href="https://segmentfault.com/a/1190000038959316" class="ne-link"><span class="ne-text">推荐 7 个学习 TypeScript 的宝库，2021 学 TS 看这篇就够了！</span></a></li><li id="ue15f5395"><a href="https://juejin.cn/post/7018805943710253086" data-href="https://juejin.cn/post/7018805943710253086" class="ne-link"><span class="ne-text">2021 typescript史上最强学习入门文章(2w字) - 掘金</span></a></li></ul><p id="u36c62ed2" class="ne-p"><span class="ne-text">相关教程：</span></p><ul class="ne-ul"><li id="u23aa8793"><a href="https://www.cnblogs.com/wisewrong/p/13717287.html" data-href="https://www.cnblogs.com/wisewrong/p/13717287.html" target="_blank" class="ne-link"><span class="ne-text">Vue3.x 从零开始（一）—— Vue-cli or Vite 构建 TypeScript 项目</span></a></li><li id="u0a06663a"><a href="https://segmentfault.com/a/1190000019661168" data-href="https://segmentfault.com/a/1190000019661168" target="_blank" class="ne-link"><span class="ne-text">在Typescript项目中，如何优雅的使用ESLint和Prettier</span></a></li><li id="u23f477e7"><a href="https://segmentfault.com/a/1190000022809326" data-href="https://segmentfault.com/a/1190000022809326" target="_blank" class="ne-link"><span class="ne-text">了不起的 tsconfig.json 指南</span></a></li><li id="uce2288cc"><a href="https://cn.eslint.org/" data-href="https://cn.eslint.org/" target="_blank" class="ne-link"><span class="ne-text">官网：ESLint 可组装的JavaScript和JSX检查工具</span></a></li><li id="uaa4c7979"><a href="https://www.jianshu.com/p/ad1e46faaea2" data-href="https://www.jianshu.com/p/ad1e46faaea2" target="_blank" class="ne-link"><span class="ne-text">Eslint 超简单入门教程</span></a></li><li id="uf1a741f9"><a href="https://segmentfault.com/a/1190000020168436" data-href="https://segmentfault.com/a/1190000020168436" target="_blank" class="ne-link"><span class="ne-text">在Vue项目中使用Eslint+Prettier+Stylelint</span></a></li><li id="u408aada3"><a href="https://segmentfault.com/a/1190000019905650" data-href="https://segmentfault.com/a/1190000019905650" target="_blank" class="ne-link"><span class="ne-text">使用Vue-cli3搭建Vue+TypeScript项目</span></a></li><li id="u9f3ba0b3"><a href="https://www.cnblogs.com/suwanbin/p/13583717.html" data-href="https://www.cnblogs.com/suwanbin/p/13583717.html" target="_blank" class="ne-link"><span class="ne-text">prettier - vscode 保存代码自动格式化插件安装与配置项备注</span></a></li></ul></div>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
          <category> JavaScript </category>
          
          <category> TypeScript </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Express框架及其使用</title>
      <link href="/blog/tdgoby/"/>
      <url>/blog/tdgoby/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h2 id="SZZM1"><span class="ne-text">express框架</span></h2><p id="u3d4ac39a" class="ne-p"><span class="ne-text">express框架相当于再http模块加上一个中间件合集。</span><strong><span class="ne-text">中间件</span></strong><span class="ne-text">的含义就相当于处理http请求的处理函数，而express相当于调用多个中间件，这么一个框架。</span></p><p id="u8f6b3063" class="ne-p"><br></p><p id="uda9de047" class="ne-p"><span class="ne-text">参考：</span></p><ul class="ne-ul"><li id="u84242c89"><a href="https://javascript.ruanyifeng.com/nodejs/express.html" data-href="https://javascript.ruanyifeng.com/nodejs/express.html" target="_blank" class="ne-link"><span class="ne-text">Express框架 来自《JavaScript 标准参考教程（alpha）》，by 阮一峰</span></a></li><li id="u29e2fce3"><a href="https://juejin.cn/post/6844904023380721678" data-href="https://juejin.cn/post/6844904023380721678" target="_blank" class="ne-link"><span class="ne-text">一杯茶的时间，上手 Express 框架开发</span></a></li></ul><p id="u3f1842ae" class="ne-p"><span class="ne-text"></span></p><p id="u39af97d3" class="ne-p"><span class="ne-text">相关文档：</span></p><ul class="ne-ul"><li id="u74927218"><a href="http://expressjs.jser.us/" data-href="http://expressjs.jser.us/" target="_blank" class="ne-link"><span class="ne-text">http://expressjs.jser.us/</span></a></li></ul><p id="u85187766" class="ne-p"><span class="ne-text"></span></p><p id="u79d28551" class="ne-p"><span class="ne-text">项目下载使用：</span></p><pre><code>cnpm install express --save</code></pre><h3 id="bvAQ0"><span class="ne-text">express路由结构化</span></h3><p id="u57d10c9d" class="ne-p"><a href="https://expressjs.com/zh-cn/guide/routing.html" data-href="https://expressjs.com/zh-cn/guide/routing.html" target="_blank" class="ne-link"><span class="ne-text">https://expressjs.com/zh-cn/guide/routing.html</span></a></p><h3 id="aGSGq"><span class="ne-text">express里http.createServer</span></h3><pre><code>const app = express()<p>app.use(bodyParser.json(&#123; limit: ‘10mb’ &#125;))<br>app.use(<br>  bodyParser.urlencoded(&#123;<br>    extended: false,<br>  &#125;)<br>)<br>const server = http.createServer(app)<br></code></pre></p><p id="uff13f501" class="ne-p"><span class="ne-text">第9行代码这样写好处有：</span></p><p id="u10abaaf7" class="ne-p"><span class="ne-text">用http封装不但可以使用express的属性和方法，而且还可以使用http的属性和方法</span></p><p id="u2c79cc69" class="ne-p"><span class="ne-text">具体可以参考这段讨论：</span><a href="https://cnodejs.org/topic/5396cd60c3ee0b5820f00e2a" data-href="https://cnodejs.org/topic/5396cd60c3ee0b5820f00e2a" target="_blank" class="ne-link"><span class="ne-text">express里http.createServer和app.listen有什么区别？</span></a></p><h3 id="maJie"><span class="ne-text">express 常用API</span></h3><h4 id="PFv2f"><span class="ne-text">use方法和中间件</span></h4><ul class="ne-ul"><li id="u3d50a3b4"><span class="ne-text">注册中间件，返回的是函数。注意第三个参数next，如果写</span><code class="ne-code"><span class="ne-text">next()</span></code><span class="ne-text">语句则执行完该中间件，前往下一个中间件执行下一个中间件，如果不写，则执行完该中间件，就停止运行中间件。</span></li><li id="u8f2e76c8"><span class="ne-text">中间件，如果注册了路由，则只显示路由内容，所以使用的时候，中间件的url不应该是具体路由，而是一层路由，其他的二层路由则是具体内容路由。</span></li></ul><pre><code>let express = require('express')let app = express()<p>// 路由<br>app.get(‘/‘, function (req, res) &#123;<br>  res.send(‘Hello world’)<br>&#125;)<br>app.get(‘/customer’, function (req, res) &#123;<br>  res.send(‘customer page’)<br>&#125;)<br>// app.get(‘/admin’, function (req, res) &#123;<br>//   console.log(‘—————————-‘)<br>//   res.send(‘admin page’)<br>// &#125;)</p><p>// 中间件<br>// 如果注册了路由，则只显示路由内容<br>app.use(‘/admin’, function (request, response, next) &#123;<br>  response.writeHead(200, &#123; ‘Content-Type’: ‘text/plain’ &#125;)<br>  response.end(‘Welcome to the admin page!\n’)<br>&#125;)</p><p>app.listen(3000)<br>console.log(‘to <a href="http://localhost:3000/&#39;">http://localhost:3000/&#39;</a>)<br></code></pre></p><h4 id="yJMJU"><span class="ne-text">get方法</span></h4><ul class="ne-ul"><li id="uc076919a"><span class="ne-text">注册路由，用于指定不同的访问路径所对应的回调函数。由于get方法没有next回调函数，所以按照执行顺序，当地一个get方法执行了（根据匹配成功参数路径），后续的都不会执行了</span></li></ul><div class="ne-quote"><p id="ue5d6d127" class="ne-p"><span class="ne-text">put()post()put()del()类似get()使用（delete是JavaScript保留字，所以改叫del）</span></p></div><p id="uc807da1e" class="ne-p"><span class="ne-text">对于第一个参数，也就是路径参数，有不同的匹配规则</span></p><pre><code>app.get('/customer/:who', function (req, res) &#123;  res.send('都能访问 /' + req.params.who + ' 该路径')&#125;)</code></pre><p id="udeb39565" class="ne-p"><span class="ne-text">访问 </span><a href="http://localhost:3000/customer/fa" data-href="http://localhost:3000/customer/fa" target="_blank" class="ne-link"><span class="ne-text">http://localhost:3000/customer/fa</span></a><span class="ne-text"> 返回 </span><code class="ne-code"><span class="ne-text">都能访问 /fa 该路径</span></code></p><p id="u5886c758" class="ne-p"><span class="ne-text">访问</span><a href="http://localhost:3000/customer/ad" data-href="http://localhost:3000/customer/ad" target="_blank" class="ne-link"><span class="ne-text">http://localhost:3000/customer/ad</span></a><span class="ne-text"> 返回 </span><code class="ne-code"><span class="ne-text">都能访问 /ad 该路径</span></code></p><p id="ud73bb228" class="ne-p"><span class="ne-text">不能访问</span><a href="http://localhost:3000/customer" data-href="http://localhost:3000/customer" target="_blank" class="ne-link"><span class="ne-text">http://localhost:3000/customer</span></a></p><p id="u8257ffd5" class="ne-p"><span class="ne-text">如果是:who? 则成为可选路径</span></p><h4 id="GoJ2E"><span class="ne-text">set方法</span></h4><ul class="ne-ul"><li id="ube09ff24"><span class="ne-text">指定变量的值</span></li></ul><pre><code>// 告诉express框架模板的位置app.set('views', path.join(__dirname, 'views'))// 告诉express框架模板的默认后缀是什么app.set('view engine', 'art');</code></pre><h4 id="tCcvQ"><span class="ne-text">response对象</span></h4><p id="uc267f8b7" class="ne-p"><span class="ne-text">response.redirect方法允许网址的重定向。</span></p><p id="uf70b4e36" class="ne-p"><span class="ne-text">response.sendFile方法用于发送文件。</span></p><p id="u2bffa3d7" class="ne-p"><span class="ne-text">response.render方法用于渲染网页模板。</span></p><h4 id="YSrGP"><span class="ne-text">request对象</span></h4><h4 id="KIPOO"><span class="ne-text">搭建HTTPS环境</span></h4><p id="udbceda63" class="ne-p"><span class="ne-text">上传crt和key文件</span></p><pre><code>var fs = require('fs');var options = &#123;  key: fs.readFileSync('E:/ssl/myserver.key'),  cert: fs.readFileSync('E:/ssl/myserver.crt'),  passphrase: '1234'&#125;;<p>var https = require(‘https’);<br>var express = require(‘express’);<br>var app = express();</p><p>app.get(‘/‘, function(req, res)&#123;<br>  res.send(‘Hello World Expressjs’);<br>&#125;);</p><p>var server = https.createServer(options, app);<br>server.listen(8084);<br>console.log(‘Server is running on port 8084’);<br></code></pre></p><h3 id="JlltX"><span class="ne-text">express写API接口</span></h3><h4 id="NEOTJ"><span class="ne-text">References</span></h4><ul class="ne-ul"><li id="u95bf99da"><a href="https://blog.csdn.net/m0_48375854/article/details/122447235" data-href="https://blog.csdn.net/m0_48375854/article/details/122447235" target="_blank" class="ne-link"><span class="ne-text">Node.js---使用Express写接口</span></a></li></ul><h4 id="ZRE1G"><span class="ne-text">response对象json方法写接口</span></h4><p id="u7bd04614" class="ne-p"><span class="ne-text">内置json响应的方式：</span></p><pre><code>/* * @Author: wztlink1013 * @Date: 2022-01-11 11:04:38 * @LastEditTime: 2022-01-11 11:21:17 * @Description: */let obj = &#123;  1: &#123;    id: 1234,    name: '张三',    college: '计算机科学与工程学院',    grade: 2018,    classes: 2,    age: 21,  &#125;,  2: &#123;    id: 5678,    name: '李四',    college: '计算机科学与工程学院',    grade: 2018,    classes: 2,    age: 21,  &#125;,&#125;<p>exports.index = function (req, res) &#123;<br>  res.status(200).json(obj)<br>&#125;<br></code></pre></p><pre><code>// 接口的使用let userinfo = require('./api/userinfo.js')app.get('/api/userinfo', userinfo.index)</code></pre><h4 id="zzaxG"><span class="ne-text">js使用接口的一些方法</span></h4><ul class="ne-ul"><li id="u43b7106d"><span class="ne-text">用之前总结的使用接口一些方法：</span><a href="https://github.com/wztlink1013/web-learn-notes/tree/gh-pages/learn-interface" data-href="https://github.com/wztlink1013/web-learn-notes/tree/gh-pages/learn-interface" target="_blank" class="ne-link"><span class="ne-text">https://github.com/wztlink1013/web-learn-notes/tree/gh-pages/learn-interface</span></a></li></ul><h4 id="mwKb2"><span class="ne-text">跨域问题的解决</span></h4><p id="uf6998da1" class="ne-p"><span class="ne-text">解法一：手写（但是有看到网上说会有设备（iPhone6）不兼容等问题）</span></p><pre><code>// 跨域设置app.all(&quot;*&quot;, function(req, res, next) &#123;    res.header(&quot;Access-Control-Allow-Credentials&quot;, true);    res.header(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;);    res.header(&quot;Access-Control-Allow-Headers&quot;, &quot;X-Requested-With&quot;);    res.header(&quot;Access-Control-Allow-Methods&quot;, &quot;PUT,POST,GET,DELETE,OPTIONS&quot;);    res.header(&quot;Content-Type&quot;, &quot;application/json;charset=utf-8&quot;);    next();&#125;);</code></pre><p id="u3807f4e8" class="ne-p"><span class="ne-text">解法二：直接使用npm里面的cors包</span></p><pre><code>&lt;!-- * @Descripttion: learn axios * @Date: 2021-12-21 09:40:36 * @LastEditTime: 2022-01-11 11:25:28--&gt;&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;  &lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot; /&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;    &lt;title&gt;Document&lt;/title&gt;    &lt;script src=&quot;https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js&quot;&gt;&lt;/script&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;script&gt;      // 配置公共的请求头      axios.defaults.baseURL = 'http://localhost:3000/'      // 配置 超时时间      axios.defaults.timeout = 2500      // 配置公共的请求头      // axios.defaults.headers.common[&quot;Authorization&quot;] =      //   &quot;token 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&quot;      // axios.defaults.headers.common[&quot;Accept&quot;] = &quot;application/vnd.github.v3+json&quot;      // 配置公共的 post 的 Content-Type      axios.defaults.headers.post['Content-Type'] = 'application/json'<pre><code>  // 请求/响应 拦截器的配置  axios.interceptors.request.use(    config =&amp;gt; &#123;      console.log(&#39;请求拦截器: &#39;)      config.headers.Accept = &#39;application/vnd.github.v3+json&#39;      config.headers.Authorization =        &#39;token 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&#39;      console.log(config)      return config    &#125;,    err =&amp;gt; &#123;      console.log(err)    &#125;  )  axios.interceptors.response.use(    data =&amp;gt; &#123;      console.log(&#39;响应拦截器: &#39;)      console.log(data.data)      return data.data    &#125;,    err =&amp;gt; &#123;      console.log(err)    &#125;  )  // 请求数据  axios.get(&#39;api/userinfo&#39;).then(data =&amp;gt; &#123;    console.log(data)  &#125;)&amp;lt;/script&amp;gt;</code></pre><p>  &lt;/body&gt;<br>&lt;/html&gt;</p><p></code></pre></p><p id="ub187bf50" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1641872349891-229b5dc9-c17f-4a3b-bbef-98611971015f.png" width="569.5" id="g5VY5" class="ne-image"></p><h4 id="RIBJU"><span class="ne-text">Postman 测试API工具</span></h4><p id="u76413f3c" class="ne-p"><span class="ne-text">如果是本地写的接口，也就是localhost类的，在web postman上是不能测试的，只能下载Postman PC应用来测试。</span></p><h3 id="HdYAo"><span class="ne-text">body-parser模块</span></h3><p id="u3898d1c9" class="ne-p"><span class="ne-text">body-parser为express框架的中间件，其作用就是对post请求的请求体进行解析。</span></p><p id="u0ca951ed" class="ne-p"><span class="ne-text">下载使用：</span></p><pre><code>cnpm install body-parser</code></pre><h4 id="JrfFg"><span class="ne-text">bodyParser.json( )与bodyParser.urlencoded( )</span></h4><ul class="ne-ul"><li id="u374ee14f"><span class="ne-text">limit参数（json）：控制请求体最大尺寸</span></li><li id="u160b544d"><span class="ne-text">extended参数（urlencoded）：</span></li></ul><p id="ub4779aaa" class="ne-p"><code class="ne-code"><span class="ne-text">extended: false</span></code><span class="ne-text">：表示使用系统模块querystring来处理，也是官方推荐的</span></p><p id="ub7c93c26" class="ne-p"><code class="ne-code"><span class="ne-text">extended: true</span></code><span class="ne-text">：表示使用第三方模块qs来处理</span></p><p id="u6b87a5c0" class="ne-p"><span class="ne-text">从功能性来讲，qs比querystring要更强大，所以这里可以根据项目的实际需求来考虑</span></p><p id="ub39513a2" class="ne-p"><span class="ne-text">详见：</span><a href="https://github.com/expressjs/body-parser/#extended" data-href="https://github.com/expressjs/body-parser/#extended" target="_blank" class="ne-link"><span class="ne-text">https://github.com/expressjs/body-parser/#extended</span></a></p><h4 id="RAcgG"><span class="ne-text">References</span></h4><ul class="ne-ul"><li id="u024103cd"><span class="ne-text"></span><a href="https://github.com/expressjs/body-parser/" data-href="https://github.com/expressjs/body-parser/" target="_blank" class="ne-link"><span class="ne-text">https://github.com/expressjs/body-parser/</span></a></li><li id="u4c67161c"><a href="https://www.cnblogs.com/chyingp/p/nodejs-learning-express-body-parser.html" data-href="https://www.cnblogs.com/chyingp/p/nodejs-learning-express-body-parser.html" target="_blank" class="ne-link"><span class="ne-text">Nodejs 进阶：Express 常用中间件 body-parser 实现解析 </span></a></li><li id="ue3e4885a"><a href="https://segmentfault.com/a/1190000004407008" data-href="https://segmentfault.com/a/1190000004407008" target="_blank" class="ne-link"><span class="ne-text">bodyParser中间件的研究</span></a></li></ul><h3 id="H76rt"><span class="ne-text">express-session模块</span></h3><p id="e5a83eec75d9703913b34f5a57c6c0e2" class="ne-p"><span class="ne-text">设置Cookie，</span><code class="ne-code"><span class="ne-text">app.use(session(&#123;secret: 'secret key'&#125;));</span></code></p><p id="668b82e8367ae7ff8268aa4fba2d1143" class="ne-p"><span class="ne-text">当参数为secret时候，通过设置的secret字符串，来计算hash值并放在cookie中，使产生的signedCookie防篡改</span></p><p id="96273afa9f3a7693cd6a47e0ad7ac5ae" class="ne-p"><br></p><p id="ec1e13fd45edd3c0f24876ef7e7914d6" class="ne-p"><span class="ne-text">还有其他的参数：</span></p><ul class="ne-ul"><li id="a790486bd5a810616c3cf007ec2ac6aa"><span class="ne-text">name: 设置cookie中，保存session的字段名称，默认为connect.sid</span></li><li id="872441e9f2d437c3d2c811e72cc7e213"><span class="ne-text">store: session的存储方式，默认为存放在内存中，我们可以自定义redis等</span></li><li id="a7b14914a20f582ee51f69406a07fd35"><span class="ne-text">genid: 生成一个新的session_id时，默认为使用uid2这个npm包</span></li><li id="b25a9619e55805dadbef4599663a29d3"><span class="ne-text">rolling: 每个请求都重新设置一个cookie，默认为false</span></li><li id="1fa877bdbea80baa1648088af27de7bf"><span class="ne-text">resave: 即使session没有被修改，也保存session值，默认为true</span></li><li id="bca8d2e03acc9f1b4960caaf7bb67ed4"><span class="ne-text">saveUninitialized：强制未初始化的session保存到数据库</span></li><li id="92596e74df5537944f8fc2acb7e8c36c"><span class="ne-text">secret: 通过设置的secret字符串，来计算hash值并放在cookie中，使产生的signedCookie防篡改</span></li><li id="d35772ab8f12660bf32fe38e9ad0d7e7"><span class="ne-text">cookie : 设置存放sessionid的cookie的相关选项</span></li></ul></div>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
          <category> Node.js </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>mongoose操作MongoDB数据库</title>
      <link href="/blog/xfn7hy/"/>
      <url>/blog/xfn7hy/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><ul class="ne-ul"><li id="ud43c3a98"><span class="ne-text">GitHub：</span><a href="https://github.com/Automattic/mongoose" data-href="https://github.com/Automattic/mongoose" target="_blank" class="ne-link"><span class="ne-text">https://github.com/Automattic/mongoose</span></a></li><li id="ud396ccb4"><span class="ne-text">英文文档：</span><a href="https://mongoosejs.com/docs/guide.html" data-href="https://mongoosejs.com/docs/guide.html" target="_blank" class="ne-link"><span class="ne-text">https://mongoosejs.com/docs/guide.html</span></a></li><li id="ucd4684f0"><span class="ne-text">中文文档：</span><a href="http://www.mongoosejs.net/docs/guide.html" data-href="http://www.mongoosejs.net/docs/guide.html" target="_blank" class="ne-link"><span class="ne-text">http://www.mongoosejs.net/docs/guide.html</span></a></li><li id="uea71dde7"><a href="https://zhuanlan.zhihu.com/p/56030432" data-href="https://zhuanlan.zhihu.com/p/56030432" target="_blank" class="ne-link"><span class="ne-text">如何使用nodejs写一个接口 - MySQL版</span></a></li></ul><p id="ue53bab1a" class="ne-p"><span class="ne-text"></span></p><p id="u2a1cce22" class="ne-p"><span class="ne-text">shardb-mongodb模块操作数据库不好去使用，比如查询，新建等，所以这个模块只用作ot服务那边；</span></p><p id="ue31486e0" class="ne-p"><span class="ne-text">另外使用mongoose去操作数据库方便写接口</span></p><ul class="ne-ul"><li id="ud603d93e"><a href="https://github.com/share/sharedb-mongo" data-href="https://github.com/share/sharedb-mongo" target="_blank" class="ne-link"><span class="ne-text">https://github.com/share/sharedb-mongo</span></a></li><li id="u387c569c"><a href="https://www.jianshu.com/p/46f06896c9cd" data-href="https://www.jianshu.com/p/46f06896c9cd" target="_blank" class="ne-link"><span class="ne-text">Mongoose 查询结果为空</span></a></li></ul><p id="u59f5e9b2" class="ne-p"><span class="ne-text">schema的相关配置为connection</span></p><ul class="ne-ul"><li id="uc952063f"><span class="ne-text">之前的增删改查笔记：</span><a href="https://github.com/wztlink1013/web-learn-notes/blob/gh-pages/learn-nodejs/express/model/connect.js" data-href="https://github.com/wztlink1013/web-learn-notes/blob/gh-pages/learn-nodejs/express/model/connect.js" target="_blank" class="ne-link"><span class="ne-text">https://github.com/wztlink1013/web-learn-notes/blob/gh-pages/learn-nodejs/express/model/connect.js</span></a></li><li id="u8ee35e52"><a href="https://segmentfault.com/a/1190000019201081" data-href="https://segmentfault.com/a/1190000019201081" target="_blank" class="ne-link"><span class="ne-text">mongoose踩坑笔记： Cannot overwrite `` model once compiled.</span></a></li></ul><h2 id="UocgJ"><span class="ne-text">安装</span></h2><h3 id="VZPAG"><span class="ne-text">MongoDB以及可视化工具Navicat</span></h3><p id="u9f7c554d" class="ne-p"><span class="ne-text">参考之前写的文章：</span><a href="https://www.yuque.com/wztlink1013/blog/nwt63v" data-href="https://www.yuque.com/wztlink1013/blog/nwt63v" target="_blank" class="ne-link"><span class="ne-text">MongoDB下载及使用+Navicat使用+服务器上的配置</span></a></p><h3 id="uwCTa"><span class="ne-text">安装mongoose</span></h3><pre><code>cnpm install mongoose -S</code></pre><h2 id="YR98P"><span class="ne-text">使用</span></h2><h3 id="CuLRf"><span class="ne-text">连接数据库语句</span></h3><pre><code>// 连接数据库mongoose  .connect('mongodb://127.0.0.1:27017/test-mongoose', &#123;    useNewUrlParser: true,    useUnifiedTopology: true,  &#125;)  .then(() =&gt; &#123;    console.log('数据库连接成功')  &#125;)  .catch(() =&gt; &#123;    console.log('数据库连接失败')  &#125;)</code></pre><p id="c9c95a662d6bdc8dfc56fe5b2a44cf39" class="ne-p"><span class="ne-text">然后再将这个js文件require到app.js里面使用</span></p><pre><code>// 数据库连接require('./model/connect')</code></pre><h3 id="q5hLU"><span class="ne-text">创建集合</span></h3><ul class="ne-ul"><li id="7d037472da9784ef7d33551a40fc00d8"><span class="ne-text">先利用函数mongoose的schema函数构建一个规则</span></li><li id="30e3a9d06838927e8d7b6185651b5f25"><span class="ne-text">然后利用model函数创建一个集合并且用上这个规则</span></li></ul><pre><code>// Schema：数据库集合的结构对象。// 创建一个集合(相当于sql里面的设定一个表)规则let TestSchema = new mongoose.Schema(&#123;  name: &#123; type: String &#125;,  age: &#123; type: Number, default: 0 &#125;,  email: &#123; type: String &#125;,  time: &#123; type: Date, default: Date.now &#125;,&#125;)<p>// Model ：由Schema构造而成，可操作数据库。<br>// 创建一个集合(并且应用上面的规则)<br>let TestModel = mongoose.model(‘schema’, TestSchema)<br></code></pre></p><h3 id="lC5j4"><span class="ne-text">增加文档</span></h3><ul class="ne-ul"><li id="c1ebd2524e4df9a8bc19d7366ca3792c"><span class="ne-text">第一个参数：create函数</span></li><li id="399e7ec053484186a0799b2639092da0"><span class="ne-text">第二个参数：可以打印相关信息（doc和err）</span></li></ul><pre><code>// 创建（创建完执行以便之后就注释掉，不然会一直重复创建）TestModel.create(  [    &#123; name: 'test-1', age: 8 &#125;,    &#123; name: 'test-2', age: 18 &#125;,    &#123; name: 'test-3', age: 28 &#125;,    &#123; name: 'test-4', age: 38 &#125;,    &#123; name: 'test-5', age: 48 &#125;,    &#123; name: 'test-6', age: 58, email: 'tttt@qq.com' &#125;,    &#123; name: 'test-7', age: 68, email: 'ssss@qq.com' &#125;,    &#123; name: 'test-8', age: 18 &#125;,    &#123; name: 'test-9', age: 18, email: 'rrrr@qq.com' &#125;,    &#123; name: 'test-10', age: 18 &#125;,  ],  (error, docs)&#123;    if (error) &#123;      console.log(error)    &#125; else &#123;      console.log('save ok')      console.log(docs)    &#125;  &#125;)</code></pre><ul class="ne-ul"><li id="a41addd210d7686d49f6ebcc93cf8e30"><span class="ne-text">也可以创建一个对象赋值给一个变量，然后该变量利用函数save即可保存到数据库</span></li></ul><div data-type="danger" class="ne-alert"><p id="u59cd1a38" class="ne-p"><span class="ne-text">创建完执行以便之后就注释掉，不然会一直重复创建</span></p></div><h3 id="vvKaw"><span class="ne-text">查询文档</span></h3><ul class="ne-ul"><li id="u47e0fb62"><span class="ne-text">查询函数</span><code class="ne-code"><span class="ne-text">findOne</span></code><span class="ne-text">：返回第一条数据</span></li><li id="u7c9bc1e0"><span class="ne-text">查询函数</span><code class="ne-code"><span class="ne-text">find</span></code><span class="ne-text">：查询所有包含条件的数据</span></li></ul><pre><code>// 查询TestModel.find(  // 28&lt;= age &lt;48  &#123; age: &#123; $gte: 28, $lt: 48 &#125; &#125;,  // 1为指定字段，0为排除字段  &#123; name: 1, age: 1, _id: 0 &#125;,  function (err, docs) &#123;    if (err) &#123;      console.log('查询出错: ' + err)    &#125; else &#123;      console.log('$gte,$lte查询结果为: ')      console.log(docs)    &#125;  &#125;)</code></pre><h3 id="xa1jM"><span class="ne-text">mongoose条件查询</span></h3><p id="u5d586ab7" class="ne-p"><span class="ne-text">键为变量时用</span></p><p id="u520d896c" class="ne-p"><span class="ne-text">中括号括起来就行了</span></p><pre><code>checkStr(data.type_id, 'email')    ? (type_str = 'email')    : (type_str = 'user_id')Model_user.find(&#123; [type_str]: data.type_id &#125;, &#123;&#125;, (err, docs) =&gt; &#123;&#125;</code></pre><p id="u847b6a58" class="ne-p"><span class="ne-text"></span></p><p id="ub924cbe9" class="ne-p"><span class="ne-text">逻辑查询</span></p><p id="uaded3def" class="ne-p"><span class="ne-text">参考：</span></p><ul class="ne-ul"><li id="u60000458"><span class="ne-text">文档：</span><a href="http://mongoosejs.net/docs/queries.html" data-href="http://mongoosejs.net/docs/queries.html" target="_blank" class="ne-link"><span class="ne-text">http://mongoosejs.net/docs/queries.html</span></a></li><li id="u8661ef16"><a href="https://segmentfault.com/a/1190000021010300" data-href="https://segmentfault.com/a/1190000021010300" target="_blank" class="ne-link"><span class="ne-text">mongoose 系列之一 find 查询</span></a></li></ul><pre><code>Model_user.find(  &#123; $or: [&#123; email: obj.email &#125;, &#123; user_id: obj.user_id &#125;] &#125;,  &#123;&#125;,  (err, docs) =&gt; &#123;&#125;)</code></pre><h3 id="lVQsg"><span class="ne-text">更新文档</span></h3><p id="ue3e09cc1" class="ne-p"><code class="ne-code"><span class="ne-text">User.updateOne(&#123;查询条件&#125;, &#123;要修改的值&#125;).then(result =&gt; console.log(result))</span></code></p><ul class="ne-ul"><li id="ua77d93c9"><span class="ne-text">updateOne：更新单个</span></li><li id="ua869ce75"><span class="ne-text">updateMany：更新多个</span></li></ul><pre><code>// 更新let conditions_1 = &#123; name: 'test-3' &#125;let update = &#123; $set: &#123; age: 11 &#125; &#125;TestModel.updateOne(conditions_1, update, function (error) &#123;  if (error) &#123;    console.log(error)  &#125; else &#123;    console.log('Update success!')    TestModel.find(      &#123; name: 'test-3' &#125;,      &#123; name: 1, age: 1, _id: 0 &#125;,      function (err, docs) &#123;        if (err) &#123;          console.log('查询出错: ' + err)        &#125; else &#123;          console.log('更新test-3后的查询结果为: ')          console.log(docs)        &#125;      &#125;    )  &#125;&#125;)</code></pre><h3 id="juiBb"><span class="ne-text">删除文档</span></h3><ul class="ne-ul"><li id="uf64adeb5"><span class="ne-text">删除单个：</span><code class="ne-code"><span class="ne-text">User.findOneAndDelete(&#123;&#125;)then(result =&gt; console.log(result))</span></code></li><li id="u3ecf60ad"><span class="ne-text">删除多个：</span><code class="ne-code"><span class="ne-text">User.deleteMany(&#123;&#125;).then(result =&gt; console.log(result))</span></code></li><li id="u2a8122d7"><span class="ne-text">deleteOne：删除单个</span></li></ul><pre><code>// 删除let conditions_2 = &#123; name: 'test-2' &#125;TestModel.deleteOne(conditions_2, function (error) &#123;  if (error) &#123;    console.log(error)  &#125; else &#123;    console.log('Delete success!')    TestModel.find(      &#123; name: 'test-2' &#125;,      &#123; name: 1, age: 1, _id: 0 &#125;,      function (err, docs) &#123;        if (err) &#123;          console.log('查询出错: ' + err)        &#125; else &#123;          console.log('删除test-2后的查询结果为: ')          console.log(docs)        &#125;      &#125;    )  &#125;&#125;)<p></code></pre></p><h3 id="NvcCP"><span class="ne-text">mongoose验证</span></h3><p id="6768b794faaf2f60036a6c1c2be309ab" class="ne-p"><br></p><p id="8ab6701f4a72f8e0af41382696760cfa" class="ne-p"><span class="ne-text">required: true 必传字段</span></p><p id="90378084bf4da9d8b82c9cd3712c60a5" class="ne-p"><span class="ne-text">minlength：3 字符串最小长度</span></p><p id="a97cb1cb66346a2d92bcd163175b37da" class="ne-p"><span class="ne-text">maxlength: 20 字符串最大长度</span></p><p id="8ec377a0a479a76429e2dd9201a85ac0" class="ne-p"><span class="ne-text">min: 2 数值最小为2</span></p><p id="7407fc8f50616d578f6683c6eca44f5a" class="ne-p"><span class="ne-text">max: 100 数值最大为100</span></p><p id="6a0c063a60a1416474477e1ef7fd4917" class="ne-p"><span class="ne-text">enum: ['html', 'css', 'javascript', 'node.js']</span></p><p id="dbdb49fa5f9fdc7cd81252f2533703c5" class="ne-p"><span class="ne-text">trim: true 去除字符串两边的空格</span></p><p id="4ad5cb8f78d2a95c5e3991b01f3519e6" class="ne-p"><span class="ne-text">validate: 自定义验证器</span></p><p id="fa2c27ed12d7ac7ad1b48f59c2f5a599" class="ne-p"><span class="ne-text">default: 默认值</span></p><p id="9ae5494a2609fbfaf10e59aa78fbd07a" class="ne-p"><br></p><p id="a018ee404ec903f0043c1b7fa65017d9" class="ne-p"><span class="ne-text">获取错误信息：error.errors['字段名称'].message</span></p><h3 id="Fa0Tc"><span class="ne-text">整体代码</span></h3><pre><code>/* * @Author: wztlink1013 * @Date: 2022-01-11 12:43:02 * @LastEditTime: 2022-01-11 16:44:13 * @Description: */const mongoose = require('mongoose')<p>// 连接数据库<br>mongoose<br>  .connect(‘mongodb://127.0.0.1:27017/test-mongoose’, &#123;<br>    useNewUrlParser: true,<br>    useUnifiedTopology: true,<br>  &#125;)<br>  .then(() =&gt; &#123;<br>    console.log(‘数据库连接成功’)<br>  &#125;)<br>  .catch(() =&gt; &#123;<br>    console.log(‘数据库连接失败’)<br>  &#125;)</p><p>// Schema：数据库集合的结构对象。<br>let TestSchema = new mongoose.Schema(&#123;<br>  name: &#123; type: String &#125;,<br>  age: &#123; type: Number, default: 0 &#125;,<br>  email: &#123; type: String &#125;,<br>  time: &#123; type: Date, default: Date.now &#125;,<br>&#125;)</p><p>// Model ：由Schema构造而成，可操作数据库。<br>let TestModel = mongoose.model(‘schema’, TestSchema)</p><p>// Entity：由Model创建的实体，可操作数据库。<br>// let TestEntity = new TestModel(&#123;<br>//   name: ‘helloworld’,<br>//   age: 28,<br>//   email: ‘<a href="mailto:&#x68;&#x65;&#x6c;&#x6c;&#111;&#x77;&#111;&#x72;&#x6c;&#x64;&#64;&#x71;&#113;&#x2e;&#x63;&#x6f;&#109;">&#x68;&#x65;&#x6c;&#x6c;&#111;&#x77;&#111;&#x72;&#x6c;&#x64;&#64;&#x71;&#113;&#x2e;&#x63;&#x6f;&#109;</a>‘,<br>// &#125;)<br>// console.log(TestEntity)</p><p>// 创建（创建完执行以便之后就注释掉，不然会一直重复创建）<br>// TestModel.create(<br>//   [<br>//     &#123; name: ‘test-1’, age: 8 &#125;,<br>//     &#123; name: ‘test-2’, age: 18 &#125;,<br>//     &#123; name: ‘test-3’, age: 28 &#125;,<br>//     &#123; name: ‘test-4’, age: 38 &#125;,<br>//     &#123; name: ‘test-5’, age: 48 &#125;,<br>//     &#123; name: ‘test-6’, age: 58, email: ‘<a href="mailto:&#x74;&#116;&#x74;&#116;&#64;&#x71;&#x71;&#46;&#x63;&#111;&#109;">&#x74;&#116;&#x74;&#116;&#64;&#x71;&#x71;&#46;&#x63;&#111;&#109;</a>‘ &#125;,<br>//     &#123; name: ‘test-7’, age: 68, email: ‘<a href="mailto:&#115;&#115;&#115;&#115;&#64;&#x71;&#113;&#46;&#99;&#x6f;&#x6d;">&#115;&#115;&#115;&#115;&#64;&#x71;&#113;&#46;&#99;&#x6f;&#x6d;</a>‘ &#125;,<br>//     &#123; name: ‘test-8’, age: 18 &#125;,<br>//     &#123; name: ‘test-9’, age: 18, email: ‘<a href="mailto:&#114;&#114;&#114;&#114;&#64;&#x71;&#113;&#46;&#x63;&#111;&#109;">&#114;&#114;&#114;&#114;&#64;&#x71;&#113;&#46;&#x63;&#111;&#109;</a>‘ &#125;,<br>//     &#123; name: ‘test-10’, age: 18 &#125;,<br>//   ],<br>//   function (error, docs) &#123;<br>//     if (error) &#123;<br>//       console.log(error)<br>//     &#125; else &#123;<br>//       // console.log(‘save ok’)<br>//       // console.log(docs)<br>//     &#125;<br>//   &#125;<br>// )</p><p>// 查询<br>TestModel.find(<br>  // 28&lt;= age &lt;48<br>  &#123; age: &#123; $gte: 28, $lt: 48 &#125; &#125;,<br>  // 1为指定字段，0为排除字段<br>  &#123; name: 1, age: 1, _id: 0 &#125;,<br>  function (err, docs) &#123;<br>    if (err) &#123;<br>      console.log(‘查询出错: ‘ + err)<br>    &#125; else &#123;<br>      console.log(‘$gte,$lte查询结果为: ‘)<br>      console.log(docs)<br>    &#125;<br>  &#125;<br>)<br>// 更新<br>let conditions_1 = &#123; name: ‘test-3’ &#125;<br>let update = &#123; $set: &#123; age: 11 &#125; &#125;<br>TestModel.updateOne(conditions_1, update, function (error) &#123;<br>  if (error) &#123;<br>    console.log(error)<br>  &#125; else &#123;<br>    console.log(‘Update success!’)<br>    TestModel.find(<br>      &#123; name: ‘test-3’ &#125;,<br>      &#123; name: 1, age: 1, _id: 0 &#125;,<br>      function (err, docs) &#123;<br>        if (err) &#123;<br>          console.log(‘查询出错: ‘ + err)<br>        &#125; else &#123;<br>          console.log(‘更新test-3后的查询结果为: ‘)<br>          console.log(docs)<br>        &#125;<br>      &#125;<br>    )<br>  &#125;<br>&#125;)<br>// 删除<br>let conditions_2 = &#123; name: ‘test-2’ &#125;<br>TestModel.deleteOne(conditions_2, function (error) &#123;<br>  if (error) &#123;<br>    console.log(error)<br>  &#125; else &#123;<br>    console.log(‘Delete success!’)<br>    TestModel.find(<br>      &#123; name: ‘test-2’ &#125;,<br>      &#123; name: 1, age: 1, _id: 0 &#125;,<br>      function (err, docs) &#123;<br>        if (err) &#123;<br>          console.log(‘查询出错: ‘ + err)<br>        &#125; else &#123;<br>          console.log(‘删除test-2后的查询结果为: ‘)<br>          console.log(docs)<br>        &#125;<br>      &#125;<br>    )<br>  &#125;<br>&#125;)<br></code></pre></p><p id="ube00435c" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1641879796743-f8670ed9-0562-4e6d-ab68-79418d34424f.png" width="373.49537658691406" id="ddiif" class="ne-image"></p><p id="ub82dbb10" class="ne-p"><br></p><p id="u29316754" class="ne-p"><br></p><p id="ud4ff2363" class="ne-p"><br></p><h3 id="Uz4XW"><span class="ne-text">其他</span></h3><ul class="ne-ul"><li id="u362fd903"><a href="https://blog.csdn.net/youhebuke225/article/details/106872122" data-href="https://blog.csdn.net/youhebuke225/article/details/106872122" target="_blank" class="ne-link"><span class="ne-text">mongoose查询到的对象无法读取问题</span></a></li></ul><h3 id="k5mRE"><span class="ne-text">mongodb创建集合</span></h3><p id="u50abd338" class="ne-p"><br></p></div>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
          <category> DataBase </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>nvm管理node版本</title>
      <link href="/blog/orml31/"/>
      <url>/blog/orml31/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><ul class="ne-ul"><li id="u6f1a11ad" data-lake-index-type="0"><span class="ne-text">下载：</span><a href="https://github.com/coreybutler/nvm-windows/releases" data-href="https://github.com/coreybutler/nvm-windows/releases" target="_blank" class="ne-link"><span class="ne-text">https://github.com/coreybutler/nvm-windows/releases</span></a></li><li id="u58522893" data-lake-index-type="0"><a href="https://blog.csdn.net/weixin_42429718/article/details/107356796" data-href="https://blog.csdn.net/weixin_42429718/article/details/107356796" target="_blank" class="ne-link"><span class="ne-text">【Win10】巧用 nvm来解决 node 版本降级需求</span></a></li><li id="u40d5f1ff" data-lake-index-type="0"><a href="https://segmentfault.com/a/1190000020807954" data-href="https://segmentfault.com/a/1190000020807954" target="_blank" class="ne-link"><span class="ne-text">使用nvm安装nodejs</span></a></li></ul><h3 id="vpliI"><span class="ne-text">下载nodejs</span></h3><p id="ue8c5c4a3" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1646015457726-d19e782f-8797-4167-a6ac-877ab4363920.png" width="575.8333104517734" id="u4e476f71" class="ne-image"></p><h3 id="tcj0K"><span class="ne-text">报错：No installations recognized.</span></h3><p id="ue22f876c" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1646014822860-68c3a4ee-6dbf-4853-a7d9-c99f28c3c972.png" width="304.99998788038937" id="MVut8" class="ne-image"></p><p id="u0486aaef" class="ne-p"><span class="ne-text">需要将之前的node环境删掉</span></p><p id="ue210897b" class="ne-p"><span class="ne-text">删掉如下</span></p><p id="u7a3cdf07" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1646015246548-4b6f975d-0652-419b-b2c1-79d5f97e5558.png" width="774.999969204268" id="BtGUQ" class="ne-image"></p><h3 id="yphLZ"><span class="ne-text">报错：exit status 1: The system cannot find the path specified.</span></h3><pre><code><code>exit status 1: You do not have sufficient privilege to perform this operation.</code></code></pre><p id="uf0e27a14" class="ne-p"><span class="ne-text">解决：使用管理员身份去使用node版本</span></p><p id="uefb9d299" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1646015723921-56f81812-b31d-45f0-8027-21d173c9acdd.png" width="497.4999802311269" id="u2f436308" class="ne-image"></p><h3 id="JRnDl"><span class="ne-text">报错：'node' 不是内部或外部命令，也不是可运行的程序或批处理文件。</span></h3><p id="ubc3b8f5f" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1646016552396-5cf3a66d-d5e7-429d-85e4-2a37df007bc6.png" width="510.8333130346412" id="u42c11cd6" class="ne-image"></p><p id="u08d05942" class="ne-p"><span class="ne-text">进入控制面板把nodejs彻底删掉</span></p><p id="u83e57d83" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1646017148931-b0919943-28b5-490c-a368-463b03f60059.png" width="469.9999813238787" id="ue43ec686" class="ne-image"></p><h3 id="u3leW"><span class="ne-text">node版本切换不影响全局npm包的通用</span></h3><p id="u99ea3528" class="ne-p"><span class="ne-text">切换版本下面，如果下载了全局包，全局包是跟着版本进行的，nvm切换node版本共用全局包：</span></p><ul class="ne-ul"><li id="u12b43bf3" data-lake-index-type="0"><a href="https://segmentfault.com/q/1010000009977998" data-href="https://segmentfault.com/q/1010000009977998" target="_blank" class="ne-link"><span class="ne-text">nvm切换node versionnpm后全局包不能共用的问题</span></a></li><li id="u6d154ef0" data-lake-index-type="0"><a href="https://blog.51cto.com/u_15349906/3712342" data-href="https://blog.51cto.com/u_15349906/3712342" target="_blank" class="ne-link"><span class="ne-text">NVM：切换node版本后无法使用npm全局包</span></a></li></ul><pre><code><code>npm config set prefix &quot;D:\nodejs_global\node_global&quot;npm config set cache &quot;D:\nodejs_global\node_cache&quot;</code></code></pre><p id="u3a548266" class="ne-p"><span class="ne-text">添加环境变量</span></p><p id="u9bd60fbc" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1646042776058-0806fb34-c929-418a-88ac-c132e5b5e348.png" width="482" id="udaf3a533" class="ne-image"></p><p id="u5a3d2a01" class="ne-p"><span class="ne-text">所以现在d盘下有三个文件夹：</span></p><ul class="ne-ul"><li id="uc72963ae" data-lake-index-type="0"><span class="ne-text">nvm：nvm的根路径，里面存有自己下载的各类node版本</span></li><li id="u9fcbba40" data-lake-index-type="0"><span class="ne-text">nodejs：映射nvm文件夹中当前已选择的node版本文件夹</span></li><li id="u83519b9e" data-lake-index-type="0"><span class="ne-text">nodejs_global：npm下载的全局包文件夹，因为如果不这么做，那么下载的全局包只能再当前node版本下使用，切换到别的node版本，全局包就不通用了</span></li></ul></div>]]></content>
      
      
      <categories>
          
          <category> 计算机素养 </category>
          
          <category> 环境搭建 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Springboot+Ajax全栈在线考试管理系统笔记</title>
      <link href="/blog/aeavli/"/>
      <url>/blog/aeavli/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="ub9d15cdc" class="ne-p"><span class="ne-text">校内实习笔记</span></p><h2 id="Zn9ho"><span class="ne-text">开发环境搭建</span></h2><h3 id="W6hhP"><span class="ne-text">MySQL下载安装</span></h3><ul class="ne-ul"><li id="ub2863bab"><span class="ne-text">下载地址：</span><a href="https://www.mysql.com/downloads/" data-href="https://www.mysql.com/downloads/" target="_blank" class="ne-link"><span class="ne-text">https://www.mysql.com/downloads/</span></a></li><li id="ub5f47daf"><span class="ne-text">安装下载教程：</span><a href="https://blog.csdn.net/Kindergarten_Sir/article/details/109274396" data-href="https://blog.csdn.net/Kindergarten_Sir/article/details/109274396" target="_blank" class="ne-link"><span class="ne-text">MySQL的下载与安装教程--超详细</span></a></li></ul><p id="u3d6edb70" class="ne-p"><span class="ne-text"></span></p><p id="u97153148" class="ne-p"><span class="ne-text">成功如下：</span></p><p id="u2f594951" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1645420397245-3062da09-70ef-47cb-94a0-1169ed942a1a.png" width="789.9999686082217" id="uf3cb7e10" class="ne-image"></p><p id="u8e210634" class="ne-p"><span class="ne-text">再配置环境变量（和java环境变量配置一样）</span></p><p id="u78a15551" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1645670861710-ec8aa52e-ae51-41d7-a008-03b385f5a189.png" width="576.666643751993" id="u53489e49" class="ne-image"></p><p id="u6d3eac2f" class="ne-p"><br></p><h3 id="eI3gv"><span class="ne-text">IDEA下载安装</span></h3><p id="ub40be899" class="ne-p"><span class="ne-text">IDEA下载：</span><a href="https://www.jetbrains.com.cn/idea/download/#section=windows" data-href="https://www.jetbrains.com.cn/idea/download/#section=windows" target="_blank" class="ne-link"><span class="ne-text">https://www.jetbrains.com.cn/idea/download/#section=windows</span></a></p><h3 id="cbjTa"><span class="ne-text">java下载安装</span></h3><p id="uea56c2b2" class="ne-p"><span class="ne-text">需要下载1.8版本的，之前版本删掉</span></p><p id="uaf99547c" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1645497764451-167842e2-5328-446e-bf72-a806cd4ba938.png" width="679.1666396790091" id="u7491a2a7" class="ne-image"></p><h3 id="SbzEb"><span class="ne-text">Maven下载安装</span></h3><p id="u15abe63a" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1645495772713-46fcc17d-68a0-4c2a-8901-87bc114cfe59.png" width="806.6666346126145" id="ua6d1ef1a" class="ne-image"></p><p id="uc0678083" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1645495819742-223ad090-3f07-4b04-95b2-e5262d74b394.png" width="822.4999673167878" id="ue1ef2b60" class="ne-image"></p><p id="u5d0ad3e5" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1645495723226-f5c72ffc-05cb-4b1c-99dc-cce4ec7667bf.png" width="813.3333010143717" id="u3a1d182d" class="ne-image"></p><h2 id="lcNBZ"><span class="ne-text">创建springboot应用程序</span></h2><h3 id="Gg6R5"><span class="ne-text">Maven模板快速创建项目</span></h3><p id="u93aa0b73" class="ne-p"><span class="ne-text">找到下面的选项快速创建</span></p><p id="ud8a8be20" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1645496306314-3c77ca31-a9e7-4e1e-96de-4e26ff1a98c6.png" width="1364.1666124595558" id="uceef7a43" class="ne-image"></p><p id="u54ceb27a" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1645496453507-1473a2e0-520a-4d7a-a0b6-cb2723f22ec5.png" width="1364.1666124595558" id="u6251fbd7" class="ne-image"></p><p id="u8c6b137c" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1645496663531-f043939a-6d4a-4c33-90cf-99ad93d71f0d.png" width="1364.1666124595558" id="u5fe0c9bc" class="ne-image"></p><h3 id="KDIfG"><span class="ne-text">配置Maven的settings文件</span></h3><p id="ufc3930b7" class="ne-p"><span class="ne-text">关于cong文件夹中的settings.xml文件（</span><code class="ne-code"><span class="ne-text">D:\maven\conf</span></code><span class="ne-text">）：</span></p><ul class="ne-ul"><li id="u5d834c39"><span class="ne-text">maven用来构建项目</span></li><li id="ubac99ee9"><span class="ne-text">java需要外部的jar包，外网的中央仓库，下载本地仓库</span></li></ul><ul class="ne-ul"><li id="ueb522d1d"><span class="ne-text">setting.xml文件里面的盘符注意</span></li></ul><pre><code>&lt;localRepository&gt;D:/lib_repo/repository&lt;/localRepository&gt;</code></pre><ul class="ne-ul"><li id="u6cc8534f"><span class="ne-text">用阿里的源站下载</span></li></ul><pre><code>  &lt;mirrors&gt;     &lt;!-- 这里使用的是阿里的远程maven镜像，目前国内大多数都使用它 --&gt;     &lt;mirror&gt;         &lt;id&gt;alimaven&lt;/id&gt;        &lt;name&gt;aliyun maven&lt;/name&gt;        &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt;        &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;    &lt;/mirror&gt;  &lt;/mirrors&gt;</code></pre><h3 id="mVcaE"><span class="ne-text">添加src/main/java目录</span></h3><p id="u721ad001" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1645498371242-a283bfdb-f00f-4c4a-8cce-548dc8f1245f.png" width="304.16665458016973" id="uUlRT" class="ne-image"></p><h3 id="VD278"><span class="ne-text">pom.xml添加项目依赖jar包</span></h3><p id="uc65a0fda" class="ne-p"><span class="ne-text">打开pom.xml文件，改配置文件，添加依赖项，具体修改为如下：</span></p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;parent&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;        &lt;version&gt;2.6.2&lt;/version&gt;        &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;    &lt;/parent&gt;    &lt;groupId&gt;com.cn.shicun&lt;/groupId&gt;    &lt;artifactId&gt;emis&lt;/artifactId&gt;    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;<pre><code>&amp;lt;name&amp;gt;emis&amp;lt;/name&amp;gt;&amp;lt;properties&amp;gt;    &amp;lt;project.build.sourceEncoding&amp;gt;UTF-8&amp;lt;/project.build.sourceEncoding&amp;gt;    &amp;lt;maven.compiler.source&amp;gt;1.8&amp;lt;/maven.compiler.source&amp;gt;    &amp;lt;maven.compiler.target&amp;gt;1.8&amp;lt;/maven.compiler.target&amp;gt;&amp;lt;/properties&amp;gt;&amp;lt;dependencies&amp;gt;    &amp;lt;dependency&amp;gt;        &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;        &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt;    &amp;lt;/dependency&amp;gt;&amp;lt;/dependencies&amp;gt;&amp;lt;build&amp;gt;&amp;lt;/build&amp;gt;</code></pre><p>&lt;/project&gt;<br></code></pre></p><p id="u1bdef055" class="ne-p"><span class="ne-text">点击右上角蓝色更新按钮</span></p><p id="uaa3e09a1" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1645757724190-8b4ba45a-8ac4-48c9-a306-b63d8936c87d.png" width="1216.666618320679" id="u0495e1bc" class="ne-image"></p><p id="ue8ab886d" class="ne-p"><span class="ne-text">然后idea会自动下载这些jar包（Maven优势之一，就是会自动下载jar包）</span></p><p id="u0671e5f1" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1645498601439-0aa7238f-2ea2-4158-8bb8-61e355c5bb1e.png" width="1599.9999364217147" id="ud93f9cb0" class="ne-image"></p><p id="u03769508" class="ne-p"><span class="ne-text">下载成功如下所示：</span></p><p id="uf55c1abd" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1645498687230-217fcf65-9ed3-4888-bc04-b1b08d423a92.png" width="179.671875" id="ub991bc27" class="ne-image"></p><h2 id="YNfUv"><span class="ne-text">运行springboot应用程序</span></h2><h3 id="QUxg1"><span class="ne-text">测试代码</span></h3><p id="u4992ca59" class="ne-p"><span class="ne-text">如下位置写入如下代码：</span></p><p id="u22d45b72" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1645511526582-4dd0440d-2caf-4137-b544-f487045eb46f.png" width="300.015625" id="u6e9df4ef" class="ne-image"></p><pre><code>package com.cn.shixun;<p>import org.springframework.boot.SpringApplication;<br>import org.springframework.boot.autoconfigure.SpringBootApplication;</p><p>@SpringBootApplication<br>public class App<br>&#123;<br>    public static void main( String[] args )<br>    &#123;<br>        SpringApplication.run(App.class);<br>    &#125;<br>&#125;<br></code></pre></p><h3 id="fzUO5"><span class="ne-text">静态资源</span></h3><p id="ufac7f9e4" class="ne-p"><span class="ne-text">然后在resources新建文件夹static，在其中写入index.html文件，然后运行App代码</span></p><p id="u48dab530" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1645513209905-d82808a5-87e0-4d1d-a44f-7bd84bf14e48.png" width="689.9999725818645" id="u08e7d5a8" class="ne-image"></p><p id="ubbaeef4f" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1645513163237-543a369b-f027-4a23-a54b-16d5396317e7.png" width="740.8333038952627" id="u649359b3" class="ne-image"></p><h3 id="R4FjW"><span class="ne-text">idea实时刷新前端代码设置</span></h3><p id="u75569296" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1645513254386-91ff5733-2ee8-4bba-a306-3e0ae0a82189.png" width="809.9999678134931" id="u857aff52" class="ne-image"></p><p id="u32ec23c5" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1645513246554-dda6481d-a454-497b-a90f-66700b3df752.png" width="811.6666344139323" id="u8bb3fd04" class="ne-image"></p><h2 id="b0Yyp"><span class="ne-text">前后端架构</span></h2><p id="u1dc3bbfa" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1645602574923-49da96c6-764f-4141-af8b-b6d8fe8bc584.png" width="840.8332999216199" id="u65920461" class="ne-image"></p><h2 id="UzUhw"><span class="ne-text">前端</span></h2><h3 id="LL54d"><span class="ne-text">jQuery的Ajax的使用</span></h3><p id="u6e7b9fc3" class="ne-p"><span class="ne-text">jQuery其他相关笔记之前已经学过，不做赘述，此文只做Ajax相关的笔记</span></p><p id="uf756364e" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1629125564200-d6272b27-ffcf-4f6d-b7f8-f1ccc7660b0c.png" width="609.4973754882812" id="pBacN" class="ne-image"></p><pre><code>//    Ajax ===============================================================let ajaxDemo = function()&#123;    $.ajax(&#123;        type : &quot;post&quot;,        url : &quot;https://127.0.0.1:8080/test/demo2&quot;,        data : &#123;            &quot;name&quot; : &quot;李四&quot;,            &quot;age&quot; : 14        &#125;,//        dataType : &quot;json&quot;,        success : function(data) &#123;// 后端的返回值            alert(data);        &#125;    &#125;);&#125;</code></pre><pre><code>&lt;input type=&quot;button&quot; value=&quot;ajax点击按钮&quot; onclick=&quot;ajaxDemo();&quot;&gt;</code></pre><p id="u0b442196" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1645600461044-6f9411a0-aaf9-4f27-bc88-9d590544a9de.png" width="578.3333103524324" id="KCZBi" class="ne-image"></p><h3 id="GmKZL"><span class="ne-text">原生JavaScript的Ajax使用</span></h3><p id="ueee0275d" class="ne-p"><br></p><pre><code>function ajax (options) &#123;    // 默认值    var defaults = &#123;        type: 'get',        url: '',        data: &#123;&#125;,        header: &#123;            'Content-Type': 'application/x-www-form-urlencoded'        &#125;,        success: function () &#123;&#125;,        error: function () &#123;&#125;    &#125;    // 使用用户传递的参数替换默认值参数    Object.assign(defaults, options);    // 创建ajax对象    var xhr = new XMLHttpRequest();    // 参数拼接变量    var params = '';    // 循环参数    for (var attr in defaults.data) &#123;        // 参数拼接        params += attr + '=' + defaults.data[attr] + '&amp;';        // 去掉参数中最后一个&amp;        params = params.substr(0, params.length-1)    &#125;    // 如果请求方式为get    if (defaults.type == 'get') &#123;        // 将参数拼接在url地址的后面        defaults.url += '?' + params;    &#125;<pre><code>// 配置ajax请求xhr.open(defaults.type, defaults.url);// 如果请求方式为postif (defaults.type == &#39;post&#39;) &#123;    // 设置请求头    xhr.setRequestHeader(&#39;Content-Type&#39;, defaults.header[&#39;Content-Type&#39;]);    // 如果想服务器端传递的参数类型为json    if (defaults.header[&#39;Content-Type&#39;] == &#39;application/json&#39;) &#123;        // 将json对象转换为json字符串        xhr.send(JSON.stringify(defaults.data))    &#125;else &#123;        // 发送请求        xhr.send(params);    &#125;&#125; else &#123;    xhr.send();&#125;// 请求加载完成xhr.onload = function () &#123;    // 获取服务器端返回数据的类型    var contentType = xhr.getResponseHeader(&#39;content-type&#39;);    // 获取服务器端返回的响应数据    var responseText = xhr.responseText;    // 如果服务器端返回的数据是json数据类型    if (contentType.includes(&#39;application/json&#39;)) &#123;        // 将json字符串转换为json对象        responseText = JSON.parse(responseText);    &#125;    // 如果请求成功    if (xhr.status == 200) &#123;        // 调用成功回调函数, 并且将服务器端返回的结果传递给成功回调函数        defaults.success(responseText, xhr);    &#125; else &#123;        // 调用失败回调函数并且将xhr对象传递给回调函数        defaults.error(responseText, xhr);    &#125; &#125;// 当网络中断时xhr.onerror = function () &#123;    // 调用失败回调函数并且将xhr对象传递给回调函数    defaults.error(xhr);&#125;</code></pre><p>}<br></code></pre></p><p id="u300e0036" class="ne-p"><br></p><h3 id="N5NMf"><span class="ne-text">AdminLTE框架</span></h3><p id="ueea8d4ed" class="ne-p"><span class="ne-text">文档：</span><a href="https://adminlte.io/" data-href="https://adminlte.io/" target="_blank" class="ne-link"><span class="ne-text">https://adminlte.io/</span></a></p><p id="ue40fc851" class="ne-p"><span class="ne-text">下载adminlte及其依赖放到静态文件夹</span></p><p id="uf0622b47" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1645520275251-6ba0c4e2-026d-4289-8519-2a67d7d0e2af.png" width="254.015625" id="vP941" class="ne-image"></p><p id="u409ab831" class="ne-p"><span class="ne-text">使用jsDelivr外链来构建</span></p><p id="u833a101c" class="ne-p"><a href="https://cdn.jsdelivr.net/npm/admin-lte@3.2/dist/css/adminlte.min.css" data-href="https://cdn.jsdelivr.net/npm/admin-lte@3.2/dist/css/adminlte.min.css" target="_blank" class="ne-link"><span class="ne-text">https://cdn.jsdelivr.net/npm/admin-lte@3.2/dist/css/adminlte.min.css</span></a></p><p id="u588423b2" class="ne-p"><a href="https://cdn.jsdelivr.net/npm/admin-lte@3.2/plugins/fontawesome-free/css/all.min.css" data-href="https://cdn.jsdelivr.net/npm/admin-lte@3.2/plugins/fontawesome-free/css/all.min.css" target="_blank" class="ne-link"><span class="ne-text">https://cdn.jsdelivr.net/npm/admin-lte@3.2/plugins/fontawesome-free/css/all.min.css</span></a></p><h3 id="SiaT0"><span class="ne-text">构建管理类系统的静态页模板</span></h3><p id="u0a4932c1" class="ne-p"><strong><span class="ne-text">利用AdminLTE UI模板搭建出项目所需的目的页面（在static里面写出想要的各种效果）</span></strong></p><p id="u20404070" class="ne-p"><span class="ne-text">管理类系统的页面类型大概有以下几类：</span></p><ol class="ne-ol"><li id="uac303bec"><span class="ne-text">登录页（大多数的管理类系统都没有注册页，需要通过用户管理模块增加用户）。</span></li></ol><p id="u174c34cd" class="ne-p"><a href="http://127.0.0.1:8080/pages/login.html" data-href="http://127.0.0.1:8080/pages/login.html" target="_blank" class="ne-link"><span class="ne-text">http://127.0.0.1:8080/pages/login.html</span></a></p><ol start="2" class="ne-ol"><li id="u69390ba2"><span class="ne-text">欢迎页，登录成功后进入的首页。</span></li></ol><p id="ub9e1b6bd" class="ne-p"><a href="http://127.0.0.1:8080/pages/index.html" data-href="http://127.0.0.1:8080/pages/index.html" target="_blank" class="ne-link"><span class="ne-text">http://127.0.0.1:8080/pages/index.html</span></a></p><ol start="3" class="ne-ol"><li id="ufe14e726"><span class="ne-text">列表页，展示数据集合的表格，一般带分页和查询功能，展示的每行数据的最后会有可以点击的“修改”和“删除”功能。</span></li><li id="u2d115db2"><span class="ne-text">新增/修改页，一个form表单，同一个的功能模块的新增/修改页的表单元素是一致的，只是修改页需要回填数据。</span></li><li id="u0eda6d8e"><span class="ne-text">其他特殊页，例如在线答题页、数据统计页、文件上传页等等，这些在管理类系统中的占比很小。</span></li></ol><h2 id="KEUvQ"><span class="ne-text">后端：Springboot 学习</span></h2><p id="ufa54678d" class="ne-p"><span class="ne-text">记录一下框架的API使用</span></p><h3 id="lbTOb"><span class="ne-text">参考资料</span></h3><ul class="ne-ul"><li id="u92531a69"><a href="https://www.springcloud.cc/spring-boot.html" data-href="https://www.springcloud.cc/spring-boot.html" target="_blank" class="ne-link"><span class="ne-text">Spring Boot参考指南</span></a></li><li id="ucf561286"><a href="http://c.biancheng.net/spring_boot/" data-href="http://c.biancheng.net/spring_boot/" target="_blank" class="ne-link"><span class="ne-text">Spring Boot框架入门教程（快速学习版）</span></a></li></ul><hr id="mk2s4" class="ne-hr"><p id="udb96359f" class="ne-p"><span class="ne-text">vscode运行springboot项目</span></p><ul class="ne-ul"><li id="u276e0432"><a href="https://juejin.cn/post/7036643751896285220" data-href="https://juejin.cn/post/7036643751896285220" target="_blank" class="ne-link"><span class="ne-text">demo5：如何优雅的在vscode里面跑springboot工程</span></a></li></ul><hr id="EJTKd" class="ne-hr"><p id="u5f30a343" class="ne-p"><span class="ne-text">SpringBoot编写接口</span></p><ul class="ne-ul"><li id="u0f65099a"><a href="https://blog.csdn.net/qq_28336351/article/details/79327357" data-href="https://blog.csdn.net/qq_28336351/article/details/79327357" target="_blank" class="ne-link"><span class="ne-text">用Spring Boot开发API接口</span></a></li></ul><hr id="GKXgn" class="ne-hr"><h3 id="k4e1H"><span class="ne-text">@SpringBootApplication</span></h3><p id="u3adda718" class="ne-p"><span class="ne-text">主要方法是通过调用run来委托Spring Boot的SpringApplication类。</span></p><p id="u35e4e33f" class="ne-p"><span class="ne-text">SpringApplication引导我们的应用程序，从Spring开始，然后启动自动配置的Tomcat Web服务器。</span></p><p id="u6a37736e" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1645749879910-2701fc28-b68f-446f-81e8-4dabe66e43e7.png" width="1599.9999364217147" id="u835cf579" class="ne-image"></p><p id="u62c67ac3" class="ne-p"><span class="ne-text">我们需要将Example.class作为参数传递给run方法，以告诉SpringApplication哪个是主要的Spring组件。</span></p><p id="u673dd8a7" class="ne-p"><span class="ne-text">还会传递args数组以公开任何命令行参数。</span></p><p id="u44cb04c0" class="ne-p"><span class="ne-text">springboot的启动类是有作用范围的</span></p><h3 id="Sutl6"><span class="ne-text">@Controller</span></h3><p id="u4a604ad2" class="ne-p"><span class="ne-text">所创建的类是一个web </span><code class="ne-code"><span class="ne-text">@Controller</span></code><span class="ne-text">，所以Spring</span><strong><span class="ne-text">在处理传入的Web请求时会考虑它</span></strong><span class="ne-text">。</span></p><h3 id="I634I"><span class="ne-text">@RequestMapping(&quot;test&quot;)</span></h3><p id="u88beba0f" class="ne-p"><span class="ne-text">@RequestMapping注释提供“路由”信息。它告诉Spring任何带有/test路径的HTTP请求都应该映射到所写的test方法。</span></p><h3 id="ZaabW"><span class="ne-text">@responseBody</span></h3><p id="u9066e349" class="ne-p"><span class="ne-text">@responseBody注解的作用是将controller的方法返回的对象通过适当的转换器转换为指定的格式之后，写入到response对象的body区，通常用来返回JSON数据回格式是text/json（或者是XML）数据，需要注意的呢，在使用此注解之后不会再走试图处理器，而是直接将数据写入到输入流中，他的效果等同于通过response对象输出指定格式的数据。</span></p><h3 id="hGDuj"><span class="ne-text">@RestController</span></h3><p id="ue2601dba" class="ne-p"><span class="ne-text">类上写上注解 @RestController，那么此Controller返回格式就都是text/json</span></p><p id="u8566e37a" class="ne-p"><br></p><h2 id="EMKFp"><span class="ne-text">后端：数据库学习</span></h2><h3 id="wFOt8"><span class="ne-text">表关系</span></h3><p id="uee74ef3a" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1645751601318-ffb24061-6e8d-4c67-a6e2-666bf0acd9d1.png" width="679.9999729792288" id="u5aec88ce" class="ne-image"></p><p id="ue90a0795" class="ne-p"><span class="ne-text"></span></p><p id="uf471721e" class="ne-p"><span class="ne-text">权限控制：</span></p><p id="u1368d99a" class="ne-p"><span class="ne-text">RBAC，role based access control，基于角色的访问控制</span></p><p id="u9e7d7ac2" class="ne-p"><span class="ne-text">用户，角色，功能（项目的粒度到二级菜单即可）</span></p><p id="ue4daa310" class="ne-p"><span class="ne-text"></span></p><p id="u18d3a9c8" class="ne-p"><span class="ne-text">user，user_role，role，role_menu，menu<br /></span><span class="ne-text">用户_角色组，角色则，角色组_角色</span></p><p id="u6491602a" class="ne-p"><br></p><h3 id="oXMNq"><span class="ne-text">数据表的初始化</span></h3><p id="u3d552a0f" class="ne-p"><span class="ne-text">连接本地数据库</span></p><p id="ubb96c3f1" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1645753130016-3d2056bc-ece0-43e8-b97a-f6ccfbc13587.png" width="306.33331298828125" id="uffe98a1a" class="ne-image"></p><p id="u49fdcae2" class="ne-p"><span class="ne-text">按照教程初始化各个数据库</span></p><p id="u16099470" class="ne-p"><span class="ne-text"></span></p><hr id="fjzNz" class="ne-hr"><p id="u647d8e29" class="ne-p"><span class="ne-text">构建实体类---如果手动构建，需要单独给每个表生成Getter Setter，所以使用下面讲的mybits逆向工程构建。</span></p><h2 id="DzvDK"><span class="ne-text">MyBatis逆向工程</span></h2><h3 id="NP9Pp"><span class="ne-text">添加数据库账户及授权</span></h3><p id="u3e6a3632" class="ne-p"><span class="ne-text">参考：</span><a href="https://blog.csdn.net/weixin_33400820/article/details/81976424" data-href="https://blog.csdn.net/weixin_33400820/article/details/81976424" target="_blank" class="ne-link"><span class="ne-text">navicat创建用户以及设置权限</span></a></p><p id="u7d231e21" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1645757383547-2e71e1ab-c656-4362-af9c-03055d1cdd04.png" width="415.015625" id="u067b447b" class="ne-image"></p><p id="u07d66762" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1645757505559-1082ac8d-ea6e-4462-bf75-dee340fbec59.png" width="345.015625" id="u2db9f02f" class="ne-image"></p><p id="u995fe687" class="ne-p"><span class="ne-text">账号密码都是：mybatis</span></p><p id="ufdf8e3c7" class="ne-p"><span class="ne-text">创建成功后如下：</span></p><p id="u45411967" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1645757562274-1c280235-ee05-4629-863f-aca7b76b5a4a.png" width="408.33331298828125" id="u4644ce1e" class="ne-image"></p><h3 id="iv1p7"><span class="ne-text">pom.xml添加依赖</span></h3><pre><code>    &lt;dependency&gt;      &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;      &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;      &lt;version&gt;2.2.1&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;mysql&lt;/groupId&gt;      &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;      &lt;scope&gt;runtime&lt;/scope&gt;      &lt;!--        1、如果你的数据库是mysql8，这段&lt;version&gt;5.1.32&lt;/version&gt;不用管        2、如果你的数据库是mysql5.x，放开&lt;version&gt;5.1.32&lt;/version&gt;这段注释        --&gt;      &lt;version&gt;5.1.32&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt;      &lt;artifactId&gt;mybatis-generator-core&lt;/artifactId&gt;      &lt;version&gt;1.4.0&lt;/version&gt;    &lt;/dependency&gt;</code></pre><h3 id="jLmYH"><span class="ne-text">编写逆向工程的配置文件generatorConfig.xml和Generator.java</span></h3><p id="u28931f65" class="ne-p"><span class="ne-text">运行Generator类的main方法生成实体类、mapper接口和mapper的xml文件</span></p><p id="ua7af06b3" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1645771323003-02719bd5-ad39-43c6-91f8-c9c3d58f68b5.png" width="209.6666259765625" id="u6276f1f8" class="ne-image"></p><p id="u98f8cbda" class="ne-p"><strong><span class="ne-text">每次生成逆向工程之前，要把之前生成的文件全部删除</span></strong><span class="ne-text">。</span></p><p id="ud61f556f" class="ne-p"><br></p><pre><code>&lt;dependency&gt;  &lt;groupId&gt;com.alibaba&lt;/groupId&gt;  &lt;artifactId&gt;fastjson&lt;/artifactId&gt;  &lt;version&gt;1.2.73&lt;/version&gt;&lt;/dependency&gt;</code></pre><p id="uce896a9a" class="ne-p"><br></p><h2 id="DgwiD"><span class="ne-text">报错</span></h2><h3 id="u7wxz"><span class="ne-text">SpringBoot启动报错Failed to configure a DataSource: ‘url’ attribute is not specified and no embedded datasource could be configured</span></h3><pre><code>Error starting ApplicationContext. To display the conditions report re-run your application with 'debug' enabled.2022-02-27 20:30:12.439 ERROR 12672 --- [           main] o.s.b.d.LoggingFailureAnalysisReporter   : <hr><p>APPLICATION FAILED TO START</p><hr><p>Description:</p><p>Failed to configure a DataSource: ‘url’ attribute is not specified and no embedded datasource could be configured.</p><p>Reason: Failed to determine a suitable driver class</p><p>Action:</p><p>Consider the following:<br>    If you want an embedded database (H2, HSQL or Derby), please put it on the classpath.<br>    If you have database settings to be loaded from a particular profile you may need to activate it (no profiles are currently active).</p><p>Process finished with exit code 1<br></code></pre></p><p id="u877d8a83" class="ne-p"><span class="ne-text">启动类添加如下：</span></p><pre><code>@SpringBootApplication(exclude = &#123;DataSourceAutoConfiguration.class&#125;)</code></pre><p id="uc454574c" class="ne-p"><span class="ne-text">参考：</span><a href="https://www.panziye.com/java/1873.html" data-href="https://www.panziye.com/java/1873.html" target="_blank" class="ne-link"><span class="ne-text">https://www.panziye.com/java/1873.html</span></a></p><h3 id="CCgIJ"><span class="ne-text">Consider defining a bean of type 'com.cn.shixun.mapper.UserMapper' in your configuration.</span></h3><p id="u161eed12" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1645965307851-1a6aeb4e-786d-453c-8f19-cf25c41156eb.png" width="788.3333020077824" id="u345021ed" class="ne-image"></p><p id="uc1c4402f" class="ne-p"><span class="ne-text">参考：</span><a href="https://blog.csdn.net/zzldm/article/details/116534419" data-href="https://blog.csdn.net/zzldm/article/details/116534419" target="_blank" class="ne-link"><span class="ne-text">https://blog.csdn.net/zzldm/article/details/116534419</span></a></p><p id="ue6c6492c" class="ne-p"><span class="ne-text"></span></p><h3 id="y7JI1"><span class="ne-text">nio-8080-exec-1</span></h3><p id="u6fbfe2d8" class="ne-p"><span class="ne-text">属于正常情况</span></p><pre><code>  .   ____          _            __ _ _ /\\ / ___'_ __ _ _(_)_ __  __ _ \ \ \ \( ( )\___ | '_ | '_| | '_ \/ _` | \ \ \ \ \\/  ___)| |_)| | | | | || (_| |  ) ) ) )  '  |____| .__|_| |_|_| |_\__, | / / / / =========|_|==============|___/=/_/_/_/ :: Spring Boot ::                (v2.6.2)<p>2022-02-27 20:46:14.796  INFO 9608 — [           main] com.App                                  : Starting App using Java 1.8.0_151 on DESKTOP-QTVR7IE with PID 9608 (D:\projects\emis\target\classes started by wztli in D:\projects\emis)<br>2022-02-27 20:46:14.799  INFO 9608 — [           main] com.App                                  : No active profile set, falling back to default profiles: default<br>2022-02-27 20:46:16.451  INFO 9608 — [           main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat initialized with port(s): 8080 (http)<br>2022-02-27 20:46:16.464  INFO 9608 — [           main] o.apache.catalina.core.StandardService   : Starting service [Tomcat]<br>2022-02-27 20:46:16.464  INFO 9608 — [           main] org.apache.catalina.core.StandardEngine  : Starting Servlet engine: [Apache Tomcat/9.0.56]<br>2022-02-27 20:46:16.582  INFO 9608 — [           main] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring embedded WebApplicationContext<br>2022-02-27 20:46:16.582  INFO 9608 — [           main] w.s.c.ServletWebServerApplicationContext : Root WebApplicationContext: initialization completed in 1721 ms<br>2022-02-27 20:46:16.996  INFO 9608 — [           main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat started on port(s): 8080 (http) with context path ‘’<br>2022-02-27 20:46:17.010  INFO 9608 — [           main] com.App                                  : Started App in 2.708 seconds (JVM running for 3.193)<br>2022-02-27 20:46:17.075  INFO 9608 — [nio-8080-exec-1] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring DispatcherServlet ‘dispatcherServlet’<br>2022-02-27 20:46:17.075  INFO 9608 — [nio-8080-exec-1] o.s.web.servlet.DispatcherServlet        : Initializing Servlet ‘dispatcherServlet’<br>2022-02-27 20:46:17.076  INFO 9608 — [nio-8080-exec-1] o.s.web.servlet.DispatcherServlet        : Completed initialization in 1 ms</p><p></code></pre></p></div>]]></content>
      
      
      <categories>
          
          <category> 计算机素养 </category>
          
          <category> 环境搭建 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>WebSocket学习笔记</title>
      <link href="/blog/pp1d2p/"/>
      <url>/blog/pp1d2p/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h3 id="D4CnP"><span class="ne-text">一些链接</span></h3><ul class="ne-ul"><li id="u99cd15f2"><span class="ne-text">WebSocket在线调试：</span><a href="http://www.easyswoole.com/wstool.html" data-href="http://www.easyswoole.com/wstool.html" target="_blank" class="ne-link"><span class="ne-text">http://www.easyswoole.com/wstool.html</span></a></li><li id="u24e7cbb7"><span class="ne-text">express笔记：</span><a href="https://www.yuque.com/wztlink1013/projects/tdgoby" data-href="https://www.yuque.com/wztlink1013/projects/tdgoby" class="ne-link"><span class="ne-text">https://www.yuque.com/wztlink1013/projects/tdgoby</span></a></li><li id="uef57eea0"><span class="ne-text">相关文档：</span><a href="http://expressjs.jser.us/" data-href="http://expressjs.jser.us/" target="_blank" class="ne-link"><span class="ne-text">http://expressjs.jser.us/</span></a></li></ul><h3 id="Iw2Vp"><span class="ne-text">mongodb和sharedb-mongo</span></h3><ul class="ne-ul"><li id="u97fcf52f"><a href="https://rain120.github.io/sharedb-zh/sharedb/sharedb" data-href="https://rain120.github.io/sharedb-zh/sharedb/sharedb" target="_blank" class="ne-link"><span class="ne-text">ShareDB中文文档</span></a></li><li id="ud175fc61"><a href="https://rain120.github.io/sharedb-zh/sharedb-mongo/sharedb-mongo" data-href="https://rain120.github.io/sharedb-zh/sharedb-mongo/sharedb-mongo" target="_blank" class="ne-link"><span class="ne-text">sharedb-mongo文档</span></a></li></ul><h3 id="nD9eJ"><span class="ne-text">WebSocket长连接概念</span></h3><p id="ud2e71363" class="ne-p"><span class="ne-text">什么是WebSocket？</span></p><p id="ub718ef9c" class="ne-p"><span class="ne-text">参考：</span></p><ul class="ne-ul"><li id="u44927020"><a href="https://www.liaoxuefeng.com/wiki/1022910821149312/1103303693824096" data-href="https://www.liaoxuefeng.com/wiki/1022910821149312/1103303693824096" target="_blank" class="ne-link"><span class="ne-text">WebSocket 廖雪峰的官方网站</span></a></li><li id="u14123397"><a href="https://www.ruanyifeng.com/blog/2017/05/websocket.html" data-href="https://www.ruanyifeng.com/blog/2017/05/websocket.html" target="_blank" class="ne-link"><span class="ne-text">WebSocket 教程 作者： 阮一峰</span></a></li></ul><p id="u4d2f3080" class="ne-p"><span class="ne-text"></span></p><p id="u753b6170" class="ne-p"><span class="ne-text">为什么需要WebSocket呢？</span></p><p id="u5e0df92f" class="ne-p"><span class="ne-text">因为网络请求，有请求响应，浏览器的请求，还需要有服务端的响应，需要时刻进行数据通信，明显上述不行，因为上述强调一个“主动”，也就是客户端如果不发送请求，服务端就不会进行响应，对协同而言明显不行，比如说，a用户修改了一个部分，这个时候就需要服务端主动将修改后的内容推送到其他客户，这样才能实现实时协同。再比如多人聊天室。</span></p><p id="u052e2fa6" class="ne-p"><span class="ne-text">所以需要一个在浏览器和服务器之间建立一个不受限的双向通信的通道，比如说，服务器可以在任意时刻发送消息给浏览器。</span></p><p id="udcb34ff6" class="ne-p"><span class="ne-text"></span></p><p id="u0aab99b2" class="ne-p"><span class="ne-text">使用的时候还需要注意，只有浏览器支持WebSocket协议，才能够使用该协议，兼容的浏览器种类及版本如下：</span></p><pre><code>ChromeFirefoxIE &gt;= 10Sarafi &gt;= 6Android &gt;= 4.4iOS &gt;= 8</code></pre><p id="u4ddd2859" class="ne-p"><span class="ne-text"></span></p><p id="u6a07008b" class="ne-p"><span class="ne-text">Node.js中，使用最广泛的WebSocket模块是ws，以下学习笔记：</span></p><h3 id="ug2x1"><span class="ne-text">Node.js的WebSocket模块ws的使用</span></h3><p id="u7e3c0ddd" class="ne-p"><span class="ne-text">地址：</span><a href="https://github.com/websockets/ws" data-href="https://github.com/websockets/ws" target="_blank" class="ne-link"><span class="ne-text">https://github.com/websockets/ws</span></a></p><p id="ube1e9f07" class="ne-p"><span class="ne-text">下载</span></p><pre><code>cnpm i ws --save</code></pre><ul class="ne-ul"><li id="uab17cfd1"><span class="ne-text">connection：</span><a href="https://github.com/websockets/ws/blob/master/doc/ws.md#event-connection" data-href="https://github.com/websockets/ws/blob/master/doc/ws.md#event-connection" target="_blank" class="ne-link"><span class="ne-text">https://github.com/websockets/ws/blob/master/doc/ws.md#event-connection</span></a></li><li id="uc72b7f0d"><span class="ne-text">addEventListener：</span><a href="https://github.com/websockets/ws/blob/master/doc/ws.md#websocketaddeventlistenertype-listener-options" data-href="https://github.com/websockets/ws/blob/master/doc/ws.md#websocketaddeventlistenertype-listener-options" target="_blank" class="ne-link"><span class="ne-text">https://github.com/websockets/ws/blob/master/doc/ws.md#websocketaddeventlistenertype-listener-options</span></a></li></ul><h3 id="g8Imx"><span class="ne-text">@teamwork/websocket-json-stream</span></h3><p id="u0e87606a" class="ne-p"><a href="https://www.npmjs.com/package/@teamwork/websocket-json-stream" data-href="https://www.npmjs.com/package/@teamwork/websocket-json-stream" target="_blank" class="ne-link"><span class="ne-text">https://www.npmjs.com/package/@teamwork/websocket-json-stream</span></a></p><p id="u62af2ec5" class="ne-p"><span class="ne-text"></span></p><p id="u4d204ccf" class="ne-p"><span class="ne-text">用于 WebSocket 连接的 nodejs 流包装器。它也适用于浏览器 WebSockets。</span></p></div>]]></content>
      
      
      <categories>
          
          <category> 计算机素养 </category>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>阿里云函数计算FC技术</title>
      <link href="/blog/yey65c/"/>
      <url>/blog/yey65c/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="u33c6bba4" class="ne-p"><span class="ne-text">前言：本文记录一下Serverless技术及其云函数计算FC的应用，以及API网关技术。本文从以下三方面详细展开：</span></p><ol class="ne-ol"><li id="u857b79b5"><span class="ne-text">先介绍Serverless的核心函数计算FC，并用其来迁移express web项目，也就是实实在在的写一个后端接口。</span></li><li id="u949b0e44"><span class="ne-text">开发过程中，如果是小功能项目直接再阿里云函数计算控制台编写代码即可，但如果是较大项目，本地开发的代码编写、调试、部署等功能就很重要了，介绍Serverless Devs Cli的使用。</span></li><li id="uadf4ad22"><span class="ne-text">最后是对API的系统化管理，比如说签名访问，提高安全性。阿里云的API网关技术，利用其完善的API的创建、测试、发布等功能，来模拟企业化开发流程。</span></li></ol><p id="u142c127a" class="ne-p"><span class="ne-text"></span></p><p id="u4b7659de" class="ne-p"><span class="ne-text"></span></p><p id="u76009ae1" class="ne-p"><span class="ne-text">前言：阿里云函数计算，与此对应的还有腾讯云函数计算，两者我都使用过，也做过demo，个人而言，腾讯云的函数计算的确操作及代码的编写简单于阿里云函数计算，具体有这么几个方面：</span></p><ul class="ne-ul"><li id="u07d15c90"><span class="ne-text">如果需要将之前的写好的一些项目代码迁移到里云函数计算中（例如express Web项目），需要改一些代码，比如对阿里云的入口函数handler进行封装，不过这个问题官方团队给出了解决代码。</span></li><li id="u5baafbfc"><span class="ne-text">文档的内容和编排不是那么详细，网络上其实对函数计算的教程类指导文章其实很少，对阿里云函数计算的更少，所以官方文档还是很重要的。</span></li><li id="udede6395"><span class="ne-text">计算函数社区模板，腾讯云应该是优于阿里云函数计算的。</span></li></ul><p id="ucc29651b" class="ne-p"><span class="ne-text"></span></p><p id="u1366782e" class="ne-p"><span class="ne-text">尽管相较腾讯云函数计算而言，阿里云操作稍微复杂，但我还是选择阿里云函数计算，一个是性能，另一个就是征服欲……</span><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/1484158/1642990978768-d60330ad-e0dd-4234-bff1-92bd2df0d596.jpeg" width="52" id="GSie5" class="ne-image"></p><h3 id="cK83W"><span class="ne-text">简单写一个后端接口API</span></h3><p id="u37d56d66" class="ne-p"><span class="ne-text" style="background-color: #FADB14">文档/教程参考：</span></p><ul class="ne-ul"><li id="uee946aab"><a href="https://help.aliyun.com/product/50980.html" data-href="https://help.aliyun.com/product/50980.html" target="_blank" class="ne-link"><span class="ne-text">阿里云函数计算官方文档：函数计算</span></a></li><li id="uadaa8a44"><span class="ne-text">代码开发文档：</span><a href="https://help.aliyun.com/document_detail/74754.html" data-href="https://help.aliyun.com/document_detail/74754.html" target="_blank" class="ne-link"><span class="ne-text">https://help.aliyun.com/document_detail/74754.html</span></a></li><li id="u73badd09"><span class="ne-text">阿里云函数计算内置模块：</span><a href="https://help.aliyun.com/document_detail/58011.html#title-rp4-xhl-ri3" data-href="https://help.aliyun.com/document_detail/58011.html#title-rp4-xhl-ri3" target="_blank" class="ne-link"><span class="ne-text">https://help.aliyun.com/document_detail/58011.html#title-rp4-xhl-ri3</span></a></li></ul><p id="u0451c906" class="ne-p"><span class="ne-text">函数计算除了可以直接使用Node.js的内置模块，还可以使用阿里云里面封装好的一些模块。</span></p><ul class="ne-ul"><li id="ue4174d81"><a href="https://www.zhihu.com/question/506704568/answer/2275420449" data-href="https://www.zhihu.com/question/506704568/answer/2275420449" target="_blank" class="ne-link"><span class="ne-text">如何评价无服务器计算（serverless）的未来前景？你认为 serverless 有未来吗？</span></a></li></ul><p id="ud2ff72e6" class="ne-p"><span class="ne-text"></span></p><p id="u65b3659f" class="ne-p"><span class="ne-text" style="background-color: #FADB14">测试url：</span></p><ul class="ne-ul"><li id="u8e54bf03"><span class="ne-text"></span><a href="https://yunfunc.wztlink1013.com/simple-api" data-href="https://yunfunc.wztlink1013.com/simple-api" target="_blank" class="ne-link"><span class="ne-text">https://yunfunc.wztlink1013.com/simple-api</span></a></li></ul><h4 id="H1TyB"><span class="ne-text">阿里云函数计算的一些注意事项</span></h4><ul class="ne-ul"><li id="u2390a977"><a href="https://www.kancloud.cn/duolabmeng/duolablog/1533791" data-href="https://www.kancloud.cn/duolabmeng/duolablog/1533791" target="_blank" class="ne-link"><span class="ne-text">阿里云-函数计算从入门到放弃</span></a></li></ul><ul class="ne-ul"><li id="u2acafd43"><span class="ne-text">自定义模块就意味着自己之前写的代码不能维护，要改成他这样的内置代码使用</span></li></ul><h4 id="WgAZY"><span class="ne-text">initializer初始化函数</span></h4><p id="u6f87af38" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1642908927273-fec0f794-3326-414d-b10c-cd423d3dd8af.png" width="433" id="ubeed9d07" class="ne-image"></p><pre><code>// 初始化函数exports.context_initializer = &#123;&#125; // 便于打印展示exports.initializer = (context, callback) =&gt; &#123;    console.log('初始化函数 -------------');    context_initializer = context    callback(null, '');&#125;;</code></pre><h4 id="HEkOW"><span class="ne-text">handler入口函数</span></h4><pre><code>// 入口函数exports.handler = (req, resp, context) =&gt; &#123;    console.log('入口函数 -------------');    let params = &#123;        // path: req.path,        // queries: req.queries,        // headers: req.headers,        // method : req.method,        // requestURI : req.url,        // clientIP : req.clientIP,        request_info: req,        context_handler: context,        context_initializer: context_initializer    &#125;<pre><code>// 处理响应getRawBody(req, function(err, body) &#123;    for (let key in req.queries) &#123;      let value = req.queries[key];      resp.setHeader(key, value);    &#125;    resp.setHeader(&amp;quot;Content-Type&amp;quot;, &amp;quot;text/plain&amp;quot;);    params.request_body = body.toString();    resp.send(JSON.stringify(params, null, &#39;    &#39;));&#125;);   /*getFormBody(req, function(err, formBody) &#123;    for (let key in req.queries) &#123;      let value = req.queries[key];      resp.setHeader(key, value);    &#125;    params.body = formBody;    console.log(formBody);    resp.send(JSON.stringify(params));&#125;); */</code></pre><p>}<br></code></pre></p><h3 id="w0qTq"><span class="ne-text">移植Express Web应用</span></h3><p id="ued3f233c" class="ne-p"><span class="ne-text">由于阿里云计算函数内置的一些框架（比如指定的入口、初始化函数等），所以在写express相关代码的时候不能像是本地使用一样，需要对其进行一些封装改造，特别是函数计算当中的入口函数handler，它的请求与响应需要封装一下。具体的封装方案，是参考的官方团队所写的教程：</span><a href="https://developer.aliyun.com/article/703317" data-href="https://developer.aliyun.com/article/703317" target="_blank" class="ne-link"><span class="ne-text">移植 express.js 应用到函数计算</span></a></p><p id="u29ffc216" class="ne-p"><span class="ne-text"></span></p><p id="u5d4746e6" class="ne-p"><span class="ne-text">其他的一些参考文章：</span></p><ul class="ne-ul"><li id="u005cbe72"><a href="https://blog.csdn.net/weixin_34004576/article/details/89700121" data-href="https://blog.csdn.net/weixin_34004576/article/details/89700121" target="_blank" class="ne-link"><span class="ne-text">express框架应用接入阿里云函数计算</span></a></li><li id="uc181e1be"><a href="https://developer.aliyun.com/article/703320" data-href="https://developer.aliyun.com/article/703320" target="_blank" class="ne-link"><span class="ne-text">开发函数计算的正确姿势——移植 Express</span></a></li></ul><p id="u4e17cb87" class="ne-p"><span class="ne-text"></span></p><h4 id="FZ6b1"><span class="ne-text">多个域名路径与路径的访问</span></h4><p id="u787419bd" class="ne-p"><span class="ne-text">Express应用里面添加多个路由，然而在测试函数里面可以正常访问，在自定义域名url不能访问。</span></p><p id="u6b7df83e" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1642921933726-9ecb436a-ccd4-4f86-829a-05fe5ec65f76.png" width="1293" id="u61acac75" class="ne-image"></p><p id="u268883ac" class="ne-p"><span class="ne-text">改用泛解析</span><code class="ne-code"><span class="ne-text">/*</span></code><span class="ne-text">还是访问无效</span></p><p id="u3da63adc" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1642916657197-e43c510e-c901-4b62-aabf-206b75683c71.png" width="530" id="u90445c3a" class="ne-image"></p><p id="ub7bb7c87" class="ne-p"><span class="ne-text">解决：因为这个Express应用我是用自定义域名的一个路径为其根目录，所以项目中的路由配置都需要加上自定义域名下的路径。</span></p><p id="ue708fb06" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1642920228403-8369d2ba-5983-4581-b570-6eeee3555826.png" width="633" id="uf84b4416" class="ne-image"></p><h3 id="zyFic"><span class="ne-text">自定义域名</span></h3><div class="ne-quote"><p id="ue14eddd8" class="ne-p"><span class="ne-text">如果不自定义域名，则访问http触发的url是以下载文件的形式访问。</span></p></div><ul class="ne-ul"><li id="u102981b6"><a href="https://help.aliyun.com/document_detail/90763.html?spm=5176.fcnext.help.dexternal.a85778c8URjMtd" data-href="https://help.aliyun.com/document_detail/90763.html?spm=5176.fcnext.help.dexternal.a85778c8URjMtd" target="_blank" class="ne-link"><span class="ne-text">函数计算 &gt;高级功能 &gt;配置自定义域名 产品详情 配置自定义域名</span></a></li><li id="u11a0a674"><a href="https://blog.51cto.com/u_14031415/2306499" data-href="https://blog.51cto.com/u_14031415/2306499" target="_blank" class="ne-link"><span class="ne-text">函数计算搭建 Serverless Web 应用（二）- 自定义域名</span></a></li></ul><h3 id="y02bK"><span class="ne-text">自定义域名配置HTTPS</span></h3><ul class="ne-ul"><li id="ufbfef6b2"><a href="https://help.aliyun.com/document_detail/156645.html" data-href="https://help.aliyun.com/document_detail/156645.html" target="_blank" class="ne-link"><span class="ne-text">申请免费DV试用证书</span></a></li></ul><p id="u2f18854f" class="ne-p"><span class="ne-text">查看免费的SSL证书：</span></p><ul class="ne-ul"><li id="u8e319937"><a href="https://yundun.console.aliyun.com/?p=cas#/certExtend/free" data-href="https://yundun.console.aliyun.com/?p=cas#/certExtend/free" target="_blank" class="ne-link"><span class="ne-text">https://yundun.console.aliyun.com/?p=cas#/certExtend/free</span></a></li></ul><p id="ua9cc3222" class="ne-p"><a href="https://bluo.cn/" data-href="https://bluo.cn/" target="_blank" class="ne-link"></a></p></div>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
          <category> DevOps </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Nodejs基本使用和内置模块</title>
      <link href="/blog/gxh14f/"/>
      <url>/blog/gxh14f/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h2 id="jPu5t"><span class="ne-text">Node.js使用</span></h2><p id="ude9bec7a" class="ne-p"><span class="ne-text">Node.js环境说白了就和浏览器一样，用来运行js，node借助终端，浏览器借助app展示HTML文件来展示js功能。具体运行在js文件的所在文件目录下运行 </span><code class="ne-code"><span class="ne-text">node xx.js</span></code><span class="ne-text">即可。</span></p><p id="u651d3898" class="ne-p"><span class="ne-text">不过一般全局下载nodemon三方模块，其作用是当js文件被改动，终端会再次执行该js文件，后续模块处再讲。</span></p><p id="udfde50a5" class="ne-p"><span class="ne-text"></span></p><p id="u2579aadd" class="ne-p"><span class="ne-text">模块化开发分为两种：</span></p><ol class="ne-ol"><li id="u612c8573"><span class="ne-text">前端网页使用JavaScript外链</span></li><li id="ue5f5485d"><span class="ne-text">使用nodejs加载模块化开发构建</span></li></ol><p id="ud282aa20" class="ne-p"><span class="ne-text"></span></p><p id="uafd4d725" class="ne-p"><span class="ne-text">Node.js实际上是模块化开发，由以下两方面组成：</span></p><ol class="ne-ol"><li id="u17a2121f"><span class="ne-text">ECMAScript</span></li><li id="u186314d7"><span class="ne-text">Node的模块API（又分为内置模块和三方模块）</span></li></ol><h3 id="lfQzP"><span class="ne-text">node环境的一些特性</span></h3><p id="u38e53630" class="ne-p"><span class="ne-text">异步式I/O：提高效率，防止阻塞这种情况</span></p><p id="ubb6b1657" class="ne-p"><span class="ne-text">事件式编程：注意事件循环机制</span></p><h3 id="DktHv"><span class="ne-text">node模块化及其使用</span></h3><p id="ued3f4eb0" class="ne-p"><span class="ne-text">参考之前写的文章：</span><a href="https://www.yuque.com/wztlink1013/blog/psazge#FPo3f" data-href="https://www.yuque.com/wztlink1013/blog/psazge#FPo3f" target="_blank" class="ne-link"><span class="ne-text">https://www.yuque.com/wztlink1013/blog/psazge#FPo3f</span></a></p><h3 id="NtVpl" style="text-align: left"><span class="ne-text">process.env环境变量</span></h3><p id="u173ea7e9" class="ne-p"><span class="ne-text">nodejs的顶层对象process下的环境变量设置与使用</span></p><ul class="ne-ul"><li id="u080a734f"><span class="ne-text">参考：</span><a href="https://juejin.cn/post/6972466143445385223" data-href="https://juejin.cn/post/6972466143445385223" target="_blank" class="ne-link"><span class="ne-text">https://juejin.cn/post/6972466143445385223</span></a></li></ul><h3 id="sEPZO"><span class="ne-text">nodejs中的try...catch</span></h3><p id="u91e15a9b" class="ne-p"><span class="ne-text">写异常的捕获的时候，要时刻注意一些异步执行的代码，比如一种场景是try里面的代码是异步操作，那么再执行异步的时候，就已经执行了catch里面的报警语句了，学会查看捕获的目标代码是哪段。</span></p><p id="u74b6719d" class="ne-p"><span class="ne-text"></span></p><p id="u6f855426" class="ne-p"><span class="ne-text">具体参考：</span><a href="https://www.cnblogs.com/surfer/p/10291609.html" data-href="https://www.cnblogs.com/surfer/p/10291609.html" target="_blank" class="ne-link"><span class="ne-text">https://www.cnblogs.com/surfer/p/10291609.html</span></a></p><h2 id="gFFTO"><span class="ne-text">Node.js内置模块</span></h2><h3 id="XltiP"><span class="ne-text">全局对象global</span></h3><p id="07f0cf1cc1320a19ca5fd8c6bf9d1e1f" class="ne-p"><span class="ne-text">Node.js和之前学过的浏览器对象区分之就是，浏览器中全局对象是window，但是Node.js的全局对象是global（也可以不写、省略）。</span></p><p id="u7bcf8117" class="ne-p"><br></p><ul class="ne-ul"><li id="ufaa9c230"><span class="ne-text">process对象：关于进程的一个对象，也是global的属性之一，是一个和操作系统的简单接口。重点了解nextTick()函数，这个函数可以将事件循环设置一个任务，提高运行效率</span></li></ul><p id="5d524ac20f9f30a8882e3bfa05b35241" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1622768098753-4f933f75-ea23-41d9-80d3-c8dd46f2e123.png" width="457" id="jU6pu" class="ne-image"></p><ul class="ne-ul"><li id="u2a3558c1"><span class="ne-text">console对象：log在控制台中输出；error输出错误信息；trace输出错误信息调用栈（就是错在什么地方）</span></li></ul><ul class="ne-ul"><li id="6ec87b332d7805f01cc811abc4c3f120"><span class="ne-text">setTimeout()     设置超时</span><strong><span class="ne-text">定时器</span></strong></li><li id="26e9a03d59b9dc4f0cc709c7e08d1a91"><span class="ne-text">clearTimeout()  清除超时时定时器</span></li><li id="018d9cf8b1048488fc71c0182cb29f2c"><span class="ne-text">setInterval()      设置间歇</span><strong><span class="ne-text">定时器</span></strong></li><li id="e854f2fbf93acc3fea5490515cac7481"><span class="ne-text">clearInterval()   清除间歇定时器</span></li></ul><h3 id="Yi0DH"><span class="ne-text">http;fs;url;querystring;path模块</span></h3><p id="u7aeed8b6" class="ne-p"><span class="ne-text">参考：</span><a href="https://blog.guowenfh.com/2016/10/15/node-http" data-href="https://blog.guowenfh.com/2016/10/15/node-http" target="_blank" class="ne-link"><span class="ne-text">https://blog.guowenfh.com/2016/10/15/node-http</span></a></p><p id="u647c3ea8" class="ne-p"><span class="ne-text"></span></p><ul class="ne-ul"><li id="u2567b226"><span class="ne-text">http，原生创建web服务</span></li></ul><ul class="ne-ul"><li id="u6a740703"><span class="ne-text">url解析url，querystring处理url参数，搭配使用</span></li><li id="u6b4062f3"><span class="ne-text">fs模块用来读取文件、写入文件等</span></li><li id="u59e7e2df"><span class="ne-text">path路径操作，一般都是路径字符串拼接join，</span><code class="ne-code"><span class="ne-text">__dirname</span></code><span class="ne-text">当前目录名</span></li></ul><pre><code>/* * @Author: wztlink1013 * @Date: 2022-01-10 16:26:41 * @LastEditTime: 2022-01-10 19:49:43 * @Description: */let http = require('http')let url = require('url')let fs = require('fs')let queryString = require('querystring')<p>let server = http.createServer()<br>// 读取我们当前文件所在的目录下的 html 文件夹<br>let HtmlDir = __dirname + ‘/html/‘</p><p>server.on(‘request’, function (req, res) &#123;<br>  let urlObj = url.parse(req.url)<br>  console.log(‘【请求url信息】’, urlObj)<br>  let params = queryString.parse(urlObj.query)<br>  console.log(‘【url参数】’, JSON.stringify(params))</p><p>  switch (urlObj.pathname) &#123;<br>    case ‘/‘:<br>      //首页<br>      sendData(HtmlDir + ‘index.html’, req, res)<br>      break<br>    case ‘/user’:<br>      //用户首页<br>      sendData(HtmlDir + ‘user.html’, req, res)<br>      break<br>    default:<br>      //处理其他情况<br>      sendData(HtmlDir + ‘err.html’, req, res)<br>      break<br>  &#125;<br>&#125;)</p><p>/**</p><ul><li>读取html文件，响应数据，发送给浏览器</li><li>@param &#123;String&#125; file 文件路径</li><li>@param &#123;Object&#125; req request</li><li>@param &#123;Object&#125; res response 对象</li><li>/<br>function sendData(file, req, res) &#123;<br>fs.readFile(file, function (err, data) &#123;<br>  if (err) &#123;<pre><code>res.writeHead(404, &#123;  &#39;content-type&#39;: &#39;text/html;charset=utf-8&#39;,&#125;)res.end(&#39;&amp;lt;h1&amp;gt;你要找的页面不见了～&amp;lt;/h1&amp;gt;&#39;)</code></pre>  } else {<pre><code>res.writeHead(200, &#123;  &#39;content-type&#39;: &#39;text/html;charset=utf-8&#39;,&#125;)res.end(data)</code></pre>  }<br>})<br>}<br>server.listen(8888)<br>console.log(‘Server is running at <a href="http://127.0.0.1:8888/&#39;">http://127.0.0.1:8888/&#39;</a>)<br></code></pre><h3 id="oG39o"><span class="ne-text">util+chalk美化</span></h3><ul class="ne-tl"><li checked="true" id="7896925bf1161e320ccb9b5a02f94749"><span class="ne-text">util.inherits</span></li></ul><p id="52f3596b6ec4580aab2aa8e6b0170d3f" class="ne-p"><span class="ne-text">不过感觉这个已经没有多大必要了，这个是实现原型间继承的相关封装，但是现在ES6已经有了class的概念了（虽然底层还是之前那套），这个工具用的不多</span></p><ul class="ne-tl"><li checked="true" id="4614b24cd9ec95c3548092d2af20ed75"><span class="ne-text">util.inspect</span></li></ul><p id="3f8573b6edf04047f6d8ac2a9afe0d76" class="ne-p"><span class="ne-text">目的就是将对象转换为字符串，比如将错误信息更加美观的展示在控制台，就可以自定义，但是可以直接用chalk模块在实现这个美化控制台输出的工作。</span></p><pre><code>'use strict';</li></ul><p>const chalk = require(‘chalk’);</p><p>module.exports = &#123;<br>  info(…args) &#123;<br>    const prefix = chalk.green(‘[INFO]’);<br>    args.unshift(prefix);<br>    console.log.apply(console, args);<br>  &#125;,<br>  warn(…args) &#123;<br>    const prefix = chalk.yellow(‘[WARNING]’);<br>    args.unshift(prefix);<br>    console.log.apply(console, args);<br>  &#125;,<br>  error(…args) &#123;<br>    const prefix = chalk.red(‘[ERROR]’);<br>    args.unshift(prefix);<br>    console.log.apply(console, args);<br>  &#125;,<br>&#125;;<br></code></pre></p><pre><code>out.info(`Current yuque-hexo-lyrics version is $&#123;chalk.yellow(pkg.version)&#125;, and the latest version is $&#123;chalk.green(update.latest)&#125;. Please update!`);out.info('View more detail: https://github.com/wztlink1013/yuque-hexo-lyrics#changelog');</code></pre><h2 id="Hbxw1"><span class="ne-text">Node.js异步的解决策略</span></h2><p id="u5df15c0c" class="ne-p"><span class="ne-text">参考：</span></p><ul class="ne-ul"><li id="u1856099b"><a href="https://segmentfault.com/a/1190000019418510" data-href="https://segmentfault.com/a/1190000019418510" target="_blank" class="ne-link"><span class="ne-text">Node.js异步处理的各种写法</span></a></li></ul><ul class="ne-ul"><li id="u1b38d376"><span class="ne-text">传统的解决方案：async await等</span></li><li id="u4bc51a10"><span class="ne-text">嵌套使用</span></li></ul></div>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
          <category> Node.js </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Git Commit 的优化</title>
      <link href="/blog/dvkqhm/"/>
      <url>/blog/dvkqhm/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="u03591007" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1640570522971-b4d4a696-55c0-496b-a81d-deeb3e83a111.png" width="900" id="u4339158d" class="ne-image"></p><p id="u2d28a016" class="ne-p"><span class="ne-text"></span></p><p id="ubbfe2e60" class="ne-p"><span class="ne-text">前言：在使用git提交代码过程中，git commit的规范常不被大多数人注意，然而版本管理工具中，代码的提交规范对项目的后续维护有着很重要的作用。故本文从以下几个方面展开述说工程开发中git commit优化的几个工具：</span></p><ul class="ne-ul"><li id="ucc09ec77"><span class="ne-text">commitizen：简单的 commit 规范</span></li><li id="ufbab311b"><span class="ne-text">cz-conventional-changelog：执行会将项目npm发布新版本，并自动生成CHANGELOG.md文件</span></li><li id="u82705670"><span class="ne-text">commitlint：格式校验工具</span></li><li id="u419914ec"><span class="ne-text">husky：Git的钩子，在此作用为代码的提交规范和规范的校验</span></li><li id="u1fd40f0a"><span class="ne-text">standard-version：辅助 cz-conventional-changelog 打 version 等功能</span></li></ul><h3 id="Ttl7l"><span class="ne-text">commitizen和cz-conventional-changelog</span></h3><p id="u6c3b2139" class="ne-p"><span class="ne-text">下载cz-conventional-changelog commitizen</span></p><pre><code>cnpm i -D commitizen cz-conventional-changelog</code></pre><p id="u65da1f08" class="ne-p"><span class="ne-text">package.json添加配置信息</span></p><pre><code>&quot;scripts&quot;: &#123;  ...,    &quot;commit&quot;: &quot;git status &amp;&amp; git add . &amp;&amp; git-cz&quot;,  &#125;,,  &quot;config&quot;: &#123;    &quot;commitizen&quot;: &#123;      &quot;path&quot;: &quot;node_modules/cz-conventional-changelog&quot;    &#125;  &#125;</code></pre><p id="u37926c96" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1640510064091-ff75df38-e750-452f-8a16-6e6930f8505b.png" width="470.5" id="ua1b3c4e2" class="ne-image"></p><p id="u6b5ae494" class="ne-p"><span class="ne-text">成功提交之后</span></p><p id="u44e5300c" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1640510234956-c68282df-e059-4a8b-b118-0932250a7420.png" width="587" id="ue703c449" class="ne-image"></p><p id="uf283b9bd" class="ne-p"><br></p><h3 id="Ag1Il"><span class="ne-text">Commitlint及husky</span></h3><pre><code>cnpm i -D husky @commitlint/config-conventional @commitlint/cli</code></pre><p id="u14464e93" class="ne-p"><span class="ne-text">项目根目录新建commitlint.config.js</span></p><pre><code>module.exports = &#123;  extends: ['@commitlint/config-conventional']&#125;</code></pre><p id="u0d788f8b" class="ne-p"><span class="ne-text">package.json添加如下</span></p><pre><code># package.json<p>…,<br>&quot;husky&quot;: &#123;<br>    &quot;hooks&quot;: &#123;<br>      &quot;commit-msg&quot;: &quot;commitlint -E $HUSKY_GIT_PARAMS&quot;    &#125;<br>&#125;</p><p></code></pre></p><p id="u2563d439" class="ne-p"><span class="ne-text">执行命令 npm run commit</span></p><pre><code>1.Select the type of change that you're committing 选择改动类型 (&lt;type&gt;)<p>2.What is the scope of this change (e.g. component or file name)? 填写改动范围 (&lt;scope&gt;)</p><p>3.Write a short, imperative tense description of the change: 写一个精简的描述 (&lt;subject&gt;)</p><p>4.Provide a longer description of the change: (press enter to skip) 对于改动写一段长描述 (&lt;body&gt;)</p><p>5.Are there any breaking changes? (y/n) 是破坏性修改吗？默认n (&lt;footer&gt;)</p><p>6.Does this change affect any openreve issues? (y/n) 改动修复了哪个问题？默认n (&lt;footer&gt;)<br></code></pre></p><p id="u24586855" class="ne-p"><span class="ne-text">生成如下格式</span></p><pre><code>&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;&lt;BLANK LINE&gt;&lt;body&gt;&lt;BLANK LINE&gt;&lt;footer&gt;</code></pre><p id="uad666844" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1640515038577-11c2fbe0-0e7e-4ec4-8836-2c49553151c0.png" width="241.5" id="ub44884a1" class="ne-image"></p><p id="u915a5ef0" class="ne-p"><span class="ne-text">其中各自含义为</span></p><ul class="ne-ul"><li id="u6aada6e4"><span class="ne-text">scope 指 commit 的范围（哪些模块进行了修改）</span></li><li id="u54a150bc"><span class="ne-text">subject 指 commit 的简短描述</span></li><li id="u290da520"><span class="ne-text">body 指 commit 主体内容（长描述）</span></li><li id="u6a10d0a9"><span class="ne-text">footer 指 commit footer 信息</span></li><li id="ue4e2d962"><span class="ne-text">type 指当前 commit 类型，一般有下面几种可选类型：</span></li></ul><p id="u7e7f121a" class="ne-p"><br></p><pre><code># 主要typefeat:     增加新功能fix:      修复bug<h1 id="特殊type"><a href="#特殊type" class="headerlink" title="特殊type"></a>特殊type</h1><p>docs:     只改动了文档相关的内容<br>style:    不影响代码含义的改动，例如去掉空格、改变缩进、增删分号<br>build:    构造工具的或者外部依赖的改动，例如webpack，npm<br>refactor: 代码重构时使用<br>revert:   执行git revert打印的message</p><h1 id="暂不使用type"><a href="#暂不使用type" class="headerlink" title="暂不使用type"></a>暂不使用type</h1><p>test:     添加测试或者修改现有测试<br>perf:     提高性能的改动<br>ci:       与CI（持续集成服务）有关的改动<br>chore:    不修改src或者test的其余修改，例如构建过程或辅助工具的变动<br></code></pre></p><h3 id="yQnaq"><span class="ne-text">standard-version: 自动生成 CHANGELOG</span></h3><p id="u109f02e4" class="ne-p"><span class="ne-text">下载插件</span></p><pre><code>cnpm i --save-dev standard-version</code></pre><p id="u9bbba48e" class="ne-p"><span class="ne-text">package.json添加如下</span></p><pre><code>&#123;  &quot;scripts&quot;: &#123;    &quot;release&quot;: &quot;standard-version&quot;  &#125;&#125;</code></pre><p id="u453f6cbd" class="ne-p"><span class="ne-text">执行npm run release，在根目录会生成CHANGELOG.md文件</span></p><p id="u9255ba0b" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1640515612285-57b296de-7def-4ef9-b022-286ac9ef1ac2.png" width="554.5" id="u715cd9c7" class="ne-image"></p><h3 id="zi86S"><span class="ne-text">总package.json</span></h3><pre><code>&#123;  &quot;name&quot;: &quot;web-learn-notes&quot;,  &quot;version&quot;: &quot;1.1.0&quot;,  &quot;description&quot;: &quot;web学习笔记仓库&quot;,  &quot;main&quot;: &quot;index.js&quot;,  &quot;scripts&quot;: &#123;    &quot;commit&quot;: &quot;git status &amp;&amp; git add . &amp;&amp; git-cz&quot;,    &quot;release&quot;: &quot;standard-version&quot;,    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;  &#125;,  &quot;repository&quot;: &#123;    &quot;type&quot;: &quot;git&quot;,    &quot;url&quot;: &quot;git+https://github.com/wztlink1013/web-learn-notes.git&quot;  &#125;,  &quot;keywords&quot;: [    &quot;web&quot;,    &quot;学习&quot;,    &quot;笔记&quot;  ],  &quot;author&quot;: &quot;wztlink1013&quot;,  &quot;license&quot;: &quot;ISC&quot;,  &quot;bugs&quot;: &#123;    &quot;url&quot;: &quot;https://github.com/wztlink1013/web-learn-notes/issues&quot;  &#125;,  &quot;homepage&quot;: &quot;https://github.com/wztlink1013/web-learn-notes#readme&quot;,  &quot;devDependencies&quot;: &#123;    &quot;@commitlint/cli&quot;: &quot;^16.0.0&quot;,    &quot;@commitlint/config-conventional&quot;: &quot;^16.0.0&quot;,    &quot;commitizen&quot;: &quot;^4.2.4&quot;,    &quot;cz-conventional-changelog&quot;: &quot;^3.3.0&quot;,    &quot;husky&quot;: &quot;^7.0.4&quot;,    &quot;standard-version&quot;: &quot;^9.3.2&quot;  &#125;,  &quot;config&quot;: &#123;    &quot;commitizen&quot;: &#123;      &quot;path&quot;: &quot;node_modules/cz-conventional-changelog&quot;    &#125;  &#125;,  &quot;husky&quot;: &#123;    &quot;hooks&quot;: &#123;      &quot;commit-msg&quot;: &quot;commitlint -E $HUSKY_GIT_PARAMS&quot;    &#125;  &#125;&#125;</code></pre><p id="u6b0e1ffe" class="ne-p"><span class="ne-text"></span></p><ul class="ne-ul"><li id="u74ff70f8"><span class="ne-text">commitizen：自动化提示工具【git-cz】</span></li><li id="u0a52a6ab"><span class="ne-text">commitlint</span></li><li id="u91f3fde8"><span class="ne-text">commitlint-config-cz</span></li><li id="u4d8f7655"><span class="ne-text">commitlint-config-git-commit-emoji </span></li><li id="u50603afd"><span class="ne-text">conventional-changelog</span></li><li id="u1eace2ab"><span class="ne-text">conventional-changelog-cli</span></li><li id="ue7a39465"><span class="ne-text">cz-conventional-changelog</span></li><li id="uf78109fb"><span class="ne-text">cz-customizable</span></li><li id="u5c453180"><span class="ne-text">husky</span></li><li id="ucadc0dab"><span class="ne-text">lint-staged</span></li></ul></div>]]></content>
      
      
      <categories>
          
          <category> 计算机素养 </category>
          
          <category> Git和GitHub </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Vue-CLI搭建Vue3.x+TypeScript项目</title>
      <link href="/blog/blhxct/"/>
      <url>/blog/blhxct/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="u30ed37f0" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1640572147933-73df2b83-c74d-4391-a90c-c8006aba471e.png" width="900" id="u1d7f2957" class="ne-image"></p><p id="u19218eee" class="ne-p"><span class="ne-text"></span></p><p id="u661f3c9b" class="ne-p"><span class="ne-text">前言：前端工程化开发总结，使用Vue-CLI脚手架搭建Vue3.x + Typescript项目，整体项目的环境配置。</span></p><p id="uebe97bf6" class="ne-p"><br></p><h2 id="RxoB1"><span class="ne-text">下载安装Vue-CLI</span></h2><ul class="ne-ul"><li id="ucd9aee0e"><span class="ne-text">官方文档：</span><a href="https://cli.vuejs.org/zh/guide/" data-href="https://cli.vuejs.org/zh/guide/" target="_blank" class="ne-link"><span class="ne-text">Vue CLI 🛠️ Vue.js 开发的标准工具</span></a></li></ul><pre><code>npm install -g @vue/cli# oryarn global add @vue/cli# orcnpm install -g @vue/cli</code></pre><p id="uab298ae3" class="ne-p"><span class="ne-text">查看版本：</span><code class="ne-code"><span class="ne-text">vue --version</span></code></p><p id="ufc4cf0bc" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1640413980237-9582e32f-7515-40b8-80a7-f678456ac739.png" width="188.5" id="ua167aa8d" class="ne-image"></p><h2 id="CV67S"><span class="ne-text">创建项目</span></h2><p id="u343d2c0c" class="ne-p"><span class="ne-text">新建并初始化项目文件夹</span></p><pre><code>vue create vue3-cli-demo</code></pre><p id="uc0b5b0b6" class="ne-p"><span class="ne-text">选择最后一项自定义相关配置</span></p><p id="uf40af224" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1640414187756-6ebbf844-853d-4a66-b0d6-f401003c1fe8.png" width="234.5" id="ub11023b3" class="ne-image"></p><p id="u9158133b" class="ne-p"><span class="ne-text">全配置搭建测试</span></p><p id="ub5de8728" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1640414751376-5215b4c4-3e85-4be2-9ce8-6e304bd5b70f.png" width="403.5" id="ud9b0ef21" class="ne-image"></p><h2 id="ftrVD"><span class="ne-text">vue.config.js</span></h2><p id="u7f1cc1f4" class="ne-p"><span class="ne-text">Vue项目的配置文件（详查：</span><a href="https://cli.vuejs.org/zh/config/#vue-config-js" data-href="https://cli.vuejs.org/zh/config/#vue-config-js" target="_blank" class="ne-link"><span class="ne-text">https://cli.vuejs.org/zh/config/#vue-config-js</span></a><span class="ne-text">）</span></p><pre><code>module.exports = &#123;  // 打包的目录  outputDir: 'dist',   // 在保存时校验格式  lintOnSave: true,   // 生产环境是否生成 SourceMap  productionSourceMap: false,  devServer: &#123;    // 启动服务后是否打开浏览器    open: true,     // 错误信息展示到页面    overlay: &#123;       warnings: true,      errors: true    &#125;,    host: '0.0.0.0',    port: 8066, // 服务端口    https: false,    hotOnly: false,    // proxy: &#123; // 设置代理    //   '/api': &#123;    //     target: host,    //     changeOrigin: true,    //     pathRewrite: &#123;    //       '/api': '/',    //     &#125;    //   &#125;,    // &#125;,  &#125;,&#125;</code></pre><h2 id="iilBk"><span class="ne-text">[单元测试]Jest</span></h2><h3 id="esZbn"><span class="ne-text">Vue3.x+TypeScript项目下的jest单元测试</span></h3><p id="ue1eeafde" class="ne-p"><span class="ne-text">官网API：</span><a href="https://next.vue-test-utils.vuejs.org/api/" data-href="https://next.vue-test-utils.vuejs.org/api/" target="_blank" class="ne-link"><span class="ne-text">https://next.vue-test-utils.vuejs.org/api/</span></a></p><h4 id="ZD3XX"><span class="ne-text">jest.config.js</span></h4><p id="u4b92032a" class="ne-p"><span class="ne-text">项目搭建成功之后的默认配置如下：</span></p><pre><code>module.exports = &#123;  preset: '@vue/cli-plugin-unit-jest/presets/typescript-and-babel',  transform: &#123;    '^.+\\.vue$': 'vue-jest',  &#125;,&#125;</code></pre><p id="u53eadf7c" class="ne-p"><span class="ne-text">更改如下配置</span></p><pre><code>/* * @Author: wztlink1013 * @Date: 2021-12-25 14:49:37 * @LastEditTime: 2021-12-26 14:56:39 * @Description: */module.exports = &#123;  preset: '@vue/cli-plugin-unit-jest/presets/typescript-and-babel',  // 测试的文件类型  moduleFileExtensions: ['js', 'jsx', 'json', 'vue', 'ts', 'tsx'],  // 转化方式  transform: &#123;    '^.+\\.vue$': '&lt;rootDir&gt;/node_modules/vue-jest',    '.+\\.(css|styl|less|sass|scss|svg|png|jpg|ttf|woff|woff2)$':      '&lt;rootDir&gt;/node_modules/jest-transform-stub',    '^.+\\.jsx?$': '&lt;rootDir&gt;/node_modules/babel-jest',    '^.+\\.tsx?$': '&lt;rootDir&gt;/node_modules/ts-jest',  &#125;,  // 不进行匹配的目录  transformIgnorePatterns: ['&lt;rootDir&gt;/node_modules/'],  // 匹配哪些文件进行测试  testMatch: ['**/tests/unit/**/*.spec.[jt]s?(x)', '**/__tests__/*.[jt]s?(x)'],  // @符号 表示当前项目下的src  moduleNameMapper: &#123;    '^@/(.*)$': '&lt;rootDir&gt;/src/$1',  &#125;,  // 将保存的快照测试结果进行序列化，使得其更美观  snapshotSerializers: ['jest-serializer-vue'],&#125;</code></pre><h4 id="DMmo5"><span class="ne-text">单个文件的单元测试</span></h4><p id="u084e8f38" class="ne-p"><span class="ne-text">项目下运行单元测试命令 </span><code class="ne-code"><span class="ne-text">test:unit</span></code><span class="ne-text"> 默认测试所有测试文件，不能指定文件进行单元测试。</span></p><p id="u05bd7eb5" class="ne-p"><span class="ne-text"></span></p><p id="u2602c250" class="ne-p"><span class="ne-text">在本地下载全局jest然后指定命令去执行项目的单个文件单个测试</span></p><pre><code>cnpm install jest --global</code></pre><p id="uc0dae2b7" class="ne-p"><span class="ne-text">然后执行</span></p><pre><code>jest ./tests/unit/jestTest.spec.ts</code></pre><p id="u914c5b2e" class="ne-p"><span class="ne-text">或</span></p><pre><code>npx jest ./tests/unit/jestTest.spec.ts</code></pre><p id="u8f69b25c" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1640502745377-c5d57f26-13d6-4701-b7fd-aa1fb0b4312f.png" width="297.5" id="u261c3a42" class="ne-image"></p><h3 id="J5fSq"><span class="ne-text">空白项目下的jest单元测试</span></h3><h4 id="H1tup"><span class="ne-text">初始化npm插件项目</span></h4><pre><code>npm init -y</code></pre><h4 id="N2udI"><span class="ne-text">下载Jest和babel依赖</span></h4><pre><code>cnpm i @babel/core @babel/preset-env  jest@24.8.0 -D</code></pre><h4 id="hMIFh"><span class="ne-text">创建测试文件</span></h4><p id="u09ce622a" class="ne-p"><span class="ne-text">创建测试框架用的文件index.js和index.test.js两个文件</span></p><p id="ua1d89b6c" class="ne-p"><code class="ne-code"><span class="ne-text">index.js</span></code></p><pre><code>/* * @Descripttion: * @Date: 2021-12-07 20:08:15 * @LastEditTime: 2021-12-07 20:08:16 */export const add = (a, b) =&gt; &#123;  return a + b;&#125;;<p>export const reduce = (a, b) =&gt; &#123;<br>  return a - b;<br>&#125;;<br></code></pre></p><p id="ud972a05a" class="ne-p"><code class="ne-code"><span class="ne-text">index.test.js</span></code></p><pre><code>/* * @Descripttion: * @Date: 2021-12-07 20:08:31 * @LastEditTime: 2021-12-07 20:45:17 */import &#123; add, reduce &#125; from &quot;./index&quot;<p>// toBe 数字<br>test(&quot;测试add函数&quot;, () =&gt; &#123;<br>  expect(add(1, 2)).toBe(3)<br>&#125;)<br>test(&quot;测试add函数（函数功能出错===打印）&quot;, () =&gt; &#123;<br>  expect(add(1, 2)).toBe(4)<br>&#125;)<br>test(&quot;测试reduce函数&quot;, () =&gt; &#123;<br>  expect(reduce(3, 2)).toBe(1)<br>&#125;)</p><p></code></pre></p><p id="u5a934f21" class="ne-p"><span class="ne-text">不能运行是node环境不能直接使用es6语法，需要只用babel来转换</span></p><p id="uf28fecec" class="ne-p"><span class="ne-text">新建</span><code class="ne-code"><span class="ne-text">.babelrc</span></code><span class="ne-text">文件</span></p><pre><code>// .babelrc&#123;    &quot;presets&quot;: [            [&quot;@babel/preset-env&quot;, &#123;                &quot;targets&quot;: &quot;&gt; 5%&quot;            &#125;]    ]&#125;</code></pre><h4 id="uA7SI"><span class="ne-text">运行</span></h4><p id="u01cd9433" class="ne-p"><span class="ne-text">运行npm run test 就可以测试了</span></p><p id="u63633d80" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1638881167559-731c4af0-07c1-4d1b-b3d2-9273ab358fcb.png" width="826.5" id="Bt95b" class="ne-image"></p><h3 id="lociY"><span class="ne-text">Jest API及相关命令</span></h3><ul class="ne-ul"><li id="u70974d24"><span class="ne-text">官方文档：</span><a href="https://jestjs.io/zh-Hans/docs/getting-started" data-href="https://jestjs.io/zh-Hans/docs/getting-started" target="_blank" class="ne-link"><span class="ne-text">https://jestjs.io/zh-Hans/docs/getting-started</span></a></li></ul><p id="u645cac91" class="ne-p"><span class="ne-text">相关教程：</span></p><ul class="ne-ul"><li id="uab34ba30"><a href="https://juejin.cn/post/6844904114753634317" data-href="https://juejin.cn/post/6844904114753634317" target="_blank" class="ne-link"><span class="ne-text">Jest前端自动化测试入门</span></a></li><li id="u3fc45678"><a href="https://xie.infoq.cn/article/f743bf48dc9ea09e5cbd7285c" data-href="https://xie.infoq.cn/article/f743bf48dc9ea09e5cbd7285c" target="_blank" class="ne-link"><span class="ne-text">搭建基本 Jest 测试框架，解读覆盖率实现原理</span></a></li><li id="ud641ceff"><a href="https://juejin.cn/post/6844904082516377607" data-href="https://juejin.cn/post/6844904082516377607" target="_blank" class="ne-link"><span class="ne-text">vue项目搭建jest单元测试及采坑</span></a></li><li id="ua6daf3d6"><a href="https://cloud.tencent.com/developer/article/1602142" data-href="https://cloud.tencent.com/developer/article/1602142" target="_blank" class="ne-link"><span class="ne-text">Vue-Test-Utils + Jest 单元测试入门与实践</span></a></li><li id="ua2ad2660"><span class="ne-text">eslint就可以使用：</span><a href="https://www.npmjs.com/package/eslint-plugin-jest" data-href="https://www.npmjs.com/package/eslint-plugin-jest" target="_blank" class="ne-link"><span class="ne-text">eslint-plugin-jest</span></a></li></ul><h4 id="nASi3"><span class="ne-text">Jest API</span></h4><ul class="ne-ul"><li id="u64eb9bc4"><code class="ne-code"><span class="ne-text">test()</span></code><span class="ne-text">类似请求后端接口一样，请求成功或失败的判断</span></li><li id="u2e2cd57b"><code class="ne-code"><span class="ne-text">expect()</span></code><span class="ne-text">则是判断和预期的值是否一样，然后执行相应的操作</span></li><li id="ud2ddc9b0"><code class="ne-code"><span class="ne-text">toBe()</span></code><span class="ne-text">就是写入预期值来判断是否和自己写的代码值是否一样</span></li><li id="u3251118b"><code class="ne-code"><span class="ne-text">describe</span></code><span class="ne-text"> 描述, decribe会形成一个作用域</span></li><li id="u74302817"><code class="ne-code"><span class="ne-text">it</span></code><span class="ne-text"> 断言</span></li></ul><h4 id="nr2aO"><span class="ne-text">jest --coverage</span></h4><p id="u966bb14b" class="ne-p"><span class="ne-text">查看覆盖率命令</span></p><p id="uafec70e4" class="ne-p"><span class="ne-text">该命令可以可视化展示，也可以在浏览器打开可视化结果网页</span></p><p id="ub8b54fff" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1640503326529-c0e50682-a7d0-4e47-9be3-df6c5e71b8e3.png" width="581.5" id="u1305df8b" class="ne-image"></p><h2 id="RCTVi"><span class="ne-text">[单元测试]e2e-cypress</span></h2><p id="u7eaa1147" class="ne-p"><span class="ne-text">插眼：日后再深入了解</span></p><p id="u9c33b81a" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1640504518665-55a6bd16-bb69-411d-bc9b-de4b6e2db2cc.jpeg" width="79" id="nTdFS" class="ne-image"></p><p id="u6b49e626" class="ne-p"><span class="ne-text">Vue官方插件地址：</span></p><ul class="ne-ul"><li id="u89b7da36"><span class="ne-text"></span><a href="https://www.npmjs.com/package/@vue/cli-plugin-e2e-cypress" data-href="https://www.npmjs.com/package/@vue/cli-plugin-e2e-cypress" target="_blank" class="ne-link"><span class="ne-text">https://www.npmjs.com/package/@vue/cli-plugin-e2e-cypress</span></a></li></ul><p id="uc4e81d13" class="ne-p"><span class="ne-text">参考教程：</span></p><ul class="ne-ul"><li id="u06cfad14"><a href="https://www.jianshu.com/p/459612488233" data-href="https://www.jianshu.com/p/459612488233" target="_blank" class="ne-link"><span class="ne-text">Vue项目采用Cypress做e2e自动化测试，手把手一撸到底</span></a></li></ul><h2 id="wYveI"><span class="ne-text">Vue3+TypeScript项目搭建过程中报错 </span></h2><h3 id="pirTY"><span class="ne-text">VSCode插件ESLint+Prettier+vetur代码格式化冲突</span></h3><p id="ue95c4747" class="ne-p"><span class="ne-text">这三者是代码校验和格式化的插件，当vue3.x项目搭建成功之后</span></p><p id="u603aa0dd" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1640422446727-53aab258-0454-486d-b2e7-f4c181c7b404.png" width="285.5" id="W9mzl" class="ne-image"></p><p id="u799823b7" class="ne-p"><span class="ne-text">该行配置需要注释，不然代码保存之后，会经过Prettier和vetur两者之间的来回格式化顺序，导致不能正常格式化。</span></p><p id="u67f0d11d" class="ne-p"><span class="ne-text"></span></p><p id="u43374fc9" class="ne-p"><span class="ne-text">具体矛盾原因：</span></p><ul class="ne-ul"><li id="u13878e26"><a href="https://zhuanlan.zhihu.com/p/101241781" data-href="https://zhuanlan.zhihu.com/p/101241781" target="_blank" class="ne-link"><span class="ne-text">解决vscode eslint与prettier冲突</span></a></li><li id="u6d1958fd"><a href="https://zhuanlan.zhihu.com/p/347339865" data-href="https://zhuanlan.zhihu.com/p/347339865" target="_blank" class="ne-link"><span class="ne-text">VSCode中ESLint、Prettier 配置冲突问题原因及解决方案</span></a></li><li id="ue1e225a1"><a href="https://www.cnblogs.com/wangpenghui522/p/13727990.html" data-href="https://www.cnblogs.com/wangpenghui522/p/13727990.html" target="_blank" class="ne-link"><span class="ne-text">VSCode-Prettier和ESLint如何和睦共处? </span></a></li><li id="u43160271"><a href="https://cloud.tencent.com/developer/article/1802491" data-href="https://cloud.tencent.com/developer/article/1802491" target="_blank" class="ne-link"><span class="ne-text">Vue 基于VSCode结合Vetur+ESlint+Prettier统一Vue代码风格</span></a></li></ul><p id="u7face581" class="ne-p"><span class="ne-text"></span></p><ul class="ne-ul"><li id="u433654bc"><span class="ne-text">Prettier插件：一定要留，能保存所有文件，按照自己规则进行格式化</span></li><li id="u411ced4f"><span class="ne-text">ESLint插件</span></li><li id="u7d95cb10"><span class="ne-text">vetur插件</span></li><li id="u81822d9f"><span class="ne-text">Vue项目中的prettier插件</span></li><li id="u17721640"><span class="ne-text">Vue项目中的eslint插件</span></li><li id="u82fcf70a"><span class="ne-text">Vue项目中的eslint的各个子插件</span></li></ul><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="u277c5a88"><span class="ne-text">eslint-plugin-prettier：这个就是typescript项目中上述冲突的缘由</span></li><li id="u77b8d609"><span class="ne-text">eslint-config-prettier</span></li><li id="u48b7feb0"><span class="ne-text">……</span></li></ul></ul><h3 id="i6BcM"><span class="ne-text">Error: Cannot find module 'vue-loader-v16/package.json'</span></h3><p id="ub55684c9" class="ne-p"><span class="ne-text">在导入Vue3 + TypeScript的项目</span></p><ol class="ne-ol"><li id="u1a42696e"><span class="ne-text">升级npm</span></li></ol><p id="u83a95ccd" class="ne-p"><span class="ne-text">使用cnpm的也要升级一下cnpm</span></p><pre><code>cnpm i -g cnpm</code></pre><ol start="2" class="ne-ol"><li id="uc1f116bd"><span class="ne-text">重新安装node_modules依赖包</span></li></ol><pre><code>cnpm i // 重新安装</code></pre><ol start="3" class="ne-ol"><li id="u1e7e4d28"><span class="ne-text">重新下载</span></li></ol><pre><code>cnpm i -D vue-loader-v16</code></pre><h3 id="LwYwy"><span class="ne-text">[vue/no-multiple-template-root]The template root requires exactly one element.eslint-plugin-vue</span></h3><p id="u59224a56" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1640357960271-5a2b291c-9a75-45eb-90c7-181a081cd1b3.png" width="524" id="LDxro" class="ne-image"></p><h3 id="JDa5v"><span class="ne-text">找不到模块“&quot;@aomao/engine&quot;”或其相应的类型声明。ts(2307)</span></h3><div data-type="danger" class="ne-alert"><p id="ub4ceac5d" class="ne-p"><span class="ne-text">报错信息</span></p></div><pre><code>找不到模块“&quot;@aomao/engine&quot;”或其相应的类型声明。ts(2307)</code></pre><pre><code>模块“&quot;@aomao/engine&quot;”没有导出的成员“PluginEntry”。ts(2305)</code></pre><div data-type="success" class="ne-alert"><p id="uac4b1750" class="ne-p"><span class="ne-text">按照网上找的一些方法，都无法解决这个问题</span></p><p id="u1c0d7a79" class="ne-p"><span class="ne-text">重启可以解决，插件用的太多===太卡顿</span></p></div><h3 id="R8rjd"><span class="ne-text">'vue/comment-directive' — error in the end of public/index.html just after vue-cli installation</span></h3><p id="uc3e1dea7" class="ne-p"><span class="ne-text">public文件夹次啊的index.html文件末尾会有该报错，解决办法就是配置相关rule</span></p><p id="udac104c0" class="ne-p"><a href="https://github.com/vuejs/eslint-plugin-vue/issues/1355" data-href="https://github.com/vuejs/eslint-plugin-vue/issues/1355" target="_blank" class="ne-link"><span class="ne-text">https://github.com/vuejs/eslint-plugin-vue/issues/1355</span></a></p><h3 id="JvlUf"><span class="ne-text">Delete `␍`eslintprettier/prettier</span></h3><p id="u7ec44cd7" class="ne-p"><span class="ne-text">将代码push到GitHub仓库，新拉取下来，文件的每行代码会有此报错</span></p><p id="u10654bf9" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1644376958819-fecf2dc0-76f0-4a31-b2a8-269dd345223d.png" width="536" id="ua5af1e6f" class="ne-image"></p><p id="ua74cd873" class="ne-p"><span class="ne-text"></span></p><p id="u33be619f" class="ne-p"><span class="ne-text">报错原因：文本文件的换行符不一致</span></p><p id="uaf340915" class="ne-p"><span class="ne-text">具体参考：</span><a href="https://juejin.cn/post/6844904069304156168#heading-6" data-href="https://juejin.cn/post/6844904069304156168#heading-6" target="_blank" class="ne-link"><span class="ne-text">https://juejin.cn/post/6844904069304156168#heading-6</span></a></p><p id="ue63cf88e" class="ne-p"><span class="ne-text">解决办法：</span></p><ol class="ne-ol"><li id="u200bacee"><span class="ne-text">【治标】如果只有少个文件，将vscode右下角处改为LF即可</span></li></ol><p id="u56edc332" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1644377438548-8db15f94-e644-43ac-bad4-2f4ce86eb274.png" width="449" id="u08d40637" class="ne-image"></p><ol start="2" class="ne-ol"><li id="u841e15fc"><span class="ne-text">【治本】在windows环境下，全局关掉转换行</span></li></ol><pre><code>git config --global core.autocrlf false</code></pre><p id="u4f4aac5e" class="ne-p"><span class="ne-text">然后再将刚刚拉取到本地的项目删掉，重新从GitHub拉取到本地，就不会出现该报错了</span></p><ol start="3" class="ne-ol"><li id="uf14bc6be"><span class="ne-text">另外，在vscode设置中设置如下，可以达到新建文件就是LF转换行的效果了</span></li></ol><p id="u33b96b28" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1644377676559-12ee984b-e189-4dcf-8a72-59e37198b974.png" width="362" id="u84528446" class="ne-image"></p><p id="uc6e546f7" class="ne-p"><br></p><h2 id="S9yt5"><span class="ne-text">vue3 + vite + typescript脚手架的安装</span></h2><p id="u8b2c7bc4" class="ne-p"><span class="ne-text" style="color: rgb(36, 41, 47); font-size: 14px">参考：</span><a href="https://juejin.cn/post/7051565418460217375" data-href="https://juejin.cn/post/7051565418460217375" target="_blank" class="ne-link"><span class="ne-text">https://juejin.cn/post/7051565418460217375</span></a></p><ul class="ne-ul"><li id="uc7cc72c2"><span class="ne-text" style="color: rgb(36, 41, 47); font-size: 14px">官网：安装vue和vue-cli</span><span class="ne-text" style="color: rgb(36, 41, 47); font-size: 14px"> </span><a href="https://v3.cn.vuejs.org/guide/installation.html" data-href="https://v3.cn.vuejs.org/guide/installation.html" target="_blank" class="ne-link"><span class="ne-text">https://v3.cn.vuejs.org/guide/installation.html</span></a></li><li id="u0e36ba39"><span class="ne-text" style="color: rgb(36, 41, 47); font-size: 14px">Vite + Vue3 + TypeScript 简单的项目骨架搭建</span></li><li id="u343654f1"><span class="ne-text" style="color: rgb(36, 41, 47); font-size: 14px">使用Vite构建项目</span></li><li id="ue6bb56d8"><span class="ne-text" style="color: rgb(36, 41, 47); font-size: 14px">修改 Vite 配置文件：需要下载path包，以便于对@符号的使用</span></li><li id="u02e6a85b"><span class="ne-text" style="color: rgb(36, 41, 47); font-size: 14px">规范目录结构</span></li><li id="u66608672"><span class="ne-text" style="color: rgb(36, 41, 47); font-size: 14px">下载vue-router</span></li></ul></div>]]></content>
      
      
      <categories>
          
          <category> 计算机素养 </category>
          
          <category> 环境搭建 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>炒青菜</title>
      <link href="/essay/cook_greens/"/>
      <url>/essay/cook_greens/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><ul class="ne-ul"><li id="u0f180e9e"><span class="ne-text">洗菜-切菜</span></li><li id="u75cb97e5"><span class="ne-text">倒如适量香油</span></li></ul><div class="ne-quote"><p id="uf3aacd3a" class="ne-p"><span class="ne-text">然后倒入部分猪油（可选）</span></p><p id="u832f287b" class="ne-p"><span class="ne-text">如果是做鱼之类的，就不要放入猪油了</span></p></div><ul class="ne-ul"><li id="u867e8c85"><span class="ne-text">待油烧入适量时刻，先将菜根先放入锅中，菜叶等菜根烧一会再放</span></li></ul><div class="ne-quote"><p id="u49432d79" class="ne-p"><span class="ne-text">炒的时候可以适量拍打菜根，以便融入配料等副菜</span></p></div><ul class="ne-ul"><li id="ua57e170b"><span class="ne-text">青菜炒至适量时刻，将盐等配料放入锅中</span></li><li id="u32e5e1aa"><span class="ne-text">不一会就可以将其乘入盘中</span></li></ul><p id="u42b5732a" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2021/gif/1484158/1639714281103-f3661a3d-07fa-4f5b-898f-992d9d9d45af.gif" width="48" id="hbB5J" class="ne-image"></p></div>]]></content>
      
      
      <categories>
          
          <category> 料理 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>炒鸡肉</title>
      <link href="/essay/cook_chicken/"/>
      <url>/essay/cook_chicken/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><ul class="ne-ul"><li id="u5bd9b07e"><span class="ne-text">切块，炒</span></li></ul><div class="ne-quote"><p id="u602b9986" class="ne-p"><span class="ne-text">目的就是把鸡肉身体里面的水分去掉</span></p></div><p id="ubbfbe04a" class="ne-p"><span class="ne-text">具体的操作步骤：</span></p><p id="u7e1f8b56" class="ne-p"><span class="ne-text">① 倒入香油，待香油表面的一层油花去掉，再将鸡肉导入</span></p><p id="u8051678a" class="ne-p"><span class="ne-text">② 炒到鸡肉大部分水分已经去掉了，放入生姜，小米椒，放盐……</span></p><p id="u60f18ddb" class="ne-p"><span class="ne-text">（此时放盐，只是以便待会炖好可以直接吃，也可以放在待会放的）</span></p><ul class="ne-ul"><li id="ua47473f0"><span class="ne-text">锅炖</span></li></ul><p id="u4042d85e" class="ne-p"><span class="ne-text">锅下面放入适量的水，不能过多，不然溢到鸡肉里面就不能吃了</span></p><p id="ucd693c30" class="ne-p"><span class="ne-text">同时还需要用个小盖子将鸡肉盖住，这样一面汽水浸入鸡肉里面，也不能吃</span></p><p id="ua7fc2bbb" class="ne-p"><span class="ne-text"></span></p><p id="ub4b0bb70" class="ne-p"><span class="ne-text">这个时候理论上是可以直接吃的，但是如果自己觉得荤味太重，也可以再拿出来，再放入一点点香油小炒小烩</span></p><p id="u92332ea5" class="ne-p"><br></p><p id="ufe3269cc" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1639711573828-ce9f3075-2dbc-465e-921f-121f56bb00e0.jpeg" width="60" id="YodIL" class="ne-image"></p></div>]]></content>
      
      
      <categories>
          
          <category> 料理 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>一个梦——害怕</title>
      <link href="/essay/ifuuic/"/>
      <url>/essay/ifuuic/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="u0c684b80" class="ne-p"><strong><span class="ne-text">被误会</span></strong></p><p id="u5259f535" class="ne-p"><span class="ne-text">两个同事和一个老人，那个老人迷迷糊糊 缓缓 进到我们房子里面，然后不知道一直在干嘛，最后是我的室友A不知道哪来的一把特别特别锋利的刀无意间割伤那位老人的大腿，导致大量失血，最终死了</span></p><p id="ua367cb5b" class="ne-p"><span class="ne-text">然后第二天，有班主任来追究这件事，我不知道怎么的，对质的时候，我正好不在，他们两个被叫去对质，听别人说，他们对质的时候说的答案不一样，反正最后，被误会成是我，我有理说不清，那个老人不是我杀的，但是我的内心又不想说是那个室友做的，于是一直耽搁，我的心里很矛盾，最终，他们统一和班主任说，看到我在那位老人面前用刀…我不知道怎么的，明明不是我，可我在逃避，我不知道在怕什么，可能是全世界都以为我是凶手，可我不是，我争辩不了，那种无力感，那种委屈，那种害怕…</span></p><p id="u9a1faadb" class="ne-p"><span class="ne-text"></span></p><p id="uc1511c19" class="ne-p"><strong><span class="ne-text">妈妈失忆</span></strong></p><p id="u187f7768" class="ne-p"><span class="ne-text">一切的落魄，我又回到那个房子里，又有一个老人走到我面前，那是我妈妈，我不知道妈妈怎么就突然瞬间变老了，样子还是一样，但是已经失忆了，我妈妈不记得我了…我哭，一直哭，我一直说，我是你儿子呀，可是我在我妈妈面前就是一个陌生人，我好伤心，一直哭，我妈妈还对房子外面的路过的街坊邻居说，你们看，这个孩子真懂事，而我呆呆地站在那，伤心到形神分离…</span></p><p id="ud91394e3" class="ne-p"><span class="ne-text"></span></p><p id="ua77c9a07" class="ne-p"><span class="ne-text"></span></p><p id="u6793d2ad" class="ne-p"><span class="ne-text">梦醒了，脚在抽搐，抽搐的那块被子特别冰凉，原来是没关窗户，十二月的冷风吹进来了……</span></p><p id="u387f48f1" class="ne-p"><span class="ne-text">2021.12.03  07:04</span></p><p id="u8eec700e" class="ne-p"><span class="ne-text"></span></p><p id="u6867dcf4" class="ne-p"><span class="ne-text"></span></p><p id="u83c1bde3" class="ne-p"><span class="ne-text">后记：</span></p><p id="u1c39052d" class="ne-p"><span class="ne-text">一个人最失意甚至死亡的时候，脑子里面浮现的，其实是亲人，在小的时候，有次和小伙伴去湖里面游泳，那是我第一次下水游泳，当时差点淹死，我至今都清楚地记得我倒在水里面的时候，一直呛水那会，脑子里面想的其实就是家里厨房，客厅，还有熟悉的我妈叫我吃饭那声音……</span></p><p id="u8e4196db" class="ne-p"><span class="ne-text"></span></p><p id="uff11e36a" class="ne-p"><span class="ne-text">很多人说我很冷，可我其实不是，相处之后，我觉得我还是比较重感情的，我挺感谢这个梦的…</span></p><p id="u17e1677c" class="ne-p"><span class="ne-text"></span></p><p id="ufe496009" class="ne-p"><span class="ne-text">人其实都有两面，一面是原本流露真情的自我，一面是这个世界这个周围环境甚至自身经历所塑造的自己，可能沉稳，冷静，等等这些都是他人所看到的，然而人的还有一面，就像迟子建笔下的杨二嫂一般，将丈夫的尸体锁在冰柜，深夜独自买醉，因为这可能就是对自我感情的一种救赎，因为到了白天，当周围不再是黑夜，人们不再抒情，用坚强的外壳去跻身于这个不好不坏，不完美却也没有大缺陷的世界中…</span></p><p id="ua3c54a2a" class="ne-p"><span class="ne-text"></span></p><p id="u6a31b4e8" class="ne-p"><span class="ne-text"></span></p><p id="ua2c293ac" class="ne-p"><span class="ne-text"></span></p><p id="u572d5056" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1638506128821-fd0914a3-839b-4cb9-9e0b-a79b4d557a1e.jpeg" width="1176" id="u8c4a114e" class="ne-image"></p></div>]]></content>
      
      
      <categories>
          
          <category> 异世界 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Nginx常用命令</title>
      <link href="/blog/kz2il6/"/>
      <url>/blog/kz2il6/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><pre><code>cd e:\Nginxcd nginx-1.16.1start nginxtasklist /fi &quot;imagename eq nginx.exe&quot;     //查看进程nginx -t -c ./conf/nginx.conf   //检查配置文件nginx -s reload  //重启服务nginx -s stop   //快速停止nginx -s quit   //完整有序的停止<p>server &#123;<br>  listen       80;<br>  server_name  tf.local.msshuo.cn;<br>  #server_name  kf.local.msshuo.cn;</p><p>  #charset koi8-r;</p><p>  #access_log  logs/host.access.log  main;</p><p>  location / &#123;<br>    root   E:\mly\ad_dist;<br>    #root   E:\mly\kf_dist;<br>    index  index.html index.htm;<br>  &#125;</p><p>  #error_page  404              /404.html;</p><h1 id="redirect-server-error-pages-to-the-static-page-50x-html"><a href="#redirect-server-error-pages-to-the-static-page-50x-html" class="headerlink" title="redirect server error pages to the static page /50x.html"></a>redirect server error pages to the static page /50x.html</h1><h1 id=""><a href="#" class="headerlink" title=""></a></h1><p>  error_page   500 502 503 504  /50x.html;<br>  location = /50x.html &#123;<br>    root   html;<br>  &#125;</p><p></code></pre></p></div>]]></content>
      
      
      <categories>
          
          <category> 计算机素养 </category>
          
          <category> 环境搭建 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>14种设计模式</title>
      <link href="/blog/figfyg/"/>
      <url>/blog/figfyg/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h3 id="xAor6"><span class="ne-text">一、单例模式</span></h3><p id="u378e1e12" class="ne-p"><span class="ne-text">类只有一个实例，像BOM这个全局对象就是单例模式，还有单独创建一个对象字面量，也是单例模式，下面讲述单例模式的实现：</span></p><pre><code>class Aoteman &#123;  constructor(name, age) &#123;    this.name = name    this.age = age  &#125;  // 实现单例模式  static getInstance(name, age) &#123;    if (!this.instance) &#123;      this.instance = new Aoteman(name, age)    &#125;    return this.instance  &#125;<p>  Ability = data =&gt; &#123;<br>    console.log(this.name + ‘ can ‘ + data)<br>  &#125;<br>&#125;</p><p>const dijia = new Aoteman(‘dijia’, ‘2022’)<br>console.log(dijia.name)<br>dijia.Ability(‘X-ray’)</p><p>let tailuo = Aoteman.getInstance(‘tailuo’, ‘1990’)<br>console.log(tailuo.name)<br>tailuo.Ability(‘Y-ray’)<br>let aidi = Aoteman.getInstance(‘aidi’, ‘1990’)<br>console.log(aidi.name)<br>tailuo.Ability(‘Z-ray’)<br>console.log(‘———————‘)<br>console.log(dijia === tailuo)<br>console.log(tailuo === aidi)<br></code></pre></p><p id="ufa71f4fa" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1648729211906-1aa126ab-8ccc-4447-9037-1e1602122a19.png" width="380.8333182003769" id="u5e96591e" class="ne-image"></p><p id="u53d5a710" class="ne-p"><span class="ne-text">上面的方式实现，只能调用getInstance方法才能创建单例，如果用户再次使用new来创建实例，还是不可行，所以还需要对上述予以工厂模式封装：</span></p><pre><code>const singleFactory = (...rest) =&gt; &#123;  return Aoteman.getInstance(...rest)&#125;</code></pre><p id="u6bc8bfaf" class="ne-p"><span class="ne-text">使用场景：发布订阅场景，我们需要在一个地方进行订阅，在另一个地方进行发布，这样就需要保证在不同文件中访问到的是同一个实例。</span></p><pre><code>class PubSub &#123;  constructor() &#123;    this.listeners = &#123;&#125;  &#125;  publish(event, data) &#123;    if (!this.listeners[event]) &#123;      return;    &#125;    this.listeners[event].forEach(listener =&gt; &#123;      listener(data);    &#125;)  &#125;  subscribe(event, callback) &#123;    if (!this.listeners[event]) &#123;      this.listeners[event] = []    &#125;    this.listeners[event].push(callback);  &#125;&#125;export default new PubSub</code></pre><p id="u1b2d8d0d" class="ne-p"><span class="ne-text"></span></p><h3 id="VPoDB"><span class="ne-text">二、工厂模式</span></h3><ul class="ne-ul"><li id="ud8b852d2"><span class="ne-text" style="color: rgb(36, 41, 47); font-size: 14px">优点：一个工厂创建同一类对象，更好的归类创建</span></li><li id="u6a38822c"><span class="ne-text" style="color: rgb(36, 41, 47); font-size: 14px">抽象工厂模式的缺点就是，如果需要增加新的产品，比如要生产可乐周边玩偶，这就需要对原有的抽象工厂接口进行改造，不符合开闭原则。</span></li></ul><pre><code>function CreateElement(type) &#123;  switch (type) &#123;    case 'Input':      return new Input()      break;    case 'Div':      return new Div()      break;    default:      throw new Error('无当前产品')  &#125;&#125;<p>function Input() &#123;<br>  return document.createElement(‘input’)<br>&#125;</p><p>function Div() &#123;<br>  return document.createElement(‘div’)<br>&#125;</p><p>//test<br>const input = new CreateElement(‘Input’);<br>const div = new CreateElement(‘DIV’);<br>console.log(input)      // input<br>console.log(div)        // div<br></code></pre></p><pre><code>class User &#123;  constructor(name) &#123;    this.name = name  &#125;  SetRoleType(type) &#123;    switch (type) &#123;      case 'Admin':        return new UserAdmin()        break      case 'Member':        return new UserMember()        break      default:        throw new Error('Set Error!')    &#125;  &#125;  GetName = () =&gt; &#123;    console.log('this name is: ' + this.name)  &#125;&#125;class UserAdmin extends User &#123;  constructor(name) &#123;    super(name)    this.name = name  &#125;  RoleInfo = () =&gt; &#123;    console.log('Type is Admin ')  &#125;&#125;const zhangsan = new User('zhangsan')zhangsan.GetName()zhangsan.SetRoleType('Admin').RoleInfo()</code></pre><p id="u218de333" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1648731190936-4c3eb68a-b66b-486c-bd51-2d7137cb592b.png" width="245.8333235647947" id="u21180cde" class="ne-image"></p><h3 id="zP5cf"><span class="ne-text">建造者模式</span></h3><pre><code>/** * 建造者模式 */<p>/* 建造者 */<br>function ComputerBuilder(brand) &#123;<br>  this.brand = brand<br>&#125;</p><p>ComputerBuilder.prototype.buildCPU = function (type) &#123;<br>  switch (type) &#123;<br>    case ‘inter’:<br>      this.cpu = ‘inter处理器’<br>      break;<br>    case ‘AMD’:<br>      this.cpu = ‘AMD处理器’<br>      break;<br>  &#125;</p><p>  return this<br>&#125;</p><p>ComputerBuilder.prototype.buildMemory = function (mSize) &#123;<br>  thgis.mSize = ‘内存’ + mSize + ‘G’<br>  return this<br>&#125;</p><p>ComputerBuilder.prototype.buildDisk = function (dSize) &#123;<br>  this.dSize = ‘硬盘’ + dSize + ‘G’<br>  return this<br>&#125;</p><p>/* 厂家，负责组装 */<br>function computerDirector(brand, type, mSize, dSize) &#123;<br>  const _computer = new ComputerBuilder(brand)<br>  _computer.buildCPU(type)<br>    .buildMemory(mSize)<br>    .buildDisk(dSize)</p><p>  return _computer<br>&#125;</p><p>//test<br>const com = computerDirector(‘联想’, ‘inter’, 16, 500);<br>console.log(com); // ComputerBuilder &#123;brand: &quot;联想&quot;, cpu: &quot;inter 处理器&quot;, mSize: &quot;内存16G&quot;, dSize: &quot;硬盘500G&quot;&#125;<br></code></pre></p><p id="ue1c744d7" class="ne-p"><span class="ne-text"></span></p><h3 id="HQMCN"><span class="ne-text">代理模式</span></h3><pre><code>/** * 代理模式 */<p> /* 目标 */<br>function sendMsg(msg) &#123;<br>  console.log(msg)<br>&#125;</p><p>/* 代理 */<br>function ProxyMsg(msg) &#123;<br>  if (!msg) &#123;<br>    console.log(‘msg is empty’)<br>    return<br>  &#125;</p><p>  msg = ‘我要发送的数据是’ + msg<br>  sendMsg(msg)<br>&#125;</p><p>// test<br>ProxyMsg(‘您好!’)<br></code></pre></p><h3 id="PhIha"><span class="ne-text">享元模式</span></h3><pre><code>/** * 享元模式 */<p>/* 享元对象 */<br>function Shape(shape) &#123;<br>  this.shape = shape<br>&#125;</p><p>shape.prototype.draw = function () &#123;<br>  console.log(<code>画了一个$&#123;this.shape&#125;</code>)<br>}</p><p>/* 享元工厂 */<br>const ShapeFactory = (function () {<br>  const dataMap = {}<br>  return {<br>    getShapeContext(shape) {<br>      if (dataMap[shape]) return dataMap[shape]<br>      else {<br>        const instance = new Shape(shape)<br>        dataMap[shape] = instance<br>        return instance<br>      }<br>    }<br>  }<br>})()</p><p>// test<br>const rect = ShapeFactory.getShapeContext(‘rect’);<br>const circle = ShapeFactory.getShapeContext(‘circle’);</p><p>rect.draw();     // 画了一个 rect<br>circle.draw();   // 画了一个 circle<br></code></pre></p><h3 id="JKLzV"><span class="ne-text">适配器模式</span></h3><pre><code>/** * 适配器模式 */<p>const baiduMap = &#123;<br>  show: function () &#123;<br>    console.log(‘开始渲染百度地图’)<br>  &#125;<br>&#125;</p><p>const AMap = &#123;<br>  show: function () &#123;<br>    console.log(‘开始渲染高德地图’)<br>  &#125;<br>&#125;</p><p>/* 适配器 */<br>const baiduAdapter = &#123;<br>  render: function () &#123;<br>      return baiduMap.show()<br>  &#125;<br>&#125;</p><p>function renderMap(map) &#123;<br>  if (typeof map.render === ‘function’) &#123;<br>      map.render()<br>  &#125;<br>&#125;</p><p>// test<br>renderMap(AMap);            // 开始渲染高德地图<br>renderMap(baiduAdapter);    // 开始渲染百度地图<br></code></pre></p><h3 id="H22N6"><span class="ne-text">装饰器模式</span></h3><pre><code>/** * 装饰器模式 */<p>const btn = document.querySelector(‘#btn’)</p><p>// 原绑定事件<br>btn.onclick = function () &#123;<br>  console.log(‘按钮被点击了’)<br>&#125;</p><p>// 新增统计<br>function ajaxToServer() &#123;<br>  console.log(‘数据统计’)<br>&#125;</p><p>// 装饰器函数<br>function decorator(target, eventName, cb) &#123;<br>  const originFn = target[‘on’ + eventName]<br>  originFn &amp;&amp; originFn()<br>  cb &amp;&amp; cb ()<br>&#125;</p><p>// test<br>decorator(btn, ‘click’, ajaxToServer)<br></code></pre></p><h3 id="N1ZoP"><span class="ne-text">外观模式</span></h3><pre><code>/** * 外观模式  */<p>// 事件绑定<br>function addEvent(element, type, fn) &#123;<br>  if (element.addEventListener) &#123;<br>    element.addEventListener(type, fn, false)<br>  &#125; else if (element.attachEvent) &#123;<br>    element.attachEvent(‘on’ + type, fn)<br>  &#125; else &#123;<br>    element[‘on’ + type] = fn<br>  &#125;<br>&#125;</p><p>// 阻止事件冒泡<br>function cancelBubble(event) &#123;<br>  if (event.stopPropagation) &#123;<br>    event.stopPropagation()<br>  &#125; else &#123;<br>    event.cancelBubble = true<br>  &#125;<br>&#125;</p><p>// axios 中 getDefaultAdapter<br>function getDefaultAdapter() &#123;<br>  var baiduAdapter<br>  if (typeof process !== ‘undefined’ &amp;&amp; Object.prototype.toString.call(process) === ‘[object process]’) &#123;<br>    adapter = ‘a’<br>  &#125; else if (typeof XMLHttpRequest !== ‘undefined’) &#123;<br>    adapter =’b’<br>  &#125;</p><p>  return adapter<br>&#125;<br></code></pre></p><p id="u61e1541c" class="ne-p"><br></p><h3 id="n7oZA"><span class="ne-text">组合模式</span></h3><pre><code>/** * 组合模式 */<p>// 创建部门<br>function createApartment(name) &#123;<br>  return &#123;<br>    name,<br>    _children: [],<br>    add(target) &#123;<br>      this._children.push(target)<br>      return this<br>    &#125;,<br>    show(cb) &#123;<br>      this._children.forEach(function(child) &#123;<br>        child.show(cb)<br>      &#125;)<br>    &#125;<br>  &#125;<br>&#125;</p><p>// 创建员工<br>function createEmp(num, name) &#123;<br>  return &#123;<br>    num,<br>    name,<br>    show(cb) &#123;<br>      cb(this)<br>    &#125;<br>  &#125;<br>&#125;</p><p>// 创建部门<br>const techApartment = createApartment(‘技术部’)</p><p>// 创建子部门<br>const proApartment = createApartment(‘产品组’),<br>  devApartment = createApartment(‘开发组’)</p><p>techApartment.add(proApartment).add(devApartment)</p><p>proApartment.add(createEmp(100, ‘张三’))<br>  .add(createEmp(101, ‘李四’))</p><p>techApartment.add(createEmp(201, ‘小刘’))<br>  .add(createEmp(202, ‘小王’))<br>  .add(createEmp(203, ‘小陈’))<br>  .add(createEmp(204, ‘小亮’))</p><p>// 遍历<br>techApartment.show(function (item) &#123;<br>  console.log(<code>工号：$&#123;item.num&#125;，姓名：$&#123;item.name&#125;</code>)<br>})<br></code></pre></p><p id="ue0737db5" class="ne-p"><br></p><h3 id="jya6o"><span class="ne-text">桥接模式</span></h3><pre><code>/** * 桥接模式 */<p>// 桥接方法<br>function addEvent(ele, eventName, fn) &#123;<br>  document.querySelector(ele).addEventListener(eventName, fn, false)<br>&#125;</p><p>// 具体业务<br>addEvent(‘#btn’, ‘click’, function () &#123;<br>  console.log(‘hello world’)<br>&#125;)<br></code></pre></p><p id="ub2eaa9c6" class="ne-p"><span class="ne-text"></span></p><h3 id="usKNI"><span class="ne-text">发布-订阅模式</span></h3><pre><code>// 事件监听器const Emitter = (function () &#123;  const _events = &#123;&#125;  return &#123;    // 事件绑定    on(type, cb) &#123;      if (!_events[type]) &#123;        _events[type] = []      &#125;      if (typeof cb === 'function') &#123;        _events[type].push(cb)      &#125; else &#123;        throw new Error('参数类型必须为函数')      &#125;    &#125;,    // 事件解绑    off(type, cb) &#123;      if (!_events[type] || !_events[type].includes(cb)) return       // 移除事件监听      _events[type].map((fn, index) =&gt; &#123;        if (fn == cb) &#123;          _events[type].splice(index, 1)        &#125;      &#125;)    &#125;,    emit(type, ...args) &#123;      if (!_events[type]) return      _events[type].forEach(cb =&gt; cb(...args))    &#125;  &#125;&#125;)()<p>// 事件订阅<br>Emitter.on(‘change’, data =&gt; console.log(<code>我是第一条信息：$&#123;data&#125;</code>))<br>Emitter.on(‘change’, data =&gt; console.log(<code>我是第二条信息：$&#123;data&#125;</code>))</p><p>// 事件发布<br>Emitter.emit(‘change’, ‘参数’)</p><p></code></pre></p><p id="udce49d72" class="ne-p"><span class="ne-text">发布-订阅模式和观察者模式相近，具体区别有：</span></p><p id="u61bde39e" class="ne-p"><img src="https://camo.githubusercontent.com/7fd692610ddad0b886a45d4f74099593899efbb0262ea18df3dca75a9f44eb6c/687474703a2f2f7374617469632e7a7962756c756f2e636f6d2f677979696e2f376e356830306d757861346f7930336d657372716a666c782f696d6167655f31653071623666746331646f6431376e6375346f66673176346d392e706e67" width="835" id="ncdsN" class="ne-image"></p><p id="ub7eb1648" class="ne-p"><span class="ne-text"></span></p><h3 id="eY1bH"><span class="ne-text">策略模式</span></h3><pre><code>/** * 策略模式 */<p>// 校验规则<br>const strategyMap = &#123;<br>  // 校验手机号<br>  isMobile(mobile) &#123;<br>    return /^1\d&#123;10&#125;$/.test(mobile)<br>  &#125;,<br>  // 校验是否必填<br>  isRequired(str) &#123;<br>    return str.replace(/(^\s*)|(\s*$)/g, ‘’) !== ‘’<br>  &#125;<br>&#125;</p><p>// 校验方法<br>function validate(formData) &#123;<br>  let valid</p><p>  for (let key in formData) &#123;<br>    const val = formData[key]?.value<br>    const rules = formData[key]?.rules</p><pre><code>for (let i = 0; i &amp;lt; rules.length; i++) &#123;  const result = strategyMap[rules[i][&#39;rule&#39;].call(null,val)]  if (!result) &#123;    valid = &#123;      errField: key,      errValue: value,      errMsg: rules[i][&#39;message&#39;]    &#125;    break  &#125;&#125;if (valid) return valid</code></pre><p>  }</p><p>  return valid<br>}</p><p>// form 表单校验<br>const formData = {<br>  mobile: {<br>    value: ‘1380000000’,<br>    rules: [<br>      { rule: ‘isRequired’, message: ‘手机号码不能为空’ },<br>      { rule: ‘isMobile’, message: ‘手机号码格式不正确’ }<br>    ]<br>  }<br>}</p><p>// 获取校验结果<br>const valid = validate(formData)<br>if (!valid) {<br>  console.log(‘校验通过’)<br>} else {<br>  console.log(valid)<br>}<br></code></pre></p><p id="u5d03555e" class="ne-p"><span class="ne-text"></span></p><h3 id="JI6jF"><span class="ne-text">状态模式</span></h3><pre><code>/** * 状态模式 */<p>// 正常状态<br>function NormalState() &#123;<br>  this.handleChange = function (context) &#123;<br>    console.log(‘正常状态’)<br>    context.state = new ColorfulState()<br>  &#125;<br>&#125;</p><p>// 彩灯状态<br>function ColorfulState() &#123;<br>  this.handleChange = function (context) &#123;<br>    console.log(‘彩灯状态’)<br>    context.state = new CloseState()<br>  &#125;<br>&#125;</p><p>// 关闭状态<br>function CloseState() &#123;<br>  this.handleChange = function (context) &#123;<br>    console.log(‘关闭状态’)<br>    context.state = new NormalState()<br>  &#125;<br>&#125;</p><p>// 灯<br>function Light(state) &#123;<br>  this.state = state<br>  this.switch = function () &#123;<br>    this.state.handleChange(this)<br>  &#125;<br>&#125;</p><p>// 设置灯光初始为关闭<br>const light = new Light(new CloseState())</p><p>// 关闭状态–&gt;正常状态–&gt;彩灯状态–&gt;关闭状态…<br>setInterval(() =&gt; &#123;<br>  light.switch()<br>&#125;, 1000)<br></code></pre></p><p id="u141d76c8" class="ne-p"><span class="ne-text"></span></p><h3 id="tVMWA"><span class="ne-text">命令模式</span></h3><pre><code>/** * 命令模式 */<p>const Manager = (function () &#123;<br>  // 命令<br>  const commander = &#123;<br>    open: function () &#123;<br>      console.log(‘打开电视’)<br>    &#125;,<br>    close: function () &#123;<br>      console.log(‘关闭电视’)<br>    &#125;,<br>    change: function (channel) &#123;<br>      console.log(‘更换频道’ + channel)<br>    &#125;<br>  &#125;</p><p>  return &#123;<br>    // 执行命令<br>    exec: function (cmd) &#123;<br>      const args = [].splice.call(arguments, 1)<br>      commander[cmd] &amp;&amp; commander[cmd][args]<br>    &#125;<br>  &#125;<br>&#125;)</p><p>// test<br>Manager.exec(‘open’)        // 打开电视<br>Manager.exec(‘change’, 10)  // 更换频道 10<br>Manager.exec(‘close’)       // 关闭电视<br></code></pre></p><h3 id="chwSO"><span class="ne-text">参考</span></h3><ul class="ne-ul"><li id="u9c4f5769"><a href="https://github.com/yinguangyao/blog/issues/64" data-href="https://github.com/yinguangyao/blog/issues/64" target="_blank" class="ne-link"><span class="ne-text">https://github.com/yinguangyao/blog/issues/64</span></a></li></ul></div>]]></content>
      
      
      <categories>
          
          <category> 计算机素养 </category>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>82. 删除排序链表中的重复元素 II🔖链表</title>
      <link href="/blog/d75374fb-d238-4bcb-9146-e8b182b66752/"/>
      <url>/blog/d75374fb-d238-4bcb-9146-e8b182b66752/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><ul class="ne-ul"><li id="uf39c1e4d" data-lake-index-type="0"><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-list-ii/description/" data-href="https://leetcode.cn/problems/remove-duplicates-from-sorted-list-ii/description/" target="_blank" class="ne-link"><span class="ne-text">https://leetcode.cn/problems/remove-duplicates-from-sorted-list-ii/description/</span></a></li></ul><p id="ub149d4a7" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2024/png/1484158/1705304228090-83a965b9-0293-4917-bd57-9bb81d92304e.png" width="841.6666332218396" id="u47ecf146" class="ne-image"></p><p id="u4eae43c3" class="ne-p"><br></p><h3 id="EDq8j"><span class="ne-text">typescript</span></h3><pre><code><code>/** * Definition for singly-linked list. * class ListNode &#123; *     val: number *     next: ListNode | null *     constructor(val?: number, next?: ListNode | null) &#123; *         this.val = (val===undefined ? 0 : val) *         this.next = (next===undefined ? null : next) *     &#125; * &#125; */<p>function deleteDuplicates(head: ListNode | null): ListNode | null &#123;<br>  if (!head) return head<br>  const firstNode = new ListNode(-1, head);<br>  let curr = firstNode;<br>  while (curr.next &amp;&amp; curr.next.next) &#123;<br>    if (curr.next.val === curr.next.next.val) &#123;<br>      const temp = curr.next.val<br>      while (curr.next &amp;&amp; curr.next.val === temp)<br>        curr.next = curr.next.next;<br>    &#125; else &#123;<br>      curr = curr.next;<br>    &#125;<br>  &#125;<br>  return firstNode.next;<br>&#125;;</code><br></code></pre></p></div>]]></content>
      
      
      <categories>
          
          <category> 计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 🔗线结构：链表 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>《华丽人生》原文摘录</title>
      <link href="/essay/algh82/"/>
      <url>/essay/algh82/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="ub1eee640" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1639824740044-5fc3d698-c9be-4993-ad8d-688ea9a6947d.png" width="1080" id="u8defc980" class="ne-image"></p><p id="u10b35ccf" class="ne-p"><span class="ne-text"></span></p><p id="uf0aec04d" class="ne-p"><span class="ne-text">我放弃抵抗人生。这世上有一股巨大的潮流，就算反抗那股潮流，终究还是会被推着走。如果能理解我们活着的背后有一股巨大的力量，那就没什么好怕的，也不需要逃避。就算我们自以为靠着自我压抑和选择过日子，其实也不过就是&quot;被迫活着&quot;而已，不是吗？” …… “是海洋啊。”黑泽耸耸肩说道，“人生是既没有路线也没有标志的茫茫大海啊。我们只是身在其中，紧紧抓住一条大鱼，委身于巨大的海流罢了</span></p></div>]]></content>
      
      
      <categories>
          
          <category> 阅读 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数组去重🔖JavaScript🔖数组</title>
      <link href="/blog/array-deduplication/"/>
      <url>/blog/array-deduplication/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="u5d074287" class="ne-p"><span class="ne-text">总结来看，去重分三种思路：</span></p><ul class="ne-ul"><li id="u17946e66"><span class="ne-text">es6的 Set 数据结构</span></li><li id="u6cded952"><span class="ne-text">Array的各类api</span></li><li id="u21d8c1a5"><span class="ne-text">利用对象的属性</span></li></ul><p id="u417f068d" class="ne-p"><span class="ne-text">文章参考：</span><a href="https://segmentfault.com/a/1190000016418021" data-href="https://segmentfault.com/a/1190000016418021" target="_blank" class="ne-link"><span class="ne-text">https://segmentfault.com/a/1190000016418021</span></a></p><h2 id="d03bbbd3"><span class="ne-text">一、利用 ES6 Set 去重（ES6 中最常用）</span></h2><p id="ud6962878" class="ne-p"><br></p><pre><code>arr_test = [0,0,999,999,'字符串','字符串',true,true,false,false,undefined,undefined,null,null,NaN,NaN,&#123;&#125;,&#123;&#125;,[],[],]<p>let unique_set = arr =&gt; &#123;<br>  return Array.from(new Set(arr))<br>&#125;</p><p>console.log(unique_set(arr_test))<br></code></pre></p><p id="u3bf4bff7" class="ne-p"><span class="ne-text">或者……</span></p><pre><code>console.log([...new Set(arr_test)])</code></pre><p id="u57699b53" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1651548685623-2a8e3fb9-2f10-4f98-bb4d-bede8276712f.png" width="232.49999076128043" id="u5b9461cf" class="ne-image"></p><div data-type="danger" class="ne-alert"><p id="u719146d8" class="ne-p"><span class="ne-text">去不掉</span></p><ul class="ne-ul"><li id="ua00300a4"><span class="ne-text">{}</span></li><li id="u8b5646db"><span class="ne-text">[]</span></li></ul></div><p id="u54caacdc" class="ne-p"><br></p><h2 id="d67f434e"><span class="ne-text">二、利用 for 嵌套 for，然后 splice 去重（ES5 中最常用）</span></h2><p id="u5aec723e" class="ne-p"><br></p><pre><code>arr_test = [0,0,999,999,'字符串','字符串',true,true,false,false,undefined,undefined,null,null,NaN,NaN,&#123;&#125;,&#123;&#125;,[],[],]<p>let unique_for_for_splice = arr =&gt; &#123;<br>  for (let i = 0; i &lt; arr.length; i++) &#123;<br>    for (let j = i + 1; j &lt; arr.length; j++) &#123;<br>      if (arr[i] === arr[j]) &#123;<br>        arr.splice(j, 1)<br>      &#125;<br>    &#125;<br>  &#125;<br>  return arr<br>&#125;<br>console.log(unique_for_for_splice(arr_test))<br></code></pre></p><p id="u9daeb974" class="ne-p"><br></p><p id="uc4605d05" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1651548810144-b36aa36d-87c9-4879-bd0a-12f3c4f55295.png" width="228.33332426018222" id="u8b1b4557" class="ne-image"></p><div data-type="danger" class="ne-alert"><p id="u250668ab" class="ne-p"><span class="ne-text">去不掉</span></p><ul class="ne-ul"><li id="uaf872f04"><span class="ne-text">NaN</span></li></ul><ul class="ne-ul"><li id="u2816b937"><span class="ne-text">{}</span></li><li id="u33792e49"><span class="ne-text">[]</span></li></ul></div><h2 id="f59a2b27"><span class="ne-text">三、利用 includes/indexOf 去重</span></h2><p id="ued10258d" class="ne-p"><br></p><pre><code>let unique_includes = arr =&gt; &#123;  let result = []  arr.forEach(data =&gt; &#123;    if (!result.includes(data)) result.push(data)  &#125;)  return result&#125;console.log(unique_includes(arr_test))</code></pre><pre><code>let unique_indexof = arr =&gt; &#123;  let result = []  arr.forEach(data =&gt; &#123;    if (result.indexOf(data) === -1) result.push(data)  &#125;)  return result&#125;console.log(unique_indexof(arr_test))</code></pre><p id="u0fa4d157" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1651549129756-b5675fd2-1851-4b74-923a-6bd90675fcd4.png" width="236.66665726237864" id="uda11904a" class="ne-image"></p><p id="ub4301d4e" class="ne-p"><br></p><h2 id="801e89a1"><span class="ne-text">四、利用 sort()</span></h2><p id="u7411e574" class="ne-p"><br></p><pre><code>let unique_sort = arr =&gt; &#123;  arr.sort().forEach((data, index) =&gt; &#123;    if (data === arr[index + 1] &amp;&amp; index &lt; arr.length - 1)      arr.splice(index + 1, 1)  &#125;)  return arr&#125;console.log(unique_indexof(arr_test))</code></pre><p id="u0fba8d32" class="ne-p"><br></p><p id="u7612ecf9" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1651549585258-df18b8b6-1a2f-4345-a7a2-db2635e84b13.png" width="284.1666553748983" id="u150d350e" class="ne-image"></p><h2 id="wP0wd"><span class="ne-text">五、利用 filter</span></h2><p id="u93c6e9db" class="ne-p"><br></p><pre><code>let unique_filter = arr =&gt; &#123;  return arr.filter((data, index, arr) =&gt; &#123;    return arr.indexOf(data, 0) === index;  &#125;)&#125;console.log(unique_filter(arr_test))</code></pre><p id="u1abe8c53" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1651550392520-a342d7c0-9102-49db-b672-3c70b887d258.png" width="296.66665487819296" id="nMX9A" class="ne-image"></p><h2 id="RfLwD"><span class="ne-text">六、利用 reduce</span></h2><p id="u587b9a1e" class="ne-p"><br></p><pre><code>let unique_reduce = arr =&gt; &#123;  return arr.reduce((a, b) =&gt; (a.includes(b) ? a : [...a, b]), [])&#125;console.log(unique_reduce(arr_test))</code></pre><p id="u918f047a" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1651550878738-7acdd3ef-54cd-4572-97e6-0e8c43b5719e.png" width="304.16665458016973" id="jhDy7" class="ne-image"></p><h2 id="f4fc8f4e"><span class="ne-text">利用对象的属性不能相同的特点进行去重（这种数组去重的方法有问题，不建议用，有待改进）</span></h2><p id="ua72da46c" class="ne-p"><br></p><pre><code>function unique(arr) &#123;    if (!Array.isArray(arr)) &#123;        console.log('type error!')        return    &#125;    var arrry= \[\];     var  obj = &#123;&#125;;    for (var i = 0; i &lt; arr.length; i++) &#123;        if (!obj\[arr\[i\]\]) &#123;            arrry.push(arr\[i\])            obj\[arr\[i\]\] = 1        &#125; else &#123;            obj\[arr\[i\]\]++        &#125;    &#125;    return arrry;&#125;    var arr = \[1,1,'true','true',true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,'NaN', 0, 0, 'a', 'a',&#123;&#125;,&#123;&#125;\];        console.log(unique(arr))//\[1, &quot;true&quot;, 15, false, undefined, null, NaN, 0, &quot;a&quot;, &#123;…&#125;\]    //两个true直接去掉了，NaN和&#123;&#125;去重</code></pre><p id="u2aa60d02" class="ne-p"><br></p><h2 id="65722c0d"><span class="ne-text">利用 hasOwnProperty</span></h2><p id="ufc660d37" class="ne-p"><br></p><pre><code>function unique(arr) &#123;    var obj = &#123;&#125;;    return arr.filter(function(item, index, arr)&#123;        return obj.hasOwnProperty(typeof item + item) ? false : (obj\[typeof item + item\] = true)    &#125;)&#125;    var arr = \[1,1,'true','true',true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,'NaN', 0, 0, 'a', 'a',&#123;&#125;,&#123;&#125;\];        console.log(unique(arr))//\[1, &quot;true&quot;, true, 15, false, undefined, null, NaN, &quot;NaN&quot;, 0, &quot;a&quot;, &#123;…&#125;\]   //所有的都去重了</code></pre><p id="u409ad723" class="ne-p"><br></p><p id="u5496097d" class="ne-p"><span class="ne-text">利用 hasOwnProperty 判断是否存在对象属性</span></p><p id="uf1ae4dc2" class="ne-p"><br></p><h2 id="37828459"></h2><h2 id="0d78e14f"><span class="ne-text">利用递归去重</span></h2><p id="u7ad84673" class="ne-p"><br></p><pre><code>function unique(arr) &#123;        var array\= arr;        var len = array.length;<pre><code>array.sort(function(a,b)&#123;   //排序后更加方便去重    return a - b;&#125;)function loop(index)&#123;    if(index &amp;gt;= 1)&#123;        if(array\[index\] === array\[index\-1\])&#123;            array.splice(index,1);        &#125;        loop(index - 1);    //递归loop，然后数组去重    &#125;&#125;loop(len\-1);return array;</code></pre><p>}<br> var arr = [1,1,’true’,’true’,true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,’NaN’, 0, 0, ‘a’, ‘a’,{},{}];<br>console.log(unique(arr))<br>//[1, &quot;a&quot;, &quot;true&quot;, true, 15, false, 1, {…}, null, NaN, NaN, &quot;NaN&quot;, 0, &quot;a&quot;, {…}, undefined]<br></code></pre></p><p id="uc875115e" class="ne-p"><br></p><h2 id="ad4d0c86"><span class="ne-text">利用 Map 数据结构去重</span></h2><p id="ud6cfc1de" class="ne-p"><br></p><pre><code>function arrayNonRepeatfy(arr) &#123;  let map = new Map();  let array = new Array();  // 数组用于返回结果  for (let i = 0; i &lt; arr.length; i++) &#123;    if(map .has(arr\[i\])) &#123;  // 如果有该key值      map .set(arr\[i\], true);     &#125; else &#123;       map .set(arr\[i\], false);   // 如果没有该key值      array .push(arr\[i\]);    &#125;  &#125;   return array ;&#125; var arr = \[1,1,'true','true',true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,'NaN', 0, 0, 'a', 'a',&#123;&#125;,&#123;&#125;\];    console.log(unique(arr))//\[1, &quot;a&quot;, &quot;true&quot;, true, 15, false, 1, &#123;…&#125;, null, NaN, NaN, &quot;NaN&quot;, 0, &quot;a&quot;, &#123;…&#125;, undefined\]</code></pre><p id="u698485f0" class="ne-p"><br></p><p id="ude7ca7ea" class="ne-p"><span class="ne-text">创建一个空 Map 数据结构，遍历需要去重的数组，把数组的每一个元素作为 key 存到 Map 中。由于 Map 中不会出现相同的 key 值，所以最终得到的就是去重后的结果。</span></p><p id="u3373844e" class="ne-p"><br></p><h2 id="b21c06bc"></h2><p id="ubcc0d98a" class="ne-p"><br></p><p id="ud9f30771" class="ne-p"><span class="ne-text">PS：有些文章提到了 foreach+indexOf 数组去重的方法，个人觉得都是大同小异，所以没有写上去。<br /></span></p></div>]]></content>
      
      
      <categories>
          
          <category> 计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 📶线结构：字符串-数组-栈-队列 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>跨域以及非跨域下载指定url图片方案</title>
      <link href="/blog/na8588/"/>
      <url>/blog/na8588/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h2 id="XXVKm"><span class="ne-text">非跨域url图片转base64</span></h2><ul class="ne-ul"><li id="u06aed2dc" data-lake-index-type="0"><span class="ne-text">条件：合法图片url、图片不存在跨域等限制</span></li><li id="u736fbb32" data-lake-index-type="0"><span class="ne-text">流程：转base64 -&gt; 在进行canvas绘制 -&gt; 模拟点击事件触发下载图片文件</span></li></ul><pre><code>downloadImg(imgsrc, name) &#123;  var image = new Image()  // 解决跨域 Canvas 污染问题  image.setAttribute('crossOrigin', 'anonymous')  image.onload = function() &#123;    var canvas = document.createElement('canvas')    canvas.width = image.width    canvas.height = image.height    var context = canvas.getContext('2d')    context.drawImage(image, 0, 0, image.width, image.height)    var url = canvas.toDataURL() //得到图片的base64编码数据    var a = document.createElement('a') // 生成一个a元素    var event = new MouseEvent('click') // 创建一个单击事件    a.download = name || 'photo' // 设置图片名称    a.href = url // 将生成的URL设置为a.href属性    a.dispatchEvent(event) // 触发a的单击事件  &#125;  image.src = imgsrc&#125;</code></pre><h2 id="ndbyD"><span class="ne-text">利用三方库superagent处理防盗链图片方法</span></h2><ul class="ne-ul"><li id="u24e24ead" data-lake-index-type="0"><span class="ne-text">条件：合法图片url、三方库</span><code class="ne-code"><a href="https://github.com/ladjs/superagent" data-href="https://github.com/ladjs/superagent" target="_blank" class="ne-link"><span class="ne-text">superagent</span></a></code></li><li id="u1075afdd" data-lake-index-type="0"><span class="ne-text">流程：请求图片url -&gt; 转buffer -&gt; 转图片文件</span></li></ul><pre><code>const superagent = require(&quot;superagent&quot;);const fs = require(&quot;fs&quot;);<p>/**</p><ul><li>将图片转成buffer</li><li></li><li>@param &#123;string&#125; imgUrl 图片url</li><li>@return &#123;Promise&lt;Buffer&gt;&#125; 文件buffer</li><li>/<br>async function imgUrlToBuffer(imgUrl) &#123;<br>const urlInfo = imgUrl.split(&quot;/&quot;);<br>const fileName = urlInfo[urlInfo.length - 1];<br>return await new Promise(async function (resolve) &#123;<br>  try &#123;<pre><code>await superagent  .get(imgUrl)  .set(&amp;quot;User-Agent&amp;quot;, &amp;quot;Mozilla/5.0&amp;quot;)  .buffer(true)  .parse((res) =&amp;gt; &#123;    const buffer = [];    res.on(&amp;quot;data&amp;quot;, (chunk) =&amp;gt; &#123;      buffer.push(chunk);    &#125;);    res.on(&amp;quot;end&amp;quot;, () =&amp;gt; &#123;      const data = Buffer.concat(buffer);      // buffer转为图片文件      fs.writeFile(`./dist/$&#123;fileName&#125;`, data, function (err) &#123;        if (err) &#123;          console.log(&amp;quot;buffer -&amp;gt; jpg error: &amp;quot;, err);        &#125;      &#125;);      resolve(data);    &#125;);  &#125;);</code></pre>  } catch (e) {<pre><code>console.log(`invalid img: $&#123;imgUrl&#125;`);resolve(null);</code></pre>  }<br>});<br>}<br></code></pre></div></li></ul>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
          <category> 前端业务解决方案 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Vue组件通信方式总结（Vue2和Vue3）</title>
      <link href="/blog/qwv5oz/"/>
      <url>/blog/qwv5oz/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="497144d8506882a2db679d679af2acea_p_4" class="ne-p"><span class="ne-text">前言：Vue 是数据驱动视图更新的框架，所以对于组件之间的数据通信非常重要，常见的Vue 组件关系如下：</span></p><img src="https://cdn.nlark.com/yuque/0/2024/jpeg/1484158/1704805890868-a605ebf8-3289-4311-b919-7a3bcfddc3ea.jpeg" id="Nu7KY" style="display: block; width: 100%"><p id="277ac1b9a01a26e550f334d2d650a2af_p_8" class="ne-p"><span class="ne-text">如上图所示, A 与 B、A 与 C、B 与 D、C 与 E 组件之间是父子关系； B 与 C 之间是兄弟关系；A 与 D、A 与 E 之间是隔代关系； D 与 E 是堂兄关系（非直系亲属） 针对以上关系我们归类为：</span></p><ul class="ne-ul"><li id="e921ea6da6315ea6a03b83b1fbdb45ce_li_0" data-lake-index-type="0"><span class="ne-text">父子组件之间通信</span></li></ul><ul class="ne-ul"><li id="afaa832eef1dad88d3692c9ee7c0cb23_li_1" data-lake-index-type="0"><span class="ne-text">非父子组件之间通信 (兄弟组件、隔代关系组件等)</span></li></ul><p id="95350d3f636bad4a4fd5424d38f13bf2_p_11" class="ne-p"><span class="ne-text">本文介绍组件间（Vue2和Vue3）通信的 8 种方式如下图目录所示：并介绍在不同的场景下如何选择有效方式实现的组件间通信方式。</span></p><h2 id="aokck"><span class="ne-text">一、props / $emit</span></h2><p id="aefd39de20827e7fa178830efd84d682_p_16" class="ne-p"><span class="ne-text">父组件通过</span><code class="ne-code"><span class="ne-text">props</span></code><span class="ne-text">的方式向子组件传递数据，而通过</span><code class="ne-code"><span class="ne-text">$emit</span></code><span class="ne-text"> 子组件可以向父组件通信。</span></p><h3 id="erDJy"><span class="ne-text">vue2</span></h3><h4 id="0695b088"><span class="ne-text">1. 父组件向子组件传值</span></h4><p id="0a6e4fcd704856005fdf95a5090e6575_p_19" class="ne-p"><span class="ne-text">下面通过一个例子说明父组件如何向子组件传递数据：在子组件</span><code class="ne-code"><span class="ne-text">article.vue</span></code><span class="ne-text">中如何获取父组件</span><code class="ne-code"><span class="ne-text">section.vue</span></code><span class="ne-text">中的数据</span><code class="ne-code"><span class="ne-text">articles:['红楼梦', '西游记','三国演义']</span></code></p><pre><code><code>// section父组件&lt;template&gt;  &lt;div class=&quot;section&quot;&gt;    &lt;com-article :articles=&quot;articleList&quot;&gt;&lt;/com-article&gt;  &lt;/div&gt;&lt;/template&gt;<p>&lt;script&gt;<br>import comArticle from ‘./test/article.vue’<br>export default &#123;<br>  name: ‘HelloWorld’,<br>  components: &#123; comArticle &#125;,<br>  data() &#123;<br>    return &#123;<br>      articleList: [‘红楼梦’, ‘西游记’, ‘三国演义’]<br>    &#125;<br>  &#125;<br>&#125;<br>&lt;/script&gt;</code><br></code></pre></p><pre><code><code>// 子组件 article.vue&lt;template&gt;  &lt;div&gt;    &lt;span v-for=&quot;(item, index) in articles&quot; :key=&quot;index&quot;&gt;&#123;&#123;item&#125;&#125;&lt;/span&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  props: ['articles']&#125;&lt;/script&gt;</code></code></pre><div class="ne-quote"><p id="85be3e4d88c775ffac9191a0916bdfa5_p_22" class="ne-p"><span class="ne-text">总结: prop 只可以从上一级组件传递到下一级组件（父子组件），即所谓的单向数据流。而且 prop 只读，不可被修改，所有修改都会失效并警告。</span></p></div><h4 id="16b04c6a"><span class="ne-text">2. 子组件向父组件传值</span></h4><p id="1f3b4b4a4867a8b756c196b38558d0c4_p_24" class="ne-p"><br></p><p id="434c1d7d47824a48e59b3b09d32b26c5_p_25" class="ne-p"><span class="ne-text">对于</span><code class="ne-code"><span class="ne-text">$emit</span></code><span class="ne-text"> 我自己的理解是这样的: </span><code class="ne-code"><span class="ne-text">$emit</span></code><span class="ne-text">绑定一个自定义事件, 当这个语句被执行时, 就会将参数 arg 传递给父组件, 父组件通过 v-on 监听并接收参数。 通过一个例子，说明子组件如何向父组件传递数据。 在上个例子的基础上, 点击页面渲染出来的</span><code class="ne-code"><span class="ne-text">ariticle</span></code><span class="ne-text">的</span><code class="ne-code"><span class="ne-text">item</span></code><span class="ne-text">, 父组件中显示在数组中的下标</span></p><p id="b57de0a6a045efefe71d109094be9ddc_p_26" class="ne-p"><br></p><pre><code><code>// 父组件&lt;template&gt;  &lt;div class=&quot;section&quot;&gt;    &lt;com-article :articles=&quot;articleList&quot; @onEmitIndex=&quot;onEmitIndex&quot;&gt;&lt;/com-article&gt;    &lt;p&gt;&#123;&#123;currentIndex&#125;&#125;&lt;/p&gt;  &lt;/div&gt;&lt;/template&gt;<p>&lt;script&gt;<br>import comArticle from ‘./test/article.vue’<br>export default &#123;<br>  name: ‘HelloWorld’,<br>  components: &#123; comArticle &#125;,<br>  data() &#123;<br>    return &#123;<br>      currentIndex: -1,<br>      articleList: [‘红楼梦’, ‘西游记’, ‘三国演义’]<br>    &#125;<br>  &#125;,<br>  methods: &#123;<br>    onEmitIndex(idx) &#123;<br>      this.currentIndex = idx<br>    &#125;<br>  &#125;<br>&#125;<br>&lt;/script&gt;</code><br></code></pre></p><pre><code><code>// 子组件&lt;template&gt;  &lt;div&gt;    &lt;div v-for=&quot;(item, index) in articles&quot; :key=&quot;index&quot; @click=&quot;emitIndex(index)&quot;&gt;&#123;&#123;item&#125;&#125;&lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  props: ['articles'],  methods: &#123;    emitIndex(index) &#123;      this.$emit('onEmitIndex', index)    &#125;  &#125;&#125;&lt;/script&gt;</code></code></pre><h3 id="B7Xr9"><span class="ne-text">vue3（组合式）</span></h3><h4 id="MIVx6"><span class="ne-text">父组件使用子组件方法</span></h4><p id="u5c98065f" class="ne-p"><span class="ne-text">子组件中：</span></p><p id="u77189cae" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1660894949430-ba1829bd-2001-4409-8c5a-d871feb4e07b.png" width="642" id="u0f0c93f6" class="ne-image"></p><p id="u8caa8f0f" class="ne-p"><span class="ne-text">父组件中：</span></p><p id="u8c24c3cc" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1660894970901-7604b713-71c3-453b-8744-245337da8e2b.png" width="742" id="u71458f7b" class="ne-image"></p><p id="uf4bd113e" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1660894987922-550b8a82-3f32-4b51-a760-ecadfc91bcbb.png" width="421" id="u7b9262a6" class="ne-image"></p><p id="u14c7a9dc" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1660895002286-18a4fb67-cb55-45c0-a3a5-f1f95f1a7d5c.png" width="648" id="ue776a999" class="ne-image"></p><h4 id="X50gB"><span class="ne-text">子组件使用父组件方法</span></h4><p id="u6f59878b" class="ne-p"><span class="ne-text">父组件</span></p><p id="ub5f76767" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1661149948014-41b17b1e-8c6c-46af-a9b1-a327ad4d2be6.png" width="733" id="u2915e955" class="ne-image"></p><p id="uc68de4ec" class="ne-p"><span class="ne-text">子组件</span></p><p id="u9acc0831" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1661149976565-2e690cd0-1303-465f-bc26-5361a080ba00.png" width="730" id="u35b6bd99" class="ne-image"></p><h4 id="rWS9U"><span class="ne-text">defineProps defineEmits defineExpose</span></h4><pre><code><code>&lt;template&gt;    &lt;h3&gt;父组件&lt;/h3&gt;    &lt;SonTemplate :father_variable='father_variable' @fatherToSonFun=&quot;fatherToSonFun&quot; ref=&quot;son&quot; /&gt;    &lt;span&gt;父组件 wait_son_value is : &#123;&#123;wait_son_value&#125;&#125;&lt;/span&gt;&lt;hr /&gt;    &lt;button @click=&quot;clickGetSonTemplateValue&quot;&gt;点击之后会获得子组件的son_val变量的值: &lt;/button&gt;&#123;&#123;value_form_son&#125;&#125;&lt;hr /&gt;&lt;/template&gt;<p>&lt;script setup lang=&quot;ts&quot;&gt;<br>import &#123;ref&#125; from ‘vue’<br>import SonTemplate from ‘./SonTemplate.vue’</p><p>// [defineProps]<br>const father_variable = ref(‘variable from father template!’)</p><p>// [defineEmits]<br>const wait_son_value=ref(‘父组件原本的值’)<br>const fatherToSonFun = (val: string) =&gt; &#123;<br>    wait_son_value.value = val<br>&#125;<br>// [ref defineExpose]<br>const son = ref()<br>const value_form_son = ref()<br>const clickGetSonTemplateValue = () =&gt; &#123;<br>    value_form_son.value = son.value.son_val<br>&#125;<br>&lt;/script&gt;</code><br></code></pre></p><pre><code><code>&lt;template&gt;    &lt;h3&gt;子组件&lt;/h3&gt;    &lt;span&gt;父组件传来的值：&lt;/span&gt;&#123;&#123;props.father_variable&#125;&#125;&lt;hr/&gt;    &lt;button @click=&quot;clickEvent&quot;&gt;点击之后会改变父组件里面的wait_son_value的值&lt;/button&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot;&gt;import &#123;ref&#125; from 'vue'// [defineProps]const props = defineProps(&#123;  father_variable: &#123;      type: String,      default: () =&gt; 'default_value'    &#125;&#125;) // [defineEmits]const son_val = ref('子组件传来的值')const emit = defineEmits(['fatherToSonFun'])const clickEvent = () =&gt; &#123;  emit('fatherToSonFun', son_val)&#125;// [ref defineExpose]defineExpose(&#123;  son_val&#125;)&lt;/script&gt;</code></code></pre><ul class="ne-ul"><li id="u77f134f8" data-lake-index-type="0"><span class="ne-text">父传子组件的props里面的变量失去响应式，解决办法</span></li></ul><pre><code><code>&lt;script setup lang=&quot;ts&quot;&gt;  import &#123; watch &#125; from 'vue';  const props = defineProps(&#123;    menuList: &#123;      type: Array,      default: () =&gt; []    &#125;  &#125;);<p>  watch(<br>    () =&gt; […props.menuList],<br>    (numbers, prevNumbers) =&gt; &#123;<br>      // console.log(‘numbers新值’, numbers);<br>      // console.log(‘numbers旧值’, prevNumbers);<br>      console.log(‘____________’, props.menuList.length);<br>    &#125;<br>  );<br>&lt;/script&gt;</code><br></code></pre></p><h3 id="PZU1h"><span class="ne-text">vue3（选项式）</span></h3><ol class="ne-ol"><li id="u99b7ae1e" data-lake-index-type="0"><span class="ne-text">父传子</span></li><li id="u09bac83d" data-lake-index-type="0"><span class="ne-text">子传父</span></li><li id="u4739fa61" data-lake-index-type="0"><span class="ne-text">双向响应通信</span></li></ol><pre><code><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;  &lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot; /&gt;    &lt;title&gt;learn vue&lt;/title&gt;    &lt;script src=&quot;./vue.global.js&quot;&gt;&lt;/script&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;div id=&quot;app&quot;&gt;      &lt;div&gt;parent count: &#123;&#123;count&#125;&#125;&lt;/div&gt;      &lt;my-head        :title=&quot;headerTitle&quot;        @custom-event=&quot;handleCustomEvent&quot;        v-model=&quot;count&quot;      &gt;&lt;/my-head&gt;    &lt;/div&gt;    &lt;script&gt;      let app = Vue.createApp(&#123;        data() &#123;          return &#123;            headerTitle: &quot;header-title&quot;,            count: &quot;1&quot;,          &#125;;        &#125;,        methods: &#123;          handleCustomEvent(data) &#123;            console.log(data);          &#125;,        &#125;,      &#125;);      // local component      const HeaderLocalComponent = &#123;        template: `header-local-component`,      &#125;;      // global component      app.component(&quot;my-head&quot;, &#123;        props: &#123;          title: &#123;            type: String,          &#125;,          modelValue: &#123;            type: String,          &#125;,        &#125;, // or props: [&quot;title&quot;]        emits: [&quot;custom-event&quot;, &quot;update:modelValue&quot;],        template: `          &lt;header&gt;            &lt;h1&gt;&#123;&#123;headTitle&#125;&#125;&lt;/h1&gt;             &lt;p&gt;description&lt;/p&gt;            &lt;p&gt;&#123;&#123;message&#125;&#125;&lt;/p&gt;             &lt;header-local-component&gt;&lt;/header-local-component&gt;            &lt;input type=&quot;text&quot; :value=&quot;modelValue&quot; @input=&quot;handleInput&quot; /&gt;          &lt;/header&gt;        `,        components: &#123;          HeaderLocalComponent,        &#125;,        data() &#123;          return &#123;            message: &quot;hello world&quot;,            headTitle: this.title, // props data -&gt; responsive...          &#125;;        &#125;,        mounted() &#123;          setTimeout(() =&gt; &#123;            this.message = &quot;hello world2&quot;;            this.headTitle = &quot;head change self title...&quot;;            this.$emit(&quot;custom-event&quot;, &#123;              info: &quot;child to parent.&quot;,            &#125;);          &#125;, 2000);        &#125;,        methods: &#123;          handleInput(e) &#123;            this.$emit(&quot;update:modelValue&quot;, e.target.value);          &#125;,        &#125;,      &#125;);      const vm = app.mount(&quot;#app&quot;);    &lt;/script&gt;  &lt;/body&gt;&lt;/html&gt;</code></code></pre><h2 id="jjpSa"><span class="ne-text">二、 $children / $parent</span></h2><h3 id="fwpyE"><span class="ne-text">vue2</span></h3><p id="a53b13677e55fdbc670902cf2d24e401_p_31" class="ne-p"><span class="ne-text">通过</span><code class="ne-code"><span class="ne-text">$parent</span></code><span class="ne-text">和</span><code class="ne-code"><span class="ne-text">$children</span></code><span class="ne-text">就可以访问组件的实例，拿到实例代表什么？代表可以访问此组件的所有方法和</span><code class="ne-code"><span class="ne-text">data</span></code><span class="ne-text">。接下来就是怎么实现拿到指定组件的实例。</span></p><pre><code><code>&lt;!-- 父组件中 --&gt;&lt;template&gt;  &lt;div class=&quot;hello_world&quot;&gt;    &lt;div&gt;&#123;&#123;msg&#125;&#125;&lt;/div&gt;    &lt;com-a&gt;&lt;/com-a&gt;    &lt;button @click=&quot;changeA&quot;&gt;点击改变子组件值&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;<p>&lt;script&gt;<br>import ComA from ‘./test/comA.vue’<br>export default &#123;<br>  name: ‘HelloWorld’,<br>  components: &#123; ComA &#125;,<br>  data() &#123;<br>    return &#123;<br>      msg: ‘Welcome’<br>    &#125;<br>  &#125;,</p><p>  methods: &#123;<br>    changeA() &#123;<br>      // 获取到子组件A<br>      this.$children[0].messageA = ‘this is new value’<br>    &#125;<br>  &#125;<br>&#125;<br>&lt;/script&gt;</code><br></code></pre></p><pre><code><code>&lt;!-- 子组件中 --&gt;&lt;template&gt;  &lt;div class=&quot;com_a&quot;&gt;    &lt;span&gt;&#123;&#123;messageA&#125;&#125;&lt;/span&gt;    &lt;p&gt;获取父组件的值为:  &#123;&#123;parentVal&#125;&#125;&lt;/p&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  data() &#123;    return &#123;      messageA: 'this is old'    &#125;  &#125;,  computed:&#123;    parentVal()&#123;      return this.$parent.msg;    &#125;  &#125;&#125;&lt;/script&gt;</code></code></pre><div class="ne-quote"><p id="baca8b35b9df69242628141ffca869a0_p_35" class="ne-p"><span class="ne-text">要注意边界情况，如在</span><code class="ne-code"><span class="ne-text">#app</span></code><span class="ne-text">上拿</span><code class="ne-code"><span class="ne-text">$parent</span></code><span class="ne-text">得到的是</span><code class="ne-code"><span class="ne-text">new Vue()</span></code><span class="ne-text">的实例，在这实例上再拿</span><code class="ne-code"><span class="ne-text">$parent</span></code><span class="ne-text">得到的是</span><code class="ne-code"><span class="ne-text">undefined</span></code><span class="ne-text">，而在最底层的子组件拿</span><code class="ne-code"><span class="ne-text">$children</span></code><span class="ne-text">是个空数组。也要注意得到</span><code class="ne-code"><span class="ne-text">$parent</span></code><span class="ne-text">和</span><code class="ne-code"><span class="ne-text">$children</span></code><span class="ne-text">的值不一样，</span><code class="ne-code"><span class="ne-text">$children</span></code><span class="ne-text"> 的值是数组，而</span><code class="ne-code"><span class="ne-text">$parent</span></code><span class="ne-text">是个对象</span></p></div><p id="udfabfdab" class="ne-p"><br></p><p id="c9f98fb68f54448a9f9adec409bc4cbe_p_38" class="ne-p"><span class="ne-text">上面两种方式用于父子组件之间的通信， 而使用 props 进行父子组件通信更加普遍；二者皆不能用于非父子组件之间的通信。</span></p><h2 id="xvUaQ"><span class="ne-text">三、provide / inject</span></h2><h3 id="OktDO"><span class="ne-text">vue2</span></h3><ol class="ne-ol"><li id="u775b7858" data-lake-index-type="0"><code class="ne-code"><span class="ne-text">provide</span></code><span class="ne-text">/ </span><code class="ne-code"><span class="ne-text">inject</span></code><span class="ne-text"> 是</span><code class="ne-code"><span class="ne-text">vue2.2.0</span></code><span class="ne-text">新增的 api, 简单来说就是父组件中通过</span><code class="ne-code"><span class="ne-text">provide</span></code><span class="ne-text">来提供变量, 然后再子组件中通过</span><code class="ne-code"><span class="ne-text">inject</span></code><span class="ne-text">来注入变量。</span></li><li id="uabe6780d" data-lake-index-type="0"><span class="ne-text">这里不论子组件嵌套有多深, 只要调用了</span><code class="ne-code"><span class="ne-text">inject</span></code><span class="ne-text"> 那么就可以注入</span><code class="ne-code"><span class="ne-text">provide</span></code><span class="ne-text">中的数据，而不局限于只能从当前父组件的 props 属性中回去数据</span></li></ol><p id="u660343e9" class="ne-p"><span class="ne-text"></span></p><p id="7c7f50d376751d2fe628d85ee09618ef_p_47" class="ne-p"><span class="ne-text">假设有三个组件: A.vue、B.vue、C.vue 其中 C 是 B 的子组件，B 是 A 的子组件</span></p><pre><code><code>&lt;!-- A.vue --&gt;&lt;template&gt;  &lt;div&gt;    &lt;comB&gt;&lt;/comB&gt;  &lt;/div&gt;&lt;/template&gt;<p>&lt;script&gt;<br>  import comB from ‘../components/test/comB.vue’<br>  export default &#123;<br>    name: &quot;A&quot;,<br>    provide: &#123;<br>      for: &quot;demo&quot;<br>    &#125;,<br>    components:&#123;<br>      comB<br>    &#125;<br>  &#125;<br>&lt;/script&gt;</code><br></code></pre></p><pre><code><code>&lt;!-- B.vue --&gt;&lt;template&gt;  &lt;div&gt;    &#123;&#123;demo&#125;&#125;    &lt;comC&gt;&lt;/comC&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;  import comC from '../components/test/comC.vue'  export default &#123;    name: &quot;B&quot;,    inject: ['for'],    data() &#123;      return &#123;        demo: this.for      &#125;    &#125;,    components: &#123;      comC    &#125;  &#125;&lt;/script&gt;</code></code></pre><pre><code><code>&lt;!-- C.vue --&gt;&lt;template&gt;  &lt;div&gt;    &#123;&#123;demo&#125;&#125;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;  export default &#123;    name: &quot;C&quot;,    inject: ['for'],    data() &#123;      return &#123;        demo: this.for      &#125;    &#125;  &#125;&lt;/script&gt;</code></code></pre><h2 id="ZNDHX"><span class="ne-text">四、$ref / $refs</span></h2><ol class="ne-ol"><li id="u796b5746" data-lake-index-type="0"><span class="ne-text">v-for 用于元素或组件时,引用信息将是</span><strong><span class="ne-text">包含 DOM 节点或组件实例的数组，</span></strong><span class="ne-text">按照这个理解，可以直接利用$refs来获取dom元素</span></li></ol><pre><code><code>this.$refs.addAlert.style.display = &quot;block&quot;;</code></code></pre><ol start="2" class="ne-ol"><li id="u51830fc2" data-lake-index-type="0"><span class="ne-text">$refs只会在组件渲染完成之后生效，并且它们不是响应式的。这仅作为一个用于直接操作子组件的“逃生舱”——你应该避免在模板或计算属性中访问$refs。这是官方说法，提倡props来操作，缺点就是非响应式的</span></li><li id="ufbf03f96" data-lake-index-type="0"><span class="ne-text">ref 本身是作为渲染结果被创建的，在初始渲染的时候你不能访问它们 - 它们还不存在！$refs 也不是响应式的，因此你不应该试图用它在模板中做数据绑定。</span></li></ol><h3 id="yutzL"><span class="ne-text">vue2</span></h3><p id="1072ea36c24eecae31028b57db98b711_p_51" class="ne-p"><code class="ne-code"><span class="ne-text">ref</span></code><span class="ne-text">：如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素；如果用在子组件上，引用就指向组件实例，可以通过实例直接调用组件的方法或访问数据， 我们看一个</span><code class="ne-code"><span class="ne-text">ref</span></code><span class="ne-text"> 来访问组件的例子:</span></p><pre><code><code>&lt;!-- 父组件 app.vue --&gt;&lt;template&gt;  &lt;component-a ref=&quot;comA&quot;&gt;&lt;/component-a&gt;&lt;/template&gt;<p>&lt;script&gt;<br>  export default &#123;<br>    mounted () &#123;<br>      const comA = this.$refs.comA;<br>      console.log(comA.name);  // Vue.js<br>      comA.sayHello();  // hello<br>    &#125;<br>  &#125;<br>&lt;/script&gt;</code><br></code></pre></p><pre><code><code>&lt;!-- 子组件 A.vue --&gt;&lt;template&gt;  &lt;div&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;  export default &#123;    data () &#123;      return &#123;        name: 'Vue.js'      &#125;    &#125;,    methods: &#123;      sayHello () &#123;        console.log('hello')      &#125;    &#125;  &#125;&lt;/script&gt;</code></code></pre><h3 id="sqXaw"><span class="ne-text">和v-for共使用</span></h3><p id="u22aa1746" class="ne-p"><span class="ne-text">遇到过这个场景，在父组件里面需要多次渲染子组件</span></p><pre><code><code>&lt;template&gt;  &lt;!-- 直播绑定 --&gt;  &lt;div slot=&quot;liveBind&quot;&gt;    &lt;AddLiveBindItem      v-for=&quot;(data, index) in datas&quot;      :key=&quot;data.id&quot;      :dataConfig=&quot;data.dataConfig&quot;      :isFirst=&quot;index === 0 ? true : false&quot;      :liveBindId=&quot;      index === 0      ? 1      : index === 1      ? 2      : index === 2      ? 3      : index === 3      ? 4      : index === 4      ? 5      : 6      &quot;      @toDeleteLiveBind=&quot;toDeleteLiveBind(index)&quot;      ref=&quot;addLiveBindRef&quot;      /&gt;  &lt;/div&gt;&lt;/template&gt;</code></code></pre><p id="uae784a6c" class="ne-p"><span class="ne-text">具体使用：下面第四行代码</span></p><pre><code><code>this.datas.forEach((_it, index) =&gt; &#123;  // 当前表单的配置项遍历上传  liveRelationList.push(    this.$refs.addLiveBindRef[index].liveBindApiParams  )  // 上传sort参数  liveRelationList[liveRelationList.length - 1].sort = _it.id&#125;)</code></code></pre><h2 id="fSF87"><span class="ne-text">五、eventBus</span></h2><ol class="ne-ol"><li id="uee6f266a" data-lake-index-type="0"><code class="ne-code"><span class="ne-text">eventBus</span></code><span class="ne-text"> 又称为事件总线，在 vue 中可以使用它来作为沟通桥梁的概念, 就像是所有组件共用相同的事件中心，可以向该中心</span><strong><span class="ne-text">注册发送事件</span></strong><span class="ne-text">或</span><strong><span class="ne-text">接收事件</span></strong><span class="ne-text">， 所以</span><strong><span class="ne-text">组件都可以通知其他组件</span></strong><span class="ne-text">。</span></li><li id="u44cfcc52" data-lake-index-type="0"><span class="ne-text">eventBus 也有不方便之处, 当项目较大, 就容易造成难以维护的灾难</span></li></ol><h3 id="qrjji"><span class="ne-text">1. 初始化</span></h3><p id="ae2699b2afa224478e7e6cc93d0dda54_p_62" class="ne-p"><span class="ne-text">首先需要创建一个事件总线并将其导出, 以便其他模块可以使用或者监听它.</span></p><pre><code><code>// event-bus.jsimport Vue from 'vue'export const EventBus = new Vue()</code></code></pre><p id="2a81d6eed31dfd1dc3c193bbdb75c1a1_p_65" class="ne-p"><br></p><p id="98de67513ec537a79ef3aa695ade51aa_p_66" class="ne-p"><span class="ne-text">假设你有两个组件: </span><code class="ne-code"><span class="ne-text">additionNum</span></code><span class="ne-text"> 和 </span><code class="ne-code"><span class="ne-text">showNum</span></code><span class="ne-text">, 这两个组件可以是兄弟组件也可以是父子组件；这里我们以兄弟组件为例:</span></p><pre><code><code>&lt;template&gt;  &lt;div&gt;    &lt;show-num-com&gt;&lt;/show-num-com&gt;    &lt;addition-num-com&gt;&lt;/addition-num-com&gt;  &lt;/div&gt;&lt;/template&gt;<p>&lt;script&gt;<br>import showNumCom from ‘./showNum.vue’<br>import additionNumCom from ‘./additionNum.vue’<br>export default &#123;<br>  components: &#123; showNumCom, additionNumCom &#125;<br>&#125;<br>&lt;/script&gt;<br></code><br></code></pre></p><h3 id="mSrTk"><span class="ne-text">2. 发送事件</span></h3><pre><code><code>&lt;!-- addtionNum.vue 中发送事件 --&gt;&lt;template&gt;  &lt;div&gt;    &lt;button @click=&quot;additionHandle&quot;&gt;+加法器&lt;/button&gt;      &lt;/div&gt;&lt;/template&gt;<p>&lt;script&gt;<br>import &#123;EventBus&#125; from ‘./event-bus.js’<br>console.log(EventBus)<br>export default &#123;<br>  data()&#123;<br>    return&#123;<br>      num:1<br>    &#125;<br>  &#125;,</p><p>  methods:&#123;<br>    additionHandle()&#123;<br>      EventBus.$emit(‘addition’, &#123;<br>        num:this.num++<br>      &#125;)<br>    &#125;<br>  &#125;<br>&#125;<br>&lt;/script&gt;</code><br></code></pre></p><h3 id="CTmwX"><span class="ne-text">3. 接收事件</span></h3><pre><code><code>&lt;!-- showNum.vue 中接收事件 --&gt;&lt;template&gt;  &lt;div&gt;计算和: &#123;&#123;count&#125;&#125;&lt;/div&gt;&lt;/template&gt;<p>&lt;script&gt;<br>import &#123; EventBus &#125; from ‘./event-bus.js’<br>export default &#123;<br>  data() &#123;<br>    return &#123;<br>      count: 0<br>    &#125;<br>  &#125;,<br>  mounted() &#123;<br>    EventBus.$on(‘addition’, param =&gt; &#123;<br>      this.count = this.count + param.num;<br>    &#125;)<br>  &#125;<br>&#125;<br>&lt;/script&gt;</code><br></code></pre></p><p id="854f22ccbc720f4f25f3f1e4fbae5cf0_p_71" class="ne-p"><span class="ne-text">这样就实现了在组件</span><code class="ne-code"><span class="ne-text">addtionNum.vue</span></code><span class="ne-text">中点击相加按钮, 在</span><code class="ne-code"><span class="ne-text">showNum.vue</span></code><span class="ne-text">中利用传递来的 </span><code class="ne-code"><span class="ne-text">num</span></code><span class="ne-text"> 展示求和的结果.</span></p><h3 id="D8K5d"><span class="ne-text">4. 移除事件监听者</span></h3><p id="017aded1276858df53bbac28c927111b_p_74" class="ne-p"><span class="ne-text">如果想移除事件的监听, 可以像下面这样操作:</span></p><pre><code><code>import &#123; eventBus &#125; from 'event-bus.js'EventBus.$off('addition', &#123;&#125;)</code></code></pre><h2 id="FvhVC"><span class="ne-text">六、Vuex</span></h2><h3 id="IAleg"><span class="ne-text">1. Vuex 介绍</span></h3><p id="f31764caf4edb6337889991729dab76f_p_79" class="ne-p"><span class="ne-text">Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化. Vuex 解决了</span><code class="ne-code"><span class="ne-text">多个视图依赖于同一状态</span></code><span class="ne-text">和</span><code class="ne-code"><span class="ne-text">来自不同视图的行为需要变更同一状态</span></code><span class="ne-text">的问题，将开发者的精力聚焦于数据的更新而不是数据在组件之间的传递上</span></p><h3 id="NOLew"><span class="ne-text">2. Vuex 各个模块</span></h3><ol class="ne-ol"><li id="086fc566ad1f3e20b5c4075a7729ead3_li_2" data-lake-index-type="0"><code class="ne-code"><span class="ne-text">state</span></code><span class="ne-text">：用于数据的存储，是 store 中的唯一数据源</span></li></ol><ol start="2" class="ne-ol"><li id="8f90ea99e20515a11d0d1c9f1f7e0553_li_3" data-lake-index-type="0"><code class="ne-code"><span class="ne-text">getters</span></code><span class="ne-text">：如 vue 中的计算属性一样，基于 state 数据的二次包装，常用于数据的筛选和多个数据的相关性计算</span></li></ol><ol start="3" class="ne-ol"><li id="e6273b5a39a57288e5a1a89f2bc1fcfe_li_4" data-lake-index-type="0"><code class="ne-code"><span class="ne-text">mutations</span></code><span class="ne-text">：类似函数，改变 state 数据的唯一途径，且不能用于处理异步事件</span></li></ol><ol start="4" class="ne-ol"><li id="a7a27b1b632925547190afbe9ad7fb4b_li_5" data-lake-index-type="0"><code class="ne-code"><span class="ne-text">actions</span></code><span class="ne-text">：类似于</span><code class="ne-code"><span class="ne-text">mutation</span></code><span class="ne-text">，用于提交</span><code class="ne-code"><span class="ne-text">mutation</span></code><span class="ne-text">来改变状态，而不直接变更状态，可以包含任意异步操作</span></li></ol><ol start="5" class="ne-ol"><li id="d03ef67930c7afc0424138385fa658e8_li_6" data-lake-index-type="0"><code class="ne-code"><span class="ne-text">modules</span></code><span class="ne-text">：类似于命名空间，用于项目中将各个模块的状态分开定义和操作，便于维护</span></li></ol><h3 id="UpZvv"><span class="ne-text">3. Vuex 实例应用</span></h3><pre><code><code>&lt;!-- 父组件 --&gt;&lt;template&gt;  &lt;div id=&quot;app&quot;&gt;    &lt;ChildA/&gt;    &lt;ChildB/&gt;  &lt;/div&gt;&lt;/template&gt;<p>&lt;script&gt;<br>  import ChildA from ‘./components/ChildA’ // 导入A组件<br>  import ChildB from ‘./components/ChildB’ // 导入B组件</p><p>  export default &#123;<br>    name: ‘App’,<br>    components: &#123;ChildA, ChildB&#125; // 注册A、B组件<br>  &#125;<br>&lt;/script&gt;</code><br></code></pre></p><pre><code><code>&lt;!-- 子组件childA --&gt;&lt;template&gt;  &lt;div id=&quot;childA&quot;&gt;    &lt;h1&gt;我是A组件&lt;/h1&gt;    &lt;button @click=&quot;transform&quot;&gt;点我让B组件接收到数据&lt;/button&gt;    &lt;p&gt;因为你点了B，所以我的信息发生了变化：&#123;&#123;BMessage&#125;&#125;&lt;/p&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;  export default &#123;    data() &#123;      return &#123;        AMessage: 'Hello，B组件，我是A组件'      &#125;    &#125;,    computed: &#123;      BMessage() &#123;        // 这里存储从store里获取的B组件的数据        return this.$store.state.BMsg      &#125;    &#125;,    methods: &#123;      transform() &#123;        // 触发receiveAMsg，将A组件的数据存放到store里去        this.$store.commit('receiveAMsg', &#123;          AMsg: this.AMessage        &#125;)      &#125;    &#125;  &#125;&lt;/script&gt;</code></code></pre><pre><code><code>&lt;!-- 子组件 childB --&gt;&lt;template&gt;  &lt;div id=&quot;childB&quot;&gt;    &lt;h1&gt;我是B组件&lt;/h1&gt;    &lt;button @click=&quot;transform&quot;&gt;点我让A组件接收到数据&lt;/button&gt;    &lt;p&gt;因为你点了A，所以我的信息发生了变化：&#123;&#123;AMessage&#125;&#125;&lt;/p&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;  export default &#123;    data() &#123;      return &#123;        BMessage: 'Hello，A组件，我是B组件'      &#125;    &#125;,    computed: &#123;      AMessage() &#123;        // 这里存储从store里获取的A组件的数据        return this.$store.state.AMsg      &#125;    &#125;,    methods: &#123;      transform() &#123;        // 触发receiveBMsg，将B组件的数据存放到store里去        this.$store.commit('receiveBMsg', &#123;          BMsg: this.BMessage        &#125;)      &#125;    &#125;  &#125;&lt;/script&gt;</code></code></pre><p id="d2ef17a7a18d8c7e67af8d1ea686174e_p_85" class="ne-p"><span class="ne-text">vuex 的</span><code class="ne-code"><span class="ne-text">store,js</span></code></p><pre><code><code>import Vue from 'vue'import Vuex from 'vuex'Vue.use(Vuex)const state = &#123;  // 初始化A和B组件的数据，等待获取  AMsg: '',  BMsg: ''&#125;<p>const mutations = &#123;<br>  receiveAMsg(state, payload) &#123;<br>    // 将A组件的数据存放于state<br>    state.AMsg = payload.AMsg<br>  &#125;,<br>  receiveBMsg(state, payload) &#123;<br>    // 将B组件的数据存放于state<br>    state.BMsg = payload.BMsg<br>  &#125;<br>&#125;</p><p>export default new Vuex.Store(&#123;<br>  state,<br>  mutations<br>&#125;)</code><br></code></pre></p><h2 id="PCidf"><span class="ne-text">七、localStorage / sessionStorage</span></h2><p id="uecdfce57" class="ne-p"><span class="ne-text">这种通信比较简单, 缺点是数据和状态比较混乱, 不太容易维护。 通过</span><code class="ne-code"><span class="ne-text">window.localStorage.getItem(key)</span></code><span class="ne-text">获取数据 通过</span><code class="ne-code"><span class="ne-text">window.localStorage.setItem(key,value)</span></code><span class="ne-text">存储数据</span></p><div class="ne-quote"><p id="5f8a28e0e191bf5002124d4728a6494d_p_91" class="ne-p"><span class="ne-text">注意用</span><code class="ne-code"><span class="ne-text">JSON.parse()</span></code><span class="ne-text"> / </span><code class="ne-code"><span class="ne-text">JSON.stringify()</span></code><span class="ne-text"> 做数据格式转换（localStorage和sessionStorage只能存字符串，会自动调用对象的toString方法）</span></p><p id="udd314bb5" class="ne-p"><span class="ne-text"> </span><code class="ne-code"><span class="ne-text">localStorage</span></code><span class="ne-text"> / </span><code class="ne-code"><span class="ne-text">sessionStorage</span></code><span class="ne-text">可以结合</span><code class="ne-code"><span class="ne-text">vuex</span></code><span class="ne-text">, 实现数据的持久保存, 同时使用 </span><code class="ne-code"><span class="ne-text">vuex</span></code><span class="ne-text">解决数据和状态混乱问题.</span></p></div><pre><code><code>// 存取sessionStorage.setItem(  'sortColumn',  JSON.stringify(&#123; prop: column.prop, order: column.order &#125;))<p>// 使用<br>this.sortColumnSession = JSON.parse(<br>    sessionStorage.getItem(‘sortColumn’)<br>)</code><br></code></pre></p><h2 id="tVBCj"><span class="ne-text">八 $attrs与 $listeners</span></h2><p id="5ee232d8069a64f0310d67c6cba2c264_p_94" class="ne-p"><span class="ne-text">现在我们来讨论一种情况， 我们一开始给出的组件关系图中 A 组件与 D 组件是隔代关系， 那它们之前进行通信有哪些方式呢？</span></p><ol class="ne-ol"><li id="83215d9ee7c1694d1bc3e76f305d7e9e_li_7" data-lake-index-type="0"><span class="ne-text">使用</span><code class="ne-code"><span class="ne-text">props</span></code><span class="ne-text">绑定来进行一级一级的信息传递, 如果 D 组件中状态改变需要传递数据给 A, 使用事件系统一级级往上传递</span></li></ol><ol start="2" class="ne-ol"><li id="2c686f3d4e49b6f903a7a060cca635e2_li_8" data-lake-index-type="0"><span class="ne-text">使用</span><code class="ne-code"><span class="ne-text">eventBus</span></code><span class="ne-text">, 这种情况下还是比较适合使用, 但是碰到多人合作开发时, 代码维护性较低, 可读性也低</span></li></ol><ol start="3" class="ne-ol"><li id="1adc8d2e29da201c9f819b96e079ce85_li_9" data-lake-index-type="0"><span class="ne-text">使用 Vuex 来进行数据管理, 但是如果仅仅是传递数据, 而不做中间处理, 使用 Vuex 处理感觉有点大材小用了.</span></li></ol><p id="1660fc758c7e386ee6c1caa5c0ba61fd_p_97" class="ne-p"><span class="ne-text">在</span><code class="ne-code"><span class="ne-text">vue2.4</span></code><span class="ne-text">中，为了解决该需求，引入了</span><code class="ne-code"><span class="ne-text">$attrs</span></code><span class="ne-text"> 和</span><code class="ne-code"><span class="ne-text">$listeners</span></code><span class="ne-text"> ， 新增了</span><code class="ne-code"><span class="ne-text">inheritAttrs</span></code><span class="ne-text"> 选项。 在版本 2.4 以前，默认情况下, 父作用域中不作为 prop 被识别 (且获取) 的特性绑定 (class 和 style 除外)，将会 “回退” 且作为普通的 HTML 特性应用在子组件的根元素上。接下来看一个跨级通信的例子:</span></p><pre><code><code>&lt;!-- app.vue --&gt;&lt;!-- index.vue --&gt;&lt;template&gt;  &lt;div&gt;    &lt;child-com1      :name=&quot;name&quot;      :age=&quot;age&quot;      :gender=&quot;gender&quot;      :height=&quot;height&quot;      title=&quot;程序员成长指北&quot;    &gt;&lt;/child-com1&gt;  &lt;/div&gt;&lt;/template&gt;<p>&lt;script&gt;<br>const childCom1 = () =&gt; import(&quot;./childCom1.vue&quot;);<br>export default &#123;<br>  components: &#123; childCom1 &#125;,<br>  data() &#123;<br>    return &#123;<br>      name: &quot;zhang&quot;,<br>      age: &quot;18&quot;,<br>      gender: &quot;女&quot;,<br>      height: &quot;158&quot;<br>    &#125;;<br>  &#125;<br>&#125;;<br>&lt;/script&gt;</code><br></code></pre></p><pre><code><code>&lt;!-- childCom1.vue --&gt;&lt;template class=&quot;border&quot;&gt;  &lt;div&gt;    &lt;p&gt;name: &#123;&#123; name&#125;&#125;&lt;/p&gt;    &lt;p&gt;childCom1的$attrs: &#123;&#123; $attrs &#125;&#125;&lt;/p&gt;    &lt;child-com2 v-bind=&quot;$attrs&quot;&gt;&lt;/child-com2&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;  const childCom2 = () =&gt; import(&quot;./childCom2.vue&quot;);  export default &#123;    components: &#123;      childCom2    &#125;,    inheritAttrs: false, // 可以关闭自动挂载到组件根元素上的没有在props声明的属性    props: &#123;      name: String // name作为props属性绑定    &#125;,    created() &#123;      console.log(this.$attrs);      // &#123; &quot;age&quot;: &quot;18&quot;, &quot;gender&quot;: &quot;女&quot;, &quot;height&quot;: &quot;158&quot;, &quot;title&quot;: &quot;程序员成长指北&quot; &#125;    &#125;  &#125;;&lt;/script&gt;</code></code></pre><pre><code><code>&lt;!-- childCom2.vue --&gt;&lt;template&gt;  &lt;div class=&quot;border&quot;&gt;    &lt;p&gt;age: &#123;&#123; age&#125;&#125;&lt;/p&gt;    &lt;p&gt;childCom2: &#123;&#123; $attrs &#125;&#125;&lt;/p&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;  export default &#123;    inheritAttrs: false,    props: &#123;      age: String    &#125;,    created() &#123;      console.log(this.$attrs);       // &#123; &quot;gender&quot;: &quot;女&quot;, &quot;height&quot;: &quot;158&quot;, &quot;title&quot;: &quot;程序员成长指北&quot; &#125;    &#125;  &#125;;&lt;/script&gt;</code></code></pre><h2 id="d3gur"><span class="ne-text">总结</span></h2><p id="d1dd1ab4b6c9dd3f0d10d775396b2c46_p_101" class="ne-p"><span class="ne-text">常见使用场景可以分为三类:</span></p><ul class="ne-ul"><li id="38d84b7f285f00e4e99192b24cdc3891_li_10" data-lake-index-type="0"><span class="ne-text">父子组件通信: </span><code class="ne-code"><span class="ne-text">props</span></code><span class="ne-text">; </span><code class="ne-code"><span class="ne-text">$parent</span></code><span class="ne-text"> / </span><code class="ne-code"><span class="ne-text">$children</span></code><span class="ne-text">; </span><code class="ne-code"><span class="ne-text">provide</span></code><span class="ne-text"> / </span><code class="ne-code"><span class="ne-text">inject</span></code><span class="ne-text"> ; </span><code class="ne-code"><span class="ne-text">ref</span></code><span class="ne-text"> ; </span><code class="ne-code"><span class="ne-text">$attrs</span></code><span class="ne-text"> / </span><code class="ne-code"><span class="ne-text">$listeners</span></code></li></ul><ul class="ne-ul"><li id="3e789b8578fdd7d181db9f576fa76889_li_11" data-lake-index-type="0"><span class="ne-text">兄弟组件通信: </span><code class="ne-code"><span class="ne-text">eventBus</span></code><span class="ne-text"> ; vuex</span></li></ul><ul class="ne-ul"><li id="e10c2c9737bf8956c62733553c8b2e96_li_12" data-lake-index-type="0"><span class="ne-text">跨级通信: </span><code class="ne-code"><span class="ne-text">eventBus</span></code><span class="ne-text">；Vuex；</span><code class="ne-code"><span class="ne-text">provide</span></code><span class="ne-text"> / </span><code class="ne-code"><span class="ne-text">inject</span></code><span class="ne-text"> 、</span><code class="ne-code"><span class="ne-text">$attrs</span></code><span class="ne-text"> / </span><code class="ne-code"><span class="ne-text">$listeners</span></code></li></ul><h3 id="Slz4b"><span class="ne-text">Conference</span></h3><ul class="ne-ul"><li id="uf0c5f17a" data-lake-index-type="0"><a href="https://juejin.cn/post/6844903887162310669" data-href="https://juejin.cn/post/6844903887162310669" class="ne-link"><span class="ne-text">vue中8种组件通信方式, 值得收藏! - 掘金</span></a></li></ul><p id="de46638becbf26f6c7e35f22ece99363_p_108" class="ne-p"><span class="ne-text"><br /></span></p></div>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
          <category> Vue </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>国庆随笔：向死而生</title>
      <link href="/essay/gqoawl/"/>
      <url>/essay/gqoawl/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="ua3dca230" class="ne-p"><span class="ne-text">国庆小随笔</span></p><h2 id="SAZEt"><span class="ne-text">十月五号</span></h2><p id="u5399fbea" class="ne-p"><span class="ne-text">姐姐结婚，爱情是什么样的，我们谁都不得而知，我自认为自己最难懂的就是爱情，从爱情走向婚姻，我觉得是最幸福的事情。</span></p><p id="u49f2a180" class="ne-p"><br></p><h2 id="uJrCV"><span class="ne-text">十月六号</span></h2><p id="ue64801e2" class="ne-p"><br></p><h3 id="rS15r"><span class="ne-text">曾视为空城的那个鄱阳</span></h3><p id="u917356c4" class="ne-p"><span class="ne-text"></span></p><p id="u0d0a9142" class="ne-p"><span class="ne-text">和两个兄弟去了趟鄱阳，那个我曾经视为空城的一个小城，东湖大道那座小桥现已修建名为文正桥，桥是宽阔了许多，不过我还是些许留恋曾经两旁有参天大树的桥道。</span></p><p id="uf89817c9" class="ne-p"><br></p><p id="u268a3f3c" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1633875808473-8c8e729a-95e5-4cc1-9569-75ebeb9ec25e.jpeg" width="3648" id="ua8c982bd" class="ne-image"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1633875807952-96f55875-30da-431c-98dd-76ee3ae331e0.jpeg" width="3648" id="u77239b62" class="ne-image"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1633875809760-4dffcacf-688d-439e-9f71-a2a3245b26dd.jpeg" width="2736" id="ufe07eabd" class="ne-image"></p><p id="u3098a4ec" class="ne-p"><br></p><h3 id="xDvQq"><span class="ne-text">饶州古镇</span></h3><p id="u3a36902f" class="ne-p"><span class="ne-text"></span></p><p id="uc4d62a20" class="ne-p"><span class="ne-text">自家有这么一个古镇景点，还是很不错的</span></p><p id="u6018850f" class="ne-p"><span class="ne-text"></span></p><p id="u3fd40eba" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1633875997616-e683f592-bb92-4ca9-93d0-67a3712df0b5.jpeg" width="3648" id="u01295dec" class="ne-image"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1633875998381-311af713-f841-4c55-852c-8f92a72749bc.jpeg" width="3648" id="u05d7c963" class="ne-image"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1633875998279-4cdfbe6b-42b1-42bc-81a1-073a7b3830d8.jpeg" width="3840" id="uddde3c37" class="ne-image"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1633875997897-10bf7687-e99e-4f1a-b67d-c6614ece8bca.jpeg" width="3648" id="u7fb6ebc3" class="ne-image"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1633875998399-1534eab0-3711-47d1-886f-4a309f9d9273.jpeg" width="3648" id="ud64bd0a4" class="ne-image"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1633876002155-627bd9d7-39ea-41a4-a82a-4ad9992056c4.jpeg" width="3648" id="ufa00a8a2" class="ne-image"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1633876002241-35379903-c302-4e54-bb58-439786ff4470.jpeg" width="3648" id="u06167c90" class="ne-image"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1633876002731-e1bb0cc3-48c4-45e0-8895-9d435b1e04fe.jpeg" width="3648" id="u625ac0a3" class="ne-image"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1633876002769-34025c83-0fd7-4f24-8ea9-e32f86b94677.jpeg" width="3648" id="u08140798" class="ne-image"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1633876001841-3bfc9710-8031-4cc4-a930-6a60bcb456f7.jpeg" width="3648" id="u582a5e29" class="ne-image"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1633876005039-78bec731-e419-471b-b1d3-5078abd8f32f.jpeg" width="3648" id="uc786dce9" class="ne-image"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1633876005917-cc7d5d1f-8813-41c8-8392-24b446712922.jpeg" width="3648" id="u00e0504d" class="ne-image"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1633876006650-1cf3f393-472d-4af3-910a-454b98599755.jpeg" width="3648" id="u08504088" class="ne-image"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1633876006744-f7a8a89f-a970-4e04-a891-c257f9e67160.jpeg" width="3840" id="u00a090b1" class="ne-image"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1633876009430-86c16483-95dc-4fea-b6ef-5b6429e0a532.jpeg" width="3648" id="ue1f27166" class="ne-image"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1633876009245-da7f7e0a-bfdb-484c-aaac-3b1d666cc25b.jpeg" width="3648" id="u60e30b2c" class="ne-image"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1633876010297-9e5a9f09-53fd-4fe0-8cfd-26fd6a69c87a.jpeg" width="3648" id="u81b81119" class="ne-image"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1633876011269-cf89a74b-13f0-4381-8754-2be7b8cdcf23.jpeg" width="2736" id="u9acd5f62" class="ne-image"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1633876011280-e399e628-809e-4668-a49b-9241c6f3409a.jpeg" width="2736" id="uf29ce6cc" class="ne-image"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1633876013616-b2afe4f8-587b-44d7-871f-f508124584f5.jpeg" width="3648" id="ud0599d64" class="ne-image"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1633876014575-2e2702c5-4cf3-461d-a2b0-c4024a95ac8f.jpeg" width="3648" id="ua104b296" class="ne-image"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1633876014664-975619ee-cd95-44c4-bfd5-a6e32201fc89.jpeg" width="3648" id="u750f8321" class="ne-image"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1633876015648-67768ec5-5d69-40c5-b96a-464e6ba3d913.jpeg" width="2736" id="ud452a52b" class="ne-image"></p><p id="u78b81c6b" class="ne-p"><span class="ne-text"></span></p><p id="uf6357425" class="ne-p"><span class="ne-text"></span></p><h2 id="lHMbd"><span class="ne-text">十月七号</span></h2><p id="u498da28b" class="ne-p"><span class="ne-text">生活节奏太快，想了想，想停下来写写走走看看，于是七号在家中，八号再去公司</span></p><p id="ueebbc9ea" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/gif/1484158/1649041952673-600e4ad8-231b-491a-b1ba-ada6a2c0ee31.gif" width="218" id="nzi5z" class="ne-image"></p><p id="u4cadfe56" class="ne-p"><br></p><h2 id="jrF6C"><span class="ne-text">十月八号</span></h2><p id="ua18e6642" class="ne-p"><br></p><h3 id="iiGzJ"><span class="ne-text">珠海版“人在囧途”</span></h3><p id="u2400248c" class="ne-p"><span class="ne-text"></span></p><p id="u0cf50ffa" class="ne-p"><span class="ne-text">返珠海，上演一段真正的人在囧途，没有遇到</span></p><p id="u51ac14be" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1633876494701-40bf091b-6af2-41bc-b108-ce3580a8e3b1.jpeg" width="3648" id="uf020ab48" class="ne-image"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1633876495028-16dcd228-d572-4658-9626-6a4a169162a0.jpeg" width="3648" id="uc21583b3" class="ne-image"></p><p id="uafcc1f5e" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1633876843288-1bd256a2-fd14-49a3-b8b2-b21ac3f050af.jpeg" width="1176" id="uf549968e" class="ne-image"></p><p id="u0bcc6009" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1633876844529-f7c4bd92-d9b2-495c-9309-6a671a860134.jpeg" width="2736" id="QEJAx" class="ne-image"></p><p id="u7d40d1db" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1633877452207-23cc8796-b4a5-4675-a283-e520384354b8.jpeg" width="2736" id="u89faf5ba" class="ne-image"></p><p id="ucb84ab3e" class="ne-p"><span class="ne-text"></span></p><h2 id="Eae3s"><span class="ne-text">十月九号</span></h2><p id="ua7267adc" class="ne-p"><span class="ne-text">四点钟被叫醒，说是去赶车，我太难了，假期到现在，每天都在早起，每天都在出行的路上，你要说我现在渴望些什么，我只想吃点粥啥的暖暖胃，然后再好好睡上一觉～</span></p><p id="u527f4d47" class="ne-p"><span class="ne-text"></span></p><p id="uee7179be" class="ne-p"><span class="ne-text">生活或许就是有时该为了活着而活着，而在关键时刻又需要向死而生的一种魄力。</span></p></div>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>PC端hevc编码的MOV格式视频无法查看</title>
      <link href="/blog/akf33e/"/>
      <url>/blog/akf33e/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="u1b5b6b57" class="ne-p"><span class="ne-text">前言：需求中有这么一个问题，部分mov格式的视频在移动端可以播放，但在pc客户端无法显示，对比能播放和不能播放的mov格式视频，发现是hevc编码的mov视频不能播放，对此在做需求过程中，寻求并尝试了一些方法来解决这个问题，在本文做个记录。</span></p><p id="u39e05545" class="ne-p"><span class="ne-text"></span></p><div class="ne-quote"><ol class="ne-ol"><li id="u6ee0e089" data-lake-index-type="0"><span class="ne-text">MOV合适视频是苹果手机拍摄的视频格式</span></li><li id="ucb6b1b39" data-lake-index-type="0"><span class="ne-text">苹果拍照的视频和苹果利用api调用的拍照的视频，这两者拍的视频编码是有差异的</span></li></ol></div><h2 id="aCbsI"><span class="ne-text">一、两者视频元信息比较</span></h2><p id="u6cb5301e" class="ne-p"><span class="ne-text">所用例子：</span></p><ul class="ne-ul"><li id="uc9188c46" data-lake-index-type="0"><a href="https://image.x7sy.com/oa_medias/65440114717__69E1A426-97B2-4832-95FC-7712D9D7A487-16327083586676.MOV" data-href="https://image.x7sy.com/oa_medias/65440114717__69E1A426-97B2-4832-95FC-7712D9D7A487-16327083586676.MOV" target="_blank" class="ne-link"><span class="ne-text">非hevc编码视频例子</span></a></li><li id="uee54ac6e" data-lake-index-type="0"><a href="https://image.x7sy.com/oa_medias/IMG_0018-16327078428771.MOV" data-href="https://image.x7sy.com/oa_medias/IMG_0018-16327078428771.MOV" target="_blank" class="ne-link"><span class="ne-text">hevc编码视频例子</span></a></li></ul><p id="u35ea3340" class="ne-p"><br></p><p id="u9a3f6e9b" class="ne-p"><span class="ne-text">利用格式工厂查看两个视频的元信息：</span></p><p id="u26dd80de" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1636168657171-19788f71-f632-44cc-9e62-0e6d9f206379.png" width="825" id="u318798b8" class="ne-image"></p><p id="uefc9da5c" class="ne-p"><span class="ne-text">利用上面的信息以及实际的可播放效果得：</span></p><ul class="ne-ul"><li id="u66d4ca2a" data-lake-index-type="0"><span class="ne-text">mobile：都能看（安卓和苹果）</span></li><li id="u37f0e1b2" data-lake-index-type="0"><span class="ne-text">pc：不能看上传的，</span><strong><span class="ne-text">hevc编码的不能解码</span></strong><span class="ne-text">？移动端相较pc能处理hevc编码？</span></li></ul><h2 id="Mg1QX"><span class="ne-text">二、HEVC、H.265兼容性支持情况</span></h2><p id="uaa976dd2" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1632730222885-c5d08df9-afdf-4b78-85fa-9003cb6b47b2.png" width="568.5" id="u07c0c94a" class="ne-image"></p><p id="u19280f6a" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1632730253372-9f6e0c9d-03c5-4685-ada6-d68306266653.png" width="570.5" id="u940ac543" class="ne-image"></p><p id="uf59796a1" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1636168806126-ed5989be-ca1f-455c-a434-b0fbe89bca94.png" width="888.5" id="ue461184a" class="ne-image"></p><p id="u76eaa99a" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1632885246692-38ce1a86-66eb-4d5e-8e91-ff2c48a65f4e.png" width="529" id="u48fdcb25" class="ne-image"></p><p id="u351c1cbd" class="ne-p"><span class="ne-text">参考方案：</span></p><ul class="ne-ul"><li id="ue429d104" data-lake-index-type="0"><a href="https://blog.csdn.net/yanrx76/article/details/116238315" data-href="https://blog.csdn.net/yanrx76/article/details/116238315" target="_blank" class="ne-link"><strong><span class="ne-text">如何在浏览器中支持H265/HEVC</span></strong></a></li><li id="uc784faa2" data-lake-index-type="0"><a href="https://www.fdbtech.com/webfrontend/%E5%89%8D%E7%AB%AF%E5%A6%82%E4%BD%95%E6%92%AD%E6%94%BEhevch265%E7%BC%96%E7%A0%81%E7%9A%84mp4%E8%A7%86%E9%A2%91" data-href="https://www.fdbtech.com/webfrontend/%E5%89%8D%E7%AB%AF%E5%A6%82%E4%BD%95%E6%92%AD%E6%94%BEhevch265%E7%BC%96%E7%A0%81%E7%9A%84mp4%E8%A7%86%E9%A2%91" target="_blank" class="ne-link"><span class="ne-text">前端web如何播放HEVC(h265)编码的MP4视频</span></a></li><li id="u9a15c27a" data-lake-index-type="0"><a href="https://segmentfault.com/a/1190000017187346" data-href="https://segmentfault.com/a/1190000017187346" target="_blank" class="ne-link"><span class="ne-text">H.265/HEVC在Web视频播放的实践</span></a></li><li id="u464cd360" data-lake-index-type="0"><a href="https://segmentfault.com/q/1010000020081504" data-href="https://segmentfault.com/q/1010000020081504" target="_blank" class="ne-link"><span class="ne-text">video播放mov文件问题</span></a></li></ul><h2 id="nWppG"><span class="ne-text">三、解决方案</span></h2><p id="u520e30a3" class="ne-p"><span class="ne-text">下面几种方法是解决过程中所尝试的几种方法，前四种都测试未能解决该问题，最后一个方法可以。</span></p><h3 id="Fh8pH"><span class="ne-text">【弃】vue-h265-player插件使用</span></h3><ul class="ne-ul"><li id="ubd7a8f37" data-lake-index-type="0"><a href="https://www.npmjs.com/package/vue-h265-player" data-href="https://www.npmjs.com/package/vue-h265-player" target="_blank" class="ne-link"><span class="ne-text">https://www.npmjs.com/package/vue-h265-player</span></a></li><li id="u4226c89f" data-lake-index-type="0"><span class="ne-text"></span><a href="https://blog.csdn.net/Nie2014/article/details/114651376" data-href="https://blog.csdn.net/Nie2014/article/details/114651376" target="_blank" class="ne-link"><span class="ne-text">https://blog.csdn.net/Nie2014/article/details/114651376</span></a></li><li id="u3bbaae9f" data-lake-index-type="0"><a href="https://blog.csdn.net/weixin_42274114/article/details/109490633" data-href="https://blog.csdn.net/weixin_42274114/article/details/109490633" target="_blank" class="ne-link"><span class="ne-text">https://blog.csdn.net/weixin_42274114/article/details/109490633</span></a></li></ul><p id="uba12ae57" class="ne-p"><span class="ne-text" style="text-decoration: line-through">判断是否为h.265，如果是就将其用新的播放器（插件）播放</span></p><p id="u01016027" class="ne-p"><a href="https://github.com/buzz/mediainfo.js" data-href="https://github.com/buzz/mediainfo.js" target="_blank" class="ne-link"><span class="ne-text" style="text-decoration: line-through">https://github.com/buzz/mediainfo.js</span></a></p><p id="ufb9ecf27" class="ne-p"><span class="ne-text" style="text-decoration: line-through">项目中添加该api的判断代码</span></p><ul class="ne-ul"><li id="u9cebd4db" data-lake-index-type="0"><a href="https://blog.csdn.net/weixin_42274114/article/details/109490633" data-href="https://blog.csdn.net/weixin_42274114/article/details/109490633" target="_blank" class="ne-link"><span class="ne-text" style="text-decoration: line-through">https://blog.csdn.net/weixin_42274114/article/details/109490633</span></a></li><li id="uccca4d9e" data-lake-index-type="0"><a href="https://segmentfault.com/a/1190000039753551" data-href="https://segmentfault.com/a/1190000039753551" target="_blank" class="ne-link"><span class="ne-text" style="text-decoration: line-through">https://segmentfault.com/a/1190000039753551</span></a></li><li id="u0bcbeeab" data-lake-index-type="0"><a href="https://blog.csdn.net/Nie2014/article/details/114651376" data-href="https://blog.csdn.net/Nie2014/article/details/114651376" target="_blank" class="ne-link"><span class="ne-text" style="text-decoration: line-through">https://blog.csdn.net/Nie2014/article/details/114651376</span></a></li></ul><div data-type="danger" class="ne-alert"><p id="u0f44f1f5" class="ne-p"><span class="ne-text">插件源代码本身有问题</span></p></div><h3 id="gtJbk"><span class="ne-text">【弃】EasyPlayer.js插件使用</span></h3><ul class="ne-ul"><li id="u46e2d2e4" data-lake-index-type="0"><a href="https://my.oschina.net/u/4383286/blog/4496965" data-href="https://my.oschina.net/u/4383286/blog/4496965" target="_blank" class="ne-link"><span class="ne-text">https://my.oschina.net/u/4383286/blog/4496965</span></a></li><li id="uf0143acd" data-lake-index-type="0"><a href="https://github.com/tsingsee/EasyPlayer.js" data-href="https://github.com/tsingsee/EasyPlayer.js" target="_blank" class="ne-link"><span class="ne-text">https://github.com/tsingsee/EasyPlayer.js</span></a></li><li id="u3a8703ea" data-lake-index-type="0"><a href="https://blog.csdn.net/a843334549/article/details/117323709" data-href="https://blog.csdn.net/a843334549/article/details/117323709" target="_blank" class="ne-link"><span class="ne-text">https://blog.csdn.net/a843334549/article/details/117323709</span></a></li><li id="ua7d9beb3" data-lake-index-type="0"><a href="https://blog.csdn.net/u012848709/article/details/106291133" data-href="https://blog.csdn.net/u012848709/article/details/106291133" target="_blank" class="ne-link"><span class="ne-text">https://blog.csdn.net/u012848709/article/details/106291133</span></a></li><li id="uee6b716b" data-lake-index-type="0"><a href="https://www.liveqing.com/docs/manuals/LivePlayer.html#%E5%9C%A8-vue-%E4%B8%AD%E4%BD%BF%E7%94%A8" data-href="https://www.liveqing.com/docs/manuals/LivePlayer.html#%E5%9C%A8-vue-%E4%B8%AD%E4%BD%BF%E7%94%A8" target="_blank" class="ne-link"><span class="ne-text">https://www.liveqing.com/docs/manuals/LivePlayer.html#%E5%9C%A8-vue-%E4%B8%AD%E4%BD%BF%E7%94%A8</span></a></li><li id="uba291925" data-lake-index-type="0"><a href="https://gitee.com/livegbs/liveplayer-vc" data-href="https://gitee.com/livegbs/liveplayer-vc" target="_blank" class="ne-link"><span class="ne-text">https://gitee.com/livegbs/liveplayer-vc</span></a></li></ul><div data-type="danger" class="ne-alert"><p id="u01bd2388" class="ne-p"><span class="ne-text">未能播放那个苹果上传mov文件</span></p><p id="u7863f7a7" class="ne-p"><span class="ne-text">可能原因是苹果上传的mov文件(hevc)不属于该插件所解码的h.265的范围。</span></p></div><p id="u28130e96" class="ne-p"><br></p><p id="u26393f1a" class="ne-p"><strong><span class="ne-text" style="color: #F5222D">只要是hevc的格式，不管是视频还是声音，都无法播放</span></strong></p><ul class="ne-ul"><li id="u41d3a275" data-lake-index-type="0"><span class="ne-text">EasyPlayer.js插件：</span><a href="https://github.com/tsingsee/EasyPlayer.js/issues/45" data-href="https://github.com/tsingsee/EasyPlayer.js/issues/45" target="_blank" class="ne-link"><span class="ne-text">https://github.com/tsingsee/EasyPlayer.js/issues/45</span></a></li><li id="uf12732b9" data-lake-index-type="0"><span class="ne-text">原项目issues（vue-video-player插件）：</span><a href="https://github.com/surmon-china/vue-video-player/issues/232" data-href="https://github.com/surmon-china/vue-video-player/issues/232" target="_blank" class="ne-link"><span class="ne-text">https://github.com/surmon-china/vue-video-player/issues/232</span></a></li></ul><p id="ua4eaf41b" class="ne-p"><br></p><h3 id="ujwBQ"><span class="ne-text">【弃】libde265.JS解决办法</span></h3><ul class="ne-ul"><li id="u73274506" data-lake-index-type="0"><span class="ne-text"></span><a href="https://github.com/strukturag/libde265" data-href="https://github.com/strukturag/libde265" target="_blank" class="ne-link"><span class="ne-text">https://github.com/strukturag/libde265</span></a></li></ul><ul class="ne-ul"><li id="u8280a4d8" data-lake-index-type="0"><span class="ne-text"></span><a href="https://www.fdbtech.com/webfrontend/%E5%89%8D%E7%AB%AF%E5%A6%82%E4%BD%95%E6%92%AD%E6%94%BEhevch265%E7%BC%96%E7%A0%81%E7%9A%84mp4%E8%A7%86%E9%A2%91" data-href="https://www.fdbtech.com/webfrontend/%E5%89%8D%E7%AB%AF%E5%A6%82%E4%BD%95%E6%92%AD%E6%94%BEhevch265%E7%BC%96%E7%A0%81%E7%9A%84mp4%E8%A7%86%E9%A2%91" target="_blank" class="ne-link"><span class="ne-text">前端web如何播放HEVC(h265)编码的MP4视频</span></a></li><li id="u211af4cc" data-lake-index-type="0"><a href="https://segmentfault.com/a/1190000017187346" data-href="https://segmentfault.com/a/1190000017187346" target="_blank" class="ne-link"><span class="ne-text">H.265/HEVC在Web视频播放的实践</span></a></li></ul><div data-type="danger" class="ne-alert"><p id="ud6c4dbc5" class="ne-p"><span class="ne-text">使用该js文件，能播放他自己提供的那个文件（改不改后缀都可以）</span></p><p id="u37c0c0dc" class="ne-p"><span class="ne-text">新上传的hevc编码的文件还是不能播放</span></p></div><h3 id="qhc2n"><span class="ne-text">【弃】easywasmplayer</span></h3><p id="ua907d3d3" class="ne-p"><span class="ne-text">测试地址：</span><a href="http://www.easydarwin.org/easywasmplayer/" data-href="http://www.easydarwin.org/easywasmplayer/" target="_blank" class="ne-link"><span class="ne-text">http://www.easydarwin.org/easywasmplayer/</span></a></p><div data-type="danger" class="ne-alert"><p id="ud3d554a5" class="ne-p"><span class="ne-text">不支持mov播放，mp4可以</span></p></div><h3 id="pDCNT"><span class="ne-text">【取】ffmpeg方法</span></h3><div data-type="success" class="ne-alert"><p id="u98bacc83" class="ne-p"><span class="ne-text">能否在后端利用ffmpeg将mov格式视频转换成mp4，转换之后的mp4格式是h.264编码的（目前只有部分mov格式视频是hevc编码的）</span></p></div><p id="ue3285a88" class="ne-p"><br></p><ul class="ne-ul"><li id="u01a2e3eb" data-lake-index-type="0"><span class="ne-text"></span><a href="https://learnku.com/articles/50169" data-href="https://learnku.com/articles/50169" target="_blank" class="ne-link"><span class="ne-text">Web 端解码 H.265 视频可行性研究</span></a></li><li id="uda1c876b" data-lake-index-type="0"><span class="ne-text"></span><a href="https://blog.csdn.net/qq_29931083/article/details/107758997" data-href="https://blog.csdn.net/qq_29931083/article/details/107758997" target="_blank" class="ne-link"><span class="ne-text">ffmpeg将mov格式的视频转换成mp4格式</span></a></li></ul><p id="u54631621" class="ne-p"><span class="ne-text"></span></p><p id="u5708f1f9" class="ne-p"><span class="ne-text">PS：ffmpeg安装方法：</span></p><p id="u6a3cb83b" class="ne-p"><a href="https://ffmpeg.org/download.html" data-href="https://ffmpeg.org/download.html" target="_blank" class="ne-link"><span class="ne-text">https://ffmpeg.org/download.html</span></a></p><p id="u22be7417" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1632896302501-77e97ee6-c0fa-444d-a9c2-a34bec0d7493.png" width="491" id="u1938d594" class="ne-image"></p><p id="u7a13ec78" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1632896323573-b3da95d2-dba7-42d0-b712-b2cfb5dbf82e.png" width="312.5" id="ud117ee8e" class="ne-image"></p><p id="uf4cb7c84" class="ne-p"><span class="ne-text">添加到环境变量</span></p><p id="uf41cab34" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1641181905373-20996222-6e15-43ee-9e2f-4ca7d62da401.png" width="355" id="ud78e85c0" class="ne-image"></p><p id="ue4c9d668" class="ne-p"><span class="ne-text">检测是否安装成功</span></p><p id="ubec3da53" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1632896355552-9604ce17-2ff5-44dc-931e-73ebc2efede8.png" width="373.5" id="ubed8d8a3" class="ne-image"></p><p id="u221b2367" class="ne-p"><span class="ne-text">安装成功</span></p><p id="u00bbe596" class="ne-p"><span class="ne-text"></span></p><p id="u4e6bed12" class="ne-p"><strong><span class="ne-text">【ffmpeg转mov为mp4-命令】</span></strong></p><pre><code><code>ffmpeg -i test.mov -vcodec libx264 -preset fast -crf 20 -y -acodec libmp3lame -ab 128k test.mp4</code></code></pre><p id="u7b747430" class="ne-p"><span class="ne-text"></span></p><p id="u36a66e9e" class="ne-p"><strong><span class="ne-text">【前端实现】</span></strong></p><p id="u4668101b" class="ne-p"><a href="https://download.csdn.net/download/weixin_42120997/19759493" data-href="https://download.csdn.net/download/weixin_42120997/19759493" target="_blank" class="ne-link"><span class="ne-text">https://download.csdn.net/download/weixin_42120997/19759493</span></a><span class="ne-text">【收费】</span></p><p id="u62303f43" class="ne-p"><a href="https://blog.csdn.net/dj513dj/article/details/60961970" data-href="https://blog.csdn.net/dj513dj/article/details/60961970" target="_blank" class="ne-link"><span class="ne-text">https://blog.csdn.net/dj513dj/article/details/60961970</span></a></p><p id="u8e862f0f" class="ne-p"><a href="https://juejin.cn/post/6844903961942556685" data-href="https://juejin.cn/post/6844903961942556685" target="_blank" class="ne-link"><span class="ne-text">https://juejin.cn/post/6844903961942556685</span></a></p><p id="u5100a420" class="ne-p"><a href="https://github.com/damianociarla/node-ffmpeg" data-href="https://github.com/damianociarla/node-ffmpeg" target="_blank" class="ne-link"><span class="ne-text">https://github.com/damianociarla/node-ffmpeg</span></a></p><p id="ubc1e5279" class="ne-p"><a href="https://blog.csdn.net/dj513dj/article/details/60961970" data-href="https://blog.csdn.net/dj513dj/article/details/60961970" target="_blank" class="ne-link"><span class="ne-text">https://blog.csdn.net/dj513dj/article/details/60961970</span></a></p><p id="u84fbaae2" class="ne-p"><span class="ne-text">还是需要电脑有ffmpeg环境</span></p><p id="uad061cd9" class="ne-p"><span class="ne-text"></span></p><p id="u70226f72" class="ne-p"><strong><span class="ne-text">【后端实现】</span></strong></p><p id="u34b02720" class="ne-p"><a href="https://blog.csdn.net/fareise/article/details/53188785" data-href="https://blog.csdn.net/fareise/article/details/53188785" target="_blank" class="ne-link"><span class="ne-text">NodeJS实现视频转码</span></a></p><p id="uf09e6507" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1632897980832-011bfd61-effc-47f9-a527-17b59644c4ae.png" width="695" id="lFosa" class="ne-image"></p><p id="u77922ea0" class="ne-p"><span class="ne-text">需要服务端有ffmpeg环境</span></p></div>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
          <category> 前端业务解决方案 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>师者对技术的态度</title>
      <link href="/essay/dqzalx/"/>
      <url>/essay/dqzalx/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="u5abe3c3a" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/1484158/1649042341317-573ef9f9-3528-4b7c-b838-21e47448200c.jpeg" width="333.015625" id="u0d8f20dd" class="ne-image"></p><p id="u3b4f5cba" class="ne-p"><span class="ne-text"></span></p><ul class="ne-ul"><li id="2302818483f14cd1baf9ad807e7aef7e"><span class="ne-text">C语言老师：</span><code class="ne-code"><span class="ne-text">像你们这个年龄，在古代那会儿，你们才刚刚进入仕途</span></code></li><li id="2d77dda4d9bf442a081548c366a79f42"><span class="ne-text">数据结构老师：</span><code class="ne-code"><span class="ne-text">将数据结构整本书上的所有算法自己实现一遍，那么代码水平就能够提升到一个不错的高度</span></code></li></ul><ul class="ne-ul"><li id="fbf26996f22e42c27a9397bfab3d4729"><span class="ne-text">JAVA老师：</span><code class="ne-code"><span class="ne-text">Ideas are cheap, show me the code</span></code></li><li id="4c8030857747fc21fdf2cf11f90e735d"><span class="ne-text">计算机网络老师：</span><code class="ne-code"><span class="ne-text">要用工程思维去设计一个系统</span></code></li><li id="3da6ea73090db79b1ffdb17b9ef49e48"><span class="ne-text">计算方法老师：</span><code class="ne-code"><span class="ne-text">计算机没有精确 只有精度</span></code></li></ul><p id="ubc03d941" class="ne-p"><br></p><p id="u6212a8de" class="ne-p"><span class="ne-text">第一个面试的HR：</span></p><p id="u7df30ff8" class="ne-p"><span class="ne-text">感受得到，她是一个资深的面试官，她问的各个问题不是很刁钻，但是很细，伴随着问答的交流，我也逐渐意识到我的不足之处（深度和广度），过程中她说了一句话，让我印象深刻：</span><code class="ne-code"><span class="ne-text">现在技术这条路，不是这么好走的</span></code></p></div>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>隐忍——能屈能伸</title>
      <link href="/essay/rng8r9/"/>
      <url>/essay/rng8r9/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="u6c6014ae" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1630644058664-8fca3267-fe2c-4890-868d-dd84180a80ce.png" width="960" id="u7bba36b2" class="ne-image"></p><p id="ub84eb308" class="ne-p"><em><span class="ne-text">风会长的隐忍，能屈能伸</span></em></p><p id="ue4ee2ab6" class="ne-p"><span class="ne-text"></span></p><p id="a20d224c568e48b9d67847a2c66a8c01_p_0" class="ne-p"><strong><span class="ne-text">『隐忍』</span></strong></p><p id="u2e676898" class="ne-p"><span class="ne-text"></span></p><p id="u7e6b5ac0" class="ne-p"><span class="ne-text">个人认为这个词有褒有贬，但有一个可以肯定的是，能隐忍的人，定在蓄势待发。</span></p><p id="u967c547f" class="ne-p"><span class="ne-text"></span></p><p id="u1e9063c5" class="ne-p"><span class="ne-text">蝇头小利也好，一时上头也好，我觉得对人而言，『克制』和『隐忍』是最需要磨练的一个品质，这不代表你放弃了洒脱，不再成为性情中人，而是这种品质会让你走得更远，情、事业、爱好等等。对隐忍这个代名词最经典的记忆之一是读《狼图腾》里的时候，里面写道狼群捕猎黄羊群，会静待最好的狩猎时机，不会为了眼前的零星几只羊而乱了阵脚，狩人掏狼崽，狼也能克制，因为它们很清楚自己与狩人的实力，即便是骨肉至亲……</span></p><p id="u309c976b" class="ne-p"><span class="ne-text"></span></p><p id="u4a361bd9" class="ne-p"><span class="ne-text">另一个就是《一人之下》的风正豪，将能屈能伸演绎的淋漓尽致，儿子风星潼被王并用自家的拘灵遣将打的重伤并羞辱，他选择的是马首是瞻，像极了越王勾践，枭雄之所以能成为枭雄，</span><strong><span class="ne-text">是因为他们能忍常人所不能接受的痛楚</span></strong><span class="ne-text">，因为在他们心里面，有一条更长的路在那里，只是在等待羽翼丰满之时。</span></p><p id="ubfab90a1" class="ne-p"><span class="ne-text"></span></p><p id="u09d507b4" class="ne-p"><span class="ne-text">最后，我之所以单方面觉得隐忍还有贬的意味，是我觉得，优秀、不卑不亢这些品质的确很重要，但真性情、简单、洒脱也是一个人不能忘却的，不然就成为了俞敏洪口中的老奸巨猾。</span><strong><span class="ne-text">懂得舍弃，学会用智慧去选择自己该做什么样的抉择</span></strong><span class="ne-text">，才是一个人最需要做的。</span></p></div>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>人生独行者</title>
      <link href="/essay/fb0yri/"/>
      <url>/essay/fb0yri/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="u3bda4409" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1630812970555-a8e776cc-9769-4729-b360-2eaeb8c95afd.jpeg" width="1920" id="u7c5aea52" class="ne-image"></p><p id="u2520bcd0" class="ne-p"><strong><span class="ne-text"></span></strong></p><p id="u6a1e5448" class="ne-p"><strong><span class="ne-text">无悔的独行者</span></strong></p><p id="ud15a128d" class="ne-p"><span class="ne-text"></span></p><p id="520f42f3293818f927861ebbd5b15da4_p_0" class="ne-p"><span class="ne-text">人生就是一个行者独自在一条大道上向前行走着，身边有许多美好，有许多遗憾，但是时间是单维度的，时间不会后退，你做过的事情，不会倒退，单一个体要对自己做过的事情无悔</span></p><p id="42b724d5778774d60e8ceb8c6aafe2fd" class="ne-p"><br></p><p id="30dd3a402fcd74138548305a9a1dc171" class="ne-p"><span class="ne-text">路上，你遇到很多人，你又和很多人说再见，你的前方无论什么时候都是那条看不到尽头的道路，</span></p><p id="234a06249234ea5e1e92b1c37696ede9" class="ne-p"><br></p><p id="619083d955cda6ae263322a8ebb6c4ba" class="ne-p"><span class="ne-text">不用去想人生的意义是什么，因为当死了的那一瞬间，了无遗憾，无悔般地笑着</span></p><p id="95cf672e8334071d2fab7f0b4b3d4a07" class="ne-p"><br></p><p id="udd7f0fcb" class="ne-p"><strong><span class="ne-text">造物主的内壁</span></strong></p><p id="u8d5ae5c3" class="ne-p"><br></p><p id="u31d69dda" class="ne-p"><span class="ne-text">人生的阶段就像是一个个内壁，就像是造物主让我们这么一个个生命体聚集在一起，他希望我们是规则的，所以在文明下，我们很多人都是规矩的，一样的……</span></p><p id="u716b142c" class="ne-p"><span class="ne-text"></span></p><p id="ud854a12d" class="ne-p"><span class="ne-text">文明框架下，每个人都是主角，每个人又好像都不是主角。</span></p><p id="ud68a5b91" class="ne-p"><span class="ne-text"></span></p><p id="ubde2b243" class="ne-p"><span class="ne-text"></span></p><p id="u4acf5d48" class="ne-p"><span class="ne-text">循环的单变量</span></p><p id="ua102cb94" class="ne-p"><span class="ne-text">读书===娶老婆===事业===生娃===读书</span></p><p id="b9c17e703a1bbbc593736caa61ef259d" class="ne-p"><br></p><p id="582d9b36ae645f59ac18545d9535ec31" class="ne-p"><span class="ne-text">这个文明带给我们的就像是这样的一段代码，然而，哪有这么容易呢？然而生活还会时不时给你制造bug，比如你学业上的困难，人总是不习惯于框架之外，但又沉溺于这个制度本身，讽刺的是，解决那些bug的人就是我们自己。</span></p><p id="7185a174c6bd5e198c0bcca841ff91fa" class="ne-p"><br></p><p id="4b6819242b47b931d3a1658713b96cfa" class="ne-p"><span class="ne-text">每个人就像是按照既定的规则去做事，不能有程序上的bug，</span></p><p id="d164fa8fc4acdbcc10e3b530cd7e9de0" class="ne-p"><br></p><p id="d8ce710037fe5edd48452a5c16b373d5" class="ne-p"><span class="ne-text">反过来说，要是我们不顺应这个文明制度，这就像是出bug了。</span></p><p id="de0cc843e56199257d01eb46a0eb9e67" class="ne-p"><br></p><p id="a566430fe2233f1d87599342268a3985" class="ne-p"><span class="ne-text">“某人读书期间，不好好读书，不务正业”造物主借由“环境”这么一个事物来影响这一个个体，让其不要破坏这个社会的制度，突然有一天，那个某人终于</span></p><p id="u400aa7ba" class="ne-p"><span class="ne-text"></span></p><p id="u2bbdfaa4" class="ne-p"><span class="ne-text">算法当中的贪心算法，其算法思想就是取局部最优</span></p><p id="u1d735217" class="ne-p"><span class="ne-text"></span></p><p id="u18ca4b97" class="ne-p"><strong><span class="ne-text">假如明天我死了</span></strong></p><p id="uc0e8c7f3" class="ne-p"><span class="ne-text"></span></p><p id="ua2dabb41" class="ne-p"><span class="ne-text">我的人生准则就是，假如我明天就死了，今天的我不会对我所做的任何事情感到后悔。</span></p><p id="b2dc5cb6d52f23fe6487d1760a025384" class="ne-p"><br></p><p id="d1ff7aabe7646884c71ea9990fadcd9b" class="ne-p"><span class="ne-text">我的行为准则很简单，但是并不代表我不懂，许多所谓的道理，我又何尝不懂，只是，我不害怕这个文明，不害怕这个文明所带来的种种。</span></p><p id="e277c3118e88ff9a64a6cb81c9eac6ed" class="ne-p"><br></p><p id="0cddda35c745c8a28a06dd4437db2736" class="ne-p"><span class="ne-text">我总是在坚守那些在其他人看来特别幼稚的事情，但是我却将其看得像珍宝一样珍贵</span></p><p id="d0439f7270971a59e10d3667c218eb94" class="ne-p"><br></p><p id="59473b30286f6680f96bf0d467a3a408" class="ne-p"><span class="ne-text">人如果没有信仰，没有坚守，那活着又有什么意义呢？</span></p><p id="uf2d17c7f" class="ne-p"><span class="ne-text"></span></p><p id="u59058a0c" class="ne-p"><strong><span class="ne-text">大学……</span></strong></p><p id="u7604627b" class="ne-p"><br></p><p id="u4019b73c" class="ne-p"><span class="ne-text">大学，只是我所经历的一站，我的前方依旧在那里，看起来很近，但是却也不近，大学快结束了，我想要的是近了还是远了……</span></p></div>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>配置GPG密钥来对GitHub做签名提交commit</title>
      <link href="/blog/go85d1/"/>
      <url>/blog/go85d1/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="42bd2d5ebf6401acbcfa2d5d5f734273" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1628854019765-b6022a63-5214-4d70-98b5-aec146cf1e6b.png" width="524" id="mqoXX" class="ne-image"></p><p id="4f10621b1ac85f0abd467b8356afb2ef" class="ne-p"><br></p><p id="1891e3f1aa952ffff092448715485f0c" class="ne-p"><span class="ne-text">前言：GitHub在提交代码的时候会出现是否验证的情况，如上图所示，出现这个机制的原因就是当利用name和email提交代码时，两个不同的人都可以提交（多人协同一个项目），为了代码更加的严密与可靠，就出现了GPG keys加重验证这一情况。</span></p><p id="0f41f994265f5f78f32a49bb7ba09225" class="ne-p"><span class="ne-text"></span></p><p id="762f0713131a16fd4cd18610c48d5d19" class="ne-p"><span class="ne-text">GPG密钥的具体逻辑应用到RSA算法，原理逻辑可参考之前写的一篇文章『</span><a href="https://www.wztlink1013.com/blog/ccd10c/" data-href="https://www.wztlink1013.com/blog/ccd10c/" target="_blank" class="ne-link"><span class="ne-text">RSA公钥密码算法 | 尼采般地抒情</span></a><span class="ne-text">』，该文也算是对该算法的一次应用。</span></p><hr id="krdEH" class="ne-hr"><h2 id="yF4YK"><span class="ne-text">一、创建gpg密钥</span></h2><p id="a05857b69218cdb73ac313e42c0d5441" class="ne-p"><span class="ne-text">在git Bash里面查看gpg版本</span></p><p id="e92b2e3f8a4a513b9a9def618c0df416" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1628854562240-df76109f-807c-46ec-93cc-eeb634181583.png" width="248" id="FSA2j" class="ne-image"></p><p id="uba621ea9" class="ne-p"><br></p><p id="4814b8f53b0b05e04def958672efc8d3" class="ne-p"><span class="ne-text">生成密钥</span></p><pre><code>gpg --full-generate-key</code></pre><p id="0c36ae9d901510b238ceab439e01bd73" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1628854642828-9298534e-2470-4440-a5d3-a0b4eebf9267.png" width="290" id="GLArL" class="ne-image"></p><p id="uf126e970" class="ne-p"><br></p><p id="1ad037c776638cabfd1c45964b01bbbc" class="ne-p"><span class="ne-text">列举已经创建好的密钥id</span></p><pre><code>gpg --list-secret-keys --keyid-format LONG</code></pre><p id="eadd38310d47c7777ee21a1d770ab12b" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1628854721166-1a7cf63a-8053-42aa-a365-9f4accc4cb40.png" width="246" id="fBUBe" class="ne-image"></p><p id="0edbc327c4a78841e4deab698907d237" class="ne-p"><br></p><div data-type="tips" class="ne-alert"><p id="8906efe46498590a79f058923b12f7fc" class="ne-p"><span class="ne-text" style="background-color: #FFF6B6">中途会弹出要设置密码，并且是两次弹出。</span></p></div><p id="u9962072f" class="ne-p"><br></p><p id="9237aa6bcdf488da490c35bbf9752d7f" class="ne-p"><span class="ne-text">查看密钥内容</span></p><pre><code>gpg --armor --export 10A9巴拉巴拉</code></pre><p id="16cd2775365117160f34038a1dd018ee" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1628854842847-28c1fb0a-ac3d-446b-b479-4c34a9d89d0d.png" width="235" id="jQgdw" class="ne-image"></p><h2 id="Divf6"><span class="ne-text">二、添加gpg密钥</span></h2><p id="022459be1af9049817901756d7835a0c" class="ne-p"><span class="ne-text">将上述控制台的密钥内容复制到GitHub的一下区域</span></p><p id="bb5883df540881786feeda6353e65ef0" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1628854955321-8c0648b4-2ed8-472a-b9a9-58638bf12b61.png" width="837.5" id="al61T" class="ne-image"></p><hr id="q1wax" class="ne-hr"><p id="40bdd7dea884ce83e2493fc8ad5f35d7" class="ne-p"><span class="ne-text">以下就是公钥和密钥内容</span></p><p id="dbf1ab26d8bb9591d6b1ca7a8562e7c1" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1628856682736-35e744c2-8f28-425f-8a4c-fe9236cd8616.png" width="586.5" id="naOHh" class="ne-image"></p><h2 id="BVLAu"><span class="ne-text">三、本地设置gpg密钥</span></h2><p id="107d83064cf0663d7f4ef54c584a98d0" class="ne-p"><span class="ne-text">将gpg密钥添加到本地设置中</span></p><pre><code>git config --global user.signingkey 10A9巴拉巴拉</code></pre><p id="2d87149a54b40e9f642314b53646b674" class="ne-p"><span class="ne-text">在所有项目中设置签名验证</span></p><pre><code>git config --global commit.gpgsign true</code></pre><h2 id="DS7c2"><span class="ne-text">四、使用</span></h2><p id="718c79b7e92e6d61c7c03e22b9fdd800" class="ne-p"><span class="ne-text">在提交代码的时候，会弹出该提示框，这就是在设置密码时候的密码（密钥）。</span></p><p id="96527d4a09b6fe6dfd4eb2d3de6846ed" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1628855341009-92cccb8c-0007-4361-8d42-778002d554e8.png" width="345.5" id="dLIY1" class="ne-image"></p><p id="50d998aabb61977a0236134dad953c61" class="ne-p"><br></p><h2 id="YU0Pr"><span class="ne-text">参考</span></h2><ul class="ne-ul"><li id="0284af9faa553fbbd031f2a0067408dc"><a href="https://www.ruanyifeng.com/blog/2013/07/gpg.html" data-href="https://www.ruanyifeng.com/blog/2013/07/gpg.html" class="ne-link"><span class="ne-text">GPG入门教程 作者： 阮一峰</span></a></li><li id="e2e39f1a038f5d13a6d69d6cabc56c0f"><a href="https://www.jianshu.com/p/195cac3a2b2c" data-href="https://www.jianshu.com/p/195cac3a2b2c" class="ne-link"><span class="ne-text">使用gpg密钥验证github提交</span></a></li></ul></div>]]></content>
      
      
      <categories>
          
          <category> 计算机素养 </category>
          
          <category> Git和GitHub </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>『花束般的恋爱』——“我认识了一个和我想法一样的人”</title>
      <link href="/essay/qraopm/"/>
      <url>/essay/qraopm/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="u22a66168" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1627879984472-b6f94d18-7055-4be5-9cb6-8a550e5342d3.png" width="1911" id="udf56b2ff" class="ne-image"></p><p id="u5f49ad95" class="ne-p"><br></p><p id="ucae40f69" class="ne-p"><span class="ne-text">看完之后的感受：</span><strong><span class="ne-text">始于心动，败于现实</span></strong><span class="ne-text">。</span></p><p id="uda3e74e7" class="ne-p"><br></p><p id="u50e01ea1" class="ne-p"><span class="ne-text">恋爱不是婚姻，因为中间有现实，但现实只是一个因素，在这个因素下，有的人忘却了曾经想要守护的，有的人想守住曾经，有的人幡然悔悟，有的人却早已失望并且走远……</span></p><p id="u6c6292df" class="ne-p"><br></p><p id="u739c65bc" class="ne-p"><span class="ne-text">这可能就是爱情和婚姻的不同吧。我也很幼稚，但是我想试试几年之后的我再看这篇文章会是什么感悟……</span></p><p id="u6e0614c2" class="ne-p"><br></p><hr id="G9wgh" class="ne-hr"><p id="u6dcd1e92" class="ne-p"><br></p><h2 id="v8t7Q"><span class="ne-text">“我认识了一个和我想法一样的人”</span></h2><p id="ud865d1f4" class="ne-p"><span class="ne-text">这就是相同的灵魂的碰撞，我相信巧合，真的相信。交谈有无数种，但是那种契合灵魂的交谈真的只有那个对的人才会有。</span></p><p id="u85bc468b" class="ne-p"><br></p><p id="u58d0633e" class="ne-p"><span class="ne-text">“我们好像，你就像是另一个世界的我一样”，就是那种你不用多言，也能感受到对方将要表达出来的感受。那绝对是亲身经历才能长存心间的事情。</span></p><p id="u0dea7a60" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1627880340235-0ee52649-ef7e-4a7b-94b4-81ca645fd24c.png" width="960" id="uc6f2af4b" class="ne-image"></p><p id="u3fc85688" class="ne-p"><br></p><p id="ua9f48cef" class="ne-p"><br></p><h2 id="W5xJs"><span class="ne-text">爱情中的智者？</span></h2><p id="uf0cfa697" class="ne-p"><span class="ne-text">生活中总会有人去告诉你一些道理，像是扮演者一个智者的角色。片中爱情博客博主芽衣就是这么一个角色。</span></p><p id="u46d8b5d9" class="ne-p"><br></p><div class="ne-quote"><p id="u2c01f862" class="ne-p"><span class="ne-text">相遇总是伴随着离别</span></p><p id="ue162fa9a" class="ne-p"><span class="ne-text">恋爱就像派对  总有一天会结束 </span></p><p id="ufee0c56b" class="ne-p"><span class="ne-text">所以恋爱的人</span></p><p id="u75f3644b" class="ne-p"><span class="ne-text">总是喜欢将迷恋的东西夹在书桌里</span></p><p id="u8c6749bb" class="ne-p"><span class="ne-text">再分享他们的爱情</span></p><p id="ud64f8980" class="ne-p"><span class="ne-text">因为他们只能享受这份悲伤</span></p><p id="u09069c2e" class="ne-p"><span class="ne-text">虽然爱情的存存活率极小</span></p><p id="u50fb7f96" class="ne-p"><span class="ne-text">但我的爱情会活下来</span></p></div><p id="uda2fa691" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1627881603601-6bb986d5-c12b-4710-8a56-cbefe8667501.png" width="960" id="u4405a4e6" class="ne-image"><span class="ne-text"> </span></p><p id="u40b0dc2e" class="ne-p"><br></p><div class="ne-quote"><p id="uc9f994e3" class="ne-p"><span class="ne-text">芽衣算是看到爱情的死亡吗？</span></p><p id="u3bfdacbd" class="ne-p"><span class="ne-text">她顺应了爱情的结束吗？</span></p><p id="u84a048e0" class="ne-p"><span class="ne-text">我只能去想象</span></p><p id="u2aaf8e51" class="ne-p"><span class="ne-text">而且也不打算  把它套用在自己的爱情上面</span></p><p id="u7a58441e" class="ne-p"><span class="ne-text">只是 我们的派对</span></p><p id="u2445e462" class="ne-p"><span class="ne-text">现在正在高潮部分</span></p></div><p id="uaf99aa6b" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1627881791016-85d417b3-119a-4c33-8e0f-927071017501.png" width="960" id="u9d16aabc" class="ne-image"></p><p id="u3ac5ff8d" class="ne-p"><br></p><h2 id="mQQbR"><span class="ne-text">现实会让你忘掉恋爱中最初的自己吗？</span></h2><p id="ue5fd01ad" class="ne-p"><span class="ne-text">我不知道，我没能看得见未来那个阶段的自己。</span></p><p id="ue5d791a6" class="ne-p"><br></p><p id="ue88fdd3d" class="ne-p"><span class="ne-text">女主工作初期的失意，以及男主工作中的起势和落魄，这可能就是常人说的现实把。现实让两个人褪去了太多色彩，但是一直坚守的是女主，同样是落魄，男主的陪伴和女主的陪伴换来的结果全然不样，没有好好珍惜把。</span></p><p id="u1a113d65" class="ne-p"><br></p><p id="u9865bfe1" class="ne-p"><span class="ne-text">人会变，也没有谁能够一直陪着谁。</span></p><p id="uedd5c011" class="ne-p"><br></p><p id="ua6f5a461" class="ne-p"><span class="ne-text">人都是个体……</span></p><p id="u613c674f" class="ne-p"><br></p><h2 id="Tq5qu"><span class="ne-text">感性 VS 理性</span></h2><p id="uc2bc6cc8" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1627883190252-ec419a89-4711-4126-aa45-5bf708930312.png" width="960" id="uca4b5a69" class="ne-image"></p><div data-type="info" class="ne-alert"><p id="uc51ad6c8" class="ne-p"><span class="ne-text">男主和女主最后的那段话，这段对话算是完完全全交代了两个人的终点。</span></p></div><p id="u03a88e41" class="ne-p"><br></p><div class="ne-quote"><p id="uff22c6b7" class="ne-p"><span class="ne-text">谢谢你</span></p></div><p id="ue0d3f9a7" class="ne-p"><br></p><div class="ne-quote"><p id="u37b5740a" class="ne-p"><span class="ne-text">小娟</span></p><p id="u96d4fd08" class="ne-p"><span class="ne-text">我不想分手</span></p><p id="ue0c63850" class="ne-p"><span class="ne-text">我觉得不用分手</span></p><p id="u7ef288cb" class="ne-p"><span class="ne-text">我们结婚吧</span></p><p id="u1f521711" class="ne-p"><span class="ne-text">结婚后</span></p><p id="ue75cc7e1" class="ne-p"><span class="ne-text">和以前一样</span></p><p id="u0efe5ecb" class="ne-p"><span class="ne-text">一起过日子吧</span></p><p id="udab251c8" class="ne-p"><span class="ne-text">没关系的</span></p></div><p id="ucb7d57b9" class="ne-p"><br></p><p id="u227cff08" class="ne-p"><br></p><div class="ne-quote"><p id="u25045beb" class="ne-p"><span class="ne-text">因为今天很开心所以你才会这么想</span></p><p id="u400965e1" class="ne-p"><span class="ne-text">我们又会回到以前那样</span></p></div><p id="u8d714314" class="ne-p"><br></p><div class="ne-quote"><p id="udd3ef590" class="ne-p"><span class="ne-text">我觉得没什么不好</span></p><p id="uc395de1a" class="ne-p"><span class="ne-text">这世上结婚的夫妻</span></p><p id="u1446fb87" class="ne-p"><span class="ne-text">大家不都是如此吗</span></p><p id="uc2a42996" class="ne-p"><span class="ne-text">都会慢慢忘记恋爱的感觉</span></p><p id="ud41c4240" class="ne-p"><span class="ne-text">不是也有结婚之后  继续这样过日子的人吗</span></p><p id="u98618816" class="ne-p"><span class="ne-text">就算感情变了</span></p><p id="u4efa80b2" class="ne-p"><span class="ne-text">不开心的事 就睁一只眼闭一只眼</span></p><p id="u1ea536a5" class="ne-p"><span class="ne-text">继续过日子  有这样的人的</span></p><p id="u81d8d840" class="ne-p"><span class="ne-text">我和你</span></p></div><p id="u52d5bbb4" class="ne-p"><br></p><div class="ne-quote"><p id="u3dff18a7" class="ne-p"><span class="ne-text">又要降低标准吗</span></p><p id="uebfd216d" class="ne-p"><span class="ne-text">降低标准</span></p><p id="u20106d10" class="ne-p"><span class="ne-text">然后想  就这样过吧</span></p><p id="ue58221d7" class="ne-p"><span class="ne-text">这样你就满意吗</span></p></div><p id="u4c953b14" class="ne-p"><br></p><div class="ne-quote"><p id="u11e5a2d5" class="ne-p"><span class="ne-text">满意</span></p><p id="u617feb85" class="ne-p"><span class="ne-text">不可能像以前一样喜欢啊</span></p><p id="u63df5a20" class="ne-p"><span class="ne-text">如果追求这种事就无法幸福了</span></p><p id="u69b1f3db" class="ne-p"><span class="ne-text">会不停地吵架</span></p><p id="uafb61969" class="ne-p"><span class="ne-text">不也是因为恋爱的感觉在捣乱吗</span></p><p id="u45882bbb" class="ne-p"><span class="ne-text">现在成为一家人的话</span></p><p id="u6c4cf163" class="ne-p"><span class="ne-text">我觉得能和你过好</span></p><p id="u1ab9ed12" class="ne-p"><span class="ne-text">生个孩子  孩子管我叫爸爸  管你叫妈妈</span></p><p id="u2e1fae82" class="ne-p"><span class="ne-text">我都能想象到那一幕</span></p><p id="u7a641f41" class="ne-p"><span class="ne-text">三个人或者四个人手牵着手一起去多摩川边散步吧</span></p><p id="u5ad2dbeb" class="ne-p"><span class="ne-text">推着婴儿车一起去逛高岛屋吧</span></p><p id="ubb95e8c0" class="ne-p"><span class="ne-text">买一辆车</span></p><p id="u417b59f8" class="ne-p"><span class="ne-text">去野营  去迪士尼乐园</span></p><p id="u907c89b3" class="ne-p"><span class="ne-text">花时间  一起过完这辈子</span></p><p id="u3d8694f0" class="ne-p"><span class="ne-text">他们俩虽然一起经历了很多事情</span></p><p id="ue334d411" class="ne-p"><span class="ne-text">但现在变成了一堆关系很好的夫妻</span></p><p id="u83c33db1" class="ne-p"><span class="ne-text">你中有我  我中有你</span></p><p id="ue53adf13" class="ne-p"><span class="ne-text">我们变成这样的关系吧</span></p><p id="u42130182" class="ne-p"><span class="ne-text">结婚吧  一起变幸福吧</span></p></div><p id="u15eff770" class="ne-p"><br></p><div class="ne-quote"><p id="u7c54de8f" class="ne-p"><span class="ne-text">你说的可能没错</span></p><p id="uc4b53c4e" class="ne-p"><span class="ne-text">是啊</span></p><p id="ud5023fe5" class="ne-p"><span class="ne-text">如果我们结婚了</span></p><p id="u37c9c63d" class="ne-p"><span class="ne-text">成为了家人</span></p></div><p id="u8b772e27" class="ne-p"><span class="ne-text">没有结局了……</span></p><p id="u091dfd5f" class="ne-p"><br></p><p id="u825d7cda" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1627883840887-418d2c4a-2209-4fec-b839-7f85c8bacb17.png" width="960" id="dQsNl" class="ne-image"></p><p id="udde4ec35" class="ne-p"><br></p><div data-type="info" class="ne-alert"><p id="u69f572ed" class="ne-p"><span class="ne-text">始于心动，败于现实，这是我所能想到的，两人的爱情被磨没了，而这之中，对现实的无能为力才是罪魁祸首……</span></p></div><p id="uc119e114" class="ne-p"><br></p><p id="u86cef349" class="ne-p"><br></p></div>]]></content>
      
      
      <categories>
          
          <category> 影视 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>『士兵突击』</title>
      <link href="/essay/qd0o6r/"/>
      <url>/essay/qd0o6r/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content-editor-core lake-engine lake-typography-classic" data-lake-element="root" data-selection-undefined="%7B%22path%22%3A%5B%5B7%2C0%2C51%5D%2C%5B7%2C0%2C51%5D%5D%2C%22active%22%3Atrue%7D"><p data-lake-id="ua79cadc0" id="ua79cadc0" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span data-card-type="inline" data-lake-card="image" id="udb87ee1e" class="lake-card-margin-top lake-card-margin-bottom"><img data-role="image" src="https://cdn.nlark.com/yuque/0/2021/webp/1484158/1627457976739-9801a315-02f3-4f5f-b590-6b2a532749a7.webp" data-raw-src="" class="image lake-drag-image" alt="image" title="image" data-height="360px" style="visibility: visible; width: 270px;"></span></p><p data-lake-id="uc43a5495" id="uc43a5495" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="u30e7b7e4" id="u30e7b7e4" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>前言：人生导师级别的一部军旅影视，看完电视剧变买了这本小说一边看完。</span></p><p data-lake-id="0f7a058a54a40e288f29b6dc5d143e5f" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span><br></span></p><h2 data-lake-id="a5133cb03312e62e22133bbbb3573172" id="77PfS" style="padding: 7px 0px; margin: 0px; font-weight: 700; font-size: 24px; line-height: 32px;">小说</h2><p data-lake-id="71b218d590149e15a2d338d72f124a87" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">第二章</p><p data-lake-id="d801c1cfdda58c4fcd0f62ed87cfc851" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="45e2571a5a7586e52903f99f47e11eeb" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">史今班长的温柔和同情，对他而言，像是看到曾经刚入部队的自己，以至于做出绝不可能而又做出的感性的选择……</p><p data-lake-id="f50e31ddeea8b86e4e841e631511c328" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="8971f4389904dd8a5ded34ddc6b8057a" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">以前在初中，是住校的，那时我班上也有一个和许三多一样的同学，我甚至还记得他叫什么，他叫程伊星，他就是看起来傻傻的，也比我们大一两岁，行为举动像是小孩子，也不谙世事，总是成为同学之间玩乐嬉戏的对象。</p><p data-lake-id="f0ecc1c9bdb7b8e86f763edf8f0b68fd" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="6d21a7ade99f2f57aaa4558d4ecc874e" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">记得有一次夏季的体育课，我回宿舍，看见他躺在床上整理被子（他是作息及其规律，内务极其规整的一个学生），那时我们聊了会天，我觉得我以前初中和谁都能说得出心里话的那种，当时好像是问他为什么不和我们一起玩，忘了他是怎么回答的，只记得他说了一番话，具体也记不清，但是说出的话就像是滑稽的哲理一般，就像是背诵了书里面的词句一样的人生态度。他收拾完之后，他就习惯性地坐在床上，跟我聊天，多的记不清了，我只知道他是一个读书人，但就像是尚未入世一样……</p><p data-lake-id="1e18f8d95c1e65a9b28fa95b0bb2ddf2" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="73e670e02c44652af26e79d1f34f71f8" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">如今在键盘上敲字的我苦笑，敲到<strong>入世</strong>两个字，我也看到了自己的些许狼狈，我不知道什么是成长，但我真的也从家乡那个小城走出来，过往的经历就像是坚毅面庞背后的幸酸，<strong>可这个社会制度下，这个文明框架下，不就是充斥着过多的悲哀么，而我们大多数人都是向着死而生</strong>。</p><div data-card-type="block" data-lake-card="hr"><hr style="background-color: rgb(232, 232, 232); border: 1px solid transparent; margin: 18px 0px;"></div><p data-lake-id="d5a588b42e08846c8000104fd2869127" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="u37a22136" id="u37a22136" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><h2 data-lake-id="41aed8a8db4b7d33bbde8fc90b8959c6" id="WhvVJ" style="padding: 7px 0px; margin: 0px; font-weight: 700; font-size: 24px; line-height: 32px;">影视</h2><div data-card-type="block" data-lake-card="hr" id="ErMZ7"><hr style="background-color: rgb(232, 232, 232); border: 1px solid transparent; margin: 18px 0px;"></div><p data-lake-id="146985790e8223b739b7528750295713" id="146985790e8223b739b7528750295713" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>10集</span></p><p data-lake-id="50c304a2049362301cf57da667c81b2d" id="50c304a2049362301cf57da667c81b2d" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="6e1c87ddcc5263b203a43da6731910ec" id="6e1c87ddcc5263b203a43da6731910ec" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>战友的帮助成就了一个兵，班长的“牺牲”造就了一个兵王。</span></p><p data-lake-id="fdcd11b21ed0576db495d025c8b6680a" id="fdcd11b21ed0576db495d025c8b6680a" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>这是部队里面才有的。</span></p><p data-lake-id="a31a46b66b5cf0bd692c6bbb96493b3a" id="a31a46b66b5cf0bd692c6bbb96493b3a" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="c329be5ed7ad045898f47b737e1c93a8" id="c329be5ed7ad045898f47b737e1c93a8" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>这就像是，重情义的往往是那些曾经成绩不好的后排生，但是会为了彼此扛刀的同学。</span></p><p data-lake-id="2b96f701b3efb2bb2fb3fb9239932ad6" id="2b96f701b3efb2bb2fb3fb9239932ad6" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>懂“不抛弃不放弃”远远比成为兵王更重要，真的。</span></p><p data-lake-id="47d7cb7cebab32d2d43decf756a61b64" id="47d7cb7cebab32d2d43decf756a61b64" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="df676c19a2090acc784ebd5f13b05297" id="df676c19a2090acc784ebd5f13b05297" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>成才最后被老A刷下的那般落魄，真的是曾经没有领悟那六个字所造成的结果。</span></p><p data-lake-id="f864a61177d3ec503436cc57c1f95fd0" id="f864a61177d3ec503436cc57c1f95fd0" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="e6df67c6365c71a8cedc414130aec622" id="e6df67c6365c71a8cedc414130aec622" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>人做事真的不要太急了，踏实，稳固，远比结果更重要，并且到最后，你还会发现，人如果走的踏实，结果都不会太差的。</span></p><p data-lake-id="e826a531d18d60c3b7c2c9cef5738d30" id="e826a531d18d60c3b7c2c9cef5738d30" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><div data-card-type="block" data-lake-card="hr" id="a6GJX"><hr style="background-color: rgb(232, 232, 232); border: 1px solid transparent; margin: 18px 0px;"></div><p data-lake-id="23b445e1c9906f7859bddec7691de2b5" id="23b445e1c9906f7859bddec7691de2b5" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>16集</span></p><p data-lake-id="529f488dd86e9d194962594be53d5265" id="529f488dd86e9d194962594be53d5265" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><blockquote style="margin-top: 5px; margin-bottom: 5px; padding-left: 1em; margin-left: 0px; border-left: 3px solid rgb(238, 238, 238); opacity: 0.6;"><p data-lake-id="03a257be0ea28267c0c1980f426d78ed" id="03a257be0ea28267c0c1980f426d78ed" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>早熟的人往往都很晚熟</span></p><p data-lake-id="baaff50bed78e7dad90baa150aec233e" id="baaff50bed78e7dad90baa150aec233e" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>骄傲的人又很急性</span></p></blockquote><div data-card-type="block" data-lake-card="hr" id="BDEqt"><hr style="background-color: rgb(232, 232, 232); border: 1px solid transparent; margin: 18px 0px;"></div><p data-lake-id="b40ccf37aed85ff9db7ee51fc0554d63" id="b40ccf37aed85ff9db7ee51fc0554d63" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>17集</span></p><p data-lake-id="1a56aa11c4b3887dae8f7f1cc7b2a2cc" id="1a56aa11c4b3887dae8f7f1cc7b2a2cc" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="6794a5bb79c3cf74d75d799c54290578" id="6794a5bb79c3cf74d75d799c54290578" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><strong><span>三多的士官和复员决定与否之路</span></strong></p><p data-lake-id="9e33345b8e01db2a145a02e7891d083d" id="9e33345b8e01db2a145a02e7891d083d" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="36bf33bac1ec8cd4961e750768e21995" id="36bf33bac1ec8cd4961e750768e21995" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>高城走了之后，七连只剩下许三多一个兵</span></p><p data-lake-id="20a112a7b3c72e88e62787996e7014c6" id="20a112a7b3c72e88e62787996e7014c6" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>一个兵守一个连……</span></p><p data-lake-id="c33dcabbeea89cfad3de368598c3b5d2" id="c33dcabbeea89cfad3de368598c3b5d2" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>就是这样，这种历练是何等的孤独，兵王就是兵王，耐得住寂寞。一个人唱战歌，一个人守住仪式，一个人过一整个夜晚，一个人面对整个连的回忆。</span></p><p data-lake-id="7b51e748560e33427fb5d73b84f5f568" id="7b51e748560e33427fb5d73b84f5f568" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="ee7af3bfacd13d18381b6f4a140655ff" id="ee7af3bfacd13d18381b6f4a140655ff" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>难，真的难。这种人真的厉害</span></p><p data-lake-id="2e28f429f41afa2f7f56197ceed239b0" id="2e28f429f41afa2f7f56197ceed239b0" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="878187c29c141527629bded4a2a7f485" id="878187c29c141527629bded4a2a7f485" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>一个月和别人说话不超过十句话，其他的都是自己和自己说话。</span></p><p data-lake-id="c5923e98320b7904677367a44b2d9282" id="c5923e98320b7904677367a44b2d9282" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="1c41f5b83bb2068da62dd4677e166b80" id="1c41f5b83bb2068da62dd4677e166b80" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>伍六一在这个时候其实是最担心三多的。</span></p><p data-lake-id="0467364aee8d5154a94e3f8f9dbb2d2b" id="0467364aee8d5154a94e3f8f9dbb2d2b" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><div data-card-type="block" data-lake-card="hr" id="OZGwh"><hr style="background-color: rgb(232, 232, 232); border: 1px solid transparent; margin: 18px 0px;"></div><p data-lake-id="u6efa79aa" id="u6efa79aa" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>18集</span></p><p data-lake-id="u35d7c6aa" id="u35d7c6aa" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="u161019ec" id="u161019ec" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>袁朗第一次去找许三多对他的评价：</span></p><blockquote style="margin-top: 5px; margin-bottom: 5px; padding-left: 1em; margin-left: 0px; border-left: 3px solid rgb(238, 238, 238); opacity: 0.6;"><p data-lake-id="253eff5fd34fac335ceb85813ea17c42" id="253eff5fd34fac335ceb85813ea17c42" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><strong><span>怎么样  一个人在这守了半年</span></strong></p><p data-lake-id="ud47bc571" id="ud47bc571" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><strong><span>不好不坏  不高不低的一个兵</span></strong></p><p data-lake-id="u5ebcf310" id="u5ebcf310" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><strong><span>一个很安分的兵</span></strong></p><p data-lake-id="ue16b3f84" id="ue16b3f84" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><strong><span>不太焦虑  耐得住寂寞</span></strong></p><p data-lake-id="u122edf3b" id="u122edf3b" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><strong><span>有很多人天天都在焦虑</span></strong></p><p data-lake-id="u37ab8c56" id="u37ab8c56" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><strong><span>怕没得到  怕寂寞</span></strong></p><p data-lake-id="u6deafebd" id="u6deafebd" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><strong><span>我喜欢不焦虑的人</span></strong></p></blockquote><p data-lake-id="udd308025" id="udd308025" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><blockquote style="margin-top: 5px; margin-bottom: 5px; padding-left: 1em; margin-left: 0px; border-left: 3px solid rgb(238, 238, 238); opacity: 0.6;"><p data-lake-id="ue85fad82" id="ue85fad82" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>我，其实我骨子里 骨子里可笨了</span></p><p data-lake-id="uc9b2d748" id="uc9b2d748" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>每一次换一次新的环境</span></p><p data-lake-id="u3bfb0767" id="u3bfb0767" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>我就跟死过一次似的</span></p><p data-lake-id="u1ee0f83d" id="u1ee0f83d" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>你一个人呆在这是怕鬼把？</span></p><p data-lake-id="u3a27cad8" id="u3a27cad8" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>这世界上根本就没有鬼</span></p><p data-lake-id="u6afaca77" id="u6afaca77" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>那就奇怪了</span></p><p data-lake-id="ud26d9397" id="ud26d9397" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><strong><span>鬼和你怕的事情不都是想出来的自己吓唬自己的吗</span></strong></p></blockquote><div data-card-type="block" data-lake-card="hr" id="IVc5Q"><hr style="background-color: rgb(232, 232, 232); border: 1px solid transparent; margin: 18px 0px;"></div><p data-lake-id="b79be21dbb5a04b02fb48de4e875900a" id="b79be21dbb5a04b02fb48de4e875900a" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>19集</span></p><p data-lake-id="a3cb9fcd1190e8e0580ff08485665074" id="a3cb9fcd1190e8e0580ff08485665074" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="9fa77668b13fd20191ce42c8845fefd7" id="9fa77668b13fd20191ce42c8845fefd7" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>参加老A集训，成才，伍六一，许三多，甘小宁……</span></p><p data-lake-id="b234f940a1d01283f36e6f4690914f4b" id="b234f940a1d01283f36e6f4690914f4b" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="6b250069e37dade86b19b60f9114d548" id="6b250069e37dade86b19b60f9114d548" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>伍六一里面对</span></p><div data-card-type="block" data-lake-card="hr" id="jAC5r"><hr style="background-color: rgb(232, 232, 232); border: 1px solid transparent; margin: 18px 0px;"></div><p data-lake-id="cf61a410b429cb718f20351bbcc318d8" id="cf61a410b429cb718f20351bbcc318d8" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>20集</span></p><p data-lake-id="d12002f45cda91a49af194b2679f5b6c" id="d12002f45cda91a49af194b2679f5b6c" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="dc1dd61a8715ff3b4f0870215cac83aa" id="dc1dd61a8715ff3b4f0870215cac83aa" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>人不是靠做出来的，而是靠活出来的</span></p><p data-lake-id="13c449eb41bae7b2b68218702028d377" id="13c449eb41bae7b2b68218702028d377" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>就像你，不仅守住了军营，还守住了你自己</span></p><p data-lake-id="732fc389631cd12faa31c84f28d9697e" id="732fc389631cd12faa31c84f28d9697e" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="0311ccc2d44f8b49723683e4886932de" id="0311ccc2d44f8b49723683e4886932de" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><div data-card-type="block" data-lake-card="hr" id="i59gR"><hr style="background-color: rgb(232, 232, 232); border: 1px solid transparent; margin: 18px 0px;"></div><p data-lake-id="ue155cd1e" id="ue155cd1e" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>五班</span></p><p data-lake-id="u044e262f" id="u044e262f" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="uf03a40bd" id="uf03a40bd" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>五班是许三多和成才都经历过的一个地方，这部剧里面有太多的亮点，但我印象最深最深的就是五班，一望无际的草原，有人觉得是束缚，又有人觉得是天堂，环境足以磨灭一个人的信仰，经得起磨练的人才真的是人才。</span></p><p data-lake-id="uf02b3188" id="uf02b3188" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="u5ab05f30" id="u5ab05f30" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>成才两次去过五班，第一次是部队整编自己去的五班，第二次是被老A打回五班</span></p><p data-lake-id="u48a39f70" id="u48a39f70" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="u4b6506d0" id="u4b6506d0" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span data-card-type="inline" data-lake-card="image" id="u4771e254" class="lake-card-margin-top lake-card-margin-bottom"><img data-role="image" src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1628321067461-42092030-1b62-4a01-9ca6-f36195ef3a22.png" data-raw-src="" class="image lake-drag-image" alt="image.png" title="image.png" data-height="381px" style="visibility: visible; width: 736.5px;"></span></p><p data-lake-id="u03c286ff" id="u03c286ff" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>最后的五班，是由成才炼好的！</span></p><p data-lake-id="u8376ce0d" id="u8376ce0d" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><div data-card-type="block" data-lake-card="hr" id="AYeDf"><hr style="background-color: rgb(232, 232, 232); border: 1px solid transparent; margin: 18px 0px;"></div><p data-lake-id="u24166b9c" id="u24166b9c" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>七连</span></p><p data-lake-id="uf939680e" id="uf939680e" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="u533571b7" id="u533571b7" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>在这里面真的学会很多，比技术和荣誉更重要的是——“不抛弃，不放弃”的人生信念。</span></p><p data-lake-id="u7c89579c" id="u7c89579c" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>其实你会发现在七连不是所有人都是厉害的，但是他们都是最“靠谱”的，最敢拼的，集体荣誉感极强。还没有成长的成才和许三多在这里面就是两个极端，一个能力极强，但功利心极强，一个能力太低，不谙世事。</span></p><p data-lake-id="u9e46a94d" id="u9e46a94d" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>就是两个这样的人最后都是兵王，能力强和弱的两个极端，在他们两个人成为一个人才的时间，我个人觉得是对那六个字的理解。</span></p><p data-lake-id="u6b485c98" id="u6b485c98" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p></div>]]></content>
      
      
      <categories>
          
          <category> 影视 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>菜鸡重学i++和++i</title>
      <link href="/blog/smpdcq/"/>
      <url>/blog/smpdcq/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="e0e5744708b55a241fcb228636fbcb4d" class="ne-p"><span class="ne-text">前言：for循环里面的i++和++i在平时使用感觉是几乎一样的，但是之前写代码，特别是数据结构课程学链表那会，经常需要做的就是一个节点的next指向什么才结束这样一种情况，当时总是不自觉地将i++调整为++i就能运行成功，这个点比较模糊，查资料才发现存在</span><strong><span class="ne-text">只有++i可以返回左值</span></strong><span class="ne-text">这一情况。</span></p><hr id="OUPno" class="ne-hr"><p id="5485f1bfe8a61ef5dd33e673b9622eaf" class="ne-p"><br></p><p id="44c7f74649c7bf9394e73fb54c8b8883" class="ne-p"><span class="ne-text">先来一段常规使用：</span></p><p id="f8ced571d1f25307cb8758c620911566" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1627270650151-857f8953-7e79-4055-a838-2b26b96aaf0a.png" width="522.5" id="sNaU2" class="ne-image"></p><p id="de2db062bf48f2e3a74c66707456022c" class="ne-p"><span class="ne-text">这个没有相关的差别</span></p><p id="015df9c2629edee9a1a1bb482a362ffd" class="ne-p"><br></p><p id="c6e17fcee2b794b85c65b56335443644" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1627271346217-4ae80a1d-979b-42cd-b6ff-8fdc271926ab.png" width="544.5" id="kmxHY" class="ne-image"></p><p id="83f75ad28b6011423f8f326d34c1529a" class="ne-p"><span class="ne-text">一个返回+之前的值一个返回+之后的值，也是字面理解。</span></p><p id="ecc2db8646a888e68a78823d1509e587" class="ne-p"><br></p><div class="ne-quote"><p id="a5c77516ff5f7b541316a3f42f4fb677" class="ne-p"><span class="ne-text">左值：在内存存储空间里面有确定的存储地址的值。</span></p><p id="02e5fffdefe3ea4c1c6f973091f7fcd0" class="ne-p"><span class="ne-text">判断是否为左值：看是否允许取地址&amp;运算符获得对应的内存地址。</span></p></div><p id="959f3baabc345c9cc324f27420f5d16f" class="ne-p"><strong><span class="ne-text">++i可以返回左值，i++不可以。</span></strong><span class="ne-text">（下面的截图对i++报错，对++i没有报错）</span></p><p id="21fafa6a5e8632dfc317f4ace858cc73" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1627437597153-a59bb261-e406-46f3-8bbb-34af9278b55d.png" width="761" id="Kc6Sg" class="ne-image"></p><p id="9d49f8f0301781a9f1e005e831f42923" class="ne-p"><br></p><p id="8cbc579eae24cf1243b7dc48adb8cbc3" class="ne-p"><span class="ne-text">i++和++i的实现：</span></p><pre><code>// 前缀形式：++iint&amp; int::operator++() //这里返回的是一个引用形式，就是说函数返回值也可以作为一个左值使用&#123;//函数本身无参，意味着是在自身空间内增加1的  *this += 1;  // 增加  return *this;  // 取回值&#125;<p>//后缀形式：i++<br>const int int::operator++(int) //函数返回值是一个非左值型的，与前缀形式的差别所在。<br>&#123;//函数带参，说明有另外的空间开辟<br>  int oldValue = *this;  // 取回值<br>  ++(*this);  // 增加<br>  return oldValue;  // 返回被取回的值<br>&#125;<br></code></pre></p><p id="0d749fc34ae2871acdb12a30ff18cfe8" class="ne-p"><br></p><p id="7cfeb712bf544e16fb19db3f76dc80b8" class="ne-p"><span class="ne-text">从这个代码也可以看出++i的效率是优于i++的，尽管很微弱。</span></p><p id="d0583fbb2c74ca0d23757cf453649629" class="ne-p"><br></p><div data-type="danger" class="ne-alert"><p id="aec6e38a293837eef420c2826726a984" class="ne-p"><span class="ne-text" style="background-color: #FFF3F3">大多数编译器已经对这两种使用方式封装，使其普通使用的效果几乎一致。</span></p></div><p id="72a9faf4dde1f00f9db035b59795ece1" class="ne-p"><br></p><div data-type="success" class="ne-alert"><p id="382e72f803d5cd997a84e8e93a54a152" class="ne-p"><span class="ne-text" style="background-color: #EDF9E8">今后尽量使用++i，特别是C++写题的时候。</span></p></div><p id="51a283f3fbec44890f013c37c17ad300" class="ne-p"><br></p><p id="2e5387db8d571168339d5e652d55fe73" class="ne-p"><br></p><p id="0567065769cacff436b96bc51ee97736" class="ne-p"><span class="ne-text">参考链接：</span></p><ul class="ne-ul"><li id="d3b4617aca6abc19bca98cfd9a2e763d"><a href="https://www.zhihu.com/question/19811087" data-href="https://www.zhihu.com/question/19811087" target="_blank" class="ne-link"><span class="ne-text">在程序开发中，++i 与 i++的区别在哪里？</span></a></li><li id="da0a72e0b6531880924eacfa377f5e26"><a href="https://blog.csdn.net/zlhy_/article/details/8349300" data-href="https://blog.csdn.net/zlhy_/article/details/8349300" target="_blank" class="ne-link"><span class="ne-text">为什么(i++)不能做左值，而(++i)可以</span></a></li></ul></div>]]></content>
      
      
      <categories>
          
          <category> 计算机素养 </category>
          
          <category> 后端编程语言 </category>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>终端环境配置</title>
      <link href="/blog/pa6aqc/"/>
      <url>/blog/pa6aqc/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="u07130102" class="ne-p"><span class="ne-text" style="color: #E8323C">命令相关教程：</span><a href="https://github.com/jlevy/the-art-of-command-line/blob/master/README-zh.md" data-href="https://github.com/jlevy/the-art-of-command-line/blob/master/README-zh.md" target="_blank" class="ne-link"><span class="ne-text" style="color: #E8323C">命令行的艺术</span></a><span class="ne-text">（the-art-of-command-line）</span></p><h2 id="Z3ER4"><span class="ne-text">scoop下载</span></h2><div class="ne-quote"><p id="u8477ab2a" class="ne-p"><span class="ne-text">Scoop是一款适用于Windows平台的命令行软件（包）管理工具，这里是Github介绍页。简单来说，就是可以通过命令行工具（PowerShell、CMD等）实现软件（包）的安装管理等需求，通过简单的一行代码实现软件的下载、安装、卸载、更新等操作。其灵感来源于macOS的Homebrew，Mac用户可以去了解了解。</span></p></div><ul class="ne-ul"><li id="uba66aecd"><span class="ne-text"></span><a href="https://scoop.sh/" data-href="https://scoop.sh/" target="_blank" class="ne-link"><span class="ne-text">https://scoop.sh/</span></a></li></ul><pre><code># 在 PowerShell 中输入下面内容，保证允许本地脚本的执行：set-executionpolicy remotesigned -scope currentuser</code></pre><pre><code># 然后执行下面的命令安装 Scoop：iex (new-object net.webclient).downloadstring('https://get.scoop.sh')</code></pre><pre><code># 静待脚本执行完成就可以了，安装成功后，让我们尝试一下：scoop help</code></pre><p id="ue576a6d8" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1639189556041-8c5d7b31-190e-463a-8ded-64ae19bc60d7.png" width="947" id="u42c137bf" class="ne-image"></p><h2 id="EIWO3"><span class="ne-text">lazygit</span></h2><p id="u1a9010b0" class="ne-p"><a href="https://github.com/jesseduffield/lazygit" data-href="https://github.com/jesseduffield/lazygit" target="_blank" class="ne-link"><span class="ne-text">https://github.com/jesseduffield/lazygit</span></a></p><p id="u0f9cf792" class="ne-p"><span class="ne-text"></span></p><p id="ud41786db" class="ne-p"><span class="ne-text">Add the extras bucket</span></p><pre><code>scoop bucket add extras</code></pre><p id="u2239e339" class="ne-p"><span class="ne-text">Install lazygit</span></p><pre><code>scoop install lazygit</code></pre><p id="udf3d5810" class="ne-p"><span class="ne-text">然后进入一个git文件夹用终端打开输入 </span><code class="ne-code"><span class="ne-text">lazygit</span></code><span class="ne-text"> 即可</span></p><h2 id="qlxSq"><span class="ne-text">Windows Terminal</span></h2><ul class="ne-ul"><li id="u7d927532"><span class="ne-text">官方教程：</span><a href="https://docs.microsoft.com/zh-cn/windows/terminal/" data-href="https://docs.microsoft.com/zh-cn/windows/terminal/" target="_blank" class="ne-link"><span class="ne-text">https://docs.microsoft.com/zh-cn/windows/terminal/</span></a></li></ul><p id="ue4d7ad55" class="ne-p"><span class="ne-text">按照此教程可以DIY如下：</span></p><p id="ueba0e8ce" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1639822798943-6d29922d-cfe5-4101-bac7-3f94650392f3.png" width="249" id="u86db2961" class="ne-image"></p><p id="u679c5799" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1639822897499-1230f2d1-791d-4e59-ac32-06c718f71ac6.png" width="352" id="u35f1ca4e" class="ne-image"></p><h2 id="I0Oax"><span class="ne-text">oh-my-posh</span></h2><p id="ua8cde725" class="ne-p"><a href="https://ohmyposh.dev/docs/windows" data-href="https://ohmyposh.dev/docs/windows" target="_blank" class="ne-link"><span class="ne-text">https://ohmyposh.dev/docs/windows</span></a></p><p id="u12d991e3" class="ne-p"><span class="ne-text">下载oh-my-posh</span></p><pre><code>Install-Module oh-my-posh -Scope AllUsers</code></pre><pre><code>Install-Module posh-git -Scope AllUsers</code></pre><p id="u7ab1c822" class="ne-p"><br></p><p id="uc6128dd6" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1639190934169-c1b6e5bc-e0f9-4b34-bdf6-113ba4c3c8f6.png" width="250.015625" id="u81c84ea1" class="ne-image"></p><p id="uca6a246f" class="ne-p"><br></p><p id="uafe7c940" class="ne-p"><span class="ne-text">参考：</span><a href="https://zhuanlan.zhihu.com/p/163007658" data-href="https://zhuanlan.zhihu.com/p/163007658" target="_blank" class="ne-link"><span class="ne-text">https://zhuanlan.zhihu.com/p/163007658</span></a></p><hr id="EoSao" class="ne-hr"><ul class="ne-ul"><li id="ud840c42f"><a href="https://zhuanlan.zhihu.com/p/354603010" data-href="https://zhuanlan.zhihu.com/p/354603010" class="ne-link"><span class="ne-text">Windows Terminal美化（oh-my-posh3）</span></a></li><li id="uea65c2d8"><a href="https://blog.walterlv.com/post/beautify-powershell-like-zsh.html" data-href="https://blog.walterlv.com/post/beautify-powershell-like-zsh.html" class="ne-link"><span class="ne-text">将美化进行到底，使用 Oh My Posh 把 PowerShell 做成 oh-my-zsh 的样子</span></a></li><li id="ua634fb84"><a href="https://www.jeremyjone.com/917/" data-href="https://www.jeremyjone.com/917/" class="ne-link"><span class="ne-text">美化 Windows Terminal（升级版） - 修身养性，知行合一</span></a></li><li id="u6eb180e7"><a href="https://yqc.im/windows-terminal-using-windows-terminal/" data-href="https://yqc.im/windows-terminal-using-windows-terminal/" class="ne-link"><span class="ne-text">Windows 11 下 Windows Terminal 使用及美化小结</span></a></li></ul></div>]]></content>
      
      
      <categories>
          
          <category> 计算机素养 </category>
          
          <category> 环境搭建 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>『大老师+路哥+师傅+折棒』</title>
      <link href="/essay/mll6d7/"/>
      <url>/essay/mll6d7/</url>
      
        <content type="html"><![CDATA[<div class="yuque-hexo-lyrics-secret">这是加密文章！</div>]]></content>
      
      
      <categories>
          
          <category> 影视 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>《狼图腾》</title>
      <link href="/essay/gla4ug/"/>
      <url>/essay/gla4ug/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content-editor-core lake-engine lake-typography-classic" data-lake-element="root" data-selection-undefined="%7B%22path%22%3A%5B%5B0%5D%2C%5B0%5D%5D%2C%22active%22%3Atrue%7D"><p data-lake-id="u543fa103" id="u543fa103" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span data-card-type="inline" data-lake-card="image" id="uc7dc0cca" class="lake-card-margin-top lake-card-margin-bottom"><img data-role="image" src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1626253972954-cf013c98-7c95-4e4c-92d0-e58722469a3b.png" data-raw-src="" class="image lake-drag-image" alt="image.png" title="image.png" data-height="381px" style="visibility: visible; width: 260px;"></span></p><p data-lake-id="u9dac54c3" id="u9dac54c3" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="u6bff1602" id="u6bff1602" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>前言：在那蒙古草原上，有一种被崇敬的事物，那就是狼图腾。</span></p><p data-lake-id="udeff3fda" id="udeff3fda" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><div data-card-type="block" data-lake-card="hr" id="CmmUd"><hr style="background-color: rgb(232, 232, 232); border: 1px solid transparent; margin: 18px 0px;"></div><p data-lake-id="ue5a5925c" id="ue5a5925c" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>1</span></p><p data-lake-id="u1c60af3d" id="u1c60af3d" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="uca6277f6" id="uca6277f6" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>狼群是一个有组织的群体，进攻、放哨兵、撤退，都会按照既定的队形实施。</span></p><div data-card-type="block" data-lake-card="hr" id="6Sku3"><hr style="background-color: rgb(232, 232, 232); border: 1px solid transparent; margin: 18px 0px;"></div><p data-lake-id="uae7cad4c" id="uae7cad4c" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>2</span></p><p data-lake-id="uf31e0f26" id="uf31e0f26" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="u5ed098fb" id="u5ed098fb" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>黄羊和狼的互相存在就是草原上的生存法则</span></p><p data-lake-id="uda8314ad" id="uda8314ad" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><blockquote style="margin-top: 5px; margin-bottom: 5px; padding-left: 1em; margin-left: 0px; border-left: 3px solid rgb(238, 238, 238); opacity: 0.6;"><p data-lake-id="ua23268b3" id="ua23268b3" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>“老人说：我也打狼，可不能多打。要是把狼打绝了，草原就活不成。草原死了，人畜还能活吗？”</span></p></blockquote><p data-lake-id="u280faa97" id="u280faa97" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="ub93f42c2" id="ub93f42c2" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>“红卫兵”“知青”“学生”……</span></p><p data-lake-id="uf974bf1c" id="uf974bf1c" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>在那种蛮荒时代里，步入殷实温暖的蒙古包，其实倒也是不错的经历，简单纯粹。</span></p><p data-lake-id="ua6d05cdb" id="ua6d05cdb" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><blockquote style="margin-top: 5px; margin-bottom: 5px; padding-left: 1em; margin-left: 0px; border-left: 3px solid rgb(238, 238, 238); opacity: 0.6;"><p data-lake-id="udadbff77" id="udadbff77" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>“你们汉人胆子太小，像吃草的羊，我们蒙古人是吃肉的狼，你是该有点狼胆了。”</span></p></blockquote><p data-lake-id="u2a0e3bb1" id="u2a0e3bb1" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="u44901109" id="u44901109" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>狼是草原的守护神，腾格里（信奉的神）护着狼。</span></p><p data-lake-id="u969a5a5d" id="u969a5a5d" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>人的内心深处亦或者说人类最原始角色就有一种猎性，只是从一开始作为农耕民族，早已被“便捷”所“进化”地向绵羊一般，不再有猎性，不再是猎人……可能这就是一种我们常说的血性。</span></p><p data-lake-id="ub449121f" id="ub449121f" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><blockquote style="margin-top: 5px; margin-bottom: 5px; padding-left: 1em; margin-left: 0px; border-left: 3px solid rgb(238, 238, 238); opacity: 0.6;"><p data-lake-id="u029726ac" id="u029726ac" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>老人说：“光靠狼的狠劲还不行，还得靠狼的耐性”（智慧、耐性、组织性、纪律性）</span></p></blockquote><p data-lake-id="u999089a9" id="u999089a9" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="u0cc8398e" id="u0cc8398e" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>草原上的蒙古人更为精明，作为狼的徒弟，青出于蓝而胜于蓝。</span></p><div data-card-type="block" data-lake-card="hr" id="zPWCX"><hr style="background-color: rgb(232, 232, 232); border: 1px solid transparent; margin: 18px 0px;"></div><p data-lake-id="u2101a43d" id="u2101a43d" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>3</span></p><p data-lake-id="ua92eb9b6" id="ua92eb9b6" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="u5f16550f" id="u5f16550f" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>古老的草原逻辑解释了食肉名族和食草民族几千年来的争斗的根本</span></p><blockquote style="margin-top: 5px; margin-bottom: 5px; padding-left: 1em; margin-left: 0px; border-left: 3px solid rgb(238, 238, 238); opacity: 0.6;"><p data-lake-id="uc04ee30e" id="uc04ee30e" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>草原名族捍卫的是“大命”——草原和自然的命比人命更宝贵；</span></p><p data-lake-id="u4826bb5a" id="u4826bb5a" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>而农耕名族捍卫的是“小命”——天下最宝贵的是人命和活命。</span></p><p data-lake-id="ufd831779" id="ufd831779" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>可是大命没了小命全都没命。</span></p></blockquote><div data-card-type="block" data-lake-card="hr" id="wLRS9"><hr style="background-color: rgb(232, 232, 232); border: 1px solid transparent; margin: 18px 0px;"></div><p data-lake-id="u4b11bd2d" id="u4b11bd2d" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>4</span></p><p data-lake-id="u5431f816" id="u5431f816" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="ud53eb6dc" id="ud53eb6dc" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>对狼的敬畏</span></p><blockquote style="margin-top: 5px; margin-bottom: 5px; padding-left: 1em; margin-left: 0px; border-left: 3px solid rgb(238, 238, 238); opacity: 0.6;"><p data-lake-id="u2f59cd7b" id="u2f59cd7b" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>在草原不吃食物，就不能算是真正的草原蒙古人。</span></p></blockquote><p data-lake-id="u9ab7f897" id="u9ab7f897" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>狼死了，狼的灵魂也会飞回腾格里那儿去的。</span></p><p data-lake-id="uf34b5114" id="uf34b5114" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>什么才叫真正的崇敬，对于蒙古民族，崇敬狼图腾，在一个人生命的终点，将躯体当成裸露坦荡的祭祀供品，从而把自己解脱的如此彻底。</span></p><div data-card-type="block" data-lake-card="hr" id="lR2Ih"><hr style="background-color: rgb(232, 232, 232); border: 1px solid transparent; margin: 18px 0px;"></div><p data-lake-id="u66e4851e" id="u66e4851e" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>5</span></p><p data-lake-id="uf0531126" id="uf0531126" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="u58887fa8" id="u58887fa8" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>巴图带领上等军马出去被狼群袭击。</span></p><p data-lake-id="ubecf5114" id="ubecf5114" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>丧崽哭嚎的母狼加入狼群，会格外地疯狂残忍</span></p><p data-lake-id="ue7ac01c3" id="ue7ac01c3" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>疯狼不能打，越打越凶，越杀越疯，疯狼的报复心草原上无人不怕</span></p><p data-lake-id="u813968f1" id="u813968f1" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>对狼来说，狼牙就是狼命。狼没了牙，狼就没了天</span></p><blockquote style="margin-top: 5px; margin-bottom: 5px; padding-left: 1em; margin-left: 0px; border-left: 3px solid rgb(238, 238, 238); opacity: 0.6;"><p data-lake-id="ucd935f61" id="ucd935f61" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>狼的最凶狠锐利的武器就是它的上下四根狼牙，如果没有狼牙，狼所有的勇敢、强悍、狡猾、凶残、贪婪、狂妄、野心、雄心、耐性、机敏、警觉、体力、耐力、等等一切的品性、个性和物性，统统等于零。</span></p></blockquote><div data-card-type="block" data-lake-card="hr" id="SfpBT"><hr style="background-color: rgb(232, 232, 232); border: 1px solid transparent; margin: 18px 0px;"></div><p data-lake-id="u83e0eec1" id="u83e0eec1" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>6</span></p><p data-lake-id="u97953c5b" id="u97953c5b" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="uc94801ed" id="uc94801ed" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p></div>]]></content>
      
      
      <categories>
          
          <category> 阅读 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>各类查找算法汇总</title>
      <link href="/blog/umxpln/"/>
      <url>/blog/umxpln/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="8adac5ba86bd45e4adf373e42360d57c" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1625064864232-8fab0164-7210-430e-881a-cf4c938d7165.jpeg" width="1200" id="SHNRc" class="ne-image"></p><p id="944c0aa28a1c84bff877f90ebf514191" class="ne-p"><span class="ne-text"></span></p><div data-type="info" class="ne-alert"><p id="a20d224c568e48b9d67847a2c66a8c01_p_0" class="ne-p"><span class="ne-text">前言：查找算法在书上分为三种</span></p><p id="a597d1ad49b48d22508abbbbea3ec86e" class="ne-p"><span class="ne-text">第一种是比较常用且较为简单的线性表查找；</span></p><p id="897d027ea2ee01fd9a0aebe390fc3f0b" class="ne-p"><span class="ne-text">第二种数表查找；</span></p><p id="ce176108f62145efbfd3a24cb4d98a5b" class="ne-p"><span class="ne-text">最后一种是哈希表查找。</span></p></div><p id="67182dad42b62d5e8622c3c03bef6da0" class="ne-p"><br></p><h2 id="CyDdg"><span class="ne-text">线性表查找</span></h2><h3 id="FCWSB"><span class="ne-text">顺序查找</span></h3><p id="d4c59044944821a6484b17213ecdbd10" class="ne-p"><span class="ne-text">就是最为常用的，将关键字依次将给定序列中的各个元素依次比较</span></p><h3 id="cPCW8"><span class="ne-text">折半查找</span></h3><p id="3d01e8062e09006f7c20e7552fc3f74c" class="ne-p"><span class="ne-text">不知道是不是也可以叫做二分查找，局限条件为有序序列，然后每次折半，在折半的范围内查找</span></p><h3 id="DeKVL"><span class="ne-text">分块查找</span></h3><p id="b00e4c76ba73f41ca27458adca579419" class="ne-p"><span class="ne-text">书中给定的情景时，索引表的数据项是按照关键字有序排列的，但是关键字所对应的子块可能是无序的，所以按照这种情景可以对索引表进行折半查找/顺序查找，对子快只能进行顺序查找（因为每个子块都不是有序的）</span></p><p id="a30e11f1bfbf2faaabd0ae1dca63ef9b" class="ne-p"><br></p><h2 id="9d8D2"><span class="ne-text">数表查找</span></h2><h3 id="tjgDp"><span class="ne-text">二叉排序树</span></h3><p id="9fc58666f27422e02f8aeec494a1a71c" class="ne-p"><span class="ne-text">关键字的特点：“左&lt;根&lt;右”</span></p><p id="8e6fe69fea0896f38b3f59f6be3730d4" class="ne-p"><span class="ne-text">创建：由一个给定序列建立二叉排序树</span></p><p id="12db53eadb5aa3ea5e8b418d21b29e4f" class="ne-p"><span class="ne-text">查找：所以只要给定一个二叉排序树，按照中序递归输出即可得到排好序的序列</span></p><p id="5a7ae08ae3a5396b8ca3b18e86f034ad" class="ne-p"><br></p><h3 id="bRpmP"><span class="ne-text">平衡二叉树</span></h3><p id="3a8c0cd0856c6e6e742f45f2f63f55a0" class="ne-p"><span class="ne-text">这个是基于上面的二叉排序树的，但是这个提出了一个结点的平衡因子概念，要求每个结点的平衡因子的绝对值不能大于1</span></p><p id="9268e85de4b9959351ca063296488a35" class="ne-p"><span class="ne-text">创建：给定一个序列，一开始还是按照二叉排序树的形式构造，当出现结点的平衡因子“非法”对其进行“调整”，一般有四种“违法”情况：LL、RR、LR、RL</span></p><p id="9f543d1b419aed077783462fe6cb998a" class="ne-p"><span class="ne-text">查找：还是按照中序遍历即可，中序遍历输出的序列就是排好序的序列</span></p><p id="2c8c0aa7c5d4e466b7f3457acea9ee09" class="ne-p"><br></p><div data-type="tips" class="ne-alert"><p id="cf72d628c02cf8725b5e38911aa80a04" class="ne-p"><span class="ne-text">上面所有查找方法都是内查找法，就是在内存中进行的，下面的是用到磁盘存储的查找方式</span></p></div><h3 id="6A7WD"><span class="ne-text">TODO: B-树</span></h3><h3 id="On2mJ"><span class="ne-text">TODO: B+树</span></h3><h2 id="QNvCf"><span class="ne-text">TODO: 散列表查找</span></h2></div>]]></content>
      
      
      <categories>
          
          <category> 计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 📊查找排序算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数字电路总结</title>
      <link href="/blog/tn3fhp/"/>
      <url>/blog/tn3fhp/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="u1d56c84c" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1627439456204-1f0fe7c2-b603-476f-93ee-d3705839148c.png" width="354" id="u0286b041" class="ne-image"></p><p id="u4d9aedc3" class="ne-p"><br></p><div data-type="info" class="ne-alert"><p id="uf894e305" class="ne-p"><span class="ne-text">前言：利用猴博士视频总结的题型对整个数字电路做出复习。</span></p></div><p id="u8876d1ed" class="ne-p"><br></p><h2 id="ApQo3"><span class="ne-text">一、进制及其转换</span></h2><ul class="ne-ul"><li id="u16ac593a"><span class="ne-text">二进制：B</span></li><li id="ub646bb4b"><span class="ne-text">十进制：D</span></li></ul><ul start="3" class="ne-ul"><li id="u4ff7bfc0"><span class="ne-text">八进制：O</span></li><li id="u7751179c"><span class="ne-text">十六进制：H</span></li></ul><p id="u2eb26806" class="ne-p"><br></p><p id="u0dfe7ac0" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1624499655205-1611e06a-b4bf-49c1-9890-5fe12bbfc2bc.png" width="500.5" id="u30777ccf" class="ne-image"></p><p id="ubf37a27c" class="ne-p"><br></p><h2 id="vhLvf"><span class="ne-text">二、逻辑门电路</span></h2><h3 id="uardA"><span class="ne-text">给出逻辑图、输入，求输出</span></h3><p id="u7b154172" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1624458112503-bd20e917-0fbd-4ab0-9ff4-b4ccd9865fc4.png" width="554.5" id="u108d5323" class="ne-image"></p><h3 id="xID8V"><span class="ne-text">给出逻辑图，写表达式</span></h3><p id="uef96a2d9" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1624458199919-649be4e4-ce94-4902-9c69-5595aff00f9e.png" width="557" id="ude5115ed" class="ne-image"></p><h3 id="StyE1"><span class="ne-text">给出表达式，画逻辑图</span></h3><p id="u9221886b" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1624458182439-0e80d369-7d17-453d-b7e6-d30e6e046598.png" width="487.5" id="u34ba51a5" class="ne-image"></p><h2 id="xIN31"><span class="ne-text">三、化简逻辑函数表达式</span></h2><h3 id="vBQ14"><span class="ne-text">公式法化简</span></h3><p id="u31c7e7a0" class="ne-p"><span class="ne-text">拍照那个笔记</span></p><h3 id="RzjkG"><span class="ne-text">卡诺图法化简</span></h3><p id="u1980cb57" class="ne-p"><span class="ne-text">要求：</span></p><ol class="ne-ol"><li id="u2a3f7583"><span class="ne-text">卡诺图表示成逻辑函数表达式</span></li><li id="ud0f9b627"><span class="ne-text">逻辑函数表达式表示成卡诺图</span></li></ol><ol start="3" class="ne-ol"><li id="u2d26855b"><span class="ne-text">化简逻辑函数表达式</span></li></ol><ol ne-level="1" class="ne-ol"><li id="u281d3b6e"><span class="ne-text">没有约束</span></li><li id="u661820ea"><span class="ne-text">有约束</span></li></ol><p id="u29f02f24" class="ne-p"><br></p><p id="u2fc80979" class="ne-p"><span class="ne-text">注意以下几点：</span></p><ul class="ne-ul"><li id="u139f5c42"><span class="ne-text">能圈多的就圈多的</span></li><li id="u70fdd96c"><span class="ne-text">约束项*能用就用，用的时候就为1，不用的时候就为0，不需要一定将其应用，*只是服务于1的</span></li></ul><p id="ua5fd92db" class="ne-p"><span class="ne-text"></span></p><h3 id="JkWMO"><span class="ne-text">求反函数</span></h3><p id="u59dd4c77" class="ne-p"><span class="ne-text">根据逻辑函数表达式求反函数</span></p><div class="ne-quote"><ul class="ne-ul"><li id="ue5616d8c"><span class="ne-text">把所有的“与”“或”互换</span></li><li id="u9ecb2432"><span class="ne-text">把所有的0、1互换</span></li></ul><ul start="3" class="ne-ul"><li id="ua54dd42e"><span class="ne-text">原变量和反变量互换</span></li><li id="u037171f1"><span class="ne-text">多个变量的公共非不变</span></li></ul><ul start="5" class="ne-ul"><li id="u9c5a6d39"><span class="ne-text">原始运算的优先顺序不变</span></li></ul></div><p id="u8b98b20d" class="ne-p"><span class="ne-text">根据卡诺图求反函数</span></p><div class="ne-quote"><ul class="ne-ul"><li id="ud37850bd"><span class="ne-text">把图中的0、1互换</span></li><li id="u94d8571b"><span class="ne-text">信徒写出来即可</span></li></ul></div><h2 id="KgpZK"><span class="ne-text">四、组合逻辑电路的分析与设计</span></h2><h3 id="rEHT8"><span class="ne-text">给出逻辑电路图，分析逻辑功能</span></h3><ul class="ne-ul"><li id="uf9001601"><span class="ne-text">逻辑电路图写出函数表达式</span></li><li id="u2d929d38"><span class="ne-text">化简函数表达式（符合要求的）</span></li></ul><ul start="3" class="ne-ul"><li id="uab5cbf33"><span class="ne-text">列出所有情况</span></li><li id="u1d887648"><span class="ne-text">分析出功能</span></li></ul><div class="ne-quote"><p id="u2647044e" class="ne-p"><span class="ne-text">常见的功能有：不一致电路、一致电路、少数服从多数电路</span></p></div><h3 id="gBuKz"><span class="ne-text">给出逻辑功能，画出逻辑电路图</span></h3><p id="u121349e2" class="ne-p"><span class="ne-text">和上面的步骤差不多，</span></p><ul class="ne-ul"><li id="u820d8078"><span class="ne-text">确定输入个数，定义0、1</span></li><li id="u85c18170"><span class="ne-text">列真值表</span></li></ul><ul start="3" class="ne-ul"><li id="ucc3ed547"><span class="ne-text">写出逻辑函数表达式</span></li><li id="u169a605d"><span class="ne-text">化简</span></li></ul><ul start="5" class="ne-ul"><li id="udb6922d4"><span class="ne-text">画出电路图</span></li></ul><h2 id="K5XZx"><span class="ne-text">五、最小项</span></h2><h3 id="qQXKn"><span class="ne-text">卡诺图求最小项</span></h3><ul class="ne-ul"><li id="u048982d0"><span class="ne-text">把逻辑函数表达式转换为卡诺图</span></li><li id="u11706cfe"><span class="ne-text">卡诺图里面为1的就是该位置二进制存在的最小项</span></li></ul><p id="ue4f16148" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1624457764328-fc869be5-3d63-4499-9a9a-6e82ca2601fe.png" width="617" id="u2aba1ab9" class="ne-image"></p><h3 id="vkFyT"><span class="ne-text">公式法求最小项</span></h3><p id="uc8350073" class="ne-p"><span class="ne-text">就是通俗的化简，不过结果的每一项都必须包含每个字母，最后用二进制表示</span></p><p id="u56e8eff8" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1624457888889-57837834-3e20-4a68-93f2-94a5d9cf0482.png" width="374.5" id="u17d70b37" class="ne-image"></p><h3 id="Q1hdE"><span class="ne-text">最小项化成变量形式</span></h3><p id="u74fd1448" class="ne-p"><span class="ne-text">将其下标化成二进制，然后转换</span></p><p id="ufc02732c" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1624457989908-8eeaae47-38c1-440b-a1b6-aacda1358653.png" width="483" id="u744474eb" class="ne-image"></p><h3 id="PoVZa"><span class="ne-text">卡诺图化简有约束条件的</span></h3><p id="u9dd108d9" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1624458044603-7393051c-fa08-444d-8890-d510b20f259a.png" width="499.5" id="ud5764522" class="ne-image"></p><h2 id="mvA4U"><span class="ne-text">六、常用的集成器件</span></h2><h3 id="tFSzw"><span class="ne-text">译码器和门电路实现逻辑函数</span></h3><p id="uf2944355" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1624495725174-7d84b3db-0535-4e9c-8445-eca05056e43e.png" width="503.5" id="u6d89f5d1" class="ne-image"></p><h3 id="yp7Bb"><span class="ne-text">译码器接线图写出逻辑函数</span></h3><p id="u22797bfd" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1624495940765-119658e7-e960-4fc3-83a7-634fdc6dc8dd.png" width="491" id="u076f4229" class="ne-image"></p><h3 id="UlDQ9"><span class="ne-text">8选1数据选择器实现3输入逻辑函数</span></h3><p id="ud45570a7" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1624496141542-776d204b-0332-4dad-acc1-c75ac793c2b7.png" width="504.5" id="u3f7c15b1" class="ne-image"></p><p id="u81d0fd72" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1624496797353-52c90305-9a96-4b48-9e94-d4ef979229e1.png" width="500" id="u693c19a9" class="ne-image"></p><h3 id="a7mKV"><span class="ne-text">8选1数据选择器实现多输入逻辑函数</span></h3><p id="u4034e95a" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1624496656766-4a7aa12f-e321-4db0-a4ad-08b6fa88599e.png" width="507" id="u6828df9f" class="ne-image"></p><p id="u1178e1ca" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1624496990732-16fbfeea-0384-4da7-9a20-af26f3a367c3.png" width="507" id="ucd4d8900" class="ne-image"></p><h2 id="HDybP"><span class="ne-text">七、触发器</span></h2><h3 id="SEpD6"><span class="ne-text">同步RS触发器</span></h3><p id="u020023c3" class="ne-p"><br></p><h3 id="iWmbZ"><span class="ne-text">给出D触发器及输入，画出波形图</span></h3><p id="ubbb059eb" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1624537249474-e313d1d4-e54a-4f11-801a-7cb35477b1ab.png" width="504" id="ua213f1e1" class="ne-image"></p><h3 id="AC2Y7"><span class="ne-text">给出JK触发器及输入，画出波形图</span></h3><p id="uaaa0c047" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1624537215870-9c84a3f2-bc32-45fc-ad01-711ccedb1f2f.png" width="500" id="u906a2e93" class="ne-image"></p><p id="uf37039fa" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1624537294036-58b09d4c-ff3f-463b-a638-40a8d9aceb27.png" width="497" id="u4547f333" class="ne-image"></p><h3 id="wE0EQ"><span class="ne-text">多个触发器相连</span></h3><p id="ue5357d3d" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1624537373073-41ebf1b0-eefa-4780-bf91-d48419f01d2d.png" width="489" id="ub2a45094" class="ne-image"></p><h2 id="w0KLf"><span class="ne-text">问答题</span></h2><p id="u92521508" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1624539793127-eb24945d-a5b8-4b60-ad1b-52764290c914.png" width="427" id="u9205094c" class="ne-image"></p><p id="u57e9de9c" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1624539824281-1a7c5e6a-774d-41de-96c0-68525d81eb6c.png" width="256.5" id="u71ba7cb4" class="ne-image"></p><p id="u2570e8e3" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1624539813127-8f316639-a479-4cf2-89b6-7e8d2d6ac7e9.png" width="179" id="u41542c50" class="ne-image"></p><p id="u05bb5331" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1624539898752-fe3a106e-2e6d-4296-8ea7-bd2e434481a9.png" width="531" id="uc035f11a" class="ne-image"></p></div>]]></content>
      
      
      <categories>
          
          <category> 计算机素养 </category>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>《洒脱的人才“玩”得起人生》</title>
      <link href="/essay/mzd92z/"/>
      <url>/essay/mzd92z/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="u95c01ed3" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1624193059628-8f003b19-46ac-47e4-b4af-23593b54b32a.jpeg" width="261.0115966796875" id="u43723471" class="ne-image"></p><p id="u20aa99fc" class="ne-p"><br></p><p id="ufd378d88" class="ne-p"><span class="ne-text">前言：</span><strong><span class="ne-text">我喜欢洒脱的人生态度，洒脱的人，活得简单、快乐</span></strong><span class="ne-text">。</span></p><p id="ub654de52" class="ne-p"><br></p><p id="u1430b4f7" class="ne-p"><span class="ne-text">对蔡澜的认识是源于『舌尖上的中国』，只知道他是一位美食家，最近才知道，蔡先生是一位见识丰富，极具艺术气质的一个人，他不仅是一位美食家，还是作家，电影制片人。</span></p><p id="u2a45e7fb" class="ne-p"><br></p><p id="u99ab65da" class="ne-p"><span class="ne-text">看完蔡澜先生写的这本随笔，会有一种豁达随性之感，有一种“生活本该如此”的感觉。整本书就是作者的随笔合集，作者有记录生活的那些看似不起眼，却也能吐槽，放开心境的一系列事情。书中还记录作者所吃过的许许多多的美食随笔，看这本书有一种吃甜点的那种愉悦感。</span></p><p id="u5f3db708" class="ne-p"><br></p><hr id="RK0bl" class="ne-hr"><p id="u88c00c22" class="ne-p"><span class="ne-text">最喜欢书里面的一段话：</span></p><p id="uc15d2bc4" class="ne-p"><br></p><div class="ne-quote"><p id="ue27f8d2a" class="ne-p"><strong><span class="ne-text">人生的意义太过广泛，这个问题天下多少宗教家、哲学家都解答不了。吃得好一点，睡得好一点，多玩玩，不羡慕别人，不听管束，多储蓄人生经验，死而无憾。这就是最大的意义吧，一点儿也不复杂</span></strong><span class="ne-text">。</span></p></div><h2 id="JUsTC"><span class="ne-text">一、我承认我快乐</span></h2><p id="u0371e027" class="ne-p"><span class="ne-text">快乐</span></p><p id="uba408fb0" class="ne-p"><br></p><p id="u577551e3" class="ne-p"><span class="ne-text">一天过得比一天快乐，是人生欢乐可行之道。可以从不刻薄自己开始。努力之余，想要什么就放手去买、去做。旅行最好，多学一样东西也不错。（蔡澜语录）</span></p><hr id="79LLN" class="ne-hr"><p id="uc9890a3b" class="ne-p"><span class="ne-text">想做的事</span></p><p id="u58dbba98" class="ne-p"><br></p><p id="u3524ee17" class="ne-p"><span class="ne-text">等到我所有的欲望都消失了，像看到好吃的东西也不想吃，好看的女人也不想和她们睡觉时，我就会去雕刻佛像，我好像说过这件事，我在清迈有一块地，可以建筑一间工作室，到时天天刻佛像，刻后涂上五颜六色，佛像的脸，像你、像我，不一定是菩萨观音。（蔡澜语录）</span></p><p id="u4109acb9" class="ne-p"><br></p><p id="ue3c4f8d8" class="ne-p"><span class="ne-text">问：“那么多的兴趣，要等到什么时候才去做？是不是要等到退休？”</span></p><p id="udabdf07b" class="ne-p"><span class="ne-text">答：“我早已退休了，从很年轻开始已经学会退休。我一直觉得时间不够用，只能在某一段时期，做某件事，什么时候开始，什么时候终结，随缘吧。”</span></p><p id="ub75c7b6c" class="ne-p"><br></p><hr id="OuIYr" class="ne-hr"><p id="uc5810815" class="ne-p"><span class="ne-text">好玩之都</span></p><p id="u0c73a96f" class="ne-p"><br></p><p id="ud7390983" class="ne-p"><span class="ne-text">在这个充满丑闻的都市中，我们得到了无限的欢乐，只要一天不死，就有笑话看。是的，还是香港好。（蔡澜语录）</span></p><hr id="hz7EN" class="ne-hr"><p id="uf5edc47f" class="ne-p"><span class="ne-text">玩物丧志</span></p><p id="uecd93098" class="ne-p"><br></p><p id="u476108d2" class="ne-p"><span class="ne-text">谁说玩物丧志？玩物养志才对！（蔡澜语录）</span></p><p id="u5d8c99de" class="ne-p"><br></p><div data-type="info" class="ne-alert"><p id="ua3a3f445" class="ne-p"><span class="ne-text">玩物丧志吗？</span></p><p id="uf5be0e66" class="ne-p"><span class="ne-text">谁都知道，如果玩的是自己极其感兴趣的，会走出不一样的路，讽刺的是，世上绝大多数人都不敢这么做……</span></p></div><hr id="kAhk0" class="ne-hr"><p id="u20bc0403" class="ne-p"><span class="ne-text">偷笑</span></p><p id="u1ba32475" class="ne-p"><br></p><p id="u8fd3e8d3" class="ne-p"><span class="ne-text">庆幸的是我没有生儿育女的经验。看到别人的失落，我躲起来偷笑。想到自己结交的一些年轻女友都是人家的女儿，笑得更厉害了。（蔡澜语录）</span></p><p id="u9f2d9d40" class="ne-p"><br></p><p id="u7c1df666" class="ne-p"><span class="ne-text">（看这段的时候，笑死）</span></p><p id="ua0655bf9" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1624348364148-8176d785-505c-4979-873b-8dbdb4341941.png" width="96" id="gGEfk" class="ne-image"></p><hr id="4v0rs" class="ne-hr"><p id="u0b21b0ce" class="ne-p"><br></p><p id="ue2cba551" class="ne-p"><span class="ne-text">后悔</span></p><p id="u5cde919e" class="ne-p"><br></p><p id="u73b9e286" class="ne-p"><span class="ne-text">后悔，我们一定有过。烦恼出自我们的贪婪。两者兼得，就产生后悔和痛苦。a君或b君，要哪一个？烦恼即来。选其中一个，不后悔就是。一切灾殃化为尘，阿弥陀佛！（蔡澜语录）</span></p><hr id="5jhEJ" class="ne-hr"><p id="u278e085e" class="ne-p"><span class="ne-text">惊讶状</span></p><p id="ubb394a0e" class="ne-p"><br></p><p id="u1c7a301e" class="ne-p"><span class="ne-text">换一个新环境，就像交了个新情妇，晚上睡不着觉，一大早起床便往外跑，想发现每一个角落有什么不同的。这种心情是兴奋的、年轻的。这就是我爱旅行、爱住酒店的主要原因。（蔡澜语录）</span></p><p id="u5b398b06" class="ne-p"><br></p><div data-type="info" class="ne-alert"><p id="uad4b7af9" class="ne-p"><span class="ne-text">这段作者讲述的是在帮一个朋友宣传的时候，某社报的记者来访问的情形，这个记者每句话离不开一个“哟”……</span></p></div><hr id="ENUu5" class="ne-hr"><p id="u8d6d7b79" class="ne-p"><span class="ne-text">水准</span></p><p id="u72d9e938" class="ne-p"><br></p><p id="u3df047cf" class="ne-p"><span class="ne-text">日本有一个很出名的料理人，他教了很多徒弟，其中有一个他最喜欢，但是他不教很多花样，每天一早，就叫这个徒弟煮一碗面豉汤给他喝。徒弟做了三年，师父也喝了三年。每天喝完不称赞，也不批评。后来徒弟才知道，师父教他的是保持一贯的水准，这是最重要的，客人吃了吃了，就吃出瘾来，不光顾不可。</span></p><p id="ueb3a0243" class="ne-p"><br></p><div data-type="info" class="ne-alert"><p id="u02ca7c7c" class="ne-p"><span class="ne-text">很多时候，最本真的或许才是最好的。</span></p><p id="ufe1832c0" class="ne-p"><span class="ne-text">想起了在天津吃的那家网红烤肉店，虽然整个餐厅运营机制不方便，但是吃到原生的服务员做的烤肉那味道，那种感觉还是很美妙的。</span></p></div><hr id="oGcYG" class="ne-hr"><p id="u2e12c8bd" class="ne-p"><span class="ne-text">蓝莓园</span></p><p id="ub91af9f9" class="ne-p"><br></p><p id="ud9862cb0" class="ne-p"><span class="ne-text">从吃一顿饭，便能观察对方是怎样的一种人。拿筷子搬弄一番又不选一块来吃，好不了哪里。大刺刺地先吃最好的部分，而不留给朋友，非常自私。夹了一大堆食物而不去动，是个贪心损人不利己的。畅怀大嚼，属于豁达型，豪放又来得性感，无妨深交。（蔡澜语录）</span></p><p id="u8530c9c1" class="ne-p"><br></p><div data-type="info" class="ne-alert"><p id="u1e23ce95" class="ne-p"><span class="ne-text">哈哈哈，好像还真有道理……</span></p></div><p id="ue14cc5e5" class="ne-p"><br></p><p id="u098d1e17" class="ne-p"><span class="ne-text">对着一望无际的蓝莓，他说：“一粒粒采摘，吃不完做果酱，春天也会开漂亮的花。到了秋天，蓝莓树像枫叶一样满山变红。那边有几棵高大的栗子树，果实熟了掉下，一面看红叶一面烤来吃，我已经不能回到城市去了。”</span></p><p id="u037d7e68" class="ne-p"><br></p><div data-type="info" class="ne-alert"><p id="u67a3e566" class="ne-p"><span class="ne-text">“明知是一场意外，你要不要来”</span></p><p id="udf9a8c0f" class="ne-p"><span class="ne-text">此般愿景，去又何妨</span></p></div><p id="ub9ad0193" class="ne-p"><br></p><hr id="CwGZl" class="ne-hr"><p id="u4b451aa9" class="ne-p"><span class="ne-text">不胖</span></p><p id="ucd64d492" class="ne-p"><br></p><p id="ueb39a037" class="ne-p"><span class="ne-text">一切浅尝，当然肥不了，但还是装腔作势，回答说：“真正会吃的人，是不胖的。”（蔡澜语录）</span></p><p id="u7dca521b" class="ne-p"><br></p><hr id="1aG4i" class="ne-hr"><p id="ua8601943" class="ne-p"><span class="ne-text">演讲与拐杖</span></p><p id="u6450329a" class="ne-p"><br></p><p id="uff5989f5" class="ne-p"><span class="ne-text">能进步的人，都有自己独立的思想，听他们的谈吐，就知与众不同，感想和观点皆独特的，都是努力奋斗的人物。（蔡澜语录）</span></p><hr id="PpRAH" class="ne-hr"><p id="u8d6a8dc9" class="ne-p"><span class="ne-text">世界上的厕所</span></p><p id="u3fa0381c" class="ne-p"><br></p><p id="u07342951" class="ne-p"><span class="ne-text">如果你很想在一生中出一本书的话，也不必有太多的才华，将所闻所见以相机拍下，再加上几行说明文字即行。举个例子，世界上的街灯都不同，乘现在年轻看到了就记录拍下，也是一本好书。（蔡澜语录）</span></p><p id="u2b314737" class="ne-p"><br></p><div data-type="info" class="ne-alert"><p id="u8c52eb5d" class="ne-p"><span class="ne-text">生活是一切美好事物的源泉</span></p></div><hr id="ZCK72" class="ne-hr"><p id="u1f606d10" class="ne-p"><span class="ne-text">整容</span></p><p id="u2bcb442f" class="ne-p"><br></p><p id="u8b985084" class="ne-p"><span class="ne-text">韩国女人愈来愈会打扮，愈来愈会穿衣服，不过这一点儿用处也没有，给外国人的印象，她们的美还是整容的结果。这对她们一点儿也不公平，数十年前经济未起飞时，哪有钱做手术，美女还不是多过其他国家？（蔡澜语录）</span></p><hr id="avytb" class="ne-hr"><p id="u32083649" class="ne-p"><span class="ne-text">商机</span></p><p id="ude152817" class="ne-p"><br></p><p id="u9b018f8f" class="ne-p"><span class="ne-text">如果只为升值及价值而去收藏某物件，这是一种肤浅的行为，我不会刻意去收藏某种物件。买一件你喜欢的，因为可以用上一生一世。（蔡澜语录）</span></p><hr id="uhWkj" class="ne-hr"><p id="u3df64745" class="ne-p"><span class="ne-text">惊喜</span></p><p id="u3564d439" class="ne-p"><br></p><p id="ua1ecca0f" class="ne-p"><span class="ne-text">轮到了乐观派：“蔡先生的团总有惊喜，加了一个采苹果的节目，这次送给我们一次地震的经验。”（蔡澜语录）</span></p><p id="u2c4f6d0a" class="ne-p"><br></p><p id="u03eee7fb" class="ne-p"><span class="ne-text">另一位说：“</span><span class="ne-text" style="color: #F5222D">最大惊喜还是我老婆给我的。结婚十多年，这一次因为地震，她才紧紧抱住我。</span><span class="ne-text">”</span></p><p id="ua3763d25" class="ne-p"><br></p><div data-type="info" class="ne-alert"><p id="u9258cfdc" class="ne-p"><span class="ne-text">悲观者，和乐观者之间的差别，就在此了</span></p></div><p id="u6490f8de" class="ne-p"><br></p><p id="uee991034" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/gif/1484158/1624195248841-6bc739e9-a3ac-449f-8bd9-6afd3edc9fe5.gif" width="45" id="d9ReS" class="ne-image"></p><hr id="iPTg9" class="ne-hr"><p id="u4679e8be" class="ne-p"><span class="ne-text">白痴</span></p><p id="ubd58feca" class="ne-p"><br></p><p id="u0c553865" class="ne-p"><span class="ne-text">一个人一生中最需要储的，是说实话的本钱。年轻人还没有大本事，你面对同事上司，怎可能随便给人脸色看？明明碰上看不顺眼的人和事，你只有逆来顺受。要一点虚伪也要圆滑，等你建立了相当的自信和说服力后，便储了说实话的本钱。（蔡澜语录）</span></p><hr id="pMetU" class="ne-hr"><p id="ub64435c8" class="ne-p"><span class="ne-text">尊重<br /></span><span class="ne-text" style="color: #F5222D">　</span></p><p id="ua5cdc408" class="ne-p"><br></p><p id="u16124879" class="ne-p"><span class="ne-text">不觉得，我心中说，太操劳的事我已不会做。况且，第一团去过的地方第二团重访，店主即当我老爷拜。怪不得那位第一次参加的团友说：“最过瘾的是跟你去到那里，都得到人家的尊重。”（蔡澜语录）</span></p><p id="uf5abb4d0" class="ne-p"><br></p><div data-type="info" class="ne-alert"><p id="u7c8f86df" class="ne-p"><span class="ne-text">感受得到，做生意就是这样，诚恳，尊重他人，待人友善的这种做事风格</span></p></div><div data-type="info" class="ne-alert"><p id="u75963cb5" class="ne-p"><span class="ne-text">所有的快乐都是在自己生活中的点滴累计而成，生活啊，不要太难为自己~身边处处是一些美好的事物啊，难道不是吗？</span></p></div><p id="ue6518e22" class="ne-p"><br></p><h2 id="Yh9if"><span class="ne-text">二、今日的烦恼将成为明日的笑话</span></h2><p id="u6d06dbc1" class="ne-p"><br></p><p id="ud938f18d" class="ne-p"><span class="ne-text">专栏作家</span></p><p id="u9cf30ed4" class="ne-p"><br></p><p id="u28d89714" class="ne-p"><span class="ne-text">既然要写专栏，记得多看专栏，仔细研究其他作者的可读性因素何在。我开始时，先拜十三妹为师，她是专栏作家的老祖宗。本人未见，读遍她的文字，知道她除了谈论国际关系、文学音乐戏剧之外，也多涉及生活点滴，连看医生，向人借钱，也可以娓娓道来，这才能与读者融合在一起。（蔡澜语录）</span></p><p id="u5b344c61" class="ne-p"><br></p><p id="uad7098ac" class="ne-p"><span class="ne-text">作者需要不断地吸收，才能付出。需要不耻下问。旅行、交友、阅读、爱戏剧电影、绘画、音乐等等，是基本的条件。专栏作者和小说家完全是两码子事，后者可以把自己藏起来，编写出动人的故事，但是前者每天赤裸裸地把生活点滴奉献给读者。想过什么、做过什么，都在每天的专栏看得清清楚楚，是假装不出来的。</span></p><p id="ub4a88d73" class="ne-p"><br></p><p id="u7b4e3fee" class="ne-p"><span class="ne-text">我们这些写作人，多多少少都有发表欲，既然有了，不必要扮清高，迎合读者，不是大罪。</span></p><p id="u79358cd8" class="ne-p"><br></p><p id="u55a3832c" class="ne-p"><strong><span class="ne-text">真，是专栏作者的本钱，一假便被看穿，如果我们把真诚的感情放在文字上，读者也许不喜欢，可是一旦爱上，就是终生的了</span></strong><span class="ne-text">。</span></p><p id="ud8d43abc" class="ne-p"><br></p><p id="u5cd19cbc" class="ne-p"><span class="ne-text">既然要写专栏，记得多看专栏，仔细研究其他作者的可读性因素何在。我开始时，先拜十三妹为师，她是专栏作家的老祖宗。本人未见，读遍她的文字，知道她除了谈论国际关系、文学音乐戏剧之外，也多涉及生活点滴，连看医生，向人借钱，也可以娓娓道来，这才能与读者融合在一起。</span></p><p id="u6f5d6a81" class="ne-p"><br></p><div data-type="info" class="ne-alert"><p id="u531382dd" class="ne-p"><span class="ne-text">“真，是专栏作者得本钱！”受益这句话。</span></p></div><p id="ub9a5b83d" class="ne-p"><br></p><hr id="cFgK1" class="ne-hr"><p id="u0e0c8001" class="ne-p"><span class="ne-text">飞行等级</span></p><p id="u8593262e" class="ne-p"><br></p><p id="u3e1a197f" class="ne-p"><br></p><p id="u0ad696d7" class="ne-p"><span class="ne-text">生活质量的提高，商务舱已是抢手货，不管是否公费，大家一坐过之后，已不能退步去坐经济舱了，自掏腰包，也非商务不可，有些航线，已是一半商务一半经济了，更夸张的，是整架飞机，只有商务的趋势。</span></p><p id="uc55ae58d" class="ne-p"><span class="ne-text"><br /></span><span class="ne-text">人往高处，乘商务的，心中也一直想要坐头等，头等那么好吗？值得吗？<br /></span><span class="ne-text">可以把座椅当床平卧，是最大的特点，但这种服务，多数的商务舱已能做到。<br /></span><span class="ne-text">吃得好，喝得佳吗？也不是，所谓的香槟，皆非第一流的，鱼子酱更是咸得要死。坐欧洲的航空公司，头等还有一点头等味道，亚洲的，有钱人通街都是，不当你是贵客。头等，只能遇到一些不肯退休的空中服务员，反正不会被炒鱿鱼，也带狗眼看人低的眼光了。<br /></span><span class="ne-text">说什么，也是商务物有所值，但物有所值这句话，是昂贵的，当今的旅行费，绝不便宜。</span></p><p id="uc299d177" class="ne-p"><br></p><div data-type="info" class="ne-alert"><p id="u9836b93d" class="ne-p"><span class="ne-text">或许是不是所有事物都是物有所值把……</span></p></div><p id="u2d592bcb" class="ne-p"><br></p><h2 id="LPqqm"><span class="ne-text">三、只有自爱才心安理得</span></h2><p id="uf2a0221e" class="ne-p"><span class="ne-text">旅行伴侣</span></p><p id="u0b304dc2" class="ne-p"><span class="ne-text"><br /></span><span class="ne-text">看了电视剧而找原著来读的不乏其人，相反就寥寥无几。到底，电视剧给我们的是固定的形象，失去了看书的幻想力。（蔡澜语录）</span></p><p id="u395c48c8" class="ne-p"><br></p><div data-type="info" class="ne-alert"><p id="u4fddb723" class="ne-p"><span class="ne-text">还好吧，我觉得『士兵突击』这部电视剧和小说就不错。</span></p></div><p id="u17234d0e" class="ne-p"><br></p><hr id="kP6at" class="ne-hr"><p id="uda4ab8c6" class="ne-p"><span class="ne-text">交友</span></p><p id="ube810227" class="ne-p"><br></p><p id="ue2d8a17c" class="ne-p"><span class="ne-text">最重要的，是把自己最真实的一面表露出来。真面目示众又如何？相貌是父母赐予，不应为讨好别人而改变。如果不够自信，就努力看书，增加自己的内涵，多写精彩的文章，日子久了，就会有人欣赏。</span></p><p id="u8698e1e4" class="ne-p"><br></p><hr id="b4K8C" class="ne-hr"><p id="u7263fd8e" class="ne-p"><span class="ne-text">乐得拍掌</span></p><p id="u2b14386b" class="ne-p"><br></p><p id="ufecede8b" class="ne-p"><span class="ne-text">做人最好的就是醉生梦死。醉生，每天喝醉；梦死，在做梦的时候死去，多幸福！（蔡澜语录）</span></p><h2 id="HnFuJ"><span class="ne-text">四、豁得出去，又是另一片天空</span></h2><p id="u76bd7f0e" class="ne-p"><span class="ne-text">痴人说梦</span></p><p id="u2d495759" class="ne-p"><br></p><p id="u7062ceba" class="ne-p"><span class="ne-text">我一直做梦，梦见给人追杀。醒来，原来是一场梦，怎会不高兴？哈哈哈哈。（蔡澜语录）</span></p><hr id="g3Uxd" class="ne-hr"><p id="u1e463490" class="ne-p"><span class="ne-text">做人</span></p><p id="ucff3b11e" class="ne-p"><br></p><p id="u818cd5cb" class="ne-p"><span class="ne-text">从小，父母亲就要我好好地“做人”。做人就是努力别看他人脸色，做人，也不必要给别人脸色看。生了下来，大家都是平等的。人与人之间要有一份互相的尊敬。所以我不管对方是什么职业，是老是少，我都尊重。（蔡澜语录）</span></p><p id="u63f70902" class="ne-p"><br></p><p id="u90f3d33a" class="ne-p"><span class="ne-text">“你到底是什么身份？电影人？食家？茶商？开餐厅的？开杂货店的？做零食的？卖财柴米油盐酱的？你最想别人怎么看你？”朋友问。“我只想做一个人。”我回答。</span><span class="ne-text">　　从小，父母亲就要我好好地“做人”。做人还不容易吗？不。不容易。“什么叫会做人？”朋友说，“看人脸色不就是？”不，做人就是努力别看他人脸色，做人，也不必要给别人脸色看。</span></p><p id="u58fc3a0c" class="ne-p"><br></p><p id="uce132af8" class="ne-p"><span class="ne-text">生了下来，大家都是平等的。人与人之间要有一份互相的尊敬。所以我不管对方是什么职业，是老是少，我都尊重。</span></p><p id="ud1e2e64c" class="ne-p"><br></p><p id="ubea532f4" class="ne-p"><span class="ne-text">除了尊敬人，也要尊敬我们住的环境，这是一个基本条件。</span></p><p id="uc4807e65" class="ne-p"><br></p><hr id="qJ3m8" class="ne-hr"><h2 id="iOPBS"><span class="ne-text">五、你是为谁生存</span></h2><p id="uefce642b" class="ne-p"><span class="ne-text">最喜欢的</span></p><p id="uc9484557" class="ne-p"><br></p><p id="ue24ae12d" class="ne-p"><span class="ne-text">写文章不求留世，工作当消遣，有什么说什么，东西不好吃就说不好吃，这种讲真话的本钱，是我花了数十年储蓄回来的。从前有点违背良心的话，是看到女人，都叫她们为“靓女”。当今也花不了本钱，说：“聪明。”（蔡澜语录）</span></p><p id="u2863cd09" class="ne-p"><br></p><hr id="3G76q" class="ne-hr"><p id="ufb358f61" class="ne-p"><span class="ne-text">教坏</span></p><p id="u09d444b9" class="ne-p"><br></p><p id="ub76b5b4c" class="ne-p"><span class="ne-text">“现在的孩子，都太乖了。出到社会，不知怎么面对。由我来教坏，遇到什么骗子都不必怕。我有个电影界的泰国朋友秦子彬先生，他把好赌的儿子带到拉斯维加斯去，给他一百万美金去赌，一下子输光，输得那儿子脸都青掉，从此不赌了。这不是以坏易好吗？”</span></p></div>]]></content>
      
      
      <categories>
          
          <category> 阅读 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>对平侠谈个人成长的一些感悟</title>
      <link href="/essay/coeh8m/"/>
      <url>/essay/coeh8m/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="e2f3704cf6670b85e36817769e9f9fcc" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1624096824333-d7a7a173-78ce-487b-8924-11e04875f913.png" width="1920" id="SJV2T" class="ne-image"></p><p id="1d6668e634401f3fd4f9dfc67554752a" class="ne-p"><br></p><p id="8c8fcf8a5ef50fbf6fe1e0c573b7ada3" class="ne-p"><span class="ne-text">前言：近期看到平侠作者发布的一篇文章『</span><a href="https://www.yuque.com/zenany/up/be_independent" data-href="https://www.yuque.com/zenany/up/be_independent" target="_blank" class="ne-link"><span class="ne-text">从高效能人士的七个习惯谈成长</span></a><span class="ne-text">』，作者对个人成长精炼出来三个要素：心态、格局、魄力，对应《高效能人士的七个习惯》就是积极主动、以终为始、要事第一这三点。这三点算是对个人成长的比较好的概括了，总的来说，这篇文章对近期有些烦躁的自己算是重新点亮了一盏明灯。</span></p><p id="477e38fb7ac7d6641e783be87cf4ebca" class="ne-p"><br></p><hr id="k0k7a" class="ne-hr"><p id="5e9af7d3ec9c6ebae86d4c4582f97905" class="ne-p"><br></p><h2 id="myjBr"><span class="ne-text">积极主动的心态</span></h2><p id="u456d0e22" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1624097233676-35f38d3c-7383-430a-9ca3-19551b956320.png" width="618.0208740234375" id="u5b8ae4a2" class="ne-image"></p><p id="d7b59f63f98e752ea3f40804e35336c8" class="ne-p"><br></p><p id="5628a002f07c9ae7759fbafa91e48b1b" class="ne-p"><span class="ne-text">作者说的这句话“</span><strong><span class="ne-text">接受无法改变的，改变有可能改变的</span></strong><span class="ne-text">”，我想应该是和李开复前辈的理念一样——“</span><strong><span class="ne-text">有勇气改变可以改变的，有胸怀接受不可改变的事情</span></strong><span class="ne-text">”，李开复其实后面还说道，“</span><strong><span class="ne-text">用智慧区分两者的不同</span></strong><span class="ne-text">”。其实说白了，就是对所处之境，所遇之事永远抱有一个乐观豁达的心态。</span></p><p id="aa6e9f6c20beab3aea21bbcc7ce596c3" class="ne-p"><br></p><p id="abe8f23a88d6be6ef8c66be72e738764" class="ne-p"><span class="ne-text">近期或然有些许同感，很多所有人都懂的道理，对一些人而言，由于性格的缘故，总要比别人接受的晚，再深点讲其实是内心不想接受罢了，抵触，就像是一个孩子被家长训话，就有些桀骜不驯的孩子，知道是这样的，知道这样是不对的，但就是愿意被性格被情绪所控制，但一旦懂得了并接受了这个所有人都懂的道理，成长加速度就会提升甚至赶超同龄人了，这或许就是成长吧。</span></p><p id="3f43d8ba7488fbf04573aa80db45c44d" class="ne-p"><br></p><div class="ne-quote"><p id="1844216885dfa369244e6831facf1e2d" class="ne-p"><span class="ne-text">天下事，难易相成。在做事的过程中，有顺境，有逆境，难在始终保持积极主动的心态。</span></p><p id="c104e7903380dd4b90271ddc9f84d4b9" class="ne-p"><span class="ne-text">顺境：比较容易做到积极主动，但也容易产生懈怠，需要顺势而为，不可懈怠，快速扩大成果。</span></p><p id="acb2874914169116381f2cd04baea73e" class="ne-p"><span class="ne-text">逆境：往往正是考验积极主动的时候，需要摆正心态，重塑信心，主动寻找改变的契机。</span></p></div><p id="afa0e71d2085b7622d3e7eb7871a70be" class="ne-p"><br></p><p id="d2edaa1299549e71332f332e57380469" class="ne-p"><span class="ne-text">作者这段话我觉得很不错，特别是对逆境的态度——始终坚持积极主动的心态。</span></p><p id="53533a4a221cda7757728bce513e3a53" class="ne-p"><br></p><p id="bd4824fec9840873a1ed87b6bd356c1f" class="ne-p"><span class="ne-text">积极主动的心态其实每个人或多或少都会，但是一直坚持的人，很少，也很难，但也正因是难，才要坚持不是么？（算是把自己好好教育了一番的感觉</span></p><p id="4697c6d6a95c7c2b5f2d2a7582f1a746" class="ne-p"><br></p><p id="b99996f0abb4df529a9c2797d21f5c23" class="ne-p"><span class="ne-text">三分钟不开刀无痛苦的历练，在这个文明制度下，不存在。</span></p><p id="349836253584b571db6174dd736420bb" class="ne-p"><br></p><h2 id="g5Mb0"><span class="ne-text">以终为始的格局</span></h2><p id="8ff8e1818720134b02154d779bd39479" class="ne-p"><span class="ne-text">换一个本人一直贯彻的学习方法中的一句话就是“以结果为导向”，以结果为导向的这种思维，在计算机专业里面特别好使，简单说明就是对于同一个技术，一个大作业比课堂上课一学期好使（我可没说我不好好听课</span><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1624095112125-51056426-2c52-4bbf-9d7f-128cd1fac489.png" width="74" id="aZJCK" class="ne-image"><span class="ne-text">）</span></p><p id="75aa5337178370ae751b7b279d33799a" class="ne-p"><br></p><p id="44a2d3320b7f8fe320e66225e7acf2df" class="ne-p"><span class="ne-text">对于把这种思维转到职业规划与发展里面，亦是如此，划分阶段的话，就如作者的三步，确定终点——推演路径——制定计划。虽然我不太习惯制定这种人生抑或是职业计划，但不得不承认，这种方式是有效果的。</span></p><p id="711d17f71664dc08138c9add98a3828b" class="ne-p"><br></p><p id="51a44226886c03223f1e351388ea3492" class="ne-p"><span class="ne-text">作者所推荐的他的师傅 </span><a href="https://www.zhihu.com/people/wuduoyi" data-href="https://www.zhihu.com/people/wuduoyi" target="_blank" class="ne-link"><span class="ne-text">nwind</span></a><span class="ne-text"> 传授的 </span><a href="https://baike.baidu.com/item/%E9%A9%AC%E9%B9%A4%E5%87%8C/5566647" data-href="https://baike.baidu.com/item/%E9%A9%AC%E9%B9%A4%E5%87%8C/5566647" target="_blank" class="ne-link"><span class="ne-text">马鹤凌老先生</span></a><span class="ne-text"> 的总结：</span><a href="https://github.com/zenany/zenany.github.io/blob/master/_posts/about_time_and_knowledge_management.md" data-href="https://github.com/zenany/zenany.github.io/blob/master/_posts/about_time_and_knowledge_management.md" target="_blank" class="ne-link"><span class="ne-text">此生理想、近期计划、今日功课</span></a><span class="ne-text">。仔细看了看，感觉也在强调计划的操作必要性。此刻，突然想到了兵长内心打算跟随团长的心理独白</span></p><p id="2cb82c13de3211ee0b1451a879120a08" class="ne-p"><br></p><p id="111cd6add3af243a58ba3a8650fb1d58" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1624096040600-e72f1c6f-cd5e-4421-a75c-9e5e8ac3edb7.png" width="650.9954223632812" id="bwQJL" class="ne-image"></p><p id="0247bc121ea0177ccd949d754a6717a3" class="ne-p"><span class="ne-text">“</span><strong><span class="ne-text">好吧，我就跟着你好了，埃尔文·史密斯</span></strong><span class="ne-text">”</span></p><p id="615f8bf674c2a0fe183d11aaa3242e6d" class="ne-p"><br></p><h2 id="IUEKs"><span class="ne-text">要事第一的魄力</span></h2><p id="cc37ee7ca89a086292e040c6c27c0de7" class="ne-p"><span class="ne-text">作者想要表达的是“专注当下，取舍果断”。</span></p><p id="13916f0afd1defae5fc51ad9eca3d5ce" class="ne-p"><br></p><p id="9833b0b36c446b504276a5ace21c1e85" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1624096754794-70a837ba-bd73-4a01-a20d-712bfe4266fe.png" width="632" id="Di3jA" class="ne-image"></p><p id="86a36e1a9f8e2145291351c318bb8273" class="ne-p"><br></p><p id="d6aee56be157d9a088a4e825d04444de" class="ne-p"><span class="ne-text">舍弃的精神，我觉得我有，作者所描述的今后我可能会遇到的工作方面，也有对职业的持续发展道路方面的，作者的三个问题值得记录：</span></p><p id="c840d6f4a8d55bd4d5bda686adafeffd" class="ne-p"><br></p><div class="ne-quote"><p id="163361efe17827b92a21e09f009ecd5a" class="ne-p"><span class="ne-text">1、我能为团队和公司带来什么？</span></p><p id="202d81b7c74e26af8558c1a16fe762e9" class="ne-p"><span class="ne-text">2、我从身边的人身上可以学到什么？</span></p><p id="13b73d98b2b968a11b365408d0c70217" class="ne-p"><span class="ne-text">3、我真正想做的事是什么？</span></p></div><p id="ac397cfcec4f53a20c4f2d6b00a3032d" class="ne-p"><br></p><p id="142ea0bea3bd4cbeafcfc34e553d1c43" class="ne-p"><span class="ne-text">时时刻刻想着这三个问题，其实结果还是比较显而易见的……</span></p><p id="ufc082983" class="ne-p"><br></p><p id="3a50d5b23e35b3c04c28834eae9cef4a" class="ne-p"><br></p></div>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>所有的职业终点都是NPC</title>
      <link href="/essay/dpauku/"/>
      <url>/essay/dpauku/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="udee1398d" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1623929248579-c01331e1-d895-4f58-bf92-026465a16a65.png" width="960" id="u7e92ea60" class="ne-image"></p><p id="u474d71c2" class="ne-p"><br></p><div class="ne-quote"><p id="u7ca8a55d" class="ne-p"><span class="ne-text">非玩家角色或称非操控角色（英语：Non-Player Character，NPC），是指角色扮演游戏中非玩家控制的角色。</span></p><p id="ub60f8b1b" class="ne-p"><span class="ne-text"></span></p><p id="uda30fd66" class="ne-p"><span class="ne-text">NPC是游戏背景中，非主角（狭义上来说还要求非敌人）的陪衬人物。玩家借由他们与游戏互动。在桌上角色扮演游戏里，NPC是由游戏主持者操纵，而在电脑角色扮演游戏里，则是由程序默认的剧本来决定NPC的反应，由游戏的人工智能做出控制。部分NPC有时可变成可操控角色</span></p><p id="uc516030e" class="ne-p"><span class="ne-text"></span></p><p id="ufb570d7c" class="ne-p"><span class="ne-text">——维基百科</span></p></div><p id="u93524499" class="ne-p"><span class="ne-text"></span></p><p id="ua68fe989" class="ne-p"><span class="ne-text">如果将一个人人生的职业经历划分为两段，第一段就像是打怪升级的攻略者，而后一段我想就是NPC吧</span></p><p id="u1894db03" class="ne-p"><span class="ne-text"></span></p><p id="u703679ac" class="ne-p"><span class="ne-text">现在的我就像是一个攻略者，利用对这个文明框架的种种，去攻略眼前的所有困难，但是，我似乎也看到了今后处在NPC角色的我……</span></p><p id="u5cb8c53d" class="ne-p"><span class="ne-text"></span></p><p id="uae26803d" class="ne-p"><span class="ne-text">如果把人生喻成一场游戏，那么我觉得人生的意义则是，</span><strong><span class="ne-text">用一颗勇敢的心，去攻略眼前的一个个困难</span></strong><span class="ne-text">。</span></p><p id="u9523df15" class="ne-p"><span class="ne-text"></span></p><p id="u300a354b" class="ne-p"><span class="ne-text"></span></p></div>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>文明框架下美好的事物是什么样的？</title>
      <link href="/essay/logfxx/"/>
      <url>/essay/logfxx/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="traditional"><p id="u193f4654" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1623724816738-638c68c5-a58d-4855-a83f-8040d78aba26.jpeg" width="1440" id="AqhVV" class="ne-image"></p><p id="u79885ccd" class="ne-p"><span class="ne-text">图：梁同学</span></p><p id="u96c6a069" class="ne-p"><br></p><hr id="pdIMd" class="ne-hr"><p id="u44d3f512" class="ne-p"><br></p><p id="udb0e38f5" class="ne-p"><br></p><p id="u231dca46" class="ne-p"><span class="ne-text">文明，历史的长久以往，让我们这个文明慢慢趋于一种某一方面而言的制度体系，或许对大多数人而言，这是一种常态，但对我而言，文明是框架。我并没有用束缚这个较为偏激的字眼去形容，而是用的框架。</span></p><p id="u4796a1d5" class="ne-p"><br></p><p id="u938f3c46" class="ne-p"><span class="ne-text">我们所喜欢的事物，至少我喜欢的事物，拆开了讲，许许多多都是都是被框架所限定，生活、思维、情感、甚至是内心，那为什么框架要限定出我们所定义出来的幸福呢？我脑海中浮现的答案是文明，是制度……</span></p><p id="u67bd9d81" class="ne-p"><br></p><p id="u43b784a3" class="ne-p"><span class="ne-text">地球最初的生命，或许只是造物主偷偷在一个水球中放下了能进行光合作用的一些小生物，进而演化成了我们此般文明景象罢了，我们都是进化而来的生物，而生物遵循了生物法则，长久以往的人们制定了无数有益于生存下去的制度、规则，而在这样的大环境下生活着，有一种奇妙的事物叫做快乐抑或是幸福。</span></p><p id="udc021f14" class="ne-p"><br></p><p id="u4b86ec93" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1623724819065-43292e39-1cfe-4dd4-b4a9-9cbf05167e4a.jpeg" width="1440" id="jClko" class="ne-image"></p><p id="u1a4a498a" class="ne-p"><br></p><p id="u45b23adb" class="ne-p"><span class="ne-text">人生的终极目标是什么？我又在一直追寻着什么啊？</span></p><p id="ue436ddde" class="ne-p"><br></p><p id="u10af1db1" class="ne-p"><span class="ne-text">我对自己问了一个特别大的问题，甚至有些幼稚的问题，或许我的潜意识里面想过这问题，但是又像是模模糊糊，如果用此刻大脑中的思绪来回答，我应该会回答：文明框架下的快乐和幸福。这个回答看起来是那么的简单易懂，却又有一些伤感与妥协，我站的太低了，我将自己死死地按在一个没有实体的框架下面，多么的悲怆，似乎就像是一台机器去做那些连幸福都定义好了的事情，</span></p><p id="ud45a6ea1" class="ne-p"><br></p><p id="ud771c32e" class="ne-p"><span class="ne-text">突然想到了一些人，无间道里面的刘建明和人间失格里面的叶藏，描述这两个人最好的状态就是无间，无间地狱，真的是艺术，描述的彻彻底底，佛教的思想：轮回、开悟、涅槃，而那两个人，无止境的在无间地狱轮回……想想这个文明制度下的种种，细思极恐</span></p><p id="u0acaf8a2" class="ne-p"><br></p><p id="ue3cfd092" class="ne-p"><br></p><p id="ue03791a5" class="ne-p"><span class="ne-text">人活着就是为了生活更快乐，更幸福，而幸福的生活要自己努力争取来的。</span></p><p id="u2d2d69a9" class="ne-p"><span class="ne-text"></span></p><p id="u26e92b81" class="ne-p"><span class="ne-text">我总是又在想，温柔的人为什么也会被</span></p><p id="u53aa6881" class="ne-p"><br></p><p id="u85586d79" class="ne-p"><br></p><hr id="Qp6B4" class="ne-hr"><p id="ua1d19015" class="ne-p"><br></p><p id="ud2fc7838" class="ne-p"><span class="ne-text">2021.06.16</span></p><p id="u792e40bb" class="ne-p"><span class="ne-text"></span></p><p id="u6b85ac87" class="ne-p"><span class="ne-text">“</span><strong><span class="ne-text">我不喜欢那些正确的人，那些从没堕落过、从没犯过错的人。生活的美未曾在他们面前展开过。</span></strong><span class="ne-text">”一个文学家在所沉浸的文学世界中的独白。</span></p><p id="u7a2eeda1" class="ne-p"><span class="ne-text"></span></p><p id="u39dd6c9a" class="ne-p"><span class="ne-text">真正的文学家总让人感觉是一个怪人，而我却独爱这般不被束缚的精神因子。</span></p><p id="u59b8f4c7" class="ne-p"><br></p><p id="u2fb77813" class="ne-p"><br></p><p id="u276fe678" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1626942905634-3fe3cc98-bedf-46bf-ac8e-20162a512b91.jpeg" width="1176" id="u233ed369" class="ne-image"></p><p id="u0baf1a43" class="ne-p"><br></p></div>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>各类排序算法汇总</title>
      <link href="/blog/garbxb/"/>
      <url>/blog/garbxb/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="598fe76c79cf4220ab7c32e59463c547" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1625064781047-2f12af3a-ce5c-4280-b387-38a40f307b45.jpeg" width="4961" id="yeGww" class="ne-image"></p><p id="f4799e2e37bd6cff1a774b72530e172e" class="ne-p"><br></p><p id="a4c64971ad367882801c73ec3d3dc979" class="ne-p"><span class="ne-text">前言：排序按照所占用的计算机内部存储设备，可以分为：</span><strong><span class="ne-text">内部排序</span></strong><span class="ne-text">和</span><strong><span class="ne-text">外部排序</span></strong></p><ul class="ne-ul"><li id="4b0aba3fe82521f2629e180cf11c0c74"><strong><span class="ne-text">内部排序：</span></strong><span class="ne-text">占用的是内存，待排序序列全部放在内存加以排序处理</span></li><li id="ce7426ba9e5f35c43ed4f0e90104c7b8"><strong><span class="ne-text">外部排序：</span></strong><span class="ne-text">占用的是外存，数据量比较大，内存空间不足以一次性全部容纳数据的情况</span></li></ul><p id="7f749a6f10609a76ec5fd0b57e19dd42" class="ne-p"><br></p><p id="8a996d904321b45f997b52fd816b00df" class="ne-p"><span class="ne-text">本文章 通过</span><a href="https://leetcode.cn/problems/sort-an-array/" data-href="https://leetcode.cn/problems/sort-an-array/" class="ne-link"><span class="ne-text">912. 排序数组</span></a><span class="ne-text"> 题目，以此来总结内部排序的各种排序算法。</span></p><p id="c9527610c382b4e6629792750a2166da" class="ne-p"><br></p><p id="7da58a290fd9cd6f0c506cf3e1747b3d" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1623667337022-44c54af8-5961-43d6-8fa4-46ef3f6ec71f.png" width="746" id="zJx4v" class="ne-image"></p><h2 id="qzpnY"><span class="ne-text">一、插入类排序</span></h2><p id="1c913d93d2cc9eff048644211658bd5c" class="ne-p"><span class="ne-text">将无序的子序列插入到有序序列中</span></p><h3 id="etEGl"><span class="ne-text">✅直接插入</span></h3><p id="f1f5744d5e0ed7b62a44cfdc3abd8e30" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/gif/1484158/1625014050650-261f0307-6356-440f-b06a-12e264344572.gif" width="813" id="pZjWF" class="ne-image"></p><p id="d5d5ac06f356ce66f8e428f2f3582506" class="ne-p"><span class="ne-text">将元素序列走一遍，走到某个元素时，将其插入到已走过的已排序序列中，这样可以保证走完所有元素，然后所有的元素都是排序好的。</span></p><p id="94537a784913cd4dce7e158543975878" class="ne-p"><span class="ne-text">数据结构选用的时顺序表</span></p><pre><code>/*** @param &#123;number[]&#125; nums* @return &#123;number[]&#125;*/var sortArray = function(nums) &#123;  for (let i = 0; i&lt;nums.length; i++) &#123;    let flag = i    for(let j = flag-1;j&gt;=0;j--) &#123;      if (nums[flag] &lt; nums[j]) &#123;        let temp = nums[j]        nums[j] = nums[flag]        nums[flag] = temp        flag--      &#125;     &#125;  &#125;  return nums&#125;;</code></pre><p id="uf9efec9a" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1653228341393-1bd78b67-0797-4bec-add7-be5d8295ac35.png" width="567.4074474905118" id="uecb8136f" class="ne-image"></p><h3 id="thpnK"><span class="ne-text">优化：折半插入</span></h3><p id="c3ffa5c0de2325e5e10b036617fee982" class="ne-p"><span class="ne-text">在直接插入的过程中，找到一个元素，然后再需要从后往前依次查找“该在”的位置，对其查找进行了折半优化</span></p><pre><code>/* 折半插入排序 */void BinsertSort(SqList &amp;S) &#123;    for (int i = 2; i &lt;= S.length;i++) &#123;        S.data[0] = S.data[i];        int low = 1;        int high = i - 1;        while (low &lt;= high) &#123;            int m = (low + high) / 2;            if (S.data[0]&lt;S.data[m]) high = m - 1;            else low = m + 1;        &#125;        int j;        for (j = i - 1; j &gt;= high + 1;--j)            S.data[j + 1] = S.data[j];        S.data[high + 1] = S.data[0];    &#125;&#125;</code></pre><h3 id="gP6SY"><span class="ne-text">优化：希尔排序</span></h3><p id="29eea55fa2a785edf01487c47c16eabc" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/gif/1484158/1625015190376-d54ed111-aa4a-41cf-9dde-6593a6aaf4e0.gif" width="665" id="KmYb4" class="ne-image"></p><pre><code>/* 希尔排序 */void ShellInsert (SqList &amp;L, int dk) &#123;    for (int i = dk + 1; i &lt;= L.length;++i) &#123;        if (L.data[i]&lt;L.data[i-dk]) &#123;            L.data[0] = L.data[i];            int j;            for (j = i - dk; j &gt; 0 &amp;&amp; L.data[0] &lt; L.data[j]; j -= dk)                L.data[j + dk] = L.data[j];            L.data[j + dk] = L.data[0];        &#125;    &#125;&#125;void ShellSort (SqList &amp;L, int dt[],int t) &#123;    for (int k = 0; k &lt; t;++k) &#123;        ShellInsert(L, dt[k]);    &#125;&#125;</code></pre><h2 id="B3KXE"><span class="ne-text">二、交换类排序</span></h2><h3 id="qHXfT"><span class="ne-text">✅冒泡排序</span></h3><p id="38bd96910e0a0454a5262c26035fe738" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/gif/1484158/1625013969954-b7310256-1c0a-4b3c-b45b-a7b33eca8e5c.gif" width="813" id="bVJVg" class="ne-image"></p><p id="u33c1f2b6" class="ne-p"><span class="ne-text"></span></p><pre><code>/** * @param &#123;number[]&#125; nums * @return &#123;number[]&#125; */var sortArray = function(nums) &#123;    for (let i = nums.length - 1; i&gt;0; i--) &#123;        for (let j = 0; j&lt;i; j++) &#123;            if (nums[j] &gt; nums[j+1]) &#123;                let temp = nums[j]                nums[j] = nums[j+1]                nums[j+1] = temp            &#125;        &#125;    &#125;    return nums&#125;;</code></pre><p id="u5d20c9a5" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1653213078608-86011f32-d058-4393-902d-33f97f21578b.png" width="578.5185593865401" id="u8a10d142" class="ne-image"></p><h3 id="tjRbu"><span class="ne-text">快速排序</span></h3><p id="2abcad580b30aa89bbac80e2f52ce1d6" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/gif/1484158/1625017709918-661c5cd4-fd2a-49a0-be80-bb59b791ed8f.gif" width="811" id="jCV3S" class="ne-image"></p><pre><code>/* 快速排序 */int Partition (SqList &amp;L, int low, int high) &#123;    L.data[0] = L.data[low];    int pivotkey = L.data[low];    while (low &lt; high) &#123;        while (low&lt;high &amp;&amp; L.data[high]&gt;=pivotkey)            --high;        L.data[low] = L.data[high];        while (low&lt;high &amp;&amp; L.data[low]&lt;=pivotkey)            ++low;        L.data[high] = L.data[low];    &#125;    L.data[low] = L.data[0];    return low;&#125;void Qsort(SqList &amp;L, int low, int high) &#123;    if (low&lt;high)&#123;        int pivoloc = Partition(L, low, high);        Qsort(L, low, pivoloc - 1);        Qsort(L, pivoloc + 1, high);    &#125;&#125;void QuickSort(SqList &amp;L) &#123;    Qsort(L, 1, L.length);&#125;</code></pre><h2 id="vqepg"><span class="ne-text">三、选择类排序</span></h2><p id="3aebb659010899dbfd5c16c892662a01" class="ne-p"><a href="http://data.biancheng.net/view/72.html" data-href="http://data.biancheng.net/view/72.html" target="_blank" class="ne-link"><span class="ne-text">参考：ata.biancheng.net/view/72.html</span></a></p><h3 id="Vrp7T"><span class="ne-text">✅简单选择排序</span></h3><p id="d5b876da9ea6683382d3772e8c2ad53a" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/gif/1484158/1625014017576-1b58bc2d-d46b-48e8-a307-6fc6f4ee8f0a.gif" width="813" id="FeuYg" class="ne-image"></p><pre><code>/** * @param &#123;number[]&#125; nums * @return &#123;number[]&#125; */var sortArray = function(nums) &#123;    for (let i = 0; i&lt;nums.length-1; i++) &#123;        for (let j = i+1; j&lt;nums.length; j++) &#123;            if (nums[i] &gt; nums[j]) &#123;                let temp = nums[i]                nums[i] = nums[j]                nums[j] = temp            &#125;        &#125;    &#125;    return nums&#125;;</code></pre><p id="u43567c96" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1653226950636-0e2a6743-01fe-4195-8d7e-a0c59a37891e.png" width="568.1481882835803" id="u6b1a3b2d" class="ne-image"></p><h3 id="8Zesn"><span class="ne-text">树形选择排序</span></h3><p id="96b4ae1229b083e76e8eb148c07e0084" class="ne-p"><br></p><h3 id="Ry3ha"><span class="ne-text">堆排序</span></h3><p id="27bd8e77d511f4282b5bf855ef57d576" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/gif/1484158/1625021691601-c1572503-c54d-4d12-8d3e-97da2ae0aa38.gif" width="547" id="b5jeQ" class="ne-image"></p><h2 id="wYfdM"><span class="ne-text">四、归并排序</span></h2><h3 id="NMBwV"><span class="ne-text">2-路归并排序</span></h3><p id="ea33608f775147ff8f17087962c9765e" class="ne-p"><span class="ne-text">给定一个序列，从左往右两两子序列进行归并</span></p><p id="6c0a75ff9d8bbfc8288fa678954e5fc6" class="ne-p"><br></p><p id="b8819e93c9172046b1309ff544c4fe6f" class="ne-p"><span class="ne-text">子序列归并的算法：加入有两个靠着的a、b序列，由上面可知，a、b各自都是有序序列，现在就是将这两个合并为一个有序序列k，将a和b序列的各个元素进行比较，小的依次放入k序列，当a、b两个中有一个序列为空了，就将那个不为空的序列直接加入到k序列即可，最后k序列就是目的序列。</span></p><p id="557d9af01136329dd59b2fa7244f3275" class="ne-p"><br></p><p id="461f6d5fc01208d120906ab21346aa22" class="ne-p"><br></p><h2 id="FZipi"><span class="ne-text">五、分配类排序</span></h2><h3 id="Qx2Q5"><span class="ne-text">基数排序</span></h3><p id="353887e2cdc59884fedc11e96e262efc" class="ne-p"><span class="ne-text">TODO: 扑克牌的花色排序</span></p><h2 id="HtSzO"><span class="ne-text">六、外部排序</span></h2><h3 id="CTOql"><span class="ne-text">基本方法</span></h3><h3 id="69w00"><span class="ne-text">多路平衡归并</span></h3><p id="862b47dd7bfc84c631f63adff5eb7698" class="ne-p"><span class="ne-text">基本思想是内部排序中的2-路归并排序</span></p><h3 id="MbQii"><span class="ne-text">置换-选择排序</span></h3><h3 id="AFobc"><span class="ne-text">最佳归并树</span></h3><h2 id="lRFoT"><span class="ne-text">参考</span></h2><p id="7bb6c59cbacbf8c147d2f3a63ef6f7cb" class="ne-p"><span class="ne-text">文章的动画演示</span></p><ul class="ne-ul"><li id="1e3a39bc9ae64cef928baee74add8602"><a href="https://blog.csdn.net/Hk_john/article/details/79888992" data-href="https://blog.csdn.net/Hk_john/article/details/79888992" target="_blank" class="ne-link"><span class="ne-text">https://blog.csdn.net/Hk_john/article/details/79888992</span></a><span class="ne-text">（js）</span></li><li id="daec35f35e8ed9e9f2186b3bd8c5ad29"><a href="https://www.itrhx.com/2020/10/23/A91-sorting-algorithm/" data-href="https://www.itrhx.com/2020/10/23/A91-sorting-algorithm/" target="_blank" class="ne-link"><span class="ne-text">https://www.itrhx.com/2020/10/23/A91-sorting-algorithm/</span></a><span class="ne-text">（python）</span></li></ul></div>]]></content>
      
      
      <categories>
          
          <category> 计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 📊查找排序算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>一个梦——梦中姑娘</title>
      <link href="/essay/di14o2/"/>
      <url>/essay/di14o2/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><div data-type="info" class="ne-alert"><p id="33be681ccc83e4979d2e8754a2873dd2" class="ne-p"><span class="ne-text">空调+风扇睡觉-&gt;易着凉-&gt;易做梦</span></p><p id="4424c713d130cfb637c4d73b8b7cf267" class="ne-p"><span class="ne-text">因着凉而做的梦大多不是自然醒，此般</span><span class="ne-text">崩坏醒……</span></p></div><p id="5f784f94c5ab374ea88f0635ecabbbf2" class="ne-p"><br></p><p id="446e5edef9cc3c53f6ad238d4f5a2aad" class="ne-p"><br></p><p id="a20d224c568e48b9d67847a2c66a8c01_p_0" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1623127396847-7144e32c-9f84-4c90-ad75-307f781827a5.png" width="1080" id="IChRS" class="ne-image"></p><p id="f08c18d7c72c51cd6ec1f17f6bd61327" class="ne-p"><br></p><p id="3429bc03398d7bba3a9aed2305d1497f" class="ne-p"><br></p><hr id="KyTjg" class="ne-hr"><p id="918755d555b381178962fd033ea8dff5" class="ne-p"><br></p></div>]]></content>
      
      
      <categories>
          
          <category> 异世界 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>《人间失格》——“纯真无垢的信任算是罪过吗？”</title>
      <link href="/essay/am0q19/"/>
      <url>/essay/am0q19/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="ue5633382" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1622964551715-a700f7e7-b3e8-45c5-9d80-787cbb0c66f3.png" width="400" id="u8cf446b6" class="ne-image"></p><p id="u797500bd" class="ne-p"><br></p><div data-type="info" class="ne-alert"><p id="u224179b9" class="ne-p"><span class="ne-text">“纯真无垢的信任算是罪过吗？”</span></p></div><p id="ue7be8be3" class="ne-p"><br></p><p id="u7bbd9143" class="ne-p"><span class="ne-text">经历了小时候的“看脸色行事”、中学寄读、与家庭隔绝任何关系……</span></p><p id="u2913a434" class="ne-p"><br></p><p id="ua6524f03" class="ne-p"><span class="ne-text">回归抑郁惆怅的那会日常状态，常去的那家酒馆，将自己灌得烂醉，突然有一天，遇见的不懂何为污秽的童贞的由子润湿了生来敏感的叶藏……</span></p><p id="u1ab3498b" class="ne-p"><br></p><div data-type="info" class="ne-alert"><p id="u41d70760" class="ne-p"><span class="ne-text">“即便因为这样日后遭逢再大的悲哀也无所谓，我一定要放纵地享受眼前这极度的欢乐，哪怕这一生仅有这一次。”</span></p></div><p id="ue99521cc" class="ne-p"><br></p><p id="u59bd13fc" class="ne-p"><span class="ne-text">还记得『无间道』里面说的「八大地狱之最，称为无间地狱，为无间断遭受大苦大意，故有此名」</span></p><p id="ucd0f2fd4" class="ne-p"><br></p><p id="u0571b508" class="ne-p"><span class="ne-text">人会变吗？不知道，但我知道敏感的人不易变……</span></p><p id="uc20bcc88" class="ne-p"><br></p><div data-type="info" class="ne-alert"><p id="u1092398f" class="ne-p"><span class="ne-text">四周的气氛蓦地变得异样紧张。两个人从楼顶天台走到二楼,再从二楼往底楼我的屋子走去。在楼梯上堀木停住了脚步,用手指着前面小声说道:“你看!”我家那间屋子上方的小窗户正敞开着,从那儿可以看到里面的光景。</span></p><p id="ue51c3d03" class="ne-p"><br></p><p id="uf3ebdd88" class="ne-p"><span class="ne-text">只见屋子里亮着电灯,有两只动物正在干着什么。我顿时觉得头晕目眩、呼吸急促,但同时心里却在暗自低语—这也算是一出人间粉戏吧,这也算是人类的本性吧,没什么好大惊小怪的—我甚至忘记了出手去解救由子,只是久久地呆立在楼梯中间。</span></p></div><p id="u576d2e7e" class="ne-p"><br></p><p id="u4644d1e8" class="ne-p"><span class="ne-text">“解救”这个一词我不是很理解，我看了两遍，不知道由子是被迫的还是自愿的，但是根据后文的由子对叶藏的眼神躲避的情节，我感觉是自愿的……</span></p><p id="u6f523a3a" class="ne-p"><span class="ne-text"></span></p><div data-type="danger" class="ne-alert"><p id="u0c1cf9c9" class="ne-p"><span class="ne-text">每当我唤她时，她总是身体冷不丁一哆嗦，视线也不知道该投向哪里好。无论我再怎么装痴装疯胡言乱语以逗她一笑，她都一副茫然不知所措、坐立不安、战战兢兢的样子，和我说话时还心不在焉地乱用敬语。</span></p></div><p id="u5a3e9711" class="ne-p"><span class="ne-text"></span></p><hr id="sYclb" class="ne-hr"><p id="ue3f4938f" class="ne-p"><span class="ne-text">原文里面的天台上的叶藏心理……</span></p><p id="u0f9a860f" class="ne-p"><span class="ne-text"></span></p><div data-type="info" class="ne-alert"><p id="ucd4215fb" class="ne-p"><span class="ne-text">我则像逃命似的一个人又冲回到天台，躺在地上，仰望含满雨气的夏日夜空。此时，袭遍我全身的情感不是愤怒，也不是厌恶，更不是悲伤，而是极度的恐惧。那不是面对墓地中诸多幽灵时的恐惧，倒更像是在神社的杉树林间，撞见身着白衣的神明时的那种来自太古的、凶暴恶戾的、令人噤默失语般的恐惧。从那晚起，我开始少年白头，我越发对世间所有的一切失去信心，越发对人产生无止境的怀疑，从此诀别了对人世生活所抱有的全部期待、喜悦、共鸣。事实上，这也是我整个人生中起到决定性作用的一个事件，仿佛被人迎面一刀砍中眉间，日后无论我与任何人接触，那伤口便会隐隐作痛。</span></p></div><p id="u6dd35c42" class="ne-p"><span class="ne-text"></span></p><p id="ue0a7c670" class="ne-p"><span class="ne-text">丧，十分丧……这一段，以前看的极度压抑，现在看的十分同情，敏感的叶藏遇到这种事情，真的是上天的无间地狱的惩罚吗？那现在这个时代的人呢？</span></p><p id="ud66000a9" class="ne-p"><br></p><hr id="j9z3P" class="ne-hr"><p id="ud76c5d75" class="ne-p"><br></p><p id="u276fcea0" class="ne-p"><br></p><div data-type="info" class="ne-alert"><p id="u9d3c5d73" class="ne-p"><span class="ne-text">“纯真无垢的信任算是罪过吗？”</span></p><p id="ufb4eec64" class="ne-p"><span class="ne-text">“纯真无垢的信任之心，难道真是罪恶之源吗？！”</span></p></div><p id="u07af0976" class="ne-p"><br></p><p id="ub16ae777" class="ne-p"><span class="ne-text">作者说着两次，好像文中还有相似强调的话语，对于一个敏感的人的内心最信任人而言，则算是一种无言的崩溃把，堕入人间地狱……</span></p><p id="ua766c76c" class="ne-p"><br></p><p id="ud9d06c63" class="ne-p"><span class="ne-text">作者不解……</span></p><p id="ub9f2e79b" class="ne-p"><br></p><p id="u2b5c6aea" class="ne-p"><span class="ne-text">第一次看这本书对此我是感到抑郁，全程压抑，但是现在看来，感受到的是一个敏感的人对周围的无奈与妥协，到最后那纯真无垢的信任之心也已死……</span></p><p id="u154db264" class="ne-p"><br></p><p id="ubc724026" class="ne-p"><span class="ne-text">这样的人生是何等的失望……</span></p><p id="ue4923726" class="ne-p"><br></p></div>]]></content>
      
      
      <categories>
          
          <category> 阅读 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>《人生》之高加林的爱情我也曾有过……</title>
      <link href="/essay/mh44ds/"/>
      <url>/essay/mh44ds/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="ef6e5d9aa1a590615f8473d394d5f526" class="ne-p"><br></p><p id="5c5d199bb38661ac8f23fe4a363d512d" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1622168235721-f78e67ae-65fa-4208-bdf6-1bbad23a55a8.png" width="291.7477111816406" id="u836e58b6" class="ne-image"></p><p id="c38fbf887b9cc1272fec9e63ebf01020" class="ne-p"><span class="ne-text">以前看的，今天突然有一些很深的感悟</span></p><p id="89427396d2c5d1daa888afbdebb672d3" class="ne-p"><br></p><p id="ae9f2b2b925c6c5b0b5413909a302f3d" class="ne-p"><span class="ne-text">高加林把纯情美丽、聪慧贤淑的刘巧珍这块“金子”丢了，突然想到相似的自己、想到了守恒、想到了辗转反侧却也难忘的心思……</span></p><p id="5c9949954b1ac835a28fec5c7dd7e7d5" class="ne-p"><br></p><p id="b06f185f80c24604db0e907c7e6bf5b3" class="ne-p"><span class="ne-text">守恒律，总觉得这世界上任何东西</span></p><p id="48416172029192e65ab79e808f6bf6a9" class="ne-p"><span class="ne-text">这世界上的事情，总是守恒的，人和人之间的情感，爱情、人情味、亲情</span></p><p id="9010c8e3989fd7b1a3132f85c9688435" class="ne-p"><br></p><p id="039264b44bbe6a4d695c6ce3c31bd2e9" class="ne-p"><span class="ne-text">还记得路遥的《人生》最后说，加林失去了自己人生中最重要的金子，我觉得这也是守恒的，从一开始，高加林就获得了自己的“金子”，然而呢，没珍惜……一开始高加林的教师职位被强拉下来，这的确是人生的不公，但是这也迎来了上天送给他的巧珍这颗金子，而后呢，他又放弃了巧珍这颗金子，追寻另外的一个女人，到最后，这个金子也没了</span></p><p id="92b4ac2768507d2d16d76794d2e49bd0" class="ne-p"><br></p><p id="da45cca86e95857c8894ad872f2ab8d3" class="ne-p"><strong><span class="ne-text">现实是如此的相似，我曾经也失去过金子，她非常漂亮，些许单纯，些许霸道，还喜欢看言情小说……我们和书里面的主人公一摸一样，真就一模一样，原因无他，在当时看来，在当时周围整个世界看来，读书谈啥恋爱……那时的我，很懵懂···后来我就进高中了，她好像是去一个技术学院还是直接工作，我忘了，有一次我上QQ了，那会应该是高一，她真好也在，便和她聊起天，那会她好朋友也在，我们三个是朋友，那会我们一起聊天，突然她朋友来一句“你啥时候和我家XXX表白呢”……</span></strong></p><p id="265828558d5bc033a25f2506ec93a7ae" class="ne-p"><strong><span class="ne-text">是的，那会，又是在读书……我不记得我当时是怎么回应的了，我只知道我当时挺想看看她的……</span></strong></p><p id="36d339b8b1c63384d8c9a9091b4c37d8" class="ne-p"><br></p><p id="0366ac1c457a937be376892979616201" class="ne-p"><strong><span class="ne-text">我大学期间，她生娃了，很漂亮但不帅……</span></strong></p><p id="49c0faf53cf3bfda53a218397a5e2280" class="ne-p"><br></p><p id="ae02a52dc2f537a826f2421d1570c094" class="ne-p"><strong><span class="ne-text">我苦笑、却又辗转反侧……</span></strong></p><p id="bd8f1f817d61e9f33d0b886a53487a1d" class="ne-p"><br></p></div>]]></content>
      
      
      <categories>
          
          <category> 阅读 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>微信屏蔽的不只有网易云的『性格主导色』</title>
      <link href="/essay/qgtwsr/"/>
      <url>/essay/qgtwsr/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="d2b61f151acbde582282a6b2f646f8ce" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1622096165024-de751f5a-0c8f-4d21-8fe9-da41dbf459bf.jpeg" width="541" id="gsk95" class="ne-image"></p><p id="e82f5b43d584b8e8acc2faf69fe90ce4" class="ne-p"><span class="ne-text"></span></p><p id="u0d1d720a" class="ne-p"><span class="ne-text">前言：网易云『性格主导色』活动页面遭微信屏蔽，在微信软件中点击活动页面会出现以下警告内容。我倒是见怪不怪，因为被屏蔽的不只有网易云的『性格主导色』，还有许许多多默不作声的外链，细想之，我个人的看法是与其说这是一种为了维护绿色上网环境，倒不如说是对当下自媒体崛起的一种流量上的恐慌……</span></p><p id="d268c05fe4a227ded7bb1b61b084825d" class="ne-p"><br></p><p id="e934efc031950b4679c0209454f48a45" class="ne-p"><br></p><p id="616a3140048db0ff66dfb99d760786a4" class="ne-p"><span class="ne-text">现如今自媒体的崛起，广告的投放不单单是微信，短视频平台，某站平台等这些更加吸引广大用户的娱乐平台的崛起，说白了，自媒体的崛起给腾讯造成了流量上的恐慌，倘若在B站动漫里面推广一些产品，不比下面这种每天都看的心烦的广告好得多</span><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1622097105798-a36f91ad-5589-4393-8a28-1d152e214c18.jpeg" width="52" id="y9K8r" class="ne-image"><span class="ne-text">……</span></p><p id="367d4467982c910dd749f19c3ba15c70" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1622095673079-588276fc-6d38-4886-8d9c-be90b62f0f63.png" width="282" id="C71oi" class="ne-image"></p><p id="a4d23d825e04d4190e7e9fe9b45dccbf" class="ne-p"><span class="ne-text">但是作为腾讯的这种机制是说为了维护用户体验，保留用户的权益……就我个人而言，我所知道的不仅仅是这个事件被屏蔽，还有之前的语雀链接在微信也不能打开，另外近期，在QQ里面我打开自己的网站，也是无效的，会提示非官方网站，许多博客站点都被屏蔽了</span><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1622097255080-95d8e27c-375d-4629-b118-4f74c1273e9c.jpeg" width="62" id="XPRrb" class="ne-image"><span class="ne-text">，总的来说，像上面那种广告是不会被屏蔽的，但是像一些外链现在十有八九是会被屏蔽的，不管这外链是低质量内容还是有不错内容的站点。</span></p><p id="u120f98ee" class="ne-p"><br></p><hr id="MvSBf" class="ne-hr"><hr id="LyYCu" class="ne-hr"><p id="ub4ad397f" class="ne-p"><span class="ne-text">给自己测了下这个主导色，除了蓝色是对的，</span><strong><span class="ne-text">其他的都扯淡</span></strong><span class="ne-text">……</span><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1622098043031-f48fc2c7-e8d9-416f-acd6-925a9528af2e.jpeg" width="48" id="ohPur" class="ne-image"></p><p id="u33cd71f0" class="ne-p"><br></p><p id="ud7df80cd" class="ne-p"><br></p><p id="u3a52bc90" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1622097912666-9ca03aa8-58f6-4f2e-a5e0-02145b87cb74.jpeg" width="648" id="u0e97d042" class="ne-image"></p><p id="423180e1a9062261b09a97f824672c75" class="ne-p"><br></p><p id="e6809a4e992ace86e9ac676452459e73" class="ne-p"><br></p><p id="c8779dfb53d51b04df5d60283ef7b7e3" class="ne-p"><br></p></div>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>《活着》</title>
      <link href="/essay/rcexdl/"/>
      <url>/essay/rcexdl/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><div data-type="info" class="ne-alert"><p id="05795b68a4e1044120001f014cc351bb" class="ne-p"><span class="ne-text">今天突然打开电脑里面的OneNote，发现以前还真写过不少东西……记得当时看这本书的时候，是在一个下午，一个最深的场景主人公他儿子死了，那个清晨黎明两三点，富贵从医院背着儿子往家走的时候，那个场景，针对心酸……有些许微风，夹杂着些许露水……阵阵凉意~</span></p></div><p id="904cf7b39d4a7de52ca0664eae909127" class="ne-p"><br></p><p id="a20d224c568e48b9d67847a2c66a8c01_p_0" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1622032573540-7113b1ee-f2f6-419f-a75b-577f79de0a27.png" width="671.5" id="KlBtd" class="ne-image"></p><p id="1311f4bca42db95a08151cd53b683752" class="ne-p"><br></p><div data-type="info" class="ne-alert"><p id="bbb2ca74705fa037f6e4f73396f16d23" class="ne-p"><span class="ne-text">18年写的</span></p></div><p id="171d6cef71fd7d7c7a9a2a2dacd57b63" class="ne-p"><br></p><p id="b4ffda1cada83f72d344cbe02557cfd4" class="ne-p"><span class="ne-text">《活着》有感</span></p><p id="9880b967dd3394db8ac8db6a334286ef" class="ne-p"><br></p><p id="936315e433bcc154cf6a1fad055282a3" class="ne-p"><span class="ne-text">每个人的人生都不一样，但是我们都活着。</span></p><p id="dcabc343faf3c64f389ec41ef6b86675" class="ne-p"><br></p><p id="f8a32de698dd65c12ce295163b752662" class="ne-p"><span class="ne-text">——有感</span></p><p id="d2c04cb2afbd09a07bb82778cfc4d416" class="ne-p"><br></p><p id="878691c5f4e27bdc24ee4ac599a8ef2c" class="ne-p"><span class="ne-text">“我知道黄昏正在准瞬即逝，黑夜从天而降了。我看到广阔的土地袒露着结实的胸膛，那是召唤的姿态，就像女人召唤者她们的儿女，土地召唤着黑夜来临。”活着是一种姿态，一种哲学，主人公福贵的人生是不幸的，在那个时代生活的艰辛，身边的人都离他而去，他几乎失去了一切，但是他活着，活得无奈，活得平庸，活的平凡，但活出了活着的意义。每个人对于活着都会有不同的人生感悟，我们的人生都不一样，因为我们都活着。</span></p><p id="c7736f8bcbdc3edda2aa593a85016dfc" class="ne-p"><br></p><p id="0eb1dbe42aea2a8226dac1cea3c8b33c" class="ne-p"><span class="ne-text">一个人的人生会因为一个人的一次行为而改变，而改变正是一个人活着意义所在。赌博让福贵的家庭从家财万贯到穷困潦倒，我一直觉得一个有故事的人一定会是曾经经历了什么。这次赔债过程中，福贵的爹爹也去世了，再混的子女遇见这等事谁不会心里塌了一片天，可能一切对于当时的他来讲很沉重，但是已经发生了。紧接着的又是妻子家珍被她爹带回家。这里我最感触深的是单纯，天真无邪的凤霞。送给龙二钱的时候，被国民党强制性的拉去充炮兵，就这样又和妻子孩子失去联系，在每天的炮火里，唯一的牵挂也只有老婆孩子了，对啊，人只有在最失意的时候才会想起身边的人，才会珍惜所拥有的，曾经对妻子的漠不关心现在会有牵挂，</span></p><p id="bcd9e16522a95621c96c4311e012bc54" class="ne-p"><br></p><p id="bd8887e5a69427fbcdbb8d51aac4e659" class="ne-p"><span class="ne-text">在人民公社之后，百姓的日子日益变得破败不堪，我没有过也没有见过那时代的人，但是我长辈见过。小说有一个片段我觉得挺真实，凤霞用锄头挖到一个地瓜，但是却被村里其他人抢去，可能许多读者看到这不会有太多感触，但我是农村人，我对于此有些许的感触。在决定把凤霞送给别人家的时候，那真的真的是走到尽头了，</span></p><p id="a8f203ad7b6dbb596774ecdf0719b8ed" class="ne-p"><span class="ne-text">感触最深的就是，凤霞一天晚上偷偷跑回家，当福贵打开家门，凤霞望着自己的爹娘，说不出话，也听不见别人的话，当福贵决定送凤霞到城里人家时，他说了一句话“就是全家都饿死，也不送凤霞回去”，那一刻，我觉得很温暖，我相信，那是真正的父爱。活着为了什么，我觉得就是为了那些生活中的感动，一个人来到这个世界上，一定都是不容易的，有爱自己的父母，这些一切的一切都是会使得情大于现实。</span></p><p id="a4a582f626b93c8a827d0645c6b31254" class="ne-p"><br></p><p id="7b2058902899511b2306330250150b5c" class="ne-p"><span class="ne-text">原本已经不错的日子最后还是发生了不幸，儿子有庆离开了人世…那天晚上的福贵抱着有庆在回家的路上走走停停，停停走走，不是得停下坐在田埂看看自己的儿子，摸着儿子的脸庞，那时间我的眼眶真的湿了。不知道为什么，看到那时候我想起了我的父母…</span></p><p id="3f6fbce2dda36f7efe9069d15ac0c8ee" class="ne-p"><br></p><p id="34b59079f71c74ffc834901bdd49d0df" class="ne-p"><span class="ne-text">原本凤霞和二喜的婚姻可以让这个不幸的家庭融入点暖和的血液，只是老天还是无情，凤霞的接生让小的来到这个世上，而大的永远离开了。读到这，我的内心真的很难让我往下看了，因为在父母而言，自己的子女都早于自己离开人世，白发人送黑发人，这是怎样的一种伤感，谁能接受这样的现实呢？只是活着终究要活着。之后的生活家珍走了，走的坦然，走之前的家珍说过一句“下辈子还做你的女人，下辈子还和你过”，让我觉得，这是历经苦难之后真正的爱情。爱情是两情相悦，是无言的天长地久，我敬重他们的真爱。福贵晚年也离不开现实的摧残，二喜、苦根也都离开人世了，苦根还那么小，那么的天真，再往后，就是福贵的和老牛的余生了。</span></p><p id="049dae438737fc21e34b80696466b6fc" class="ne-p"><br></p><p id="ed7d0dde53b7d53e8028786d4b9a034e" class="ne-p"><span class="ne-text">远处的池塘边，有一头老牛在池边喝水，一位老人慢慢的走去。</span></p><p id="fceb970a55838b8744a4f4cff519a96d" class="ne-p"><br></p><p id="bb1388307b90b3ee0aa3fa86bbf70f80" class="ne-p"><span class="ne-text">尽管《活着》不是一部老师所要求的自传，但我恰恰觉得这是这个世界里许多平凡的人的自传，是那些这个社会中底层人民的生活真实写照，是那些渺小的生命，却能活出活着的意义。</span></p><p id="c2481fe8be7567940164ce7f5cf5038d" class="ne-p"><br></p><p id="b7da4d66ffd8383cca955fbb6dfba0ef" class="ne-p"><br></p><p id="829298cdfced754b6c6566f9cbac2fc3" class="ne-p"><span class="ne-text">福贵，福贵的牛，福贵的爹，龙二，家丁长根，老全，春生，家珍，凤霞，有庆，二喜，苦根</span></p><p id="7fe1e951d728d6503b99cb7c8b6b0c0b" class="ne-p"><span class="ne-text">和龙二赌博输了家底导致生活破败，爹爹去世了，家珍被她爹带回家</span></p><p id="9f6e2657353a2bec2ee18add05680803" class="ne-p"><span class="ne-text">被国名党拉去充炮兵，结识老全，春生，战败之际，投降回到家里见到老婆孩子</span></p><p id="7d9acd8b2ddde6e3755d97c9ff5f0ef4" class="ne-p"><span class="ne-text">人民公社的成立以及之后的潦倒生活，文革</span></p><p id="91ef678e8518e3dac8437d7307b82975" class="ne-p"><span class="ne-text">把凤霞送给别人家，最后还是情大于现实，留下凤霞一家人生活着</span></p><p id="0602788741f7fa9102b3c48a610b6c41" class="ne-p"><span class="ne-text">有庆献血离去，凤霞接生出血离去，家珍身子体弱离去，二喜工作事故离去，苦根吃豆子死去</span></p><p id="8a8c1dcc710561a2021aebdd665eda6a" class="ne-p"><br></p><p id="906faa5ee7c65f846679dba0cc041575" class="ne-p"><span class="ne-text">反过来我们也可以说，</span><strong><span class="ne-text">因为我们都活着，从而我们的人生可以选择得不一样</span></strong><span class="ne-text">。</span></p><p id="8f06410e555a21cb23ee58c612b9ff45" class="ne-p"><br></p><p id="c7d31ee818e418b7302309ec9b606c1f" class="ne-p"><span class="ne-text">作者是以第一人称来塑造富贵这个人物形象，最后的最后只有富贵和他的老牛，不幸的人生，却告诉我们一个人生哲学：活着本身的意义就是活着。</span></p><p id="0731a5b59c027f3439682eb1fd845b60" class="ne-p"><br></p></div>]]></content>
      
      
      <categories>
          
          <category> 阅读 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>『境界的彼方』</title>
      <link href="/essay/wvwrcu/"/>
      <url>/essay/wvwrcu/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="traditional"><p id="u435b3838" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/jpg/1484158/1623940888474-c6aa4c62-7d9d-44df-b0ab-bd198c263434.jpg" width="2003" id="T2Yxz" class="ne-image"></p><p id="6246a9bb1cda408c977bad04d75c2888" class="ne-p"><br></p><p id="uceda34d7" class="ne-p"><span class="ne-text">两个特殊身份的角色在一起发生的战斗纯爱番……栗山未来是有着“被诅咒血脉”的异界士少女，神原秋人是有着寄居在体内强大妖梦的半妖（最大的反派竟是主角自己</span><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1623926928373-713cb502-b0c8-43a3-ae20-e45a5b4d6828.jpeg" width="79" id="hqw9a" class="ne-image"></p><p id="u1a52d698" class="ne-p"><br></p><hr id="8gtz1" class="ne-hr"><p id="ud713ec65" class="ne-p"><br></p><p id="u6a479a0b" class="ne-p"><span class="ne-text">虚幻之影一战</span></p><p id="ue4cd9e2f" class="ne-p"><span class="ne-text">这算是秋人解开未来心结的剧情了，男主</span></p><p id="u10b370b4" class="ne-p"><br></p><p id="u0ec14f65" class="ne-p"><br></p><p id="u95718d68" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1623927006789-0efec99a-7362-4b1f-8118-0f139cb451a3.jpeg" width="1024" id="jD2t5" class="ne-image"></p><p id="udcc70e87" class="ne-p"><br></p><p id="ud285752b" class="ne-p"><br></p><p id="ubbfc4030" class="ne-p"><span class="ne-text">当一个纯爱的人突然有一天闯进缺爱的人世界，这个人就不再孤独，他的余生也注定会因此而改变……</span></p><p id="ue6f5448e" class="ne-p"><br></p><p id="u902ad01f" class="ne-p"><br></p><p id="u2e457d3d" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1623927008770-1000842b-b921-4257-9ffe-3698a435f1ef.png" width="1920" id="EBka9" class="ne-image"></p><p id="u71452075" class="ne-p"><br></p><p id="ucfe46fd0" class="ne-p"><span class="ne-text">受过爱的缺爱的人做出的抉择往往不会像常人一样……</span></p><p id="uef31c1e8" class="ne-p"><br></p><p id="u07e89aec" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1623927010160-66e09e34-7c86-4ac5-af4d-0097251e4f26.png" width="1920" id="WSDbg" class="ne-image"></p><p id="uc2681876" class="ne-p"><br></p><p id="u87d127d5" class="ne-p"><br></p><p id="uf52bea41" class="ne-p"><br></p><p id="ub6f752f2" class="ne-p"><br></p><p id="u349cf580" class="ne-p"><span class="ne-text">这个是真的呆萌……</span></p><p id="uad20e3cf" class="ne-p"><br></p><p id="uf68c7505" class="ne-p"><br></p><p id="u9bba37de" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1623927004531-2156628e-e34f-415b-9ff1-a2b53d98f167.jpeg" width="1024" id="KMadh" class="ne-image"></p></div>]]></content>
      
      
      <categories>
          
          <category> 影视 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>最短路径算法（Dijkstra+Floyd）</title>
      <link href="/blog/rxx0ab/"/>
      <url>/blog/rxx0ab/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h2 id="zNIHZ"><span class="ne-text">问题描述</span></h2><p id="62dc1f6eeaf4d085770a4b431580e59f" class="ne-p"><strong><span class="ne-text">校园最短路径实验</span></strong></p><p id="a73d6fe9137a449283e7e6174b9a8672" class="ne-p"><span class="ne-text">1、给出校园中常用的几个点，如教室550、文宗楼、三个食堂、大操场、宿舍楼（自定）、校门口、体育场；</span></p><p id="e872dd787b0659b0ba4e065a8d1304e5" class="ne-p"><span class="ne-text">2、画图并给出其邻接矩阵（请合作完成）；</span></p><p id="8dfdd4331fdd61b2225d6ae6be60e67c" class="ne-p"><span class="ne-text">3、用floyd算法求每对顶点间的最短路。</span></p><p id="695d4175097ade1b18ab44f07893e3d0" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1622701735560-677cf8e1-e3f6-4c6a-9288-500eefaae6d4.png" width="545.5" id="VrPJt" class="ne-image"></p><hr id="RYp3i" class="ne-hr"><p id="f5896a514532e26e9ab4f424db11e700" class="ne-p"><br></p><div data-type="tips" class="ne-alert"><p id="a20d224c568e48b9d67847a2c66a8c01_p_0" class="ne-p"><span class="ne-text">迪杰斯特拉（Dijkstra）算法</span></p></div><p id="f5df7e9bae3edc596f0249ded448a799" class="ne-p"><br></p><p id="c0ace7f4bd10e006e360cc545ad23796" class="ne-p"><span class="ne-text">Dijkstra算法是经典的单源最短路径算法，用于计算源点到其它所有顶点的最短路径。在图 G=(V,E) 中，假设每条边 E[i] 的权值距离为 w[i]，找到由源点 v0 到其余各点的最短路径。</span></p><p id="c4eda4769b9382558e617e1d98192a33" class="ne-p"><span class="ne-text">适用：不含负权重的图</span></p><p id="f8c761d9834b36277f84b1f6b36ba85f" class="ne-p"><br></p><p id="660b2e6d53de278be77090da3cdff5f4" class="ne-p"><span class="ne-text">算法当中，对图的遍历方式为BFS（广度优先遍历）</span></p><h2 id="GgRFy"><span class="ne-text">代码</span></h2><p id="48d84c4d0710621d0f26ff9b37fc918b" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1622703321484-ea1fa3e2-34db-4827-8048-cd68231125cb.png" width="280.5" id="MRDfH" class="ne-image"></p><pre><code>/** * C++: Floyd算法获取最短路径(邻接矩阵) * */<p>#include &lt;iomanip&gt;<br>#include &lt;iostream&gt;<br>#include &lt;vector&gt;<br>#include &lt;bits/stdc++.h&gt;<br>using namespace std;</p><p>// 边的结构体<br>class EData<br>&#123;<br>    public:<br>        char start; // 边的起点<br>        char end;   // 边的终点<br>        int weight; // 边的权重</p><pre><code>public:    EData()&#123;&#125;    EData(char s, char e, int w):start(s),end(e),weight(w)&#123;&#125;</code></pre><p>};</p><p>class MatrixUDG {<br>    #define MAX    100<br>    #define INF    (~(0x1&lt;&lt;31))        // 无穷大(即0X7FFFFFFF)<br>    private:<br>        char mVexs[MAX];    // 顶点集合<br>        int mVexNum;             // 顶点数<br>        int mEdgNum;             // 边数<br>        int mMatrix[MAX][MAX];   // 邻接矩阵</p><pre><code>public:    // 创建图(自己输入数据)    MatrixUDG();    // 创建图(用已提供的矩阵)    //MatrixUDG(char vexs[], int vlen, char edges[][2], int elen);    MatrixUDG(char vexs[], int vlen, int matrix[][9]);    ~MatrixUDG();    // 深度优先搜索遍历图    void DFS();    // 广度优先搜索（类似于树的层次遍历）    void BFS();    // prim最小生成树(从start开始生成最小生成树)    void prim(int start);    // 克鲁斯卡尔（Kruskal)最小生成树    void kruskal();    // Dijkstra最短路径    void dijkstra(int vs, int vexs[], int dist[]);    // Floyd最短路径    void floyd(int path[][MAX], int dist[][MAX]);    // 打印矩阵队列图    void print();private:    // 读取一个输入字符    char readChar();    // 返回ch在mMatrix矩阵中的位置    int getPosition(char ch);    // 返回顶点v的第一个邻接顶点的索引，失败则返回-1    int firstVertex(int v);    // 返回顶点v相对于w的下一个邻接顶点的索引，失败则返回-1    int nextVertex(int v, int w);    // 深度优先搜索遍历图的递归实现    void DFS(int i, int *visited);    // 获取图中的边    EData* getEdges();    // 对边按照权值大小进行排序(由小到大)    void sortEdges(EData* edges, int elen);    // 获取i的终点    int getEnd(int vends[], int i);</code></pre><p>};</p><p>/* </p><ul><li><p>创建图(自己输入数据)</p></li><li><p>/<br>MatrixUDG::MatrixUDG()<br>{<br>  char c1, c2;<br>  int i, j, weight, p1, p2;</p><p>  // 输入&quot;顶点数&quot;和&quot;边数&quot;<br>  cout &lt;&lt; &quot;input vertex number: &quot;;<br>  cin &gt;&gt; mVexNum;<br>  cout &lt;&lt; &quot;input edge number: &quot;;<br>  cin &gt;&gt; mEdgNum;<br>  if ( mVexNum &lt; 1 || mEdgNum &lt; 1 || (mEdgNum &gt; (mVexNum * (mVexNum-1))))<br>  {</p><pre><code>  cout &amp;lt;&amp;lt; &amp;quot;input error: invalid parameters!&amp;quot; &amp;lt;&amp;lt; endl;  return ;</code></pre><p>  }</p><p>  // 初始化&quot;顶点&quot;<br>  for (i = 0; i &lt; mVexNum; i++)<br>  {</p><pre><code>  cout &amp;lt;&amp;lt; &amp;quot;vertex(&amp;quot; &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &amp;quot;): &amp;quot;;  mVexs[i] = readChar();</code></pre><p>  }</p><p>  // 1. 初始化&quot;边&quot;的权值<br>  for (i = 0; i &lt; mVexNum; i++)<br>  {</p><pre><code>  for (j = 0; j &amp;lt; mVexNum; j++)  &#123;      if (i==j)          mMatrix[i][j] = 0;      else          mMatrix[i][j] = INF;  &#125;</code></pre><p>  }<br>  // 2. 初始化&quot;边&quot;的权值: 根据用户的输入进行初始化<br>  for (i = 0; i &lt; mEdgNum; i++)<br>  {</p><pre><code>  // 读取边的起始顶点，结束顶点，权值  cout &amp;lt;&amp;lt; &amp;quot;edge(&amp;quot; &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &amp;quot;): &amp;quot;;  c1 = readChar();  c2 = readChar();  cin &amp;gt;&amp;gt; weight;  p1 = getPosition(c1);  p2 = getPosition(c2);  if (p1==-1 || p2==-1)  &#123;      cout &amp;lt;&amp;lt; &amp;quot;input error: invalid edge!&amp;quot; &amp;lt;&amp;lt; endl;      return ;  &#125;  mMatrix[p1][p2] = weight;  mMatrix[p2][p1] = weight;</code></pre><p>  }<br>}</p></li></ul><p>/*</p><ul><li><p>创建图(用已提供的矩阵)</p></li><li></li><li><p>参数说明：</p></li><li><pre><code>vexs  -- 顶点数组</code></pre></li><li><pre><code>vlen  -- 顶点数组的长度</code></pre></li><li><pre><code>matrix-- 矩阵(数据)</code></pre></li><li><p>/<br>MatrixUDG::MatrixUDG(char vexs[], int vlen, int matrix[][9])<br>{<br>  int i, j;</p><p>  // 初始化&quot;顶点数&quot;和&quot;边数&quot;<br>  mVexNum = vlen;<br>  // 初始化&quot;顶点&quot;<br>  for (i = 0; i &lt; mVexNum; i++)</p><pre><code>  mVexs[i] = vexs[i];</code></pre><p>  // 初始化&quot;边&quot;<br>  for (i = 0; i &lt; mVexNum; i++)</p><pre><code>  for (j = 0; j &amp;lt; mVexNum; j++)      mMatrix[i][j] = matrix[i][j];</code></pre><p>  // 统计边的数目<br>  for (i = 0; i &lt; mVexNum; i++)</p><pre><code>  for (j = 0; j &amp;lt; mVexNum; j++)      if (i!=j &amp;amp;&amp;amp; mMatrix[i][j]!=INF)          mEdgNum++;</code></pre><p>  mEdgNum /= 2;<br>}</p></li></ul><p>/* </p><ul><li>析构函数</li><li>/<br>MatrixUDG::~MatrixUDG()<br>{<br>}</li></ul><p>/*</p><ul><li>返回ch在mMatrix矩阵中的位置</li><li>/<br>int MatrixUDG::getPosition(char ch)<br>{<br>  int i;<br>  for(i=0; i&lt;mVexNum; i++)<pre><code>  if(mVexs[i]==ch)      return i;</code></pre>  return -1;<br>}</li></ul><p>/*</p><ul><li><p>读取一个输入字符</p></li><li><p>/<br>char MatrixUDG::readChar()<br>{<br>  char ch;</p><p>  do {</p><pre><code>  cin &amp;gt;&amp;gt; ch;</code></pre><p>  } while(!((ch&gt;=’a’&amp;&amp;ch&lt;=’z’) || (ch&gt;=’A’&amp;&amp;ch&lt;=’Z’)));</p><p>  return ch;<br>}</p></li></ul><p>/*</p><ul><li><p>返回顶点v的第一个邻接顶点的索引，失败则返回-1</p></li><li><p>/<br>int MatrixUDG::firstVertex(int v)<br>{<br>  int i;</p><p>  if (v&lt;0 || v&gt;(mVexNum-1))</p><pre><code>  return -1;</code></pre><p>  for (i = 0; i &lt; mVexNum; i++)</p><pre><code>  if (mMatrix[v][i]!=0 &amp;amp;&amp;amp; mMatrix[v][i]!=INF)      return i;</code></pre><p>  return -1;<br>}</p></li></ul><p>/*</p><ul><li><p>返回顶点v相对于w的下一个邻接顶点的索引，失败则返回-1</p></li><li><p>/<br>int MatrixUDG::nextVertex(int v, int w)<br>{<br>  int i;</p><p>  if (v&lt;0 || v&gt;(mVexNum-1) || w&lt;0 || w&gt;(mVexNum-1))</p><pre><code>  return -1;</code></pre><p>  for (i = w + 1; i &lt; mVexNum; i++)</p><pre><code>  if (mMatrix[v][i]!=0 &amp;amp;&amp;amp; mMatrix[v][i]!=INF)      return i;</code></pre><p>  return -1;<br>}</p></li></ul><p>/*</p><ul><li><p>深度优先搜索遍历图的递归实现</p></li><li><p>/<br>void MatrixUDG::DFS(int i, int *visited)<br>{<br>  int w;</p><p>  visited[i] = 1;<br>  cout &lt;&lt; mVexs[i] &lt;&lt; &quot; &quot;;<br>  // 遍历该顶点的所有邻接顶点。若是没有访问过，那么继续往下走<br>  for (w = firstVertex(i); w &gt;= 0; w = nextVertex(i, w))<br>  {</p><pre><code>  if (!visited[w])      DFS(w, visited);</code></pre><p>  }</p></li></ul><p>}</p><p>/*</p><ul><li><p>深度优先搜索遍历图</p></li><li><p>/<br>void MatrixUDG::DFS()<br>{<br>  int i;<br>  int visited[MAX];       // 顶点访问标记</p><p>  // 初始化所有顶点都没有被访问<br>  for (i = 0; i &lt; mVexNum; i++)</p><pre><code>  visited[i] = 0;</code></pre><p>  cout &lt;&lt; &quot;DFS: &quot;;<br>  for (i = 0; i &lt; mVexNum; i++)<br>  {</p><pre><code>  //printf(&amp;quot;\n== LOOP(%d)\n&amp;quot;, i);  if (!visited[i])      DFS(i, visited);</code></pre><p>  }<br>  cout &lt;&lt; endl;<br>}</p></li></ul><p>/*</p><ul><li><p>广度优先搜索（类似于树的层次遍历）</p></li><li><p>/<br>void MatrixUDG::BFS()<br>{<br>  int head = 0;<br>  int rear = 0;<br>  int queue[MAX];     // 辅组队列<br>  int visited[MAX];   // 顶点访问标记<br>  int i, j, k;</p><p>  for (i = 0; i &lt; mVexNum; i++)</p><pre><code>  visited[i] = 0;</code></pre><p>  cout &lt;&lt; &quot;BFS: &quot;;<br>  for (i = 0; i &lt; mVexNum; i++)<br>  {</p><pre><code>  if (!visited[i])  &#123;      visited[i] = 1;      cout &amp;lt;&amp;lt; mVexs[i] &amp;lt;&amp;lt; &amp;quot; &amp;quot;;      queue[rear++] = i;  // 入队列  &#125;  while (head != rear)   &#123;      j = queue[head++];  // 出队列      for (k = firstVertex(j); k &amp;gt;= 0; k = nextVertex(j, k)) //k是为访问的邻接顶点      &#123;          if (!visited[k])          &#123;              visited[k] = 1;              cout &amp;lt;&amp;lt; mVexs[k] &amp;lt;&amp;lt; &amp;quot; &amp;quot;;              queue[rear++] = k;          &#125;      &#125;  &#125;</code></pre><p>  }<br>  cout &lt;&lt; endl;<br>}</p></li></ul><p>/*</p><ul><li><p>打印矩阵队列图</p></li><li><p>/<br>void MatrixUDG::print()<br>{<br>  int i,j;</p><p>  cout &lt;&lt; &quot;Martix Graph:&quot; &lt;&lt; endl;<br>  for (i = 0; i &lt; mVexNum; i++)<br>  {</p><pre><code>  for (j = 0; j &amp;lt; mVexNum; j++)      cout &amp;lt;&amp;lt; setw(10) &amp;lt;&amp;lt; mMatrix[i][j] &amp;lt;&amp;lt; &amp;quot; &amp;quot;;  cout &amp;lt;&amp;lt; endl;</code></pre><p>  }<br>}</p></li></ul><p>/*</p><ul><li><p>prim最小生成树</p></li><li></li><li><p>参数说明：</p></li><li><p>  start – 从图中的第start个元素开始，生成最小树</p></li><li><p>/<br>void MatrixUDG::prim(int start)<br>{<br>  int min,i,j,k,m,n,sum;<br>  int index=0;         // prim最小树的索引，即prims数组的索引<br>  char prims[MAX];     // prim最小树的结果数组<br>  int weights[MAX];    // 顶点间边的权值</p><p>  // prim最小生成树中第一个数是&quot;图中第start个顶点&quot;，因为是从start开始的。<br>  prims[index++] = mVexs[start];</p><p>  // 初始化&quot;顶点的权值数组&quot;，<br>  // 将每个顶点的权值初始化为&quot;第start个顶点&quot;到&quot;该顶点&quot;的权值。<br>  for (i = 0; i &lt; mVexNum; i++ )</p><pre><code>  weights[i] = mMatrix[start][i];</code></pre><p>  // 将第start个顶点的权值初始化为0。<br>  // 可以理解为&quot;第start个顶点到它自身的距离为0&quot;。<br>  weights[start] = 0;</p><p>  for (i = 0; i &lt; mVexNum; i++)<br>  {</p><pre><code>  // 由于从start开始的，因此不需要再对第start个顶点进行处理。  if(start == i)      continue;  j = 0;  k = 0;  min = INF;  // 在未被加入到最小生成树的顶点中，找出权值最小的顶点。  while (j &amp;lt; mVexNum)  &#123;      // 若weights[j]=0，意味着&amp;quot;第j个节点已经被排序过&amp;quot;(或者说已经加入了最小生成树中)。      if (weights[j] != 0 &amp;amp;&amp;amp; weights[j] &amp;lt; min)      &#123;          min = weights[j];          k = j;      &#125;      j++;  &#125;  // 经过上面的处理后，在未被加入到最小生成树的顶点中，权值最小的顶点是第k个顶点。  // 将第k个顶点加入到最小生成树的结果数组中  prims[index++] = mVexs[k];  // 将&amp;quot;第k个顶点的权值&amp;quot;标记为0，意味着第k个顶点已经排序过了(或者说已经加入了最小树结果中)。  weights[k] = 0;  // 当第k个顶点被加入到最小生成树的结果数组中之后，更新其它顶点的权值。  for (j = 0 ; j &amp;lt; mVexNum; j++)  &#123;      // 当第j个节点没有被处理，并且需要更新时才被更新。      if (weights[j] != 0 &amp;amp;&amp;amp; mMatrix[k][j] &amp;lt; weights[j])          weights[j] = mMatrix[k][j];  &#125;</code></pre><p>  }</p><p>  // 计算最小生成树的权值<br>  sum = 0;<br>  for (i = 1; i &lt; index; i++)<br>  {</p><pre><code>  min = INF;  // 获取prims[i]在mMatrix中的位置  n = getPosition(prims[i]);  // 在vexs[0...i]中，找出到j的权值最小的顶点。  for (j = 0; j &amp;lt; i; j++)  &#123;      m = getPosition(prims[j]);      if (mMatrix[m][n]&amp;lt;min)          min = mMatrix[m][n];  &#125;  sum += min;</code></pre><p>  }<br>  // 打印最小生成树<br>  cout &lt;&lt; &quot;PRIM(&quot; &lt;&lt; mVexs[start] &lt;&lt; &quot;)=&quot; &lt;&lt; sum &lt;&lt; &quot;: &quot;;<br>  for (i = 0; i &lt; index; i++)</p><pre><code>  cout &amp;lt;&amp;lt; prims[i] &amp;lt;&amp;lt; &amp;quot; &amp;quot;;</code></pre><p>  cout &lt;&lt; endl;<br>}</p></li></ul><p>/* </p><ul><li><p>获取图中的边</p></li><li><p>/<br>EData* MatrixUDG::getEdges()<br>{<br>  int i,j;<br>  int index=0;<br>  EData *edges;</p><p>  edges = new EData[mEdgNum];<br>  for (i=0; i &lt; mVexNum; i++)<br>  {</p><pre><code>  for (j=i+1; j &amp;lt; mVexNum; j++)  &#123;      if (mMatrix[i][j]!=INF)      &#123;          edges[index].start  = mVexs[i];          edges[index].end    = mVexs[j];          edges[index].weight = mMatrix[i][j];          index++;      &#125;  &#125;</code></pre><p>  }</p><p>  return edges;<br>}</p></li></ul><p>/* </p><ul><li><p>对边按照权值大小进行排序(由小到大)</p></li><li><p>/<br>void MatrixUDG::sortEdges(EData* edges, int elen)<br>{<br>  int i,j;</p><p>  for (i=0; i&lt;elen; i++)<br>  {</p><pre><code>  for (j=i+1; j&amp;lt;elen; j++)  &#123;      if (edges[i].weight &amp;gt; edges[j].weight)      &#123;          // 交换&amp;quot;边i&amp;quot;和&amp;quot;边j&amp;quot;          swap(edges[i], edges[j]);      &#125;  &#125;</code></pre><p>  }<br>}</p></li></ul><p>/*</p><ul><li>获取i的终点</li><li>/<br>int MatrixUDG::getEnd(int vends[], int i)<br>{<br>  while (vends[i] != 0)<pre><code>  i = vends[i];</code></pre>  return i;<br>}</li></ul><p>/*</p><ul><li><p>克鲁斯卡尔（Kruskal)最小生成树</p></li><li><p>/<br>void MatrixUDG::kruskal()<br>{<br>  int i,m,n,p1,p2;<br>  int length;<br>  int index = 0;          // rets数组的索引<br>  int vends[MAX]={0};     // 用于保存&quot;已有最小生成树&quot;中每个顶点在该最小树中的终点。<br>  EData rets[MAX];        // 结果数组，保存kruskal最小生成树的边<br>  EData *edges;           // 图对应的所有边</p><p>  // 获取&quot;图中所有的边&quot;<br>  edges = getEdges();<br>  // 将边按照&quot;权&quot;的大小进行排序(从小到大)<br>  sortEdges(edges, mEdgNum);</p><p>  for (i=0; i&lt;mEdgNum; i++)<br>  {</p><pre><code>  p1 = getPosition(edges[i].start);      // 获取第i条边的&amp;quot;起点&amp;quot;的序号  p2 = getPosition(edges[i].end);        // 获取第i条边的&amp;quot;终点&amp;quot;的序号  m = getEnd(vends, p1);                 // 获取p1在&amp;quot;已有的最小生成树&amp;quot;中的终点  n = getEnd(vends, p2);                 // 获取p2在&amp;quot;已有的最小生成树&amp;quot;中的终点  // 如果m!=n，意味着&amp;quot;边i&amp;quot;与&amp;quot;已经添加到最小生成树中的顶点&amp;quot;没有形成环路  if (m != n)  &#123;      vends[m] = n;                       // 设置m在&amp;quot;已有的最小生成树&amp;quot;中的终点为n      rets[index++] = edges[i];           // 保存结果  &#125;</code></pre><p>  }<br>  delete[] edges;</p><p>  // 统计并打印&quot;kruskal最小生成树&quot;的信息<br>  length = 0;<br>  for (i = 0; i &lt; index; i++)</p><pre><code>  length += rets[i].weight;</code></pre><p>  cout &lt;&lt; &quot;Kruskal=&quot; &lt;&lt; length &lt;&lt; &quot;: &quot;;<br>  for (i = 0; i &lt; index; i++)</p><pre><code>  cout &amp;lt;&amp;lt; &amp;quot;(&amp;quot; &amp;lt;&amp;lt; rets[i].start &amp;lt;&amp;lt; &amp;quot;,&amp;quot; &amp;lt;&amp;lt; rets[i].end &amp;lt;&amp;lt; &amp;quot;) &amp;quot;;</code></pre><p>  cout &lt;&lt; endl;<br>}</p></li></ul><p>/*</p><ul><li><p>Dijkstra最短路径。</p></li><li><p>即，统计图中&quot;顶点vs&quot;到其它各个顶点的最短路径。</p></li><li></li><li><p>参数说明：</p></li><li><pre><code>  vs -- 起始顶点(start vertex)。即计算&amp;quot;顶点vs&amp;quot;到其它顶点的最短路径。</code></pre></li><li><pre><code>prev -- 前驱顶点数组。即，prev[i]的值是&amp;quot;顶点vs&amp;quot;到&amp;quot;顶点i&amp;quot;的最短路径所经历的全部顶点中，位于&amp;quot;顶点i&amp;quot;之前的那个顶点。</code></pre></li><li><pre><code>dist -- 长度数组。即，dist[i]是&amp;quot;顶点vs&amp;quot;到&amp;quot;顶点i&amp;quot;的最短路径的长度。</code></pre></li><li><p>/<br>void MatrixUDG::dijkstra(int vs, int prev[], int dist[])<br>{<br>  int i,j,k;<br>  int min;<br>  int tmp;<br>  int flag[MAX];      // flag[i]=1表示&quot;顶点vs&quot;到&quot;顶点i&quot;的最短路径已成功获取。</p><p>  // 初始化<br>  for (i = 0; i &lt; mVexNum; i++)<br>  {</p><pre><code>  flag[i] = 0;              // 顶点i的最短路径还没获取到。  prev[i] = 0;              // 顶点i的前驱顶点为0。  dist[i] = mMatrix[vs][i]; // 顶点i的最短路径为&amp;quot;顶点vs&amp;quot;到&amp;quot;顶点i&amp;quot;的权。</code></pre><p>  }</p><p>  // 对&quot;顶点vs&quot;自身进行初始化<br>  flag[vs] = 1;<br>  dist[vs] = 0;</p><p>  // 遍历mVexNum-1次；每次找出一个顶点的最短路径。<br>  for (i = 1; i &lt; mVexNum; i++)<br>  {</p><pre><code>  // 寻找当前最小的路径；  // 即，在未获取最短路径的顶点中，找到离vs最近的顶点(k)。  min = INF;  for (j = 0; j &amp;lt; mVexNum; j++)  &#123;      if (flag[j]==0 &amp;amp;&amp;amp; dist[j]&amp;lt;min)      &#123;          min = dist[j];          k = j;      &#125;  &#125;  // 标记&amp;quot;顶点k&amp;quot;为已经获取到最短路径  flag[k] = 1;  // 修正当前最短路径和前驱顶点  // 即，当已经&amp;quot;顶点k的最短路径&amp;quot;之后，更新&amp;quot;未获取最短路径的顶点的最短路径和前驱顶点&amp;quot;。  for (j = 0; j &amp;lt; mVexNum; j++)  &#123;      tmp = (mMatrix[k][j]==INF ? INF : (min + mMatrix[k][j]));      if (flag[j] == 0 &amp;amp;&amp;amp; (tmp  &amp;lt; dist[j]) )      &#123;          dist[j] = tmp;          prev[j] = k;      &#125;  &#125;</code></pre><p>  }</p><p>  // 打印dijkstra最短路径的结果<br>  cout &lt;&lt; &quot;dijkstra(&quot; &lt;&lt; mVexs[vs] &lt;&lt; &quot;): &quot; &lt;&lt; endl;<br>  for (i = 0; i &lt; mVexNum; i++)</p><pre><code>  cout &amp;lt;&amp;lt; &amp;quot;  shortest(&amp;quot; &amp;lt;&amp;lt; mVexs[vs] &amp;lt;&amp;lt; &amp;quot;, &amp;quot; &amp;lt;&amp;lt; mVexs[i] &amp;lt;&amp;lt; &amp;quot;)=&amp;quot; &amp;lt;&amp;lt; dist[i] &amp;lt;&amp;lt; endl;</code></pre><p>}</p></li></ul><p>/*</p><ul><li><p>floyd最短路径。</p></li><li><p>即，统计图中各个顶点间的最短路径。</p></li><li></li><li><p>参数说明：</p></li><li><pre><code>path -- 路径。path[i][j]=k表示，&amp;quot;顶点i&amp;quot;到&amp;quot;顶点j&amp;quot;的最短路径会经过顶点k。</code></pre></li><li><pre><code>dist -- 长度数组。即，dist[i][j]=sum表示，&amp;quot;顶点i&amp;quot;到&amp;quot;顶点j&amp;quot;的最短路径的长度是sum。</code></pre></li><li><p>/<br>void MatrixUDG::floyd(int path[][MAX], int dist[][MAX])<br>{<br>  int i,j,k;<br>  int tmp;</p><p>  // 初始化<br>  for (i = 0; i &lt; mVexNum; i++)<br>  {</p><pre><code>  for (j = 0; j &amp;lt; mVexNum; j++)  &#123;      dist[i][j] = mMatrix[i][j];    // &amp;quot;顶点i&amp;quot;到&amp;quot;顶点j&amp;quot;的路径长度为&amp;quot;i到j的权值&amp;quot;。      path[i][j] = j;                // &amp;quot;顶点i&amp;quot;到&amp;quot;顶点j&amp;quot;的最短路径是经过顶点j。  &#125;</code></pre><p>  }</p><p>  // 计算最短路径<br>  for (k = 0; k &lt; mVexNum; k++)<br>  {</p><pre><code>  for (i = 0; i &amp;lt; mVexNum; i++)  &#123;      for (j = 0; j &amp;lt; mVexNum; j++)      &#123;          // 如果经过下标为k顶点路径比原两点间路径更短，则更新dist[i][j]和path[i][j]          tmp = (dist[i][k]==INF || dist[k][j]==INF) ? INF : (dist[i][k] + dist[k][j]);          if (dist[i][j] &amp;gt; tmp)          &#123;              // &amp;quot;i到j最短路径&amp;quot;对应的值设，为更小的一个(即经过k)              dist[i][j] = tmp;              // &amp;quot;i到j最短路径&amp;quot;对应的路径，经过k              path[i][j] = path[i][k];          &#125;      &#125;  &#125;</code></pre><p>  }<br>  char dot[] = {‘A’, ‘B’, ‘C’, ‘D’, ‘E’, ‘F’, ‘G’, ‘H’, ‘I’};<br>  // 打印floyd最短路径的结果<br>  cout &lt;&lt; &quot;floyd各个地点的最短路径矩阵如下: &quot; &lt;&lt; endl;<br>  cout &lt;&lt; &quot;    &quot;;<br>  for (int k = 0;k&lt;9;k++){</p><pre><code>  cout &amp;lt;&amp;lt; dot[k] &amp;lt;&amp;lt; &amp;quot;    &amp;quot;;</code></pre><p>  }<br>  cout &lt;&lt; &quot;\n&quot;;<br>  for (i = 0; i &lt; mVexNum; i++){</p><pre><code>  cout &amp;lt;&amp;lt; dot[i] &amp;lt;&amp;lt; &amp;quot;: &amp;quot;;  for (j = 0; j &amp;lt; mVexNum; j++)      cout &amp;lt;&amp;lt; setw(2) &amp;lt;&amp;lt; dist[i][j] &amp;lt;&amp;lt; &amp;quot;  &amp;quot;;  cout &amp;lt;&amp;lt; endl;</code></pre><p>  }<br>}</p></li></ul><p>int main()<br>{<br>    int prev[MAX] = {0};<br>    int dist[MAX] = {0};<br>    int path[MAX][MAX] = {0};    // 用于保存floyd路径<br>    int floy[MAX][MAX] = {0};    // 用于保存floyd长度<br>    char vexs[] = {‘A’, ‘B’, ‘C’, ‘D’, ‘E’, ‘F’, ‘G’, ‘H’, ‘I’};<br>    int matrix[][9] = {<br>                      /<em>A</em>//<em>B</em>//<em>C</em>//<em>D</em>//<em>E</em>//<em>F</em>//<em>G</em>//<em>H</em>//<em>I</em>/<br>      /<em>A西门</em>/     {   0,  615, 435, 210, 790,  INF,  INF, INF, INF},<br>      /<em>B550教室</em>/  { 615,   0,  144, 620, 380,   822, INF, INF, INF},<br>      /<em>C文宗楼</em>/   { 435,  144,   0,   INF,   265,   INF, INF, INF, INF},<br>      /<em>D二餐</em>/     { 210, 620,   INF,   0,   480, INF, INF, INF, 170},<br>      /<em>E图书馆</em>/   { 790, 380,   265,   480,   0,   620,   735, 310, 700},<br>      /<em>F北门</em>/     { INF, 822,   INF,   INF,   620,   0,   500, INF, INF},<br>      /<em>G体育馆</em>/   { INF, INF,   INF,   INF,   735,   500,   0, 556, INF},<br>      /<em>H一餐</em>/     {  INF,   INF,   INF, INF,   310,   INF,   556, 0, 420},<br>      /<em>I16号楼</em>/   {  INF, INF, INF, 170,   700,   INF,   INF, 420, 0}};<br>    int vlen = sizeof(vexs)/sizeof(vexs[0]);<br>    MatrixUDG* pG;</p><pre><code>// 自定义&amp;quot;图&amp;quot;(输入矩阵队列)//pG = new MatrixUDG();// 采用已有的&amp;quot;图&amp;quot;pG = new MatrixUDG(vexs, vlen, matrix);//pG-&amp;gt;print();   // 打印图//pG-&amp;gt;DFS();     // 深度优先遍历//pG-&amp;gt;BFS();     // 广度优先遍历//pG-&amp;gt;prim(0);   // prim算法生成最小生成树//pG-&amp;gt;kruskal(); // Kruskal算法生成最小生成树// dijkstra算法获取&amp;quot;第4个顶点&amp;quot;到其它各个顶点的最短距离//pG-&amp;gt;dijkstra(3, prev, dist);// floyd算法获取各个顶点之间的最短距离pG-&amp;gt;floyd(path, floy);return 0;</code></pre><p>}<br></code></pre></p><p id="890d57e51a7141565ace3003b56e24c7" class="ne-p"><br></p><h2 id="UcdRQ"><span class="ne-text">参考</span></h2><ul class="ne-ul"><li id="5086d9c56dadd125ba405e10f6379b06"><a href="https://houbb.github.io/2020/01/23/data-struct-learn-03-graph-dijkstra" data-href="https://houbb.github.io/2020/01/23/data-struct-learn-03-graph-dijkstra" target="_blank" class="ne-link"><span class="ne-text">图最短路径算法之迪杰斯特拉算法（Dijkstra）</span></a></li><li id="97fadfb9fac663e518e85ca92e948634"><a href="https://www.cnblogs.com/skywang12345/p/3711526.html" data-href="https://www.cnblogs.com/skywang12345/p/3711526.html" target="_blank" class="ne-link"><span class="ne-text">Floyd算法(二)之 C++详解</span></a></li></ul></div>]]></content>
      
      
      <categories>
          
          <category> 计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 💕贪心算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>图的遍历——DFS（深度优先）、BFS（广度优先）</title>
      <link href="/blog/ztiag3/"/>
      <url>/blog/ztiag3/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="c4377b9c5907fc32e4dd3a3ec889224d" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1621307069176-74d6900b-6edd-4e7a-b761-789df7a17cfe.png" width="563" id="W9sKH" class="ne-image"></p><p id="aeba3ae9fd44225e4bcdfd6b1387df74" class="ne-p"><br></p><div data-type="info" class="ne-alert"><p id="8602641d8bcd30fd83b83906a84c1786" class="ne-p"><span class="ne-text">前言：用邻接矩阵和邻接表两种图的存储形式实现DFS、BFS算法，并附例子实现。</span></p><p id="a2a30595325972cce3bffd75dcc31f68" class="ne-p"><span class="ne-text">总的来说，邻接矩阵比较好处理，没有邻接表处理那么复杂，但是数组永远不能规避的一个缺点就是内存的占用较邻接表高。</span></p></div><p id="905ea7f782ba98d5a209da0f35f5c203" class="ne-p"><br></p><h2 id="QOJfe"><span class="ne-text">一、深度优先搜索算法（Depth-First-Search）</span></h2><h3 id="MZ0vA"><span class="ne-text">算法说明</span></h3><p id="4e097c10f9608f768b643efb77ddac9f" class="ne-p"><strong><span class="ne-text">访问步骤：</span></strong></p><div class="ne-quote"><ul class="ne-ul"><li id="7a87afee8efc50a1215b2c73dee1007c"><span class="ne-text">访问顶点v；</span></li><li id="75fd425f477a5edfe8e8f42d7362ada1"><span class="ne-text">依次从v的未被访问的邻接点出发，对图进行深度优先遍历；直至图中和v有路径相通的顶点都被访问；</span></li><li id="fd5afc9bef88cbee4ece89b7a4b042f5"><span class="ne-text">若此时图中尚有顶点未被访问，则从一个未被访问的顶点出发，重新进行深度优先遍历，直到图中所有顶点均被访问过为止。</span></li></ul></div><p id="ba6b093d11719b506938b7131380d8ac" class="ne-p"><br></p><p id="0aab1d1b162418f9bf49863d35a32fda" class="ne-p"><strong><span class="ne-text">核心代码就是利用递归，以及标志数组的设定，每次访问数组元素的那一行，对那行链表进行遍历，每遍历一个链表结点，就将“其”所在的那个数组元素“点亮”。如果标志数组里面的所有元素都被访问了，说明遍历完了</span></strong></p><p id="b12a3d4a70976459fc1d9bcab1a7ff25" class="ne-p" style="text-indent: 2em"><br></p><p id="ccdd034b8bc976b98a833b1b3a4480f7" class="ne-p"><strong><span class="ne-text">深度优先搜索类似于树里面遍历算法当中的先序遍历。</span></strong></p><h3 id="ZU5Ew"><span class="ne-text">邻接矩阵的DFS代码</span></h3><p id="0c7fc91bebbf033661b0d2f0e2755bb3" class="ne-p"><span class="ne-text">以这个无向图为例</span></p><p id="e91496d0133f08a7c583147a966ce5cb" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1621329549870-b2fd8a63-a532-4860-8e46-a79cc52a7e0f.png" width="197" id="Xvwlk" class="ne-image"></p><p id="f5a357efd0ac30dc1a34889c7258c8c8" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1621329584016-32d023fe-dc14-4c0d-90e1-7afe6fcc9cd2.png" width="227.5" id="XY5Cd" class="ne-image"></p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;<p>#define MVNum 100<br>#define MaxInt 32767</p><p>typedef char VerTexType;<br>typedef int ArcType;</p><p>/**</p><ul><li>邻接矩阵存储形式</li><li>/<br>typedef struct &#123;<br>  /* data */<br>  VerTexType vexs[MVNum]; //顶点表<br>  ArcType arcs[MVNum][MVNum]; //邻接矩阵<br>  int vexnum, arcnum; //图的当前顶点和边数<br>&#125;AMGraph;</li></ul><p>/**</p><ul><li>确定v在G中的位置，即顶点数组的下标</li><li>/<br>int LocateVex(AMGraph &amp;G, char v) &#123;<br>  for (int i = 0; i &lt; G.vexnum;i++) &#123;<pre><code>  if (v == G.vexs[i])&#123;      return i;  &#125;</code></pre>  }<br>}</li></ul><p>/**</p><ul><li>如果创建无向图   </li><li>/<br>void CreateUDN(AMGraph &amp;G) {<br>  // 采用邻接矩阵表示法，创建无向图G<br>  cout &lt;&lt; &quot;请输入顶点数和边数：&quot; &lt;&lt; endl;<br>  cin &gt;&gt; G.vexnum &gt;&gt; G.arcnum; //输入顶点数和边数<br>  // 初始化顶点<br>  for (int i = 0; i &lt; G.vexnum;i++){<pre><code>  cout &amp;lt;&amp;lt; &amp;quot;请输入第&amp;quot; &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &amp;quot;个顶点值&amp;quot; &amp;lt;&amp;lt; endl;  cin &amp;gt;&amp;gt; G.vexs[i];</code></pre>  }<br>  // 初始化邻接矩阵的边的权值为最大值<br>  for (int i = 0; i &lt; G.vexnum;i++) {<pre><code>  for (int j = 0; j &amp;lt; G.vexnum;j++) &#123;      G.arcs[i][j] = 0;  &#125;</code></pre>  }<br>  // 构造邻接矩阵<br>  for (int k = 0; k &lt; G.arcnum;k++) {<pre><code>  cout &amp;lt;&amp;lt; &amp;quot;请输入每条边所依附的顶点：&amp;quot; &amp;lt;&amp;lt; endl;  char v1, v2;  int w = 1; //一条边所依附的顶点和权值  cin &amp;gt;&amp;gt; v1 &amp;gt;&amp;gt; v2;  int i = LocateVex(G, v1);  int j = LocateVex(G, v2);  G.arcs[i][j] = w;  G.arcs[j][i] = w;</code></pre>  }<br>}</li></ul><p>/**</p><ul><li>打印输出图</li><li>/<br>void Display(AMGraph &amp;G) {<br>  for (int i = 0; i &lt; G.vexnum;i++) {<pre><code>  for (int j = 0; j &amp;lt; G.vexnum;j++) &#123;      cout &amp;lt;&amp;lt; G.arcs[i][j] &amp;lt;&amp;lt; &amp;quot; &amp;quot;;  &#125;  cout &amp;lt;&amp;lt; endl;</code></pre>  }<br>}</li></ul><p>//—-邻接矩阵的DFS遍历—-</p><p>//访问标志数组，其初值为false<br>bool visited[MVNum]; </p><p>/**</p><ul><li>图G为邻接矩阵类型，从第v个顶点出发深度优先搜索遍历图G</li><li>/<br>void DFS_AM(AMGraph &amp;G, int v) {<br>  //访问第v个顶点，并置访问标志数组相应分量值为true<br>  cout&lt;&lt;v;<br>  visited[v] = true;<br>  //依次检查邻接矩阵v所在的行<br>  for(int w = 0; w &lt; G.vexnum; w++)  <pre><code>  //G.arcs[v][w] != 0表示w是v的邻接点，!visited[w]表示未访问到  if((G.arcs[v][w] != 0) &amp;amp;&amp;amp; (!visited[w]))        DFS_AM(G, w);    //递归调用DFS_AM</code></pre>}</li></ul><p>/**</p><ul><li>图G的储存类型任意，对非连通图G做深度优先遍历</li><li>/<br>void DFSTraverse(AMGraph &amp;G) {<br>  //访问标志数组初始化<br>  for(int v = 0; v &lt; G.vexnum; v++)  <pre><code>  visited[v] = false;</code></pre>  //循环调用DFS<br>  for(int v = 0; v &lt; G.vexnum; v++)  <pre><code>  if(!visited[v])      DFS_AM(G, v); //对尚未访问的顶点调用DFS</code></pre>}</li></ul><p>int main() {<br>    AMGraph test;<br>    CreateUDN(test);<br>    Display(test);<br>    DFSTraverse(test);<br>    return 0;<br>}</p><p></code></pre></p><h3 id="yoSIg"><span class="ne-text">邻接表的DFS代码</span></h3><p id="0185257cc5891b4779bd509a36e4bf08" class="ne-p"><span class="ne-text">举之前上课的一张PPT例子（元素插入为后插法）</span></p><p id="8f0f1b106f7dee1d8b9124d39e708517" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1621333199678-46b6841b-415b-46e8-b0f6-0d0407284b15.png" width="554" id="HmOsr" class="ne-image"></p><p id="7d9b1ab0ddea1a0b1cc6919a63753b20" class="ne-p"><span class="ne-text">结果</span></p><p id="87a60371c70d6ef42ae0b5733953742a" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1621333246481-117ec0ea-ab95-43be-ac13-75712fdf1e2b.png" width="222" id="KjOYY" class="ne-image"></p><pre><code>#include &lt;bits/stdc++.h&gt;using namespace std;<p>#define MVNum 100<br>#define MaxInt 32767</p><p>typedef char VerTexType;<br>typedef int OtherInfo;</p><p>/**</p><ul><li>邻接表存储</li><li>/</li></ul><p>/**</p><ul><li>存储结构</li><li>/<br>typedef struct ArcNode &#123;  //边结点<br>  int adjvex;  //该边所指向的结点的位置<br>  struct ArcNode *nextarc; //指向下一条边的指针<br>  OtherInfo info;   //和边相关的其他信息<br>&#125;ArcNode;</li></ul><p>typedef struct VNode &#123;   //顶点信息<br>    VerTexType data;  //数据域，存放顶点vi的名称或其他有关信息<br>    ArcNode *firstarc;  //指向第一条依附该顶点的边的指针<br>&#125;VNode, AdjList[MVNum]; //AdjList表示邻接表的类型</p><p>typedef struct &#123;<br>    AdjList vertices;<br>    int vexnum, arcnum; //图当前的顶点数和边数<br>&#125;ALGragh; //邻接表（Adjacency List）</p><p>/**</p><ul><li>找到v顶点在图的顶点数组中的位置</li><li>/<br>int LocateVex(ALGragh &amp;G, char v) &#123;<br>  for (int i = 0; i &lt; G.vexnum;i++) &#123;<pre><code>  if (v == G.vertices[i].data) &#123;      return i;  &#125;</code></pre>  }<br>}</li></ul><p>/**</p><ul><li>邻接表创建无向图</li><li>/<br>void CreateUDG(ALGragh &amp;G) {<br>  cout &lt;&lt; &quot;请输入顶点数和边数：&quot; &lt;&lt; endl;<br>  cin &gt;&gt; G.vexnum &gt;&gt; G.arcnum; // 邻接表的顶点数和边数<br>  // 初始化顶点数组<br>  for (int i = 0; i &lt; G.vexnum;i++) {<pre><code>  cin &amp;gt;&amp;gt; G.vertices[i].data; // 初始化顶点数组里面的结点data  G.vertices[i].firstarc = NULL; // 初始化顶点数组里面的结点next域</code></pre>  }<br>  // 初始化所有的边<br>  for (int k = 0; k &lt; G.arcnum;k++) {<pre><code>  char v1, v2;  cout &amp;lt;&amp;lt; &amp;quot;请输入每条边所依附的顶点：&amp;quot; &amp;lt;&amp;lt; endl;  cin &amp;gt;&amp;gt; v1 &amp;gt;&amp;gt; v2;  int i = LocateVex(G, v1); // 找到v1在顶点数组的下标  int j = LocateVex(G, v2); // 找到v2在顶点数组的下标  // 下面建立p1和p2是因为无向图，如果是有向图就没必要了只需要p1  // 前插  ArcNode *p1 = new ArcNode;  p1-&amp;gt;adjvex = j;  p1-&amp;gt;nextarc = G.vertices[i].firstarc;  G.vertices[i].firstarc = p1;  ArcNode *p2 = new ArcNode;  p2-&amp;gt;adjvex = i;  p2-&amp;gt;nextarc = G.vertices[j].firstarc;  G.vertices[j].firstarc = p2;</code></pre>  }<br>}</li></ul><p>/**</p><ul><li>打印输出图</li><li>/<br>void Display(ALGragh &amp;G) {<br>  for (int i = 0; i &lt; G.vexnum;i++) {<pre><code>  cout &amp;lt;&amp;lt; &amp;quot;结点&amp;quot; &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &amp;quot;：&amp;quot;;  // 复制选中的节点数组中的结点  VNode p;  p = G.vertices[i];  if (p.firstarc != NULL)&#123;      ArcNode *temp;      temp = G.vertices[i].firstarc;      while (temp != NULL) &#123;          cout &amp;lt;&amp;lt; temp-&amp;gt;adjvex&amp;lt;&amp;lt;&amp;quot; &amp;quot;;          temp = temp-&amp;gt;nextarc;      &#125;      cout &amp;lt;&amp;lt; &amp;quot;\n&amp;quot;;  &#125;</code></pre>  }<br>}</li></ul><p>//—-邻接表的DFS遍历—-<br>bool visited[MVNum];                                                    //访问标志数组，其初值为false</p><p>void DFS_AL(ALGragh G, int v)<br>{//图G为邻接表类型，从从第v个顶点出发深度优先搜索遍历图G<br>    cout&lt;&lt;v;                                                            //访问第v个顶点，并置访问标志数组相应分量值为true<br>    visited[v] = true;<br>    ArcNode *p;<br>    p = G.vertices[v].firstarc;                                         //p指向v的边链表的第一个边结点<br>    while(p != NULL)<br>    {<br>       int w = p-&gt;adjvex;                                               //w是v的邻接点<br>        if(!visited[w])                                                 //如果w未访问<br>            DFS_AL(G, w);                                               //递归调用DFS_AL<br>        p = p-&gt;nextarc;                                                 //p指向下一个结点<br>    }<br>}</p><p>void DFSTraverse(ALGragh G)<br>{//图G的储存类型任意，对非连通图G做深度优先遍历<br>    for(int v = 0; v &lt; G.vexnum; v++)                                   //访问标志数组初始化<br>        visited[v] = false;<br>    for(int v = 0; v &lt; G.vexnum; v++)                                   //循环调用DFS<br>        if(!visited[v])<br>            DFS_AL(G, v);                                                  //对尚未访问的顶点调用DFS<br>}</p><p>int main() {<br>    ALGragh test;<br>    CreateUDG(test);<br>    // Display(test);<br>    DFSTraverse(test);<br>}<br></code></pre></p><h2 id="QXnap"><span class="ne-text">二、广度优先搜索算法（Breadth-First-Search）</span></h2><h3 id="G0xbz"><span class="ne-text">算法说明</span></h3><p id="94b96fd18f6299a92edb0bbb0104497e" class="ne-p"><span class="ne-text">从某个顶点V0出发，并在访问此顶点之后依次访问V0的所有未被访问过的邻接点，之后按这些顶点被访问的先后次序依次访问它们的邻接点，直至图中所有和V0有路径相通的顶点都被访问到。</span></p><p id="79c6bc4660da95e5eb3a4d3b82f0c95d" class="ne-p"><span class="ne-text"></span></p><p id="7d0dd6f76b33ab2e7809089c7833daa9" class="ne-p"><span class="ne-text">若此时图中尚有顶点未被访问，则另选图中一个未曾被访问的顶点作起始点，重复上述过程，直至图中所有顶点都被访问到为止。</span></p><p id="c994dac6d6ea729bf4c53d5e56f6b638" class="ne-p"><br></p><p id="5603100122d38ec5f9e050b858b65d40" class="ne-p"><strong><span class="ne-text">在树遍历中类似层次遍历。</span></strong></p><p id="cec298b23684b1046e1e7ced82785774" class="ne-p"><strong><span class="ne-text"></span></strong></p><h3 id="tX0WF"><span class="ne-text">邻接矩阵的BFS代码</span></h3><p id="2c79fedd6fba3d1dc3fa877ec630c8b4" class="ne-p"><span class="ne-text">还是这个例子</span></p><p id="4182bef26913ccb9daaf8020669dfc2f" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1621329549870-b2fd8a63-a532-4860-8e46-a79cc52a7e0f.png" width="197" id="bbWIn" class="ne-image"></p><p id="aee9ada2779b6772f70229266531e473" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1621338913834-3f2453f3-c56d-4401-9e26-2de805587a04.png" width="228.5" id="hRiOt" class="ne-image"></p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;<p>#define MVNum 100<br>#define MaxInt 32767</p><p>typedef char VerTexType;<br>typedef int ArcType;</p><p>/**</p><ul><li>邻接矩阵的bfs代码</li><li>/<br>typedef struct &#123;<br>  /* data */<br>  VerTexType vexs[MVNum]; //顶点表<br>  ArcType arcs[MVNum][MVNum]; //邻接矩阵<br>  int vexnum, arcnum; //图的当前顶点和边数<br>&#125;AMGraph;</li></ul><p>/**</p><ul><li>确定v在G中的位置，即顶点数组的下标</li><li>/<br>int LocateVex(AMGraph &amp;G, char v) &#123;<br>  for (int i = 0; i &lt; G.vexnum;i++) &#123;<pre><code>  if (v == G.vexs[i])&#123;      return i;  &#125;</code></pre>  }<br>}</li></ul><p>/**</p><ul><li>创建无向网</li><li>如果创建无向图   </li><li>/<br>void CreateUDN(AMGraph &amp;G) {<br>  // 采用邻接矩阵表示法，创建无向图G<br>  cout &lt;&lt; &quot;请输入顶点数和边数：&quot; &lt;&lt; endl;<br>  cin &gt;&gt; G.vexnum &gt;&gt; G.arcnum; //输入顶点数和边数<br>  // 初始化顶点<br>  for (int i = 0; i &lt; G.vexnum;i++){<pre><code>  cout &amp;lt;&amp;lt; &amp;quot;请输入第&amp;quot; &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &amp;quot;个顶点值&amp;quot; &amp;lt;&amp;lt; endl;  cin &amp;gt;&amp;gt; G.vexs[i];</code></pre>  }<br>  // 初始化邻接矩阵的边的权值为最大值<br>  for (int i = 0; i &lt; G.vexnum;i++) {<pre><code>  for (int j = 0; j &amp;lt; G.vexnum;j++) &#123;      G.arcs[i][j] = 0;  &#125;</code></pre>  }<br>  // 构造邻接矩阵<br>  for (int k = 0; k &lt; G.arcnum;k++) {<pre><code>  cout &amp;lt;&amp;lt; &amp;quot;请输入每条边所依附的顶点：&amp;quot; &amp;lt;&amp;lt; endl;  char v1, v2;  int w = 1; //一条边所依附的顶点和权值  cin &amp;gt;&amp;gt; v1 &amp;gt;&amp;gt; v2;  int i = LocateVex(G, v1);  int j = LocateVex(G, v2);  G.arcs[i][j] = w;  G.arcs[j][i] = w;</code></pre>  }<br>}</li></ul><p>/**</p><ul><li>打印输出图</li><li>/<br>void Display(AMGraph &amp;G) {<br>  for (int i = 0; i &lt; G.vexnum;i++) {<pre><code>  for (int j = 0; j &amp;lt; G.vexnum;j++) &#123;      cout &amp;lt;&amp;lt; G.arcs[i][j] &amp;lt;&amp;lt; &amp;quot; &amp;quot;;  &#125;  cout &amp;lt;&amp;lt; endl;</code></pre>  }<br>}</li></ul><p>//—-邻接矩阵的BFS遍历—-</p><p>bool visited[MVNum]; </p><p>void BFS_AM(AMGraph G, int v)<br>{//按广度优先非递归遍历连通图G<br>    cout&lt;&lt;v;<br>    visited[v] = true; //访问第v个顶点，并置访问标志数组相应分量值为true<br>    queue&lt;int&gt; Q;<br>    Q.push(v);<br>    while(!Q.empty())<br>    {<br>        int u = Q.front(); //队头元素出队并置为u<br>        Q.pop();<br>        for(int w = 0; w &lt; G.vexnum; w++)<br>            if((G.arcs[u][w] != 0) &amp;&amp; (!visited[w])) //G.arcs[v][w] != 0表示w是v的邻接点，!visited[w]表示未访问到                                            //w为u的尚未访问的邻接顶点<br>            {<br>                cout&lt;&lt;w;<br>                visited[w] = true; //访问w，并置访问标志数组相应分量值为true<br>                Q.push(w); //w进队<br>            }<br>    }<br>}</p><p>void BFSTraverse(AMGraph &amp;G) {<br>    //访问标志数组初始化<br>    for(int v = 0; v &lt; G.vexnum; v++)<br>        visited[v] = false;<br>    //循环调用BFS<br>    for(int v = 0; v &lt; G.vexnum; v++)<br>        if(!visited[v])<br>            BFS_AM(G, v); //对尚未访问的顶点调用BFS<br>}</p><p>int main() {<br>    AMGraph test;<br>    CreateUDN(test);<br>    Display(test);<br>    // DFSTraverse(test);<br>    BFSTraverse(test);<br>    return 0;<br>}</p><p></code></pre></p><h3 id="1RjxQ"><span class="ne-text">邻接表的BFS代码</span></h3><p id="19d60bf6aae1fc1f2364707c8a4a32c7" class="ne-p"><span class="ne-text">还用和DFS一样的例子</span></p><p id="2f63b2855bb2a7ced47b120060177ab5" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1621339344717-55530db9-253b-451d-af57-b591ff17353e.png" width="417" id="I73u9" class="ne-image"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1621390194148-da12a2e4-1f85-491b-9e53-3848ac4e4a4c.png" width="167" id="iul50" class="ne-image"></p><p id="5b8a5022ed1fcec1eef4bd087d6293fa" class="ne-p"><br></p><p id="44e1f9ec1603ae99eb545fd108578a1c" class="ne-p"><br></p><pre><code>#include &lt;bits/stdc++.h&gt;using namespace std;<p>#define MVNum 100<br>#define MaxInt 32767</p><p>typedef char VerTexType;<br>typedef int OtherInfo;</p><p>/**</p><ul><li>邻接表的bfs代码</li><li>/</li></ul><p>/**</p><ul><li>存储结构</li><li>/<br>typedef struct ArcNode &#123;  //边结点<br>  int adjvex;  //该边所指向的结点的位置<br>  struct ArcNode *nextarc; //指向下一条边的指针<br>  OtherInfo info;   //和边相关的其他信息<br>&#125;ArcNode;</li></ul><p>typedef struct VNode &#123;   //顶点信息<br>    VerTexType data;  //数据域，存放顶点vi的名称或其他有关信息<br>    ArcNode *firstarc;  //指向第一条依附该顶点的边的指针<br>&#125;VNode, AdjList[MVNum]; //AdjList表示邻接表的类型</p><p>typedef struct &#123;<br>    AdjList vertices;<br>    int vexnum, arcnum; //图当前的顶点数和边数<br>&#125;ALGraph; //邻接表（Adjacency List）</p><p>/**</p><ul><li>找到v顶点在图的顶点数组中的位置</li><li>/<br>int LocateVex(ALGraph &amp;G, char v) &#123;<br>  for (int i = 0; i &lt; G.vexnum;i++) &#123;<pre><code>  if (v == G.vertices[i].data) &#123;      return i;  &#125;</code></pre>  }<br>}</li></ul><p>/**</p><ul><li>邻接表创建无向图</li><li>/<br>void CreateUDG(ALGraph &amp;G) {<br>  cout &lt;&lt; &quot;请输入顶点数和边数：&quot; &lt;&lt; endl;<br>  cin &gt;&gt; G.vexnum &gt;&gt; G.arcnum; // 邻接表的顶点数和边数<br>  // 初始化顶点数组<br>  for (int i = 0; i &lt; G.vexnum;i++) {<pre><code>  cin &amp;gt;&amp;gt; G.vertices[i].data; // 初始化顶点数组里面的结点data  G.vertices[i].firstarc = NULL; // 初始化顶点数组里面的结点next域</code></pre>  }<br>  // 初始化所有的边<br>  for (int k = 0; k &lt; G.arcnum;k++) {<pre><code>  char v1, v2;  cout &amp;lt;&amp;lt; &amp;quot;请输入每条边所依附的顶点：&amp;quot; &amp;lt;&amp;lt; endl;  cin &amp;gt;&amp;gt; v1 &amp;gt;&amp;gt; v2;  int i = LocateVex(G, v1); // 找到v1在顶点数组的下标  int j = LocateVex(G, v2); // 找到v2在顶点数组的下标  // 下面建立p1和p2是因为无向图，如果是有向图就没必要了只需要p1  // 前插  ArcNode *p1 = new ArcNode;  p1-&amp;gt;adjvex = j;  p1-&amp;gt;nextarc = G.vertices[i].firstarc;  G.vertices[i].firstarc = p1;  ArcNode *p2 = new ArcNode;  p2-&amp;gt;adjvex = i;  p2-&amp;gt;nextarc = G.vertices[j].firstarc;  G.vertices[j].firstarc = p2;</code></pre>  }<br>}</li></ul><p>/**</p><ul><li>打印输出图</li><li>/<br>void Display(ALGraph &amp;G) {<br>  for (int i = 0; i &lt; G.vexnum;i++) {<pre><code>  cout &amp;lt;&amp;lt; &amp;quot;结点&amp;quot; &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &amp;quot;：&amp;quot;;  // 复制选中的节点数组中的结点  VNode p;  p = G.vertices[i];  if (p.firstarc != NULL)&#123;      ArcNode *temp;      temp = G.vertices[i].firstarc;      while (temp != NULL) &#123;          cout &amp;lt;&amp;lt; temp-&amp;gt;adjvex&amp;lt;&amp;lt;&amp;quot; &amp;quot;;          temp = temp-&amp;gt;nextarc;      &#125;      cout &amp;lt;&amp;lt; &amp;quot;\n&amp;quot;;  &#125;</code></pre>  }<br>}</li></ul><p>//—-邻接表的BFS遍历—-</p><p>bool visited[MVNum];</p><p>int FirstAdjvex(ALGraph&amp; G, int u)<br>{<br>    int w = G.vertices[u].firstarc-&gt;adjvex;<br>    return w;<br>}<br>int NextAdjVex(ALGraph&amp; G, int u, int w)<br>{<br>    ArcNode *temp = G.vertices[u].firstarc;<br>    while (temp-&gt;adjvex != w)<br>    {<br>        temp = temp-&gt;nextarc;<br>    }<br>    if (temp-&gt;nextarc)<br>        return temp-&gt;nextarc-&gt;adjvex;<br>    else<br>        return -1;<br>    delete temp;<br>}<br>void BFS_AL(ALGraph&amp; G, int v){<br>    cout &lt;&lt; v;<br>    visited[v] = true;<br>    queue&lt;int&gt; Q;<br>    Q.push(v);<br>    int u = v;<br>    while (!Q.empty()){<br>        u = Q.front();<br>        Q.pop();<br>        for (int w = FirstAdjvex(G, u); w &gt;= 0; w = NextAdjVex(G, u, w)){<br>            if (!visited[w]){<br>                cout &lt;&lt;w;<br>                visited[w] = true;<br>                Q.push(w);<br>            }<br>        }<br>    }<br>}</p><p>void BFSTraverse(ALGraph &amp;G) {<br>    //访问标志数组初始化<br>    for(int v = 0; v &lt; G.vexnum; v++)<br>        visited[v] = false;<br>    //循环调用BFS<br>    for(int v = 0; v &lt; G.vexnum; v++)<br>        if(!visited[v])<br>            BFS_AL(G, v); //对尚未访问的顶点调用BFS<br>}</p><p>int main() {<br>    ALGraph test;<br>    CreateUDG(test);<br>    Display(test);<br>    BFSTraverse(test);<br>}<br></code></pre></p><p id="c606f86cc011bbd8daff4fdf8fde78ee" class="ne-p"><span class="ne-text"></span></p><div data-type="danger" class="ne-alert"><p id="0ef6670727161ceae2b2fd7611579ede" class="ne-p"><span class="ne-text">【插眼】为啥我写的一个函数不需要队列也可以？？？直接将顶点数组的一个元素后面接的链表遍历不就好了，然后再遍历标志数组元素值部位true的不就好了。。。为啥要压队列呀？</span></p><p id="40e16d77d4f0ef5fa0dd607f4ef45ee1" class="ne-p"><span class="ne-text">莫不是哪里有隐藏的bug，插个眼！！！</span></p></div><p id="e6f8995f72a0e332e6921816bb8d07b0" class="ne-p"><span class="ne-text"></span></p><p id="410e780ff2dc9b2b7265d7357bed6936" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/gif/1484158/1621340205400-d534997e-4b20-4f0e-8db6-4a91e39c68b6.gif" width="218" id="Ivn4n" class="ne-image"></p><p id="87461184d6165e71f83ee3ca2c47cee8" class="ne-p"><span class="ne-text"></span></p><div data-type="success" class="ne-alert"><p id="4555a876fb667c46816df66773c5e6e1" class="ne-p"><span class="ne-text">【拔眼】这样是一种特殊情况，只适合图的各个结点是按照层次标号的，并且放入标志数组也是按照顺序放入的……</span></p></div><p id="1cf117f18c823349567e5d7b36a5ff7b" class="ne-p"><br></p><p id="0f6e52a1f536ea9359c2494c19ca0529" class="ne-p"><span class="ne-text">插眼代码如下：</span></p><pre><code>void BFS_AL(ALGraph &amp;G, int v)&#123;//按广度优先非递归遍历连通图G    cout&lt;&lt;v;    visited[v] = true;    //访问第v个顶点，并置访问标志数组相应分量值为true    ArcNode *p;    p = G.vertices[v].firstarc;    if (p != NULL) &#123;        while(p != NULL) &#123;            if (!visited[p-&gt;adjvex])&#123;                cout &lt;&lt; p-&gt;adjvex;            &#125;            visited[p-&gt;adjvex] = true;            p = p-&gt;nextarc;        &#125;    &#125;&#125;</code></pre><p id="ae0f5d621f99ca5480d74bece56a5520" class="ne-p"><span class="ne-text"></span></p></div>]]></content>
      
      
      <categories>
          
          <category> 计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 📉图结构：无向图-有向图 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>图的术语、存储、应用综述</title>
      <link href="/blog/gqpli5/"/>
      <url>/blog/gqpli5/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="a20d224c568e48b9d67847a2c66a8c01_p_0" class="ne-p"><span class="ne-text">前言：</span><strong><span class="ne-text">数据结构一般就四种关系：集合、线性、树、图</span></strong><span class="ne-text">。这篇文章打算对图这类数据结构做一个概览。先介绍图的一些术语（复制粘贴：））；然后讲解一下图的各种存储形式；最后把图的应用记录一下，具体应用算法放在算法分类里面。</span></p><p id="u15a4556b" class="ne-p"><span class="ne-text"></span></p><h2 id="Xftp7"><span class="ne-text">一、图的一些术语</span></h2><p id="u7b8fcc5d" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1621256644397-9e2a9a9a-c3f9-4bfe-af9d-d3eec44c16b2.png" width="499" id="ue0b15b96" class="ne-image"></p><p id="u054df83b" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1621256670453-caccc927-2510-4119-9452-a588b6f590e5.png" width="476" id="u1e1a40e2" class="ne-image"></p><p id="u5c8e2bbc" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1621256694543-32b41537-3bc7-4515-b8e9-eb56b026d2a7.png" width="470" id="uee62fe0a" class="ne-image"></p><h2 id="YcmB4"><span class="ne-text">二、图存储</span></h2><h3 id="bKChi"><span class="ne-text">邻接矩阵</span></h3><div data-type="info" class="ne-alert"><p id="04fc687e04e1d5533771232c89922a29" class="ne-p"><span class="ne-text">创建无向网</span></p></div><p id="u7562b828" class="ne-p"><br></p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;<p>#define MVNum 100<br>#define MaxInt 32767</p><p>typedef char VerTexType;<br>typedef int ArcType;</p><p>/**</p><ul><li>邻接矩阵存储形式</li><li>/<br>typedef struct &#123;<br>  /* data */<br>  VerTexType vexs[MVNum]; //顶点表<br>  ArcType arcs[MVNum][MVNum]; //邻接矩阵<br>  int vexnum, arcnum; //图的当前顶点和边数<br>&#125;AMGraph;</li></ul><p>/**</p><ul><li>确定v在G中的位置，即顶点数组的下标</li><li>/<br>int LocateVex(AMGraph &amp;G, char v) &#123;<br>  for (int i = 0; i &lt; G.vexnum;i++) &#123;<pre><code>  if (v == G.vexs[i])&#123;      return i;  &#125;</code></pre>  }<br>}</li></ul><p>/**</p><ul><li>创建无向网</li><li>如果创建无向图   </li><li>/<br>void CreateUDN(AMGraph &amp;G) {<br>  // 采用邻接矩阵表示法，创建无向图G<br>  cout &lt;&lt; &quot;请输入顶点数和边数：&quot; &lt;&lt; endl;<br>  cin &gt;&gt; G.vexnum &gt;&gt; G.arcnum; //输入顶点数和边数<br>  // 初始化顶点<br>  for (int i = 0; i &lt; G.vexnum;i++){<pre><code>  cout &amp;lt;&amp;lt; &amp;quot;请输入第&amp;quot; &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &amp;quot;个顶点值&amp;quot; &amp;lt;&amp;lt; endl;  cin &amp;gt;&amp;gt; G.vexs[i];</code></pre>  }<br>  // 初始化邻接矩阵的边的权值为最大值<br>  for (int i = 0; i &lt; G.vexnum;i++) {<pre><code>  for (int j = 0; j &amp;lt; G.vexnum;j++) &#123;      G.arcs[i][j] = MaxInt;  &#125;</code></pre>  }<br>  // 构造邻接矩阵<br>  for (int k = 0; k &lt; G.arcnum;k++) {<pre><code>  cout &amp;lt;&amp;lt; &amp;quot;请输入每条边所依附的顶点和权值：&amp;quot; &amp;lt;&amp;lt; endl;  char v1, v2;  int w; //一条边所依附的顶点和权值  cin &amp;gt;&amp;gt; v1 &amp;gt;&amp;gt; v2 &amp;gt;&amp;gt; w;  int i = LocateVex(G, v1);  int j = LocateVex(G, v2);  G.arcs[i][j] = w;  G.arcs[j][i] = w;</code></pre>  }<br>}</li></ul><p>void Display(AMGraph &amp;G) {<br>    for (int i = 0; i &lt; G.vexnum;i++) {<br>        for (int j = 0; j &lt; G.vexnum;j++) {<br>            cout &lt;&lt; G.arcs[i][j] &lt;&lt; &quot; &quot;;<br>        }<br>        cout &lt;&lt; endl;<br>    }<br>}</p><p>int main() {<br>    AMGraph test;<br>    // CreateUDN(test);<br>    Display(test);<br>}<br></code></pre></p><p id="u449d1a79" class="ne-p"><br></p><div data-type="tips" class="ne-alert"><p id="ubfd95f3b" class="ne-p"><span class="ne-text">创建无向图</span></p></div><p id="ue2d1f836" class="ne-p"><span class="ne-text">对</span><code class="ne-code"><span class="ne-text">CreateUDN</span></code><span class="ne-text"> 进行处理：</span></p><ul class="ne-ul"><li id="u86393495"><span class="ne-text">G.arcs[i][j] = MaxInt;改为G.arcs[i][j] = 0;</span></li><li id="uf0d4b0c7"><span class="ne-text">将w改为常量1即可  </span></li></ul><p id="ubf2f1771" class="ne-p"><br></p><div data-type="tips" class="ne-alert"><p id="ud4631bb3" class="ne-p"><span class="ne-text">创建有向网</span></p></div><p id="u6d3051a6" class="ne-p"><span class="ne-text">对</span><code class="ne-code"><span class="ne-text">CreateUDN</span></code><span class="ne-text"> 进行处理：</span></p><ul class="ne-ul"><li id="ua516c49e"><span class="ne-text">删除G.arcs[j][i] = w;</span></li></ul><p id="u46ec0f2b" class="ne-p"><br></p><div data-type="tips" class="ne-alert"><p id="ub07dff75" class="ne-p"><span class="ne-text">创建有向图</span></p></div><p id="ua2fdba0d" class="ne-p"><span class="ne-text">对</span><code class="ne-code"><span class="ne-text">CreateUDN</span></code><span class="ne-text"> 进行处理：</span></p><ul class="ne-ul"><li id="u13aeacb4"><span class="ne-text">删除G.arcs[j][i] = w;</span></li></ul><h3 id="Au8am"><span class="ne-text">邻接表</span></h3><pre><code>#include &lt;bits/stdc++.h&gt;using namespace std;<p>#define MVNum 100<br>#define MaxInt 32767</p><p>typedef char VerTexType;<br>typedef int OtherInfo;</p><p>/**</p><ul><li>邻接表存储</li><li>/</li></ul><p>/**</p><ul><li>存储结构</li><li>/<br>typedef struct ArcNode &#123;                      //边结点<br>  int adjvex;                             //该边所指向的结点的位置<br>  struct ArcNode *nextarc;                //指向下一条边的指针<br>  OtherInfo info;                         //和边相关的其他信息<br>&#125;ArcNode;</li></ul><p>typedef struct VNode &#123;                        //顶点信息<br>    VerTexType data;                        //数据域，存放顶点vi的名称或其他有关信息<br>    ArcNode *firstarc;                      //指向第一条依附该顶点的边的指针<br>&#125;VNode, AdjList[MVNum];                     //AdjList表示邻接表的类型</p><p>typedef struct &#123;<br>    AdjList vertices;<br>    int vexnum, arcnum;                     //图当前的顶点数和边数<br>&#125;ALGragh;                                   //邻接表（Adjacency List）</p><p>/**</p><ul><li>找到v顶点在图中的位置</li><li>/<br>int LocateVex(ALGragh &amp;G, char v) &#123;<br>  for (int i = 0; i &lt; G.vexnum;i++) &#123;<pre><code>  if (v == G.vertices[i].data) &#123;      return i;  &#125;</code></pre>  }<br>}</li></ul><p>/**</p><ul><li>邻接表创建无向图</li><li>/<br>void CreateUDG(ALGragh &amp;G) {<br>  cin &gt;&gt; G.vexnum &gt;&gt; G.arcnum; // 邻接表的顶点数和边数<br>  for (int i = 0; i &lt; G.vexnum;i++) {<pre><code>  cin &amp;gt;&amp;gt; G.vertices[i].data;  G.vertices[i].firstarc = NULL;</code></pre>  }  for (int k = 0; k &lt; G.arcnum;k++) {<pre><code>  char v1, v2;  cin &amp;gt;&amp;gt; v1 &amp;gt;&amp;gt; v2;  int i = LocateVex(G, v1);  int j = LocateVex(G, v2);  ArcNode *p1 = new ArcNode;  p1-&amp;gt;adjvex = j;  p1-&amp;gt;nextarc = G.vertices[i].firstarc;  G.vertices[i].firstarc = p1;  ArcNode *p2 = new ArcNode;  p2-&amp;gt;adjvex = i;  p2-&amp;gt;nextarc = G.vertices[j].firstarc;  G.vertices[j].firstarc = p1;</code></pre>  }<br>}<br></code></pre><h3 id="leRQZ"><span class="ne-text">有向图：十字链表存储</span></h3><pre><code>#include &lt;bits/stdc++.h&gt;using namespace std;typedef int Status;#define OK 1;</li></ul><p>//—-有向图的十字链表储存表示—-<br>#define MAX_VERTEX_NUM 20<br>typedef char VerTexType;<br>typedef int InfoType;<br>typedef struct ArcBox<br>&#123;<br>    int tailvex, headvex;                   //该弧的头尾和头顶点的位置<br>    struct ArcBox *hlink, *tlink;            //分别为弧头相同和弧尾相同的链域<br>    InfoType *info;                         //该弧相关信息的指针<br>&#125;ArcBox;</p><p>typedef struct VexNode<br>&#123;<br>    VerTexType data;<br>    ArcBox *firstin, *firstout;             //分别指向该顶点的第一项入弧和出弧<br>&#125;VexNode;</p><p>typedef struct<br>&#123;<br>    VexNode xlist[MAX_VERTEX_NUM];          //表头向量<br>    int vexnum, arcnum;                     //有向图的当前顶点数和弧数<br>&#125;OLGraph;                                   //十字链表（Orthogonal List）</p><p></code></pre></p><h3 id="vsryl"><span class="ne-text">无向图：邻接多重表存储</span></h3><pre><code>#include &lt;bits/stdc++.h&gt;using namespace std;typedef int Status;#define OK 1;<p>//—-无向图的邻接多重表储存表示—-<br>#define MAX_VERTEX_NUM 20<br>typedef char VerTexType;<br>typedef int InfoType;</p><p>typedef enum<br>&#123;<br>    unvisited, visited                     //枚举unvisited是0，visited是1，注意没有分号<br>&#125;VisitIf;</p><p>typedef struct EBox<br>&#123;<br>    VisitIf mark;                           //访问标记<br>    int ivex, jvex;                         //该边依附的两个顶点的位置<br>    struct EBox *ilink, *jlink;             //分别指向依附这两个顶点的下一条边<br>    InfoType *info;                         //该边的信息指针<br>&#125;EBox;</p><p>typedef struct VexBox<br>&#123;<br>    VerTexType data;<br>    EBox *firstedge;                        //指向第一条依附该顶点的边<br>&#125;VexBox;</p><p>typedef struct<br>&#123;<br>    VexBox adjmulist[MAX_VERTEX_NUM];<br>    int vexnum, arcnum;                     //无向图当前的顶点数和边数<br>&#125;AMLGraph;                                  //邻接多重表(Adjacency Multilist)<br></code></pre></p><h3 id="yIN8s"><span class="ne-text">其他：边集数组</span></h3><p id="f7caa591865821073c01be60256a98d5" class="ne-p"><br></p><h3 id="EYiXl"><span class="ne-text">其他：链式前向星</span></h3><p id="37b365ee016545bff4ec27eb3f6afd50" class="ne-p"><br></p><h2 id="GJZzj"><span class="ne-text">三、图的应用</span></h2><ul class="ne-ul"><li id="1853f2f02796d7f84065b7f0802239d1"><span class="ne-text">最小生成树</span></li><li id="3d0e7c3bba57f2e22cb08454d8351cf9"><span class="ne-text">最短路径</span></li><li id="974b0e776d1250a371152cff90420be4"><span class="ne-text">环路</span></li><li id="ebe95ecfd4e0f08b0581a7cfdf5fd876"><span class="ne-text">关键路径</span></li></ul><p id="9d3c089ab3cd581998d3b22fa4c644db" class="ne-p"><br></p><p id="827d80a13d6f97ce4d10e4dcf0ed2b9a" class="ne-p"><span class="ne-text">具体这几类问题都是算法中的贪心算法所属，故将其放到算法分类里面了。</span></p><p id="88bb9f458aac1f0aa89a861c39b131f6" class="ne-p"><br></p><p id="26dd6339706b64d9f617cf5e571ec4bf" class="ne-p"><br></p><p id="4dccc396ba4ee721ad76b490e08c8486" class="ne-p"><br></p><p id="2722e61c51c854135f8ad27e4594a933" class="ne-p"><br></p><p id="a4f7ffd8a89771e03642e1dd3e60709e" class="ne-p"><br></p></div>]]></content>
      
      
      <categories>
          
          <category> 计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 📉图结构：无向图-有向图 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>『灵笼』——灵魂的牢笼</title>
      <link href="/essay/pnapfw/"/>
      <url>/essay/pnapfw/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="87ae0048a72f1bee29ddbcc5e0202b3b" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1621244428291-8f947575-4da5-4938-a3fa-09f21bed0925.png" width="1920" id="ijJPU" class="ne-image"></p><p id="af9e6b14f89909a2ad76a80c8b99faee" class="ne-p"><br></p><p id="a20d224c568e48b9d67847a2c66a8c01_p_0" class="ne-p"><span class="ne-text">看了五集，觉得剧情设定方面有浓浓的进击的巨人和Darling in the franxx这两部番那味了（去论坛看了看，果然有吐槽的…不过都在说巨人，我更加觉得和国家队的世界观很像）…但不管怎么说，</span><strong><span class="ne-text">剧情设定和画质方面在国漫里面也是可圈可点，并且，我个人认为，这部番是这么多年国漫里面最用心最花成本的一部</span></strong><span class="ne-text">～</span></p><p id="936a42ff936d7c1a50bf89c9b89d16da" class="ne-p"><br></p><p id="374184666c63eb0a7c54d62122377acf" class="ne-p"><span class="ne-text">灵笼，灵魂的牢笼，就像是巨壁</span></p><p id="u452a7683" class="ne-p"><span class="ne-text">重立体，立体机动装置（就不能叫个重装甲啥的，害</span><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1621243721740-de5b6182-0bb1-4971-95bf-1309c0fdfb1d.jpeg" width="79" id="rboSG" class="ne-image"></p><p id="udcc19708" class="ne-p"><span class="ne-text">猎荒者，调查兵团</span></p><p id="ub245810e" class="ne-p"><span class="ne-text">荷光者，宪兵团</span></p><p id="c7a73cad76fd1527d918edc112252883" class="ne-p"><span class="ne-text">……</span></p><p id="e78c7f6ff1c79e75b6edd496476b3456" class="ne-p"><br></p><p id="5f41b43f70ab381b3abcf9ff01ffd036" class="ne-p"><span class="ne-text">我之前对darling里面的是『心』这个人物，我当时的感受是整部番的点睛之笔，在世界观的角度上，拉伸高度，在灵笼这里被设定为佩妮这个角色……</span></p><p id="728fce5b4089cc37c61f73c1aac677ed" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1621244183522-a0ab8144-4141-4887-895b-a5b3e6230613.png" width="1920" id="VgAwl" class="ne-image"></p><p id="5fb20c568753e1230fc1d6e5797cc35e" class="ne-p"><br></p><p id="b2b0e7e0c4539f2d0197a340b959221c" class="ne-p"><span class="ne-text">这些说实话，感受的挺多了，用这部番里面的一个词就是——躯壳。希望后面的剧情能挖掘出作品的闪光之处～</span></p><p id="2eca8e0a0ec8ea3176a08ef390d6d713" class="ne-p"><br></p><hr id="cUmMX" class="ne-hr"><p id="400943748f0c11a5e083e3ec212e589e" class="ne-p"><span class="ne-text">EP6</span></p><p id="48776f2534cdb298e8192f61cd81f10c" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/jpg/1484158/1621262671765-0831d8b9-f8eb-4a16-acc0-1b8d622ff5b8.jpg" width="1975" id="OlIMX" class="ne-image"></p><p id="8df7dc13a99fcdda8256b823298f09ee" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/jpg/1484158/1621262686893-e61922ea-e1b5-4fa8-82ac-cabc2ef60391.jpg" width="1349" id="fQ07I" class="ne-image"></p><p id="189f2a7b38aac1e37c3c1a33380ca524" class="ne-p"><span class="ne-text">不管这个世界再怎么变，人性永远在那，就像爱情……</span></p><p id="befbd46b4767a3843e589d6e1805da04" class="ne-p"><br></p><p id="27fc0931913efab3517f903ee0a636c0" class="ne-p"><span class="ne-text">或许我在想，即便这个世界颠倒了，文明是一个全新的面貌，人性或许是那诸多不变的点之一。</span></p><p id="e0ddfdfcbc11e27cbaddd761616191e4" class="ne-p"><br></p><hr id="9yNge" class="ne-hr"><p id="43cfb880aec7af6b4d5b99387187dae2" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/jpg/1484158/1621472984542-d6010263-d430-4ab7-ac8d-4f911c4d4bf3.jpg" width="2083" id="mKa4W" class="ne-image"></p><p id="55d077335426a9183d75f8137608dde2" class="ne-p"><span class="ne-text">万万没想到系列，冉冰居然凉凉～</span></p><hr id="JHHXc" class="ne-hr"><p id="78b38bbb609e7489da4763bbac776424" class="ne-p"><span class="ne-text">终章+特别篇</span></p><p id="f9676a9ce027e8eb4f0f6f8ac9f534a5" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/jpg/1484158/1621473001235-cb79d2e3-6a7e-4556-92b4-33ea9d442010.jpg" width="1996" id="gBT7O" class="ne-image"></p><p id="b4c13366a067784ca2275dc78f63bc2a" class="ne-p"><br></p><p id="9eb8b13ef41bc89ffb62a78d2d5fca91" class="ne-p" style="text-indent: 2em"><span class="ne-text">这波用灯塔来反衬地面幸存者的存在的意义，都知道噬极兽会以人类的情感来孕育，灯塔是颁布三大法令来限制灯塔上的人的情感，以此来让灯塔幸存于这乱世，地面幸存者则是相反，情感不但不能舍弃，反而要坚守</span></p><p id="7822c0b6e9292530c1203301f4b9559a" class="ne-p"><br></p><p id="c8f38feb7a41905e44c624908c3b6642" class="ne-p" style="text-indent: 2em"><span class="ne-text">至于白月魁，直接将这部番提升到修仙境界了</span><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1622037065067-007f3642-a1e3-4f60-862b-af2e1013c8ec.jpeg" width="77" id="MR71l" class="ne-image"><span class="ne-text">，就是人类中靠修炼而成的外挂，和阿克曼一族利威尔兵长是一类人，人类最强。</span></p><p id="b5766f96b10e63a8f42dde3c5f7e6e90" class="ne-p"><br></p><p id="312a046a99097258c6a8ea393340ac79" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/jpg/1484158/1621473476256-6440f355-2230-47d7-9a2d-cc3a92afa850.jpg" width="2400" id="TxJXz" class="ne-image"></p><p id="9c1614cb08b3160c581649ba8b86aa00" class="ne-p"><br></p><p id="b54a74b17960bed47ccfa51e84751b7b" class="ne-p"><br></p><p id="2756fb0549ca456400a599e1f6287693" class="ne-p"><br></p><p id="f637daffca44c515b3cd4e2e1d12b591" class="ne-p"><br></p><p id="52495223c959fec8eafe0d63e412feb8" class="ne-p"><br></p><p id="6f4edc684874a8e74dc2fb283776fedd" class="ne-p"><br></p><p id="4d9958565eaea1c075296feb05ee05f9" class="ne-p"><br></p><p id="cd0243f05e57869e3766d3b2a6a0b44a" class="ne-p"><br></p><p id="b19d4dde4f88ee6fb0fc5ed772107461" class="ne-p"><br></p><p id="d6f84594942f8d96354473ed3b7f5450" class="ne-p"><br></p><p id="5447c9d736c76beff2cf33f6ae3f3956" class="ne-p"><br></p><p id="7e8b0f2d040e7447cc79790df266eccf" class="ne-p"><br></p><p id="cfd4f14294417abe856a51737d9fd334" class="ne-p"><br></p></div>]]></content>
      
      
      <categories>
          
          <category> 影视 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[转]竞赛常用STL容器详解</title>
      <link href="/blog/porzdi/"/>
      <url>/blog/porzdi/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><div class="ne-quote"><p id="b174f416224bd7d428d5952653d786f8" class="ne-p"><span class="ne-text">大部分文字内容转载自：</span><a href="https://blog.csdn.net/weixin_43844677/article/details/104902417" data-href="https://blog.csdn.net/weixin_43844677/article/details/104902417" target="_blank" class="ne-link"><span class="ne-text">竞赛常用STL容器详解</span></a></p><p id="u869b6a94" class="ne-p"><span class="ne-text">部分内容个人修改补充。</span></p></div><p id="e5c401f15f8c481887594e6e60a99c11" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1626175209711-5b013be3-5942-4a0a-b9ce-529a73668d94.jpeg" width="360" id="rFa1j" class="ne-image"></p><h2 id="FsIvq"><span class="ne-text">一、 概述</span></h2><p id="9325e5cb1f074bb346e4d4351260b24c" class="ne-p"><span class="ne-text">在算法竞赛中，使用C++语言的占很大比例，而几乎没有人使用C语言，其中核心的原因就是C++包含STL容器库，能够极大地减少选手在赛场上为了一些基础数据结构而浪费的时间。诚然，花一两分钟实现一个stack、queue甚至priority_queue都不是什么大问题，但如果需要实现BBST（Balanced Binary Search Tree）的情况呢？如果可以的话，我们总是希望不要手写红黑树、动态数组的。那么STL容器库的出现就像雪中送炭一样了。它们覆盖了竞赛中最基础的需要（张昆玮树、主席树这种东西肯定不会包含的），让你在面对非数据结构题的时候能够不因数据结构部分的代码而分心。</span></p><p id="46bd6ff3ccf301afd671dccb15832982" class="ne-p"><span class="ne-text"></span></p><p id="97da7fcd9472789cd12c279999442d4a" class="ne-p"><span class="ne-text">关于STL容器的相关问题非常细，经常成为面试中的考题，这里我们仅讨论一些必须的内容，然后只谈论在竞赛中的具体使用。</span></p><p id="551c7c831a7c03907effea19f85d8815" class="ne-p"><span class="ne-text"></span></p><p id="748f546e2cfa7dea162504441128383a" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1621221298404-a6bf5daf-fd5b-4504-a4d0-f80b17dc5899.png" width="1778" id="Rv9rY" class="ne-image"></p><p id="bc9da56b08501be44ab80c74871f3bcd" class="ne-p"><span class="ne-text">首先给出一张表格（来自cppreference）：</span></p><p id="b909ffb1c2645000a3fadf53bc7da1d2" class="ne-p"><span class="ne-text"></span></p><p id="89ffba3ee54d7d59bf99a47309fdc95d" class="ne-p"><span class="ne-text">这张表格中给出了各种容器支持的成员函数，在大多数停留在C++14和C++11版本的测试平台中，只有紫色、绿色部分是可用的。</span></p><p id="44ccc4a9adf75f8e0042b43b33fd83de" class="ne-p"><span class="ne-text"></span></p><p id="f29d38316edbbf61104ff268d8cf1503" class="ne-p"><span class="ne-text">在考察具体的容器的时候，出于竞赛中的需要，我们不会涵盖以上的全部，而是着重关注以下几点：</span></p><ol class="ne-ol"><li id="e3a45c83635d297ccda38ddb9d6dd721"><strong><span class="ne-text">随机访问</span></strong></li><li id="69bfa84b70d960e6323b085550f2cea4"><strong><span class="ne-text">插入和删除</span></strong></li><li id="59ba20d870115f04dc50335bc7c94948"><strong><span class="ne-text">端点访问</span></strong></li><li id="336e884d20f34f99decfeadc5641e490"><strong><span class="ne-text">迭代器类型（总结以上几点）</span></strong></li><li id="c498b0f5613aba11c9e457ae6c842ffd"><strong><span class="ne-text">时间复杂度</span></strong></li></ol><p id="99b0d09fab938a21cb2754647d420082" class="ne-p"><strong><span class="ne-text"></span></strong></p><p id="a3e5165a16b1bae8fdf91219d525dd61" class="ne-p"><span class="ne-text">事实上，综合以上几点，就可以得出一个容器的作用。容器的作用是由它支持的操作及其时间复杂度决定的，并不是说，容器的名字叫做set我就一定把它当作集合来用。从ADT的角度来说，</span><strong><span class="ne-text">数据结构=接口+接口的复杂度</span></strong><span class="ne-text">。而从另一个角度来看，容器内部支持的逻辑操作决定了它能够使用的迭代器类型，而这决定了外部可能存在哪些接口，因此也可以说</span><strong><span class="ne-text">数据结构=内部存储+迭代器</span></strong><span class="ne-text">。这样两种观点，能够在使用的层面加强我们对于STL容器的理解。</span></p><p id="2991cf1395bfdc1d38f67bdc19b84e7d" class="ne-p"><span class="ne-text"></span></p><p id="cf86b02f332a87d38750352809652a2f" class="ne-p"><span class="ne-text">方便起见，这里先列出一个汇总的表格，包含了竞赛中常用的几种数据结构：</span></p><p id="fc2f072711b55b1880c821933e0952cb" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1621221298080-23300f65-22c0-48b6-895a-324e3793fed5.png" width="857" id="PnAJG" class="ne-image"></p><p id="ef4077071ca1b74312af73b195c64fe0" class="ne-p"><span class="ne-text"></span></p><p id="17aab6c9586e8902c6fd2078e0858e61" class="ne-p"><span class="ne-text">这里的表格只给出了很简单的内容，本文末尾会给出两个总结性的表格，给出具体操作的函数名和时间复杂度。</span></p><p id="e40afaabd6286f809dee5c382de4cf66" class="ne-p"><span class="ne-text"></span></p><h2 id="Xuzkh"><span class="ne-text">二、 迭代器</span></h2><h3 id="xshvx"><span class="ne-text">迭代器与遍历</span></h3><p id="074397d1269d9d82ce8b72aee49ddc7b" class="ne-p"><span class="ne-text">操作一个容器，无法脱离它提供的工具——</span><strong><span class="ne-text">迭代器</span></strong><span class="ne-text">。即使没有使用过容器，我们也一定使用过最基本的方式遍历一个数组：</span></p><pre><code>for (int i = 0; i &lt;n;i++)    //......</code></pre><p id="bef551f9c032825e8f863bf429c15fd2" class="ne-p"><span class="ne-text"></span></p><p id="351c9dc6e6e7f8e8f6940e80a257906a" class="ne-p"><span class="ne-text">不严格地说，这里的”i”就可以视作一个最原始的迭代器。事实上，对于藉由它，我们可以访问一个容器内的全部内容——这就是我们所说的“遍历”，这能够让我们对内部数据进行基于元素的操作。</span></p><p id="e3d177960f3a9710f3f6e20420be6ddc" class="ne-p"><span class="ne-text"></span></p><p id="88a1bf253f2267bb88accb386ed229d7" class="ne-p"><span class="ne-text">事实上，一个真正的迭代器需要符合很多要求。STL容器所配备的迭代器都属于C++迭代器库规定的六种之一，它们是：</span></p><ol class="ne-ol"><li id="a0a508f956a7f7422c0ead00ef730792"><strong><span class="ne-text">遗留输入迭代器</span></strong></li><li id="9f854f20bfdb6d2e1286977be28fe7a4"><strong><span class="ne-text">遗留向前迭代器</span></strong></li><li id="0a72a21e2d5642f1eff31bb9d583ba50"><strong><span class="ne-text">遗留双向迭代器</span></strong></li><li id="3c95bdede059dce4c441b09a86225a2a"><strong><span class="ne-text">遗留随机访问迭代器</span></strong></li><li id="ed66347e7daafc2a005be826efaa4cfe"><strong><span class="ne-text">遗留输出迭代器</span></strong></li><li id="c5d7514d16d7b3c2dc4b549670e87ddb"><strong><span class="ne-text">遗留连续迭代器</span></strong></li></ol><p id="e20cdf4f8c8c6e24ed84a0a4f496f6c2" class="ne-p"><span class="ne-text">这些名字看起来很唬人，让我们来一点一点解释。</span></p><p id="10f96e2fae647322cc53935b4ded4772" class="ne-p"><span class="ne-text">首先，它们都是“</span><strong><span class="ne-text">遗留迭代器</span></strong><span class="ne-text">”，这意味着它们都：（以下假设i是迭代器）</span></p><ul class="ne-ul"><li id="b3a4a9484fce4dba2ca346bf763aabb9"><span class="ne-text">可</span><strong><span class="ne-text">解引用</span></strong><span class="ne-text">（*i得到元素）</span></li><li id="77ffa0ff535587adbc30033b9e4bfc29"><span class="ne-text">可</span><strong><span class="ne-text">前自增</span></strong><span class="ne-text">（++i得到下一位置）</span></li></ul><p id="6287f35ce511723066defafead41e55d" class="ne-p"><span class="ne-text">这也就是为何我们能藉由迭代器来完成遍历容器内元素的操作。</span></p><p id="bd99dd12ea8e1576f52b59606c2761d1" class="ne-p"><span class="ne-text">下面给出上文提到的六种迭代器的实际含义，虽然大多数情况下竞赛中用不到这些原理，但偶尔会有基于手动遍历的技巧性操作，这时候也许需要你对迭代器有一定的认知：</span></p><p id="97f18ee5233fecadc9d2c10b132ade08" class="ne-p"><strong><span class="ne-text">遗留输入迭代器：</span></strong></p><p id="3ecf3a7b5df6db5f69c312daffa5ce32" class="ne-p"><span class="ne-text">在</span><strong><span class="ne-text">遗留迭代器</span></strong><span class="ne-text">的基础上，</span></p><ul class="ne-ul"><li id="04a52d75fbd1399b41b2a89b1046b15e"><span class="ne-text">可</span><strong><span class="ne-text">不等比较</span></strong><span class="ne-text">（i!=j有定义）</span></li><li id="003b47a543740051e9a5b4afe8408af3"><span class="ne-text">可</span><strong><span class="ne-text">后自增</span></strong><span class="ne-text">（i++有定义）</span></li></ul><p id="ef8ef9ebbdec97b920d878dc57c1fcdc" class="ne-p"><span class="ne-text">但：**自增后，先前值可能失效。**也就是说，当你访问第1个元素时，可能无法通过这个迭代器的拷贝访问第0个元素。</span></p><p id="2c669df7fb5c7ea71f8d787d0626292c" class="ne-p"><strong><span class="ne-text">遗留向前迭代器：</span></strong></p><p id="549b249d7366005f6663910166b92d71" class="ne-p"><span class="ne-text">在</span><strong><span class="ne-text">遗留输入迭代器</span></strong><span class="ne-text">的基础上，</span></p><ul class="ne-ul"><li id="2148cf7e33ed970a529e0971a7fa763a"><strong><span class="ne-text">自增后保证先前值不失效。</span></strong></li></ul><p id="a7efa65b859d944ac6cfb118f9a01a0c" class="ne-p"><strong><span class="ne-text">遗留双向迭代器：</span></strong></p><p id="27fa68639706c4eef6b49d6cf96de5ef" class="ne-p"><span class="ne-text">在</span><strong><span class="ne-text">遗留向前迭代器</span></strong><span class="ne-text">的基础上，</span></p><ul class="ne-ul"><li id="3062dfba061363d314e7404df219a293"><span class="ne-text">可</span><strong><span class="ne-text">前自减</span></strong><span class="ne-text">（–i有定义）</span></li><li id="4407856a0ce5d1429e52ef999251e8e2"><span class="ne-text">可</span><strong><span class="ne-text">后自减</span></strong><span class="ne-text">（i–有定义）</span></li></ul><p id="f981fa9738a21332add68b7616f568af" class="ne-p"><strong><span class="ne-text">遗留随机访问迭代器：</span></strong></p><p id="6d11fae78ee405d0e50b53a45c33579e" class="ne-p"><span class="ne-text">在</span><strong><span class="ne-text">遗留双向迭代器</span></strong><span class="ne-text">的基础上，</span></p><ul class="ne-ul"><li id="60fd749ae9531b0f615604e6af9edf5b"><span class="ne-text">有</span><strong><span class="ne-text">下标</span></strong><span class="ne-text">运算符（i[n]有定义）</span></li><li id="7189f291e63823ee6538353ceaa4d920"><span class="ne-text">有</span><strong><span class="ne-text">比较</span></strong><span class="ne-text">运算符（&gt;、&lt;、&gt;=、&lt;=有定义）</span></li><li id="a86c22e9b5a39cbca0f00050bd5d264a"><span class="ne-text">可按</span><strong><span class="ne-text">增量移动</span></strong><span class="ne-text">（+、-、+=、-=有定义）</span></li></ul><p id="00031be3672384a249e470a5a5805156" class="ne-p"><span class="ne-text">且：</span><strong><span class="ne-text">迭代器移动只耗费常数时间。</span></strong></p><p id="b1c9abdd70ae2a110b1dab135c960e37" class="ne-p"><em><span class="ne-text">若以上迭代器满足</span></em><strong><em><span class="ne-text">遗留输出迭代器</span></em></strong><em><span class="ne-text">的标准，那么称它们是“可变迭代器”。</span></em></p><p id="ad9fae9b279b18048b52b3558422d6ae" class="ne-p"><strong><span class="ne-text">遗留输出迭代器：</span></strong></p><p id="220355b273fa9687e963738aab9533ca" class="ne-p"><span class="ne-text">在</span><strong><span class="ne-text">遗留迭代器</span></strong><span class="ne-text">的基础上：</span></p><ul class="ne-ul"><li id="e95b5efedf1430da2c01bcbcc61a83ca"><span class="ne-text">可</span><strong><span class="ne-text">赋值</span></strong><span class="ne-text">（*i=something有定义）</span></li><li id="82be7c34f1fafff53248888851e35de9"><span class="ne-text">可</span><strong><span class="ne-text">后自增</span></strong></li></ul><p id="7b6ba705789cd5611d237dab96a66335" class="ne-p"><em><span class="ne-text">若以上迭代器满足</span></em><strong><em><span class="ne-text">遗留连续迭代器</span></em></strong><em><span class="ne-text">的标准，那么称它们是“连续迭代器”。</span></em></p><p id="f6407a21d18d62bfede55dbdce19796b" class="ne-p"><strong><span class="ne-text">遗留连续迭代器：</span></strong></p><p id="966927bf45388048f32c753c5dc97e02" class="ne-p"><span class="ne-text">在</span><strong><span class="ne-text">遗留迭代器</span></strong><span class="ne-text">的基础上：</span></p><ul class="ne-ul"><li id="295aa1c5a2c7abf01d1c8a89fd4a2a34"><span class="ne-text">逻辑相邻元素在内存中也相邻，</span></li><li id="5505a0d35f145ed1be5b9704e1c4021d"><span class="ne-text">即：</span><code class="ne-code"><span class="ne-text">*(i + n)</span></code><span class="ne-text"> 等价于 </span><code class="ne-code"><span class="ne-text">*(std::addressof(*i) + n)</span></code></li></ul><p id="582a156458fbccb1ec63aa622e34b058" class="ne-p"><span class="ne-text">以上涉及的运算，不仅需要定义，并且需要符合功能要求。同时，部分操作有特例存在。例如，即使迭代器可解引用，也无法对尾后迭代器或孤立迭代器解引用。</span></p><p id="e99c167444924f0b4082b4bb007fd382" class="ne-p"><span class="ne-text">那么，如果知道某个容器的迭代器类型，对比一下它们支持的操作，你就能知道自己的一些奇思妙想能否实现了。例如：两头向中间访问、一次跳过多个元素、多个迭代器同时访问……</span></p><p id="7aeb1f2b98528f9ea4648524c956fa92" class="ne-p"><span class="ne-text">那么，在复杂的环境下，例如访问的同时涉及插入和删除，这些操作还能按照我的意图运行吗？这就是我们要讨论的下一个问题了。如果说以上内容更偏向于实务开发，那么这个问题在竞赛中就更加常见了，它就是“迭代器失效”问题。</span></p><h3 id="UeT7t"><span class="ne-text">迭代器失效</span></h3><p id="47f4069d0f6796748f6ff291a6db7aa7" class="ne-p"><span class="ne-text">容器的一些操作会使得先前声明的迭代器失去它应有的作用，这种限制来自于容器底层的实现。例如在vector中，即使在尾部插入一个新元素也可能因为导致空间达到临界值而使得数据全部被移动到新空间，从而使全部迭代器失效。</span></p><p id="495c9d23522fa234f80177a2bacdeeac" class="ne-p"><span class="ne-text"></span></p><p id="90bb6dd65a4b4938a8261adeb97d1a18" class="ne-p"><span class="ne-text">大体来说，删除总会使得迭代器失效，而插入有些情况会使其失效。具体的情形见下表：（同样来自cppreference）</span></p><p id="e337efacc6b6c67eddb05a168c1b18d4" class="ne-p"><span class="ne-text"></span></p><p id="e489e1368915645afa8777bf8467f447" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1621221298154-92c7bf87-74b3-4fd5-9f62-d7ab6e5aa25b.png" width="982" id="N6O99" class="ne-image"></p><p id="d205f6a916045701debe1e97841744d1" class="ne-p"><span class="ne-text"></span></p><p id="6cd9b94d46196c0f14adc7af20025543" class="ne-p"><span class="ne-text">除此之外，尾后迭代器有一些特殊情形需要考虑，例如vector的尾后迭代器总是会被非法化、除了删除首元素外的修改操作都会非法化deque的尾后迭代器，等等。</span></p><h3 id="xSEPM"><span class="ne-text">尾后迭代器</span></h3><p id="f647c83d4c6e493b67419f5f8160b665" class="ne-p"><span class="ne-text">另一个要注意的点是，一般来说一个容器的begin()返回的是指向容器内首个元素的迭代器，而end()指向的却不是尾部元素，而是</span><strong><span class="ne-text">尾后</span></strong><span class="ne-text">——一个不存在的元素，我们也常常把这种位置称为“哨兵”。这一点好像恰好和其他参数为一个区间的函数，如sort(), substr()等，对应了起来——似乎编程中所有涉及区间的操作，都是使用左开右闭区间来表示的——也就是说，end()表示尾后。这是为什么呢？</span></p><p id="3e39e9ba14e44104b73621d2592b67c5" class="ne-p"><span class="ne-text">考虑对一个具有</span><strong><span class="ne-text">普通遗留迭代器</span></strong><span class="ne-text">的容器进行迭代，应当怎么写呢？似乎很简单：</span></p><pre><code>for (auto i = x.begin(); i != x.end(); i++)</code></pre><p id="f50449d8125daae28412eb40bda2df91" class="ne-p"><span class="ne-text">看到这里，你应当已经明白了：大多数容器不具有遗留连续迭代器的性质，那就不存在像</span><code class="ne-code"><span class="ne-text">i &lt; x.end()</span></code><span class="ne-text">这种操作，因此无法像迭代一个数组一样以一个偏序比较作为条件，那么就必须有一个哨兵作为实际可以访问到的截止位，这个哨兵就是end()。</span></p><h3 id="T5IXM"><span class="ne-text">其他补充</span></h3><p id="3e5bcbf022fee73947a9cebc6bbbd284" class="ne-p"><span class="ne-text">在自写模板的时候，需要加上关键字</span><code class="ne-code"><span class="ne-text">typename</span></code></p><pre><code>typename list&lt;T&gt;::iterator p;</code></pre><h2 id="5nJdZ"><span class="ne-text">三、容器</span></h2><h3 id="EIqvD"><span class="ne-text">Vector</span></h3><h4 id="FLeAQ"><span class="ne-text">总览</span></h4><p id="8da9b17972578457ab1b8ac68711eab1" class="ne-p"><span class="ne-text">那么，我们就开始讲每个具体的容器了。在各节中，我们会依次介绍每个容器的用途、迭代器类型、插查删操作及其复杂度，有必要的时候，我们还会介绍一些其他的小trick。</span></p><p id="90864959b211b66ce9b82c10490b466a" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1621221298034-6e429607-ece3-4c15-bd6a-e02efaf4d4f6.png" width="669" id="STppH" class="ne-image"></p><p id="bd5baafee5b7d487116c4d04df613fe2" class="ne-p"><span class="ne-text">我们看到，Vector与其他STL容器最大的区别就在于，只要元素不为bool类型（bool类型因内存对齐而不连续），它是唯一使用</span><strong><span class="ne-text">连续迭代器</span></strong><span class="ne-text">的，即使对于全部情况，它也符合遗留随机访问迭代器，从而支持以常数复杂度通过下标运算符随机访问。这使得我们可以直接将其作为升级版的数组使用——数组的功能全部被它继承，而它又自带了其他一些便捷的函数——因此vector又被称为 </span><strong><span class="ne-text">“动态数组”</span></strong><span class="ne-text"> 。</span></p><p id="68ba6e696a07e5feb42e1f9197e58ee8" class="ne-p"><span class="ne-text">它底层的数据结构使用的是静态数组，实现动态扩容的奥秘在于，它在每一次容量占用达到阈值时就进行一次翻倍扩容，从而保证了均摊 O ( 1 ) O(1) </span><span class="ne-text">O</span><span class="ne-text">(</span><span class="ne-text">1</span><span class="ne-text">)</span><span class="ne-text">的时间复杂度，而又能节省空间。</span></p><h4 id="1nRvr"><span class="ne-text">常见用法</span></h4><p id="40d49aa8a2ae98495eef68ae7a560d8b" class="ne-p"><span class="ne-text">在C++11中，在具有begin()和end()的范围上进行迭代，有一种简便写法，那就是</span></p><pre><code>for (auto&amp; v : container)</code></pre><p id="8f3f53ff952f027921f5bd7bc5c5d305" class="ne-p"><span class="ne-text">它等价于</span></p><pre><code>for (auto&amp; v = container.begin(); v != container.end(); v++)</code></pre><p id="f99b96a4b658ddef8216895c2cb93089" class="ne-p"><span class="ne-text">这里的auto利用了C++11的另一个特性——类型推导，这只是一个语法糖，它使我们不必写上container::iterator这一串复杂的类型，而在程序运行中与完整键入的并无区别。而auto后面加的&amp;代表v是一个左值引用，那么我们就可以通过v来修改容器中的元素。而如果我们想避免这种修改，可以去掉&amp;，这时v就是一个右值拷贝。</span></p><p id="5ea6aa09545d180fe8500bb40dc1e3f8" class="ne-p"><span class="ne-text">以一个int类型动态数组为例，我们可以这样输出：</span></p><pre><code>vector&lt;int&gt; arr;for (auto v : arr)    cout&lt;&lt;v;</code></pre><p id="4e7db535eb1db00d7da248ffd0162de4" class="ne-p"><span class="ne-text">而读入可以这样写：</span></p><pre><code>for (int i = 1; i &lt;= n; i++)&#123;    <pre><code>cin&amp;gt;&amp;gt;temp;arr.push_back(temp);</code></pre><p>}<br></code></pre></p><p id="666266c9dbc2b7a3d18471334ffb3fbf" class="ne-p"><span class="ne-text">当然，同程序员们默认的一样，它的下标是从0开始的。</span></p><p id="c8f2191dc38184e07be9cbf4e62fd167" class="ne-p"><span class="ne-text">vector是否可以写高维数组呢？如果你经常在Leetcode上刷题，应当见过二维数组的这种写法：</span><code class="ne-code"><span class="ne-text">vector&lt;vector&lt;int&gt;&gt;</span></code><span class="ne-text">。高维数组以此类推即可。在访问上，这种写法与</span><code class="ne-code"><span class="ne-text">int arr[][]</span></code><span class="ne-text">没有任何区别。</span></p><h3 id="DGKQN"><span class="ne-text">List</span></h3><p id="1acbcecc2af052496c684194e713ae79" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1621221298094-bbd53e64-b82a-4b51-aa3a-f354b3bd7023.png" width="669" id="D1lAx" class="ne-image"></p><p id="d63f691f3f345af2bf77c6e3f79f136d" class="ne-p"><span class="ne-text">可以看到，list实际上就是一个</span><strong><span class="ne-text">双向链表</span></strong><span class="ne-text">，因此对于插入和删除的操作具有优秀的时间表现。当然也很容易想到，list是无法实现常数时间随机访问的，insert和erase看起来时间复杂度为 O ( 1 ) O(1) </span><span class="ne-text">O</span><span class="ne-text">(</span><span class="ne-text">1</span><span class="ne-text">)</span><span class="ne-text">，但在实际应用中，找到插入位置往往就需要 O ( n ) O(n) </span><span class="ne-text">O</span><span class="ne-text">(</span><span class="ne-text">n</span><span class="ne-text">)</span><span class="ne-text">的时间。</span></p><p id="d32940f3fd463a51dc7ea65729be9260" class="ne-p"><span class="ne-text">与list相似的，STL中还存在一个单向链表forward_list。由于不需要反向链，它的空间占用有所减小，不过这一点在竞赛中不怎么需要，所以那种结构了解即可。</span></p><h3 id="rolg4"><span class="ne-text">Stack</span></h3><h4 id="kAXMV"><span class="ne-text">总览</span></h4><p id="3ef016234adc4e2ac63f435d07edfb7f" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1621221298067-e4b7c1aa-ec7e-4535-a505-59440ac713db.png" width="669" id="Sfmf5" class="ne-image"></p><p id="876d6e559924ae58ddc7a67716f7c38c" class="ne-p"><span class="ne-text">相比于精心构造的数据结构，stack似乎更应当被称为一种“包装器”，它在底层实现的基础上屏蔽掉了一些功能，从而使自身表现得更像一个物理栈。对于它和queue，我们不需要多费口舌，也许这是仅有的两种我们可以自己实现而不会使代码冗长的数据结构了。但无论怎么说，有一个构造好的容器使用总是好的，它可以防止我们在底层的操作上犯一些愚蠢的错误。</span></p><h4 id="PHE4D"><span class="ne-text">常见用法</span></h4><p id="2db55f94404cd8b7f985357ba12bf50a" class="ne-p"><span class="ne-text">那么，这里就实际给出使用stack完成DFS的过程，以下是一段代码片段：</span></p><pre><code>vector&lt;int&gt; edges[N];    stack&lt;int&gt; dfs;    /*............*/    dfs.push(v0);    vis[v0] = true;    while (!dfs.empty())    &#123;    <pre><code>    bool tag = false;    int now = dfs.top();    prt.push_back(now);    for (auto v : edges[now])        if (!vis[v])        &#123;            dfs.push(v);            vis[v] = true;            tag = true;            break;        &#125;    if (!tag)        dfs.pop();&#125;</code></pre><p></code></pre></p><h3 id="55tfW"><span class="ne-text">Deque及其延伸</span></h3><h4 id="nzjq9"><span class="ne-text">Deque</span></h4><p id="2bbed1a65109b74243d276980a437a1b" class="ne-p"><span class="ne-text">虽然实际使用时很少见，但deque是很多STL容器的基础，stack和queue都由它封装而来，它也支持相当多的操作，详见下表：</span></p><p id="7c1538f25f54b9cb6eef0f1277000c7a" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1621221298045-e627f316-cc63-4992-817c-f8025c1474df.png" width="669" id="yw0ii" class="ne-image"></p><p id="e4c286b966d21b0cde6e4afb055e06d5" class="ne-p"><span class="ne-text">值得注意的是，该容器的迭代器非法化情形比较有趣，其原理也是面试题常考的内容，建议结合STL源码深入分析。</span></p><p id="50074c6f4b501f0f0b3d31f55a9f4d92" class="ne-p"><span class="ne-text">结合上表，发现它与List的区别主要在于，它能够实现常数时间随机访问，但内部插入、删除却需要线性时间，这也符合他们底层实现：链表和数组的区别，也正是这一点使得它们的迭代器一个是双向而另一个是随机访问。多进行这种思考，由</span><strong><span class="ne-text">底层实现——容器——迭代器——操作</span></strong><span class="ne-text">转为</span><strong><span class="ne-text">底层实现——迭代器——操作</span></strong><span class="ne-text">，是一名程序员获得抽象思维的重要方式。</span></p><h4 id="6rbAT"><span class="ne-text">Queue</span></h4><p id="3909376590ae0222a94ca9c7692afde7" class="ne-p"><span class="ne-text">总览</span></p><p id="cdee1d85330f92001b29a84a305488fe" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1621221298045-979ccd1c-9d0c-4971-8323-beeb278dfecb.png" width="669" id="LTTqa" class="ne-image"></p><p id="ec3bf6075f1a314469dd41c85550556d" class="ne-p"><span class="ne-text">queue就是我们常说的</span><strong><span class="ne-text">队列</span></strong><span class="ne-text">了。同stack一样，它是很常见而且简单的数据结构，同样由deque封装得来。当然，由于deque和list都满足它的底层实现的要求，因此你可以指明换用list作为你的queue的底层实现：</span></p><pre><code>queue&lt;int, list&lt;int&gt;&gt; myQue;</code></pre><p id="b3e401d6e594a0ed43953b2bf0cee848" class="ne-p"><span class="ne-text">由于STL容器都使用模板类，因此在实际开发中，你完全可以将所有容器的分配器、底层容器自主实现。</span></p><p id="2b75de0ad67e1676f0db8df3cdadd680" class="ne-p"><span class="ne-text">6.2.2.常见用法</span></p><p id="7d2eb183e468080fbbedee2f802bb948" class="ne-p"><span class="ne-text">queue用来实现BFS应该是最常见的用法了，以下和stack一样给出一个代码片段：</span></p><pre><code>queue&lt;int&gt; que;    while (!que.empty())    &#123;    <pre><code>    int now = que.front();    que.pop();    if (success(pos[now]))        return true;    for (int i = 0; i &amp;lt; n; i++)        if (!vis[i] &amp;amp;&amp;amp; dis[now][i] &amp;lt;= limit)        &#123;            que.push(i);            vis[i] = true;        &#125;&#125;</code></pre><p></code></pre></p><h4 id="nq54Y"><span class="ne-text">Priority_Queue</span></h4><p id="f8bba081079bb648ee52b2800fa424d1" class="ne-p"><span class="ne-text">6.3.1.总览</span></p><p id="73c8082ad9bcb477ced5371c8f482918" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1621221298072-4aa3333f-4fe3-4f4e-8f10-212345e22947.png" width="669" id="Qei4g" class="ne-image"></p><p id="b1a64cf544310cf445ace3e2c776c0b2" class="ne-p"><span class="ne-text">priority_queue实现了优先队列这一ADT，也就是我们常说的 </span><strong><span class="ne-text">“堆”</span></strong><span class="ne-text"> 。但要明晰的是，优先队列是一种ADT，而堆是它的一种具体实现。在默认状态下，priority_queue实现的是大根堆，但你可以通过模板特化从而实现小根堆，甚至是自己定义的规则。</span></p><p id="18bee2c7c8a3ef343a4a01fb476dc32f" class="ne-p"><span class="ne-text"></span></p><p id="2625d01610d99818430568d7dc76a179" class="ne-p"><span class="ne-text">6.3.2.常见用法</span></p><p id="fc64dc42e1cfe0f73f54117301683f43" class="ne-p"><span class="ne-text">实现小根堆的方式很简单:</span></p><pre><code>priority_queue&lt;int, vector&lt;int&gt;, std::greater&lt;int&gt;&gt; myHeap;</code></pre><p id="b33ef558e9c550cef931703739fb90fd" class="ne-p"><span class="ne-text">其中第一个参数为元素类型，第二个类型为底层实现，默认为vector，但STL库中的deque也符合要求。第三个参数为你的比较类型。priority_queue会按照这一比较偏序将</span><strong><span class="ne-text">最末序</span></strong><span class="ne-text">的元素作为“最大元素”。</span></p><p id="4417a73f75ce3889eaf3285c2868f150" class="ne-p"><span class="ne-text">在sort函数中自己构造函数对象以指定排序方式的写法非常基础，但其实在优先队列中指定排序方式的写法也并不困难。在sort中，我们传入一个函数指针，sort函数调用这个函数，获得它的返回值，从而得到元素之间的偏序。而在模板类中，由于</span><strong><span class="ne-text">需要在编译期就特化类</span></strong><span class="ne-text">，所以我们无法传入一个函数，而必须传入一个</span><strong><span class="ne-text">类</span></strong><span class="ne-text">。堆在排序时会</span><strong><span class="ne-text">调用其构造函数</span></strong><span class="ne-text">，获得构造函数的返回值，这整体上与我们给sort传参无异。</span></p><p id="165ef316ded3d73eba745a367532c747" class="ne-p"><span class="ne-text">大多数情况下，我们可以使用STL提供的编译器函数库中的比较运算，例如小于是less，大于等于是greater_equal，等等。上面用于实现小根堆的greater源码如下：</span></p><pre><code>template&lt;typename _Tp&gt;    struct greater : public binary_function&lt;_Tp, _Tp, bool&gt;    &#123;    <pre><code>    bool    operator()(const _Tp&amp;amp; __x, const _Tp&amp;amp; __y) const    &#123; return __x &amp;gt; __y; &#125;&#125;;</code></pre><p></code></pre></p><p id="a78f9ba03c7b071ed994cf16d4234a6d" class="ne-p"><span class="ne-text">然而观察这一函数，它最终还是要调用具体类型的比较运算。那么如果我们给容器的类不具有偏序，或者我们需要特别指定偏序怎么办呢？下面给出一个实例。</span></p><p id="e8d6aadcbc80e9b16463d5e5cb8f57a8" class="ne-p"><span class="ne-text">例如，在图的搜索中我们需要存储点和它到源点的距离，那么我们的元素可能是这样的：</span></p><pre><code>typename int Vertex;typename int Distance;typename pair&lt;Vertex, Distance&gt; Dest;</code></pre><p id="fdac6754ddac46a7c32775d34f405a56" class="ne-p"><span class="ne-text">在Dijkstra算法中，用堆优化时我们需要建立边权的小根堆，那么就可以这样自建比较类型（我们知道自己要使用的类型，就不需要写成模板类了）：</span></p><pre><code>struct myGreater : public binary_function&lt;Dest, Dest, bool&gt;&#123;    <pre><code>bool operator() (const Dest &amp;amp;lhs, const Dest &amp;amp;rhs) const&#123; return lhs.second &amp;gt; rhs.second; &#125;</code></pre><p>}<br></code></pre></p><p id="abcbbae7b6f64f631f2ef577d5b39fea" class="ne-p"><span class="ne-text">于是就可以这样建立基于边权的小根堆：</span></p><pre><code>priority_queue&lt;Dest, vector&lt;Dest&gt;, myGreater&gt; myHeap;</code></pre><h3 id="UVR8t"><span class="ne-text">Set及Multiset</span></h3><h4 id="0ldEU"><span class="ne-text">总览</span></h4><p id="37cd991762e49138a54b07d2185a183a" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1621221298126-cd7b73e2-055e-4325-8270-dadc26949011.png" width="669" id="fntg7" class="ne-image"></p><p id="460933e07cace91c2d79850aa732d841" class="ne-p"><span class="ne-text">set对应的ADT是</span><strong><span class="ne-text">集合</span></strong><span class="ne-text">：它支持元素的存储和查找，同时符合抽象意义上的集合要求——</span><strong><span class="ne-text">不允许出现重复元素</span></strong><span class="ne-text">。</span></p><h4 id="eJ0my"><span class="ne-text">常见用法</span></h4><p id="608b3b42ab2d86d2318893fb566ca7a6" class="ne-p"><span class="ne-text">set的一个重要用途就是</span><strong><span class="ne-text">排序同时去重</span></strong><span class="ne-text">。在BST家族中，理论表现最好的是Fibonacci-heap，但由于常数过大，实际表现最好的数据结构其实是set所采用的底层结构红黑树。如果说排序去重可以通过使用一个sort函数加手工来完成，那么需要</span><strong><span class="ne-text">支持插入和查找</span></strong><span class="ne-text">的题目呢？莫非我们要手写RBT吗？这时候，一个深受考验的set无疑是广大竞赛选手的福音。</span></p><p id="67486a4a9e1734a9fe7de395f24fbb50" class="ne-p"><span class="ne-text">当然，在更多的情况下，我们需要</span><strong><span class="ne-text">允许数据中出现重复</span></strong><span class="ne-text">的元素，那么</span><strong><span class="ne-text">可以使用multiset</span></strong><span class="ne-text">这种数据结构，它在其他地方与set无异，唯一的区别在于它允许重复元素的出现。</span></p><p id="6328a682fa5e63b882187edf744a94b1" class="ne-p"><span class="ne-text">在容器中，find函数在找不到对象的时候一般会返回end，那么查找可以写作：</span></p><pre><code>if (c.find(x) != c.end())    //do something...</code></pre><h3 id="KnVnr"><span class="ne-text">Map</span></h3><h4 id="fGies"><span class="ne-text">总览</span></h4><p id="11714e03628efdbd418962483353ea3c" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1621221298068-5d1c0d5a-095f-44a8-92cd-fa4bc119ab01.png" width="669" id="dyk1Y" class="ne-image"></p><h4 id="Brk2P"><span class="ne-text">常见用法</span></h4><p id="6b7f1567e7734cb156957c66f7742e78" class="ne-p"><span class="ne-text">map和set非常类似，只不过它的数据是</span><strong><span class="ne-text">键值对</span></strong><span class="ne-text">而非一个单独的键，而</span><strong><span class="ne-text">键是唯一的</span></strong><span class="ne-text">。如果给它的用途举个例子，可以是存储源点到所有可达点的访问记录。</span></p><p id="8512a19455a672ebcd5cffe914270d06" class="ne-p"><span class="ne-text">当然，同map一样，它也有允许键不唯一的版本，那就是</span><strong><span class="ne-text">multimap</span></strong><span class="ne-text">。本质上，</span><code class="ne-code"><span class="ne-text">multimap&lt;Key, T&gt;</span></code><span class="ne-text">等价于</span><code class="ne-code"><span class="ne-text">multiset&lt;pair&lt;Key, T&gt;, Comp&lt;pair&lt;Key, T&gt;&gt;, std::allocator&lt;std::pair&lt;Key, T&gt;&gt;&gt;</span></code><span class="ne-text">，其中Comp是自主实现的依据Key的比较类型。</span></p><p id="54a78d612f66c46942d22fae55ef4be8" class="ne-p"><span class="ne-text">也就是说，map和set和priority_queue一样，支持特化比较类型，特化的方式也是一样的。只不过实际使用的时候，不要忘记最后一个模板参数，那是用于生成元素空间的分配器。</span></p><h2 id="MeMEn"><span class="ne-text">四、算法</span></h2><p id="6901abc61810e97f08b225965a3331a0" class="ne-p"><span class="ne-text">STL里面有一些常用的函数模板，可以在平常使用。</span></p><p id="4343e03862a3774dcea7257894b11748" class="ne-p"><span class="ne-text"></span></p><div class="ne-quote"><p id="24ddbcb123cfa0ba4c14afd8e23a1491" class="ne-p"><span class="ne-text">参考这个链接：</span><a href="https://segmentfault.com/a/1190000021581714" data-href="https://segmentfault.com/a/1190000021581714" target="_blank" class="ne-link"><span class="ne-text">https://segmentfault.com/a/1190000021581714</span></a></p></div><h2 id="Muzfm"><span class="ne-text">五、总结</span></h2><p id="56eba145a4c02cfa4a011954a67d1c6d" class="ne-p"><span class="ne-text">本文最后，给出一个表格以供检索，相比于cppreference的总结，这里只列出了竞赛中常用的一些操作及其复杂度。begin()和end()虽然较为常用，不过由于是全体容器必备的，所以不再列出。</span></p><p id="156aed03e46ea7de2b27acae470d0b92" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1621221298131-b854f40d-40b6-42fb-a901-467032ef3583.png" width="1321" id="Pt0mu" class="ne-image"></p><p id="9e767f6fca48577ae56528e10dd311e8" class="ne-p"><span class="ne-text">这样，这篇文章也就基本结束了。可以看到，为了照顾特定的使用需求，本文对容器具体的实现未做过多探讨，反而对通常不太重视的迭代器部分做了一定的讲解。在竞赛中掌握这些内容，已经能够满足几乎全部的需求了。但在实际应用中，掌握这些内容甚至不足以通过一个大厂的面试。例如，deque的若是对容器原理有兴趣，可以找市面上评价较好的STL源码解读类书籍学习。</span></p><p id="51b6ea6eb3ea297d2531b1a174409218" class="ne-p"><span class="ne-text"></span></p><div data-type="tips" class="ne-alert"><p id="0c4773046d8106f57ad18705b5021e76" class="ne-p"><span class="ne-text">补充：头文件#include&lt;bits/stdc.h&gt;（最常用，特别是OJ刷题）的内容如下</span></p></div><p id="83b015f0947ebeaea02152032cc3da8d" class="ne-p"><br></p><pre><code>// C++ includes used for precompiling -*- C++ -*- <p>// Copyright (C) 2003-2013 Free Software Foundation, Inc.<br>//<br>// This file is part of the GNU ISO C++ Library.  This library is free<br>// software; you can redistribute it and/or modify it under the<br>// terms of the GNU General Public License as published by the<br>// Free Software Foundation; either version 3, or (at your option)<br>// any later version.</p><p>// This library is distributed in the hope that it will be useful,<br>// but WITHOUT ANY WARRANTY; without even the implied warranty of<br>// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the<br>// GNU General Public License for more details.</p><p>// Under Section 7 of GPL version 3, you are granted additional<br>// permissions described in the GCC Runtime Library Exception, version<br>// 3.1, as published by the Free Software Foundation.</p><p>// You should have received a copy of the GNU General Public License and<br>// a copy of the GCC Runtime Library Exception along with this program;<br>// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see<br>// &lt;Licenses - GNU Project - Free Software Foundation&gt;.</p><p>/** @file stdc++.h</p><ul><li> This is an implementation file for a precompiled header.</li><li>/</li></ul><p>// 17.4.1.2 Headers</p><p>// C<br>#ifndef _GLIBCXX_NO_ASSERT<br>#include &lt;cassert&gt;<br>#endif<br>#include &lt;cctype&gt;<br>#include &lt;cerrno&gt;<br>#include &lt;cfloat&gt;<br>#include &lt;ciso646&gt;<br>#include &lt;climits&gt;<br>#include &lt;clocale&gt;<br>#include &lt;cmath&gt;<br>#include &lt;csetjmp&gt;<br>#include &lt;csignal&gt;<br>#include &lt;cstdarg&gt;<br>#include &lt;cstddef&gt;<br>#include &lt;cstdio&gt;<br>#include &lt;cstdlib&gt;<br>#include &lt;cstring&gt;<br>#include &lt;ctime&gt;</p><p>#if __cplusplus &gt;= 201103L<br>#include &lt;ccomplex&gt;<br>#include &lt;cfenv&gt;<br>#include &lt;cinttypes&gt;<br>#include &lt;cstdalign&gt;<br>#include &lt;cstdbool&gt;<br>#include &lt;cstdint&gt;<br>#include &lt;ctgmath&gt;<br>#include &lt;cwchar&gt;<br>#include &lt;cwctype&gt;<br>#endif</p><p>// C++<br>#include &lt;algorithm&gt;<br>#include &lt;bitset&gt;<br>#include &lt;complex&gt;<br>#include &lt;deque&gt;<br>#include &lt;exception&gt;<br>#include &lt;fstream&gt;<br>#include &lt;functional&gt;<br>#include &lt;iomanip&gt;<br>#include &lt;ios&gt;<br>#include &lt;iosfwd&gt;<br>#include &lt;iostream&gt;<br>#include &lt;istream&gt;<br>#include &lt;iterator&gt;<br>#include &lt;limits&gt;<br>#include &lt;list&gt;<br>#include &lt;locale&gt;<br>#include &lt;map&gt;<br>#include &lt;memory&gt;<br>#include &lt;new&gt;<br>#include &lt;numeric&gt;<br>#include &lt;ostream&gt;<br>#include &lt;queue&gt;<br>#include &lt;set&gt;<br>#include &lt;sstream&gt;<br>#include &lt;stack&gt;<br>#include &lt;stdexcept&gt;<br>#include &lt;streambuf&gt;<br>#include &lt;string&gt;<br>#include &lt;typeinfo&gt;<br>#include &lt;utility&gt;<br>#include &lt;valarray&gt;<br>#include &lt;vector&gt;</p><p>#if __cplusplus &gt;= 201103L<br>#include &lt;array&gt;<br>#include &lt;atomic&gt;<br>#include &lt;chrono&gt;<br>#include &lt;condition_variable&gt;<br>#include &lt;forward_list&gt;<br>#include &lt;future&gt;<br>#include &lt;initializer_list&gt;<br>#include &lt;mutex&gt;<br>#include &lt;random&gt;<br>#include &lt;ratio&gt;<br>#include &lt;regex&gt;<br>#include &lt;scoped_allocator&gt;<br>#include &lt;system_error&gt;<br>#include &lt;thread&gt;<br>#include &lt;tuple&gt;<br>#include &lt;typeindex&gt;<br>#include &lt;type_traits&gt;<br>#include &lt;unordered_map&gt;<br>#include &lt;unordered_set&gt;<br>#endif<br></code></pre></p></div>]]></content>
      
      
      <categories>
          
          <category> 计算机素养 </category>
          
          <category> 后端编程语言 </category>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>视频的无伤切割</title>
      <link href="/blog/wr3hmo/"/>
      <url>/blog/wr3hmo/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="ud132d32d" class="ne-p"><span class="ne-text">前言：对于一个很大的视频，不方便和其他用户使用软件传输，需要将其切割成数个小容量视频，两种方法，一种是利用其他软件来进行切割，比如pr；另一种是利用万能的ffmpeg，这个需求采用后者方法。</span></p><p id="uf011c49d" class="ne-p"><span class="ne-text">需求视频为8G多，总时长01：51：00，QQ在线传输一次最多4G，所以需要将目标视频切成三段，需要的命令如下：</span></p><pre><code>ffmpeg -ss 00:00:00 -i target.mp4 -c copy -t 00:45:00 target-part1.mp4 #Start～00:45:00ffmpeg -ss 00:45:00 -i target.mp4 -c copy -t 00:45:00 target-part2.mp4 #00:45:00~01:30:00ffmpeg -ss 01:30:00 -i target.mp4 -c copy -t 00:21:00 target-part3.mp4 #01:30:00～End</code></pre><p id="u86567bc1" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1643942474386-cacbcb25-dd05-48fa-b575-7cf6e13eb635.png" width="675" id="u9fb04278" class="ne-image"></p></div>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
          <category> 前端业务解决方案 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>多一些沉稳，少一点浮躁</title>
      <link href="/essay/wrlggf/"/>
      <url>/essay/wrlggf/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="u426878f6" class="ne-p"><br></p><div data-type="info" class="ne-alert"><p id="ue7f3a63c" class="ne-p"><span class="ne-text">在自己、同学身上学到的一些关于沉稳和浮躁的相关感悟。</span></p></div><p id="u76cc7f70" class="ne-p"><br></p><p id="u334205ae" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1621129502175-8304c744-6269-4ca9-a89f-7180dbd6911c.png" width="1920" id="ue9157375" class="ne-image"></p><p id="ua4bfe073" class="ne-p"><br></p><p id="uea4e4ec2" class="ne-p"><strong><span class="ne-text">多一些沉稳，少一些浮躁</span></strong></p><p id="u163a699d" class="ne-p"><br></p><p id="ufa440c5c" class="ne-p" style="text-indent: 2em"><span class="ne-text">真正的技术人是不断去学习技术的，抑或是精进自己已有的技术，而不是像一个井底之蛙，不踏踏实实做技术，只想着一步登云，对技术而言，哪来的精进可言</span></p><p id="u3e091225" class="ne-p"><br></p><p id="uaa7e917f" class="ne-p" style="text-indent: 2em"><span class="ne-text">这个节奏下面，很多人很多时候被生活牵着走，不再是我们过生活，而是生活过着我们，少了一些风情雅致，多了一些功利与欲望，就像是越肤浅的人，越浮躁，一新急于求成，功利心太重。越是有实力，能将生活活出自我的人越是沉稳安静，不急不躁，踏实努力，以梦为马，执笔为声！</span></p><p id="u6053d842" class="ne-p"><br></p><p id="u82921bff" class="ne-p" style="text-indent: 2em"><span class="ne-text">上面说到功利了，于是乎想到了我父母做生意的那路历程，做生意不可能一直起势，有起就有落，可在一些人眼中，他们所看到的，永远只有起势和高光……大学三年之下，A同学想着年薪百万，B同学想着开公司，我觉得这都是可以的，我相信年轻的资本在人生历程中是占比很足的，但是现在细想，那些话的字体行间透露着些许的浮躁，我暂且用野心来代替那些话，我相信野心这个词，但这三年在学校的生活与对社会的前驱认知告诉我，野心是基于沉稳之上的，野心是基于踏实之上，野心更是对理想而拆解成一系列目标并予以实施的基础上的，多一些沉稳，少一些浮躁……</span></p></div>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>哈夫曼树</title>
      <link href="/blog/fyhtb2/"/>
      <url>/blog/fyhtb2/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h2 id="6aTqg"><span class="ne-text">实验内容</span></h2><p id="7d4494118179e44e0f3ed8839f84ffb0" class="ne-p"><span class="ne-text">已知某系统在通信联络中只可能出现n种字符，其概率从键盘输入。试创建哈夫曼树。</span></p><p id="u14631b82" class="ne-p"><span class="ne-text"></span></p><h2 id="cozPM"><span class="ne-text">实验要求</span></h2><p id="2e4df6f34b851d957d20a58176fee7ae" class="ne-p"><span class="ne-text"> 1、从键盘输入n, 以及n个字符的概率。</span></p><p id="53159717888700928d3025e77865f9a9" class="ne-p"><span class="ne-text">例如：已知某系统在通信联络中只可能出现n种字符，其概率分别为   0.05, 0.29, 0.07, 0.08, 0.14, 0.23, 0.03, 0.11，试设计哈夫曼编码创建哈夫曼树。</span></p><p id="3f08e9ba77eae8c4d6729c3d06a2c7de" class="ne-p"><span class="ne-text">2、用顺序存储。</span></p><p id="8fa3ffb8da8d9047bbe0fcf4b26a8146" class="ne-p"><span class="ne-text">3、输出结果如下</span></p><p id="8ca76d9eebc14783ea80967a6eede7f6" class="ne-p"><span class="ne-text"> </span><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1620964210279-ee3848d0-d031-4dc0-a850-3ae179b7a317.png" width="312" id="lteAK" class="ne-image"></p><p id="0c54abe86060ef65be0dc82c893a755c" class="ne-p"><span class="ne-text">交作业时间：下次上机前</span></p><h2 id="z4tNS"><span class="ne-text">实验代码</span></h2><pre><code>#include &lt;bits/stdc++.h&gt;using namespace std;<p>int n, m, s1, s2;<br>typedef struct HTNode<br>&#123;<br>    int weight, parent, lchild, rchild, pos;<br>    bool operator&lt;(const HTNode &amp;a)const<br>   &#123;<br>       return a.weight &lt; weight;<br>   &#125;<br>&#125;HTNode, *HuffmanTree;</p><p>priority_queue&lt;HTNode&gt;P;</p><p>void Select(HuffmanTree &amp;HT, int ii, int &amp;s1, int &amp;s2)<br>&#123;<br>    HTNode t = P.top();<br>    s1 = t.pos;<br>    P.pop();<br>    t = P.top();<br>    s2 = t.pos;<br>    P.pop();<br>&#125;</p><p>void CreateHuffmantree(HuffmanTree &amp;HT, int n)<br>&#123;<br>    if(n &lt;= 1)<br>        return;<br>    m = 2 * n - 1;<br>    HT = new HTNode[m + 1];<br>    for(int i = 1; i &lt;= m; i++)<br>    &#123;<br>        HT[i].parent = 0;<br>        HT[i].lchild = 0;<br>        HT[i].rchild = 0;<br>    &#125;<br>    for(int i = 1; i &lt;= n; ++i)<br>    &#123;<br>        cin &gt;&gt; HT[i].weight;<br>        HT[i].pos = i;<br>        P.push(HT[i]);<br>    &#125;<br>    for(int i = n + 1; i &lt;= m; i++)<br>    &#123;<br>        Select(HT, i - 1, s1, s2);<br>        HT[s1].parent = i;<br>        HT[s2].parent = i;<br>        HT[i].lchild = s1;<br>        HT[i].rchild = s2;<br>        HT[i].weight = HT[s1].weight + HT[s2].weight;<br>        HT[i].pos = i ;<br>        P.push(HT[i]);<br>    &#125;<br>&#125;</p><p>int main()<br>&#123;<br>    HuffmanTree HT;<br>    cout &lt;&lt; &quot;请输入哈夫曼树的叶子结点个数：&quot;;<br>    cin &gt;&gt; n;<br>    cout &lt;&lt; &quot;请输入每个叶子结点的权值：&quot; &lt;&lt; ‘\n’;<br>    CreateHuffmantree(HT, n);<br>    for(int i = 1; i &lt;= 2 * n - 1; ++i)<br>    &#123;<br>        cout &lt;&lt; &quot;结点序号 &quot; &lt;&lt; i &lt;&lt; &quot; 权重 &quot; &lt;&lt; HT[i].weight<br>        &lt;&lt; &quot; parent &quot; &lt;&lt; HT[i].parent &lt;&lt; &quot; lchild &quot; &lt;&lt; HT[i].lchild<br>        &lt;&lt; &quot; rchild &quot; &lt;&lt; HT[i].rchild &lt;&lt; ‘\n’;<br>    &#125;<br>&#125;</p><p></code></pre></p><h2 id="Oq4eC"><span class="ne-text">实验结果</span></h2><p id="a17e3b9f9fa59ed14ab816423bd5d336" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1621215937466-2f1ef720-c7ae-4103-bf0b-0f75855059ff.png" width="369" id="mQROC" class="ne-image"></p></div>]]></content>
      
      
      <categories>
          
          <category> 计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 🌲树结构：二叉树-哈夫曼树 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>树的基本知识</title>
      <link href="/blog/tyyaq0/"/>
      <url>/blog/tyyaq0/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h2 id="wUWWX"><span class="ne-text">基本概念</span></h2><p id="ud11c2854" class="ne-p"><br></p><p id="d59840dd0f24290c76b104f04af4576f" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1625137853863-648e9e16-dded-4a47-81c4-4dc759a29e05.png" width="435.5" id="krxvv" class="ne-image"><span class="ne-text">  </span></p><p id="2b08cadb4fc1c56acd4a172087e12859" class="ne-p"><span class="ne-text"></span></p><p id="499128c4757efa545c7b3aae17ab1c85" class="ne-p"><span class="ne-text"></span></p><p id="0db3ada666899d52bef676216cc77384" class="ne-p"><span class="ne-text"></span></p></div>]]></content>
      
      
      <categories>
          
          <category> 计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 🌲树结构：二叉树-哈夫曼树 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>blob格式视频链接的下载</title>
      <link href="/blog/bhnvxw/"/>
      <url>/blog/bhnvxw/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h3 id="my40N"><span class="ne-text">场景</span></h3><p id="ub57bf056" class="ne-p"><span class="ne-text">有些网页的视频链接（html中）如下格式会下载不了，也没有视频的url可供访问</span></p><ul class="ne-ul"><li id="ua5adde30"><span class="ne-text">具体网页：</span><code class="ne-code"><a href="https://5kb.co/vodplay/33666-2-1.html" data-href="https://5kb.co/vodplay/33666-2-1.html" target="_blank" class="ne-link"><span class="ne-text">https://5kb.co/vodplay/33666-2-1.html</span></a></code></li><li id="ub002c8b1"><span class="ne-text">网页中的blob视频格式</span></li></ul><pre><code>&lt;img src: &quot;blob:https://5kb.co/a504161c-cf27-4979-a1c3-86a0ce4f6556&quot;&gt;</code></pre><ul class="ne-ul"><li id="ud27b560d"><span class="ne-text">控制台查看后缀为m3u8的接口访问网络请求</span></li></ul><p id="ud04248ff" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1641182194610-2c7ff9b7-6445-45b3-b2d9-fcbe164705b4.png" width="820" id="u616d033a" class="ne-image"></p><h3 id="cC4PX"><span class="ne-text">解决思路</span></h3><p id="u03a76a85" class="ne-p"><span class="ne-text">思路：安装ffmpeg环境，利用转换命令将其转换为MP4资源</span></p><ul class="ne-ul"><li id="uce246083"><span class="ne-text">ffmpeg环境的安装：</span><a href="https://www.yuque.com/wztlink1013/blog/akf33e#pDCNT" data-href="https://www.yuque.com/wztlink1013/blog/akf33e#pDCNT" target="_blank" class="ne-link"><span class="ne-text">https://www.yuque.com/wztlink1013/blog/akf33e#pDCNT</span></a></li><li id="u02d12fdd"><span class="ne-text">转换命令：</span></li></ul><pre><code>ffmpeg -i https://v3.dious.cc/20210520/8sKShH2U/index.m3u8 target.mp4</code></pre><h3 id="BtAhT"><span class="ne-text">关于blob视频加密相关知识</span></h3><p id="u4cafee64" class="ne-p"><span class="ne-text">blob视频加密就相当于将原视频url进行隐藏，然后切片访问播放。</span></p><p id="uc4c9fa2e" class="ne-p"><span class="ne-text">那么网页如何成功加载该视频呢？服务器会返回一个m3u8的响应文件，这个文件的作用就是正确找到所有的切片，然后拼接播放。</span></p><p id="u873a2172" class="ne-p"><span class="ne-text"></span></p><p id="ub09557a7" class="ne-p"><span class="ne-text">在使用ffmpeg将其拼接ts文件称mp4文件过程中，如下：</span></p><p id="u06afdfb4" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1641183335922-952b5616-e47f-44fa-89b6-4f6abaf78157.png" width="1402" id="u8b056dae" class="ne-image"></p><p id="u4f49849a" class="ne-p"><span class="ne-text">那么ts文件又是什么用的呢？</span></p><p id="u6093b0a7" class="ne-p"><span class="ne-text">百度百科的定义：</span></p><div class="ne-quote"><p id="u9945b40f" class="ne-p"><span class="ne-text">ts是日本高清摄像机拍摄下进行的封装格式，全称为MPEG2-TS。ts即&quot;Transport Stream&quot;的缩写。MPEG2-TS格式的特点就是要求从视频流的任一片段开始都是可以独立解码的。</span></p></div><p id="u7ab401c8" class="ne-p"><span class="ne-text"></span></p></div>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
          <category> 前端业务解决方案 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>二叉树的创建与遍历🔖DFS🔖先序🔖中序🔖后序</title>
      <link href="/blog/ggimdr/"/>
      <url>/blog/ggimdr/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h2 id="4Epl1"><span class="ne-text">实验报告</span></h2><div data-type="color1" class="ne-alert"><p id="a20d224c568e48b9d67847a2c66a8c01_p_0" class="ne-p"><span class="ne-text">编写一个程序，实现二叉树的各种运算，并在此基础上设计一个程序完成如下功能：</span></p></div><p id="4d03c6b09b984aef043ed5b518c363c7" class="ne-p"><br></p><div class="ne-quote"><p id="38598db323ff50acdf71c84be93d56d2" class="ne-p"><span class="ne-text">（1）创建一棵二叉树（用键盘按照</span><strong><span class="ne-text">先序遍历</span></strong><span class="ne-text">序列输入一个字符串生成二叉树）；</span></p><p id="6d6611128e131f3a0d3a0f0d853687c8" class="ne-p"><span class="ne-text">（2）输出前序、中序、后序遍历的遍历序列；  </span></p><p id="d3bc67e9954efda55a647c26d988e214" class="ne-p"><span class="ne-text">（3）统计并输出二叉树的的结点个数；</span></p><p id="2b559b492f686815878cb75ac83b3b42" class="ne-p"><span class="ne-text">（4）输出二叉树的叶子结点的个数；(选做)</span></p></div><p id="c05a274226f7be751442f3c2688a5e1f" class="ne-p"><br></p><div data-type="color1" class="ne-alert"><p id="3d301d5e79f0b9519c224c1db62d626b" class="ne-p"><span class="ne-text">实验要求：  </span></p></div><p id="9a21f7d2dbdf87c8a1d6951d6090b939" class="ne-p"><br></p><div class="ne-quote"><p id="29367bb74625a503f401e74a67a84591" class="ne-p"><span class="ne-text">用键盘输入一个字符串，按照</span><strong><span class="ne-text">满二叉树的特点</span></strong><span class="ne-text">生成一棵二叉树。</span></p></div><p id="663a7b36b101c7fddf398dd7f4151ef9" class="ne-p"><br></p><div data-type="color1" class="ne-alert"><p id="31e43c4890b63675efb128313a69f5e6" class="ne-p"><span class="ne-text">测试用例要求：</span></p></div><p id="8508e775c2dd3f3338c305eec70bcfd5" class="ne-p"><br></p><div class="ne-quote"><p id="5b4622339600d057a077198d9246b236" class="ne-p"><span class="ne-text">如下二叉树的输入字符串为：ABD###C#E##</span></p><p id="70373932282643f63ec142623dc8c357" class="ne-p"><span class="ne-text">书写方法：碰到#说明该二叉树是一棵空树，注意分配（下面缺两个左右补两个#，缺一个左/右子树，补一个#）</span></p></div><p id="1e4fa4b6d686ada91a2726874baf4778" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1620295747111-4774a4a6-b617-4f26-a0c3-f9f1bdb386cc.png" width="235" id="Fl1gC" class="ne-image"></p><div data-type="color1" class="ne-alert"><p id="33e9672dfd9a5ed7c83baa6580c2cfdb" class="ne-p"><span class="ne-text">二叉链表的结点类型（C++）：</span></p></div><p id="203045dd2c8c14b360c1d2de82cbf109" class="ne-p"><br></p><pre><code>Typedef structure  tnode&#123;    int   data;    structure  tnode   *lchild, *rchild;&#125;bitree,*bitlink ;</code></pre><h2 id="iDiJK"><span class="ne-text">实验代码</span></h2><p id="4e4255e3159bf6d3a0d0ac2d29c6a6aa" class="ne-p"><span class="ne-text">用上面的二叉树作为例子：</span></p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;typedef int Status;typedef char TElemType;#define OVERFLOW -1#define ERROR 0#define OK 1char ch;<p>/**</p><ul><li>采用二叉链表的存储形式</li><li>/<br>typedef struct BiTNode<br>&#123;<br>  TElemType data;<br>  struct BiTNode *lchild, *rchild;<br>&#125;BiTNode, *BiTree;</li></ul><p>/**</p><ul><li>创建一棵二叉树</li><li>/<br>void CreateBiTree(BiTree &amp;T) &#123;<br>  //按先序次序输入二叉树中结点的值，创建二叉链表表示的二叉树T<br>  TElemType ch;<br>  cin&gt;&gt;ch;<br>  if(ch == ‘#’)&#123;//递归结束，建空树<pre><code>  T = NULL;</code></pre>  } else {<pre><code>  T = new BiTNode;  T-&amp;gt;data = ch;  CreateBiTree(T-&amp;gt;lchild);  CreateBiTree(T-&amp;gt;rchild);</code></pre>  }     </li></ul><p>}</p><p>/**</p><ul><li>先序遍历</li><li>/<br>void PreOrderTraverse(BiTree &amp;T)<br>{//先序遍历二叉树T的递归算法<br>  if(T)                               //若二叉树非空<br>  {<pre><code>  cout &amp;lt;&amp;lt; T-&amp;gt;data &amp;lt;&amp;lt; &amp;quot; &amp;quot;;                  //访问根结点   PreOrderTraverse(T-&amp;gt;lchild);     //中序遍历左子树   PreOrderTraverse(T-&amp;gt;rchild);     //中序遍历右子树</code></pre>  }<br>}</li></ul><p>/**</p><ul><li>中序遍历</li><li>/<br>void InOrderTraverse(BiTree &amp;T) {<br>  if (T) {<pre><code>  InOrderTraverse(T-&amp;gt;lchild);  cout &amp;lt;&amp;lt; T-&amp;gt;data &amp;lt;&amp;lt; &amp;quot; &amp;quot;;  InOrderTraverse(T-&amp;gt;rchild);</code></pre>  }<br>}</li></ul><p>/**</p><ul><li>后序遍历</li><li>/<br>void PostOrderTraverse(BiTree &amp;T)<br>{//后序遍历二叉树T的递归算法<br>  if(T)                               //若二叉树非空<br>  {<pre><code>  PostOrderTraverse(T-&amp;gt;lchild);   //中序遍历左子树   PostOrderTraverse(T-&amp;gt;rchild);   //中序遍历右子树  cout &amp;lt;&amp;lt; T-&amp;gt;data &amp;lt;&amp;lt; &amp;quot; &amp;quot;;                 //访问根结点 </code></pre>  }<br>}</li></ul><p>/**</p><ul><li>统计二叉树中节点个数</li><li>/<br>int NodeCount (BiTree &amp;T) {<br>  if (T == NULL) {<pre><code>  return 0;</code></pre>  } else {<pre><code>  return NodeCount(T-&amp;gt;lchild) + NodeCount(T-&amp;gt;rchild) + 1;</code></pre>  }<br>}</li></ul><p>/**</p><ul><li>二叉树中叶结点个数</li><li>/<br>int LeavesCount (BiTree &amp;T) {<br>  if (T == NULL) {<pre><code>  return 0;</code></pre>  } else if (T-&gt;lchild == NULL &amp;&amp; T-&gt;rchild == NULL) {<pre><code>  return LeavesCount(T-&amp;gt;lchild) + LeavesCount(T-&amp;gt;rchild) + 1;</code></pre>  }<br>  else {<pre><code>  return LeavesCount(T-&amp;gt;lchild) + LeavesCount(T-&amp;gt;rchild);</code></pre>  }<br>}</li></ul><p>int main() {<br>    BiTree test = new BiTNode;<br>    cout &lt;&lt; &quot;请输入一个字符串以生成二叉树：&quot;;<br>    CreateBiTree(test);<br>    cout &lt;&lt;&quot;\n&quot;&lt;&lt; &quot;先序遍历结果：&quot;;<br>    PreOrderTraverse(test);<br>    cout &lt;&lt;&quot;\n&quot;&lt;&lt; &quot;中序遍历结果：&quot;;<br>    InOrderTraverse(test);<br>    cout &lt;&lt;&quot;\n&quot;&lt;&lt; &quot;后序遍历结果：&quot;;<br>    PostOrderTraverse(test);<br>    cout &lt;&lt;&quot;\n&quot;&lt;&lt; &quot;二叉树结点个数：&quot;&lt;&lt;NodeCount(test);<br>    cout &lt;&lt;&quot;\n&quot;&lt;&lt; &quot;二叉树叶结点个数：&quot;&lt;&lt;LeavesCount(test);<br>}<br></code></pre></p><p id="f7b064b46c7f5e5145d73cd94574a05e" class="ne-p" style="text-align: left"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1620302765118-f27235d1-7167-40ae-ab80-dc23494d55cc.png" width="512.5" id="fbgNz" class="ne-image"></p><h2 id="sowJA"><span class="ne-text">DFS遍历算法</span></h2><p id="u4362d8eb" class="ne-p" style="text-align: center"><strong><span class="ne-text" style="color: #E8323C">DFS遍历分三种情况：先序、中序、后序</span></strong></p><div data-type="info" class="ne-alert"><p id="u95df2ce2" class="ne-p"><span class="ne-text" style="background-color: #E8F7FF">把一颗树遍历完，有下面三种方法：</span></p><ul class="ne-ul"><li id="uc9ff0cc0"><strong><span class="ne-text" style="background-color: #E8F7FF">波兰</span></strong><span class="ne-text" style="background-color: #E8F7FF">表达式 -&gt; </span><strong><span class="ne-text" style="background-color: #E8F7FF"> 先序</span></strong><span class="ne-text" style="background-color: #E8F7FF">遍历二叉树</span></li><li id="uc43055cb"><strong><span class="ne-text" style="background-color: #E8F7FF">中缀</span></strong><span class="ne-text" style="background-color: #E8F7FF">表达式 -&gt; </span><strong><span class="ne-text" style="background-color: #E8F7FF">中序</span></strong><span class="ne-text" style="background-color: #E8F7FF">遍历二叉树</span></li><li id="udba25db2"><strong><span class="ne-text" style="background-color: #E8F7FF">逆波兰</span></strong><span class="ne-text" style="background-color: #E8F7FF">表达式 -&gt;</span><strong><span class="ne-text" style="background-color: #E8F7FF"> 后序</span></strong><span class="ne-text" style="background-color: #E8F7FF">遍历二叉树</span></li></ul></div><p id="u92cfd7ea" class="ne-p"><br></p><p id="u22ea8840" class="ne-p" style="text-align: left"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1620298049502-63346474-7a61-45cf-88a8-56c66954d894.png" width="385.5" id="WLPKa" class="ne-image"></p><h3 id="Huygi"><span class="ne-text">手写例子</span></h3><p id="u4849dcc2" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1620298098593-6760a592-4907-4662-a4be-404dde35d246.png" width="295" id="zsvnG" class="ne-image"></p><p id="ueab83a04" class="ne-p" style="text-align: left"><br></p><p id="ue7256163" class="ne-p" style="text-align: left"><span class="ne-text">各种遍历结果</span></p><ul class="ne-ul"><li id="ua1c0307d" style="text-align: left"><span class="ne-text">先序：-+a*b-cd/ef</span></li><li id="uf0007730" style="text-align: left"><span class="ne-text">中序：a+b*c-d-e/f</span></li><li id="u16808acb" style="text-align: left"><span class="ne-text">后序：abcd-*+ef/-</span></li></ul><p id="6a565f3d23b6283c08540b7cf1afa97e" class="ne-p" style="text-align: left"><br></p><h3 id="ZLoiv"><span class="ne-text">前序遍历</span></h3><ul class="ne-ul"><li id="u945a3d19"><a href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/" data-href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/" class="ne-link"><span class="ne-text">144. 二叉树的前序遍历</span></a></li></ul><pre><code>/** * Definition for a binary tree node. * function TreeNode(val, left, right) &#123; *     this.val = (val===undefined ? 0 : val) *     this.left = (left===undefined ? null : left) *     this.right = (right===undefined ? null : right) * &#125; *//** * @param &#123;TreeNode&#125; root * @return &#123;number[]&#125; */var preorderTraversal = function(root) &#123;    let result = []    let preorder = data =&gt; &#123;        if (data) &#123;            result.push(data.val)            preorder(data.left)            preorder(data.right)        &#125;    &#125;    preorder(root)    return result&#125;;</code></pre><h3 id="v6dYp"><span class="ne-text">中序遍历</span></h3><ul class="ne-ul"><li id="ua597b26d"><a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/" data-href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/" class="ne-link"><span class="ne-text">94. 二叉树的中序遍历</span></a></li></ul><pre><code>/** * Definition for a binary tree node. * function TreeNode(val, left, right) &#123; *     this.val = (val===undefined ? 0 : val) *     this.left = (left===undefined ? null : left) *     this.right = (right===undefined ? null : right) * &#125; *//** * @param &#123;TreeNode&#125; root * @return &#123;number[]&#125; */var inorderTraversal = function(root) &#123;    let result = []    let inorder = data =&gt; &#123;        if (data) &#123;            inorder(data.left)            result.push(data.val)            inorder(data.right)        &#125;    &#125;    inorder(root)    return result&#125;;</code></pre><h3 id="o6HJu"><span class="ne-text">后序遍历</span></h3><ul class="ne-ul"><li id="u9bf35e9b"><a href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/" data-href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/" class="ne-link"><span class="ne-text">145. 二叉树的后序遍历</span></a></li></ul><pre><code>/** * Definition for a binary tree node. * function TreeNode(val, left, right) &#123; *     this.val = (val===undefined ? 0 : val) *     this.left = (left===undefined ? null : left) *     this.right = (right===undefined ? null : right) * &#125; *//** * @param &#123;TreeNode&#125; root * @return &#123;number[]&#125; */var postorderTraversal = function(root) &#123;    let result = []    let postorder = data =&gt; &#123;        if (data) &#123;            postorder(data.left)            postorder(data.right)            result.push(data.val)        &#125;    &#125;    postorder(root)    return result&#125;;</code></pre></div>]]></content>
      
      
      <categories>
          
          <category> 计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 🌲树结构：二叉树-哈夫曼树 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>实验5——波兰/逆波兰表达式求值🔖栈</title>
      <link href="/blog/iyb7wi/"/>
      <url>/blog/iyb7wi/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="9e860144325b87da71afc87eefe2d77a" class="ne-p"><br></p><h2 id="9vFrj"><span class="ne-text">实验报告</span></h2><p id="f79ae7dddc05f05b1fe9f31553cdf695" class="ne-p"><span class="ne-text">实验五：实现用波兰表达式（先序）和逆波兰表达式（后序）求算术表达式的值</span></p><p id="4a9b70f09095db07a51166c993864aa5" class="ne-p"><span class="ne-text">要求：仅用一个栈实现（并且用原生单链表实现）</span></p><p id="0073cffd2d82424ee08e442fde183209" class="ne-p"><span class="ne-text">测试用例：4+2*3-10/5</span></p><p id="1015932deb14ce9808f762815a09e7c9" class="ne-p"><span class="ne-text">交作业时间：5月14日</span></p><h2 id="95f63ce98656d59fcee6f1cad6c4ae42"><span class="ne-text">思路</span></h2><p id="03a71edb0ce041bb880fac7483d51a8d" class="ne-p"><span class="ne-text">两个步骤：</span></p><ol class="ne-ol"><li id="127832819ea0b8b0383119803531e321"><strong><span class="ne-text">将给定的表达式转换为波兰表达式/逆波兰表达式</span></strong></li><li id="bbeddc496c9bbaa01590501e70c3593d"><strong><span class="ne-text">对转换后的式子进行计算</span></strong></li></ol><p id="75aa0ca11c1c45c1e80b31c018656ccc" class="ne-p"><br></p><p id="544e05aece3b557af8c08d44fe4340cf" class="ne-p"><span class="ne-text">学习遍历二叉树，利用前序/中序/后序表达式的时候，经常有一个问题就是：</span></p><p id="9fda6508e74029858e9a77d75c366090" class="ne-p"><br></p><ul class="ne-tl"><li checked="true" id="dff42916b2274e13af7620f3be09f8f4"><span class="ne-text">给出中缀表达式，【写出&amp;&amp;编程出】</span><span class="ne-text">后序（逆波兰）表达式</span></li></ul><p id="1cc028e11883abbffc825eedbee0a6d1" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1620306330357-a83abeff-56a3-44f1-b837-82051f46e3b5.png" width="237" id="ZAX5A" class="ne-image"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1620306352380-f6eef790-b72d-4e1d-9da1-6597ec5ae11d.png" width="294" id="zESCQ" class="ne-image"></p><p id="4ac0025b3ca7f49b653537cf8d999dca" class="ne-p"><span class="ne-text">上面的是课堂上在纸上的书写，那么如何将其用编程语言实现呢？思路应该是这样的：</span></p><ul class="ne-ul"><li id="f3e9b0538142d63fb0dddee70782998a"><span class="ne-text">遍历表达式：对遍历的元素进行判断</span></li><li id="16cdfca79195b1e48ee8fb8da2f93a3f"><span class="ne-text">是运算符？操作数？还是括号呢？对其相应的判断</span></li></ul><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="536967d5477dce93aae2af4844744c6a"><span class="ne-text">操作数</span></li><li id="f742c335bbfeceb701f45f6da5359fda"><span class="ne-text">运算符：+-*/</span></li><li id="37bf504cf25ab5a1e31c553ebfe1f88e"><span class="ne-text">括号</span></li></ul></ul><ul class="ne-tl"><li checked="true" id="5a8cbdcf9cfe9df1a63ee1b6026b78d7"><span class="ne-text">个位数/双位数……的字符处理</span></li></ul><p id="59a438bb0fbcce4204dcef4b54e34c97" class="ne-p"><br></p><ul class="ne-tl"><li checked="true" id="03c0087d691f6334d867ef61684852de"><span class="ne-text">给出中缀表达式，【</span><span class="ne-text">写出&amp;&amp;编程出】</span><span class="ne-text">前序（波兰）表达式</span></li></ul><p id="0f94194b7fb7b6193beba54f8228ffa2" class="ne-p"><span class="ne-text">如果写出了逆波兰表达式，转换为波兰表达式只需要将</span><code class="ne-code"><span class="ne-text">（</span></code><span class="ne-text">变为</span><code class="ne-code"><span class="ne-text">）</span></code><span class="ne-text">，同时遍历从后往前遍历即可</span></p><p id="fb58b92c1fc00f9bcd46cc62d1ec7c6e" class="ne-p"><br></p><p id="7eb7f2863604df250b519a0432fe9e65" class="ne-p"><span class="ne-text">最后的结果逆置</span></p><ul class="ne-tl"><li checked="true" id="cb3454de2df57954ef838a0995e12ebc"><span class="ne-text">最后的计算，波兰和逆波兰不能写成一个函数，因为减数和被减数，除数和被除数的缘故</span></li></ul><h2 id="IjDi9"><span class="ne-text">实验代码</span></h2><p id="394b25ed4cb75f5498127a399da3cfeb" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1620979662957-690a9050-8a82-4170-816b-ffcff99f38d7.png" width="500" id="Kzxk3" class="ne-image"></p><p id="0e973006837549c019ba002da970c410" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1620979669021-d90e4ff6-feb6-4df9-9f6a-d7176b25d258.png" width="446" id="XDVSW" class="ne-image"></p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;<p>/**</p><ul><li>波兰表达式/逆波兰表达式求解运算表达式</li><li></li><li>/</li></ul><p>/**</p><ul><li>单链表的存储结构</li><li>/<br>typedef struct LNode &#123;<br>  string data; //数据域<br>  struct LNode *next; //指针域<br>&#125;Lnode, *LinkList; //LinkList为指向结构体LNode的指针类型</li></ul><p>/* 初始化链表 */<br>void InitList(LinkList &amp;L) &#123;<br>    L = new LNode;<br>    L-&gt;next = NULL;<br>&#125;</p><p>/* 打印 */<br>void TraverseList(LinkList &amp; L)&#123;<br>        LNode *p = new LNode;<br>        p = L-&gt;next;<br>        // cout &lt;&lt; &quot;此中缀表达式链表打印的结果为：&quot;;<br>        while (p != NULL)<br>        &#123;<br>            cout &lt;&lt; p-&gt;data;<br>            p = p-&gt;next;<br>        &#125;<br>        cout &lt;&lt; &quot;\n&quot;;<br>&#125;</p><p>/* 逆置 */<br>void ReverseList(LinkList &amp;L) &#123;<br>    LNode *p = L-&gt;next;<br>    L-&gt;next = NULL;<br>    while(p)<br>    &#123;<br>        LNode *q = p-&gt;next;<br>        p-&gt;next = L-&gt;next;<br>        L-&gt;next = p;<br>        p = q;<br>    &#125;<br>&#125;</p><p>/**</p><ul><li>初始化用户输入的链表</li><li>/<br>void Center(LinkList &amp;L,string s) &#123;<br>  InitList(L);<br>  LinkList p = L;<br>  string temp = &quot;&quot;;<br>  for (int i = 0; i &lt; s.length();i++)&#123;<pre><code>  // 处理双位数字情况  if (isdigit(s[i])) &#123;      // 该字符为数字      temp = temp + s[i];      if (!isdigit(s[i+1])) &#123;          // 下一个不是数字，而是字符，将temp后插          LinkList node = new LNode;          node-&amp;gt;data = temp;          node-&amp;gt;next = NULL;          p-&amp;gt;next = node;          p = node;          // 将temp重置          temp = &amp;quot;&amp;quot;;          continue;      &#125;      continue;  &#125;  // 后插到L尾巴上  LinkList node = new LNode;  node-&amp;gt;data = s[i];  node-&amp;gt;next = NULL;  p-&amp;gt;next = node;  p = node;</code></pre>  }<br>}</li></ul><p>/**</p><ul><li><p>将表达式转换为波兰表达式/逆波兰表达式</p></li><li><p>第二个参数对逆波兰而言是左括号，第三个参数对逆波兰而言是右括号</p></li><li><p>对波兰而言反过来</p></li><li><p>/<br>void Transition(LinkList &amp;L, string l, string r){<br>  // 定义一个栈用来处理<br>  stack&lt;string&gt; stack;<br>  LinkList p = L-&gt;next;<br>  LinkList result = new LNode;<br>  InitList(result);<br>  LinkList result_a = result;</p><p>  while(p != NULL) {</p><pre><code>  if (p-&amp;gt;data == l) &#123;      stack.push(p-&amp;gt;data);  &#125; else if(p-&amp;gt;data == r) &#123;      while(stack.top() != l)&#123;          LinkList temp = new LNode;          temp-&amp;gt;data = stack.top();          temp-&amp;gt;next = NULL;          result_a-&amp;gt;next = temp;          result_a = temp;          stack.pop();      &#125;      if (stack.top() == l)&#123;          stack.pop();      &#125;  &#125; else if(p-&amp;gt;data == &amp;quot;+&amp;quot; || p-&amp;gt;data == &amp;quot;-&amp;quot;) &#123;      if (stack.size() != 0) &#123;          if (stack.top() == &amp;quot;*&amp;quot; || stack.top() == &amp;quot;/&amp;quot;)&#123;              for (int i = 0; i &amp;lt; stack.size();i++) &#123;                  if (stack.top() == l) &#123;                      break;                  &#125;                  LinkList temp = new LNode;                  temp-&amp;gt;data = stack.top();                  temp-&amp;gt;next = NULL;                  result_a-&amp;gt;next = temp;                  result_a = temp;                  stack.pop();              &#125;          &#125;      &#125;      stack.push(p-&amp;gt;data);  &#125; else if(p-&amp;gt;data == &amp;quot;*&amp;quot; || p-&amp;gt;data == &amp;quot;/&amp;quot;) &#123;      stack.push(p-&amp;gt;data);  &#125; else &#123;      LinkList temp = new LNode;      temp-&amp;gt;data = p-&amp;gt;data;      temp-&amp;gt;next = NULL;      result_a-&amp;gt;next = temp;      result_a = temp;  &#125;  p = p-&amp;gt;next;</code></pre><p>  }<br>  // TraverseList(result);<br>  for (int i = 0; i &lt; stack.size();i++) {</p><pre><code>  LinkList temp = new LNode;  temp-&amp;gt;data = stack.top();  temp-&amp;gt;next = NULL;  result_a-&amp;gt;next = temp;  result_a = temp;  stack.pop();</code></pre><p>  }<br>  // 上一个操作总是不能清空栈的最后一个元素<br>  LinkList temp = new LNode;<br>  temp-&gt;data = stack.top();<br>  temp-&gt;next = NULL;<br>  result_a-&gt;next = temp;<br>  result_a = temp;<br>  stack.pop();</p><p>  L = result;<br>}</p></li></ul><p>/**</p><ul><li>计算</li><li>/</li></ul><p>void EvaulTree(LinkList &amp;L) {<br>    // 定义一个栈用来处理<br>    stack&lt;string&gt; stack;<br>    LinkList p = L-&gt;next;<br>    while(p != NULL) {<br>        if (p-&gt;data == &quot;+&quot;){<br>            int x = stoi(stack.top());<br>            stack.pop();<br>            int y = stoi(stack.top());<br>            stack.pop();<br>            stack.push(to_string(y + x));<br>        } else if(p-&gt;data == &quot;-&quot;) {<br>            int x = stoi(stack.top());<br>            stack.pop();<br>            int y = stoi(stack.top());<br>            stack.pop();<br>            stack.push(to_string(y - x));<br>        } else if(p-&gt;data == &quot;*&quot;) {<br>            int x = stoi(stack.top());<br>            stack.pop();<br>            int y = stoi(stack.top());<br>            stack.pop();<br>            stack.push(to_string(y * x));<br>        } else if(p-&gt;data == &quot;/&quot;) {<br>            int x = stoi(stack.top());<br>            stack.pop();<br>            int y = stoi(stack.top());<br>            stack.pop();<br>            stack.push(to_string(y / x));<br>        } else {<br>            stack.push(p-&gt;data);<br>        }<br>        p = p-&gt;next;<br>    }<br>    while (!stack.empty()){<br>        cout &lt;&lt; stoi(stack.top());<br>        stack.pop();<br>    }<br>}</p><p>void EvaulTree_polish(LinkList &amp;L) {<br>    // 定义一个栈用来处理<br>    stack&lt;string&gt; stack;<br>    LinkList p = L-&gt;next;<br>    while(p != NULL) {<br>        if (p-&gt;data == &quot;+&quot;){<br>            int x = stoi(stack.top());<br>            stack.pop();<br>            int y = stoi(stack.top());<br>            stack.pop();<br>            stack.push(to_string(x + y));<br>        } else if(p-&gt;data == &quot;-&quot;) {<br>            int x = stoi(stack.top());<br>            stack.pop();<br>            int y = stoi(stack.top());<br>            stack.pop();<br>            stack.push(to_string(x - y));<br>        } else if(p-&gt;data == &quot;*&quot;) {<br>            int x = stoi(stack.top());<br>            stack.pop();<br>            int y = stoi(stack.top());<br>            stack.pop();<br>            stack.push(to_string(x * y));<br>        } else if(p-&gt;data == &quot;/&quot;) {<br>            int x = stoi(stack.top());<br>            stack.pop();<br>            int y = stoi(stack.top());<br>            stack.pop();<br>            stack.push(to_string(x / y));<br>        } else {<br>            stack.push(p-&gt;data);<br>        }<br>        p = p-&gt;next;<br>    }<br>    while (!stack.empty()){<br>        cout &lt;&lt; stoi(stack.top());<br>        stack.pop();<br>    }<br>}</p><p>int main () {<br>    cout &lt;&lt; &quot;————————————&quot;&lt;&lt;&quot;\n&quot;;<br>    string s;<br>    cout &lt;&lt; &quot;请输入运算表达式：&quot;&lt;&lt;&quot;\n&quot;;<br>    cin &gt;&gt; s;<br>    LinkList test_reversepolish = new LNode;<br>    InitList(test_reversepolish);<br>    LinkList test_polish = new LNode;<br>    InitList(test_polish);</p><pre><code>Center(test_reversepolish, s);Center(test_polish, s);cout &amp;lt;&amp;lt; &amp;quot;------------------------------------&amp;quot;&amp;lt;&amp;lt;&amp;quot;\n&amp;quot;;// 波兰表达式ReverseList(test_polish);Transition(test_polish, &amp;quot;)&amp;quot;, &amp;quot;(&amp;quot;);cout &amp;lt;&amp;lt; &amp;quot;波兰表达式为：&amp;quot;;ReverseList(test_polish);TraverseList(test_polish);cout &amp;lt;&amp;lt; &amp;quot;波兰表达式计算结果为：&amp;quot;;ReverseList(test_polish);EvaulTree_polish(test_polish);cout &amp;lt;&amp;lt; &amp;quot;\n&amp;quot;&amp;lt;&amp;lt;&amp;quot;------------------------------------&amp;quot;&amp;lt;&amp;lt;&amp;quot;\n&amp;quot;;// 逆波兰表达式Transition(test_reversepolish, &amp;quot;(&amp;quot;, &amp;quot;)&amp;quot;);cout &amp;lt;&amp;lt; &amp;quot;逆波兰表达式为：&amp;quot;;TraverseList(test_reversepolish);cout &amp;lt;&amp;lt; &amp;quot;逆波兰表达式计算结果为：&amp;quot;;EvaulTree(test_reversepolish);cout &amp;lt;&amp;lt; &amp;quot;\n&amp;quot;&amp;lt;&amp;lt;&amp;quot;------------------------------------&amp;quot;&amp;lt;&amp;lt;&amp;quot;\n&amp;quot;;</code></pre><p>}<br></code></pre></p></div>]]></content>
      
      
      <categories>
          
          <category> 计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 📶线结构：字符串-数组-栈-队列 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>BF和KMP模式匹配算法</title>
      <link href="/blog/ah7arw/"/>
      <url>/blog/ah7arw/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="bbef41e6cf359255bbde71a85dc43898" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1620290726560-b77d1aa1-b7ed-4561-95b4-0e8f7e643ca9.png" width="361.5" id="Q9tj2" class="ne-image"></p><p id="c907579b64684dfce48f3205154333a3" class="ne-p"><br></p><div data-type="info" class="ne-alert"><p id="2d18b8a0f458f4ecf10e7bd1f860780f" class="ne-p"><span class="ne-text" style="background-color: #E8F7FF">在进行字符串匹配的相关程序中，看一个子串是否在一个主串里面，有著名的Brute-Force和基于此改进的KMP算法，具体学习记录如下：</span></p></div><h2 id="Ffqh8"><span class="ne-text">Brute-Force</span></h2><div class="ne-quote"><p id="8ad2578b424968bc6bd4f2ed0e0f65af" class="ne-p"><span class="ne-text">给出一个主串和一个子串</span></p><p id="8a36746aaf9610184b750791b5965c6b" class="ne-p"><span class="ne-text">主串：s = ababc</span><strong><span class="ne-text">abcac</span></strong><span class="ne-text">bab</span></p><p id="9d4d068fe6d44771c021c63e175b098e" class="ne-p"><span class="ne-text" style="background-color: transparent">子串：t = abcac</span></p></div><p id="b2dd074081afd9c9b47ccd7b9143e880" class="ne-p"><span class="ne-text">①BF算法算是一种暴力算法，首先是查看t的第一字母a和上面s的第一个字母比较相同，所以接着比较比到各自的第三个字符也就是，aba、abc发现不同，</span></p><p id="e35adca9e0bc3093c9d5f32e26b61bed" class="ne-p"><br></p><p id="131d9605c2eda9766ec9f323ff2dc55c" class="ne-p"><span class="ne-text">②再递推比较，t回到第一个字母a，这时s回到第二个字符（因为第一个字符已经比过了）相当于</span><span class="ne-text">babcabcacbab和abcac两个字符串进行比较，很明显第一个字符就不一样，</span></p><p id="edbbad2ce92acabab926dfe05a89c053" class="ne-p"><br></p><p id="d9d2e440fb580c81dfee4ebb1d516d52" class="ne-p"><span class="ne-text">③再递推比较……</span></p><p id="70fa395bcedb3156c06b512ee7064afb" class="ne-p"><br></p><p id="c94c3d9622e6711a795a02dd95dfbed1" class="ne-p"><span class="ne-text">按常理来思考，这样总能得出结果，但是在此基础上，可以有进一步的优化操作，怎么说？</span><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1617677082076-945e1a85-4b75-40ad-a413-46f7e514b7f4.jpeg" width="55" id="xbp9q" class="ne-image"></p><p id="0f257d56637c7793a108f18b7ed01bc8" class="ne-p"><span class="ne-text">在上面的第②步里面，我们总是一步一步递推，那我们能不能一次性推好几步呢？就根据已经匹配了的那串字母。</span></p><p id="ed3b2f764966d419e64c220dd62e5cc9" class="ne-p"><br></p><p id="d90f5843ceba354fcb6794586b242373" class="ne-p"><span class="ne-text">具体表现为：①已经发现是第三个字符不同，那我们就根据前面两个相同的字符（ab）推出第②步推两步，为什么根据相同的ab，第②个步骤就可以一次性走两步？</span></p><h2 id="oEgiu"><span class="ne-text">KMP算法</span></h2><h3 id="wGOpN"><span class="ne-text">算法详述</span></h3><p id="bbd5d8a2fc71893bd94dc1ffb47a3523" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1617677082076-945e1a85-4b75-40ad-a413-46f7e514b7f4.jpeg" width="55" id="tAJ2v" class="ne-image"><span class="ne-text">先学会用，理论日后再补…… 🕊</span></p><p id="8b014eafa0ce22db1682a80cc7459e40" class="ne-p"><span class="ne-text"></span></p><p id="05966fbe8ad009c95ad9f1520ce6f98c" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1620286656388-6b7c4ae0-8c01-4ae5-9451-9d17c63a23bb.png" width="362.5" id="t1z49" class="ne-image"></p><h3 id="3gIJ6"><span class="ne-text">计算next函数值</span></h3><div class="ne-quote"><p id="c45f9f063f5d4748f12a7b453abb0aa1" class="ne-p"><span class="ne-text">（3）串“ababaaababaa”的next数组为（  ）。</span></p><p id="e026a63024d856bb636b5dc3e91145c8" class="ne-p"><span class="ne-text">A．012345678999   B．012121111212   C．011234223456    D．0123012322345</span></p><p id="05cb2f2e114ba30bf170a09d1f5ab3d6" class="ne-p"><span class="ne-text">答案：C</span></p></div><p id="28778f634e9aa96ca56b29417b3a5d2a" class="ne-p"><br></p><table id="WQyby" class="ne-table" style="width: 623px"><tbody><tr style="height: 33px"><td width="75"><p id="9be41bd898970beaef453015a11fc209_p_0" class="ne-p"><span class="ne-text">j</span></p></td><td width="41"><p id="f5288918051daac58a0cdf74b1d666a8_p_0" class="ne-p"><span class="ne-text">1</span></p></td><td width="47"><p id="2437cac6ad8f03448ae403be9a3af9ed_p_0" class="ne-p"><span class="ne-text">2</span></p></td><td width="41"><p id="51d6cd746c79a513e0ce3a75ec25e3f9_p_0" class="ne-p"><span class="ne-text">3</span></p></td><td width="47"><p id="c5dca1e0e58592b0de68a15917b9aac6_p_0" class="ne-p"><span class="ne-text">4</span></p></td><td width="48"><p id="e93c6396b478003add85a5ab1354e564_p_0" class="ne-p"><span class="ne-text">5</span></p></td><td width="44"><p id="4e0a00f0fff2d08f625bcf3627cf94db_p_0" class="ne-p"><span class="ne-text">6</span></p></td><td width="50"><p id="ae427e384184b1214e0bf3f7df0a833e_p_0" class="ne-p"><span class="ne-text">7</span></p></td><td width="50"><p id="2a7b14533ca92e6ddd576c36969708ce_p_0" class="ne-p"><span class="ne-text">8</span></p></td><td width="45"><p id="af98e36da6caf2103235814d586bea93_p_0" class="ne-p"><span class="ne-text">9</span></p></td><td width="45" style="background-color: #FFFFFF"><p id="a20d224c568e48b9d67847a2c66a8c01_p_0" class="ne-p"><span class="ne-text">10</span></p></td><td width="45" style="background-color: #FFFFFF"><p id="u19987c0e" class="ne-p"><span class="ne-text">11</span></p></td><td width="45" style="background-color: #FFFFFF"><p id="ube4b3363" class="ne-p"><span class="ne-text">12</span></p></td></tr><tr style="height: 33px"><td width="75"><p id="a542bd2757409de9dfb7727ebcaf31c5_p_0" class="ne-p"><span class="ne-text">t</span></p></td><td width="41"><p id="08ca20eb36284487001463292f6550f4_p_0" class="ne-p"><span class="ne-text">a</span></p></td><td width="47"><p id="8d5efedb4fdbe061cc194fc98f15df26_p_0" class="ne-p"><span class="ne-text">b</span></p></td><td width="41"><p id="u4ba171c0" class="ne-p"><span class="ne-text">a</span></p></td><td width="47"><p id="uad8517ea" class="ne-p"><span class="ne-text">b</span></p></td><td width="48"><p id="u4fc6d17a" class="ne-p"><span class="ne-text">a</span></p></td><td width="44"><p id="u3a396665" class="ne-p"><span class="ne-text">a</span></p></td><td width="50"><p id="uea5ab139" class="ne-p"><span class="ne-text">a</span></p></td><td width="50"><p id="uf43da0d5" class="ne-p"><span class="ne-text">b</span></p></td><td width="45"><p id="u15a07baf" class="ne-p"><span class="ne-text">a</span></p></td><td width="45" style="background-color: #FFFFFF"><p id="ue0fede51" class="ne-p"><span class="ne-text">b</span></p></td><td width="45" style="background-color: #FFFFFF"><p id="u925438c3" class="ne-p"><span class="ne-text">a</span></p></td><td width="45" style="background-color: #FFFFFF"><p id="u3bc3bb00" class="ne-p"><span class="ne-text">a</span></p></td></tr><tr style="height: 33px"><td width="75"><p id="fc06ea377ed3bb2f227b8d21f4771bce_p_0" class="ne-p"><span class="ne-text">next(j)</span></p></td><td width="41"><p id="515141c761d1a2676477bcc490f86bc4_p_0" class="ne-p"><span class="ne-text">0</span></p></td><td width="47"><p id="uf33c1bad" class="ne-p"><span class="ne-text">1</span></p></td><td width="41"><p id="u6cc7fec3" class="ne-p"><span class="ne-text">1</span></p></td><td width="47"><p id="u906cf0a9" class="ne-p"><span class="ne-text">2</span></p></td><td width="48"><p id="ud7d51835" class="ne-p"><span class="ne-text">3</span></p></td><td width="44"><p id="u1ac6d524" class="ne-p"><span class="ne-text">4</span></p></td><td width="50"><p id="uf064b958" class="ne-p"><span class="ne-text">2</span></p></td><td width="50"><p id="u20960527" class="ne-p"><span class="ne-text">2</span></p></td><td width="45"><p id="u82b4e795" class="ne-p"><span class="ne-text">3</span></p></td><td width="45" style="background-color: #FFFFFF"><p id="udb52cb3c" class="ne-p"><span class="ne-text">4</span></p></td><td width="45" style="background-color: #FFFFFF"><p id="u5ec269a0" class="ne-p"><span class="ne-text">5</span></p></td><td width="45" style="background-color: #FFFFFF"><p id="u85d1d3ab" class="ne-p"><span class="ne-text">6</span></p></td></tr></tbody></table><p id="ede4828120a719212ee5f1d7947d6c20" class="ne-p"><br></p><p id="4de55acebb3d510651128eca5999d7f1" class="ne-p"><span class="ne-text">方法：</span></p><p id="ab27975aadd906abf25ea1dbd2125eb0" class="ne-p"><span class="ne-text">①next数组第一位永远是0，1；</span></p><p id="cfb93f39fdd200be46ebfeada7a0a690" class="ne-p"><span class="ne-text">②next(j) = 前序列相同元素个数 + 1；</span></p><p id="6df74f3284fc578a55db44c9c9f9d254" class="ne-p"><br></p><p id="fa5ee3ccca7aac454647436aa6cf105d" class="ne-p"><span class="ne-text">eg：当t = 6：</span></p><p id="9864edcb5890059cbb029dbc654018de" class="ne-p"><span class="ne-text">前面的序列为ababa，可以看出相同的子序列为aba，相同元素个数为3，所以next(6) = 3 + 1 = 4</span></p><p id="cf8a5f56ac58875441ad5b78ef1d2b3b" class="ne-p"><br></p><p id="c47cb9d84cbe7f19c89783788434f82b" class="ne-p"><span class="ne-text">注意：不能“全覆盖”，比如当j = 2时候，前面的a不能看成a = a序列，这样就变成next(2) = 2了；</span></p><h3 id="Lal6X"><span class="ne-text">计算next函数修正值</span></h3><div class="ne-quote"><p id="82c60e34e8efe5d73792a25711b26d07" class="ne-p"><span class="ne-text">（4）串“ababaabab”的nextval为（  ）。</span></p><p id="0d1e20f00ec873da884183137c074223" class="ne-p"><span class="ne-text">A．010104101      B．010102101      C．010100011       D．010101011  </span></p><p id="86fd109cdad34ea14d6272183b3be0c5" class="ne-p"><span class="ne-text">答案：A</span></p></div><p id="32422b3ed1271a846e5e6fb91bfc5c8c" class="ne-p"><br></p><table id="iFRJu" class="ne-table" style="width: 685px"><tbody><tr style="height: 33px"><td width="91"><p id="u0503555c" class="ne-p"><span class="ne-text">j</span></p></td><td width="58"><p id="uaffdd452" class="ne-p"><span class="ne-text">1</span></p></td><td width="67"><p id="u948458ea" class="ne-p"><span class="ne-text">2</span></p></td><td width="67"><p id="ua15993c3" class="ne-p"><span class="ne-text">3</span></p></td><td width="67"><p id="u6fe61ea3" class="ne-p"><span class="ne-text">4</span></p></td><td width="67"><p id="ubb150015" class="ne-p"><span class="ne-text">5</span></p></td><td width="67"><p id="u4fe2041a" class="ne-p"><span class="ne-text">6</span></p></td><td width="67"><p id="u22de8214" class="ne-p"><span class="ne-text">7</span></p></td><td width="67"><p id="ue55b58a5" class="ne-p"><span class="ne-text">8</span></p></td><td width="67"><p id="ua381e01f" class="ne-p"><span class="ne-text">9</span></p></td></tr><tr style="height: 33px"><td width="91"><p id="ue40b085e" class="ne-p"><span class="ne-text">t</span></p></td><td width="58"><p id="ub14b7f38" class="ne-p"><span class="ne-text">a</span></p></td><td width="67"><p id="uf8d77d0a" class="ne-p"><span class="ne-text">b</span></p></td><td width="67"><p id="u5d6d9d21" class="ne-p"><span class="ne-text">a</span></p></td><td width="67"><p id="u8f3c9d6c" class="ne-p"><span class="ne-text">b</span></p></td><td width="67"><p id="ub23d82fe" class="ne-p"><span class="ne-text">a</span></p></td><td width="67"><p id="u84ef0982" class="ne-p"><span class="ne-text">a</span></p></td><td width="67"><p id="u71711152" class="ne-p"><span class="ne-text">b</span></p></td><td width="67"><p id="uabbd99d3" class="ne-p"><span class="ne-text">a</span></p></td><td width="67"><p id="ufdaa6f7c" class="ne-p"><span class="ne-text">b</span></p></td></tr><tr style="height: 33px"><td width="91"><p id="ue4f46a92" class="ne-p"><span class="ne-text">next(j)</span></p></td><td width="58"><p id="u0d72915c" class="ne-p"><span class="ne-text">0</span></p></td><td width="67"><p id="ua6e5fb83" class="ne-p"><span class="ne-text">1</span></p></td><td width="67"><p id="ub71e39c2" class="ne-p"><span class="ne-text">1</span></p></td><td width="67"><p id="u18bd8601" class="ne-p"><span class="ne-text">2</span></p></td><td width="67"><p id="uf56335fe" class="ne-p"><span class="ne-text">3</span></p></td><td width="67"><p id="u6c9e9845" class="ne-p"><span class="ne-text">4</span></p></td><td width="67"><p id="u84ac07b9" class="ne-p"><span class="ne-text">2</span></p></td><td width="67"><p id="u197bad17" class="ne-p"><span class="ne-text">3</span></p></td><td width="67"><p id="u3050e6c5" class="ne-p"><span class="ne-text">4</span></p></td></tr><tr style="height: 33px"><td width="91"><p id="ud1bcfa0a" class="ne-p"><span class="ne-text">nextval(j)</span></p></td><td width="58"><p id="u2935a6d0" class="ne-p"><span class="ne-text">0</span></p></td><td width="67"><p id="uca5f7fff" class="ne-p"><span class="ne-text">1</span></p></td><td width="67"><p id="u8033274d" class="ne-p"><span class="ne-text">0</span></p></td><td width="67"><p id="u4018b298" class="ne-p"><span class="ne-text">1</span></p></td><td width="67"><p id="ufda5b86c" class="ne-p"><span class="ne-text">0</span></p></td><td width="67"><p id="u623694a6" class="ne-p"><span class="ne-text">4</span></p></td><td width="67"><p id="u07718737" class="ne-p"><span class="ne-text">1</span></p></td><td width="67"><p id="u24391151" class="ne-p"><span class="ne-text">0</span></p></td><td width="67"><p id="u320bd3a3" class="ne-p"><span class="ne-text">1</span></p></td></tr></tbody></table><p id="43418445725a8b1c9da02be97acc6eb0" class="ne-p"><br></p><p id="3e55a0781e7099dd7009a0f7d481b0c6" class="ne-p"><span class="ne-text">方法：</span></p><p id="2faf3d9586a9b0d8c5486e592d62e0f1" class="ne-p"><span class="ne-text">①先列举出next(j)，求nextval(j)是基于</span><span class="ne-text">next(j)的；</span></p><p id="ab7e86d247d92acbbf32773beaab474e" class="ne-p"><span class="ne-text">②</span><span class="ne-text">求nextval(j)，先看</span><span class="ne-text">求next(j)的值，记这个值为x；</span></p><p id="165ea6e5343f9d430222164c5bcf2f5f" class="ne-p"><span class="ne-text">③在表格中找出j = x的那一列，如果这一列的t值和②步骤中的t值相同，则结果为j = x这一列的</span><span class="ne-text">nextval(j)值，如果不相同，则结果为所要求的那一列的</span><span class="ne-text">next(j)值；</span></p><p id="3a0744062e0dcb3e16e2d6e3ca799b61" class="ne-p"><br></p><p id="7b1836d799fc31c6d255b45fcd52987d" class="ne-p"><span class="ne-text">eg：当j = 5时：</span></p><p id="5454822d50705ef65ed7c54c9e0d0234" class="ne-p"><span class="ne-text">此时next(j) = 3，就去j = 3那一列看到t = a，和j = 5一列的t值a相同，所以结果为j = 3一列的</span><span class="ne-text">nextval值0</span></p><p id="f88b11c1f0df00493a4fef31c0d174ab" class="ne-p"><br></p><p id="2e9d752cb16fedaf515563cf05ee8149" class="ne-p"><span class="ne-text">eg：当j = 6时：</span></p><p id="18e8aa25864872faa5c446d1bf786d16" class="ne-p"><span class="ne-text">此时next(j) = 4，就去j = 4那一列看到t = b，和j = 6一列的t值不相同，所以结果为j = 6一列的</span><span class="ne-text">next值4</span></p><h3 id="Vn5VN"><span class="ne-text">具体匹配情况</span></h3><div class="ne-quote"><p id="2bb2aa0c380cb029f331136f0bf95666" class="ne-p"><span class="ne-text">（2）设目标为t=“abcaabbabcabaacbacba”,模式为p=“abcabaa”</span></p><p id="93f6259891d767ae845e04e48379f217" class="ne-p"><span class="ne-text">① 计算模式p的naxtval函数值；</span></p><p id="52096b14ec8bfa95f285bd5cb9477dc3" class="ne-p"><span class="ne-text">② 不写出算法,只画出利用KMP算法进行模式匹配时每一趟的匹配过程。</span></p></div><p id="3e8c22d46292fd2da5b00fbae2e47a63" class="ne-p"><span class="ne-text">答案：</span></p><p id="004848556f2fb83956150623bee8d144" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1620290726560-b77d1aa1-b7ed-4561-95b4-0e8f7e643ca9.png" width="361.5" id="cwWr7" class="ne-image"></p><h3 id="LGp3i"><span class="ne-text">代码</span></h3><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;typedef int Status;typedef int ElemType;#define OVERFLOW -1#define ERROR 0#define OK 1<p>//——串的顺序存储结构—–<br>#define MAXLEN 225<br>typedef struct<br>&#123;<br>    char ch[MAXLEN + 1];    //存储串的一维数组，从下标为1的数组分量开始存储的，下标为0的分量闲置不用<br>    int length;             //串的当前长度<br>&#125;SString;</p><p>//——串的堆式顺序存储结构—–<br>typedef struct<br>&#123;<br>    char *ch;       //若是非空串，则按串长分配存储区，否则ch为NULL<br>    int length;     //串的当前长度<br>&#125;HString;</p><p>HString S, T;</p><p>//—–串的链式存储结构—–<br>#define CHUNKSIZE 80<br>typedef struct Chunk<br>&#123;<br>    char ch[CHUNKSIZE];<br>    struct Chunk *next;<br>&#125;Chunk;<br>typedef struct<br>&#123;<br>    Chunk *head, *tail;     //串的头指针和尾指针<br>    int length;             //串的当前长度<br>&#125;LString;</p><p>// //1、生成串<br>// StrAssign(&amp;T, chars)</p><p>// //2、复制<br>// StrCopy(&amp;T, S)</p><p>// //3、判空<br>// StrEmpty(S)</p><p>// //4、比较<br>// StrCompare(S, T)</p><p>// //5、长度<br>// StrLength(S)</p><p>// //6、清空<br>// ClearString(&amp;S)</p><p>// //7、联接<br>// Concat(&amp;T, S1, S2)</p><p>// //8、子串<br>// SubString(&amp;Sub, S, pos, len)</p><p>//9、串的模式匹配_BF算法 O(n * m)<br>int Index_BF(HString S, HString T, int pos)<br>&#123;//返回模式T在主串s中第pos个字符开始第一次出现的位置。若不存在，则返回值为0<br> //其中，T非空，1&lt;=pos&lt;=S.length<br>    int i = pos, j = 1;                     //初始化<br>    while(i &lt;= S.length &amp;&amp; j &lt;= T.length)   //两串均未比较到串尾<br>    &#123;<br>        if(S.ch[i] == T.ch[j])              //继续比较后继字符<br>        &#123;<br>            i++;<br>            j++;<br>        &#125;<br>        else                                //指针后退重新开始匹配<br>        &#123;<br>            i = i - j + 2;                  //i=i-j+1回到i的起点，+2到下一个字符<br>            j = 1;<br>        &#125;<br>    &#125;<br>    if(j &gt; T.length)<br>            return i - T.length;            //匹配成功，返回T在S中第一次出现的位置<br>        else<br>            return 0;<br>&#125;</p><p>//9、串的模式匹配_KMP算法求next数组<br>void get_next(HString, int next[])<br>&#123;//求模式串T的next函数值并存入数组next<br>    int j = 1, t = 0;<br>    next[1] = 0;<br>    while(j &lt; T.length)<br>    &#123;<br>        if(t == 0 || T.ch[j] == T.ch[t])<br>        &#123;<br>            t++;<br>            j++;<br>            next[j] = t;<br>        &#125;<br>        else<br>            t = next[t];<br>    &#125;<br>&#125;</p><p>//9、串的模式匹配_KMP算法求nextval数组<br>void get_nextval(HString T, int nextval[])<br>&#123;//求模式串T的next函数修正值并存入数组nextval<br>    int j = 1, t = 0;<br>    nextval[1] = 0;<br>    while(j &lt; T.length)<br>    &#123;<br>        if(t == 0 || T.ch[j] == T.ch[t])<br>        &#123;<br>            t++;<br>            j++;<br>            if(T.ch[j] != T.ch[t])<br>                nextval[j] = t;<br>            else<br>                nextval[j] = nextval[t];<br>        &#125;<br>        else<br>            t = nextval[t];<br>    &#125;<br>&#125;</p><p>//9、串的模式匹配_KMP算法 O(n + m)<br>int Index_KMP(HString S, HString T, int pos, int next[])<br>&#123;//利用模式串T的next函数求T在主串S中第pos个字符之后的位置<br> //其中，T非空，1&lt;=pos&lt;=S.length<br>    int i = pos, j = 1;<br>    while(i &lt;= S.length &amp;&amp; j &lt;= S.length)   //两个串均未比较到串尾<br>    &#123;<br>        if(j == 0 || S.ch[i] == T.ch[i])    //继续比较后继字符<br>        &#123;<br>            i++;<br>            j++;<br>        &#125;<br>        else<br>            j = next[j];                    //模式串向右移动<br>        if(j &gt; T.length)                    //匹配成功<br>            return i - T.length;<br>        else<br>            return 0;<br>    &#125;<br>&#125;</p><p>// //10、插入<br>// Strlnsert(&amp;S, pos, T) </p><p>// //11、删除<br>// StrDelete(&amp;S, pos, len)</p><p>// //12、销毁<br>// DestroyString(&amp;S)</p><p></code></pre></p><p id="da6d9a983e14a866be04369afc52bbe6" class="ne-p"><br></p><p id="4e65f666b11f7a7d080ef5f05ae814ff" class="ne-p"><br></p><p id="5bba2de59a85e9d920e75a24bd65b86e" class="ne-p"><br></p></div>]]></content>
      
      
      <categories>
          
          <category> 计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 🥢KMP类算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>《文城》——我也曾是林详福</title>
      <link href="/essay/ll4lrz/"/>
      <url>/essay/ll4lrz/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="traditional"><div class="ne-quote"><p id="efd2f302b81a26e601cfbd82b34ad478" class="ne-p" style="text-align: left"><span class="ne-text">文城（《活着》作者余华时隔8年，全新长篇重磅归来。关于一个人和他一生的寻找，以及一群人和一个汹涌的年代。他原本不属于这里，但许多人的牵挂和眼泪都留在了他身上） (余华)</span></p></div><p id="a4685e7df874bb285abef683fb9c9c66" class="ne-p" style="text-align: left"><br></p><p id="a20d224c568e48b9d67847a2c66a8c01_p_0" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2021/webp/1484158/1620263368423-1137b0d5-338f-4b67-8710-05113a05e2cf.webp" width="245" id="q1Cav" class="ne-image"></p><p id="u05a7e443" class="ne-p" style="text-align: center"><br></p><div class="ne-quote"><p id="ud1c9376b" class="ne-p"><span class="ne-text">七月三号阅读小记</span></p></div><p id="bd63ffd0b27f153328c726f955c75da8" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1625267396039-fd9ba6e0-3e18-4d2d-abf1-ac129db4ec64.png" width="1128" id="wN6zS" class="ne-image"></p><p id="da68bafe473eff9e0ca481a9669ed16e" class="ne-p"><br></p><p id="1d75b4248ebc31ca1eea816b9feb0063" class="ne-p"><br></p><p id="ua9b8fb9e" class="ne-p"><span class="ne-text"></span></p><p id="u4fea5143" class="ne-p"><span class="ne-text">- 您在位置 #275-277的标注 | 添加于 2021年4月28日星期三 下午2:27:12</span></p><p id="u5cc60fd1" class="ne-p"><br></p><div data-type="info" class="ne-alert"><p id="u53d58b19" class="ne-p"><span class="ne-text">她一边说一边笑，她的眼睛闪闪发亮，这是林祥福第一次见到小美这样的神态。一个在屋子里走动时只有木屐声响的女子，一个不会笑出声音而是将笑意含在嘴角的女子，此刻容光焕发了。</span></p></div><p id="u6596fcd9" class="ne-p"><span class="ne-text"></span></p><p id="u1ae7424c" class="ne-p"><span class="ne-text">- 您在位置 #289-289的标注 | 添加于 2021年4月28日星期三 下午2:29:19</span></p><p id="uf23a8556" class="ne-p"><br></p><div data-type="info" class="ne-alert"><p id="u74e7c20f" class="ne-p"><span class="ne-text">刚才屋顶被砸出的洞口纷纷落下来碗大的雨雹，砸到地上后犹如花开花谢。</span></p></div><p id="u31225aa6" class="ne-p"><span class="ne-text"></span></p><p id="u9ec716d1" class="ne-p"><span class="ne-text">- 您在位置 #330-330的标注 | 添加于 2021年4月28日星期三 下午2:33:05</span></p><p id="uaf1384c9" class="ne-p"><br></p><div data-type="info" class="ne-alert"><p id="u8d6dc744" class="ne-p"><span class="ne-text">“天下棺材七尺三。”</span></p></div><p id="ub564b13f" class="ne-p"><span class="ne-text"></span></p><p id="u0be77ed2" class="ne-p"><span class="ne-text">- 您在位置 #474-476的标注 | 添加于 2021年4月28日星期三 下午2:46:24</span></p><p id="uc419e439" class="ne-p"><br></p><div data-type="info" class="ne-alert"><p id="u636878f8" class="ne-p"><span class="ne-text">人生在世祸福难测，有一门技艺在身能够逢凶化吉，技艺是怎么也不会败落的。林祥福觉得自己的木工技艺应该更上一层楼，应该继续去拜师学艺。</span></p></div><p id="u6b786f38" class="ne-p"><span class="ne-text"></span></p><p id="ude3dae47" class="ne-p"><span class="ne-text">- 您在位置 #818-819的标注 | 添加于 2021年4月28日星期三 下午3:09:19</span></p><p id="u156cb9c7" class="ne-p"><br></p><div data-type="info" class="ne-alert"><p id="ucafa1f0a" class="ne-p"><span class="ne-text">晚霞在明净的天空里燃烧般通红，岸上的田地里传来耕牛回家的哞哞叫声，炊烟正在袅袅升起。</span></p></div><p id="u91bbd27f" class="ne-p"><br></p></div>]]></content>
      
      
      <categories>
          
          <category> 阅读 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>『无间道』有感</title>
      <link href="/essay/ebd5c2/"/>
      <url>/essay/ebd5c2/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="traditional"><p id="d4cd9e0b7643b178590e5bd43190a698" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1663487070433-15da28ac-1613-48b1-bd45-0cb19c946655.png" width="640" id="u2305c69a" class="ne-image"></p><p id="bca677546c40af316ec70d00c4f1f9aa" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1663487102892-a9dcfb0b-d3b5-4a73-928b-1fba8e9612b5.png" width="640" id="u49a4e274" class="ne-image"></p><p id="c79d5e3f0a39dd702d986bafe1be8a08" class="ne-p"><br></p><p id="a20d224c568e48b9d67847a2c66a8c01_p_0" class="ne-p"><span class="ne-text">上个礼拜看的，我觉得这无间道三部曲算是港片的鼻祖地位的，因为传神……</span></p><p id="8d300c677e4a9086d7e65ebf9d38463f" class="ne-p"><br></p><p id="9ecc208c16440d622ef7f65e4f3526b4" class="ne-p"><span class="ne-text">对刘建明和阿仁，我只想说，</span><strong><span class="ne-text">有的人死去，人已经解脱了，有的人，看似风生水起，实则，已堕入无间地狱</span></strong><span class="ne-text">。</span></p><p id="16c080f51d5704ddb6a9b798aba0c519" class="ne-p"><span class="ne-text"></span></p><p id="9b8f43669e12798d79692411f0d6bccb" class="ne-p"><span class="ne-text">还有一句“我只想做个好人”，初听之下就像是步入正途之下的光明大道，实则细想实在是</span><strong><span class="ne-text">鬼魅</span></strong><span class="ne-text">。</span></p><p id="d52ffb5a5b0c766efccd5acbc29d2768" class="ne-p"><br></p><p id="c4f8147964b709abdb4fd363215884b1" class="ne-p"><br></p><p id="d52ca9bbaa3f79d34d3480ea1173d8ce" class="ne-p"><span class="ne-text">这里面还有很多关于佛教的一些摘录，感觉很值得揣摩，在此摘录一番</span></p><p id="3608c9450d75ee1469f27cdb481746ca" class="ne-p"><br></p><div data-type="tips" class="ne-alert"><p id="079ef868ca01f016b633a9ece7c10a0f" class="ne-p"><span class="ne-text">《涅槃经》第十九卷</span></p><p id="be0431b93590460a95a42c30827e15ca" class="ne-p"><span class="ne-text">「八大地狱之最，称为无间地狱，为无间断遭受大苦大意，故有此名。」</span></p></div><p id="701037c1e65ccdb7be47ca7bb8536938" class="ne-p"><br></p><div data-type="tips" class="ne-alert"><p id="a6b2b87526764897fbe9410ec967ac06" class="ne-p"><span class="ne-text">「无间有三，时无间，空无间，受业无间。犯忤逆罪这永堕此界，尽受终极之无间。」</span></p></div><p id="72803a2d8e43b08ce33939c809250346" class="ne-p"><br></p><div data-type="tips" class="ne-alert"><p id="5d43979d9efd07864562fad132f591fc" class="ne-p"><span class="ne-text">地藏菩萨本愿经卷上：</span></p><p id="3db11f1ff4abe3f5955ba94113b85e13" class="ne-p"><span class="ne-text">「如是本辈，当堕无间地狱，千万亿劫，以此连绵，求出无期。」</span></p></div><p id="924afdb50df8e8613eb2e3d4133903fa" class="ne-p"><br></p><p id="f54e3ce4ddf35bc041c2c155126a2caf" class="ne-p"><br></p><p id="80e985baec561216ea9f5d5da324cf8c" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1663487117998-91c8dc3a-5b25-4c30-9ed2-1077c7aeb862.png" width="640" id="u724895c8" class="ne-image"></p></div>]]></content>
      
      
      <categories>
          
          <category> 影视 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>『DARLING in the FRANXX』</title>
      <link href="/essay/lwgmc6/"/>
      <url>/essay/lwgmc6/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content-editor-core lake-engine lake-typography-classic" data-lake-element="root" data-selection-undefined="%7B%22path%22%3A%5B%5D%2C%22active%22%3Atrue%7D"><blockquote class="lake-alert lake-alert-info" style="margin: 0px; padding: 10px; border: 1px solid rgb(171, 210, 218); opacity: 1; border-radius: 3px; color: rgb(38, 38, 38); background-color: rgb(232, 247, 255);"><p data-lake-id="eb20118c0862988d4b58e2f199067c2c" id="eb20118c0862988d4b58e2f199067c2c" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>Darling in the FranXX （比翼之吻）</span></p></blockquote><p data-lake-id="5eff8955e6a6de7fb185315726afb2ce" id="5eff8955e6a6de7fb185315726afb2ce" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="u1a39d7f3" id="u1a39d7f3" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="u7ed4fe23" id="u7ed4fe23" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>这部番我觉得从世界观的角度来说构思很新奇，贯穿全篇则为——人性。</span></p><p data-lake-id="uaf01d3d1" id="uaf01d3d1" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="u1ee6b533" id="u1ee6b533" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>世界观颠覆了以往的人类美的一面，将人类的人格寄存于“爸爸”的手掌之下，欲望促使人类的人形暴露，但同时人性的一些闪光点，也在悄然萌发。</span></p><p data-lake-id="u12f8e672" id="u12f8e672" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="u5969b72c" id="u5969b72c" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>zero two和广的爱情，就像是我之前写的『缺爱』一篇，zero two的缺爱的极端时刻，被广的光辉所拯救了，成年之际，广的失意落魄被zero two口中的darling所拯救；</span></p><p data-lake-id="ue7fba2c8" id="ue7fba2c8" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="ufb130638" id="ufb130638" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>还有心的圣母形象，忘了对满的感情和生育的知识，这是我觉得这部番里面特别重要的一个点睛之笔。</span></p><p data-lake-id="uf464e2e7" id="uf464e2e7" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="ud4dbf13a" id="ud4dbf13a" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>我们很难去理性的分析这些人物角色，但是贯穿这些的我想就是人性最为光辉的各个闪光点吧……</span></p><p data-lake-id="uc768b23e" id="uc768b23e" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="u109f29d8" id="u109f29d8" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>转载一篇文章，片中几个机体的命名——对应的都是植物</span></p><blockquote style="margin-top: 5px; margin-bottom: 5px; padding-left: 1em; margin-left: 0px; border-left: 3px solid rgb(238, 238, 238); opacity: 0.6;"><p data-lake-id="u3cf346f2" id="u3cf346f2" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><a href="https://movie.douban.com/review/9225938/" target="_blank"><span>片中几个机体的命名——对应的都是植物</span></a></p></blockquote><p data-lake-id="ue098f2ad" id="ue098f2ad" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="ub2673e7b" id="ub2673e7b" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span data-card-type="inline" data-lake-card="image" id="u4f75054a" class="lake-card-margin-top lake-card-margin-bottom"><img data-role="image" src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1619577542480-78f1ab01-405e-411c-ae14-537958ecf49e.jpeg" data-raw-src="" class="image lake-drag-image" alt="image" title="image" data-height="540px" style="visibility: visible; width: 960px;"></span></p><p data-lake-id="u417634c2" id="u417634c2" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="e2c837ea6885adf42094dfcc56db1347" id="e2c837ea6885adf42094dfcc56db1347" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span data-card-type="inline" data-lake-card="image" id="QP1th" class="lake-card-margin-top lake-card-margin-bottom"><img data-role="image" src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1619485267464-dd9642d5-df67-4a97-8419-8e5fc3a709a9.png" data-raw-src="" class="image lake-drag-image" alt="85308871_p0.png" title="85308871_p0.png" data-height="1200px" style="visibility: visible; width: 1600px;"></span></p><p data-lake-id="2afb306203f11e865bca119dc4559b91" id="2afb306203f11e865bca119dc4559b91" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span data-card-type="inline" data-lake-card="image" id="U6MD4" class="lake-card-margin-top lake-card-margin-bottom"><img data-role="image" src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1619485230506-60d08215-4e79-42cb-9ba0-d3b5681edec4.png" data-raw-src="" class="image lake-drag-image" alt="87980648_p0.png" title="87980648_p0.png" data-height="1261px" style="visibility: visible; width: 2000px;"></span></p><p data-lake-id="8cf5c9ef0277f37b37cd611a58909e65" id="8cf5c9ef0277f37b37cd611a58909e65" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span data-card-type="inline" data-lake-card="image" id="LdgD5" class="lake-card-margin-top lake-card-margin-bottom"><img data-role="image" src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1619485170602-d19ab096-b1e2-4001-a419-4e1cc1c5a8ba.jpeg" data-raw-src="" class="image lake-drag-image" alt="87883532_p0.jpg" title="87883532_p0.jpg" data-height="1040px" style="visibility: visible; width: 700px;"></span></p><p data-lake-id="f30b58723d2340e5ff523deac5fc5904" id="f30b58723d2340e5ff523deac5fc5904" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span data-card-type="inline" data-lake-card="image" id="Y2Du1" class="lake-card-margin-top lake-card-margin-bottom"><img data-role="image" src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1619485191278-d20ca434-1141-41f5-a73e-db7b54f34d4e.png?x-oss-process=image%2Fresize%2Cw_2000" data-raw-src="" class="image lake-drag-image" alt="87324495_p0.png" title="87324495_p0.png" data-height="5000px" style="visibility: visible; width: 3000px;"></span></p></div>]]></content>
      
      
      <categories>
          
          <category> 影视 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>《平凡的世界》有感</title>
      <link href="/essay/hhd57l/"/>
      <url>/essay/hhd57l/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="863f517155e0cf66b43d8d543437e9a1" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1622032253532-9007acd3-e5c9-4e15-9839-7412bf52d680.jpeg" width="350" id="gdmS8" class="ne-image"></p><p id="u9ec3384d" class="ne-p" style="text-align: left"><span class="ne-text">平凡的世界（路遥著长篇小说）</span></p><hr id="jWCqK" class="ne-hr"><p id="ueda912e9" class="ne-p"><span class="ne-text">21.06.12</span></p><p id="ua1a33424" class="ne-p"><span class="ne-text"></span></p><p id="uc053d937" class="ne-p"><span class="ne-text">经历了一件事，心碎。</span></p><p id="udcaa575c" class="ne-p"><span class="ne-text">今天的我懂得到什么叫成长，就像最后的少平那样，笔直地走向那条铁路，坚毅，成长……</span></p><p id="u98966ebf" class="ne-p"><span class="ne-text"></span></p><p id="u91c377bd" class="ne-p"><span class="ne-text">“少平，你要记得，你与其他人不一样，你是一个有另外世界的人，你的心不应该只在这，而是在远方，那个充满光的地方”</span></p><p id="u0fd6aeb5" class="ne-p"><span class="ne-text"></span></p><p id="u3204451d" class="ne-p"><span class="ne-text">这话湿了眼眶……</span></p><p id="u4f212593" class="ne-p" style="text-align: left"><br></p><hr id="nqvgI" class="ne-hr"><p id="ue48eb825" class="ne-p" style="text-align: left"><span class="ne-text">21.02.21号整理家里书架时候写的</span></p><p id="593a8a6d23a9a70a8856487c01c855c3" class="ne-p"><br></p><p id="a20d224c568e48b9d67847a2c66a8c01_p_0" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1619483066100-b7e6b34c-9232-4dda-859f-02f28ceec07c.jpeg" width="1125" id="fX4yb" class="ne-image"></p></div>]]></content>
      
      
      <categories>
          
          <category> 阅读 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>我变了吗？</title>
      <link href="/essay/ogyb5h/"/>
      <url>/essay/ogyb5h/</url>
      
        <content type="html"><![CDATA[<div class="yuque-hexo-lyrics-secret">这是加密文章！</div>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>应用层及网络应用万维网的HTTP协议</title>
      <link href="/blog/re05fo/"/>
      <url>/blog/re05fo/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h2 id="eglYS"><span class="ne-text">为什么需要应用层呢？</span></h2><p id="d5104f7caada438423b3717ef9b93288" class="ne-p"><span class="ne-text">应用层的上一层，也就是传输层其实就已经搭建好了传输信息的框架，但是为什么还需要应用层这一层，因为</span><strong><span class="ne-text">传输层传的太简单，只实现我给你传过去，不全面有不足之处，用课上老师的话说，各层的宗旨就是尽力而为，举一些传输层心有余而力不足的地方：</span></strong></p><ul class="ne-ul"><li id="0acc0f7570b3c0e5417a75fdeb9e6983"><span class="ne-text">客户端发送的是什么数据类型的文件</span></li><li id="581acc4506fb6a8a75f799fbb1dcd879"><span class="ne-text">数据的长度，传输一次的数据长度为多长，一次是否传得完？什么时候传完？（TCP的流量控制）</span></li><li id="3129068ecf6d9fd8d743db5437703910"><span class="ne-text">数据的压缩方式，服务端如何知道客户端对数据是否压缩抑或是压缩算法是什么？</span></li></ul><p id="a3ae40530a1423eca58fa2142460cd8c" class="ne-p"><br></p><p id="303a98500a5374d068fe268e5fa1a103" class="ne-p"><span class="ne-text">而对于上述三个问题，在应用层给出相应的解决方案：</span></p><p id="a085c8e41d589ed87ec5c51ef626824e" class="ne-p"><br></p><ul class="ne-ul"><li id="8d28769a5e009a3b99805b3c8b1a2ffa"><span class="ne-text">数据的类型，HTTP Header： Content-Type</span></li><li id="5dd888b6b68aaa859ca36dc9b7f38b0a"><span class="ne-text">数据的长度，HTTP Header： Content-Length</span></li><li id="f463ad19d58db7e42f4d3e370230935e"><span class="ne-text">数据的压缩方式，HTTP Header： Accept-Encoding</span></li></ul><h2 id="0LSKV"><span class="ne-text">搞清互联网和万维网主次</span></h2><p id="848f8e181e1e1eae9e4e449f6653ce70" class="ne-p"><span class="ne-text">之前上课的时候，这里一直被忽视了，有一个主次概念需要搞清楚，</span><strong><span class="ne-text">万维网（WWW）是一个网络应用，万维网应用是一种基于客户/服务器体系结构的网络应用</span></strong><span class="ne-text">『应用层的协议都是基于客户服务器方式的，即便是P2P对等通信方式，实质上也是一种特殊的客户服务器方式』</span><strong><span class="ne-text">，它是一个网络应用</span></strong><span class="ne-text">，相应地，在互联网里面，还有</span><span class="ne-text">文件传输（FTP)、电子邮件E-mail、远程登录（Telnet）等这些应用。</span><span class="ne-text">所以引用对互联网还可以说成：</span><strong><span class="ne-text">是线路、协议以及通过TCP/IP协议实现数据电子传输的硬件和软件的集合体</span></strong><span class="ne-text">。</span></p><p id="3531571023b1a92a57dce45c234d1255" class="ne-p"><br></p><p id="476b67a110c81401bc82687c6403de7c" class="ne-p"><span class="ne-text">万维网这个应用还包括一些部件：万维网浏览器，万维网服务器，玩万维网文档的格式标准，以及一个应用层协议等等，这样就将HTTP的来源就串起来了。</span></p><p id="ee7d7d54ab30969e56b58a92dba75cd4" class="ne-p"><br></p><p id="dbf21727037776ed88af3faca6d22fa1" class="ne-p"><span class="ne-text">理解了主次，再从“主”依次理解“次”</span></p><ul class="ne-ul"><li id="95736441e5fb2ac7a2376f56c0fd96c8"><span class="ne-text">先理解许多应用协议都要使用的</span><strong><span class="ne-text">域名系统（DNS）</span></strong><span class="ne-text">，这是基础中的基础</span></li><li id="29c5e23d4350feeebdbf9855ddb1fc82"><span class="ne-text">文件传送协议：具体应用就是云主机的使用吧</span></li></ul><p id="38be84c954a2fc5689252b2c4789bac5" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1618625750527-7aa85753-4d61-4400-8e86-f8f2c6ae0c41.png" width="109.5" id="YCaOz" class="ne-image"></p><ul class="ne-ul"><li id="46d301d7daca1ec195ae686bc312aebf"><span class="ne-text">远程登录协议：书上只讲了TELNET，具体应用XSHELL的SSH也是</span></li></ul><p id="e842d4a8b93c9e9a6d104ddab2d12ed8" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1618625847438-b61068f8-a3d5-43b0-8cd3-eefb3aeac42d.png" width="100" id="koiBy" class="ne-image"></p><ul class="ne-ul"><li id="0b6e902c07b0f45cfb86072d27c2b6c9"><strong><span class="ne-text">万维网及其主要协议</span></strong></li><li id="cd7e73deb034be478e6f4cfe0e1b93aa"><span class="ne-text">电子邮件</span></li></ul><p id="325eec7049007d74b9561c42a059b958" class="ne-p"><br></p><h2 id="w9vSY"><span class="ne-text">万维网是什么？有什么用？</span></h2><div class="ne-quote"><p id="12b962bab78cc1e96e78ac77f5f8e1c8" class="ne-p"><span class="ne-text">用课本的概念：万维网用链接的方式能非常方便地从互联网上的一个站点访问另一个站点（也就是所谓的“链接到另一个站点”），从而主动地按需获取丰富的信息。</span></p></div><p id="7c40e2993f984315240eabd2e49c851f" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1618626263044-e610396b-b7b5-4f11-a8f5-1499f0f7f5d8.png" width="477.5" id="BPTJ3" class="ne-image"></p><p id="c08afff16b15c0cce9ba8d6d667dddb0" class="ne-p"><span class="ne-text">要达到这样的构想，架构这样的系统需要解决哪些问题呢？</span></p><p id="06bc65dea7d96591f5d96b2b8c2805e2" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1618626404243-cf649c67-a499-46a3-a163-aad61a17c9b7.png" width="566" id="Gmaxj" class="ne-image"></p><ol class="ne-ol"><li id="13007b271ad66e84aed1f7a3b4236cc4"><span class="ne-text">利用URL</span></li><li id="46cfaf4c592f52c7ad765c16131ed883"><span class="ne-text">HTTP协议（基于TCP）</span></li><li id="6fb27a72523914ff0a353ce10907758a"><span class="ne-text">HTML：就是超文本标记语言，这里不再赘述</span></li><li id="252dfb874897ae120ce37fd620e81382"><span class="ne-text">搜索工具：搜索引擎工具，谷歌、百度……</span></li></ol><h2 id="to7JS"><span class="ne-text">HTTP协议</span></h2><h3 id="8aJXI"><span class="ne-text">HTTP的报文结构</span></h3><p id="2fb36cdb73dc4719227c4f15a619568b" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1618626839900-2a58c82a-1c27-427e-a902-6b21e3458b12.png" width="429" id="V2nrj" class="ne-image"></p><h3 id="L5msE"><span class="ne-text">请求报文实例</span></h3><p id="0c0b60cf6a71a91b10300cbbe9fe07ac" class="ne-p"><span class="ne-text">请求行中的方法，就是对所请求对象进行的操作，具体有以下一些方法：</span></p><p id="5a338f15ca4935a54a9d36cdc6df0fe7" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1618627091156-cd978f06-4e39-41ea-9652-0ceddab98bb7.png" width="341" id="zSrHY" class="ne-image"></p><p id="1543b18fe99a0e5f4f64804fcdcd28b3" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1618627123440-4ed5d351-96a7-4228-a9fe-aaff7e5bb9e2.png" width="474.5" id="crkmI" class="ne-image"></p><p id="e14d60dd756dc70e202c5479b323a164" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1618627710005-1577f282-ff85-4fd2-a6ae-51187928044e.png" width="442.5" id="sW7Mj" class="ne-image"></p><p id="123d8d70ed726a26db301addb5a6c6af" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1618627722921-07c819d7-b873-4644-8cb0-844ff27450d0.png" width="414" id="w3y6P" class="ne-image"></p><p id="12b86c7270c3e6472753afa85275a373" class="ne-p"><span class="ne-text">具体在浏览器的显示为：</span></p><p id="e054b5c596e564117ba8aedd01f6ed3e" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1618627622010-49ba1876-a555-41a6-85b6-f23bc458ac82.png" width="624" id="mlIDO" class="ne-image"></p><p id="6f64df2c40ae71196368903404adfb29" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1618627640727-1204203a-4f3e-4fff-a388-fa47224fd7a0.png" width="618.5" id="DJDi5" class="ne-image"></p><h3 id="4nTpJ"><span class="ne-text">本地存储和Cookie</span></h3><p id="95a70d5098ff005a5099ad0291933f6b" class="ne-p"><span class="ne-text">自己搭建个人网站的时候，有这么一个功能，</span></p><p id="842ad0d38510d250834aed05aab39b3e" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1618627885598-f7d86695-ab4b-47b1-84de-1f7131daf095.png" width="960" id="LcLA1" class="ne-image"></p><p id="9a8e21d715e2818bbe49ce1861e221d1" class="ne-p"><span class="ne-text">对用户在本地浏览器里面点击这个伸缩布局按钮，下一次再打开网站，浏览器会记住这个布局，我是使用的localSession这个对象方法，因为是静态网站，这样实现还是比较友好的</span><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1618628002219-e1725906-d456-4930-bba7-cc800938c02f.png" width="960" id="sVhQJ" class="ne-image"></p><p id="370b9b001740e9c98903fa9bfb647684" class="ne-p"><span class="ne-text">这是静态站点使用的友好方式，比较灵活的还有Cookie方式，特别是在动态网站的搭建过程中。</span></p><p id="00cabe344e8430db30acf5ec4a56db79" class="ne-p"><span class="ne-text">在Node.js框架Express里面利用“</span><span class="ne-text">express-session</span><span class="ne-text">”插件来使用Cookie。</span></p><p id="95cf757c966b97a1bb048ed21b7ca9c9" class="ne-p"><br></p><ul class="ne-ul"><li id="61cf0bad5bbc5b0da962c4418ac4e03b"><span class="ne-text">Cookie会记录客户端和服务端之间的信息</span></li><li id="d01cdf4dafe2204a182ecc1eed464ff5"><span class="ne-text">每次请求都会默认携带Cookie</span></li><li id="a6254f43bc5f5055478aea9d23a90bfc"><span class="ne-text">会被加密，安全</span></li></ul><p id="dd068003f7ac215177018bb30fd03783" class="ne-p"><span class="ne-text">关于安全问题，课本上的表述是这样的：</span></p><p id="4a2c4cec13e5c675a3beac303246bb7b" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1618628510004-3df5120d-f238-4a6c-9dc8-e9c803283163.png" width="465.5" id="hPBY6" class="ne-image"></p><p id="491b384fb9c7fc0225367cde0910181a" class="ne-p"><br></p><h2 id="59BBL"><span class="ne-text">参考</span></h2><ul class="ne-ul"><li id="fb3d200ff22f63429e8f4ddfe04cddff"><span class="ne-text">《计算机网络》第7版——谢希仁</span></li><li id="6679e4b30fd24962320d3ace093d7526"><a href="https://www.html.cn/qa/other/21226.html" data-href="https://www.html.cn/qa/other/21226.html" target="_blank" class="ne-link"><span class="ne-text">万维网和互联网的区别是什么？</span></a></li><li id="c5f068bcea7d8b66f2fd8474f1248623"><a href="https://www.zhihu.com/question/368324676/answer/988997873" data-href="https://www.zhihu.com/question/368324676/answer/988997873" target="_blank" class="ne-link"><span class="ne-text">为什么需要，以及如何设计应用层协议？</span></a></li><li id="fd5da6f3aeb1a5557fc24e6d3c75a7a4"><a href="https://blog.csdn.net/u010076558/article/details/17620719" data-href="https://blog.csdn.net/u010076558/article/details/17620719" target="_blank" class="ne-link"><span class="ne-text">几种远程控制协议</span></a></li></ul></div>]]></content>
      
      
      <categories>
          
          <category> 计算机素养 </category>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>实验4——超市排队机🔖队列</title>
      <link href="/blog/zgiaxv/"/>
      <url>/blog/zgiaxv/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h2 id="20T4y"><span class="ne-text">实验任务</span></h2><p id="9f9b98eac38d19e538b42d7746c04a9f" class="ne-p"><span class="ne-text">    实验4：队列的链式表示和实现</span></p><p id="7f5ef7b6fb7c14232a9d0715d945ae8e" class="ne-p"><span class="ne-text">    要求：某小超市有两个排队机，构建2个用带头结点的单链表队列QA和QB, 实现下列操作</span></p><p id="61513287fe3e2922bdd79107f0ef3355" class="ne-p"><span class="ne-text">        1、初始化队列(清空)；</span></p><p id="e318417a78d41bdc35b2fb51fea54408" class="ne-p"><span class="ne-text">        2、入队；</span></p><p id="66ab82335f33a8cb72f8a7d37f44777b" class="ne-p"><span class="ne-text">        3、出队;</span></p><p id="c16c943dd4288a72dd6b295bfa0377bf" class="ne-p"><span class="ne-text">        4、求队列长度；</span></p><p id="10fe96031b21a32c13c6097ae020e25f" class="ne-p"><span class="ne-text">        5、判断队列是否为空；</span></p><p id="ae0a391b09cffe7a9126f70818e56eda" class="ne-p"><span class="ne-text">        6、判断队列是否为满；</span></p><p id="9e5d1dae28859a8abeca1d0471446006" class="ne-p"><span class="ne-text">        7、对于队列QA和QB，如果其中一个队列的售货员下班，则自动甩到另一个队列后面。</span></p><p id="5e9cc15a80111b6a597cc9e255190af3" class="ne-p"><span class="ne-text">截止日期：4月22日</span></p><p id="u7db2feae" class="ne-p"><span class="ne-text"></span></p><h2 id="14MhD"><span class="ne-text">实验讨论</span></h2><p id="2e010ce1f965a4edb43b07e76023f987" class="ne-p"><br></p><div data-type="info" class="ne-alert"><p id="87dfb2648de3a04b1bf58824421fe863" class="ne-p"><span class="ne-text">觉得问题里面有bug</span></p></div><p id="06843150f7061a5692c3cab91b34abaf" class="ne-p"><br></p><p id="d94608e0b1b127fba7a074eb3c24a11b" class="ne-p"><span class="ne-text">对问题判满的疑惑与解决，第六个问题对链对判满是否有意义，如果是链式存储，数据结构本身判断满没有意义，但是考虑到是小型超市，超市空间不大，所以对其进行一开始的用户自己输入两个队列的最大长度。</span></p><p id="b46ce36306c0795c661082ae93333276" class="ne-p"><br></p><p id="d1dc74f717ac959b4fe6f310f217fb61" class="ne-p"><span class="ne-text">但是这样又有一个问题，在问题7中，如果一个队列的售货员下班了，这个队列的所有人排到另一个队列中，那如果新队列的长度超出用户输入的队列最大长度呢？考虑到实际问题，这个问题不打算解决了，让他们挤挤……</span></p><h2 id="yLU1H"><span class="ne-text">代码代码</span></h2><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;<p>typedef int Status;<br>typedef int QElemType;</p><p>#define OVERFLOW -1<br>#define ERROR 0<br>#define OK 1</p><p>/**<br>    实验4：队列的链式表示和实现<br>    要求：某小超市有两个排队机，构建2个用带头结点的单链表队列QA和QB, 实现下列操作<br>        1、初始化队列(清空)；<br>        2、入队；<br>        3、出队;<br>        4、求队列长度；<br>        5、判断队列是否为空；<br>        6、判断队列是否为满；<br>        7、对于队列QA和QB，如果其中一个队列的售货员下班，则自动甩到另一个队列后面。</p><p> */</p><p>/* 存储形式 */<br>typedef struct QNode&#123; //链队用的结点<br>    QElemType data;<br>    struct QNode *next;<br>&#125;QNode,*QueuePtr;</p><p>typedef struct &#123;<br>    QueuePtr front;<br>    QueuePtr rear;<br>&#125;LinkQueue;</p><p>/* 初始化 */<br>Status InitQueue(LinkQueue &amp;queue) &#123;<br>    queue.front = queue.rear = new QNode;<br>    queue.front-&gt;next = NULL;<br>    return OK;<br>&#125;</p><p>/* 求队列长度 */<br>Status QueueLength(LinkQueue &amp;queue) &#123;<br>    int count = 0;<br>    if (queue.rear == queue.front) &#123;<br>        return count;<br>    &#125;<br>    QueuePtr temp = queue.front;<br>    while (temp != queue.rear) &#123;<br>        count++;<br>        temp = temp-&gt;next;<br>    &#125;<br>    return count;<br>&#125;</p><p>/* 入队 */<br>Status EnQueue(LinkQueue &amp;queue, QElemType e, int length) &#123;<br>    if (QueueLength(queue) &lt;length) &#123;<br>        QueuePtr temp = new QNode;<br>        temp-&gt;data = e;<br>        temp-&gt;next = NULL;<br>        queue.rear-&gt;next = temp;<br>        queue.rear = temp;<br>        return OK;<br>    &#125; else &#123;<br>        cout &lt;&lt; &quot;队已经满了，不能再入元素了&quot;&lt;&lt; &quot;\n&quot;;<br>        return ERROR;<br>    &#125;<br>&#125;</p><p>/* 出队 */<br>Status DeQueue(LinkQueue &amp;queue) &#123;<br>    if (queue.front == queue.rear) &#123;<br>        return OVERFLOW;<br>    &#125;<br>    // 有必要定义一个p，不然头结点会掉<br>    QueuePtr p = queue.front-&gt;next;<br>    QElemType e = p-&gt;data;<br>    queue.front-&gt;next = p-&gt;next;<br>    // 考虑最后一个元素被删，队尾指针指向头结点<br>    if (queue.rear == p) &#123;<br>        queue.rear = queue.front;<br>    &#125;<br>    return e;<br>&#125;</p><p>/* 取队头元素 */<br>// Status GetHead(LinkQueue &amp;queue) &#123;<br>//     if (queue.front != queue.rear)&#123;<br>//         return queue.front-&gt;next-&gt;data;<br>//     &#125;<br>// &#125;</p><p>/* 判断队列是否为空 */<br>bool QueueIsEmpty(LinkQueue &amp;queue) &#123;<br>    if (queue.rear == queue.front) &#123;<br>        return true;<br>    &#125; else &#123;<br>        return false;<br>    &#125;<br>&#125;</p><p>/**</p><ul><li>判断队列是否为满</li><li>不是很理解为什么链队需要判断是否为满呢？</li><li>采用输入链队长度，利用链队函数来判断</li><li>那么入队的代码需要输入length参数来判断是否还能让元素入队</li><li>/<br>bool QueueIsFull(LinkQueue &amp;queue, int length) &#123;<br>  if (QueueLength(queue) == length) &#123;<pre><code>  return true;</code></pre>  } else {<pre><code>  return false;</code></pre>  }<br>}</li></ul><p>/* 一个队列甩到另一个队列 */<br>Status QueueMove(LinkQueue &amp;queue_delete,LinkQueue &amp;queue_add) {<br>    queue_add.rear-&gt;next = queue_delete.front-&gt;next;<br>    queue_add.rear = queue_delete.rear;<br>    return OK;<br>}</p><p>/* 遍历查看队列元素 */<br>Status DisplayQueue(LinkQueue &amp;queue) {<br>    LinkQueue L = queue;<br>    while (L.front-&gt;next != NULL) {<br>        cout &lt;&lt; L.front-&gt;next-&gt;data &lt;&lt; &quot; &quot;;<br>        L.front = L.front-&gt;next;<br>    }<br>    cout &lt;&lt; &quot;\n&quot;;<br>    return OK;<br>}</p><p>int main() {</p><pre><code>cout&amp;lt;&amp;lt;&amp;quot;------------------------链队菜单----------------------&amp;quot;&amp;lt;&amp;lt;&#39;\n&#39;;cout&amp;lt;&amp;lt;&amp;quot;操作0：退出程序&amp;quot;&amp;lt;&amp;lt;&#39;\n&#39;;cout&amp;lt;&amp;lt;&amp;quot;操作1：初始化两队列&amp;quot;&amp;lt;&amp;lt;&#39;\n&#39;;cout&amp;lt;&amp;lt;&amp;quot;操作2：入队操作&amp;quot;&amp;lt;&amp;lt;&#39;\n&#39;;cout&amp;lt;&amp;lt;&amp;quot;操作3：出队操作&amp;quot;&amp;lt;&amp;lt;&#39;\n&#39;;cout&amp;lt;&amp;lt;&amp;quot;操作4：判断判断链队是否为空&amp;quot;&amp;lt;&amp;lt;&#39;\n&#39;;cout&amp;lt;&amp;lt;&amp;quot;操作5：判断判断链队是否为满&amp;quot;&amp;lt;&amp;lt;&#39;\n&#39;;cout&amp;lt;&amp;lt;&amp;quot;操作6：售货员偷懒选项&amp;quot;&amp;lt;&amp;lt;&#39;\n&#39;;cout&amp;lt;&amp;lt;&amp;quot;操作7：查看队列&amp;quot;&amp;lt;&amp;lt;&#39;\n&#39;;cout&amp;lt;&amp;lt;&amp;quot;操作8：求队列长度&amp;quot;&amp;lt;&amp;lt;&#39;\n&#39;;cout&amp;lt;&amp;lt;&amp;quot;--------------------------------------------------------&amp;quot;&amp;lt;&amp;lt;&#39;\n&#39;;int a, length,flag = 1;cout &amp;lt;&amp;lt; &amp;quot;请输入你希望排队机最多能排的人数：&amp;quot;&amp;lt;&amp;lt;&amp;quot;\n&amp;quot;&amp;lt;&amp;lt;&amp;quot;\n&amp;quot;;cin &amp;gt;&amp;gt; length;LinkQueue QA,QB;while(flag)&#123;    cout&amp;lt;&amp;lt;&#39;\n&#39;&amp;lt;&amp;lt;&amp;quot;请选择要执行的操作：&amp;quot;;    while(cin&amp;gt;&amp;gt;a)    &#123;        if(a &amp;lt; 0 || a &amp;gt; 8)            cout&amp;lt;&amp;lt;&amp;quot;请选择正确操作编号：&amp;quot;;        else            break;    &#125;    switch(a)    &#123;        case 0:        &#123;            cout&amp;lt;&amp;lt;&amp;quot;正在退出程序中……&amp;quot;&amp;lt;&amp;lt;&#39;\n&#39;;            flag = 0;            break;        &#125;        case 1:        &#123;            cout&amp;lt;&amp;lt;&amp;quot;初始化QA、QB队列中……&amp;quot;&amp;lt;&amp;lt;&#39;\n&#39;;            InitQueue(QA);            InitQueue(QB);            break;        &#125;        case 2:        &#123;            cout&amp;lt;&amp;lt;&amp;quot;请输入入队的队列（QA输入1，QB输入2）&amp;quot;&amp;lt;&amp;lt;&#39;\n&#39;;            int select_queue;            cin &amp;gt;&amp;gt; select_queue;            if (select_queue == 1) &#123;                cout&amp;lt;&amp;lt;&amp;quot;请输入入QA队的队列的元素&amp;quot;&amp;lt;&amp;lt;&#39;\n&#39;;                int select_queue_A;                cin &amp;gt;&amp;gt; select_queue_A;                EnQueue(QA, select_queue_A, length);            &#125; else if (select_queue == 2) &#123;                cout&amp;lt;&amp;lt;&amp;quot;请输入入QB队的队列的元素&amp;quot;&amp;lt;&amp;lt;&#39;\n&#39;;                int select_queue_B;                cin &amp;gt;&amp;gt; select_queue_B;                EnQueue(QB, select_queue_B, length);            &#125; else &#123;                cout &amp;lt;&amp;lt; &amp;quot;输入有误！&amp;quot;&amp;lt;&amp;lt; &amp;quot;\n&amp;quot;;            &#125;            break;        &#125;        case 3:        &#123;            cout&amp;lt;&amp;lt;&amp;quot;请输入需要出队的队列（QA输入1，QB输入2）&amp;quot;&amp;lt;&amp;lt;&#39;\n&#39;;            int select_queue;            cin &amp;gt;&amp;gt; select_queue;            if (select_queue == 1) &#123;                DeQueue(QA);            &#125; else if (select_queue == 2) &#123;                DeQueue(QB);            &#125; else &#123;                cout &amp;lt;&amp;lt; &amp;quot;输入有误！&amp;quot;&amp;lt;&amp;lt; &amp;quot;\n&amp;quot;;            &#125;            break;        &#125;        case 4:        &#123;            cout&amp;lt;&amp;lt;&amp;quot;请输入需要判空的队列（QA输入1，QB输入2）&amp;quot;&amp;lt;&amp;lt;&#39;\n&#39;;            int select_queue;            cin &amp;gt;&amp;gt; select_queue;            if (select_queue == 1) &#123;                cout &amp;lt;&amp;lt; &amp;quot;QA队列为空吗？&amp;quot;&amp;lt;&amp;lt; boolalpha &amp;lt;&amp;lt; QueueIsEmpty(QA) &amp;lt;&amp;lt; &amp;quot;\n&amp;quot;;            &#125; else if (select_queue == 2) &#123;                cout &amp;lt;&amp;lt; &amp;quot;QB队列为空吗？&amp;quot;&amp;lt;&amp;lt; boolalpha &amp;lt;&amp;lt; QueueIsEmpty(QB) &amp;lt;&amp;lt; &amp;quot;\n&amp;quot;;            &#125; else &#123;                cout &amp;lt;&amp;lt; &amp;quot;输入有误！&amp;quot;&amp;lt;&amp;lt; &amp;quot;\n&amp;quot;;            &#125;            break;        &#125;        case 5:        &#123;            cout&amp;lt;&amp;lt;&amp;quot;请输入需要判满的队列（QA输入1，QB输入2）&amp;quot;&amp;lt;&amp;lt;&#39;\n&#39;;            int select_queue;            cin &amp;gt;&amp;gt; select_queue;            if (select_queue == 1) &#123;                cout &amp;lt;&amp;lt; &amp;quot;QA队列为满吗？&amp;quot;&amp;lt;&amp;lt; boolalpha &amp;lt;&amp;lt; QueueIsFull(QA,length) &amp;lt;&amp;lt; &amp;quot;\n&amp;quot;;            &#125; else if (select_queue == 2) &#123;                cout &amp;lt;&amp;lt; &amp;quot;QB队列为满吗？&amp;quot;&amp;lt;&amp;lt; boolalpha &amp;lt;&amp;lt; QueueIsFull(QB,length) &amp;lt;&amp;lt; &amp;quot;\n&amp;quot;;            &#125; else &#123;                cout &amp;lt;&amp;lt; &amp;quot;输入有误！&amp;quot;&amp;lt;&amp;lt; &amp;quot;\n&amp;quot;;            &#125;            break;        &#125;        case 6:        &#123;            cout&amp;lt;&amp;lt;&amp;quot;请输入下班的售货员（QA输入1，QB输入2）&amp;quot;&amp;lt;&amp;lt;&#39;\n&#39;;            int select_queue;            cin &amp;gt;&amp;gt; select_queue;            if (select_queue == 1) &#123;                QueueMove(QA, QB);            &#125; else if (select_queue == 2) &#123;                QueueMove(QB, QA);            &#125; else &#123;                cout &amp;lt;&amp;lt; &amp;quot;输入有误！&amp;quot;&amp;lt;&amp;lt; &amp;quot;\n&amp;quot;;            &#125;            break;        &#125;        case 7:        &#123;            cout&amp;lt;&amp;lt;&amp;quot;请输入要查看的队列（QA输入1，QB输入2）&amp;quot;&amp;lt;&amp;lt;&#39;\n&#39;;            int select_queue;            cin &amp;gt;&amp;gt; select_queue;            if (select_queue == 1) &#123;                DisplayQueue(QA);            &#125; else if (select_queue == 2) &#123;                DisplayQueue(QB);            &#125; else &#123;                cout &amp;lt;&amp;lt; &amp;quot;输入有误！&amp;quot;&amp;lt;&amp;lt; &amp;quot;\n&amp;quot;;            &#125;            break;        &#125;        case 8:        &#123;            cout&amp;lt;&amp;lt;&amp;quot;请输入要查看的队列的长度（QA输入1，QB输入2）&amp;quot;&amp;lt;&amp;lt;&#39;\n&#39;;            int select_queue;            cin &amp;gt;&amp;gt; select_queue;            if (select_queue == 1) &#123;                cout&amp;lt;&amp;lt;QueueLength(QA)&amp;lt;&amp;lt; &amp;quot;\n&amp;quot;;            &#125; else if (select_queue == 2) &#123;                cout&amp;lt;&amp;lt;QueueLength(QB)&amp;lt;&amp;lt; &amp;quot;\n&amp;quot;;            &#125; else &#123;                cout &amp;lt;&amp;lt; &amp;quot;输入有误！&amp;quot;&amp;lt;&amp;lt; &amp;quot;\n&amp;quot;;            &#125;            break;        &#125;    &#125;&#125;</code></pre><p>}<br></code></pre></p></div>]]></content>
      
      
      <categories>
          
          <category> 计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 📶线结构：字符串-数组-栈-队列 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++队列顺序和链式实现及操作</title>
      <link href="/blog/fbfgft/"/>
      <url>/blog/fbfgft/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h2 id="noBws"><span class="ne-text">顺序循环队列</span></h2><p id="u38c4a437" class="ne-p"><br></p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;<p>typedef int Status;<br>typedef int QElemType;</p><p>#define OVERFLOW -1<br>#define ERROR 0<br>#define OK 1<br>#define MAXSIZE 100</p><p>/**</p><ul><li>循环队列——队列的顺序表示和实现</li><li></li><li>操作：初始化、队列长度、入队、出队、取队头元素</li><li>/</li></ul><p>/* 存储形式 */<br>typedef struct &#123;<br>    QElemType *base;<br>    int front;<br>    int rear;<br>&#125; SqQueue;</p><p>/* 初始化 */<br>Status InitQueue(SqQueue &amp;queue) &#123;<br>    // 初始化这个base地址为一个有最大容量的数组初地址<br>    queue.base = new int[MAXSIZE];<br>    if (!queue.base) &#123;<br>        return OVERFLOW;<br>    &#125;<br>    queue.front = queue.rear = 0;<br>    return OK;<br>&#125;</p><p>/* 求队列长度 */<br>Status QueueLength(SqQueue &amp;queue) &#123;<br>    return (queue.rear - queue.front + MAXSIZE) % MAXSIZE;<br>&#125;</p><p>/* 入队 */<br>Status EnQueue(SqQueue &amp;queue, QElemType e) &#123;<br>    if ((queue.rear+1)%MAXSIZE == queue.front) &#123;<br>        return OVERFLOW;<br>    &#125;<br>    queue.base[queue.rear] = e;<br>    queue.rear = (queue.rear + 1) % MAXSIZE;<br>    return OK;<br>&#125;</p><p>/* 出队 */<br>Status DeQueue(SqQueue &amp;queue) &#123;<br>    if ((queue.rear+1)%MAXSIZE == queue.front) &#123;<br>        return OVERFLOW;<br>    &#125;<br>    QElemType e = queue.base[queue.front];<br>    queue.front = (queue.front + 1) % MAXSIZE; //队头指针+1<br>    return e;<br>&#125;</p><p>/* 取队头元素 */<br>Status GetHead(SqQueue &amp;queue) &#123;<br>    if (queue.front != queue.rear) &#123;<br>        return queue.base[queue.front];<br>    &#125;<br>&#125;</p><p>int main() &#123;<br>    SqQueue test;<br>    InitQueue(test);<br>    EnQueue(test, 10);<br>    EnQueue(test, 15);<br>    EnQueue(test, 20);<br>    cout &lt;&lt; &quot;队列长度为：&quot; &lt;&lt; QueueLength(test) &lt;&lt; &quot;\n&quot;;<br>    cout &lt;&lt; GetHead(test)&lt;&lt;&quot; &quot;&lt;&lt; GetHead(test)&lt;&lt;&quot; &quot;&lt;&lt; GetHead(test)&lt;&lt;&quot; &quot;&lt;&lt;&quot;\n&quot;;<br>    cout &lt;&lt; DeQueue(test)&lt;&lt;&quot; &quot;&lt;&lt; DeQueue(test)&lt;&lt;&quot; &quot;&lt;&lt; DeQueue(test)&lt;&lt;&quot; &quot;&lt;&lt;&quot;\n&quot;;<br>&#125;<br></code></pre></p><h2 id="ntYcn"><span class="ne-text">链队</span></h2><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;<p>typedef int Status;<br>typedef int QElemType;</p><p>#define OVERFLOW -1<br>#define ERROR 0<br>#define OK 1<br>#define MAXSIZE 100</p><p>/**</p><ul><li>链队——队列的链式表示和实现</li><li></li><li>操作：初始化、入队、出队、取队头元素</li><li>/</li></ul><p>/* 存储形式 */<br>typedef struct QNode&#123; //链队用的结点<br>    QElemType data;<br>    struct QNode *next;<br>&#125;QNode,*QueuePtr;</p><p>typedef struct &#123;<br>    QueuePtr front;<br>    QueuePtr rear;<br>&#125;LinkQueue;</p><p>/* 初始化 */<br>Status InitQueue(LinkQueue &amp;queue) &#123;<br>    queue.front = queue.rear = new QNode;<br>    queue.front-&gt;next = NULL;<br>    return OK;<br>&#125;</p><p>/* 入队 */<br>Status EnQueue(LinkQueue &amp;queue, QElemType e) &#123;<br>    QueuePtr temp = new QNode;<br>    temp-&gt;data = e;<br>    temp-&gt;next = NULL;<br>    queue.rear-&gt;next = temp;<br>    queue.rear = temp;<br>    return OK;<br>&#125;</p><p>/* 出队 */<br>Status DeQueue(LinkQueue &amp;queue) &#123;<br>    if (queue.front == queue.rear) &#123;<br>        return OVERFLOW;<br>    &#125;<br>    QElemType e = queue.front-&gt;next-&gt;data;<br>    queue.front-&gt;next = queue.front-&gt;next-&gt;next;<br>    // 考虑最后一个元素被删，队尾指针指向头结点<br>    if (queue.rear == queue.front) &#123;<br>        queue.front = queue.rear;<br>    &#125;<br>    return e;<br>&#125;</p><p>/* 取队头元素 */<br>Status GetHead(LinkQueue &amp;queue) &#123;<br>    if (queue.front != queue.rear)&#123;<br>        return queue.front-&gt;next-&gt;data;<br>    &#125;<br>&#125;</p><p>int main() &#123;<br>    LinkQueue test;<br>    InitQueue(test);<br>    EnQueue(test, 10);<br>    EnQueue(test, 15);<br>    EnQueue(test, 20);<br>    // cout &lt;&lt; &quot;队列长度为：&quot; &lt;&lt; QueueLength(test) &lt;&lt; &quot;\n&quot;;<br>    cout &lt;&lt; GetHead(test)&lt;&lt;&quot; &quot;&lt;&lt; GetHead(test)&lt;&lt;&quot; &quot;&lt;&lt; GetHead(test)&lt;&lt;&quot; &quot;&lt;&lt;&quot;\n&quot;;<br>    cout &lt;&lt; DeQueue(test)&lt;&lt;&quot; &quot;&lt;&lt; DeQueue(test)&lt;&lt;&quot; &quot;&lt;&lt; DeQueue(test)&lt;&lt;&quot; &quot;&lt;&lt;&quot;\n&quot;;<br>&#125;<br></code></pre></p></div>]]></content>
      
      
      <categories>
          
          <category> 计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 📶线结构：字符串-数组-栈-队列 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++栈顺序和链式实现及操作</title>
      <link href="/blog/tlzqah/"/>
      <url>/blog/tlzqah/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="a20d224c568e48b9d67847a2c66a8c01_p_0" class="ne-p"><br></p><div data-type="info" class="ne-alert"><p id="179d6501b149bd3789fe38d726e29887" class="ne-p"><span class="ne-text">存储形式以及操作和顺序表和链表差不多，需要的操作也少，学栈和队列，感觉只是抽离出来这两种便于在应用层面使用</span></p></div><h2 id="GFKJm"><span class="ne-text">顺序栈</span></h2><pre><code>#include&lt;bits/stdc++.h&gt;typedef int Status;typedef int SElemType;#define OVERFLOW -1#define ERROR 0#define OK 1#define MAXSIZE 100<p>using namespace std;<br>/**</p><ul><li>顺序栈</li><li></li><li>顺序栈的基本操作：初始化、入栈、出栈、取栈顶元素</li><li>/</li></ul><p>/* 顺序栈的存储形式 */<br>typedef struct &#123;<br>    SElemType *base;<br>    SElemType *top;<br>    int stacksize;<br>&#125; SqStack;</p><p>/* 初始化 */<br>Status InitSqStack(SqStack &amp;stack) &#123;<br>    // 为栈分配容量<br>    stack.base = new int[MAXSIZE];<br>    // 分配失败返回失败值<br>    if (!stack.base) &#123;<br>        return OVERFLOW;<br>    &#125;<br>    // 让栈顶地址初始为栈底地址<br>    stack.top = stack.base;<br>    // 初始化容量<br>    stack.stacksize = MAXSIZE;<br>    return OK;<br>&#125;</p><p>/* 入栈 */<br>Status Push(SqStack &amp;stack, SElemType e) &#123;<br>    if (stack.top - stack.base == stack.stacksize) &#123;<br>        return OVERFLOW;<br>    &#125;<br>    *stack.top = e; // 先在top位置赋值<br>    stack.top++; // 将top地址++<br>    return OK;<br>&#125;</p><p>/* 出栈 */<br>Status Pop(SqStack &amp;stack) &#123;<br>    // 空栈返回异常<br>    if (stack.top == stack.base) &#123;<br>        return OVERFLOW;<br>    &#125;<br>    stack.top–; // 栈顶地址减1<br>    return *stack.top; // 返回此时“栈顶”元素<br>&#125;</p><p>/* 取栈顶元素 */<br>Status GetTop (SqStack &amp;stack) &#123;<br>    // 空栈返回异常<br>    if (stack.top == stack.base) &#123;<br>        return OVERFLOW;<br>    &#125;<br>    // stack.top–; // 栈顶地址减1，这是和出栈的区别<br>    return *(stack.top-1); // 返回此时“栈顶”元素<br>&#125;</p><p>int main() &#123;<br>    SqStack test;<br>    InitSqStack(test);<br>    Push(test, 10);<br>    Push(test, 15);<br>    Push(test, 20);<br>    cout &lt;&lt; GetTop(test)&lt;&lt;&quot; &quot;&lt;&lt; GetTop(test)&lt;&lt;&quot; &quot;&lt;&lt; GetTop(test)&lt;&lt;&quot; &quot;&lt;&lt;&quot;\n&quot;;<br>    cout &lt;&lt; Pop(test)&lt;&lt;&quot; &quot;&lt;&lt; Pop(test)&lt;&lt;&quot; &quot;&lt;&lt; Pop(test)&lt;&lt;&quot; &quot;&lt;&lt;&quot;\n&quot;;<br>&#125;<br></code></pre></p><h2 id="aheiA"><span class="ne-text">链栈</span></h2><pre><code>#include&lt;bits/stdc++.h&gt;typedef int Status;typedef int SElemType;#define OVERFLOW -1#define ERROR 0#define OK 1#define MAXSIZE 100<p>using namespace std;<br>/**</p><ul><li>链栈</li><li></li><li>链栈的基本操作：初始化、入栈、出栈、取栈顶元素</li><li>/</li></ul><p>/* 链栈的存储形式 */<br>typedef struct StackNode&#123;<br>    SElemType data;<br>    struct StackNode *next;<br>&#125; StackNode, *LinkStack;</p><p>/**</p><ul><li>初始化</li><li>不设头结点</li><li>/<br>Status InitLinkStack(LinkStack &amp;stack) &#123;<br>  stack = NULL; // 栈顶元素置空<br>  return OK;<br>&#125;</li></ul><p>/* 入栈 */<br>Status Push(LinkStack &amp;stack, SElemType e) &#123;<br>    // 不能用LinkStack这样声明结点变量，需要new一个内存空间<br>    LinkStack temp = new StackNode;<br>    temp-&gt;data = e;<br>    temp-&gt;next = stack;<br>    stack = temp;<br>    return OK;<br>&#125;</p><p>/* 出栈 */<br>Status Pop (LinkStack &amp;stack) &#123;<br>    SElemType i = stack-&gt;data;<br>    stack = stack-&gt;next;<br>    return i;<br>&#125;</p><p>/* 取栈顶元素 */<br>Status GetTop (LinkStack &amp;stack) &#123;<br>    return stack-&gt;data;<br>&#125;</p><p>int main() &#123;<br>    LinkStack test;<br>    InitLinkStack(test);<br>    Push(test, 10);<br>    Push(test, 15);<br>    Push(test, 20);<br>    cout &lt;&lt; GetTop(test)&lt;&lt;&quot; &quot;&lt;&lt; GetTop(test)&lt;&lt;&quot; &quot;&lt;&lt; GetTop(test)&lt;&lt;&quot; &quot;&lt;&lt;&quot;\n&quot;;<br>    cout &lt;&lt; Pop(test)&lt;&lt;&quot; &quot;&lt;&lt; Pop(test)&lt;&lt;&quot; &quot;&lt;&lt; Pop(test)&lt;&lt;&quot; &quot;&lt;&lt;&quot;\n&quot;;<br>&#125;<br></code></pre></p></div>]]></content>
      
      
      <categories>
          
          <category> 计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 📶线结构：字符串-数组-栈-队列 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>缺爱</title>
      <link href="/essay/xikynq/"/>
      <url>/essay/xikynq/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="ue38d18f1" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1620269016472-0205bffa-da28-4411-9950-1b94025de0f7.jpeg" width="550" id="THQSB" class="ne-image"></p><p id="u78948a78" class="ne-p" style="text-align: left"><br></p><p id="ub66f1859" class="ne-p" style="text-align: left"><span class="ne-text">前言：观《刀剑神域》《东京食尸鬼》《进击的巨人》等一些番，对“缺爱”这个词的一些感悟……</span></p><p id="u9c68e113" class="ne-p" style="text-align: left"><br></p><hr id="srTUH" class="ne-hr"><p id="u6563aa42" class="ne-p"><br></p><p id="uf2eaf996" class="ne-p" style="text-align: center"><br></p><p id="a20d224c568e48b9d67847a2c66a8c01_p_0" class="ne-p"><span class="ne-text">缺爱的人，内心总有一些渴望，渴望被关爱，渴望被呵护，渴望对方是自己心里想要的模样……这种渴望是一种游走在刀尖上的隐式力量，甚至，会让一个人人格变化，变成一个我们都不在认识的人……</span></p><p id="c4117653d51cd868e6dc22310070e8fa" class="ne-p"><br></p><p id="4a6b24cfa2b15d79fe14e63a02c3f76a" class="ne-p"><span class="ne-text">尤吉欧缺的是从小的青梅竹马爱丽丝的爱，在面对最高祭司的亲昵……当然，尤吉欧的强大就强大在，他无条件相信挚友桐人，即便是那般情形，他也从刀尖上走向了正确的道路。金木研缺少的是母爱，的佣人，缺少的是家主的关爱</span></p><p id="a478fc563129e4f079b6953e4d61345a" class="ne-p"><br></p><p id="3270eb285d36ab65041306778a361ad5" class="ne-p"><span class="ne-text">兵长利威尔，就更不用说了，人类中外挂，绝对的强者，他缺少的不仅是亲人的爱，更是这个世界的压抑与社会的动荡，地下生活，从小就仰头看不见天空，低头被人唾弃，这缺的简直是一个世界啊，他心里也是多么珍视自己的爱和他人的爱，最初的两个小伙伴，再到利威尔整个班，还有……佩特拉……</span></p><p id="dd1259eb009d4739a1200ca7aa563b64" class="ne-p"><br></p><p id="43a38f1ccb147a4287059cf525aad5d3" class="ne-p"><span class="ne-text">如果说这个世界真有一种至暗力量，缺爱或许也是其一呢~这个世界谁都没错，错的是这个世界，那么    我又为何一直低头呢？这就是缺爱的至暗力量……</span></p><p id="d4e2f3b848139d4c6309dc4c86de9199" class="ne-p"><br></p><p id="aec01b16fedb1f190c42998dd0bfc12c" class="ne-p"><span class="ne-text">生活中，也有很多啊，跟班，小时候的孩子，经常有跟班一说，如果你是和别人相爱的人，那么你可以给对方更多一点的爱，如果你是为人父母，你可以更加爱自己的子女，爱，从来都不嫌多，两个人之间的爱情也是一样</span></p><p id="b1748f97ad8674bc38ef2a38857c60fe" class="ne-p"><br></p><p id="1613204624cab5463d85d87e2a4ab215" class="ne-p"><span class="ne-text">人与人之间，不要让对方、让彼此缺爱……</span></p><p id="1cbf858f5b06b20c52478e7f5a6b349a" class="ne-p"><br></p><p id="e691ca557d793a55550ea296fc706439" class="ne-p"><span class="ne-text">你仔细看看，缺爱的人好多，小什造，又何尝不是，</span></p><p id="578e731111732a7970a40d89ac702f6c" class="ne-p"><br></p><p id="90606eeec48d383f2365da3b94729cbb" class="ne-p"><br></p><p id="217aafd31c5bb15e59f0194e07211d32" class="ne-p"><span class="ne-text">这部剧好就好在，没有没有对错，没有哪一方是绝对的正确，贯穿全剧的就是一句话——“错的不是我，而是这个世界”</span></p><p id="6db1b2b17b72e9d4157a23637f2b828f" class="ne-p"><br></p><p id="uff60666a" class="ne-p"><br></p><p id="9add66c2f6176132dfe12b6382c5f6b5" class="ne-p"><span class="ne-text">写着写着，简直我就要黑化一般</span><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1618565453724-89af8f91-a000-4be3-bddd-cb1708cc5065.jpeg" width="52" id="fQUdE" class="ne-image"></p><p id="8ad1a4088531ca01eb309d6471ed829b" class="ne-p"><br></p><p id="ba3a0f736f53b26b9b6438df3ed2196e" class="ne-p"><code class="ne-code"><span class="ne-text">2021.05.06</span></code></p><p id="854af4395650d0eaf1e60c9604aa723e" class="ne-p"><br></p><p id="309036480d8044a52008b70a3f57daf7" class="ne-p"><span class="ne-text">上网搜了一下，缺爱还是有相应的词条的：</span><a href="https://baike.baidu.com/item/%E7%BC%BA%E7%88%B1/4544029" data-href="https://baike.baidu.com/item/%E7%BC%BA%E7%88%B1/4544029" target="_blank" class="ne-link"><span class="ne-text">缺爱·百度百科</span></a></p><p id="be6c6541496ec8a5c8f7af6c39009eb4" class="ne-p"><br></p><div class="ne-quote"><p id="6126e973de9910dd6b637453ae721b5c" class="ne-p"><span class="ne-text">缺爱：一般指缺少关爱的孩子的一种心情表现形式，着调于凄凉寂寞的非乐观主义。缺爱的孩子性格往往和普通孩子不一样，思想也成熟的早一点，但是较容易走极端。</span></p><p id="539c7177e3d4a0b69efe564377e2b866" class="ne-p"><span class="ne-text">——百度百科</span></p></div><p id="848ed0e6c1e965a5de024aa5242f0881" class="ne-p"><br></p><div class="ne-quote"><p id="d779548761360bf116198c8257ec7729" class="ne-p"><span class="ne-text">表现：缺爱的孩子性格往往和普通孩子不一样，思想也成熟的早一点，但是容易走极端，比较叛逆，一般能力较强，事业心强，但在内心里缺乏安全感，不论拥有再多，始终担忧如果有一天失去了怎么办。</span></p><p id="2945629b7787335af10a6fdcc5e8cde7" class="ne-p"><span class="ne-text">缺爱的孩子比较喜欢自己一个人不声不响的做事，性格比较孤僻，一般让人看上去会形容他“感觉这个人有很多心事”。</span></p></div><div class="ne-quote"><p id="bd3304777067eacab18ed6a98a3c989c" class="ne-p"><span class="ne-text">对于爱情，缺爱的孩子比较“慢热”，心里有恐惧感，害怕如果我投入了结果会怎样…… 但是一旦投入了，就会比较偏激的把自己认为好的全部给对方。不管这爱是亲情，友情，爱情，他都是全方位的去考虑去付出。因为他缺少爱，他全身心的付出内心里也是希望对方能像他一样全身心付出的对他好。如果没有得到期望中的回报或者被人所不屑，心中必然是由爱生恨，他们的爱恨往往比较极端。</span></p></div><div class="ne-quote"><p id="814a4210db2d23ca47878a7b60457bbc" class="ne-p"><span class="ne-text">单亲家庭的孩子、孤儿、重男轻女家庭的女儿、重小轻大家庭的大孩一般都会存在缺爱的现象，这是一个比较普遍的现象。</span></p></div><div class="ne-quote"><p id="e4c825fa0ab7b1e7c1360c4454dcf174" class="ne-p"><span class="ne-text">缺爱的孩子需要社会的关心，不然容易变坏，社会上这样的例子很多。</span></p><p id="8c622d0019853599e7fe8675b11dd46c" class="ne-p"><span class="ne-text">——百度百科</span></p></div></div>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>实验3——求LA和LB(用单链表表示)的并和交集🔖链表</title>
      <link href="/blog/tw2cvt/"/>
      <url>/blog/tw2cvt/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h2 id="kfwKY"><span class="ne-text">实验要求</span></h2><p id="fc77a305509589eb8e57f5dfb40b0283" class="ne-p"><span class="ne-text" style="font-size: 16px">求两个集合</span><span class="ne-text" style="font-size: 16px">LA</span><span class="ne-text" style="font-size: 16px">和</span><span class="ne-text" style="font-size: 16px">LB(</span><span class="ne-text" style="font-size: 16px">用单链表表示</span><span class="ne-text" style="font-size: 16px">)</span><span class="ne-text" style="font-size: 16px">的并和交集</span></p><p id="97cde14d07d55927cbe8c267732498e8" class="ne-p"><span class="ne-text" style="font-size: 16px">要求：在实验二的基础上，使用单链表表示集合。编写两个算法（求交算法和求并算法），并输出最终的结果。</span></p><p id="ead1e8e70488c4fe4831812a1ca80cd6" class="ne-p"><span class="ne-text" style="font-size: 16px">测试用例：集合</span><span class="ne-text" style="font-size: 16px">A</span><span class="ne-text" style="font-size: 16px">为</span><span class="ne-text" style="font-size: 16px">{3</span><span class="ne-text" style="font-size: 16px">，</span><span class="ne-text" style="font-size: 16px">4</span><span class="ne-text" style="font-size: 16px">，</span><span class="ne-text" style="font-size: 16px">1</span><span class="ne-text" style="font-size: 16px">，</span><span class="ne-text" style="font-size: 16px">6}</span><span class="ne-text" style="font-size: 16px">，集合</span><span class="ne-text" style="font-size: 16px">A</span><span class="ne-text" style="font-size: 16px">为</span><span class="ne-text" style="font-size: 16px">{2</span><span class="ne-text" style="font-size: 16px">，</span><span class="ne-text" style="font-size: 16px">3</span><span class="ne-text" style="font-size: 16px">，</span><span class="ne-text" style="font-size: 16px">6</span><span class="ne-text" style="font-size: 16px">，</span><span class="ne-text" style="font-size: 16px">7}</span><span class="ne-text" style="font-size: 16px">，</span></p><p id="bb2a51a2d8dae453e9cee5530fc5cf09" class="ne-p"><span class="ne-text" style="font-size: 16px">           </span><span class="ne-text" style="font-size: 16px">交集为</span><span class="ne-text" style="font-size: 16px">{3</span><span class="ne-text" style="font-size: 16px">，</span><span class="ne-text" style="font-size: 16px">6}</span></p><p id="16107b01f015db18e9dad1c123c47f6f" class="ne-p"><span class="ne-text" style="font-size: 16px">           </span><span class="ne-text" style="font-size: 16px">并集为</span><span class="ne-text" style="font-size: 16px">{1</span><span class="ne-text" style="font-size: 16px">，</span><span class="ne-text" style="font-size: 16px">2</span><span class="ne-text" style="font-size: 16px">，</span><span class="ne-text" style="font-size: 16px">3</span><span class="ne-text" style="font-size: 16px">，</span><span class="ne-text" style="font-size: 16px">4</span><span class="ne-text" style="font-size: 16px">，</span><span class="ne-text" style="font-size: 16px">6</span><span class="ne-text" style="font-size: 16px">，</span><span class="ne-text" style="font-size: 16px">7}</span></p><p id="a985b06473d654b3af94e60d4faaecb5" class="ne-p"><span class="ne-text" style="font-size: 16px">交作业时间：4月16日</span></p><h2 id="bRCZx"><span class="ne-text">实验代码</span></h2><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;<p>/**</p><ul><li>求两个集合LA和LB(用单链表表示)的并和交集</li><li>/</li></ul><p>/* 单链表的存储结构 */<br>typedef struct LNode &#123;<br>    int data; //数据域<br>    struct LNode *next; //指针域<br>&#125;Lnode, *LinkList; //LinkList为指向结构体LNode的指针类型</p><p>/* 初始化链表 */<br>void InitList(LinkList &amp;L) &#123;<br>    L = new LNode;<br>    L-&gt;next = NULL;<br>&#125;</p><p>/* 创建：后插 */<br>void CreateList_R(LinkList &amp;L, int n) &#123;<br>    cout &lt;&lt; &quot;请输入&quot; &lt;&lt; n &lt;&lt; &quot;个数字&quot;&lt;&lt; &quot;\n&quot;;<br>    InitList(L);<br>    // 定义一个在下面循环用来一直操作所加元素的结点p来指向头结点L<br>    LinkList p = L;<br>    for (int i = 0; i &lt; n;i++) &#123;<br>        LinkList q = new Lnode;<br>        q-&gt;next = NULL;<br>        cin &gt;&gt; q-&gt;data;<br>        p-&gt;next = q;<br>        p = q; //为了下一次<br>    &#125;<br>&#125;</p><p>/* 打印 */<br>void TraverseList(LinkList &amp; L)&#123;<br>        LinkList p = new LNode;<br>        p = L-&gt;next;<br>        cout &lt;&lt; &quot;此链表打印的结果为：&quot;&lt;&lt; &quot;\n&quot;;<br>        while (p != NULL)<br>        &#123;<br>            cout &lt;&lt; p-&gt;data &lt;&lt; &quot; &quot;;<br>            p = p-&gt;next;<br>        &#125;<br>        cout &lt;&lt; &quot;\n&quot;;<br>&#125;</p><p>/* 排序单链表 */<br>void sort(LinkList &amp;L) &#123;</p><p>&#125;</p><p>/* jiao算法 */<br>void jiao(LinkList &amp;A,LinkList &amp;B) &#123;<br>    // 用双循环得出共有的元素并输出<br>    LinkList p;<br>    InitList(p);<br>    A = A-&gt;next;<br>    B = B-&gt;next;<br>    while (A != NULL ) &#123;<br>        LinkList copy_b = B;<br>        while(copy_b != NULL) &#123;<br>            if (A-&gt;data == copy_b-&gt;data) &#123;<br>                LinkList temp = new Lnode;<br>                temp-&gt;data = copy_b-&gt;data;<br>                temp-&gt;next = p-&gt;next;<br>                p-&gt;next = temp;<br>                break;<br>            &#125; else &#123;<br>                copy_b = copy_b-&gt;next;<br>            &#125;<br>        &#125;<br>        A = A-&gt;next;<br>    &#125;</p><pre><code>while(p-&amp;gt;next != NULL) &#123;    cout &amp;lt;&amp;lt; p-&amp;gt;next-&amp;gt;data &amp;lt;&amp;lt; &amp;quot; &amp;quot;;    p = p-&amp;gt;next;&#125;</code></pre><p>}</p><p>/* bing算法 */<br>void bing(LinkList &amp;A,LinkList &amp;B) {<br>    LinkList p = A;<br>    LinkList s = B;</p><pre><code>A = A-&amp;gt;next;B = B-&amp;gt;next;while (A != NULL ) &#123;    LinkList copy_b = B;    while(copy_b != NULL) &#123;        if (A-&amp;gt;data == copy_b-&amp;gt;data) &#123;            // cout &amp;lt;&amp;lt; A-&amp;gt;data &amp;lt;&amp;lt; &amp;quot;\n&amp;quot;;            // 在p链里面删除A-&amp;gt;data值            LinkList q = p;            while(q-&amp;gt;next != NULL) &#123;                if (q-&amp;gt;next-&amp;gt;data == A-&amp;gt;data) &#123;                    q-&amp;gt;next = q-&amp;gt;next-&amp;gt;next;                    break;                &#125; else &#123;                    q = q-&amp;gt;next;                &#125;            &#125;            break;        &#125; else &#123;            copy_b = copy_b-&amp;gt;next;        &#125;    &#125;    A = A-&amp;gt;next;&#125;// 将p链表连接到s链表上LinkList result = p;while (p != NULL) &#123;    if (p-&amp;gt;next == NULL) &#123;        p-&amp;gt;next = s-&amp;gt;next;        break;    &#125;    p = p-&amp;gt;next;&#125;while(result-&amp;gt;next != NULL) &#123;    cout &amp;lt;&amp;lt; result-&amp;gt;next-&amp;gt;data &amp;lt;&amp;lt; &amp;quot; &amp;quot;;    result = result-&amp;gt;next;&#125;</code></pre><p>}</p><p>int main() {<br>    LinkList list_A;<br>    LinkList list_B;<br>    InitList(list_A);<br>    InitList(list_B);<br>    CreateList_R(list_A, 6);<br>    CreateList_R(list_B, 6);<br>    LinkList list_C = list_A;<br>    LinkList list_D = list_B;<br>    cout &lt;&lt;&quot;A、B交集的值为：&quot;;<br>    jiao(list_A, list_B);<br>    cout &lt;&lt;&quot;\n&quot;&lt;&lt;&quot;A、B并集的值为：&quot;;<br>    bing(list_C, list_D);<br>}<br></code></pre></p></div>]]></content>
      
      
      <categories>
          
          <category> 计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 🔗线结构：链表 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>“错的不是我，是这个世界”</title>
      <link href="/essay/lu9dks/"/>
      <url>/essay/lu9dks/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="9d6d26b32c5407fa409e22cc09422383" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1619799998545-a5718c40-08b7-4571-84a2-c79b4396d498.jpeg" width="2154" id="WX9p5" class="ne-image"></p><p id="u96b61946" class="ne-p"><br></p><p id="u3e997bfe" class="ne-p"><span class="ne-text">既不是喰种也不是人类，与既是喰种又是人类，怎么选呢？</span></p><p id="u2e8b020d" class="ne-p"><span class="ne-text">不谙世事所带来的就是单纯与洁白</span></p><p id="u6768765b" class="ne-p"><span class="ne-text"></span></p><p id="u6027b438" class="ne-p"><span class="ne-text">英对好友金木敏锐的反应真的是关心与从小而来的感情之深。</span></p><p id="uf33262fa" class="ne-p"><br></p><div class="ne-quote"><p id="uc691bd7b" class="ne-p"><span class="ne-text">咖啡的味道会随着人们花费于其中的精力而变</span></p><p id="uaf790a20" class="ne-p"><span class="ne-text">人做事也是如此，你不用太着急</span></p></div><p id="u67365225" class="ne-p"><span class="ne-text">所有人都认为是对的事情，不一定是对的，而有些错误的事情，的确掌握在少数人手上</span></p><p id="ubc53c7bf" class="ne-p"><span class="ne-text"></span></p><p id="u27fb74dd" class="ne-p"><span class="ne-text">呗先生说的一句话：“金木没有恋人吗  比起同龄的女性  更喜欢被年长的姐姐疼爱把”，这也的确点明金木从小缺爱的身世。</span></p><p id="u7df1d4ec" class="ne-p"><br></p><p id="ub0375c15" class="ne-p"><span class="ne-text">稚实和董香应该都是内心非常可爱的女孩子把，从小经历生死颠簸坎坷的生活与环境，能保持这么一点可爱的童心真的很不容易。</span></p><p id="ucf45e830" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1642409420043-064162ee-0226-4957-bb9e-2d0b8050ec57.png" width="1920" id="ub936c96a" class="ne-image"></p><p id="u27a23963" class="ne-p"><br></p><h3 id="kdQTp"><span class="ne-text">致终章</span></h3><div class="ne-quote"><p id="u1208d7d3" class="ne-p"><span class="ne-text">不……不是我的错</span></p><p id="ueb12282f" class="ne-p"><span class="ne-text">不对  都是我  都是我的错</span></p></div><p id="u1a9e88c4" class="ne-p"><br></p><div class="ne-quote"><p id="u9b3ef655" class="ne-p"><span class="ne-text">事到如今  你还在说这么显而易见的事实</span></p><p id="u08514cc6" class="ne-p"><span class="ne-text">你就像这样责备自己  不断地责备自己</span></p></div><p id="u246dd462" class="ne-p"><br></p><div class="ne-quote"><p id="uf0a4fa9b" class="ne-p"><span class="ne-text">只是一味地责备自己  结果一点也没有改变</span></p><p id="u204c6fa1" class="ne-p"><span class="ne-text">变成这样到底是谁的错</span></p><p id="u3e87d74f" class="ne-p"><span class="ne-text">偶然  事故  运气</span></p><p id="uaa0b7fc8" class="ne-p"><strong><span class="ne-text">运气是不存在的  那只是情况和情况的不同组合</span></strong></p><p id="u19d69df4" class="ne-p"><span class="ne-text">那又是谁制造了这种情况  是谁呢？</span></p><p id="u7c5af00f" class="ne-p"><span class="ne-text">就是你啊</span></p><p id="u990aab69" class="ne-p"><strong><span class="ne-text">世界上所有的不利因素都是因为当事人的能力不足</span></strong></p></div><p id="ua98c32e0" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1618470547319-c45591d3-8c94-4a78-8e1d-83174784522b.png" width="960" id="u3e621b1a" class="ne-image"></p><p id="uf2bd473c" class="ne-p"><br></p><div class="ne-quote"><p id="ud1eb8702" class="ne-p"><span class="ne-text">事实如此</span></p><p id="ud1bfe9b8" class="ne-p"><span class="ne-text">话说回来  一切的开端</span></p><p id="uc7feaa6c" class="ne-p"><strong><span class="ne-text">也就是因为你是一个不谙世事的笨蛋啊</span></strong></p><p id="u700a4ca5" class="ne-p"><span class="ne-text">因为你是笨蛋  然后被我欺骗</span></p><p id="u28786c7d" class="ne-p"><span class="ne-text">还被医生动了手脚</span></p><p id="u8193f59a" class="ne-p"><span class="ne-text">所以变成了怪物</span></p></div><p id="u41d38080" class="ne-p"><br></p><div class="ne-quote"><p id="u14d42fe1" class="ne-p"><span class="ne-text">全部都是你的错</span></p><p id="u73565b64" class="ne-p"><span class="ne-text">于其伤害他人  不如成为被伤害的那一方</span></p><p id="uef9eba06" class="ne-p"><span class="ne-text">所以你遇到这种事</span></p><p id="udd24419e" class="ne-p"><span class="ne-text">如果你足够强到能够杀死壁虎的话</span></p><p id="uc3b27f60" class="ne-p"><span class="ne-text">那两人就能得救了哦</span></p><p id="ub5b0621e" class="ne-p"><span class="ne-text">或者如果你选择了男人的话  那个女人就可能得救了</span></p><p id="u7ad4f9f7" class="ne-p"><span class="ne-text">那个时候也是如此</span></p><p id="u7e162a96" class="ne-p"><strong><span class="ne-text">如果你有足够实力的话</span></strong></p></div><p id="u1f9eb97c" class="ne-p"><br></p><p id="u4e68e398" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1618470834142-4bea4e83-48a2-41fd-9246-e1f0b27c04e5.png" width="960" id="u8e685db7" class="ne-image"></p><p id="u0ae4fd4a" class="ne-p"><br></p><div class="ne-quote"><p id="u12ce4896" class="ne-p"><span class="ne-text">从今往后也一样</span></p><p id="u7b3fb88b" class="ne-p"><span class="ne-text">董香  雏实  英  </span></p><p id="uf2880180" class="ne-p"><span class="ne-text">你所珍视的人</span></p></div><p id="u902d8b8b" class="ne-p"><br></p><div class="ne-quote"><p id="u31cf0e26" class="ne-p"><span class="ne-text">明白了吗</span></p><p id="u424f8eed" class="ne-p"><span class="ne-text">这就是你所选择的生活方式</span></p><p id="u2791fd54" class="ne-p"><span class="ne-text">你所选择的未来啊</span></p><p id="u405d9cc8" class="ne-p"><span class="ne-text">为什么要哭泣呢  为什么要呐喊呢</span></p><p id="u34e8514d" class="ne-p"><span class="ne-text">与其伤害他人  你选择成为被伤害的那一方不是吗</span></p><p id="ue2a9d257" class="ne-p"><span class="ne-text">既温柔又美好</span></p><p id="uac21108b" class="ne-p"><span class="ne-text">看似你两者都选择了</span></p><p id="udbc70cee" class="ne-p"><span class="ne-text">但实际上你两者都失去了</span></p><p id="u36f705f0" class="ne-p"><span class="ne-text">你的母亲也是如此</span></p></div><p id="u2fe0846b" class="ne-p"><br></p><div class="ne-quote"><p id="u436173b3" class="ne-p"><span class="ne-text">你其实也希望她这么做吧</span></p><p id="u28728406" class="ne-p"><span class="ne-text">请你……不要再说了</span></p></div><p id="u0ef17453" class="ne-p"><br></p><div class="ne-quote"><p id="ua534ce78" class="ne-p"><span class="ne-text">为什么</span></p><p id="u66a48a5a" class="ne-p"><span class="ne-text">为什么留下我一个人</span></p><p id="ub3cc6355" class="ne-p"><span class="ne-text">我不要孤单一人</span></p><p id="ub51c3e6c" class="ne-p"><span class="ne-text">我好希望你能够选择我啊</span></p></div><p id="u05930376" class="ne-p"><br></p><div class="ne-quote"><p id="uf49eacd3" class="ne-p"><span class="ne-text">没错  金木</span></p><p id="u6dfde17f" class="ne-p"><strong><span class="ne-text">『每个人都有必须舍弃某一边才能保护重要事物的时刻』</span></strong></p></div><p id="u70555b21" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1618471315132-4f0b9cc2-ba10-4c59-8c6f-73475002e472.png" width="960" id="u5f1533bb" class="ne-image"></p><p id="u33115feb" class="ne-p"><br></p><div class="ne-quote"><p id="u41c7c5a0" class="ne-p"><strong><span class="ne-text">没做到这一点  只是软弱罢了</span></strong></p><p id="u75ef3085" class="ne-p"><strong><span class="ne-text">没有舍弃的坚强  缺乏深刻的觉悟</span></strong></p><p id="u9857e086" class="ne-p"><span class="ne-text">你还能继续做被伤害的那一方吗</span></p><p id="u102bc79c" class="ne-p"><span class="ne-text">你还能原谅壁虎这种人吗</span></p></div><p id="u27678e24" class="ne-p"><br></p><div class="ne-quote"><p id="ud726279d" class="ne-p"><span class="ne-text">无法……无法原谅</span></p></div><p id="u2a11cbc4" class="ne-p"><br></p><div class="ne-quote"><p id="u97512d74" class="ne-p"><span class="ne-text">你最重要的英  还有安定区的同伴们</span></p><p id="u079c5634" class="ne-p"><span class="ne-text">都有可能遇到那种事</span></p></div><p id="u3907bb53" class="ne-p"><br></p><p id="ub5752ca7" class="ne-p"><br></p><div class="ne-quote"><p id="ufd611f74" class="ne-p"><strong><span class="ne-text">你拥有做到这些的力量吗</span></strong></p><p id="u23c23957" class="ne-p"><strong><span class="ne-text">我有…</span></strong></p><p id="u3680cb80" class="ne-p"><strong><span class="ne-text">那也就是你要接受我的意思吗</span></strong></p><p id="u8796a7ba" class="ne-p"><strong><span class="ne-text">不对</span></strong></p><p id="ud18a180c" class="ne-p"><strong><span class="ne-text">并不是这样</span></strong></p><p id="u9bce2c3b" class="ne-p"><strong><span class="ne-text">我只要超越你就好了</span></strong></p><p id="u3c07236f" class="ne-p"><strong><span class="ne-text">即使这是错误的选择也没关系吗</span></strong></p><p id="u8eca6478" class="ne-p"><strong><span class="ne-text" style="color: #F5222D">『错的人不是我   错误的是…这个世界』</span></strong></p></div><p id="u78887dd7" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1618471631139-459ab7b1-8de4-439a-ba90-47ec64a973db.png" width="960" id="u359998a2" class="ne-image"></p><p id="ud33c5f4e" class="ne-p"><br></p><p id="u52478afc" class="ne-p"><br></p><p id="ud1a2ce0b" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1618471714779-46f493f2-f76d-4ae8-8016-82a8acc51e66.png" width="960" id="u0b809119" class="ne-image"></p><p id="u786832fe" class="ne-p"><br></p><p id="u98d514cc" class="ne-p"><br></p><p id="uf4dec34a" class="ne-p"><br></p><div id="iBfRz" class="ne-thirdparty"><a href="https://music.163.com/outchain/player?type=2&amp;id=29017078&amp;auto=0&amp;height=66">https://music.163.com/outchain/player?type=2&amp;id=29017078&amp;auto=0&amp;height=66</a></div><p id="ub2437acf" class="ne-p"><br></p><p id="uf1d37ecd" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1618472037932-fcffb7e6-0ca2-4f68-9c3d-52d865fd05ca.png" width="960" id="u82016ac2" class="ne-image"></p><p id="u45031f57" class="ne-p"><br></p><pre><code>教えて 教えてよその仕組みを僕の中に誰がいるの？壊れた 壊れたよこの世界で君が笑う何も見えずに壊れた僕なんてさ息を止めてほどけない もう ほどけないよ真実さえ freeze壊せる 壊せない狂える 狂えないあなたを見つけて 揺れた歪んだ世界にだんだん僕は透き通って見えなくなって見つけないで 僕のことを見つめないで誰かが描いた世界の中であなたを傷つけたくはないよ覚えていて 僕のことを鮮やかなまま無限に広がる孤独が絡まる無邪気に笑った記憶が刺さって動けない 動けない動けない 動けない動けない 動けないよUnravelling the world変わってしまった 変えられなかった2つが絡まる 2人が滅びる壊せる 壊せない狂える 狂えないあなたを汚せないよ 揺れた歪んだ世界にだんだん僕は透き通って見えなくなって見つけないで 僕のことを見つめないで誰かが仕組んだ孤独な罠に未来がほどけてしまう前に思い出して 僕のことを鮮やかなまま忘れないで 忘れないで忘れないで 忘れないで変わってしまったことに paralyze変えられないことだらけの paradise覚えていて 僕のことを教えて教えて僕の中に誰がいるの？</code></pre></div>]]></content>
      
      
      <categories>
          
          <category> 影视 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>art-template模板</title>
      <link href="/blog/qhgult/"/>
      <url>/blog/qhgult/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content-editor-core lake-engine lake-typography-classic" data-lake-element="root" data-selection-undefined="%7B%22path%22%3A%5B%5B2%2C0%2C1%2C0%2C17%5D%2C%5B2%2C0%2C1%2C0%2C17%5D%5D%2C%22active%22%3Atrue%7D"><h2 data-lake-id="61b71090e71a42cd9513389859fdaf25" id="b2N2J" style="padding: 7px 0px; margin: 0px; font-weight: 700; font-size: 24px; line-height: 32px;">art-template和express-art-template</h2><blockquote class="lake-alert lake-alert-info" style="background-color: rgb(232, 247, 255); margin: 0px; padding: 10px; border: 1px solid rgb(171, 210, 218); opacity: 1; border-radius: 3px; color: rgb(38, 38, 38);"><p data-lake-id="e81fb9afc377a89ff77e62472fe6888f" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">为了是art-template模板引擎能够更好地和Express框架配合，模板引擎官方在源art-template模板引擎的基础上封装了express-art-template，所以在使用Espress框架时候，这两个模块都要下载。</p></blockquote><ul data-lake-id="d11b77d0fb802a8689d4d183e4a0866d" lake-indent="0" style="list-style-type: disc; margin: 0px; padding-left: 23px; font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word;"><li data-lake-id="3adfd7ff7ffa142abbd0994e6cd1fdc2">art-template官网：<a href="https://aui.github.io/art-template/zh-cn/docs/" target="_blank">https://aui.github.io/art-template/zh-cn/docs/</a></li><li data-lake-id="f3aa99eabfbe9ef89236ea72110834cc">关于模板引擎：<a href="https://segmentfault.com/a/1190000020478061" target="_blank">6个常见JS模板引擎</a></li></ul><h3 data-lake-id="5337312138fc9083ee298b8ca1b92d85" id="F4gaD" style="padding: 7px 0px; margin: 0px; font-weight: 700; font-size: 20px; line-height: 28px;">使用模板渲染情况下声明</h3><div data-card-type="block" data-lake-card="codeblock" id="bmkAD" class="lake-card-margin" data-language="javascript"><div class="lake-codeblock-content" style="border: 1px solid rgb(232, 232, 232); max-width: 750px; color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: rgb(249, 249, 249);"><div class="CodeMirror-sizer" style="color: rgb(89, 89, 89); margin: 0px; padding: 16px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"><pre class="cm-s-default" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"><span class="lake-preview-line" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"><span class="lake-preview-line-number lake-lm-pad-level-0" style="color: rgb(191, 191, 191); margin: 0px 8px 0px 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"></span><span class="lake-preview-codeblock-content" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"><span class="cm-comment" style="color: rgb(106, 115, 125); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">// 渲染后缀为art的模板时，所使用的模板引擎是什么</span></span></span><span class="lake-preview-line" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"><span class="lake-preview-line-number lake-lm-pad-level-0" style="color: rgb(191, 191, 191); margin: 0px 8px 0px 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"></span><span class="lake-preview-codeblock-content" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"><span class="cm-variable" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">app</span>.<span class="cm-property" style="color: rgb(0, 92, 197); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">engine</span>(<span class="cm-string" style="color: rgb(102, 153, 0); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">'art'</span>, <span class="cm-variable" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">require</span>(<span class="cm-string" style="color: rgb(102, 153, 0); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">'express-art-template'</span>));</span></span><span class="lake-preview-line" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"><span class="lake-preview-line-number lake-lm-pad-level-0" style="color: rgb(191, 191, 191); margin: 0px 8px 0px 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"></span><span class="lake-preview-codeblock-content" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"><span class="cm-comment" style="color: rgb(106, 115, 125); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">// 告诉express框架模板的位置</span></span></span><span class="lake-preview-line" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"><span class="lake-preview-line-number lake-lm-pad-level-0" style="color: rgb(191, 191, 191); margin: 0px 8px 0px 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"></span><span class="lake-preview-codeblock-content" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"><span class="cm-variable" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">app</span>.<span class="cm-property" style="color: rgb(0, 92, 197); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">set</span>(<span class="cm-string" style="color: rgb(102, 153, 0); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">'views'</span>, <span class="cm-variable" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">path</span>.<span class="cm-property" style="color: rgb(0, 92, 197); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">join</span>(<span class="cm-variable" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">__dirname</span>, <span class="cm-string" style="color: rgb(102, 153, 0); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">'views'</span>))</span></span><span class="lake-preview-line" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"><span class="lake-preview-line-number lake-lm-pad-level-0" style="color: rgb(191, 191, 191); margin: 0px 8px 0px 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"></span><span class="lake-preview-codeblock-content" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"><span class="cm-comment" style="color: rgb(106, 115, 125); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">// 告诉express框架模板的默认后缀是什么</span></span></span><span class="lake-preview-line" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"><span class="lake-preview-line-number lake-lm-pad-level-0" style="color: rgb(191, 191, 191); margin: 0px 8px 0px 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"></span><span class="lake-preview-codeblock-content" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"><span class="cm-variable" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">app</span>.<span class="cm-property" style="color: rgb(0, 92, 197); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">set</span>(<span class="cm-string" style="color: rgb(102, 153, 0); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">'view engine'</span>, <span class="cm-string" style="color: rgb(102, 153, 0); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">'art'</span>);</span></span></pre></div></div></div><h3 data-lake-id="c0f2b06f951eab51f4b60847af75cc8b" id="eTsmx" style="padding: 7px 0px; margin: 0px; font-weight: 700; font-size: 20px; line-height: 28px;">关于绝对/相对路径的引用</h3><p data-lake-id="ee887858624d1b0690c72bd8607b9490" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><strong><span>模板资源里面引用静态资源的路径要用绝对路径</span></strong><span>。怎么使用绝对路径呢，类似hexo静态博客一样，前面加一个“/”即可是根目录路径下，再进行根目录路径下路径写法</span></p></div>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
          <category> Node.js </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>MongoDB下载及使用+Navicat使用+服务器上的配置</title>
      <link href="/blog/nwt63v/"/>
      <url>/blog/nwt63v/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><ul class="ne-ul"><li id="ue787d955" data-lake-index-type="0"><a href="https://docs.mongoing.com/" data-href="https://docs.mongoing.com/" target="_blank" class="ne-link"><span class="ne-text">MongoDB中文手册|官方文档中文版</span></a></li><li id="ub12e3d29" data-lake-index-type="0"><a href="https://www.runoob.com/mongodb/mongodb-tutorial.html" data-href="https://www.runoob.com/mongodb/mongodb-tutorial.html" target="_blank" class="ne-link"><span class="ne-text">MongoDB 教程 | 菜鸟教程</span></a></li></ul><h2 id="LmrLI"><span class="ne-text">MongoDB的安装及开发工具的使用</span></h2><h3 id="Frqus"><span class="ne-text">MongoDB下载安装</span></h3><ul class="ne-ul"><li id="u7f19f85b" data-lake-index-type="0"><span class="ne-text">下载地址：</span><a href="https://www.mongodb.com/try/download/community" data-href="https://www.mongodb.com/try/download/community" target="_blank" class="ne-link"><span class="ne-text">https://www.mongodb.com/try/download/community</span></a></li></ul><p id="uc5e6a50a" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1641785675512-02e6f0d4-ea5a-49a4-be43-9c4467cd24cb.png" width="386" id="ua1cddbf5" class="ne-image"></p><p id="u6d2cbadf" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1641785757640-0a248bb1-e980-47ed-829f-6b70ae6b269a.png" width="386" id="uff723749" class="ne-image"></p><p id="ue1635f5b" class="ne-p"><span class="ne-text">不要勾选，最后将安装的bin目录路径添加到环境变量中即可，安装成功如下：</span></p><p id="u7ec6be96" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1641875672118-08da6786-ae2b-4b77-8e36-ff19b54c5e27.png" width="370" id="ue3f0b045" class="ne-image"></p><p id="u85ec9c04" class="ne-p"><span class="ne-text"></span></p><h3 id="Lv7NL"><span class="ne-text">创建云数据库</span></h3><p id="u9dd3ae85" class="ne-p"><span class="ne-text">官网创建的免费数据库（512MB空间）</span></p><ul class="ne-ul"><li id="u80d6bc8f" data-lake-index-type="0"><span class="ne-text">控制台：</span><a href="https://cloud.mongodb.com/v2/62037110f7e060349a8c7f47#clusters" data-href="https://cloud.mongodb.com/v2/62037110f7e060349a8c7f47#clusters" target="_blank" class="ne-link"><span class="ne-text">https://cloud.mongodb.com/v2/62037110f7e060349a8c7f47#clusters</span></a></li></ul><h3 id="DWP8v"><span class="ne-text">Navicat数据库管理软件</span></h3><ul class="ne-ul"><li id="u603d2659" data-lake-index-type="0"><span class="ne-text">只有Navicat 15及以上才能连接MongoDB数据库</span></li></ul><ul class="ne-ul"><li id="uc278de5f" data-lake-index-type="0"><span class="ne-text">下载以及破解版：</span><a href="https://romanli.top/?id=18" data-href="https://romanli.top/?id=18" target="_blank" class="ne-link"><span class="ne-text">Navicat Premium v15.0.22 中文最新破解版（附：激活工具）</span></a></li></ul><h4 id="zm8mV"><span class="ne-text">连接远程云数据库</span></h4><p id="u0ab478fa" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1644479041420-13a11797-74ae-46c8-93e9-64c19be8ab13.png" width="177" id="IP715" class="ne-image"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1644479089843-a151178a-b096-4a18-a70e-27fd367d3367.png" width="337" id="G6P2A" class="ne-image"></p><p id="ub0718573" class="ne-p"><span class="ne-text">框里面粘贴云数据库那边提供的连接url即可</span></p><p id="u29158a67" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1644722409596-6bc906be-4eec-43bc-ad4d-aa09099712ff.png" width="600" id="u0bc60c7b" class="ne-image"></p><pre><code><code>mongodb+srv://lyrics:密码@lyrics-cluster.czuca.mongodb.net/myFirstDatabase?retryWrites=true&amp;w=majority</code></code></pre><h3 id="JTQ1v"><span class="ne-text">服务器的云数据库安全组的配置</span></h3><p id="u3b14f53c" class="ne-p"><span class="ne-text">如果自己的项目部署到服务器上，项目中需要使用mongodb的连接，则需要给服务器配置相应的安全组规则，具体如下：</span></p><p id="u9d00b139" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1644402764562-81e6602f-3464-410e-9f6e-9a29675ee9e0.png" width="1393" id="yrIMz" class="ne-image"></p><p id="u07c5b00d" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1644402776201-400a02b5-7c51-422e-8b77-96fd03191fe2.png" width="1464" id="NT9Oa" class="ne-image"></p><h2 id="eD2VG"><span class="ne-text">MongoDB相关使用</span></h2><h3 id="RJLiE"><span class="ne-text">MongoDB数据库命令</span></h3><ul class="ne-ul"><li id="uc3a7fd64" data-lake-index-type="0"><span class="ne-text">查看所有数据库：show dbs</span></li><li id="u0b9c4ab6" data-lake-index-type="0"><span class="ne-text">使用指定数据库：use testmongodb</span></li></ul><p id="udd77ada0" class="ne-p"><span class="ne-text">如果有该数据库则切换到该数据库，如果没有则新建再切换至该数据库</span></p><ul class="ne-ul"><li id="u82f0dd2d" data-lake-index-type="0"><span class="ne-text">展示数据库所有用户：show users</span></li></ul><p id="u23bedd54" class="ne-p"><span class="ne-text"></span></p></div>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
          <category> DataBase </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>应用层下的域名系统DNS</title>
      <link href="/blog/lz0ywx/"/>
      <url>/blog/lz0ywx/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content-editor-core lake-engine lake-typography-classic" data-lake-element="root" data-selection-undefined="%7B%22path%22%3A%5B%5B0%2C0%2C0%5D%2C%5B0%2C0%2C0%5D%5D%2C%22active%22%3Atrue%7D"><p data-lake-id="e851aae42d65745b0d683eb5c9f38726" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">域名系统DNS的作用就是域名解析为IP地址，因为在网络中传输的是字节，从之前学过的报文结构就可以得知，但是为何不直接在报文中直接传输域名呢？因为IP地址长度是固定的32位（如果是IPV6就是固定的128位），而域名长度不是固定长度的，及其处理比较困难。所以将域名解析成IP地址这个任务就交给了域名服务器了。</p><p data-lake-id="6be2ebd7d69e4dda7aab539619d76c3b" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><h2 data-lake-id="2b20760eff31b899c1219d589dfaeb38" id="4WKcd" style="padding: 7px 0px; margin: 0px; font-weight: 700; font-size: 24px; line-height: 32px;">理解什么是域名服务器？</h2><p data-lake-id="1cc5df2045c13e41c651fe6812d3b2b4" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">域名服务器构成了DNS中的分布式网络系统，其功能主要是为内外主机提供域名与IP地址的互相解析映射服务。域名服务器分布在互联网的各子网中，每个域名服务器负责管理连接到本子网的所有主机，并为其提供服务。</p><p data-lake-id="93b03fc108af5fac7292ba6ab353e54c" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="b89c451d28c2ebb7a55f664cf8147253" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="a9fca39e81541c5c9665eecfa5e909ee" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span data-card-type="inline" data-lake-card="image" class="lake-card-margin-top lake-card-margin-bottom"><img data-role="image" src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1618645215420-4ee27962-12d4-467b-81e6-f932e4c82a2a.png" data-raw-src="" class="image lake-drag-image" alt="image.png" title="image.png" data-height="226px" style="visibility: visible; width: 545px;"></span></p><p data-lake-id="f9d06677dbad14dff6fdf4e0744cfd33" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">域名服务器分为上面所表示的根域名服务器、顶级域名服务器、权限域名服务器、还有本地域名服务器（在本地电脑里面）</p><h3 data-lake-id="7e0a561a8c3968a46230625423fff0c1" id="a1FJu" style="padding: 7px 0px; margin: 0px; font-weight: 700; font-size: 20px; line-height: 28px;">关于本地域名服务器</h3><p data-lake-id="83ac8606dda70819aa90179b895d0785" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">本地电脑就有</p><p data-lake-id="5d071c8c1f140fd228aa2dcbfd45eae5" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span data-card-type="inline" data-lake-card="image" class="lake-card-margin-top lake-card-margin-bottom"><img data-role="image" src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1618647707183-7e8f7af0-a3ab-455b-b702-18f82644471b.png" data-raw-src="" class="image lake-drag-image" alt="image.png" title="image.png" data-height="398px" style="visibility: visible; width: 331px;"></span></p><h3 data-lake-id="cc532d2ef47892e3d60a6128246a56c8" id="UGxo5" style="padding: 7px 0px; margin: 0px; font-weight: 700; font-size: 20px; line-height: 28px;">关于根域名服务器</h3><blockquote style="padding-left: 1em; margin-top: 5px; margin-bottom: 5px; margin-left: 0px; border-left: 3px solid rgb(238, 238, 238); opacity: 0.6;"><p data-lake-id="64679f4246c6f2c8f8f18602cb31f390" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">关于根域名服务器，这里面有个有趣的话题，参考这篇文章：</p><p data-lake-id="66ff46e7fac8c1d721a2f1026281a27b" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><a href="https://segmentfault.com/a/1190000023696737" target="_blank">美国如果把根域名服务器封了，中国会从网络上消失？</a></p></blockquote><h2 data-lake-id="dc9f03115bf131a979cc8f96aa024b51" id="4B7Ww" style="padding: 7px 0px; margin: 0px; font-weight: 700; font-size: 24px; line-height: 32px;">理解什么是域名注册商？</h2><blockquote style="padding-left: 1em; margin-top: 5px; margin-bottom: 5px; margin-left: 0px; border-left: 3px solid rgb(238, 238, 238); opacity: 0.6;"><p data-lake-id="adfedbee81dfb532339a7cf2ce133800" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">域名服务器之所以能知道域名与 IP 地址的映射信息，是因为我们在域名服务商那里提交了域名记录。购买了一个域名之后，我们需要在域名服务商那里设置域名解析的记录，域名服务商把这些记录推送到权威域名服务器，这样我们的域名才能正式生效。</p><p data-lake-id="f5c2d8e7621afe29f08a554fc85b5eb1" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">常见的域名服务商有阿里云、腾讯云等等……</p></blockquote><p data-lake-id="ed2d627e039df479e28204f746a09736" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><h3 data-lake-id="0b6a493bd3b95a64eee229ed099d4e48" id="SSnav" style="padding: 7px 0px; margin: 0px; font-weight: 700; font-size: 20px; line-height: 28px;">注册域名注册商</h3><p data-lake-id="76f57c7e99c0dc75a6e571d973945d3c" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">要成为域名注册商需要提权，具体参考：<a href="https://baike.baidu.com/item/%E5%9F%9F%E5%90%8D%E6%B3%A8%E5%86%8C%E5%95%86" target="_blank">https://baike.baidu.com/item/%E5%9F%9F%E5%90%8D%E6%B3%A8%E5%86%8C%E5%95%86</a></p><p data-lake-id="06be4f72f91ac2dde73f73b3bbf46051" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span data-card-type="inline" data-lake-card="image" class="lake-card-margin-top lake-card-margin-bottom"><img data-role="image" src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1618646601711-fca612d8-b2cd-4c22-8417-5938c415c7ce.png" data-raw-src="" class="image lake-drag-image" alt="image.png" title="image.png" data-height="85px" style="visibility: visible; width: 532px;"></span></p><h3 data-lake-id="004bc62474ceb180c59870df62f03064" id="KiHSB" style="padding: 7px 0px; margin: 0px; font-weight: 700; font-size: 20px; line-height: 28px;">ICANN</h3><p data-lake-id="4c9ca4772d8e63100012dc5fb1a91a45" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">『互联网名称与数字地址分配机构』</p><p data-lake-id="24609c832d6f348497c178acd6cf2dab" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">可以看看发展历程</p><p data-lake-id="97b91b88d06c1a605a293875fbecabf3" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span data-card-type="inline" data-lake-card="image" class="lake-card-margin-top lake-card-margin-bottom"><img data-role="image" src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1618646847974-89e834aa-7e05-4788-aebb-ac3a084362e4.png" data-raw-src="" class="image lake-drag-image" alt="image.png" title="image.png" data-height="382px" style="visibility: visible; width: 553.5px;"></span></p><p data-lake-id="e4f1cda3459a5b5b0c247267f85eac42" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">不仅如此，包含全球的域名相关信息的ICANN的数据库管控方式也是极为严格，</p><p data-lake-id="9e7f3f82f476a2f40719f5e0af18eef8" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span data-card-type="inline" data-lake-card="image" class="lake-card-margin-top lake-card-margin-bottom"><img data-role="image" src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1618646929122-b3d35ad5-9a28-4fd2-a56f-1b7164cd51ff.png" data-raw-src="" class="image lake-drag-image" alt="image.png" title="image.png" data-height="242px" style="visibility: visible; width: 555.5px;"></span></p><p data-lake-id="9056b8917ea83736ad7c0873a0fc9b8e" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">像极了电影里面的情节<span data-card-type="inline" data-lake-card="image" class="lake-card-margin-top lake-card-margin-bottom"><img data-role="image" src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1618646983840-652fc715-3b53-427d-9722-86890ccbe07a.jpeg" data-raw-src="" class="image lake-drag-image" alt="huaji1558a846ddf2e12b.jpeg" title="huaji1558a846ddf2e12b.jpeg" data-height="59px" style="visibility: visible; width: 55px;"></span></p><p data-lake-id="98c8450eeafbd5e497108e18580d79b8" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">具体参考：<a href="https://baike.baidu.com/item/%E4%BA%92%E8%81%94%E7%BD%91%E5%90%8D%E7%A7%B0%E4%B8%8E%E6%95%B0%E5%AD%97%E5%9C%B0%E5%9D%80%E5%88%86%E9%85%8D%E6%9C%BA%E6%9E%84/2775450?fromtitle=ICANN&amp;fromid=6807198" target="_blank">https://baike.baidu.com/item/%E4%BA%92%E8%81%94%E7%BD%91%E5%90%8D%E7%A7%B0%E4%B8%8E%E6%95%B0%E5%AD%97%E5%9C%B0%E5%9D%80%E5%88%86%E9%85%8D%E6%9C%BA%E6%9E%84/2775450?fromtitle=ICANN&amp;fromid=6807198</a></p><p data-lake-id="3634e4e1e97dbc2d2c0264d33ab6e04d" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><h2 data-lake-id="4abf672446cb6fe5eaf462baa4f8bcc3" id="59xby" style="padding: 7px 0px; margin: 0px; font-weight: 700; font-size: 24px; line-height: 32px;">域名解析过程</h2><p data-lake-id="71a80dbdbfd5889f40353a3a80b66a3c" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><blockquote class="lake-alert lake-alert-info" style="background-color: rgb(232, 247, 255); margin: 0px; padding: 10px; border: 1px solid rgb(171, 210, 218); opacity: 1; border-radius: 3px; color: rgb(38, 38, 38);"><p data-lake-id="f19f6e4e3c9b012ea32ed4cc472712d7" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">了解了上面一些DNS宏观的设计方式，再来到域名解析就比较好理解了，域名解析就是将域名解析为IP地址，它怎么解析呢？利用在域名服务器里面查找有没有相关的解析记录。</p></blockquote><p data-lake-id="3a46bb7b8be5f903df7b243a4f66381f" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="10fc7258fdc590421f837ccdd5f460e9" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span data-card-type="inline" data-lake-card="image" class="lake-card-margin-top lake-card-margin-bottom"><img data-role="image" src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1618647354829-7da7d070-ba2e-404d-937d-45dcfb2faf25.png" data-raw-src="" class="image lake-drag-image" alt="image.png" title="image.png" data-height="329px" style="visibility: visible; width: 646.5px;"></span></p><p data-lake-id="f0d402c626b6a0792e62b7d6ea8d8f7a" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span data-card-type="inline" data-lake-card="image" class="lake-card-margin-top lake-card-margin-bottom"><img data-role="image" src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1618647396384-6ec5030a-0fdf-46c5-9ebb-1d257d92f2c9.png" data-raw-src="" class="image lake-drag-image" alt="image.png" title="image.png" data-height="333px" style="visibility: visible; width: 471.5px;"></span></p><h2 data-lake-id="66a563b6690fbe174ae4beb11e40739d" id="7Elhd" style="padding: 7px 0px; margin: 0px; font-weight: 700; font-size: 24px; line-height: 32px;">使用工具查看DNS查询过程</h2><h3 data-lake-id="d25b2b925de1038ee94bcc037a16cf1d" id="fuhq6" style="padding: 7px 0px; margin: 0px; font-weight: 700; font-size: 20px; line-height: 28px;">Linux下的dig命令</h3><p data-lake-id="3a937ee6b6bc4b2c91ddb33518ce531b" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span data-card-type="inline" data-lake-card="image" class="lake-card-margin-top lake-card-margin-bottom"><img data-role="image" src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1618649698238-46345e66-fccd-4ad5-b99c-76db7072c62f.png" data-raw-src="" class="image lake-drag-image" alt="image.png" title="image.png" data-height="360px" style="visibility: visible; width: 720px;"></span></p><h3 data-lake-id="ef503ad3f8edfe300c6f97d22ab47f3a" id="VGQRU" style="padding: 7px 0px; margin: 0px; font-weight: 700; font-size: 20px; line-height: 28px;">Windows下的trance命令</h3><p data-lake-id="984c3f3cbc5a4292ba60871d988d97e8" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span data-card-type="inline" data-lake-card="image" class="lake-card-margin-top lake-card-margin-bottom"><img data-role="image" src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1618649719833-b58925d7-4a25-4bdc-897b-e7bb281efed5.png" data-raw-src="" class="image lake-drag-image" alt="image.png" title="image.png" data-height="360px" style="visibility: visible; width: 720px;"></span></p><p data-lake-id="5e639c59243b33bb22120546f13a53c4" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><h2 data-lake-id="2ccbd3230b7ec01b60999276b4935e05" id="zlv4P" style="padding: 7px 0px; margin: 0px; font-weight: 700; font-size: 24px; line-height: 32px;">参考</h2><ul data-lake-id="9506c2ac3a1f5e61b993e4a5211b1929" lake-indent="0" style="list-style-type: disc; margin: 0px; padding-left: 23px; font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word;"><li data-lake-id="88c500237bd998872be26826ce7e62c7"><a href="https://github.com/ruanyf/articles/blob/master/2016/2016-06-15-dns.md" target="_blank">DNS 原理入门 - 阮一峰的网络日志</a></li><li data-lake-id="1473e4390fa9183575fc62148041d58b"><a href="https://segmentfault.com/a/1190000023696737" target="_blank">https://segmentfault.com/a/1190000023696737</a></li><li data-lake-id="fbafc64d00d65323ec9d045a47070dd8"><a href="https://baike.baidu.com/item/%E5%9F%9F%E5%90%8D%E6%B3%A8%E5%86%8C%E5%95%86" target="_blank">https://baike.baidu.com/item/%E5%9F%9F%E5%90%8D%E6%B3%A8%E5%86%8C%E5%95%86</a></li><li data-lake-id="146e25f3e8343119b2922eb9d154a4c9"><a href="https://baike.baidu.com/item/%E4%BA%92%E8%81%94%E7%BD%91%E5%90%8D%E7%A7%B0%E4%B8%8E%E6%95%B0%E5%AD%97%E5%9C%B0%E5%9D%80%E5%88%86%E9%85%8D%E6%9C%BA%E6%9E%84/2775450?fromtitle=ICANN&amp;fromid=6807198" target="_blank">https://baike.baidu.com/item/%E4%BA%92%E8%81%94%E7%BD%91%E5%90%8D%E7%A7%B0%E4%B8%8E%E6%95%B0%E5%AD%97%E5%9C%B0%E5%9D%80%E5%88%86%E9%85%8D%E6%9C%BA%E6%9E%84/2775450?fromtitle=ICANN&amp;fromid=6807198</a></li></ul></div>]]></content>
      
      
      <categories>
          
          <category> 计算机素养 </category>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>客户端存储</title>
      <link href="/blog/bzdwkx/"/>
      <url>/blog/bzdwkx/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h3 id="bt5VO"><span class="ne-text">本地存储特性</span></h3><ul class="ne-ul"><li id="fe1e67d146dcba84053c3ed73416e503"><span class="ne-text">数据存储在用户浏览器中</span></li><li id="694d4c336287d21891a48c1585df9167"><span class="ne-text">设置、读取方便、甚至页面刷新不丢失数据</span></li><li id="9e0c681e5ab26d20e35a98ee55ab923e"><span class="ne-text">容量较大，</span><code class="ne-code"><span class="ne-text">sessionStorage</span></code><span class="ne-text">约</span><code class="ne-code"><span class="ne-text">5M</span></code><span class="ne-text">、</span><code class="ne-code"><span class="ne-text">localStorage</span></code><span class="ne-text">约</span><code class="ne-code"><span class="ne-text">20M</span></code></li><li id="b4c20b4d476feaa8701afb77bc733fd2"><span class="ne-text">只能存储字符串，可以将对象</span><code class="ne-code"><span class="ne-text">JSON.stringify()</span></code><span class="ne-text">编码后存储，然后使用的使用</span><code class="ne-code"><span class="ne-text">JSON.parse()</span></code><span class="ne-text">转换回对象</span></li></ul><h3 id="0VYws"><span class="ne-text">window.sessionStorage</span></h3><p id="4fbc447b4ea9f2038b2724db70d01ac3" class="ne-p"><span class="ne-text">1、生命周期为关闭浏览器窗口</span></p><p id="ccbbbcff305024a4dcdaaba7a6fafb46" class="ne-p"><span class="ne-text">2、在同一个窗口(页面)下数据可以共享</span></p><p id="a89a782ba947bdd860fc28e00b0ec836" class="ne-p"><span class="ne-text">3、以键值对的形式存储使用</span></p><p id="0d5a24edd5013b2b523b7556c60b3a03" class="ne-p"><span class="ne-text">存储数据：</span></p><pre><code>sessionStorage.setItem(key, value)</code></pre><p id="378124830a6c00a1292d88c4290e2e3a" class="ne-p"><span class="ne-text">获取数据：</span></p><pre><code>sessionStorage.getItem(key)</code></pre><p id="de29b3a1eac52596c4d6ad3477a15da7" class="ne-p"><span class="ne-text">删除数据：</span></p><pre><code>sessionStorage.removeItem(key)</code></pre><p id="1e38450b9673a6b54d83ef06310d138d" class="ne-p"><span class="ne-text">清空数据：(所有都清除掉)</span></p><pre><code>sessionStorage.clear()</code></pre><h3 id="W0req"><span class="ne-text">window.localStorage</span></h3><p id="a007e6a71e5ca794e958969ddef8bdba" class="ne-p"><span class="ne-text">1、声明周期永久生效，除非手动删除 否则关闭页面也会存在</span></p><p id="6a425f93f4e0f02acb3258b01229e6ab" class="ne-p"><span class="ne-text">2、可以多窗口（页面）共享（同一浏览器可以共享）</span></p><p id="a518a54105653ec1d50b49829412919b" class="ne-p"><span class="ne-text">3.  以键值对的形式存储使用</span></p><p id="1484f30a6a428ec7aa94550ad64b0dfe" class="ne-p"><span class="ne-text">存储数据：</span></p><pre><code>localStorage.setItem(key, value)</code></pre><p id="ca6e3b4987fe148e2ca3e237353b2b91" class="ne-p"><span class="ne-text">获取数据：</span></p><pre><code>localStorage.getItem(key)</code></pre><p id="e9492b2f395dc29922c93f6fa0ecb2bb" class="ne-p"><span class="ne-text">删除数据：</span></p><pre><code>localStorage.removeItem(key)</code></pre><p id="81471323871e63783885b77b2ca4387e" class="ne-p"><span class="ne-text">清空数据：(所有都清除掉)</span></p><pre><code>localStorage.clear()</code></pre><h3 id="swXya"><span class="ne-text">工具函数的封装</span></h3><pre><code>class StorageFn &#123;    constructor () &#123;        this.ls = window.localStorage;        this.ss = window.sessionStorage;    &#125;<pre><code>/*-----------------cookie---------------------*//*设置cookie*/setCookie (name, value, day) &#123;    var setting = arguments[0];    if (Object.prototype.toString.call(setting).slice(8, -1) === &#39;Object&#39;)&#123;        for (var i in setting) &#123;            var oDate = new Date();            oDate.setDate(oDate.getDate() + day);            document.cookie = i + &#39;=&#39; + setting[i] + &#39;;expires=&#39; + oDate;        &#125;    &#125;else&#123;        var oDate = new Date();        oDate.setDate(oDate.getDate() + day);        document.cookie = name + &#39;=&#39; + value + &#39;;expires=&#39; + oDate;    &#125;    &#125;/*获取cookie*/getCookie (name) &#123;    var arr = document.cookie.split(&#39;; &#39;);    for (var i = 0; i &amp;lt; arr.length; i++) &#123;        var arr2 = arr[i].split(&#39;=&#39;);        if (arr2[0] == name) &#123;            return arr2[1];        &#125;    &#125;    return &#39;&#39;;&#125;/*删除cookie*/removeCookie (name) &#123;    this.setCookie(name, 1, -1);&#125;/*-----------------localStorage---------------------*//*设置localStorage*/setLocal(key, val) &#123;    var setting = arguments[0];    if (Object.prototype.toString.call(setting).slice(8, -1) === &#39;Object&#39;)&#123;        for(var i in setting)&#123;            this.ls.setItem(i, JSON.stringify(setting[i]))        &#125;    &#125;else&#123;        this.ls.setItem(key, JSON.stringify(val))    &#125;    &#125;/*获取localStorage*/getLocal(key) &#123;    if (key) return JSON.parse(this.ls.getItem(key))    return null;    &#125;/*移除localStorage*/removeLocal(key) &#123;    this.ls.removeItem(key)&#125;/*移除所有localStorage*/clearLocal() &#123;    this.ls.clear()&#125;/*-----------------sessionStorage---------------------*//*设置sessionStorage*/setSession(key, val) &#123;    var setting = arguments[0];    if (Object.prototype.toString.call(setting).slice(8, -1) === &#39;Object&#39;)&#123;        for(var i in setting)&#123;            this.ss.setItem(i, JSON.stringify(setting[i]))        &#125;    &#125;else&#123;        this.ss.setItem(key, JSON.stringify(val))    &#125;    &#125;/*获取sessionStorage*/getSession(key) &#123;    if (key) return JSON.parse(this.ss.getItem(key))    return null;    &#125;/*移除sessionStorage*/removeSession(key) &#123;    this.ss.removeItem(key)&#125;/*移除所有sessionStorage*/clearSession() &#123;    this.ss.clear()&#125;</code></pre><p>}<br></code></pre></p></div>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
          <category> JavaScript </category>
          
          <category> BOM </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>综合实验2——约瑟夫环🔖链表</title>
      <link href="/blog/itu2g5/"/>
      <url>/blog/itu2g5/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h2 id="FMVQA"><span class="ne-text">问题描述</span></h2><p id="76743e7f4199f7efee4a22b25121b5e5" class="ne-p" style="text-align: left"><span class="ne-text" style="font-size: 16px">设有</span><span class="ne-text" style="font-size: 16px">n</span><span class="ne-text" style="font-size: 16px">个人围坐在圆桌周围，现从某个位置</span><span class="ne-text" style="font-size: 16px">m(1</span><span class="ne-text" style="font-size: 16px">≤</span><span class="ne-text" style="font-size: 16px">m</span><span class="ne-text" style="font-size: 16px">≤</span><span class="ne-text" style="font-size: 16px">n)</span><span class="ne-text" style="font-size: 16px">上的人开始报数，报数到</span><span class="ne-text" style="font-size: 16px">k</span><span class="ne-text" style="font-size: 16px">的人就站出来。下一个人，即原来的第</span><span class="ne-text" style="font-size: 16px">k+1</span><span class="ne-text" style="font-size: 16px">个位置上的人，又从</span><span class="ne-text" style="font-size: 16px">1</span><span class="ne-text" style="font-size: 16px">开始报数，再报数到</span><span class="ne-text" style="font-size: 16px">k</span><span class="ne-text" style="font-size: 16px">的人站出来。依次重复下去，直到全部的人都站出来为止。试设计一个程序求出这</span><span class="ne-text" style="font-size: 16px">n</span><span class="ne-text" style="font-size: 16px">个人的</span><strong><span class="ne-text" style="font-size: 16px">出列顺序</span></strong><span class="ne-text" style="font-size: 16px">。</span></p><h2 id="TthUA"><span class="ne-text">问题要求</span></h2><ol class="ne-ol"><li id="f7ffa65606c3c5ce4f0945ee28b9389d"><span class="ne-text" style="font-size: 16px">构造一个具有</span><span class="ne-text" style="font-size: 16px">n</span><span class="ne-text" style="font-size: 16px">个结点的循环单链表，用于存储圆桌周围的人的编号，链表结点的</span><span class="ne-text" style="font-size: 16px">data</span><span class="ne-text" style="font-size: 16px">域存放桌子周围的人的编号。</span></li><li id="7474e399364ccbe7fb2f5a2a999027b9"><span class="ne-text" style="font-size: 16px">为保持程序的通用性</span><span class="ne-text" style="font-size: 16px">,</span><span class="ne-text" style="font-size: 16px">问题中的</span><span class="ne-text" style="font-size: 16px">n</span><span class="ne-text" style="font-size: 16px">、</span><span class="ne-text" style="font-size: 16px">m</span><span class="ne-text" style="font-size: 16px">、</span><span class="ne-text" style="font-size: 16px">k</span><span class="ne-text" style="font-size: 16px">可由用户从键盘输入</span><span class="ne-text" style="font-size: 16px">.</span></li><li id="234247c54de30c2b78b470b84bd03335"><span class="ne-text" style="font-size: 16px">要求编写函数模拟约瑟夫问题的实现过程</span><span class="ne-text" style="font-size: 16px">,</span><span class="ne-text" style="font-size: 16px">并输出</span><span class="ne-text" style="font-size: 16px">n</span><span class="ne-text" style="font-size: 16px">个人的出列顺序。</span></li></ol><h2 id="4I3Ah"><span class="ne-text">问题分析</span></h2><p id="5a6ecfa618166afd045d0a0791b14f3b" class="ne-p" style="text-align: left"><span class="ne-text" style="font-size: 16px">这个问题和综合实验一的思路一样，都是利用循环单链表（所以理论上之前的狐狸逮兔子应该用顺序表，而我用了链表</span><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1617761762269-2745323d-e497-4442-984b-fe31e817f25a.jpeg" width="62" id="stiqD" class="ne-image" style="font-size: 16px"><span class="ne-text" style="font-size: 16px">）。</span></p><h2 id="E798Q"><span class="ne-text">代码</span></h2><p id="3dccd7bfd415ad54cdb2e26974c2bf5b" class="ne-p"><span class="ne-text">写代码过程中，题目没看清楚，一开始以为是被选中的人还呆在环里面，就导致我的指针指了一下午的寂寞……</span><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1617799608465-1b5ed521-81ea-4434-a2bb-3d104e6ea038.jpeg" width="52" id="gg81l" class="ne-image"><span class="ne-text">，不说了，交实验报告去了……</span></p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;<p>/**</p><ul><li>定义一个单链表</li><li>/<br>typedef struct LNode &#123;<br>  int data;<br>  struct LNode *next;<br>&#125;Lnode, *LinkList;</li></ul><p>/**</p><ul><li>初始化单链表</li><li>/<br>void InitList(LinkList &amp;L) &#123;<br>  L = new LNode;<br>  L-&gt;next = NULL;<br>  L-&gt;data = 1;<br>&#125;</li></ul><p>/* 初始化循环链表的初始值 */<br>void init_add(LinkList &amp;L, int n) &#123;<br>    InitList(L);<br>    LinkList p = L;<br>    for (int i = 2; i &lt;= n;i++) &#123;<br>        LinkList p_temp = new Lnode;<br>        p_temp-&gt;data = i;<br>        if (i == n) &#123;<br>            p_temp-&gt;next = L;<br>            p-&gt;next = p_temp;<br>        &#125; else &#123;<br>            p_temp-&gt;next = p-&gt;next;<br>            p-&gt;next = p_temp;<br>            p = p-&gt;next;<br>        &#125;<br>    &#125;<br>&#125;</p><p>void joseph_ring(LinkList &amp;L, int n, int m, int k) &#123;<br>    init_add(L, n);<br>    LinkList p = L;<br>    for (int i = 0; i&lt; m; i++) &#123;<br>        p = p-&gt;next;<br>    &#125;<br>    while(p-&gt;next != p) &#123;<br>        for (int j = 1; j&lt; k; j++) &#123;<br>            if (j == k-1) &#123;<br>                cout&lt;&lt;p-&gt;next-&gt;data&lt;&lt;&quot;号出来&quot;&lt;&lt;&quot;\n&quot;;<br>                p-&gt;next = p-&gt;next-&gt;next;<br>                p = p-&gt;next;<br>            &#125; else &#123;<br>                p = p-&gt;next;<br>            &#125;<br>        &#125;<br>    &#125;<br>    cout&lt;&lt; p-&gt;data&lt;&lt;&quot;号出来&quot;&lt;&lt;&quot;\n&quot;;</p><p>&#125;</p><p>int main()<br>&#123;<br>    cout &lt;&lt; &quot;请依次输入人数n、报数位置m、报到指定值就站起来的k值&quot; &lt;&lt; &quot;\n&quot;;<br>    int n, m, k;<br>    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;<br>    LinkList p;<br>    joseph_ring(p, n, m, k);<br>&#125;<br></code></pre></p><p id="77d3f4a34fbc0db46b044a8d3113eb4f" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1618305848004-50b702f4-e85f-410e-8310-bbd0c16ecac2.png" width="466.5" id="Mzbfg" class="ne-image"></p></div>]]></content>
      
      
      <categories>
          
          <category> 计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 🔗线结构：链表 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>综合实验1——狐狸逮兔子🔖链表</title>
      <link href="/blog/bexxoi/"/>
      <url>/blog/bexxoi/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h2 id="PyYRh"><span class="ne-text">问题描述</span></h2><p id="68664ae3a87302ca7bffb18e27450a37" class="ne-p" style="text-align: left"><span class="ne-text" style="font-size: 16px">围绕着山顶有</span><span class="ne-text" style="font-size: 16px">10</span><span class="ne-text" style="font-size: 16px">个圆形排列的洞</span><span class="ne-text" style="font-size: 16px">,狐狸</span><span class="ne-text" style="font-size: 16px">要吃兔子</span><span class="ne-text" style="font-size: 16px">,</span><span class="ne-text" style="font-size: 16px">兔子说</span><span class="ne-text" style="font-size: 16px">:”</span><span class="ne-text" style="font-size: 16px">可以</span><span class="ne-text" style="font-size: 16px">,</span><span class="ne-text" style="font-size: 16px">但必须找到我</span><span class="ne-text" style="font-size: 16px">,</span><span class="ne-text" style="font-size: 16px">我就藏于这</span><span class="ne-text" style="font-size: 16px">10</span><span class="ne-text" style="font-size: 16px">个洞中</span><span class="ne-text" style="font-size: 16px">,</span><span class="ne-text" style="font-size: 16px">你先到</span><span class="ne-text" style="font-size: 16px">1</span><span class="ne-text" style="font-size: 16px">号洞找</span><span class="ne-text" style="font-size: 16px">,</span><span class="ne-text" style="font-size: 16px">第二次隔</span><span class="ne-text" style="font-size: 16px">1</span><span class="ne-text" style="font-size: 16px">个洞</span><span class="ne-text" style="font-size: 16px">(</span><span class="ne-text" style="font-size: 16px">即</span><span class="ne-text" style="font-size: 16px">3</span><span class="ne-text" style="font-size: 16px">号洞</span><span class="ne-text" style="font-size: 16px">)</span><span class="ne-text" style="font-size: 16px">找</span><span class="ne-text" style="font-size: 16px">,</span><span class="ne-text" style="font-size: 16px">第二次隔</span><span class="ne-text" style="font-size: 16px">2</span><span class="ne-text" style="font-size: 16px">个洞</span><span class="ne-text" style="font-size: 16px">(</span><span class="ne-text" style="font-size: 16px">即</span><span class="ne-text" style="font-size: 16px">6</span><span class="ne-text" style="font-size: 16px">号洞</span><span class="ne-text" style="font-size: 16px">)</span><span class="ne-text" style="font-size: 16px">找</span><span class="ne-text" style="font-size: 16px">,</span><span class="ne-text" style="font-size: 16px">以后如此类推</span><span class="ne-text" style="font-size: 16px">,</span><span class="ne-text" style="font-size: 16px">次数不限</span><span class="ne-text" style="font-size: 16px">.”</span><span class="ne-text" style="font-size: 16px">但狐狸从早到晚进进出出了</span><span class="ne-text" style="font-size: 16px">1000</span><span class="ne-text" style="font-size: 16px">次</span><span class="ne-text" style="font-size: 16px">,</span><span class="ne-text" style="font-size: 16px">仍没有找到兔子</span><span class="ne-text" style="font-size: 16px">.</span><span class="ne-text" style="font-size: 16px">问</span><span class="ne-text" style="font-size: 16px">:</span><span class="ne-text" style="font-size: 16px">兔子究竟藏在那个洞里</span><span class="ne-text" style="font-size: 16px">?</span></p><p id="u97a0e4c8" class="ne-p" style="text-align: left"><span class="ne-text" style="font-size: 16px"></span></p><h2 id="5AMn1"><span class="ne-text">问题要求</span></h2><ol class="ne-ol"><li id="5faf33621f969d6114ccd33d665e60dd"><span class="ne-text" style="font-size: 16px">设计一种存储方式用于存储山洞</span><span class="ne-text" style="font-size: 16px">,</span><span class="ne-text" style="font-size: 16px">元素的下标表示山洞的编号</span><span class="ne-text" style="font-size: 16px">,</span><span class="ne-text" style="font-size: 16px">元素的值为</span><span class="ne-text" style="font-size: 16px">1</span><span class="ne-text" style="font-size: 16px">表示狐狸没有进过山洞</span><span class="ne-text" style="font-size: 16px">,</span><span class="ne-text" style="font-size: 16px">为</span><span class="ne-text" style="font-size: 16px">0</span><span class="ne-text" style="font-size: 16px">表示狐狸进过该山洞</span><span class="ne-text" style="font-size: 16px">.</span></li><li id="f878e49a39c71c179a009fc33c471445"><span class="ne-text" style="font-size: 16px">为保持程序的通用性</span><span class="ne-text" style="font-size: 16px">,</span><span class="ne-text" style="font-size: 16px">山洞的数目和狐狸进出山洞的次数不一定为题设的</span><span class="ne-text" style="font-size: 16px">10</span><span class="ne-text" style="font-size: 16px">和</span><span class="ne-text" style="font-size: 16px">1000,</span><span class="ne-text" style="font-size: 16px">可由用户从键盘输入</span><span class="ne-text" style="font-size: 16px">.</span></li><li id="80dac89e32893d84daf589e4340ebd9b"><span class="ne-text" style="font-size: 16px">要求编写函数模拟狐狸逮兔子的过程</span><span class="ne-text" style="font-size: 16px">,</span><span class="ne-text" style="font-size: 16px">并输出兔子可能的藏身之处</span><span class="ne-text" style="font-size: 16px">.</span></li></ol><p id="8b49c149e23f9100f3206f3d7eb62b55" class="ne-p"><span class="ne-text" style="font-size: 16px">注：实验报告中要求说明采用了什么存储结构。</span></p><h2 id="RU5tb"><span class="ne-text">问题分析</span></h2><p id="85384a1ced148c62d966da4e772571c1" class="ne-p" style="text-align: left"><span class="ne-text" style="font-size: 16px">这实际上是一个反复查找线性表的过程</span><span class="ne-text" style="font-size: 16px">.</span></p><p id="94ce9c55919fd04eb253ed8b75d78535" class="ne-p" style="text-align: left"><span class="ne-text" style="text-decoration: line-through; font-size: 16px">定义一个顺序表</span><span class="ne-text" style="text-decoration: line-through; font-size: 16px">,</span><span class="ne-text" style="text-decoration: line-through; font-size: 16px">用具有</span><span class="ne-text" style="text-decoration: line-through; font-size: 16px">10</span><span class="ne-text" style="text-decoration: line-through; font-size: 16px">个元素的顺序表来表示这</span><span class="ne-text" style="text-decoration: line-through; font-size: 16px">10</span><span class="ne-text" style="text-decoration: line-through; font-size: 16px">个洞</span><span class="ne-text" style="text-decoration: line-through; font-size: 16px">.</span><span class="ne-text" style="text-decoration: line-through; font-size: 16px">每个元素表示围绕山顶的一个洞</span><span class="ne-text" style="text-decoration: line-through; font-size: 16px">,</span><span class="ne-text" style="text-decoration: line-through; font-size: 16px">下标为洞的编号</span><span class="ne-text" style="text-decoration: line-through; font-size: 16px">.</span><span class="ne-text" style="text-decoration: line-through; font-size: 16px">对所有洞设置初始标志为</span><span class="ne-text" style="text-decoration: line-through; font-size: 16px">1,</span><span class="ne-text" style="text-decoration: line-through; font-size: 16px">然后通过</span><span class="ne-text" style="text-decoration: line-through; font-size: 16px">1000</span><span class="ne-text" style="text-decoration: line-through; font-size: 16px">次循环</span><span class="ne-text" style="text-decoration: line-through; font-size: 16px">,</span><span class="ne-text" style="text-decoration: line-through; font-size: 16px">对每次所进之洞修改标志为</span><span class="ne-text" style="text-decoration: line-through; font-size: 16px">0,</span><span class="ne-text" style="text-decoration: line-through; font-size: 16px">最后输出标志为</span><span class="ne-text" style="text-decoration: line-through; font-size: 16px">1</span><span class="ne-text" style="text-decoration: line-through; font-size: 16px">的洞</span><span class="ne-text" style="text-decoration: line-through; font-size: 16px">,</span><span class="ne-text" style="text-decoration: line-through; font-size: 16px">即兔子藏身的洞</span><span class="ne-text" style="font-size: 16px">.</span></p><p id="19a5619b15d3f1fec17d3e9d6ebc376b" class="ne-p" style="text-align: left"><span class="ne-text" style="font-size: 16px">定义了一个单链表，将其转换为循环链表，利用循环链表来解决了这个问题。</span></p><h2 id="EbCn3"><span class="ne-text">代码</span></h2><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;<p>typedef struct LNode &#123;<br>    int data;<br>    int flag;<br>    struct LNode *next;<br>&#125;Lnode, *LinkList;</p><p>int main() &#123;<br>    LinkList L;<br>    L = new LNode;<br>    L-&gt;data = 1;<br>    L-&gt;flag = 1;<br>    L-&gt;next = NULL;<br>    for (int i = 1; i &lt; 10;i++) &#123;<br>        LinkList p;<br>        p = new LNode;<br>        p-&gt;data = 11-i;<br>        p-&gt;flag = 1;<br>        p-&gt;next = L-&gt;next;<br>        L-&gt;next = p;<br>        if (i == 1)&#123;<br>            p-&gt;next = L;<br>        &#125;<br>    &#125;</p><pre><code>LinkList s;s = new LNode;s = L;for (int i = 0; i &amp;lt; 1000;i++) &#123;    s-&amp;gt;flag = 0;    for (int j = 0; j &amp;lt; i+2;j++) &#123;        s = s-&amp;gt;next;    &#125;&#125;cout &amp;lt;&amp;lt; &amp;quot;最终结果：&amp;quot;&amp;lt;&amp;lt; &amp;quot;\n&amp;quot;;for (int i = 0; i &amp;lt; 10;i++)&#123;    cout &amp;lt;&amp;lt; L-&amp;gt;data &amp;lt;&amp;lt;&amp;quot;洞&amp;quot;&amp;lt;&amp;lt; &amp;quot; &amp;quot; &amp;lt;&amp;lt; L-&amp;gt;flag &amp;lt;&amp;lt; &amp;quot;\n&amp;quot;;    L = L-&amp;gt;next;&#125;</code></pre><p>}<br></code></pre></p><p id="08bfc357d12d7c800475ed13e89e31fb" class="ne-p"><span class="ne-text" style="font-size: 16px"></span></p><p id="308c8b412ea8db17fbec5f4d9585c80d" class="ne-p"><span class="ne-text" style="font-size: 16px"> </span></p><p id="1cd3c1d9b37ab8d19bc96a09ccc7e035" class="ne-p"><span class="ne-text" style="font-size: 16px"> </span></p><p id="75d6038d714c56f1524323be1470baf8" class="ne-p"><span class="ne-text" style="font-size: 16px"></span></p></div>]]></content>
      
      
      <categories>
          
          <category> 计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 🔗线结构：链表 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Write Code Summary</title>
      <link href="/blog/fit037/"/>
      <url>/blog/fit037/</url>
      
        <content type="html"><![CDATA[<div class="yuque-hexo-lyrics-secret">这是加密文章！</div>]]></content>
      
      
      <categories>
          
          <category> 计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 📌数据结构和算法综述 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++串</title>
      <link href="/blog/hcwio0/"/>
      <url>/blog/hcwio0/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content-editor-core lake-engine lake-typography-classic" data-lake-element="root" data-selection-undefined="%7B%22path%22%3A%5B%5B12%2C0%2C14%5D%2C%5B12%2C0%2C14%5D%5D%2C%22active%22%3Atrue%7D"><h2 data-lake-id="f265812fd0ea136fc0cb08637c13c905" id="v6aeX" style="padding: 7px 0px; margin: 0px; font-weight: 700; font-size: 24px; line-height: 32px;">课后一些问题</h2><p data-lake-id="31dcf9c599f0a38ce7dfec130ed9a175" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">（1）串是一种特殊的线性表，其特殊性体现在（ &nbsp;）。</p><p data-lake-id="b696679a3f8e3e7ff083b2b85ece3497" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"> &nbsp;A．可以顺序存储 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <strong>&nbsp; B．数据元素是一个字符 &nbsp; </strong>&nbsp; &nbsp;</p><p data-lake-id="d6c3841d7e341e214200b07f4fd282d4" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">C．可以链式存储 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; D．数据元素可以是多个字符若 &nbsp;</p><p data-lake-id="a3939fa8d1e2259268cc78b5ee563022" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">答案：B</p><p data-lake-id="d6d0eddef652ccc89742e2efd7da81a2" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="b3c9440a7cdecd4ce0dd0bdfdc03fcde" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">（2）串下面关于串的的叙述中，（ &nbsp;）是不正确的？ &nbsp;</p><p data-lake-id="ed64bcc84722f575ba3518bd135bc206" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">A．串是字符的有限序列 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<strong>B．空串是由空格构成的串</strong></p><p data-lake-id="6bf941378f090c901f73f1246d2f8732" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">C．模式匹配是串的一种重要运算 &nbsp;D．串既可以采用顺序存储，也可以采用链式存储</p><p data-lake-id="6f341985e3ea3d674cdd927cae6796a2" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">答案：B</p><p data-lake-id="d878bd0a038c640896dd8f04a309a8bf" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">解释：空格常常是串的字符集合中的一个元素，有一个或多个空格组成的串成为空格串，零个字符的串成为空串，其长度为零。 &nbsp;</p><p data-lake-id="8673313376125a3b137f76bd69946003" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="c6a8a28c382e562ac2d4da16640d1068" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">（5）串的长度是指（ &nbsp;）。</p><p data-lake-id="25636c2447e4fa8a95d61194f1a57570" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">A．串中所含不同字母的个数 &nbsp; &nbsp;<strong> &nbsp; B．串中所含字符的个数</strong></p><p data-lake-id="3821edffbc48826fa70d1af55d056424" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">C．串中所含不同字符的个数 &nbsp; &nbsp; &nbsp; D．串中所含非空格字符的个数</p><p data-lake-id="145dc10f528d8704b69109679379ddc7" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">答案：B</p><p data-lake-id="00bb229b2b0660bdbd3bb980d0e2a44d" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">解释：串中字符的数目称为串的长度。</p></div>]]></content>
      
      
      <categories>
          
          <category> 计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 📶线结构：字符串-数组-栈-队列 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>今年的清明有点不一样</title>
      <link href="/essay/nyh946/"/>
      <url>/essay/nyh946/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="traditional"><p class="ne-p"><span class="ne-text">还是在昨天，济南这边下了一场不小的雨，图书馆外的风甚是喧嚣，今天却又是格外晴朗…</span></p><p class="ne-p"><br></p><p class="ne-p"><span class="ne-text">和三月份回学校那天一样，南昌下着大雨，在去昌北机场大巴的车上，鹏鹏打电话和我说华哥死了的时候，那会儿我是很突然的，还没反应过来，人就懵了…车窗外的雨下的愈来愈大</span></p><p class="ne-p"><br></p><p class="ne-p"><span class="ne-text">以前，亲戚长辈们总和我们后辈说，不要学华哥，说是没出息，那会我不懂，我不懂的是什么叫出息，更不懂人们眼中的出息叫什么，我只知道他是我哥，我很喜欢和他玩。</span></p><p class="ne-p"><br></p><p class="ne-p"><span class="ne-text">小时候某年过节那会，亲戚朋友们都聚在一起，大人们都在那谈论电动摩特车，我在一旁听着，想跃跃欲试，我和身旁的华哥说，借他车去路上试试，华哥二话不说把我带到路上把车子开动，我凭着刚才他们大人们的三言两句，三下五除二车子就被我骑的老远，然后手不由自主地加速，车子越来越快，那一瞬间我突然想起来我忘了问刹车在哪…那一瞬间我实实在在感受到了相对速度的感念，车子走了，我屁股着地了～事后华哥笑着和我爸妈说，没多大事…</span></p><p class="ne-p"><br></p><p class="ne-p"><span class="ne-text">这个世界上，我一直相信人不止一面，在人们面前展示的一面，或许是普通的一面，可能一个人的表面是不被人所喜爱的，有几分不羁放纵，也可以是洒脱，当然也有那种特别讨别人喜的那种性格，但我也说了，人是复杂的，有的人在别人看来很没出息，没有大作为，可是，人心很好，当亲朋好友有困难，他会第一时间帮忙，和长辈说话，他会很认真倾听…当人类文明被创建那会，就注定会有框架来定义某些事情的标准。</span></p><p class="ne-p"><br></p><p class="ne-p"><span class="ne-text">我一直对自己说，平生这辈不做一个庸俗之人，尽管身处这个文明有很多的框架…</span></p><p class="ne-p"><br></p><p class="ne-p"><span class="ne-text">已故之人，定当缅怀之，下飞机已经是傍晚六点那会，夕阳洒在那诺大的跑道上，那般场景太容易调动情感，</span></p><p class="ne-p"><br></p><p class="ne-p"><span class="ne-text">在飞机上的一个半小时，我应该是离华哥最近的吧…</span></p><p class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1617606456340-0908688d-ae97-4581-9cdd-53c767da919d.jpeg" width="354"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1617606104878-d295f451-12db-4207-b53a-9bfa1b250017.jpeg" width="354"></p><p class="ne-p"><br></p><p class="ne-p"><br></p></div>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>轮子哥……</title>
      <link href="/essay/las4ft/"/>
      <url>/essay/las4ft/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content-editor-core lake-engine lake-typography-classic" data-lake-element="root" data-selection-undefined="%7B%22path%22%3A%5B%5B0%2C0%2C20%5D%2C%5B0%2C0%2C20%5D%5D%2C%22active%22%3Atrue%7D"><p data-lake-id="a20d224c568e48b9d67847a2c66a8c01_p_0" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">一时造轮子一时爽，一直造轮子，一直爽……</p></div>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>jQuery使用笔记</title>
      <link href="/blog/aa9fsh/"/>
      <url>/blog/aa9fsh/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="a20d224c568e48b9d67847a2c66a8c01_p_0" class="ne-p"><code class="ne-code"><span class="ne-text">jQuery</span></code><span class="ne-text">只是对原生的</span><code class="ne-code"><span class="ne-text">JavaScript</span></code><span class="ne-text">进行封装，说白了就是封装成伪数组，所以记住它的一些调用方法就可以了</span></p><p id="de43568ce566d742cc4dc43bfcbceb53" class="ne-p"><br></p><h2 id="12cNO"><span class="ne-text">参考资料</span></h2><ul class="ne-ul"><li id="e01bddf6d0184ec895f76c099bc08a32"><a href="https://jquery.cuishifeng.cn/" data-href="https://jquery.cuishifeng.cn/" target="_blank" class="ne-link"><span class="ne-text">jQuery API 速查表  --作者：Shifone</span></a></li><li id="b6410930dad07c76852da1de0d43b439"><a href="https://www.processon.com/view/link/5b7d6458e4b0534c9bb76ad9#map" data-href="https://www.processon.com/view/link/5b7d6458e4b0534c9bb76ad9#map" target="_blank" class="ne-link"><span class="ne-text">jQuery思维导图</span></a></li></ul><h2 id="Yy6G8"><span class="ne-text">一些特性</span></h2><ul class="ne-ul"><li id="9ab2320fab604f7cb9f2ff9bc93f2eb5"><code class="ne-code"><span class="ne-text">$</span></code><span class="ne-text">符号：jq里面的顶级对象</span></li><li id="1b1742fcc89d53c4a71949d43b13db7e"><span class="ne-text">入口函数：在DOM里面的</span><span class="ne-text">DOMContentLoaded，在$里面直接赋予入口函数即可</span></li></ul><ul start="3" class="ne-ul"><li id="58420a26243878b1c5e6d82615ed8d58"><span class="ne-text">jq对象和DOM对象：</span></li></ul><p id="c9ac62a6c03b2a1d9e5cdc1f4373bb0f" class="ne-p"><span class="ne-text">两者之间的函数调用不能互换（因为是被封装成了伪数组）</span></p><p id="225f10b8aabd791d71f18ae75ab43ceb" class="ne-p"><span class="ne-text">jq转换为DOM：加数组下标即可</span><span class="ne-text">（因为是被封装成了伪数组，利用索引即可）</span></p><p id="1c8e7ce06b6018fd90c9f08141073c26" class="ne-p"><span class="ne-text">DOM转换为jq：使用$符号即可（括号不加引号），或者是get(索引值)</span></p><h2 id="KS0GD"><span class="ne-text">常用API</span></h2><h3 id="UPgrG"><span class="ne-text">选择器操作</span></h3><ul class="ne-ul"><li id="2a41e99fc1b06afd4748a517f675fc1d"><span class="ne-text">元素获取：之前的CSS选择器（基础选择器、复合选择器）怎么写，这里直接就放到$里面即可</span></li></ul><p id="7650925720f490de73ba59e8322a9e01" class="ne-p"><span class="ne-text">筛选选择器</span></p><p id="4e27c9c09861b54c98d5eb1f8cdd285a" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1617359781992-e02802ae-f357-4987-a8a0-46cc0c5be69a.png" width="524" id="yL3dG" class="ne-image"></p><ul class="ne-ul"><li id="1a27dd3a03c64a9534739d7c6c8eed3c"><span class="ne-text">隐式迭代：如果获取的元素是一个数组，那么对其赋予的新操作，会隐式遍历</span></li><li id="2bee8e4ae71361c3d944e799fec950de"><span class="ne-text">元素属性操作：css(&quot;属性&quot;,&quot;值&quot;)函数</span></li></ul><ul start="3" class="ne-ul"><li id="0cb05668563d2d2ffd3493767266c90e"><span class="ne-text">元素节点操作</span></li></ul><p id="a3c41e2d8826c81dfb91873977ed1e8a" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1617359820567-38b9fad2-deb7-429f-9d21-8f9676563426.png" width="541" id="G7Yck" class="ne-image"></p><p id="672e6e51a8475d895774bfb5d481d768" class="ne-p"><br></p><ul class="ne-ul"><li id="dc7922e3952089ef17dde809f5e8358b"><span class="ne-text">事件：.mouseover()、.click()</span></li><li id="aa872635f671ab45ac240ab897e92ba7"><span class="ne-text">.show()、.hide()：元素显示和隐藏</span></li></ul><ul start="3" class="ne-ul"><li id="6082de1ba1336d659e31b3059aaeb319"><span class="ne-text">$(this)当前这个对象</span></li></ul><h3 id="aSnP5"><span class="ne-text">样式操作</span></h3><p id="3e8f10016e271373aa72a4bd04f84379" class="ne-p"><span class="ne-text">样式的操作还是和之前的DOM一样，有两种，一种是逐个设置该元素的属性和值，另一种就是改变其类，jq里面也是这个大题思路，不过有不同</span></p><p id="7514a4dc78af37e41d943b07a4abad78" class="ne-p"><br></p><ul class="ne-ul"><li id="86e64d0eebee88b5b095f6d8adb70e46"><span class="ne-text">单一设置：.css()函数，一个参数的时候，返回该参数的值，两个参数的时候，即赋予该属性及值</span></li><li id="5866e3069dc9461ede811a32ce07fd0a"><span class="ne-text">clsss设置</span></li></ul><p id="fb354fca6afe944be652058c065de7ae" class="ne-p"><span class="ne-text">.addClass(&quot;类名&quot;)：如果该元素没有该类，则加上</span></p><p id="64fcddc76d48e8ff6dc608c8f2e52961" class="ne-p"><span class="ne-text">.removeClass()：移除指定类名</span></p><p id="cf1d33cf1d1b4b3a1048701bce77140b" class="ne-p"><span class="ne-text">.toggle()：如果该元素有该类则删除，如果没有该类则加上</span></p><p id="65aa808d270c7ca0376eead229fa3896" class="ne-p"><br></p><ul class="ne-ul"><li id="a95103df535ead96a7e6a61b3f1a86b9"><span class="ne-text">class设置和DOM里面className区别是前者不会删除原本的类，后者会</span></li></ul><h3 id="dgpQs"><span class="ne-text">效果操作</span></h3><p id="557caec8d8090bdde7526a69d5e81253" class="ne-p"><span class="ne-text">jq封装了很多的效果，具体可以详查相关文档    </span></p><p id="2c91295911a02a1636db646b11a14181" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1617361907950-d1d89194-401d-46aa-9471-34139e3e00df.png" width="351.5" id="SD9oO" class="ne-image"></p><h3 id="DzFX6"><span class="ne-text">属性操作</span></h3><ul class="ne-ul"><li id="b0312590ad1d416a46c7047cad1eb51b"><span class="ne-text">prop()：得到/设置元素固有的属性及值</span></li><li id="75381246b6dd4f80808426d191caaed3"><span class="ne-text">attr()：得到/设置元素自定义的属性及值</span></li></ul><ul start="3" class="ne-ul"><li id="08ec800bbbd7ebb550101047a6132655"><span class="ne-text">data()：数据缓存</span></li></ul><h3 id="NlpzM"><span class="ne-text">内容文本值操作</span></h3><ul class="ne-ul"><li id="c00ce586c548052b1357d7c2694caa2b"><span class="ne-text">html()：相当于innerHTML</span></li><li id="5fbfcc177fc81d3d1525e69bdd7a8a7e"><span class="ne-text">text()：相当于innerText</span></li></ul><ul start="3" class="ne-ul"><li id="660d54b547338a92c6432042fc1ba3f5"><span class="ne-text">val()：操作表单的值（没有参数是获取值，有一个参数是设置）</span></li></ul><h3 id="u4L4A"><span class="ne-text">元素操作</span></h3><div data-type="info" class="ne-alert"><p id="11ee78e97c938aa98b1789a93790ae7d" class="ne-p"><span class="ne-text">遍历</span></p></div><p id="b38098c59a399b93fbd23ce5cfd3dafe" class="ne-p"><br></p><div class="ne-quote"><p id="ebf89f25145d952c93719ecf6617b416" class="ne-p"><span class="ne-text">第一种表达：</span></p></div><ul class="ne-ul"><li id="7d6908137833a84be94dd8d3cfd9e7d5"><span class="ne-text">$(&quot;div&quot;).each(function(index,ele){XXXX})</span></li><li id="fbe71cf944eb5882519c695fa0dd7fda"><span class="ne-text">其中index是索引号，ele得到的是DOM对象</span></li></ul><div class="ne-quote"><p id="913f07908bcd64c5b98d83210315403e" class="ne-p"><span class="ne-text">第二种表达</span></p></div><ul class="ne-ul"><li id="e3a19e3266a3e2865533169928321c51"><span class="ne-text">$.each(Object,function(index,ele){XXXXX})</span></li><li id="0b81bcf5981aed6fb50411f4efaadb69"><span class="ne-text">主要用于数据处理</span></li></ul><p id="a2d0d6a9ac0f09ebbecede19eaad70c4" class="ne-p"><br></p><div data-type="info" class="ne-alert"><p id="c9f786a0f9ceeaebe548220fcb9d3b5c" class="ne-p"><span class="ne-text">创建</span></p></div><p id="6b1de1e66547f3f16c00e328bd4b2c64" class="ne-p"><br></p><p id="879ad0498c5d00cd026bb5274af07224" class="ne-p"><span class="ne-text">直接在$里面双引号加上需要创建的标签</span></p><p id="767d6cc22830a26393b135d2b498fa5f" class="ne-p"><br></p><div data-type="info" class="ne-alert"><p id="07059a0b2eb61dece09fa91041fdfaa1" class="ne-p"><span class="ne-text">添加</span></p></div><p id="74c01037713daae461bc3a957cb243df" class="ne-p"><br></p><div class="ne-quote"><p id="6621fe80cdd7269d49fe030309384dbc" class="ne-p"><span class="ne-text">第一种关系：添加生成父子关系</span></p></div><ul class="ne-ul"><li id="f26a63599bf94c55db5a88177d751562"><span class="ne-text">append(&quot;&quot;)</span></li><li id="9f981d6a7e1147114329ddb689987e73"><span class="ne-text">prepend(&quot;&quot;)</span></li></ul><div class="ne-quote"><p id="b25d1ded663bd9079177df2b138ff027" class="ne-p"><span class="ne-text">第二种关系：添加生成兄弟关系</span></p></div><ul class="ne-ul"><li id="249a0d56e52df01b48ae3bc34803d308"><span class="ne-text">after(&quot;&quot;)</span></li><li id="726de4b46f61bc29d99d49a834d71915"><span class="ne-text">before(&quot;&quot;)</span></li></ul><p id="8301a769f76c2e93d6a36819800b8c27" class="ne-p"><br></p><div data-type="info" class="ne-alert"><p id="fa6120f2c42f9084290d26a8ede55362" class="ne-p"><span class="ne-text">删除</span></p></div><p id="0959176024c4622f309e59c6b05f725e" class="ne-p"><br></p><ul class="ne-ul"><li id="fb13b9f3c00152f3324b5267d5b0ba09"><span class="ne-text">remove()：移除选定节点</span></li><li id="dde65bd8b804b2d36f327e1e69c3aaa8"><span class="ne-text">empty()：清空所选节点的左右子节点</span></li></ul><ul start="3" class="ne-ul"><li id="cddf9dd16267a7e1c4ea57b238b1c47a"><span class="ne-text">html(&quot;&quot;)：将所选节点的html内容制空（相当于删除节点了）</span></li></ul><h3 id="L7wkW"><span class="ne-text">尺寸、位置操作</span></h3><p id="1d0b003757b8a2f0553a50faafbafbc0" class="ne-p"><br></p><div data-type="info" class="ne-alert"><p id="0979ce8391a1cfe51e177c149311b3aa" class="ne-p"><span class="ne-text">尺寸操作</span></p></div><p id="52250d8638cb68a364d9e07b0365361a" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1617364626783-b5a50ec5-eeb2-4447-bc15-c7c209ae1d08.png" width="583" id="AIKMv" class="ne-image"></p><p id="9e29cca939c5b3efe1921d23336187ad" class="ne-p"><span class="ne-text">参数为空：返回值</span></p><p id="51f292fb19da19a6d477efaa569c14b5" class="ne-p"><span class="ne-text">参数为一个值：设置</span></p><p id="a71f7e5719b083e1f628ba7db4d96b7e" class="ne-p"><br></p><p id="7dd7dfadb8ba312a97ed97496c00accc" class="ne-p"><br></p><div data-type="info" class="ne-alert"><p id="72d806ea8edd33836b4e32011f80d4c4" class="ne-p"><span class="ne-text">位置操作</span></p></div><p id="2c59051aaaf55f39c36349f349594db0" class="ne-p"><br></p><p id="00bd1e37a2b8faa0c0b8200e083310ac" class="ne-p"><br></p><p id="c02db588425c095fc03a80a0c06b42a1" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1617364679986-4ff0b4c0-8622-4111-9c4b-c6571bd278db.png" width="623" id="SdHbS" class="ne-image"></p><p id="3a60bc8a5c64f4ac264dd4f8d0f2e22f" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1617364688980-2d85f32d-a51c-48ae-85a9-fc9f613536e5.png" width="589.5" id="AO6QL" class="ne-image"></p><p id="3c40b3114fa2320a1bec36ed192b4677" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1617364699038-74aa84bc-20ec-4427-9485-311ebaf9d066.png" width="523.5" id="jllHI" class="ne-image"></p><p id="e74be622e43f0843137ec567dbb4ec59" class="ne-p"><br></p></div>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
          <category> JavaScript </category>
          
          <category> jQuery </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CSS预处理器</title>
      <link href="/blog/zsiw5e/"/>
      <url>/blog/zsiw5e/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="traditional"><h2 id="u2Coo"><span class="ne-text">stylus</span></h2><p id="452a67e8416e5886cf217588873f2947" class="ne-p"><span class="ne-text">CSS预处理器优化CSS的开发</span></p><p id="ccdcf278ecc82a6e13e74521cdb4a20d" class="ne-p"><br></p><div data-type="info" class="ne-alert"><p id="3225668e3c05a454496713f58c85b9cd" class="ne-p"><span class="ne-text">CSS 的预处理器，给 CSS 添加了可编程的特性，也就是说，在 stylus 中可以使用变量、函数、判断、循环一系列 CSS 没有的东西来编写样式文件，这个文件可编译成 CSS 文件</span></p></div><p id="d98fa72ca4a4d2c7bf4de368a59b5a4e" class="ne-p"><br></p><h3 id="UxRVE"><span class="ne-text">note</span></h3><ul class="ne-ul"><li id="378c5b362d5f14d4ca2667b8e5ae15f5"><span class="ne-text">“[]”：中括号内容，是定义属性的方式</span></li></ul><p id="ebd134e9428d26b9f70409563356beff" class="ne-p"><br></p><h3 id="B9Svy"><span class="ne-text">参考</span></h3><ul class="ne-ul"><li id="cdb195997112ae2a308d8333150363d7"><a href="https://www.zhangxinxu.com/jq/stylus/" data-href="https://www.zhangxinxu.com/jq/stylus/" target="_blank" class="ne-link"><span class="ne-text">stylus中文版参考文档之综述——张鑫旭</span></a></li><li id="67056520763e5b1fe08cb786414c73dc"><a href="https://stylus.bootcss.com/" data-href="https://stylus.bootcss.com/" target="_blank" class="ne-link"><span class="ne-text">富于表现力、动态的、健壮的 CSS</span></a></li></ul><p id="ua8003f55" class="ne-p"><span class="ne-text"></span></p><h2 id="lmd5c"><span class="ne-text">less</span></h2><p id="u9b2914bf" class="ne-p"><span class="ne-text">参考：</span><a href="https://less.bootcss.com/" data-href="https://less.bootcss.com/" target="_blank" class="ne-link"><span class="ne-text">https://less.bootcss.com/</span></a></p></div>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
          <category> HTML+CSS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CSS的媒体查询</title>
      <link href="/blog/mio9h2/"/>
      <url>/blog/mio9h2/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="traditional"><h3 id="23ZNi"><span class="ne-text">媒体查询（CSS3）</span></h3><div data-type="info" class="ne-alert"><p id="5ac086b799bc33aa7a9cd2e7ece989b3" class="ne-p"><span class="ne-text" style="background-color: #E8F7FF">@media：注意@符号</span></p></div><pre><code>@media mediatype and|not|only (media feature) &#123;    CSS-Code;&#125;</code></pre><h3 id="Jdwqy"><span class="ne-text">mediatype 查询类型</span></h3><div data-type="info" class="ne-alert"><p id="d6f925662956c9dbc2e4c88433bc166c" class="ne-p"><span class="ne-text" style="background-color: #E8F7FF">将不同的终端设备划分成不同的类型，称为媒体类型</span></p></div><p id="27435027d74589dafd7000d4c2de0b1f" class="ne-p"><br></p><p id="070a16a857a6e87adc3e6f53ff2127fd" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/jpg/1484158/1615360325196-c449a080-4612-4814-b5da-5a61b1da1c0b.jpg" width="915" id="jLd4P" class="ne-image"></p><h3 id="91mxe"><span class="ne-text">关键字</span></h3><div data-type="info" class="ne-alert"><p id="7918a9dbda126ecad8bab3207f970fef" class="ne-p"><span class="ne-text" style="background-color: #E8F7FF">关键字将媒体类型或多个媒体特性连接到一起做为媒体查询的条件。</span></p></div><p id="3498795937d447cc9cc04d33c3aebe52" class="ne-p"><br></p><ul class="ne-ul"><li id="e089796360e0009d3b14ec2aff4a6242"><span class="ne-text">and：可以将多个媒体特性连接到一起，相当于“且”的意思。</span></li><li id="9eb946d76e571bb6dd5f8ce52754a1f4"><span class="ne-text">not：排除某个媒体类型，相当于“非”的意思，可以省略。</span></li><li id="5d3fd7da92fe2ac73f1d56c81c8e424f"><span class="ne-text">only：指定某个特定的媒体类型，可以省略。</span></li></ul><h3 id="LOgiW"><span class="ne-text">媒体特性</span></h3><div data-type="info" class="ne-alert"><p id="9015da3e9feb95758fe3dbe563cab402" class="ne-p"><span class="ne-text" style="background-color: #E8F7FF">每种媒体类型都具体各自不同的特性，根据不同媒体类型的媒体特性设置不同的展示风格。我们暂且了解三个。</span></p></div><p id="89e55b400cd384cf5d5c5494d812f35a" class="ne-p"><br></p><p id="ad00b8c6f4e31428409176ace3ccc883" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/jpg/1484158/1615360325364-d6cd0d1a-1ec7-4bd1-a67e-3fadde7c4381.jpg" width="918" id="yj8Yz" class="ne-image"></p><h3 id="8eYMp"><span class="ne-text">媒体查询书写规则</span></h3><div data-type="danger" class="ne-alert"><p id="49409e3a9b274523127921a2233d650d" class="ne-p"><span class="ne-text" style="background-color: #FFF3F3">为了防止混乱，媒体查询我们要按照从小到大或者从大到小的顺序来写,但是我们最喜欢的还是从小到大来写，这样代码更简洁</span></p></div><p id="0cf8bb4f1f7175bd98658821fcbd9a40" class="ne-p"><br></p></div>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
          <category> HTML+CSS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>GitHub基于Issue的软件项目管理</title>
      <link href="/blog/hgbehz/"/>
      <url>/blog/hgbehz/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="u22cd1647" class="ne-p"><br></p><div data-type="color1" class="ne-alert"><p id="011a5357f7205dddf9b1506eaad76bb4" class="ne-p"><span class="ne-text">在进行GitHub项目开发过程中，途中会有一些新想法，遇见的新bug等问题，提出的一些新灵感等等都可以利用GitHub每个项目自带的issues（议题）来进行管理、跟踪并且加以解决。</span></p><p id="ec94d49f4ca5d591db0708d31278dec0" class="ne-p"><span class="ne-text">传统的软件项目管理还有Milestones（里程碑）、Projects（画板）来一并进行项目的开发，GitHub在2020年还新增加了Discussion（讨论区）模块，进一步提高软件项目的管理工作。</span></p></div><p id="42d01dbfc9c0385189d6ccd13dd47397" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616655875686-d8387a58-3c42-4442-b6b5-1cd2b0c68a5f.png" width="946.5" id="vUGI2" class="ne-image"></p><p id="3710271f5e1a3824aa072f559ead2b3b" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616656006240-dd9c58bd-6675-487e-aab0-58878e9fcb29.png" width="947.5" id="PmAcn" class="ne-image"></p><h2 id="uwbhj"><span class="ne-text">Issue标签类型总结</span></h2><h3 id="URZo7"><span class="ne-text">GitHub默认标签</span></h3><table id="NznVX" class="ne-table" style="width: 893px"><tbody><tr style="height: 33px"><td width="150"><p id="u12a869c5" class="ne-p" style="text-align: center"><strong><span class="ne-text">Label</span></strong></p></td><td width="212"><p id="u896c770b" class="ne-p" style="text-align: center"><strong><span class="ne-text">explanation</span></strong></p></td><td width="531"><p id="udd4e1716" class="ne-p" style="text-align: center"><strong><span class="ne-text">Description</span></strong></p></td></tr><tr style="height: 33px"><td width="150"><p id="u0619f6a9" class="ne-p" style="text-align: center"><span class="ne-text">bug</span></p></td><td width="212"><p id="u38e16eb8" class="ne-p" style="text-align: center"><span class="ne-text">提出一个bug</span></p></td><td width="531"><p id="u48ef1bcc" class="ne-p" style="text-align: center"><span class="ne-text">Indicates an unexpected problem or unintended behavior</span></p></td></tr><tr style="height: 33px"><td width="150"><p id="ua98df8d6" class="ne-p" style="text-align: center"><span class="ne-text">documentation</span></p></td><td width="212"><p id="ue0ed9c1a" class="ne-p" style="text-align: center"><span class="ne-text">添加/改进/详查文档</span></p></td><td width="531"><p id="uee246b2c" class="ne-p" style="text-align: center"><span class="ne-text">Indicates a need for improvements or additions to documentation</span></p></td></tr><tr style="height: 33px"><td width="150"><p id="u05d518b4" class="ne-p" style="text-align: center"><span class="ne-text">duplicate</span></p></td><td width="212"><p id="uee784ab9" class="ne-p" style="text-align: center"><span class="ne-text">重复的问题/requests/讨论</span></p></td><td width="531"><p id="u3a3eccf8" class="ne-p" style="text-align: center"><span class="ne-text">Indicates similar issues, pull requests, or discussions</span></p></td></tr><tr style="height: 33px"><td width="150"><p id="u6e0e3cb7" class="ne-p" style="text-align: center"><span class="ne-text">enhancement</span></p></td><td width="212" style="background-color: #FFFFFF"><p id="u529c40d1" class="ne-p" style="text-align: center"><span class="ne-text">增强/新增功能</span></p></td><td width="531"><p id="u7abcf037" class="ne-p" style="text-align: center"><span class="ne-text">Indicates new feature requests</span></p></td></tr><tr style="height: 33px"><td width="150"><p id="u947dbd10" class="ne-p" style="text-align: center"><span class="ne-text">good first issue</span></p></td><td width="212" style="background-color: #FFFFFF"><p id="ufe96cb4b" class="ne-p" style="text-align: center"><span class="ne-text">好的想法/灵感</span></p></td><td width="531"><p id="u01874ec4" class="ne-p" style="text-align: center"><span class="ne-text">Indicates a good issue for first-time contributors</span></p></td></tr><tr style="height: 33px"><td width="150"><p id="u883f26fd" class="ne-p" style="text-align: center"><span class="ne-text">help wanted</span></p></td><td width="212" style="background-color: #FFFFFF"><p id="u2c12ec31" class="ne-p" style="text-align: center"><span class="ne-text">过程中需要帮助</span></p></td><td width="531"><p id="uf1f58498" class="ne-p" style="text-align: center"><span class="ne-text">Indicates that a maintainer wants help on an issue or pull request</span></p></td></tr><tr style="height: 33px"><td width="150"><p id="ud2a85c2c" class="ne-p" style="text-align: center"><span class="ne-text">invalid</span></p></td><td width="212" style="background-color: #FFFFFF"><p id="ue144fca0" class="ne-p" style="text-align: center"><span class="ne-text">没有意义，不再讨论</span></p></td><td width="531"><p id="uc0aa83ca" class="ne-p" style="text-align: center"><span class="ne-text">Indicates that an issue, pull request, or discussion is no longer relevant</span></p></td></tr><tr style="height: 33px"><td width="150"><p id="u4d0ff9e6" class="ne-p" style="text-align: center"><span class="ne-text">question</span></p></td><td width="212" style="background-color: #FFFFFF"><p id="uf3471de4" class="ne-p" style="text-align: center"><span class="ne-text">请提供进一步资料</span></p></td><td width="531"><p id="ue29f0928" class="ne-p" style="text-align: center"><span class="ne-text">Indicates that an issue, pull request, or discussion needs more information</span></p></td></tr><tr style="height: 33px"><td width="150"><p id="ucbbf8a6d" class="ne-p" style="text-align: center"><span class="ne-text">wontfix</span></p></td><td width="212" style="background-color: #FFFFFF"><p id="uc1630edc" class="ne-p" style="text-align: center"><span class="ne-text">不做处理</span></p></td><td width="531"><p id="u6a6ff953" class="ne-p" style="text-align: center"><span class="ne-text">Indicates that work won't continue on an issue, pull request, or discussion</span></p></td></tr></tbody></table><h3 id="AbJiS"><span class="ne-text">自需添加</span></h3><table id="bLXb2" class="ne-table" style="width: 479px"><tbody><tr style="height: 33px"><td width="239"><p id="a24c7d0b6d9283518f91f4c0317a7bae" class="ne-p"><span class="ne-text">debugging</span></p></td><td width="240"><p id="5394a8ea5a0306ce3ac1e6aa18b98826_p_0" class="ne-p"><span class="ne-text">正在调试</span></p></td></tr><tr style="height: 33px"><td width="239"><p id="920315d99b965a5644fee80c3835ad1e" class="ne-p"><span class="ne-text">fixed</span></p></td><td width="240"><p id="7093202f29ebdfb9d282758af8be662d_p_0" class="ne-p"><span class="ne-text">已被修复</span></p></td></tr></tbody></table><h2 id="AUORQ"><span class="ne-text">Discussion的新革新</span></h2><p id="92b019e096e018cf9ddfc50063e5d71a" class="ne-p"><span class="ne-text">传统的流程是提出issues之后，根据不同的issue来跟进画板（Project）的内容。</span></p><p id="092ba84ad78c26f4415b771106bd6690" class="ne-p"><br></p><p id="36bf279ab58f49ff5d9a08ff59e8542f" class="ne-p"><span class="ne-text">上面的做法其实有一个思维上的bug，一些灵感之类的不好放上去，使用Discussion之后，可以在</span><span class="ne-text">Discussion里面放上想法、灵感等，实际开发从这里面的一个的一个具体的评论转换到实际的issue里面</span></p><h2 id="tbZ3q"><span class="ne-text">参考</span></h2><ul class="ne-ul"><li id="1acc1b1e05ed6bb38cba9e4b9107e0f3"><a href="http://www.ruanyifeng.com/blog/2017/08/issue.html" data-href="http://www.ruanyifeng.com/blog/2017/08/issue.html" target="_blank" class="ne-link"><span class="ne-text">http://www.ruanyifeng.com/blog/2017/08/issue.html</span></a></li><li id="9ad438665f32035d34baf7a5fab9c8d8"><a href="https://github.com/volantis-x/hexo-theme-volantis/" data-href="https://github.com/volantis-x/hexo-theme-volantis/" target="_blank" class="ne-link"><span class="ne-text">https://github.com/volantis-x/hexo-theme-volantis/</span></a></li></ul></div>]]></content>
      
      
      <categories>
          
          <category> 计算机素养 </category>
          
          <category> Git和GitHub </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Git push出(10054)/(port 443：time out)错</title>
      <link href="/blog/tttk33/"/>
      <url>/blog/tttk33/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="uc53e90c4" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1624951739057-ebfc3755-1e5a-426b-a7b3-a7841ead1b1f.png" width="441" id="yDPwn" class="ne-image"></p><p id="ub196f5cb" class="ne-p"><span class="ne-text"></span></p><p id="ud8f0faf3" class="ne-p"><strong><span class="ne-text">前言：今年GitHub的各种操作被屏蔽的挺迷的，一开始我只是以为偶尔报个连接失败的port443的错误，但是后来经常性的出现本地push不上GitHub的情况，在此情况记录一下各种情况（clone、pull、push……）连接不上的解决办法。</span></strong></p><p id="uacec6dbf" class="ne-p"><br></p><h2 id="vMQmQ"><span class="ne-text">一、报错信息与原因分析</span></h2><h3 id="mOgXN"><span class="ne-text">报错信息</span></h3><pre><code><code>Git push出(10054)/(port 443：time out)错<p>git push error: RPC failed; curl 56 OpenSSL SSL_read: SSL_ERROR_SYSCALL, errno 10054</code><br></code></pre></p><p id="u2aee6d65" class="ne-p"><br></p><h3 id="Kpmuy"><span class="ne-text">原因分析</span></h3><ol class="ne-ol"><li id="u18980f1a" data-lake-index-type="0"><span class="ne-text">由于Http协议错误，当 pull 或者 clone 的时候，或者是 github 某个CDN被qiang屏蔽所致。</span></li><li id="u5ee232b6" data-lake-index-type="0"><span class="ne-text">用了kexueshangwang工具之后，由于更改代理服务器连接端口，导致本地push偶尔失败（但是以前有用）。</span></li></ol><h2 id="nOi29"><span class="ne-text">二、常规解决方案</span></h2><div data-type="success" class="ne-alert"><p id="uab283dd3" class="ne-p"><span class="ne-text">2021.06.29更新解决方法：【针对clone失败】https的连接不行，那就用ssh的连接。</span></p><p id="u63139dec" class="ne-p"><span class="ne-text">2021.07.13更新解决方案：【针对pull、push失败】ssh连接push连接不行，那就用token来push。</span></p></div><p id="ua5aa3a5b" class="ne-p"><span class="ne-text"></span></p><div data-type="success" class="ne-alert"><p id="u97b70ea5" class="ne-p"><span class="ne-text">常规解决方法：</span></p><p id="u4479d0d3" class="ne-p"><span class="ne-text">第一种方法是下面的三条命令，另外如果用了该三条命令还不行，那就ctrl + c ，再进行输入命令，以此往复，总会出现GitHub的登录框的……；</span></p><p id="u2848c832" class="ne-p"><span class="ne-text">第二种方法就是在本地对host进行更改，让其可以访问github网站的相关ip；</span></p></div><p id="ua79015bf" class="ne-p"><span class="ne-text"></span></p><h3 id="UOJ1D"><span class="ne-text">常规解决方案1：改代理</span></h3><div class="ne-quote"><p id="u18fba66e" class="ne-p"><span class="ne-text">10054的bug复制下面的</span></p></div><pre><code><code>git config http.postBuffer 524288000</code></code></pre><div class="ne-quote"><p id="ufc3918f6" class="ne-p"><span class="ne-text">443的bug复制下面的</span></p></div><pre><code><code># 设置ssgit config --global http.proxy 'socks5://127.0.0.1:10080'git config --global https.proxy 'socks5://127.0.0.1:10080'# 设置代理git config --global https.proxy http://127.0.0.1:10080git config --global https.proxy https://127.0.0.1:10080# 取消代理git config --global --unset http.proxygit config --global --unset https.proxy</code></code></pre><h3 id="SCsCl"><span class="ne-text">常规解决方案2：改变本地hosts文件</span></h3><p id="78ed051236d072ca01dcfb356337895e" class="ne-p"><span class="ne-text">在</span><a href="https://www.ipaddress.com/" data-href="https://www.ipaddress.com/" target="_blank" class="ne-link"><span class="ne-text">https://www.ipaddress.com/</span></a><span class="ne-text">里面查找下面三个域名的ip地址</span></p><ul class="ne-ul"><li id="19bb41ac716d33bfc9eefbb90abc83cd" data-lake-index-type="0"><span class="ne-text">github.com</span></li><li id="7070d7115839d2f0108e4458654d3ca7" data-lake-index-type="0"><span class="ne-text">github.global.ssl.fastly.net</span></li><li id="61629bb945eb3ea6add4933918a8fc03" data-lake-index-type="0"><span class="ne-text">codeload.github.com</span></li></ul><p id="ec5a0662d9c737b31b6470c66b3659e4" class="ne-p"><span class="ne-text">将其添加到本电脑hosts文件当中</span></p><p id="e389f74b35a35de6376e3f8f9d1a3179" class="ne-p"><code class="ne-code"><span class="ne-text">C:\Windows\System32\drivers\etc\hosts</span></code><span class="ne-text"> </span></p><p id="ub3851647" class="ne-p"><span class="ne-text">类似下面：</span></p><p id="3c99eb4bc70690f460649a291643b991" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1615339105733-afb66a55-d96e-4dba-9650-a9d3cb8324fa.png" width="245" id="EhSLV" class="ne-image"></p><p id="d1c2a5c3a0027563e1787158147c15f3" class="ne-p"><span class="ne-text">CMD窗口刷新DNS缓存</span></p><pre><code><code>ipconfig /flushdns</code></code></pre><h2 id="daQUa"><span class="ne-text">三、针对性解决方案</span></h2><p id="u5f814d65" class="ne-p"><span class="ne-text">上面两种方案理论上解决了问题，但是奇葩的问题年年有，上述两种方案都不能解决，就用如下方案：</span></p><h3 id="GIgvQ"><span class="ne-text">针对clone失败</span></h3><p id="u5d77397b" class="ne-p"><span class="ne-text">如果https连接失败，使用ssh链连接（前提是电脑端配置了ssh），如果ssh连接也不行，那就下面的针对pull、push失败的方案。</span></p><p id="u7e654cd7" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1624953268520-f8c7c56d-6588-4991-b63c-11adc5cdd0ae.png" width="441" id="KCLWc" class="ne-image"></p><h3 id="ZkQc2"><span class="ne-text">针对pull、push失败</span></h3><p id="uefd8d8a0" class="ne-p"><span class="ne-text">ssh连接不行，那就使用token来连接</span></p><pre><code><code>git push https://一串token@github.com/wztlink1013/datastructure-algorithm</code></code></pre><h2 id="boevI"><span class="ne-text">参考</span></h2><ul class="ne-ul"><li id="9a0c30a27e5684596a4353039851aa5e" data-lake-index-type="0"><a href="https://www.cnblogs.com/mmzs/p/12039888.html" data-href="https://www.cnblogs.com/mmzs/p/12039888.html" target="_blank" class="ne-link"><span class="ne-text">https://www.cnblogs.com/mmzs/p/12039888.html</span></a></li><li id="uf80e0f59" data-lake-index-type="0"><a href="https://www.jianshu.com/p/f98ed938f91a" data-href="https://www.jianshu.com/p/f98ed938f91a" target="_blank" class="ne-link"><span class="ne-text">使用Personal access tokens以避免Windows下每次git push都需要输入账号密码</span></a></li><li id="u696c7627" data-lake-index-type="0"><a href="https://segmentfault.com/q/1010000039738438" data-href="https://segmentfault.com/q/1010000039738438" target="_blank" class="ne-link"><span class="ne-text">2021年为什么最近github能访问不能push代码了</span></a></li></ul><p id="uef725edc" class="ne-p"><br></p></div>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
          <category> Bug记录 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++链表(单、循环、双向)设计及操作</title>
      <link href="/blog/gu92gu/"/>
      <url>/blog/gu92gu/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><div data-type="info" class="ne-alert"><p id="c88ce5764357a091522741724378b1dd" class="ne-p"><span class="ne-text">前言：这篇文章，打算详细记录下链表的相关知识，毕竟是基础中的基础。首先是先记录下在一开始学习过程中的些许疑惑/C的遗忘，然后记录各种代码（实验报告代码，单链表各种操作代码总结，循环链表代码，双向链表代码）</span></p></div><h2 id="fWwcE"><span class="ne-text">实验要求</span></h2><div class="ne-quote"><p id="0a190c74909083860b0ea4ec77a7f8e0" class="ne-p"><span class="ne-text">1、创建一个带头结点的单链表（头指针为head），且遍历此链表（输出链表中各结点的值）；</span></p><p id="39f29f4dc50744c5a850b3f5d4694202" class="ne-p"><span class="ne-text">2、查找单链表中的第i个结点，并输出结点元素的值；</span></p></div><div class="ne-quote"><p id="49447049dc631801c0d0cf98ab90b493" class="ne-p"><span class="ne-text">3、在单链表中的第i个结点前插入一个结点值为e的正整数(从外部输入);</span></p></div><div class="ne-quote"><p id="43c77222ef93623b95e886aeacbe2ddc" class="ne-p"><span class="ne-text">4、删除单链表中的第j个结点；</span></p></div><div class="ne-quote"><p id="e25375651bc08487d6880bc6695fce1d" class="ne-p"><span class="ne-text">*5、将单链表中的各结点就地逆序（不允许另建一个链表）；</span></p></div><h2 id="eP7sU"><span class="ne-text">概念理解</span></h2><h3 id="AEx9L"><span class="ne-text">链表数据结构</span></h3><p id="57e1ef23e935c9b21e2cfea98c4cb69f" class="ne-p" style="text-indent: 2em"><span class="ne-text">链表是一种数据结构，和</span><strong><span class="ne-text">数组同级</span></strong><span class="ne-text">。之前JAVA里面的ArrayList数据结构，其实现原理是数组，而JAVA的LinkedList的实现原理就是链表了。链表在进行循环遍历时效率不高，但是插入和删除时优势明显，其实C/C++抑或是JAVA这些数据结构都一样——地址……引用……</span></p><p id="8c7be3dc4c48c18392ebe9a3a21f453d" class="ne-p"><br></p><p id="58ae00dffdc23c957024b218a4fe2a7f" class="ne-p" style="text-indent: 2em"><span class="ne-text">单向链表是一种线性表，实际上是由</span><strong><span class="ne-text">节点（Node）</span></strong><span class="ne-text">组成的，一个链表拥有不定数量的节点。其数据在</span><strong><span class="ne-text">内存中存储是不连续的</span></strong><span class="ne-text">，它存储的数据分散在内存中，每个结点只能也只有它能知道下一个结点的存储位置。由N各节点（Node）组成单向链表，每一个Node记录本Node的数据及下一个Node。向外暴露的只有一个头节点（Head），</span><strong><span class="ne-text" style="text-decoration: underline">我们对链表的所有操作，都是直接或者间接地通过其头节点来进行的。</span></strong></p><p id="0486b484d9c64e85ae8df6456202c9d8" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1603194076184-195f3044-1083-4244-9eeb-d86c96a37e6f.png" width="491" id="y2G05" class="ne-image"></p><p id="287ed5b5812f8c5dc5acab531ab80a88" class="ne-p" style="text-align: left; text-indent: 2em"><span class="ne-text">上图中最左边的节点即为头结点（Head），但是添加节点的顺序是从右向左的，添加的新节点会被作为新节点。最先添加的节点对下一节点的引用可以为空。引用是引用下一个节点而非下一个节点的对象。因为有着不断的引用，所以</span><strong><span class="ne-text">头节点就可以操作所有节点</span></strong><span class="ne-text">了。</span></p><p id="37a5d5b22afe684dd87bdb37f699fdbc" class="ne-p" style="text-align: left; text-indent: 2em"><br></p><p id="9497ce3266be94b1f9295a37ec97730e" class="ne-p" style="text-indent: 2em"><span class="ne-text">下图描述了单向链表存储情况。存储是分散的，每一个节点只要记录下一节点，就把所有数据串了起来，形成了一个单向链表。</span></p><p id="1cb7d03553cc0fa59abb313b8c76e605" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1603194105521-d31f8e78-7f2a-4c60-8838-57e15707e27b.png" width="195" id="grJMc" class="ne-image"></p><p id="2b230249e0620a7b7bac08dc0c49afbd" class="ne-p" style="text-indent: 2em"><span class="ne-text">节点（Node）是由一个需要储存的对象及对下一个节点的引用组成的。也就是说，节点拥有两个成员：储存的对象、对下一个节点的引用。下面图是具体的说明：</span></p><p id="55b372445df1ebd0fc079c95a7cdeb52" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1603194124335-fc6fc00c-35fb-44e1-a01c-de4b8b5531af.png" width="370" id="MPcIA" class="ne-image"></p><p id="3da71b933dc4ba0ab559566e0a5a7a96" class="ne-p"><br></p><h3 id="Aq3FT"><span class="ne-text">关于链表的指向</span></h3><div class="ne-quote"><p id="b9a522a52b21f6716cf72dde48ffebd2" class="ne-p"><span class="ne-text">【1】何为指向？</span></p></div><p id="3fccb63f4a6337e5f88fb28b45873a5a" class="ne-p"><span class="ne-text">个人觉得链表的相关问题及操作就是理解链表的</span><strong><span class="ne-text">“指向”</span></strong><span class="ne-text">这么个概念，先明确以下几点</span></p><ul class="ne-ul"><li id="2cc71630bb88cfed92846d7a93cca40a"><span class="ne-text">每个节点的</span><strong><span class="ne-text">next</span></strong><span class="ne-text">用来存放</span><strong><span class="ne-text">下一个节点的“地址”</span></strong></li><li id="65cf0414c2481a13c6c9a21ef0be7dbf"><strong><span class="ne-text">每个节点的自身就是地址</span></strong><span class="ne-text">，相当于C语言中数组的数组名就是本数组的地址</span></li></ul><p id="bd5c4f3fd8cef0f7caad73699ea58d9d" class="ne-p"><br></p><div class="ne-quote"><p id="66f673c4f6f0bc17dce2567f2e5064b0" class="ne-p"><span class="ne-text">【2】谁指向谁？</span></p></div><p id="c3111db0cf2ee8b8d4fb2a84131fbd4d" class="ne-p"><strong><span class="ne-text">总结：做题用下面总结的方法，绝对好使</span></strong></p><p id="e99ba7156e434dbd6bc32bd816a6f035" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1616501415627-ee5d1008-a07d-4acb-821b-e227b5cb7ad8.jpeg" width="55" id="BIrmM" class="ne-image"></p><ul class="ne-ul"><li id="c169699238a96a22f348421cb8d23eb3"><strong><span class="ne-text">读的时候：从左往右读，一般左边是某某的next域，右边是具体的结点</span></strong></li><li id="c217a55e6fabfd14cbcce9084eedf109"><strong><span class="ne-text">画的时候：在图中表示为等号左边指向等号右边</span></strong></li></ul><p id="4c686c860538d538bd106f5ac64721f7" class="ne-p"><strong><span class="ne-text"></span></strong></p><p id="e25c398d084c2af531afd302dc939259" class="ne-p"><span class="ne-text">例子：</span></p><p id="55421008445ce977395cfde0ec899cd4" class="ne-p"><span class="ne-text">① </span><code class="ne-code"><span class="ne-text">node.next = prev.next;</span></code></p><p id="c56914d506733f4e7f46b2105d9a08f7" class="ne-p"><span class="ne-text">② </span><code class="ne-code"><span class="ne-text">prev.next = node</span></code></p><p id="2af80e2b9ed35166f790a4a320b7269f" class="ne-p"><span class="ne-text">读法：</span></p><p id="19a7191dca062c4c3a1d9d89c2d086a1" class="ne-p"><span class="ne-text">①“node的next指向prev的下一个结点”</span></p><p id="327d3249675c1750699f5acc083802a6" class="ne-p"><span class="ne-text">（用指针的概念通俗地说，其实就是prev的下一个结点的地址由prev的指针域里面赋值给了node的next指针域里面）</span></p><p id="4f79632f5aecaae5f550faaea0237f6a" class="ne-p"><span class="ne-text">②“prev的next指向node这个结点”</span></p><p id="a92a2aac44c6403f602575bc1f3b116a" class="ne-p"><span class="ne-text">（还可以这么说：将node赋值给prev的next，也就是说prev的下一个结点是node）</span></p><p id="3f0e90b501bed8fa69c01c2bdf014acc" class="ne-p"><strong><span class="ne-text"></span></strong></p><p id="56d8b5f2c7ac7c9b9e18f93387a7c499" class="ne-p"><br></p><p id="c6a1d4a8cbe7b36a97ddb92a4eab18d0" class="ne-p" style="text-align: left"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1599309003706-ad779a14-1678-4d0c-86f2-b147752bd252.png" width="328" id="xCmIZ" class="ne-image"></p><p id="378d2212f658d52c8fecd6a063078f6f" class="ne-p" style="text-align: left"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1599309003751-ffeee4d8-9662-416e-8f46-5cf5edf03114.png" width="324" id="SUwQZ" class="ne-image"></p><p id="f33d58f9c2135015e50cd632ee29f224" class="ne-p" style="text-align: left"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1599309003658-46b3e7db-e6dc-4d13-baea-e7e44075e8bc.png" width="344" id="knAnJ" class="ne-image"></p><p id="65d1058f0d85fbe900ec755111ed2582" class="ne-p"><br></p><div class="ne-quote"><p id="0b73013ce5e35f1fc49270bd59ede650" class="ne-p"><span class="ne-text">【3】指向错位？</span></p></div><p id="9652a1886ad8458f39492fcf396b361a" class="ne-p"><strong><span class="ne-text">关注第一个元素节点是不是head，因为有的链表不声明头节点（head），直接就是第一个结点就是元素结点</span></strong></p><h3 id="wCCZi"><span class="ne-text">关于p=L的理解</span></h3><p id="b5903ee1ed44d08989b2aaf858ba1a47" class="ne-p"><span class="ne-text">写代码的时候，还经常遇到下面的情况</span></p><p id="22e2a41b379b545011d6dba722e6440c" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616501697301-b63e6312-d8f9-4130-8d25-2d3becd75038.png" width="233" id="sQQqv" class="ne-image"></p><p id="90e4c31faebbcdf8ad4edd95189d5cd0" class="ne-p"><span class="ne-text">p、L就是指向结点的指针类型，将L的值赋给p，也就是p、L指向同一个结点。具体理解可以用下面一个例子来说明：</span></p><p id="e77fbf67f75189f49760964c7edbbb44" class="ne-p"><span class="ne-text">下面图片这个函数就是在一个单链表中，功能就是指定i位置插入e值。下图箭头处如果TraverseList返回的是p那么得出的链表结果就是从插入的那个元素往后这样一个部分链表，返回的是L就是想要的结果，p的功能有点类似在L的中间做了手脚……</span></p><p id="ea6d7ac80e26cac99036b09285d023d1" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616501856348-955542eb-258d-473f-b003-c53881275937.png" width="370" id="IhEAo" class="ne-image"></p><h2 id="j3WQa"><span class="ne-text">各种代码</span></h2><h3 id="6qnQd"><span class="ne-text">实验报告代码</span></h3><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;<p>typedef struct LNode &#123;<br>    int data;<br>    struct LNode *next;<br>&#125;Lnode, *LinkList;</p><p>LinkList L;</p><p>void InitList(LinkList &amp;L) &#123;<br>    L = new LNode;<br>    L-&gt;next = NULL;<br>&#125;</p><p>void CreateList_H(LinkList &amp;L) &#123;<br>    InitList(L);<br>    int n;<br>    cout &lt;&lt; &quot;请输入要使用前插法插入的元素个数：&quot;;<br>    cin &gt;&gt; n;<br>    for (int i = 0; i &lt; n; i++)&#123;<br>        LNode *p = new LNode;<br>        cin &gt;&gt; p-&gt;data;<br>        p-&gt;next = L-&gt;next;<br>        L-&gt;next = p;<br>    &#125;<br>&#125;<br>void TraverseList(LinkList &amp;L)&#123;<br>    LNode *p = new LNode;<br>    p = L-&gt;next;<br>    cout &lt;&lt; &quot;此链表打印的结果为：&quot;&lt;&lt;&quot;\n&quot;;<br>    while (p != NULL)&#123;<br>        cout &lt;&lt; p-&gt;data &lt;&lt; &quot; &quot;;<br>        p = p-&gt;next;<br>    &#125;<br>    cout &lt;&lt; &quot;\n&quot;;<br>&#125;<br>void GetElem(LinkList &amp;L) &#123;<br>    int n;<br>    cout &lt;&lt; &quot;请输入要查询的链表中第i个数：&quot;;<br>    cin &gt;&gt; n;<br>    LNode *p = new LNode;<br>    p = L;<br>    for (int i = 0; i &lt; n;i++)&#123;<br>        p = p-&gt;next;<br>    &#125;<br>    cout &lt;&lt; &quot;查询的结果为：&quot; &lt;&lt; p-&gt;data&lt;&lt;&quot;\n&quot;;<br>&#125;<br>void ListInsert(LinkList &amp;L)&#123;<br>    LNode *p = new LNode;<br>    p = L;<br>    int n;<br>    int e;<br>    cout &lt;&lt; &quot;请分别输入要在第n个位置插入的e值：&quot;;<br>    cin &gt;&gt; n&gt;&gt; e ;<br>    for (int i = 0; i &lt; n;i++) &#123;<br>        if (n == i+1)&#123;<br>            LNode *temp = new LNode;<br>            temp-&gt;data = e;<br>            temp-&gt;next = p-&gt;next;<br>            p-&gt;next = temp;<br>            break;<br>        &#125;<br>        p = p-&gt;next;<br>    &#125;<br>    TraverseList(L); // 直接返回L就可以了，之前返回p是不可以的！！！唉，大意了~<br>&#125;<br>void ListDelete(LinkList &amp;L)&#123;<br>    cout &lt;&lt; &quot;请输入要删除的第j个位置的j值：&quot;;<br>    LNode *p = new LNode;<br>    p = L;<br>    int j;<br>    cin &gt;&gt; j;<br>    for (int i = 0; i &lt; j;i++) &#123;<br>        if (j == i+1) &#123;<br>            p-&gt;next = p-&gt;next-&gt;next;<br>            break;<br>        &#125;<br>        p = p-&gt;next;<br>    &#125;<br>    TraverseList(L);<br>&#125;<br>void ReverseList(LinkList &amp;L) &#123;<br>    LNode *p = L-&gt;next;<br>    L-&gt;next = NULL;<br>    while(p)<br>    &#123;<br>        LNode *q = p-&gt;next;<br>        p-&gt;next = L-&gt;next;<br>        L-&gt;next = p;<br>        p = q;<br>    &#125;<br>    cout &lt;&lt; &quot;通过逆置之后……&quot;;<br>    TraverseList(L);<br>&#125;</p><p>int main() &#123;<br>    LNode *test = new LNode;<br>    CreateList_H(test);//1<br>    TraverseList(test);//1<br>    GetElem(test);//2<br>    ListInsert(test);//3<br>    ListDelete(test);//4<br>    ReverseList(test);//5<br>&#125;<br></code></pre></p><p id="6924a6f6a888785632ceae0b56ec2c76" class="ne-p"><br></p><h3 id="vUcQ1"><span class="ne-text">单链表各种操作代码总结</span></h3><ul class="ne-tl"><li checked="true" id="d8f54fbe28dd447b243ee72253190acc"><span class="ne-text">单链表存储形式</span></li></ul><pre><code>typedef struct LNode &#123;    int data; //数据域    struct LNode *next; //指针域&#125;Lnode, *LinkList; //LinkList为指向结构体LNode的指针类型</code></pre><ul class="ne-tl"><li checked="true" id="027dcb64e4c7da81c1dce8344a65d6fc"><span class="ne-text">初始化</span></li><li checked="true" id="0c0d3140097f699146d288977fa442b9"><span class="ne-text">创建：前插法</span></li><li checked="true" id="c7a314b61d17dd1aa7915287ece885a1"><span class="ne-text">创建：后插法</span></li><li checked="true" id="dc521ab52463696309916d7834adee61"><span class="ne-text">取值</span></li><li checked="true" id="0040cab7104e6ad31c114f5380f60ead"><span class="ne-text">插值</span></li><li checked="true" id="8eeed69d6492556fbea91c72881e50e7"><span class="ne-text">删除</span></li><li checked="true" id="fd5154d1130614337170b6352b00cc10"><span class="ne-text">打印</span></li><li checked="true" id="9c3c22c01869ff0d25e899ab92ffe053"><strong><span class="ne-text">逆置</span></strong></li></ul><p id="efde38cb18c702fbc13b193fd111d4a5" class="ne-p"><span class="ne-text">逆置多用前插的思想</span></p><pre><code>void ReverseList(LinkList &amp;L) &#123;    LNode *p = L-&gt;next;                 L-&gt;next = NULL;                    while(p) &#123;        LinkList q = p-&gt;next;                 p-&gt;next = L-&gt;next;                  L-&gt;next = p;                        p = q;                          &#125;&#125;</code></pre><p id="85d0a02ed4a1f5c0e36e8c9878c2b016" class="ne-p"><span class="ne-text">所有操作如下</span></p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;<p>/**</p><ul><li>单链表</li><li></li><li>链表的基本操作：初始化、创建（前插、后插）、取值、查找、插值、删除、打印、逆置</li><li>/</li></ul><p>/* 单链表的存储结构 */<br>typedef struct LNode &#123;<br>    int data; //数据域<br>    struct LNode *next; //指针域<br>&#125;Lnode, *LinkList; //LinkList为指向结构体LNode的指针类型</p><p>/* 初始化链表 */<br>void InitList(LinkList &amp;L) &#123;<br>    L = new LNode;<br>    L-&gt;next = NULL;<br>&#125;</p><p>/* 创建：前插 */<br>void CreateList_H(LinkList &amp;L, int n) &#123;<br>    InitList(L);<br>    for (int i = 0; i &lt; n; i++)&#123;<br>        LNode *p = new LNode;<br>        cin &gt;&gt; p-&gt;data;<br>        p-&gt;next = L-&gt;next;<br>        L-&gt;next = p;<br>    &#125;<br>&#125;</p><p>/* 创建：后插 */<br>void CreateList_R(LinkList &amp;L, int n) &#123;<br>    cout &lt;&lt; &quot;请输入&quot; &lt;&lt; n &lt;&lt; &quot;个数字&quot;&lt;&lt; &quot;\n&quot;;<br>    InitList(L);<br>    // 定义一个在下面循环用来一直操作所加元素的结点p来指向头结点L<br>    LinkList p = L;<br>    for (int i = 0; i &lt; n;i++) &#123;<br>        LinkList q = new Lnode;<br>        q-&gt;next = NULL;<br>        cin &gt;&gt; q-&gt;data;<br>        p-&gt;next = q;<br>        p = q; //为了下一次<br>    &#125;<br>&#125;</p><p>/* 取值 */<br>void GetElem(LinkList &amp;L, int n) &#123;<br>    LinkList p = L;<br>    for (int i = 0; i &lt; n;i++)&#123;<br>        p = p-&gt;next;<br>    &#125;<br>    cout &lt;&lt;n&lt;&lt;&quot;的值为：&quot; &lt;&lt; p-&gt;data&lt;&lt;&quot;\n&quot;&lt;&lt;&quot;\n&quot;;<br>&#125;</p><p>/* 查找 */<br>void SearchElem(LinkList &amp;L, int ele) &#123;<br>    LinkList p = L;<br>    int count = 0;<br>    while (p-&gt;data != ele) &#123;<br>        p = p-&gt;next;<br>        count++;<br>    &#125;<br>    cout &lt;&lt;ele&lt;&lt;&quot;这个值的索引位置是：&quot;&lt;&lt; count&lt;&lt;&quot;\n&quot;;<br>&#125;</p><p>/* 插值：在第n个位置插入ele值*/<br>void ListInsert(LinkList &amp;L, int n, int ele)&#123;<br>    LinkList p = L;<br>    for (int i = 0; i &lt; n;i++) &#123;<br>        if (n == i+1)&#123;<br>            LinkList temp = new LNode;<br>            temp-&gt;data = ele;<br>            temp-&gt;next = p-&gt;next;<br>            p-&gt;next = temp;<br>            break;<br>        &#125;<br>        p = p-&gt;next;<br>    &#125;<br>    TraverseList(L);<br>&#125;</p><p>/* 删除：删除第j个位置的值 */<br>void ListDelete(LinkList &amp;L, int j)&#123;<br>    LinkList p = L;<br>    for (int i = 0; i &lt; j;i++) &#123;<br>        if (j == i+1) &#123;<br>            p-&gt;next = p-&gt;next-&gt;next;<br>            break;<br>        &#125;<br>        p = p-&gt;next;<br>    &#125;<br>    TraverseList(L);<br>&#125;</p><p>/* 打印 */<br>void TraverseList(LinkList &amp; L)&#123;<br>        LNode <em>p = new LNode;<br>        p = L-&gt;next;<br>        cout &lt;&lt; &quot;此链表打印的结果为：&quot;<br>             &lt;&lt; &quot;\n&quot;;<br>        while (p != NULL)<br>        &#123;<br>            cout &lt;&lt; p-&gt;data &lt;&lt; &quot; &quot;;<br>            p = p-&gt;next;<br>        &#125;<br>        cout &lt;&lt; &quot;\n&quot;;<br>&#125;<br>/</em> 逆置 */<br>void ReverseList(LinkList &amp;L) &#123;<br>    LNode *p = L-&gt;next;<br>    L-&gt;next = NULL;<br>    while(p)<br>    &#123;<br>        LNode *q = p-&gt;next;<br>        p-&gt;next = L-&gt;next;<br>        L-&gt;next = p;<br>        p = q;<br>    &#125;<br>    cout &lt;&lt; &quot;通过逆置之后……&quot;;<br>    TraverseList(L);<br>&#125;</p><p>int main() &#123;<br>    // LNode *test = new LNode;<br>    LinkList test;<br>    // struct LNode *test;<br>    CreateList_R(test,4);<br>    SearchElem(test, 3);<br>    // cout &lt;&lt; GetEle(test, 2);<br>    // TraverseList(test);<br>    // GetElem(test,2);<br>    // ListInsert(test);<br>    // ListDelete(test);<br>    // ReverseList(test);<br>&#125;<br></code></pre></p><h3 id="9cNHm"><span class="ne-text">循环链表代码</span></h3><p id="549db6ef0c251cb77027ad7d5eaff608" class="ne-p"><span class="ne-text"> * 循环链表其实只需要注意最后一个结点所指向的下一个结点为头结点L就好了</span></p><p id="da588e22a9aeca27b818a25ed2e924a5" class="ne-p"><span class="ne-text"> * 还要注意头结点存不存元素</span></p><p id="e50f21c2f1c86db9888257f67c4fc1a7" class="ne-p"><span class="ne-text"> * 还有判断的时候条件不是单链表那样判断是否为空了，而是是否为头结点的值了</span></p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;<p>/**</p><ul><li>循环链表</li><li></li><li>循环链表其实只需要注意最后一个结点所指向的下一个结点为头结点L就好了</li><li>还要注意头结点存不存元素</li><li>还有判断的时候条件不是单链表那样判断是否为空了，而是是否为头结点的值了</li><li>/</li></ul><p>/* 定义一个单链表 */<br>typedef struct LNode &#123;<br>    int data;<br>    struct LNode *next;<br>&#125;Lnode, *LinkList;</p><p>/**</p><ul><li>初始化单链表</li><li>/<br>void InitList(LinkList &amp;L) &#123;<br>  L = new LNode;<br>  L-&gt;next = NULL;<br>&#125;</li></ul><p>/**</p><ul><li>初始化单链表并将其变成循环链表</li><li>/</li></ul><p>void CircleList(LinkList &amp;L, int n) &#123;<br>    InitList(L);<br>    // 初始化第一个结点的值<br>    L-&gt;data = 1;<br>    LinkList p = L;<br>    for (int i = 2; i &lt;= n; i++) &#123;<br>        LinkList temp = new Lnode;<br>        temp-&gt;data = i;<br>        if (i == n) &#123;<br>            temp-&gt;next = L;<br>            p-&gt;next = temp;<br>            break;<br>        &#125;<br>        temp-&gt;next = NULL;<br>        p-&gt;next = temp;<br>        p = p-&gt;next;<br>    &#125;<br>&#125;</p><p>/**</p><ul><li>打印输出用来测试是否为循环链表</li><li>/<br>void PrintList(LinkList &amp;L, int n) &#123;<br>  LinkList p = L;<br>  for (int i = 0; i &lt; n;i++) &#123;<pre><code>  cout &amp;lt;&amp;lt; p-&amp;gt;data &amp;lt;&amp;lt; &amp;quot; &amp;quot;;  p = p-&amp;gt;next;</code></pre>  }<br>}</li></ul><p>int main() {<br>    LinkList test;<br>    CircleList(test,5);<br>    PrintList(test, 12);<br>}<br></code></pre></p><p id="ff79e6e706f18ea894d0ae5a945a8faa" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1618307254729-8f60bc5d-be41-47fe-a2ad-466715cc740e.png" width="298" id="w18Z2" class="ne-image"></p><h3 id="oJUke"><span class="ne-text">双向链表代码</span></h3><ul class="ne-ul"><li id="7af3cafdf043e6e1bf6359aa4e769148"><span class="ne-text">双向链表从某种意义上来说，更加简单了，因为可操作的“指向更多了”，但正因为这样，所以每次指向操作之后，检查一下有没有“落单的指向”</span></li><li id="86ad4ef024a48d73c326810ae865c10b"><span class="ne-text">删除某个结点的时候，一定要记得删除哪个结点，就操作哪个结点</span></li></ul><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;<p>/**</p><ul><li>双向链表</li><li>/</li></ul><p>/* 双向链表的存储结构 */<br>typedef struct DuLNode &#123;<br>    int data;<br>    struct DuLNode *prior;<br>    struct DuLNode *next;<br>&#125;DuLnode, *DuLinkList; </p><p>/* 双向链表的初始化 */<br>void InitDuLinkList(DuLinkList &amp;L) &#123;<br>    L = new DuLNode;<br>    L-&gt;prior = NULL;<br>    L-&gt;next = NULL;<br>&#125;</p><p>int main() &#123;<br>    DuLinkList L;<br>    InitDuLinkList(L);<br>    // 初始化初始节点值为100<br>    L-&gt;data = 100;<br>    // 在L结点前面插值50<br>    DuLinkList L_prior;<br>    L_prior-&gt;data = 50;<br>    L_prior-&gt;next = L;<br>    L-&gt;prior = NULL;<br>    L-&gt;prior = L_prior;<br>    // 在L结点后面插值150<br>    DuLinkList L_next;<br>    L_next-&gt;data = 150;<br>    L_next-&gt;prior = L;<br>    L_next-&gt;next = NULL;<br>    L-&gt;next = L_next;<br>    cout &lt;&lt; L_prior-&gt;data &lt;&lt; &quot; &quot; &lt;&lt; L_prior-&gt;next-&gt;data &lt;&lt; &quot; &quot; &lt;&lt; L_prior-&gt;next-&gt;next-&gt;data&lt;&lt;&quot;\n&quot;;<br>    // 在50和100之间插值75（只操作L结点）<br>    DuLinkList L_prior_L;<br>    L_prior_L-&gt;data = 75;<br>    L_prior_L-&gt;prior = L-&gt;prior;<br>    L-&gt;prior-&gt;next = L_prior_L;<br>    L_prior_L-&gt;next = L;<br>    L-&gt;prior = L_prior_L;<br>    cout &lt;&lt; L-&gt;prior-&gt;prior-&gt;data &lt;&lt; &quot; &quot; &lt;&lt; L-&gt;prior-&gt;data &lt;&lt; &quot; &quot; &lt;&lt; L-&gt;data &lt;&lt;&quot; &quot;&lt;&lt; L-&gt;next-&gt;data&lt;&lt;&quot;\n&quot;;<br>    // 删除75这个值的结点(记住一点，删除哪个结点就操作哪个结点)<br>    L_prior_L-&gt;next-&gt;prior = L_prior_L-&gt;prior;<br>    L_prior_L-&gt;prior-&gt;next = L_prior_L-&gt;next;<br>    cout &lt;&lt; L-&gt;prior-&gt;data &lt;&lt; &quot; &quot; &lt;&lt; L-&gt;data &lt;&lt; &quot; &quot; &lt;&lt; L-&gt;next-&gt;data &lt;&lt; &quot;\n&quot;;<br>&#125;<br></code></pre></p><p id="f11573736063c8fe96bf5ee924812cba" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1618309282126-1ad3d5c4-1d3e-425f-b474-27f33261ead6.png" width="263" id="cIkbQ" class="ne-image"></p><h2 id="fi44g"><span class="ne-text">参考</span></h2><ul class="ne-ul"><li id="62da17fbdf777d52c0d1361001a230c1"><a href="http://shangdixinxi.com/detail-1507915.html" data-href="http://shangdixinxi.com/detail-1507915.html" target="_blank" class="ne-link"><span class="ne-text">链表p-&gt;next=q-&gt;next,q-&gt;next=p,q=p;的一些解释</span></a></li><li id="fc4623d0caae8ec3ef1caecb202218cf"><a href="https://blog.csdn.net/weixin_44135282/article/details/90348885" data-href="https://blog.csdn.net/weixin_44135282/article/details/90348885" target="_blank" class="ne-link"><span class="ne-text">p-&gt;next=q与q=p-&gt;next区分</span></a></li><li id="47c085a3d88531803ecee1fec885d77d"><a href="https://www.jianshu.com/p/73d56c3d228c" data-href="https://www.jianshu.com/p/73d56c3d228c" target="_blank" class="ne-link"><span class="ne-text">数据结构：链表</span></a></li></ul><p id="0f9e0d8be38732af40953d37ead05312" class="ne-p"><br></p></div>]]></content>
      
      
      <categories>
          
          <category> 计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 📶线结构：字符串-数组-栈-队列 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript函数及this不同场景下的指向</title>
      <link href="/blog/egols2d1kxs2/"/>
      <url>/blog/egols2d1kxs2/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="ueac13956" class="ne-p"><span class="ne-text">前言：基本上和之前学过的语言一样，return语句、continue语句、break语句、函数的传参用法基本都一样，记录一下js的特征用法</span></p><h1 id="EEH6p"><span class="ne-text">一、函数</span></h1><h2 id="X8waC"><span class="ne-text">函数定义及使用</span></h2><p id="72f9191dd6c40f9c957d08a6a4fb5fa6" class="ne-p"><span class="ne-text">不像之前的C++、JAVA那样需要一个返回值来声明，JavaScript里面直接一个关键字就搞定了，如果里面有return就返回return的值，没有则返回undefined。下面记录一下js里面的三种函数声明方式和不同情况下的使用场景。</span></p><h3 id="C0pXG"><span class="ne-text">function关键字</span></h3><div class="ne-quote"><p id="cac310a57f721c495201fd8f43fd717a" class="ne-p"><span class="ne-text">自定义函数方式(命名函数)利用函数关键字 function 自定义函数方式</span></p></div><pre><code>// 声明定义方式function fn() &#123;...&#125;// 调用  fn();</code></pre><ul class="ne-ul"><li id="f79542d89be6709192b07b467ab1226b"><span class="ne-text">调用函数的代码既可以放到声明函数的前面，也可以放在声明函数的后面</span></li></ul><h3 id="LMsru"><span class="ne-text">匿名函数表达式</span></h3><p id="uf48c7914" class="ne-p"><span class="ne-text">函数表达式方式(匿名函数）</span></p><div class="ne-quote"><p id="d040539e6b580f6af5b43432e1718261" class="ne-p"><span class="ne-text">【C++11里面也有匿名函数的用法，基本上就是</span><strong><span class="ne-text">匿名函数表达式</span></strong><span class="ne-text">】</span></p></div><pre><code>// 这是函数表达式写法，匿名函数后面跟分号结束var fn = function()&#123;...&#125;;// 调用的方式，函数调用必须写到函数体下面fn();</code></pre><ul class="ne-ul"><li id="d283d6025aa0cb9c95c9e5d6432ca365"><span class="ne-text">这个fn 里面存储的是一个函数</span></li><li id="5426ae5b14dc2793b18c9f79bb1cf86b"><span class="ne-text">函数表达式方式原理跟声明变量方式是一致的</span></li><li id="80bea0e7c9c366bf13aed839abfac9c2"><span class="ne-text">函数调用的代码必须写到函数体后面</span></li></ul><h3 id="RafLV"><span class="ne-text">构造函数</span></h3><ul class="ne-ul"><li id="aeb9c9b1aab71e3be3ce5b0910474db7"><span class="ne-text">所有函数都是Function的对象，函数也是对象</span></li></ul><pre><code>var f = new Function('a', 'b', 'console.log(a + b)');f(1, 2);var fn = new Function('参数1','参数2'..., '函数体')</code></pre><p id="u336b8edc" class="ne-p"><br></p><h2 id="xa3mE"><span class="ne-text">函数参数</span></h2><h3 id="zek5T"><span class="ne-text">arguments</span></h3><p id="f311e77fa167c8ab1de5f667408fff32" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1617851666624-a963acb7-8a97-43bc-9998-35738a1a1a7f.png" width="467.5" id="OVrKI" class="ne-image"></p><p id="d6a5429b661f0a926663653c08d5a96f" class="ne-p"><strong><span class="ne-text">当不确定有多少个参数传递的时候，可以用 arguments 来获取</span></strong><span class="ne-text">。JavaScript 中，arguments实际上它是当前函数的一个内置对象。所有函数都内置了一个 arguments 对象，arguments 对象中存储了传递的所有实参。arguments展示形式是一个伪数组，因此可以进行遍历。伪数组具有以下特点：</span></p><ul class="ne-ul"><li id="8843827210f3e42e9156792599a0c118"><span class="ne-text">具有 length 属性</span></li><li id="b11e149419c70d416f470742d52ad2ea"><span class="ne-text">按索引方式储存数据</span></li><li id="af2df2e4345f47f3086f4e9675aa2d5e"><span class="ne-text">不具有数组的 push , pop 等方法<br /></span><span class="ne-text">注意：在函数内部使用该对象，用此对象获取函数调用时传的实参。</span></li></ul><h3 id="tJe43"><span class="ne-text">箭头函数中arguments不可用</span></h3><p id="d00f8bade49b871e8239cf73671daa98" class="ne-p"><span class="ne-text">es6的箭头函数用起来很方便，但是一个不方便的就是在这里面</span><span class="ne-text">arguments 不能用了</span></p><p id="a1d8c49b30b7ae2677e321044c51a114" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1617852137156-ea361bcf-a64d-40e7-9ad4-de9ad5a2789d.png" width="464" id="FOFeI" class="ne-image"></p><p id="46c2b14c2b66de8578ce1092cd594b13" class="ne-p"><span class="ne-text">如果非要用的化，将这个箭头函数放在一个普通函数里面，让箭头函数接受这个普通函数的参数</span></p><p id="494bcad7a1c0a199d65391a31a8e438e" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1617852218090-65cab2f5-0088-41e5-95fa-0845a253fcbd.png" width="377" id="kFJpX" class="ne-image"></p><h3 id="YcdT5"><span class="ne-text">关于值传递</span></h3><p id="828ba1738a54a70ab3e620409dd3bde3" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1617852230127-5b2394d1-82c0-48a4-8bbb-385f5d27760b.png" width="406.5" id="Iq2ke" class="ne-image"></p><h2 id="iPHty"><span class="ne-text">简单/复杂数据类型传参</span></h2><ul class="ne-ul"><li id="u7e7dc6da"><span class="ne-text"></span><strong><span class="ne-text">简单类型</span></strong><span class="ne-text">（</span><strong><span class="ne-text">基本数据类型</span></strong><span class="ne-text">、</span><strong><span class="ne-text">值类型</span></strong><span class="ne-text">）：在存储时变量中存储的是值本身，包括string ，number，boolean，undefined，null</span></li><li id="u1e4d266a"><span class="ne-text"></span><strong><span class="ne-text">复杂数据类型（引用类型）</span></strong><span class="ne-text">：在存储时变量中存储的仅仅是地址（引用），通过 new 关键字创建的对象（系统对象、自定义对象），如 Object、Array、Date等；</span></li></ul><h3 id="NyCmw"><span class="ne-text">堆栈存储区别</span></h3><p id="uac14d1ad" class="ne-p"><span class="ne-text">堆栈空间分配区别：</span></p><p id="u0d4c51a5" class="ne-p"><span class="ne-text">1、栈（操作系统）：由操作系统自动分配释放存放函数的参数值、局部变量的值等。其操作方式类似于数据结构中的栈；</span></p><p id="ud59709bd" class="ne-p"><span class="ne-text">简单数据类型存放到栈里面</span></p><p id="ufb2855d4" class="ne-p"><span class="ne-text">2、堆（操作系统）：存储复杂类型(对象)，一般由程序员分配释放，若程序员不释放，由垃圾回收机制回收。</span></p><p id="ue7c0d4a8" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611885075555-12234777-10f8-4df1-8a9f-e61078298520.png" width="238" id="OjtFR" class="ne-image"></p><p id="ub0f3ed76" class="ne-p"><span class="ne-text">简单数据类型的存储方式：值类型变量的数据直接存放在变量（栈空间）中</span></p><p id="ucd1e1316" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611885085102-7ebb3c36-ffc2-4a5b-af50-c8e377f92cef.png" width="394.5" id="IeCaI" class="ne-image"></p><p id="uddc1f7fd" class="ne-p"><span class="ne-text">复杂数据类型的存储方式：引用类型变量（栈空间）里存放的是地址，真正的对象实例存放在堆空间中</span></p><p id="uc55c772d" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611885116525-3f8ac293-e955-40f9-bbff-1aa589b53efa.png" width="279" id="jlWv9" class="ne-image"></p><h3 id="ABgTS"><span class="ne-text">简单类型传参</span></h3><p id="u90c5491d" class="ne-p"><span class="ne-text">函数的形参也可以看做是一个变量，当我们把一个</span><strong><span class="ne-text">值类型变量</span></strong><span class="ne-text">作为参数传给函数的形参时，其实是把变量在栈空间里的值</span><strong><span class="ne-text">复制了一份给形参</span></strong><span class="ne-text">，那么在方法内部对形参做任何修改，都不会影响到的外部变量。</span></p><pre><code>let some = 111;const change = (o) =&gt; &#123;  o = 222;&#125;;console.log(some); // 111change(some);console.log(some); // 111</code></pre><h3 id="LhYgy"><span class="ne-text">复杂数据类型传参</span></h3><p id="ud7624fb8" class="ne-p"><span class="ne-text">函数的形参也可以看做是一个变量，当我们把引用类型变量传给形参时，其实是把变量在栈空间里保存的堆地址复制给了形参，形参和实参其实保存的是同一个堆地址，所以操作的是同一个对象。</span></p><pre><code>const obj = &#123;  x: 111,&#125;;const change = (o) =&gt; &#123;  o.x = 222;&#125;;console.log(obj.x); // 111change(obj);console.log(obj.x); // 222</code></pre><h1 id="t0M8K"><span class="ne-text">二、this</span></h1><h2 id="uG7dX"><span class="ne-text">几个常用this指向</span></h2><ul class="ne-ul"><li id="b12db0c1b44a96c0860ec712b67838a8"><span class="ne-text">全局作用域或者普通函数中this指向全局对象window（定时器里面的this指向window）</span></li></ul><pre><code>function fn() &#123;  console.log(this); // Window&#125;window.fn();window.setTimeout(function () &#123;  console.log(this); // Window&#125;, 1000);</code></pre><ul class="ne-ul"><li id="d940230ffea7da43e23a70b95c5abe22"><span class="ne-text">方法调用中谁调用this指向谁</span></li></ul><pre><code>var o = &#123;  sayHi: function () &#123;    console.log(this); // this指向的是 o 这个对象  &#125;,&#125;;o.sayHi();</code></pre><p id="u83d3980c" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1668946804214-60fa4a1f-3e55-4376-b6e0-9edfe81b9acd.png" width="129.6" id="udc71e238" class="ne-image"></p><pre><code>var btn = document.querySelector(&quot;button&quot;);btn.addEventListener(&quot;click&quot;, function () &#123;  console.log(this); // 事件处理函数中的this指向的是btn这个按钮对象&#125;);</code></pre><p id="u49a7f530" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1668946866999-00e9175c-7986-4596-83ed-9c420904b214.png" width="167.2" id="uebc3722c" class="ne-image"></p><ul class="ne-ul"><li id="3d0a596a8316330855355f25214d49d7"><span class="ne-text">构造函数中this指向构造函数的实例</span></li></ul><pre><code>function Fun() &#123;  console.log(this); // this 指向的是fun 实例对象&#125;var fun = new Fun();</code></pre><p id="ub91c4c50" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1668946751737-3b11c194-1db4-4353-9d1a-f17f78355fa8.png" width="159.2" id="u05e77006" class="ne-image"></p><h2 id="sUQvc"><span class="ne-text">改变函数内部this指向</span></h2><p id="uf7ff9938" class="ne-p"><span class="ne-text">这些 this 的指向，是当我们调用函数的时候确定的。调用方式的不同决定了this 的指向不同</span></p><p id="u3a0b5eb4" class="ne-p"><span class="ne-text">一般指向我们的调用者.</span></p><h3 id="oTowG"><span class="ne-text">call方法</span></h3><p id="80cca7746d6e3f6ddfbe0d0a13db64e5" class="ne-p"><span class="ne-text">call()方法调用一个对象。简单理解为调用函数的方式，但是它可以改变函数的 this 指向</span></p><p id="7d682c1147cd95a30b2a202e05e6d44a" class="ne-p"><span class="ne-text">应用场景:  经常做继承.</span></p><pre><code>var o = &#123;    name: 'andy'&#125; function fn(a, b) &#123;      console.log(this);      console.log(a+b)&#125;;fn(1,2)// 此时的this指向的是window 运行结果为3fn.call(o,1,2)//此时的this指向的是对象o,参数使用逗号隔开,运行结果为3</code></pre><h3 id="SYKcd"><span class="ne-text">apply方法</span></h3><p id="73b1a29ae377fe1ddecf267dd75876bc" class="ne-p"><span class="ne-text">apply() 方法调用一个函数。简单理解为调用函数的方式，但是它可以改变函数的 this 指向。</span></p><p id="dd98af2b8f1c5e1042c608d46e2719dc" class="ne-p"><span class="ne-text">应用场景:  经常跟数组有关系</span></p><pre><code>var o = &#123;    name: 'andy'&#125; function fn(a, b) &#123;      console.log(this);      console.log(a+b)&#125;;fn(1, 2)// 此时的this指向的是window 运行结果为3fn.apply(o,[1,2])//此时的this指向的是对象o,参数使用数组传递 运行结果为3</code></pre><h3 id="qVFN0"><span class="ne-text">bind方法</span></h3><p id="8f2d73d4ff5434244e4816d57d2cb70f" class="ne-p"><span class="ne-text">bind() 方法不会调用函数,但是能改变函数内部this 指向,返回的是原函数改变this之后产生的新函数</span></p><p id="ba3ad094ba0a2a1de54306a05a4b328d" class="ne-p"><span class="ne-text">如果只是想改变 this 指向，并且不想调用这个函数的时候，可以使用bind</span></p><p id="8b4f288bfc20dcaa6db7eb9f1f5a02c5" class="ne-p"><span class="ne-text">应用场景:不调用函数,但是还想改变this指向</span></p><pre><code>var o = &#123; name: 'andy' &#125;;function fn(a, b) &#123;    console.log(this);    console.log(a + b);&#125;;var f = fn.bind(o, 1, 2); //此处的f是bind返回的新函数f();//调用新函数  this指向的是对象o 参数使用逗号隔开</code></pre><h3 id="c1uzr"><span class="ne-text">call、apply、bind三者的异同</span></h3><ul class="ne-ul"><li id="837bea232f7b27b17dfc1aad61300dca"><span class="ne-text">共同点 : 都可以改变this指向</span></li><li id="a9e715db538e1cdabc5c18c1fa0b36bc"><span class="ne-text">不同点:</span></li></ul><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="19a7e4c1e6fc48212336c8fef1dac5ad"><span class="ne-text">call 和 apply  会调用函数, 并且改变函数内部this指向.</span></li><li id="466f286b25babfe9a43ac9c4a313764e"><span class="ne-text">call 和 apply传递的参数不一样,call传递参数使用逗号隔开,apply使用数组传递</span></li><li id="06600e50bdef14fb975e1c3fa12d4f53"><strong><span class="ne-text">bind  不会调用函数</span></strong><span class="ne-text">, 可以改变函数内部this指向.</span></li></ul></ul><ul class="ne-ul"><li id="6da2dd93023b14ff4a91066c042741e8"><span class="ne-text">应用场景</span></li></ul><ol class="ne-list-wrap"><ol ne-level="1" class="ne-ol"><li id="8b224e2fbc010eec2cfde9212337b809"><span class="ne-text">call 经常做继承.</span></li><li id="40e7f61a43b0d91c0459283a016ca67d"><span class="ne-text">apply经常跟数组有关系.  比如借助于数学对象实现数组最大值最小值</span></li><li id="83fdbccdc3765ef1b5c93004952744e1"><span class="ne-text">bind  不调用函数,但是还想改变this指向. 比如改变定时器内部的this指向.</span></li></ol></ol><h2 id="oALIH"><span class="ne-text">setTimeout和setInterval中的this</span></h2><p id="ud51af3d9" class="ne-p" style="text-align: justify"><span class="ne-text" style="color: rgb(77, 77, 77); font-size: 16px">在setTimeOut()或setInterval()这样的方法中，如果传入的函数包含this, 那么，默认情况下，函数中的this会指向window对象。这是由于setTimeout()调用的代码运行在与所在函数完全分离的执行环境上。这会导致这些代码中包含的 this 关键字会指向 window (或全局)对象。有以下几种方式可以正确this指向：</span></p><h3 id="NshPR"><span class="ne-text" style="color: rgb(79, 79, 79)">方法1：将目标对象的this存为一个变量</span></h3><p id="ufc8a20a2" class="ne-p"><span class="ne-text" style="color: rgb(77, 77, 77); font-size: 16px">定时器内部的函数来访问到这个变量，此时的this，就指向了当前对象</span></p><pre><code>function doClick()&#123;  var that = this;  setInterval(function() &#123;    console.log(that.msg);  &#125;, 1000);&#125;</code></pre><h3 id="YqOau"><span class="ne-text" style="color: rgb(79, 79, 79)">方法2：利用bind()方法</span></h3><pre><code>function doClick()&#123;  setInterval(function() &#123;    console.log(this.msg);  &#125;.bind(this), 1000);  //利用bind()将this绑定到这个函数上&#125;</code></pre><h3 id="sOgXx"><span class="ne-text" style="color: rgb(79, 79, 79)">方法3：ES6的箭头函数</span></h3><p id="u9d5a1d2a" class="ne-p"><span class="ne-text" style="color: rgb(77, 77, 77); font-size: 16px">ES6中的箭头函数, this总是指向词法作用域，也就是外层调用者obj，因此利用箭头函数就可以轻松解决这个问题</span></p><pre><code>function doClick()&#123;  setInterval(() =&gt; &#123;    console.log(this.msg);  &#125;, 100);&#125;,</code></pre><h2 id="g0WFc"><span class="ne-text" style="color: rgb(77, 77, 77)">如何准确判断 this 指向的是什么？</span></h2><ol class="ne-ol"><li id="u52767a52"><span class="ne-text" style="color: rgb(77, 77, 77); font-size: 16px">函数是否在 new 中调用 (new 绑定)，如果是，那么 this 绑定的是新创建的对象。</span></li><li id="u7d785062"><span class="ne-text" style="color: rgb(77, 77, 77); font-size: 16px">函数是否通过 call,apply 调用，或者使用了 bind(即硬绑定)，如果是，那么 this 绑定的就是指定的对象。</span></li><li id="u2b7ef61a"><span class="ne-text" style="color: rgb(77, 77, 77); font-size: 16px">函数是否在某个上下文对象中调用 (隐式绑定)，如果是的话，this 绑定的是那个上下文对象。一般是 obj.foo()。</span></li><li id="ua0127edc"><span class="ne-text" style="color: rgb(77, 77, 77); font-size: 16px">如果以上都不是，那么使用默认绑定。如果在严格模式下，则绑定到 undefined，否则绑定到全局对象。</span></li><li id="ub6cad697"><span class="ne-text" style="color: rgb(77, 77, 77); font-size: 16px">如果把 Null 或者 undefined 作为 this 的绑定对象传入 call、apply 或者 bind，这些值在调用时会被忽略，实际应用的是默认绑定规则。</span></li><li id="ud7f7dca0"><span class="ne-text" style="color: rgb(77, 77, 77); font-size: 16px">如果是箭头函数，箭头函数的 this 继承的是外层代码块的 this。</span></li></ol><h1 id="LeD6H"><span class="ne-text">三、闭包</span></h1><p id="76c889831aab9d05eb52cec950336aca" class="ne-p"><span class="ne-text">闭包（closure）指有权访问另一个函数作用域中变量的函数。简单理解就是 ，一个作用域可以访问另外一个函数内部的局部变量。</span></p><h2 id="xs7BF"><span class="ne-text">闭包的作用</span></h2><p id="63e908510a6aff59e9327379faa2435c" class="ne-p"><span class="ne-text">作用：延伸变量的作用范围。</span></p><pre><code>function fn() &#123;  var num = 10;  function fun() &#123;    console.log(num);  &#125;  return fun;&#125;var f = fn();f();</code></pre><h2 id="vzrZP"><span class="ne-text">闭包的案例</span></h2><ol class="ne-ol"><li id="a3a8e47a2abddf99014bff26562b3108"><span class="ne-text">利用闭包的方式得到当前li 的索引号</span></li></ol><pre><code>for (var i = 0; i &lt; lis.length; i++) &#123;// 利用for循环创建了4个立即执行函数// 立即执行函数也成为小闭包因为立即执行函数里面的任何一个函数都可以使用它的i这变量(function(i) &#123;    lis[i].onclick = function() &#123;      console.log(i);    &#125; &#125;)(i);&#125;</code></pre><ol start="2" class="ne-ol"><li id="e23058120f4f4379a7b8c6e3ee120611"><span class="ne-text">闭包应用-3秒钟之后,打印所有li元素的内容</span></li></ol><pre><code>for (var i = 0; i &lt; lis.length; i++) &#123;   (function(i) &#123;     setTimeout(function() &#123;     console.log(lis[i].innerHTML);     &#125;, 3000)   &#125;)(i);&#125;</code></pre><ol start="3" class="ne-ol"><li id="9ada127ae1595d7d5d1f035287cb5726"><span class="ne-text">闭包应用-计算打车价格</span></li></ol><pre><code>/*需求分析打车起步价13(3公里内),  之后每多一公里增加 5块钱.  用户输入公里数就可以计算打车价格如果有拥堵情况,总价格多收取10块钱拥堵费*/ var car = (function() &#123;     var start = 13; // 起步价  局部变量     var total = 0; // 总价  局部变量     return &#123;       // 正常的总价       price: function(n) &#123;         if (n &lt;= 3) &#123;           total = start;         &#125; else &#123;           total = start + (n - 3) * 5         &#125;         return total;       &#125;,       // 拥堵之后的费用       yd: function(flag) &#123;         return flag ? total + 10 : total;       &#125;    &#125; &#125;)();console.log(car.price(5)); // 23console.log(car.yd(true)); // 33</code></pre><p id="98b2a169a1398d289874189535e94975" class="ne-p"><br></p><pre><code>var name = &quot;The Window&quot;;   var object = &#123;     name: &quot;My Object&quot;,     getNameFunc: function() &#123;     return function() &#123;     return this.name;     &#125;;   &#125; &#125;;console.log(object.getNameFunc()())-----------------------------------------------------------------------------------var name = &quot;The Window&quot;;　　  var object = &#123;　　　　    name: &quot;My Object&quot;,    getNameFunc: function() &#123;    var that = this;    return function() &#123;    return that.name;    &#125;;  &#125;&#125;;console.log(object.getNameFunc()())</code></pre><p id="9d3b3410f572bb95a27cf75f4bc16f5d" class="ne-p"><br></p><h1 id="WkFNQ"><span class="ne-text">四、特殊功能性函数</span></h1><h2 id="NODez"><span class="ne-text">立即调用函数</span></h2><p id="u1fbd0b13" class="ne-p"><span class="ne-text">两种表达方式</span></p><ul class="ne-ul"><li id="ub635b41c"><span class="ne-text"> (function(){})()  </span></li><li id="u5533ec3b"><span class="ne-text"> (function(){}())</span></li></ul><p id="u1c9222f1" class="ne-p"><span class="ne-text">与立即执行函数相关的知识还有在函数前面加上一些符号（！、~、+……）会对函数的返回值进行相应的操作，其中加上~的意思是对返回值进行按位取反的操作，具体参考下面的参考资料</span></p><p id="ua9a270d6" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1617956106484-c021320c-100a-49b5-a668-99928bf3a720.png" width="472.98846435546875" id="uWasL" class="ne-image"></p><p id="u1fd169bb" class="ne-p"><span class="ne-text">参考：</span><span class="ne-text">https://blog.csdn.net/hot_cool/article/details/77567166</span></p><h2 id="drews"><span class="ne-text">生成器函数</span></h2><p id="uc723bf0c" class="ne-p"><span class="ne-text">类似于nodejs的express框架的中间件</span></p><p id="uce53102b" class="ne-p"><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/function*" data-href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/function*" target="_blank" class="ne-link"><span class="ne-text">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/function*</span></a></p><h2 id="aT35S"><span class="ne-text">方法函数</span></h2><h3 id="R0omn"><span class="ne-text">方法定义语法</span></h3><pre><code>const obj = &#123;  a: 'dd',  foo() &#123;    return 'bar';  &#125;,  some: () =&gt; &#123;    return 'something.'  &#125;&#125;;<p>console.log(obj.a, obj.foo(), obj.some()); // &quot;dd&quot; &quot;bar&quot; &quot;something.&quot;<br></code></pre></p><h3 id="mHlff"><span class="ne-text">get set函数</span></h3><p id="uc1cacfad" class="ne-p"><span class="ne-text">对象中可以定义get和set函数来完成更好的访问和修改对象属性值逻辑。</span></p><ul class="ne-ul"><li id="uc7d87134"><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/get" data-href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/get" target="_blank" class="ne-link"><span class="ne-text">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/get</span></a></li><li id="udf868282"><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/set" data-href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/set" target="_blank" class="ne-link"><span class="ne-text">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/set</span></a></li></ul><p id="ua14098b9" class="ne-p"><br></p><p id="ue7a71f74" class="ne-p"><br></p><p id="u6453869a" class="ne-p"><br></p><p id="u6dbb4a60" class="ne-p"><br></p><p id="ub6631d00" class="ne-p"><br></p><p id="u99c07e79" class="ne-p"><br></p><p id="u90a29703" class="ne-p"><br></p><p id="u095cadeb" class="ne-p"><br></p><p id="uf6aa086f" class="ne-p"><br></p><p id="u7b48dc95" class="ne-p"><br></p><p id="u1ff70eff" class="ne-p"><br></p><p id="u68ac64c5" class="ne-p"><br></p><p id="ue5cfbb9b" class="ne-p"><br></p><p id="uae970d7a" class="ne-p"><br></p><p id="uc7452431" class="ne-p"><br></p><p id="ubec4ec7f" class="ne-p"><br></p><p id="u8ef53ac6" class="ne-p"><br></p><p id="u9bb83e57" class="ne-p"><br></p><p id="ubddc1f17" class="ne-p"><br></p><p id="uec007e87" class="ne-p"><br></p><p id="u9fbc16a3" class="ne-p"><br></p><p id="u83da4ff8" class="ne-p"><br></p><p id="ufc0c584e" class="ne-p"><br></p><p id="u2ee70ca3" class="ne-p"><br></p><p id="u65dada90" class="ne-p"><br></p><p id="u08888f00" class="ne-p"><br></p><p id="u8356d7a5" class="ne-p"><br></p><p id="u791a5818" class="ne-p"><br></p><p id="u6973b2cf" class="ne-p"><br></p><p id="u74f7646b" class="ne-p"><br></p><p id="u68cd48ba" class="ne-p"><br></p><p id="ua51cf1a3" class="ne-p"><br></p><p id="u6bf640f1" class="ne-p"><br></p></div>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
          <category> JavaScript </category>
          
          <category> ECMAScript </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>DOM事件</title>
      <link href="/blog/wgzidzz85o76/"/>
      <url>/blog/wgzidzz85o76/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h2 id="QPRCY"><span class="ne-text">事件（低阶）</span></h2><div class="ne-quote"><p id="ba969457d3d481f4f58736bd6c36d828" class="ne-p"><span class="ne-text">事件三要素</span></p></div><ul class="ne-ul"><li id="5e185517246fffbef0739fa305e1a269"><span class="ne-text" style="background-color: #FADB14">Who(</span><span class="ne-text">事件源)：触发事件的元素</span></li><li id="896a369ca82ab809872eecb47593fe13"><span class="ne-text" style="background-color: #FADB14">What(</span><span class="ne-text">事件类型)： eg绑定click点击事件</span></li><li id="185614550c2f6249c6397a554774211d"><span class="ne-text" style="background-color: #FADB14">How(</span><span class="ne-text">事件处理程序)：事件触发后要执行的代码(函数赋值形式)，事件处理函数</span><strong><span class="ne-text"></span></strong></li></ul><p id="5b2cd1a827b3b52e697f8f9935da47fd" class="ne-p"><br></p><h3 id="QFfkk"><span class="ne-text">常见鼠标事件</span></h3><p id="3e300ab9705fb9183b85eece5ca6ad37" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518355975-babb3ede-4626-4ccd-9507-eb4c35c58439.png" width="714" id="lEgEZ" class="ne-image"></p><p id="952b40b9aa1db2e537818188929e4df5" class="ne-p"><br></p><h3 id="ATUpr"><span class="ne-text">addEventListener()</span></h3><div class="ne-quote"><p id="0d6e9dee2f34c5c515d1092ee25274a5" class="ne-p"><span class="ne-text">事件监听（IE9以后支持）</span></p></div><p id="73fd37530a6735c2e2dcaa5f9cc34d55" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518360715-05c708e0-db51-4791-b3cc-14ca89b6d9bc.png" width="707" id="ioKxV" class="ne-image"></p><p id="eea6d93e364e9871dd6af834731635c1" class="ne-p"><span class="ne-text">eventTarget.addEventListener()方法将指定的监听器注册到 eventTarget（目标对象）上，当该对象触发指定的事件时，就会执行事件处理函数。</span></p><ul class="ne-ul"><li id="a00280620bc4a8d0742c710aafb1252f"><span class="ne-text">type：监听事件类型click……（不要加on，要记得加引号）</span></li><li id="250ea7b30c98112381216e44c2987bb9"><span class="ne-text">listener：监听函数（触发之后进行什么样的行为（函数））</span></li><li id="b55cfb7798c0b34c00b574f86e6cde65"><span class="ne-text">useCapture：默认false</span></li></ul><pre><code>var class_down = document.getElementsByClassName('entry-thumb');var over_img_back_index = class_down[0].getElementsByTagName('img');over_img_back_index[0].addEventListener('mouseover',function()&#123;    alert('鼠标经过左侧图片，触发至即将跳转到首页');    location.href = 'https://www.wztlink1013.com';&#125;)</code></pre><h3 id="pAK2G"><span class="ne-text">attachEvent()</span></h3><div class="ne-quote"><p id="168bdd41b35757469d9dd7d566cacdda" class="ne-p"><span class="ne-text">事件监听（IE678支持）</span></p></div><p id="u93000583" class="ne-p"><span class="ne-text"></span></p><p id="56c0ebbd489fba897b85e1086fa6c3e8" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518360822-32bdd41a-9d13-4b76-93db-3f503b39bba7.png" width="696" id="azBrz" class="ne-image"></p><ul class="ne-ul"><li id="a2aa1adbfb03ca99b8a253c85e02926a"><span class="ne-text">和addEventListener()功能一样，不过这是老版本只带两个参数，而且第一个参数要加on</span></li></ul><h3 id="w1NHT"><span class="ne-text">兼容性解决注册事件</span></h3><p id="1fbe85f60da132b1ec60b147994d8381" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518360652-874303ea-a903-4f8c-93a0-a90c193c661b.png" width="867" id="mEfG9" class="ne-image"></p><p id="dd0475da28d2a7081f17bd64d0f74b23" class="ne-p"><span class="ne-text">封装一个函数，函数中判断浏览器的类型：</span></p><p id="f4837a32f19fbc68970b1d134989a6c5" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518360935-9054e419-704a-402e-969c-a572f0f322e0.png" width="643" id="jojyL" class="ne-image"></p><h3 id="3zq4i"><span class="ne-text">解绑事件</span></h3><p id="16781f9f62f480e76938fbb67d0bffc2" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518360992-53947cad-916b-4b2a-baf9-0587c30a33d9.png" width="737" id="ZW5u1" class="ne-image"></p><pre><code>&lt;div&gt;1&lt;/div&gt;&lt;div&gt;2&lt;/div&gt;&lt;div&gt;3&lt;/div&gt;&lt;script&gt;  var divs = document.querySelectorAll('div');  divs[0].onclick = function() &#123;    alert(11);    // 1. 传统方式删除事件    divs[0].onclick = null;  &#125;  // 2. removeEventListener 删除事件  divs[1].addEventListener('click', fn) // 里面的fn 不需要调用加小括号  function fn() &#123;    alert(22);    divs[1].removeEventListener('click', fn);  &#125;  // 3. detachEvent  divs[2].attachEvent('onclick', fn1);  function fn1() &#123;    alert(33);    divs[2].detachEvent('onclick', fn1);  &#125;&lt;/script&gt;</code></pre><div class="ne-quote"><p id="2ff54bd1d4bd426868a23a25308db2a6" class="ne-p"><strong><span class="ne-text">删除事件兼容性解决方案 </span></strong></p></div><p id="40666cbe6d5320d4846b4bbe5e2ff46b" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518361056-6ce22708-00af-43e8-943d-466fe8fcb053.png" width="713" id="hJ2YZ" class="ne-image"></p><h2 id="r3xe0"><span class="ne-text">常用鼠标事件</span></h2><p id="002c7cabdc9a78deb3d591b99f27e8d6" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518361860-3dea106f-9140-4836-8e7d-2f160b94435b.png" width="683" id="TkrRA" class="ne-image"></p><h3 id="QuEUR"><span class="ne-text">Demo：禁止选中文字和禁止右键菜单</span></h3><div class="ne-quote"><p id="f79c18b0892e2b84000032b48fe1e47b" class="ne-p"><span class="ne-text">【1】禁止鼠标选中</span></p></div><ul class="ne-ul"><li id="7125b6c7239ac18b49da8bb1898ca4f2"><span class="ne-text">selectstart开始选中</span></li></ul><pre><code>document.addEventListener('selectstart', function(e) &#123;  e.preventDefault();&#125;)</code></pre><div class="ne-quote"><p id="fc494d880867d15513a5bffa1c8f808d" class="ne-p"><span class="ne-text">【2】禁止鼠标右键菜单</span></p></div><ul class="ne-ul"><li id="8eb5f8e6b193f716efeae0d29de53e3b"><span class="ne-text">contextmenu主要控制应该合适显示上下文菜单，主要用于程序员取消默认的上下文菜单</span></li></ul><pre><code>document.addEventListener('contextmenu', function(e) &#123;    e.preventDefault();&#125;)</code></pre><h3 id="YIozD"><span class="ne-text">鼠标事件对象</span></h3><p id="4c842015ad6ac6e4f69e5e72c2cae205" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518361978-034f2af6-14fa-4ddb-bd8b-2eabe289eb59.png" width="703" id="GXMNi" class="ne-image"></p><h3 id="kM6Ej"><span class="ne-text">Demo：获取鼠标在页面的坐标</span></h3><pre><code>&lt;script&gt;  // 鼠标事件对象 MouseEvent  document.addEventListener('click', function(e) &#123;    console.log('client 鼠标在可视区的x和y坐标');    console.log(e.clientX);    console.log(e.clientY);    console.log('---------------------');    console.log('page 鼠标在页面文档的x和y坐标');    console.log(e.pageX);    console.log(e.pageY);    console.log('---------------------');    console.log('screen 鼠标在电脑屏幕的x和y坐标');    console.log(e.screenX);    console.log(e.screenY);  &#125;)&lt;/script&gt;</code></pre><h3 id="No1zU"><span class="ne-text">Demo：跟随鼠标的天使</span></h3><p id="e5107b269c65ccd796700aad3cc81a1e" class="ne-p"><br></p><pre><code>&lt;img src=&quot;images/angel.gif&quot; alt=&quot;&quot;&gt;    &lt;script&gt;        var pic = document.querySelector('img');        document.addEventListener('mousemove', function(e) &#123;            // 1. mousemove只要我们鼠标移动1px 就会触发这个事件            // 2.核心原理： 每次鼠标移动，我们都会获得最新的鼠标坐标，             // 把这个x和y坐标做为图片的top和left 值就可以移动图片            var x = e.pageX;            var y = e.pageY;            console.log('x坐标是' + x, 'y坐标是' + y);            //3 . 千万不要忘记给left 和top 添加px 单位            pic.style.left = x - 50 + 'px';            pic.style.top = y - 40 + 'px';        &#125;);    &lt;/script&gt;</code></pre><h3 id="cDws0"><span class="ne-text">mouseenter 和mouseover的区别</span></h3><ul class="ne-ul"><li id="88c115b01a2b6c236f234cf08ef5d7d4"><span class="ne-text">当鼠标移动到元素上时就会触发mouseenter 事件</span></li><li id="f8f15a01a6862e22ba659b724cfd8ce0"><span class="ne-text">类似 mouseover，它们两者之间的差别是</span></li><li id="773ac692fd2f9810e9ed2196af203c10"><span class="ne-text">mouseover 鼠标经过自身盒子会触发，经过子盒子还会触发。mouseenter  只会经过自身盒子触发</span></li><li id="9e4be62c339051eaa945e719c5ba2524"><span class="ne-text">之所以这样，就是因为mouseenter不会冒泡</span></li><li id="696b59f226bc1326eb53ca8b7fa62a5a"><span class="ne-text">跟mouseenter搭配鼠标离开 mouseleave  同样不会冒泡</span></li></ul><h2 id="ct83k"><span class="ne-text">常用键盘事件</span></h2><p id="326f5221d3d3f4d8a6981a19890f683d" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518362322-f21797ca-1e8e-4702-a243-4e76a8458b7e.png" width="701" id="vLAKo" class="ne-image"></p><ul class="ne-ul"><li id="bd4e3c484424ef8f908369b4086c14b5"><span class="ne-text">三个事件执行的顺序是：keydown-&gt;keypress-&gt;keyup</span></li></ul><pre><code>&lt;script&gt;        // 常用的键盘事件        //1. keyup 按键弹起的时候触发         document.addEventListener('keyup', function() &#123;            console.log('我弹起了');        &#125;)        //3. keypress 按键按下的时候触发  不能识别功能键 比如 ctrl shift 左右箭头啊        document.addEventListener('keypress', function() &#123;                console.log('我按下了press');        &#125;)        //2. keydown 按键按下的时候触发  能识别功能键 比如 ctrl shift 左右箭头啊        document.addEventListener('keydown', function() &#123;                console.log('我按下了down');        &#125;)        // 4. 三个事件的执行顺序  keydown -- keypress -- keyup    &lt;/script&gt;</code></pre><h3 id="Gb0Dv"><span class="ne-text">键盘事件对象</span></h3><p id="8945a6b3aa40369f48ed4e09c58901ba" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518362443-95c05d9c-6850-4cc3-a35e-c972b1723658.png" width="700" id="rFUEV" class="ne-image"></p><ul class="ne-ul"><li id="7d80cbe4fe5226cfa7abf4481adc48cd"><span class="ne-text">onkeydown和onkeyup不区分字母大小写，onkeypress区分字母大小写（使用更多的前面两个，能够识别所有键，包括功能键）</span></li><li id="f3ee963cc37dc5d79e3bd27018a9b9c6"><span class="ne-text">keypress不识别功能键，但是keyCode属性能够区分大小写，返回不同的ASCII值</span></li></ul><div class="ne-quote"><p id="cadf8aec7e3856d6ce4b3258b5538441" class="ne-p"><strong><span class="ne-text">使用keyCode属性判断用户按下哪个键</span></strong></p></div><pre><code>&lt;script&gt;        // 键盘事件对象中的keyCode属性可以得到相应键的ASCII码值        document.addEventListener('keyup', function(e) &#123;            console.log('up:' + e.keyCode);            // 我们可以利用keycode返回的ASCII码值来判断用户按下了那个键            if (e.keyCode === 65) &#123;                alert('您按下的a键');            &#125; else &#123;                alert('您没有按下a键')            &#125;        &#125;)        document.addEventListener('keypress', function(e) &#123;            // console.log(e);            console.log('press:' + e.keyCode);        &#125;)    &lt;/script&gt;</code></pre><h3 id="qworo"><span class="ne-text">Demo：模拟京东按键输入内容</span></h3><ul class="ne-ul"><li id="7565f06c60c84c01f09d86ad4c9c2972"><span class="ne-text">当我们按下 s 键， 光标就定位到搜索框（文本框获得焦点）。</span></li><li id="c3d8fb836327ccbbbae84a01cba915de"><span class="ne-text">注意：触发获得焦点事件，可以使用 元素对象.focus()</span></li></ul><p id="8c611ea4d1f59d20b33b39115f4fbe00" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616211826182-452dfe9b-0c03-4fe3-845c-afc16697e3ee.png" width="960" id="Zx9kR" class="ne-image"></p><h3 id="ZG4dd"><span class="ne-text">Demo：模拟京东快递单号查询</span></h3><p id="84fd26f435a94167f2954643790cdfe9" class="ne-p"><span class="ne-text">要求：当我们在文本框中输入内容时，文本框上面自动显示大字号的内容。</span></p><p id="9429f4798d18e4859b4475998d830317" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518362646-5b0c1da3-32dd-40b4-8b42-1bbb3065c01c.png" width="551" id="GMhtr" class="ne-image"></p><p id="ea68715abcd7776b25fa92976ecbb098" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518362734-9740cabb-bd4d-48ce-824d-001b5913b804.png" width="751" id="wAggT" class="ne-image"></p><pre><code>&lt;div class=&quot;search&quot;&gt;        &lt;div class=&quot;con&quot;&gt;123&lt;/div&gt;        &lt;input type=&quot;text&quot; placeholder=&quot;请输入您的快递单号&quot; class=&quot;jd&quot;&gt;    &lt;/div&gt;    &lt;script&gt;        // 获取要操作的元素        var con = document.querySelector('.con');        var jd_input = document.querySelector('.jd');        // 给输入框注册keyup事件        jd_input.addEventListener('keyup', function() &#123;                // 判断输入框内容是否为空                if (this.value == '') &#123;                    // 为空，隐藏放大提示盒子                    con.style.display = 'none';                &#125; else &#123;                    // 不为空，显示放大提示盒子，设置盒子的内容                    con.style.display = 'block';                    con.innerText = this.value;                &#125;            &#125;)        // 给输入框注册失去焦点事件，隐藏放大提示盒子        jd_input.addEventListener('blur', function() &#123;                con.style.display = 'none';            &#125;)        // 给输入框注册获得焦点事件        jd_input.addEventListener('focus', function() &#123;            // 判断输入框内容是否为空            if (this.value !== '') &#123;                // 不为空则显示提示盒子                con.style.display = 'block';            &#125;        &#125;)    &lt;/script&gt;</code></pre><p id="44e5295e1f2fa53a5af88709aa057e45" class="ne-p"><br></p><h2 id="P79Nv"><span class="ne-text">事件（高阶）</span></h2><h3 id="Rd1zx"><span class="ne-text">DOM事件流</span></h3><pre><code>html中的标签都是相互嵌套的，我们可以将元素想象成一个盒子装一个盒子，document是最外面的大盒子。当你单击一个div时，同时你也单击了div的父元素，甚至整个页面。那么是先执行父元素的单击事件，还是先执行div的单击事件 ？？？</code></pre><p id="c14f201d94d44c81abb8f2c3000bdd67" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518361114-2ab6ad14-e27a-4626-88bd-abbc2badfc0b.png" width="696" id="lErXc" class="ne-image"></p><div class="ne-quote"><p id="78868800be8bc613f36c3edb4b3a1dde" class="ne-p"><span class="ne-text">比如：我们给页面中的一个div注册了单击事件，当你单击了div时，也就单击了body，单击了html，单击了document。</span></p></div><p id="5d4b75ae4678e48d6af7075109db522e" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518361173-9a6bf5d3-a273-4294-b849-0ebaf79da603.png" width="268" id="GVG7z" class="ne-image"></p><p id="37d68242d49f8b52b1a9676369660126" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518361248-0ea0959b-c350-4780-9437-8561fe69f36d.png" width="751" id="EjVGr" class="ne-image"></p><pre><code>当时的2大浏览器霸主谁也不服谁！IE 提出从目标元素开始，然后一层一层向外接收事件并响应，也就是冒泡型事件流。Netscape（网景公司）提出从最外层开始，然后一层一层向内接收事件并响应，也就是捕获型事件流。江湖纷争，武林盟主也脑壳疼！！！最终，w3c 采用折中的方式，平息了战火，制定了统一的标准 —--— 先捕获再冒泡。现代浏览器都遵循了此标准，所以当事件发生时，会经历3个阶段。</code></pre><p id="f556229822e9ba88ea4d1e2850397e9d" class="ne-p"><span class="ne-text">DOM 事件流会经历3个阶段：</span></p><ol class="ne-ol"><li id="12de94fb204e535c5f84f321af9a2479"><span class="ne-text">捕获阶段</span></li><li id="a84b5336e39d35584955ba8353f5e62c"><span class="ne-text">当前目标阶段</span></li><li id="6fadf0984110fb347a97a8f370d60813"><span class="ne-text">冒泡阶段</span></li></ol><p id="f5859b14e6dc68e0781c994a5ca99f01" class="ne-p"><span class="ne-text">    我们向水里面扔一块石头，首先它会有一个下降的过程，这个过程就可以理解为从最顶层向事件发生的最具体元素（目标点）的捕获过程；之后会产生泡泡，会在最低点（ 最具体元素）之后漂浮到水面上，这个过程相当于事件冒泡。</span></p><p id="98adf75e5ed2e0490abafd540d7c00e1" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518361302-fa0b37f5-a8ec-4898-82b6-e136cd291951.png" width="498" id="pnFlw" class="ne-image"></p><p id="efd402678c9324978a2ea7a626841bff" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518361362-b8b1f065-da6a-40c5-8782-b265699cdd49.png" width="757" id="BMWF3" class="ne-image"></p><p id="fa8756cfd13405402d6ac6e0570e8f84" class="ne-p"><strong><span class="ne-text">事件冒泡</span></strong></p><pre><code>&lt;div class=&quot;father&quot;&gt;        &lt;div class=&quot;son&quot;&gt;son盒子&lt;/div&gt;    &lt;/div&gt;    &lt;script&gt;        // onclick 和 attachEvent（ie） 在冒泡阶段触发        // 冒泡阶段 如果addEventListener 第三个参数是 false 或者 省略         // son -&gt; father -&gt;body -&gt; html -&gt; document        var son = document.querySelector('.son');        // 给son注册单击事件        son.addEventListener('click', function() &#123;            alert('son');        &#125;, false);        // 给father注册单击事件        var father = document.querySelector('.father');        father.addEventListener('click', function() &#123;            alert('father');        &#125;, false);        // 给document注册单击事件，省略第3个参数        document.addEventListener('click', function() &#123;            alert('document');        &#125;)    &lt;/script&gt;</code></pre><p id="b7914d45fc380407e7f6dfae0f319192" class="ne-p"><strong><span class="ne-text">事件捕获</span></strong></p><pre><code>&lt;div class=&quot;father&quot;&gt;        &lt;div class=&quot;son&quot;&gt;son盒子&lt;/div&gt;    &lt;/div&gt;    &lt;script&gt;        // 如果addEventListener() 第三个参数是 true 那么在捕获阶段触发        // document -&gt; html -&gt; body -&gt; father -&gt; son         var son = document.querySelector('.son');        // 给son注册单击事件，第3个参数为true         son.addEventListener('click', function() &#123;             alert('son');         &#125;, true);         var father = document.querySelector('.father');        // 给father注册单击事件，第3个参数为true         father.addEventListener('click', function() &#123;             alert('father');         &#125;, true);        // 给document注册单击事件，第3个参数为true        document.addEventListener('click', function() &#123;            alert('document');        &#125;, true)    &lt;/script&gt;</code></pre><h3 id="uscVy"><span class="ne-text">事件对象</span></h3><h4 id="lh6g5"><span class="ne-text">什么是事件对象</span></h4><p id="54b33c7d311826ffec4520d2734a16d0" class="ne-p"><span class="ne-text">事件发生后，跟事件相关的一系列信息数据的集合都放到这个对象里面，这个对象就是事件对象。</span></p><p id="04803a183bddb874739ed06a3f25dc7b" class="ne-p"><span class="ne-text">比如：</span></p><ol class="ne-ol"><li id="e83b68cae6c31114de58901c5fe78d12"><span class="ne-text">谁绑定了这个事件。</span></li><li id="d8251054a60591581beece42e0f44464"><span class="ne-text">鼠标触发事件的话，会得到鼠标的相关信息，如鼠标位置。</span></li><li id="87d5ad226aa335770e51d4b3bef54267"><span class="ne-text">键盘触发事件的话，会得到键盘的相关信息，如按了哪个键。</span></li></ol><h4 id="YD8EB"><span class="ne-text">事件对象的使用</span></h4><p id="fdbd2d9f46988811915af195be4083ee" class="ne-p"><span class="ne-text">事件触发发生时就会产生事件对象，并且系统会以实参的形式传给事件处理函数。</span></p><p id="ee813f86056fc9f048d9aef2064de077" class="ne-p"><span class="ne-text">所以，在事件处理函数中声明1个形参用来接收事件对象。</span></p><p id="6bfa54243984b387569aceda77c3cb0a" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518361420-28ca3202-57b2-48ab-83cb-620191320123.png" width="681" id="yTBu7" class="ne-image"></p><h4 id="MfnbO"><span class="ne-text">事件对象的兼容性处理</span></h4><p id="9761c13e5f19594c776f0c7edfb9a87c" class="ne-p"><span class="ne-text">事件对象本身的获取存在兼容问题：</span></p><ol class="ne-ol"><li id="081e0ad76de02446ef57aff577d7244a"><span class="ne-text">标准浏览器中是浏览器给方法传递的参数，只需要定义形参 e 就可以获取到。</span></li><li id="b61f1d8104467023001dfc0ef676be65"><span class="ne-text">在 IE6~8 中，浏览器不会给方法传递参数，如果需要的话，需要到 window.event 中获取查找。</span></li></ol><p id="caa7a88343b34d34f785c9d7f093d9f7" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518361484-fb99b58d-4733-4716-b625-a14e1cd02938.png" width="660" id="AKYdD" class="ne-image"></p><pre><code>只要“||”前面为false, 不管“||”后面是true 还是 false，都返回 “||” 后面的值。只要“||”前面为true, 不管“||”后面是true 还是 false，都返回 “||” 前面的值。</code></pre><pre><code>&lt;div&gt;123&lt;/div&gt;    &lt;script&gt;        var div = document.querySelector('div');        div.onclick = function(e) &#123;                // 事件对象                e = e || window.event;                console.log(e);        &#125;    &lt;/script&gt;</code></pre><h4 id="v3WbX"><span class="ne-text">事件对象的属性和方法</span></h4><p id="c04df420165c82c6e3649132e76633bd" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518361541-14665361-d721-4083-8cb2-d2088c6dc0cc.png" width="698" id="xkt42" class="ne-image"></p><h4 id="XwqEo"><span class="ne-text">e.target 和 this 的区别</span></h4><ul class="ne-ul"><li id="255fb1cb53b39afbcb0dfdfe62a7354c"><span class="ne-text">this 是事件绑定的元素（绑定这个事件处理函数的元素） 。</span></li><li id="0eefb6af1c1df629f64df9faa64e79f6"><span class="ne-text">e.target 是事件触发的元素。</span></li></ul><pre><code>常情况下terget 和 this是一致的，但有一种情况不同，那就是在事件冒泡时（父子元素有相同事件，单击子元素，父元素的事件处理函数也会被触发执行），    这时候this指向的是父元素，因为它是绑定事件的元素对象，    而target指向的是子元素，因为他是触发事件的那个具体元素对象。</code></pre><pre><code>&lt;div&gt;123&lt;/div&gt;    &lt;script&gt;        var div = document.querySelector('div');        div.addEventListener('click', function(e) &#123;            // e.target 和 this指向的都是div            console.log(e.target);            console.log(this);        &#125;);    &lt;/script&gt;</code></pre><p id="7b5afcc4c8774f913e33749bc991a729" class="ne-p"><span class="ne-text">事件冒泡下的e.target和this</span></p><pre><code>&lt;ul&gt;        &lt;li&gt;abc&lt;/li&gt;        &lt;li&gt;abc&lt;/li&gt;        &lt;li&gt;abc&lt;/li&gt;    &lt;/ul&gt;    &lt;script&gt;        var ul = document.querySelector('ul');        ul.addEventListener('click', function(e) &#123;              // 我们给ul 绑定了事件  那么this 就指向ul                console.log(this); // ul              // e.target 触发了事件的对象 我们点击的是li e.target 指向的就是li              console.log(e.target); // li        &#125;);    &lt;/script&gt;</code></pre><h3 id="cyiXy"><span class="ne-text">阻止默认行为</span></h3><div class="ne-quote"><p id="854c1e3cd2ac3599dc97c6c7e7826ac9" class="ne-p"><span class="ne-text">html中一些标签有默认行为，例如a标签被单击后，默认会进行页面跳转。</span></p></div><pre><code>&lt;a href=&quot;http://www.baidu.com&quot;&gt;百度&lt;/a&gt;    &lt;script&gt;        // 2. 阻止默认行为 让链接不跳转         var a = document.querySelector('a');        a.addEventListener('click', function(e) &#123;             e.preventDefault(); //  dom 标准写法        &#125;);        // 3. 传统的注册方式        a.onclick = function(e) &#123;            // 普通浏览器 e.preventDefault();  方法            e.preventDefault();            // 低版本浏览器 ie678  returnValue  属性            e.returnValue = false;            // 我们可以利用return false 也能阻止默认行为 没有兼容性问题            return false;        &#125;    &lt;/script&gt;</code></pre><h3 id="EzK38"><span class="ne-text">阻止事件冒泡</span></h3><p id="fbc94145f6de007c1d2edc039decc605" class="ne-p"><span class="ne-text">事件冒泡本身的特性，会带来的坏处，也会带来的好处。</span></p><p id="58c12cf373e0565c0759fea7ff3ef9a2" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518361625-d482ad01-1332-4d91-b951-664b337c86f3.png" width="667" id="UdMeX" class="ne-image"></p><pre><code>&lt;div class=&quot;father&quot;&gt;        &lt;div class=&quot;son&quot;&gt;son儿子&lt;/div&gt;    &lt;/div&gt;    &lt;script&gt;        var son = document.querySelector('.son');        // 给son注册单击事件        son.addEventListener('click', function(e) &#123;            alert('son');            e.stopPropagation(); // stop 停止  Propagation 传播            window.event.cancelBubble = true; // 非标准 cancel 取消 bubble 泡泡        &#125;, false);        var father = document.querySelector('.father');        // 给father注册单击事件        father.addEventListener('click', function() &#123;            alert('father');        &#125;, false);        // 给document注册单击事件        document.addEventListener('click', function() &#123;            alert('document');        &#125;)    &lt;/script&gt;</code></pre><p id="3b98a675e82a8647f534b60d88d4aa26" class="ne-p"><strong><span class="ne-text">阻止事件冒泡的兼容性处理</span></strong></p><p id="14666baa432bef3397a3db8126ff71a5" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518361680-f20195f2-69b6-4d72-a6d5-6a5d08646b73.png" width="685" id="Ts107" class="ne-image"></p><h3 id="imMYA"><span class="ne-text">事件委托</span></h3><p id="e7c48210ad41e1d44e7a2e556b53463b" class="ne-p"><span class="ne-text">事件冒泡本身的特性，会带来的坏处，也会带来的好处。</span></p><h4 id="8IDAK"><span class="ne-text">什么是事件委托</span></h4><pre><code>把事情委托给别人，代为处理。</code></pre><p id="4fa8f0acc6d4268beeb196dbc27fff66" class="ne-p"><span class="ne-text">事件委托也称为事件代理，在 jQuery 里面称为事件委派。</span></p><div class="ne-quote"><p id="faf13b4a845244b53c7160acfc1914c9" class="ne-p"><span class="ne-text">说白了就是，不给子元素注册事件，给父元素注册事件，把处理代码在父元素的事件中执行。</span></p></div><p id="d4f77f6cf7cb9a7fb89c1b075582970c" class="ne-p"><strong><span class="ne-text">生活中的代理：</span></strong></p><p id="e4654954748ae19eecb4a109b529d50b" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518361736-9861e13e-f31a-4425-b062-883b21374fce.png" width="689" id="Pr1hq" class="ne-image"></p><p id="196dd6988d488b7c8b788af95edeb655" class="ne-p"><strong><span class="ne-text">js事件中的代理：</span></strong></p><p id="9cce8ee5a723fde233923710d585fd31" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518361805-81024b8b-f5e4-488a-91fa-d8ffa16d04fa.png" width="698" id="bFULB" class="ne-image"></p><h4 id="r9vbn"><span class="ne-text">事件委托的原理</span></h4><p id="229515cbd20f9d988912c01d1a7f9f59" class="ne-p"><span class="ne-text">    给父元素注册事件，利用事件冒泡，当子元素的事件触发，会冒泡到父元素，然后去控制相应的子元素。</span></p><h4 id="m9u6H"><span class="ne-text">事件委托的作用</span></h4><ul class="ne-ul"><li id="d3be9d93cb120dca88eb33e7c306e918"><span class="ne-text">我们只操作了一次 DOM ，提高了程序的性能。</span></li><li id="0600d3d420712c5a7ef129876158ca7f"><span class="ne-text">动态新创建的子元素，也拥有事件。</span></li></ul><pre><code>&lt;ul&gt;        &lt;li&gt;知否知否，点我应有弹框在手！&lt;/li&gt;        &lt;li&gt;知否知否，点我应有弹框在手！&lt;/li&gt;        &lt;li&gt;知否知否，点我应有弹框在手！&lt;/li&gt;        &lt;li&gt;知否知否，点我应有弹框在手！&lt;/li&gt;        &lt;li&gt;知否知否，点我应有弹框在手！&lt;/li&gt;    &lt;/ul&gt;    &lt;script&gt;        // 事件委托的核心原理：给父节点添加侦听器， 利用事件冒泡影响每一个子节点        var ul = document.querySelector('ul');        ul.addEventListener('click', function(e) &#123;            // e.target 这个可以得到我们点击的对象            e.target.style.backgroundColor = 'pink';        &#125;)    &lt;/script&gt;</code></pre></div>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
          <category> JavaScript </category>
          
          <category> DOM </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript面向对象体系及对象内置属性和方法</title>
      <link href="/blog/zfpg9dfgehog/"/>
      <url>/blog/zfpg9dfgehog/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="u9f2794ef" class="ne-p" style="text-indent: 2em"><span class="ne-text">前言：JavaScript首先在ES6没有出来之前，利用一个叫原型的一系列机制来用一段很长的代码来实现类的继承，说白了就是在函数里面默认给你加个一个叫原型的对象属性，再利用一系列指向来完成继承。在ES6之后，才有了形式上的类class及其对象，以及一个单词extends就搞定的继承，虽说搞定，但这里面的机制还是原型相关知识，记录学习一下。</span></p><p id="udc8e4c2c" class="ne-p" style="text-indent: 2em"><span class="ne-text">不管是原型也好，新加的class也罢，就一个目的——为了实现面向对象。从两个体系来展开详述。</span></p><h2 id="yj3wW"><span class="ne-text">体系一：原型+原型链</span></h2><ul class="ne-ul"><li id="u3d362539"><span class="ne-text">讲解的很透彻：</span><a href="https://www.bilibili.com/video/BV1Q64y1v7fW" data-href="https://www.bilibili.com/video/BV1Q64y1v7fW" target="_blank" class="ne-link"><span class="ne-text">https://www.bilibili.com/video/BV1Q64y1v7fW</span></a></li></ul><h3 id="LnxeQ"><span class="ne-text">隐式原型__proto__</span></h3><p id="ud0a1f80e" class="ne-p"><span class="ne-text" style="text-decoration: underline">每个对象里面都有__proto__属性</span><span class="ne-text">，这个叫对象原型，这个玩意指向</span><strong><span class="ne-text">构造函数的prototype对象</span></strong></p><div class="ne-quote"><p id="u5184b156" class="ne-p"><span class="ne-text">__proto__对象原型的意义就在于为对象的查找机制提供一个方向，或者说一条路线，但是它是一个非标准属性，因此实际开发中，不可以使用这个属性，它只是内部指向原型对象 prototype</span></p></div><p id="u9a75c883" class="ne-p"><span class="ne-text">比如说，有一个Person类，有一个Student类，Student类继承自Person类，Student有一个实例student_1，那么student_1会有__proto__对象属性，并且展开该__proto__，会发现里面是Person类的方法和属性</span></p><h3 id="CLRny"><span class="ne-text">显式原型prototype</span></h3><p id="7c59d55d4430a46b8ffc2c7b51f1e256" class="ne-p"><span class="ne-text" style="text-decoration: underline">每个构造函数里面都有一个属性，这个属性叫prototype，</span><strong><span class="ne-text" style="text-decoration: underline">指向另一个对象</span></strong><span class="ne-text" style="text-decoration: underline">（</span><span class="ne-text">有什么用？在后面原型链就会发现有用了），并且这个属性是一个对象，叫做构造函数原型</span></p><div class="ne-quote"><p id="66d8017956949710921f46829a08c3d8" class="ne-p"><span class="ne-text">这样可以解决一个问题，就是创建不同实例，这些事例所用的方法都是同一个内存下的方法，实现共享</span></p></div><h3 id="w9Uhl"><span class="ne-text">constructor构造函数</span></h3><ol class="ne-ol"><li id="fccf204ee8c9f63131ce572e4bd9135c"><span class="ne-text">对象原型（ __proto__）和构造函数（prototype）原型对象里面都有一个属性 constructor 属性 ，constructor 我们称为构造函数，因为它</span><strong><span class="ne-text" style="text-decoration: underline">指回构造函数本身</span></strong><span class="ne-text">。</span></li><li id="43bf14b0a19dae4f626eb4be000d8fce"><span class="ne-text">constructor 主要用于记录该对象引用于哪个构造函数，它可以让原型对象重新指向原来的构造函数。</span></li><li id="052026097e14bd2660b57547591740ee"><span class="ne-text">一般情况下，对象的方法都在构造函数的原型对象中设置。如果有多个对象的方法，我们可以给原型对象采取对象形式赋值，但是这样就会覆盖构造函数原型对象原来的内容，这样修改后的原型对象 constructor  就不再指向当前构造函数了。此时，我们可以在修改后的原型对象中，添加一个 constructor 指向原来的构造函数。</span></li></ol><h3 id="zGyP9"><span class="ne-text">instanceof</span></h3><p id="ucbd81d9b" class="ne-p"><span class="ne-text">a instanceof b</span></p><p id="uff532746" class="ne-p"><span class="ne-text">判断是true还是false</span></p><p id="ub45967b4" class="ne-p"><span class="ne-text">看a的constructor是什么</span></p><p id="uea8ad4ec" class="ne-p"><span class="ne-text">当b为   a的constructor或a的__proto__的constructor……</span></p><p id="u574656e6" class="ne-p"><span class="ne-text">结果都是true</span></p><h3 id="y8vLN"><span class="ne-text">原型链和成员查找机制</span></h3><p id="u5702aa15" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1651672328368-25e71aa6-4015-4469-9a67-5d841645aebe.png" width="1268.333282934297" id="ue6601372" class="ne-image"></p><p id="4598fd72a5cc5f9d913bdf73126385d4" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1622632967349-b2adf38c-b51f-445b-b4c8-7d0408e96390.png" width="501" id="B3Eo8" class="ne-image"></p><h3 id="V8jhV"><span class="ne-text">原型体系中的继承</span></h3><p id="512dd492c06f7b4ac69269f1b091b237" class="ne-p"><span class="ne-text">call方法可以改变一个函数的指向</span></p><ol class="ne-ol"><li id="344c83abd47ab0a088a47b2c6337455d"><span class="ne-text">继承父构造函数里面的属性</span></li></ol><pre><code>// 1. 父构造函数 function Father(uname, age) &#123;   // this 指向父构造函数的对象实例   this.uname = uname;   this.age = age; &#125;  // 2 .子构造函数 function Son(uname, age, score) &#123;  // this 指向子构造函数的对象实例  // 3.使用call方式实现子继承父的属性  Father.call(this, uname, age);  this.score = score;&#125;var son = new Son('刘德华', 18, 100);console.log(son);</code></pre><ol start="2" class="ne-ol"><li id="a3855cf3ab3a5f5c35c51d1dd654cb4f"><span class="ne-text">继承方法</span></li></ol><pre><code>// 1. 父构造函数function Father(uname, age) &#123;  // this 指向父构造函数的对象实例  this.uname = uname;  this.age = age;&#125;Father.prototype.money = function() &#123;  console.log(100000); &#125;; // 2 .子构造函数   function Son(uname, age, score) &#123;      // this 指向子构造函数的对象实例      Father.call(this, uname, age);      this.score = score;  &#125;// Son.prototype = Father.prototype;  这样直接赋值会有问题,如果修改了子原型对象,父原型对象也会跟着一起变化  Son.prototype = new Father();  // 如果利用对象的形式修改了原型对象,别忘了利用constructor 指回原来的构造函数  Son.prototype.constructor = Son;  // 这个是子构造函数专门的方法  Son.prototype.exam = function() &#123;    console.log('孩子要考试');  &#125;  var son = new Son('刘德华', 18, 100);  console.log(son);</code></pre><h2 id="2AkCh"><span class="ne-text">体系二：类(class)【ES6】</span></h2><p id="cad140a8200f42428c7a238d32d88835" class="ne-p"><span class="ne-text">在 ES6 中新增加了类的概念，可以使用 class 关键字声明一个类，之后以这个类来实例化对象。类抽象了对象的公共部分，它泛指某一大类（class）对象特指某一个，通过类实例化一个具体的对象。其创建的方式和之前学过的语言很类似。</span></p><p id="u12d357f4" class="ne-p"><span class="ne-text"></span></p><p id="u0a5bbe48" class="ne-p"><span class="ne-text">在 ES6 中类没有变量或是函数提升概念，所以必须先定义类，才能通过类实例化对象，这也是类和函数最大的不同。</span></p><h3 id="cMF3s"><span class="ne-text">原型方法和原型字段声明</span></h3><p id="u87ac43e1" class="ne-p"><span class="ne-text">原型方法：</span></p><ol class="ne-ol"><li id="uba4c9294"><span class="ne-text">构造函数方法</span></li><li id="uc9b3df1c"><span class="ne-text">get set</span></li><li id="u04200080"><span class="ne-text">静态方法：通常作为类的工具函数</span></li><li id="u7247d342"><span class="ne-text">普通方法</span></li></ol><p id="uc6eb4120" class="ne-p"><br></p><p id="u29912692" class="ne-p"><span class="ne-text">原型字段：</span></p><ol class="ne-ol"><li id="u3bfea643"><span class="ne-text">私有字段</span></li><li id="u55109b6c"><span class="ne-text">公有字段</span></li></ol><pre><code>class Tooltip &#123;  #test1 = 111; // 私有成员  test2 = 222; // 公有成员  static test3 = 333; // 静态成员（类内部不能访问 相当于类的属性）  static fun1(a, b) &#123;    // 静态方法（类内部不能访问 相当于类的属性）    return a + b;  &#125;  constructor() &#123;    console.log('private member test1: ', ++this.#test1);    console.log('public member test2: ', ++this.test2);    console.log('origin class: ', this);  &#125;&#125;<p>class TextTooltip extends Tooltip &#123;<br>  constructor(quill, options) &#123;<br>    super(quill, options.bounds);<br>  &#125;<br>&#125;</p><p>this.textToolTip = new TextTooltip(quill, options);<br>console.log(this.textToolTip,<br>            Tooltip.test3,<br>            TextTooltip.test3,<br>            TextTooltip.fun1(333, 333));</p><p>export default TextTooltipToolbar;</p><p></code></pre></p><h3 id="EQmnS"><span class="ne-text">继承</span></h3><pre><code>// 奥特曼类class Aoteman &#123;    // 构造函数里面放共有属性、方法    constructor(name, age) &#123;        this.name = name;        this.age = age;    &#125;    Ability(abi) &#123;        console.log(this.name + &quot; can &quot; + abi);    &#125;&#125;<p>// 假 继承 奥特曼<br>class Jia extends Aoteman &#123;<br>    constructor (x, y) &#123;<br>        // 继承父类的构造函数<br>        super(x,y);<br>        // 方便写自己的函数<br>        this.x = x;<br>        this.y = y;<br>    &#125;<br>    // 自己内部的函数<br>    Chuiniu() &#123;<br>        console.log(this.x + &quot; chuiniu&quot;);<br>    &#125;</p><p>&#125;</p><p>// 创建迪迦对象<br>let dijia = new Aoteman(‘dijia’, 100);<br>console.log(dijia);<br>dijia.Ability(&quot;X-ray&quot;);<br>let dijia_jia = new Jia(&quot;dijia_jia&quot;, 50);<br>dijia_jia.Ability(&quot;xxx&quot;);<br>dijia_jia.Chuiniu();<br></code></pre></p><p id="cb14a18ef0b052581ff2c955bf1a0ffc" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1622622728600-59f47873-c895-4686-b771-f1f538198f26.png" width="441" id="JN882" class="ne-image"></p><h3 id="UyaIK"><span class="ne-text">多重继承</span></h3><p id="u3310e98b" class="ne-p"><span class="ne-text">JavaScript对象的继承只能继承一个父类，因为继承的根本实现是基于原型链的，所以继承不能同时指向多个对象，所以实现多重继承有两个思路：</span></p><ol class="ne-ol"><li id="u52a6832e"><span class="ne-text">父类链式继承</span></li></ol><pre><code>class Parent1 extends Parent2 &#123;&#125;class Parent2 extends Parent3 &#123;&#125;class Child extends Parent1 &#123;&#125;</code></pre><ol start="2" class="ne-ol"><li id="ube418643"><span class="ne-text">实现Mixin来继承</span></li></ol><pre><code>function mixin(...mixins) &#123;  class Mixin &#123;    constructor(...args) &#123;      mixins.forEach(        mixin =&gt; copyProperties(this, new mixin(...args)) // 拷贝实例属性      )     &#125;  &#125;  mixins.forEach(    mixin =&gt; &#123;      copyProperties(Mixin, mixin); // 拷贝静态属性      copyProperties(Mixin.prototype, mixin.prototype); // 拷贝原型属性    &#125;  )<p>  return Mixin;<br>&#125;</p><p>function copyProperties(target, source) &#123;<br>  for (let key of Reflect.ownKeys(source)) &#123;<br>    if ([‘constructor’, ‘prototype’, ‘name’].indexOf(key) &lt; 0) &#123;<br>      let desc = Object.getOwnPropertyDescriptor(source, key);<br>      Object.defineProperty(target, key, desc);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></p><pre><code>class Child extends mixin(Parent1, Parent2, Parent3) &#123;&#125;</code></pre><h2 id="Pieyx"><span class="ne-text">对象的各种创建方式</span></h2><h3 id="zit4E"><span class="ne-text">字面量</span></h3><p id="083a4934aac2b8be69b10cc6f6d4f323" class="ne-p"><span class="ne-text">属性和方法的调用：</span></p><p id="36235a6d55d24a73c9da43f5eef64605" class="ne-p"><span class="ne-text">属性可以用&quot;.&quot;和[&quot;属性名&quot;]来调用</span></p><p id="60c09abb79feb2bc609b8822c6ece536" class="ne-p"><span class="ne-text">方法用&quot;.&quot;来调用</span></p><h3 id="qieAE"><span class="ne-text">模式工厂</span></h3><p id="12f03a76db50bccfcb65ebd419d35599" class="ne-p"><span class="ne-text">new一个空对象，</span><code class="ne-code"><span class="ne-text">let obj = new Object();</span></code></p><p id="76e77acf462c0d5fc6711fe41458c5b8" class="ne-p"><span class="ne-text">然后利用&quot;.&quot;的方式给其添加属性和方法</span></p><p id="9a7c3df6d0ab8823ad10b9d56da71806" class="ne-p"><span class="ne-text">内置的Object()构造函数</span></p><p id="c1e35870ec274c5a60120cec9b6a71c8" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1622623002064-1297005b-76a6-4d94-9b12-a83cf709e3a1.png" width="529.5" id="hDM2I" class="ne-image"></p><h3 id="6Kx17"><span class="ne-text">构造函数</span></h3><div class="ne-quote"><p id="4bb010f534c4432e61c5acfc8ed7f78d" class="ne-p"><span class="ne-text">构造函数：是一种特殊的函数，主要用来初始化对象，即为对象成员变量赋初始值，它总与 new 运算符一起使用。我们可以把对象中一些公共的属性和方法抽取出来，然后封装到这个函数里面。</span></p></div><pre><code>function 构造函数名(形参1,形参2,形参3) &#123;     this.属性名1 = 参数1;     this.属性名2 = 参数2;     this.属性名3 = 参数3;     this.方法名 = 函数体;&#125;<p>let obj = new 构造函数名(实参1，实参2，实参3)<br></code></pre></p><p id="4c6617820231460b3d1a5ba0052650cc" class="ne-p"><br></p><ul class="ne-ul"><li id="42ddfc91739b54f0db3ad2360bfa2a11"><span class="ne-text">构造函数约定</span><strong><span class="ne-text">首字母大写</span></strong><span class="ne-text">。</span></li><li id="107ab55d6bdb5fc8852a8ba09058c242"><span class="ne-text">函数内的属性和方法前面需要添加 </span><strong><span class="ne-text">this</span></strong><span class="ne-text"> ，表示当前对象的属性和方法。</span></li><li id="a40659a6a97972cbe2892ca3ba220606"><span class="ne-text">构造函数中</span><strong><span class="ne-text">不需要 return 返回结果</span></strong><span class="ne-text">。</span></li><li id="d5ada7fd51b068d3faab947354a6172c"><span class="ne-text">当我们创建对象的时候，</span><strong><span class="ne-text">必须用 new 来调用构造函数</span></strong><span class="ne-text">。</span></li></ul><h3 id="1QZhm"><span class="ne-text">原型模式</span></h3><p id="70c37cafa4ed06b8de783a9a800765ed" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1622623181327-bd4b5d09-8525-4c59-b550-9af381526f23.png" width="529.5" id="qBvgN" class="ne-image"></p><p id="cab84c8c6b9a31635a96b6562e393404" class="ne-p"><span class="ne-text">下面详述什么是原型</span></p><h2 id="sxsBG"><span class="ne-text">对象的内置方法</span></h2><p id="u0e9e74a8" class="ne-p"><span class="ne-text">参考教程：</span></p><ul class="ne-ul"><li id="uc70efeef"><a href="https://zh.javascript.info/object-basics" data-href="https://zh.javascript.info/object-basics" target="_blank" class="ne-link"><span class="ne-text">https://zh.javascript.info/object-basics</span></a></li></ul><h3 id="7WtOk"><span class="ne-text">Object.defineProperty</span></h3><p id="e403193d89184c9e7039f12f52d5c627" class="ne-p"><span class="ne-text">Object.defineProperty设置或修改对象中的属性</span></p><pre><code>Object.defineProperty(对象，修改或新增的属性名，&#123;        value:修改或新增的属性的值,        writable:true/false,//如果值为false 不允许修改这个属性值        enumerable: false,//enumerable 如果值为false 则不允许遍历    configurable: false  //configurable 如果为false 则不允许删除这个属性 属性是否可以被删除或是否可以再次修改特性&#125;)</code></pre><h3 id="lQpR4"><span class="ne-text">删除对象属性</span></h3><ul class="ne-ul"><li id="ue8b0d3cd"><span class="ne-text">直接用delete，暴力简单</span></li><li id="uc28fcad7"><span class="ne-text">也可以参考：</span><a href="https://segmentfault.com/q/1010000013891861" data-href="https://segmentfault.com/q/1010000013891861" target="_blank" class="ne-link"><span class="ne-text">如何优雅的删除对象中的指定属性？</span></a></li></ul><h3 id="Aliaq"><span class="ne-text">assign()</span></h3><ul class="ne-ul"><li id="u4c6a6bde"><span class="ne-text">Object.assign后者覆盖前者，再返回前者</span></li><li id="u33bd510a"><span class="ne-text">常用于深拷贝浅拷贝数据</span></li></ul><h2 id="vJuVU"><span class="ne-text">对象的遍历</span></h2><h3 id="yyCtR"><span class="ne-text">for...in </span></h3><div data-type="info" class="ne-alert"><p id="u49da1b9d" class="ne-p"><span class="ne-text" style="background-color: #E8F7FF">语句用于对数组或者对象的属性进行循环操作。</span></p></div><p id="uc155870c" class="ne-p"><span class="ne-text">其语法如下：</span></p><pre><code>for (变量 in 对象名字) &#123;    // 在此执行代码&#125;</code></pre><ul class="ne-ul"><li id="ud155867e"><span class="ne-text">语法中的变量是自定义的，它需要符合命名规范，通常我们会将这个变量写为 k 或者 key。书里面建议用const来加持。</span></li></ul><pre><code>for (let k in obj) &#123;    console.log(k);      // 这里的 k 是属性名    console.log(obj[k]); // 这里的 obj[k] 是属性值&#125;</code></pre><h3 id="Thzwk"><span class="ne-text">Object.keys(obj)</span></h3><div data-type="info" class="ne-alert"><p id="u1ab14861" class="ne-p"><span class="ne-text" style="background-color: #E8F7FF">获取属性名</span></p></div><pre><code>var obj = &#123;     id: 1,     pname: '小米',     price: 1999,     num: 2000&#125;;var result = Object.keys(obj)console.log(result)//[id，pname,price,num]</code></pre><h2 id="qrXFP"><span class="ne-text">参考</span></h2><ul class="ne-ul"><li id="u63206bdc"><a href="https://github.com/yinguangyao/blog" data-href="https://github.com/yinguangyao/blog" class="ne-link"><span class="ne-text">https://github.com/yinguangyao/blog</span></a></li></ul></div>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
          <category> JavaScript </category>
          
          <category> ECMAScript </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>jQuery事件+插件</title>
      <link href="/blog/3_day03_jquery/"/>
      <url>/blog/3_day03_jquery/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h2 id="6nKXU"><span class="ne-text">jQuery 事件注册</span></h2><p id="1e079f7fc93138d41c83e6307322c395" class="ne-p"><span class="ne-text">jQuery 为我们提供了方便的事件注册机制，是开发人员抑郁操作优缺点如下：</span></p><ul class="ne-ul"><li id="c808388301fd63bad9c767da948c322e"><span class="ne-text">优点: 操作简单，且不用担心事件覆盖等问题。</span></li><li id="bbabe8c7d4fe4c8da0d39350a99614c6"><span class="ne-text">缺点: 普通的事件注册不能做事件委托，且无法实现事件解绑，需要借助其他方法。</span></li></ul><p id="1864e480f8d3149886b1a2fd5e7313d8" class="ne-p"><strong><span class="ne-text">语法</span></strong></p><p id="ef9109cb2e57e3ef815add54e5b29f5b" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616073493434-c3ba216b-4d64-4229-b788-30947c24ab77.png" width="620" id="fMqr8" class="ne-image"></p><p id="edd9c3d61ded33e7aa40fe0899623f7e" class="ne-p"><strong><span class="ne-text">演示代码</span></strong></p><pre><code>&lt;body&gt;    &lt;div&gt;&lt;/div&gt;    &lt;script&gt;        $(function() &#123;            // 1. 单个事件注册            $(&quot;div&quot;).click(function() &#123;                $(this).css(&quot;background&quot;, &quot;purple&quot;);            &#125;);            $(&quot;div&quot;).mouseenter(function() &#123;                $(this).css(&quot;background&quot;, &quot;skyblue&quot;);            &#125;);        &#125;)    &lt;/script&gt;&lt;/body&gt;</code></pre><h2 id="epxS2"><span class="ne-text">jQuery 事件处理</span></h2><p id="f54334778311efa0f4e4d14ad229f9e1" class="ne-p"><span class="ne-text">因为普通注册事件方法的不足，jQuery又开发了多个处理方法，重点讲解如下：</span></p><ul class="ne-ul"><li id="34055378e712e493b6d4161b573a3301"><span class="ne-text">on(): 用于事件绑定，目前最好用的事件绑定方法</span></li><li id="ea25e2366c24c0d05647b2495c51c58c"><span class="ne-text">off(): 事件解绑</span></li></ul><ul class="ne-ul"><li id="3830ab27a86e1c0bb3526650198a5818"><span class="ne-text">trigger() / triggerHandler(): 事件触发</span></li></ul><h3 id="0uqBm"><span class="ne-text">1.2.1 事件处理 on() 绑定事件</span></h3><p id="62799bd1a890cfa043aa589978cb7501" class="ne-p"><span class="ne-text">    因为普通注册事件方法的不足，jQuery又创建了多个新的事件绑定方法bind() / live() / delegate() / on()等，其中最好用的是: on()</span></p><p id="25d79611f4bd96e0bf439cba3f7b1e6b" class="ne-p"><strong><span class="ne-text">语法</span></strong></p><p id="84ebca37ae4dea24c1bf49f572a9ed85" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616073493540-3a234b93-0493-427d-9113-4a801e391e60.png" width="620" id="RIdT9" class="ne-image"></p><p id="07fa4c678f8a92f5afdcee0b00cbaa24" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616073493614-d618db76-bdb5-4284-a6c3-433bf44340b2.png" width="620" id="hBFH2" class="ne-image"></p><p id="9aa581dd60172652dea0f6ada276c2b4" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616073493684-be1891f4-c228-49eb-ac9d-47e233dafaad.png" width="620" id="Cd9At" class="ne-image"></p><p id="7a614249218469849607c38bae692545" class="ne-p"><strong><span class="ne-text">演示代码</span></strong></p><pre><code>&lt;body&gt;    &lt;div&gt;&lt;/div&gt;    &lt;ul&gt;        &lt;li&gt;我们都是好孩子&lt;/li&gt;        &lt;li&gt;我们都是好孩子&lt;/li&gt;        &lt;li&gt;我们都是好孩子&lt;/li&gt;    &lt;/ul&gt;    &lt;ol&gt;&lt;/ol&gt;    &lt;script&gt;        $(function() &#123;            // (1) on可以绑定1个或者多个事件处理程序            // $(&quot;div&quot;).on(&#123;            //     mouseenter: function() &#123;            //         $(this).css(&quot;background&quot;, &quot;skyblue&quot;);            //     &#125;,            //     click: function() &#123;            //         $(this).css(&quot;background&quot;, &quot;purple&quot;);            //     &#125;            // &#125;);            $(&quot;div&quot;).on(&quot;mouseenter mouseleave&quot;, function() &#123;                $(this).toggleClass(&quot;current&quot;);            &#125;);  <pre><code>        // (2) on可以实现事件委托（委派）        // click 是绑定在ul 身上的，但是 触发的对象是 ul 里面的小li        // $(&amp;quot;ul li&amp;quot;).click();        $(&amp;quot;ul&amp;quot;).on(&amp;quot;click&amp;quot;, &amp;quot;li&amp;quot;, function() &#123;            alert(11);        &#125;);        // (3) on可以给未来动态创建的元素绑定事件        $(&amp;quot;ol&amp;quot;).on(&amp;quot;click&amp;quot;, &amp;quot;li&amp;quot;, function() &#123;            alert(11);        &#125;)        var li = $(&amp;quot;&amp;lt;li&amp;gt;我是后来创建的&amp;lt;/li&amp;gt;&amp;quot;);        $(&amp;quot;ol&amp;quot;).append(li);    &#125;)&amp;lt;/script&amp;gt;</code></pre><p>&lt;/body&gt;<br></code></pre></p><h3 id="vjmrz"><span class="ne-text">1.2.3. 事件处理 off() 解绑事件</span></h3><p id="ca7ede028a7f07a37020cca741ad544e" class="ne-p"><span class="ne-text">    当某个事件上面的逻辑，在特定需求下不需要的时候，可以把该事件上的逻辑移除，这个过程我们称为事件解绑。jQuery 为我们提供 了多种事件解绑方法：die() / undelegate() / off() 等，甚至还有只触发一次的事件绑定方法 one()，在这里我们重点讲解一下 off() ;</span></p><p id="2b51b5149f611a9d07c7d645f9c35f48" class="ne-p"><strong><span class="ne-text">语法</span></strong></p><p id="3cd4aeb1c4533c26e80f568526c2b6a3" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616073493756-82ebfacb-9794-47bf-8776-6b7d80437782.png" width="620" id="IIuR6" class="ne-image"></p><p id="07e0b707fcfb0a1d83cf889e34013983" class="ne-p"><strong><span class="ne-text">演示代码</span></strong></p><pre><code>&lt;body&gt;    &lt;div&gt;&lt;/div&gt;    &lt;ul&gt;        &lt;li&gt;我们都是好孩子&lt;/li&gt;        &lt;li&gt;我们都是好孩子&lt;/li&gt;        &lt;li&gt;我们都是好孩子&lt;/li&gt;    &lt;/ul&gt;    &lt;p&gt;我是一个P标签&lt;/p&gt;    &lt;script&gt;        $(function() &#123;              // 事件绑定            $(&quot;div&quot;).on(&#123;                click: function() &#123;                    console.log(&quot;我点击了&quot;);                &#125;,                mouseover: function() &#123;                    console.log('我鼠标经过了');                &#125;            &#125;);            $(&quot;ul&quot;).on(&quot;click&quot;, &quot;li&quot;, function() &#123;                alert(11);            &#125;);  <pre><code>        // 1. 事件解绑 off         // $(&amp;quot;div&amp;quot;).off();  // 这个是解除了div身上的所有事件        $(&amp;quot;div&amp;quot;).off(&amp;quot;click&amp;quot;); // 这个是解除了div身上的点击事件        $(&amp;quot;ul&amp;quot;).off(&amp;quot;click&amp;quot;, &amp;quot;li&amp;quot;);        // 2. one() 但是它只能触发事件一次        $(&amp;quot;p&amp;quot;).one(&amp;quot;click&amp;quot;, function() &#123;            alert(11);        &#125;)    &#125;)&amp;lt;/script&amp;gt;</code></pre><p>&lt;/body&gt;<br></code></pre></p><h3 id="Su6fF"><span class="ne-text">1.2.4. 事件处理 trigger() 自动触发事件</span></h3><p id="acb3bfcd1cb90bffd26c7cb83eafe110" class="ne-p"><span class="ne-text">    有些时候，在某些特定的条件下，我们希望某些事件能够自动触发, 比如轮播图自动播放功能跟点击右侧按钮一致。可以利用定时器自动触发右侧按钮点击事件，不必鼠标点击触发。由此 jQuery 为我们提供了两个自动触发事件 trigger() 和 triggerHandler() ;</span></p><p id="ef781c11379caf67e369b3f700f76e6c" class="ne-p"><strong><span class="ne-text">语法</span></strong></p><p id="59181ab615f875d06d8ca08d3e313c9a" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616073493822-a72c8dfb-7860-407e-b410-60c073ed48d7.png" width="620" id="wy7Zt" class="ne-image"></p><p id="f6c2275990ad9334331cf0d35879a0d5" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616073493901-f1048b8f-64aa-4cf6-98df-0ea9245e813e.png" width="620" id="EXulM" class="ne-image"></p><p id="0beed4a3a038cb320bab570e717fe2c1" class="ne-p"><strong><span class="ne-text">演示代码</span></strong></p><pre><code>&lt;body&gt;    &lt;div&gt;&lt;/div&gt;    &lt;input type=&quot;text&quot;&gt;      <pre><code>&amp;lt;script&amp;gt;$(function() &#123;  // 绑定事件  $(&amp;quot;div&amp;quot;).on(&amp;quot;click&amp;quot;, function() &#123;    alert(11);  &#125;);  // 自动触发事件  // 1. 元素.事件()  // $(&amp;quot;div&amp;quot;).click();会触发元素的默认行为    // 2. 元素.trigger(&amp;quot;事件&amp;quot;)  // $(&amp;quot;div&amp;quot;).trigger(&amp;quot;click&amp;quot;);会触发元素的默认行为  $(&amp;quot;input&amp;quot;).trigger(&amp;quot;focus&amp;quot;);    // 3. 元素.triggerHandler(&amp;quot;事件&amp;quot;) 就是不会触发元素的默认行为  $(&amp;quot;input&amp;quot;).on(&amp;quot;focus&amp;quot;, function() &#123;    $(this).val(&amp;quot;你好吗&amp;quot;);  &#125;);  // 一个会获取焦点，一个不会  $(&amp;quot;div&amp;quot;).triggerHandler(&amp;quot;click&amp;quot;);  // $(&amp;quot;input&amp;quot;).triggerHandler(&amp;quot;focus&amp;quot;);&#125;);&amp;lt;/script&amp;gt;</code></pre><p>&lt;/body&gt;<br></code></pre></p><h2 id="SbVO0"><span class="ne-text">1.3. jQuery 事件对象</span></h2><p id="9b3a2941d9219d9ebcb67c406212630a" class="ne-p"><span class="ne-text">    jQuery 对DOM中的事件对象 event 进行了封装，兼容性更好，获取更方便，使用变化不大。事件被触发，就会有事件对象的产生。</span></p><p id="1dc5008c0c73b7cb053a1838dda7a5d5" class="ne-p"><strong><span class="ne-text">语法</span></strong></p><p id="67696560df2bb412b30ce75bb122e9fb" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616073493975-78588b8f-4bb7-4720-b637-d256b2831b0b.png" width="635" id="rOjnn" class="ne-image"></p><p id="4ffc343e626eb7f053cb813ba022d447" class="ne-p"><strong><span class="ne-text">演示代码</span></strong></p><pre><code>&lt;body&gt;    &lt;div&gt;&lt;/div&gt;    &lt;script&gt;        $(function() &#123;            $(document).on(&quot;click&quot;, function() &#123;                console.log(&quot;点击了document&quot;);            &#125;)            $(&quot;div&quot;).on(&quot;click&quot;, function(event) &#123;                // console.log(event);                console.log(&quot;点击了div&quot;);                event.stopPropagation();            &#125;)        &#125;)    &lt;/script&gt;&lt;/body&gt;</code></pre><p id="9ac2c2b45e418decb3e4c13e8ab72b61" class="ne-p"><span class="ne-text">注意：jQuery中的 event 对象使用，可以借鉴 API 和 DOM 中的 event 。</span></p><h2 id="UgRln"><span class="ne-text">1.4.  jQuery 拷贝对象</span></h2><p id="15c266e5200f2f66a3eff4916e44d816" class="ne-p"><span class="ne-text">    jQuery中分别为我们提供了两套快速获取和设置元素尺寸和位置的API，方便易用，内容如下。</span></p><p id="869f035caae2b45702879fe7323f2d7c" class="ne-p"><strong><span class="ne-text">语法</span></strong></p><p id="11ba8533e184fa5d4f27f50e085c0f5d" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616073494039-54be8373-5ba6-4c40-af84-3c6e7cd37d79.png" width="620" id="n5zBz" class="ne-image"></p><p id="23a58add2fafe93a5463bb367c440635" class="ne-p"><strong><span class="ne-text">演示代码</span></strong></p><pre><code>&lt;script&gt;        $(function() &#123;               // 1.合并数据            var targetObj = &#123;&#125;;            var obj = &#123;                id: 1,                name: &quot;andy&quot;            &#125;;            // $.extend(target, obj);            $.extend(targetObj, obj);            console.log(targetObj);   <pre><code>           // 2. 会覆盖 targetObj 里面原来的数据        var targetObj = &#123;            id: 0        &#125;;        var obj = &#123;            id: 1,            name: &amp;quot;andy&amp;quot;        &#125;;        // $.extend(target, obj);        $.extend(targetObj, obj);        console.log(targetObj);     &#125;)&amp;lt;/script&amp;gt;</code></pre><p></code></pre></p><h2 id="IZRrF"><span class="ne-text">1.5.  jQuery 多库共存</span></h2><p id="8357c305cb60e4e6bd222ed243746fbb" class="ne-p"><span class="ne-text">    实际开发中，很多项目连续开发十多年，jQuery版本不断更新，最初的 jQuery 版本无法满足需求，这时就需要保证在旧有版本正常运行的情况下，新的功能使用新的jQuery版本实现，这种情况被称为，jQuery 多库共存。</span></p><p id="84f1b795d31729a8ef17e94444b4afe4" class="ne-p"><strong><span class="ne-text">语法</span></strong></p><p id="dad15e0707e5aa7de311deb335cd7451" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616073494111-229f7c73-4d09-4074-bd62-0da6a2f0db40.png" width="620" id="iTQQD" class="ne-image"></p><p id="9e10ca41123f0ffc0022f9e7a9f62d98" class="ne-p"><strong><span class="ne-text">演示代码</span></strong></p><pre><code>&lt;script&gt;    $(function() &#123;          // 让jquery 释放对$ 控制权 让用自己决定          var suibian = jQuery.noConflict();          console.log(suibian(&quot;span&quot;));    &#125;)&lt;/script&gt;</code></pre><h2 id="Eo5OD"><span class="ne-text">1.6.  jQuery 插件</span></h2><p id="daf396b48b366501c68ccb82100ec403" class="ne-p"><span class="ne-text">    jQuery 功能比较有限，想要更复杂的特效效果，可以借助于 jQuery 插件完成。 这些插件也是依赖于jQuery来完成的，所以必须要先引入</span></p><p id="036d0840c4e2478e6952e488682e8d22" class="ne-p"><span class="ne-text">jQuery文件，因此也称为 jQuery 插件。</span></p><p id="38b20ceb5f76880fd855d36dac6fca19" class="ne-p"><span class="ne-text">    jQuery 插件常用的网站：</span></p><ol class="ne-ol"><li id="9d22b08c02d16cafbb40bf0b639d18e3"><span class="ne-text">jQuery 插件库  </span><a href="http://www.jq22.com/" data-href="http://www.jq22.com/" target="_blank" class="ne-link"><span class="ne-text">http://www.jq22.com/</span></a></li><li id="337d3a12c6c66a565df7a5643b75d9a9"><span class="ne-text">jQuery 之家   </span><a href="http://www.htmleaf.com/" data-href="http://www.htmleaf.com/" target="_blank" class="ne-link"><span class="ne-text">http://www.htmleaf.com/</span></a></li></ol><p id="299c9ce426a47c386d83d47df8ded0af" class="ne-p"><span class="ne-text">jQuery 插件使用步骤：</span></p><ol start="3" class="ne-ol"><li id="7acafff7d2dae86e620b77bbd2fafa62"><span class="ne-text">引入相关文件。（jQuery 文件 和 插件文件）</span></li><li id="f1945fe734388a83aae5600f016a34d3"><span class="ne-text">复制相关html、css、js (调用插件)。</span></li></ol><h3 id="9ieHe"><span class="ne-text">1.4.1.  瀑布流插件（重点讲解）</span></h3><p id="c62102b4462dbbcf1ea1e1159e2e0726" class="ne-p"><span class="ne-text">    我们学习的第一个插件是jQuery之家的开源插件，瀑布流。我们将重点详细讲解，从找到插件所在网页，然后点击下载代码，到插件的使用等，后面的插件使用可参考瀑布流插件的使用。</span></p><p id="7c61ac3e9a0b612a3123a1dc94a06977" class="ne-p"><strong><span class="ne-text">下载位置</span></strong></p><p id="af159dae35f3653f36af11c7fc25fc66" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616073494174-fb4a286c-0558-4af1-98d7-08102ae5bb99.png" width="1200" id="noBRx" class="ne-image"></p><p id="6a1ec52e2ca33b6fdad168330f77751f" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616073494257-d73dc383-f99b-465d-908e-703a4c023f36.png" width="318" id="MxV60" class="ne-image"></p><p id="e7cd3e319b356b85a72c5af9d097b2db" class="ne-p"><strong><span class="ne-text">代码演示</span></strong></p><p id="c2e0bd7ee791ae82e37ec48b0a6de92e" class="ne-p"><span class="ne-text">    插件的使用三点：   1. 引入css.           2.引入JS            3.引入html。 （有的简单插件只需引入html和js，甚至有的只需引入js）</span></p><ul class="ne-ul"><li id="87b0cbdb6a03055295f6bc8d7258bee3"><span class="ne-text">1.引入css.</span></li></ul><pre><code>&lt;link rel=&quot;stylesheet&quot; href=&quot;css/normalize.css&quot;&gt;&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;css/default.css&quot;&gt;  <p>&lt;!– 下面的样式代码为页面布局，可以引入，也可以自己写，自己设计页面样式，一般为直接引入，方便 –&gt;<br>&lt;style type=&quot;text/css&quot;&gt;<br>  #gallery-wrapper &#123;<br>    position: relative;<br>    max-width: 75%;<br>    width: 75%;<br>    margin: 50px auto;<br>  &#125;<br>  img.thumb &#123;<br>    width: 100%;<br>    max-width: 100%;<br>    height: auto;<br>  &#125;<br>  .white-panel &#123;<br>    position: absolute;<br>    background: white;<br>    border-radius: 5px;<br>    box-shadow: 0px 1px 2px rgba(0, 0, 0, 0.3);<br>    padding: 10px;<br>  &#125;<br>  .white-panel h1 &#123;<br>    font-size: 1em;<br>  &#125;<br>  .white-panel h1 a &#123;<br>    color: #A92733;<br>  &#125;<br>  .white-panel:hover &#123;<br>    box-shadow: 1px 1px 10px rgba(0, 0, 0, 0.5);<br>    margin-top: -5px;<br>    -webkit-transition: all 0.3s ease-in-out;<br>    -moz-transition: all 0.3s ease-in-out;<br>    -o-transition: all 0.3s ease-in-out;<br>    transition: all 0.3s ease-in-out;<br>  &#125;<br>&lt;/style&gt;<br></code></pre></p><ul class="ne-ul"><li id="ee295205b3258810652f6c1ad7676327"><span class="ne-text">2.引入js.</span></li></ul><pre><code>&lt;!-- 前两个必须引入 --&gt;&lt;script src=&quot;js/jquery-1.11.0.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;js/pinterest_grid.js&quot;&gt;&lt;/script&gt;&lt;!-- 下面的为启动瀑布流代码，参数可调节属性，具体功能可参考readme.html --&gt;&lt;script type=&quot;text/javascript&quot;&gt;    $(function() &#123;      $(&quot;#gallery-wrapper&quot;).pinterest_grid(&#123;          no_columns: 5,          padding_x: 15,          padding_y: 10,          margin_bottom: 50,          single_column_breakpoint: 700      &#125;);    &#125;);&lt;/script&gt;</code></pre><ul class="ne-ul"><li id="90429a79ea9868bf175ab694ae467f90"><span class="ne-text">3.引入html.</span></li></ul><pre><code>&lt;!-- html结构一般为事先写好，很难修改结构，但可以修改内容及图片的多少（article标签） --&gt;    &lt;section id=&quot;gallery-wrapper&quot;&gt;        &lt;article class=&quot;white-panel&quot;&gt;            &lt;img src=&quot;images/P_000.jpg&quot; class=&quot;thumb&quot;&gt;            &lt;h1&gt;&lt;a href=&quot;#&quot;&gt;我是轮播图片1&lt;/a&gt;&lt;/h1&gt;            &lt;p&gt;里面很精彩哦&lt;/p&gt;        &lt;/article&gt;        &lt;article class=&quot;white-panel&quot;&gt;            &lt;img src=&quot;images/P_005.jpg&quot; class=&quot;thumb&quot;&gt;            &lt;h1&gt;&lt;a href=&quot;#&quot;&gt;我是轮播图片1&lt;/a&gt;&lt;/h1&gt;            &lt;p&gt;里面很精彩哦&lt;/p&gt;        &lt;/article&gt;        &lt;article class=&quot;white-panel&quot;&gt;            &lt;img src=&quot;images/P_006.jpg&quot; class=&quot;thumb&quot;&gt;            &lt;h1&gt;&lt;a href=&quot;#&quot;&gt;我是轮播图片1&lt;/a&gt;&lt;/h1&gt;            &lt;p&gt;里面很精彩哦&lt;/p&gt;        &lt;/article&gt;        &lt;article class=&quot;white-panel&quot;&gt;            &lt;img src=&quot;images/P_007.jpg&quot; class=&quot;thumb&quot;&gt;            &lt;h1&gt;&lt;a href=&quot;#&quot;&gt;我是轮播图片1&lt;/a&gt;&lt;/h1&gt;            &lt;p&gt;里面很精彩哦&lt;/p&gt;        &lt;/article&gt;    &lt;/section&gt;</code></pre><p id="2cebc871eb4858041be0c6b2ea1bd12f" class="ne-p"><span class="ne-text">总结：jQuery插件就是引入别人写好的：html 、css、js  （有时也可以只引入一部分，读懂后也可以修改部分内容）</span></p><h3 id="corv0"><span class="ne-text">1.4.2. 图片懒加载插件</span></h3><p id="d669e8fd16cf0d8cbea91ec3b8879eab" class="ne-p"><span class="ne-text">    图片的懒加载就是：当页面滑动到有图片的位置，图片才进行加载，用以提升页面打开的速度及用户体验。（下载略）</span></p><p id="e2c1c3f950a6b51f4a783d5063b8dd4c" class="ne-p"><strong><span class="ne-text">代码演示</span></strong></p><p id="a4174de760805276de05839765c52752" class="ne-p"><span class="ne-text">    懒加载只需引入html 和 js操作 即可，此插件不涉及css。</span></p><ul class="ne-ul"><li id="87e94090f81a3a53278fe1805a1c1e1f"><span class="ne-text">1.引入js</span></li></ul><pre><code>&lt;script src=&quot;js/EasyLazyload.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt;       lazyLoadInit(&#123;           showTime: 1100,           onLoadBackEnd: function(i, e) &#123;             console.log(&quot;onLoadBackEnd:&quot; + i);           &#125;,           onLoadBackStart: function(i, e) &#123;             console.log(&quot;onLoadBackStart:&quot; + i);           &#125;     &#125;);&lt;/script&gt;</code></pre><ul class="ne-ul"><li id="c44d3b912972c9d6c87268b258b700e6"><span class="ne-text">2.引入html</span></li></ul><pre><code>&lt;img data-lazy-src=&quot;upload/floor-1-3.png&quot; alt=&quot;&quot;&gt;</code></pre><h3 id="ghjB7"><span class="ne-text">1.4.3. 全屏滚动插件</span></h3><p id="a3c5f0983e30aaf690050ecec1840821" class="ne-p"><span class="ne-text">    全屏滚动插件比较大，所以，一般大型插件都会有帮助文档，或者网站。全屏滚动插件介绍比较详细的网站为：</span></p><p id="3d1a46b3ad0ec1f2446db67cef761ccc" class="ne-p"><a href="http://www.dowebok.com/demo/2014/77/" data-href="http://www.dowebok.com/demo/2014/77/" target="_blank" class="ne-link"><span class="ne-text">http://www.dowebok.com/demo/2014/77/</span></a></p><p id="d9277d1c714013ed864b4f8ebec617c9" class="ne-p"><strong><span class="ne-text">代码演示</span></strong></p><p id="3c8ac7a28432302ee64f04c98bfac2a7" class="ne-p"><span class="ne-text">    全屏滚动因为有多重形式，所以不一样的风格html和css也不一样，但是 js 变化不大。所以下面只演示js的引入，html和css引入根据自己实际</span></p><p id="e287944b65da3c8440df4c4dba0ef07c" class="ne-p"><span class="ne-text">项目需要使用哪种风格引入对应的HTML和CSS。</span></p><pre><code>&lt;script src=&quot;js/jquery.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;js/fullpage.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt;      $(function() &#123;          $('#dowebok').fullpage(&#123;            sectionsColor: ['pink', '#4BBFC3', '#7BAABE', '#f90'],            navigation: true          &#125;);    &#125;);&lt;/script&gt;</code></pre><p id="2f7f87435ce98177fd89bfdab4cc6b76" class="ne-p"><span class="ne-text">注意：实际开发，一般复制文件，然后在文件中进行修改和添加功能。</span></p><h3 id="98lES"><span class="ne-text">1.4.4. bootstrap组件</span></h3><p id="50234f7e89ffa7a36c8cc0085a266321" class="ne-p"><span class="ne-text">    Bootstrap是 Twitter 公司设计的基于HTML、CSS、JavaScript开发的简洁、直观、强悍的前端开发框架，他依靠jQuery实现，且支持响应式</span></p><p id="8f56f32642a879204a210868af4e763a" class="ne-p"><span class="ne-text">布局，使得 Web 开发更加方便快捷。</span></p><p id="c8e213a8d8f91767729d58ef025d6f61" class="ne-p"><span class="ne-text">    </span><strong><span class="ne-text">凡是在软件开发中用到了软件的复用，被复用的部分都可以称为组件，凡是在应用程序中已经预留接口的组件就是插件</span></strong><span class="ne-text">。Bootstrap组件使</span></p><p id="368dd2f0fa47cebfbab2bf2c7399daaa" class="ne-p"><span class="ne-text">用非常方便:  1.引入bootstrap相关css和js        2.去官网复制html</span></p><p id="4a9225b1c8e31ed25c4d6ebdae4988e0" class="ne-p"><strong><span class="ne-text">代码演示</span></strong></p><ol class="ne-ol"><li id="4a472d790db2f22b81f27a91c87e19a0"><span class="ne-text">引入bootstrap相关css和js</span></li></ol><pre><code>&lt;link rel=&quot;stylesheet&quot; href=&quot;bootstrap/css/bootstrap.min.css&quot;&gt;&lt;script src=&quot;bootstrap/js/jquery.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;bootstrap/js/bootstrap.min.js&quot;&gt;&lt;/script&gt;</code></pre><ol start="2" class="ne-ol"><li id="bf12ebc8e0315ae0176857a9c5c7759b"><span class="ne-text">去官网复制html的功能模块</span></li></ol><pre><code>&lt;div class=&quot;container&quot;&gt;        &lt;!-- Single button --&gt;        &lt;div class=&quot;btn-group&quot;&gt;            &lt;button type=&quot;button&quot; class=&quot;btn btn-default dropdown-toggle&quot; data-toggle=&quot;dropdown&quot; aria-haspopup=&quot;true&quot; aria-expanded=&quot;false&quot;&gt;              Action &lt;span class=&quot;caret&quot;&gt;&lt;/span&gt;            &lt;/button&gt;            &lt;ul class=&quot;dropdown-menu&quot;&gt;                &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Action&lt;/a&gt;&lt;/li&gt;                &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Another action&lt;/a&gt;&lt;/li&gt;                &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Something else here&lt;/a&gt;&lt;/li&gt;                &lt;li role=&quot;separator&quot; class=&quot;divider&quot;&gt;&lt;/li&gt;                &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Separated link&lt;/a&gt;&lt;/li&gt;            &lt;/ul&gt;         &lt;/div&gt;    &lt;/div&gt;</code></pre><h3 id="raOoE"><span class="ne-text">1.4.5. bootstrap插件（JS）</span></h3><p id="c0414aa19be56e28edc03d11e744fdf3" class="ne-p"><span class="ne-text">    bootstrap中的js插件其实也是组件的一部分，只不过是需要js调用功能的组件，所以一般bootstrap的js插件一般会伴随着js代码（有的也可以</span></p><p id="60eca7467a6a6d0b4088869c14a4b473" class="ne-p"><span class="ne-text">省略js，用属性实现）。</span></p><p id="e45e9aec6dbcc78cf247f3e846c6a3a2" class="ne-p"><span class="ne-text">    步骤： 1.引入bootstrap相关css和js        2.去官网复制html        3.复制js代码，启动js插件。</span></p><p id="7c5e733d100b5c5e68cadf1a2c2ed718" class="ne-p"><strong><span class="ne-text">代码演示</span></strong></p><ol class="ne-ol"><li id="e18e9a0b2dff0f2a70cb9ccda6ab5a76"><span class="ne-text">引入bootstrap相关css和js</span></li></ol><pre><code>&lt;link rel=&quot;stylesheet&quot; href=&quot;bootstrap/css/bootstrap.min.css&quot;&gt;&lt;script src=&quot;bootstrap/js/jquery.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;bootstrap/js/bootstrap.min.js&quot;&gt;&lt;/script&gt;</code></pre><ol start="2" class="ne-ol"><li id="5c0b585808c162fedf482a8320273a86"><span class="ne-text">去官网复制html的功能模块</span></li></ol><pre><code>&lt;!-- 模态框 --&gt;&lt;!-- Large modal --&gt;&lt;button type=&quot;button&quot; class=&quot;btn btn-primary&quot; data-toggle=&quot;modal&quot; data-target=&quot;.bs-example-modal-lg&quot;&gt;Large modal&lt;/button&gt;&lt;div class=&quot;modal fade bs-example-modal-lg&quot; tabindex=&quot;-1&quot; role=&quot;dialog&quot; aria-labelledby=&quot;myLargeModalLabel&quot;&gt;    &lt;div class=&quot;modal-dialog modal-lg&quot; role=&quot;document&quot;&gt;        &lt;div class=&quot;modal-content&quot;&gt;            里面就是模态框        &lt;/div&gt;    &lt;/div&gt;&lt;/div&gt;</code></pre><ol start="3" class="ne-ol"><li id="d9ce2af0a9b472020ce2d76ef872b8d0"><span class="ne-text">复制js代码，启动js插件。</span></li></ol><pre><code>&lt;script&gt;    // 当我们点击了自己定义的按钮，就弹出模态框    $(&quot;.myBtn&quot;).on(&quot;click&quot;, function() &#123;        // alert(11);        $('#btn').modal()    &#125;)&lt;/script&gt;</code></pre><h3 id="ew7V0"><span class="ne-text">1.4.6. bootstrap案例-阿里百秀</span></h3><div class="ne-quote"><p id="c8d8cd4d291f85a5d849fbadaf2de451" class="ne-p"><span class="ne-text">1.通过调用组件实现导航栏</span></p><p id="def90a1ecb0b6791eb0b21b59195f115" class="ne-p"><span class="ne-text">2.通过调用插件实现登录</span></p><p id="f27406bc15cbc2e5a7e2322fa61f11be" class="ne-p"><span class="ne-text">3.通过调用插件标签页实现 tab 栏</span></p></div><p id="a14550fd94b926128c9a99ae9f926815" class="ne-p"><span class="ne-text">    代码实现略。(详情参考源代码)</span></p><h2 id="hzD6P"><span class="ne-text">1.7. 综合案例: toDoList案例分析（代码略）</span></h2><h3 id="flTdM"><span class="ne-text">1.7.1 案例：案例介绍</span></h3><pre><code>// 1. 文本框里面输入内容，按下回车，就可以生成待办事项。// 2. 点击待办事项复选框，就可以把当前数据添加到已完成事项里面。// 3. 点击已完成事项复选框，就可以把当前数据添加到待办事项里面。// 4. 但是本页面内容刷新页面不会丢失。</code></pre><h3 id="Ipy2e"><span class="ne-text">1.7.2 案例：toDoList 分析</span></h3><pre><code>// 1. 刷新页面不会丢失数据，因此需要用到本地存储 localStorage// 2. 核心思路： 不管按下回车，还是点击复选框，都是把本地存储的数据加载到页面中，这样保证刷新关闭页面不会丢失数据// 3. 存储的数据格式：var todolist =  [&#123; title : ‘xxx’, done: false&#125;]// 4. 注意点1： 本地存储 localStorage 里面只能存储字符串格式 ，因此需要把对象转换为字符串 JSON.stringify(data)。// 5. 注意点2： 获取本地存储数据，需要把里面的字符串转换为对象格式JSON.parse() 我们才能使用里面的数据。</code></pre><h3 id="2WmZi"><span class="ne-text">1.7.3 案例：toDoList 按下回车把新数据添加到本地存储里面</span></h3><pre><code>// 1.切记： 页面中的数据，都要从本地存储里面获取，这样刷新页面不会丢失数据，所以先要把数据保存到本地存储里面。// 2.利用事件对象.keyCode判断用户按下回车键（13）。// 3.声明一个数组，保存数据。// 4.先要读取本地存储原来的数据（声明函数 getData()），放到这个数组里面。// 5.之后把最新从表单获取过来的数据，追加到数组里面。// 6.最后把数组存储给本地存储 (声明函数 savaDate())</code></pre><h3 id="EYpyG"><span class="ne-text">1.7.4 案例：toDoList 本地存储数据渲染加载到页面</span></h3><pre><code>// 1.因为后面也会经常渲染加载操作，所以声明一个函数 load，方便后面调用// 2.先要读取本地存储数据。（数据不要忘记转换为对象格式）// 3.之后遍历这个数据（$.each()），有几条数据，就生成几个小li 添加到 ol 里面。// 4.每次渲染之前，先把原先里面 ol 的内容清空，然后渲染加载最新的数据。</code></pre><h3 id="Bq0CI"><span class="ne-text">1.7.5 案例：toDoList 删除操作</span></h3><pre><code>// 1.点击里面的a链接，不是删除的li，而是删除本地存储对应的数据。// 2.核心原理：先获取本地存储数据，删除对应的数据，保存给本地存储，重新渲染列表li// 3.我们可以给链接自定义属性记录当前的索引号// 4.根据这个索引号删除相关的数据----数组的splice(i, 1)方法// 5.存储修改后的数据，然后存储给本地存储// 6.重新渲染加载数据列表// 7.因为a是动态创建的，我们使用on方法绑定事件</code></pre><h3 id="4xnMN"><span class="ne-text">1.7.6 案例：toDoList  正在进行和已完成选项操作</span></h3><pre><code>// 1.当我们点击了小的复选框，修改本地存储数据，再重新渲染数据列表。// 2.点击之后，获取本地存储数据。// 3.修改对应数据属性 done 为当前复选框的checked状态。// 4.之后保存数据到本地存储// 5.重新渲染加载数据列表// 6.load 加载函数里面，新增一个条件,如果当前数据的done为true 就是已经完成的，就把列表渲染加载到 ul 里面// 7.如果当前数据的done 为false， 则是待办事项，就把列表渲染加载到 ol 里面</code></pre><h3 id="yB6r9"><span class="ne-text">1.7.7 案例：toDoList 统计正在进行个数和已经完成个数</span></h3><pre><code>// 1.在我们load 函数里面操作// 2.声明2个变量 ：todoCount 待办个数  doneCount 已完成个数   // 3.当进行遍历本地存储数据的时候， 如果 数据done为 false， 则 todoCount++, 否则 doneCount++// 4.最后修改相应的元素 text()</code></pre><h2 id="Xmq62"><span class="ne-text">1.8. 今日总结</span></h2><p id="05f8df70e9447b2bb650af82331e3c22" class="ne-p"><img src="images/%E6%80%BB%E7%BB%93.png" id="M74oU" class="ne-image"></p></div>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
          <category> JavaScript </category>
          
          <category> jQuery </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>jQuery元素+属性操作</title>
      <link href="/blog/2_day02_jquery/"/>
      <url>/blog/2_day02_jquery/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h2 id="a84WB"><span class="ne-text">jQuery 属性操作</span></h2><p id="a8defb124f5e5a9575153fec51a39e0b" class="ne-p"><span class="ne-text">jQuery 常用属性操作有三种：prop() / attr() / data() ;</span></p><h3 id="3uR5P"><span class="ne-text">元素固有属性值 prop()</span></h3><p id="b8a37df535bfa26833c1ed9f7513401d" class="ne-p"><span class="ne-text">所谓元素固有属性就是元素本身自带的属性，比如  元素里面的 href ，比如  元素里面的 type。</span></p><p id="a9487485bd2d576830eb3683b8133305" class="ne-p"><strong><span class="ne-text">语法</span></strong></p><p id="c67bac1140207aad202dec5763ae612e" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616073492194-d6d9ff5b-5c98-495b-bebb-c3be7790bbf4.png" width="619" id="F3BQ7" class="ne-image"></p><p id="f6f44187171a3efbebbb6447243d6f25" class="ne-p"><span class="ne-text">注意：prop() 除了普通属性操作，更适合操作表单属性：disabled / checked / selected 等。</span></p><h3 id="4q3oJ"><span class="ne-text">元素自定义属性值 attr()</span></h3><p id="1e90bde4e6989ac8347119f1cf6c2c3b" class="ne-p"><span class="ne-text">用户自己给元素添加的属性，我们称为自定义属性。 比如给 div 添加 index =“1”。</span></p><p id="8a1aabfa4ec49b05bfc0060d7fc95a2b" class="ne-p"><strong><span class="ne-text">语法</span></strong></p><p id="fe9ca068f651da492fabea6d7b7516ea" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616073492261-f36c35ad-cba6-4c24-ac2d-18781c30b41a.png" width="616" id="ULnKR" class="ne-image"></p><p id="ef1900287a2293f5a2cb993d6b0cf328" class="ne-p"><span class="ne-text">    注意：attr() 除了普通属性操作，更适合操作自定义属性。（该方法也可以获取 H5 自定义属性）</span></p><h3 id="EKaoU"><span class="ne-text">数据缓存 data()</span></h3><p id="44d6f8942be4dd8afaed4a940dcdaf62" class="ne-p"><span class="ne-text">    data() 方法可以在指定的元素上存取数据，并不会修改 DOM 元素结构。一旦页面刷新，之前存放的数据都将被移除。</span></p><p id="24c6921186ca6d63500beddc86d91c7f" class="ne-p"><strong><span class="ne-text">语法</span></strong></p><p id="4fcfe1d6594d886fe9b1e0165d692b29" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616073492334-8d7a046e-854f-4449-a169-2820244ff75f.png" width="616" id="teEJx" class="ne-image"></p><p id="3343a230869e6af51123f0592ff78b20" class="ne-p"><span class="ne-text">注意：同时，还可以读取 HTML5 自定义属性  data-index ，得到的是数字型。</span></p><p id="ccd713e912a51f9648ef08f6b4f37aea" class="ne-p"><strong><span class="ne-text">演示代码</span></strong></p><pre><code>&lt;body&gt;    &lt;a href=&quot;http://www.itcast.cn&quot; title=&quot;都挺好&quot;&gt;都挺好&lt;/a&gt;    &lt;input type=&quot;checkbox&quot; name=&quot;&quot; id=&quot;&quot; checked&gt;    &lt;div index=&quot;1&quot; data-index=&quot;2&quot;&gt;我是div&lt;/div&gt;    &lt;span&gt;123&lt;/span&gt;    &lt;script&gt;        $(function() &#123;            //1. element.prop(&quot;属性名&quot;) 获取元素固有的属性值            console.log($(&quot;a&quot;).prop(&quot;href&quot;));            $(&quot;a&quot;).prop(&quot;title&quot;, &quot;我们都挺好&quot;);            $(&quot;input&quot;).change(function() &#123;                console.log($(this).prop(&quot;checked&quot;));            &#125;);            // console.log($(&quot;div&quot;).prop(&quot;index&quot;));            // 2. 元素的自定义属性 我们通过 attr()            console.log($(&quot;div&quot;).attr(&quot;index&quot;));            $(&quot;div&quot;).attr(&quot;index&quot;, 4);            console.log($(&quot;div&quot;).attr(&quot;data-index&quot;));            // 3. 数据缓存 data() 这个里面的数据是存放在元素的内存里面            $(&quot;span&quot;).data(&quot;uname&quot;, &quot;andy&quot;);            console.log($(&quot;span&quot;).data(&quot;uname&quot;));            // 这个方法获取data-index h5自定义属性 第一个 不用写data-  而且返回的是数字型            console.log($(&quot;div&quot;).data(&quot;index&quot;));        &#125;)    &lt;/script&gt;&lt;/body&gt;</code></pre><h2 id="Zge0q"><span class="ne-text">jQuery 文本属性值</span></h2><p id="5dedcb1fae70b3e970d22cf12f74224d" class="ne-p"><span class="ne-text">jQuery的文本属性值常见操作有三种：html() / text() / val() ; 分别对应JS中的 innerHTML 、innerText 和 value 属性。</span></p><h3 id="pHXtm"><span class="ne-text">jQuery内容文本值</span></h3><p id="1c68e4140afbb05fe6c9039e32ce483c" class="ne-p"><span class="ne-text">常见操作有三种：html() / text() / val() ; 分别对应JS中的 innerHTML 、innerText 和 value 属性，主要针对元素的内容还有表单的值操作。</span></p><p id="c731a7625b28369eb5cc172761a1aec0" class="ne-p"><strong><span class="ne-text">语法</span></strong></p><p id="9390d9f3727b9b4d762371d4e296475d" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616073492400-d8ee58ad-1d5e-42a0-a07f-52d7558fb341.png" width="663" id="WFDE9" class="ne-image"></p><p id="fe96f366f951c6e6593d7640219a72d1" class="ne-p"><span class="ne-text">注意：html() 可识别标签，text() 不识别标签。</span></p><p id="d0ec0a582e10753e0d7879ab68d48642" class="ne-p"><strong><span class="ne-text">演示代码</span></strong></p><pre><code>&lt;body&gt;    &lt;div&gt;        &lt;span&gt;我是内容&lt;/span&gt;    &lt;/div&gt;    &lt;input type=&quot;text&quot; value=&quot;请输入内容&quot;&gt;    &lt;script&gt;        // 1. 获取设置元素内容 html()        console.log($(&quot;div&quot;).html());        // $(&quot;div&quot;).html(&quot;123&quot;);        // 2. 获取设置元素文本内容 text()        console.log($(&quot;div&quot;).text());        $(&quot;div&quot;).text(&quot;123&quot;);        // 3. 获取设置表单值 val()        console.log($(&quot;input&quot;).val());        $(&quot;input&quot;).val(&quot;123&quot;);    &lt;/script&gt;&lt;/body&gt;</code></pre><h2 id="c2kiZ"><span class="ne-text">jQuery 元素操作</span></h2><p id="d4dd32c8b56d740c5000658a8051fcbf" class="ne-p"><span class="ne-text">jQuery 元素操作主要讲的是用jQuery方法，操作标签的遍历、创建、添加、删除等操作。</span></p><h3 id="LTUXw"><span class="ne-text">遍历元素</span></h3><p id="da559053930325ccc78d10eed450cbc8" class="ne-p"><span class="ne-text">jQuery 隐式迭代是对同一类元素做了同样的操作。 如果想要给同一类元素做不同操作，就需要用到遍历。</span></p><p id="bc3b6d6af0dd36ad44979f953823bfff" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616073492472-0f31ef63-133b-40cf-b438-391dde571eb4.png" width="622" id="kRNyG" class="ne-image"></p><p id="4e8e29b1e454c9573443c3dc25a4c65d" class="ne-p"><span class="ne-text">注意：此方法用于遍历 jQuery 对象中的每一项，回调函数中元素为 DOM 对象，想要使用 jQuery 方法需要转换。</span></p><p id="90f8868709a602071b2ed5c829c476fd" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616073492553-9c2ac31d-49a0-4e91-bf4e-d2279e74ff32.png" width="617" id="W8TwJ" class="ne-image"></p><p id="d560c0796978ee3038a0252c52c75a74" class="ne-p"><span class="ne-text">注意：此方法用于遍历 jQuery 对象中的每一项，回调函数中元素为 DOM 对象，想要使用 jQuery 方法需要转换。</span></p><p id="c457090a7ff195c6728e2f0ce715073c" class="ne-p"><strong><span class="ne-text">演示代码</span></strong></p><pre><code>&lt;body&gt;    &lt;div&gt;1&lt;/div&gt;    &lt;div&gt;2&lt;/div&gt;    &lt;div&gt;3&lt;/div&gt;    &lt;script&gt;        $(function() &#123;            // 如果针对于同一类元素做不同操作，需要用到遍历元素（类似for，但是比for强大）            var sum = 0;            var arr = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;];            // 1. each() 方法遍历元素             $(&quot;div&quot;).each(function(i, domEle) &#123;                // 回调函数第一个参数一定是索引号  可以自己指定索引号号名称                // console.log(i);                // 回调函数第二个参数一定是 dom 元素对象，也是自己命名                // console.log(domEle);  // 使用jQuery方法需要转换 $(domEle)                $(domEle).css(&quot;color&quot;, arr[i]);                sum += parseInt($(domEle).text());            &#125;)            console.log(sum);            // 2. $.each() 方法遍历元素 主要用于遍历数据，处理数据            // $.each($(&quot;div&quot;), function(i, ele) &#123;            //     console.log(i);            //     console.log(ele);            // &#125;);            // $.each(arr, function(i, ele) &#123;            //     console.log(i);            //     console.log(ele);            // &#125;)            $.each(&#123;                name: &quot;andy&quot;,                age: 18            &#125;, function(i, ele) &#123;                console.log(i); // 输出的是 name age 属性名                console.log(ele); // 输出的是 andy  18 属性值            &#125;)        &#125;)    &lt;/script&gt;&lt;/body&gt;</code></pre><h3 id="b1i7j"><span class="ne-text">创建、添加、删除</span></h3><p id="22331a7c4bac55bdabf10be2d0cd3b45" class="ne-p"><span class="ne-text">jQuery方法操作元素的创建、添加、删除方法很多，则重点使用部分，如下：</span></p><p id="ae75d84aaedc75e27004c537ab734f2d" class="ne-p"><strong><span class="ne-text">语法总和</span></strong></p><p id="b084aa5675b44665b99fa086aa3cf755" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616073492632-06694ce7-f376-454f-9c85-c4f7a0ba0338.png" width="624" id="yRDsg" class="ne-image"></p><p id="09d17b60e40b36a044d0f790df349c0b" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616073492709-dbf5e1ae-fcee-4283-8cc2-5ecb0bcc1b83.png" width="623" id="jQMTc" class="ne-image"></p><p id="2c2af8ddf2ff10d519825d26564b9f84" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616073492783-28f74b87-b629-477d-9ca2-47e4588c4b96.png" width="621" id="YQmbb" class="ne-image"></p><p id="72c38b32527c6926ba9e0d65ee4e84d9" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616073492861-e9f292d0-aaf9-4b05-b013-77a589f3bf2a.png" width="625" id="YVMfw" class="ne-image"></p><p id="8d1b437df37981f98a63c0a1976308bf" class="ne-p"><span class="ne-text">    注意：以上只是元素的创建、添加、删除方法的常用方法，其他方法请参详API。</span></p><p id="122596ffaae400a0c8adf0a6cf8c7b00" class="ne-p"><strong><span class="ne-text">案例代码</span></strong></p><pre><code>&lt;body&gt;    &lt;ul&gt;        &lt;li&gt;原先的li&lt;/li&gt;    &lt;/ul&gt;    &lt;div class=&quot;test&quot;&gt;我是原先的div&lt;/div&gt;    &lt;script&gt;        $(function() &#123;            // 1. 创建元素            var li = $(&quot;&lt;li&gt;我是后来创建的li&lt;/li&gt;&quot;);      <pre><code>        // 2. 添加元素        //     2.1 内部添加        // $(&amp;quot;ul&amp;quot;).append(li);  内部添加并且放到内容的最后面         $(&amp;quot;ul&amp;quot;).prepend(li); // 内部添加并且放到内容的最前面        //  2.2 外部添加        var div = $(&amp;quot;&amp;lt;div&amp;gt;我是后妈生的&amp;lt;/div&amp;gt;&amp;quot;);        // $(&amp;quot;.test&amp;quot;).after(div);        $(&amp;quot;.test&amp;quot;).before(div);          // 3. 删除元素        // $(&amp;quot;ul&amp;quot;).remove(); 可以删除匹配的元素 自杀        // $(&amp;quot;ul&amp;quot;).empty(); // 可以删除匹配的元素里面的子节点 孩子        $(&amp;quot;ul&amp;quot;).html(&amp;quot;&amp;quot;); // 可以删除匹配的元素里面的子节点 孩子    &#125;)&amp;lt;/script&amp;gt;</code></pre><p>&lt;/body&gt;<br></code></pre></p><h2 id="4p0dj"><span class="ne-text">jQuery 尺寸、位置操作</span></h2><p id="48388913479dff10690233a08f9860ba" class="ne-p"><span class="ne-text">jQuery中分别为我们提供了两套快速获取和设置元素尺寸和位置的API，方便易用，内容如下。</span></p><h3 id="uwWhH"><span class="ne-text">jQuery 尺寸操作</span></h3><p id="c8aaa1b81d5817ab46a9041c62bf29f3" class="ne-p"><span class="ne-text">jQuery 尺寸操作包括元素宽高的获取和设置，且不一样的API对应不一样的盒子模型。</span></p><p id="94a1c1107dcc132d20661ab9850a3f6f" class="ne-p"><strong><span class="ne-text">语法</span></strong></p><p id="c775a5b617646febd7150a498ab8fb00" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616073492939-79b5b959-2700-496c-adb0-d049e25f6490.png" width="629" id="sD1iA" class="ne-image"></p><p id="111930a35a9b8d2157f54007cfcb8235" class="ne-p"><strong><span class="ne-text">代码演示</span></strong></p><pre><code>&lt;body&gt;    &lt;div&gt;&lt;/div&gt;    &lt;script&gt;        $(function() &#123;            // 1. width() / height() 获取设置元素 width和height大小             console.log($(&quot;div&quot;).width());            // $(&quot;div&quot;).width(300);            // 2. innerWidth() / innerHeight()  获取设置元素 width和height + padding 大小             console.log($(&quot;div&quot;).innerWidth());            // 3. outerWidth()  / outerHeight()  获取设置元素 width和height + padding + border 大小             console.log($(&quot;div&quot;).outerWidth());            // 4. outerWidth(true) / outerHeight(true) 获取设置 width和height + padding + border + margin            console.log($(&quot;div&quot;).outerWidth(true));        &#125;)    &lt;/script&gt;&lt;/body&gt;</code></pre><p id="87df67f798730df6655125418d43a041" class="ne-p"><span class="ne-text">注意：有了这套 API 我们将可以快速获取和子的宽高，至于其他属性想要获取和设置，还要使用 css() 等方法配合。</span></p><h3 id="oNnlJ"><span class="ne-text">jQuery 位置操作</span></h3><p id="9139b8677f3c1d005f6fce8ae1788241" class="ne-p"><span class="ne-text">jQuery的位置操作主要有三个： offset()、position()、scrollTop()/scrollLeft() , 具体介绍如下:</span></p><p id="64e6daca86565ba5a3bd127b34da1fae" class="ne-p"><strong><span class="ne-text">语法</span></strong></p><p id="cde3dca760a02c5526209a3a07b40b18" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616073493024-1b363784-6614-4dd9-8ddc-dd97531a3cb6.png" width="663" id="No6MP" class="ne-image"></p><p id="331d1daa4a3c747bf22b136812e7e456" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616073493095-d18b82ae-83d0-465b-bf27-4fb9449ee6c6.png" width="663" id="uRPbe" class="ne-image"></p><p id="60be9a06b093c0bc7b909727767cdcfa" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616073493171-f3d23a41-7256-4fe7-9818-1624a3ab45ce.png" width="663" id="q9MPG" class="ne-image"></p><p id="52420ede99fa7dfcd6a1af6949acadc9" class="ne-p"><strong><span class="ne-text">代码演示</span></strong></p><pre><code>&lt;body&gt;    &lt;div class=&quot;father&quot;&gt;        &lt;div class=&quot;son&quot;&gt;&lt;/div&gt;    &lt;/div&gt;        <pre><code>&amp;lt;div class=&amp;quot;back&amp;quot;&amp;gt;返回顶部&amp;lt;/div&amp;gt;&amp;lt;div class=&amp;quot;container&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;&amp;lt;script&amp;gt;    $(function() &#123;        // 1. 获取设置距离文档的位置（偏移） offset        console.log($(&amp;quot;.son&amp;quot;).offset());        console.log($(&amp;quot;.son&amp;quot;).offset().top);        // $(&amp;quot;.son&amp;quot;).offset(&#123;        //     top: 200,        //     left: 200        // &#125;);          // 2. 获取距离带有定位父级位置（偏移） position   如果没有带有定位的父级，则以文档为准        // 这个方法只能获取不能设置偏移        console.log($(&amp;quot;.son&amp;quot;).position());        // $(&amp;quot;.son&amp;quot;).position(&#123;        //     top: 200,        //     left: 200        // &#125;);            // 3. 被卷去的头部          $(document).scrollTop(100);        // 被卷去的头部 scrollTop()  / 被卷去的左侧 scrollLeft()        // 页面滚动事件        var boxTop = $(&amp;quot;.container&amp;quot;).offset().top;        $(window).scroll(function() &#123;            // console.log(11);            console.log($(document).scrollTop());            if ($(document).scrollTop() &amp;gt;= boxTop) &#123;                $(&amp;quot;.back&amp;quot;).fadeIn();            &#125; else &#123;                $(&amp;quot;.back&amp;quot;).fadeOut();            &#125;        &#125;);        // 返回顶部        $(&amp;quot;.back&amp;quot;).click(function() &#123;            // $(document).scrollTop(0);            $(&amp;quot;body, html&amp;quot;).stop().animate(&#123;                scrollTop: 0            &#125;);            // $(document).stop().animate(&#123;            //     scrollTop: 0            // &#125;); 不能是文档而是 html和body元素做动画        &#125;)    &#125;)&amp;lt;/script&amp;gt;</code></pre><p>&lt;/body&gt;<br></code></pre></p></div>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
          <category> JavaScript </category>
          
          <category> jQuery </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>jQuery选择器+样式操作+动画效果</title>
      <link href="/blog/1_day01_jquery/"/>
      <url>/blog/1_day01_jquery/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h2 id="8Ek4z"><span class="ne-text">jQuery 介绍</span></h2><h3 id="KqIXV"><span class="ne-text">JavaScript 库</span></h3><p id="1182ed20e25accc5fbd9143d687f6c07" class="ne-p"><span class="ne-text">JavaScript库：即 library，是一个封装好的特定的集合（方法和函数）。从封装一大堆函数的角度理解库，就是在这个库中，封装了很多预先定义好的函数在里面，比如动画animate、hide、show，比如获取元素等。</span></p><div class="ne-quote"><p id="89d908b18207376577ae8cc53af60e5c" class="ne-p"><span class="ne-text">简单理解： 就是一个JS 文件，里面对我们原生js代码进行了封装，存放到里面。这样我们可以快速高效的使用这些封装好的功能了。</span></p><p id="a6ec09241f96424cab0d9be5df79a994" class="ne-p"><span class="ne-text">比如 jQuery，就是为了快速方便的操作DOM，里面基本都是函数（方法）。</span></p></div><p id="0427ba38e93e82b2a3d289aa1fc3b4d9" class="ne-p"><span class="ne-text">常见的JavaScript 库：jQuery、Prototype、YUI、Dojo、Ext JS、移动端的zepto等，这些库都是对原生 JavaScript 的封装，内部都是用 JavaScript 实现的。</span></p><h3 id="4SEJ9"><span class="ne-text">jQuery的概念</span></h3><p id="47e5877d4eb321532eccc0128e9515af" class="ne-p"><span class="ne-text">jQuery总体概况如下 :</span></p><ul class="ne-ul"><li id="6fdb9a8e1f3d9da6b783eff0d2f0e8a3"><span class="ne-text">jQuery 是一个快速、简洁的 JavaScript 库，其设计的宗旨是“write Less，Do More”，即倡导写更少的代码，做更多的事情。</span></li><li id="f94375b9bc1b990b73aa941ff7365fbf"><span class="ne-text">j 就是 JavaScript；   Query 查询； 意思就是查询js，把js中的DOM操作做了封装，我们可以快速的查询使用里面的功能。</span></li><li id="70723e35bcaf5be7cc5bd40732363cb3"><span class="ne-text">jQuery 封装了 JavaScript 常用的功能代码，优化了 DOM 操作、事件处理、动画设计和 Ajax 交互。</span></li><li id="934ff02a78cc1adfb530a19375b126ae"><span class="ne-text">学习jQuery本质： 就是学习调用这些函数（方法）。</span></li><li id="7f63453d84012af519d0990d13470253"><span class="ne-text">jQuery 出现的目的是加快前端人员的开发速度，我们可以非常方便的调用和使用它，从而提高开发效率。</span></li></ul><h3 id="34zpI"><span class="ne-text">jQuery的优点</span></h3><ol class="ne-ol"><li id="54115ba1d6e8f841c0e60eb142d7ba7d"><span class="ne-text">轻量级。核心文件才几十kb，不会影响页面加载速度。</span></li><li id="727281aa54326002957b4cb7c923ab55"><span class="ne-text">跨浏览器兼容，基本兼容了现在主流的浏览器。</span></li><li id="6efed6014d1bc336e5f55d5eee4daecc"><span class="ne-text">链式编程、隐式迭代。</span></li><li id="b26b37f7cb86f312d5f27bcc6bc2c448"><span class="ne-text">对事件、样式、动画支持，大大简化了DOM操作。</span></li><li id="6b26dec636a34b31fdd0b573b899c3e1"><span class="ne-text">支持插件扩展开发。有着丰富的第三方的插件，例如：树形菜单、日期控件、轮播图等。</span></li><li id="8c812f001480b530e4aad998df0eca9f"><span class="ne-text">免费、开源。</span></li></ol><h2 id="18WMh"><span class="ne-text">jQuery 的基本使用</span></h2><h3 id="wJ15y"><span class="ne-text">jQuery 的下载</span></h3><p id="867f0b84a73e837656a8e417ea851cc0" class="ne-p"><span class="ne-text">jQuery的官网地址： </span><a href="https://jquery.com/" data-href="https://jquery.com/" target="_blank" class="ne-link"><span class="ne-text">https://jquery.com/</span></a><span class="ne-text">，官网即可下载最新版本。</span></p><div class="ne-quote"><p id="2fef01ecc28078472419fcc46b8fab90" class="ne-p"><span class="ne-text">各个版本的下载：</span><a href="https://code.jquery.com/" data-href="https://code.jquery.com/" target="_blank" class="ne-link"><span class="ne-text">https://code.jquery.com/</span></a></p></div><p id="bd5c5ad29252aa4b3f3f55125afcadcf" class="ne-p"><span class="ne-text">版本介绍：</span></p><div class="ne-quote"><p id="8bddad0a025599de58d1aef78f52bf1b" class="ne-p"><span class="ne-text">1x ：兼容 IE 678 等低版本浏览器， 官网不再更新</span></p><p id="a9d6041ed889a999dc5d2e207deb18b7" class="ne-p"><span class="ne-text">2x ：不兼容 IE 678 等低版本浏览器， 官网不再更新</span></p><p id="dc445a36ad5d4ead3db6ca4c08e263b3" class="ne-p"><span class="ne-text">3x ：不兼容 IE 678 等低版本浏览器， 是官方主要更新维护的版本</span></p></div><h3 id="gQGyH"><span class="ne-text">jQuery的入口函数</span></h3><p id="930452f0e22e096c9e91ba76df805407" class="ne-p"><span class="ne-text">jQuery中常见的两种入口函数：</span></p><pre><code>// 第一种: 简单易用。$(function () &#123;       ...  // 此处是页面 DOM 加载完成的入口&#125;) ; // 第二种: 繁琐，但是也可以实现$(document).ready(function()&#123;   ...  //  此处是页面DOM加载完成的入口&#125;);</code></pre><p id="4137ae0c08ddfbbdc35f9bb25fab0a32" class="ne-p"><span class="ne-text">总结：</span></p><ol class="ne-ol"><li id="702afba3d76b335eb7f5f6ee13d6fb68"><span class="ne-text">等着 DOM 结构渲染完毕即可执行内部代码，不必等到所有外部资源加载完成，jQuery 帮我们完成了封装。</span></li><li id="fef8c6c594017f4a36d613903afcba23"><span class="ne-text">相当于原生 js 中的 DOMContentLoaded。</span></li><li id="3966a73057b576f4fb354b1c319921b6"><span class="ne-text">不同于原生 js 中的 load 事件是等页面文档、外部的 js 文件、css文件、图片加载完毕才执行内部代码。</span></li><li id="e4946db59715c38c5704f0292060129f"><span class="ne-text">更推荐使用第一种方式。</span></li></ol><h3 id="77r7T"><span class="ne-text">jQuery中的顶级对象$</span></h3><ol class="ne-ol"><li id="36d2bcdc0d5dd72ee958df908e2c4c93"><span class="ne-text">$是 jQuery 的别称，在代码中可以使用 jQuery 代替，但一般为了方便，通常都直接使用 $ 。</span></li><li id="a4ed960ba7251da7e7a4fa568a74d579"><span class="ne-text">$是jQuery的顶级对象，相当于原生JavaScript中的 window。把元素利用$包装成jQuery对象，就可以调用jQuery 的方法。</span></li></ol><h3 id="luvkQ"><span class="ne-text">jQuery 对象和 DOM 对象</span></h3><p id="6c165ae2a5431e0e40917ff04cae2b55" class="ne-p"><span class="ne-text">使用 jQuery 方法和原生JS获取的元素是不一样的，总结如下 :</span></p><ol class="ne-ol"><li id="cb1a96b529e1e8c0590a5739529364a3"><span class="ne-text">用原生 JS 获取来的对象就是 DOM 对象</span></li><li id="994792250516d232528543d6adf94dff"><span class="ne-text">jQuery 方法获取的元素就是 jQuery 对象。</span></li><li id="6e09e2361690febe741b4bd8016a0123"><span class="ne-text">jQuery 对象本质是： 利用$对DOM 对象包装后产生的对象（伪数组形式存储）。</span></li></ol><div class="ne-quote"><p id="190b19ef2498ddbda5b40f6fac9f554d" class="ne-p"><span class="ne-text">注意：</span></p><p id="1d18c24b0bbd0ffe0ce089de583233c9" class="ne-p"><span class="ne-text">只有 jQuery 对象才能使用 jQuery 方法，DOM 对象则使用原生的 JavaScirpt 方法。</span></p></div><h3 id="gMhvh"><span class="ne-text">jQuery 对象和 DOM 对象转换</span></h3><p id="c20d3fa584d4735bc1f6fdcf11aaac95" class="ne-p"><span class="ne-text">DOM 对象与 jQuery 对象之间是可以相互转换的。因为原生js 比 jQuery 更大，原生的一些属性和方法 jQuery没有给我们封装. 要想使用这些属性和方法需要把jQuery对象转换为DOM对象才能使用。</span></p><pre><code>// 1.DOM对象转换成jQuery对象，方法只有一种var box = document.getElementById('box');  // 获取DOM对象var jQueryObject = $(box);  // 把DOM对象转换为 jQuery 对象// 2.jQuery 对象转换为 DOM 对象有两种方法：//   2.1 jQuery对象[索引值]var domObject1 = $('div')[0]//   2.2 jQuery对象.get(索引值)var domObject2 = $('div').get(0)</code></pre><p id="b2649e984275afcf11127f6ed1c7f91f" class="ne-p"><span class="ne-text">总结：实际开发比较常用的是把DOM对象转换为jQuery对象，这样能够调用功能更加强大的jQuery中的方法。</span></p><h2 id="ktAhE"><span class="ne-text">jQuery 选择器</span></h2><p id="8d915d7e8be2007eae4e53e7df18a87c" class="ne-p"><span class="ne-text">原生 JS 获取元素方式很多，很杂，而且兼容性情况不一致，因此 jQuery 给我们做了封装，使获取元素统一标准。</span></p><p id="udb9b1577" class="ne-p"><span class="ne-text">参考：</span><a href="https://www.runoob.com/jquery/jquery-selectors.html" data-href="https://www.runoob.com/jquery/jquery-selectors.html" target="_blank" class="ne-link"><span class="ne-text">https://www.runoob.com/jquery/jquery-selectors.html</span></a></p><h3 id="lHMbX"><span class="ne-text">基础选择器</span></h3><pre><code>$(&quot;选择器&quot;)   //  里面选择器直接写 CSS 选择器即可，但是要加引号</code></pre><h3 id="KXygK"><span class="ne-text">层级选择器</span></h3><p id="b9c7844ef17f3fc98abcedfc0c93eb9c" class="ne-p"><span class="ne-text">层级选择器最常用的两个分别为：后代选择器和子代选择器。</span></p><p id="211aa1bc3e828ef4044aaaafc077e7dd" class="ne-p"><strong><span class="ne-text">基础选择器和层级选择器案例代码</span></strong></p><pre><code>&lt;body&gt;    &lt;div&gt;我是div&lt;/div&gt;    &lt;div class=&quot;nav&quot;&gt;我是nav div&lt;/div&gt;    &lt;p&gt;我是p&lt;/p&gt;    &lt;ul&gt;        &lt;li&gt;我是ul 的&lt;/li&gt;        &lt;li&gt;我是ul 的&lt;/li&gt;                &lt;li&gt;我是ul 的&lt;/li&gt;    &lt;/ul&gt;    &lt;script&gt;        $(function() &#123;            console.log($(&quot;.nav&quot;));            console.log($(&quot;ul li&quot;));        &#125;)    &lt;/script&gt;&lt;/body&gt;</code></pre><h3 id="8Ie2G"><span class="ne-text">筛选选择器</span></h3><p id="6b9a2e3242e899100e8da670172def21" class="ne-p"><span class="ne-text">筛选选择器，顾名思义就是在所有的选项中选择满足条件的进行筛选选择。常见如下 :</span></p><pre><code>&lt;body&gt;    &lt;ul&gt;        &lt;li&gt;多个里面筛选几个&lt;/li&gt;        &lt;li&gt;多个里面筛选几个&lt;/li&gt;        &lt;li&gt;多个里面筛选几个&lt;/li&gt;        &lt;li&gt;多个里面筛选几个&lt;/li&gt;        &lt;li&gt;多个里面筛选几个&lt;/li&gt;        &lt;li&gt;多个里面筛选几个&lt;/li&gt;    &lt;/ul&gt;    &lt;ol&gt;        &lt;li&gt;多个里面筛选几个&lt;/li&gt;        &lt;li&gt;多个里面筛选几个&lt;/li&gt;        &lt;li&gt;多个里面筛选几个&lt;/li&gt;        &lt;li&gt;多个里面筛选几个&lt;/li&gt;        &lt;li&gt;多个里面筛选几个&lt;/li&gt;        &lt;li&gt;多个里面筛选几个&lt;/li&gt;    &lt;/ol&gt;    &lt;script&gt;        $(function() &#123;            $(&quot;ul li:first&quot;).css(&quot;color&quot;, &quot;red&quot;);            $(&quot;ul li:eq(2)&quot;).css(&quot;color&quot;, &quot;blue&quot;);            $(&quot;ol li:odd&quot;).css(&quot;color&quot;, &quot;skyblue&quot;);            $(&quot;ol li:even&quot;).css(&quot;color&quot;, &quot;pink&quot;);        &#125;)    &lt;/script&gt;&lt;/body&gt;</code></pre><p id="5616b4eb0ad58311565ee67efc781d46" class="ne-p"><span class="ne-text">另:  jQuery中还有一些筛选方法，类似DOM中的通过一个节点找另外一个节点，父、子、兄以外有所加强。</span></p><p id="42756e9054f54f3b4b93785466b00bc0" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616073490928-8c91de0f-b9b1-41c3-8a06-ab51b23cfb98.png" width="1002" id="oIGOe" class="ne-image"></p><h2 id="THC2V"><span class="ne-text">jQuery 样式操作</span></h2><p id="7af30d2ef8b5bbbfeb1e81a4df86098b" class="ne-p"><span class="ne-text">jQuery中常用的样式操作有两种：css() 和 设置类样式方法</span></p><h3 id="TFScD"><span class="ne-text">方法1: 操作 css 方法</span></h3><p id="6b1cdc342891d41f2302466d0b0ebd33" class="ne-p"><span class="ne-text">jQuery 可以使用 css 方法来修改简单元素样式； 也可以操作类，修改多个样式。常用以下三种形式 :</span></p><pre><code>// 1.参数只写属性名，则是返回属性值var strColor = $(this).css('color');// 2.参数是属性名，属性值，逗号分隔，是设置一组样式，属性必须加引号，值如果是数字可以不用跟单位和引号$(this).css(''color'', ''red'');// 3.  参数可以是对象形式，方便设置多组样式。属性名和属性值用冒号隔开， 属性可以不用加引号$(this).css(&#123; &quot;color&quot;:&quot;white&quot;,&quot;font-size&quot;:&quot;20px&quot;&#125;);</code></pre><p id="7dcd2e5fdb2a96a92824ac0d36473d98" class="ne-p"><span class="ne-text">注意：css() 多用于样式少时操作，多了则不太方便。</span></p><h3 id="jScRR"><span class="ne-text">方法2: 设置类样式方法</span></h3><p id="e0c1ea636dcb2989941876c8fe934775" class="ne-p"><span class="ne-text">作用等同于以前的 classList，可以操作类样式， 注意操作类里面的参数不要加点。常用的三种设置类样式方法：</span></p><pre><code>// 1.添加类$(&quot;div&quot;).addClass(&quot;current&quot;);// 2.删除类$(&quot;div&quot;).removeClass(&quot;current&quot;);// 3.切换类$(&quot;div&quot;).toggleClass(&quot;current&quot;);</code></pre><p id="d0fe2c914d179f1b39eed2ba6b1f99c9" class="ne-p"><span class="ne-text">注意：</span></p><ol class="ne-ol"><li id="b948cd658011062da26edc2fd8cc75c2"><span class="ne-text">设置类样式方法比较适合样式多时操作，可以弥补css()的不足。</span></li><li id="1e301e65e0bdebef5b03d8daec3aaf26"><span class="ne-text">原生 JS 中 className 会覆盖元素原先里面的类名，jQuery 里面类操作只是对指定类进行操作，不影响原先的类名。</span></li></ol><h2 id="NExrh"><span class="ne-text">jQuery 效果</span></h2><p id="09a892292bf997e01b28fd9034e6a6da" class="ne-p"><span class="ne-text">jQuery 给我们封装了很多动画效果，最为常见的如下：</span></p><ul class="ne-ul"><li id="ffa413f426cfa4b6a3c88697b4621ba6"><span class="ne-text">显示隐藏：show() / hide() / toggle() ;</span></li><li id="03430495a40cf5ad63ce6b178ee2bc9d"><span class="ne-text">划入画出：slideDown() / slideUp() / slideToggle() ;</span></li><li id="c351f774709f458e374596f03c13188e"><span class="ne-text">淡入淡出：fadeIn() / fadeOut() / fadeToggle() / fadeTo() ;</span></li><li id="43f14f3792457b4703837fa1a4a61df1"><span class="ne-text">自定义动画：animate() ;</span></li></ul><div class="ne-quote"><p id="e99e03ba521df73423339073ebc39127" class="ne-p"><span class="ne-text">注意：</span></p><p id="d822bcecc9bfebe3c1bc84dae64a1d9f" class="ne-p"><span class="ne-text">动画或者效果一旦触发就会执行，如果多次触发，就造成多个动画或者效果排队执行。</span></p><p id="287cd3b3d4b8ef3bd476fbde0134c041" class="ne-p"><span class="ne-text">jQuery为我们提供另一个方法，可以停止动画排队：stop() ;</span></p></div><h3 id="I8g10"><span class="ne-text">显示隐藏切换</span></h3><p id="ba35a434e38a303b51fe45bb6b2283c9" class="ne-p"><span class="ne-text">显示隐藏动画，常见有三个方法：show() / hide() / toggle() ;</span></p><p id="2ee1cf188e6e4a659376dba53b3dfab4" class="ne-p"><span class="ne-text">语法规范如下:</span></p><p id="416abaa38bfefaa419861d8287198643" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616073491028-773a9d46-839b-4afc-bee1-17d55ed0a4ad.png" width="624" id="q0jwB" class="ne-image"></p><p id="c6c6910b9f6200fa8c9367be6990c80d" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616073491164-e18ddc74-6cd9-4758-98be-8a4ba4a5659b.png" width="624" id="Jbw7X" class="ne-image"></p><p id="5f96e6b2edf4067f78883bba72d320fb" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616073491265-475bb990-b1e3-4aa8-b58a-089a14539935.png" width="625" id="j1sLx" class="ne-image"></p><p id="829da9d5bf2a7ac1d61394ec386f2a96" class="ne-p"><strong><span class="ne-text">代码演示</span></strong></p><pre><code>&lt;body&gt;    &lt;button&gt;显示&lt;/button&gt;    &lt;button&gt;隐藏&lt;/button&gt;    &lt;button&gt;切换&lt;/button&gt;    &lt;div&gt;&lt;/div&gt;    &lt;script&gt;        $(function() &#123;            $(&quot;button&quot;).eq(0).click(function() &#123;                $(&quot;div&quot;).show(1000, function() &#123;                    alert(1);                &#125;);            &#125;)            $(&quot;button&quot;).eq(1).click(function() &#123;                $(&quot;div&quot;).hide(1000, function() &#123;                    alert(1);                &#125;);            &#125;)            $(&quot;button&quot;).eq(2).click(function() &#123;              $(&quot;div&quot;).toggle(1000);            &#125;)            // 一般情况下，我们都不加参数直接显示隐藏就可以了        &#125;);    &lt;/script&gt;&lt;/body&gt;</code></pre><h3 id="CDLRs"><span class="ne-text">滑入滑出</span></h3><p id="80d7ab8a022efd9bee75d2f0266ee9fb" class="ne-p"><span class="ne-text">    滑入滑出动画，常见有三个方法：slideDown() / slideUp() / slideToggle() ;</span></p><p id="7dc11fc9a03cb4dc6729a2db14c5c5d7" class="ne-p"><span class="ne-text">    语法规范如下:</span></p><p id="f4b449101218606ab0bdef84f539bc90" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616073491339-dc77fd79-125f-48b7-a6e8-3d44db54fba8.png" width="624" id="WXVZd" class="ne-image"></p><p id="8c22b416d87c55e443bc009db57f05c0" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616073491433-2cf9c8e4-43ce-4c72-849f-2d23bf822215.png" width="624" id="DlH5f" class="ne-image"></p><p id="f6e22f3389e5c250fc41ebfd1fa1876e" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616073491518-8e00011c-f004-4d1b-81f4-e0ade442f00f.png" width="624" id="L8ZSu" class="ne-image"></p><p id="0342ef4909abaa63c533d2c6e683096e" class="ne-p"><strong><span class="ne-text">代码演示</span></strong></p><pre><code>&lt;body&gt;    &lt;button&gt;下拉滑动&lt;/button&gt;    &lt;button&gt;上拉滑动&lt;/button&gt;    &lt;button&gt;切换滑动&lt;/button&gt;    &lt;div&gt;&lt;/div&gt;    &lt;script&gt;        $(function() &#123;            $(&quot;button&quot;).eq(0).click(function() &#123;                // 下滑动 slideDown()                $(&quot;div&quot;).slideDown();            &#125;)            $(&quot;button&quot;).eq(1).click(function() &#123;                // 上滑动 slideUp()                $(&quot;div&quot;).slideUp(500);            &#125;)            $(&quot;button&quot;).eq(2).click(function() &#123;                // 滑动切换 slideToggle()                $(&quot;div&quot;).slideToggle(500);            &#125;);        &#125;);    &lt;/script&gt;&lt;/body&gt;</code></pre><h3 id="CiMj0"><span class="ne-text">淡入淡出</span></h3><p id="462c12910e033a89114c6d7d41f8b49b" class="ne-p"><span class="ne-text">    淡入淡出动画，常见有四个方法：fadeIn() / fadeOut() / fadeToggle() / fadeTo() ;</span></p><p id="d4f5b63d28c6d4e41ea043204ec3e6c5" class="ne-p"><span class="ne-text">    语法规范如下:</span></p><p id="4af8d14843a6a63e09ae03ac59e38312" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616073491592-b675c8b8-6d7a-40b5-a4be-d51dc9bd1c86.png" width="624" id="bTN9b" class="ne-image"></p><p id="cee2eb25ba4d625f5b8d37430b16171b" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616073491668-703fa0c6-d2f4-48e6-a78c-5db0cb33df17.png" width="624" id="B9SjO" class="ne-image"></p><p id="030f1fd88e9045db226a17a4bce78044" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616073491743-2587d517-38fd-4633-9273-d99234bb35e4.png" width="624" id="lDuyr" class="ne-image"></p><p id="1582730df5ca6787b9552289f39c8678" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616073491838-9409127c-665d-4c7e-b4b0-180ef10ffa61.png" width="664" id="VB0bu" class="ne-image"></p><p id="99b19770e0353d6597f9d0fee0e904c6" class="ne-p"><strong><span class="ne-text">代码演示</span></strong></p><pre><code>&lt;body&gt;    &lt;button&gt;淡入效果&lt;/button&gt;    &lt;button&gt;淡出效果&lt;/button&gt;    &lt;button&gt;淡入淡出切换&lt;/button&gt;    &lt;button&gt;修改透明度&lt;/button&gt;    &lt;div&gt;&lt;/div&gt;    &lt;script&gt;        $(function() &#123;            $(&quot;button&quot;).eq(0).click(function() &#123;                // 淡入 fadeIn()                $(&quot;div&quot;).fadeIn(1000);            &#125;)            $(&quot;button&quot;).eq(1).click(function() &#123;                // 淡出 fadeOut()                $(&quot;div&quot;).fadeOut(1000);            &#125;)            $(&quot;button&quot;).eq(2).click(function() &#123;                // 淡入淡出切换 fadeToggle()                $(&quot;div&quot;).fadeToggle(1000);            &#125;);            $(&quot;button&quot;).eq(3).click(function() &#123;                //  修改透明度 fadeTo() 这个速度和透明度要必须写                $(&quot;div&quot;).fadeTo(1000, 0.5);            &#125;);        &#125;);    &lt;/script&gt;&lt;/body&gt;</code></pre><h3 id="5qt9U"><span class="ne-text">自定义动画</span></h3><p id="94b51ee08aa9de70ccdaf4af4e2d8c54" class="ne-p"><span class="ne-text">自定义动画非常强大，通过参数的传递可以模拟以上所有动画，方法为：animate() ;</span></p><p id="63538bb320e15d684798de366bf5f08e" class="ne-p"><span class="ne-text">语法规范如下:</span></p><p id="5b6452a6bf2aec5a1a52ffc39f496f9d" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616073491922-87ac5de5-e3b5-410a-afee-89e862531e62.png" width="624" id="qdJ6i" class="ne-image"></p><p id="0b52743fd294c7b48e02306787939ecf" class="ne-p"><strong><span class="ne-text">代码演示</span></strong></p><pre><code>&lt;body&gt;    &lt;button&gt;动起来&lt;/button&gt;    &lt;div&gt;&lt;/div&gt;    &lt;script&gt;        $(function() &#123;            $(&quot;button&quot;).click(function() &#123;                $(&quot;div&quot;).animate(&#123;                    left: 500,                    top: 300,                    opacity: .4,                    width: 500                &#125;, 500);            &#125;)        &#125;)    &lt;/script&gt;&lt;/body&gt;</code></pre><h3 id="2pqIY"><span class="ne-text">停止动画排队</span></h3><p id="8617b206957a15f156970392d25d694f" class="ne-p"><span class="ne-text">动画或者效果一旦触发就会执行，如果多次触发，就造成多个动画或者效果排队执行。</span></p><p id="ceade3f7ed7c37ca934aedf9b5c17eb2" class="ne-p"><span class="ne-text">停止动画排队的方法为：stop() ;</span></p><ul class="ne-ul"><li id="e4919040ecd04f675b45b00b2664d8b8"><span class="ne-text">stop() 方法用于停止动画或效果。</span></li><li id="e63109e8006775328abff943efc1510d"><span class="ne-text">stop() 写到动画或者效果的前面， 相当于停止结束上一次的动画。</span></li></ul><p id="b9dc36a4c7653e2a46f4771d932835ea" class="ne-p"><span class="ne-text">总结: 每次使用动画之前，先调用 stop() ,在调用动画。</span></p><h3 id="kiJtl"><span class="ne-text">事件切换hover()</span></h3><p id="8445780ebcf32907088caee425f296c0" class="ne-p"><span class="ne-text">jQuery中为我们添加了一个新事件 hover() ; 功能类似 css 中的伪类 :hover 。介绍如下</span></p><p id="4de11ed9eb7fac9a6a137f01677b2c9a" class="ne-p"><strong><span class="ne-text">语法</span></strong></p><pre><code>hover([over,]out)     // 其中over和out为两个函数</code></pre><ul class="ne-ul"><li id="0fd0f5bb603299c8fe9f560e417e72e4"><span class="ne-text">over:鼠标移到元素上要触发的函数（相当于mouseenter）</span></li><li id="57fddb0388d5f83d790ae99a1397fa49"><span class="ne-text">out:鼠标移出元素要触发的函数（相当于mouseleave）</span></li><li id="9930c2cd83b177ec4b093104f6df99ad"><span class="ne-text">如果只写一个函数，则鼠标经过和离开都会触发它</span></li></ul><p id="e3e188a059e4045dc90d9c249b6c1a43" class="ne-p"><strong><span class="ne-text">hover事件和停止动画排列案例</span></strong></p><pre><code>&lt;body&gt;    &lt;ul class=&quot;nav&quot;&gt;        &lt;li&gt;            &lt;a href=&quot;#&quot;&gt;微博&lt;/a&gt;            &lt;ul&gt;&lt;li&gt;&lt;a href=&quot;&quot;&gt;私信&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;&quot;&gt;评论&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;&quot;&gt;@我&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;        &lt;/li&gt;        &lt;li&gt;            &lt;a href=&quot;#&quot;&gt;微博&lt;/a&gt;            &lt;ul&gt;&lt;li&gt;&lt;a href=&quot;&quot;&gt;私信&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;&quot;&gt;评论&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;&quot;&gt;@我&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;        &lt;/li&gt;    &lt;/ul&gt;    &lt;script&gt;        $(function() &#123;            // 鼠标经过            // $(&quot;.nav&gt;li&quot;).mouseover(function() &#123;            //     // $(this) jQuery 当前元素  this不要加引号            //     // show() 显示元素  hide() 隐藏元素            //     $(this).children(&quot;ul&quot;).slideDown(200);            // &#125;);            // // 鼠标离开            // $(&quot;.nav&gt;li&quot;).mouseout(function() &#123;            //     $(this).children(&quot;ul&quot;).slideUp(200);            // &#125;);            // 1. 事件切换 hover 就是鼠标经过和离开的复合写法            // $(&quot;.nav&gt;li&quot;).hover(function() &#123;            //     $(this).children(&quot;ul&quot;).slideDown(200);            // &#125;, function() &#123;            //     $(this).children(&quot;ul&quot;).slideUp(200);            // &#125;);            // 2. 事件切换 hover  如果只写一个函数，那么鼠标经过和鼠标离开都会触发这个函数            $(&quot;.nav&gt;li&quot;).hover(function() &#123;                // stop 方法必须写到动画的前面                $(this).children(&quot;ul&quot;).stop().slideToggle();            &#125;);        &#125;)    &lt;/script&gt;&lt;/body&gt;</code></pre><h2 id="x3QNW"></h2></div>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
          <category> JavaScript </category>
          
          <category> jQuery </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>计算方法数学部分解法算法</title>
      <link href="/blog/hizlew/"/>
      <url>/blog/hizlew/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="uc3674619" class="ne-p"><span class="ne-text">前言：大三</span><strong><span class="ne-text">计算方法</span></strong><span class="ne-text">课程所有实验报告的流程图，做个存档，以备不时之需~~</span><img src="https://cdn.nlark.com/yuque/0/2021/gif/1484158/1616633908079-3d59dbee-c4dc-4c51-899f-0708e3570b0d.gif" width="100" id="q5k8l" class="ne-image"><span class="ne-text">具体代码改天再找找再放上来。</span></p><p id="u715c090f" class="ne-p"><span class="ne-text"></span></p><p id="u45288615" class="ne-p"><span class="ne-text">目录</span></p><ul class="ne-ul"><li id="ub5e60a7d" data-lake-index-type="0"><span class="ne-text">非线性方程的解法</span></li><li id="uee0b8ede" data-lake-index-type="0"><span class="ne-text">线性方程组的解法</span></li><li id="uffbd453a" data-lake-index-type="0"><span class="ne-text">Hermite插值</span></li><li id="u99f24e01" data-lake-index-type="0"><span class="ne-text">最小二乘算法</span></li><li id="u6877ed26" data-lake-index-type="0"><span class="ne-text">正态分布表复现</span></li></ul><p id="43476ec5ee1337c0526f302132b1eb5a" class="ne-p"><br></p><h2 id="27gMO"><span class="ne-text">非线性方程的解法</span></h2><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1616633610151-eed94d68-d147-4478-9c56-730fbe696d47.jpeg" id="zQMmN" style="display: block; width: 100%"><h2 id="fGbAk"><span class="ne-text">线性方程组的解法</span></h2><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1616633610254-fa45fc83-037a-4ef6-8335-15363df8051a.jpeg" id="uvwN0" style="display: block; width: 100%"><h2 id="6Oij3"><span class="ne-text">Hermite插值</span></h2><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1616633692587-90b66863-8a3c-4b63-8046-674f80dc04d9.jpeg" id="fOBI6" style="display: block; width: 100%"><h2 id="YRxKM"><span class="ne-text">最小二乘算法</span></h2><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1616633747782-b4fd3da7-09fe-4bed-bd37-e9bec306e6a6.jpeg" id="jtqHT" style="display: block; width: 100%"><h2 id="Yu8LW"><span class="ne-text">正态分布表复现</span></h2><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1616633747770-5c3e05b2-2b4a-4187-9aa8-e4063434dfc0.jpeg" id="ZQOdI" style="display: block; width: 100%"></div>]]></content>
      
      
      <categories>
          
          <category> 计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> ⚙️计算算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>响应式布局rem</title>
      <link href="/blog/rm1i2lgosgh2/"/>
      <url>/blog/rm1i2lgosgh2/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h2 id="di2Wv"><span class="ne-text">rem</span></h2><h3 id="Iq49g"><span class="ne-text">em</span></h3><div data-type="danger" class="ne-alert"><ul class="ne-ul"><li id="u876c1de9"><span class="ne-text">相对单位</span></li><li id="u843ab563"><span class="ne-text">em是父元素字体大小</span></li></ul></div><h3 id="EjSri"><span class="ne-text">rem</span></h3><div data-type="danger" class="ne-alert"><ul class="ne-ul"><li id="u88601b52"><span class="ne-text">相对单位</span></li><li id="uc85a19de"><span class="ne-text">rem的基准是相对于html元素的字体大小。</span></li></ul></div><p id="9794fe54ba1509e1addc4fb844c10209" class="ne-p"><span class="ne-text">比如，根元素（html）设置font-size=12px; 非根元素设置width:2rem; 则换成px表示就是24px。</span></p><pre><code>/* 根html 为 12px */html &#123;   font-size: 12px;&#125;/* 此时 div 的字体大小就是 24px */       div &#123;    font-size: 2rem;&#125;</code></pre><p id="83b267967fecdd7b664bb0b08ce1b457" class="ne-p"><span class="ne-text">rem的优势：父元素文字大小可能不一致， 但是整个页面只有一个html，可以很好来控制整个页面的元素大小。</span></p><h3 id="zJUmq"><span class="ne-text">vm和vh</span></h3><ul class="ne-ul"><li id="uac223e5b"><span class="ne-text">视口的宽高</span></li><li id="u693c9403"><span class="ne-text">按照100来划分</span></li></ul><p id="ub948ddb5" class="ne-p"><span class="ne-text">用过的例子：</span></p><pre><code>.test &#123;    height: calc(100vh);    padding: calc((100vh - 60px - 10px) / 4) 10px;&#125;</code></pre><h2 id="nlt2Y"><span class="ne-text">rem适配方案</span></h2><p id="72ccd932e896c120d6d5205580e88fd8" class="ne-p"><span class="ne-text">1.让一些不能等比自适应的元素，达到当设备尺寸发生改变的时候，等比例适配当前设备。</span></p><p id="70fbc3a2e996c196764c6200c9158755" class="ne-p"><span class="ne-text">2.使用媒体查询根据不同设备按比例设置html的字体大小，然后页面元素使用rem做尺寸单位，当html字体大小变化元素尺寸也会发生变化，从而达到等比缩放的适配。</span></p><p id="e9eb1c5f6b036c6037509282a03983df" class="ne-p"><span class="ne-text">技术方案：</span></p><p id="e21f3ae7a185b3d70436fed9a04ca485" class="ne-p"><span class="ne-text">1.less+rem+媒体查询</span></p><p id="479ce89db4df183c888da091a8df805f" class="ne-p"><span class="ne-text">2.lflexible.js+rem</span></p><p id="bbd16f79c8cd0945db7f5f154a826315" class="ne-p"><span class="ne-text">总结：</span></p><p id="006e55f0360a249208d2e260bfd29874" class="ne-p"><span class="ne-text">两种方案现在都存在。</span></p><p id="246c94aafbf7afd64954e2e6e15a3854" class="ne-p"><span class="ne-text">方案2 更简单，现阶段大家无需了解里面的js代码。</span></p><h3 id="lGEBf"><span class="ne-text">rem适配方案1</span></h3><p id="0fabd5e4d19b82930559d17ccaa824e3" class="ne-p"><span class="ne-text">①假设设计稿是750px</span></p><p id="bc78e17155075c61cf0f9f4a677dc540" class="ne-p"><span class="ne-text">②假设我们把整个屏幕划分为15等份（划分标准不一可以是20份也可以是10等份）</span></p><p id="a13c9fcd3659f85ffcbe87f6971de920" class="ne-p"><span class="ne-text">③每一份作为html字体大小，这里就是50px</span></p><p id="7b9bb779c2a2c4535405556e6a1856a0" class="ne-p"><span class="ne-text">④那么在320px设备的时候，字体大小为320/15就是  21.33px</span></p><p id="945a4707c73032b2de9db785cb59d095" class="ne-p"><span class="ne-text">⑤用我们页面元素的大小除以不同的 html字体大小会发现他们比例还是相同的</span></p><p id="7c3a8e052d9361e7ee943c7addfb3554" class="ne-p"><span class="ne-text">⑥比如我们以750为标准设计稿</span></p><p id="2e76cafeb1d872b057b83dc77a75f27a" class="ne-p"><span class="ne-text">⑦一个100</span><em><span class="ne-text">100像素的页面元素在  750屏幕下，  就是 100/ 50  转换为rem  是  2rem</span></em><span class="ne-text">2rem  比例是1比1</span></p><p id="14619e9cfa606e7b11e47d2a435191b1" class="ne-p"><span class="ne-text">⑧320屏幕下，  html字体大小为21.33   则 2rem=  42.66px  此时宽和高都是 42.66  但是宽和高的比例还是 1比1</span></p><p id="fd7677e685482b484c39ab3d358bd4f5" class="ne-p"><span class="ne-text">⑨但是已经能实现不同屏幕下  页面元素盒子等比例缩放的效果</span></p><p id="8fbe03ab6927da91f406c2adf763a33e" class="ne-p"><span class="ne-text">总结：</span></p><p id="dfb56d67ffe1f41a619247b5044ef7a8" class="ne-p"><span class="ne-text">①最后的公式：页面元素的rem值 =  页面元素值（px） /  （屏幕宽度  /  划分的份数）</span></p><p id="0854f6cf818b1d9b145bd5c8dbb5ae33" class="ne-p"><span class="ne-text">②屏幕宽度/划分的份数就是 htmlfont-size 的大小</span></p><p id="459e7a4ad69b867c942824e4d4b2d4db" class="ne-p"><span class="ne-text">③或者：页面元素的rem值 =  页面元素值（px） /  html font-size 字体大小</span></p><h3 id="jNtjj"><span class="ne-text">苏宁首页</span></h3><p id="c5f3a15e766da5beb0f6408a0e189db3" class="ne-p"><span class="ne-text">苏宁首页地址 ：</span><a href="m.suning.com" data-href="m.suning.com" class="ne-link"><span class="ne-text">苏宁首页</span></a></p><p id="5683829706fc014721ec45c0fddf3c86" class="ne-p"><span class="ne-text">1、 技术选型</span></p><p id="90d04822287edfa989ae2506aa58ac30" class="ne-p"><span class="ne-text">方案：我们采取单独制作移动页面方案</span></p><p id="342af9b22f2c90acff2abdc5e0ca9b02" class="ne-p"><span class="ne-text">技术：布局采取rem适配布局（less + rem  + 媒体查询）</span></p><p id="abb16eca1af82ed1bb587067762346cb" class="ne-p"><span class="ne-text">设计图： 本设计图采用 750px 设计尺寸</span></p><p id="ad9ecc98e2a24d594e7262e59b1697f6" class="ne-p"><span class="ne-text">2、搭建文件结构</span></p><p id="0efc58c7090e946f079901a5a5af686b" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/jpg/1484158/1615360325682-7e3f3397-a6e1-47eb-9774-d632ea98c710.jpg" width="466" id="JeBWG" class="ne-image"></p><p id="7d861253120af1ff5071ef59f96b1388" class="ne-p"><span class="ne-text">3、设置视口标签以及引入初始化样式</span></p><pre><code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no,         initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;css/normalize.css&quot;&gt;</code></pre><p id="54b82b94bfd32257df43d14cd8035d4a" class="ne-p"><span class="ne-text">4、设置公共common.less文件</span></p><ul class="ne-ul"><li id="c25e78c15c62fbbb4a10bc895779fb24"><span class="ne-text">新建common.less    设置好最常见的屏幕尺寸，利用媒体查询设置不同的html字体大小，因为除了首页其他页面也需要</span></li><li id="39c5e26a6fce19b056e26b8b8d63b625"><span class="ne-text">我们关心的尺寸有 320px、360px、375px、384px、400px、414px、424px、480px、540px、720px、750px</span></li><li id="96e58eeb513fe7026126ee633b42cf95"><span class="ne-text">划分的份数我们定为 15等份</span></li><li id="6c699bebfbb42c377b14162e869fdcd7"><span class="ne-text">因为我们pc端也可以打开我们苏宁移动端首页，我们默认html字体大小为 50px，注意这句话写到最上面</span></li></ul><h3 id="A1Y4x"><span class="ne-text">rem 适配方案2</span></h3><p id="421b7de7f1346eaf8e7c7edae3e60d45" class="ne-p"><span class="ne-text">手机淘宝团队出的简洁高效 移动端适配库</span></p><p id="f22ae3c8658642db05aa0b948a85e94e" class="ne-p"><span class="ne-text">我们再也不需要在写不同屏幕的媒体查询，因为里面js做了处理</span></p><p id="87934ad09701bbaf47be7b0c6c634318" class="ne-p"><span class="ne-text">它的原理是把当前设备划分为10等份，但是不同设备下，比例还是一致的。</span></p><p id="9a31d36488ef29c7036301acff1ea9e3" class="ne-p"><span class="ne-text">我们要做的，就是确定好我们当前设备的html 文字大小就可以了</span></p><p id="b0cfb361a495ce5c6eb5e9299c4a6a89" class="ne-p"><span class="ne-text">比如当前设计稿是 750px， 那么我们只需要把 html 文字大小设置为 75px(750px / 10) 就可以</span></p><p id="1c408b06482c45277a14102f82633604" class="ne-p"><span class="ne-text">里面页面元素rem值： 页面元素的px 值 /  75</span></p><p id="931f0f2044123e3450f71d104250f23f" class="ne-p"><span class="ne-text">剩余的，让flexible.js来去算</span></p><p id="e962dab7f016e4c01ff7787c69685eaa" class="ne-p"><span class="ne-text">github地址：</span><a href="https://link.jianshu.com/?t=https://github.com/amfe/lib-flexible" data-href="https://link.jianshu.com/?t=https://github.com/amfe/lib-flexible" target="_blank" class="ne-link"><span class="ne-text">https://github.com/amfe/lib-flexible</span></a></p><p id="a7ce2ff53830ba636e2db6c6b7aaeebb" class="ne-p"><span class="ne-text">总结：</span></p><p id="a4ffa14094eedc7a6fdab882c4ce8d23" class="ne-p"><span class="ne-text">因为flexible是默认将屏幕分为10等分</span></p><p id="e48c36b3c59dd21db612887004aeba5c" class="ne-p"><span class="ne-text">但是当屏幕大于750的时候希望不要再去重置html字体了</span></p><p id="15d93bbaa66cb68cf8a746b012424655" class="ne-p"><span class="ne-text">所以要自己通过媒体查询设置一下</span></p><p id="46ca7b65a4e06a8707bb58eb6a2ebb1b" class="ne-p"><span class="ne-text">并且要把权重提到最高</span></p><p id="cd28daa22748ef32f1b13254d7079d11" class="ne-p"><span class="ne-text">VSCode  px 转换rem 插件 cssrem</span></p><p id="2399e7cf6b1aafe65ed9ceae7478d810" class="ne-p"><span class="ne-text">因为cssrem中css自动转化为rem是参照默认插件的16转换的所以需要自己配置</span></p><p id="fd1ec7c8e8205367d56584910bcf7105" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/jpg/1484158/1615360325777-63efe343-7fb5-46ff-a976-757d50df3556.jpg" width="713" id="UABvV" class="ne-image"><img src="https://cdn.nlark.com/yuque/0/2021/jpg/1484158/1615360325891-a1820b7f-bdbf-47e8-b04b-723db8329cf8.jpg" width="566" id="alFe1" class="ne-image"></p><h2 id="liQps"><span class="ne-text">响应式开发原理</span></h2><h3 id="9tybR"><span class="ne-text">响应式开发原理</span></h3><div data-type="success" class="ne-alert"><p id="295fc47ec7030c8a60586927723cff10" class="ne-p"><span class="ne-text">就是使用媒体查询针对不同宽度的设备进行布局和样式的设置，从而适配不同设备的目的</span></p></div><p id="df38333cd1aca3452a0c05f5f2ecd791" class="ne-p"><span class="ne-text">设备的划分情况</span></p><ul class="ne-ul"><li id="18daf0aa56f892429cb4665c8f894e88"><span class="ne-text">小于768的为超小屏幕（手机）</span></li><li id="d8f91fac26a10c5469ef3f219001cfb6"><span class="ne-text">768~992之间的为小屏设备（平板）</span></li><li id="7ae16c51f2202ef45bc671eb86f33558"><span class="ne-text">992~1200的中等屏幕（桌面显示器）</span></li><li id="d8300c847748e7fada9f9cafe0735f10"><span class="ne-text">大于1200的宽屏设备（大桌面显示器）</span></li></ul><h3 id="bKScf"><span class="ne-text">响应式布局容器</span></h3><div data-type="info" class="ne-alert"><p id="fcfaf4bd52142005517e295680216ba9" class="ne-p"><span class="ne-text">响应式需要一个父级做为布局容器，来配合子级元素来实现变化效果。</span></p><p id="d8201961a1ae3342eb92187470a9b0b4" class="ne-p"><span class="ne-text">原理就是在不同屏幕下，通过媒体查询来改变这个布局容器的大小，再改变里面子元素的排列方式和大小，从而实现不同屏幕下，看到不同的页面布局和样式变化。</span></p></div><p id="b78dfdb71954e555a42a5ba55908a10a" class="ne-p"><span class="ne-text">父容器版心的尺寸划分</span></p><ul class="ne-ul"><li id="12ca9ef7f4888c66bc08fe1ea1d8233f"><span class="ne-text">超小屏幕（手机，小于 768px）：设置宽度为 100%</span></li><li id="a0d552a99518fe4c8b5f9e995693ed9f"><span class="ne-text">小屏幕（平板，大于等于 768px）：设置宽度为 750px</span></li><li id="24333d919c22c372cf04d4eeec590266"><span class="ne-text">中等屏幕（桌面显示器，大于等于 992px）：宽度设置为 970px</span></li><li id="a1f154c1bb235302656b0fd8c75f1231"><span class="ne-text">大屏幕（大桌面显示器，大于等于 1200px）：宽度设置为 1170px</span></li></ul><p id="300bf3d5f63e5c09c0e2c9a4e2643243" class="ne-p"><span class="ne-text">但是我们也可以根据实际情况自己定义划分</span></p></div>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
          <category> HTML+CSS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Flex布局</title>
      <link href="/blog/ogynfghwtsa7/"/>
      <url>/blog/ogynfghwtsa7/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h2 id="uextT"><span class="ne-text">flex布局原理</span></h2><ul class="ne-ul"><li id="4641d586b67817f416de2a5f3e5bf6e0"><span class="ne-text">flex 是 flexible Box 的缩写，意为&quot;弹性布局&quot;，用来为盒状模型提供最大的灵活性，任何一个容器都可以指定为 flex 布局。</span></li><li id="6b7990dc2c54d02b8778b8bd0643896d"><span class="ne-text">当我们为父盒子设为 flex 布局以后，子元素的 float、clear 和 vertical-align 属性将失效。</span></li><li id="06bf7504af475a9813718a5218cd058a"><span class="ne-text">flex布局又叫伸缩布局 、弹性布局 、伸缩盒布局 、弹性盒布局</span></li><li id="ecdd1b91b949fd3ce6dead99a38ccd8c"><span class="ne-text">采用 Flex 布局的元素，称为 Flex 容器（flex</span></li></ul><p id="3afae559b46cfd8ccaed336730ffbcb8" class="ne-p"><span class="ne-text">container），简称&quot;容器&quot;。它的所有子元素自动成为容器成员，称为 Flex 项目（flex</span></p><p id="90300683e7b4b3835bc800fa73e079e1" class="ne-p"><span class="ne-text">item），简称&quot;项目&quot;。</span></p><p id="159e1bdb88544fa763b9fa33f8a69db7" class="ne-p"><strong><span class="ne-text">总结</span></strong><span class="ne-text">：就是通过给父盒子添加flex属性，来控制子盒子的位置和排列方式</span></p><h2 id="JWis1"><span class="ne-text">父项常见属性</span></h2><ul class="ne-ul"><li id="b823754e73b6319e580583ff1182e0d0"><span class="ne-text">flex-direction：设置主轴的方向</span></li><li id="db8e2987cdd403f2a59746cc782b1508"><span class="ne-text">justify-content：设置主轴上的子元素排列方式</span></li><li id="68bc1c65af5bbb39a9883447cea32907"><span class="ne-text">flex-wrap：设置子元素是否换行</span></li><li id="b56793027cc608d909118811f4fb6e3b"><span class="ne-text">align-content：设置侧轴上的子元素的排列方式（多行）</span></li><li id="52c02f2f8fa2b16a7c561eee3f6b8cfb"><span class="ne-text">align-items：设置侧轴上的子元素排列方式（单行）</span></li><li id="0b25460301aec512ff08504603d7e166"><span class="ne-text">flex-flow：复合属性，相当于同时设置了 flex-direction 和 flex-wrap</span></li></ul><h3 id="TWwcR"><span class="ne-text">flex-direction设置主轴的方向</span></h3><ul class="ne-ul"><li id="17a64700d6bf0e26f65a67e6bad5db92"><span class="ne-text">在 flex 布局中，是分为主轴和侧轴两个方向，同样的叫法有 ： 行和列、x 轴和y 轴</span></li><li id="313115a9c216db17eea25dad0edab817"><span class="ne-text">默认主轴方向就是 x 轴方向，水平向右</span></li><li id="4734be80603f500f47d575bf3b6776da"><span class="ne-text">默认侧轴方向就是 y 轴方向，水平向下</span></li></ul><p id="4d5aa5ac16192614c134ef8792dfd4df" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1615561167817-709457f2-58f3-47b2-82f2-36a27c5ffbac.png" width="485" id="cmnlC" class="ne-image"></p><ul class="ne-ul"><li id="16f34e0e11dfd0c58fbaefc3c12401e9"><span class="ne-text">注意： 主轴和侧轴是会变化的，就看 flex-direction 设置谁为主轴，剩下的就是侧轴。而我们的子元素是跟着主轴来排列的</span></li></ul><p id="u5b5e1785" class="ne-p"><span class="ne-text"></span></p><p id="f99db99500e1337f8924eca3a2517e0e" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1615561179498-b513941e-0741-403e-a156-bf3794692e74.png" width="463.5" id="p4Lox" class="ne-image"></p><h3 id="V5Jhm"><span class="ne-text">justify-content 设置主轴上的子元素排列方式</span></h3><p id="5b3fc1a0ad8baaf0468d30f2c83108b9" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1615561189187-37fb2250-6a7a-4b7e-8da7-8bfbed134942.png" width="614" id="Ucr9M" class="ne-image"></p><h3 id="Nm7PW"><span class="ne-text">flex-wrap设置是否换行</span></h3><ul class="ne-ul"><li id="b3612a7815994c14c468bb3b8485f358"><span class="ne-text">默认情况下，项目都排在一条线（又称”轴线”）上。flex-wrap属性定义，flex布局中默认是不换行的。</span></li><li id="eba8dc63cb97b7e2ffb9c2c528fa6648"><span class="ne-text">nowrap 不换行</span></li><li id="ff0ab6d6ee5d9835c03306ff602add24"><span class="ne-text">wrap 换行</span></li></ul><h3 id="EZp2l"><span class="ne-text">align-items 设置侧轴上的子元素排列方式（单行 ）</span></h3><ul class="ne-ul"><li id="018ecaeab353d72404753e6fc8bcd205"><span class="ne-text">该属性是控制子项在侧轴（默认是y轴）上的排列方式  在子项为单项（单行）的时候使用</span></li><li id="9a5b5622b2ee3bf3d1168a3f1d01bd16"><span class="ne-text">flex-start 从头部开始</span></li><li id="d7cd2384dbbb1ba09cf5972040075289"><span class="ne-text">flex-end 从尾部开始</span></li><li id="7ed5e14b71d688301deec4fa7918cd0d"><span class="ne-text">center 居中显示</span></li><li id="dc05ed293e836ef3de9756c479bf6670"><span class="ne-text">stretch 拉伸</span></li></ul><h3 id="BNYTF"><span class="ne-text">align-content  设置侧轴上的子元素的排列方式（多行）</span></h3><p id="7973d0841f73d45571d9e9df87b95b68" class="ne-p"><span class="ne-text">设置子项在侧轴上的排列方式 并且只能用于子项出现 换行 的情况（多行），在单行下是没有效果的。</span></p><p id="450ba76159bc9a969fd603e70a5615f4" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1615561203043-769de419-37f6-47ac-8a01-7353fb2fbcd4.png" width="542" id="C4BgP" class="ne-image"></p><h3 id="WbfsQ"><span class="ne-text">align-content 和align-items区别</span></h3><ul class="ne-ul"><li id="d658600aec23697915a23530805b5b2a"><span class="ne-text">align-items  适用于单行情况下， 只有上对齐、下对齐、居中和 拉伸</span></li><li id="7263d49e37aa9db3dec13f9264ba1200"><span class="ne-text">align-content适应于换行（多行）的情况下（单行情况下无效）， 可以设置 上对齐、下对齐、居中、拉伸以及平均分配剩余空间等属性值。</span></li><li id="d93fb4b456ed4e4eadbce54cbdc23e0c"><span class="ne-text">总结就是单行找align-items  多行找 align-content</span></li></ul><h3 id="mNc0j"><span class="ne-text">flex-flow 属性是 flex-direction 和 flex-wrap 属性的复合属性</span></h3><pre><code>flex-flow:row wrap;</code></pre><h2 id="Mc8HC"><span class="ne-text">flex布局子项常见属性</span></h2><ul class="ne-ul"><li id="55fc33f9eb6697b685614141c9066557"><span class="ne-text">flex子项目占的份数</span></li><li id="5dcd0eafa6fd8700ca2cbc030c6420ee"><span class="ne-text">align-self控制子项自己在侧轴的排列方式</span></li><li id="b4dff300df24f3d15c639111c46a84b1"><span class="ne-text">order属性定义子项的排列顺序（前后顺序）</span></li></ul><h3 id="pJZVV"><span class="ne-text">flex 属性</span></h3><p id="945d7173aeb46338f01aacf272a8cdef" class="ne-p"><span class="ne-text">flex 属性定义子项目分配剩余空间，用flex来表示占多少份数。</span></p><pre><code>.item &#123;    flex: &lt;number&gt;; /* 默认值 0 */&#125;</code></pre><h3 id="Zg5De"><span class="ne-text">align-self控制子项自己在侧轴上的排列方式</span></h3><p id="015ee5a428996ea1c44d89c086632a5f" class="ne-p"><span class="ne-text">align-self 属性允许单个项目有与其他项目不一样的对齐方式，可覆盖 align-items 属性。</span></p><p id="1130288394efc75ec8e6107000cfa89f" class="ne-p"><span class="ne-text">默认值为 auto，表示继承父元素的 align-items 属性，如果没有父元素，则等同于 stretch。</span></p><pre><code>span:nth-child(2) &#123;      /* 设置自己在侧轴上的排列方式 */      align-self: flex-end;&#125;</code></pre><h3 id="nogLK"><span class="ne-text">order 属性定义项目的排列顺序</span></h3><p id="2fe6cf3e8589b179bf9f58a254c26185" class="ne-p"><span class="ne-text">数值越小，排列越靠前，默认为0。</span></p><p id="48c1abdf0b4380be44712312a681e847" class="ne-p"><span class="ne-text">注意：和 z-index 不一样。</span></p><pre><code>.item &#123;    order: &lt;number&gt;;&#125;</code></pre><h2 id="fqJAn"><span class="ne-text">携程网首页案例制作</span></h2><p id="4c42d29f9679b39d6a46dee2f04f7617" class="ne-p"><span class="ne-text">携程网链接：</span><a href="http://m.ctrip.com" data-href="http://m.ctrip.com" target="_blank" class="ne-link"><span class="ne-text">http://m.ctrip.com</span></a></p><p id="bb30fb4a553196661876850e3eb722af" class="ne-p"><span class="ne-text">1.技术选型</span></p><p id="ec5fe9ea8b49f67a58214508dcb65a84" class="ne-p"><span class="ne-text">方案：我们采取单独制作移动页面方案</span></p><p id="a228b77a49f9b2bfb9fd6e903d8148ee" class="ne-p"><span class="ne-text">技术：布局采取flex布局</span></p><p id="abff4b8f88d360e6d777f9824517589e" class="ne-p"><span class="ne-text">2.搭建相关文件夹</span></p><p id="21af76ebfc98f12813d36e8f6d3e89b3" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1615561216425-7cb96807-082c-4f58-a8e6-7fd089ad6c35.png" width="194" id="RYYOf" class="ne-image"></p><p id="87675e462c5b518fe45c310745b077c5" class="ne-p"><span class="ne-text">3.设置视口标签以及引入初始化样式</span></p><pre><code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no,initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;css/normalize.css&quot;&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;css/index.css&quot;&gt;</code></pre><p id="1d303f7680d961e7f410b7995b7c2fa4" class="ne-p"><span class="ne-text">4.常用初始化样式</span></p><pre><code>body &#123;  max-width: 540px;  min-width: 320px;  margin: 0 auto;  font: normal 14px/1.5 Tahoma,&quot;Lucida Grande&quot;,Verdana,&quot;Microsoft Yahei&quot;,STXihei,hei;  color: #000;  background: #f2f2f2;  overflow-x: hidden;  -webkit-tap-highlight-color: transparent;&#125;</code></pre><p id="3dad3ae7d3793f495517aaa1cea1cafe" class="ne-p"><span class="ne-text">5.模块名字划分</span></p><p id="8f82a5428aa90eb86100221cd52e6e3f" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1615561231614-a9ccc256-3219-41a4-a610-588d72137519.png" width="517.5" id="A2cyp" class="ne-image"></p></div>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
          <category> HTML+CSS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>百分比布局</title>
      <link href="/blog/oxqtosvrfeg8/"/>
      <url>/blog/oxqtosvrfeg8/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h2 id="6oTsX"><span class="ne-text">meta标签viewport</span></h2><p id="uee036b2f" class="ne-p"><br></p><p id="770978c4aa3b4bccc710aa4fe5a55bdd" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1615360134988-de179521-dfc1-419f-a1b6-5e45b5b40096.png" width="1043" id="IIJLj" class="ne-image"></p><h2 id="2hDHo"><span class="ne-text">normalize.css</span></h2><p id="ec551c93bcab2996bf33232a61a2a5bf" class="ne-p"><span class="ne-text">移动端 CSS 初始化推荐使用 normalize.css/</span></p><p id="af02910c3aefafb0e9d646a2c81c0e23" class="ne-p"><span class="ne-text">Normalize.css：保护了有价值的默认值</span></p><p id="fa70175d47970c925f56b7a844bf0752" class="ne-p"><span class="ne-text">Normalize.css：修复了浏览器的bug</span></p><p id="5ebc772fdaba896863a433e28ac5f67c" class="ne-p"><span class="ne-text">Normalize.css：是模块化的</span></p><p id="8be05c9f23069cb701ea13274d073012" class="ne-p"><span class="ne-text">Normalize.css：拥有详细的文档</span></p><p id="19eca2d97cc15ebf95dddfbb11422d3b" class="ne-p"><span class="ne-text">官网地址： </span><a href="http://necolas.github.io/normalize.css/" data-href="http://necolas.github.io/normalize.css/" target="_blank" class="ne-link"><span class="ne-text">http://necolas.github.io/normalize.css/</span></a></p><h2 id="IpFMf"><span class="ne-text">box-sizing</span></h2><div data-type="danger" class="ne-alert"><p id="78cb920c38acc26b0208ead9a5246b94" class="ne-p"><span class="ne-text">传统模式宽度计算：盒子的宽度 = CSS中设置的width + border + padding</span></p></div><div data-type="success" class="ne-alert"><p id="241d7c01ea8bbb781df383a25eaed6c3" class="ne-p"><span class="ne-text">CSS3盒子模型：盒子的宽度=  CSS中设置的宽度width 里面包含了 border 和 padding</span></p></div><p id="8d97bd396911cca22eb2595f00be8672" class="ne-p"><span class="ne-text">也就是说，我们的CSS3中的盒子模型， padding 和 border 不会撑大盒子了</span></p><pre><code>/*CSS3盒子模型*/box-sizing: border-box;/*传统盒子模型*/box-sizing: content-box;</code></pre><p id="892b3e63b59ca750957572aa57c42683" class="ne-p"><span class="ne-text">移动端可以全部CSS3 盒子模型</span></p><div data-type="danger" class="ne-alert"><p id="ac1830f00ab6326d34aaac3a73118a94" class="ne-p"><span class="ne-text">PC端如果完全需要兼容，我们就用传统模式，如果不考虑兼容性，我们就选择 CSS3 盒子模型</span></p></div><p id="9eaec18c8a81c19d1900c25c4837fb1f" class="ne-p"><br></p><pre><code>-webkit-box-sizing: border-box              /* CSS3盒模型 */-moz-box-sizing: border-box                 /* CSS3盒模型 */box-sizing: border-box                      /* CSS3盒模型 */</code></pre><h3 id="btPxJ"><span class="ne-text">移动端特殊样式</span></h3><pre><code>/*CSS3盒子模型*/    box-sizing: border-box;    -webkit-box-sizing: border-box;    /*点击高亮我们需要清除清除  设置为transparent 完成透明*/    -webkit-tap-highlight-color: transparent;    /*在移动端浏览器默认的外观在iOS上加上这个属性才能给按钮和输入框自定义样式*/    -webkit-appearance: none;    /*禁用长按页面时的弹出菜单*/    img,a &#123; -webkit-touch-callout: none; &#125;</code></pre><h2 id="3b1Sw"><span class="ne-text">移动端常见布局</span></h2><h3 id="GSP4w"><span class="ne-text">移动端单独制作</span></h3><div data-type="success" class="ne-alert"><p id="88cf1185b32f87d64bbd9bff44e9a662" class="ne-p"><span class="ne-text">流式布局（百分比布局）</span></p></div><p id="9f3abf9c2b3779387c5e07ce199bdee3" class="ne-p"><span class="ne-text">流式布局，就是百分比布局，也称非固定像素布局。通过盒子的宽度设置成百分比来根据屏幕的宽度来进行伸缩，不受固定像素的限制，内容向两侧填充。流式布局方式是移动web开发使用的比较常见的布局方式。</span></p><p id="e9b3459c824ce950fc1603e31ed3dd80" class="ne-p"><br></p></div>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
          <category> HTML+CSS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CSS选择器总结</title>
      <link href="/blog/01_html5css3_day01/"/>
      <url>/blog/01_html5css3_day01/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h2 id="WOt8C"><span class="ne-text">选择器</span></h2><p id="ud2f5741e" class="ne-p"><span class="ne-text">CSS选择器分为基础选择器和复合选择器.</span></p><h3 id="syHma"><span class="ne-text">基础选择器</span></h3><ol class="ne-ol"><li id="ua77bca62" data-lake-index-type="0"><span class="ne-text">标签选择器（元素选择器）</span></li><li id="uc5c85ec2" data-lake-index-type="0"><span class="ne-text">类选择器</span></li><li id="udd6a0a39" data-lake-index-type="0"><span class="ne-text">id选择器</span></li><li id="ud7fd2c4c" data-lake-index-type="0"><span class="ne-text">通配符选择器</span></li></ol><h3 id="HvZl4"><span class="ne-text">后代选择器( )</span></h3><pre><code><code>.class h3&#123;  color:red;  font-size:16px;&#125;</code></code></pre><h3 id="GDsx0"><span class="ne-text">子元素选择器(&gt;)</span></h3><pre><code><code>.class&gt;h3&#123;  color:red;  font-size:14px;&#125;</code></code></pre><h3 id="AE4h0"><span class="ne-text">交集选择器(.)</span></h3><pre><code><code>p.one &#123;  /*  */&#125;</code></code></pre><h3 id="okTVH"><span class="ne-text">并集选择器(,)</span></h3><pre><code><code>.one, p , #test &#123;  color: #F00;&#125; </code></code></pre><h3 id="Gwu8B"><span class="ne-text">~ +</span></h3><ul class="ne-ul"><li id="u35799911" data-lake-index-type="0"><span class="ne-text">A ~ B表示选择A标签后的所有B标签，但是A和B标签必须有相同的父元素。</span></li><li id="ud021d744" data-lake-index-type="0"><span class="ne-text">A+B表示选择紧邻在A后面的B元素，且A和B必须拥有相同的父元素，所选到的仅为一个B元素标签</span></li></ul><h3 id="vKNbA"><span class="ne-text">链接伪类选择器</span></h3><ul class="ne-ul"><li id="f7c52037e88328555502fc29a8e0986c" data-lake-index-type="0"><span class="ne-text">a:link      /</span><em><span class="ne-text"> 未访问的链接 </span></em><span class="ne-text">/</span></li><li id="d4dd471b8880f202504a7dd5a7f865e1" data-lake-index-type="0"><span class="ne-text">a:visited   /</span><em><span class="ne-text"> 已访问的链接 </span></em><span class="ne-text">/</span></li><li id="238594354804660610d7325df097ca3a" data-lake-index-type="0"><span class="ne-text">a:hover     /</span><em><span class="ne-text"> 鼠标移动到链接上 </span></em><span class="ne-text">/</span></li><li id="11bf9fa717b673cd2e98b8601026b665" data-lake-index-type="0"><span class="ne-text">a:active    /</span><em><span class="ne-text"> 选定的链接 </span></em><span class="ne-text">/</span></li><li id="98a61817e929def698d7be74e93f946e" data-lake-index-type="0"><span class="ne-text">注意：写的时候，他们的顺序尽量不要颠倒  按照  lvha 的顺序。否则可能引起错误。</span></li></ul><pre><code><code>/* a是标签选择器  所有的链接 */a &#123;     font-weight: 700;  font-size: 16px;  color: gray;&#125;/* :hover 是链接伪类选择器 鼠标经过 */a:hover &#123;     color: red; &#125;</code></code></pre><h2 id="uWQ1h"><span class="ne-text">CSS3选择器</span></h2><h3 id="b6TVm"><span class="ne-text">属性选择器</span></h3><p id="u459eab15" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1615560941419-cf3cbc9c-220a-40a1-8f0b-ed243d38a53e.png" width="600.5" id="dIQ5a" class="ne-image"></p><h3 id="V3rR6"><span class="ne-text">结构伪类选择器<br /></span><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1615560953518-b31659af-60a9-425e-a173-c52117fa5ce1.png" width="597.5" id="hq2VM" class="ne-image"></h3><pre><code><code>ul li:first-child &#123;  background-color: lightseagreen;&#125;ul li:last-child &#123;  background-color: lightcoral;&#125;ul li:nth-child(3) &#123;  background-color: aqua;&#125;</code></code></pre><h3 id="YlqpL"><span class="ne-text">nth-child</span></h3><ul class="ne-ul"><li id="092416165a91ed83b3f4637074e64513" data-lake-index-type="0"><span class="ne-text">注意：本质上就是选中第几个子元素</span></li><li id="afddd891cd4f34b5920e6f6214068824" data-lake-index-type="0"><span class="ne-text">n 可以是数字、关键字、公式</span></li><li id="8b385ad8a1c63c87737292fc488285dc" data-lake-index-type="0"><span class="ne-text">n 如果是数字，就是选中第几个</span></li><li id="b9bef76a807c4d3c8906d6fe52e0f441" data-lake-index-type="0"><span class="ne-text">常见的关键字有 </span><code class="ne-code"><span class="ne-text">even</span></code><span class="ne-text"> 偶数、</span><code class="ne-code"><span class="ne-text">odd</span></code><span class="ne-text"> 奇数</span></li><li id="745b8fab5750bc03454142923612578f" data-lake-index-type="0"><span class="ne-text">常见的公式如下(如果 n 是公式，则从 0 开始计算)</span></li><li id="1dbd88449fda90ad526e3bf7c0bdefa2" data-lake-index-type="0" style="text-align: left"><span class="ne-text">但是第 0 个元素或者超出了元素的个数会被忽略</span></li></ul><p id="u116d68c1" class="ne-p"><span class="ne-text"></span><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1615560964893-79ea2620-3fbe-4c17-93b7-f8f9ce6f681e.png" width="570" id="kxWK9" class="ne-image"></p><pre><code><code>/* 偶数 */ul li:nth-child(even) &#123;  background-color: aquamarine;&#125;/* 奇数 */ul li:nth-child(odd) &#123;  background-color: blueviolet;&#125;/*n 是公式，从 0 开始计算 */ul li:nth-child(n) &#123;  background-color: lightcoral;&#125;/* 偶数 */ul li:nth-child(2n) &#123;  background-color: lightskyblue;&#125;/* 奇数 */ul li:nth-child(2n + 1) &#123;  background-color: lightsalmon;&#125;/* 选择第 0 5 10 15, 应该怎么选 */ul li:nth-child(5n) &#123;  background-color: orangered;&#125;/* n + 5 就是从第5个开始往后选择 */ul li:nth-child(n + 5) &#123;  background-color: peru;&#125;/* -n + 5 前五个 */ul li:nth-child(-n + 5) &#123;  background-color: tan;&#125;</code></code></pre><h3 id="8alEL"><code class="ne-code"><span class="ne-text">nth-child</span></code><span class="ne-text"> 和  </span><code class="ne-code"><span class="ne-text">nt-of-type</span></code><span class="ne-text"> 的区别</span></h3><ol class="ne-ol"><li id="6a240e0cd5e0c67010c5f3140df6633c" data-lake-index-type="0"><span class="ne-text">代码演示</span></li></ol><pre><code><code>&lt;style&gt;  div :nth-child(1) &#123;    background-color: lightblue;  &#125;  div :nth-child(2) &#123;    background-color: lightpink;  &#125;  div span:nth-of-type(2) &#123;    background-color: lightseagreen;  &#125;  div span:nth-of-type(3) &#123;    background-color: #fff;  &#125;&lt;/style&gt;</code></code></pre><ol start="2" class="ne-ol"><li id="ca32b21dadd45a60b2ff6b9db9b12b60" data-lake-index-type="0"><span class="ne-text">区别</span></li></ol><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="65611212985ee293f0e2691f38a41d9f" data-lake-index-type="0"><code class="ne-code"><span class="ne-text">nth-child</span></code><span class="ne-text">  选择父元素里面的第几个子元素，不管是第几个类型</span></li><li id="a2e4284d7c41056b0d557b989fd53911" data-lake-index-type="0"><code class="ne-code"><span class="ne-text">nt-of-type</span></code><span class="ne-text">  选择指定类型的元素</span></li></ul></ul><h3 id="chOOD"><span class="ne-text">伪元素选择器</span></h3><p id="uea7e74c0" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1615560977673-8652488a-11a5-4e15-8f24-b93bdf1b9c88.png" width="602" id="KcslO" class="ne-image"></p><ul class="ne-ul"><li id="43fbfea61483d3ea1aaf9dd700d0829c" data-lake-index-type="0"><code class="ne-code"><span class="ne-text">before</span></code><span class="ne-text"> 和 </span><code class="ne-code"><span class="ne-text">after</span></code><span class="ne-text"> 必须有 </span><code class="ne-code"><span class="ne-text">content</span></code><span class="ne-text"> 属性</span></li><li id="14ee139319e92aea7c4a006b4b69bd99" data-lake-index-type="0"><code class="ne-code"><span class="ne-text">before</span></code><span class="ne-text"> 在内容前面，after 在内容后面</span></li><li id="a84cef62487caf1c7cc693d57649be93" data-lake-index-type="0"><code class="ne-code"><span class="ne-text">before</span></code><span class="ne-text"> 和 </span><code class="ne-code"><span class="ne-text">after</span></code><span class="ne-text"> 创建的是一个元素，但是属于行内元素</span></li><li id="5f41383361181c53de49a5978f450ae7" data-lake-index-type="0"><span class="ne-text">创建出来的元素在 </span><code class="ne-code"><span class="ne-text">Dom</span></code><span class="ne-text"> 中查找不到，所以称为伪元素</span></li><li id="c7405c74bc396e916e548cded122cc8d" data-lake-index-type="0"><span class="ne-text">伪元素和标签选择器一样，权重为 1</span></li></ul><h3 id="C7n01"></h3></div>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
          <category> HTML+CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> todo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS中的2D动画</title>
      <link href="/blog/02_html5css3_day02/"/>
      <url>/blog/02_html5css3_day02/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="u0a2c16c8" class="ne-p"><span class="ne-text">前言: CSS中的</span><code class="ne-code"><span class="ne-text">2D</span></code><span class="ne-text"> 转换是指改变标签在二维平面上的位置和形状</span></p><ul class="ne-ul"><li id="u61a2caa8" data-lake-index-type="0"><span class="ne-text">移动： </span><code class="ne-code"><span class="ne-text">translate</span></code></li><li id="ufc051c4c" data-lake-index-type="0"><span class="ne-text">旋转： </span><code class="ne-code"><span class="ne-text">rotate</span></code></li><li id="u5061fe50" data-lake-index-type="0"><span class="ne-text">缩放： </span><code class="ne-code"><span class="ne-text">scale</span></code></li></ul><h2 id="translate"><span class="ne-text">translate</span></h2><ul class="ne-ul"><li id="79be9c9fbcb091ba060718be95280000" data-lake-index-type="0"><span class="ne-text">x 就是 x 轴上水平移动</span></li><li id="c24748c65334ee0efc958660ab76c083" data-lake-index-type="0"><span class="ne-text">y 就是 y 轴上水平移动</span></li></ul><pre><code><code>transform: translate(x, y)transform: translateX(n)transfrom: translateY(n)</code></code></pre><ul class="ne-ul"><li id="6386d541bfeb5fd27f0ea33e3ba3dd05" data-lake-index-type="0"><code class="ne-code"><span class="ne-text">2D</span></code><span class="ne-text"> 的移动主要是指 水平、垂直方向上的移动</span></li><li id="d7cb5914dd63811c7f6a7ea7c611f628" data-lake-index-type="0"><code class="ne-code"><span class="ne-text">translate</span></code><span class="ne-text"> 最大的优点就是不影响其他元素的位置</span></li><li id="d26465f9a0ddb8661c05ffdbe2509935" data-lake-index-type="0"><code class="ne-code"><span class="ne-text">translate</span></code><span class="ne-text"> 中的100%单位，</span><span class="ne-text" style="background-color: rgba(255, 255, 255, 0)">是相对于本身的宽度和高度来进行计算的</span></li></ul><p id="851bb8235374656b9795f978b628c308" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616205104693-ec7eec39-aa37-44fe-879c-3f9b7dd4e90d.png" width="960" id="lYB1a" class="ne-image"></p><div class="ne-quote"><p id="a4926865550eb4a68091f9f5c8b62900" class="ne-p"><span class="ne-text">这也是盒子居中的另一种方法</span></p></div><ul class="ne-ul"><li id="9e5a6d19c6d0452cb65e86e47bbdaa7e" data-lake-index-type="0"><span class="ne-text">行内标签没有效果</span></li></ul><p id="47e0413776abdd3c20d89e91712693b7" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616204546631-96431c20-82e7-4d39-8f87-3bd6a2ab3be4.png" width="960" id="iatwu" class="ne-image"></p><p id="31e3079277e44a4617cb419853dee25d" class="ne-p"><br></p><h2 id="BhXls"><span class="ne-text">rotate</span></h2><ol class="ne-ol"><li id="b464f405f16fa4a40a7709f352b096e0" data-lake-index-type="0"><span class="ne-text">rotate 旋转</span></li></ol><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="ecf4367280a1e92318f25f6077deffca" data-lake-index-type="0"><code class="ne-code"><span class="ne-text">2D</span></code><span class="ne-text"> 旋转指的是让元素在二维平面内顺时针或者逆时针旋转</span></li></ul></ul><ol start="2" class="ne-ol"><li id="a705fbf254cbfe658524ec0b99062903" data-lake-index-type="0"><code class="ne-code"><span class="ne-text">rotate</span></code><span class="ne-text"> 语法</span></li></ol><pre><code><code>/* 单位是：deg */transform: rotate(度数)</code></code></pre><ol start="3" class="ne-ol"><li id="46c2d83b4692eaf97374e327747b6249" data-lake-index-type="0"><span class="ne-text">重点知识点</span></li></ol><ul class="ne-ul"><li id="f2da925ee2fedc12956630c73280dcab" data-lake-index-type="0"><code class="ne-code"><span class="ne-text">rotate</span></code><span class="ne-text"> 里面跟度数，单位是 </span><code class="ne-code"><span class="ne-text">deg</span></code></li><li id="cebb988d11cb7dc9f88900f6aecc3e01" data-lake-index-type="0"><span class="ne-text">角度为正时，顺时针，角度为负时，逆时针</span></li><li id="24af52f34750a97ab517a145522c4a51" data-lake-index-type="0"><span class="ne-text">默认旋转的中心点是元素的中心点</span></li></ul><ol start="4" class="ne-ol"><li id="cef2c77309c566b376bddd5a1d39a500" data-lake-index-type="0"><span class="ne-text">代码演示</span></li></ol><pre><code><code>img:hover &#123;  transform: rotate(360deg)&#125;</code></code></pre><p id="u9eb369c3" class="ne-p"><br></p><div class="ne-quote"><p id="4b51da4b42192910373ea1d79d3735cd" class="ne-p"><span class="ne-text">2d旋转指的是让元素在2维平面内顺时针旋转或者逆时针旋转</span></p></div><p id="f05ed87ad9287f6f052c2a24caf18dd9" class="ne-p"><span class="ne-text">使用步骤：</span></p><ol class="ne-ol"><li id="bce316654b08f530874cfd23d43d810d" data-lake-index-type="0"><span class="ne-text">给元素添加转换属性 </span><code class="ne-code"><span class="ne-text">transform</span></code></li><li id="14386718e69af881fc5f1eff1a86f0b2" data-lake-index-type="0"><span class="ne-text">属性值为 </span><code class="ne-code"><span class="ne-text">rotate(角度)</span></code><span class="ne-text">  如 </span><code class="ne-code"><span class="ne-text">transform:rotate(30deg)</span></code><span class="ne-text">  顺时针方向旋转</span><strong><span class="ne-text">30度</span></strong></li></ol><pre><code><code>div&#123;      transform: rotate(0deg);&#125;</code></code></pre><h3 id="HwzBc"><span class="ne-text">设置元素旋转中心点(transform-origin)</span></h3><ol class="ne-ol"><li id="adb4753e4a270d584f12c09682615e41" data-lake-index-type="0"><code class="ne-code"><span class="ne-text">transform-origin</span></code><span class="ne-text"> 基础语法</span></li></ol><pre><code><code>transform-origin: x y;</code></code></pre><ol start="2" class="ne-ol"><li id="cee08e784ba923f5e267daf35124e308" data-lake-index-type="0"><span class="ne-text">重要知识点</span></li></ol><ul class="ne-ul"><li id="180f2ab50fa9f9c5de29aa4e0c20f4c1" data-lake-index-type="0"><span class="ne-text">注意后面的参数 x 和 y 用空格隔开</span></li><li id="86d555901d4b58d053701187f0dfe875" data-lake-index-type="0"><span class="ne-text">x y 默认旋转的中心点是元素的中心 (50% 50%)，等价于 </span><code class="ne-code"><span class="ne-text">center</span></code><span class="ne-text">  </span><code class="ne-code"><span class="ne-text">center</span></code></li><li id="31ee1b02316ca940d687efbf7c172c75" data-lake-index-type="0"><span class="ne-text">还可以给 x y 设置像素或者方位名词(</span><code class="ne-code"><span class="ne-text">top</span></code><span class="ne-text">、</span><code class="ne-code"><span class="ne-text">bottom</span></code><span class="ne-text">、</span><code class="ne-code"><span class="ne-text">left</span></code><span class="ne-text">、</span><code class="ne-code"><span class="ne-text">right</span></code><span class="ne-text">、</span><code class="ne-code"><span class="ne-text">center</span></code><span class="ne-text">)</span></li></ul><h2 id="wkK66"><code class="ne-code"><span class="ne-text">scale</span></code></h2><ol class="ne-ol"><li id="939b55284a600b32b1c39e537becf79f" data-lake-index-type="0"><code class="ne-code"><span class="ne-text">scale</span></code><span class="ne-text"> 的作用</span></li></ol><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="e0d29c29abe3cc16f88a39cc034b6ea0" data-lake-index-type="0"><span class="ne-text">用来控制元素的放大与缩小</span></li></ul></ul><ol start="2" class="ne-ol"><li id="cb92b81fb026b4f43eb3ad72898c9eec" data-lake-index-type="0"><span class="ne-text">语法</span></li></ol><pre><code><code>transform: scale(x, y)</code></code></pre><ol class="ne-ol"><li id="ae5866f258d33ca07600e7158b734a31" data-lake-index-type="0"><span class="ne-text">知识要点</span></li></ol><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="84ac319006cba66341289ead9ae0aadd" data-lake-index-type="0"><span class="ne-text">注意，x 与 y 之间使用逗号进行分隔</span></li><li id="7e0e04e294deb8edced84f5c2ea9dde5" data-lake-index-type="0"><code class="ne-code"><span class="ne-text">transform: scale(1, 1)</span></code><span class="ne-text">: 宽高都放大一倍，相当于没有放大</span></li><li id="b7e4683300c8349216973c02920656bb" data-lake-index-type="0"><code class="ne-code"><span class="ne-text">transform: scale(2, 2)</span></code><span class="ne-text">: 宽和高都放大了二倍</span></li><li id="767a6adbf3b25919c026f8092a36f2c3" data-lake-index-type="0"><code class="ne-code"><span class="ne-text">transform: scale(2)</span></code><span class="ne-text">: 如果只写了一个参数，第二个参数就和第一个参数一致</span></li><li id="c3b8bd26961f86ac3f214d9df6ff7ad2" data-lake-index-type="0"><code class="ne-code"><span class="ne-text">transform:scale(0.5, 0.5)</span></code><span class="ne-text">: 缩小</span></li><li id="ea48b7f68ca0889ade4c6266ec09bf5f" data-lake-index-type="0"><code class="ne-code"><span class="ne-text">scale</span></code><span class="ne-text"> 最大的优势：可以设置转换中心点缩放，默认以中心点缩放，而且不影响其他盒子</span></li></ul></ul><ol start="2" class="ne-ol"><li id="ba63f7717247be9fb4808fa0a07b7131" data-lake-index-type="0"><span class="ne-text">代码演示</span></li></ol><pre><code><code>div:hover &#123;       /* 注意，数字是倍数的含义，所以不需要加单位 */       /* transform: scale(2, 2) */   <pre><code>   /* 实现等比缩放，同时修改宽与高 */   /* transform: scale(2) */   /* 小于 1 就等于缩放*/   transform: scale(0.5, 0.5)</code></pre><p>   }</code><br></code></pre></p><h2 id="wfwBH"></h2><h2 id="F5eZJ"><span class="ne-text">translate rotate scale 相关问题</span></h2><ol class="ne-ol"><li id="4cebe013202d86f01cf36605d64132e5" data-lake-index-type="0"><span class="ne-text">知识要点</span></li></ol><ul class="ne-ul"><li id="457a91980e350f6a665ce8d7523f44e6" data-lake-index-type="0"><span class="ne-text">同时使用多个转换，其格式为 </span><code class="ne-code"><span class="ne-text">transform: translate() rotate() scale()</span></code></li><li id="9bf3347d5f62e79639829072dd0ff377" data-lake-index-type="0"><span class="ne-text">顺序会影响到转换的效果(先旋转会改变坐标轴方向)</span></li><li id="8f0d86537398ab4a4d2fc85440284d33" data-lake-index-type="0"><span class="ne-text">但我们同时有位置或者其他属性的时候，要将位移放到最前面</span></li></ul><ol start="2" class="ne-ol"><li id="42db8af2ee71a774d78f6d8eabbb1a8d" data-lake-index-type="0"><span class="ne-text">代码演示</span></li></ol><pre><code><code>div:hover &#123;  transform: translate(200px, 0) rotate(360deg) scale(1.2)&#125;</code></code></pre><h2 id="w9cCQ"><span class="ne-text">animation</span></h2><ol class="ne-ol"><li id="61500cbf461ed1471eecb272946dd1f7" data-lake-index-type="0"><span class="ne-text">什么是动画</span></li></ol><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="03409d0983e9faab0440f9caeaca4dc7" data-lake-index-type="0"><span class="ne-text">动画是 </span><code class="ne-code"><span class="ne-text">CSS3</span></code><span class="ne-text"> 中最具颠覆性的特征之一，可通过设置多个节点来精确的控制一个或者一组动画，从而实现复杂的动画效果</span></li></ul></ul><ol start="2" class="ne-ol"><li id="e0d55a514b73df27ba2376f80552708d" data-lake-index-type="0"><span class="ne-text">动画的基本使用</span></li></ol><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="3110b6fbaf8a8b4a39350cdebf507e43" data-lake-index-type="0"><span class="ne-text">先定义动画</span></li><li id="332dce494df8de0e3e88ccf2427e9768" data-lake-index-type="0"><span class="ne-text">在调用定义好的动画</span></li></ul></ul><ol start="3" class="ne-ol"><li id="cca4817af470ea63e876c21facf03d38" data-lake-index-type="0"><span class="ne-text">语法格式(定义动画)</span></li></ol><pre><code><code>@keyframes 动画名称 &#123;    0% &#123;        width: 100px;    &#125;    100% &#123;        width: 200px    &#125;&#125;</code></code></pre><details class="lake-collapse"><summary id="ue26dfa1b"><span class="ne-text">代码演示</span></summary><pre><code><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;  &lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot; /&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot; /&gt;    &lt;title&gt;Document&lt;/title&gt;    &lt;style&gt;      @keyframes move &#123;        from &#123;          transform: translate(-50px, -50px) rotate(0deg) scale(1, 1);        &#125;        50% &#123;          transform: rotate(180deg) scale(3, 3);        &#125;        to &#123;          transform: translate(0, 0) rotate(360deg) scale(1, 1);        &#125;      &#125;      .box &#123;        margin-left: 200px;        margin-top: 100px;        width: 500px;        height: 500px;        border: 1px red solid;      &#125;      /*  */      .box1 &#123;        width: 50px;        height: 50px;        background-color: aqua;        text-align: center;        line-height: 50px;        animation-name: move;        /* 运动时间 */        animation-duration: 3s;        /* 动画次数 */        /* animation-iteration-count: infinite; */        /* 来回运动 */        /* animation-direction: alternate; */      &#125;    &lt;/style&gt;  &lt;/head&gt;<p>  &lt;body&gt;<br>    &lt;div class=&quot;box&quot;&gt;<br>      &lt;div class=&quot;box1&quot;&gt;6&lt;/div&gt;<br>    &lt;/div&gt;<br>  &lt;/body&gt;<br>&lt;/html&gt;<br></code><br></code></pre></p><p id="u7dca9d77" class="ne-p"><br></p></details><p id="u995046d0" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/gif/1484158/1669282734997-95ad5c3a-1c93-4408-8a0d-039a34aa0898.gif" width="512" id="u956cc3e3" class="ne-image"></p><ol start="4" class="ne-ol"><li id="ua40da46c" data-lake-index-type="0"><span class="ne-text">动画序列</span></li></ol><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="883898f79fcae5714aedd5f1e91e3b12" data-lake-index-type="0"><span class="ne-text">0% 是动画的开始，100 % 是动画的完成，这样的规则就是动画序列</span></li><li id="4ce200efbc2e814feabd5c904b0c71a0" data-lake-index-type="0"><span class="ne-text">在 </span><em><span class="ne-text">@</span></em><span class="ne-text">keyframs  中规定某项 CSS 样式，就由创建当前样式逐渐改为新样式的动画效果 </span></li><li id="0d9772729dbba6d4f2343def8e6bb77f" data-lake-index-type="0"><span class="ne-text">动画是使元素从一个样式逐渐变化为另一个样式的效果，可以改变任意多的样式任意多的次数</span></li><li id="5923a5881f6bffc9a56671f22d207c7b" data-lake-index-type="0"><span class="ne-text">用百分比来规定变化发生的时间，或用 </span><code class="ne-code"><span class="ne-text">from</span></code><span class="ne-text"> 和 </span><code class="ne-code"><span class="ne-text">to</span></code><span class="ne-text">，等同于 0% 和 100%</span></li></ul></ul><h3 id="pmAhO"><span class="ne-text">动画常见属性</span></h3><ol class="ne-ol"><li id="1be96e164f13cbdaf16c2451e38033f2" data-lake-index-type="0"><span class="ne-text">常见的属性</span></li></ol><p id="4382f77869387647d5b3e1acc5234c78" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1615561017110-4a2da65a-dd0d-42e6-b3cf-b4f698e56f95.png" width="602.5" id="uwLLK" class="ne-image"></p><ol start="2" class="ne-ol"><li id="937fc40a74a817e22968d47bb3747cff" data-lake-index-type="0"><span class="ne-text">代码演示</span></li></ol><pre><code><code>div &#123;  width: 100px;  height: 100px;  background-color: aquamarine;  /* 动画名称 */  animation-name: move;  /* 动画花费时长 */  animation-duration: 2s;  /* 动画速度曲线 */  animation-timing-function: ease-in-out;  /* 动画等待多长时间执行 */  animation-delay: 2s;  /* 规定动画播放次数 infinite: 无限循环 */  animation-iteration-count: infinite;  /* 是否逆行播放 */  animation-direction: alternate;  /* 动画结束之后的状态 */  animation-fill-mode: forwards;&#125;div:hover &#123;  /* 规定动画是否暂停或者播放 */  animation-play-state: paused;&#125;</code></code></pre><h3 id="qcgBN"><span class="ne-text">动画简写方式</span></h3><ol class="ne-ol"><li id="d5c2dae0bfba40ca421ed7c6968c39cf" data-lake-index-type="0"><span class="ne-text">动画简写方式</span></li></ol><pre><code><code>/* animation: 动画名称 持续时间 运动曲线 何时开始 播放次数 是否反方向 起始与结束状态 */animation: name duration timing-function delay iteration-count direction fill-mode</code></code></pre><ol start="2" class="ne-ol"><li id="e25b7e0ab44fa6f12f438883dfc5b374" data-lake-index-type="0"><span class="ne-text">知识要点</span></li></ol><ul class="ne-ul"><li id="a8f3e5f1361dfeb24cffa6bada70c486" data-lake-index-type="0"><span class="ne-text">简写属性里面不包含 </span><code class="ne-code"><span class="ne-text">animation-paly-state</span></code></li><li id="627e851573eed2fd79193f212d510144" data-lake-index-type="0"><span class="ne-text">暂停动画 </span><code class="ne-code"><span class="ne-text">animation-paly-state: paused</span></code><span class="ne-text">; 经常和鼠标经过等其他配合使用</span></li><li id="5636018db8a71f8385b17ab30d17bc72" data-lake-index-type="0"><span class="ne-text">要想动画走回来，而不是直接调回来：</span><code class="ne-code"><span class="ne-text">animation-direction: alternate</span></code></li><li id="a306cf97c153b6fbf9e8dc1abd178034" data-lake-index-type="0"><span class="ne-text">盒子动画结束后，停在结束位置：</span><code class="ne-code"><span class="ne-text">animation-fill-mode: forwards</span></code></li></ul><ol start="3" class="ne-ol"><li id="015cc67f23dd0724f488f1d170bc5f20" data-lake-index-type="0"><span class="ne-text">代码演示</span></li></ol><pre><code><code>animation: move 2s linear 1s infinite alternate forwards;</code></code></pre><h3 id="OCxWb"><span class="ne-text">速度曲线细节</span></h3><ol class="ne-ol"><li id="7943349b59d1d14af0dcce535167a70f" data-lake-index-type="0"><span class="ne-text">速度曲线细节</span></li></ol><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="66d53ce3d67e36c89fffeae9793191fe" data-lake-index-type="0"><code class="ne-code"><span class="ne-text">animation-timing-function</span></code><span class="ne-text">: 规定动画的速度曲线，默认是</span><code class="ne-code"><span class="ne-text">ease</span></code></li></ul></ul><p id="ef10f6cd9275725090820c0912495131" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1615561032196-9bb59857-8c59-4c84-a309-c7018dfc0d17.png" width="617.5" id="Rf1vn" class="ne-image"></p><ol start="2" class="ne-ol"><li id="acf203371dd584f3e9d1320e7f1c66fc" data-lake-index-type="0"><span class="ne-text">代码演示</span></li></ol><pre><code><code>div &#123;  width: 0px;  height: 50px;  line-height: 50px;  white-space: nowrap;  overflow: hidden;  background-color: aquamarine;  animation: move 4s steps(24) forwards;&#125;@keyframes move &#123;  0% &#123;    width: 0px;  &#125;  100% &#123;    width: 480px;  &#125;&#125;</code></code></pre></div>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
          <category> HTML+CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> todo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS3的3D效果</title>
      <link href="/blog/03_html5css3_day03/"/>
      <url>/blog/03_html5css3_day03/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h2 id="gg8e7"><span class="ne-text">一、 认识 </span><code class="ne-code"><span class="ne-text">3D</span></code><span class="ne-text"> 转换</span></h2><ol class="ne-ol"><li id="6a8943a427946ad326f216bebbb85c8c"><code class="ne-code"><span class="ne-text">3D</span></code><span class="ne-text"> 的特点</span></li></ol><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="de1118194a467567a8c9f026bdbc1607"><span class="ne-text">近大远小</span></li><li id="4837dc465064a20d75132f232dfd44fe"><span class="ne-text">物体和面遮挡不可见</span></li></ul></ul><ol start="2" class="ne-ol"><li id="09beb4ea5c1f403d57366f79c8c65365"><span class="ne-text">三维坐标系</span></li></ol><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="d8b9f5e23ba2ae5795261f4a92b29f82"><span class="ne-text">x 轴：水平向右  -- </span><strong><span class="ne-text">注意：x 轴右边是正值，左边是负值</span></strong></li><li id="5f4ab0c95dbfc804c3170e411c15411d"><span class="ne-text">y 轴：垂直向下  -- </span><strong><span class="ne-text">注意：y 轴下面是正值，上面是负值</span></strong></li><li id="711d2793702c464daa838a1e6a22bd0a"><span class="ne-text">z 轴：垂直屏幕  --  </span><strong><span class="ne-text">注意：往外边的是正值，往里面的是负值</span></strong><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1615561054770-fd36ec08-dafd-4b7b-b075-847435ec7bed.png" width="482.5" id="Ca0uC" class="ne-image"></li></ul></ul><h2 id="19d2w"><span class="ne-text">二、</span><code class="ne-code"><span class="ne-text">3D</span></code><span class="ne-text"> 转换</span></h2><ol class="ne-ol"><li id="2456bb67f8e3c54d36c8d0c411aa571a"><code class="ne-code"><span class="ne-text">3D</span></code><span class="ne-text"> 转换知识要点</span></li></ol><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="df809b141b43e83b168de1507d26d385"><code class="ne-code"><span class="ne-text">3D</span></code><span class="ne-text"> 位移：</span><code class="ne-code"><span class="ne-text">translate3d(x, y, z)</span></code></li><li id="0888bd2e128d5d0ab0b9f9b1f548c2a6"><code class="ne-code"><span class="ne-text">3D</span></code><span class="ne-text"> 旋转：</span><code class="ne-code"><span class="ne-text">rotate3d(x, y, z)</span></code></li><li id="a61be4446f63ad635bfea4b076c7e382"><span class="ne-text">透视：</span><code class="ne-code"><span class="ne-text">perspctive</span></code></li><li id="c2353e1e14cee59a4da5899f5287b067"><code class="ne-code"><span class="ne-text">3D</span></code><span class="ne-text">呈现 </span><code class="ne-code"><span class="ne-text">transfrom-style</span></code></li></ul></ul><ol start="2" class="ne-ol"><li id="6e8f3bf37e2d8523b7dc599db6d3d8ce"><code class="ne-code"><span class="ne-text">3D</span></code><span class="ne-text"> 移动 </span><code class="ne-code"><span class="ne-text">translate3d</span></code></li></ol><ul class="ne-ul"><li id="8ab6b2d4a9daf4dffa4a3632cf611be6"><code class="ne-code"><span class="ne-text">3D</span></code><span class="ne-text"> 移动就是在 </span><code class="ne-code"><span class="ne-text">2D</span></code><span class="ne-text"> 移动的基础上多加了一个可以移动的方向，就是 z 轴方向</span></li><li id="75ba3ffa547715357e657bfad3e1a214"><code class="ne-code"><span class="ne-text">transform: translateX(100px)</span></code><span class="ne-text">：仅仅是在 x 轴上移动</span></li><li id="024409b747e6c611a69ea95153c01e32"><code class="ne-code"><span class="ne-text">transform: translateY(100px)</span></code><span class="ne-text">：仅仅是在 y 轴上移动</span></li><li id="9f27c7b6366d07981e13e6c8d105379f"><code class="ne-code"><span class="ne-text">transform: translateZ(100px)</span></code><span class="ne-text">：仅仅是在 z 轴上移动</span></li><li id="11984676632e214933a41a567c797f39"><code class="ne-code"><span class="ne-text">transform: translate3d(x, y, z)</span></code><span class="ne-text">：其中x、y、z 分别指要移动的轴的方向的距离</span></li><li id="6e1bd39915c9ae56b80ca30b34ab53fd"><strong><span class="ne-text">注意：x, y, z 对应的值不能省略，不需要填写用 0 进行填充</span></strong></li></ul><ol start="3" class="ne-ol"><li id="6e60e2414dfa03caececa3835c560a1a"><span class="ne-text">语法</span></li></ol><pre><code>transform: translate3d(x, y, z)</code></pre><ol start="4" class="ne-ol"><li id="983c48c63729c399a367eb2e6c3b9eb0"><span class="ne-text">代码演示</span></li></ol><pre><code>transform: translate3d(100px, 100px, 100px)/* 注意：x, y, z 对应的值不能省略，不需要填写用 0 进行填充 */transform: translate3d(100px, 100px, 0)</code></pre><h2 id="DmKKA"><span class="ne-text">三、透视 </span><code class="ne-code"><span class="ne-text">perspective</span></code></h2><ol class="ne-ol"><li id="97f74a97faf7bb3b2cf1c8c78e916b76"><span class="ne-text">知识点讲解</span></li></ol><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="57e6b4c49415fb7ebc3c1c1c5af5d89d"><span class="ne-text">如果想要网页产生 </span><code class="ne-code"><span class="ne-text">3D</span></code><span class="ne-text"> 效果需要透视(理解成 </span><code class="ne-code"><span class="ne-text">3D</span></code><span class="ne-text"> 物体投影的 </span><code class="ne-code"><span class="ne-text">2D</span></code><span class="ne-text"> 平面上)</span></li><li id="4d55bd37fcbe53224610decdeca037cd"><span class="ne-text">实际上模仿人类的视觉位置，可视为安排一直眼睛去看</span></li><li id="f912e39364efb7b98a05f620d7f665d3"><span class="ne-text">透视也称为视距，所谓的视距就是人的眼睛到屏幕的距离</span></li><li id="212cfbc8765f3a1622430e11e24e5c66"><span class="ne-text">距离视觉点越近的在电脑平面成像越大，越远成像越小</span></li><li id="540f0fb0ab711174cfb6789dc23c1492"><span class="ne-text">透视的单位是像素</span></li></ul></ul><ol start="2" class="ne-ol"><li id="bdb689472a04e97bcc160c30c047f711"><span class="ne-text">知识要点</span></li></ol><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="1fed3529dd50f83abe26063f06416609"><strong><span class="ne-text">透视需要写在被视察元素的父盒子上面</span></strong></li><li id="0e16c08e2b966c20e74018dae7d311ff"><span class="ne-text">注意下方图片</span></li></ul></ul><ul class="ne-list-wrap"><ul class="ne-list-wrap"><ul ne-level="2" class="ne-ul"><li id="3763d8cb6956d6956d157a22f54d44a2"><span class="ne-text">d：就是视距，视距就是指人的眼睛到屏幕的距离</span></li><li id="f265e4eaa9beef675ee628666c5ab02a"><span class="ne-text">z：就是 z 轴，z 轴越大(正值)，我们看到的物体就越大</span><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1615561069343-d9028767-2dde-4e2f-8d2e-a1066091d6f4.png" width="428" id="Jguym" class="ne-image"></li></ul></ul></ul><ol start="3" class="ne-ol"><li id="993a3610463c7841aa119bcede0f1d01"><span class="ne-text">代码演示</span></li></ol><pre><code>body &#123;  perspective: 1000px;&#125;</code></pre><h2 id="GqRGF"><span class="ne-text">四、 </span><code class="ne-code"><span class="ne-text">translateZ</span></code></h2><ol class="ne-ol"><li id="134cc6ae321724eaff238ca73d5ba740"><code class="ne-code"><span class="ne-text">translateZ</span></code><span class="ne-text"> 与 </span><code class="ne-code"><span class="ne-text">perspecitve</span></code><span class="ne-text"> 的区别</span></li></ol><ul class="ne-ul"><li id="410f503784cb158bd0292c3e37625636"><code class="ne-code"><span class="ne-text">perspecitve</span></code><span class="ne-text"> 给父级进行设置，</span><code class="ne-code"><span class="ne-text">translateZ</span></code><span class="ne-text"> 给 子元素进行设置不同的大小</span></li></ul><h2 id="RJRWd"><span class="ne-text">五、</span><code class="ne-code"><span class="ne-text">3D</span></code><span class="ne-text"> 旋转</span><code class="ne-code"><span class="ne-text">rotateX</span></code></h2><div class="ne-quote"><p id="b43070cdd7aeb4839f900490305f8021" class="ne-p"><span class="ne-text">3D 旋转指可以让元素在三维平面内沿着 x 轴、y 轴、z 轴 或者自定义轴进行旋转</span></p></div><ol class="ne-ol"><li id="cd40d1e84d3dd8c584d1454850bc582d"><span class="ne-text">语法</span></li></ol><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="c20eb1afbd47f21924b75b92f3811b6f"><code class="ne-code"><span class="ne-text">transform: rotateX(45deg)</span></code><span class="ne-text"> -- 沿着 x 轴正方向旋转 45 度</span></li><li id="23bda4d627b45f0757e7e2d7bbe41a70"><code class="ne-code"><span class="ne-text">transform: rotateY(45deg)</span></code><span class="ne-text"> -- 沿着 y 轴正方向旋转 45 度</span></li><li id="8c99d7d60a335b2f3d6cf621c9b4bf47"><code class="ne-code"><span class="ne-text">transform: rotateZ(45deg)</span></code><span class="ne-text"> -- 沿着 z 轴正方向旋转 45 度</span></li><li id="7d2dd0fe7b3507ea8b2fe1779647f689"><code class="ne-code"><span class="ne-text">transform: rotate3d(x, y, z, 45deg)</span></code><span class="ne-text"> -- 沿着自定义轴旋转 45 deg 为角度</span></li></ul></ul><ol start="2" class="ne-ol"><li id="6a0b2ec4fd6fd872151a2a8981a4796a"><span class="ne-text">代码案例</span></li></ol><pre><code>div &#123;  perspective: 300px;&#125;img &#123;  display: block;  margin: 100px auto;  transition: all 1s;&#125;img:hover &#123;  transform: rotateX(-45deg)&#125;</code></pre><ol start="3" class="ne-ol"><li id="aa4eb50708eb9265b2443a59425e2752"><span class="ne-text">左手准则</span></li></ol><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="fbc244c4a19b0c8e3216979ebc41db7e"><span class="ne-text">左手的手拇指指向 x 轴的正方向</span></li><li id="98e6444702c6334f422363d653bdcbcf"><span class="ne-text">其余手指的弯曲方向就是该元素沿着 x 轴旋转的方向</span><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1615561085007-085d7541-71bf-4dd9-bb17-f69476ba1a47.png" width="525" id="Q2KAY" class="ne-image"></li></ul></ul><h2 id="SPeAj"><span class="ne-text">六、</span><code class="ne-code"><span class="ne-text">3D</span></code><span class="ne-text"> 旋转 </span><code class="ne-code"><span class="ne-text">rotateY</span></code></h2><ol class="ne-ol"><li id="79a37132f70ba794bad1374b3be49098"><span class="ne-text">代码演示</span></li></ol><pre><code>div &#123;  perspective: 500px;&#125;img &#123;  display: block;  margin: 100px auto;  transition: all 1s;&#125;img:hover &#123;  transform: rotateY(180deg)&#125;</code></pre><ol start="2" class="ne-ol"><li id="5f1b9c2daecabe49422ea4fd44b6d37a"><span class="ne-text">左手准则</span></li></ol><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="4bd8a468434dea375a8c1f64ed4121e7"><span class="ne-text">左手的拇指指向 y 轴的正方向</span></li><li id="dfd8ce08cfc0e02dd4d4405f702fc908"><span class="ne-text">其余的手指弯曲方向就是该元素沿着 y 轴旋转的方向(正值)</span></li></ul></ul><p id="cc487b98018b91ef20255d9c7be9fcc8" class="ne-p" style="margin-left: 2em"><br></p><p id="c0d836522c5b69f2f610e499704a6cda" class="ne-p" style="margin-left: 2em"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1615561115468-180fac93-a772-4b1f-8067-d49baaa69573.png" width="475" id="kQmph" class="ne-image"></p><h2 id="Uu8ef"><span class="ne-text">七、 </span><code class="ne-code"><span class="ne-text">3D</span></code><span class="ne-text"> 旋转 </span><code class="ne-code"><span class="ne-text">rotateZ</span></code></h2><ol class="ne-ol"><li id="937701eb3c83fb9ec6a0eedea4cdd659"><span class="ne-text">代码演示</span></li></ol><pre><code>div &#123;  perspective: 500px;&#125;img &#123;  display: block;  margin: 100px auto;  transition: all 1s;&#125;img:hover &#123;  transform: rotateZ(180deg)&#125;</code></pre><ol start="2" class="ne-ol"><li id="ddb921dd95f860b7b67073a35b113e48"><code class="ne-code"><span class="ne-text">rotate3d</span></code></li></ol><ul class="ne-ul"><li id="a7883ac2c47b88a5f7249a59e83cefe7"><code class="ne-code"><span class="ne-text">transform: rotate3d(x, y, z, deg)</span></code><span class="ne-text"> -- 沿着自定义轴旋转 deg 为角度</span></li><li id="b2f407e560af3630a666984b0f1c7472"><span class="ne-text">x, y, z 表示旋转轴的矢量，是标识你是否希望沿着该轴进行旋转，最后一个标识旋转的角度</span></li></ul><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="268ac0a8d29ef59103036e7b14f7ed3b"><code class="ne-code"><span class="ne-text">transform: rotate3d(1, 1, 0, 180deg)</span></code><span class="ne-text"> -- 沿着对角线旋转 45deg</span></li><li id="bcf7471439009f2d0d71a110610bca8d"><code class="ne-code"><span class="ne-text">transform: rotate3d(1, 0, 0, 180deg)</span></code><span class="ne-text"> -- 沿着 x 轴旋转 45deg</span></li></ul></ul><ol start="3" class="ne-ol"><li id="5281401e5215ad9f154bdb33fe53096e"><span class="ne-text">代码演示</span></li></ol><pre><code>div &#123;  perspective: 500px;&#125;img &#123;  display: block;  margin: 100px auto;  transition: all 1s;&#125;img:hover &#123;  transform: rotate3d(1, 1, 0, 180deg)&#125;</code></pre><h2 id="LxsRM"><span class="ne-text">八、</span><code class="ne-code"><span class="ne-text">3D</span></code><span class="ne-text"> 呈现 </span><code class="ne-code"><span class="ne-text">transform-style</span></code></h2><ol class="ne-list-wrap"><ol ne-level="1" class="ne-ol"><li id="3f964fbbdc50f66c8b579965a409b21f"><code class="ne-code"><span class="ne-text">transform-style</span></code></li></ol></ol><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="29b0c81191db3289ab4903ce3a6955e6"><span class="ne-text">☆☆☆☆☆</span></li><li id="74725547c6008ae93de0153860ed2e7a"><span class="ne-text">控制子元素是否开启三维立体环境</span></li><li id="0a8473fe37574c7a8036a023bc17b293"><code class="ne-code"><span class="ne-text">transform-style: flat</span></code><span class="ne-text">  代表子元素不开启 </span><code class="ne-code"><span class="ne-text">3D</span></code><span class="ne-text"> 立体空间，默认的</span></li><li id="78f4271ffedb7dfa8f7f84771991f584"><code class="ne-code"><span class="ne-text">transform-style: preserve-3d</span></code><span class="ne-text"> 子元素开启立体空间</span></li><li id="124fd07856c3d7916b85f4bcd9e44b27"><span class="ne-text">代码写给父级，但是影响的是子盒子</span></li></ul></ul><ol class="ne-list-wrap"><ol start="2" ne-level="1" class="ne-ol"><li id="08cb7891d17722257deee751811e8255"><span class="ne-text">代码演示</span></li></ol></ol></div>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
          <category> HTML+CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> todo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA当中栈和队列常用方法</title>
      <link href="/blog/oylyeh/"/>
      <url>/blog/oylyeh/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><div class="ne-quote"><p id="ed13560de6a7ec9b1eda86979c2cc929" class="ne-p"><span class="ne-text">Java里有一个叫做Stack的类，却没有叫做Queue的类（它是个接口名字）。当需要使用栈时，Java已不推荐使用Stack，而是推荐使用更高效的ArrayDeque；</span></p></div><div class="ne-quote"><p id="a61fde9420972de7ad3023c639a8454d" class="ne-p"><span class="ne-text">既然Queue只是一个接口，当需要使用队列时也就首选ArrayDeque了（次选是LinkedList）。</span></p></div><h2 id="DNrKW"><span class="ne-text">队列常用方法</span></h2><div class="ne-quote"><p id="669ccf1ddf6db7985144999f4db9d1ff" class="ne-p"><span class="ne-text">初始化</span></p></div><p id="u79e3622b" class="ne-p"><span class="ne-text"></span></p><pre><code>import java.util.LinkedList;import java.util.Queue;<p>Queue&lt;Integer&gt; queue_input = new LinkedList&lt;&gt;();<br></code></pre></p><p id="80236d6d508a247e1bdeb8786c427278" class="ne-p"><br></p><table id="f1ea7225" class="ne-table" style="width: 676px"><tbody><tr style="height: 33px"><td width="196"><p id="ub8f323f3" class="ne-p"><span class="ne-text">Queue Method</span></p></td><td width="226"><p id="u84b0529d" class="ne-p"><span class="ne-text">Equivalent Deque Method</span></p></td><td width="254"><p id="ud33ae7a9" class="ne-p"><span class="ne-text">说明</span></p></td></tr><tr style="height: 33px"><td width="196"><p id="u8fa7d8f3" class="ne-p"><span class="ne-text">add(e)</span></p></td><td width="226"><p id="u7361f04c" class="ne-p"><span class="ne-text">addLast(e)</span></p></td><td width="254"><p id="u7705ed20" class="ne-p"><span class="ne-text">向队尾插入元素，失败则抛出异常</span></p></td></tr><tr style="height: 33px"><td width="196"><p id="ue59b1a2c" class="ne-p"><span class="ne-text">offer(e)</span></p></td><td width="226"><p id="u3abdec16" class="ne-p"><span class="ne-text">offerLast(e)</span></p></td><td width="254"><p id="b9e17585c170a48179234823803e5277" class="ne-p"><span class="ne-text">向队尾插入元素，失败则返回false，offer(E e)操作是专为容量受限的队列实现而设计的，在大多数实现中，插入操作不会失败</span></p></td></tr><tr style="height: 33px"><td width="196"><p id="u73a85312" class="ne-p"><span class="ne-text">remove()</span></p></td><td width="226"><p id="u0fa47dee" class="ne-p"><span class="ne-text">removeFirst()</span></p></td><td width="254"><p id="ubfd2bd45" class="ne-p"><span class="ne-text">获取并删除队首元素，失败则抛出异常</span></p></td></tr><tr style="height: 33px"><td width="196"><p id="u6c4615ca" class="ne-p"><span class="ne-text">poll()</span></p></td><td width="226"><p id="u726ad4ec" class="ne-p"><span class="ne-text">pollFirst()</span></p></td><td width="254"><p id="ueee98e65" class="ne-p"><span class="ne-text">获取并删除队首元素，失败则返回null</span></p></td></tr><tr style="height: 33px"><td width="196"><p id="u2610504a" class="ne-p"><span class="ne-text">element()</span></p></td><td width="226"><p id="u1d5f6660" class="ne-p"><span class="ne-text">getFirst()</span></p></td><td width="254"><p id="ub895706c" class="ne-p"><span class="ne-text">获取但不删除队首元素，失败则抛出异常</span></p></td></tr><tr style="height: 33px"><td width="196"><p id="u018de360" class="ne-p"><span class="ne-text">peek()</span></p></td><td width="226"><p id="ufe072106" class="ne-p"><span class="ne-text">peekFirst()</span></p></td><td width="254"><p id="u263a739b" class="ne-p"><span class="ne-text">获取但不删除队首元素，失败则返回null</span></p></td></tr></tbody></table><h2 id="4mxoW"><span class="ne-text">栈常用方法</span></h2><table id="e1bd6743" class="ne-table" style="width: 760px"><tbody><tr style="height: 33px"><td width="253"><p id="ue61c19ac" class="ne-p"><span class="ne-text">Stack Method</span></p></td><td width="253"><p id="ua44f8d57" class="ne-p"><span class="ne-text">Equivalent Deque Method</span></p></td><td width="254"><p id="u78e311d0" class="ne-p"><span class="ne-text">说明</span></p></td></tr><tr style="height: 33px"><td width="253"><p id="u88229ae2" class="ne-p"><span class="ne-text">push(e)</span></p></td><td width="253"><p id="ud47aae9c" class="ne-p"><span class="ne-text">addFirst(e)</span></p></td><td width="254"><p id="u711e2955" class="ne-p"><span class="ne-text">向栈顶插入元素，失败则抛出异常</span></p></td></tr><tr style="height: 33px"><td width="253"><p id="ue9461341" class="ne-p"><span class="ne-text">无</span></p></td><td width="253"><p id="ue1fb42ef" class="ne-p"><span class="ne-text">offerFirst(e)</span></p></td><td width="254"><p id="u69a8175b" class="ne-p"><span class="ne-text">向栈顶插入元素，失败则返回false</span></p></td></tr><tr style="height: 33px"><td width="253"><p id="u6d83e19f" class="ne-p"><span class="ne-text">pop()</span></p></td><td width="253"><p id="u834e64f1" class="ne-p"><span class="ne-text">removeFirst()</span></p></td><td width="254"><p id="u38a790d1" class="ne-p"><span class="ne-text">获取并删除栈顶元素，失败则抛出异常</span></p></td></tr><tr style="height: 33px"><td width="253"><p id="ud1895fe8" class="ne-p"><span class="ne-text">无</span></p></td><td width="253"><p id="u458b9742" class="ne-p"><span class="ne-text">pollFirst()</span></p></td><td width="254"><p id="uc2f801e7" class="ne-p"><span class="ne-text">获取并删除栈顶元素，失败则返回null</span></p></td></tr><tr style="height: 33px"><td width="253"><p id="ue079cbd5" class="ne-p"><span class="ne-text">peek()</span></p></td><td width="253"><p id="u72e787fe" class="ne-p"><span class="ne-text">peekFirst()</span></p></td><td width="254"><p id="u7c260756" class="ne-p"><span class="ne-text">获取但不删除栈顶元素，失败则抛出异常</span></p></td></tr><tr style="height: 33px"><td width="253"><p id="u611f152d" class="ne-p"><span class="ne-text">无</span></p></td><td width="253"><p id="uac3786e6" class="ne-p"><span class="ne-text">peekFirst()</span></p></td><td width="254"><p id="u996c94ef" class="ne-p"><span class="ne-text">获取但不删除栈顶元素，失败则返回null</span></p></td></tr></tbody></table><h2 id="ZVu6R"><span class="ne-text">关于ArrayDeque</span></h2><div class="ne-quote"><p id="9e141997ce9104b3870e5fd54cacc514" class="ne-p"><span class="ne-text">ArrayDeque和LinkedList是Deque的两个通用实现，由于官方更推荐使用AarryDeque用作栈和队列，</span></p><p id="53a4f11749e2e66a47917c942a74d069" class="ne-p"><span class="ne-text">从名字可以看出ArrayDeque底层通过数组实现，为了满足可以同时在数组两端插入或删除元素的需求，该数组还必须是循环的，即循环数组（circular array），也就是说数组的任何一点都可能被看作起点或者终点。ArrayDeque是非线程安全的（not thread-safe），当多个线程同时使用的时候，需要程序员手动同步；另外，该容器不允许放入null元素。</span></p></div><p id="2d36075aa731cf91bb285f067dbd44da" class="ne-p"><br></p><pre><code>import java.util.*;<p>public class ArrayDequeStack &#123;<br>    public static void main(String[] args) &#123;<br>        ArrayDeque stack = new ArrayDeque();<br>        // 依次将三个元素push入“栈”，先进后出<br>        stack.push(&quot;疯狂Java讲义&quot;);<br>        stack.push(&quot;轻量级Java EE企业应用实战&quot;);<br>        stack.push(&quot;疯狂Android讲义&quot;);<br>        System.out.println(stack); // [疯狂Android讲义, 轻量级Java EE企业应用实战, 疯狂Java讲义]<br>        System.out.println(stack.peek()); // 疯狂Android讲义<br>        System.out.println(stack); // [疯狂Android讲义, 轻量级Java EE企业应用实战, 疯狂Java讲义]<br>        System.out.println(stack.pop()); // 疯狂Android讲义<br>        System.out.println(stack);//[轻量级Java EE企业应用实战, 疯狂Java讲义]</p><pre><code>    // 当做队列来使用,先进先出    ArrayDeque queue = new ArrayDeque();    queue.offer(&amp;quot;疯狂Java讲义&amp;quot;);    queue.offer(&amp;quot;轻量级JavaEE企业应用实践&amp;quot;);    queue.offer(&amp;quot;疯狂Android讲义&amp;quot;);    System.out.println(queue); //[疯狂Java讲义, 轻量级JavaEE企业应用实践, 疯狂Android讲义]    // 访问队列头部元素，但不将其poll出队列    System.out.println(queue.peek());    System.out.println(queue);    // poll出第一个元素    System.out.println(queue.poll());    System.out.println(queue);// [轻量级JavaEE企业应用实践, 疯狂Android讲义]&#125;</code></pre><p>}<br></code></pre></p><pre><code>[疯狂Android讲义, 轻量级Java EE企业应用实战, 疯狂Java讲义]疯狂Android讲义[疯狂Android讲义, 轻量级Java EE企业应用实战, 疯狂Java讲义]疯狂Android讲义[轻量级Java EE企业应用实战, 疯狂Java讲义][疯狂Java讲义, 轻量级JavaEE企业应用实践, 疯狂Android讲义]疯狂Java讲义[疯狂Java讲义, 轻量级JavaEE企业应用实践, 疯狂Android讲义]疯狂Java讲义[轻量级JavaEE企业应用实践, 疯狂Android讲义]</code></pre><p id="acf9f3857a7d8138cea03a0bc41e17ab" class="ne-p"><span class="ne-text">例子参考：</span><a href="https://www.cnblogs.com/jiqing9006/p/6107491.html" data-href="https://www.cnblogs.com/jiqing9006/p/6107491.html" target="_blank" class="ne-link"><span class="ne-text">https://www.cnblogs.com/jiqing9006/p/6107491.html</span></a></p></div>]]></content>
      
      
      <categories>
          
          <category> 计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 📶线结构：字符串-数组-栈-队列 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>225/232. 队列和栈的相互实现🔖队列🔖栈</title>
      <link href="/blog/le21wf/"/>
      <url>/blog/le21wf/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="a29a1b8e333ebb6218a4a850e5fe17c2" class="ne-p"><span class="ne-text">简单实现一下，熟悉一下写题目，这几天找找状态……</span><img src="https://cdn.nlark.com/yuque/0/2021/gif/1484158/1615278756585-fb0d9f38-8031-472f-9a19-8545be93a548.gif" width="100" id="QjErw" class="ne-image"></p><p id="ef899eed96ff8a1bcaaa60a81c23e200" class="ne-p"><br></p><p id="u880365d5" class="ne-p"><br></p><h2 id="o2VfU"><span class="ne-text">P232. 栈实现队列</span></h2><pre><code>package com.wztlink1013.problems.leetcode.editor.cn;<p>// P232.用栈实现队列<br>// P232.implement-queue-using-stacks<br>//请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（push、pop、peek、empty）：<br>//<br>// 实现 MyQueue 类：<br>//<br>//<br>// void push(int x) 将元素 x 推到队列的末尾<br>// int pop() 从队列的开头移除并返回元素<br>// int peek() 返回队列开头的元素<br>// boolean empty() 如果队列为空，返回 true ；否则，返回 false<br>//<br>//<br>//<br>//<br>// 说明：<br>//<br>//<br>// 你只能使用标准的栈操作 —— 也就是只有 push to top, peek/pop from top, size, 和 is empty 操作是合法的。<br>//<br>// 你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。<br>//<br>//<br>//<br>//<br>// 进阶：<br>//<br>//<br>// 你能否实现每个操作均摊时间复杂度为 O(1) 的队列？换句话说，执行 n 个操作的总时间复杂度为 O(n) ，即使其中一个操作可能花费较长时间。<br>//<br>//<br>//<br>//<br>// 示例：<br>//<br>//<br>//输入：<br>//[&quot;MyQueue&quot;, &quot;push&quot;, &quot;push&quot;, &quot;peek&quot;, &quot;pop&quot;, &quot;empty&quot;]<br>//[[], [1], [2], [], [], []]<br>//输出：<br>//[null, null, null, 1, 1, false]<br>//<br>//解释：<br>//MyQueue myQueue = new MyQueue();<br>//myQueue.push(1); // queue is: [1]<br>//myQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue)<br>//myQueue.peek(); // return 1<br>//myQueue.pop(); // return 1, queue is [2]<br>//myQueue.empty(); // return false<br>//<br>//<br>//<br>//<br>//<br>//<br>//<br>// 提示：<br>//<br>//<br>// 1 &lt;= x &lt;= 9<br>// 最多调用 100 次 push、pop、peek 和 empty<br>// 假设所有操作都是有效的 （例如，一个空的队列不会调用 pop 或者 peek 操作）<br>//<br>// Related Topics 栈 设计<br>// 👍 361 👎 0</p><p>import java.util.Stack;</p><p>public class P232ImplementQueueUsingStacks&#123;<br>    public void main(String[] args) &#123;<br>        MyQueue myQueue = new MyQueue();<br>        //本地调试需要将MyQueue类和主函数加上静态static修饰字<br>        //具体解释：<a href="https://www.cnblogs.com/dolphin0520/p/3799052.html">https://www.cnblogs.com/dolphin0520/p/3799052.html</a><br>        myQueue.push(1); // queue is: [1]<br>        myQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue)<br>        myQueue.pop();<br>        myQueue.peek();<br>//        myQueue.peek(); // return 1<br>//        myQueue.pop(); // return 1, queue is [2]<br>//        myQueue.empty(); // return false<br>//        System.out.println(myQueue);<br>    &#125;</p><p>//leetcode submit region begin(Prohibit modification and deletion)<br>class MyQueue &#123;<br>    Stack&lt;Integer&gt; stack_input = new Stack&lt;&gt;();<br>    Stack&lt;Integer&gt; stack_output = new Stack&lt;&gt;();<br>    /** Initialize your data structure here. */<br>    public MyQueue() &#123;<br>//        Stack&lt;Integer&gt; stack_input = new Stack&lt;&gt;();<br>//        Stack&lt;Integer&gt; stack_output = new Stack&lt;&gt;();<br>    &#125;</p><pre><code>/** Push element x to the back of queue. */public void push(int x) &#123;    stack_input.push(x);    int temp = stack_input.size();    if (stack_output.size() == 0) &#123;        for (int i=0; i&amp;lt;temp; i++)&#123;            stack_output.push(stack_input.pop());        &#125;    &#125;&#125;/** Removes the element from in front of queue and returns that element. */public int pop() &#123;    int temp = stack_input.size();    if (stack_output.size() == 0) &#123;        for (int i=0; i&amp;lt;temp; i++)&#123;            stack_output.push(stack_input.pop());        &#125;    &#125;    return stack_output.pop();&#125;/** Get the front element. */public int peek() &#123;    int temp = stack_input.size();    if (stack_output.size() == 0) &#123;        for (int i=0; i&amp;lt;temp; i++)&#123;            stack_output.push(stack_input.pop());        &#125;    &#125;    return stack_output.peek();&#125;/** Returns whether the queue is empty. */public boolean empty() &#123;    if (stack_input.size() == 0 &amp;amp;&amp;amp; stack_output.size() == 0) &#123;        return true;    &#125;    return false;&#125;</code></pre><p>}</p><p>/**</p><ul><li>Your MyQueue object will be instantiated and called as such:</li><li>MyQueue obj = new MyQueue();</li><li>obj.push(x);</li><li>int param_2 = obj.pop();</li><li>int param_3 = obj.peek();</li><li>boolean param_4 = obj.empty();</li><li>/<br>//leetcode submit region end(Prohibit modification and deletion)</li></ul><p>}<br></code></pre></p><h2 id="YtwL8"><span class="ne-text">P225. 队列实现栈</span></h2><pre><code>package com.wztlink1013.problems.leetcode.editor.cn;<p>// P225.用队列实现栈<br>// P225.implement-stack-using-queues<br>//请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通队列的全部四种操作（push、top、pop 和 empty）。<br>//<br>// 实现 MyStack 类：<br>//<br>//<br>// void push(int x) 将元素 x 压入栈顶。<br>// int pop() 移除并返回栈顶元素。<br>// int top() 返回栈顶元素。<br>// boolean empty() 如果栈是空的，返回 true ；否则，返回 false 。<br>//<br>//<br>//<br>//<br>// 注意：<br>//<br>//<br>// 你只能使用队列的基本操作 —— 也就是 push to back、peek/pop from front、size 和 is empty 这些操作。<br>// 你所使用的语言也许不支持队列。 你可以使用 list （列表）或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。<br>//<br>//<br>//<br>//<br>// 示例：<br>//<br>//<br>//输入：<br>//[&quot;MyStack&quot;, &quot;push&quot;, &quot;push&quot;, &quot;top&quot;, &quot;pop&quot;, &quot;empty&quot;]<br>//[[], [1], [2], [], [], []]<br>//输出：<br>//[null, null, null, 2, 2, false]<br>//<br>//解释：<br>//MyStack myStack = new MyStack();<br>//myStack.push(1);<br>//myStack.push(2);<br>//myStack.top(); // 返回 2<br>//myStack.pop(); // 返回 2<br>//myStack.empty(); // 返回 False<br>//<br>//<br>//<br>//<br>// 提示：<br>//<br>//<br>// 1 &lt;= x &lt;= 9<br>// 最多调用100 次 push、pop、top 和 empty<br>// 每次调用 pop 和 top 都保证栈不为空<br>//<br>//<br>//<br>//<br>// 进阶：你能否实现每种操作的均摊时间复杂度为 O(1) 的栈？换句话说，执行 n 个操作的总时间复杂度 O(n) ，尽管其中某个操作可能需要比其他操作更长的<br>//时间。你可以使用两个以上的队列。<br>// Related Topics 栈 设计<br>// 👍 291 👎 0</p><p>import java.util.LinkedList;<br>import java.util.Queue;</p><p>public class P225ImplementStackUsingQueues&#123;<br>    public void main(String[] args) &#123;<br>//        Solution solution = new P225ImplementStackUsingQueues().new Solution();</p><pre><code>&#125;</code></pre><p>//leetcode submit region begin(Prohibit modification and deletion)<br>class MyStack {<br>    Queue&lt;Integer&gt; queue_input = new LinkedList&lt;&gt;();<br>    Queue&lt;Integer&gt; queue_output = new LinkedList&lt;&gt;();<br>    /** Initialize your data structure here. */<br>    public MyStack() {</p><pre><code>&#125;/** Push element x onto stack. */public void push(int x) &#123;    queue_input.add(x);&#125;/** Removes the element on top of the stack and returns that element. */public int pop() &#123;    int temp_2 = queue_input.size();    for (int i=0; i&amp;lt;temp_2; i++) &#123;        queue_output.add(queue_input.remove());    &#125;    int temp_3 = queue_output.size();    for (int i=0; i&amp;lt;temp_3-1; i++) &#123;        queue_input.add(queue_output.remove());    &#125;    return queue_output.remove();&#125;/** Get the top element. */public int top() &#123;    int top = 0;    int temp_4 = queue_input.size();    for (int i=0; i&amp;lt;temp_4; i++) &#123;        queue_output.add(queue_input.remove());    &#125;    int temp_5 = queue_output.size();    for (int i=0; i&amp;lt;temp_5; i++) &#123;        if (i == temp_5-1) &#123;            top = queue_output.element();        &#125;        queue_input.add(queue_output.remove());    &#125;    return top;&#125;/** Returns whether the stack is empty. */public boolean empty() &#123;    if (queue_input.size() == 0 &amp;amp;&amp;amp; queue_output.size() == 0) &#123;        return true;    &#125;    return false;&#125;</code></pre><p>}</p><p>/**</p><ul><li>Your MyStack object will be instantiated and called as such:</li><li>MyStack obj = new MyStack();</li><li>obj.push(x);</li><li>int param_2 = obj.pop();</li><li>int param_3 = obj.top();</li><li>boolean param_4 = obj.empty();</li><li>/<br>//leetcode submit region end(Prohibit modification and deletion)</li></ul><p>}<br></code></pre></p><p id="c85ff563fe7096567c2ba4ddbe4a46f7" class="ne-p"><br></p><p id="978d3b8ea3f6378eb757293446e8714d" class="ne-p"><br></p><p id="177934f4fd8489d50ebbf77c3edd6caf" class="ne-p"><br></p><p id="955b42ad8438ffa991a6e0e0d5a36501" class="ne-p"><br></p><p id="e9d6c34d897fe5fda361fea40c76df6d" class="ne-p"><br></p></div>]]></content>
      
      
      <categories>
          
          <category> 计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 📶线结构：字符串-数组-栈-队列 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>RSA公钥密码算法</title>
      <link href="/blog/ccd10c/"/>
      <url>/blog/ccd10c/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><div class="ne-quote"><p id="1361ac60683f4eb70b67453160b38ffb" class="ne-p"><span class="ne-text">最近利用自己曾经写过的一篇文章『</span><a href="https://www.wztlink1013.com/blog/bw80k6/" data-href="https://www.wztlink1013.com/blog/bw80k6/" target="_blank" class="ne-link"><span class="ne-text">https://www.wztlink1013.com/blog/bw80k6/</span></a><span class="ne-text">』（利用一次抓包来复习学习过的计网知识）</span></p></div><p id="12f629a7bde08826aa213fbf1f470fd0" class="ne-p"><br></p><p id="e6f62102d4830f4e633a1f91f8184228" class="ne-p"><span class="ne-text">前言：在分析HTTPS和HTTP这两个协议之间的区别的时候，我感觉HTTPS的SSL(Secure Sockets Layer 安全套接字协议)证书很类似之前老师讲过的RSA算法，做此篇文章复习下RSA算法和加深HTTPS的理解。</span></p><p id="f0a10b85ff0e50d2f4d8727451589e45" class="ne-p"><br></p><p id="6ea55680c18e8a51b28317e8cfb2eeab" class="ne-p"><span class="ne-text">在密码学当中，由对称密钥和非对称密钥之分。</span></p><p id="u4665cf23" class="ne-p"><span class="ne-text"></span></p><h2 id="YrgFk"><span class="ne-text">对称密钥</span></h2><p id="f8843ff5e287cfc067fcc2e3cb10feee" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612943343546-b8330998-9019-40a1-9759-12b459d5379b.png" width="491" id="rvUuR" class="ne-image"></p><p id="0253454387d002137ebad0e59b33b2dd" class="ne-p"><span class="ne-text">用一个简单的凯撒密码例子来讲解一下对称密钥：</span></p><p id="dc29144aad9a00526749aabb1736e11b" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612943823633-5283daed-a125-46fd-a785-93851daf5269.png" width="478.5" id="g4j6n" class="ne-image"></p><p id="8782cf33b87bc57ee69803d5ff8be64a" class="ne-p"><span class="ne-text">上图是凯撒密码的定义，先说一下怎么用：</span></p><p id="7d0edaf4b7aecb5b3ca582cd4e6c54cd" class="ne-p"><br></p><p id="69615f37631954ed545f7ea9221e7516" class="ne-p"><span class="ne-text">假如张三和李四两个人之间需要传输一段密码apple，他们之间共同约定使用密钥-3（再上图表示就为e字母编程b字母了，以此类推），而这个算法是基于</span><a href="https://zh.wikipedia.org/wiki/%E6%A8%A1%E9%99%A4" data-href="https://zh.wikipedia.org/wiki/%E6%A8%A1%E9%99%A4" target="_blank" class="ne-link"><span class="ne-text">mod运算</span></a><span class="ne-text">（在这里看成是一种加密/解密机制）的。</span></p><p id="1b4a2b23c390a92cdc1554605a9767d2" class="ne-p"><br></p><p id="c8f51bd99b13e7fc6580b62a4e6c9e72" class="ne-p"><span class="ne-text">张三利用mod运算加密机制（mod运算）将apple转换位xmmfb</span></p><p id="e0000b51e016347fa172d5c63020f986" class="ne-p"><span class="ne-text">李四利用mod运算解密机制（mod运算）将xmmfb转换位apple</span></p><p id="5073e25392e5c848891f287eb64d7814" class="ne-p"><br></p><div class="ne-quote"><p id="c13de66d78c8a604676a5ad0ae9b9bd8" class="ne-p"><span class="ne-text">a为什么到x：（0-3）mod26可以看成（23-26）mod26=23，所以a往后退三位还是x</span></p></div><p id="ecde1210f865a4584d48be7b1302be0e" class="ne-p"><span class="ne-text">上述例子的加密机制和解密机制算法一样（mod运算），实际上也可以不一样，不做详述。但是可以说名对称加密的密钥都一样，该例子中表现为-3</span></p><p id="2909d93dbe7bd2f9afc48e7fcdc0f8f1" class="ne-p"><br></p><h2 id="n5gMm"><span class="ne-text">RSA公钥密码算法</span></h2><p id="74861a7195564ccaef58a46d61cd18f6" class="ne-p"><span class="ne-text">RSA公钥密码算法是非对称加密。</span></p><p id="fed6a505df0d0be6454dcdaa8d2ae556" class="ne-p"><br></p><p id="f0e137f855d14f9ef1af860a29c2a479" class="ne-p"><span class="ne-text">先说一下和上面的对称密钥的不同，很简单，不同之处就是对称密钥只有一个密钥，而非对称密钥有两个（我觉得严谨来说可以有多个，但在这里先局限地说有两个），而且一个叫公钥，一个叫密钥。</span></p><p id="51b6876de43586349e6b79e5fb738ce9" class="ne-p"><br></p><p id="c0112ecb1b92f214b202e28eb89dcb58" class="ne-p"><span class="ne-text">还是上面的张三李四例子，就相当于张三这次用公钥来加密apple这个单词，加密成一段密文，这段密文</span><strong><span class="ne-text">只能由密钥来解密</span></strong><span class="ne-text">，即便是你有了公钥，也不能将其解密。</span></p><p id="dca5320b6a290dce7be5a1d91c22d727" class="ne-p"><br></p><p id="39123083f61d0fadc3b489a2ad6936f9" class="ne-p"><span class="ne-text">然后来抛出几个问题来分析之：</span></p><p id="0e3ea83e5ac90a208a407f4fdf5a71a4" class="ne-p"><br></p><div class="ne-quote"><p id="c51b3fc104abbfbb81668de279ad0bb0" class="ne-p"><span class="ne-text">【Q1】公钥和密钥怎么来规定呢？我要是一个网络攻击者，我利用公钥来推理出密钥，那我岂不是直接解密了？！</span></p></div><p id="80ba919176ce9e46abe9a5d84a74c831" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612945567958-1cd39a87-ba61-4dd8-955e-1a4fc130378d.png" width="237" id="WyGPZ" class="ne-image"></p><p id="07935626abdfc2478c0253eb7b878bdb" class="ne-p"><span class="ne-text">具体的相关mod运算在此不做详述</span></p><p id="a7f586f83fa0b771a6cfe81d536ec0fa" class="ne-p"><br></p><div class="ne-quote"><p id="2b8bf37984341886a7547465fc06d5fb" class="ne-p"><span class="ne-text">【Q2】算法可靠与否</span></p></div><p id="247e0b16e3d47a9222e60a1d70b214a2" class="ne-p"><span class="ne-text">为了保证严谨，同时也证明了这种算法的</span></p><ul class="ne-ul"><li id="76ab6859bb1a650c7bf530e1bfd01468"><span class="ne-text">可行性，所计算出来的算法复杂度最高是4次方，对计算机而言，可计算</span></li><li id="1f60f8619bb765e108cfe23d06aad01b"><span class="ne-text">不可攻破，在学界，大数因子分解不可行，或者说，如今的科技还不能轻易的破解</span></li></ul><p id="c200e268cf270e2c75385c57d177fd8e" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612945767363-ee62dad7-357d-42d3-a932-78cc10d29866.png" width="492.5" id="jZ5AI" class="ne-image"></p><p id="6d27d977f5d2a5274128284457747b67" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612945781929-bea0946c-3f24-472d-a4d4-3c40abd83ee3.png" width="493.5" id="gpoCJ" class="ne-image"></p><p id="06af2cbce95bd37f0c5fb45adc7dadeb" class="ne-p"><br></p><p id="69f63303f8273a258c7a5bd5f5263c30" class="ne-p"><br></p><p id="a7d9f4d3b0cbb47eefac08194e29d7b8" class="ne-p"><br></p></div>]]></content>
      
      
      <categories>
          
          <category> 计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 🔐RSA算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>HTTPS较HTTP安全在哪？</title>
      <link href="/blog/pl8gro/"/>
      <url>/blog/pl8gro/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="ef44f44e02f83438b51c1e60da737802" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612949716697-1ceb6a5c-fa5e-4129-9c0a-63e01ce75057.png" width="564" id="VgkSz" class="ne-image"></p><h2 id="nbD9e"><span class="ne-text">HTTPS的精妙之处</span></h2><p id="1b2cc6e57561a893317018494b067755" class="ne-p"><span class="ne-text">在我写的算法相关文章里面，有一篇RSA相关的文章</span><a href="https://www.yuque.com/wztlink1013/blog/ccd10c" data-href="https://www.yuque.com/wztlink1013/blog/ccd10c" class="ne-link"><span class="ne-text">https://www.yuque.com/wztlink1013/blog/ccd10c</span></a><span class="ne-text">，里面解释了对称加密和的非对称加密</span></p><p id="fca7d676a2041b66a43f19be381c59f0" class="ne-p"><br></p><p id="3dda5208b6006b366bc9df58f5eb0e1b" class="ne-p"><span class="ne-text">我觉得HTTPS的精妙之处就是在于它同时运用了</span><strong><span class="ne-text">对称加密（AES）</span></strong><span class="ne-text">和</span><strong><span class="ne-text">非对称加密（RSA）</span></strong><span class="ne-text">两种加密，下面我解释一下：</span></p><p id="04e746d4f38ba2204dc437f3b5ee4a5d" class="ne-p"><br></p><h2 id="DZDTA"><span class="ne-text">HTTP为何不安全？</span></h2><p id="8b2dbe2c550f978dfb29652f2d297b01" class="ne-p"><span class="ne-text">客户端对服务端做出请求，然后服务端做出响应，这个大家都知道，但是HTTP是明文传输，我在</span><a href="https://www.yuque.com/wztlink1013/blog/bw80k6/" data-href="https://www.yuque.com/wztlink1013/blog/bw80k6/" class="ne-link"><span class="ne-text">https://www.yuque.com/wztlink1013/blog/bw80k6/</span></a><span class="ne-text">这篇文章里面也详细抓包展示了HTTP的明文传输</span></p><p id="c3332cf857ffd6689b1db7cd518c0f52" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612946821326-d568e02e-1173-4af4-93c5-539275023ba3.png" width="772" id="rZuDh" class="ne-image"></p><p id="46ca81dc18fe96e1631b9c7b97b77295" class="ne-p"><span class="ne-text">这样传输的信息就不安全，</span><span class="ne-text">攻击者就能轻易得到，进一步讲，得到了就不安全吗？</span></p><ul class="ne-ul"><li id="e15cee96579d1486429a3621d6807ba1"><span class="ne-text">因为假如此时服务端响应给客户端的是很重要的诸如密码或者个人信息之类的敏感信息，就会被窃听</span></li><li id="c411fc4875eac717e794ef868e487e35"><span class="ne-text">中途截取，将所传输的信息不完整等等</span></li></ul><h2 id="ueEPX"><span class="ne-text">HTTPS安全在哪？精妙之处！</span></h2><p id="17fa4cd519be4730f49e54e40240ca73" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612947167321-69c11c8d-9f8d-4f78-80a9-b2ee1c02e6b8.png" width="496" id="m1HhZ" class="ne-image"></p><p id="2ac687b6be968c414849fd62f7225f41" class="ne-p"><span class="ne-text">由上图所示，HTTPS的协议栈相较HTTP协议栈多了安全层，也就是SSL(安全套接层)或者TSL(安全传输层)协议</span></p><p id="495928fc11abdbb78b4fc323b28606d5" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1651901470392-70830d5a-2402-4dd5-90d2-f1f52004da65.png" width="436.015625" id="u6c39ea43" class="ne-image"></p><ol class="ne-ol"><li id="146220d0b0bcc0e2440ea73c4e443935"><span class="ne-text">客户端向服务端发出一个https请求，其中端口位443</span></li></ol><div class="ne-quote"><p id="f7bc1600a71b76bbc0ed2da6dd723479" class="ne-p"><span class="ne-text">说明：采用https的网站都会有相应的ssl证书，在服务器那里，这个证书内容就是颁发的机构、到期时间……，而这个证书的形式就是以公钥的形式存在于服务器的。</span></p></div><ol start="2" class="ne-ol"><li id="3a7fc489e47e11ae95816e3e18b54ad2"><span class="ne-text">服务端响应给客户端这个证书（公钥的形式）</span></li><li id="34fd67235c159a89145b2fdf352389e7"><span class="ne-text">客户端解析响应来的公钥，因为需要验证这个ssl是不是伪造的还是过期了等等，假如验证不成功，就会如下：</span></li></ol><p id="5917ab143fdd8845150c324469c3754e" class="ne-p" style="text-indent: 2em"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612948950125-219e56dd-b6cd-4245-8aa5-44ad8e6e381c.png" width="302.5" id="orB4W" class="ne-image"></p><ol start="4" class="ne-ol"><li id="7a7a7031f934d2224627928938e2a58f"><span class="ne-text">然后客户端（浏览器）利用这个公钥随机得出的私钥，然后将这个私钥发给服务端，以后客户端和服务端就可以利用这个密钥来解密双方传来传去的加密信息了</span></li></ol><div class="ne-quote"><p id="80643695a94aaccb1ae4649ca85f582c" class="ne-p"><span class="ne-text">说明：随机的出的私钥并不是那么“随机”，因为要保证不可攻破性，具体可以看我的RSA算法相关文章</span></p></div><hr id="xRZXg" class="ne-hr"><ol start="5" class="ne-ol"><li id="0119dd35a254fac92a480d631d6e31b4"><span class="ne-text">服务端将要展示给客户端的具体信息利用上述私钥来加密</span></li><li id="1eab2922dcf081d630dc21591f689100"><span class="ne-text">客户端接收到服务端发过来的加密信息，用共同都有的私钥解密查看之</span></li></ol><div class="ne-quote"><p id="779b869a4738d08bea8e3a00693656af" class="ne-p"><span class="ne-text">整个过程对外人而言看到的都是加密后的信息，而不是明文</span></p></div><p id="a30deaf8ed626553f4d5259efac2ae2f" class="ne-p"><br></p><p id="9a2f0d53f6fdc898bd4a23c1c6a6fb06" class="ne-p"><span class="ne-text">综上，56条是采用了AES对称加密，而前面是利用RSA算法得到私钥</span></p><h2 id="05Oaf"><span class="ne-text">参考</span></h2><ul class="ne-ul"><li id="bb90bf4c12e98aa4e84667fc6ebdfa18"><span class="ne-text">这位博主（</span><span class="ne-text" style="color: #555555; font-size: 16px">数据中心网络工程师</span><span class="ne-text">）将SSL讲解的更加细致，可以常看：</span><a href="https://cshihong.github.io/2019/05/09/SSL%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/" data-href="https://cshihong.github.io/2019/05/09/SSL%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/" target="_blank" class="ne-link"><span class="ne-text">SSL/TLS协议详解</span></a></li></ul><p id="1ff4d3d0b158c3a218a8dcfa09409d63" class="ne-p"><br></p></div>]]></content>
      
      
      <categories>
          
          <category> 计算机素养 </category>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>关于CDN的一些概念</title>
      <link href="/blog/fxzcy3/"/>
      <url>/blog/fxzcy3/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h2 id="xlZLV"><span class="ne-text">CDN回源</span></h2><p id="8147a44fca09bde09c02881a9e4a1a5e" class="ne-p" style="text-indent: 2em"><span class="ne-text">cdn回源是什么意思？CDN回源包括回源地址和加速</span><a href="https://www.west.cn/services/domain/" data-href="https://www.west.cn/services/domain/" target="_blank" class="ne-link"><span class="ne-text">域名</span></a><span class="ne-text">。常规的CDN都是回源的。即：当有用户访问某一个URL的时候，如果被解析到的那个CDN节点没有缓存响应的内容，或者是缓存已经到期，就会回源站去获取。如果没有人访问，那么CDN节点不会主动去源站拿的。</span></p><p id="df3d30da288ba66e5421c2de49ba544c" class="ne-p" style="text-indent: 2em"><span class="ne-text">回源地址：可以使回源域名，也可以是回源IP，主要作用是CDN加速节点同步更新的一个地址；</span></p><p id="f887357ea519facb15d65e85522e4f4a" class="ne-p" style="text-indent: 2em"><span class="ne-text">加速域名：使用CDN</span><a href="https://www.west.cn/cloudhost/" data-href="https://www.west.cn/cloudhost/" target="_blank" class="ne-link"><span class="ne-text">服务器</span></a><span class="ne-text">需要加速的一个域名，一般会将加速域名做别名解析为CDN运营商提供的域名，来做CDN加速访问。</span></p><p id="e4ad4f76e9862f7c014be679163f923c" class="ne-p"><a href="https://www.west.cn/docs/wp-content/uploads/2018/05/n-40.jpg" target="_blank" id="YP5GO" class="ne-image-link"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1612941062375-753094ca-dc39-494d-abaf-022708a631a3.jpeg" width="581" class="ne-image"></a></p><p id="f7c0ae2f7d8a5fc7accc3f59767fdd1f" class="ne-p"><span class="ne-text">回源域名一般是cdn领域的专业术语，通常情况下，是直接用ip进行回源的，但是如果客户源站有多个ip，并且ip地址会经常变化，对于cdn厂商来说，为了避免经常更改配置（回源ip），会采用回源域名方式进行回源，这样即使源站的ip变化了，也不影响原有的配置。</span></p><p id="a1694293675c8addd427bbbd8335c381" class="ne-p"><span class="ne-text">CDN本来是给网站加速的，但是有时会因为不合适的回源策略给服务器带来负担，只有选择正确的策略才能给自己的网站带来更高的访问效率。</span></p><h2 id="7wDA9"><span class="ne-text">网站优化</span></h2><h3 id="Ubg6y"><span class="ne-text">Gzip智能压缩</span></h3><p id="7c9bb2201a947bd86254630fa6addae7" class="ne-p"><span class="ne-text" style="color: #121212">gzip是GNUzip的缩写，最早用于UNIX系统的文件压缩</span></p><p id="8c09cd046b5ff4dc7da82b45d1fdd90e" class="ne-p"><span class="ne-text" style="color: #121212"></span></p><p id="61809721e669f5ea235636ee92be6f5b" class="ne-p"><span class="ne-text" style="color: #121212">HTTP协议上的gzip编码是一种用来改进web应用程序性能的技术，web服务器和客户端（浏览器）必须共同支持gzip</span></p><p id="750bf35fb9c8308bb9a206b4bd7dd707" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612939525023-772b71d1-11ea-4f13-8629-500d71865e16.png" width="545.5" id="l3xba" class="ne-image" style="color: #121212"></p><h3 id="GDGzg"><span class="ne-text">Brotli智能压缩</span></h3><p id="6e26adf45fc4e624dc1405056096cb66" class="ne-p"><span class="ne-text">也是一种静态资源压缩算法，并且也支持HTTPS</span></p><h3 id="q5q0o"><span class="ne-text">页面压缩</span></h3><p id="70523bee88418a138db5cb3d37e4024e" class="ne-p"><span class="ne-text">去除掉页面的注释或空格提高传输效率</span></p><h3 id="9w5Jh"><span class="ne-text">302调度</span></h3><p id="b3547cf5b8a9c590c713f6b57548489b" class="ne-p"><a href="https://cloud.tencent.com/developer/article/1445728" data-href="https://cloud.tencent.com/developer/article/1445728" target="_blank" class="ne-link"><span class="ne-text">CDN系列学习文章（三）——302调度</span></a></p><p id="c9cb1ade36b8107051bae0d28240f11d" class="ne-p"><br></p><p id="6941b6b7a0204626b2a326d0ad41802b" class="ne-p"><span class="ne-text">作者：深蓝加菲</span></p><p id="5bd143e7b27c49eda394f7555cedb0f0" class="ne-p"><span class="ne-text">链接：</span><a href="https://www.zhihu.com/question/32148047/answer/70920110" data-href="https://www.zhihu.com/question/32148047/answer/70920110" target="_blank" class="ne-link"><span class="ne-text">https://www.zhihu.com/question/32148047/answer/70920110</span></a></p><p id="bfa1566da694ef475a631cd2598b60bc" class="ne-p"><span class="ne-text">来源：知乎</span></p><p id="c92cab146699c2df5ea88d3e06861438" class="ne-p"><span class="ne-text">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span></p><p id="a8281bee7ae2b52b851e477eaa32cf96" class="ne-p"><br></p><p id="cf26933da576dbb1eba35c829f32e15c" class="ne-p"><span class="ne-text">一般是两者结合，DNS做省市级别和跨运营商的调度， 302做基于内容和精确IP的精确调度</span></p><p id="fb0e0da0e3970b343d165b23e095e412" class="ne-p"><span class="ne-text">DNS的优点：</span></p><p id="d0b49b103e5f250e6a4bec72eae41d7e" class="ne-p"><span class="ne-text">DNS系统是天然的分布式结构</span></p><p id="b83a034b7310f32d30140c28ee3fa30b" class="ne-p"><span class="ne-text">客户端本机，LDNS都可以实现cache，</span><strong><span class="ne-text">架构本身就能实现高的伸缩性和性能</span></strong></p><p id="2586f057c40a0bd7abbac121d52fe068" class="ne-p"><span class="ne-text">---------------------------------------------------------</span></p><p id="ba693bbcb4b7216e40dbb2eeac28994a" class="ne-p"><span class="ne-text">DNS的缺点：</span></p><p id="2afde6a094044f4aaccef5c0605dd1c9" class="ne-p"><span class="ne-text">DNS并不是为GSLB设计的</span></p><p id="4f40287c6dbbd10959137b825b4ca1ec" class="ne-p"><span class="ne-text">GSLB 基于 local DNS的地址判断，</span><strong><span class="ne-text">粒度较粗</span></strong><span class="ne-text">。而且LDNS可能和end user网络距离很远。</span></p><p id="808be923fa1dfdb78812b4f98e078aeb" class="ne-p"><span class="ne-text">用户可能会设置错误的Local DNS，该服务器和用户实际距离较远，比如8.8.8.8等(edns-client-subnet可以部分解决该问题)</span></p><p id="905db8f74bc30c9b5fef1b8e39bc768e" class="ne-p"><span class="ne-text">DNS请求里面</span><strong><span class="ne-text">不会带有内容信息</span></strong><span class="ne-text">，GSLB只能拥有LDNS ip信息，无法针对内容作出更加灵活的判断</span></p><p id="8f50b8be270d59a468c3ec6211309502" class="ne-p"><span class="ne-text">因为DNS reply TTL，所以某个用户一段时间内的请求都会导向同一个site (解决：趋向于较短的TTL) </span></p><p id="a3de8afbfd0e83eeb65fbc0f14646c6c" class="ne-p"><span class="ne-text">因为local dns缓存和TTL的存在，你很难判断某次的返回会对负载有多大影响</span></p><p id="b90a5cd8a8edb7a3df0c934854817480" class="ne-p"><span class="ne-text">某些Local DNS会忽略DNS TTL信息，而采用固定的TTL时间，对此我们无能为力</span></p><p id="1cf01151d692257ffd9a946029e4b7e2" class="ne-p"><span class="ne-text">电信系统倾向于直接使用ip地址访问，不使用域名</span></p><p id="ba0552461696b82cf73b73a1e0fe4c86" class="ne-p"><span class="ne-text">---------------------------------------------------------</span></p><p id="d763e5bff7ef8971cdaf3872c1970a3d" class="ne-p"><span class="ne-text">302的优点：</span></p><p id="f98286666e0a731230bfb6f431b6f40f" class="ne-p"><span class="ne-text">可以直接得到end user ip和内容的地址，可以</span><strong><span class="ne-text">做出精确的redirect</span></strong></p><p id="606abac10ad4266cd78798880aa13184" class="ne-p"><span class="ne-text">每个请求都需要访问GSLB,可以做出单独的处理</span></p><p id="fc7abb017f2c035fbdd1d57eae77dee7" class="ne-p"><span class="ne-text">可以在一个点方便的作出统计和认证</span></p><p id="e109ce7deb66847d7fd65745ca76a6b7" class="ne-p"><span class="ne-text">---------------------------------------------------------</span></p><p id="3045bd660fa83e43212a891d669cf4d3" class="ne-p"><span class="ne-text">302的缺点：</span></p><p id="8c9b3af29d6721b73477a4f77215503e" class="ne-p"><span class="ne-text">需要应用层协议支持(http / rtsp)</span></p><p id="0121d9e5215eb45a43d19857d5c823eb" class="ne-p"><span class="ne-text">一般有重定向次数限制</span></p><p id="7fea09c798deac6017f299ef161346e1" class="ne-p"><span class="ne-text">GSLB需要处理较多的请求，却没有LDNS作为cache</span></p><p id="474e649138cf8c6a1278cf134882100e" class="ne-p"><span class="ne-text">GSLB暴露给end user ， 容易遭受攻击</span></p><p id="b2777f5e0342b77e9da69dc14ebe60a7" class="ne-p"><span class="ne-text">用户访问GSLB本身就会带来时延，可能深圳的用户需要访问北京的GSLB</span></p><p id="d86afd889f24785f359500623fc2af61" class="ne-p"><span class="ne-text">单点故障(可以通过GSLB服务群集解决)</span></p><p id="eaea7a0c6c9b41d669ef7f0a154f1618" class="ne-p"><span class="ne-text">某些应用对URL变化敏感，比如WEB</span></p><p id="3e3362b77e87f0fabcc20d9ec12fc727" class="ne-p"><span class="ne-text">某些客户端支持不好(中文字符集等问题)</span></p><h3 id="gK3Zg"><span class="ne-text">TLS1.3</span></h3><p id="b6fb70efc58af69baf04ab89bbc3b72e" class="ne-p"><span class="ne-text">TLS 1.3 是一种全新的加密协议，它既能提高终端用户的访问速度，又能增强安全性</span></p><p id="373bd96eee79913463315d2257b944f0" class="ne-p"><br></p><div id="0dxvR" class="ne-bookmark"><a href="https://zhuanlan.zhihu.com/p/44980381" target="_blank">TLS1.3 VS TLS1.2，让你明白TLS1.3的强大</a></div><h3 id="nQNaE"><span class="ne-text">HTTP/2 + Server Push</span></h3><div id="RLYjg" class="ne-bookmark"><a href="https://www.ruanyifeng.com/blog/2018/03/http2_server_push.html" target="_blank">HTTP/2 服务器推送（Server Push）教程</a></div><h3 id="7fZkP"><span class="ne-text">WebP 自适应</span></h3><p id="f2ed59db935ef176eb39c41b4a558f42" class="ne-p"><span class="ne-text">WebP 自适应功能是 CDN 平台智能判断客户端浏览器是否支持 WebP 解码，如支持则返回 WebP 格式图片，否则返回原图，客户端以及源站无需任何改动。开启该特性，可以有效节省 CDN 传输带宽，加速图片渲染速度。</span></p><p id="b75cf7af42d73f151d4527a77372a282" class="ne-p"><br></p><h2 id="TJ0xN"><span class="ne-text">网站防攻击</span></h2><h3 id="RhH3k"><span class="ne-text">IP限制访问</span></h3><h3 id="mJNT8"><span class="ne-text">CC防护</span></h3></div>]]></content>
      
      
      <categories>
          
          <category> 计算机素养 </category>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>『Re：从零开始的异世界生活』</title>
      <link href="/essay/ghnpqy/"/>
      <url>/essay/ghnpqy/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content-editor-core lake-engine lake-typography-traditional" data-lake-element="root" data-selection-undefined="%7B%22path%22%3A%5B%5B9%2C0%2C0%2C0%5D%2C%5B9%2C0%2C0%2C0%5D%5D%2C%22active%22%3Atrue%7D"><blockquote class="lake-alert lake-alert-info" style="margin: 0px; padding: 10px; border: 1px solid rgb(171, 210, 218); opacity: 1; border-radius: 3px; color: rgb(38, 38, 38); background-color: rgb(232, 247, 255);"><p data-lake-id="f82967bdc4f33d74704b90cc17462368" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">“我可是经历过死亡的人！”</p></blockquote><p data-lake-id="9582e6df9c987b482d5ae48d02c1207a" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">第一次听到486说这句话的时候，我是有很大的感触的，甚至是共鸣，因为，见过地狱的人啊……被历史所记载下来的人，总有异于常人的行为准则。</p><p data-lake-id="93f88d7b67a29f6e5043166a785be1a7" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="748c5d0ccf51ff03bb7ffb8ae680b705" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">希特勒，大三寒假在家那会在家看了郭伟强作者译作的《希特勒》一书，以前，我觉得我或多或少了解那个恶魔，因为二战，我觉得这人应该是人们脑海中残酷战争的人形代表吧。或在少年时期，一个人的精神和心智都是极其可变的……</p><p data-lake-id="ea13745d49ec3d0d175d5512c05a82d1" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="623c379379a9be6c5b0afa3cafaede57" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">如果把思维换一下来思考，如果，我明天就死了，那么现在的我会做出什么样的行为呢？因为懂得地狱的可怕，那可怕来自心里面的恐惧、来自亲人爱人的离去、来自一切想要去守护的人的离去……</p><p data-lake-id="3f708d4e7760af998e9917ebb5f534fb" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="4a036f0e7c834ee8e8133f7fb45ddfb5" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">见过地狱的人啊。</p><p data-lake-id="28bca212f0929138b04e3bb7b9562f15" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><blockquote class="lake-alert lake-alert-info" style="margin: 0px; padding: 10px; border: 1px solid rgb(171, 210, 218); opacity: 1; border-radius: 3px; color: rgb(38, 38, 38); background-color: rgb(232, 247, 255);"><p data-lake-id="2ad95152849478bfedeb874ea2d3c77e" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">如果真爱有颜色，那么一定是蓝色</p></blockquote><p data-lake-id="9ed6dea072e29351ce02dd1b1a0799b5" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p></div>]]></content>
      
      
      <categories>
          
          <category> 影视 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>『进击的巨人』是信仰</title>
      <link href="/essay/ebg1s8/"/>
      <url>/essay/ebg1s8/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="u16d69534" class="ne-p"><br></p><p id="839fa5a74076a91fd8a9efafff6083df" class="ne-p"><span class="ne-text">21.05更</span></p><p id="5097b817a0f098f248b241986ed021cd" class="ne-p"><br></p><p id="b602fce0790b25ea19dfb9d2b3dc357a" class="ne-p"><span class="ne-text" style="text-decoration: line-through">海的那边，是自由。</span></p><p id="ea8283829c3eb468b290fd73e112a5ff" class="ne-p"><br></p><p id="899f17bd9c2b0a163e7903c1fb2a3ae1" class="ne-p" style="text-align: center"><span class="ne-text">海的那边，是杀千刀的jsc</span><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1623928492929-ffc048a0-5a85-4f9c-81d6-c71ceda450b5.jpeg" width="75" id="uLVJZ" class="ne-image"></p><p id="u0e3d2f1f" class="ne-p"><br></p><p id="ua85c884d" class="ne-p"><br></p><p id="u4fee72c6" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1623928497065-1e541eba-d224-4125-acee-eb249a83bb3b.jpeg" width="50" id="oqhQI" class="ne-image"></p><p id="1c0798c40473c4568795382dab34c1b6" class="ne-p"><br></p><p id="u5bebfd35" class="ne-p"><br></p><p id="a20d224c568e48b9d67847a2c66a8c01_p_0" class="ne-p"><span class="ne-text">兵长永远是最强的……</span></p><div data-type="info" class="ne-alert"><p id="a7f15d06ca2c0995d66a7da1b165d31d" class="ne-p"><span class="ne-text">你刚才玩的挺开心啊~ </span></p></div><p id="9289e6820487cb3409cda6b787257264" class="ne-p"><br></p><p id="u0a7b4f25" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1619319047360-440f4560-ea7d-4751-822c-0451f0fa40f0.jpeg" width="1100" id="u0d61af7a" class="ne-image"></p><p id="u4b9307cc" class="ne-p"><br></p><p id="27142e226e7527b83e8ddfcece1c2609" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1619482927278-c7d820d9-9797-45ff-89a6-3fc5b4a10304.png" width="1920" id="GvVBt" class="ne-image"></p><p id="fd087ac5a1d6d2d8ba543b8f88885c02" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1619482904818-7bc6ef93-00d8-4fc1-ac3b-75338fb25a41.png" width="1920" id="LStyO" class="ne-image"></p><p id="2a043388ce9bc1b8ca2fc03e7a60384f" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1619482905865-3e7b798f-1888-4ecc-86fd-8200bc78b73b.png" width="1920" id="ExxI6" class="ne-image"></p><p id="udff024df" class="ne-p"><br></p><p id="d19b4a6ad39c6f287df567df62781f89" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1619482909799-aec5bedb-ce37-4f2c-959a-b15c3bd34e8f.png" width="1920" id="W3TmY" class="ne-image"></p><p id="u3c1697cb" class="ne-p"><br></p><p id="u07da6580" class="ne-p"><br></p><p id="ucbeaa1fe" class="ne-p"><br></p><p id="7d22db10ae09c5cbd7d4f68c1097bab9" class="ne-p"><br></p></div>]]></content>
      
      
      <categories>
          
          <category> 影视 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Nodejs包管理工具以及NPM的包发布</title>
      <link href="/blog/auczes/"/>
      <url>/blog/auczes/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="uecac80f3" class="ne-p"><span class="ne-text">前言：介绍Node.js包的几种管理工具（Rush， NPM，Yarn，PNPM），同时介绍完整发布一个NPM包的流程，最后介绍相关Nodejs包相关知识：</span></p><ul class="ne-ul"><li id="u96062865"><span class="ne-text">package.json和package-lock.json文件</span></li><li id="uc420482f"><span class="ne-text">两种本地调试包的方式</span></li><li id="u582fc440"><span class="ne-text">npm账户开启二次验证情况下发布包需要注意的事项</span></li></ul><h2 id="l0NM6"><span class="ne-text">一、Nodejs包管理</span></h2><ul class="ne-ul"><li id="ub690bb7d"><a href="https://rushjs.io/zh-cn/" data-href="https://rushjs.io/zh-cn/" target="_blank" class="ne-link"><span class="ne-text">Rush</span></a><span class="ne-text" style="color: rgb(36, 41, 47); font-size: 14px">：提高性能，提出“中心”包管理</span></li><li id="u5369c135"><a href="https://docs.npmjs.com/getting-started/what-is-npm" data-href="https://docs.npmjs.com/getting-started/what-is-npm" target="_blank" class="ne-link"><span class="ne-text">NPM</span></a><span class="ne-text" style="color: rgb(36, 41, 47); font-size: 14px">: 它是当今最广泛的 JavaScript 包管理工具，它开创了包管理标准，其开发者还维护了世界上最多人使用的分布式开源 JavaScript 包管理网站 npmjs.com.</span></li><li id="u84803965"><a href="https://yarnpkg.com/en/" data-href="https://yarnpkg.com/en/" target="_blank" class="ne-link"><span class="ne-text">Yarn</span></a><span class="ne-text" style="color: rgb(36, 41, 47); font-size: 14px">: 它重新实现了 NPM, 与之相比，Yarn 具有相同的管理方式，但是安装速度更快，稳定性更好，而且提供了一些新特性（例如 Yarn workspaces），用于大型开发。</span></li><li id="ueada952f"><a href="https://rushjs.io/zh-cn/pages/maintainer/package_managers/pnpm.js.org/" data-href="https://rushjs.io/zh-cn/pages/maintainer/package_managers/pnpm.js.org/" target="_blank" class="ne-link"><span class="ne-text">PNPM</span></a><span class="ne-text" style="color: rgb(36, 41, 47); font-size: 14px">: 它提供了一个全新的包管理模式，该模式解决了</span><a href="https://rushjs.io/zh-cn/pages/advanced/phantom_deps/" data-href="https://rushjs.io/zh-cn/pages/advanced/phantom_deps/" target="_blank" class="ne-link"><span class="ne-text">“幻影依赖”和“ NPM 分身”</span></a><span class="ne-text" style="color: rgb(36, 41, 47); font-size: 14px">的问题，同时</span><a href="https://en.wikipedia.org/wiki/Symbolic_link" data-href="https://en.wikipedia.org/wiki/Symbolic_link" target="_blank" class="ne-link"><span class="ne-text">符号链接</span></a><span class="ne-text" style="color: rgb(36, 41, 47); font-size: 14px">使之与 NodeJS 模块解析标准保持 100% 兼容。</span></li></ul><h2 id="YqBrW"><span class="ne-text" style="font-size: 14px">二、注册并发布一个包</span></h2><h3 id="kkq24"><span class="ne-text">注册npm账号</span></h3><ul class="ne-ul"><li id="u4e482340"><span class="ne-text">在官网</span><a href="https://www.npmjs.com/" data-href="https://www.npmjs.com/" target="_blank" class="ne-link"><span class="ne-text">https://www.npmjs.com/</span></a><span class="ne-text">注册用户账号</span></li></ul><p id="7b67f700fc2618c4889c569f03571a45" class="ne-p"><span class="ne-text">新建一个文件夹</span><code class="ne-code"><span class="ne-text">npm-wzutao</span></code><span class="ne-text">在此文件夹下进入bash终端键入下面命令：</span></p><pre><code>npm login</code></pre><p id="uc8c7b1a6" class="ne-p"><span class="ne-text">登录自己的npm账号，后面发布包就会发布在该账号下。</span></p><p id="75c981f231fa9b50abcdd5eef37d4c4f" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612782412366-aeecc92e-a5e0-4f3d-9172-c607a5c06199.png" width="441" id="eG8zD" class="ne-image"></p><h3 id="Jhyb4"><span class="ne-text">初始化项目</span></h3><p id="ubd56e175" class="ne-p"><span class="ne-text">键入下面命令初始化一个空项目：</span></p><pre><code>npm init</code></pre><div class="ne-quote"><p id="uaa29513c" class="ne-p"><span class="ne-text">也可以快速初始化创建 </span><code class="ne-code"><span class="ne-text">npm init -y</span></code><span class="ne-text"></span></p></div><p id="032261ab2267b7c64df525e1d6e2d3c8" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612782805229-e691af8b-0440-4fdb-baa6-63f5089017bb.png" width="421.5" id="QpvJz" class="ne-image"></p><p id="a7c376cf9eb4f7346c5981827ee5eedc" class="ne-p"><span class="ne-text">然后在该文件夹下新建index.js文件，写入如下测试代码</span></p><pre><code>exports.sum = function() &#123;  var res = 0;<p>  for (var i=0; i&lt;arguments.length; i++) &#123;<br>    res+=arguments[i];<br>  &#125;</p><p>  return res;<br>&#125;<br></code></pre></p><h3 id="ax6yE"><span class="ne-text">发布包</span></h3><p id="uc80f2f9a" class="ne-p"><span class="ne-text">每一个npm包都有一个版本号，发布包也需要有一个明确的版本号才能予以发布。</span></p><h3 id="kmtU6"><span class="ne-text">包版本更新</span></h3><div data-type="info" class="ne-alert"><p id="u1b0f5548" class="ne-p"><strong><span class="ne-text">npm包发布/版本更新，都需要包的版本明确，而更新包的版本，有两种方式，</span></strong></p><ol class="ne-ol"><li id="u938c875f"><strong><span class="ne-text">第一种是更改package.json文件中的version字段为指定版本号，再进行npm publish更新</span></strong></li><li id="ucca4e1c8"><strong><span class="ne-text">第二种就是通过命令来更新新版本号，进而npm publish更新</span></strong></li></ol></div><p id="uabc37cf1" class="ne-p" style="text-align: center"><span class="ne-text">通过命令来更新版本号</span></p><p id="a0d0d96455a0e3a034f8e033af18abda" class="ne-p"><span class="ne-text">1.0.1版本，注意，是最后一位修改了增1</span></p><pre><code>npm version patch</code></pre><p id="ff342aeb04f702778cf00a0c9dfadc9c" class="ne-p"><span class="ne-text">1.1.0版本，注意，是第二位修改了增1</span></p><pre><code>npm version minor</code></pre><p id="b34da549bdc61335754b6988ab38b6b5" class="ne-p"><span class="ne-text">2.0.0版本，注意，是第一位修改了增1</span></p><pre><code>npm version major </code></pre><p id="a6500e075d8e03725ce3d17a22a57c3a" class="ne-p"><span class="ne-text">最后再提交到远端npm中</span></p><pre><code>npm publish </code></pre><h3 id="vlmJW"><span class="ne-text">包发布</span></h3><pre><code>npm publish </code></pre><p id="ef1594fce6927ef0a6c3fe35e331be5a" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612782959102-a6d78720-76a0-472a-b0d9-430c83ce7c8b.png" width="380.5" id="JUrwH" class="ne-image"></p><p id="517f6963d46ea21049e4ad7f6edda445" class="ne-p"><span class="ne-text">去官网可以搜索到</span></p><p id="1501a24fc0895f6a88a06ec83e16247c" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612783041850-acf55586-80aa-4cf5-b19a-7f538396fadd.png" width="463" id="nvASC" class="ne-image"></p><h2 id="PXskd"><span class="ne-text">三、package-lock.json</span></h2><p id="ub0414d04" class="ne-p"><span class="ne-text">不同包管理工具生成的锁定文件都不一样。</span></p><ul class="ne-ul"><li id="u00fdb77d"><span class="ne-text"> 锁定包的版本，确保再次下载时不会因为包版本不同而产生问题</span></li><li id="uc636257e"><span class="ne-text"> 加快下载速度，因为该文件中已经记录了项目所依赖第三方包的树状结构和包的下载地址，重新安装时只需下载即可，不需要做额外的工作</span></li></ul><h2 id="PDNY3"><span class="ne-text">四、package.json</span></h2><p id="b761fef007e6bb33a345dcdf85f049db" class="ne-p"><span class="ne-text">项目依赖和开发依赖</span></p><ul class="ne-ul"><li id="4614784420d8f64bbdcb445b0f829234"><span class="ne-text">项目依赖就是这个产品线上运营所依赖的模块，在文件的dependencies字段</span></li></ul><p id="64010e5fb89e52bc8b6ccd04d935aea5" class="ne-p"><span class="ne-text">npm install 包名</span></p><ul class="ne-ul"><li id="481ea4498a95cd9ed976a3b016461235"><span class="ne-text">开发依赖就是项目的开发阶段需要依赖，线上运营阶段不需要依赖的第三方包，称为开发依赖，devDependencies字段    </span></li></ul><p id="db25e905713c554b8d8d279b0f9dc82b" class="ne-p"><span class="ne-text">npm install 包名 --save-dev</span></p><ul class="ne-ul"><li id="5c921b891c22a21e22ee6a23c743d80f"><span class="ne-text">npm install --production，在本地下载依赖的包</span></li><li id="cec76de0e88669a59486d6591be4c196"><span class="ne-text">里面的script使用：npm run XXX</span></li></ul><h3 id="DnH6J"><span class="ne-text">scripts</span></h3><p id="udf22ff82" class="ne-p"><span class="ne-text">大型项目中，npm run xxx 运行命令常常是自行来编写相应的命令脚本</span></p><p id="u134b217d" class="ne-p"><span class="ne-text">参考：</span><a href="https://www.ruanyifeng.com/blog/2016/10/npm_scripts.html" data-href="https://www.ruanyifeng.com/blog/2016/10/npm_scripts.html" target="_blank" class="ne-link"><span class="ne-text">npm scripts 使用指南-阮一峰的网络日志</span></a></p><pre><code>&#123;  &quot;name&quot;: &quot;learn-scripts&quot;,  &quot;version&quot;: &quot;1.0.0&quot;,  &quot;description&quot;: &quot;&quot;,  &quot;main&quot;: &quot;index.js&quot;,  &quot;scripts&quot;: &#123;    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;,    &quot;runFile&quot;: &quot;node index.js&quot;,    &quot;commit&quot;: &quot;git status &amp;&amp; git add . &amp;&amp; git-cz&quot;,    &quot;runBashCommand&quot;: &quot;git --version &amp;&amp; git help -a&quot;  &#125;,  &quot;keywords&quot;: [],  &quot;author&quot;: &quot;&quot;,  &quot;license&quot;: &quot;ISC&quot;&#125;</code></pre><h2 id="mOhk4"><span class="ne-text">五、本地调试npm包的问题</span></h2><h3 id="zx2aQ"><span class="ne-text">相对路径测试所开发的npm包</span></h3><div class="ne-quote"><p id="ucd601d24" class="ne-p"><span class="ne-text">适合项目所需的某一个npm包</span></p></div><p id="u06f37694" class="ne-p"><span class="ne-text">比如a文件夹下有npm包b文件夹和测试插件的c文件夹，那么在c文件夹下使用</span><code class="ne-code"><span class="ne-text">npm i ../b</span></code><span class="ne-text">命令来下载本地开发的npm包。</span></p><h3 id="GGa6K"><span class="ne-text">npm link链接全局测试</span></h3><div class="ne-quote"><p id="u35c0d46a" class="ne-p"><span class="ne-text">适合脚手架类型的npm包</span></p></div><p id="ud70dcdbf" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1644571675015-971bcbde-3119-43dd-90ed-8ef33c5bb478.png" width="436" id="ue70d5364" class="ne-image"></p><p id="ufb736e32" class="ne-p"><span class="ne-text">node全局包目录如下：其实就是链接使用一下而已</span></p><p id="ua4546a51" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1644571733855-7615cfb8-8648-4468-ad35-199c95161160.png" width="428" id="u1fb22cf2" class="ne-image"></p><h2 id="awRFg"><span class="ne-text">六、其他</span></h2><h3 id="y4elJ"><span class="ne-text">npm账户开启Two-Factor Authentication</span></h3><p id="ub99909ac" class="ne-p"><span class="ne-text">现在很多应用软件都有二级验证的功能，如果npm开启二级验证，可以提高安全性，开启后为如下：</span></p><p id="u6340f1a3" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1668916685382-4234ae1e-68c5-4612-8576-ed7cb8f5177d.png" width="1331.2" id="uc2dd7d67" class="ne-image"></p><p id="u062a43c7" class="ne-p"><span class="ne-text">开启了二级验证，如果发布包有如下报错：</span></p><pre><code>npm ERR! code E403npm ERR! 403 403 Forbidden - PUT https://registry.npmjs.org/@clem_b%2fweather - Forbiddennpm ERR! 403 In most cases, you or one of your dependencies are requestingnpm ERR! 403 a package version that is forbidden by your security policy, ornpm ERR! 403 on a server you do not have access to.</code></pre><p id="u70496756" class="ne-p"><span class="ne-text">重新npm login登录</span></p><p id="u51e42637" class="ne-p"><span class="ne-text">然后npm publish会需要输入一个Recovery Codes，在账户如下位置获取输入即可：</span></p><p id="u95460b96" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1668916914523-57cac265-c530-4a2c-b34d-9bb449ce8cb0.png" width="449.6" id="ude5e45af" class="ne-image"></p><p id="u2d6cd107" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1668916885408-b2f805cc-8934-4ce9-9cea-d73e1c6e899f.png" width="669.6" id="u40632052" class="ne-image"></p><p id="u16ccada3" class="ne-p"><span class="ne-text"></span></p><p id="ub366ce6c" class="ne-p"><br></p><p id="uf94cc0fa" class="ne-p"><br></p><p id="u2bd2b3e6" class="ne-p"><br></p><p id="ub9f93926" class="ne-p"><br></p><p id="u261f9f25" class="ne-p"><br></p><p id="u4f1d2581" class="ne-p"><br></p><p id="u4ee189f1" class="ne-p"><br></p><p id="u8d8e699d" class="ne-p"><br></p><p id="u137cb713" class="ne-p"><br></p><p id="u772263b6" class="ne-p"><br></p><p id="u38742d5f" class="ne-p"><br></p><p id="uf7071aac" class="ne-p"><br></p><p id="ue0e3a7f8" class="ne-p"><br></p><p id="u8cc97c80" class="ne-p"><br></p><p id="u13adf36e" class="ne-p"><br></p></div>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
          <category> Node.js </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>IDEA环境下的Javaweb开发bug汇总</title>
      <link href="/blog/aiuif3/"/>
      <url>/blog/aiuif3/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h2 id="haJK6"><span class="ne-text">Unsupported major.minor version 52.0</span></h2><div class="ne-quote"><p id="8b6445fca96b6712b87ad3cd7cf9f186" class="ne-p"><span class="ne-text">版本过低</span></p></div><pre><code>[2021-02-07 08:25:52,537] Artifact javaweb-blog:war exploded: Error during artifact deployment. See server log for details.</code></pre><pre><code> java.lang.UnsupportedClassVersionError: com/nic/filter/AdminFilter : Unsupported major.minor version 52.0 (unable to load class com.nic.filter.AdminFilter)</code></pre><p id="277c3637042e99ad42b2160eefccc7ec" class="ne-p"><span class="ne-text">一直报错，网上找一直是说和jdk的版本有关，但是jdk的版本尝试更换几个都无效。事实上是Tomcat的版本问题，项目开始用的是Tomcat8.1升级至8.5.34即可（升级Tomcat9可以否？会对下兼容吗？trytry）</span></p><h2 id="gN7tT"><span class="ne-text">org.apache.tomcat.util.descriptor.web.WebXml.setVersion Unknown version string [4.0]</span></h2><div class="ne-quote"><p id="c4f1c8b91c3989e72d1e0ddcde6fbed2" class="ne-p"><span class="ne-text">warning：4.0太高</span></p></div><pre><code>org.apache.tomcat.util.descriptor.web.WebXml.setVersion Unknown version string [4.0]</code></pre><ul class="ne-ul"><li id="77c385a4bfefd7ab229818af44b46978"><span class="ne-text">解决：</span><a href="https://blog.csdn.net/qq_32483145/article/details/80292463" data-href="https://blog.csdn.net/qq_32483145/article/details/80292463" target="_blank" class="ne-link"><span class="ne-text">https://blog.csdn.net/qq_32483145/article/details/80292463</span></a></li></ul><h2 id="sc9fQ"><span class="ne-text">用到servlet的页面跳转404</span></h2><h3 id="egmby"><span class="ne-text">web.xml配置有误</span></h3><p id="720ced33822230ccd0a1638e30626880" class="ne-p"><span class="ne-text">页面能访问，也成功部署到tomcat下面的weapps文件夹下面，但是在进行页面跳转的过程中，会出现下面的404情况。分析之后是我这个项目是新建的一个空项目，然后代码是之前在eclipse下运行过的，而后直接将内容代码复制过来，却没复制web.xml，导致现项目的web.xml是“空的”，无配置。</span></p><p id="2afa0a40ee013ac80d38eccef28697e1" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612753264339-b79c791c-6814-4c38-b42d-6b85bb9c1d5f.png" width="960" id="VxL8Y" class="ne-image"></p><h3 id="DzlOe"><span class="ne-text">Tomcat路径配置有误</span></h3><p id="933000fed5ab6a8a438b766c6990a595" class="ne-p"><span class="ne-text">还有一种情况，就是tomcat配置过程中的那两个路径也要注意下</span></p><p id="808e36351971917c539103a32c77cfdf" class="ne-p"><span class="ne-text">调整为如下配置，不然会出现访问/jsp-peojectname/jsp-</span><span class="ne-text">peojectname</span><span class="ne-text">/index.jsp页面为404的情况</span></p><p id="5d1ec0127af429a814e1f0826c870ac1" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612756924057-55c60ad3-85b8-4cf0-aa9d-6184bfbd296e.png" width="805.5" id="rdvlv" class="ne-image"></p><p id="ae4a94dd9ea0f3ddaaafe1de77482ba4" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612756936656-72d837f5-46ef-4d35-8e39-e49d2c6f077d.png" width="805.5" id="qzUm9" class="ne-image"></p><h3 id="k4028"><span class="ne-text">其他类型错误</span></h3><p id="57df7bd56a6945c07c448efdaebd0b9f" class="ne-p"><span class="ne-text">可能还有其他类型错误，参考以下的总结</span></p><p id="1d717f539e59f4168a0041eae023681c" class="ne-p"><br></p><ul class="ne-ul"><li id="81517281bc6077014324468ebe1af49d"><a href="https://blog.csdn.net/DBC_121/article/details/79204340" data-href="https://blog.csdn.net/DBC_121/article/details/79204340" target="_blank" class="ne-link"><span class="ne-text">Web开发：关于Tomcat出现The origin server did not find a current representation for the target resourc...的问题</span></a></li></ul><h2 id="e1ijn"><span class="ne-text">数据库报错</span></h2><p id="951707ef5652cfb006c0098cc2a8c3d2" class="ne-p"><span class="ne-text">navicat也不能查看该数据库</span></p><pre><code>HTTP Status 500 – Internal Server ErrorType Exception Report<p>Message get connection error!</p><p>Description The server encountered an unexpected condition that prevented it from fulfilling the request.</p><p>Exception</p><p>java.lang.RuntimeException: get connection error!<br>    com.nic.util.JdbcUtil.getConnection(JdbcUtil.java:55)<br>    com.nic.dao.ArticleDao.findArticle(ArticleDao.java:56)<br>    com.nic.service.ArticleService.findArticle(ArticleService.java:20)<br>    com.nic.servlet.PostlistServlet.doGet(PostlistServlet.java:50)<br>    javax.servlet.http.HttpServlet.service(HttpServlet.java:635)<br>    javax.servlet.http.HttpServlet.service(HttpServlet.java:742)<br>    org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:52)<br>Root Cause</p><p>java.lang.ClassNotFoundException: com.mysql.jdbc.Driver<br>    org.apache.catalina.loader.WebappClassLoaderBase.loadClass(WebappClassLoaderBase.java:1309)<br>    org.apache.catalina.loader.WebappClassLoaderBase.loadClass(WebappClassLoaderBase.java:1137)<br>    java.lang.Class.forName0(Native Method)<br>    java.lang.Class.forName(Class.java:264)<br>    com.nic.util.JdbcUtil.getConnection(JdbcUtil.java:52)<br>    com.nic.dao.ArticleDao.findArticle(ArticleDao.java:56)<br>    com.nic.service.ArticleService.findArticle(ArticleService.java:20)<br>    com.nic.servlet.PostlistServlet.doGet(PostlistServlet.java:50)<br>    javax.servlet.http.HttpServlet.service(HttpServlet.java:635)<br>    javax.servlet.http.HttpServlet.service(HttpServlet.java:742)<br>    org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:52)<br>Note The full stack trace of the root cause is available in the server logs.</p><p>Apache Tomcat/8.5.34<br></code></pre></p><p id="00f4969e188ff08a736523f47b566cc3" class="ne-p"><span class="ne-text">初步分析是用的phpstudy里面的mysql数据库不能生效，删除电脑之前的mysql，用phpstudy数据库恢复</span></p><p id="ebe37768bdb0e8d77497b3646c0c6097" class="ne-p"><br></p><hr id="sDbaj" class="ne-hr"><p id="c3a3977ed9581b78769ef322e738ad5e" class="ne-p"><br></p><p id="7ee329e34b272736f7371a549825b9b7" class="ne-p"><span class="ne-text">但是还会报错，判断应该是代码文件出错【不过不用将这个jar包导入到lib文件夹下（反而会报错），只需要将其导入到tomcat文件夹下的lib文件夹，即可】</span></p><p id="d85975554ed07e722c2c5206034f904a" class="ne-p"><a href="https://www.yuque.com/attachments/yuque/0/2021/jar/1484158/1612768356808-4c69cbaa-cbc7-4ebe-9232-423cad8ef54f.jar" id="xrOhc" class="ne-card-file">📎mysql-connector-java-5.1.49.jar</a><span class="ne-text">（或者直接上网搜再下载）</span></p><p id="c7fe26f2bacf06bbc7f62483c99bf7cd" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612756117413-4649efa1-9274-4ae5-aa1a-463750acd571.png" width="645.5" id="ISElc" class="ne-image"><span class="ne-text" style="text-decoration: line-through"></span></p></div>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
          <category> Bug记录 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>IDEA创建JavaWeb项目</title>
      <link href="/blog/qi1ddv/"/>
      <url>/blog/qi1ddv/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content-editor-core lake-engine lake-typography-classic" data-lake-element="root" data-selection-undefined="%7B%22path%22%3A%5B%5B0%2C0%2C0%5D%2C%5B0%2C0%2C0%5D%5D%2C%22active%22%3Atrue%7D"><h2 data-lake-id="63edee382d63173f31043ce80330d00c" id="Dj8JX" style="padding: 7px 0px; margin: 0px; font-weight: 700; font-size: 24px; line-height: 32px;">一、Tomcat下载</h2><h3 id="7730a6e8" data-lake-id="513d1fed45f203afb36a3282392efce6" style="padding: 7px 0px; margin: 0px; font-weight: 700; font-size: 20px; line-height: 28px;">1. 下载并安装</h3><blockquote style="margin-top: 5px; margin-bottom: 5px; padding-left: 1em; margin-left: 0px; border-left: 3px solid rgb(238, 238, 238); opacity: 0.6;"><p data-lake-id="cdeb1a2587df0cff6bc0867ac63ae028" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">假如不是集成开发环境（比如phpstudy），电脑要有jdk环境</p></blockquote><p data-lake-id="bc94ef466687aa2d0d5c348c89a605b1" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">【1】官网下载：<a href="http://tomcat.apache.org/" target="_blank">http://tomcat.apache.org/</a><br></p><p data-lake-id="8522c6b890b66cefcf2157063ae6ec6b" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span data-card-type="inline" data-lake-card="image" class="lake-card-margin-top lake-card-margin-bottom"><img data-role="image" src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598787914511-a035ba93-0b7a-450b-b391-5d1452435ca7.png" data-raw-src="" class="image lake-drag-image" alt="image" title="image" data-height="220px" style="visibility: visible; width: 425px;"></span></p><p data-lake-id="c448ace09b5ab2511b5eaae7a7198390" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">【2】下载并解压到自己的相应盘区，再检验是否成功<br><span data-card-type="inline" data-lake-card="image" class="lake-card-margin-top lake-card-margin-bottom"><img data-role="image" src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598787914448-2ef2e1a1-2966-4d35-8bfe-82162aa1588b.png" data-raw-src="" class="image lake-drag-image" alt="image" title="image" data-height="273px" style="visibility: visible; width: 431px;"></span></p><p data-lake-id="4ca05aa2f9fe762f0022dfa8a6113f7c" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">点击第二个框不出现闪退情况则证明成功<br><span data-card-type="inline" data-lake-card="image" class="lake-card-margin-top lake-card-margin-bottom"><img data-role="image" src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598787914507-87063aec-884a-4180-b124-568478d81bc0.png" data-raw-src="" class="image lake-drag-image" alt="image" title="image" data-height="222px" style="visibility: visible; width: 425px;"></span></p><p data-lake-id="4915bda3aec13cd32e89560157a6b5cd" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">【3】浏览器进入端口<a href="http://localhost:8080/" target="_blank">http://localhost:8080/</a>上述配置成功则表明成功<br><span data-card-type="inline" data-lake-card="image" class="lake-card-margin-top lake-card-margin-bottom"><img data-role="image" src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598787914624-248148e3-3f5f-45ca-ad93-c063216a7aff.png" data-raw-src="" class="image lake-drag-image" alt="image" title="image" data-height="270px" style="visibility: visible; width: 482px;"></span></p><h3 data-lake-id="377cdb334b9f35b942b445fb097803a4" id="iCBvN" style="padding: 7px 0px; margin: 0px; font-weight: 700; font-size: 20px; line-height: 28px;">2. 过程中可能会出现的问题</h3><p data-lake-id="1b07bf46e0e492e2d6dadc399e9717b2" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">【1】点击startup.bat文件出现闪退</p><blockquote style="margin-top: 5px; margin-bottom: 5px; padding-left: 1em; margin-left: 0px; border-left: 3px solid rgb(238, 238, 238); opacity: 0.6;"><p data-lake-id="d0708110248ea1defede037ed433609d" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">电脑中java jdk有无（JAVA_HOME）</p></blockquote><p data-lake-id="85ad0082aa384b1084a06bd69738afb5" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">【2】端口被占用</p><blockquote style="margin-top: 5px; margin-bottom: 5px; padding-left: 1em; margin-left: 0px; border-left: 3px solid rgb(238, 238, 238); opacity: 0.6;"><p data-lake-id="24a8ae1eb8271058383cc3b3e898f668" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">进入Tomcat文件夹下的conf文件下的server.xml文件，用记事本查找8080，下面复制一个新的初始端口<br><span data-card-type="inline" data-lake-card="image"><img data-role="image" src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598787914513-8083bc6e-4c6f-436e-b0b0-98d3d70b9dea.png" data-raw-src="" class="image lake-drag-image" alt="image" title="image" data-height="80px" style="visibility: visible; width: 557px;"></span></p></blockquote><h2 data-lake-id="6bc83becd1fe9c21f1844e5bdf59ecad" id="2V0Nz" style="padding: 7px 0px; margin: 0px; font-weight: 700; font-size: 24px; line-height: 32px;">二、利用IDEA创建一个JavaWeb项目</h2><h3 data-lake-id="ea6285186d8d02895a9f1ab20d84c474" id="kX4ZX" style="padding: 7px 0px; margin: 0px; font-weight: 700; font-size: 20px; line-height: 28px;">1. 创建新项目</h3><p data-lake-id="a33553342d0f213e7d6dafc265f4ca1a" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">依次点击：<code style="font-family: monospace; font-size: inherit; background-color: rgba(0, 0, 0, 0.06); padding: 0px 2px; border: 1px solid rgba(0, 0, 0, 0.08); border-radius: 2px; line-height: inherit; overflow-wrap: break-word; text-indent: 0px;">File </code>-&gt; <code style="font-family: monospace; font-size: inherit; background-color: rgba(0, 0, 0, 0.06); padding: 0px 2px; border: 1px solid rgba(0, 0, 0, 0.08); border-radius: 2px; line-height: inherit; overflow-wrap: break-word; text-indent: 0px;">New </code>-&gt; <code style="font-family: monospace; font-size: inherit; background-color: rgba(0, 0, 0, 0.06); padding: 0px 2px; border: 1px solid rgba(0, 0, 0, 0.08); border-radius: 2px; line-height: inherit; overflow-wrap: break-word; text-indent: 0px;">Project</code></p><p data-lake-id="85b492a8a49c44e13da27c1a31ffcd6e" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span data-card-type="inline" data-lake-card="image" class="lake-card-margin-top lake-card-margin-bottom"><img data-role="image" src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612697874347-fef7ad38-7ff2-4567-89a9-f5d47a1f4824.png" data-raw-src="" class="image lake-drag-image" alt="image.png" title="image.png" data-height="316px" style="visibility: visible; width: 468px;"></span></p><p data-lake-id="44f05783ba13cbcdd975831c5213e32a" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><h3 data-lake-id="a7b20ac4ecdef728f599dee7b2b355c6" id="ca24o" style="padding: 7px 0px; margin: 0px; font-weight: 700; font-size: 20px; line-height: 28px;">2. 项目工程配置</h3><p data-lake-id="f7187cc17ab2441a7628f7dd3098f399" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">【1】在<code style="font-family: monospace; font-size: inherit; background-color: rgba(0, 0, 0, 0.06); padding: 0px 2px; border: 1px solid rgba(0, 0, 0, 0.08); border-radius: 2px; line-height: inherit; overflow-wrap: break-word; text-indent: 0px;">WEB-INF</code>下创建两个空文件夹 <code style="font-family: monospace; font-size: inherit; background-color: rgba(0, 0, 0, 0.06); padding: 0px 2px; border: 1px solid rgba(0, 0, 0, 0.08); border-radius: 2px; line-height: inherit; overflow-wrap: break-word; text-indent: 0px;">classes</code> <code style="font-family: monospace; font-size: inherit; background-color: rgba(0, 0, 0, 0.06); padding: 0px 2px; border: 1px solid rgba(0, 0, 0, 0.08); border-radius: 2px; line-height: inherit; overflow-wrap: break-word; text-indent: 0px;">lib</code></p><blockquote style="margin-top: 5px; margin-bottom: 5px; padding-left: 1em; margin-left: 0px; border-left: 3px solid rgb(238, 238, 238); opacity: 0.6;"><p data-lake-id="60d32c5535bfbcd0d5f213ef9c70bd1e" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">目的：</p><ul data-lake-id="feba500e96a86bb1041a43d559e44693" lake-indent="0" style="list-style-type: disc; margin: 0px; padding-left: 23px; font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word;"><li data-lake-id="48148cfee554a99d0ac033caa07961f1">classes文件夹用于存放编译后的class文件</li><li data-lake-id="2b9fb8455249c12ae514e84b2c663eb9">lib文件夹用于存放依赖的jar包</li></ul></blockquote><p data-lake-id="9cd21d9459c6fa83fbd7072ac0a7ed5e" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span data-card-type="inline" data-lake-card="image" class="lake-card-margin-top lake-card-margin-bottom"><img data-role="image" src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612697966439-ab639870-61ab-429e-919a-4109c8cefdc5.png" data-raw-src="" class="image lake-drag-image" alt="image.png" title="image.png" data-height="237px" style="visibility: visible; width: 234.5px;"></span></p><p data-lake-id="fbc92aea63ea53816bc2e2d9bb37eb57" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">【2】依次点击<code style="font-family: monospace; font-size: inherit; background-color: rgba(0, 0, 0, 0.06); padding: 0px 2px; border: 1px solid rgba(0, 0, 0, 0.08); border-radius: 2px; line-height: inherit; overflow-wrap: break-word; text-indent: 0px;">file</code> -&gt; <code style="font-family: monospace; font-size: inherit; background-color: rgba(0, 0, 0, 0.06); padding: 0px 2px; border: 1px solid rgba(0, 0, 0, 0.08); border-radius: 2px; line-height: inherit; overflow-wrap: break-word; text-indent: 0px;">Project Structure</code></p><blockquote style="margin-top: 5px; margin-bottom: 5px; padding-left: 1em; margin-left: 0px; border-left: 3px solid rgb(238, 238, 238); opacity: 0.6;"><p data-lake-id="d311fad424dbaa32f13ed38da6f1aef1" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">目的：将后面编译的class文件默认生成到刚刚新建的classes目录下</p></blockquote><p data-lake-id="a7a1d5bf2941814cd63ec1061062229a" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span data-card-type="inline" data-lake-card="image" class="lake-card-margin-top lake-card-margin-bottom"><img data-role="image" src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612698144393-24e78472-430b-47a4-b423-e091597bb4f3.png" data-raw-src="" class="image lake-drag-image" alt="image.png" title="image.png" data-height="364px" style="visibility: visible; width: 767.5px;"></span></p><p data-lake-id="18f53294b5e9ef9d29dc9be26d13d2a2" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>【3】</span>依次点击<code style="font-family: monospace; font-size: inherit; background-color: rgba(0, 0, 0, 0.06); padding: 0px 2px; border: 1px solid rgba(0, 0, 0, 0.08); border-radius: 2px; line-height: inherit; overflow-wrap: break-word; text-indent: 0px;">file</code> -&gt; <code style="font-family: monospace; font-size: inherit; background-color: rgba(0, 0, 0, 0.06); padding: 0px 2px; border: 1px solid rgba(0, 0, 0, 0.08); border-radius: 2px; line-height: inherit; overflow-wrap: break-word; text-indent: 0px;">Project Structure</code></p><blockquote style="margin-top: 5px; margin-bottom: 5px; padding-left: 1em; margin-left: 0px; border-left: 3px solid rgb(238, 238, 238); opacity: 0.6;"><p data-lake-id="26a7a3be5c0b93cda4d7bd3186de182f" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>目的：添加jar包依赖</span></p><span>（项目所需要的jar包都放到刚刚新建的lib文件夹）</span></blockquote><p data-lake-id="505a9f1841b26a39c285413b254e094d" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span data-card-type="inline" data-lake-card="image" class="lake-card-margin-top lake-card-margin-bottom"><img data-role="image" src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612698241583-99ff6441-6e2a-4776-addb-9f8f1eda6636.png" data-raw-src="" class="image lake-drag-image" alt="image.png" title="image.png" data-height="268px" style="visibility: visible; width: 637px;"></span></p><p data-lake-id="46932e6db80853ecaf2db465130f6659" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span data-card-type="inline" data-lake-card="image" class="lake-card-margin-top lake-card-margin-bottom"><img data-role="image" src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612698274993-98e1b314-c726-41e6-973e-1dbb07ef7312.png" data-raw-src="" class="image lake-drag-image" alt="image.png" title="image.png" data-height="169px" style="visibility: visible; width: 273px;"></span></p><p data-lake-id="01d3b67e0258655ffbd019fb957650e3" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">【4】配置打包方式Artifacts</p><blockquote style="margin-top: 5px; margin-bottom: 5px; padding-left: 1em; margin-left: 0px; border-left: 3px solid rgb(238, 238, 238); opacity: 0.6;"><p data-lake-id="b30429f17ec665ec50adada7955b5fc9" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span style="text-decoration: line-through;">点击 Artifacts选项卡，IDEA会为该项目自动创建一个名为“JavaWeb:war exploded”的打包方式，表示 打包成war包，并且是文件展开性的，输出路径为当前项目下的 out 文件夹，保持默认即可。另外勾选下“Build on make”，表示编译的时候就打包部署，勾选“Show content of elements”，表示显示详细的内容列表。</span></p></blockquote><p data-lake-id="be492de58b2f1a37b3074ca9d0524030" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><em>如果按照上面说的，那么会发现发布的项目并没有在 tomcat目录下的webapps目录下，如果项目以前在其他电脑抑或是其他环境下运行过，可能会导致项目的很多子页面默认URL404。</em></p><p data-lake-id="6adde888c2dad0692e419aedbdf59fba" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span style="text-decoration: line-through;"><span data-card-type="inline" data-lake-card="image" class="lake-card-margin-top lake-card-margin-bottom"><img data-role="image" src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612711385355-7645f327-ad5c-40aa-a165-b975f957ebe3.png" data-raw-src="" class="image lake-drag-image" alt="image.png" title="image.png" data-height="239px" style="visibility: visible; width: 442px;"></span></span></p><p data-lake-id="4b4bf89f80972d983c5b16b0eadb929e" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">正确解决办法：<span>项目一开始</span>依次点击<code style="font-family: monospace; font-size: inherit; background-color: rgba(0, 0, 0, 0.06); padding: 0px 2px; border: 1px solid rgba(0, 0, 0, 0.08); border-radius: 2px; line-height: inherit; overflow-wrap: break-word; text-indent: 0px;">file</code> -&gt; <code style="font-family: monospace; font-size: inherit; background-color: rgba(0, 0, 0, 0.06); padding: 0px 2px; border: 1px solid rgba(0, 0, 0, 0.08); border-radius: 2px; line-height: inherit; overflow-wrap: break-word; text-indent: 0px;">Project Structure</code></p><blockquote style="margin-top: 5px; margin-bottom: 5px; padding-left: 1em; margin-left: 0px; border-left: 3px solid rgb(238, 238, 238); opacity: 0.6;"><p data-lake-id="8f12efa200105c52f3d15779ed9a898b" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">1区域：将output路径指定到<code style="font-family: monospace; font-size: inherit; background-color: rgba(0, 0, 0, 0.06); padding: 0px 2px; border: 1px solid rgba(0, 0, 0, 0.08); border-radius: 2px; line-height: inherit; overflow-wrap: break-word; text-indent: 0px;">tomcat</code>的<code style="font-family: monospace; font-size: inherit; background-color: rgba(0, 0, 0, 0.06); padding: 0px 2px; border: 1px solid rgba(0, 0, 0, 0.08); border-radius: 2px; line-height: inherit; overflow-wrap: break-word; text-indent: 0px;">webapps</code>下面（新建一个本项目的同名文件夹）</p><p data-lake-id="abd9ea5850d1befff3660892bbc72fba" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">2区域：Output Layout就是配置这个路径里面生成的所有文件</p><p data-lake-id="25e60282edc2d2048febc6c1313737de" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">3区域：将右边的文件内容脱拉到左边的3区域即可</p></blockquote><p data-lake-id="598c7b395be110ce8f8e6f0209c7f4ec" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span data-card-type="inline" data-lake-card="image" class="lake-card-margin-top lake-card-margin-bottom"><img data-role="image" src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612763067214-29b72122-e8c6-4df1-a112-50ffb6c43084.png" data-raw-src="" class="image lake-drag-image" alt="image.png" title="image.png" data-height="327px" style="visibility: visible; width: 767.5px;"></span></p><h3 data-lake-id="3f143700f8c1c638ae9fe4906888c52e" id="Jd8NS" style="padding: 7px 0px; margin: 0px; font-weight: 700; font-size: 20px; line-height: 28px;">3. Tomcat配置</h3><p data-lake-id="89eeb898fab17ee770d0f6380c33770c" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">【1】点击如下位置进入tomcat容器编辑板块</p><p data-lake-id="03d43cde06396254ee53f33d382247c0" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span data-card-type="inline" data-lake-card="image" class="lake-card-margin-top lake-card-margin-bottom"><img data-role="image" src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612698536983-4544013a-5e2a-43d7-ae31-7aa5c871fb3a.png" data-raw-src="" class="image lake-drag-image" alt="image.png" title="image.png" data-height="151px" style="visibility: visible; width: 960px;"></span></p><p data-lake-id="91aa0bcd803a07deb850e72dd6568301" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">【2】默认会自动给我们生成一个Tomcat容器，基本上只需要配置<code style="font-family: monospace; font-size: inherit; background-color: rgba(0, 0, 0, 0.06); padding: 0px 2px; border: 1px solid rgba(0, 0, 0, 0.08); border-radius: 2px; line-height: inherit; overflow-wrap: break-word; text-indent: 0px;">Deployment</code>即可，如果没有默认生成就新建一个。其中<code style="font-family: monospace; font-size: inherit; background-color: rgba(0, 0, 0, 0.06); padding: 0px 2px; border: 1px solid rgba(0, 0, 0, 0.08); border-radius: 2px; line-height: inherit; overflow-wrap: break-word; text-indent: 0px;">Application server</code>填写本地tomcat的安装目录文件夹即可（因为一台电脑开发可能会有多个tomcat版本）</p><p data-lake-id="8897380c9075558f3b5018b5942afb76" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span data-card-type="inline" data-lake-card="image" class="lake-card-margin-top lake-card-margin-bottom"><img data-role="image" src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612711521404-673143aa-f3fd-4b37-aed1-919d0ea1de1f.png" data-raw-src="" class="image lake-drag-image" alt="image.png" title="image.png" data-height="370px" style="visibility: visible; width: 581.5px;"></span></p><blockquote style="margin-top: 5px; margin-bottom: 5px; padding-left: 1em; margin-left: 0px; border-left: 3px solid rgb(238, 238, 238); opacity: 0.6;"><p data-lake-id="4751dfc4719d21e52368c7c4ef84abaf" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">❗ <span>❗ </span><span>❗</span>如果要换不同版本的tomcat来运行项目，改如下地方：</p><ol data-lake-id="42e3b85723f57f051a6ec4bc28942807" start="1" lake-indent="0" style="list-style-type: decimal; margin: 0px; padding-left: 23px; font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word;"><li data-lake-id="0983b81ebaea8201edd8956e9ad40b99">先将上面图片<code style="font-family: monospace; font-size: inherit; background-color: rgba(0, 0, 0, 0.06); padding: 0px 2px; border: 1px solid rgba(0, 0, 0, 0.08); border-radius: 2px; line-height: inherit; overflow-wrap: break-word; text-indent: 0px;">Application server</code>tomcat版本更换至新的tomcat版本</li><li data-lake-id="26b9a9a2728881d7dfee51df01a30de7">去<code style="font-family: monospace; font-size: inherit; background-color: rgba(0, 0, 0, 0.06); padding: 0px 2px; border: 1px solid rgba(0, 0, 0, 0.08); border-radius: 2px; line-height: inherit; overflow-wrap: break-word; text-indent: 0px;">2. 项目工程配置</code>步骤中，减去原先的tomcat，加上新的tomcat</li></ol></blockquote><p data-lake-id="3d05edbd6075f8407205daa224f41d6d" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span data-card-type="inline" data-lake-card="image" class="lake-card-margin-top lake-card-margin-bottom"><img data-role="image" src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612698612335-158bfcb3-3016-478c-b86a-770ad57ad2a9.png" data-raw-src="" class="image lake-drag-image" alt="image.png" title="image.png" data-height="511px" style="visibility: visible; width: 805.5px;"></span></p><blockquote style="margin-top: 5px; margin-bottom: 5px; padding-left: 1em; margin-left: 0px; border-left: 3px solid rgb(238, 238, 238); opacity: 0.6;"><p data-lake-id="fcc6e35f22cc90a3a23b0e1033060116" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>此处的Application context是指定本工程的根目录</span></p></blockquote><h3 data-lake-id="ef11a24b23822ed53d0781dea7a16aac" id="W4nNn" style="padding: 7px 0px; margin: 0px; font-weight: 700; font-size: 20px; line-height: 28px;">4. 结果测试</h3><p data-lake-id="b40187367ae12b3231bc40304f6bd804" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">在<code style="font-family: monospace; font-size: inherit; background-color: rgba(0, 0, 0, 0.06); padding: 0px 2px; border: 1px solid rgba(0, 0, 0, 0.08); border-radius: 2px; line-height: inherit; overflow-wrap: break-word; text-indent: 0px;">index.jsp</code>文件下添加显示代码</p><p data-lake-id="21666df89e434eec5b18db1bb37d2438" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span data-card-type="inline" data-lake-card="image" class="lake-card-margin-top lake-card-margin-bottom"><img data-role="image" src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612698732177-5bedf912-6a16-47d4-ab96-d5527b9567d1.png" data-raw-src="" class="image lake-drag-image" alt="image.png" title="image.png" data-height="271px" style="visibility: visible; width: 939.5px;"></span></p><p data-lake-id="f7a3fd3c65825d81fea868fc06d0eb25" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">直接运行</p><p data-lake-id="09e25ce396481e2b3aca5f7f8c6e5696" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span data-card-type="inline" data-lake-card="image" class="lake-card-margin-top lake-card-margin-bottom"><img data-role="image" src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612698844575-2952fffc-3616-43f1-be90-138dbe0df86d.png" data-raw-src="" class="image lake-drag-image" alt="image.png" title="image.png" data-height="128px" style="visibility: visible; width: 553.5px;"></span></p><p data-lake-id="7deb6792d8c9120fbbac6a28ebf7672b" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span data-card-type="inline" data-lake-card="image" class="lake-card-margin-top lake-card-margin-bottom"><img data-role="image" src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612698866551-55b0f5c6-fc7e-423a-8c59-2af2cbe08953.png" data-raw-src="" class="image lake-drag-image" alt="image.png" title="image.png" data-height="152px" style="visibility: visible; width: 413.5px;"></span></p><blockquote style="margin-top: 5px; margin-bottom: 5px; padding-left: 1em; margin-left: 0px; border-left: 3px solid rgb(238, 238, 238); opacity: 0.6;"><p data-lake-id="b6085e3cc0216f8d35d519a0e562b8a4" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">如果在Tomcat配置过程中的部署路径为 <code style="font-family: monospace; font-size: inherit; background-color: rgba(0, 0, 0, 0.06); padding: 0px 2px; border: 1px solid rgba(0, 0, 0, 0.08); border-radius: 2px; line-height: inherit; overflow-wrap: break-word; text-indent: 0px;">/</code>&nbsp;，会出现下面第二张图的结果，都能访问，但是最好还是上面的方式，符合服务器“一个文件夹一个站点”的思想，路径访问的相关问题不会挖坑。</p></blockquote><p data-lake-id="6384b0824cca3550d175a9f631244f72" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span data-card-type="inline" data-lake-card="image" class="lake-card-margin-top lake-card-margin-bottom"><img data-role="image" src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612698976241-4d798089-9581-4cdf-893b-dbbc11b18057.png" data-raw-src="" class="image lake-drag-image" alt="image.png" title="image.png" data-height="511px" style="visibility: visible; width: 805.5px;"></span></p><p data-lake-id="88b571e3f5827d45128c9ac83412bfa7" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span data-card-type="inline" data-lake-card="image" class="lake-card-margin-top lake-card-margin-bottom"><img data-role="image" src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612698989649-0fdabed2-a690-450a-b11f-3900a477a68a.png" data-raw-src="" class="image lake-drag-image" alt="image.png" title="image.png" data-height="170px" style="visibility: visible; width: 431px;"></span></p><h3 data-lake-id="83ca51e3f13e327e51a0cc56069e46b8" id="R1vic" style="padding: 7px 0px; margin: 0px; font-weight: 700; font-size: 20px; line-height: 28px;">❗ JavaWeb项目结构分析</h3><p data-lake-id="7d1d88201c20f123f60fad58a0d335d1" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span data-card-type="inline" data-lake-card="image" class="lake-card-margin-top lake-card-margin-bottom"><img data-role="image" src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612752142869-4f7db98f-6d15-4ce5-be4b-1e0e13dcab08.png" data-raw-src="" class="image lake-drag-image" alt="image.png" title="image.png" data-height="444px" style="visibility: visible; width: 160.5px;"></span></p><ul data-lake-id="e48218114418eee1c6b225cb0b6c0c11" lake-indent="0" style="list-style-type: disc; margin: 0px; padding-left: 23px; font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word;"><li data-lake-id="de7105846ee25dd96541b08de713abb5">src文件夹：编写的java代码，编译后会放到WEB-INF文件夹下的classes文件夹</li><li data-lake-id="960358f6438e9c8ad4b73c49ef577158">web文件夹：web应用程序的根目录，web应用程序所有的文件都在该目录下</li><li data-lake-id="861313a8e731c7a452d7b8f08d8d437c">WEB-INF：客户不能直接通过浏览器进行访问</li></ul><ul data-lake-id="ec317f8b6e69c1a32043410ff2186cd4" lake-indent="1" style="list-style-type: none; margin: 0px; padding-left: 23px; font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word;"><ul data-lake-id="d9ce5de85e244dcc12509c7162990199" lake-indent="0" style="list-style-type: circle; margin: 0px; padding-left: 23px;"><li data-lake-id="f58091f122a7030992877d2098635262">classes：存放servlet和其他有用的class文件（编译后的）</li><li data-lake-id="19c93315661297cf7c5b2a2b97c30248">lib：存放web应用程序所需要的jar包</li><li data-lake-id="1b3c16c77c397e317eb79651fce558c2">web.xml：存放部署和配置信息的文件（当前WEB项目的核心配置，Servlet2.5必须有，3.0以后可省略）</li></ul></ul><h2 data-lake-id="dcb67ca02d1f3f693cf0cf7c3f5ed759" id="D87OL" style="padding: 7px 0px; margin: 0px; font-weight: 700; font-size: 24px; line-height: 32px;">参考</h2><ul data-lake-id="c1af10cc941e86734905873a536c92de" lake-indent="0" style="list-style-type: disc; margin: 0px; padding-left: 23px; font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word;"><li data-lake-id="617d69fcbc37a9ed735a1064f8b9fb13"><a href="https://blog.csdn.net/m0_37499059/article/details/78806617" target="_blank"><span>Intellij idea创建javaWeb项目</span></a></li><li data-lake-id="2f592f55bd18fbf7ed8491f0704f90ef"><span><a target="_blank" href="https://blog.csdn.net/c_little_white/article/details/89435646?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.control&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.control">IDEA启动tomcat不报错，tomcat的webapps文件夹没有项目文件，项目的默认URL404</a></span></li></ul></div>]]></content>
      
      
      <categories>
          
          <category> 计算机素养 </category>
          
          <category> 环境搭建 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>BOM各种长宽的总结</title>
      <link href="/blog/5_day05_webapis/"/>
      <url>/blog/5_day05_webapis/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h2 id="554d0"><strong><span class="ne-text">其他关于长宽</span></strong></h2><p id="ub3199948" class="ne-p"><br></p><h3 id="k8Yoi"><span class="ne-text">window.innerWidth和</span><span class="ne-text">innerHeight</span></h3><ul class="ne-ul"><li id="fffcee86f0b69d28fa052f3416ff42a4"><span class="ne-text" style="color: #4D4D4D; font-size: 16px">表示文档显示区域的宽高，不包括工具栏和地址栏等区域；</span></li></ul><p id="48c0d826e3cfdff268e862faa73354a4" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1617937380778-c1f24a67-c63e-49d1-9907-f7fe91880e9f.png" width="618" id="XJRfy" class="ne-image"></p><h3 id="YIozD"><span class="ne-text">window.pageYOffset和</span><span class="ne-text">pageXOffset</span></h3><p id="716976c49a06d30461e5c172d3687ca6" class="ne-p"><span class="ne-text">ie9往后才支持的“被卷去”的长度</span></p><p id="ab9bcc236105cfda1856fe6a98d1320d" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1617938014655-932453ea-63bc-4bc1-8388-63b41417892d.png" width="617" id="zy42z" class="ne-image"></p><p id="f18c4e1f1c5a9292cebbe576e2d9e7e0" class="ne-p"><span class="ne-text"></span></p><h3 id="UaaMt"><span class="ne-text">鼠标事件对象event</span></h3><p id="c2e01fa3a4c223b2894094ffbb203375" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518361978-034f2af6-14fa-4ddb-bd8b-2eabe289eb59.png" width="703" id="nnFwt" class="ne-image"></p><p id="a0610de16ebdee3ca9844fb127be1ea0" class="ne-p"><br></p><h2 id="U6S0b"><span class="ne-text">元素偏移量offset</span></h2><h3 id="cIUmT"><span class="ne-text">offset 概述</span></h3><div class="ne-quote"><p id="36cee601812a5cae31f1bfdae78719c5" class="ne-p"><span class="ne-text">offset 翻译过来就是偏移量， 我们使用 offset系列相关属性可以动态的得到该元素的位置（偏移）、大小等。</span></p></div><ul class="ne-ul"><li id="61296beadd25f4305dd958e50972ce7f"><span class="ne-text">获得元素距离带有定位父元素的位置</span></li><li id="c36fec9465ccf515f8f4b5181a220e44"><span class="ne-text">获得元素自身的大小（宽度高度）</span></li><li id="2aa12a4af1255a0c4f38a63c2e478ce7"><span class="ne-text">注意：返回的数值都不带单位</span></li></ul><p id="6b59ba834eebd043fecbbf9ffe97b10e" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616067042341-17b54a01-de40-4ad5-8a54-ad61317d27ae.png" width="522" id="g51rZ" class="ne-image"></p><p id="9cc1a45f4a63450e88fe31bb0f9ed42a" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616068060630-5d0eeb72-5a55-48c4-8e60-1e0f2cd4afed.png" width="960" id="vDTUe" class="ne-image"></p><h3 id="bSGRp"><span class="ne-text">offset 与 style 区别</span></h3><p id="6a55eaccfed38649cc21117e5188379d" class="ne-p"><span class="ne-text">【1】offset</span></p><ul class="ne-ul"><li id="19b80b40c0d93db5921d4e2a5dd57cbf"><span class="ne-text">offset 可以得到任意样式表中的样式值</span></li><li id="472fbc5f93fa8202921c835c0aef7e0d"><span class="ne-text">offset 系列获得的数值是没有单位的</span></li><li id="62831ab59bf214609f66206ec149bb0c"><strong><span class="ne-text">offsetWidth 包含padding+border+width</span></strong></li><li id="78961a0400789377e9c4aa8fd24fdbb9"><span class="ne-text">offsetWidth 等属性是只读属性，只能获取不能赋值</span></li></ul><div class="ne-quote"><p id="1523e9b0b35faa85b2afa8c48b8bc5e3" class="ne-p"><span class="ne-text">所以，我们想要获取元素大小位置，用offset更合适</span></p></div><p id="9a2fd986d8e6d296472c65bc1fac8027" class="ne-p"><span class="ne-text">【2】style</span></p><ul class="ne-ul"><li id="5057a864781691a453dd2f734536745c"><span class="ne-text">style 只能得到</span><strong><span class="ne-text">行内样式表中的样式值</span></strong></li><li id="9132c2eb2eec95a33ecef6f05ca8adad"><span class="ne-text">style.width 获得的是带有单位的字符串</span></li><li id="963ea56ee346a6837c51db20ec33bb1c"><span class="ne-text">style.width 获得不包含padding和border 的值</span></li><li id="fc17c23b46fd9e61e6d8867164683691"><span class="ne-text">style.width 是可读写属性，可以获取也可以赋值</span></li></ul><div class="ne-quote"><p id="cca2d9ac6e73fc7f9112699f811e3a05" class="ne-p"><span class="ne-text">所以，我们想要给元素更改值，则需要用style改变</span></p><p id="61dea57ac71828ab38f85fc6138b1f75" class="ne-p"><strong><span class="ne-text">因为平时我们都是给元素注册触摸事件，所以重点记住 targetTocuhes</span></strong></p></div><h3 id="Pb3tt"><span class="ne-text">Demo：获取鼠标在盒子内的坐标</span></h3><p id="7f574ec0cc308e9e438fb0bb00a3c234" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616069445575-c9a9b51d-665d-4f26-96bb-768a9415a230.png" width="960" id="OSAx3" class="ne-image"></p><p id="cb704cfbae779d2f31f6eaef4a4bf96d" class="ne-p"><br></p><pre><code>box.addEventListener('mousemove',function(e)&#123;  if(e.pageX &gt; (box_left + box.width))&#123;    var ture_width = e.pageX - box_left +box_width;  &#125; else &#123;var ture_width = e.pageX - box_left;&#125;  if(e.pageY &gt; (box_top + box_height))&#123;    var ture_height = e.pageY - box_top + box_height;  &#125;else &#123;var ture_height = e.pageY - box_top;&#125;  this.innerHTML = 'x坐标是' + ture_width + ' y坐标是' + ture_height;&#125;)</code></pre><h3 id="1tFb7"><span class="ne-text">Demo：模态框拖拽</span></h3><p id="7703a12f10c24691471bf77aa4c49085" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616210051320-8b04d6a8-efc0-4a78-a985-80fdc0a0c238.png" width="960" id="BpD78" class="ne-image"></p><p id="dea71cdd071adbfc45d6797c9b64e514" class="ne-p"><br></p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;    &lt;style&gt;        * &#123;            padding: 0px;            margin: 0px;        &#125;        a &#123;            text-decoration: none;            color: #000000;        &#125;        .login-header &#123;            width: 100%;            text-align: center;            height: 30px;            line-height: 30px;            font-size: 24px;        &#125;        .login-bg &#123;            display: none;            width: 100%;            height: 100%;            position: fixed;            top: 0px;            left: 0px;            background: rgba(0, 0, 0, .3);        &#125;        .login &#123;            display: none;            width: 512px;            height: 280px;            position: fixed;            left: 50%;            top: 50%;            z-index: 9999;            border: #ebebeb solid 1px;            background-color: #ffffff;            box-shadow: 0px 0px 20px #ddd;            transform: translate(-50%, -50%);        &#125;        .login-title &#123;            width: 100%;            margin: 10px 0 0 0;            text-align: center;            line-height: 40px;            height: 40px;            font-size: 18px;            position: relative;            cursor: move;        &#125;        .login-title span &#123;            position: absolute;            width: 40px;            height: 40px;            font-size: 12px;            background: #ffffff;            border: #ebebeb solid 1px;            right: -20px;            top: -30px;            border-radius: 50%;        &#125;        .login-input-content &#123;            margin: 20px 0 0 0;        &#125;        .login-input &#123;            overflow: hidden;            margin: 0px 0px 20px 0px;        &#125;        .login-input label &#123;            float: left;            width: 90px;            padding-right: 10px;            text-align: right;            line-height: 35px;            height: 35px;            font-size: 14px;        &#125;        .login-input input.list-input &#123;            float: left;            line-height: 35px;            height: 35px;            width: 350px;            border: #ebebeb 1px solid;            text-indent: 5px;        &#125;        .login-input input.button-login &#123;            display: block;            border: 1px #ebebeb solid;            height: 35px;            width: 50%;            margin: 20px auto;        &#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;div class=&quot;login-header&quot;&gt;&lt;a id=&quot;link&quot; href=&quot;javascript:;&quot;&gt;点击，弹出登录框&lt;/a&gt;&lt;/div&gt;    &lt;div id=&quot;loginBg&quot; class=&quot;login-bg&quot;&gt;&lt;/div&gt;    &lt;div id=&quot;login&quot; class=&quot;login&quot;&gt;        &lt;div class=&quot;login-title&quot; &gt;登录会员            &lt;span&gt;&lt;a id=&quot;closeBtn&quot; href=&quot;javascript:; &quot; class=&quot;close-login&quot;&gt;关闭&lt;/a&gt;&lt;/span&gt;        &lt;/div&gt;        &lt;div class=&quot;login-input-content&quot;&gt;            &lt;div class=&quot;login-input&quot;&gt;                &lt;label&gt;用户名：&lt;/label&gt;                &lt;input type=&quot;text&quot; placeholder=&quot;请输入用户名&quot; name=&quot;info[username]&quot; id=&quot;username&quot; class=&quot;list-input&quot;&gt;            &lt;/div&gt;            &lt;div class=&quot;login-input&quot;&gt;                &lt;label&gt;登录密码：&lt;/label&gt;                &lt;input type=&quot;password&quot; placeholder=&quot;请输入登录密码&quot; name=&quot;info[password]&quot; id=&quot;password&quot; class=&quot;list-input&quot;&gt;            &lt;/div&gt;            &lt;div class=&quot;login-input&quot;&gt;                &lt;input type=&quot;button&quot; class=&quot;button-login&quot; value=&quot;登录会员&quot;/&gt;            &lt;/div&gt;        &lt;/div&gt;    &lt;/div&gt;    &lt;script&gt;        var link = document.getElementById('link');        var loginBg = document.getElementById('loginBg');        var login = document.getElementById('login');        var closeBtn = document.getElementById('closeBtn');        link.addEventListener('click',function()&#123;            loginBg.style.display = 'block';            login.style.display = 'block';        &#125;)        closeBtn.addEventListener('click',function()&#123;            loginBg.style.display = 'none';            login.style.display = 'none';        &#125;)        login.addEventListener('mousedown', function(e)&#123;            var x = e.pageX - login.offsetLeft;            var y = e.pageY - login.offsetTop;            document.addEventListener('mousemove', move)<pre><code>        function move(e) &#123;            login.style.left = e.pageX - x + &#39;px&#39;;            login.style.top = e.pageY - y + &#39;px&#39;;        &#125;        document.addEventListener(&#39;mouseup&#39;, function() &#123;            document.removeEventListener(&#39;mousemove&#39;, move);        &#125;)    &#125;)&amp;lt;/script&amp;gt;</code></pre><p>&lt;/body&gt;<br>&lt;/html&gt;<br></code></pre></p><h2 id="7Q7rO"><span class="ne-text">元素可视区 client 系列</span></h2><h3 id="AU5zq"><span class="ne-text">client概述</span></h3><p id="a91bac5ac636ce9279f978baad74e250" class="ne-p"><span class="ne-text">client 翻译过来就是客户端，我们使用 client 系列的相关属性来获取元素可视区的相关信息。通过 client</span></p><p id="161a8bbf651f3b800685c7d09893881a" class="ne-p"><span class="ne-text">系列的相关属性可以动态的得到该元素的边框大小、元素大小等。</span></p><p id="9a60f89df4ce3a5748ffe44c6c93c691" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616070278053-25f4dbb3-2991-4ce4-b1ec-cb3a94f80c0c.png" width="515" id="u4HFg" class="ne-image"></p><p id="1e9256a55dabac26adc47632fd07593f" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616070286487-4d2a07f6-46b7-4af4-be5c-134ac01d6b48.png" width="286" id="n6sG4" class="ne-image"></p><p id="54195d8a856e36eb32657382a9ab3193" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616070508648-c56b354b-77e7-4afb-9072-0385ac38782f.png" width="960" id="uEuaD" class="ne-image"></p><p id="abbed13e0bc0e9346de8b3b3b7bedffd" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616070554658-21dea2fb-5942-4f60-9205-71bc2a022a79.png" width="960" id="QhNXz" class="ne-image"></p><p id="cec95b197ba5e813d4a2367ac24f8a77" class="ne-p"><br></p><h3 id="Gn6hw"><span class="ne-text">淘宝 flexible.js 源码分析</span></h3><ul class="ne-ul"><li id="7227529bd0b0bf7a89cf0880c53e7ff8"><span class="ne-text">立即执行函数 (function(){})()  或者 (function(){}())</span></li><li id="022bd01f7149e6e34ebb9866225fc691"><span class="ne-text">主要作用： 创建一个独立的作用域。 避免了命名冲突问题</span></li><li id="87cbbe9eeda8bef197cc70b40c967214"><span class="ne-text">下面三种情况都会刷新页面都会触发 load 事件。</span></li></ul><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="05d6a1e6b1d87666ce8b4b637d1c0024"><span class="ne-text">a标签的超链接</span></li><li id="c4ac24d03f554cc433d81923c4f6404e"><span class="ne-text">F5或者刷新按钮（强制刷新）</span></li><li id="1b0579a1cf9f7226ca0337a091665148"><span class="ne-text">前进后退按钮</span></li></ul></ul><div class="ne-quote"><p id="9d40d33a120d5ec57cde5b477a991f02" class="ne-p"><span class="ne-text">但是 火狐中，有个特点，有个“往返缓存”，这个缓存中不仅保存着页面数据，还保存了DOM和JavaScript的状态；实际上是将整个页面都保存在了内存里。</span></p></div><p id="36c7cc356274b5fc59aa881db8f5d00f" class="ne-p"><span class="ne-text">所以此时后退按钮不能刷新页面。</span></p><p id="6bf724d20555e5f8d1e2811e9bba70ef" class="ne-p"><br></p><p id="269f37cea8b590146f3c8840bb360aa3" class="ne-p"><span class="ne-text">此时可以使用 pageshow事件来触发。，这个事件在页面显示时触发，无论页面是否来自缓存。在重新加载页面中，pageshow会在load事件触发后触发；根据事件对象中的persisted来判断是否是缓存中的页面触发的pageshow事件</span></p><p id="785180c496f22b98d41ef081092e5601" class="ne-p"><br></p><p id="fda309f83465cbabb7e3c8e1a11448d5" class="ne-p"><code class="ne-code"><span class="ne-text">注意这个事件给window添加。</span></code></p><pre><code>(function flexible(window, document) &#123;    // 获取的html 的根元素    var docEl = document.documentElement        // dpr 物理像素比    var dpr = window.devicePixelRatio || 1<pre><code>// adjust body font size  设置我们body 的字体大小function setBodyFontSize() &#123;    // 如果页面中有body 这个元素 就设置body的字体大小    if (document.body) &#123;        document.body.style.fontSize = (12 * dpr) + &#39;px&#39;    &#125; else &#123;        // 如果页面中没有body 这个元素，则等着 我们页面主要的DOM元素加载完毕再去设置body        // 的字体大小        document.addEventListener(&#39;DOMContentLoaded&#39;, setBodyFontSize)    &#125;&#125;setBodyFontSize();// set 1rem = viewWidth / 10    设置我们html 元素的文字大小function setRemUnit() &#123;    var rem = docEl.clientWidth / 10    docEl.style.fontSize = rem + &#39;px&#39;&#125;setRemUnit()// reset rem unit on page resize  当我们页面尺寸大小发生变化的时候，要重新设置下rem 的大小window.addEventListener(&#39;resize&#39;, setRemUnit)    // pageshow 是我们重新加载页面触发的事件window.addEventListener(&#39;pageshow&#39;, function(e) &#123;    // e.persisted 返回的是true 就是说如果这个页面是从缓存取过来的页面，也需要从新计算一下rem 的大小    if (e.persisted) &#123;        setRemUnit()    &#125;&#125;)// detect 0.5px supports  有些移动端的浏览器不支持0.5像素的写法if (dpr &amp;gt;= 2) &#123;    var fakeBody = document.createElement(&#39;body&#39;)    var testElement = document.createElement(&#39;div&#39;)    testElement.style.border = &#39;.5px solid transparent&#39;    fakeBody.appendChild(testElement)    docEl.appendChild(fakeBody)    if (testElement.offsetHeight === 1) &#123;        docEl.classList.add(&#39;hairlines&#39;)    &#125;    docEl.removeChild(fakeBody)&#125;</code></pre><p>}(window, document))<br></code></pre></p><h2 id="PqA5S"><span class="ne-text">元素滚动 scroll 系列</span></h2><h3 id="uEzrT"><span class="ne-text">scroll 概述</span></h3><p id="638e3b34f6caa099a0edf7b5a65b0af1" class="ne-p"><span class="ne-text">scroll 翻译过来就是滚动的，我们使用 scroll 系列的相关属性可以动态的得到该元素的大小、滚动距离等。</span></p><p id="47ab09402ec4a49ea25b37f343438e9a" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616070606903-ad20b10d-b146-4d60-bcc8-b202127dbac2.png" width="528" id="Av8YH" class="ne-image"></p><p id="813d034c7681beaff60c2c89d34e352b" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616070615035-e5456585-8b3a-4c5a-8e1d-e4affd0e7fd2.png" width="210.5" id="fltiA" class="ne-image"></p><h3 id="sLsqC"><span class="ne-text">页面被卷去的头部</span></h3><p id="c0d8982276e0f7ca23cdc0ce56da1a37" class="ne-p"><span class="ne-text">如果浏览器的高（或宽）度不足以显示整个页面时，会自动出现滚动条。当滚动条向下滚动时，页面上面被隐藏掉的高度，我们就称为页面被卷去的头部。滚动条在滚动时会触发 onscroll事件。</span></p><h3 id="Dqr96"><span class="ne-text">页面被卷去的头部兼容性解决方案</span></h3><p id="b318cfaf793624daec91cc06ba25f643" class="ne-p"><span class="ne-text">需要注意的是，页面被卷去的头部，有兼容性问题，因此被卷去的头部通常有如下几种写法：</span></p><ol class="ne-ol"><li id="356f947a4302c52a189979f43eabf741"><span class="ne-text">声明了 DTD，使用 document.documentElement.scrollTop</span></li><li id="a1a223829ec3e48a0c6aba5b97e2868a"><span class="ne-text">未声明 DTD，使用  document.body.scrollTop</span></li><li id="92a572b59b8eeb2cce92afde520f3473"><span class="ne-text">新方法 window.pageYOffset和 window.pageXOffset，IE9 开始支持</span></li><li id="c58b60ef3d06bf9dcd277f4d577ef68e"><span class="ne-text">微信里面浏览也会有相关兼容性的问题，所以需要兼容行解决</span></li></ol><pre><code>function getScroll() &#123;    return &#123;      left: window.pageXOffset || document.documentElement.scrollLeft || document.body.scrollLeft||0,      top: window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0    &#125;; &#125; 使用的时候  getScroll().left</code></pre><h2 id="FEDmA"><span class="ne-text">三大系列总结</span></h2><p id="86f5e62f6f9edd4094dd4b359c198a13" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616070740695-1045516b-2b85-4697-874b-32fe2b1cbe5b.png" width="552.5" id="vDeiC" class="ne-image"></p><p id="ffde75e13e6d47892886298e95cf6928" class="ne-p"><span class="ne-text">他们主要用法：</span></p><ol class="ne-ol"><li id="8bb793eb49617b5d37e26b3da9dca410"><span class="ne-text">offset系列 经常用于获得元素位置    offsetLeft  offsetTop</span></li><li id="518920d7f27dba5b0dae28fab3815575"><span class="ne-text">client经常用于获取元素大小  clientWidth clientHeight</span></li><li id="e4d34e79eee5492714edb409bf794112"><span class="ne-text">scroll 经常用于获取滚动距离 scrollTop  scrollLeft</span></li><li id="438f9bd58d52a3ddffb608858e428e0d"><span class="ne-text">注意页面滚动的距离通过 window.pageXOffset  获得</span></li></ol><h2 id="r7BDm"></h2><h2 id="3Ynw6"></h2></div>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
          <category> JavaScript </category>
          
          <category> BOM </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>window五大对象</title>
      <link href="/blog/window_five_obj_webapis/"/>
      <url>/blog/window_five_obj_webapis/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h2 id="Ga8tW"><span class="ne-text">什么是BOM</span></h2><p id="058ef4e02219954f5ec808e64a3a5fe2" class="ne-p"><span class="ne-text">BOM（Browser Object Model）即浏览器对象模型，它提供了独立于内容而与浏览器窗口进行交互的对象，其核心对象是 window。</span></p><p id="207aa15a466633c36e4f19108bdb2d4c" class="ne-p"><span class="ne-text">BOM 由一系列相关的对象构成，并且每个对象都提供了很多方法与属性。</span></p><p id="c54dbafcadc13b73267b0c50ffabc251" class="ne-p"><span class="ne-text">BOM 缺乏标准，JavaScript 语法的标准化组织是 ECMA，DOM 的标准化组织是 W3C，BOM 最初是Netscape 浏览器标准的一部分。</span></p><p id="f10624593cf2df7ba60d41ba9eeb2f58" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518362800-e37d0116-7afb-4099-9d0e-d06e4a1e5127.png" width="866" id="AK9gT" class="ne-image"></p><p id="1d09b07fec86db6338249e251740a360" class="ne-p"><span class="ne-text">BOM 比 DOM 更大，它包含 DOM。</span></p><p id="f9e6ea6272c9755736daff0697dddc38" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518362856-04ac0f7c-e251-4985-ba14-9d8839bd2fcf.png" width="629" id="AS3Ek" class="ne-image"></p><h2 id="aujcX"><span class="ne-text">window对象</span></h2><h3 id="nFKGI"><span class="ne-text">window.alert、</span><span class="ne-text">window.</span><span class="ne-text">prompt</span></h3><ul class="ne-ul"><li id="448376cc99c3150fa4b0fb3153e5afe2"><span class="ne-text">是js访问浏览器窗口的一个接口</span></li><li id="619dde06a5576c7276c6340dbde3a7ec"><span class="ne-text">之前学的这两种输入输出都是window的对象方法，window.alert的window可以省略</span></li></ul><h3 id="WoQ2w"><span class="ne-text">window.</span><span class="ne-text">name</span></h3><p id="e728e0d7e9622bf55557bbbc6e189fb8" class="ne-p"><span class="ne-text">window.name的使用</span></p><ul class="ne-ul"><li id="44285870c101813ab27b9383d18fe554"><span class="ne-text">参考：</span><a href="https://www.zhangxinxu.com/wordpress/2019/09/window-name/" data-href="https://www.zhangxinxu.com/wordpress/2019/09/window-name/" target="_blank" class="ne-link"><span class="ne-text">https://www.zhangxinxu.com/wordpress/2019/09/window-name/</span></a><span class="ne-text">（基本没啥用了）</span></li></ul><h3 id="QAl5V"><span class="ne-text">window.onload和DOMContentLoaded</span></h3><p id="aeb0cf48a35574ba4a68dc083679a6f1" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518362978-a9a37865-ed21-4388-9d6b-9c95cf4e2c03.png" width="697" id="GEaKk" class="ne-image"></p><ul class="ne-ul"><li id="bdf0e78738974823f652880fd6911c36"><span class="ne-text">窗口 (页面）加载事件</span></li><li id="2b026f52a699d91c0bbddbb1ed20d945"><strong><span class="ne-text">当文档内容完全加载完成</span></strong><span class="ne-text">会触发该事件(包括图像、脚本文件、CSS 文件等), 就调用的处理函数。</span></li></ul><p id="6b3bdbdaef0e05dc9e6db7f016df3e15" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518363060-d1b0c898-d05e-45d2-b969-d625f094716e.png" width="717" id="iqFg7" class="ne-image"><span class="ne-text"></span></p><p id="bb2671e68beee3d95ce638daa16ce12d" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518363117-b08edff8-a5e7-4d72-af87-30d266da9644.png" width="692" id="FuxJM" class="ne-image"></p><p id="420e728cbe52b3dbf084874ff4d6cec8" class="ne-p"><span class="ne-text">事件触发时，仅当DOM加载完成，不包括样式表，图片，flash等等。</span></p><p id="3982d9ee0bdbb878262e7a319d0ad56a" class="ne-p"><span class="ne-text">IE9以上才支持</span></p><p id="5c9f5027770267f4ddba29f78f88589c" class="ne-p"><span class="ne-text">适用场景：如果页面的图片很多的话, 从用户访问到onload触发可能需要较长的时间, 交互效果就不能实现，必然影响用户的体验，此时用 DOMContentLoaded 事件比较合适。</span></p><pre><code>&lt;script&gt;        window.addEventListener('load', function() &#123;            var btn = document.querySelector('button');            btn.addEventListener('click', function() &#123;                alert('点击我');            &#125;)        &#125;)        window.addEventListener('load', function() &#123;            alert(22);        &#125;)        document.addEventListener('DOMContentLoaded', function() &#123;            alert(33);        &#125;)    &lt;/script&gt;</code></pre><h3 id="XoAZx"><span class="ne-text">window.onresize</span></h3><p id="03c87d57037c484fa747a2535560251d" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518363174-36e0247a-e870-47b7-ad70-a39e8204f778.png" width="698" id="Yml18" class="ne-image"></p><ul class="ne-ul"><li id="559622a62f442fabf2a1522d46cb5777"><span class="ne-text">window.onresize 是调整窗口大小加载事件,  当触发时就调用的处理函数。</span></li><li id="725c5aabe697f4cefd5a63ea317f2a9e"><span class="ne-text">只要窗口大小发生像素变化，就会触发这个事件。</span></li><li id="ed29a664c947925f7e00cd6712b391fc"><span class="ne-text">利用这个事件完成响应式布局</span></li><li id="71ee46687c911ea3e392664b8bbee534"><span class="ne-text"> window.innerWidth 当前屏幕的宽度</span></li></ul><pre><code>&lt;script&gt;        // 注册页面加载事件        window.addEventListener('load', function() &#123;            var div = document.querySelector('div');            // 注册调整窗口大小事件            window.addEventListener('resize', function() &#123;                // window.innerWidth 获取窗口大小                console.log('变化了');                if (window.innerWidth &lt;= 800) &#123;                    div.style.display = 'none';                &#125; else &#123;                    div.style.display = 'block';                &#125;            &#125;)        &#125;)    &lt;/script&gt;    &lt;div&gt;&lt;/div&gt;</code></pre><h3 id="sCtq2"><span class="ne-text">setTimeout()和</span><span class="ne-text">clearTimeout()</span></h3><p id="e533d711b4937d2912983dd7006213ff" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518363237-7fb4b99d-18cc-4621-9153-99ee3b219faa.png" width="695" id="zmYE6" class="ne-image"></p><p id="ed00cc3be52d6c3c859af99f74d1ab73" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518363294-245f3e69-65be-425b-8390-cedcea50e6b9.png" width="687" id="YGNul" class="ne-image"></p><ul class="ne-ul"><li id="d76a7ea67bb840a6822b490fef9ff820"><span class="ne-text">默认的延迟毫秒数默认是0，单位必须是毫秒</span></li><li id="9a652084583376f52ccf7c2acde54563"><span class="ne-text">通常定义了一个这种函数就给其“名”，赋予其一个标识符，因为一个项目里面可能有很多的定时器。</span></li></ul><div class="ne-quote"><p id="106a138231405a9ef34bdfd5ab12e7dc" class="ne-p"><span class="ne-text">什么是回调函数呢？</span></p></div><p id="af57320e5d23b3abb419bdf7cb1bbb68" class="ne-p"><span class="ne-text">普通函数是按照代码顺序直接调用。回调，就是回头调用的意思。上一件事干完，再回头再调用这个函数。例如：定时器中的调用函数，事件处理函数，也是回调函数。element.onclick = function(){}   或者  element.addEventListener(“click”, fn);   里面的 函数也是回调函数。</span></p><pre><code>&lt;script&gt;        // 回调函数是一个匿名函数         setTimeout(function() &#123;             console.log('时间到了');         &#125;, 2000);        function callback() &#123;            console.log('爆炸了');        &#125;        // 回调函数是一个有名函数        var timer1 = setTimeout(callback, 3000);        var timer2 = setTimeout(callback, 5000);    &lt;/script&gt;</code></pre><p id="26d89d5e64d61cd27ce8f64d1bcf9bc6" class="ne-p"><br></p><p id="cd070e19d0fd983567a628f0b2484eae" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518363519-c36076ed-0e62-471c-a193-001186cebc77.png" width="703" id="k1kyd" class="ne-image"></p><ul class="ne-ul"><li id="2b4bc620787233ab3c288843dd3f5461"><span class="ne-text">类似在炸弹爆炸前拆除的意思</span></li></ul><pre><code>&lt;button&gt;点击停止定时器&lt;/button&gt;    &lt;script&gt;        var btn = document.querySelector('button');        // 开启定时器        var timer = setTimeout(function() &#123;            console.log('爆炸了');        &#125;, 5000);        // 给按钮注册单击事件        btn.addEventListener('click', function() &#123;            // 停止定时器            clearTimeout(timer);        &#125;)    &lt;/script&gt;</code></pre><h3 id="T4tK9"><span class="ne-text">setInterval()和</span><span class="ne-text">clearInterval()</span></h3><ul class="ne-ul"><li id="226b7599882b655bfcae881af34a1d3e"><span class="ne-text">会多次进行调用，直到清除</span></li></ul><p id="500758cf6759c3c60ba07c436b732f09" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616033160668-637ca99a-723f-4f14-9576-6de4f4fdd383.png" width="719" id="lb5Xh" class="ne-image"></p><h3 id="fvsZV"><span class="ne-text">Demo：倒计时</span></h3><p id="1e36f8f161cc0cb3b86563f97daae6f3" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616035667401-0c467c6a-2509-4b0c-a1b3-ea2a9b3d4f85.png" width="158" id="Vxs7R" class="ne-image"></p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;<p>&lt;head&gt;<br>    &lt;meta charset=&quot;UTF-8&quot;&gt;<br>    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;<br>    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;<br>    &lt;title&gt;Document&lt;/title&gt;<br>    &lt;style&gt;<br>        div &#123;<br>            margin: 200px;<br>        &#125;</p><pre><code>    span &#123;        display: inline-block;        width: 40px;        height: 40px;        background-color: #333;        font-size: 20px;        color: #fff;        text-align: center;        line-height: 40px;    &#125;&amp;lt;/style&amp;gt;</code></pre><p>&lt;/head&gt;</p><p>&lt;body&gt;<br>    &lt;div&gt;<br>        &lt;span class=&quot;hour&quot;&gt;1&lt;/span&gt;<br>        &lt;span class=&quot;minute&quot;&gt;2&lt;/span&gt;<br>        &lt;span class=&quot;second&quot;&gt;3&lt;/span&gt;<br>    &lt;/div&gt;<br>    &lt;script&gt;<br>        // 1. 获取元素<br>        var hour = document.querySelector(‘.hour’); // 小时的黑色盒子<br>        var minute = document.querySelector(‘.minute’); // 分钟的黑色盒子<br>        var second = document.querySelector(‘.second’); // 秒数的黑色盒子<br>        var inputTime = +new Date(‘2021-3-18 19:00:00’); // 返回的是用户输入时间总的毫秒数<br>        countDown(); // 我们先调用一次这个函数，防止第一次刷新页面有空白<br>        // 2. 开启定时器<br>        setInterval(countDown, 1000);</p><pre><code>    function countDown() &#123;        var nowTime = +new Date(); // 返回的是当前时间总的毫秒数        var times = (inputTime - nowTime) / 1000; // times是剩余时间总的秒数         var h = parseInt(times / 60 / 60 % 24); //时        h = h &amp;lt; 10 ? &#39;0&#39; + h : h;        hour.innerHTML = h; // 把剩余的小时给 小时黑色盒子        var m = parseInt(times / 60 % 60); // 分        m = m &amp;lt; 10 ? &#39;0&#39; + m : m;        minute.innerHTML = m;        var s = parseInt(times % 60); // 当前的秒        s = s &amp;lt; 10 ? &#39;0&#39; + s : s;        second.innerHTML = s;    &#125;&amp;lt;/script&amp;gt;</code></pre><p>&lt;/body&gt;</p><p>&lt;/html<br></code></pre></p><h3 id="0Vvqr"><span class="ne-text">Demo：短信倒计时</span></h3><p id="1475bd120e9f3a2ce379477879949b72" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616036201989-deced5f6-9ec3-4392-8e1d-cf10d7c1c55b.png" width="641" id="KNBAm" class="ne-image"></p><div class="ne-quote"><p id="65d9f85f2c6c622b5e3f8d4122b98dde" class="ne-p"><span class="ne-text">案例：发送短信倒计时</span></p><p id="5cd325b6cb2702993f40532b5c641e19" class="ne-p"><span class="ne-text">同时这个例子还用到了闭包的相关知识</span></p></div><p id="007bfc06d5261a27005b5317bf6da7aa" class="ne-p"><span class="ne-text">点击按钮后，该按钮60秒之内不能再次点击，防止重复发送短信。</span></p><p id="61dd7f4004ca51e32c3314cb9730d98a" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518363854-8efb51de-f962-4ce9-b686-4166d4ef3bfe.png" width="364" id="KGTIA" class="ne-image"></p><pre><code>手机号码： &lt;input type=&quot;number&quot;&gt; &lt;button&gt;发送&lt;/button&gt;    &lt;script&gt;        var btn = document.querySelector('button');        // 全局变量，定义剩下的秒数        var time = 3;         // 注册单击事件        btn.addEventListener('click', function() &#123;            // 禁用按钮            btn.disabled = true;            // 开启定时器            var timer = setInterval(function() &#123;                // 判断剩余秒数                if (time == 0) &#123;                    // 清除定时器和复原按钮                    clearInterval(timer);                    btn.disabled = false;                    btn.innerHTML = '发送';                &#125; else &#123;                    btn.innerHTML = '还剩下' + time + '秒';                    time--;                &#125;            &#125;, 1000);        &#125;);    &lt;/script&gt;</code></pre><h2 id="8VBes"><span class="ne-text">location对象</span></h2><p id="u061c71de" class="ne-p"><span class="ne-text">参考：</span></p><ul class="ne-ul"><li id="uc8152b11"><span class="ne-text"></span><a href="https://www.cnblogs.com/cang12138/p/7677239.html" data-href="https://www.cnblogs.com/cang12138/p/7677239.html" target="_blank" class="ne-link"><span class="ne-text">https://www.cnblogs.com/cang12138/p/7677239.html</span></a></li></ul><p id="e2075ea852fbd51db4333c83d85c9523" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518363970-e7ae6f17-8fa0-4cda-bd5c-a486dbad0410.png" width="722" id="MQwpb" class="ne-image"></p><p id="f7ecca6db22c94e25e21f9028af8fc43" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518364029-47b8981f-8ef1-4978-8760-2be8bc0c5e96.png" width="723" id="UFOqO" class="ne-image"></p><p id="25c715d613c17d0626a6317d0e406d8d" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518364086-8b3e0045-e245-4c0a-b484-4e038b829a6b.png" width="684" id="MJ42d" class="ne-image"></p><h3 id="2M3aW"><span class="ne-text">location对象常用属性</span></h3><p id="85011982c4c2827ad3941f9fd94c779a" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518364152-c5c0aa45-eb47-49d3-81ce-2318a6bc8497.png" width="705" id="UD8ZA" class="ne-image"></p><h3 id="2mGXr"><span class="ne-text">location对象常见方法</span></h3><p id="10d4f3fcc9195198740bd901b9a28ab0" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518364490-f3c87eef-a34f-4378-9b69-03ea18f2fb26.png" width="728" id="hTDRo" class="ne-image"></p><pre><code>&lt;button&gt;点击&lt;/button&gt;    &lt;script&gt;        var btn = document.querySelector('button');        btn.addEventListener('click', function() &#123;            // 记录浏览历史，所以可以实现后退功能            // location.assign('http://www.itcast.cn');            // 不记录浏览历史，所以不可以实现后退功能            // location.replace('http://www.itcast.cn');            location.reload(true);        &#125;)    &lt;/script&gt;</code></pre><h3 id="B9Vt4"><span class="ne-text">Demo：5秒钟自动跳转页面</span></h3><p id="0f4f867ac9741a98761fd02175a9b64a" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616038766425-7b736d4a-8329-4912-879c-7eb5924745f5.png" width="399" id="ZGNKi" class="ne-image"></p><pre><code>var img = document.getElementsByTagName('img');img[0].addEventListener('click',function()&#123;    console.log('运行到了这里1');    setTimeout(function()&#123;        location.href = 'https://www.wztlink1013.com';        console.log('运行到了这里');    &#125;,5000);&#125;);</code></pre><h3 id="yyyVI"><span class="ne-text">Demo：获取URL参数</span></h3><div class="ne-quote"><p id="196f687b145b90010f886f2070baea0d" class="ne-p"><span class="ne-text">login.html</span></p></div><pre><code>&lt;body&gt;    &lt;form action=&quot;index.html&quot;&gt;        用户名： &lt;input type=&quot;text&quot; name=&quot;uname&quot;&gt;        &lt;input type=&quot;submit&quot; value=&quot;登录&quot;&gt;    &lt;/form&gt;&lt;/body&gt;</code></pre><div class="ne-quote"><p id="a5a0e4e055a91abface6de685a421b2b" class="ne-p"><span class="ne-text">index.html</span></p></div><p id="7849bed1ce9e820cbfa79c3bedff2de0" class="ne-p"><span class="ne-text">收到login页面传来的参数后</span><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616039288488-d1884566-894d-4a15-a677-9227934a5eb9.png" width="170.5" id="ftUqi" class="ne-image"></p><pre><code>&lt;div&gt;&lt;/div&gt;    &lt;script&gt;        console.log(location.search); // ?uname=wztlink1013        // 1.先去掉？  substr('起始的位置'，截取几个字符);        var params = location.search.substr(1); // uname=wztlink1013        console.log(params);        // 2. 利用=把字符串分割为数组 split('=');        var arr = params.split('=');        console.log(arr); // [&quot;uname&quot;, &quot;wztlink1013&quot;]        var div = document.querySelector('div');        // 3.把数据写入div中        div.innerHTML = arr[1] + '欢迎您';&lt;/script&gt;</code></pre><h2 id="hB16a"><span class="ne-text">navigator对象</span></h2><p id="5d635830a7e29e9e05a508c2814d3885" class="ne-p"><span class="ne-text">navigator 对象包含有关浏览器的信息，它有很多属性，我们最常用的是 userAgent，该属性可以返回由客户机发送服务器的 user-agent 头部的值。</span></p><p id="5f76ba34027cd602f6a90bf7d3f8a93e" class="ne-p"><span class="ne-text">下面前端代码可以判断用户那个终端打开页面，实现跳转，比如：</span></p><pre><code>if((navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i))) &#123;    window.location.href = &quot;https://www.wztlink1013.com/m/index.html&quot;;    //手机页面 &#125; else &#123;    window.location.href = &quot;https://www.wztlink1013.com/p/index.html&quot;;    //电脑页面 &#125;</code></pre><p id="02a0bc9cc29aa62f4e980991386921e1" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616072483887-50d05057-73f8-49b7-8761-8f68defe6194.png" width="960" id="lZii4" class="ne-image"></p><h2 id="vUGy8"><span class="ne-text">history对象</span></h2><p id="c9515b92dac24aeb44c22728cf1009ee" class="ne-p"><span class="ne-text">    window对象给我们提供了一个 history对象，与浏览器历史记录进行交互。该对象包含用户（在浏览器窗口中）访问过的URL。</span></p><p id="50db8e2b4cc06f0aca16245c29a0fbfe" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518364555-790a838f-2446-45bd-886e-686c75286b2c.png" width="731" id="moiW0" class="ne-image"></p><h2 id="UCYb9"><span class="ne-text">screen对象</span></h2><table id="cBUJj" class="ne-table" style="width: 658px"><tbody><tr style="height: 33px"><td width="263" style="background-color: #555555"><p id="udc37d18e" class="ne-p" style="text-align: left"><span class="ne-text">属性</span></p></td><td width="395" style="background-color: #555555"><p id="ub8875a7e" class="ne-p" style="text-align: left"><span class="ne-text">说明</span></p></td></tr><tr style="height: 33px"><td width="263"><p id="ufb787a3c" class="ne-p"><a href="https://www.runoob.com/jsref/prop-screen-availheight.html" data-href="https://www.runoob.com/jsref/prop-screen-availheight.html" target="_blank" class="ne-link"><span class="ne-text">availHeight</span></a></p></td><td width="395"><p id="u29d77a4e" class="ne-p"><span class="ne-text">返回屏幕的高度（不包括Windows任务栏）</span></p></td></tr><tr style="height: 33px"><td width="263"><p id="u1c28a76c" class="ne-p"><a href="https://www.runoob.com/jsref/prop-screen-availwidth.html" data-href="https://www.runoob.com/jsref/prop-screen-availwidth.html" target="_blank" class="ne-link"><span class="ne-text">availWidth</span></a></p></td><td width="395"><p id="u284c540e" class="ne-p"><span class="ne-text">返回屏幕的宽度（不包括Windows任务栏）</span></p></td></tr><tr style="height: 33px"><td width="263"><p id="ub996e69c" class="ne-p"><a href="https://www.runoob.com/jsref/prop-screen-colordepth.html" data-href="https://www.runoob.com/jsref/prop-screen-colordepth.html" target="_blank" class="ne-link"><span class="ne-text">colorDepth</span></a></p></td><td width="395"><p id="u4b34713b" class="ne-p"><span class="ne-text">返回目标设备或缓冲器上的调色板的比特深度</span></p></td></tr><tr style="height: 33px"><td width="263"><p id="u6ef27334" class="ne-p"><a href="https://www.runoob.com/jsref/prop-screen-height.html" data-href="https://www.runoob.com/jsref/prop-screen-height.html" target="_blank" class="ne-link"><span class="ne-text">height</span></a></p></td><td width="395"><p id="ubfca94cc" class="ne-p"><span class="ne-text">返回屏幕的总高度</span></p></td></tr><tr style="height: 33px"><td width="263"><p id="uc7818a93" class="ne-p"><a href="https://www.runoob.com/jsref/prop-screen-pixeldepth.html" data-href="https://www.runoob.com/jsref/prop-screen-pixeldepth.html" target="_blank" class="ne-link"><span class="ne-text">pixelDepth</span></a></p></td><td width="395"><p id="u3d0c54da" class="ne-p"><span class="ne-text">返回屏幕的颜色分辨率（每象素的位数）</span></p></td></tr><tr style="height: 33px"><td width="263"><p id="ub44e530e" class="ne-p"><a href="https://www.runoob.com/jsref/prop-screen-width.html" data-href="https://www.runoob.com/jsref/prop-screen-width.html" target="_blank" class="ne-link"><span class="ne-text">width</span></a></p></td><td width="395"><p id="u390b7b4f" class="ne-p"><span class="ne-text">返回屏幕的总宽度</span></p></td></tr></tbody></table><p id="f60bdbd441a4acd43caeb5a354f70f3c" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616073065915-eee3a4aa-52a8-4200-9d15-9e66f5c4fba5.png" width="1920" id="ugF7E" class="ne-image"></p><p id="54ccc4cbab7357ca8c88c5dde6702538" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616073033094-e0640f15-e1a2-4f9d-9937-aad687e2bfbe.png" width="310" id="PyKN9" class="ne-image"></p></div>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
          <category> JavaScript </category>
          
          <category> BOM </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>DOM节点操作</title>
      <link href="/blog/2_day02_webapis/"/>
      <url>/blog/2_day02_webapis/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h3 id="mk5K8"><span class="ne-text">节点概述</span></h3><p id="dc7f4e6b1cd6d40ca4a311ae5b67c390" class="ne-p"><span class="ne-text">网页中的所有内容都是节点（标签、属性、文本、注释等），在DOM 中，节点使用 node 来表示。HTML DOM 树中的所有节点均可通过 JavaScript 进行访问，所有 HTML 元素（节点）均可被修改，也可以创建或删除。</span></p><p id="4d787dc172fdd79c5539a2cd6577c735" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518358489-a0521202-b32d-46a9-9b8d-f0cfe9afc455.png" width="432" id="m41li" class="ne-image"></p><p id="c6ee72606a158be15bb6368a12996e6c" class="ne-p"><span class="ne-text">    一般地，节点至少拥有nodeType（节点类型）、nodeName（节点名称）和nodeValue（节点值）这三个基本属性。</span></p><p id="de51f2d38fac0c9a1eac755aeb99bac5" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518358548-9283575f-7aef-450d-bc6e-b9d3a4384cc2.png" width="666" id="u8PE0" class="ne-image"></p><div class="ne-quote"><p id="24bed889a829869f109e4f3e77a13507" class="ne-p"><span class="ne-text">节点层级：</span><span class="ne-text" style="background-color: transparent">利用 DOM 树可以把节点划分为不同的层级关系，常见的是</span><strong><span class="ne-text">父子兄层级关系</span></strong><span class="ne-text" style="background-color: transparent">。</span></p></div><h2 id="JLpsj"><span class="ne-text">父节点</span></h2><h3 id="AcNO7"><span class="ne-text">node.parentNode</span></h3><ul class="ne-ul"><li id="214d3250d71e594490fe6d85ed4fd06c"><span class="ne-text">返回某节点的父节点，最近的一个父节点</span></li><li id="19c44750b461e686d3a7b36c6c520389"><span class="ne-text">如果没有父节点，则返回null</span></li></ul><p id="3598457b7bfbb4f1400b4003bcb8d0fe" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616056309357-b2a256d0-2a4d-4983-80f9-1eed069c3890.png" width="960" id="RV3TK" class="ne-image"></p><h2 id="YKxQz"><span class="ne-text">子节点</span></h2><h3 id="xzVW4"><span class="ne-text">parentNode.childNodes</span></h3><ul class="ne-ul"><li id="d2468443d1f99250be50717ff123dd78"><span class="ne-text">返回指定节点的子节点的集合，会即时更新</span></li><li id="20988a9f7f831fe4b48859299f30b821"><span class="ne-text">会返回所有的节点（包含元素节点、文本节点等）</span></li></ul><p id="f695e5b6acc6dd337f9481e12d8c5f44" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616056553404-55b8fe19-9bea-413d-9cb1-6554380831af.png" width="960" id="V1IMU" class="ne-image"></p><h3 id="JUL3j"><span class="ne-text">parentNode.children</span></h3><ul class="ne-ul"><li id="cfd68b72ad47b9384c688dfb234a686e"><span class="ne-text">只读属性</span></li><li id="14d127abf548bffd5c4bf60c0d8f264e"><span class="ne-text">只返回元素节点</span></li><li id="9e055b1e452900d2c2f436fe73549e96"><span class="ne-text">非标准，但是各个浏览器都支持</span></li></ul><p id="02dbc621d526400a9fc369764443db25" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616056710609-4bb68282-b6ae-4240-b9be-a9faea530ab2.png" width="960" id="ETIGI" class="ne-image"></p><p id="7b0f909b7e33e289761ac8692ed8e3bf" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616057002507-4244db60-7bf0-4e95-b68b-acb4d4d62d8d.png" width="960" id="SeFkp" class="ne-image"></p><h3 id="8BZkY"><span class="ne-text">parent.firstChild</span></h3><p id="94055100bdfc122d67577e163d597c1e" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616057242192-2bb01e66-de7d-4220-afc2-499adbdcc3de.png" width="960" id="AABqT" class="ne-image"></p><ul class="ne-ul"><li id="cc4b16e24523b5e81ed4ddf28ad1b2ca"><span class="ne-text">返回第一个子节点，找不到返回null，包含所有节点</span></li></ul><h3 id="7u8YN"><span class="ne-text">parent.lastChild</span></h3><ul class="ne-ul"><li id="b0bb21926aa0f08aafacdc611c0905e1"><span class="ne-text">返回最后一个子节点，找不到返回null，包含所有节点</span></li></ul><h3 id="ZVCAx"><span class="ne-text">parent.firstElementChild</span></h3><ul class="ne-ul"><li id="2546240e4abb5957d6d47ec52e05a2d0"><span class="ne-text">返回第一个子元素节点，找不到返回null</span></li><li id="d02e585bb29e669b962d666aa2e2d2c9"><span class="ne-text">IE9以上支持</span></li></ul><h3 id="VZX5Y"><span class="ne-text">parent.lastElementChild</span></h3><ul class="ne-ul"><li id="b5df47c0827866d5a2158d076685e62d"><span class="ne-text">返回最后一个子元素节点，找不到返回null</span></li><li id="9dc8087686e7a330c54e0b2751448eac"><span class="ne-text">IE9以上支持</span></li></ul><h3 id="8cKJW"><span class="ne-text">首末节点兼容方案</span></h3><div class="ne-quote"><p id="ad42fb7dbeabf149dbad3d2a82077ce5" class="ne-p"><span class="ne-text">实际开发中，firstChild 和 lastChild 包含其他节点，操作不方便，而 firstElementChild 和 lastElementChild 又有兼容性问题，那么我们如何</span><span class="ne-text" style="background-color: #FADB14">获取第一个子元素节点或最后一个子元素节点</span><span class="ne-text">呢？</span></p></div><p id="515f8306e2c8718e01a2221f9466258e" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616057537841-77a6605b-5d29-4cf2-b750-0cd916841cdd.png" width="960" id="zmR8s" class="ne-image"></p><h2 id="NWCvP"><span class="ne-text">兄弟节点</span></h2><p id="3e6d008f6fb317b408d07babc65f55af" class="ne-p"><strong><span class="ne-text">下一个兄弟节点</span></strong></p><p id="b94982616ed9363bc290bb1052cd75cf" class="ne-p"><img src="../../../../../%E5%A4%87%E8%AF%BE%E8%B5%84%E6%96%99/20190220-%E8%AF%BE%E4%BB%B6%E5%88%B6%E4%BD%9C/Web%20APIs/Web%20APIs-day02/4-%E7%AC%94%E8%AE%B0/images/1550973538696.png" id="Fmrev" class="ne-image"></p><p id="8f8fe743b4bc1872fdc564c667ce2332" class="ne-p"><strong><span class="ne-text">上一个兄弟节点</span></strong></p><p id="d18faf12e39d18e226d625bc07f1bf1e" class="ne-p"><img src="../../../../../%E5%A4%87%E8%AF%BE%E8%B5%84%E6%96%99/20190220-%E8%AF%BE%E4%BB%B6%E5%88%B6%E4%BD%9C/Web%20APIs/Web%20APIs-day02/4-%E7%AC%94%E8%AE%B0/images/1550973558511.png" id="iqUXH" class="ne-image"></p><pre><code>&lt;div&gt;我是div&lt;/div&gt;    &lt;span&gt;我是span&lt;/span&gt;    &lt;script&gt;        var div = document.querySelector('div');        // 1.nextSibling 下一个兄弟节点 包含元素节点或者 文本节点等等        console.log(div.nextSibling);        console.log(div.previousSibling);        // 2. nextElementSibling 得到下一个兄弟元素节点        console.log(div.nextElementSibling);        console.log(div.previousElementSibling);    &lt;/script&gt;</code></pre><p id="2954658347162a9881591549390e610c" class="ne-p"><strong><span class="ne-text">下一个兄弟元素节点（有兼容性问题）</span></strong></p><p id="0e1a245336e0edf9e4950e49e0c9c9b0" class="ne-p"><img src="../../../../../%E5%A4%87%E8%AF%BE%E8%B5%84%E6%96%99/20190220-%E8%AF%BE%E4%BB%B6%E5%88%B6%E4%BD%9C/Web%20APIs/Web%20APIs-day02/4-%E7%AC%94%E8%AE%B0/images/1550973610223.png" id="ZByAF" class="ne-image"></p><p id="7afee902c6ad421a1412cf4081e5dfd7" class="ne-p"><strong><span class="ne-text">上一个兄弟元素节点（有兼容性问题）</span></strong></p><p id="e569f5d7ab198f09c62ddf90cd8b74a9" class="ne-p"><img src="../../../../../%E5%A4%87%E8%AF%BE%E8%B5%84%E6%96%99/20190220-%E8%AF%BE%E4%BB%B6%E5%88%B6%E4%BD%9C/Web%20APIs/Web%20APIs-day02/4-%E7%AC%94%E8%AE%B0/images/1550973630150.png" id="lHwA1" class="ne-image"></p><p id="4516a008fb10406165b70b2882c672c0" class="ne-p"><img src="../../../../../%E5%A4%87%E8%AF%BE%E8%B5%84%E6%96%99/20190220-%E8%AF%BE%E4%BB%B6%E5%88%B6%E4%BD%9C/Web%20APIs/Web%20APIs-day02/4-%E7%AC%94%E8%AE%B0/images/1550973722805.png" id="SByYv" class="ne-image"></p><p id="14a9fcb3460bf0f1e9ecaaa268bcb09e" class="ne-p"><img src="../../../../../%E5%A4%87%E8%AF%BE%E8%B5%84%E6%96%99/20190220-%E8%AF%BE%E4%BB%B6%E5%88%B6%E4%BD%9C/Web%20APIs/Web%20APIs-day02/4-%E7%AC%94%E8%AE%B0/images/1550973799759.png" id="GbWgS" class="ne-image"></p><pre><code>function getNextElementSibling(element) &#123;      var el = element;      while (el = el.nextSibling) &#123;        if (el.nodeType === 1) &#123;            return el;        &#125;      &#125;      return null;    &#125;</code></pre><h2 id="W9ils"><span class="ne-text">创建结点</span></h2><h3 id="ha59o"><span class="ne-text">document.createElement()</span></h3><ul class="ne-ul"><li id="96c84d1efcad0c3e5dd844371a1dcb73"><span class="ne-text">document.createElement('tagName')</span></li><li id="b4f5eef18cc8513ff6b060ef837d78ab"><span class="ne-text">动态创建元素节点</span></li></ul><h3 id="x1qgY"><span class="ne-text">node.cloneNode()</span></h3><p id="2ddb4ee68a31ece5931b994700e347ed" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518359854-90c1339a-ca41-47e5-86b1-189336c186d3.png" width="726" id="qNYYA" class="ne-image"></p><pre><code>&lt;ul&gt;        &lt;li&gt;1111&lt;/li&gt;        &lt;li&gt;2&lt;/li&gt;        &lt;li&gt;3&lt;/li&gt;    &lt;/ul&gt;    &lt;script&gt;        var ul = document.querySelector('ul');        // 1. node.cloneNode(); 括号为空或者里面是false 浅拷贝 只复制标签不复制里面的内容        // 2. node.cloneNode(true); 括号为true 深拷贝 复制标签复制里面的内容        var lili = ul.children[0].cloneNode(true);        ul.appendChild(lili);    &lt;/script&gt;</code></pre><h3 id="O6pmN"><span class="ne-text">Demo：动态生成表格</span></h3><p id="5f8dc010dd93f6a2a266cd688a4113c4" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518359913-8e1af74d-0a30-4370-83ea-4974ad83d2b8.png" width="718" id="ykYr0" class="ne-image"></p><p id="8d005f91d480eadcff03e6605ddcec4f" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518359980-7b2a19b1-47dd-41cb-8f9b-93d64873fb6f.png" width="751" id="SuO9z" class="ne-image"></p><pre><code>&lt;script&gt;        // 1.先去准备好学生的数据        var datas = [&#123;            name: '魏璎珞',            subject: 'JavaScript',            score: 100        &#125;, &#123;            name: '弘历',            subject: 'JavaScript',            score: 98        &#125;, &#123;            name: '傅恒',            subject: 'JavaScript',            score: 99        &#125;, &#123;            name: '明玉',            subject: 'JavaScript',            score: 88        &#125;, &#123;            name: '大猪蹄子',            subject: 'JavaScript',            score: 0        &#125;];        // 2. 往tbody 里面创建行： 有几个人（通过数组的长度）我们就创建几行        var tbody = document.querySelector('tbody');        // 遍历数组        for (var i = 0; i &lt; datas.length; i++) &#123;             // 1. 创建 tr行            var tr = document.createElement('tr');            tbody.appendChild(tr);            // 2. 行里面创建单元格td 单元格的数量取决于每个对象里面的属性个数              // 使用for in遍历学生对象            for (var k in datas[i]) &#123;                 // 创建单元格                 var td = document.createElement('td');                // 把对象里面的属性值 datas[i][k] 给 td                  td.innerHTML = datas[i][k];                tr.appendChild(td);            &#125;            // 3. 创建有删除2个字的单元格             var td = document.createElement('td');            td.innerHTML = '&lt;a href=&quot;javascript:;&quot;&gt;删除 &lt;/a&gt;';            tr.appendChild(td);        &#125;        // 4. 删除操作 开始         var as = document.querySelectorAll('a');        for (var i = 0; i &lt; as.length; i++) &#123;            as[i].onclick = function() &#123;                // 点击a 删除 当前a 所在的行(链接的爸爸的爸爸)  node.removeChild(child)                  tbody.removeChild(this.parentNode.parentNode)            &#125;        &#125;    &lt;/script&gt;</code></pre><h3 id="6oHgk"><span class="ne-text">创建元素的三种方式对比</span></h3><p id="2479c525a97b45574e75871c79bf64b3" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518360041-a233aa10-7238-46f4-bb78-2438898c8950.png" width="759" id="s3h0H" class="ne-image"></p><pre><code>&lt;script&gt;        // 三种创建元素方式区别         // 1. document.write() 创建元素  如果页面文档流加载完毕，再调用这句话会导致页面重绘         var btn = document.querySelector('button');         btn.onclick = function() &#123;             document.write('&lt;div&gt;123&lt;/div&gt;');         &#125;        // 2. innerHTML 创建元素        var inner = document.querySelector('.inner');         for (var i = 0; i &lt;= 100; i++) &#123;             inner.innerHTML += '&lt;a href=&quot;#&quot;&gt;百度&lt;/a&gt;'         &#125;        var arr = [];        for (var i = 0; i &lt;= 100; i++) &#123;            arr.push('&lt;a href=&quot;#&quot;&gt;百度&lt;/a&gt;');        &#125;        inner.innerHTML = arr.join('');        // 3. document.createElement() 创建元素        var create = document.querySelector('.create');        for (var i = 0; i &lt;= 100; i++) &#123;            var a = document.createElement('a');            create.appendChild(a);        &#125;    &lt;/script&gt;</code></pre><div class="ne-quote"><p id="66bb89d7710225bfbcb10f876f9b3ed4" class="ne-p"><span class="ne-text">innerTHML和createElement效率对比</span></p></div><p id="44edf8c2da4b84868603d0dcd99d1ab0" class="ne-p"><strong><span class="ne-text">innerHTML字符串拼接方式（效率低）</span></strong></p><pre><code>&lt;script&gt;    function fn() &#123;        var d1 = +new Date();        var str = '';        for (var i = 0; i &lt; 1000; i++) &#123;            document.body.innerHTML += '&lt;div style=&quot;width:100px; height:2px; border:1px solid blue;&quot;&gt;&lt;/div&gt;';        &#125;        var d2 = +new Date();        console.log(d2 - d1);    &#125;    fn();&lt;/script&gt;</code></pre><p id="2b823e413e8e01c50ad79dac0acf1a9d" class="ne-p"><strong><span class="ne-text">createElement方式（效率一般）</span></strong></p><pre><code>&lt;script&gt;    function fn() &#123;        var d1 = +new Date();        for (var i = 0; i &lt; 1000; i++) &#123;            var div = document.createElement('div');            div.style.width = '100px';            div.style.height = '2px';            div.style.border = '1px solid red';            document.body.appendChild(div);        &#125;        var d2 = +new Date();        console.log(d2 - d1);    &#125;    fn();&lt;/script&gt;</code></pre><p id="0166dfeb770e51b004795669737cf141" class="ne-p"><strong><span class="ne-text">innerHTML数组方式（效率高）</span></strong></p><pre><code>&lt;script&gt;    function fn() &#123;        var d1 = +new Date();        var array = [];        for (var i = 0; i &lt; 1000; i++) &#123;            array.push('&lt;div style=&quot;width:100px; height:2px; border:1px solid blue;&quot;&gt;&lt;/div&gt;');        &#125;        document.body.innerHTML = array.join('');        var d2 = +new Date();        console.log(d2 - d1);    &#125;    fn();&lt;/script&gt;</code></pre><h2 id="Xq4N9"><span class="ne-text">插入结点</span></h2><h3 id="QVxNQ"><span class="ne-text">node.appendChild()</span></h3><ul class="ne-ul"><li id="649946c80ab704b81055977fe71e029f"><span class="ne-text">node.appendChild(child)</span></li><li id="4f432e38d2e122cb48b2e2fec8e556d3"><span class="ne-text">添加到父节点的子节点列表末尾</span></li></ul><h3 id="PxnWx"><span class="ne-text">node.insertBefore()</span></h3><ul class="ne-ul"><li id="b13792234f4f581423280656bbe0e915"><span class="ne-text">node.insertBefore(child,指定元素)</span></li><li id="52a2ece9f61e782d5b10f54cd394899d"><span class="ne-text">将一个节点添加到父节点的指定子节点前面</span></li></ul><p id="217e22c13038952a26b6badb974d07f1" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616058396292-0ab90d78-37b9-4851-96bf-2e2bf5fb13cd.png" width="960" id="TYlXP" class="ne-image"></p><h3 id="juCJS"><span class="ne-text">Demo：简单版发布留言</span></h3><p id="10ac85b13821f565506d3ba166fd4b81" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518359458-b8cd80e8-0c64-4c8f-8d76-2cfcdbce3f48.png" width="337" id="fwxL4" class="ne-image"></p><p id="25c21382339a2bec5d7986e102f1f234" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518359516-1b352ba3-c851-49d8-aeff-5af5668b1d71.png" width="727" id="Azxna" class="ne-image"></p><pre><code>&lt;body&gt;    &lt;textarea name=&quot;&quot; id=&quot;&quot;&gt;&lt;/textarea&gt;    &lt;button&gt;发布&lt;/button&gt;    &lt;ul&gt;    &lt;/ul&gt;    &lt;script&gt;        // 1. 获取元素        var btn = document.querySelector('button');        var text = document.querySelector('textarea');        var ul = document.querySelector('ul');        // 2. 注册事件        btn.onclick = function() &#123;            if (text.value == '') &#123;                alert('您没有输入内容');                return false;            &#125; else &#123;                // console.log(text.value);                // (1) 创建元素                var li = document.createElement('li');                // 先有li 才能赋值                li.innerHTML = text.value;                // (2) 添加元素                // ul.appendChild(li);                ul.insertBefore(li, ul.children[0]);            &#125;        &#125;    &lt;/script&gt;&lt;/body&gt;</code></pre><h2 id="4G5LG"><span class="ne-text">删除节点</span></h2><h3 id="dOGTN"><span class="ne-text">node.removeChild() </span></h3><ul class="ne-ul"><li id="32b7446bc5896ab43803da93d378e39c"><span class="ne-text">node.removeChild() 方法从 node节点中删除一个子节点，返回删除的节点。</span></li></ul><p id="a6d0a5c7e259c75180d2fd3d8ffaf67f" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616060281051-79e7f85a-572a-4e31-b204-b5dbdaff1e60.png" width="960" id="eMnK9" class="ne-image"></p><h3 id="77XYl"><span class="ne-text">Demo：删除留言</span></h3><p id="bc2225f5b9f4ac124db30f4b695235c6" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518359732-302df5c2-5149-4e89-89dd-e99586f91651.png" width="361" id="FdDfh" class="ne-image"></p><p id="4e195b3ce00a4a21dc50d84ac9396486" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518359795-1a54681c-6264-48c2-a670-28b1f41c4388.png" width="718" id="aRDNj" class="ne-image"></p><pre><code>&lt;textarea name=&quot;&quot; id=&quot;&quot;&gt;&lt;/textarea&gt;    &lt;button&gt;发布&lt;/button&gt;    &lt;ul&gt;    &lt;/ul&gt;    &lt;script&gt;        // 1. 获取元素        var btn = document.querySelector('button');        var text = document.querySelector('textarea');        var ul = document.querySelector('ul');        // 2. 注册事件        btn.onclick = function() &#123;            if (text.value == '') &#123;                alert('您没有输入内容');                return false;            &#125; else &#123;                // console.log(text.value);                // (1) 创建元素                var li = document.createElement('li');                // 先有li 才能赋值                li.innerHTML = text.value + &quot;&lt;a href='javascript:;'&gt;删除&lt;/a&gt;&quot;;                // (2) 添加元素                // ul.appendChild(li);                ul.insertBefore(li, ul.children[0]);                // (3) 删除元素 删除的是当前链接的li  它的父亲                var as = document.querySelectorAll('a');                for (var i = 0; i &lt; as.length; i++) &#123;                    as[i].onclick = function() &#123;                        // 删除的是 li 当前a所在的li  this.parentNode;                        ul.removeChild(this.parentNode);                    &#125;                &#125;            &#125;        &#125;    &lt;/script&gt;</code></pre><p id="da21939b8aebd1ca3f149d196b4790e4" class="ne-p"><br></p></div>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
          <category> JavaScript </category>
          
          <category> DOM </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>DOM元素操作</title>
      <link href="/blog/1_day01_webapis/"/>
      <url>/blog/1_day01_webapis/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h2 id="kXvnu"><span class="ne-text">API和Web API和SDK</span></h2><ul class="ne-ul"><li id="u558b1200"><span class="ne-text">文档：</span><a href="https://developer.mozilla.org/zh-CN/docs/Web/API" data-href="https://developer.mozilla.org/zh-CN/docs/Web/API" target="_blank" class="ne-link"><span class="ne-text">https://developer.mozilla.org/zh-CN/docs/Web/API</span></a></li></ul><p id="46a55321a1895c69fde7aeab23a2c28b" class="ne-p"><br></p><div data-type="color2" class="ne-alert"><p id="5291c3b97996b679982429fc3397629f" class="ne-p" style="text-indent: 2em"><span class="ne-text">API（Application Programming Interface，应用程序编程接口）是一些预先定义的函数，目的是提供应用程序与开发人员基于某软件或硬件得以访问一组例程的能力，而又无需访问源码，无需理解其内部工作机制细节，只需直接调用使用即可。</span></p><p id="ub0b15aa9" class="ne-p" style="text-indent: 2em"><span class="ne-text">Web API 是浏览器提供的一套操作浏览器功能和页面元素的 API ( BOM 和 DOM )。</span></p><p id="u84e7cb00" class="ne-p" style="text-indent: 2em"><a href="https://www.zhihu.com/question/21691705" data-href="https://www.zhihu.com/question/21691705" target="_blank" class="ne-link"><span class="ne-text">https://www.zhihu.com/question/21691705</span></a></p></div><p id="u40e389be" class="ne-p"><br></p><h2 id="93oSV"><span class="ne-text">DOM总结</span></h2><p id="d2dc6ed3d0cf7e566d27b3c1e4796553" class="ne-p"><span class="ne-text">关于dom操作，我们主要针对于元素的操作。主要有创建、增、删、改、查、属性操作、事件操作。</span></p><p id="e36c44b913505a074d5c2745fd5745ac" class="ne-p"><span class="ne-text">【1】创建</span></p><p id="4c7cd54fd8ba33513a77991fcd6544b4" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518360222-db94e8d0-f9a7-459d-8a24-88b745237bd5.png" width="691" id="FDEjx" class="ne-image"></p><p id="9c3c4b00d6fd2ce9decc0d669bbf0f93" class="ne-p"><span class="ne-text">【2】增</span></p><p id="436b5b59f684285797cce52197a750d1" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518360287-480d224a-a047-4ef5-8bba-92845d85b573.png" width="720" id="ITVoj" class="ne-image"></p><p id="bb9372eb5deae8f74ce73ee55ec42aeb" class="ne-p"><span class="ne-text">【3】删</span></p><p id="87d68c0fd85fae7f741af7d4d6778d1a" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518360367-4e96254b-5fd8-4f7e-8fb3-29143718f08d.png" width="695" id="Y43N0" class="ne-image"></p><p id="4d144f96f196a9852cc6bd0e3ff55001" class="ne-p"><span class="ne-text">【4】改</span></p><p id="7a6028416e906114f423e37858dd2e3d" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518360436-7e94f916-24d1-4e97-84fe-6fc6ba6d68fb.png" width="731" id="Ex39g" class="ne-image"></p><p id="b062b8089a2b2862cea420f46547a800" class="ne-p"><span class="ne-text">【5】查</span></p><p id="8d43f07d6e7a91d895c47a6ad35de70d" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518360497-cfec4566-ac5b-46c6-995d-8db307167137.png" width="703" id="mmFdZ" class="ne-image"></p><p id="baa1abc359c4fffb9cbcdfa99aaf3ee7" class="ne-p"><span class="ne-text">【6】属性操作</span></p><p id="3f836afe6696cf03b355adb074be23f2" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518360564-6e2cf7dd-fa5e-48fe-bcdb-be69ea87065c.png" width="722" id="MIdFD" class="ne-image"></p><p id="f0172a463e96ea8908580ce1583d5829" class="ne-p"><span class="ne-text">【7】事件操作（重点）</span></p><h2 id="aSkft"><span class="ne-text">获取元素</span></h2><h3 id="y6ztq"><span class="ne-text">getElementById</span></h3><ul class="ne-ul"><li id="f1719c4402fcb59e9d3cf73ec34ba38a"><span class="ne-text">语法：document.getElementById(id)</span></li><li id="12217790a54ad508927771e6a7efdb6c"><span class="ne-text">作用：根据ID获取元素对象</span></li><li id="a23e203313e0d34ba7bf8c0bf1d839e6"><span class="ne-text">参数：id值，区分大小写的字符串</span></li><li id="3be95e2cc1b6817bda44d4fabb3d1d92"><span class="ne-text">返回值：元素对象 或 null</span></li></ul><p id="461243afee13281b53efe612e95b95d6" class="ne-p"><strong><span class="ne-text"></span></strong></p><pre><code>var test_id = document.getElementById('indexLogo');</code></pre><p id="294ffa847e4baf68230cb7b07bbe1024" class="ne-p"><br></p><p id="3cb570bd77d18b6f22da38d9472c4acc" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616048539813-60fc22f6-0d07-482c-aaae-0227b1f55206.png" width="458" id="N8Ltb" class="ne-image"></p><h3 id="iE8k5"><span class="ne-text">getElementsByTagName</span></h3><ul class="ne-ul"><li id="569cbc6c9f38397aabc6b1f3c5f6fea3"><span class="ne-text">语法：document.getElementsByTagName('标签名') 或者 element.getElementsByTagName('标签名') </span></li><li id="a800fcae80700b9a1ba7a4cf1d64e137"><span class="ne-text">作用：根据标签名获取元素对象</span></li><li id="c257c843c80461ec8bc372fb600881b8"><span class="ne-text">参数：标签名</span></li><li id="a44919a3f9a2c3aae3b3ad67cadae8ec"><span class="ne-text">返回值：元素对象集合（伪数组，数组元素是元素对象）</span><strong><span class="ne-text"></span></strong></li></ul><pre><code>var test_tag = document.getElementsByTagName('p');</code></pre><p id="40778211121366a71fcf19e632a0d747" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616048909454-bdfb7dbc-18e4-4449-abc6-800e87b42380.png" width="960" id="t8bGK" class="ne-image"></p><ul class="ne-ul"><li id="b34498ba8e1e1389a1109099ce7aaa2b"><span class="ne-text">getElementsByTagName()获取到是动态集合，即：当页面增加了标签，这个集合中也就增加了元素。</span></li><li id="07d484efcc0dcac5a6d9a9b02fed9ab6"><span class="ne-text">由上面的图可以知道，得到的不是一个对象，而是一个对象集合，所以要操作具体的一个p就要遍历，然后再进行操作（抑或是对其当作节点再进行操作）</span></li></ul><h3 id="lOixS"><span class="ne-text">getElementsByClassName</span></h3><h3 id="nv6PV"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616049522946-8c892471-1b04-4b04-b56f-630420bdb654.png" width="960" id="Nlkk2" class="ne-image"></h3><h3 id="AIV4u"><span class="ne-text">querySelector</span></h3><p id="8f9179e82d91b48eb024cdac48bfb563" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616049685312-55929307-c68b-4e1d-b6b5-1845c0d5a878.png" width="960" id="LgQYU" class="ne-image"></p><h3 id="qVXpe"><span class="ne-text">querySelectorAll</span></h3><p id="e6c4ba0c3da0bccddf51c8a37952abfe" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616049810063-ee5595dc-89bb-47cc-aa9a-c9446ed97d6f.png" width="960" id="KPxZC" class="ne-image"></p><ul class="ne-ul"><li id="ec916636cb33d1b8bb0ef59f878a566b"><span class="ne-text">如果是选择器，需要加符号 </span><code class="ne-code"><span class="ne-text">querySelectorAll('#box1')</span></code><span class="ne-text"> </span><strong><span class="ne-text"></span></strong></li></ul><h3 id="49WPY"><span class="ne-text">获取body/html对象</span></h3><p id="782093db7de09b389fac5ebf8f94ccda" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616050005999-ac944be2-9612-41ac-89f7-9fa04c4d3912.png" width="960" id="PNy3x" class="ne-image"></p><p id="818568300e29c7f77a38996b4784f6e7" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518355850-2e015c88-50b7-400e-9593-c7e21a9068b5.png" width="748" id="Z6YzO" class="ne-image"></p><h2 id="QPRCY"><span class="ne-text">操作元素内容/属性</span></h2><p id="231261464f3195f4bc5abf22621579ce" class="ne-p"><span class="ne-text">JavaScript的 DOM 操作可以改变网页内容、结构和样式，我们可以利用 DOM 操作元素来改变元素里面的内容、属性等。（注意：这些操作都是通过元素对象的属性实现的）</span></p><h4 id="NABhf" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518357274-e26496b9-3fdb-47de-85be-fd6aea949767.png" width="442" id="n2RiL" class="ne-image"></h4><h3 id="hufij"><span class="ne-text">innerText和innerHTML</span></h3><ul class="ne-ul"><li id="533564842a159c2f961d622684f8f626"><span class="ne-text">获取内容时的区别：innerText会去除空格和换行，而innerHTML会保留空格和换行</span></li><li id="c4044cc83ce8e36d708c42e5255f2e37"><span class="ne-text">设置内容时的区别：innerText不会识别html，而innerHTML会识别</span></li><li id="02a0603246a53e036ffbaacc4089267b"><span class="ne-text">小记：是属性，不是方法！要用赋值的形式，而不是带参数的形式</span></li></ul><p id="4f95198e0ef3a9d536ebc3577b7bd8b7" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616053295394-7fe7d51d-3ce6-4f51-9898-9e0e62b207c4.png" width="960" id="JoltV" class="ne-image"></p><p id="2dcdbf74ff30faf3b96cdf4824622a6f" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616053546675-78ea1659-1dee-4b43-aa1a-82aad00e1795.png" width="960" id="t99V1" class="ne-image"></p><h3 id="6Ju71"><span class="ne-text">改变元素属性操作</span></h3><h3 id="9e57k"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616053829361-6faff7b2-0d8f-41c6-b909-6b72ff3b5401.png" width="960" id="fZfug" class="ne-image"></h3><p id="600003b1cb57747b608f5712550f1236" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616054507713-8b717792-1d98-4477-a9e8-db7417b87f34.png" width="960" id="lu27B" class="ne-image"></p><h3 id="1fiqy"><span class="ne-text">element.style</span></h3><h3 id="ebUmt"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616053829361-6faff7b2-0d8f-41c6-b909-6b72ff3b5401.png" width="960" id="uXyKy" class="ne-image"></h3><ul class="ne-ul"><li id="e5f1f5c01ab77f9aa0bab0743b156bc7"><span class="ne-text">元素对象的style属性也是一个对象！</span></li><li id="c1c6acc991cf7cb26f48fc953fc73a6c"><span class="ne-text">元素对象.style.样式属性 = 值;</span></li><li id="4b0ab22a2c4e0de22a695a451e46a565"><span class="ne-text">其中样式属性的命名不再是中间有-的，而是驼峰命名，eg：backgroundColor</span></li><li id="f0e95dc00ab4260e2cd0822c77d61d1b"><span class="ne-text">js修改的style样式操作，产生的是行内样式，css权重较高</span></li></ul><h3 id="1tNkf"><span class="ne-text">element.className</span></h3><ul class="ne-ul"><li id="aaf7eadae2a32bd0e2669c62d7bd923d"><span class="ne-text">元素对象.className = 值;</span></li><li id="e3ea1781ca3cffb067c8621a4bc01551"><span class="ne-text">因为class是关键字，所有使用className，覆盖原先的类名</span></li></ul><p id="d4ad769ece313bfb45ebdf3a41e3f9b7" class="ne-p"><br></p><pre><code>&lt;body&gt;    &lt;div class=&quot;first&quot;&gt;文本&lt;/div&gt;    &lt;script&gt;        // 1. 使用 element.style 获得修改元素样式  如果样式比较少 或者 功能简单的情况下使用        var test = document.querySelector('div');        test.onclick = function() &#123;            // 2. 我们可以通过 修改元素的className更改元素的样式 适合于样式较多或者功能复杂的情况            // 3. 如果想要保留原先的类名，我们可以这么做 多类名选择器            // this.className = 'change';            this.className = 'first change';        &#125;    &lt;/script&gt;&lt;/body&gt;</code></pre><h2 id="wqS45"><span class="ne-text">自定义元素属性</span></h2><h3 id="38TpP"><span class="ne-text">element.getAttribute</span></h3><ul class="ne-ul"><li id="7250277a59b030794fb03d75366e68d2"><span class="ne-text">和element.属性不同的是，获取的是自定义属性的值，而</span><span class="ne-text">element.属性获取的是内置的属性</span></li></ul><pre><code>&lt;div id=&quot;demo&quot; index=&quot;1&quot; class=&quot;nav&quot;&gt;&lt;/div&gt;    &lt;script&gt;        var div = document.querySelector('div');        // 1. 获取元素的属性值        // (1) element.属性        console.log(div.id);        //(2) element.getAttribute('属性')  get得到获取 attribute 属性的意思 我们程序员自己添加的属性我们称为自定义属性 index        console.log(div.getAttribute('id'));        console.log(div.getAttribute('index'));    &lt;/script&gt;</code></pre><h3 id="Ju7l1"><span class="ne-text">element.setAttribute</span></h3><ul class="ne-ul"><li id="d59a6ca897a739414fbc4aa61081127e"><span class="ne-text">element.setAttribute('属性','值')；</span></li></ul><pre><code>// 2. 设置元素属性值// (1) element.属性= '值'div.id = 'test';div.className = 'navs';// (2) element.setAttribute('属性', '值');  主要针对于自定义属性div.setAttribute('index', 2);div.setAttribute('class', 'footer'); // class 特殊  这里面写的就是</code></pre><h3 id="Bw0TQ"><span class="ne-text">element.removeAttribute</span></h3><pre><code>// class 不是className// 3 移除属性 removeAttribute(属性)    div.removeAttribute('index');</code></pre><h3 id="8H5MW"><span class="ne-text">Demo：tab栏</span></h3><p id="7d95c8cd54584a750b700f79681b518f" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518358239-8396b94f-cc87-4ff3-bc86-20c652a2fe8f.png" width="786" id="loWsi" class="ne-image"></p><p id="5bba20fb3e4554c5be1be14951844e58" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518358314-a1d9f6be-a9c3-4693-8b11-eec0665df297.png" width="744" id="zrKHc" class="ne-image"></p><pre><code>&lt;script&gt;        // 获取元素        var tab_list = document.querySelector('.tab_list');        var lis = tab_list.querySelectorAll('li');        var items = document.querySelectorAll('.item');        // for循环，给选项卡绑定点击事件        for (var i = 0; i &lt; lis.length; i++) &#123;            // 开始给5个小li 设置索引号             lis[i].setAttribute('index', i);            lis[i].onclick = function() &#123;                // 1. 上的模块选项卡，当前这一个底色会是红色，其余不变（排他思想）                // 干掉所有人 其余的li清除 class 这个类                for (var i = 0; i &lt; lis.length; i++) &#123;                    lis[i].className = '';                &#125;                // 留下我自己                 this.className = 'current';                // 2. 下面的显示内容模块                var index = this.getAttribute('index');                console.log(index);                // 干掉所有人 让其余的item 这些div 隐藏                for (var i = 0; i &lt; items.length; i++) &#123;                    items[i].style.display = 'none';                &#125;                // 留下我自己 让对应的item 显示出来                items[index].style.display = 'block';            &#125;        &#125;    &lt;/script&gt;</code></pre><h3 id="A5dLE"><span class="ne-text">element.dataset</span></h3><p id="52bd4c3c970ebe6427840f35f75fdd30" class="ne-p"><span class="ne-text">自定义属性目的：是为了保存并使用数据。有些数据可以保存到页面中而不用保存到数据库中。</span></p><p id="31fafa53a2b0d3a98fc062f59ba54e0a" class="ne-p"><span class="ne-text">自定义属性获取是通过getAttribute(‘属性’) 获取。</span></p><p id="63a299636dc1440b67ea25d070e9cd83" class="ne-p"><span class="ne-text">但是有些自定义属性很容易引起歧义，不容易判断是元素的内置属性还是自定义属性。</span></p><p id="2244a4bc40652131415dc54d083183b6" class="ne-p"><span class="ne-text">H5给我们新增了自定义属性：</span></p><p id="45df4c9292145a8050e9f4e7eefe8cc4" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518358371-b2d8cb33-5750-4e13-be06-27c86768b244.png" width="705" id="lLVY2" class="ne-image"></p><p id="52e2425c30b46fe0f3e38e022835773f" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518358431-0a046321-c303-4333-9e0d-57875144f3e5.png" width="691" id="FSDEa" class="ne-image"></p><pre><code>&lt;div getTime=&quot;20&quot; data-index=&quot;2&quot; data-list-name=&quot;andy&quot;&gt;&lt;/div&gt;&lt;script&gt;  var div = document.querySelector('div');  // console.log(div.getTime);  console.log(div.getAttribute('getTime'));  div.setAttribute('data-time', 20);  console.log(div.getAttribute('data-index'));  console.log(div.getAttribute('data-list-name'));  // h5新增的获取自定义属性的方法 它只能获取data-开头的  // dataset 是一个集合里面存放了所有以data开头的自定义属性  console.log(div.dataset);  console.log(div.dataset.index);  console.log(div.dataset['index']);  // 如果自定义属性里面有多个-链接的单词，我们获取的时候采取 驼峰命名法  console.log(div.dataset.listName);  console.log(div.dataset['listName']);&lt;/script&gt;</code></pre></div>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
          <category> JavaScript </category>
          
          <category> DOM </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript内置对象和全局属性和函数</title>
      <link href="/blog/fc3rdkwoum2b/"/>
      <url>/blog/fc3rdkwoum2b/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="u261d7807" class="ne-p"><strong><span class="ne-text">前言：</span></strong></p><p id="u4d3428e8" class="ne-p"><span class="ne-text">【全文内容是基于以下文档内容所作的补充】</span></p><ul class="ne-ul"><li id="u2b79b1a0"><span class="ne-text">MDN：</span><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects" data-href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects" target="_blank" class="ne-link"><span class="ne-text">JavaScript 标准内置对象</span></a></li><li id="ub7629a50"><span class="ne-text">W3school：</span><a href="https://www.w3school.com.cn/jsref/index.asp" data-href="https://www.w3school.com.cn/jsref/index.asp" target="_blank" class="ne-link"><span class="ne-text">JavaScript 和 HTML DOM 参考手册</span></a></li><li id="ub4e95964"><span class="ne-text">菜鸟教程：</span><a href="https://www.runoob.com/jsref/jsref-tutorial.html" data-href="https://www.runoob.com/jsref/jsref-tutorial.html" target="_blank" class="ne-link"><span class="ne-text">JavaScript 和 HTML DOM 参考手册</span></a></li></ul><p id="ub9304818" class="ne-p"><span class="ne-text"></span></p><p id="ue5cc3ce9" class="ne-p"><span class="ne-text">补充：数组、字符串两中对象，都是打印原始值：</span></p><ul class="ne-ul"><li id="u71c31306"><span class="ne-text">toString</span></li><li id="u2fee9a4c"><span class="ne-text">valueOf</span></li></ul><h2 id="FFg7P"><span class="ne-text">String</span></h2><h3 id="lajfL"><span class="ne-text">API</span></h3><table id="VULTc" class="ne-table" style="width: 488px"><tbody><tr style="height: 33px"><td width="113" style="background-color: #F5F5F5"><p id="u617eacbe" class="ne-p" style="text-align: left"><span class="ne-text">类型</span></p></td><td width="375" style="background-color: #F5F5F5"><p id="u7aaa95ae" class="ne-p"><span class="ne-text">API</span></p></td></tr><tr style="height: 33px"><td width="113"><p id="ub8860a2e" class="ne-p" style="text-align: left"><span class="ne-text">增、删、改</span></p></td><td width="375"><ul class="ne-ul"><li id="uceea0bfc"><span class="ne-text">replace()：修改指定字符串为新字符串</span></li><li id="uc6b2f2b2"><span class="ne-text">replaceAll()：所有的</span></li><li id="u749b6910"><span class="ne-text">slice()：和数组api一样</span></li><li id="uc10a88f1"><span class="ne-text">substr()：给起始索引截取指定个数</span></li><li id="u8b3d45d9"><span class="ne-text">substring()：[起始索引，结束索引)</span></li><li id="u82f1c337"><span class="ne-text">trim()：清楚两边空白字符串</span></li><li id="u83eb35a6"><span class="ne-text">toLowerCase()：字符串转换为小写</span></li><li id="ue834212a"><span class="ne-text">toUpperCase()：字符串转换为大写</span></li><li id="uc927ccb9"><span class="ne-text">toLocaleLowerCase()：根据本地主机的语言环境把字符串转换为小写</span></li><li id="ue44112ac"><span class="ne-text">toLocaleUpperCase()：根据本地主机的语言环境把字符串转换为大写</span></li></ul></td></tr><tr style="height: 33px"><td width="113"><p id="ud3d7e531" class="ne-p" style="text-align: left"><span class="ne-text">查</span></p></td><td width="375"><ul class="ne-ul"><li id="u2d171914"><span class="ne-text">charAt：根据索引得到指定位置值</span></li><li id="ue1bff438"><span class="ne-text">charCodeAt：根据索引得到指定位置值Unicode码</span></li><li id="u8b35bee4"><span class="ne-text">indexOf()：查找子字符串的初次索引</span></li><li id="u5dedcd4a"><span class="ne-text">lastIndexOf()：从右往左</span></li><li id="u71a562bb"><span class="ne-text">includes()：是否包含子字符串</span></li><li id="ue1763914"><span class="ne-text">match()：查找正则规则子字符串</span></li><li id="u0d483084"><span class="ne-text">search()：查找指定字符串/正则的索引</span></li></ul></td></tr><tr style="height: 33px"><td width="113"><p id="u1b9296c1" class="ne-p" style="text-align: left"><span class="ne-text">和数组联系</span></p></td><td width="375"><ul class="ne-ul"><li id="u99f3459b"><span class="ne-text">split：根据指定字符切割数组</span></li></ul></td></tr><tr style="height: 33px"><td width="113"><p id="u9dc6f3f5" class="ne-p" style="text-align: left"><span class="ne-text">拷贝和拼接</span></p></td><td width="375"><ul class="ne-ul"><li id="ua930b6b7"><span class="ne-text">concat：和数组一样</span></li></ul></td></tr><tr style="height: 33px"><td width="113"><p id="u4678e961" class="ne-p" style="text-align: left"><span class="ne-text">其他</span></p></td><td width="375"><ul class="ne-ul"><li id="u4e3ede4b"><span class="ne-text">startsWith()：是否以子字符串开头</span></li><li id="uaf594236"><span class="ne-text">endsWith：是否以子字符串结尾</span></li><li id="u1c34259a"><span class="ne-text">fromCharCode()：Unicode码转换为字符</span></li><li id="u88b66f9e"><span class="ne-text">repeat：将字符串复制指定次数并返回，参数是次数</span></li></ul></td></tr></tbody></table><h3 id="PScRQ"><span class="ne-text">反引号</span></h3><p id="udbabc879" class="ne-p"><span class="ne-text">ES6新增的创建字符串的方式，使用反引号定义</span></p><ul class="ne-ul"><li id="u6e263fc1"><span class="ne-text">模板字符串中可以解析变量</span></li></ul><ul class="ne-ul"><li id="uc4068474"><span class="ne-text">模板字符串中可以换行</span></li></ul><ul class="ne-ul"><li id="u2bc5cf99"><span class="ne-text">在模板字符串中可以调用函数</span></li></ul><pre><code>const sayHello = function () &#123;     return '666'; &#125;;  let greet = `$&#123;sayHello()&#125; 777`; console.log(greet); // 666 777</code></pre><h3 id="NEia8"><span class="ne-text">正则表达式</span></h3><h4 id="XWA8j"><span class="ne-text">js匹配string中的img标签，并且获取其src图片链接地址</span></h4><pre><code>&lt;script&gt;  window.onload = function () &#123;    var content = '&lt;P&gt;&lt;img src=&quot;http://bbs.cn.yimg.com/user_img/200701/31/jisuanji986_117025184198149.jpg&quot; mce_src=&quot;http://bbs.cn.yimg.com/user_img/200701/31/jisuanji986_117025184198149.jpg&quot;&gt;&lt;/P&gt;'    let imgReg = /&lt;img.*?(?:&gt;|\/&gt;)/gi //匹配图片中的img标签    let srcReg = /src=[\'\&quot;]?([^\'\&quot;]*)[\'\&quot;]?/i // 匹配图片中的src    let arr = content.match(imgReg)  //筛选出所有的img    console.log(arr)    let srcArr = []    for (let i = 0; i &lt; arr.length; i++) &#123;      let src = arr[i].match(srcReg)      // 获取图片地址      srcArr.push(src[1])    &#125;    console.log(srcArr)  &#125;&lt;/script&gt;<p></code></pre></p><h2 id="RQulP"><span class="ne-text">Array</span></h2><h3 id="JnsIz"><span class="ne-text">API</span></h3><table id="YyxzQ" class="ne-table" style="width: 514px"><tbody><tr style="height: 33px"><td width="139" style="background-color: #F5F5F5"><p id="ue39bf158" class="ne-p" style="text-align: left"><span class="ne-text">类型</span></p></td><td width="375" style="background-color: #F5F5F5"><p id="ub804ed71" class="ne-p"><span class="ne-text">API</span></p></td></tr><tr style="height: 33px"><td width="139"><p id="ua63777b7" class="ne-p" style="text-align: left"><span class="ne-text">增、删、改</span></p></td><td width="375"><ul class="ne-ul"><li id="ua151c249"><span class="ne-text">slice：操作完然后复制结果为一个新数组</span></li><li id="uae071f96"><span class="ne-text">splice：会改变原始数组，返回的删除元素数组</span></li></ul></td></tr><tr style="height: 33px"><td width="139"><p id="uecace477" class="ne-p" style="text-align: left"><span class="ne-text">查</span></p></td><td width="375"><ul class="ne-ul"><li id="u08bc2761"><span class="ne-text">includes：根据数组元素值查</span></li><li id="ub252024f"><span class="ne-text">indexOf：根据索引查</span></li><li id="u2c0a06ef"><span class="ne-text">lastIndexOf：根据索引查</span></li></ul></td></tr><tr style="height: 33px"><td width="139"><p id="u1c022b42" class="ne-p"><span class="ne-text">栈、队列</span></p></td><td width="375"><ul class="ne-ul"><li id="uf37d678d"><span class="ne-text">push：末尾添加元素，返回新长度</span></li><li id="u28f95f9c"><span class="ne-text">pop：删除最后一个元素并且返回该值</span></li><li id="uab4a9f75"><span class="ne-text">shift：删除第一个元素并且返回该值</span></li><li id="u0787b237"><span class="ne-text">unshift：开头添加元素，返回新长度</span></li></ul></td></tr><tr style="height: 33px"><td width="139"><p id="ud43d0a77" class="ne-p" style="text-align: left"><span class="ne-text">和字符串联系</span></p></td><td width="375"><ul class="ne-ul"><li id="u69790b3c"><span class="ne-text">join：通过指定字符串拼接，空参数则为逗号</span></li></ul></td></tr><tr style="height: 33px"><td width="139"><p id="u8a07e430" class="ne-p" style="text-align: left"><span class="ne-text">迭代遍历有关</span></p></td><td width="375"><p id="u10558545" class="ne-p"><span class="ne-text">every、some、entries、filter、find、findIndex、forEach、keys</span></p><ul class="ne-ul"><li id="u3a814cdc"><span class="ne-text">find：常用于在对象数组中，查找指定属性值的数组元素</span></li><li id="u2a14a33e"><span class="ne-text">map：相当于将y = x 变成y = x</span><sup><span class="ne-text">2</span></sup><span class="ne-text">，不改变原数组</span></li><li id="uf673912c"><span class="ne-text">reduce：把结果继续和序列的下一个元素做累积计算</span></li></ul><pre><code>var arr = [1, 3, 5, 7, 9];arr.reduce(function (x, y) &#123;    return x * 10 + y;&#125;); // 13579</code></pre><ul class="ne-ul"><li id="uf9f49f80"><span class="ne-text">reduceRight</span></li></ul></td></tr><tr style="height: 33px"><td width="139"><p id="ud7b8e5a9" class="ne-p" style="text-align: left"><span class="ne-text">拷贝和拼接</span></p></td><td width="375"><ul class="ne-ul"><li id="u54065c1a"><span class="ne-text">concat：不改变原数组，arr1.concat(arr2, arr3)</span></li><li id="u1e00281c"><span class="ne-text">copyWithin：从数组的指定位置拷贝元素到数组的另一个指定位置中</span></li></ul></td></tr><tr style="height: 33px"><td width="139"><p id="u40e31ae7" class="ne-p" style="text-align: left"><span class="ne-text">排序</span></p></td><td width="375"><ul class="ne-ul"><li id="uecea2954"><span class="ne-text">sort：数字升序（sort((a,b)=&gt;{return a-b})）</span></li><li id="u76b32c37"><span class="ne-text">reserve：逆置</span></li></ul></td></tr><tr style="height: 33px"><td width="139"><p id="u04b94af7" class="ne-p" style="text-align: left"><span class="ne-text">其他</span></p></td><td width="375"><ul class="ne-ul"><li id="u2a30c5c0"><span class="ne-text">fill：使用一个值来填充/替换数组元素，可以指定索引，通常用在DP问题的填充0</span></li><li id="u3257185f"><span class="ne-text">from：构造函数方法，将伪数组或可遍历对象转换为真正的数组（类数组转换为数组）</span></li></ul><div class="ne-quote"><p id="u4f76070f" class="ne-p"><span class="ne-text">伪数组、可遍历对象、Set</span></p></div><ul class="ne-ul"><li id="u455e6bce"><span class="ne-text">isArray</span></li></ul></td></tr></tbody></table><h3 id="B7bYV"><span class="ne-text">类数组与数组</span></h3><p id="u6772056e" class="ne-p"><a href="https://blog.csdn.net/qq_37635012/article/details/106195211" data-href="https://blog.csdn.net/qq_37635012/article/details/106195211" target="_blank" class="ne-link"><span class="ne-text">https://blog.csdn.net/qq_37635012/article/details/106195211</span></a></p><h3 id="xdGXB"><span class="ne-text">扩展运算符</span></h3><p id="6b22497dcf2459ba4e94305295651863" class="ne-p"><span class="ne-text">扩展运算符可以将数组或者对象转为用逗号分隔的参数序列</span></p><p id="u66ffe4c2" class="ne-p"><strong><span class="ne-text" style="color: #E8323C">扩展运算符可以应用于合并数组</span></strong></p><pre><code>// 方法一  let ary1 = [1, 2, 3]; let ary2 = [3, 4, 5]; let ary3 = [...ary1, ...ary2]; // 方法二  ary1.push(...ary2);</code></pre><p id="u3a23de2d" class="ne-p"><strong><span class="ne-text" style="color: #E8323C">将类数组或可遍历对象转换为真正的数组</span></strong></p><pre><code>let oDivs = document.getElementsByTagName('div'); oDivs = [...oDivs];</code></pre><h3 id="tBIF4"><span class="ne-text">Array构造函数</span></h3><ul class="ne-ul"><li id="u9f71d109"><span class="ne-text">Array构造函数：</span><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/Array" data-href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/Array" target="_blank" class="ne-link"><span class="ne-text">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/Array</span></a></li></ul><h3 id="D5FbK"><span class="ne-text">from</span></h3><p id="u48ce05e1" class="ne-p"><span class="ne-text">构造函数方法：Array.from()</span></p><p id="a55532828913cd79169f81b6626ea807" class="ne-p"><span class="ne-text">将伪数组或可遍历对象转换为真正的数组</span></p><pre><code>//定义一个集合let arrayLike = &#123;    '0': 'a',    '1': 'b',    '2': 'c',    length: 3&#125;; //转成数组let arr2 = Array.from(arrayLike); // ['a', 'b', 'c']</code></pre><p id="5cfbba68dda39d45a09a16232e8d457d" class="ne-p"><span class="ne-text">方法还可以接受第二个参数，作用类似于数组的map方法，用来对每个元素进行处理，将处理后的值放入返回的数组</span></p><pre><code>let arrayLike = &#123;      &quot;0&quot;: 1,     &quot;1&quot;: 2,     &quot;length&quot;: 2 &#125; let newAry = Array.from(arrayLike, item =&gt; item *2)//[2,4]</code></pre><p id="1a11d080cac1316fae624d88ef6b98cd" class="ne-p"><span class="ne-text">注意：如果是对象，那么属性需要写对应的索引</span></p><h3 id="Z9Ogp"><span class="ne-text">find</span></h3><p id="d9da4319774215d055aa9f178498bcac" class="ne-p"><span class="ne-text">用于找出第一个符合条件的数组成员，如果没有找到返回undefined</span></p><pre><code>let ary = [&#123;     id: 1,     name: '张三' &#125;, &#123;      id: 2,     name: '李四' &#125;]; //找数组里面符合条件的值，当数组中元素id等于2的查找出来，注意，只会匹配第一个 let target = ary.find((item, index) =&gt; item.id == 2);</code></pre><h3 id="QV1uF"><span class="ne-text">findIndex</span></h3><p id="926e377abb1d5d9bce32f14ef10cc0c8" class="ne-p"><span class="ne-text">用于找出第一个符合条件的数组成员的位置，如果没有找到返回-1</span></p><pre><code>let ary = [1, 5, 10, 15];let index = ary.findIndex((value, index) =&gt; value &gt; 9); console.log(index); // 2</code></pre><h2 id="aYG20"><span class="ne-text">Set</span></h2><p id="u45fbb6f7" class="ne-p"><a href="https://www.runoob.com/w3cnote/es6-map-set.html" data-href="https://www.runoob.com/w3cnote/es6-map-set.html" target="_blank" class="ne-link"><span class="ne-text">https://www.runoob.com/w3cnote/es6-map-set.html</span></a></p><h3 id="wPg0o"><span class="ne-text">构造函数</span></h3><p id="d69e2b330bbdf98ea073bb8d8682d0d6" class="ne-p"><span class="ne-text">ES6 提供了新的数据结构  Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。</span></p><p id="5678d1e94c0c0e8e175c338c7c7d3f7a" class="ne-p"><span class="ne-text">Set本身是一个构造函数，用来生成  Set  数据结构</span></p><pre><code>const s = new Set();</code></pre><p id="4fb8c374014d58f0a33f107e2db03d10" class="ne-p"><span class="ne-text">Set函数可以接受一个数组作为参数，用来初始化。</span></p><pre><code>const set = new Set([1, 2, 3, 4, 4]);//&#123;1, 2, 3, 4&#125;</code></pre><h3 id="qoiWl"><span class="ne-text">实例方法</span></h3><ul class="ne-ul"><li id="0ab1d7020fd21bf92e6d626b0276a540"><span class="ne-text">add(value)：添加某个值，返回 Set 结构本身</span></li><li id="1c3ec2ddd240bd790c2e3847a5d53936"><span class="ne-text">delete(value)：删除某个值，返回一个布尔值，表示删除是否成功</span></li><li id="e79974c89233f1c17df98e55353ec9c3"><span class="ne-text">has(value)：返回一个布尔值，表示该值是否为 Set 的成员</span></li><li id="061c1d0fef5be553c3322d0227757653"><span class="ne-text">clear()：清除所有成员，没有返回值</span></li></ul><pre><code>const s = new Set(); s.add(1).add(2).add(3); // 向 set 结构中添加值  s.delete(2)             // 删除 set 结构中的2值    s.has(1)                // 表示 set 结构中是否有1这个值 返回布尔值  s.clear()               // 清除 set 结构中的所有值 //注意：删除的是元素的值，不是代表的索引</code></pre><h3 id="dwQLf"><span class="ne-text">遍历</span></h3><p id="5d10e3fbc5f04d2ca41330e68eade34f" class="ne-p"><span class="ne-text">Set 结构的实例与数组一样，也拥有forEach方法，用于对每个成员执行某种操作，没有返回值。</span></p><pre><code>s.forEach(value =&gt; console.log(value))</code></pre><h2 id="XKyKc"><span class="ne-text">Map</span></h2><p id="u0b973f4e" class="ne-p"><a href="https://www.runoob.com/w3cnote/es6-map-set.html" data-href="https://www.runoob.com/w3cnote/es6-map-set.html" target="_blank" class="ne-link"><span class="ne-text">https://www.runoob.com/w3cnote/es6-map-set.html</span></a></p><h2 id="cC4mz"><span class="ne-text">其他</span></h2><h3 id="DHVnH"><span class="ne-text" style="color: rgb(49, 49, 48)">解构赋值</span></h3><ul class="ne-ul"><li id="ud57ba94c"><span class="ne-text">数组和对象可以赋值解构</span></li><li id="ubff8641c"><span class="ne-text">参考：</span><a href="https://zh.javascript.info/destructuring-assignment" data-href="https://zh.javascript.info/destructuring-assignment" target="_blank" class="ne-link"><span class="ne-text">https://zh.javascript.info/destructuring-assignment</span></a></li></ul><h3 id="KnCV1"><span class="ne-text">剩余参数</span></h3><ul class="ne-ul"><li id="u71820533"><span class="ne-text">剩余参数是以</span><strong><span class="ne-text">数组</span></strong><span class="ne-text">的形式存在的</span></li></ul><pre><code>function sum(...theArgs) &#123;  return theArgs.reduce((previous, current) =&gt; &#123;    return previous + current;  &#125;);&#125;<p>console.log(sum(1, 2, 3));<br>// expected output: 6</p><p>console.log(sum(1, 2, 3, 4));<br>// expected output: 10<br></code></pre></p></div>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
          <category> JavaScript </category>
          
          <category> ECMAScript </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Shadowsocks/ByWave使用总结</title>
      <link href="/blog/qt0mw3de2tcn/"/>
      <url>/blog/qt0mw3de2tcn/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h2 id="9McZr"><span class="ne-text">直连、规则、全局</span></h2><ul class="ne-ul"><li id="c788f73e52a4aefceb0c61f0a7510fb2"><span class="ne-text">直连：没经过节点上网</span></li><li id="151a805aa059514082088d89ac736e27"><span class="ne-text">规则（PAC）：PAC是一个规则文档，文档里面有链接。当你访问PAC文档里面的链接时，使用SSR提供的节点访问（即达到科学上网访问YouTube、Facebook等网站的效果）</span></li><li id="1156e266fd6abf0ac1b775ddef0b01b1"><span class="ne-text">全局：所有网站、数据、都走节点！不管访问什么都是经过的节点，全局模式只适合部分需要全局代理的网站</span></li></ul><h2 id="fVMaT"><span class="ne-text">Vray和SS/SSR有什么区别和联系呢？</span></h2><h2 id="lX0fE"><span class="ne-text">PAC文件编写语法</span></h2><p id="u3b5f74fc" class="ne-p"><span class="ne-text" style="color: #555555">在ShadowsocksR中除了pac.txt文件以外，还会有一个 user-rule.txt 的文件</span><strong><span class="ne-text">（如果没有就新建一个）</span></strong><span class="ne-text" style="color: #555555">，是单独给用户来添加网址规则的</span></p><pre><code>=== 通配符支持 =&gt; **.example.com/ 代表 http://example.com http://233.example.com https://233.example.com https://666.example.com/233.mp4 全部走代理。同时&quot;*&quot;可省略，.example.com/ 与 *.example.com/ 效果是一样的 <p>=== 正则表达式支持<br>以 \ 开始和结束，[\w]+://example.com\</p><p>=== 例外规则 =&gt; @@<br>@@<em>.example.com/ 表示&quot;@@&quot;后面的网址规则(</em>.example.com)不走代理<br>如：@@<a href="http://www.baidu.com/">www.baidu.com</a> 表示 <a href="http://www.baidu.com/">www.baidu.com</a> 不走代理</p><p>=== 匹配地址开始和结尾规则 =&gt; |<br>|<a href="http://example.com、example.com|/">http://example.com、example.com|</a> 分别表示 以<a href="http://example.com开始/">http://example.com开始</a> 和 以example.com结束 的地址<br>如：|<a href="http://233.com/">http://233.com</a> ，代表 <a href="http://233.com/">http://233.com</a> 开头的网址才会走代理，即 <a href="https://233.com/">https://233.com</a> <a href="http://1.233.com/">http://1.233.com</a> 都不会走代理<br>如：233.com|，代表 233.com 结尾的网站才会走代理，即 <a href="http://233.com/">http://233.com</a> <a href="https://233.com/">https://233.com</a> <a href="http://1.233.com/">http://1.233.com</a> 都会走带了，而 <a href="http://233.com/index.html">http://233.com/index.html</a> 不会走代理。</p><p>=== 全匹配规则 =&gt; ||<br>||example.com 则代表 <a href="http://example.com、https//example.com%E3%80%81ftp://example.com">http://example.com、https://example.com、ftp://example.com</a> 等协议的地址全部走代理<br>如：||233.com ，即 <a href="http://233.com、https//233.com%E3%80%81ftp://233.com">http://233.com、https://233.com、ftp://233.com</a> 等地址全都走代理</p><p>=== 注释规则 =&gt; !<br>!我是注释233<br>!我也是注释666<br></code></pre></p><h2 id="4lmZx"><span class="ne-text">PAC记录备份</span></h2><pre><code>! Put user rules line by line in this file.! See https://adblockplus.org/en/filter-cheatsheet||www.typingclub.com||stackedit.io||ma-jinyao.cn||checkio.org||wakatime.com||typingclub.com||app.netlify.com||netlify.com||fontawesome.com||www.ahonn.me||www.microsoftedgeinsider.com||stackoverflow.com||vercel.com</code></pre><h2 id="T1kLn"><span class="ne-text">设置开机自启动</span></h2><p id="a2197a0a5198156fbb36029d008e540e" class="ne-p"><code class="ne-code"><span class="ne-text">WIN+R</span></code><span class="ne-text">  </span><code class="ne-code"><span class="ne-text">regedit </span></code><span class="ne-text"> </span></p><p id="d399ae13b578f8854bfe33bf4dcafefd" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1615343305831-6d2f2028-f9de-4206-a915-da77ba921296.png" width="710" id="BBC2L" class="ne-image"></p><h2 id="9tLq7"><span class="ne-text">开机不开ByWave就不能上网</span></h2><p id="39f32e2eea425bfa0a98d12ceb35087b" class="ne-p"><span class="ne-text">没有开启自动检测设置，但是还有一个问题，就是开了之后，会被自动关掉。</span></p><p id="b7de7533f217ddfe665bb9ca51d4c7b2" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1626050410337-3cb42d6f-65ea-41f3-8a55-68c0dee32e6b.png" width="600" id="tYZfe" class="ne-image"></p><h2 id="csMCq"><span class="ne-text">参考</span></h2><ul class="ne-ul"><li id="u61a4fd7c"><a href="https://tlanyan.pp.ua/shadowsockr-shadowsocksr-shadowsocksrr-clients/" data-href="https://tlanyan.pp.ua/shadowsockr-shadowsocksr-shadowsocksrr-clients/" target="_blank" class="ne-link"><span class="ne-text">ShadowsocksR/SSR客户端</span></a></li></ul></div>]]></content>
      
      
      <categories>
          
          <category> 计算机素养 </category>
          
          <category> 工具使用 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript语言基本知识</title>
      <link href="/blog/uz1d072engtt/"/>
      <url>/blog/uz1d072engtt/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="u3791673d" class="ne-p"><span class="ne-text">前言：JavaScript语言基本知识</span></p><p id="u87631b7c" class="ne-p"><span class="ne-text"></span></p><div class="ne-quote"><ol data-index-type="1" class="ne-ol"><li id="ua38debb9" data-lake-index-type="1"><span class="ne-text">JavaScript编程语言</span></li><li id="uea1c92ee" data-lake-index-type="1"><span class="ne-text">变量</span></li><li id="u2973cf6c" data-lake-index-type="1"><span class="ne-text">基本数据类型</span></li><li id="ua7755087" data-lake-index-type="1"><span class="ne-text">运算符和表达式</span></li><li id="u672bc334" data-lake-index-type="1"><span class="ne-text">语句结构</span></li></ol></div><p id="u8e5dcc83" class="ne-p"><span class="ne-text"></span></p><h2 id="GvevH"><span class="ne-text">一、JavaScript编程语言</span></h2><h3 id="78f3f7ef"><span class="ne-text">解释型语言和编译型语言</span></h3><p id="dfe8e5c763d02ef66ada79c293445101" class="ne-p"><span class="ne-text">计算机不能直接理解任何除机器语言以外的语言，所以必须要把程序员所写的程序语言翻译成机器语言才能执行程序。程序语言翻译成机器语言的工具，被称为翻译器。</span></p><p id="baf5e8aabb77bc62e6171b03a3826398" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611883945965-edfd63f6-b312-4daa-990e-aa7fb8d29640.png" width="307" id="lzaQj" class="ne-image"></p><ul class="ne-ul"><li id="efec4d96acc3487841fe1c20fe326675" data-lake-index-type="0"><span class="ne-text">翻译器翻译的方式有两种：一个是编译，另外一个是解释。两种方式之间的区别在于翻译的时间点不同</span></li><li id="0edde9d3ff6baac0b93441af50cc77b9" data-lake-index-type="0"><span class="ne-text">编译器是在代码执行之前进行编译，生成中间代码文件</span></li><li id="b50497b629bf6d2b0b30059b8084d5f0" data-lake-index-type="0"><span class="ne-text">解释器是在运行时进行及时解释，并立即执行(当编译器以解释方式运行的时候，也称之为解释器)</span></li></ul><div class="ne-quote"><p id="a90f8b7e8fa2b421e01306c42417af73" class="ne-p"><span class="ne-text">执行过程</span></p></div><p id="8091ab085a95f6a5b8e5af75a6cd1c9d" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611883933551-3185c915-4a31-4151-a6c6-9212e11d336c.png" width="412.5" id="Fnw0A" class="ne-image"></p><h3 id="0gbfN"><span class="ne-text">是什么</span></h3><ul class="ne-ul"><li id="b6e3ac0f6e2af3555e1378cb16e6b12f" data-lake-index-type="0"><span class="ne-text">JavaScript 是世界上最流行的语言之一，是一种运行在客户端的脚本语言 （Script == 脚本）</span></li><li id="74f0d8b65f96d7c5a6077f292280f75b" data-lake-index-type="0"><span class="ne-text">脚本语言：不需要编译，运行过程中由 js 解释器( js 引擎）逐行来进行解释并执行</span></li><li id="7b94a21c458ad335dba5acd13541c6b3" data-lake-index-type="0"><span class="ne-text">现在也可以基于 Node.js 技术进行服务器端编程</span></li></ul><h3 id="xeNhG"><span class="ne-text">用途</span></h3><ul class="ne-ul"><li id="bbed77407276a35c0259baced5bd344c" data-lake-index-type="0"><span class="ne-text">表单动态校验（密码强度检测）  （ JS 产生最初的目的 ）</span></li><li id="ace9e3fba9f20d8bab5385aae951bf5a" data-lake-index-type="0"><span class="ne-text">网页特效</span></li><li id="cc0c97ac003fb1af899b9d45c7537186" data-lake-index-type="0"><span class="ne-text">服务端开发(Node.js)</span></li><li id="78616ee8907d689ec18133f86ce622cd" data-lake-index-type="0"><span class="ne-text">桌面程序(Electron)</span></li><li id="891ae8804cc06ed9a64f1ec98c95938f" data-lake-index-type="0"><span class="ne-text">App(Cordova)</span></li><li id="341af114419bf832ccb4fbb8ddec5084" data-lake-index-type="0"><span class="ne-text">控制硬件-物联网(Ruff)</span></li><li id="382a39ab9b42d32c40e55c5bf1140621" data-lake-index-type="0"><span class="ne-text">游戏开发(cocos2d-js)</span></li></ul><h3 id="z0wpQ"><span class="ne-text">浏览器执行JS简介</span></h3><p id="0fb918279dbf616a0b59c4903bdb082d" class="ne-p"><span class="ne-text">浏览器分成两部分：</span></p><ol class="ne-ol"><li id="uf54b5929" data-lake-index-type="0"><span class="ne-text">渲染引擎：用来解析HTML和CSS，俗称内核。比如Chrome浏览器是blink，老版本是webkit。</span></li><li id="u1ba8428a" data-lake-index-type="0"><span class="ne-text">JS引擎：也称JS解释器，用来读取网页中的JavaScript代码，对其处理后运行。比如Chrome的V8引擎。</span></li></ol><div class="ne-quote"><p id="u46e7aee0" class="ne-p"><span class="ne-text">浏览器本身并不会执行JS代码，而是通过内置 JavaScript 引擎(解释器) 来执行 JS 代码 。JS 引擎执行代码时逐行解释每一句源码（转换为机器语言），然后由计算机去执行，所以 JavaScript 语言归为脚本语言，会逐行解释执行。</span></p></div><h3 id="LJtqL"><span class="ne-text">JavaScript的组成</span></h3><p id="3fc8971ef42cf383049a55c071f80223" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611883453712-2dfb6f14-cf77-4475-ad87-5826124bc43f.png" width="412.5" id="nDXwH" class="ne-image"></p><ol class="ne-ol"><li id="9d3fa69f2905f0015a2cb70aada359d8" data-lake-index-type="0"><strong><span class="ne-text">ECMAScript</span></strong></li></ol><p id="ucaa337c7" class="ne-p" style="text-align: left"><span class="ne-text">ECMAScript 是由ECMA 国际（ 原欧洲计算机制造商协会）进行标准化的一门编程语言，这种语言在万维网上应用广泛，它往往被称为 JavaScript或 JScript，但实际上后两者是 ECMAScript 语言的实现和扩展。</span></p><p id="ubaed624f" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611883470657-6e9bb00b-781e-46d3-99e7-64afd35e3758.png" width="420.5" id="TAj2x" class="ne-image"></p><p id="u784a7bfd" class="ne-p" style="text-align: left"><span class="ne-text">ECMAScript：规定了JS的编程语法和基础核心知识，是所有浏览器厂商共同遵守的一套JS语法工业标准。</span></p><ul class="ne-ul"><li id="u22db2333" data-lake-index-type="0" style="text-align: left"><span class="ne-text"></span><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/JavaScript_technologies_overview" data-href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/JavaScript_technologies_overview" target="_blank" class="ne-link"><span class="ne-text">JavaScript 技术概览 - JavaScript | MDN</span></a></li></ul><ol start="2" class="ne-ol"><li id="6211f9bd380f9eab462a26b6f6fa9604" data-lake-index-type="0"><strong><span class="ne-text">DOM——文档对象模型</span></strong></li></ol><p id="u99ef5f32" class="ne-p"><span class="ne-text">文档对象模型（DocumentObject Model，简称DOM），是W3C组织推荐的处理可扩展标记语言的标准编程接口。通过 DOM 提供的接口可以对页面上的各种元素进行操作（大小、位置、颜色等）</span></p><ol start="3" class="ne-ol"><li id="b384e8b17b6138d481f89b860d6065e8" data-lake-index-type="0"><strong><span class="ne-text">BOM——浏览器对象模型</span></strong></li></ol><p id="u6b20ab3d" class="ne-p"><span class="ne-text">浏览器对象模型(Browser Object Model，简称BOM) 是指浏览器对象模型，它提供了独立于内容的、可以与浏览器窗口进行互动的对象结构。通过BOM可以操作浏览器窗口，比如弹出框、控制浏览器跳转、获取分辨率等。</span></p><h2 id="sbNCv"><span class="ne-text">二、变量</span></h2><p id="ub1701346" class="ne-p"><span class="ne-text">“行为怪异的</span><code class="ne-code"><span class="ne-text">var</span></code><span class="ne-text">所造成的各种问题。”</span></p><p id="u38ba7289" class="ne-p" style="text-align: right"><em><span class="ne-text">《JavaScript高级程序设计》</span></em></p><h3 id="VtQxt"><span class="ne-text">var和let和const</span></h3><p id="9fae286a19ede0132a5a1a12ac0f7401" class="ne-p" style="text-align: center"><strong><span class="ne-text">【var】</span></strong></p><ul class="ne-ul"><li id="4b18ac66fd11eb63fce31132e08e6905" data-lake-index-type="0"><span class="ne-text">在全局区域声明是全局变量</span></li><li id="4e7c5fcdfd99152eca107eed7dd2c013" data-lake-index-type="0"><span class="ne-text">在</span><strong><span class="ne-text">函数里面</span></strong><span class="ne-text">用var声明变量的时候是局部变量，但是省略var的时候，就变成全局变量了（坑……），好在严格模式下如果在函数里面这样定义会报错</span></li></ul><p id="17bbb693bcc03ecc288ff17db9c2b30b" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1617867733497-db043164-d28e-48e8-8bd7-2a9b1d30203a.png" width="394.5" id="HzdsA" class="ne-image"></p><ul class="ne-ul"><li id="f638dd23fb3b1540a05cdda9e79b177e" data-lake-index-type="0"><span class="ne-text">会变量提升，把所有变量声明都拉到函数作用域的顶部，所以在同一个域里面，var定义的变量，先使用在定义也是可以的。</span></li><li id="dc244b9f34ceed5f0b4fcbf3b5281c0e" data-lake-index-type="0"><span class="ne-text">可以多次定义赋值</span></li></ul><span style="margin-left: 2em"><pre><code><code>var i = 0;var i = 0;</code></code></pre></span><div class="ne-quote"><p id="u20eab999" class="ne-p"><span class="ne-text">编写代码不建议使用var来定义变量了</span></p></div><p id="e8254d958e99a0d08ff6ffaeffa7e111" class="ne-p" style="text-align: center"><strong><span class="ne-text">【let】</span></strong></p><ul class="ne-ul"><li id="25474a0c4d77e48d0a4a46a7e38d27e7" data-lake-index-type="0"><span class="ne-text">作用范围：块作用域</span></li><li id="a9afcf6c118af8e2fe38d77d6230ec3e" data-lake-index-type="0"><span class="ne-text">会有冗余声明（不可以多次定义赋值）</span></li><li id="1fb550c75ddb693e76698978e23d9141" data-lake-index-type="0"><span class="ne-text">不会变量提升，俗称“暂时性死区”</span></li></ul><p id="37bbef0fa25eda71ada360f4d91b4231" class="ne-p" style="text-align: center"><strong><span class="ne-text">【const】</span></strong></p><ul class="ne-ul"><li id="067ab39a534217f79f6adff89fa3f32e" data-lake-index-type="0"><span class="ne-text">作用范围：块作用域</span></li><li id="33666ea26ba42487b84cef5e601af45c" data-lake-index-type="0"><strong><span class="ne-text">声明变量必须同时初始化变量</span></strong></li><li id="49f0d13a0b574d6cec237d487a23784f" data-lake-index-type="0"><span class="ne-text">不允许重复声明</span></li><li id="8399546d375b0568936129626249f4d2" data-lake-index-type="0"><span class="ne-text">尝试修改变量的值报错，但对对象操作就不一样了</span></li></ul><p id="0fb976da70fae316328a15fdcc8511cf" class="ne-p" style="text-align: left"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1617866749694-8c13df91-894d-41ba-a6bf-4545875594be.png" width="450" id="Tyu1F" class="ne-image"></p><div class="ne-quote"><p id="udebd39a1" class="ne-p" style="text-align: left"><span class="ne-text">使用建议：参照《JavaScript高级程序设计》书中所说的，“不使用var，const优先，let次之”。</span></p></div><h3 id="hadaa"><span class="ne-text">作用域链</span></h3><p id="9b06e3ef24f988cbf5ada73473af0ca6" class="ne-p"><span class="ne-text">因为var可以多次声明这一个特点，就产生出了一个问题，在函数里面声明一个变量，在函数外也声明一个同名的变量，就会导致接下来的代码使用哪一个变量的情况。分析是哪个其实也好办，就是看调用的这个函数离哪个声明的变量最近，哪个最近取哪个。</span></p><p id="80a50768986d03c2f827454471ac74cd" class="ne-p"><br></p><p id="479e3709bd121f8ec83beb8b71dc79d6" class="ne-p"><strong><span class="ne-text">作用域链有其解决的办法，那就是利用作用域链，但是使用let和const更为方便</span></strong><span class="ne-text">。</span></p><p id="866735ea735d526fbf4227849f23cc2a" class="ne-p"><br></p><p id="3f19ead06d1fb42b98104cf2befdb5c8" class="ne-p"><span class="ne-text">比如：循环迭代过程中</span></p><p id="7fbe1e43dfcc7c2fb50235c53d85c645" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1617867856859-e30d58a7-ff23-4c94-9690-fa18931b1274.png" width="465" id="R0mLn" class="ne-image"></p><h3 id="QYvRI"><span class="ne-text">预解析和代码执行</span></h3><p id="cef513c0880c7435eacf92f0c844c35a" class="ne-p"><span class="ne-text">浏览器的js解析器当中，会将js代码分两步执行，分别为，预解析和执行代码</span></p><ul class="ne-ul"><li id="d4260e8a8c85ebc367a453db9e9eccab" data-lake-index-type="0"><span class="ne-text">预解析：在当前作用域下, JS 代码执行之前，浏览器会默认把带有 var 和 function 声明的变量在内存中进行提前声明或者定义</span></li><li id="41fa0c517abcb568eeaf0e218d77268a" data-lake-index-type="0"><span class="ne-text">代码执行： 从上到下执行JS语句</span></li></ul><h2 id="jdb6i"><span class="ne-text">三、基本数据类型</span></h2><h3 id="9G5W7"><span class="ne-text">8种数据类型</span></h3><p id="u37098d42" class="ne-p"><span class="ne-text">最新的 ECMAScript 标准定义了 8 种数据类型：</span></p><p id="ue28e7477" class="ne-p"><span class="ne-text">七种基本</span><strong><span class="ne-text">数据类型</span></strong><span class="ne-text">：</span></p><ol class="ne-ol"><li id="ua013e174" data-lake-index-type="0"><span class="ne-text">数字（Number），整数或浮点数，例如： 42 或者 3.14159。</span></li><li id="uccbc3168" data-lake-index-type="0"><span class="ne-text">字符串（String），字符串是一串表示文本值的字符序列，例如：&quot;Howdy&quot; 。</span></li><li id="ue088a993" data-lake-index-type="0"><span class="ne-text">布尔值（Boolean），有 2 个值分别是：true 和 false.</span></li><li id="u3572ac18" data-lake-index-type="0"><span class="ne-text">undefined，和 null 一样是一个特殊的关键字，undefined 表示变量未赋值时的属性。</span></li><li id="ued1c40bf" data-lake-index-type="0"><span class="ne-text">null，一个表明 null 值的特殊关键字。JavaScript 是大小写敏感的，因此 null 与 Null、NULL或变体完全不同。</span></li><li id="u5be4096e" data-lake-index-type="0"><span class="ne-text">任意精度的整数 (BigInt) ，可以安全地存储和操作大整数，甚至可以超过数字的安全整数限制。</span></li><li id="ua1cd9dd7" data-lake-index-type="0"><span class="ne-text">代表（Symbol）( 在 ECMAScript 6 中新添加的类型).。一种实例是唯一且不可改变的数据类型。</span></li><li id="ud9a201d8" data-lake-index-type="0"><span class="ne-text">以及对象（Object）。</span></li></ol><h3 id="z9IHQ"><span class="ne-text">自动确定类型机制</span></h3><p id="u43a2602d" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/1484158/1702283370849-5ee79395-d1c2-4840-8738-009af352cc4b.jpeg" width="237" id="uc0b3bc8e" class="ne-image"></p><p id="f4e0edcd3e3d01abbabd141904c255ce" class="ne-p"><span class="ne-text">JavaScript 是一种弱类型或者说动态语言。这意味着不用提前声明变量的类型，在程序运行过程中，类型会被自动确定，这是和Java基本类型不同的一点。</span></p><pre><code><code>let age = 10;        // 这是一个数字型let forsome= '是的';   // 这是一个字符串</code></code></pre><p id="68f2c4303a2a1c7c967ae54726fa8a2b" class="ne-p"><span class="ne-text">在代码运行时，变量的数据类型是由 </span><strong><span class="ne-text">JS引擎</span></strong><span class="ne-text"> 根据 = 右边变量值的数据类型来判断 的，运行完毕之后， 变量就确定了数据类型。</span><strong><span class="ne-text">JavaScript 拥有动态类型，同时也意味着相同的变量可用作不同的类型</span></strong></p><p id="u4fcaf1dd" class="ne-p"><strong><span class="ne-text"></span></strong></p><ul class="ne-ul"><li id="u1b11f3ee" data-lake-index-type="0"><a href="https://vue3js.cn/interview/JavaScript/type_conversion.html" data-href="https://vue3js.cn/interview/JavaScript/type_conversion.html" class="ne-link"><span class="ne-text">面试官：谈谈 JavaScript 中的类型转换机制 | web前端面试 - 面试官系列</span></a></li></ul><h3 id="e674dc88"><span class="ne-text">number</span></h3><ol class="ne-ol"><li id="uffa4eba5" data-lake-index-type="0"><span class="ne-text">Infinity和NaN是JavaScript语言的全局属性（</span><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects#%E5%80%BC%E5%B1%9E%E6%80%A7" data-href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects#%E5%80%BC%E5%B1%9E%E6%80%A7" class="ne-link"><span class="ne-text">JavaScript 标准内置对象 - JavaScript | MDN</span></a><span class="ne-text">）</span></li><li id="u352bb2ed" data-lake-index-type="0"><span class="ne-text">JavaScript 数字类型既可以保存整数，也可以保存小数(浮点数）</span></li></ol><span style="margin-left: 2em"><table id="ql3SS" class="ne-table" style="width: 660px"><tbody><tr style="height: 37px"><td width="193"><p id="5e45ec84827cfb9f97c75aaa08781710" class="ne-p"><span class="ne-text">Number.MAX_VALUE</span></p></td><td width="467"><p id="130e7f32aae07295c8a98efa9a3ce6aa" class="ne-p"><span class="ne-text">最大值</span></p></td></tr><tr style="height: 37px"><td width="193"><p id="547b64fb9d070428f592b37d63f975e8" class="ne-p"><span class="ne-text">Number.MIN_VALUE</span></p></td><td width="467"><p id="42f20137ee9e7a5dd3f5f41057fcba2f" class="ne-p"><span class="ne-text">最小值</span></p></td></tr><tr style="height: 33px"><td width="193"><p id="fe06105b5e515933087c9deb23103db7" class="ne-p"><span class="ne-text">Infinity </span></p></td><td width="467"><p id="5ba9e08ee4e145a5117ac331037ba95f" class="ne-p"><span class="ne-text">正无穷大  </span></p><p id="ua6e75604" class="ne-p"><span class="ne-text">【</span><code class="ne-code"><span class="ne-text">Number.MAX_VALUE</span></code><span class="ne-text"> </span><code class="ne-code"><span class="ne-text">&lt;</span></code><span class="ne-text"> </span><code class="ne-code"><span class="ne-text">Infinity</span></code><span class="ne-text">】</span></p></td></tr><tr style="height: 33px"><td width="193"><p id="u2b29095d" class="ne-p"><span class="ne-text" style="color: #404040">-Infinity</span></p></td><td width="467"><p id="d6ced9d7c04c424000c39e75d0418591" class="ne-p"><span class="ne-text">负无穷大</span></p></td></tr><tr style="height: 33px"><td width="193"><p id="uafd41328" class="ne-p"><span class="ne-text" style="color: #404040">NaN </span></p></td><td width="467"><p id="40671c008d6bc06d52333a8258445105" class="ne-p"><span class="ne-text">非数值</span></p></td></tr></tbody></table></span><h3 id="uY2n4"><span class="ne-text">string</span></h3><ol class="ne-ol"><li id="uf8cb8fdf" data-lake-index-type="0"><span class="ne-text">字符串长度：通过字符串的 length 属性可以获取整个字符串的长度。</span></li></ol><div data-type="color3" class="ne-alert"><p id="u0a6e2127" class="ne-p"><span class="ne-text">Java里面基本数据类型比如定义了一串字符，是没有相应长度length属性一说的，除非new一个字符的对象。JavaScript里面也有相应的机制，称之为——</span><strong><span class="ne-text">“包装对象”</span></strong><span class="ne-text">，可以直接使用length属性，指的是与数值、字符串、布尔值分别相对应的Number、String、Boolean三个原生对象。这三个原生对象可以把原始类型的值变成（包装成）对象，和Java里面一样。</span></p></div><ol start="2" class="ne-ol"><li id="u606f5f7f" data-lake-index-type="0"><span class="ne-text">转义符</span></li></ol><span style="margin-left: 2em"><table id="VgS2L" class="ne-table" style="width: 750px"><tbody><tr style="height: 33px"><td width="375"><p id="ue9877b5d" class="ne-p"><span class="ne-text">转义符</span></p></td><td width="375"><p id="u6a61842a" class="ne-p"><span class="ne-text">解释说明</span></p></td></tr><tr style="height: 33px"><td width="375"><p id="u44aeffdc" class="ne-p"><span class="ne-text">\n</span></p></td><td width="375"><p id="ue5100e5b" class="ne-p"><span class="ne-text">换行符，n   是   newline   的意思</span></p></td></tr><tr style="height: 33px"><td width="375"><p id="u73f7d0d8" class="ne-p"><span class="ne-text">\ \</span></p></td><td width="375"><p id="ue5964408" class="ne-p"><span class="ne-text">斜杠   \</span></p></td></tr><tr style="height: 33px"><td width="375"><p id="udd88e141" class="ne-p"><span class="ne-text">'</span></p></td><td width="375"><p id="u88cc2fc6" class="ne-p"><span class="ne-text">'   单引号</span></p></td></tr><tr style="height: 33px"><td width="375"><p id="uc84de0ce" class="ne-p"><span class="ne-text">&quot;</span></p></td><td width="375"><p id="ubebb2834" class="ne-p"><span class="ne-text">”双引号</span></p></td></tr><tr style="height: 33px"><td width="375"><p id="ubb8ae444" class="ne-p"><span class="ne-text">\t</span></p></td><td width="375"><p id="u1588ec72" class="ne-p"><span class="ne-text">tab  缩进</span></p></td></tr><tr style="height: 33px"><td width="375"><p id="u93eb6780" class="ne-p"><span class="ne-text">\b</span></p></td><td width="375"><p id="u3dca8f38" class="ne-p"><span class="ne-text">空格 ，b   是   blank  的意思</span></p></td></tr></tbody></table></span><h3 id="OHZAa"><span class="ne-text">boolean</span></h3><ol class="ne-ol"><li id="ua0bd2387" data-lake-index-type="0"><span class="ne-text">布尔类型有两个值：true 和 false ，其中 true 表示真（对），而 false 表示假（错）。</span></li><li id="u873a590f" data-lake-index-type="0"><span class="ne-text">布尔型和数字型相加的时候， true 的值为 1 ，false 的值为 0。</span></li></ol><span style="margin-left: 2em"><pre><code><code>console.log(true + 1);  // 2console.log(false + 1); // 1</code></code></pre></span><h3 id="NxgS8"><span class="ne-text">undefined</span></h3><p id="u120178cf" class="ne-p"><span class="ne-text">一个声明未定义的变量的初始值，或没有实际参数的形式参数。</span></p><h3 id="QbygZ"><span class="ne-text">null</span></h3><ol class="ne-ol"><li id="u462b6834" data-lake-index-type="0"><span class="ne-text">null是一个表示“空”的对象，转为数值时为0</span></li><li id="u7af936ac" data-lake-index-type="0"><span class="ne-text">undefined是一个表示”此处无定义”的原始值，转为数值时为NaN</span></li></ol><h3 id="CaEwI"><span class="ne-text">symbol</span></h3><p id="u384a037d" class="ne-p"><span class="ne-text">使用场景：</span></p><ol class="ne-ol"><li id="u2097b6ad" data-lake-index-type="0"><span class="ne-text">定义一组常量来代表一种业务逻辑下的几个不同类型。</span></li><li id="uf36be47d" data-lake-index-type="0"><span class="ne-text">如果做为对象的键，那么这个的keys遍历键是会略过symbol类型的键的，这一点可以用来构造一些复杂数据结构，比如设置不太想让外部用到的键遍历。</span></li></ol><h3 id="R1UJS"><span class="ne-text">数据类型判断及转换</span></h3><ul class="ne-ul"><li id="u7a09a07d" data-lake-index-type="0"><span class="ne-text">数据类型的几种判断方法</span></li></ul><table id="fsXa0" class="ne-table" style="width: 749px"><tbody><tr style="height: 33px"><td width="374" style="background-color: #E7E9E8"><p id="u27a9cecd" class="ne-p" style="text-align: center"><span class="ne-text">判断方法</span></p></td><td width="375" style="background-color: #E7E9E8"><p id="ue4a346c2" class="ne-p" style="text-align: center"><span class="ne-text">缺点</span></p></td></tr><tr style="height: 36px"><td width="374"><p id="u24b60e2a" class="ne-p" style="text-align: center"><span class="ne-text">typeof</span></p></td><td width="375"><p id="u45b05ac7" class="ne-p"><span class="ne-text">不能判断null和区分array/Date/RegExp等</span></p></td></tr><tr style="height: 33px"><td width="374"><p id="u42cc41a4" class="ne-p" style="text-align: center"><span class="ne-text">instanceof</span></p></td><td width="375"><p id="ua2aeaf53" class="ne-p"><span class="ne-text">无法检测null和undefined，未必准确，无法判断字面量方式创建的基本数据类型</span></p></td></tr><tr style="height: 33px"><td width="374"><p id="ueb1c0103" class="ne-p" style="text-align: center"><span class="ne-text">constructor</span></p></td><td width="375"><p id="u0df86cfe" class="ne-p"><span class="ne-text">无法检测null和undefined，未必准确</span></p></td></tr><tr style="height: 33px"><td width="374"><p id="u00281da6" class="ne-p" style="text-align: center"><span class="ne-text">Object.prototype.toString.call()</span></p></td><td width="375"><p id="u938ab9ee" class="ne-p" style="text-align: center"><span class="ne-text">无</span></p></td></tr></tbody></table><div class="ne-quote"><p id="u2a31b220" class="ne-p"><span class="ne-text"></span><a href="https://www.jianshu.com/p/6f3087a44d83" data-href="https://www.jianshu.com/p/6f3087a44d83" class="ne-link"><span class="ne-text">JS类型判断typeof、instanceof、constructor、Object.prototype.toString.call()</span></a></p></div><ul class="ne-ul"><li id="u33fbcbe4" data-lake-index-type="0"><span class="ne-text">数据类型的转换</span></li></ul><p id="b1017f65214934b4aa69112b1dafbfb4" class="ne-p"><span class="ne-text">使用表单、prompt 获取过来的数据默认是字符串类型的，此时就不能直接简单的进行加法运算，而需要转换变量的数据类型</span></p><div class="ne-quote"><p id="8341bc266f56864d5ebbd96ad4fb6bb1" class="ne-p"><span class="ne-text">当参数为： ''、0、NaN、null、undefined，转换为false，其他都转换称true</span></p></div><h2 id="tw29Y"><span class="ne-text">四、运算符和表达式</span></h2><h3 id="Bzl1R"><span class="ne-text">基本运算符</span></h3><ul class="ne-ul"><li id="f93a4d541ac032e85efecb51275eca2a" data-lake-index-type="0"><span class="ne-text">+-*/%：数学运算符</span></li><li id="45ad3a1c4eba1e3e77045d304fc99c4e" data-lake-index-type="0"><span class="ne-text">++：自增运算符（注意i++和++i区别）</span></li><li id="899c1722e0db3cd3873805589e5d266f" data-lake-index-type="0"><span class="ne-text">==、===：区别就是后者要求值和数据类型都相等，前者只要求值</span></li></ul><ul class="ne-ul"><li id="ucf25a710" data-lake-index-type="0"><span class="ne-text">&amp;&amp;、||、!：与或非</span></li><li id="u7797fdf0" data-lake-index-type="0"><span class="ne-text">!!：将值转换为Boolean类型</span></li></ul><h3 id="y1rv4"><span class="ne-text">位移运算符</span></h3><ul class="ne-ul"><li id="u2b2ce3c4" data-lake-index-type="0"><span class="ne-text">&lt;&lt;：按位左移</span></li><li id="u61a28b66" data-lake-index-type="0"><span class="ne-text">&gt;&gt;：按位右移</span></li><li id="u7064ed3c" data-lake-index-type="0"><span class="ne-text">&gt;&gt;&gt;：按位无符号右移</span></li></ul><div class="ne-quote"><p id="u398a3c2e" class="ne-p"><a href="https://juejin.cn/post/6844903568906911752" data-href="https://juejin.cn/post/6844903568906911752" class="ne-link"><span class="ne-text">位运算符在JS中的妙用 - 掘金</span></a></p></div><h3 id="lyYmP"><span class="ne-text">二进制位运算符</span></h3><ul class="ne-ul"><li id="u48e7d71b" data-lake-index-type="0"><span class="ne-text">&amp;：按位与</span></li><li id="u194d77bb" data-lake-index-type="0"><span class="ne-text">|：按位或</span></li></ul><div data-type="success" class="ne-alert"><p id="u4053004f" class="ne-p"><span class="ne-text">两边转换为二进制进行相加得到后的结果</span></p><p id="u6dbcb06a" class="ne-p"><strong><span class="ne-text">技巧</span></strong><span class="ne-text">：Number|0 将Number取整</span></p><p id="u853ad154" class="ne-p"><span class="ne-text">Number为正数的时候，相当于向下取整，Math.floor()。console.log(1.1|0) // 1</span></p><p id="u68246772" class="ne-p"><span class="ne-text">Number为负数的时候，相当于向上取整，Math.ceil()。console.log(-5.22|0) // -5</span></p></div><ul class="ne-ul"><li id="ue2af4b99" data-lake-index-type="0"><span class="ne-text">～：按位非</span></li></ul><div data-type="info" class="ne-alert"><p id="u3050752b" class="ne-p"><span class="ne-text">按位取反（eg：00000001 -&gt; 11111110）</span></p></div><ul class="ne-ul"><li id="uf318837f" data-lake-index-type="0"><span class="ne-text">^：按位异或</span></li></ul><h3 id="LUwhr"><span class="ne-text">二元逻辑运算符</span></h3><ul class="ne-ul"><li id="u7648e9ab" data-lake-index-type="0"><span class="ne-text">逻辑与：存在假则返回假的值，否则返回最后一个值</span></li></ul><span style="margin-left: 2em"><pre><code><code>console.log( 123 &amp;&amp; 456 );        // 456console.log( 0 &amp;&amp; 456 );          // 0console.log( 123 &amp;&amp; 456&amp;&amp; 789 );  // 789</code></code></pre></span><ul class="ne-ul"><li id="uf16b3c2a" data-lake-index-type="0"><span class="ne-text">逻辑或：返回最先为真的值</span></li></ul><span style="margin-left: 2em"><pre><code><code>console.log( 123 || 456 );         //  123console.log( 0 ||  456 );          //  456console.log( 123 || 456 || 789 );  //  123</code></code></pre></span><ul class="ne-ul"><li id="u243c9708" data-lake-index-type="0"><span class="ne-text">空值合并运算符：当前面的值为null或者undefined时，取后面的值，否则取前面的值</span></li></ul><span style="margin-left: 2em"><pre><code><code>console.log(55 ?? 66)console.log(false ?? 66)<p>interface Customer &#123;<br>  name: string<br>  city?: string<br>&#125;<br>let customer: Customer = &#123;<br>  name: ‘xiaoming’,<br>  city: ‘jiangxi’<br>&#125;<br>console.log(customer?.city)<br>let customerCity = customer?.city ?? ‘Unknown city’</p><p>console.log(customerCity)</code><br></code></pre><br></span><span style="margin-left: 2em"></p><pre><code><code>55falsejiangxijiangxi</code></code></pre><p></span><h3 id="ysIVH"><span class="ne-text">可选链运算符</span></h3><ul class="ne-ul"><li id="u4211c0bb" data-lake-index-type="0"><span class="ne-text">可选链</span><code class="ne-code"><span class="ne-text">?.</span></code><span class="ne-text">：类似判断条件是否存在</span></li></ul><h3 id="kM7kT"><span class="ne-text">赋值运算符</span></h3><ul class="ne-ul"><li id="u1bf81056" data-lake-index-type="0"><span class="ne-text">&gt;&gt;=：右位移复制</span></li><li id="u1a2f02c4" data-lake-index-type="0"><span class="ne-text">……</span></li></ul><h3 id="qhNAq"><span class="ne-text">逗号运算符</span></h3><p id="u3dc5f080" class="ne-p"><span class="ne-text">逗号（,）运算符对它的每个操作数从左到右求值，并返回最后一个操作数的值。这让你可以创建一个复合表达式，其中多个表达式被评估，复合表达式的最终值是其成员表达式中最右边的值。这通常用于为 for 循环提供多个参数。</span></p><h2 id="u2gBR"><span class="ne-text">五、语句结构</span></h2><h3 id="cD1tY"><span class="ne-text">顺序结构</span></h3><p id="0409ac153792ff51d807e66eb5bba5bd" class="ne-p"><span class="ne-text">浏览器引擎对js代码是从上往下依次执行的</span></p><p id="u192c8656" class="ne-p"><span class="ne-text">所以js代码的位置，以及代码与代码相互依赖的关系顺序都要注意。</span></p><h3 id="9PsRD"><span class="ne-text">选择结构</span></h3><ul class="ne-ul"><li id="udf8d2421" data-lake-index-type="0"><span class="ne-text">if…else</span></li></ul><ul class="ne-ul"><li id="u56d34b10" data-lake-index-type="0"><span class="ne-text">switch 语句</span></li></ul></p><pre><code><code>switch( 表达式 )&#123;   case value1:    // 表达式 等于 value1 时要执行的代码    break;  case value2:    // 表达式 等于 value2 时要执行的代码    break;  default:    // 表达式 不等于任何一个 value 时要执行的代码&#125;</code></code></pre><p id="u4bd4c086" class="ne-p"><br></p><ul class="ne-ul"><li id="u8844da52" data-lake-index-type="0"><span class="ne-text">三元表达式：条件赋值语句 = 赋值语句 + </span><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Conditional_Operator" data-href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Conditional_Operator" target="_blank" class="ne-link"><span class="ne-text">条件（三元）运算符</span></a></li></ul><pre><code><code>// 如果row为true则this.actFormOptions.modelObject.assign(&#123;&#125;, toShowActFromData(row))this.actFormOptions.model = row ? Object.assign(&#123;&#125;, toShowActFromData(row)) : getColumnFormModel(actColumns, defaultActProp)</code></code></pre><h3 id="69bdc66b"><span class="ne-text">循环结构</span></h3><p id="9f5fc0154d98d39318addfb18498bc71" class="ne-p"><span class="ne-text">和Java一样都有，都有for(){}、while(){}、do{}while()三种结构，以及continue、break两个关键字，用法完全一样，在java里面有增强的for循环一说，js也有相应的增强的for循环。</span></p><ul class="ne-ul"><li id="u037b4460" data-lake-index-type="0"><span class="ne-text">while</span></li><li id="u1c7152ca" data-lake-index-type="0"><span class="ne-text">do...while</span></li><li id="uce78aabc" data-lake-index-type="0"><span class="ne-text">for</span></li><li id="u6c150343" data-lake-index-type="0"><span class="ne-text">for-in语句</span></li></ul><p id="452de57e58a327227019f0d17ff0183e" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1622620171596-8dc93211-66d7-4bff-aa7a-f0a1f25fef6b.png" width="175.99542236328125" id="hh3nm" class="ne-image"></p><ul class="ne-ul"><li id="uc84c48fd" data-lake-index-type="0"><span class="ne-text">for-of语句</span></li><li id="u3d388379" data-lake-index-type="0"><span class="ne-text">for await...of</span></li></ul><p id="aa3e67f4cc97321006824c1ec232217e" class="ne-p"><span class="ne-text">遍历可迭代对象的元素</span></p><h3 id="tmayl"><span class="ne-text">其他</span></h3><h4 id="fuUcy"><span class="ne-text">throw</span></h4><p id="u5413684c" class="ne-p"><span class="ne-text">抛出一个用户定义的异常。</span></p><h4 id="w3gQu"><span class="ne-text">try...catch</span></h4><p id="ua0d7cb68" class="ne-p"><span class="ne-text">标记一个语句块，并指定一个应该抛出异常的反馈。</span></p></div>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
          <category> JavaScript </category>
          
          <category> ECMAScript </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CSS定位</title>
      <link href="/blog/qfka5bkr6swg/"/>
      <url>/blog/qfka5bkr6swg/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h2 id="65gks"><span class="ne-text">CSS 布局的三种机制</span></h2><div class="ne-quote"><p id="724554c70ac42551b74ef2ad8d363e1b" class="ne-p"><span class="ne-text">网页布局的核心 —— 就是</span><strong><span class="ne-text">用 CSS 来摆放盒子位置</span></strong><span class="ne-text">。</span></p><p id="u7a88283e" class="ne-p"><span class="ne-text">CSS 提供了 </span><strong><span class="ne-text">3 种机制</span></strong><span class="ne-text">来设置盒子的摆放位置，分别是</span><strong><span class="ne-text">普通流</span></strong><span class="ne-text">、</span><strong><span class="ne-text">浮动</span></strong><span class="ne-text">和</span><strong><span class="ne-text">定位</span></strong></p></div><p id="edae316fcfc6158bd65d60d946024894" class="ne-p"><br></p><div class="ne-quote"><p id="fc10cf71c968792f8eb87c32b43e6f85" class="ne-p"><strong><span class="ne-text">【1】普通流</span></strong><span class="ne-text">（</span><strong><span class="ne-text">标准流</span></strong><span class="ne-text">）</span></p></div><p id="3f9dd38c6447fc6c09f3dd9500607afb" class="ne-p"><span class="ne-text">可以让盒子上下排列或者左右排列的</span></p><ul class="ne-ul"><li id="67c6f632b995ef4e73b5da3b8df402f4"><strong><span class="ne-text">块级元素</span></strong><span class="ne-text">会独占一行，</span><strong><span class="ne-text">从上向下</span></strong><span class="ne-text">顺序排列；</span></li></ul><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="236edbcb61b399e70ad3194cb8d9a86b"><span class="ne-text">常用元素：div、hr、p、h1~h6、ul、ol、dl、form、table</span></li></ul></ul><ul class="ne-ul"><li id="b00c5bdcfcc9cd9db53ec08d59915754"><strong><span class="ne-text">行内元素</span></strong><span class="ne-text">会按照顺序，</span><strong><span class="ne-text">从左到右</span></strong><span class="ne-text">顺序排列，碰到父元素边缘则自动换行；</span></li></ul><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="d9242960895707a6b9b775a1a1ad63ec"><span class="ne-text">常用元素：span、a、i、em等</span></li></ul></ul><div class="ne-quote"><p id="4f6393051ded8ff63cd5fd82a39ec378" class="ne-p"><strong><span class="ne-text">【2】浮动</span></strong></p></div><ul class="ne-ul"><li id="262eb5b768fb1615537d8abababdd540"><span class="ne-text">让盒子从普通流中</span><strong><span class="ne-text">浮</span></strong><span class="ne-text">起来 —— </span><strong><span class="ne-text">让多个盒子(div)水平排列成一行</span></strong><span class="ne-text">。</span></li><li id="66d451cdcf0680dd5cc3a742f884026b"><span class="ne-text">可以让多个块级元素一行显示  或者 左右对齐盒子   浮动的盒子就是按照顺序左右排列</span></li></ul><div class="ne-quote"><p id="021ee711bb151487bf712b1151a748ca" class="ne-p"><strong><span class="ne-text">【3】定位</span></strong></p></div><ul class="ne-ul"><li id="cb03fe93167fc6d2ec6dca88dcdfa83b"><span class="ne-text">将盒子</span><strong><span class="ne-text">定</span></strong><span class="ne-text">在某一个</span><strong><span class="ne-text">位</span></strong><span class="ne-text">置  自由的漂浮在其他盒子的上面  —— CSS 离不开定位，特别是后面的 js 特效。</span></li><li id="27aec920a4f380f1ed132b42a2a94692"><span class="ne-text">定位最大的特点是有层叠的概念，就是可以让多个盒子 前后 叠压来显示。 但是每个盒子需要测量数值。</span></li></ul><div class="ne-quote"><p id="0f2e6d737c0e906ac7244974bc7863f6" class="ne-p"><strong><span class="ne-text">【结论】</span></strong></p><ul class="ne-ul"><li id="346e0171743956d8d8b703fd72d6dd99"><span class="ne-text">标准流在最底层</span></li><li id="177921ad9727a25b32380ebf22ae4b17"><span class="ne-text">浮动的盒子在中间层</span></li><li id="4c29b0f39bc0ecb42d635fd4ef44d211"><span class="ne-text">定位的盒子在最上层</span></li></ul></div><h2 id="d1Y7J"><span class="ne-text">定位详解</span></h2><p id="f1fa9f746a60f81ef735ba80db36f1c6" class="ne-p"><span class="ne-text">定位也是用来布局的，它有两部分组成：</span></p><div class="ne-quote"><p id="7ecc134c80772b1ce6c928226e3c90d2" class="ne-p"><code class="ne-code"><span class="ne-text" style="background-color: #FADB14">定位 = 定位模式 + 边偏移</span></code></p></div><p id="455389d2b88fdf8ad77ac3ada964412c" class="ne-p" style="text-align: center"><span class="ne-text" style="background-color: #FADB14"><br /></span><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611552456483-b258a0b4-d5e2-43ab-af99-f6eef921bacb.png" width="301" id="tPuDD" class="ne-image"></p><h3 id="1K2Ri"><span class="ne-text">边偏移</span></h3><p id="fb261a241352e64819d572aaba30815c" class="ne-p"><span class="ne-text">简单说， 我们定位的盒子，是通过边偏移来移动位置的。</span></p><p id="1267830c67568ad54390c8d1384f4023" class="ne-p"><span class="ne-text">在 CSS 中，通过 </span><code class="ne-code"><span class="ne-text">top</span></code><span class="ne-text">、</span><code class="ne-code"><span class="ne-text">bottom</span></code><span class="ne-text">、</span><code class="ne-code"><span class="ne-text">left</span></code><span class="ne-text"> 和 </span><code class="ne-code"><span class="ne-text">right</span></code><span class="ne-text"> 属性定义元素的</span><strong><span class="ne-text">边偏移</span></strong><span class="ne-text">：（方位名词）</span></p><table id="kZb6M" class="ne-table" style="width: 750px"><tbody><tr style="height: 33px"><td width="250"><p id="uf0893d0e" class="ne-p"><span class="ne-text">边偏移属性</span></p></td><td width="250"><p id="u5b47e94c" class="ne-p" style="text-align: left"><span class="ne-text">示例</span></p></td><td width="250"><p id="u35c861a2" class="ne-p"><span class="ne-text">描述</span></p></td></tr><tr style="height: 33px"><td width="250"><p id="ueaaffd79" class="ne-p"><code class="ne-code"><span class="ne-text">top</span></code></p></td><td width="250"><p id="uf9b7c0f0" class="ne-p" style="text-align: left"><code class="ne-code"><span class="ne-text">top: 80px</span></code></p></td><td width="250"><p id="u3bfeb26f" class="ne-p"><strong><span class="ne-text">顶端</span></strong><span class="ne-text">偏移量，定义元素相对于其父元素</span><strong><span class="ne-text">上边线的距离</span></strong><span class="ne-text">。</span></p></td></tr><tr style="height: 33px"><td width="250"><p id="u0fae95fb" class="ne-p"><code class="ne-code"><span class="ne-text">bottom</span></code></p></td><td width="250"><p id="u366ababc" class="ne-p" style="text-align: left"><code class="ne-code"><span class="ne-text">bottom: 80px</span></code></p></td><td width="250"><p id="u41d2f3a2" class="ne-p"><strong><span class="ne-text">底部</span></strong><span class="ne-text">偏移量，定义元素相对于其父元素</span><strong><span class="ne-text">下边线的距离</span></strong><span class="ne-text">。</span></p></td></tr><tr style="height: 33px"><td width="250"><p id="u6fa5efd3" class="ne-p"><code class="ne-code"><span class="ne-text">left</span></code></p></td><td width="250"><p id="u321cec7e" class="ne-p" style="text-align: left"><code class="ne-code"><span class="ne-text">left: 80px</span></code></p></td><td width="250"><p id="u6b20a4a7" class="ne-p"><strong><span class="ne-text">左侧</span></strong><span class="ne-text">偏移量，定义元素相对于其父元素</span><strong><span class="ne-text">左边线的距离</span></strong><span class="ne-text">。</span></p></td></tr><tr style="height: 33px"><td width="250"><p id="ud83f9f2f" class="ne-p"><code class="ne-code"><span class="ne-text">right</span></code></p></td><td width="250"><p id="ube9a64bf" class="ne-p" style="text-align: left"><code class="ne-code"><span class="ne-text">right: 80px</span></code></p></td><td width="250"><p id="u7a671312" class="ne-p"><strong><span class="ne-text">右侧</span></strong><span class="ne-text">偏移量，定义元素相对于其父元素</span><strong><span class="ne-text">右边线的距离</span></strong></p></td></tr></tbody></table><p id="43af9b6612ed81f652b3287c153eb95b" class="ne-p"><span class="ne-text">定位的盒子有了边偏移才有价值。 一般情况下，凡是有定位地方必定有边偏移。</span></p><h3 id="4A2UW"><span class="ne-text">static</span></h3><ul class="ne-ul"><li id="331e4f6a35ce0d54170a1ee05026bdad"><strong><span class="ne-text">静态定位</span></strong><span class="ne-text">是元素的默认定位方式，无定位的意思。它相当于 border 里面的none， 不要定位的时候用。</span></li><li id="80ce23d3b66c7604285b97fe1b469aaa"><span class="ne-text">静态定位 按照标准流特性摆放位置，它没有边偏移。</span></li><li id="435fecf0c833a4e4cf3d3d29be4a3dfb"><span class="ne-text">静态定位在布局时我们几乎不用的</span></li></ul><h3 id="GFG3d"><span class="ne-text">relative</span></h3><ul class="ne-ul"><li id="dd42d137e5033eb61538e251049a13bb"><strong><span class="ne-text">相对定位</span></strong><span class="ne-text">是元素</span><strong><span class="ne-text" style="background-color: #FADB14">相对</span></strong><span class="ne-text" style="background-color: #FADB14">于它原来在标准流中的位置 </span><span class="ne-text">来说的。（自恋型）</span><strong><span class="ne-text"></span></strong></li></ul><p id="79bf9ba704f0110d328df135a7de910f" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611552470167-bd2f5289-4670-4b1f-9b22-1361f8cd58d0.png" width="365" id="hJGMp" class="ne-image"></p><p id="c1d344c57d750307207fec2a4c93df18" class="ne-p"><span class="ne-text">相对定位的特点：（务必记住）</span></p><ul class="ne-ul"><li id="c2a9d82d9882e894f0665b319ea45e4e"><span class="ne-text">相对于 </span><span class="ne-text" style="background-color: #FADB14">自己原来在标准流中位置</span><span class="ne-text">来移动的</span></li><li id="4bbc08ef0de456d9d40eba1b4743a2bc"><span class="ne-text" style="background-color: #FADB14">原来</span><strong><span class="ne-text" style="background-color: #FADB14">在标准流的区域继续占有</span></strong><span class="ne-text">，后面的盒子仍然以标准流的方式对待它。</span></li></ul><h3 id="HdfJM"><span class="ne-text">absolute</span></h3><div class="ne-quote"><p id="4e4c61a9eda6b0d988624646a72d60d4" class="ne-p"><strong><span class="ne-text">【1】绝对定位</span></strong><span class="ne-text">是元素以</span><span class="ne-text" style="background-color: #FADB14">带有定位的父级元素</span><span class="ne-text">来移动位置 （拼爹型）</span></p></div><ul class="ne-ul"><li id="9575cff1d09fecb62c7624a84da41ff5"><strong><span class="ne-text">完全脱标</span></strong><span class="ne-text">：完全不占位置，完全镂空</span></li><li id="8bf51dee24b5b51b7bc4fae1dfe74ef1"><strong><span class="ne-text">父元素没有定位：</span></strong><span class="ne-text">则</span><span class="ne-text" style="background-color: #FADB14">以</span><strong><span class="ne-text" style="background-color: #FADB14">浏览器</span></strong><span class="ne-text" style="background-color: #FADB14">为准定位</span><span class="ne-text">（Document 文档）。</span></li><li id="ee0b69474d539a5bef37523d4679b5c7"><strong><span class="ne-text">父元素要有定位：</span></strong><span class="ne-text">将元素依据</span><span class="ne-text" style="background-color: #FADB14">最近的已经定位（绝对、固定或相对定位）的父元素</span><span class="ne-text">（祖先）进行定位。</span></li><li id="c2033b627f9b53d96424c366617b842a"><span class="ne-text" style="background-color: #FADB14">绝对是以带有定位的父级元素来移动位置， 如果父级都没有定位，则以浏览器文档为准移动位置</span></li><li id="8107c669dc33a33cd93a0866117e5b7f"><span class="ne-text">不保留原来的位置，完全是脱标的。</span></li></ul><p id="e0bfb2f31e6e5a4a75328ded17f972d3" class="ne-p"><br></p><div class="ne-quote"><p id="8e05428a270afb4dbb178db748d114c5" class="ne-p"><span class="ne-text">【2】子级元素使用绝对定位时，父级元素就要用相对定位</span></p></div><p id="26f0f4debd399214965f47acd79bfa1b" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611552541033-59cb288a-ccb1-4ccb-aa4c-e4550e99edf0.png" width="617" id="Nzb9x" class="ne-image"></p><div class="ne-quote"><p id="b75da7bdce2e85eb000ecf30896d4fd9" class="ne-p"><strong><span class="ne-text">分析</span></strong></p></div><ul class="ne-ul"><li id="d618608aff39b7822f091431719bcedc"><strong><span class="ne-text">方向箭头</span></strong><span class="ne-text">叠加在其他图片上方，应该使用</span><strong><span class="ne-text">绝对定位</span></strong><span class="ne-text">，因为</span><strong><span class="ne-text">绝对定位完全脱标</span></strong><span class="ne-text">，完全不占位置。</span></li><li id="c076c7c69bba3cbf65c5ea9b70534bf2"><strong><span class="ne-text">父级盒子</span></strong><span class="ne-text">应该使用</span><strong><span class="ne-text">相对定位</span></strong><span class="ne-text">，因为</span><strong><span class="ne-text" style="background-color: #FADB14">相对定位不脱标</span></strong><span class="ne-text" style="background-color: #FADB14">，后续盒子仍然以标准流的方式对待它</span><span class="ne-text">。</span></li><li id="d054a418d38211b7819ce50c458f2fda"><span class="ne-text">如果父级盒子也使用</span><strong><span class="ne-text">绝对定位</span></strong><span class="ne-text">，会完全脱标，那么下方的</span><strong><span class="ne-text">广告盒子</span></strong><span class="ne-text">会上移，这显然不是我们想要的。</span></li></ul><h3 id="1ngvh"><span class="ne-text">fixed</span></h3><ul class="ne-ul"><li id="14e1df3d5ea13ae4e65b0ae6a7fae03f"><strong><span class="ne-text">固定定位</span></strong><span class="ne-text">是</span><strong><span class="ne-text">绝对定位</span></strong><span class="ne-text">的一种特殊形式： （认死理型）  </span></li><li id="1cac66d1bd321be37c94d60cd6a334b2"><strong><span class="ne-text">完全脱标</span></strong><span class="ne-text"> —— 完全不占位置；</span></li><li id="39c0532981c4ce636b3bc5a6fa8cb6f4"><span class="ne-text">只认</span><strong><span class="ne-text">浏览器的可视窗口</span></strong><span class="ne-text"> —— </span><code class="ne-code"><span class="ne-text">浏览器可视窗口 + 边偏移属性</span></code><span class="ne-text"> 来设置元素的位置；</span></li></ul><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="20e4fcadce41afb9b037c549d45d3c29"><span class="ne-text" style="background-color: #FADB14">跟父元素没有任何关系；单独使用的</span></li><li id="f35266c895be9f1023dd2e0e5f933c96"><span class="ne-text">不随滚动条滚动。</span></li></ul></ul><div class="ne-quote"><p id="23667b0e72a02c9503d0fc160e82c755" class="ne-p"><span class="ne-text">案例演练：固定定位案例。</span></p></div><p id="b552766fb43e413630fbfbb9c583338c" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611552558881-329f4f76-7ace-4fdd-840d-40a651c628ad.png" width="610.5" id="dVYeK" class="ne-image"></p><p id="5f3773a56e8eaff000ffb1fcf238c5fc" class="ne-p"><strong><span class="ne-text">提示</span></strong><span class="ne-text">：IE 6 等低版本浏览器不支持固定定位。</span></p><h3 id="t5NV1"><span class="ne-text">Demo：轮播图</span></h3><p id="fb46235baba689e57749b342fabae2d5" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616243009664-321f94d9-d92b-4503-9ff3-beaf87f2413e.png" width="960" id="RvrWd" class="ne-image"></p><div class="ne-quote"><p id="ff1b950566f10e46a24f5c420e8b970a" class="ne-p"><span class="ne-text">圆角矩形设置4个角</span></p></div><ul class="ne-ul"><li id="6d73e870c448f85b869d03b19b93958e"><span class="ne-text">圆角矩形可以为4个角分别设置圆度， 但是是有顺序的</span></li></ul><pre><code>border-top-left-radius:20px;border-top-right-radius:20px;border-bottom-right-radius:20px;border-bottom-left-radius:20px;</code></pre><ul class="ne-ul"><li id="3009035cd1ebf3fad224902ec6fd7a0f"><span class="ne-text">如果4个角，数值相同</span></li></ul><pre><code>border-radius: 15px;</code></pre><ul class="ne-ul"><li id="ffd12c25f9293674bc08021abb0391a7"><span class="ne-text">里面数值不同，我们也可以按照简写的形式，</span><span class="ne-text">还是遵循的顺时针。</span></li></ul><pre><code>border-radius: 左上角 右上角  右下角  左下角;</code></pre><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;    &lt;style&gt;        * &#123;            padding: 0;            margin: 0;        &#125;        li &#123;            list-style: none;        &#125;        .box &#123;            width: 400px;            height: 300px;            background-color: tan;            position: relative;            margin: 0 auto;        &#125;        .row_left &#123;            position: absolute;            width: 20px;            height: 30px;            top: 50%;            left: 0;            margin-top: -15px;            border: 1px darkgoldenrod solid;            line-height: 30px;            border-top-right-radius:30px;            border-bottom-right-radius:30px;            text-align: left;        &#125;        .row_right &#123;            position: absolute;            width: 20px;            height: 30px;            top: 50%;            right: 0;            margin-top: -15px;            border: 1px darkgoldenrod solid;            line-height: 30px;            border-top-left-radius:30px;            border-bottom-left-radius:30px;            text-align: right;        &#125;        .bottom_dots &#123;            position: absolute;            width: 110px;            height: 22px;            bottom: 10px;            left: 50%;            margin-left: -50px;            border: springgreen 1px solid;            border-radius: 10px;        &#125;        .row_left:hover,        .row_right:hover &#123;            background-color: yellowgreen;        &#125;        .bottom_dots li &#123;            float: left;            width: 20px;            height: 20px;            border-radius: 50%;            border: steelblue solid 1px;        &#125;        .bottom_dots .current &#123;            background-color: tomato;        &#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;div class=&quot;box&quot;&gt;        &lt;div class=&quot;row_left&quot;&gt;&lt;&lt;/div&gt;        &lt;div class=&quot;row_right&quot;&gt;&gt;&lt;/div&gt;        &lt;ul class=&quot;bottom_dots&quot;&gt;            &lt;li&gt;&lt;/li&gt;            &lt;li class=&quot;current&quot;&gt;&lt;/li&gt;            &lt;li&gt;&lt;/li&gt;            &lt;li&gt;&lt;/li&gt;            &lt;li&gt;&lt;/li&gt;        &lt;/ul&gt;    &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="YIsso"><span class="ne-text">Demo：网站右下角快捷功能</span></h3><ul class="ne-ul"><li id="cd3a0fa344613d8115a8f7296762ebb8"><strong><span class="ne-text">注意</span></strong><span class="ne-text">：不要同时使用 </span><code class="ne-code"><span class="ne-text">left</span></code><span class="ne-text"> 和 </span><code class="ne-code"><span class="ne-text">right</span></code><span class="ne-text"> 和边偏移属性。</span><strong><span class="ne-text"></span></strong></li><li id="9521ffcacff82408c09e4f640086213e"><strong><span class="ne-text">固定定位</span></strong><span class="ne-text">的应用场景：</span><strong><span class="ne-text">固定在浏览器可视窗口某个位置的布局</span></strong><span class="ne-text">；</span></li><li id="b35f8fc0ee97f3e5aa6ba71c095a8e99"><span class="ne-text">在使用固定和绝对定位时，如果盒子中没有内容，需要指定宽度，下面的例子又宽度</span></li></ul><p id="68d1de6a9c23d84ce731913b5c206789" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616239742720-28510068-3322-4b73-ad28-8a345ba5f8c6.png" width="960" id="pTRHC" class="ne-image"></p><h2 id="gHroO"><span class="ne-text">定位的相关问题</span></h2><h3 id="VmeQ1"><span class="ne-text">绝对定位的盒子居中</span></h3><div class="ne-quote"><p id="04b3a9f11f4b6bf0df3b853a3d5fdba7" class="ne-p"><strong><span class="ne-text" style="background-color: #FADB14">注意</span></strong><span class="ne-text" style="background-color: #FADB14">：</span><strong><span class="ne-text" style="background-color: #FADB14">绝对定位/固定定位的盒子</span></strong><span class="ne-text" style="background-color: #FADB14">不能通过设置 </span><code class="ne-code"><span class="ne-text" style="background-color: #FADB14">margin: auto</span></code><span class="ne-text" style="background-color: #FADB14"> 设置</span><strong><span class="ne-text" style="background-color: #FADB14">水平居中</span></strong><span class="ne-text" style="background-color: #FADB14">。</span></p></div><p id="2733432ec4c32d5473b9fa84161e3135" class="ne-p"><span class="ne-text">在使用</span><strong><span class="ne-text">绝对定位</span></strong><span class="ne-text">时要想实现水平居中，可以按照下面的方法：</span></p><ol class="ne-ol"><li id="8c06e18365b09613746b656e3013218c"><code class="ne-code"><span class="ne-text">left: 50%;</span></code><span class="ne-text">：让</span><strong><span class="ne-text">盒子的左侧</span></strong><span class="ne-text">移动到</span><strong><span class="ne-text">父级元素的水平中心位置</span></strong><span class="ne-text">；</span></li><li id="5639daa73293066eb95f618cd5596eb2"><code class="ne-code"><span class="ne-text">margin-left: -100px;</span></code><span class="ne-text">：让盒子</span><strong><span class="ne-text">向左</span></strong><span class="ne-text">移动</span><strong><span class="ne-text">自身宽度的一半</span></strong><span class="ne-text">。</span></li></ol><p id="0d83f3805ed7919c00bef9a3f04c9a68" class="ne-p"><span class="ne-text">整体居中如下设置</span></p><p id="e5be7eaec3cb956b3e7bdb2960681d11" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616240730926-4415dd36-b842-4cc8-b0a2-49345b503a43.png" width="1920" id="U8COT" class="ne-image"></p><p id="dff5bbe7cdeb1d6ecfe6f49808ad8930" class="ne-p"><br></p><h3 id="lTMxE"><span class="ne-text">z-index</span></h3><ul class="ne-ul"><li id="cf5426f76cd1774030b9f8350f9d6a36"><span class="ne-text">在使用</span><strong><span class="ne-text">定位</span></strong><span class="ne-text">布局时，可能会</span><strong><span class="ne-text">出现盒子重叠的情况</span></strong><span class="ne-text">。</span></li><li id="b7474ae292e77bb67aa37b46fb54550c"><span class="ne-text">加了定位的盒子，默认</span><strong><span class="ne-text">后来者居上</span></strong><span class="ne-text">， 后面的盒子会压住前面的盒子。</span></li><li id="98b244a4b7393536e332be065c6bfdb9"><span class="ne-text">应用 </span><code class="ne-code"><span class="ne-text">z-index</span></code><span class="ne-text"> 层叠等级属性可以</span><strong><span class="ne-text">调整盒子的堆叠顺序</span></strong><span class="ne-text">。如下图所示：</span></li></ul><p id="25cd43f3aa4d88c6b4b97cbb30e93f1e" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611552609219-135cc13d-9a4e-411e-bac1-3b3fcad55d5e.png" width="622.5" id="FpYQs" class="ne-image"></p><div class="ne-quote"><p id="063262891111d21d460e4da48a13cd72" class="ne-p"><code class="ne-code"><span class="ne-text">z-index</span></code><span class="ne-text"> 的特性如下：</span></p></div><ul class="ne-ul"><li id="5c1828638f0025f7546bc78b74336c22"><strong><span class="ne-text">属性值</span></strong><span class="ne-text">：</span><strong><span class="ne-text">正整数</span></strong><span class="ne-text">、</span><strong><span class="ne-text">负整数</span></strong><span class="ne-text">或 </span><strong><span class="ne-text">0</span></strong><span class="ne-text">，默认值是 0，</span><span class="ne-text" style="background-color: #FADB14">数值越大，盒子越靠上</span><span class="ne-text">；</span></li><li id="12acdffa2fed8e2fe09f2ff82ece7ca5"><span class="ne-text">如果</span><strong><span class="ne-text">属性值相同</span></strong><span class="ne-text">，则按照书写顺序，</span><strong><span class="ne-text">后来居上</span></strong><span class="ne-text">；</span></li><li id="10e253e2f66239d776cd64004a570b71"><strong><span class="ne-text">数字后面不能加单位</span></strong><span class="ne-text">。</span></li><li id="e1cf084fa0cdb11f0ab8e4e4952a17a0"><strong><span class="ne-text">注意</span></strong><span class="ne-text">：</span><code class="ne-code"><span class="ne-text">z-index</span></code><span class="ne-text"> 只能应用于</span><strong><span class="ne-text">相对定位</span></strong><span class="ne-text">、</span><strong><span class="ne-text">绝对定位</span></strong><span class="ne-text">和</span><strong><span class="ne-text">固定定位</span></strong><span class="ne-text">的元素，其他</span><strong><span class="ne-text">标准流</span></strong><span class="ne-text">、</span><strong><span class="ne-text">浮动</span></strong><span class="ne-text">和</span><strong><span class="ne-text">静态定位</span></strong><span class="ne-text">无效。</span></li></ul><h3 id="tElMM"><span class="ne-text">定位改变display属性</span></h3><p id="47a3b713314689865e3381fc8c0676d6" class="ne-p"><span class="ne-text">前面我们讲过，display是显示模式，可以改变显示模式有以下方式:</span></p><ul class="ne-ul"><li id="c61fb1545c072579bf87260f723645cf"><span class="ne-text">可以用inline-block  转换为行内块</span></li><li id="ab2a8ea79335be9dd1072c8217d1bbaa"><span class="ne-text">可以用浮动 float 默认转换为行内块（类似，并不完全一样，因为浮动是脱标的）</span></li><li id="98ae6ec17d21e910e10651e39347feab"><span class="ne-text">绝对定位和固定定位也和浮动类似， 默认转换的特性转换为行内块。</span></li></ul><p id="d8b740389eae7cb20a3e57c5d26aab4c" class="ne-p"><span class="ne-text">所以说， 一个行内的盒子，如果加了</span><strong><span class="ne-text">浮动</span></strong><span class="ne-text">、</span><strong><span class="ne-text">固定定位</span></strong><span class="ne-text">和</span><strong><span class="ne-text">绝对定位</span></strong><span class="ne-text">，不用转换，就可以给这个盒子直接设置宽度和高度等。</span></p><div class="ne-quote"><p id="a6f42af6bd0cf0a011eb36f1b069f922" class="ne-p"><strong><span class="ne-text">同时注意：</span></strong></p></div><p id="aafbd03eda2dfa99dcc0735091d3e864" class="ne-p"><span class="ne-text">浮动元素、绝对定位(固定定位）元素的都不会触发外边距合并的问题。 （我们以前是用padding border overflow解决的）</span></p><p id="7f815c6a0925a73b63dae3d21a5817ab" class="ne-p"><span class="ne-text">也就是说，我们给盒子改为了浮动或者定位，就不会有垂直外边距合并的问题了。</span></p><p id="f6b3a849d3b4e348a77a602292c88baa" class="ne-p"><br></p><p id="9cfb767413c757141c9c6f05ba097f84" class="ne-p"><br></p></div>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
          <category> HTML+CSS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CSS浮动</title>
      <link href="/blog/vgixv5vex3i8/"/>
      <url>/blog/vgixv5vex3i8/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h2 id="Pnpum"><span class="ne-text">浮动详解</span></h2><h3 id="YjyYs"><span class="ne-text">为什么需要浮动</span></h3><ul class="ne-ul"><li id="7fe98f969121ab3da7e79bf3bc0f5d3b"><span class="ne-text">多个盒子(div)水平排列成一行</span></li><li id="f450cb6b8b07c6696515dbffa535ba73"><span class="ne-text">实现盒子的左右对齐</span></li><li id="6718aa183014881ad0069ba82f5c092d"><span class="ne-text">行内块（inline-block）</span><span class="ne-text">它可以实现多个元素一行显示，但是中间会有空白缝隙，不能满足以上第一个问题。</span></li><li id="3d3fe32ff4a5c1b956bb07a704f2b33e"><span class="ne-text">行内块（inline-block）不能实现以上第二个问题，盒子左右对齐</span></li></ul><h3 id="IEEfh"><span class="ne-text">浮动特点</span></h3><div class="ne-quote"><p id="0fde6a0492814b5705a53b8c6914a860" class="ne-p"><strong><span class="ne-text">概念</span></strong><span class="ne-text">：元素的浮动是指</span><strong><span class="ne-text">设置了浮动属性的元素</span></strong><span class="ne-text">会</span></p></div><ul class="ne-ul"><li id="55f5b825ae004b7e42be440ff72fd7c4"><span class="ne-text">脱离标准普通流的控制</span></li><li id="367f43a10c3797faf9c708191edb1381"><span class="ne-text">移动到指定位置</span></li></ul><div class="ne-quote"><p id="84682cd9897038d8c192d9e247f3ac76" class="ne-p"><span class="ne-text">作用</span></p></div><ul class="ne-ul"><li id="38fbcead580fd692865b133eee5ca680"><strong><span class="ne-text" style="color: #F5222D">让多个盒子(div)水平排列成一行</span></strong><span class="ne-text">，使得浮动成为布局的重要手段。</span></li><li id="6de5316c386b3f6df7edddc747732d3c"><span class="ne-text">可以实现盒子的左右对齐等等..</span></li><li id="2bc6e1d004f79b9031044b3cd1727675"><span class="ne-text">浮动最早是用来</span><strong><span class="ne-text">控制图片</span></strong><span class="ne-text">，实现</span><strong><span class="ne-text">文字环绕图片的效果</span></strong><span class="ne-text">。</span></li></ul><div class="ne-quote"><p id="f83501794e2e93a82b5306c3bfadd752" class="ne-p"><span class="ne-text">语法</span></p></div><pre><code>选择器 &#123; float: 属性值; &#125;</code></pre><table id="prf6J" class="ne-table" style="width: 750px"><tbody><tr style="height: 33px"><td width="375"><p id="u7cd09a85" class="ne-p"><span class="ne-text">属性值</span></p></td><td width="375"><p id="u8b7181df" class="ne-p"><span class="ne-text">描述</span></p></td></tr><tr style="height: 33px"><td width="375"><p id="u6efbd0a2" class="ne-p"><strong><span class="ne-text">none</span></strong></p></td><td width="375"><p id="uc645375d" class="ne-p"><span class="ne-text">元素不浮动（</span><strong><span class="ne-text">默认值</span></strong><span class="ne-text">）</span></p></td></tr><tr style="height: 33px"><td width="375"><p id="u9cf8251f" class="ne-p"><strong><span class="ne-text">left</span></strong></p></td><td width="375"><p id="ufac7de07" class="ne-p"><span class="ne-text">元素向</span><strong><span class="ne-text">左</span></strong><span class="ne-text">浮动</span></p></td></tr><tr style="height: 33px"><td width="375"><p id="u1f133063" class="ne-p"><strong><span class="ne-text">right</span></strong></p></td><td width="375"><p id="u7e1b66ed" class="ne-p"><span class="ne-text">元素向</span><strong><span class="ne-text">右</span></strong><span class="ne-text">浮动</span></p></td></tr></tbody></table><div class="ne-quote"><p id="0f39c1fdfa4940bad68a51e9c2393f29" class="ne-p"><span class="ne-text">特点1：浮</span></p></div><ul class="ne-ul"><li id="2a2949829b327623764c499f92b30d62"><span class="ne-text">浮动——浮</span><sub><span class="ne-text">浮</span></sub><span class="ne-text">浮~~~漂浮在普通流的上面。  脱离标准流。 俗称 “脱标”</span></li><li id="3dd3592c9477cb4b17ac7d41c0929e4d"><code class="ne-code"><span class="ne-text">float</span></code><span class="ne-text"> 属性会</span><span class="ne-text" style="background-color: #FADB14">让盒子漂浮在标准流的上面</span><span class="ne-text">，所以第二个标准流的盒子跑到浮动盒子的底下了。</span></li></ul><p id="0b5b0c88f34f52519f53f1e69faaeba7" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616233538999-0a7d098b-a897-491c-b25c-36f34eb7b193.png" width="960" id="g1rEz" class="ne-image"></p><ul class="ne-ul"><li id="b9e590f2bc293d29382d423fb2b3f8b5"><span class="ne-text">上图问题1处出现文字被撑开的情况，似乎和预想的有一丢丢的不尽如意，原因是对于文本和行内元素来说依然是占用空间的</span></li></ul><div class="ne-quote"><p id="8c20acd9f9ab93e0aa9d4e7ea93c9c9c" class="ne-p"><span class="ne-text">特点2：漏</span></p></div><ul class="ne-ul"><li id="fd36b579359bbe2926e6b3a549b84fe8"><span class="ne-text">浮动——漏</span><sub><span class="ne-text">漏</span></sub><span class="ne-text">漏~  浮动的盒子，把自己原来的位置漏给下面标准流的盒子，就是不占有原来位置，是脱离标准流的，我们俗称 “脱标”。</span></li></ul><div class="ne-quote"><p id="431f97ac0f0723691f3a342fa5a42d05" class="ne-p"><span class="ne-text">特点3：特</span></p></div><ul class="ne-ul"><li id="f9b94d5d9bf202de9a747e893cda496f"><span class="ne-text">浮动——特性  float属性</span><span class="ne-text" style="background-color: #FADB14">会改变元素display属性</span><span class="ne-text">。</span></li><li id="82472b2355811e914bc07a76fc445270"><span class="ne-text">任何元素都可以浮动。浮动元素会生成一个块级框，而不论它本身是何种元素。 生成的块级框和我们前面的行内块极其相似，所以出现了上面浮里面的例子当中父元素里面的文字被撑开的情况</span></li></ul><p id="b08b4725742ce3a26387b33231ee6d8a" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616234017630-4391a0b4-6214-42ba-a1f2-cd44c1a99f94.png" width="960" id="xv7E0" class="ne-image"></p><ul class="ne-ul"><li id="2a115c14676bfc7e332ecebcce2c60bc"><strong><span class="ne-text">浮动的元素互相贴靠一起的，但是如果父级宽度装不下这些浮动的盒子， </span></strong><strong><span class="ne-text" style="background-color: #FADB14">多出的盒子会另起一行对齐</span></strong></li></ul><h3 id="RuL9h"><span class="ne-text">Demo：</span><span class="ne-text">浮动+标准流的布局</span></h3><div class="ne-quote"><p id="4ef971344694c0c7aba13859866c208a" class="ne-p"><span class="ne-text">浮动和标准流的父盒子搭配</span></p></div><p id="bf973f234adc970e1fc93111a591375b" class="ne-p"><span class="ne-text">我们知道，</span><span class="ne-text" style="color: #F5222D">浮动是脱标的，会影响下面的标准流元素，此时，我们需要给浮动的元素添加一个标准流的父亲，这样，最大化的减小了对其他标准流的影响。</span><strong><span class="ne-text"></span></strong></p><p id="e0f64ac51914923bab3cc58c492974ad" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616236830103-21860906-bc1f-48a8-8fb1-a5011f02a551.png" width="960" id="dIXWA" class="ne-image"></p><h2 id="wQdZz"><span class="ne-text">浮动的相关问题</span></h2><h3 id="IM9H6"><span class="ne-text">浮动元素与父盒子的关系</span></h3><ul class="ne-ul"><li id="4b46306c53c4ceedf33ae623d4b68bac"><span class="ne-text">子盒子的浮动参照父盒子对齐</span></li><li id="14156dcbcedc089b2ca10dbdda908395"><span class="ne-text">不会与父盒子的边框重叠，也不会超过父盒子的内边距</span></li></ul><p id="6a9f60c0d5cef8b6617cfa7a54fc6d38" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616237499108-fe82abe6-42c1-4f37-ad68-d45c3f78cd11.png" width="960" id="ilWC3" class="ne-image"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616237548311-79fb762c-6f7d-45c0-b316-14a12ba92098.png" width="960" id="vhwGB" class="ne-image"></p><h3 id="9GPll"><span class="ne-text">浮动元素与兄弟盒子的关系</span></h3><p id="2db6f72e32f7cbd488ae7c9b91224da0" class="ne-p"><span class="ne-text">在一个父级盒子中，如果</span><strong><span class="ne-text">前一个兄弟盒子</span></strong><span class="ne-text">是：</span></p><ul class="ne-ul"><li id="fc323f18b46c5cccacd0a074b5744147"><strong><span class="ne-text">浮动</span></strong><span class="ne-text">的，那么</span><strong><span class="ne-text">当前盒子</span></strong><span class="ne-text">会与前一个盒子的顶部对齐；</span></li><li id="2f3e4959d009695be5dfd7d34a3702ac"><strong><span class="ne-text">普通流</span></strong><span class="ne-text">的，那么</span><strong><span class="ne-text">当前盒子</span></strong><span class="ne-text">会显示在前一个兄弟盒子的下方。</span></li></ul><ul class="ne-ul"><li id="a4ccf5f65ce1b09d20fe82716c312743"><span class="ne-text">浮动只会影响当前的或者是后面的标准流盒子，不会影响前面的标准流。</span></li></ul><p id="5d3acedd395a92571db9f70946806e50" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/jpg/1484158/1611549557830-9fdd5350-af70-4793-8dba-cc3c06214b72.jpg" width="486" id="g7jBt" class="ne-image"></p><ul class="ne-ul"><li id="b2c8cf509911ffbf403e3708153b1d99"><strong><span class="ne-text">如果一个盒子里面有多个子盒子，如果其中一个盒子浮动了，其他兄弟也应该浮动。防止引起问题</span></strong></li></ul><h3 id="vDgC2"><span class="ne-text">为什么要清除浮动</span></h3><ul class="ne-ul"><li id="76265c07e0eb08052994d26955f82330"><span class="ne-text">因为父级盒子很多情况下，不方便给高度，但是子盒子浮动就不占有位置，最后父级盒子高度为0，就影响了下面的标准流盒子</span></li></ul><p id="3c65b916d269495dc3549c4506a2e21f" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616238120449-097b5efe-31ea-43f9-b393-4e64e9836530.png" width="960" id="YeDHm" class="ne-image"></p><p id="bdc86e98cfb6b0c1d2ed01a6df31ded3" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616238209810-a8b31f63-37b3-4289-a691-e52ab55f8203.png" width="960" id="CKrnI" class="ne-image"></p><ul class="ne-ul"><li id="babd04fd874137e57cc04b4d0600404d"><span class="ne-text">总结：由于浮动元素不再占用原文档流的位置，所以它会对后面的元素排版产生影响，准确地说，并不是清除浮动，而是</span><strong><span class="ne-text">清除浮动后造成的影响</span></strong></li><li id="dd0def44fdbaa9b594f8a6d5574dc18d"><strong><span class="ne-text">所以还是最好利用一个标准流为父盒子，里面套数个浮动盒子最为好用</span></strong></li></ul><div class="ne-quote"><p id="428b625cbbb7ce77cd124a42a92bb8e3" class="ne-p"><strong><span class="ne-text">清除浮动本质：</span></strong></p><p id="u68725ad3" class="ne-p"><strong><span class="ne-text" style="background-color: #FADB14">清除浮动主要为了解决父级元素因为子级浮动引起内部高度为0 的问题</span></strong><strong><span class="ne-text">。清除浮动之后， 父级就会根据浮动的子盒子自动检测高度。父级有了高度，就不会影响下面的标准流了</span></strong></p></div><h3 id="W1MTH"><span class="ne-text">清除浮动的方法</span></h3><ul class="ne-ul"><li id="d312522c5925acc97d1f46b9facb0946"><span class="ne-text">clear属性用于清除浮动</span></li></ul><table id="9Apov" class="ne-table" style="width: 634px"><tbody><tr style="height: 33px"><td width="317"><p id="uf8b0a08f" class="ne-p"><span class="ne-text">属性值</span></p></td><td width="317"><p id="ue63a6de6" class="ne-p"><span class="ne-text">描述</span></p></td></tr><tr style="height: 33px"><td width="317"><p id="u6ac652ed" class="ne-p"><span class="ne-text">left</span></p></td><td width="317"><p id="u3462895a" class="ne-p"><span class="ne-text">不允许左侧有浮动元素（清除左侧浮动的影响）</span></p></td></tr><tr style="height: 33px"><td width="317"><p id="u1ecadbf6" class="ne-p"><span class="ne-text">right</span></p></td><td width="317"><p id="u1c4e7b2a" class="ne-p"><span class="ne-text">不允许右侧有浮动元素（清除右侧浮动的影响）</span></p></td></tr><tr style="height: 33px"><td width="317"><p id="u2040bf3a" class="ne-p"><span class="ne-text">both</span></p></td><td width="317"><p id="u173b26f5" class="ne-p"><span class="ne-text">同时清除左右两侧浮动的影响</span></p></td></tr></tbody></table><p id="6e9bce7e97d5d22debeadd67f3b5ef31" class="ne-p"><br></p><h4 id="enI7K"><span class="ne-text">clear:both</span></h4><p id="4ac5f6d0397e3560e92eb56786fabde1" class="ne-p"><span class="ne-text">是W3C推荐的做法是通过在浮动元素末尾添加一个空的标签例如 </span><code class="ne-code"><span class="ne-text">&lt;div style=”clear:both”&gt;&lt;/div&gt;</span></code><span class="ne-text">，或则其他标签br等亦可。</span></p><ul class="ne-ul"><li id="106bb9b7a67e28ed03cb38b3020a3871"><span class="ne-text">优点： 通俗易懂，书写方便</span></li><li id="884ed29906ba71b0f119e4557c4f950e"><span class="ne-text">缺点： 添加许多无意义的标签，结构化较差。</span></li></ul><h4 id="c6y3n"><span class="ne-text">overflow: hidden;</span></h4><p id="f1a1c620ee8153583146af43159f338e" class="ne-p"><span class="ne-text">可以给父级添加： overflow为 hidden| auto| scroll  都可以实现。</span></p><ul class="ne-ul"><li id="1bcb0c5138d96d02cf1ad23e840b6fa7"><span class="ne-text">优点：  代码简洁</span></li><li id="49fab35d4a352416b4472fd7a36d9c70"><span class="ne-text">缺点：  内容增多时候容易造成不会自动换行导致内容被隐藏掉，无法显示需要溢出的元素。</span></li></ul><h4 id="xMs3g"><span class="ne-text">使用after伪元素清除浮动</span></h4><div class="ne-quote"><p id="92ad997409a0ef9eef1c88f3e51d1e06" class="ne-p"><strong><span class="ne-text">:after 方式为空元素额外标签法的升级版，好处是不用单独加标签了</span></strong></p></div><pre><code>.clearfix:after &#123;    content: &quot;&quot;;   display: block;   height: 0;   clear: both;   visibility: hidden;  &#125;   .clearfix &#123;   *zoom: 1;&#125;   /* IE6、7 专有 */</code></pre><ul class="ne-ul"><li id="21f9c49158fd67d535e786fbd21e2d26"><span class="ne-text">优点： 符合闭合浮动思想  结构语义化正确</span></li><li id="da3589ab0eda11f91f3179bd17fb4d12"><span class="ne-text">缺点： 由于IE6-7不支持:after，使用 zoom:1触发 hasLayout。</span></li><li id="c8b058f2ab76d9e4821939a59b60a7e0"><span class="ne-text">代表网站： 百度、淘宝网、网易等</span></li></ul><h4 id="ys7kP"><span class="ne-text">使用双伪元素清除浮动</span></h4><pre><code>.clearfix:before,.clearfix:after &#123;   content:&quot;&quot;;  display:table; &#125;.clearfix:after &#123; clear:both;&#125;.clearfix &#123;  *zoom:1;&#125;</code></pre><ul class="ne-ul"><li id="1b4bfabffd301eb9633b9611a32e5d74"><span class="ne-text">优点：  代码更简洁</span></li><li id="eb4353557a6e2a844a063e0806623d7b"><span class="ne-text">缺点：  由于IE6-7不支持:after，使用 zoom:1触发 hasLayout。</span></li><li id="2e20a92d3c148e2ee11f2c2e38867241"><span class="ne-text">代表网站： 小米、腾讯等</span></li></ul></div>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
          <category> HTML+CSS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CSS盒模型</title>
      <link href="/blog/dnp4byvzqz87/"/>
      <url>/blog/dnp4byvzqz87/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="u44a2d1d8" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2023/png/1484158/1679117135156-5c30df04-77c0-4db1-9f23-07a926e5949e.png" width="746" id="ue2ba78fe" class="ne-image"></p><h2 id="JCTid"><span class="ne-text">border</span></h2><h3 id="ezq6V"><span class="ne-text">border综合</span></h3><table id="TcCkm" class="ne-table" style="width: 750px"><tbody><tr style="height: 33px"><td width="375"><p id="u101cc3bd" class="ne-p"><span class="ne-text">属性</span></p></td><td width="375"><p id="u4029e0c8" class="ne-p" style="text-align: center"><span class="ne-text">作用</span></p></td></tr><tr style="height: 33px"><td width="375"><p id="u4fe48a3d" class="ne-p"><span class="ne-text">border-width</span></p></td><td width="375"><p id="u7bdc8c95" class="ne-p" style="text-align: center"><span class="ne-text">定义边框粗细，单位是px</span></p></td></tr><tr style="height: 33px"><td width="375"><p id="ud4c1097e" class="ne-p"><span class="ne-text">border-style</span></p></td><td width="375"><p id="u018efb90" class="ne-p" style="text-align: center"><span class="ne-text">边框的样式</span></p></td></tr><tr style="height: 33px"><td width="375"><p id="u6703b7cf" class="ne-p"><span class="ne-text">border-color</span></p></td><td width="375"><p id="u71adaaa7" class="ne-p" style="text-align: center"><span class="ne-text">边框颜色</span></p></td></tr></tbody></table><div class="ne-quote"><p id="77e5ef6b8df66c1afb69f75e276d2551" class="ne-p"><span class="ne-text">【1】border-style</span></p></div><ul class="ne-ul"><li id="518d3853e6641a846ed6bb2e890daf98"><span class="ne-text">none：没有边框即忽略所有边框的宽度（默认值）</span></li><li id="0f9cb37cd35a4c063bf9c92f75872f1c"><span class="ne-text">solid：边框为单实线(最为常用的)</span></li><li id="711a5f1e83c36fdb4ffa67f310a4dfca"><span class="ne-text">dashed：边框为虚线</span></li><li id="850cde88a66e84b4994d70d53dd731ce"><span class="ne-text">dotted：边框为点线</span></li></ul><div class="ne-quote"><p id="81757a593425d2684863b55da9916c40" class="ne-p"><span class="ne-text">【2】综合设置：</span><span class="ne-text">盒子边框写法总结表</span></p></div><pre><code>border: 1px solid red;  </code></pre><div class="ne-quote"><p id="f44af2eeb9a0e528aa9699feac1673a7" class="ne-p"><span class="ne-text">【3】很多情况下，我们不需要指定4个边框，我们是可以单独给4个边框分别指定的。</span></p></div><table id="5BX0r" class="ne-table" style="width: 748px"><tbody><tr style="height: 33px"><td width="187"><p id="u74e184bb" class="ne-p" style="text-align: left"><span class="ne-text">上边框</span></p></td><td width="187"><p id="u310b3604" class="ne-p" style="text-align: left"><span class="ne-text">下边框</span></p></td><td width="187"><p id="uf00d2c41" class="ne-p" style="text-align: left"><span class="ne-text">左边框</span></p></td><td width="187"><p id="ue30f51ec" class="ne-p" style="text-align: left"><span class="ne-text">右边框</span></p></td></tr><tr style="height: 33px"><td width="187"><p id="u199ec862" class="ne-p" style="text-align: left"><span class="ne-text">border-top-style:样式;</span></p></td><td width="187"><p id="u59c60a04" class="ne-p" style="text-align: left"><span class="ne-text">border-bottom-style:样式;</span></p></td><td width="187"><p id="u830c29ab" class="ne-p" style="text-align: left"><span class="ne-text">border-left-style:样式;</span></p></td><td width="187"><p id="u969dc48a" class="ne-p" style="text-align: left"><span class="ne-text">border-right-style:样式;</span></p></td></tr><tr style="height: 33px"><td width="187"><p id="u3b3796e2" class="ne-p" style="text-align: left"><span class="ne-text">border-top-width:宽度;</span></p></td><td width="187"><p id="u3083998c" class="ne-p" style="text-align: left"><span class="ne-text">border- bottom-width:宽度;</span></p></td><td width="187"><p id="u3ea29bd3" class="ne-p" style="text-align: left"><span class="ne-text">border-left-width:宽度;</span></p></td><td width="187"><p id="ub06ef4f8" class="ne-p" style="text-align: left"><span class="ne-text">border-right-width:宽度;</span></p></td></tr><tr style="height: 33px"><td width="187"><p id="u2f7ccc78" class="ne-p" style="text-align: left"><span class="ne-text">border-top-color:颜色;</span></p></td><td width="187"><p id="u14320fe2" class="ne-p" style="text-align: left"><span class="ne-text">border- bottom-color:颜色;</span></p></td><td width="187"><p id="u43281b90" class="ne-p" style="text-align: left"><span class="ne-text">border-left-color:颜色;</span></p></td><td width="187"><p id="u78a1b7a6" class="ne-p" style="text-align: left"><span class="ne-text">border-right-color:颜色;</span></p></td></tr><tr style="height: 33px"><td width="187"><p id="u917e4d22" class="ne-p" style="text-align: left"><span class="ne-text">border-top:宽度 样式 颜色;</span></p></td><td width="187"><p id="uc16e7248" class="ne-p" style="text-align: left"><span class="ne-text">border-bottom:宽度 样式 颜色;</span></p></td><td width="187"><p id="udc3f48b3" class="ne-p" style="text-align: left"><span class="ne-text">border-left:宽度 样式 颜色;</span></p></td><td width="187"><p id="u450cf750" class="ne-p" style="text-align: left"><span class="ne-text">border-right:宽度 样式 颜色;</span></p></td></tr></tbody></table><div class="ne-quote"><p id="d2c77a59b154c7ef703ba9baf0083383" class="ne-p"><span class="ne-text">表格的细线边框</span></p></div><ul class="ne-ul"><li id="2d1f0514add2a1b8fe04f31199288037"><span class="ne-text">通过表格的</span><code class="ne-code"><span class="ne-text">cellspacing=&quot;0&quot;</span></code><span class="ne-text">,将单元格与单元格之间的距离设置为0，</span></li><li id="ad3f32e503f612a47f765e2860d27665"><span class="ne-text">但是两个单元格之间的边框会出现重叠，从而使边框变粗</span></li><li id="3912787b161a6b732d2de0db14ea4b56"><span class="ne-text">通过css属性：</span></li></ul><pre><code>table&#123; border-collapse:collapse; &#125;</code></pre><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="a53e896a4ffe982c42b62f7b7e7ce43c"><span class="ne-text">collapse 单词是合并的意思</span></li><li id="d7af81c6fc39f80b5d7ff5a6aa786601"><span class="ne-text">border-collapse:collapse; 表示相邻边框合并在一起。</span></li></ul></ul><pre><code>&lt;style&gt;    table &#123;        width: 500px;        height: 300px;        border: 1px solid red;    &#125;    td &#123;        border: 1px solid red;        text-align: center;    &#125;    table, td &#123;        border-collapse: collapse;  /*合并相邻边框*/    &#125;&lt;/style&gt;</code></pre><p id="0ac9af404a9aab9aa70853735c45405b" class="ne-p"><br></p><h3 id="blzJF"><span class="ne-text">border-radius</span></h3><ul class="ne-ul"><li id="68a5cefee0330a38ec118af3bff46b79"><span class="ne-text">语法：</span></li></ul><pre><code>border-radius:length;</code></pre><ul class="ne-ul"><li id="924ad8023f83a51f7a394e7d0e3430c8"><span class="ne-text">其中每一个值可以为 数值或百分比的形式。</span></li><li id="4f052032249c4047a5860e6fe54b3d46"><span class="ne-text">让一个正方形（让这个盒子width和height相等）变成圆圈</span></li></ul><pre><code>border-radius: 50%;</code></pre><p id="92d09cd9977b517db7be31d0d68f7677" class="ne-p"><br></p><ul class="ne-ul"><li id="780851b513ce546b9047c529c3619f14"><span class="ne-text">百分比会是表示高度和宽度的一半的情况</span></li></ul><p id="9a6be9e92e67fe84d4d9f0e9d64e10d7" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616160100879-1ec56967-ea20-4bd2-8327-519c75d1367f.png" width="960" id="Pc3pC" class="ne-image"></p><h3 id="o20No"><span class="ne-text">box-shadow</span></h3><ul class="ne-ul"><li id="a36ff41dece00cdb0f0019a2f74a4a36"><span class="ne-text">语法:</span></li></ul><pre><code>box-shadow:水平阴影 垂直阴影 模糊距离（虚实）  阴影尺寸（影子大小）  阴影颜色  内/外阴影；</code></pre><p id="115db4e91ea3aa39630df3308b34e537" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611549557136-9945210f-61eb-44df-af61-5eb070818e6f.png" width="862" id="K53lY" class="ne-image"></p><ul class="ne-ul"><li id="1b6420b10dad52b7033b959e96a8c4f1"><span class="ne-text">前两个属性是必须写的。其余的可以省略。</span></li><li id="acf5393b844c9b136af59fd17c26b566"><span class="ne-text">外阴影 (outset) 是默认的 但是不能写           想要内阴影可以写  inset</span></li></ul><p id="c8182447720f3d1d977f98bbb2a7f816" class="ne-p"><br></p><h2 id="kTQ9J"><span class="ne-text">padding</span></h2><div class="ne-quote"><p id="7344ed2f44175c1d046f5f86bc4ffb55" class="ne-p"><span class="ne-text">内边距：</span><span class="ne-text" style="background-color: transparent">padding属性用于设置内边距。 </span><strong><span class="ne-text">是指 边框与内容之间的距离。</span></strong></p></div><h3 id="UWMMQ"><span class="ne-text">padding综合</span></h3><table id="xWw9k" class="ne-table" style="width: 750px"><tbody><tr style="height: 33px"><td width="375"><p id="u7dc644cd" class="ne-p"><span class="ne-text">属性</span></p></td><td width="375"><p id="u2800f0e1" class="ne-p" style="text-align: left"><span class="ne-text">作用</span></p></td></tr><tr style="height: 33px"><td width="375"><p id="u993e2695" class="ne-p"><span class="ne-text">padding-left</span></p></td><td width="375"><p id="u74d3359c" class="ne-p" style="text-align: left"><span class="ne-text">左内边距</span></p></td></tr><tr style="height: 33px"><td width="375"><p id="u59b59b31" class="ne-p"><span class="ne-text">padding-right</span></p></td><td width="375"><p id="u1239baab" class="ne-p" style="text-align: left"><span class="ne-text">右内边距</span></p></td></tr><tr style="height: 33px"><td width="375"><p id="u9cbc149f" class="ne-p"><span class="ne-text">padding-top</span></p></td><td width="375"><p id="uf647fefe" class="ne-p" style="text-align: left"><span class="ne-text">上内边距</span></p></td></tr><tr style="height: 33px"><td width="375"><p id="u382b8957" class="ne-p"><span class="ne-text">padding-bottom</span></p></td><td width="375"><p id="u7e3035d5" class="ne-p" style="text-align: left"><span class="ne-text">下内边距</span></p></td></tr></tbody></table><p id="15448386d88a9f8c4cba0b0730e63010" class="ne-p"><span class="ne-text">当我们给盒子指定padding值之后， 发生了2件事情：</span></p><ol class="ne-ol"><li id="14f6e1056fc92cf53290828decec0659"><span class="ne-text">内容和边框 有了距离，添加了内边距。</span></li><li id="db0171fb34e72ff3d223679c911447c0"><span class="ne-text">盒子会变大了。</span></li></ol><p id="410353c73f30cdbc4270274bdb21f6e5" class="ne-p"><strong><span class="ne-text">注意：  后面跟几个数值表示的意思是不一样的。</span></strong></p><p id="66497da65a5cd86b01d3c8c566e47050" class="ne-p"><span class="ne-text">我们分开写有点麻烦，我们可以不可以简写呢？</span></p><table id="g1A1w" class="ne-table" style="width: 750px"><tbody><tr style="height: 33px"><td width="375"><p id="u69c72838" class="ne-p"><span class="ne-text">值的个数</span></p></td><td width="375"><p id="uf590e907" class="ne-p"><span class="ne-text">表达意思</span></p></td></tr><tr style="height: 33px"><td width="375"><p id="uebdbf0a2" class="ne-p"><span class="ne-text">1个值</span></p></td><td width="375"><p id="uaca4eb31" class="ne-p"><span class="ne-text">padding：上下左右内边距;</span></p></td></tr><tr style="height: 33px"><td width="375"><p id="u2104276e" class="ne-p"><span class="ne-text">2个值</span></p></td><td width="375"><p id="uc9eb3fe0" class="ne-p"><span class="ne-text">padding: 上下内边距    左右内边距 ；</span></p></td></tr><tr style="height: 33px"><td width="375"><p id="uf5afd962" class="ne-p"><span class="ne-text">3个值</span></p></td><td width="375"><p id="u6a6e6140" class="ne-p"><span class="ne-text">padding：上内边距   左右内边距   下内边距；</span></p></td></tr><tr style="height: 33px"><td width="375"><p id="u96bf2ac5" class="ne-p"><span class="ne-text">4个值</span></p></td><td width="375"><p id="ub6f785eb" class="ne-p"><span class="ne-text">padding: 上内边距 右内边距 下内边距 左内边距 ；</span></p></td></tr></tbody></table><p id="ef5eade0247ea0263135b9e7fc0f188b" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611552112041-a7ed9154-18bb-478e-867f-92e7837719ea.png" width="204.5" id="zFwzo" class="ne-image"><strong><span class="ne-text"></span></strong></p><p id="580eb2e4f8cb735ad88dd2efe2107633" class="ne-p"><br></p><h3 id="6HsEI"><span class="ne-text">内盒尺寸计算（元素实际大小）</span></h3><p id="162d50e36bf780d8e71a111bcd850fe8" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611552122666-74470517-33eb-4212-b483-430e2bbd0ee5.png" width="173.5" id="c2yvz" class="ne-image"></p><ul class="ne-ul"><li id="c09e8d80bebc732aed586709735996e1"><span class="ne-text">宽度：Element Height = content height + padding + border （Height为内容高度）</span></li><li id="c0767eddda0221523668f7d53c7bdae8"><span class="ne-text">高度：Element Width = content width + padding + border （Width为内容宽度）</span></li><li id="d7c2ea6a331bc5caecd54dc4a4b8c9e3"><span class="ne-text">盒子的实际的大小 =   内容的宽度和高度 +  内边距   +  边框</span></li></ul><h3 id="EX92l"><span class="ne-text">内边距撑大盒子（怪异盒模型）的解决方案</span></h3><div class="ne-quote"><p id="04df78ba9bc7d8c663522632bc30bb00" class="ne-p"><span class="ne-text">问题：</span><span class="ne-text">会撑大原来的盒子</span></p></div><p id="259f7baa08cca490803c3baa7029fe7b" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611552148703-03f4e9a2-62c0-4ef6-bcc9-daca7a48972f.png" width="350" id="HK0PO" class="ne-image"></p><p id="d5a90ce1bb855d20073ff41e2bc2c131" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611552164629-96bb4847-362e-4c50-ad11-9bf86c3cd22e.png" width="353" id="RI9BY" class="ne-image"></p><div class="ne-quote"><p id="7e81d58b9af23f2bb4975d3f84ccd067" class="ne-p"><span class="ne-text">解决方案【1】：通过给设置了宽高的盒子，减去相应的内边距的值，维持盒子原有的大小</span></p></div><p id="32ba22cc2c7f2701ad958c938f13cb32" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611552179527-c1060669-e26e-4c16-b0eb-0fa78c03b45b.png" width="393" id="ZRlkd" class="ne-image"></p><p id="7219cf1fbf5f6cba8df42cc64dd9b33c" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611552188919-c9493a98-9f8f-4ba4-942c-83d9fd2a033f.png" width="397" id="Xomtj" class="ne-image"></p><p id="79c394fd265eb212d6c98aa8873f2967" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611552197848-242d4e3f-1cdd-4f31-b86b-e42b549e2094.png" width="397" id="ZzyzG" class="ne-image"></p><p id="722c3478a0ed1bba8fac82be535e3a84" class="ne-p"><span class="ne-text">关于根据下列代码计算 盒子宽高下列说法正确的是（）</span></p><pre><code>div &#123;        width: 200px;    height: 200px;        border: 1px solid #000000;        border-top: 5px solid blue;        padding: 50px;        padding-left: 100px;        &#125;</code></pre><ul class="ne-ul"><li id="504bc166451eeaadebb0469bc7b8862d"><span class="ne-text"> (A) 宽度为200px 高度为200px</span></li><li id="9c7f2da53ca8da36f17381752bce84c9"><span class="ne-text"> (B) 宽度为352px 高度为306px</span></li><li id="8d1b80a2536a6024e3b530b42056a6b3"><span class="ne-text"> (C) 宽度为302px 高度为307px</span></li><li id="e0f36ef537b95e19b2cb552195d8bfe7"><span class="ne-text"> (D) 宽度为302px 高度为252px</span></li></ul><p id="73e574d35139f8ec2d08dd2dce5c3efd" class="ne-p"><span class="ne-text">w  200 +   150   + 2   =  352</span></p><p id="6064c109d8ff412bec6d77199d1ddf50" class="ne-p"><span class="ne-text">h   200 +  100 +  6   =  306</span></p><p id="6a6a1806ec47d55c8b4d767974bc841d" class="ne-p"><br></p><div class="ne-quote"><p id="4e9a3e9d6adf48267faaa699bf36c3fe" class="ne-p"><span class="ne-text">解决方案【2】：设置box-sizing属性</span></p></div><pre><code>-moz-box-sizing: border-box;  /*Firefox3.5+*/-webkit-box-sizing: border-box; /*Safari3.2+*/-o-box-sizing: border-box; /*Opera9.6*/-ms-box-sizing: border-box; /*IE8*/box-sizing: border-box; /*W3C标准(IE9+，Safari5.1+,Chrome10.0+,Opera10.6+都符合box-sizing的w3c标准语法)*/</code></pre><p id="8ae3be472fc28a03cf5761fe64146f58" class="ne-p"><span class="ne-text" style="color: #121212">注意：box-sizing属性是CSS3的属性，IE低版本不支持，注意兼容性</span></p><p id="05121a1c196c4949e8fbc16f489374e1" class="ne-p"><span class="ne-text" style="color: #121212">参考：</span></p><ul class="ne-ul"><li id="6c64f2b92b3db6da9e28112b0c7b5e99"><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/box-sizing" data-href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/box-sizing" target="_blank" class="ne-link"><span class="ne-text">https://developer.mozilla.org/zh-CN/docs/Web/CSS/box-sizing</span></a></li><li id="c3eeb96cbccff5c7f4f910639dc47f26"><a href="https://www.zhihu.com/question/31031251" data-href="https://www.zhihu.com/question/31031251" target="_blank" class="ne-link"><span class="ne-text">https://www.zhihu.com/question/31031251</span></a></li></ul><h3 id="nknxQ"><span class="ne-text">内边距不影响盒子大小情况</span></h3><div class="ne-quote"><p id="48bfcda97c1090abc231bddaefdc9ba7" class="ne-p"><span class="ne-text">如果没有给一个盒子指定宽度， 此时，如果给这个盒子指定padding， 则不会撑开盒子。</span></p></div><h2 id="p28ou"><span class="ne-text">margin</span></h2><p id="b9cd49468404bed5db521d4cd4a9a4ab" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611552211186-1bc52b3c-f2d9-418b-99d8-582718465af1.png" width="475" id="V78Gu" class="ne-image"></p><p id="f82da73851a2f0d52d0c51aa2b4d5c82" class="ne-p"><span class="ne-text">margin属性用于设置外边距。  margin就是控制</span><strong><span class="ne-text">盒子和盒子之间的距离</span></strong></p><h3 id="wTOej"><span class="ne-text">padding综合</span></h3><table id="n1CCn" class="ne-table" style="width: 750px"><tbody><tr style="height: 33px"><td width="375"><p id="u844cb1e6" class="ne-p"><span class="ne-text">属性</span></p></td><td width="375"><p id="ua1522471" class="ne-p" style="text-align: left"><span class="ne-text">作用</span></p></td></tr><tr style="height: 33px"><td width="375"><p id="uc4fe543a" class="ne-p"><span class="ne-text">margin-left</span></p></td><td width="375"><p id="u7d0bfc42" class="ne-p" style="text-align: left"><span class="ne-text">左外边距</span></p></td></tr><tr style="height: 33px"><td width="375"><p id="ud9867846" class="ne-p"><span class="ne-text">margin-right</span></p></td><td width="375"><p id="uc1faecae" class="ne-p" style="text-align: left"><span class="ne-text">右外边距</span></p></td></tr><tr style="height: 33px"><td width="375"><p id="u3a6793c4" class="ne-p"><span class="ne-text">margin-top</span></p></td><td width="375"><p id="udf32b5cf" class="ne-p" style="text-align: left"><span class="ne-text">上外边距</span></p></td></tr><tr style="height: 33px"><td width="375"><p id="uff664e70" class="ne-p"><span class="ne-text">margin-bottom</span></p></td><td width="375"><p id="u3c77c338" class="ne-p" style="text-align: left"><span class="ne-text">下外边距</span></p></td></tr></tbody></table><p id="ffd339cb8367066aebcbff07969e5c70" class="ne-p"><span class="ne-text">margin值的简写 （复合写法）代表意思  跟 padding 完全相同。</span></p><h2 id="xn3UG"><span class="ne-text">display</span></h2><h3 id="iskUR"><span class="ne-text">什么是标签显示模式</span></h3><ul class="ne-ul"><li id="89a08160615f7bc0de3f74b3bcb1c9cf"><span class="ne-text">什么是标签的显示模式？<br /></span><span class="ne-text">标签以什么方式进行显示，比如div 自己占一行， 比如span 一行可以放很多个</span></li><li id="bf1f63ef35d5e7105cceaedaa8156536"><span class="ne-text">作用：<br /></span><span class="ne-text">我们网页的标签非常多，再不同地方会用到不同类型的标签，以便更好的完成我们的网页。</span></li><li id="19c249a9f17bcd78f1a0ccbec3dab83c"><span class="ne-text">标签的类型(分类)<br /></span><span class="ne-text">HTML标签一般分为块标签和行内标签两种类型，它们也称块元素和行内元素。</span></li></ul><h3 id="hK2nl"><span class="ne-text">块级元素(block-level)</span></h3><ul class="ne-ul"><li id="4b4928e7812cbb7c0c4c783aed635ed9"><span class="ne-text">例：</span></li></ul><pre><code>常见的块元素有&lt;h1&gt;~&lt;h6&gt;、&lt;p&gt;、&lt;div&gt;、&lt;ul&gt;、&lt;ol&gt;、&lt;li&gt;等，其中&lt;div&gt;标签是最典型的块元素。</code></pre><p id="3deaf2bc621f3577cbb913e0e1b27e50" class="ne-p"><br></p><ul class="ne-ul"><li id="4757984c4fb871c7d983bbd9af426d43"><span class="ne-text">块级元素的特点</span></li></ul><p id="59a0c9463618efc8d1990b4b74625e32" class="ne-p"><span class="ne-text">（1）比较霸道，自己独占一行</span></p><p id="4f5e01ecc1283dfadd396f9991d07089" class="ne-p"><span class="ne-text">（2）</span><span class="ne-text" style="background-color: #FADB14">高度，宽度、外边距以及内边距都可以控制</span><span class="ne-text">。</span></p><p id="373e8b457225bb93a4f89e1dee82f015" class="ne-p"><span class="ne-text">（3）宽度默认是容器（父级宽度）的100%</span></p><p id="b61df844563bb3d409e2197924f7c4ae" class="ne-p"><span class="ne-text">（4）是一个容器及盒子，里面可以放行内或者块级元素。</span></p><ul class="ne-ul"><li id="f733edd36ff4994b4e0955b53072d743"><span class="ne-text">只有 文字才 能组成段落  因此 p  里面不能放块级元素，特别是 p 不能放div</span></li><li id="d26fc0f5797995c7774c891ab4f6f2c2"><span class="ne-text">同理还有这些标签h1,h2,h3,h4,h5,h6,dt，他们都是</span><span class="ne-text" style="background-color: #FADB14">文字类块级标签，里面不能放其他块级元素</span><span class="ne-text">。</span></li></ul><h3 id="Ut6nc"><span class="ne-text">行内元素(inline-level)</span></h3><ul class="ne-ul"><li id="5052735a7226bc4b97ea6084eadcba86"><span class="ne-text">例：</span></li></ul><pre><code>常见的行内元素有&lt;a&gt;、&lt;strong&gt;、&lt;b&gt;、&lt;em&gt;、&lt;i&gt;、&lt;del&gt;、&lt;s&gt;、&lt;ins&gt;、&lt;u&gt;、&lt;span&gt;等，其中&lt;span&gt;标签最典型的行内元素。有的地方也成内联元素</code></pre><p id="438b5e985d85d249c9951bbd9ddb476e" class="ne-p"><br></p><ul class="ne-ul"><li id="5f0d2d02d21d01dc8213bbcb58211dd2"><span class="ne-text">行内元素的特点：</span></li></ul><p id="e42a2507e5459cae465a2838b2a3ea35" class="ne-p"><span class="ne-text">（1）相邻行内元素在一行上，一行可以显示多个。</span></p><p id="cc921f9e60be9f4bb13e88dfe7c89da4" class="ne-p"><span class="ne-text">（2）</span><span class="ne-text" style="background-color: #FADB14">高、宽直接设置是无效的</span><span class="ne-text">。</span></p><p id="a5a74e19eff289c7aeda8eaf8cbb8a18" class="ne-p"><span class="ne-text">（3）默认宽度就是它本身内容的宽度。</span></p><p id="c16ec105df6030002c0101359e231e5c" class="ne-p"><span class="ne-text">（4）</span><strong><span class="ne-text">行内元素只能容纳文本或则其他行内元素。</span></strong></p><ul class="ne-ul"><li id="4d6821870d1e2e4cf1ebc19120c2dd2a"><span class="ne-text">链接里面不能再放链接。</span></li><li id="e45d011ab4da6d7f498edebeff3a548a"><span class="ne-text">特殊情况a里面可以放块级元素，但是给a转换一下块级模式最安全。</span></li></ul><h3 id="IDdRF"><span class="ne-text">行内块元素（inline-block）</span></h3><ul class="ne-ul"><li id="39a6f44be52adfdc1d518bf15b74fe1b"><span class="ne-text">例：</span></li></ul><pre><code>在行内元素中有几个特殊的标签——&lt;img /&gt;、&lt;input /&gt;、&lt;td&gt;，可以对它们设置宽高和对齐属性，有些资料可能会称它们为行内块元素。</code></pre><p id="0dd916847200e446ef2e7492e2cdc4e2" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611551937533-f958d872-1942-4aee-8533-8671afa1dc82.png" width="608.5" id="BC5Jb" class="ne-image"></p><ul class="ne-ul"><li id="1f1ef48461f9100a9ba646144ca191ea"><span class="ne-text">行内块元素的特点：<br /></span><span class="ne-text">（1）和相邻行内元素（行内块）在一行上,但是</span><span class="ne-text" style="background-color: #FADB14">之间会有空白缝隙</span><span class="ne-text">。一行可以显示多个<br /></span><span class="ne-text">（2）默认宽度就是它本身内容的宽度。<br /></span><span class="ne-text">（3）</span><span class="ne-text" style="background-color: #FADB14">高度，行高、外边距以及内边距都可以控制</span><span class="ne-text">。</span></li></ul><h3 id="rK5xE"><span class="ne-text">display</span></h3><ul class="ne-ul"><li id="89f5af16d988948efc7fbe26a970a48b"><span class="ne-text">块转行内：display:inline;</span></li><li id="6dc33ba7cfc639f381667ff870c5d372"><span class="ne-text">行内转块：display:block;</span></li><li id="e9c6980a124fa80fedc36d9d69eec2b9"><span class="ne-text">块、行内元素转换为行内块： display: inline-block;</span></li></ul><p id="8c84626698c91d68e38edb269b092476" class="ne-p"><span class="ne-text">此阶段，我们只需关心这三个，其他的是我们后面的工作。</span></p><h2 id="AOfov"><span class="ne-text">盒模型的相关问题</span></h2><h3 id="Nb3xh"><span class="ne-text">块级盒子水平居中</span></h3><ul class="ne-ul"><li id="437cd4cffd0f54b1a9dc6dc31cdd24f0"><span class="ne-text">一个块级盒子实现水平居中必须：</span></li></ul><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="3cb4ea77bd5869bd3fe08cbfe7ebbc33"><span class="ne-text">盒子</span><span class="ne-text" style="background-color: #FADB14">必须指定了宽度</span><span class="ne-text">（width）</span></li><li id="d6a40ea3ecc6204f5521ef90715cc5b5"><span class="ne-text">然后就给</span><strong><span class="ne-text">左右的外边距都设置为auto</span></strong><span class="ne-text">，</span></li></ul></ul><p id="9786810a09167ebbff13ca70a9ca8e59" class="ne-p"><span class="ne-text">实际工作中常用这种方式进行网页布局，示例代码如下：</span></p><pre><code>.header&#123; width:960px; margin:0 auto;&#125;</code></pre><p id="5d37638b52a8e8a18251e14c0ac1eae2" class="ne-p"><span class="ne-text">常见的写法，以下下三种都可以。</span></p><ul class="ne-ul"><li id="6d1848e42521eb6ebc2eab3b4267e11c"><span class="ne-text">margin-left: auto;   margin-right: auto;</span></li><li id="9a5cd3c22438f4b405ca11cb209a9208"><span class="ne-text">margin: auto;</span></li><li id="eac29aeef9a15c2278a78eb80edff1a2"><span class="ne-text">margin: 0 auto;</span></li></ul><h3 id="nTwFa"><span class="ne-text">文字居中和盒子居中区别</span></h3><ol class="ne-ol"><li id="e910db0b669314404b209b4fe6440052"><span class="ne-text">盒子内的文字水平居中是  text-align: center,  </span><span class="ne-text" style="background-color: #FADB14">而且还可以让行内元素和行内块居中对齐</span></li><li id="2f6322dbcdb8f57a23a777aa93a99679"><span class="ne-text">块级盒子水平居中左右margin 改为 auto</span></li></ol><pre><code>text-align: center; /*  文字 行内元素 行内块元素水平居中 */margin: 10px auto;  /* 块级盒子水平居中  左右margin 改为 auto 就阔以了 上下margin都可以 */</code></pre><h3 id="8k8xB"><span class="ne-text">插入图片和背景图片区别</span></h3><ol class="ne-ol"><li id="2ce52b32ba2d31381d85168d74dd4211"><span class="ne-text">插入图片 我们用的最多 比如产品展示类  移动位置只能靠盒模型 padding margin</span></li><li id="9b91d6d8add70ec135e2bf2db9c283a1"><span class="ne-text">背景图片我们一般用于小图标背景 或者 超大背景图片  背景图片 只能通过  background-position</span></li></ol><pre><code>img &#123;          width: 200px;/* 插入图片更改大小 width 和 height */        height: 210px;        margin-top: 30px;  /* 插入图片更改位置 可以用margin 或padding  盒模型 */        margin-left: 50px; /* 插入当图片也是一个盒子 */    &#125; div &#123;        width: 400px;        height: 400px;        border: 1px solid purple;        background: #fff url(images/sun.jpg) no-repeat;        background-position: 30px 50px; /* 背景图片更改位置 我用 background-position */    &#125;</code></pre><h3 id="Pdv2Q"><span class="ne-text">清除元素的默认内外边距</span></h3><p id="8a6590d752c05cc7a7063f8d49a81435" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611552224242-7158d827-f872-4872-9c9d-598c846d74b9.png" width="537.5" id="mX9H5" class="ne-image"></p><p id="5ac4d743cebf72c649c0e1819516cb21" class="ne-p"><span class="ne-text">为了更灵活方便地控制网页中的元素，制作网页时，我们需要将元素的默认内外边距清除</span></p><p id="1c6943b223f9cbe41c41d6adbb93468c" class="ne-p"><span class="ne-text">代码：</span></p><pre><code>* &#123;   padding:0;         /* 清除内边距 */   margin:0;          /* 清除外边距 */&#125;</code></pre><p id="e7dfa241672cc4fb19f03d10d4abe302" class="ne-p"><br></p><ul class="ne-ul"><li id="99cbbfb0a8392e760a978ce3ebe48d89"><span class="ne-text">行内元素为了照顾兼容性， 尽量只设置左右内外边距， 不要设置上下内外边距。</span></li></ul><h3 id="RaoY5"><span class="ne-text">margin塌陷问题</span></h3><p id="dd543c9f345ee1ece37c051df01fd992" class="ne-p"><span class="ne-text">使用margin定义块元素的</span><strong><span class="ne-text">垂直外边距</span></strong><span class="ne-text">时，可能会出现外边距的合并。</span></p><div class="ne-quote"><p id="1ad377dbaaf5dd90e43f08508e95d40d" class="ne-p"><span class="ne-text">相邻块元素垂直外边距的合并</span></p></div><ul class="ne-ul"><li id="f630addbe363d41abaeab18b3930ee1e"><span class="ne-text">当上下相邻的两个块元素相遇时，如果上面的元素有下外边距margin-bottom</span></li><li id="ef6249e101ed2779e4f79840e2cd6f01"><span class="ne-text">下面的元素有上外边距margin-top，则他们之间的垂直间距不是margin-bottom与margin-top之和</span></li><li id="8b41c378b72995e706e74bd145bffa25"><strong><span class="ne-text">取两个值中的较大者</span></strong><span class="ne-text">这种现象被称为相邻块元素垂直外边距的合并（也称外边距塌陷）。</span></li></ul><p id="85633555814b639522d9b43aff72daec" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611549556832-735ecd9b-2e20-4413-a635-cedc3692442f.png" width="504" id="Xh86G" class="ne-image"></p><p id="efc378e9313574719b1994f3041394e7" class="ne-p"><strong><span class="ne-text">解决方案：</span></strong><strong><span class="ne-text" style="background-color: #FADB14">尽量给只给一个盒子添加margin值</span></strong><span class="ne-text">。</span></p><div class="ne-quote"><p id="3ac2d8bb3f362ecf7af03d75e490cc23" class="ne-p"><span class="ne-text">嵌套块元素垂直外边距的合并（塌陷）</span></p></div><ul class="ne-ul"><li id="f48f3c54537f3f88fe0d67192d22abc1"><span class="ne-text">对于两个嵌套关系的块元素，如果父元素没有上内边距及边框</span></li><li id="185b5033f3dde26a0b853e77c2b298c1"><span class="ne-text">父元素的上外边距会与子元素的上外边距发生合并</span></li><li id="83b8eb018eaac93605fa6bdbc55bedc9"><span class="ne-text">合并后的外边距为两者中的较大者</span></li></ul><p id="fd2ab7cac791d6551ec60aed341b41cf" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611549556894-4dc0bcd3-d5ed-467c-b725-bf4477a4e93c.png" width="504" id="IGgQt" class="ne-image"></p><p id="346586f3289b9f6716d564a6c29f0e83" class="ne-p"><strong><span class="ne-text">解决方案：</span></strong></p><ol class="ne-ol"><li id="facd0aef5c5b8e5b9ac705cd34cde1d0"><span class="ne-text">可以为父元素定义上边框。</span></li><li id="38fe1d73e2aacba786ce75234290ecda"><span class="ne-text">可以为父元素定义上内边距</span></li><li id="39585dd00016953d196179ffb4c437a9"><span class="ne-text">可以为父元素添加overflow:hidden。</span></li></ol><p id="804de09e7be716252fae4ea7171adfe6" class="ne-p"><span class="ne-text">还有其他方法，比如浮动、固定、绝对定位的盒子不会有问题，后面咱们再总结。。。</span></p><h3 id="JJYX2"><span class="ne-text">盒子模型布局稳定性</span></h3><ul class="ne-ul"><li id="4d65dcd3d034a343d8b98ed58060c363"><span class="ne-text">根据稳定性来分：按照 优先使用  宽度 （width）  其次 使用内边距（padding）    再次  外边距（margin）。</span></li><li id="e6a870579c41773a05091c7976d17d06"><span class="ne-text">margin 会有外边距合并 还有 ie6下面margin 加倍的bug（讨厌）所以最后使用。</span></li><li id="486a6af44f14fba2f4bf8a3786d8e078"><span class="ne-text">padding  会影响盒子大小， 需要进行加减计算（麻烦） 其次使用。</span></li><li id="e16ea833830f425a6e2b4f1865de948e"><span class="ne-text">width   没有问题，经常使用宽度剩余法 高度剩余法来做。</span></li></ul><h3 id="163a7388"><span class="ne-text">line-height的问题</span></h3><div class="ne-quote"><p id="a34d352388a29dfcf6de65f88ea9b1f9" class="ne-p"><span class="ne-text">【1】行高测量</span></p></div><p id="2c03a2b7fd64293043ff6cefd146d65a" class="ne-p"><span class="ne-text">行高的测量方法：</span></p><p id="19c3a75b19a867666a11b6e5f5b1cd12" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611549555568-b660d3a6-0153-453f-ae22-fc831f79d659.png" width="407" id="x9gll" class="ne-image"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611549555629-ba0bce7a-f7b1-49ff-89aa-c14496ccbcb6.png" width="408" id="nxHkv" class="ne-image"></p><div class="ne-quote"><p id="58b8fc7eaabe988fa6e371e7650d7107" class="ne-p"><span class="ne-text">【2】单行文本垂直居中</span></p></div><p id="51b9b25a2edc37518f00345a3313b06b" class="ne-p"><span class="ne-text">行高我们利用最多的一个地方是： 可以让单行文本在盒子中垂直居中对齐。</span></p><div class="ne-quote"><p id="af89ce2b5d40945c3346d2a91c7c0650" class="ne-p"><strong><span class="ne-text">文字的行高等于盒子的高度。</span></strong></p></div><p id="3e4bc506a9085bf4cd60a09c7f9f7e4a" class="ne-p"><span class="ne-text">这里情况些许复杂，开始学习，我们可以先从简单地方入手学会。</span></p><p id="554d2c5826a2d89b9c5e397e4c7e70e1" class="ne-p"><span class="ne-text">行高   =  上距离 +  内容高度  + 下距离</span></p><p id="643f7cdf1a6f02f27ba698ac5668282f" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611549555695-02bf584b-9ece-45fe-a081-52aaf565d20d.png" width="700" id="MtmuD" class="ne-image"></p><p id="3bc01b831d7f26166eade37c44905689" class="ne-p"><span class="ne-text">上距离和下距离总是相等的，因此文字看上去是垂直居中的。</span></p><p id="1bc83f7189819f709e9da1ea6669d02f" class="ne-p"><strong><span class="ne-text">行高和高度的三种关系</span></strong></p><ul class="ne-ul"><li id="53b38d91456bf8df5fc2fce675fbc288"><span class="ne-text">如果 行高 等 高度  文字会 垂直居中</span></li><li id="43ef6b9886ad131cf6aaef4737bd1f22"><span class="ne-text">如果行高 大于 高度   文字会 偏下</span></li><li id="e179c187a8654a8d4b1f5f5fbe7a8a1e"><span class="ne-text">如果行高小于高度   文字会  偏上</span></li></ul><h3 id="RmwDf"></h3></div>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
          <category> HTML+CSS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CSS字体和背景</title>
      <link href="/blog/sideak09lpko/"/>
      <url>/blog/sideak09lpko/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h2 id="WU1xa"><span class="ne-text">字体相关</span></h2><p id="ua093e460" class="ne-p"><br></p><h3 id="stiE1"><span class="ne-text">font-size</span></h3><ul class="ne-ul"><li id="8e43b3eea7f7b798e48bf1af27414841"><span class="ne-text">作用：<br /></span><span class="ne-text">font-size属性用于设置字号</span></li></ul><pre><code>p &#123;      font-size:20px; &#125;</code></pre><ul class="ne-ul"><li id="8bfa902392b2aeb8bfd1d8dd40e6609b"><span class="ne-text">单位：</span></li></ul><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="f4bf7008ed8b5bdd6fba01bd2d0577a2"><span class="ne-text">可以使用相对长度单位，也可以使用绝对长度单位。</span></li><li id="60e0817b239ec2884c905d56656f1943"><span class="ne-text">相对长度单位比较常用，推荐使用像素单位px，绝对长度单位使用较少。</span></li></ul></ul><p id="bd06cb1ec6cf54e3d7abaa019cb4cbf4" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611549554219-97b92fc6-0b55-4946-a903-080b2dfa44fa.png" width="637" id="qV5gw" class="ne-image"></p><p id="2c356f6322f61c7102e3f88cc2042fb1" class="ne-p"><strong><span class="ne-text">注意：</span></strong></p><ul class="ne-ul"><li id="fe97b200a8a2c2c6bb4e4d2bcbd9d1b3"><span class="ne-text">我们文字大小以后，基本就用px了，其他单位很少使用</span></li><li id="3acdedf95108e28d574be4b287a13c3f"><span class="ne-text">谷歌浏览器默认的文字大小为16px</span></li><li id="4bf467144a558303f4f85d9752995bbf"><span class="ne-text">但是不同浏览器可能默认显示的字号大小不一致，我们尽量给一个明确值大小，不要默认大小。一般给body指定整个页面文字的大小</span></li></ul><h3 id="rROy7"><span class="ne-text">font-family</span></h3><pre><code>p&#123; font-family:&quot;微软雅黑&quot;;&#125;</code></pre><ul class="ne-ul"><li id="5868d62378de2747bdad9788cabc69f0"><span class="ne-text">网页中常用的字体有宋体、微软雅黑、黑体等，例如将网页中所有段落文本的字体设置为微软雅黑</span></li><li id="ac0ad11168330a61c5aa46e9401f05d7"><span class="ne-text">可以同时指定多个字体，中间以逗号隔开，表示如果浏览器不支持第一个字体，则会尝试下一个，直到找到合适的字体， 如果都没有，则以我们电脑默认的字体为准。</span></li></ul><pre><code>p&#123;font-family: Arial,&quot;Microsoft Yahei&quot;, &quot;微软雅黑&quot;;&#125;</code></pre><div class="ne-quote"><p id="eb83b2f69b375ac6aef1e35b90ff08a2" class="ne-p"><span class="ne-text">常用技巧：</span></p><ol class="ne-ol"><li id="65ef063464b28f62823807c841a87ae4"><span class="ne-text">各种字体之间必须使用英文状态下的逗号隔开。</span></li><li id="39b6fcc3fbd63f03375f97c46f995679"><span class="ne-text">中文字体需要加英文状态下的引号，英文字体一般不需要加引号。当需要设置英文字体时，英文字体名必须位于中文字体名之前。</span></li><li id="cc68a00775015182ea05ef5f335dbb66"><span class="ne-text">如果字体名中包含空格、#、$等符号，则该字体必须加英文状态下的单引号或双引号，例如font-family: &quot;Times New Roman&quot;;。</span></li><li id="4c8ba9e7209d79bf037a46f0f51fc89a"><span class="ne-text">尽量使用系统默认字体，保证在任何用户的浏览器中都能正确显示。</span></li></ol></div><h3 id="TB5BW"></h3><div class="ne-quote"><p id="c6bb0d2aa68fcc325598c9cd38d411f1" class="ne-p"><span class="ne-text">CSS Unicode字体</span></p></div><ul class="ne-ul"><li id="a3b079f90095249452216ebdabf85f20"><span class="ne-text">为什么使用 Unicode字体</span></li></ul><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="5b6654582a3ee45dd48601b766e9e6db"><span class="ne-text">在 CSS 中设置字体名称，直接写中文是可以的。但是在文件编码（GB2312、UTF-8 等）不匹配时会产生乱码的错误。</span></li><li id="ac28e35bd8581d2bd5554b7db6acdd99"><span class="ne-text">xp 系统不支持 类似微软雅黑的中文。</span></li></ul></ul><ul class="ne-ul"><li id="1d62cc4a8dc3b5f3eb00ced601a57f73"><span class="ne-text">解决方案一： 你可以使用英文来替代。 比如</span><code class="ne-code"><span class="ne-text">font-family:&quot;Microsoft Yahei&quot;</span></code><span class="ne-text">。</span></li><li id="58f562c7e9a2e05fa6ed03132a12574b"><span class="ne-text">解决方案二： 在 CSS 直接使用 Unicode 编码来写字体名称可以避免这些错误。使用 Unicode 写中文字体名称，浏览器是可以正确的解析的，记住！是在CSS里面</span></li></ul><pre><code>font-family: &quot;\5FAE\8F6F\96C5\9ED1&quot;;   表示设置字体为“微软雅黑”。</code></pre><table id="UQOeB" class="ne-table" style="width: 634px"><tbody><tr style="height: 33px"><td width="211"><p id="ucf6e2cb8" class="ne-p"><span class="ne-text">字体名称</span></p></td><td width="211"><p id="u7afdb783" class="ne-p"><span class="ne-text">英文名称</span></p></td><td width="212"><p id="ueea774a4" class="ne-p"><span class="ne-text">Unicode 编码</span></p></td></tr><tr style="height: 33px"><td width="211"><p id="u9cd417cf" class="ne-p"><span class="ne-text">宋体</span></p></td><td width="211"><p id="u98a3c135" class="ne-p"><span class="ne-text">SimSun</span></p></td><td width="212"><p id="u368ae8f1" class="ne-p"><span class="ne-text">\5B8B\4F53</span></p></td></tr><tr style="height: 33px"><td width="211"><p id="u191f50ce" class="ne-p"><span class="ne-text">新宋体</span></p></td><td width="211"><p id="u7540a81a" class="ne-p"><span class="ne-text">NSimSun</span></p></td><td width="212"><p id="uca11cf31" class="ne-p"><span class="ne-text">\65B0\5B8B\4F53</span></p></td></tr><tr style="height: 33px"><td width="211"><p id="u8c31e834" class="ne-p"><span class="ne-text">黑体</span></p></td><td width="211"><p id="ueace5b20" class="ne-p"><span class="ne-text">SimHei</span></p></td><td width="212"><p id="u57d5de2c" class="ne-p"><span class="ne-text">\9ED1\4F53</span></p></td></tr><tr style="height: 33px"><td width="211"><p id="uf119efbd" class="ne-p"><span class="ne-text">微软雅黑</span></p></td><td width="211"><p id="udd05be5c" class="ne-p"><span class="ne-text">Microsoft YaHei</span></p></td><td width="212"><p id="u1f8e18fd" class="ne-p"><span class="ne-text">\5FAE\8F6F\96C5\9ED1</span></p></td></tr><tr style="height: 33px"><td width="211"><p id="u6f7b0e30" class="ne-p"><span class="ne-text">楷体_GB2312</span></p></td><td width="211"><p id="u140ceb6e" class="ne-p"><span class="ne-text">KaiTi_GB2312</span></p></td><td width="212"><p id="ud52232b6" class="ne-p"><span class="ne-text">\6977\4F53_GB2312</span></p></td></tr><tr style="height: 33px"><td width="211"><p id="u5ecea98b" class="ne-p"><span class="ne-text">隶书</span></p></td><td width="211"><p id="u8b3a52f2" class="ne-p"><span class="ne-text">LiSu</span></p></td><td width="212"><p id="ufdf09f77" class="ne-p"><span class="ne-text">\96B6\4E66</span></p></td></tr><tr style="height: 33px"><td width="211"><p id="ud46ec35b" class="ne-p"><span class="ne-text">幼园</span></p></td><td width="211"><p id="ufa48359a" class="ne-p"><span class="ne-text">YouYuan</span></p></td><td width="212"><p id="uc3a4f246" class="ne-p"><span class="ne-text">\5E7C\5706</span></p></td></tr><tr style="height: 33px"><td width="211"><p id="u5b2a7daf" class="ne-p"><span class="ne-text">华文细黑</span></p></td><td width="211"><p id="u6cf9b908" class="ne-p"><span class="ne-text">STXihei</span></p></td><td width="212"><p id="u07b704ac" class="ne-p"><span class="ne-text">\534E\6587\7EC6\9ED1</span></p></td></tr><tr style="height: 33px"><td width="211"><p id="u5741e7f8" class="ne-p"><span class="ne-text">细明体</span></p></td><td width="211"><p id="u66743664" class="ne-p"><span class="ne-text">MingLiU</span></p></td><td width="212"><p id="u71cec40e" class="ne-p"><span class="ne-text">\7EC6\660E\4F53</span></p></td></tr><tr style="height: 33px"><td width="211"><p id="u431c6120" class="ne-p"><span class="ne-text">新细明体</span></p></td><td width="211"><p id="u36208940" class="ne-p"><span class="ne-text">PMingLiU</span></p></td><td width="212"><p id="u6bf8af56" class="ne-p"><span class="ne-text">\65B0\7EC6\660E\4F53</span></p></td></tr></tbody></table><p id="a46319f729dd5fd84480af2537acb64c" class="ne-p"><span class="ne-text">为了照顾不同电脑的字体安装问题，我们尽量只使用宋体和微软雅黑中文字体</span></p><h3 id="hcJS6"><span class="ne-text">font-weight</span></h3><ul class="ne-ul"><li id="1cf7778ea7e35c4c0fabb72769f19a73"><span class="ne-text">在html中使用 b  和 strong 标签是文本加粗。</span></li><li id="73706be18f2409ee0534999843c78595"><span class="ne-text">可以使用CSS 来实现，但是CSS 是没有语义的。</span></li></ul><table id="uQDCQ" class="ne-table" style="width: 634px"><tbody><tr style="height: 33px"><td width="317"><p id="u36e05a7b" class="ne-p"><span class="ne-text">属性值</span></p></td><td width="317"><p id="u337f7186" class="ne-p" style="text-align: left"><span class="ne-text">描述</span></p></td></tr><tr style="height: 33px"><td width="317"><p id="u9bfc89b7" class="ne-p"><span class="ne-text">normal</span></p></td><td width="317"><p id="ua5f78f53" class="ne-p" style="text-align: left"><span class="ne-text">默认值（不加粗的）</span></p></td></tr><tr style="height: 33px"><td width="317"><p id="u5f3eb217" class="ne-p"><span class="ne-text">bold</span></p></td><td width="317"><p id="u1269b5e6" class="ne-p" style="text-align: left"><span class="ne-text">定义粗体（加粗的）</span></p></td></tr><tr style="height: 33px"><td width="317"><p id="ud0f7c24b" class="ne-p"><span class="ne-text">100~900</span></p></td><td width="317"><p id="u8ba9bbaa" class="ne-p" style="text-align: left"><span class="ne-text">400 等同于 normal，而 700 等同于 bold </span></p></td></tr></tbody></table><p id="18d7995e48948e1ccd3b2b7b41b15603" class="ne-p"><br></p><h3 id="psESq"><span class="ne-text">font-style</span></h3><ul class="ne-ul"><li id="c323f4844af6ba3ea71ac61ec503eb17"><span class="ne-text">在html中字体倾斜用 i  和 em 标签，</span></li><li id="9b0a13eab7d5582cb8e0745e3d32862c"><span class="ne-text">可以使用CSS 来实现，但是CSS 是没有语义的</span></li></ul><p id="3f462c871bb5608bd3e3de9860f8a52e" class="ne-p"><span class="ne-text">font-style属性用于定义字体风格，如设置斜体、倾斜或正常字体，其可用属性值如下：</span></p><table id="WhXxP" class="ne-table" style="width: 750px"><tbody><tr style="height: 33px"><td width="375"><p id="udc3ef5f1" class="ne-p"><span class="ne-text">属性</span></p></td><td width="375"><p id="u72f1bd92" class="ne-p" style="text-align: left"><span class="ne-text">作用</span></p></td></tr><tr style="height: 33px"><td width="375"><p id="u69aafc66" class="ne-p"><span class="ne-text">normal</span></p></td><td width="375"><p id="uf96287ca" class="ne-p" style="text-align: left"><span class="ne-text">默认值，浏览器会显示标准的字体样式  font-style: normal;</span></p></td></tr><tr style="height: 33px"><td width="375"><p id="u5e8582d3" class="ne-p"><span class="ne-text">italic</span></p></td><td width="375"><p id="u60cd0133" class="ne-p" style="text-align: left"><span class="ne-text">浏览器会显示斜体的字体样式。</span></p></td></tr></tbody></table><p id="4da476ca833af4498080dd5a7fce0e0c" class="ne-p"><br></p><h3 id="PcpGh"><span class="ne-text">font综合设置</span></h3><ul class="ne-ul"><li id="34c5903b2de0ee158f7ce2d512b7a39b"><span class="ne-text">基本语法格式如下：</span></li></ul><pre><code>选择器 &#123;   font: font-style  font-weight  font-size/line-height  font-family;&#125;</code></pre><ul class="ne-ul"><li id="f72b059c56b8dfe0e2f3f73428678421"><span class="ne-text">使用font属性时，必须按上面语法格式中的顺序书写，不能更换顺序，各个属性以</span><strong><span class="ne-text">空格</span></strong><span class="ne-text">隔开。</span></li><li id="07fa0204254ed683cae615d30feca2bb"><span class="ne-text">其中不需要设置的属性可以省略（取默认值），但必须保留font-size和font-family属性，否则font属性将不起作用。</span></li></ul><h3 id="ngzBC"><span class="ne-text">color</span></h3><ul class="ne-ul"><li id="059578d93fd28a83241f555b5b2bda11"><span class="ne-text">作用：color属性用于</span><span class="ne-text" style="background-color: #FADB14">定义文本的颜色</span><span class="ne-text">，</span></li><li id="085bbd251f449a8805330557aa351a18"><span class="ne-text">一般选用十六进制的</span></li><li id="43c49596b43bde17e0587ed25994aa56"><span class="ne-text">其取值方式有如下3种：</span></li></ul><table id="sYGFx" class="ne-table" style="width: 568px"><tbody><tr style="height: 33px"><td width="284"><p id="u7046a06f" class="ne-p" style="text-align: left"><span class="ne-text">表示表示</span></p></td><td width="284"><p id="ud5955bb3" class="ne-p" style="text-align: left"><span class="ne-text">属性值</span></p></td></tr><tr style="height: 33px"><td width="284"><p id="u56c1d57c" class="ne-p" style="text-align: left"><span class="ne-text">预定义的颜色值</span></p></td><td width="284"><p id="uf3402dda" class="ne-p" style="text-align: left"><span class="ne-text">red，green，blue，还有我们的御用色 pink</span></p></td></tr><tr style="height: 33px"><td width="284"><p id="u1697ed52" class="ne-p" style="text-align: left"><span class="ne-text">十六进制</span></p></td><td width="284"><p id="u762f5640" class="ne-p" style="text-align: left"><span class="ne-text">#FF0000，#FF6600，#29D794</span></p></td></tr><tr style="height: 33px"><td width="284"><p id="u33cb846c" class="ne-p" style="text-align: left"><span class="ne-text">RGB代码</span></p></td><td width="284"><p id="u4e97f8d7" class="ne-p" style="text-align: left"><span class="ne-text">rgb(255,0,0)或rgb(100%,0%,0%)</span></p></td></tr></tbody></table><h3 id="zHk1x"><span class="ne-text">text-align</span></h3><ul class="ne-ul"><li id="8f5826a4c479bb4f7edc8eaecf54db0c"><span class="ne-text">文本水平对齐方式：text-align属性用于设置文本内容的水平对齐，相当于html中的align对齐属性</span></li><li id="d97698018ce0b800138714770c2beb91"><span class="ne-text">其可用属性值如下：</span></li></ul><table id="CM1ef" class="ne-table" style="width: 750px"><tbody><tr style="height: 33px"><td width="375"><p id="u54a9c299" class="ne-p"><span class="ne-text">属性</span></p></td><td width="375"><p id="uc438d3b8" class="ne-p" style="text-align: center"><span class="ne-text">解释</span></p></td></tr><tr style="height: 33px"><td width="375"><p id="u2faf7c1d" class="ne-p"><span class="ne-text">left</span></p></td><td width="375"><p id="u69b6cf5d" class="ne-p" style="text-align: center"><span class="ne-text">左对齐（默认值）</span></p></td></tr><tr style="height: 33px"><td width="375"><p id="u28295ba4" class="ne-p"><span class="ne-text">right</span></p></td><td width="375"><p id="u67a9311a" class="ne-p" style="text-align: center"><span class="ne-text">右对齐</span></p></td></tr><tr style="height: 33px"><td width="375"><p id="u7201017c" class="ne-p"><span class="ne-text">center</span></p></td><td width="375"><p id="u0ccc7a27" class="ne-p" style="text-align: center"><span class="ne-text">居中对齐</span></p></td></tr></tbody></table><ul class="ne-ul"><li id="7420a6a71abdab22492ee6119eb94584"><span class="ne-text">注意：<br /></span><span class="ne-text">是让盒子里面的内容水平居中， 而不是让盒子居中对齐</span></li></ul><h3 id="80aPj"><span class="ne-text">TODO: line-height</span></h3><ul class="ne-ul"><li id="f8abec0cd94b9e7e61de78d98a139763"><span class="ne-text">行间距：line-height属性用于设置行间距，就是行与行之间的距离，即字符的垂直间距，一般称为行高。</span></li><li id="239976a5b6452d80c8bd3ebe142f4958"><span class="ne-text">单位：line-height常用的属性值单位有三种，分别为像素px，相对值em和百分比%，实际工作中使用最多的是像素px</span></li></ul><pre><code>一般情况下，行距比字号大7.8像素左右就可以了。line-height: 24px;</code></pre><h3 id="gITg7"><span class="ne-text">text-indent</span></h3><ul class="ne-ul"><li id="ce1e703598265ce3ecc212147c55087c"><span class="ne-text">作用：text-indent属性用于设置首行文本的缩进，</span></li><li id="39d76db4ee50f2b57926f2c2ed34c1ba"><span class="ne-text">其属性值可为不同单位的数值、em字符宽度的倍数、或相对于浏览器窗口宽度的百分比%，允许使用负值,</span></li><li id="363d39e17b84fbfde77093413c6f3c0d"><span class="ne-text">建议使用em作为设置单位，</span><strong><span class="ne-text">1em 就是一个字的宽度   如果是汉字的段落， 1em 就是一个汉字的宽度</span></strong></li></ul><pre><code>p &#123;      /*行间距*/      line-height: 25px;      /*首行缩进2个字  em  1个em 就是1个字的大小*/      text-indent: 2em;   &#125;</code></pre><h3 id="SCoxC"><span class="ne-text">text-decoration</span></h3><ul class="ne-ul"><li id="f7cf032e274e467fac30577bc24ef0c3"><span class="ne-text">text-decoration   通常我们用于给链接修改装饰效果</span></li></ul><table id="rkvxe" class="ne-table" style="width: 750px"><tbody><tr style="height: 33px"><td width="375"><p id="ube459a65" class="ne-p"><span class="ne-text">值</span></p></td><td width="375"><p id="u2bcb4e37" class="ne-p"><span class="ne-text">描述</span></p></td></tr><tr style="height: 33px"><td width="375"><p id="u5464b817" class="ne-p"><span class="ne-text">none</span></p></td><td width="375"><p id="u467b833c" class="ne-p"><span class="ne-text">默认。定义标准的文本。 取消下划线（最常用）</span></p></td></tr><tr style="height: 33px"><td width="375"><p id="u7bb3c8cb" class="ne-p"><span class="ne-text">underline</span></p></td><td width="375"><p id="u43b1baa6" class="ne-p"><span class="ne-text">定义文本下的一条线。下划线 也是我们链接自带的（常用）</span></p></td></tr><tr style="height: 33px"><td width="375"><p id="u1330d5eb" class="ne-p"><span class="ne-text">overline</span></p></td><td width="375"><p id="u48f0c42d" class="ne-p"><span class="ne-text">定义文本上的一条线。（不用）</span></p></td></tr><tr style="height: 33px"><td width="375"><p id="ub1992c55" class="ne-p"><span class="ne-text">line-through</span></p></td><td width="375"><p id="ub35bb2db" class="ne-p"><span class="ne-text">定义穿过文本下的一条线。（不常用）</span></p></td></tr></tbody></table><p id="fee0cf74a4f0b39a790d3cf20cf9ce37" class="ne-p"><br></p><h2 id="mhb00"><span class="ne-text">背景相关</span></h2><h3 id="kZ6AP"><span class="ne-text">background-color</span></h3><ul class="ne-ul"><li id="9f8ec23b1a989c1ff41e8daf52dd8d1a"><span class="ne-text">background-color: 颜色值;</span></li><li id="f29ca935a52510bc930afbafe808ace8"><span class="ne-text">默认的值是 transparent  透明的</span></li></ul><h3 id="knP1Y"><span class="ne-text">background-image</span></h3><ul class="ne-ul"><li id="2fccad699df5122aa563c1fdd0afb97e"><span class="ne-text">background-image : url(images/demo.png);</span></li><li id="d728a04db20c8f3e1e4c1f0e16649751"><span class="ne-text">背景图片后面的地址，url不要加引号。</span></li></ul><pre><code>background-image : none | url (url)</code></pre><table id="LuvYR" class="ne-table" style="width: 750px"><tbody><tr style="height: 33px"><td width="375"><p id="u3fd3515c" class="ne-p"><span class="ne-text">参数</span></p></td><td width="375"><p id="ue87ae9cd" class="ne-p" style="text-align: center"><span class="ne-text">作用</span></p></td></tr><tr style="height: 33px"><td width="375"><p id="u9fcc575f" class="ne-p"><span class="ne-text">none</span></p></td><td width="375"><p id="uf66eb0fb" class="ne-p" style="text-align: center"><span class="ne-text">无背景图（默认的）</span></p></td></tr><tr style="height: 33px"><td width="375"><p id="u6fbf4a5d" class="ne-p"><span class="ne-text">url</span></p></td><td width="375"><p id="uddc1f659" class="ne-p" style="text-align: center"><span class="ne-text">使用绝对或相对地址指定背景图像</span></p></td></tr></tbody></table><p id="0a5011efb1d57bc6cd5c29975df1dd16" class="ne-p"><br></p><h3 id="VdPjT"><span class="ne-text">background-repeat</span></h3><ul class="ne-ul"><li id="bb9d397c7f4e3366ff713dcf858efe2b"><span class="ne-text">语法：</span></li></ul><pre><code>background-repeat : repeat | no-repeat | repeat-x | repeat-y</code></pre><table id="XNa51" class="ne-table" style="width: 750px"><tbody><tr style="height: 33px"><td width="375"><p id="u4b8d4c02" class="ne-p"><span class="ne-text">参数</span></p></td><td width="375"><p id="u082b9d44" class="ne-p" style="text-align: center"><span class="ne-text">作用</span></p></td></tr><tr style="height: 33px"><td width="375"><p id="u4f0b70f8" class="ne-p"><span class="ne-text">repeat</span></p></td><td width="375"><p id="uf08131b8" class="ne-p" style="text-align: center"><span class="ne-text">背景图像在纵向和横向上平铺（默认的）</span></p></td></tr><tr style="height: 33px"><td width="375"><p id="u11e204da" class="ne-p"><span class="ne-text">no-repeat</span></p></td><td width="375"><p id="u25c70515" class="ne-p" style="text-align: center"><span class="ne-text">背景图像不平铺</span></p></td></tr><tr style="height: 33px"><td width="375"><p id="u1efa323b" class="ne-p"><span class="ne-text">repeat-x</span></p></td><td width="375"><p id="ub7636bc6" class="ne-p" style="text-align: center"><span class="ne-text">背景图像在横向上平铺</span></p></td></tr><tr style="height: 33px"><td width="375"><p id="u06ff26ce" class="ne-p"><span class="ne-text">repeat-y</span></p></td><td width="375"><p id="u451b353e" class="ne-p" style="text-align: center"><span class="ne-text">背景图像在纵向平铺</span></p></td></tr></tbody></table><h3 id="maWIg"><span class="ne-text">background-position</span></h3><ul class="ne-ul"><li id="cd4f25d2ca7a9b98807393b7582106de"><span class="ne-text">语法：</span></li></ul><pre><code>background-position : length || lengthbackground-position : position || position</code></pre><ul class="ne-ul"><li id="944f0ffcab9c21fb077b6ac07e5f50b4"><span class="ne-text">参数解释</span></li></ul><table id="wKMRs" class="ne-table" style="width: 750px"><tbody><tr style="height: 33px"><td width="375"><p id="u16aeb696" class="ne-p"><span class="ne-text">参数</span></p></td><td width="375"><p id="u6bfb5a48" class="ne-p" style="text-align: center"><span class="ne-text">值</span></p></td></tr><tr style="height: 33px"><td width="375"><p id="u6f7a4e9f" class="ne-p"><span class="ne-text">length</span></p></td><td width="375"><p id="ud6a2f4dc" class="ne-p" style="text-align: center"><span class="ne-text">百分数 | 由浮点数字和单位标识符组成的长度值</span></p></td></tr><tr style="height: 33px"><td width="375"><p id="u682d50cf" class="ne-p"><span class="ne-text">position</span></p></td><td width="375"><p id="u28e44348" class="ne-p" style="text-align: center"><span class="ne-text">top | center | bottom | left | center | right   方位名词</span></p></td></tr></tbody></table><p id="cdd7dfc8797842cfa0b6e1ca1f60b7ee" class="ne-p"><br></p><ul class="ne-ul"><li id="eb4538599e63d4221bed5057ae516cf2"><span class="ne-text">必须先指定background-image属性</span></li><li id="6ec962b18a0eb4c67c5f9c0f74470f08"><span class="ne-text">position 后面是x坐标和y坐标。 可以使用方位名词或者 精确单位。</span></li><li id="16eb9a84c4cf05516a300ad858051391"><span class="ne-text">如果指定两个值，两个值都是方位名字，则两个值前后顺序无关，比如left  top和top  left效果一致</span></li><li id="c11f599edbac51ec6d4818f2ff124784"><span class="ne-text">如果只指定了一个方位名词，另一个值默认居中对齐。</span></li><li id="bfad8a29d772f8aa9e0724375d400844"><span class="ne-text">如果position 后面是精确坐标， 那么第一个，肯定是 x  第二的一定是y</span></li><li id="8430d1c9203e531bbee190d951a161ce"><span class="ne-text">如果只指定一个数值,那该数值一定是x坐标，另一个默认垂直居中</span></li><li id="6330bd3aabd30ec5525f9169dcbe96c8"><span class="ne-text">如果指定的两个值是 精确单位和方位名字混合使用，则第一个值是x坐标，第二个值是y坐标</span></li><li id="089f1d235d246a97cad4da7b403dc0b9"><strong><span class="ne-text">实际工作用的最多的，就是背景图片居中对齐了。</span></strong></li></ul><h3 id="WcAYx"><span class="ne-text">background-attachment</span></h3><ul class="ne-ul"><li id="3215b38962dd6157e3269b26cb66a02a"><span class="ne-text">背景附着就是解释背景是滚动的还是固定的</span></li><li id="683bd0554e204723f4ad10c6bda06b2a"><span class="ne-text">语法：</span></li></ul><pre><code>background-attachment : scroll | fixed</code></pre><table id="O1Ml4" class="ne-table" style="width: 750px"><tbody><tr style="height: 33px"><td width="375"><p id="u04ec1eeb" class="ne-p"><span class="ne-text">参数</span></p></td><td width="375"><p id="u27cd12ce" class="ne-p" style="text-align: center"><span class="ne-text">作用</span></p></td></tr><tr style="height: 33px"><td width="375"><p id="u5d59f1fb" class="ne-p"><span class="ne-text">scroll</span></p></td><td width="375"><p id="u57d9a984" class="ne-p" style="text-align: center"><span class="ne-text">背景图像是随对象内容滚动</span></p></td></tr><tr style="height: 33px"><td width="375"><p id="uedb2a723" class="ne-p"><span class="ne-text">fixed</span></p></td><td width="375"><p id="u1f85d788" class="ne-p" style="text-align: center"><span class="ne-text">背景图像固定</span></p></td></tr></tbody></table><h3 id="1D8b9"><span class="ne-text">background-size</span></h3><div class="ne-quote"><p id="4bca5d850aec85fc6407cffcb8478047" class="ne-p"><span class="ne-text">background-size 属性规定背景图像的尺寸</span></p></div><ul class="ne-ul"><li id="fcf1c81b4928af3b262fd2df0f9861ab"><span class="ne-text">两个参数：分别是长度和宽度</span></li><li id="d30026ded0e900d31e22fb76dd154b08"><span class="ne-text">一个参数：就是宽度，高度跟着宽度等比拉伸</span></li><li id="b39544135268299b015c4182b651d462"><strong><span class="ne-text">也可以是百分比，相对父盒子</span></strong></li><li id="9dbed52c124ad259c3c504b05fd55727"><span class="ne-text">cover：类似按着右下角光标，把背景图像扩展至足够大，以使背景图像完全覆盖背景区域。</span></li><li id="58b0a8cbb55fa54b2010b423455029a2"><span class="ne-text">contain：把图像扩展至最大尺寸，以使其宽度和高度完全适应内容区域</span></li></ul><h3 id="Z6U90"><span class="ne-text">背景简写</span></h3><ul class="ne-ul"><li id="b00a2ace8788e67fb85f42bf1f53e816"><span class="ne-text">background：属性的值的书写顺序官方</span><span class="ne-text" style="background-color: #FADB14">并没有强制标准</span><span class="ne-text">的。</span></li><li id="3f72d20b2c0454a04afde43924d6e188"><span class="ne-text">background: 背景</span><span class="ne-text" style="color: #F5222D">颜色</span><span class="ne-text"> 背景</span><span class="ne-text" style="color: #F5222D">图片地址</span><span class="ne-text"> 背景</span><span class="ne-text" style="background-color: transparent; color: #F5222D">平铺</span><span class="ne-text"> 背景</span><span class="ne-text" style="color: #F5222D">滚动</span><span class="ne-text"> 背景</span><span class="ne-text" style="color: #F5222D">位置</span><span class="ne-text">;</span></li><li id="bef72971c1c3b01818f649ac15c9eb1d"><span class="ne-text">语法：</span></li></ul><pre><code>background: blue url(image.jpg) repeat-y  scroll center top ;</code></pre><p id="738c50709a978b35759842a1bb3b1d7e" class="ne-p"><br></p><h3 id="zSOq3"><span class="ne-text">背景透明(CSS3)</span></h3><ul class="ne-ul"><li id="1d94db94af3eaac4c290c401d74ac8b5"><span class="ne-text">语法：</span></li></ul><pre><code>background: rgba(0, 0, 0, 0);</code></pre><ul class="ne-ul"><li id="914da85d55c7e7d3299bdc60ea3ff4cb"><span class="ne-text">最后一个参数是alpha 透明度  取值范围 0~1之间</span></li><li id="50115bc31d1c1cdf7c4becb7ae4307f7"><span class="ne-text">我们习惯把0.3 的 0 省略掉  这样写  background: rgba(0, 0, 0, .3);</span></li><li id="ec156db933637e0d0a37c74da3bb4f1b"><span class="ne-text">注意：  背景半透明是指盒子背景半透明， 盒子里面的内容不受影响</span></li><li id="3d2dbe3de60b5a9ea2e6fb4d3cf6265b"><span class="ne-text">因为是CSS3 ，所以 低于 ie9 的版本是不支持的。</span></li></ul><p id="62d74c5b709174b23bc31c244acba0a9" class="ne-p"><br></p><p id="374da716b00bcaa399985b4d9756ed1c" class="ne-p"><br></p></div>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
          <category> HTML+CSS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>HTML5总结</title>
      <link href="/blog/vxz6aq7m0szt/"/>
      <url>/blog/vxz6aq7m0szt/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h2 id="ZkzlO"><span class="ne-text">HTML5</span></h2><div data-type="info" class="ne-alert"><p id="5f2311a63014ef8aea05ee4a4b4a1ddc" class="ne-p"><span class="ne-text">新版本的 HTML 语言，定义了新的标签、特性和属性</span></p></div><h3 id="8MvVB"><span class="ne-text">常用文档</span></h3><div class="ne-quote"><p id="f82a9e7df8b21eef78cf9ab241036a96" class="ne-p"><span class="ne-text">W3C :  </span><a href="http://www.w3school.com.cn/" data-href="http://www.w3school.com.cn/" target="_blank" class="ne-link"><span class="ne-text">http://www.w3school.com.cn/</span></a></p><p id="a9693ce5572587f78832ec6c5caea27e" class="ne-p"><span class="ne-text">MDN: </span><a href="https://developer.mozilla.org/zh-CN/" data-href="https://developer.mozilla.org/zh-CN/" target="_blank" class="ne-link"><span class="ne-text">https://developer.mozilla.org/zh-CN/</span></a></p><p id="6e87e3fb9d2d879b4e89b41f01e346a0" class="ne-p"><span class="ne-text">菜鸟：</span><a href="https://www.runoob.com/" data-href="https://www.runoob.com/" target="_blank" class="ne-link"><span class="ne-text">https://www.runoob.com/</span></a></p></div><h3 id="SAKcC"><span class="ne-text">扩展的内容</span></h3><ul class="ne-ul"><li id="2576dd5e70338b5ab236655dd7140dd0"><span class="ne-text">语义化标签</span></li><li id="cc85e1a4dfedecc807b62ad17cb3e3fe"><span class="ne-text">本地存储</span></li><li id="b1fad9da0de12a43a6e61f0fb8a01426"><span class="ne-text">兼容特性</span></li><li id="a80caa2dac765fbc4feb7e5720dfd1cf"><span class="ne-text">2D、3D</span></li><li id="56c7a854bf7023b5175df6b51925509a"><span class="ne-text">动画、过渡</span></li><li id="70cdba570bd2326cc35ba111550bad66"><span class="ne-text">CSS3 特性</span></li><li id="3b740b119c3124f163867dc45e2c3b55"><span class="ne-text">性能与集成</span></li></ul><h2 id="B8GzM"><span class="ne-text">HTML5文档结构/语义化标签</span></h2><p id="fd03a18ba6e17c41c78082ab3295e7ad" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616663386514-c6d53c70-d47f-4e40-b6f8-4a0f0596489b.png" width="334.5" id="lgs5S" class="ne-image"></p><ul class="ne-ul"><li id="f45bbd7e39f254637aaa60fc3ef0dc05"><a href="https://www.jianshu.com/p/c41b88217834" data-href="https://www.jianshu.com/p/c41b88217834" target="_blank" class="ne-link"><span class="ne-text">https://www.jianshu.com/p/c41b88217834</span></a></li><li id="06dd8082656e33ab385b9b4e4f82068e"><a href="https://juejin.cn/post/6844903544995184653" data-href="https://juejin.cn/post/6844903544995184653" target="_blank" class="ne-link"><span class="ne-text">https://juejin.cn/post/6844903544995184653</span></a></li></ul><h2 id="8aB2g"><span class="ne-text">&lt;!DOCTYPE&gt;</span></h2><ul class="ne-ul"><li id="d1e82340b404562616c95978ef587888"><span class="ne-text">html5的文档类型声明：声明位于文档中的最前面的位置，处于  标签之前。此标签可告知浏览器文档使用哪种 HTML 或 XHTML 规范。</span></li><li id="e06797b56fd2a8025d6c5b6741dff4fb"><span class="ne-text" style="background-color: transparent">一些老网站可能用的还是老版本的文档类型比如 XHTML之类的，但是我们学的是HTML5,而且HTML5的文档类型兼容很好(向下兼容的原则)</span></li></ul><h2 id="uWDQh"><span class="ne-text">charset</span></h2><ul class="ne-ul"><li id="03f8547414a772599060d12b5e0b16b2"><span class="ne-text">html5文档编码格式的指定</span></li></ul><pre><code>&lt;meta charset=&quot;UTF-8&quot; /&gt;</code></pre><div class="ne-quote"><p id="520f6765beab0b82f6020b9f64bbdc62" class="ne-p"><span class="ne-text">字符集(Character set)是多个字符的集合。</span></p><p id="f44de8225c3ae022a5888e8700666f7d" class="ne-p"><span class="ne-text">计算机要准确的处理各种字符集文字，需要进行字符编码，以便计算机能够识别和存储各种文字。</span></p></div><p id="f1615e0cc70e5b86af5393e9cc72be40" class="ne-p"><span class="ne-text">utf-8是目前最常用的字符集编码方式，常用的字符集编码方式还有gbk和gb2312。</span></p><ul class="ne-ul"><li id="f7cbd6b361453e85e7e2420b1daec0bb"><span class="ne-text">gb2312 简单中文  包括6763个汉字</span></li><li id="6f945bfea92cb04029853be612934b35"><span class="ne-text">BIG5   繁体中文 港澳台等用</span></li><li id="7943dadd5c0b456f85a054c440a84e93"><span class="ne-text">GBK包含全部中文字符    是GB2312的扩展，加入对繁体字的支持，兼容GB2312</span></li><li id="e91d1cc50d349f88823aad50d6aaf115"><span class="ne-text">UTF-8则基本包含全世界所有国家需要用到的字符</span></li></ul><h2 id="uKwWB"><span class="ne-text">多媒体音频标签</span></h2><ol class="ne-ol"><li id="df329d3ea76bedef62cea5aafe922c6a"><span class="ne-text">多媒体标签有两个，分别是</span></li></ol><ul class="ne-ul"><li id="ba194af62a61a209391e330173faa070"><span class="ne-text">音频  -- </span><code class="ne-code"><span class="ne-text">audio</span></code></li><li id="996462f3326a9f962b8f3db13378cb1d"><span class="ne-text">视频  -- </span><code class="ne-code"><span class="ne-text">video</span></code></li></ul><ol start="2" class="ne-ol"><li id="924aa3218a69542dff9e67d340cf5758"><code class="ne-code"><span class="ne-text">audio</span></code><span class="ne-text"> 标签说明</span></li></ol><ul class="ne-ul"><li id="0c70170019bc3e0fba044da599125975"><span class="ne-text">可以在不使用标签的情况下，也能够原生的支持音频格式文件的播放，</span></li><li id="a083cd1beac4d4a4d753746bab961cd4"><span class="ne-text">但是：播放格式是有限的</span></li></ul><ol start="3" class="ne-ol"><li id="37114ce1b72c417f46901f8ed7a9c9ea"><span class="ne-text">audio 支持的音频格式</span></li></ol><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="fa4749fc93a863b2fd24daf66577991b"><span class="ne-text">audio 目前支持三种格式</span></li></ul></ul><ol start="4" class="ne-ol"><li id="cddae4aa81f1abe4eecc459b90949b24"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1615560874331-7786480d-ad33-403e-976d-73e235a0f3ec.png" width="589.5" id="RY5qn" class="ne-image"></li><li id="69c380758e7954808541f645e8961074"><span class="ne-text">audio 的参数</span><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1615560883989-c202ee16-7e45-4c86-ac47-3e3ba07fc2a7.png" width="601.5" id="jl5Sy" class="ne-image"></li></ol><p id="d09cbaad74a33137afc660c975ff3051" class="ne-p"><span class="ne-text">5、audio 代码演示</span></p><pre><code>&lt;body&gt;  &lt;!-- 注意：在 chrome 浏览器中已经禁用了 autoplay 属性 --&gt;  &lt;!-- &lt;audio src=&quot;./media/snow.mp3&quot; controls autoplay&gt;&lt;/audio&gt; --&gt;  &lt;!--     因为不同浏览器支持不同的格式，所以我们采取的方案是这个音频准备多个文件   --&gt;  &lt;audio controls&gt;    &lt;source src=&quot;./media/snow.mp3&quot; type=&quot;audio/mpeg&quot; /&gt;  &lt;/audio&gt;&lt;/body&gt;</code></pre><h2 id="gfSCR"><span class="ne-text">多媒体视频标签</span></h2><ol class="ne-ol"><li id="06e83d4275eec88014e5e02c639395b1"><span class="ne-text">video 视频标签</span></li></ol><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="9952ba70d653f33fde3ba24ec195918b"><span class="ne-text">目前支持三种格式</span></li></ul></ul><ol start="2" class="ne-ol"><li id="815508b07e5037fb06d4750cd6b78da3"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1615560894436-db88d851-871b-4758-9b78-9b9892711139.png" width="605.5" id="LTerj" class="ne-image"></li><li id="864d706f7cf4dd51f52d4fd976647bbb"><span class="ne-text">语法格式</span></li></ol><pre><code>&lt;video src=&quot;./media/video.mp4&quot; controls=&quot;controls&quot;&gt;&lt;/video&gt;</code></pre><ol class="ne-ol"><li id="3db938a7697face04ccb25872a80d2d7"><span class="ne-text">video 参数</span><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1615560905874-4a6cc88d-8941-4f8c-9c89-05ce01e229fb.png" width="596.5" id="cVVsr" class="ne-image"></li><li id="ad0e24959eca689b28d12891f6d26705"><span class="ne-text">video 代码演示</span></li></ol><pre><code>&lt;body&gt;  &lt;!-- &lt;video src=&quot;./media/video.mp4&quot; controls=&quot;controls&quot;&gt;&lt;/video&gt; --&gt;  &lt;!-- 谷歌浏览器禁用了自动播放功能，如果想自动播放，需要添加 muted 属性 --&gt;  &lt;video controls=&quot;controls&quot; autoplay muted loop poster=&quot;./media/pig.jpg&quot;&gt;    &lt;source src=&quot;./media/video.mp4&quot; type=&quot;video/mp4&quot;&gt;    &lt;source src=&quot;./media/video.ogg&quot; type=&quot;video/ogg&quot;&gt;  &lt;/video&gt;&lt;/body&gt;</code></pre><ol class="ne-ol"><li id="98177e61ec71e15abae90eb7144ef5ac"><span class="ne-text">多媒体标签总结</span></li></ol><ul class="ne-ul"><li id="82e44acec12dbcd2169ae9ec80c5cab2"><span class="ne-text">音频标签与视频标签使用基本一致</span></li><li id="db1a6c5b6b0f06a9084137509f4e0fa3"><span class="ne-text">多媒体标签在不同浏览器下情况不同，存在兼容性问题</span></li><li id="a4aa2e20bab7877979128818300defc8"><span class="ne-text">谷歌浏览器把音频和视频标签的自动播放都禁止了</span></li><li id="9d3b339ecaead5270fa379ca944773da"><span class="ne-text">谷歌浏览器中视频添加 muted 标签可以自己播放</span></li><li id="7807befe0e4644cde46c9c80ddeab9d8"><span class="ne-text">注意：重点记住使用方法以及自动播放即可，其他属性可以在使用时查找对应的手册</span></li></ul><h2 id="cMw9Z"><span class="ne-text">新增 input 标签</span></h2><p id="7663543d9a186a67902e6d945bd05595" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1615560920848-b6218b7e-57ed-4da9-889e-ff00dd8df1c2.png" width="629.5" id="QfnGy" class="ne-image"></p><h2 id="1y9CZ"><span class="ne-text">新增表单属性</span></h2><p id="b4f19541ffe4082aabd9018ed884fd9f" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1615560931257-0c5b2693-9baf-4129-a502-e22ebc14c89e.png" width="608.5" id="xEk6J" class="ne-image"></p><p id="u44ad0119" class="ne-p"><br></p><p id="u0ac21576" class="ne-p"><br></p></div>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
          <category> HTML+CSS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>HTML总结</title>
      <link href="/blog/vtwy70ohpnm5/"/>
      <url>/blog/vtwy70ohpnm5/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h2 id="dZG9R"><span class="ne-text">常用文档</span></h2><div class="ne-quote"><p id="1730efa97c814edb0a0af9fdccb1ef56" class="ne-p"><span class="ne-text">W3C :  </span><a href="http://www.w3school.com.cn/" data-href="http://www.w3school.com.cn/" target="_blank" class="ne-link"><span class="ne-text">http://www.w3school.com.cn/</span></a></p><p id="c7fd9ef80bcede5c3555529ab9b94c34" class="ne-p"><span class="ne-text">MDN: </span><a href="https://developer.mozilla.org/zh-CN/" data-href="https://developer.mozilla.org/zh-CN/" target="_blank" class="ne-link"><span class="ne-text">https://developer.mozilla.org/zh-CN/</span></a></p><p id="5551e70a0ba88ded407ba5e50b0ff279" class="ne-p"><span class="ne-text">菜鸟：</span><a href="https://www.runoob.com/" data-href="https://www.runoob.com/" target="_blank" class="ne-link"><span class="ne-text">https://www.runoob.com/</span></a></p></div><h2 id="npsjj"><span class="ne-text">排版标签</span></h2><ul class="ne-ul"><li id="c58d1d14e822228e7de7b1d387eae4f4"><span class="ne-text">h：标题</span></li><li id="752fbd6a7f0db71d8bfb5b4c3e66a76b"><span class="ne-text">p：段落</span></li><li id="1af4dad3c9a5482c5a72883184a3a2b3"><span class="ne-text">hr（单）：横线</span></li><li id="dbe599382da964f3c9db2ced9aa8415e"><span class="ne-text">br（单）：换行</span></li><li id="90f1a7203b674a62fea092312c140167"><span class="ne-text" style="color: #4D4D4D; font-size: 16px">blockquote：引用</span></li><li id="325664d03a52915e3e258062f8c56445"><span class="ne-text" style="color: #4D4D4D; font-size: 16px">pre：预定义格式</span></li></ul><div class="ne-quote"><p id="4d51bedc413f950d477424f0b2269688" class="ne-p"><span class="ne-text">标签可定义预格式化的文本。 被包围在   标签 元素中的文本通常会保留空格和换行符。而文本也会呈现为等宽字体。</span></p></div><span id="rahiB"></span><h2 id="L1PLV"><span class="ne-text">文本格式化标签</span></h2><p id="f3ba3ad02b77de7e36371f91b1fbaabd" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611547659083-2c64e035-b906-47c8-84e1-67b8e747e361.png" width="1054" id="hTJyy" class="ne-image"></p><ul class="ne-ul"><li id="746680bbb7293cd90ce0fceeec3c3525"><span class="ne-text" style="background-color: transparent">b 只是加粗strong除了可以加粗还有 强调的意思，语义更强烈。</span></li></ul><h2 id="Y1Z3u"><span class="ne-text">img（单）</span></h2><p id="6e01155f3183ccbbdaa0d5d8c4f66f9d" class="ne-p"><br></p><p id="bd0f3775697bd11cff7298215468fcc1" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611547659339-b5fd80fe-ed24-42d9-8d70-ab9fe086449d.png" width="997" id="qWbBI" class="ne-image"></p><p id="84ef3e55c8d1099d653b4d7948d4b6cb" class="ne-p"><span class="ne-text">border 后面我们会用css来做，这里童鞋们就记住这个border 单词就好了</span></p><p id="3b087b4c5380b9c94d71bc1692f72147" class="ne-p"><strong><span class="ne-text">注意: </span></strong></p><ol class="ne-ol"><li id="807e1815b792378ebf4e94283a6cfe9d"><span class="ne-text">标签可以拥有多个属性，必须写在开始标签中，位于标签名后面。</span></li><li id="3dbcc6d607d712dbdb7a1f933b09bba6"><span class="ne-text">属性之间不分先后顺序，标签名与属性、属性与属性之间均以空格分开。</span></li><li id="d678fc804f07a24a329d9ebe62e7ea31"><span class="ne-text">任何标签的属性都有默认值，省略该属性则取默认值。</span></li><li id="0ec5f1ec9e03bff327e8b0f37543ed41"><span class="ne-text">采取  键值对 的格式   key=&quot;value&quot;  的格式</span></li></ol><p id="4cbe163524078f64efdeebf5a77ca286" class="ne-p"><span class="ne-text">比如:</span></p><span id="Vc37C"></span><p id="81d7149d5163ab07286a2b1718d2baeb" class="ne-p"><span class="ne-text">此处有练习题</span></p><p id="26cbd0574b9aa0697630dfbada743c3b" class="ne-p"><strong><span class="ne-text">重点掌握点：</span></strong></p><ul class="ne-ul"><li id="b71ea9f48e0abe185409c6b1a4cea80e"><span class="ne-text"> 请说出 图像标签那个属性是必须要写的？  img  src 图片的路径</span></li><li id="187463f93b61742b415d079a095f8ab0"><span class="ne-text"> 请说出 图像标签中 alt 和  title 属性区别？ alt 图片显示不出，文字就显示     title 鼠标经过图片的时候显示文字</span></li></ul><h2 id="TUVIZ"><span class="ne-text">a</span><strong><span class="ne-text"></span></strong></h2><ul class="ne-ul"><li id="a2430543e546b23873a407f4ad76810b"><span class="ne-text"> href：必须要的属性</span></li><li id="f6895ebac9686e774eccd98fda26e5d9"><span class="ne-text">target=“_blank”：新窗口打开</span></li></ul><h2 id="BatH6"><span class="ne-text">div和span</span></h2><div class="ne-quote"><p id="b5f6582587884fb813bd7d87a00187cb" class="ne-p"><span class="ne-text">标准流布局</span></p></div><ul class="ne-ul"><li id="d05d1232aa861b2108b327fc365ff3ac"><span class="ne-text">div标签  用来布局的，但是现在一行只能放一个div</span></li><li id="30faeb721117edf86fdd11764dd9a41a"><span class="ne-text">span标签  用来布局的，一行上可以放好多个span</span></li></ul><h2 id="Qo35Y"><span class="ne-text">base</span></h2><ul class="ne-ul"><li id="d637d8e76b5fd773f91aee5dbe978807"><span class="ne-text">base 可以设置整体链接的打开状态</span></li></ul><div class="ne-quote"><p id="c3fc3eb4ba3d36bb11cd68128ca18905" class="ne-p"><span class="ne-text">最常用的就是&lt;base target=&quot;_blank&quot; /&gt;</span></p></div><p id="ff81843c907c80bb4f282f7c083c2d6b" class="ne-p"><br></p><h2 id="8aB2g"></h2><h2 id="NS3GL"><span class="ne-text">lang</span></h2><pre><code>&lt;html lang=&quot;en&quot;&gt;  指定html 语言种类</code></pre><p id="b26c08b7b08fb95b641b20636fe462ae" class="ne-p"><span class="ne-text">最常见的2个：</span></p><ol class="ne-ol"><li id="f523c33a93dd7d077235040184061708"><code class="ne-code"><span class="ne-text">en</span></code><span class="ne-text">定义语言为英语</span></li><li id="a907681bcc17b7516a48453fcb7511ae"><code class="ne-code"><span class="ne-text">zh-CN</span></code><span class="ne-text">定义语言为中文</span></li></ol><ul class="ne-ul"><li id="053e4f69d6d72ee5d5f0c8311db4c9fe"><span class="ne-text">指定该html标签 内容 所用的语言为中文</span><strong><span class="ne-text"></span></strong></li><li id="227d29a54a59530daa63f6cfb61656bd"><span class="ne-text">简单来说，可能对于程序来说没有太大的作用，但是它可以告诉浏览器，搜索引擎，一些处理Html的程序对页面语言内容来做一些对应的处理或者事情。</span></li></ul><p id="fd03547ee12ad4e8c25dfe5910c52e51" class="ne-p"><br></p><h2 id="5ecVw"><span class="ne-text">table</span></h2><h3 id="bryeo"><span class="ne-text">解释</span></h3><ul class="ne-ul"><li id="cbeb125d54f702ed33e5ca74573a7a6e"><span class="ne-text">展示数据</span></li><li id="902d55a49f6e5c2cf66f2c0395154328"><span class="ne-text">让数据显示整齐规范</span></li><li id="2d57b152aafdf627d23586b4c0d89bcb"><span class="ne-text">表格属性需要注意的</span></li></ul><p id="9f56becae2aece13e944d1c664bee8a6" class="ne-p"><span class="ne-text">平时开发的我们这三个参数border、cellpadding、cellspacing为0，但在HTML5里面，后两者属性设置无效，利用 </span><code class="ne-code"><span class="ne-text">border-collapse: collapse;</span></code><span class="ne-text"> 来设置，将th和td设置为0</span></p><ul class="ne-ul"><li id="408fe9d1ca157a3567bf96ec624990f5"><span class="ne-text">浏览器会默认包裹tbody标签</span></li><li id="eaffcbabbd2c9d5a9620ac8ec141ff59"><span class="ne-text">HTML5里面用thead,tbody,tfoot来标注内容，更加清晰</span><strong><span class="ne-text"></span></strong></li></ul><h3 id="SqIni"><span class="ne-text">合并单元格</span></h3><p id="38dbbade10b863bc300718edf1b0617c" class="ne-p"><span class="ne-text">合并单元格是我们比较常用的一个操作，但是不会合并的很复杂。</span></p><div class="ne-quote"><p id="b7b96409b556c1ee73d7520552b21dbc" class="ne-p"><span class="ne-text">【1】合并单元格2种方式</span></p></div><ul class="ne-ul"><li id="dba3f0910488b3618d3d54ec5a86238e"><span class="ne-text">跨行合并：rowspan=&quot;合并单元格的个数&quot;</span></li><li id="23d45b8f12e5ce98dd35acbf74c34da3"><span class="ne-text">跨列合并：colspan=&quot;合并单元格的个数&quot;</span></li></ul><div class="ne-quote"><p id="ed00c86c77879b70ba1296d0adbe0c13" class="ne-p"><span class="ne-text">【2】合并单元格顺序</span></p><p id="de0116a248a291ee6cf56bddd657fbe4" class="ne-p"><strong><span class="ne-text">合并的顺序我们按照   先上 后下     先左  后右 的顺序 </span></strong></p></div><p id="1adbbc617356d92cbee58f233e655b01" class="ne-p"><span class="ne-text">跟我们以前学习汉字的书写顺序完全一致。</span></p><div class="ne-quote"><p id="02773556afb0793cbeaf3e3a2184ee47" class="ne-p"><span class="ne-text">【3】合并单元格三步曲</span></p></div><ol class="ne-ol"><li id="53edf24679a27257a723e79b4d0b8f59"><span class="ne-text">先确定是跨行还是跨列合并</span></li><li id="ea62ad1c10c1ffe956c908ce110fdd40"><span class="ne-text">根据 先上 后下   先左  后右的原则找到目标单元格    然后写上 合并方式 还有 要合并的单元格数量  比如 ：    </span></li><li id="2944a1964138c244395cd912cd745714"><span class="ne-text">删除多余的单元格 单元格</span></li></ol><h2 id="5Qiin"><span class="ne-text">ul、ol、dl</span></h2><h3 id="6xC2e"><span class="ne-text">去掉列表默认的样式</span></h3><p id="d9586db6059b7cb2e4a0304ae1d8345c" class="ne-p"><span class="ne-text">无序和有序列表前面默认的列表样式，在不同浏览器显示效果不一样，而且也比较难看，所以，我们一般上来就直接去掉这些列表样式就行了。 代码如下</span></p><pre><code>li &#123; list-style: none; &#125;</code></pre><h2 id="x6Hv6"><span class="ne-text">form</span></h2><ul class="ne-ul"><li id="d802bced65eba0ac604c6187eeed57dd"><span class="ne-text">表单目的是为了收集用户信息。</span></li></ul><p id="946ad7e8a5abf5dea27b2a08e4102e93" class="ne-p"><span class="ne-text">在我们网页中， 我们也需要跟用户进行交互，收集用户资料，此时也需要表单。</span></p><div class="ne-quote"><p id="3aa180518e9978d41bb13185f25f3800" class="ne-p"><span class="ne-text">在HTML中，一个完整的表单通常由表单控件（也称为表单元素）、提示信息和表单域3个部分构成。</span></p></div><ul class="ne-ul"><li id="d5a6e453dc3fd2c8ee80bd3b2faa5c03"><strong><span class="ne-text">表单控件： </span></strong><span class="ne-text">包含了具体的表单功能项，如单行文本输入框、密码输入框、复选框、提交按钮、重置按钮等。</span></li><li id="a5f481fa212c0bbf7d2b8aff6909641e"><strong><span class="ne-text">提示信息：</span></strong><span class="ne-text">一个表单中通常还需要包含一些说明性的文字，提示用户进行填写和操作。</span></li><li id="ca3b62ad328c68dacf5717898c4cff35"><strong><span class="ne-text">表单域：</span></strong><span class="ne-text">他相当于一个容器，用来容纳所有的表单控件和提示信息，可以通过他定义处理表单数据所用程序的url地址，以及数据提交到服务器的方法。如果不定义表单域，表单中的数据就无法传送到后台服务器。</span></li></ul><h3 id="J30BE"><span class="ne-text">input</span></h3><ul class="ne-ul"><li id="708bc00409b6951e0568439e6bd50401"><span class="ne-text">常用属性：</span></li></ul><p id="25ae6c09845c71d5cbd3a42106a1cdb4" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611547661035-9721cb68-5232-4cbf-8bf5-01b447ed3f3f.png" width="950" id="BiEER" class="ne-image"></p><ul class="ne-ul"><li id="96409159c52168dd7cd21522f33888a1"><span class="ne-text">value 默认的文本值。 有些表单想刚打开页面就默认显示几个文字，就可以通过这个value 来设置。</span></li></ul><div class="ne-quote"><p id="9098761dcdcaabbae8752cbaf8f4be43" class="ne-p"><span class="ne-text">name属性后面的值，是我们自己定义的。</span></p></div><ul class="ne-ul"><li id="777a432e08a3d84e5fe34e4425adedab"><span class="ne-text">name表单的名字， 这样，后台可以通过这个name属性找到这个表单。  页面中的表单很多，name主要作用就是用于区别不同的表单。</span></li><li id="1fd92e9f3054a9cf22591a76647bf148"><span class="ne-text">radio  如果是一组，我们必须给他们命名相同的名字 name   这样就可以在同一个组里面多个选其中的一个</span></li><li id="343bee6cc19ef0c8eef0782dadada843"><span class="ne-text">name属性，我们现在用的较少， 但是，当我们学ajax 和后台的时候，是必须的。</span></li></ul><div class="ne-quote"><p id="ea9fcc433044658e950fdb2c12740e7d" class="ne-p"><span class="ne-text">checked属性</span></p></div><ul class="ne-ul"><li id="8638fed527ec64aef863070db5d678f9"><span class="ne-text">默认选中状态。  较常见于 单选按钮和复选按钮。</span></li></ul><h3 id="pFWQV"><span class="ne-text">label</span></h3><ul class="ne-ul"><li id="fb5c6b55f8d543ae80f4b986ea41e043"><span class="ne-text">用于绑定一个表单元素, 当点击label标签的时候, 被绑定的表单元素就会获得输入焦点。</span></li></ul><div class="ne-quote"><p id="23c3bac617d30e9e6221c498a9e6c2cc" class="ne-p"><span class="ne-text">两种绑定方式</span></p></div><ol class="ne-ol"><li id="0fc90e67592232b4cbad70745cdb1a01"><span class="ne-text">第一种用法就是用label直接包括input表单。</span></li></ol><pre><code>&lt;label&gt; 用户名： &lt;input type=&quot;radio&quot; name=&quot;usename&quot; value=&quot;请输入用户名&quot;&gt;   &lt;/label&gt;</code></pre><p id="a984427ff266427f18b1550a1c94a4ca" class="ne-p"><span class="ne-text">适合单个表单选择</span></p><ol start="2" class="ne-ol"><li id="dc0782022e14c21fdb00507407349e69"><span class="ne-text">第二种用法 for 属性规定 label 与哪个表单元素绑定。</span></li></ol><pre><code>&lt;label for=&quot;sex&quot;&gt;男&lt;/label&gt;&lt;input type=&quot;radio&quot; name=&quot;sex&quot;  id=&quot;sex&quot;&gt;</code></pre><h3 id="f8rp2"><span class="ne-text">textarea</span></h3><h3 id="dlEQf"><span class="ne-text">select</span></h3><h3 id="BEna6"></h3><ul class="ne-ul"><li id="0a912ce9277e7ec729177ab905ddefe0"><span class="ne-text">&lt;select&gt;  中至少包含一对 option</span></li><li id="9dc2fd4c252850af4c10619c11c7e093"><span class="ne-text">在option 中定义selected =&quot; selected &quot;时，当前项即为默认选中项。</span></li><li id="9cb5a3582e1366a7c3c844fadefb794e"><span class="ne-text">但是我们实际开发会用的比较少</span></li></ul><h3 id="UQL8F"><span class="ne-text">form表单域</span></h3><ul class="ne-ul"><li id="26b0190ce393a5aaf96962fc3e3100b1"><span class="ne-text">收集的用户信息怎么传递给服务器：通过form表单域</span></li><li id="b1f7fce94a087e1c39f04441c803038a"><span class="ne-text">目的：在HTML中，form标签被用于定义表单域，以实现用户信息的收集和传递，form中的所有内容都会被提交给服务器。</span></li></ul><pre><code>&lt;form action=&quot;url地址&quot; method=&quot;提交方式&quot; name=&quot;表单名称&quot;&gt;  各种表单控件&lt;/form&gt;</code></pre><p id="227c848e2a3bb1e297ee457d25dd613e" class="ne-p"><br></p><ul class="ne-ul"><li id="5ac1d849d58aca6b7d530170ad76a674"><span class="ne-text">每一个form至少含有一个submit类型的input标签（点击submit提交到form中的action地址当中），然后接收的html页面（服务端）利用类似以下的代码进行处理url得到前者页面所传过来的参数，以便在服务端进行利用</span></li></ul><pre><code>&lt;script&gt;    console.log(location.search); // ?uname=andy    // 1.先去掉？  substr('起始的位置'，截取几个字符);    var params = location.search.substr(1); // uname=andy    console.log(params);    // 2. 利用=把字符串分割为数组 split('=');    var arr = params.split('=');    console.log(arr); // [&quot;uname&quot;, &quot;ANDY&quot;]    var div = document.querySelector('div');    // 3.把数据写入div中    div.innerHTML = arr[1] + '欢迎您';&lt;/script&gt;</code></pre><ul class="ne-ul"><li id="c18037fa2f630dadad819c600904f594"><strong><span class="ne-text">常用属性</span></strong></li></ul><table id="e9gFW" class="ne-table" style="width: 750px"><tbody><tr style="height: 33px"><td width="250"><p id="u512bd0ef" class="ne-p"><span class="ne-text">属性</span></p></td><td width="250"><p id="u56ca4cef" class="ne-p" style="text-align: left"><span class="ne-text">属性值</span></p></td><td width="250"><p id="u86a41f61" class="ne-p"><span class="ne-text">作用</span></p></td></tr><tr style="height: 33px"><td width="250"><p id="ud5e906c8" class="ne-p"><span class="ne-text">action</span></p></td><td width="250"><p id="u6e241977" class="ne-p" style="text-align: left"><span class="ne-text">url地址</span></p></td><td width="250"><p id="u06e58014" class="ne-p"><span class="ne-text">用于指定接收并处理表单数据的服务器程序的url地址。</span></p></td></tr><tr style="height: 33px"><td width="250"><p id="u2c885830" class="ne-p"><span class="ne-text">method</span></p></td><td width="250"><p id="u56055c02" class="ne-p" style="text-align: left"><span class="ne-text">get/post</span></p></td><td width="250"><p id="uc97156b6" class="ne-p"><span class="ne-text">用于设置表单数据的提交方式，其取值为get或post。</span></p></td></tr><tr style="height: 33px"><td width="250"><p id="u58721498" class="ne-p"><span class="ne-text">name</span></p></td><td width="250"><p id="u8a30ce77" class="ne-p" style="text-align: left"><span class="ne-text">名称</span></p></td><td width="250"><p id="u11fb0c64" class="ne-p"><span class="ne-text">用于指定表单的名称，以区分同一个页面中的多个表单。</span></p></td></tr></tbody></table><ul class="ne-ul"><li id="a344cbcf320b7302fdd8fb26c704b41b"><span class="ne-text">每个表单都应该有自己表单域。我们现在做页面，不写看不到效果，但是 如果后面学 ajax 后台交互的时候，必须需要 form表单域。</span></li></ul><p id="1325c33cdd78fe0615dea69075fcc3cf" class="ne-p"><br></p></div>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
          <category> HTML+CSS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>674. 最长连续递增序列🔖数组🔖双指针</title>
      <link href="/blog/guaorh/"/>
      <url>/blog/guaorh/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><ul class="ne-ul"><li id="u8ff4bb64"><a href="https://leetcode-cn.com/problems/longest-continuous-increasing-subsequence/" data-href="https://leetcode-cn.com/problems/longest-continuous-increasing-subsequence/" target="_blank" class="ne-link"><span class="ne-text">https://leetcode-cn.com/problems/longest-continuous-increasing-subsequence/</span></a></li></ul><h3 id="Iw90w"><span class="ne-text">思路</span></h3><p id="ue0607f29" class="ne-p"><span class="ne-text">双指针顺移思想</span></p><p id="uff2fb206" class="ne-p"><span class="ne-text"></span></p><h3 id="AGl80"><span class="ne-text">ts实现</span></h3><pre><code>function findLengthOfLCIS(nums: number[]): number &#123;  if (nums.length === 1) return 1  let head: number = 0  let next: number = 1  let result: number = 1  while (next !== nums.length) &#123;    nums[next - 1] &lt; nums[next]      ? (result = result &lt;= next - head + 1 ? next - head + 1 : result)      : (head = next)    next++  &#125;  return result&#125;</code></pre><p id="u882f6202" class="ne-p"><span class="ne-text"></span></p><h3 id="OB9D2"><span class="ne-text">之前java代码实现</span></h3><pre><code>package com.wztlink1013.problems.leetcode.editor.cn;<p>// P674.最长连续递增序列<br>// P674.longest-continuous-increasing-subsequence<br>//给定一个未经排序的整数数组，找到最长且 连续递增的子序列，并返回该序列的长度。<br>//<br>// 连续递增的子序列 可以由两个下标 l 和 r（l &lt; r）确定，如果对于每个 l &lt;= i &lt; r，都有 nums[i] &lt; nums[i + 1] ，那<br>//么子序列 [nums[l], nums[l + 1], …, nums[r - 1], nums[r]] 就是连续递增子序列。<br>//<br>//<br>//<br>// 示例 1：<br>//<br>//<br>//输入：nums = [1,3,5,4,7]<br>//输出：3<br>//解释：最长连续递增序列是 [1,3,5], 长度为3。<br>//尽管 [1,3,5,7] 也是升序的子序列, 但它不是连续的，因为 5 和 7 在原数组里被 4 隔开。<br>//<br>//<br>// 示例 2：<br>//<br>//<br>//输入：nums = [2,2,2,2,2]<br>//输出：1<br>//解释：最长连续递增序列是 [2], 长度为1。<br>//<br>//<br>//<br>//<br>// 提示：<br>//<br>//<br>// 0 &lt;= nums.length &lt;= 104<br>// -109 &lt;= nums[i] &lt;= 109<br>//<br>// Related Topics 数组<br>// 👍 147 👎 0</p><p>public class P674LongestContinuousIncreasingSubsequence&#123;<br>    public static void main(String[] args) &#123;<br>        Solution solution = new P674LongestContinuousIncreasingSubsequence().new Solution();<br>        int [] nums = &#123;1,3,5,7&#125;;<br>        int result = solution.findLengthOfLCIS(nums);<br>        System.out.println(result);<br>    &#125;</p><p>//leetcode submit region begin(Prohibit modification and deletion)<br>class Solution &#123;<br>    public int findLengthOfLCIS(int[] nums) &#123;<br>        if (nums.length == 0) &#123; return 0; &#125;<br>        int result = 1;<br>        int count = 1;<br>        for (int i=0; i&lt;nums.length-1; i++) &#123;<br>            if (nums[i] &lt; nums[i+1] ) &#123;<br>                count++;<br>                if (result &lt; count) &#123;result = count;&#125;<br>            &#125; else &#123;<br>                if (result &lt; count) &#123;result = count;&#125;<br>                count = 1;<br>            &#125;<br>        &#125;<br>        return result;<br>    &#125;<br>&#125;<br>//leetcode submit region end(Prohibit modification and deletion)</p><p>&#125;<br></code></pre></p></div>]]></content>
      
      
      <categories>
          
          <category> 计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 📶线结构：字符串-数组-栈-队列 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>《软件工程导论》知识总结</title>
      <link href="/blog/sc6tzq/"/>
      <url>/blog/sc6tzq/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="ue801d3a7" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1623288164521-ad52e1f8-1a29-4976-ac2b-c45d7d5aa773.png" width="234.98956298828125" id="uca9222ff" class="ne-image"></p><p id="u0f5fa5c3" class="ne-p"><span class="ne-text"></span></p><p id="udeb4604d" class="ne-p"><span class="ne-text">前言：大三课程所学总结，同时日后以此为蓝本在实际开发中规范化开发。</span></p><p id="ud6be1287" class="ne-p"><br></p><h2 id="Sg2gh"><span class="ne-text">一、传统方法学</span></h2><ul class="ne-ul"><li id="u064198b3"><strong><span class="ne-text">问题定义</span></strong></li><li id="u573f5f0a"><strong><span class="ne-text">可行性研究</span></strong></li></ul><p id="u629ba7d2" class="ne-p"><br></p><ul class="ne-ul"><li id="u933d2d62"><strong><span class="ne-text">需求分析</span></strong></li><li id="u6e6fc06e"><strong><span class="ne-text">总体设计</span></strong></li><li id="uf627370b"><strong><span class="ne-text">详细设计</span></strong></li></ul><p id="ua85c12d8" class="ne-p"><br></p><ul class="ne-ul"><li id="u37f64c7c"><strong><span class="ne-text">编码和单元测试</span></strong></li><li id="u74245b96"><strong><span class="ne-text">综合测试</span></strong></li></ul><p id="u32145c4e" class="ne-p"><br></p><ul class="ne-ul"><li id="u34d5e06c"><strong><span class="ne-text">软件维护</span></strong></li></ul><p id="uecdbfe88" class="ne-p"><strong><span class="ne-text"></span></strong></p><h3 id="kWUyN"><span class="ne-text">可行性研究</span></h3><div class="ne-quote"><p id="da256ec317c21c67463ce9e72c02676b" class="ne-p"><span class="ne-text">在了解问题定义之后，将其模型抽离出来，然后对其进行可行性分析，探索若干种解法，对每种解法仔细研究其可行性，从下面几种方面来考虑</span></p></div><ol class="ne-ol"><li id="4491145eb22ea1f1f9851e794718f1b1"><span class="ne-text">技术可行性：能否用现又技术实现？</span></li><li id="0ef89cd6a88e622374fd1c9abd33be3a"><span class="ne-text">经济可行性：软件带来的经济效益能否大于软件的开发成本？</span></li><li id="91bc3d6b87ac18c66962c6db7181155b"><span class="ne-text">操作可行性：在用户组织之间是否具有操作可行性？</span></li></ol><p id="e7c5762d2b7f53f3c02815b1ac02dab5" class="ne-p"><br></p><p id="f56b388d47cc5e1383c0f819c95ff2c2" class="ne-p"><span class="ne-text">必要时还有从法律和社会效益来研究其可行性。</span></p><p id="f736b9b4886d5b30b7f847a004cfaba2" class="ne-p"><br></p><div class="ne-quote"><p id="2cb44a84ff8d9e6512b497e6ea8830e9" class="ne-p"><span class="ne-text">系统流程图</span></p><p id="990dc056d60a8294a724cf6ac2e0b26f" class="ne-p"><span class="ne-text">数据流图</span></p></div><p id="e2724457d877628cb99acab2eec04da4" class="ne-p"><br></p><div class="ne-quote"><p id="1b361a0060ba18cfae16ab07acc28938" class="ne-p"><span class="ne-text">成本/效益分析</span></p></div><p id="220af99ca5b90b67c97cb898bdde6493" class="ne-p"><span class="ne-text">成本估计的几种方法</span></p><ul class="ne-ul"><li id="a1ce0c0a61613b6dd566b39061c6f943"><span class="ne-text">代码行技术：根据每行代码的平均成本乘以行数就是大概的成本</span></li><li id="87615407e2f1fb8079c9c57e73739125"><span class="ne-text">任务分解技术：将整个声明周期划分不同阶段，估计每个不同阶段所花费的成本，一般都是各阶段的人数诚意平均工资再加这般</span></li><li id="1e278915a7b91d80f4b4e32795487753"><span class="ne-text">自动估计成本：根据程序来估计，一般要用到大量数据，才能保证这个估计有效（大数据时代应该很吃香，可以利用所搜集的大量数据来进行建模）</span></li></ul><p id="1775f6dde2a55974718d34e86bf586a6" class="ne-p"><br></p><p id="476b681e81fd2f67fd8a382cc00391f3" class="ne-p"><span class="ne-text">成本/效益分析的方法</span></p><ul class="ne-ul"><li id="f67bec3f08ba880aa864bca1291f02c2"><span class="ne-text">货币的时间价值：这里面有年利率的概念，就是过n年之后，你手中的钱在n年之后会提升</span></li></ul><p id="4ee18602917afb986f4f491c367652b7" class="ne-p"><span class="ne-text">F=P（1+n）^n        （P元钱在n年后的价值）</span></p><ul class="ne-ul"><li id="d87da5223a3b61714341639756dc6289"><span class="ne-text">投资回收期：你所赚的钱等于你所投资的资金所花费的时间越短越好</span></li><li id="db66717e9cac0948bd3732fbb7550a5c"><span class="ne-text">纯收入：整个生命周期内，赚的钱减去你投资的钱</span></li></ul><h3 id="i74Hr"><span class="ne-text">需求分析</span></h3><div class="ne-quote"><p id="abe209f676db33b9d9a619b6e9aa6f90" class="ne-p"><span class="ne-text">与用户沟通获取需求的方法</span></p></div><ul class="ne-ul"><li id="c81898b947638b817b40a1ee6b31997d"><span class="ne-text">访谈</span></li><li id="50482d1eb38d4982069107892aa38382"><span class="ne-text">面向数据流自顶向下求精</span></li><li id="504a63ce936b7c766f2e360d8ee1f67b"><span class="ne-text">简易的应用规格说明技术</span></li><li id="9e77c616f4921079c2ecd3b0197a433b"><span class="ne-text">快速建立软件模型</span></li></ul><p id="a129032def9a21df6ec1816fb63c7536" class="ne-p"><br></p><div class="ne-quote"><p id="a6976eabc8b5a57c244dc94c31ae467a" class="ne-p"><span class="ne-text">根据结构化分析准则，需求分析过程应该建立三种模型，它们分别是？以及他们所用到的工具？</span></p></div><ul class="ne-ul"><li id="d5810c7e4c99fe3c690286d15258a271"><span class="ne-text">数据模型——E-R图：就是数据库里面学到的实体-联系图</span></li><li id="ecff7d5e5389025a0c7de4166b323828"><span class="ne-text">功能模型——数据流图：描述数据在系统中的转换的逻辑过程</span></li><li id="44e373a12ce96cd1e6e9dc964b52ecf9"><span class="ne-text">行为模型——状态转换图：作为外部事件结果的系统行为</span></li></ul><p id="4ad53d3f9e7fbcad84af4ead365a4254" class="ne-p"><br></p><div class="ne-quote"><p id="5ed1424a182263377220cfe0104f5a84" class="ne-p"><span class="ne-text">其他的工具还有</span></p></div><ul class="ne-ul"><li id="bfdc0d510e292081cae0537b845462d4"><span class="ne-text">层次方框图（树形结构）</span></li><li id="06f3050dcb6c971fcf9177f4fd71c9c9"><span class="ne-text">Warnier图{大括号包裹）</span></li><li id="6720079fe34f229e69a211ed8f6977e8"><span class="ne-text">IPO图（方框-箭头；表格形式）</span></li></ul><p id="c8bac408ac7e8d987d6ac2b9f87e67a1" class="ne-p"><br></p><h3 id="XMDx8"><span class="ne-text">形式化说明技术</span></h3><div class="ne-quote"><p id="4f81173a2f49c4af9bc074d2c65331b6" class="ne-p"><span class="ne-text">软件工程所使用的方法可划分为下面三种</span></p></div><ul class="ne-ul"><li id="aa3a4b4b22f9df9f52a75fd4b5787b49"><span class="ne-text">非形式化方法：用自然语言描述就是典型的非形式化方法</span></li><li id="282495a0dd8355d5495c0db509344ccd"><span class="ne-text">半形式化方法：利用E-R图描述就是半形式化方法</span></li><li id="462d34af07b4f5e183190104e896ee18"><span class="ne-text">形式化方法：用到数学的技术，也就是说，如果一种方法用到坚实的数学基础，那么他就是形式化方法</span></li></ul><p id="0278630d09af9b8e39ae0eacf316e038" class="ne-p"><br></p><h3 id="IECRF"><span class="ne-text">总体设计</span></h3><div class="ne-quote"><p id="c095e1f290f3a6bd1331e12b689974b1" class="ne-p"><span class="ne-text">总体设计又称之为概要设计、初步设计</span></p></div><p id="f9ffad5ade83523a7e15cdf9fc65a51c" class="ne-p"><br></p><div class="ne-quote"><p id="3cb7fa8506228a3b8e172579417623a5" class="ne-p"><span class="ne-text">由哪两阶段组成呢？</span></p></div><ul class="ne-ul"><li id="d6bb60278de18caf92d0d38d880517e3"><span class="ne-text">系统设计阶段：确定系统的具体实现方案</span></li><li id="9f284ffd2d8474dffec7ced586f34e58"><span class="ne-text">结构设计阶段：确定软件结构</span></li></ul><p id="2cbeb585f58b1631c245e39292eb3612" class="ne-p"><br></p><div class="ne-quote"><p id="81d32fbaac962fc58818774d3fdf63d7" class="ne-p"><span class="ne-text">设计原理</span></p></div><p id="33600484e6ffb5faea327d78d9c85c16" class="ne-p"><strong><span class="ne-text">模块</span></strong><span class="ne-text">是由边界元素限定的相邻程序元素（数据说明，可执行的语句）的序列，而且有一个总体标识符代表它</span></p><p id="58244961575f89e6b5f1ed76b954aa59" class="ne-p"><br></p><p id="a22ea39919ca56b42645b301fc737f9b" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1608815946283-167d2edb-f25b-45de-ade4-6041bddf45c2.png" width="347" id="LdPtL" class="ne-image"></p><p id="aa02840ac5fcd121ad83406d7093cab2" class="ne-p"><br></p><p id="ecf87b630b701c6cb6656f8779ea3bfc" class="ne-p"><br></p><p id="9105c9d8f9cb15172cb19cc4903aefb5" class="ne-p"><span class="ne-text">模块之间的</span><strong><span class="ne-text">独立程度</span></strong><span class="ne-text">有两个标准来度量，分别是：</span></p><p id="5b4f0e2d137cd16a71cbcce9a0321030" class="ne-p"><br></p><p id="f88789e8c34c9ebbd8db4b66488ee0f5" class="ne-p"><span class="ne-text">耦合：度量</span><strong><span class="ne-text">模块间</span></strong><span class="ne-text">的互相依赖程度</span></p><p id="6e2424863e29b1c1adf1d771db288b8d" class="ne-p"><br></p><p id="f7122c2837080727dd4bd2bb54054327" class="ne-p"><span class="ne-text">内聚：度量</span><strong><span class="ne-text">模块内部元素间</span></strong><span class="ne-text">的结合程度</span></p><p id="760f6c8b5cd58d68df12050c14aeaf8a" class="ne-p"><br></p><p id="e852b73d15289a8fc8fcd3824c3f8bd0" class="ne-p"><strong><span class="ne-text">尽量使用数据耦合，少用控制耦合和特征耦合，限制公共环境耦合的范围，完全不用内容耦合</span></strong></p><p id="b04f602a43611d629c8ffd9a6f20f0a3" class="ne-p"><br></p><p id="f6bdd7d8c49ec62f7bb77db48f63f55b" class="ne-p"><span class="ne-text">7种内聚优劣评分：功能内聚（10分）偶然内聚（0分）</span></p><p id="12859f61a93111253568308a59c23924" class="ne-p"><br></p><p id="bcba68641f66e8a8fad0ce7c1aae5e58" class="ne-p"><br></p><div class="ne-quote"><p id="0a164888fc073692c379e2f485f972d0" class="ne-p"><span class="ne-text">描绘软件结构的图形工具</span></p></div><ul class="ne-ul"><li id="cf54a5d7bfc71c75141f3081e5952a5e"><span class="ne-text">层次图（树状）和HIPO图（带编号的层次图）</span></li><li id="9c69e26cd9190ae3fff35df02c5e1a06"><span class="ne-text">结构图</span></li></ul><p id="462482eb0d23638902d6e635ccdbd5ac" class="ne-p"><br></p><div class="ne-quote"><p id="0455dfb17ed7f2cc85a0be9dcb6c65dd" class="ne-p"><span class="ne-text">面向数据流的设计方法</span></p></div><p id="fec262227f248cb37fc0c92964752881" class="ne-p"><span class="ne-text">概念：面向数据流的设计方法就是把信息流映射成软件结构，同时信息流的结构决定了映射的方法</span></p><ul class="ne-ul"><li id="f4370e4bd0d5beba8545faf6c09b9ab3"><span class="ne-text">变换流</span></li><li id="cb85574b913dd2d3e35009f0141d0098"><span class="ne-text">事务流</span></li><li id="e147a27045b2a8b3a5c09febdeda30a3"><span class="ne-text">设计过程</span></li></ul><p id="9a483d7fc338d13110695847ddf5ccc6" class="ne-p"><br></p><h3 id="DbbUV"><span class="ne-text">详细设计</span></h3><div class="ne-quote"><p id="443d467214e52b2b1c698b72d8659de2" class="ne-p"><span class="ne-text">结构程序设计</span></p></div><p id="1fe118dce6b49fb0cddd673ba252f346" class="ne-p"><span class="ne-text">只用3种控制结构就能实现任何单入口单出口的程序，这三种结构分别是顺序结构、选择结构、循环结构</span></p><p id="f763b9eb74869fad77139fab87bf7fb6" class="ne-p"><br></p><div class="ne-quote"><p id="bfd7aaf9bd228397f640fd8a3022f1a8" class="ne-p"><span class="ne-text">人机界面设计的设计问题有：</span></p></div><ul class="ne-ul"><li id="9ced93a1317b97f85376e9c449904fc2"><span class="ne-text">系统响应时间</span></li><li id="a3d9dcb8fa2155170cd8b6eecb47c11f"><span class="ne-text">用户帮助实施</span></li><li id="e7b3ce822219911bc89cc0fef1644ed8"><span class="ne-text">出错信息处理</span></li><li id="3d0c3d8df2b1eb6650b2006fdfff5a5c"><span class="ne-text">命令交互</span></li></ul><p id="e4555c640ff81385e9791a398d81dfa8" class="ne-p"><br></p><div class="ne-quote"><p id="c02606096e3a4ac9ead29edffbf0a34c" class="ne-p"><span class="ne-text">人机界面设计的设计指南：</span></p></div><ul class="ne-ul"><li id="a1bd29ae07ab96fab323785d20c5bc67"><span class="ne-text">一般交互指南</span></li><li id="de06e4d07e2ace5bacb4fca1d03b0e9d"><span class="ne-text">信息显示指南</span></li><li id="19a9595dd58f8d9b71367ea2ae38b752"><span class="ne-text">数据输入指南</span></li></ul><p id="9071298852c9231623309cd766a7109e" class="ne-p"><br></p><div class="ne-quote"><p id="30fb3c25eb3a86cbc11061b3230db105" class="ne-p"><span class="ne-text">过程设计的工具【重要】</span></p></div><ol class="ne-ol"><li id="b025b96e652e9bf3a6aaccd0ce217480"><span class="ne-text">程序流程图</span></li><li id="5ef4caaceb7524873bbe5fa273100774"><span class="ne-text">盒图（N-S图）</span></li><li id="c41e532c02b61ed188a0e90289f32928"><span class="ne-text">PAD图</span></li><li id="2879ff7ca86a0d5993f8aad5de8b0a19"><span class="ne-text">判定表</span></li><li id="53e72a38aaadb5e6796a71d4250677eb"><span class="ne-text">判定树</span></li><li id="b4537a54d484d6e6f06b17bd781635cf"><span class="ne-text">过程设计语言</span></li></ol><p id="837fcba8267b78744a3425b4876abf79" class="ne-p"><br></p><div class="ne-quote"><p id="f0c4583917dcbdd1b1e498760cbea0a3" class="ne-p"><span class="ne-text">面向数据结构的设计方法</span></p></div><p id="aad5708860dabaed2e66051c5e502278" class="ne-p"><strong><span class="ne-text">两个最著名的方法为：Jackson方法和Warnier方法</span></strong></p><p id="81bdd1af3843b105d53d661dd93f0921" class="ne-p"><br></p><div class="ne-quote"><p id="2eeafbb284efe2526ff2f088288915dc" class="ne-p"><span class="ne-text">Jackson方法</span></p></div><p id="de6c848630baecfc322c9ae676e817ef" class="ne-p"><span class="ne-text">只有顺序、选择、重复三种结构</span></p><p id="8fa8c35706c506788ea92fd019f18f3a" class="ne-p"><br></p><p id="ff05530cb6b0944032a3318da99c61b9" class="ne-p"><span class="ne-text">要会用伪代码表示</span></p><p id="ede4aaecbb95bdab786cea0c294e455a" class="ne-p"><br></p><div class="ne-quote"><p id="2a8f8ba9267e31fb85ac50d19e5d395b" class="ne-p"><span class="ne-text">程序复杂程度的定量度量有McCabe方法和Halstead方法，只介绍前者</span></p></div><ol class="ne-ol"><li id="b83ce80d9e0e4d850d28f5342ab0b5af"><span class="ne-text">流图（给出伪代码画流图）</span></li><li id="33daebeb3ded5c6b1dc06e20ef95602e"><span class="ne-text">计算环形复杂度的方法</span></li></ol><h3 id="bZDiQ"><span class="ne-text">实现</span></h3><p id="ud66084d2" class="ne-p"><span class="ne-text">实现 = 编码 + 调试</span></p><p id="u6361cd37" class="ne-p"><br></p><p id="u9921e41a" class="ne-p"><span class="ne-text">实际过程中，调试所花费的时间远大于编码的时间</span></p><h3 id="s1Bnl"><span class="ne-text">维护</span></h3><hr id="WKC4w" class="ne-hr"><p id="u28c37437" class="ne-p"><br></p><h2 id="ebErT"><span class="ne-text">二、面向对象方法学</span></h2><p id="973562448df5e3b289545e92949add7c" class="ne-p"><br></p><p id="98d76573c00e18bed3152076eca61ff1" class="ne-p"><span class="ne-text">由三部分组成：分析，设计，实现</span></p><p id="u361bafd9" class="ne-p"><br></p><h2 id="nBd4i"><span class="ne-text">三、软件项目管理</span></h2><p id="11788720156d1924889182831224b54a" class="ne-p"><br></p><p id="7d4a8b3d1acc1ca0f23cfb44f4f8f668" class="ne-p" style="text-indent: 2em"><span class="ne-text">本章节探讨的是实际</span><strong><span class="ne-text">软件项目管理</span></strong><span class="ne-text">的相关工作，软件项目管理是软件项目一经启动就开始实施的一系列工作，其首先需要探讨的就是软件项目的相关估算，具体的有</span><strong><span class="ne-text">软件规模的估算、工作量的估算</span></strong><span class="ne-text">和</span><strong><span class="ne-text">完成项目估算</span></strong><span class="ne-text">，由上述的估算再对其进行制定一套完整的</span><strong><span class="ne-text">进度计划方案</span></strong><span class="ne-text">和</span><strong><span class="ne-text">人员组织方案</span></strong><span class="ne-text">，在整个项目过程中，还需要动态的</span><strong><span class="ne-text">软件配置管理</span></strong><span class="ne-text">，最后还介绍了</span><strong><span class="ne-text">软件质量的保证</span></strong><span class="ne-text">和</span><strong><span class="ne-text">软件能力成熟度模型</span></strong><span class="ne-text">这两个软件完成收尾的相关概念。</span></p><p id="ua95ab332" class="ne-p"><br></p><p id="uf6e13592" class="ne-p" style="text-indent: 2em"><span class="ne-text">作者想要解决软件危机相关问题，具体而言就印证“后人哀之而不鉴之，亦是后人而复哀后人也”这句古话，所以一套系统的软件项目管理出来了。</span></p><p id="4ac9099fefb47413fb631ebb746249fe" class="ne-p"><br></p><h3 id="FhYVU"><span class="ne-text">估算工作</span></h3><p id="dcb4c6036ec315e999b7a26b7d081a80" class="ne-p"><strong><span class="ne-text">估算软件规模</span></strong><span class="ne-text">有两种方法：代码行估算和功能点估算</span></p><p id="c6fd79aa347b5f525d17a0fe5a310686" class="ne-p" style="text-indent: 2em"><span class="ne-text">代码行技术就是利用代码的行数来进行估算的，会根据几个有经验的工作者利用一个公式来进行估算（最小可能的规模+最大可能的规模+最可能的规模）/6，得到的结果有两种，第一种是规模小的时候，单位行，第二种是规模大的时候，单位是千行。</span></p><p id="bb218ba9a4af03e7895ad913e7f1b505" class="ne-p" style="text-indent: 2em"><span class="ne-text">功能点技术就比较复杂了，它涉及到五个相关信息域特征的概念，分别是输入项数，输出项数，查询项数，主文件数，外部接口项数，再利用一系列步骤公式得到这个软件的功能点估算，最后得到的是功能点数FP。</span></p><p id="9291bc14cf0a3023f7c41a7bb1b0a87a" class="ne-p" style="text-indent: 2em"><span class="ne-text">具体可以参考：</span><a href="https://wiki.mbalib.com/wiki/%E5%8A%9F%E8%83%BD%E7%82%B9%E4%BC%B0%E7%AE%97%E6%B3%95" data-href="https://wiki.mbalib.com/wiki/%E5%8A%9F%E8%83%BD%E7%82%B9%E4%BC%B0%E7%AE%97%E6%B3%95" target="_blank" class="ne-link"><span class="ne-text">功能点估算法 | MBA智库</span></a></p><p id="27a02b83c7c038ac03a549a49a114ae6" class="ne-p"><strong><span class="ne-text">估算工作量</span></strong><span class="ne-text">有三种方法</span></p><p id="b30bb9c6aa59761a4c3ac94a95118e6c" class="ne-p" style="text-indent: 2em"><span class="ne-text">构造的函数模型的有静态单变量模型、动态多变量模型、COCOMO2模型这三种模型，得到的结果单位是人月（pm）。     </span></p><p id="cd402b4625b2321063e188b743e6c109" class="ne-p" style="text-indent: 2em"><span class="ne-text">静态单变量是基于上一个估算软件规模得出的代码行/功能点结果这一个变量函数，有一些相应的前人总结的公式</span></p><p id="f904977abee7508fbf5daa2232d161c8" class="ne-p" style="text-indent: 2em"><span class="ne-text">多变量模型，顾名思义，多个变量不止一个变量，有项目持续时间，特殊技术因子，生产率参数，也有相应的函数，可以去查查。</span></p><p id="1a033da3ccb58b79378792b75c9c643f" class="ne-p" style="text-indent: 2em"><span class="ne-text">COCOMO2模型 略、</span></p><p id="bd97fa8750217c45735f37b01d6d38cf" class="ne-p"><strong><span class="ne-text">估算开发时间</span></strong></p><p id="ff704fb3f91505dfb86d4220d8be62b5" class="ne-p" style="text-indent: 2em"><span class="ne-text">利用上一步骤得到的所估算的工作量，有一系列模型将工作量的值带进去就会得到相应的开发时间值。书中介绍了Walston_Felix、原始的COCOMO模型、COCOMO2模型、Putnam模型。</span></p><hr id="UiY8s" class="ne-hr"><h3 id="antpi"><span class="ne-text">制定进度计划表/图</span></h3><p id="fbffa6431b00ef3f008b9c92cccb0901" class="ne-p" style="text-indent: 2em"><span class="ne-text">得到开发时间，然后就是根据人员人员数量的资源来自定计划，有两种可视化方法：</span></p><p id="a8a8cca474ca2a750020a9d9595f5b7e" class="ne-p" style="text-indent: 2em"><span class="ne-text">第一种就是</span><strong><span class="ne-text">Gantt图</span></strong><span class="ne-text">：典型的异于流水作业的一种方法，动态调配人员来完成工作</span></p><p id="8a678f2ae91dc2521139b950aff125f2" class="ne-p" style="text-indent: 2em"><span class="ne-text">第二种就是</span><strong><span class="ne-text">工程网络</span></strong><span class="ne-text">：用箭头和圆圈来表示整个项目流程，优于Gantt图的就是能够实际根据实际项目中的潜力任务来跟踪观察，具体说就是有些任务可能在实际过程中，用原先指定的时间或人员不一定能高效完成，逾期或是提前很久完成等等这种情况。</span></p><p id="66ebe5fc24301b3cd8a4865483c6bb54" class="ne-p" style="text-indent: 2em"><span class="ne-text">工程网络功能可以估算工程的进度，在工程网络里面加上一些时间数字，可以灵活地查看并计算工程的计划时间。</span></p><p id="66839487d9df2505cbc30bc1d9ebc2d9" class="ne-p" style="text-indent: 2em"><span class="ne-text">工程网络还可以计算出机动时间。</span></p><p id="99f725f16a892be5dfbf5ffb4463f611" class="ne-p" style="text-indent: 2em"><span class="ne-text">其实在实际过程中，这两种方法都是并用的。</span></p><hr id="Z5TGx" class="ne-hr"><h3 id="uXQqO"><span class="ne-text">人员组织</span></h3><p id="u2901f8b4" class="ne-p"><span class="ne-text">人员组织在所经历的阶段中，经过多次变革，书中介绍有，最初的民主制程序员组👉主程序员</span></p><p id="52bb8c3b5ff106c6af3409409567c823" class="ne-p"><span class="ne-text">组👉现代程序员组</span></p><p id="75444e66e94cc38829277c056c2b460b" class="ne-p" style="text-indent: 2em"><span class="ne-text">只介绍现代程序员组，其实这个在历史中也分两种，第一种是根据职能不同分成两个组长，这种方式不能根治这过程中的软件危机，不详细讲述，第二种就是现在常说的项目经理管理下调配的，项目经理管多个组长，各个组长管理下面的多个程序员，并且，在组长与组长之间可以进行该层的交流，程序员层也一样，但是项目经理就是在该项目中的天花板了，没人管得了……</span></p><hr id="9JKVX" class="ne-hr"><h3 id="cTc7h"><span class="ne-text">软件配置管理、质量保证、能力成熟度模型</span></h3><p id="97b9eb0ea70dcea85baa6783d3b9c090" class="ne-p" style="text-indent: 2em"><span class="ne-text">这三个就是项目管理过程中一些概念之类的，其中软件配置管理讲究动态二字，因为随着时间抑或是用户需求的推移，软件配置势必会改变，这时候就需要即时更新相应配置</span></p><p id="04943293cbad84bafed42068304ddd16" class="ne-p" style="text-indent: 2em"><span class="ne-text">后两者是对软件完成的收尾相关工作了。</span></p><p id="uea81367b" class="ne-p"><br></p><p id="8ca165ef34fd3139501918978b84a812" class="ne-p"><br></p><p id="53bd320562154be3fa996c5b0f326ccd" class="ne-p"><br></p></div>]]></content>
      
      
      <categories>
          
          <category> 计算机素养 </category>
          
          <category> 软件工程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成原理知识点回顾</title>
      <link href="/blog/pnf49g/"/>
      <url>/blog/pnf49g/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><div class="ne-quote"><p id="8ad03590f73c34d275dfefb0c8e25d8a" class="ne-p"><span class="ne-text">利用一些基本的问题简单回顾一下这学期学的计组的基本知识点。</span></p></div><h2 id="MTQew"><span class="ne-text">概论</span></h2><div class="ne-quote"><p id="31d14279500463f7b782d82a1e4c75ea" class="ne-p" style="text-align: left"><span class="ne-text">电子数字计算机和电子模拟计算机的区别是什么？</span></p></div><p id="80f953469f71f4acc35b6630fa82d40f" class="ne-p" style="text-align: left"><span class="ne-text">电子数字计算机处理的信息是</span><strong><span class="ne-text">离散</span></strong><span class="ne-text">的，运算过程是离散的</span></p><p id="u0e03442d" class="ne-p" style="text-align: left"><span class="ne-text"></span></p><p id="443d32daf3b1bddb7c83d1b6d9425fac" class="ne-p" style="text-align: left"><span class="ne-text">电子模拟计算机处理的信号时</span><strong><span class="ne-text">连续</span></strong><span class="ne-text">的，运算过程是连续的</span></p><div class="ne-quote"><p id="edf4419af9927be6045773d9ca7a81e3" class="ne-p"><span class="ne-text">冯诺依曼计算机的特点是什么？其中最主要的一点是什么？</span></p></div><ol class="ne-ol"><li id="e2c29bb8a0409b4fe70c80a62181f253"><span class="ne-text">计算机由运算器、控制器、存储器、输入系统、输出系统</span><strong><span class="ne-text">五大部件</span></strong><span class="ne-text">组成（注意中央处理器是运算器和控制器的合称）</span></li><li id="374b9714d18be902ffd47d5abe513b94"><span class="ne-text">计算机内部由</span><strong><span class="ne-text">二进制编码</span></strong><span class="ne-text">指令和数据</span></li><li id="28b1ea0a9b7fab2e68dd14e628fc90e7"><span class="ne-text">将编好的数据和程序</span><strong><span class="ne-text">先放</span></strong><span class="ne-text">入存储器中，然后</span><strong><span class="ne-text">再启动</span></strong><span class="ne-text">计算机工作</span></li></ol><p id="c563b5321c8c4f9c9fe197d941f31d8c" class="ne-p"><br></p><p id="c6543040bbeda2deb8a0af5bcedbfad5" class="ne-p"><span class="ne-text">其中最主要的一点是第三点最主要！</span></p><h2 id="qiJfo"><span class="ne-text">数据的机器层次表示</span></h2><div class="ne-quote"><p id="9ce13ff84e9d3693974d273aad1b3f55" class="ne-p"><span class="ne-text">机器数的原码+反码+补码表示</span></p></div><p id="879c1e9515c98cc016b56c7e4493ca39" class="ne-p"><span class="ne-text">定点小数表示：阶码：小数点位数；尾数：在小数那里编码即可</span></p><p id="5da2b7534817403b242f7d9195016ef7" class="ne-p"><br></p><p id="86633fcf0244c9dd6ce3495f9cca8ddb" class="ne-p"><span class="ne-text">真值就是加正负所表现出来的</span></p><p id="357642719f8c68765b7df7a5421d34bf" class="ne-p"><br></p><div class="ne-quote"><p id="31eb1926fc3ea63fbb02fc712d0e54cb" class="ne-p"><span class="ne-text">给定计算机字长位数，知道各种情况下表示数值的范围</span></p></div><p id="c4ad836da807b205d6a6bb9b8594cda6" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1608863188017-8f6c8d66-710e-4880-8559-af59c6e37609.png" width="657.5" id="eaL0T" class="ne-image"></p><h2 id="YkVpK"><span class="ne-text">数值的机器运算</span></h2><div class="ne-quote"><p id="70123f476bc78a3897b756f6f2fd43d6" class="ne-p"><span class="ne-text">定点加减运算+判断结果是否溢出</span></p></div><ol class="ne-ol"><li id="b0920e9899d1e1bc286b45928ce10e93"><span class="ne-text">先写出两个数的补码（减法运算转换为加法运算即可）</span></li><li id="1777aeedda9391f96f2c10deb07df8f0"><span class="ne-text">然后进行二进制加法运算（遵循0+0=0，1+0=1，0+1=1，1+1=10向高位进位）</span></li><li id="87f1fdc8d85cb9d95fec626a2efa745f"><span class="ne-text">判断是否溢出【00：结果为正无溢出；01：正溢；10：负溢；11结果为负无溢出】</span></li><li id="122017f46b9bf7758f2a588f69ed49f8"><span class="ne-text">将[X+Y]补转换为[X+Y]真值</span></li></ol><div class="ne-quote"><p id="2ef8f2b15fa3f9a073b674d99b970ba2" class="ne-p"><span class="ne-text">定点乘法运算：原码一位乘法运算+补码一位乘法运算</span></p></div><p id="0905019b3ac25e330eb8feef29036281" class="ne-p"><span class="ne-text">原码一位乘法运算：</span></p><ol class="ne-ol"><li id="d4d3ac15c729c249277feca190144110"><span class="ne-text">先写出X和Y的绝对值|X|和|Y|</span></li><li id="f8b036cbfdbaf1be9896cee854b5d763"><span class="ne-text">让00.0……和|X|相加同时判断|Y|的最后一位（如果为1加|X|如果是0加0）</span></li><li id="1cc1be5ff7baa72b2b507ba296e33772"><span class="ne-text">加完之后右移一位，再判断，加了再判断，啥时候那个分隔符分没了，就好了……………</span></li><li id="0d20e618c0a38ecdb5808ea9b029ab8f"><span class="ne-text">最后判断真值符号</span></li></ol><p id="77b252cc036615a7948c6810cc3b4447" class="ne-p"><span class="ne-text">我写的个啥………………逃</span></p><p id="a12331a3fab11218e635d2837ea8382a" class="ne-p"><br></p><p id="c6e155cc91fa478a383e70393598fedb" class="ne-p"><span class="ne-text">补码一位乘法运算：</span></p><ol class="ne-ol"><li id="7188fa67760f6d1f9b9c2d8260604f68"><span class="ne-text">写出[X]补[-X]补[Y]补</span></li><li id="6470ab89f1179721d5f9a8d15771b337"><span class="ne-text">在[Y]补码尾巴后面加一个0，判断最后两位，（00加0；10加</span><span class="ne-text">[-X]补；01加</span><span class="ne-text">[X]补；11加0</span><span class="ne-text">）</span></li><li id="3bde37c7e803f097305188c472459c36"><span class="ne-text">让00.000……加上上面判断的加上某某</span></li><li id="9454f72239a79d3729dc6db38c4a7fbe"><span class="ne-text">又一直这样下去下去……</span></li><li id="eb2cb9a8e55705a195ed5c9a731b2e7e"><span class="ne-text">把补码换成原码即可……</span></li></ol><p id="0106ebfe35adb04961dfb580e8437c6c" class="ne-p"><span class="ne-text">…………逃🤣</span></p><h2 id="1GunN"><span class="ne-text">指令系统</span></h2><div class="ne-quote"><p id="f5ed26763e16575fce31eb067819e736" class="ne-p" style="text-align: left"><span class="ne-text">什么叫主程序和子程序？调用子程序还可以采用哪几种方法保存返回地址？画出图说明调用子程序的过程。</span></p></div><p id="204a01cee0bd9b479833edc5cf5f7815" class="ne-p"><span class="ne-text">主程序：</span><strong><span class="ne-text">通常</span></strong><span class="ne-text">的程序</span></p><p id="241dd345798400ab5c67846097f12a7d" class="ne-p"><strong><span class="ne-text"></span></strong></p><p id="7bb09abafb177f3d2e953ac0efee5ef0" class="ne-p"><span class="ne-text">子程序：可以被反复调用、</span><strong><span class="ne-text">公用</span></strong><span class="ne-text">的程序，只要知道其</span><strong><span class="ne-text">入口地址</span></strong><span class="ne-text">，就可以调用之，其就是我们编程常写的函数</span></p><p id="b7675f618d31c01265ce25e12799f835" class="ne-p"><br></p><p id="e619bbac62c03e91eec987482d66157d" class="ne-p"><span class="ne-text">保存返回地址的方法：</span></p><ul class="ne-ul"><li id="42c608e25ee0488f2036f9314d9bdb36"><span class="ne-text">子程序的第一个</span><strong><span class="ne-text">子单元</span></strong><span class="ne-text">存放返回地址，然后从第二个字单元开始执行子程序</span></li><li id="37347f7860837462c02c24acf3f3acf8"><strong><span class="ne-text">寄存器</span></strong><span class="ne-text">存放</span></li><li id="5143570db311f33bc33658bf07a5c836"><strong><span class="ne-text">堆栈</span></strong><span class="ne-text">保存</span></li></ul><p id="d7f843db66f7e3d41f618eff3dc0cd8e" class="ne-p"><br></p><p id="e75a14f7160c60c7b700722a62349832" class="ne-p"><span class="ne-text">以堆栈保存返回地址的方法来说明调用子程序的过程：</span></p><p id="31405bd4340cb931a268ad1d7c5a4891" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1608774330112-3e8bf3df-1091-4476-aa72-e9757e36a3e6.png" width="121" id="DF2GZ" class="ne-image"></p><div class="ne-quote"><p id="0bc9ae1fd9a06faefeef0492f7a546e9" class="ne-p"><span class="ne-text">如果某计算机调用子程序保存返回地址是上个问题的第一种方式，有这么几个问题：</span></p><ol class="ne-ol"><li id="fc1c868b1d3d81dd3fbd1bee778f62fd"><span class="ne-text">为这种方法设计一条从子程序转到主程序的返回指令</span></li><li id="0f2527e29c21f249548270f9a9ae0e96"><span class="ne-text">怎么在主程序和子程序之间进行传参</span></li><li id="36da0b43e2c23abb4b0e983e8f2c0c64"><span class="ne-text">可否用于子程序嵌套</span></li><li id="e7c2acec70b8fa57e42bdb4ca00a1de3"><span class="ne-text">可否用于子程序的递归</span></li><li id="4456529a4550141fcc599297b99334ef"><span class="ne-text">如果将该种方式改为第三种方式（堆栈方式），可否完成4</span></li></ol></div><ol class="ne-ol"><li id="2e1a3644ca845a6843fa8ee430780c81"><span class="ne-text">使用间接寻址方式</span></li></ol><p id="5b9e53296660beb156de5733c5da00b8" class="ne-p"><br></p><table id="2LYD7" class="ne-table" style="width: 912px"><tbody><tr style="height: 33px"><td width="304"><p id="816d21bd9c047ae4c49e5e033acac4a3" class="ne-p"><span class="ne-text">JMP</span></p></td><td width="304"><p id="b2e6b668ff1b9a9aa2c080e617e79de4_p_0" class="ne-p"><span class="ne-text">@</span></p></td><td width="304"><p id="a6e5e54fbd1a6a759ab4854adf387653_p_0" class="ne-p"><span class="ne-text">子程序首地址</span></p></td></tr></tbody></table><p id="19c173f676918d5da2d46703e15279e8" class="ne-p"><br></p><ol start="2" class="ne-ol"><li id="54263ce76ba764aeed91a9dfd54179d9"><span class="ne-text">可以利用寄存器或主存单元进行主、子程序间的参数传递</span></li><li id="b39dfb2b472800cb73eaef4a900e063c"><span class="ne-text">可以。返回的地址都放在子程序的第一个单元</span></li><li id="d3c8d5784ace5ed7c57897a1f8813c8f"><span class="ne-text">不可以。会破坏其内部结构</span></li><li id="5f702ef8ca222ad8cc0785dfca37759e"><span class="ne-text">可以。因为堆栈具有后进先出功能</span></li></ol><p id="c3d1751a96104ce576139282d838ca49" class="ne-p"><br></p><h2 id="SfjVG"><span class="ne-text">存储系统和结构</span></h2><div class="ne-quote"><p id="852ba6465f7286d6d69e3e2a10645446" class="ne-p"><span class="ne-text">如何区别存储器和寄存器？两者是一回事说法对吗？</span></p></div><p id="5fa952249ec83ac207a68223fd81fa3b" class="ne-p"><span class="ne-text">两者不是一回事。</span></p><p id="1c4e1d918a0b5dd1d5cd044b77043aa2" class="ne-p"><br></p><p id="fa47cd5ab7e43727a8671f6dcf693692" class="ne-p"><span class="ne-text">存储器是在</span><strong><span class="ne-text">CPU</span></strong><span class="ne-text">外边，用来存放数据和程序的，访问存储器的</span><strong><span class="ne-text">速度</span></strong><span class="ne-text">较慢；</span></p><p id="964d621dbb3f7a14565847f8787e0a0e" class="ne-p"><br></p><p id="a9b67f5dc531f3d148c75330767a08b3" class="ne-p"><span class="ne-text">寄存器数据CPU的一部分，访问寄存器的速度很快。</span></p><p id="cfb35d68ff524d04f1d7e765fac7a3c3" class="ne-p"><strong><span class="ne-text"></span></strong></p><div class="ne-quote"><p id="970947708aa151c237982f1afa409466" class="ne-p"><span class="ne-text">存储器的主要功能是什么？为什么把存储系统分成若干个不同层次？主要有那些层次？</span></p></div><p id="5caee85a402367e1707bf7235206b371" class="ne-p"><span class="ne-text">存储器的主要功能：存储数据和程序</span></p><p id="3f22f2a92b8fa4d7aef6ca88fd3143e7" class="ne-p"><br></p><p id="693872a58a506ecd748a075f12a33320" class="ne-p"><span class="ne-text">存储系统是有几个</span><strong><span class="ne-text">容量、速度、价格</span></strong><span class="ne-text">不同的存储器用硬件、软件、软硬件相结合起来的系统。分成若干个不同层次是因为考虑到不同存储器的价格因素、存储速度、存储容量三个因素。</span></p><p id="938a3900f42a61a964c49b0b8249e88d" class="ne-p"><br></p><ol class="ne-ol"><li id="dfc059d62bf5c064acdf25c194e89fbf"><span class="ne-text">高速缓存</span></li><li id="0d30099b072f94de5275190001870ce1"><span class="ne-text">主存</span></li><li id="f3fd3872a2030a914118032cb8879955"><span class="ne-text">辅存</span></li></ol><p id="0d36a4aa9c21de3a1f06c05887169957" class="ne-p"><br></p><p id="f9cff4010943d46fc8f00055d1ba95ef" class="ne-p"><span class="ne-text">其中12又称之为Cache-主存存储层次，23又称之为主存-辅存存储层次。</span></p><p id="6db556996c11f57a93040fa86544ce8a" class="ne-p"><br></p><div class="ne-quote"><p id="da18244217f0e6449790e6b1e28ee017" class="ne-p"><span class="ne-text">动态RAM为什么要刷新？一般有几种刷新方式？各有什么优缺点？</span></p></div><p id="54f00e02a63ab155c031bab9ada01c49" class="ne-p"><strong><span class="ne-text">为了维持DRAM的记忆单元的存储信息</span></strong></p><ul class="ne-ul"><li id="51369c4ec0bf4fbc746761810e0194b2"><strong><span class="ne-text">集中式</span></strong><span class="ne-text">刷新</span></li></ul><p id="f6a95914f2cfa71fd460e179cc771d20" class="ne-p"><span class="ne-text">优点：</span><strong><span class="ne-text">读写操作</span></strong><span class="ne-text">不受刷新工作的影响，</span><strong><span class="ne-text">存取速度</span></strong><span class="ne-text">高</span></p><p id="2f52e97ee9aa2445d61a8f62e81e1a40" class="ne-p"><br></p><p id="4c9f9dba696547423f74fd21d535cea1" class="ne-p"><span class="ne-text">缺点：存储容量越大，死区越长</span></p><ul class="ne-ul"><li id="7e617547b2ede92904e6e2dde8d1d3e7"><strong><span class="ne-text">分散式</span></strong><span class="ne-text">刷新</span></li></ul><p id="138316dc28b0c6e1e058fb29f04b1645" class="ne-p"><span class="ne-text">优点：没有死区</span></p><p id="218df8daebc9aa27392a1275a2eb4d13" class="ne-p"><br></p><p id="3b066343f56c3d85c5daa4e7af6741ee" class="ne-p"><span class="ne-text">缺点：加长了系统的</span><strong><span class="ne-text">存取周期</span></strong><span class="ne-text">，降低了整机的速度，并且刷新过于频繁，没有充分利用允许的最大刷新间隔</span></p><ul class="ne-ul"><li id="e35570a707be389e1f302033802d59c4"><strong><span class="ne-text">异步式</span></strong><span class="ne-text">刷新</span></li></ul><p id="a79792d9af9ffb369cd0cdcc59e0077d" class="ne-p"><span class="ne-text">异步式虽然有死区，但是比几种方式的</span><strong><span class="ne-text">死区小</span></strong><span class="ne-text">得多，而且</span><strong><span class="ne-text">减少了刷新次数</span></strong><span class="ne-text">，是比较实用的一种刷新方式。</span></p><p id="9e71039ca057d47c358f523ef0fd073a" class="ne-p"><br></p><h2 id="ITNcC"><span class="ne-text">中央处理器</span></h2><hr id="pj8gk" class="ne-hr"><div class="ne-quote"><p id="bcea3ec07206330004e2e3789c35ce09" class="ne-p"><span class="ne-text">控制器有哪几种控制方式？各有何特点？</span></p></div><ul class="ne-ul"><li id="069dd81db3936611fadcb15177e7d127"><strong><span class="ne-text">同步</span></strong><span class="ne-text">控制方式</span></li></ul><p id="fa54d530d058750d622b4c3f37d24d21" class="ne-p"><span class="ne-text">该控制方式各项操作都由统一的</span><strong><span class="ne-text">时序信号</span></strong><span class="ne-text">完成，并且在每个及其周期中产生统一的</span><strong><span class="ne-text">节拍电位和工作脉冲</span></strong><span class="ne-text">。这种方式设计简单，但是对于许多</span><strong><span class="ne-text">单指令</span></strong><span class="ne-text">来说，有太多的</span><strong><span class="ne-text">空闲时间</span></strong><span class="ne-text">，造成时间浪费，影响指令执行速度。</span></p><p id="07a4c5c2f6d132046518ad852d64ee7b" class="ne-p"><br></p><ul class="ne-ul"><li id="bbf515908cf3b84af7a41726dd1cfd1a"><strong><span class="ne-text">异步</span></strong><span class="ne-text">控制方式</span></li></ul><p id="d42c82b6ae1e7c98d3963038b6a1d464" class="ne-p"><span class="ne-text">该控制方式的各项操作都</span><strong><span class="ne-text">不由统一的时序信号</span></strong><span class="ne-text">完成，而是由指令本身或部件的具体情况决定，因此这种控制方式的效率高，时间能够合理利用，但是该控制方式也比较复杂。</span></p><p id="8a31a2411880accf26ba0334f49c72d0" class="ne-p"><br></p><ul class="ne-ul"><li id="54addc15f4395432239c5e127c4d33ec"><strong><span class="ne-text">联合</span></strong><span class="ne-text">控制方式</span></li></ul><p id="320df0179f596617b456951d7fc84d82" class="ne-p"><span class="ne-text">是由上面的同步控制方式和异步控制方式相结合的方式。</span></p><hr id="ZCrzr" class="ne-hr"><div class="ne-quote"><p id="89a2449ce0c4197c43b444f796c1a242" class="ne-p"><span class="ne-text">什么是三级时序系统？</span></p></div><p id="49334fc101fddb224f33914c5dd9c5d8" class="ne-p"><span class="ne-text">三级时序系统是指</span><strong><span class="ne-text">机器周期</span></strong><span class="ne-text">、</span><strong><span class="ne-text">节拍</span></strong><span class="ne-text">、</span><strong><span class="ne-text">工作脉冲</span></strong></p><p id="875d1d3a314a7947327aaaea9fccc003" class="ne-p"><br></p><p id="f051d98d24e8baf2b6ded9588bdae088" class="ne-p"><span class="ne-text">具体所属关系是：每个指令周期划分若干个机器周期，每个机器周期划分若干个节拍，每个节拍划分1个或几个工作脉冲。</span></p><hr id="HdIYa" class="ne-hr"><div class="ne-quote"><p id="545a4d1e85ebc11216d7299cf1133dfe" class="ne-p"><span class="ne-text">控制器有哪些基本功能？可分为哪几类？分类的依据是什么？</span></p></div><p id="cce468c294e11bad12e47b9429c69724" class="ne-p"><span class="ne-text">基本功能：</span></p><ul class="ne-ul"><li id="e3d0f91ef261179e42dfe616ba162512"><span class="ne-text">从主存中</span><strong><span class="ne-text">取出一条指令</span></strong><span class="ne-text">，并指出下一跳指令在主存中的位置</span></li><li id="917bd76d7485df150900a43755bf4ba2"><span class="ne-text">对指令进行</span><strong><span class="ne-text">译码或是测试</span></strong><span class="ne-text">，产生相应的操作控制信号，以便启动规定的工作</span></li><li id="a8fc5203632cb27284271c21f2fa09f0"><span class="ne-text">指挥并控制</span><strong><span class="ne-text">CPU</span></strong><span class="ne-text">，主存和输入输出设备之间的</span><strong><span class="ne-text">数据流动</span></strong></li></ul><p id="bed058693632f901f735bc5da78143b9" class="ne-p"><span class="ne-text">分类：</span></p><ul class="ne-ul"><li id="c539818b0a659b32407bb6ce0137f27a"><strong><span class="ne-text">组合逻辑</span></strong><span class="ne-text">型</span></li><li id="a9e8c918340cda1890553998780dbf20"><strong><span class="ne-text">存储逻辑</span></strong><span class="ne-text">型</span></li><li id="358a09680fbf3e00fdd45e35532b7ab5"><span class="ne-text">组合逻辑和存储逻辑</span><strong><span class="ne-text">结合</span></strong><span class="ne-text">型</span></li></ul><p id="22bfbaa2cbc6d8e4ff6d944cf683fa37" class="ne-p"><span class="ne-text">分类的依据：</span></p><p id="b95bdd01da2c3f224d79acd9d2575986" class="ne-p"><span class="ne-text">在于控制器的核心——</span><strong><span class="ne-text">微操作信号发生器的实现方法不同</span></strong><span class="ne-text">。</span></p><hr id="AaWg1" class="ne-hr"><div class="ne-quote"><p id="17f72232f2b1d5d97e0b1b9129cc987f" class="ne-p"><span class="ne-text">中央处理器有哪些功能？它是由那些基本部件构成的？</span></p></div><p id="e829c3e1520460b7e850f1288194b22f" class="ne-p"><span class="ne-text">构成：</span></p><ul class="ne-ul"><li id="cdac7027e772b3f3feb39658f4a7d544"><span class="ne-text">控制器</span></li><li id="bd2c6cf87849f07ef7000902847f1d0f"><span class="ne-text">运算器</span></li></ul><p id="4bdc50e6020643b565ed4bed5e3eee70" class="ne-p"><span class="ne-text">功能：</span></p><p id="a83025c5146a2600186b1edf659481d4" class="ne-p"><span class="ne-text">对数据流和指令流在时间上和空间上进行正确的控制。当然，对于冯诺依曼结构的计算机而言，数据流是基于指令流的操作而驱动的。</span></p><hr id="wZckO" class="ne-hr"><div class="ne-quote"><p id="b484dd2533aee804ce4b287497a435e9" class="ne-p"><span class="ne-text">中央处理器有哪几个主要寄存器？说说他们的结构和功能？</span></p></div><p id="77ba3dd412afabc7e9e503fc88442709" class="ne-p"><span class="ne-text">寄存器的功能就是用来存放程序运行过程中的中间结果、最终结果以及控制、状态信息的。</span></p><ul class="ne-ul"><li id="e13f8067776706b09322783c9c0827d3"><span class="ne-text">通用寄存器</span></li></ul><p id="c48ace8dd6a28c243eae640aff6c0130" class="ne-p"><span class="ne-text">用来存放原始数据和运算结果，有的还可以作为变址寄存器、计数器、地址指针等</span></p><ul class="ne-ul"><li id="2e7e0367e7370abbed35ebf62171d1bf"><span class="ne-text">专用寄存器</span></li></ul><p id="138e2900bb45f1c63a9789a37eab3c6a" class="ne-p"><span class="ne-text">是用来完成某些特定功能的寄存器：程序计数器（PC）、指令寄存器（IR）、存储器地址寄存器（MAR）、存储器数据寄存器（MDR）、程序状态字寄存器（PSWR）等</span></p><p id="669386b2f97c3ec049c32cc82ef9fb5a" class="ne-p"><br></p><div class="ne-quote"><p id="c4523aba7842fae72ae515c3f02e563e" class="ne-p"><span class="ne-text">以单指令为例，简要说明下列部件在计算机的取值周期和执行周期的作用。</span></p></div><ul class="ne-ul"><li id="1e201c5462e561a5857105d079538b16"><span class="ne-text">程序计数器（PC）：存放指令地址</span></li><li id="64ccffe53e1a34cb1afcf5ba6d7065ef"><span class="ne-text">指令寄存器（IR）：存放当前指令</span></li><li id="1fd6998aba727f19794915a8f481c016"><span class="ne-text">存储器地址寄存器（MAR）：进行算术逻辑运算</span></li><li id="d08be2ebbadaf994c98d0614e4089b5c"><span class="ne-text">存储器数据寄存器（MDR）：存放写入或读出的数据/指令</span></li><li id="c0a63d3a0b6ef0ddecda83aca430f580"><span class="ne-text">程序状态字寄存器（PSWR）：存放写入或读出的数据/指令的地址</span></li></ul><hr id="pnGgF" class="ne-hr"><div class="ne-quote"><p id="3c8ab0d3ddc3cd6174c3324ec8e0255d" class="ne-p"><span class="ne-text">什么是指令周期？什么是CPU周期？他们之间有什么关系？</span></p></div><p id="eea0bee762845c5dda2546a1ab1cda0b" class="ne-p"><span class="ne-text">指令周期：指</span><strong><span class="ne-text">取指令</span></strong><span class="ne-text">、</span><strong><span class="ne-text">分析指令</span></strong><span class="ne-text">到</span><strong><span class="ne-text">执行指令</span></strong><span class="ne-text">所花费的所有时间</span></p><p id="2a66bfbbbb1d05b8957fa4ab4c013bbf" class="ne-p"><br></p><p id="dcd2fcd80d5598b99b9470ecc5855f99" class="ne-p"><span class="ne-text">CPU周期：也叫</span><strong><span class="ne-text">机器周期</span></strong><span class="ne-text">，是指完成一个基本操作所花费的时间</span></p><p id="17bed01c4b7b0d346941e5a5450d04d8" class="ne-p"><span class="ne-text">一个指令周期划分为多个CPU周期</span></p><hr id="yXu0E" class="ne-hr"><h2 id="K6voT"><span class="ne-text">【总线+外部设备】nothing</span></h2><h2 id="dmz3A"><span class="ne-text">输入输出系统</span></h2><hr id="AFwJf" class="ne-hr"><div class="ne-quote"><p id="2d329cb51b5a202823a61a48ed8448fd" class="ne-p"><span class="ne-text">什么是计机的输入输出系统？输入输出设备有哪些编址方式？有什么特点？</span></p></div><p id="edefd57ab69af8470668ff2a424356a1" class="ne-p"><span class="ne-text">输入输出系统：包括输入输出</span><strong><span class="ne-text">接口</span></strong><span class="ne-text">和输入输出信息</span><strong><span class="ne-text">传送</span></strong><span class="ne-text">控制方式，是计算机系统中最具有</span><strong><span class="ne-text">多样性</span></strong><span class="ne-text">和</span><strong><span class="ne-text">复杂性</span></strong><span class="ne-text">的部分。</span></p><p id="f9fc8ac6291156b3f05b224fd32bf2ed" class="ne-p"><br></p><p id="ab87944d3ce6f7a51fefd1953f5351d9" class="ne-p"><span class="ne-text">编址方式：</span></p><ul class="ne-ul"><li id="2707ef199b4f1e9984f5b26de524424b"><strong><span class="ne-text">独立编址</span></strong></li></ul><p id="fabc1c5bddd0b669a0124171c4db4f1a" class="ne-p"><span class="ne-text">优点：指令易于区分，译码简单，主存空间不会减少</span></p><p id="d563ec5ff4b439085cb9ab1601704308" class="ne-p"><br></p><p id="0cc8b5d976bbc529e4debeb63ec9d40b" class="ne-p"><span class="ne-text">缺点：增加了控制线I/ORead和I/OWrite信号</span></p><ul class="ne-ul"><li id="27da5029a93cb3f29a4b7ddd5149a335"><strong><span class="ne-text">统一编址</span></strong></li></ul><p id="db0394b2e9cbdd8e060cbcef65b95726" class="ne-p"><span class="ne-text">优点：总线结构简单，全部访存类指令都可用于控制外设，可直接对外设寄存器进行各种运算</span></p><p id="c9ec0f4c81c14859d4f616d21c82d21a" class="ne-p"><br></p><p id="d0d4cb0e5308de9987cc3b8cf6f2cc15" class="ne-p"><span class="ne-text">缺点：占用主存一部分地址，缩小了可用的主存空间</span></p><hr id="muQ6M" class="ne-hr"><div class="ne-quote"><p id="b22a986de3efd0a5b8efa407e847f202" class="ne-p"><span class="ne-text">什么是I/O接口？I/O接口有哪些特点和功能？接口有哪些类型？</span></p></div><p id="98a2cf08c7c301f2ab0aba9ea1fd7cd0" class="ne-p"><span class="ne-text">主机和外设之间的交接界面</span></p><p id="83a9756d9dc7e015d8768506f919ec9b" class="ne-p"><br></p><p id="4333b6c723d94f845b3a5614e3095f64" class="ne-p"><span class="ne-text">特点：</span></p><p id="b712a5be993fb88c5d4d62baea0b6f6f" class="ne-p"><span class="ne-text">实现信息交换</span></p><p id="544d1cc53d23366b107405a2ea8f7bb0" class="ne-p"><br></p><p id="0cc25be04a53a0c916aac101aba94675" class="ne-p"><span class="ne-text">功能：</span></p><ul class="ne-ul"><li id="5c723efbc9ebbf5520e009a67bc22003"><span class="ne-text">实现主机和外设的通信联络控制</span></li><li id="b6fea9d4ef882ec6551e95c5b93c35cc"><span class="ne-text">进行地址译码和设备选择</span></li><li id="4720e6750b9905bf1076f2a89350bad0"><span class="ne-text">实现数据缓冲</span></li><li id="1af433d251035ab2181cbd62799cc149"><span class="ne-text">完成数据格式的变换</span></li><li id="d3b797cf76b8bb289949ce0cf39c04f7"><span class="ne-text">传递控制命令和状态信息</span></li></ul><p id="48b588f728fe021b99967853961b8497" class="ne-p"><span class="ne-text">类型：</span></p><ul class="ne-ul"><li id="21882bf923e3234f90da98bf2614405e"><span class="ne-text">串行接口</span></li><li id="8175ce14a9e0743c683ef38001d276a7"><span class="ne-text">并行接口</span></li></ul><p id="4a6b52ff999522ae3c33345921945361" class="ne-p"><br></p><hr id="trvup" class="ne-hr"><p id="77cc6dc8295348d4c2f8d497aa36ea99" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1608728980150-18e3d2ee-cc80-4187-b38c-14c78554e979.png" width="589" id="xIuDJ" class="ne-image"></p><p id="ee38f7a51426771d7c16bea8a84cea26" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1608729028676-c983dd94-3689-431d-bf54-76bbb5b01f75.png" width="394" id="auSQX" class="ne-image"></p><p id="617d7abbbc2b6c009ce7716456731744" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1608729049887-aee5cd74-e49d-44d1-88b2-bcdc511ff3c3.png" width="484" id="jcRjZ" class="ne-image"></p><p id="306325c19a7a2f3a0d213b5f5e4fee4f" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1608729065956-47dc5b50-caaa-44a1-a54e-8e3f5ae2192a.png" width="343.5" id="mPHNN" class="ne-image"></p><p id="399fce97c541358e15ec13808166372b" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1608729081886-f27d6175-e541-4379-b158-0093a23b693d.png" width="461" id="oRfmo" class="ne-image"></p><p id="6bfd4491ff863d27832ff22b4c2c8283" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1608729097801-61fd270b-1608-48ab-b1fa-a951febba5d6.png" width="453.5" id="yeoZf" class="ne-image"></p><p id="f4b79ef71832f8c5a407ba8be18261a4" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1608729108461-95f5d6e5-efd6-4acf-a2c7-fb72f6052d25.png" width="448.5" id="cRak4" class="ne-image"></p><p id="8896d7b3ea160b9a6486690e87021da2" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1608729131667-e6955db4-4b2c-4efb-ad1f-3acf8ccc5e48.png" width="487" id="Y7pz1" class="ne-image"></p><p id="449b7cd92863b968e08149ab77db3031" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1608729144873-1a207e20-98d9-4e44-b40e-c1a81a54b667.png" width="484" id="VOGan" class="ne-image"></p><p id="cf52e2046f0c6701e6ccd82a088c7b2a" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1608729157489-b3899992-00d9-405b-8f02-9619f08d9960.png" width="469" id="evibg" class="ne-image"></p><p id="65832d59e9fafe63982b5add438c52ac" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1608729176250-7499ab5f-2a40-4514-92f3-afc46c739936.png" width="502.5" id="MLKi5" class="ne-image"></p><p id="0234382e72464867bc7bd05cba0e3ce4" class="ne-p"><br></p><p id="120b5003507e6a34cb6f0c259cd54f7f" class="ne-p"><br></p><p id="2011e3c76f08a21c0746f4bc94d537a7" class="ne-p"><br></p></div>]]></content>
      
      
      <categories>
          
          <category> 计算机素养 </category>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>VuePress初体验</title>
      <link href="/blog/czl3oc/"/>
      <url>/blog/czl3oc/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h2 id="ozvnV"><span class="ne-text">安装Yarn</span></h2><div class="ne-quote"><p id="9f230f3078dda28f9190829db7cf14f5" class="ne-p"><span class="ne-text">Yarn 是为了弥补 npm 的一些缺陷而生的</span></p></div><p id="18f7bf9e434b2aa7bf34c07f048c0400" class="ne-p"><span class="ne-text">具体参考：</span><a href="https://zhuanlan.zhihu.com/p/27449990" data-href="https://zhuanlan.zhihu.com/p/27449990" target="_blank" class="ne-link"><span class="ne-text">https://zhuanlan.zhihu.com/p/27449990</span></a></p><h3 id="sUZiq"><span class="ne-text">引导式安装</span></h3><p id="308b0baf1ce6d0c44024f8c422ab9c07" class="ne-p"><a href="https://classic.yarnpkg.com/zh-Hans/docs/install#windows-stable" data-href="https://classic.yarnpkg.com/zh-Hans/docs/install#windows-stable" target="_blank" class="ne-link"><span class="ne-text">下载地址</span></a></p><p id="e9f75a338ae8719f5690c2481f765c56" class="ne-p"><span class="ne-text">使用Windows版的下载安装即可</span></p><p id="4f0292a57b73306d20fdb988adeb8053" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1608540352757-ed3ef592-f042-4262-9378-42aa9d053fcd.png" width="216.5" id="cUHeI" class="ne-image"></p><h3 id="HmpLs"><span class="ne-text">bash安装</span></h3><p id="45d24035c8269d64a7dec4fd942e155f" class="ne-p"><span class="ne-text">在bash里面不能显示，在bash里面下载</span></p><p id="f0590a47339cb2f102ce3a00b82f4f8e" class="ne-p"><code class="ne-code"><span class="ne-text">npm install -g yarn</span></code><span class="ne-text"> 即可</span></p><h2 id="BAmwf"><span class="ne-text">将 VuePress 安装为本地依赖</span></h2><h3 id="hTgJ6"><span class="ne-text">yarn init</span></h3><p id="2138ae8db26c8146a6b1ba44f50470ed" class="ne-p"><span class="ne-text">yarn init 出错</span></p><pre><code>error An unexpected error occurred: &quot;Can't answer a question unless a user TTY&quot;. info If you think t</code></pre><p id="a5a86f73bd4bb824ef123a24a7d72df7" class="ne-p"><br></p><p id="c930e64598c0fab55a88f896ba724116" class="ne-p"><strong><span class="ne-text">使用cmd或者power shell不要使用bash</span></strong></p><p id="254831a44128efb65c0596eafc3d2e1e" class="ne-p"><br></p><h3 id="y9C7f"><span class="ne-text">yarn add -D vuepress</span></h3><p id="d5bd5357c4ae3e4a21e8e621cc185459" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1608541125538-3124ff43-0574-4bfd-a290-908621b54644.png" width="960" id="wwNV3" class="ne-image"></p><h3 id="CfmJf"><span class="ne-text">创建一篇文章</span></h3><p id="57df215360093e1966f8fc3f2b635a57" class="ne-p"><span class="ne-text">在bash创建，在powershell里面创建会报错</span></p><pre><code>mkdir docs &amp;&amp; echo '# Hello VuePress' &gt; docs/README.md</code></pre><p id="616f3cc2b927ab5cce32e0b7c3e04b61" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1608541380531-3ad1565f-0eef-4dac-bebf-64d1a131d7f3.png" width="580" id="RwhmG" class="ne-image"></p><h3 id="7N75d"><span class="ne-text">添加脚本</span></h3><pre><code>&#123;  &quot;name&quot;: &quot;my-site&quot;,  &quot;version&quot;: &quot;1.0.0&quot;,  &quot;main&quot;: &quot;index.js&quot;,  &quot;license&quot;: &quot;MIT&quot;,  &quot;devDependencies&quot;: &#123;    &quot;vuepress&quot;: &quot;^1.7.1&quot;  &#125;,  &quot;scripts&quot;: &#123;    &quot;docs:dev&quot;: &quot;vuepress dev docs&quot;,    &quot;docs:build&quot;: &quot;vuepress build docs&quot;  &#125;&#125;<p></code></pre></p><h3 id="D36sT"><span class="ne-text">运行</span></h3><p id="f29d4b5825726ddeecc7b678467b47c8" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1608541418296-b53b29dc-f6a9-480f-b65d-009a21c0d013.png" width="475.5" id="YrVlg" class="ne-image"></p><p id="0657fe2ea1293fafb661fb2b837f9bbf" class="ne-p"><span class="ne-text">端口访问：</span><a href="http://localhost:8080/" data-href="http://localhost:8080/" target="_blank" class="ne-link"><span class="ne-text">http://localhost:8080/</span></a></p><p id="b08fb81c68f3ededd960aa218a6dc28d" class="ne-p"><br></p></div>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
          <category> 博客技术 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[转]低谷</title>
      <link href="/essay/vpzzbr/"/>
      <url>/essay/vpzzbr/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><blockquote class="ne-quote"><p class="ne-p" style="text-align: left"><span class="ne-text">不要害怕低谷，这是上天给你的升级时间</span></p><p class="ne-p" style="text-align: left"><span class="ne-text">有个好玩的现象，我这里的畅销书，绝大多数是在作者低谷的时候写出来的。比如创业失败、被公司裁员、或者身体不好在家休息等等。</span></p><p class="ne-p" style="text-align: left"><span class="ne-text"></span></p><p class="ne-p" style="text-align: left"><span class="ne-text">为什么呢？因为事业上升时，人被事情推着走，每天忙忙碌碌，没有一块时间思考和复盘。</span></p><p class="ne-p" style="text-align: left"><span class="ne-text">进入低谷后，时间充足，可以好好整理思想了，把以前的经验体系化，于是一本畅销书横空出世。更重要的是，这本书已成为他的视野催化剂，走向人生的第二巅峰。</span></p><p class="ne-p" style="text-align: left"><span class="ne-text"></span></p><p class="ne-p" style="text-align: left"><span class="ne-text">低谷不可怕，可怕的是一蹶不振啊。</span></p><p class="ne-p" style="text-align: left"><span class="ne-text"></span></p><p class="ne-p" style="text-align: left"><strong><span class="ne-text">转载自：写书哥（同微博）</span></strong></p></blockquote></div>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CSS的高级使用技巧</title>
      <link href="/blog/rpd10b/"/>
      <url>/blog/rpd10b/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h2 id="Jhdvr"><span class="ne-text">元素的显示与隐藏</span></h2><ul class="ne-ul"><li id="9529167b8d0f57e8b28066d12a417060"><span class="ne-text">目的：让一个元素在页面中消失或者显示出来</span></li><li id="5ba573d756e49918e8b7e9abf01396c7"><span class="ne-text">场景：类似网站广告，当我们点击关闭就不见了，但是我们重新刷新页面，会重新出现！</span></li></ul><h3 id="EOj9M"><span class="ne-text">display</span></h3><ul class="ne-ul"><li id="4f5c75f3cafc53a001c7dae26d016cd6"><span class="ne-text">display 显示</span></li><li id="88c2502b916a6501783260e73e5bcd18"><span class="ne-text">display 设置或检索对象是否及如何显示</span></li><li id="7c61bd1b47861ccbf0d3c08c6f3e2454"><span class="ne-text">特点： 隐藏之后，不再保留位置。</span></li><li id="e2cd1451bbb22ffeccb9e07c0cff59ef"><span class="ne-text">实际开发场景：配合后面js做特效，比如下拉菜单，原先没有，鼠标经过，显示下拉菜单， 应用极为广泛</span></li></ul><pre><code>display: none 隐藏对象display：block 除了转换为块级元素之外，同时还有显示元素的意思。</code></pre><p id="25db14fa799b5cf27d5b28e473411aa8" class="ne-p"><br></p><p id="b519c7693aaee180b8c4885264ff11ba" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611549560775-2b5ddfb8-b678-4e07-8d41-1f5388980dc8.png" width="718" id="w1I1o" class="ne-image"></p><h3 id="2G8i7"><span class="ne-text">visibility</span></h3><ul class="ne-ul"><li id="be05658521767539604139ec292ac0df"><span class="ne-text">visibility 可见性</span></li><li id="0373a762c21e5d428ee0935ab080b209"><span class="ne-text">设置或检索是否显示对象。</span></li><li id="daa91cf6afa66be1a04fc74f8455b072"><span class="ne-text">特点： 隐藏之后，继续保留原有位置。（停职留薪）</span></li></ul><pre><code>visibility：visible ; 　对象可视visibility：hidden; 　  对象隐藏</code></pre><p id="d23c24c7a58bb5a767e3a8aa83f88a21" class="ne-p"><br></p><p id="5d14ed11bb8939dd4386da375541e51d" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611549560856-f5a4403c-b0c3-4296-b220-48c85187c525.png" width="680" id="dBE1a" class="ne-image"></p><h3 id="4vk3a"><span class="ne-text">overflow</span></h3><ul class="ne-ul"><li id="c16fdcbb93efb354f3fd90cf1ab42684"><span class="ne-text">overflow 溢出</span></li><li id="e1b102de3716c3fc5b98406442522033"><span class="ne-text">检索或设置当对象的内容超过其指定高度及宽度时如何管理内容。</span></li></ul><div class="ne-quote"><p id="8a8b61a3a5c978efad76314b98b5222d" class="ne-p"><span class="ne-text">实际开发场景</span></p></div><ul class="ne-ul"><li id="624aab650764edf38f02b252f9cd1a43"><span class="ne-text">清除浮动</span></li><li id="e7e941d52cdbfa66f0b0130501ff2b67"><span class="ne-text">隐藏超出内容，隐藏掉,  不允许内容超过父盒子。</span></li></ul><table id="w4er2" class="ne-table" style="width: 682px"><tbody><tr style="height: 33px"><td width="343"><p id="u997ad859" class="ne-p"><span class="ne-text">属性值</span></p></td><td width="339"><p id="ua872851c" class="ne-p"><span class="ne-text">描述</span></p></td></tr><tr style="height: 33px"><td width="343"><p id="u163abeb4" class="ne-p"><strong><span class="ne-text">visible</span></strong></p></td><td width="339"><p id="u3c7cf5d8" class="ne-p"><span class="ne-text">不剪切内容也不添加滚动条</span></p></td></tr><tr style="height: 33px"><td width="343"><p id="ue8f321f5" class="ne-p"><strong><span class="ne-text">hidden</span></strong></p></td><td width="339"><p id="u6bf96c7d" class="ne-p"><span class="ne-text">不显示超过对象尺寸的内容，超出的部分隐藏掉</span></p></td></tr><tr style="height: 33px"><td width="343"><p id="u540aa4fb" class="ne-p"><strong><span class="ne-text">scroll</span></strong></p></td><td width="339"><p id="u5c58a409" class="ne-p"><span class="ne-text">不管超出内容否，总是显示滚动条</span></p></td></tr><tr style="height: 33px"><td width="343"><p id="ub2dbf114" class="ne-p"><strong><span class="ne-text">auto</span></strong></p></td><td width="339"><p id="ue2e31adc" class="ne-p"><span class="ne-text">超出自动显示滚动条，不超出不显示滚动条</span></p></td></tr></tbody></table><p id="25112e16312d02a11054e2cd716f4dba" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611549560959-143b1112-5b3f-4ccd-ab2c-2172cda7197d.png" width="794" id="nKi63" class="ne-image"></p><p id="093cabf81548d38145bdec9e00a702a8" class="ne-p"><br></p><h2 id="5WlIO"><span class="ne-text">CSS用户界面样式</span></h2><h3 id="qQI6B"><span class="ne-text">cursor</span></h3><ul class="ne-ul"><li id="41e57d3adf3facef2de68f102c9d1465"><span class="ne-text">设置或检索在对象上移动的鼠标指针采用何种系统预定义的光标形状。</span></li></ul><table id="t3WcO" class="ne-table" style="width: 703px"><tbody><tr style="height: 33px"><td width="344"><p id="uc9dc36dd" class="ne-p"><span class="ne-text">属性值</span></p></td><td width="359"><p id="ud6a69903" class="ne-p"><span class="ne-text">描述</span></p></td></tr><tr style="height: 33px"><td width="344"><p id="u3ad6d5bc" class="ne-p"><strong><span class="ne-text">default</span></strong></p></td><td width="359"><p id="uc68a248f" class="ne-p"><span class="ne-text">小白  默认</span></p></td></tr><tr style="height: 33px"><td width="344"><p id="u3dfa2de3" class="ne-p"><strong><span class="ne-text">pointer</span></strong></p></td><td width="359"><p id="u2a256e90" class="ne-p"><span class="ne-text">小手</span></p></td></tr><tr style="height: 33px"><td width="344"><p id="u74f2f34c" class="ne-p"><strong><span class="ne-text">move</span></strong></p></td><td width="359"><p id="u4e491462" class="ne-p"><span class="ne-text">移动</span></p></td></tr><tr style="height: 33px"><td width="344"><p id="u71fa96a9" class="ne-p"><strong><span class="ne-text">text</span></strong></p></td><td width="359"><p id="uc6a6ea4d" class="ne-p"><span class="ne-text">文本</span></p></td></tr><tr style="height: 33px"><td width="344"><p id="u9e1c08e6" class="ne-p"><strong><span class="ne-text">not-allowed</span></strong></p></td><td width="359"><p id="ub566d336" class="ne-p"><span class="ne-text">禁止</span></p></td></tr></tbody></table><p id="16868c1e94d68280bfb42d59fd3283b5" class="ne-p"><br></p><pre><code>&lt;ul&gt;  &lt;li style=&quot;cursor:default&quot;&gt;我是小白&lt;/li&gt;  &lt;li style=&quot;cursor:pointer&quot;&gt;我是小手&lt;/li&gt;  &lt;li style=&quot;cursor:move&quot;&gt;我是移动&lt;/li&gt;  &lt;li style=&quot;cursor:text&quot;&gt;我是文本&lt;/li&gt;  &lt;li style=&quot;cursor:not-allowed&quot;&gt;我是文本&lt;/li&gt;&lt;/ul&gt;</code></pre><h3 id="f9Nul"><span class="ne-text">outline</span></h3><p id="fec246643f3f54589f01ed093d583f25" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611549561022-9a6b408d-50da-4b18-ba1a-16277bd1a763.png" width="181" id="NZwru" class="ne-image"></p><ul class="ne-ul"><li id="0b39c98a35c39d0dc97c2b837e6c177b"><span class="ne-text">是绘制于元素周围的一条线，位于边框边缘的外围，可起到突出元素的作用。</span></li></ul><pre><code>outline : outline-color ||outline-style || outline-width</code></pre><ul class="ne-ul"><li id="1bcd3d1c4de49da3400763c6acc796ba"><span class="ne-text">但是我们都不关心可以设置多少，我们平时都是去掉的。 li</span></li><li id="eff9ba399c43efc89dff29bcd576affc"><span class="ne-text">最直接的写法是 ：  outline: 0;   或者  outline: none;</span></li></ul><pre><code>&lt;input  type=&quot;text&quot;  style=&quot;outline: 0;&quot;/&gt;</code></pre><h3 id="Lmrzm"><span class="ne-text">resize</span></h3><ul class="ne-ul"><li id="48d49fe4063ec2ee4592648548a5fa5f"><span class="ne-text">防止拖拽文本域resize</span></li></ul><p id="19e6347d3c015e4e4b8abb5bfa547466" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611549561079-ecbc9d77-f458-4317-b1f5-7687fb8388f4.png" width="416" id="X22Js" class="ne-image"></p><p id="17585032023ce8962c2c179949ba9a6c" class="ne-p"><span class="ne-text">实际开发中，我们文本域右下角是不可以拖拽：</span></p><pre><code>&lt;textarea  style=&quot;resize: none;&quot;&gt;&lt;/textarea&gt;</code></pre><h2 id="cm4Wa"><span class="ne-text">vertical-align</span></h2><ul class="ne-ul"><li id="86ac5d75e16dbded16e2ddb1064372fe"><span class="ne-text">有宽度的块级元素居中对齐，是margin: 0 auto;</span></li><li id="54f067028aaaa15f69145d261fea1c17"><span class="ne-text">让文字居中对齐，是 text-align: center;</span></li><li id="ce39d3388b4a26f92857c3e6b3131a15"><span class="ne-text">vertical-align 垂直对齐，它只针对于</span><strong><span class="ne-text" style="background-color: #FADB14">行内元素</span></strong><span class="ne-text" style="background-color: #FADB14">或者</span><strong><span class="ne-text" style="background-color: #FADB14">行内块元素</span></strong></li></ul><p id="98de1b595d456d51ee76897af52dec8b" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/jpg/1484158/1611549561144-6cc18baa-04db-44b3-837f-a6c6dba0f5d5.jpg" width="750" id="QGjdo" class="ne-image"></p><pre><code>vertical-align : baseline |top |middle |bottom</code></pre><p id="8ec081d561eb05ad08907653bdcf8407" class="ne-p"><span class="ne-text">设置或检索对象内容的垂直对其方式。</span></p><ul class="ne-ul"><li id="205f5b757fb62f731253d80649d5c26f"><span class="ne-text">注意：<br /></span><span class="ne-text">vertical-align 不影响块级元素中的内容对齐，它只针对于</span><strong><span class="ne-text">行内元素</span></strong><span class="ne-text">或者</span><strong><span class="ne-text">行内块元素</span></strong><span class="ne-text">，<br /></span><span class="ne-text">特别是行内块元素， </span><strong><span class="ne-text">通常用来控制图片/表单与文字的对齐</span></strong><span class="ne-text">。</span></li></ul><h3 id="odw46"><span class="ne-text">图片、表单和文字对齐</span></h3><p id="6349b0e62ee3e5cd261a51aa0148d4b3" class="ne-p"><span class="ne-text">所以我们知道，我们可以通过vertical-align 控制图片和文字的垂直关系了。 默认的图片会和文字基线对齐。</span></p><p id="68b9c67a32d5d0705deaaecc22532333" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611552656909-663d0bb7-812d-43ec-93a1-c2f4e0fc7f2c.png" width="260" id="tmp5k" class="ne-image"></p><p id="fecb4428e0c228a252bcd5a9047dc47d" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611549561232-122c97fa-81ab-4941-bb7f-a82c77d34e8b.png" width="936" id="vVjCq" class="ne-image"></p><h3 id="s2TTt"><span class="ne-text">去除图片底侧空白缝隙</span></h3><p id="eab66bb5a3d92eca593c3044efafa083" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611549561364-5f9b7f14-f3ab-4031-8770-3d51f9656cbc.png" width="302" id="lf5jQ" class="ne-image"></p><ul class="ne-ul"><li id="3eaf2da73ef8fae4d4b148111d42baeb"><span class="ne-text">原因：<br /></span><span class="ne-text">图片或者表单等行内块元素，他的底线会和父级盒子的基线对齐。<br /></span><span class="ne-text">就是图片底侧会有一个空白缝隙。</span></li><li id="399a31badd1ce64c23cae6f81a653d52"><span class="ne-text">解决的方法就是：</span></li></ul><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="e0906f5e44e7715bfbc4d3c01476d7cb"><span class="ne-text">给img vertical-align:middle | top| bottom等等。  让图片不要和基线对齐。</span><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611549561421-0668f2a0-ebf9-41bf-9470-f9411a85fc27.png" width="500" id="z5cpu" class="ne-image"></li><li id="2a9bae30c396e46a76e9ce37ce82112c"><span class="ne-text">给img 添加 display：block; 转换为块级元素就不会存在问题了。</span><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611549561496-59e91163-2753-4dcb-9e6b-38c048ffda33.png" width="500" id="duRA2" class="ne-image"></li></ul></ul><h2 id="0rxmd"><span class="ne-text">4. 溢出的文字省略号显示</span></h2><h3 id="A3iqY"><span class="ne-text">white-space</span></h3><ul class="ne-ul"><li id="128d6e2d151a19d0999ce3fd1cb5c38d"><span class="ne-text">white-space设置或检索对象内文本显示方式。通常我们使用于强制一行显示内容</span></li></ul><pre><code>white-space:normal ；默认处理方式white-space:nowrap ；　强制在同一行内显示所有文本，直到文本结束或者遭遇br标签对象才换行。</code></pre><h3 id="Kh3gj"><span class="ne-text">text-overflow 文字溢出</span></h3><ul class="ne-ul"><li id="7f06cd46c7f79687786f2f72ba3f4e92"><span class="ne-text">设置或检索是否使用一个省略标记（...）标示对象内文本的溢出</span></li></ul><pre><code>text-overflow : clip ；不显示省略标记（...），而是简单的裁切 text-overflow：ellipsis ； 当对象内文本溢出时显示省略标记（...）</code></pre><p id="a7b55bef22c9192b6c64720026118520" class="ne-p"><strong><span class="ne-text">注意</span></strong><span class="ne-text">：</span></p><p id="dcd247f302a759ad767d11f946ec29ac" class="ne-p"><span class="ne-text">一定要首先强制一行内显示，再次和overflow属性  搭配使用</span></p><p id="d5c5aa4ccc4393d3f8b2b15b0ab96538" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611549561575-da9313fd-2a27-4d05-8d6e-9c4ded39cf0c.png" width="104" id="CWi5m" class="ne-image"></p><h3 id="T23KM"><span class="ne-text">总结三步曲</span></h3><pre><code>/*1. 先强制一行内显示文本*/      white-space: nowrap;  /*2. 超出的部分隐藏*/      overflow: hidden;  /*3. 文字用省略号替代超出的部分*/      text-overflow: ellipsis;</code></pre><h2 id="uSsQP"><span class="ne-text">5. CSS精灵技术（sprite) 重点</span></h2><h3 id="5noZB"><span class="ne-text">为什么需要精灵技术</span></h3><p id="32e95c8aecf1fe634ceb862a0b1ed239" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611549561631-f7ca8545-e322-4363-8524-c1c9f49c0c20.png" width="886" id="FXKFz" class="ne-image"></p><p id="41a78bb4f3d3247ee7b55985c65efb88" class="ne-p"><span class="ne-text">图所示为网页的请求原理图，当用户访问一个网站时，需要向服务器发送请求，网页上的每张图像都要经过一次请求才能展现给用户。</span></p><p id="676ca0afe7895aae396818f4cb5d7e35" class="ne-p"><span class="ne-text">然而，一个网页中往往会应用很多小的背景图像作为修饰，当网页中的图像过多时，服务器就会频繁地接受和发送请求，这将大大降低页面的加载速度。</span></p><p id="8a52355ca7e2460f5f1513dfd4f0ffe4" class="ne-p"><strong><span class="ne-text">pink老师告诉你我们为什么需要精灵技术：</span></strong></p><div class="ne-quote"><p id="e8cd473ebbc0e908f86eece369e8d01f" class="ne-p"><strong><span class="ne-text">为了有效地减少服务器接受和发送请求的次数，提高页面的加载速度。</span></strong></p></div><p id="b58341294558ebddbbc4151c72298380" class="ne-p"><span class="ne-text">出现了CSS精灵技术（也称CSS Sprites、CSS雪碧）。</span></p><h3 id="XbUO8"><span class="ne-text">精灵技术讲解</span></h3><p id="179f990b433173cf3e4d15618a7189a6" class="ne-p"><span class="ne-text">CSS 精灵其实是将网页中的一些背景图像整合到一张大图中（精灵图），然而，各个网页元素通常只需要精灵图中不同位置的某个小图，要想精确定位到精灵图中的某个小图。</span></p><p id="45cedfa778352656a21737d4d535f742" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611549561713-9f18eeb4-7450-43f0-b6e2-3c3921cf33f2.png" width="220" id="EeJGM" class="ne-image"></p><p id="03e31c8e58ecf636a529dd3eb6597846" class="ne-p"><span class="ne-text">这样，当用户访问该页面时，只需向服务发送一次请求，网页中的背景图像即可全部展示出来。</span></p><p id="640de1f114240b01c834e5712a5b6922" class="ne-p"><span class="ne-text">我们需要使用CSS的</span></p><ul class="ne-ul"><li id="4e90a74ac132d59864edff30faabc764"><span class="ne-text">background-image、</span></li><li id="1c6c93c6671d981d173d9290e62ac247"><span class="ne-text">background-repeat</span></li><li id="a6d0c9d05da186d6e47b7ce90e211746"><span class="ne-text">background-position属性进行背景定位，</span></li><li id="ea774e082446994552b612f9b76dc72d"><span class="ne-text">其中最关键的是使用background-position 属性精确地定位。</span></li></ul><h3 id="xWxbR"><span class="ne-text">精灵技术使用的核心总结</span></h3><p id="5530cb772368cb4d5a24ff6df722d650" class="ne-p"><span class="ne-text">首先我们知道，css精灵技术主要针对于背景图片，插入的图片img 是不需要这个技术的。</span></p><ol class="ne-ol"><li id="36374d92259ca85fcf40ff8e66321a8c"><span class="ne-text">精确测量，每个小背景图片的大小和 位置。</span></li><li id="64d170bf78f5ce9ed29ffd945743fe32"><span class="ne-text">给盒子指定小背景图片时， 背景定位基本都是 负值。</span></li></ol><h3 id="P9hvK"><span class="ne-text">制作精灵图(了解)</span></h3><p id="318a61438b3b1208629274d77942e456" class="ne-p"><span class="ne-text">CSS 精灵其实是将网页中的一些背景图像整合到一张大图中（精灵图），那我们要做的，就是把小图拼合成一张大图。</span></p><p id="44e10d2e649e50ceee9cf5e81a6e035d" class="ne-p"><span class="ne-text">大部分情况下，精灵图都是网页美工做。</span></p><pre><code>我们精灵图上放的都是小的装饰性质的背景图片。 插入图片不能往上放。我们可以横向摆放也可以纵向摆放，但是每个图片之间留有适当的空隙在我们精灵图的最低端，留一片空隙，方便我们以后添加其他精灵图。</code></pre><p id="566cc9a073e3a71dc22f0d5b98ace9ad" class="ne-p"><span class="ne-text">结束语：   小公司，背景图片很少的情况，没有必要使用精灵技术，维护成本太高。 如果是背景图片比较多，可以建议使用精灵技术。</span></p><h2 id="RUhPR"><span class="ne-text">6. 滑动门</span></h2><p id="2c314c6dbf430872f0da77c4a4ef75be" class="ne-p"><span class="ne-text">先来体会下现实中的滑动门,或者你可以叫做推拉门：</span></p><p id="0e7a714303ce4d21131797d518ffee27" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/gif/1484158/1611549561776-6f3ff095-d927-46a8-9ae9-ed2ced5b6d8b.gif" width="640" id="CIobb" class="ne-image"></p><h3 id="qElKk"><span class="ne-text">滑动门出现的背景</span></h3><p id="4293734f0e2734690f181122278c7936" class="ne-p"><span class="ne-text">制作网页时，为了美观，常常需要为网页元素设置特殊形状的背景，比如微信导航栏，有凸起和凹下去的感觉，最大的问题是里面的字数不一样多，咋办？</span></p><p id="cfc5f3eee9f856cc813fe928444443aa" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/jpg/1484158/1611549561985-32e0b028-36b8-40bb-85c4-1a570ae4cd42.jpg" width="1214" id="SyeWA" class="ne-image"></p><p id="ed0dd75a68fc1987eb791cf7c735adc4" class="ne-p"><span class="ne-text">为了使各种特殊形状的背景能够自适应元素中文本内容的多少，出现了CSS滑动门技术。它从新的角度构建页面，使各种特殊形状的背景能够自由拉伸滑动，以适应元素内部的文本内容，可用性更强。 最常见于各种导航栏的滑动门。</span></p><p id="16007d61fe0c31557aec37720c20a575" class="ne-p"><a href="http://weixin.qq.com/" data-href="http://weixin.qq.com/" target="_blank" class="ne-link"><span class="ne-text">http://weixin.qq.com/</span></a></p><h3 id="WO5hO"><span class="ne-text">核心技术</span></h3><p id="199b21db0aaf00ca8758cbc31b7eb354" class="ne-p"><span class="ne-text">核心技术就是利用CSS精灵（主要是背景位置）和 盒子padding撑开宽度, 以便能适应不同字数的导航栏。</span></p><p id="930f1a0b083774b981c2c73f55631e4e" class="ne-p"><span class="ne-text">一般的经典布局都是这样的：</span></p><pre><code>&lt;li&gt;  &lt;a href=&quot;#&quot;&gt;    &lt;span&gt;导航栏内容&lt;/span&gt;  &lt;/a&gt;&lt;/li&gt;</code></pre><p id="e172a8e56b431f16917183af1983bc5b" class="ne-p"><span class="ne-text">css样式</span></p><pre><code>* &#123;      padding:0;      margin:0;    &#125;    body&#123;      background: url(images/wx.jpg) repeat-x;    &#125;    .father &#123;      padding-top:20px;    &#125;    li &#123;      padding-left: 16px;      height: 33px;      float: left;      line-height: 33px;      margin:0  10px;      background: url(./images/to.png) no-repeat left ;    &#125;    a &#123;      padding-right: 16px;      height: 33px;      display: inline-block;      color:#fff;      background: url(./images/to.png) no-repeat right ;      text-decoration: none;    &#125;    li:hover,     li:hover a &#123;      background-image:url(./images/ao.png);    &#125;</code></pre><p id="92379cdcd843b9a7329469bbf7eb6a9f" class="ne-p"><span class="ne-text">总结：</span></p><ol class="ne-ol"><li id="46335e4a4df4ee070bfb9fa1fe3b89cb"><span class="ne-text">a 设置 背景左侧，padding撑开合适宽度。</span></li><li id="cef9a0370335dc671c2e0ea348585d12"><span class="ne-text">span 设置背景右侧， padding撑开合适宽度 剩下由文字继续撑开宽度。</span></li><li id="5370dd12fcaf70a7c74da3650c7d335b"><span class="ne-text">之所以a包含span就是因为 整个导航都是可以点击的。</span></li></ol><h2 id="KyZY8"><span class="ne-text">7. 拓展@</span></h2><h3 id="94JvV"><span class="ne-text">7.1 margin负值之美</span></h3><div class="ne-quote"><p id="43b50e61a1f4bc86974a2b39d82047d5" class="ne-p"><span class="ne-text">1). 负边距+定位：水平垂直居中</span></p></div><p id="164407d24b557e6c675cea52e0f9bced" class="ne-p"><span class="ne-text">咱们前面讲过， 一个绝对定位的盒子， 利用  父级盒子的 50%，  然后 往左(上) 走 自己宽度的一半 ，可以实现盒子水平垂直居中。</span></p><div class="ne-quote"><p id="00a7332bb88c23a092f0f0308adeb8a9" class="ne-p"><span class="ne-text">2). 压住盒子相邻边框</span></p></div><p id="616eac64873c60539a45905d639c4b5d" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611549562073-8c7f6392-a50a-4a49-af0b-0a820c58e669.png" width="1220" id="dd05p" class="ne-image"></p><h3 id="Da96z"><span class="ne-text">7.2 CSS三角形之美</span></h3><pre><code>div &#123;     width: 0;     height: 0;    line-height:0；    font-size: 0;    border-top: 10px solid red;    border-right: 10px solid green;    border-bottom: 10px solid blue;    border-left: 10px solid #000;  &#125;</code></pre><p id="cdcaec11d3f52447e17db641505fff0d" class="ne-p"><span class="ne-text">一张图， 你就知道 css 三角是怎么来的了, 做法如下：</span></p><p id="1af97ea3ede676c06e3e58a874440fcc" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611549562255-39a63568-e0a9-470d-8bd5-56b4d1e18205.png" width="263" id="KZE6A" class="ne-image"></p><ol class="ne-ol"><li id="9d117fe627c4182f7b8cdc567ab559cf"><span class="ne-text">我们用css 边框可以模拟三角效果</span></li><li id="cdfc53d48b3452b43b8504bf85b47615"><span class="ne-text">宽度高度为0</span></li><li id="106155d7d20aee9719e1e3b04820bd2d"><span class="ne-text">我们4个边框都要写， 只保留需要的边框颜色，其余的不能省略，都改为 transparent 透明就好了</span></li><li id="f6554ec01bb48b65f8068af36d6d8631"><span class="ne-text">为了照顾兼容性 低版本的浏览器，加上 font-size: 0;  line-height: 0;</span></li></ol></div>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
          <category> HTML+CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> todo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搭建“文本三巨头”环境</title>
      <link href="/blog/yhxiep/"/>
      <url>/blog/yhxiep/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h2 id="MX2J5"><span class="ne-text">Vim</span></h2><h3 id="UeIzT"><span class="ne-text">Vim下载安装</span></h3><ul class="ne-ul"><li id="u37b51cda"><span class="ne-text"></span><a href="https://www.vim.org/download.php" data-href="https://www.vim.org/download.php" target="_blank" class="ne-link"><span class="ne-text">下载地址</span></a></li></ul><p id="fd7db94422d09137b510c85a8f048e85" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1608357192619-ac3d093e-c4e4-49fa-9a3b-8ead607b2160.png" width="959.5" id="RDX6X" class="ne-image"></p><p id="2449b5f125868070febf7be6f42fcab4" class="ne-p"><span class="ne-text">下载完之后next安装即可</span></p><h3 id="LeFv1"><span class="ne-text">Vim环境变量配置</span></h3><p id="2d8a275cd1370075d6c93754c5bfe8a4" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1608357482468-e6a53bc3-991d-4eda-aa2e-c5643b9617b0.png" width="301" id="PYvNp" class="ne-image"></p><p id="098d2d74bb7ca4f594cdacaa29a6ded2" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1608357463679-c00baef1-4e21-4405-8e79-f65afabe0370.png" width="488" id="RNNXe" class="ne-image"></p><h3 id="YO0FX"><span class="ne-text">测试</span></h3><p id="5f1be856ce1788c351c271daabb249dc" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1608357601712-bc8f6f5b-6038-4358-8699-a7201ce8223e.png" width="734" id="yrzYQ" class="ne-image"></p><p id="67778d17505fe26067423a65e21cc36a" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1608357572830-fd4043b2-f02a-4c32-b9e7-677c4918ec19.png" width="721" id="gVyaq" class="ne-image"></p><p id="8b603cfeea4571802722e72d2bb3ba71" class="ne-p"><br></p><h2 id="6BZUj"><span class="ne-text">zsh</span></h2><h3 id="5elC9"><span class="ne-text">安装Linux子系统</span></h3><p id="1287f4331cd3cf96803fad048a9fdaeb" class="ne-p"><span class="ne-text">查看之前写的文章：</span><a href="https://www.wztlink1013.com/blog/xnh83z/" data-href="https://www.wztlink1013.com/blog/xnh83z/" target="_blank" class="ne-link"><span class="ne-text">搭建Windows子系统Linux - 尼采般地抒情</span></a></p><h3 id="GSwqQ"><span class="ne-text">安装ConEmu</span></h3><p id="2269ccbd077f3fb5114a7175f53939eb" class="ne-p"><a href="https://www.fosshub.com/ConEmu.html" data-href="https://www.fosshub.com/ConEmu.html" target="_blank" class="ne-link"><span class="ne-text">https://www.fosshub.com/ConEmu.html</span></a></p><p id="bfab0f338cb60686ecb2f0ae6f3878f9" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1608358847174-3a3b7ba1-45e8-4951-a943-debd2a09de43.png" width="952" id="JLc7g" class="ne-image"></p><p id="2ebcb0025b41d5882e1342b644cbb602" class="ne-p"><span class="ne-text">设置如下：</span></p><p id="824e1177a6f2cef5e494d9af45775d2b" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1608358926353-c172728f-978e-47f7-9ec5-34472219ccdb.png" width="571.5" id="jMLUr" class="ne-image"></p><p id="32d37a369121314e27dda5bbebc813c3" class="ne-p"><span class="ne-text">确定后会进入以下界面</span></p><p id="0152db9904699107b9ad4429273bc13c" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1608358964494-c12c30a4-4b04-4463-b3d6-3c5fc21b607f.png" width="485" id="aXzWd" class="ne-image"></p><h3 id="x8iJh"><span class="ne-text">安装并配置zsh</span></h3><p id="aeb676b2c219ea91b35677d9de82d04c" class="ne-p"><span class="ne-text">进入页面 </span><code class="ne-code"><span class="ne-text">sudo apt-get install -y zsh</span></code><span class="ne-text"> ，输入密码：</span></p><p id="e43bdbe7ea45caf308a48dc8a305c670" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1608359167583-80d5f5fd-77e6-417d-ac0c-279dbfb55776.png" width="480" id="tPJV7" class="ne-image"></p><p id="2e682f65e859273cd4350c083d006f4e" class="ne-p"><span class="ne-text">安装成功界面如下：</span></p><p id="7edf269ca8eba2bd4c536a050301f018" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1608360612991-863a5a2e-77a2-4bd7-b1b9-4ef6a79dcb86.png" width="954" id="CG6aU" class="ne-image"></p><h3 id="3aliR"><span class="ne-text">安装oh-my-zsh</span></h3><p id="e102b11293393af801ac79b473c4b0c4" class="ne-p"><span class="ne-text">sh -c &quot;$(curl -fsSL </span><a href="https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)%22" data-href="https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)%22" target="_blank" class="ne-link"><span class="ne-text">https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot;</span></a></p><p id="bbbdc71fc02899370ca618bc6bbd7e92" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1608360763102-d6886d61-c954-4c15-adfc-ca42c0daf337.png" width="954" id="rLLx0" class="ne-image"></p><p id="d41909239673e72a3b22acf5d4e178b4" class="ne-p"><span class="ne-text">上述文件夹在这里： </span><code class="ne-code"><span class="ne-text">C:\Users\wztli\AppData\Local\Packages\CanonicalGroupLimited.UbuntuonWindows_79rhkp1fndgsc\LocalState\rootfs\home\wztlink1013</span></code></p><h2 id="R79BF"><span class="ne-text">tmux</span></h2><h3 id="G5qPr"><span class="ne-text">安装运行</span></h3><p id="c06eec7d1d903a65c9492f40534fda91" class="ne-p"><span class="ne-text">Ubuntu系统命令行界面输入： </span><code class="ne-code"><span class="ne-text">sudo apt install tmux</span></code></p><p id="cde2dbaf7bb9d5d1a7e0454459c73752" class="ne-p"><br></p><p id="618b9ad9be8a1fd257d9b1a1215c079a" class="ne-p"><span class="ne-text">在Ubuntu系统输入并执行&quot;tmux&quot;命令，会进入tmux窗口</span></p><h2 id="kMBv5"><span class="ne-text">参考</span></h2><ul class="ne-ul"><li id="6cb9d18d408a2264bfbcc4b6dcc20f16"><a href="https://www.jianshu.com/p/5f7b83ca3952" data-href="https://www.jianshu.com/p/5f7b83ca3952" target="_blank" class="ne-link"><span class="ne-text">https://www.jianshu.com/p/5f7b83ca3952</span></a></li><li id="e7ee5cc06385fadf6576551109990cf8"><a href="https://post.smzdm.com/p/a5k6e033/" data-href="https://post.smzdm.com/p/a5k6e033/" target="_blank" class="ne-link"><span class="ne-text">https://post.smzdm.com/p/a5k6e033/</span></a></li><li id="d4c1f36e4129f6867e6453ee35ef630d"><a href="https://blog.csdn.net/qq_2300688967/article/details/81774297" data-href="https://blog.csdn.net/qq_2300688967/article/details/81774297" target="_blank" class="ne-link"><span class="ne-text">https://blog.csdn.net/qq_2300688967/article/details/81774297</span></a></li></ul></div>]]></content>
      
      
      <categories>
          
          <category> 计算机素养 </category>
          
          <category> 环境搭建 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>150.逆波兰表达式求值🔖栈</title>
      <link href="/blog/ewoap5/"/>
      <url>/blog/ewoap5/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h2 id="vi7Gj"><span class="ne-text">问题分析</span></h2><p id="eb6bae56e307e499aa83c1b2931e1693" class="ne-p"><span class="ne-text">对所给字符串进行遍历，遇到数字字符就压入栈stack内，遇到+-*/符号就pop处栈的两个元素，进行该字符运算处理</span></p><p id="u854f3b3d" class="ne-p"><span class="ne-text"></span></p><h2 id="gnNEL"><span class="ne-text">代码实现</span></h2><pre><code>package com.wztlink1013.problems.leetcode.editor.cn;<p>// P150.逆波兰表达式求值<br>// P150.evaluate-reverse-polish-notation<br>//根据 逆波兰表示法，求表达式的值。<br>//<br>// 有效的运算符包括 +, -, <em>, / 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。<br>//<br>//<br>//<br>// 说明：<br>//<br>//<br>// 整数除法只保留整数部分。<br>// 给定逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。<br>//<br>//<br>//<br>//<br>// 示例 1：<br>//<br>// 输入: [&quot;2&quot;, &quot;1&quot;, &quot;+&quot;, &quot;3&quot;, &quot;</em>&quot;]<br>//输出: 9<br>//解释: 该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) = 9<br>//<br>//<br>// 示例 2：<br>//<br>// 输入: [&quot;4&quot;, &quot;13&quot;, &quot;5&quot;, &quot;/&quot;, &quot;+&quot;]<br>//输出: 6<br>//解释: 该算式转化为常见的中缀算术表达式为：(4 + (13 / 5)) = 6<br>//<br>//<br>// 示例 3：<br>//<br>// 输入: [&quot;10&quot;, &quot;6&quot;, &quot;9&quot;, &quot;3&quot;, &quot;+&quot;, &quot;-11&quot;, &quot;<em>&quot;, &quot;/&quot;, &quot;</em>&quot;, &quot;17&quot;, &quot;+&quot;, &quot;5&quot;, &quot;+&quot;]<br>//输出: 22<br>//解释:<br>//该算式转化为常见的中缀算术表达式为：<br>//  ((10 * (6 / ((9 + 3) * -11))) + 17) + 5<br>//= ((10 * (6 / (12 * -11))) + 17) + 5<br>//= ((10 * (6 / -132)) + 17) + 5<br>//= ((10 * 0) + 17) + 5<br>//= (0 + 17) + 5<br>//= 17 + 5<br>//= 22<br>//<br>//<br>//<br>// 逆波兰表达式：<br>//<br>// 逆波兰表达式是一种后缀表达式，所谓后缀就是指算符写在后面。<br>//<br>//<br>// 平常使用的算式则是一种中缀表达式，如 ( 1 + 2 ) * ( 3 + 4 ) 。<br>// 该算式的逆波兰表达式写法为 ( ( 1 2 + ) ( 3 4 + ) * ) 。<br>//<br>//<br>// 逆波兰表达式主要有以下两个优点：<br>//<br>//<br>// 去掉括号后表达式无歧义，上式即便写成 1 2 + 3 4 + * 也可以依据次序计算出正确结果。<br>// 适合用栈操作运算：遇到数字则入栈；遇到算符则取出栈顶两个数字进行计算，并将结果压入栈中。<br>//<br>// Related Topics 栈<br>// 👍 213 👎 0</p><p>import java.util.Stack;</p><p>public class P150EvaluateReversePolishNotation&#123;<br>    public static void main(String[] args) &#123;<br>        Solution solution = new P150EvaluateReversePolishNotation().new Solution();<br>        String[] tokens_1 = &#123;&quot;10&quot;, &quot;6&quot;, &quot;9&quot;, &quot;3&quot;, &quot;+&quot;, &quot;-11&quot;, &quot;<em>&quot;, &quot;/&quot;, &quot;</em>&quot;, &quot;17&quot;, &quot;+&quot;, &quot;5&quot;, &quot;+&quot;&#125;;<br>        int temp = solution.evalRPN(tokens_1);<br>        System.out.println(temp);</p><pre><code>&#125;</code></pre><p>//leetcode submit region begin(Prohibit modification and deletion)<br>class Solution {<br>    public int evalRPN(String[] tokens) {<br>        Stack&lt;String&gt; stack = new Stack&lt;&gt;();</p><pre><code>    String temp = &amp;quot;0&amp;quot;;    stack.push(temp);    for (String token : tokens) &#123;        int sum = 0;        if (token.equals(&amp;quot;+&amp;quot;)) &#123;            sum += Integer.parseInt(stack.pop()) + Integer.parseInt(stack.pop());            String str = String.valueOf(sum);            stack.push(str);        &#125; else if (token.equals(&amp;quot;-&amp;quot;)) &#123;            int i = Integer.parseInt(stack.pop());            int j = Integer.parseInt(stack.pop());            sum += j-i;            String str = String.valueOf(sum);            stack.push(str);        &#125; else if (token.equals(&amp;quot;*&amp;quot;)) &#123;            sum += Integer.parseInt(stack.pop()) * Integer.parseInt(stack.pop());            String str = String.valueOf(sum);            stack.push(str);        &#125; else if (token.equals(&amp;quot;/&amp;quot;)) &#123;            int i = Integer.parseInt(stack.pop());            int j = Integer.parseInt(stack.pop());            sum += j / i;            String str = String.valueOf(sum);            stack.push(str);        &#125; else &#123;            stack.push(token);        &#125;    &#125;    int result = Integer.parseInt(stack.pop());    return result;&#125;</code></pre><p>}<br>//leetcode submit region end(Prohibit modification and deletion)</p><p>}<br></code></pre></p></div>]]></content>
      
      
      <categories>
          
          <category> 计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 📶线结构：字符串-数组-栈-队列 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Hexo报错at formatNunjucksError</title>
      <link href="/blog/gw1d4z/"/>
      <url>/blog/gw1d4z/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h2 id="ZHzbx"><span class="ne-text">报错信息</span></h2><p id="5938fb2fe1d4c56c4604990ca6c24af9" class="ne-p"><span class="ne-text">GitHub Actions 流程中 hexo g 出现错误，具体错误在“Vue笔记”中那篇文章中，有个地方用到了大括号嵌套的情况。</span></p><p id="u1514b961" class="ne-p"><span class="ne-text"></span></p><pre><code>    =====             Context Dump Ends            =====    at formatNunjucksError (/home/runner/work/website/website/node_modules/hexo/lib/extend/tag.js:102:13)    at Promise.fromCallback.catch.err (/home/runner/work/website/website/node_modules/hexo/lib/extend/tag.js:124:34)    at tryCatcher (/home/runner/work/website/website/node_modules/bluebird/js/release/util.js:16:23)    at Promise._settlePromiseFromHandler (/home/runner/work/website/website/node_modules/bluebird/js/release/promise.js:547:31)    at Promise._settlePromise (/home/runner/work/website/website/node_modules/bluebird/js/release/promise.js:604:18)    at Promise._settlePromise0 (/home/runner/work/website/website/node_modules/bluebird/js/release/promise.js:649:10)    at Promise._settlePromises (/home/runner/work/website/website/node_modules/bluebird/js/release/promise.js:725:18)    at _drainQueueStep (/home/runner/work/website/website/node_modules/bluebird/js/release/async.js:93:12)    at _drainQueue (/home/runner/work/website/website/node_modules/bluebird/js/release/async.js:86:9)    at Async._drainQueues (/home/runner/work/website/website/node_modules/bluebird/js/release/async.js:102:5)    at Immediate.Async.drainQueues [as _onImmediate] (/home/runner/work/website/website/node_modules/bluebird/js/release/async.js:15:14)    at runCallback (timers.js:705:18)    at tryOnImmediate (timers.js:676:5)    at processImmediate (timers.js:658:5)Error: Process completed with exit code 2.</code></pre><h2 id="jey7n"><span class="ne-text">问题分析与解决</span></h2><p id="f32587a18e5fbb9076f47fa248dea0ba" class="ne-p"><span class="ne-text">上述代码中第二行其实已经说的很明确 </span><code class="ne-code"><span class="ne-text"> at formatNunjucksError</span></code></p><p id="ca6c3ba87a6e808b7ce9caba49cbcd21" class="ne-p"><span class="ne-text">但是hexo中，渲染过程中用到的是Nunjucks，在</span><span class="ne-text">Nunjucks中双大括号被视为语法，所以报错。</span></p><p id="5c64b985804966a5f0cae8668252b7a6" class="ne-p"><br></p><h2 id="dGlTA"><span class="ne-text">小记</span></h2><p id="4ff02731522488c525e38c80355b3636" class="ne-p"><a href="https://www.wztlink1013.com/blog/pxpix4/" data-href="https://www.wztlink1013.com/blog/pxpix4/" target="_blank" class="ne-link"><span class="ne-text">https://www.wztlink1013.com/blog/pxpix4/</span></a></p><p id="e15627319cbf9b3a8521b96cc8107302" class="ne-p"><br></p><p id="0518438c34866821cedf6125a3d3856d" class="ne-p"><span class="ne-text">其实之前遇到过类似的问题……写的博客还是要经常回顾……</span></p></div>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
          <category> Bug记录 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>GitHub多人协作功能Pull requests</title>
      <link href="/blog/iwvugw/"/>
      <url>/blog/iwvugw/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="u31601118" class="ne-p"><br></p><h2 id="DCg0L"><span class="ne-text">给出一个初始场景</span></h2><p id="c0439f998a7d6e947c75a146c50f3ffd" class="ne-p"><span class="ne-text">小吴和小王同时开发一个项目project，该项目托管到GitHub上，假定该项目托管到小吴的GitHub上，小王要想同时开发这个</span><span class="ne-text">project</span><span class="ne-text">，就必须要fork小吴的这个</span><span class="ne-text">project，最后两个人GitHub仓库是这个样子的：</span></p><p id="eb9de5372fb93217c68d508889e9e4cd" class="ne-p"><span class="ne-text"></span></p><p id="c2f46a89e5d15d8ef53e3f6b2f2d4ab5" class="ne-p"><span class="ne-text">小吴：xiaowu/</span><span class="ne-text">project</span></p><p id="8aa249bbe683024034e0992fb6055a79" class="ne-p"><span class="ne-text">小王：xiaowang/</span><span class="ne-text">project</span></p><p id="8bda843a6ff64345456ade47213f08bf" class="ne-p"><span class="ne-text"></span></p><p id="24ceaa9af6e310aa231a9b483c5769b2" class="ne-p"><span class="ne-text">（需要明确一点，小吴小王各自的</span><span class="ne-text">project</span><span class="ne-text">仓库现在就相当各做各的事情了）</span></p><h2 id="1qeg2"><span class="ne-text">具体工作场景</span></h2><p id="9b038e2df868654b1a890dbd8d750bef" class="ne-p"><span class="ne-text">小王的仓库xiaowang/</span><span class="ne-text">project</span><span class="ne-text">改了代码，想要push合并到小吴的仓库</span><span class="ne-text">xiaowu/</span><span class="ne-text">project</span><span class="ne-text">中，这里分两种情况。</span></p><h3 id="DiWJ5"><span class="ne-text">第一种情况</span></h3><p id="4e893ad2c787d4a3a779a7168168092b" class="ne-p"><strong><span class="ne-text">小王在从fork小吴仓库到现在这段期间，小吴没有对</span></strong><strong><span class="ne-text">xiaowu/</span></strong><strong><span class="ne-text">project做任何改动</span></strong></p><div class="ne-quote"><p id="b9e9e81e49a159a584b0bde3013e3f5d" class="ne-p"><span class="ne-text">处理方法：直接Pull request</span></p><p id="0325da8c1804938cc8da4cbe8fae3cc8" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1606915274704-123b219d-d7fe-4816-88c4-91ba11b5c466.png" width="958.5" id="e0K97" class="ne-image"></p><p id="0abe218755ef480a82419c4db86fc31f" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1606915405152-c1e60a93-99fb-42d5-a7a5-87c564fe53d4.png" width="960" id="Of4D4" class="ne-image"></p><p id="445cb52a29ae02f428d83bfdf1d0cdcb" class="ne-p"><span class="ne-text">可以看到1区域显示Able to merge，表明这个Pull request对于双方是没有矛盾的</span></p></div><h3 id="32QPC"><span class="ne-text">第二种情况</span></h3><p id="ec75d99a8dfa37cfc3805c5048f48b3b" class="ne-p"><strong><span class="ne-text">小王在从fork小吴仓库到现在这段期间，小吴又在</span></strong><strong><span class="ne-text">xiaowu/</span></strong><strong><span class="ne-text">project里面做了改动，就相当于小王fork过后，两个人都对各自的仓库更新了，然后小王想将自己的改动推送到小吴那里</span></strong></p><div class="ne-quote"><p id="0d2cf68d0594a424347363bcc59db400" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1606916524143-c5076532-2497-4923-986f-d442122e6de7.png" width="960" id="YBom8" class="ne-image"></p><p id="03ab732358a386ad99e80c772e5cceeb" class="ne-p"><strong><span class="ne-text">可以发现1处并没有那么顺利，因为产生了冲突，但是2处仍然可以新建一个request请求，先点击2</span></strong></p><p id="c6e5b226b1eefb56ff6a05488526e174" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1606916762342-e5215ae5-cf61-43ac-9051-f73c40de1fb1.png" width="595.5" id="F7o57" class="ne-image"></p><p id="fdf5506797d72d1ab6bb3df9f3f8e95b" class="ne-p"><strong><span class="ne-text">点击之后会这样👇</span></strong></p><p id="c229297191fc31dd9b02969a7f402804" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1606916826669-b406d584-50a7-49d5-9044-166bba4bc75f.png" width="642" id="D3ARz" class="ne-image"></p><p id="d5443136a0d145e87ab8b46faa73fac5" class="ne-p"><span class="ne-text">1处显示矛盾的文件（就是小吴和小王在各自的仓库都进行了更改）</span></p><p id="688d507347aaf61e5509b5ecaba3555d" class="ne-p"><span class="ne-text">我们点击2处</span></p><p id="eccad7ee02b8b3e852fabd0bdeb5418c" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1606916998671-6b369cf8-f6dc-4ad3-ba0b-d2f7006b7804.png" width="960" id="nRTI1" class="ne-image"></p><p id="d467d8ba7db152777274f22d363c75fe" class="ne-p"><span class="ne-text">接下来解决这个问题并且点击Mark as resolved按钮就可以了</span></p><p id="cab9aefe14bc6edf1c5ffb77a5e5fb47" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1606917076365-e79652f9-3c56-4259-87d4-b6e979af277d.png" width="960" id="UNqSw" class="ne-image"></p><p id="74945fa4679aefd2686ac145b8c4e922" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1606917146702-bc316303-78f2-4746-94fa-72e4cda90dd0.png" width="960" id="jhbAg" class="ne-image"></p><p id="3ad2005353acf4f79465f5e62d5f949e" class="ne-p"><span class="ne-text">最后就会出现下面的图，接下来，小吴在他的GitHub上同意接受这个请求就可以了。（或者小王有权限小王自己接受也可以）</span></p><p id="1b6480392b24d94385471138665d6163" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1606917264180-37c25758-4db9-44f8-a3f6-0ca725d6c0fd.png" width="717.5" id="Z5Awy" class="ne-image"></p></div><p id="fa17e72108ac106d6ff944862bb4d411" class="ne-p"><br></p><p id="f10c012a34060aec773c9785b4f20443" class="ne-p"><br></p></div>]]></content>
      
      
      <categories>
          
          <category> 计算机素养 </category>
          
          <category> Git和GitHub </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>224.基本计算器🔖栈</title>
      <link href="/blog/ckr31m/"/>
      <url>/blog/ckr31m/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h2 id="qBwwM"><span class="ne-text">问题思路</span></h2><p id="08d50083874be74117e6e22e45bdce8f" class="ne-p"><span class="ne-text">用栈来作为临时存取非括号的求和数。对字符串进行逐个遍历，然后对遇到的每个字符串进行判断</span></p><ul class="ne-ul"><li id="b5cdec04cd257aa592ef59810a4af372"><span class="ne-text">数字：将其求和到sum当中</span></li><li id="d1177edf6ed8225eddd2b90fba55cbc4"><span class="ne-text">（：将上述sum和符号压入栈内</span></li><li id="196c7a9b829fde933e3b4af76d924a5c"><span class="ne-text">）：将栈内的元素取出与现有sum求和</span></li><li id="1166e7c68cdc0bd4ed851db695c47b66"><span class="ne-text">+：直接走</span></li><li id="4ba40d6ea839a7bfbfd7dc6b53927f06"><span class="ne-text">-：直接走不过给下一个计算数提前加负号</span></li></ul><p id="ueba54000" class="ne-p"><span class="ne-text"></span></p><h2 id="UGPHv"><span class="ne-text">代码实现</span></h2><pre><code>package com.wztlink1013.problems.leetcode.editor.cn;<p>// P224.基本计算器<br>//实现一个基本的计算器来计算一个简单的字符串表达式的值。<br>//<br>// 字符串表达式可以包含左括号 ( ，右括号 )，加号 + ，减号 -，非负整数和空格 。<br>//<br>// 示例 1:<br>//<br>// 输入: &quot;1 + 1&quot;<br>//输出: 2<br>//<br>//<br>// 示例 2:<br>//<br>// 输入: &quot; 2-1 + 2 &quot;<br>//输出: 3<br>//<br>// 示例 3:<br>//<br>// 输入: &quot;(1+(4+5+2)-3)+(6+8)&quot;<br>//输出: 23<br>//<br>// 说明：<br>//<br>//<br>// 你可以假设所给定的表达式都是有效的。<br>// 请不要使用内置的库函数 eval。<br>//<br>// Related Topics 栈 数学<br>// 👍 309 👎 0</p><p>import java.util.Stack;</p><p>public class P224BasicCalculator&#123;<br>    public static void main(String[] args) &#123;<br>        Solution solution = new P224BasicCalculator().new Solution();<br>        int key_1 = solution.calculate(&quot;7896979&quot;);<br>        int key_2 = solution.calculate(&quot;(23-2)-33+1111&quot;);<br>        System.out.println(key_1);<br>        System.out.println(key_2);<br>    &#125;</p><p>//leetcode submit region begin(Prohibit modification and deletion)<br>class Solution &#123;<br>    public int calculate(String s) &#123;<br>        Stack&lt;Integer&gt; stack_1 = new Stack&lt;Integer&gt;();<br>        int sum = 0;<br>        int sign = 1;<br>        int num = 0;</p><pre><code>    for (int i=0;i&amp;lt;s.length();i++) &#123;        char ch = s.charAt(i);        if (Character.isDigit(ch)) &#123;            num = 10 * num + (int) (ch - &#39;0&#39;);        &#125; else if (ch == &#39;+&#39;) &#123;            num = num * sign;            sum = sum + num;            sign = 1;            num = 0;        &#125; else if (ch == &#39;-&#39;) &#123;            num = num * sign;            sum = sum + num;            sign = -1;            num = 0;        &#125; else if (ch == &#39;(&#39;) &#123;            stack_1.push(sum);            stack_1.push(sign);            sum = 0;            num = 0;            sign = 1;        &#125; else if (ch == &#39;)&#39;) &#123;            num = num * sign;            sum = sum + num;            sum = stack_1.pop() * sum;            sum = sum + stack_1.pop();            num = 0;            sign = 1;        &#125;    &#125;    sum = sum + sign * num;    return sum;&#125;&#125;</code></pre><p>//leetcode submit region end(Prohibit modification and deletion)</p><p>}<br></code></pre></p></div>]]></content>
      
      
      <categories>
          
          <category> 计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 📶线结构：字符串-数组-栈-队列 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>sdnu-dboj-Student-Movie</title>
      <link href="/blog/zhdy1x/"/>
      <url>/blog/zhdy1x/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><div class="ne-quote"><p id="766f80ed9b16d637ca1bb196c489ffe8" class="ne-p"><span class="ne-text">题目入口：</span><a href="http://db.itoi.sd.cn/problem/set" data-href="http://db.itoi.sd.cn/problem/set" target="_blank" class="ne-link"><span class="ne-text">http://db.itoi.sd.cn/problem/set</span></a></p></div><h2 id="oszRU"><span class="ne-text">成绩管理相关题目</span></h2><h3 id="6sRD6"><span class="ne-text">Student表</span></h3><p id="5ccc5406745fb4adea6deee908cf8c88" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1600849205116-d4263820-8bbb-4d01-b97b-a0363f4498e7.png" width="361" id="i6Mtq" class="ne-image"></p><h3 id="vpVPK"><span class="ne-text">Course表</span></h3><p id="5b3d9be708bed51611532df4586b3c55" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1600849217512-41be815b-8bc4-4b6a-82c2-cbb4d335c9b9.png" width="316" id="TH7Ie" class="ne-image"></p><h3 id="EbonT"><span class="ne-text">SC表</span></h3><p id="fb17afe17cd270a297f15766c0b9a636" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1600849229639-8d5cd91f-d87e-49e9-a1cd-9c563b64723f.png" width="246" id="FFiKd" class="ne-image"></p><p id="717d0a9d202baca2ab2288e4f84ab294" class="ne-p"><br></p><h3 id="Gs1JS"><span class="ne-text">初始化SQL语句</span></h3><pre><code>SET NAMES utf8mb4;SET FOREIGN_KEY_CHECKS = 0;<p>/<em>学生表</em>/<br>CREATE TABLE Student<br>(<br>    Sno  INT(9) PRIMARY KEY,<br>    Sname VARCHAR(10),<br>    Ssex  CHAR(2),<br>    Sage  TINYINT(3),<br>    Sdept VARCHAR(20)<br>);<br>INSERT INTO Student<br>VALUES (201215121, ‘李勇’, ‘男’, 20, ‘CS’),<br>     (201215122, ‘刘晨’, ‘女’, 19, ‘CS’),<br>    (201215123, ‘王敏’, ‘女’, 18, ‘MA’),<br>    (201215125, ‘张立’, ‘男’, 19, ‘IS’),<br>    (201215133, ‘张三’, ‘男’, 21, ‘TE’),<br>     (201215137, ‘赵四’, ‘男’, 23, ‘TE’),<br>     (201215139, ‘田二’, ‘女’, 24, ‘CS’),<br>     (201215140, ‘李四’, ‘男’, 21, ‘CS’),<br>     (201215141, ‘郑五’, ‘女’, 22, ‘IS’);</p><p>/<em>课程表</em>/<br>CREATE TABLE Course<br>(<br>    Cno      INT(4) PRIMARY KEY,<br>    Cname     VARCHAR(40),<br>    Cpno      INT(4),<br>    Ccredit     TINYINT(3),<br>    FOREIGN     KEY (Cpno) REFERENCES Course (Cno)<br>);<br>INSERT INTO Course<br>VALUES    (1, ‘数据库’, 5, 4),<br>        (2, ‘数学’, NULL, 2),<br>    (3, ‘信息系统’, 1, 4),<br>     (4, ‘操作系统’, 6, 3),<br>     (5, ‘数据结构’, 7, 4),<br>     (6, ‘数据处理’, NULL, 2),<br>     (7, ‘PASCAL语言’, 6, 4);</p><p>/<em>选课表</em>/<br>CREATE TABLE SC<br>(<br>    Sno  INT(9),<br>    Cno  INT(4),<br>    Grade SMALLINT(3),<br>    PRIMARY KEY (Sno, Cno),<br>/* 主码由两个属性构成，必须作为表级完整性进行定义*/<br>    FOREIGN KEY (Sno) REFERENCES Student (Sno),<br>/* 表级完整性约束条件，Sno是外码，被参照表是Student <em>/<br>    FOREIGN KEY (Cno) REFERENCES Course (Cno)<br>/</em> 表级完整性约束条件， Cno是外码，被参照表是Course*/<br>);<br>INSERT INTO SC<br>VALUES (201215121, 1, 92),<br>            (201215121, 2, 85),<br>            (201215121, 3, 88),<br>            (201215122, 2, 90),<br>      (201215122, 3, 80),<br>            (201215122, 6, 59),<br>         (201215123, 1, 84),<br>         (201215125, 1, 60),<br>         (201215125, 3, 90),<br>         (201215133, 4, 87),<br>         (201215137, 2, 79),<br>         (201215139, 2, 80),<br>         (201215140, 2, 81);</p><p>SET FOREIGN_KEY_CHECKS = 1;<br></code></pre></p><h3 id="HrV7x"><span class="ne-text">问题代码</span></h3><pre><code>0select Sno, Sname        from Student1select Sname, Sno, Sdept        from Student2select Sname, Sno, Sdept        from Student3select distinct Sno        from SC4select distinct Sname        from Student        where Sdept='CS'5select Sname, Sage    from Student    where Sage&lt;206select Sno    from SC    where Grade&lt;607select Sname, Sdept, Sage    from Student    where Sage&gt;=20 and Sage&lt;=238select Sname, Sdept, Sage    from Student    where Sage&lt;20 or Sage&gt;239select Sname, Ssex    from Student    where Sdept='CS' or Sdept='MA' or Sdept='IS'10select Sname, Ssex    from Student    where Sdept not in ('CS', 'MA', 'IS')11select Sname, Sno, Ssex    from Student    where Sname like '刘_'12select Sname, Sno    from Student    where Sname like '_立'13select Sname, Sno, Ssex    from Student    where Sname not like '刘_'14select Sno, Cno    from SC    where Grade is not null15select Sname    from Student    where Sdept='CS' and Sage&lt;2016select Sno, Grade    from SC    where Cno='3'    order by Grade desc17select *    from Student    order by Sdept asc, Sage desc18select count(Sno) as 'COUNT'    from Student19select count(Sno) as COUNT        from (        select Sno                from SC                group by sno) as test20select avg(Grade) as AVG    from SC    where Cno='1'21select max(Grade) as MAX    from SC    where Cno='1'22select SUM(Ccredit) as SUM        from Course, SC        where Course.Cno=SC.Cno         and Sno='201215121'23select Cno, count(Grade) as COUNT        from SC        group by Cno24select Sno        from(        select Sno, count(Grade) as COUNT                from SC                group by Sno            )as test        where COUNT&gt;225select Sno, AVG(Grade) as AVG        from SC        group by Sno        having AVG(Grade)&gt;=8826select Student.Sno, Sname, Ssex, Sage, Sdept, Cno, Grade    from Student inner join SC    on Student.Sno=SC.Sno27SELECT x.Cno, y.Cpno        FROM Course x, Course y        WHERE x.Cpno = y.Cno28select Student.Sno, Student.Sname        from Student, SC        where Student.Sno=SC.Sno                and SC.Cno='2'                and SC.Grade&gt;8029select test.Sno, test.Sname, Course.Cname, test.Grade    from Course join        (select SC.Sno, SC.Cno, Student.Sname, SC.Grade            from Student join SC                 on Student.Sno=SC.Sno)as test        on Course.Cno=test.Cno</code></pre><h2 id="6Emyc"><span class="ne-text">Movie相关题目</span></h2><pre><code>30select title        from movie        where director='Steven Spielberg'31select year        from movie        where mID in (                select mID                from rating                where stars='4' or stars='5'                )        order by year asc32select title        from movie        where mID not in (                select mID                    from rating)33select name        from reviewer        where rID in (                select rID                        from rating                        where ratingDate is null)34select reviewer.name, test.title, test.stars, test.ratingDatefrom reviewer join (    select movie.title, rating.rID, rating.stars, rating.ratingDate    from movie join rating    on movie.mID=rating.mID    ) as teston reviewer.rID=test.rIDorder by reviewer.name, test.title, test.stars35<p>37<br>select movie.title, rating_2.stars_avg as stars<br>from movie join (<br>    select mID, AVG(stars) as stars_avg<br>    from rating<br>    group by mID) as rating_2<br>on movie.mID=rating_2.mID<br>order by stars desc, title<br>38<br>select name<br>from reviewer<br>where rID in(<br>    select rID<br>    from rating<br>    group by rID<br>    having COUNT(rID)&gt;=3)<br>39<br>select name<br>from reviewer<br>where rID in (<br>select distinct rID<br>from rating<br>where mID in (<br>    select mID<br>    from movie<br>    where title=’Gone with the Wind’))<br> 40<br> select temp.name as name, movie.title as title, temp.stars as stars<br>    from movie join (<br>        select rating.stars, reviewer.name, rating.mID<br>        from rating join reviewer<br>        on rating.rID=reviewer.rID) as temp<br>    on movie.mID=temp.mID<br>    where movie.director=temp.name</p><p></code></pre></p></div>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
          <category> DataBase </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>509. 斐波那契数🔖递归</title>
      <link href="/blog/pmd7dz/"/>
      <url>/blog/pmd7dz/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><ul class="ne-ul"><li id="u81e6a0fb"><a href="https://leetcode-cn.com/problems/fibonacci-number/" data-href="https://leetcode-cn.com/problems/fibonacci-number/" target="_blank" class="ne-link"><span class="ne-text">https://leetcode-cn.com/problems/fibonacci-number/</span></a></li></ul><p id="u42c17be2" class="ne-p"><span class="ne-text"></span></p><h3 id="vDIhF"><span class="ne-text">ts实现</span></h3><pre><code>function fib(n: number): number &#123;  if (n &lt;= 1) return n  return fib(n - 1) + fib(n - 2)&#125;</code></pre><h3 id="WHTdQ"><span class="ne-text">java实现</span></h3><pre><code>class Solution &#123;    // TODO: for循环实现    public int fib(int N) &#123;        if (N &lt;= 1) return N;        int first = 0;        int second = 1;        for (int i = 0; i &lt; N - 1; i++) &#123;            int sum = first + second;            first = second;            second = sum;        &#125;        return second;    &#125;//    // TODO: 递归实现O(2^n)//    public int fib1(int n) &#123;//        if (n &lt;= 1) return n;//        return fib1(n - 1) + fib1(n - 2);//    &#125;//    // TODO: 首尾实现//    public int fib3(int n) &#123;//        if (n &lt;= 1) return n;//        int first = 0;//        int second = 1;//        while (n-- &gt; 1) &#123;//            second += first;//            first = second - first;//        &#125;//        return second;//    &#125;&#125;</code></pre><h3 id="Qk196"><span class="ne-text">C++实现</span></h3><pre><code>// 递归：O(2^n)public static int fib1(int n) &#123;    if (n &lt;= 1) return n;    return fib1(n - 1) + fib1(n - 2);&#125;<p>// for循环：O(n)<br>public static int fib2(int n) &#123;<br>    if (n &lt;= 1) return n;<br>    int first = 0;<br>    int second = 1;<br>    for (int i = 0; i &lt; n - 1; i++) &#123;<br>        int sum = first + second;<br>        first = second;<br>        second = sum;<br>    &#125;<br>    return second;<br>&#125;<br>// 首尾法<br>public static int fib3(int n) &#123;<br>    if (n &lt;= 1) return n;</p><pre><code>int first = 0;int second = 1;while (n-- &amp;gt; 1) &#123;    second += first;    first = second - first;&#125;return second;</code></pre><p>}<br>// 特征方程解法：O（1）<br>public static int fib4(int n) {<br>    double c = Math.sqrt(5);<br>    return (int) (Math.pow((1+c) / 2, n) - Math.pow((1-c) / 2, c));<br>}<br></code></pre></p></div>]]></content>
      
      
      <categories>
          
          <category> 计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 🌌递归算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>486. 预测赢家🔖数组</title>
      <link href="/blog/srvbwz/"/>
      <url>/blog/srvbwz/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><ul class="ne-ul"><li id="u65f8b50c"><a href="https://leetcode-cn.com/problems/predict-the-winner/" data-href="https://leetcode-cn.com/problems/predict-the-winner/" target="_blank" class="ne-link"><span class="ne-text">https://leetcode-cn.com/problems/predict-the-winner/</span></a></li></ul><p id="ueb9322bf" class="ne-p"><span class="ne-text"></span></p><p id="ud43caea7" class="ne-p"><span class="ne-text"></span></p><h3 id="eJk9K"><span class="ne-text">思路</span></h3><p id="u94ddd270" class="ne-p"><span class="ne-text">贪心策略不行，如果玩家每次都选相对自己当下可选择的最大值，这样的贪心策略有错误，比如这个例子：</span></p><div class="ne-quote"><p id="uc8fe1ddc" class="ne-p"><span class="ne-text">输入：nums = [1,5,233,7]</span></p><p id="u21848967" class="ne-p"><span class="ne-text">输出：true</span></p><p id="u2b002e03" class="ne-p"><span class="ne-text">解释：玩家 1 一开始选择 1 。然后玩家 2 必须从 5 和 7 中进行选择。无论玩家 2 选择了哪个，玩家 1 都可以选择 233 。</span></p><p id="u77e974fa" class="ne-p"><span class="ne-text">最终，玩家 1（234 分）比玩家 2（12 分）获得更多的分数，所以返回 true，表示玩家 1 可以成为赢家。</span></p></div><p id="u6b4f21c1" class="ne-p"><br></p><p id="u923b8044" class="ne-p"><span class="ne-text"></span></p><h3 id="275rS"><span class="ne-text">java实现</span></h3><pre><code>class Solution &#123;    public boolean PredictTheWinner(int[] nums) &#123;        return total(nums, 0, nums.length - 1, 1) &gt;= 0;    &#125;<pre><code>public int total(int[] nums, int start, int end, int turn) &#123;    if (start == end) &#123;        return nums[start] * turn;    &#125;    int scoreStart = nums[start] * turn + total(nums, start + 1, end, -turn);    int scoreEnd = nums[end] * turn + total(nums, start, end - 1, -turn);    return Math.max(scoreStart * turn, scoreEnd * turn) * turn;</code></pre><p>//        if(turn == 1){<br>//            return Math.max(scoreStart ,scoreEnd );<br>//        }else{<br>//            return Math.min(scoreStart ,scoreEnd );<br>//        }<br>    }<br>}<br></code></pre></p></div>]]></content>
      
      
      <categories>
          
          <category> 计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 📶线结构：字符串-数组-栈-队列 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>876. 链表的中间结点🔖链表</title>
      <link href="/blog/serpsb/"/>
      <url>/blog/serpsb/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="ub5d113e8" class="ne-p"><br></p><h2 id="XRQoL"><span class="ne-text">876. 链表的中间结点</span></h2><ul class="ne-ul"><li id="u1161591c"><a href="https://leetcode-cn.com/problems/middle-of-the-linked-list/" data-href="https://leetcode-cn.com/problems/middle-of-the-linked-list/" target="_blank" class="ne-link"><span class="ne-text">https://leetcode-cn.com/problems/middle-of-the-linked-list/</span></a></li></ul><h3 id="ADYbv"><span class="ne-text">问题描述</span></h3><p id="f851f8caacea66d5f47930ef13cbcc66" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1603195941092-8cd11b96-c174-425e-ab68-a7015110092e.png" width="358.5" id="QJds4" class="ne-image"></p><h3 id="wGOtu"><span class="ne-text">问题分析</span></h3><h3 id="DKSwG"><span class="ne-text">代码实现</span></h3><h4 id="VgC44"><span class="ne-text">js</span></h4><pre><code>/** * Definition for singly-linked list. * function ListNode(val, next) &#123; *     this.val = (val===undefined ? 0 : val) *     this.next = (next===undefined ? null : next) * &#125; *//** * @param &#123;ListNode&#125; head * @return &#123;ListNode&#125; */var middleNode = function(head) &#123;    let count = 0    let temp = head    while(temp) &#123;        count++        temp = temp.next    &#125;    for(let i = 0; i &lt; (count-1)/2; i++) &#123;        head = head.next    &#125;    return head&#125;;</code></pre><h4 id="Oopql"><span class="ne-text">java</span></h4><pre><code>class Solution &#123;    public ListNode middleNode(ListNode head) &#123;        if (head.next == null) return head;        if (head.next.next == null) return head.next;<pre><code>    ListNode slow = head.next;    ListNode fast = head.next.next;    while (fast != null &amp;amp;&amp;amp; fast.next != null) &#123;        slow = slow.next;        fast = fast.next.next;        if (fast == null) return slow;    &#125;    return slow;&#125;</code></pre><p>}<br></code></pre></p><p id="8be157d580e196b77db4a526b3f96cad" class="ne-p"><br></p></div>]]></content>
      
      
      <categories>
          
          <category> 计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 🔗线结构：链表 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>83. 删除排序链表中的重复元素🔖链表</title>
      <link href="/blog/lg67md/"/>
      <url>/blog/lg67md/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><ul class="ne-ul"><li id="u580cba14" data-lake-index-type="0"><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-list/description/" data-href="https://leetcode.cn/problems/remove-duplicates-from-sorted-list/description/" class="ne-link"><span class="ne-text">83. 删除排序链表中的重复元素</span></a></li></ul><p id="da0c5698221c6ef0a11fab5a5ebff8c0" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1603195897467-fdb33dfe-a1c0-4963-b76a-2c978f565801.png" width="363.5" id="jCb28" class="ne-image"></p><h3 id="q6Tve"><span class="ne-text">typescript实现</span></h3><pre><code><code>/** * Definition for singly-linked list. * class ListNode &#123; *     val: number *     next: ListNode | null *     constructor(val?: number, next?: ListNode | null) &#123; *         this.val = (val===undefined ? 0 : val) *         this.next = (next===undefined ? null : next) *     &#125; * &#125; */<p>function deleteDuplicates(head: ListNode | null): ListNode | null &#123;<br>  let start = head<br>  while(start) &#123;<br>    const next = start.next<br>    next &amp;&amp; start.val === next.val &amp;&amp; (start.next = next.next)<br>    start = start.next &amp;&amp; start.val === start.next.val ? start :  start.next<br>  &#125;<br>  return head<br>&#125;;</code><br></code></pre></p><h3 id="mBIcW"><span class="ne-text">java实现</span></h3><pre><code><code>/** * public class ListNode &#123; *     int val; *     ListNode next; *     ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123;  public ListNode deleteDuplicates(ListNode head) &#123;    // TODO: 快慢指针    if (head == null) return head;    ListNode slow = head;    ListNode fast = head.next;    while (fast != null)&#123;      if (slow.val != fast.val) &#123;        slow.next = fast;        slow = fast;      &#125;      fast = fast.next;    &#125;    slow.next = null;    return head;  &#125;&#125;// TODO: 单指针下一步//class Solution &#123;//    public ListNode deleteDuplicates(ListNode head) &#123;//        ListNode cur = head;//        while(cur != null &amp;&amp; cur.next != null) &#123;//            if(cur.val == cur.next.val) &#123;//                cur.next = cur.next.next;//            &#125; else &#123;//                cur = cur.next;//            &#125;//        &#125;//        return head;//    &#125;//&#125;</code></code></pre></div>]]></content>
      
      
      <categories>
          
          <category> 计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 🔗线结构：链表 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>203. 移除链表元素🔖链表</title>
      <link href="/blog/kgpm3x/"/>
      <url>/blog/kgpm3x/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><ul class="ne-ul"><li id="u3a997e51" data-lake-index-type="0"><a href="https://leetcode.cn/problems/remove-linked-list-elements/description/" data-href="https://leetcode.cn/problems/remove-linked-list-elements/description/" target="_blank" class="ne-link"><span class="ne-text">https://leetcode.cn/problems/remove-linked-list-elements/description/</span></a></li></ul><p id="d189c77098b09ec66d33802808106857" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1603195857807-2e8c8296-2d79-4e36-b304-f02c4dee52b3.png" width="364.5" id="GxO4N" class="ne-image"></p><h2 id="bVvK8"><span class="ne-text">递归</span></h2><h3 id="qdcwo"><span class="ne-text">java代码实现</span></h3><pre><code><code>/** * public class ListNode &#123; *     int val; *     ListNode next; *     ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123;  public ListNode removeElements(ListNode head, int val) &#123;    // 将整个链表想象成head+子链表    if (head == null)      return null;    // 先处理子链表    head.next = removeElements(head.next, val);    // 再处理头结点    return head.val == val ? head.next : head;  &#125;&#125;</code></code></pre><h3 id="YSz8F"><span class="ne-text">typescript</span></h3><pre><code><code>/** * Definition for singly-linked list. * class ListNode &#123; *     val: number *     next: ListNode | null *     constructor(val?: number, next?: ListNode | null) &#123; *         this.val = (val===undefined ? 0 : val) *         this.next = (next===undefined ? null : next) *     &#125; * &#125; */<p>function removeElements(head: ListNode | null, val: number): ListNode | null &#123;<br>  if (!head) return null<br>  head.next = removeElements(head.next, val)<br>  return head.val === val ? head.next : head<br>&#125;;</code><br></code></pre></p></div>]]></content>
      
      
      <categories>
          
          <category> 计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 🔗线结构：链表 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>141. 环形链表🔖链表</title>
      <link href="/blog/fgkbg2/"/>
      <url>/blog/fgkbg2/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><ul class="ne-ul"><li id="ud2a26550" data-lake-index-type="0"><a href="https://leetcode.cn/problems/linked-list-cycle/description/" data-href="https://leetcode.cn/problems/linked-list-cycle/description/" target="_blank" class="ne-link"><span class="ne-text">https://leetcode.cn/problems/linked-list-cycle/description/</span></a></li></ul><p id="b845617b08d4e230e723d0fe77c421fb" class="ne-p"><span class="ne-text">给定一个链表，判断链表中是否有环。</span></p><p id="d5d83d8d177c68c1286e4bc279c70a22" class="ne-p"><br></p><p id="a94910678403385c503aa30e56d9059b" class="ne-p"><span class="ne-text">如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。</span></p><p id="308bdb2ec7045fea75ded39be10410f1" class="ne-p"><br></p><p id="40ab708608e25dd3b797e9ecbdf80c94" class="ne-p"><span class="ne-text">如果链表中存在环，则返回 true 。 否则，返回 false 。</span></p><p id="e8ad61232c56c5940b39c44eaebc65f0" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1603195777983-5574f7c4-135c-45c2-aef2-6118e954bf68.png" width="363" id="ydSqs" class="ne-image"></p><h3 id="sl3wo"><span class="ne-text">java实现</span></h3><pre><code><code>/** * public class ListNode &#123; *     int val; *     ListNode next; *     ListNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123;  public boolean hasCycle(ListNode head) &#123;    if (head == null || head.next == null) return false;<pre><code>// TODO: 快慢指针ListNode slow = head;ListNode fast = head.next;while (fast != null &amp;amp;&amp;amp; fast.next != null) &#123;  slow = slow.next;  fast = fast.next.next;  if (slow == fast) return true; //如果能相遇则表示有环&#125;return false; //不能相遇则没有环</code></pre><p>  }<br>}</code><br></code></pre></p><h3 id="OrUC3"><span class="ne-text">typescript实现</span></h3><pre><code><code>/** * Definition for singly-linked list. * class ListNode &#123; *     val: number *     next: ListNode | null *     constructor(val?: number, next?: ListNode | null) &#123; *         this.val = (val===undefined ? 0 : val) *         this.next = (next===undefined ? null : next) *     &#125; * &#125; */<p>function hasCycle(head: ListNode | null): boolean &#123;<br>  const set = new Set()<br>  while(head) &#123;<br>    if (set.has(head)) return true<br>    set.add(head)<br>    head = head.next<br>  &#125;<br>  return false<br>&#125;;</code><br></code></pre></p><p id="u3cb29d93" class="ne-p"><br></p><p id="u799a5202" class="ne-p"><br></p><p id="ua6eb9fed" class="ne-p"><br></p><div data-type="info" class="ne-alert"><p id="u85fbb49e" class="ne-p"><span class="ne-text">ps：也可以利用快慢指针来做，如果慢指针反而追上了，那么说明存在环结构</span></p></div></div>]]></content>
      
      
      <categories>
          
          <category> 计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 🔗线结构：链表 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>.gitignore文件使用总结</title>
      <link href="/blog/hgxgvd/"/>
      <url>/blog/hgxgvd/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><div data-type="info" class="ne-alert"><p id="f47a11490e029063f14371f0d1d2180c" class="ne-p"><span class="ne-text">在Git项目将要提交到github仓库的时候，有些时候我们想要将指定文件不push，例如含有敏感信息类似token的文件，或者.class、.xml、等文件</span></p></div><p id="u8267b8e4" class="ne-p"><span class="ne-text"></span></p><h2 id="hzRD2"><span class="ne-text">忽略指定文件的push的三种方式</span></h2><ul class="ne-ul"><li id="d5936771af41aa4bac653963e539c1fe"><span class="ne-text">方式一：在Git项目中定义.gitignore文件</span></li><li id="4aec825d2a0be427f6b76228fc2c7da6"><span class="ne-text">方式二：在Git项目的设置中指定排除文件</span></li></ul><ul start="3" class="ne-ul"><li id="46dcbf7e45127090c3c6416767235663"><span class="ne-text">方式三：定义Git全局的 .gitignore 文件</span></li></ul><p id="a80d535ea7c8b5af3cc4eadf87f77f32" class="ne-p"><br></p><h2 id="1DegL"><span class="ne-text">语法规则</span></h2><pre><code>#               表示此为注释,将被Git忽略*.a             表示忽略所有 .a 结尾的文件!lib.a          表示但lib.a除外/TODO           表示仅仅忽略项目根目录下的 TODO 文件，不包括 subdir/TODObuild/          表示忽略 build/目录下的所有文件，过滤整个build文件夹；doc/*.txt       表示会忽略doc/notes.txt但不包括 doc/server/arch.txt <p>bin/:           表示忽略当前路径下的bin文件夹，该文件夹下的所有内容都会被忽略，不忽略 bin 文件<br>/bin:           表示忽略根目录下的bin文件<br>/<em>.c:           表示忽略cat.c，不忽略 build/cat.c<br>debug/</em>.obj:    表示忽略debug/io.obj，不忽略 debug/common/io.obj和tools/debug/io.obj<br><strong>/foo:         表示忽略/foo,a/foo,a/b/foo等<br>a/</strong>/b:         表示忽略a/b, a/x/b,a/x/y/b等<br>!/bin/run.sh    表示不忽略bin目录下的run.sh文件<br>*.log:          表示忽略所有 .log 文件<br>config.php:     表示忽略当前路径的 config.php 文件</p><p>/mtk/           表示过滤整个文件夹<br>*.zip           表示过滤所有.zip文件<br>/mtk/do.c       表示过滤某个具体文件</p><p>被过滤掉的文件就不会出现在git仓库中（gitlab或github）了，当然本地库中还有，只是push的时候不会上传。</p><p>需要注意的是，gitignore还可以指定要将哪些文件添加到版本管理中，如下：<br>!*.zip<br>!/mtk/one.txt</p><p>唯一的区别就是规则开头多了一个感叹号，Git会将满足这类规则的文件添加到版本管理中。为什么要有两种规则呢？<br>想象一个场景：假如我们只需要管理/mtk/目录中的one.txt文件，这个目录中的其他文件都不需要管理，那么.gitignore规则应写为：：<br>/mtk/*<br>!/mtk/one.txt</p><p>假设我们只有过滤规则，而没有添加规则，那么我们就需要把/mtk/目录下除了one.txt以外的所有文件都写出来！<br>注意上面的/mtk/*不能写为/mtk/，否则父目录被前面的规则排除掉了，one.txt文件虽然加了!过滤规则，也不会生效！</p><hr><p>还有一些规则如下：<br>fd1/*<br>说明：忽略目录 fd1 下的全部内容；注意，不管是根目录下的 /fd1/ 目录，还是某个子目录 /child/fd1/ 目录，都会被忽略；</p><p>/fd1/*<br>说明：忽略根目录下的 /fd1/ 目录的全部内容；</p><p>/*<br>!.gitignore<br>!/fw/<br>/fw/*<br>!/fw/bin/<br>!/fw/sf/<br>说明：忽略全部内容，但是不忽略 .gitignore 文件、根目录下的 /fw/bin/ 和 /fw/sf/ 目录；注意要先对bin/的父目录使用!规则，使其不被排除。<br></code></pre></p><h2 id="IOM5w"><span class="ne-text">参考文章</span></h2><ul class="ne-ul"><li id="f99cb5013fe93dcc5133f5bb13981dec"><span class="ne-text">文章主要参考：</span><a href="https://www.cnblogs.com/kevingrace/p/5690241.html" data-href="https://www.cnblogs.com/kevingrace/p/5690241.html" target="_blank" class="ne-link"><span class="ne-text">https://www.cnblogs.com/kevingrace/p/5690241.html</span></a></li></ul><p id="4ba6965444eace451678908c1920bb80" class="ne-p"><br></p></div>]]></content>
      
      
      <categories>
          
          <category> 计算机素养 </category>
          
          <category> Git和GitHub </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>《围城》有感</title>
      <link href="/essay/obs0vr/"/>
      <url>/essay/obs0vr/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content-editor-core lake-engine lake-typography-classic" data-lake-element="root" data-selection-undefined="%7B%22path%22%3A%5B%5B16%2C2%2C4%5D%2C%5B16%2C2%2C4%5D%5D%2C%22active%22%3Atrue%7D"><p data-lake-id="b789d1efa36e0abe5cbc7219e396bb93" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">持续记录读这本书的所思所感所悟</p><p data-lake-id="e6d3db6f4a85e94337bad3b88d22725f" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><blockquote class="lake-alert lake-alert-info" style="margin: 0px; padding: 10px; border: 1px solid rgb(171, 210, 218); opacity: 1; border-radius: 3px; color: rgb(38, 38, 38); background-color: rgb(232, 247, 255);"><p data-lake-id="a20d224c568e48b9d67847a2c66a8c01_p_0" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">“城外的人想进来，城内的人想出去”</p></blockquote><p data-lake-id="d2d63d2879ad44fc90806f08c5559399" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><blockquote class="lake-alert lake-alert-success" style="margin: 0px; padding: 10px; border: 1px solid rgb(194, 210, 181); opacity: 1; border-radius: 3px; color: rgb(38, 38, 38); background-color: rgb(237, 249, 232);"><p data-lake-id="475e81f65b57fe0952d55508c9f5e73a" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">这真的是一种人生态度，每次用这句话对一系列问题进行思考的时候，我总喜欢在后面加上一句“活在当下，知足常乐”。</p></blockquote><p data-lake-id="c3431d7780d27281483e678fe0f92a0e" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="896e462daba6f696bec087a38b0461d1" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">还是坐在教室里面的一些遐想…</p><p data-lake-id="68e89188f89f7353eb813d5240c982a7" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="c673b7452f6cb01ec12f8001f9a6f195" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">我很难去想象一个没有选择权利的人会怎么样度过这么一生。这是一个极端，也是一个愿以安于现状的人的一种解脱，</p><p data-lake-id="23fd8e2c160a48ce0e49c66115936356" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="e4032a9a58f27c8b7bb6fe8242c556ba" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="ad977d0940dfcd72ed2bc5ac3344b050" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">还没看完，下次再写吧</p><p data-lake-id="553d4176d279bdd2a9d9181e9021915a" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><div data-card-type="block" data-lake-card="hr"><hr style="background-color: rgb(232, 232, 232); border: 1px solid transparent; margin: 18px 0px;"></div><p data-lake-id="dc6f25a0946b8911145587b844fd196d" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">最大的围城，或许就是知识分子之间的吧，就像是一个圈子，这个圈子吧所谓的知识分子划分出来，而这个圈子里面的人或许又如井底的青蛙一样，甚至也不想出去呢~</p><p data-lake-id="c68c97a423a94c11987939de4db0c582" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="50fe0a7ca3a1acae3a25df290ab1f143" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">滑稽的人呀，一切都貌似在追求一些虚无缥缈般地事物一样，易碎​<code style="font-family: monospace; font-size: inherit; background-color: rgba(0, 0, 0, 0.06); padding: 0px 2px; border: 1px solid rgba(0, 0, 0, 0.08); border-radius: 2px; line-height: inherit; overflow-wrap: break-word; text-indent: 0px;">fragile</code>​ ……</p></div>]]></content>
      
      
      <categories>
          
          <category> 阅读 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>计算方法课小记</title>
      <link href="/essay/sdzqr3/"/>
      <url>/essay/sdzqr3/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="traditional"><p id="d9e332cce85f1f3ef7298d122d15d531" class="ne-p"><span class="ne-text">上计算方法课的那个老师，我严重怀疑他有山东口音，他讲话，一开始简直听不清，可能是我还不习惯山东话的缘故吧~可就是在那样的课堂里面，在那些个周里面，我真的是潜移默化般地学到了许多到许多……</span></p><p id="d73afa25b0d28b77dfdf79ec77f2dc0e" class="ne-p"><br></p><p id="a20d224c568e48b9d67847a2c66a8c01_p_0" class="ne-p"><span class="ne-text">大三上学期选了一门计算方法这门课，当时选的人不太多，四十几个吧，当时都是说这门课太难了，需要用到许多之前学习的高数、线代、概率统计等知识，我选这门课，一是自己比较喜欢数学，想着今后应该不做科研了，与数学不出意外应该是不会再相见了，还想再最后学习一下自己最喜欢的科目，也算是一种情怀吧~哈哈，在一个原因就是，这门课四个学分，四个学分！！</span></p><p id="02e23851902c918bbdaca021544d8345" class="ne-p"><br></p><p id="7e97f63a8153e16390c1108753032f9c" class="ne-p"><span class="ne-text">老师经常和我们说，算法就是解决实际问题，以前我们学的理科当中，结果就是是与不是，但是这门课里面，没有对错，他经常让我们看到一个问题，不要立马去看书上的解答，他说书很局限思维，起初我不以为意，渐渐地，我发现了这位老师说的的确对，我记得有一次课是讲求积分，我一直觉得我高数学的还行，老师让我们尽自己所想，想出所有的解决方案，来解决求一个正态分布表这么个简单的问题，老师一再强调让我们不要有正确答案的想法，有解决方案即可，那次我记得那个问题同学们给出的解决方案有许许多多，插值、拟合、泰勒多项式展开、幂级数展开、求面积，多点函数值……</span></p><p id="9b0bb4b85f2dec12205f63aaabae9573" class="ne-p"><br></p><p id="092d046e3d698127add0c41ce2a3402f" class="ne-p"><span class="ne-text">其实从那个时候，我对算法这个事物有了进一步的认识，就像这位常年带学校ACM队的老师所说，算法就是解决实际问题，没有什么对错，只有精度，优化，算法亦是如此，其实那个时候，我对算法设计与分析那门课程里面谈及的各种算法问题，各种算法思想，也有了更加一步的上帝视角来观望。</span></p><p id="05929eda00ae5919fd815a662cd85fa9" class="ne-p"><br></p><p id="9253fa293a725c65c3d84a578fabd5d7" class="ne-p"><span class="ne-text">算法就是解决实际问题，手上敲的代码亦是如此。</span></p><p id="0cf6fc779ba8f66fde6e7988564ec396" class="ne-p"><br></p><p id="20752f0dd67268309d23274c50751265" class="ne-p"><span class="ne-text">他和我们说，我们现在在学校里面学的这些知识出去是用不到的，那为什么还学呢？</span></p><p id="8c49eea7ba0e2a94e20d5aa7979e7ac7" class="ne-p"><br></p><p id="c99f3d7c69c95bae89f8e779587cb237" class="ne-p"><span class="ne-text">能力。他的这个回答，和我的回答一样，身处在这个技术迭代极快的情况下，更何况是计算机行业，我们要学的实在太多了，但是又如老师所言，那些底层的知识，那些思想，是我们这些学习者要学习的，我想老师想表达的更是一种万变不离其中的意味吧。</span></p></div>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>博客与前端历程</title>
      <link href="/essay/sgyoz3/"/>
      <url>/essay/sgyoz3/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content-editor-core lake-engine lake-typography-traditional" data-lake-element="root" data-selection-undefined="%7B%22path%22%3A%5B%5B20%2C0%2C19%5D%2C%5B20%2C0%2C19%5D%5D%2C%22active%22%3Atrue%7D"><blockquote class="lake-alert lake-alert-info" style="margin: 0px; padding: 10px; border: 1px solid rgb(171, 210, 218); opacity: 1; border-radius: 3px; color: rgb(38, 38, 38); background-color: rgb(232, 247, 255);"><p data-lake-id="cba2c4e2b71701941bfa0c1b20ed801e" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">大三上学期，学习计算机网络的应用层那里，我才知道我常写的原来叫博客……</p></blockquote><h2 data-lake-id="92adbbfe4a5aa6608e7cd089ecbd6deb" id="ibOL9" style="padding: 7px 0px; margin: 0px; font-weight: 700; font-size: 24px; line-height: 32px;">学习就要做笔记</h2><p data-lake-id="a14d6fdcaceee344552fd9572dd3fb7a" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">大二上学期期末那会，当时复习操作系统那会在想，为什么我现在想不起来我大一的C语言的一些知识呢？学过的知识过了许久没有记录，没有可以供自己想起的那般线索，还有什么意义呢？于是，那时我就想着在网上弄一个电子笔记吧。</p><p data-lake-id="dedaa9ddca9d558738bd76d7dd060118" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="502c32f5f32c55fee52806f91995cf56" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">于是，我认识了Onenote，Onenote很灵活，以至于太过灵活，不太适合发布文章，用了一段时间，想了想我还是想以发布文章的角色来做笔记</p><p data-lake-id="a9712a7039eaf3d3c9344da5a5317081" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="1bc7ac352eda9f3034b820e0fdf38b84" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">于是期末那段时间我就平时在网上搜适合我做电子笔记的平台，当时改不知道什么是博客，但是看<span style="text-decoration: line-through;">很多人 </span>程序员都有自己的网站写点东西，于是就对其感兴趣了</p><p data-lake-id="39f8636cb14afd1e7e0a872601061e6d" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">再后来就发现很多人都拥有自己的个人网站，而且建立也很简单，一个GitHub就可以了，那会就一直玩GitHub，利用GitHub Pages搭建了一个静态网站</p><p data-lake-id="79016ef87fa507d74e85fa61668ccc5e" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="80be56b949cb5a9ce3c51bbead1b3625" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">疫情期间正好有一门选修课是JavaWeb，那会我就接触了CS架构模型</p><p data-lake-id="3067b5d791ed4700b4958eb0dd40ea66" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="46df8df78309cc710af16c686a0e6142" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">疫情期间，在家发现网上有好多的博客大神。突然有那么一刹那，我突然意识到，我想写的不是笔记，也不是零零碎碎的小想法，我要写的是一篇篇博客，一篇篇文章呀！</p><p data-lake-id="31b804584570c696e8ea320e26e9f4ea" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="c7934e2b02b6d40ffcfbde4bcba20775" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">从那之后，对前端就慢慢了解，前端很难，水很深，需要的自学能力甚至赶超其他行业。</p><p data-lake-id="c49606feb4bd6cb226e0fe51aa7fc1d6" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><h2 data-lake-id="1c8870608f4926bf4e6e23cfef6bcaf8" id="gQsCw" style="padding: 7px 0px; margin: 0px; font-weight: 700; font-size: 24px; line-height: 32px;">前端</h2><p data-lake-id="f60be6a15b71990dff19e58b6f34ad0e" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">其实一直喜欢数据，大一那会，人工智能，机器学习啥的，都特别火，那会我也就学了python，然后数据分析，那会我就挺喜欢数据分析挖掘的，将一堆杂乱的数据经过处理之后，就可以变成各种自己需要的各种数据，还能出图，matplotlib包，我就特别喜欢用这个画各种图</p><p data-lake-id="aceaa9d3d29394e66d88620d6e36a72f" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="4b60ced739e8b0da55379b397af86b5a" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="5e55e088ebeb13830aaac1b8427f3380" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">2021.04.26更</p><p data-lake-id="392a4c5cea7f24baee6ecf587f5f9134" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">好的，已入前端坑🙃，两个字——鬼魅～</p><p data-lake-id="890d5c1fa7a973f0e8769f32ea9db104" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="03c80d4816d1d81b111bd3892cc02b5b" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="afa02f3a67e1c46339d8fe127ba9845c" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="8a929880cea610aceb818399ccb02f75" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="9e5eec44a57eff2d2cbe60014751b27e" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p></div>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>万物守恒</title>
      <link href="/essay/ipgq2m/"/>
      <url>/essay/ipgq2m/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content-editor-core lake-engine lake-typography-classic" data-lake-element="root" data-selection-undefined="%7B%22path%22%3A%5B%5B0%2C0%2C26%5D%2C%5B0%2C0%2C26%5D%5D%2C%22active%22%3Atrue%7D"><p data-lake-id="a20d224c568e48b9d67847a2c66a8c01_p_0" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">什么都是守恒的，我一直觉得这世界上很多事物都是守恒的</p><ul data-lake-id="f41dc6a0380592dbd79392c93c9b4e96" lake-indent="0" style="list-style-type: disc; margin: 0px; padding-left: 23px; font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word;"><li data-lake-id="71604d4a068f0609c501f81d38b46f42">有过很顺的时候，也有过身处逆境</li><li data-lake-id="6d0e9b7b5bf941b8fd15550646b8ffc7">有过巅峰，也有过没落</li><li data-lake-id="10e305127541295efba8bb61559d7ce6">有些时候，你帮助陌生人，到某个时候，你也会被他人帮助</li><li data-lake-id="db95885c159ac2953e4cdc373eca749d">盛极一时的罗马，最后也败于自己</li><li data-lake-id="32e25861b77c470f3e9b1906cce703ed">秦的大一统，也终将没落</li></ul></div>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++匿名函数</title>
      <link href="/blog/uq89oe/"/>
      <url>/blog/uq89oe/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content-editor-core lake-engine lake-typography-classic" data-lake-element="root" data-selection-undefined="%7B%22path%22%3A%5B%5B0%2C0%2C0%5D%2C%5B0%2C0%2C0%5D%5D%2C%22active%22%3Atrue%7D"><h3 data-lake-id="c512eaf71a92e4852a8aed5b134a2fb2" id="5pXad" style="padding: 7px 0px; margin: 0px; font-weight: 700; font-size: 20px; line-height: 28px;">常用形式</h3><div data-card-type="block" data-lake-card="codeblock" id="9NY69" class="lake-card-margin" data-language="cpp"><div class="lake-codeblock-content" style="border: 1px solid rgb(232, 232, 232); max-width: 750px; color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: rgb(249, 249, 249);"><div class="CodeMirror-sizer" style="color: rgb(89, 89, 89); margin: 0px; padding: 16px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"><pre class="cm-s-default" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"><span class="lake-preview-line" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"><span class="lake-preview-line-number lake-lm-pad-level-0" style="color: rgb(191, 191, 191); margin: 0px 8px 0px 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"></span><span class="lake-preview-codeblock-content" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">[](<span class="cm-type" style="color: rgb(34, 134, 58); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">int</span> <span class="cm-variable" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">x</span>, <span class="cm-type" style="color: rgb(34, 134, 58); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">int</span> <span class="cm-variable" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">y</span>) <span class="cm-operator" style="color: rgb(215, 58, 73); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">-&gt;</span> <span class="cm-type" style="color: rgb(34, 134, 58); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">int</span> { <span class="cm-type" style="color: rgb(34, 134, 58); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">int</span> <span class="cm-variable" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">z</span> <span class="cm-operator" style="color: rgb(215, 58, 73); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">=</span> <span class="cm-variable" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">x</span> <span class="cm-operator" style="color: rgb(215, 58, 73); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">+</span> <span class="cm-variable" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">y</span>; <span class="cm-keyword" style="color: rgb(215, 58, 73); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">return</span> <span class="cm-variable" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">z</span>; } <span class="cm-comment" style="color: rgb(106, 115, 125); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">//这样显示指定返回类型:</span></span></span><span class="lake-preview-line" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"><span class="lake-preview-line-number lake-lm-pad-level-0" style="color: rgb(191, 191, 191); margin: 0px 8px 0px 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"></span><span class="lake-preview-codeblock-content" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"></span></span><span class="lake-preview-line" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"><span class="lake-preview-line-number lake-lm-pad-level-0" style="color: rgb(191, 191, 191); margin: 0px 8px 0px 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"></span><span class="lake-preview-codeblock-content" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">[](<span class="cm-type" style="color: rgb(34, 134, 58); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">int</span> <span class="cm-variable" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">x</span>, <span class="cm-type" style="color: rgb(34, 134, 58); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">int</span> <span class="cm-variable" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">y</span>) { <span class="cm-keyword" style="color: rgb(215, 58, 73); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">return</span> <span class="cm-variable" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">x</span> <span class="cm-operator" style="color: rgb(215, 58, 73); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">+</span> <span class="cm-variable" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">y</span>; } <span class="cm-comment" style="color: rgb(106, 115, 125); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">// 隐式返回类型</span></span></span><span class="lake-preview-line" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"><span class="lake-preview-line-number lake-lm-pad-level-0" style="color: rgb(191, 191, 191); margin: 0px 8px 0px 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"></span><span class="lake-preview-codeblock-content" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">[](<span class="cm-type" style="color: rgb(34, 134, 58); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">int</span><span class="cm-operator" style="color: rgb(215, 58, 73); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">&amp;</span> <span class="cm-variable" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">x</span>) { <span class="cm-operator" style="color: rgb(215, 58, 73); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">++</span><span class="cm-variable" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">x</span>; }   <span class="cm-comment" style="color: rgb(106, 115, 125); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">// 没有return语句 -&gt; lambda 函数的返回类型是'void'</span></span></span><span class="lake-preview-line" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"><span class="lake-preview-line-number lake-lm-pad-level-0" style="color: rgb(191, 191, 191); margin: 0px 8px 0px 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"></span><span class="lake-preview-codeblock-content" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">[]() { <span class="cm-operator" style="color: rgb(215, 58, 73); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">++</span><span class="cm-variable" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">global_x</span>; }  <span class="cm-comment" style="color: rgb(106, 115, 125); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">// 没有参数,仅访问某个全局变量</span></span></span><span class="lake-preview-line" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"><span class="lake-preview-line-number lake-lm-pad-level-0" style="color: rgb(191, 191, 191); margin: 0px 8px 0px 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"></span><span class="lake-preview-codeblock-content" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">[]{ <span class="cm-operator" style="color: rgb(215, 58, 73); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">++</span><span class="cm-variable" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">global_x</span>; }     <span class="cm-comment" style="color: rgb(106, 115, 125); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">// 与上一个相同,省略了()</span></span></span></pre></div></div></div><h3 data-lake-id="279e2274eaf98f290a7b10804c6e7d10" id="b6aC6" style="padding: 7px 0px; margin: 0px; font-weight: 700; font-size: 20px; line-height: 28px;">小例子</h3><div data-card-type="block" data-lake-card="codeblock" id="cbZUs" class="lake-card-margin" data-language="cpp"><div class="lake-codeblock-content" style="border: 1px solid rgb(232, 232, 232); max-width: 750px; color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: rgb(249, 249, 249);"><div class="CodeMirror-sizer" style="color: rgb(89, 89, 89); margin: 0px; padding: 16px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"><pre class="cm-s-default" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"><span class="lake-preview-line" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"><span class="lake-preview-line-number lake-lm-pad-level-1" style="color: rgb(191, 191, 191); margin: 0px 8px 0px 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"></span><span class="lake-preview-codeblock-content" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"><span class="cm-meta" style="color: rgb(31, 127, 154); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">#include &lt;iostream&gt;</span></span></span><span class="lake-preview-line" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"><span class="lake-preview-line-number lake-lm-pad-level-1" style="color: rgb(191, 191, 191); margin: 0px 8px 0px 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"></span><span class="lake-preview-codeblock-content" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"></span></span><span class="lake-preview-line" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"><span class="lake-preview-line-number lake-lm-pad-level-1" style="color: rgb(191, 191, 191); margin: 0px 8px 0px 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"></span><span class="lake-preview-codeblock-content" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"><span class="cm-type" style="color: rgb(34, 134, 58); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">int</span> <span class="cm-def" style="color: rgb(0, 92, 197); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">main</span>() {</span></span><span class="lake-preview-line" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"><span class="lake-preview-line-number lake-lm-pad-level-1" style="color: rgb(191, 191, 191); margin: 0px 8px 0px 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"></span><span class="lake-preview-codeblock-content" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">    <span class="cm-comment" style="color: rgb(106, 115, 125); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">// lambda表达式</span></span></span><span class="lake-preview-line" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"><span class="lake-preview-line-number lake-lm-pad-level-1" style="color: rgb(191, 191, 191); margin: 0px 8px 0px 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"></span><span class="lake-preview-codeblock-content" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">    <span class="cm-keyword" style="color: rgb(215, 58, 73); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">auto</span> <span class="cm-variable" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">multiply</span> <span class="cm-operator" style="color: rgb(215, 58, 73); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">=</span> [](<span class="cm-type" style="color: rgb(34, 134, 58); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">int</span> <span class="cm-variable" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">a</span>, <span class="cm-type" style="color: rgb(34, 134, 58); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">int</span> <span class="cm-variable" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">b</span>) <span class="cm-operator" style="color: rgb(215, 58, 73); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">-&gt;</span> <span class="cm-type" style="color: rgb(34, 134, 58); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">int</span> { <span class="cm-keyword" style="color: rgb(215, 58, 73); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">return</span> <span class="cm-variable" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">a</span> <span class="cm-operator" style="color: rgb(215, 58, 73); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">*</span> <span class="cm-variable" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">b</span>; };</span></span><span class="lake-preview-line" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"><span class="lake-preview-line-number lake-lm-pad-level-1" style="color: rgb(191, 191, 191); margin: 0px 8px 0px 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"></span><span class="lake-preview-codeblock-content" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">    <span class="cm-comment" style="color: rgb(106, 115, 125); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">// 匿名函数调用</span></span></span><span class="lake-preview-line" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"><span class="lake-preview-line-number lake-lm-pad-level-1" style="color: rgb(191, 191, 191); margin: 0px 8px 0px 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"></span><span class="lake-preview-codeblock-content" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">    <span class="cm-keyword" style="color: rgb(215, 58, 73); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">auto</span> <span class="cm-variable" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">result</span> <span class="cm-operator" style="color: rgb(215, 58, 73); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">=</span> <span class="cm-variable" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">multiply</span>(<span class="cm-number" style="color: rgb(0, 92, 197); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">2</span>, <span class="cm-number" style="color: rgb(0, 92, 197); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">4</span>);</span></span><span class="lake-preview-line" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"><span class="lake-preview-line-number lake-lm-pad-level-1" style="color: rgb(191, 191, 191); margin: 0px 8px 0px 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"></span><span class="lake-preview-codeblock-content" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">    <span class="cm-variable" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">std::cout</span> <span class="cm-operator" style="color: rgb(215, 58, 73); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">&lt;&lt;</span> <span class="cm-variable" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">result</span> <span class="cm-operator" style="color: rgb(215, 58, 73); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">&lt;&lt;</span> <span class="cm-variable" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">std::endl</span>;</span></span><span class="lake-preview-line" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"><span class="lake-preview-line-number lake-lm-pad-level-1" style="color: rgb(191, 191, 191); margin: 0px 8px 0px 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"></span><span class="lake-preview-codeblock-content" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">    <span class="cm-keyword" style="color: rgb(215, 58, 73); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">return</span> <span class="cm-number" style="color: rgb(0, 92, 197); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">0</span>;</span></span><span class="lake-preview-line" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"><span class="lake-preview-line-number lake-lm-pad-level-0" style="color: rgb(191, 191, 191); margin: 0px 8px 0px 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"></span><span class="lake-preview-codeblock-content" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">}</span></span></pre></div></div></div><h3 data-lake-id="f2db07d882cd109da59b5282d55d45ed" id="Idn0s" style="padding: 7px 0px; margin: 0px; font-weight: 700; font-size: 20px; line-height: 28px;">参考</h3><blockquote style="margin-top: 5px; margin-bottom: 5px; padding-left: 1em; margin-left: 0px; border-left: 3px solid rgb(238, 238, 238); opacity: 0.6;"><p data-lake-id="731c941f597e22e1c1c49f48f68cf314" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">一些进一步用法<a href="https://www.cnblogs.com/pzhfei/archive/2013/01/14/lambda_expression.html" target="_blank">https://www.cnblogs.com/pzhfei/archive/2013/01/14/lambda_expression.html</a></p></blockquote></div>]]></content>
      
      
      <categories>
          
          <category> 计算机素养 </category>
          
          <category> 后端编程语言 </category>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Huffman编码算法</title>
      <link href="/blog/ggu8v9/"/>
      <url>/blog/ggu8v9/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h2 id="sgeWE"><span class="ne-text">问题描述</span></h2><p id="9e986f8b518aa874e5488365b4e318ad" class="ne-p"><span class="ne-text">压缩算法，目的就是根据字母的出现频率来“按需分配”编码来优化编码方式。</span></p><p id="077c62ae4385fc6d47f65957345e17f5" class="ne-p"><span class="ne-text">比如：给出一串字母   </span><code class="ne-code"><span class="ne-text">Huffman Coding</span></code><span class="ne-text">   ，按照计算机处理形式，会根据ascll码将这串字符编码，具体形式（十进制）就是104 117 102 102 109 97 110 32 67 111 100 105 110 103，然后转换成二进制，最后会得到需要97个比特来存储。</span></p><h2 id="CaJgL"><span class="ne-text">算法描述</span></h2><p id="7e72a7f72a1ef85799d8e92db7d33404" class="ne-p"><span class="ne-text">算法角度来讲对上述问题ascll编码方式是浪费空间的，优化方向是改变编码方式，根据字母出现的频率来“按需分配”进制位。</span></p><p id="7bcb792f84491e892aa6eec4fe5ff850" class="ne-p"><br></p><p id="3568172be7d1c8656b762c0d960074ad" class="ne-p" style="text-align: left"><span class="ne-text">给出下面所给出的字母，以及出现的频率，来得到哈夫曼编码</span></p><p id="6ccb77d085739e1dd8a502fd7145d98b" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1605340774734-5ec5e8f1-0fae-47ff-8ded-dccf9611a3ad.png" width="205.5" id="pbDsY" class="ne-image"></p><p id="08528f8a11c5d0ecc0cd3bae97773b5b" class="ne-p" style="text-align: left"><span class="ne-text">先提出将频率小的依次加入。d和h组合权值为9(或者说A只是称呼方便)，然后将这个9“替换d和h”代入整个序列，在进行插入树操作，</span></p><div class="ne-quote"><p id="a5e27cd3dfd648344330915cf07369d8" class="ne-p" style="text-align: left"><span class="ne-text">过程中，遵循数字大的在左数字小的在右原则（互换也没关系，只不过换的是二进制的0和1）</span></p></div><p id="80aefeec8f8b6ab08a4c6c02bfb68c36" class="ne-p"><span class="ne-text">在进行到E的时候，此时的队列应该为120 107 42 37，所以此时需要重新调整队列，然后进行到结束。</span></p><p id="e68706c149a6ec04640e3cad07d51c50" class="ne-p" style="text-align: left"><br></p><p id="c8e68bfc6996011d2dc03f21a12bb5f5" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1605340899720-d8867a90-d01c-4bf6-8ec7-ca0e812a99dd.png" width="188" id="vJM66" class="ne-image"></p><p id="4ef66678373379b55daca8b336a95124" class="ne-p" style="text-align: left"><span class="ne-text">最后的编码结果为：</span></p><p id="05a0e15b6dd3480361d88674d68f7b0d" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1605341313840-61587c86-135d-4ba0-96aa-844868de1d56.png" width="82.5" id="ENEj4" class="ne-image"></p><h2 id="3eVEL"><span class="ne-text">编码实现</span></h2><pre><code>#include &lt;stdio.h&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;namespace NS_HuffmanCoding &#123;using namespace std;void BuildHuffmanTree();void Initialization(vector&lt;pair&lt;char, int&gt;&gt; chars);void Finalization();struct HFMNode &#123;  char Ch; int Freq;  HFMNode* Left, * Right;  HFMNode(char pCh, int pFreq, HFMNode* pLeft, HFMNode* pRight)    : Ch(pCh), Freq(pFreq), Left(pLeft), Right(pRight) &#123;&#125;  HFMNode(char pCh, int pFreq)    : HFMNode(pCh, pFreq, NULL, NULL) &#123;&#125;&#125;;void MinHeapify(vector&lt;HFMNode*&gt;&amp; H);void InsertH(vector&lt;HFMNode*&gt;&amp; H, HFMNode* node);void SiftDown(vector&lt;HFMNode*&gt;&amp; H, int i);void SiftUp(vector&lt;HFMNode*&gt;&amp; H, int i);HFMNode* ExtractMin(vector&lt;HFMNode*&gt;&amp; H);void DeleteANode(HFMNode* node);void ShowInput(vector&lt;pair&lt;char, int&gt;&gt; chars);void Output();static vector&lt;HFMNode*&gt; Q;void HuffmanCodingCaller(vector&lt;pair&lt;char, int&gt;&gt; chars)&#123;  ShowInput(chars);  Initialization(chars);  BuildHuffmanTree();  Output();  Finalization();&#125;void BuildHuffmanTree()&#123;  char C = 'A';  while (Q.size() &gt; 1)  &#123;    HFMNode* x = ExtractMin(Q);    HFMNode* y = ExtractMin(Q);    HFMNode* z = new HFMNode(C++, x-&gt;Freq + y-&gt;Freq, x, y);    InsertH(Q, z);  &#125;&#125;HFMNode* ExtractMin(vector&lt;HFMNode*&gt;&amp; H)&#123;  swap(H.front(), H.back());  HFMNode* p = H.back();  H.pop_back();  if (!H.empty())    SiftDown(H, 0);  return p;&#125;void SiftDown(vector&lt;HFMNode*&gt;&amp; H, int i)&#123;    while ((i = (i &lt;&lt; 1) + 1) &lt; H.size()) &#123;        if ((i + 1 &lt; H.size()) &amp;&amp; (H[i + 1]-&gt;Freq &lt; H[i]-&gt;Freq))            i = i + 1;        if (H[(i - 1) &gt;&gt; 1]-&gt;Freq &gt; H[i]-&gt;Freq)            swap(H[(i - 1) &gt;&gt; 1], H[i]);        else break;    &#125;&#125;void InsertH(vector&lt;HFMNode*&gt;&amp; H, HFMNode* node)&#123;  H.push_back(node);  SiftUp(H, H.size() - 1);&#125;void SiftUp(vector&lt;HFMNode*&gt;&amp; H, int i)&#123;  while (i &gt; 0 &amp;&amp; H[i]-&gt;Freq &lt; H[(i - 1) &gt;&gt; 1]-&gt;Freq) &#123;    swap(H[i], H[(i - 1) &gt;&gt; 1]);    i = (i - 1) &gt;&gt; 1;  &#125;&#125;void MinHeapify(vector&lt;HFMNode*&gt;&amp; H)&#123;  for (int i = (H.size() &gt;&gt; 1) - 1; i &gt;= 0; i--) &#123;    SiftDown(H, i);  &#125;&#125;<p>void Initialization(vector&lt;pair&lt;char, int&gt;&gt; chars)<br>&#123;<br>  Q.clear();<br>  for (auto ch : chars)<br>    Q.push_back(new HFMNode(ch.first, ch.second));<br>  MinHeapify(Q);<br>&#125;<br>void Finalization()<br>&#123;<br>  DeleteANode(Q[0]);<br>&#125;<br>void DeleteANode(HFMNode* node)<br>&#123;<br>  if (node-&gt;Left)<br>  &#123;<br>    DeleteANode(node-&gt;Left);<br>    DeleteANode(node-&gt;Right);<br>  &#125;<br>  delete node;<br>&#125;<br>void ShowInput(vector&lt;pair&lt;char, int&gt;&gt; chars)<br>&#123;<br>  printf(&quot;Huffman coding input: \n&quot;);<br>  for (auto c : chars)<br>    printf(&quot;%c,%d; &quot;, c.first, c.second);<br>  printf(&quot;\n&quot;);<br>&#125;<br>static vector&lt;char&gt; coding;<br>static vector&lt;pair&lt;char, vector&lt;char&gt;&gt;&gt; codingList;<br>void GetHuffmanCoding(HFMNode* node)<br>&#123;<br>  if (node-&gt;Left)<br>  &#123;<br>    coding.push_back(‘0’);<br>    GetHuffmanCoding(node-&gt;Left);<br>    coding.pop_back();<br>    coding.push_back(‘1’);<br>    GetHuffmanCoding(node-&gt;Right);<br>    coding.pop_back();<br>  &#125;<br>  else<br>  &#123;<br>    codingList.push_back(pair&lt;char,<br>      vector&lt;char&gt;&gt;(node-&gt;Ch, coding));<br>  &#125;<br>&#125;<br>void Output()<br>&#123;<br>  printf(&quot;Huffman coding:\n&quot;);<br>  coding.clear();<br>  codingList.clear();<br>  GetHuffmanCoding(Q[0]);<br>  sort(codingList.begin(), codingList.end());<br>  for (auto c1 : codingList)<br>  &#123;<br>    printf(&quot;  %c: &quot;, c1.first);<br>    for (auto c2 : c1.second)<br>      printf(&quot;%c&quot;, c2);<br>    printf(&quot;\n&quot;);<br>  &#125;<br>  printf(&quot;\n&quot;);<br>&#125;<br>&#125; //namespace NS_HuffmanCoding<br>using namespace NS_HuffmanCoding;<br>void TestHuffmanCoding()<br>&#123;<br>  vector&lt;vector&lt;pair&lt;char, int&gt;&gt;&gt; charLists = &#123;<br>      //Introduction to Algorithms<br>     &#123;<br>        &#123; &#123;‘a’,40&#125;, &#123;‘b’,13&#125;, &#123;‘c’,12&#125;,<br>          &#123;‘d’,16&#125;, &#123;‘e’,9&#125;, &#123;‘f’,5&#125; &#125;,<br>     &#125;,<br>     //ÑÏÎµÃô<br>     &#123;<br>        &#123; &#123;‘a’,5&#125;, &#123;‘b’,29&#125;, &#123;‘c’,7&#125;, &#123;‘d’,8&#125;,<br>          &#123;‘e’,14&#125;, &#123;‘f’,23&#125;, &#123;‘g’,3&#125;, &#123;‘h’,11&#125; &#125;,<br>     &#125;,<br>  &#125;;<br>  int n = charLists.size();<br>  for (int i = 0; i &lt; n; i++)<br>  &#123;<br>    HuffmanCodingCaller(charLists[i]);<br>  &#125;<br>&#125;<br></code></pre></p></div>]]></content>
      
      
      <categories>
          
          <category> 计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 💕贪心算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>最小生成树算法（Prim+Kruskal）</title>
      <link href="/blog/ghf568/"/>
      <url>/blog/ghf568/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><div data-type="info" class="ne-alert"><p id="5e0adbd3c4d03c372bc5bdbf949fc59c" class="ne-p"><span class="ne-text" style="background-color: #E8F7FF">贪心算法四个字总结：目前最优</span></p></div><h2 id="nHUEx"><span class="ne-text">图的一些概念</span></h2><p id="be7203f2c5e3cc70ac3430a06137165d" class="ne-p"><span class="ne-text">具体看先前的一篇文章</span><a href="https://www.wztlink1013.com/blog/gqpli5/" data-href="https://www.wztlink1013.com/blog/gqpli5/" target="_blank" class="ne-link"><span class="ne-text">https://www.wztlink1013.com/blog/gqpli5/</span></a></p><p id="5898cb029323a7e7bcde68a749655cea" class="ne-p"><span class="ne-text"></span></p><p id="0efe0efc44dc0dc883b9f397c6ac1ab9" class="ne-p"><strong><span class="ne-text">连通图</span></strong></p><div class="ne-quote"><p id="8380f5d22f1a9a91b06b0c585ee37581" class="ne-p"><span class="ne-text" style="color: #333333; font-size: 14px">在</span><a href="https://baike.baidu.com/item/%E5%9B%BE%E8%AE%BA/1433806" data-href="https://baike.baidu.com/item/%E5%9B%BE%E8%AE%BA/1433806" target="_blank" class="ne-link"><span class="ne-text">图论</span></a><span class="ne-text" style="color: #333333; font-size: 14px">中，连通图基于连通的概念。在一个</span><a href="https://baike.baidu.com/item/%E6%97%A0%E5%90%91%E5%9B%BE/1680427" data-href="https://baike.baidu.com/item/%E6%97%A0%E5%90%91%E5%9B%BE/1680427" target="_blank" class="ne-link"><span class="ne-text">无向图</span></a><span class="ne-text" style="color: #333333; font-size: 14px"> G 中，若从</span><a href="https://baike.baidu.com/item/%E9%A1%B6%E7%82%B9/11030118" data-href="https://baike.baidu.com/item/%E9%A1%B6%E7%82%B9/11030118" target="_blank" class="ne-link"><span class="ne-text">顶点</span></a><span class="ne-text" style="color: #333333; font-size: 14px">i到顶点j有路径相连（当然从j到i也一定有路径），则称i和j是连通的。如果 G 是</span><a href="https://baike.baidu.com/item/%E6%9C%89%E5%90%91%E5%9B%BE" data-href="https://baike.baidu.com/item/%E6%9C%89%E5%90%91%E5%9B%BE" target="_blank" class="ne-link"><span class="ne-text">有向图</span></a><span class="ne-text" style="color: #333333; font-size: 14px">，那么连接i和j的路径中所有的边都必须同向。如果图中任意两点都是连通的，那么图被称作连通图。如果此图是有向图，则称为强连通图（注意：需要双向都有路径）。图的</span><a href="https://baike.baidu.com/item/%E8%BF%9E%E9%80%9A%E6%80%A7/6688865" data-href="https://baike.baidu.com/item/%E8%BF%9E%E9%80%9A%E6%80%A7/6688865" target="_blank" class="ne-link"><span class="ne-text">连通性</span></a><span class="ne-text" style="color: #333333; font-size: 14px">是图的基本性质。</span></p></div><p id="665951f6ed45e95795596091ea37cb43" class="ne-p"><strong><span class="ne-text">生成树</span></strong></p><div class="ne-quote"><p id="10112c33ae37e9de266d7dc9ad43da3e" class="ne-p"><span class="ne-text">包含图的全部顶点，边数最少的连通子图</span></p></div><p id="bf98f96271e09d1bf20e8fafda285603" class="ne-p"><strong><span class="ne-text">最小生成树</span></strong></p><div class="ne-quote"><p id="3826220ba76c178c35683068e2ab02a8" class="ne-p"><span class="ne-text">总权值最小的生成树</span></p></div><p id="b7c6c94ca874bae05cd003d128c1f69e" class="ne-p"><span class="ne-text">常见问题（该算法）就是求最小生成树。</span></p><p id="3ad4e5b28974402730ddf0a7a6c9a765" class="ne-p"><strong><span class="ne-text">并查集</span></strong></p><div class="ne-quote"><p id="fb49f1af56a20258b0994e05a5bd822f" class="ne-p"><span class="ne-text">是一个数据结构，功能有查找a和b是否为同一组；将a和b合并为同一组。</span></p></div><h2 id="Vz5Jg"><span class="ne-text">Prim算法思路</span></h2><p id="63b94f88c91d418b3a5ea7c1d40eb1c1" class="ne-p"><code class="ne-code"><span class="ne-text">Prim——普里姆算法</span></code></p><p id="57e1c39936058ab0cf89190777c671eb" class="ne-p"><span class="ne-text"></span></p><p id="65c9dddc9466daf1f87f622ae9013e7e" class="ne-p"><span class="ne-text">类似于图的深度优先遍历一样，在遍历到一个结点的时候，在此根据该节点所连通的各边权值，取最小的，以此往复</span></p><p id="cbff9ebe6415e49d40421bd46dcadcad" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1625102662437-05ab5a6e-fcc3-46d5-8c2d-666c9c23fa9a.png" width="388" id="Qjspy" class="ne-image"></p><h2 id="PFbmU"><span class="ne-text">Kruskal算法</span><span class="ne-text">思路</span></h2><p id="bc1fd8840968eaa8cd942c02348006fc" class="ne-p"><code class="ne-code"><span class="ne-text">Kruskal——克鲁斯卡尔算法</span></code></p><p id="5d99ae9579b08eceffe5b7ad59c14ee2" class="ne-p"><br></p><p id="7a889ea78b39c7c9c9904fcebe169343" class="ne-p"><span class="ne-text">把所有边按照权值全部按数值大小拿出来，然后按顺序选取每条边，利用并查集的思想，如果这条边的两个端点不属于同一集合，那么就将它们合并，直到所有的点都属于同一个集合为止。</span></p><p id="26e6db5a49dd1bdcfc6be897e96f7c38" class="ne-p"><br></p><p id="bb2fe010dc25de5f292f2c92b428fe68" class="ne-p"><span class="ne-text">比如有如下这么一个图：</span></p><p id="6e2e9f3149f755d4f53fdad50964b38b" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1605320252853-c5d445e4-aa0e-4279-b9fd-7477f23b1bc1.png" width="219" id="Hx7aL" class="ne-image"></p><p id="aac64b9ab680edd476d18b367cb142ba" class="ne-p" style="text-align: left"><span class="ne-text">单独分析①②边和③④边情况下，两个不在一个集合里面，</span></p><p id="39ba58d75802638e8beb1aeb08e5f2b4" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1605320331669-51ec03dc-caf6-449d-9e8b-e4e62b9f35a6.png" width="384.5" id="PuNRa" class="ne-image"></p><p id="c55b6b173dedc37838a3ebc2021f673d" class="ne-p"><span class="ne-text">不断重复，不断判断是否为同一个集合，不在同一个集合的话，就合并，持续如此。比方说当一直操作到权值为3的时候，此时就需要将左右两个集合合并了</span></p><p id="90ebd57d6561894820dc28eb8dba77c2" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1605320497092-00097419-4852-44c4-884e-febd4d37eb65.png" width="374" id="wsUam" class="ne-image"></p><p id="997a98f28e94a25540a4893a96c5098d" class="ne-p" style="text-align: left"><span class="ne-text">最后的结果样式就为如下</span></p><p id="fd9a3ee6d2a2bf0a101c0dfb8cb7eb03" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1605320612085-d893c759-4ef1-410c-976e-8f32ddfe6321.png" width="390" id="adOCr" class="ne-image"></p><p id="91b40a459460ec5d2efb79ae1d139a58" class="ne-p" style="text-align: center"><br></p><h2 id="9kZiP"><span class="ne-text">代码实现</span></h2><h3 id="YPhZh"><span class="ne-text">Kruskal算法代码</span></h3><pre><code>#include &lt;stdio.h&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;namespace NS_KruskalMST &#123;using namespace std;void KruskalMST();int FindSet(int u);void UnionSets(int u, int v);void Initialization();void GenEdges();void MakeSets();void Output(int v0);#define INF INT_MAXstatic int n;static vector&lt;vector&lt;int&gt;&gt; WMatrix;static vector&lt;pair&lt;pair&lt;int, int&gt;, int&gt;&gt; Edges;//Node struct for the disjoint setstruct DJSNode &#123;    int Parent; int Rank;    DJSNode(int p) : Parent(p), Rank(0) &#123;&#125;&#125;;static vector&lt;DJSNode&gt; DisjointSet;static vector&lt;pair&lt;int, int&gt;&gt; MST;//The adjacency list for MSTstatic vector&lt;vector&lt;int&gt;&gt; MSTList;static vector&lt;int&gt; Prev;void KruskalMSTCaller(int an,     vector&lt;vector&lt;int&gt;&gt; &amp;wMatrix, int v0)&#123;    n = an;    WMatrix = wMatrix;    Initialization();    KruskalMST();    Output(v0);&#125;void KruskalMST()&#123;    for (auto &amp;e: Edges)    &#123;        int u = e.first.first;        int v = e.first.second;        int setU = FindSet(u);        int setV = FindSet(v);        if (setU != setV)        &#123;            MST.push_back(e.first);            if (MST.size() == n - 1)                break;            UnionSets(setU, setV);        &#125;    &#125;&#125;int FindSet(int u)&#123;    while (u != DisjointSet[u].Parent)        u = DisjointSet[u].Parent;        //For path compression:        //DisjointSet[u].Parent =         //    FindSet(DisjointSet[u].Parent);    return u;&#125;void UnionSets(int u, int v)&#123;    if (DisjointSet[u].Rank &gt;= DisjointSet[v].Rank)        DisjointSet[v].Parent = u;    else        DisjointSet[u].Parent = v;    if (DisjointSet[u].Rank == DisjointSet[v].Rank)        DisjointSet[u].Rank++;&#125;void Initialization()&#123;    GenEdges();    sort(Edges.begin(), Edges.end(),         [](pair&lt;pair&lt;int, int&gt;, int&gt;a,             pair&lt;pair&lt;int, int&gt;, int&gt;b)        &#123;return a.second &lt; b.second; &#125;);    MakeSets();    MST.clear();&#125;void GenEdges()&#123;    Edges.clear();    //Traverse the upper triangle of WMatrix    for (int i = 0; i &lt; n - 1; i++)    &#123;        for (int j = i + 1; j &lt; n; j++)            if (WMatrix[i][j] != INF)                Edges.push_back(&#123; &#123;i, j&#125;,                    WMatrix[i][j] &#125;);    &#125;&#125;void MakeSets()&#123;    DisjointSet.clear();    for (int i = 0; i &lt; n; i++)        DisjointSet.push_back(DJSNode(i));&#125;void OutputWMatrix()&#123;    printf(&quot;n = %d\n&quot;, n);    printf(&quot;The weight matrix:\n&quot;);    printf(&quot;%3c&quot;, ' ');    for (int j = 0; j &lt; n; j++)        printf(&quot;%3d&quot;, j + 1);    printf(&quot;\n&quot;);    for (int i = 0; i &lt; n; i++)    &#123;        printf(&quot;%3d&quot;, i + 1);        for (auto j : WMatrix[i])            if (j &lt; INF)                printf(&quot;%3d&quot;, j);            else                printf(&quot;%3c&quot;, '*');        printf(&quot;\n&quot;);    &#125;&#125;void OutputPath(int u)&#123;    if (Prev[u] == -1)        printf(&quot;%d&quot;, u + 1);    else    &#123;        OutputPath(Prev[u]);        printf(&quot;-%d&quot;, u + 1);    &#125;&#125;void GenMSTList()&#123;    MSTList.clear();    MSTList.resize(n);    for (auto &amp;e: MST)    &#123;        MSTList[e.first].push_back(e.second);        MSTList[e.second].push_back(e.first);    &#125;&#125;void GenPrev(int v)&#123;    for (auto &amp;u : MSTList[v])        if (u != -1)        &#123;            Prev[u] = v;            auto w = find(MSTList[u].begin(),                 MSTList[u].end(), v);            MSTList[u][w - MSTList[u].begin()] = -1;            GenPrev(u);        &#125;&#125;void Output(int v0)&#123;    printf(&quot;Kruskal's MST algorithm\n&quot;);    OutputWMatrix();    int wSum = 0;    for (int i = 0; i &lt; n - 1; i++)        wSum += WMatrix[MST[i].first][MST[i].second];    GenMSTList();    Prev.clear();    Prev.resize(n);    Prev[v0] = -1;    GenPrev(v0);    printf(&quot;The MST edges:\n&quot;);    printf(&quot;Edge Weight\n&quot;);    for (auto &amp;e : MST)        printf(&quot; %d-%d  %d\n&quot;, e.first + 1, e.second + 1,            WMatrix[e.first][e.second]);    printf(&quot;Total MST weight: %d\n&quot;, wSum);    printf(&quot;The MST paths from vertex %d:\n&quot;, v0 + 1);    for (int u = 0; u &lt; n; u++)        if (u != v0)        &#123;            printf(&quot;%3d: &quot;, u + 1);            OutputPath(u);            printf(&quot;\n&quot;);        &#125;    printf(&quot;\n&quot;);&#125;&#125; //namespace NS_KruskalMSTusing namespace NS_KruskalMST;void TestKruskalMST(int v0 = 0)&#123;    vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt; w = &#123;        //https://www.geeksforgeeks.org/        //prims-minimum-spanning-tree-mst-greedy-algo-5/        &#123;            &#123;   0,  2,INF,  6,INF &#125;,            &#123;   2,  0,  3,  8,  5 &#125;,            &#123; INF,  3,  0,INF,  7 &#125;,            &#123;   6,  8,INF,  0,  9 &#125;,            &#123; INF,  5,  7,  9,  0 &#125;        &#125;,        // Dijkstra's algorithm on Wikipedia        &#123;            &#123;   0,  7,  9,INF,INF, 14 &#125;,            &#123;   7,  0, 10, 15,INF,INF &#125;,            &#123;   9, 10,  0, 11,INF,  2 &#125;,            &#123; INF, 15, 11,  0,  6,INF &#125;,            &#123; INF,INF,INF,  6,  0,  9 &#125;,            &#123;  14,INF,  2,INF,  9,  0 &#125;,        &#125;,        //https://www.geeksforgeeks.org/        //kruskals-minimum-spanning-tree-using-stl-in-c/        &#123;            &#123;   0,  4,INF,INF,INF,INF,INF,  8,INF &#125;,            &#123;   4,  0,  8,INF,INF,INF,INF, 11,INF &#125;,            &#123; INF,  8,  0,  7,INF,  4,INF,INF,  2 &#125;,            &#123; INF,INF,  7,  0,  9, 14,INF,INF,INF &#125;,            &#123; INF,INF,INF,  9,  0, 10,INF,INF,INF &#125;,            &#123; INF,INF,  4, 14, 10,  0,  2,INF,INF &#125;,            &#123; INF,INF,INF,INF,INF,  2,  0,  1,  6 &#125;,            &#123;   8, 11,INF,INF,INF,INF,  1,  0,  7 &#125;,            &#123; INF,INF,  2,INF,INF,INF,  6,  7,  0 &#125;,        &#125;,    &#125;;    int k = w.size();    for (int i = 0; i &lt; k; i++)    &#123;      if (v0 &gt; w[i].size() - 1)        v0 = w[i].size() - 1;      KruskalMSTCaller(w[i].size(), w[i], v0);    &#125;&#125;</code></pre></div>]]></content>
      
      
      <categories>
          
          <category> 计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 💕贪心算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Git提交规范</title>
      <link href="/blog/lezklv/"/>
      <url>/blog/lezklv/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h2 id="xQctS"><span class="ne-text">一、提交格式</span></h2><h3 id="fWntM"><span class="ne-text">commit message格式</span></h3><p id="uf7ca8131" class="ne-p"><br></p><pre><code>&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;</code></pre><p id="u065d4b06" class="ne-p"><br></p><h3 id="l3coW"><span class="ne-text">type(必须）</span></h3><div class="ne-quote"><p id="u5d05744d" class="ne-p"><span class="ne-text">用于说明git commit的类别，只允许使用下面的标识。</span></p></div><p id="uad66bacc" class="ne-p"><span class="ne-text"><br /></span><span class="ne-text">feat：新功能（feature）。<br /></span><span class="ne-text">fix/to：修复bug，可以是QA发现的BUG，也可以是研发自己发现的BUG。</span></p><ul class="ne-ul"><li id="u12c875ce"><span class="ne-text">fix：产生diff并自动修复此问题。适合于一次提交直接修复问题</span></li><li id="u5c601204"><span class="ne-text">to：只产生diff不自动修复此问题。适合于多次提交。最终修复问题提交时使用fix</span></li></ul><p id="u23e52ac0" class="ne-p"><span class="ne-text">docs：文档（documentation）。<br /></span><span class="ne-text">style：格式（不影响代码运行的变动）。<br /></span><span class="ne-text">refactor：重构（即不是新增功能，也不是修改bug的代码变动）<br /></span><span class="ne-text">perf：优化相关，比如提升性能、体验。<br /></span><span class="ne-text">test：增加测试。<br /></span><span class="ne-text">chore：构建过程或辅助工具的变动。<br /></span><span class="ne-text">revert：回滚到上一个版本。<br /></span><span class="ne-text">merge：代码合并。<br /></span><span class="ne-text">sync：同步主线或分支的Bug。</span></p><p id="uf1d446b1" class="ne-p"><span class="ne-text"></span></p><h2 id="WSJ5U"><span class="ne-text">二、开发流程</span></h2><h3 id="qv5kn"><span class="ne-text">线上库命名</span></h3><p id="u3181e763" class="ne-p"><span class="ne-text">master：测试站的分支</span></p><p id="uc859c8ca" class="ne-p"><span class="ne-text">develop：开发站的分支</span></p><p id="uaca724de" class="ne-p"><span class="ne-text">release：部署到正式站的分支</span></p><h3 id="FDk4H"><span class="ne-text">SOP（开发流程）</span></h3><ul class="ne-ul"><li id="u18088f90"><span class="ne-text">在本地main主分支下创建新分支</span></li></ul><pre><code>git checkout -b &quot;dev/wzt-feat-newFeature&quot;</code></pre><ul class="ne-ul"><li id="u22dedb3c"><span class="ne-text">push即可</span></li></ul></div>]]></content>
      
      
      <categories>
          
          <category> 计算机素养 </category>
          
          <category> Git和GitHub </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>GitHub Pages相关使用</title>
      <link href="/blog/di1z9u/"/>
      <url>/blog/di1z9u/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="traditional"><p id="ufa614c25" class="ne-p"><br></p><div data-type="color1" class="ne-alert"><p id="e6f0dfb3669688e4d6e678b424581546" class="ne-p"><span class="ne-text">前言：GitHub Pages是GitHub软件的一个页面展示功能，它可以让展示用户的个人信息，也可以为你在GitHub上存放的一个项目定制一个介绍页面（纯静态网站）</span></p></div><p id="uc5db2a84" class="ne-p"><span class="ne-text"></span></p><div class="ne-quote"><p id="bc3b62e8d75db827d1d70e537e5dc8d9" class="ne-p"><span class="ne-text">官网地址：</span><a href="https://pages.github.com/" data-href="https://pages.github.com/" target="_blank" class="ne-link"><span class="ne-text">https://pages.github.com/</span></a></p></div><h2 id="9Fzdc"><span class="ne-text">xxxx.github.io仓库的创建</span></h2><p id="2407356f1975125a2e2b5283d83d0e5c" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616657760639-b6e36a91-6822-4ea2-9dc4-649ec5ef9768.png" width="946.5" id="uq7fd" class="ne-image"></p><p id="544e007406348ad8a78a58d848512e16" class="ne-p"><span class="ne-text">创建一个用户名.github.io的仓库，这个仓库的主分支下的静态网页就可以被访问到了，比如我创建的wztlink1013.github.io仓库，访问https://</span><span class="ne-text">wztlink1013.github.io就可以访问了。</span></p><div data-type="tips" class="ne-alert"><p id="30310b8dcf5bccddf7464c120ccb417a" class="ne-p"><span class="ne-text">需要注意的有：</span></p><ul class="ne-ul"><li id="f0d52154af71f87642d6892a795f6510"><span class="ne-text">仓库必须有index.html文件</span></li></ul></div><h2 id="FGUZN"><span class="ne-text">gh-pages分支的使用</span></h2><p id="7acd869e25b735376c28f9b9de705127" class="ne-p"><span class="ne-text">其他仓库（非</span><span class="ne-text">wztlink1013.github.io仓库</span><span class="ne-text">）下新建gh-pages分支，则gh-pages分支下的静态网页会被访问到，比如</span></p><p id="6391dbc377f75b6ebff10f9606c08cf5" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616658110985-fab12af6-362b-4fca-838c-78441e834197.png" width="945.5" id="GVSVP" class="ne-image"></p><h2 id="t2rYS"><span class="ne-text">私有仓库下的共有Pages</span></h2><div class="ne-quote"><p id="2ff5cde4f41fc3102197d60d810da784" class="ne-p"><span class="ne-text">Caution: This repository is private but the published site will be public.</span></p></div><p id="5321ec21aed43a849bbf3f7b3bd2f4ee" class="ne-p" style="text-align: left"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1605229290479-7c20a062-56f7-4f20-af37-b3354ca69daf.png" width="444" id="kY2We" class="ne-image"></p><div data-type="info" class="ne-alert"><p id="18cc8868f75eea8cccafb99312f3920b" class="ne-p" style="text-align: left"><span class="ne-text">简单解释一下就是，仓库虽然是私有的，但是gh-pages下的静态页面将会被公开。</span></p></div><h2 id="APzvq"><span class="ne-text">gh-pages分支下的静态css/js资源加载失败</span></h2><div data-type="danger" class="ne-alert"><p id="db3dcacfae54a3abb5fc50357b91494f" class="ne-p"><span class="ne-text">单个仓库下的gh-pages分支，可能导致静态网页css/js等文件加载不了，问题出在网站的css/js的引用方面上</span></p></div><div data-type="info" class="ne-alert"><p id="6b3fcbcd33adfedd6011d8e32850c38e" class="ne-p"><span class="ne-text">更改_yaml文件下的root的路径即可</span></p></div><p id="7d73561e25360191295833fc10874909" class="ne-p"><br></p><p id="2c6f7525a52c3cad853b4d908f64e5d3" class="ne-p"><strong><span class="ne-text">参考：</span></strong></p><ul class="ne-ul"><li id="d30c6b764a2914ffd6409a9c27e1bb8f"><a href="https://blog.csdn.net/simple_the_best/article/details/53403787" data-href="https://blog.csdn.net/simple_the_best/article/details/53403787" target="_blank" class="ne-link"><span class="ne-text">https://blog.csdn.net/simple_the_best/article/details/53403787</span></a></li></ul><h2 id="jQwdq"><span class="ne-text">使用issues搭建博客</span></h2><p id="35828e7be91d937fe56644e6dd47328e" class="ne-p"><span class="ne-text">这个就比较会玩了，将GitHub的API接口玩的溜溜的……</span><img src="https://cdn.nlark.com/yuque/0/2021/gif/1484158/1616657583331-5d034146-804a-44e8-a90e-994f86de946a.gif" width="90" id="NXawR" class="ne-image"></p><p id="474b5f0fec8432240646b6f1df1bed1c" class="ne-p"><span class="ne-text">先插个眼，日后技术学到家再来玩玩这个</span><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1616657633200-0f3a1324-21c2-4165-a23f-9a86ac69f399.jpeg" width="51" id="K09k5" class="ne-image"><strong><span class="ne-text"></span></strong></p><p id="5a0b721b44eef4bfb788a1d78bdbf9be" class="ne-p"><a href="https://github.com/Pines-Cheng/blog" data-href="https://github.com/Pines-Cheng/blog" target="_blank" class="ne-link"><span class="ne-text"><br /></span></a></p><p id="u456cc46d" class="ne-p"><br></p></div>]]></content>
      
      
      <categories>
          
          <category> 计算机素养 </category>
          
          <category> Git和GitHub </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>搭建Windows子系统Linux及其相关命令</title>
      <link href="/blog/xnh83z/"/>
      <url>/blog/xnh83z/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h2 id="UX4My"><span class="ne-text">Windows子系统Linux</span></h2><h3 id="XwO7W"><span class="ne-text">子系统Linux下载安装</span></h3><p id="4e3035feeb898199586aa056b29e015c" class="ne-p"><span class="ne-text">在windows里面搜索 </span><code class="ne-code"><span class="ne-text">windows功能</span></code><span class="ne-text"> </span></p><p id="5761e24c746bcd3e5d36e0c19ef1182d" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1604913834448-30d164c9-e0a6-47f8-baac-03c5d6648186.png" width="588" id="CJVjC" class="ne-image"></p><p id="6a72bcc62e58d8943fdbbcd32a7f095d" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1604913865729-b20b3a35-ab49-48c9-be97-9f3c56d6d7a6.png" width="311.5" id="HcgSp" class="ne-image"></p><p id="2a32bc760492c78ba1c3b3e58f7f548f" class="ne-p" style="text-align: left"><span class="ne-text">然后已知下一步操作即可，该过程中会有重启的过程。</span></p><p id="ced017f33454563c24be9f6992ba3b43" class="ne-p" style="text-align: left"><span class="ne-text">之后重启之后在应用商店下载Ubuntu系统，如下。</span></p><p id="15a884993b3a19476677fa3af2d9d2e6" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1604913776014-38c5ce17-996d-4827-8c49-bb047b2f7d3c.png" width="429" id="JGNy1" class="ne-image"></p><p id="b8fd1b4bafb7ec17e8995af2b306bd8d" class="ne-p"><span class="ne-text">然后启动的时候，会有让自己输入用户名和密码的情况。输入确认就好了（</span><strong><span class="ne-text">输入密码的时候，终端内不会显示光标以及输入的字符！但是会有密码验证</span></strong><span class="ne-text">）</span></p><p id="u577779aa" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1630977376308-3239ad06-8a3a-406a-8c0f-6ed478ce0c3b.png" width="720" id="u250e6022" class="ne-image"></p><h3 id="igB9b"><span class="ne-text">子系统Linux文件目录</span></h3><pre><code>C:\Users\wztli\AppData\Local\Packages\CanonicalGroupLimited.UbuntuonWindows_79rhkp1fndgsc\LocalState\rootfs\home\wztlink1013</code></pre><p id="e0a95afc1f4b23caefcfc2b984ae3b49" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1604914117863-4fc253c2-1978-44b1-94c6-48e82a3ddf3a.png" width="734" id="t36kI" class="ne-image"></p><p id="40049f7f41fc0cf107deaf3ec57ee67b" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1604914176405-056c5008-8168-40f8-a599-0e7951cad309.png" width="703" id="VZms0" class="ne-image"></p><h3 id="lDQPU"><span class="ne-text">Linux访问Windows文件</span></h3><p id="b3b2b35022c9ff4e6e66ecd67480ac21" class="ne-p"><span class="ne-text">如下图中1所示，访问时，需要先将Windows磁盘挂载到/mnt下面，然后就可以访问了。</span></p><ul class="ne-ul"><li id="u6d22e418"><span class="ne-text">ls命令：列举指定文件夹下的目录</span></li><li id="u2ae08792"><span class="ne-text">cd命令：在指定文件夹下运行该linux环境</span></li></ul><p id="c8d576d5ba7868e7073068d76e514e94" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1604914600884-f758bc8f-668d-4354-be9f-f9be774cfff1.png" width="561" id="HLsJa" class="ne-image"></p></div>]]></content>
      
      
      <categories>
          
          <category> 计算机素养 </category>
          
          <category> 环境搭建 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>一个梦——一切都太迟了</title>
      <link href="/essay/gx3g8t/"/>
      <url>/essay/gx3g8t/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="traditional"><p class="ne-p"><span class="ne-text">那天早上，老康起得很早，五点就起床了，说是要坐车去考教资，然后我突然迷迷糊糊被他起床的动静吵醒了，那天早上，我终于想起了什么…原来，黑魔法是存在的！！！</span></p><p class="ne-p"><br></p><p class="ne-p"><strong><span class="ne-text">和一批人上山</span></strong></p><p class="ne-p"><span class="ne-text">有好几伙人，同时登上山顶，像是被什么所指引那般，都像是阻止什么，又好像是为了得到什么……</span></p><p class="ne-p"><br></p><p class="ne-p"><br></p><p class="ne-p"><strong><span class="ne-text">我的境遇</span></strong></p><p class="ne-p"><span class="ne-text">山顶那个小栈好像是取某个物品，</span></p><p class="ne-p"><br></p><p class="ne-p"><span class="ne-text">夜晚某个时辰，周围突然陷入黑暗，所有人都匆匆忙忙跑下山，那个客栈里面，大量的黑烟逐渐弥漫开来，我们都内心里面清楚，太迟了，我们都太迟了！</span></p><p class="ne-p"><br></p><p class="ne-p"><span class="ne-text">我赶紧跑下山，摔到了一个村庄，然后一直跑，跑到我那个伙伴的家里，我看到了我那副眼镜，然后一直跑，跑回我自己的地方了</span></p></div>]]></content>
      
      
      <categories>
          
          <category> 异世界 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>uni-app实现一套代码多端使用</title>
      <link href="/blog/ytoag7/"/>
      <url>/blog/ytoag7/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="uf79f4f49" class="ne-p"><span class="ne-text">前言：本文是大三web技术课程中使用的uni-app技术的学习记录，uni-app实现一套代码多端使用。代码多和vue类似，但是有一些变动，本文内容部分继承自 </span><a href="https://ask.dcloud.net.cn/article/35657" data-href="https://ask.dcloud.net.cn/article/35657" target="_blank" class="ne-link"><span class="ne-text">白话uni-app </span></a><span class="ne-text"> 做出二次修改与记录。</span></p><p id="u275ed4ff" class="ne-p"><span class="ne-text"></span></p><ul class="ne-ul"><li id="u0c347a75"><span class="ne-text">课程大作业：</span><a href="https://github.com/wztlink1013/uniapp-harrypotter-visualize" data-href="https://github.com/wztlink1013/uniapp-harrypotter-visualize" target="_blank" class="ne-link"><span class="ne-text">https://github.com/wztlink1013/uniapp-harrypotter-visualize</span></a></li></ul><h2 id="Mccdr"><span class="ne-text">uni-app相对传统web的变化</span></h2><p id="u69f0996a" class="ne-p"><span class="ne-text">代码结构上继承vue的 </span><a href="https://cn.vuejs.org/v2/guide/single-file-components.html" data-href="https://cn.vuejs.org/v2/guide/single-file-components.html" target="_blank" class="ne-link"><span class="ne-text">Vue 单文件组件</span></a><span class="ne-text"> ，连文件后缀也都是</span><code class="ne-code"><span class="ne-text">.vue</span></code><span class="ne-text">，都是将vue文件编译成js文件，但是uni-app在此基础上还做了HTML上标签的变动以及移动端标签的增加，具体如下：</span></p><h3 id="HlgtE"><span class="ne-text">标签上的变化</span></h3><p id="3a207791db86c2086991f5cd57eebbe3" class="ne-p"><span class="ne-text">下为html标签和uni-app内置组件的映射表：</span></p><p id="632cb615a76108baf949c94c9af7eefa" class="ne-p"><span class="ne-text">（其实老的HTML标签也可以在uni-app里使用，uni-app编译器会在编译时把老标签转为新标签，比如把div编译成view。但不推荐这种用法，调试H5端时容易混乱。）</span></p><ul class="ne-ul"><li id="4e255ed4753d8fbf252b643167f65f1b"><span class="ne-text">div 改成 </span><a href="https://uniapp.dcloud.io/component/view" data-href="https://uniapp.dcloud.io/component/view" target="_blank" class="ne-link"><span class="ne-text">view</span></a></li><li id="24409615974d7473d6ac953aca34c2a7"><span class="ne-text">span、font 改成 </span><a href="https://uniapp.dcloud.io/component/text" data-href="https://uniapp.dcloud.io/component/text" target="_blank" class="ne-link"><span class="ne-text">text</span></a></li><li id="aed2e12170278288ede1ba61bdd062e9"><span class="ne-text">a 改成 </span><a href="https://uniapp.dcloud.io/component/navigator" data-href="https://uniapp.dcloud.io/component/navigator" target="_blank" class="ne-link"><span class="ne-text">navigator</span></a></li><li id="5da7ace80da533ed5de82da531ff0c9f"><span class="ne-text">img 改成 </span><a href="https://uniapp.dcloud.io/component/image" data-href="https://uniapp.dcloud.io/component/image" target="_blank" class="ne-link"><span class="ne-text">image</span></a></li><li id="bfa4385359d666425f13bb5cfdb7d32d"><a href="https://uniapp.dcloud.io/component/input" data-href="https://uniapp.dcloud.io/component/input" target="_blank" class="ne-link"><span class="ne-text">input</span></a><span class="ne-text"> 还在，但type属性改成了confirmtype</span></li><li id="a1160e6db31323e6661ccf094a56a478"><a href="https://uniapp.dcloud.io/component/form" data-href="https://uniapp.dcloud.io/component/form" target="_blank" class="ne-link"><span class="ne-text">form</span></a><span class="ne-text">、</span><a href="https://uniapp.dcloud.io/component/button" data-href="https://uniapp.dcloud.io/component/button" target="_blank" class="ne-link"><span class="ne-text">button</span></a><span class="ne-text">、</span><a href="https://uniapp.dcloud.io/component/checkbox" data-href="https://uniapp.dcloud.io/component/checkbox" target="_blank" class="ne-link"><span class="ne-text">checkbox</span></a><span class="ne-text">、</span><a href="https://uniapp.dcloud.io/component/radio" data-href="https://uniapp.dcloud.io/component/radio" target="_blank" class="ne-link"><span class="ne-text">radio</span></a><span class="ne-text">、</span><a href="https://uniapp.dcloud.io/component/label" data-href="https://uniapp.dcloud.io/component/label" target="_blank" class="ne-link"><span class="ne-text">label</span></a><span class="ne-text">、</span><a href="https://uniapp.dcloud.io/component/textarea" data-href="https://uniapp.dcloud.io/component/textarea" target="_blank" class="ne-link"><span class="ne-text">textarea</span></a><span class="ne-text">、</span><a href="https://uniapp.dcloud.io/component/canvas" data-href="https://uniapp.dcloud.io/component/canvas" target="_blank" class="ne-link"><span class="ne-text">canvas</span></a><span class="ne-text">、</span><a href="https://uniapp.dcloud.io/component/video" data-href="https://uniapp.dcloud.io/component/video" target="_blank" class="ne-link"><span class="ne-text">video</span></a><span class="ne-text"> 这些还在。</span></li><li id="bd7ad6f991ca58f5f706aff94e2dedf8"><span class="ne-text">select 改成 </span><a href="https://uniapp.dcloud.io/component/picker" data-href="https://uniapp.dcloud.io/component/picker" target="_blank" class="ne-link"><span class="ne-text">picker</span></a></li><li id="9cc82dc3f7dc7254643314418fcf795e"><span class="ne-text">iframe 改成 </span><a href="https://uniapp.dcloud.io/component/web-view" data-href="https://uniapp.dcloud.io/component/web-view" target="_blank" class="ne-link"><span class="ne-text">web-view</span></a></li><li id="01fff985aaa0340be3a027b5e2016ad8"><span class="ne-text">ul、li没有了，都用view替代</span></li><li id="d7bc5fd904fb0dadea5bafe2db17d6ac"><span class="ne-text">audio 不再推荐使用，改成api方式，</span><a href="https://uniapp.dcloud.io/api/media/background-audio-manager?id=getbackgroundaudiomanager" data-href="https://uniapp.dcloud.io/api/media/background-audio-manager?id=getbackgroundaudiomanager" target="_blank" class="ne-link"><span class="ne-text">背景音频api文档</span></a></li></ul><h3 id="RmiNR"><span class="ne-text">组件上的增加</span></h3><p id="u61f14a3a" class="ne-p"><span class="ne-text">除了上述html标签改动外，新增了一批手机端常用的新组件</span></p><ul class="ne-ul"><li id="e87028913fffc43b8fbd1b093d0c89bd"><span class="ne-text">scroll-view </span><a href="https://uniapp.dcloud.io/component/scroll-view" data-href="https://uniapp.dcloud.io/component/scroll-view" target="_blank" class="ne-link"><span class="ne-text">可区域滚动视图容器</span></a></li><li id="2ee2254baacc1c9a9b9dfe8409990592"><span class="ne-text">swiper </span><a href="https://uniapp.dcloud.io/component/swiper" data-href="https://uniapp.dcloud.io/component/swiper" target="_blank" class="ne-link"><span class="ne-text">可滑动区域视图容器</span></a></li><li id="59baaf5b3da38aea050c43584321e50c"><span class="ne-text">icon </span><a href="https://uniapp.dcloud.io/component/icon" data-href="https://uniapp.dcloud.io/component/icon" target="_blank" class="ne-link"><span class="ne-text">图标</span></a></li><li id="45b709aa13192ccfbd0f45e19d4bd93a"><span class="ne-text">rich-text </span><a href="https://uniapp.dcloud.io/component/rich-text" data-href="https://uniapp.dcloud.io/component/rich-text" target="_blank" class="ne-link"><span class="ne-text">富文本（不可执行js，但可渲染各种文字格式和图片）</span></a></li><li id="601dfac3262ef5d1e07dde1ddf1085ca"><span class="ne-text">progress </span><a href="https://uniapp.dcloud.io/component/progress" data-href="https://uniapp.dcloud.io/component/progress" target="_blank" class="ne-link"><span class="ne-text">进度条</span></a></li><li id="96914b255c8c1c5025228991554561da"><span class="ne-text">slider </span><a href="https://uniapp.dcloud.io/component/slider" data-href="https://uniapp.dcloud.io/component/slider" target="_blank" class="ne-link"><span class="ne-text">滑块指示器</span></a></li><li id="d47efbdb64345227dec5f582c298da55"><span class="ne-text">switch </span><a href="https://uniapp.dcloud.io/component/switch" data-href="https://uniapp.dcloud.io/component/switch" target="_blank" class="ne-link"><span class="ne-text">开关选择器</span></a></li><li id="6bdf801a7c402d35e3bfca4b9b085efb"><span class="ne-text">camera </span><a href="https://uniapp.dcloud.io/component/camera" data-href="https://uniapp.dcloud.io/component/camera" target="_blank" class="ne-link"><span class="ne-text">相机</span></a></li><li id="59f95112502b75095d91e671e97acb4a"><span class="ne-text">live-player </span><a href="https://uniapp.dcloud.io/component/live-player" data-href="https://uniapp.dcloud.io/component/live-player" target="_blank" class="ne-link"><span class="ne-text">直播</span></a></li><li id="2f6b7fb99bf9fef8babf652765b3c625"><span class="ne-text">map </span><a href="https://uniapp.dcloud.io/component/map" data-href="https://uniapp.dcloud.io/component/map" target="_blank" class="ne-link"><span class="ne-text">地图</span></a></li><li id="cb05de41bb30535b85cfaa1e9d1c1d3d"><span class="ne-text">cover-view </span><a href="https://uniapp.dcloud.io/component/cover-view?id=cover-view" data-href="https://uniapp.dcloud.io/component/cover-view?id=cover-view" target="_blank" class="ne-link"><span class="ne-text">可覆盖原生组件的视图容器</span></a><span class="ne-text"> <br /></span><span class="ne-text">cover-view需要多强调几句，uni-app的非h5端的video、map、canvas、textarea是原生组件，层级高于其他组件。如需覆盖原生组件，则需要使用cover-view组件。详见</span><a href="https://uniapp.dcloud.net.cn/component/native-component" data-href="https://uniapp.dcloud.net.cn/component/native-component" target="_blank" class="ne-link"><span class="ne-text">层级介绍</span></a></li></ul><hr id="lqUAg" class="ne-hr"><p id="5bbeba8f366e6d98e1225bc30528dfdb" class="ne-p"><span class="ne-text">除了内置组件，还有很多开源的扩展组件，把常用操作都进行封装，DCloud建立了插件市场收录这些扩展组件，详见</span><a href="https://ext.dcloud.net.cn/" data-href="https://ext.dcloud.net.cn/" target="_blank" class="ne-link"><span class="ne-text">插件市场</span></a><span class="ne-text">。</span></p><h3 id="WAbDY"><span class="ne-text">工程结构和页面管理</span></h3><p id="ca51688a7f2333de0f6af8af2b824520" class="ne-p"><span class="ne-text">uni-app的工程结构有单独的要求，</span><a href="https://uniapp.dcloud.io/frame?id=%e7%9b%ae%e5%bd%95%e7%bb%93%e6%9e%84" data-href="https://uniapp.dcloud.io/frame?id=%e7%9b%ae%e5%bd%95%e7%bb%93%e6%9e%84" target="_blank" class="ne-link"><span class="ne-text">详见</span></a></p><p id="97cbbfefc56ed306276570ed088e7782" class="ne-p"><br></p><p id="64f439da9672f579681ec2e5eb5202e1" class="ne-p"><span class="ne-text">每个可显示的页面，都必须在 </span><a href="https://uniapp.dcloud.io/collocation/pages" data-href="https://uniapp.dcloud.io/collocation/pages" target="_blank" class="ne-link"><span class="ne-text">pages.json</span></a><span class="ne-text"> 中注册。如果你开发过小程序，那么pages.json类似app.json。如果你熟悉vue，这里没有vue的路由，都是在pages.json里管理。</span></p><p id="66a228827511e0ec374498be516de0e1" class="ne-p"><br></p><p id="74cce9d094f35fb68a981a712a407a49" class="ne-p"><span class="ne-text">原来工程的首页一般是index.html或default.html，是在web server里配的。而uni-app的首页，是在pages.json里配的，page节点下第一个页面就是首页。一般在/pages/xx的目录下。</span></p><p id="cb34a01c22f471615ff8401d995599e7" class="ne-p"><br></p><p id="571a4cad666921419fbf536155daa95f" class="ne-p"><span class="ne-text">app和小程序中，为了提升体验，页面提供了原生的导航栏和底部tabbar，注意这些配置是在pages.json中做，而不是在vue页面里创建，但点击事件的监听在显示的vue页面中做。</span></p><p id="38afb0fdf574c0ca8d62b5d749ff85b6" class="ne-p"><br></p><p id="d351237eccf285ccc5ed8f7193d00697" class="ne-p"><span class="ne-text">如果你熟悉小程序开发的话，对比变化如下：</span></p><ul class="ne-ul"><li id="f587ced0e0e1f88c0cdafb49730028ae"><span class="ne-text">原来app.json被一拆为二。页面管理，被挪入了uni-app的pages.json；非页面管理，挪入了manifest.json</span></li><li id="552eeda22b7a35141566e09fcf34e86e"><span class="ne-text">原来的app.js和app.wxss被合并到了app.vue中</span></li></ul><h2 id="QSNTK"><span class="ne-text">文件导入方式变化</span></h2><h3 id="d11or"><span class="ne-text">js引入方式</span></h3><p id="727be6b205b2dd52ff98ba32d4019414" class="ne-p"><span class="ne-text">以前通过</span><code class="ne-code"><span class="ne-text">script </span></code><code class="ne-code"><span class="ne-text">src</span></code><span class="ne-text">、</span><code class="ne-code"><span class="ne-text">link </span></code><code class="ne-code"><span class="ne-text">href</span></code><span class="ne-text">引入外部的js和css；</span></p><p id="d8e08a9e55c321dd0b2bf76aa9bad3ce" class="ne-p"><span class="ne-text">现在是</span><strong><span class="ne-text">es6</span></strong><span class="ne-text">的写法，</span><code class="ne-code"><span class="ne-text">import</span></code><span class="ne-text">引入外部的js模块(注意不是文件)或css</span></p><ul class="ne-ul"><li id="u3f44eddb"><span class="ne-text">以前</span></li></ul><pre><code>&lt;script src=&quot;js/jquery-1.10.2.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;  &lt;link href=&quot;css/bootstrap.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot;/&gt;</code></pre><ul class="ne-ul"><li id="ubc70e53e"><span class="ne-text">现在 js要require进来，变成了对象。</span></li></ul><p id="dab91d38ea911e4d17e5bc4d2c5218bb" class="ne-p"><span class="ne-text">在hello uni-app项目的common目录有一个工具类</span><code class="ne-code"><span class="ne-text">util.js</span></code><span class="ne-text">，可以在hello uni-app中搜索这个例子查看。</span></p><pre><code>&lt;script&gt;  var util = require('../../../common/util.js');  //require这个js模块  var formatedPlayTime = util.formatTime(playTime); //调用js模块的方法  &lt;/script&gt;</code></pre><p id="aa83aeddd4d086d2fb198078cee14f60" class="ne-p"><span class="ne-text">而在这个</span><code class="ne-code"><span class="ne-text">util.js</span></code><span class="ne-text">里，要把之前的function封装为对象的方法</span></p><p id="21d9e2e89f696d89c68fc2aaa6373473" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1604048264989-b4591bb0-e4bc-4581-aae5-bf7615f268b4.png" width="508" id="wkQ3w" class="ne-image"></p><pre><code>var dateUtils = require('../../../common/util.js').dateUtils; //直接使用js模块的属性。在hello uni-app有示例  import * as echarts from '/components/echarts/echarts.simple.min.js'; //将js导入并重命名为echarts，然后使用echarts.来继续执行方法。</code></pre><h3 id="72581a45"><span class="ne-text">CSS引入方式</span></h3><pre><code>&lt;style&gt;      @import &quot;./common/uni.css&quot;;      .uni-hello-text&#123;          color:#7A7E83;      &#125;  &lt;/style&gt;</code></pre><p id="f25884384b253fed473bd0514a0bf3c9" class="ne-p"><strong><span class="ne-text">改全局样式：</span></strong><span class="ne-text">在根目录下的app.vue里写入，每个页面都会加载app.vue里的样式。</span></p><h3 id="0WsT0"><span class="ne-text">组件导入</span></h3><p id="3bd6451b4bff23deea29d99719401c43" class="ne-p"><span class="ne-text">类似hexo博客主题设计一样，能以组件的形式模块化导入。</span></p><p id="31e6ffa0a70c54a96c1c76b3efd249bb" class="ne-p"><span class="ne-text">如下是导入一个角标的组件库，在页面上显示一个abc并且右上角有个数字角标1，</span><a href="http://ext.dcloud.net.cn/plugin?id=21" data-href="http://ext.dcloud.net.cn/plugin?id=21" target="_blank" class="ne-link"><span class="ne-text">详见</span></a></p><pre><code>&lt;template&gt;      &lt;view&gt;          &lt;uni-badge text=&quot;abc&quot; :inverted=&quot;true&quot;&gt;&lt;/uni-badge&gt;&lt;!--3.使用组件--&gt;      &lt;/view&gt;  &lt;/template&gt;  &lt;script&gt;      import uniBadge from &quot;../../../components/uni-badge.vue&quot;;//1.导入组件（这步属于传统vue规范，但在uni-app的easycom下可以省略这步）      export default &#123;          data() &#123;              return &#123;              &#125;          &#125;,          components: &#123;              uniBadge //2.注册组件（这步属于传统vue规范，但在uni-app的easycom下可以省略这步）          &#125;      &#125;  &lt;/script&gt;</code></pre><p id="fdc34858dcff96b87f6e1cf2c9d745fc" class="ne-p"><span class="ne-text">如需要全局导入vue组件，即每个页面都可以直接使用而不用引用和注册的话，在项目根目录下的main.js里处理。如下是hello uni-app里的例子。</span></p><pre><code>//main.js  import pageHead from './components/page-head.vue' //导入  Vue.component('page-head', pageHead) //注册。注册后在每个vue的page页面里可以直接使用&lt;page-head&gt;&lt;/page-head&gt;组件。</code></pre><p id="758d2e3e83f6519710750264cacbf690" class="ne-p"><span class="ne-text">上述的组件使用方式属于传统vue的概念。uni-app 2.7以后推出了更简单的组件使用技术</span><a href="https://uniapp.dcloud.net.cn/collocation/pages?id=easycom" data-href="https://uniapp.dcloud.net.cn/collocation/pages?id=easycom" target="_blank" class="ne-link"><span class="ne-text">easycom</span></a><span class="ne-text">，无需引用和注册组件，直接在template区域使用组件即可。</span></p><p id="b7443f7afae36687f40ef92e4cf4ea11" class="ne-p"><br></p><h2 id="72505980"><span class="ne-text">js的变化</span></h2><p id="61d502f5529ded98c379a721660f839b" class="ne-p"><span class="ne-text">js的变化，分为</span><strong><span class="ne-text">运行环境变化</span></strong><span class="ne-text">、</span><strong><span class="ne-text">数据绑定模式变化</span></strong><span class="ne-text">、</span><strong><span class="ne-text">api变化</span></strong><span class="ne-text">3部分。</span></p><h3 id="vNdy9"><span class="ne-text">运行环境从浏览器变成v8引擎</span></h3><p id="d27940c658c8e04b1e38b28dd72f9dd4" class="ne-p"><span class="ne-text">标准js语法和api都支持，比如if、for、settimeout、indexOf等。</span></p><p id="f7409cc3b0a94b2da6a5701d47de7f18" class="ne-p"><br></p><p id="53640e60cb3f0408c83c1ce0604faa4b" class="ne-p"><span class="ne-text">但</span><strong><span class="ne-text">浏览器专用的</span></strong><span class="ne-text">window、document、navigator、location对象，包括cookie等存储，</span><strong><span class="ne-text">只有在浏览器中才有</span></strong><span class="ne-text">，app和小程序都不支持。</span></p><p id="b3758dc607e5b8c63fb1bb9d4f411f63" class="ne-p"><br></p><div class="ne-quote"><p id="f5a153969de7c094fb6c2cb34c8246bc" class="ne-p"><span class="ne-text">可能有些人以为js等于浏览器里的js。其实js是ECMAScript组织管理的，浏览器中的js是w3c组织基于js规范补充了window、document、navigator、location等专用对象。</span></p></div><p id="c6566e32ff4d4451f3b14b4f94753bf6" class="ne-p"><span class="ne-text">在uni-app的各个端中，除了h5端，其他端的js都运行在一个独立的v8引擎下，不是在浏览器中，所以浏览器的对象无法使用。如果你做过小程序开发，对此应当很了解。</span></p><p id="2132ef2d9349284fac839a33b387b7d2" class="ne-p"><strong><span class="ne-text">这意味着依赖document的很多HTML的库，比如jqurey无法使用。</span></strong></p><p id="be8fb78e319a400ad87d2e93c547dce6" class="ne-p"><span class="ne-text">当然app和小程序支持web-view组件，里面可以加载标准HTML，这种页面仍然支持浏览器专用对象window、document、navigator、location。</span></p><h3 id="04kae"><span class="ne-text">以前的dom操作，改成vue的MVVM模式</span></h3><p id="c3f9b571fdd117cf94df539bc44d0f5a" class="ne-p"><span class="ne-text">现在前端趋势是去dom化，改用</span><strong><span class="ne-text">mvvm模式，</span></strong><span class="ne-text">更简洁的写法，大幅减少代码行数，同时差量渲染性能更好。</span></p><p id="0e876d2cadaed7ebe773db01b197dcd8" class="ne-p"><span class="ne-text">uni-app使用vue的数据绑定方式解决js和dom界面交互的问题。</span></p><p id="d829eda9aa22a42e4cb1d7bea07ed0e2" class="ne-p"><span class="ne-text">如果你想改变某个dom元素的显示内容，比如一个view的显示文字：</span></p><p id="0c5d88300f29c716b63f06777891275b" class="ne-p"><strong><span class="ne-text">以前</span></strong><span class="ne-text">是</span><span class="ne-text" style="text-decoration: underline">给view设id，然后js里通过选择器获取dom元素，进一步通过js进行赋值操作，修改dom元素的属性或值。</span></p><p id="2e023ff3890e11eef3fc3ae164bfbdfd" class="ne-p"><span class="ne-text">如下演示了一段代码，页面中有个显示的文字区和一个按钮，点击按钮后会修改文字区的值</span></p><pre><code>&lt;html&gt;      &lt;head&gt;          &lt;script type=&quot;text/javascript&quot;&gt;              document.addEventListener(&quot;DOMContentLoaded&quot;,function () &#123;                  document.getElementById(&quot;spana&quot;).innerText=&quot;456&quot;              &#125;)              function changetextvalue () &#123;                  document.getElementById(&quot;spana&quot;).innerText=&quot;789&quot;              &#125;          &lt;/script&gt;      &lt;/head&gt;      &lt;body&gt;          &lt;span id=&quot;spana&quot;&gt;123&lt;/span&gt;          &lt;button type=&quot;button&quot; onclick=&quot;changetextvalue()&quot;&gt;修改为789&lt;/button&gt;      &lt;/body&gt;  &lt;/html&gt;</code></pre><p id="6e0731a9482a90ca8cfd543cac0f5a5d" class="ne-p"><span class="ne-text">现在的做法，是</span><strong><span class="ne-text">vue的绑定模式</span></strong><span class="ne-text">，给这个</span><strong><span class="ne-text">dom元素绑定一个js变量</span></strong><span class="ne-text">，在script中修改js变量的值，dom会自动变化，页面会自动更新渲染</span></p><pre><code>&lt;template&gt;      &lt;view&gt;          &lt;text&gt;&#123;&#123;textvalue&#125;&#125;&lt;/text&gt;&lt;!-- 这里演示了组件值的绑定 --&gt;          &lt;button :type=&quot;buttontype&quot; @click=&quot;changetextvalue()&quot;&gt;修改为789&lt;/button&gt;&lt;!-- 这里演示了属性和事件的绑定 --&gt;      &lt;/view&gt;  &lt;/template&gt;  &lt;script&gt;      export default &#123;          data() &#123;              return &#123;                  textvalue:&quot;123&quot;,                  buttontype:&quot;primary&quot;              &#125;;          &#125;,          onLoad() &#123;              this.textvalue=&quot;456&quot;//这里修改textvalue的值，其实123都来不及显示就变成了456          &#125;,          methods: &#123;              changetextvalue() &#123;                  this.textvalue=&quot;789&quot;//这里修改textvalue的值，页面自动刷新为789              &#125;          &#125;      &#125;  &lt;/script&gt;</code></pre><p id="bc368c6ca5fe6f2050365c1ca6c94b50" class="ne-p"><span class="ne-text">注意上述代码中的 </span><code class="ne-code"><span class="ne-text">export default &#123;&#125;</span></code><span class="ne-text"> 里的 </span><code class="ne-code"><span class="ne-text">data(): &#123;return &#123; &#125;&#125;</span></code><span class="ne-text">。</span></p><p id="759ea192959475f38176b131034c1804" class="ne-p"><span class="ne-text">在vue的设计中，这里存放着页面中需要绑定的数据，写在data里，才能被界面正确的绑定和渲染。</span></p><p id="00dd11445938bf5ebda6b987b37578ab" class="ne-p"><span class="ne-text">注意：uni-app的vue页面是vue的单文件组件规范，按照vue的定义只接受 function，必须用 return 包起来。</span></p><p id="417ce279021fdf8ddf1a14640853b25c" class="ne-p"><span class="ne-text">如果你学过小程序的数据绑定，但不了解vue，要注意：</span></p><ul class="ne-ul"><li id="929bdf76b10333306717a395b4a75fa9"><span class="ne-text">小程序的数据绑定参考了vue，但自己修改了一些。在uni-app中只支持标准的vue，不支持小程序的数据绑定语法</span></li><li id="52b04def02fc0f6d1e3f7140967aab91"><span class="ne-text">小程序里的setData在uni-app里并不存在，因为vue是自动双向数据绑定的。直接通过赋值方式修改数据，如果数据绑定到界面上，界面会自动更新渲染</span></li></ul><p id="1dd93bf69cfe5d627fa00d8d4a8b39f6" class="ne-p"><span class="ne-text">从上述示例，还可看出事件的写法变化。</span></p><ul class="ne-ul"><li id="44aa4a140ad05a32b9cec86fd5852be7"><span class="ne-text">以前，元素的事件是用onxxx=&quot;&quot;，里面写一段js或引用function的name，比如上述代码中的</span><code class="ne-code"><span class="ne-text">onclick=&quot;changetextvalue()&quot;</span></code></li><li id="41867f53cd0d583070e864f28ef3d037"><span class="ne-text">现在，需要在js的</span><code class="ne-code"><span class="ne-text">export default &#123;&#125;</span></code><span class="ne-text"> 里的 </span><code class="ne-code"><span class="ne-text">methods: &#123;&#125;</span></code><span class="ne-text"> 里写一个方法，然后在组件中使用</span><code class="ne-code"><span class="ne-text">@click=&quot;changetextvalue()&quot;</span></code></li></ul><p id="18e52674a48b83551b618a7df7f6b177" class="ne-p"><span class="ne-text">在js中，与data和methods平级的，如上述示例代码中的</span><code class="ne-code"><span class="ne-text">onload()</span></code><span class="ne-text">，称为生命周期。在普通vue页面里的生命周期叫页面生命周期。在项目根目录的app.vue文件中的生命周期叫应用生命周期。</span></p><p id="319355b017d6c9bc7d7c2ab484dc551d" class="ne-p"><span class="ne-text">除了</span><code class="ne-code"><span class="ne-text">onload</span></code><span class="ne-text">，还有</span><code class="ne-code"><span class="ne-text">onready</span></code><span class="ne-text">等很多生命周期，具体见</span><a href="https://uniapp.dcloud.io/collocation/frame/lifecycle" data-href="https://uniapp.dcloud.io/collocation/frame/lifecycle" target="_blank" class="ne-link"><span class="ne-text">uni-app的生命周期</span></a></p><p id="8cb769a80e78d931024ec7839dbe5131" class="ne-p"><span class="ne-text">在高级用法里，</span><strong><span class="ne-text">vue支持给组件设ref（引用标记）</span></strong><span class="ne-text">，这类似于之前html中给一个dom元素设id，然后在js中也可以用</span><code class="ne-code"><span class="ne-text">this.$refs.xxx</span></code><span class="ne-text">来获取。如下：</span></p><pre><code>&lt;template&gt;    &lt;view&gt;      &lt;view ref=&quot;testview&quot;&gt;11111&lt;/view&gt;      &lt;button @click=&quot;getTest&quot;&gt;获取test节点&lt;/button&gt;    &lt;/view&gt;  &lt;/template&gt;  &lt;script&gt;  export default &#123;    methods: &#123;      getTest() &#123;        console.log(this.$refs.testview)      &#125;    &#125;  &#125;;  &lt;/script&gt;</code></pre><h3 id="idCpM"><span class="ne-text">js api的变化</span></h3><p id="1346ad461c78f72851d48b28cd0a04de" class="ne-p"><span class="ne-text">因为uni-app的api是</span><strong><span class="ne-text">参考小程序</span></strong><span class="ne-text">的，所以</span><strong><span class="ne-text">和浏览器的js api</span></strong><span class="ne-text">有很多不同，如</span></p><ol class="ne-ol"><li id="1a12d133b7d0017d5f9f9cbc79f49654"><span class="ne-text">alert,confirm 改成 </span><a href="https://uniapp.dcloud.io/api/ui/prompt?id=showmodal" data-href="https://uniapp.dcloud.io/api/ui/prompt?id=showmodal" target="_blank" class="ne-link"><span class="ne-text">uni.showmodel</span></a></li><li id="00389029828cdf1d3e9ee97783342e14"><span class="ne-text">ajax 改成 </span><a href="https://uniapp.dcloud.io/api/request/request" data-href="https://uniapp.dcloud.io/api/request/request" target="_blank" class="ne-link"><span class="ne-text">uni.request</span></a></li><li id="7716c7c0e7a527c6882fc62a1a1774e4"><span class="ne-text">cookie、session 没有了，local.storage 改成 </span><a href="https://uniapp.dcloud.io/api/storage/storage?id=setstorage" data-href="https://uniapp.dcloud.io/api/storage/storage?id=setstorage" target="_blank" class="ne-link"><span class="ne-text">uni.storage</span></a></li></ol><p id="3fa69db8130011eb01a2a82448359762" class="ne-p"><span class="ne-text">uni-app的js api还有很多，但基本就是小程序的api，把wx.xxx改为uni.xxx即可。</span><a href="https://uniapp.dcloud.io/api/README" data-href="https://uniapp.dcloud.io/api/README" target="_blank" class="ne-link"><span class="ne-text">详见</span></a></p><p id="2acdbf6612454e9d34d591577351d275" class="ne-p"><span class="ne-text">uni-app在不同的端，支持条件编译，无限制的使用各端独有的api，</span><a href="https://uniapp.dcloud.io/platform" data-href="https://uniapp.dcloud.io/platform" target="_blank" class="ne-link"><span class="ne-text">详见条件编译</span></a></p><p id="9dc2e2b51cdc23e965e30caef7c0a9c8" class="ne-p"><br></p><h2 id="61f2d4d5"><span class="ne-text">css的变化</span></h2><p id="4595b3949443db62e1fa2a13906f83c9" class="ne-p"><strong><span class="ne-text">标准的css基本都是支持的。</span></strong></p><h3 id="lfkJR"><span class="ne-text">选择器方面</span></h3><div class="ne-quote"><p id="bc0842daf7756f35541ac204b3449f8e" class="ne-p"><span class="ne-text">有2个变化：</span></p></div><ol class="ne-ol"><li id="f935ec358a77e119b405f3a2af015580"><span class="ne-text">*选择器不支持；</span></li><li id="c3504e842b2d83c37b53e0faf325053f"><span class="ne-text">元素选择器里没有body，改为了page。微信小程序即是如此。</span></li></ol><pre><code>page&#123;  &#125;</code></pre><ul class="ne-ul"><li id="d839e1a36d35735a80f49e1cd5f6d213"><strong><span class="ne-text">单位方面：</span></strong><span class="ne-text">px无法动态适应不同宽度的屏幕，rem无法用于nvue/weex。如果想使用根据屏幕宽度自适应的单位，推荐使用rpx，全端支持。 </span><a href="https://uniapp.dcloud.io/frame?id=%e5%b0%ba%e5%af%b8%e5%8d%95%e4%bd%8d" data-href="https://uniapp.dcloud.io/frame?id=%e5%b0%ba%e5%af%b8%e5%8d%95%e4%bd%8d" target="_blank" class="ne-link"><span class="ne-text">尺寸单位文档</span></a></li><li id="724ea670a147ba2bf3236d8670b2464a"><strong><span class="ne-text">布局方面：</span></strong><span class="ne-text">uni-app推荐使用flex布局，这个布局思路和传统流式布局有点区别。但flex的特色在于，不管是什么技术都支持这种排版，web、小程序/快应用、weex/rn、原生的iOS、Android开发，全都支持flex。它是通吃所有端的新一代布局方案。相关教程请自行百度学习。</span></li></ul><h3 id="wIidY"><span class="ne-text">flex</span></h3><p id="c33ad76392bd8d676d2e1dc676c2676f" class="ne-p"><span class="ne-text">uni-app的vue文件里支持所有web排版方式，不管是流式还是flex。但nvue里，只支持flex，因为它在app端是使用原生排版引擎渲染的。</span></p><p id="6863d421ba7589a46b08bf2e1aad31c7" class="ne-p"><strong><span class="ne-text">注意css里背景图和字体文件，尽量不要大于40k，因为会影响性能。在小程序端，如果要大于40k，需放到服务器侧远程引用或base64后引入，不能放到本地作为独立文件引用。</span></strong></p><h2 id="7zUoo"><span class="ne-text">参考资料</span></h2><ul class="ne-ul"><li id="7675e633752c3528a0c07510e6739b8a"><a href="https://uniapp.dcloud.net.cn/" data-href="https://uniapp.dcloud.net.cn/" target="_blank" class="ne-link"><span class="ne-text">https://uniapp.dcloud.net.cn/</span></a></li><li id="9e83bf2b1195a1d5c3d28c534686e7a1"><a href="https://cn.vuejs.org/index.html" data-href="https://cn.vuejs.org/index.html" target="_blank" class="ne-link"><span class="ne-text">https://cn.vuejs.org/index.html</span></a></li><li id="3955ce6848c09d752bea9078f714ef0f"><span class="ne-text">官方教程：</span><a href="https://ke.qq.com/course/343370" data-href="https://ke.qq.com/course/343370" target="_blank" class="ne-link"><span class="ne-text">uni-app跨平台框架官方教程</span></a></li><li id="985d82d6017ab65b2945babdad6ea901"><a href="https://ask.dcloud.net.cn/article/35657" data-href="https://ask.dcloud.net.cn/article/35657" target="_blank" class="ne-link"><span class="ne-text">白话uni-app </span></a></li><li id="e196c8a3b3fba790d9311e27e46ace8a"><span class="ne-text">微信官方文档：</span><a href="https://developers.weixin.qq.com/doc/" data-href="https://developers.weixin.qq.com/doc/" target="_blank" class="ne-link"><span class="ne-text">https://developers.weixin.qq.com/doc/</span></a></li></ul></div>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
          <category> 前端业务解决方案 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Android平台与开发技术</title>
      <link href="/blog/im0an1/"/>
      <url>/blog/im0an1/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h2 id="wFtgu"><span class="ne-text">一、目的</span></h2><p id="a430fa648a590878705a06f4b4e672c2" class="ne-p"><span class="ne-text">大学期间，有没有能够</span><strong><span class="ne-text">有专业能力的项目实战</span></strong><span class="ne-text">。希望在你的将来的简历中加入技术方面的项目介绍。</span></p><h2 id="1WhOi"><span class="ne-text">二、考核方式</span></h2><p id="9044483781dc5c603eb8fbbe1708d60e" class="ne-p"><span class="ne-text">PBL的方式组队，开发一个创意项目。</span><strong><span class="ne-text" style="color: black; font-size: 14px"></span></strong></p><h2 id="l2Bzi"><span class="ne-text">三、课程背景</span></h2><ol class="ne-ol"><li id="1b92fe6abf119f37a57ae13afed757b9" data-lake-index-type="0"><span class="ne-text">Android平台简介</span></li><li id="efa6b9eb6a54afc4effcb5af9d8fb5df" data-lake-index-type="0"><span class="ne-text">Google 提供了官方的Android Studio</span></li></ol><ol class="ne-list-wrap"><ol ne-level="1" class="ne-ol"><li id="8938dd5195d1139a879a488c711574ca" data-lake-index-type="0"><span class="ne-text">Java 或者 Kotlin</span></li></ol></ol><ol start="3" class="ne-ol"><li id="dfa4902c3a93e1dfaabce23bb97c52ec" data-lake-index-type="0"><span class="ne-text">Apple提供了官方的开发环境</span></li></ol><ol class="ne-list-wrap"><ol ne-level="1" class="ne-ol"><li id="195e639ea9ad339594bb4a241bc57a28" data-lake-index-type="0"><span class="ne-text">Swift或者OC</span></li></ol></ol><ol start="4" class="ne-ol"><li id="8c996553d687b1d40c45b0fffbd4228b" data-lake-index-type="0"><span class="ne-text">Wechat提供了官方的开发环境</span></li></ol><ol class="ne-list-wrap"><ol ne-level="1" class="ne-ol"><li id="46b408d3f06910182797a912ffc67592" data-lake-index-type="0"><span class="ne-text">SNS 排第一的产品；Facebook</span></li><li id="662c3b4293ab748ac551c15e815b4f5e" data-lake-index-type="0"><span class="ne-text">小程序，JD</span></li></ol></ol><ol start="5" class="ne-ol"><li id="c664d32cf93465a7aa31e944eb588d99" data-lake-index-type="0"><span class="ne-text">其他平台</span></li></ol><ol class="ne-list-wrap"><ol ne-level="1" class="ne-ol"><li id="45b7ee62f30f183188a7fb3531495cf5" data-lake-index-type="0"><span class="ne-text">百度小程序等</span></li></ol></ol><h2 id="s10gz"><span class="ne-text">四、技术路线</span></h2><ol class="ne-ol"><li id="c1515d008e8899a2eddfc99363cecf68" data-lake-index-type="0"><span class="ne-text">uni-app 是一个使用 </span><a href="https://vuejs.org/" data-href="https://vuejs.org/" target="_blank" class="ne-link"><span class="ne-text" style="color: black">Vue.js</span></a><span class="ne-text"> 开发所有前端应用的框架，开发者编写一套代码，可发布到iOS、Android、H5、以及各种小程序（微信/支付宝/百度/头条/QQ/钉钉/淘宝）、快应用等多个平台。</span></li><li id="a0dedc56476c72f211fec397e9017edf" data-lake-index-type="0"><span class="ne-text">DCloud公司</span><span class="ne-text">拥有500万开发者用户，几十万应用案例、10亿手机端月活用户，数千款uni-app插件、70+微信/qq群。阿里小程序工具官方内置uni-app（</span><a href="https://docs.alipay.com/mini/ide/0.70-stable" data-href="https://docs.alipay.com/mini/ide/0.70-stable" target="_blank" class="ne-link"><span class="ne-text" style="color: black">详见</span></a><span class="ne-text">），腾讯课堂官方为uni-app录制培训课程（</span><a href="https://ask.dcloud.net.cn/article/35640" data-href="https://ask.dcloud.net.cn/article/35640" target="_blank" class="ne-link"><span class="ne-text" style="color: black">详见</span></a><span class="ne-text">），开发者可以放心选择。</span></li><li id="4bd1cf68901330387fa0e7d672502aec" data-lake-index-type="0"><span class="ne-text">uni-app在手，做啥都不愁。即使不跨端，uni-app也是更好的小程序开发框架（</span><a href="https://ask.dcloud.net.cn/article/35947" data-href="https://ask.dcloud.net.cn/article/35947" target="_blank" class="ne-link"><span class="ne-text" style="color: black">详见</span></a><span class="ne-text">）、更好的App跨平台框架、更方便的H5开发框架。不管领导安排什么样的项目，你都可以快速交付，不需要转换开发思维、不需要更改开发习惯。</span></li></ol><h2 id="Vc49F"><span class="ne-text">五、快速上手+安装环境</span></h2><p id="061f2f100a5606d1a45163bfe7397d1d" class="ne-p"><span class="ne-text">uni-app支持通过可视化界面、</span><a href="https://uniapp.dcloud.io/quickstart?id=%e9%80%9a%e8%bf%87vue-cli%e5%91%bd%e4%bb%a4%e8%a1%8c" data-href="https://uniapp.dcloud.io/quickstart?id=%e9%80%9a%e8%bf%87vue-cli%e5%91%bd%e4%bb%a4%e8%a1%8c" target="_blank" class="ne-link"><span class="ne-text" style="color: black">vue-cli命令行</span></a><span class="ne-text"> 两种方式快速创建项目。</span></p><p id="2fe5e3f9e41c3b6a4cdc7f7d0ab0a84a" class="ne-p"><br></p><h3 id="S71ku"><a href="https://uniapp.dcloud.io/quickstart?id=_1-%e9%80%9a%e8%bf%87-hbuilderx-%e5%8f%af%e8%a7%86%e5%8c%96%e7%95%8c%e9%9d%a2" data-href="https://uniapp.dcloud.io/quickstart?id=_1-%e9%80%9a%e8%bf%87-hbuilderx-%e5%8f%af%e8%a7%86%e5%8c%96%e7%95%8c%e9%9d%a2" target="_blank" class="ne-link"><span class="ne-text" style="color: black">通过</span><span class="ne-text" style="color: black"> HBuilderX </span><span class="ne-text" style="color: black">可视化界面</span></a></h3><ol class="ne-ol"><li id="1474f88fe45df08977bcf3b0bc8e04b4" data-lake-index-type="0"><span class="ne-text">可视化的方式比较简单，HBuilderX内置相关环境，开箱即用，无需配置nodejs。</span></li><li id="6ede59ec30abf404eea475b21a0bf0fd" data-lake-index-type="0"><span class="ne-text">开始之前，开发者需先下载安装如下工具：</span></li><li id="512d49462be22bfadf3f137f9b3a3356" data-lake-index-type="0"><span class="ne-text">HBuilderX：</span><a href="https://www.dcloud.io/hbuilderx.html" data-href="https://www.dcloud.io/hbuilderx.html" target="_blank" class="ne-link"><span class="ne-text" style="color: black">官方</span><span class="ne-text" style="color: black">IDE下载地址</span></a></li><li id="60a9ceb1c37f4d821e3d5fd0a928e1df" data-lake-index-type="0"><a href="https://www.dcloud.io/hbuilderx.html" data-href="https://www.dcloud.io/hbuilderx.html" target="_blank" class="ne-link"><span class="ne-text">HBuilderX</span></a><span class="ne-text">是通用的前端开发工具，但为uni-app做了特别强化。</span></li><li id="6dff256edff5f7aba4d2c28fab54a1c3" data-lake-index-type="0"><span class="ne-text">下载App开发版，可开箱即用；如下载标准版，在运行或发行uni-app时，会提示安装uni-app插件，插件下载完成后方可使用。</span></li></ol><p id="5dcbe0eb0cb08128ec21bb8d9c4cc88f" class="ne-p"><br></p><h3 id="o463A"><span class="ne-text">Chrome/最新版Edge</span></h3><ul class="ne-ul"><li id="9eae4ed9d76397fe7c1931914a4c2ccf" data-lake-index-type="0"><a href="https://www.google.com/intl/zh-CN/chrome/" data-href="https://www.google.com/intl/zh-CN/chrome/" target="_blank" class="ne-link"><span class="ne-text">https://www.google.com/intl/zh-CN/chrome/</span></a></li><li id="a4c98286a364204a25112c044924916d" data-lake-index-type="0"><span class="ne-text">Edge(最新)浏览器：</span><a href="https://www.microsoftedgeinsider.com/en-us/download" data-href="https://www.microsoftedgeinsider.com/en-us/download" target="_blank" class="ne-link"><span class="ne-text">下载地址（DEV版本会消去插件开发者禁用状态）</span></a></li></ul><h3 id="hTDAB"><span class="ne-text">Android Studio</span></h3><ul class="ne-ul"><li id="8283dfcc39fab7fd48dc4f5c33c55db7" data-lake-index-type="0"><span class="ne-text">下载地址：</span><a href="https://developer.android.com/studio" data-href="https://developer.android.com/studio" target="_blank" class="ne-link"><span class="ne-text">https://developer.android.com/studio</span></a></li></ul><h3 id="vesdr"><span class="ne-text">gradle国内源配置方法</span></h3><p id="873847124577992992fbd7c3de0f55f5" class="ne-p"><span class="ne-text">Android Studio在构建项目时会拉取gradle资源，而goole和jcenter在国内的网络环境并不好用，容易产生connect timeout等错误。因此将地址修改成阿里云的国内镜像。<br /></span><span class="ne-text">一、允许使用maven仓库<br /></span><span class="ne-text">　　点击File-&gt;Settings进入设置界面，勾选“Enable embedded Maven repository”，<br /><br /></span><span class="ne-text">二、修改build.gradle<br /></span><span class="ne-text">　　在项目文件中找到build.gradle文件，修改其中的buildscript和allprojects地址：</span></p><pre><code><code>buildscript &#123;    repositories &#123;        maven&#123; url 'http://maven.aliyun.com/nexus/content/groups/public/' &#125;        maven&#123; url 'http://maven.aliyun.com/nexus/content/repositories/jcenter'&#125;    &#125;    dependencies &#123;        classpath 'com.android.tools.build:gradle:3.3.0-alpha13'    &#125;&#125;allprojects &#123;    repositories &#123;        maven&#123; url 'http://maven.aliyun.com/nexus/content/groups/public/'&#125;        maven&#123; url 'http://maven.aliyun.com/nexus/content/repositories/jcenter'&#125;    &#125;&#125;task clean(type: Delete) &#123;    delete rootProject.buildDir&#125;</code></code></pre><p id="2dfb76dc0e465544f79e60b754cdff6c" class="ne-p"><span class="ne-text">gradle的文件下载下来以后会保存在本地，也有缓存。这意味着不同的项目如果有相同的gradle依赖，则不需要重复下载。因此也不是每次打开新项目都需要修改build.gradle文件。</span></p><p id="af0d9fdae7327c1072c1ddded689b8df" class="ne-p"><br></p><p id="9494f966c6b80d44a198c0bbbbfc138b" class="ne-p"><span class="ne-text">如果修改build.gradle后重新build还是有错，可以尝试新建一个相同API版本的项目。</span></p><p id="76d7b54fc742727c180b86afb40e4c1d" class="ne-p"><br></p><p id="1075834db39bf8498e36425775590aef" class="ne-p"><span class="ne-text">参考：</span></p><ul class="ne-ul"><li id="c6d3599260af4b650bb04bab2cba8c09" data-lake-index-type="0"><a href="https://maven.aliyun.com/mvn/guide" data-href="https://maven.aliyun.com/mvn/guide" target="_blank" class="ne-link"><span class="ne-text">阿里云gradle 配置指南</span></a></li></ul><h2 id="B0xb8"><span class="ne-text">六、考核方式</span></h2><p id="728c439c078640dffd0d5fdebc092a42" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1605441751743-cb395908-39ce-4303-ab00-0c885d05abe9.png" width="596" id="f7AlH" class="ne-image"></p><h3 id="Dj7kz"><span class="ne-text">后台技术栈</span></h3><ul class="ne-ul"><li id="d7bb8a3069a37036f90a9c5252d3e769" data-lake-index-type="0"><span class="ne-text">PHP</span></li><li id="05b756c9e890b0a6619dbaccb84f7262" data-lake-index-type="0"><span class="ne-text">Node.js</span></li></ul><div class="ne-quote"><p id="c598e1f234658828ea227e2943b0d54a" class="ne-p"><span class="ne-text">JavaScript</span></p><p id="2c3be8ae486e0b66c6152f6575f8b750" class="ne-p"><span class="ne-text">node.js+express+ejs</span></p></div><ul class="ne-ul"><li id="344069b073796e40358350dd05f91fa8" data-lake-index-type="0"><span class="ne-text">Spring Boot</span></li></ul><ul class="ne-ul"><li id="56cf329068a4870c4f2b91bb32d674a2" data-lake-index-type="0"><span class="ne-text">数据库</span></li></ul><div class="ne-quote"><ul class="ne-ul"><li id="48a349b15d5c34b22c0e712fe8f210bf" data-lake-index-type="0"><span class="ne-text">MyBatis-Plus</span></li><li id="2ab15cdde202e46722a666e588c1a5b4" data-lake-index-type="0"><span class="ne-text">DCloud</span></li></ul></div></div>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
          <category> 前端业务解决方案 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++广义表</title>
      <link href="/blog/gosz5u/"/>
      <url>/blog/gosz5u/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h2 id="EuQc4"><span class="ne-text">广义表举例</span></h2><p id="u0a224aa8" class="ne-p"><span class="ne-text">.</span></p><p id="ee4d796addaa55869cad32441f7911e2" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1620291002536-6b098e81-6400-4139-876b-9ef890f1dc71.png" width="668.5" id="mXXFN" class="ne-image"></p><h2 id="hgbWz"><span class="ne-text">广义表的3个重要结论</span></h2><p id="510710ca7be796029c3e34b327515cf5" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1620291048426-17db6fbb-8972-4d82-980e-6ff303f55752.png" width="704.5" id="Pf4IN" class="ne-image"></p><h2 id="9epRZ"><span class="ne-text">广义表的运算</span></h2><p id="d7254dd7bf9ef5ea4827311af3d85987" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1620291080210-d88e7855-41ed-45be-a433-1a60a64d3220.png" width="695" id="uZluo" class="ne-image"></p><p id="10780ef1ec3b884cbd0fbf75d2663be2" class="ne-p"><br></p><h2 id="BqmdO"><span class="ne-text">一些题目</span></h2><div class="ne-quote"><p id="c0344972f68040fb4742717d47307a96" class="ne-p"><span class="ne-text">（13）广义表A=(a,b,(c,d),(e,(f,g)))，则Head(Tail(Head(Tail(Tail(A)))))的值为（  ）。</span></p><p id="7fc6b2939e9c9b2f42cf68d7669f63ed" class="ne-p"><span class="ne-text">A．(g)            B．(d)             C．c            D．d</span></p></div><p id="701b1a41924543f8e69ecc226af11c13" class="ne-p"><span class="ne-text">答案：D</span></p><p id="2666f277f741c10e8574926e17f581c7" class="ne-p"><span class="ne-text">解释：Tail(A)=(b,(c,d),(e,(f,g)))；Tail(Tail(A))=( (c,d),(e,(f,g)))； Head(Tail(Tail(A)))= (c,d)；Tail(Head(Tail(Tail(A))))=(d)；Head(Tail(Head(Tail(Tail(A)))))=d。</span></p><p id="5acd8898c58d06ee125f507d9f6bf8a6" class="ne-p"><br></p><div class="ne-quote"><p id="8332376071039a51004352774c468b65" class="ne-p"><span class="ne-text">（14）广义表((a,b,c,d))的表头是（  ），表尾是（  ）。</span></p><p id="5b4580e7a0b310e036317d20d66c2acb" class="ne-p"><span class="ne-text">A．a              B．( )             C．(a,b,c,d)      D．(b,c,d)</span></p></div><p id="7491c703b0e310e88fac7e1c23695de9" class="ne-p"><span class="ne-text">答案：C、B</span></p><p id="ed8f9bd6f3db6d13a6ac0e4b31898b6c" class="ne-p"><span class="ne-text">解释：表头为非空广义表的第一个元素，可以是一个单原子，也可以是一个子表，((a,b,c,d))的表头为一个子表(a,b,c,d)；表尾为除去表头之外，由其余元素构成的表，表为一定是个广义表，((a,b,c,d))的表尾为空表( )。</span></p><p id="43d06cd5b511dcb9b1482f2c907ecbfc" class="ne-p"><br></p><div class="ne-quote"><p id="04f91434e98e3d2fdf156dd21856a2d2" class="ne-p"><span class="ne-text">（15）设广义表L=((a,b,c))，则L的长度和深度分别为（  ）。</span></p><p id="366e639445d485e8c76d1ad23b69e3c9" class="ne-p"><span class="ne-text">A．1和1          B．1和3          C．1和2          D．2和3  </span></p></div><p id="24e6fbe5058a8ce9e4b95e57abd47ea1" class="ne-p"><span class="ne-text">答案：C</span></p><p id="1eb889738236c426269487ba5ac0fa6f" class="ne-p"><span class="ne-text">解释：广义表的深度是指广义表中展开后所含括号的层数，广义表的长度是指广义表中所含元素的个数。根据定义易知L的长度为1，深度为2。</span></p></div>]]></content>
      
      
      <categories>
          
          <category> 计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 📶线结构：字符串-数组-栈-队列 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>周围的喧嚣</title>
      <link href="/essay/nqm77s/"/>
      <url>/essay/nqm77s/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="traditional"><p id="d9a1b748e9d5bf4c733df9798ece4464" class="ne-p"><span class="ne-text">现在的文章，喧嚣</span></p><p id="udd66b3fc" class="ne-p"><br></p><p id="u4baa13e0" class="ne-p"><span class="ne-text">动不动一篇文章出来个广告</span></p><p id="ue0a96af3" class="ne-p"><br></p><p id="u2015d2bc" class="ne-p"><span class="ne-text">目的性太强</span></p><p id="u91c22381" class="ne-p"><br></p><p id="u204225f2" class="ne-p"><span class="ne-text">为了写而写，就像是，文字什么时候变得这么苍白</span></p><p id="ee6aed8d571b29cca6f68bd19bd71169" class="ne-p"><br></p></div>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>《许三观卖血记》</title>
      <link href="/essay/ghwn6o/"/>
      <url>/essay/ghwn6o/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content-editor-core lake-engine lake-typography-classic" data-lake-element="root" data-selection-undefined="%7B%22path%22%3A%5B%5B11%2C0%2C33%5D%2C%5B11%2C0%2C33%5D%5D%2C%22active%22%3Atrue%7D"><p data-lake-id="d4cea9740a69221dffc5f2ba9e3f7db3" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">===有一个场景我记得很清楚，当许玉兰被批斗的时候，许三观送饭，在饭下面藏着几块肉，那样的场景，温情脉脉</p><p data-lake-id="602e0d465d59f9fad75c23b850601196" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">还有在家里的时候，玉兰说出自己曾经的种种不堪的事情的时候，许三观为了在几个儿子面前维护玉兰，也同等说出自己的许多不堪的事</p><p data-lake-id="099db7dbd436f79364b4e901ac4c41ff" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">我觉得，这种关系，才像是一起经历过苦难的夫妻作为，那个家庭场景，老实说，我感到很有温度</p><p data-lake-id="c77249fb93f55829de65225e0a08320e" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="8f8ff8415a08cea2870450099f3b7f18" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="60c44371af314bbc5d8e0b0bf4f4732b" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">===小说最后，让我有点痛心的就是三个儿子对许三观说出的一番话。</p><p data-lake-id="90eca51690bc80a509b2c071009e504b" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">子女永远不知道自己父母付出的有多少</p><p data-lake-id="51af3b00918ea9ababfabf97a0ea1618" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">好在身边一直有的是玉兰。</p><p data-lake-id="05202ccf59cd392160058e84b14fb836" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="110d2cf60e2d3d58c9c7b87d2daa4645" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="e73f342f845d00a5ef9992ee105dde8f" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">===突然又想到《活着》，突然又想到富贵的人生似乎更为惨淡，一生下来，经历种种苦楚，最后的人生和一头老牛在田野远远望去</p><p data-lake-id="f93769d5a9c011b9344ab9683729bcdb" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">家珍，还有一个女儿，一个儿子…说实话，他们的结局，也是挺悲惨的……</p></div>]]></content>
      
      
      <categories>
          
          <category> 阅读 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++随机字符串生成函数</title>
      <link href="/blog/zeszpb/"/>
      <url>/blog/zeszpb/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="512ec903a675f1d65946a0ae6c669460" class="ne-p"><br></p><p id="ufa821b96" class="ne-p"><br></p><pre><code>//C++ 随机字符串生成函数#include&lt;iostream&gt;#include&lt;ctime&gt;using namespace std; <p>const int LEN_NAME=4;</p><p>char *rand_str(char *str,const int len)<br>&#123;<br>    int i;<br>    for(i=0;i&lt;len;++i)<br>        str[i]=’A’+rand()%26;<br>    str[++i]=’\0’;<br>    return str;<br>&#125;</p><p>void main()<br>&#123;<br>    srand(time(NULL));<br>    int i;<br>    char name[LEN_NAME+1];</p><pre><code>for(i=0;i&amp;lt;20;++i)&#123;    cout&amp;lt;&amp;lt;rand_str(name,LEN_NAME)&amp;lt;&amp;lt;endl;&#125;</code></pre><p>}<br></code></pre></p><p id="a5fd2b717bc3549e236bcb1670a6c8c2" class="ne-p"><br></p></div>]]></content>
      
      
      <categories>
          
          <category> 计算机素养 </category>
          
          <category> 后端编程语言 </category>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>分治算法+归并排序</title>
      <link href="/blog/ab9fkt/"/>
      <url>/blog/ab9fkt/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h2 id="cfcVz"><span class="ne-text">分治算法</span></h2><p id="35aafef4a9bcda56fd4b3dba1a40d2bd" class="ne-p"><span class="ne-text">此前学习的</span><strong><span class="ne-text">递归设计方法</span></strong><span class="ne-text">，是针对规模大的问题拆成规模小的问题，并且规模大的问题和规模小的问题的解决办法相同。</span></p><p id="c255444429f9bde357299190cda1ce10" class="ne-p"><span class="ne-text">分治算法与递归设计方法的不同之处就是，该规模较大的问题分解为多个不重叠的子问题，并将其称为</span><strong><span class="ne-text">“分而治之”</span></strong></p><p id="f5da9f304053283051d36c3209602cb2" class="ne-p"><strong><span class="ne-text"></span></strong></p><p id="f7be74539c18b7442691d70eaff3e713" class="ne-p"><span class="ne-text">分治的三个步骤：</span></p><ol class="ne-ol"><li id="f57c5c6c8a092421769e80ff6e62e52e"><span class="ne-text">分解：将原问题分解为若干个规模较小、相互不重叠与原问题形式相同的子问题</span></li><li id="69c2c7d170be1f23ed1ada962ac0a89c"><span class="ne-text">解决：</span></li></ol><ol class="ne-list-wrap"><ol ne-level="1" class="ne-ol"><li id="5caa5d0a43955bb47e82d0562c29ac25"><span class="ne-text">若子问题规模较小且易于解决时候直接解出</span></li><li id="7637769c316422d46a9df77dc13cbd48"><span class="ne-text">否则递归地解决各个子问题</span></li></ol></ol><ol start="3" class="ne-ol"><li id="c28caab89b84198c68a66eeaa4db0791"><span class="ne-text">合并：将各个子问题的解个并未原问题的解</span></li></ol><p id="66b67bebe7070a915d898cf3fe17d3c4" class="ne-p"><br></p><h2 id="eyoCp"><span class="ne-text">归并排序</span></h2><h3 id="MwiZs"><span class="ne-text">问题分析</span></h3><ul class="ne-ul"><li id="f1be42afae72c8b1f39e714ade5bd973"><span class="ne-text">分解：将排序数组分解为左右两个相等的不重叠的数组</span></li><li id="478a66cbae93c17af3e2defd24c869a3"><span class="ne-text">解决：递归</span></li><li id="cc673598dbfe5bbab9b7e8308ee61396"><span class="ne-text">合并：将两个已经有序的数组合并为一个有序的数组</span></li></ul><p id="d13888f50bb29ce34b29389eced48dfe" class="ne-p"><br></p><p id="dd044635c677c7d57855fe4bb0139137" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1603617542157-07613fda-ebed-4924-bf6a-091c19b12fc7.png" width="447.5" id="UFs9X" class="ne-image"></p><h3 id="vaZYS"><span class="ne-text">代码实现</span></h3></div>]]></content>
      
      
      <categories>
          
          <category> 计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 🧮分治算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>IDEA控制台输出中文乱码问题</title>
      <link href="/blog/lkgrkx/"/>
      <url>/blog/lkgrkx/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content-editor-core lake-engine lake-typography-classic" data-lake-element="root" data-selection-undefined="%7B%22path%22%3A%5B%5B0%2C0%2C0%5D%2C%5B0%2C0%2C0%5D%5D%2C%22active%22%3Atrue%7D"><h2 data-lake-id="3445993c8397f923f593148c9678b2be" id="12NJp" style="padding: 7px 0px; margin: 0px; font-weight: 700; font-size: 24px; line-height: 32px;">问题描述</h2><p data-lake-id="27cf45e30730ae904801551a4fd45618" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">在java实现ping/tracert两个命令时候，输出到控制台里面中文乱码。</p><h2 data-lake-id="e41747057624da1fda53f1692c2abf8b" id="6Mrsg" style="padding: 7px 0px; margin: 0px; font-weight: 700; font-size: 24px; line-height: 32px;">问题分析</h2><p data-lake-id="aa4133aacb145f7a60e48ec97e02b1ff" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">应该是调用了终端，而windows的终端默认是GBK的编码，所以要对其更改管用的utf-8编码，改为GBK编码。</p><p data-lake-id="bf8885768c610002aed1a805dff4db9e" style="text-align: center; font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span data-card-type="inline" data-lake-card="image" class="lake-card-margin-top lake-card-margin-bottom"><img data-role="image" src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1603613519544-dc851d0f-e0c0-4a0a-9a2d-0043285b3db0.png" data-raw-src="" class="image lake-drag-image" alt="image.png" title="image.png" data-height="441px" style="visibility: visible; width: 353px;"></span></p><h2 data-lake-id="e6d5080eb6263c31f10245126b9c609a" id="nikHe" style="padding: 7px 0px; margin: 0px; font-weight: 700; font-size: 24px; line-height: 32px;">问题解决</h2><h3 data-lake-id="a77363c514edff9c5855074c2adede07" id="9YLoX" style="padding: 7px 0px; margin: 0px; font-weight: 700; font-size: 20px; line-height: 28px;">编码更改</h3><p data-lake-id="8232504546bba3aebade5ca7d951282f" style="text-align: center; font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span data-card-type="inline" data-lake-card="image" class="lake-card-margin-top lake-card-margin-bottom"><img data-role="image" src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1603613302488-7bd6d045-81c3-470c-a57c-05a020588fcd.png" data-raw-src="" class="image lake-drag-image" alt="image.png" title="image.png" data-height="511px" style="visibility: visible; width: 724.5px;"></span></p><p data-lake-id="028c31c7314a8565212d048087ec748e" style="text-align: center; font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span data-card-type="inline" data-lake-card="image" class="lake-card-margin-top lake-card-margin-bottom"><img data-role="image" src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1603613687953-21f1bbc9-b0bc-4db4-a935-3fcf6275909f.png" data-raw-src="" class="image lake-drag-image" alt="image.png" title="image.png" data-height="185px" style="visibility: visible; width: 960px;"></span></p><p data-lake-id="45a541a368680486dfd89aed4c5900ab" style="text-align: center; font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span data-card-type="inline" data-lake-card="image" class="lake-card-margin-top lake-card-margin-bottom"><img data-role="image" src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1603613719305-ac9dc39b-2c6a-4350-9f31-49d48dbedfe5.png" data-raw-src="" class="image lake-drag-image" alt="image.png" title="image.png" data-height="110px" style="visibility: visible; width: 382px;"></span></p><ul data-lake-id="ad98330023369022e7c492b154832ac9" lake-indent="0" style="list-style-type: disc; margin: 0px; padding-left: 23px; font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word;"><li data-lake-id="31314182133023b36174255e06cef8e6"><code style="font-family: monospace; font-size: inherit; background-color: rgba(0, 0, 0, 0.06); padding: 0px 2px; border: 1px solid rgba(0, 0, 0, 0.08); border-radius: 2px; line-height: inherit; overflow-wrap: break-word; text-indent: 0px;">Reload</code> 表示使用新编码重新加载，新编码不会保存到文件中</li><li data-lake-id="645132a8a849b3c30b2b2b05e47511c3"><code style="font-family: monospace; font-size: inherit; background-color: rgba(0, 0, 0, 0.06); padding: 0px 2px; border: 1px solid rgba(0, 0, 0, 0.08); border-radius: 2px; line-height: inherit; overflow-wrap: break-word; text-indent: 0px;">Convert</code> 表示使用新编码进行转换，新编码会保存到文件中</li><li data-lake-id="54c65ef286ef227dae57eaf3b6cce40f">含有中文的代码文件，<code style="font-family: monospace; font-size: inherit; background-color: rgba(0, 0, 0, 0.06); padding: 0px 2px; border: 1px solid rgba(0, 0, 0, 0.08); border-radius: 2px; line-height: inherit; overflow-wrap: break-word; text-indent: 0px;">Convert</code> 之后可能会使中文变成乱码，所以在转换成请做好备份，不然可能出现转换过程变成乱码，无法还原</li></ul><h3 data-lake-id="d617008360d65738588699c203e3edf4" id="qL8ve" style="padding: 7px 0px; margin: 0px; font-weight: 700; font-size: 20px; line-height: 28px;">BOM问题</h3><blockquote style="margin-top: 5px; margin-bottom: 5px; padding-left: 1em; margin-left: 0px; border-left: 3px solid rgb(238, 238, 238); opacity: 0.6;"><p data-lake-id="4f754943ed27cdaf17e219840aa83198" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>BOM：byte-order mark 字节顺序标记</span></p><p data-lake-id="7e72738ee6656e87f9aeb8c7d67711a4" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><a href="https://zh.wikipedia.org/wiki/%E4%BD%8D%E5%85%83%E7%B5%84%E9%A0%86%E5%BA%8F%E8%A8%98%E8%99%9F" target="_blank">https://zh.wikipedia.org/wiki/%E4%BD%8D%E5%85%83%E7%B5%84%E9%A0%86%E5%BA%8F%E8%A8%98%E8%99%9F</a></p></blockquote><p data-lake-id="c186f2a92de8812276f9c8df946d62dc" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="e4bd50c23f781957256b7bc15a11fb39" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">可能会出现的问题有：</p><blockquote style="margin-top: 5px; margin-bottom: 5px; padding-left: 1em; margin-left: 0px; border-left: 3px solid rgb(238, 238, 238); opacity: 0.6;"><p data-lake-id="dc869bf9f63b3fd02cd80938c3fc3072" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">编译报错：<code style="font-family: monospace; font-size: inherit; background-color: rgba(0, 0, 0, 0.06); padding: 0px 2px; border: 1px solid rgba(0, 0, 0, 0.08); border-radius: 2px; line-height: inherit; overflow-wrap: break-word; text-indent: 0px;">找不到符号</code>、<code style="font-family: monospace; font-size: inherit; background-color: rgba(0, 0, 0, 0.06); padding: 0px 2px; border: 1px solid rgba(0, 0, 0, 0.08); border-radius: 2px; line-height: inherit; overflow-wrap: break-word; text-indent: 0px;">未结束的字符串文字</code> 或者是 提示 <code style="font-family: monospace; font-size: inherit; background-color: rgba(0, 0, 0, 0.06); padding: 0px 2px; border: 1px solid rgba(0, 0, 0, 0.08); border-radius: 2px; line-height: inherit; overflow-wrap: break-word; text-indent: 0px;">非法字符</code></p></blockquote><p data-lake-id="d03a593e0d7aec1949563aa2a6a50e3b" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="0fa9f222416e1c1f128b3ed7afb5660e" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">解决办法：有上述百科可知，UTF-8编码分有BOM和无BOM两种分类。IDEA打开Eclipse项目，会提示出现上述编译问题，因为<strong>Eclipse默认是有BOM的文件编译</strong>，而<strong>IDEA只能编译无BOM的文件编译</strong>，所以解决办法就是对项目进行<strong>BOM去除</strong>操作。</p><p data-lake-id="c01cd8ce07fe1dc7047ba8953b14a750" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p></div>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
          <category> Bug记录 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>莱文斯坦距离(LD)问题</title>
      <link href="/blog/bvk4ok/"/>
      <url>/blog/bvk4ok/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="traditional"><h2 id="IPeo8"><span class="ne-text">问题描述</span></h2><p id="50f7f61626c9cea10ad11df3d32e6d78" class="ne-p"><strong><span class="ne-text">Levenshtein Distance</span></strong><span class="ne-text">也称</span><strong><span class="ne-text">莱文斯坦距离</span></strong></p><p id="94b372e58c2def29b24b287d2ca70e56" class="ne-p"><br></p><p id="c891008a0ab5f196e1064f8395543d31" class="ne-p"><span class="ne-text">具体形式就是求一个字符串到另一个字符串所需要的</span><strong><span class="ne-text">最少操作步数</span></strong><span class="ne-text">，操作形式有：</span></p><ul class="ne-ul"><li id="db162df517a0dcc5c15edc37ba727945"><span class="ne-text">替换字母</span></li><li id="6dfe0c3dfb3d85638d4936ba5d511017"><span class="ne-text">删除字母</span></li><li id="15fa4b9d318b31488329c0948ec7bede"><span class="ne-text">插入字母</span></li></ul><h2 id="lrKvr"><span class="ne-text">问题分析</span></h2><p id="d4286e3fb8b1a8b8b8cfa22c583b466f" class="ne-p"><span class="ne-text">利用动态规划思想，将其剖析为一个个子问题，用其子问题的解决方式来解决该问题。问题分解出来的子问题存在重叠的情况，这是区分分治算法的不同。</span></p><p id="84e9545dbb3cf8bc12a504de0b98e08c" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1603615056984-36cbce7c-c55e-456a-bb90-eb18471167e0.png" width="513" id="qpRoD" class="ne-image"></p><p id="31510a6c776efeddd9241dda48ae654c" class="ne-p"><br></p><p id="8cc72b13408e66840d6974e7da61d8b3" class="ne-p"><strong><span class="ne-text">莱文斯坦的公式化</span></strong><span class="ne-text">表述为：</span></p><p id="8de07f27492486c9eada6c9e310e1aed" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1603614727015-dad259b0-7904-4e5d-9ec8-f4ac284af2e5.png" width="437" id="OLKIR" class="ne-image"></p><p id="edf04eb3be987bfa921b098a3ba8ea53" class="ne-p"><br></p><p id="a30741b57baf655228acfec9a9c39546" class="ne-p"><span class="ne-text">下面利用表格的形式来步步推出该字母所需要达到相应的目标字母序列的步数。</span></p><table id="3PvI2" class="ne-table" style="width: 594px"><tbody><tr style="height: 33px"><td width="86" style="background-color: #F5F5F5"><p id="f3e472ab12f9966dab4e6b74aeb56b9d" class="ne-p"><br></p></td><td width="95" style="background-color: #F5F5F5"><p id="f16c561e219b1ff75664df8f04727ca0" class="ne-p"><span class="ne-text" style="color: #F5222D"></span></p></td><td width="97" style="background-color: #F5F5F5"><p id="67673e77ebf482a713c4c13946c504d4" class="ne-p"><span class="ne-text">s</span></p></td><td width="164" style="background-color: #F5F5F5"><p id="70a201ceeb03fa2fe27ea15b1fb4f457_p_0" class="ne-p"><span class="ne-text">o</span></p></td><td width="152" style="background-color: #F5F5F5"><p id="fc06ea377ed3bb2f227b8d21f4771bce_p_0" class="ne-p"><span class="ne-text">n</span></p></td></tr><tr style="height: 33px"><td width="86" style="background-color: #F5F5F5"><p id="80541b5a35403e1d0187d5985b6ce42e" class="ne-p"><span class="ne-text" style="color: #F5222D"></span></p></td><td width="95" style="background-color: #F5F5F5"><p id="515141c761d1a2676477bcc490f86bc4_p_0" class="ne-p"><span class="ne-text">0</span></p></td><td width="97" style="background-color: #F5F5F5"><p id="f5288918051daac58a0cdf74b1d666a8_p_0" class="ne-p"><span class="ne-text">1</span></p></td><td width="164" style="background-color: #F5F5F5"><p id="2437cac6ad8f03448ae403be9a3af9ed_p_0" class="ne-p"><span class="ne-text">2</span></p></td><td width="152" style="background-color: #F5F5F5"><p id="51d6cd746c79a513e0ce3a75ec25e3f9_p_0" class="ne-p"><span class="ne-text">3</span></p></td></tr><tr style="height: 33px"><td width="86" style="background-color: #F5F5F5"><p id="f699b6228a0ee572bf4fb4d49a92b3a0_p_0" class="ne-p"><span class="ne-text">s</span></p></td><td width="95" style="background-color: #F5F5F5"><p id="u6d4d522e" class="ne-p"><span class="ne-text">1</span></p></td><td width="97" style="background-color: #F5F5F5"><p id="uc8d8518d" class="ne-p"><span class="ne-text">0</span></p></td><td width="164" style="background-color: #F5F5F5"><p id="u7b01e8b3" class="ne-p"><span class="ne-text">1</span></p></td><td width="152" style="background-color: #F5F5F5"><p id="ud61300b3" class="ne-p"><span class="ne-text">2</span></p></td></tr><tr style="height: 33px"><td width="86" style="background-color: #F5F5F5"><p id="d494e79b3ef38df3865761fcf4432084_p_0" class="ne-p"><span class="ne-text">u</span></p></td><td width="95" style="background-color: #F5F5F5"><p id="ueead533a" class="ne-p"><span class="ne-text">2</span></p></td><td width="97" style="background-color: #F5F5F5"><p id="u5ea1e755" class="ne-p"><span class="ne-text">1</span></p></td><td width="164" style="background-color: #F5F5F5"><p id="u14510cdb" class="ne-p"><span class="ne-text">1</span></p></td><td width="152" style="background-color: #F5F5F5"><p id="ub7b1b851" class="ne-p"><span class="ne-text">2</span></p></td></tr><tr style="height: 33px"><td width="86" style="background-color: #F5F5F5"><p id="u39513c29" class="ne-p"><span class="ne-text">n</span></p></td><td width="95" style="background-color: #F5F5F5"><p id="ucc281d76" class="ne-p"><span class="ne-text">3</span></p></td><td width="97" style="background-color: #F5F5F5"><p id="ua96d5dd5" class="ne-p"><span class="ne-text">2</span></p></td><td width="164" style="background-color: #F5F5F5"><p id="u9393e833" class="ne-p"><span class="ne-text">2</span></p></td><td width="152" style="background-color: #F5F5F5"><p id="u9eb8ca53" class="ne-p"><span class="ne-text">1</span></p></td></tr></tbody></table><p id="4e386a904d040c2995c6a0aeb36c5c74" class="ne-p"><span class="ne-text">记横（son）为i字符串序列，纵（sun）为j字符串序列。需要完成的字符串变换为i-&gt;j。现举例格子数值该怎么填：</span></p><p id="4581bb5d4677bbf6b767df7cfccb3152" class="ne-p"><br></p><p id="f7d67b4bb4a022d082b6bc52dd63ad43" class="ne-p"><span class="ne-text">当到了第三行第三列的那一格，需要完成s-&gt;s，有三种情况可以选择</span></p><ol class="ne-ol"><li id="40767cc511a12f666908c40020a80f19"><span class="ne-text">左操作(i-1,j)：删除s字符然后插入s字符===操作步数两步</span></li><li id="d108b1360974e2c055f24f1db19dcd20"><span class="ne-text">上操作(i,j-1)：插入s字符然后删除s字符===操作步数两步</span></li><li id="38d82807972ec8c28f30be0d048dc363"><span class="ne-text">左上操作(i-1,j-1)：替换步骤，因为这个元素相同，故===操作步数零部</span></li></ol><p id="d7ce6a0e344a6a4058733108d421bc30" class="ne-p"><span class="ne-text">然后选取上述三种情况最短步数的数值0</span></p><p id="3a7417d853b4f22e665459afbcacb791" class="ne-p"><br></p><p id="624cd4681ef4cf611d94acb24b00a849" class="ne-p"><span class="ne-text">然后再看第三行第四列，需要完成so-&gt;s，</span></p><ol class="ne-ol"><li id="c192fffaeebe1cf6aa83be59c62e3b56"><span class="ne-text">左操作：删除o===一步</span></li><li id="cbf04063dd6b83559883d81d2bbc92ac"><span class="ne-text">上操作：插入s删除so===三步</span></li><li id="eb344f34b82fb264eec4412eda9da4e3"><span class="ne-text">做上操作：替换s删除o===两步</span></li></ol><p id="6419b9242f10f326ff180798ce0d0fe5" class="ne-p"><span class="ne-text">综上应该填1</span></p><p id="d9647893b32b0b730cdb4c275a3fec91" class="ne-p"><br></p><p id="ee64389c1d418a3ad8262bd7f919a8dc" class="ne-p"><span class="ne-text">其他格子也一样以上述方法填写。</span></p><p id="0a7afece280e72a6e374318d8becb0fb" class="ne-p"><br></p><p id="12d3e2d8ce5ff3c66eeb2a69e61a0787" class="ne-p"><span class="ne-text">有个作业遗留问题，在CAAIS里面每个得出的值右上标的 </span><code class="ne-code"><span class="ne-text">U</span></code><span class="ne-text">  </span><code class="ne-code"><span class="ne-text">L</span></code><span class="ne-text">  </span><code class="ne-code"><span class="ne-text">0</span></code><span class="ne-text">  </span><code class="ne-code"><span class="ne-text">1</span></code><span class="ne-text">  这些的依次顺序是怎么个顺序？ </span></p><p id="699db9ca10ac4e09d630178423ea19f9" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1603615446981-23bea432-08ee-490a-9037-018ba6280c3b.png" width="325.5" id="C4QpM" class="ne-image"></p><p id="4b29ce52a9487cf0312dd1d7b8a78017" class="ne-p"><br></p><h2 id="zQ0uK"><span class="ne-text">代码实现</span></h2><pre><code>#include &lt;string&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;ctime&gt;<p>const int LEN_NAME=100;</p><p>namespace NS_LSEditDist &#123;<br>    using namespace std;<br>    void Initialization(const string &amp;x, const string &amp;y);<br>    int GetLSEditDist(const string &amp;x, const string &amp;y);<br>    void GetLSEdits(const string &amp;x, const string &amp;y);<br>    void Output(const string &amp;x, const string &amp;y, int OptD);<br>    void OutputE(const string &amp;x, const string &amp;y);<br>    void OutputP(const string &amp;x, const string &amp;y);<br>    static int m, n;<br>    static vector&lt;vector&lt;int&gt;&gt; E;<br>    static vector&lt;vector&lt;char&gt;&gt; P;<br>    static string xe, ye;<br>    void LSEditDistCaller(const string &amp;x, const string &amp;y)<br>    &#123;<br>        Initialization(x, y);<br>        int OptD = GetLSEditDist(x, y);<br>        GetLSEdits(x, y);<br>        Output(x, y, OptD);<br>    &#125;<br>    int GetLSEditDist(const string &amp;x, const string &amp;y)<br>    &#123;<br>        for (int i = 1; i &lt;= m; i++)<br>            for (int j = 1; j &lt;= n; j++)<br>            &#123;<br>                E[i][j] = min(E[i - 1][j] + 1,<br>                              min(E[i][j - 1] + 1,<br>                                  E[i - 1][j - 1] + (x[i - 1] != y[j - 1])));<br>                if (E[i][j] == E[i - 1][j] + 1)<br>                    P[i][j] = ‘U’;<br>                else if (E[i][j] == E[i][j - 1] + 1)<br>                    P[i][j] = ‘L’;<br>                else if (x[i - 1] != y[j - 1])<br>                    P[i][j] = ‘1’;<br>            &#125;<br>        return E[m][n];<br>    &#125;<br>    void GetLSEdits(const string &amp;x, const string &amp;y)<br>    &#123;<br>        int i = m, j = n;<br>        while (i &gt; 0 || j &gt; 0)<br>        &#123;<br>            if (P[i][j] == ‘0’ || P[i][j] == ‘1’)<br>            &#123;<br>                xe.insert(0, 1, x[i - 1]);<br>                ye.insert(0, 1, y[j - 1]);<br>                i–; j–;<br>            &#125;<br>            else if (P[i][j] == ‘U’)<br>            &#123;<br>                xe.insert(xe.begin(), x[i - 1]);<br>                ye.insert(ye.begin(), ‘-‘);<br>                i–;<br>            &#125;<br>            else<br>            &#123;<br>                xe.insert(xe.begin(), ‘-‘);<br>                ye.insert(ye.begin(), y[j - 1]);<br>                j–;<br>            &#125;<br>        &#125;<br>    &#125;<br>    void Initialization(const string &amp;x, const string &amp;y)<br>    &#123;<br>        m = x.length();<br>        n = y.length();<br>        E.clear();<br>        E.resize(m + 1, vector&lt;int&gt;(n + 1, 0));<br>        P.clear();<br>        P.resize(m + 1, vector&lt;char&gt;(n + 1, ‘0’));<br>        for (int j = 1; j &lt;= n; j++)<br>        &#123;<br>            E[0][j] = j;<br>            P[0][j] = ‘L’;<br>        &#125;<br>        for (int i = 1; i &lt;= m; i++)<br>        &#123;<br>            E[i][0] = i;<br>            P[i][0] = ‘U’;<br>        &#125;<br>        xe.clear();<br>        ye.clear();<br>    &#125;<br>    void Output(const string &amp;x, const string &amp;y, int OptD)<br>    &#123;<br>        printf(&quot;Levenshtein distance: \n&quot;);<br>        printf(&quot;Strings: %s, %s\n\n&quot;, x.c_str(), y.c_str());<br>        OutputE(x, y);<br>        OutputP(x, y);<br>        printf(&quot;Distance: %d\n&quot;, OptD);<br>        printf(&quot;Edited strings:\n&quot;);<br>        for (auto c : xe)<br>            printf(&quot;%2c&quot;, c);<br>        printf(&quot;\n&quot;);<br>        for (auto c : ye)<br>            printf(&quot;%2c&quot;, c);<br>        printf(&quot;\n\n&quot;);<br>    &#125;<br>    void OutputE(const string &amp;x, const string &amp;y)<br>    &#123;<br>        printf(&quot; E  &quot;);<br>        for (int j = 0; j &lt; n; j++)<br>            printf(&quot;%2c&quot;, y[j]);<br>        printf(&quot;\n&quot;);<br>        for (int i = 0; i &lt;= m; i++)<br>        &#123;<br>            if (i == 0)<br>                printf(&quot;  &quot;);<br>            else<br>                printf(&quot;%2c&quot;, x[i - 1]);<br>            for (int j = 0; j &lt;= n; j++)<br>            &#123;<br>                printf(&quot;%2d&quot;, E[i][j]);<br>            &#125;<br>            printf(&quot;\n&quot;);<br>        &#125;<br>        printf(&quot;\n&quot;);<br>    &#125;<br>    void OutputP(const string &amp;x, const string &amp;y)<br>    &#123;<br>        printf(&quot; P  &quot;);<br>        for (int j = 0; j &lt; n; j++)<br>            printf(&quot;%2c&quot;, y[j]);<br>        printf(&quot;\n&quot;);<br>        for (int i = 0; i &lt;= m; i++)<br>        &#123;<br>            if (i == 0)<br>                printf(&quot;  &quot;);<br>            else<br>                printf(&quot;%2c&quot;, x[i - 1]);<br>            for (int j = 0; j &lt;= n; j++)<br>            &#123;<br>                printf(&quot;%2c&quot;, P[i][j]);<br>            &#125;<br>            printf(&quot;\n&quot;);<br>        &#125;<br>        printf(&quot;\n&quot;);<br>    &#125;<br>&#125; //namespace NS_LSEditDist<br>char *rand_str(char *str,const int len)<br>&#123;<br>    int i;<br>    for(i=0;i&lt;len;++i)<br>        str[i]=’a’+rand()%26;<br>    str[++i]=’\0’;<br>    return str;<br>&#125;<br>using namespace NS_LSEditDist;<br>int main()<br>&#123;<br>    vector&lt;vector&lt;string&gt;&gt; abs = &#123;<br>            &#123; &quot;water&quot;, &quot;wheat&quot; &#125;,<br>            &#123; &quot;servant&quot;, &quot;reveal&quot; &#125;<br>    &#125;;<br>    for (auto ab : abs)<br>    &#123;<br>        string a = ab[0];<br>        string b = ab[1];<br>        LSEditDistCaller(a, b);<br>    &#125;</p><pre><code>cout&amp;lt;&amp;lt;&amp;quot;两个100位字符串的LevenShtein距离：&amp;quot;&amp;lt;&amp;lt;endl;srand(time(NULL));int i;char name[LEN_NAME+1];string x = rand_str(name,LEN_NAME);string y = rand_str(name,LEN_NAME);cout&amp;lt;&amp;lt;&amp;quot;字符串1：&amp;quot;&amp;lt;&amp;lt;x&amp;lt;&amp;lt;endl;cout&amp;lt;&amp;lt;&amp;quot;字符串2：&amp;quot;&amp;lt;&amp;lt;y&amp;lt;&amp;lt;endl;LSEditDistCaller(x, y);</code></pre><p>}<br></code></pre></p><h2 id="RJs7f"><span class="ne-text">参考资料</span></h2><ul class="ne-ul"><li id="f334999207f869e2b2ef6c8458528f61"><a href="https://zh.wikipedia.org/wiki/%E8%90%8A%E6%96%87%E6%96%AF%E5%9D%A6%E8%B7%9D%E9%9B%A2" data-href="https://zh.wikipedia.org/wiki/%E8%90%8A%E6%96%87%E6%96%AF%E5%9D%A6%E8%B7%9D%E9%9B%A2" target="_blank" class="ne-link"><span class="ne-text">莱文斯坦距离</span></a></li><li id="36faa47bd0df5696577ae0214bd92488"><a href="https://www.dazhuanlan.com/2019/12/06/5dea0cb03281f/" data-href="https://www.dazhuanlan.com/2019/12/06/5dea0cb03281f/" target="_blank" class="ne-link"><span class="ne-text">理解 Levenshtein Distancee</span></a></li><li id="4a60131c436c156ea072cc4afa51c663"><a href="https://www.throwable.club/2020/03/08/learn-about-levenshtein-distance-algorithm/" data-href="https://www.throwable.club/2020/03/08/learn-about-levenshtein-distance-algorithm/" target="_blank" class="ne-link"><span class="ne-text">Levenshtein Distance（编辑距离）算法与使用场景</span></a></li></ul></div>]]></content>
      
      
      <categories>
          
          <category> 计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 🔢动态规划算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>利用WireShark捕获并分析以太网报文结构</title>
      <link href="/blog/bw80k6/"/>
      <url>/blog/bw80k6/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><div class="ne-quote"><p id="7f76e8a93084cc3bd1203ea842e80463" class="ne-p"><span class="ne-text">学习网络协议分析工具WireShark，利用WireShark捕获并分析以太网报文结构，最重要的是后面超星网登录案例分析，用实际例子将计网的所学知识串起来。</span></p></div><div class="ne-quote"><p id="483fc60921d2cb8c6e28ccf682601256" class="ne-p"><span class="ne-text">文章更新内容说明：无线上网和有线上网的MAC地址是不一样的</span></p><p id="542f6b8c4bef85750f8441adcb8f0b61" class="ne-p"><span class="ne-text">【查看本地地址的截图是在家里的查看，wireshark的使用是在学校】</span></p></div><p id="u846af37d" class="ne-p"><br></p><h2 id="oJyzb"><span class="ne-text">查看信息</span></h2><h3 id="batDK"><span class="ne-text">查看本地的mac地址</span></h3><p id="35d0a1f21db4bc7c3bc8b11f369bc572" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612839562082-cbc1fcf8-a520-4820-bafc-e26f07ba1177.png" width="960" id="ctz1g" class="ne-image"></p><p id="8cf1f24f09ab4ce3d5091569e56dbd32" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612839610832-5568023d-da16-41af-b95e-1787acadf747.png" width="667.5" id="gbTD4" class="ne-image"></p><h3 id="ZQKy5"><span class="ne-text">ping命令</span></h3><div class="ne-quote"><p id="0a8db97e13e25c87031ff1df3a98abf3" class="ne-p"><span class="ne-text">先使用ping命令找到需要抓包的网站的ip地址</span></p></div><p id="b348e59c5de96bfd78107335a4aa4e69" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612845955475-12f08386-5ec4-4b3f-8cbf-56059d79677c.png" width="414" id="wPIZW" class="ne-image"></p><h2 id="Zw1Iq"><span class="ne-text">WireShark使用</span></h2><h3 id="1Xcn3"><span class="ne-text">WireShark使用及面板功能区域</span></h3><p id="fa98de219118fb378ff82828fe9006c9" class="ne-p"><span class="ne-text">进入软件，若成功适配电脑网卡，则出现如下类似接口列表</span></p><p id="358c8fadfc38c1e8f0cc9fb2ea6321d3" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1603434019601-cc879af3-8784-4ada-83dc-642d64e02981.png" width="608" id="A49JU" class="ne-image"></p><p id="1e4fd55e1cf4991e3742ff8b35188327" class="ne-p" style="text-align: left"><span class="ne-text">直接双击上图中WLAN行即可抓包，也可以如下设置网卡启动抓包</span></p><p id="4b00f5e6301cc3f49309448ee54593b7" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1603434096441-73c67d75-4e36-4e76-ae3c-0a8b8976da28.png" width="634" id="VEwdC" class="ne-image"></p><p id="cc1c0b09556c84ce2a4810c4417e6026" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1603431676018-f4988b52-5aef-4d92-8b9b-15109a08adab.png" width="641" id="wQqBe" class="ne-image"></p><h3 id="CGYGl"><span class="ne-text">1区域-显示过滤器</span></h3><div class="ne-quote"><p id="55c603a7cecbc1e31135a88af4b0695c" class="ne-p"><span class="ne-text">为过滤ip地址区域。相关表达式语法有</span></p></div><ol class="ne-ol"><li id="285faedea56f60e2bf1d633a16edc188"><span class="ne-text">协议过滤。比如TCP，只显示TCP协议。</span></li><li id="b8c3ee5012ea92cd61208814567ec55b"><span class="ne-text">IP 过滤。比如 ip.src == 192.168.1.102,显示源地址为192.168.1.102，</span></li></ol><p id="eb5f60d8e1b6f401cb94dd65f16bf230" class="ne-p"><span class="ne-text">    ip.dst == 192.168.1.102, 目标地址为192.168.1.102。</span></p><ol start="3" class="ne-ol"><li id="f43ad1194c54db6141aab755159e47b8"><span class="ne-text">端口过滤。   tcp.port ==80,  端口为80的</span></li></ol><p id="ad8af10993aec72ea64e2579f3516b90" class="ne-p"><span class="ne-text">        tcp.srcport == 80,只显示TCP协议的愿端口为80的。</span></p><ol start="4" class="ne-ol"><li id="63c0219a2b5e2278fe8f7a416f0bfd0b"><span class="ne-text">Http模式过滤。http.request.method==&quot;GET&quot;,   只显示HTTP GET方法的。</span></li><li id="828b646a4d94632f9a6e92b8a275c186"><span class="ne-text">逻辑运算符为 AND/ OR</span></li></ol><h3 id="1fMmM"><span class="ne-text">2区域-获取的数据包</span></h3><div class="ne-quote"><p id="d0df4ea9d84c3ba8a2ef5af6c067492d" class="ne-p"><span class="ne-text">封包列表(Packet List Pane)</span></p></div><h3 id="sX7cp"><span class="ne-text">3区域-单个数据包各层详细内容</span></h3><div class="ne-quote"><p id="bbea5dd017f419081df244135164a278" class="ne-p"><span class="ne-text">选定的封包详细信息 (Packet Details Pane)</span></p></div><ol class="ne-ol"><li id="57e605ee544b17a27f91c692c50ec5dc"><span class="ne-text" style="color: #F5222D">Frame:物理层的数据帧概况。</span></li></ol><pre><code>Frame 165: 74 bytes on wire (592 bits), 74 bytes captured (592 bits) on interface \Device\NPF_&#123;B016AB5D-3088-41BD-8997-48F19D9DEBFA&#125;, id 0 //165号帧，对方发送74字节，实际收到74字节     Interface id: 0 (\Device\NPF_&#123;B016AB5D-3088-41BD-8997-48F19D9DEBFA&#125;) //接口id为0         Interface name: \Device\NPF_&#123;B016AB5D-3088-41BD-8997-48F19D9DEBFA&#125;        Interface description: WLAN    Encapsulation type: Ethernet (1) //封装类型     Arrival Time: Oct 23, 2020 13:37:43.372763000 中国标准时间//捕获日期和时间（中国标准时间）     [Time shift for this packet: 0.000000000 seconds]    Epoch Time: 1603431463.372763000 seconds    [Time delta from previous captured frame: 0.008472000 seconds]//与前一包时间间隔     [Time delta from previous displayed frame: 0.000000000 seconds]    [Time since reference or first frame: 36.349570000 seconds]//此包与第一帧的时间间隔    Frame Number: 165//帧序号     Frame Length: 74 bytes (592 bits)//帧长度     Capture Length: 74 bytes (592 bits)//捕获字节长度     [Frame is marked: False]//是否做了标记     [Frame is ignored: False]//是否被忽略     [Protocols in frame: eth:ethertype:ip:icmp:data]//帧内封装的协议层次结构     [Coloring Rule Name: ICMP]//着色标记的协议名称     [Coloring Rule String: icmp || icmpv6]//着色规则显示的字符串</code></pre><ol start="2" class="ne-ol"><li id="7a30f31ca568f601cb330100ba9fb7e7"><span class="ne-text" style="color: #F5222D">Ethernet II:数据链路层以太网帧头部信息。</span></li></ol><pre><code>Ethernet II, Src: IntelCor_fb:33:94 (0c:54:15:fb:33:94), Dst: HuaweiTe_da:ff:f3 (7c:a1:77:da:ff:f3)    Destination: HuaweiTe_da:ff:f3 (7c:a1:77:da:ff:f3)//目的MAC地址     Source: IntelCor_fb:33:94 (0c:54:15:fb:33:94)//源MAC地址（就是我电脑的MAC地址）     Type: IPv4 (0x0800)//0x0800表示使用IP协议</code></pre><p id="d99f5d6b708fcb626d50bbca01757bc5" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1603432754493-20843464-3bbb-4c01-9ceb-e781759a583d.png" width="960" id="JoqS9" class="ne-image"></p><ol start="3" class="ne-ol"><li id="9ff3eec3fe96bcffcd9cb5168103fd63"><span class="ne-text" style="color: #F5222D">Internet Protocol Version 4:互联网层IP包头部信息。</span></li></ol><pre><code>Internet Protocol Version 4, Src: 192.168.43.36, Dst: 39.156.66.18    0100 .... = Version: 4//互联网协议IPv4    .... 0101 = Header Length: 20 bytes (5)//IP包头部长度    Differentiated Services Field: 0x00 (DSCP: CS0, ECN: Not-ECT)//差分服务字段    Total Length: 60//IP包的总长度    Identification: 0xdf8c (57228)//标志字段    Flags: 0x0000//标记字段    Fragment offset: 0//分的偏移量    Time to live: 128//生存期TTL    Protocol: ICMP (1)//此包内封装的上层协议为TCP    Header checksum: 0x05ba [validation disabled]//头部数据的校验和    [Header checksum status: Unverified]    Source: 192.168.43.36//来源IP地址    Destination: 39.156.66.18//目标IP地址</code></pre><p id="20508231b2a2787b1d1ea1029c345645" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1603433033837-c88714a1-eaa1-45cb-b836-5672e4515eee.png" width="320" id="K9phM" class="ne-image"></p><ol start="4" class="ne-ol"><li id="e4be22a4d0c4f8e0b67c7be8e4e91770"><span class="ne-text" style="color: #F5222D">Transmission Control Protocol:传输层T的数据段头部信息，此处是TCP。</span></li></ol><pre><code>Transmission Control Protocol, Src Port: 80 (80), Dst Port: 50362 (50362), Seq: 1025, Ack: 447, Len: 714Source Port: 80 (80) //源端口号Destination Port: 50362 (50362) //目标端口号Sequence number: 1025 (relative sequence number) //序列号（相对序列号）[Next sequence number: 1739 (relative sequence number)] //下一个序列号Acknowledgment number: 447    (relative ack number) //确认序列号Header Length: 20 bytes  //头部长度.... 0000 0001 1000 = Flags: 0x018 (PSH, ACK) //TCP标记长度Window size value: 5896  //流量控制的窗口大小Checksum: 0x915b [validation disabled] //TCP数据段的校验和</code></pre><p id="b15538e2b44aff1c225daef842e5367c" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1603433149527-0125377e-b64b-4e32-9eb0-e122d0c111cb.png" width="289.5" id="R5Mls" class="ne-image"></p><ol start="5" class="ne-ol"><li id="4db6e77e82b1f3a4eff25f9a42178e87"><span class="ne-text" style="color: #F5222D">Hypertext Transfer Protocol:应用层的信息，此处是HTTP协议。</span></li></ol><p id="da4e8f8527b3023dc25a25c37cc87ab5" class="ne-p"><br></p><ol start="6" class="ne-ol"><li id="54a2b39754a8591a93d5438ea0b09342"><span class="ne-text" style="color: #F5222D">Data（312 bytes）：数据。</span></li></ol><p id="6972f071d3fbe559dbd5b5286eb02c5d" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1603434354567-45e84cc7-63a9-4136-adde-85c377345e92.png" width="813" id="EWPd6" class="ne-image"></p><h2 id="71BCN"><span class="ne-text">超星网登录案例分析</span></h2><h3 id="LTTI3"><span class="ne-text">网站请求和响应</span></h3><p id="75aefee6d41f432def583b317335cdd6" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612849248230-2f38b355-ee1f-4ee1-8b8a-291e64f4e1bd.png" width="960" id="mun7j" class="ne-image"></p><h3 id="0G2ii"><span class="ne-text">发送请求相应协议</span></h3><p id="b1fa9d0aed7d119e738df1b195566f3e" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612849740094-cbdefdda-f504-43f3-9e41-ac8dc8029fd3.png" width="960" id="FoSDc" class="ne-image"></p><h3 id="V55oa"><span class="ne-text">收到响应相应协议</span></h3><p id="d13a0e437b254f6bcf67656eebc023e4" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612849811431-437bd72d-ac54-4c28-b731-9e128b6b998f.png" width="959" id="kW7LF" class="ne-image"></p><div class="ne-quote"><p id="da9a5f2a31839f9fd37773017af15042" class="ne-p"><span class="ne-text">接下来的7个小节内容来具体对数据报头做出分析❗</span></p></div><h3 id="JA1F5"><span class="ne-text">Hypertext Transfer Protocol</span></h3><p id="d5a0569d34990a4bd7efde0442233906" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612849851243-b18b3e15-f21e-4998-bcfe-45c0b92aabde.png" width="960" id="U7606" class="ne-image"></p><div class="ne-quote"><p id="0a184dc93573f69a44ce7d5a430b037c" class="ne-p"><span class="ne-text">HTTP 协议定义了客户端和服务器之间交互的消息内容和步骤，大家按照固定的步骤和格式进行通信</span></p><p id="3063fd4e006703c1ee2275705845cab6" class="ne-p"><span class="ne-text">根据URL可以定位请求资源的位置，但是对于这个资源可能还有多种处理方法，比如是请求资源还是要删除指定资源？</span></p></div><p id="ee891ecf6b864e3d18cdeebc0dd721f1" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612851558692-ed870a9e-f619-4235-bb98-85d22557340f.png" width="960" id="AtlPY" class="ne-image"></p><p id="9d3dd303e0d8f0cc2ad21fa8bed4193c" class="ne-p"><span class="ne-text">这个时候</span><strong><span class="ne-text">浏览器</span></strong><span class="ne-text">将需要请求的信息，按照HTTP协议约定的格式，封装成为HTTP请求报文</span></p><p id="8e66507c1adba2e9d97d7deff2742256" class="ne-p"><span class="ne-text">HTTP主要请求方法为 GET 和 POST</span></p><p id="1ec2199fef69997b754da0850e31b2a1" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612851687862-c1a44f57-065b-4547-93bb-4ae9b1f9cb95.png" width="346.5" id="j4FRd" class="ne-image"></p><div class="ne-quote"><p id="3db622fedd5dd7c59a1cf2508fa3729f" class="ne-p"><span class="ne-text">请求报文和响应报文的具体形式参考课本</span></p></div><h3 id="w0nqa"><span class="ne-text">Line-based text data</span></h3><p id="acd78ccc6fafd19cd16cf613a658da46" class="ne-p"><span class="ne-text">这里面内容就是请求成功所返回的Html代码</span></p><p id="10408f86909761c20966effe0a6cdb93" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612851995920-233bc149-948d-43e1-a549-fc2887c23163.png" width="960" id="BoWGc" class="ne-image"></p><h3 id="Kt97I"><span class="ne-text">Transmission Control Protocol</span></h3><p id="6214a23a4ae50bf55e14e7af5ff422dd" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612852359910-50409417-8113-4600-bbb6-6d0e02db4894.png" width="960" id="Ja3wE" class="ne-image"></p><p id="c33eb87ecff11f2745b9977786d3a2df" class="ne-p"><span class="ne-text">这个数据报传输使用的可靠的TCP协议，而不是UDP，所以会有相应的滑动窗口、流量控制等等相关机制，还有三次握手，四次挥手……</span></p><p id="1f6cc3d7a0f9bfea84bd32f1d46ad733" class="ne-p"><span class="ne-text">（插个眼，日后再复习一下……）</span></p><p id="f122a3c15130065fea8ba8437479ba98" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/gif/1484158/1612852762215-ba49fa51-55e0-440d-afa7-b567540e39a2.gif" width="218" id="Wnesc" class="ne-image"></p><p id="91620e41543360b96857863946dda522" class="ne-p"><span class="ne-text">（插眼专用图/滑稽）</span></p><h3 id="41wDc"><span class="ne-text">Internet Protocol Version 4</span></h3><p id="ef5a852c4c7bebc8f9ce82641870ad8e" class="ne-p"><span class="ne-text">好了，接下来到了IP层，需要给上面来的数据报加上IP头部，IP数据报结构如下：</span></p><p id="0731b26a1e6c3ad160fe123905554b55" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612853140617-ff243167-abb7-4c65-b5c3-b0bbaa77b5aa.png" width="446" id="inliL" class="ne-image"></p><p id="4c7e0c411f2e50dea19af40f6c166e76" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612853444183-7fa048ef-3e75-4586-82a7-ac9cc58c3630.png" width="960" id="uodGK" class="ne-image"></p><p id="147230e658b8beddd38ad140f0ba7556" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612852425531-82ec984f-ac3b-4f8a-a06e-0c48080815f6.png" width="960" id="ixgOl" class="ne-image"></p><p id="a6e478f2600c4aa706ae3f70701baa45" class="ne-p"><span class="ne-text">比如说</span><code class="ne-code"><span class="ne-text">45 </span></code><span class="ne-text">这个字节这具体表现是ip数据报的第一行和第二行的具体信息，IP版本为IPv4，报头长度为二十个字节，往后的各个字段都是这样一一对应的关系，具体还要加强对那张ip数据报结构图的理解，要了然于胸。</span></p><h3 id="vKnIg"><span class="ne-text">Ethernet II, Src</span></h3><p id="685a52a31e8df273d5bdb2d1ba2344b8" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612853924295-ea6fe64c-bc90-4e49-ad4e-5ff212448fdc.png" width="452" id="lBSIK" class="ne-image"></p><p id="f1ca664128e3df6a651637d36f6557a0" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612850191706-18807d7d-16b5-44fa-a436-5c2b7c4ed5ed.png" width="960" id="yU23P" class="ne-image"></p><div class="ne-quote"><p id="12b13bd6786e930e7cd17c39908451a7" class="ne-p" style="text-align: left"><span class="ne-text">图中三个方框的14个字节对应以太网MAC帧的前14个字节：前6个字节是目的地址，接下来的6个字节是源地址，最后两个字节是类型字段(用来标志上一层使用的是什么协议，以便把收到的MAC帧的数据交给上一层的这个协议。0x8000代表上层使用的是IP数据报)，后面是数据部分。</span></p><p id="09f9916c2b48c349b53c26ec64d712be" class="ne-p"><span class="ne-text">另外：wireshark把8字节的前序（前同步码）和4字节的FCS（帧开始界定符）都给过滤掉了，所以捕获到的帧里看不到这两部分。</span></p></div><h3 id="2QvJK"><span class="ne-text">Frame 75</span></h3><p id="7c2bdc1183114f8020222dd1d6392462" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612852486656-87756b19-ff3d-4833-9af9-d2006a401068.png" width="960" id="gaYxa" class="ne-image"></p><ul class="ne-ul"><li id="8ad34ce80451781402eeb842fba3b836"><span class="ne-text">对方发送5520字节，实际收到5520字节</span></li><li id="224ee446863c116125f2a48f36c1b91c"><span class="ne-text">第一行表示接口位0号</span></li></ul><h3 id="oeNHm"><span class="ne-text">总体数据表示</span></h3><p id="dd6ccf5512fccc15209d0583d52f8362" class="ne-p"><span class="ne-text">其实在计算机看来，网络中的数据传输就是传输下面的这些字节</span></p><div class="ne-quote"><p id="b838ea6f2d333781d1eb8714b5476a44" class="ne-p"><span class="ne-text">一个字节由八个位组成，而位就是我们通常所说的二进制中的0或1</span></p></div><p id="a944ca7be0a0e0f2900b763ee32af5f8" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612852578885-9519d1d0-a72d-409b-a480-f8554b87fd0d.png" width="959" id="BmzUj" class="ne-image"></p><h2 id="XFqxp"><span class="ne-text">后记</span></h2><h3 id="bRCHY"><span class="ne-text">Wireshark 抓不到HTTPS数据包</span></h3><div class="ne-quote"><p id="bbd3cba14f9102cbeb9483144e8f79c5" class="ne-p"><span class="ne-text">有些时候HTTP包也抓不到抑或是抓的不全，用如下方式解决即可。</span></p></div><p id="c43d74a0502c52adc94c89d66a4ce293" class="ne-p"><span class="ne-text">在C盘根目录下创建如下目录和文件，.log就是后缀不要txt</span></p><p id="5684d1f9cf60f3c415e924c1c24d684b" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612847971131-6c3c2084-c6d8-41ae-8a82-8a4df65748b8.png" width="405.5" id="MTMvQ" class="ne-image"></p><p id="bc4a18221495485ee9926d7264e6a76f" class="ne-p"><span class="ne-text">添加环境变量</span></p><p id="8a4e3d09482be0cb3966bdf62c046f3f" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612848066208-6f22250b-e74d-4156-aa31-c5de17d2e812.png" width="484" id="SJvIm" class="ne-image"></p><p id="929a0d53efd15ff230fc090f3750a7bf" class="ne-p"><span class="ne-text">进入wireshark软件</span></p><p id="e4bc3833b6e6e97b5a7ac398208efc15" class="ne-p"><code class="ne-code"><span class="ne-text">编辑 </span></code><code class="ne-code"><span class="ne-text">首选项</span></code><span class="ne-text"> </span><code class="ne-code"><span class="ne-text">Protocols</span></code></p><p id="8dcceb0603ce39e060374186028b2f6b" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612848155164-ace1e002-1971-4910-8d04-cf9c388eb5cd.png" width="681" id="ccyel" class="ne-image"></p><h3 id="KVsMi"><span class="ne-text">参考资料</span></h3><ul class="ne-ul"><li id="8be9e4995ac78bca3845b353eba314d7"><a href="https://www.cnblogs.com/linyfeng/p/9496126.html" data-href="https://www.cnblogs.com/linyfeng/p/9496126.html" target="_blank" class="ne-link"><span class="ne-text">wireshark抓包新手使用教程</span></a></li><li id="b6d8694534be197c58bd29958a938c2c"><a href="https://zhuanlan.zhihu.com/p/82498482" data-href="https://zhuanlan.zhihu.com/p/82498482" target="_blank" class="ne-link"><span class="ne-text">https://zhuanlan.zhihu.com/p/82498482</span></a></li><li id="01a33d33cac36d91474456fa7143680e"><a href="https://zhuanlan.zhihu.com/p/264942536" data-href="https://zhuanlan.zhihu.com/p/264942536" target="_blank" class="ne-link"><span class="ne-text">https://zhuanlan.zhihu.com/p/264942536</span></a></li><li id="9f988f01118465c675c266195d220c2f"><a href="https://blog.csdn.net/zam183/article/details/103783785" data-href="https://blog.csdn.net/zam183/article/details/103783785" target="_blank" class="ne-link"><span class="ne-text">https://blog.csdn.net/zam183/article/details/103783785</span></a></li><li id="a07301b383f225ea1c853cbfeb683b38"><span class="ne-text">TODO: </span><a href="https://www.cnblogs.com/zhaopei/p/12152139.html#autoid-2-6" data-href="https://www.cnblogs.com/zhaopei/p/12152139.html#autoid-2-6" target="_blank" class="ne-link"><span class="ne-text">Wireshark抓包，带你快速入门</span></a></li><li id="0ca6bbfae534b48adc8e57d6d082108d"><span class="ne-text">TODO: </span><a href="https://www.cnblogs.com/noteless/p/10256470.html#21" data-href="https://www.cnblogs.com/noteless/p/10256470.html#21" target="_blank" class="ne-link"><span class="ne-text">网络是如何连接的？网络发展简介（四）</span></a></li></ul></div>]]></content>
      
      
      <categories>
          
          <category> 计算机素养 </category>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ping、traceroute命令编程实现</title>
      <link href="/blog/qlrcf6/"/>
      <url>/blog/qlrcf6/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h3 id="NcA1c"><span class="ne-text">ping和tracert命令</span></h3><p id="u99edc073" class="ne-p"><br></p><p id="e1e4c2d83c19f3cbcdd3e821665410f2" class="ne-p"><strong><span class="ne-text">ping</span></strong><span class="ne-text">命令一般用来测试两台机器或者机器和服务器之间网络是否连通。</span></p><p id="99d7c143653b8aee0e100c60af247f91" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1603437323252-a3bf1470-c4ae-450a-b0fd-4d83281aab46.png" width="719.5" id="iYLwF" class="ne-image"></p><p id="74ee36d8d4fff217167eaf6fda55ce4e" class="ne-p"><strong><span class="ne-text">tracert</span></strong><span class="ne-text">命令显示数据报到达目标主机途中所经过的路径（路由器），并且显示到达每个节点（路由器）的花费时间，显示的信息比ping出来的信息要多，要详细。</span></p><p id="826ccd031113feeba65616a9453a7b78" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1603437358485-aef50645-6ff9-4395-bbae-0bfe22ce3dc1.png" width="718" id="E5tYJ" class="ne-image"></p><h3 id="ehxra"><span class="ne-text">编程实现</span></h3><h4 id="ccfCW"><span class="ne-text">Code</span></h4><pre><code>import java.net.InetAddress;import java.net.MalformedURLException;import java.net.URL;import java.net.UnknownHostException;<p>import java.io.BufferedReader;<br>import java.io.IOException;<br>import java.io.InputStream;<br>import java.io.InputStreamReader;</p><p>import java.util.Scanner;</p><p>public class CommandUtil &#123;</p><pre><code>String tracert = &amp;quot;tracert -h 10 &amp;quot;; //模拟tracert命令String ping = &amp;quot;ping&amp;quot;;//模拟 ping 命令String routePrint = &amp;quot;route print -4&amp;quot;;//模拟route print命令public static void main(String args[])&#123;    String input = null;    @SuppressWarnings(&amp;quot;resource&amp;quot;)    Scanner scanner = new Scanner(System.in);    //利用while循环接收输入的命令行参数    while(true)&#123;        System.out.println(&amp;quot;Please input destination server IP address ：\n&amp;quot;);        input = scanner.next();        CommandUtil host = new CommandUtil();        host.tracert = host.tracert + &amp;quot; &amp;quot; + input;        host.ping = host.ping + &amp;quot; &amp;quot; + input;        try &#123;            host.command(host.routePrint);        &#125; catch (IOException exception) &#123;            exception.printStackTrace();        &#125;        try &#123;            host.command(host.tracert) ;        &#125; catch (IOException exception) &#123;            exception.printStackTrace();        &#125;        try &#123;            host.command(host.ping);        &#125; catch (IOException exception) &#123;            exception.printStackTrace();        &#125;        InetAddress ipAddress;        try &#123;            ipAddress = InetAddress.getByName(input);            System.out.println(&amp;quot;IP address : &amp;quot;+ipAddress);        &#125; catch (UnknownHostException exception) &#123;            exception.printStackTrace();        &#125;        URL url;        try &#123;            url = new URL(&amp;quot;http&amp;quot;,input,80,&amp;quot;index.html&amp;quot;);            System.out.println();//输出服务器地址            System.out.println(&amp;quot;Get the Server-Name# : &amp;quot;+url.getHost());            System.out.println();//输出首页文件            System.out.println(&amp;quot;Get the default file# : &amp;quot;+url.getFile());            System.out.println();//输出首页协议和端口            System.out.println(&amp;quot;Get the protocol# : &amp;quot;+url.getProtocol()+&amp;quot; &amp;quot;+url.getPort());            System.out.println();        &#125; catch (MalformedURLException e) &#123;            e.printStackTrace();        &#125;        System.out.println();        try &#123;            System.out.println(&amp;quot;Get serverName &amp;amp; IPAddress：&amp;quot;+InetAddress.getByName(input));        &#125; catch (UnknownHostException e) &#123;            e.printStackTrace();        &#125;        long freeMemory = Runtime.getRuntime().freeMemory();        System.out.println(&amp;quot;Surplus memory of JVM: &amp;quot;+freeMemory+&amp;quot;B&amp;quot;);    &#125;&#125;//模拟 tracert 命令StringBuffer commandResult = null;private void command(String tracerCommand) throws IOException&#123;    //第一步：创建进程(是接口不必初始化)    //1.通过Runtime类的getRuntime().exec()传入需要运行的命令参数    System.out.println();    System.out.println(InetAddress.getByName(&amp;quot;localhost&amp;quot;)+&amp;quot; is tracking the destination server...&amp;quot;);    Process process = Runtime.getRuntime().exec(tracerCommand);    readResult(process.getInputStream());    process.destroy();&#125;//第二步：通过输入流来将命令执行结果输出到控制台private void readResult(InputStream inputStream) throws IOException&#123;    commandResult = new StringBuffer();  //初始化命令行    String commandInfo = null; //定义用于接收命令行执行结果的字符串    BufferedReader bufferedReader =            new BufferedReader(new InputStreamReader(inputStream));    while ( (commandInfo = bufferedReader.readLine()) != null)  &#123;        System.out.println(commandInfo);    &#125;    bufferedReader.close();&#125;</code></pre><p>}<br></code></pre></p><h4 id="qhQAd"><span class="ne-text">Result</span></h4><pre><code>D:\Java\jdk1.8.0_181\bin\java.exe &quot;-javaagent:D:\JetBrains\IntelliJ IDEA 2020.1.3\lib\idea_rt.jar=39614:D:\JetBrains\IntelliJ IDEA 2020.1.3\bin&quot; -Dfile.encoding=GBK -classpath D:\Java\jdk1.8.0_181\jre\lib\charsets.jar;D:\Java\jdk1.8.0_181\jre\lib\deploy.jar;D:\Java\jdk1.8.0_181\jre\lib\ext\access-bridge-64.jar;D:\Java\jdk1.8.0_181\jre\lib\ext\cldrdata.jar;D:\Java\jdk1.8.0_181\jre\lib\ext\dnsns.jar;D:\Java\jdk1.8.0_181\jre\lib\ext\jaccess.jar;D:\Java\jdk1.8.0_181\jre\lib\ext\jfxrt.jar;D:\Java\jdk1.8.0_181\jre\lib\ext\localedata.jar;D:\Java\jdk1.8.0_181\jre\lib\ext\nashorn.jar;D:\Java\jdk1.8.0_181\jre\lib\ext\sunec.jar;D:\Java\jdk1.8.0_181\jre\lib\ext\sunjce_provider.jar;D:\Java\jdk1.8.0_181\jre\lib\ext\sunmscapi.jar;D:\Java\jdk1.8.0_181\jre\lib\ext\sunpkcs11.jar;D:\Java\jdk1.8.0_181\jre\lib\ext\zipfs.jar;D:\Java\jdk1.8.0_181\jre\lib\javaws.jar;D:\Java\jdk1.8.0_181\jre\lib\jce.jar;D:\Java\jdk1.8.0_181\jre\lib\jfr.jar;D:\Java\jdk1.8.0_181\jre\lib\jfxswt.jar;D:\Java\jdk1.8.0_181\jre\lib\jsse.jar;D:\Java\jdk1.8.0_181\jre\lib\management-agent.jar;D:\Java\jdk1.8.0_181\jre\lib\plugin.jar;D:\Java\jdk1.8.0_181\jre\lib\resources.jar;D:\Java\jdk1.8.0_181\jre\lib\rt.jar;D:\project-java\jiwang\out\production\jiwang CommandUtilPlease input destination server IP address ：<p>baidu.com</p><h1 id="localhost-127-0-0-1-is-tracking-the-destination-server…"><a href="#localhost-127-0-0-1-is-tracking-the-destination-server…" class="headerlink" title="localhost/127.0.0.1 is tracking the destination server…"></a>localhost/127.0.0.1 is tracking the destination server…</h1><p>接口列表<br>  6…b4 b6 86 df cc 9d ……Realtek PCIe GbE Family Controller<br> 11…0c 54 15 fb 33 95 ……Microsoft Wi-Fi Direct Virtual Adapter<br> 14…0e 54 15 fb 33 94 ……Microsoft Wi-Fi Direct Virtual Adapter #2<br> 16…0c 54 15 fb 33 94 ……Intel(R) Dual Band Wireless-AC 3168<br> 17…0c 54 15 fb 33 98 ……Bluetooth Device (Personal Area Network)<br>  1………………………Software Loopback Interface 1<br>===========================================================================</p><h1 id="IPv4-路由表"><a href="#IPv4-路由表" class="headerlink" title="IPv4 路由表"></a>IPv4 路由表</h1><p>活动路由:<br>网络目标        网络掩码          网关       接口   跃点数<br>          0.0.0.0          0.0.0.0      192.168.2.1    192.168.2.132     35<br>        127.0.0.0        255.0.0.0            在链路上         127.0.0.1    331<br>        127.0.0.1  255.255.255.255            在链路上         127.0.0.1    331<br>  127.255.255.255  255.255.255.255            在链路上         127.0.0.1    331<br>      192.168.2.0    255.255.255.0            在链路上     192.168.2.132    291<br>    192.168.2.132  255.255.255.255            在链路上     192.168.2.132    291<br>    192.168.2.255  255.255.255.255            在链路上     192.168.2.132    291<br>        224.0.0.0        240.0.0.0            在链路上         127.0.0.1    331<br>        224.0.0.0        240.0.0.0            在链路上     192.168.2.132    291<br>  255.255.255.255  255.255.255.255            在链路上         127.0.0.1    331<br>  255.255.255.255  255.255.255.255            在链路上     192.168.2.132    291<br>===========================================================================<br>永久路由:<br>  无</p><p>localhost/127.0.0.1 is tracking the destination server…</p><p>通过最多 10 个跃点跟踪<br>到 baidu.com [39.156.69.79] 的路由:</p><p>  1     1 ms     1 ms     1 ms  RM2100.lan [192.168.2.1]<br>  2     *        *        *     请求超时。<br>  3     *        *        *     请求超时。<br>  4     4 ms     3 ms     3 ms  192.168.100.253<br>  5     4 ms     5 ms    10 ms  192.168.100.114<br>  6     3 ms     3 ms     3 ms  192.168.100.118<br>  7     *        *        *     请求超时。<br>  8     *        *        *     请求超时。<br>  9     *        *        *     请求超时。<br> 10     *        *        *     请求超时。</p><p>跟踪完成。</p><p>localhost/127.0.0.1 is tracking the destination server…</p><p>正在 Ping baidu.com [39.156.69.79] 具有 32 字节的数据:<br>来自 39.156.69.79 的回复: 字节=32 时间=20ms TTL=48<br>来自 39.156.69.79 的回复: 字节=32 时间=20ms TTL=48<br>来自 39.156.69.79 的回复: 字节=32 时间=20ms TTL=48<br>来自 39.156.69.79 的回复: 字节=32 时间=20ms TTL=48</p><p>39.156.69.79 的 Ping 统计信息:<br>    数据包: 已发送 = 4，已接收 = 4，丢失 = 0 (0% 丢失)，<br>往返行程的估计时间(以毫秒为单位):<br>    最短 = 20ms，最长 = 20ms，平均 = 20ms<br>IP address : baidu.com/39.156.69.79</p><p>Get the Server-Name# : baidu.com</p><p>Get the default file# : index.html</p><p>Get the protocol# : http 80</p><p>Get serverName &amp; IPAddress：baidu.com/39.156.69.79<br>Surplus memory of JVM: 124194640B<br></code></pre></p></div>]]></content>
      
      
      <categories>
          
          <category> 计算机素养 </category>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>继承和多态</title>
      <link href="/blog/bn6afv/"/>
      <url>/blog/bn6afv/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h2 id="awvbQ"><span class="ne-text">extends和super</span></h2><ul class="ne-ul"><li id="33f2fdc852defe16759be1d814e3a3b3"><span class="ne-text">子类继承父类用关键字 </span><code class="ne-code"><span class="ne-text">extends</span></code><span class="ne-text"> </span></li><li id="42279eac9187a3930ee60ef102ade2c4"><span class="ne-text">super关键字作用有</span></li></ul><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="7a340188d733c2369699ab23faa24116"><span class="ne-text">继承父类的构造函数</span></li><li id="5072468ec0e6bbca672185b375980339"><span class="ne-text">构造方法链</span></li><li id="8a2f589ca8bdad475920826d2bf2d55a"><span class="ne-text">调用父类的方法（一般不怎么用）</span></li></ul></ul><h2 id="fzQA3"><span class="ne-text">方法重写和方法重载</span></h2><div class="ne-quote"><p id="2e1b332c486bbbe798aed425ce35394a" class="ne-p"><span class="ne-text">方法重写注意要子类和父类的方法都得是一样的签名和返回类型</span></p></div><p id="b234490804163988d22e1541658a4c24" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1600089343780-c8d0a28c-dc06-4aab-a331-9ac926a65498.png" width="382" id="kHlhK" class="ne-image"></p><p id="3490a4a668d38b032dbad5ea2ab9aa40" class="ne-p" style="text-align: center"><br></p><p id="f53e36aef60ceb65730aa77f7122ad4d" class="ne-p" style="text-align: left"><span class="ne-text">为了避免编写程序过程中方法重载和方法重写的误用，使用</span><strong><span class="ne-text">重写标注 </span></strong><code class="ne-code"><strong><span class="ne-text">@Override</span></strong></code><span class="ne-text"> 来区分，</span><span class="ne-text">系统可以检查方法的正确性。</span></p><h2 id="Ldp8q"><span class="ne-text">Object类</span></h2><div class="ne-quote"><p id="734b6ce2d3cd881f5850e80337a57e10" class="ne-p"><span class="ne-text">java中所有类都继承子java.lang.Object类，其中toString就是该类里面的方法之一，所有许多接口/类都会重写这个方法，手写的链表里面的该方法就是重写之后的方法</span></p></div><h2 id="tfo9C"><span class="ne-text">多态与动态绑定</span></h2><div class="ne-quote"><p id="4e13fc2a801a8c2bb100755fe12b0ef4" class="ne-p"><span class="ne-text">多态</span></p></div><p id="f9cb595476fadfa835c2c66852310ae4" class="ne-p"><span class="ne-text">使用夫类对象的地方都可以使用子类对象。也就意味着父类的变量可以引用子类型的对象</span></p><p id="88119842b402d6e8bc568bbdf31594f4" class="ne-p"><br></p><div class="ne-quote"><p id="330f677d9ad5604363423dbd31db6576" class="ne-p"><span class="ne-text">动态绑定</span></p></div><p id="abaa02ebf8ae1138a5d319cc70362b90" class="ne-p"><span class="ne-text">如果定义了一个父类的对象，该对象调用了一个方法，该方法不存在父类当中，但是存在其父类下面的多个子类当中，那么这个方法调用的是哪个子类当中的该方法呢？JVM有这么一个机制，从“辈分最小的类”依次往上找，第一个找到含有该方法的类，则调用该类当中的那个方法</span></p><p id="805dc9df1323d3f74035b8902e515dbf" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1600138148812-5cc991ce-0577-4f01-b57c-bec631518a99.png" width="483" id="IXvxo" class="ne-image"></p><p id="d55d06ce4d5a7898f2e1be516ada4888" class="ne-p" style="text-align: center"><span class="ne-text">注：Cn为父类，往后都是以此继承的子类</span></p><h2 id="uGszw"><span class="ne-text">对象转换</span></h2><div class="ne-quote"><p id="69f7077a82c94d3b61bcdede74a44d8b" class="ne-p"><span class="ne-text">向下转换与向上转换</span></p></div><pre><code>Object o = new Student(); // 可以：因为Student的实例也是Object的实例<p>Student a = o; // (o是Object对象)不可以：因为“级别”的不可逆</p><p>Student s = Student(o); //向上转换<br></code></pre></p><div class="ne-quote"><p id="1d6d234ffa5f55964237e1f68e817c6b" class="ne-p"><span class="ne-text">instanceof</span></p></div><p id="6d2d1eec3ffc9daecc6871dcd0e993ab" class="ne-p"><span class="ne-text">如果一个对象不是Student实例，他就不能转换成Student类型的变量，会报错 </span><code class="ne-code"><span class="ne-text">ClassCastException</span></code><span class="ne-text"> 。因此，在此之前最好先确保该对象是另一个对象的实例，于是用到关键字 </span><code class="ne-code"><span class="ne-text">instanceof</span></code></p><p id="c7ab37ffd3c4c3387a5cd8c7ca7fbe7d" class="ne-p"><br></p><pre><code>Object myObject = new Circle();... // Some lines of code/** Perform casting if myObject is an instance of Circle */if (myObject instanceof Circle) &#123;  System.out.println(&quot;The circle diameter is &quot; +     ((Circle)myObject).getDiameter());  ...&#125;</code></pre><h2 id="Gn1ts"><span class="ne-text">@override </span></h2><p id="b6a2ac362a45bb4786300ef30246340f" class="ne-p"><span class="ne-text">在重写父类的函数时，在方法前面加上</span><a href="https://www.yuque.com/Override" data-href="https://www.yuque.com/Override" target="_blank" class="ne-link"><span class="ne-text">@Override </span></a><span class="ne-text"> 系统可以帮你检查方法的正确性。 </span></p></div>]]></content>
      
      
      <categories>
          
          <category> 计算机素养 </category>
          
          <category> 后端编程语言 </category>
          
          <category> JAVA </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>抽象类和接口</title>
      <link href="/blog/akog9h/"/>
      <url>/blog/akog9h/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h2 id="71IRy"><span class="ne-text">概念名词</span></h2><ul class="ne-ul"><li id="56be3051b397ee4e3350ab3537f79f53"><strong><span class="ne-text">接口</span></strong><span class="ne-text">：许多类的</span><strong><span class="ne-text" style="text-decoration: underline">共同行为</span></strong><span class="ne-text">（包含非相关类），就当与给客户看的。</span></li><li id="5ae9c8c840f173e8686cfb045e963cbe"><strong><span class="ne-text">抽象类</span></strong><span class="ne-text">：就相当于一个父类，该父类</span><span class="ne-text" style="text-decoration: underline">包含其子类的</span><strong><span class="ne-text" style="text-decoration: underline">共性</span></strong><span class="ne-text" style="text-decoration: underline">特征</span><span class="ne-text">，就像是子类园和子类长方形，两个类可以有一个共同的父类，该父类定义为抽象类，其包含一个</span><strong><span class="ne-text">抽象方法</span></strong><span class="ne-text">，比如求面积或是求周长</span></li></ul><p id="u234ed369" class="ne-p"><span class="ne-text"></span></p><h2 id="QidSb"><span class="ne-text">接口的一些要点</span></h2><div class="ne-quote"><p id="2e71e13d39166690040117cfbb79f878" class="ne-p"><code class="ne-code"><span class="ne-text">public interface List&lt;E&gt; &#123; &#125;</span></code></p></div><ul class="ne-ul"><li id="5b267cd5a5a4613b7530fdce1f22c3bb"><span class="ne-text" style="text-decoration: underline">接口是一个</span><strong><span class="ne-text" style="text-decoration: underline">写注释</span></strong><span class="ne-text" style="text-decoration: underline">的好地方</span></li></ul><h2 id="4CIZ1"><span class="ne-text">抽象类的一些要点</span></h2><div class="ne-quote"><p id="648dc79d06d9abca3ca7067042c1a727" class="ne-p"><code class="ne-code"><span class="ne-text">public abstract class AbstractList&lt;E&gt; implements List&lt;E&gt; &#123; &#125;</span></code></p><p id="a72eca167583562b0ffc45a6facde8f9" class="ne-p"><code class="ne-code"><span class="ne-text">public abstract class Test()&#123;&#125;</span></code></p><p id="50deb558e6899de244bfc879275786f8" class="ne-p"><code class="ne-code"><span class="ne-text">public abstract double getTest()&#123;&#125;</span></code></p></div><p id="761ea2dde749381118ca01c700d8593d" class="ne-p"><br></p><ul class="ne-ul"><li id="3d1a189f1f5f548c0031b9511076d864"><span class="ne-text">抽象类当中的</span><strong><span class="ne-text" style="text-decoration: underline">抽象方法</span></strong><span class="ne-text">要在其子类当中实现，因为抽象类“抽象”的以至于没有实例</span></li><li id="c643d6237801e0dad70a276f54b5407b"><span class="ne-text">包含抽象方法的类必定是抽象类</span></li><li id="cfc0a5b0c70f698d5661d151beea4634" style="text-align: left"><strong><span class="ne-text">抽象类的构造函数实现要加上protected，因为其构造函数只被其子类所使用，在创建子类实例的时候，其父类构造函数被调用来初始化该父类的数据域</span></strong></li><li id="777886b062fa283774548ced3c169d28" style="text-align: left"><strong><span class="ne-text">抽象类不可以new对象，不对外公开，只抽取公共代码，eg：ArrayList和LinkedList</span></strong></li><li id="7b1abbaeac5702e01e6fe3727f25e70e" style="text-align: left"><strong><span class="ne-text">抽象类可以不是先接口里面的部分函数</span></strong></li><li id="4d43a90062534514213584d9ceeff945" style="text-align: left"><strong><span class="ne-text">抽象类作用：放“公共代码”</span></strong></li></ul><p id="01e94bef717cf7f6acf8d25a4e55e0ea" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598686636557-2700f743-9f28-435a-b771-86bdf7b2b25c.png" width="416" id="SYEBn" class="ne-image"></p><p id="bf49b5b59c1eff4bf0f2235986f632ae" class="ne-p"><br></p><p id="8b0fc585cae133d0117b3fabfab5834a" class="ne-p"><br></p></div>]]></content>
      
      
      <categories>
          
          <category> 计算机素养 </category>
          
          <category> 后端编程语言 </category>
          
          <category> JAVA </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JAVA队列设计</title>
      <link href="/blog/zqmygi/"/>
      <url>/blog/zqmygi/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h2 id="LaKGf"><span class="ne-text">Queue队列设计</span></h2><div class="ne-quote"><p id="ac52ddc375fb2102c6135f5574ffbc64" class="ne-p"><span class="ne-text">在头尾两端进行操作，先进先出FIFO</span></p></div><p id="3e5326d211f6e4b86271a61fb80d22ac" class="ne-p"><span class="ne-text">队列的接口设计</span></p><p id="ud2eeb6ba" class="ne-p"><span class="ne-text"></span></p><p id="u343a0a17" class="ne-p"><span class="ne-text"></span></p><pre><code>int size(); //队列元素个数boolean isEmpty(); //队列是否为空void clear(); //清空队列元素void enQueue(E element); //入队E deQueue(); // 出队E front(); //获取队列的头元素</code></pre><pre><code>package com.wztlink1013.ds.queue;import com.wztlink1013.ds.queue.list.LinkedList;import com.wztlink1013.ds.queue.list.List;public class Queue&lt;E&gt; &#123;    private List&lt;E&gt; list = new LinkedList&lt;&gt;();    public int size() &#123;        return list.size();    &#125;    public boolean isEmpty() &#123;        return list.isEmpty();    &#125;    public void clear() &#123;        list.clear();    &#125;    public void enQueue(E element) &#123;        list.add(element);    &#125;    public E deQueue() &#123;        return list.remove(0);    &#125;    public E front() &#123;        return list.get(0);    &#125;&#125;</code></pre><h2 id="TZeCs"><span class="ne-text">Deque双端队列设计</span></h2><div class="ne-quote"><p id="af7aaae0a02d7ec3a05c28f48a5a7e0d" class="ne-p"><span class="ne-text">双端队列是能在头尾两端添加、删除的队列</span></p></div><pre><code>package com.wztlink1013.ds.queue;<p>import com.wztlink1013.ds.queue.list.LinkedList;<br>import com.wztlink1013.ds.queue.list.List;</p><p>public class Deque&lt;E&gt; &#123;<br>    private List&lt;E&gt; list = new LinkedList&lt;&gt;();</p><pre><code>public int size() &#123;    return list.size();&#125;public boolean isEmpty() &#123;    return list.isEmpty();&#125;public void clear() &#123;    list.clear();&#125;public void enQueueRear(E element) &#123;    list.add(element);&#125;public E deQueueFront() &#123;    return list.remove(0);&#125;public void enQueueFront(E element) &#123;    list.add(0, element);&#125;public E deQueueRear() &#123;    return list.remove(list.size() - 1);&#125;public E front() &#123;    return list.get(0);&#125;public E rear() &#123;    return list.get(list.size() - 1);&#125;</code></pre><p>}<br></code></pre></p></div>]]></content>
      
      
      <categories>
          
          <category> 计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 📶线结构：字符串-数组-栈-队列 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++顺序表设计</title>
      <link href="/blog/nlhg88/"/>
      <url>/blog/nlhg88/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><div data-type="info" class="ne-alert"><p id="17b89f0817a52e14ae8000bacb0a5935" class="ne-p"><span class="ne-text">类似一个简易版本的数组</span></p></div><h2 id="Qlc9m"><span class="ne-text">代码</span></h2><ul class="ne-tl"><li checked="true" id="63ca34a96f85b4dd1e58bcd2f6106ad9"><span class="ne-text">顺序表存储形式</span></li></ul><pre><code>/* 顺序表的存储形式就是连续存储空间，地址连续的，其实就是数组 */typedef struct &#123;    int *arr;    int length;&#125;SqList;</code></pre><ul class="ne-tl"><li checked="true" id="c4c430a0bf31bd44c7ad82fd0a74f7b6"><span class="ne-text">打印</span></li><li checked="true" id="ecf1ca33414f6a84470bc6f41baee82c"><span class="ne-text">取值</span></li><li checked="true" id="575c964652363409f0fcb36a7f90e6a7"><span class="ne-text">查找</span></li><li checked="true" id="dcc87412e379afd95293b68abfce065b"><span class="ne-text">插入</span></li><li checked="true" id="786cd662043221242464c67ddfd57162"><span class="ne-text">删除</span></li><li checked="true" id="d6835b58b8bd16893dd238c74a55cc8e"><span class="ne-text">升序</span></li><li checked="true" id="3e50b4048010643e7b42ebb021d7508f"><span class="ne-text">逆置</span></li></ul><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;#define MAXSIZE 100<p>/**</p><ul><li>顺序表</li><li></li><li>顺序表的基本操作： 初始化、打印、取值、查找、插入、删除、升序、逆置</li><li>/</li></ul><p>/* 顺序表的存储形式就是连续存储空间，地址连续的，其实就是数组 */<br>typedef struct &#123;<br>    int *arr;<br>    int length;<br>&#125;SqList;</p><p>/* 初始化 */<br>void InitList(SqList &amp;L)<br>&#123;<br>    L.arr = new int[MAXSIZE];<br>    if (!L.arr) exit(-1);<br>    L.length = 0;<br>&#125;</p><p>/* 初始化添加元素 <em>/<br>void ListInsert(SqList &amp;L) &#123;<br>    cout &lt;&lt; &quot;请输入元素个数n：&quot;;<br>    int n;<br>    cin &gt;&gt; n;<br>    for (int i = 0; i &lt; n;i++)&#123;<br>        cin &gt;&gt; L.arr[i];<br>        L.length++;<br>    &#125;<br>&#125;<br>/</em> 打印 <em>/<br>void TraverseList(SqList &amp;L) &#123;<br>    cout &lt;&lt; &quot;该顺序表元素遍历结果为：&quot;;<br>    for (int i = 0; i &lt; L.length;i++) &#123;<br>        cout &lt;&lt; L.arr[i] &lt;&lt; ‘ ‘;<br>    &#125;<br>    cout &lt;&lt; &quot;\n&quot;;<br>&#125;<br>/</em> 最大值 */<br>void NumberMax (SqList &amp;L)&#123;<br>    cout &lt;&lt; &quot;该顺序表最大值为：&quot;;<br>    int max = L.arr[0];<br>    for (int i = 0; i &lt; L.length;i++) &#123;<br>        if(L.arr[i]&gt;max)<br>            max = L.arr[i];<br>    &#125;<br>    cout &lt;&lt; max&lt;&lt;&quot;\n&quot;;<br>&#125;</p><p>/* 插值 */<br>void InsertOneElement (SqList &amp;L) &#123;<br>    cout &lt;&lt; &quot;请分别输入在n位置插入的e值：&quot;;<br>    int n;<br>    int e;<br>    cin &gt;&gt; n &gt;&gt; e;<br>    for (int i = L.length - 1; i &gt;= n-1;i–)&#123;<br>        L.arr[i + 1] = L.arr[i];<br>    &#125;<br>    L.arr[n-1] = e;<br>    L.length++;<br>    cout &lt;&lt; &quot;\n&quot;&lt;&lt;&quot;插入值之后的顺序表为：&quot;;<br>    TraverseList(L);<br>&#125;</p><p>/* 删除 <em>/<br>void DeleteOneElement (SqList &amp;L) &#123;<br>    cout &lt;&lt; &quot;请输入要删除n位置的n值：&quot;;<br>    int n;<br>    cin &gt;&gt; n;<br>    for (int i = 0; i &lt; L.length;i++)&#123;<br>        if (i&gt;=n-1)&#123;<br>            L.arr[i] = L.arr[i + 1];<br>        &#125;<br>    &#125;<br>    L.length–;<br>    cout &lt;&lt; &quot;\n&quot;&lt;&lt;&quot;删除值之后的顺序表为：&quot;;<br>    TraverseList(L);<br>&#125;<br>/</em> 升序 <em>/<br>void IncrList (SqList &amp;L) &#123;<br>    cout &lt;&lt; &quot;升序之后的顺序表为：&quot;;<br>    for (int i = 0; i &lt; L.length;i++)&#123;<br>        for (int j = 0; j &lt; L.length;j++)&#123;<br>            if (L.arr[j]&gt;L.arr[i]) &#123;<br>                int temp;<br>                temp = L.arr[j];<br>                L.arr[j] = L.arr[i];<br>                L.arr[i] = temp;<br>            &#125;<br>        &#125;<br>    &#125;<br>    TraverseList(L);<br>&#125;<br>/</em> 逆置 */<br>void ReverseList (SqList &amp;L) &#123;<br>    cout &lt;&lt; &quot;逆序之后……&quot;;<br>    for (int i = 0; i &lt; L.length / 2;i++)&#123;<br>        int temp;<br>        temp = L.arr[i];<br>        L.arr[i] = L.arr[L.length-i-1];<br>        L.arr[L.length-i-1] = temp;<br>    &#125;<br>    TraverseList(L);<br>&#125;</p><p>int main () &#123;<br>    SqList test;<br>    InitList(test);//1<br>    ListInsert(test);//1<br>    TraverseList(test);//1<br>    NumberMax(test);//2<br>    InsertOneElement(test);//3<br>    DeleteOneElement(test);//4<br>    IncrList(test);//5<br>    ReverseList(test);//6<br>&#125;<br></code></pre></p></div>]]></content>
      
      
      <categories>
          
          <category> 计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 📶线结构：字符串-数组-栈-队列 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>20. 有效的括号🔖栈</title>
      <link href="/blog/aritwv/"/>
      <url>/blog/aritwv/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><ul class="ne-ul"><li id="u250f831a"><a href="https://leetcode-cn.com/problems/valid-parentheses/" data-href="https://leetcode-cn.com/problems/valid-parentheses/" target="_blank" class="ne-link"><span class="ne-text">https://leetcode-cn.com/problems/valid-parentheses/</span></a></li></ul><h2 id="3H4Uf"><span class="ne-text">问题思路</span></h2><p id="a6aa5c3b8ed802ced4ca290e5002d985" class="ne-p"><span class="ne-text">将所有的左半边括号push到栈内，然后遇到右半边括号，就将其与栈顶元素匹配测试，若能匹配成功则继续匹配，反之输出false。</span></p><p id="68251b5bc897786f2791581cca554016" class="ne-p"><br></p><p id="d6745d88d12858cbb36ae4e2a190ed6a" class="ne-p"><span class="ne-text">在这之间注意比较当栈内没有元素了，而字符串还有待匹配的字符，输出false，当栈内还有元素，外面与之匹配测试的右半边括号，也输出false。</span></p><h3 id="hVDJG"><span class="ne-text">ts实现</span></h3><pre><code>function isValid(s: string): boolean &#123;  let stack: Array&lt;string&gt; = []  for (let i of s) &#123;    if (['(', '[', '&#123;'].includes(i)) &#123;      stack.push(i)    &#125; else &#123;      switch (i) &#123;        case ')':          if (stack[stack.length - 1] === '(') &#123;            stack.pop()          &#125; else &#123;            return false          &#125;          break        case ']':          if (stack[stack.length - 1] === '[') &#123;            stack.pop()          &#125; else &#123;            return false          &#125;          break        case '&#125;':          if (stack[stack.length - 1] === '&#123;') &#123;            stack.pop()          &#125; else &#123;            return false          &#125;          break      &#125;    &#125;  &#125;  return stack.length ? false : true&#125;</code></pre><p id="u0a351627" class="ne-p"><span class="ne-text"></span></p><h3 id="hkttw"><span class="ne-text">之前的java代码实现</span></h3><h4 id="coOPC"><span class="ne-text">栈实现</span></h4><pre><code>class Solution &#123;    public boolean isValid(String s) &#123;        Stack&lt;Character&gt; stack = new Stack&lt;&gt;();<pre><code>    int len = s.length();    for (int i=0;i&amp;lt;len;i++) &#123;        char c = s.charAt(i);        if (c == &#39;(&#39; || c == &#39;[&#39; || c == &#39;&#123;&#39;) &#123;            stack.push(c);        &#125; else &#123;            if (stack.isEmpty()) return false;            char left = stack.pop();            if (left == &#39;(&#39; &amp;amp;&amp;amp; c !=&#39;)&#39;) return false;            if (left == &#39;[&#39; &amp;amp;&amp;amp; c !=&#39;]&#39;) return false;            if (left == &#39;&#123;&#39; &amp;amp;&amp;amp; c !=&#39;&#125;&#39;) return false;        &#125;    &#125;    return stack.isEmpty();&#125;</code></pre><p>}<br></code></pre></p><pre><code>class Solution &#123;    public boolean isValid(String s) &#123;        Stack&lt;Character&gt; stack = new Stack&lt;&gt;();        for (int i = 0; i&lt; s.length();i++)&#123;            if (s.charAt(0) == ')' || s.charAt(0) == ']' || s.charAt(0) == '&#125;')&#123;                return false;            &#125;            if (s.charAt(i) == '(' || s.charAt(i) == '[' || s.charAt(i) == '&#123;')&#123;                stack.push(s.charAt(i));            &#125;            if (s.charAt(i) == ')' || s.charAt(i) == ']' || s.charAt(i) == '&#125;')&#123;                if (s.charAt(i) == ')')&#123;                    if (stack.isEmpty() == true) &#123;                        return false;                    &#125;                    if (stack.pop() != '(')                        return false;                &#125;                if (s.charAt(i) == ']')&#123;                    if (stack.isEmpty() == true) &#123;                        return false;                    &#125;                    if (stack.pop() != '[')                        return false;                &#125;                if (s.charAt(i) == '&#125;')&#123;                    if (stack.isEmpty() == true) &#123;                        return false;                    &#125;                    if (stack.pop() != '&#123;')                        return false;                &#125;            &#125;        &#125;        if (stack.isEmpty() == true)&#123;            return true;        &#125; else &#123;            return false;        &#125;    &#125;&#125;</code></pre><h4 id="wlwJM"><span class="ne-text">HashMap实现</span></h4><pre><code>class Solution &#123;    private static HashMap&lt;Character, Character&gt; map = new HashMap&lt;&gt;();    static &#123;        // key - value        map.put('(', ')');        map.put('&#123;', '&#125;');        map.put('[', ']');    &#125;    <pre><code>public boolean isValid(String s) &#123;    Stack&amp;lt;Character&amp;gt; stack = new Stack&amp;lt;&amp;gt;();        int len = s.length();    for (int i = 0; i &amp;lt; len; i++) &#123;        char c = s.charAt(i);        if (map.containsKey(c)) &#123; // 左括号            stack.push(c);        &#125; else &#123; // 右括号            if (stack.isEmpty()) return false;                        if (c != map.get(stack.pop())) return false;        &#125;    &#125;    return stack.isEmpty();&#125;</code></pre><p>}<br></code></pre></p></div>]]></content>
      
      
      <categories>
          
          <category> 计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 📶线结构：字符串-数组-栈-队列 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JAVA栈设计</title>
      <link href="/blog/yxy6mv/"/>
      <url>/blog/yxy6mv/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h2 id="mbNmd"><span class="ne-text">栈的设计</span></h2><h3 id="YmYSZ"><span class="ne-text">栈的特点</span></h3><p id="ubb584bef" class="ne-p"><br></p><p id="356e5feffef0d675b37bcabe5fa4307e" class="ne-p"><span class="ne-text">栈的最重要特点就是其元素的</span><strong><span class="ne-text">后进先出，先进后出</span></strong><span class="ne-text">。</span></p><h3 id="UnewH"><span class="ne-text">栈的接口设计</span></h3><p id="62d1abe431f740f5969fba7a50b8eb23" class="ne-p"><span class="ne-text">栈可以</span><strong><span class="ne-text">直接继承</span></strong><span class="ne-text">之前所学的ArrayList亦或是List接口。</span></p><p id="fca3f98f0da0c22facd6ecd71c0ddc55" class="ne-p"><span class="ne-text">这过程中需要注意，最好不要直接继承，因为如果直接继承，会将接口里面的其他方法也继承下来，会导致栈的对外接口不合理，解决办法就是在</span><strong><span class="ne-text">类设计内部new一个private List对象</span></strong><span class="ne-text">来设计栈。</span></p><pre><code>int size(); // 元素的数量boolean isEmpty(); // 栈是否为空void push(E element); // 入栈E pop(); // 出栈E top(); // 获取栈顶元素void clear(); // 清空栈</code></pre><pre><code>package com.wztlink1013.ds.stack;import com.wztlink1013.ds.stack.list.ArrayList;import com.wztlink1013.ds.stack.list.List;public class Stack&lt;E&gt; &#123;    private List&lt;E&gt; list = new ArrayList&lt;&gt;();    public void clear() &#123;        list.clear();    &#125;    public int size() &#123;        return list.size();    &#125;    public boolean isEmpty() &#123;        return list.isEmpty();    &#125;    public void push(E element) &#123;        list.add(element);    &#125;    public E pop() &#123;        return list.remove(list.size() - 1);    &#125;    public E top() &#123;        return list.get(list.size() - 1);    &#125;&#125;</code></pre><h2 id="mu0a8"><span class="ne-text">栈的应用</span></h2><p id="33858337566dce4c7d285a24ff302120" class="ne-p"><br></p><p id="ee4232e23b9b7490b87b5aac01895525" class="ne-p"><strong><span class="ne-text">浏览器的前进和后退</span></strong><span class="ne-text">的功能。</span></p><p id="7aa224657e2e60c1bd4e8bd9d7fdc6cf" class="ne-p"><span class="ne-text">假如有网页a、b、c、d，依次点击abc三个网页，然后回退至b网页，这个时候，就相当于在1栈中有ab两个网页（且b为栈顶元素），c暂时放到2栈中，此时依然可以使用回退前进功能，但是现在在b页面上在新输入d网页并进入，此时2栈被清空，d为1栈的栈顶元素，在此时的d页面内，不能使用浏览器的前进功能，只能使用后退功能。</span></p><p id="db8f06bbe0e3d7e68cfad7a8ba312d40" class="ne-p"><br></p><h2 id="zLWwa"></h2></div>]]></content>
      
      
      <categories>
          
          <category> 计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 📶线结构：字符串-数组-栈-队列 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>GitHub+PicGo构建免费图床及其高效使用</title>
      <link href="/blog/bzf30z/"/>
      <url>/blog/bzf30z/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h2 id="48eafeef"><span class="ne-text">一、搭建缘由</span></h2><p id="4f727f40e64576fad71ffc08f56ca87c" class="ne-p"><span class="ne-text">一开始搭建博客，避免不了要用许多图片，最初使用七牛云来做博客图床，但是后来发现，七牛云只有30天的临时域名，hhhhhhh，果然啊，天下就没有免费的好事啊~后来就发现GitHub配合PicGo可以作图床，而且加上jsDlivr速度可观。</span></p><p id="f8544afa12ece5d6eec191b42a8e569d" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1602926956661-8671ebfe-4f99-494d-b759-a9c75cd67b41.png" width="807" id="tXrax" class="ne-image"></p><p id="f939000ee37f2623e67e59c7074ef5ce" class="ne-p"><br></p><h2 id="57b1f41b"><span class="ne-text">二、GitHub相关配置</span></h2><h3 id="26376074"><span class="ne-text">新建figure图床仓库</span></h3><p id="3843538455ea7c52a556be1d1af1ece4" class="ne-p"><span class="ne-text">常规新建仓库方式，命名figure</span></p><p id="a79702fb454d475a470f7123f4e328cc" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1602926957158-9c7f8749-4d8e-4bc9-9e1c-7d3db5a307b1.png" width="1812" id="c5Wn2" class="ne-image"></p><h3 id="8489cf17"><span class="ne-text">生成一个Token密匙</span></h3><p id="02e8231dd6bcf875d8fe8066777938ef" class="ne-p"><span class="ne-text">点击setting</span></p><p id="bad4478c9fe69ab21f3696e3c58d98c6" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1602926956634-4c139fbc-0469-4749-89b8-f139226aa7d2.png" width="1823" id="y83dC" class="ne-image"></p><p id="678091010234f5965af82ef3ded03e1e" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1605839703428-b18e3c24-48e0-44ed-9715-81fcd822d4e8.png" width="599" id="DEbkz" class="ne-image"></p><p id="aee1e903788fc37cb85056e504a4cb23" class="ne-p" style="text-align: center"><strong><span class="ne-text">只需要勾选第一个仓库选项就可以了！</span></strong></p><h2 id="b8d02c8e"><span class="ne-text">三、PicGo相关配置</span></h2><h3 id="c8f7b5c7"><span class="ne-text">下载及注意事项</span></h3><p id="3cf4d4e8136aaeec683bb50405bcc9ba" class="ne-p"><a href="https://github.com/Molunerfinn/PicGo/releases" data-href="https://github.com/Molunerfinn/PicGo/releases" target="_blank" class="ne-link"><span class="ne-text">下载地址</span></a></p><p id="35bcd5a2382809b424ff1d62a1a10e70" class="ne-p"><span class="ne-text">注意：下载picgo时候，要科学上网</span></p><h3 id="224e2ccd"><span class="ne-text">配置</span></h3><p id="9feb30085d6e8942a7a8f7d6b1ebab98" class="ne-p"><br></p><p id="5770b3fd2b9105f65561b47f1ddb65b5" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1602926956815-db5cf455-f628-4c4d-9242-1687e15a7f03.png" width="1002" id="nHxuO" class="ne-image"></p><p id="31e915163b1a1651c09159cdbff6051c" class="ne-p"><br></p><h2 id="fbe1b2a5"><span class="ne-text">四、高效写博客</span></h2><h3 id="11d50b82"><span class="ne-text">Snipaste截图软件</span></h3><div class="ne-quote"><p id="9799af9cd3667277d32b5ea87c60631a" class="ne-p"><strong><span class="ne-text">常用</span></strong><span class="ne-text">快捷键【作者是用的惠普笔记本电脑，不同电脑键盘的使用方式会不一样】</span></p></div><p id="f85db0c436b1b87dcf584523118d2f8b" class="ne-p"><span class="ne-text">fn+f1：截屏（可编辑）</span></p><p id="93f8ff2d082d9f568ea5085d5031623e" class="ne-p"><span class="ne-text">esc：退出</span></p><p id="414660940139dc91e3db3868f0563866" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1602926956785-4e12ba13-c4c6-4e5a-9758-5d3de27f9718.png" width="553" id="c5EI8" class="ne-image"></p><h3 id="71752a89"><span class="ne-text">结合PicGo使用</span></h3><p id="a536457bb941d527dc20da0c3c941d6f" class="ne-p"><span class="ne-text">PicGo+Snipaste快捷键结合<br /></span><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1602926956619-08d5eae3-3b21-42cc-a2d8-85d6d2f8ed62.png" width="847" id="RxuyV" class="ne-image"></p><h3 id="a3f18b89"><span class="ne-text">综合使用SOP</span></h3><ol class="ne-ol"><li id="87c8ff2aa9721a37a58ea86860d9ed7f"><span class="ne-text">按</span><code class="ne-code"><span class="ne-text">fn+f1</span></code><span class="ne-text">截完图，再按</span><code class="ne-code"><span class="ne-text">ctrl+c</span></code><span class="ne-text">将刚刚截图放到剪贴板</span></li><li id="2b28bb3a32d1e678f3cf5afe4e960dad"><span class="ne-text">再按</span><code class="ne-code"><span class="ne-text">ctrl+shift+p</span></code><span class="ne-text">使用picgo快捷键将剪贴板上的图片上传同时将此时图片的外链复制到剪贴板</span></li></ol><h2 id="723e94d8"><span class="ne-text">五、相关补充</span></h2><h3 id="54e5de42"><span class="ne-text">上传失败</span></h3><p id="5dbc1861a69ad02c481adec93ad8cd9c" class="ne-p"><code class="ne-code"><span class="ne-text">问题1：有些时候上传picgo时，会出现配置报错的情况</span></code></p><div class="ne-quote"><p id="a772c8ec68b4dbf0b7e9a43a89a7d81b" class="ne-p"><span class="ne-text">方案1：在picgo的配置中，改一下文件夹名字（相当于在仓库下新建一个文件夹），就比如本来存到blogarticle3/文件夹下，改成blogarticle4/就好了</span></p><p id="b31febe9734c042c303ce8b69612b817" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1602926956579-eafc7cfa-1e0b-41be-ae5b-c6560b8c7638.png" width="1320" id="SUtOG" class="ne-image"></p><p id="3d16f291f6f140b6fd1c647947f9038d" class="ne-p"><span class="ne-text">方案2：将下图所示的</span><code class="ne-code"><span class="ne-text">上传前重命名</span></code><span class="ne-text">打开同时</span><code class="ne-code"><span class="ne-text">设置Server</span></code><span class="ne-text">内容开换成关，关换成开，玄学……</span></p><p id="fd626682e799bf03c7785c18cfb1ac43" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1602926956785-fb091672-3c17-49db-a0e7-965e20c93f5c.png" width="1002" id="mBrId" class="ne-image"></p><p id="52abdd57c3356b6bf288a42e6f1062d3" class="ne-p"><span class="ne-text">方案3：将PicGo软件叉掉重新运行。玄学····</span></p><p id="d90a16a878589f6728d9f8297737cf42" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1602926957260-3a981036-cd74-4a90-8665-d2510470f2c9.png" width="1002" id="uDV56" class="ne-image"></p><p id="812bd0c26f8627db68f72d542fc17c9e" class="ne-p"><span class="ne-text">方案4（最优方案）：科学上网</span></p></div><h3 id="474294e8"><span class="ne-text">关于插件</span></h3><p id="104a6257dfb8536020fe3057822fcf31" class="ne-p"><span class="ne-text">在插件列表里面下载这三个拓展插件，其中两个国内的托管coding和gitee，还有一个github plus版本，不过觉得国内的外链范围肯定是要小一点的应该，最好是优先使用github图床，coding和gitee的作为文章使用，有关博客配置的使用CDN等。</span></p><p id="0d48474349378fd3eb0896899595196b" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1602926956548-b7b5ad1b-2586-42c5-8f7d-9dd17c265fcf.png" width="771" id="jVclk" class="ne-image"></p><p id="29f236751d44d58ebd95b7350ae77f88" class="ne-p"><br></p><h4 id="75295b5b"><span class="ne-text">Coding配置</span></h4><p id="83d8fb5eb3e64366f2897f9e56ef40c1" class="ne-p"><br></p><p id="906d0696e8c8bb72d0bc2aeb62ab8469" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1602926956265-035a546d-2ecd-48c3-8eec-c9ef7779653b.png" width="739" id="tS4xk" class="ne-image"></p><p id="7d5fa74befbe566d6186f5810131678b" class="ne-p"><br></p><h4 id="becf3f88"><span class="ne-text">gitee配置</span></h4><p id="96b269d8fd73c4b78ed0845fb8a72fcb" class="ne-p"><br></p><p id="5bd04874e8c3563dc4e10baae7725b27" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1602926956286-859465c2-411f-4761-8921-526656b8a191.png" width="778" id="Dz7ij" class="ne-image"></p><p id="3b714b4341176f6827f03784d9b58a74" class="ne-p"><br></p><h4 id="222c511c"><span class="ne-text">GitHub plus配置</span></h4><p id="3a44d21f09f952693fe82bec1028280a" class="ne-p"><br></p><p id="01ef99aa2eb19766d33cf1be636b3c64" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1602926956274-6e705ace-8e6f-4226-9fae-ffaaa66a2aa9.png" width="727" id="I5d4B" class="ne-image"></p></div>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
          <category> 博客技术 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>jsDelivr+Github或NPM+国内镜像源两种方法构建免费CDN库</title>
      <link href="/blog/erx9hf/"/>
      <url>/blog/erx9hf/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="ufff27c93" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1641718461641-3811ef80-de8d-4fe8-adf5-1e80d9bc3a4f.png" width="900" id="ue9c0ff30" class="ne-image"></p><p id="u2c6acca8" class="ne-p"><span class="ne-text">前言：此前一直使用jsDelivr+GitHub来构建免费的CDN服务，但是在2121.12.20左右，jsDelivr貌似崩了，究其原因是其在国内的备案失效了，导致网宿停止对该域名的服务，之后恢复之后，国内节点也不会像之前一样的解析得快了，具体体现就是网站中涉及jsDelivr静态资源CDN处打开会有卡顿的访问情况。</span></p><p id="uf2abdbbd" class="ne-p"><span class="ne-text"></span></p><p id="u9f61f891" class="ne-p"><span class="ne-text">所以本文介绍新一种搭建免费CDN的方案：将静态资源发布NPM包+国内镜像引用的方式，另一种是之前一直用的jsDelivr+GitHub仓库引用的方案。</span></p><h3 id="L1aek"><span class="ne-text">何为内容分发网络CDN</span></h3><div class="ne-quote"><p id="840ab83f70eedb9e6b563de4a14509fd" class="ne-p"><span class="ne-text">CDN的全称是Content Delivery Network，即内容分发网络。CDN是构建在网络之上的内容分发网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。CDN的关键技术主要有内容存储和分发技术。——百度百科</span></p></div><p id="90ac18bee2af62f6e23446cfb8d2e32c" class="ne-p"><br></p><p id="5c8c490b737bbbf78164784095359219" class="ne-p"><span class="ne-text">通俗来说就是提取外链，同时加速访问的好处。Github的资源在国内加载速度比较慢，因此需要使用CDN加速来优化网站打开速度，</span><span class="ne-text" style="text-decoration: line-through">jsDelivr + Github便是免费且好用的CDN</span><span class="ne-text">（jsDelivr cdn 半挂状态），非常适合博客网站使用。</span></p><p id="u27dd36b3" class="ne-p"><span class="ne-text"></span></p><h2 id="ZAcHs"><span class="ne-text">方法一：NPM包+国内镜像</span></h2><p id="uaa8bcd1b" class="ne-p"><span class="ne-text">原因：</span></p><ul class="ne-ul"><li id="ucbee54c9"><span class="ne-text">网站引入的静态资源，如js、css、图片等资源，使用公共的CDN库来引入会更好地优化网站速度。</span></li><li id="u8bfdfc51"><span class="ne-text">不用jsDelivr+GitHub做CDN的缘由是，镜像没有npm的镜像多</span></li><li id="ufedf9993"><span class="ne-text">jsDelivr cdn 挂了（盲猜薅羊毛导致），备案证书过期，国内速度不再是从前的那般快了</span></li></ul><h3 id="pvyK8"><span class="ne-text">CDN镜像源</span></h3><ul class="ne-ul"><li id="uf1fcafcb"><span class="ne-text">饿了么做的：</span><a href="https://npm.elemecdn.com/" data-href="https://npm.elemecdn.com/" target="_blank" class="ne-link"><span class="ne-text">https://npm.elemecdn.com/</span></a></li></ul><p id="u9e6ee108" class="ne-p"><a href="https://unpkg.zhimg.com/yuque-hexo-lyrics@1.0.0/config.js" data-href="https://unpkg.zhimg.com/yuque-hexo-lyrics@1.0.0/config.js" target="_blank" class="ne-link"><span class="ne-text">https://unpkg.zhimg.com/yuque-hexo-lyrics@1.0.0/config.js</span></a></p><ul class="ne-ul"><li id="u13b6279b"><span class="ne-text">知乎做的：</span><a href="https://unpkg.zhimg.com/" data-href="https://unpkg.zhimg.com/" target="_blank" class="ne-link"><span class="ne-text">https://unpkg.zhimg.com/</span></a></li></ul><p id="uc65b504f" class="ne-p"><a href="https://npm.elemecdn.com/yuque-hexo-lyrics@1.0.0/config.js" data-href="https://npm.elemecdn.com/yuque-hexo-lyrics@1.0.0/config.js" target="_blank" class="ne-link"><span class="ne-text">https://npm.elemecdn.com/yuque-hexo-lyrics@1.0.0/config.js</span></a></p><ul class="ne-ul"><li id="ubdcd697e"><span class="ne-text">UNPKG（unpkg镜像用的是CloudFlare，国内加速效果不好）：</span><a href="https://unpkg.com/" data-href="https://unpkg.com/" target="_blank" class="ne-link"><span class="ne-text">https://unpkg.com/</span></a></li></ul><p id="ua50cbc0a" class="ne-p"><a href="https://unpkg.com/yuque-hexo-lyrics@1.0.0/config.js" data-href="https://unpkg.com/yuque-hexo-lyrics@1.0.0/config.js" target="_blank" class="ne-link"><span class="ne-text">https://unpkg.com/yuque-hexo-lyrics@1.0.0/config.js</span></a></p><ul class="ne-ul"><li id="u9206eec1"><span class="ne-text">……</span></li></ul><h3 id="WDSHp"><span class="ne-text">实现思路</span></h3><p id="u9f7905cb" class="ne-p"><span class="ne-text">将GitHub仓库私有化，同时配置GitHub Actions，如果发布版本/fork/star等操作，就将其pulish到npm包</span></p><p id="ua952998e" class="ne-p"><span class="ne-text"></span></p><p id="u7154484c" class="ne-p"><span class="ne-text">每次更新GitHub仓库之后，需要将package.json文件中的version字段的值指定，然后才能使用GitHub Actions进行自动化部署</span></p><p id="u16dd565c" class="ne-p"><span class="ne-text"></span></p><p id="u094e8964" class="ne-p"><span class="ne-text">具体使用形式：</span></p><ul class="ne-ul"><li id="u54d149a3"><a href="https://unpkg.zhimg.com/cdn-website@0.0.0/ico/heroes_villains/Totoro.ico" data-href="https://unpkg.zhimg.com/cdn-website@0.0.0/ico/heroes_villains/Totoro.ico" target="_blank" class="ne-link"><span class="ne-text">https://unpkg.zhimg.com/cdn-website@0.0.0/ico/heroes_villains/Totoro.ico</span></a></li><li id="u146d4300"><a href="https://unpkg.zhimg.com/cdn-pictures@0.0.0/about/teacher.png" data-href="https://unpkg.zhimg.com/cdn-pictures@0.0.0/about/teacher.png" target="_blank" class="ne-link"><span class="ne-text">https://unpkg.zhimg.com/cdn-pictures@0.0.0/about/teacher.png</span></a></li><li id="ud9f1bbfa"><a href="https://unpkg.zhimg.com/cdn-articles@0.0.0/article1/20200725094728.jpg" data-href="https://unpkg.zhimg.com/cdn-articles@0.0.0/article1/20200725094728.jpg" target="_blank" class="ne-link"><span class="ne-text">https://unpkg.zhimg.com/cdn-articles@0.0.0/article1/20200725094728.jpg</span></a></li></ul><p id="u6ba2595e" class="ne-p"><span class="ne-text"></span></p><p id="ud0434ae6" class="ne-p"><span class="ne-text">其中，上述链接中的CDN链接</span><a href="https://unpkg.zhimg.com/" data-href="https://unpkg.zhimg.com/" target="_blank" class="ne-link"><span class="ne-text">https://unpkg.zhimg.com/</span></a><span class="ne-text">都可以用其他镜像源（unpkg、elemecdn、jsdelivr等）替换</span></p><h2 id="m2ViF"><span class="ne-text">方法二：jsDelivr+GitHub仓库</span></h2><h3 id="ktjsG"><span class="ne-text">GitHub新建CDN仓库</span></h3><p id="c284058895633e58a2ba2a3fe54eaafe" class="ne-p"><br></p><p id="0878494016df1c3e17d3b62b4207e8ac" class="ne-p"><span class="ne-text">在本地电脑进行一系列clone/pull等一系列操作，同时发布版本（最好上传一次就发布依次版本）</span></p><p id="15aac5478cfe89fc751f3736e48bcc10" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1602926808858-fcdea51e-42b2-4582-b46d-e9c105842039.png" width="1844" id="H2FW1" class="ne-image"></p><p id="db5bd10a52ba645c649a6ec2f84185e2" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1602926808290-99384f86-d857-415a-83e6-9be3b5bcf279.png" width="1832" id="nIJCg" class="ne-image"></p><p id="1832f2183d844a77a49e94a0eb6ee9db" class="ne-p"><br></p><h3 id="zpcmm"><span class="ne-text">使用jsDelivr</span></h3><p id="073ec0ba7b6f2f2cc3dba983ab009d5e" class="ne-p"><code class="ne-code"><a href="https://cdn.jsdelivr.net/gh/wztlink1013/CDN-Volantis@" data-href="https://cdn.jsdelivr.net/gh/wztlink1013/CDN-Volantis@" target="_blank" class="ne-link"><strong><span class="ne-text">https://cdn.jsdelivr.net/gh/wztlink1013/CDN-Volantis@</span></strong></a><strong><span class="ne-text">版本号/文件夹/文件名.文件后缀</span></strong></code></p><p id="2913f52497204ca38cfe2b79246d0eb4" class="ne-p"><strong><span class="ne-text">举个栗子</span></strong></p><ul class="ne-ul"><li id="b38f58c6e41dad0025a997b77e18a657"><a href="https://cdn.jsdelivr.net/gh/wztlink1013/CDN@2.4/Pictures/blogbackground/fengbaobao_1.jpg" data-href="https://cdn.jsdelivr.net/gh/wztlink1013/CDN@2.4/Pictures/blogbackground/fengbaobao_1.jpg" target="_blank" class="ne-link"><span class="ne-text">https://cdn.jsdelivr.net/gh/wztlink1013/CDN@2.4/Pictures/blogbackground/fengbaobao_1.jpg</span></a></li><li id="867dc0cd4fc6b6a4a46840eccf31d26a"><a href="https://cdn.jsdelivr.net/gh/moezx/cdn@3.1.3//The%20Pet%20Girl%20of%20Sakurasou.mp4" data-href="https://cdn.jsdelivr.net/gh/moezx/cdn@3.1.3//The%20Pet%20Girl%20of%20Sakurasou.mp4" target="_blank" class="ne-link"><span class="ne-text">https://cdn.jsdelivr.net/gh/moezx/cdn@3.1.3//The Pet Girl of Sakurasou.mp4</span></a></li></ul><p id="29df8afaa1feb78832fc9b8d0c811dcc" class="ne-p"><br></p><div class="ne-quote"><p id="3bf1ef921059d895947a569bd00904f1" class="ne-p"><span class="ne-text">0、具体使用教程</span></p></div><ul class="ne-ul"><li id="a6c07817ec1826e0ee0100c52ece3ae3"><a href="https://blog.wztlink1013.com/2020/02/25/Hexo/jsDelivr%E5%92%8CGitHub%E6%9E%84%E5%BB%BA%E5%85%8D%E8%B4%B9CDN/" data-href="https://blog.wztlink1013.com/2020/02/25/Hexo/jsDelivr%E5%92%8CGitHub%E6%9E%84%E5%BB%BA%E5%85%8D%E8%B4%B9CDN/" target="_blank" class="ne-link"><span class="ne-text">jsDelivr和Github构建免费CDN</span></a></li><li id="e987a4e3cecd805913c4fdc0056b7638"><a href="https://www.jsdelivr.com/" data-href="https://www.jsdelivr.com/" target="_blank" class="ne-link"><span class="ne-text">jsdelivr官网网站</span></a></li></ul><p id="434883797f9d5ce1690005e7bfa8529b" class="ne-p"><br></p><div class="ne-quote"><p id="1f4eb5777e6e48253a2f87cf2d1e7df6" class="ne-p"><span class="ne-text">1、加载任何Github发布、提交或分支</span></p></div><ul class="ne-ul"><li id="98e48520e5f0df70314dfa0803b9a20f"><a href="https://cdn.jsdelivr.net/gh/user/repo@version/file" data-href="https://cdn.jsdelivr.net/gh/user/repo@version/file" target="_blank" class="ne-link"><span class="ne-text">https://cdn.jsdelivr.net/gh/user/repo@version/file</span></a></li></ul><div class="ne-quote"><p id="5fc01cec3d879c6027c5b63e0cde73c9" class="ne-p"><span class="ne-text">2、加载 jQuery v3.2.1</span></p></div><ul class="ne-ul"><li id="8044a13c7fab2ec6bd5b09a50079aa7c"><a href="https://cdn.jsdelivr.net/gh/jquery/jquery@3.2.1/dist/jquery.min.js" data-href="https://cdn.jsdelivr.net/gh/jquery/jquery@3.2.1/dist/jquery.min.js" target="_blank" class="ne-link"><span class="ne-text">https://cdn.jsdelivr.net/gh/jquery/jquery@3.2.1/dist/jquery.min.js</span></a></li></ul><p id="c1755bc347326be221542560d52c51f2" class="ne-p"><br></p><div class="ne-quote"><p id="3b840d7fe5df9b288c0dcbc6c7fe578b" class="ne-p"><span class="ne-text">3、使用版本范围而不是特定版本</span></p></div><ul class="ne-ul"><li id="155b258f84fed50dca398969efed1fe7"><a href="https://cdn.jsdelivr.net/gh/jquery/jquery@3.2/dist/jquery.min.js" data-href="https://cdn.jsdelivr.net/gh/jquery/jquery@3.2/dist/jquery.min.js" target="_blank" class="ne-link"><span class="ne-text">https://cdn.jsdelivr.net/gh/jquery/jquery@3.2/dist/jquery.min.js</span></a></li><li id="df0286308c62fdea9a8e538cf9646bd7"><a href="https://cdn.jsdelivr.net/gh/jquery/jquery@3/dist/jquery.min.js" data-href="https://cdn.jsdelivr.net/gh/jquery/jquery@3/dist/jquery.min.js" target="_blank" class="ne-link"><span class="ne-text">https://cdn.jsdelivr.net/gh/jquery/jquery@3/dist/jquery.min.js</span></a></li></ul><p id="ade19f7333fde57d4630be05ec397499" class="ne-p"><br></p><div class="ne-quote"><p id="fe85c27c0afda11a8e5ffa5e21865b20" class="ne-p"><span class="ne-text">4、完全省略该版本以获取最新版本</span></p></div><ul class="ne-ul"><li id="e532c26a90f4c8d77e48dc3bb0082cba"><a href="https://cdn.jsdelivr.net/gh/jquery/jquery/dist/jquery.min.js" data-href="https://cdn.jsdelivr.net/gh/jquery/jquery/dist/jquery.min.js" target="_blank" class="ne-link"><span class="ne-text">https://cdn.jsdelivr.net/gh/jquery/jquery/dist/jquery.min.js</span></a></li></ul><p id="1a0044b5faeb3f5f51e4a7c6cfbb7ef0" class="ne-p"><br></p><div class="ne-quote"><p id="9f8eece216416d831eeb0c388c3b42be" class="ne-p"><span class="ne-text">5、将“.min”添加到任何JS/CSS文件中以获取缩小版本，如果不存在，将为会自动生成</span></p></div><ul class="ne-ul"><li id="69446385cee77f5e9285ef32d4c3f386"><a href="https://cdn.jsdelivr.net/gh/jquery/jquery@3.2.1/src/core.min.js" data-href="https://cdn.jsdelivr.net/gh/jquery/jquery@3.2.1/src/core.min.js" target="_blank" class="ne-link"><span class="ne-text">https://cdn.jsdelivr.net/gh/jquery/jquery@3.2.1/src/core.min.js</span></a></li></ul><p id="ca071a7d9ea8bd378d666c79a5378eea" class="ne-p"><br></p><div class="ne-quote"><p id="4124ef81391f3dcca87546eacb99b342" class="ne-p"><span class="ne-text">6、在末尾添加 / 以获取资源目录列表</span></p></div><ul class="ne-ul"><li id="097bad980a01b3a8419b7ba208706950"><a href="https://cdn.jsdelivr.net/gh/jquery/jquery/" data-href="https://cdn.jsdelivr.net/gh/jquery/jquery/" target="_blank" class="ne-link"><span class="ne-text">https://cdn.jsdelivr.net/gh/jquery/jquery/</span></a></li></ul></div>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
          <category> 博客技术 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Python路径和nltk报错问题</title>
      <link href="/blog/uatg7m/"/>
      <url>/blog/uatg7m/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h2 id="6cb6c7f7"><span class="ne-text">一、路径相关</span></h2><h3 id="6ee0e6b6"><span class="ne-text">路径相关报错信息</span></h3><p id="4572a7354aab604138d885135048872d" class="ne-p"><br></p><pre><code>IOError: [Errno 2] No such file or directory</code></pre><p id="f25522bdb71fc742445b3197abc62381" class="ne-p"><br></p><pre><code>pandas.read_csv() 报错 OSError: Initializing from file failed</code></pre><p id="77b109b94605ef2a5e27757c7dc7205b" class="ne-p"><br></p><pre><code>(unicode error) 'unicodeescape' codec can't decode bytes in position 2-3: truncated \UXXXXXXXX escape [duplicate]</code></pre><p id="b60edebe83dbf86246674b4c6af422bb" class="ne-p"><br></p><pre><code>File b'train.csv' does not exist even though file exist</code></pre><p id="a316d145247105cdf0ba63d72c97d5d7" class="ne-p"><br></p><h3 id="23232096"><span class="ne-text">分析与解决问题</span></h3><p id="18dca0c7cdec33832180efc3da091854" class="ne-p"><br></p><p id="d16ae3a35aacbeb16dada31a93ccd7ca" class="ne-p"><span class="ne-text">编写python代码过程中，出现了类似这种一系列路径相关的错误，原因是，自己更改了</span><strong><span class="ne-text">相关文件夹/文件在电脑中的位置</span></strong><span class="ne-text">，解决办法就新建一个项目建一个全新路径或者修改现有路径</span></p><p id="e59d58fa2d2fe14d08e139b0efa22691" class="ne-p"><br></p><ul class="ne-ul"><li id="1a6eef5d0ccc2c6ee0ff14a8008f00e8"><code class="ne-code"><span class="ne-text">\</span></code><span class="ne-text">绝对路径 会报错（转义字符）处理：①双引号前面加一个r②</span><code class="ne-code"><span class="ne-text">\</span></code><span class="ne-text">换成</span><code class="ne-code"><span class="ne-text">\\</span></code><span class="ne-text">（硬盘代号后面的第一个）</span></li><li id="98df76572544ac1d18830058449ec39c"><code class="ne-code"><span class="ne-text">./</span></code><span class="ne-text">相对路径</span></li></ul><p id="51e22662287482e60928a4f653e88f5d" class="ne-p"><br></p><div class="ne-quote"><p id="7f956e229304152140484388f6e2c27a" class="ne-p"><span class="ne-text">三种解决方式</span></p><p id="6d409d8e37e7746f60de847ae6fe3b89" class="ne-p"><code class="ne-code"><span class="ne-text">r&quot;C:\Users\YJG\Desktop\pi_digits.txt&quot;</span></code></p><p id="60023f44cfe8f3239ef0a14cbc51d28e" class="ne-p"><code class="ne-code"><span class="ne-text">&quot;C:\\Users\\YJG\\Desktop\\pi_digits.txt&quot;</span></code></p><p id="368cecf545b73963cf3f48eb34394ced" class="ne-p"><code class="ne-code"><span class="ne-text">&quot;C:/Users/YJG/Desktop/pi_digits.txt&quot;</span></code></p></div><p id="0130f444cb27d4e3f231021e65c19049" class="ne-p"><br></p><h3 id="d252fb78"><span class="ne-text">PS：路径含中文</span></h3><p id="c9374d00a9b99aa410c3e1ca8a1f506f" class="ne-p"><br></p><p id="37468547ba25c2bf9bb9c7e411b1fe81" class="ne-p"><span class="ne-text">假如路径、文件名都完整，还是报错的原因是这个参数中有中文，即使Python3已经支持中文，但是调用pandas的read_csv()方法时，默认使用C engine作为parser engine，而当文件名中含有中文的时候，用C engine在部分情况下就会出错。所以在调用read_csv()方法时指定engine为Python就可以解决问题。根治：将路径编程全英文，这是必要素养习惯！</span></p><p id="523ad4dcba199dfa88e073f63aae22d0" class="ne-p"><br></p><p id="5d6ca3481b155b9518674862cd029000" class="ne-p"><code class="ne-code"><span class="ne-text">da4=pd.read_csv(xxxxxxxxxx,engine='python')</span></code></p><p id="5e5562d2ed4c57d81f6e8247742a7a3c" class="ne-p"><br></p><h3 id="e39bd83f"><span class="ne-text">PS：utf-8</span></h3><p id="c3b42e6aa5f6f8c52749c90950432a7b" class="ne-p"><br></p><pre><code>UnicodeDecodeError：: 'utf-8' codec can't decode byte 0xc8 in position 0: invalid contin</code></pre><p id="a5bece3a9a19565d2d1859c79539039d" class="ne-p"><br></p><div class="ne-quote"><p id="a914bb65d1269e2db74878a49f937c23" class="ne-p"><span class="ne-text">解决办法：</span><code class="ne-code"><span class="ne-text">data_1 = pd.read_csv(data1, encoding = 'gb2312')</span></code><span class="ne-text">或者gb2312换成gbk</span></p><p id="d12146d16852fb2ed497c307e21d919d" class="ne-p"><span class="ne-text">参考：</span><a href="https://blog.csdn.net/qq_18888869/article/details/82625343" data-href="https://blog.csdn.net/qq_18888869/article/details/82625343" target="_blank" class="ne-link"><span class="ne-text">https://blog.csdn.net/qq_18888869/article/details/82625343</span></a></p></div><p id="300f902454be93b73d6799c083b90f8d" class="ne-p"><br></p><h2 id="1f1ff85b"><span class="ne-text">二、nltk相关</span></h2><p id="5f970449ad105f93602d5219004fbe5f" class="ne-p"><br></p><h3 id="50e37e8c"><span class="ne-text">nltk下载报错信息</span></h3><p id="86a67e61602f3f374027d37b4e1ea626" class="ne-p"><br></p><pre><code>bug:[WinError 10054] 远程主机强迫关闭了一个现有的连接</code></pre><p id="42cb1a2feb3d2b55b4fc758a07553bf4" class="ne-p"><br></p><h3 id="23232096-1"><span class="ne-text">分析与解决问题</span></h3><p id="d4fb6afc1f4b300011bb68ff044efe35" class="ne-p"><br></p><p id="9b0d8477193bb99726118cc416881992" class="ne-p"><span class="ne-text">原因：模型权重参数文件（.h5）较大，下载出现中断，下载失败</span></p><p id="c0e52bc335036398dc4557328dc97e2d" class="ne-p"><br></p><div class="ne-quote"><ul class="ne-ul"><li id="8406610a1907fc3a4c7a5628184ce9c3"><span class="ne-text">解决办法：手动下载模型，放到指定目录</span></li><li id="dad1ec73df28aa1c45d5870fc2477a31"><code class="ne-code"><span class="ne-text">C:\Users\XXX\AppData\Roaming</span></code></li></ul></div><p id="989b666510388075cfd915130f709b10" class="ne-p"><br></p><p id="dfd955e933a230756233255d25a2854f" class="ne-p"><a href="https://pan.baidu.com/s/1oUsf-FgVAZnQAtZWRwiK4w" data-href="https://pan.baidu.com/s/1oUsf-FgVAZnQAtZWRwiK4w" target="_blank" class="ne-link"><span class="ne-text">下载地址</span></a><span class="ne-text">  （密码9sar）</span></p><p id="8a60970ce06cd75e72a86f0ea972bb8f" class="ne-p"><br></p><h2 id="d17a0f0b"><span class="ne-text">参考</span></h2><p id="af71db04b34e3ce5951654ee0ae16651" class="ne-p"><br></p><ul class="ne-ul"><li id="ec7e0bef0a86f630f160680ec0254583"><a href="https://blog.csdn.net/zln_whu/article/details/103448420" data-href="https://blog.csdn.net/zln_whu/article/details/103448420" target="_blank" class="ne-link"><span class="ne-text">CSDN-103448420</span></a></li><li id="dccfaa5b278c9b44f0ae14f381df9fdb"><a href="https://www.jianshu.com/p/0e1d51a7549d" data-href="https://www.jianshu.com/p/0e1d51a7549d" target="_blank" class="ne-link"><span class="ne-text">nltk简书详细讲解</span></a></li></ul></div>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
          <category> Bug记录 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JavaWeb端口8080端口被占用</title>
      <link href="/blog/qi1md8/"/>
      <url>/blog/qi1md8/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content-editor-core lake-engine lake-typography-classic" data-lake-element="root" data-selection-undefined="%7B%22path%22%3A%5B%5B0%2C0%2C0%5D%2C%5B0%2C0%2C0%5D%5D%2C%22active%22%3Atrue%7D"><h2 id="8143e79b" data-lake-id="6e6e7508ba3b5435e2b1f1f31d3721f6" style="padding: 7px 0px; margin: 0px; font-weight: 700; font-size: 24px; line-height: 32px;">一、报错信息</h2><p data-lake-id="1b5f8aaa4df491e018ca5f29d568a55c" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><div data-card-type="block" data-lake-card="codeblock" id="638e3cf4" data-language="plain"><div class="lake-codeblock-content" style="border: 1px solid rgb(232, 232, 232); max-width: 750px; color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: rgb(249, 249, 249);"><div class="CodeMirror-sizer" style="color: rgb(89, 89, 89); margin: 0px; padding: 16px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"><pre class="cm-s-default" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"><span class="lake-preview-line" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"><span class="lake-preview-line-number lake-lm-pad-level-0" style="color: rgb(191, 191, 191); margin: 0px 8px 0px 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"></span><span class="lake-preview-codeblock-content" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">localhost:8080 is already in use</span></span><span class="lake-preview-line" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"><span class="lake-preview-line-number lake-lm-pad-level-0" style="color: rgb(191, 191, 191); margin: 0px 8px 0px 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"></span><span class="lake-preview-codeblock-content" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"></span></span><span class="lake-preview-line" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"><span class="lake-preview-line-number lake-lm-pad-level-0" style="color: rgb(191, 191, 191); margin: 0px 8px 0px 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"></span><span class="lake-preview-codeblock-content" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">Port 8080 required by Tomcat v8.0 Server at localhost is already in use. The server may already be running in another process, or a system process may be using the port. To start this server you will need to stop the other process or change the port number(s).</span></span><span class="lake-preview-line" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"><span class="lake-preview-line-number lake-lm-pad-level-0" style="color: rgb(191, 191, 191); margin: 0px 8px 0px 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"></span><span class="lake-preview-codeblock-content" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"></span></span><span class="lake-preview-line" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"><span class="lake-preview-line-number lake-lm-pad-level-0" style="color: rgb(191, 191, 191); margin: 0px 8px 0px 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"></span><span class="lake-preview-codeblock-content" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">Error running Tomcat8: Address localhost:8080 is already in use</span></span></pre></div></div></div><p data-lake-id="e4349de5bd7f8f254d74416b46dd2788" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><h2 id="ddf7c1a7" data-lake-id="31ab5fbf0ac1440219c327547324593f" style="padding: 7px 0px; margin: 0px; font-weight: 700; font-size: 24px; line-height: 32px;">一、分析并解决问题</h2><p data-lake-id="7c296753c51224da3f6f8ba86099478a" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><blockquote style="margin-top: 5px; margin-bottom: 5px; padding-left: 1em; margin-left: 0px; border-left: 3px solid rgb(238, 238, 238); opacity: 0.6;"><p data-lake-id="7b830aa09272d2dd170ab75569ebe12c" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">电脑中8080端口被占用，导致web项目不能运行</p></blockquote><p data-lake-id="55e542800a9d1849918b1951eff3f12b" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><blockquote style="margin-top: 5px; margin-bottom: 5px; padding-left: 1em; margin-left: 0px; border-left: 3px solid rgb(238, 238, 238); opacity: 0.6;"><p data-lake-id="3766c87d3d6fb43d668722db6b993e29" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">任务管理器关闭占用8080端口的程序</p></blockquote><p data-lake-id="1951daa14ef067b509b51dfc01982e59" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><h3 id="2943492d" data-lake-id="4a5d871e69c23370660c26c5ca25d322" style="padding: 7px 0px; margin: 0px; font-weight: 700; font-size: 20px; line-height: 28px;">netstat -ano</h3><p data-lake-id="c6a33238a58c8d1107d0242d17011aa5" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="59abdcdd660923e328cb466acc0e4017" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span data-card-type="inline" data-lake-card="image"><img data-role="image" src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1602926284869-236a07ed-16de-4b45-9fb3-08aa10dd3df8.png" data-raw-src="" class="image lake-drag-image" alt="image" title="image" data-height="600px" style="visibility: visible; width: 1200px;"></span></p><p data-lake-id="e7a3f8e5e9ad71f255140e140473fc2a" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><h3 id="tasklist" data-lake-id="71ae2e730075815b21e9d9a87b21a10f" style="padding: 7px 0px; margin: 0px; font-weight: 700; font-size: 20px; line-height: 28px;">tasklist</h3><p data-lake-id="6ca90fd8f888c59dee73ac67b7ef68c6" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="e1bc1b9363024045cd856135cdf88044" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span data-card-type="inline" data-lake-card="image"><img data-role="image" src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1602926285001-7e1779f1-5c00-4f0d-ad38-20b653849c37.png" data-raw-src="" class="image lake-drag-image" alt="image" title="image" data-height="221px" style="visibility: visible; width: 1200px;"></span></p><p data-lake-id="9ebfb697e2449fe0287d85487119855a" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span data-card-type="inline" data-lake-card="image"><img data-role="image" src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1602926284877-544af23f-b422-49de-af28-86f9c7a37ce3.png" data-raw-src="" class="image lake-drag-image" alt="image" title="image" data-height="183px" style="visibility: visible; width: 1200px;"></span></p><p data-lake-id="1a7c764a03c949479b2152f9ef987f9c" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><h3 id="69ad1550" data-lake-id="1a455bf815a857916cb9a3b3a9340b92" style="padding: 7px 0px; margin: 0px; font-weight: 700; font-size: 20px; line-height: 28px;">任务管理器</h3><p data-lake-id="711499bc584bb73d78ba43fc155d6240" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="d3ae8add94374a3de6911dd3f39bb3be" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span data-card-type="inline" data-lake-card="image"><img data-role="image" src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1602926285182-6bfb20a5-33a4-4a6b-8969-eaae9b7c67e4.png" data-raw-src="" class="image lake-drag-image" alt="image" title="image" data-height="550px" style="visibility: visible; width: 834px;"></span></p></div>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
          <category> Bug记录 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Hexo生成文章出错</title>
      <link href="/blog/pxpix4/"/>
      <url>/blog/pxpix4/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h2 id="8143e79b"><span class="ne-text">一、报错信息</span></h2><p id="udc9d4e1d" class="ne-p"><br></p><p id="0290256124b20eb1dffc0915b07ff279" class="ne-p"><br></p><pre><code>hexo gINFO  Start processingFATAL Somethings wrong. Maybe you can find the solution here: https://hexo.io/docs/troubleshooting.htmlTemplate render error: (unknown path)  unexpected end of file    at Object._prettifyError (D:\Blog\blog-wztlink1013-3.0\node_modules\nunjucks\src\lib.js:36:11)    at Template.render (D:\Blog\blog-wztlink1013-3.0\node_modules\nunjucks\src\environment.js:536:21)    at Environment.renderString (D:\Blog\blog-wztlink1013-3.0\node_modules\nunjucks\src\environment.js:378:17)    at D:\Blog\blog-wztlink1013-3.0\node_modules\hexo\lib\extend\tag.js:120:48    at tryCatcher (D:\Blog\blog-wztlink1013-3.0\node_modules\bluebird\js\release\util.js:16:23)    at Function.Promise.fromNode.Promise.fromCallback (D:\Blog\blog-wztlink1013-3.0\node_modules\bluebird\js\release\promise.js:209:30)    at Tag.render (D:\Blog\blog-wztlink1013-3.0\node_modules\hexo\lib\extend\tag.js:120:18)    at Object.onRenderEnd (D:\Blog\blog-wztlink1013-3.0\node_modules\hexo\lib\hexo\post.js:291:22)    at D:\Blog\blog-wztlink1013-3.0\node_modules\hexo\lib\hexo\render.js:79:21    at tryCatcher (D:\Blog\blog-wztlink1013-3.0\node_modules\bluebird\js\release\util.js:16:23)    at Promise._settlePromiseFromHandler (D:\Blog\blog-wztlink1013-3.0\node_modules\bluebird\js\release\promise.js:547:31)    at Promise._settlePromise (D:\Blog\blog-wztlink1013-3.0\node_modules\bluebird\js\release\promise.js:604:18)    at Promise._settlePromise0 (D:\Blog\blog-wztlink1013-3.0\node_modules\bluebird\js\release\promise.js:649:10)    at Promise._settlePromises (D:\Blog\blog-wztlink1013-3.0\node_modules\bluebird\js\release\promise.js:729:18)    at _drainQueueStep (D:\Blog\blog-wztlink1013-3.0\node_modules\bluebird\js\release\async.js:93:12)    at _drainQueue (D:\Blog\blog-wztlink1013-3.0\node_modules\bluebird\js\release\async.js:86:9)    at Async._drainQueues (D:\Blog\blog-wztlink1013-3.0\node_modules\bluebird\js\release\async.js:102:5)    at Immediate.Async.drainQueues (D:\Blog\blog-wztlink1013-3.0\node_modules\bluebird\js\release\async.js:15:14)    at processImmediate (internal/timers.js:456:21)</code></pre><p id="a6f9e2b26b91c578ff98443908ffdb5e" class="ne-p"><br></p><h2 id="8435b3ec"><span class="ne-text">二、分析并解决问题</span></h2><p id="8116886521e85c899667ead8b0939441" class="ne-p"><br></p><p id="81c68d6aebd4c5df313760f694ce83ee" class="ne-p"><span class="ne-text">根据报错信息，包nunjucks、bluebird使用异常</span></p><p id="752dccd22df2accc971e1af2f6f4842c" class="ne-p"><br></p><p id="24fafb7d6f3bf1242f3e94519e1e8995" class="ne-p"><span class="ne-text">然后进到node_modules文件夹里面分别找到两个包，进入README.md进入官网，numjucks包应该是渲染文章有关，期间出错应该是markdown文章里面所使用的标签与nunjucks模板引擎的标签冲突，</span></p><p id="92cfd6a7216a1a70cb3922ed6874d9c8" class="ne-p"><br></p><p id="bf9d4f2cb0f538212d0c492fc13933f5" class="ne-p"><span class="ne-text">根据文档定位英文大括号的使用，定位文章使用带有大括号的fancybox标签，标签结束忘记加end而导致出错</span></p><p id="84594cbd2668af5006192182d8ee9498" class="ne-p"><br></p><h2 id="e439b6ae"><span class="ne-text">三、hexo g 出错总结</span></h2><p id="4ed95a6a5dba1c9f93e05752e4e283ae" class="ne-p"><br></p><p id="81f39ca9a90a4429135f849befd2e58e" class="ne-p"><span class="ne-text">hexo g出错总结多为文件格式出错，主题配置出错，抑或是文章格式出错等</span></p><p id="8071d35b5aabe8d9c91b79eb1a4dce51" class="ne-p"><br></p><h3 id="a7851469"><span class="ne-text">文章头部</span></h3><p id="27050f9c56314d5415841c203b157e72" class="ne-p"><br></p><ul class="ne-ul"><li id="6e12cc6c48adc8ae1d03f3b434236566"><em><span class="ne-text">hexo相关文章报错，大多数为格式出错，文章头部的使用严格遵循hexo官方文档的使用，但是目录优化插件，使得文章头部的元信息更为简单化</span></em></li><li id="0094e52e5e0b5bdf749eb907f2ace394"><span class="ne-text">减号</span><code class="ne-code"><span class="ne-text">-</span></code><span class="ne-text">分隔符，注意头部front-matter、markdown行分隔。如果没有加front-matter，文章还用了markdown，会报错<br /></span><code class="ne-code"><span class="ne-text">YAMLException: end of the stream or a document separator is expected at line 6, column 1:</span></code></li><li id="b89d0887667d0801fb9ee3b28cd257bd"><span class="ne-text">目录优化插件的使用</span></li></ul><p id="f13ef048f86d86b522a2e6edce54091b" class="ne-p"><br></p><h3 id="d5bce8fc"><span class="ne-text">文章体</span></h3><p id="579711fa71a925dd2c3d0f97bbc49f6d" class="ne-p"><br></p><ul class="ne-ul"><li id="0a42815bf740f97e80d3c67440418199"><span class="ne-text">英文大括号的使用要“有始有终”，Volantis主题的大括号标签使用</span></li></ul><p id="b3cae8064e5d996bfaac2b365b037af5" class="ne-p"><br></p><h3 id="6feddb88"><span class="ne-text">空格问题</span></h3><p id="73742133f5f51e192492336031a9afe6" class="ne-p"><br></p><pre><code>ERROR Process failed: _posts/yuque/外汇时间序列预测.mdYAMLException: end of the stream or a document separator is expected at line 2, column 11:    categories:              ^    at generateError (D:\Blog\blog-wztlink1013-3.0\node_modules\js-yaml\lib\js-yaml\loader.js:167:10)    at throwError (D:\Blog\blog-wztlink1013-3.0\node_modules\js-yaml\lib\js-yaml\loader.js:173:9)    at readDocument (D:\Blog\blog-wztlink1013-3.0\node_modules\js-yaml\lib\js-yaml\loader.js:1545:5)    at loadDocuments (D:\Blog\blog-wztlink1013-3.0\node_modules\js-yaml\lib\js-yaml\loader.js:1588:5)    at Object.load (D:\Blog\blog-wztlink1013-3.0\node_modules\js-yaml\lib\js-yaml\loader.js:1614:19)    at parseYAML (D:\Blog\blog-wztlink1013-3.0\node_modules\hexo-front-matter\lib\front_matter.js:78:23)    at parse (D:\Blog\blog-wztlink1013-3.0\node_modules\hexo-front-matter\lib\front_matter.js:54:12)    at D:\Blog\blog-wztlink1013-3.0\node_modules\hexo\lib\plugins\processor\post.js:48:20    at tryCatcher (D:\Blog\blog-wztlink1013-3.0\node_modules\bluebird\js\release\util.js:16:23)    at Promise._settlePromiseFromHandler (D:\Blog\blog-wztlink1013-3.0\node_modules\bluebird\js\release\promise.js:544:35)    at Promise._settlePromise (D:\Blog\blog-wztlink1013-3.0\node_modules\bluebird\js\release\promise.js:604:18)    at Promise._settlePromise0 (D:\Blog\blog-wztlink1013-3.0\node_modules\bluebird\js\release\promise.js:649:10)    at Promise._settlePromises (D:\Blog\blog-wztlink1013-3.0\node_modules\bluebird\js\release\promise.js:729:18)    at Promise._fulfill (D:\Blog\blog-wztlink1013-3.0\node_modules\bluebird\js\release\promise.js:673:18)    at PromiseArray._resolve (D:\Blog\blog-wztlink1013-3.0\node_modules\bluebird\js\release\promise_array.js:127:19)    at PromiseArray._promiseFulfilled (D:\Blog\blog-wztlink1013-3.0\node_modules\bluebird\js\release\promise_array.js:145:14)    at PromiseArray._iterate (D:\Blog\blog-wztlink1013-3.0\node_modules\bluebird\js\release\promise_array.js:115:31)    at PromiseArray.init [as _init] (D:\Blog\blog-wztlink1013-3.0\node_modules\bluebird\js\release\promise_array.js:79:10)    at Promise._settlePromise (D:\Blog\blog-wztlink1013-3.0\node_modules\bluebird\js\release\promise.js:601:21)    at Promise._settlePromise0 (D:\Blog\blog-wztlink1013-3.0\node_modules\bluebird\js\release\promise.js:649:10)    at Promise._settlePromises (D:\Blog\blog-wztlink1013-3.0\node_modules\bluebird\js\release\promise.js:729:18)    at Promise._fulfill (D:\Blog\blog-wztlink1013-3.0\node_modules\bluebird\js\release\promise.js:673:18)    at PromiseArray._resolve (D:\Blog\blog-wztlink1013-3.0\node_modules\bluebird\js\release\promise_array.js:127:19)    at PromiseArray._promiseFulfilled (D:\Blog\blog-wztlink1013-3.0\node_modules\bluebird\js\release\promise_array.js:145:14)    at Promise._settlePromise (D:\Blog\blog-wztlink1013-3.0\node_modules\bluebird\js\release\promise.js:609:26)    at Promise._settlePromise0 (D:\Blog\blog-wztlink1013-3.0\node_modules\bluebird\js\release\promise.js:649:10)    at Promise._settlePromises (D:\Blog\blog-wztlink1013-3.0\node_modules\bluebird\js\release\promise.js:729:18)    at Promise._fulfill (D:\Blog\blog-wztlink1013-3.0\node_modules\bluebird\js\release\promise.js:673:18)INFO  Generating Baidu urls for last 1 posts</code></pre><p id="10e2910c1eb345ce483a118a0b0aac93" class="ne-p"><br></p><p id="64c77b8979194e0ea31bed3b51962930" class="ne-p"><span class="ne-text">奇葩错误，在最上面的三个分隔符后面也要加空格，可能是语雀那边同步过来的文章问题</span></p><p id="1e3923d7d621d60a86b2a271d041570f" class="ne-p"><br></p><h2 id="d17a0f0b"><span class="ne-text">参考</span></h2><p id="127424fd9c6256ada29b9793e5c43d35" class="ne-p"><br></p><ul class="ne-ul"><li id="3a670f8cba1c6b1ef1852f5fb14eeeef"><a href="https://mozilla.github.io/nunjucks/cn/getting-started.html" data-href="https://mozilla.github.io/nunjucks/cn/getting-started.html" target="_blank" class="ne-link"><span class="ne-text">nunjucks文档</span></a></li></ul></div>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
          <category> Bug记录 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>SSH登录报错</title>
      <link href="/blog/pix070/"/>
      <url>/blog/pix070/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h2 id="8143e79b"><span class="ne-text">一、报错信息</span></h2><p id="761152f5c808cb7d38ef42984e7cc521" class="ne-p"><br></p><pre><code><code>remote: Coding 提示: Authentication failed.remote: 认证失败，请确认您输入了正确的账号密码。fatal: Authentication failed for 'https://e.coding.net/wztlink1013/wztlink1013.git/'##[error]Process completed with exit code 128.</code></code></pre><p id="a8bd6aa03824b3fee9b508b237904085" class="ne-p"><br></p><h2 id="8435b3ec"><span class="ne-text">二、分析并解决问题</span></h2><p id="0a7298dd94a9898e274849cfba8e27f0" class="ne-p"><br></p><p id="d0f3fe7639a6665610483bd06e887764" class="ne-p"><span class="ne-text">自动化部署过程中，coding认证出错，我觉得应该有两个可能性</span></p><p id="97d4f0e71b685f58b34fab6cc8d08c8a" class="ne-p"><br></p><ol class="ne-ol"><li id="146323826f704af268d5f04419aa45c8" data-lake-index-type="0"><span class="ne-text">字面意思账号密码出错</span></li><li id="2c31f3bf4f9adabb87b8df236856237c" data-lake-index-type="0"><span class="ne-text">SSH密匙没有匹配到</span></li><li id="2a1164156ca68200a987ea75243e764e" data-lake-index-type="0"><span class="ne-text">在GitHub Actions上所配置的Token信息之间也修改了一次，会不会是忘了改用户名</span></li></ol><p id="c51b636f86f0c517cf986af15d5b7476" class="ne-p"><br></p><p id="a55a081aca880a4fc853f8fd5123f55a" class="ne-p"><span class="ne-text">如果是第一种情况，已经进入控制面板中的凭据管理器，更改了coding在本机上的默认永久密码，不弹窗理论没事，但是无效，</span></p><p id="6971a343522590a3830dc423dce83ba0" class="ne-p"><br></p><p id="7db10bb3a80c392794d2f314954c6e2d" class="ne-p"><span class="ne-text">根据上次在本机上克隆coding仓库也没有其任何反应，所以问题应该出在ssh密匙上面，进一步回想，自己重装电脑后，当时是打算不使用全局用户没加上global打算使用各个用户，但是最后又换成全局用户，所以生成的.ssh文件夹下的config文件有被删除了，会不会是config里面的coding host被删除，就默认这个电脑只有初始化github用户呢？</span></p><p id="6c9b8adf912cd8c0e1e677e9c63a8ac2" class="ne-p"><br></p><p id="46ac5f8a84910d50f6f10ed68c11b899" class="ne-p"><span class="ne-text">好的，试验了一下，解决了在本地电脑coding“不算用户”的问题，但是自动化部署的问题未解决</span></p><p id="c418c4409e76cd3ffba5b8ae0c5c3167" class="ne-p"><br></p><p id="d74b5f15ae3207ad791d90bd7c369b75" class="ne-p"><span class="ne-text">最后试一下GitHub Actions上是不是coding用户名之间忘了换一次，的确是……</span></p><p id="a955016f8030a00026cf6fe38aea877c" class="ne-p"><br></p><h2 id="d17a0f0b"><span class="ne-text">参考</span></h2><p id="b06903a987f6793be74653c8518d67a3" class="ne-p"><br></p><ul class="ne-ul"><li id="144069c225a0fb5a70f6b2f5d56fceef" data-lake-index-type="0"><a href="https://www.jianshu.com/p/501277e1bada" data-href="https://www.jianshu.com/p/501277e1bada" target="_blank" class="ne-link"><span class="ne-text">一台电脑利用秘钥绑定多个ssh-key账号（实n</span></a></li></ul></div>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
          <category> Bug记录 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Navicat弹框1045报错</title>
      <link href="/blog/wp9hok/"/>
      <url>/blog/wp9hok/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h2 id="WeVFN"><span class="ne-text">一、报错信息</span></h2><p id="cf5f4a7f1083fe6d2f0bbaf1b5b84145" class="ne-p"><br></p><pre><code><code>1045-Access denied for user root@localhost(using password:YES)</code></code></pre><p id="eedf373a200787f1fbef38cc5612986b" class="ne-p"><br></p><h2 id="43117871"><span class="ne-text">二、问题分析与解决</span></h2><p id="2c339a4453f6351b9b3a2b08e57487ce" class="ne-p"><br></p><p id="b627d75ea66c5a0c93c14c0598a057ba" class="ne-p"><span class="ne-text">不被接入，改root密码</span></p><p id="e3ae1b1417fdb74f54415345d17e187b" class="ne-p"><br></p><p id="130a3667ffbbf7789245b583f79b25fc" class="ne-p"><span class="ne-text">在mysql控制台里面改密码</span></p><p id="488f9d4e1a58439def93d24f16d5a4a7" class="ne-p"><br></p><p id="e9cc0fdbe2507031a2f5f37cc2b22ff1" class="ne-p"><code class="ne-code"><span class="ne-text">ALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY '你的密码';</span></code></p><p id="a5b3c1f6f0cbba5c627f295099ee9988" class="ne-p"><br></p><p id="c60fe0d946ea3a88bfc10502a28436b4" class="ne-p"><span class="ne-text">刷新数据库</span></p><p id="223e3e13d2036f1356f8c3fca17090fd" class="ne-p"><br></p><p id="034821b17ea0bac9ced4ddf0ad122d5a" class="ne-p"><code class="ne-code"><span class="ne-text">flush privileges;</span></code></p><p id="dd50c550c7e8962d61e96ee6a110cfbe" class="ne-p"><br></p><p id="3a94eff37557d8316b987dfd47a34f0e" class="ne-p"><span class="ne-text">退出</span></p><p id="76ebc5952b42a751224a0e25846f5f5e" class="ne-p"><br></p><p id="eeac4566ed6043956c11313ec270d7a7" class="ne-p"><code class="ne-code"><span class="ne-text">quit;</span></code></p><p id="701ba1c28f8c40d7a2d0ec3ad5ea1fad" class="ne-p"><br></p><p id="7cc50a2f0b953b821b843276aa571580" class="ne-p"><span class="ne-text">重启Navicat再次链接即可。</span></p><p id="167333e5553eeced03dc96ea275ee4d9" class="ne-p"><br></p><h2 id="d17a0f0b"><span class="ne-text">参考</span></h2><p id="b3a317b50036cee0e03be7e3b516003a" class="ne-p"><br></p><ul class="ne-ul"><li id="70986a211afe210d9bf4b76d270a5e2a" data-lake-index-type="0"><a href="https://blog.csdn.net/acoolgiser/article/details/82967317?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522159185926319725250149590%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=159185926319725250149590&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_ctr_v3-4-82967317.ecpm_v1_rank_ctr_v3&amp;utm_term=1045-Access+denied+for+user+ro" data-href="https://blog.csdn.net/acoolgiser/article/details/82967317?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522159185926319725250149590%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=159185926319725250149590&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_ctr_v3-4-82967317.ecpm_v1_rank_ctr_v3&amp;utm_term=1045-Access+denied+for+user+ro" target="_blank" class="ne-link"><span class="ne-text">acoolgiser</span></a></li><li id="5e3aebd52bb51d553f88676be9d8606b" data-lake-index-type="0"><a href="https://blog.csdn.net/zhang_yu_ling/article/details/103177296?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522159185926319725250149590%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=159185926319725250149590&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_ctr_v3-2-103177296.ecpm_v1_rank_ctr_v3&amp;utm_term=1045-Access+denied+for+user+ro" data-href="https://blog.csdn.net/zhang_yu_ling/article/details/103177296?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522159185926319725250149590%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=159185926319725250149590&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_ctr_v3-2-103177296.ecpm_v1_rank_ctr_v3&amp;utm_term=1045-Access+denied+for+user+ro" target="_blank" class="ne-link"><span class="ne-text">张张张i</span></a></li></ul></div>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
          <category> Bug记录 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>炒土豆</title>
      <link href="/essay/cfatgg/"/>
      <url>/essay/cfatgg/</url>
      
        <content type="html"><![CDATA[<div class="yuque-hexo-lyrics-secret">这是加密文章！</div>]]></content>
      
      
      <categories>
          
          <category> 料理 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>『斩·赤红之瞳』</title>
      <link href="/essay/vbkkpv/"/>
      <url>/essay/vbkkpv/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="4d5347df929630415d1eaa23d5a8f0b4" class="ne-p"><span class="ne-text">赤瞳的“葬送！”永远无敌，威尔的乡巴佬（贵族）战车甚是让人怀念！</span></p><p id="u02c38766" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1620268429108-34b6b7b4-9e0e-44f5-aec6-6ea523773328.jpeg" width="60" id="tBuFQ" class="ne-image"></p><p id="u011e84f1" class="ne-p"><br></p><p id="uab433b80" class="ne-p"><span class="ne-text">最喜欢威尔这个角色，有自己的信仰，却又不被信仰所蒙蔽双眼！</span></p><p id="u2b652480" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1620268376141-97fd7be2-f256-442b-970d-1ab2b6b29214.png" width="960" id="u9c94a2b1" class="ne-image"></p><p id="u39838fd4" class="ne-p"><br></p><p id="uac513801" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1619317355425-0fe5d175-5fc4-4e3c-b6e0-ecef02d26cf6.png" width="1920" id="uf72f0f30" class="ne-image"></p><p id="2d98ab074f3c7042e488f2cbe8a8fc8b" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1619403236436-3b1f1084-70d1-470c-8033-8da759333d26.png" width="1378" id="KgBwl" class="ne-image"></p><p id="7dc62483859c13d4e812cef7cd35d93a" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1619403320717-174bfe62-fc0d-4470-ade4-dfaec764e1a8.jpeg" width="1920" id="OBENY" class="ne-image"></p><p id="c724b4145e0046b3240614788eaa0dfc" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1619403335035-06379a53-3aa1-4ed1-8194-864aa0423edf.png" width="1920" id="BZQXf" class="ne-image"></p><p id="635826ac418eda5a93f130567610a042" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1619403340923-d3a0d8f3-2a53-4f2d-ae07-18c5a4d10d3b.jpeg" width="1920" id="poIeY" class="ne-image"></p></div>]]></content>
      
      
      <categories>
          
          <category> 影视 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>榕树下的男孩和女孩</title>
      <link href="/essay/rqlvig/"/>
      <url>/essay/rqlvig/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="1d7566e2ce91837757f63ad4c71dc461" class="ne-p"><span class="ne-text">趁着伙伴们都还在睡觉那天还未入夜，他朝着桥的那头跑去，那天月亮高高挂起，像是蒙娜丽莎的那般深邃眼眸观望着他，突然，他像是被什么东西拍打了一下，男孩往后望去，是个小女孩，那女孩头发短短的，头发末梢还有些卷卷的，就像是柳树下的枝柳发梢一般，凌乱有致，最重要的是男孩被那饱含星辰大海的眼眸所吸引，还有那唇……小男孩突然一愣，回应道：“你是谁？”女孩说：“我练完了，想去桥的那头玩玩！”男孩惊讶之，连忙回应：“我也是”，榕树那边的风景亦是观之，却不能让我陶醉，说罢，小男孩帮那个小女孩整理一番身边的杂草，他想牵起哪个女孩的手，但是他并没有，他在害怕吗？不知道。我想可能是他没有这般前期过别人的手吧。</span></p><p id="4441b864f887e27f7ccf204b29aaccb7" class="ne-p"><br></p><p id="3190081a6e59df3c1441b07abc83880c" class="ne-p"><span class="ne-text">桥的那头好漂亮，哪里有些许的繁华，还有些唱作，同时传来了一阵阵的童谣响起，那个女孩心里一颤，她说，如熟悉的唱作，和我家乡一般，她说她听到了她儿时的童谣，男孩向她的眼眸观去，他像是看到了星辰，他瞬间感受到一种温度，是的！他喜欢上她了。</span></p><p id="a5c0557a57bacf31ec6fad3c7a9a026b" class="ne-p"><br></p><p id="a56aad4aa282c86bfa6016bb8246d630" class="ne-p"><span class="ne-text">榕树下的人们，是有着各自的命运的，男孩和女孩，男孩子要往前走，因为这里的人们是不能停滞的。因为它们本该如此。</span></p><p id="cd07cb19ab0d9b7ed28b6e7e57891e2a" class="ne-p"><br></p><p id="7d0db8c5f650bd4d67fac45439107db1" class="ne-p"><span class="ne-text">男孩终于忍不住了，他对女孩说：“你喜欢这个童谣吗？”女孩说：“好感动，能在这个地方听到这个童谣”，女孩有一个动作，她用手指收起了她的眼泪，男孩心里想着，桥是禁忌，按照他们的文明，那是他们不能逾越的禁忌。</span></p><p id="2d5b2b73089d8c223e2e84e4ab37cd00" class="ne-p"><br></p><p id="750dcb31634e19f9342bc273a591bf68" class="ne-p"><span class="ne-text">旁边的蛐蛐们开始了，仿佛开始为那童谣奏乐了，周围很喧闹，但是他的内心足够安静的，一切都是那般静，那一瞬间，那个男孩就像静静地享受着这般安静与温暖，就像是圆月下的海面，波光涟漪却也有着阵阵波澜。</span></p><p id="e81d44610904b1fb7a710f1c62c7d174" class="ne-p"><br></p><p id="8fa5f2a123c69946518c38feb8be5d17" class="ne-p"><span class="ne-text">桥就像是时间的奴隶，夜深了，桥头的那根锁链开始叮叮叮~的响起，像是提醒着失足的孩子们该回去了，男孩和女孩的时间不读了，往日，男孩会跑着回桥的那头榕树下，来日再来看看这繁华的都市，然后回到榕树下面，因为本该如此，他比谁都清楚榕树下的他背负着怎么样的命运。</span></p><p id="bf773ddc8ebbc413d245ca9a9ce98de2" class="ne-p"><br></p><p id="5e65cf931f30609108468b0a568faa49" class="ne-p"><span class="ne-text">黑夜里，男孩再也看不见女孩的脸，月光很圆，周围的灯也是明亮着的，但男孩却觉得周围一切都是暗淡的，因为他再也看不见那深邃的眼眸。</span></p><p id="bf7c1ce617753b73746228c3656ff276" class="ne-p"><br></p><p id="701110b2feba53e25a78ee149c96e9db" class="ne-p"><span class="ne-text">女孩对男孩说：“谢谢你帮我越过那座桥，我才有了这般幸运，在这榕树下的文明之外还能听到这般旋律，谢谢你！”</span></p><p id="17b374ef3671a31ce0cfc933e636ac65" class="ne-p"><br></p><p id="63d690780371f847b501d7fa5d01a446" class="ne-p"><span class="ne-text">但是男孩心里想要的不是这句谢谢，是她眼神之下的温暖的星辰大海，因为他一直往前走，修炼。</span></p><p id="e6373480df5c8b13e5682bb37b355adb" class="ne-p"><br></p><p id="bf86e966e4fced747e73743c61952f9e" class="ne-p"><span class="ne-text">他想要在榕树下成为一个真正的男人，特立独行，无惧生死，因为他觉得，他本该如此！可今天，他似乎被他的脸庞融化了。</span></p><p id="a4ef5a86c0d7e8da0acc15641c1a2fb9" class="ne-p"><br></p><p id="8226b772c42542e024ff90eccad992c4" class="ne-p"><span class="ne-text">一路上，男孩和女孩说着话，他从来没有这般欣喜，来到榕树下面，这个新生的文明之下，可是，女孩的话却在变少。</span></p><p id="1b64e79979726d07de770d8d9d1af857" class="ne-p"><br></p><p id="09826dd0ccd0dcb374010907d7edf95b" class="ne-p"><span class="ne-text">回到榕树下，隧道已经慢慢如期开启，男孩和女孩要走了，男孩心里清楚着，他不会再见她了，他心里忧伤，却也无奈，因为，在此之下的文明，亦是如此，就像是之前所述的“内壁”那般文明、国度。或者还可以说，文明之间，男孩和女孩是不合适的，因为她走的和他走的路从一开始就是相反的道路，但在榕树下的男孩确实一直以来有着思想的精灵，他有些忍不住了，在女孩走向隧道那扇门之前那么一瞬，男孩大声说：“喂，你，你的眼睛很好看，虽然夜太黑，但我心里还记得，我喜欢你，喜欢你喜欢的童谣，喜欢你眼睛中的星辰大海！我从没有想过，在榕树下的文明，还能遇见此般的你。还有，我很喜欢你的微笑。”女孩说：“嗯。”</span></p><p id="f0977dd3725c4a2381780c8afffe3662" class="ne-p"><br></p><p id="65bfb4e9a768829c0f3c1419f9950934" class="ne-p" style="text-align: right"><span class="ne-text">2020.10.12 文渊楼C区255 划水ing</span></p><p id="d86240bf1f2f2d9aad38e7931f8cd558" class="ne-p"><br></p><p id="93bac6acd442264a945de2d3261188be" class="ne-p"><br></p></div>]]></content>
      
      
      <categories>
          
          <category> 异世界 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>鸟儿飞走了</title>
      <link href="/essay/pyxkf8/"/>
      <url>/essay/pyxkf8/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p class="ne-p"><span class="ne-text">学校又要建楼了，地点是图书馆靠西边的那片树林。</span></p><p class="ne-p"><br></p><p class="ne-p"><span class="ne-text">去二餐的靠建筑工地的那条沿路上，总是听到叽叽喳喳的小鸟叫声，定睛一看，原来是因建筑而没有去路的小鸟，它们就在那片矮秃秃的草丛里面，就像是饿了的稚鸟在窝里面叽叽喳喳等它们母亲回来一般。</span></p><p class="ne-p"><br></p><p class="ne-p"><span class="ne-text">“济南一建”的速度真是快，短短一个月不到，那栋楼就建成有二、三层高楼那般模样，可我却不太喜欢它们这么快速度，因为那样，就会挡住我在E区各个楼道往学校南边观去的视线，正好挡住学校后面的双龙山，学校的小鸟也会少了，估计它们会生气般地往山上飞去，不再飞回来了。</span></p><p class="ne-p"><br></p><p class="ne-p"><span class="ne-text">为什么我会有些许的伤感……</span></p><p class="ne-p"><br></p><p class="ne-p"><br></p></div>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对待问题要静心处理</title>
      <link href="/essay/wgtfly/"/>
      <url>/essay/wgtfly/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content-editor-core lake-engine lake-typography-traditional" data-lake-element="root" data-selection-undefined="%7B%22path%22%3A%5B%5B4%2C0%2C28%5D%2C%5B4%2C0%2C28%5D%5D%2C%22active%22%3Atrue%7D"><p data-lake-id="a20d224c568e48b9d67847a2c66a8c01_p_0" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">在配置安卓环境的时候，遇到sdk漏下载的情况，中间有几次心态爆炸，遇到问题发现自己还是不能很好的解决</p><p data-lake-id="c789ee93d870002ab938c2a1eaa2945c" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="8a79987fff927dee2a879f619b9d093d" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">这过程中，S同学说到他配置环境用到了三天，最后成功了，而且，他的环境远劣于我，突然让我想到一句话，<strong>谁都会遇到问题，甚至遇到的问题都一样</strong>。但是不同的人会有不同的处理方式以及对待问题的态度，我的心真的还不够静，甚至可以说，依旧那么浮躁…</p><p data-lake-id="cce84e6685db6643aa7e727e2610a2da" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="dd4591e6ca22fb5dbaba5cfa73b9180c" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">遇到困难，要静下心来，纸上得来终觉浅，绝知此事要躬行啊～</p></div>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>SQL表查询操作</title>
      <link href="/blog/igxqxi/"/>
      <url>/blog/igxqxi/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h2 id="BAHT9"><span class="ne-text">基本词汇</span></h2><div class="ne-quote"><p id="281ac2126bb3f15c34855cb037ef59f1" class="ne-p"><span class="ne-text">查询就是SELECT语句</span></p></div><pre><code>SELECT  [ ALL | DISTINCT ]        [ TOP expression [ PERCENT ] [ WITH TIES ] ]     &lt;列名&gt;                                             /*指定要选择的列及其限定*/    [ INTO &lt;表名&gt; ]                             /*INTO子句，指定结果存入新表*/    [ FROM &lt;查询对象&gt; ]                        /*FROM子句，指定表或视图*/    [ WHERE &lt;条件&gt; ]                             /*WHERE子句，指定查询条件*/    [ GROUP BY &lt;分组表达式&gt;]                 /*GROUP BY子句，指定分组表达式*/    [ HAVING &lt;分组统计条件&gt;]                 /*HAVING子句，指定分组统计条件*/    [ ORDER BY &lt;排序表达式&gt; [ ASC | DESC ] ] /*ORDER子句，指定排序表达式和顺序*/<p></code></pre></p><div class="ne-quote"><p id="4531c0da0da9a1258271824694ebff28" class="ne-p"><span class="ne-text">说明：所有被使用的子句必须按语法说明中显示的顺序严格地排序。例如，一个HAVING子句必须位于GROUP BY子句之后，并位于ORDER BY子句之前。</span></p><p id="eeb63e310ce88f6799d083e7792faacb" class="ne-p"><span class="ne-text">SELECT语句返回一个表的结果集，通常该结果集被称为表值表达式。</span></p></div><h3 id="6dc7a717"><span class="ne-text">distinct</span></h3><p id="fd53e647a7907bfb73bd61e511df1db6" class="ne-p"><span class="ne-text">去掉重复的行</span></p><h3 id="MP2oa"><span class="ne-text">where</span></h3><div class="ne-quote"><p id="acbdd8aff3701871c1e5eb3b0fb5b1a0" class="ne-p"><span class="ne-text">条件</span></p></div><pre><code>select distinct Sname        from Student        where Sdept='CS'</code></pre><h3 id="VaMqd"><span class="ne-text">as</span></h3><p id="d9713f77d96e56752ea9608cf3711677" class="ne-p"><br></p><pre><code>SELECT id AS userId，username AS uname     FROM users;</code></pre><p id="0a7683985a492fc96205f2276289b805" class="ne-p"><br></p><p id="a5f6598ca4f824c5d1463ff8af6222c2" class="ne-p"><span class="ne-text">查询出来的列名，就变成了别名。AS其实可以省略，但可能会出现问题。</span></p><p id="5bbf5b398e0497c6449f873132394594" class="ne-p"><br></p><pre><code>SELECT id username  FROM users;</code></pre><p id="ff49d08443d85b0933eaed9abca91b4c" class="ne-p"><br></p><p id="a697740377cad6b21f828f6ee3d7b953" class="ne-p"><span class="ne-text">这样会将username视作id的别名。</span></p><p id="2ecf77b59883f38893a621b52ffe096e" class="ne-p"><br></p><h3 id="d2nhV"><span class="ne-text">like </span></h3><pre><code>SELECT 书名 AS BookName, 作译者 AS Author, 出版社 AS PressFROM TBookWHERE 书名 LIKE '%SQL Server%'</code></pre><pre><code>select Sname, Sno, Ssex    from Student    where Sname not like '刘_'</code></pre><h3 id="ed92d"><span class="ne-text">is not</span></h3><pre><code>select Sno, Cno    from SC    where Grade is not null</code></pre><h3 id="dbCr3"><span class="ne-text">and、or</span></h3><pre><code>select Sname, Ssex    from Student    where Sdept='CS' or Sdept='MA' or Sdept='IS'</code></pre><div class="ne-quote"><p id="adb32849efc88d55c2cf30c3a5374d20" class="ne-p"><span class="ne-text">键可以不用引号，但是值要引号</span></p><p id="4b3a0da6caa18adae6001b5849b80b5f" class="ne-p"><span class="ne-text">列名又空格也需要加引号</span></p></div><h3 id="dGNnp"><span class="ne-text">top</span></h3><div class="ne-quote"><p id="a9172d454d894153ef9934a50bd99be5" class="ne-p"><span class="ne-text">前五行数据</span></p></div><pre><code>select top 5 *    from rating</code></pre><h3 id="fxnoz"><span class="ne-text">not in</span></h3><pre><code>select Sname, Ssex    from Student    where Sdept not in ('CS', 'MA', 'IS')</code></pre><h3 id="rlZsi"><span class="ne-text">多表查询</span></h3><ul class="ne-ul"><li id="8ac489789f94b187322d0cdc18cf5e78"><span class="ne-text">有公共的列，在前面表名以示区分</span></li><li id="f92a34621cec7f3b9a0b6c3979eaa7c7"><span class="ne-text">指明两个表的公共</span><strong><span class="ne-text">相等</span></strong><span class="ne-text">的列</span></li></ul><p id="5f508966e82e1181e498b1b9368226c7" class="ne-p"><br></p><pre><code>select TLend.ISBN, TLend.借书时间, TLend.借书证号, TLend.图书ID, TLend.应还时间,TReader.姓名from TReader,TLend, TBookwhere TReader.借书证号 = TLend.借书证号    and TBook.ISBN = TLend.ISBN    and TLend.借书证号 = '081101'    and TBook.书名 = 'SQL Server实用教程（第3版）'</code></pre><p id="5ead02499b17dc7850d53fc75b2b3412" class="ne-p"><br></p><h3 id="aplrm"><span class="ne-text">join on</span></h3><pre><code>select 姓名    from TReader join HLend    on TReader.借书证号 = HLend.借书证号    where (还书时间 - 借书时间)&gt;5</code></pre><p id="7d549f41dbeaa3adcfac5c7e60a74784" class="ne-p"><br></p><h3 id="o7p21"><span class="ne-text">count</span></h3><pre><code>select count(*) 读者总数    from TReader</code></pre><h3 id="OwVTx"><span class="ne-text">order by</span></h3><p id="5a3acfe63f9a872b07ab292fcf16c909" class="ne-p"><span class="ne-text">排序ORDER BY</span></p><pre><code>select Sno, Grade    from SC    where Cno='3'    order by Grade desc</code></pre><p id="014af1100827bc3acb9c02b77e2bc202" class="ne-p"><br></p><pre><code>SELECT *         FROM users     ORDER BY id DESC;</code></pre><p id="483a65d5078046613cc9d0e5ddcee7c8" class="ne-p"><br></p><p id="70726d943f542af6b025aca5d1c563ab" class="ne-p"><span class="ne-text">可以排序多个字段，如果第一个字段能排出结果，就不会用到第2个字段。比如：</span></p><p id="8329dde98bc38a7ce9cea68501c907fd" class="ne-p"><br></p><pre><code>select *    from Student    order by Sdept asc, Sage desc</code></pre><p id="2ac4c26b9311f6d34de6dd4ee273f93a" class="ne-p"><br></p><p id="3ad877dee5e11d750dc533bb5a405170" class="ne-p"><span class="ne-text">因为年龄age有相同的，继续排序就要用到id的降序。</span></p><h3 id="Picn0"><span class="ne-text">limit</span></h3><p id="8abc030f3ba54deeceeb9546528aa4c9" class="ne-p"><span class="ne-text">限制返回记录的数量LIMIT</span></p><p id="8661b05ac0d65f80d90f7ec2bd98c4ff" class="ne-p"><br></p><p id="12b5c6dcde437cf2254ad1ebf95f8ff1" class="ne-p"><span class="ne-text">LIMIT有两种语法结构，第一种比较常见。</span></p><p id="8dfa2d111a3ef8934eabbf6e23c85b4d" class="ne-p"><br></p><pre><code>[LIMIT &#123;[offset,] row_count|row_count OFFSET offset&#125;]</code></pre><p id="d7652c18e1385552436b5b86d06f1fce" class="ne-p"><br></p><p id="adc857a105cbdddacdfad48be8a47190" class="ne-p"><span class="ne-text">起始位置，偏移量</span></p><p id="0f48eae9cf7ba61f3bf7693a0106b160" class="ne-p"><br></p><pre><code>SELECT * FROM users ;SELECT * FROM users LIMIT 3,2;SELECT * FROM users LIMIT 2;</code></pre><p id="39e528143c423496958047bbfa312a2e" class="ne-p"><br></p><p id="466af24c8b5a652791546c053aae5e7a" class="ne-p"><span class="ne-text">3，2：表示从第3条开始返回，返回两条记录。注意记录从0开始编号，即结果集中的从第0条开始。</span></p><p id="6a7c63f313d4b4660cc2fde3880870ee" class="ne-p"><span class="ne-text">如果LIMIT后面只有一个参数，认作是偏移量，起始位置缺省为0。</span></p><h3 id="ZGe8y"><span class="ne-text">union</span></h3><div class="ne-quote"><p id="bf62e876116b6699d55de270a0e65bbb" class="ne-p"><span class="ne-text">合并查询结果UNION</span></p></div><p id="43989b427a41d639e28fb6195bbf4fa6" class="ne-p"><br></p><p id="2d376262551d119cbf5c7c16f587109f" class="ne-p"><span class="ne-text">在多条查询语句之间，使用</span><code class="ne-code"><span class="ne-text">UNION</span></code><span class="ne-text">关键字会合并所有查询结果。</span></p><p id="22e5197503f961dbdfe1e2691fd3cbf3" class="ne-p"><span class="ne-text">默认会去掉重复行，如果不想去掉重复行，请使用</span><code class="ne-code"><span class="ne-text">UNION ALL</span></code></p><p id="e7a161b58d34360ebdaf1a6f733787be" class="ne-p"><span class="ne-text">需要注意的是，要联合的查询结果必须有相同的列数（列名可以不同）</span></p><p id="80b32292eb23024a24c4a389a207112b" class="ne-p"><br></p><div class="ne-quote"><p id="45781a46e2b90fbe68964d5b7bec265d" class="ne-p"><span class="ne-text">去重效率比不去重效率低</span></p></div><h2 id="b314d699"><span class="ne-text">group by</span></h2><p id="ac8f94bdad64203162d6e031ff1f3b8b" class="ne-p"><br></p><pre><code>[GROUP BY &#123;col_name|position&#125; [ASC|DESC],...]</code></pre><p id="03d55535e34290137d6b15f46f7ffba0" class="ne-p"><br></p><pre><code>select 专业, count(*) 不同专业人数    from TReader    group by 专业</code></pre><p id="3e2228cd0c39e475a148771c8dc672bd" class="ne-p"><br></p><h3 id="8Tk5D"><span class="ne-text">having</span></h3><p id="660abed82a1c3f051696d3a05507c778" class="ne-p"><br></p><p id="418f511347293cb6c5e6d382e07bb60e" class="ne-p"><span class="ne-text">与GROUP BY分组联用。只对部分记录做分组操作。有两种用法，比如：</span></p><p id="e650a089613a601f28e56af68764cd79" class="ne-p"><br></p><pre><code>SELECT sex,age     FROM users   GROUP BY sex   HAVING age &gt; 35;SELECT sex     FROM users   GROUP BY sex   HAVING count(id) &gt;=2;</code></pre><p id="45011a6607bdd5fee5736b771f0a2a79" class="ne-p"><br></p><ul class="ne-ul"><li id="a865927409cb49c1d5a9972f8dd4ade7"><span class="ne-text">第一种，注意后面的HAVING的字段必须在前面SELECT部分出现才行。</span></li><li id="3fe9ea7ca402c7b34fc9c5fa6665e941"><span class="ne-text">第二种，在HAVING后面使用</span><em><span class="ne-text">聚合函数</span></em><span class="ne-text">，前面无需出现相应字段。</span></li></ul><h3 id="eeigV"><span class="ne-text">asc、desc</span></h3><p id="5dc31ad70623ca877473d3382b43e18b" class="ne-p"><span class="ne-text">排序升序asc、降序desc</span></p><pre><code>SELECT *      FROM TReader    WHERE 专业='计算机'    ORDER BY 出生时间 desc</code></pre><h2 id="KKotB"></h2><h2 id="5qtqd"><span class="ne-text">子查询</span></h2><p id="4eb3539e532e05ef2d8807304b1e2712" class="ne-p"><span class="ne-text">子查询（Subquery）是指嵌套在查询内部，且必须始终出现在圆括号内。外面的查询并非只是指的查找。可以包含的关键字或条件：</span></p><p id="3e5d234ec64c9db23c6f007fbc1edd5c" class="ne-p"><br></p><pre><code>DISTINCT、GROUP BY、ORDER BY、LIMIT、函数等</code></pre><p id="bc2f8a49be62677959cda3523fcb7ddf" class="ne-p"><br></p><p id="cba664cd34a1463059d2a0de318677af" class="ne-p"><span class="ne-text">外层的查询可以是：</span></p><pre><code>SELECT、INSERT、UPDATE、SET、DO</code></pre><p id="bb2dcce48080eadc8e634a2b952092d7" class="ne-p"><br></p><h3 id="c20a854c"><span class="ne-text">①使用比较运算符的子查询</span></h3><p id="61bbe9b8f6c9e56ae9409704114ac210" class="ne-p"><br></p><ul class="ne-ul"><li id="d1a4e57d08eefdbe73eaa21074c5a292"><span class="ne-text">比较运算符</span></li></ul><div class="ne-quote"><p id="90f885d99059bf5298bdac4254924043" class="ne-p"><span class="ne-text">=,&gt;,&lt;,&gt;=,&lt;=,&lt;&gt;,!=,&lt;=&gt;</span></p></div><pre><code>SELECT *     FROM av   WHERE 身高&gt;=(    SELECT AVG(身高)     FROM av);</code></pre><ul class="ne-ul"><li id="4d14d43f0cfaf0163ad55c93632e8c05"><span class="ne-text">修饰比较运算符</span></li></ul><div class="ne-quote"><p id="831bf50f68e8c205ffb57a2ba9fa9216" class="ne-p"><span class="ne-text">使用ANY、SOME、ALL，ANY和SOME是等价的。</span></p></div><table id="b57b04cd" class="ne-table" style="width: 750px"><tbody><tr style="height: 33px"><td width="250"></td><td width="250"><p id="ueb01277f" class="ne-p"><span class="ne-text">ANY</span></p></td><td width="250"><p id="u359438cc" class="ne-p"><span class="ne-text">ALL</span></p></td></tr><tr style="height: 33px"><td width="250"><p id="udb1e1be3" class="ne-p"><span class="ne-text">&gt;,&gt;=</span></p></td><td width="250"><p id="u75800521" class="ne-p"><span class="ne-text">最小值</span></p></td><td width="250"><p id="ud5788adf" class="ne-p"><span class="ne-text">最大值</span></p></td></tr><tr style="height: 33px"><td width="250"><p id="u7532e55b" class="ne-p"><span class="ne-text">&lt;,&lt;=</span></p></td><td width="250"><p id="uc73eecdb" class="ne-p"><span class="ne-text">最大值</span></p></td><td width="250"><p id="u97e62f36" class="ne-p"><span class="ne-text">最小值</span></p></td></tr><tr style="height: 33px"><td width="250"><p id="ueb1bbb2f" class="ne-p"><span class="ne-text">=,&lt;=&gt;</span></p></td><td width="250"><p id="uc1c1cfb0" class="ne-p"><span class="ne-text">任意值</span></p></td><td width="250"></td></tr><tr style="height: 33px"><td width="250"><p id="u031e803b" class="ne-p"><span class="ne-text">&lt;&gt;,!=</span></p></td><td width="250"></td><td width="250"><p id="uf9627cd1" class="ne-p"><span class="ne-text">任意值</span></p></td></tr></tbody></table><p id="883142559a32aedc80f551ce437abf33" class="ne-p"><br></p><pre><code>select emp.empno,emp.ename,emp.job,emp.sal     from scott.emp   where sal &gt;any(    select sal     from scott.emp     where job=&quot;MANAGER&quot;);</code></pre><p id="4bd629ff4606f6c8c8232194b6a79177" class="ne-p"><span class="ne-text">等价于下边两步的执行过程：</span></p><p id="7ef8ba5a0ef89dc534f154e5a2ba54f8" class="ne-p"><span class="ne-text">（1）执行“select sal from scott.emp where job=&quot;MANAGER&quot;”</span></p><p id="60710ae1df17911ff409807e322e6d96" class="ne-p"><span class="ne-text">（2）查询到3个薪水值2975、2850和2450，父查询执行下列语句：</span></p><p id="48a8f9f18b8eb74f6c42f7c31079591b" class="ne-p"><span class="ne-text">select emp.empno,emp.ename,emp.job,emp.sal from scott.emp where</span><strong><span class="ne-text"> sal &gt;2975 or sal&gt;2850 or sal&gt;2450;</span></strong></p><p id="43d523eb3403f3e415ad8d5f6ba940b8" class="ne-p"><br></p><h3 id="2a70086d"><span class="ne-text">②使用[not]in的子查询</span></h3><p id="2b197f1c63e1945e5c3cf21334fe4c95" class="ne-p"><br></p><pre><code>operand comparison_operator [NOT] IN (subquery)</code></pre><p id="0561a4e8a1dfe0fe1190ee3a2c628b9b" class="ne-p"><br></p><p id="e71700f53886c787f975673837e82b71" class="ne-p"><span class="ne-text">=ANY和IN等效</span></p><p id="155544c5673d207a078d0e87606f04e5" class="ne-p"><span class="ne-text">!=ALL和NOT IN等效</span></p><p id="59a25caea3dbe30ebbc6b8a21e67453b" class="ne-p"><br></p><h3 id="bce73132"><span class="ne-text">③使用[not]exists的子查询</span></h3><p id="d2d7cb964a28eb75b8ca2f4f57064cd8" class="ne-p"><br></p><p id="46729483bfe6cecb3e7e451f47781822" class="ne-p"><span class="ne-text">如果子查询返回任何行，EXISTS将返回TRUE，否则返回FALSE。</span></p><p id="6177da588331b479ef62f4c63843e42a" class="ne-p"><span class="ne-text">该类子查询使用较少</span></p></div>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
          <category> DataBase </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>SQL数据库操作</title>
      <link href="/blog/afuf5u/"/>
      <url>/blog/afuf5u/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h2 id="NtKL9"><span class="ne-text">创建数据库</span></h2><p id="0137b33a88e2a14b4cdebae6363de1b1" class="ne-p"><br></p><pre><code>CREATE &#123;DATABASE|SCHEMA&#125; [IF NOT EXISTS] db_name [DEFAULT] CHARCTER SET [=] charset_name;</code></pre><p id="761d7943cd1f51a6c49e73715407a1c4" class="ne-p"><br></p><div class="ne-quote"><p id="56387d24eb0c30ad36984cef4453f00a" class="ne-p"><span class="ne-text">注意设置字符集的时候，utf-8要写作utf8</span></p></div><h2 id="UDttS"><span class="ne-text">使用数据库</span></h2><div class="ne-quote"><p id="515a62ea8b08a3c21f0c30d78c60ce81" class="ne-p"><span class="ne-text">使用指定数据库</span></p></div><pre><code>use DATABASEgo</code></pre><h2 id="2ba003cd"><span class="ne-text">修改数据库</span></h2><p id="96eab48725a6aa3892050109c090162a" class="ne-p"><br></p><pre><code>ALTER &#123;DATABASE|SCHEMA&#125; db_name [DEFAUTL] CHARCTER SET [=] charset_name;</code></pre><p id="b61a45a2644317b170c67858f82ad776" class="ne-p"><br></p><h3 id="93674c0f"><span class="ne-text">修改数据库编码格式</span></h3><p id="92e23fa621dabbfaaa0e74fd4b315be8" class="ne-p"><br></p><pre><code>SET NAMES GBK;</code></pre><p id="a7bb72209db368725722d07108577b6b" class="ne-p"><br></p><p id="e56dd3966c1a307e176315b7375d3f80" class="ne-p"><span class="ne-text">GBK也可以是其他编码格式。但这只是修改你客户端显示的编码格式。服务端并不变化。</span></p><p id="def5d5d77821b424a883406f3d68f639" class="ne-p"><strong><span class="ne-text">修改配置文件来改服务端编码</span></strong></p><p id="910253dcae1c4fa192a08bba2ed8c87f" class="ne-p"><span class="ne-text">打开/etc/my.cnf文件</span></p><p id="8d065465916e3444e3f8c941d4a999d5" class="ne-p"><span class="ne-text">在[mysqld]条目下：增加</span></p><p id="3b1df4b618d5636178d8864dee70ea2f" class="ne-p"><br></p><pre><code>character_set_server=utf8  init_connect='SET NAMES utf8'</code></pre><p id="64524bbe902c88ab127a47ba10fc1f33" class="ne-p"><br></p><p id="83df3ccfe22e4e52ddf08a404d944cda" class="ne-p"><span class="ne-text">有时在数据库创建完成后，编码格式是无法修改的。只能删掉重新建。</span></p><p id="30e932e656359eb38a88f84c8fe9c96a" class="ne-p"><br></p><h2 id="17d6bfc2"><span class="ne-text">删除数据库</span></h2><p id="79cfe8bc49838caf6911423d666b7f61" class="ne-p"><br></p><pre><code>    DROP &#123;DATABASE|SCHEMA&#125; [IF EXISTS] db_name;</code></pre></div>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
          <category> DataBase </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>SQL表基本操作</title>
      <link href="/blog/zqbaxc/"/>
      <url>/blog/zqbaxc/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h1 id="Bbv6P"><span class="ne-text">表基本操作</span></h1><h2 id="7tt1c"><span class="ne-text">创建表</span></h2><p id="u5096f51f" class="ne-p"><br></p><p id="2bfba170ff6dfe1afda6cbd45dbd9fa5" class="ne-p"><br></p><pre><code>Create table student(    Sno char(9),    Same char(20),    Ssex char(2),    Sage smallint,    Sdept char(20));Create table course(    Cno char(4),    Cname char(40),    Cpno char(4),    Ccredit smallint);Create table sc(    Sno char(9),    Cno char(4),    Grade smallint);Insert into student values('200215121','李勇','男',20,'cs');Insert into student values('200215122','刘晨','女',19,'cs');Insert into student values('200215123','王敏','女',18,'ma');Insert into student values('200515124','张立','男',19,'is');  Insert into course values ('1','数据库','5',4);Insert into course values ('2','数学',NULL,2);    Insert into course values('3','信息系统','1',4);Insert into course values('4','操作系统','6',3);Insert into course values('5','数据结构','7',4);Insert into course values('6','数据处理',NULL,2);Insert into course values('7','pascal语言','6',4);Insert into sc values('200215121','1',92);Insert into sc values('200215121','2',85);Insert into sc values('200215121','3',88);Insert into sc values('200215122','2',90);Insert into sc values('200215122','3',80);</code></pre><h2 id="e9efaab2"><span class="ne-text">查看表</span></h2><p id="0edce77211314d065bddec62dd0347d5" class="ne-p"><br></p><pre><code>    SHOW TABLES [FROM db_name] [LIKE 'pattern'|WHEAR expr];</code></pre><p id="41ad3e744952d676c9a5dca289d9a441" class="ne-p"><br></p><h2 id="b45b493d"><span class="ne-text">查看列（表的组织结构）</span></h2><p id="b16e3855ac87f9eb477a0f211d8c0895" class="ne-p"><br></p><pre><code>    SHOW COLUMNS FROM tb_name;    DESC tb_name;</code></pre><p id="faa907d5d5db8505e26cfad0ca2bcce0" class="ne-p"><br></p><p id="5f1c912fde623a742919df1c9c686675" class="ne-p"><span class="ne-text">以上两条语句都可以。</span></p><p id="ff0997c14d8b2a1380d104ef972f2782" class="ne-p"><br></p><h2 id="6763c1c5"><span class="ne-text">查看表的内容</span></h2><p id="b5886419b19bba8e41ecabb1ec26753f" class="ne-p"><br></p><pre><code>    SELECT * FROM tb_name;</code></pre><p id="95df1a3f8fda68fbb1c05ce27ea4b0f5" class="ne-p"><br></p><h2 id="131d2cc4"><span class="ne-text">插入数据</span></h2><p id="d32a19556322d8f39916008934fb680a" class="ne-p"><br></p><pre><code>    INSERT [INTO] tb_name [(col_name,...)] VALUES(val,...);</code></pre><p id="9f7f0fb435b53aae6be2684bfea14264" class="ne-p"><br></p><p id="e16272e4a571e75352cb2028fe0b10c2" class="ne-p"><span class="ne-text">如果不指明任何字段名，那么插入的数据必须要包含所有的字段。</span></p><p id="45a0f79544a7ac873df1a827a6aa3277" class="ne-p"><br></p><h1 id="ea44402b"><span class="ne-text">插入记录</span></h1><p id="7389be37da995f42513e3fafef16d052" class="ne-p"><br></p><p id="24abcc0e245a4ae60eaef254765aff6f" class="ne-p"><span class="ne-text">共有三种Insert语句。</span></p><p id="d27c8f99f568ada487c4d2b355d6920a" class="ne-p"><br></p><h2 id="INSERT"><span class="ne-text">INSERT</span></h2><p id="5c7dfc37519b140d6759ea36754d902e" class="ne-p"><br></p><pre><code>INSERT [INTO] tb_name [(col_name,.....)] &#123;VALUE|VALUES&#125; (&#123;expr|DEFAULT&#125;,...) (...),...</code></pre><p id="1942e4aa5170d0571b8d50cd71684256" class="ne-p"><br></p><ul class="ne-ul"><li id="82cb94f30dfc6b9dc8b0c7d88260d0ac"><span class="ne-text">values是标准SQL关键字，value是MySQL自己的。</span></li><li id="76d0494653a23978f69fb2568a3ff9d7"><span class="ne-text">插入语句可以一次性插入多条记录。</span></li><li id="a017c1470988e836f0a76b364fd0c5b3"><span class="ne-text">值可以是：</span></li></ul><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="44be2704375bdd8b1f6620db902ea5bf"><span class="ne-text">函数</span></li><li id="177f769ab45b709e11b693fcdf0df177"><span class="ne-text">数学表达式</span></li><li id="94bd5a9e8d954dbefa285fa9871cd06b"><span class="ne-text">等</span></li></ul></ul><p id="153c9daae3034bb40cd203e51c669552" class="ne-p"><br></p><p id="1d9b80c99da6f23b8561258974619c44" class="ne-p"><span class="ne-text">默认值</span></p><p id="84daaba7470f2501eba275792485a5a7" class="ne-p"><br></p><p id="6b3ac9de00450738fd42dcbd5f5283d6" class="ne-p"><span class="ne-text">在创建数据表的时候可以设置DEFAUTL。</span></p><p id="c9fb2a944d8c66a543010132cb5f7ff5" class="ne-p"><br></p><pre><code>CREATE TABLE users(    id SAMLLINT UNSIGNED PRIMARY KEY AUTO_INCREMENT,    username SAMLLINT VARCHAR(20) NOT NULL,    password SAMLLINT VARCHAR(20) NOT NULL,    age TINYINT UNSIGNED NOT NULL DEFAULT 10,    sex BOOLEAN);</code></pre><p id="caa286ba4fd9089469a97759946bca9d" class="ne-p"><br></p><p id="6b11b7f7a0db68ef51af0d30cb9190ca" class="ne-p"><span class="ne-text">INSERT的时候如果为自动编号的字段（比如上表中主键id）赋值的话，可写作NULL，或DEFAULT就会采用默认值。</span></p><p id="80554680c2af40dead6d5be4a754bf9b" class="ne-p"><span class="ne-text">如果字段设置了DEFAULT（比如上表中age），那么值直接写DEFAULT就行，注意此时，不能为NULL。例如：</span></p><p id="f41cdad2570f87b1cd685dbb0d5bdc2c" class="ne-p"><br></p><pre><code>INSERT users VALUES(NULL,'TOM','123',DEFAULT,1);</code></pre><p id="9b4bc12e4e227b8794902dc336ae135f" class="ne-p"><br></p><h2 id="INSERT...SET"><span class="ne-text">INSERT...SET</span></h2><p id="1d8001a043db59e55d810481558b5011" class="ne-p"><br></p><pre><code>INSERT [INTO] tb_name SET col_name=&#123;expr|DEFAULT&#125;,...</code></pre><p id="038c4e1dc09407157bc02ddb601847d4" class="ne-p"><br></p><p id="477deef1560839de76b8301242f5c974" class="ne-p"><span class="ne-text">采用了</span><a href="%E5%AD%90%E6%9F%A5%E8%AF%A2.md" data-href="%E5%AD%90%E6%9F%A5%E8%AF%A2.md" class="ne-link"><span class="ne-text">子查询</span></a><span class="ne-text">。例如，上表中插入：</span></p><p id="1a54292d5e5a3cdd55653b9405b0d110" class="ne-p"><br></p><pre><code>INSERT users SET username='Ben',password='456';</code></pre><p id="53f9113d4d59affb2620c5c49f2e8fd3" class="ne-p"><br></p><p id="01c50264da2b7856f84b0167d4104a4f" class="ne-p"><span class="ne-text">因为id，和age都有默认值，所以可以不写。而sex允许为空，也可以不写。</span></p><p id="478ebeb45586f737c27012ce7b4a0a41" class="ne-p"><br></p><h2 id="be74e164"><span class="ne-text">INSERT...SELECT*</span></h2><p id="41288b8eabab13960bd87ef8cc071e46" class="ne-p"><br></p><p id="a1a732cdfe886daeac4e355621ea8626" class="ne-p"><span class="ne-text">将查找的结果写入记录中。</span></p><p id="f456f0bc74f876f10b0f8abdcb52bf39" class="ne-p"><br></p><pre><code>INSERT test(username) SELECT username FROM users WHERE age &gt;=30;</code></pre><p id="505300ce9d84625ea16b930b6c02b4a9" class="ne-p"><br></p><h1 id="a790208c"><span class="ne-text">删除记录</span></h1><p id="190ee8fcb585a5332fe69a465286235b" class="ne-p"><br></p><p id="910a985e4203fc2e283c25e41421fc2e" class="ne-p"><span class="ne-text">同样分为：</span></p><p id="a80746ad0cc1e7cc085b423110edfbd5" class="ne-p"><br></p><ul class="ne-ul"><li id="89cb5133e329d3995ce15256645dc8f7"><span class="ne-text">单表删除</span></li><li id="40a1101204c05c6f22654902f851ddaf"><span class="ne-text">多表删除</span></li></ul><p id="3cb9d25d2006918b3b422370e1c2e84a" class="ne-p"><br></p><pre><code>DELETE FROM tb_name [WHERE where_condition];</code></pre><p id="2e16d5591146c043e21f1c74880bcbc4" class="ne-p"><br></p><p id="ddcfa7f97d9228e978918263c4a4db37" class="ne-p"><span class="ne-text">没有where部分则会删除全部记录。</span></p><h1 id="du2gc"><span class="ne-text">更新记录-单表更新</span></h1><p id="2b5cbd74033c2008113972aeaf0dfafa" class="ne-p"><span class="ne-text">更新记录分为：</span></p><p id="0587a973a4c487f563704ebe55825319" class="ne-p"><br></p><ul class="ne-ul"><li id="46cfc4f01e1813cccc2d6c3e118796e6"><span class="ne-text">单表更新</span></li><li id="28c79a7cc87c23cf4a63d4527b02d8f1"><span class="ne-text">多表更新（要涉及连接）</span></li></ul><p id="dbac7d7178b47f94fa92f7b85041d5cd" class="ne-p"><br></p><div class="ne-quote"><p id="c5c9596f764cd78f29e513bc32cbda05" class="ne-p"><span class="ne-text">单表更新</span></p></div><pre><code>UPDATE [LOW_PRIORITY] [IGNORE] tb_reference SET col_name1=&#123;expr|DEFAULT&#125; [,col_name2=&#123;expr|DEFAULT&#125;]...[WHERE where_condition]</code></pre><p id="258dfe20332c29036f5601d3cc5380b4" class="ne-p"><br></p><p id="39d7fa4ce6da08b2a3faa49275d236fb" class="ne-p"><span class="ne-text">不写where会更新全部的记录。</span></p><h1 id="8d1e69db"><span class="ne-text">更新记录-连接（多表更新）</span></h1><p id="e73faf597eeb5aed351f3a0359fb528c" class="ne-p"><br></p><h2 id="76ad9a84"><span class="ne-text">多表更新</span></h2><p id="064e4ff2fb927cfdfb6ae2dbddd06990" class="ne-p"><br></p><pre><code>UPDATE table_references SET col_name1=&#123;expr1|DEFAULT&#125;[,col_name2=&#123;expr2|DEFAULT&#125;]...[WHERE where_condition]</code></pre><p id="1ca581e114b5e27b895e3a9ab8e453d3" class="ne-p"><br></p><h2 id="CREATE...SELECT"><span class="ne-text">CREATE...SELECT</span></h2><p id="a43aaebc98533654cd53159c38cdf22d" class="ne-p"><br></p><p id="ffb68cda1eadb385887e7f09a68df31a" class="ne-p"><span class="ne-text">创建数据表同时将查询结果写入到数据表</span></p><p id="1d242b3741f788c505b4fb69ba438770" class="ne-p"><br></p><pre><code>CREATE TABLE [IF NOT EXISTS]tb_name[(create_definetion,...)]select_statement</code></pre><p id="caa5f844d00a61901bc903e63d8f4c02" class="ne-p"><br></p><p id="44dc4f9e4209290bb34c6ac08db7f56c" class="ne-p"><span class="ne-text">比如：</span></p><p id="c4637eefa014fa2da4f43c10b356d474" class="ne-p"><br></p><pre><code>CREATE TABLE tall (    tall_id SMALLINT UNSIGNED PRIMARY KEY AUTO_INCREMENT,    num INT) SELECT 身高 AS num FROM    avGROUP BY 身高;</code></pre><p id="2e3b2905182b181e9aae282980f598a8" class="ne-p"><br></p><p id="5ab71fe37034f48deccc06ebceca561b" class="ne-p"><span class="ne-text">创建新表tall，并从av表中选取身高字段插入到tall表的num字段。</span></p><p id="8dbced6607206b9b7bd2c2d03743ecdb" class="ne-p"><br></p><h2 id="30f7dd4e"><span class="ne-text">连接</span></h2><p id="c98e26095940275e5b2f82658e1a4052" class="ne-p"><br></p><h3 id="804ed42b"><span class="ne-text">语法结构</span></h3><p id="739cbd9012eebd5f881e222b748ffc66" class="ne-p"><br></p><pre><code>table_reference&#123;[INNER|CROSS] JOIN|&#123;LELT|RIGHT&#125;[OUTER] JOIN&#125;table_referenceON conditional_expr</code></pre><p id="c565c5e07af8373cabf58deac3c9ea50" class="ne-p"><br></p><p id="4cece135c2ab26473202cad6a010395f" class="ne-p"><span class="ne-text">ON为条件。</span></p><p id="c203d00128a2c817da55949c3b47c192" class="ne-p"><span class="ne-text">三种连接，即：</span></p><p id="d8742fa4efc4fbe15986b0cc82b6d50d" class="ne-p"><br></p><ul class="ne-ul"><li id="507027516ffd278f4809da376c9cf2eb"><span class="ne-text">内连接</span></li><li id="46eaf6f733c22e6088d2875039ca4dda"><span class="ne-text">左外连接</span></li><li id="ea335329116896fcd992d0ad4c78de83"><span class="ne-text">右外连接</span></li></ul><p id="5a99dfe8668812b08ea928076c30086c" class="ne-p"><br></p><h4 id="1da1d322"><span class="ne-text">内连接</span></h4><p id="ee8d444d6af5156cd3f5b24ed4a7a46b" class="ne-p"><br></p><p id="204f2c3eaf1c1cd2058e2c8acbe6a9b2" class="ne-p"><span class="ne-text">显示左表及右表符合连接条件的记录（交集）</span></p><p id="eacc4735d57a386b6c1ef29824957d94" class="ne-p"><br></p><h4 id="3cb26c64"><span class="ne-text">左外连接</span></h4><p id="df7d795b795708235b68a37451b994a7" class="ne-p"><br></p><p id="b36a298248b832cc026f740de3e024f3" class="ne-p"><span class="ne-text">显示左表的全部记录及右表符合连接条件的记录</span></p><p id="dd0052344cbdba362b0cd7fda2930cbe" class="ne-p"><br></p><h4 id="0abc0f82"><span class="ne-text">右外连接</span></h4><p id="5bd17482e7913e88520c9ffa74ebbc46" class="ne-p"><br></p><p id="a1ad1e85d651fa9ccb46a94e7a01dff5" class="ne-p"><span class="ne-text">类别左外连接</span></p><p id="6ded0059a59810d5309e171d99f270f6" class="ne-p"><br></p><h3 id="UPDATE..JOIN..SET"><span class="ne-text">UPDATE..JOIN..SET</span></h3><p id="50d6adad3e8e89c89d756cff49a8cb1f" class="ne-p"><br></p><p id="a8af1fbb7276aec34849146c19247c46" class="ne-p"><span class="ne-text">比如</span></p><p id="eef29f93edd5b6bff263f470a5533e39" class="ne-p"><br></p><pre><code>UPDATE actor AS a        INNER JOIN    tall AS b ON a.tall = b.num SET     a.tall = b.tall_id;</code></pre><p id="f96e30b14e15c7d4cb11743d21bc2b66" class="ne-p"><br></p><p id="5d876d73698232f110182d396d355364" class="ne-p"><span class="ne-text">依据实际情况，选择是否使用别名。（如果两个表中进行比较的字段名相同，则需要别名）</span></p><p id="6f8d5ca38b7a640e63288d0d6ef6a5b2" class="ne-p"><span class="ne-text">该语句完成了一个替换，将actor表中具体的身高数值，替换为tall表中身高的对应id。</span></p><p id="ce2677e2b72606ce433927b3dda675d6" class="ne-p"><br></p><p id="21a4cb36daa0fc03e25801dd3a9b72d6" class="ne-p"><br></p><h1 id="dc15d5f9"><span class="ne-text">修改数据表</span></h1><p id="ed1f8f7b8b6317e120717010ff3dd45f" class="ne-p"><br></p><p id="54b81631cb7cf81d72070b0ed9d8361b" class="ne-p"><span class="ne-text">所有的数据表的修改SQL语句的开头都是ALTER TABLE+表名称。</span></p><p id="93eec81050a9c842166a3841b179e8b7" class="ne-p"><br></p><h2 id="988f7bc5"><span class="ne-text">给表改名</span></h2><p id="9e354744cf5ead8b77c5131c50fd456c" class="ne-p"><br></p><pre><code>ALTER TABLE tb_name RENAME &#123;TO|AS&#125; tb_new_name;</code></pre><p id="13340f0101dfed8138f98ab685c5ec25" class="ne-p"><br></p><p id="c58656481f17f9097b09e7b765afeac9" class="ne-p"><span class="ne-text">另外有个写法是：</span></p><p id="ebb660649610a88661d258ee89491516" class="ne-p"><br></p><pre><code>RENAME TABLE tb_name TO tb_new_name;</code></pre><p id="d58f9f4ef307d673c8bdfe7ffdee50e7" class="ne-p"><br></p><p id="eed10987cda338eec19acf34adebd97f" class="ne-p"><span class="ne-text">这句可以批量修改多个表的名称。</span></p><p id="cc59cc5e57bdb554245e39a7eabe6e2a" class="ne-p"><br></p><div class="ne-quote"><p id="7bd88d4ced6e49d09225e548dd9d7402" class="ne-p"><span class="ne-text">尽量不要随意修改表的名称。对视图有影响。</span></p></div><p id="44eca86c0422544a4bce80075f5f4c4f" class="ne-p"><br></p><h2 id="74e1e78f"><span class="ne-text">添加/删除列</span></h2><p id="7edd44f8648e30e4cdab53aa35cd2199" class="ne-p"><br></p><h3 id="3d3d1ae0"><span class="ne-text">插入列</span></h3><p id="b9b0689567c79496c8191db333af79fc" class="ne-p"><br></p><pre><code>ALTER TABLE tb_name ADD [COLUMN] col_name column_definition [FIRST|AFTER col_name];</code></pre><p id="c1c2aa59e4aaf0b4c04fb8e2a2efd372" class="ne-p"><br></p><p id="4f719905204b24073549c5d42b94dc8e" class="ne-p"><span class="ne-text">默认会插入到表的最下面，指定FIRST，则置于最上面，或者用</span><code class="ne-code"><span class="ne-text">AFTER col_name</span></code><span class="ne-text"> 指定为</span><code class="ne-code"><span class="ne-text">col_name</span></code><span class="ne-text">的下面。</span></p><p id="4f5a3e57a668bd9ac5c0a21e793aba6f" class="ne-p"><br></p><h3 id="3aac0e33"><span class="ne-text">删除列</span></h3><p id="c89b92048bcc8c8780eb853a6ead82bf" class="ne-p"><br></p><pre><code>ALTER TABLE tb_name DROP col_name,DROP.....;</code></pre><p id="b09eb58c10c9d2c8ed7d056488ce19d9" class="ne-p"><br></p><p id="a91574fa695629fc1c492f7b6265b327" class="ne-p"><span class="ne-text">可以一次性删除多个列。</span></p><p id="682cf8e3f6882e0b487d68e82f46b991" class="ne-p"><br></p><h2 id="67998807"><span class="ne-text">修改列</span></h2><p id="79774b9538b04c5aaf479bf942a8e079" class="ne-p"><br></p><h3 id="42ddcc1d"><span class="ne-text">修改列定义</span></h3><p id="05352f44c4668f01f95b1d89cd14da9d" class="ne-p"><br></p><p id="61f982f71377ae323e9c20407cef0b8b" class="ne-p"><span class="ne-text">即修改列的属性。</span></p><p id="6451358430f6afbc36cef369f288ffe8" class="ne-p"><br></p><pre><code>ALTER TABLE tb_name MODIFY col_name column_definition [FIRST|AFTER col_name];</code></pre><p id="cba9bad81a8cb8fa4867b552bf5cee7c" class="ne-p"><br></p><p id="3d88c0e299daf7752afca030b1670500" class="ne-p"><span class="ne-text">比如：</span></p><p id="1c5b4bc3d818be498a01c270ae3dec6b" class="ne-p"><br></p><pre><code>ALTER TABLE test ADD id SMALLINT unsigned KEY auto_increment first;</code></pre><p id="99698519ebf3917d00123f9ceca093b7" class="ne-p"><br></p><p id="2e5b7ea82e65f98b2d5b5cbcdd2a3cb0" class="ne-p"><span class="ne-text">key可以表示主键，无需primary。fitrst表示插入的位置。</span></p><p id="df7ef49ea09a7a7f7e8a67f6ff3ef6df" class="ne-p"><br></p><div class="ne-quote"><p id="93d4ccf6931ab3b5c33c16faef6410ce" class="ne-p"><span class="ne-text">如果要修改的列已经是</span><code class="ne-code"><span class="ne-text">主键</span></code><span class="ne-text">了，则修改列定义的时候再加上</span><code class="ne-code"><span class="ne-text">主键</span></code><span class="ne-text">字段会报错。</span></p></div><p id="dfcf1d3b5a3ca0549a18d4975bd198a8" class="ne-p"><br></p><h3 id="620f3b9b"><span class="ne-text">修改列名</span></h3><p id="cc46a2a1da4b95b04030678ec3143d75" class="ne-p"><br></p><pre><code>ALTER TABLE tb_name CHANGE col_name col_new_name column_definition [FIRST|AFTER col_name];</code></pre><p id="122664258f6dd3f84df9e720801be136" class="ne-p"><br></p><p id="a6e05b4080e82a793dc30d4d3ac30fa5" class="ne-p"><span class="ne-text">修改列名时，新列名后面要指明数据类型。</span></p><p id="a459593041f2df10f8f77b7ed2cf46a1" class="ne-p"><br></p><h3 id="cdb14e66"><span class="ne-text">修改列顺序</span></h3><p id="9f39225dbff2385a00e3148f6eac4b4e" class="ne-p"><br></p><p id="9b19ba2669940fdb7f297ebc4c692c59" class="ne-p"><span class="ne-text">其实同上，具体比如：</span></p><p id="92a1fcfe609687cf10dda860089d217c" class="ne-p"><br></p><pre><code>ALTER TABLE `user` CHANGE `join_time` `join_time` DATE NULL DEFAULT NULL AFTER `role`;</code></pre><p id="f55da1127f8ae9e883e635c95b68d0a5" class="ne-p"><br></p><p id="e076461ae47cac79b8cbb555adb4dbea" class="ne-p"><span class="ne-text">把join_time列放到role列后面。</span></p><p id="f49dec30a6df7d97177d9e6ab071ce52" class="ne-p"><br></p><h2 id="ce722eca"><span class="ne-text">修改约束</span></h2><p id="d6ce3d585916862fc431e6be900eea43" class="ne-p"><br></p><h3 id="a6f1dc8f"><span class="ne-text">PRIMARY KEY</span></h3><p id="333db360852f4109e6ea8f12137a9029" class="ne-p"><br></p><p id="e3d9c1a0b539ecdc6f7ac7b64d3586bc" class="ne-p"><span class="ne-text">添加主键约束</span></p><p id="43b7644200197e6550813278394143df" class="ne-p"><br></p><pre><code>ALTER TABLE tb_name ADD [CONSTRAIN[symbol]] PRIMARY KEY [index.type] (index_col_name,.....);</code></pre><p id="d3180966f9bbd433b5eed03ea49e0242" class="ne-p"><br></p><p id="fc6fc3f4f39b9947ae6ec65bb1c432d2" class="ne-p"><span class="ne-text">删除主键约束</span></p><p id="f1d3686383649b63333a89f8de4f73f8" class="ne-p"><br></p><pre><code>ALTER TABLE tb_name DROP [index.type] PRIMARY KEY;</code></pre><p id="3b289fe1242c5f7a4339e3604f8bb7d3" class="ne-p"><br></p><p id="46316e12d47e3dcc42c157bf42d34163" class="ne-p"><span class="ne-text">不需要指定列名，因为每个表只有一个主键。</span></p><p id="5d5ff63fc1ee6fb8df03c4351e484755" class="ne-p"><span class="ne-text">注意！只有一个主键并不意味着主键只有一列。</span></p><p id="b5609fd47ba207413c298d6eecc78131" class="ne-p"><br></p><h3 id="UNIQUE"><span class="ne-text">UNIQUE</span></h3><p id="bb98eb97b1354a26645bd711c394508f" class="ne-p"><br></p><p id="ce9c7dc1c486cc9883bcce2ad88668b2" class="ne-p"><span class="ne-text">添加唯一约束</span></p><p id="02dcadac04080c909be6b9c644ebc13c" class="ne-p"><br></p><pre><code>ALTER TABLE tb_name ADD [index.type] unique(col_name);</code></pre><p id="9b7a80ceff5e2b850a9e50c90ee0d821" class="ne-p"><br></p><p id="4fa1ed6a9fa5cfd351166cbb12c66d0e" class="ne-p"><span class="ne-text">删除唯一约束</span></p><p id="8160458a658452491af0ea4052dc8fd0" class="ne-p"><br></p><pre><code>ALTER TABLE tb_name DROP [index.type] unique(col_name);</code></pre><p id="8569b42a9b6213edf029dfa8a284eeb2" class="ne-p"><br></p><h3 id="DEFAULT"><span class="ne-text">DEFAULT</span></h3><p id="d39269fa9d5d95931555d3b9d9fd28fe" class="ne-p"><br></p><pre><code>ALTER TABLE tb_name ALTER [COLUMN] col_name &#123;SET DEFAULT literal|DROP DEFAULT&#125;;for example:ALTER TABLE users ALTER age SET DEFAULT 20;</code></pre><p id="06fa49b8e68199e9af616b210d48a5e9" class="ne-p"><br></p><h3 id="7efc1efe"><span class="ne-text">FOREIGN KEY</span></h3><p id="3f63612be3a1e087a1f7c78bf767bd93" class="ne-p"><br></p><p id="a39da979180ccc98d49662cd0d757290" class="ne-p"><span class="ne-text">添加外键约束</span></p><p id="1b442bb84bbdde69658bcb768e2865f9" class="ne-p"><br></p><pre><code>ALTER TABLE tb_name ADD [CONSTRAIN[symbol]] FOREIGN KEY [index_name](index_col_name,...)reference_definition;for example:ALTER TABLE users add FOREIGN KEY (pid) REFERENCE provinces (id);</code></pre><p id="09cefe28114cd8420be412563c2c1214" class="ne-p"><br></p><p id="c813b9a99bacc7ca4f88c285fbce6476" class="ne-p"><span class="ne-text">删除外键约束</span></p><p id="6a8551b2fe8af6c693bd94914e079751" class="ne-p"><br></p><pre><code>ALTER TABLE tb_name DROP FOREIGN KEY fk_symbol;</code></pre></div>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
          <category> DataBase </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>0-1背包问题</title>
      <link href="/blog/kb5sse/"/>
      <url>/blog/kb5sse/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h2 id="lRlkk"><span class="ne-text">问题描述</span></h2><h3 id="7Fox1"><span class="ne-text">问题描述</span></h3><p id="a77700202349a06007d1c20950f36da7" class="ne-p"><span class="ne-text">给定一组已知重量和价值的物品和一个容量已知的背包，求解在不超过背包容量情况下，选用那些物品放入背包，使得所选用的所有物品价值最大化。</span></p><table id="Kxcnj" class="ne-table" style="width: 568px"><tbody><tr style="height: 33px"><td width="284"><p id="386a7bca1015834bb8197ed23406c2cd" class="ne-p"><span class="ne-text">物品总数N</span></p></td><td width="284"><p id="b7385dd6795340d6cd8537cb2272b4cd" class="ne-p"><span class="ne-text">4</span></p></td></tr><tr style="height: 33px"><td width="284"><p id="a20d224c568e48b9d67847a2c66a8c01_p_0" class="ne-p"><span class="ne-text">背包容量M</span></p></td><td width="284"><p id="ba275721c17bb484c2a65dfa4c4be9d4" class="ne-p"><span class="ne-text">8</span></p></td></tr><tr style="height: 33px"><td width="284"><p id="bbd8a608ef98cdcde660b7027123ae52" class="ne-p"><span class="ne-text">每个物品重量wi</span></p></td><td width="284"><p id="2aff6ad44c7ee56d73718d58fdf5d9cd" class="ne-p"><span class="ne-text">{5, 4, 3, 2}</span></p></td></tr><tr style="height: 33px"><td width="284"><p id="7c374bf7c0c403036462af9122de9eb7" class="ne-p"><span class="ne-text">每个物品价值vi</span></p></td><td width="284"><p id="8f8b3b671af4cf8c7022a234e79217e8" class="ne-p"><span class="ne-text">{15, 10, 6, 2}</span></p></td></tr></tbody></table><h3 id="kV86b" style="text-align: left"><span class="ne-text">问题的判定性说法</span></h3><h3 id="6UUMl" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1600597489691-e0d838af-003e-404e-8a40-5145d2fefbad.png" width="484.5" id="jAqDv" class="ne-image"></h3><h3 id="Wuaqr"><span class="ne-text">问题的形式化定义</span></h3><p id="ac18c94ee3a340915739dbc1f8bfed15" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1600597354257-45eba2b3-641c-433a-8732-9b6c11a16061.png" width="532.5" id="PlZXH" class="ne-image"></p><h2 id="vPxMl"><span class="ne-text">问题思路</span></h2><h3 id="8v4Q2"><span class="ne-text">动态规划思路</span></h3><p id="5b1dd1177277e0a2231abc79a2504715" class="ne-p"><strong><span class="ne-text">动态规划</span></strong><span class="ne-text">解决该问题，类似于</span><strong><span class="ne-text">莱文斯坦距离</span></strong><span class="ne-text">的解法类似。利用CAAIS数据来说明这个问题的解决思想。</span></p><p id="1f80558ddd90268ceaf49ec6143fa0b1" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1603943092299-49a0bc97-f2cf-4258-8dde-022b4aae06d1.png" width="421" id="bAWry" class="ne-image"></p><p id="dce4c11cc328491c5f934cdc0faf723e" class="ne-p" style="text-align: left"><strong><span class="ne-text">动态规划DP方程构造</span></strong></p><p id="a491a318199a14597b77b639908925f3" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1603943375703-889cea96-f3a0-41df-b806-386dca8bcc82.png" width="510" id="FlFHG" class="ne-image"></p><p id="819e04e2fb8c81394923d7b13367d2a9" class="ne-p" style="text-align: center"><strong><span class="ne-text">PS：V[i,j]表示在前i件物品中选择若干件放在承重为 j 的背包中，可以取得的最大价值</span></strong></p><p id="016745efdd21ed5b2551c84cdfe5b959" class="ne-p" style="text-align: left"><span class="ne-text"></span></p><p id="a8e4731a61f3becea162ae74ad1e0140" class="ne-p" style="text-align: left"><span class="ne-text">（整张表格是从上往下，从左往右地填）</span></p><p id="b0f70ea6d985134ca3546f3ee969eb47" class="ne-p" style="text-align: left"><span class="ne-text">举例说明表格中的数值填法，</span><strong><span class="ne-text">倒数第二行倒数第四列的16 4</span></strong><span class="ne-text">的填法：</span></p><ul class="ne-ul"><li id="fd0af2766eddd8d677c7fed7cc6508c5"><span class="ne-text">首先不满足DP方程的第一种和第二种情况</span></li><li id="1e0486298cdf7b14fdc49498e589ff51"><span class="ne-text">所以代入取最大值max函数</span></li></ul><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="122cc3f4fa9b3b221f5816dd01191edb"><span class="ne-text">V（i-1，j）：不选本物品（3，6），还是用之前的值，继承上面的第一个物品和第二个物品，DP值为15 U</span></li><li id="210f1f8f22481b0e5f36a6a10d6f26bf"><span class="ne-text">V（i-1，j）+vi：用该容量（7）-所选物品的重量为4，然后再查容量为4的时候DP值为10，然后求出该情况DP是，10加上该物品的价值，所以该情况下的DP值为16，右上标为4（CAAIS），值来源于前面容量为4的情况。</span></li></ul></ul><p id="4d7e42f132c33e5d1739b85934eab5fe" class="ne-p"><strong><span class="ne-text"> </span></strong></p><p id="2baa3e54a74f1948a2278ea4430ad71a" class="ne-p"><strong><span class="ne-text">格子如上方式填就好了！</span></strong></p><h3 id="iFSbE"><span class="ne-text">递归思路</span></h3><p id="bb4af9858c11fb268b7bba45a9477a7d" class="ne-p"><span class="ne-text">第二节课将递归的时候，也讲了这个问题的递归思路。不过复杂度记得是指数级的，暂时不写了~~</span></p><h2 id="Mh56N"><span class="ne-text">代码实现</span></h2><h3 id="i668W"><span class="ne-text">动态规划Code</span></h3><pre><code>#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;namespace NS_DP0_1Knapsack &#123;int DP0_1Knapsack(int n, int W, int *w, int *v);void Output(int n, int W, int *w, int *v, int OptV);static vector&lt;vector&lt;int&gt;&gt; V;static vector&lt;int&gt; x;void DP0_1KnapsackCaller(int n, int W, int *w, int *v)&#123;    V.clear();    V.resize(n + 1, vector&lt;int&gt;(W + 1, 0));    x.resize(n + 1);    int OptV = DP0_1Knapsack(n, W, w, v);    Output(n, W, w, v, OptV);&#125;int DP0_1Knapsack(int n, int W, int *w, int *v)&#123;    for (int i = 1; i &lt;= n; i++)        for (int j = 1; j &lt;= W; j++)            if (j &lt; w[i - 1])                V[i][j] = V[i - 1][j];            else if (V[i - 1][j] &gt;=                V[i - 1][j - w[i - 1]] + v[i - 1])                V[i][j] = V[i - 1][j];            else                V[i][j] = V[i - 1][j - w[i - 1]] + v[i - 1];    int j = W;    for (int i = n; i &gt; 0; i--)        if (V[i][j] == V[i - 1][j])            x[i] = 0;        else        &#123;   x[i] = 1; j -= w[i - 1];  &#125;    return V[n][W];&#125;void Output(int n, int W, int *w, int *v, int OptV)&#123;    //inputs    printf(&quot;DP to solve 0-1 knapsack:\n&quot;);    printf(&quot;%d items with knapsack capacity %d.\n&quot;, n , W);    printf(&quot;%-6s: &quot;, &quot;Weight&quot;);    for (int i = 0; i &lt; n; i++)        printf(&quot;%3d&quot;, w[i]);    printf(&quot;\n&quot;);    printf(&quot;%-6s: &quot;, &quot;Value&quot;);    for (int i = 0; i &lt; n; i++)        printf(&quot;%3d&quot;, v[i]);    printf(&quot;\n&quot;);    //the value matrix    printf(&quot;\nThe value matrix:\n&quot;);    printf(&quot;  &quot;);    for (int j = 0; j &lt;= W; j++)        printf(&quot;%3d&quot;, j);    printf(&quot;\n&quot;);    for (int i = 0; i &lt;= n; i++)    &#123;        printf(&quot;%2d&quot;, i);        for (int j = 0; j &lt;= W; j++)            printf(&quot;%3d&quot;, V[i][j]);        printf(&quot;\n&quot;);    &#125;    //solution    printf(&quot;\nThe optimal value: %d\n&quot;, OptV);    printf(&quot;The optimal solution:\n&quot;);    for (int i = 1; i &lt;= n; i++)        printf(&quot;%2d&quot;, x[i]);    printf(&quot;\n\n&quot;);&#125;&#125; //namespace NS_DP0_1Knapsackusing namespace NS_DP0_1Knapsack;int main()&#123;    // 物品个数    vector&lt;int&gt; N = &#123; 4,  10&#125;;    // 背包容量    vector&lt;int&gt; W = &#123; 8,  100&#125;;    // 各物品重量    vector&lt;vector&lt;int&gt;&gt; w = &#123;        &#123; 5, 4, 3, 2 &#125;,        &#123; 4, 3, 7, 2, 9, 3, 1, 7, 2, 5 &#125;    &#125;;    // 各物品价值    vector&lt;vector&lt;int&gt;&gt; v = &#123;        &#123; 15, 10, 6, 2 &#125;,        &#123; 15, 10, 6, 2, 23, 12, 33, 7, 22, 10 &#125;    &#125;;<pre><code>int m = N.size();for (int i = 0; i &amp;lt; m; i++)&#123;    DP0_1KnapsackCaller(N[i], W[i], &amp;amp;w[i][0], &amp;amp;v[i][0]);&#125;return 0;</code></pre><p>}<br></code></pre></p><h3 id="OJalB"><span class="ne-text">动态规划Result</span></h3><p id="00a1ce1dd408aefacd8ac2534241b04e" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1603943258085-fac4811f-87e7-4eef-8194-ee47d88063a6.png" width="960" id="zluPB" class="ne-image"></p><p id="09adf6c6abcf90133480f096836f6a43" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1603943276039-f6f74edf-4871-426d-8af8-e1a62edaf071.png" width="960" id="nfyc3" class="ne-image"></p><p id="cc8df1961f2421b4edd6b1e108e851ec" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1603943291836-84a15101-d6e7-4c9f-91b5-1122afd7ac5c.png" width="960" id="FpXM4" class="ne-image"></p></div>]]></content>
      
      
      <categories>
          
          <category> 计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 🔢动态规划算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>TSP问题</title>
      <link href="/blog/bkbll1/"/>
      <url>/blog/bkbll1/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h2 id="ZHb7n"><span class="ne-text">问题描述</span></h2><p id="17bc640017c4e7c4683b7e4a0374f4a4" class="ne-p"><span class="ne-text">假设有n个城市，各个城市与城市间的距离也已知，有一位旅行商需要途径所有的这n个城市，且每个城市只能且必须经过以此，求出一条路线，使得旅行商所走过的路程最短</span></p><h2 id="Q952s"><span class="ne-text">问题思路</span></h2><h2 id="LYpm0"><span class="ne-text">代码思路</span></h2><h2 id="C9pn9"><span class="ne-text">代码实现</span></h2><h2 id="itSa6"><span class="ne-text">参考资料</span></h2><ul class="ne-ul"><li id="01521159061afdf5727facd6f4cb2439"><a href="https://jerkwin.github.io/2016/03/17/%E6%97%85%E8%A1%8C%E6%8E%A8%E9%94%80%E5%95%86%E9%97%AE%E9%A2%98TSP%E7%9A%84%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E8%A7%A3%E6%B3%95/" data-href="https://jerkwin.github.io/2016/03/17/%E6%97%85%E8%A1%8C%E6%8E%A8%E9%94%80%E5%95%86%E9%97%AE%E9%A2%98TSP%E7%9A%84%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E8%A7%A3%E6%B3%95/" target="_blank" class="ne-link"><span class="ne-text">旅行推销商问题TSP的动态规划解法</span></a></li><li id="dbc24a26ebb401b61f70faaff2cda805"><a href="https://blog.csdn.net/joekwok/article/details/4749713" data-href="https://blog.csdn.net/joekwok/article/details/4749713" target="_blank" class="ne-link"><span class="ne-text">TSP(旅行者问题)——动态规划详解</span></a></li></ul></div>]]></content>
      
      
      <categories>
          
          <category> 计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 🔢动态规划算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>TODO: 46. 全排列🔖递归</title>
      <link href="/blog/kgaymi/"/>
      <url>/blog/kgaymi/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><ul class="ne-ul"><li id="uca5e700f"><a href="https://leetcode-cn.com/problems/permutations/" data-href="https://leetcode-cn.com/problems/permutations/" target="_blank" class="ne-link"><span class="ne-text">https://leetcode-cn.com/problems/permutations/</span></a></li><li id="uf2f2c88e"><a href="https://leetcode-cn.com/problems/permutations-ii/" data-href="https://leetcode-cn.com/problems/permutations-ii/" target="_blank" class="ne-link"><span class="ne-text">https://leetcode-cn.com/problems/permutations-ii/</span></a></li></ul><h2 id="uK3fK"><span class="ne-text">问题描述</span></h2><p id="0b066c7dcf442f3491a28066cab231ea" class="ne-p"><span class="ne-text">给定n个有序元素的集合，列出其可能出现的排列。</span></p><h2 id="sMXsU"><span class="ne-text">问题思路</span></h2><h2 id="NsHpX"><span class="ne-text">代码思路</span></h2><ul class="ne-ul"><li id="436e466cec138ae286ab1c3a4ee05202"><span class="ne-text">利用动态数组数据结构</span></li></ul><h2 id="YzpDm"><span class="ne-text">代码实现</span></h2><pre><code>package com.wztlink1013.al._递归法_;import java.util.ArrayList;<p>/**</p><ul><li>全排列问题</li><li>*/</li></ul><p>public class Permuting &#123;<br>    static ArrayList&lt;Integer&gt; x  = new ArrayList&lt;Integer&gt;();<br>    static int N;<br>    static int cnt = 0;<br>    static int t;</p><pre><code>public static void main(String args[]) &#123;    int n = 10;    Times.test(&amp;quot;当n = &amp;quot; + n + &amp;quot;时候的耗费时间&amp;quot;, new Times.Task() &#123;        public void execute() &#123;            PermutingCaller(n);        &#125;    &#125;);&#125;private static void PermutingCaller(int n) &#123;    N = n;    for (int i = 0; i &amp;lt; n; ++i)        x.add(i + 1);    Permuting(0);&#125;private static void Permuting(int i) &#123;    if (i &amp;lt; N - 1) &#123;        for (int j = i; j &amp;lt; N; j++) &#123;            t = x.get(i);            x.set(i, x.get(j));            x.set(j, t);            Permuting(i + 1);            t = x.get(i);            x.set(i, x.get(j));            x.set(j, t);        &#125;    &#125;    else        OutputOnePermutation();&#125;private static void OutputOnePermutation()&#123;    System.out.print(++cnt + &amp;quot; : &amp;quot;);    for (int x : x)        System.out.print(x + &amp;quot; &amp;quot;);    System.out.println();&#125;</code></pre><p>}<br></code></pre></p><div class="ne-quote"><p id="4da02f40c1cd063d40e69e44ad57d9db" class="ne-p"><span class="ne-text">n:10</span></p></div><p id="075b4e7747e1029e40faec7ceb139a49" class="ne-p"><br></p><div class="ne-quote"><p id="85f46c500eb90d2f54166377f17b7852" class="ne-p"><span class="ne-text">n</span></p></div></div>]]></content>
      
      
      <categories>
          
          <category> 计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 🌌递归算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>线性搜索</title>
      <link href="/blog/ete0k7/"/>
      <url>/blog/ete0k7/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content-editor-core lake-engine lake-typography-classic" data-lake-element="root" data-selection-undefined="%7B%22path%22%3A%5B%5B0%2C0%2C0%5D%2C%5B0%2C0%2C0%5D%5D%2C%22active%22%3Atrue%7D"><h2 data-lake-id="c1890278ba67c58bbae4eb1fb7169f2f" id="CRGUS" style="padding: 7px 0px; margin: 0px; font-weight: 700; font-size: 24px; line-height: 32px;">问题描述</h2><p data-lake-id="6aff1e7e83bb6c4ddb5ed7c3da579477" style="text-align: center; font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span data-card-type="inline" data-lake-card="image" class="lake-card-margin-top lake-card-margin-bottom"><img data-role="image" src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1599481660030-a834223b-30e4-4a9e-a290-243f028112f2.png" data-raw-src="" class="image lake-drag-image" alt="image.png" title="image.png" data-height="325px" style="visibility: visible; width: 520px;"></span></p><p data-lake-id="d5810dad979e39b899134401480aa668" style="text-align: left; font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><h2 data-lake-id="fa302002469ab36b98237d76f3288ea3" id="VnaIB" style="padding: 7px 0px; margin: 0px; font-weight: 700; font-size: 24px; line-height: 32px;">问题思路</h2><h2 data-lake-id="6de205eb8258f2cd589a20e7ffd32d8d" id="7iRKh" style="padding: 7px 0px; margin: 0px; font-weight: 700; font-size: 24px; line-height: 32px;">代码思路</h2><h2 data-lake-id="6eeba5194a0e08b66ee205464517a2fe" id="BXK7k" style="padding: 7px 0px; margin: 0px; font-weight: 700; font-size: 24px; line-height: 32px;">代码实现</h2></div>]]></content>
      
      
      <categories>
          
          <category> 计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 🔤穷举算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>穷举算法+百元买百兔、洗牌问题</title>
      <link href="/blog/czgm7d/"/>
      <url>/blog/czgm7d/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h2 id="9dZGL"><span class="ne-text">穷举思想</span></h2><p id="701034f23e618154434f87d75290519f" class="ne-p"><span class="ne-text">穷举法就是针对问题可能出现的结果，对其逐个进行测验并得出是否为符合要求的结果，穷举法也是许多高级算法中的某个部分。</span><strong><span class="ne-text">有点像高中数学里面的对问题进行分类讨论</span></strong><span class="ne-text">的过程中，寻找所有的情况的异曲同工之处。</span></p><h3 id="yuQ8P"><span class="ne-text">两部分组成</span></h3><ol class="ne-ol"><li id="d125884b53c39c6e816069df78dfd590" data-lake-index-type="0"><span class="ne-text">系统化地枚举问题各种可能的候选解</span></li><li id="5de4a93dacb15c70033bb6d45da6cd27" data-lake-index-type="0"><span class="ne-text">检查验证每一个候选解是否满足问题的求解要求</span></li></ol><h3 id="35c7035a"><span class="ne-text">穷举的抽象算法伪代码</span></h3><p id="0c6e4f6483dc4ac48c110f30517cae62" class="ne-p" style="text-align: left"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1599469820927-b990d8a2-9025-4f33-becb-46a03890bf07.png" width="548.5" id="J9C5J" class="ne-image"></p><h2 id="GppXW"><span class="ne-text">百元买百兔问题</span></h2><p id="89151cb71f121dc41c1bf5a031ad6c4e" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1621393290050-0aa37db7-c08b-407b-8088-c4ede29b80b5.png" width="559.5" id="Ys3JG" class="ne-image"></p><h2 id="zkq0Z"><span class="ne-text">洗牌问题</span></h2><p id="c5bfc9757b0ec7e046981409eee9a8e5" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1599475674143-ee86ef49-1b68-4940-baef-e556f225e43d.png" width="528" id="YAiZx" class="ne-image"></p><h3 id="Sy39a"><span class="ne-text">问题思路</span></h3><ul class="ne-ul"><li id="0eca9bf3dc25065b5ff97041e54925ff" data-lake-index-type="0"><span class="ne-text">在1~n-1当中随机选择一个数k1，将其与第n个数互换；</span></li><li id="64b861b55c3bebc88ae1996ff8260453" data-lake-index-type="0"><span class="ne-text">在1~n-2当中随机选择一个属k2，将其与第n-1个数互换；</span></li><li id="e228f261b87001e5189e2859a5f9a648" data-lake-index-type="0"><span class="ne-text">在第i轮之后，1~n-</span><strong><span class="ne-text">(i-1)</span></strong><span class="ne-text">当中选择一个数ki，将其与第n-</span><strong><span class="ne-text">(i-1)</span></strong><span class="ne-text">个数互换；</span></li></ul><h3 id="BMa7D"><span class="ne-text">代码思路</span></h3><ul class="ne-ul"><li id="7375bca2adbdc78011c5ef2a39453e87" data-lake-index-type="0"><span class="ne-text">在区间之间随机数的生成</span></li><li id="3c1788deb88593e1aa228354c26fe00b" data-lake-index-type="0"><span class="ne-text">交换函数</span></li><li id="6cb0b75ba8f7cd66516ca20b41cdae95" data-lake-index-type="0"><span class="ne-text">泛型：支持各种类型数据的“洗牌”</span></li></ul><p id="6bc76bbc1ebbeaa6465a1e70916c7927" class="ne-p"><br></p></div>]]></content>
      
      
      <categories>
          
          <category> 计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 🔤穷举算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>TODO: 78. 子集🔖递归</title>
      <link href="/blog/mz8hpp/"/>
      <url>/blog/mz8hpp/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><ul class="ne-ul"><li id="uc83ba6b1"><a href="https://leetcode-cn.com/problems/subsets/" data-href="https://leetcode-cn.com/problems/subsets/" target="_blank" class="ne-link"><span class="ne-text">https://leetcode-cn.com/problems/subsets/</span></a></li></ul><p id="u0d912814" class="ne-p"><span class="ne-text"></span></p><h2 id="oWCtR"><span class="ne-text">问题描述</span></h2><p id="u987a602d" class="ne-p"><span class="ne-text">给定一个正整数n，生成集合 {1,2,3,…n} 的所有子集</span></p><h2 id="TTeaW"><span class="ne-text">问题思路</span></h2><div class="ne-quote"><p id="u4d5d2633" class="ne-p"><span class="ne-text">思路一：二进制法</span></p></div><p id="u9cfecfd5" class="ne-p"><span class="ne-text">利用</span><strong><span class="ne-text">二进制</span></strong><span class="ne-text">“</span><strong><span class="ne-text">是否显现”</span></strong><span class="ne-text">的转换思路来解决这个问题，一个数字在子集当中就标记为1反之标记为0，就比如 </span><code class="ne-code"><span class="ne-text">n=3</span></code><span class="ne-text"> ，输出： </span><code class="ne-code"><span class="ne-text">&#123;&#125;&#123;1,0,0&#125;&#123;0,1,0&#125;&#123;0,0,1&#125;&#123;1,1,0&#125;&#123;1,0,1&#125;&#123;0,1,1&#125;&#123;1,1,1&#125;</span></code><span class="ne-text"> </span></p><h2 id="nasxE"><span class="ne-text">代码思路</span></h2><div class="ne-quote"><p id="u6c37ed60" class="ne-p"><span class="ne-text">思路一：利用动态数组数据结构</span></p></div><p id="u03f8fd6a" class="ne-p"><span class="ne-text">输入的n就是动态数组的初始大小</span></p><p id="u19e25500" class="ne-p"><span class="ne-text">然后依次利用“吞进来”和“吐出去”尾元素来实现</span></p><h2 id="sJsJW"><span class="ne-text">java代码实现</span></h2><pre><code>package com.wztlink1013.al._递归法_;/* * 作用：测量代码运行时间 */import java.text.SimpleDateFormat;import java.util.Date;<p>public class Times &#123;<br>    private static final SimpleDateFormat fmt = new SimpleDateFormat(&quot;HH:mm:ss.SSS&quot;);</p><pre><code>public interface Task &#123;    void execute();&#125;public static void test(String title, Task task) &#123;    if (task == null) return;    title = (title == null) ? &amp;quot;&amp;quot; : (&amp;quot;【&amp;quot; + title + &amp;quot;】&amp;quot;);    System.out.println(title);    System.out.println(&amp;quot;开始：&amp;quot; + fmt.format(new Date()));    long begin = System.currentTimeMillis();    task.execute();    long end = System.currentTimeMillis();    System.out.println(&amp;quot;结束：&amp;quot; + fmt.format(new Date()));    double delta = (end - begin) / 1000.0;    System.out.println(&amp;quot;耗时：&amp;quot; + delta + &amp;quot;秒&amp;quot;);    System.out.println(&amp;quot;-------------------------------------&amp;quot;);&#125;</code></pre><p>}<br></code></pre></p><pre><code>package com.wztlink1013.al._递归法_;import java.util.ArrayList;/** * 子集问题 */public class SubSetting &#123;    static ArrayList&lt;Integer&gt; x  = new ArrayList&lt;Integer&gt;();    static int cnt = 0;    public static void main(String args[]) &#123;        int n = 4;        Times.test(&quot;当n = &quot; + n + &quot;时候的耗费时间&quot;, new Times.Task() &#123;            public void execute() &#123;                Subsetting(n);            &#125;        &#125;);    &#125;    private static void Subsetting(int n) &#123;        if (n &gt; 0) &#123;            x.add(0);            Subsetting(n - 1);            x.remove(x.size() - 1);            x.add(1);            Subsetting(n - 1);            x.remove(x.size() - 1);        &#125;else &#123;            OutputOneSubsetBinary();            OutputOneSubset();            System.out.print(&quot;\n&quot;);        &#125;    &#125;    private static void OutputOneSubset() &#123;        System.out.printf(&quot;; &#123;&quot;);        int k = 0;        for (int i = x.size() - 1; i &gt;=0; i--) &#123;            if (x.get(i) == 1) &#123;                if (k &gt; 0)                    System.out.printf(&quot;,&quot;);                System.out.printf(&quot;%d&quot;, x.size() - i);                k++;            &#125;        &#125;        System.out.printf(&quot;&#125;&quot;);    &#125;    private static void OutputOneSubsetBinary() &#123;        System.out.printf(&quot;%010d: &quot;, ++cnt);        for (int i = x.size() - 1; i &gt;= 0; i--)            System.out.printf(&quot;%d&quot;, x.get(i));    &#125;&#125;</code></pre><p id="u846ac0c3" class="ne-p"><span class="ne-text">运行结果：</span></p><div class="ne-quote"><p id="u62b76a93" class="ne-p"><span class="ne-text">n：18（分钟）</span></p></div><p id="u65fd3b0a" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1600319992252-d49865a4-9a9d-4c65-88c8-ea72f140bf85.png" width="960" id="fUSjb" class="ne-image"></p><div class="ne-quote"><p id="u91007ebb" class="ne-p"><span class="ne-text">n：19（分钟）</span></p></div><p id="u7ed8826a" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1600320121635-ea76638e-a4c2-4686-a017-0d97088dc417.png" width="960" id="vPsbY" class="ne-image"></p><div class="ne-quote"><p id="u9ab386d4" class="ne-p"><span class="ne-text">n：20（分钟）</span></p></div><p id="uf3e3294b" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1600320284010-b885d1eb-01da-40d9-a098-f5d84744d847.png" width="960" id="ulpx3" class="ne-image"></p><div class="ne-quote"><p id="u9dd37efc" class="ne-p"><span class="ne-text">n：21（分钟）</span></p></div><p id="u20a0d9f9" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1600320620721-cf61057d-1eac-48d3-b724-36d0d21c4d1e.png" width="960" id="oFf1t" class="ne-image"></p><div class="ne-quote"><p id="u0fc251d1" class="ne-p"><span class="ne-text">n：22（分钟）</span></p></div><p id="u047f9967" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1600321218265-60888e51-2006-4dd7-bbe0-60b336895b8c.png" width="960" id="Gkj9x" class="ne-image"></p><div class="ne-quote"><p id="u4c599785" class="ne-p" style="text-align: left"><span class="ne-text">n：23（分钟）</span></p></div><p id="ub5346238" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1600329834700-9cb11fdc-fec8-463d-934a-b140b45cc0ae.png" width="960" id="FPV45" class="ne-image"></p><div class="ne-quote"><p id="u836b42f4" class="ne-p"><span class="ne-text" style="background-color: #FADB14">网上查的代码！</span></p></div><pre><code>class Main&#123;    static void printSubsets(String[] set)    &#123;        int n = set.length;        for (int i = 0; i &lt; (1&lt;&lt;n); i++)        &#123;            System.out.print(&quot;&#123; &quot;);            for (int j = 0; j &lt; n; j++)                if ((i &amp; (1 &lt;&lt; j)) &gt; 0)                    System.out.print(set[j] + &quot; &quot;);            System.out.println(&quot;&#125;&quot;);        &#125;    &#125;    public static void main(String[] args)    &#123;        String[] set = &#123;&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;,                        &quot;5&quot;, &quot;6&quot;, &quot;7&quot;, &quot;8&quot;&#125;;        printSubsets(set);    &#125;&#125;</code></pre><p id="ucfd2866f" class="ne-p"><br></p></div>]]></content>
      
      
      <categories>
          
          <category> 计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 🌌递归算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>常用类</title>
      <link href="/blog/rnsz9o/"/>
      <url>/blog/rnsz9o/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h2 id="hu2tb"><span class="ne-text">java.util.Date</span></h2><p id="u90320dc3" class="ne-p"><br></p><pre><code>java.util.Date date = new java.util.Date();System.out.println(date.toString());</code></pre><pre><code>Sun Mar 09 13:50:19 EST 2020</code></pre><h2 id="bGgjz"><span class="ne-text">java.util.Random</span></h2><div class="ne-quote"><p id="3ebc3aa752139df15b3b84eec82e1bfb" class="ne-p"><span class="ne-text">Math.Random()：Math类里面的随机数函数，范围是0.0到0.1</span></p></div><p id="a0966ea30f501dd358a4cbe5d0fd47dd" class="ne-p"><br></p><div class="ne-quote"><p id="b4f9e6ac9806372413c926ee61932a0d" class="ne-p"><span class="ne-text">java.util.Random </span></p></div><p id="d50507f457166c83a53d93400af6343f" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1600085762621-35c72adc-6c6e-4ab2-ac8b-d76d50e570e5.png" width="449.5" id="wOnz7" class="ne-image"></p><p id="2092969a19f287a6f7c288e43e280a0a" class="ne-p" style="text-align: center"><br></p><h2 id="8rhVQ"><span class="ne-text">javafx.geometry.Point2D</span></h2><p id="75b80ea1aee10da394909335a3c78b0f" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1600086091697-6fa8f4e4-137d-490a-8fe0-3546693a1f86.png" width="480" id="F3zQL" class="ne-image"></p><pre><code>import java.util.Scanner;import javafx.geometry.Point2D;public class TestPoint2D &#123;public static void main(String[] args)&#123;    <pre><code>Scanner input= new Scanner(System.in);System.out.println(&amp;quot;Enter point1&#39;s x-,y-coordinates:&amp;quot;);double x1=input.nextDouble();double y1=input.nextDouble();System.out.println(&amp;quot;Enter point2&#39;s x-,y-coordinates:&amp;quot;);double x2=input.nextDouble();double y2=input.nextDouble();Point2D p1 =new Point2D(x1,y1);Point2D p2 =new Point2D(x2,y2);System.out.println(&amp;quot;p1 is&amp;quot;+p1.toString());System.out.println(&amp;quot;p2 is&amp;quot;+p2.toString());System.out.println(&amp;quot;distance is&amp;quot;+p1.distance(p2));&#125; </code></pre><p>}<br></code></pre></p><pre><code>Enter point1's x-,y-coordinates:1 2Enter point2's x-,y-coordinates:3 4p1 isPoint2D [x = 1.0, y = 2.0]p2 isPoint2D [x = 3.0, y = 4.0]distance is2.8284271247461903</code></pre><h2 id="cfrIf"><span class="ne-text">String和StringBuilder和StringBuffer</span></h2><p id="c96272c27bf97d8a091e5fe92acb1db5" class="ne-p"><br></p><h2 id="KFk2b"><span class="ne-text">Object</span></h2><h3 id="9LDLB"><span class="ne-text">toString()方法</span></h3><h3 id="323B6"><span class="ne-text">equals()方法</span></h3><div class="ne-quote"><p id="f796af356e2eece6fe52e1fcdf774a2c" class="ne-p"><span class="ne-text">默认实现的方法</span></p></div><pre><code>public boolean equals(Object obj) &#123;    return (this == obj);&#125;</code></pre><div class="ne-quote"><p id="57042814c9899def2684ff3eba0159e7" class="ne-p"><span class="ne-text">重写例子</span></p></div><pre><code>public boolean equals(Object obj) &#123;    if (o instanceof Circe)        return radius == ((Circle)o).radius;    else        return this == o;&#125;</code></pre><p id="76768b7678f7b008f5ba9e7830055fdc" class="ne-p"><br></p><p id="de74c54ab0bf22d0c294e571b04c8a5b" class="ne-p"><br></p><p id="43ef6a2a08160c4a79107bb7fabf3eac" class="ne-p"><br></p><p id="24f6e318ea16b7922e289a49a36c90aa" class="ne-p"><br></p><p id="0dd07e2a49f0b4d23a27fa1084a9a439" class="ne-p"><br></p><p id="1c266256220313f5a316bd2cbb9afca9" class="ne-p"><br></p><p id="36fd9bb1cd8e04c7b37b5cb4195b5e40" class="ne-p"><br></p><p id="c51df20b12b79079022a36b0d3c405e4" class="ne-p"><br></p><p id="78c06392a68bc5cd11384cb8531e1b04" class="ne-p"><br></p><p id="b1c15509562284ea1c4df857d638c4c3" class="ne-p"><br></p><p id="a8a4609032789c13cd6f2dd0127cda0b" class="ne-p"><br></p><p id="240b47d1c095fbba948d18ebf5a74acf" class="ne-p"><br></p><p id="6e6b1644a3ad3ca45d4eae24030617a1" class="ne-p"><br></p><p id="c66e211ccbe193dfd5fca2521d4d60f1" class="ne-p"><br></p><p id="b157532cebe9521a769a255f17afe3cf" class="ne-p"><br></p><p id="e24566882138240a169e32389529dc4e" class="ne-p"><br></p><p id="a1bc8fa86745692fa2c9ea6e3a0ba861" class="ne-p"><br></p><p id="8b7b8e3f8fde4b245e0258e8a75c0947" class="ne-p"><br></p><p id="d3d2905383183702ebcfd8ad70896b5e" class="ne-p"><br></p><p id="71bcfe7d999828ca48d1a58416032acd" class="ne-p"><br></p><p id="62681aaf1c448c3cf45f6a36153a1c27" class="ne-p"><br></p><p id="d16baf99b221016c7803b7b0f1c2e0a5" class="ne-p"><br></p><p id="e03a961c1f666e936355abd15f1cf635" class="ne-p"><br></p><p id="25fcc9b9f62775b33a5a944b2e956af6" class="ne-p"><br></p><p id="b5ceff8c2a47105ee3244256cadf335a" class="ne-p"><br></p></div>]]></content>
      
      
      <categories>
          
          <category> 计算机素养 </category>
          
          <category> 后端编程语言 </category>
          
          <category> JAVA </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>206.反转链表🔖链表</title>
      <link href="/blog/ipiwza/"/>
      <url>/blog/ipiwza/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h2 id="MFdvm"><span class="ne-text">206. 反转链表</span></h2><ul class="ne-ul"><li id="ue0d90691"><a href="https://leetcode-cn.com/problems/reverse-linked-list/" data-href="https://leetcode-cn.com/problems/reverse-linked-list/" target="_blank" class="ne-link"><span class="ne-text">https://leetcode-cn.com/problems/reverse-linked-list/</span></a></li></ul><h3 id="onjU3"><span class="ne-text">问题描述</span></h3><p id="9017fce1dfd655319ba1ee74af5e5d77" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1603193588776-6539785f-f52d-494b-b7a1-2bc6cebf1e60.png" width="362.5" id="YFQAP" class="ne-image"></p><h3 id="3x1H8"><span class="ne-text">问题思路</span></h3><ol class="ne-ol"><li id="8e9865640e4179ed60cda8425dd1c7d5"><strong><span class="ne-text">利用外部空间：</span></strong><span class="ne-text">将所给链表存到ArryList里面或者是新的链表里面，然后再反转动态数组就可以了。</span></li><li id="243204d6df5dc3c4a2970de3d704c420"><strong><span class="ne-text">快慢指针</span></strong><span class="ne-text"></span></li><li id="33dc470dda2ef16930e214739c03046d"><strong><span class="ne-text">递归解法</span></strong><span class="ne-text"></span></li></ol><h3 id="VZKxU"><span class="ne-text">代码实现</span></h3><h4 id="rIxIY"><span class="ne-text">js</span></h4><pre><code>/** * Definition for singly-linked list. * function ListNode(val, next) &#123; *     this.val = (val===undefined ? 0 : val) *     this.next = (next===undefined ? null : next) * &#125; *//** * @param &#123;ListNode&#125; head * @return &#123;ListNode&#125; */var reverseList = function(head) &#123;    let prev = null;    let curr = head;    while (curr) &#123;        const next = curr.next;        curr.next = prev;        prev = curr;        curr = next;    &#125;    return prev;&#125;;</code></pre><h4 id="GjwCF"><span class="ne-text">递归实现</span></h4><pre><code>/** * public class ListNode &#123; *     int val; *     ListNode next; *     ListNode(int x) &#123; val = x; &#125; * &#125; */</code></pre><pre><code>// 避免陷入死循环if (head == null || head.next == null) return head;ListNode newHead = reverseList(head.next); //此处递归，找到最后一个节点了head.next.next = head; //重新指定节点指向（有两个next，注意少写）head.next = null; //将最初的节点指向空return newHead; //返回新的“倒置”头节点</code></pre><h4 id="C3tj2"><span class="ne-text" style="color: #000000; background-color: #FADB14">快慢指针</span></h4><pre><code>class Solution &#123;    public ListNode reverseList(ListNode head) &#123;        // 避免陷入死循环        if (head == null || head.next == null) return head;<pre><code>    ListNode newHead = null;    while (head != null)&#123;        ListNode tmp = head.next;        head.next = newHead;        newHead = head;        head = tmp;    &#125;    return newHead;&#125;</code></pre><p>}<br></code></pre></p><h2 id="FAX8v"></h2></div>]]></content>
      
      
      <categories>
          
          <category> 计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 🔗线结构：链表 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>算法复杂度</title>
      <link href="/blog/veggl2/"/>
      <url>/blog/veggl2/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h2 id="ir0Jb"><span class="ne-text">一、算法优化方向</span></h2><ol class="ne-ol"><li id="1cbd7ed09928d427d71a19829e597667" data-lake-index-type="0"><span class="ne-text">用尽量少的存储空间</span></li><li id="0aaa3b840975842d1ecd9ed3f2159cf5" data-lake-index-type="0"><span class="ne-text">用尽量少的执行步骤（执行时间）</span></li><li id="1f1bd0762a34e315aa0b7f1be06266ba" data-lake-index-type="0"><span class="ne-text">具体情况，具体分析（空间换时间，时间换空间）</span></li></ol><h2 id="mKd8o"><span class="ne-text">二、时间复杂度</span></h2><div class="ne-quote"><p id="52b1e28cf7d109874c39e42819bc533f" class="ne-p"><span class="ne-text">估算程序指令的执行次数（执行时间）</span></p></div><h3 id="SCfqv"><span class="ne-text">大O估算法</span></h3><div class="ne-quote"><p id="7e3600a6c86b5afa7d7247752c7ad8b0" class="ne-p"><span class="ne-text">忽略常数、系数、低阶（对数利用换底公式，相当于加了一个常数系数，所以为log(n)）</span></p><p id="d838e983c1c657d736e0152ea8118c72" class="ne-p"><span class="ne-text">常见的复杂度</span></p></div><p id="6ff01b32d2f7d75367782cdff3ebb1c0" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1599393633525-ae152fa4-ab52-4436-a91a-4237888491db.png" width="457.5" id="vulFS" class="ne-image"></p><p id="39a04f92b8a5a52722aa9a84d985c0ff" class="ne-p" style="text-align: center"><code class="ne-code"><span class="ne-text">Ο(1)＜Ο(logn)＜Ο(n)＜Ο(nlogn)＜Ο(n^2)＜Ο(n^3)＜…＜Ο(2^n)＜Ο(n!)&lt;O(n^n)</span></code></p><div class="ne-quote"><p id="6a642459ea77430d519e3c5e38774685" class="ne-p"><span class="ne-text">当数据规模较小的时候</span></p></div><p id="7cf5e1cbbc20f57e3d947b5da2d2f5ef" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1599393701320-c1869593-be0a-4552-9b1c-8a6fb00d300c.png" width="406.5" id="rOaJk" class="ne-image"></p><div class="ne-quote"><p id="9f9e69cbe0e8d0d5dee0d212a05c7615" class="ne-p" style="text-align: left"><span class="ne-text">当数据规模较大的时候</span></p></div><p id="f6b2a7aad9c3467d4c91911780ce932b" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1599395912246-1e996955-9150-4af1-b6d9-f7d15ce7d594.png" width="426" id="Ft8by" class="ne-image"></p><p id="f50072ae3851787586a7ce67ed734f6f" class="ne-p" style="text-align: center"><a href="https://zh.numberempire.com/graphingcalculator.php" data-href="https://zh.numberempire.com/graphingcalculator.php" target="_blank" class="ne-link"><span class="ne-text">函数图像绘制工具</span></a></p><p id="f037fec737394f27740fe1bd97db5c3f" class="ne-p" style="text-align: center"><br></p><h2 id="xc22M"><span class="ne-text">三、空间复杂度</span></h2><div class="ne-quote"><p id="0862a6b067e83c1dec2b91f2266deb19" class="ne-p"><span class="ne-text">估算所需占用的存储空间</span></p></div><p id="51a48263c99f147b4924aa1a161090ec" class="ne-p"><span class="ne-text">空间复杂度是算法运行过程中所需存储空间的量度。它表示算法解决问题所需的内存空间与问题规模之间的关系。通常用大O符号表示。</span></p><p id="uf1c07865" class="ne-p"><span class="ne-text">在分析空间复杂度时，我们考虑算法在运行过程中使用的额外空间，不包括输入数据占用的空间。以下是一些常见的空间复杂度情况：</span></p><ul class="ne-ul"><li id="ued4035e5" data-lake-index-type="0"><span class="ne-text">O(1) - 常数空间复杂度： 算法的额外空间需求是固定的，与输入规模无关。例如，一个固定大小的变量或常数大小的数组。</span></li><li id="u4162b5f3" data-lake-index-type="0"><span class="ne-text">O(n) - 线性空间复杂度： 算法的额外空间需求与输入规模成正比。例如，一个数组，其大小与输入数据的规模相同。</span></li><li id="u497819b6" data-lake-index-type="0"><span class="ne-text">O(log n) - 对数空间复杂度： 算法的空间需求与输入规模的对数成正比。这通常出现在使用递归分治策略的算法中。</span></li><li id="u1e7e80cb" data-lake-index-type="0"><span class="ne-text">O(n^2)、O(n^3) 等 - 多项式空间复杂度： 算法的额外空间需求与输入规模的某个幂次关系成正比。例如，嵌套循环的算法可能具有二次或三次空间复杂度。</span></li><li id="u7d6eb9b2" data-lake-index-type="0"><span class="ne-text">O(2^n)、O(n!) 等 - 指数空间复杂度： 算法的额外空间需求随着输入规模的指数增长。这样的算法通常效率较低，应该尽量避免使用。</span></li></ul></div>]]></content>
      
      
      <categories>
          
          <category> 计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 📌数据结构和算法综述 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>算法分析与设计课程综述</title>
      <link href="/blog/eq2l1v/"/>
      <url>/blog/eq2l1v/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="uc2c6e46a" class="ne-p"><span class="ne-text">前言：大三算法分析与设计课程的学习笔记。</span></p><h2 id="rU8fV"><span class="ne-text">形式化定义</span></h2><p id="c3a072660e4f55234ffea419e05f1207" class="ne-p"><span class="ne-text">对于一个问题，将其进行科学的分析研究，就需要对其进行更加严谨的形式化定义，其形式就类似于数学建模过程中的构建出</span><strong><span class="ne-text">数学模型</span></strong><span class="ne-text">一样，对其进行问题的抽象化提取，以及合理的公式化，就比如“0-1背包”问题中：</span></p><p id="f63087dccbff79d0c562199ad315640f" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1600597354257-45eba2b3-641c-433a-8732-9b6c11a16061.png" width="532.5" id="FfSoK" class="ne-image"></p><h2 id="AHjIH"><span class="ne-text">判定性问题</span></h2><p id="8da3e850ab67d48d57ee4a44b5fcf917" class="ne-p"><span class="ne-text">类似于数学建模当中</span><strong><span class="ne-text">模型的求解</span></strong><span class="ne-text">，在给定模型以及约束条件的情况下求出符合该约束条件下的模型解：</span></p><p id="bfe8e49a8319845c5b0dec84d0805be0" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1600597489691-e0d838af-003e-404e-8a40-5145d2fefbad.png" width="484.5" id="ZMrl3" class="ne-image"></p><h2 id="6Bf6i"><span class="ne-text">例子：Euclid-GCD问题</span></h2><p id="ufaffbb0b" class="ne-p"><span class="ne-text">问题描述</span></p><p id="2b0bd3adab947ea6df5e9b9054faffc6" class="ne-p"><span class="ne-text">将每个整数分解为素因子的积，找出公共的素因子，它们的积即是GCD</span></p><p id="u3610fd1a" class="ne-p"><span class="ne-text">问题思路</span></p><p id="2aa5e9833be129f16b160223aa008628" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1599360897754-ab7b7684-5565-471b-aece-1725b39196bb.png" width="395" id="zBWoT" class="ne-image"></p><p id="u6243f6f6" class="ne-p"><span class="ne-text">代码实现</span></p><pre><code><code>package com.wztlink1013.al.EuclidGCD;import java.util.Scanner;<p>public class Main &#123;<br>    public static void main(String args[])&#123;<br>        Scanner input = new Scanner(System.in);</p><pre><code>    System.out.println(&amp;quot;请输入两个大于零的自然数：&amp;quot;);    int a = input.nextInt();    int b = input.nextInt();    GCD(a,b);    System.out.println(a + &amp;quot;和&amp;quot; + b + &amp;quot;两个数的GCD值为：&amp;quot; + GCD(a,b));&#125;public static int GCD(int i, int j)&#123;    int r;    while (j != 0)&#123;        r = i%j;        i = j;        j = r;        System.out.println(&amp;quot;a=&amp;quot;+i+&amp;quot;；b=&amp;quot;+j+&amp;quot;；r=&amp;quot;+r);    &#125;    return i;&#125;</code></pre><p>}</code><br></code></pre></p><p id="bf411c85a6f59a31f84ebbd861e193de" class="ne-p"><br></p><p id="0ed8cce25eb9272b76b389ae29130c72" class="ne-p"><br></p><p id="c25c5404378b4c9b4ba086a3fdc9201f" class="ne-p"><br></p></div>]]></content>
      
      
      <categories>
          
          <category> 计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 📌数据结构和算法综述 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>1/15/18. 两/三/四数之和🔖数组🔖多指针🔖暴力</title>
      <link href="/blog/dq9vp6/"/>
      <url>/blog/dq9vp6/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h3 id="VS1b5"><span class="ne-text">1. 两数之和</span></h3><p id="u8b3df82f" class="ne-p"><a href="https://leetcode.cn/problems/two-sum/" data-href="https://leetcode.cn/problems/two-sum/" target="_blank" class="ne-link"><span class="ne-text">https://leetcode.cn/problems/two-sum/</span></a></p><pre><code>/** * @param &#123;number[]&#125; nums * @param &#123;number&#125; target * @return &#123;number[]&#125; */var twoSum = function(nums, target) &#123;    let result = []    for (let i = 0; i&lt;nums.length; i++) &#123;        for (let j = i+1; j&lt;nums.length; j++) &#123;            if (nums[i]+nums[j]===target) &#123;                result = [i,j]                break            &#125;        &#125;    &#125;    return result&#125;;</code></pre><p id="u4f1299f7" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1652967530657-b60f0c75-a67f-4415-85e9-36c3f6ea89d0.png" width="685.8333060807663" id="u3349df16" class="ne-image"></p><h3 id="TwjW2"><span class="ne-text">15. 三数之和</span></h3><ul class="ne-ul"><li id="uc8771cb6"><a href="https://leetcode-cn.com/problems/3sum/" data-href="https://leetcode-cn.com/problems/3sum/" target="_blank" class="ne-link"><span class="ne-text">https://leetcode-cn.com/problems/3sum/</span></a></li></ul><pre><code>/** * @param &#123;number[]&#125; nums * @return &#123;number[][]&#125; */var threeSum = function(nums) &#123;    let result = []    let arr = nums.sort((a, b) =&gt; &#123;return a - b&#125;)    for (let i = 0; i&lt;arr.length; i++) &#123;        if (i&gt;0 &amp;&amp; arr[i] === arr[i-1]) continue        for (let j = i+1; j&lt;arr.length; j++) &#123;            if (j&gt;i+1 &amp;&amp; arr[j] === arr[j-1]) continue            for (let k = j+1; k&lt;arr.length; k++) &#123;                if (arr[i]+arr[j]+arr[k] === 0) &#123;                    if (k&gt;j+1 &amp;&amp; arr[k] === arr[k-1]) &#123;                        k++                        continue                    &#125;                    result.push([arr[i], arr[j], arr[k]])                &#125;            &#125;        &#125;    &#125;    return result&#125;;</code></pre><p id="u90c86df0" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1652966701635-7130309a-dd69-4cb7-93fc-3a2f0ddffa65.png" width="735.8333040939449" id="ub4f4d5d1" class="ne-image"></p><p id="u0f508055" class="ne-p"><span class="ne-text">5%……我裂开……思路还是for暴力循环，但是和上面的耗时过长做了一个先把数组排序的操作。</span></p><p id="uef360e05" class="ne-p"><span class="ne-text"></span></p><p id="ua3a58832" class="ne-p"><span class="ne-text">感觉肯定是有简单的方法的…</span></p><p id="uaf28f9ae" class="ne-p"><span class="ne-text">但肯定都是定一移二的操作</span></p><p id="ude1a341b" class="ne-p"><br></p><h3 id="lw8nH"><span class="ne-text">18. 四数之和</span></h3><ul class="ne-ul"><li id="u5db38256"><span class="ne-text"></span><a href="https://leetcode.cn/problems/4sum/" data-href="https://leetcode.cn/problems/4sum/" target="_blank" class="ne-link"><span class="ne-text">https://leetcode.cn/problems/4sum/</span></a></li></ul><pre><code>/** * @param &#123;number[]&#125; nums * @param &#123;number&#125; target * @return &#123;number[][]&#125; */var fourSum = function(nums, target) &#123;    let result = []    let arr = nums.sort((a, b) =&gt; &#123;return a - b&#125;)    for (let i = 0; i&lt;arr.length; i++) &#123;        if (i&gt;0 &amp;&amp; arr[i] == arr[i-1]) continue        for (let j = i+1; j&lt;arr.length; j++) &#123;            if (j&gt;i+1 &amp;&amp; arr[j] == arr[j-1]) continue            for (let k = j+1; k&lt;arr.length; k++) &#123;                if (k&gt;j+1 &amp;&amp; arr[k] == arr[k-1]) continue                for (let l = k+1; l&lt;arr.length; l++) &#123;                    if (arr[i]+arr[j]+arr[k]+arr[l]===target) &#123;                        if (l&gt;k+1 &amp;&amp; arr[l] === arr[l-1]) &#123;                            l++                            continue                        &#125;                        result.push([arr[i],arr[j],arr[k],arr[l]])                    &#125;                &#125;            &#125;        &#125;    &#125;    return result&#125;;</code></pre><p id="u9f98182c" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1653017507005-019cf789-c92c-4510-a8fa-a7ccbd00fc1c.png" width="647.4999742706627" id="u56d5290b" class="ne-image"></p></div>]]></content>
      
      
      <categories>
          
          <category> 计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 📶线结构：字符串-数组-栈-队列 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>泛型</title>
      <link href="/blog/ef1q5c/"/>
      <url>/blog/ef1q5c/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="22eb6e7402146143bb2eec8c91969cee" class="ne-p"><span class="ne-text">类似C++里面的模板</span></p><ul style="margin: 0; padding-left: 23px"><li id="ee4362dddf1a7a080c9d882c8ade010c"><span class="ne-text">定义的时候就是直接在后面加上&lt;E&gt;，比如： </span><code class="ne-code"><span class="ne-text">public class ArrayList&lt;E&gt;</span></code><span class="ne-text"> </span></li><li id="e19fe7f167fcc159934b8e0e6bbe54fc"><span class="ne-text">使用就是 </span><code class="ne-code"><span class="ne-text">private E[] array</span></code><span class="ne-text"> ;</span></li></ul><h2 id="tQE4C"></h2><h2 id="7MhZG"></h2><p id="05efe278d6899c3db53044e2effc732d" class="ne-p"><br></p></div>]]></content>
      
      
      <categories>
          
          <category> 计算机素养 </category>
          
          <category> 后端编程语言 </category>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> todo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA动态数组设计</title>
      <link href="/blog/bx5ouf/"/>
      <url>/blog/bx5ouf/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h3 id="IHGHb"><span class="ne-text">接口设计</span></h3><pre><code>public int size(); // 返回动态数组元素个数public boolean isEmpty(); // 是否为空public boolean contains(E element); // 是否包含某个元素public void add(E element); // 在数组尾部添加元素public E get(int index); // 返回index位置对应的元素public E set(int index, E element); // 设置/更换index位置上的值public void add (int index, E element); // 在index位置上添加元素public E remove(int index); // 移除index位置上的值public int indexOf(E element); // 查看元素的位置public void clear(); // 清空动态数组所有元素</code></pre><h3 id="yhped"><span class="ne-text">private设计</span></h3><pre><code>// 元素的数量private int size;// 所有的元素private E[] elements;<p>private static final int DEFAULT_CAPACITY = 10;<br>private static final int ELEMENT_NOT_FOUND = -1;</p><p>/**<br>     * 保证要有capacity的容量<br>     * @param capacity<br>     */<br>private void ensureCapacity(int capacity) &#123;<br>    int oldCapacity = elements.length;<br>    if (oldCapacity &gt;= capacity) return;</p><pre><code>// 新容量为旧容量的1.5倍int newCapacity = oldCapacity + (oldCapacity &amp;gt;&amp;gt; 1);E[] newElements = (E[]) new Object[newCapacity];for (int i = 0; i &amp;lt; size; i++) &#123;    newElements[i] = elements[i];&#125;elements = newElements;System.out.println(oldCapacity + &amp;quot;扩容为&amp;quot; + newCapacity);</code></pre><p>}</p><p>private void outOfBounds(int index) {<br>    throw new IndexOutOfBoundsException(&quot;Index:&quot; + index + &quot;, Size:&quot; + size);<br>}</p><p>private void rangeCheck(int index) {<br>    if (index &lt; 0 || index &gt;= size) {<br>        outOfBounds(index);<br>    }<br>}</p><p>private void rangeCheckForAdd(int index) {<br>    if (index &lt; 0 || index &gt; size) {<br>        outOfBounds(index);<br>    }<br>}<br></code></pre></p><h3 id="UCaGc"><span class="ne-text">构造函数设计</span></h3><pre><code>public ArrayList(int capaticy) &#123;    capaticy = (capaticy &lt; DEFAULT_CAPACITY) ? DEFAULT_CAPACITY : capaticy;    elements = (E[]) new Object[capaticy];&#125;<p>public ArrayList() &#123;<br>    this(DEFAULT_CAPACITY);<br>&#125;<br></code></pre></p><h3 id="BtPzG"><span class="ne-text">重写输出</span></h3><pre><code>@Overridepublic String toString() &#123;    // size=3, [99, 88, 77]    StringBuilder string = new StringBuilder();    string.append(&quot;size=&quot;).append(size).append(&quot;, [&quot;);    for (int i = 0; i &lt; size; i++) &#123;        if (i != 0) &#123;            string.append(&quot;, &quot;);        &#125;<pre><code>    string.append(elements[i]);    //            if (i != size - 1) &#123;    //                string.append(&amp;quot;, &amp;quot;);    //            &#125;&#125;string.append(&amp;quot;]&amp;quot;);return string.toString();</code></pre><p>}<br></code></pre></p><p id="uf7239e17" class="ne-p"><span class="ne-text">22</span></p></div>]]></content>
      
      
      <categories>
          
          <category> 计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 📶线结构：字符串-数组-栈-队列 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JAVA链表设计</title>
      <link href="/blog/nkn2os/"/>
      <url>/blog/nkn2os/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h2 id="87ed5342"><span class="ne-text">LinkedList和ArrayList的设计</span></h2><p id="u138158d0" class="ne-p"><br></p><p id="uec8e29a0" class="ne-p"><br></p><div class="ne-quote"><p id="06b3dd2f95b4188a76d895dc7d174e4f" class="ne-p"><span class="ne-text" style="color: #F5222D">同时设计LinkedList和ArrayList</span></p></div><ul class="ne-ul"><li id="57803a540903fc07605b8f82b8c92064"><strong><span class="ne-text">LinkedList</span></strong><span class="ne-text">不需要构造函数</span></li><li id="bc16b24596092dadd91267c5f6b7b794"><strong><span class="ne-text">ArrayList</span></strong><span class="ne-text">需要，后者需要一个容量的初始化。</span></li></ul><p id="094c1b843afa0d090e6c14fb0948ce50" class="ne-p"><br></p><p id="ff0c850e3ddf6f7d3e965268398eb025" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1603191040309-0ed4b536-89c0-449d-85cc-e763afcb73ea.png" width="278.5" id="NZYUa" class="ne-image"></p><h3 id="9cXZd"><span class="ne-text">接口List设计</span></h3><div class="ne-quote"><p id="19863c3bb1cb0b3ed277ef3db37ea991" class="ne-p"><span class="ne-text">只用来</span><strong><span class="ne-text">声明对外接口</span></strong><span class="ne-text">，不能声明</span></p></div><pre><code>package com.wztlink1013.ds.linkedlist;<p>/**</p><ul><li>fun：实现ArrayList和LinkedList的接口</li><li></li><li>/</li></ul><p>public interface List&lt;E&gt; &#123;<br>    static final int ELEMENT_NOT_FOUND = -1;</p><pre><code>/** * 元素的数量[抽象类中实现] * @return */int size();/** * 是否为空[抽象类中实现] * @return */boolean isEmpty();/** * 是否包含某个元素[抽象类中实现] * @param element * @return */boolean contains(E element);/** * 添加元素到尾部[抽象类中实现] * @param element */void add(E element);/** * 清除所有元素[实现类中实现] */void clear();/** * 获取index位置的元素[实现类中实现] * @param index * @return */E get(int index);/** * 设置index位置的元素[实现类中实现] * @param index * @param element * @return 原来的元素ֵ */E set(int index, E element);/** * 在index位置插入一个元素[实现类中实现] * @param index * @param element */void add(int index, E element);/** * 删除index位置的元素[实现类中实现] * @param index * @return */E remove(int index);/** * 查看元素的索引[实现类中实现] * @param element * @return */int indexOf(E element);</code></pre><p>}</p><p></code></pre></p><h3 id="SyVsT"><span class="ne-text">抽象类AbstractList设计</span></h3><div class="ne-quote"><p id="074137348dfb83ac851f92e3410c4d2b" class="ne-p"><span class="ne-text">放ArrayList和LinkedList的公共代码</span></p><ul class="ne-ul"><li id="bdc02f7dd192704b4f61a9702ec8910e"><strong><span class="ne-text">实现List接口类</span></strong><span class="ne-text">的共同代码</span></li><li id="c6aa6536ec4a4d325c86ece9d1eb3efa"><span class="ne-text">ArrayList和LinkedList都用得到但是不对外公开的代码</span></li></ul><p id="f18b25c51383375495aa35bafcf41c32" class="ne-p"><span class="ne-text">声明抽象类abstract，就意味着可以不用全部实现接口List里面的所有方法</span></p></div><pre><code>package com.wztlink1013.ds.linkedlist;<p>/**</p><ul><li>fun：放ArrayList和LinkedList公共代码的抽象类（父类）</li><li></li><li>/</li></ul><p>public abstract class AbstractList&lt;E&gt; implements List&lt;E&gt; &#123;</p><pre><code>protected int size;/** * 元素的数量 * @return */public int size() &#123;    return size;&#125;/** * 是否为空 * @return */public boolean isEmpty() &#123;    return size == 0;&#125;/** * 是否包含某个元素 * @param element * @return */public boolean contains(E element) &#123;    return indexOf(element) != ELEMENT_NOT_FOUND;&#125;/** * 添加元素到尾部 * @param element */public void add(E element) &#123;    add(size, element);&#125;/** * 下面三个是ArrayList和LinkedList两个实现类中的公共代码 * */protected void outOfBounds(int index) &#123;    throw new IndexOutOfBoundsException(&amp;quot;Index:&amp;quot; + index + &amp;quot;, Size:&amp;quot; + size);&#125;protected void rangeCheck(int index) &#123;    if (index &amp;lt; 0 || index &amp;gt;= size) &#123;        outOfBounds(index);    &#125;&#125;protected void rangeCheckForAdd(int index) &#123;    if (index &amp;lt; 0 || index &amp;gt; size) &#123;        outOfBounds(index);    &#125;&#125;</code></pre><p>}</p><p></code></pre></p><h3 id="LHnfr"><span class="ne-text" style="color: #000000">ArrayList设计</span></h3><pre><code>package com.wztlink1013.ds.linkedlist;<p>/**<br> *fun：实现动态数组<br> */<br>@SuppressWarnings(&quot;unchecked&quot;)<br>public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; &#123;<br>    private E[] elements;</p><pre><code>private static final int DEFAULT_CAPACITY = 10;public ArrayList(int capaticy) &#123;    capaticy = (capaticy &amp;lt; DEFAULT_CAPACITY) ? DEFAULT_CAPACITY : capaticy;    elements = (E[]) new Object[capaticy];&#125;public ArrayList() &#123;    this(DEFAULT_CAPACITY);&#125;@Overridepublic void clear() &#123;    for (int i = 0; i &amp;lt; size; i++) &#123;        elements[i] = null;    &#125;    size = 0;&#125;@Overridepublic E get(int index) &#123;    rangeCheck(index);    return elements[index];&#125;@Overridepublic E set(int index, E element) &#123;    rangeCheck(index);    E old = elements[index];    elements[index] = element;    return old;&#125;@Overridepublic void add(int index, E element) &#123;    rangeCheckForAdd(index);    ensureCapacity(size + 1);    for (int i = size; i &amp;gt; index; i--) &#123;        elements[i] = elements[i - 1];    &#125;    elements[index] = element;    size++;&#125;@Overridepublic E remove(int index) &#123;    rangeCheck(index);    E old = elements[index];    for (int i = index + 1; i &amp;lt; size; i++) &#123;        elements[i - 1] = elements[i];    &#125;    elements[--size] = null;    return old;&#125;@Overridepublic int indexOf(E element) &#123;    if (element == null) &#123;  // 1        for (int i = 0; i &amp;lt; size; i++) &#123;            if (elements[i] == null) return i;        &#125;    &#125; else &#123;        for (int i = 0; i &amp;lt; size; i++) &#123;            if (element.equals(elements[i])) return i; // n        &#125;    &#125;    return ELEMENT_NOT_FOUND;&#125;/** * 保证要有capacity的容量 * @param capacity */private void ensureCapacity(int capacity) &#123;    int oldCapacity = elements.length;    if (oldCapacity &amp;gt;= capacity) return;    // 新容量为旧容量的1.5倍    int newCapacity = oldCapacity + (oldCapacity &amp;gt;&amp;gt; 1);    E[] newElements = (E[]) new Object[newCapacity];    for (int i = 0; i &amp;lt; size; i++) &#123;        newElements[i] = elements[i];    &#125;    elements = newElements;    System.out.println(oldCapacity + &amp;quot;扩容为&amp;quot; + newCapacity);&#125;@Overridepublic String toString() &#123;    // size=3, [99, 88, 77]    StringBuilder string = new StringBuilder();    string.append(&amp;quot;size=&amp;quot;).append(size).append(&amp;quot;, [&amp;quot;);    for (int i = 0; i &amp;lt; size; i++) &#123;        if (i != 0) &#123;            string.append(&amp;quot;, &amp;quot;);        &#125;        string.append(elements[i]);    &#125;    string.append(&amp;quot;]&amp;quot;);    return string.toString();&#125;/** * 新添加功能 */public int search(E element)&#123;    for (int i = 0;i&amp;lt;size;i++)&#123;        if (element == elements[i])&#123;            return i;        &#125;    &#125;    return ELEMENT_NOT_FOUND;&#125;</code></pre><p>}</p><p></code></pre></p><p id="eef65beb7cc29a45fc39ce651b8ed461" class="ne-p"><br></p><h3 id="DCY67"><span class="ne-text">LinkedList设计</span></h3><pre><code>package com.wztlink1013.ds.linkedlist;<p>/**<br> *fun：链表的实现<br> */<br>@SuppressWarnings(&quot;unchecked&quot;)<br>public class LinkedList&lt;E&gt; extends AbstractList&lt;E&gt; &#123;<br>    private Node&lt;E&gt; first;<br>    private Node&lt;E&gt; last;</p><pre><code>private static class Node&amp;lt;E&amp;gt; &#123;    E element;    Node&amp;lt;E&amp;gt; prev;    Node&amp;lt;E&amp;gt; next;    public Node(E element, Node&amp;lt;E&amp;gt; next) &#123;        this.element = element;        this.next = next;    &#125;&#125;@Overridepublic void clear() &#123;    size = 0;    first = null;    last = null;&#125;@Overridepublic E get(int index) &#123;    return node(index).element;&#125;@Overridepublic E set(int index, E element) &#123;    Node&amp;lt;E&amp;gt; node = node(index);    E old = node.element;    node.element = element;    return old;&#125;@Overridepublic void add(int index, E element) &#123;    if (index == 0)&#123;        first = new Node&amp;lt;&amp;gt;(element, first);    &#125; else &#123;        Node&amp;lt;E&amp;gt; prev = node(index - 1);        prev.next = new Node&amp;lt;&amp;gt;(element, prev.next);    &#125;    size++;&#125;@Overridepublic E remove(int index) &#123;</code></pre><p>//        Node&lt;E&gt; node = first;<br>//        if (index == 0) {<br>//            first = first.next;<br>//        } else {<br>//            Node&lt;E&gt; prev = node(index -1);<br>//            node = prev.next;<br>//            prev.next = node.next;<br>//        }<br>        rangeCheck(index);</p><pre><code>    Node&amp;lt;E&amp;gt; node = node(index);    Node&amp;lt;E&amp;gt; prev = node.prev;    Node&amp;lt;E&amp;gt; next = node.next;    if (prev == null) &#123; // index == 0        first = next;    &#125; else &#123;        prev.next = next;    &#125;    if (next == null) &#123; // index == size - 1        last = prev;    &#125; else &#123;        next.prev = prev;    &#125;    size--;    return node.element;&#125;@Overridepublic int indexOf(E element) &#123;    if (element == null) &#123;        Node&amp;lt;E&amp;gt; node = first;        for (int i = 0; i &amp;lt; size; i++) &#123;            if (node.element == null) return i;            node = node.next;        &#125;    &#125; else &#123;        Node&amp;lt;E&amp;gt; node = first;        for (int i = 0; i &amp;lt; size; i++) &#123;            if (element.equals(node.element)) return i;            node = node.next;        &#125;    &#125;    return ELEMENT_NOT_FOUND;&#125;/** * 获取index位置对应的节点对象 * @param index * @return */private Node&amp;lt;E&amp;gt; node(int index) &#123;    rangeCheck(index);    if (index &amp;lt; (size &amp;gt;&amp;gt; 1)) &#123;        Node&amp;lt;E&amp;gt; node = first;        for (int i = 0; i &amp;lt; index; i++) &#123;            node = node.next;        &#125;        return node;    &#125; else &#123;        Node&amp;lt;E&amp;gt; node = last;        for (int i = size - 1; i &amp;gt; index; i--) &#123;            node = node.prev;        &#125;        return node;    &#125;&#125;@Overridepublic String toString() &#123;    StringBuilder string = new StringBuilder();    string.append(&amp;quot;size=&amp;quot;).append(size).append(&amp;quot;, [&amp;quot;);    Node&amp;lt;E&amp;gt; node = first;    for (int i = 0; i &amp;lt; size; i++) &#123;        if (i != 0) &#123;            string.append(&amp;quot;, &amp;quot;);        &#125;        string.append(node);        node = node.next;    &#125;    string.append(&amp;quot;]&amp;quot;);    return string.toString();&#125;</code></pre><p>}<br></code></pre></p><h2 id="mAZyd"></h2></div>]]></content>
      
      
      <categories>
          
          <category> 计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 📶线结构：字符串-数组-栈-队列 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>IDEA配置Tomcat</title>
      <link href="/blog/fgh5bc/"/>
      <url>/blog/fgh5bc/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h2 id="iLgZj"><span class="ne-text">一、Tomcat的下载</span></h2><p id="7a017bd8e8e57ed7be8af467a3d07a18" class="ne-p"><br></p><h3 id="7730a6e8"><span class="ne-text">正常下载并安装</span></h3><div class="ne-quote"><p id="37d154ed957326ba548647ad42228a35" class="ne-p"><span class="ne-text">！！！在此之前默认读者下载且配置好了jdk环境</span></p></div><p id="15ceaa3f3b21e4713261d096377b5934" class="ne-p"><br></p><ul class="ne-ul"><li id="372f8734116240546215c7df0d9eacfd" style="text-align: center"><span class="ne-text">进入该官网</span><a href="https://imgconvert.csdnimg.cn/aHR0cDovL3RvbWNhdC5hcGFjaGUub3JnLw?x-oss-process=image/format,png" data-href="https://imgconvert.csdnimg.cn/aHR0cDovL3RvbWNhdC5hcGFjaGUub3JnLw?x-oss-process=image/format,png" target="_blank" class="ne-link"><span class="ne-text">下载页面</span></a><span class="ne-text"><br /></span><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598787914511-a035ba93-0b7a-450b-b391-5d1452435ca7.png" width="461" id="f42cV" class="ne-image"></li><li id="55cfb4a6606ba8f6b0a73fcc56f5c98d" style="text-align: center"><span class="ne-text">下载并解压到自己的相应盘区，再进入下图文件夹检验是否成功<br /></span><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598787914448-2ef2e1a1-2966-4d35-8bfe-82162aa1588b.png" width="431" id="vyTkc" class="ne-image"></li><li id="c3ea57144edfc0f341cfe8df78cd3800" style="text-align: center"><span class="ne-text">点击第二个框不出现闪退情况则证明成功<br /></span><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598787914507-87063aec-884a-4180-b124-568478d81bc0.png" width="425" id="rgrop" class="ne-image"></li><li id="0ad6bc125416a42078cb0cb477710091" style="text-align: center"><span class="ne-text">浏览器进入端口</span><a href="http://localhost:8080/" data-href="http://localhost:8080/" target="_blank" class="ne-link"><span class="ne-text">http://localhost:8080/</span></a><span class="ne-text">上述配置成功则表明成功<br /></span><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598787914624-248148e3-3f5f-45ca-ad93-c063216a7aff.png" width="429" id="N7Pg6" class="ne-image"></li></ul><p id="ba972926e91f7f3b2b7564248dc1d242" class="ne-p"><br></p><h3 id="7ae41c7b"><span class="ne-text">过程中可能会出现的问题</span></h3><p id="b6e60141a96a1c1634bce1c1ff9592ee" class="ne-p"><br></p><ul class="ne-ul"><li id="a7e7087f9b895988e7e3a9ed0d1f5f5b"><span class="ne-text">点击startup.bat文件出现闪退<br /></span><span class="ne-text">电脑中java jdk有无（JAVA_HOME）</span></li><li id="5f157a19d26ef621428854de8c6cf303"><span class="ne-text">端口被占用<br /></span><span class="ne-text">进入Tomcat文件夹下的conf文件下的server.xml文件，用记事本查找8080，下面复制一个新的初始端口<br /></span><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598787914513-8083bc6e-4c6f-436e-b0b0-98d3d70b9dea.png" width="557" id="Z1QuJ" class="ne-image"></li></ul><p id="1f1a86b0108f014bb2e9e3214fe382c7" class="ne-p"><br></p><h2 id="87228d3a"><span class="ne-text">二、IDEA配置Tomcat</span></h2><p id="68e90f88b89a55ffd97870ade37c6d8b" class="ne-p"><br></p><h3 id="224e2ccd"><span class="ne-text">配置</span></h3><p id="1ae705a5c75e9821bdad0220bcf24c69" class="ne-p"><br></p><ul class="ne-ul"><li id="4306f37ec643ec27c61edd7104c1f9e6"><span class="ne-text">新建一个项目<br /></span><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598787914503-6a4bf3f9-0e92-4bd3-bcde-e65af73510b8.png" width="1457" id="SyJXG" class="ne-image"></li><li id="39cefd027174599aebe9a86e1e89ae75"><span class="ne-text">编写head/body待会测试用<br /></span><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598787914719-36f4cef3-db7c-4bd9-a43a-5c92f0afead2.png" width="1842" id="FdDQj" class="ne-image"></li><li id="1eb675b1324051082529b7e54556b7a4"><span class="ne-text">相关配置<br /></span><span class="ne-text">进入配置页面</span><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598787914684-a3f47ea5-50df-450f-935d-f9ec086bc2cb.png" width="1842" id="e3y51" class="ne-image"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598787914511-d1b72498-32cb-4868-8758-34fb3de3e798.png" width="1343" id="W5tPZ" class="ne-image"><span class="ne-text"><br /></span><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598787914585-5e3362d9-db50-4bdb-8640-f3a2f630bbbf.png" width="1343" id="mQrTR" class="ne-image"></li></ul><p id="65be47269fa48a821e6b44f572f9ec99" class="ne-p"><br></p><h3 id="9c484867"><span class="ne-text">运行测试</span></h3><p id="051dc1bc2615045f6ff8356943d3488b" class="ne-p"><br></p><p id="0926fcb9fe467ded67acdf5d3f1537b8" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598787914608-c71c5263-ae91-472f-b760-cc3fbd78b81c.png" width="1842" id="hHket" class="ne-image"></p><p id="fca4efa535dada10c3d2838d542abdff" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598787914608-14ca2925-9dd2-4cfd-9399-597c08094743.png" width="1836" id="L3XOo" class="ne-image"></p></div>]]></content>
      
      
      <categories>
          
          <category> 计算机素养 </category>
          
          <category> 环境搭建 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>对谷歌BERT模型的思考</title>
      <link href="/blog/mssoff/"/>
      <url>/blog/mssoff/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content-editor-core lake-engine lake-typography-classic" data-lake-element="root" data-selection-undefined="%7B%22path%22%3A%5B%5B1%2C0%2C0%2C0%5D%2C%5B1%2C0%2C0%2C0%5D%5D%2C%22active%22%3Atrue%7D"><h2 data-lake-id="QmMzl" id="QmMzl" style="padding: 7px 0px; margin: 0px; font-weight: 700; font-size: 24px; line-height: 32px;"><span>why？</span></h2><blockquote style="margin-top: 5px; margin-bottom: 5px; padding-left: 1em; margin-left: 0px; border-left: 3px solid rgb(238, 238, 238); opacity: 0.6;"><p data-lake-id="ec3bb7405bd7550ef75e1f43c383194c" id="ec3bb7405bd7550ef75e1f43c383194c" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>BERT 可以用来干什么？</span></p></blockquote><p data-lake-id="23fbdb616f0d31557fc0272925a08c03" id="23fbdb616f0d31557fc0272925a08c03" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="c82cd921db9953498d69a5ebfed46291" id="c82cd921db9953498d69a5ebfed46291" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>处理这种非结构化的数据以及之前学习到的情感分析</span></p><p data-lake-id="552845ea0ca3ed757de48705c950835a" id="552845ea0ca3ed757de48705c950835a" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="ede620a9eeba128e8744d65d197be635" id="ede620a9eeba128e8744d65d197be635" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>BERT 可以用于问答系统，情感分析，垃圾邮件过滤，命名实体识别，文档聚类等任务中，作为这些任务的基础设施即语言模型，</span></p><p data-lake-id="e764cf4f661a88ce43217a7f9e73c915" id="e764cf4f661a88ce43217a7f9e73c915" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><h2 data-lake-id="SoIfy" id="SoIfy" style="padding: 7px 0px; margin: 0px; font-weight: 700; font-size: 24px; line-height: 32px;"><span>what？</span></h2><p data-lake-id="750137749eeb8445f5a750d2e948f4fc" id="750137749eeb8445f5a750d2e948f4fc" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>是一个自然语言处理模型</span></p><p data-lake-id="14e39690420b1775312001f022312241" id="14e39690420b1775312001f022312241" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>提出了“训练词向量”概念，这是独特之处</span></p><p data-lake-id="fb23f27ed98d0439bfc1a3c65991a3af" id="fb23f27ed98d0439bfc1a3c65991a3af" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="196aef9c54ed8b55a864d421c3affea0" id="196aef9c54ed8b55a864d421c3affea0" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><strong><span>BERT 利用了 Transformer 的 encoder 部分。</span></strong></p><p data-lake-id="86fd545c660e9a6889a7dfefa31e1a63" id="86fd545c660e9a6889a7dfefa31e1a63" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><strong><span>BERT 的创新点在于它将双向 Transformer 用于语言模型，</span></strong></p><p data-lake-id="befa81a632ce3c61445c15128fa41d50" id="befa81a632ce3c61445c15128fa41d50" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>之前的模型是从左向右输入一个文本序列，或者将 left-to-right 和 right-to-left 的训练结合起来。实验的结果表明，双向训练的语言模型对语境的理解会比单向的语言模型更深刻，Transformer 是一种注意力机制，可以学习文本中单词之间的上下文关系的。Transformer 的原型包括两个独立的机制，一个 encoder 负责接收文本作为输入，一个 decoder 负责预测任务的结果。BERT 的目标是生成语言模型，所以只需要 encoder 机制。Transformer 的 encoder 是一次性读取整个文本序列，而不是从左到右或从右到左地按顺序读取，这个特征使得模型能够基于单词的两侧学习，相当于是一个双向的功能。 Transformer 的 encoder 部分，输入是一个 token 序列，先对其进行 embedding 称为向量，然后输入给神经网络，输出是大小为 H 的向量序列，每个向量对应着具有相同索引的 token。当我们在训练语言模型时，有一个挑战就是要定义一个预测目标，很多模型在一个序列中预测下一个单词，“The child came home from ___”双向的方法在这样的任务中是有限制的，为了克服这个问题，BERT 使用两个策略:</span></p><h3 data-lake-id="PGVlb" id="PGVlb" style="padding: 7px 0px; margin: 0px; font-weight: 700; font-size: 20px; line-height: 28px;"><span>Masked LM (MLM)</span></h3><p data-lake-id="0ee04d459d5b3c3dc4fa2a6c770cd12a" id="0ee04d459d5b3c3dc4fa2a6c770cd12a" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>论文中介绍了一种新技术叫做 Masked LM（MLM），在这个技术出现之前是无法进行双向语言模型训练的。在将单词序列输入给 BERT 之前，每个序列中有 15％ 的单词被 [MASK] token 替换。 然后模型尝试基于序列中其他未被 mask 的单词的上下文来预测被掩盖的原单词。</span></p><p data-lake-id="59ad2945651a517229be802fad20586f" id="59ad2945651a517229be802fad20586f" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="5e11775ccadeae7fe2e76420dcbfdea1" id="5e11775ccadeae7fe2e76420dcbfdea1" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>这样就需要：</span></p><ul class="lake-list" data-lake-id="8c7ed3a6330fd908d0f1f447da832f18_ul_0" lake-indent="0" style="list-style-type: disc; margin: 0px; padding-left: 23px; font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word;"><li data-lake-id="1d7c69f17e4e3d51480cc39c25489780" class="lake-list-node lake-list-task" data-lake-checked="true" style="list-style: none;"><span data-card-type="inline" data-lake-card="checkbox" contenteditable="false"><span style="margin: 3px 0.5ex; vertical-align: middle; width: 16px; height: 16px;">✅<span></span></span></span><span>在 encoder 的输出上添加一个分类层</span></li><li data-lake-id="29e80f48b8b6677bcfc9cd1e6ab76069" class="lake-list-node lake-list-task" data-lake-checked="true" style="list-style: none;"><span data-card-type="inline" data-lake-card="checkbox" contenteditable="false"><span style="margin: 3px 0.5ex; vertical-align: middle; width: 16px; height: 16px;">✅<span></span></span></span><span>用嵌入矩阵乘以输出向量，将其转换为词汇的维度</span></li><li data-lake-id="852de69aa7e6fc0ef176ef97941b4c14" class="lake-list-node lake-list-task" data-lake-checked="true" style="list-style: none;"><span data-card-type="inline" data-lake-card="checkbox" contenteditable="false"><span style="margin: 3px 0.5ex; vertical-align: middle; width: 16px; height: 16px;">✅<span></span></span></span><span>用 softmax 计算词汇表中每个单词的概率</span></li></ul><p data-lake-id="e7423df12dc3f78076db3b90884ce5a6" id="e7423df12dc3f78076db3b90884ce5a6" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="6bf72040d7b344f5b61fa736b4457dfc" id="6bf72040d7b344f5b61fa736b4457dfc" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>BERT 的损失函数只考虑了 mask 的预测值，忽略了没有掩蔽的字的预测。这样的话，模型要比单向模型收敛得慢，不过结果的情境意识增加了。</span></p><p data-lake-id="615fc7a3da7d7b28434e75a86a6feed3" id="615fc7a3da7d7b28434e75a86a6feed3" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="04c8c4500374f0fe342ab27acfa02378" id="04c8c4500374f0fe342ab27acfa02378" style="text-align: left; font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><strong><span>eg：my dog is hairy</span></strong></p><ul data-lake-id="09f4cf3a75546f17ed3a193a946d3c40_ul_1" lake-indent="0" style="list-style-type: disc; margin: 0px; padding-left: 23px; font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word;"><li data-lake-id="496115badd4393942914d31debfb699e"><span>有80%的概率用“[mask]”标记来替换——my dog is [MASK]</span></li><li data-lake-id="349a2c6494ddbcca7de20b70ebe7b826"><span>有10%的概率用随机采样的一个单词来替换——my dog is apple</span></li><li data-lake-id="f6a32b7016ecd937ba3851dc4e477ee8"><span>有10%的概率不做替换——my dog is hairy</span></li></ul><h3 data-lake-id="89DVm" id="89DVm" style="padding: 7px 0px; margin: 0px; font-weight: 700; font-size: 20px; line-height: 28px;"><span>Next Sentence Prediction (NSP)</span></h3><p data-lake-id="75e65e079964114273708a308f723c12" id="75e65e079964114273708a308f723c12" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>在 BERT 的训练过程中，模型接收成对的句子作为输入，并且预测其中第二个句子是否在原始文档中也是后续句子。在训练期间，50％ 的输入对在原始文档中是前后关系，另外 50％ 中是从语料库中随机组成的，并且是与第一句断开的。为了帮助模型区分开训练中的两个句子，输入在进入模型之前要按以下方式进行处理：</span></p><p data-lake-id="33027e6a488dc7c4a68d923794c2f552" id="33027e6a488dc7c4a68d923794c2f552" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><ul class="lake-list" data-lake-id="6d0a401c8bb2d48b070cce9f584db5c9_ul_2" lake-indent="0" style="list-style-type: disc; margin: 0px; padding-left: 23px; font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word;"><li data-lake-id="540700a6986c2c94c03c58d4f1d6ee73" class="lake-list-node lake-list-task" data-lake-checked="true" style="list-style: none;"><span data-card-type="inline" data-lake-card="checkbox" contenteditable="false"><span style="margin: 3px 0.5ex; vertical-align: middle; width: 16px; height: 16px;">✅<span></span></span></span><span>在第一个句子的开头插入 [CLS] 标记，在每个句子的末尾插入 [SEP] 标记。</span></li><li data-lake-id="bd720e6295fc2ea40133ee1c0bf0d8c9" class="lake-list-node lake-list-task" data-lake-checked="true" style="list-style: none;"><span data-card-type="inline" data-lake-card="checkbox" contenteditable="false"><span style="margin: 3px 0.5ex; vertical-align: middle; width: 16px; height: 16px;">✅<span></span></span></span><span>将表示句子 A 或句子 B 的一个句子 embedding 添加到每个 token 上。</span></li><li data-lake-id="d41c0a90ff6a24f0751e06eaf0b76f12" class="lake-list-node lake-list-task" data-lake-checked="true" style="list-style: none;"><span data-card-type="inline" data-lake-card="checkbox" contenteditable="false"><span style="margin: 3px 0.5ex; vertical-align: middle; width: 16px; height: 16px;">✅<span></span></span></span><span>给每个 token 添加一个位置 embedding，来表示它在序列中的位置。</span></li><li data-lake-id="17c3fc6224d25dbbce673c8eb4af22c7" class="lake-list-node lake-list-task" data-lake-checked="true" style="list-style: none;"><span data-card-type="inline" data-lake-card="checkbox" contenteditable="false"><span style="margin: 3px 0.5ex; vertical-align: middle; width: 16px; height: 16px;">✅<span></span></span></span><span>为了预测第二个句子是否是第一个句子的后续句子，用下面几个步骤来预测：</span></li><li data-lake-id="f2f91655eda5e3968c23da52d4185e45" class="lake-list-node lake-list-task" data-lake-checked="true" style="list-style: none;"><span data-card-type="inline" data-lake-card="checkbox" contenteditable="false"><span style="margin: 3px 0.5ex; vertical-align: middle; width: 16px; height: 16px;">✅<span></span></span></span><span>整个输入序列输入给 Transformer 模型</span></li><li data-lake-id="bb780f1f3ebc46947923155094495131" class="lake-list-node lake-list-task" data-lake-checked="true" style="list-style: none;"><span data-card-type="inline" data-lake-card="checkbox" contenteditable="false"><span style="margin: 3px 0.5ex; vertical-align: middle; width: 16px; height: 16px;">✅<span></span></span></span><span>用一个简单的分类层将 [CLS] 标记的输出变换为 2×1 形状的向量</span></li><li data-lake-id="3d20f16be54396b5896fd49c755d7ac7" class="lake-list-node lake-list-task" data-lake-checked="true" style="list-style: none;"><span data-card-type="inline" data-lake-card="checkbox" contenteditable="false"><span style="margin: 3px 0.5ex; vertical-align: middle; width: 16px; height: 16px;">✅<span></span></span></span><span>用 softmax 计算 IsNextSequence 的概率</span></li></ul><p data-lake-id="b89a08c9e01239cdf586fae257b063ed" id="b89a08c9e01239cdf586fae257b063ed" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="22124aeac3683100b16b15985885efd9" id="22124aeac3683100b16b15985885efd9" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>在训练 BERT 模型时，Masked LM 和 Next Sentence Prediction 是一起训练的，目标就是要最小化两种策略的组合损失函数。</span></p><h2 data-lake-id="EkXye" id="EkXye" style="padding: 7px 0px; margin: 0px; font-weight: 700; font-size: 24px; line-height: 32px;"><span>how？</span></h2><p data-lake-id="79f6188d4282c40c16ed6aff02fadf39" id="79f6188d4282c40c16ed6aff02fadf39" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>BERT 可以用于各种NLP任务，只需在核心模型中添加一个层.</span></p><p data-lake-id="26b59c6f69d7ee7d2df66f86de875eff" id="26b59c6f69d7ee7d2df66f86de875eff" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>例如：</span></p><ul class="lake-list" data-lake-id="6accca962a7aedb3ce49c489ef714cfd_ul_3" lake-indent="0" style="list-style-type: disc; margin: 0px; padding-left: 23px; font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word;"><li data-lake-id="0e6fe1a94b8968aff7e52ed6f92a7f3a" class="lake-list-node lake-list-task" data-lake-checked="true" style="list-style: none;"><span data-card-type="inline" data-lake-card="checkbox" contenteditable="false"><span style="margin: 3px 0.5ex; vertical-align: middle; width: 16px; height: 16px;">✅<span></span></span></span><span>在分类任务中，例如情感分析等，只需要在 Transformer 的输出之上加一个分类层</span></li><li data-lake-id="d08b109a55e20e3bcb68ef55f591e4e3" class="lake-list-node lake-list-task" data-lake-checked="true" style="list-style: none;"><span data-card-type="inline" data-lake-card="checkbox" contenteditable="false"><span style="margin: 3px 0.5ex; vertical-align: middle; width: 16px; height: 16px;">✅<span></span></span></span><span>在问答任务（例如SQUAD v1.1）中，问答系统需要接收有关文本序列的 question，并且需要在序列中标记 answer。 可以使用 BERT 学习两个标记 answer 开始和结尾的向量来训练Q＆A模型。</span></li><li data-lake-id="385d7efda04fdaacc41cbd46c063b79c" class="lake-list-node lake-list-task" data-lake-checked="true" style="list-style: none;"><span data-card-type="inline" data-lake-card="checkbox" contenteditable="false"><span style="margin: 3px 0.5ex; vertical-align: middle; width: 16px; height: 16px;">✅<span></span></span></span><span>在命名实体识别（NER）中，系统需要接收文本序列，标记文本中的各种类型的实体（人员，组织，日期等）。 可以用 BERT 将每个 token 的输出向量送到预测 NER 标签的分类层。</span></li></ul><p data-lake-id="834b34a0a59600348c97c2712968d078" id="834b34a0a59600348c97c2712968d078" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="83250b8e71dd4b733e4b46c63f63a637" id="83250b8e71dd4b733e4b46c63f63a637" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p></div>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Node环境+Hexo环境的搭建</title>
      <link href="/blog/yo1xhz/"/>
      <url>/blog/yo1xhz/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><div data-type="info" class="ne-alert"><p id="f060265e624c0d01ab491c2fec245665" class="ne-p"><span class="ne-text">前言：搭建node环境，在此基础上安装hexo模块以搭建个人静态网站。</span></p></div><h2 id="44703baa"><span class="ne-text">一、环境安装与配置</span></h2><h3 id="4ae46e8c"><span class="ne-text">Node的下载与安装</span></h3><ul class="ne-ul"><li id="u176f5000"><span class="ne-text">下载</span><a href="https://nodejs.org/en/" data-href="https://nodejs.org/en/" target="_blank" class="ne-link"><span class="ne-text">Node.js</span></a></li></ul><ul class="ne-ul"><li id="u847758e1"><strong><span class="ne-text">设置模块的安装路径，不然会默认在C盘，不好管理，也占系统盘存储空间</span></strong></li></ul><div class="ne-quote"><p id="u2e97cde0" class="ne-p"><span class="ne-text" style="color: #121212">nodejs 文件夹中新建两个空文件夹 node_cache、node_global</span></p></div><pre><code>npm config set prefix &quot;D:\nodejs\node_global&quot;npm config set cache &quot;D:\nodejs\node_cache&quot;</code></pre><p id="217386aba664ecd5edc826f36bc5811f" class="ne-p" style="text-align: left"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1624969463695-0751b555-3284-469d-9a94-d721eb6c2ff7.png" width="720" id="u454edc1a" class="ne-image"></p><ul class="ne-ul"><li id="ub5841fdb" style="text-align: left"><span class="ne-text">环境变量的配置</span></li></ul><div class="ne-quote"><p id="u4c2a9030" class="ne-p" style="text-align: left"><span class="ne-text">需要用到的路径</span></p><p id="u97a3a00c" class="ne-p" style="text-align: left"><span class="ne-text" style="color: #121212">D:\nodejs\node_global\node_modules</span></p><p id="ucccdceb9" class="ne-p" style="text-align: left"><span class="ne-text" style="color: #121212">D:\nodejs\node_global</span></p></div><p id="50146f55c53350f4ecec4c7f3a987355" class="ne-p" style="text-align: left"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1624969533021-b8d200d6-eb5e-44f1-8e7c-f62914d05bb2.png" width="849" id="u26c06f0e" class="ne-image"></p><h3 id="NhJgb"><span class="ne-text">安装Hexo </span></h3><pre><code>npm install -g hexo-cli</code></pre><p id="ueada9bc9" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1624970023639-a627549b-bd0f-4ca6-ad98-448cda506627.png" width="720" id="u95259d87" class="ne-image"></p><div class="ne-quote"><p id="ue2925ab7" class="ne-p"><span class="ne-text">同时也可以看到全局所安装的模块在刚刚设定的路径下面</span></p></div><p id="ub21f8446" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1624970066364-8a42b037-868e-4e72-9644-1ed15b81b482.png" width="269.5" id="ucbce49f7" class="ne-image"></p><h3 id="00656b27"><span class="ne-text">申请GitHub Pages</span></h3><p id="00d5e938438121689335709c7746f95d" class="ne-p"><span class="ne-text">在github上申请github pages，在账户下创建一个仓库名为 </span><code class="ne-code"><span class="ne-text">wztlink1013.github.io</span></code><span class="ne-text">的仓库，则这个仓库下的main分支下的前端代码就会被发布成成网页（必须要由index.html文件）。</span></p><div class="ne-quote"><p id="d0222dc488fe23029d35b9e9f5dc63f7" class="ne-p"><span class="ne-text">访问：</span><a href="https://wztlink1013.github.io/" data-href="https://wztlink1013.github.io/" target="_blank" class="ne-link"><span class="ne-text">https://wztlink1013.github.io</span></a></p></div><h2 id="8becaf52"><span class="ne-text">二、搭建博客</span></h2><h3 id="a5dab729"><span class="ne-text">创建并初始化文件夹</span></h3><div class="ne-quote"><p id="c3ac13c119756e60c9e926f0c12386ab" class="ne-p"><span class="ne-text">这里面所有文件就相当于所搭建博客网页所有源文件</span></p></div><p id="2326be445612db35ebd03719bcb69dc6" class="ne-p"><span class="ne-text">进入文件夹输入</span></p><pre><code>hexo init</code></pre><p id="9bf91bad5a2319fd16358cb4848911f9" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616727001925-a02dabbf-4792-492e-bf5d-fed01a85eafc.png" width="947" id="WSl3w" class="ne-image"></p><p id="2d478cdf57ebf409d10d175ee41372b3" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616727028761-75106936-43e9-4879-9c25-4596074efc43.png" width="947" id="omNqC" class="ne-image"></p><ul class="ne-ul"><li id="u2365d2f6"><span class="ne-text">文件夹下个文件的功能</span></li></ul><pre><code>node_modules：各种插件的安装文件夹scaffolds：模板文件夹（new的对象的模板）source：资源文件夹themes：主题文件夹（相当于“衣裳”）_config.yml：站点配置文件package.json：应用程序的信息</code></pre><p id="420f9776d5e40ebb3bc49dba6fa2dea7" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616727087774-de9b7013-31f1-4f4b-8018-4dc47b46d075.png" width="960" id="Hho9g" class="ne-image"></p><p id="2039efb3c1ffc3646c05a8928ea57688" class="ne-p"><br></p><h3 id="c5609495"><span class="ne-text">相关命令</span></h3><pre><code>hexo clean   #清除缓存，网页正常情况下可以忽略此条命令hexo n &quot;博客名称&quot;  # hexo new &quot;博客名称&quot;   hexo p  # hexo publishhexo g  # hexo generate  # 生成静态网页hexo s  # hexo server  # 启动服务预览；Hexo 会监视文件变动并自动更新，无须重启服务器。        hexo server -s   #静态模式        hexo server -p 5000   #更改端口        hexo server -i 192.168.1.1   #自定义IPhexo d  # hexo deploy  # 部署                hexo deploy --message &quot;哈哈，hexo deploy --message 双引号内容就可以提交commit信息了&quot;</code></pre><p id="5a9e07991240f620638af3d1cd022415" class="ne-p"><br></p></div>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
          <category> 博客技术 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C/C++遗忘知识总结</title>
      <link href="/blog/uakfgc/"/>
      <url>/blog/uakfgc/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="67e08bf60a7cfacfbb8c4052e2207871" class="ne-p"><span class="ne-text"></span></p><div data-type="info" class="ne-alert"><p id="4c7db9327d0913fd8a6a2ace42d9147b" class="ne-p"><span class="ne-text">相当于记个流水帐了~菜鸡永远没有对任何知识都会的时候</span></p></div><p id="6d7ec2fd06fbaecb8e255afc1a37f01c" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/gif/1484158/1618304475795-4149058a-4d7c-49b6-8956-e22568cb4888.gif" width="218" id="qc35J" class="ne-image"></p><h2 id="51ycv"><span class="ne-text">C指针</span></h2><p id="fe0c7c9940c211b668231edb786f465d" class="ne-p"><span class="ne-text">相关概念的理解容易混淆，记住之前学习理解的一个准则！</span><code class="ne-code"><span class="ne-text">*p 的理解意义就是p 所指向的那个东西</span></code></p><ul class="ne-ul"><li id="bb3eb5d3bc35c5d6903a9a061b3e4ecd"><span class="ne-text">取地址符 </span><code class="ne-code"><span class="ne-text">&amp;</span></code><span class="ne-text"> </span></li><li id="62f95a3a5290178ef3014814ac01e852"><span class="ne-text">解引用运算符 </span><code class="ne-code"><span class="ne-text">*</span></code><span class="ne-text"> </span></li></ul><div class="ne-quote"><p id="53738e97dc2d9cf4535fc5b1e8796bb4" class="ne-p"><span class="ne-text">参考：</span></p><ul class="ne-ul"><li id="2672231334543f9f4afce57ff5d2e4b5"><a href="https://blog.csdn.net/soonfly/article/details/51131141" data-href="https://blog.csdn.net/soonfly/article/details/51131141" target="_blank" class="ne-link"><span class="ne-text">https://blog.csdn.net/soonfly/article/details/51131141</span></a></li></ul><p id="5fdee32c1d2d23ca527b0a0e3f03293d" class="ne-p"><span class="ne-text">* 有3个用途</span></p><p id="34ad2adec1bf20f86371daee5f520aaf" class="ne-p"><span class="ne-text">1. 乘号（Multiply）： 2*3 就是6</span></p><p id="86eed2b389d6d469bbc049cccd9c9dff" class="ne-p"><span class="ne-text">2. 声明指针（Pointer Statement）： int a =5; int* ptr=&amp;a;就是声明变量a是5，把a的地址附到指针ptr上</span></p><p id="4a2090c015d624cddee6d8fb820093a7" class="ne-p"><span class="ne-text">3. 解引用 （Dereference）： *ptr 单独拿出来就是找出 ptr指针指向的值，按照第二点的说法就是5. </span></p><p id="8e6f31b52e16a3501484d737cdf0eff2" class="ne-p"><span class="ne-text">&amp;叫做取地址符号</span></p><p id="e1c6edd61c6e97358be76e8037a3d20a" class="ne-p"><span class="ne-text">• 一般指针只能接受一个内存地址而不能接受一个值</span></p><p id="dd88659bafe8f78eb1df3dfbd4b2de03" class="ne-p"><span class="ne-text">• int a =5; int* ptr=a;就是错误的，指针不能接受一个值</span></p><p id="e90cb6d514707ddb743b35a622d58347" class="ne-p"><span class="ne-text">• int a =5; int* ptr=&amp;a;才对，把a的地址给指针ptr</span></p><p id="38b65fa2d86abe387f7b5c0fe66a7f43" class="ne-p"><span class="ne-text">指针理解的话你可以这么想。</span></p><p id="5502ae354a57a74024c7b64fcc8eaabc" class="ne-p"><span class="ne-text">你问我书在哪。我说在书架第一层。</span></p><p id="4714f9a4cc8d2c2a7d850833106baa12" class="ne-p"><span class="ne-text">你问我书在哪。我说在那个桌子上的纸条上写着位置。这样的话那个纸条就是指针。</span></p><p id="ae3b732f456aeee776c46ad3eee3fbf3" class="ne-p"><span class="ne-text">纸条上写着，书在书架第一层，这就是地址，他并不是书的实体</span></p><p id="237aff462c974bc1cfe6447a87739d58" class="ne-p"><span class="ne-text">真正的书在书架第一层，顺着地址去找吧</span></p></div><h2 id="9d99bbbf"><span class="ne-text">C结构体</span></h2><h3 id="z86QD"><span class="ne-text">一些概念</span></h3><div class="ne-quote"><ul class="ne-ul"><li id="d1765bfb6d06c10f21c7014f39941e62"><span class="ne-text">结构体:构造（定义新的数据类型）</span></li><li id="efc3c5b1e5a95051c641ef77b8cc52bb"><span class="ne-text">结构体变量:定义（两种）；结构体变量访问结构体里面的成员：</span><code class="ne-code"><span class="ne-text">.</span></code><span class="ne-text">；指针访问成员的时候</span><code class="ne-code"><span class="ne-text">-&gt;</span></code></li><li id="b5c26d68531331694fe7229e8608fcfd"><span class="ne-text">结构体数组：变量很多</span></li><li id="5c1bb0304ccf530c82320b29bc12a50c"><span class="ne-text">结构体指针：指向结构体变量的指针，定义：</span><code class="ne-code"><span class="ne-text">struct Student *p</span></code><span class="ne-text">；指向结构体数组的指针</span></li></ul></div><ul class="ne-ul"><li id="71d14417540589cb4879c6a9f576e411"><span class="ne-text">C里面的</span><strong><span class="ne-text">结构体、共用体、枚举体</span></strong><span class="ne-text">根据这几类来构造新的数据类型，比如链表的初始实现，就是利用指针和结构体来实现</span></li><li id="ec15cbc229cf94352200ecef4e216f4f"><strong><span class="ne-text">typedef</span></strong><span class="ne-text">给结构体制定新的类型名  eg：计数专用变量</span><code class="ne-code"><span class="ne-text">typedef int Count</span></code></li></ul><h3 id="k01wR"><span class="ne-text">单链表的存储结构</span></h3><p id="17c2f0384e632317fcf803860ee866c4" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616502801770-db341786-acc5-4024-966b-8793c339cc89.png" width="494.5" id="C1xSN" class="ne-image"></p><p id="25b850048759a9e061612cc535a1790c" class="ne-p"><span class="ne-text">上面的代码可以分解为：</span></p><pre><code>typedef struct LNode LNode;         //将结构体类型struct LNode重命名为LNodetypedef struct LNode *LinkList;     //将struct LNode *重命名为LinkList</code></pre><p id="865af01bee2b75a80b16f792cab36b9a" class="ne-p"><br></p><div class="ne-quote"><p id="b855a25b780b0279264580a610b36641" class="ne-p"><span class="ne-text">创建的时候，可以有下面三种方法</span></p><p id="8cdfabb8f1a8a036898bffe14e7697dd" class="ne-p"><span class="ne-text">【L是指向结构体类型（struct LNode型）指针变量】</span></p></div><ol class="ne-ol"><li id="9e5a715bd579c72ae9ae9a4f58176c2a"><span class="ne-text">LinkList L; </span></li><li id="e326d19f83319b427fb6b370eddddd7f"><span class="ne-text">struct LNode * L</span></li><li id="7173c9458fbaf788bd5794741e60c140"><span class="ne-text">LNode *L = new LNode;</span></li></ol><p id="14736ef7af51e46ed8c9c81b265e631f" class="ne-p"><span class="ne-text" style="color: #4D4D4D; font-size: 16px">只不过是用第1种方式创建更加简单，</span><span class="ne-text">具体的使用，new的时候一般使用前者，定义一个该类型变量的时候一般用后者</span></p><p id="980dd05e1ac6353ccbc803dd39bb8b95" class="ne-p"><br></p><p id="1e840869837fd9966bd8cdaa9bd595c6" class="ne-p"><span class="ne-text">LinkList L；理解：一个结构体变量的指针就是该结构体变量所占据的内存段的起始地址，而我定义的是LinkList而不是int，只是和计算机说明我需要的内存不一样了这种作用</span></p><p id="f2cb48f92634a846edf03d1a43600089" class="ne-p"><span class="ne-text" style="color: #4D4D4D; font-size: 16px"></span></p><p id="5f2cbc958c2139a89b32a6d4cca0b09f" class="ne-p"><span class="ne-text">参考：</span><a href="https://blog.csdn.net/GRoads/article/details/104155255" data-href="https://blog.csdn.net/GRoads/article/details/104155255" target="_blank" class="ne-link"><span class="ne-text">https://blog.csdn.net/GRoads/article/details/104155255</span></a></p><h2 id="419ebc43"><span class="ne-text">C++的函数参数引用&amp;理解</span></h2><p id="7cc49998b1370db36bea506d4e759ec3" class="ne-p"><span class="ne-text">在学习单链表的时候，编写前插法的函数，函数参数传递的是&amp;L而不是*L，这个相关知识的解释，参考这个帖子</span><a href="https://fishc.com.cn/thread-98021-1-1.html" data-href="https://fishc.com.cn/thread-98021-1-1.html" target="_blank" class="ne-link"><span class="ne-text">https://fishc.com.cn/thread-98021-1-1.html</span></a><span class="ne-text">，里面的榜首答案下图这么一句话</span></p><p id="8f530b1c09d55f86025485d72befda37" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616504219420-872367f1-be2c-4afe-89e5-12ecbfe817dc.png" width="829" id="WlGM3" class="ne-image"></p><ul class="ne-ul"><li id="742be92a48a50262c0a7c8ae157cff63"><span class="ne-text">函数传递&amp;：为引用参数，传递给引用于传递指针的效果是一样的，【只是个别名，不是取值！！】</span><a href="https://blog.csdn.net/weibo1230123/article/details/78910179" data-href="https://blog.csdn.net/weibo1230123/article/details/78910179" target="_blank" class="ne-link"><span class="ne-text">https://blog.csdn.net/weibo1230123/article/details/78910179</span></a></li><li id="921afbb19819ae1f580f32c198c2a283"><span class="ne-text">代码实操以下</span></li></ul><p id="a5f96fb6c792a7616ed296343243b524" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616504292045-802c3bc2-ebbc-49aa-8764-7852def70548.png" width="377.5" id="cHiQv" class="ne-image"></p><p id="38f6858eb112651311de60217a7dcde8" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616504341193-3d82d795-ebab-42c9-bc2c-3b6f0fe04e2e.png" width="427" id="H6SrY" class="ne-image"></p><p id="b5b2124d24a5f6a247509d8e7312e59a" class="ne-p"><span class="ne-text">图1是可以运行的，图2不可以（传递错误的格式）</span></p><p id="f3ea05b6555d9da08da917027b1c7759" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616504560727-4aacc3bb-139a-46be-aafb-5ba50bbae0b3.png" width="531" id="Y5Ioe" class="ne-image"></p><p id="6cebf9ae5aa7c0687bec91caf8263783" class="ne-p"><span class="ne-text">函数参数的传递，还要好好再复习复习……</span></p><h2 id="o2Z0x"><span class="ne-text">类C中new、delete</span></h2><p id="e0d887f1be6eac510cf730e18aca18eb" class="ne-p"><span class="ne-text">在数据结构课程里面的类C语言里面，new、delete分别为在内存中分配/释放空间</span></p><h2 id="T3UgL"><span class="ne-text">C++值STL</span></h2><h3 id="U5dxH"><span class="ne-text">vector</span></h3><ul class="ne-ul"><li id="480bbb9d0e672da3fff6452dc69aa3d9"><span class="ne-text">函数模板</span></li><li id="5141ab7cf02123b3972b56e8f0e66a60"><span class="ne-text">类模板<br /></span><span class="ne-text">STL概述当中，vector容器，顺序容器：向量vector、列表list、双端队列deque</span></li></ul><div class="ne-quote"><p id="045a23a63cadcd0ebdadacb2876753f8" class="ne-p"><a href="https://www.cnblogs.com/mr-wid/archive/2013/01/22/2871105.html" data-href="https://www.cnblogs.com/mr-wid/archive/2013/01/22/2871105.html" target="_blank" class="ne-link"><span class="ne-text">https://www.cnblogs.com/mr-wid/archive/2013/01/22/2871105.html</span></a></p></div><h2 id="fPtfg"><span class="ne-text" style="color: #444444">C之#define</span></h2><p id="44548c1b7c301856ed5c6bc5d432b6b9" class="ne-p"><span class="ne-text" style="color: #444444; font-size: 14px">C语言中，可以用 #define 定义一个标识符来表示一个常量。其特点是：</span><span class="ne-text" style="color: #B22222; font-size: 14px">定义的标识符不占内存，只是一个临时的符号，预编译后这个符号就不存在了</span><span class="ne-text" style="color: #444444; font-size: 14px">。</span></p><p id="8672ef02e17ec401a068b87b74583dbe" class="ne-p"><br></p><p id="90beba95a8af2036675861d6042c4a28" class="ne-p"><span class="ne-text" style="color: #008000; font-size: 14px">预编译</span><span class="ne-text" style="color: #444444; font-size: 14px">又叫</span><span class="ne-text" style="color: #008000; font-size: 14px">预处理</span><span class="ne-text" style="color: #444444; font-size: 14px">。</span><span class="ne-text" style="color: #B22222; font-size: 14px">预编译不是编译，而是编译前的处理。这个操作是在正式编译之前由系统自动完成的。</span></p><ul class="ne-ul"><li id="50151bba3e3b7def1aa641331a065930"><a href="http://c.biancheng.net/view/187.html" data-href="http://c.biancheng.net/view/187.html" target="_blank" class="ne-link"><span class="ne-text">http://c.biancheng.net/view/187.html</span></a></li></ul><p id="5ca2028ad68d7599f6b9e73030d22730" class="ne-p"><br></p><ul class="ne-ul"><li id="58a5d293ab2f35f06261d38697641ca1"><span class="ne-text">const定义常量</span></li><li id="c49f64a50e65bbf680fb29eb9007cfaf"><span class="ne-text">之前C语言里面用的是宏定义#define Π 3.1415927，但是宏定义有时候太“死板”</span></li></ul><h2 id="2zw9a"><span class="ne-text">C++头文件</span></h2><div data-type="info" class="ne-alert"><ul class="ne-ul"><li id="ffe7efa9366c2f1984c0427e0c5159ec"><span class="ne-text">C语言中的头文件以.h后缀，C++中头文件不加后缀。</span></li><li id="aeee0c5f08d489c840abf1edb39310f8"><span class="ne-text">C语言中的string.h头文件，C++用cstring，</span></li><li id="f03ff47e40cd02c6988e9d01fe22813e"><span class="ne-text">C语言中的math头文件，C++使用cmath头文件</span></li></ul><p id="6f073a6314cc15cc46bcc13d83f6c681" class="ne-p"><br></p><p id="41000e3a824319b4af8ac0d2ee874693" class="ne-p"><span class="ne-text">这不只是形式上的改变，其实现也有所不同。</span></p></div><p id="a492ba3ec1f53ba2958a9fdca18b2cbb" class="ne-p"><br></p><h3 id="0WKhV"><span class="ne-text">using namespace std;</span></h3><p id="5aec11683d87524d1ca84b43a9aa3654" class="ne-p"><span class="ne-text">C++标准库中所有标识符并定义于一个名为std的命名空间中，std称为标准命名空间（standard，标准的）。</span></p><h3 id="ZtzRE"><span class="ne-text">iostream</span></h3><p id="270a58b0ccaea3d56696f7850a5ed9f4" class="ne-p"><span class="ne-text">C++中的输入、输出头文件iostream</span></p><p id="b22abc89ae022a3e7e8d5d095f093673" class="ne-p"><span class="ne-text">i ——input 输入</span></p><p id="10c87288b0d974618b0399bfebb0a383" class="ne-p"><span class="ne-text">o ——output 输出</span></p><p id="56c5514adbd9844f99d3547e378f20d3" class="ne-p"><span class="ne-text">stream —— 流</span></p><h3 id="2csm2"><span class="ne-text">iomanip</span></h3><table id="EsEEx" class="ne-table" style="width: 610px"><tbody><tr style="height: 33px"><td width="220"><p id="88a99ea41343b05ed265c393dd388bbd" class="ne-p" style="text-align: center"><span class="ne-text">操作符</span></p></td><td width="390"><p id="98181e6d96315c945283697d3f049619" class="ne-p" style="text-align: center"><span class="ne-text">功能</span></p></td></tr><tr style="height: 45px"><td width="220"><p id="822844c83fba1f8e176ce5add4631295" class="ne-p" style="text-align: center"><span class="ne-text">setfill(char   c)</span></p></td><td width="390"><p id="f2875fcf32508579d7a583bfb6374728" class="ne-p" style="text-align: justify"><span class="ne-text" style="color: black; font-size: 22px">设置以</span><span class="ne-text" style="color: black; font-size: 22px">c</span><span class="ne-text" style="color: black; font-size: 22px">表示的填充字符</span></p></td></tr><tr style="height: 45px"><td width="220"><p id="d79aeda26d1f86fb6c3814b5949d4b3b" class="ne-p" style="text-align: center"><span class="ne-text">setprecision(int n)</span></p></td><td width="390"><p id="1e7609e62fa9c25c6cb791722f7dab7e" class="ne-p" style="text-align: justify"><span class="ne-text" style="color: black; font-size: 22px">设置以</span><span class="ne-text" style="color: black; font-size: 22px">n</span><span class="ne-text" style="color: black; font-size: 22px">表示的数值精度</span></p></td></tr><tr style="height: 33px"><td width="220"><p id="7ac89c1b0ef6160dde3bcad59f275b8d" class="ne-p" style="text-align: center"><span class="ne-text">setw(int n)</span></p></td><td width="390"><p id="48bbe218aa41d923e8387daa215cd690" class="ne-p" style="text-align: justify"><span class="ne-text" style="color: black; font-size: 22px">设置以n表示的域宽</span></p></td></tr></tbody></table><pre><code>#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &lt;cmath&gt;using namespace std;<p>int main()&#123;<br>    double num=sqrt(3.0);<br>    for (int i = 0; i &lt; 6; i++)&#123;<br>        cout &lt;&lt;&quot;当精度为&quot;&lt;&lt;i&lt;&lt;&quot;时：&quot;&lt;&lt;setprecision(i)&lt;&lt;num&lt;&lt;endl;//设置不同的精度<br>    &#125;<br>    cout &lt;&lt; &quot;当前cout精度为：&quot; &lt;&lt;cout.precision() &lt;&lt; endl;<br>    cout &lt;&lt; &quot;当前域宽：&quot; &lt;&lt;cout.width() &lt;&lt; endl;<br>    cout &lt;&lt; &quot;==================================&quot;<br>        &lt;&lt; &quot;\n&quot;;<br>    cout &lt;&lt;setw(7)&lt;&lt;num &lt;&lt; endl; //默认是右对齐<br>    cout &lt;&lt; &quot;当前填充字符：&quot; &lt;&lt; endl;<br>    cout&lt;&lt;setfill(‘*’) &lt;&lt;setw(10)&lt;&lt;num &lt;&lt; endl; //setfill()函数可以直接插入流中<br>    return 0;<br>&#125;</p><p></code></pre></p><p id="67712d42bd5edc22fb79c6b7a14e9df7" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1621218267138-b3d7bcad-1567-4448-9839-e339c6bcb922.png" width="360" id="YmhV9" class="ne-image"></p><ul class="ne-ul"><li id="8328b5e1fc7b88dc61cc5bd8a7b6efed"><span class="ne-text">参考：</span><a href="https://blog.csdn.net/akof1314/article/details/4625888" data-href="https://blog.csdn.net/akof1314/article/details/4625888" target="_blank" class="ne-link"><span class="ne-text">https://blog.csdn.net/akof1314/article/details/4625888</span></a></li></ul><h3 id="eFy46"><span class="ne-text">✨bits/stdc++.h</span></h3><ul class="ne-ul"><li id="e82fbd3af961e04838d2e69e25bbc4ce"><span class="ne-text">万能头文件：几乎包含所有的可用到的C++库函数</span></li><li id="ba26eb4c224023f214cb902ccfa6692f"><span class="ne-text">缺点</span></li></ul><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="1fd81b33caa328693545ed0043882bb5"><span class="ne-text">编译时间慢，具有不可移植的问题，很多编译器和oj不支持，虽然现在noip支持了...</span></li><li id="2fee56dfc1ba16f6da3995e1cdb6e46b"><span class="ne-text">如果你用了bits/stdc++.h，那么你很大几率就会用using namespace std;而不是using std::cin; using std::cout;这样的。这会导致你的某些变量或函数已经被包含了而你不知道（关键字作为函数名）</span></li><li id="6db837e628d81110557f347fc4d592fe"><span class="ne-text">还有很重要的一点，就是用bits很占内存，某些卡内存的题根本用不了</span></li></ul></ul><ul class="ne-ul"><li id="89835c59e2e985c3b932fb27dd95a34f"><span class="ne-text">具体头文件内容</span></li></ul><pre><code>// C++ includes used for precompiling -*- C++ -*- <p>// Copyright (C) 2003-2013 Free Software Foundation, Inc.<br>//<br>// This file is part of the GNU ISO C++ Library.  This library is free<br>// software; you can redistribute it and/or modify it under the<br>// terms of the GNU General Public License as published by the<br>// Free Software Foundation; either version 3, or (at your option)<br>// any later version.</p><p>// This library is distributed in the hope that it will be useful,<br>// but WITHOUT ANY WARRANTY; without even the implied warranty of<br>// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the<br>// GNU General Public License for more details.</p><p>// Under Section 7 of GPL version 3, you are granted additional<br>// permissions described in the GCC Runtime Library Exception, version<br>// 3.1, as published by the Free Software Foundation.</p><p>// You should have received a copy of the GNU General Public License and<br>// a copy of the GCC Runtime Library Exception along with this program;<br>// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see<br>// &lt;Licenses - GNU Project - Free Software Foundation&gt;.</p><p>/** @file stdc++.h</p><ul><li> This is an implementation file for a precompiled header.</li><li>/</li></ul><p>// 17.4.1.2 Headers</p><p>// C<br>#ifndef _GLIBCXX_NO_ASSERT<br>#include &lt;cassert&gt;<br>#endif<br>#include &lt;cctype&gt;<br>#include &lt;cerrno&gt;<br>#include &lt;cfloat&gt;<br>#include &lt;ciso646&gt;<br>#include &lt;climits&gt;<br>#include &lt;clocale&gt;<br>#include &lt;cmath&gt;<br>#include &lt;csetjmp&gt;<br>#include &lt;csignal&gt;<br>#include &lt;cstdarg&gt;<br>#include &lt;cstddef&gt;<br>#include &lt;cstdio&gt;<br>#include &lt;cstdlib&gt;<br>#include &lt;cstring&gt;<br>#include &lt;ctime&gt;</p><p>#if __cplusplus &gt;= 201103L<br>#include &lt;ccomplex&gt;<br>#include &lt;cfenv&gt;<br>#include &lt;cinttypes&gt;<br>#include &lt;cstdalign&gt;<br>#include &lt;cstdbool&gt;<br>#include &lt;cstdint&gt;<br>#include &lt;ctgmath&gt;<br>#include &lt;cwchar&gt;<br>#include &lt;cwctype&gt;<br>#endif</p><p>// C++<br>#include &lt;algorithm&gt;<br>#include &lt;bitset&gt;<br>#include &lt;complex&gt;<br>#include &lt;deque&gt;<br>#include &lt;exception&gt;<br>#include &lt;fstream&gt;<br>#include &lt;functional&gt;<br>#include &lt;iomanip&gt;<br>#include &lt;ios&gt;<br>#include &lt;iosfwd&gt;<br>#include &lt;iostream&gt;<br>#include &lt;istream&gt;<br>#include &lt;iterator&gt;<br>#include &lt;limits&gt;<br>#include &lt;list&gt;<br>#include &lt;locale&gt;<br>#include &lt;map&gt;<br>#include &lt;memory&gt;<br>#include &lt;new&gt;<br>#include &lt;numeric&gt;<br>#include &lt;ostream&gt;<br>#include &lt;queue&gt;<br>#include &lt;set&gt;<br>#include &lt;sstream&gt;<br>#include &lt;stack&gt;<br>#include &lt;stdexcept&gt;<br>#include &lt;streambuf&gt;<br>#include &lt;string&gt;<br>#include &lt;typeinfo&gt;<br>#include &lt;utility&gt;<br>#include &lt;valarray&gt;<br>#include &lt;vector&gt;</p><p>#if __cplusplus &gt;= 201103L<br>#include &lt;array&gt;<br>#include &lt;atomic&gt;<br>#include &lt;chrono&gt;<br>#include &lt;condition_variable&gt;<br>#include &lt;forward_list&gt;<br>#include &lt;future&gt;<br>#include &lt;initializer_list&gt;<br>#include &lt;mutex&gt;<br>#include &lt;random&gt;<br>#include &lt;ratio&gt;<br>#include &lt;regex&gt;<br>#include &lt;scoped_allocator&gt;<br>#include &lt;system_error&gt;<br>#include &lt;thread&gt;<br>#include &lt;tuple&gt;<br>#include &lt;typeindex&gt;<br>#include &lt;type_traits&gt;<br>#include &lt;unordered_map&gt;<br>#include &lt;unordered_set&gt;<br>#endif<br></code></pre></p><p id="97f8165b5a3956ac5048e81fae71667e" class="ne-p"><span class="ne-text">C++</span></p><h2 id="ReJeb"><span class="ne-text">【大一C和C++笔记】</span></h2><p id="7af6b9c1c75c2f66a7f719ecc18f8851" class="ne-p"><br></p><div data-type="info" class="ne-alert"><p id="ef60fdfa17ed709a6e549c2c96c94e9c" class="ne-p"><span class="ne-text">当时在OneNote的一些小记</span></p></div><p id="68ada53a1f93f1298e075a75dcf5fba2" class="ne-p"><br></p><h3 id="GscrZ"><span class="ne-text">C常用字符函数</span></h3><p id="64b64d2ad079fdda80fbd32b3afc1a36" class="ne-p"><span class="ne-text"> </span></p><p id="a382b6b642296befa9c1264f9ede5215" class="ne-p"><span class="ne-text">Printf()</span></p><p id="98bf251bc1a674355131abe6c7da3d9f" class="ne-p"><span class="ne-text">Scanf()</span></p><p id="62137e0e25bab3b229d15dc562b7ac3f" class="ne-p"><span class="ne-text">Putchar()</span></p><p id="c32b42f41eb04686673a8fd27b305bee" class="ne-p"><span class="ne-text">Getchar()</span></p><p id="9c9c5df76124ca7e35f177aea8371baa" class="ne-p"><span class="ne-text">Puts(str)</span></p><p id="c5b494286fab05e744caf7a590efeeca" class="ne-p"><span class="ne-text">Gets(str)</span></p><p id="ddf6c274761b268a5c519ed7ef2af13c" class="ne-p"><span class="ne-text">Strcat(str1,str2)：连接字符串</span></p><p id="77ff234766fbce470f781f2f7774cf1a" class="ne-p"><span class="ne-text">复制函数：将str2复制给str1</span></p><p id="e59ce8a742f3dc555ba72530acdeb7a7" class="ne-p"><span class="ne-text">Strcpy(str1,str2)</span></p><p id="fdb30d360356c9d39841847625c02440" class="ne-p"><span class="ne-text">在C++里面会报错</span></p><p id="c1d35b02ad624a80d7b48f8c4faf788b" class="ne-p"><span class="ne-text">    解决①：将函数strcpy改成strcpy_s,中间加一个参数——复制的长度</span></p><p id="39296429b8ccb2e5ff1adb53b20140d0" class="ne-p"><span class="ne-text"> </span></p><p id="26cfdcccf0ef06b007e77c04f42f920f" class="ne-p"><span class="ne-text">Strncpy(str1,str2,n)：复制函数，将str2的前n个字符复制给str1</span></p><p id="d5664de620ffb55fb34279dfeaf211f4" class="ne-p"><span class="ne-text">Strlen(str)：检测str的字符串长度</span></p><p id="74a4c95fe38644ceea308bcb605e39e2" class="ne-p"><span class="ne-text">Fopen(文件名，使用文件方式）</span></p><p id="686241d18ae7ddb6fc86c2d416ba68cc" class="ne-p"><span class="ne-text">fclose（文件指针）</span></p><p id="edd61a04a35dbdf495fa8081d42d2a87" class="ne-p"><br></p><h3 id="w0KlJ"><span class="ne-text">I/O改进</span></h3><ul class="ne-ul"><li id="d4628833a4b1679e371aae2c6c691c2c"><span class="ne-text">scanf===cin&gt;&gt; &gt;&gt;endl;</span></li><li id="da66da384035e3b7a2bdedd863c64f8d"><span class="ne-text">Print===cout&lt;&lt; &lt;&lt;endl;</span></li><li id="f7d7d68b88fcc4dd294978c4a3cff970"><span class="ne-text">换行符：endl 和 &quot;\n&quot;</span></li></ul><h3 id="kGoPT"><span class="ne-text">类和对象</span></h3><p id="589170fc5e5cd9631945f12a37e4b88d" class="ne-p"><span class="ne-text">类的形式？</span></p><p id="af80291bb23e82186f8df0b5152dd3db" class="ne-p"><span class="ne-text">Class wuzutao</span></p><p id="561e36aea521749971c338abca67a2e9" class="ne-p"><span class="ne-text">{</span></p><p id="db82741fde0d8b439118d4405f7d63e1" class="ne-p"><span class="ne-text">private：</span></p><p id="2ecc49d85d163094dc1d8f7e8d1d5867" class="ne-p"><br></p><pre><code>    public：    <pre><code>protect：</code></pre><p>}；<br>数据成员<br>成员函数：<br>    类内实现=和普通函数的实现一样<br>    类外实现=void Date：：Display（）{}<br></code></pre></p><p id="3bc5b604a54f0c74362259ac49694d25" class="ne-p"><br></p><p id="656b0a5e2a1b09887053d66151c4ac78" class="ne-p"><span class="ne-text">类定义对象？</span></p><p id="3e8c35312172b97afc005b2258c557ac" class="ne-p"><span class="ne-text">①花括号内定义</span></p><p id="8aeb26b926cb5ea068a108dd7602e1c2" class="ne-p"><span class="ne-text">②花括号外定义</span></p><p id="d26f136ae749f77977878223a4c2027b" class="ne-p"><br></p><p id="1406e91a94b5aff767e691c26d99f36b" class="ne-p"><span class="ne-text">访问对象？</span></p><p id="9a0e900cc7e9a6c2632bbbe8a0176458" class="ne-p"><span class="ne-text">访问的是类内的成员</span></p><p id="e5704bfc4d5f5629e17635a59d4dbb7e" class="ne-p"><span class="ne-text">①圆点访问形式</span></p><p id="70c128f1088632fa45f657b30e379205" class="ne-p"><span class="ne-text">②指针访问形式</span></p><p id="821877274380e995d387ff010703f52c" class="ne-p"><br></p><p id="f22aace15a5b40bcb79405dda1ec77da" class="ne-p"><span class="ne-text">this指针？</span></p><p id="84a6bb1cd76344b395b8372e4a74d3f8" class="ne-p"><span class="ne-text">每个成员函数都会有一个特殊的隐含指针——this指针。</span></p><p id="484b6a7a9cb0bcbd331e006d8317156b" class="ne-p"><span class="ne-text">调用形式：cout&lt;&lt;this&lt;year&lt;day&lt;&lt;endl;</span></p><p id="10bfe802c7e6f51e7c02770a94f252a8" class="ne-p"><br></p><p id="48698c70dc5a5dff498e841253c22d84" class="ne-p"><strong><span class="ne-text">构造函数和析构函数</span></strong></p><p id="1e4f386c85cbfba45aeef0dfda743097" class="ne-p"><span class="ne-text">构造函数的作用就是适当地给类进行初始化的作用</span></p><p id="52fda6fe5b8046f18be9fbbb2b2cf89a" class="ne-p"><span class="ne-text">无参数的构造函数</span></p><p id="142ff04b6b77ad986130d7ff9c664524" class="ne-p"><span class="ne-text">带参数的构造函数</span></p><p id="944bdca6c2fb088e7066ed79d4cbfbe0" class="ne-p"><span class="ne-text"> </span></p><p id="914a175212b6158656849bb369b0d38a" class="ne-p"><span class="ne-text">拷贝构造函数，这里不是太懂！</span></p><p id="4987984bd65d13beb8a21d2c3c085973" class="ne-p"><span class="ne-text">拷贝构造函数声明</span></p><p id="d00a70e20cfbdf04c9ad64710d4c229a" class="ne-p"><span class="ne-text">拷贝构造函数定义和实现</span></p><p id="8c19e813b7e8f71dd27a8f010de2e4b1" class="ne-p"><span class="ne-text"> </span></p><p id="24ba2cc1833a8e12607e3c6923524f69" class="ne-p"><span class="ne-text">析构函数</span></p><p id="5baf7a64503989bda36307a1e47c0688" class="ne-p"><span class="ne-text">一般默认，如果自己写的话就是</span></p><p id="2c589c6bbe11028c7a236f53ceeb066c" class="ne-p"><span class="ne-text" style="text-decoration: underline">析构函数的声明：</span></p><p id="cf73c55c41048022280c9cb139e25cbc" class="ne-p"><span class="ne-text">~</span><span class="ne-text">类名（）；</span></p><p id="d8f58369c6fcbb19b572067dba806308" class="ne-p"><span class="ne-text" style="text-decoration: underline">析构函数的定义和实现：</span></p><p id="a810f2a26e898e9ba5043568cc195072" class="ne-p"><span class="ne-text">类名：：</span><span class="ne-text">~</span><span class="ne-text">类名（）</span><span class="ne-text">{</span><span class="ne-text">……</span><span class="ne-text">}</span></p><p id="8e1e71fb9355fe249e323c499bd0b134" class="ne-p"><span class="ne-text"></span></p><h3 id="KcS3M"><span class="ne-text">数据的共享和保护</span></h3><p id="5d9778e68bc61c3fce43a85f4e3858d8" class="ne-p"><strong><span class="ne-text">数据共享static</span></strong></p><ol class="ne-ol"><li id="a0aac2ce035f89879774a2b81910298a"><span class="ne-text">静态数据成员<br /></span><span class="ne-text">声明：static 数据类型 静态数据成员名；<br /></span><span class="ne-text">初始化在类结束和类中函数实现的中间<br /></span><span class="ne-text">之后访问（通过类名/对象名来访问）：<br /></span><span class="ne-text">私有的静态成员只能通过间接的方式来访问===静态成员函数<br /></span><span class="ne-text">对象名.公有静态成员变量名<br /></span><span class="ne-text">对象名::公有静态成员变量名</span></li><li id="cc703b49f1efe178f9363a0e5a5aaea2"><span class="ne-text">静态成员函数<br /></span><span class="ne-text">没有this指针<br /></span><span class="ne-text">声明：static 返回值类型 静态成员函数名（形参表）<br /></span><span class="ne-text">之后访问（通过类名/对象名来访问）：<br /></span><span class="ne-text">类名::静态成员函数名（实参表）<br /></span><span class="ne-text">类名.静态成员函数名（实参表）</span></li></ol><p id="ab1ab0d853067d4d1868eb25c62f1613" class="ne-p"><strong><span class="ne-text">数据保护const</span></strong></p><ol class="ne-ol"><li id="7e1e8ba2ba362ee483ba134992f22b71"><span class="ne-text">常数据成员<br /></span><span class="ne-text">有些时候，希望不用全局变量，因为这样不好移植，所以用到const场数据类型，相当于每次用不同场合用到这个类，都是这些用到这些固定的数据<br /></span><span class="ne-text">一般结合static来避免数据赘余<br /></span><span class="ne-text">eg：类Circle中<br /></span><span class="ne-text">定义：const double PI；<br /></span><span class="ne-text">初始化只能在构造函数后面的初始化列表中：Circle （double r=0）：PI（3.1415926）</span></li></ol><ol class="ne-list-wrap"><ol ne-level="1" class="ne-ol"><li id="16efbf2301904d3ab7a2947dd492209e"><span class="ne-text">常成员函数<br /></span><span class="ne-text">只访问类中的数据而不修改类中的数据成员，最好用到常成员函数<br /></span><span class="ne-text">eg：只访问类中的半径<br /></span><span class="ne-text">声明：Double GetRadius（）const；<br /></span><span class="ne-text">实现：double Circle：：GetRadius（）const{……}</span></li><li id="9edebba565af7a4ecd14de8c277f560b"><span class="ne-text">常对象<br /></span><span class="ne-text">所定义的常对象p1在之后就不会被改变了<br /></span><span class="ne-text">形式：const Person p1（17，“wu”）；</span></li></ol></ol><p id="77fa8a497ceee03a9c8ba16faa2a631c" class="ne-p" style="margin-left: 2em"><br></p><p id="96d4968e4f7fce6503427244f879f0d7" class="ne-p" style="margin-left: 2em"><br></p><h3 id="IcXSd"><span class="ne-text">类和类之间的关系</span></h3><p id="98e2d89fb19f51515d4d26734163d309" class="ne-p"><strong><span class="ne-text">类的组合</span></strong></p><p id="786c1cd5601038ccad92ee21ea056907" class="ne-p"><span class="ne-text">直观：</span><span class="ne-text">B</span><span class="ne-text">类中有</span><span class="ne-text">A</span><span class="ne-text">类定义的对象</span></p><p id="e798f3d873f80f3df1b8a252b0c2fbb4" class="ne-p"><span class="ne-text"> </span></p><p id="810a7518fb82c99cb4fe4f35ca35fdce" class="ne-p"><span class="ne-text">构造函数的顺序：</span></p><p id="eb51d1f203ce1efe4307151fe78efe76" class="ne-p"><span class="ne-text">对象成员的构造函数</span></p><p id="74d3a419ca2730249beed48442b0cd32" class="ne-p"><span class="ne-text">自身的构造函数</span></p><p id="9c9b3a40442a376cdc11af1550166469" class="ne-p"><span class="ne-text"> </span></p><p id="c22d51a1ed297f4a7b2682fca7814c84" class="ne-p"><span class="ne-text">构造函数有参数的时候：</span></p><p id="98fa9d7e9410489a0e437c0d02743791" class="ne-p"><span class="ne-text">怎么个表现形式呢？</span></p><p id="0349e66e3e90afb809979b11ffeb3fc3" class="ne-p"><strong><span class="ne-text">B</span></strong><strong><span class="ne-text">类中</span></strong><strong><span class="ne-text">B</span></strong><strong><span class="ne-text">的构造函数后面带有</span></strong><strong><span class="ne-text">A</span></strong><strong><span class="ne-text">类在</span></strong><strong><span class="ne-text">B</span></strong><strong><span class="ne-text">类中所定义的对象</span></strong><strong><span class="ne-text">，这个对象的参数用做左边</span></strong><strong><span class="ne-text">B</span></strong><strong><span class="ne-text">类构造函数的参数、</span></strong></p><p id="5b0ac855ff20990756e091cd54e2ab80" class="ne-p"><br></p><p id="35114f94260a19065dacde4c0bd36d2b" class="ne-p"><strong><span class="ne-text" style="color: #F5222D">类的依赖</span></strong></p><p id="2120cdba3907f458b2be589a6a28b0f8" class="ne-p"><span class="ne-text">赌徒和骰子，这就是一种依赖关系，如果用组合关系的话，就会影响到生命周期问题</span></p><p id="3ad63c77c1f535e1e895afbe7fa5f53b" class="ne-p"><span class="ne-text"> </span></p><p id="b0d2528755215f90af93003525b9ae24" class="ne-p"><span class="ne-text">Class </span><span class="ne-text">🎲</span><span class="ne-text">{}</span><span class="ne-text">；</span></p><p id="45736a566870db39d0b2f388773f5ebc" class="ne-p"><span class="ne-text">Class </span><span class="ne-text">🕵️‍♂️</span></p><p id="60de9abc3576b20020434de45c18dd26" class="ne-p"><span class="ne-text">{</span></p><p id="6e4d277170e48e9a7d3fd6791870a4c6" class="ne-p"><span class="ne-text">public</span><span class="ne-text">：</span></p><p id="8207342bb80b58fcc89574dab05fe8b3" class="ne-p"><span class="ne-text">Void play</span><span class="ne-text">（</span><span class="ne-text">🎲</span><span class="ne-text">1</span><span class="ne-text">，</span><span class="ne-text">🎲</span><span class="ne-text">2</span><span class="ne-text">，</span><span class="ne-text">🎲</span><span class="ne-text">3</span><span class="ne-text">）</span></p><p id="ef5452fed63dc615964d2df2dc931e33" class="ne-p"><span class="ne-text">{</span><span class="ne-text">……</span><span class="ne-text">}</span></p><p id="01f5cf56b9805a1a6ace3d918a2e307b" class="ne-p"><span class="ne-text">}</span><span class="ne-text">；</span></p><p id="5b11ad7340a9de6e18ed9974cdf940e2" class="ne-p"><strong><span class="ne-text" style="color: #F5222D">类的继承和派生</span></strong></p><p id="98ac0f5108d1a6221ffc86822f21336e" class="ne-p"><span class="ne-text">一、派生类的定义：</span></p><p id="384b69dd62e3dec7a4d75b8a78bd89db" class="ne-p"><span class="ne-text">父类</span><span class="ne-text">class Base{}</span></p><p id="4c3c3deedeec76bd438a7339821003f6" class="ne-p"><span class="ne-text">派生子类：单一继承</span><span class="ne-text">class Derived</span><span class="ne-text">：</span><span class="ne-text">public Base{}</span><span class="ne-text">；</span></p><p id="3b3e896a3854b0463e93b0379323af6b" class="ne-p"><span class="ne-text">多重继承</span><span class="ne-text">Class Derived</span><span class="ne-text">：</span><span class="ne-text">public Base1</span><span class="ne-text">，</span><span class="ne-text">pretect Base2{}</span><span class="ne-text">；</span></p><p id="cddaa48af29d232be3e2539249edca8b" class="ne-p"><span class="ne-text">继承的类型：</span></p><p id="cb07b91742f05b2d9a390a2acda093b2" class="ne-p"><span class="ne-text">单一继承：只有一个基类</span></p><p id="be57b54cb87cc33e58e885376f5c98eb" class="ne-p"><span class="ne-text">多重继承：有多个基类</span></p><p id="4df0ab886a06ba25553f120a41a1f6a0" class="ne-p"><span class="ne-text"> </span></p><p id="d83f7578f73bc0fa78a4abe4059bc55c" class="ne-p"><span class="ne-text">继承方式：</span></p><p id="fcce92249b7460260ee1dc8f5ea1d618" class="ne-p"><span class="ne-text">private</span><span class="ne-text">继承：所有的数据成员都为子类的的私有成员</span></p><p id="283441ba5cdb5555dae73b5130db3cf9" class="ne-p"><span class="ne-text">public</span><span class="ne-text">继承：父类的数据类型怎样，在子类类型不变</span></p><p id="ebd29994eda1c8fb5fc84668678babc5" class="ne-p"><span class="ne-text">protect</span><span class="ne-text">继承：所有的数据成员和成员函数都为字类的保护成员</span></p><p id="24f217697f287063ba79860299650ce6" class="ne-p"><span class="ne-text">ps</span><span class="ne-text">：①父类的</span><span class="ne-text">private</span><span class="ne-text">数据成员和成员函数不能被子类所继承</span></p><p id="bdc3648f0724694c3016cee7b8fd96cf" class="ne-p"><span class="ne-text">②一般很少用</span><span class="ne-text">protect</span><span class="ne-text">和</span><span class="ne-text">private</span><span class="ne-text">两种继承，因为两种改变了之前基类的访问属性，限制了这些的进一步派生，所以很少使用</span></p><p id="deb43f5da363790a96f3ed9e0c9073cf" class="ne-p"><span class="ne-text"> </span></p><p id="1dcfd9ee92488af32d16befb423d4360" class="ne-p"><span class="ne-text">二、派生类的构造和析构</span></p><p id="ae12bca60ea6731d45a1e79bf654c01a" class="ne-p"><span class="ne-text">构造和析构的调用顺序：</span></p><p id="592215823025cde0bc1e00d9dfe1f318" class="ne-p"><span class="ne-text">①所有虚基类的构造函数</span></p><p id="36cafbfc8fd89185a82efd335cbd8a55" class="ne-p"><span class="ne-text">②基类的构造函数</span></p><p id="51f264f053728bcb1fc048251935c564" class="ne-p"><span class="ne-text">③对象成员的构造函数</span></p><p id="2497479d3300cee2d1875c50c7b6ce9a" class="ne-p"><span class="ne-text">④自身派生类的构造函数</span></p><p id="da494451850f90cbc9168a4a21cee947" class="ne-p"><span class="ne-text">ps</span><span class="ne-text">：析构函数的调用顺序则正好相反、</span></p><p id="f79cb136e1b42eb5d6d091eb8c9d4315" class="ne-p"><span class="ne-text">虚基类保证调用一次构造函数。两个子类都有同一个基类的虚基类继承，构造函数只调用一次</span></p><p id="32b1e6b8317cd019ef219f86f0d4ab48" class="ne-p"><span class="ne-text">带参数的构造函数：</span></p><p id="6e1dd6b5fc891c2b352302c7fa9ac2a5" class="ne-p"><span class="ne-text">子类里面，构造函数的初始化要连带着基类的构造函数的初始化</span></p><p id="b2eee0eb655fe153e93c7479910100eb" class="ne-p"><span class="ne-text">eg</span><span class="ne-text">：</span><span class="ne-text">classA(int a,int b,int c):classB(a*2),classC(a,b){}</span></p><p id="0c7c8bd48fc4cd2e1e11b690e7eefe65" class="ne-p"><span class="ne-text"> </span></p><p id="3197ab6ab1ce831cb094780d874c4b52" class="ne-p"><span class="ne-text">三、同名冲突和解决方案</span></p><p id="1c77a501b36888b67586ca075f329ca5" class="ne-p"><span class="ne-text">解决①双冒号法：：</span></p><p id="5aea5f35f2ece42bb6b1621065368194" class="ne-p"><span class="ne-text">基类和子类当中有相同名字的数据成员和成员函数，</span></p><p id="48aac120f4a7006e033b06367ff26bbe" class="ne-p"><span class="ne-text">访问的时候：相同的名字：：数据成员</span><span class="ne-text">/</span><span class="ne-text">成员函数</span></p><p id="1836f06387b659546c48cc89e68a3746" class="ne-p"><span class="ne-text">解决②定义虚基类</span><span class="ne-text">virtual</span></p><p id="f883bfe022e48ba13675efa7184299e4" class="ne-p"><span class="ne-text">eg</span><span class="ne-text">：</span><span class="ne-text">class furniture{}</span><span class="ne-text">；</span></p><p id="90b7cf4bcf3c85dac20dbb1a0373ded7" class="ne-p"><span class="ne-text">Class sofa </span><span class="ne-text">：</span><span class="ne-text">virtual public furniture{}</span><span class="ne-text">；</span></p><p id="a731e7cd0e1fb2c091dbad3843780f3a" class="ne-p"><span class="ne-text">Class bed</span><span class="ne-text">：</span><span class="ne-text">virtual public furniture{}</span><span class="ne-text">；</span></p><p id="b4f2f06c32ffc21d3bf94737451bbcfe" class="ne-p"><span class="ne-text">Class sofabed</span><span class="ne-text">：</span><span class="ne-text">public sofa</span><span class="ne-text">，</span><span class="ne-text">public bed{}</span><span class="ne-text">；</span></p><p id="b462943b523c2abae01625e219b3eff8" class="ne-p"><span class="ne-text"> </span></p><p id="7e03fcbe8dfa104ab6182fbc7f335003" class="ne-p"><span class="ne-text">四、赋值兼容规则</span></p><h3 id="ErDXB"><span class="ne-text">主函数</span></h3><p id="1c4b0382dec30a4caf7a522f1a1a9dbf" class="ne-p"><span class="ne-text">主函数main()是程序的入口，每个程序都需要一个主函数。主函数返回值为int型。</span></p><p id="d80befa739da1067f0c8e41f32a6c81e" class="ne-p"><span class="ne-text">int main()</span></p><p id="6443c7ea6fbb4e429bc64e51cc87fda6" class="ne-p"><span class="ne-text">{</span></p><p id="1056b6a00cb45ba5b5340ea0ea50305d" class="ne-p"><span class="ne-text">    cout&lt;&lt;&quot;hello,world!&quot;&lt;&lt;endl;</span></p><p id="12bb5062573d55001cfdb78fd0a82118" class="ne-p"><span class="ne-text">    return 0;</span></p><p id="b3c87eeb90698c2de59e4d4d0fb8d7d2" class="ne-p"><span class="ne-text">}  </span></p><p id="b7dbb41ea44b1fbda81092556f904f1c" class="ne-p"><span class="ne-text">注意：程序末尾返回0</span></p><h3 id="9Ylus"><span class="ne-text"> </span></h3></div>]]></content>
      
      
      <categories>
          
          <category> 计算机素养 </category>
          
          <category> 后端编程语言 </category>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Git多账号同设备部署总结</title>
      <link href="/blog/uke79e/"/>
      <url>/blog/uke79e/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h2 id="fb67b043"><span class="ne-text">部署多个github+coding等账号</span></h2><p id="84d69f1e9506ec3aa5fd417e7280b2d5" class="ne-p"><br></p><h3 id="32ae35ec"><span class="ne-text">思路</span></h3><p id="ea54fe62ae4f310895f44953314ddfc9" class="ne-p"><br></p><p id="f00605b0827a7fa6d528de3d5f48d498" class="ne-p"><span class="ne-text">好处：一台设备可以使用多个github账号/github+coding等等多平台托管/搭建两个静态博客</span></p><p id="20a9696410385bce48d028ae64f074e1" class="ne-p"><br></p><p id="2b87b99c0eb3f3f7ccee0e30d3cdc9d4" class="ne-p"><span class="ne-text">取消全局用户配置（每建立一个新文件夹，需要输入使用账号），建立多个ssh密匙（如果是github账号+coding账号+gitee账号等）</span></p><p id="b50355fbc8094874b3de931c131eb867" class="ne-p"><br></p><p id="73e0219f7080cfc92d3a5d94fed2a8e7" class="ne-p"><span class="ne-text">SSH的公钥是GitHub连接本地仓库和远程仓库的标识，一个公钥只能对应一个GitHub账户，一个相同的公钥不能上传到不同的GitHub账户</span></p><p id="41d2e17aa725384e76d2cb8a97a7587a" class="ne-p"><br></p><p id="57ed1f1388860025c6e03c2bc20ef84a" class="ne-p"><span class="ne-text">一台电脑，可以生成多对公私钥，可以通过配置，将不同的公钥上传到不同的GitHub账号，那么就不存在单个公钥绑定多个GitHub账号的情况存在了</span></p><p id="0533e1fbc3a1087484bc097c7e81934b" class="ne-p"><br></p><h3 id="5e2376c3"><span class="ne-text">多密匙生成</span></h3><p id="5d3ba53379e2115d3885f3461473430f" class="ne-p"><br></p><ul class="ne-ul"><li id="de478b027839c255ebd57dac23f193b9"><span class="ne-text">先进来该文件夹（忽略图片上写的字）<br /></span><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1597632490897-11718be6-6492-4ead-a739-1c92af25c648.png" width="1215" id="rIi3X" class="ne-image"></li><li id="7c00259532719c7626e599e775371f89"><span class="ne-text">创建新密匙方法一（首选）</span></li></ul><p id="72972c835a3b78baa4997a661fc37cc4" class="ne-p"><br></p><p id="1a8ff91c68644220d8c1fb7aa8232ab6" class="ne-p"><code class="ne-code"><span class="ne-text">ssh-keygen -t rsa -f ~/.ssh/这里是新密钥名称 -C &quot;这里是你的邮箱&quot;</span></code></p><p id="52eeef5cacb242ce628692008823aa25" class="ne-p"><br></p><p id="327dab9a078fe3d4837d878282f7b2b1" class="ne-p"><span class="ne-text">注意区别新密钥名称和旧密钥名称，不要相同！！</span></p><p id="07c6e9952cf15c610ae5cb0643f05dd1" class="ne-p"><br></p><ul class="ne-ul"><li id="fab83884386f42d4fb6b6791891d094f"><span class="ne-text">创建新密匙方法二</span></li></ul><p id="783c24a3fedecb77a77d77319149391c" class="ne-p"><br></p><p id="32dff8ccf55fa662a985843411d41939" class="ne-p"><span class="ne-text">输入这个：</span><code class="ne-code"><span class="ne-text">ssh-keygen -t rsa -C &quot;这里是你的邮箱&quot;</span></code></p><p id="bd472c715d8f127ae71ec1e975e57182" class="ne-p"><br></p><p id="a42e4c437e250fb58ce9123a8b49587d" class="ne-p"><span class="ne-text">出现这两句：</span></p><p id="971f78fef5df65240f73006aebacef94" class="ne-p"><code class="ne-code"><span class="ne-text">Generating public/private rsa key pair.</span></code></p><p id="907ed5e1ce0f826d6843019c5259515c" class="ne-p"><br></p><p id="6ce0e867e6b2d3328477a30ec64cab8b" class="ne-p"><code class="ne-code"><span class="ne-text">Enter file in which to save the key (/c/Users/you/.ssh/id_rsa):</span></code></p><p id="1c4d06d8209229a284a1ea83572ad902" class="ne-p"><br></p><p id="3938c8db081599069efae73cd4dd03f0" class="ne-p"><span class="ne-text">注意此时需要你输入新密钥的名称，同样要注意区别新密钥名称和旧密钥名称，不要相同，之后再两次回车。</span></p><p id="a24b5eafa327a3cd206f3ecc695b44df" class="ne-p"><br></p><h3 id="61cc6367"><span class="ne-text">配置config</span></h3><p id="9dcc3f90dbe792bcf889b166d8b2e8d8" class="ne-p"><br></p><p id="a4d695be592ddb56c680463fcc92074c" class="ne-p"><span class="ne-text">.ssh根文件夹下没有config文件，需要新建</span></p><p id="4e039ab3754bc1b51145b7e0a879c301" class="ne-p"><br></p><ul class="ne-ul"><li id="b0d22308a546867b12830d5ecaec8c04"><span class="ne-text">新建config文件方法一</span></li></ul><p id="3ff7dcebefaf81ca3db1bca10e19b790" class="ne-p"><br></p><p id="0172cf94b63c25ab01df6f140c5eab82" class="ne-p"><span class="ne-text">在.ssh根路径下键入该命令</span><code class="ne-code"><span class="ne-text">touch config</span></code></p><p id="ec3a5c096253adb1b792c4d8c33bc1b4" class="ne-p"><br></p><ul class="ne-ul"><li id="31a00b8f3af45b20b2f7464c64c2a25d"><span class="ne-text">新建config文件方法二</span></li></ul><p id="2cb1606c83fd91cf545d323a4cd85b47" class="ne-p"><br></p><p id="2d42872b2a76ab0f6345702e1013f19a" class="ne-p"><span class="ne-text">记事本新建文件config文件！！没有后缀</span></p><p id="20b8491c87201ed6905f3c1b42af36c3" class="ne-p"><br></p><ul class="ne-ul"><li id="aa0bf1ef802fb89cd7f6d55a8de38337"><span class="ne-text">输入内容</span></li></ul><p id="3b8d69f3aae7d208d4a7ffc7c3c4387a" class="ne-p"><br></p><pre><code>#第一个账号，默认使用的账号，不用做任何更改Host github.com    HostName github.com    User git    IdentityFile ~/.ssh/id_rsa    <p>#第二个新账号，#&quot;xxxxxx&quot;为前缀名，可以任意设置，要记住，后面需要用到<br>Host xxxxxx.github.com<br>    HostName github.com<br>    User git<br>    IdentityFile ~/.ssh/这里是你创建的新密钥的名称<br></code></pre></p><p id="642a0e34c8fb2d86baa9ca6b5f4ff6e7" class="ne-p"><br></p><pre><code># one(one@gmail.com)Host one.github.comHostName github.comPreferredAuthentications publickeyIdentityFile ~/.ssh/id_rsa_oneUser one    <h1 id="two-116-119-x6f-64-103-x6d-x61-105-x6c-x2e-x63-x6f-109"><a href="#two-116-119-x6f-64-103-x6d-x61-105-x6c-x2e-x63-x6f-109" class="headerlink" title="two(&#116;&#119;&#x6f;&#64;&#103;&#x6d;&#x61;&#105;&#x6c;&#x2e;&#x63;&#x6f;&#109;)"></a>two(<a href="mailto:&#116;&#119;&#x6f;&#64;&#103;&#x6d;&#x61;&#105;&#x6c;&#x2e;&#x63;&#x6f;&#109;">&#116;&#119;&#x6f;&#64;&#103;&#x6d;&#x61;&#105;&#x6c;&#x2e;&#x63;&#x6f;&#109;</a>)</h1><p>Host two.github.com<br>HostName github.com<br>PreferredAuthentications publickey<br>IdentityFile ~/.ssh/id_rsa_two<br>User two<br></code></pre></p><p id="4d5784308268a307d6c9a860eaa9be9f" class="ne-p"><br></p><pre><code>Host myhost（这里是自定义的host简称，以后连接远程服务器就可以用命令ssh myhost）HostName 主机名可用ip也可以是域名(如:github.com或者bitbucket.org)Port 服务器open-ssh端口（默认：22,默认时一般不写此行）PreferredAuthentications   配置登录时用什么权限认证--可设为publickey,password publickey,keyboard-interactive等IdentityFile 证书文件路径（如~/.ssh/id_rsa_*)User 登录用户名(如：git)</code></pre><p id="439c4095aebbebb99b1720a4215c1763" class="ne-p"><br></p><p id="f02b6197965358da0100ab69c19a8628" class="ne-p"><span class="ne-text">每个账号单独配置一个Host，每个Host要取一个别名，一般为每个Host主要配置HostName和IdentityFile两个属性，配置完保存即可。</span></p><p id="bb61705f22c20443679af330bf1163b0" class="ne-p"><br></p><p id="7c2809cd6d14752b903d8aa3e99ed63c" class="ne-p"><span class="ne-text">Host的名字可以自定义名字，不过这个会影响git相关命令，例如：Host mygithub 这样定义的话，使用命令git clone git@mygithub:PopFisher/AndroidRotateAnim.git，git@后面紧跟的名字改为mygithub</span></p><p id="cde10c2c6854a82ee860ba6851354407" class="ne-p"><br></p><div class="ne-quote"><p id="19ad9f09b817634a332a87625cb32841" class="ne-p"><strong><span class="ne-text">mine</span></strong></p><p id="cd645c268c2271bb8ffeb91dfafff22f" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1597632490639-fd51b09d-c037-4fdb-bad3-e2e1d56d7aed.png" width="999" id="uEqZT" class="ne-image"></p></div><p id="99bcaa1e5ffd5db28aa259b0706e8e7a" class="ne-p"><br></p><h3 id="530a9d85"><span class="ne-text">部署SSH key</span></h3><p id="888e315bdee9ca333594fff8fa432aff" class="ne-p"><br></p><p id="cdc1b113b91df2c8bcf5868834141c91" class="ne-p"><span class="ne-text">将根文件夹下的</span><code class="ne-code"><span class="ne-text">wztlink1013.pub</span></code><span class="ne-text">文件复制到github上，coding/gitee类似</span></p><p id="5ebb897316771936fc3c2eaa1de25fc5" class="ne-p"><br></p><p id="baeeaf76c863612c9717d334c507c74d" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1597632490332-674f64ec-d09e-4351-a3cd-dbebc15a3a32.png" width="1839" id="P7hWK" class="ne-image"></p><p id="b7f90ece5dde7ad6e5f6febc9a121a44" class="ne-p"><span class="ne-text">title可以随便填</span></p><p id="e5bd9b7f3c85fe1f4399de4693f564b6" class="ne-p"><br></p><h3 id="70c59940"><span class="ne-text">清缓存，添agent</span></h3><p id="5a7567aac6f5d86b192b62b32e074751" class="ne-p"><br></p><p id="dd59aeb08546be538fe010aed4cddb46" class="ne-p"><span class="ne-text">在根目录下</span></p><p id="7bba79da380a12883486cf9c004b6ea3" class="ne-p"><br></p><pre><code>ssh-add -Dssh-add xxxxxx #旧密钥名称，一般是id_rsassh-add xxxxxx #新创建的密钥名称</code></pre><p id="4669abed1bbdc01087c573a676f18446" class="ne-p"><br></p><p id="b4c61c754b5f8ea3a769f5e1c4842ae5" class="ne-p"><span class="ne-text">如果执行以上命令出现错误：</span><code class="ne-code"><span class="ne-text">Could not open a connection to your authentication agent.</span></code><span class="ne-text">，那么就需要先执行</span><code class="ne-code"><span class="ne-text">ssh-agent bash</span></code><span class="ne-text">，再执行以上命令</span></p><p id="03525d0831255645f7e80844657465e9" class="ne-p"><br></p><h3 id="b644b124"><span class="ne-text">验证是否配置成功</span></h3><p id="496dd64d2fe810ec12ed81369517c521" class="ne-p"><br></p><p id="f612bfcc5041326c149c8aad14857da5" class="ne-p"><span class="ne-text">一下第一个是之前默认的github账号，默认即可，第二个是添加的</span></p><p id="cc473f1603bd6892a603ef84683d6358" class="ne-p"><br></p><pre><code>ssh -T git@github.comssh -T git@xxxxxxx.github.com</code></pre><p id="a0a045df0fbb1e1cd1cdab40a7ad7f41" class="ne-p"><br></p><p id="859795e16c81c6140a4d3a46644178cb" class="ne-p"><span class="ne-text">出现</span><code class="ne-code"><span class="ne-text">Hi 你的用户名! You've successfully authenticated, but GitHub does not provide shell access.</span></code><span class="ne-text">则成功。</span></p><p id="bbfe5332646c3eb64894a14a06513857" class="ne-p"><br></p><h3 id="ecff77a8"><span class="ne-text">使用</span></h3><p id="dec4e567985ba7c6daa83dd7efd4d7aa" class="ne-p"><br></p><ul class="ne-ul"><li id="1f5b251ade45d2df4286fec0c31f9aad"><span class="ne-text">取消全局用户名和邮箱配置（如果已经设置了全局的话）</span></li></ul><p id="49fc33402e1c55ebe1dbe86b84df93a9" class="ne-p"><br></p><pre><code>git config --global --unset user.namegit config --global --unset user.email</code></pre><p id="64c6fe7685f68ecac8a58b46e3ed2660" class="ne-p"><br></p><ul class="ne-ul"><li id="478d7951053c5209ae32960170a2d6a6"><span class="ne-text">clone</span></li></ul><p id="3cf89497aa39505bf781974bac162fb3" class="ne-p"><br></p><p id="abac6dfad45fcd2015180f8dcb97afcf" class="ne-p"><span class="ne-text">原来：</span><code class="ne-code"><span class="ne-text">git clone git@github.com: wztlink1013/learngit.git</span></code></p><p id="685853d5e013a258ebd6ea4463478b56" class="ne-p"><br></p><p id="d6eddf455dad8ad8d750ba0d6fad3874" class="ne-p"><span class="ne-text">现在：</span></p><p id="bca65a7f7725db91e4f694b2b03ceb10" class="ne-p"><br></p><pre><code>git clone git@wztlink1013.github.com: wztlink1013/learngit.gitgit clone git@twicename.github.com: twicename/learngit.git</code></pre><p id="db59368126eecb6ba239c5a2a7abbfcb" class="ne-p"><br></p><ul class="ne-ul"><li id="42ed0027e20be9ba6800985e1a73e010"><span class="ne-text">单独为每个repo设置 用户名/邮箱【以文件夹为单位】</span></li></ul><p id="8ddaefb655b7fa3508bfbe72b7573b4f" class="ne-p"><br></p><pre><code>git config user.name &quot;wztlink1013&quot;git config user.email &quot;2550374815@qq.com&quot;<p>git config user.name &quot;twicename&quot;<br>git config user.email &quot;<a href="mailto:&#x31;&#50;&#x33;&#x34;&#53;&#x36;&#x37;&#56;&#57;&#64;&#x71;&#x71;&#x2e;&#99;&#111;&#x6d;">&#x31;&#50;&#x33;&#x34;&#53;&#x36;&#x37;&#56;&#57;&#64;&#x71;&#x71;&#x2e;&#99;&#111;&#x6d;</a>&quot;<br></code></pre></p><p id="5238a03b67081fbc36b2f3d912731e38" class="ne-p"><br></p><p id="037ff2827c1c5cc7f40818c8512eb0b0" class="ne-p"><span class="ne-text">如果报错：</span><code class="ne-code"><span class="ne-text">fatal: not in a git directory</span></code><span class="ne-text">，说明没有进入.git目录下，具体路径：其中.git目录是隐藏的，需要你设置隐藏目录可见</span></p><p id="ef8fd1c012bb835caf90d934b0df5824" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1597632490310-1580343b-946c-4d67-a063-d5cd11bc6136.png" width="925" id="oPGRx" class="ne-image"></p><p id="7845e79f636dc900adbb5fb34b968e0b" class="ne-p"><br></p><p id="20cfea0ff85a401eaafe36ac836fabc4" class="ne-p"><span class="ne-text">执行</span><code class="ne-code"><span class="ne-text">git config --list</span></code><span class="ne-text">查看设置是否成功</span></p><p id="ff40e24211446f3703a820455043b979" class="ne-p"><br></p><h2 id="1808d429"><span class="ne-text">参考资料</span></h2><p id="8965ca6c3881f5c06a19f8fc0bc85445" class="ne-p"><br></p><ul class="ne-ul"><li id="8f39cdcf32806689a60e8772a903db52"><a href="https://github.com/guobinhit/cg-blog/blob/master/articles/github/README.md" data-href="https://github.com/guobinhit/cg-blog/blob/master/articles/github/README.md" target="_blank" class="ne-link"><span class="ne-text">史上最简单的 GitHub 教程</span></a></li><li id="b0eb734e49841990fe45436f6bbd2007"><a href="https://www.itrhx.com/2019/01/18/A16-deploy-two-or-more-hexo-blogs/" data-href="https://www.itrhx.com/2019/01/18/A16-deploy-two-or-more-hexo-blogs/" target="_blank" class="ne-link"><span class="ne-text">一台电脑使用两个/多个GitHub账号部署两个/多个Hexo博客</span></a></li></ul><ul class="ne-ul"><li id="c31f2191a7ffba5d8c03dba199597bba"><a href="https://blog.csdn.net/u013716535/article/details/78621775" data-href="https://blog.csdn.net/u013716535/article/details/78621775" target="_blank" class="ne-link"><span class="ne-text">一台电脑两个github账号</span></a></li><li id="2ecf8b0cfe027ad095ba9f12f127bc05"><a href="https://blog.csdn.net/IT_xiao_bai/article/details/88563103" data-href="https://blog.csdn.net/IT_xiao_bai/article/details/88563103" target="_blank" class="ne-link"><span class="ne-text">一台电脑上的git同时使用两个github账户</span></a></li></ul></div>]]></content>
      
      
      <categories>
          
          <category> 计算机素养 </category>
          
          <category> Git和GitHub </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>基本语法</title>
      <link href="/blog/ewt4nc/"/>
      <url>/blog/ewt4nc/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="2a6d98d92033574f2698ed8fe7fd0f79" class="ne-p"><br></p><div data-type="danger" class="ne-alert"><p id="f11422df3acf6c4995299675b04e020a" class="ne-p"><span class="ne-text">之前从OneNote转过来的笔记，暂未排版整理，日后整理……咕咕咕~</span></p></div><h2 id="cffLH"><span class="ne-text">一、基本语法</span></h2><p id="13f2ee330cde4024b9a14863a0c02d59" class="ne-p"><br></p><ol class="ne-ol"><li id="c4cd6d832be362df611f5dce18f8626d"><span class="ne-text">大事谷歌；小事百度【建立良好的编程式思维】</span></li><li id="ce9543acb2adc2e3fcd9164e07ece7cb"><span class="ne-text">PEP8中的一些良好约定【编程规范】</span></li><li id="f0de4a4ebb98ad3e6bf7c607b787f2d0"><span class="ne-text">字符串格式化：<br /></span><span class="ne-text">print('%s--%d--%s'%('wuzutao',20,'尼采般地抒情'))<br /></span><span class="ne-text">a. %i是什么格式的那啥？‘</span></li><li id="dfc4de496ee115d47599344719ebcebc"><span class="ne-text">强制性类型转换：类C</span></li><li id="d79dee57ea7aef63ef67a5f00c96fc5c"><span class="ne-text">时间和日期：<br /></span><span class="ne-text">from datetime import datetime<br /></span><span class="ne-text">dt=datetime(2019,5,12,9,20)<br /></span><span class="ne-text">print(dt.year,dt.month,dt.day)</span></li></ol><div class="ne-quote"><p id="02bd554fca20fb225a4e72be91a619c3" class="ne-p"><span class="ne-text">2019  5  12</span></p><p id="f2b14ab2ef15161d72d0e24e6035adc1" class="ne-p"><span class="ne-text">dt.strftime('%Y/%m/%d %H:%M')</span></p><p id="9b0a90d51334f62664ef26f821109434" class="ne-p"><span class="ne-text">#datetime格式转化为字符串</span></p><p id="3061771b0879cf438b497137f36e2c38" class="ne-p"><span class="ne-text">'2019/05/12 09:20'</span></p><p id="5eb378169969bb96726f7789fcb48a50" class="ne-p"><span class="ne-text">datetime.strptime('20161203', '%Y%m%d')</span></p><p id="e960fa85b4cd49680920dd7b76eb8dde" class="ne-p"><span class="ne-text">#字符串转化为datetime格式</span></p><p id="cafdf3ff4cb9c23403fdd2eea587ff90" class="ne-p"><span class="ne-text">datetime.datetime(2016, 12, 3, 0, 0)</span></p></div><ol start="6" class="ne-ol"><li id="b9accde722e5e9b7c11eeacbdd0c5677"><span class="ne-text">pass函数<br /></span><span class="ne-text">def f():<br /></span><span class="ne-text">    #TODO: test pass<br /></span><span class="ne-text">    pass</span></li><li id="0af1b5d10cfd7648bbda61f023062fdd"><span class="ne-text">异常的处理<br /></span><span class="ne-text">def test(x,y):<br /></span><span class="ne-text">    try:<br /></span><span class="ne-text">        print(y/x)<br /></span><span class="ne-text">    except:<br /></span><span class="ne-text">        print('输入的信息有误！')</span></li></ol><div class="ne-quote"><p id="8cd1c8107f0d49039e383eb459f377cf" class="ne-p"><span class="ne-text">test(2,8)</span></p><p id="dfb9444e5b35fe91500e9f2bc6c70b25" class="ne-p"><span class="ne-text">test('e',8)</span></p></div><ol start="8" class="ne-ol"><li id="6d1d70d45bb72197f01d18d95b136487"><span class="ne-text">range和range的区别！！！</span></li><li id="5b1ba9bc6ce66b7602e3ddd319e784d8"><span class="ne-text">对象传递和拷贝【类似C语言中的指针】<br /></span><span class="ne-text">#变量传递、列表传递和C类似<br /></span><span class="ne-text">#深拷贝和浅拷贝<br /></span><span class="ne-text">import copy<br /></span><span class="ne-text">a = [[1, 2, 3], [4, 5, 6]]<br /></span><span class="ne-text">b = a<br /></span><span class="ne-text">c = copy.copy(a)<br /></span><span class="ne-text">d = copy.deepcopy(a)<br /></span><span class="ne-text">print ('a-id:',id(a))#id相当于内存里面的地址<br /></span><span class="ne-text">print ('b-id:',id(b))<br /></span><span class="ne-text">print ('c-id:',id(c))<br /></span><span class="ne-text">print ('d-id:',id(d))<br /></span><span class="ne-text">a.append(15)<br /></span><span class="ne-text">a[1][2] = 10<br /></span><span class="ne-text">print (a)<br /></span><span class="ne-text">print (b)<br /></span><span class="ne-text">print (c)<br /></span><span class="ne-text">print (d)</span></li></ol><div class="ne-quote"></div><ol start="9" class="ne-ol"><li id="cd0c1eff537f153f12d6bd7657864a8e"><span class="ne-text">a-id: 2171119139144<br /></span><span class="ne-text">b-id: 2171119139144<br /></span><span class="ne-text">c-id: 2171119848136<br /></span><span class="ne-text">d-id: 2171119140744<br /></span><span class="ne-text">[[1, 2, 3], [4, 5, 10], 15]<br /></span><span class="ne-text">[[1, 2, 3], [4, 5, 10], 15]<br /></span><span class="ne-text">[[1, 2, 3], [4, 5, 10]]<br /></span><span class="ne-text">[[1, 2, 3], [4, 5, 6]]</span></li></ol><p id="c0388c341b9c4c7fcf9fdac344b8f4ed" class="ne-p"><br></p><h2 id="1d4ca41f"><span class="ne-text">二、数据结构</span></h2><p id="98fa019b4141affe9be259edd3b76b0d" class="ne-p"><br></p><h3 id="cda9f200"><span class="ne-text">元组</span></h3><p id="88f5b1a5f22d38724bb2e05985033fdc" class="ne-p"><br></p><pre><code>    ○ #转换为元组（list-&gt;tuple, string-&gt;tuple）    l = [1, 2, 3]    print (tuple(l))    str = ('Hello ChinaHadoop')    print (tuple(str))    &gt;&gt;&gt;(1, 2, 3) ('H', 'e', 'l', 'l', 'o', ' ', 'C', 'h', 'i', 'n', 'a', 'H', 'a', 'd', 'o', 'o', 'p')    ○ tup1 = (1, 2, 3)    #嵌套元组:    tup2 = ((1, 2, 3), (4, 5))    print (tup2)    #合并元组:    tup1 + tup2    ○ #拆包    def test_1():        r=(2,4,5,32)        return r    a, b, _, f=test_1()    print(f)    &gt;&gt;&gt; 32    ○ # 元组列表迭代    tuple_lst = [(1, 2), (3, 4), (5, 6)]    for x, y in tuple_lst:        print (x+y)    &gt;&gt;&gt;3   7   11    ○ # 计数器    列表/元组.('需要查找里面的某个对象的个数')</code></pre><p id="76462e976ae949f07c383933dea1d20f" class="ne-p"><br></p><h3 id="3712972d"><span class="ne-text">列表</span></h3><p id="52397d22f8eda4950f62d0350593815b" class="ne-p"><br></p><pre><code>    ○ list里面可以有不同类型的元素    ○ #合并列表    lst_1=[352,2352,3,556]    lst_2=['gew','f']    &gt;lst_3 = lst_1 + lst_2    &gt;lst_1.extend(lst_2)    ○ #sort函数和sorted函数    list_1=[23,54,346,222,4,1]    print(list_1.sort())     #查查版本    print(sorted(list_1))  #sorted是新起的一个列表    lst_6 = ['Welcome', 'to', 'Python', 'Data', 'Analysis', 'Course']    lst_6.sort()    print (lst_6)【!!!!打印出来是none===查查版本】    &gt;&gt;&gt;['Analysis', 'Course', 'Data', 'Python', 'Welcome', 'to']    lst_6.sort(key = len, reverse=True)    print (lst_6)    &gt;&gt;&gt;['Analysis', 'Welcome', 'Course', 'Python', 'Data', 'to']</code></pre><p id="da3ede3ec7d00bffbf805437da65ce49" class="ne-p"><br></p><h3 id="ad552573"><span class="ne-text">字典</span></h3><p id="127500d1d4e372dcb0d38356150e8a13" class="ne-p"><br></p><pre><code>    ○ #合并字典    dict1 = &#123;1:'huhuhu'&#125;    dict2 = &#123;4: 'new1', 5: 'news'&#125;    dict1.update(dict2)    ○ #通过多个列表创建字典    dict_3 = &#123;&#125;    l1 = [32,543,6,2,7,4]    l2 = reversed(l1)    for i1, i2 in zip(l1, l2):        dict_3[i1] = i2    print (dict_3)    &gt;&gt;&gt;&#123;32: 4, 543: 7, 6: 2, 2: 6, 7: 543, 4: 32&#125;    '''hash函数来判断某个对象是否可以做键'''    ○ '''位置赋值；默认赋值；关键字赋值——format'''    '''遍历字典的方式变了：keys，values，items'''    天行九歌=&#123;'韩非':'逆鳞','卫庄':'鲨齿','盖聂':'渊虹'&#125;    print(天行九歌)    for ren,jian in 天行九歌.items():        print('&#123;&#125;--&#123;&#125;'.format(ren,jian))    &gt;&gt;&gt;    &#123;'韩非': '逆鳞', '卫庄': '鲨齿', '盖聂': '渊虹'&#125;</code></pre><p id="595daa81a734ca97f30b3a6354c8e9d7" class="ne-p"><br></p><h3 id="508b37f1"><span class="ne-text">集合</span></h3><p id="d9dfa6f70259f8712e171ebfa1b7dab4" class="ne-p"><br></p><pre><code>    ○ a1=[1,3,4,1,35,2352,75]    b1=[3,2352,24354,4332432,54]    a=set(a1)    b=set(b1)    print(a)    print(b)    a | b#并；a &amp; b#交；a - b#呃。。。；a ^ b#呃。。。；    a.issubset(b)#判断子集    &gt;&gt;&gt;False    a.issuperset(b)#判断父集    &gt;&gt;&gt;False</code></pre><p id="dcbc8cb70c8377c710b4e39eb6c19317" class="ne-p"><br></p><h2 id="980d97e1"><span class="ne-text">三、高级特性</span></h2><p id="dc35503db2af0de529ea6a3d75050045" class="ne-p"><br></p><h3 id="55f730a2"><span class="ne-text">推导式</span></h3><p id="f4a5f201674c403e9e9a9eb0f6ebe529" class="ne-p"><br></p><pre><code>    ○ str_lst = ['Welcome', 'to', 'Python', 'Data', 'Analysis', 'Course']    result = [x.upper() for x in str_lst if len(x) &gt; 4]    print (result)    &gt;&gt;&gt;['WELCOME', 'PYTHON', 'ANALYSIS', 'COURSE']</code></pre><p id="9959e1adf74c43f06bab44fce7efb820" class="ne-p"><br></p><h3 id="e436a373"><span class="ne-text">多函数模式</span></h3><p id="ad562de11eb3e12b689748381c550d5e" class="ne-p"><br></p><pre><code>    ○ str_lst = ['$1.123', ' $1123.454', '$899.12312']    <pre><code>def remove_space(str):    &amp;quot;&amp;quot;&amp;quot;        remove space    &amp;quot;&amp;quot;&amp;quot;    str_no_space = str.replace(&#39; &#39;, &#39;&#39;)    return str_no_spacedef remove_dollar(str):    &amp;quot;&amp;quot;&amp;quot;        remove $    &amp;quot;&amp;quot;&amp;quot;    if &#39;$&#39; in str:        return str.replace(&#39;$&#39;, &#39;&#39;)    else:        return strdef clean_str_lst(str_lst, operations):    &amp;quot;&amp;quot;&amp;quot;        clean string list    &amp;quot;&amp;quot;&amp;quot;    result = []    for item in str_lst:        for op in operations:            item = op(item)        result.append(item)    return resultclean_operations = [remove_space, remove_dollar]result = clean_str_lst(str_lst, clean_operations)print (result)&amp;gt;&amp;gt;&amp;gt;[&#39;1.123&#39;, &#39;1123.454&#39;, &#39;899.12312&#39;]</code></pre><p></code></pre></p><p id="68031d523f9910737a129b3c77c00c00" class="ne-p"><br></p><h3 id="0153bdbc"><span class="ne-text">匿名函数</span></h3><p id="74520702090e791521c5344d24a46f24" class="ne-p"><br></p><pre><code>    ○ str_lst = ['Welcome', 'to', 'Python', 'Data', 'Analysis', 'Course']    str_lst.sort(key=lambda x:len(x)) # sort by length    print (str_lst)    <pre><code>str_lst.sort(key=lambda x:x[-1]) # sort by the last letterprint (str_lst)&amp;gt;&amp;gt;&amp;gt;[&#39;to&#39;, &#39;Data&#39;, &#39;Python&#39;, &#39;Course&#39;, &#39;Welcome&#39;, &#39;Analysis&#39;][&#39;Data&#39;, &#39;Course&#39;, &#39;Welcome&#39;, &#39;Python&#39;, &#39;to&#39;, &#39;Analysis&#39;]</code></pre><p></code></pre></p><p id="9f689cee4f71315c403549a284431542" class="ne-p"><br></p><h3 id="4c718d0b"><span class="ne-text">迭代器</span></h3><p id="c457fe224407fd8db023845a6f6c7255" class="ne-p"><br></p><pre><code>    ○ def gen_test():        for i in range(3):            yield i            <pre><code>gen = gen_test() #此时不执行生成器type(gen)for i in gen:    print(i)#用意何在呢？？！！&amp;gt;&amp;gt;&amp;gt;0  1  2</code></pre><p></code></pre></p><p id="5c766503d2641ad311a51230acc24879" class="ne-p"><br></p><h2 id="1a40e8f0"><span class="ne-text">四、常用函数</span></h2><p id="64efbb4171e43bcf92f7e4f0d7ad5ead" class="ne-p"><br></p><h3 id="5cee3ed5"><span class="ne-text">序列函数&amp;zip使用</span></h3><p id="ca28b43b59718630dcae965003188e4b" class="ne-p"><br></p><pre><code>    a. enumerate函数    list_11 = ['Welcome', 'to', 'Python', 'Data', 'Analysis', 'Course']     for i, item in enumerate(lst_6):        print ('%i-%s' %(i, item))    &gt;&gt;&gt;    0-Analysis     1-Welcome     2-Course     3-Python     4-Data     5-to    str_dict = dict((i, item) for i, item in enumerate(list_11))    print (str_dict)    &gt;&gt;&gt;&#123;0: 'Welcome', 1: 'to', 2: 'Python', 3: 'Data', 4: 'Analysis', 5: 'Course'&#125;    b. zip压缩    lst_6 = ['Welcome', 'to', 'Python', 'Data', 'Analysis', 'Course']    lst_8 = ['a', 'b', 'c']    zip_lst = zip(lst_6, lst_8)    print(list(zip_lst))    #方式一：直接转化为列表    print(dict(list(zip_lst)))    #方式二：转化为字典    for i in zip_lst:        print (i)    #方式三：直接遍历    解压：    print(*zip_lst)    print(lst_6)    c. reversed逆序输出</code></pre><p id="140d9c7e372982ff13665cedffbb9a57" class="ne-p"><br></p><h3 id="1cf50330"><span class="ne-text">函数式编程</span></h3><p id="21b3eb55002a9cfee230597862b03235" class="ne-p"><br></p><pre><code>    a. #函数可以作为变量使用;也可以将函数作为参数使用    import math    def func_add(x, y, f):        &quot;&quot;&quot;            functional addition        &quot;&quot;&quot;        return f(x) + f(y)    <pre><code>print (func_add(4, 25, math.sqrt))print (func_add(-4, 25, abs))&amp;gt;&amp;gt;&amp;gt;7.0    29</code></pre><p></code></pre></p><p id="03ef49ef206b95b185a3acb628933256" class="ne-p"><br></p><h3 id="cf808b2e"><span class="ne-text">map和reduce</span></h3><p id="e05e6015b3818ec2d1a7634653e64197" class="ne-p"><br></p><pre><code>    a. '''map函数'''    list_1=[1,4,9]    aaa = [x**2 for x in list_1]    print (aaa)    <pre><code>bbb = map(math.sqrt, aaa)print (bbb)&amp;gt;&amp;gt;&amp;gt;[1, 16, 81]</code></pre><p></code></pre></p><p id="a97905d34f851c154b2bd75325351007" class="ne-p"><br></p><p id="fa30fdc7b99a9b3413ee8f65edaa4c4a" class="ne-p"><span class="ne-text">&lt;map object at 0x000002145B2B77F0&gt;</span></p><p id="85fb5a3ddc05dd1c9f5683e39938e036" class="ne-p"><br></p><h3 id="cfecb9e9"><span class="ne-text">filter函数</span></h3><p id="ac5a64340a2190ec87b513df48b927c7" class="ne-p"><br></p><pre><code>    a. 天行=['韩非','卫庄','张良','盖聂','逆鳞']    def fx(x):        y=['逆鳞']        if x in y:            return x    filtered_lst = filter(fx,天行)    print(天行)    print(list(filtered_lst))    #注意python2和3的区别，很多时候要区别出来列表等序列，加上list很有必要    &gt;&gt;&gt;    ['韩非', '卫庄', '张良', '盖聂', '逆鳞']     ['逆鳞']</code></pre></div>]]></content>
      
      
      <categories>
          
          <category> 计算机素养 </category>
          
          <category> 后端编程语言 </category>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>apply函数和入口函数</title>
      <link href="/blog/hy14ic/"/>
      <url>/blog/hy14ic/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content-editor-core lake-engine lake-typography-classic" data-lake-element="root" data-selection-undefined="%7B%22path%22%3A%5B%5B0%2C0%2C0%5D%2C%5B0%2C0%2C0%5D%5D%2C%22active%22%3Atrue%7D"><h2 id="246b9da3" data-lake-id="844f80aba1a839d18f00392f27755399" style="padding: 7px 0px; margin: 0px; font-weight: 700; font-size: 24px; line-height: 32px;">pandas之apply函数</h2><p data-lake-id="04c3207445a0fa8ec49851f401e3e515" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><div data-card-type="block" data-lake-card="codeblock" id="5847fdd6" data-language="plain"><div class="lake-codeblock-content" style="border: 1px solid rgb(232, 232, 232); max-width: 750px; color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: rgb(249, 249, 249);"><div class="CodeMirror-sizer" style="color: rgb(89, 89, 89); margin: 0px; padding: 16px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"><pre class="cm-s-default" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"><span class="lake-preview-line" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"><span class="lake-preview-line-number lake-lm-pad-level-0" style="color: rgb(191, 191, 191); margin: 0px 8px 0px 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"></span><span class="lake-preview-codeblock-content" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">DataFrame.apply(func, axis=0, broadcast=False, raw=False, reduce=None, args=(), **kwds)</span></span></pre></div></div></div><p data-lake-id="7acd2f075bbdcc3918084199a7585cfb" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="38780fb1ad5e0900eca50dd2e5b6a031" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">第一个参数，这个参数是函数，相当于C/C++的函数指针。</p><p data-lake-id="266650ba684d96742abe5720fda6ffb2" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="08bbb10c326dd1ab87cc7e3a04ee7beb" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">这个函数需要自己实现，函数的传入参数根据axis来定，比如axis = 1，就会把一行数据作为Series的数据</p><p data-lake-id="b6f158a06cfe2ca03a8585f09dc5ec72" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">结构传入给自己实现的函数中，我们在函数中实现对Series不同属性之间的计算，返回一个结果，则apply函数</p><p data-lake-id="a74f2b6e30c197bf9fd20da00386abaf" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">会自动遍历每一行DataFrame的数据，最后将所有结果组合成一个Series数据结构并返回。</p><p data-lake-id="b4455c7d90f49ccb5e39dabe91d631cc" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><h2 id="4bf0240c" data-lake-id="d41b572923476057a29f506409166c4e" style="padding: 7px 0px; margin: 0px; font-weight: 700; font-size: 24px; line-height: 32px;">if <strong>name</strong> == 'main'</h2><p data-lake-id="d8cba4b33333b2023dba924a13608091" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="70814379fb07d2a600c168602ef4a235" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><a href="https://zhuanlan.zhihu.com/p/34112508" target="_blank">参考：知乎用户</a></p></div>]]></content>
      
      
      <categories>
          
          <category> 计算机素养 </category>
          
          <category> 后端编程语言 </category>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>qrcode和myqr花式二维码</title>
      <link href="/blog/ro3p67/"/>
      <url>/blog/ro3p67/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h2 id="o04Pl"><span class="ne-text">一、官方文档</span></h2><p id="22f49c2d869c21f5dea0ff3f73ebbbef" class="ne-p"><a href="https://pypi.org/project/qrcode/" data-href="https://pypi.org/project/qrcode/" target="_blank" class="ne-link"><span class="ne-text">https://pypi.org/project/qrcode/</span></a></p><p id="51136b0b262d1382694cd480ee80bc44" class="ne-p"><a href="https://pypi.org/project/MyQR/" data-href="https://pypi.org/project/MyQR/" target="_blank" class="ne-link"><span class="ne-text">https://pypi.org/project/MyQR/</span></a></p><h2 id="045e782b"><span class="ne-text">二、下载包</span></h2><p id="bf430b601d035b96fa7ec8618ffb486d" class="ne-p"><br></p><p id="ae8e789952f0e5ee6f06a634e0c4ef73" class="ne-p"><span class="ne-text">pip install qrcode  #方法多，体量小</span></p><p id="a2246ccdf64f749c73b4a664b63eb5db" class="ne-p"><br></p><p id="a20fedc429c3810eb0b738bbec0fc21a" class="ne-p"><span class="ne-text">pip install myqr    #操作简单，功能强大</span></p><p id="8bca71033f49365a128b86ef3613f0e4" class="ne-p"><br></p><h2 id="dd4077aa"><span class="ne-text">三、代码</span></h2><p id="97ec651e48d286b5dced3be63fca9788" class="ne-p"><br></p><h3 id="6ef799f7"><span class="ne-text">qrcode一行字二维码</span></h3><p id="4a76cabfeaffb73b04126c636c7dd260" class="ne-p"><br></p><pre><code>import qrcode<p>qrcode.make(&quot;不睡觉干嘛呢&quot;).get_image().show()   #设置URL必须添加http://<br></code></pre></p><p id="90d8f3edb17610adee15dcc81d8f59ee" class="ne-p"><br></p><h3 id="6ef799f7-1"><span class="ne-text">qrcode一行字二维码</span></h3><p id="6b21b559a6eec9276922d3b9fead3f9b" class="ne-p"><br></p><pre><code>import qrcode <p>text = input(&quot;输入文字或URL：&quot;)<br>img =qrcode.make(text)<br>img.save()                            #保存图片至本地目录，可以设定路径<br>img.show()<br></code></pre></p><p id="ed7556b5eb110f98fd4c55c438bbb372" class="ne-p"><br></p><h3 id="2915ed48"><span class="ne-text">qrcode生成logo二维码</span></h3><p id="c551995531d4811dc8aea45b124a88af" class="ne-p"><br></p><pre><code>from PIL import Imageimport qrcode,os <p>def create_qrcode(url,qrcodename):<br>    qr = qrcode.QRCode(<br>        version=1,  # 设置容错率为最高<br>        error_correction=qrcode.ERROR_CORRECT_H, # 用于控制二维码的错误纠正程度<br>        box_size=8, # 控制二维码中每个格子的像素数，默认为10<br>        border=1, # 二维码四周留白，包含的格子数，默认为4<br>        #image_factory=None,  保存在模块根目录的image文件夹下<br>        #mask_pattern=None<br>    )</p><pre><code>qr.add_data(url) # QRCode.add_data(data)函数添加数据qr.make(fit=True)  # QRCode.make(fit=True)函数生成图片img = qr.make_image()img = img.convert(&amp;quot;RGBA&amp;quot;) # 二维码设为彩色logo = Image.open(&#39;xx.jpg&#39;) # 传gif生成的二维码也是没有动态效果的w , h = img.sizelogo_w , logo_h = logo.sizefactor = 4   # 默认logo最大设为图片的四分之一s_w = int(w / factor)s_h = int(h / factor)if logo_w &amp;gt; s_w or logo_h &amp;gt; s_h:    logo_w = s_w    logo_h = s_hlogo = logo.resize((logo_w, logo_h), Image.ANTIALIAS)l_w = int((w - logo_w) / 2)l_h = int((h - logo_h) / 2)logo = logo.convert(&amp;quot;RGBA&amp;quot;)img.paste(logo, (l_w, l_h), logo)img.show()img.save(os.getcwd()+&#39;/&#39; + qrcodename + &#39;.png&#39;, quality=100)</code></pre><p></code></pre></p><p id="1cceb12f9d94fae140f68e18060de1ef" class="ne-p"><br></p><h3 id="68412b23"><span class="ne-text">myqr动态二维码</span></h3><p id="8b4531183dec82761497329f38f5b2ee" class="ne-p"><br></p><pre><code>相关参数：    words：二维码内容，链接或者句子    version：二维码大小，范围为[1,40]    level：二维码纠错级别，范围为&#123;L,M,Q,H&#125;，H为最高级，默认。    picture：自定义二维码背景图，支持格式为 .jpg，.png，.bmp，.gif，默认为黑白色    colorized：二维码背景颜色，默认为 False，即黑白色    contrast：对比度，值越高对比度越高，默认为 1.0    brightness：亮度，值越高亮度越高，默认为 1.0，值常和对比度相同    save_name：二维码名称，默认为 qrcode.png    save_dir：二维码路径，默认为程序工作路径</code></pre><p id="56fd137fc8a2f287c0e0b04341f81231" class="ne-p"><br></p><pre><code># 调用库from MyQR import myqr<h1 id="函数部分"><a href="#函数部分" class="headerlink" title="函数部分"></a>函数部分</h1><p>myqr.run(<br>    # 网址<br>    words=’<a href="https://wztlink1013.com&/#39;">https://wztlink1013.com&#39;</a>,<br>    # 控制边长，范围是1到40，数字越大边长越大，默认边长是取决于你输入的信息的长度和使用的纠错等级<br>    version=5,<br>    # 控制纠错水平，范围是L、M、Q、H，从左到右依次升高<br>    level=’H’,<br>    # 将QR二维码图像与一张同目录下的图片相结合，此处设置该图片，可以是gif<br>    picture=’./input/girl.gif’,<br>    # 默认是黑白(False)，可以选择彩色(True)<br>    colorized=True,<br>    # 调节图片的对比度，1.0 表示原始图片，更小的值表示更低对比度，更大反之。默认为1.0。<br>    contrast=1.0,<br>    # 调节图片的亮度，用法与contrast相同<br>    brightness=1.0,<br>    # 输出文件名，格式可以是jpg，png，bmp，gif<br>    save_name=’girl.gif’,<br>    save_dir=’./output’)<br></code></pre></p></div>]]></content>
      
      
      <categories>
          
          <category> 计算机素养 </category>
          
          <category> 后端编程语言 </category>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>面向对象</title>
      <link href="/blog/eywygo/"/>
      <url>/blog/eywygo/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h2 id="1wZ8H"><span class="ne-text">一、面向对象思考</span></h2><p id="u7554e2f3" class="ne-p"><br></p><h3 id="s8rdr"><span class="ne-text">思想</span></h3><div class="ne-quote"><p id="211427836ec509f2622ec9d08aa8fedd" class="ne-p"><span class="ne-text">就像是手工设计动态数组、链表等数据结构一样，要用</span><strong><span class="ne-text">设计</span></strong><span class="ne-text">这个字眼去面向对象思考。</span></p><p id="d0dc6c5c0be539111fd0c276fbf15f8c" class="ne-p"><span class="ne-text">同时还要关注类与类之间的关系有关联、聚集、组合，在设计多个类的过程中要有这些意识</span></p></div><p id="405b7f8ebc4270cb7f0de4ac35865edc" class="ne-p" style="text-align: left"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1600086611076-d83aa284-7977-447d-9b25-0a0a67a12c3f.png" width="501.5" id="NWYR1" class="ne-image"></p><p id="6983c00ad0f82b0bcc139fafb2ababf7" class="ne-p" style="text-align: left"><span class="ne-text">就像是之前的数据结构课程一样，像那样就是面向过程，全都是写函数来实现操作</span></p><h3 id="BC2lr"><span class="ne-text">基本数据类型值及其包装类</span></h3><div class="ne-quote"><p id="49a4297fd4e58ddedfb232196eab45d5" class="ne-p"><span class="ne-text">都存在java.lang里面</span></p></div><p id="e83c85ae6c81425f659cf03bc66eb30b" class="ne-p"><span class="ne-text">Integer、Long、Float、Double、Boolean、Character、Short、Byte</span></p><p id="9df1f6ac5a301638ae38e27d810e2482" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1600087287006-c480d8fd-a6b5-4be9-bc43-3023e9fa4a0c.png" width="494.5" id="fgi7A" class="ne-image"></p><div class="ne-quote"><p id="5507f7c0b5139313b32769fb46cb429f" class="ne-p"><span class="ne-text">基本数据类型和其对象化之后的包装类类型之间的自动转换</span></p></div><p id="c09f1b334dc8c713bf2d845ca2d826c7" class="ne-p"><code class="ne-code"><span class="ne-text">Integer intObject = new Integer (2);</span></code><span class="ne-text">  等价于 </span><code class="ne-code"><span class="ne-text">Integer intObject = 2;</span></code></p><div class="ne-quote"><p id="e52d16157e729e82227b20ba87df60a2" class="ne-p"><span class="ne-text">BigInteger 类和BigDeciml类用于表示任意大小和精度的整数或是二进制数</span></p></div><h2 id="l8hNI"><span class="ne-text">二、对象和类</span></h2><p id="5e6b7d98ed607486250e35c35f8fa6f0" class="ne-p"><br></p><h3 id="906a449b"><span class="ne-text">OOP阶梯图</span></h3><p id="bd0bc805dc8520df4ac2609a60ecbae6" class="ne-p"><br></p><div class="ne-quote"><p id="ac63916c9c34a07bce126c664303e837" class="ne-p"><span class="ne-text">“OOP阶梯图”—— 类的多个特性，同时以对象对基础</span></p></div><p id="cb43303427ae402236e24111d60148c6" class="ne-p" style="text-align: left"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598686636493-3aecdbf5-1f94-4076-99dc-0ef0dac07331.png" width="396" id="YkXtT" class="ne-image"></p><p id="cfe7eefc15bdc987f6e2eb698d861c9f" class="ne-p"><br></p><h3 id="6565c177"><span class="ne-text">类的组成</span></h3><div class="ne-quote"><p id="39e74c9750afecf01becb77046505dc3" class="ne-p"><span class="ne-text">数据域、构造函数、方法（C++里面的说法是数据成员和成员函数）</span></p><p id="7a61a585ce490b7c9b158e085c036943" class="ne-p"><strong><span class="ne-text">类中不能存在可执行语句</span></strong></p></div><p id="102cc5587b09ef81aa956e8f131282e5" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598686636459-572d60ff-0740-4487-b3fd-9e2fa94b643f.png" width="482" id="pUnxB" class="ne-image"></p><h3 id="81b1781e"><span class="ne-text">构造函数</span></h3><ul class="ne-ul"><li id="06cff58237f450ecce68ebd23933e49c"><span class="ne-text">和类同名、重载、没有返回值</span></li></ul><p id="c2f2aaa51e26c816d02f8b7406dd516a" class="ne-p" style="text-align: left"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598686636454-ce95b4aa-9966-4024-82ae-b7cc296097db.png" width="321" id="yocVH" class="ne-image"></p><ul class="ne-ul"><li id="325bf5bdc9feed420fb40831d8e87b03"><strong><span class="ne-text">构造函数初始化优先级</span></strong></li></ul><div class="ne-quote"><ol class="ne-ol"><li id="47da672e43499734e6b6ad8295930987"><span class="ne-text">静态成员变量初始化顺序高于非静态成员变量</span></li><li id="826ad49b485166e4ec8c28ed7b235c77"><span class="ne-text">成员变量的初始化顺序优于构造函数</span></li><li id="b90209d4e5c3c9456062aed4ef716193"><span class="ne-text">静态成员变量只初始化一次，就是第一次被访问的时候</span></li><li id="ca998545cd713ef6d259be26f4fd08ab"><span class="ne-text">存在多个静态成员变量的时候，按照次序依次执行</span></li></ol></div><p id="1b68705f1714689fc280c0f416cfbcba" class="ne-p"><br></p><p id="3c2dedb5b6e7c347e41935af7452f6c0" class="ne-p" style="text-align: left"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598686636495-c0c2fdf5-3919-475e-a2f7-a3888d97492d.png" width="441" id="sbHzG" class="ne-image"></p><p id="87d804df0e9be7ceeb1d31cf346dc9ef" class="ne-p"><br></p><pre><code>Window(2)Window(1)Window(2)Window(3)House()Window(33)f()</code></pre><h3 id="d370f29b"><span class="ne-text">数据域的默认值</span></h3><p id="49b379390616d0b50433996d8a9cf833" class="ne-p"><br></p><div class="ne-quote"><p id="096b16213c564543e9f82bf86efc1ad3" class="ne-p"><strong><span class="ne-text">对于对象而言，不赋值也会有默认的</span></strong><span class="ne-text">。之前的数组就是如此</span></p></div><p id="f1740f26d8a822648591f52af737a335" class="ne-p"><br></p><p id="a097998937fee72fa15a01e8f1e3b07a" class="ne-p"><span class="ne-text">各个数据域按照之前的基本上的默认初值，如果是其他的类型，则空</span></p><h3 id="f16d08eb"><span class="ne-text">对象的创建和访问</span></h3><div class="ne-quote"><ol class="ne-ol"><li id="f635cd50459d9f5e863b48b757481fc4"><span class="ne-text">通过引用变量来访问对象，创建的类的对象被内存分配了内存空间，可以用引用变量来访问</span></li><li id="e7e70313f481026c64ae8c029f910136"><strong><span class="ne-text">对象类型都需要用new来新建</span></strong></li></ol></div><pre><code>ClassName objectRefVar = new ClassName();<p>Circle myCircle = new Circle();<br></code></pre></p><p id="9cef77f1626d6ebfe841f3b696a3702c" class="ne-p"><br></p><p id="261ea8a37dc6d09b9ced7d69deae7c0e" class="ne-p"><strong><span class="ne-text">使用成员变量和成员函数</span></strong></p><pre><code>mycircle.radiusmycircle.getArea()</code></pre><p id="755d9559751c63b4e7b954b6f9b748b9" class="ne-p"><br></p><p id="9980d246b4f314f805cb5af18c33fffa" class="ne-p"><strong><span class="ne-text">调用静态函数，动态函数需要在自己类下面调用自己的函数</span></strong></p><h3 id="DjjQL"><span class="ne-text">“炸宿舍”</span></h3><div class="ne-quote"><p id="7452cf4e0ec6614b911b97281df8e336" class="ne-p"><span class="ne-text">关于老师提出来的炸宿舍例子</span></p></div><p id="1bbc7a7ec0b97df1615374585302c6bb" class="ne-p"><br></p><p id="09ca8400bffa9d03f1c9ba0837e5f3a1" class="ne-p"><strong><span class="ne-text">对象间的赋值和基本类型的赋值，能改变的一定是基本数值类型，所谓的数组名抑或是对象名，都只是地址映射</span></strong></p><p id="a444ed3d5f4288bf76bb5926549f332a" class="ne-p"><br></p><h3 id="fbf314e8"><span class="ne-text">垃圾回收机制和this</span></h3><pre><code>System.gc(); // 提醒垃圾回收</code></pre><p id="dbb47a0cbce9893e04d546db3f6c14af" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1600086346479-3cc546b6-dab8-4fc5-a352-8f2fb2ea8065.png" width="480" id="GZtwv" class="ne-image"></p><h3 id="749b9660"><span class="ne-text">静态变量、常量和方法</span></h3><div class="ne-quote"><p id="158734f34b1414b11f2a2a26930bf2b1" class="ne-p"><span class="ne-text">静态成员变量：静态成员变量可以被类的所有实例共享（比如计数变量用到）</span></p><p id="7bb2e66bfc0724af6e4fb145e239bff0" class="ne-p"><span class="ne-text">静态方法：不能访问类的实例成员</span></p><p id="6e1f2881172d329f1c465fd54d363e85" class="ne-p"><span class="ne-text">关于静态变量、静态方法、实例变量、实例方法</span></p></div><h3 id="3259401b"><span class="ne-text">可见性修饰符</span></h3><p id="b74fe4875219c7a9d279942c20c20d3c" class="ne-p"><br></p><p id="141c64de8b53347e49448ccb3f2d0953" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598686637158-0b08a6a1-5cd8-4aac-9133-1ad101cc8a52.png" width="491" id="h729N" class="ne-image"></p><p id="4f64bca697a16b8c1598036796326608" class="ne-p"><br></p><h3 id="cf65091d"><span class="ne-text">“析构函数”</span></h3><p id="b874b4e9f4c91bd8c7c0b1607d6a56b2" class="ne-p"><br></p><pre><code>protected void finalize() throwsable &#123;    super.finalize();    System.out.println(&quot;Person - finalize&quot;);&#125;</code></pre><p id="dd8fa05d8feab1cda081705a54904dd4" class="ne-p"><br></p><h3 id="94e0e403"><span class="ne-text">内部类</span></h3><p id="287ad1c49ac85b2113793cf19d6c1af1" class="ne-p"><br></p><p id="49907d7f616073980255671481afbfad" class="ne-p"><span class="ne-text">内部类只给该类使用（私有自己用，同时写静态的），就如LinkedList类的设计</span></p><h2 id="395285bb"></h2></div>]]></content>
      
      
      <categories>
          
          <category> 计算机素养 </category>
          
          <category> 后端编程语言 </category>
          
          <category> JAVA </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>基础知识</title>
      <link href="/blog/esofty/"/>
      <url>/blog/esofty/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h2 id="ql5Mg"><span class="ne-text">一、关于JAVA</span></h2><h3 id="ed9e5ca1"><span class="ne-text">Java和C和C++</span></h3><p id="ccd8e63159edceb17178c218367bc3f2" class="ne-p"><br></p><ol class="ne-ol"><li id="698cd8933b365e5b8cf4332b7f54f884"><span class="ne-text">c是面向过程的语言。c++和Java都是面向对象的。在c中没有类或者对象的概念。</span></li><li id="7aa0b30f75d6c7b94713e4b0ae4d68e6"><span class="ne-text">java运行在虚拟机上，号称与平台无关。也就是你开发的java程序无论是unix，linux还是windows都可以正常运行。但是实际上这是一个良好的愿望，实际跨平台时还会有各种各样的问题。c和c++都是直接编译成可执行文件，是否能跨平台主要看你用到的编译器特性是否有多平台支持。</span></li><li id="35663555ece757a13ba0160984cd967b"><span class="ne-text">因为c和c是直接编译成可执行文件，所以运行效率要比java高。至于c和c哪个更快，两种语言的拥趸已经吵了很多年。</span></li><li id="7ad027c5cbb2c8bde150fbefcfc1ada1"><span class="ne-text">java因为是运行在虚拟机上，不需要考虑内存管理和垃圾回收机制。也是就你可以声明一个对象而不用考虑释放他，虚拟机帮你做这事情。而c和c语言本身没有多少内存管理的概念，写c和c程序如果用到指针就一定要考虑内存申请和释放。内存泄漏是c和c++最头疼的问题。</span></li><li id="671344b8037dc8e5c03c14d4e149dbf3"><span class="ne-text">代码重用：java中有一个根类object，所有的类都是其子类，通过这种方式将容器和算法分离，实现一种操作作用于多种对象，提高代码重用。c中没有总根对象，但是c提供了另一个更强大的功能“模板”，同样高效地实现了一种操作作用于多种对象，提供了高效的代码重用方法。</span></li><li id="5a55af800fd882ca6767aced5e786e64"><span class="ne-text">数据结构：java内建了丰富的数据结构：列表，集合等等（很久没用java了，有些记不太清）。而c++则用“模板”同样提供了各种数据结构（容器）。</span></li><li id="4a85ea95f6665b68a74c91f296ebb8ef"><span class="ne-text">c语言在一些比较低层，和硬件打交道的地方用得比较多。另外很多开源软件由于unix/linux开发习惯也大多采用c来开发。Java是现在最流行的开发语言，c++比起java稍稍不那么流行一些，但是功能很强大。如能深入掌握，可以写出兼顾效率和美观的优秀代码。</span></li></ol><p id="539d215e3b4b6eb82efd60f12d42e3e9" class="ne-p"><br></p><h3 id="7a35a8d1"><span class="ne-text">多语言简略对比</span></h3><p id="b3de2788b6aa2da04eada8c990df7573" class="ne-p"><br></p><div class="ne-quote"><p id="0f32c20e39f4d4f82c95a88e719b5b89" class="ne-p"><strong><span class="ne-text">Ideas are cheap, show me the code</span></strong><span class="ne-text">  学到了，学到了~</span></p></div><p id="598300285116db515bbf9af11683f9cf" class="ne-p"><br></p><pre><code>代码块：python通过缩进来确定代码块复数：java、python有，C、Cplusplus没有python：相对于java，python就是java的压缩版本包、接口、API：我觉得java也好，python也好，正是因为这些模块组件化，才使得这些语言好很好的的健壮性</code></pre><p id="c73bade17b01fa82e1e94ced63400cdc" class="ne-p"><br></p><h2 id="0c1eaf47"><span class="ne-text">二、数据类型；运算符；表达式</span></h2><h3 id="3787f6af"><span class="ne-text">基本数据类型</span></h3><div class="ne-quote"><p id="7bda25f24a20dc222165486ea714bedc" class="ne-p"><span class="ne-text">常量、标识符和变量、数据类型</span></p></div><div class="ne-quote"><p id="3f2bc39d8d91deda8ece0b3d1a28fe73" class="ne-p"><strong><span class="ne-text">JAVA中除了下面8种数据类型其他的都是以对象（或者说类的实例）存在的</span></strong></p></div><ul class="ne-ul"><li id="129972189685aac88a76a73a231d2c0f"><span class="ne-text">string：要熟悉常用的函数</span></li></ul><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="c49a204e4968daffdceb6e354b31c99d"><span class="ne-text">length()：字符串的长度</span></li><li id="2a4f608990ed45be4166eef6351e0dc5"><span class="ne-text">charAt(i)：取字符串的第i个元素</span></li></ul></ul><ul class="ne-ul"><li id="f18c4c85809c8a56b0cf1459adf725d1"><span class="ne-text">boolean（java中需要全部写出来）</span></li></ul><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="03ea7bcc64dfab7902061fdcac00cd58"><code class="ne-code"><span class="ne-text">true</span></code></li><li id="dd94539ec68f3f034f1ba835aa609a22"><code class="ne-code"><span class="ne-text">false</span></code></li></ul></ul><ul class="ne-ul"><li id="310eb6ecb40ffc2639e36ea95f0e8995"><span class="ne-text">下面6中数值型数据类型</span></li></ul><p id="6bf32b47b37e76c47b7124d446ce83ac" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598686524193-b62199d3-9dc6-4caa-a3c1-2484c7d6185c.png" width="418" id="dyqgY" class="ne-image"></p><p id="d071baed3a3c06a3d1b1245812c09732" class="ne-p"><br></p><h3 id="794caa2a"><span class="ne-text">运算符和表达式</span></h3><ul class="ne-ul"><li id="07bb8f6ea6cacc31dbc25707f4ad028e"><span class="ne-text">赋值语句，赋值表达式</span></li><li id="5871557d73ee3bef1d11f26ae90c7c79"><span class="ne-text">输入输出：</span><strong><span class="ne-text">输入输出，要有记得清除的空间，close的意识！</span></strong></li></ul><pre><code>// 方式一import java.util.Scanner;<p>Scanner input = new Scanner(System.in);<br>double radius = input.nextDouble();</p><p>// 方式二 : 好处就是避免项目工程中类当中重名的情况<br>java.util.Scanner input = new java.util.Scanner(System.in);<br>double radius = input.nextDouble();<br></code></pre></p><p id="73c8bc3c5ef4d3b679a4a2d1c62fcebf" class="ne-p"><br></p><ul class="ne-ul"><li id="594bd46047eafe0bce50530344cfc631"><span class="ne-text">数值运算符</span></li></ul><div class="ne-quote"><p id="4188bb7db8158fdbc3ab5c1b44130d37" class="ne-p"><span class="ne-text">+、-、*、/、%</span></p></div><ul class="ne-ul"><li id="26f0a7d86406433d6c6f3eb2de66f565"><span class="ne-text">逻辑运算符<br /></span><code class="ne-code"><span class="ne-text">&amp;&amp;</span></code><span class="ne-text"> </span><code class="ne-code"><span class="ne-text">||</span></code><span class="ne-text"> </span><code class="ne-code"><span class="ne-text">!</span></code><span class="ne-text"> </span><code class="ne-code"><span class="ne-text">^</span></code><span class="ne-text">(异或：相同才为假)<br /></span><code class="ne-code"><span class="ne-text">&amp;</span></code><span class="ne-text"> </span><code class="ne-code"><span class="ne-text">|</span></code><span class="ne-text"> </span><code class="ne-code"><span class="ne-text">^</span></code><span class="ne-text"> 位运算符：会先化成二进制对二进制码进行分析</span></li><li id="79c033ed8cd8d971c31a53628b12bd03"><span class="ne-text">运算符的优先级</span></li></ul><p id="76fce43108f5d07713aea62528878f86" class="ne-p" style="text-align: center"><span class="ne-text"><br /></span><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598686523840-d1395ecf-7d3c-416b-8ce8-5d11a0e3f313.png" width="297" id="Dfenb" class="ne-image"></p><p id="4e2484b080566a8460f53f81b7c2e726" class="ne-p"><br></p><h2 id="f387966e"><span class="ne-text">三、程序三大基本结构</span></h2><h3 id="4ebeccc3"><span class="ne-text">顺序结构</span></h3><h3 id="f5dfe658"><span class="ne-text">选择结构</span></h3><p id="f3df1031e9e750bbc09d457e94306eb0" class="ne-p"><br></p><ul class="ne-ul"><li id="a74864ee35d748814a9978d33ed164fb"><span class="ne-text">if(){} else{}</span></li><li id="d67ed33cdd176ebff5d4b081b602078a"><span class="ne-text">switch</span></li></ul><pre><code>public class Test &#123;   public static void main(String args[])&#123;      //char grade = args[0].charAt(0);      char grade = 'C'; <pre><code>  switch(grade)  &#123;     case &#39;A&#39; :        System.out.println(&amp;quot;优秀&amp;quot;);         break;     case &#39;B&#39; :     case &#39;C&#39; :        System.out.println(&amp;quot;良好&amp;quot;);        break;     case &#39;D&#39; :        System.out.println(&amp;quot;及格&amp;quot;);        break;     case &#39;F&#39; :        System.out.println(&amp;quot;你需要再努力努力&amp;quot;);        break;     default :        System.out.println(&amp;quot;未知等级&amp;quot;);  &#125;  System.out.println(&amp;quot;你的等级是 &amp;quot; + grade);</code></pre><p>   }<br>}<br></code></pre></p><p id="20df002ac286d1a65c6ff264a236fa5d" class="ne-p"><br></p><ul class="ne-ul"><li id="ec491077ee36159093176d3e9ae161f1"><strong><span class="ne-text">条件表达式</span></strong></li></ul><pre><code>System.out.println((num % 2 == 0) ? &quot;num is even&quot; : &quot;num is odd&quot;);</code></pre><p id="af4037f23ef3986f2c571bc3db38fcf9" class="ne-p"><br></p><h3 id="037bdbce"><span class="ne-text">循环结构</span></h3><p id="d372f90191d3d74a255dde2aedac4163" class="ne-p"><br></p><ul class="ne-ul"><li id="ee08897ac873410e9300bc7569b45ec3"><span class="ne-text">while () {}</span></li><li id="d8512ea8dfc3a064f68faa5729802615"><span class="ne-text">do {} while ();</span></li><li id="347a6524fd216b0a778b6cdbf75ef226"><span class="ne-text">for () {}</span></li><li id="0bd19a0fa33440fde83eb559d2a5c37d"><span class="ne-text">关于break（跳出该级别的for循环）和continue（后面的语句不读）</span></li><li id="ef433c6e5dddc34fba80796c61f8083c"><span class="ne-text">关于return</span></li></ul><p id="75197706801d5d28b3cf8c0cfe18f787" class="ne-p" style="text-align: center"><span class="ne-text"><br /></span><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598686523958-c57b6b4d-e802-44e1-adc6-276167476c3d.png" width="381" id="WHaFp" class="ne-image"></p><p id="50b9a37069d342a1704b2cc7764c966c" class="ne-p"><br></p><ul class="ne-ul"><li id="8a6329e12a0a08a3d17fd033ee825f5a"><span class="ne-text">关于</span><strong><span class="ne-text">增强的for循环</span></strong><span class="ne-text">，在模板章节，配合vector使用，并发控制，高效使用</span></li></ul><p id="4dd9deabe9dbc4a0655c5a3eec8ad92e" class="ne-p"><br></p><p id="8394e3fc9537c4a23cf62ef4f262d74b" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598686523773-6d1af202-9aa9-4789-b931-b0671aac432f.png" width="369" id="FC64A" class="ne-image"></p><p id="de8e3ff4e2d542c742574aa65e577f9e" class="ne-p"><span class="ne-text">缺点：看不见索引</span></p><p id="56092ba7e99b6e92f177e0830e74599c" class="ne-p"><br></p><h2 id="99f0d0e9"><span class="ne-text">四、方法</span></h2><p id="ff7625673d51cecb746acb7b8256ce85" class="ne-p"><br></p><p id="0a3536a12e1c22b17f432e7af9a64a85" class="ne-p"><br></p><p id="3928816623d1f9c41a125fa458ab9b06" class="ne-p"><br></p><p id="e799a36524f375f624214a6036e80d97" class="ne-p"><br></p><p id="8f28be14aa85f36befc83eabd9cf2fd6" class="ne-p"><br></p><p id="8b936d0aebb99127b4a31a8031783e78" class="ne-p"><br></p><p id="ebb007c50670c35f910c78847b446a2f" class="ne-p"><br></p><p id="aaf1c2bc32229a445a537490725ad856" class="ne-p"><br></p></div>]]></content>
      
      
      <categories>
          
          <category> 计算机素养 </category>
          
          <category> 后端编程语言 </category>
          
          <category> JAVA </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>机器学习scikit-learn库的使用</title>
      <link href="/blog/wgv3ak/"/>
      <url>/blog/wgv3ak/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h2 id="5bee3f0f"><span class="ne-text">一、机器学习的一些概念</span></h2><h3 id="e2d6d0e3"><span class="ne-text">基本概念</span></h3><ul class="ne-ul"><li id="d2d782db5069f8dae8b6a1bff6271770"><span class="ne-text">特征：一组数据的多个属性</span></li><li id="1ae1f056eb066684a43e6d67b7844f01"><span class="ne-text">标签：人为指定特征</span></li><li id="7a50a4b66cab34d55eca1deb1c1ab1a3"><span class="ne-text">监督学习：就像分类（离散化的标签），回归（连续性的标签）、【“有标准答案”】</span></li><li id="2769fd3cae1a5e79bed5c3269bde5c65"><span class="ne-text">无监督学习：就像聚类【“无标准答案”】</span></li><li id="7581b3163cfaa24b8f99df504d81cd20"><strong><span class="ne-text">数据</span></strong><span class="ne-text">：是机器学习的命脉</span></li></ul><p id="0ceea112001075e31517062efafa3ad8" class="ne-p"><br></p><h3 id="ed38e053"><span class="ne-text">基本框架图</span></h3><p id="eb6bf04abe1d9f83c3ecca43f734d4bf" class="ne-p"><br></p><p id="250704e17a13248b5fb5b23d9d313a66" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598686130909-116e16a4-e86a-46e0-93fb-ac0263257056.png" width="453" id="F2NI4" class="ne-image"></p><p id="7a9cfeb28d8dc025f7e248610c39d913" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598686131288-431d8fe6-bf3f-4f3e-9986-9b282e9e2982.png" width="475" id="LzfkG" class="ne-image"></p><p id="73e4f1fcaf93d5eeedf210175c8ee3a9" class="ne-p"><br></p><h2 id="a72013d5"><span class="ne-text">二、机器学习的一些阶段/步骤</span></h2><p id="050e76919058cb184eb20ef48961b3b2" class="ne-p"><br></p><h3 id="cef7202b"><span class="ne-text">sklearn相关提及</span></h3><p id="1fafce44ffb6281355e9421dc94c9fc1" class="ne-p"><br></p><p id="9db7f6fb2b04cf93dcc8fa3728c6158f" class="ne-p"><a href="https://scikit-learn.org/stable/testimonials/testimonials.html" data-href="https://scikit-learn.org/stable/testimonials/testimonials.html" target="_blank" class="ne-link"><span class="ne-text">官网scikit-learn</span></a></p><p id="c843d200c3848ad05cc984f83a9d2e3f" class="ne-p"><br></p><ol class="ne-ol"><li id="9805e279fad9f4cd1b787cbb59e6a2bb"><span class="ne-text">包含聚类、分类、回归等算法<br /></span><span class="ne-text">eg：随机森林、k-means、SVM等</span></li><li id="db3038ecab25f3fc24d631311365ae13"><span class="ne-text">包含模型筛选、降维、预处理等算法</span></li><li id="54c678cfeb754645357efec91f999024"><span class="ne-text">要特别注意安装该包使用要注意的细节，具体参考上一篇博客</span></li></ol><p id="2e30cd945612807b08816b4cc33f5568" class="ne-p"><br></p><h3 id="f2bc4819"><span class="ne-text">sklearn处理机器学习的一般化sop</span></h3><p id="8022d1c4d586139cc725870d5eacff7c" class="ne-p"><br></p><ol class="ne-ol"><li id="f13ba218c28b3d269d775f7350a0850a"><strong><span class="ne-text">准备数据集</span></strong></li></ol><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="c5c5f4fda83ea45f98d978991c87d3a3"><span class="ne-text">数据分析</span><span class="ne-text">:（利用np.reshape()成二维(n_samples,n_features)）</span></li><li id="63a3e4964bdf56bcbc95035f6149e27c"><span class="ne-text">划分数据集：train_test_split()</span></li><li id="59ef378048ac74571cda7c44c98f3898"><span class="ne-text">特征工程：特征的提取、特征的归一化nomalization</span></li></ul></ul><ol start="2" class="ne-ol"><li id="0c68cc70de7d4b52895bb74e612b045f"><strong><span class="ne-text">选择模型</span></strong></li></ol><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="afc2714ef64987184b522ea6fa37a2a5"><span class="ne-text">根据不同场景选择合适的模型:</span><a href="https://scikit-learn.org/stable/tutorial/machine_learning_map/index.html" data-href="https://scikit-learn.org/stable/tutorial/machine_learning_map/index.html" target="_blank" class="ne-link"><span class="ne-text">scikit-learn的模型选择路线图</span></a></li><li id="5d15b30fc6cf661cfbc37d0fb4566861"><span class="ne-text">分类、聚类、回归……</span></li></ul></ul><ol start="3" class="ne-ol"><li id="71e3de310907fb0a10e93040b9ccb56f"><span class="ne-text">在训练集上</span><strong><span class="ne-text">训练模型</span></strong><span class="ne-text">，并调整参数</span></li></ol><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="9b9950c6e51e8c6ae10a2fbdd228def1"><span class="ne-text">经验选定参数</span></li><li id="aafbec39c5d8e67ed288bdb0265c67cc"><span class="ne-text">交叉验证确定最优的参数cross validation</span></li></ul></ul><ol start="4" class="ne-ol"><li id="13143c01f4d80cb1698eafe8386a45c2"><span class="ne-text">在测试集上</span><strong><span class="ne-text">测试模型</span></strong></li></ol><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="b54f8f021f312942ca8fa6b689cfae53"><span class="ne-text">predict预测、score真实值预测值评分、etc</span></li></ul></ul><ol start="5" class="ne-ol"><li id="2d1c2382fe82579fbe51e7f824f435d6"><strong><span class="ne-text">保存模型</span></strong></li></ol><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="b50eab253057b56bb54f3b3dc5b2ddbd"><code class="ne-code"><span class="ne-text">import pickle</span></code></li></ul></ul><p id="4552fb1bc582283e48711dcd041031d1" class="ne-p"><br></p><h3 id="88197008"><span class="ne-text">主成分分析：将特征降维</span></h3><p id="0d3292eb853d31942b5cda713773fccd" class="ne-p"><br></p><ul class="ne-ul"><li id="be0894fecc9d50b0d38969bb4c9b4641"><span class="ne-text">统计学相关知识：方差（衡量在一个维度的偏差）、协方差（衡量一个维度是否对另一个维度有影响cov（x，y））</span></li><li id="805bf986765a88e71efddbab8cffecf6"><span class="ne-text">线代相关知识：特征值、特征向量、协方差向量</span></li><li id="a4e955004f4587c2bd327f7dda04414f"><span class="ne-text">PCA</span></li></ul><p id="2d0a46eb2b25603e3431acc63be10047" class="ne-p"><br></p><p id="b8bfe4715d89bd2397f34a17fbc29673" class="ne-p"><a href="http://q5e49p23n.bkt.clouddn.com/scikit_pca.html" data-href="http://q5e49p23n.bkt.clouddn.com/scikit_pca.html" target="_blank" class="ne-link"><span class="ne-text">相关代码html页面</span></a></p><p id="14a0b4bf064d45461b9c269466566ec1" class="ne-p"><br></p><h2 id="c85531aa"><span class="ne-text">三、通过scikit-learn认识机器学习</span></h2><p id="b9f86893b1532af72bc0fa5deaf7a4c1" class="ne-p"><br></p><h3 id="c11d2053"><span class="ne-text">加载示例数据集</span></h3><p id="72b6c2ed2e671a5e099e132f46ea3a19" class="ne-p"><br></p><pre><code>from sklearn import datasetsiris = datasets.load_iris()#用sklearn自身配带的数据digits = datasets.load_digits()# C:\Users\wztli\Anaconda3\pkgs\scikit-learn-0.21.3-py37h6288b17_0\Lib\site-packages\sklearn\datasets\data# 数据集在电脑中的位置</code></pre><p id="69e1a15bea11fdcf845239a8237db4c4" class="ne-p"><br></p><pre><code># 查看数据集# irisprint(iris.data[:5])print(iris.data.shape)print(iris.target_names)print(iris.target)</code></pre><p id="2c82c2a79829d6250f8aae3e4415a676" class="ne-p"><br></p><pre><code>[[5.1 3.5 1.4 0.2] [4.9 3.  1.4 0.2] [4.7 3.2 1.3 0.2] [4.6 3.1 1.5 0.2] [5.  3.6 1.4 0.2]](150, 4)['setosa' 'versicolor' 'virginica'][0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2]</code></pre><p id="75fb5f18a8ca61a6d2f8d213b9a93ea0" class="ne-p"><br></p><pre><code># digitsprint(digits.data)print(digits.data.shape)print(digits.target_names)print(digits.target)</code></pre><p id="c08e4f227e41ac1048417c7eba4443a6" class="ne-p"><br></p><pre><code>[[ 0.  0.  5. ...  0.  0.  0.] [ 0.  0.  0. ... 10.  0.  0.] [ 0.  0.  0. ... 16.  9.  0.] ... [ 0.  0.  1. ...  6.  0.  0.] [ 0.  0.  2. ... 12.  0.  0.] [ 0.  0. 10. ... 12.  1.  0.]](1797, 64)[0 1 2 3 4 5 6 7 8 9][0 1 2 ... 8 9 8]</code></pre><p id="6bb801e7672fafcf2402ad8b2eada8b9" class="ne-p"><br></p><h3 id="2e430784"><span class="ne-text">在训练集上训练模型</span></h3><p id="ea0bd901af9a5698d87611a8431800f7" class="ne-p"><br></p><pre><code># 手动划分训练集、测试集 n_test = 100 # 测试样本个数train_X = digits.data[:-n_test, :]train_y = digits.target[:-n_test]<p>test_X = digits.data[-n_test:, :]<br>y_true = digits.target[-n_test:]<br></code></pre></p><p id="4c84d82408c9a7607fdde54aab1c5fea" class="ne-p"><br></p><pre><code># 选择SVM模型from sklearn import svm<p>svm_model = svm.SVC(gamma=0.001, C=100.)</p><h1 id="svm-model-svm-SVC-gamma-100-C-1"><a href="#svm-model-svm-SVC-gamma-100-C-1" class="headerlink" title="svm_model = svm.SVC(gamma=100., C=1.)"></a>svm_model = svm.SVC(gamma=100., C=1.)</h1><h1 id="训练模型"><a href="#训练模型" class="headerlink" title="训练模型"></a>训练模型</h1><p>svm_model.fit(train_X, train_y)<br>#训练要放入两个参数：样本的特征数据，样本的标签<br></code></pre></p><p id="8966759209375247b0896c8e7ec13b52" class="ne-p"><br></p><pre><code>SVC(C=100.0, cache_size=200, class_weight=None, coef0=0.0,    decision_function_shape='ovr', degree=3, gamma=0.001, kernel='rbf',    max_iter=-1, probability=False, random_state=None, shrinking=True,    tol=0.001, verbose=False)</code></pre><p id="3143848dcca4492177329a5a5bd3dd8b" class="ne-p"><br></p><pre><code># 选择LR（逻辑回归）模型from sklearn.linear_model import LogisticRegression<p>lr_model = LogisticRegression()</p><h1 id="训练模型-1"><a href="#训练模型-1" class="headerlink" title="训练模型"></a>训练模型</h1><p>lr_model.fit(train_X, train_y)<br></code></pre></p><p id="c24ae4e4bd254df0142100716c8430b4" class="ne-p"><br></p><pre><code>C:\Users\wztli\Anaconda3\lib\site-packages\sklearn\linear_model\logistic.py:432: FutureWarning: Default solver will be changed to 'lbfgs' in 0.22. Specify a solver to silence this warning.  FutureWarning)C:\Users\wztli\Anaconda3\lib\site-packages\sklearn\linear_model\logistic.py:469: FutureWarning: Default multi_class will be changed to 'auto' in 0.22. Specify the multi_class option to silence this warning.  &quot;this warning.&quot;, FutureWarning)<p>LogisticRegression(C=1.0, class_weight=None, dual=False, fit_intercept=True,<br>                   intercept_scaling=1, l1_ratio=None, max_iter=100,<br>                   multi_class=’warn’, n_jobs=None, penalty=’l2’,<br>                   random_state=None, solver=’warn’, tol=0.0001, verbose=0,<br>                   warm_start=False)<br></code></pre></p><p id="b50e7f4b41f61ea572f7d7f4c695e57a" class="ne-p"><br></p><h3 id="fedce9bc"><span class="ne-text">在测试集上测试模型</span></h3><p id="4fa0e85e0eb9c3fcd97c3ac317840bbb" class="ne-p"><br></p><pre><code>y_pred_svm = svm_model.predict(test_X)y_pred_lr = lr_model.predict(test_X)</code></pre><p id="7cfc4933ab8163a87e6df6d42796f957" class="ne-p"><br></p><pre><code># 查看结果# 评价指标from sklearn.metrics import accuracy_score<p>#print ‘预测标签：’, y_pred<br>#print ‘真实标签：’, y_true</p><p>print(‘SVM结果：’, accuracy_score(y_true, y_pred_svm))<br>print(‘LR结果：’, accuracy_score(y_true, y_pred_lr))<br></code></pre></p><p id="c3283b91cc35ef6836bbf6f1e7e2b30f" class="ne-p"><br></p><pre><code>SVM结果： 0.98LR结果： 0.94</code></pre><p id="ae4787e0e9369132023f669d68bcff3a" class="ne-p"><br></p><h3 id="2368cbf8"><span class="ne-text">保存模型</span></h3><p id="711dfa9304a4069ee9c72dbaf8af9914" class="ne-p"><br></p><pre><code>import pickle<p>with open(‘svm_model.pkl’, ‘wb’) as f:<br>    pickle.dump(svm_model, f)<br></code></pre></p><p id="393f058aef4b4b4fce8c679b3ddeca2d" class="ne-p"><br></p><pre><code>import numpy as np<h1 id="重新加载模型进行预测"><a href="#重新加载模型进行预测" class="headerlink" title="重新加载模型进行预测"></a>重新加载模型进行预测</h1><p>with open(‘svm_model.pkl’, ‘rb’) as f:<br>    model = pickle.load(f)</p><p>random_samples_index = np.random.randint(0, 1796, 5)<br>random_samples = digits.data[random_samples_index, :]<br>random_targets = digits.target[random_samples_index]</p><p>random_predict = model.predict(random_samples)</p><p>print(random_predict)<br>print(random_targets)<br></code></pre></p><p id="f22dffbb49c54ba3a3375c22a1e1780d" class="ne-p"><br></p><pre><code>[2 2 1 3 8][2 2 1 3 8]</code></pre><p id="daa5b608f7016bc41e60043754db5b5b" class="ne-p"><br></p><p id="253af5b5a05a4f63bd2da5ada2ab7b42" class="ne-p"><br></p><h2 id="5ca8154b"><span class="ne-text">四、scikit-learn入门</span></h2><p id="0e97c0d59899fdd888caa6fdaf4ac7b0" class="ne-p"><br></p><h3 id="15d049a5"><span class="ne-text">准备数据集</span></h3><p id="e87a310596dcc968db1d5ce53a065989" class="ne-p"><br></p><pre><code>import numpy as npfrom sklearn.model_selection import train_test_split</code></pre><p id="677abb17e30637609cf15d18fe4548bb" class="ne-p"><br></p><pre><code>X = np.random.randint(0, 100, (10, 4))y = np.random.randint(0, 4, 10)y.sort()<p>print(‘样本：’)<br>print(X)<br>print(‘标签：’, y)<br></code></pre></p><p id="543b06ac3de2b0f9c100c41a0a5c2290" class="ne-p"><br></p><pre><code>样本：[[43 43 18 78] [74 24 42 37] [36 69 84 47] [70 62 77 30] [87 38  3 96] [68 67 24  7] [66 36 72 72] [12 94 87 72] [66  5 92  6] [41 59 60 91]]标签： [0 0 0 2 2 2 2 3 3 3]</code></pre><p id="f5dd0524eabf3f9400602f9a46a7e5e8" class="ne-p"><br></p><pre><code># 分割训练集、测试集# random_state确保每次随机分割得到相同的结果X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=1/3., random_state=7) <p>print(‘训练集：’)<br>print(X_train)<br>print(y_train)</p><p>print(‘测试集：’)<br>print(X_test)<br>print(y_test)<br></code></pre></p><p id="48e56a34adc66c2e5c55c3c9d74fd27f" class="ne-p"><br></p><pre><code>训练集：[[63 56  7 42] [40 47 17 23] [41 31 26  8] [79 30 22 88] [54 85 48 54] [89 73 77 41]][0 1 1 0 1 1]测试集：[[ 3  0 42 86] [42 96 83 38] [33 45  8 37] [ 1 44 75  7]][1 1 0 0]</code></pre><p id="6770977ecd10dd5d619ab1d28996764e" class="ne-p"><br></p><pre><code># 特征归一化from sklearn import preprocessing<p>x1 = np.random.randint(0, 1000, 5).reshape(5,1)<br>x2 = np.random.randint(0, 10, 5).reshape(5, 1)<br>x3 = np.random.randint(0, 100000, 5).reshape(5, 1)</p><p>X = np.concatenate([x1, x2, x3], axis=1)<br>print(X)<br></code></pre></p><p id="85bc1e247acd1d16e6b704dd5da2a813" class="ne-p"><br></p><pre><code>[[  353     4 27241] [  999     4 34684] [  911     4 78606] [  310     6 44593] [  817     9  6356]]</code></pre><p id="dc10186fca14068b5fe5986e09b9f92f" class="ne-p"><br></p><pre><code>print(preprocessing.scale(X))</code></pre><p id="430c7a343ef9d25ac1541ef957180558" class="ne-p"><br></p><pre><code>[[-1.12443958 -0.71443451 -0.46550183] [ 1.11060033 -0.71443451 -0.15209341] [ 0.80613669 -0.71443451  1.69736578] [-1.27321159  0.30618622  0.26515287] [ 0.48091416  1.83711731 -1.34492342]]</code></pre><p id="204053c1a3a2c98fa486d34865ead442" class="ne-p"><br></p><pre><code># 生成分类数据进行验证scale的必要性from sklearn.datasets import make_classificationimport matplotlib.pyplot as plt%matplotlib inline<p>X, y = make_classification(n_samples=300, n_features=2, n_redundant=0, n_informative=2,<br>                           random_state=25, n_clusters_per_class=1, scale=100)</p><p>plt.scatter(X[:,0], X[:,1], c=y)<br>plt.show()<br></code></pre></p><p id="df434115680152f8ffa701ec8283165a" class="ne-p"><br></p><p id="584acfcd9658a334d1253064bd0c0394" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598686130636-3a18d8f2-51cb-4b04-8a0f-a40cf1d0b9b6.png" width="384" id="BKtnM" class="ne-image"></p><p id="15c96f58169f6c9d950cfa7e385d4eb4" class="ne-p"><br></p><pre><code>from sklearn import svm<h1 id="注释掉以下这句表示不进行特征归一化"><a href="#注释掉以下这句表示不进行特征归一化" class="headerlink" title="注释掉以下这句表示不进行特征归一化"></a>注释掉以下这句表示不进行特征归一化</h1><p>X = preprocessing.scale(X)</p><p>X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=1/3., random_state=7)<br>svm_classifier = svm.SVC()<br>svm_classifier.fit(X_train, y_train)<br>svm_classifier.score(X_test, y_test)<br></code></pre></p><p id="cd9793129aa04ea0d6f6c35636421e24" class="ne-p"><br></p><pre><code>C:\Users\wztli\Anaconda3\lib\site-packages\sklearn\svm\base.py:193: FutureWarning: The default value of gamma will change from 'auto' to 'scale' in version 0.22 to account better for unscaled features. Set gamma explicitly to 'auto' or 'scale' to avoid this warning.  &quot;avoid this warning.&quot;, FutureWarning)<p>0.25<br></code></pre></p><p id="64d401b7c2e36d9ed5539dd517136770" class="ne-p"><br></p><h3 id="a162534b"><span class="ne-text">训练模型</span></h3><p id="dd2ce1398f6117ba5ca42c6d622ed617" class="ne-p"><br></p><pre><code># 回归模型from sklearn import datasets<p>boston_data = datasets.load_boston()<br>X = boston_data.data<br>y = boston_data.target</p><p>print(‘样本：’)<br>print(X[:5, :])<br>print(‘标签：’)<br>print(y[:5])<br></code></pre></p><p id="a08b7063785f4dbcc5a662aaf1925f11" class="ne-p"><br></p><pre><code>样本：[[6.3200e-03 1.8000e+01 2.3100e+00 0.0000e+00 5.3800e-01 6.5750e+00  6.5200e+01 4.0900e+00 1.0000e+00 2.9600e+02 1.5300e+01 3.9690e+02  4.9800e+00] [2.7310e-02 0.0000e+00 7.0700e+00 0.0000e+00 4.6900e-01 6.4210e+00  7.8900e+01 4.9671e+00 2.0000e+00 2.4200e+02 1.7800e+01 3.9690e+02  9.1400e+00] [2.7290e-02 0.0000e+00 7.0700e+00 0.0000e+00 4.6900e-01 7.1850e+00  6.1100e+01 4.9671e+00 2.0000e+00 2.4200e+02 1.7800e+01 3.9283e+02  4.0300e+00] [3.2370e-02 0.0000e+00 2.1800e+00 0.0000e+00 4.5800e-01 6.9980e+00  4.5800e+01 6.0622e+00 3.0000e+00 2.2200e+02 1.8700e+01 3.9463e+02  2.9400e+00] [6.9050e-02 0.0000e+00 2.1800e+00 0.0000e+00 4.5800e-01 7.1470e+00  5.4200e+01 6.0622e+00 3.0000e+00 2.2200e+02 1.8700e+01 3.9690e+02  5.3300e+00]]标签：[24.  21.6 34.7 33.4 36.2]</code></pre><p id="98101aaad54eaf5ee059928edd05c11c" class="ne-p"><br></p><pre><code># 选择线性回顾模型from sklearn.linear_model import LinearRegression<p>lr_model = LinearRegression()<br></code></pre></p><p id="c668aa03a5ba249b3a649e72af7cbe86" class="ne-p"><br></p><pre><code>from sklearn.model_selection import train_test_split<h1 id="分割训练集、测试集"><a href="#分割训练集、测试集" class="headerlink" title="分割训练集、测试集"></a>分割训练集、测试集</h1><p>X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=1/3., random_state=7)<br></code></pre></p><p id="139269d9c14d92afa60662bf15cf4528" class="ne-p"><br></p><pre><code># 训练模型lr_model.fit(X_train, y_train)</code></pre><p id="4fc615f05f90aba2d7cdc715364d250f" class="ne-p"><br></p><pre><code>LinearRegression(copy_X=True, fit_intercept=True, n_jobs=None, normalize=False)</code></pre><p id="251fef8ddb74a2c95c6fa6932b69b2d8" class="ne-p"><br></p><pre><code># 返回参数lr_model.get_params()</code></pre><p id="eb617c84c76be9c4eec131f70e997ad9" class="ne-p"><br></p><pre><code>&#123;'copy_X': True, 'fit_intercept': True, 'n_jobs': None, 'normalize': False&#125;</code></pre><p id="c42dc688472c0e2324aa698f31da80f7" class="ne-p"><br></p><pre><code>lr_model.score(X_train, y_train)</code></pre><p id="2c7b205b5802cd82901cee3aabb5b120" class="ne-p"><br></p><pre><code>0.7598132492351114</code></pre><p id="03dd00659a65b34b00137f7b4f13a21c" class="ne-p"><br></p><pre><code>lr_model.score(X_test, y_test)</code></pre><p id="63ff02db23bd9fdb0ab22157b50127fd" class="ne-p"><br></p><pre><code>0.6693852753319398</code></pre><p id="d11e0df1150b9cc415330ed1897dc791" class="ne-p"><br></p><h3 id="95c01146"><span class="ne-text">交叉验证</span></h3><p id="e7d50bcfa04456167bf498f3906f048b" class="ne-p"><br></p><pre><code>from sklearn import datasetsfrom sklearn.model_selection import train_test_split, cross_val_scorefrom sklearn.neighbors import KNeighborsClassifierimport matplotlib.pyplot as plt%matplotlib inline<p>iris = datasets.load_iris()<br>X = iris.data<br>y = iris.target</p><p>X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=1/3., random_state=10) </p><p>k_range = range(1, 31)<br>cv_scores = []<br>for n in k_range:<br>    knn = KNeighborsClassifier(n)<br>    scores = cross_val_score(knn, X_train, y_train, cv=10, scoring=’accuracy’) # 分类问题使用<br>    #scores = cross_val_score(knn, X_train, y_train, cv=10, scoring=’neg_mean_squared_error’) # 回归问题使用<br>    cv_scores.append(scores.mean())</p><p>plt.plot(k_range, cv_scores)<br>plt.xlabel(‘K’)<br>plt.ylabel(‘Accuracy’)<br>plt.show()<br></code></pre></p><p id="a0cded2f71f7aa3fa90d3eaadfecd803" class="ne-p"><br></p><p id="2c0277bb65360b70642be04d029190f5" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598686130618-179a3dfa-9ffd-4f45-9cc2-d6f63e1ad2b9.png" width="392" id="uSgI0" class="ne-image"></p><p id="493f3ee2cd36e50d58098a4754934f4e" class="ne-p"><br></p><pre><code># 选择最优的Kbest_knn = KNeighborsClassifier(n_neighbors=5)best_knn.fit(X_train, y_train)print(best_knn.score(X_test, y_test))print(best_knn.predict(X_test))</code></pre><p id="53630747d5d6a54a8f8691293beb276a" class="ne-p"><br></p><pre><code>0.96[1 2 0 1 0 1 2 1 0 1 1 2 1 0 0 2 1 0 0 0 2 2 2 0 1 0 1 1 1 2 1 1 2 2 2 0 2 2 2 2 0 0 1 0 1 0 1 2 2 2]</code></pre><p id="1dade961417cd6d7c846d50bdce2ee94" class="ne-p"><br></p><span id="python-1"></span><p id="91ae545daa1b2a4b77f487c8256edd44" class="ne-p"><br></p><h2 id="tmokZ"><span class="ne-text">参考</span></h2><ul class="ne-ul"><li id="658d75dd41d71405e20edf15c803b74d"><a href="https://github.com/wztlink1013/scikit-learn" data-href="https://github.com/wztlink1013/scikit-learn" target="_blank" class="ne-link"><span class="ne-text">scikit-learn中文文档github</span></a><span class="ne-text">文中链接为英文文档</span></li><li id="15a722080e24c81b2e413a8594541477"><a href="https://blog.csdn.net/Little_Fire/article/details/81062447" data-href="https://blog.csdn.net/Little_Fire/article/details/81062447" target="_blank" class="ne-link"><span class="ne-text">解释iris数据集</span></a></li></ul></div>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ANN神经网络</title>
      <link href="/blog/apohu8/"/>
      <url>/blog/apohu8/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h2 id="5396595c"><span class="ne-text">一、基本结构</span></h2><div class="ne-quote"><p id="9ff676f1b1428f70651dd81351c918a9" class="ne-p"><span class="ne-text">神经网络基本结构</span></p><p id="9afe084d0c0f5d125454c00d8316ac2b" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685949882-81dbb96c-eafa-4294-aae3-242fd33fff2b.png" width="858" id="gahgJ" class="ne-image"></p><p id="000939a8cad93dc9132994c3242c46e0" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685950067-4d0671d6-b294-4284-9eff-9409d230e91e.png" width="768" id="agJlv" class="ne-image"></p></div><p id="0645cf040cdcaf713e02b87ada120f01" class="ne-p"><br></p><div class="ne-quote"><p id="065eac867ac6742e31c641fd69006c49" class="ne-p"><span class="ne-text">何为深度学习？</span></p><p id="22ad9d9a288750336a81502235e0bdc8" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685949953-b8d95ff1-6384-4e59-b3d6-1f8151f08204.png" width="842" id="WSSoJ" class="ne-image"></p></div><p id="fc998640964f9078e4e2140f7fa8f381" class="ne-p"><br></p><h2 id="3b8ffd43"><span class="ne-text">二、感知器和激活函数</span></h2><p id="d9bfad8faec766177ed1b90e8b1d1d4f" class="ne-p"><br></p><div class="ne-quote"><p id="6c00d0e6fb4e76337fa07a0654b24320" class="ne-p"><span class="ne-text">感知器</span></p><p id="b390f6d32b37c46232883ec68642565e" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685949922-e9c76c57-f1c5-4ff1-af82-25c35a4005b1.png" width="802" id="eaX9r" class="ne-image"></p></div><p id="27156250e2f5ccb96ec3a468cbb26206" class="ne-p"><br></p><div class="ne-quote"><p id="efe4993581ab112af68216d3cfc36ddf" class="ne-p"><span class="ne-text">激活函数（其中w和x为向量点乘；b为偏置，w0）</span></p><p id="bb328765130737e96a0a2e05e5d8f36d" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685949961-18eeecb5-c82e-4f71-a543-9bd0c0f27043.png" width="836" id="LJZ0R" class="ne-image"></p></div><p id="7bfc817383b4942925b419c7ef868499" class="ne-p"><br></p><div class="ne-quote"><p id="f88afa39211585266699b85eed9d4938" class="ne-p"><span class="ne-text">激活函数的选择</span></p><p id="c0d9b184bc68ff2aa819c1d56400ad75" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685950003-072268a5-122d-4340-85d5-85eeb04236fe.png" width="861" id="DZqH3" class="ne-image"></p></div><p id="c692710e26bc6f3e43ad120dc80e6160" class="ne-p"><br></p><h2 id="a96c723f"><span class="ne-text">三、感知器的训练</span></h2><p id="899625be1fe26e9be99b2cc902920d4d" class="ne-p"><br></p><p id="87529d7d3344062aa2131512dac8e20d" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685950698-fc03bb22-76e6-4328-9a6b-ee2168250fec.png" width="872" id="jRv0N" class="ne-image"></p><p id="071952e49355376deb91bdb4df4a66f3" class="ne-p"><br></p><h2 id="8a01797f"><span class="ne-text">四、简单代码实现</span></h2><p id="2bfb8ab8673378a709be5c94953bd7bb" class="ne-p"><br></p><pre><code>from functools import reduce<p>class Perceptron(object):<br>    ‘’’<br>    构造函数的初始化<br>    ‘’’<br>    def <strong>init</strong>(self,input_num,activator):<br>        ‘’’<br>        构造函数的初始化<br>        ‘’’<br>        self.activator = activator<br>        self.weights = [0.0 for _ in range(input_num)]<br>        self.bias = 0.0<br>    def <strong>str</strong>(self):<br>        ‘’’<br>        打印学习后的权重值和偏置项<br>        ‘’’<br>        return ‘weights\t:%s\nbias\t:%f\n’ %(self.weights,self.bias)<br>    def predict(self,input_vec):<br>        ‘’’<br>        输入向量，输出感知器的计算结果<br>        ‘’’<br>        return self.activator(<br>            reduce(lambda a,b: a+b,<br>                    list(map(lambda x,w: x<em>w,<br>                        input_vec,self.weights)<br>                 ),0.0)+self.bias)<br>    def train(self,input_vecs,labels,iteration,rate):<br>        ‘’’<br>        输入训练数据：一组向量、与每个向量对应的label；以及训练轮数、学习率<br>        ‘’’<br>        for i in range(iteration):<br>            self._one_iteration(input_vecs,labels,rate)<br>    def _one_iteration(self,input_vecs,labels,rate):<br>        ‘’’<br>        迭代，把所有的训练数据过一遍<br>        ‘’’<br>        samples = zip(input_vecs,labels)<br>        for (input_vec,label) in samples:<br>            output = self.predict(input_vec)<br>            self._update_weights(input_vec,output,label,rate)<br>    def _update_weights(self,input_vec,output,label,rate):<br>        ‘’’<br>        按照感知器规则更新权重<br>        ‘’’<br>        delta = label - output<br>        self.weights = map(<br>            lambda x, w:w+rate</em>delta<em>x,<br>            input_vec,self.weights)<br>        self.weights = list(self.weights)<br>        self.bias += rate</em>delta<br>def f(x):<br>    ‘’’<br>    定义激活函数<br>    ‘’’<br>    return 1 if x&gt;0 else 0<br>def get_training_dataset():<br>    ‘’’<br>    训练数据<br>    ‘’’<br>    input_vecs = [[1,1],[0,0],[1,0],[0,1]]<br>    labels = [1,0,0,0]<br>    return input_vecs,labels<br>def train_and_perceptron():<br>    ‘’’<br>    训练感知器<br>    ‘’’<br>    p = Perceptron(2,f)<br>    input_vecs,labels = get_training_dataset()<br>    p.train(input_vecs,labels,10,0.1)<br>    return p</p><p>if <strong>name</strong> == ‘<strong>main</strong>‘:<br>    and_perception = train_and_perceptron()<br>    print(and_perception)<br>    print(‘1 and 1 = %d’ % and_perception.predict([1,1]))<br>    print(‘0 and 0 = %d’ % and_perception.predict([0,0]))<br>    print(‘1 and 0 = %d’ % and_perception.predict([1,0]))<br>    print(‘0 and 1 = %d’ % and_perception.predict([0,1]))<br></code></pre></p><p id="c000e4c215a32dd9babffd762600a81c" class="ne-p"><br></p><div class="ne-quote"><p id="48138431c23bb5cded564b12e3891d08" class="ne-p"><span class="ne-text">运行结果：</span></p><p id="9f488a9d49c8ac409e5b9b2a45ae23f7" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685949806-ba54dca5-89a6-474a-809c-0b0238184755.png" width="536" id="KN2eh" class="ne-image"></p></div></div>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[转]操作系统核心知识点</title>
      <link href="/blog/spobqi/"/>
      <url>/blog/spobqi/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><div class="ne-quote"><ul class="ne-ul"><li id="78c70b8dd6e7969e68cc2270cf0b875c"><span class="ne-text">本文转载自：</span><a href="https://www.cnblogs.com/cxuanBlog/p/13297199.html" data-href="https://www.cnblogs.com/cxuanBlog/p/13297199.html" target="_blank" class="ne-link"><span class="ne-text">5万字、97 张图总结操作系统核心知识点 - 程序员cxuan - 博客园</span></a></li></ul></div><div class="ne-quote"><ul class="ne-ul"><li id="f1f3650356a7da2355a3c9411b72ce03"><span class="ne-text">部分内容自行添加</span></li></ul></div><p id="e09cae7512bb1e7e65e0b987a5ca3c8a" class="ne-p"><br></p><p id="931bb607447da06d6f3bed0cd017ed4c" class="ne-p"><span class="ne-text">这不是一篇教你如何创建一个操作系统的文章，相反，这是一篇指导性文章，教你从几个方面来理解操作系统。首先你需要知道你为什么要看这篇文章以及为什么要学习操作系统。</span></p><h2 id="61749910"><span class="ne-text">搞清楚几个问题</span></h2><p id="cd8943ed3bdff3713c416af18dcb5bc9" class="ne-p"><br></p><p id="25252fec79848d7bbc0a038fde638496" class="ne-p"><span class="ne-text">首先你要搞明白你学习操作系统的目的是什么？操作系统的重要性如何？学习操作系统会给我带来什么？下面我会从这几个方面为你回答下。</span></p><p id="8b7d10816f8e53284531845daf551ca3" class="ne-p"><br></p><p id="e6f1da87c780159f3f7de45053402efa" class="ne-p"><span class="ne-text">操作系统也是一种软件，但是操作系统是一种非常复杂的软件。操作系统提供了几种抽象模型</span></p><p id="8c1a07ee6be4f495dd752ea6d4f3b020" class="ne-p"><br></p><ul class="ne-ul"><li id="217f42e4058efed81e8bad4607e4acfd"><span class="ne-text">文件：对 I/O 设备的抽象</span></li><li id="22715eb1c834fc55bf11ecf2484d0865"><span class="ne-text">虚拟内存：对程序存储器的抽象</span></li></ul><ul class="ne-ul"><li id="205178dc0bcb920fd8c85c7c3b010b77"><span class="ne-text">进程：对一个正在运行程序的抽象</span></li><li id="d622cbce3a4c328a2322c48ec279ab56"><span class="ne-text">虚拟机：对整个操作系统的抽象</span></li></ul><p id="657df5130cb382aef2c3c6c91108272c" class="ne-p"><br></p><p id="e59e93c8b78c17b38240227d505e21cc" class="ne-p"><span class="ne-text">这些抽象和我们的日常开发息息相关。搞清楚了操作系统是如何抽象的，才能培养我们的抽象性思维和开发思路。</span></p><p id="49e331b04cc221ab606f3858c8793691" class="ne-p"><br></p><p id="a96f950d10e2e4820afcebed6cf4e11a" class="ne-p"><span class="ne-text">很多问题都和操作系统相关，操作系统是解决这些问题的基础。如果你不学习操作系统，可能会想着从框架层面来解决，那是你了解的还不够深入，当你学习了操作系统后，能够培养你的全局性思维。</span></p><p id="ce485e2ee746cb7a676b02e43c98539b" class="ne-p"><br></p><p id="ec2f957b8d14b5f67e2d5112d8c194f2" class="ne-p"><span class="ne-text">学习操作系统我们能够有效的解决</span><code class="ne-code"><span class="ne-text">并发</span></code><span class="ne-text">问题，并发几乎是互联网的重中之重了，这也从侧面说明了学习操作系统的重要性。</span></p><p id="b149befad325016fc7e10b44f43be20d" class="ne-p"><br></p><p id="30f71f05e85cb30d12e23064ca8a482b" class="ne-p"><span class="ne-text">学习操作系统的重点不是让你从头制造一个操作系统，而是告诉你</span><strong><span class="ne-text">操作系统是如何工作的</span></strong><span class="ne-text">，能够让你对计算机底层有所了解，打实你的基础。</span></p><p id="08806088071147ea10f99421320d32a2" class="ne-p"><br></p><p id="58b941ab309d9181cde3a97a32dc6d0f" class="ne-p"><span class="ne-text">相信你一定清楚什么是编程</span></p><p id="f44e3319e6f321d74f1c7f6d708cc27b" class="ne-p"><br></p><p id="ce7a48bbdff10a0f0748d43a4fee9e90" class="ne-p"><strong><span class="ne-text">Data structures + Algorithms = Programming</span></strong></p><p id="175f4024cc2c962517efb5997682de75" class="ne-p"><br></p><p id="f80de5c67c6431f2afbd24dbb2aee176" class="ne-p"><span class="ne-text">操作系统内部会涉及到众多的数据结构和算法描述，能够让你了解算法的基础上，让你编写更优秀的程序。</span></p><p id="5986e2d6bb54fb966e95673f071c0621" class="ne-p"><br></p><p id="0ed49e5e0331cad434e0b8915d4b5cdc" class="ne-p"><span class="ne-text">我认为可以把计算机比作一栋楼</span></p><p id="8c2a4868810afe3b9525b76e29ed5d78" class="ne-p"><br></p><p id="1988bafa6f22a0fcc069c82a692373b7" class="ne-p"><span class="ne-text">计算机的底层相当于就是楼的根基，计算机应用相当于就是楼的外形，而操作系统就相当于是告诉你大楼的构造原理，编写高质量的软件就相当于是告诉你构建一个稳定的房子。</span></p><p id="7014f45e7cc9e806853372bde37b2cfd" class="ne-p"><br></p><h2 id="5e0a7a49"><span class="ne-text">认识操作系统</span></h2><p id="60374c1e79cb4d4843a09fd94637d612" class="ne-p"><br></p><p id="e93269cf41ced53553d81ffb79f9eb8d" class="ne-p"><span class="ne-text">在了解操作系统前，你需要先知道一下什么是计算机系统：现代计算机系统由</span><strong><span class="ne-text">一个或多个处理器、主存、打印机、键盘、鼠标、显示器、网络接口以及各种输入/输出设备构成的系统</span></strong><span class="ne-text">。这些都属于</span><code class="ne-code"><span class="ne-text">硬件</span></code><span class="ne-text">的范畴。我们程序员不会直接和这些硬件打交道，并且每位程序员不可能会掌握所有计算机系统的细节。</span></p><p id="65640a6ae74714a11395c1618a7fc89d" class="ne-p"><br></p><p id="3b4307743edbac97da76c836b32da301" class="ne-p"><span class="ne-text">所以计算机科学家在硬件的基础之上，安装了一层软件，这层软件能够根据用户输入的指令达到控制硬件的效果，从而满足用户的需求，这样的软件称为 </span><code class="ne-code"><span class="ne-text">操作系统</span></code><span class="ne-text">，它的任务就是为用户程序提供一个更好、更简单、更清晰的计算机模型。也就是说，操作系统相当于是一个中间层，为用户层和硬件提供各自的借口，屏蔽了不同应用和硬件之间的差异，达到统一标准的作用。</span></p><p id="fd9511ee26ef4adfd5ce0d2019b4f14e" class="ne-p"><br></p><p id="17ca944a6947bc0c3d6a5de1a9445a06" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829342-133c5955-ce6b-4c7a-9b0e-74e4a24c0f14.png" width="698" id="ahwEU" class="ne-image"></p><p id="6b6913492663205e0e2997de2b4a2e49" class="ne-p"><br></p><p id="f876d76748832add56dda94beed6921e" class="ne-p"><span class="ne-text">上面一个操作系统的简化图，最底层是硬件，硬件包括</span><strong><span class="ne-text">芯片、电路板、磁盘、键盘、显示器</span></strong><span class="ne-text">等我们上面提到的设备，在硬件之上是软件。大部分计算机有两种运行模式：</span><code class="ne-code"><span class="ne-text">内核态</span></code><span class="ne-text"> 和 </span><code class="ne-code"><span class="ne-text">用户态</span></code><span class="ne-text">，软件中最基础的部分是</span><code class="ne-code"><span class="ne-text">操作系统</span></code><span class="ne-text">，它运行在 </span><code class="ne-code"><span class="ne-text">内核态</span></code><span class="ne-text"> 中。操作系统具有硬件的访问权，可以执行机器能够运行的任何指令。软件的其余部分运行在 </span><code class="ne-code"><span class="ne-text">用户态</span></code><span class="ne-text"> 下。</span></p><p id="ebbba497f9d6ba190aa46822d3e0cc7a" class="ne-p"><br></p><p id="d02cfd23d8b7a7af003461286a9cda5e" class="ne-p"><span class="ne-text">在大概了解到操作系统之后，我们先来认识一下硬件都有哪些</span></p><p id="05876b94be1f5d0bd06294890520ce08" class="ne-p"><br></p><h2 id="7f56845d"><span class="ne-text">计算机硬件</span></h2><p id="cce8b5dc91c592c0a00cafe91abb32e9" class="ne-p"><br></p><p id="01ff293d3d3a521947f1a8dd38dcb947" class="ne-p"><span class="ne-text">计算机硬件是计算机的重要组成部分，其中包含了 5 个重要的组成部分：</span><strong><span class="ne-text">运算器、控制器、存储器、输入设备、输出设备</span></strong><span class="ne-text">。</span></p><p id="47deb5600e522c817edbe7abbee25e00" class="ne-p"><br></p><ul class="ne-ul"><li id="23c0ff48cfcf83bd619a8d1744e4fb5c"><code class="ne-code"><span class="ne-text">运算器</span></code><span class="ne-text">：运算器最主要的功能是对数据和信息进行加工和运算。它是计算机中执行算数和各种逻辑运算的部件。运算器的基本运算包括加、减、乘、除、移位等操作，这些是由 </span><code class="ne-code"><span class="ne-text">算术逻辑单元(Arithmetic&amp;logical Unit)</span></code><span class="ne-text"> 实现的。而运算器主要由算数逻辑单元和寄存器构成。</span></li><li id="fbc8179c7d070a8101707bce37bcf93c"><code class="ne-code"><span class="ne-text">控制器</span></code><span class="ne-text">：指按照指定顺序改变主电路或控制电路的部件，它主要起到了控制命令执行的作用，完成协调和指挥整个计算机系统的操作。控制器是由程序计数器、指令寄存器、解码译码器等构成。</span></li></ul><p id="e2a465bc1d98db155979301524d750b7" class="ne-p"><br></p><div class="ne-quote"><p id="68e4847b9cac4d5690f4fe3ddad81505" class="ne-p"><span class="ne-text">运算器和控制器共同组成了 CPU</span></p></div><p id="f40393f314f00082df3f5dac5390d54d" class="ne-p"><br></p><ul class="ne-ul"><li id="d14c467ef32e45959a85f7540068eec0"><code class="ne-code"><span class="ne-text">存储器</span></code><span class="ne-text">：存储器就是计算机的</span><code class="ne-code"><span class="ne-text">记忆设备</span></code><span class="ne-text">，顾名思义，存储器可以保存信息。存储器分为两种，一种是主存，也就是内存，它是 CPU 主要交互对象，还有一种是外存，比如硬盘软盘等。下面是现代计算机系统的存储架构</span></li><li id="0109b65dcc8a312766f7aff0577f9186"><code class="ne-code"><span class="ne-text">输入设备</span></code><span class="ne-text">：输入设备是给计算机获取外部信息的设备，它主要包括键盘和鼠标。</span></li></ul><ul class="ne-ul"><li id="9c9570d30438ade57fc34f62ed6f8d37"><code class="ne-code"><span class="ne-text">输出设备</span></code><span class="ne-text">：输出设备是给用户呈现根据输入设备获取的信息经过一系列的计算后得到显示的设备，它主要包括显示器、打印机等。</span></li></ul><p id="1dce3c1a02c140ec91fee67be8e36769" class="ne-p"><br></p><p id="835a282fa628ddcb34e19f76a5ef697a" class="ne-p"><span class="ne-text">这五部分也是冯诺伊曼的体系结构，它认为计算机必须具有如下功能：</span></p><p id="ad40a6a3aaf0578f66a2c4e20a5720ea" class="ne-p"><br></p><p id="2bbfd0566e38489f15096e54e9a0a614" class="ne-p"><span class="ne-text">把需要的程序和数据送至计算机中。必须具有长期记忆程序、数据、中间结果及最终运算结果的能力。能够完成各种算术、逻辑运算和数据传送等数据加工处理的能力。能够根据需要控制程序走向，并能根据指令控制机器的各部件协调操作。能够按照要求将处理结果输出给用户。</span></p><p id="e1452348578beeb6a16c16494dc88fe4" class="ne-p"><br></p><p id="02f40d52bf1660ca14fc7d9e3ef3826c" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829342-9ed0fc8c-06fb-431d-8db6-2caaca0abc0f.png" width="721" id="qMDVd" class="ne-image"></p><p id="800c9b83462be50fcb8a3f3cdd6e3b94" class="ne-p"><br></p><p id="c4403308930ab6ac5ceca26c06a272c8" class="ne-p"><span class="ne-text">下面是一张 intel 家族产品图，是一个详细的计算机硬件分类，我们在根据图中涉及到硬件进行介绍</span></p><p id="5b37e26e7636153b562b485458fc5ef1" class="ne-p"><br></p><p id="e0fb51cbe771fc7ec497266795295f0e" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829351-810b3b3e-2849-45d3-96c8-62280633f4a6.png" width="747" id="ZSJw7" class="ne-image"></p><p id="48dffd0496d4e7ac46311057c1da3964" class="ne-p"><br></p><ul class="ne-ul"><li id="4edfeb0a52189d8edd1c42763577ee9e"><code class="ne-code"><span class="ne-text">总线(Buses)</span></code><span class="ne-text">：在整个系统中运行的是称为总线的电气管道的集合，这些总线在组件之间来回传输字节信息。通常总线被设计成传送定长的字节块，也就是 </span><code class="ne-code"><span class="ne-text">字(word)</span></code><span class="ne-text">。字中的字节数（字长）是一个基本的系统参数，各个系统中都不尽相同。现在大部分的字都是 4 个字节（32 位）或者 8 个字节（64 位）。</span></li></ul><p id="8722f36b77845d4b9ad537bf6958cb52" class="ne-p"><br></p><p id="c153395442fe97613ef51a62e92903b8" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829372-677cad04-111e-4904-a865-109bf7e95c9c.png" width="731" id="GR4Q2" class="ne-image"></p><p id="56abdc5d1e5b29b2c23b1d995808d341" class="ne-p"><br></p><ul class="ne-ul"><li id="314397e76b319606a6f50e9bc4e4d686"><code class="ne-code"><span class="ne-text">I/O 设备(I/O Devices)</span></code><span class="ne-text">：Input/Output 设备是系统和外部世界的连接。上图中有四类 I/O 设备：用于用户输入的键盘和鼠标，用于用户输出的显示器，一个磁盘驱动用来长时间的保存数据和程序。刚开始的时候，可执行程序就保存在磁盘上。<br /></span><span class="ne-text">每个I/O 设备连接 I/O 总线都被称为</span><code class="ne-code"><span class="ne-text">控制器(controller)</span></code><span class="ne-text"> 或者是 </span><code class="ne-code"><span class="ne-text">适配器(Adapter)</span></code><span class="ne-text">。控制器和适配器之间的主要区别在于封装方式。控制器是 I/O 设备本身或者系统的主印制板电路（通常称作主板）上的芯片组。而适配器则是一块插在主板插槽上的卡。无论组织形式如何，它们的最终目的都是彼此交换信息。</span></li><li id="5ed03e7dde30479bc8253a8f0657526c"><code class="ne-code"><span class="ne-text">主存(Main Memory)</span></code><span class="ne-text">，主存是一个</span><code class="ne-code"><span class="ne-text">临时存储设备</span></code><span class="ne-text">，而不是永久性存储，磁盘是 </span><code class="ne-code"><span class="ne-text">永久性存储</span></code><span class="ne-text"> 的设备。主存既保存程序，又保存处理器执行流程所处理的数据。从物理组成上说，主存是由一系列 </span><code class="ne-code"><span class="ne-text">DRAM(dynamic random access memory)</span></code><span class="ne-text"> 动态随机存储构成的集合。逻辑上说，内存就是一个线性的字节数组，有它唯一的地址编号，从 0 开始。一般来说，组成程序的每条机器指令都由不同数量的字节构成，C 程序变量相对应的数据项的大小根据类型进行变化。比如，在 Linux 的 x86-64 机器上，short 类型的数据需要 2 个字节，int 和 float 需要 4 个字节，而 long 和 double 需要 8 个字节。</span></li></ul><ul class="ne-ul"><li id="78a508a67b0570af15a3f2a6cd9321a0"><code class="ne-code"><span class="ne-text">处理器(Processor)</span></code><span class="ne-text">，</span><code class="ne-code"><span class="ne-text">CPU(central processing unit)</span></code><span class="ne-text"> 或者简单的处理器，是解释（并执行）存储在主存储器中的指令的引擎。处理器的核心大小为一个字的存储设备（或寄存器），称为</span><code class="ne-code"><span class="ne-text">程序计数器(PC)</span></code><span class="ne-text">。在任何时刻，PC 都指向主存中的某条机器语言指令（即含有该条指令的地址）。<br /></span><span class="ne-text">从系统通电开始，直到系统断电，处理器一直在不断地执行程序计数器指向的指令，再更新程序计数器，使其指向下一条指令。处理器根据其指令集体系结构定义的指令模型进行操作。在这个模型中，指令按照严格的顺序执行，执行一条指令涉及执行一系列的步骤。处理器从程序计数器指向的内存中读取指令，解释指令中的位，执行该指令指示的一些简单操作，然后更新程序计数器以指向下一条指令。指令与指令之间可能连续，可能不连续（比如 jmp 指令就不会顺序读取）</span></li></ul><p id="3a4a2a641d1a1c2de5ad66377fca1a30" class="ne-p"><br></p><p id="954dbf0f9e583d9fe45125eabf87296d" class="ne-p"><span class="ne-text">下面是 CPU 可能执行简单操作的几个步骤</span></p><p id="0e7c003044e5b5185d07ad8a3a2b10dc" class="ne-p"><br></p><ul class="ne-ul"><li id="62092432619e0a8617a85dc65506af1f"><code class="ne-code"><span class="ne-text">加载(Load)</span></code><span class="ne-text">：从主存中拷贝一个字节或者一个字到内存中，覆盖寄存器先前的内容</span></li><li id="d70e3efbed128cede95336b4ab29b2c8"><code class="ne-code"><span class="ne-text">存储(Store)</span></code><span class="ne-text">：将寄存器中的字节或字复制到主存储器中的某个位置，从而覆盖该位置的先前内容</span></li></ul><ul class="ne-ul"><li id="34ef14e8474868fc664a6a7a93da783c"><code class="ne-code"><span class="ne-text">操作(Operate)</span></code><span class="ne-text">：把两个寄存器的内容复制到 </span><code class="ne-code"><span class="ne-text">ALU(Arithmetic logic unit)</span></code><span class="ne-text"> 。把两个字进行算术运算，并把结果存储在寄存器中，重写寄存器先前的内容。</span></li></ul><p id="b0921cf26e6a7ca068ba0fe5f7503a34" class="ne-p"><br></p><div class="ne-quote"><p id="24027a2585b5d271d4a70016b7d63879" class="ne-p"><span class="ne-text">算术逻辑单元（ALU）是对数字二进制数执行算术和按位运算的组合数字电子电路。</span></p></div><p id="8875ee2f15790a01020ed498f5331bbf" class="ne-p"><br></p><ul class="ne-ul"><li id="04e09f85f3b9c8a6b2b2cb9643a334b0"><code class="ne-code"><span class="ne-text">跳转(jump)</span></code><span class="ne-text">：从指令中抽取一个字，把这个字复制到</span><code class="ne-code"><span class="ne-text">程序计数器(PC)</span></code><span class="ne-text"> 中，覆盖原来的值</span></li></ul><p id="40564caba44243a15803ea8ea3df1185" class="ne-p"><br></p><h2 id="e5b00e3a"><span class="ne-text">进程和线程</span></h2><p id="89e59462cf5e42126bf7fd69ec455e43" class="ne-p"><br></p><p id="279db931dc6baec0f7e3d4b21b009845" class="ne-p"><span class="ne-text">关于进程和线程，你需要理解下面这张脑图中的重点</span></p><p id="cd6805c2765d2ea297065d329755927f" class="ne-p"><br></p><p id="1d9db861bcf8b6d42bd30feae4ef59ef" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829389-4c3de174-e023-4600-b910-b01112bd2f4c.png" width="734" id="tvXh9" class="ne-image"></p><p id="7b1432c8b72204ee4b825e861b12f98e" class="ne-p"><br></p><h2 id="f88522cf"><span class="ne-text">进程</span></h2><p id="558402d93b3b4cb15182048bf1d22ac0" class="ne-p"><br></p><p id="0989e50fff0d7132d77a4dc9d000527a" class="ne-p"><span class="ne-text">操作系统中最核心的概念就是 </span><code class="ne-code"><span class="ne-text">进程</span></code><span class="ne-text">，进程是对正在运行中的程序的一个抽象。操作系统的其他所有内容都是围绕着进程展开的。</span></p><p id="9858e22f7b813dbde0def60216102845" class="ne-p"><br></p><p id="c6c622877f50d6ecedc29825038afaef" class="ne-p"><span class="ne-text">在多道程序处理的系统中，CPU 会在</span><code class="ne-code"><span class="ne-text">进程</span></code><span class="ne-text">间快速切换，使每个程序运行几十或者几百毫秒。然而，严格意义来说，在某一个瞬间，CPU 只能运行一个进程，然而我们如果把时间定位为 1 秒内的话，它可能运行多个进程。这样就会让我们产生</span><code class="ne-code"><span class="ne-text">并行</span></code><span class="ne-text">的错觉。因为 CPU 执行速度很快，进程间的换进换出也非常迅速，因此我们很难对多个并行进程进行跟踪。所以，操作系统的设计者开发了用于描述并行的一种概念模型（顺序进程），使得并行更加容易理解和分析。</span></p><p id="7ebadc22ea804dc3ce1f6cb4f1faa79a" class="ne-p"><br></p><h3 id="db1832c3"><span class="ne-text">进程模型</span></h3><p id="d840b450465be09e434df4a3dd9a3f21" class="ne-p"><br></p><p id="0f48d95b096b20bbe4d780741e4b7c54" class="ne-p"><span class="ne-text">一个进程就是一个正在执行的程序的实例，进程也包括程序计数器、寄存器和变量的当前值。从概念上来说，每个进程都有各自的虚拟 CPU，但是实际情况是 CPU 会在各个进程之间进行来回切换。</span></p><p id="864056155c24e8395f096ca45cc118d3" class="ne-p"><br></p><p id="89fb82994d781ae23159ddf581f8535e" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829609-9880b940-5163-45d4-8ef6-b559ab53b55d.png" width="455" id="XCIWa" class="ne-image"></p><p id="503dfc349a03926ac40238c181049013" class="ne-p"><br></p><p id="e44e9da7ec98c3c4fe1fdbf7978527ea" class="ne-p"><span class="ne-text">如上图所示，这是一个具有 4 个程序的多道处理程序，在进程不断切换的过程中，程序计数器也在不同的变化。</span></p><p id="8b5b1883046bf13d25c14fb35e4516bb" class="ne-p"><br></p><p id="bbcf34ef348ae4a397c45691442445a7" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829415-2d4059be-d447-4abf-8e77-2df51d6cc6a1.png" width="647" id="CNsvU" class="ne-image"></p><p id="13790759d024503953e9acbb6b0b7ab3" class="ne-p"><br></p><p id="1df3a5508dff94ecadd151924567d3b5" class="ne-p"><span class="ne-text">在上图中，这 4 道程序被抽象为 4 个拥有各自控制流程（即每个自己的程序计数器）的进程，并且每个程序都独立的运行。当然，实际上只有一个物理程序计数器，每个程序要运行时，其逻辑程序计数器会装载到物理程序计数器中。当程序运行结束后，其物理程序计数器就会是真正的程序计数器，然后再把它放回进程的逻辑计数器中。</span></p><p id="ee92f5f090955049ed874d170f8164cb" class="ne-p"><br></p><p id="01f2e5a8184ecf5d05233123e72d116d" class="ne-p"><span class="ne-text">从下图我们可以看到，在观察足够长的一段时间后，所有的进程都运行了，</span><strong><span class="ne-text">但在任何一个给定的瞬间仅有一个进程真正运行</span></strong><span class="ne-text">。</span></p><p id="d183af70e6d683798bd87e78de114558" class="ne-p"><br></p><p id="c50a4b4a34d3cd79990b212d4fbfc543" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829611-a49b5e88-0d0e-42c3-a103-485b6e5c984b.png" width="578" id="Zm8OZ" class="ne-image"></p><p id="77943fe667db14d2a7a7af237a686d74" class="ne-p"><br></p><p id="04d2c0652dedc050608799739b401859" class="ne-p"><span class="ne-text">因此，当我们说一个 CPU 只能真正一次运行一个进程的时候，即使有 2 个核（或 CPU），</span><strong><span class="ne-text">每一个核也只能一次运行一个线程</span></strong><span class="ne-text">。</span></p><p id="5f3805e43ab58c9f9b1421c309983a93" class="ne-p"><br></p><p id="caa82774fc8116b9bb58bada934ea47c" class="ne-p"><span class="ne-text">由于 CPU 会在各个进程之间来回快速切换，所以每个进程在 CPU 中的运行时间是无法确定的。并且当同一个进程再次在 CPU 中运行时，其在 CPU 内部的运行时间往往也是不固定的。</span></p><p id="3833fb1e45d8a553449ff36ab59e4177" class="ne-p"><br></p><p id="802684c9e995650755383da022afcbb1" class="ne-p"><span class="ne-text">这里的关键思想是</span><code class="ne-code"><span class="ne-text">认识到一个进程所需的条件</span></code><span class="ne-text">，进程是某一类特定活动的总和，它有程序、输入输出以及状态。</span></p><p id="2d8841ff912ecc1480e38c0ace860c22" class="ne-p"><br></p><h3 id="ef174e29"><span class="ne-text">进程的创建</span></h3><p id="b69f4a48539edd2c438341715747400d" class="ne-p"><br></p><p id="34e9aef6755ca9dc3103ca25f2c1b94c" class="ne-p"><span class="ne-text">操作系统需要一些方式来创建进程。下面是一些创建进程的方式</span></p><p id="7f056f7e3d9ba5170e3d973201d6e577" class="ne-p"><br></p><ul class="ne-ul"><li id="5525a064edc2a71505894af900e9ae6d"><span class="ne-text">系统初始化（init）：启动操作系统时，通常会创建若干个进程。</span></li><li id="655f909b3a436f6c5d0b2f6ce577f1eb"><span class="ne-text">正在运行的程序执行了创建进程的系统调用（比如 fork）</span></li></ul><ul class="ne-ul"><li id="15f97be6f701a9d2e285ce067dcaa4f5"><span class="ne-text">用户请求创建一个新进程：在许多交互式系统中，输入一个命令或者双击图标就可以启动程序，以上任意一种操作都可以选择开启一个新的进程，在基本的 UNIX 系统中运行 X，新进程将接管启动它的窗口。</span></li><li id="9cbc72a5195fe8f27a433e2cf1537410"><span class="ne-text">初始化一个批处理工作</span></li></ul><p id="734b1131d138309cb8f6e8751b24b0ca" class="ne-p"><br></p><p id="36bcfdf4e40be363d8ec64c87f794ea4" class="ne-p"><span class="ne-text">从技术上讲，在所有这些情况下，让现有流程执行流程是通过创建系统调用来创建新流程的。该进程可能是正在运行的用户进程，是从键盘或鼠标调用的系统进程或批处理程序。这些就是系统调用创建新进程的过程。该系统调用告诉操作系统创建一个新进程，并直接或间接指示在其中运行哪个程序。</span></p><p id="e244fe98d07fe53d8b8b074500bbdbf0" class="ne-p"><br></p><p id="90057922d3b14889ff144902ccb57016" class="ne-p"><span class="ne-text">在 UNIX 中，仅有一个系统调用来创建一个新的进程，这个系统调用就是 </span><code class="ne-code"><span class="ne-text">fork</span></code><span class="ne-text">。这个调用会创建一个与调用进程相关的副本。在 fork 后，一个父进程和子进程会有相同的</span><code class="ne-code"><span class="ne-text">内存映像</span></code><span class="ne-text">，相同的环境字符串和相同的打开文件。</span></p><p id="40b362f7c35397f6ed004f88fc15b256" class="ne-p"><br></p><p id="8ca0bc63e686352cfce2b4e04f846f34" class="ne-p"><span class="ne-text">在 Windows 中，情况正相反，一个简单的 Win32 功能调用 </span><code class="ne-code"><span class="ne-text">CreateProcess</span></code><span class="ne-text">，会处理流程创建并将正确的程序加载到新的进程中。这个调用会有 10 个参数，包括了需要执行的程序、输入给程序的命令行参数、各种安全属性、有关打开的文件是否继承控制位、优先级信息、进程所需要创建的窗口规格以及指向一个结构的指针，在该结构中新创建进程的信息被返回给调用者。</span><strong><span class="ne-text">在 Windows 中，从一开始父进程的地址空间和子进程的地址空间就是不同的</span></strong><span class="ne-text">。</span></p><p id="c760fc897fd7f21d634e5d2c5ab8dd50" class="ne-p"><br></p><h3 id="24ee23f9"><span class="ne-text">进程的终止</span></h3><p id="2a356a15e9c85c0d5ea48bee53e3ee53" class="ne-p"><br></p><p id="a0bc37496955070caffd70767e9fccca" class="ne-p"><span class="ne-text">进程在创建之后，它就开始运行并做完成任务。然而，没有什么事儿是永不停歇的，包括进程也一样。进程早晚会发生终止，但是通常是由于以下情况触发的</span></p><p id="1785949fd41d177bee8df659bfa2541e" class="ne-p"><br></p><ul class="ne-ul"><li id="aef294d171fb8cac4c656d092ad0efd6"><code class="ne-code"><span class="ne-text">正常退出(自愿的)</span></code><span class="ne-text"> ： 多数进程是由于完成了工作而终止。当编译器完成了所给定程序的编译之后，编译器会执行一个系统调用告诉操作系统它完成了工作。这个调用在 UNIX 中是 </span><code class="ne-code"><span class="ne-text">exit</span></code><span class="ne-text"> ，在 Windows 中是 </span><code class="ne-code"><span class="ne-text">ExitProcess</span></code><span class="ne-text">。</span></li><li id="64851a07fdbb717aabe3e48e41e69418"><code class="ne-code"><span class="ne-text">错误退出(自愿的)</span></code><span class="ne-text">：比如执行一条不存在的命令，于是编译器就会提醒并退出。</span></li></ul><ul class="ne-ul"><li id="7cdd5fd1594ea716be38ce11cb3a10e2"><code class="ne-code"><span class="ne-text">严重错误(非自愿的)</span></code></li><li id="6babe1237002ef73948160629e13b605"><code class="ne-code"><span class="ne-text">被其他进程杀死(非自愿的)</span></code><span class="ne-text"> ： 某个进程执行系统调用告诉操作系统杀死某个进程。在 UNIX 中，这个系统调用是 kill。在 Win32 中对应的函数是 </span><code class="ne-code"><span class="ne-text">TerminateProcess</span></code><span class="ne-text">（注意不是系统调用）。</span></li></ul><p id="5bd73c750876718c6aca8ef216af6b54" class="ne-p"><br></p><h3 id="59a65ba2"><span class="ne-text">进程的层次结构</span></h3><p id="0bb47166b3c322ba29b0f204223d5fd0" class="ne-p"><br></p><p id="7f07789281882e50c0fc300b3ca03f9c" class="ne-p"><span class="ne-text">在一些系统中，当一个进程创建了其他进程后，父进程和子进程就会以某种方式进行关联。子进程它自己就会创建更多进程，从而形成一个进程层次结构。</span></p><p id="829195fa901cce4553d63f442daebea8" class="ne-p"><br></p><h4 id="9a0a3bf9"><span class="ne-text">UNIX 进程体系</span></h4><p id="1c753e33d5a50d5c91e575f5f321a978" class="ne-p"><br></p><p id="71620443f7be78f9d927a3e3caee47a6" class="ne-p"><span class="ne-text">在 UNIX 中，进程和它的所有子进程以及子进程的子进程共同组成一个进程组。当用户从键盘中发出一个信号后，该信号被发送给当前与键盘相关的进程组中的所有成员（它们通常是在当前窗口创建的所有活动进程）。每个进程可以分别捕获该信号、忽略该信号或采取默认的动作，即被信号 kill 掉。整个操作系统中所有的进程都隶属于一个单个以 init 为根的进程树。</span></p><p id="dcf543e13cb6e080adafb4af20eb2588" class="ne-p"><br></p><p id="c4605dff5b082200add96857699ecbb3" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829468-bff503cb-cf97-4853-aca3-35db5bb67312.png" width="615" id="TUggO" class="ne-image"></p><p id="3fa2c3bfabb4e38822ab985e931554cb" class="ne-p"><br></p><h4 id="5d016720"><span class="ne-text">Windows 进程体系</span></h4><p id="fb9194b7b563522aaf65f5e7877f5d9d" class="ne-p"><br></p><p id="45b7deda743f60e53beed2089b218a3c" class="ne-p"><span class="ne-text">相反，Windows 中没有进程层次的概念，Windows 中所有进程都是平等的，唯一类似于层次结构的是在创建进程的时候，父进程得到一个特别的令牌（称为句柄），该句柄可以用来控制子进程。然而，这个令牌可能也会移交给别的操作系统，这样就不存在层次结构了。而在 UNIX 中，进程不能剥夺其子进程的 </span><code class="ne-code"><span class="ne-text">进程权</span></code><span class="ne-text">。（这样看来，还是 Windows 比较</span><code class="ne-code"><span class="ne-text">渣</span></code><span class="ne-text">）。</span></p><p id="248c55e3f445201dd7dbeca56a3f9b00" class="ne-p"><br></p><h3 id="fe290ad3"><span class="ne-text">进程状态</span></h3><p id="ad4ee3dd92ab5c79b1c5cbc43c5a3dba" class="ne-p"><br></p><p id="4d829862b4033af7e64e431f9c777402" class="ne-p"><span class="ne-text">尽管每个进程是一个独立的实体，有其自己的程序计数器和内部状态，但是，进程之间仍然需要相互帮助。当一个进程开始运行时，它可能会经历下面这几种状态</span></p><p id="a7817b1f61e8d565b373c264359e44f9" class="ne-p"><br></p><p id="c8b03ba9b3b2b9903b85c39e72dd8a91" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829472-6b2e277f-f4b9-4f38-805d-e9ac73f33129.png" width="734" id="nVHjc" class="ne-image"></p><p id="08028f8436803d51ec1e716d72fe2310" class="ne-p"><br></p><p id="82bce743c56b29faca92df0ac4052b5e" class="ne-p"><span class="ne-text">图中会涉及三种状态</span></p><p id="9f699dbeb42df9e8d0551ca5d9171c73" class="ne-p"><br></p><ol class="ne-ol"><li id="aec08485f34560a4b7b6abadb75ef79d"><code class="ne-code"><span class="ne-text">运行态</span></code><span class="ne-text">，运行态指的就是进程实际占用 CPU 时间片运行时</span></li><li id="381d58aae0b72332585ff6985de97c5e"><code class="ne-code"><span class="ne-text">就绪态</span></code><span class="ne-text">，就绪态指的是可运行，但因为其他进程正在运行而处于就绪状态</span></li></ol><ol start="3" class="ne-ol"><li id="65a92d0ec3b2adb54401c8528d0e23b6"><code class="ne-code"><span class="ne-text">阻塞态</span></code><span class="ne-text">，除非某种外部事件发生，否则进程不能运行</span></li></ol><p id="081c0d4cc15fd01c6d95209ecec0c1e0" class="ne-p"><br></p><h3 id="27fe55d6"><span class="ne-text">进程的实现</span></h3><p id="92b3b630daddd7d1ddb5cf95b49e523c" class="ne-p"><br></p><p id="7837b0696feedfcbb97df8ce125c1217" class="ne-p"><span class="ne-text">操作系统为了执行进程间的切换，会维护着一张表，这张表就是 </span><code class="ne-code"><span class="ne-text">进程表(process table)</span></code><span class="ne-text">。每个进程占用一个进程表项。该表项包含了进程状态的重要信息，包括程序计数器、堆栈指针、内存分配状况、所打开文件的状态、账号和调度信息，以及其他在进程由运行态转换到就绪态或阻塞态时所必须保存的信息。</span></p><p id="d3d512edb88e5511bf9ce1530b15e0f8" class="ne-p"><br></p><p id="650b4ebec7f6635f2b6ff4cc027a95fe" class="ne-p"><span class="ne-text">下面展示了一个典型系统中的关键字段</span></p><p id="023ffbba17dc27adc6ff1d21fb9e45cf" class="ne-p"><br></p><p id="abf3e59185ee55f8fe152e201cecaf06" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829487-6d8a6e92-d068-48a8-b5a0-9e5b74f9ab3f.png" width="749" id="Sr874" class="ne-image"></p><p id="4c8283b21ecd2b4d4d8121fed458946c" class="ne-p"><br></p><p id="4fe136f6a62abb9ab8066e3c6085988c" class="ne-p"><span class="ne-text">第一列内容与</span><code class="ne-code"><span class="ne-text">进程管理</span></code><span class="ne-text">有关，第二列内容与 </span><code class="ne-code"><span class="ne-text">存储管理</span></code><span class="ne-text">有关，第三列内容与</span><code class="ne-code"><span class="ne-text">文件管理</span></code><span class="ne-text">有关。</span></p><p id="93ffa9020d0b8573b25e9ad3d4211dbc" class="ne-p"><br></p><p id="6a6879f2608015b94561ab03cca29275" class="ne-p"><span class="ne-text">现在我们应该对进程表有个大致的了解了，就可以在对单个 CPU 上如何运行多个顺序进程的错觉做更多的解释。与每一 I/O 类相关联的是一个称作 </span><code class="ne-code"><span class="ne-text">中断向量(interrupt vector)</span></code><span class="ne-text"> 的位置（靠近内存底部的固定区域）。它包含中断服务程序的入口地址。假设当一个磁盘中断发生时，用户进程 3 正在运行，则中断硬件将程序计数器、程序状态字、有时还有一个或多个寄存器压入堆栈，计算机随即跳转到中断向量所指示的地址。这就是硬件所做的事情。然后软件就随即接管一切剩余的工作。</span></p><p id="d944c12bcb8d1fb777afe0c76b5d4dfe" class="ne-p"><br></p><p id="67925a50acf5cec75da68f7c4fa97604" class="ne-p"><span class="ne-text">当中断结束后，操作系统会调用一个 C 程序来处理中断剩下的工作。在完成剩下的工作后，会使某些进程就绪，接着调用调度程序，决定随后运行哪个进程。然后将控制权转移给一段汇编语言代码，为当前的进程装入寄存器值以及内存映射并启动该进程运行，下面显示了中断处理和调度的过程。</span></p><p id="e9c2e6a19d20c8e9d745ba1ede98bda0" class="ne-p"><br></p><ol class="ne-ol"><li id="bcfd5526252f62185fad5607256d5a21"><span class="ne-text">硬件压入堆栈程序计数器等</span></li><li id="7fe994f519b0faf5566db73640fc6be1"><span class="ne-text">硬件从中断向量装入新的程序计数器</span></li></ol><ol start="3" class="ne-ol"><li id="c934d43af74c443845b28312159ee1ac"><span class="ne-text">汇编语言过程保存寄存器的值</span></li><li id="82e923138b451b98f625e89cbd0b6bca"><span class="ne-text">汇编语言过程设置新的堆栈</span></li></ol><ol start="5" class="ne-ol"><li id="4f5334e81f1d5a5f1e64fda967d5fca0"><span class="ne-text">C 中断服务器运行（典型的读和缓存写入）</span></li><li id="94f7067d3f873488b2a017df5a72d5ce"><span class="ne-text">调度器决定下面哪个程序先运行</span></li></ol><ol start="7" class="ne-ol"><li id="eff3e73d42a5e05ab6c5e185f9a05120"><span class="ne-text">C 过程返回至汇编代码</span></li><li id="724b882cbe84a93d767c38842f66357b"><span class="ne-text">汇编语言过程开始运行新的当前进程</span></li></ol><p id="60ef497df3321edea7d108cdcc4053d3" class="ne-p"><br></p><p id="38f27f3718510227db767b00debb1939" class="ne-p"><span class="ne-text">一个进程在执行过程中可能被中断数千次，但关键每次中断后，被中断的进程都返回到与中断发生前完全相同的状态。</span></p><p id="51999800e2ccce806ac92346816458e4" class="ne-p"><br></p><h2 id="d276123c"><span class="ne-text">线程</span></h2><p id="9f602f2dc988af4bde245a6ccdf7ff13" class="ne-p"><br></p><p id="55772d1f565f2ecbfcfc09a8bc616c44" class="ne-p"><span class="ne-text">在传统的操作系统中，每个进程都有一个地址空间和一个控制线程。事实上，这是大部分进程的定义。不过，在许多情况下，经常存在同一地址空间中运行多个控制线程的情形，这些线程就像是分离的进程。下面我们就着重探讨一下什么是线程</span></p><p id="ea8fb1edc20cb64f1273a9310aa3751d" class="ne-p"><br></p><h3 id="b2c46474"><span class="ne-text">线程的使用</span></h3><p id="ab116c151e8ba219bf8ae6f68ab5ede4" class="ne-p"><br></p><p id="1ce2c19e90381851b1534560e92b51d3" class="ne-p"><span class="ne-text">或许这个疑问也是你的疑问，为什么要在进程的基础上再创建一个线程的概念，准确的说，这其实是进程模型和线程模型的讨论，回答这个问题，可能需要分三步来回答</span></p><p id="e8a5e2e598ab662e0607b58901d9758e" class="ne-p"><br></p><ul class="ne-ul"><li id="a68004fabbe64f1be4294491ce6943cc"><span class="ne-text">多线程之间会共享同一块地址空间和所有可用数据的能力，这是进程所不具备的</span></li><li id="c16d784bb6036482a74a4f2816dcd734"><span class="ne-text">线程要比进程</span><code class="ne-code"><span class="ne-text">更轻量级</span></code><span class="ne-text">，由于线程更轻，所以它比进程更容易创建，也更容易撤销。在许多系统中，创建一个线程要比创建一个进程快 10 - 100 倍。</span></li></ul><ul class="ne-ul"><li id="124456cced3a6934d0dbc4c8b6e588fa"><span class="ne-text">第三个原因可能是性能方面的探讨，如果多个线程都是 CPU 密集型的，那么并不能获得性能上的增强，但是如果存在着大量的计算和大量的 I/O 处理，拥有多个线程能在这些活动中彼此重叠进行，从而会加快应用程序的执行速度</span></li></ul><p id="969485792d07970e248a25c707ae81c3" class="ne-p"><br></p><h3 id="eb3f9151"><span class="ne-text">经典的线程模型</span></h3><p id="0f4cd5ac358f2cd5d9e6305faa1d2f19" class="ne-p"><br></p><p id="f4399e0137f899b35f0a99796f458cee" class="ne-p"><span class="ne-text">进程中拥有一个执行的线程，通常简写为 </span><code class="ne-code"><span class="ne-text">线程(thread)</span></code><span class="ne-text">。线程会有程序计数器，用来记录接着要执行哪一条指令；线程实际上 CPU 上调度执行的实体。</span></p><p id="9f6e4eaf1534a378bf8231492af63f4b" class="ne-p"><br></p><p id="cf636b0793325e7d330a7e6769b03700" class="ne-p"><span class="ne-text">下图我们可以看到三个传统的进程，每个进程有自己的地址空间和单个控制线程。每个线程都在不同的地址空间中运行</span></p><p id="90ee1e4c78f7c3f9bacfeddf50cce64c" class="ne-p"><br></p><p id="6caf3b47091b19d6f3453533334c3136" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829491-73cfd311-e3e5-4381-886b-f904f3c8ca5c.png" width="658" id="lfuB1" class="ne-image"></p><p id="8ba295dcb96dca3a3572f16973748711" class="ne-p"><br></p><p id="1644b4a344140948fb4c97c0bd2cd7df" class="ne-p"><span class="ne-text">下图中，我们可以看到有一个进程三个线程的情况。每个线程都在相同的地址空间中运行。</span></p><p id="a6c4bee1d01b8aa5be0eadc12cbe618b" class="ne-p"><br></p><p id="af6501c631d07365f00006589b930913" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829501-7e5370fc-b9ec-4804-a862-9c86e00bf231.png" width="640" id="uVJR7" class="ne-image"></p><p id="181be89a9207f89b1c00524cbbab1e00" class="ne-p"><br></p><p id="39810993b510056e76c4a3b570b37cd2" class="ne-p"><span class="ne-text">线程不像是进程那样具备较强的独立性。同一个进程中的所有线程都会有完全一样的地址空间，这意味着它们也共享同样的全局变量。由于每个线程都可以访问进程地址空间内每个内存地址，</span><strong><span class="ne-text">因此一个线程可以读取、写入甚至擦除另一个线程的堆栈</span></strong><span class="ne-text">。线程之间除了共享同一内存空间外，还具有如下不同的内容</span></p><p id="e6b58ebee8ff091f855004f3afe8523d" class="ne-p"><br></p><p id="9cf3875d0759c13afa2efc6cbceea3c6" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829530-1ce4e3bb-f3b4-4fae-bd6b-2a09cb86e2d3.png" width="583" id="GpbmQ" class="ne-image"></p><p id="5d5826853af545f770aa24d16ca10997" class="ne-p"><br></p><p id="33ecc512185771f5ff75d82ee58a1d69" class="ne-p"><span class="ne-text">上图左边的是同一个进程中</span><code class="ne-code"><span class="ne-text">每个线程共享</span></code><span class="ne-text">的内容，上图右边是</span><code class="ne-code"><span class="ne-text">每个线程</span></code><span class="ne-text">中的内容。也就是说左边的列表是进程的属性，右边的列表是线程的属性。</span></p><p id="ad5fb01708e084b0184f6e5dc56062b2" class="ne-p"><br></p><p id="1e26ec6c5f413fc1bd832038d6fce9ce" class="ne-p"><strong><span class="ne-text">线程之间的状态转换和进程之间的状态转换是一样的</span></strong><span class="ne-text">。</span></p><p id="7c1105577d60fc2e15dc30ee4592d372" class="ne-p"><br></p><p id="f4511cae93abe3026efa2cf3757360d5" class="ne-p"><span class="ne-text">每个线程都会有自己的堆栈，如下图所示</span></p><p id="8adbcedd049bb3edc3764bede487c847" class="ne-p"><br></p><p id="27f1bbcde67b84d60351835e8ce7750b" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829586-41932660-4ab5-42e2-bbb1-bbd660b183f6.png" width="682" id="WnFPn" class="ne-image"></p><p id="0e816dfec54ca3e832073ef02dbeeb6b" class="ne-p"><br></p><h4 id="6632fae6"><span class="ne-text">线程系统调用</span></h4><p id="8626c74ea022a987992b0c1fbdb792b3" class="ne-p"><br></p><p id="eef4b592177acc7598b410c9dcbd2692" class="ne-p"><span class="ne-text">进程通常会从当前的某个单线程开始，然后这个线程通过调用一个库函数（比如 </span><code class="ne-code"><span class="ne-text">thread_create</span></code><span class="ne-text"> ）创建新的线程。线程创建的函数会要求指定新创建线程的名称。创建的线程通常都返回一个线程标识符，该标识符就是新线程的名字。</span></p><p id="699815b2cc0f7cb21f43b7de2be07cdf" class="ne-p"><br></p><p id="a7c9a0127beb8b9c706078fde4ff4ee2" class="ne-p"><span class="ne-text">当一个线程完成工作后，可以通过调用一个函数（比如 </span><code class="ne-code"><span class="ne-text">thread_exit</span></code><span class="ne-text">）来退出。紧接着线程消失，状态变为终止，不能再进行调度。在某些线程的运行过程中，可以通过调用函数例如 </span><code class="ne-code"><span class="ne-text">thread_join</span></code><span class="ne-text"> ，表示一个线程可以等待另一个线程退出。这个过程阻塞调用线程直到等待特定的线程退出。在这种情况下，线程的创建和终止非常类似于进程的创建和终止。</span></p><p id="f4a5500946aabb17ea44c2558f19c2ca" class="ne-p"><br></p><p id="9629c5ac74f429f3955418e20f72cec0" class="ne-p"><span class="ne-text">另一个常见的线程是调用 </span><code class="ne-code"><span class="ne-text">thread_yield</span></code><span class="ne-text">，它允许线程自动放弃 CPU 从而让另一个线程运行。这样一个调用还是很重要的，因为不同于进程，线程是无法利用时钟中断强制让线程让出 CPU 的。</span></p><p id="8fdc0d7830858c997bfd188739ed7afc" class="ne-p"><br></p><h3 id="b1d15c6e"><span class="ne-text">POSIX 线程</span></h3><p id="db401dc44303ec105e67be5c2fc389c4" class="ne-p"><br></p><p id="dfd97f521bd61893a8aeabdb0535fa87" class="ne-p"><code class="ne-code"><span class="ne-text">POSIX 线程 通常称为 pthreads</span></code><span class="ne-text">是一种独立于语言而存在的执行模型，以及并行执行模型。</span></p><p id="1bf64c399339628fb7957855f494f71f" class="ne-p"><br></p><p id="e49542eca979134cc9c9f75f2f329a24" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829568-3bded50a-8029-4644-9e42-c2c6ddf60ca1.png" width="639" id="ZELdp" class="ne-image"></p><p id="fe7cfff22c57936dee6dd54e80f17015" class="ne-p"><br></p><p id="c50783d2ba22cd47838f774866f90191" class="ne-p"><span class="ne-text">它允许程序控制时间上重叠的多个不同的工作流程。每个工作流程都称为一个线程，可以通过调用 POSIX Threads API 来实现对这些流程的创建和控制。可以把它理解为线程的标准。</span></p><p id="6ae632f03f369eff8d56f27dbe210647" class="ne-p"><br></p><div class="ne-quote"><p id="cd16084d7837c5073a2fa1c2189d0c10" class="ne-p"><span class="ne-text">POSIX Threads 的实现在许多类似且符合POSIX的操作系统上可用，例如 </span><strong><span class="ne-text">FreeBSD、NetBSD、OpenBSD、Linux、macOS、Android、Solaris</span></strong><span class="ne-text">，它在现有 Windows API 之上实现了</span><strong><span class="ne-text">pthread</span></strong><span class="ne-text">。</span></p><p id="4bb522cf8ceadf992cc37fe01affca2b" class="ne-p"><span class="ne-text">IEEE 是世界上最大的技术专业组织，致力于为人类的利益而发展技术。</span></p></div><table id="d6ca4def" class="ne-table" style="width: 750px"><tbody><tr style="height: 33px"><td width="375"><p id="uf5bca78d" class="ne-p"><span class="ne-text">线程调用</span></p></td><td width="375"><p id="u066f4fdf" class="ne-p"><span class="ne-text">描述</span></p></td></tr><tr style="height: 33px"><td width="375"><p id="u96230ab3" class="ne-p"><span class="ne-text">pthread_create</span></p></td><td width="375"><p id="uff601278" class="ne-p"><span class="ne-text">创建一个新线程</span></p></td></tr><tr style="height: 33px"><td width="375"><p id="ucb6f1a7c" class="ne-p"><span class="ne-text">pthread_exit</span></p></td><td width="375"><p id="u2c6ae04a" class="ne-p"><span class="ne-text">结束调用的线程</span></p></td></tr><tr style="height: 33px"><td width="375"><p id="u2219439b" class="ne-p"><span class="ne-text">pthread_join</span></p></td><td width="375"><p id="ub02eaf4e" class="ne-p"><span class="ne-text">等待一个特定的线程退出</span></p></td></tr><tr style="height: 33px"><td width="375"><p id="u2804c355" class="ne-p"><span class="ne-text">pthread_yield</span></p></td><td width="375"><p id="u60922575" class="ne-p"><span class="ne-text">释放 CPU 来运行另外一个线程</span></p></td></tr><tr style="height: 33px"><td width="375"><p id="u9eb11640" class="ne-p"><span class="ne-text">pthread_attr_init</span></p></td><td width="375"><p id="ue5ad1df6" class="ne-p"><span class="ne-text">创建并初始化一个线程的属性结构</span></p></td></tr><tr style="height: 33px"><td width="375"><p id="u1ea06b78" class="ne-p"><span class="ne-text">pthread_attr_destory</span></p></td><td width="375"><p id="ub04e7306" class="ne-p"><span class="ne-text">删除一个线程的属性结构</span></p></td></tr></tbody></table><p id="f6a1a765e184a87a3cf062bd79112ab3" class="ne-p"><br></p><p id="964bff2b1f299a8123c4564cf6c32159" class="ne-p"><span class="ne-text">所有的 Pthreads 都有特定的属性，每一个都含有标识符、一组寄存器（包括程序计数器）和一组存储在结构中的属性。这个属性包括堆栈大小、调度参数以及其他线程需要的项目。</span></p><p id="8557a0d1a9c2d19f43f23a025b5b1e9d" class="ne-p"><br></p><h3 id="15ab0a3d"><span class="ne-text">线程实现</span></h3><p id="5e3030d48820fc3f997c9fc07867d415" class="ne-p"><br></p><p id="bfec13543c9248ed01602aac8986d3b1" class="ne-p"><span class="ne-text">主要有三种实现方式</span></p><p id="6ca771c1e461f72989e0d3259a67f52e" class="ne-p"><br></p><ul class="ne-ul"><li id="7c27924bef969657528fcdaaa609f955"><span class="ne-text">在用户空间中实现线程；</span></li><li id="600f350c1424b2986a7804ec78dc04b3"><span class="ne-text">在内核空间中实现线程；</span></li></ul><ul class="ne-ul"><li id="edbb0a2cf6d6e63294285f0299dda3fc"><span class="ne-text">在用户和内核空间中混合实现线程。</span></li></ul><p id="4c6f55a17135de2b2291efc72cead4d1" class="ne-p"><br></p><p id="83eff6a3553c469021aa6db1dceec0d9" class="ne-p"><span class="ne-text">下面我们分开讨论一下</span></p><p id="9572d3617e09301baa3ee984f1c92f5c" class="ne-p"><br></p><h4 id="9f307c8e"><span class="ne-text">在用户空间中实现线程</span></h4><p id="42e095da41230932ab0833eed35e4a62" class="ne-p"><br></p><p id="95fe62305076810bbdbc0548d37541ba" class="ne-p"><span class="ne-text">第一种方法是把整个线程包放在用户空间中，内核对线程一无所知，它不知道线程的存在。所有的这类实现都有同样的通用结构</span></p><p id="276d2eb1fdc4a41e4173ea11b35f5cc2" class="ne-p"><br></p><p id="7a5fa3aa9f73d81d2fb09d64a02e4f3b" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829565-1733358e-dbe8-4e1e-ab32-50b95d98a6e3.png" width="599" id="uVF3u" class="ne-image"></p><p id="994599839f8a0493163453339bc36bf1" class="ne-p"><br></p><p id="eff4df6ded311edd97d79b039f96d79d" class="ne-p"><span class="ne-text">线程在运行时系统之上运行，运行时系统是管理线程过程的集合，包括前面提到的四个过程： pthread_create, pthread_exit, pthread_join 和 pthread_yield。</span></p><p id="9f01a3a063f4e73adb15e108ca6a7eea" class="ne-p"><br></p><h3 id="78ffb122"><span class="ne-text">在内核中实现线程</span></h3><p id="c1f41f5788707afdebb1adada6659535" class="ne-p"><br></p><p id="31823d31c3e4c8a1d3e9c4053e65166f" class="ne-p"><span class="ne-text">当某个线程希望创建一个新线程或撤销一个已有线程时，它会进行一个系统调用，这个系统调用通过对线程表的更新来完成线程创建或销毁工作。</span></p><p id="70941018fd44652b5554c9be911f4bb4" class="ne-p"><br></p><p id="74b4ad9f0cf425a882479e7b9fccc210" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829600-91569966-c35c-4db1-858b-f7fcae7729c3.png" width="600" id="hh20v" class="ne-image"></p><p id="9be5d4ee6254ece2371dae576e1ce5ed" class="ne-p"><br></p><p id="ca2c3a358734c3ac5a68fd4da8a6f6d1" class="ne-p"><span class="ne-text">内核中的线程表持有每个线程的寄存器、状态和其他信息。这些信息和用户空间中的线程信息相同，但是位置却被放在了内核中而不是用户空间中。另外，内核还维护了一张进程表用来跟踪系统状态。</span></p><p id="5d51544c741cef09fd2074b01c87b917" class="ne-p"><br></p><p id="446a4e049bb4f8b4e6d08161a35277b5" class="ne-p"><span class="ne-text">所有能够阻塞的调用都会通过系统调用的方式来实现，当一个线程阻塞时，内核可以进行选择，是运行在同一个进程中的另一个线程（如果有就绪线程的话）还是运行一个另一个进程中的线程。但是在用户实现中，运行时系统始终运行自己的线程，直到内核剥夺它的 CPU 时间片（或者没有可运行的线程存在了）为止。</span></p><p id="15f0ff35b5546621cdfa2a7240307b67" class="ne-p"><br></p><h3 id="26e17fd6"><span class="ne-text">混合实现</span></h3><p id="b5ee17fce17b6cdbe43273512e22ecb9" class="ne-p"><br></p><p id="63976c7cc6bac642a93b4f69c61c73b7" class="ne-p"><span class="ne-text">结合用户空间和内核空间的优点，设计人员采用了一种</span><code class="ne-code"><span class="ne-text">内核级线程</span></code><span class="ne-text">的方式，然后将用户级线程与某些或者全部内核线程多路复用起来</span></p><p id="a817d6cedfd6372e5126592d084db2cd" class="ne-p"><br></p><p id="065866846bc241326c1231ae19b4e8c3" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829624-481cc859-db6d-4516-8dc4-6ea9f958c022.png" width="647" id="z1E6R" class="ne-image"></p><p id="80cc0ff3caab76b5b04463be351d36e6" class="ne-p"><br></p><p id="46d3024237e6c858dddb4620413c3f9d" class="ne-p"><span class="ne-text">在这种模型中，编程人员可以自由控制用户线程和内核线程的数量，具有很大的灵活度。采用这种方法，内核只识别内核级线程，并对其进行调度。其中一些内核级线程会被多个用户级线程多路复用。</span></p><p id="cafd9a2584fc98d82c47a69f4eb4a44a" class="ne-p"><br></p><h2 id="13747cb9"><span class="ne-text">进程间通信</span></h2><p id="89f23068c1d014c8ae7379c1ee4ff256" class="ne-p"><br></p><p id="ae233faa7b8916909e1f871f4d9ceb06" class="ne-p"><span class="ne-text">进程是需要频繁的和其他进程进行交流的。下面我们会一起讨论有关 </span><code class="ne-code"><span class="ne-text">进程间通信(Inter Process Communication, IPC)</span></code><span class="ne-text"> 的问题。大致来说，进程间的通信机制可以分为 6 种</span></p><p id="dfe97806c12fe7f893011f144d1a8165" class="ne-p"><br></p><p id="bc4ca741dee963edba6ac3cea886b95e" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829616-22b9e251-36fa-4a65-8102-204b899c01ca.png" width="772" id="WxiTX" class="ne-image"></p><p id="13d5bccfbad5a2bc08c0ae4830359792" class="ne-p"><br></p><p id="2cc0c61db915799a3dab5663db6d75de" class="ne-p"><span class="ne-text">下面我们分别对其进行概述</span></p><p id="7666fa53af51829ddb54296233381012" class="ne-p"><br></p><h3 id="cf09c6fb"><span class="ne-text">信号 signal</span></h3><p id="f2d6f42f7be9db0ef2e31f6e6bec3b21" class="ne-p"><br></p><p id="f56f26bead6812e39ebd085c6282a029" class="ne-p"><span class="ne-text">信号是 UNIX 系统最先开始使用的进程间通信机制，因为 Linux 是继承于 UNIX 的，所以 Linux 也支持信号机制，通过向一个或多个进程发送</span><code class="ne-code"><span class="ne-text">异步事件信号</span></code><span class="ne-text">来实现，信号可以从键盘或者访问不存在的位置等地方产生；信号通过 shell 将任务发送给子进程。</span></p><p id="77a00de06ad8a313624bebd7197daab0" class="ne-p"><br></p><p id="c3a46e2f457eb12ac07b2735125ed640" class="ne-p"><span class="ne-text">你可以在 Linux 系统上输入 </span><code class="ne-code"><span class="ne-text">kill -l</span></code><span class="ne-text"> 来列出系统使用的信号，下面是我提供的一些信号</span></p><p id="b6d3f3b7ee125b00a6385d6a05e9c790" class="ne-p"><br></p><p id="c332f05576b8b21614e769f51765e046" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829652-e25e8aaa-523f-49e7-91a6-13af7872483a.png" width="736" id="iFTA7" class="ne-image"></p><p id="e94793bcd68a9f5383857361c260794e" class="ne-p"><br></p><p id="1e0b0c18d976e2cb412fe31f463b0b70" class="ne-p"><span class="ne-text">进程可以选择忽略发送过来的信号，但是有两个是不能忽略的：</span><code class="ne-code"><span class="ne-text">SIGSTOP</span></code><span class="ne-text"> 和 </span><code class="ne-code"><span class="ne-text">SIGKILL</span></code><span class="ne-text"> 信号。SIGSTOP 信号会通知当前正在运行的进程执行关闭操作，SIGKILL 信号会通知当前进程应该被杀死。除此之外，进程可以选择它想要处理的信号，进程也可以选择阻止信号，如果不阻止，可以选择自行处理，也可以选择进行内核处理。如果选择交给内核进行处理，那么就执行默认处理。</span></p><p id="f463e7202028da7ee34fa86439d2d0bc" class="ne-p"><br></p><p id="97307b7fc6bb2a3d3a6c7415c2d1a58f" class="ne-p"><span class="ne-text">操作系统会中断目标程序的进程来向其发送信号、在任何非原子指令中，执行都可以中断，如果进程已经注册了新号处理程序，那么就执行进程，如果没有注册，将采用默认处理的方式。</span></p><p id="f0d78f86dcc225fbef3bc7ca4b9c2eae" class="ne-p"><br></p><h3 id="79c52210"><span class="ne-text">管道 pipe</span></h3><p id="e581372206c587ee595cd8880c7fe68c" class="ne-p"><br></p><p id="7d6b1edbc43ab03cd76e374db13b3d79" class="ne-p"><span class="ne-text">Linux 系统中的进程可以通过建立管道 pipe 进行通信</span></p><p id="8ccfe4d2fc3be296206ee867a830076f" class="ne-p"><br></p><p id="e4d7d6e07cdeb822a190325504719442" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829658-0cfbf5f9-97b3-4972-8205-7953cdab82b7.png" width="729" id="UyA6r" class="ne-image"></p><p id="b1d8ec45d3bd885ef634b40206c6be13" class="ne-p"><br></p><p id="94564611bd47217e8819b4129456507f" class="ne-p"><span class="ne-text">在两个进程之间，可以建立一个通道，一个进程向这个通道里写入字节流，另一个进程从这个管道中读取字节流。管道是同步的，当进程尝试从空管道读取数据时，该进程会被阻塞，直到有可用数据为止。shell 中的</span><code class="ne-code"><span class="ne-text">管线 pipelines</span></code><span class="ne-text"> 就是用管道实现的，当 shell 发现输出</span></p><p id="f6df0669510949bc580d81d8ca93eb12" class="ne-p"><br></p><pre><code>sort &lt;f | head</code></pre><p id="41e8a4181b2a6e81046de5357f803804" class="ne-p"><br></p><p id="b87e76fec29ab8fc296c13120144f137" class="ne-p"><span class="ne-text">它会创建两个进程，一个是 sort，一个是 head，sort，会在这两个应用程序之间建立一个管道使得 sort 进程的标准输出作为 head 程序的标准输入。sort 进程产生的输出就不用写到文件中了，如果管道满了系统会停止 sort 以等待 head 读出数据</span></p><p id="2dde603cd64cf50dcaf8d9d7df59a61f" class="ne-p"><br></p><p id="5e1bfd07d47f7ada8a6d809c79141d39" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829684-0f55014e-302f-4dbe-9ea8-9ee4d6c9fdeb.png" width="488" id="irplH" class="ne-image"></p><p id="5e74f9a53149c90944e0bad4389f82c3" class="ne-p"><br></p><p id="57493598a8059c5e29d760919d110090" class="ne-p"><span class="ne-text">管道实际上就是 </span><code class="ne-code"><span class="ne-text">|</span></code><span class="ne-text">，两个应用程序不知道有管道的存在，一切都是由 shell 管理和控制的。</span></p><p id="9135a0a2091dee1a4cfbf8c684405913" class="ne-p"><br></p><h3 id="72b83631"><span class="ne-text">共享内存 shared memory</span></h3><p id="b441fd0f50991bc8fbdb133ed2bfecc1" class="ne-p"><br></p><p id="5c9437460a98ec5c1b1963be737e891a" class="ne-p"><span class="ne-text">两个进程之间还可以通过共享内存进行进程间通信，其中两个或者多个进程可以访问公共内存空间。两个进程的共享工作是通过共享内存完成的，一个进程所作的修改可以对另一个进程可见(很像线程间的通信)。</span></p><p id="3b7e81fdce6f289a7b5b128d1c5890be" class="ne-p"><br></p><p id="84515a95f3770ad7ac1586bd0d382886" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829708-7158a6ec-203c-42aa-96bb-7946e3fb959a.png" width="659" id="WYSoT" class="ne-image"></p><p id="d4fb40df164d63a65f225277e42634fa" class="ne-p"><br></p><p id="caab3879748d4be435662e13c24b3335" class="ne-p"><span class="ne-text">在使用共享内存前，需要经过一系列的调用流程，流程如下</span></p><p id="c59ad6e8a32a354abe821f6b1d455495" class="ne-p"><br></p><ul class="ne-ul"><li id="eaf12986b718d744584491248cd9ad59"><span class="ne-text">创建共享内存段或者使用已创建的共享内存段</span><code class="ne-code"><span class="ne-text">(shmget())</span></code></li><li id="07722001603dcec1909ffeebbc9bbba5"><span class="ne-text">将进程附加到已经创建的内存段中</span><code class="ne-code"><span class="ne-text">(shmat())</span></code></li></ul><ul class="ne-ul"><li id="c08827f8c1685d8ec2163aebf19295b9"><span class="ne-text">从已连接的共享内存段分离进程</span><code class="ne-code"><span class="ne-text">(shmdt())</span></code></li><li id="8cd7c3fb9d858dcc81002e015465844d"><span class="ne-text">对共享内存段执行控制操作</span><code class="ne-code"><span class="ne-text">(shmctl())</span></code></li></ul><p id="8b6f722bbcdffe424e246ed3a95b9cec" class="ne-p"><br></p><h3 id="c4f8f8c1"><span class="ne-text">先入先出队列 FIFO</span></h3><p id="52767acac0b583fa16bd52993f2cff1a" class="ne-p"><br></p><p id="a66eca62deab14281ed14fd5255e4c7c" class="ne-p"><span class="ne-text">先入先出队列 FIFO 通常被称为 </span><code class="ne-code"><span class="ne-text">命名管道(Named Pipes)</span></code><span class="ne-text">，命名管道的工作方式与常规管道非常相似，但是确实有一些明显的区别。未命名的管道没有备份文件：操作系统负责维护内存中的缓冲区，用来将字节从写入器传输到读取器。一旦写入或者输出终止的话，缓冲区将被回收，传输的数据会丢失。相比之下，命名管道具有支持文件和独特 API ，命名管道在文件系统中作为设备的专用文件存在。当所有的进程通信完成后，命名管道将保留在文件系统中以备后用。命名管道具有严格的 FIFO 行为</span></p><p id="4c4130835544d2e4037541a399c00274" class="ne-p"><br></p><p id="518b30630e1757de83724356bf420c6f" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829713-f872efe8-5031-4f02-89ad-8c8351a854c7.png" width="584" id="gHPi1" class="ne-image"></p><p id="64556edd5c72d351442d4c215bd78afa" class="ne-p"><br></p><p id="ad02a68ae4b9a278228e0e65be24c577" class="ne-p"><span class="ne-text">写入的第一个字节是读取的第一个字节，写入的第二个字节是读取的第二个字节，依此类推。</span></p><p id="cacfa57508b4cbca4112ae43dda31420" class="ne-p"><br></p><h3 id="cf4ddbc3"><span class="ne-text">消息队列 Message Queue</span></h3><p id="f3a9949035996a711f2acc9e1cb8a548" class="ne-p"><br></p><p id="502aac7079420863be2b507a816dad7f" class="ne-p"><span class="ne-text">一听到消息队列这个名词你可能不知道是什么意思，消息队列是用来描述内核寻址空间内的内部链接列表。可以按几种不同的方式将消息按顺序发送到队列并从队列中检索消息。每个消息队列由 IPC 标识符唯一标识。消息队列有两种模式，一种是</span><code class="ne-code"><span class="ne-text">严格模式</span></code><span class="ne-text">， 严格模式就像是 FIFO 先入先出队列似的，消息顺序发送，顺序读取。还有一种模式是 </span><code class="ne-code"><span class="ne-text">非严格模式</span></code><span class="ne-text">，消息的顺序性不是非常重要。</span></p><p id="76610295702efeb67524a09a51ca022c" class="ne-p"><br></p><h3 id="fbaf7bbe"><span class="ne-text">套接字 Socket</span></h3><p id="9f141557fe97223eea8773c539b9552a" class="ne-p"><br></p><p id="28af2f3a58533de88a523266b8f66673" class="ne-p"><span class="ne-text">还有一种管理两个进程间通信的是使用 </span><code class="ne-code"><span class="ne-text">socket</span></code><span class="ne-text">，socket 提供端到端的双相通信。一个套接字可以与一个或多个进程关联。就像管道有命令管道和未命名管道一样，套接字也有两种模式，套接字一般用于两个进程之间的网络通信，网络套接字需要来自诸如</span><code class="ne-code"><span class="ne-text">TCP（传输控制协议）</span></code><span class="ne-text">或较低级别</span><code class="ne-code"><span class="ne-text">UDP（用户数据报协议）</span></code><span class="ne-text">等基础协议的支持。</span></p><p id="8c6d6b235890be26598ba16ff7a067fe" class="ne-p"><br></p><p id="203016d407ce5eb34e08849dadb79d88" class="ne-p"><span class="ne-text">套接字有以下几种分类</span></p><p id="854024933d86bf7a4d7c66a6b9ea755a" class="ne-p"><br></p><ul class="ne-ul"><li id="d8b2232e1900fd6705f4245543d5376b"><code class="ne-code"><span class="ne-text">顺序包套接字(Sequential Packet Socket)</span></code><span class="ne-text">： 此类套接字为最大长度固定的数据报提供可靠的连接。此连接是双向的并且是顺序的。</span></li><li id="d95a76dd1ca1ff9e7882c7f123319b54"><code class="ne-code"><span class="ne-text">数据报套接字(Datagram Socket)</span></code><span class="ne-text">：数据包套接字支持双向数据流。数据包套接字接受消息的顺序与发送者可能不同。</span></li></ul><ul class="ne-ul"><li id="055798b0b774376247582b29b38e9e51"><code class="ne-code"><span class="ne-text">流式套接字(Stream Socket)</span></code><span class="ne-text">：流套接字的工作方式类似于电话对话，提供双向可靠的数据流。</span></li><li id="485881b289944fc9644438d0af5b2bab"><code class="ne-code"><span class="ne-text">原始套接字(Raw Socket)</span></code><span class="ne-text">： 可以使用原始套接字访问基础通信协议。</span></li></ul><p id="06fb91a72234b4c3fa8fe3c525213a6c" class="ne-p"><br></p><h2 id="b088138c"><span class="ne-text">调度</span></h2><p id="db46aa2e41d292eabf878a29ae6e1eb9" class="ne-p"><br></p><p id="ac80db1c477dc4d61938c67e1e24cf4e" class="ne-p"><span class="ne-text">当一个计算机是多道程序设计系统时，会频繁的有很多进程或者线程来同时竞争 CPU 时间片。当两个或两个以上的进程/线程处于就绪状态时，就会发生这种情况。如果只有一个 CPU 可用，那么必须选择接下来哪个进程/线程可以运行。操作系统中有一个叫做 </span><code class="ne-code"><span class="ne-text">调度程序(scheduler)</span></code><span class="ne-text"> 的角色存在，它就是做这件事儿的，该程序使用的算法叫做 </span><code class="ne-code"><span class="ne-text">调度算法(scheduling algorithm)</span></code><span class="ne-text"> 。</span></p><p id="1ff7123ceb621d6eaa21f166661d48b5" class="ne-p"><br></p><h3 id="3b22ed94"><span class="ne-text">调度算法的分类</span></h3><p id="0536eab6c3f4f86d8c9e1eb4c2caa9ce" class="ne-p"><br></p><p id="50c7a2aa3ff0a2a07aaaabc9d81745d1" class="ne-p"><span class="ne-text">毫无疑问，不同的环境下需要不同的调度算法。之所以出现这种情况，是因为不同的应用程序和不同的操作系统有不同的目标。也就是说，在不同的系统中，调度程序的优化也是不同的。这里有必要划分出三种环境</span></p><p id="df6c20d6e0a6232273f0d1601c76cabd" class="ne-p"><br></p><ul class="ne-ul"><li id="0d3206be3b8ae11db093294df323407e"><code class="ne-code"><span class="ne-text">批处理(Batch)</span></code><span class="ne-text"> : 商业领域</span></li><li id="e9309e368b52d8797ac81aed29cd060e"><code class="ne-code"><span class="ne-text">交互式(Interactive)</span></code><span class="ne-text"> ： 交互式用户环境</span></li></ul><ul class="ne-ul"><li id="efe0fd41056503e2ca46a96cc1fbf80a"><code class="ne-code"><span class="ne-text">实时(Real time)</span></code></li></ul><p id="630e123e440c743aa695a6f16637ef25" class="ne-p"><br></p><h3 id="cc6a2057"><span class="ne-text">批处理中的调度</span></h3><p id="337455c979553991e97c1bdf5f17b0ec" class="ne-p"><br></p><p id="abd9e19e95f4d0564da8037374dd3741" class="ne-p"><span class="ne-text">现在让我们把目光从一般性的调度转换为特定的调度算法。下面我们会探讨在批处理中的调度。</span></p><p id="7dc9c8578156af1d69a73bd6804b3cdf" class="ne-p"><br></p><h4 id="400c234c"><span class="ne-text">先来先服务</span></h4><p id="50d75b4163179fa5fa7fc840e8287dc1" class="ne-p"><br></p><p id="52ddec5249cbe7ff90aa61f7d024e8d0" class="ne-p"><span class="ne-text">最简单的非抢占式调度算法的设计就是 </span><code class="ne-code"><span class="ne-text">先来先服务(first-come,first-serverd)</span></code><span class="ne-text">。当第一个任务从外部进入系统时，将会立即启动并允许运行任意长的时间。它不会因为运行时间太长而中断。当其他作业进入时，它们排到就绪队列尾部。当正在运行的进程阻塞，处于等待队列的第一个进程就开始运行。当一个阻塞的进程重新处于就绪态时，它会像一个新到达的任务，会排在队列的末尾，即排在所有进程最后。</span></p><p id="16c8c47a7ed1c45b2de1234c1bb04c16" class="ne-p"><br></p><p id="95d765b412db9d37d883066bcc827d68" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829697-a9e6978f-5f26-4491-8a57-4691ea81546b.png" width="709" id="fZNys" class="ne-image"></p><p id="d04f25840bac9f45b0816d3340b83e6f" class="ne-p"><br></p><p id="366e0b92b10f32bf06f3957591c4d306" class="ne-p"><span class="ne-text">这个算法的强大之处在于易于理解和编程，在这个算法中，一个单链表记录了所有就绪进程。要选取一个进程运行，只要从该队列的头部移走一个进程即可；要添加一个新的作业或者阻塞一个进程，只要把这个作业或进程附加在队列的末尾即可。这是很简单的一种实现。</span></p><p id="c90bc0690170107bb9cc1bfcf44a1869" class="ne-p"><br></p><h4 id="6b3d276b"><span class="ne-text">最短作业优先</span></h4><p id="7ae3f2475901cff482d976aea0dcce3d" class="ne-p"><br></p><p id="468e7a05528290bbd0be1d2d98c139b5" class="ne-p"><span class="ne-text">批处理中，第二种调度算法是 </span><code class="ne-code"><span class="ne-text">最短作业优先(Shortest Job First)</span></code><span class="ne-text">，我们假设运行时间已知。例如，一家保险公司，因为每天要做类似的工作，所以人们可以相当精确地预测处理 1000 个索赔的一批作业需要多长时间。当输入队列中有若干个同等重要的作业被启动时，调度程序应使用最短优先作业算法</span></p><p id="bbea4d15d597e1b2dbbcb2ec89f4bb11" class="ne-p"><br></p><p id="a517b18d42d12e1b8a78a7509be7885f" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829752-b3677366-5828-45be-9c62-d182dce0a26e.png" width="695" id="LgBd9" class="ne-image"></p><p id="f1c689fa90494cf32bd7f6aec4ba09af" class="ne-p"><br></p><div class="ne-quote"><p id="b6c055d28c6fdd14f00876b918817a67" class="ne-p"><span class="ne-text">需要注意的是，在所有的进程都可以运行的情况下，最短作业优先的算法才是最优的。</span></p></div><p id="3a11d311f7f2e5161f91e1442bf04adc" class="ne-p"><br></p><h4 id="0333fbb6"><span class="ne-text">最短剩余时间优先</span></h4><p id="92ead72ad4d93735b706d26474e6a2e4" class="ne-p"><br></p><p id="de6d4308827fa52aa18b1fc1eb0c02db" class="ne-p"><span class="ne-text">最短作业优先的抢占式版本被称作为 </span><code class="ne-code"><span class="ne-text">最短剩余时间优先(Shortest Remaining Time Next)</span></code><span class="ne-text"> 算法。使用这个算法，调度程序总是选择剩余运行时间最短的那个进程运行。</span></p><p id="b3ae427a7dda06a6f658ab859d284ec9" class="ne-p"><br></p><h3 id="3741716d"><span class="ne-text">交互式系统中的调度</span></h3><p id="422ebaab9625add00d44934dd813586f" class="ne-p"><br></p><p id="5137e8748df6e262c0ad40bc23d1ac26" class="ne-p"><span class="ne-text">交互式系统中在个人计算机、服务器和其他系统中都是很常用的，所以有必要来探讨一下交互式调度</span></p><p id="b7b5379045dd5e6e2189718effe74ae0" class="ne-p"><br></p><h4 id="8bea3bc8"><span class="ne-text">轮询调度</span></h4><p id="c5e4cc242c8c1a6b1a380f5ffb966ab1" class="ne-p"><br></p><p id="26df182ec60081d548dae5cbd53321de" class="ne-p"><span class="ne-text">一种最古老、最简单、最公平并且最广泛使用的算法就是 </span><code class="ne-code"><span class="ne-text">轮询算法(round-robin)</span></code><span class="ne-text">。每个进程都会被分配一个时间段，称为</span><code class="ne-code"><span class="ne-text">时间片(quantum)</span></code><span class="ne-text">，在这个时间片内允许进程运行。如果时间片结束时进程还在运行的话，则抢占一个 CPU 并将其分配给另一个进程。如果进程在时间片结束前阻塞或结束，则 CPU 立即进行切换。轮询算法比较容易实现。调度程序所做的就是维护一个可运行进程的列表，就像下图中的 a，当一个进程用完时间片后就被移到队列的末尾，就像下图的 b。</span></p><p id="2a48ba8c954dab1a6cbe6acc552135f3" class="ne-p"><br></p><p id="ad704eaa039166852e0fd5cd8ee74b31" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829772-8a1f4a69-9934-4cf9-b1bd-80a69f410e13.png" width="724" id="Zwr0C" class="ne-image"></p><p id="a0dd0fcd6b9dfa625206206a78e03ac6" class="ne-p"><br></p><h4 id="88650772"><span class="ne-text">优先级调度</span></h4><p id="59456b117bfb3b8f23d61c02b4b66490" class="ne-p"><br></p><p id="2286b41a5fbc982ed667d87f5fb1518f" class="ne-p"><span class="ne-text">轮询调度假设了所有的进程是同等重要的。但事实情况可能不是这样。例如，在一所大学中的等级制度，首先是院长，然后是教授、秘书、后勤人员，最后是学生。这种将外部情况考虑在内就实现了</span><code class="ne-code"><span class="ne-text">优先级调度(priority scheduling)</span></code></p><p id="a4784b0754fc345730f6757657160021" class="ne-p"><br></p><p id="c011fa04b7f2812398f076cb4e99b1fd" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829781-669962be-9966-4de1-be47-f3e9822459eb.png" width="678" id="Lt9Nc" class="ne-image"></p><p id="417688711448227baa00b80a4ddecb3f" class="ne-p"><br></p><p id="c6dc6554e74b480c52c7a694b6a90a73" class="ne-p"><span class="ne-text">它的基本思想很明确，每个进程都被赋予一个优先级，优先级高的进程优先运行。</span></p><p id="9121719585434ff2f0a1fca66a3e46d5" class="ne-p"><br></p><h4 id="edc1014b"><span class="ne-text">多级队列</span></h4><p id="6e60cd02590664c4b1a39db6543af092" class="ne-p"><br></p><p id="017210b6aad11b943d3912c5cffa57e5" class="ne-p"><span class="ne-text">最早使用优先级调度的系统是 </span><code class="ne-code"><span class="ne-text">CTSS(Compatible TimeSharing System)</span></code><span class="ne-text">。CTSS 在每次切换前都需要将当前进程换出到磁盘，并从磁盘上读入一个新进程。为 CPU 密集型进程设置较长的时间片比频繁地分给他们很短的时间要更有效（减少交换次数）。另一方面，如前所述，长时间片的进程又会影响到响应时间，解决办法是设置优先级类。属于最高优先级的进程运行一个时间片，次高优先级进程运行 2 个时间片，再下面一级运行 4 个时间片，以此类推。当一个进程用完分配的时间片后，它被移到下一类。</span></p><p id="bae603c7682382f7e3af58359797cb99" class="ne-p"><br></p><h4 id="9e5db475"><span class="ne-text">最短进程优先</span></h4><p id="d3fd5aec5606c3f51805ab6ba705c676" class="ne-p"><br></p><p id="c1612c156911dcadfd48e601dc6cff0a" class="ne-p"><span class="ne-text">最短进程优先是根据进程过去的行为进行推测，并执行估计运行时间最短的那一个。假设每个终端上每条命令的预估运行时间为 </span><code class="ne-code"><span class="ne-text">T0</span></code><span class="ne-text">，现在假设测量到其下一次运行时间为 </span><code class="ne-code"><span class="ne-text">T1</span></code><span class="ne-text">，可以用两个值的加权来改进估计时间，即</span><code class="ne-code"><span class="ne-text">aT0+ (1- 1)T1</span></code><span class="ne-text">。通过选择 a 的值，可以决定是尽快忘掉老的运行时间，还是在一段长时间内始终记住它们。当 a = 1/2 时，可以得到下面这个序列</span></p><p id="6769b00d23ae9769141733ed8b1fcd6d" class="ne-p"><br></p><p id="091226d35ecf107e9b32444780d14bcc" class="ne-p"><span class="ne-text">![image-20200220120452410](/Users/mr.l/Library/Application Support/typora-user-images/image-20200220120452410.png)</span></p><p id="c46a33578ba15bf3a896acf4a7439d4b" class="ne-p"><br></p><p id="b84ae544ee7149cb676643c21f7c4002" class="ne-p"><span class="ne-text">可以看到，在三轮过后，T0 在新的估计值中所占比重下降至 1/8。</span></p><p id="a1f413692778469baa56acbd5ffcf6d0" class="ne-p"><br></p><h4 id="5abf2b05"><span class="ne-text">保证调度</span></h4><p id="01ce9b320999207d18ddc9192f428dbc" class="ne-p"><br></p><p id="8a68e211434a7f5613ac4f8218909916" class="ne-p"><span class="ne-text">一种完全不同的调度方法是对用户做出明确的性能保证。一种实际而且容易实现的保证是：若用户工作时有 n 个用户登录，则每个用户将获得 CPU 处理能力的 1/n。类似地，在一个有 n 个进程运行的单用户系统中，若所有的进程都等价，则每个进程将获得 1/n 的 CPU 时间。</span></p><p id="bad28048c33e866f65513743c9071379" class="ne-p"><br></p><h4 id="6d170350"><span class="ne-text">彩票调度</span></h4><p id="1ec63cbf9f419d479434f9b178b91ee5" class="ne-p"><br></p><p id="c994c1728228b0f8690b76ebfde67d27" class="ne-p"><span class="ne-text">对用户进行承诺并在随后兑现承诺是一件好事，不过很难实现。但是存在着一种简单的方式，有一种既可以给出预测结果而又有一种比较简单的实现方式的算法，就是 </span><code class="ne-code"><span class="ne-text">彩票调度(lottery scheduling)</span></code><span class="ne-text">算法。</span></p><p id="7a64ea69d571753adc711f3065ec5eb9" class="ne-p"><br></p><p id="009f3b9dc6647cecef4e0f5e64e84e09" class="ne-p"><span class="ne-text">其基本思想是为进程提供各种系统资源（例如 CPU 时间）的彩票。当做出一个调度决策的时候，就随机抽出一张彩票，拥有彩票的进程将获得该资源。在应用到 CPU 调度时，系统可以每秒持有 50 次抽奖，每个中奖者将获得比如 20 毫秒的 CPU 时间作为奖励。</span></p><p id="21e629b1eaa9fcd18efe030f5360b954" class="ne-p"><br></p><h4 id="f52d1789"><span class="ne-text">公平分享调度</span></h4><p id="454ce166479faf6b0bac6a5a1d950fc0" class="ne-p"><br></p><p id="3e7328aa85fbda7ea81e5451ecd63f55" class="ne-p"><span class="ne-text">到目前为止，我们假设被调度的都是各个进程自身，而不用考虑该进程的拥有者是谁。结果是，如果用户 1 启动了 9 个进程，而用户 2 启动了一个进程，使用轮转或相同优先级调度算法，那么用户 1 将得到 90 % 的 CPU 时间，而用户 2 将之得到 10 % 的 CPU 时间。</span></p><p id="247ab6cb450a5c6c2432cec96ed7ec6e" class="ne-p"><br></p><p id="a8997400e66c5b2d256fccc7ea3776bf" class="ne-p"><span class="ne-text">为了阻止这种情况的出现，一些系统在调度前会把进程的拥有者考虑在内。在这种模型下，每个用户都会分配一些CPU 时间，而调度程序会选择进程并强制执行。因此如果两个用户每个都会有 50% 的 CPU 时间片保证，那么无论一个用户有多少个进程，都将获得相同的 CPU 份额。</span></p><p id="25cfa5c1dd3833edf698f7172bb0cd48" class="ne-p"><br></p><p id="8a2de1e6a6957d4a3a1cd8ddd4f15cf3" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829805-f1649640-92c0-4cc0-9d11-d33091868df3.png" width="681" id="s6DG8" class="ne-image"></p><p id="a71b4648e92abc3a0a98e890305bbfc7" class="ne-p"><br></p><h3 id="e87fdf39"><span class="ne-text">实时系统中的调度</span></h3><p id="65e73472811dc36880ee811fac3bfc94" class="ne-p"><br></p><p id="2f7c753cdac04c87a34af91ae1219692" class="ne-p"><code class="ne-code"><span class="ne-text">实时系统(real-time)</span></code><span class="ne-text"> 是一个时间扮演了重要作用的系统。实时系统可以分为两类，</span><code class="ne-code"><span class="ne-text">硬实时(hard real time)</span></code><span class="ne-text"> 和 </span><code class="ne-code"><span class="ne-text">软实时(soft real time)</span></code><span class="ne-text"> 系统，前者意味着必须要满足绝对的截止时间；后者的含义是虽然不希望偶尔错失截止时间，但是可以容忍。</span></p><p id="670523a1b5511e2dbbe7df30ea900b9d" class="ne-p"><br></p><p id="f974b8ccc4e8617c2d30cf67ec750345" class="ne-p"><span class="ne-text">实时系统中的事件可以按照响应方式进一步分类为</span><code class="ne-code"><span class="ne-text">周期性(以规则的时间间隔发生)</span></code><span class="ne-text">事件或 </span><code class="ne-code"><span class="ne-text">非周期性(发生时间不可预知)</span></code><span class="ne-text">事件。一个系统可能要响应多个周期性事件流，根据每个事件处理所需的时间，可能甚至无法处理所有事件。例如，如果有 m 个周期事件，事件 i 以周期 Pi 发生，并需要 Ci 秒 CPU 时间处理一个事件，那么可以处理负载的条件是</span></p><p id="d8cf2cf43fb9725d8547f64247372780" class="ne-p"><br></p><p id="0d5983b3ee8a785dc8f03c345ec7a943" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829813-d541b483-e6c2-4e61-b29d-faf9719ce83f.png" width="180" id="ufEZW" class="ne-image"></p><p id="97acdb638c547195b6ef846c1e51b89f" class="ne-p"><br></p><p id="ef8f27436da7fb3f3e483c323e3bf505" class="ne-p"><span class="ne-text">只有满足这个条件的实时系统称为</span><code class="ne-code"><span class="ne-text">可调度的</span></code><span class="ne-text">，这意味着它实际上能够被实现。一个不满足此检验标准的进程不能被调度，因为这些进程共同需要的 CPU 时间总和大于 CPU 能提供的时间。</span></p><p id="253e9dd88734332a7e277657f4bbe7aa" class="ne-p"><br></p><p id="84fb8043025bc72a7a331f4b2038fec9" class="ne-p"><span class="ne-text">下面我们来了解一下内存管理，你需要知道的知识点如下</span></p><p id="be344a47b1bc97136a272661dcae26ab" class="ne-p"><br></p><p id="08d4a9f1f09106f5567bc8cd8ce5f2ea" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829871-ad9be6cd-aa53-4acc-b245-5dd76199a6ba.png" width="742" id="qZ8YJ" class="ne-image"></p><p id="897f56e4266d6ddefb7a80f14fdc066f" class="ne-p"><br></p><h2 id="f8c25083"><span class="ne-text">地址空间</span></h2><p id="bde8f9f383388c601478c74a93453ac7" class="ne-p"><br></p><p id="ec6517c213e0ba8f57072f457233836a" class="ne-p"><span class="ne-text">如果要使多个应用程序同时运行在内存中，必须要解决两个问题：</span><code class="ne-code"><span class="ne-text">保护</span></code><span class="ne-text">和 </span><code class="ne-code"><span class="ne-text">重定位</span></code><span class="ne-text">。第一种解决方式是用</span><code class="ne-code"><span class="ne-text">保护密钥标记内存块</span></code><span class="ne-text">，并将执行过程的密钥与提取的每个存储字的密钥进行比较。这种方式只能解决第一种问题（破坏操作系统），但是不能解决多进程在内存中同时运行的问题。</span></p><p id="5a59697a4c5abbfa70470c3bd42ae884" class="ne-p"><br></p><p id="edaf48dfdb5c68281fed3d81ca91c83e" class="ne-p"><span class="ne-text">还有一种更好的方式是创造一个存储器抽象：</span><code class="ne-code"><span class="ne-text">地址空间(the address space)</span></code><span class="ne-text">。就像进程的概念创建了一种抽象的 CPU 来运行程序，地址空间也创建了一种抽象内存供程序使用。</span></p><p id="8b864388ad7cbe940f6df98cf8047f40" class="ne-p"><br></p><h4 id="dc58b76e"><span class="ne-text">基址寄存器和变址寄存器</span></h4><p id="688b9c8ffedbb24b760571665f734e30" class="ne-p"><br></p><p id="34958411ca47c301b7e17928791bbede" class="ne-p"><span class="ne-text">最简单的办法是使用</span><code class="ne-code"><span class="ne-text">动态重定位(dynamic relocation)</span></code><span class="ne-text">技术，它就是通过一种简单的方式将每个进程的地址空间映射到物理内存的不同区域。还有一种方式是使用基址寄存器和变址寄存器。</span></p><p id="aa38b2f5d51810e34c165ded7b78d47d" class="ne-p"><br></p><ul class="ne-ul"><li id="e880fdf6fcd3d032a4341180b8593207"><span class="ne-text">基址寄存器：存储数据内存的起始位置</span></li><li id="d832ace055abe375212e5ebc6c6de94c"><span class="ne-text">变址寄存器：存储应用程序的长度。</span></li></ul><p id="85d454c1417111a0069356a762f1ad16" class="ne-p"><br></p><p id="c96b02a131713a5288237b39959a7848" class="ne-p"><span class="ne-text">每当进程引用内存以获取指令或读取、写入数据时，CPU 都会自动将</span><code class="ne-code"><span class="ne-text">基址值</span></code><span class="ne-text">添加到进程生成的地址中，然后再将其发送到内存总线上。同时，它检查程序提供的地址是否大于或等于</span><code class="ne-code"><span class="ne-text">变址寄存器</span></code><span class="ne-text"> 中的值。如果程序提供的地址要超过变址寄存器的范围，那么会产生错误并中止访问。</span></p><p id="657477406dfb1d962867bf48ef305165" class="ne-p"><br></p><h3 id="4c736ad5"><span class="ne-text">交换技术</span></h3><p id="2fc583f502358c13597da6fff3de80fd" class="ne-p"><br></p><p id="8c95f9eaf3a6186e888348475003c367" class="ne-p"><span class="ne-text">在程序运行过程中，经常会出现内存不足的问题。</span></p><p id="ddf8522ed4c5cc50a55556b7984536bc" class="ne-p"><br></p><p id="8938c8e1fd6a3f0862e0a2c359b11055" class="ne-p"><span class="ne-text">针对上面内存不足的问题，提出了两种处理方式：最简单的一种方式就是</span><code class="ne-code"><span class="ne-text">交换(swapping)</span></code><span class="ne-text">技术，即把一个进程完整的调入内存，然后再内存中运行一段时间，再把它放回磁盘。空闲进程会存储在磁盘中，所以这些进程在没有运行时不会占用太多内存。另外一种策略叫做</span><code class="ne-code"><span class="ne-text">虚拟内存(virtual memory)</span></code><span class="ne-text">，虚拟内存技术能够允许应用程序部分的运行在内存中。下面我们首先先探讨一下交换</span></p><p id="3ad35936eb8cb28c5c2fa936042097bd" class="ne-p"><br></p><h4 id="7e402db3"><span class="ne-text">交换过程</span></h4><p id="4d79d791ebde11eac836417d99a83a32" class="ne-p"><br></p><p id="de4f76e258b0deaab8ec99cb01bfa6ef" class="ne-p"><span class="ne-text">下面是一个交换过程</span></p><p id="716222faf1c7f3ed190c4114812ce6f8" class="ne-p"><br></p><p id="6ccc90eceb94b75a14c9d216c722138a" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829844-31f0d41e-db06-4f4a-86d4-15250999e2dd.png" width="724" id="PM0yA" class="ne-image"></p><p id="dc7cc2c39c8d3f304020512f8ff9b9bc" class="ne-p"><br></p><p id="996bc77c0dba2ac7b6d7396b4b5ca492" class="ne-p"><span class="ne-text">刚开始的时候，只有进程 A 在内存中，然后从创建进程 B 和进程 C 或者从磁盘中把它们换入内存，然后在图 d 中，A 被换出内存到磁盘中，最后 A 重新进来。因为图 g 中的进程 A 现在到了不同的位置，所以在装载过程中需要被重新定位，或者在交换程序时通过软件来执行；或者在程序执行期间通过硬件来重定位。基址寄存器和变址寄存器就适用于这种情况。</span></p><p id="85a1527560367b27f342301a635faa1d" class="ne-p"><br></p><p id="25bb57681bc250f1818434d7d35b4930" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829879-4fde9a55-0c36-4d7d-948a-49841539d0c8.png" width="696" id="SC4tr" class="ne-image"></p><p id="4acee99ad01bb62a54a2e2bd553446b8" class="ne-p"><br></p><p id="2d984474d589be5f5955c2ce294ec16e" class="ne-p"><span class="ne-text">交换在内存创建了多个 </span><code class="ne-code"><span class="ne-text">空闲区(hole)</span></code><span class="ne-text">，内存会把所有的空闲区尽可能向下移动合并成为一个大的空闲区。这项技术称为</span><code class="ne-code"><span class="ne-text">内存紧缩(memory compaction)</span></code><span class="ne-text">。但是这项技术通常不会使用，因为这项技术会消耗很多 CPU 时间。</span></p><p id="b28c8d2e8428888c6adf339dc61047f2" class="ne-p"><br></p><h3 id="6bbc8b2f"><span class="ne-text">空闲内存管理</span></h3><p id="6fd3637e0cb8f6d3d237425a70b8067f" class="ne-p"><br></p><p id="2050198cea7f2d6fa1fddd5ac13c4444" class="ne-p"><span class="ne-text">在进行内存动态分配时，操作系统必须对其进行管理。大致上说，有两种监控内存使用的方式</span></p><p id="79f8b96bcfca73171c3a49ff9cfbf205" class="ne-p"><br></p><ul class="ne-ul"><li id="e72421e316cd2ca7ca62cdeb089ee797"><code class="ne-code"><span class="ne-text">位图(bitmap)</span></code></li><li id="363344e59979446380ae415574aa7cd0"><code class="ne-code"><span class="ne-text">空闲列表(free lists)</span></code></li></ul><p id="b610fbf0037c478e4c50c66707220a71" class="ne-p"><br></p><h4 id="bcd570ff"><span class="ne-text">使用位图的存储管理</span></h4><p id="1b793a00e7d2c49c89beb25f52ff969b" class="ne-p"><br></p><p id="01106bad7b2d039f9d53f44c574b3c78" class="ne-p"><span class="ne-text">使用位图方法时，内存可能被划分为小到几个字或大到几千字节的分配单元。每个分配单元对应于位图中的一位，0 表示空闲， 1 表示占用（或者相反）。一块内存区域和其对应的位图如下</span></p><p id="f9fd09e0470dab41be4f170ebe495874" class="ne-p"><br></p><p id="d2fd7e81e8fd6d19e6bc81d1ea9dbb09" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829887-83af6188-e02c-4437-8739-40021e8a2957.png" width="734" id="uirOM" class="ne-image"></p><p id="6579c3b5ec2bf6680f8a53ad590b2b3f" class="ne-p"><br></p><p id="0bad0d7b6f984dfeb8fb7d633878dc75" class="ne-p"><code class="ne-code"><span class="ne-text">位图</span></code><span class="ne-text">提供了一种简单的方法在固定大小的内存中跟踪内存的使用情况，因为</span><strong><span class="ne-text">位图的大小取决于内存和分配单元的大小</span></strong><span class="ne-text">。这种方法有一个问题是，当决定为把具有 k 个分配单元的进程放入内存时，</span><code class="ne-code"><span class="ne-text">内容管理器(memory manager)</span></code><span class="ne-text"> 必须搜索位图，在位图中找出能够运行 k 个连续 0 位的串。在位图中找出制定长度的连续 0 串是一个很耗时的操作，这是位图的缺点。（可以简单理解为在杂乱无章的数组中，找出具有一大长串空闲的数组单元）</span></p><p id="eb3f59ae4a980fa5ed18835d708de977" class="ne-p"><br></p><h4 id="467e29df"><span class="ne-text">使用链表进行管理</span></h4><p id="0ba53562a3e5d7f756273229624888b1" class="ne-p"><br></p><p id="65daec3f55e2fb306b3bd1ea1f8ec09e" class="ne-p"><span class="ne-text">另一种记录内存使用情况的方法是，维护一个记录已分配内存段和空闲内存段的链表，段会包含进程或者是两个进程的空闲区域。可用上面的图 c </span><strong><span class="ne-text">来表示内存的使用情况</span></strong><span class="ne-text">。链表中的每一项都可以代表一个 </span><code class="ne-code"><span class="ne-text">空闲区(H)</span></code><span class="ne-text"> 或者是</span><code class="ne-code"><span class="ne-text">进程(P)</span></code><span class="ne-text">的起始标志，长度和下一个链表项的位置。</span></p><p id="7492aba8e2e2a0b00bddc1bba083dec4" class="ne-p"><br></p><p id="2f92da5d9f5567454cc1afc04526ce0b" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829908-832c7960-d7cc-45fc-a029-b803b86a6bf9.png" width="695" id="ZQMqP" class="ne-image"></p><p id="f407fecb833a46515b987fd8965b5866" class="ne-p"><br></p><p id="0dbfeeb82b221eef296e1b1d55fac093" class="ne-p"><span class="ne-text">当按照地址顺序在链表中存放进程和空闲区时，有几种算法可以为创建的进程（或者从磁盘中换入的进程）分配内存。我们先假设内存管理器知道应该分配多少内存，最简单的算法是使用 </span><code class="ne-code"><span class="ne-text">首次适配(first fit)</span></code><span class="ne-text">。内存管理器会沿着段列表进行扫描，直到找个一个足够大的空闲区为止。 除非空闲区大小和要分配的空间大小一样，否则将空闲区分为两部分，一部分供进程使用；一部分生成新的空闲区。首次适配算法是一种速度很快的算法，因为它会尽可能的搜索链表。</span></p><p id="750c592d1471e8b63a925fb723ea5093" class="ne-p"><br></p><p id="b4c3aa0ee2ac733daa864079298d1186" class="ne-p"><span class="ne-text">首次适配的一个小的变体是 </span><code class="ne-code"><span class="ne-text">下次适配(next fit)</span></code><span class="ne-text">。它和首次匹配的工作方式相同，只有一个不同之处那就是下次适配在每次找到合适的空闲区时就会记录当时的位置，以便下次寻找空闲区时从上次结束的地方开始搜索，而不是像首次匹配算法那样每次都会从头开始搜索。</span></p><p id="a21e47b580db1794269936af697ac5b6" class="ne-p"><br></p><p id="154349d0e6d25598125edd960c601f1a" class="ne-p"><span class="ne-text">另外一个著名的并且广泛使用的算法是 </span><code class="ne-code"><span class="ne-text">最佳适配(best fit)</span></code><span class="ne-text">。最佳适配会从头到尾寻找整个链表，找出能够容纳进程的最小空闲区。</span></p><p id="c0239fb5654f6172a04ffc454db60829" class="ne-p"><br></p><h2 id="84429675"><span class="ne-text">虚拟内存</span></h2><p id="a52e80a7a17362a2071a9ac3d43c6331" class="ne-p"><br></p><p id="a3b16b4a43fc377a78e20e68d2604a84" class="ne-p"><span class="ne-text">尽管基址寄存器和变址寄存器用来创建地址空间的抽象，但是这有一个其他的问题需要解决：</span><code class="ne-code"><span class="ne-text">管理软件的不断增大(managing bloatware)</span></code><span class="ne-text">。虚拟内存的基本思想是，每个程序都有自己的地址空间，这个地址空间被划分为多个称为</span><code class="ne-code"><span class="ne-text">页面(page)</span></code><span class="ne-text">的块。每一页都是连续的地址范围。这些页被映射到物理内存，但并不是所有的页都必须在内存中才能运行程序。当程序引用到一部分在物理内存中的地址空间时，硬件会立刻执行必要的映射。当程序引用到一部分不在物理内存中的地址空间时，由操作系统负责将缺失的部分装入物理内存并重新执行失败的指令。</span></p><p id="cfc9dd2da74bf0ac8eb66cdcb2922008" class="ne-p"><br></p><h3 id="3862626c"><span class="ne-text">分页</span></h3><p id="ad408dc123ddf88a8c25c2e8c88dae85" class="ne-p"><br></p><p id="4066a9b0016b34734e2fbf3e8f54723b" class="ne-p"><span class="ne-text">大部分使用虚拟内存的系统中都会使用一种 </span><code class="ne-code"><span class="ne-text">分页(paging)</span></code><span class="ne-text"> 技术。在任何一台计算机上，程序会引用使用一组内存地址。当程序执行</span></p><p id="d759b00624e8ef1625c86e6add1eddcb" class="ne-p"><br></p><pre><code>MOV REG,1000</code></pre><p id="89add3c3374d8e28c840c7bccca4a7e5" class="ne-p"><br></p><p id="96c2f3af046d1e1074a249ed5b62d8d1" class="ne-p"><span class="ne-text">这条指令时，它会把内存地址为 1000 的内存单元的内容复制到 REG 中（或者相反，这取决于计算机）。地址可以通过索引、基址寄存器、段寄存器或其他方式产生。</span></p><p id="d4405ed4f3767b04521138e8ae125763" class="ne-p"><br></p><p id="bb0d8776d1f68b804c2256cb8e6a8782" class="ne-p"><span class="ne-text">这些程序生成的地址被称为 </span><code class="ne-code"><span class="ne-text">虚拟地址(virtual addresses)</span></code><span class="ne-text"> 并形成</span><code class="ne-code"><span class="ne-text">虚拟地址空间(virtual address space)</span></code><span class="ne-text">，在没有虚拟内存的计算机上，系统直接将虚拟地址送到内存中线上，读写操作都使用同样地址的物理内存。</span><strong><span class="ne-text">在使用虚拟内存时，虚拟地址不会直接发送到内存总线上</span></strong><span class="ne-text">。相反，会使用 </span><code class="ne-code"><span class="ne-text">MMU(Memory Management Unit)</span></code><span class="ne-text"> 内存管理单元把</span><strong><span class="ne-text">虚拟地址映射为物理内存地址</span></strong><span class="ne-text">，像下图这样</span></p><p id="7af393fea8b22c962a02bb238a51bfcf" class="ne-p"><br></p><p id="26978d8cd99d410a14326508c2a49c82" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829902-6db577d7-0921-4635-82f1-62f7fe723b48.png" width="710" id="DPfTF" class="ne-image"></p><p id="920e1606a09ad135a916cc1d8ea86734" class="ne-p"><br></p><p id="d01e804e8a33f6a675e0545fe9f7dde7" class="ne-p"><span class="ne-text">下面这幅图展示了这种映射是如何工作的</span></p><p id="5aceabff0e61c0d5d5d970315896fe1e" class="ne-p"><br></p><p id="70d3b873e0804fdcc75108174659a7b5" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829922-b5a208d9-6807-4201-b95a-50c300ec3f1e.png" width="701" id="jEXGv" class="ne-image"></p><p id="b96f2dce14d08fbe8bbb54b56cb574bf" class="ne-p"><br></p><p id="dc3ab02bd9504ce5467860296b9a74d2" class="ne-p"><span class="ne-text">页表给出虚拟地址与物理内存地址之间的映射关系。每一页起始于 4096 的倍数位置，结束于 4095 的位置，所以 4K 到 8K 实际为 4096 - 8191 ，8K - 12K 就是 8192 - 12287</span></p><p id="bc7ed89c32cb3a181312532bc488d2e0" class="ne-p"><br></p><p id="a2f11223fc6e7fd34aab2e859e41b4f3" class="ne-p"><span class="ne-text">在这个例子中，我们可能有一个 16 位地址的计算机，地址从 0 - 64 K - 1，这些是</span><code class="ne-code"><span class="ne-text">虚拟地址</span></code><span class="ne-text">。然而只有 32 KB 的物理地址。所以虽然可以编写 64 KB 的程序，但是程序无法全部调入内存运行，在磁盘上必须有一个最多 64 KB 的程序核心映像的完整副本，以保证程序片段在需要时被调入内存。</span></p><p id="9596f00592eb949c69c63cbdb69b8643" class="ne-p"><br></p><h3 id="48de0fdd"><span class="ne-text">页表</span></h3><p id="857f37982ab15377827623d3d741445c" class="ne-p"><br></p><p id="3fa7e03ff8c37017d8d9354b20f1a7f6" class="ne-p"><span class="ne-text">虚拟页号可作为页表的索引用来找到虚拟页中的内容。由页表项可以找到页框号（如果有的话）。然后把页框号拼接到偏移量的高位端，以替换掉虚拟页号，形成物理地址。</span></p><p id="b804d0484cc73b4e42e4c1a16cf433bf" class="ne-p"><br></p><p id="97e874b55d764de49c180df820f441ac" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829940-3af1fa95-4f53-459f-88e6-dc9540fc58fa.png" width="726" id="gDLPK" class="ne-image"></p><p id="7d73b7251105220113cfc0e95b4dae9e" class="ne-p"><br></p><p id="063ec3cf1870ce7283f1ec520bf8725e" class="ne-p"><span class="ne-text">因此，页表的目的是把虚拟页映射到页框中。从数学上说，页表是一个函数，它的参数是虚拟页号，结果是物理页框号。</span></p><p id="7c5451128fbe624fd69dc56c6324aa00" class="ne-p"><br></p><p id="ecc02083465bab9e94b190db907b78cf" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829970-f9085cee-e3ce-49a6-a175-31095f33b104.png" width="549" id="r6cAl" class="ne-image"></p><p id="f4cbe70227438afd44c6da369ae27783" class="ne-p"><br></p><p id="ecc882e5c8595768f3b9b1a82f95c800" class="ne-p"><span class="ne-text">通过这个函数可以把虚拟地址中的虚拟页转换为页框，从而形成物理地址。</span></p><p id="d5a128f20cf5882f3e7639970691078c" class="ne-p"><br></p><h4 id="ebc1ec9d"><span class="ne-text">页表项的结构</span></h4><p id="8580345f352bef3704c4f0cfb0671d79" class="ne-p"><br></p><p id="e0361fcd123e7c408a1410e6cc45439c" class="ne-p"><span class="ne-text">下面我们探讨一下页表项的具体结构，上面你知道了页表项的大致构成，是由页框号和在/不在位构成的，现在我们来具体探讨一下页表项的构成</span></p><p id="47984eb3ee2b2f2dfa132deed0eb8316" class="ne-p"><br></p><p id="cc5c2e897e5e7b5827cdd4c67abaaa77" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829994-5ecf9cda-4a6f-418e-b786-bf4a2a05e7c3.png" width="701" id="PVew4" class="ne-image"></p><p id="4cbaab2ba9647f14311ad1df919f070b" class="ne-p"><br></p><p id="a0482db6a2673a73d8ea3e3348c44e1e" class="ne-p"><span class="ne-text">页表项的结构是与机器相关的，但是不同机器上的页表项大致相同。上面是一个页表项的构成，不同计算机的页表项可能不同，但是一般来说都是 32 位的。页表项中最重要的字段就是</span><code class="ne-code"><span class="ne-text">页框号(Page frame number)</span></code><span class="ne-text">。毕竟，页表到页框最重要的一步操作就是要把此值映射过去。下一个比较重要的就是</span><code class="ne-code"><span class="ne-text">在/不在</span></code><span class="ne-text">位，如果此位上的值是 1，那么页表项是有效的并且能够被</span><code class="ne-code"><span class="ne-text">使用</span></code><span class="ne-text">。如果此值是 0 的话，则表示该页表项对应的虚拟页面</span><code class="ne-code"><span class="ne-text">不在</span></code><span class="ne-text">内存中，访问该页面会引起一个</span><code class="ne-code"><span class="ne-text">缺页异常(page fault)</span></code><span class="ne-text">。</span></p><p id="1538e61821a53e91fd6c621fea99050c" class="ne-p"><br></p><p id="07e2267978cae7258a9ac4111b0bfac6" class="ne-p"><code class="ne-code"><span class="ne-text">保护位(Protection)</span></code><span class="ne-text"> 告诉我们哪一种访问是允许的，啥意思呢？最简单的表示形式是这个域只有一位，</span><strong><span class="ne-text">0 表示可读可写，1 表示的是只读</span></strong><span class="ne-text">。</span></p><p id="cd5113de44f663e8dcda2e73383b485f" class="ne-p"><br></p><p id="2f956dc3258cb003ac6dc16c55871787" class="ne-p"><code class="ne-code"><span class="ne-text">修改位(Modified)</span></code><span class="ne-text"> 和 </span><code class="ne-code"><span class="ne-text">访问位(Referenced)</span></code><span class="ne-text"> 会跟踪页面的使用情况。当一个页面被写入时，硬件会自动的设置修改位。修改位在页面重新分配页框时很有用。如果一个页面已经被修改过（即它是 </span><code class="ne-code"><span class="ne-text">脏</span></code><span class="ne-text"> 的），则必须把它写回磁盘。如果一个页面没有被修改过（即它是 </span><code class="ne-code"><span class="ne-text">干净</span></code><span class="ne-text">的），那么重新分配时这个页框会被直接丢弃，因为磁盘上的副本仍然是有效的。这个位有时也叫做 </span><code class="ne-code"><span class="ne-text">脏位(dirty bit)</span></code><span class="ne-text">，因为它反映了页面的状态。</span></p><p id="b79e431bca8c6a4061cff3e6e2cd7e33" class="ne-p"><br></p><p id="e4dfca25e9150ba09532a333d26042ad" class="ne-p"><code class="ne-code"><span class="ne-text">访问位(Referenced)</span></code><span class="ne-text"> 在页面被访问时被设置，不管是读还是写。这个值能够帮助操作系统在发生缺页中断时选择要淘汰的页。不再使用的页要比正在使用的页更适合被淘汰。这个位在后面要讨论的</span><code class="ne-code"><span class="ne-text">页面置换</span></code><span class="ne-text">算法中作用很大。</span></p><p id="3c02b4c632833430510ae67ff9ed4e16" class="ne-p"><br></p><p id="dbc93bd44ac1087b64e0b1d023ba34c3" class="ne-p"><span class="ne-text">最后一位用于禁止该页面被高速缓存，这个功能对于映射到设备寄存器还是内存中起到了关键作用。通过这一位可以禁用高速缓存。具有独立的 I/O 空间而不是用内存映射 I/O 的机器来说，并不需要这一位。</span></p><p id="befcfc4e20c5082a05f87de19bcd7503" class="ne-p"><br></p><h2 id="62ce86fe"><span class="ne-text">页面置换算法</span></h2><p id="dd4394f57b4886240b2c215cdd1e4631" class="ne-p"><br></p><p id="4f6a92a94c2e30c6050bfb462299a22b" class="ne-p"><span class="ne-text">下面我们就来探讨一下有哪些页面置换算法。</span></p><p id="a1b1f01ba8c41e23d328afe683dd334c" class="ne-p"><br></p><h3 id="62592cf3"><span class="ne-text">最优页面置换算法</span></h3><p id="0e512837e885309b4830226205348edd" class="ne-p"><br></p><p id="9213075cee522577cc3a7c72861ccedd" class="ne-p"><span class="ne-text">最优的页面置换算法的工作流程如下：在缺页中断发生时，这些页面之一将在下一条指令（包含该指令的页面）上被引用。其他页面则可能要到 10、100 或者 1000 条指令后才会被访问。每个页面都可以用在该页首次被访问前所要执行的指令数作为标记。</span></p><p id="60569c4b121798a3dfa3559723a85c22" class="ne-p"><br></p><p id="f652c71e4c322ab28275da1eef94b0bb" class="ne-p"><span class="ne-text">最优化的页面算法表明应该标记最大的页面。如果一个页面在 800 万条指令内不会被使用，另外一个页面在 600 万条指令内不会被使用，则置换前一个页面，从而把需要调入这个页面而发生的缺页中断推迟。计算机也像人类一样，会把不愿意做的事情尽可能的往后拖。</span></p><p id="933341d07fd0cb969e37b2921a21a1b4" class="ne-p"><br></p><p id="0b6aa11ee462069a41c30975c1369ec7" class="ne-p"><span class="ne-text">这个算法最大的问题时无法实现。当缺页中断发生时，操作系统无法知道各个页面的下一次将在什么时候被访问。这种算法在实际过程中根本不会使用。</span></p><p id="7cccf369523448e9ea1adb8b38b19c65" class="ne-p"><br></p><h3 id="f3900d0e"><span class="ne-text">最近未使用页面置换算法</span></h3><p id="84094ac7292da84c018fa4aa4de731a1" class="ne-p"><br></p><p id="48785f09a7c92dc9c6b7cb0413f2955c" class="ne-p"><span class="ne-text">为了能够让操作系统收集页面使用信息，大部分使用虚拟地址的计算机都有两个状态位，R 和 M，来和每个页面进行关联。</span><strong><span class="ne-text">每当引用页面（读入或写入）时都设置 R，写入（即修改）页面时设置 M</span></strong><span class="ne-text">，这些位包含在每个页表项中，就像下面所示</span></p><p id="893a0cfa909ed56729e771832bca703f" class="ne-p"><br></p><p id="a4c3f7d5b620ee72ed1f39cf3b0f2f9c" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830000-886bdae7-531d-42ce-86c1-970d3c0fd287.png" width="644" id="GjVza" class="ne-image"></p><p id="d91a668fe44efebe3f6df1f790f756b6" class="ne-p"><br></p><p id="cd2436ef675270bdeb27defe9bb4a987" class="ne-p"><span class="ne-text">因为每次访问时都会更新这些位，因此由</span><code class="ne-code"><span class="ne-text">硬件</span></code><span class="ne-text">来设置它们非常重要。一旦某个位被设置为 1，就会一直保持 1 直到操作系统下次来修改此位。</span></p><p id="e7a4fdba97874bdf3ba1bbbcc25d17b6" class="ne-p"><br></p><p id="cc2fe27785e322231e1760788dacd2e8" class="ne-p"><span class="ne-text">如果硬件没有这些位，那么可以使用操作系统的</span><code class="ne-code"><span class="ne-text">缺页中断</span></code><span class="ne-text">和</span><code class="ne-code"><span class="ne-text">时钟中断</span></code><span class="ne-text">机制来进行模拟。当启动一个进程时，将其所有的页面都标记为</span><code class="ne-code"><span class="ne-text">不在内存</span></code><span class="ne-text">；一旦访问任何一个页面就会引发一次缺页中断，此时操作系统就可以设置 </span><code class="ne-code"><span class="ne-text">R 位(在它的内部表中)</span></code><span class="ne-text">，修改页表项使其指向正确的页面，并设置为 </span><code class="ne-code"><span class="ne-text">READ ONLY</span></code><span class="ne-text"> 模式，然后重新启动引起缺页中断的指令。如果页面随后被修改，就会发生另一个缺页异常。从而允许操作系统设置 M 位并把页面的模式设置为 </span><code class="ne-code"><span class="ne-text">READ/WRITE</span></code><span class="ne-text">。</span></p><p id="1cdfab7830fe96b8bd64eba745fa4f54" class="ne-p"><br></p><p id="8dac468a9941b20f7d32592bf3233e15" class="ne-p"><span class="ne-text">可以用 R 位和 M 位来构造一个简单的页面置换算法：当启动一个进程时，操作系统将其所有页面的两个位都设置为 0。R 位定期的被清零（在每个时钟中断）。用来将最近未引用的页面和已引用的页面分开。</span></p><p id="6f7fbf64554353465ff29f99860787b3" class="ne-p"><br></p><p id="39bab2fdc8db36d5ebb838bbc9610a1e" class="ne-p"><span class="ne-text">当出现缺页中断后，操作系统会检查所有的页面，并根据它们的 R 位和 M 位将当前值分为四类：</span></p><p id="abc034f6c92699f9fbdd74ea4d336581" class="ne-p"><br></p><ul class="ne-ul"><li id="7f488d4df8b3c78c1612b6b90607a6ec"><span class="ne-text">第 0 类：没有引用 R，没有修改 M</span></li><li id="6e0da38d60df8303cdfb64d30e7ae9f9"><span class="ne-text">第 1 类：没有引用 R，已修改 M</span></li></ul><ul class="ne-ul"><li id="e52f9551f8862c020d85a689e7669461"><span class="ne-text">第 2 类：引用 R ，没有修改 M</span></li><li id="2098c1e2e0738f1af205e33bac18f3f8"><span class="ne-text">第 3 类：已被访问 R，已被修改 M</span></li></ul><p id="19ca51f0ab68b170e6b85ceff4a1422c" class="ne-p"><br></p><p id="55b6e4fc2dcc6d749c16ef21258bf769" class="ne-p"><span class="ne-text">尽管看起来好像无法实现第一类页面，但是当第三类页面的 R 位被时钟中断清除时，它们就会发生。时钟中断不会清除 M 位，因为需要这个信息才能知道是否写回磁盘中。清除 R 但不清除 M 会导致出现一类页面。</span></p><p id="19f438a3cf1ce096f4968e4f66c24d05" class="ne-p"><br></p><p id="3639cbe3d0887d2760c552159b6ac088" class="ne-p"><code class="ne-code"><span class="ne-text">NRU(Not Recently Used)</span></code><span class="ne-text"> 算法从编号最小的非空类中随机删除一个页面。此算法隐含的思想是，在一个时钟内（约 20 ms）淘汰一个已修改但是没有被访问的页面要比一个大量引用的未修改页面好，NRU 的主要优点是</span><strong><span class="ne-text">易于理解并且能够有效的实现</span></strong><span class="ne-text">。</span></p><p id="e69f0a756fab88cc1ab941d6eb5f0429" class="ne-p"><br></p><h3 id="ef992930"><span class="ne-text">先进先出页面置换算法</span></h3><p id="b54cfe45e7d8a2900b5ab6e37cac9c7d" class="ne-p"><br></p><p id="cedbd31bfca554665ded81b0817e03ff" class="ne-p"><span class="ne-text">另一种开销较小的方式是使用 </span><code class="ne-code"><span class="ne-text">FIFO(First-In,First-Out)</span></code><span class="ne-text"> 算法，这种类型的数据结构也适用在页面置换算法中。由操作系统维护一个所有在当前内存中的页面的链表，最早进入的放在表头，最新进入的页面放在表尾。在发生缺页异常时，会把头部的页移除并且把新的页添加到表尾。</span></p><p id="017b429504dba6c1df0a023aed81995c" class="ne-p"><br></p><h3 id="fbe44333"><span class="ne-text">第二次机会页面置换算法</span></h3><p id="dec3701d79739bc3cf2072c3170b98e4" class="ne-p"><br></p><p id="b0f6d433a3bf62769df7a29957f2f42f" class="ne-p"><span class="ne-text">我们上面学到的 FIFO 链表页面有个</span><code class="ne-code"><span class="ne-text">缺陷</span></code><span class="ne-text">，那就是出链和入链并不会进行 check </span><code class="ne-code"><span class="ne-text">检查</span></code><span class="ne-text">，这样就会容易把经常使用的页面置换出去，为了避免这一问题，我们对该算法做一个简单的修改：我们检查最老页面的 </span><code class="ne-code"><span class="ne-text">R 位</span></code><span class="ne-text">，如果是 0 ，那么这个页面就是最老的而且没有被使用，那么这个页面就会被立刻换出。如果 R 位是 1，那么就清除此位，此页面会被放在链表的尾部，修改它的装入时间就像刚放进来的一样。然后继续搜索。</span></p><p id="d6333e220f33af321d74ec854f04b55a" class="ne-p"><br></p><p id="089f8f24e153eee75e5e435a679afa1e" class="ne-p"><span class="ne-text">这种算法叫做 </span><code class="ne-code"><span class="ne-text">第二次机会(second chance)</span></code><span class="ne-text">算法，就像下面这样，我们看到页面 A 到 H 保留在链表中，并按到达内存的时间排序。</span></p><p id="a28bcb1486944b773b50fcf51df4749c" class="ne-p"><br></p><p id="fde6e179989ecc6f697670c740914dce" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830001-d17523cc-7d04-4aa5-9b91-7cb47cc26508.png" width="731" id="fCBHb" class="ne-image"></p><p id="57038d8271d2c901cbf3b2f205aa4536" class="ne-p"><br></p><p id="c231a3eb1c1ffe613e927adb3cc23dfc" class="ne-p"><span class="ne-text">a）按照先进先出的方法排列的页面；b）在时刻 20 处发生缺页异常中断并且 A 的 R 位已经设置时的页面链表。</span></p><p id="dfb82b03a7f6557807ac7332498453cc" class="ne-p"><br></p><p id="6071f4976010720b318f23a5435af7c9" class="ne-p"><span class="ne-text">假设缺页异常发生在时刻 20 处，这时最老的页面是 A ，它是在 0 时刻到达的。如果 A 的 R 位是 0，那么它将被淘汰出内存，或者把它写回磁盘（如果它已经被修改过），或者只是简单的放弃（如果它是未被修改过）。另一方面，如果它的 R 位已经设置了，则将 A 放到链表的尾部并且重新设置</span><code class="ne-code"><span class="ne-text">装入时间</span></code><span class="ne-text">为当前时刻（20 处），然后清除 R 位。然后从 B 页面开始继续搜索合适的页面。</span></p><p id="9254e5ee7d07b1644978e8fae8815ee4" class="ne-p"><br></p><p id="213128048d32400dc1be31f0854dccca" class="ne-p"><span class="ne-text">寻找第二次机会的是在最近的时钟间隔中未被访问过的页面。如果所有的页面都被访问过，该算法就会被简化为单纯的 </span><code class="ne-code"><span class="ne-text">FIFO 算法</span></code><span class="ne-text">。具体来说，假设图 a 中所有页面都设置了 R 位。操作系统将页面依次移到链表末尾，每次都在添加到末尾时清除 R 位。最后，算法又会回到页面 A，此时的 R 位已经被清除，那么页面 A 就会被执行出链处理，因此算法能够正常结束。</span></p><p id="006bfd0eee72f06883aeacf0049fb0e5" class="ne-p"><br></p><h3 id="77c3ba6e"><span class="ne-text">时钟页面置换算法</span></h3><p id="ad9e64b0208686171b28fcdaa3269f69" class="ne-p"><br></p><p id="6753b55523ed6e4fbb740e4d95f05fec" class="ne-p"><span class="ne-text">一种比较好的方式是把所有的页面都保存在一个类似钟面的环形链表中，一个表针指向最老的页面。如下图所示</span></p><p id="8ab484c60155725d209fbb22b51d2566" class="ne-p"><br></p><p id="52032f6515f4f45cee8fedf418227902" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830029-543aeeff-242c-4b6f-a9a4-87fa9b101280.png" width="669" id="Xw06o" class="ne-image"></p><p id="a537643cb2a9b195c3c6ed6460bb4427" class="ne-p"><br></p><p id="34c47bdd9eccecfd23ed6a6c98202f9e" class="ne-p"><span class="ne-text">当缺页错误出现时，算法首先检查表针指向的页面，如果它的 R 位是 0 就淘汰该页面，并把新的页面插入到这个位置，然后把表针向前移动一位；如果 R 位是 1 就清除 R 位并把表针前移一个位置。重复这个过程直到找到了一个 R 位为 0 的页面位置。了解这个算法的工作方式，就明白为什么它被称为 </span><code class="ne-code"><span class="ne-text">时钟(clokc)</span></code><span class="ne-text">算法了。</span></p><p id="2bb310c9d960a15e936ed5cd9874ca22" class="ne-p"><br></p><h3 id="a918bb5b"><span class="ne-text">最近最少使用页面置换算法</span></h3><p id="dcd37ab4af6b75e405921bbc1c037e68" class="ne-p"><br></p><p id="205663d914713ca94cf7dee4abb58f3b" class="ne-p"><span class="ne-text">在前面几条指令中频繁使用的页面和可能在后面的几条指令中被使用。反过来说，已经很久没有使用的页面有可能在未来一段时间内仍不会被使用。这个思想揭示了一个可以实现的算法：在缺页中断时，置换未使用时间最长的页面。这个策略称为 </span><code class="ne-code"><span class="ne-text">LRU(Least Recently Used)</span></code><span class="ne-text"> ，最近最少使用页面置换算法。</span></p><p id="7b1a47269ade45a6f9b444a5e67e2b4a" class="ne-p"><br></p><p id="9e365e147cef6fb0ce851d48e6498ae7" class="ne-p"><span class="ne-text">虽然 LRU 在理论上是可以实现的，但是从长远看来代价比较高。为了完全实现 LRU，会在内存中维护一个所有页面的链表，最频繁使用的页位于表头，最近最少使用的页位于表尾。困难的是在每次内存引用时更新整个链表。在链表中找到一个页面，删除它，然后把它移动到表头是一个非常耗时的操作，即使使用</span><code class="ne-code"><span class="ne-text">硬件</span></code><span class="ne-text">来实现也是一样的费时。</span></p><p id="ce5addf295db9d862f1c198299520382" class="ne-p"><br></p><h3 id="3d8761a9"><span class="ne-text">用软件模拟 LRU</span></h3><p id="37d6bfe86f6fcc86a602d5597f75e357" class="ne-p"><br></p><p id="6061c314c4be9623fa92455e73227ba8" class="ne-p"><span class="ne-text">尽管上面的 LRU 算法在原则上是可以实现的，</span><strong><span class="ne-text">但是很少有机器能够拥有那些特殊的硬件</span></strong><span class="ne-text">。上面是硬件的实现方式，那么现在考虑要用</span><code class="ne-code"><span class="ne-text">软件</span></code><span class="ne-text">来实现 LRU 。一种可以实现的方案是 </span><code class="ne-code"><span class="ne-text">NFU(Not Frequently Used，最不常用)</span></code><span class="ne-text">算法。它需要一个软件计数器来和每个页面关联，初始化的时候是 0 。在每个时钟中断时，操作系统会浏览内存中的所有页，会将每个页面的 R 位（0 或 1）加到它的计数器上。这个计数器大体上跟踪了各个页面访问的频繁程度。当缺页异常出现时，则置换计数器值最小的页面。</span></p><p id="2a6159adb02ff3cc9bce97cd9579d42e" class="ne-p"><br></p><p id="a7be3c75d28420ac502d39512cf7dc74" class="ne-p"><span class="ne-text">只需要对 NFU 做一个简单的修改就可以让它模拟 LRU，这个修改有两个步骤</span></p><p id="a1f2097df3061d1fd3dbb757d747437f" class="ne-p"><br></p><ul class="ne-ul"><li id="4bbd7f83857962a0edf2928dd13577f4"><span class="ne-text">首先，在 R 位被添加进来之前先把计数器右移一位；</span></li><li id="4583a5fcd17a9fe4311405a164d135ef"><span class="ne-text">第二步，R 位被添加到最左边的位而不是最右边的位。</span></li></ul><p id="b2717e6278239c301fbc4d9e32bb5ba8" class="ne-p"><br></p><p id="6a60486aae78656f5b1415e75528cf92" class="ne-p"><span class="ne-text">修改以后的算法称为 </span><code class="ne-code"><span class="ne-text">老化(aging)</span></code><span class="ne-text"> 算法，下图解释了老化算法是如何工作的。</span></p><p id="0e45535a1d54c69288a3c65fdd3f9eda" class="ne-p"><br></p><p id="17f0818b86d3528d2d965e22f418a75b" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830078-9cab6ac9-f2fa-4395-b8d5-57b61a80e6d3.png" width="747" id="kzyJK" class="ne-image"></p><p id="f34b569fc53d87a9b00b7727cfc529dd" class="ne-p"><br></p><p id="c81d065239846ddb58479859917fabc9" class="ne-p"><span class="ne-text">我们假设在第一个时钟周期内页面 0 - 5 的 R 位依次是 1，0，1，0，1，1，（也就是页面 0 是 1，页面 1 是 0，页面 2 是 1 这样类推）。也就是说，</span><strong><span class="ne-text">在 0 个时钟周期到 1 个时钟周期之间，0，2，4，5 都被引用了</span></strong><span class="ne-text">，从而把它们的 R 位设置为 1，剩下的设置为 0 。在相关的六个计数器被右移之后 R 位被添加到 </span><code class="ne-code"><span class="ne-text">左侧</span></code><span class="ne-text"> ，就像上图中的 a。剩下的四列显示了接下来的四个时钟周期内的六个计数器变化。</span></p><p id="499a1052524254f8661e3f408cf21aa3" class="ne-p"><br></p><div class="ne-quote"><p id="129f113f3de0adc28d4390fd9db25563" class="ne-p"><span class="ne-text">CPU正在以某个频率前进，该频率的周期称为</span><code class="ne-code"><span class="ne-text">时钟滴答</span></code><span class="ne-text">或</span><code class="ne-code"><span class="ne-text">时钟周期</span></code><span class="ne-text">。一个 100Mhz 的处理器每秒将接收100,000,000个时钟滴答。</span></p></div><p id="eaca1a1c1cedd12caea8a55b7023c5df" class="ne-p"><br></p><p id="22915b2fc6fa12c8e3283015a6e73231" class="ne-p"><span class="ne-text">当缺页异常出现时，将</span><code class="ne-code"><span class="ne-text">置换（就是移除）</span></code><span class="ne-text">计数器值最小的页面。如果一个页面在前面 4 个时钟周期内都没有被访问过，那么它的计数器应该会有四个连续的 0 ，因此它的值肯定要比前面 3 个时钟周期内都没有被访问过的页面的计数器小。</span></p><p id="6ac140bf2daf5bfd92cfe42f2385f2ff" class="ne-p"><br></p><p id="dcf4a0b873c335c26afd35584ae48010" class="ne-p"><span class="ne-text">这个算法与 LRU 算法有两个重要的区别：看一下上图中的 </span><code class="ne-code"><span class="ne-text">e</span></code><span class="ne-text">，第三列和第五列</span></p><p id="b83cb567bda1ff21e9c305d5e47b6dc1" class="ne-p"><br></p><p id="67b39e8eb31df20830950dcf649331c2" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830053-3463258f-69af-41f6-94ed-94a15761844e.png" width="763" id="BE7AZ" class="ne-image"></p><p id="0673d7e6e35f4f09d2394193508d2a05" class="ne-p"><br></p><h3 id="3b91d1a3"><span class="ne-text">工作集时钟页面置换算法</span></h3><p id="63abd06159f80e0e075790bb08d4ffed" class="ne-p"><br></p><p id="73bb03fe3aaa4adac274dc16a8d05404" class="ne-p"><span class="ne-text">当缺页异常发生后，需要扫描整个页表才能确定被淘汰的页面，因此基本工作集算法还是比较浪费时间的。一个对基本工作集算法的提升是基于时钟算法但是却使用工作集的信息，这种算法称为</span><code class="ne-code"><span class="ne-text">WSClock(工作集时钟)</span></code><span class="ne-text">。由于它的实现简单并且具有高性能，因此在实践中被广泛应用。</span></p><p id="d58ba8b46f716fecbc53ecbc4210e48b" class="ne-p"><br></p><p id="3944528a9e5d2af730bcc21a6fcbc8ab" class="ne-p"><span class="ne-text">与时钟算法一样，所需的数据结构是一个以页框为元素的循环列表，就像下面这样</span></p><p id="01d5cdf75a341e23abd1d6d52c38226f" class="ne-p"><br></p><p id="a2e7cd58c23ca108b5363f7a00477f63" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830081-e96444ca-dda9-4c3f-9af5-e0db74d03a6f.png" width="705" id="tl5hI" class="ne-image"></p><p id="2d178410b1a9f1db6d542c7530824d29" class="ne-p"><br></p><p id="de674762efef1a1d31d2a2f9116a6360" class="ne-p"><span class="ne-text"> 工作集时钟页面置换算法的操作：a) 和 b) 给出 R = 1 时所发生的情形；c) 和 d) 给出 R = 0 的例子</span></p><p id="376ca02884d8a1d9619e3a218afdf8b0" class="ne-p"><br></p><p id="63fe0e0e76165313969aad9b5a52a257" class="ne-p"><span class="ne-text">最初的时候，该表是空的。当装入第一个页面后，把它加载到该表中。随着更多的页面的加入，它们形成一个环形结构。每个表项包含来自基本工作集算法的上次使用时间，以及 R 位（已标明）和 M 位（未标明）。</span></p><p id="7e3a6f2fed60f5194bfd204102e2952d" class="ne-p"><br></p><p id="957756ce70967b23ea6854a4f43d3a03" class="ne-p"><span class="ne-text">与时钟算法一样，在每个缺页异常时，首先检查指针指向的页面。如果 R 位被是设置为 1，该页面在当前时钟周期内就被使用过，那么该页面就不适合被淘汰。然后把该页面的 R 位置为 0，指针指向下一个页面，并重复该算法。该事件序列化后的状态参见图 b。</span></p><p id="660512e597b1be7f79759c859c5ad630" class="ne-p"><br></p><p id="3131acf40f8b8061433775a713b92569" class="ne-p"><span class="ne-text">现在考虑指针指向的页面 R = 0 时会发生什么，参见图 c，如果页面的使用期限大于 t 并且页面为被访问过，那么这个页面就不会在工作集中，并且在磁盘上会有一个此页面的副本。申请重新调入一个新的页面，并把新的页面放在其中，如图 d 所示。另一方面，如果页面被修改过，就不能重新申请页面，因为这个页面在磁盘上没有有效的副本。为了避免由于调度写磁盘操作引起的进程切换，指针继续向前走，算法继续对下一个页面进行操作。毕竟，有可能存在一个老的，没有被修改过的页面可以立即使用。</span></p><p id="259f8e1c415f1f342157b2c74fa8531d" class="ne-p"><br></p><p id="c3a7464fe9b882ee84c2133203efbc8f" class="ne-p"><span class="ne-text">原则上来说，所有的页面都有可能因为</span><code class="ne-code"><span class="ne-text">磁盘I/O</span></code><span class="ne-text"> 在某个时钟周期内被调度。为了降低磁盘阻塞，需要设置一个限制，即最大只允许写回 n 个页面。一旦达到该限制，就不允许调度新的写操作。</span></p><p id="14bb94ec4633fd27809f92c905c5c4a0" class="ne-p"><br></p><p id="6b5f609cfef9d1be84780092687527ed" class="ne-p"><span class="ne-text">那么就有个问题，指针会绕一圈回到原点的，如果回到原点，它的起始点会发生什么？这里有两种情况：</span></p><p id="af605baae7a6291209d87aad111ebdde" class="ne-p"><br></p><ul class="ne-ul"><li id="be710c9c234ad6ebc9bb28abb8befd14"><span class="ne-text">至少调度了一次写操作</span></li><li id="1f5761b8fa6436255d40db750cdca12c"><span class="ne-text">没有调度过写操作</span></li></ul><p id="d327ffc3f06f2f92e3638b05eb18f99f" class="ne-p"><br></p><p id="f279a05a1c84ac5f4f42f1b687ca65e9" class="ne-p"><span class="ne-text">在第一种情况中，指针仅仅是不停的移动，寻找一个未被修改过的页面。由于已经调度了一个或者多个写操作，最终会有某个写操作完成，它的页面会被标记为未修改。置换遇到的第一个未被修改过的页面，这个页面不一定是第一个被调度写操作的页面，因为硬盘驱动程序为了优化性能可能会把写操作重排序。</span></p><p id="f975c09f26fb82689584d8824d592a03" class="ne-p"><br></p><p id="9a686c8455f99d36ff56e36cb6856304" class="ne-p"><span class="ne-text">对于第二种情况，所有的页面都在工作集中，否则将至少调度了一个写操作。由于缺乏额外的信息，最简单的方法就是置换一个未被修改的页面来使用，扫描中需要记录未被修改的页面的位置，如果不存在未被修改的页面，就选定当前页面并把它写回磁盘。</span></p><p id="22bc054ec4116393b13ced80f5f13f97" class="ne-p"><br></p><h3 id="88464125"><span class="ne-text">页面置换算法小结</span></h3><p id="c76fb75fa6f7d1c2e423f6396b4d785a" class="ne-p"><br></p><p id="a4a73b9727c0408ace20acf41c243df7" class="ne-p"><span class="ne-text">我们到现在已经研究了各种页面置换算法，现在我们来一个简单的总结，算法的总结归纳如下</span></p><table id="1b009b27" class="ne-table" style="width: 750px"><tbody><tr style="height: 33px"><td width="375"><p id="u8155d1fa" class="ne-p"><span class="ne-text">算法</span></p></td><td width="375"><p id="ub91c6a44" class="ne-p"><span class="ne-text">注释</span></p></td></tr><tr style="height: 33px"><td width="375"><p id="u9675e649" class="ne-p"><span class="ne-text">最优算法</span></p></td><td width="375"><p id="ua39abb97" class="ne-p"><span class="ne-text">不可实现，但可以用作基准</span></p></td></tr><tr style="height: 33px"><td width="375"><p id="u394e510f" class="ne-p"><span class="ne-text">NRU(最近未使用) 算法</span></p></td><td width="375"><p id="uf3d6826a" class="ne-p"><span class="ne-text">和 LRU 算法很相似</span></p></td></tr><tr style="height: 33px"><td width="375"><p id="u26c74d8a" class="ne-p"><span class="ne-text">FIFO(先进先出) 算法</span></p></td><td width="375"><p id="u7ac53964" class="ne-p"><span class="ne-text">有可能会抛弃重要的页面</span></p></td></tr><tr style="height: 33px"><td width="375"><p id="ubd2f9fd7" class="ne-p"><span class="ne-text">第二次机会算法</span></p></td><td width="375"><p id="u74ec06bd" class="ne-p"><span class="ne-text">比 FIFO 有较大的改善</span></p></td></tr><tr style="height: 33px"><td width="375"><p id="ueb91d76a" class="ne-p"><span class="ne-text">时钟算法</span></p></td><td width="375"><p id="u34def58d" class="ne-p"><span class="ne-text">实际使用</span></p></td></tr><tr style="height: 33px"><td width="375"><p id="uff3a1852" class="ne-p"><span class="ne-text">LRU(最近最少)算法</span></p></td><td width="375"><p id="u5613a15a" class="ne-p"><span class="ne-text">比较优秀，但是很难实现</span></p></td></tr><tr style="height: 33px"><td width="375"><p id="u7a5e614f" class="ne-p"><span class="ne-text">NFU(最不经常食用)算法</span></p></td><td width="375"><p id="uc4d42f56" class="ne-p"><span class="ne-text">和 LRU 很类似</span></p></td></tr><tr style="height: 33px"><td width="375"><p id="u97c1197a" class="ne-p"><span class="ne-text">老化算法</span></p></td><td width="375"><p id="u1102fb4d" class="ne-p"><span class="ne-text">近似 LRU 的高效算法</span></p></td></tr><tr style="height: 33px"><td width="375"><p id="udcc054bf" class="ne-p"><span class="ne-text">工作集算法</span></p></td><td width="375"><p id="u04210cf5" class="ne-p"><span class="ne-text">实施起来开销很大</span></p></td></tr><tr style="height: 33px"><td width="375"><p id="u9cb6c78e" class="ne-p"><span class="ne-text">工作集时钟算法</span></p></td><td width="375"><p id="uac13bd4a" class="ne-p"><span class="ne-text">比较有效的算法</span></p></td></tr></tbody></table><p id="95ce7ac6c96f2836c1da1058696564f2" class="ne-p"><br></p><ul class="ne-ul"><li id="706a0737a142822991e3b2d4119a9f68"><code class="ne-code"><span class="ne-text">最优算法</span></code><span class="ne-text">在当前页面中置换最后要访问的页面。不幸的是，没有办法来判定哪个页面是最后一个要访问的，</span><code class="ne-code"><span class="ne-text">因此实际上该算法不能使用</span></code><span class="ne-text">。然而，它可以作为衡量其他算法的标准。</span></li><li id="234dd392c4e9dd0ebf9e661f94d080f5"><code class="ne-code"><span class="ne-text">NRU</span></code><span class="ne-text"> 算法根据 R 位和 M 位的状态将页面氛围四类。从编号最小的类别中随机选择一个页面。NRU 算法易于实现，但是性能不是很好。存在更好的算法。</span></li></ul><ul class="ne-ul"><li id="c8f6c0a7d8a9df2355aa867a989f0b49"><code class="ne-code"><span class="ne-text">FIFO</span></code><span class="ne-text"> 会跟踪页面加载进入内存中的顺序，并把页面放入一个链表中。有可能删除存在时间最长但是还在使用的页面，因此这个算法也不是一个很好的选择。</span></li><li id="7fbec0a11e860f50edfed9e85c41b9f8"><code class="ne-code"><span class="ne-text">第二次机会</span></code><span class="ne-text">算法是对 FIFO 的一个修改，它会在删除页面之前检查这个页面是否仍在使用。如果页面正在使用，就会进行保留。这个改进大大提高了性能。</span></li></ul><ul class="ne-ul"><li id="ab0708a3d3cf4e9100075a87c9844641"><code class="ne-code"><span class="ne-text">时钟</span></code><span class="ne-text"> 算法是第二次机会算法的另外一种实现形式，时钟算法和第二次算法的性能差不多，但是会花费更少的时间来执行算法。</span></li><li id="416499a4e283e26c762f68ae643534cb"><code class="ne-code"><span class="ne-text">LRU</span></code><span class="ne-text"> 算法是一个非常优秀的算法，但是没有</span><code class="ne-code"><span class="ne-text">特殊的硬件(TLB)</span></code><span class="ne-text">很难实现。如果没有硬件，就不能使用 LRU 算法。</span></li></ul><ul class="ne-ul"><li id="0f2459808b7e2868c13dcbefd2ac7590"><code class="ne-code"><span class="ne-text">NFU</span></code><span class="ne-text"> 算法是一种近似于 LRU 的算法，它的性能不是非常好。</span></li><li id="f620cb928c9ef81c30cec4bd9400d7ce"><code class="ne-code"><span class="ne-text">老化</span></code><span class="ne-text"> 算法是一种更接近 LRU 算法的实现，并且可以更好的实现，因此是一个很好的选择</span></li></ul><ul class="ne-ul"><li id="69318a6d572af791c360d57906970f77"><span class="ne-text">最后两种算法都使用了工作集算法。工作集算法提供了合理的性能开销，但是它的实现比较复杂。</span><code class="ne-code"><span class="ne-text">WSClock</span></code><span class="ne-text"> 是另外一种变体，它不仅能够提供良好的性能，而且可以高效地实现。</span></li></ul><p id="d21cffc43ac7dcbfeeae73c897933787" class="ne-p"><br></p><p id="943b2ac9ccdf5bcd3ad85d6c44db2f03" class="ne-p"><span class="ne-text">总之，</span><strong><span class="ne-text">最好的算法是老化算法和WSClock算法</span></strong><span class="ne-text">。他们分别是基于 LRU 和工作集算法。他们都具有良好的性能并且能够被有效的实现。还存在其他一些好的算法，但实际上这两个可能是最重要的。</span></p><p id="70262061a374bbe6c590cdc622d20dd3" class="ne-p"><br></p><p id="318317ce1479c23add8291c2bdd17d4c" class="ne-p"><span class="ne-text">下面来聊一聊文件系统，你需要知道下面这些知识点</span></p><p id="54b70121bb60e581d442d6b45ec1f775" class="ne-p"><br></p><p id="0626228031f054313c8c68db9c55566d" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830114-09f30aaf-25b8-44c3-992a-577e4c3a833c.png" width="721" id="MOs6Q" class="ne-image"></p><p id="68aa5203572adaa78a2cacc78c181478" class="ne-p"><br></p><h2 id="2a0c4740"><span class="ne-text">文件</span></h2><p id="0e1a4d0a2da43ff7a64f39e8a2ccc002" class="ne-p"><br></p><h3 id="42b5d073"><span class="ne-text">文件命名</span></h3><p id="39eaa5bb7eaee0059fc8f8ab050013c3" class="ne-p"><br></p><p id="ac843df76f1fa5996bb18f7b8f3abeff" class="ne-p"><span class="ne-text">文件是一种抽象机制，它提供了一种方式用来存储信息以及在后面进行读取。可能任何一种机制最重要的特性就是管理对象的命名方式。在创建一个文件后，它会给文件一个命名。当进程终止时，文件会继续存在，并且其他进程可以使用</span><code class="ne-code"><span class="ne-text">名称访问该文件</span></code><span class="ne-text">。</span></p><p id="7a4f2e6c93c769b7b830ce3a98164e0a" class="ne-p"><br></p><p id="1aa170f1d7914802b5f71c9fa09eea8c" class="ne-p"><span class="ne-text">文件命名规则对于不同的操作系统来说是不一样的，但是所有现代操作系统都允许使用 1 - 8 个字母的字符串作为合法文件名。</span></p><p id="549e424671eb70506667316221ea0b6a" class="ne-p"><br></p><p id="947a29553feb4fed91e398dd0b909941" class="ne-p"><span class="ne-text">某些文件区分大小写字母，而大多数则不区分。</span><code class="ne-code"><span class="ne-text">UNIX</span></code><span class="ne-text"> 属于第一类；历史悠久的 </span><code class="ne-code"><span class="ne-text">MS-DOS</span></code><span class="ne-text"> 属于第二类（顺便说一句，尽管 MS-DOS 历史悠久，但 MS-DOS 仍在嵌入式系统中非常广泛地使用，因此它绝不是过时的）；因此，UNIX 系统会有三种不同的命名文件：</span><code class="ne-code"><span class="ne-text">maria</span></code><span class="ne-text">、</span><code class="ne-code"><span class="ne-text">Maria</span></code><span class="ne-text">、</span><code class="ne-code"><span class="ne-text">MARIA</span></code><span class="ne-text"> 。在 MS-DOS ，所有这些命名都属于相同的文件。</span></p><p id="ca90743de49e769fc630a186e1284fae" class="ne-p"><br></p><p id="a406e7618fc08a6827c4aef95651a84b" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830120-5ba4f13c-ee71-46f2-a110-e2eaf1dbf324.png" width="691" id="JHfwL" class="ne-image"></p><p id="afc97bceb18793a83e8a6d91c9533dfc" class="ne-p"><br></p><p id="6ae582e29691ea6d28dfb309f8a33d63" class="ne-p"><span class="ne-text">许多操作系统支持两部分的文件名，它们之间用 </span><code class="ne-code"><span class="ne-text">.</span></code><span class="ne-text"> 分隔开，比如文件名 </span><code class="ne-code"><span class="ne-text">prog.c</span></code><span class="ne-text">。原点后面的文件称为 </span><code class="ne-code"><span class="ne-text">文件扩展名(file extension)</span></code><span class="ne-text"> ，文件扩展名通常表示文件的一些信息。一些常用的文件扩展名以及含义如下图所示</span></p><table id="7f756c92" class="ne-table" style="width: 750px"><tbody><tr style="height: 33px"><td width="375"><p id="u86bcac8e" class="ne-p"><span class="ne-text">扩展名</span></p></td><td width="375"><p id="u7fa179fd" class="ne-p"><span class="ne-text">含义</span></p></td></tr><tr style="height: 33px"><td width="375"><p id="u3c31ee67" class="ne-p"><span class="ne-text">bak</span></p></td><td width="375"><p id="ub1009dae" class="ne-p"><span class="ne-text">备份文件</span></p></td></tr><tr style="height: 33px"><td width="375"><p id="u8e21211b" class="ne-p"><span class="ne-text">c</span></p></td><td width="375"><p id="ub7814047" class="ne-p"><span class="ne-text">c 源程序文件</span></p></td></tr><tr style="height: 33px"><td width="375"><p id="u60b4b5ca" class="ne-p"><span class="ne-text">gif</span></p></td><td width="375"><p id="uc630794d" class="ne-p"><span class="ne-text">符合图形交换格式的图像文件</span></p></td></tr><tr style="height: 33px"><td width="375"><p id="u8fc5ed2b" class="ne-p"><span class="ne-text">hlp</span></p></td><td width="375"><p id="u4100d4e1" class="ne-p"><span class="ne-text">帮助文件</span></p></td></tr><tr style="height: 33px"><td width="375"><p id="u126c4c61" class="ne-p"><span class="ne-text">html</span></p></td><td width="375"><p id="u6d6dd5e8" class="ne-p"><span class="ne-text">WWW 超文本标记语言文档</span></p></td></tr><tr style="height: 33px"><td width="375"><p id="uaf121ed5" class="ne-p"><span class="ne-text">jpg</span></p></td><td width="375"><p id="ud8de46a6" class="ne-p"><span class="ne-text">符合 JPEG 编码标准的静态图片</span></p></td></tr><tr style="height: 33px"><td width="375"><p id="udab5f881" class="ne-p"><span class="ne-text">mp3</span></p></td><td width="375"><p id="uaefb3290" class="ne-p"><span class="ne-text">符合 MP3 音频编码格式的音乐文件</span></p></td></tr><tr style="height: 33px"><td width="375"><p id="u6f6a8cf4" class="ne-p"><span class="ne-text">mpg</span></p></td><td width="375"><p id="u4e9b5a7a" class="ne-p"><span class="ne-text">符合 MPEG 编码标准的电影</span></p></td></tr><tr style="height: 33px"><td width="375"><p id="u17182b2f" class="ne-p"><span class="ne-text">o</span></p></td><td width="375"><p id="uba61755c" class="ne-p"><span class="ne-text">目标文件（编译器输出格式，尚未链接）</span></p></td></tr><tr style="height: 33px"><td width="375"><p id="uc827d007" class="ne-p"><span class="ne-text">pdf</span></p></td><td width="375"><p id="u490abaca" class="ne-p"><span class="ne-text">pdf 格式的文件</span></p></td></tr><tr style="height: 33px"><td width="375"><p id="u8deec9bc" class="ne-p"><span class="ne-text">ps</span></p></td><td width="375"><p id="u480b1c6a" class="ne-p"><span class="ne-text">PostScript 文件</span></p></td></tr><tr style="height: 33px"><td width="375"><p id="u3341c4b9" class="ne-p"><span class="ne-text">tex</span></p></td><td width="375"><p id="uef7e717f" class="ne-p"><span class="ne-text">为 TEX 格式化程序准备的输入文件</span></p></td></tr><tr style="height: 33px"><td width="375"><p id="u563e6d6d" class="ne-p"><span class="ne-text">txt</span></p></td><td width="375"><p id="u230821ad" class="ne-p"><span class="ne-text">文本文件</span></p></td></tr><tr style="height: 33px"><td width="375"><p id="u77e32004" class="ne-p"><span class="ne-text">zip</span></p></td><td width="375"><p id="u599395eb" class="ne-p"><span class="ne-text">压缩文件</span></p></td></tr></tbody></table><p id="c6ab14359737194a972479d8287c47a1" class="ne-p"><br></p><p id="4549bf524aabfd45c2fa83047348e305" class="ne-p"><span class="ne-text">在 UNIX 系统中，文件扩展名只是一种约定，操作系统并不强制采用。</span></p><p id="d4f6ff6d0e62a25ca2d68a7c83d9af63" class="ne-p"><br></p><h3 id="68d96662"><span class="ne-text">文件结构</span></h3><p id="e267d3840df18b33c8d7169b8089f9f5" class="ne-p"><br></p><p id="aab7d13a47a4100ca4968738f5dec9af" class="ne-p"><span class="ne-text">文件的构造有多种方式。下图列出了常用的三种构造方式</span></p><p id="05b429377a0f05d00edcba9ad1341ff3" class="ne-p"><br></p><p id="0eeb7da1658a82bc57977ae24dd2c8e8" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830179-1cd3ea7b-cf21-432f-a8e4-c2d8f317e0ff.png" width="728" id="HSm1k" class="ne-image"></p><p id="66e04dd599052b4626cdb9aedfdd4ce2" class="ne-p"><br></p><p id="84f276b301ae3859ddde1903c0c2b706" class="ne-p"><span class="ne-text"> 三种不同的文件。 a) 字节序列 。b) 记录序列。c) 树</span></p><p id="0e82b2e8eb49dec1dc54c30359b708b0" class="ne-p"><br></p><p id="a970ad933a1746cea41087c5b928095b" class="ne-p"><span class="ne-text">上图中的 a 是一种无结构的字节序列，操作系统不关心序列的内容是什么，操作系统能看到的就是</span><code class="ne-code"><span class="ne-text">字节(bytes)</span></code><span class="ne-text">。其文件内容的任何含义只在用户程序中进行解释。UNIX 和 Windows 都采用这种办法。</span></p><p id="715200795b1099f573c996fc4f5ade2c" class="ne-p"><br></p><p id="e40d5e148ce0e55c7c15939cc5e60d7c" class="ne-p"><span class="ne-text">图 b 表示在文件结构上的第一部改进。在这个模型中，文件是具有固定长度记录的序列，每个记录都有其内部结构。 把文件作为记录序列的核心思想是：</span><strong><span class="ne-text">读操作返回一个记录，而写操作重写或者追加一个记录</span></strong><span class="ne-text">。第三种文件结构如上图 c 所示。在这种组织结构中，文件由一颗</span><code class="ne-code"><span class="ne-text">记录树</span></code><span class="ne-text">构成，记录树的长度不一定相同，每个记录树都在记录中的固定位置包含一个</span><code class="ne-code"><span class="ne-text">key</span></code><span class="ne-text"> 字段。这棵树按 key 进行排序，从而可以对特定的 key 进行快速查找。</span></p><p id="a3805c0b27de6eb1994037fb394c695d" class="ne-p"><br></p><h3 id="28b988ce"><span class="ne-text">文件类型</span></h3><p id="dd0277dd6c9510a4288d26904622fa34" class="ne-p"><br></p><p id="700a86aaacacb207860a5ef065bfc842" class="ne-p"><span class="ne-text">很多操作系统支持多种文件类型。例如，UNIX（同样包括 OS X）和 Windows 都具有常规的文件和目录。除此之外，UNIX 还具有</span><code class="ne-code"><span class="ne-text">字符特殊文件(character special file)</span></code><span class="ne-text"> 和 </span><code class="ne-code"><span class="ne-text">块特殊文件(block special file)</span></code><span class="ne-text">。</span><code class="ne-code"><span class="ne-text">常规文件(Regular files)</span></code><span class="ne-text"> 是包含有用户信息的文件。用户一般使用的文件大都是常规文件，常规文件一般包括 </span><strong><span class="ne-text">可执行文件、文本文件、图像文件</span></strong><span class="ne-text">，从常规文件读取数据或将数据写入时，内核会根据文件系统的规则执行操作，是写入可能被延迟，记录日志或者接受其他操作。</span></p><p id="d803466fc9fe85690453543577916782" class="ne-p"><br></p><h3 id="2ca5dd51"><span class="ne-text">文件访问</span></h3><p id="1eea59f4629deed14c4bbefdb9ff560d" class="ne-p"><br></p><p id="b132fe515bd7dd759ef63c37eb082a61" class="ne-p"><span class="ne-text">早期的操作系统只有一种访问方式：</span><code class="ne-code"><span class="ne-text">序列访问(sequential access)</span></code><span class="ne-text">。在这些系统中，进程可以按照顺序读取所有的字节或文件中的记录，但是不能跳过并乱序执行它们。顺序访问文件是可以返回到起点的，需要时可以多次读取该文件。当存储介质是磁带而不是磁盘时，顺序访问文件很方便。</span></p><p id="2149db0b1f4aef60c803eb241beaceb9" class="ne-p"><br></p><p id="dce71c7fccbf2fc8964d659038be9e03" class="ne-p"><span class="ne-text">在使用磁盘来存储文件时，可以不按照顺序读取文件中的字节或者记录，或者按照关键字而不是位置来访问记录。这种能够以任意次序进行读取的称为</span><code class="ne-code"><span class="ne-text">随机访问文件(random access file)</span></code><span class="ne-text">。许多应用程序都需要这种方式。</span></p><p id="4f74717aa95a17e1fcd34889477b996a" class="ne-p"><br></p><p id="008ff964469f0ec53c27329344f05020" class="ne-p"><span class="ne-text">随机访问文件对许多应用程序来说都必不可少，例如，数据库系统。如果乘客打电话预定某航班机票，订票程序必须能够直接访问航班记录，而不必先读取其他航班的成千上万条记录。</span></p><p id="53807ed6cd70ab7d582f3dcdc0fc14c0" class="ne-p"><br></p><p id="af6c758e0caff2e1a559f009fefe473e" class="ne-p"><span class="ne-text">有两种方法可以指示从何处开始读取文件。第一种方法是直接使用 </span><code class="ne-code"><span class="ne-text">read</span></code><span class="ne-text"> 从头开始读取。另一种是用一个特殊的 </span><code class="ne-code"><span class="ne-text">seek</span></code><span class="ne-text"> 操作设置当前位置，在 seek 操作后，从这个当前位置顺序地开始读文件。UNIX 和 Windows 使用的是后面一种方式。</span></p><p id="8020d0101a5f3dcbb54621b955f23d0b" class="ne-p"><br></p><h3 id="0b81772b"><span class="ne-text">文件属性</span></h3><p id="8062f25c30a983560cb8b3e049ade111" class="ne-p"><br></p><p id="3b59c2728b8366a73b1922e7adf5feb0" class="ne-p"><span class="ne-text">文件包括文件名和数据。除此之外，所有的操作系统还会保存其他与文件相关的信息，如文件创建的日期和时间、文件大小。我们可以称这些为文件的</span><code class="ne-code"><span class="ne-text">属性(attributes)</span></code><span class="ne-text">。有些人也喜欢把它们称作 </span><code class="ne-code"><span class="ne-text">元数据(metadata)</span></code><span class="ne-text">。文件的属性在不同的系统中差别很大。文件的属性只有两种状态：</span><code class="ne-code"><span class="ne-text">设置(set)</span></code><span class="ne-text"> 和 </span><code class="ne-code"><span class="ne-text">清除(clear)</span></code><span class="ne-text">。</span></p><p id="ff3234edb116466cf8feb1acf75da02b" class="ne-p"><br></p><h3 id="52cefcb2"><span class="ne-text">文件操作</span></h3><p id="1e779b7cc62a0d85bd60f607a32dfe08" class="ne-p"><br></p><p id="de771a10ee395dd67ec222bec5fdecb7" class="ne-p"><span class="ne-text">使用文件的目的是用来存储信息并方便以后的检索。对于存储和检索，不同的系统提供了不同的操作。以下是与文件有关的最常用的一些系统调用：</span></p><p id="c0724f0565ae49c0d6b6cc475b6ac846" class="ne-p"><br></p><ol class="ne-ol"><li id="504ecd73fd5ceecb12f3932e3f9b2ca1"><code class="ne-code"><span class="ne-text">Create</span></code><span class="ne-text">，创建不包含任何数据的文件。调用的目的是表示文件即将建立，并对文件设置一些属性。</span></li><li id="179ee01cd008860de8a7a253e9d18249"><code class="ne-code"><span class="ne-text">Delete</span></code><span class="ne-text">，当文件不再需要，必须删除它以释放内存空间。为此总会有一个系统调用来删除文件。</span></li></ol><ol start="3" class="ne-ol"><li id="328a4d096282ef0c9bd3f349be56947f"><code class="ne-code"><span class="ne-text">Open</span></code><span class="ne-text">，在使用文件之前，必须先打开文件。这个调用的目的是允许系统将属性和磁盘地址列表保存到主存中，用来以后的快速访问。</span></li><li id="7c85b0b657768dc1ce22864b71e5a08e"><code class="ne-code"><span class="ne-text">Close</span></code><span class="ne-text">，当所有进程完成时，属性和磁盘地址不再需要，因此应关闭文件以释放表空间。很多系统限制进程打开文件的个数，以此达到鼓励用户关闭不再使用的文件。磁盘以块为单位写入，关闭文件时会强制写入最后一</span><code class="ne-code"><span class="ne-text">块</span></code><span class="ne-text">，即使这个块空间内部还不满。</span></li></ol><ol start="5" class="ne-ol"><li id="50bfb078134ebd8dff44c5657d8994e7"><code class="ne-code"><span class="ne-text">Read</span></code><span class="ne-text">，数据从文件中读取。通常情况下，读取的数据来自文件的当前位置。调用者必须指定需要读取多少数据，并且提供存放这些数据的缓冲区。</span></li><li id="43384bb690645e13a262e1955f177b7a"><code class="ne-code"><span class="ne-text">Write</span></code><span class="ne-text">，向文件写数据，写操作一般也是从文件的当前位置开始进行。如果当前位置是文件的末尾，则会直接追加进行写入。如果当前位置在文件中，则现有数据被覆盖，并且永远消失。</span></li></ol><ol start="7" class="ne-ol"><li id="e3f6ff74f235e372c8bbf5609d277cd8"><code class="ne-code"><span class="ne-text">append</span></code><span class="ne-text">，使用 append 只能向文件末尾添加数据。</span></li><li id="b9c24d0c6b35e2bb0b54f846c2f3cbe2"><code class="ne-code"><span class="ne-text">seek</span></code><span class="ne-text">，对于随机访问的文件，要指定从何处开始获取数据。通常的方法是用 seek 系统调用把当前位置指针指向文件中的特定位置。seek 调用结束后，就可以从指定位置开始读写数据了。</span></li></ol><ol start="9" class="ne-ol"><li id="922b6108cf62d8263fbd88c8d5498241"><code class="ne-code"><span class="ne-text">get attributes</span></code><span class="ne-text">，进程运行时通常需要读取文件属性。</span></li><li id="8c8e3ceb23d3a616b99b8b941b08aa52"><code class="ne-code"><span class="ne-text">set attributes</span></code><span class="ne-text">，用户可以自己设置一些文件属性，甚至是在文件创建之后，实现该功能的是 set attributes 系统调用。</span></li></ol><ol start="11" class="ne-ol"><li id="e72eb2d85f14c3f7ac4d9fd59c6888b7"><code class="ne-code"><span class="ne-text">rename</span></code><span class="ne-text">，用户可以自己更改已有文件的名字，rename 系统调用用于这一目的。</span></li></ol><p id="a87343eaf9d3450efabef778da123d99" class="ne-p"><br></p><h2 id="767fa455"><span class="ne-text">目录</span></h2><p id="b9343aee17ca89896a9c0199f20a54f1" class="ne-p"><br></p><p id="3c356aca639851aa2446430e0cf3733e" class="ne-p"><span class="ne-text">文件系统通常提供</span><code class="ne-code"><span class="ne-text">目录(directories)</span></code><span class="ne-text"> 或者 </span><code class="ne-code"><span class="ne-text">文件夹(folders)</span></code><span class="ne-text"> 用于记录文件的位置，在很多系统中目录本身也是文件，下面我们会讨论关于文件，他们的组织形式、属性和可以对文件进行的操作。</span></p><p id="dff0717322930d1c24e5ab4609400092" class="ne-p"><br></p><h3 id="007929bd"><span class="ne-text">一级目录系统</span></h3><p id="34540bcb72c35b535e539c2292febbbb" class="ne-p"><br></p><p id="54065234453c67a62e92fdfbb18d6e66" class="ne-p"><span class="ne-text">目录系统最简单的形式是有一个能够包含所有文件的目录。这种目录被称为</span><code class="ne-code"><span class="ne-text">根目录(root directory)</span></code><span class="ne-text">，由于根目录的唯一性，所以其名称并不重要。在最早期的个人计算机中，这种系统很常见，部分原因是因为只有一个用户。下面是一个单层目录系统的例子</span></p><p id="608cd64c499251753f32da03fb38243a" class="ne-p"><br></p><p id="487deb8f9d390dd52747ae3a2d276448" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830155-ca95d416-207a-46d6-89dd-77c398a175d3.png" width="500" id="LyUcX" class="ne-image"></p><p id="45f33aa4b012163e958412625f737ea8" class="ne-p"><br></p><p id="888aed0ab34181e2ca6fdb1bf464feae" class="ne-p"><span class="ne-text"> 含有四个文件的单层目录系统</span></p><p id="6c96f97c55ea84f77c4863a07950cfa6" class="ne-p"><br></p><p id="06c45b31715829537869cc1e51ceae82" class="ne-p"><span class="ne-text">该目录中有四个文件。这种设计的优点在于简单，并且能够快速定位文件，毕竟只有一个地方可以检索。这种目录组织形式现在一般用于简单的嵌入式设备（如数码相机和某些便携式音乐播放器）上使用。</span></p><p id="05cc9579be20bd8d9cd8382cc614bdd7" class="ne-p"><br></p><h3 id="17225630"><span class="ne-text">层次目录系统</span></h3><p id="a2f4aec9d46fbfd0fca6e2d7fbefc82e" class="ne-p"><br></p><p id="7a7f44ac2994c611f0b66c4e87c0d70e" class="ne-p"><span class="ne-text">对于简单的应用而言，一般都用单层目录方式，但是这种组织形式并不适合于现代计算机，因为现代计算机含有成千上万个文件和文件夹。如果都放在根目录下，查找起来会非常困难。为了解决这一问题，出现了</span><code class="ne-code"><span class="ne-text">层次目录系统(Hierarchical Directory Systems)</span></code><span class="ne-text">，也称为</span><code class="ne-code"><span class="ne-text">目录树</span></code><span class="ne-text">。通过这种方式，可以用很多目录把文件进行分组。进而，如果多个用户共享同一个文件服务器，比如公司的网络系统，每个用户可以为自己的目录树拥有自己的私人根目录。这种方式的组织结构如下</span></p><p id="dbf72bf64d673a9ed4ac556da2b03fc5" class="ne-p"><br></p><p id="8fd241c376d25d675006401b0450d10d" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830190-cdcd48b8-b7ca-4597-b41d-d61089e0250d.png" width="699" id="eyi1a" class="ne-image"></p><p id="595388086341aaf9ea0cc4f986c5f072" class="ne-p"><br></p><p id="1facfc7d32c49c743af569c6eac8ba13" class="ne-p"><span class="ne-text">根目录含有目录 A、B 和 C ，分别属于不同的用户，其中两个用户个字创建了</span><code class="ne-code"><span class="ne-text">子目录</span></code><span class="ne-text">。用户可以创建任意数量的子目录，现代文件系统都是按照这种方式组织的。</span></p><p id="9606d66d6cd5e0bfc4b92e125dce83ca" class="ne-p"><br></p><h3 id="26f36dea"><span class="ne-text">路径名</span></h3><p id="3c68cf4eceb1aebdebb0636d38b6d630" class="ne-p"><br></p><p id="20cf84ba39d49bdb319108dd01bd8f7c" class="ne-p"><span class="ne-text">当目录树组织文件系统时，需要有某种方法指明文件名。常用的方法有两种，第一种方式是每个文件都会用一个</span><code class="ne-code"><span class="ne-text">绝对路径名(absolute path name)</span></code><span class="ne-text">，它由根目录到文件的路径组成。</span></p><p id="7375343f1d5a3e86bc7693dec3e4e850" class="ne-p"><br></p><p id="1864d899922b43e08ec349f3b9185a11" class="ne-p"><span class="ne-text">另外一种指定文件名的方法是 </span><code class="ne-code"><span class="ne-text">相对路径名(relative path name)</span></code><span class="ne-text">。它常常和 </span><code class="ne-code"><span class="ne-text">工作目录(working directory)</span></code><span class="ne-text"> （也称作 </span><code class="ne-code"><span class="ne-text">当前目录(current directory)</span></code><span class="ne-text">）一起使用。用户可以指定一个目录作为当前工作目录。例如，如果当前目录是 </span><code class="ne-code"><span class="ne-text">/usr/ast</span></code><span class="ne-text">，那么绝对路径 </span><code class="ne-code"><span class="ne-text">/usr/ast/mailbox</span></code><span class="ne-text">可以直接使用 </span><code class="ne-code"><span class="ne-text">mailbox</span></code><span class="ne-text"> 来引用。</span></p><p id="4d86e51488f9e3357b3d1c7316d4d4ee" class="ne-p"><br></p><h3 id="20731fe2"><span class="ne-text">目录操作</span></h3><p id="72f0e76f51955e4fd5747f7f47125254" class="ne-p"><br></p><p id="5a42d88e3de5412699ce7ef46d8b0754" class="ne-p"><span class="ne-text">不同文件中管理目录的系统调用的差别比管理文件的系统调用差别大。为了了解这些系统调用有哪些以及它们怎样工作，下面给出一个例子（取自 UNIX）。</span></p><p id="40bbdad75c7cc6d07a2763e60ee386b6" class="ne-p"><br></p><ol class="ne-ol"><li id="b514136adfffb03de670ef5af862b47c"><code class="ne-code"><span class="ne-text">Create</span></code><span class="ne-text">，创建目录，除了目录项 </span><code class="ne-code"><span class="ne-text">.</span></code><span class="ne-text"> 和 </span><code class="ne-code"><span class="ne-text">..</span></code><span class="ne-text"> 外，目录内容为空。</span></li><li id="b11a83b53464bd86401aa01c73f5c27f"><code class="ne-code"><span class="ne-text">Delete</span></code><span class="ne-text">，删除目录，只有空目录可以删除。只包含 </span><code class="ne-code"><span class="ne-text">.</span></code><span class="ne-text"> 和 </span><code class="ne-code"><span class="ne-text">..</span></code><span class="ne-text"> 的目录被认为是空目录，这两个目录项通常不能删除</span></li></ol><ol start="3" class="ne-ol"><li id="963fdf6f08b50d63286bc505dffbf5fb"><code class="ne-code"><span class="ne-text">opendir</span></code><span class="ne-text">，目录内容可被读取。例如，未列出目录中的全部文件，程序必须先打开该目录，然后读其中全部文件的文件名。与打开和读文件相同，在读目录前，必须先打开文件。</span></li><li id="c74b7a45eea8a24a9f1c8549c7864719"><code class="ne-code"><span class="ne-text">closedir</span></code><span class="ne-text">，读目录结束后，应该关闭目录用于释放内部表空间。</span></li></ol><ol start="5" class="ne-ol"><li id="17dd041b9516a40a3358c45b1362d7ec"><code class="ne-code"><span class="ne-text">readdir</span></code><span class="ne-text">，系统调用 readdir 返回打开目录的下一个目录项。以前也采用 read 系统调用来读取目录，但是这种方法有一个缺点：程序员必须了解和处理目录的内部结构。相反，不论采用哪一种目录结构，readdir 总是以标准格式返回一个目录项。</span></li><li id="4f848d51acdd481545cb2cb86b2d4a9b"><code class="ne-code"><span class="ne-text">rename</span></code><span class="ne-text">，在很多方面目录和文件都相似。文件可以更换名称，目录也可以。</span></li></ol><ol start="7" class="ne-ol"><li id="edbace6607fb3be4e1b637a1dd9aa171"><code class="ne-code"><span class="ne-text">link</span></code><span class="ne-text">，链接技术允许在多个目录中出现同一个文件。这个系统调用指定一个存在的文件和一个路径名，并建立从该文件到路径所指名字的链接。这样，可以在多个目录中出现同一个文件。有时也被称为</span><code class="ne-code"><span class="ne-text">硬链接(hard link)</span></code><span class="ne-text">。</span></li><li id="2cc1cbbf1be79fb5e132a02d030c0afc"><code class="ne-code"><span class="ne-text">unlink</span></code><span class="ne-text">，删除目录项。如果被解除链接的文件只出现在一个目录中，则将它从文件中删除。如果它出现在多个目录中，则只删除指定路径名的链接，依然保留其他路径名的链接。在 UNIX 中，用于删除文件的系统调用就是 unlink。</span></li></ol><p id="885d73b5a39a7c004346a847d1440b8a" class="ne-p"><br></p><h2 id="f7f29532"><span class="ne-text">文件系统的实现</span></h2><p id="ec714890f3489b939201876f99912a34" class="ne-p"><br></p><h3 id="063a94b5"><span class="ne-text">文件系统布局</span></h3><p id="4a9f73122edec1e3f247798ed5bb6ed5" class="ne-p"><br></p><p id="861f46d91942e981cc98ea26967493e0" class="ne-p"><span class="ne-text">文件系统存储在</span><code class="ne-code"><span class="ne-text">磁盘</span></code><span class="ne-text">中。大部分的磁盘能够划分出一到多个分区，叫做</span><code class="ne-code"><span class="ne-text">磁盘分区(disk partitioning)</span></code><span class="ne-text"> 或者是</span><code class="ne-code"><span class="ne-text">磁盘分片(disk slicing)</span></code><span class="ne-text">。每个分区都有独立的文件系统，每块分区的文件系统可以不同。磁盘的 0 号分区称为 </span><code class="ne-code"><span class="ne-text">主引导记录(Master Boot Record, MBR)</span></code><span class="ne-text">，用来</span><code class="ne-code"><span class="ne-text">引导(boot)</span></code><span class="ne-text"> 计算机。在 MBR 的结尾是</span><code class="ne-code"><span class="ne-text">分区表(partition table)</span></code><span class="ne-text">。每个分区表给出每个分区由开始到结束的地址。</span></p><p id="0721c038245fb84b7719e05e8f622ff2" class="ne-p"><br></p><p id="9a6cf1225520c728351597ee0e399155" class="ne-p"><span class="ne-text">当计算机开始引 boot 时，BIOS 读入并执行 MBR。</span></p><p id="75737c56aefb3c7fffd13019a2a1d831" class="ne-p"><br></p><h4 id="740649ac"><span class="ne-text">引导块</span></h4><p id="79156822d8503698dc82e2138c609266" class="ne-p"><br></p><p id="3ff3214b74c0925029bca92abe9ea54e" class="ne-p"><span class="ne-text">MBR 做的第一件事就是</span><code class="ne-code"><span class="ne-text">确定活动分区</span></code><span class="ne-text">，读入它的第一个块，称为</span><code class="ne-code"><span class="ne-text">引导块(boot block)</span></code><span class="ne-text"> 并执行。引导块中的程序将加载分区中的操作系统。为了一致性，每个分区都会从引导块开始，即使引导块不包含操作系统。引导块占据文件系统的前 4096 个字节，从磁盘上的字节偏移量 0 开始。引导块可用于启动操作系统。</span></p><p id="cc963be5f996c475d719d40c4fa10893" class="ne-p"><br></p><p id="4eff089b1ed72dbedc26da706d2b576c" class="ne-p"><span class="ne-text">除了从引导块开始之外，磁盘分区的布局是随着文件系统的不同而变化的。通常文件系统会包含一些属性，如下</span></p><p id="418b125edcf82ba1123e87efba837f9e" class="ne-p"><br></p><p id="6e21b01c67c9de127bae097535ad2d34" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830178-416c1399-355d-4e11-aaad-360c3071d651.png" width="725" id="WO5Ij" class="ne-image"></p><p id="802ba5c7e2c81d6c079467b487a35ee2" class="ne-p"><br></p><p id="70b4cab1c421609e38e9318a8e29f8ed" class="ne-p"><span class="ne-text"> 文件系统布局</span></p><p id="bc19ea1c5561802b619f7862b16edf7e" class="ne-p"><br></p><h4 id="0f7ddcc2"><span class="ne-text">超级块</span></h4><p id="a899d94ff2d728d47e586dc99a20e67d" class="ne-p"><br></p><p id="87b2599a79fc028dca72250f4bb1b6c9" class="ne-p"><span class="ne-text">紧跟在引导块后面的是 </span><code class="ne-code"><span class="ne-text">超级块(Superblock)</span></code><span class="ne-text">，超级块 的大小为 4096 字节，从磁盘上的字节偏移 4096 开始。超级块包含文件系统的所有关键参数</span></p><p id="1476e552c3b10f8582475439b1afb325" class="ne-p"><br></p><ul class="ne-ul"><li id="e4948c5816657ad07b16d2106062394d"><span class="ne-text">文件系统的大小</span></li><li id="8d63325fca6fd5dd7c277423a3ee972d"><span class="ne-text">文件系统中的数据块数</span></li></ul><ul class="ne-ul"><li id="587353c806d7ddc766494832594e262c"><span class="ne-text">指示文件系统状态的标志</span></li><li id="cc7684fc661626e2319cfe80411a56cc"><span class="ne-text">分配组大小</span></li></ul><p id="2a9a7c180f2ee41597fc75f3099404ed" class="ne-p"><br></p><p id="e5bdce31d9d48389f4afd8a853074c25" class="ne-p"><span class="ne-text">在计算机启动或者文件系统首次使用时，超级块会被读入内存。</span></p><p id="cdfd564f630ad7e23f32c907e7be4764" class="ne-p"><br></p><h4 id="d1ac35a8"><span class="ne-text">空闲空间块</span></h4><p id="6c535e1a3405fed739b7db4477fcfe06" class="ne-p"><br></p><p id="e75d427462705c57bc53dcb068c3ec3f" class="ne-p"><span class="ne-text">接着是文件系统中</span><code class="ne-code"><span class="ne-text">空闲块</span></code><span class="ne-text">的信息，例如，可以用位图或者指针列表的形式给出。</span></p><p id="310d3be16358713f214a0b655e726d8f" class="ne-p"><br></p><p id="277b5380d1da751428660b1bcedfa5ff" class="ne-p"><strong><span class="ne-text">BitMap 位图或者 Bit vector 位向量</span></strong></p><p id="d4f7482f58816535906052b8e6a7d87e" class="ne-p"><br></p><p id="55cffd4813169a9f5d4e6c6b2c0e7ec4" class="ne-p"><span class="ne-text">位图或位向量是一系列位或位的集合，其中每个位对应一个磁盘块，该位可以采用两个值：0和1，0表示已分配该块，而1表示一个空闲块。下图中的磁盘上给定的磁盘块实例（分配了绿色块）可以用16位的位图表示为：0000111000000110。</span></p><p id="0af159c768142dd2b260c453127538c0" class="ne-p"><br></p><p id="093caab837a37d141b3925293bf9714d" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830202-8aab8dd3-4293-45ca-ab73-fdf893584edc.png" width="395" id="NJVi8" class="ne-image"></p><p id="8705f7dfac212aab78bf0ab7417d616e" class="ne-p"><br></p><p id="f331be17432c09b9a9f2000d393d383a" class="ne-p"><strong><span class="ne-text">使用链表进行管理</span></strong></p><p id="ae280515e910cb48e7500b5ab206df39" class="ne-p"><br></p><p id="a1ef494d8b253a9a5c23a588a613ec9b" class="ne-p"><span class="ne-text">在这种方法中，空闲磁盘块链接在一起，即一个空闲块包含指向下一个空闲块的指针。第一个磁盘块的块号存储在磁盘上的单独位置，也缓存在内存中。</span></p><p id="7161779eddc824e1d1133e5170bb19c8" class="ne-p"><br></p><p id="1e7553f5324ffb7c2a2dc274b3f94e7b" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830218-bc0ef6e9-c0df-4495-9a7f-4bd5161d4bef.png" width="432" id="dvjrg" class="ne-image"></p><p id="63945d94feb7a4c5fb0b41b6083864f8" class="ne-p"><br></p><h4 id="4f0b14f4"><span class="ne-text">碎片</span></h4><p id="75254f59dc781b72e779b3fe96e7a629" class="ne-p"><br></p><p id="e541583744244097bd2f9fa7b3bb37c5" class="ne-p"><span class="ne-text">这里不得不提一个叫做</span><code class="ne-code"><span class="ne-text">碎片(fragment)</span></code><span class="ne-text">的概念，也称为片段。一般零散的单个数据通常称为片段。 磁盘块可以进一步分为固定大小的分配单元，片段只是在驱动器上彼此不相邻的文件片段。</span></p><p id="3f26e24c7f974df5bffef64b27e565d5" class="ne-p"><br></p><h4 id="inode"><span class="ne-text">inode</span></h4><p id="6fc1903ad5e0e3115581a601fdd7564b" class="ne-p"><br></p><p id="8363cd64eb86a68613f21c83f735a113" class="ne-p"><span class="ne-text">然后在后面是一个 </span><code class="ne-code"><span class="ne-text">inode(index node)</span></code><span class="ne-text">，也称作索引节点。它是一个数组的结构，每个文件有一个 inode，inode 非常重要，它说明了文件的方方面面。每个索引节点都存储对象数据的属性和磁盘块位置</span></p><p id="c4e25dd9c42034d98f8d6ead66069b73" class="ne-p"><br></p><p id="78b35dea2fbf0caa97c6a0e4d341729f" class="ne-p"><span class="ne-text">有一种简单的方法可以找到它们 </span><code class="ne-code"><span class="ne-text">ls -lai</span></code><span class="ne-text"> 命令。让我们看一下根文件系统：</span></p><p id="f73d13b715b79dd4b9d2a3973799f1b2" class="ne-p"><br></p><p id="23fc4b493a2a8cacfd956a7a12ea18fa" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830231-757b0e6a-7a82-4ec8-9a1c-15b9999e0185.png" width="725" id="dyXmP" class="ne-image"></p><p id="7cdc062285235cfe9cc6d010d78172ec" class="ne-p"><br></p><p id="1a3a5b8a310886a6d1c3ee8aa40ca65a" class="ne-p"><span class="ne-text">inode 节点主要包括了以下信息</span></p><p id="0f214c2c872e0efbb561a09eee7fd193" class="ne-p"><br></p><ul class="ne-ul"><li id="4e0fc36ad25bba57c6c83faee15237e8"><span class="ne-text">模式/权限（保护）</span></li><li id="823d04a8b16ecce489446613644eb5f3"><span class="ne-text">所有者 ID</span></li></ul><ul class="ne-ul"><li id="36a513e2056edf128f901912bdd5844a"><span class="ne-text">组 ID</span></li><li id="546b99bab3f0efe6dd65374f82ea512f"><span class="ne-text">文件大小</span></li></ul><ul class="ne-ul"><li id="ca587e18e953730b595535a6d2c2a52e"><span class="ne-text">文件的硬链接数</span></li><li id="d902e80175e84a5d6d169458079df074"><span class="ne-text">上次访问时间</span></li></ul><ul class="ne-ul"><li id="c4df7d4c30aeed369984820d84d672ae"><span class="ne-text">最后修改时间</span></li><li id="4cf9ad6d8fd4f59667245e548904693e"><span class="ne-text">inode 上次修改时间</span></li></ul><p id="63d51221d1e89f15fef8cf8046b41c7f" class="ne-p"><br></p><p id="edba86612d73fee8953765e5d1e71604" class="ne-p"><span class="ne-text">文件分为两部分，索引节点和块。一旦创建后，每种类型的块数是固定的。你不能增加分区上 inode 的数量，也不能增加磁盘块的数量。</span></p><p id="bab0d6d8fdb7ade0c409c63b794198cd" class="ne-p"><br></p><p id="257f76d41594956d4e6f434c94fcd48f" class="ne-p"><span class="ne-text">紧跟在 inode 后面的是根目录，它存放的是文件系统目录树的根部。最后，磁盘的其他部分存放了其他所有的目录和文件。</span></p><p id="07384bc2838ccc280811305a814ac5ae" class="ne-p"><br></p><h3 id="2fa1f996"><span class="ne-text">文件的实现</span></h3><p id="99b6ccd02eb7d36b23ac87b3d23be908" class="ne-p"><br></p><p id="520d4f89043e0d3ef94e335ae502c537" class="ne-p"><span class="ne-text">最重要的问题是记录各个文件分别用到了哪些磁盘块。不同的系统采用了不同的方法。下面我们会探讨一下这些方式。分配背后的主要思想是</span><code class="ne-code"><span class="ne-text">有效利用文件空间</span></code><span class="ne-text">和</span><code class="ne-code"><span class="ne-text">快速访问文件</span></code><span class="ne-text"> ，主要有三种分配方案</span></p><p id="d5bcaa062d84a2587d7983f841a8bb43" class="ne-p"><br></p><ul class="ne-ul"><li id="bd6f72f15903e819e6825d6a4c7d5066"><span class="ne-text">连续分配</span></li><li id="73e9c7cdab99a93a7b5d1cff4ce5bee3"><span class="ne-text">链表分配</span></li></ul><ul class="ne-ul"><li id="6c8d5f5e0b3f6cbb9bedb283610e1607"><span class="ne-text">索引分配</span></li></ul><p id="272e01376fc108d16c05972efeddd7b6" class="ne-p"><br></p><h4 id="72b53a95"><span class="ne-text">连续分配</span></h4><p id="bb7d19bc0a00fea5cb03d6b986da98b5" class="ne-p"><br></p><p id="739ceabf45e4e532ceaee28804bd6747" class="ne-p"><span class="ne-text">最简单的分配方案是把每个文件作为一连串连续数据块存储在磁盘上。因此，在具有 1KB 块的磁盘上，将为 50 KB 文件分配 50 个连续块。</span></p><p id="57e7fce6afec06f7bac3cc1f758e706a" class="ne-p"><br></p><p id="f485071b361eacaef97f0d6bc93d38d0" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830290-96589d90-fa12-43fb-a38a-8ece59db8fcd.png" width="708" id="DEFjo" class="ne-image"></p><p id="149d6540bff10fd348ccf39a548b4008" class="ne-p"><br></p><p id="ad710f4df53ff897f898e195d3474ef4" class="ne-p"><span class="ne-text"> 使用连续空间存储文件</span></p><p id="6e62bb3ca3c03233a13af4af40a1e434" class="ne-p"><br></p><p id="4409e41335edde0a0d4bead916ef1d10" class="ne-p"><span class="ne-text">上面展示了 40 个连续的内存块。从最左侧的 0 块开始。初始状态下，还没有装载文件，因此磁盘是空的。接着，从磁盘开始处（块 0 ）处开始写入占用 4 块长度的内存 A 。然后是一个占用 6 块长度的内存 B，会直接在 A 的末尾开始写。</span></p><p id="eb491f935999b43456e0680eb86056c0" class="ne-p"><br></p><p id="1dbb3a5ff9f7fb7ded0538273ec30ec5" class="ne-p"><span class="ne-text">注意每个文件都会在新的文件块开始写，所以如果文件 A 只占用了 </span><code class="ne-code"><span class="ne-text">3 又 1/2</span></code><span class="ne-text"> 个块，那么最后一个块的部分内存会被浪费。在上面这幅图中，总共展示了 7 个文件，每个文件都会从上个文件的末尾块开始写新的文件块。</span></p><p id="4d302f7f8ae1e2e3584289e94f7b7ee2" class="ne-p"><br></p><p id="ea5e53beccedfc7b48a72979c05ce798" class="ne-p"><span class="ne-text">连续的磁盘空间分配有两个优点。</span></p><p id="429ef5981f289b4d48278e8e51438334" class="ne-p"><br></p><ul class="ne-ul"><li id="07797a0fdd2cc4666f9a5e4a2b80175a"><span class="ne-text">第一，连续文件存储实现起来比较简单，只需要记住两个数字就可以：一个是第一个块的文件地址和文件的块数量。给定第一个块的编号，可以通过简单的加法找到任何其他块的编号。</span></li><li id="40dc07731b88d5bc4e9f39dbda642ece"><span class="ne-text">第二点是读取性能比较强，可以通过一次操作从文件中读取整个文件。只需要一次寻找第一个块。后面就不再需要寻道时间和旋转延迟，所以数据会以全带宽进入磁盘。</span></li></ul><p id="fb5eddf328615cd7b667cd0f76ed8064" class="ne-p"><br></p><p id="c211a55fb8333594f2910711c0080375" class="ne-p"><span class="ne-text">因此，连续的空间分配具有</span><code class="ne-code"><span class="ne-text">实现简单</span></code><span class="ne-text">、</span><code class="ne-code"><span class="ne-text">高性能</span></code><span class="ne-text">的特点。</span></p><p id="226cf8984f3e14ad2f869b70b0ae3d25" class="ne-p"><br></p><p id="584d3adf6df424e0caad8d640306ac6f" class="ne-p"><span class="ne-text">不幸的是，连续空间分配也有很明显的不足。随着时间的推移，磁盘会变得很零碎。下图解释了这种现象</span></p><p id="beb6289ffd948b913ab42f89fc806491" class="ne-p"><br></p><p id="3ca05927b2bc30ed4efbcbe0009b626d" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830262-ef7ce9d8-c4b9-488c-a2d3-48d7888ffe1f.png" width="700" id="AWBOd" class="ne-image"></p><p id="da80c0e171d6555b328959c948dd63da" class="ne-p"><br></p><p id="665c27cdd3d5d092fa41038401e02f09" class="ne-p"><span class="ne-text">这里有两个文件 D 和 F 被删除了。当删除一个文件时，此文件所占用的块也随之释放，就会在磁盘空间中留下一些空闲块。磁盘并不会在这个位置挤压掉空闲块，因为这会复制空闲块之后的所有文件，可能会有上百万的块，这个量级就太大了。</span></p><p id="516ce272d9891eb30c2670ca8fd9c815" class="ne-p"><br></p><h4 id="3d0c6331"><span class="ne-text">链表分配</span></h4><p id="b3b68de304c1d67898de10b8a645632c" class="ne-p"><br></p><p id="8ee621e84c761779bda7b9527721198f" class="ne-p"><span class="ne-text">第二种存储文件的方式是为每个文件构造磁盘块链表，每个文件都是磁盘块的链接列表，就像下面所示</span></p><p id="9d34cfd049bd058c018f3fbe6541ec1d" class="ne-p"><br></p><p id="4433a4082a45a23ee4f93af4c0102214" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830296-9199d50b-5e5b-43f4-a62b-dc0b1ef02d6d.png" width="739" id="UEy0O" class="ne-image"></p><p id="7f14e16ff0324beb9815b3ee276388d4" class="ne-p"><br></p><p id="308a2bb2be459b1d5455d81efb421ceb" class="ne-p"><span class="ne-text"> 以磁盘块的链表形式存储文件</span></p><p id="dc594ff5bca4f75526a34525758f6cf8" class="ne-p"><br></p><p id="60e8ab8b1ba0ea6828d0b8e832d4aabf" class="ne-p"><span class="ne-text">每个块的第一个字作为指向下一块的指针，块的其他部分存放数据。如果上面这张图你看的不是很清楚的话，可以看看整个的链表分配方案</span></p><p id="f2cd47fbd794262b99b108f78818a186" class="ne-p"><br></p><p id="6d43d1117b2ffa2b376514a9bdfbb5c3" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830272-99171e3f-0aae-4fa7-b127-e43f64daed7d.png" width="717" id="MV6v4" class="ne-image"></p><p id="a211e6d69c7bbfb39749b7bec6679328" class="ne-p"><br></p><p id="1763c1572bf74bab8443b0251b0cab48" class="ne-p"><span class="ne-text">与连续分配方案不同，这一方法可以充分利用每个磁盘块。除了最后一个磁盘块外，不会因为磁盘碎片而浪费存储空间。同样，在目录项中，只要存储了第一个文件块，那么其他文件块也能够被找到。</span></p><p id="f61320e6d20a47449e2034136f13b99e" class="ne-p"><br></p><p id="7c4e5c49d0f6e1ea08c9347e50f2d9cc" class="ne-p"><span class="ne-text">另一方面，在链表的分配方案中，尽管顺序读取非常方便，但是随机访问却很困难（这也是数组和链表数据结构的一大区别）。</span></p><p id="4dfa5bc9fab85a3f79ba645a4de63d55" class="ne-p"><br></p><p id="ff5cd3412028401a7eb6f6907edfe384" class="ne-p"><span class="ne-text">还有一个问题是，由于指针会占用一些字节，每个磁盘块实际存储数据的字节数并不再是 2 的整数次幂。虽然这个问题并不会很严重，但是这种方式降低了程序运行效率。许多程序都是以长度为 2 的整数次幂来读写磁盘，由于每个块的前几个字节被指针所使用，所以要读出一个完成的块大小信息，就需要当前块的信息和下一块的信息拼凑而成，因此就引发了查找和拼接的开销。</span></p><p id="5c501728e8545b3abf2ebd585e59e40a" class="ne-p"><br></p><h4 id="e7754cf3"><span class="ne-text">使用内存表进行链表分配</span></h4><p id="f55bd6034ba134163728e11d790728db" class="ne-p"><br></p><p id="fa31a2161c19438020b78c4e5edcff77" class="ne-p"><span class="ne-text">由于连续分配和链表分配都有其不可忽视的缺点。所以提出了使用内存中的表来解决分配问题。取出每个磁盘块的指针字，把它们放在内存的一个表中，就可以解决上述链表的两个不足之处。下面是一个例子</span></p><p id="c62141cbec45e806125f66c6443b2cae" class="ne-p"><br></p><p id="5294fd0f6ea2c7bd340fe04e8f683dfe" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830309-8180ae56-d298-4224-a60b-d472bd7dff53.png" width="499" id="qB40I" class="ne-image"></p><p id="8a73dddf92c308f55531792c78bc4c17" class="ne-p"><br></p><p id="3231eff73ea3778fa27bf38cee3b7593" class="ne-p"><span class="ne-text">上图表示了链表形成的磁盘块的内容。这两个图中都有两个文件，文件 A 依次使用了磁盘块地址 </span><strong><span class="ne-text">4、7、 2、 10、 12</span></strong><span class="ne-text">，文件 B 使用了</span><strong><span class="ne-text">6、3、11 和 14</span></strong><span class="ne-text">。也就是说，文件 A 从地址 4 处开始，顺着链表走就能找到文件 A 的全部磁盘块。同样，从第 6 块开始，顺着链走到最后，也能够找到文件 B 的全部磁盘块。你会发现，这两个链表都以不属于有效磁盘编号的特殊标记（-1）结束。内存中的这种表格称为 </span><code class="ne-code"><span class="ne-text">文件分配表(File Application Table,FAT)</span></code><span class="ne-text">。</span></p><p id="679e35092915fc206d463659b3246031" class="ne-p"><br></p><h3 id="507a4c82"><span class="ne-text">目录的实现</span></h3><p id="229b6f0552c8dcf4c69d5168f63a9eeb" class="ne-p"><br></p><p id="8db380cc3bd619deb9e5ee87c2dcc678" class="ne-p"><span class="ne-text">文件只有打开后才能够被读取。在文件打开后，操作系统会使用用户提供的路径名来定位磁盘中的目录。目录项提供了查找文件磁盘块所需要的信息。根据系统的不同，提供的信息也不同，可能提供的信息是整个文件的磁盘地址，或者是第一个块的数量（两个链表方案）或 inode的数量。不过不管用那种情况，目录系统的主要功能就是 </span><strong><span class="ne-text">将文件的 ASCII 码的名称映射到定位数据所需的信息上</span></strong><span class="ne-text">。</span></p><p id="c245ee3f18a5371b2e919276ff42e4d6" class="ne-p"><br></p><h3 id="7378a354"><span class="ne-text">共享文件</span></h3><p id="0d90e5167a61cad90103ab57542ccd79" class="ne-p"><br></p><p id="a010daa0deac86c6117411cf1b76ee1c" class="ne-p"><span class="ne-text">当多个用户在同一个项目中工作时，他们通常需要共享文件。如果这个共享文件同时出现在多个用户目录下，那么他们协同工作起来就很方便。下面的这张图我们在上面提到过，但是有一个更改的地方，就是 </span><strong><span class="ne-text">C 的一个文件也出现在了 B 的目录下</span></strong><span class="ne-text">。</span></p><p id="4ea8ea0f7dce1ab59600bb31b7fde121" class="ne-p"><br></p><p id="3f9712fc94bd87bc5bce05ab31700a90" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830321-b6391c5b-3b64-4089-9c4e-9a9afd09875c.png" width="743" id="wJKZ9" class="ne-image"></p><p id="1516e5428216ce2d70a3848a9e18d8b7" class="ne-p"><br></p><p id="84f511f5e2da2d65639ae5e4c5f08116" class="ne-p"><span class="ne-text">如果按照如上图的这种组织方式而言，那么 B 的目录与该共享文件的联系称为 </span><code class="ne-code"><span class="ne-text">链接(link)</span></code><span class="ne-text">。那么文件系统现在就是一个 </span><code class="ne-code"><span class="ne-text">有向无环图(Directed Acyclic Graph, 简称 DAG)</span></code><span class="ne-text">，而不是一棵树了。</span></p><p id="dedd40e6c19976b91159210337187cb3" class="ne-p"><br></p><h3 id="062d38ab"><span class="ne-text">日志结构文件系统</span></h3><p id="7d7ce6ffa46d0b80b05b4fa7cf88eb72" class="ne-p"><br></p><p id="0c348de3e61e1b6861d79e122967c6a9" class="ne-p"><span class="ne-text">技术的改变会给当前的文件系统带来压力。这种情况下，CPU 会变得越来越快，磁盘会变得越来越大并且越来越便宜（但不会越来越快）。内存容量也是以指数级增长。但是磁盘的寻道时间（除了固态盘，因为固态盘没有寻道时间）并没有获得提高。</span></p><p id="615e318cbe6ce685b317cedee5ce3166" class="ne-p"><br></p><p id="dc3ac711f3172e557139794ff56c713e" class="ne-p"><span class="ne-text">为此，</span><code class="ne-code"><span class="ne-text">Berkeley</span></code><span class="ne-text"> 设计了一种全新的文件系统，试图缓解这个问题，这个文件系统就是 </span><code class="ne-code"><span class="ne-text">日志结构文件系统(Log-structured File System, LFS)</span></code><span class="ne-text">。旨在解决以下问题。</span></p><p id="0c98bd5354523a99fdbae6022075672f" class="ne-p"><br></p><ul class="ne-ul"><li id="155a7907a5e3bdd0310a98218fdc334b"><span class="ne-text">不断增长的系统内存</span></li><li id="3b38564d520640464c2205c9486261b4"><span class="ne-text">顺序 I/O 性能胜过随机 I/O 性能</span></li></ul><ul class="ne-ul"><li id="32b086adb43b911b202b70e5aff36de8"><span class="ne-text">现有低效率的文件系统</span></li><li id="f7a37a133cbda2e36cf91ffdbee4d115"><span class="ne-text">文件系统不支持 RAID（虚拟化）</span></li></ul><p id="cf17037d9f08713ca3eeb4ace7b47ca8" class="ne-p"><br></p><p id="297fb6753d11f490d126e727b7c09c48" class="ne-p"><span class="ne-text">另一方面，当时的文件系统不论是 UNIX 还是 FFS，都有大量的随机读写（在 FFS 中创建一个新文件至少需要5次随机写），因此成为整个系统的性能瓶颈。同时因为 </span><code class="ne-code"><span class="ne-text">Page cache</span></code><span class="ne-text"> 的存在，作者认为随机读不是主要问题：随着越来越大的内存，大部分的读操作都能被 cache，因此 LFS 主要要解决的是减少对硬盘的随机写操作。</span></p><p id="1bad16ccaa3347ac4cfab1786828e972" class="ne-p"><br></p><p id="d005e77189b514affc9db35092a8db48" class="ne-p"><span class="ne-text">在这种设计中，inode 甚至具有与 UNIX 中相同的结构，但是现在它们分散在整个日志中，而不是位于磁盘上的固定位置。所以，inode 很定位。为了能够找到 inode ，维护了一个由 inode 索引的 </span><code class="ne-code"><span class="ne-text">inode map(inode 映射)</span></code><span class="ne-text">。表项 i 指向磁盘中的第 i 个 inode 。这个映射保存在磁盘中，但是也保存在缓存中，因此，使用最频繁的部分大部分时间都在内存中。</span></p><p id="a624918a0a3ce7dd4dc1ac14978eae8c" class="ne-p"><br></p><p id="268c06eaa913f22f2d46aba8d7868764" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830360-ead8d1cc-da6e-40bc-896b-4350498bf5c8.png" width="732" id="qxML0" class="ne-image"></p><p id="135f1d10729c89da15b349f4f1a6f674" class="ne-p"><br></p><p id="d3439b4c32b9a597fdf5c3f4980e183c" class="ne-p"><span class="ne-text">到目前为止，所有写入最初都缓存在</span><code class="ne-code"><span class="ne-text">内存</span></code><span class="ne-text">中，并且追加在</span><code class="ne-code"><span class="ne-text">日志末尾</span></code><span class="ne-text">，所有缓存的写入都定期在单个段中写入磁盘。所以，现在打开文件也就意味着用映射定位文件的索引节点。一旦 inode 被定位后，磁盘块的地址就能够被找到。所有这些块本身都将位于日志中某处的分段中。</span></p><p id="4deeb5cc8765dcdcffc2051d29dd889c" class="ne-p"><br></p><p id="1da2cd86f605c95cfd9b33b6424b03a8" class="ne-p"><span class="ne-text">真实情况下的磁盘容量是有限的，所以最终日志会占满整个磁盘空间，这种情况下就会出现没有新的磁盘块被写入到日志中。幸运的是，许多现有段可能具有不再需要的块。例如，如果一个文件被覆盖了，那么它的 inode 将被指向新的块，但是旧的磁盘块仍在先前写入的段中占据着空间。</span></p><p id="f7cc586edf59e28b51595cb2d99969e4" class="ne-p"><br></p><p id="b252ea9c8d9887d0749eca891ee9370a" class="ne-p"><span class="ne-text">为了处理这个问题，LFS 有一个</span><code class="ne-code"><span class="ne-text">清理(clean)</span></code><span class="ne-text">线程，它会循环扫描日志并对日志进行压缩。首先，通过查看日志中第一部分的信息来查看其中存在哪些索引节点和文件。它会检查当前 inode 的映射来查看 inode 否在在当前块中，是否仍在被使用。如果不是，该信息将被丢弃。如果仍然在使用，那么 inode 和块就会进入内存等待写回到下一个段中。然后原来的段被标记为空闲，以便日志可以用来存放新的数据。用这种方法，清理线程遍历日志，从后面移走旧的段，然后将有效的数据放入内存等待写到下一个段中。由此一来整个磁盘会形成一个大的</span><code class="ne-code"><span class="ne-text">环形缓冲区</span></code><span class="ne-text">，写线程将新的段写在前面，而清理线程则清理后面的段。</span></p><p id="d882117f7dd0d9016cd4efa5d88f836b" class="ne-p"><br></p><p id="4cb4c6428aac735024f7bd8e7b3df742" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830348-81e32c04-1184-4cdb-8403-2efeeb68787c.png" width="631" id="A4Ev0" class="ne-image"></p><p id="254c2fb97c081e7566ee59c417621dc6" class="ne-p"><br></p><h3 id="97a9825e"><span class="ne-text">日志文件系统</span></h3><p id="54c993a6b70774346a7e6a74670bd65d" class="ne-p"><br></p><p id="15ef008aa02d98f6108fd2b0045ad8ce" class="ne-p"><span class="ne-text">虽然日志结构系统的设计很优雅，但是由于它们和现有的文件系统不相匹配，因此还没有广泛使用。不过，从日志文件结构系统衍生出来一种新的日志系统，叫做</span><code class="ne-code"><span class="ne-text">日志文件系统</span></code><span class="ne-text">，它会记录系统下一步将要做什么的日志。微软的 </span><code class="ne-code"><span class="ne-text">NTFS</span></code><span class="ne-text"> 文件系统、Linux 的 </span><code class="ne-code"><span class="ne-text">ext3</span></code><span class="ne-text"> 就使用了此日志。 </span><code class="ne-code"><span class="ne-text">OS X</span></code><span class="ne-text"> 将日志系统作为可供选项。为了看清它是如何工作的，我们下面讨论一个例子，比如 </span><code class="ne-code"><span class="ne-text">移除文件</span></code><span class="ne-text"> ，这个操作在 UNIX 中需要三个步骤完成：</span></p><p id="542c202aaf8ebf265f4cb616c83eb215" class="ne-p"><br></p><ul class="ne-ul"><li id="67d6fbc0f368e73ec0ae0cd1ae302ca0"><span class="ne-text">在目录中删除文件</span></li><li id="a89a87cfde0f907da93ba98949232c61"><span class="ne-text">释放 inode 到空闲 inode 池</span></li></ul><ul class="ne-ul"><li id="9d7a41e6c40debc886ece1919154c122"><span class="ne-text">将所有磁盘块归还给空闲磁盘池。</span></li></ul><p id="0373ab5b606fbc4ea64ceb3e16560a81" class="ne-p"><br></p><h3 id="85c5a550"><span class="ne-text">虚拟文件系统</span></h3><p id="290a38b2c6595805459b83e5d9efd348" class="ne-p"><br></p><p id="fa0fd762b6f480ec670bc0caaa659d75" class="ne-p"><span class="ne-text">UNIX 操作系统使用一种 </span><code class="ne-code"><span class="ne-text">虚拟文件系统(Virtual File System, VFS)</span></code><span class="ne-text"> 来尝试将多种文件系统构成一个有序的结构。关键的思想是抽象出所有文件系统都共有的部分，并将这部分代码放在一层，这一层再调用具体文件系统来管理数据。下面是一个 VFS 的系统结构</span></p><p id="adaba32ebb0cc75090b68328c3028b7b" class="ne-p"><br></p><p id="a3c0af3bdad2c2390baf7ba0b99cc521" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830356-635b72b4-bcf2-434f-9719-c83b191da6cf.png" width="675" id="zWieH" class="ne-image"></p><p id="d59ed70f4605a2d10f29fbf5243a3add" class="ne-p"><br></p><p id="db2b2f4f03009dfb83d4c4702f1c8bce" class="ne-p"><span class="ne-text">还是那句经典的话，在计算机世界中，任何解决不了的问题都可以加个</span><code class="ne-code"><span class="ne-text">代理</span></code><span class="ne-text">来解决。所有和文件相关的系统调用在最初的处理上都指向虚拟文件系统。这些来自用户进程的调用，都是标准的 </span><code class="ne-code"><span class="ne-text">POSIX 系统调用</span></code><span class="ne-text">，比如 open、read、write 和 seek 等。VFS 对用户进程有一个 </span><code class="ne-code"><span class="ne-text">上层</span></code><span class="ne-text"> 接口，这个接口就是著名的 POSIX 接口。</span></p><p id="b00daf97b264c2c2bbe03d1961ade40f" class="ne-p"><br></p><h2 id="9bc5cc8b"><span class="ne-text">文件系统的管理和优化</span></h2><p id="e52554121a51cb24a7d18cea51ff1273" class="ne-p"><br></p><p id="a457d363aece63ffafdc7a21b8ea5bda" class="ne-p"><span class="ne-text">能够使文件系统工作是一回事，能够使文件系统高效、稳定的工作是另一回事，下面我们就来探讨一下文件系统的管理和优化。</span></p><p id="7427320717087557ca6baac5f2f4e9e6" class="ne-p"><br></p><h3 id="36f7581f"><span class="ne-text">磁盘空间管理</span></h3><p id="2ddbfc7d676fa2fb7e22874efb2691cf" class="ne-p"><br></p><p id="72ecbbb431e26da743b3582748db5218" class="ne-p"><span class="ne-text">文件通常存在磁盘中，所以如何管理磁盘空间是一个操作系统的设计者需要考虑的问题。在文件上进行存有两种策略：</span><strong><span class="ne-text">分配 n 个字节的连续磁盘空间；或者把文件拆分成多个并不一定连续的块</span></strong><span class="ne-text">。在存储管理系统中，主要有</span><code class="ne-code"><span class="ne-text">分段管理</span></code><span class="ne-text">和 </span><code class="ne-code"><span class="ne-text">分页管理</span></code><span class="ne-text"> 两种方式。</span></p><p id="dd7036c30b5429f0012e299634b76e92" class="ne-p"><br></p><p id="67ddc9963643581de7e3a7a9dc7fc649" class="ne-p"><span class="ne-text">正如我们所看到的，按</span><code class="ne-code"><span class="ne-text">连续字节序列</span></code><span class="ne-text">存储文件有一个明显的问题，当文件扩大时，有可能需要在磁盘上移动文件。内存中分段也有同样的问题。不同的是，相对于把文件从磁盘的一个位置移动到另一个位置，内存中段的移动操作要快很多。因此，几乎所有的文件系统都把文件分割成固定大小的块来存储。</span></p><p id="344a106798ca8fae42c7928b5ec1fc77" class="ne-p"><br></p><h4 id="e30f1fa9"><span class="ne-text">块大小</span></h4><p id="38509e646d595c8ff6d9a8436e3eedaf" class="ne-p"><br></p><p id="547a3489e12fa9b51d40fb6441101da0" class="ne-p"><span class="ne-text">一旦把文件分为固定大小的块来存储，就会出现问题，块的大小是多少？按照</span><strong><span class="ne-text">磁盘组织方式，扇区、磁道和柱面显然都可以作为分配单位</span></strong><span class="ne-text">。在分页系统中，分页大小也是主要因素。</span></p><p id="eef07e9a93ba53842388a4f3930178df" class="ne-p"><br></p><p id="db7ed5c40d46b10feac962743c5d08dc" class="ne-p"><span class="ne-text">拥有大的块尺寸意味着每个文件，甚至 1 字节文件，都要占用一个柱面空间，也就是说小文件浪费了大量的磁盘空间。另一方面，小块意味着大部分文件将会跨越多个块，因此需要多次搜索和旋转延迟才能读取它们，从而降低了性能。因此，如果分配的块</span><code class="ne-code"><span class="ne-text">太大</span></code><span class="ne-text">会浪费</span><code class="ne-code"><span class="ne-text">空间</span></code><span class="ne-text">；分配的块</span><code class="ne-code"><span class="ne-text">太小</span></code><span class="ne-text">会浪费</span><code class="ne-code"><span class="ne-text">时间</span></code><span class="ne-text">。</span></p><p id="c2835cdef3fed7ded33775fbb7ca6297" class="ne-p"><br></p><h4 id="295e0480"><span class="ne-text">记录空闲块</span></h4><p id="edd1908809f46d895dc025e523270a52" class="ne-p"><br></p><p id="dd215e9d3aec5bd07fefcbb6ef543dc8" class="ne-p"><span class="ne-text">一旦指定了块大小，下一个问题就是怎样跟踪空闲块。有两种方法被广泛采用，如下图所示</span></p><p id="47accf180646908f7be85a16c3d72875" class="ne-p"><br></p><p id="96bc7041bf4c1a86d46bb5c63cefd992" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830365-86ca166a-5dd1-4e96-b9b4-2966e2d87565.png" width="753" id="CTgLy" class="ne-image"></p><p id="2051479c114a6b22e965758e8797badf" class="ne-p"><br></p><p id="ca2834028031ca00495c9ea1276d53aa" class="ne-p"><span class="ne-text">第一种方法是采用</span><code class="ne-code"><span class="ne-text">磁盘块链表</span></code><span class="ne-text">，链表的每个块中包含极可能多的空闲磁盘块号。对于 1 KB 的块和 32 位的磁盘块号，空闲表中每个块包含有 255 个空闲的块号。考虑 1 TB 的硬盘，拥有大概十亿个磁盘块。为了存储全部地址块号，如果每块可以保存 255 个块号，则需要将近 400 万个块。通常，空闲块用于保存空闲列表，因此存储基本上是空闲的。</span></p><p id="5f10f38fe901cd0eb895dbc49f3e37f0" class="ne-p"><br></p><p id="56b4758c79b155d6ba6436edeba4ba04" class="ne-p"><span class="ne-text">另一种空闲空间管理的技术是</span><code class="ne-code"><span class="ne-text">位图(bitmap)</span></code><span class="ne-text">，n 个块的磁盘需要 n 位位图。在位图中，空闲块用 1 表示，已分配的块用 0 表示。对于 1 TB 硬盘的例子，需要 10 亿位表示，即需要大约 130 000 个 1 KB 块存储。很明显，和 32 位链表模型相比，位图需要的空间更少，因为每个块使用 1 位。只有当磁盘快满的时候，链表需要的块才会比位图少。</span></p><p id="7e0bf942bbab56b06289c8725066eb20" class="ne-p"><br></p><h3 id="4facddb8"><span class="ne-text">磁盘配额</span></h3><p id="032a35f5bc36753dde6f1497ca87082d" class="ne-p"><br></p><p id="215d7a97d62c80293c9847906f762497" class="ne-p"><span class="ne-text">为了防止一些用户占用太多的磁盘空间，多用户操作通常提供一种</span><code class="ne-code"><span class="ne-text">磁盘配额(enforcing disk quotas)</span></code><span class="ne-text">的机制。系统管理员为每个用户分配</span><strong><span class="ne-text">最大的文件和块分配</span></strong><span class="ne-text">，并且操作系统确保用户不会超过其配额。我们下面会谈到这一机制。</span></p><p id="2ee4b6ff9b5bf884af9208e43d278aa6" class="ne-p"><br></p><p id="c20140937b0c58800dec7ed9cd67e95b" class="ne-p"><span class="ne-text">在用户打开一个文件时，操作系统会找到</span><code class="ne-code"><span class="ne-text">文件属性</span></code><span class="ne-text">和</span><code class="ne-code"><span class="ne-text">磁盘地址</span></code><span class="ne-text">，并把它们送入内存中的打开文件表。其中一个属性告诉</span><code class="ne-code"><span class="ne-text">文件所有者</span></code><span class="ne-text">是谁。任何有关文件的增加都会记到所有者的配额中。</span></p><p id="b1cacad06963157173172584f9db8096" class="ne-p"><br></p><p id="3c665c8af9fb07bcf153caa4b682fe95" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830397-dc14e657-f7ce-4c0e-a2fc-dae37cdce37e.png" width="681" id="Oo3ow" class="ne-image"></p><p id="c7a9e9f8b0a5997c4e2a3e6dbc31775a" class="ne-p"><br></p><p id="43b46d497e9c436b2f556aa5c66e2c43" class="ne-p"><span class="ne-text"> 配额表中记录了每个用户的配额</span></p><p id="0f9f915845b742eeb1c89f50a592a657" class="ne-p"><br></p><p id="c5a0b6749f84d9c09a768bf537638a09" class="ne-p"><span class="ne-text">第二张表包含了每个用户当前打开文件的配额记录，即使是其他人打开该文件也一样。如上图所示，该表的内容是从被打开文件的所有者的磁盘配额文件中提取出来的。当所有文件关闭时，该记录被写回配额文件。</span></p><p id="1ee6d826e9a005489809f6cdbc1f74fd" class="ne-p"><br></p><p id="9e3b6aa356a538a1f623df8fbfee0caf" class="ne-p"><span class="ne-text">当在打开文件表中建立一新表项时，会产生一个指向所有者配额记录的指针。每次向文件中添加一个块时，文件所有者所用数据块的总数也随之增加，并会同时增加</span><code class="ne-code"><span class="ne-text">硬限制</span></code><span class="ne-text">和</span><code class="ne-code"><span class="ne-text">软限制</span></code><span class="ne-text">的检查。可以超出软限制，但硬限制不可以超出。当已达到硬限制时，再往文件中添加内容将引发错误。同样，对文件数目也存在类似的检查。</span></p><p id="9dfa42d3b8bda31015aff60e6402447b" class="ne-p"><br></p><h3 id="448f0b53"><span class="ne-text">文件系统备份</span></h3><p id="ffdfb3c549d5e57f21be4e05a1a2db62" class="ne-p"><br></p><p id="113ba2fa14d2438cead2475b7b39a27e" class="ne-p"><span class="ne-text">做文件备份很耗费时间而且也很浪费空间，这会引起下面几个问题。首先，是要</span><strong><span class="ne-text">备份整个文件还是仅备份一部分呢</span></strong><span class="ne-text">？一般来说，只是备份特定目录及其下的全部文件，而不是备份整个文件系统。</span></p><p id="46fadd39621ab910d498dbceb75c70a5" class="ne-p"><br></p><p id="aa6bac235f93e3c65c678e094392adca" class="ne-p"><span class="ne-text">其次，对上次未修改过的文件再进行备份是一种浪费，因而产生了一种</span><code class="ne-code"><span class="ne-text">增量转储(incremental dumps)</span></code><span class="ne-text"> 的思想。最简单的增量转储的形式就是</span><code class="ne-code"><span class="ne-text">周期性</span></code><span class="ne-text">的做全面的备份，而每天只对增量转储完成后发生变化的文件做单个备份。</span></p><p id="bd26f462660acfa584c45424f992c0d3" class="ne-p"><br></p><p id="d7a48a9530c54662113424a7892a7643" class="ne-p"><span class="ne-text">稍微好一点的方式是只备份最近一次转储以来更改过的文件。当然，这种做法极大的缩减了转储时间，但恢复起来却更复杂，因为</span><strong><span class="ne-text">最近的全面转储先要全部恢复，随后按逆序进行增量转储</span></strong><span class="ne-text">。为了方便恢复，人们往往使用更复杂的转储模式。</span></p><p id="51edae20809214a4ee16554d2b0d6c6e" class="ne-p"><br></p><p id="fc00c1f85af8e54127292c60f1ce58f2" class="ne-p"><span class="ne-text">第三，既然待转储的往往是海量数据，那么在将其写入磁带之前对文件进行压缩就很有必要。但是，如果在备份过程中出现了文件损坏的情况，就会导致破坏压缩算法，从而使整个磁带无法读取。所以在备份前是否进行文件压缩需慎重考虑。</span></p><p id="48064cf8ac09f37c3e9fb90da4bd86f6" class="ne-p"><br></p><p id="eae33460e594d4ace436ad41cdee09bb" class="ne-p"><span class="ne-text">第四，对正在使用的文件系统做备份是很难的。如果在转储过程中要添加，删除和修改文件和目录，则转储结果可能不一致。因此，因为转储过程中需要花费数个小时的时间，所以有必要在晚上将系统脱机进行备份，然而这种方式的接受程度并不高。所以，人们修改了转储算法，记下文件系统的</span><code class="ne-code"><span class="ne-text">瞬时快照</span></code><span class="ne-text">，即复制关键的数据结构，然后需要把将来对文件和目录所做的修改复制到块中，而不是到处更新他们。</span></p><p id="30c5145da5c3daf19f6a6c121ac3cd34" class="ne-p"><br></p><p id="b0fcc685273d71a66e54ea23168256e7" class="ne-p"><span class="ne-text">磁盘转储到备份磁盘上有两种方案：</span><strong><span class="ne-text">物理转储和逻辑转储</span></strong><span class="ne-text">。</span><code class="ne-code"><span class="ne-text">物理转储(physical dump)</span></code><span class="ne-text"> 是从磁盘的 0 块开始，依次将所有磁盘块按照顺序写入到输出磁盘，并在复制最后一个磁盘时停止。这种程序的万无一失性是其他程序所不具备的。</span></p><p id="16f52d5c94af08b8399b7f00fde02baf" class="ne-p"><br></p><p id="a4280007245d6cde87091ae5723b514f" class="ne-p"><span class="ne-text">第二个需要考虑的是</span><strong><span class="ne-text">坏块的转储</span></strong><span class="ne-text">。制造大型磁盘而没有瑕疵是不可能的，所以也会存在一些</span><code class="ne-code"><span class="ne-text">坏块(bad blocks)</span></code><span class="ne-text">。有时进行低级格式化后，坏块会被检测出来并进行标记，这种情况的解决办法是用磁盘末尾的一些空闲块所替换。</span></p><p id="d3a520d2dc75e3c048f1f7be7a3b1521" class="ne-p"><br></p><p id="9e3a9f3c7ea68c671fba5541ec778315" class="ne-p"><span class="ne-text">然而，一些块在格式化后会变坏，在这种情况下操作系统可以检测到它们。通常情况下，它可以通过创建一个由所有坏块组成的</span><code class="ne-code"><span class="ne-text">文件</span></code><span class="ne-text">来解决问题，确保它们不会出现在空闲池中并且永远不会被分配。</span><strong><span class="ne-text">那么此文件是完全不可读的</span></strong><span class="ne-text">。如果磁盘控制器将所有的坏块重新映射，物理转储还是能够正常工作的。</span></p><p id="079669c0c544c835fd273273a33afdd7" class="ne-p"><br></p><p id="f5aa458d6a0327dcf235ab0f937d1e5b" class="ne-p"><span class="ne-text">Windows 系统有</span><code class="ne-code"><span class="ne-text">分页文件(paging files)</span></code><span class="ne-text"> 和 </span><code class="ne-code"><span class="ne-text">休眠文件(hibernation files)</span></code><span class="ne-text"> 。它们在文件还原时不发挥作用，同时也不应该在第一时间进行备份。</span></p><p id="7cec7ef194f71a4845069c7b2467ba86" class="ne-p"><br></p><h3 id="7bf7e71c"><span class="ne-text">文件系统的一致性</span></h3><p id="82c29f8de3c1d8f9d3e3a242854aea5a" class="ne-p"><br></p><p id="95f468ed0b314583e7bb1b5d96463a0d" class="ne-p"><span class="ne-text">影响可靠性的一个因素是文件系统的一致性。许多文件系统读取磁盘块、修改磁盘块、再把它们写回磁盘。如果系统在所有块写入之前崩溃，文件系统就会处于一种</span><code class="ne-code"><span class="ne-text">不一致(inconsistent)</span></code><span class="ne-text">的状态。如果某些尚未写回的块是索引节点块，目录块或包含空闲列表的块，则此问题是很严重的。</span></p><p id="aa1b70a4eed4630530233add037539f3" class="ne-p"><br></p><p id="964d4c4e15c95803c23efa7ae10be9e2" class="ne-p"><span class="ne-text">为了处理文件系统一致性问题，大部分计算机都会有应用程序来检查文件系统的一致性。例如，UNIX 有 </span><code class="ne-code"><span class="ne-text">fsck</span></code><span class="ne-text">；Windows 有 </span><code class="ne-code"><span class="ne-text">sfc</span></code><span class="ne-text">，每当引导系统时（尤其是在崩溃后），都可以运行该程序。</span></p><p id="48ab85b18d500f6f09aae6694c153193" class="ne-p"><br></p><p id="f69a8abc58586e91d81d5e78464cf3d0" class="ne-p"><span class="ne-text">可以进行两种一致性检查：</span><strong><span class="ne-text">块的一致性检查和文件的一致性检查</span></strong><span class="ne-text">。为了检查块的一致性，应用程序会建立两张表，每个包含一个计数器的块，最初设置为 0 。第一个表中的计数器跟踪该块在文件中出现的次数，第二张表中的计数器记录每个块在空闲列表、空闲位图中出现的频率。</span></p><p id="6aef6c93e388526281d0ccfabc109e56" class="ne-p"><br></p><h3 id="1813df07"><span class="ne-text">文件系统性能</span></h3><p id="d3fb5bbd9e1d7c87c8abc3f98dad08fa" class="ne-p"><br></p><p id="1b317a6725a77f944c82f795f51802c4" class="ne-p"><span class="ne-text">访问磁盘的效率要比内存满的多，是时候又祭出这张图了</span></p><p id="e65e5e0ed7603e2c50058d08807f17fe" class="ne-p"><br></p><p id="1a1e743c356c1915686f30c85dd8837e" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830422-af95403a-f195-4d9e-8125-0d05ec7651ff.png" width="711" id="oMNVY" class="ne-image"></p><p id="b50a79ed6fb74211ac37fdda653d5b8f" class="ne-p"><br></p><p id="859c470037440cdd28efa0d26f3ef0a6" class="ne-p"><span class="ne-text">从内存读一个 32 位字大概是 10ns，从硬盘上读的速率大概是 100MB/S，对每个 32 位字来说，效率会慢了四倍，另外，还要加上 5 - 10 ms 的寻道时间等其他损耗，如果只访问一个字，内存要比磁盘快百万数量级。所以磁盘优化是很有必要的，下面我们会讨论几种优化方式</span></p><p id="f08d65d53f1351340cdb0ecf65f4e735" class="ne-p"><br></p><h4 id="cdde49bb"><span class="ne-text">高速缓存</span></h4><p id="a88faf1cb721a77ececf2015cf53efa9" class="ne-p"><br></p><p id="7c675dc314d14c2ae799ed6640c9d2e9" class="ne-p"><span class="ne-text">最常用的减少磁盘访问次数的技术是使用 </span><code class="ne-code"><span class="ne-text">块高速缓存(block cache)</span></code><span class="ne-text"> 或者 </span><code class="ne-code"><span class="ne-text">缓冲区高速缓存(buffer cache)</span></code><span class="ne-text">。高速缓存指的是一系列的块，它们在逻辑上属于磁盘，但实际上基于性能的考虑被保存在内存中。</span></p><p id="b17a6714b13a17563901344d07462477" class="ne-p"><br></p><p id="dc154ad0b420fd4f3673118cc516d2e6" class="ne-p"><span class="ne-text">管理高速缓存有不同的算法，常用的算法是：检查全部的读请求，查看在高速缓存中是否有所需要的块。如果存在，可执行读操作而无须访问磁盘。如果检查块不再高速缓存中，那么首先把它读入高速缓存，再复制到所需的地方。之后，对同一个块的请求都通过</span><code class="ne-code"><span class="ne-text">高速缓存</span></code><span class="ne-text">来完成。</span></p><p id="c25b8162bb8c3e4f67a87ba9bac5a070" class="ne-p"><br></p><p id="6c386979476c9d66e19b2d612c66328f" class="ne-p"><span class="ne-text">高速缓存的操作如下图所示</span></p><p id="3d3a4d92696219f66d8742c69e570752" class="ne-p"><br></p><p id="24044650b0ba67c609c1fd504c6288be" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830486-9b7cd7d5-cd58-485e-8fb9-7c5f918fb69a.png" width="733" id="w4gdw" class="ne-image"></p><p id="e9c3294259bbd6241a38558088b3ebd6" class="ne-p"><br></p><p id="6eca2ec60272b982b11ff45c7220cf1c" class="ne-p"><span class="ne-text">由于在高速缓存中有许多块，所以需要某种方法快速确定所需的块是否存在。常用方法是将设备和磁盘地址进行散列操作，然后，在散列表中查找结果。具有相同散列值的块在一个链表中连接在一起（这个数据结构是不是很像 HashMap?），这样就可以沿着冲突链查找其他块。</span></p><p id="d484a308c97ec7ef8cadad561dd451b0" class="ne-p"><br></p><p id="de071a26c813ef0d71da3b2b2adce651" class="ne-p"><span class="ne-text">如果高速缓存</span><code class="ne-code"><span class="ne-text">已满</span></code><span class="ne-text">，此时需要调入新的块，则要把原来的某一块调出高速缓存，如果要调出的块在上次调入后已经被修改过，则需要把它写回磁盘。</span></p><p id="d2cb85bba04c34338b74daba699247a5" class="ne-p"><br></p><h4 id="66d87443"><span class="ne-text">块提前读</span></h4><p id="30c57914a283b1c14a9a70972a449fdc" class="ne-p"><br></p><p id="deeccda0a50582f53cf9c6007fc28d76" class="ne-p"><span class="ne-text">第二个明显提高文件系统的性能是，在需要用到块之前，试图</span><code class="ne-code"><span class="ne-text">提前</span></code><span class="ne-text">将其写入高速缓存，从而</span><code class="ne-code"><span class="ne-text">提高命中率</span></code><span class="ne-text">。许多文件都是顺序读取。如果请求文件系统在某个文件中生成块 k，文件系统执行相关操作并且在完成之后，会检查高速缓存，以便确定块 k + 1 是否已经在高速缓存。如果不在，文件系统会为 k + 1 安排一个预读取，因为文件希望在用到该块的时候能够直接从高速缓存中读取。</span></p><p id="8a69c495fe7bb783b79dbf75485864bc" class="ne-p"><br></p><p id="808c596082fdff6eaae697cd580903a8" class="ne-p"><span class="ne-text">当然，块提前读取策略只适用于实际顺序读取的文件。对随机访问的文件，提前读丝毫不起作用。甚至还会造成阻碍。</span></p><p id="5b78528d1ba45c2104816c3e8e709aff" class="ne-p"><br></p><h4 id="aa9dd989"><span class="ne-text">减少磁盘臂运动</span></h4><p id="d09f4491931761a8ce0444d664eebb7a" class="ne-p"><br></p><p id="fb7b8c5c382a9dee9c90ffe1a4934f58" class="ne-p"><span class="ne-text">高速缓存和块提前读并不是提高文件系统性能的唯一方法。另一种重要的技术是</span><strong><span class="ne-text">把有可能顺序访问的块放在一起，当然最好是在同一个柱面上，从而减少磁盘臂的移动次数</span></strong><span class="ne-text">。当写一个输出文件时，文件系统就必须按照要求一次一次地分配磁盘块。如果用位图来记录空闲块，并且整个位图在内存中，那么选择与前一块最近的空闲块是很容易的。如果用空闲表，并且链表的一部分存在磁盘上，要分配紧邻的空闲块就会困难很多。</span></p><p id="fb9ea860feeaa3264df8728b7749755f" class="ne-p"><br></p><h4 id="67e3ff13"><span class="ne-text">磁盘碎片整理</span></h4><p id="ba79cd85e1dad3bed9f2216b2b7253b1" class="ne-p"><br></p><p id="41c56da85159758040baae19181247c8" class="ne-p"><span class="ne-text">在初始安装操作系统后，文件就会被不断的创建和清除，于是磁盘会产生很多的碎片，在创建一个文件时，它使用的块会散布在整个磁盘上，降低性能。删除文件后，回收磁盘块，可能会造成空穴。</span></p><p id="b1d265b54391b9395004a22d89f3381d" class="ne-p"><br></p><p id="408e532833df6ecd00374e3714b691a6" class="ne-p"><span class="ne-text">磁盘性能可以通过如下方式恢复：移动文件使它们相互挨着，并把所有的至少是大部分的空闲空间放在一个或多个大的连续区域内。Windows 有一个程序 </span><code class="ne-code"><span class="ne-text">defrag</span></code><span class="ne-text"> 就是做这个事儿的。Windows 用户会经常使用它，SSD 除外。</span></p><p id="2b171a55d46f2e7b316bfa4dca7e1d30" class="ne-p"><br></p><p id="0a13d2e5ecaea758dd489d8b3f708327" class="ne-p"><span class="ne-text">磁盘碎片整理程序会在让文件系统上很好地运行。Linux 文件系统（特别是 ext2 和 ext3）由于其选择磁盘块的方式，在磁盘碎片整理上一般不会像 Windows 一样困难，因此很少需要手动的磁盘碎片整理。而且，固态硬盘并不受磁盘碎片的影响，事实上，在固态硬盘上做磁盘碎片整理反倒是多此一举，不仅没有提高性能，反而磨损了固态硬盘。所以碎片整理只会缩短固态硬盘的寿命。</span></p><p id="e7ebcf76e9e7e212ad0bcdf32a78971d" class="ne-p"><br></p><p id="89ca27714a847f6e1742fe7c23d34046" class="ne-p"><span class="ne-text">下面我们来探讨一下 I/O 流程问题。</span></p><p id="1cef0573f6ef4eb8042d81ad743c2c6e" class="ne-p"><br></p><p id="55fa1a1e6692073f30600efec9761a8f" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830481-2693434c-6334-4f5a-a152-75454e91d275.png" width="752" id="Nh8lv" class="ne-image"></p><p id="dab506072acfbe1a65ea20b5d8f20187" class="ne-p"><br></p><h2 id="ccf866bd"><span class="ne-text">I/O 设备</span></h2><p id="fef21a68cfbbf3d40c8c42db7160f3fc" class="ne-p"><br></p><p id="a11a667a8e08d786f9df34bbf650bf3d" class="ne-p"><span class="ne-text">什么是 I/O 设备？I/O 设备又叫做输入/输出设备，它是人类用来和计算机进行通信的外部硬件。输入/输出设备能够向计算机</span><code class="ne-code"><span class="ne-text">发送数据（输出）</span></code><span class="ne-text">并从计算机</span><code class="ne-code"><span class="ne-text">接收数据（输入）</span></code><span class="ne-text">。</span></p><p id="c552565b432c8f2328937d605d16b55f" class="ne-p"><br></p><p id="36a413dde5afb50347686b041abb2194" class="ne-p"><code class="ne-code"><span class="ne-text">I/O 设备(I/O devices)</span></code><span class="ne-text">可以分成两种：</span><code class="ne-code"><span class="ne-text">块设备(block devices)</span></code><span class="ne-text"> 和 </span><code class="ne-code"><span class="ne-text">字符设备(character devices)</span></code><span class="ne-text">。</span></p><p id="041f671ef3cc121c9abd0eb87bea40ce" class="ne-p"><br></p><h4 id="b0737d59"><span class="ne-text">块设备</span></h4><p id="85b0d1db3e51529ae28eb21531dbabc9" class="ne-p"><br></p><p id="6791ea347b3b675b23d8b71834de784d" class="ne-p"><span class="ne-text">块设备是一个能存储</span><code class="ne-code"><span class="ne-text">固定大小块</span></code><span class="ne-text">信息的设备，它支持</span><strong><span class="ne-text">以固定大小的块，扇区或群集读取和（可选）写入数据</span></strong><span class="ne-text">。每个块都有自己的</span><code class="ne-code"><span class="ne-text">物理地址</span></code><span class="ne-text">。通常块的大小在 512 - 65536 之间。所有传输的信息都会以</span><code class="ne-code"><span class="ne-text">连续</span></code><span class="ne-text">的块为单位。块设备的基本特征是每个块都较为对立，能够独立的进行读写。常见的块设备有 </span><strong><span class="ne-text">硬盘、蓝光光盘、USB 盘</span></strong></p><p id="b52171cdae8af1f376f27c40ad67ac26" class="ne-p"><br></p><p id="cf77f280837dfa3d5315eadc8011a27d" class="ne-p"><span class="ne-text">与字符设备相比，块设备通常需要较少的引脚。</span></p><p id="7ecf223db6465ee23234ff197ee6a09c" class="ne-p"><br></p><p id="7acf3702619a1520d671342f2aa55ce2" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830476-de4c28f8-7881-487b-9bc3-11bf81770f23.png" width="700" id="pm6J2" class="ne-image"></p><p id="0e9ec415e4a41b3d94d858c66fadaad5" class="ne-p"><br></p><h4 id="4946a116"><span class="ne-text">块设备的缺点</span></h4><p id="f6b824a5b70558096a86b0e599ace532" class="ne-p"><br></p><p id="7e18a2c7272bc8e4a6f3a6ab2944d1e1" class="ne-p"><span class="ne-text">基于给定固态存储器的块设备比基于相同类型的存储器的字节寻址要慢一些，因为必须在块的开头开始读取或写入。所以，要读取该块的任何部分，必须寻找到该块的开始，读取整个块，如果不使用该块，则将其丢弃。要写入块的一部分，必须寻找到块的开始，将整个块读入内存，修改数据，再次寻找到块的开头处，然后将整个块写回设备。</span></p><p id="b56f0082d6f7228e3d6e2ccca060af64" class="ne-p"><br></p><h4 id="d4ea5237"><span class="ne-text">字符设备</span></h4><p id="029c7023153fa023483fe82decdea68f" class="ne-p"><br></p><p id="43cd71445d951e98def6564f4fb90e2f" class="ne-p"><span class="ne-text">另一类 I/O 设备是</span><code class="ne-code"><span class="ne-text">字符设备</span></code><span class="ne-text">。字符设备以</span><code class="ne-code"><span class="ne-text">字符</span></code><span class="ne-text">为单位发送或接收一个字符流，而不考虑任何块结构。字符设备是不可寻址的，也没有任何寻道操作。常见的字符设备有 </span><strong><span class="ne-text">打印机、网络设备、鼠标、以及大多数与磁盘不同的设备</span></strong><span class="ne-text">。</span></p><p id="28e05ffc9309d60a2e6a8be0504cb2b6" class="ne-p"><br></p><p id="1613d0fe5c97aa26e6cc98547e4b3f5e" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830510-e704b09f-ae66-45ce-bde4-66fd175dc769.png" width="703" id="ZC93B" class="ne-image"></p><p id="45829f5e3fd12814f44a925a42257add" class="ne-p"><br></p><h3 id="9881f730"><span class="ne-text">设备控制器</span></h3><p id="42cfb8373d43692de4cab682355d0267" class="ne-p"><br></p><p id="01c9dcd39c0617edea3fe8743f8387e7" class="ne-p"><span class="ne-text">设备控制器是处理 CPU 传入和传出信号的系统。设备通过插头和插座连接到计算机，并且插座连接到设备控制器。设备控制器从连接的设备处接收数据，并将其存储在控制器内部的一些</span><code class="ne-code"><span class="ne-text">特殊目的寄存器(special purpose registers)</span></code><span class="ne-text"> 也就是本地缓冲区中。</span></p><p id="e8d0510ece8b2837f0fe7c0812240fab" class="ne-p"><br></p><p id="c5350ce1c360c31d9f02ded8ad634464" class="ne-p"><span class="ne-text">每个设备控制器都会有一个应用程序与之对应，设备控制器通过应用程序的接口通过中断与操作系统进行通信。设备控制器是硬件，而设备驱动程序是软件。</span></p><p id="ee7e18cfd23f391533dba522b7fb2d17" class="ne-p"><br></p><h3 id="2b21e7c0"><span class="ne-text">内存映射 I/O</span></h3><p id="478fcce32a2fb12395f5979c573146eb" class="ne-p"><br></p><p id="de6bab2e6473dcb8f55d739b5d01be84" class="ne-p"><span class="ne-text">每个控制器都会有几个寄存器用来和 CPU 进行通信。通过写入这些寄存器，操作系统可以命令设备发送数据，接收数据、开启或者关闭设备等。通过从这些寄存器中读取信息，操作系统能够知道设备的状态，是否准备接受一个新命令等。</span></p><p id="49d135f8526a65aa9126b14668ee49ed" class="ne-p"><br></p><p id="8c5d7f345d34f8b2c41baab490473318" class="ne-p"><span class="ne-text">为了控制</span><code class="ne-code"><span class="ne-text">寄存器</span></code><span class="ne-text">，许多设备都会有</span><code class="ne-code"><span class="ne-text">数据缓冲区(data buffer)</span></code><span class="ne-text">，来供系统进行读写。</span></p><p id="a5a4118b957e027328e237a6e1a992f3" class="ne-p"><br></p><p id="b2afa8b116e5e0ca2d07bb3a17bd3fa2" class="ne-p"><span class="ne-text">那么问题来了，CPU 如何与设备寄存器和设备数据缓冲区进行通信呢？存在两个可选的方式。第一种方法是，每个控制寄存器都被分配一个 </span><code class="ne-code"><span class="ne-text">I/O 端口(I/O port)</span></code><span class="ne-text">号，这是一个 8 位或 16 位的整数。所有 I/O 端口的集合形成了受保护的 I/O 端口空间，以便普通用户程序无法访问它（只有操作系统可以访问）。使用特殊的 I/O 指令像是</span></p><p id="765a4ca508a5115b78ed2925e14838d8" class="ne-p"><br></p><pre><code>IN REG,PORT</code></pre><p id="d488b29580542c9583338320551ab3c6" class="ne-p"><br></p><p id="08ce542e0db8dcd660e9764cb17b670f" class="ne-p"><span class="ne-text">CPU 可以读取控制寄存器 PORT 的内容并将结果放在 CPU 寄存器 REG 中。类似的，使用</span></p><p id="862fabda27bff31f4481f0fbb1841f04" class="ne-p"><br></p><pre><code>OUT PORT,REG</code></pre><p id="2af22811e69fd5e8ed8a16f28179a129" class="ne-p"><br></p><p id="bded26b72586207ef1db5725a5279922" class="ne-p"><span class="ne-text">CPU 可以将 REG 的内容写到控制寄存器中。大多数早期计算机，包括几乎所有大型主机，如 IBM 360 及其所有后续机型，都是以这种方式工作的。</span></p><p id="726bebd6ef6b472edc3181572bdfa656" class="ne-p"><br></p><p id="473bae0048dd7032999f2251d5a662b7" class="ne-p"><span class="ne-text">第二个方法是 PDP-11 引入的，它将</span><strong><span class="ne-text">所有控制寄存器映射到内存空间</span></strong><span class="ne-text">中。</span></p><p id="55f1ecf17cdddd5693acbda0af158993" class="ne-p"><br></p><h3 id="71380d9f"><span class="ne-text">直接内存访问</span></h3><p id="1cec9d2a2b4a37680ebefd6565e21175" class="ne-p"><br></p><p id="ce6e80a93dc12dcb9aa9d664ffadc5fa" class="ne-p"><span class="ne-text">无论一个 CPU 是否具有内存映射 I/O，它都需要寻址设备控制器以便与它们交换数据。CPU 可以从 I/O 控制器每次请求一个字节的数据，但是这么做会浪费 CPU 时间，所以经常会用到一种称为</span><code class="ne-code"><span class="ne-text">直接内存访问(Direct Memory Access)</span></code><span class="ne-text"> 的方案。为了简化，我们假设 CPU 通过单一的系统总线访问所有的设备和内存，该总线连接 CPU 、内存和 I/O 设备，如下图所示</span></p><p id="009027f46496d3f8f2bcb165a348c8df" class="ne-p"><br></p><p id="85b72b01debce0ace6ba07e6e9e6c0aa" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830508-9d21c036-35f6-4f66-a119-b33cd2ebffa9.png" width="720" id="s3oNe" class="ne-image"></p><p id="fff67c6d75a8f701088870489a68703b" class="ne-p"><br></p><p id="b6f73292094a29c64c123bc26d8c3f35" class="ne-p"><span class="ne-text"> DMA 传送操作</span></p><p id="2e9984b3603d69feb8670dc2a1da4da7" class="ne-p"><br></p><p id="fa3070dc88798a6ad84f66d79849c409" class="ne-p"><span class="ne-text">现代操作系统实际更为复杂，但是原理是相同的。如果硬件有 </span><code class="ne-code"><span class="ne-text">DMA 控制器</span></code><span class="ne-text">，那么操作系统只能使用 DMA。有时这个控制器会集成到磁盘控制器和其他控制器中，但这种设计需要在每个设备上都装有一个分离的 DMA 控制器。单个的 DMA 控制器可用于向多个设备传输，这种传输往往同时进行。</span></p><p id="9872ff0e8287271e0167ad5fe4904890" class="ne-p"><br></p><h4 id="fb19257e"><span class="ne-text">DMA 工作原理</span></h4><p id="a03e5cbf85c29f2523e00aebff3be168" class="ne-p"><br></p><p id="83ad54a6486153ef6c842a3d2356ce33" class="ne-p"><span class="ne-text">首先 CPU 通过设置 DMA 控制器的寄存器对它进行编程，所以 DMA 控制器知道将什么数据传送到什么地方。DMA 控制器还要向磁盘控制器发出一个命令，通知它从磁盘读数据到其内部的缓冲区并检验校验和。当有效数据位于磁盘控制器的缓冲区中时，DMA 就可以开始了。</span></p><p id="988a05fc57bbc139ee60ade19db59775" class="ne-p"><br></p><p id="a747f027f15ed77d2cb1885a1e205177" class="ne-p"><span class="ne-text">DMA 控制器通过在总线上发出一个</span><code class="ne-code"><span class="ne-text">读请求</span></code><span class="ne-text">到磁盘控制器而发起 DMA 传送，这是第二步。这个读请求就像其他读请求一样，磁盘控制器并不知道或者并不关心它是来自 CPU 还是来自 DMA 控制器。通常情况下，要写的内存地址在总线的地址线上，所以当磁盘控制器去匹配下一个字时，它知道将该字写到什么地方。写到内存就是另外一个总线循环了，这是第三步。当写操作完成时，磁盘控制器在总线上发出一个应答信号到 DMA 控制器，这是第四步。</span></p><p id="07fa0e231d1e259cf61d47eec043f097" class="ne-p"><br></p><p id="5db6af288a1595b279c38f3dfc63fbe9" class="ne-p"><span class="ne-text">然后，DMA 控制器会增加内存地址并减少字节数量。如果字节数量仍然大于 0 ，就会循环步骤 2 - 步骤 4 ，直到字节计数变为 0 。此时，DMA 控制器会打断 CPU 并告诉它传输已经完成了。</span></p><p id="9e6195abe1061d23e1d4d22ae3d6afa8" class="ne-p"><br></p><h3 id="88738ca6"><span class="ne-text">重温中断</span></h3><p id="7c3f61ac5e50355d43deec6eb171c4b3" class="ne-p"><br></p><p id="48c3b8a5650e6a887fa2b72a2b529060" class="ne-p"><span class="ne-text">在一台个人计算机体系结构中，中断结构会如下所示</span></p><p id="95bd47e829d0671f561d6b370de02cea" class="ne-p"><br></p><p id="5dd6ab905cdc97ae2993d6f60bcc7ead" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830529-8f149c71-9817-4096-a8df-b613c0308a0c.png" width="719" id="iOWO2" class="ne-image"></p><p id="10d79c44f0beaa13fc3f7bbeb5749849" class="ne-p"><br></p><p id="601484c465041f9864201581aa71a5bd" class="ne-p"><span class="ne-text"> 中断是怎样发生的</span></p><p id="7c3e2170d94eae6e8bb1e7ed99cf48eb" class="ne-p"><br></p><p id="de5270978abbc6bac17d8b32c4827722" class="ne-p"><span class="ne-text">当一个 I/O 设备完成它的工作后，它就会产生一个中断（默认操作系统已经开启中断），它通过在总线上声明已分配的信号来实现此目的。主板上的中断控制器芯片会检测到这个信号，然后执行中断操作。</span></p><p id="d54426721eeb0af5700de3ec951f31f3" class="ne-p"><br></p><h4 id="a032d055"><span class="ne-text">精确中断和不精确中断</span></h4><p id="0373af03e43a5a5ef1859377c0c633d9" class="ne-p"><br></p><p id="91b406cc3a3758fb324eb8607af4e8f2" class="ne-p"><span class="ne-text">使机器处于良好状态的中断称为</span><code class="ne-code"><span class="ne-text">精确中断(precise interrupt)</span></code><span class="ne-text">。这样的中断具有四个属性：</span></p><p id="48b23acc0c3fe244343225c69bafd081" class="ne-p"><br></p><ul class="ne-ul"><li id="8fd4c3bc25c5fe2966bbd8a70be45152"><span class="ne-text">PC （程序计数器）保存在一个已知的地方</span></li><li id="9e17123cbba8fae7fe1a9991e2dd410d"><span class="ne-text">PC 所指向的指令之前所有的指令已经完全执行</span></li></ul><ul class="ne-ul"><li id="340dcd019fc2ddbb3832064d9c975248"><span class="ne-text">PC 所指向的指令之后所有的指令都没有执行</span></li><li id="65e37ac7f0148917395ea4dde0172c57"><span class="ne-text">PC 所指向的指令的执行状态是已知的</span></li></ul><p id="e4c96ab14cd240a871b7845132f1d548" class="ne-p"><br></p><p id="660407a271fb6d3cfc3717ddc6ee834d" class="ne-p"><span class="ne-text">不满足以上要求的中断称为 </span><code class="ne-code"><span class="ne-text">不精确中断(imprecise interrupt)</span></code><span class="ne-text">，不精确中断让人很头疼。上图描述了不精确中断的现象。指令的执行时序和完成度具有不确定性，而且恢复起来也非常麻烦。</span></p><p id="e3e336a043b7c00394ea46bfc5cfd46c" class="ne-p"><br></p><h2 id="bd465b75"><span class="ne-text">IO 软件原理</span></h2><p id="9805805a9a255a10c1f4cb4e0d0c05a7" class="ne-p"><br></p><h3 id="4d234768"><span class="ne-text">I/O 软件目标</span></h3><p id="f96764b4ab266d91c2222e0ddc8d698e" class="ne-p"><br></p><h4 id="e0ddd7b0"><span class="ne-text">设备独立性</span></h4><p id="fb7a0820cadbc5c77f90763e0c7b7ee1" class="ne-p"><br></p><p id="cae2b2b1223c280ab808cd070ae929d4" class="ne-p"><span class="ne-text">I/O 软件设计一个很重要的目标就是</span><code class="ne-code"><span class="ne-text">设备独立性(device independence)</span></code><span class="ne-text">。这意味着</span><strong><span class="ne-text">我们能够编写访问任何设备的应用程序，而不用事先指定特定的设备</span></strong><span class="ne-text">。</span></p><p id="d82bc7d1671e4c56ae19ad479cb3d7f2" class="ne-p"><br></p><p id="1d54ad5122b27da8853c8b013cd174a5" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830529-e4825574-4e1c-43fa-adf0-519f0ea1c7f7.png" width="500" id="GdxNy" class="ne-image"></p><p id="f68ad4f4e9d3b73f17102d65ba3e55e8" class="ne-p"><br></p><h4 id="6a8bef7b"><span class="ne-text">错误处理</span></h4><p id="d1f2e4f1a31eed63e226fd56b6613183" class="ne-p"><br></p><p id="a7884712cfe85b529bebc4d2be5e0cf4" class="ne-p"><span class="ne-text">除了</span><code class="ne-code"><span class="ne-text">设备独立性</span></code><span class="ne-text">外，I/O 软件实现的第二个重要的目标就是</span><code class="ne-code"><span class="ne-text">错误处理(error handling)</span></code><span class="ne-text">。通常情况下来说，错误应该交给</span><code class="ne-code"><span class="ne-text">硬件</span></code><span class="ne-text">层面去处理。如果设备控制器发现了读错误的话，它会尽可能的去修复这个错误。如果设备控制器处理不了这个问题，那么设备驱动程序应该进行处理，设备驱动程序会再次尝试读取操作，很多错误都是偶然性的，如果设备驱动程序无法处理这个错误，才会把错误向上抛到硬件层面（上层）进行处理，很多时候，上层并不需要知道下层是如何解决错误的。</span></p><p id="9e170e1f0fd449f4dd2137e7394a5814" class="ne-p"><br></p><h4 id="11e7c14a"><span class="ne-text">同步和异步传输</span></h4><p id="53f8dc2f75dd7561fb001a400b5bc1e2" class="ne-p"><br></p><p id="3ac6b21c213e53b332d365fd3c462651" class="ne-p"><span class="ne-text">I/O 软件实现的第三个目标就是 </span><code class="ne-code"><span class="ne-text">同步(synchronous)</span></code><span class="ne-text"> 和 </span><code class="ne-code"><span class="ne-text">异步(asynchronous，即中断驱动)</span></code><span class="ne-text">传输。这里先说一下同步和异步是怎么回事吧。</span></p><p id="6600d3b4dbf1a21ab257c236aaf74890" class="ne-p"><br></p><p id="8a81b17161a0891783a1e47bafccc87a" class="ne-p"><span class="ne-text">同步传输中数据通常以块或帧的形式发送。发送方和接收方在数据传输之前应该具有</span><code class="ne-code"><span class="ne-text">同步时钟</span></code><span class="ne-text">。而在异步传输中，数据通常以字节或者字符的形式发送，异步传输则不需要同步时钟，但是会在传输之前向数据添加</span><code class="ne-code"><span class="ne-text">奇偶校验位</span></code><span class="ne-text">。大部分</span><code class="ne-code"><span class="ne-text">物理IO(physical I/O)</span></code><span class="ne-text"> 是异步的。物理 I/O 中的 CPU 是很聪明的，CPU 传输完成后会转而做其他事情，它和中断心灵相通，等到中断发生后，CPU 才会回到传输这件事情上来。</span></p><p id="13f056d30c7563c88922db85f5bfa65b" class="ne-p"><br></p><h4 id="beeaff4e"><span class="ne-text">缓冲</span></h4><p id="695396bd0e3da1432e28a9ec7ad67c44" class="ne-p"><br></p><p id="d694cf6a6b725b199182eab1999db6af" class="ne-p"><span class="ne-text">I/O 软件的最后一个问题是</span><code class="ne-code"><span class="ne-text">缓冲(buffering)</span></code><span class="ne-text">。通常情况下，从一个设备发出的数据不会直接到达最后的设备。其间会经过一系列的校验、检查、缓冲等操作才能到达。</span></p><p id="6d8f5e80ec7671a409b3349aeafa4e84" class="ne-p"><br></p><h4 id="f1ccad80"><span class="ne-text">共享和独占</span></h4><p id="c08f1179ba4ca61d0259277331999928" class="ne-p"><br></p><p id="431707a6eac38d978e9d7b60547c75ec" class="ne-p"><span class="ne-text">I/O 软件引起的最后一个问题就是共享设备和独占设备的问题。有些 I/O 设备能够被许多用户共同使用。一些设备比如磁盘，让多个用户使用一般不会产生什么问题，但是某些设备必须具有独占性，即只允许单个用户使用完成后才能让其他用户使用。</span></p><p id="bcb812bfa70e5469e62fda4e1664762d" class="ne-p"><br></p><p id="fdb189d5793fe92aaecbae65c33c9d60" class="ne-p"><span class="ne-text">一共有三种控制 I/O 设备的方法</span></p><p id="3ac081282b49c86ef8508659ef7bae3c" class="ne-p"><br></p><ul class="ne-ul"><li id="0b7a67c756d4dfb9d85b4a1e274e5cf8"><span class="ne-text">使用程序控制 I/O</span></li><li id="1d1393ce94ebf7d064d3f95fa243aac4"><span class="ne-text">使用中断驱动 I/O</span></li></ul><ul class="ne-ul"><li id="2280839d3c18c5d4110059dbf95d31b0"><span class="ne-text">使用 DMA 驱动 I/O</span></li></ul><p id="efc9fb3091302ca297ac8fd3ebf94a6f" class="ne-p"><br></p><h2 id="ad10edaf"><span class="ne-text">I/O 层次结构</span></h2><p id="62f867ad46d621ab0a552b8ce4d2a9fb" class="ne-p"><br></p><p id="68dfa1c9e4977f08396c1a2cfac6b2ee" class="ne-p"><span class="ne-text">I/O 软件通常组织成四个层次，它们的大致结构如下图所示</span></p><p id="7929e287e6be90fb05c7f6eda9e795c6" class="ne-p"><br></p><p id="3c94fa0cf4df1135075bdba9d69394e4" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830546-fa05a772-fc02-4957-ba1d-1e5a82d78de2.png" width="733" id="la9lz" class="ne-image"></p><p id="367071aef5c7e0cb28661020c6ec67ea" class="ne-p"><br></p><p id="fa33c7104d42e131152f9d0133c0bd34" class="ne-p"><span class="ne-text">下面我们具体的来探讨一下上面的层次结构</span></p><p id="453f272b64d2fca31d28de214c7af40f" class="ne-p"><br></p><h3 id="6b8ce92c"><span class="ne-text">中断处理程序</span></h3><p id="969295b5c2e73885da41f57f47ef9de7" class="ne-p"><br></p><p id="c27f88832c6acafb20ddebaa70764997" class="ne-p"><span class="ne-text">在计算机系统中，中断就像女人的脾气一样无时无刻都在产生，中断的出现往往是让人很不爽的。中断处理程序又被称为</span><code class="ne-code"><span class="ne-text">中断服务程序</span></code><span class="ne-text"> 或者是 </span><code class="ne-code"><span class="ne-text">ISR(Interrupt Service Routines)</span></code><span class="ne-text">，它是最靠近硬件的一层。中断处理程序由硬件中断、软件中断或者是软件异常启动产生的中断，用于实现设备驱动程序或受保护的操作模式（例如系统调用）之间的转换。</span></p><p id="90650cff08428997dffa1476c683dc7d" class="ne-p"><br></p><p id="fb6ef6915c1d6c5b6dc560331811403c" class="ne-p"><span class="ne-text">中断处理程序负责处理中断发生时的所有操作，操作完成后阻塞，然后启动中断驱动程序来解决阻塞。通常会有三种通知方式，依赖于不同的具体实现</span></p><p id="ad18698c37cb1386d4706b9bbd1f4b18" class="ne-p"><br></p><ul class="ne-ul"><li id="d0bf3529fd768e31495ed16c17aff466"><span class="ne-text">信号量实现中：在信号量上使用 </span><code class="ne-code"><span class="ne-text">up</span></code><span class="ne-text"> 进行通知；</span></li><li id="270d701c94d64a8cac75bef7a1a8005c"><span class="ne-text">管程实现：对管程中的条件变量执行 </span><code class="ne-code"><span class="ne-text">signal</span></code><span class="ne-text"> 操作</span></li></ul><ul class="ne-ul"><li id="a5a1d1b1aca07b60a91e3c1ff266e036"><span class="ne-text">还有一些情况是发送一些消息</span></li></ul><p id="e31a7428eaec4de703b54c063801fb8d" class="ne-p"><br></p><h3 id="62e973ec"><span class="ne-text">设备驱动程序</span></h3><p id="72c1ffdc38a4bc2a1e7f08037f01f10f" class="ne-p"><br></p><p id="ff158f09e0c7d71bdd01b66caa4a81b7" class="ne-p"><span class="ne-text">每个连接到计算机的 I/O 设备都需要有某些特定设备的代码对其进行控制。这些提供 I/O 设备到设备控制器转换的过程的代码称为 </span><code class="ne-code"><span class="ne-text">设备驱动程序(Device driver)</span></code><span class="ne-text">。</span></p><p id="ec30527260057319b095d7f987af51b2" class="ne-p"><br></p><p id="c44d98b89a8cb33f62b8d0170aba3810" class="ne-p"><span class="ne-text">设备控制器的主要功能有下面这些</span></p><p id="a8ef9058a6e1d341ecda61b3859848f2" class="ne-p"><br></p><ul class="ne-ul"><li id="03e25f8eb054ac95ed4d49b5e64491fb"><span class="ne-text">接收和识别命令：设备控制器可以接受来自 CPU 的指令，并进行识别。设备控制器内部也会有寄存器，用来存放指令和参数</span></li><li id="9b58f4a82cbcbee09a8c32dbae5e5a4b"><span class="ne-text">进行数据交换：CPU、控制器和设备之间会进行数据的交换，CPU 通过总线把指令发送给控制器，或从控制器中并行地读出数据；控制器将数据写入指定设备。</span></li></ul><ul class="ne-ul"><li id="cee546a33ac12989b6ae397dd0e2575f"><span class="ne-text">地址识别：每个硬件设备都有自己的地址，设备控制器能够识别这些不同的地址，来达到控制硬件的目的，此外，为使 CPU 能向寄存器中写入或者读取数据，这些寄存器都应具有唯一的地址。</span></li><li id="663801b37deb964c633d23a86521b554"><span class="ne-text">差错检测：设备控制器还具有对设备传递过来的数据进行检测的功能。</span></li></ul><p id="186d2e5b3c69f4cc63090482bc71d034" class="ne-p"><br></p><p id="918cc521f50cf3d9e06f10a4209a52a2" class="ne-p"><span class="ne-text">在这种情况下，设备控制器会阻塞，直到中断来解除阻塞状态。还有一种情况是操作是可以无延迟的完成，所以驱动程序不需要阻塞。在第一种情况下，操作系统可能被中断唤醒；第二种情况下操作系统不会被休眠。</span></p><p id="4dc6d4e2af5d94415071e30bbf4dedd3" class="ne-p"><br></p><p id="1921ce376109381d2b798c1d0d33e21e" class="ne-p"><span class="ne-text">设备驱动程序必须是</span><code class="ne-code"><span class="ne-text">可重入</span></code><span class="ne-text">的，因为设备驱动程序会阻塞和唤醒然后再次阻塞。驱动程序不允许进行系统调用，但是它们通常需要与内核的其余部分进行交互。</span></p><p id="b14ceef4943a55f53f523e4cce258b4d" class="ne-p"><br></p><h3 id="e3bc39ca"><span class="ne-text">与设备无关的 I/O 软件</span></h3><p id="10f8fed94d32fc074de365780434ded0" class="ne-p"><br></p><p id="ebda650d821c17681ecaf27bac82b100" class="ne-p"><span class="ne-text">I/O 软件有两种，一种是我们上面介绍过的基于特定设备的，还有一种是</span><code class="ne-code"><span class="ne-text">设备无关性</span></code><span class="ne-text">的，设备无关性也就是不需要特定的设备。设备驱动程序与设备无关的软件之间的界限取决于具体的系统。下面显示的功能由设备无关的软件实现</span></p><p id="0738bab2eec34e7d51f649716df70129" class="ne-p"><br></p><p id="0f127c6454010b4bb99d4d0e7ed1f1ba" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830586-059b4da8-ea81-4a5a-b884-3377ca39d976.png" width="428" id="qRr1F" class="ne-image"></p><p id="5e72fbe3b21aa9f1140fb098efa4b1ce" class="ne-p"><br></p><p id="7d6498e221ca9dbc841a87b949759de7" class="ne-p"><span class="ne-text">与设备无关的软件的基本功能是对所有设备执行公共的 I/O 功能，并且向用户层软件提供一个统一的接口。</span></p><p id="2147c0bb4a536252e4e10fe043856497" class="ne-p"><br></p><h4 id="beeaff4e-1"><span class="ne-text">缓冲</span></h4><p id="70b3be0dccb8514110943a6e97648b17" class="ne-p"><br></p><p id="af82636aa6623d48560a80e60ca7a455" class="ne-p"><span class="ne-text">无论是对于块设备还是字符设备来说，缓冲都是一个非常重要的考量标准。缓冲技术应用广泛，但它也有缺点。如果数据被缓冲次数太多，会影响性能。</span></p><p id="14ca5e8726df30d891d845d39491b86f" class="ne-p"><br></p><h4 id="6a8bef7b-1"><span class="ne-text">错误处理</span></h4><p id="1bd1dadfd62e3af3a1173bcb759bfb94" class="ne-p"><br></p><p id="b09255dfe1fe9917fbddf39e9aa593de" class="ne-p"><span class="ne-text">在 I/O 中，出错是一种再正常不过的情况了。当出错发生时，操作系统必须尽可能处理这些错误。有一些错误是只有特定的设备才能处理，有一些是由框架进行处理，这些错误和特定的设备无关。</span></p><p id="965a674df58190d1b05557392745253b" class="ne-p"><br></p><p id="ee5331138dfc8e986ea7badf7ba49ce5" class="ne-p"><span class="ne-text">I/O 错误的一类是程序员</span><code class="ne-code"><span class="ne-text">编程</span></code><span class="ne-text">错误，比如还没有打开文件前就读流，或者不关闭流导致内存溢出等等。这类问题由程序员处理；另外一类是实际的 I/O 错误，例如向一个磁盘坏块写入数据，无论怎么写都写入不了。这类问题由驱动程序处理，驱动程序处理不了交给硬件处理，这个我们上面也说过。</span></p><p id="522aff626808aa1e8c176163d925a242" class="ne-p"><br></p><h4 id="4e16fdac"><span class="ne-text">设备驱动程序统一接口</span></h4><p id="b4d2e1f579a5150b9d5d256369497333" class="ne-p"><br></p><p id="26833baca0c0963e267e4649428f43be" class="ne-p"><span class="ne-text">我们在操作系统概述中说到，操作系统一个非常重要的功能就是屏蔽了硬件和软件的差异性，为硬件和软件提供了统一的标准，这个标准还体现在为设备驱动程序提供统一的接口，因为不同的硬件和厂商编写的设备驱动程序不同，所以如果为每个驱动程序都单独提供接口的话，这样没法搞，所以必须统一。</span></p><p id="bbde6811238d412e5b62ea43f1d18f97" class="ne-p"><br></p><h4 id="c74ca274"><span class="ne-text">分配和释放</span></h4><p id="4aba2ddd488b12a50616973441385c40" class="ne-p"><br></p><p id="dfe10ac47170d60e5e6d5d9b24b9c827" class="ne-p"><span class="ne-text">一些设备例如打印机，它只能由一个进程来使用，这就需要操作系统根据实际情况判断是否能够对设备的请求进行检查，判断是否能够接受其他请求，一种比较简单直接的方式是在特殊文件上执行 </span><code class="ne-code"><span class="ne-text">open</span></code><span class="ne-text">操作。如果设备不可用，那么直接 open 会导致失败。还有一种方式是不直接导致失败，而是让其阻塞，等到另外一个进程释放资源后，在进行 open 打开操作。这种方式就把选择权交给了用户，由用户判断是否应该等待。</span></p><p id="510e44b2f5b8f53eaa9a17d6fbf08d28" class="ne-p"><br></p><h4 id="5dae479a"><span class="ne-text">设备无关的块</span></h4><p id="cdbefea531e399d091ad67a9c010a18e" class="ne-p"><br></p><p id="97f7a0d77ba330bf8aa1481f43e9db01" class="ne-p"><span class="ne-text">不同的磁盘会具有不同的扇区大小，但是软件不会关心扇区大小，只管存储就是了。一些字符设备可以一次一个字节的交付数据，而其他的设备则以较大的单位交付数据，这些差异也可以隐藏起来。</span></p><p id="7c1bb67a7692b24f169e8ed1c7dd6425" class="ne-p"><br></p><h3 id="6d8fb3eb"><span class="ne-text">用户空间的 I/O 软件</span></h3><p id="22e1a0b547c5bcd83b395670c5dfbddf" class="ne-p"><br></p><p id="b44115534de48afe22f229f049c4dd3d" class="ne-p"><span class="ne-text">虽然大部分 I/O 软件都在内核结构中，但是还有一些在用户空间实现的 I/O 软件，凡事没有绝对。一些 I/O 软件和库过程在用户空间存在，然后以提供系统调用的方式实现。</span></p><p id="daf9ee811684e122a58c85cb4e3d1ab8" class="ne-p"><br></p><h2 id="ff4efcaf"><span class="ne-text">盘</span></h2><p id="f670bd979c27b25d4c7d4fc8220167b5" class="ne-p"><br></p><p id="46790dad61b28c8d412e582e4b59070a" class="ne-p"><span class="ne-text">盘可以说是硬件里面比较简单的构造了，同时也是最重要的。下面我们从盘谈起，聊聊它的物理构造</span></p><p id="6f9f8e17698ca692669e1ed2b80c6402" class="ne-p"><br></p><h3 id="6f7147b6"><span class="ne-text">盘硬件</span></h3><p id="881f0a078f484235fe35102fd05a5fcc" class="ne-p"><br></p><p id="410790e052c1df4a2afe5f919551a676" class="ne-p"><span class="ne-text">盘会有很多种类型。其中最简单的构造就是</span><code class="ne-code"><span class="ne-text">磁盘(magnetic hard disks)</span></code><span class="ne-text">， 也被称为 </span><code class="ne-code"><span class="ne-text">hard disk,HDD</span></code><span class="ne-text">等。磁盘通常与安装在磁臂上的磁头配对，磁头可将数据读取或者将数据写入磁盘，因此磁盘的读写速度都同样快。在磁盘中，数据是随机访问的，这也就说明可以通过任意的顺序来</span><code class="ne-code"><span class="ne-text">存储</span></code><span class="ne-text">和</span><code class="ne-code"><span class="ne-text">检索</span></code><span class="ne-text">单个数据块，所以你可以在任意位置放置磁盘来让磁头读取，磁盘是一种</span><code class="ne-code"><span class="ne-text">非易失性</span></code><span class="ne-text">的设备，即使断电也能永久保留。</span></p><p id="7697974a6ae1d7204b416004062d2c44" class="ne-p"><br></p><h4 id="4f5537dd"><span class="ne-text">磁盘</span></h4><p id="a7ccf8203470d7449eecb013543925cd" class="ne-p"><br></p><p id="99c3228c34d08b56f9e4be97cf06b550" class="ne-p"><span class="ne-text">为了组织和检索数据，会将磁盘组织成特定的结构，这些特定的结构就是</span><strong><span class="ne-text">磁道、扇区和柱面</span></strong></p><p id="4aef88f0b558db891f24c06feed2859c" class="ne-p"><br></p><p id="1ffcc406a94d9db392fcc0964818d5f3" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830596-8b2a7f11-b5c9-4a00-b0c9-436889b099a8.png" width="498" id="XlRJ3" class="ne-image"></p><p id="6b06d914be3bc7c54870e83b6c07bc5f" class="ne-p"><br></p><p id="37a4261fd1b90279efe2e7508794d558" class="ne-p"><span class="ne-text">磁盘被组织成柱面形式，每个盘用轴相连，每一个柱面包含若干磁道，每个磁道由若干扇区组成。软盘上大约每个磁道有 8 - 32 个扇区，硬盘上每条磁道上扇区的数量可达几百个，磁头大约是 1 - 16 个。</span></p><p id="97b0132a4dc0ae7ea912969bd55fd30b" class="ne-p"><br></p><p id="81575d25682d5751d39b94b88d20e861" class="ne-p"><span class="ne-text">对于磁盘驱动程序来说，一个非常重要的特性就是控制器是否能够同时控制两个或者多个驱动器进行磁道寻址，这就是</span><code class="ne-code"><span class="ne-text">重叠寻道(overlapped seek)</span></code><span class="ne-text">。对于控制器来说，它能够控制一个磁盘驱动程序完成寻道操作，同时让其他驱动程序等待寻道结束。控制器也可以在一个驱动程序上进行读写草哦做，与此同时让另外的驱动器进行寻道操作，但是软盘控制器不能在两个驱动器上进行读写操作。</span></p><p id="62b66fc124bdd060dc868e7aac33e6d7" class="ne-p"><br></p><h4 id="RAID"><span class="ne-text">RAID</span></h4><p id="ffaba10a54eaac5469b3370e3b57ec33" class="ne-p"><br></p><p id="06399267d1efd2f5ec1beb76f23a781c" class="ne-p"><span class="ne-text">RAID 称为 </span><code class="ne-code"><span class="ne-text">磁盘冗余阵列</span></code><span class="ne-text">，简称 </span><code class="ne-code"><span class="ne-text">磁盘阵列</span></code><span class="ne-text">。利用虚拟化技术把多个硬盘结合在一起，成为一个或多个磁盘阵列组，目的是提升性能或数据冗余。</span></p><p id="e603443b78b137065f5838e183e64ae6" class="ne-p"><br></p><p id="d99b54a84a692f29ff775f8d078930b0" class="ne-p"><span class="ne-text">RAID 有不同的级别</span></p><p id="006985b2d9a124508177b0fe9a97e3d8" class="ne-p"><br></p><ul class="ne-ul"><li id="fc7b26a623451b45652560652f0ce2dc"><span class="ne-text">RAID 0 - 无容错的条带化磁盘阵列</span></li><li id="608dcc8c4da9da1cc93901fce2f72bd4"><span class="ne-text">RAID 1 - 镜像和双工</span></li></ul><ul class="ne-ul"><li id="e2f271c87c776d795773644ce782a5be"><span class="ne-text">RAID 2 - 内存式纠错码</span></li><li id="b865a2f4bbc441c2d6c00230b77ba8a6"><span class="ne-text">RAID 3 - 比特交错奇偶校验</span></li></ul><ul class="ne-ul"><li id="ffd5c142e5fbb5f5caeb8ad4d2df93a9"><span class="ne-text">RAID 4 - 块交错奇偶校验</span></li><li id="b27145d5ca28e12929413d476ca9d1d4"><span class="ne-text">RAID 5 - 块交错分布式奇偶校验</span></li></ul><ul class="ne-ul"><li id="44edb52008f1699295a33a01674147e4"><span class="ne-text">RAID 6 - P + Q冗余</span></li></ul><p id="e0dd1db8bb6fec97312e991f0c0702d6" class="ne-p"><br></p><h4 id="a0c9482b"><span class="ne-text">磁盘格式化</span></h4><p id="603ffce150e2fc1d987dcfd88ae12f0e" class="ne-p"><br></p><p id="2892a91ceec697d1af55116f4eed65ed" class="ne-p"><span class="ne-text">磁盘由一堆铝的、合金或玻璃的盘片组成，磁盘刚被创建出来后，没有任何信息。磁盘在使用前必须经过</span><code class="ne-code"><span class="ne-text">低级格式化(low-levvel format)</span></code><span class="ne-text">，下面是一个扇区的格式</span></p><p id="237635b0cde6098f7edf3d17b16c4fb5" class="ne-p"><br></p><p id="9eb9a9e1de2f4cd41c8c10489509b3f3" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830611-1b106d56-fbdb-4e79-b2b5-e5bd2778a387.png" width="638" id="LU06a" class="ne-image"></p><p id="0c16920b767cb6ec4ea66f9992882f6b" class="ne-p"><br></p><p id="0666a317b3e567ada28b40a2ae4678b7" class="ne-p"><span class="ne-text">前导码相当于是标示扇区的开始位置，通常以位模式开始，前导码还包括</span><code class="ne-code"><span class="ne-text">柱面号</span></code><span class="ne-text">、</span><code class="ne-code"><span class="ne-text">扇区号</span></code><span class="ne-text">等一些其他信息。紧随前导码后面的是数据区，数据部分的大小由低级格式化程序来确定。大部分磁盘使用 512 字节的扇区。数据区后面是 ECC，ECC 的全称是 </span><strong><span class="ne-text">error correction code</span></strong><span class="ne-text"> ，</span><code class="ne-code"><span class="ne-text">数据纠错码</span></code><span class="ne-text">，它与普通的错误检测不同，ECC 还可以用于恢复读错误。ECC 阶段的大小由不同的磁盘制造商实现。ECC 大小的设计标准取决于</span><strong><span class="ne-text">设计者愿意牺牲多少磁盘空间来提高可靠性</span></strong><span class="ne-text">，以及程序可以处理的 ECC 的复杂程度。通常情况下 ECC 是 16 位，除此之外，硬盘一般具有一定数量的备用扇区，用于替换制造缺陷的扇区。</span></p><p id="7528fe0235fd15d3595da91dcbfc864d" class="ne-p"><br></p><h3 id="760df63f"><span class="ne-text">磁盘臂调度算法</span></h3><p id="b6278a03e824428f665cec4c6e256f50" class="ne-p"><br></p><p id="03e011ea5a88d0387736e681d5ce4617" class="ne-p"><span class="ne-text">下面我们来探讨一下关于影响磁盘读写的算法，一般情况下，影响磁盘快读写的时间由下面几个因素决定</span></p><p id="314b5126105ededa2a365cf439adc99f" class="ne-p"><br></p><ul class="ne-ul"><li id="7462d9403fc3252905f5a028434ad7c1"><span class="ne-text">寻道时间 - 寻道时间指的就是将磁盘臂移动到需要读取磁盘块上的时间</span></li><li id="5f7257bc3d72ff601be446ec912b45ca"><span class="ne-text">旋转延迟 - 等待合适的扇区旋转到磁头下所需的时间</span></li></ul><ul class="ne-ul"><li id="2be1b7ef29e9defa9d00b39f69ec3494"><span class="ne-text">实际数据的读取或者写入时间</span></li></ul><p id="2b370356fac399fe05f109995162a179" class="ne-p"><br></p><p id="0dc67d0cf7fad6f14c4ad3b58f27915e" class="ne-p"><span class="ne-text">这三种时间参数也是磁盘寻道的过程。一般情况下，寻道时间对总时间的影响最大，所以，有效的降低寻道时间能够提高磁盘的读取速度。</span></p><p id="91c6c8ce16ce7b9388de0e43ef253a37" class="ne-p"><br></p><p id="8d11395ec1947cc3a0b7ab12754b4328" class="ne-p"><span class="ne-text">如果磁盘驱动程序每次接收一个请求并按照接收顺序完成请求，这种处理方式也就是 </span><code class="ne-code"><span class="ne-text">先来先服务(First-Come, First-served, FCFS)</span></code><span class="ne-text"> ，这种方式很难优化寻道时间。因为每次都会按照顺序处理，不管顺序如何，有可能这次读完后需要等待一个磁盘旋转一周才能继续读取，而其他柱面能够马上进行读取，这种情况下每次请求也会排队。</span></p><p id="7d18009d76c74dd7b8db33951c729bd5" class="ne-p"><br></p><p id="c10ff5cc598f273b4133beab2f7333d7" class="ne-p"><span class="ne-text">通常情况下，磁盘在进行寻道时，其他进程会产生其他的磁盘请求。磁盘驱动程序会维护一张表，表中会记录着柱面号当作索引，每个柱面未完成的请求会形成链表，链表头存放在表的相应表项中。</span></p><p id="e046aef3abb66ef5daf5fc38d4c7ca3e" class="ne-p"><br></p><p id="6a69ca5623a5c553a4153757cc235dc8" class="ne-p"><span class="ne-text">一种对先来先服务的算法改良的方案是使用 </span><code class="ne-code"><span class="ne-text">最短路径优先(SSF)</span></code><span class="ne-text"> 算法，下面描述了这个算法。</span></p><p id="32b5296ec1d24eb2a7d5a6939088ad43" class="ne-p"><br></p><p id="9b84f8da5378b036c6c206344a7a7154" class="ne-p"><span class="ne-text">假如我们在对磁道 6 号进行寻址时，同时发生了对 11 , 2 , 4, 14, 8, 15, 3 的请求，如果采用先来先服务的原则，如下图所示</span></p><p id="807006c94eac31f179e807c72677c14d" class="ne-p"><br></p><p id="139b589cb34fee0e242e2a53b569c729" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830646-2dfee703-9a35-47c9-880c-2c620d64464a.png" width="762" id="GIQle" class="ne-image"></p><p id="852c3cef391fcf30dcbc45d68ead84cb" class="ne-p"><br></p><p id="07318c6d578eb7970403c2e9c0200380" class="ne-p"><span class="ne-text">我们可以计算一下磁盘臂所跨越的磁盘数量为 5 + 9 + 2 + 10 + 6 + 7 + 12 = 51，相当于是跨越了 51 次盘面，如果使用最短路径优先，我们来计算一下跨越的盘面</span></p><p id="9251d4187ee9e3955d98e126f5a61b7b" class="ne-p"><br></p><p id="f7750d7e03767b8fb7464af21e31e096" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830629-e3cda6d4-2317-438b-a377-9e5dc5a3a802.png" width="709" id="k9irp" class="ne-image"></p><p id="33fc7e528d1fb915ae0e5eb381f979a1" class="ne-p"><br></p><p id="a31730f3fb60b31dd1c442e0b3c89ff8" class="ne-p"><span class="ne-text">跨越的磁盘数量为 4 + 1 + 1 + 4 + 3 + 3 + 1 = 17 ，相比 51 足足省了两倍的时间。</span></p><p id="aeb569eb1e81c5ef30132a4f118513d6" class="ne-p"><br></p><p id="bbe4e798ae04ba9181c1b53f7030014c" class="ne-p"><span class="ne-text">但是，最短路径优先的算法也不是完美无缺的，这种算法照样存在问题，那就是</span><code class="ne-code"><span class="ne-text">优先级</span></code><span class="ne-text"> 问题，</span></p><p id="33bbdf6c3903be454a5434c1b4b45129" class="ne-p"><br></p><p id="753770733d67a5f8ee48a11ff1bbe27a" class="ne-p"><span class="ne-text">这里有一个原型可以参考就是我们日常生活中的电梯，电梯使用一种</span><code class="ne-code"><span class="ne-text">电梯算法(elevator algorithm)</span></code><span class="ne-text"> 来进行调度，从而满足协调效率和公平性这两个相互冲突的目标。电梯一般会保持向一个方向移动，直到在那个方向上没有请求为止，然后改变方向。</span></p><p id="58e3089c129557a6025b4b2e291be8e5" class="ne-p"><br></p><p id="6148ba2cda1c3131d27d57b6737daef0" class="ne-p"><span class="ne-text">电梯算法需要维护一个</span><code class="ne-code"><span class="ne-text">二进制位</span></code><span class="ne-text">，也就是当前的方向位：</span><code class="ne-code"><span class="ne-text">UP(向上)</span></code><span class="ne-text">或者是 </span><code class="ne-code"><span class="ne-text">DOWN(向下)</span></code><span class="ne-text">。当一个请求处理完成后，磁盘或电梯的驱动程序会检查该位，如果此位是 UP 位，磁盘臂或者电梯仓移到下一个更高跌未完成的请求。如果高位没有未完成的请求，则取相反方向。当方向位是 </span><code class="ne-code"><span class="ne-text">DOWN</span></code><span class="ne-text"> 时，同时存在一个低位的请求，磁盘臂会转向该点。如果不存在的话，那么它只是停止并等待。</span></p><p id="e90c80069ca940c4dccc45414d988aa6" class="ne-p"><br></p><p id="2e5464096db15e05287322aedc930903" class="ne-p"><span class="ne-text">我们举个例子来描述一下电梯算法，比如各个柱面得到服务的顺序是 4，7，10，14，9，6，3，1 ，那么它的流程图如下</span></p><p id="f8c4a980d7ccbf906215cfae641fb9de" class="ne-p"><br></p><p id="9db3b630e1e92fea3c4e594885ac701c" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830648-6e8afe9c-f2fd-4c64-8db9-7f68930d0a27.png" width="710" id="qkkaP" class="ne-image"></p><p id="c0843a5f92d2fd7b0137831f7a66b398" class="ne-p"><br></p><p id="56a54c492ce1f8a483ad07c078eedaa6" class="ne-p"><span class="ne-text">所以电梯算法需要跨越的盘面数量是 3 + 3 + 4 + 5 + 3 + 3 + 1 = 22</span></p><p id="6537fc8bf8f453295d6a455f604979f3" class="ne-p"><br></p><p id="67c0f7b60aa67bfebb7ad608b2d9b80e" class="ne-p"><span class="ne-text">电梯算法通常情况下不如 SSF 算法。</span></p><p id="6cdbd3e42df5f443f82a300371150d79" class="ne-p"><br></p><h3 id="6a8bef7b-2"><span class="ne-text">错误处理</span></h3><p id="cd448c76eee05090052f87c787370093" class="ne-p"><br></p><p id="e35a9d1da80fb23de9e8c755ab4375f7" class="ne-p"><span class="ne-text">一般坏块有两种处理办法，一种是在控制器中进行处理；一种是在操作系统层面进行处理。</span></p><p id="f72cda08c63f4925bb58c1e69dc98731" class="ne-p"><br></p><p id="efe36e8265e3ea31c5ca3acbbd4d2419" class="ne-p"><span class="ne-text">这两种方法经常替换使用，比如一个具有 30 个数据扇区和两个备用扇区的磁盘，其中扇区 4 是有瑕疵的。</span></p><p id="46e08dedb1f01e545beee9d410b8ca30" class="ne-p"><br></p><p id="973a0923ca8878b60159e1381d2db988" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830690-4489f1b3-d4a8-49d6-bd29-1becb143d418.png" width="423" id="j9QM3" class="ne-image"></p><p id="efc58b0eaccde5c29602b247280b7659" class="ne-p"><br></p><p id="c04a32c0f9c7869487d8bf460b2af6f0" class="ne-p"><span class="ne-text">控制器能做的事情就是将备用扇区之一重新映射。</span></p><p id="b409a58389fcff3598c331a89f6dbeb2" class="ne-p"><br></p><p id="4da899689af489cd2c870ae6658c4290" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830735-2f51c8ae-a37f-4673-9781-a2519263c63f.png" width="500" id="BSem5" class="ne-image"></p><p id="8e494cf7453125ff435eff2d552fb41d" class="ne-p"><br></p><p id="e6f45bb62550a08872dea21674e5c005" class="ne-p"><span class="ne-text">还有一种处理方式是将所有的扇区都向上移动一个扇区</span></p><p id="c46a73b199e28b719c907ef92d49b313" class="ne-p"><br></p><p id="48f0cc7b31fc216b96308193861a1900" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830717-1dc1be76-6eff-4891-8d89-843a7110e6a8.png" width="497" id="OZ9U3" class="ne-image"></p><p id="c3abc09db901f9b310fad8ef6cdb5415" class="ne-p"><br></p><p id="1559044f1c5e9c73aff061102d26bd29" class="ne-p"><span class="ne-text">上面这这两种情况下控制器都必须知道哪个扇区，可以通过内部的表来跟踪这一信息，或者通过重写前导码来给出重新映射的扇区号。如果是重写前导码，那么涉及移动的方式必须重写后面所有的前导码，但是最终会提供良好的性能。</span></p><p id="f15e6f8229cb758b7b0c9e8ebb12edd8" class="ne-p"><br></p><h3 id="dd4fb2cb"><span class="ne-text">稳定存储器</span></h3><p id="4ad899cab1ab97a5aabbaf01a5be34cf" class="ne-p"><br></p><p id="58e282adac0cb4419208d340a02153a8" class="ne-p"><span class="ne-text">磁盘经常会出现错误，导致好的扇区会变成坏扇区，驱动程序也有可能挂掉。RAID 可以对扇区出错或者是驱动器崩溃提出保护，然而 RAID 却不能对坏数据中的写错误提供保护，也不能对写操作期间的崩溃提供保护，这样就会破坏原始数据。</span></p><p id="473a78fd5112572f75a9b22ad7bf64eb" class="ne-p"><br></p><p id="27763f1b1c4778a17eba274ab07dbeec" class="ne-p"><span class="ne-text">我们期望磁盘能够准确无误的工作，但是事实情况是不可能的，但是我们能够知道的是，一个磁盘子系统具有如下特性：当一个写命令发给它时，磁盘要么正确地写数据，要么什么也不做，让现有的数据完整无误的保留。这样的系统称为 </span><code class="ne-code"><span class="ne-text">稳定存储器(stable storage)</span></code><span class="ne-text">。 稳定存储器的目标就是不惜一切代价保证磁盘的一致性。</span></p><p id="e0bbd24c6e2eac90bc9bef03d023565c" class="ne-p"><br></p><p id="23c65e8ec21c9f98369932ed2ca149d8" class="ne-p"><span class="ne-text">稳定存储器使用两个一对相同的磁盘，对应的块一同工作形成一个无差别的块。稳定存储器为了实现这个目的，定义了下面三种操作：</span></p><p id="5fb6db8f32f3839372d1c236a3e8bf98" class="ne-p"><br></p><ul class="ne-ul"><li id="11e13f4166e70f36fb7c87fb739dea9c"><code class="ne-code"><span class="ne-text">稳定写(stable write)</span></code></li><li id="895c72d40eb8c8f6b8d1b19066db9933"><code class="ne-code"><span class="ne-text">稳定读(stable read)</span></code></li></ul><ul class="ne-ul"><li id="da686324dfe297329016a5be43c1141d"><code class="ne-code"><span class="ne-text">崩溃恢复(crash recovery)</span></code></li></ul><p id="3bf3c6998eede59026606fee3cbb805a" class="ne-p"><br></p><h2 id="751437d1"><span class="ne-text">时钟</span></h2><p id="42bfc7cc58126df175de0804edb625f1" class="ne-p"><br></p><p id="275f2f33e6f9a41aaf0f1af466175266" class="ne-p"><code class="ne-code"><span class="ne-text">时钟(Clocks)</span></code><span class="ne-text"> 也被称为</span><code class="ne-code"><span class="ne-text">定时器(timers)</span></code><span class="ne-text">，时钟/定时器对任何程序系统来说都是必不可少的。时钟负责维护时间、防止一个进程长期占用 CPU 时间等其他功能。</span><code class="ne-code"><span class="ne-text">时钟软件(clock software)</span></code><span class="ne-text"> 也是一种设备驱动的方式。下面我们就来对时钟进行介绍，一般都是先讨论硬件再介绍软件，采用由下到上的方式，也是告诉你，底层是最重要的。</span></p><p id="53b9aa404a3a4a083622863777556273" class="ne-p"><br></p><h3 id="e8a4fb9a"><span class="ne-text">时钟硬件</span></h3><p id="2a655f87074ad58d9ef984e79932a319" class="ne-p"><br></p><p id="8ef96daa1f5875a499646dd402188b1f" class="ne-p"><span class="ne-text">在计算机中有两种类型的时钟，这些时钟与现实生活中使用的时钟完全不一样。</span></p><p id="2e4a913ade7c6d01a0f32f2a434d095c" class="ne-p"><br></p><ul class="ne-ul"><li id="55f7695ceccc219d7810683c20403f2f"><span class="ne-text">比较简单的一种时钟被连接到 110 V 或 220 V 的电源线上，这样每个</span><code class="ne-code"><span class="ne-text">电压周期</span></code><span class="ne-text">会产生一个中断，大概是 50 - 60 HZ。这些时钟过去一直占据支配地位。</span></li><li id="cf9376a6328b7c2eb22a1a93c6f08aa6"><span class="ne-text">另外的一种时钟由晶体振荡器、计数器和寄存器组成，示意图如下所示</span></li></ul><p id="439d4fe21f5ac9db8fcc1898d175e44d" class="ne-p"><br></p><p id="58e69eb2dd1d8030de36ab796376c1f3" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830741-6daaaf06-0552-44b1-bf19-85729fd25288.png" width="627" id="VUI1p" class="ne-image"></p><p id="138cdebd4b5315b038710c7d2442d19c" class="ne-p"><br></p><p id="fed5845bb86ffee727f4ec21c1f3305b" class="ne-p"><span class="ne-text">这种时钟称为</span><code class="ne-code"><span class="ne-text">可编程时钟</span></code><span class="ne-text"> ，可编程时钟有两种模式，一种是 </span><code class="ne-code"><span class="ne-text">一键式(one-shot mode)</span></code><span class="ne-text">，当时钟启动时，会把存储器中的值复制到计数器中，然后，每次晶体的振荡器的脉冲都会使计数器 -1。当计数器变为 0 时，会产生一个中断，并停止工作，直到软件再一次显示启动。还有一种模式时 </span><code class="ne-code"><span class="ne-text">方波(square-wave mode)</span></code><span class="ne-text"> 模式，在这种模式下，当计数器变为 0 并产生中断后，存储寄存器的值会自动复制到计数器中，这种周期性的中断称为一个时钟周期。</span></p><p id="bda3a730c41682e58599382a899dcd60" class="ne-p"><br></p><h3 id="b173f2cb"><span class="ne-text">时钟软件</span></h3><p id="d8bdf65c9a5135888a2497a3439f7145" class="ne-p"><br></p><p id="b00c628ad58f5b5dce23e9850a61c034" class="ne-p"><span class="ne-text">时钟硬件所做的工作只是根据已知的时间间隔产生中断，而其他的工作都是由</span><code class="ne-code"><span class="ne-text">时钟软件</span></code><span class="ne-text">来完成，一般操作系统的不同，时钟软件的具体实现也不同，但是一般都会包括以下这几点</span></p><p id="c9f6a7282375ba50967103b96e0fa187" class="ne-p"><br></p><ul class="ne-ul"><li id="87f3966c7f38a21ec3de2e00caa8c495"><span class="ne-text">维护一天的时间</span></li><li id="83f9eb2354f6857b43e402f24d895af3"><span class="ne-text">阻止进程运行的时间超过其指定时间</span></li></ul><ul class="ne-ul"><li id="b15f932d0660dfeed727e20b42edf52d"><span class="ne-text">统计 CPU 的使用情况</span></li><li id="5b41149ddbaee4b2dc5216e16149e38a"><span class="ne-text">处理用户进程的警告系统调用</span></li></ul><ul class="ne-ul"><li id="3e1b60c00fc9f9f5bc20bfc979ef00a2"><span class="ne-text">为系统各个部分提供看门狗定时器</span></li><li id="d2276a0cd1af25e63d9f08f9fe7ee549"><span class="ne-text">完成概要剖析，监视和信息收集</span></li></ul><p id="9e1dabd93c76dcfad0d1beab34188d56" class="ne-p"><br></p><h3 id="b91fda0e"><span class="ne-text">软定时器</span></h3><p id="95ae8d930b294e9c0fbf9c4a05ebbc55" class="ne-p"><br></p><p id="a5c4252cb21d8d6068043a7afe3d314c" class="ne-p"><span class="ne-text">时钟软件也被称为可编程时钟，可以设置它以程序需要的任何速率引发中断。时钟软件触发的中断是一种硬中断，但是某些应用程序对于硬中断来说是不可接受的。</span></p><p id="f79ba5cf1321c60b2dc29763e734e1ac" class="ne-p"><br></p><p id="e6dfdfd7167d693006ca2a8a105d7c9b" class="ne-p"><span class="ne-text">这时候就需要一种</span><code class="ne-code"><span class="ne-text">软定时器(soft timer)</span></code><span class="ne-text"> 避免了中断，无论何时当内核因为某种原因呢在运行时，它返回用户态之前都会检查时钟来了解软定时器是否到期。如果软定时器到期，则执行被调度的事件也无需切换到内核态，因为本身已经处于内核态中。这种方式避免了频繁的内核态和用户态之前的切换，提高了程序运行效率。</span></p><p id="4d84d77fd04a9489fe535b3daa4f7b69" class="ne-p"><br></p><p id="d50c55b092a1800b5a7f27a4dc606790" class="ne-p"><span class="ne-text">软定时器因为不同的原因切换进入内核态的速率不同，原因主要有</span></p><p id="b15053b7084f5d35f327aba23c558ddd" class="ne-p"><br></p><ul class="ne-ul"><li id="e896c450129d2ead85b0eb99d11bb5eb"><span class="ne-text">系统调用</span></li><li id="0c1a4062ca9907469cc5b5a914f250ef"><span class="ne-text">TLB 未命中</span></li></ul><ul class="ne-ul"><li id="f984a4635683adf2eff00aa2764aae22"><span class="ne-text">缺页异常</span></li><li id="1e8fa7b36d7c84263c14a105f9d8a40a"><span class="ne-text">I/O 中断</span></li></ul><ul class="ne-ul"><li id="8584034cbecc7bed86a6ce92b0021351"><span class="ne-text">CPU 变得空闲</span></li></ul><p id="8c1b12bc4cb14f1332748c06db0e8a82" class="ne-p"><br></p><p id="20bd0c60869e5232c1a9da4f41bc3362" class="ne-p"><span class="ne-text">死锁问题也是操作系统非常重要的一类问题</span></p><p id="d8b84eaac214a26402cf69e0457896cb" class="ne-p"><br></p><p id="2e47e39e0877ecee085aa3aa086c4bd7" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830748-305133ff-5324-4e46-b119-74609aedd401.png" width="721" id="WK6xj" class="ne-image"></p><p id="a9d7734a1e890759c5b156cdd8f82011" class="ne-p"><br></p><h2 id="eee83a92"><span class="ne-text">资源</span></h2><p id="d7231e68daee7dc7da7271048e9e2f43" class="ne-p"><br></p><p id="9478bc370ebcfa642d99c1b1d4e681fa" class="ne-p"><span class="ne-text">大部分的死锁都和资源有关，在进程对设备、文件具有独占性（排他性）时会产生死锁。我们把这类需要排他性使用的对象称为</span><code class="ne-code"><span class="ne-text">资源(resource)</span></code><span class="ne-text">。资源主要分为 </span><strong><span class="ne-text">可抢占资源和不可抢占资源</span></strong></p><p id="3eac1e4d117abd05087b36175c975155" class="ne-p"><br></p><h3 id="27201743"><span class="ne-text">可抢占资源和不可抢占资源</span></h3><p id="72ec56e9b234da0b742fc02a6cabc6f5" class="ne-p"><br></p><p id="aca2fb281a7bd5541bea22c94bd6b33a" class="ne-p"><span class="ne-text">资源主要有可抢占资源和不可抢占资源。</span><code class="ne-code"><span class="ne-text">可抢占资源(preemptable resource)</span></code><span class="ne-text"> 可以从拥有它的进程中抢占而不会造成其他影响，内存就是一种可抢占性资源，任何进程都能够抢先获得内存的使用权。</span></p><p id="5b8beb8ea2c4de6036320fcc924dcf57" class="ne-p"><br></p><p id="e1b275fbf0b76f9c98f8612371b35e35" class="ne-p"><code class="ne-code"><span class="ne-text">不可抢占资源(nonpreemtable resource)</span></code><span class="ne-text"> 指的是除非引起错误或者异常，否则进程无法抢占指定资源，这种不可抢占的资源比如有光盘，在进程执行调度的过程中，其他进程是不能得到该资源的。</span></p><p id="1bb4f502e68b522ee9f808e108067db3" class="ne-p"><br></p><h2 id="60461afa"><span class="ne-text">死锁</span></h2><p id="fb62f7163749f731b9eea44242c66117" class="ne-p"><br></p><p id="fd64352b74e15c5119d31f2d078fa99f" class="ne-p"><span class="ne-text">如果要对死锁进行一个定义的话，下面的定义比较贴切</span></p><p id="481b22ddedf0cdb8abca22a089108ce4" class="ne-p"><br></p><p id="baae47f87c55b321b1a847755d5bd5a2" class="ne-p"><strong><span class="ne-text">如果一组进程中的每个进程都在等待一个事件，而这个事件只能由该组中的另一个进程触发，这种情况会导致死锁</span></strong><span class="ne-text">。</span></p><p id="cd3b049f801c785902aa2ee9f5537659" class="ne-p"><br></p><h3 id="a4ffc042"><span class="ne-text">资源死锁的条件</span></h3><p id="8cf2cde31de59698515b56ec5a49c581" class="ne-p"><br></p><p id="7bf9ec1a4e71c2362bc024c611a36dab" class="ne-p"><span class="ne-text">针对我们上面的描述，资源死锁可能出现的情况主要有</span></p><p id="d2965e8c80a02d9f6ae8ad4dd9741a6c" class="ne-p"><br></p><ul class="ne-ul"><li id="2461cac20ec655f2ce5216f716ed970d"><span class="ne-text">互斥条件：每个资源都被分配给了一个进程或者资源是可用的</span></li><li id="b59b3d4339b30dbbd1d4c840019f29fa"><span class="ne-text">保持和等待条件：已经获取资源的进程被认为能够获取新的资源</span></li></ul><ul class="ne-ul"><li id="c83defcb158380ae745008f1ce2e7b4b"><span class="ne-text">不可抢占条件：分配给一个进程的资源不能强制的从其他进程抢占资源，它只能由占有它的进程显示释放</span></li><li id="24871dfae1e4208085188d6d4dffdce3"><span class="ne-text">循环等待：死锁发生时，系统中一定有两个或者两个以上的进程组成一个循环，循环中的每个进程都在等待下一个进程释放的资源。</span></li></ul><p id="57e7bca96f378b5215fc1af485de28e6" class="ne-p"><br></p><p id="ec8baeee4c99e209781933e1f1514ea9" class="ne-p"><span class="ne-text">发生死锁时，上面的情况必须同时会发生。如果其中任意一个条件不会成立，死锁就不会发生。可以通过破坏其中任意一个条件来破坏死锁，下面这些破坏条件就是我们探讨的重点</span></p><p id="1df908aa8bf7935a457c9c552b0fea44" class="ne-p"><br></p><h3 id="2ba04a66"><span class="ne-text">死锁模型</span></h3><p id="a04f8c5e84de9684afc27ae414a6d779" class="ne-p"><br></p><p id="85b83d0ed4eb6aa01bc52b5c0e6916ca" class="ne-p"><span class="ne-text">Holt 在 1972 年提出对死锁进行建模，建模的标准如下：</span></p><p id="35efa46631e12a3613067329ef47eaa6" class="ne-p"><br></p><ul class="ne-ul"><li id="5c6ff301023c6b32a75add616a9f195a"><span class="ne-text">圆形表示进程</span></li><li id="8fd6eb48acae20dc5052e40e62d39242"><span class="ne-text">方形表示资源</span></li></ul><p id="76e680e1ac67826c1904b922f2508207" class="ne-p"><br></p><p id="0eb57a1be3e1c45d5a9d5d78b3855fb1" class="ne-p"><span class="ne-text">从资源节点到进程节点表示资源已经被进程占用，如下图所示</span></p><p id="59962074ed9fa78004d8f206555aeb1c" class="ne-p"><br></p><p id="e23a383dff53004dac74daaebfa5cf62" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830760-e22f0a74-94ab-4be7-9b39-3f611c32823a.png" width="331" id="BjL47" class="ne-image"></p><p id="0a2f8ae870c3bb8c95857ace4b4c3e73" class="ne-p"><br></p><p id="cdfcbee5b6e9b6948f037308db4d7622" class="ne-p"><span class="ne-text">在上图中表示当前资源 R 正在被 A 进程所占用</span></p><p id="67676b8c22e281f016c0d0b1e01204e0" class="ne-p"><br></p><p id="1fb8a54214e882e963e6db8825977fc4" class="ne-p"><span class="ne-text">由进程节点到资源节点的有向图表示当前进程正在请求资源，并且该进程已经被阻塞，处于等待这个资源的状态</span></p><p id="bb1747bacfa748ab9f5f396430510658" class="ne-p"><br></p><p id="53fdec97a470c1c990d4c19da34a87c2" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830813-2b57251b-055b-4664-b040-89f60d1d43c4.png" width="345" id="u51ZN" class="ne-image"></p><p id="fc7fcab5e87f8354278b202646ce6bb8" class="ne-p"><br></p><p id="2ca0e28dee5d52b527286b9f49dc14da" class="ne-p"><span class="ne-text">在上图中，表示的含义是进程 B 正在请求资源 S 。Holt 认为，死锁的描述应该如下</span></p><p id="3f72668bb9a949d52e87791eae34010b" class="ne-p"><br></p><p id="51082e3beb38f015ef3ac95212b138d2" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830811-a3afe75e-0c48-40b9-8fa4-e74d132d9b58.png" width="485" id="bhef4" class="ne-image"></p><p id="01f74cd30421be5cf72c44619b12477f" class="ne-p"><br></p><p id="01f565a83434d718c7ae59fd03de6811" class="ne-p"><span class="ne-text">这是一个死锁的过程，进程 C 等待资源 T 的释放，资源 T 却已经被进程 D 占用，进程 D 等待请求占用资源 U ，资源 U 却已经被线程 C 占用，从而形成环。</span></p><p id="b237901b2be04c14ea3abad0df23223c" class="ne-p"><br></p><p id="d3950d5ac640dba2723c9ce141487292" class="ne-p"><span class="ne-text">有四种处理死锁的策略：</span></p><p id="9c28eb93725ce1026b8e57cbdc9d884a" class="ne-p"><br></p><ul class="ne-ul"><li id="f02059d209937e043cc91b3202332b45"><span class="ne-text">忽略死锁带来的影响（惊呆了）</span></li><li id="7ed0ecd020c81e768cc3daddc64d269c"><span class="ne-text">检测死锁并回复死锁，死锁发生时对其进行检测，一旦发生死锁后，采取行动解决问题</span></li></ul><ul class="ne-ul"><li id="15d6f899a7a219f73c9f9c5d3d84284a"><span class="ne-text">通过仔细分配资源来避免死锁</span></li><li id="3480f5545cb59921ddc8cce5bb380e7e"><span class="ne-text">通过破坏死锁产生的四个条件之一来避免死锁</span></li></ul><p id="01bc1144b78631aef94e579fa8d1d912" class="ne-p"><br></p><p id="495a1907b5f77a040cb025c261a0dde9" class="ne-p"><span class="ne-text">下面我们分别介绍一下这四种方法</span></p><p id="364bc81ab84b40122e907de1d02cf761" class="ne-p"><br></p><h2 id="445e7ac3"><span class="ne-text">鸵鸟算法</span></h2><p id="036b75a65beb0a6e2c2ca45ebd1bf297" class="ne-p"><br></p><p id="e6043383dfd449422770da6892dcea16" class="ne-p"><span class="ne-text">最简单的解决办法就是使用</span><code class="ne-code"><span class="ne-text">鸵鸟算法(ostrich algorithm)</span></code><span class="ne-text">，把头埋在沙子里，假装问题根本没有发生。每个人看待这个问题的反应都不同。数学家认为死锁是不可接受的，必须通过有效的策略来防止死锁的产生。工程师想要知道问题发生的频次，系统因为其他原因崩溃的次数和死锁带来的严重后果。如果死锁发生的频次很低，而经常会由于硬件故障、编译器错误等其他操作系统问题导致系统崩溃，那么大多数工程师不会修复死锁。</span></p><p id="52f6db636d5ff751b26f95bdd338d289" class="ne-p"><br></p><h2 id="c34052de"><span class="ne-text">死锁检测和恢复</span></h2><p id="225135e8a2070f389de38812717eb75d" class="ne-p"><br></p><p id="f06571b2cb07e67da53eb1f9ae46f666" class="ne-p"><span class="ne-text">第二种技术是死锁的检测和恢复。这种解决方式不会尝试去阻止死锁的出现。相反，这种解决方案会希望死锁尽可能的出现，在监测到死锁出现后，对其进行恢复。下面我们就来探讨一下死锁的检测和恢复的几种方式</span></p><p id="14ee619ccacc077fbb0ab230f795ff08" class="ne-p"><br></p><h3 id="845b19bd"><span class="ne-text">每种类型一个资源的死锁检测方式</span></h3><p id="8856acadce3e4be26400996c75037a18" class="ne-p"><br></p><p id="1dce1bbff3adfcf55a761b49b459a9a9" class="ne-p"><span class="ne-text">每种资源类型都有一个资源是什么意思？我们经常提到的打印机就是这样的，资源只有打印机，但是设备都不会超过一个。</span></p><p id="7aa26a189549bf96df754b2f1ace77ae" class="ne-p"><br></p><p id="ae3dd6af307505c10b0eb562a80986f1" class="ne-p"><span class="ne-text">可以通过构造一张资源分配表来检测这种错误，比如我们上面提到的</span></p><p id="57bb0ac633cecdfa908fa75afa54cbdc" class="ne-p"><br></p><p id="ad5e4cd721b90f28101f2acd23afe3bb" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830848-f4bc59e7-89e2-4e78-909c-e8dcd1718ebe.png" width="475" id="TYPR7" class="ne-image"></p><p id="2745a826110fc96a2b6216f300175397" class="ne-p"><br></p><p id="32c152b4a1b42accb3ee8f73ca42fd9a" class="ne-p"><span class="ne-text">如果这张图包含了一个或一个以上的环，那么死锁就存在，处于这个环中任意一个进程都是死锁的进程。</span></p><p id="00db8fb2a967b493da00c952b7385bb2" class="ne-p"><br></p><h3 id="0e6d1847"><span class="ne-text">每种类型多个资源的死锁检测方式</span></h3><p id="feab24bd3b82d2799e2dac6d56957450" class="ne-p"><br></p><p id="8675e27ef21c4d6f4e3c390a9039463d" class="ne-p"><span class="ne-text">如果有多种相同的资源存在，就需要采用另一种方法来检测死锁。可以通过构造一个矩阵来检测从 P1 -&gt; Pn 这 n 个进程中的死锁。</span></p><p id="04fc31dd56db424542188c800706797c" class="ne-p"><br></p><p id="a24b641ae3e9651167024af87187bf28" class="ne-p"><span class="ne-text">现在我们提供一种基于矩阵的算法来检测从 P1 到 Pn 这 n 个进程中的死锁。假设资源类型为 m，E1 代表资源类型1，E2 表示资源类型 2 ，Ei 代表资源类型 i (1 &lt;= i &lt;= m)。E 表示的是 </span><code class="ne-code"><span class="ne-text">现有资源向量(existing resource vector)</span></code><span class="ne-text">，代表每种已存在的资源总数。</span></p><p id="9d26e86025397b8d6319268fa76a93a3" class="ne-p"><br></p><p id="41f401b08793431302caeb310f9f5076" class="ne-p"><span class="ne-text">现在我们就需要构造两个数组：C 表示的是</span><code class="ne-code"><span class="ne-text">当前分配矩阵(current allocation matrix)</span></code><span class="ne-text"> ，R 表示的是 </span><code class="ne-code"><span class="ne-text">请求矩阵(request matrix)</span></code><span class="ne-text">。Ci 表示的是 Pi 持有每一种类型资源的资源数。所以，Cij 表示 Pi 持有资源 j 的数量。Rij 表示 Pi 所需要获得的资源 j 的数量</span></p><p id="66cca3aac1c7c3a268bcf0cbe528756c" class="ne-p"><br></p><p id="92630dcca8243665dde0564f6c12e1cd" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830847-d4f0a077-7abd-4507-a720-337bc99b121e.png" width="686" id="JZ0fA" class="ne-image"></p><p id="56bc171dc0bf324243530e635d5bab68" class="ne-p"><br></p><p id="423bab2c70172066263bee3d30dad1f7" class="ne-p"><span class="ne-text">一般来说，已分配资源 j 的数量加起来再和所有可供使用的资源数相加 = 该类资源的总数。</span></p><p id="77aae0d262cefbaa04162ad431e28520" class="ne-p"><br></p><p id="6c93735bd020f34c0a7d4addc689ef08" class="ne-p"><span class="ne-text">死锁的检测就是基于向量的比较。每个进程起初都是没有被标记过的，算法会开始对进程做标记，进程被标记后说明进程被执行了，不会进入死锁，当算法结束时，任何没有被标记过的进程都会被判定为死锁进程。</span></p><p id="14e91ed8d03af86ca1b09968d2699d12" class="ne-p"><br></p><p id="124b222886574ccd5653fc831d93cb96" class="ne-p"><span class="ne-text">上面我们探讨了两种检测死锁的方式，那么现在你知道怎么检测后，你何时去做死锁检测呢？一般来说，有两个考量标准：</span></p><p id="1a40a355ed7a5a9fea8130b2e3e33388" class="ne-p"><br></p><ul class="ne-ul"><li id="ee8c565c1201d24a8441c6fbb77ece7b"><span class="ne-text">每当有资源请求时就去检测，这种方式会占用昂贵的 CPU 时间。</span></li><li id="afc8b082824e82774c1c3be31d74ac3e"><span class="ne-text">每隔 k 分钟检测一次，或者当 CPU 使用率降低到某个标准下去检测。考虑到 CPU 效率的原因，如果死锁进程达到一定数量，就没有多少进程可以运行，所以 CPU 会经常空闲。</span></li></ul><p id="6488c6772dd853d8292d2e105a388286" class="ne-p"><br></p><h3 id="95bdbdb5"><span class="ne-text">从死锁中恢复</span></h3><p id="a374c9f6b0536b99e76dc7d380d5ad4d" class="ne-p"><br></p><p id="6c6fa66bb994f4b13767e0758e7bc15b" class="ne-p"><span class="ne-text">上面我们探讨了如何检测进程死锁，我们最终的目的肯定是想让程序能够正常的运行下去，所以针对检测出来的死锁，我们要对其进行恢复，下面我们会探讨几种死锁的恢复方式</span></p><p id="17c663707ef8dd6df4ca3362d812f340" class="ne-p"><br></p><h4 id="82459936"><span class="ne-text">通过抢占进行恢复</span></h4><p id="8611e726a4b51bbc2a2a73b2584f2cf4" class="ne-p"><br></p><p id="b09a07bd4466a6494cae3cb7b5f3487c" class="ne-p"><span class="ne-text">在某些情况下，可能会临时将某个资源从它的持有者转移到另一个进程。比如在不通知原进程的情况下，将某个资源从进程中强制取走给其他进程使用，使用完后又送回。这种恢复方式一般比较困难而且有些简单粗暴，并不可取。</span></p><p id="9db11e547d3327df9fd8150582728d11" class="ne-p"><br></p><h4 id="48c12fe7"><span class="ne-text">通过回滚进行恢复</span></h4><p id="7c6c5b54d8c697c690324a6fa94cdf41" class="ne-p"><br></p><p id="718e20e97011e6148925c731421cd028" class="ne-p"><span class="ne-text">如果系统设计者和机器操作员知道有可能发生死锁，那么就可以定期检查流程。进程的检测点意味着进程的状态可以被写入到文件以便后面进行恢复。检测点不仅包含</span><code class="ne-code"><span class="ne-text">存储映像(memory image)</span></code><span class="ne-text">，还包含</span><code class="ne-code"><span class="ne-text">资源状态(resource state)</span></code><span class="ne-text">。一种更有效的解决方式是不要覆盖原有的检测点，而是每出现一个检测点都要把它写入到文件中，这样当进程执行时，就会有一系列的检查点文件被累积起来。</span></p><p id="339f29e4c95b23688e573aa6483a9909" class="ne-p"><br></p><p id="600363987ac3776bc472e109917d4090" class="ne-p"><span class="ne-text">为了进行恢复，要从上一个较早的检查点上开始，这样所需要资源的进程会回滚到上一个时间点，在这个时间点上，死锁进程还没有获取所需要的资源，可以在此时对其进行资源分配。</span></p><p id="2d8e54e18dce59911f57770e4ea8f824" class="ne-p"><br></p><h4 id="ec735624"><span class="ne-text">杀死进程恢复</span></h4><p id="b10cebb135de327c0a84909c0003ab1f" class="ne-p"><br></p><p id="1c29d7da30e23b9c755589852bb6efe3" class="ne-p"><span class="ne-text">最简单有效的解决方案是直接杀死一个死锁进程。但是杀死一个进程可能照样行不通，这时候就需要杀死别的资源进行恢复。</span></p><p id="4665eae3b27d917878b8ac71b95d7352" class="ne-p"><br></p><p id="b4068288f1099860bf4bef3010a9cc89" class="ne-p"><span class="ne-text">另外一种方式是选择一个环外的进程作为牺牲品来释放进程资源。</span></p><p id="1bb34cd91b0412e04dc1a611adbc6be6" class="ne-p"><br></p><h2 id="9f401114"><span class="ne-text">死锁避免</span></h2><p id="d96231a65e2b63d55b620a5f9679a5f5" class="ne-p"><br></p><p id="460e408b4f85f86b4fc5ffc9c3cabaaa" class="ne-p"><span class="ne-text">我们上面讨论的是如何检测出现死锁和如何恢复死锁，下面我们探讨几种规避死锁的方式</span></p><p id="e2769cc5a198cfa247c1b1e14580c945" class="ne-p"><br></p><h3 id="221804d8"><span class="ne-text">单个资源的银行家算法</span></h3><p id="e89b2e891d5b7f70257c4553152b1789" class="ne-p"><br></p><p id="59b8da1dc357e739ca2d3879ad6138c5" class="ne-p"><span class="ne-text">银行家算法是 Dijkstra 在 1965 年提出的一种调度算法，它本身是一种死锁的调度算法。它的模型是基于一个城镇中的银行家，银行家向城镇中的客户承诺了一定数量的贷款额度。算法要做的就是判断请求是否会进入一种不安全的状态。如果是，就拒绝请求，如果请求后系统是安全的，就接受该请求。</span></p><p id="41faefa6584da64f07618f4036a158d8" class="ne-p"><br></p><p id="7507faed5c63e725af97d762eaec96b0" class="ne-p"><span class="ne-text">类似的，还有多个资源的银行家算法，读者可以自行了解。</span></p><p id="c6c2f8962b34bd84d67b6adae75e4c47" class="ne-p"><br></p><h2 id="1c662b9c"><span class="ne-text">破坏死锁</span></h2><p id="1042b3632351757a6665bfb3b2cab55c" class="ne-p"><br></p><p id="614019792c2d83e0b74de617146216f2" class="ne-p"><span class="ne-text">死锁本质上是无法避免的，因为它需要获得未知的资源和请求，但是死锁是满足四个条件后才出现的，它们分别是</span></p><p id="342083631481cc21a58439f88448ba23" class="ne-p"><br></p><ul class="ne-ul"><li id="7f073eb63fdf3296f66785047892f3da"><span class="ne-text">互斥</span></li><li id="8ec9e0fc4c8a1ce01e825d8cb74487f5"><span class="ne-text">保持和等待</span></li></ul><ul class="ne-ul"><li id="3243ef42ffbe01b313da032f2182b94e"><span class="ne-text">不可抢占</span></li><li id="d45e0cad6dc74d87e3c08fec2ee0f8d8"><span class="ne-text">循环等待</span></li></ul><p id="fe59f031b5ed305654906780fa2edef6" class="ne-p"><br></p><p id="7177a34bdca01a41d03870d15ba1e6a8" class="ne-p"><span class="ne-text">我们分别对这四个条件进行讨论，按理说破坏其中的任意一个条件就能够破坏死锁</span></p><p id="c27bcda5e1b8bdec4067b11fcc6c05d8" class="ne-p"><br></p><h3 id="48c312fb"><span class="ne-text">破坏互斥条件</span></h3><p id="26613ade80fc258b9f36f537ecc823f0" class="ne-p"><br></p><p id="d10c8076c6a1afdc5be18d3da29045a0" class="ne-p"><span class="ne-text">我们首先考虑的就是</span><strong><span class="ne-text">破坏互斥使用条件</span></strong><span class="ne-text">。如果资源不被一个进程独占，那么死锁肯定不会产生。如果两个打印机同时使用一个资源会造成混乱，打印机的解决方式是使用 </span><code class="ne-code"><span class="ne-text">假脱机打印机(spooling printer)</span></code><span class="ne-text"> ，这项技术可以允许多个进程同时产生输出，在这种模型中，实际请求打印机的唯一进程是打印机守护进程，也称为后台进程。后台进程不会请求其他资源。我们可以消除打印机的死锁。</span></p><p id="0075a1624d67b11ba8d15ed77b0e1b7b" class="ne-p"><br></p><p id="4bf1551f195c5c46cf38ed105690a369" class="ne-p"><span class="ne-text">后台进程通常被编写为能够输出完整的文件后才能打印，假如两个进程都占用了假脱机空间的一半，而这两个进程都没有完成全部的输出，就会导致死锁。</span></p><p id="fa76008afa94ebc89b5a16b2f22cd27c" class="ne-p"><br></p><p id="4709a3f6c7bb8468e3d0556402b77cd3" class="ne-p"><span class="ne-text">因此，尽量做到尽可能少的进程可以请求资源。</span></p><p id="95cb9bb0e7f02afb35945ffbb03cb13b" class="ne-p"><br></p><h3 id="1ce8619b"><span class="ne-text">破坏保持等待的条件</span></h3><p id="a0402a5e468f049bcea75885f6bdb094" class="ne-p"><br></p><p id="59a68622dc4bdac082e2cf8505d3a8a3" class="ne-p"><span class="ne-text">第二种方式是如果我们能阻止持有资源的进程请求其他资源，我们就能够消除死锁。一种实现方式是让所有的进程开始执行前请求全部的资源。如果所需的资源可用，进程会完成资源的分配并运行到结束。如果有任何一个资源处于频繁分配的情况，那么没有分配到资源的进程就会等待。</span></p><p id="cc80a0d7d7adc5e15d896ab15932e1d9" class="ne-p"><br></p><p id="44f4b6bc44f660cc6ec2cb66a0dcab09" class="ne-p"><span class="ne-text">很多进程</span><strong><span class="ne-text">无法在执行完成前就知道到底需要多少资源</span></strong><span class="ne-text">，如果知道的话，就可以使用银行家算法；还有一个问题是这样</span><strong><span class="ne-text">无法合理有效利用资源</span></strong><span class="ne-text">。</span></p><p id="cb584b7d098165ccd9f854d4403c81a7" class="ne-p"><br></p><p id="e4c08e27eb55f0691ba9869f7d983987" class="ne-p"><span class="ne-text">还有一种方式是进程在请求其他资源时，先释放所占用的资源，然后再尝试一次获取全部的资源。</span></p><p id="b1b1836523c7189c11cdf7b4a834cab5" class="ne-p"><br></p><h3 id="d83055ce"><span class="ne-text">破坏不可抢占条件</span></h3><p id="83056be73110a576565be358f73dc447" class="ne-p"><br></p><p id="d095796526d11fc7b3a879f40f8b76af" class="ne-p"><span class="ne-text">破坏不可抢占条件也是可以的。可以通过虚拟化的方式来避免这种情况。</span></p><p id="595c68731aa3abbd5a09a8c780c2c6fb" class="ne-p"><br></p><h3 id="75513240"><span class="ne-text">破坏循环等待条件</span></h3><p id="2cce5860fcb20508493132ff4d52c8e7" class="ne-p"><br></p><p id="6bd78a1878c0b44133e8615952a7b6cd" class="ne-p"><span class="ne-text">现在就剩最后一个条件了，循环等待条件可以通过多种方法来破坏。一种方式是制定一个标准，一个进程在任何时候只能使用一种资源。如果需要另外一种资源，必须释放当前资源。对于需要将大文件从磁带复制到打印机的过程，此限制是不可接受的。</span></p><p id="3e6e2f47972b8cfddb751b8b98fd4e57" class="ne-p"><br></p><p id="ff2b35f6c8e9a28f1b38326659b83623" class="ne-p"><span class="ne-text">另一种方式是将所有的资源统一编号，如下图所示</span></p><p id="c009095ac315c19ae85c392536222bb8" class="ne-p"><br></p><p id="719cfd06171e090674e6588ea72e2514" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830860-d72b0344-264f-4bfe-91f7-43d5b4121f58.png" width="419" id="Nm5h1" class="ne-image"></p><p id="378b45679e11bbc4ae4cbb1bb07f051b" class="ne-p"><br></p><p id="4d406e8ec640206937c30f4f87d1e0df" class="ne-p"><span class="ne-text">进程可以在任何时间提出请求，但是所有的请求都必须按照资源的顺序提出。如果按照此分配规则的话，那么资源分配之间不会出现环。</span></p><p id="33a3a40e0e4503fb2a58f13489a613ad" class="ne-p"><br></p><p id="d0388e319759e7f357c45d4e95179c2e" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830858-19d66189-e808-4999-879e-3e2e8d4273f0.png" width="423" id="xulHt" class="ne-image"></p><p id="8c42c0e89584a6d912c13ee84ca0d1da" class="ne-p"><br></p><p id="998a94d4e63eda812da79b5f56e93eea" class="ne-p"><span class="ne-text">尽管通过这种方式来消除死锁，但是编号的顺序不可能让每个进程都会接受。</span></p><p id="65f5a9bf2b2f3359e44646086bf6db51" class="ne-p"><br></p><h2 id="bf52b411"><span class="ne-text">其他问题</span></h2><p id="3b41d963203b64c7498fc565603991b5" class="ne-p"><br></p><p id="d91adc7b4ff6e74ed3b09939b40132d8" class="ne-p"><span class="ne-text">下面我们来探讨一下其他问题，包括 </span><strong><span class="ne-text">通信死锁、活锁是什么、饥饿问题和两阶段加锁</span></strong></p><p id="48288ba7fbb610cf326cedc0d9f0f6d7" class="ne-p"><br></p><h3 id="e8230499"><span class="ne-text">两阶段加锁</span></h3><p id="1e34b78f13fa6ccb27f3e79ce5525ea9" class="ne-p"><br></p><p id="9a404aeba16fe407449e9620f8e60b5a" class="ne-p"><span class="ne-text">虽然很多情况下死锁的避免和预防都能处理，但是效果并不好。随着时间的推移，提出了很多优秀的算法用来处理死锁。例如在数据库系统中，一个经常发生的操作是请求锁住一些记录，然后更新所有锁定的记录。当同时有多个进程运行时，就会有死锁的风险。</span></p><p id="31bbdd311778f49d2f23e1b5f99582fb" class="ne-p"><br></p><p id="6a87b8d5f0df4dfddf9222397284816e" class="ne-p"><span class="ne-text">一种解决方式是使用 </span><code class="ne-code"><span class="ne-text">两阶段提交(two-phase locking)</span></code><span class="ne-text">。顾名思义分为两个阶段，一阶段是进程尝试一次锁定它需要的所有记录。如果成功后，才会开始第二阶段，第二阶段是执行更新并释放锁。第一阶段并不做真正有意义的工作。</span></p><p id="5b1b66cb117a5aa66675875203023dc1" class="ne-p"><br></p><p id="d0a72b442ed8f3bf7c655ddef2038559" class="ne-p"><span class="ne-text">如果在第一阶段某个进程所需要的记录已经被加锁，那么该进程会释放所有锁定的记录并重新开始第一阶段。从某种意义上来说，这种方法类似于预先请求所有必需的资源或者是在进行一些不可逆的操作之前请求所有的资源。</span></p><p id="6d0daef74b5849a82b735e9072ff2277" class="ne-p"><br></p><p id="40ca79e448a5b8410caca0b328fa6ae5" class="ne-p"><span class="ne-text">不过在一般的应用场景中，两阶段加锁的策略并不通用。如果一个进程缺少资源就会半途中断并重新开始的方式是不可接受的。</span></p><p id="a93254cb959a97f440ed888fe197b863" class="ne-p"><br></p><h3 id="44d2b9b0"><span class="ne-text">通信死锁</span></h3><p id="2130ade79d2e280cb7ddd6f93f606bae" class="ne-p"><br></p><p id="64776094a4eeb9c963f8960bfdd20280" class="ne-p"><span class="ne-text">我们上面一直讨论的是资源死锁，资源死锁是一种死锁类型，但并不是唯一类型，还有通信死锁，也就是两个或多个进程在发送消息时出现的死锁。进程 A 给进程 B 发了一条消息，然后进程 A 阻塞直到进程 B 返回响应。假设请求消息丢失了，那么进程 A 在一直等着回复，进程 B 也会阻塞等待请求消息到来，这时候就产生</span><code class="ne-code"><span class="ne-text">死锁</span></code><span class="ne-text">。</span></p><p id="7b2dca72612d5432be0e4378ee44b636" class="ne-p"><br></p><p id="40989330fbee6643a7ebeab9d1b7f7e8" class="ne-p"><span class="ne-text">尽管会产生死锁，但是这并不是一个资源死锁，因为 A 并没有占据 B 的资源。事实上，通信死锁并没有完全可见的资源。根据死锁的定义来说：每个进程因为等待其他进程引起的事件而产生阻塞，这就是一种死锁。相较于最常见的通信死锁，我们把上面这种情况称为</span><code class="ne-code"><span class="ne-text">通信死锁(communication deadlock)</span></code><span class="ne-text">。</span></p><p id="0cde873bd73f03c66e1e81dfabb9ecff" class="ne-p"><br></p><p id="14dbb722a2f2fd6709732ca83eedd397" class="ne-p"><span class="ne-text">通信死锁不能通过调度的方式来避免，但是可以使用通信中一个非常重要的概念来避免：</span><code class="ne-code"><span class="ne-text">超时(timeout)</span></code><span class="ne-text">。在通信过程中，只要一个信息被发出后，发送者就会启动一个定时器，定时器会记录消息的超时时间，如果超时时间到了但是消息还没有返回，就会认为消息已经丢失并重新发送，通过这种方式，可以避免通信死锁。</span></p><p id="05e534c4b272054adbc3e743bbb87ed5" class="ne-p"><br></p><p id="ebad5559c5e8228b7c32bd7e22a53fcc" class="ne-p"><span class="ne-text">但是并非所有网络通信发生的死锁都是通信死锁，也存在资源死锁，下面就是一个典型的资源死锁。</span></p><p id="43db3302928da79ca9d4847a52057335" class="ne-p"><br></p><p id="d2066eecb8a130f79bde31d4bc952698" class="ne-p"><span class="ne-text">当一个数据包从主机进入路由器时，会被放入一个缓冲区，然后再传输到另外一个路由器，再到另一个，以此类推直到目的地。缓冲区都是资源并且数量有限。如下图所示，每个路由器都有 10 个缓冲区（实际上有很多）。</span></p><p id="fd8d6b4496f962959fbda6d31e8fe14a" class="ne-p"><br></p><p id="4605b8d7affea0247962f50ca34605a0" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830887-98d92f9c-72d1-4710-a487-1bd4dc953b7c.png" width="702" id="JN6QA" class="ne-image"></p><p id="3cc175c53ce850923dd266c70fa2d2da" class="ne-p"><br></p><p id="404a0deda9c033b83ccdd5f1e1085499" class="ne-p"><span class="ne-text">假如路由器 A 的所有数据需要发送到 B ，B 的所有数据包需要发送到 D，然后 D 的所有数据包需要发送到 A 。没有数据包可以移动，因为在另一端没有缓冲区可用，这就是一个典型的资源死锁。</span></p><p id="c619f7fb9d739d143fbd13aed16af5e1" class="ne-p"><br></p><h3 id="94c14e72"><span class="ne-text">活锁</span></h3><p id="d58bf9c2b4a5f6bbecbf4b7136473e80" class="ne-p"><br></p><p id="4cf25a1c790a47e1298e729b06421709" class="ne-p"><span class="ne-text">某些情况下，当进程意识到它不能获取所需要的下一个锁时，就会尝试礼貌的释放已经获得的锁，然后等待非常短的时间再次尝试获取。可以想像一下这个场景：当两个人在狭路相逢的时候，都想给对方让路，相同的步调会导致双方都无法前进。</span></p><p id="65625d90055aa1173e9f493729a8a70a" class="ne-p"><br></p><p id="38424978488c1ad9578cd5c604bd379c" class="ne-p"><span class="ne-text">现在假想有一对并行的进程用到了两个资源。它们分别尝试获取另一个锁失败后，两个进程都会释放自己持有的锁，再次进行尝试，这个过程会一直进行重复。很明显，这个过程中没有进程阻塞，但是进程仍然不会向下执行，这种状况我们称之为 </span><code class="ne-code"><span class="ne-text">活锁(livelock)</span></code><span class="ne-text">。</span></p><p id="2772a3ba2c19ab0d95902ec3f6f3fc3d" class="ne-p"><br></p><h3 id="48073fce"><span class="ne-text">饥饿</span></h3><p id="d44dc6d0b955b9b3194082ba392239a7" class="ne-p"><br></p><p id="d089c608be88bd00f0435afcf9fedf5b" class="ne-p"><span class="ne-text">与死锁和活锁的一个非常相似的问题是 </span><code class="ne-code"><span class="ne-text">饥饿(starvvation)</span></code><span class="ne-text">。想象一下你什么时候会饿？一段时间不吃东西是不是会饿？对于进程来讲，最重要的就是资源，如果一段时间没有获得资源，那么进程会产生饥饿，这些进程会永远得不到服务。</span></p><p id="2cbb310b9cbe820deb2a9140fd73b7b2" class="ne-p"><br></p><p id="2ae27778a42bd6691929243288b93f65" class="ne-p"><span class="ne-text">我们假设打印机的分配方案是每次都会分配给最小文件的进程，那么要打印大文件的进程会永远得不到服务，导致进程饥饿，进程会无限制的推后，虽然它没有阻塞。</span></p><p id="31731cb931d8de3f4bb18fd8da9bc111" class="ne-p"><br></p></div>]]></content>
      
      
      <categories>
          
          <category> 计算机素养 </category>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>常用软件快捷键/CMD/Linux命令及其他使用</title>
      <link href="/blog/nvlr2g/"/>
      <url>/blog/nvlr2g/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="ue27923e8" class="ne-p"><span class="ne-text">做个记录</span></p><h2 id="3bd7297d"><span class="ne-text">一、软件常用快捷键</span></h2><h3 id="399b57eb"><span class="ne-text">Win10 快捷键</span></h3><pre><code>Win+E                  打开文件管器Win+D                  显示桌面Win+L                  锁计算机Win+V：                                打开剪贴板Win+PgUp：                            在桌面选定左上角软件/文件Win+PgDown：                        在桌面选定右下角软件/文件Win+G                                    录频选项Win+alt+G                            直接录频<p>alt+F4                关闭当前程序</p><p>ctrl+shift+Esc/ctrl+alt+delete：任务管理器<br>ctrl+F                文本或网页中查找（退出一般按ESC）<br>ctrl+A                选中所有文本<br></code></pre></p><p id="120c3ff4f439846cb54943848d15bdf3" class="ne-p"><br></p><h3 id="b2eab411"><span class="ne-text">Eclipse快捷键</span></h3><div class="ne-quote"><p id="bdea73380976670588d1c1baf02f4001" class="ne-p"><span class="ne-text">ctrl+shift+L：eclipse所有快捷键</span></p><p id="e77ac893d4ee87f990183fa01fe086f0" class="ne-p"><code class="ne-code"><span class="ne-text">//</span></code><span class="ne-text">注释：</span><code class="ne-code"><span class="ne-text">ctrl+shift+c</span></code><span class="ne-text">（添加和注释都是这样）或者</span><code class="ne-code"><span class="ne-text">ctrl+/</span></code></p><p id="8a9accc05689f8bfb9fad31f64c81aa3" class="ne-p"><code class="ne-code"><span class="ne-text">/**/</span></code><span class="ne-text">注释：添加</span><code class="ne-code"><span class="ne-text">ctrl+shift+/</span></code><span class="ne-text">  取消</span><code class="ne-code"><span class="ne-text">ctrl+shift+\</span></code></p></div><pre><code>Alt+方向键：                    将当前行向上或者向下移动ctrl+m：                            编辑窗口最大化（反复两次按即取消）ctrl+.及ctrl+1：            下一个错误及快速修改Control+O:                         快速概要,迅速的跳到一个方法或者属性，只需要输入名字的头几个字母。<p>shift+home/end：                选中一行<br>ctrl+pgup/pgdn：                切换页面（浏览器打开的页面/编辑器的多窗口）<br></code></pre></p><h3 id="c7b2cf8d"><span class="ne-text">Pycharm/JetBrains快捷键</span></h3><p id="52fabd9b70e7e013ac8cbe059e06a00a" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685666000-0fb595f1-51e4-4e71-8547-96aa0b938148.png" width="769" id="E0vxq" class="ne-image"></p><pre><code>Ctrl+F5（左上角）：（return &quot;project&quot;）重新debug该文件F9：（resume program）一个断点接着一个断点走，不按行走（eg：有循环会随着i一步一步走完）F8：（step over） 一行一行走代码F7：（step into） 进入函数内部Alt+shift+F7：（step into mycode）遇到自己函数  进去 shift+F8：（step out）跳出，进入函数后，跳出来Alt+F10：（show execution point）指针显示当前断点旁边**Show Python Prompt**按键,交互式调试命令</code></pre><h3 id="PnNOu"><span class="ne-text">VScode快捷键</span></h3><pre><code># 直接进入当前所打开的根目录下的CMD模式ctrl+shift+c</code></pre><h2 id="eefb7855"><span class="ne-text">二、CMD</span></h2><h3 id="LFTlM"><span class="ne-text">CMD常用命令</span></h3><div class="ne-quote"><ul class="ne-ul"><li id="3927602bd1d02818e3e89a51366cbb5b"><span class="ne-text">使用help命令，查看所有的dos命令</span></li><li id="405c3b81ee6e46975e66f0e5eed1aa11"><span class="ne-text">找到命令之后，使用 </span><code class="ne-code"><span class="ne-text">命令+ /?</span></code><span class="ne-text">来查看该命令下的其他属性</span></li></ul><ul class="ne-ul"><li id="e839e8cc93799c32b2f20c32f402ea29"><span class="ne-text">DOS不区分大小写</span></li></ul></div><h4 id="JCesk"><span class="ne-text">磁盘/文件夹相关</span></h4><ul class="ne-ul"><li id="607f926ccbd45ff934a3e5f8a07cb96a"><code class="ne-code"><span class="ne-text">d:</span></code><span class="ne-text"> </span><code class="ne-code"><span class="ne-text">e:</span></code><span class="ne-text"> 进入不同的盘</span></li><li id="f24e27509e75be8e22d5e375f5afbcd1"><code class="ne-code"><span class="ne-text">cd:</span></code><span class="ne-text"> 进入指定文件夹。注意：只在</span><strong><span class="ne-text">该磁盘</span></strong><span class="ne-text">才有效</span></li><li id="98cb68c4fd4a942a202c393f7edbe350"><code class="ne-code"><span class="ne-text">dir</span></code><span class="ne-text"> 查看当前目录下的所有文件，使用dir /?来查看其它用法</span></li><li id="6a436e74487058fc6747427d0de3ffd6"><span class="ne-text">创建和删除目录</span></li></ul><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="ff4f4590f077283b4870ee44e92b03fc"><span class="ne-text">md 目录名（文件夹） </span><span class="ne-text">//创建目录</span></li><li id="b1f1dac5d108c5728debfd53a6ce7705"><span class="ne-text">rd  目录名（文件夹） </span><span class="ne-text">//删除目录</span></li></ul></ul><ul class="ne-ul"><li id="41821c16d653fc8b39a699233d31ca04"><span class="ne-text">cd .. 返回上一级文件夹</span></li><li id="3379e065628f52d97723f5835629e225"><span class="ne-text">复制文件:把一个文件移动（就是剪切+复制）到另一个地方。甚至可以改后缀</span></li></ul><div class="ne-quote"><p id="a9ca862d00fc1faa5816fa47652feaa2" class="ne-p"><span class="ne-text">move 路径\文件名 路径\文件名</span></p></div><ul class="ne-ul"><li id="38f3c541c1d41b303e573455b25d7487"><strong><span class="ne-text">删除文件</span></strong></li></ul><pre><code>del test.txt</code></pre><ul class="ne-ul"><li id="u2b4eb7dd"><strong><span class="ne-text">CMD删除文件夹</span></strong></li></ul><pre><code>rd /s /q 文件夹名</code></pre><ul class="ne-ul"><li id="a84adc927449bb651dfb28fbaf74ee8f"><span class="ne-text">生成文件树</span></li></ul><div class="ne-quote"><p id="93a677d01b8d7e0448e73d7ad489c53c" class="ne-p"><code class="ne-code"><span class="ne-text">tree /f &gt;tree.txt</span></code></p></div><h4 id="DB59p"><span class="ne-text">网络相关</span></h4><ul class="ne-ul"><li id="c9b75a1d8666a2eb9c60654387d6cdd0"><code class="ne-code"><span class="ne-text">ipconfig</span></code><span class="ne-text"> 查看本机ip</span></li><li id="c1b345eb7de3b34cea40a5b668da465f"><code class="ne-code"><span class="ne-text">cls</span></code><span class="ne-text"> 清除屏幕</span></li><li id="c57415e85f061abd7fba07deb50d9f46"><code class="ne-code"><span class="ne-text">ping</span></code></li></ul><div class="ne-quote"><p id="02b3d39ce6cb7f3bec6d34070a32eab6" class="ne-p"><span class="ne-text">用来测试网络是否畅通</span></p><p id="88183e1ede157761a06b4fab6a155521" class="ne-p"><span class="ne-text">ping ip(主机名)</span></p></div><h4 id="UuVoa"><span class="ne-text">其他</span></h4><ul class="ne-ul"><li id="5de76c56311d77dae27e4209e256112d"><span class="ne-text">在文件夹空白处按住Shift，然后右键弹出快捷菜单，可以看到“在此处打开命令行窗口”</span></li><li id="d0b302a20a4ff3b4a5dfca0e1c2ed896"><span class="ne-text">tab补齐功能！！！</span></li><li id="af6260a701b9561e8fb82946b116dec5"><span class="ne-text">文件及目录名中不能包含下列任何字符：\ / : * ? &quot; &lt; &gt; |</span></li></ul><h3 id="rXY8a"><span class="ne-text">CMD默认非utf-8编码解决方案</span></h3><p id="cafac0cfae4cb6139cd7ec8cc0616f39" class="ne-p"><span class="ne-text">报错：运行java程序时候，如果代码中有中文，会出现中文报错乱码情况/</span></p><ul class="ne-ul"><li id="ua4a38aac"><span class="ne-text">方法一：治标方法</span></li></ul><p id="1452111825f1976fd75cfb28b796321b" class="ne-p"><code class="ne-code"><span class="ne-text">CMD</span></code><span class="ne-text"> 中输入 </span><code class="ne-code"><span class="ne-text">chcp 65001</span></code><span class="ne-text"> 进入utf-8模式下的的控制台，再运行程序</span></p><p id="2e94b2cc5f26755152af55f3cf305ddb" class="ne-p"><br></p><ul class="ne-ul"><li id="ub582005a"><span class="ne-text">方法二：治本方法</span></li></ul><p id="f8b4ae39f36b35f5f1f4d1e8c2e0d92a" class="ne-p"><span class="ne-text">注意：自己已经再注册表中增加了一行tuf-8编码数据，以后要留意、</span></p><p id="a27e189914f7580368424b96593c879c" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685666566-625a520c-ff9d-4eea-8fba-3a8c4f8f696e.png" width="660" id="SsvdB" class="ne-image"></p><p id="ufb328a5e" class="ne-p"><span class="ne-text">参考：</span></p><ul class="ne-ul"><li id="uce8d5854"><span class="ne-text"></span><a href="https://blog.csdn.net/gulang03/article/details/81771343" data-href="https://blog.csdn.net/gulang03/article/details/81771343" target="_blank" class="ne-link"><span class="ne-text">修改 cmd 控制台默认代码页编码的几种方法【GBK、UTF-8】</span></a><span class="ne-text">  </span></li><li id="u65364600"><span class="ne-text"></span><a href="https://blog.csdn.net/runAndRun/article/details/103072938" data-href="https://blog.csdn.net/runAndRun/article/details/103072938" target="_blank" class="ne-link"><span class="ne-text">windows 控制台 cmd/PowerShell 中文显示乱码，解决方法</span></a></li></ul><p id="605fe6b12178050bbb69ae94a2652acc" class="ne-p"><br></p><h3 id="K0ElO"><span class="ne-text">CMD运行JAVA文件</span></h3><h4 id="jukMj"><span class="ne-text">CMD运行java程序</span></h4><p id="07bc59222091968043ea5c856bdd5014" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685666652-cb97d69b-664c-4506-a24f-1dc5b8220a02.png" width="902" id="B6IyR" class="ne-image"></p><h4 id="JDJ2n"><span class="ne-text">命令行参数</span></h4><p id="5a84f710a699b7b629244cf6c93a312f" class="ne-p"><br></p><ul class="ne-ul"><li id="ue1c1cdb7"><span class="ne-text">main主函数可以看成一个普通的方法，也可以传递实参来调用普通方法</span></li></ul><p id="a08a7fb3ab5ef55915a0df01870af9aa" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685666759-75d2a062-c52d-4c49-acce-7310a0280f24.png" width="455" id="T7PKm" class="ne-image"></p><p id="u2debd83c" class="ne-p"><br></p><ul class="ne-ul"><li id="u624b28c4"><span class="ne-text">向main方法传递字符串</span></li></ul><p id="u9235dd32" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685666878-98ce351e-4485-4381-bcfe-4b9121226fc9.png" width="292" id="PYoCa" class="ne-image"></p><p id="ed07c459310efec65b0d30d169a54ecf" class="ne-p"><br></p><h4 id="YcFdg"><span class="ne-text">CMD下运行Java中文乱码</span></h4><p id="69cd2d33791350065c0ba63567786f57" class="ne-p"><code class="ne-code"><span class="ne-text">javac -encoding utf-8 test.java</span></code></p><p id="a333b05d84ff6f30ef36975eaba24097" class="ne-p"><span class="ne-text">还是上面的问题，DOS默认使用的编码是GBK,这里需要再编译的时候制定使用的编码</span></p><h2 id="u5wpj"><span class="ne-text">三、Linux</span></h2><h3 id="glaz1"><span class="ne-text">cat命令</span></h3><p id="uf5ee9737" class="ne-p"><span class="ne-text">查看CentOS版本：</span></p><pre><code>cat /etc/redhat-release</code></pre><p id="u5ca36bee" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1643018844135-441f0c04-500b-4dd4-97a3-d11edc72cae3.png" width="366" id="Q1RIE" class="ne-image"></p><p id="uc2252afe" class="ne-p"><span class="ne-text">在此可以去学习Linux相关命令，如果只是用xshell不适用其他软件，那么linux的使用很重要</span></p><h3 id="YEMJR"><span class="ne-text">yum 命令</span></h3><p id="uad7448a3" class="ne-p"><span class="ne-text">Linux yum 命令参考：</span><a href="https://www.runoob.com/linux/linux-yum.html" data-href="https://www.runoob.com/linux/linux-yum.html" target="_blank" class="ne-link"><span class="ne-text">https://www.runoob.com/linux/linux-yum.html</span></a></p><div class="ne-quote"><p id="u893049a5" class="ne-p"><span class="ne-text">是一个终端的前端软件包管理器</span></p></div><p id="uf4a649de" class="ne-p"><span class="ne-text">更新CentOS版本：</span></p><pre><code>yum -y update</code></pre><h3 id="oKFc9"><span class="ne-text">Bash Shell</span></h3><p id="u8b657891" class="ne-p"><span class="ne-text">bash是Linux默认shell</span></p><h4 id="DqgWm"><span class="ne-text">文件夹相关</span></h4><ul class="ne-ul"><li id="u4d9cb2a1"><span class="ne-text">复制文件夹</span></li></ul><pre><code>cp  -r  ./js/  ./backup/</code></pre><ul class="ne-ul"><li id="ubde5f35c"><span class="ne-text">移动文件夹</span></li></ul><pre><code>mv  visualization/  -f  .github_pages/</code></pre><ul class="ne-ul"><li id="u065b5014"><span class="ne-text">删除文件夹</span></li></ul><pre><code>rm  -r  .git</code></pre><p id="u86342d99" class="ne-p"><br></p><p id="u47193685" class="ne-p"><br></p><p id="u68c50299" class="ne-p"><br></p><p id="u8f6b646b" class="ne-p"><br></p></div>]]></content>
      
      
      <categories>
          
          <category> 计算机素养 </category>
          
          <category> 工具使用 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Jupyter使用总结</title>
      <link href="/blog/ouipza/"/>
      <url>/blog/ouipza/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content-editor-core lake-engine lake-typography-classic" data-lake-element="root" data-selection-undefined="%7B%22path%22%3A%5B%5B0%2C0%2C0%5D%2C%5B0%2C0%2C0%5D%5D%2C%22active%22%3Atrue%7D"><h2 data-lake-id="56ba6a2aadcb3630c55544debb007a72" id="buLMf" style="padding: 7px 0px; margin: 0px; font-weight: 700; font-size: 24px; line-height: 32px;">一、Jupyter环境的搭建</h2><ol start="1" data-lake-id="40fa4ba87608aa8e704716aabb4154c9" lake-indent="0" style="list-style-type: decimal; margin: 0px; padding-left: 23px; font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word;"><li data-lake-id="a01b2ca87d4d3df7fc74dd1df2d58a62">pip下载</li><li data-lake-id="f082b39258209d6b76215f87aff2b5b1">跟随anaconda下载</li></ol><h2 id="416a4b37" data-lake-id="bf37cba4da19cfb76cdb6df28a5cd8b8" style="padding: 7px 0px; margin: 0px; font-weight: 700; font-size: 24px; line-height: 32px;">二、高效使用，安装扩展插件</h2><p data-lake-id="c9e3c37f9d7768bffc93951055eafb5e" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="32347bdf3fa90460c3fa3cfdf936809f" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">一般只需要下面两条命令，就可以重新打开就可看见新安装的插件环境。</p><p data-lake-id="732f0645a831af474306b8fb57c33f1f" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="f8e24e384b337503d7d273a85a5a79f9" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><code style="font-family: monospace; font-size: inherit; background-color: rgba(0, 0, 0, 0.06); padding: 0px 2px; border: 1px solid rgba(0, 0, 0, 0.08); border-radius: 2px; line-height: inherit; overflow-wrap: break-word; text-indent: 0px;">pip install jupyter_contrib_nbextensions</code></p><p data-lake-id="9919269fc924edd9519b6e188c76b5c7" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="1751a12d41007ec962b0877ae0bbc405" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">或者</p><p data-lake-id="6e5cb1089e09787c400381bb39a136af" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="ecfe4f64833f809ac16bf66ad8f36539" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><code style="font-family: monospace; font-size: inherit; background-color: rgba(0, 0, 0, 0.06); padding: 0px 2px; border: 1px solid rgba(0, 0, 0, 0.08); border-radius: 2px; line-height: inherit; overflow-wrap: break-word; text-indent: 0px;">jupyter contrib nbextension install</code></p><p data-lake-id="24f41e0a6ec74af298a89bff9c8b7272" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="392b8fb1344b016d9cef2fa505e39386" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">但是pip下载完，会出现jupyter_contrib_nbextension扩展功能后不显示Nbextensions标签的bug，在此记录下解决的方式。</p><p data-lake-id="c154a1dbdc5e89aeca3978a73887a22f" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><h2 id="a0cd3a84" data-lake-id="be67711a150e8eaa72d1e320417eac73" style="padding: 7px 0px; margin: 0px; font-weight: 700; font-size: 24px; line-height: 32px;">三、扩展插件不显示的解决方法</h2><ol start="1" data-lake-id="fb6a9f3c8ab172db73e2aef993d8ced4" lake-indent="0" style="list-style-type: decimal; margin: 0px; padding-left: 23px; font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word;"><li data-lake-id="4a187725778ef6d8905618c889e5ee33">如果之前已经用上述两条命令之一安装了上述包，且用pip list查看的确成功安装，则依次进行下面删除命令（选y）:<br><code style="font-family: monospace; font-size: inherit; background-color: rgba(0, 0, 0, 0.06); padding: 0px 2px; border: 1px solid rgba(0, 0, 0, 0.08); border-radius: 2px; line-height: inherit; overflow-wrap: break-word; text-indent: 0px;">pip uninstall jupyter_contrib_nbextensions</code><br><code style="font-family: monospace; font-size: inherit; background-color: rgba(0, 0, 0, 0.06); padding: 0px 2px; border: 1px solid rgba(0, 0, 0, 0.08); border-radius: 2px; line-height: inherit; overflow-wrap: break-word; text-indent: 0px;">pip uninstall jupyter_nbextensions_configurator</code></li><li data-lake-id="a83d952c0523d604251e3f5c66d2d920">打开Anaconda Prompt窗口，执行第一个命令，用于安装nbextensions:<br><code style="font-family: monospace; font-size: inherit; background-color: rgba(0, 0, 0, 0.06); padding: 0px 2px; border: 1px solid rgba(0, 0, 0, 0.08); border-radius: 2px; line-height: inherit; overflow-wrap: break-word; text-indent: 0px;">pip install jupyter_contrib_nbextensions</code></li><li data-lake-id="4f8650666c7d618e826b11abab8e47b2">再执行第下面命令，用于安装 javascript and css files:<br><code style="font-family: monospace; font-size: inherit; background-color: rgba(0, 0, 0, 0.06); padding: 0px 2px; border: 1px solid rgba(0, 0, 0, 0.08); border-radius: 2px; line-height: inherit; overflow-wrap: break-word; text-indent: 0px;">jupyter contrib nbextension install --user</code></li><li data-lake-id="dc49571735d62404e28b3529dccff553">最后执行，用于安装configurator:<br><code style="font-family: monospace; font-size: inherit; background-color: rgba(0, 0, 0, 0.06); padding: 0px 2px; border: 1px solid rgba(0, 0, 0, 0.08); border-radius: 2px; line-height: inherit; overflow-wrap: break-word; text-indent: 0px;">pip install jupyter_nbextensions_configurator</code></li></ol><p data-lake-id="1cb9391eb292bce0ca353a387e40781c" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><h2 id="d17a0f0b" data-lake-id="4a9c3bd7a0e4d6a5d575ee115fc72bd1" style="padding: 7px 0px; margin: 0px; font-weight: 700; font-size: 24px; line-height: 32px;">参考</h2><ul data-lake-id="6979e188c8b503b2b577ebb51cf921b5" lake-indent="0" style="list-style-type: disc; margin: 0px; padding-left: 23px; font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word;"><li data-lake-id="29eaa12b9c8445118a8e100e8ea3dceb"><a href="https://www.jiqizhixin.com/articles/2018-12-20-12" target="_blank">五个常用插件 - 简书</a></li><li data-lake-id="91b347d7e1b074a113a0af62adbbbad7"><a href="https://www.zhihu.com/question/59392251/answer/560977151" target="_blank">如何优雅地使用 Jupyter？ - 量子位的回答 - 知乎</a></li><li data-lake-id="37018b913cede6b141d38ddb221a577c"><a href="https://blog.csdn.net/xiaodongxiexie/article/details/54633183" target="_blank">jupyter使用技巧</a></li></ul></div>]]></content>
      
      
      <categories>
          
          <category> 计算机素养 </category>
          
          <category> 工具使用 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>配置java开发环境</title>
      <link href="/blog/cwqx6l/"/>
      <url>/blog/cwqx6l/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h2 id="WJsSs"><span class="ne-text">一、下载</span></h2><p id="94772b8776b4506a079808b9228b9c9c" class="ne-p"><a href="https://www.oracle.com/cn/java/technologies/javase-downloads.html" data-href="https://www.oracle.com/cn/java/technologies/javase-downloads.html" target="_blank" class="ne-link"><span class="ne-text">https://www.oracle.com/cn/java/technologies/javase-downloads.html</span></a></p><h2 id="bee77271"><span class="ne-text">二、环境变量配置</span></h2><p id="f886bb5195ea880247108a59eb8e2b6e" class="ne-p"><br></p><p id="f1d5d1261b875f365fc36f6be911a261" class="ne-p"><strong><span class="ne-text">在系统变量下</span></strong></p><h3 id="CLASSPATH"><span class="ne-text">CLASSPATH</span></h3><p id="71a2668cb130c53f0fe8d76a38047dac" class="ne-p"><br></p><div class="ne-quote"><p id="035722a81469fb0db03ac69dc6c54600" class="ne-p"><span class="ne-text">.;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar;%CATALINA_HOME%\common\lib\servlet-api.jar;</span></p></div><p id="677a6fedc7a89dfa14cec6fe3e1ef35d" class="ne-p"><br></p><p id="f80a605c210254a888b22a01def5ccbf" class="ne-p"><span class="ne-text">其中</span><code class="ne-code"><span class="ne-text">%CATALINA_HOME%\common\lib\servlet-api.jar;</span></code><span class="ne-text">为tomcat的加包配置</span></p><p id="6a9ee80a570cb539d084e9a6898da2d2" class="ne-p"><br></p><h3 id="JAVA_HOME"><span class="ne-text">JAVA_HOME</span></h3><p id="e32350bfb5757a8d058339b41dd956fa" class="ne-p"><br></p><div class="ne-quote"><p id="7b87dce1888ff435832173cdf57f39ec" class="ne-p"><span class="ne-text">C:\Program Files\Java\jdk1.8.0_181</span></p></div><p id="e1c7994756c1a755c19bd9d0edccdb36" class="ne-p"><br></p><h3 id="path"><span class="ne-text">path</span></h3><p id="1e2011831fa3a492ec008f7223d4883f" class="ne-p"><br></p><div class="ne-quote"><p id="6bf05e9fbf30409695a41940b299fd35" class="ne-p"><span class="ne-text">%JAVA_HOME%\bin</span></p><p id="e537226076a33a8f21c8f7ea442b963f" class="ne-p"><span class="ne-text">%JAVA_HOME%\jre\bin</span></p></div><p id="61299833e917408aa80c4bc2cafc883c" class="ne-p"><br></p><h2 id="f01972f5"><span class="ne-text">三、测试</span></h2><p id="3be498e236daeb86f2b232624a6b7cbf" class="ne-p"><br></p><p id="d0d6e7019cd6ca595dd20974fcbb508c" class="ne-p"><span class="ne-text">CMD下输入</span><code class="ne-code"><span class="ne-text">java -version</span></code></p></div>]]></content>
      
      
      <categories>
          
          <category> 计算机素养 </category>
          
          <category> 环境搭建 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Pycharm,Anaconda,JetBrains系列app相关总结</title>
      <link href="/blog/mv7tir/"/>
      <url>/blog/mv7tir/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h2 id="ndOrX"><span class="ne-text">一、Anaconda和Pycharm下载与配置</span></h2><h3 id="09d85f5c"><span class="ne-text">下载Anaconda且配置</span></h3><ul class="ne-ul"><li id="5b583420df7679ff7fe5d8d3a223aa47"><span class="ne-text">（更新）下载了anaconda就不要单独下载python，之前下的也删掉，以此避免路径冲突</span></li><li id="521f6e7f65f820fd63c96665ccee3a21"><span class="ne-text">方式一：</span><strong><span class="ne-text">迅雷下载</span></strong><span class="ne-text">（推荐）；方式二：提取链接</span><strong><span class="ne-text">网盘下载</span></strong><span class="ne-text">；方式三：清华镜像下载，下载完安装【直接next即可】</span></li></ul><ul start="3" class="ne-ul"><li id="d0f5d7fd01611a5ca208d65e3265dce6"><strong><span class="ne-text">测试</span></strong><span class="ne-text">：</span><code class="ne-code"><span class="ne-text">win + R</span></code><span class="ne-text"> 进入终端输入</span><code class="ne-code"><span class="ne-text">conda</span></code><span class="ne-text">出现conda命令使用指南，即证明成功安装</span></li><li id="421b7a496e3fb30a523eb33868861881"><strong><span class="ne-text">配置环境变量</span></strong><span class="ne-text">：在</span><strong><span class="ne-text">系统变量</span></strong><span class="ne-text">path路径中加入下面配置（具体路径具体填写）</span></li></ul><p id="f5302e4b4d6949a4f63740c1de14cbb1" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1606634508207-8eb4dda2-6dbe-4162-b7eb-93cc5b35dc0e.png" width="296" id="oIosg" class="ne-image"></p><p id="cd71b789b6e9ce7a7294133a080076e1" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1606634439956-bfa830a0-ece9-4caa-9bf7-641b14dafd70.png" width="322.5" id="v6rw7" class="ne-image"></p><h3 id="18a731be"><span class="ne-text">下载Pycharm且配置</span></h3><p id="4538e0858e3013d02f248b1e37143de6" class="ne-p"><br></p><ul class="ne-ul"><li id="f64d6672b36400cdab083604f5bf1567"><strong><span class="ne-text">下载版本</span></strong><a href="https://www.jetbrains.com/pycharm/download/" data-href="https://www.jetbrains.com/pycharm/download/" target="_blank" class="ne-link"><span class="ne-text">社区/专业</span></a><span class="ne-text">：专业版本需要激活码，社区版本功能基本能应付日常使用  </span></li></ul><div class="ne-quote"><p id="ba7660b3fee571ec954f8c3df51b13c1" class="ne-p"><span class="ne-text">（大学学生时期可以用学生邮箱申请使用JetBrains系列软件，我的方法是先认证GitHub学生认证，然后直接从GitHub那边认证JetBrains软件的使用权，当然也可以直接用学生邮箱去</span><span class="ne-text">JetBrains官网认证</span><span class="ne-text">）</span></p></div><ul class="ne-ul"><li id="d73d3a26f1ffb98af76765e9ff8b7dad"><strong><span class="ne-text">❗补充：取消上面用学生邮箱去申请JetBrains系列软件使用方法。先去GitHub申请学生包，然后通过GitHub已认证的GitHub账号再去申请JetBrains系列软件较为方便 </span></strong><a href="https://www.jetbrains.com/zh-cn/community/education/?_ga=2.186354217.1063699871.1594345232-1379189663.1590592761#students" data-href="https://www.jetbrains.com/zh-cn/community/education/?_ga=2.186354217.1063699871.1594345232-1379189663.1590592761#students" target="_blank" class="ne-link"><strong><span class="ne-text">JetBrains申请链接🔗</span></strong></a></li><li id="6627c491cfc17582e85b9017c1422c6c"><span class="ne-text">Pycharm使用Anaconda的配置 （ </span><strong><span class="ne-text">❗补充：下面貌似是社区版本的添加方式，但是专业版本会自动识别</span></strong><span class="ne-text"> ）：</span></li></ul><p id="3245f1276e7df950545157d7329f1df8" class="ne-p"><br></p><p id="e653c63091219f644a6ad2818a73dbde" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685306285-e6ca8228-9234-4c7f-97f3-9d7fc26e0728.png" width="456" id="yAxpP" class="ne-image"></p><p id="cef888c4d3dd9a1407d485f7c2acf49a" class="ne-p" style="text-align: center"><br></p><p id="3228284acfbdbbb38b8884c152ffeb1e" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685306347-9a79eaf2-93cf-4ed4-b008-9e49aa66ad7e.png" width="449" id="bePXH" class="ne-image"></p><p id="a5ab58c06206e67eb6d8da0b1a2f7acc" class="ne-p"><br></p><h2 id="b619559f"><span class="ne-text">二、Anaconda环境管理</span></h2><h3 id="c97910bc"><span class="ne-text">pip,conda,Miniconda,Anaconda</span></h3><ul class="ne-ul"><li id="c8c8d8abf2f967f951edb34d961fa96a"><span class="ne-text">pip包管理工具，python官方认证</span></li><li id="150127e1633fcdee1bd7d69a18131474"><span class="ne-text">conda是一种通用包管理系统，旨在构建和管理任何语言和任何类型的软件。包管理与pip的使用类似，环境管理则允许用户方便地安装不同版本的python并可以快速切换。</span></li></ul><ul start="3" class="ne-ul"><li id="f0a6d15b030758f36511b53a06ad49c2"><span class="ne-text">Anaconda则是一个打包的集合，里面预装好了conda、某个版本的python、众多packages、科学计算工具等等，就是把很多常用的不常用的库都给你装好了。同时利用配置/工具/命令conda来进行package和</span><strong><span class="ne-text">environment</span></strong><span class="ne-text">的管理。</span></li><li id="946c7739d525be202b7f8dc7da9488d8"><span class="ne-text">Miniconda，它只包含最基本的内容——python与conda，以及相关的必须依赖项，对于空间要求严格的用户，Miniconda是一种选择。就只包含最基本的东西，其他的库得自己装。</span></li></ul><p id="02db07711cdc4d4718350ebac88634d8" class="ne-p"><br></p><div class="ne-quote"><p id="7c199d10645ebf43f4514690048a6e19" class="ne-p"><span class="ne-text">pip下载/管理经常bug，用conda结合anaconda/miniconda方便使用</span></p></div><h3 id="3f08ea70"><span class="ne-text">Python相关包路径的查看</span></h3><ul class="ne-ul"><li id="911faa86ef04d4ad01862589ec865a2f"><code class="ne-code"><span class="ne-text">win+R</span></code><span class="ne-text">  输入</span><code class="ne-code"><span class="ne-text">cmd</span></code><span class="ne-text">  输入</span><code class="ne-code"><span class="ne-text">python</span></code><span class="ne-text"> 输入</span><code class="ne-code"><span class="ne-text">import sys</span></code><span class="ne-text"> 输入</span><code class="ne-code"><span class="ne-text">sys.path</span></code></li><li id="30fc1d7e96b3ece62750b62dfca75e60"><span class="ne-text">标准库：anaconda文件夹下的lib文件夹</span></li></ul><ul start="3" class="ne-ul"><li id="8adb84260bada17144ec2204ca0c52ab"><span class="ne-text">第三方库：下述代码中的文件夹 </span><code class="ne-code"><span class="ne-text">C:\Users\wztli\Anaconda3\Lib\site-packages</span></code><span class="ne-text"> </span></li></ul><h3 id="70776e8d"><span class="ne-text">Sklearn包安装失败总结</span></h3><p id="506bb4edaa8f67b3cd799b010f47a1c8" class="ne-p"><span class="ne-text">安装scikit-learn包，导入sklearn的Bug</span></p><p id="380e07e949f424f1e9f7bc8833a2d8a1" class="ne-p"><br></p><pre><code>ImportError: DLL load failed: 找不到指定的模块</code></pre><p id="08d5f71abfa3c7dfad37fd04841f4290" class="ne-p"><br></p><p id="838f836e6895b0a7df63c832666f08b8" class="ne-p"><code class="ne-code"><span class="ne-text">scikit-learn</span></code><span class="ne-text">的下载会对numpy、scipy、joblib三个库相应版本有所要求，总之如果用anaconda的话，全部更新为最新即可（</span><a href="https://www.lfd.uci.edu/~gohlke/pythonlibs/" data-href="https://www.lfd.uci.edu/~gohlke/pythonlibs/" target="_blank" class="ne-link"><span class="ne-text">参考whl版本</span></a><span class="ne-text">）</span></p><div class="ne-quote"><ul class="ne-ul"><li id="01cc0500ee9b19e4153fffcc7b8fd025"><code class="ne-code"><span class="ne-text">C:\Users\wztli\Anaconda3\pkgs\scikit-learn-0.21.3-py37h6288b17_0\Lib\site-packages\sklearn\datasets\data</span></code></li><li id="723db2c7b107cb97ebce7465d489163f"><span class="ne-text">数据集在电脑中的位置</span></li></ul></div><h3 id="f184b6a9"><span class="ne-text">Scrapy包安装失败总结</span></h3><ul class="ne-ul"><li id="899cc91773bf069836a9eb066c193c26"><span class="ne-text">pip 下载可能会失败</span></li><li id="fb616eae9a1af9b577805a7266fe51b0"><span class="ne-text">使用conda（镜像）下载</span><code class="ne-code"><span class="ne-text">conda install -c scrapinghub scrapy</span></code></li></ul><h2 id="0d03af7f"><span class="ne-text">三、JetBrains系列软件的高效使用</span></h2><p id="d26622e9592b03713e605fe1b43f0249" class="ne-p"><br></p><h3 id="1622395b"><span class="ne-text">JetBrains之初始配置</span></h3><div class="ne-quote"><p id="11afb75f70cb0240cc46ea033f859cda" class="ne-p"><span class="ne-text">界面字体大小、代码字体大小、主题默认（dark）、背景图片（看心情）</span></p></div><ul class="ne-ul"><li id="17d7cf8184578db6ea6345bf167dc21a"><span class="ne-text">字体相关<br /></span><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685306645-d747b801-f817-475d-93e7-a9357a6f810b.png" width="393" id="vCu8H" class="ne-image"></li><li id="136335ae542e2d015ebc18bd03cba84d"><span class="ne-text">主题相关<br /></span><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685306383-6425ce01-32e1-4216-b62e-def25d1e9dc7.png" width="398" id="GQ6ez" class="ne-image"></li></ul><p id="ed5f3f81e5f9b1d801dc74510cd6437f" class="ne-p"><br></p><h3 id="f0290bfc"><span class="ne-text">JetBrains之Debug断点调试</span></h3><div class="ne-quote"><p id="d4a6ec2c32e163f1eb981d46ad9d841e" class="ne-p"><span class="ne-text">断点调试是优于打印输出的一种调试程序的一种手段（Pycharm编辑器，其他系列软件也一样）</span></p></div><p id="528191a61afa960709f80aacb3d7ef17" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685306462-78e560c3-6150-4b08-b806-34919a36f0a2.png" width="548" id="D1jlp" class="ne-image"></p><div class="ne-quote"><ul class="ne-ul"><li id="801a4a62cdadbc50b2beddfc1f40b57b"><span class="ne-text">Ctrl+F5（左上角）：（return &quot;project&quot;）重新debug该文件</span></li><li id="4cb64363e695431381fbe14de9502593"><span class="ne-text">F9：（resume program）一个断点接着一个断点走，不按行走（eg：有循环会随着i一步一步走完）</span></li></ul><ul start="3" class="ne-ul"><li id="da350373c9f4444865f1073e93c589b9"><span class="ne-text">F8：（step over） 一行一行走代码</span></li><li id="455b1850e833c1d52b7c1ab50dffb664"><span class="ne-text">F7：（step into） 进入函数内部</span></li></ul><ul start="5" class="ne-ul"><li id="1606e718138e730c14ffb93f9af6b33c"><span class="ne-text">Alt+shift+F7：（step into mycode）遇到自己函数  进去</span></li><li id="c465b4b3662801cafbd6e4373b7f3e3b"><span class="ne-text">shift+F8：（step out）跳出，进入函数后，跳出来</span></li></ul><ul start="7" class="ne-ul"><li id="9344e302477f2e0f18e3ad96db604ac1"><span class="ne-text">Alt+F10：（show execution point）指针显示当前断点旁边</span></li><li id="d99caaf48a61b89b0582c0e1974bb0a9"><strong><span class="ne-text">Show Python Prompt</span></strong><span class="ne-text">按键<br /></span><span class="ne-text">交互式调试命令</span></li></ul></div><p id="8e396fe0c8c29f88b815a511a7c10205" class="ne-p"><br></p><h3 id="74d4f47a"><span class="ne-text">JetBrains之GitHub使用</span></h3><ol class="ne-ol"><li id="e11bd32c211d809c2269532ae256e962"><span class="ne-text">配置Git和GitHub（先连接本地git，然后登录GitHub）<br /></span><span class="ne-text">页面  依次点击</span><code class="ne-code"><span class="ne-text">File</span></code><span class="ne-text"> </span><code class="ne-code"><span class="ne-text">Setting</span></code><span class="ne-text"> </span><code class="ne-code"><span class="ne-text">Version Control</span></code><span class="ne-text"> </span><code class="ne-code"><span class="ne-text">GitHub</span></code><span class="ne-text">然后登录账户进行配置</span></li><li id="96d226a7fb1175b7d6addcfaa92de00e"><span class="ne-text">将项目新建在GitHub<br /></span><span class="ne-text">菜单栏 依次点击 </span><code class="ne-code"><span class="ne-text">VCS</span></code><span class="ne-text"> </span><code class="ne-code"><span class="ne-text">Import into Version Control</span></code><span class="ne-text"> </span><code class="ne-code"><span class="ne-text">Share Project on GitHub</span></code></li></ol><ol start="3" class="ne-ol"><li id="3d4d3d4276b82ebd9f6845881142fba7"><strong><span class="ne-text">将项目克隆在本地</span></strong><span class="ne-text"> </span><code class="ne-code"><span class="ne-text">VCS</span></code><span class="ne-text"> </span><code class="ne-code"><span class="ne-text">Get from Version Control</span></code></li></ol><p id="ad02bc6276d4c5b30f5b30730ffe5224" class="ne-p"><br></p><h3 id="3dbad505"><span class="ne-text">JetBrains之TODO使用</span></h3><p id="8adbfdd10501735ae6023cd64a261d41" class="ne-p"><br></p><p id="d52d13f5de31f6d887f8c469247e34ee" class="ne-p"><span class="ne-text">便于编写大型代码，将注释加上前缀以便分类处理，以下图片展示</span></p><p id="4ae3bedb4c1fd505b952f1986d26db8a" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685306509-efc968a4-bf76-44f3-8347-52cbb5a7cc73.png" width="1890" id="ztWN4" class="ne-image"></p><p id="0337881be11eb88f7a8cad53a1137f80" class="ne-p"><br></p><p id="855614a664f4e7c65265683f425f7a73" class="ne-p"><span class="ne-text">参考：</span></p><p id="8a5aa92c0a6d736fba4b85474fc4eb2b" class="ne-p"><br></p><ul class="ne-ul"><li id="b64832b39b804a9aeb68372adf518c4e"><a href="https://www.jetbrains.com/help/pycharm/using-todo.html" data-href="https://www.jetbrains.com/help/pycharm/using-todo.html" target="_blank" class="ne-link"><span class="ne-text">TODO的使用官方文档</span></a></li><li id="e8247593617bd5e1e692363a7095ef7e"><a href="https://blog.csdn.net/weixin_34277853/article/details/94205060?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-5&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-5" data-href="https://blog.csdn.net/weixin_34277853/article/details/94205060?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-5&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-5" target="_blank" class="ne-link"><span class="ne-text">TODO的用法</span></a></li></ul><p id="a33bf6e407a76e006fb093752a4261c0" class="ne-p"><br></p><h3 id="5bbec828"><span class="ne-text">JetBrains之插件枚举</span></h3><p id="b1ea30bc232d6c5c99379ba41682de0b" class="ne-p"><br></p><ul class="ne-ul"><li id="3e7d0bc5fe585cbb239f5549a82e8ca5"><span class="ne-text">Waka Time：持续记录自己的IDE以及编程语言的使用时长</span></li><li id="eac501f074858261f0f434aa1426e48e"><span class="ne-text">leetcode editor：leetcode刷题插件</span></li></ul><p id="823ba2e2781c8defccc6d81b8eba1145" class="ne-p"><br></p><h3 id="f617d329"><span class="ne-text">JetBrains之初用警告</span></h3><p id="4217510e20bb7a9fa04e27b16f138791" class="ne-p"><br></p><p id="78da0b88600a975ff3bd32d9705a9416" class="ne-p"><span class="ne-text">一般下载完开始使用，IDE会报一个 </span><code class="ne-code"><span class="ne-text">Windows安全中心</span></code><span class="ne-text"> 的警告</span></p><p id="21b3546d1f182a772f009d0083823bf9" class="ne-p"><br></p><pre><code>Windows Defender might be impacting your build performance. PyCharm checked the following directorie</code></pre><p id="2b33e7d685046fa2ba58efc4b432efdc" class="ne-p"><br></p><p id="a6b10e823b0543fd4e11ab620088fa41" class="ne-p"><span class="ne-text">解决：</span><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685306961-bcb04392-e8c2-4f3a-a7f0-d2d1516afe70.png" width="1184" id="ReCbv" class="ne-image"></p><p id="5d765564e7f3603c9bd1bf045264b7fb" class="ne-p"><span class="ne-text">然后再进入排除项添加报错的文件夹即可</span></p><h3 id="G1n7V"><span class="ne-text">JetBrains之IDEA的leetcode插件</span></h3><div class="ne-quote"><p id="b62bcededdb88acbb63947d2562e4d99" class="ne-p"><span class="ne-text">记录一些配置</span></p></div><ul class="ne-ul"><li id="eb50ac1320c6384ace03a89de6d6ca7d"><span class="ne-text">勾选Custom Template和Plugin Update</span></li><li id="e2506bb664864e15138b5b55354f5b1d"><span class="ne-text">TempFilePath</span></li></ul><pre><code>D:\project-java\datastructure\src\com\wztlink1013\problems</code></pre><ul class="ne-ul"><li id="b143f9a217847a9a936fbde44b7a9387"><span class="ne-text">CodeFileName</span></li></ul><pre><code>P$&#123;question.frontendQuestionId&#125;$!velocityTool.camelCaseName($&#123;question.titleSlug&#125;)</code></pre><ul class="ne-ul"><li id="39be212120668d85699c12f435fe64e2"><span class="ne-text">CodeTemplate</span></li></ul><pre><code>package com.wztlink1013.problems.leetcode.editor.cn;<p>$&#123;question.content&#125;<br>public class P$&#123;question.frontendQuestionId&#125;$!velocityTool.camelCaseName($&#123;question.titleSlug&#125;)&#123;<br>    public static void main(String[] args) &#123;<br>        Solution solution = new P$&#123;question.frontendQuestionId&#125;$!velocityTool.camelCaseName($&#123;question.titleSlug&#125;)().new Solution();</p><pre><code>&#125;</code></pre><p>${question.code}<br>}<br></code></pre></p><p id="ed3b870db39cb22965aa08fdd660138d" class="ne-p"><br></p><p id="18ec4628e8a6d2592815ad0222051f1a" class="ne-p"><span class="ne-text">参考：</span></p><p id="d6a4c36f44385c5c18a7e4fabb3317e1" class="ne-p"><a href="https://blog.csdn.net/yxf19034516/article/details/106087994/" data-href="https://blog.csdn.net/yxf19034516/article/details/106087994/" target="_blank" class="ne-link"><span class="ne-text">IDEA的LeetCode力扣插件设置与使用</span></a></p><p id="e4ec6bfdeda4c0f63e7777918ef26a0a" class="ne-p"><a href="https://hacpai.com/article/1575547715310" data-href="https://hacpai.com/article/1575547715310" target="_blank" class="ne-link"><span class="ne-text">IDEA 的 LeetCode 刷题插件 leetcode editor</span></a></p></div>]]></content>
      
      
      <categories>
          
          <category> 计算机素养 </category>
          
          <category> 工具使用 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Git使用Token连接</title>
      <link href="/blog/lg6q7n/"/>
      <url>/blog/lg6q7n/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="u86415782" class="ne-p"><br></p><h2 id="5d4c567c"><span class="ne-text">一、应用</span></h2><p id="a1d791bd6206c9e714ac671ac749ab7d" class="ne-p"><span class="ne-text">多个终端使用，而且没必要配置SSH连接的情况，可以使用GitHub Token来连接使用。还有就是使用GitHub Actions时候用Token情况较SSH方便。</span></p><p id="dbcb0542983e256653a696e0108ad94f" class="ne-p"><br></p><p id="3e7c0edd1b7bd266032da9d8ae4daa89" class="ne-p"><span class="ne-text">不同的托管平台使用语法会有差异，在此记录下GitHub、Coding、Gitee的使用</span></p><p id="27795895dadbf965d1a132764a884e1f" class="ne-p"><br></p><h2 id="ae698d41"><span class="ne-text">二、GitHub</span></h2><p id="a7f51f5b1e7cfef03ceef858cf2eac15" class="ne-p"><br></p><p id="572d39f3c50b153e73bef188725562f6" class="ne-p"><span class="ne-text">GitHub生成一个Token：***</span></p><p id="ad80b074987bd3e6eebd8f02faa1b0fc" class="ne-p"><br></p><p id="e3a11c6096ddc9a44a904eed7ed7713f" class="ne-p"><span class="ne-text">使用SSH情况：</span><code class="ne-code"><span class="ne-text">git clone </span><a href="https://github.com/wztlink1013/blog3.0.git" data-href="https://github.com/wztlink1013/blog3.0.git" target="_blank" class="ne-link"><span class="ne-text">https://github.com/wztlink1013/blog3.0.git</span></a></code></p><p id="a20bad5a1195060fb1a983435c958666" class="ne-p"><br></p><p id="ba900a44b11cf91921b8579b57117fc6" class="ne-p"><span class="ne-text">使用Token情况：</span><code class="ne-code"><a href="https://x-access-token:**************@github.com/wztlink1013/blog3.0.git" data-href="https://x-access-token:**************@github.com/wztlink1013/blog3.0.git" target="_blank" class="ne-link"><span class="ne-text">https://x-access-token:**************@github.com/wztlink1013/blog3.0.git</span></a></code></p><p id="8bb442f9c95f69fd6ebb4c62d498fb33" class="ne-p"><br></p><h2 id="7a90c0c0"><span class="ne-text">三、Coding</span></h2><p id="e58023abd48b8bd2d25a5d3d8afa6e75" class="ne-p"><br></p><p id="3b96fa754226156cd18a4255afcd133b" class="ne-p"><span class="ne-text">在个人设置中设置一个访问令牌</span></p><p id="7bb9b07f75c581244e2f9a1d32bf79c8" class="ne-p"><br></p><ul class="ne-ul"><li id="7b67b64ea6240ba3e3161611c827469d"><span class="ne-text">令牌用户名：####</span></li><li id="4e81b1dcd3551160ea65e76f4dea0eb0"><span class="ne-text">令牌Token：*</span></li></ul><p id="dde0302fb7e02d28f7d482bc09ff76d6" class="ne-p"><br></p><p id="043b79557c7a8d60f336dc6ce4f8ea85" class="ne-p"><span class="ne-text">使用SSH情况：</span><code class="ne-code"><a href="https://e.coding.net/wztlink1013/project/repo.git" data-href="https://e.coding.net/wztlink1013/project/repo.git" target="_blank" class="ne-link"><span class="ne-text">https://e.coding.net/wztlink1013/project/repo.git</span></a></code></p><p id="dc52361d87396b8c9a34133508c18c65" class="ne-p"><span class="ne-text">使用令牌情况：</span><code class="ne-code"><a href="https://####:***********@e.coding.net/wztlink1013/project/repo.git" data-href="https://####:***********@e.coding.net/wztlink1013/project/repo.git" target="_blank" class="ne-link"><span class="ne-text">https://####:***********@e.coding.net/wztlink1013/project/repo.git</span></a></code></p><p id="d3869df8023a8cd7ebc75bee50305598" class="ne-p"><br></p><h2 id="88be64df"><span class="ne-text">四、Gitee</span></h2><p id="4dc85e09f4c1105689b96ade345939df" class="ne-p"><br></p><p id="b4823addcf0e04d1a84475b5c78c653a" class="ne-p"><span class="ne-text">头像设置中申请私人令牌：**</span></p><p id="36afefacb9aa992c5b51b90b44ed587b" class="ne-p"><br></p><p id="562d103e9c850fb5675fb40c12e70024" class="ne-p"><span class="ne-text">使用SSH情况：</span><code class="ne-code"><a href="https://gitee.com/user/repo.git" data-href="https://gitee.com/user/repo.git" target="_blank" class="ne-link"><span class="ne-text">https://gitee.com/user/repo.git</span></a></code></p><p id="27fa0efc6c3143ed2aae7cc8ae31ea9a" class="ne-p"><br></p><p id="99c54fe1990b811c9cff121938ea6a20" class="ne-p"><span class="ne-text">使用Token情况：</span><code class="ne-code"><a href="https://oauth2:**********@gitee.com/user/repo.git" data-href="https://oauth2:**********@gitee.com/user/repo.git" target="_blank" class="ne-link"><span class="ne-text">https://oauth2:**********@gitee.com/user/repo.git</span></a></code></p><p id="9ac2004bd0077be8689a400d45b210d6" class="ne-p"><br></p><h2 id="5bc5db4d"><span class="ne-text">五、GitHub Actions中的使用</span></h2><p id="4f23e929f040f7f71f95a7dc6f50895e" class="ne-p"><br></p><pre><code>Github_Pages:  github.com/wztlink1013/wztlink1013.github.ioGithub_Token:  $&#123;&#123;  secrets.token_GithubAPI  &#125;&#125;<p>git  push  –force  –quiet  &quot;https://$&#123;Github_Token&#125;@$&#123;Github_Pages&#125;&quot;<br></code></pre></p><p id="e1d782ea52f90fd34d6296cf616b9b89" class="ne-p"><br></p><pre><code>Coding_Pages:  e.coding.net/wztlink1013/wztlink1013.gitCoding_Token:  $&#123;&#123;  secrets.token_CodingAPI  &#125;&#125;Coding_Username:  $&#123;&#123;  secrets.Username_Coding  &#125;&#125;<p>git  push  –force  –quiet  &quot;https://$&#123;Coding_Username&#125;:$&#123;Coding_Token&#125;@$&#123;Coding_Pages&#125;&quot;<br></code></pre></p></div>]]></content>
      
      
      <categories>
          
          <category> 计算机素养 </category>
          
          <category> Git和GitHub </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Eclipse的使用总结</title>
      <link href="/blog/at014v/"/>
      <url>/blog/at014v/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h2 id="08648db2"><span class="ne-text">一、Eclipse的下载与安装</span></h2><p id="7536057be2edc73ef247e00b37a8aa94" class="ne-p"><br></p><ul class="ne-ul"><li id="u80ad3b79"><span class="ne-text"></span><a href="https://www.eclipse.org/downloads/" data-href="https://www.eclipse.org/downloads/" target="_blank" class="ne-link"><span class="ne-text">下载地址</span></a></li></ul><p id="25c82c931426a2f6f1e96e18450c4aa9" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685180944-7ec7ebc3-8c39-44a7-9bec-85fded021a40.png" width="1817" id="dYx1H" class="ne-image"></p><p id="79ba222c54c57dc646ad453f2fffdb24" class="ne-p"><br></p><p id="7716f79f3035b1d2595feeb46775a7ad" class="ne-p"><strong><span class="ne-text">注意不要下错版本，不然开发不了web环境</span></strong></p><p id="7a4f121dc96a82ab6a70e45fa4fb5c49" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685180923-a106c8c7-aebe-4f0a-bc06-d166bfc8894d.png" width="731" id="AjuXj" class="ne-image"></p><p id="057c35073a50654129cf3c394d156f77" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685180948-16e05303-0d11-454e-8bbd-71a11d7a3ef7.png" width="741" id="yVKJo" class="ne-image"></p><p id="d1e472e053f8441f7a9a514b711ead15" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685180925-0262b0ea-f7af-493b-85a5-d8e7cbd12751.png" width="762" id="NLbFI" class="ne-image"></p><p id="985cd8f1f789946d0e6998acf0f94df4" class="ne-p"><br></p><h2 id="f659fd57"><span class="ne-text">二、插件</span></h2><p id="c234f354bc18943cd0b5cc401b14c014" class="ne-p"><br></p><div class="ne-quote"><p id="2ec0b9a353bd8f0ae49a025230ada072" class="ne-p"><span class="ne-text">进入：</span><code class="ne-code"><span class="ne-text">Help Eclipse</span></code><span class="ne-text"> </span><code class="ne-code"><span class="ne-text">MarketPlace</span></code></p></div><p id="198f890d9d6c04a72884a9011ea85317" class="ne-p"><br></p><ul class="ne-ul"><li id="9d753e5748509c6987d1c7fa130e6a77"><span class="ne-text">Plugin1：Waka Time</span></li></ul><p id="22821cfce7ca1b7ee911a54bfe92aa52" class="ne-p"><br></p><h2 id="74b5d460"><span class="ne-text">三、使用</span></h2><p id="80a0ffbc93078f77b0c05463f2027cc6" class="ne-p"><br></p><h3 id="39003734"><span class="ne-text">样式</span></h3><p id="5ab923aac74917458ad0efd7f6651b65" class="ne-p"><br></p><ul class="ne-ul"><li id="1b0994b66fb32ee4538d80bff45f2553"><span class="ne-text">字体设置</span></li><li id="71b02e98756f4081bb6d41e2a42a765e"><span class="ne-text">行数显示</span></li><li id="4a1ef318f1c180d8f48e4b195e247a2c"><span class="ne-text">更改工作空间的默认编码</span></li><li id="0c07e2002c5f99108c95aed7463bb434"><span class="ne-text">代码增强显示，在设置中的</span><code class="ne-code"><span class="ne-text">java</span></code><span class="ne-text">中的</span><code class="ne-code"><span class="ne-text">content Assistant</span></code><span class="ne-text">中，将</span><code class="ne-code"><span class="ne-text">.</span></code><span class="ne-text">改为</span><code class="ne-code"><span class="ne-text">.ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789</span></code></li></ul><p id="d47953b5126b60592d42f3659de53c44" class="ne-p"><br></p><h3 id="616c8f3c"><span class="ne-text">导入已存在的项目</span></h3></div>]]></content>
      
      
      <categories>
          
          <category> 计算机素养 </category>
          
          <category> 工具使用 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Eclipse下载使用以及配置Tomcat创建Servlet</title>
      <link href="/blog/ro0lgm/"/>
      <url>/blog/ro0lgm/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h2 id="XKsm7"><span class="ne-text">一、Eclipse的下载与安装与使用</span></h2><p id="d22f933e54231c45c739b35455fd6011" class="ne-p"><br></p><ul class="ne-ul"><li id="ufba0ac5e"><span class="ne-text"></span><a href="https://www.eclipse.org/downloads/" data-href="https://www.eclipse.org/downloads/" target="_blank" class="ne-link"><span class="ne-text">下载地址</span></a></li></ul><p id="174e419e65f783ac80f61dfd35ef9c40" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685043597-84e5ed4c-8ad9-496b-997d-fd84136d0a86.png" width="1817" id="G6LM6" class="ne-image"></p><p id="1b6bae00950afb9547af4e978bf4446f" class="ne-p"><br></p><p id="a3d30bd43c066f1d672e6112f759eaf5" class="ne-p"><strong><span class="ne-text">注意不要下错版本，不然开发不了web环境</span></strong></p><p id="12c8a7dc4aefffea788e01b6c7a9788f" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685043623-2432fa56-57df-4b19-bbcf-d7f803db63d3.png" width="731" id="yRync" class="ne-image"></p><p id="411b244c71fbe46ee61f59b8b7ede2ad" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685043608-ed00c908-2eb3-4a07-bcd4-c93a58aed494.png" width="741" id="rkrad" class="ne-image"></p><p id="c05a34b4624c677dbbec8cc59d68a795" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685043479-aac1b3ff-f51d-4dce-8313-4e10d2e78bbb.png" width="762" id="ThLfH" class="ne-image"></p><p id="aa5b4f1c12e6b9e9bdcbd203a06c3565" class="ne-p"><br></p><h2 id="f1467b90"><span class="ne-text">二、Tomcat的下载与配置</span></h2><p id="f784f5b3157ad91ce492e8b0e60cd990" class="ne-p"><br></p><p id="28803d989b6f99f11f161d7a556ef94e" class="ne-p"><a href="https://tomcat.apache.org/download-90.cgi" data-href="https://tomcat.apache.org/download-90.cgi" target="_blank" class="ne-link"><span class="ne-text">下载地址</span></a></p><p id="d19f70ff91634e3f9466a396b3b5120e" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685043712-245a08a5-48cd-4446-ae4b-2ac442f09a44.png" width="1829" id="t3Fxz" class="ne-image"></p><p id="09104af19350c1c49fd07d7dd891eea8" class="ne-p"><strong><span class="ne-text">一直下一步即可</span></strong></p><p id="c8c49b905b1658f1a9a85965661ad639" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685043478-1e8b6460-5b48-424e-8f2d-db26d6bbce42.png" width="623" id="obx49" class="ne-image"></p><p id="01265c86fc349f49d4e19bef94d44951" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685043417-e391db44-2cd9-4c7c-8e6b-1f131ab95769.png" width="624" id="gKPxP" class="ne-image"></p><p id="84f1d5682264b8688d547eb7d08e9510" class="ne-p"><br></p><p id="f531331bcabb676811807be8d89a3a38" class="ne-p"><span class="ne-text">打开浏览器 键入 </span><a href="http://localhost:8080" data-href="http://localhost:8080" target="_blank" class="ne-link"><span class="ne-text">http://localhost:8080</span></a><span class="ne-text"> 进入页面则表示安装成功</span></p><p id="9aebfad63b25a67c10ce99f874b60e63" class="ne-p"><br></p><p id="56f78c429cbde9e55a8369a30f44a75d" class="ne-p"><span class="ne-text">添加环境变量，以下全在系统环境变量下配置</span></p><p id="7dea95d94accdd15d57a2bf300f7168d" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685043418-feddef63-fcb3-45ce-ac5a-33dd94d77655.png" width="1089" id="Flmgj" class="ne-image"></p><p id="7dc9340094727e16c37023f6d5a4987f" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685043499-20fddab9-abfb-4d0d-9c6d-956933ee59be.png" width="704" id="FC9yv" class="ne-image"></p><p id="a62e46ce6cd6c7f657f197724c007666" class="ne-p"><br></p><pre><code>TOMCAT_HOME：C:\Program Files\Apache Software Foundation\Tomcat 9.0CATALINA_BASE：C:\Program Files\Apache Software Foundation\Tomcat 9.0;CATALINA_HOME：C:\Program Files\Apache Software Foundation\Tomcat 9.0;在classpath当中加入%CATALINA_HOME%\common\lib\servlet-api.jar;在path中加入%CATALINA_HOME%\bin;</code></pre><p id="91a01e38a8df64d1842240be9f390bba" class="ne-p"><br></p><p id="5381ad444b45a3b3160597a49dbe8a00" class="ne-p"><span class="ne-text">打开浏览器 键入 </span><a href="http://localhost:8080" data-href="http://localhost:8080" target="_blank" class="ne-link"><span class="ne-text">http://localhost:8080</span></a><span class="ne-text"> 进入页面则表示配置成功</span></p><p id="ceabc5386bc0513f2968026145f7d51c" class="ne-p"><br></p><h2 id="8891e692"><span class="ne-text">三、Eclipse配置Tomcat</span></h2><p id="a40255cea2effc2794e27f76113db839" class="ne-p"><br></p><p id="23a0a32c1a59b68d9506255c9a290439" class="ne-p"><strong><span class="ne-text">让Tomcat服务器显示在控制台上，将Web应用部署到Tomcat中</span></strong></p><p id="c180076da3f14ac0c2af90dc6e689aed" class="ne-p"><br></p><p id="7246ebc8e238d7bc1f0ff3d40281e29a" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685043589-c8022021-1185-4c41-b114-630856e16984.png" width="1837" id="CVcDY" class="ne-image"></p><p id="ff004e2f6f6e7b32152f85d996c83863" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685043661-236843dd-f3ea-433e-b23a-254cc0a41c9b.png" width="1217" id="KUNBB" class="ne-image"></p><p id="8a70eeb1bceda5b7a170b4cf1a6fce6c" class="ne-p"><span class="ne-text">点击</span><code class="ne-code"><span class="ne-text">Window</span></code><span class="ne-text"> → </span><code class="ne-code"><span class="ne-text">Show View</span></code><span class="ne-text"> → </span><code class="ne-code"><span class="ne-text">Servers</span></code><span class="ne-text"> 也可以在控制台点击</span><code class="ne-code"><span class="ne-text">Servers</span></code></p><p id="fdde81f7a4c0621106c6c75e827632ee" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685043514-556e9b3f-1003-40ff-9066-70349be51101.png" width="1600" id="hNwzT" class="ne-image"></p><p id="40aa8fa3df20d469177bc07e700f621c" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685043568-aa8984a7-e9e9-4206-a922-f3386127191d.png" width="597" id="B8gZ2" class="ne-image"></p><p id="4fbec848f244fa2fb9d50647f3a1faf5" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685043484-23195297-3636-47d7-bf44-ee0151382f87.png" width="1478" id="dJMaU" class="ne-image"></p><p id="e6cb854de4ab32e6679322755d329407" class="ne-p"><strong><span class="ne-text">双击点击</span></strong></p><p id="c84ca78dfcdd8b9a56f770ed9c720993" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685043403-e34d7544-8144-4516-bb7c-53adbabac167.png" width="1375" id="Gcbaq" class="ne-image"></p><p id="7bd810a5aed4db03860eae1fa9b5ceca" class="ne-p"><br></p><h2 id="48a8162f"><span class="ne-text">四、Eclipse使用Servlet</span></h2><p id="7bff59aaedfd80a8844fbb7d0b8109fa" class="ne-p"><br></p><h3 id="bfb57051"><span class="ne-text">创建web工程</span></h3><p id="1926075b59cca19f23e85b5efe2d48b3" class="ne-p"><br></p><p id="81791be211f329d81374866c4d9406e7" class="ne-p"><strong><span class="ne-text">创建过程中，要记得勾选生成web.xml文件选项</span></strong></p><p id="317dec62e3c84ad2008ffc45e987bae4" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685043545-0429f9cf-3910-4401-85da-08dd0118e9b1.png" width="1838" id="wOVWA" class="ne-image"></p><p id="829a66a096b0301ff20e6174cddc3608" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685043538-d98f2569-40d6-4c3a-8111-9c3d6702052a.png" width="820" id="svPwh" class="ne-image"></p><p id="3525d6a2192de5bd1693c0d214faa031" class="ne-p"><br></p><h3 id="54c2047f"><span class="ne-text">添加相关文件</span></h3><p id="77bd63fe78189308f68d609b135445fd" class="ne-p"><br></p><p id="900d2902035d1086b673d3b9ff9fb04f" class="ne-p"><strong><span class="ne-text">添加下面的四个文件</span></strong></p><p id="07ea45f4ba61c35c4831d762c6bba533" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685043712-c178c180-3c3a-44a2-9518-671033558337.png" width="1831" id="oHS9Z" class="ne-image"></p><p id="6463a75cb07cc2e4ed80409452af0ee9" class="ne-p"><br></p><div class="ne-quote"><p id="f187acf4216f85e2095ef3fef1d30f06" class="ne-p"><span class="ne-text">HelloWordServlet.java</span></p></div><p id="1e759b3516d28291761a08d1690d04b6" class="ne-p"><br></p><pre><code>package cn.itcast.firstmyapp.servlet;<p>import java.io.IOException;<br>import java.io.PrintWriter;</p><p>import javax.servlet.ServletException;<br>import javax.servlet.http.HttpServlet;<br>import javax.servlet.http.HttpServletRequest;<br>import javax.servlet.http.HttpServletResponse;</p><p>public class HelloWordServlet extends HttpServlet &#123;</p><pre><code> protected void doGet(HttpServletRequest req, HttpServletResponse resp)            throws ServletException, IOException &#123;             System.out.println(&amp;quot;接受了客户端的请求----------------------------------------------------&amp;quot;);     // 设置响应类型:        resp.setContentType(&amp;quot;text/html&amp;quot;);        // 获取输出流:        PrintWriter pw = resp.getWriter();        // 写入响应:        pw.write(&amp;quot;&amp;lt;h1&amp;gt;Hello, world!&amp;lt;/h1&amp;gt;&amp;quot;);        // 最后不要忘记flush强制输出:        pw.flush();    &#125;</code></pre><p>}<br></code></pre></p><p id="9c1bd153aac1d7c834f855995b2deff2" class="ne-p"><br></p><div class="ne-quote"><p id="97fcc0bb0bde9264593f8d2e19b709f8" class="ne-p"><span class="ne-text">web.xml</span></p><p id="c577747e78b27f5db86c33829ed1bed6" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685043517-5459e979-8525-4be9-8dab-d38f0857ef56.png" width="1178" id="EcMnq" class="ne-image"></p></div><p id="7195f94127c578cee2b547cd58c6412a" class="ne-p"><br></p><h3 id="e37b1858"><span class="ne-text">运行并查看结果</span></h3><p id="aaa2fa67ed7a520e8b24a62f91789f78" class="ne-p"><br></p><p id="0a65d1edc6d861758493de9c852d1f03" class="ne-p"><strong><span class="ne-text">运行</span></strong></p><p id="af91bcbc0c0732579c38ac9ac2b0bfa8" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685043718-5d90186b-8040-4098-b1d4-bb1f67740382.png" width="1434" id="eFEub" class="ne-image"></p><p id="7d45073dbe36aac9bd6d1d5cf43fd878" class="ne-p"><span class="ne-text">然后查看console部分</span></p><p id="fa101114255ccbcf9f8a634b0430ac07" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685043524-efeaf228-713b-43e1-ba15-375060ef20d2.png" width="1449" id="iYu91" class="ne-image"></p><p id="2ffb68210e9c9a42b8bde66b48dda724" class="ne-p"><strong><span class="ne-text">服务器响应情况</span></strong></p><p id="6e5e760df7a4d8751f5a30fba73bf6e6" class="ne-p"><br></p><div class="ne-quote"><p id="7df4eda92c46e111ca0c39e4f1ede5d9" class="ne-p"><span class="ne-text">出现下图则说明成功</span></p><p id="25b99464fa0e3d323ddd6d3bbde88cdb" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685043360-fd5bb570-f56a-429a-ad0e-627646447132.png" width="1318" id="sq6h2" class="ne-image"></p></div><p id="94163f88494e7cdfedbb93010b019ee5" class="ne-p"><br></p><div class="ne-quote"><p id="c9e565bc54d4c4d40224bf4c55a9e6ac" class="ne-p"><span class="ne-text">还可以回到控制台查看请求成功情况</span></p><p id="9ced40694bd97894433c18b773da8042" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685043568-b62922c0-c458-4c71-bd9c-800f57b356de.png" width="1445" id="PPuUA" class="ne-image"></p></div><p id="6b5d745582849784116d0b6823f6af28" class="ne-p"><br></p><h2 id="cc8f5ec4"><span class="ne-text">五、过程中出现的问题</span></h2><p id="21c7d1a4ae3e2f923bcb0f90d311cc11" class="ne-p"><br></p><h3 id="89cb7a49"><span class="ne-text">IDEA上的部署</span></h3><p id="254bcd966f8975b9194dc51b927dcddf" class="ne-p"><br></p><p id="8b18c36e455d27f54993f19c7c1e4957" class="ne-p"><span class="ne-text">一开始从tomcat部署是完成的，具体参考我的csdn一篇小文章</span><a href="https://blog.csdn.net/ZTlink1013/article/details/104815639" data-href="https://blog.csdn.net/ZTlink1013/article/details/104815639" target="_blank" class="ne-link"><span class="ne-text">地址</span></a><span class="ne-text">。但是在后面使用Servlet的时候，不能成功部署，具体原因【图片内容来自</span><a href="https://blog.csdn.net/HughGilbert/article/details/56424137" data-href="https://blog.csdn.net/HughGilbert/article/details/56424137" target="_blank" class="ne-link"><span class="ne-text">链接</span></a><span class="ne-text">！！】</span></p><p id="28b6c4548b90adde05e67cc187a3f162" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685043902-5708dbdc-79d7-4e16-9e6d-d5571c5de758.png" width="941" id="WybYZ" class="ne-image"></p><p id="6cb78eda93f95140cd0dec88755e0aa5" class="ne-p"><br></p><div class="ne-quote"><p id="2cb452c4e05997ac7458758cfbd716f9" class="ne-p"><span class="ne-text">暂时分析：是和idea下的根目录下的某个配置文件的默认配置有关，需要更改相关内容，暂时不折腾了。先记录下，有空再折腾，先学习。还是eclipse好配置···</span></p></div><p id="eb3170ef48ea425b1b65db43a108f7e7" class="ne-p"><br></p><h3 id="35808e79"><span class="ne-text">参考资料</span></h3><p id="08bc55847419f2294c336f7f4436e0ba" class="ne-p"><br></p><ul class="ne-ul"><li id="89b7cf1df4cc307fa13d89fb43873760"><a href="https://blog.csdn.net/weixin_34026276/article/details/93834823?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task" data-href="https://blog.csdn.net/weixin_34026276/article/details/93834823?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task" target="_blank" class="ne-link"><span class="ne-text">https://blog.csdn.net/weixin_34026276/article/details/93834823?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task</span></a></li><li id="b1c363efa5d5b09917907fc4572ceea0"><a href="https://blog.csdn.net/qq_38190185/article/details/88198794?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task" data-href="https://blog.csdn.net/qq_38190185/article/details/88198794?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task" target="_blank" class="ne-link"><span class="ne-text">https://blog.csdn.net/qq_38190185/article/details/88198794?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task</span></a></li><li id="39e754e822292dba62842add453503e8"><a href="https://www.yiibai.com/servlet/creating-servlet-in-eclipse-ide.html" data-href="https://www.yiibai.com/servlet/creating-servlet-in-eclipse-ide.html" target="_blank" class="ne-link"><span class="ne-text">直接创建Servlet</span></a></li><li id="741f5e0aedac7b1c8fb430facaf1e1a9"><span class="ne-text">快捷键：</span><a href="https://www.open-open.com/bbs/view/1320934157953" data-href="https://www.open-open.com/bbs/view/1320934157953" target="_blank" class="ne-link"><span class="ne-text">https://www.open-open.com/bbs/view/1320934157953</span></a></li></ul></div>]]></content>
      
      
      <categories>
          
          <category> 计算机素养 </category>
          
          <category> 环境搭建 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>GitHub Actions：不同仓库文件夹迁移</title>
      <link href="/blog/qp5kuu/"/>
      <url>/blog/qp5kuu/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="u5135cf9f" class="ne-p"><span class="ne-text">前言：每一个GitHub仓库都有GitHub Pages功能，虽然可以利用wztlink1013.github.io/test来访问，但是这种形式第一次访问还是会走github的cdn一步骤，所以为了其他仓库的gh-pages页面也能继承wztlink1013.github.io的速度，打算将test仓库下gh-pages分支下的所有文件复制到wztlink1013.github.io仓库主分支下的test文件夹中。</span></p><p id="ufe31a19e" class="ne-p"><span class="ne-text"></span></p><div data-type="danger" class="ne-alert"><p id="u0cf6d9a1" class="ne-p"><span class="ne-text">弃用：过于繁琐😆</span></p></div><h2 id="fc2260b5"><span class="ne-text">一、编写脚本</span></h2><p id="6841877c72e520141268f8eeb584a88e" class="ne-p"><span class="ne-text">配置git用户逻辑</span></p><pre><code>git config --global user.name 'wztlink1013' git config --global user.email 'wztlink1013@163.com'git clone https://github.com/wztlink1013/test.gitgit clone https://github.com/wztlink1013/wztlink1013.github.io.git</code></pre><p id="806e0bc1449dfd08b014c3b33cfb727f" class="ne-p"><span class="ne-text">文件夹移动逻辑</span></p><pre><code>cd wztlink1013.github.iomkdir testcd ..xcopy .\test .\wztlink1013.github.io /e</code></pre><p id="0667e64e67844b7c2e6b71a58175d47e" class="ne-p"><span class="ne-text">代码提交逻辑</span></p><pre><code>cd wztlink1013.github.iogit statusgit add .git commit -m &quot;add gh-pages files&quot;git push &quot;https://$&#123;Github_Token&#125;@github.com/wztlink1013/wztlink1013.github.io&quot;  master:master</code></pre><p id="f1303e9a8bd8a36e2f3e660041c3c2c8" class="ne-p"><br></p><h2 id="c28e0ff6"><span class="ne-text">二、编写GitHub Actions</span></h2><p id="f79a68536e8e8ad5aee3833f9ad2a40b" class="ne-p"><br></p><pre><code>name: CI for wztlink1013.github.io<p>on: [push, watch]</p><p>jobs:<br>  build:<br>    runs-on: ubuntu-latest</p><pre><code>steps:- uses: actions/checkout@v2- name: 配置Git  run: |     git config --global user.name &#39;wztlink1013&#39;     git config --global user.email &#39;wztlink1013@163.com&#39;- name: 在云端进行复制文件夹操作  env:    Github_Token: $&#123;&#123; secrets.TOKEN_GITHUBAPI &#125;&#125;  run: |     git clone https://github.com/wztlink1013/visualization visualization    git clone https://github.com/wztlink1013/wztlink1013.github.io .github_pages    cd visualization    rm -r .git    rm -r .github    cd ..    cd .github_pages    rm -r visualization    cd ..    mv visualization/ -f .github_pages/    cd .github_pages    git status    git add .    git commit -m &amp;quot;add gh-pages files&amp;quot;    git push --force --quiet &amp;quot;https://$&#123;Github_Token&#125;@github.com/wztlink1013/wztlink1013.github.io&amp;quot;  master:master</code></pre><p></code></pre></p></div>]]></content>
      
      
      <categories>
          
          <category> 计算机素养 </category>
          
          <category> Git和GitHub </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>VScode插件+配置C++环境</title>
      <link href="/blog/pm7mpk/"/>
      <url>/blog/pm7mpk/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="udeb49267" class="ne-p"><span class="ne-text">前言：本来我也不是插件重度用户，写项目觉得太累赘，然后在公司前端工作之后，嗯，真香……本文总结vscode的使用，并记录配置相关信息以便更换设备迁移配置，具体内容有：</span></p><ul class="ne-ul"><li id="uc978866e"><span class="ne-text">常用插件总结</span></li><li id="udb4052d9"><span class="ne-text">vscode配置C++运行环境</span></li></ul><p id="ubaee4af6" class="ne-p"><span class="ne-text">参考：</span><a href="https://blog.csdn.net/TriDiamond6/article/details/105604427?utm_source=app" data-href="https://blog.csdn.net/TriDiamond6/article/details/105604427?utm_source=app" target="_blank" class="ne-link"><span class="ne-text">VSCode插件大全｜VSCode高级玩家之第二篇</span></a></p><h2 id="kSVW4" style="text-align: center"><span class="ne-text">DELETE: 彻底删除vscode软件</span></h2><p id="u152e3230" class="ne-p" style="text-align: left"><strong><span class="ne-text">本着要学会如何配置环境，首先要学会如何彻底删除软件的原则（曾经的javaweb懂得都懂……），先介绍一下如何在本地设备彻底删除vscode软件。</span></strong></p><p id="u24815e89" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1640403466550-8a3fb5fa-9fe5-4ba0-8ea9-80e773fd43f5.jpeg" width="105.99074172973633" id="nq92q" class="ne-image"></p><ul class="ne-ul"><li id="u314cd579"><code class="ne-code"><span class="ne-text">win + r</span></code><span class="ne-text"> 在输入框输入</span><code class="ne-code"><span class="ne-text">%appdata%</span></code><span class="ne-text"> 回车</span></li><li id="u13cff4bb"><span class="ne-text">删除 Code 和 Visual Studio Code 文件夹</span></li><li id="uc3e62902"><span class="ne-text">地址栏输入 </span><code class="ne-code"><span class="ne-text">%userprofile%</span></code><span class="ne-text"> 回车</span></li><li id="ubac316ef"><span class="ne-text">删除 </span><code class="ne-code"><span class="ne-text">.vscode</span></code><span class="ne-text"> 文件夹</span></li><li id="u26143e85"><span class="ne-text">重新下载：</span><a href="https://code.visualstudio.com/download" data-href="https://code.visualstudio.com/download" target="_blank" class="ne-link"><span class="ne-text">https://code.visualstudio.com/download</span></a></li></ul><h2 id="ce9bb4e0"><span class="ne-text">一、VScode插件使用</span></h2><h3 id="qaLIR"><span class="ne-text">常用插件</span></h3><ul class="ne-tl"><li checked="true" id="3332911a31b4f035638135342944c6e4"><span class="ne-text">Chinese (simplified)Language pack for Visual Code</span></li><li checked="true" id="32fcc5aa5b469aa290dfb90ca3903b1c"><span class="ne-text">Todo Highlight</span></li></ul><ul class="ne-ul"><li id="u7624379d"><span class="ne-text">优化TODO高亮 </span><a href="https://github.com/wayou/vscode-todo-highlight" data-href="https://github.com/wayou/vscode-todo-highlight" target="_blank" class="ne-link"><span class="ne-text">https://github.com/wayou/vscode-todo-highlight</span></a></li></ul><pre><code>  &quot;todohighlight.defaultStyle&quot;: &#123;    &quot;color&quot;: &quot;#ffffff&quot;,    &quot;backgroundColor&quot;: &quot;#ffab00&quot;,    &quot;overviewRulerColor&quot;: &quot;#ffab00&quot;,    // &quot;cursor&quot;: &quot;pointer&quot;,    &quot;border&quot;: &quot;1px solid #eee&quot;,    &quot;borderRadius&quot;: &quot;1px&quot;,    &quot;isWholeLine&quot;: true  &#125;,  &quot;todohighlight.keywords&quot;: [    &#123;      &quot;text&quot;: &quot;NOTE:&quot;,      &quot;backgroundColor&quot;: &quot;#1295db&quot;,      &quot;overviewRulerColor&quot;: &quot;grey&quot;,      &quot;isWholeLine&quot;: true    &#125;  ],</code></pre><ul class="ne-tl"><li checked="true" id="f9f53deacc04e8f59bcbb6d3451121fb"><span class="ne-text">Live Server</span></li></ul><p id="u3bf49f5d" class="ne-p"><span class="ne-text">运行HTML</span></p><ul class="ne-tl"><li checked="true" id="u1c25fbd0"><span class="ne-text">Vue Language Features (Volar)</span></li></ul><p id="ubd7851af" class="ne-p"><span class="ne-text">Vue2的高亮</span></p><ul class="ne-tl"><li checked="true" id="u9744937d"><span class="ne-text">Color Highlight</span></li></ul><p id="u713b4c68" class="ne-p"><span class="ne-text">代码中有颜色的地方会高亮</span></p><p id="uf650c0f8" class="ne-p"><span class="ne-text">文件中找到的 css/web 颜色，所以你无需打开页面就能看到它们是什么颜色。</span></p><ul class="ne-tl"><li id="u3e4ed336"><span class="ne-text">koroFileHeader</span></li></ul><ul class="ne-ul"><li id="u2ef7b4c2"><span class="ne-text">生成文件头注释 配置参考：</span><a href="https://github.com/OBKoro1/koro1FileHeader" data-href="https://github.com/OBKoro1/koro1FileHeader" target="_blank" class="ne-link"><span class="ne-text">https://github.com/OBKoro1/koro1FileHeader</span></a></li></ul><pre><code>// 头部注释&quot;fileheader.customMade&quot;: &#123;  // 头部注释默认字段  &quot;Author&quot;: &quot;wztlink1013&quot;,  &quot;Date&quot;: &quot;Do not edit&quot;, // 设置后默认设置文件生成时间  &quot;LastEditTime&quot;: &quot;Do not edit&quot;, // 设置后，保存文件更改默认更新最后编辑时间  &quot;Description&quot;: &quot;&quot;&#125;,// 函数注释&quot;fileheader.cursorMode&quot;: &#123;  // 默认字段  &quot;description&quot;:&quot;&quot;,  &quot;param&quot;:&quot;&quot;,  &quot;return&quot;:&quot;&quot;&#125;,</code></pre><ul class="ne-tl"><li id="u95f42ad8"><span class="ne-text">background</span></li></ul><p id="uaee3d44f" class="ne-p"><span class="ne-text">背景图片的设置</span></p><pre><code>  // ======================================================== //  //                      background                          //  // ======================================================== //  &quot;update.enableWindowsBackgroundUpdates&quot;: true,  &quot;background.customImages&quot;: [&quot;https://s4.ax1x.com/2021/12/25/TUYYNQ.jpg&quot;],  &quot;background.style&quot;: &#123;    &quot;content&quot;: &quot;''&quot;,    &quot;pointer-events&quot;: &quot;none&quot;,    &quot;position&quot;: &quot;absolute&quot;, //定位    &quot;width&quot;: &quot;100%&quot;,    &quot;height&quot;: &quot;100%&quot;,    &quot;z-index&quot;: &quot;99999&quot;,    &quot;background.repeat&quot;: &quot;no-repeat&quot;, //是否重复    &quot;background-size&quot;: &quot;100%,100%&quot;, //图片大小    &quot;opacity&quot;: 0.1 //透明度  &#125;,  &quot;background.useFront&quot;: true,  &quot;background.useDefault&quot;: false, //是否使用默认图片</code></pre><h3 id="PnwkU"><span class="ne-text">不常用插件</span></h3><ul class="ne-tl"><li id="u22b96203"><span class="ne-text">HTML CSS Support</span></li></ul><p id="u03ddec3a" class="ne-p"><span class="ne-text">让 html 标签上写class 智能提示当前项目所支持的样式</span></p><ul class="ne-tl"><li id="u856a11f0"><span class="ne-text">IntelliSense for CSS class names in HTML</span></li><li id="u1ebe3fcd"><span class="ne-text">JavaScript (ES6) code snippets</span></li></ul><p id="u1a9339b9" class="ne-p"><span class="ne-text">ES6语法智能提示以及快速输入，除js外还支持.ts，.jsx，.tsx，.html，.vue，省去了配置其支持各种包含js代码文件的时间</span></p><ul class="ne-tl"><li id="u3f684dbb"><span class="ne-text">Auto Import</span></li></ul><p id="ubd40226a" class="ne-p"><span class="ne-text">自动导入包（组件）：第一次用到该组件（包）时是不会有自动导入提示的，在另一个文件第二次用时就会有自动导入提示了</span></p><ul class="ne-tl"><li checked="true" id="u9c763934"><span class="ne-text">vscode-icons</span></li></ul><p id="u8662c941" class="ne-p"><span class="ne-text">美化图标</span></p><ul class="ne-tl"><li id="u4069ae1e"><span class="ne-text">Waka Time</span></li></ul><p id="ubabf86bf" class="ne-p"><span class="ne-text">记录软件编写各类语言时间分配</span></p><ul class="ne-tl"><li id="u4b429e9e"><span class="ne-text">Nuxt Typescript Snippets</span></li><li id="uad01a17c"><span class="ne-text">Path Autocomplete</span></li></ul><p id="ua3a38cfa" class="ne-p"><span class="ne-text">会有路径提示</span></p><ul class="ne-tl"><li id="ufa58c1a7"><span class="ne-text">Path Intellisense</span></li></ul><p id="ua5a457f7" class="ne-p"><span class="ne-text">自动路径补全</span></p><ul class="ne-tl"><li id="u94228d42"><span class="ne-text">Reactjs code snippets</span></li><li id="uf51e4074"><span class="ne-text">Vetur</span></li></ul><p id="ua574fc3d" class="ne-p"><span class="ne-text">针对vue2的推荐</span></p><p id="u32858c71" class="ne-p"><span class="ne-text">VSCode里安装Vetur可以将“.vue”文件中的语法进行高亮显示，Vetur不仅支持Vue中的template模板以外，还支持大多数主流的前端开发脚本和插件，比如Sass、TypeScript、Jade和Less等等。</span></p><ul class="ne-tl"><li id="u7c413155"><span class="ne-text">Vue 3 Snippets</span></li><li id="ua93de0a3"><span class="ne-text">Vue VSCode Snippets</span></li><li id="udf12dc96"><span class="ne-text">Auto Close Tag</span></li></ul><p id="u66376ac6" class="ne-p"><span class="ne-text">自动闭合HTML/XML标签</span></p><ul class="ne-tl"><li id="udd680fc7"><span class="ne-text"> Auto Rename Tag</span></li></ul><p id="u43f11d13" class="ne-p"><span class="ne-text">自动关闭Html标签，输入起始标签后会自动变换尾部标签。</span></p><ul class="ne-tl"><li id="u17d5d537"><span class="ne-text">DotENV【添加env环境变量参数】</span></li></ul><p id="u66417218" class="ne-p"><span class="ne-text">参考：</span><a href="https://blog.csdn.net/hbiao68/article/details/105205112" data-href="https://blog.csdn.net/hbiao68/article/details/105205112" target="_blank" class="ne-link"><span class="ne-text">https://blog.csdn.net/hbiao68/article/details/105205112</span></a></p><ul class="ne-tl"><li id="u90569d29"><span class="ne-text">Todo Tree【优化TODO：侧边栏】</span></li><li id="u9e377c6e"><span class="ne-text">language-stylus</span></li><li id="u68f97402"><span class="ne-text">GitLens 【显示当前行commit信息，管理git】</span></li><li id="u4d4e55c0"><span class="ne-text">Git History 【查看commit信息】</span></li><li id="u3747756b"><span class="ne-text">Bracket Pair Colorrizer 2 【优化大括号】</span></li><li id="u9bd5e048"><span class="ne-text">vscode可以自定义markdown预览样式，css文件以外链的方式放上</span></li></ul><h3 id="C1YIH"><span class="ne-text">自定义字体</span></h3><p id="ue5874f20" class="ne-p"><span class="ne-text">TODO: 选用好看的中文字体和英文字体</span></p><h2 id="87c5883a"><span class="ne-text">二、VScode配置C/C++环境</span></h2><p id="uf99033ee" class="ne-p"><span class="ne-text">参考：</span><a href="https://www.zhihu.com/question/30315894" data-href="https://www.zhihu.com/question/30315894" target="_blank" class="ne-link"><span class="ne-text">Visual Studio Code 如何编写运行 C、C++ 程序？</span></a></p><h3 id="V8Iq2"><span class="ne-text">下载gcc编译器</span></h3><div class="ne-quote"><p id="u4e2fd0ab" class="ne-p"><span class="ne-text">下载地址：</span><a href="https://sourceforge.net/projects/mingw-w64/files/" data-href="https://sourceforge.net/projects/mingw-w64/files/" target="_blank" class="ne-link"><span class="ne-text">https://sourceforge.net/projects/mingw-w64/files/</span></a></p></div><p id="u2efd8d80" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1624949859317-61aab22e-74c9-4210-9c4b-f192c9af76ea.png" width="955.5" id="u0f6c1ee7" class="ne-image"></p><div class="ne-quote"><p id="u8b5f377f" class="ne-p"><span class="ne-text">配置环境</span></p></div><p id="u31964630" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1624949943592-2695ea6b-4237-4a26-8d5b-c39a2c2ff920.png" width="485" id="u901eeafb" class="ne-image"></p><p id="u2dcc7cc0" class="ne-p"><span class="ne-text">检查是否配置成功</span></p><p id="ufd6722a7" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1624949993088-16f38896-e62c-4347-8e3e-d4ac0e5c4273.png" width="720" id="u842c5c50" class="ne-image"></p><h3 id="r1XIX"><span class="ne-text">下载插件</span></h3><p id="u3130b0be" class="ne-p"><span class="ne-text">在vscode中下载如下两个插件</span></p><ul class="ne-tl"><li checked="true" id="u9fc786ec"><span class="ne-text">CodeRunner</span></li><li checked="true" id="uf640c9d4"><span class="ne-text">C/C++</span></li></ul><p id="ucbe47b0f" class="ne-p"><span class="ne-text"></span><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1624948996187-240d18a3-446f-4381-a685-e9a2a7af5d91.png" width="139.5" id="ubffcb48a" class="ne-image"></p><h3 id="iqbXP"><span class="ne-text">项目.vscode配置</span></h3><p id="u41e685cc" class="ne-p"><span class="ne-text">建立一个 </span><code class="ne-code"><span class="ne-text">.vscode</span></code><span class="ne-text"> 文件夹，然后在里面新建下面三个文件即可。</span></p><p id="u03e482c9" class="ne-p"><span class="ne-text"></span></p><p id="uad961a08" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1624949162500-fc5ebdeb-2c45-49d6-afb0-badec740d502.png" width="167" id="ue1af6290" class="ne-image"></p><div data-type="danger" class="ne-alert"><p id="ub7fb3b0b" class="ne-p"><span class="ne-text">注意：以后只有该配置文件夹的文件夹才能编写C/C++代码</span></p></div><h4 id="L5w9u"><span class="ne-text">launch.json</span></h4><pre><code>&#123;    &quot;version&quot;: &quot;0.2.0&quot;,    &quot;configurations&quot;: [&#123;        &quot;name&quot;: &quot;(gdb) Launch&quot;,         &quot;type&quot;: &quot;cppdbg&quot;,         &quot;request&quot;: &quot;launch&quot;,         &quot;program&quot;: &quot;$&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;.exe&quot;,         &quot;args&quot;: [],         &quot;stopAtEntry&quot;: false,         &quot;cwd&quot;: &quot;$&#123;workspaceFolder&#125;&quot;,         &quot;environment&quot;: [],         &quot;externalConsole&quot;: true,         &quot;internalConsoleOptions&quot;: &quot;neverOpen&quot;,         &quot;MIMode&quot;: &quot;gdb&quot;,         &quot;miDebuggerPath&quot;: &quot;gdb.exe&quot;,         &quot;setupCommands&quot;: [            &#123;                 &quot;description&quot;: &quot;Enable pretty-printing for gdb&quot;,                &quot;text&quot;: &quot;-enable-pretty-printing&quot;,                &quot;ignoreFailures&quot;: false            &#125;        ],        &quot;preLaunchTask&quot;: &quot;Compile&quot;     &#125;]&#125;<p></code></pre></p><h4 id="ImhQO"><span class="ne-text">settings.json</span></h4><pre><code>&#123;    &quot;files.defaultLanguage&quot;: &quot;c&quot;,     &quot;editor.formatOnType&quot;: true,      &quot;editor.suggest.snippetsPreventQuickSuggestions&quot;: false,     &quot;editor.acceptSuggestionOnEnter&quot;: &quot;off&quot;,     &quot;code-runner.runInTerminal&quot;: true,     &quot;code-runner.executorMap&quot;: &#123;        &quot;c&quot;: &quot;gcc '$fileName' -o '$fileNameWithoutExt.exe' -Wall -O2 -m64 -lm -static-libgcc -std=c11 -fexec-charset=GBK &amp;&amp; &amp;'./$fileNameWithoutExt.exe'&quot;,        &quot;cpp&quot;: &quot;g++ '$fileName' -o '$fileNameWithoutExt.exe' -Wall -O2 -m64 -static-libgcc -std=c++14 -fexec-charset=GBK &amp;&amp; &amp;'./$fileNameWithoutExt.exe'&quot;    &#125;,     &quot;code-runner.saveFileBeforeRun&quot;: true,     &quot;code-runner.preserveFocus&quot;: true,         &quot;code-runner.clearPreviousOutput&quot;: false,     &quot;code-runner.ignoreSelection&quot;: true,       &quot;code-runner.fileDirectoryAsCwd&quot;: true, <pre><code>&amp;quot;C_Cpp.clang_format_sortIncludes&amp;quot;: true</code></pre><p>}</p><p></code></pre></p><h4 id="Hmg1P"><span class="ne-text">tasks.json</span></h4><pre><code>&#123;    &quot;version&quot;: &quot;2.0.0&quot;,    &quot;tasks&quot;: [&#123;        &quot;label&quot;: &quot;Compile&quot;,         &quot;command&quot;: &quot;gcc&quot;,           &quot;args&quot;: [            &quot;$&#123;file&#125;&quot;,            &quot;-o&quot;,                &quot;$&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;.exe&quot;,            &quot;-g&quot;,                &quot;-m64&quot;,             &quot;-Wall&quot;,             &quot;-static-libgcc&quot;,                 &quot;-fexec-charset=GBK&quot;,             <pre><code>    ],     &amp;quot;type&amp;quot;: &amp;quot;process&amp;quot;,     &amp;quot;group&amp;quot;: &#123;        &amp;quot;kind&amp;quot;: &amp;quot;build&amp;quot;,        &amp;quot;isDefault&amp;quot;: true     &#125;,    &amp;quot;presentation&amp;quot;: &#123;        &amp;quot;echo&amp;quot;: true,        &amp;quot;reveal&amp;quot;: &amp;quot;always&amp;quot;,         &amp;quot;focus&amp;quot;: false,             &amp;quot;panel&amp;quot;: &amp;quot;shared&amp;quot;       &#125;,    &amp;quot;problemMatcher&amp;quot;:&amp;quot;$gcc&amp;quot;     &#125;]</code></pre><p>}</p><p></code></pre></p><h2 id="DCTRV"><a href="https://blog.csdn.net/TriDiamond6/article/details/105604427?utm_source=app" data-href="https://blog.csdn.net/TriDiamond6/article/details/105604427?utm_source=app" target="_blank" class="ne-link"><span class="ne-text"><br /></span></a><span class="ne-text">三、其他</span></h2><p id="ud59fa1aa" class="ne-p"><br></p></div>]]></content>
      
      
      <categories>
          
          <category> 计算机素养 </category>
          
          <category> 工具使用 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>电脑重装系统以及重装后的软件下载</title>
      <link href="/blog/qq1dno/"/>
      <url>/blog/qq1dno/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="uc80604f5" class="ne-p"><span class="ne-text">前言：个人重装系统的缘由有如下几个原因：</span></p><ul class="ne-ul"><li id="u73d09211" data-lake-index-type="0"><span class="ne-text">环境配置混乱</span></li><li id="ucd45fc15" data-lake-index-type="0"><span class="ne-text">网卡驱动出错，重装驱动不生效 </span></li><li id="uc40d6110" data-lake-index-type="0"><span class="ne-text">电脑的空间太杂乱</span></li></ul><p id="ucf5120c1" class="ne-p"><span class="ne-text">同时，重装系统能解决电脑带来的大部分问题，所以在此记录一下重装的各类方法、操作流程、以及重装之后的电脑所需要下载的软件总结。</span></p><h2 id="87d96d8d"><span class="ne-text">一、重装系统流程</span></h2><p id="uaca7f33c" class="ne-p"><span class="ne-text">重装系统有很多种方法：传统的U盘下载镜像重装、win10的重置电脑功能、三方软件的一键重装，但是个人而言，所有的方法都没有U盘方法“干净”，比如win10的重置功能会保留一些文件在重装后的电脑中，导致占内存，三方软件一般都会捆绑三方软件在你的重装之后电脑中，</span><strong><span class="ne-text">所以推荐使用U盘下载镜像的方法</span></strong><span class="ne-text">。</span></p><h3 id="c625568f"><span class="ne-text">1.1 下载镜像</span></h3><p id="u0f71d538" class="ne-p"><span class="ne-text">进入下面任一地址获取windows下载镜像种子地址, 然后到</span><span class="ne-text" style="text-decoration: underline">迅雷</span><span class="ne-text">/</span><span class="ne-text" style="text-decoration: underline">网盘离线</span><span class="ne-text">下载即可</span></p><ul class="ne-ul"><li id="u405e2a39" data-lake-index-type="0"><span class="ne-text">地址1: </span><a href="https://msdn.itellyou.cn/" data-href="https://msdn.itellyou.cn/" target="_blank" class="ne-link"><span class="ne-text">MSDN下载镜像</span></a><span class="ne-text"></span></li></ul><ul class="ne-ul"><li id="u49279ec9" data-lake-index-type="0"><span class="ne-text">地址2: </span><a href="https://www.microsoft.com/zh-cn/software-download/windows10" data-href="https://www.microsoft.com/zh-cn/software-download/windows10" target="_blank" class="ne-link"><span class="ne-text">微软官方下载镜像</span></a><span class="ne-text"> ( 下载的是当前电脑windows版本镜像 )</span></li></ul><p id="u04867952" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2023/png/1484158/1693671258780-d9bb308f-3387-4601-91cd-d5ad26691d38.png" width="190" id="USs2z" class="ne-image"></p><h3 id="Lt3z9"><span class="ne-text">1.2 制作启动盘</span></h3><p id="ub0474a1d" class="ne-p"><span class="ne-text">下载完镜像之后，再用 </span><code class="ne-code"><span class="ne-text" style="text-decoration: line-through">ULtralSO</span></code><span class="ne-text">/ </span><code class="ne-code"><span class="ne-text">rufus</span></code><span class="ne-text">软件刻录在U盘, 由于下载的镜像大小一般大于4G, 所以U盘必须大于4G, 不然录入不了.</span></p><div class="ne-quote"><p id="u4e8fa7ae" class="ne-p"><span class="ne-text">rufus下载地址: </span><a href="https://onedrive.wztlink1013.com/api/raw/?path=/re_install_os/rufus/rufus-3.10.exe" data-href="https://onedrive.wztlink1013.com/api/raw/?path=/re_install_os/rufus/rufus-3.10.exe" class="ne-link"><span class="ne-text">https://onedrive.wztlink1013.com/api/raw/?path=/re_install_os/rufus/rufus-3.10.exe</span></a></p></div><p id="u06bafc43" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2023/png/1484158/1693671258780-d9bb308f-3387-4601-91cd-d5ad26691d38.png" width="190" id="u13612a9f" class="ne-image"></p><p id="u37bb308c" class="ne-p" style="text-align: left"><img src="https://cdn.nlark.com/yuque/0/2023/png/1484158/1693670538161-16cdc71d-7c8c-4fb3-aca2-ff92c9aa91f6.png" width="294.6666564941406" id="u358cf89e" class="ne-image"></p><div class="ne-quote"><ol class="ne-ol"><li id="u3a0d89a3" data-lake-index-type="0"><span class="ne-text">如果下载的镜像大于4G左右，ULtralSO不能刻录。</span></li><li id="ubf096449" data-lake-index-type="0"><span class="ne-text">官方下载，可以匹配自己电脑本来的版本；可以直接刻录在U盘，唯一不足应该就是网速问题。</span></li><li id="u34770707" data-lake-index-type="0"><span class="ne-text">U盘如果“身患重伤”，下个相关优化U盘软件处理一下</span></li></ol></div><h3 id="856f2641"><span class="ne-text">1.3 USB正式重装</span></h3><ol class="ne-ol"><li id="u5c6994d0" data-lake-index-type="0"><span class="ne-text">将刻入镜像的USB插上电脑, 然后进入bios界面, 按F9设置启动选项</span></li></ol><div class="ne-quote"><p id="u3c38df36" class="ne-p"><span class="ne-text">如何进入bios界面：开机刚要出现</span><code class="ne-code"><span class="ne-text">HP</span></code><span class="ne-text">字样，一直点</span><code class="ne-code"><em><span class="ne-text">esc</span></em></code><span class="ne-text">键，然后再设置开机进入启动盘（不同电脑，不同进入方式，网上搜一下就可以了）</span></p></div><p id="ucbc99b47" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/1484158/1693715315361-987a3ee5-c5a4-4f5f-b5d5-d22b66b78ec3.jpeg" width="292.2615966796875" id="trBpx" class="ne-image"></p><ol start="2" class="ne-ol"><li id="u3404f954" data-lake-index-type="0"><span class="ne-text">选择第二个,使用</span><code class="ne-code"><span class="ne-text">USB</span></code><span class="ne-text">硬盘启动</span></li></ol><p id="u5d13d62b" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/1484158/1693715312383-38c14d89-531a-416d-b130-c4f4599469f9.jpeg" width="229.2615966796875" id="aUlbH" class="ne-image"></p><ol start="3" class="ne-ol"><li id="u027a6e6b" data-lake-index-type="0"><span class="ne-text">Next Wait即可(格式化C盘→安装→等候→登录微软账号...)</span></li></ol><h3 id="af05a627"><span class="ne-text">1.4 关于磁盘管理</span></h3><ul class="ne-ul"><li id="u690ed442" data-lake-index-type="0"><span class="ne-text">重装系统的安装，一般是安装到C盘，也就是系统盘</span></li><li id="u72421bda" data-lake-index-type="0"><span class="ne-text">重装完成之后，根据需求也可以人为将磁盘分区</span></li></ul><div class="ne-quote"><p id="u7d4c0a11" class="ne-p"><span class="ne-text">相关问题1：给C盘扩展时不能扩展？</span></p><p id="u687b73d1" class="ne-p"><span class="ne-text">磁盘只有相邻卷才能扩展卷：解决办法就是把右边的磁盘删除（状态为未分配空间），然后用左边的磁盘合并之（使用扩展卷）</span></p></div><h3 id="51af8e23"><span class="ne-text"> 1.5 关于破解</span></h3><ul class="ne-ul"><li id="u5d843ffb" data-lake-index-type="0"><span class="ne-text">下载自己笔记本出厂Windows版本，则不需要激活码，自带</span></li><li id="ua92bf028" data-lake-index-type="0"><span class="ne-text">有条件购买支持正版，支持同行</span></li><li id="u49adf3f9" data-lake-index-type="0"><span class="ne-text">最后使用：激活工具</span></li></ul><div class="ne-quote"><p id="u4d18e8df" class="ne-p"><span class="ne-text">下载地址：</span><a href="https://onedrive.wztlink1013.com/zh-CN/re_install_os/DragonKMS/" data-href="https://onedrive.wztlink1013.com/zh-CN/re_install_os/DragonKMS/" target="_blank" class="ne-link"><span class="ne-text">https://onedrive.wztlink1013.com/zh-CN/re_install_os/DragonKMS/</span></a></p></div><h2 id="8d4a5a1f"><span class="ne-text">二、电脑备份相关工作</span></h2><h3 id="1EabK"><span class="ne-text">2.1 上网与浏览器</span></h3><ul class="ne-tl"><li checked="true" id="ubc52a0dc" data-lake-index-type="0"><span class="ne-text">kxsw： </span><a href="https://www.freewhale.site/user" data-href="https://www.freewhale.site/user" target="_blank" class="ne-link"><span class="ne-text">freewhale</span></a><span class="ne-text">、</span><a href="https://onedrive.wztlink1013.com/zh-CN/re_install_os/over_wall/" data-href="https://onedrive.wztlink1013.com/zh-CN/re_install_os/over_wall/" target="_blank" class="ne-link"><span class="ne-text">下载链接</span></a></li><li checked="true" id="u82f1a9e8" data-lake-index-type="0"><span class="ne-text">谷歌浏览器：</span><a href="https://www.google.com/intl/zh-CN/chrome/" data-href="https://www.google.com/intl/zh-CN/chrome/" class="ne-link"><span class="ne-text">下载地址</span></a></li></ul><div class="ne-quote"><p id="u7d8ddff5" class="ne-p"><span class="ne-text">登录谷歌账号同步书签插件等设置</span></p></div><ul class="ne-tl"><li checked="true" id="u2e4b0eb5" data-lake-index-type="0"><span class="ne-text">解压软件: </span><a href="https://www.bandisoft.com/bandizip/" data-href="https://www.bandisoft.com/bandizip/" target="_blank" class="ne-link"><span class="ne-text">Bandizip</span></a></li><li checked="true" id="u6de633ef" data-lake-index-type="0"><span class="ne-text">截图软件: </span><a href="https://www.snipaste.com/download.html" data-href="https://www.snipaste.com/download.html" target="_blank" class="ne-link"><span class="ne-text">Snipaste</span></a></li><li checked="true" id="u6fac1e8c" data-lake-index-type="0"><span class="ne-text">ScreenToGif：</span><a href="https://github.com/NickeManarin/ScreenToGif" data-href="https://github.com/NickeManarin/ScreenToGif" target="_blank" class="ne-link"><span class="ne-text">https://github.com/NickeManarin/ScreenToGif</span></a></li></ul><details class="lake-collapse"><summary id="u6244731f"><strong><span class="ne-text">非必须环境</span></strong></summary><ul class="ne-tl"><li id="ud778aa42" data-lake-index-type="0"><span class="ne-text">IDM下载器</span></li></ul></details><h3 id="Q5NmO"><span class="ne-text">2.2 搭建必备开发环境</span></h3><ul class="ne-tl"><li checked="true" id="u39e6df4d" data-lake-index-type="0"><span class="ne-text">Git</span></li></ul><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="u7511cfb4" data-lake-index-type="0"><span class="ne-text">Git下载配置：</span><a href="https://www.wztlink1013.com/blog/fnsge3/" data-href="https://www.wztlink1013.com/blog/fnsge3/" target="_blank" class="ne-link"><span class="ne-text">Git常见使用+多账号同设备部署总结 | 尼采般地抒情</span></a></li><li id="ue391d1b5" data-lake-index-type="0"><span class="ne-text">GitHub配置GPG：</span><a href="https://www.yuque.com/wztlink1013/blog/go85d1" data-href="https://www.yuque.com/wztlink1013/blog/go85d1" class="ne-link"><span class="ne-text">https://www.yuque.com/wztlink1013/blog/go85d1</span></a></li></ul></ul><ul class="ne-tl"><li checked="true" id="u57e9b55a" data-lake-index-type="0"><span class="ne-text">Nodejs</span></li></ul><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="u4a0f2265" data-lake-index-type="0"><span class="ne-text" style="text-decoration: line-through">无需版本管理：</span><a href="https://www.wztlink1013.com/blog/yo1xhz/" data-href="https://www.wztlink1013.com/blog/yo1xhz/" target="_blank" class="ne-link"><span class="ne-text" style="text-decoration: line-through">Hexo+GitHub Pages搭建个人静态网站 | 尼采般地抒情</span></a></li><li id="ua48831f8" data-lake-index-type="0"><span class="ne-text">nvm管理Node版本：</span><a href="https://www.yuque.com/jaegers/lyrics/orml31" data-href="https://www.yuque.com/jaegers/lyrics/orml31" target="_blank" class="ne-link"><span class="ne-text">https://www.yuque.com/jaegers/lyrics/orml31</span></a></li></ul></ul><div class="ne-quote"><p id="uc450139c" class="ne-p"><span class="ne-text">使用nvm管理Node.js版本（</span><a href="https://www.yuque.com/wztlink1013/lyrics/orml31" data-href="https://www.yuque.com/wztlink1013/lyrics/orml31" target="_blank" class="ne-link"><span class="ne-text">https://www.yuque.com/wztlink1013/lyrics/orml31</span></a><span class="ne-text">）</span></p></div><details class="lake-collapse"><summary id="u117eb016"><strong><span class="ne-text">非必须环境</span></strong></summary><ul class="ne-tl"><li id="u30ddf4a9" data-lake-index-type="0"><strong><span class="ne-text">MongoDB</span></strong></li><li id="ue61d8410" data-lake-index-type="0"><span class="ne-text">Java（jdkjdk1.8.0_181，jrejdk1.8.0_181）：</span><a href="https://www.wztlink1013.com/blog/cwqx6l/" data-href="https://www.wztlink1013.com/blog/cwqx6l/" target="_blank" class="ne-link"><span class="ne-text">配置java开发环境 | 尼采般地抒情</span></a></li><li id="u27b9a68f" data-lake-index-type="0"><span class="ne-text">ffmpeg（图片处理）</span></li><li id="ueaaaadb8" data-lake-index-type="0"><span class="ne-text">MySQL</span></li><li id="u8c18d14f" data-lake-index-type="0"><span class="ne-text">Windows子系统</span><span class="ne-text" style="text-decoration: line-through">，Unix：VMware15</span></li><li id="u6bd65a2b" data-lake-index-type="0"><span class="ne-text">Docker 、 Docker Desktop</span></li><li id="ub5a28e9c" data-lake-index-type="0"><span class="ne-text">YApi：不建议在本地搭建，建议在服务器中搭建</span></li></ul></details><h3 id="ieRkR"><span class="ne-text">2.3 搭建必备开发工具</span></h3><ul class="ne-tl"><li checked="true" id="ub6aa984b" data-lake-index-type="0"><span class="ne-text">Web：</span><a href="https://code.visualstudio.com/download" data-href="https://code.visualstudio.com/download" target="_blank" class="ne-link"><span class="ne-text">Visual Studio Code</span></a><span class="ne-text">（登录GitHub账号同步配置）</span></li><li checked="true" id="u1d8c4de6" data-lake-index-type="0"><span class="ne-text">Navicat：</span><a href="https://onedrive.wztlink1013.com/api/raw/?path=/re_install_os/Navicat_16/Navicat%2016.zip" data-href="https://onedrive.wztlink1013.com/api/raw/?path=/re_install_os/Navicat_16/Navicat%2016.zip" target="_blank" class="ne-link"><span class="ne-text">下载地址</span></a></li></ul><details class="lake-collapse"><summary id="ucb154f0a"><strong><span class="ne-text">非必须环境</span></strong></summary><ul class="ne-tl"><li id="uc2b74bfc" data-lake-index-type="0"><span class="ne-text">云服务器</span></li></ul><ul class="ne-list-wrap"><ul ne-level="1" class="ne-tl"><li id="uee76b0a8" data-lake-index-type="0"><strong><span class="ne-text">FinalShell</span></strong><span class="ne-text"> </span><span class="ne-text" style="text-decoration: line-through">或 XShel</span><span class="ne-text">l：</span><a href="https://www.yuque.com/ypcarf/lyrics/loyv75#CRNrT" data-href="https://www.yuque.com/ypcarf/lyrics/loyv75#CRNrT" target="_blank" class="ne-link"><span class="ne-text">https://www.yuque.com/ypcarf/lyrics/loyv75#CRNrT</span></a></li><li id="ub38171f5" data-lake-index-type="0"><strong><span class="ne-text">FileZilla Client</span></strong><span class="ne-text">（云服务器、云虚拟主机）：</span><a href="https://www.yuque.com/ypcarf/lyrics/loyv75#qU93H" data-href="https://www.yuque.com/ypcarf/lyrics/loyv75#qU93H" target="_blank" class="ne-link"><span class="ne-text">https://www.yuque.com/ypcarf/lyrics/loyv75#qU93H</span></a></li></ul></ul><ul class="ne-tl"><li id="u7f826c1c" data-lake-index-type="0"><span class="ne-text">DataBase： </span><strong><span class="ne-text">Navicat Premium 15</span></strong><span class="ne-text">：</span><a href="https://www.yuque.com/ypcarf/lyrics/nwt63v#DWP8v" data-href="https://www.yuque.com/ypcarf/lyrics/nwt63v#DWP8v" target="_blank" class="ne-link"><span class="ne-text">https://www.yuque.com/ypcarf/lyrics/nwt63v#DWP8v</span></a><span class="ne-text">、</span><a href="https://www.microsoft.com/zh-cn/download/confirmation.aspx?id=30438" data-href="https://www.microsoft.com/zh-cn/download/confirmation.aspx?id=30438" target="_blank" class="ne-link"><span class="ne-text" style="text-decoration: line-through">SQL Server 2008</span></a><span class="ne-text" style="text-decoration: line-through"> 和 </span><a href="https://zhuanlan.zhihu.com/p/65630194" data-href="https://zhuanlan.zhihu.com/p/65630194" target="_blank" class="ne-link"><span class="ne-text" style="text-decoration: line-through">安装教程</span></a><span class="ne-text" style="text-decoration: line-through"> </span></li><li id="ub212b072" data-lake-index-type="0"><span class="ne-text">Python：Anaconda、Pycharm(</span><span class="ne-text" style="text-decoration: line-through">配置nltk、tensorflow等</span><span class="ne-text">)(</span><span class="ne-text" style="text-decoration: line-through">关于破解或</span><span class="ne-text"> </span><strong><span class="ne-text">学生用户登录</span></strong><span class="ne-text">)</span></li><li id="u717a167b" data-lake-index-type="0"><span class="ne-text">Java/JavaWeb：IDEA、IDEA/Eclipse(配置Tomcat)</span></li><li id="u787117a3" data-lake-index-type="0"><span class="ne-text">Android：Android Studio、HBuilder X、微信开发者工具</span></li><li id="u7e81b0c3" data-lake-index-type="0"><span class="ne-text">OS：CPU Simulator</span></li><li id="u333806ed" data-lake-index-type="0"><span class="ne-text">科研：Matlab、CAJViewer 7.3、AxMath、研究-AxGlyph</span></li><li id="uc602bdc7" data-lake-index-type="0"><span class="ne-text">Docker</span></li><li id="ud200a341" data-lake-index-type="0"><span class="ne-text" style="text-decoration: line-through">C&amp;C++：</span><a href="https://www.wztlink1013.com/blog/pm7mpk/" data-href="https://www.wztlink1013.com/blog/pm7mpk/" target="_blank" class="ne-link"><span class="ne-text" style="text-decoration: line-through">VScode（搭配C/C++开发插件使用）</span></a><span class="ne-text" style="text-decoration: line-through">、Clion、Codeblocks、VS</span></li><li id="u29a77c0b" data-lake-index-type="0"><span class="ne-text">Postman</span></li><li id="u5f64f019" data-lake-index-type="0"><span class="ne-text">Charles（抓包工具）</span></li></ul></details><h3 id="mwZUB"><span class="ne-text">2.4 同步个人文件及代码</span></h3><ul class="ne-tl"><li checked="true" id="u7ef9c7d2" data-lake-index-type="0"><a href="https://pan.baidu.com/disk/main#/index?category=all" data-href="https://pan.baidu.com/disk/main#/index?category=all" target="_blank" class="ne-link"><span class="ne-text">百度网盘</span></a></li><li checked="true" id="u70fe7b61" data-lake-index-type="0"><a href="https://github.com/wztlink1013" data-href="https://github.com/wztlink1013" target="_blank" class="ne-link"><span class="ne-text">GitHub </span></a><code class="ne-code"><span class="ne-text">git clone</span></code><span class="ne-text">同步开发项目代码</span></li></ul><ul class="ne-tl"><li checked="true" id="uef4c8e4e" data-lake-index-type="0"><a href="https://www.aliyundrive.com/sign/in" data-href="https://www.aliyundrive.com/sign/in" target="_blank" class="ne-link"><span class="ne-text">阿里云盘</span></a></li></ul><details class="lake-collapse"><summary id="uae0c24ef"><strong><span class="ne-text">非必须环境</span></strong></summary><ul class="ne-tl"><li id="u150419f7" data-lake-index-type="0"><span class="ne-text">onedrive云盘</span></li><li id="u3cf2a668" data-lake-index-type="0"><span class="ne-text">夸克网盘</span></li></ul></details><h3 id="36e56c01"><span class="ne-text">2.5 通用软件</span></h3><ul class="ne-tl"><li checked="true" id="u0edcffea" data-lake-index-type="0"><a href="https://music.163.com/#/download" data-href="https://music.163.com/#/download" target="_blank" class="ne-link"><span class="ne-text">网易云</span></a></li><li checked="true" id="uf82f4273" data-lake-index-type="0"><a href="https://download.kugou.com/" data-href="https://download.kugou.com/" target="_blank" class="ne-link"><span class="ne-text">酷狗</span></a></li><li checked="true" id="ube311ec6" data-lake-index-type="0"><a href="https://im.qq.com/pcqq" data-href="https://im.qq.com/pcqq" target="_blank" class="ne-link"><span class="ne-text">QQ</span></a></li><li checked="true" id="u1ec75993" data-lake-index-type="0"><a href="https://weixin.qq.com/" data-href="https://weixin.qq.com/" target="_blank" class="ne-link"><span class="ne-text">微信</span></a></li><li id="ueb6b8b33" data-lake-index-type="0"><a href="https://dashi.163.com/download.html" data-href="https://dashi.163.com/download.html" target="_blank" class="ne-link"><span class="ne-text">网易邮箱大师</span></a></li></ul><ul class="ne-tl"><li id="u3f310ec7" data-lake-index-type="0"><a href="https://potplayer.daum.net/?lang=zh_CN" data-href="https://potplayer.daum.net/?lang=zh_CN" target="_blank" class="ne-link"><span class="ne-text">Potplayer</span></a></li><li id="u42c23f54" data-lake-index-type="0"><span class="ne-text">PDF阅读软件: Adobe Acrobat DC</span></li></ul><ul class="ne-tl"><li id="uebdab4a4" data-lake-index-type="0"><a href="https://consumer.huawei.com/cn/support/hisuite/" data-href="https://consumer.huawei.com/cn/support/hisuite/" target="_blank" class="ne-link"><span class="ne-text">华为手机助手</span></a></li></ul><ul class="ne-tl"><li id="u6484e5af" data-lake-index-type="0"><span class="ne-text">Rainmeter</span></li><li id="u738a3e83" data-lake-index-type="0"><span class="ne-text">steam</span></li><li id="uad671f08" data-lake-index-type="0"><span class="ne-text">Visio</span></li><li id="udd0b2de2" data-lake-index-type="0"><a href="https://authy.com/download/" data-href="https://authy.com/download/" target="_blank" class="ne-link"><span class="ne-text">Authy Desktop（二重验证）</span></a><span class="ne-text"></span></li><li checked="true" id="u9906dfa4" data-lake-index-type="0"><span class="ne-text">火萤桌面视频</span></li></ul></div>]]></content>
      
      
      <categories>
          
          <category> 计算机素养 </category>
          
          <category> 环境搭建 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>时间格式UTC、GMT、GST</title>
      <link href="/blog/delag2/"/>
      <url>/blog/delag2/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h2 id="ZR0ag"><span class="ne-text">一、三者区别与关系</span></h2><h3 id="e4d17160"><strong><span class="ne-text">UTC：世界标准时间</span></strong></h3><p id="f2dc20bcd4b1ec8addd104b0c97eac47" class="ne-p"><br></p><p id="d2d34a9a44184446cd02719245df29c7" class="ne-p"><span class="ne-text">协调世界时（英：Coordinated Universal Time ，法：Temps Universel Coordonné），又称世界统一时间，世界标准时间，国际协调时间。英文（CUT）和法文（TUC）的缩写不同，作为妥协，简称UTC。</span></p><p id="11ef24fd9196495d64c7529bf1353032" class="ne-p"><br></p><h3 id="07e95782"><strong><span class="ne-text">GMT：格林尼治时间</span></strong></h3><p id="6ce5585bf59dc3765fe77ca047ea9740" class="ne-p"><br></p><p id="490bee815e671a05cb33070e3fac9bec" class="ne-p"><span class="ne-text">世界时UT  即格林尼治时间，格林尼治所在地的标准时间。以地球自转为基础的时间计量系统。地球自转的角度可用地方子午线相对于地球上的基本参考点的运动来度量。为了测量地球自转，人们在地球上选取了两个基本参考点：春分点（见分至点）和平太阳，由此确定的时间分别称为恒星时和平太阳时。</span></p><p id="c436589a2e58c892e5273a316df7e27b" class="ne-p"><br></p><h3 id="213f0223"><strong><span class="ne-text">GST：北京时间</span></strong></h3><p id="72d83a4fca718a610f5690fef7d73aad" class="ne-p"><br></p><p id="db6d1fe855e6743050a572e8b5eb5666" class="ne-p"><span class="ne-text">在数据库中存放，或者给用户看的时间都是GST时间</span></p><p id="64bdd6b2d78bd3000f5284d28f5e587b" class="ne-p"><br></p><h3 id="86f348c0"><strong><span class="ne-text">UTC和GST</span></strong></h3><p id="a3aa6246d5073cb7f4973183ea17206f" class="ne-p"><br></p><p id="219f840783b3ff83b068c7f21d59b6db" class="ne-p"><span class="ne-text">中国北京市的时间比UTC</span><strong><span class="ne-text">早</span></strong><span class="ne-text"> 8 小时</span></p><p id="d5f23a90480bbbe4ec2bd2afd274a289" class="ne-p"><br></p><h2 id="871be4c6"><strong><span class="ne-text">二、UTC与GST之间的转换</span></strong></h2><p id="74e97223e5c9be510bf9290b9851d19c" class="ne-p"><br></p><h3 id="ac8a4f56"><span class="ne-text">理解</span></h3><p id="553debbfde8add12847f34445aeb510c" class="ne-p"><br></p><div class="ne-quote"><p id="bb9282fdbc3e966abbd1cde839adaf80" class="ne-p"><span class="ne-text">2020-05-23T01:12:19.602Z</span></p></div><p id="9eaa499c79d29e4c3d4bdd039ec54dd2" class="ne-p"><br></p><ul class="ne-ul"><li id="676a1a3f76863ae0a848cfaedc872431"><span class="ne-text">T：他表示后面跟的时间</span></li><li id="6183113db5a5966d0ab57188975aa088"><span class="ne-text">Z：表示UTC统一时间</span></li><li id="d3af0d669756ee8763c4d79eefb64c54"><span class="ne-text">602：表示毫秒，如果为6020，最后得到的时间，秒会增加1秒。000Z意思就是 0毫秒  utc统一时间</span></li></ul><p id="d2797006e0f8b29e29a89fc88f3ab4c7" class="ne-p"><br></p><h3 id="dc06252c"><span class="ne-text">java实现</span></h3><p id="24ae5ed0f50a0c0acbbeff8b0718cbba" class="ne-p"><br></p><pre><code>package website;<p>import java.text.*;<br>import java.util.Date;</p><p>public class UTC_GST &#123;<br>    public static void main(String[] args) throws ParseException &#123;</p><pre><code>    String date = &amp;quot;2020-05-23T20:12:19.602Z&amp;quot;;    date = date.replace(&amp;quot;Z&amp;quot;, &amp;quot; UTC&amp;quot;);    System.out.println(&amp;quot;输入的UTC格式数据为：&amp;quot;+date);        SimpleDateFormat format = new SimpleDateFormat(&amp;quot;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSS Z&amp;quot;);    Date d = format.parse(date);    System.out.println(&amp;quot;输出的背景格式数据为：&amp;quot;+d);    &#125;</code></pre><p>}<br></code></pre></p><p id="960563780a70e24311a2d92263c509d2" class="ne-p"><br></p><pre><code>输入的UTC格式数据为：2020-05-23T20:12:19.602 UTC输出的背景格式数据为：Sun May 24 04:12:19 CST 2020</code></pre><p id="881306f2187ec1f53ec678fe2fe11943" class="ne-p"><br></p><pre><code>package website;<p>import java.text.SimpleDateFormat;<br>import java.util.Date;</p><p>public class Format &#123;<br>    public static void main(String[] args) &#123;</p><pre><code>    Date ss = new Date();    System.out.println(&amp;quot;一般日期输出：&amp;quot; + ss);    System.out.println(&amp;quot;toString日期输出：&amp;quot; + ss.toString());    System.out.println(&amp;quot;时间戳：&amp;quot; + ss.getTime()+&amp;quot;\n&amp;quot;); // getTime返回的是1970年1月1号至今流逝的时间     //Date aw = Calendar.getInstance().getTime();//获得时间的另一种方式，测试效果一样        SimpleDateFormat format0 = new SimpleDateFormat(&amp;quot;yyyy-MM-dd HH:mm:ss&amp;quot;);    String time = format0.format(ss.getTime());//这个就是把时间戳经过处理得到期望格式的时间    System.out.println(&amp;quot;格式化结果0：&amp;quot; + time + &amp;quot;\n&amp;quot;);        SimpleDateFormat format1 = new SimpleDateFormat(&amp;quot;yyyy年MM月dd日 HH时mm分ss秒&amp;quot;);    time = format1.format(ss.getTime());    System.out.println(&amp;quot;格式化结果1：&amp;quot; + time + &amp;quot;\n&amp;quot;);&#125;</code></pre><p>}<br></code></pre></p><p id="c99c2436480b0b9dbf0fc97e1cdf24d2" class="ne-p"><br></p><pre><code>一般日期输出：Sat May 23 15:03:25 CST 2020toString日期输出：Sat May 23 15:03:25 CST 2020时间戳：1590217405777<p>格式化结果0：2020-05-23 15:03:25</p><p>格式化结果1：2020年05月23日 15时03分25秒<br></code></pre></p></div>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
          <category> 数据分析 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Pandas库使用——基础知识</title>
      <link href="/blog/li8bkt/"/>
      <url>/blog/li8bkt/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h2 id="Zj5wq"><span class="ne-text">一、Pandas数据结构</span></h2><pre><code>import pandas as pd</code></pre><p id="64598c6647357a991a7aeda728c24565" class="ne-p"><br></p><h3 id="Series"><span class="ne-text">Series</span></h3><p id="81a7898e1a18038391463c044043e249" class="ne-p"><br></p><div class="ne-quote"><ol class="ne-ol"><li id="595fc87a6ac842e606abc1431145149d"><span class="ne-text">通过list构建Series</span></li></ol></div><p id="a3b3a6df45405a4e1672bf3546454f28" class="ne-p"><br></p><pre><code>ser_obj = pd.Series(range(10, 20,2))print (type(ser_obj))print(ser_obj)</code></pre><p id="f462a0c9cba1c8837e2a412c23a602ec" class="ne-p"><br></p><pre><code>&lt;class 'pandas.core.series.Series'&gt;0    101    122    143    164    18dtype: int64</code></pre><p id="867a54850090293c3454d4d223a1c817" class="ne-p"><br></p><pre><code># 获取数据print (ser_obj.values)<h1 id="获取索引"><a href="#获取索引" class="headerlink" title="获取索引"></a>获取索引</h1><p>print (ser_obj.index)<br>#范围索引数据类型</p><h1 id="预览数据"><a href="#预览数据" class="headerlink" title="预览数据"></a>预览数据</h1><p>print (ser_obj.head(3))<br>#默认输出五行<br></code></pre></p><p id="a16e7e17ba3b650c95491b4694181df3" class="ne-p"><br></p><pre><code>[10 12 14 16 18]RangeIndex(start=0, stop=5, step=1)0    101    122    14dtype: int64</code></pre><p id="37bed406f3295d67975e6ee5109d6c29" class="ne-p"><br></p><div class="ne-quote"><ol start="2" class="ne-ol"><li id="6a12031f0d9b708357c35cb2de39abc2"><span class="ne-text">通过dict构建Series</span></li></ol></div><p id="61b2c553c683ae4526c7f464928e9ae8" class="ne-p"><br></p><pre><code>year_data = &#123;2001: 17.8, 2002: 20.1, 2003: 16.5,2004:324,2423:243&#125;ser_obj2 = pd.Series(year_data)print (ser_obj2.head(2))print (ser_obj2.index)print(ser_obj2)</code></pre><p id="c843671f361878b033c4be85aba57cca" class="ne-p"><br></p><pre><code>2001    17.82002    20.1dtype: float64Int64Index([2001, 2002, 2003, 2004, 2423], dtype='int64')2001     17.82002     20.12003     16.52004    324.02423    243.0dtype: float64</code></pre><p id="c651e2c3276a13d5e8f5f070d19af4c8" class="ne-p"><br></p><pre><code># name属性【【【【【出问题了！！！】】】】】ser_obj2.name = '钱'ser_obj2.index.name = 'year'print (ser_obj2.head())</code></pre><p id="ee6934764425275e489856f62ff2ad54" class="ne-p"><br></p><pre><code>year2001     17.82002     20.12003     16.52004    324.02423    243.0Name: 钱, dtype: float64</code></pre><p id="4256388e88f01a1d5bb186da7ddf17ea" class="ne-p"><br></p><h3 id="DataFrame"><span class="ne-text">DataFrame</span></h3><p id="af86fb91a5ca2fb88f034dbe5866eebb" class="ne-p"><br></p><div class="ne-quote"><ol class="ne-ol"><li id="9e36348a1fe37c2e77344588212ebf88"><span class="ne-text">通过ndarray构建DataFrame</span></li></ol></div><p id="e3c16ed248fb0d5b06fe413dc77eb7f8" class="ne-p"><br></p><pre><code>import numpy as np<p>array = np.random.rand(5,4)<br>print (array)</p><p>df_obj = pd.DataFrame(array,columns=[‘a’,’b’,’c’,’d’])<br>print (df_obj.head())<br>print(df_obj.sort_values(by=’a’, ascending=False))<br></code></pre></p><p id="52c3155a83e623f4215f5166e1656369" class="ne-p"><br></p><pre><code>[[0.23496522 0.92258429 0.36447462 0.52634697] [0.73743514 0.88175941 0.48944212 0.4173522 ] [0.21214568 0.57148666 0.59496072 0.49490723] [0.7458542  0.74743907 0.70475157 0.28130394] [0.43805937 0.90300134 0.00730653 0.68203725]]          a         b         c         d0  0.234965  0.922584  0.364475  0.5263471  0.737435  0.881759  0.489442  0.4173522  0.212146  0.571487  0.594961  0.4949073  0.745854  0.747439  0.704752  0.2813044  0.438059  0.903001  0.007307  0.682037          a         b         c         d3  0.745854  0.747439  0.704752  0.2813041  0.737435  0.881759  0.489442  0.4173524  0.438059  0.903001  0.007307  0.6820370  0.234965  0.922584  0.364475  0.5263472  0.212146  0.571487  0.594961  0.494907</code></pre><p id="37892e6046ec4a72e3651fc6ccf5b91a" class="ne-p"><br></p><div class="ne-quote"><ol start="2" class="ne-ol"><li id="6fd033f73c60a22a7c7856115e2f6294"><span class="ne-text">通过dict构建DataFrame</span></li></ol></div><p id="f1e0fbc6f41eda70e1287a72a742c1fc" class="ne-p"><br></p><pre><code>#一个键值对就相当于一列！！但是具体到字典里面的值所用到的一些函数还是不能很清楚dict_data = &#123;'A': 1.,              'B': pd.Timestamp('20161217'),             'C': pd.Series(1, index=list(range(4)),dtype='float32'),             'D': np.array([3] * 4,dtype='int32'),             'E' : pd.Categorical([&quot;Python&quot;,&quot;Java&quot;,&quot;C++&quot;,&quot;C#&quot;]),             'F' : 'ChinaHadoop' &#125;df_obj2 = pd.DataFrame(dict_data)print (df_obj2.head())</code></pre><p id="3c92a21f44121ca5734c1601936a901a" class="ne-p"><br></p><pre><code>     A          B    C  D       E            F0  1.0 2016-12-17  1.0  3  Python  ChinaHadoop1  1.0 2016-12-17  1.0  3    Java  ChinaHadoop2  1.0 2016-12-17  1.0  3     C++  ChinaHadoop3  1.0 2016-12-17  1.0  3      C#  ChinaHadoop</code></pre><p id="7d77e458dc5484b333953bb9e9fb40eb" class="ne-p"><br></p><pre><code># 增加列df_obj2['G'] = df_obj2['D'] + 4print (df_obj2.head())xxx = pd.DataFrame(df_obj2,columns=['A','B','C','D','E','F','G','H'],index=[0,1,2,3,4])print(xxx)</code></pre><p id="cb400dc63863cf7a006b70f30ff68d40" class="ne-p"><br></p><pre><code>     A          B    C  D       E            F  G0  1.0 2016-12-17  1.0  3  Python  ChinaHadoop  71  1.0 2016-12-17  1.0  3    Java  ChinaHadoop  72  1.0 2016-12-17  1.0  3     C++  ChinaHadoop  73  1.0 2016-12-17  1.0  3      C#  ChinaHadoop  7     A          B    C    D       E            F    G   H0  1.0 2016-12-17  1.0  3.0  Python  ChinaHadoop  7.0 NaN1  1.0 2016-12-17  1.0  3.0    Java  ChinaHadoop  7.0 NaN2  1.0 2016-12-17  1.0  3.0     C++  ChinaHadoop  7.0 NaN3  1.0 2016-12-17  1.0  3.0      C#  ChinaHadoop  7.0 NaN4  NaN        NaT  NaN  NaN     NaN          NaN  NaN NaN</code></pre><p id="afee90e9c536669026b735adf77486d9" class="ne-p"><br></p><h3 id="Index"><span class="ne-text">Index</span></h3><p id="aa0dd744f83a8a9e13c0df361272a804" class="ne-p"><br></p><pre><code>print (type(ser_obj.index))print (type(df_obj2.index))<p>print (df_obj2.index)<br></code></pre></p><p id="7eed9c93342f7efbc7d001b7fe8c03ab" class="ne-p"><br></p><pre><code>&lt;class 'pandas.core.indexes.range.RangeIndex'&gt;&lt;class 'pandas.core.indexes.numeric.Int64Index'&gt;Int64Index([0, 1, 2, 3], dtype='int64')</code></pre><p id="74087c11e0999852099cdc9ef3d9efff" class="ne-p"><br></p><pre><code># 索引对象不可变df_obj2.index[0] = 2</code></pre><p id="4f580ce71ad1527d01d87f0ed52c0d59" class="ne-p"><br></p><pre><code>---------------------------------------------------------------------------<p>TypeError                                 Traceback (most recent call last)</p><p>&lt;ipython-input-10-6367894e76d8&gt; in &lt;module&gt;<br>      1 # 索引对象不可变<br>—-&gt; 2 df_obj2.index[0] = 2</p><p>~\Anaconda3\lib\site-packages\pandas\core\indexes\base.py in <strong>setitem</strong>(self, key, value)<br>   4258<br>   4259     def <strong>setitem</strong>(self, key, value):<br>-&gt; 4260         raise TypeError(&quot;Index does not support mutable operations&quot;)<br>   4261<br>   4262     def <strong>getitem</strong>(self, key):</p><p>TypeError: Index does not support mutable operations<br></code></pre></p><p id="f1d1b709a9ae55db1577a0d5e804ef2a" class="ne-p"><br></p><span id="python"></span><p id="9f9feacbbe1d6904748682e48d864f9d" class="ne-p"><br></p><h2 id="00f40f54"><span class="ne-text">二、Pandas数据操作</span></h2><p id="c8145203e9bb082405f112fec0399d80" class="ne-p"><br></p><h3 id="63421879"><span class="ne-text">常用函数总结</span></h3><p id="227fe566e3117c1ad2d257bb135230aa" class="ne-p"><br></p><div class="ne-quote"><p id="030a4cdcd69b7e00d9a772425ccd6c72" class="ne-p"><span class="ne-text">·shape  获取数据的尺寸</span></p></div><p id="c395b366d0c5a8d51b90e47f0e128293" class="ne-p"><br></p><pre><code> 获得df的size：df.shape 获得df中的行数：df.shape[0] 获得df中的列数： df.shape[1] 获得行索引信息：df.index 获得列索引信息：df.colomns</code></pre><p id="1764c30a157dbd2c2622f65d511d4466" class="ne-p"><br></p><div class="ne-quote"><p id="4f872c1735a10d292a72d19e28b11e90" class="ne-p"><span class="ne-text">·values  获得df中的值===中文没用</span></p></div><p id="b79b055d747cced8a2d5d9c7ed45c5c0" class="ne-p"><br></p><pre><code>df.values === 以列表的形式展现出来，去除了索引===dataframe类型数据转换成array类型</code></pre><p id="1c74a235565230d15bef5aeb5c7a63b8" class="ne-p"><br></p><div class="ne-quote"><p id="61c69c64f105fa552561967eb4ebd891" class="ne-p"><span class="ne-text">·setindex和resetindex</span></p></div><p id="476d0ffe5598a8157c0bf2a747e8e037" class="ne-p"><br></p><pre><code>reset_index可以还原索引，从新变为默认的整型索引     DataFrame.reset_index(level=None, drop=False, inplace=False, col_level=0, col_fill=”)     level控制了具体要还原的那个等级的索引     drop为False则索引列会被还原为普通列，否则会丢失set_index方法，设置单索引和复合索引抑或是添加索引。     DataFrame.set_index(keys, drop=True, append=False, inplace=False, verify_integrity=False)     append添加新索引，drop为False，inplace为True时，索引将会还原为列</code></pre><p id="3d0b56fa7f6c54be0af81c7da92afb5d" class="ne-p"><br></p><div class="ne-quote"><p id="be9a0c0e9a05e861b67d78e1265ce5ba" class="ne-p"><span class="ne-text">·iterrows（）遍历DataFrame中的数据</span></p></div><p id="2085ec4d8885af04f903986e508b0318" class="ne-p"><br></p><pre><code>for index,row in df.iterrows():</code></pre><p id="0896b7932167ac4e6881066c2421395f" class="ne-p"><br></p><div class="ne-quote"><p id="e98fb020ffb27d4b399c1df48444ac31" class="ne-p"><span class="ne-text">·split(sep,n,expand=false)</span></p></div><p id="b168adb52493a4e1d42e107f9a70bea9" class="ne-p"><br></p><pre><code>sep表示用于分割的字符；n表格分割成多少列；expand表示是否展开为数据款，True输出Series，False输出Dataframe。字段拆分：是指按照固定的字符，拆分已有字符串</code></pre><p id="1f0bff324cbbc0a706fe24efd2d14f86" class="ne-p"><br></p><pre><code>import pandas as pdimport numpy as np</code></pre><p id="62e68dc6988b91ce15233ab71f8ac8ba" class="ne-p"><br></p><h3 id="548cb2e7"><span class="ne-text">匿名函数应用</span></h3><p id="4d385ea0b72df561c9ede1550790f380" class="ne-p"><br></p><pre><code># Numpy ufunc 函数df = pd.DataFrame(np.random.randn(5,4) - 1)print (df)<p>print (np.abs(df))<br></code></pre></p><p id="bdb01dab77cb0e059bdbb14885331a46" class="ne-p"><br></p><pre><code>          0         1         2         30  0.624016 -2.695175 -1.211426 -0.3861511 -1.335385 -1.315232 -0.305902 -0.3613482 -0.349443 -2.032110  0.075995 -0.9667253 -1.631192 -1.051390 -1.767981 -0.3666634 -0.786178 -0.335846 -0.797992 -0.931216          0         1         2         30  0.624016  2.695175  1.211426  0.3861511  1.335385  1.315232  0.305902  0.3613482  0.349443  2.032110  0.075995  0.9667253  1.631192  1.051390  1.767981  0.3666634  0.786178  0.335846  0.797992  0.931216</code></pre><p id="282b53ed88d89f06ecccfc583566c5bc" class="ne-p"><br></p><pre><code># 使用apply应用行或列数据f = lambda x : x.max()print (df.apply(f))</code></pre><p id="a6263942dadc12148255472c4a074ca6" class="ne-p"><br></p><pre><code>0    0.6240161   -0.3358462    0.0759953   -0.361348dtype: float64</code></pre><p id="6c1efbacd97b957dab5d707e05bb080c" class="ne-p"><br></p><pre><code># 指定轴方向print (df.apply(f, axis=1))</code></pre><p id="895376894be37cc403c587c8306c4a05" class="ne-p"><br></p><pre><code>0    0.6240161   -0.3059022    0.0759953   -0.3666634   -0.335846dtype: float64</code></pre><p id="a1dca7860d574a9bd09099306b4cf69b" class="ne-p"><br></p><pre><code># 使用applymap应用到每个数据f2 = lambda x : '%.2f' % xprint (df.applymap(f2))</code></pre><p id="a0ccbf54ee1222d18a92df19d90b4642" class="ne-p"><br></p><pre><code>       0      1      2      30   0.62  -2.70  -1.21  -0.391  -1.34  -1.32  -0.31  -0.362  -0.35  -2.03   0.08  -0.973  -1.63  -1.05  -1.77  -0.374  -0.79  -0.34  -0.80  -0.93</code></pre><p id="5c58c9b67e870902430c102b72efefc3" class="ne-p"><br></p><h3 id="c360e994"><span class="ne-text">排序</span></h3><p id="fa019d431a8e2900fbaf1cf42eee0f85" class="ne-p"><br></p><pre><code>s4 = pd.Series(range(10, 15), index = np.random.randint(5, size=5))print (s4)</code></pre><p id="a9738ba952913a34f56a903262a9e42a" class="ne-p"><br></p><pre><code>4    101    114    121    131    14dtype: int64</code></pre><p id="2d7974e77d711e32ef0d2f173e4e5a42" class="ne-p"><br></p><div class="ne-quote"><ol class="ne-ol"><li id="b787c42fb378cdd230e7f18152d9fc6e"><span class="ne-text">索引排序</span></li></ol></div><p id="361e603592d19c7f51bf6ec830187a07" class="ne-p"><br></p><pre><code>s4.sort_index()</code></pre><p id="bce8bb3f2f05af2e6f3b5e82c6d907b5" class="ne-p"><br></p><pre><code>1    111    131    144    104    12dtype: int64</code></pre><p id="fdcbe02b1e3e11f97da18f03c09cafc6" class="ne-p"><br></p><pre><code>df4 = pd.DataFrame(np.random.randn(3, 4),                    index=np.random.randint(3, size=3),                   columns=np.random.randint(4, size=4))</code></pre><p id="c4e6e18691e543baf3d74d00fed4b062" class="ne-p"><br></p><pre><code>df4</code></pre><p id="526a8fb83681027ff62d0ad46d8e5bda" class="ne-p"><br></p><table id="54465905" class="ne-table" style="width: 750px"><tbody><tr style="height: 33px"><td width="150"></td><td width="150"><p id="u3d60c20c" class="ne-p"><span class="ne-text">2</span></p></td><td width="150"><p id="ua972c94c" class="ne-p"><span class="ne-text">1</span></p></td><td width="150"><p id="uacc282b0" class="ne-p"><span class="ne-text">3</span></p></td><td width="150"><p id="ua57c2184" class="ne-p"><span class="ne-text">1</span></p></td></tr><tr style="height: 33px"><td width="150"><p id="u7bdafe09" class="ne-p"><span class="ne-text">0</span></p></td><td width="150"><p id="u9e0fb881" class="ne-p"><span class="ne-text">0.007031</span></p></td><td width="150"><p id="u49092440" class="ne-p"><span class="ne-text">1.261990</span></p></td><td width="150"><p id="u66f07d12" class="ne-p"><span class="ne-text">-1.647929</span></p></td><td width="150"><p id="u85a3eb8e" class="ne-p"><span class="ne-text">0.176549</span></p></td></tr><tr style="height: 33px"><td width="150"><p id="u4cb2dc62" class="ne-p"><span class="ne-text">1</span></p></td><td width="150"><p id="u01e0bde4" class="ne-p"><span class="ne-text">-2.510698</span></p></td><td width="150"><p id="ud88fce81" class="ne-p"><span class="ne-text">-0.207659</span></p></td><td width="150"><p id="u469ebb03" class="ne-p"><span class="ne-text">0.628221</span></p></td><td width="150"><p id="u9170bc0d" class="ne-p"><span class="ne-text">0.441352</span></p></td></tr><tr style="height: 33px"><td width="150"><p id="ue2d6a948" class="ne-p"><span class="ne-text">0</span></p></td><td width="150"><p id="u257d4c82" class="ne-p"><span class="ne-text">-0.367051</span></p></td><td width="150"><p id="u4367bd13" class="ne-p"><span class="ne-text">1.536606</span></p></td><td width="150"><p id="uc2aede5c" class="ne-p"><span class="ne-text">0.167158</span></p></td><td width="150"><p id="u8de9c1a3" class="ne-p"><span class="ne-text">-0.236129</span></p></td></tr></tbody></table><p id="13d7a0400e4a39d2d79ad7b303c5920a" class="ne-p"><br></p><pre><code>#df4.sort_index(ascending=False)df4.sort_index(axis=1)</code></pre><p id="2a4ec755389ca2de29727be4924b1904" class="ne-p"><br></p><table id="aae8b8e6" class="ne-table" style="width: 750px"><tbody><tr style="height: 33px"><td width="150"></td><td width="150"><p id="u48c95b51" class="ne-p"><span class="ne-text">1</span></p></td><td width="150"><p id="udf0a3f71" class="ne-p"><span class="ne-text">1</span></p></td><td width="150"><p id="uc27cd52b" class="ne-p"><span class="ne-text">2</span></p></td><td width="150"><p id="u308e210e" class="ne-p"><span class="ne-text">3</span></p></td></tr><tr style="height: 33px"><td width="150"><p id="ue1fbb30e" class="ne-p"><span class="ne-text">0</span></p></td><td width="150"><p id="u567adc0b" class="ne-p"><span class="ne-text">1.261990</span></p></td><td width="150"><p id="uc597078f" class="ne-p"><span class="ne-text">0.176549</span></p></td><td width="150"><p id="ub1a8ae11" class="ne-p"><span class="ne-text">0.007031</span></p></td><td width="150"><p id="u34935057" class="ne-p"><span class="ne-text">-1.647929</span></p></td></tr><tr style="height: 33px"><td width="150"><p id="ua924ba9d" class="ne-p"><span class="ne-text">1</span></p></td><td width="150"><p id="ua216e706" class="ne-p"><span class="ne-text">-0.207659</span></p></td><td width="150"><p id="u69a8d6c8" class="ne-p"><span class="ne-text">0.441352</span></p></td><td width="150"><p id="ucbf04447" class="ne-p"><span class="ne-text">-2.510698</span></p></td><td width="150"><p id="u030c1b4b" class="ne-p"><span class="ne-text">0.628221</span></p></td></tr><tr style="height: 33px"><td width="150"><p id="u41f66984" class="ne-p"><span class="ne-text">0</span></p></td><td width="150"><p id="u75652155" class="ne-p"><span class="ne-text">1.536606</span></p></td><td width="150"><p id="u79340f36" class="ne-p"><span class="ne-text">-0.236129</span></p></td><td width="150"><p id="u3c43abba" class="ne-p"><span class="ne-text">-0.367051</span></p></td><td width="150"><p id="u541220e8" class="ne-p"><span class="ne-text">0.167158</span></p></td></tr></tbody></table><p id="13be3f79fc3c94206791985e9fec0344" class="ne-p"><br></p><div class="ne-quote"><ol start="2" class="ne-ol"><li id="1805359db39da03074933e07617e6c0c"><span class="ne-text">按值排序</span></li></ol></div><p id="f6084774bc518891332d7a1628637230" class="ne-p"><br></p><pre><code>#df.sortvalues(by='a', ascending=False) === 通过a的值#    作用是对选定的一列数值（'a'）数据从上往下从小到大进行排序（如果传值没成功===设置本体覆盖，传值覆盖）df4.sort_values(by=1)</code></pre><p id="255ab5286c37fbbc409790403455a290" class="ne-p"><br></p><pre><code>---------------------------------------------------------------------------<p>ValueError                                Traceback (most recent call last)</p><p>&lt;ipython-input-22-36ffa8ddd07d&gt; in &lt;module&gt;<br>      2 #df.sortvalues(by=’a’, ascending=False) === 通过a的值<br>      3 #    作用是对选定的一列数值（’a’）数据从上往下从小到大进行排序（如果传值没成功===设置本体覆盖，传值覆盖）<br>—-&gt; 4 df4.sort_values(by=1)</p><p>~\Anaconda3\lib\site-packages\pandas\core\frame.py in sort_values(self, by, axis, ascending, inplace, kind, na_position)<br>   4991<br>   4992             by = by[0]<br>-&gt; 4993             k = self._get_label_or_level_values(by, axis=axis)<br>   4994<br>   4995             if isinstance(ascending, (tuple, list)):</p><p>~\Anaconda3\lib\site-packages\pandas\core\generic.py in _get_label_or_level_values(self, key, axis)<br>   1795                     key=key,<br>   1796                     label_axis_name=label_axis_name,<br>-&gt; 1797                     multi_message=multi_message,<br>   1798                 )<br>   1799             )</p><p>ValueError: The column label ‘1’ is not unique.<br></code></pre></p><p id="35f1ee2ed50d88c39dfd98e4bf1896d3" class="ne-p"><br></p><span id="python-1"></span></div>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
          <category> 数据分析 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Numpy库使用</title>
      <link href="/blog/mk2z96/"/>
      <url>/blog/mk2z96/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h2 id="5dda6113"><span class="ne-text">一、NumPy</span></h2><h3 id="c974c4cf"><span class="ne-text">ndarray 理解多维数组</span></h3><p id="9f70acbd729b36a9550c3da1acdf3cca" class="ne-p"><br></p><pre><code>import numpy as np<h1 id="生成指定维度的随机多维数据"><a href="#生成指定维度的随机多维数据" class="headerlink" title="生成指定维度的随机多维数据"></a>生成指定维度的随机多维数据</h1><p>#数学建模应该用不到<br>data = np.random.rand(2, 3)<br>print (data)<br>print (type(data))<br>#type是显示数据类型；shape显示维度；ndim维度个数;type另外的作用<br></code></pre></p><p id="07d42de244aa1fb833b377a8665b3cc1" class="ne-p"><br></p><pre><code>[[0.46686682 0.68844304 0.76663872] [0.70747721 0.47887587 0.25943412]]&lt;class 'numpy.ndarray'&gt;</code></pre><p id="924326de9382f2a656033f0f039d6643" class="ne-p"><br></p><div class="ne-quote"><p id="da3825b347a4453dee4080f62645940b" class="ne-p"><span class="ne-text">ndim, shape 和 dtype 属性</span></p></div><p id="1444c16d449be0b1f2efbbccab430e2d" class="ne-p"><br></p><pre><code>print ('维度个数', data.ndim)print ('各维度大小: ', data.shape)print ('数据类型: ', data.dtype)</code></pre><p id="82aca8ecf8229d0e7c410b658dbe1f6b" class="ne-p"><br></p><pre><code>维度个数 2各维度大小:  (2, 3)数据类型:  float64</code></pre><p id="33bec1f6cb39ce4363a114d9b2aa6553" class="ne-p"><br></p><h3 id="c774ee7b"><span class="ne-text">创建ndarray</span></h3><p id="8387622836f4affadaac98f63b7a0c37" class="ne-p"><br></p><pre><code>'''1. array创建'''# list转换为 ndarrayl = range(10)data = np.array(l)print (data)print (data.shape)print (data.ndim)</code></pre><p id="e28071517cf66555a1ba01c9bda0e43e" class="ne-p"><br></p><pre><code>[0 1 2 3 4 5 6 7 8 9](10,)1</code></pre><p id="a470ceb0a563ee753b83f6440d4d275b" class="ne-p"><br></p><pre><code># 嵌套序列转换为ndarrayl2 = [range(10), range(10)]#就这样形成了一个数组data = np.array(l2)print (data)print (data.shape)</code></pre><p id="974aae87a659606e931232d92865e517" class="ne-p"><br></p><pre><code>[[0 1 2 3 4 5 6 7 8 9] [0 1 2 3 4 5 6 7 8 9]](2, 10)</code></pre><p id="3a70740bfdc4ca08738c281a5c097fc9" class="ne-p"><br></p><pre><code>'''2. zeros;ones;empty创建'''<h1 id="np-zeros"><a href="#np-zeros" class="headerlink" title="np.zeros"></a>np.zeros</h1><p>zeros_arr = np.zeros((3, 4))<br>#注意元组，这里经常报错</p><h1 id="np-ones"><a href="#np-ones" class="headerlink" title="np.ones"></a>np.ones</h1><p>ones_arr = np.ones((2, 3))</p><h1 id="np-empty-不全为零，而且是随机的一些数字"><a href="#np-empty-不全为零，而且是随机的一些数字" class="headerlink" title="np.empty[不全为零，而且是随机的一些数字]"></a>np.empty[不全为零，而且是随机的一些数字]</h1><p>empty_arr = np.empty((3, 3))</p><h1 id="np-empty-指定数据类型"><a href="#np-empty-指定数据类型" class="headerlink" title="np.empty 指定数据类型"></a>np.empty 指定数据类型</h1><p>empty_int_arr = np.empty((3, 3), int)</p><p>print (zeros_arr)<br>print (‘————-‘)<br>print (ones_arr)<br>print (‘————-‘)<br>print (empty_arr)<br>print (‘————-‘)<br>print (empty_int_arr)<br></code></pre></p><p id="ab801385f72967ebf3c91fa514400330" class="ne-p"><br></p><pre><code>[[0. 0. 0. 0.] [0. 0. 0. 0.] [0. 0. 0. 0.]]-------------[[1. 1. 1.] [1. 1. 1.]]-------------[[0.000e+000 0.000e+000 0.000e+000] [0.000e+000 0.000e+000 2.174e-321] [0.000e+000 0.000e+000 0.000e+000]]-------------[[0 0 0] [0 0 0] [0 0 0]]</code></pre><p id="261d294fc6b68e7ec8a03998dac8cc87" class="ne-p"><br></p><pre><code># np.arange()#创建一系列连续的数算是numpy里面类似python里面range的功能print (np.arange(10))</code></pre><p id="d89e37e1e82664c45661497492c93b6b" class="ne-p"><br></p><pre><code>[0 1 2 3 4 5 6 7 8 9]</code></pre><p id="b93b188a587362374f6073381039a19a" class="ne-p"><br></p><h2 id="cedb2184"><span class="ne-text">二、操作nddarray</span></h2><p id="e85630f7171ce0ac05e544139727e542" class="ne-p"><br></p><h3 id="0e0c1ff0"><span class="ne-text">矢量化 (vectorization)</span></h3><p id="4a2ff1b6092c45db28a61a978b9e2fbd" class="ne-p"><br></p><pre><code># 矢量与矢量运算arr = np.array([[1, 2, 3],                [4, 5, 6]])<p>print (&quot;元素之间相乘：&quot;)<br>#注意区分矩阵之间的运算。这里的矢量原酸相当于是广播式的运算<br>print (arr * arr)</p><p>print (&quot;矩阵相加：&quot;)<br>print (arr + arr)<br></code></pre></p><p id="081a9aa3cd7e2cf2223a71ee18cf1c5d" class="ne-p"><br></p><pre><code>元素之间相乘：[[ 1  4  9] [16 25 36]]矩阵相加：[[ 2  4  6] [ 8 10 12]]</code></pre><p id="3115c158cbe32ab1ef50e2413f48cf4a" class="ne-p"><br></p><pre><code># 矢量与标量运算print (1. / arr)print (2. * arr)</code></pre><p id="97d65a13721f6408e8efee0baaf1f599" class="ne-p"><br></p><pre><code>[[1.         0.5        0.33333333] [0.25       0.2        0.16666667]][[ 2.  4.  6.] [ 8. 10. 12.]]</code></pre><p id="5169a002f9b59ecd2c6126932bc57eb7" class="ne-p"><br></p><h3 id="7e64e175"><span class="ne-text">索引与切片</span></h3><p id="7fb186f67058cd0d01b845c64926659d" class="ne-p"><br></p><pre><code># 一维数组arr1 = np.arange(10)print (arr1)<p>print (arr1[2:5])<br></code></pre></p><p id="a0cd79f720336ff7de907a13d1b3535a" class="ne-p"><br></p><pre><code>[0 1 2 3 4 5 6 7 8 9][2 3 4]</code></pre><p id="93bc9543ed6f1f3e1fabd55651fb321c" class="ne-p"><br></p><pre><code># 多维数组arr2 = np.arange(12).reshape(3,4)#要学会定义多维数组，arange是形成12个随机数，之后的reshape是形成维数#多维数组的空间含义就是比如：3.4.5=长4宽5高3#还有点数就是应用函数print (arr2)</code></pre><p id="5c77c9d0d8989e1bb8d0c3ae5d20ba4c" class="ne-p"><br></p><pre><code>[[ 0  1  2  3] [ 4  5  6  7] [ 8  9 10 11]]</code></pre><p id="4af02b2bbbc7fac5370aa084a8043520" class="ne-p"><br></p><pre><code>print (arr2[1])<p>print (arr2[0:2, 2:])</p><p>print (arr2[:, 1:3])<br></code></pre></p><p id="1a4eb13855ef542288c19a4aab2e4faf" class="ne-p"><br></p><pre><code>[4 5 6 7][[2 3] [6 7]][[ 1  2] [ 5  6] [ 9 10]]</code></pre><p id="f7542000dc5d71a98c68b90394782f3c" class="ne-p"><br></p><pre><code># 条件索引<h1 id="找出-data-arr-中-2015年后的数据"><a href="#找出-data-arr-中-2015年后的数据" class="headerlink" title="找出 data_arr 中 2015年后的数据"></a>找出 data_arr 中 2015年后的数据</h1><p>data_arr = np.random.rand(3,3)<br>print (data_arr)</p><p>year_arr = np.array([[2000, 2001, 2000],<br>                     [2005, 2002, 2009],<br>                     [2001, 2003, 2010]])</p><p>is_year_after_2005 = year_arr &gt;= 2005<br>#:他会扩展成同类型的数组<br>print (is_year_after_2005, is_year_after_2005.dtype)</p><p>filtered_arr = data_arr[is_year_after_2005]</p><p>filtered_arr = data_arr[year_arr &gt;= 2005]<br>print (filtered_arr)<br>#中间的一些语句可以删除<br>#最后生成得是一维数组，进行数据过滤的时候很有用<br></code></pre></p><p id="d9792b1e14647aa72aa727b15c52c8c1" class="ne-p"><br></p><pre><code>[[0.61482194 0.0249229  0.28525661] [0.05121173 0.37672803 0.86259463] [0.22648329 0.4581513  0.18620441]][[False False False] [ True False  True] [False False  True]] bool[0.05121173 0.86259463 0.18620441]</code></pre><p id="2504498c174d6be38a675139f015eacd" class="ne-p"><br></p><pre><code># 多个条件&amp; |filtered_arr = data_arr[(year_arr &lt;= 2005) &amp; (year_arr % 2 == 0)]print (filtered_arr)</code></pre><p id="b8a128a40897d47fbfe5deda15269edf" class="ne-p"><br></p><pre><code>[0.61482194 0.28525661 0.37672803]</code></pre><p id="64ac8a9c1b3d4e47cf770870a80c8d4d" class="ne-p"><br></p><h3 id="e673cd7d"><span class="ne-text">转置 === transpose</span></h3><p id="66629fa2baf1d46faafac6ea93e30087" class="ne-p"><br></p><pre><code>arr = np.random.rand(2,3)print (arr)print (arr.transpose())</code></pre><p id="3fcbcb528fb9ccc4f3cd3d38034984f5" class="ne-p"><br></p><pre><code>[[0.01538974 0.47573964 0.90684253] [0.93683601 0.64306611 0.63846634]][[0.01538974 0.93683601] [0.47573964 0.64306611] [0.90684253 0.63846634]]</code></pre><p id="58f6d1c9941dcb2c9fae3d4fbfc5d0b6" class="ne-p"><br></p><pre><code>#高维数组的转换(图像里面会用得到转换维度)<p>arr3d = np.random.rand(2,3,4)<br>print (arr3d)<br>print (‘———————-‘)<br>print (arr3d.transpose((1,0,2))) # 多维数组的转置和定义不会<br></code></pre></p><p id="81eb6a8e2b7bb4de3329fefb052cafd0" class="ne-p"><br></p><pre><code>[[[0.18074837 0.64652003 0.80527972 0.67800268]  [0.95766577 0.2498768  0.00304503 0.7058178 ]  [0.12523549 0.18796252 0.72463798 0.15352211]]<p> [[0.38808013 0.31075033 0.53082474 0.32254431]<br>  [0.6861262  0.02999367 0.70980993 0.09099878]<br>  [0.14987301 0.78237398 0.90159408 0.82897071]]]</p><hr><p>[[[0.18074837 0.64652003 0.80527972 0.67800268]<br>  [0.38808013 0.31075033 0.53082474 0.32254431]]</p><p> [[0.95766577 0.2498768  0.00304503 0.7058178 ]<br>  [0.6861262  0.02999367 0.70980993 0.09099878]]</p><p> [[0.12523549 0.18796252 0.72463798 0.15352211]<br>  [0.14987301 0.78237398 0.90159408 0.82897071]]]<br></code></pre></p><p id="6ba937e85438ed73cf67c1c075cba1af" class="ne-p"><br></p><h3 id="a43ab641"><span class="ne-text">ndarray数据类型转化 === astype</span></h3><p id="27511ff0b954eeef5dc8b93620941540" class="ne-p"><br></p><pre><code>zeros_float_arr = np.zeros((3, 4), dtype=np.float64)print (zeros_float_arr)print (zeros_float_arr.dtype)<h1 id="astype转换数据类型"><a href="#astype转换数据类型" class="headerlink" title="astype转换数据类型"></a>astype转换数据类型</h1><p>zeros_int_arr = zeros_float_arr.astype(np.int32)<br>print (zeros_int_arr)<br>print (zeros_int_arr.dtype)<br></code></pre></p><p id="b9ad655927fa6bdb2a76d5ec4548ccc0" class="ne-p"><br></p><pre><code>[[0. 0. 0. 0.] [0. 0. 0. 0.] [0. 0. 0. 0.]]float64[[0 0 0 0] [0 0 0 0] [0 0 0 0]]int32</code></pre><p id="757cd317887ffaf3a780a53985b17744" class="ne-p"><br></p><h3 id="97a6cf61"><span class="ne-text">文本文件的读取</span></h3><p id="1721f0356b7707fd1fbf1c646c0d9517" class="ne-p"><br></p><pre><code># loadtxtfilename = './presidential_polls.csv'data_array = np.loadtxt(filename,      # 文件名                        delimiter=',', # 指定里面的元素分隔符                        dtype=str,     # 指定数据类型                        usecols=(0,2,3)) # 指定读取的列索引号print (data_array, data_array.shape)</code></pre><p id="36a7e4b1748b43e95fd61d94d5e3729d" class="ne-p"><br></p><pre><code>[['cycle' 'type' 'matchup'] ['2016' '&quot;polls-plus&quot;' '&quot;Clinton vs. Trump vs. Johnson&quot;'] ['2016' '&quot;polls-plus&quot;' '&quot;Clinton vs. Trump vs. Johnson&quot;'] ... ['2016' '&quot;polls-only&quot;' '&quot;Clinton vs. Trump vs. Johnson&quot;'] ['2016' '&quot;polls-only&quot;' '&quot;Clinton vs. Trump vs. Johnson&quot;'] ['2016' '&quot;polls-only&quot;' '&quot;Clinton vs. Trump vs. Johnson&quot;']] (10237, 3)</code></pre><p id="09daec525a69a6e9ad33d1c1247315f6" class="ne-p"><br></p><pre><code># loadtxt, 明确指定每列数据的类型filename = './presidential_polls.csv'data_array = np.loadtxt(filename,      # 文件名                        delimiter=',', # 分隔符                        skiprows=1,                        dtype=&#123;'names':('cycle', 'type', 'matchup'),                               'formats':('i4', 'S15', 'S50')&#125;,     # 数据类型                        usecols=(0,2,3)) # 指定读取的列索引号<p>print (data_array, data_array.shape) # 读取的结果是一维的数组，每个元素是一个元组<br></code></pre></p><p id="c5a02cebaed6802aaa1ce221289ee6aa" class="ne-p"><br></p><pre><code>[(2016, b'&quot;polls-plus&quot;', b'&quot;Clinton vs. Trump vs. Johnson&quot;') (2016, b'&quot;polls-plus&quot;', b'&quot;Clinton vs. Trump vs. Johnson&quot;') (2016, b'&quot;polls-plus&quot;', b'&quot;Clinton vs. Trump vs. Johnson&quot;') ... (2016, b'&quot;polls-only&quot;', b'&quot;Clinton vs. Trump vs. Johnson&quot;') (2016, b'&quot;polls-only&quot;', b'&quot;Clinton vs. Trump vs. Johnson&quot;') (2016, b'&quot;polls-only&quot;', b'&quot;Clinton vs. Trump vs. Johnson&quot;')] (10236,)</code></pre><p id="d4eed498810fdbe063f7169a55b1f180" class="ne-p"><br></p><span id="python"></span><p id="549871fdea0653e95ae1401bf32b31a6" class="ne-p"><br></p><h2 id="b6028138"><span class="ne-text">三、np的常用函数</span></h2><p id="6a46ff4930886a44c1837fcb8c6d14b7" class="ne-p"><br></p><h3 id="d21a6be0"><span class="ne-text">转置transpose</span></h3><p id="8c630ef84a710462e01f55082f978723" class="ne-p"><br></p><pre><code>import numpy as np</code></pre><p id="d773c06c8cecad414760f6a234ed033e" class="ne-p"><br></p><pre><code>arr = np.random.rand(2,3)print (arr)print (arr.transpose())</code></pre><p id="c7746e1dcfbdd80f24d5255e9a33c1dd" class="ne-p"><br></p><pre><code>[[0.78485041 0.88817969 0.34809014] [0.32744286 0.97539301 0.94401872]][[0.78485041 0.32744286] [0.88817969 0.97539301] [0.34809014 0.94401872]]</code></pre><p id="de7c070ea01893ef6735f2b871cfa537" class="ne-p"><br></p><pre><code>#高维数组的转换(图像里面会用得到转换维度)#不懂这里！！！arr3d = np.random.rand(2,3,4)print (arr3d)print ('----------------------')print (arr3d.transpose((1,0,2))) # 多维数组的转置和定义不会</code></pre><p id="1530b1cc6c147a969a43ae7afa680fea" class="ne-p"><br></p><pre><code>[[[0.28492549 0.60197236 0.45582367 0.21992479]  [0.1747163  0.69201365 0.85460359 0.65311699]  [0.62189644 0.25217555 0.16347156 0.29831219]]<p> [[0.42826733 0.81396165 0.187138   0.560564  ]<br>  [0.10162186 0.66419751 0.03261665 0.06969256]<br>  [0.55461652 0.55020586 0.50693591 0.31741807]]]</p><hr><p>[[[0.28492549 0.60197236 0.45582367 0.21992479]<br>  [0.42826733 0.81396165 0.187138   0.560564  ]]</p><p> [[0.1747163  0.69201365 0.85460359 0.65311699]<br>  [0.10162186 0.66419751 0.03261665 0.06969256]]</p><p> [[0.62189644 0.25217555 0.16347156 0.29831219]<br>  [0.55461652 0.55020586 0.50693591 0.31741807]]]<br></code></pre></p><p id="825ab9d00b376dc87698a24f5ffe9698" class="ne-p"><br></p><h3 id="18eade90"><span class="ne-text">ceil和floor和rint和isnan</span></h3><p id="892edc4cdd1e5eb900cf354256cc8dd9" class="ne-p"><br></p><pre><code>arr = np.random.randn(2,3)<p>print (arr)<br>print (np.ceil(arr))<br>#向上最接近的整数<br>print (np.floor(arr))<br>#向下最接近的整数<br>print (np.rint(arr))<br>#四舍五入<br>print (np.isnan(arr))<br>#判断元素是否为NaN<br>#笔记上还有其他的函数<br></code></pre></p><p id="1a9198d67ad2be3be0cde1beeb54ce02" class="ne-p"><br></p><pre><code>[[ 0.262106   -1.33680008 -1.08562543] [ 0.3990978   0.1410074   0.64278274]][[ 1. -1. -1.] [ 1.  1.  1.]][[ 0. -2. -2.] [ 0.  0.  0.]][[ 0. -1. -1.] [ 0.  0.  1.]][[False False False] [False False False]]</code></pre><p id="5903d43b93728e6ab3d3ad1a7780b817" class="ne-p"><br></p><h3 id="where"><span class="ne-text">where</span></h3><p id="afe557f881019b1acaf9a37fd2193956" class="ne-p"><br></p><pre><code>arr = np.random.randn(3,4)print (arr)<p>np.where(arr &gt; 0, 1, -1)<br>#（条件，满足输出，不满足输出）<br></code></pre></p><p id="a5c05f0a8a80db02cb29c7556b86c773" class="ne-p"><br></p><pre><code>[[ 2.04688394  0.48063737  1.20876913 -0.93412937] [-0.43427472 -1.47755481  0.36882256 -0.08943138] [-0.2847686   0.96915893  0.32641235  0.28346922]]<p>array([[ 1,  1,  1, -1],<br>       [-1, -1,  1, -1],<br>       [-1,  1,  1,  1]])<br></code></pre></p><p id="976e237ef644e92c75ffbec317880663" class="ne-p"><br></p><h3 id="sum"><span class="ne-text">sum</span></h3><p id="79468f61a58009af012e522099fc8847" class="ne-p"><br></p><pre><code>arr = np.arange(10).reshape(5,2)print (arr)<p>print (np.sum(arr))<br>print (np.sum(arr, axis=0))<br>print (np.sum(arr, axis=1))<br></code></pre></p><p id="3fe13e42a996282fb9b6979c915a9064" class="ne-p"><br></p><pre><code>[[0 1] [2 3] [4 5] [6 7] [8 9]]45[20 25][ 1  5  9 13 17]</code></pre><p id="15e1dd455c43f93153fd3dc0f9411f35" class="ne-p"><br></p><h3 id="17e0c333"><span class="ne-text">all和any</span></h3><p id="a53080753bc8a5b45f56f53ec6dc8ef4" class="ne-p"><br></p><pre><code>import numpy as nparr = np.random.randn(2,3)print (arr)<p>print (np.any(arr &gt; 0))<br>#有一个就对<br>print (np.all(arr &gt; 0))<br>#全部对才对<br>‘’’<br>·用处就是判断一组数据当中，是否===有点类似布尔类型的<br>·这个也可以应用在pandas中的DataFrame中<br>‘’’<br></code></pre></p><p id="f1224f5c917f1d0e83dabc195ce054b8" class="ne-p"><br></p><pre><code>[[-1.020184   -0.48466272 -0.8496271 ] [ 0.88815825 -0.81911857  0.64570539]]TrueFalse<p>‘\n·用处就是判断一组数据当中，是否===有点类似布尔类型的\n·这个也可以应用在pandas中的DataFrame中\n’<br></code></pre></p><p id="83a06a6dcba27602bb418dd8f29239dd" class="ne-p"><br></p><h3 id="unique"><span class="ne-text">unique</span></h3><p id="ac9c26392f1befcc8a8e5da38098b9ce" class="ne-p"><br></p><pre><code>arr = np.array([[1, 2, 1], [2, 3, 4]])print (arr)print (np.unique(arr))</code></pre><p id="c872745113595a91e903204e1fd5baac" class="ne-p"><br></p><pre><code>[[1 2 1] [2 3 4]][1 2 3 4]</code></pre></div>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
          <category> 数据分析 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数据可视化</title>
      <link href="/blog/kt0kvc/"/>
      <url>/blog/kt0kvc/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content-editor-core lake-engine lake-typography-classic" data-lake-element="root" data-selection-undefined="%7B%22path%22%3A%5B%5B0%2C0%2C0%5D%2C%5B0%2C0%2C0%5D%5D%2C%22active%22%3Atrue%7D"><h2 id="3b2518f3" data-lake-id="11bbc0e0f8edfd2b6d7fdca29be54d91" style="padding: 7px 0px; margin: 0px; font-weight: 700; font-size: 24px; line-height: 32px;">一、GitHub Juper NoteBook笔记</h2><ul data-lake-id="41a10e0a54ba1530967c5818dfae399b" lake-indent="0" style="list-style-type: disc; margin: 0px; padding-left: 23px; font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word;"><li data-lake-id="6068469cff9a0367039290a52f7b96cf"><a href="https://github.com/wztlink1013/data-analysis-mining" target="_blank">https://github.com/wztlink1013/data-analysis-mining</a></li></ul><h2 data-lake-id="02f22caebec008bbb3fbae514f12cd61" id="90dgr" style="padding: 7px 0px; margin: 0px; font-weight: 700; font-size: 24px; line-height: 32px;">二、零碎总结</h2><h3 data-lake-id="164b95810e06f70a7cb1d0fff5f1a9dc" id="DA5NE" style="padding: 7px 0px; margin: 0px; font-weight: 700; font-size: 20px; line-height: 28px;">matplotlib调整子图间距，调整整体空白</h3><div data-card-type="block" data-lake-card="codeblock" id="EdBMq" class="lake-card-margin" data-language="python"><div class="lake-codeblock-content" style="border: 1px solid rgb(232, 232, 232); max-width: 750px; color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: rgb(249, 249, 249);"><div class="CodeMirror-sizer" style="color: rgb(89, 89, 89); margin: 0px; padding: 16px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"><pre class="cm-s-default" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"><span class="lake-preview-line" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"><span class="lake-preview-line-number lake-lm-pad-level-0" style="color: rgb(191, 191, 191); margin: 0px 8px 0px 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"></span><span class="lake-preview-codeblock-content" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"><span class="cm-variable" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">fig</span>.<span class="cm-property" style="color: rgb(0, 92, 197); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">tight_layout</span>() <span class="cm-comment" style="color: rgb(106, 115, 125); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">#调整整体空白</span></span></span><span class="lake-preview-line" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"><span class="lake-preview-line-number lake-lm-pad-level-0" style="color: rgb(191, 191, 191); margin: 0px 8px 0px 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"></span><span class="lake-preview-codeblock-content" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"><span class="cm-variable" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">plt</span>.<span class="cm-property" style="color: rgb(0, 92, 197); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">subplots_adjust</span>(<span class="cm-variable" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">wspace</span> <span class="cm-operator" style="color: rgb(215, 58, 73); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">=</span><span class="cm-number" style="color: rgb(0, 92, 197); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">0</span>, <span class="cm-variable" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">hspace</span> <span class="cm-operator" style="color: rgb(215, 58, 73); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">=</span><span class="cm-number" style="color: rgb(0, 92, 197); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">0</span>) <span class="cm-comment" style="color: rgb(106, 115, 125); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">#调整子图间距</span></span></span></pre></div></div></div><h2 id="d17a0f0b" data-lake-id="6d4a405b6d449bfe903dffc12deaca65" style="padding: 7px 0px; margin: 0px; font-weight: 700; font-size: 24px; line-height: 32px;">参考</h2><ul data-lake-id="31686b2cd9184ef8ce7436b550fe6b82" lake-indent="0" style="list-style-type: disc; margin: 0px; padding-left: 23px; font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word;"><li data-lake-id="9c06bce30678fc4ffb1868e40c71c60c"><a href="https://mp.weixin.qq.com/s/DaQL6bqr0wu5iYt-cVkz6g" target="_blank">Matplotlib 可视化最有价值的 50 个图表</a></li></ul></div>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
          <category> 数据分析 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数据的清洗和规整（一）</title>
      <link href="/blog/gvi1hn/"/>
      <url>/blog/gvi1hn/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="2d9fc2b03af5094d5348c0c09fa153eb" class="ne-p"><span class="ne-text">清洗数据：删除指定数据、处理缺失数据etc</span></p><p id="ua0c79517" class="ne-p"><br></p><h2 id="bc91b829"><span class="ne-text">一、数据预览：tail（）、head（）</span></h2><p id="96f3b4dc408392fe46a9b5d268b2bc67" class="ne-p"><br></p><pre><code>import numpy as npimport pandas as pddf_obj = pd.DataFrame(np.random.randn(5,4), columns = ['a', 'b', 'c', 'd'])print(df_obj.tail())# 数据预览尾巴print(df_obj.head())# 数据预览头部</code></pre><p id="2d4b15e888b5b511f88d6b061e73ad00" class="ne-p"><br></p><pre><code>          a         b         c         d0 -0.507788  0.213237  0.003150 -0.7773121 -0.896653 -2.188016 -0.114848  0.1670572 -1.131242 -0.142287 -1.027330  1.8618143  0.369608  0.823453  1.030830 -0.0417784 -0.647625  0.056791 -0.394078 -1.347718          a         b         c         d0 -0.507788  0.213237  0.003150 -0.7773121 -0.896653 -2.188016 -0.114848  0.1670572 -1.131242 -0.142287 -1.027330  1.8618143  0.369608  0.823453  1.030830 -0.0417784 -0.647625  0.056791 -0.394078 -1.347718</code></pre><p id="07243dfeb6b35aea066223e2bc8721a5" class="ne-p"><br></p><h2 id="d2aaa534"><span class="ne-text">二、数据描述：shape、info()</span></h2><p id="d8cc5506d77c9ba0cc8945b0683f2dd1" class="ne-p"><br></p><pre><code>print ('数据集有%i行，%i列' %(df_obj.shape[0], df_obj.shape[1]))</code></pre><p id="64fdeb61b3f6d620e09cbc6315339eec" class="ne-p"><br></p><pre><code>数据集有5行，4列</code></pre><p id="1f70d0bfa86adafd4dec464863d6795e" class="ne-p"><br></p><pre><code>print(df_obj.info())</code></pre><p id="6dedde4942b4c583185f791ce6d363ee" class="ne-p"><br></p><pre><code>&lt;class 'pandas.core.frame.DataFrame'&gt;RangeIndex: 5 entries, 0 to 4Data columns (total 4 columns):a    5 non-null float64b    5 non-null float64c    5 non-null float64d    5 non-null float64dtypes: float64(4)memory usage: 288.0 bytesNone</code></pre><p id="788ae5c0ae57921fc0e3875e52574b62" class="ne-p"><br></p><h2 id="d34cceb7"><span class="ne-text">三、数据统计：describe()</span></h2><p id="53e8da371e2ff989da6709611903687a" class="ne-p"><br></p><pre><code>print(df_obj.describe())</code></pre><p id="69c0487683cbade5f72bdec2ac0c03a5" class="ne-p"><br></p><pre><code>              a         b         c         dcount  5.000000  5.000000  5.000000  5.000000mean  -0.562740 -0.247365 -0.100455 -0.027587std    0.573191  1.143294  0.747673  1.215808min   -1.131242 -2.188016 -1.027330 -1.34771825%   -0.896653 -0.142287 -0.394078 -0.77731250%   -0.647625  0.056791 -0.114848 -0.04177875%   -0.507788  0.213237  0.003150  0.167057max    0.369608  0.823453  1.030830  1.861814</code></pre><p id="bc40386ac1dcef875aea89e6100aaf51" class="ne-p"><br></p><h2 id="085506d6"><span class="ne-text">四、pandas不完全显示行列</span></h2><p id="bc97e93146d1f62dde07f61e6c09c0d0" class="ne-p"><br></p><pre><code>pd.set_option('display.max_rows', 100)        //显示的最大行数（避免只显示部分行数据）pd.set_option('display.max_columns', 1000)    //显示的最大列数（避免列显示不全）pd.set_option(&quot;display.max_colwidth&quot;, 1000)   //每一列最大的宽度（避免属性值或列名显示不全）pd.set_option('display.width', 1000)          //每一行的宽度（避免换行）</code></pre><p id="2732beacf23d67ec4a012fc6b1940909" class="ne-p"><br></p><h2 id="xzrrn"><span class="ne-text">五、删除指定行列数据</span></h2><p id="0d7a05e69e367d5d3519e415aa4d8f30" class="ne-p"><br></p><pre><code>import pandas as pdimport numpy as np</code></pre><p id="a5370a2dd1edaf2d40788c47fcf8de05" class="ne-p"><br></p><pre><code>dict_data = &#123;'A': 1.,              'B': pd.Timestamp('20161217'),             'C': pd.Series(1, index=list(range(4)),dtype='float32'),             'D': np.array([3] * 4,dtype='int32'),             'E' : pd.Categorical([&quot;Python&quot;,&quot;Java&quot;,&quot;C++&quot;,&quot;C#&quot;]),             'F' : 'ChinaHadoop' &#125;df_obj2 = pd.DataFrame(dict_data)print(df_obj2)</code></pre><p id="750948187165f98506423c685cfc6611" class="ne-p"><br></p><pre><code>     A          B    C  D       E            F0  1.0 2016-12-17  1.0  3  Python  ChinaHadoop1  1.0 2016-12-17  1.0  3    Java  ChinaHadoop2  1.0 2016-12-17  1.0  3     C++  ChinaHadoop3  1.0 2016-12-17  1.0  3      C#  ChinaHadoop</code></pre><p id="cbf63c3041a807fbb566f8431497843e" class="ne-p"><br></p><h3 id="del"><span class="ne-text">del</span></h3><p id="44a23bc41656701d9c6e9ebe1d53af61" class="ne-p"><br></p><div class="ne-quote"><p id="f722bbce2fdaf6c705b525530a0d5696" class="ne-p"><span class="ne-text">删除列</span></p></div><p id="a5e0adb4343ae3ee7a35a43529e9a060" class="ne-p"><br></p><pre><code>del df_obj2['A'] print (df_obj2.head())</code></pre><p id="667133040d7226dcc12dfb386b471f27" class="ne-p"><br></p><pre><code>           B    C  D       E            F0 2016-12-17  1.0  3  Python  ChinaHadoop1 2016-12-17  1.0  3    Java  ChinaHadoop2 2016-12-17  1.0  3     C++  ChinaHadoop3 2016-12-17  1.0  3      C#  ChinaHadoop</code></pre><p id="2dd53dc59a034f772e80b3819437b585" class="ne-p"><br></p><h3 id="drop"><span class="ne-text">drop</span></h3><p id="5c32368d733a91d16d68de90259769b0" class="ne-p"><br></p><div class="ne-quote"><p id="ba7db11ac2cf703500f94be806f977e5" class="ne-p"><span class="ne-text">删除行/列数据</span></p></div><p id="44bc5b4e6213c581549c0e6d9bf61b57" class="ne-p"><br></p><pre><code>dict_data = &#123;'A': 1.,              'B': pd.Timestamp('20161217'),             'C': pd.Series(1, index=list(range(4)),dtype='float32'),             'D': np.array([3] * 4,dtype='int32'),             'E' : pd.Categorical([&quot;Python&quot;,&quot;Java&quot;,&quot;C++&quot;,&quot;C#&quot;]),             'F' : 'ChinaHadoop' &#125;df_obj3 = pd.DataFrame(dict_data,index = ['sfd','sdfd','wer','rwer'])print (df_obj3.head(7))print(df_obj3.drop('wer'))#删除行print(df_obj3.drop('F',axis=1))#删除列</code></pre><p id="071fd38e10ce753ac8bf5f74e07702e6" class="ne-p"><br></p><pre><code>        A          B   C  D       E            Fsfd   1.0 2016-12-17 NaN  3  Python  ChinaHadoopsdfd  1.0 2016-12-17 NaN  3    Java  ChinaHadoopwer   1.0 2016-12-17 NaN  3     C++  ChinaHadooprwer  1.0 2016-12-17 NaN  3      C#  ChinaHadoop        A          B   C  D       E            Fsfd   1.0 2016-12-17 NaN  3  Python  ChinaHadoopsdfd  1.0 2016-12-17 NaN  3    Java  ChinaHadooprwer  1.0 2016-12-17 NaN  3      C#  ChinaHadoop        A          B   C  D       Esfd   1.0 2016-12-17 NaN  3  Pythonsdfd  1.0 2016-12-17 NaN  3    Javawer   1.0 2016-12-17 NaN  3     C++rwer  1.0 2016-12-17 NaN  3      C#</code></pre><p id="88a23cbadb1e4866303eb9b237777925" class="ne-p"><br></p><h2 id="f844b7ca"><span class="ne-text">六、处理缺失数据</span></h2><p id="d6fab5c357cfb91d163c88df390d144d" class="ne-p"><br></p><pre><code>df_data = pd.DataFrame([np.random.randn(3), [1., np.nan, np.nan],                       [4., np.nan, np.nan], [1., np.nan, 2.]])df_data.head()</code></pre><p id="1c635f015daa241973f9633ca872b802" class="ne-p"><br></p><table id="f98d8222" class="ne-table" style="width: 748px"><tbody><tr style="height: 33px"><td width="187"></td><td width="187"><p id="ufff03452" class="ne-p"><span class="ne-text">0</span></p></td><td width="187"><p id="u5c405d15" class="ne-p"><span class="ne-text">1</span></p></td><td width="187"><p id="ub3408fb7" class="ne-p"><span class="ne-text">2</span></p></td></tr><tr style="height: 33px"><td width="187"><p id="u72ae5465" class="ne-p"><span class="ne-text">0</span></p></td><td width="187"><p id="u4fbc751d" class="ne-p"><span class="ne-text">-0.702713</span></p></td><td width="187"><p id="u29cca36d" class="ne-p"><span class="ne-text">-0.991383</span></p></td><td width="187"><p id="u45efa7fc" class="ne-p"><span class="ne-text">-1.058464</span></p></td></tr><tr style="height: 33px"><td width="187"><p id="u27521e29" class="ne-p"><span class="ne-text">1</span></p></td><td width="187"><p id="u4c91cc7c" class="ne-p"><span class="ne-text">1.000000</span></p></td><td width="187"><p id="u8a0e1327" class="ne-p"><span class="ne-text">NaN</span></p></td><td width="187"><p id="u09f1cf50" class="ne-p"><span class="ne-text">NaN</span></p></td></tr><tr style="height: 33px"><td width="187"><p id="u693a0924" class="ne-p"><span class="ne-text">2</span></p></td><td width="187"><p id="u3431aae3" class="ne-p"><span class="ne-text">4.000000</span></p></td><td width="187"><p id="u4b44f71a" class="ne-p"><span class="ne-text">NaN</span></p></td><td width="187"><p id="u972b14cd" class="ne-p"><span class="ne-text">NaN</span></p></td></tr><tr style="height: 33px"><td width="187"><p id="uf10730f3" class="ne-p"><span class="ne-text">3</span></p></td><td width="187"><p id="uc39e96fa" class="ne-p"><span class="ne-text">1.000000</span></p></td><td width="187"><p id="u84129301" class="ne-p"><span class="ne-text">NaN</span></p></td><td width="187"><p id="ub0daba30" class="ne-p"><span class="ne-text">2.000000</span></p></td></tr></tbody></table><p id="1699d63561ae70ebafe6b2b3677a3975" class="ne-p"><br></p><h3 id="e4f95d9e"><span class="ne-text">判断是否存在缺失值</span></h3><p id="fde168bca0e0d5dbea611d39135b38ae" class="ne-p"><br></p><pre><code>df_data.isnull()</code></pre><p id="3ba725772307b872ddde1bf9fe457026" class="ne-p"><br></p><table id="2832a2a7" class="ne-table" style="width: 748px"><tbody><tr style="height: 33px"><td width="187"></td><td width="187"><p id="u1f2b6405" class="ne-p"><span class="ne-text">0</span></p></td><td width="187"><p id="u318ad4c7" class="ne-p"><span class="ne-text">1</span></p></td><td width="187"><p id="ucda7c6fd" class="ne-p"><span class="ne-text">2</span></p></td></tr><tr style="height: 33px"><td width="187"><p id="u95185dea" class="ne-p"><span class="ne-text">0</span></p></td><td width="187"><p id="u27fb143a" class="ne-p"><span class="ne-text">False</span></p></td><td width="187"><p id="u2bb9ae08" class="ne-p"><span class="ne-text">False</span></p></td><td width="187"><p id="ua611fdfb" class="ne-p"><span class="ne-text">False</span></p></td></tr><tr style="height: 33px"><td width="187"><p id="uf03ca756" class="ne-p"><span class="ne-text">1</span></p></td><td width="187"><p id="uee5544fd" class="ne-p"><span class="ne-text">False</span></p></td><td width="187"><p id="u9484ee21" class="ne-p"><span class="ne-text">True</span></p></td><td width="187"><p id="u1dc9dbfd" class="ne-p"><span class="ne-text">True</span></p></td></tr><tr style="height: 33px"><td width="187"><p id="u066a2fc9" class="ne-p"><span class="ne-text">2</span></p></td><td width="187"><p id="u6158815d" class="ne-p"><span class="ne-text">False</span></p></td><td width="187"><p id="u59d21081" class="ne-p"><span class="ne-text">True</span></p></td><td width="187"><p id="u42dde343" class="ne-p"><span class="ne-text">True</span></p></td></tr><tr style="height: 33px"><td width="187"><p id="ucc30df4c" class="ne-p"><span class="ne-text">3</span></p></td><td width="187"><p id="u5b29b2de" class="ne-p"><span class="ne-text">False</span></p></td><td width="187"><p id="u95fd7dd0" class="ne-p"><span class="ne-text">True</span></p></td><td width="187"><p id="ub3cc46eb" class="ne-p"><span class="ne-text">False</span></p></td></tr></tbody></table><p id="82127210ee243b1ba59aa7c20bea8da5" class="ne-p"><br></p><h3 id="f129ed06"><span class="ne-text">丢弃缺失数据</span></h3><p id="097316b7cfa2c3b0c0c7bb419e1565c3" class="ne-p"><br></p><pre><code>print(df_data.dropna(axis=0))#0是行；1是列</code></pre><p id="debac196834b73c507501794a128dce5" class="ne-p"><br></p><pre><code>          0         1         20 -0.702713 -0.991383 -1.058464</code></pre><p id="daaede3e28a1a38ab5329b3831f7a12d" class="ne-p"><br></p><h3 id="90e6feb8"><span class="ne-text">填充缺失数据</span></h3><p id="3c622806d1b3f497125a0d9ace44d3c5" class="ne-p"><br></p><pre><code>df_data.fillna(-100.)</code></pre><p id="80489ca4f8406f1562538f6ae016cbd5" class="ne-p"><br></p><table id="184c1433" class="ne-table" style="width: 748px"><tbody><tr style="height: 33px"><td width="187"></td><td width="187"><p id="u3e724e83" class="ne-p"><span class="ne-text">0</span></p></td><td width="187"><p id="uf3ea97f2" class="ne-p"><span class="ne-text">1</span></p></td><td width="187"><p id="u18a56e83" class="ne-p"><span class="ne-text">2</span></p></td></tr><tr style="height: 33px"><td width="187"><p id="uf0822b36" class="ne-p"><span class="ne-text">0</span></p></td><td width="187"><p id="u388ad21e" class="ne-p"><span class="ne-text">-0.702713</span></p></td><td width="187"><p id="u5b07ba46" class="ne-p"><span class="ne-text">-0.991383</span></p></td><td width="187"><p id="uc675abdc" class="ne-p"><span class="ne-text">-1.058464</span></p></td></tr><tr style="height: 33px"><td width="187"><p id="u8ccab074" class="ne-p"><span class="ne-text">1</span></p></td><td width="187"><p id="u714799b2" class="ne-p"><span class="ne-text">1.000000</span></p></td><td width="187"><p id="ud8abf9dd" class="ne-p"><span class="ne-text">-100.000000</span></p></td><td width="187"><p id="uaea41179" class="ne-p"><span class="ne-text">-100.000000</span></p></td></tr><tr style="height: 33px"><td width="187"><p id="uf9749a17" class="ne-p"><span class="ne-text">2</span></p></td><td width="187"><p id="u549ed89a" class="ne-p"><span class="ne-text">4.000000</span></p></td><td width="187"><p id="ufff1f276" class="ne-p"><span class="ne-text">-100.000000</span></p></td><td width="187"><p id="u5fb7444f" class="ne-p"><span class="ne-text">-100.000000</span></p></td></tr><tr style="height: 33px"><td width="187"><p id="u3ec43b61" class="ne-p"><span class="ne-text">3</span></p></td><td width="187"><p id="u512f8909" class="ne-p"><span class="ne-text">1.000000</span></p></td><td width="187"><p id="uf9f8153a" class="ne-p"><span class="ne-text">-100.000000</span></p></td><td width="187"><p id="ua64bf884" class="ne-p"><span class="ne-text">2.000000</span></p></td></tr></tbody></table><p id="410d3226004878274076168e1678f567" class="ne-p"><br></p><h2 id="e2adcb7f"></h2></div>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
          <category> 数据分析 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数据的清洗和规整（二）</title>
      <link href="/blog/dggm37/"/>
      <url>/blog/dggm37/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="97ef088b442e4d2142d29a2e13b8d1de" class="ne-p"><span class="ne-text">规整数据：连接、合并、重构、转换etc</span></p><h2 id="vEPCg"><span class="ne-text">三、数据规整-连接-含索引</span></h2><p id="a1bbb91372d002f331fde0656b4cc56a" class="ne-p"><br></p><ul class="ne-ul"><li id="442526d957c5fb17cab73e321b572dfa"><span class="ne-text">数据连接 merge</span></li></ul><p id="3ed571a27f671d77436a0e8c85505146" class="ne-p"><br></p><pre><code>import pandas as pdimport numpy as np</code></pre><p id="07952fd692f716395bf5e1b3cf8a0099" class="ne-p"><br></p><pre><code>df_obj1 = pd.DataFrame(&#123;'key': ['b', 'b', 'a', 'c', 'a', 'a', 'b'],                        'data1' : ['sfd','fdsf','we',24,3253,234,23]&#125;)df_obj2 = pd.DataFrame(&#123;'key': ['a', 'b', 'd'],                        'data2' : np.random.randint(0,10,3)&#125;)<p>print (df_obj1)<br>print (df_obj2)<br></code></pre></p><p id="5691e0ea0261fff8e49759f14021d6ea" class="ne-p"><br></p><pre><code>  key data10   b   sfd1   b  fdsf2   a    we3   c    244   a  32535   a   2346   b    23  key  data20   a      01   b      62   d      6</code></pre><p id="e09f6a427b8f74efffb99ae32ddb18a0" class="ne-p"><br></p><h3 id="d0056c72"><span class="ne-text">merge和on</span></h3><p id="f9dd2e2d0d23aae3cf45c7b972556467" class="ne-p"><br></p><div class="ne-quote"><p id="4a2557b15dbc0d2dd180f6cb2c1d6d02" class="ne-p"><span class="ne-text">默认将重叠列的列名作为“外键”进行连接</span></p></div><p id="3a2d6c142e690e074bda76238f9b89e5" class="ne-p"><br></p><pre><code>pd.merge(df_obj1, df_obj2)</code></pre><p id="3c48bf0324fce9a28d5c3344079b6ccd" class="ne-p"><br></p><table id="fa6fdee9" class="ne-table" style="width: 748px"><tbody><tr style="height: 33px"><td width="187"></td><td width="187"><p id="u81c7f678" class="ne-p"><span class="ne-text">key</span></p></td><td width="187"><p id="u47cc03c9" class="ne-p"><span class="ne-text">data1</span></p></td><td width="187"><p id="uad64b95c" class="ne-p"><span class="ne-text">data2</span></p></td></tr><tr style="height: 33px"><td width="187"><p id="u9e853297" class="ne-p"><span class="ne-text">0</span></p></td><td width="187"><p id="u7fae4863" class="ne-p"><span class="ne-text">b</span></p></td><td width="187"><p id="u8fbc2b26" class="ne-p"><span class="ne-text">sfd</span></p></td><td width="187"><p id="u45459c4e" class="ne-p"><span class="ne-text">6</span></p></td></tr><tr style="height: 33px"><td width="187"><p id="u7a799426" class="ne-p"><span class="ne-text">1</span></p></td><td width="187"><p id="ue933ed11" class="ne-p"><span class="ne-text">b</span></p></td><td width="187"><p id="uf60692d6" class="ne-p"><span class="ne-text">fdsf</span></p></td><td width="187"><p id="u1d4182bb" class="ne-p"><span class="ne-text">6</span></p></td></tr><tr style="height: 33px"><td width="187"><p id="u9af03cc1" class="ne-p"><span class="ne-text">2</span></p></td><td width="187"><p id="ud93fd487" class="ne-p"><span class="ne-text">b</span></p></td><td width="187"><p id="uc69a1da8" class="ne-p"><span class="ne-text">23</span></p></td><td width="187"><p id="u38b73542" class="ne-p"><span class="ne-text">6</span></p></td></tr><tr style="height: 33px"><td width="187"><p id="ufa297162" class="ne-p"><span class="ne-text">3</span></p></td><td width="187"><p id="u993abd3e" class="ne-p"><span class="ne-text">a</span></p></td><td width="187"><p id="u01b435c1" class="ne-p"><span class="ne-text">we</span></p></td><td width="187"><p id="uc8ce293f" class="ne-p"><span class="ne-text">0</span></p></td></tr><tr style="height: 33px"><td width="187"><p id="ufa7c8400" class="ne-p"><span class="ne-text">4</span></p></td><td width="187"><p id="u020cedbb" class="ne-p"><span class="ne-text">a</span></p></td><td width="187"><p id="u06a7ac18" class="ne-p"><span class="ne-text">3253</span></p></td><td width="187"><p id="u0215a34d" class="ne-p"><span class="ne-text">0</span></p></td></tr><tr style="height: 33px"><td width="187"><p id="u6dc25070" class="ne-p"><span class="ne-text">5</span></p></td><td width="187"><p id="u81a2de26" class="ne-p"><span class="ne-text">a</span></p></td><td width="187"><p id="u71c4b61e" class="ne-p"><span class="ne-text">234</span></p></td><td width="187"><p id="uce4a9e8e" class="ne-p"><span class="ne-text">0</span></p></td></tr></tbody></table><p id="fed4089a44edfd08f93ffcb4987f64d0" class="ne-p"><br></p><pre><code># on显示指定“外键”pd.merge(df_obj1, df_obj2, on='key')</code></pre><p id="ea17b24616d7207d5ce90012a1fb671c" class="ne-p"><br></p><table id="fa6fdee9-1" class="ne-table" style="width: 748px"><tbody><tr style="height: 33px"><td width="187"></td><td width="187"><p id="u7fe1b3fa" class="ne-p"><span class="ne-text">key</span></p></td><td width="187"><p id="u122e90f3" class="ne-p"><span class="ne-text">data1</span></p></td><td width="187"><p id="u99351a52" class="ne-p"><span class="ne-text">data2</span></p></td></tr><tr style="height: 33px"><td width="187"><p id="ue2faa1ca" class="ne-p"><span class="ne-text">0</span></p></td><td width="187"><p id="u5c4c597b" class="ne-p"><span class="ne-text">b</span></p></td><td width="187"><p id="ua544cc9f" class="ne-p"><span class="ne-text">sfd</span></p></td><td width="187"><p id="udf59bbc2" class="ne-p"><span class="ne-text">6</span></p></td></tr><tr style="height: 33px"><td width="187"><p id="ueb229588" class="ne-p"><span class="ne-text">1</span></p></td><td width="187"><p id="u9dc8007c" class="ne-p"><span class="ne-text">b</span></p></td><td width="187"><p id="u656a787d" class="ne-p"><span class="ne-text">fdsf</span></p></td><td width="187"><p id="u826baaa4" class="ne-p"><span class="ne-text">6</span></p></td></tr><tr style="height: 33px"><td width="187"><p id="u5807e653" class="ne-p"><span class="ne-text">2</span></p></td><td width="187"><p id="u816d0966" class="ne-p"><span class="ne-text">b</span></p></td><td width="187"><p id="uf6d9f8c9" class="ne-p"><span class="ne-text">23</span></p></td><td width="187"><p id="ub107dba1" class="ne-p"><span class="ne-text">6</span></p></td></tr><tr style="height: 33px"><td width="187"><p id="u41659a36" class="ne-p"><span class="ne-text">3</span></p></td><td width="187"><p id="ucc46c302" class="ne-p"><span class="ne-text">a</span></p></td><td width="187"><p id="u626b47da" class="ne-p"><span class="ne-text">we</span></p></td><td width="187"><p id="u0e3b3b67" class="ne-p"><span class="ne-text">0</span></p></td></tr><tr style="height: 33px"><td width="187"><p id="u550ff022" class="ne-p"><span class="ne-text">4</span></p></td><td width="187"><p id="u004f7a57" class="ne-p"><span class="ne-text">a</span></p></td><td width="187"><p id="ue8f1adea" class="ne-p"><span class="ne-text">3253</span></p></td><td width="187"><p id="u5c718f9f" class="ne-p"><span class="ne-text">0</span></p></td></tr><tr style="height: 33px"><td width="187"><p id="ud676974f" class="ne-p"><span class="ne-text">5</span></p></td><td width="187"><p id="u6f743d5e" class="ne-p"><span class="ne-text">a</span></p></td><td width="187"><p id="u23413843" class="ne-p"><span class="ne-text">234</span></p></td><td width="187"><p id="u1fea02fd" class="ne-p"><span class="ne-text">0</span></p></td></tr></tbody></table><p id="6386a653f3be049e7f0f6aebfc469eef" class="ne-p"><br></p><h3 id="fde24c2a"><span class="ne-text">left-on和right-on</span></h3><p id="594d00f819eb667ccf7ca0de6d006a3c" class="ne-p"><br></p><pre><code># left_on，right_on分别指定左侧数据和右侧数据的“外键”<h1 id="更改列名"><a href="#更改列名" class="headerlink" title="更改列名"></a>更改列名</h1><p>df_obj1 = df_obj1.rename(columns=&#123;‘key’:’key1’&#125;)<br>df_obj2 = df_obj2.rename(columns=&#123;‘key’:’key2’&#125;)<br></code></pre></p><p id="d5ff1a530532c6bb8601fbf92ca3d57d" class="ne-p"><br></p><pre><code>print(df_obj1)print(df_obj2)</code></pre><p id="71109d928c3ae48fb908a9ed414771c4" class="ne-p"><br></p><pre><code>  key1 data10    b   sfd1    b  fdsf2    a    we3    c    244    a  32535    a   2346    b    23  key2  data20    a      01    b      62    d      6</code></pre><p id="b4e360316db744a782b5f7fc3e0b6ae0" class="ne-p"><br></p><pre><code>pd.merge(df_obj1, df_obj2, left_on='key1', right_on='key2')</code></pre><p id="95130cbb4e261528bb2343d18add2102" class="ne-p"><br></p><table id="8bca1abb" class="ne-table" style="width: 750px"><tbody><tr style="height: 33px"><td width="150"></td><td width="150"><p id="u06054f28" class="ne-p"><span class="ne-text">key1</span></p></td><td width="150"><p id="u9247a866" class="ne-p"><span class="ne-text">data1</span></p></td><td width="150"><p id="u7c6ce5a4" class="ne-p"><span class="ne-text">key2</span></p></td><td width="150"><p id="u7237f8b6" class="ne-p"><span class="ne-text">data2</span></p></td></tr><tr style="height: 33px"><td width="150"><p id="ubcb21996" class="ne-p"><span class="ne-text">0</span></p></td><td width="150"><p id="ue30ad954" class="ne-p"><span class="ne-text">b</span></p></td><td width="150"><p id="u9ee91e7a" class="ne-p"><span class="ne-text">sfd</span></p></td><td width="150"><p id="u415e3cea" class="ne-p"><span class="ne-text">b</span></p></td><td width="150"><p id="u93c4f0bc" class="ne-p"><span class="ne-text">6</span></p></td></tr><tr style="height: 33px"><td width="150"><p id="u9cf2aa12" class="ne-p"><span class="ne-text">1</span></p></td><td width="150"><p id="u1750e3d9" class="ne-p"><span class="ne-text">b</span></p></td><td width="150"><p id="u61b465c1" class="ne-p"><span class="ne-text">fdsf</span></p></td><td width="150"><p id="u41baefeb" class="ne-p"><span class="ne-text">b</span></p></td><td width="150"><p id="u49391f29" class="ne-p"><span class="ne-text">6</span></p></td></tr><tr style="height: 33px"><td width="150"><p id="u4fb2ab16" class="ne-p"><span class="ne-text">2</span></p></td><td width="150"><p id="ub7cef164" class="ne-p"><span class="ne-text">b</span></p></td><td width="150"><p id="u526066bd" class="ne-p"><span class="ne-text">23</span></p></td><td width="150"><p id="ud8d82bc9" class="ne-p"><span class="ne-text">b</span></p></td><td width="150"><p id="uba43d188" class="ne-p"><span class="ne-text">6</span></p></td></tr><tr style="height: 33px"><td width="150"><p id="u1cf0af8d" class="ne-p"><span class="ne-text">3</span></p></td><td width="150"><p id="uf3b015e1" class="ne-p"><span class="ne-text">a</span></p></td><td width="150"><p id="ud650d4e7" class="ne-p"><span class="ne-text">we</span></p></td><td width="150"><p id="u24de2110" class="ne-p"><span class="ne-text">a</span></p></td><td width="150"><p id="uadaff155" class="ne-p"><span class="ne-text">0</span></p></td></tr><tr style="height: 33px"><td width="150"><p id="ue8fbb8ad" class="ne-p"><span class="ne-text">4</span></p></td><td width="150"><p id="u195aa35c" class="ne-p"><span class="ne-text">a</span></p></td><td width="150"><p id="ue3d47ced" class="ne-p"><span class="ne-text">3253</span></p></td><td width="150"><p id="u652aef25" class="ne-p"><span class="ne-text">a</span></p></td><td width="150"><p id="uc089db0c" class="ne-p"><span class="ne-text">0</span></p></td></tr><tr style="height: 33px"><td width="150"><p id="uedad1fbf" class="ne-p"><span class="ne-text">5</span></p></td><td width="150"><p id="u4abb0a43" class="ne-p"><span class="ne-text">a</span></p></td><td width="150"><p id="u65e75755" class="ne-p"><span class="ne-text">234</span></p></td><td width="150"><p id="u4a85a1f9" class="ne-p"><span class="ne-text">a</span></p></td><td width="150"><p id="u098f7dca" class="ne-p"><span class="ne-text">0</span></p></td></tr></tbody></table><p id="ccae74a66be4389d93d7cb06bc608c98" class="ne-p"><br></p><h3 id="how"><span class="ne-text">how</span></h3><p id="149802a1efddfff49fbad25750572f02" class="ne-p"><br></p><pre><code># “外连接”pd.merge(df_obj1, df_obj2, left_on='key1', right_on='key2', how='outer')</code></pre><p id="8d62b2ca602aec2ae5f89e8a2144b7eb" class="ne-p"><br></p><table id="726ff191" class="ne-table" style="width: 750px"><tbody><tr style="height: 33px"><td width="150"></td><td width="150"><p id="ud5b7b797" class="ne-p"><span class="ne-text">key1</span></p></td><td width="150"><p id="u1a488068" class="ne-p"><span class="ne-text">data1</span></p></td><td width="150"><p id="uc39e995e" class="ne-p"><span class="ne-text">key2</span></p></td><td width="150"><p id="ubee6378f" class="ne-p"><span class="ne-text">data2</span></p></td></tr><tr style="height: 33px"><td width="150"><p id="u14078539" class="ne-p"><span class="ne-text">0</span></p></td><td width="150"><p id="u9d3a854d" class="ne-p"><span class="ne-text">b</span></p></td><td width="150"><p id="u0e13c750" class="ne-p"><span class="ne-text">sfd</span></p></td><td width="150"><p id="u4a0b5b0f" class="ne-p"><span class="ne-text">b</span></p></td><td width="150"><p id="uc19cea51" class="ne-p"><span class="ne-text">6.0</span></p></td></tr><tr style="height: 33px"><td width="150"><p id="uff06689c" class="ne-p"><span class="ne-text">1</span></p></td><td width="150"><p id="ueffc61ed" class="ne-p"><span class="ne-text">b</span></p></td><td width="150"><p id="u54b586cb" class="ne-p"><span class="ne-text">fdsf</span></p></td><td width="150"><p id="u1854d84f" class="ne-p"><span class="ne-text">b</span></p></td><td width="150"><p id="ubc9c3e92" class="ne-p"><span class="ne-text">6.0</span></p></td></tr><tr style="height: 33px"><td width="150"><p id="u1654d75c" class="ne-p"><span class="ne-text">2</span></p></td><td width="150"><p id="ufa1b5463" class="ne-p"><span class="ne-text">b</span></p></td><td width="150"><p id="u053b68ff" class="ne-p"><span class="ne-text">23</span></p></td><td width="150"><p id="ubab1b60b" class="ne-p"><span class="ne-text">b</span></p></td><td width="150"><p id="uc168d932" class="ne-p"><span class="ne-text">6.0</span></p></td></tr><tr style="height: 33px"><td width="150"><p id="u03e6d48c" class="ne-p"><span class="ne-text">3</span></p></td><td width="150"><p id="u9228a865" class="ne-p"><span class="ne-text">a</span></p></td><td width="150"><p id="u8d0b8d13" class="ne-p"><span class="ne-text">we</span></p></td><td width="150"><p id="u9d151a6a" class="ne-p"><span class="ne-text">a</span></p></td><td width="150"><p id="udb82c967" class="ne-p"><span class="ne-text">0.0</span></p></td></tr><tr style="height: 33px"><td width="150"><p id="u50423c41" class="ne-p"><span class="ne-text">4</span></p></td><td width="150"><p id="u39f1fb57" class="ne-p"><span class="ne-text">a</span></p></td><td width="150"><p id="ube53939a" class="ne-p"><span class="ne-text">3253</span></p></td><td width="150"><p id="ufbd76739" class="ne-p"><span class="ne-text">a</span></p></td><td width="150"><p id="u2e144b7d" class="ne-p"><span class="ne-text">0.0</span></p></td></tr><tr style="height: 33px"><td width="150"><p id="u449be90a" class="ne-p"><span class="ne-text">5</span></p></td><td width="150"><p id="u077a087a" class="ne-p"><span class="ne-text">a</span></p></td><td width="150"><p id="uc91cb1f1" class="ne-p"><span class="ne-text">234</span></p></td><td width="150"><p id="u8b92efd9" class="ne-p"><span class="ne-text">a</span></p></td><td width="150"><p id="u4af471dd" class="ne-p"><span class="ne-text">0.0</span></p></td></tr><tr style="height: 33px"><td width="150"><p id="ud35b0d1d" class="ne-p"><span class="ne-text">6</span></p></td><td width="150"><p id="u30854da3" class="ne-p"><span class="ne-text">c</span></p></td><td width="150"><p id="ubdaca31c" class="ne-p"><span class="ne-text">24</span></p></td><td width="150"><p id="u5f0c01fa" class="ne-p"><span class="ne-text">NaN</span></p></td><td width="150"><p id="u6d412986" class="ne-p"><span class="ne-text">NaN</span></p></td></tr><tr style="height: 33px"><td width="150"><p id="uaf87fe4d" class="ne-p"><span class="ne-text">7</span></p></td><td width="150"><p id="uaa605f48" class="ne-p"><span class="ne-text">NaN</span></p></td><td width="150"><p id="uf945c8b0" class="ne-p"><span class="ne-text">NaN</span></p></td><td width="150"><p id="uce1bcf75" class="ne-p"><span class="ne-text">d</span></p></td><td width="150"><p id="ueeb4b365" class="ne-p"><span class="ne-text">6.0</span></p></td></tr></tbody></table><p id="7d128243f99f1148c8232d032b1f703a" class="ne-p"><br></p><pre><code># 左连接pd.merge(df_obj1, df_obj2, left_on='key1', right_on='key2', how='left')</code></pre><p id="e7ff97059482740d29c9bac0032eae52" class="ne-p"><br></p><table id="a5cfc142" class="ne-table" style="width: 750px"><tbody><tr style="height: 33px"><td width="150"></td><td width="150"><p id="u63c99f94" class="ne-p"><span class="ne-text">key1</span></p></td><td width="150"><p id="ubdd125ab" class="ne-p"><span class="ne-text">data1</span></p></td><td width="150"><p id="u6421ee8e" class="ne-p"><span class="ne-text">key2</span></p></td><td width="150"><p id="u9fc23289" class="ne-p"><span class="ne-text">data2</span></p></td></tr><tr style="height: 33px"><td width="150"><p id="u7f1006fe" class="ne-p"><span class="ne-text">0</span></p></td><td width="150"><p id="uf196dabb" class="ne-p"><span class="ne-text">b</span></p></td><td width="150"><p id="u41a20ef9" class="ne-p"><span class="ne-text">sfd</span></p></td><td width="150"><p id="uc3a0fadb" class="ne-p"><span class="ne-text">b</span></p></td><td width="150"><p id="u4a05892f" class="ne-p"><span class="ne-text">6.0</span></p></td></tr><tr style="height: 33px"><td width="150"><p id="u8cae5ac7" class="ne-p"><span class="ne-text">1</span></p></td><td width="150"><p id="uc598fb00" class="ne-p"><span class="ne-text">b</span></p></td><td width="150"><p id="u089b308f" class="ne-p"><span class="ne-text">fdsf</span></p></td><td width="150"><p id="uf7ee4ade" class="ne-p"><span class="ne-text">b</span></p></td><td width="150"><p id="u14a13cfa" class="ne-p"><span class="ne-text">6.0</span></p></td></tr><tr style="height: 33px"><td width="150"><p id="u7bd97d12" class="ne-p"><span class="ne-text">2</span></p></td><td width="150"><p id="ua3b58d74" class="ne-p"><span class="ne-text">a</span></p></td><td width="150"><p id="u8f4e5089" class="ne-p"><span class="ne-text">we</span></p></td><td width="150"><p id="u2c17af4e" class="ne-p"><span class="ne-text">a</span></p></td><td width="150"><p id="udc3d9c6e" class="ne-p"><span class="ne-text">0.0</span></p></td></tr><tr style="height: 33px"><td width="150"><p id="ua7ff1057" class="ne-p"><span class="ne-text">3</span></p></td><td width="150"><p id="ud718c670" class="ne-p"><span class="ne-text">c</span></p></td><td width="150"><p id="u2c266203" class="ne-p"><span class="ne-text">24</span></p></td><td width="150"><p id="u321cd0ce" class="ne-p"><span class="ne-text">NaN</span></p></td><td width="150"><p id="u8b086260" class="ne-p"><span class="ne-text">NaN</span></p></td></tr><tr style="height: 33px"><td width="150"><p id="uca2089c3" class="ne-p"><span class="ne-text">4</span></p></td><td width="150"><p id="u19ce949e" class="ne-p"><span class="ne-text">a</span></p></td><td width="150"><p id="ua92ceec6" class="ne-p"><span class="ne-text">3253</span></p></td><td width="150"><p id="ub0d07af1" class="ne-p"><span class="ne-text">a</span></p></td><td width="150"><p id="u4d4af551" class="ne-p"><span class="ne-text">0.0</span></p></td></tr><tr style="height: 33px"><td width="150"><p id="ua633e260" class="ne-p"><span class="ne-text">5</span></p></td><td width="150"><p id="u202ea6ca" class="ne-p"><span class="ne-text">a</span></p></td><td width="150"><p id="u0e252d6b" class="ne-p"><span class="ne-text">234</span></p></td><td width="150"><p id="u30087809" class="ne-p"><span class="ne-text">a</span></p></td><td width="150"><p id="ua46ba011" class="ne-p"><span class="ne-text">0.0</span></p></td></tr><tr style="height: 33px"><td width="150"><p id="ue7928f90" class="ne-p"><span class="ne-text">6</span></p></td><td width="150"><p id="u7b35c690" class="ne-p"><span class="ne-text">b</span></p></td><td width="150"><p id="uda1ad5f6" class="ne-p"><span class="ne-text">23</span></p></td><td width="150"><p id="ud6bd06dc" class="ne-p"><span class="ne-text">b</span></p></td><td width="150"><p id="u18765b13" class="ne-p"><span class="ne-text">6.0</span></p></td></tr></tbody></table><p id="c27ff2da229f5c41d9452afc6596e283" class="ne-p"><br></p><pre><code># 右连接pd.merge(df_obj1, df_obj2, left_on='key1', right_on='key2', how='right')</code></pre><p id="c99867ca36cc05595165c7f88d7177dd" class="ne-p"><br></p><table id="89ba0ef8" class="ne-table" style="width: 750px"><tbody><tr style="height: 33px"><td width="150"></td><td width="150"><p id="u1b72c8f6" class="ne-p"><span class="ne-text">key1</span></p></td><td width="150"><p id="u13578791" class="ne-p"><span class="ne-text">data1</span></p></td><td width="150"><p id="ube4e68a3" class="ne-p"><span class="ne-text">key2</span></p></td><td width="150"><p id="u4c6bef6a" class="ne-p"><span class="ne-text">data2</span></p></td></tr><tr style="height: 33px"><td width="150"><p id="u850b96bd" class="ne-p"><span class="ne-text">0</span></p></td><td width="150"><p id="ufd624173" class="ne-p"><span class="ne-text">b</span></p></td><td width="150"><p id="ube886771" class="ne-p"><span class="ne-text">sfd</span></p></td><td width="150"><p id="u2adafbae" class="ne-p"><span class="ne-text">b</span></p></td><td width="150"><p id="u88182e42" class="ne-p"><span class="ne-text">6</span></p></td></tr><tr style="height: 33px"><td width="150"><p id="u72a1c694" class="ne-p"><span class="ne-text">1</span></p></td><td width="150"><p id="uad77ad88" class="ne-p"><span class="ne-text">b</span></p></td><td width="150"><p id="ub1c05071" class="ne-p"><span class="ne-text">fdsf</span></p></td><td width="150"><p id="ua0c89301" class="ne-p"><span class="ne-text">b</span></p></td><td width="150"><p id="ubeb4aa02" class="ne-p"><span class="ne-text">6</span></p></td></tr><tr style="height: 33px"><td width="150"><p id="u1cced7c1" class="ne-p"><span class="ne-text">2</span></p></td><td width="150"><p id="uddf830d2" class="ne-p"><span class="ne-text">b</span></p></td><td width="150"><p id="u8932a4a3" class="ne-p"><span class="ne-text">23</span></p></td><td width="150"><p id="u22034050" class="ne-p"><span class="ne-text">b</span></p></td><td width="150"><p id="u4a657573" class="ne-p"><span class="ne-text">6</span></p></td></tr><tr style="height: 33px"><td width="150"><p id="u9bc615fc" class="ne-p"><span class="ne-text">3</span></p></td><td width="150"><p id="u14060d29" class="ne-p"><span class="ne-text">a</span></p></td><td width="150"><p id="u95a7baf1" class="ne-p"><span class="ne-text">we</span></p></td><td width="150"><p id="ub78508cb" class="ne-p"><span class="ne-text">a</span></p></td><td width="150"><p id="u5a3df887" class="ne-p"><span class="ne-text">0</span></p></td></tr><tr style="height: 33px"><td width="150"><p id="u4b390fe9" class="ne-p"><span class="ne-text">4</span></p></td><td width="150"><p id="u20e5a6a2" class="ne-p"><span class="ne-text">a</span></p></td><td width="150"><p id="uf4629209" class="ne-p"><span class="ne-text">3253</span></p></td><td width="150"><p id="u60f55919" class="ne-p"><span class="ne-text">a</span></p></td><td width="150"><p id="u72a875b4" class="ne-p"><span class="ne-text">0</span></p></td></tr><tr style="height: 33px"><td width="150"><p id="u557bb0a4" class="ne-p"><span class="ne-text">5</span></p></td><td width="150"><p id="u187c0608" class="ne-p"><span class="ne-text">a</span></p></td><td width="150"><p id="ua92550d1" class="ne-p"><span class="ne-text">234</span></p></td><td width="150"><p id="u4bcf382e" class="ne-p"><span class="ne-text">a</span></p></td><td width="150"><p id="uea179258" class="ne-p"><span class="ne-text">0</span></p></td></tr><tr style="height: 33px"><td width="150"><p id="ubf0ad0fc" class="ne-p"><span class="ne-text">6</span></p></td><td width="150"><p id="u9a3d76ab" class="ne-p"><span class="ne-text">NaN</span></p></td><td width="150"><p id="u7aea8edf" class="ne-p"><span class="ne-text">NaN</span></p></td><td width="150"><p id="u3aeb1d5e" class="ne-p"><span class="ne-text">d</span></p></td><td width="150"><p id="ufc1fc8d0" class="ne-p"><span class="ne-text">6</span></p></td></tr></tbody></table><p id="11112ec21536f2c1ab276f8aec610529" class="ne-p"><br></p><h3 id="661c28ad"><span class="ne-text">处理重复列名suffixes</span></h3><p id="4e0f222c017990f038c3ec9ea9e0e1d2" class="ne-p"><br></p><pre><code># 处理重复列名df_obj1 = pd.DataFrame(&#123;'key': ['b', 'b', 'a', 'c', 'a', 'a', 'b'],                        'data' : np.random.randint(0,10,7)&#125;)df_obj2 = pd.DataFrame(&#123;'key': ['a', 'b', 'd'],                        'data' : np.random.randint(0,10,3)&#125;)<p>pd.merge(df_obj1, df_obj2, on=’key’, suffixes=(‘_left’, ‘_right’))<br></code></pre></p><p id="b6b4547a314821c4c01a1dc7018d74ff" class="ne-p"><br></p><table id="e549a09a" class="ne-table" style="width: 748px"><tbody><tr style="height: 33px"><td width="187"></td><td width="187"><p id="u4a7e6604" class="ne-p"><span class="ne-text">key</span></p></td><td width="187"><p id="uf5cc2932" class="ne-p"><span class="ne-text">data_left</span></p></td><td width="187"><p id="u3c649438" class="ne-p"><span class="ne-text">data_right</span></p></td></tr><tr style="height: 33px"><td width="187"><p id="u9010976f" class="ne-p"><span class="ne-text">0</span></p></td><td width="187"><p id="uf5846ba0" class="ne-p"><span class="ne-text">b</span></p></td><td width="187"><p id="ueba6a795" class="ne-p"><span class="ne-text">9</span></p></td><td width="187"><p id="u3c282e9e" class="ne-p"><span class="ne-text">1</span></p></td></tr><tr style="height: 33px"><td width="187"><p id="uc2575b0c" class="ne-p"><span class="ne-text">1</span></p></td><td width="187"><p id="ub7a980b1" class="ne-p"><span class="ne-text">b</span></p></td><td width="187"><p id="u04a43efb" class="ne-p"><span class="ne-text">1</span></p></td><td width="187"><p id="u38130794" class="ne-p"><span class="ne-text">1</span></p></td></tr><tr style="height: 33px"><td width="187"><p id="u51b27135" class="ne-p"><span class="ne-text">2</span></p></td><td width="187"><p id="u28efdd29" class="ne-p"><span class="ne-text">b</span></p></td><td width="187"><p id="u1c8e4402" class="ne-p"><span class="ne-text">6</span></p></td><td width="187"><p id="u7bbc7107" class="ne-p"><span class="ne-text">1</span></p></td></tr><tr style="height: 33px"><td width="187"><p id="uf8d7f6a9" class="ne-p"><span class="ne-text">3</span></p></td><td width="187"><p id="u29c2763c" class="ne-p"><span class="ne-text">a</span></p></td><td width="187"><p id="u3b68162b" class="ne-p"><span class="ne-text">7</span></p></td><td width="187"><p id="ued6e6d1b" class="ne-p"><span class="ne-text">1</span></p></td></tr><tr style="height: 33px"><td width="187"><p id="ue5500bd4" class="ne-p"><span class="ne-text">4</span></p></td><td width="187"><p id="ub942bbdb" class="ne-p"><span class="ne-text">a</span></p></td><td width="187"><p id="u72e7f305" class="ne-p"><span class="ne-text">3</span></p></td><td width="187"><p id="uad3535ca" class="ne-p"><span class="ne-text">1</span></p></td></tr><tr style="height: 33px"><td width="187"><p id="u1432cbbe" class="ne-p"><span class="ne-text">5</span></p></td><td width="187"><p id="uf5fe005d" class="ne-p"><span class="ne-text">a</span></p></td><td width="187"><p id="u4d9ccf9e" class="ne-p"><span class="ne-text">4</span></p></td><td width="187"><p id="ued5648dc" class="ne-p"><span class="ne-text">1</span></p></td></tr></tbody></table><p id="d9ff3f0273fafbf1a39678bd76e0137c" class="ne-p"><br></p><pre><code># 按索引连接df_obj3 = pd.DataFrame(&#123;'key': ['b', 'b', 'a', 'c', 'a', 'a', 'b'],                        'data1' : np.random.randint(0,10,7)&#125;)df_obj4 = pd.DataFrame(&#123;'data2' : np.random.randint(0,10,3)&#125;, index=['a', 'b', 'd'])</code></pre><p id="3f46b4f7a30dc33710afecd7d7bee118" class="ne-p"><br></p><pre><code>print(df_obj3)print(df_obj4)</code></pre><p id="4c1535115414f3abd8f35720a1efd400" class="ne-p"><br></p><pre><code>  key  data10   b      71   b      42   a      13   c      94   a      25   a      96   b      7   data2a      9b      4d      0</code></pre><p id="ba5cadd765601d9c81d3336139cf0825" class="ne-p"><br></p><pre><code>pd.merge(df_obj3, df_obj4, left_on='key', right_index=True)</code></pre><p id="3f8d7431b2331010ffc772e2f3cf0a85" class="ne-p"><br></p><table id="71c4d53b" class="ne-table" style="width: 748px"><tbody><tr style="height: 33px"><td width="187"></td><td width="187"><p id="ue676d06d" class="ne-p"><span class="ne-text">key</span></p></td><td width="187"><p id="u773ee3bd" class="ne-p"><span class="ne-text">data1</span></p></td><td width="187"><p id="u98abc2b3" class="ne-p"><span class="ne-text">data2</span></p></td></tr><tr style="height: 33px"><td width="187"><p id="u7b12e514" class="ne-p"><span class="ne-text">0</span></p></td><td width="187"><p id="u96db1dff" class="ne-p"><span class="ne-text">b</span></p></td><td width="187"><p id="u01b1f3a6" class="ne-p"><span class="ne-text">7</span></p></td><td width="187"><p id="u8723a135" class="ne-p"><span class="ne-text">4</span></p></td></tr><tr style="height: 33px"><td width="187"><p id="ud62cb7ec" class="ne-p"><span class="ne-text">1</span></p></td><td width="187"><p id="u4ce39eed" class="ne-p"><span class="ne-text">b</span></p></td><td width="187"><p id="uc03e835c" class="ne-p"><span class="ne-text">4</span></p></td><td width="187"><p id="ua2ac0b60" class="ne-p"><span class="ne-text">4</span></p></td></tr><tr style="height: 33px"><td width="187"><p id="u4f48427b" class="ne-p"><span class="ne-text">6</span></p></td><td width="187"><p id="ub55f40e5" class="ne-p"><span class="ne-text">b</span></p></td><td width="187"><p id="ufc6c45c9" class="ne-p"><span class="ne-text">7</span></p></td><td width="187"><p id="u217a4a0d" class="ne-p"><span class="ne-text">4</span></p></td></tr><tr style="height: 33px"><td width="187"><p id="u8df3b809" class="ne-p"><span class="ne-text">2</span></p></td><td width="187"><p id="u90b38f13" class="ne-p"><span class="ne-text">a</span></p></td><td width="187"><p id="u800bb8a5" class="ne-p"><span class="ne-text">1</span></p></td><td width="187"><p id="u1ec27293" class="ne-p"><span class="ne-text">9</span></p></td></tr><tr style="height: 33px"><td width="187"><p id="ub83510f3" class="ne-p"><span class="ne-text">4</span></p></td><td width="187"><p id="ua44e4b57" class="ne-p"><span class="ne-text">a</span></p></td><td width="187"><p id="u9ec1582c" class="ne-p"><span class="ne-text">2</span></p></td><td width="187"><p id="u609d6fc7" class="ne-p"><span class="ne-text">9</span></p></td></tr><tr style="height: 33px"><td width="187"><p id="ud2af22e4" class="ne-p"><span class="ne-text">5</span></p></td><td width="187"><p id="ue92a7dd3" class="ne-p"><span class="ne-text">a</span></p></td><td width="187"><p id="u2096078f" class="ne-p"><span class="ne-text">9</span></p></td><td width="187"><p id="u9b74a610" class="ne-p"><span class="ne-text">9</span></p></td></tr></tbody></table><p id="5a05660a53754f05ff35c456740b9b51" class="ne-p"><br></p><h3 id="49f47e6d"><span class="ne-text">按索引连接right_index</span></h3><p id="fbdbcd0395d391083d8cba07df975b14" class="ne-p"><br></p><pre><code># 按索引连接df_obj1 = pd.DataFrame(&#123;'key': ['b', 'b', 'a', 'c', 'a', 'a', 'b'],                        'data1' : np.random.randint(0,10,7)&#125;)df_obj2 = pd.DataFrame(&#123;'data2' : np.random.randint(0,10,3)&#125;, index=['a', 'b', 'd'])</code></pre><p id="71b3c11c2b0e69ca9f4e23331b1485a0" class="ne-p"><br></p><pre><code>print(df_obj1)print(df_obj2)</code></pre><p id="24292a6a36afdb16eaf0beb4b0307ac6" class="ne-p"><br></p><pre><code>  key  data10   b      01   b      22   a      73   c      34   a      15   a      16   b      6   data2a      2b      1d      1</code></pre><p id="76c85f57d29e2e47f13bb1002394a92e" class="ne-p"><br></p><pre><code>pd.merge(df_obj1, df_obj2, left_on='key', right_index=True)</code></pre><p id="9207b0b94ba6c1704d694ae6091c45b5" class="ne-p"><br></p><table id="5bb8d65c" class="ne-table" style="width: 748px"><tbody><tr style="height: 33px"><td width="187"></td><td width="187"><p id="uf3bbccca" class="ne-p"><span class="ne-text">key</span></p></td><td width="187"><p id="ub0f7d646" class="ne-p"><span class="ne-text">data1</span></p></td><td width="187"><p id="u3c2a3cee" class="ne-p"><span class="ne-text">data2</span></p></td></tr><tr style="height: 33px"><td width="187"><p id="u50247be0" class="ne-p"><span class="ne-text">0</span></p></td><td width="187"><p id="u8a9a7c9f" class="ne-p"><span class="ne-text">b</span></p></td><td width="187"><p id="u2613d70c" class="ne-p"><span class="ne-text">0</span></p></td><td width="187"><p id="u8fe6d22c" class="ne-p"><span class="ne-text">1</span></p></td></tr><tr style="height: 33px"><td width="187"><p id="uc9eb80e3" class="ne-p"><span class="ne-text">1</span></p></td><td width="187"><p id="uf478f8ad" class="ne-p"><span class="ne-text">b</span></p></td><td width="187"><p id="u517918ba" class="ne-p"><span class="ne-text">2</span></p></td><td width="187"><p id="u906a3b22" class="ne-p"><span class="ne-text">1</span></p></td></tr><tr style="height: 33px"><td width="187"><p id="u489501df" class="ne-p"><span class="ne-text">6</span></p></td><td width="187"><p id="u807e05c2" class="ne-p"><span class="ne-text">b</span></p></td><td width="187"><p id="u8e45dee3" class="ne-p"><span class="ne-text">6</span></p></td><td width="187"><p id="ue4a8525d" class="ne-p"><span class="ne-text">1</span></p></td></tr><tr style="height: 33px"><td width="187"><p id="udc9495fe" class="ne-p"><span class="ne-text">2</span></p></td><td width="187"><p id="u195f6007" class="ne-p"><span class="ne-text">a</span></p></td><td width="187"><p id="u563e1529" class="ne-p"><span class="ne-text">7</span></p></td><td width="187"><p id="u407404da" class="ne-p"><span class="ne-text">2</span></p></td></tr><tr style="height: 33px"><td width="187"><p id="u9785691e" class="ne-p"><span class="ne-text">4</span></p></td><td width="187"><p id="ue5d3ee74" class="ne-p"><span class="ne-text">a</span></p></td><td width="187"><p id="u2c0116bf" class="ne-p"><span class="ne-text">1</span></p></td><td width="187"><p id="ua8bb2afa" class="ne-p"><span class="ne-text">2</span></p></td></tr><tr style="height: 33px"><td width="187"><p id="uc7e474cc" class="ne-p"><span class="ne-text">5</span></p></td><td width="187"><p id="u8d2a21f6" class="ne-p"><span class="ne-text">a</span></p></td><td width="187"><p id="ud80ce599" class="ne-p"><span class="ne-text">1</span></p></td><td width="187"><p id="u4d897f62" class="ne-p"><span class="ne-text">2</span></p></td></tr></tbody></table><p id="77a619e17ed30f0aa7e15d95a32210ed" class="ne-p"><br></p><h2 id="9b60fc97"><span class="ne-text">四、数据合并</span></h2><p id="18edee4592a49ccf3ae67cced40b6cfa" class="ne-p"><br></p><ul class="ne-ul"><li id="77625b8c9b2ecf5eb6d780abee640b86"><span class="ne-text">数据合并 concat</span></li><li id="2b0cdfced0b3ad2f4227beea1b9c79d2"><span class="ne-text">按索引连接===right_index</span></li></ul><p id="ed6338172bda2d4a9c6507d9cda3239a" class="ne-p"><br></p><pre><code>import numpy as npimport pandas as pd</code></pre><p id="0b775728997e70e0f93d3a375db538ff" class="ne-p"><br></p><h3 id="49dc343d"><span class="ne-text">numpy的concat</span></h3><p id="c95569105529e86f35e53a62889ab33d" class="ne-p"><br></p><pre><code>arr1 = np.random.randint(0, 10, (3, 4))arr2 = np.random.randint(0, 10, (3, 4))<p>print (arr1)<br>print (arr2)<br></code></pre></p><p id="4a735d281237eaa1531b33085dd1f7fb" class="ne-p"><br></p><pre><code>[[6 0 3 2] [5 7 9 8] [5 8 0 3]][[6 5 7 9] [0 1 0 0] [1 1 1 7]]</code></pre><p id="02900d627a5f4e09d8afb126589748c1" class="ne-p"><br></p><pre><code>np.concatenate([arr1, arr2])</code></pre><p id="2769aa5948ecc8ea89d8e26b7355e256" class="ne-p"><br></p><pre><code>array([[6, 0, 3, 2],       [5, 7, 9, 8],       [5, 8, 0, 3],       [6, 5, 7, 9],       [0, 1, 0, 0],       [1, 1, 1, 7]])</code></pre><p id="14a136369610593e3e3f358328c7088d" class="ne-p"><br></p><pre><code>np.concatenate([arr1, arr2], axis=1)</code></pre><p id="78ccf6f53e5fc87cba6face79f6057dc" class="ne-p"><br></p><pre><code>array([[6, 0, 3, 2, 6, 5, 7, 9],       [5, 7, 9, 8, 0, 1, 0, 0],       [5, 8, 0, 3, 1, 1, 1, 7]])</code></pre><p id="512de7ce3af3c665b29a990bdaf86ceb" class="ne-p"><br></p><h3 id="e971060d"><span class="ne-text">series上的concat</span></h3><p id="dc665ce85f0e8c991214924a6ff21333" class="ne-p"><br></p><pre><code># index 没有重复的情况ser_obj1 = pd.Series(np.random.randint(0, 10, 5), index=range(0,5))ser_obj2 = pd.Series(np.random.randint(0, 10, 4), index=range(5,9))ser_obj3 = pd.Series(np.random.randint(0, 10, 3), index=range(9,12))</code></pre><p id="9375174b7428570213a03c2869e85e79" class="ne-p"><br></p><pre><code>pd.concat([ser_obj1, ser_obj2, ser_obj3])</code></pre><p id="2b5423ebc29fbb43211fa4a94cdc6482" class="ne-p"><br></p><pre><code>0     01     42     53     14     95     76     87     58     09     510    911    0dtype: int32</code></pre><p id="7a2aacd43d6294ea263f999cb56cdb6b" class="ne-p"><br></p><pre><code>pd.concat([ser_obj1, ser_obj2, ser_obj3], axis=1)</code></pre><p id="04a2ff893e8f69d45ea62966d979756b" class="ne-p"><br></p><table id="8427a3c9" class="ne-table" style="width: 748px"><tbody><tr style="height: 33px"><td width="187"></td><td width="187"><p id="u68272f85" class="ne-p"><span class="ne-text">0</span></p></td><td width="187"><p id="u9f251536" class="ne-p"><span class="ne-text">1</span></p></td><td width="187"><p id="ua0c573b4" class="ne-p"><span class="ne-text">2</span></p></td></tr><tr style="height: 33px"><td width="187"><p id="u2cb3f6be" class="ne-p"><span class="ne-text">0</span></p></td><td width="187"><p id="u64a4ba24" class="ne-p"><span class="ne-text">0.0</span></p></td><td width="187"><p id="ub35b7657" class="ne-p"><span class="ne-text">NaN</span></p></td><td width="187"><p id="u9259d2e3" class="ne-p"><span class="ne-text">NaN</span></p></td></tr><tr style="height: 33px"><td width="187"><p id="u974efbdd" class="ne-p"><span class="ne-text">1</span></p></td><td width="187"><p id="u9f73e4f3" class="ne-p"><span class="ne-text">4.0</span></p></td><td width="187"><p id="u598ff12c" class="ne-p"><span class="ne-text">NaN</span></p></td><td width="187"><p id="u9bcf9b46" class="ne-p"><span class="ne-text">NaN</span></p></td></tr><tr style="height: 33px"><td width="187"><p id="ufc476255" class="ne-p"><span class="ne-text">2</span></p></td><td width="187"><p id="u2a31a0b6" class="ne-p"><span class="ne-text">5.0</span></p></td><td width="187"><p id="ubc01f667" class="ne-p"><span class="ne-text">NaN</span></p></td><td width="187"><p id="u29df66d5" class="ne-p"><span class="ne-text">NaN</span></p></td></tr><tr style="height: 33px"><td width="187"><p id="ua6f10e9f" class="ne-p"><span class="ne-text">3</span></p></td><td width="187"><p id="u32b9d10e" class="ne-p"><span class="ne-text">1.0</span></p></td><td width="187"><p id="uf366b326" class="ne-p"><span class="ne-text">NaN</span></p></td><td width="187"><p id="ub37a92a6" class="ne-p"><span class="ne-text">NaN</span></p></td></tr><tr style="height: 33px"><td width="187"><p id="u573469cf" class="ne-p"><span class="ne-text">4</span></p></td><td width="187"><p id="u3365dbc7" class="ne-p"><span class="ne-text">9.0</span></p></td><td width="187"><p id="u46f1e3b7" class="ne-p"><span class="ne-text">NaN</span></p></td><td width="187"><p id="u552073d8" class="ne-p"><span class="ne-text">NaN</span></p></td></tr><tr style="height: 33px"><td width="187"><p id="ue83b0001" class="ne-p"><span class="ne-text">5</span></p></td><td width="187"><p id="ubf5df2de" class="ne-p"><span class="ne-text">NaN</span></p></td><td width="187"><p id="ufd454cbd" class="ne-p"><span class="ne-text">7.0</span></p></td><td width="187"><p id="uf3048786" class="ne-p"><span class="ne-text">NaN</span></p></td></tr><tr style="height: 33px"><td width="187"><p id="u6d2a712f" class="ne-p"><span class="ne-text">6</span></p></td><td width="187"><p id="u3d847a81" class="ne-p"><span class="ne-text">NaN</span></p></td><td width="187"><p id="u9086dcfe" class="ne-p"><span class="ne-text">8.0</span></p></td><td width="187"><p id="u263cd9b8" class="ne-p"><span class="ne-text">NaN</span></p></td></tr><tr style="height: 33px"><td width="187"><p id="uf9426871" class="ne-p"><span class="ne-text">7</span></p></td><td width="187"><p id="u418435d4" class="ne-p"><span class="ne-text">NaN</span></p></td><td width="187"><p id="u20bb670f" class="ne-p"><span class="ne-text">5.0</span></p></td><td width="187"><p id="uc920091e" class="ne-p"><span class="ne-text">NaN</span></p></td></tr><tr style="height: 33px"><td width="187"><p id="uad32547e" class="ne-p"><span class="ne-text">8</span></p></td><td width="187"><p id="u15cc9d57" class="ne-p"><span class="ne-text">NaN</span></p></td><td width="187"><p id="u234eee7b" class="ne-p"><span class="ne-text">0.0</span></p></td><td width="187"><p id="uc6b9510f" class="ne-p"><span class="ne-text">NaN</span></p></td></tr><tr style="height: 33px"><td width="187"><p id="u07396bb2" class="ne-p"><span class="ne-text">9</span></p></td><td width="187"><p id="u066a5866" class="ne-p"><span class="ne-text">NaN</span></p></td><td width="187"><p id="u7a34e029" class="ne-p"><span class="ne-text">NaN</span></p></td><td width="187"><p id="u4916b5a6" class="ne-p"><span class="ne-text">5.0</span></p></td></tr><tr style="height: 33px"><td width="187"><p id="uaf35c6b0" class="ne-p"><span class="ne-text">10</span></p></td><td width="187"><p id="u8ace6b4e" class="ne-p"><span class="ne-text">NaN</span></p></td><td width="187"><p id="uf4e1c731" class="ne-p"><span class="ne-text">NaN</span></p></td><td width="187"><p id="ue24c1d5e" class="ne-p"><span class="ne-text">9.0</span></p></td></tr><tr style="height: 33px"><td width="187"><p id="uc869a91e" class="ne-p"><span class="ne-text">11</span></p></td><td width="187"><p id="u424909af" class="ne-p"><span class="ne-text">NaN</span></p></td><td width="187"><p id="u24805868" class="ne-p"><span class="ne-text">NaN</span></p></td><td width="187"><p id="u4a968f40" class="ne-p"><span class="ne-text">0.0</span></p></td></tr></tbody></table><p id="12a40b9035ba00eb3d255135cc6f03cf" class="ne-p"><br></p><pre><code># index 有重复的情况ser_obj1 = pd.Series(np.random.randint(0, 10, 5), index=range(5))ser_obj2 = pd.Series(np.random.randint(0, 10, 4), index=range(4))ser_obj3 = pd.Series(np.random.randint(0, 10, 3), index=range(3))<p>print (ser_obj1)<br>print (ser_obj2)<br>print (ser_obj3)<br></code></pre></p><p id="65f2989eec41d9e3edbf15829d050c4b" class="ne-p"><br></p><pre><code>0    51    32    03    84    3dtype: int320    51    32    23    1dtype: int320    51    82    6dtype: int32</code></pre><p id="43e0399af1da657ae037dbcfa7ece246" class="ne-p"><br></p><pre><code>pd.concat([ser_obj1, ser_obj2, ser_obj3])</code></pre><p id="f0815a23c01cd10d1fa91c689cc8d459" class="ne-p"><br></p><pre><code>0    51    32    03    84    30    51    32    23    10    51    82    6dtype: int32</code></pre><p id="0d5c7ae2b016bcb65ea90fd972d2175f" class="ne-p"><br></p><pre><code>pd.concat([ser_obj1, ser_obj2, ser_obj3], axis=1, join='inner')</code></pre><p id="12b98ea80373f2aa707dcb8965a4766a" class="ne-p"><br></p><table id="e22433b0" class="ne-table" style="width: 748px"><tbody><tr style="height: 33px"><td width="187"></td><td width="187"><p id="u4ca4c7f7" class="ne-p"><span class="ne-text">0</span></p></td><td width="187"><p id="uf38912d4" class="ne-p"><span class="ne-text">1</span></p></td><td width="187"><p id="u4b7040a9" class="ne-p"><span class="ne-text">2</span></p></td></tr><tr style="height: 33px"><td width="187"><p id="u5b8f08c7" class="ne-p"><span class="ne-text">0</span></p></td><td width="187"><p id="u2824847e" class="ne-p"><span class="ne-text">5</span></p></td><td width="187"><p id="u187ea68a" class="ne-p"><span class="ne-text">5</span></p></td><td width="187"><p id="u3ca97659" class="ne-p"><span class="ne-text">5</span></p></td></tr><tr style="height: 33px"><td width="187"><p id="ue07e43b3" class="ne-p"><span class="ne-text">1</span></p></td><td width="187"><p id="ua2cd5759" class="ne-p"><span class="ne-text">3</span></p></td><td width="187"><p id="u72b9b04e" class="ne-p"><span class="ne-text">3</span></p></td><td width="187"><p id="u61b41737" class="ne-p"><span class="ne-text">8</span></p></td></tr><tr style="height: 33px"><td width="187"><p id="u76ff3900" class="ne-p"><span class="ne-text">2</span></p></td><td width="187"><p id="u82306db4" class="ne-p"><span class="ne-text">0</span></p></td><td width="187"><p id="u718c4f3a" class="ne-p"><span class="ne-text">2</span></p></td><td width="187"><p id="u3aa8d31a" class="ne-p"><span class="ne-text">6</span></p></td></tr></tbody></table><p id="919e295539e5d4ce048d1068bf02fc40" class="ne-p"><br></p><h3 id="335f7ae5"><span class="ne-text">dataframe上的concat</span></h3><p id="c4e24097651cc85c44624174455debf9" class="ne-p"><br></p><pre><code>df_obj1 = pd.DataFrame(np.random.randint(0, 10, (3, 2)), index=['a', 'b', 'c'],                       columns=['A', 'B'])df_obj2 = pd.DataFrame(np.random.randint(0, 10, (2, 2)), index=['a', 'b'],                       columns=['C', 'D'])print (df_obj1)print (df_obj2)</code></pre><p id="c3eddd7d60ed23308ecc08a06554c379" class="ne-p"><br></p><pre><code>   A  Ba  4  3b  8  1c  6  3   C  Da  1  3b  8  2</code></pre><p id="ed2fdeecaa0daa34d97a7d590aa87af5" class="ne-p"><br></p><pre><code>pd.concat([df_obj1, df_obj2])</code></pre><p id="077f4b0cfaf1fecffca7302f73362348" class="ne-p"><br></p><pre><code>C:\Users\wztli\Anaconda3\lib\site-packages\ipykernel_launcher.py:1: FutureWarning: Sorting because non-concatenation axis is not aligned. A future versionof pandas will change to not sort by default.<p>To accept the future behavior, pass ‘sort=False’.</p><p>To retain the current behavior and silence the warning, pass ‘sort=True’.</p><p>  &quot;&quot;&quot;Entry point for launching an IPython kernel.<br></code></pre></p><p id="fc316cf85cde91be2757489ae12b9135" class="ne-p"><br></p><table id="ac00ad54" class="ne-table" style="width: 750px"><tbody><tr style="height: 33px"><td width="150"></td><td width="150"><p id="uab796b30" class="ne-p"><span class="ne-text">A</span></p></td><td width="150"><p id="ue12b0137" class="ne-p"><span class="ne-text">B</span></p></td><td width="150"><p id="u271a66f0" class="ne-p"><span class="ne-text">C</span></p></td><td width="150"><p id="u6068b22c" class="ne-p"><span class="ne-text">D</span></p></td></tr><tr style="height: 33px"><td width="150"><p id="ub830ccf8" class="ne-p"><span class="ne-text">a</span></p></td><td width="150"><p id="u266f71bd" class="ne-p"><span class="ne-text">4.0</span></p></td><td width="150"><p id="u7542c263" class="ne-p"><span class="ne-text">3.0</span></p></td><td width="150"><p id="ubd7e4c4e" class="ne-p"><span class="ne-text">NaN</span></p></td><td width="150"><p id="ua283a993" class="ne-p"><span class="ne-text">NaN</span></p></td></tr><tr style="height: 33px"><td width="150"><p id="u529832e3" class="ne-p"><span class="ne-text">b</span></p></td><td width="150"><p id="ued5ad518" class="ne-p"><span class="ne-text">8.0</span></p></td><td width="150"><p id="u0557f4f4" class="ne-p"><span class="ne-text">1.0</span></p></td><td width="150"><p id="u1781a84c" class="ne-p"><span class="ne-text">NaN</span></p></td><td width="150"><p id="u7e92786c" class="ne-p"><span class="ne-text">NaN</span></p></td></tr><tr style="height: 33px"><td width="150"><p id="uae87b9fb" class="ne-p"><span class="ne-text">c</span></p></td><td width="150"><p id="u8c99268a" class="ne-p"><span class="ne-text">6.0</span></p></td><td width="150"><p id="u90adcf59" class="ne-p"><span class="ne-text">3.0</span></p></td><td width="150"><p id="ua2020bd0" class="ne-p"><span class="ne-text">NaN</span></p></td><td width="150"><p id="u1fe0774d" class="ne-p"><span class="ne-text">NaN</span></p></td></tr><tr style="height: 33px"><td width="150"><p id="u92a7afd0" class="ne-p"><span class="ne-text">a</span></p></td><td width="150"><p id="u2dcb7440" class="ne-p"><span class="ne-text">NaN</span></p></td><td width="150"><p id="u79a8b449" class="ne-p"><span class="ne-text">NaN</span></p></td><td width="150"><p id="u306e4273" class="ne-p"><span class="ne-text">1.0</span></p></td><td width="150"><p id="uf3df0c17" class="ne-p"><span class="ne-text">3.0</span></p></td></tr><tr style="height: 33px"><td width="150"><p id="uaed95ed2" class="ne-p"><span class="ne-text">b</span></p></td><td width="150"><p id="u6c477b1d" class="ne-p"><span class="ne-text">NaN</span></p></td><td width="150"><p id="u14989056" class="ne-p"><span class="ne-text">NaN</span></p></td><td width="150"><p id="u739f66ee" class="ne-p"><span class="ne-text">8.0</span></p></td><td width="150"><p id="u81b88095" class="ne-p"><span class="ne-text">2.0</span></p></td></tr></tbody></table><p id="67a9d50c87f86671b30abe750ad1c0b3" class="ne-p"><br></p><pre><code>pd.concat([df_obj1, df_obj2], axis=1)</code></pre><p id="9fbaee2702102560b31ed7ed296bd607" class="ne-p"><br></p><pre><code>C:\Users\wztli\Anaconda3\lib\site-packages\ipykernel_launcher.py:1: FutureWarning: Sorting because non-concatenation axis is not aligned. A future versionof pandas will change to not sort by default.<p>To accept the future behavior, pass ‘sort=False’.</p><p>To retain the current behavior and silence the warning, pass ‘sort=True’.</p><p>  &quot;&quot;&quot;Entry point for launching an IPython kernel.<br></code></pre></p><p id="40b9f3d4ca1045b61eb9d93d25f1dd72" class="ne-p"><br></p><table id="8a43a84b" class="ne-table" style="width: 750px"><tbody><tr style="height: 33px"><td width="150"></td><td width="150"><p id="u02e408f2" class="ne-p"><span class="ne-text">A</span></p></td><td width="150"><p id="u6d20e4f5" class="ne-p"><span class="ne-text">B</span></p></td><td width="150"><p id="u03bdd708" class="ne-p"><span class="ne-text">C</span></p></td><td width="150"><p id="ub2b48fa4" class="ne-p"><span class="ne-text">D</span></p></td></tr><tr style="height: 33px"><td width="150"><p id="u8143ea69" class="ne-p"><span class="ne-text">a</span></p></td><td width="150"><p id="ub12fb30e" class="ne-p"><span class="ne-text">4</span></p></td><td width="150"><p id="ud80ebe28" class="ne-p"><span class="ne-text">3</span></p></td><td width="150"><p id="u7b61c426" class="ne-p"><span class="ne-text">1.0</span></p></td><td width="150"><p id="ub409f483" class="ne-p"><span class="ne-text">3.0</span></p></td></tr><tr style="height: 33px"><td width="150"><p id="uae898043" class="ne-p"><span class="ne-text">b</span></p></td><td width="150"><p id="ua563c8cd" class="ne-p"><span class="ne-text">8</span></p></td><td width="150"><p id="u63ce1413" class="ne-p"><span class="ne-text">1</span></p></td><td width="150"><p id="u997b869a" class="ne-p"><span class="ne-text">8.0</span></p></td><td width="150"><p id="u8e61c765" class="ne-p"><span class="ne-text">2.0</span></p></td></tr><tr style="height: 33px"><td width="150"><p id="u2789d61f" class="ne-p"><span class="ne-text">c</span></p></td><td width="150"><p id="u7bc2332c" class="ne-p"><span class="ne-text">6</span></p></td><td width="150"><p id="u4498fc92" class="ne-p"><span class="ne-text">3</span></p></td><td width="150"><p id="ub5bb1127" class="ne-p"><span class="ne-text">NaN</span></p></td><td width="150"><p id="uc0abec00" class="ne-p"><span class="ne-text">NaN</span></p></td></tr></tbody></table><p id="8bfb15bac0ecf1b8c787dc7a01c2a028" class="ne-p"><br></p><h2 id="aaabb73c"><span class="ne-text">五、数据重构</span></h2><p id="09679efbcf9f47e02fee9a1a6d039b6a" class="ne-p"><br></p><pre><code>import numpy as npimport pandas as pd</code></pre><p id="6200b93aabb7c246f4f1f1fb4525e67f" class="ne-p"><br></p><h3 id="stack"><span class="ne-text">stack</span></h3><p id="5206bb1c95588434110c48ed5dcfa6aa" class="ne-p"><br></p><pre><code>df_obj = pd.DataFrame(np.random.randint(0,10, (5,2)), columns=['data1', 'data2'])df_obj</code></pre><p id="a837b226492db97471958ac9903b4432" class="ne-p"><br></p><table id="91086468" class="ne-table" style="width: 750px"><tbody><tr style="height: 33px"><td width="250"></td><td width="250"><p id="uc9e2ebb3" class="ne-p"><span class="ne-text">data1</span></p></td><td width="250"><p id="u8db106c0" class="ne-p"><span class="ne-text">data2</span></p></td></tr><tr style="height: 33px"><td width="250"><p id="u44268a4a" class="ne-p"><span class="ne-text">0</span></p></td><td width="250"><p id="udb7beff3" class="ne-p"><span class="ne-text">0</span></p></td><td width="250"><p id="udbfad175" class="ne-p"><span class="ne-text">4</span></p></td></tr><tr style="height: 33px"><td width="250"><p id="ufacb442c" class="ne-p"><span class="ne-text">1</span></p></td><td width="250"><p id="u08cff539" class="ne-p"><span class="ne-text">6</span></p></td><td width="250"><p id="ubd9a116a" class="ne-p"><span class="ne-text">2</span></p></td></tr><tr style="height: 33px"><td width="250"><p id="u08ee48c6" class="ne-p"><span class="ne-text">2</span></p></td><td width="250"><p id="uc383920b" class="ne-p"><span class="ne-text">9</span></p></td><td width="250"><p id="u542ab240" class="ne-p"><span class="ne-text">8</span></p></td></tr><tr style="height: 33px"><td width="250"><p id="u5cc68de2" class="ne-p"><span class="ne-text">3</span></p></td><td width="250"><p id="u636e6bb5" class="ne-p"><span class="ne-text">7</span></p></td><td width="250"><p id="uf1d60ada" class="ne-p"><span class="ne-text">0</span></p></td></tr><tr style="height: 33px"><td width="250"><p id="u8025f01a" class="ne-p"><span class="ne-text">4</span></p></td><td width="250"><p id="u03306ab8" class="ne-p"><span class="ne-text">3</span></p></td><td width="250"><p id="u1006e986" class="ne-p"><span class="ne-text">1</span></p></td></tr></tbody></table><p id="59f7ab51fb7b67a21d7164f545943fb5" class="ne-p"><br></p><pre><code>stacked = df_obj.stack()print (stacked)</code></pre><p id="7236f683db3fda28b0c683af2ce355b8" class="ne-p"><br></p><pre><code>0  data1    0   data2    41  data1    6   data2    22  data1    9   data2    83  data1    7   data2    04  data1    3   data2    1dtype: int32</code></pre><p id="0ed95166cddf4c254591d38d6d8d3ecb" class="ne-p"><br></p><pre><code>print (type(stacked))print (type(stacked.index))</code></pre><p id="a0f97e379854a606e012448962686ef5" class="ne-p"><br></p><pre><code>&lt;class 'pandas.core.series.Series'&gt;&lt;class 'pandas.core.indexes.multi.MultiIndex'&gt;</code></pre><p id="c14a7b185435507ea54db3144176f42e" class="ne-p"><br></p><h3 id="unstack"><span class="ne-text">unstack</span></h3><p id="289adf4c5e7a257346bc39676ca3849f" class="ne-p"><br></p><pre><code># 默认操作内层索引stacked.unstack()</code></pre><p id="25917fddfb9e9ef38ac7b69c0493ba5d" class="ne-p"><br></p><table id="91086468-1" class="ne-table" style="width: 750px"><tbody><tr style="height: 33px"><td width="250"></td><td width="250"><p id="u81e4bf05" class="ne-p"><span class="ne-text">data1</span></p></td><td width="250"><p id="ub06599cb" class="ne-p"><span class="ne-text">data2</span></p></td></tr><tr style="height: 33px"><td width="250"><p id="u07bbb3c4" class="ne-p"><span class="ne-text">0</span></p></td><td width="250"><p id="u2d4d6069" class="ne-p"><span class="ne-text">0</span></p></td><td width="250"><p id="ue44d5fa9" class="ne-p"><span class="ne-text">4</span></p></td></tr><tr style="height: 33px"><td width="250"><p id="ua1ad5523" class="ne-p"><span class="ne-text">1</span></p></td><td width="250"><p id="uf65a0b11" class="ne-p"><span class="ne-text">6</span></p></td><td width="250"><p id="u6b0d2066" class="ne-p"><span class="ne-text">2</span></p></td></tr><tr style="height: 33px"><td width="250"><p id="u8603d2a8" class="ne-p"><span class="ne-text">2</span></p></td><td width="250"><p id="u858ad280" class="ne-p"><span class="ne-text">9</span></p></td><td width="250"><p id="u209b4b73" class="ne-p"><span class="ne-text">8</span></p></td></tr><tr style="height: 33px"><td width="250"><p id="u718c743b" class="ne-p"><span class="ne-text">3</span></p></td><td width="250"><p id="u376daae7" class="ne-p"><span class="ne-text">7</span></p></td><td width="250"><p id="u773270ad" class="ne-p"><span class="ne-text">0</span></p></td></tr><tr style="height: 33px"><td width="250"><p id="u095b98a1" class="ne-p"><span class="ne-text">4</span></p></td><td width="250"><p id="ue3ac7448" class="ne-p"><span class="ne-text">3</span></p></td><td width="250"><p id="u249cb31f" class="ne-p"><span class="ne-text">1</span></p></td></tr></tbody></table><p id="82baa61bc650bac43fe315afe791d962" class="ne-p"><br></p><pre><code># 通过level指定操作索引的级别stacked.unstack(level=0)</code></pre><p id="d7e58703c322b81ee262bfede7ac4a5f" class="ne-p"><br></p><table id="2ff17a10" class="ne-table" style="width: 750px"><tbody><tr style="height: 33px"><td width="125"></td><td width="125"><p id="u8209af75" class="ne-p"><span class="ne-text">0</span></p></td><td width="125"><p id="u30cc3d16" class="ne-p"><span class="ne-text">1</span></p></td><td width="125"><p id="u5f8f0599" class="ne-p"><span class="ne-text">2</span></p></td><td width="125"><p id="u5df48f31" class="ne-p"><span class="ne-text">3</span></p></td><td width="125"><p id="u5a1b07ff" class="ne-p"><span class="ne-text">4</span></p></td></tr><tr style="height: 33px"><td width="125"><p id="uf7e9d9e7" class="ne-p"><span class="ne-text">data1</span></p></td><td width="125"><p id="uab1b1305" class="ne-p"><span class="ne-text">0</span></p></td><td width="125"><p id="u34b7f6c6" class="ne-p"><span class="ne-text">6</span></p></td><td width="125"><p id="u4e1d9e66" class="ne-p"><span class="ne-text">9</span></p></td><td width="125"><p id="ua84a0995" class="ne-p"><span class="ne-text">7</span></p></td><td width="125"><p id="uc02cc941" class="ne-p"><span class="ne-text">3</span></p></td></tr><tr style="height: 33px"><td width="125"><p id="u49b9b876" class="ne-p"><span class="ne-text">data2</span></p></td><td width="125"><p id="uf54625a0" class="ne-p"><span class="ne-text">4</span></p></td><td width="125"><p id="u848b644a" class="ne-p"><span class="ne-text">2</span></p></td><td width="125"><p id="udbac930f" class="ne-p"><span class="ne-text">8</span></p></td><td width="125"><p id="u8560deaa" class="ne-p"><span class="ne-text">0</span></p></td><td width="125"><p id="u1409f450" class="ne-p"><span class="ne-text">1</span></p></td></tr></tbody></table><p id="c3c3d38f0736bc7689d61d97fc990b67" class="ne-p"><br></p><h2 id="8b734d80"><span class="ne-text">六、数据转换</span></h2><p id="dd7c210c859d5825a6fc3a6970eeb989" class="ne-p"><br></p><pre><code>import numpy as npimport pandas as pd</code></pre><p id="1de42d69bb5e55f7742fe670a84e4017" class="ne-p"><br></p><h3 id="733c6e83"><span class="ne-text">重复数据duplicates函数</span></h3><p id="962a64b299d0f2297960980e1f901514" class="ne-p"><br></p><pre><code>df_obj = pd.DataFrame(&#123;'data1' : ['a'] * 4 + ['b'] * 4,                       'data2' : np.random.randint(0, 4, 8)&#125;)df_obj</code></pre><p id="6f619776294030ce1be0072f00a19853" class="ne-p"><br></p><table id="e04f5215" class="ne-table" style="width: 750px"><tbody><tr style="height: 33px"><td width="250"></td><td width="250"><p id="u29addf64" class="ne-p"><span class="ne-text">data1</span></p></td><td width="250"><p id="uf4c1bc65" class="ne-p"><span class="ne-text">data2</span></p></td></tr><tr style="height: 33px"><td width="250"><p id="u6da35f6c" class="ne-p"><span class="ne-text">0</span></p></td><td width="250"><p id="uac616efa" class="ne-p"><span class="ne-text">a</span></p></td><td width="250"><p id="ub8202c56" class="ne-p"><span class="ne-text">3</span></p></td></tr><tr style="height: 33px"><td width="250"><p id="u155bfe0c" class="ne-p"><span class="ne-text">1</span></p></td><td width="250"><p id="ub284bbba" class="ne-p"><span class="ne-text">a</span></p></td><td width="250"><p id="u1e5f62f4" class="ne-p"><span class="ne-text">2</span></p></td></tr><tr style="height: 33px"><td width="250"><p id="uf650c2c9" class="ne-p"><span class="ne-text">2</span></p></td><td width="250"><p id="ua8c0d965" class="ne-p"><span class="ne-text">a</span></p></td><td width="250"><p id="ud6e1ddc2" class="ne-p"><span class="ne-text">2</span></p></td></tr><tr style="height: 33px"><td width="250"><p id="u6928d329" class="ne-p"><span class="ne-text">3</span></p></td><td width="250"><p id="u4ece4166" class="ne-p"><span class="ne-text">a</span></p></td><td width="250"><p id="u5308bb48" class="ne-p"><span class="ne-text">1</span></p></td></tr><tr style="height: 33px"><td width="250"><p id="u5eca0bb9" class="ne-p"><span class="ne-text">4</span></p></td><td width="250"><p id="u60f0a88d" class="ne-p"><span class="ne-text">b</span></p></td><td width="250"><p id="ueb83b479" class="ne-p"><span class="ne-text">0</span></p></td></tr><tr style="height: 33px"><td width="250"><p id="u6c220b40" class="ne-p"><span class="ne-text">5</span></p></td><td width="250"><p id="uf15379a7" class="ne-p"><span class="ne-text">b</span></p></td><td width="250"><p id="u1f68bac9" class="ne-p"><span class="ne-text">2</span></p></td></tr><tr style="height: 33px"><td width="250"><p id="ue49eff14" class="ne-p"><span class="ne-text">6</span></p></td><td width="250"><p id="ua4b7ebc3" class="ne-p"><span class="ne-text">b</span></p></td><td width="250"><p id="udd5752c2" class="ne-p"><span class="ne-text">2</span></p></td></tr><tr style="height: 33px"><td width="250"><p id="ub1a2a5f1" class="ne-p"><span class="ne-text">7</span></p></td><td width="250"><p id="u60398876" class="ne-p"><span class="ne-text">b</span></p></td><td width="250"><p id="u206db7c0" class="ne-p"><span class="ne-text">1</span></p></td></tr></tbody></table><p id="5faea08b4e3bbc7b5a2ee0960b926599" class="ne-p"><br></p><pre><code>df_obj.duplicated()</code></pre><p id="2327004780c08df0e8ad8280ae74a217" class="ne-p"><br></p><pre><code>0    False1    False2     True3    False4    False5    False6     True7    Falsedtype: bool</code></pre><p id="7b51935ce28e051cf9e03153030e9bba" class="ne-p"><br></p><pre><code>df_obj.drop_duplicates()</code></pre><p id="42e64d2366041ba4f6a8abf12afc225e" class="ne-p"><br></p><table id="60f15592" class="ne-table" style="width: 750px"><tbody><tr style="height: 33px"><td width="250"></td><td width="250"><p id="u6ef0f98b" class="ne-p"><span class="ne-text">data1</span></p></td><td width="250"><p id="uce9c2d07" class="ne-p"><span class="ne-text">data2</span></p></td></tr><tr style="height: 33px"><td width="250"><p id="uea5fc425" class="ne-p"><span class="ne-text">0</span></p></td><td width="250"><p id="u0ec2791f" class="ne-p"><span class="ne-text">a</span></p></td><td width="250"><p id="u00a07693" class="ne-p"><span class="ne-text">3</span></p></td></tr><tr style="height: 33px"><td width="250"><p id="u41e18df0" class="ne-p"><span class="ne-text">1</span></p></td><td width="250"><p id="ud2250003" class="ne-p"><span class="ne-text">a</span></p></td><td width="250"><p id="u383b7309" class="ne-p"><span class="ne-text">2</span></p></td></tr><tr style="height: 33px"><td width="250"><p id="uf36ee208" class="ne-p"><span class="ne-text">3</span></p></td><td width="250"><p id="u0f4b3c9f" class="ne-p"><span class="ne-text">a</span></p></td><td width="250"><p id="uf1ef6594" class="ne-p"><span class="ne-text">1</span></p></td></tr><tr style="height: 33px"><td width="250"><p id="u0dffc0ed" class="ne-p"><span class="ne-text">4</span></p></td><td width="250"><p id="u14b2a985" class="ne-p"><span class="ne-text">b</span></p></td><td width="250"><p id="u2f08f83f" class="ne-p"><span class="ne-text">0</span></p></td></tr><tr style="height: 33px"><td width="250"><p id="uf8354273" class="ne-p"><span class="ne-text">5</span></p></td><td width="250"><p id="u85a7d9e0" class="ne-p"><span class="ne-text">b</span></p></td><td width="250"><p id="u44b593ca" class="ne-p"><span class="ne-text">2</span></p></td></tr><tr style="height: 33px"><td width="250"><p id="ua7d4d6bd" class="ne-p"><span class="ne-text">7</span></p></td><td width="250"><p id="u76e6704e" class="ne-p"><span class="ne-text">b</span></p></td><td width="250"><p id="u0a63610f" class="ne-p"><span class="ne-text">1</span></p></td></tr></tbody></table><p id="286808f0af9855277d74f3310fdfdee0" class="ne-p"><br></p><pre><code>df_obj.drop_duplicates('data2')</code></pre><p id="5ef194d891497497b7d9d24d10c447d9" class="ne-p"><br></p><table id="377e3648" class="ne-table" style="width: 750px"><tbody><tr style="height: 33px"><td width="250"></td><td width="250"><p id="u5dfa3cff" class="ne-p"><span class="ne-text">data1</span></p></td><td width="250"><p id="u20afa825" class="ne-p"><span class="ne-text">data2</span></p></td></tr><tr style="height: 33px"><td width="250"><p id="uab7ba142" class="ne-p"><span class="ne-text">0</span></p></td><td width="250"><p id="u4b24c996" class="ne-p"><span class="ne-text">a</span></p></td><td width="250"><p id="ub0e38445" class="ne-p"><span class="ne-text">3</span></p></td></tr><tr style="height: 33px"><td width="250"><p id="ua2dda83e" class="ne-p"><span class="ne-text">1</span></p></td><td width="250"><p id="ud09c3c1c" class="ne-p"><span class="ne-text">a</span></p></td><td width="250"><p id="u09b7e036" class="ne-p"><span class="ne-text">2</span></p></td></tr><tr style="height: 33px"><td width="250"><p id="ub942c0eb" class="ne-p"><span class="ne-text">3</span></p></td><td width="250"><p id="u92494f3f" class="ne-p"><span class="ne-text">a</span></p></td><td width="250"><p id="u55a6f46a" class="ne-p"><span class="ne-text">1</span></p></td></tr><tr style="height: 33px"><td width="250"><p id="uc494eb8b" class="ne-p"><span class="ne-text">4</span></p></td><td width="250"><p id="ub9808a69" class="ne-p"><span class="ne-text">b</span></p></td><td width="250"><p id="uf67e7889" class="ne-p"><span class="ne-text">0</span></p></td></tr></tbody></table><p id="6fb8ac6cc72bbf4d459ca4323c3369cf" class="ne-p"><br></p><h3 id="207de4ba"><span class="ne-text">map函数</span></h3><p id="0b852b014c420dfa44de29a2094f36bc" class="ne-p"><br></p><pre><code>ser_obj = pd.Series(np.random.randint(0,10,10))ser_obj</code></pre><p id="20f3b3fe6db7de5d960e0f9f3e5daa5c" class="ne-p"><br></p><pre><code>0    11    92    13    24    75    26    47    58    49    6dtype: int32</code></pre><p id="417b03bd67025a010d552a47f2557d9f" class="ne-p"><br></p><pre><code>ser_obj.map(lambda x : x ** 2)</code></pre><p id="1e8c432b1337e249a62dd72a98a9bd65" class="ne-p"><br></p><pre><code>0     11    812     13     44    495     46    167    258    169    36dtype: int64</code></pre><p id="1e529b753a515a1b0e602cd47d91e556" class="ne-p"><br></p><h3 id="1584db2b"><span class="ne-text">数据替换repalce</span></h3><p id="8110e898e645923cf5bdb0698a0ba85e" class="ne-p"><br></p><pre><code># 替换单个值ser_obj.replace(0, -100)</code></pre><p id="8acd89d411f1fe553a62e07956358d97" class="ne-p"><br></p><pre><code>0    11    92    13    24    75    26    47    58    49    6dtype: int32</code></pre><p id="b54c66d8f7e43413c0b8cf2346183aa0" class="ne-p"><br></p><pre><code># 替换多个值ser_obj.replace([0, 2], -100)</code></pre><p id="ecfa1ac314577c38da677bf50befe650" class="ne-p"><br></p><pre><code>0      11      92      13   -1004      75   -1006      47      58      49      6dtype: int32</code></pre><p id="068d5496b45003de6a59b69f9d88ef82" class="ne-p"><br></p><pre><code># 替换多个值ser_obj.replace([0, 2], [-100, -200])</code></pre><p id="72422fede5e8faea414154c40133d57f" class="ne-p"><br></p><pre><code>0      11      92      13   -2004      75   -2006      47      58      49      6dtype: int64</code></pre><p id="d65e0ebb83ebe63c7e11dc2777c3e2cc" class="ne-p"><br></p><pre><code>ser_obj.map(lambda x : x ** 2)<h4 id="3-数据替换repalce"><a href="#3-数据替换repalce" class="headerlink" title="3. 数据替换repalce"></a>3. 数据替换repalce</h4><h1 id="替换单个值"><a href="#替换单个值" class="headerlink" title="替换单个值"></a>替换单个值</h1><p>ser_obj.replace(0, -100)</p><h1 id="替换多个值"><a href="#替换多个值" class="headerlink" title="替换多个值"></a>替换多个值</h1><p>ser_obj.replace([0, 2], -100)</p><h1 id="替换多个值-1"><a href="#替换多个值-1" class="headerlink" title="替换多个值"></a>替换多个值</h1><p>ser_obj.replace([0, 2], [-100, -200])<br></code></pre></p><p id="ec9881a62ad4fb02d90aa9fa8ea52c70" class="ne-p"><br></p><pre><code>0      11      92      13   -2004      75   -2006      47      58      49      6dtype: int64</code></pre></div>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
          <category> 数据分析 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Python的本地各类数据读取</title>
      <link href="/blog/lb8ugs/"/>
      <url>/blog/lb8ugs/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h2 id="hySBP"><span class="ne-text">一、TXT文件操作</span></h2><p id="1c9b06a4e45017a35246f5a956dbff9f" class="ne-p"><br></p><h3 id="fc1ffaa9"><span class="ne-text">读取全部内容</span></h3><p id="f8b3b85cbf63cd7d657993e7c313dea0" class="ne-p"><br></p><pre><code>import numpy as npimport pandas as pd</code></pre><p id="2ef521d6e78e5bd3c4b078614ecda820" class="ne-p"><br></p><pre><code>txt_filename = './files/python_wiki.txt'<h1 id="打开文件"><a href="#打开文件" class="headerlink" title="打开文件"></a>打开文件</h1><p>file_obj = open(txt_filename,’r’)</p><h1 id="读取整个文件内容"><a href="#读取整个文件内容" class="headerlink" title="读取整个文件内容"></a>读取整个文件内容</h1><p>all_content = file_obj.read()</p><h1 id="关闭文件"><a href="#关闭文件" class="headerlink" title="关闭文件"></a>关闭文件</h1><p>file_obj.close()</p><p>print (all_content)<br></code></pre></p><p id="ab2d0261ee3db68b4444bcaed3276ee7" class="ne-p"><br></p><pre><code>Python is a widely used high-level, general-purpose, interpreted, dynamic programming language.[24][25] Its design philosophy emphasizes code readability, and its syntax allows programmers to express concepts in fewer lines of code than possible in languages such as C++ or Java.[26][27] The language provides constructs intended to enable writing clear programs on both a small and large scale.[28]Python supports multiple programming paradigms, including object-oriented, imperative and functional programming or procedural styles. It features a dynamic type system and automatic memory management and has a large and comprehensive standard library.[29]Python interpreters are available for many operating systems, allowing Python code to run on a wide variety of systems. CPython, the reference implementation of Python, is open source software[30] and has a community-based development model, as do nearly all of its variant implementations. CPython is managed by the non-profit Python Software Foundation.</code></pre><p id="e129906e27765b599f204b1b8169af57" class="ne-p"><br></p><h3 id="860fcf92"><span class="ne-text">逐行读取</span></h3><p id="f00ce072fcafc401962a7c1589be41f8" class="ne-p"><br></p><pre><code>txt_filename = './files/python_wiki.txt'<h1 id="打开文件-1"><a href="#打开文件-1" class="headerlink" title="打开文件"></a>打开文件</h1><p>file_obj = open(txt_filename, ‘r’)</p><h1 id="逐行读取"><a href="#逐行读取" class="headerlink" title="逐行读取"></a>逐行读取</h1><p>line1 = file_obj.readline()<br>print (line1)<br></code></pre></p><p id="08164aae7ba5f46e00c7c3de7c78a689" class="ne-p"><br></p><pre><code>Python is a widely used high-level, general-purpose, interpreted, dynamic programming language.[24][25] Its design philosophy emphasizes code readability, and its syntax allows programmers to express concepts in fewer lines of code than possible in languages such as C++ or Java.[26][27] The language provides constructs intended to enable writing clear programs on both a small and large scale.[28]</code></pre><p id="69c6e7752fe1dea536ca1121a52939e9" class="ne-p"><br></p><pre><code># 继续读下一行【不会全部读完】line2 = file_obj.readline()print (line2)<h1 id="关闭文件-1"><a href="#关闭文件-1" class="headerlink" title="关闭文件"></a>关闭文件</h1><p>file_obj.close()<br></code></pre></p><p id="3f2e8b02a7ed006a6d01deff9a3bac9a" class="ne-p"><br></p><pre><code>Python supports multiple programming paradigms, including object-oriented, imperative and functional programming or procedural styles. It features a dynamic type system and automatic memory management and has a large and comprehensive standard library.[29]</code></pre><p id="8c4d59e7927553b74a20906863242be2" class="ne-p"><br></p><h3 id="6d74200a"><span class="ne-text">读取全部内容，返回列表</span></h3><p id="fa2bcf2fcb6e146fe78f834a79cc9287" class="ne-p"><br></p><pre><code>txt_filename = './files/python_wiki.txt'<h1 id="打开文件-2"><a href="#打开文件-2" class="headerlink" title="打开文件"></a>打开文件</h1><p>file_obj = open(txt_filename, ‘r’)</p><p>lines = file_obj.readlines()</p><p>for i, line in enumerate(lines):<br>    print (‘%i: %s’ %(i, line))</p><h1 id="关闭文件-2"><a href="#关闭文件-2" class="headerlink" title="关闭文件"></a>关闭文件</h1><p>file_obj.close()<br></code></pre></p><p id="506b5bc3702daaa64b6c95ca566be89e" class="ne-p"><br></p><pre><code>0: Python is a widely used high-level, general-purpose, interpreted, dynamic programming language.[24][25] Its design philosophy emphasizes code readability, and its syntax allows programmers to express concepts in fewer lines of code than possible in languages such as C++ or Java.[26][27] The language provides constructs intended to enable writing clear programs on both a small and large scale.[28]<p>1: Python supports multiple programming paradigms, including object-oriented, imperative and functional programming or procedural styles. It features a dynamic type system and automatic memory management and has a large and comprehensive standard library.[29]</p><p>2: Python interpreters are available for many operating systems, allowing Python code to run on a wide variety of systems. CPython, the reference implementation of Python, is open source software[30] and has a community-based development model, as do nearly all of its variant implementations. CPython is managed by the non-profit Python Software Foundation.<br></code></pre></p><p id="3a7861dc4373f577ad38e1d05f0d0269" class="ne-p"><br></p><h3 id="a6abfd3f"><span class="ne-text">写操作</span></h3><p id="159ed0fa4aba36e6e9495976d4a7fe97" class="ne-p"><br></p><pre><code>txt_filename = './files/test_write.txt'<h1 id="打开文件-3"><a href="#打开文件-3" class="headerlink" title="打开文件"></a>打开文件</h1><p>file_obj = open(txt_filename, ‘w’)</p><h1 id="写入全部内容"><a href="#写入全部内容" class="headerlink" title="写入全部内容"></a>写入全部内容</h1><p>file_obj.write(&quot;《Python数据分析》&quot;)<br>file_obj.close()<br></code></pre></p><p id="b83ffa419fcf75c8aad6deafabb58d8b" class="ne-p"><br></p><pre><code>txt_filename = './files/test_write.txt'<h1 id="打开文件-4"><a href="#打开文件-4" class="headerlink" title="打开文件"></a>打开文件</h1><p>file_obj = open(txt_filename, ‘w’)</p><h1 id="写入字符串列表"><a href="#写入字符串列表" class="headerlink" title="写入字符串列表"></a>写入字符串列表</h1><p>lines = [‘这是第%i行\n’ %n for n in range(10)]<br>file_obj.writelines(lines)<br>file_obj.close()<br></code></pre></p><p id="d06bef75376975bd3bc0a0d155127988" class="ne-p"><br></p><h3 id="ece39eee"><span class="ne-text">with语句</span></h3><p id="be6c4c96a3fdfed287890aa5f5cb58e7" class="ne-p"><br></p><pre><code>txt_filename = './files/test_write.txt'with open(txt_filename, 'r') as f_obj:    print (f_obj.read())</code></pre><p id="20da9e61a49a7df4edf7f2b593ca2a54" class="ne-p"><br></p><pre><code>这是第0行这是第1行这是第2行这是第3行这是第4行这是第5行这是第6行这是第7行这是第8行这是第9行</code></pre><p id="6cde88e7c1102a0f9a40735637acec60" class="ne-p"><br></p><h2 id="3a91feb2"><span class="ne-text">二、CSV文件操作</span></h2><p id="5a4f81942757a22fa388b6c0b4af6298" class="ne-p"><br></p><h3 id="dfca1c51"><span class="ne-text">pandas读csv文件</span></h3><p id="04d24e7b60414a9109ef046e9e9e6745" class="ne-p"><br></p><div class="ne-quote"><p id="04734f996dc385c7f7a3219efc22d369" class="ne-p"><span class="ne-text">根据路径导入数据以及指定的列</span></p></div><p id="a334378bf4e6d817955aa5f6b784ad2c" class="ne-p"><br></p><pre><code>import pandas as pdfilename = './files/presidential_polls.csv'df = pd.read_csv(filename, usecols=['cycle', 'type', 'startdate'])#导入指定列print (type(df))print (df.head())</code></pre><p id="e99007d2ec0f37f2563be81f597cc2c0" class="ne-p"><br></p><pre><code>&lt;class 'pandas.core.frame.DataFrame'&gt;   cycle        type   startdate0   2016  polls-plus  10/25/20161   2016  polls-plus  10/27/20162   2016  polls-plus  10/27/20163   2016  polls-plus  10/20/20164   2016  polls-plus  10/20/2016</code></pre><p id="0fdaeaa72fecc96be92e86c9e23edbfa" class="ne-p"><br></p><div class="ne-quote"><p id="4106cad5392914f7900a5edea9ac1b28" class="ne-p"><span class="ne-text">引用指定的列</span></p></div><p id="79cccf8e9be9ef03ac67a917b2534c9f" class="ne-p"><br></p><pre><code>cycle_se = df['cycle']print (type(cycle_se))print (cycle_se.head())</code></pre><p id="14f96d9c6ceb9804fdc8a4761b1adb9c" class="ne-p"><br></p><pre><code>&lt;class 'pandas.core.series.Series'&gt;0    20161    20162    20163    20164    2016Name: cycle, dtype: int64</code></pre><p id="e84f6bea4b935b931b7e234518bd1ef2" class="ne-p"><br></p><div class="ne-quote"><p id="d98a82f4c9a4bfa87fdc429c9e3e4ac5" class="ne-p"><span class="ne-text">多层索引成dataframe类型</span></p></div><p id="70fdea5cf6a5a49d2d47b7bf47f1206b" class="ne-p"><br></p><pre><code>filename = './files/presidential_polls.csv'df1 = pd.read_csv(filename,usecols=['cycle', 'type', 'startdate','state','grade'],index_col = ['state','grade'])print(df1.head())</code></pre><p id="aff7543c7487ecd2c86604de3c379216" class="ne-p"><br></p><pre><code>                cycle        type   startdatestate    grade                               U.S.     B       2016  polls-plus  10/25/2016         A+      2016  polls-plus  10/27/2016Virginia A+      2016  polls-plus  10/27/2016Florida  A       2016  polls-plus  10/20/2016U.S.     B+      2016  polls-plus  10/20/2016</code></pre><p id="18fe5de52d442afbe9772aa7955c12fd" class="ne-p"><br></p><div class="ne-quote"><p id="13314ed439c33a5fe4922bde8d9a8c78" class="ne-p"><span class="ne-text">跳过指定的行</span></p></div><p id="ff64956c6963c2664b162d2083b73443" class="ne-p"><br></p><pre><code>filename = './files/presidential_polls.csv'df2 = pd.read_csv(filename,usecols=['cycle', 'type', 'startdate','state','grade'],skiprows=[1, 2, 3])print(df2.head())</code></pre><p id="6a053627e1226f45edce047e5eea3099" class="ne-p"><br></p><pre><code>   cycle        type         state   startdate grade0   2016  polls-plus       Florida  10/20/2016     A1   2016  polls-plus          U.S.  10/20/2016    B+2   2016  polls-plus          U.S.  10/22/2016     A3   2016  polls-plus          U.S.  10/26/2016    A-4   2016  polls-plus  Pennsylvania  10/25/2016    B-</code></pre><p id="3048a9d40f77221188429b68c772df3d" class="ne-p"><br></p><h3 id="896b1553"><span class="ne-text">pandas写csv文件</span></h3><p id="cfefff088e31631da34fbb16c2dde3ef" class="ne-p"><br></p><div class="ne-quote"><p id="e716063f9215d4cf52dddb31221423e1" class="ne-p"><span class="ne-text">·to_csv里面的index参数作用？===可能是不要索引的意思。</span></p></div><p id="efae2139ae49d34ef186b80471b67531" class="ne-p"><br></p><pre><code>filename = './files/pandas_output.csv'df.to_csv(filename, index=None)</code></pre><p id="777151de6c4351819f024109e6406d9d" class="ne-p"><br></p><h2 id="6832156e"><span class="ne-text">三、JSON文件操作</span></h2><p id="2031561c5a224041b84b08e29f06a472" class="ne-p"><br></p><h3 id="0fefaed0"><span class="ne-text">json读操作</span></h3><p id="10bf27a11c1b1734918c2b60c6cc076a" class="ne-p"><br></p><pre><code>import json<p>filename = ‘./files/global_temperature.json’<br>with open(filename, ‘r’) as f_obj:<br>    json_data = json.load(f_obj)</p><h1 id="返回值是dict类型"><a href="#返回值是dict类型" class="headerlink" title="返回值是dict类型"></a>返回值是dict类型</h1><p>print (type(json_data))<br></code></pre></p><p id="04cbdd67a6fc9ffe61a152ff1194db6a" class="ne-p"><br></p><pre><code>&lt;class 'dict'&gt;</code></pre><p id="1156617fa842af2a7070c342e7920a16" class="ne-p"><br></p><pre><code>print (json_data.keys())</code></pre><p id="95c158ff6cfe1900ad15a95e17b299dd" class="ne-p"><br></p><pre><code>dict_keys(['description', 'data'])</code></pre><p id="bb111a55ee5d5d4e11636eba951f1a91" class="ne-p"><br></p><h3 id="b95c783a"><span class="ne-text">json转CSV</span></h3><p id="13e42db0ba90e22adafbcc53d51c1e6b" class="ne-p"><br></p><pre><code>#print json_data['data'].keys()print (json_data['data'].values())</code></pre><p id="256c1b572f61798c06fd44efb1ca8c97" class="ne-p"><br></p><pre><code>dict_values(['-0.1247', '-0.0707', '-0.0710', '-0.1481', '-0.2099', '-0.2220', '-0.2101', '-0.2559', '-0.1541', '-0.1032', '-0.3233', '-0.2552', '-0.3079', '-0.3221', '-0.2828', '-0.2279', '-0.0971', '-0.1232', '-0.2578', '-0.1172', '-0.0704', '-0.1471', '-0.2535', '-0.3442', '-0.4240', '-0.2967', '-0.2208', '-0.3767', '-0.4441', '-0.4332', '-0.3862', '-0.4367', '-0.3318', '-0.3205', '-0.1444', '-0.0747', '-0.2979', '-0.3193', '-0.2118', '-0.2082', '-0.2152', '-0.1517', '-0.2318', '-0.2161', '-0.2510', '-0.1464', '-0.0618', '-0.1506', '-0.1749', '-0.2982', '-0.1016', '-0.0714', '-0.1214', '-0.2481', '-0.1075', '-0.1445', '-0.1173', '-0.0204', '-0.0318', '-0.0157', '0.0927', '0.1974', '0.1549', '0.1598', '0.2948', '0.1754', '-0.0013', '-0.0455', '-0.0471', '-0.0550', '-0.1579', '-0.0095', '0.0288', '0.0997', '-0.1118', '-0.1305', '-0.1945', '0.0538', '0.1145', '0.0640', '0.0252', '0.0818', '0.0924', '0.1100', '-0.1461', '-0.0752', '-0.0204', '-0.0112', '-0.0282', '0.0937', '0.0383', '-0.0775', '0.0280', '0.1654', '-0.0698', '0.0060', '-0.0769', '0.1996', '0.1139', '0.2288', '0.2651', '0.3024', '0.1836', '0.3429', '0.1510', '0.1357', '0.2308', '0.3710', '0.3770', '0.2982', '0.4350', '0.4079', '0.2583', '0.2857', '0.3420', '0.4593', '0.3225', '0.5185', '0.6335', '0.4427', '0.4255', '0.5455', '0.6018', '0.6145', '0.5806', '0.6583', '0.6139', '0.6113', '0.5415', '0.6354', '0.7008', '0.5759', '0.6219', '0.6687', '0.7402', '0.8990'])</code></pre><p id="8acd6f2f6686a2424f8d17e0ac95a049" class="ne-p"><br></p><pre><code># 转换keyyear_str_lst = json_data['data'].keys()year_lst = [int(year_str) for year_str in year_str_lst]print (year_lst)</code></pre><p id="4f5fe92ae245e12848eb2911b1b91d90" class="ne-p"><br></p><pre><code>[1880, 1881, 1882, 1883, 1884, 1885, 1886, 1887, 1888, 1889, 1890, 1891, 1892, 1893, 1894, 1895, 1896, 1897, 1898, 1899, 1900, 1901, 1902, 1903, 1904, 1905, 1906, 1907, 1908, 1909, 1910, 1911, 1912, 1913, 1914, 1915, 1916, 1917, 1918, 1919, 1920, 1921, 1922, 1923, 1924, 1925, 1926, 1927, 1928, 1929, 1930, 1931, 1932, 1933, 1934, 1935, 1936, 1937, 1938, 1939, 1940, 1941, 1942, 1943, 1944, 1945, 1946, 1947, 1948, 1949, 1950, 1951, 1952, 1953, 1954, 1955, 1956, 1957, 1958, 1959, 1960, 1961, 1962, 1963, 1964, 1965, 1966, 1967, 1968, 1969, 1970, 1971, 1972, 1973, 1974, 1975, 1976, 1977, 1978, 1979, 1980, 1981, 1982, 1983, 1984, 1985, 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015]</code></pre><p id="5382a951b36086d4ee93fba19a12fd3f" class="ne-p"><br></p><pre><code># 转换valuetemp_str_lst = json_data['data'].values()temp_lst = [float(temp_str) for temp_str in temp_str_lst]print (temp_lst)</code></pre><p id="e6ce978a209f8e1ff180bebed920d286" class="ne-p"><br></p><pre><code>[-0.1247, -0.0707, -0.071, -0.1481, -0.2099, -0.222, -0.2101, -0.2559, -0.1541, -0.1032, -0.3233, -0.2552, -0.3079, -0.3221, -0.2828, -0.2279, -0.0971, -0.1232, -0.2578, -0.1172, -0.0704, -0.1471, -0.2535, -0.3442, -0.424, -0.2967, -0.2208, -0.3767, -0.4441, -0.4332, -0.3862, -0.4367, -0.3318, -0.3205, -0.1444, -0.0747, -0.2979, -0.3193, -0.2118, -0.2082, -0.2152, -0.1517, -0.2318, -0.2161, -0.251, -0.1464, -0.0618, -0.1506, -0.1749, -0.2982, -0.1016, -0.0714, -0.1214, -0.2481, -0.1075, -0.1445, -0.1173, -0.0204, -0.0318, -0.0157, 0.0927, 0.1974, 0.1549, 0.1598, 0.2948, 0.1754, -0.0013, -0.0455, -0.0471, -0.055, -0.1579, -0.0095, 0.0288, 0.0997, -0.1118, -0.1305, -0.1945, 0.0538, 0.1145, 0.064, 0.0252, 0.0818, 0.0924, 0.11, -0.1461, -0.0752, -0.0204, -0.0112, -0.0282, 0.0937, 0.0383, -0.0775, 0.028, 0.1654, -0.0698, 0.006, -0.0769, 0.1996, 0.1139, 0.2288, 0.2651, 0.3024, 0.1836, 0.3429, 0.151, 0.1357, 0.2308, 0.371, 0.377, 0.2982, 0.435, 0.4079, 0.2583, 0.2857, 0.342, 0.4593, 0.3225, 0.5185, 0.6335, 0.4427, 0.4255, 0.5455, 0.6018, 0.6145, 0.5806, 0.6583, 0.6139, 0.6113, 0.5415, 0.6354, 0.7008, 0.5759, 0.6219, 0.6687, 0.7402, 0.899]</code></pre><p id="f3d86cbf3e1555be8b8f2276b2c878a9" class="ne-p"><br></p><pre><code>import pandas as pd<h1 id="构建-dataframe"><a href="#构建-dataframe" class="headerlink" title="构建 dataframe"></a>构建 dataframe</h1><p>year_se = pd.Series(year_lst, name = ‘year’)<br>temp_se = pd.Series(temp_lst, name = ‘temperature’)<br>result_df = pd.concat([year_se, temp_se], axis = 1)<br>print (result_df.head())</p><h1 id="保存csv"><a href="#保存csv" class="headerlink" title="保存csv"></a>保存csv</h1><p>result_df.to_csv(‘./files/json_to_csv.csv’, index = None)<br></code></pre></p><p id="66213c9d50b791c5fb81465766ba1567" class="ne-p"><br></p><pre><code>   year  temperature0  1880      -0.12471  1881      -0.07072  1882      -0.07103  1883      -0.14814  1884      -0.2099</code></pre><p id="4e2627fb42b99e36edb796ea2391053f" class="ne-p"><br></p><h3 id="f39917fb"><span class="ne-text">写json操作</span></h3><p id="e3e0c809313dd9acc8efdfe28109da6e" class="ne-p"><br></p><pre><code>book_dict = [&#123;'书名':'无声告白', '作者':'伍绮诗'&#125;, &#123;'书名':'我不是潘金莲', '作者':'刘震云'&#125;, &#123;'书名':'沉默的大多数 (王小波集)', '作者':'王小波'&#125;]<p>filename = ‘./files/json_output.json’<br>with open(filename, ‘w’) as f_obj:<br>    f_obj.write(json.dumps(book_dict, ensure_ascii=False))</p><h1 id="不需要加-encoding-’utf-8’参数"><a href="#不需要加-encoding-’utf-8’参数" class="headerlink" title="不需要加, encoding=’utf-8’参数"></a>不需要加, encoding=’utf-8’参数</h1><p></code></pre></p><p id="e0838705451009103208b8a8306257bd" class="ne-p"><br></p><h2 id="5f1a3adb"><span class="ne-text">四、SQLite基本操作</span></h2><p id="3d4ad084b1d1f36784fd7f7a615be5be" class="ne-p"><br></p><h3 id="a29c5a85"><span class="ne-text">连接数据库</span></h3><p id="9fb26e4428f21542bdfb2463bddd0ad8" class="ne-p"><br></p><pre><code>import sqlite3<p>db_path = ‘./files/test.sqlite’</p><p>conn = sqlite3.connect(db_path)<br>cur = conn.cursor()<br>conn.text_factory = str  # 处理中文<br></code></pre></p><p id="64dfb468bc2cc7c05ca18b5b16005def" class="ne-p"><br></p><h3 id="9c5e1e6b"><span class="ne-text">获取基本信息</span></h3><p id="da9e0348ebe33d1ac1eb74266dcba47c" class="ne-p"><br></p><pre><code>cur.execute('SELECT SQLITE_VERSION()')<p>print (‘SQLite版本：%s’ %str(cur.fetchone()[0]))<br></code></pre></p><p id="b88625a36beae1e4f63b766b42737e8d" class="ne-p"><br></p><pre><code>SQLite版本：3.30.0</code></pre><p id="e6d2ea5de28ce8a42ead8c83a00f210b" class="ne-p"><br></p><h3 id="643f6530"><span class="ne-text">逐条插入数据</span></h3><p id="743378636855064d52fabb5891f290f5" class="ne-p"><br></p><pre><code>cur.execute(&quot;DROP TABLE IF EXISTS book&quot;)cur.execute(&quot;CREATE TABLE book(id INT, name TEXT, price DOUBLE)&quot;)cur.execute(&quot;INSERT INTO book VALUES(1,'肖秀荣考研书系列:肖秀荣(2017)考研政治命题人终极预测4套卷',14.40)&quot;)cur.execute(&quot;INSERT INTO book VALUES(2,'法医秦明作品集:幸存者+清道夫+尸语者+无声的证词+第十一根手指(套装共5册) (两种封面随机发货)',100.00)&quot;)cur.execute(&quot;INSERT INTO book VALUES(3,'活着本来单纯:丰子恺散文漫画精品集(收藏本)',30.90)&quot;)cur.execute(&quot;INSERT INTO book VALUES(4,'自在独行:贾平凹的独行世界',26.80)&quot;)cur.execute(&quot;INSERT INTO book VALUES(5,'当你的才华还撑不起你的梦想时',23.00)&quot;)cur.execute(&quot;INSERT INTO book VALUES(6,'巨人的陨落(套装共3册)',84.90)&quot;)cur.execute(&quot;INSERT INTO book VALUES(7,'孤独深处(收录雨果奖获奖作品《北京折叠》)',21.90)&quot;)cur.execute(&quot;INSERT INTO book VALUES(8,'世界知名企业员工指定培训教材:所谓情商高,就是会说话',22.00)&quot;)</code></pre><p id="72f155b7e9e126c5f6de6a1322fb71e6" class="ne-p"><br></p><pre><code>&lt;sqlite3.Cursor at 0x2d2d64e7c00&gt;</code></pre><p id="3a7e4394465571d270a424d80997ad59" class="ne-p"><br></p><h3 id="c7bf12ad"><span class="ne-text">批量插入数据</span></h3><p id="21584e43999c4894c95585c3400bc9c6" class="ne-p"><br></p><pre><code>books = (    (9, '人间草木', 30.00),    (10,'你的善良必须有点锋芒', 20.50),    (11, '这么慢,那么美', 24.80),    (12, '考拉小巫的英语学习日记:写给为梦想而奋斗的人(全新修订版)', 23.90))cur.executemany(&quot;INSERT INTO book VALUES(?, ?, ?)&quot;, books)</code></pre><p id="cae013fc137fc8e5d932916b8f9426ff" class="ne-p"><br></p><pre><code>&lt;sqlite3.Cursor at 0x2d2d64e7c00&gt;</code></pre><p id="b002caadd88cb08679ebba31474cf6d8" class="ne-p"><br></p><pre><code>conn.commit()</code></pre><p id="29689200a72fa76db97529a512910fa7" class="ne-p"><br></p><h3 id="0a7fa4b6"><span class="ne-text">查找数据</span></h3><p id="93b6ff223e905572d848e99218baea59" class="ne-p"><br></p><pre><code>cur.execute('SELECT * FROM book')rows = cur.fetchall()<h1 id="通过索引号访问"><a href="#通过索引号访问" class="headerlink" title="通过索引号访问"></a>通过索引号访问</h1><p>for row in rows:<br>    print (‘序号: %i, 书名: %s, 价格: %.2f’ %(row[0], row[1], row[2]))<br></code></pre></p><p id="fb67befb2847144a0846520ff6798e2a" class="ne-p"><br></p><pre><code>序号: 1, 书名: 肖秀荣考研书系列:肖秀荣(2017)考研政治命题人终极预测4套卷, 价格: 14.40序号: 2, 书名: 法医秦明作品集:幸存者+清道夫+尸语者+无声的证词+第十一根手指(套装共5册) (两种封面随机发货), 价格: 100.00序号: 3, 书名: 活着本来单纯:丰子恺散文漫画精品集(收藏本), 价格: 30.90序号: 4, 书名: 自在独行:贾平凹的独行世界, 价格: 26.80序号: 5, 书名: 当你的才华还撑不起你的梦想时, 价格: 23.00序号: 6, 书名: 巨人的陨落(套装共3册), 价格: 84.90序号: 7, 书名: 孤独深处(收录雨果奖获奖作品《北京折叠》), 价格: 21.90序号: 8, 书名: 世界知名企业员工指定培训教材:所谓情商高,就是会说话, 价格: 22.00序号: 9, 书名: 人间草木, 价格: 30.00序号: 10, 书名: 你的善良必须有点锋芒, 价格: 20.50序号: 11, 书名: 这么慢,那么美, 价格: 24.80序号: 12, 书名: 考拉小巫的英语学习日记:写给为梦想而奋斗的人(全新修订版), 价格: 23.90</code></pre><p id="86607338499ad4af24c5712c9311b068" class="ne-p"><br></p><pre><code>conn.row_factory = sqlite3.Rowcur = conn.cursor() cur.execute('SELECT * FROM book')rows = cur.fetchall()<h1 id="通过列名访问"><a href="#通过列名访问" class="headerlink" title="通过列名访问"></a>通过列名访问</h1><p>for row in rows:<br>    print (‘序号: %i, 书名: %s, 价格: %.2f’ %(row[‘id’], row[‘name’], row[‘price’]))<br></code></pre></p><p id="661f1f35d17a9883ed1ac16478fb23f4" class="ne-p"><br></p><pre><code>序号: 1, 书名: 肖秀荣考研书系列:肖秀荣(2017)考研政治命题人终极预测4套卷, 价格: 14.40序号: 2, 书名: 法医秦明作品集:幸存者+清道夫+尸语者+无声的证词+第十一根手指(套装共5册) (两种封面随机发货), 价格: 100.00序号: 3, 书名: 活着本来单纯:丰子恺散文漫画精品集(收藏本), 价格: 30.90序号: 4, 书名: 自在独行:贾平凹的独行世界, 价格: 26.80序号: 5, 书名: 当你的才华还撑不起你的梦想时, 价格: 23.00序号: 6, 书名: 巨人的陨落(套装共3册), 价格: 84.90序号: 7, 书名: 孤独深处(收录雨果奖获奖作品《北京折叠》), 价格: 21.90序号: 8, 书名: 世界知名企业员工指定培训教材:所谓情商高,就是会说话, 价格: 22.00序号: 9, 书名: 人间草木, 价格: 30.00序号: 10, 书名: 你的善良必须有点锋芒, 价格: 20.50序号: 11, 书名: 这么慢,那么美, 价格: 24.80序号: 12, 书名: 考拉小巫的英语学习日记:写给为梦想而奋斗的人(全新修订版), 价格: 23.90</code></pre><p id="77e213762f65e51405edb0591de67abe" class="ne-p"><br></p><pre><code>conn.close()</code></pre><p id="acf11068e3023a2453b028cb0b86380a" class="ne-p"><br></p><h2 id="64a963be"><span class="ne-text">五、SQLite_json操作</span></h2><p id="a6df6bd6d976702e0184110c53638a98" class="ne-p"><br></p><pre><code>import sqlite3<p>db_path = ‘./files/test_join.sqlite’</p><p>conn = sqlite3.connect(db_path)<br>cur = conn.cursor()<br></code></pre></p><p id="fbaf5cc8414e55c9d27b8e8061cd9ad7" class="ne-p"><br></p><pre><code># 建 depaetment 表，并插入数据cur.execute(&quot;DROP TABLE IF EXISTS department&quot;)cur.execute(&quot;CREATE TABLE department(\                id INT PRIMARY KEY NOT NULL, \                dept CHAR(50) NOT NULL, \                emp_id INT NOT NULL)&quot;)depts = (        (1, 'IT Builing', 1),        (2, 'Engineerin', 2),        (3, 'Finance', 7))cur.executemany(&quot;INSERT INTO department VALUES(?, ?, ?)&quot;, depts)</code></pre><p id="cf7e6e276db7e56014292ee1011dd2b7" class="ne-p"><br></p><pre><code>&lt;sqlite3.Cursor at 0x2d2d64f70a0&gt;</code></pre><p id="6ecb5c7f01bf2bf88bbfdf94ba2c2b7f" class="ne-p"><br></p><pre><code>conn.commit()</code></pre><p id="e1a4c39e0f1d9f270ab255517b48b711" class="ne-p"><br></p><h3 id="6da83b0f"><span class="ne-text">CROSS JOIN 交叉连接</span></h3><p id="1201739ff173575db939edbdadad9e41" class="ne-p"><br></p><pre><code>cur.execute(&quot;SELECT emp_id, name, dept FROM company CROSS JOIN department;&quot;)rows = cur.fetchall()for row in rows:    print (row)</code></pre><p id="b370338fa779f887e3ad297a1f7c7f99" class="ne-p"><br></p><pre><code># 建 company 表，并插入数据cur.execute(&quot;DROP TABLE IF EXISTS company&quot;)cur.execute(&quot;CREATE TABLE company(\                    id INT PRIMARY KEY NOT NULL, \                    name CHAR(50) NOT NULL, \                    age INT NOT NULL, \                    address CHAR(50) NOT NULL,\                    salary DOUBLE NOT NULL)&quot;)companies = (        (1, 'Paul', 32, 'California', 20000.0),        (2, 'Allen', 25, 'Texas', 15000.0),        (3, 'Teddy', 23, 'Norway', 20000.0),        (4, 'Mark', 25, 'Rich-Mond', 65000.0),        (5, 'David', 27, 'Texas', 85000.0),        (6, 'Kim', 22, 'South-Hall', 45000.0),        (7, 'James', 24, 'Houston', 10000.0))cur.executemany(&quot;INSERT INTO company VALUES (?, ?, ?, ?, ?)&quot;, companies)</code></pre><p id="d10582cdd4b393b27bdc85249652b979" class="ne-p"><br></p><pre><code>&lt;sqlite3.Cursor at 0x2d2d64f70a0&gt;</code></pre><p id="08388108de85d7f2aad79ca56896edaf" class="ne-p"><br></p><h3 id="041fd6a0"><span class="ne-text">INNER JOIN 内连接</span></h3><p id="55c4df77f06ee19d2d03ec193ddecdae" class="ne-p"><br></p><pre><code>cur.execute(&quot;SELECT emp_id, name, dept FROM company INNER JOIN department \            ON company.id = department.emp_id;&quot;)rows = cur.fetchall()for row in rows:    print (row)</code></pre><p id="159c28575d995e87710d4c0987bd8ebf" class="ne-p"><br></p><pre><code>(1, 'Paul', 'IT Builing')(2, 'Allen', 'Engineerin')(7, 'James', 'Finance')</code></pre><p id="07b1dcc13e66053f6f9bd421abc034d5" class="ne-p"><br></p><h3 id="56d30f7a"><span class="ne-text">OUTER JOIN 外连接</span></h3><p id="6dcf2de73bab0a6ddc8d1395cb4ff6f4" class="ne-p"><br></p><pre><code># 左连接cur.execute(&quot;SELECT emp_id, name, dept FROM company LEFT OUTER JOIN department \            ON company.id = department.emp_id;&quot;)rows = cur.fetchall()for row in rows:    print (row)</code></pre><p id="344a0d86c63e00e9b8b821225910f37f" class="ne-p"><br></p><pre><code>(1, 'Paul', 'IT Builing')(2, 'Allen', 'Engineerin')(None, 'Teddy', None)(None, 'Mark', None)(None, 'David', None)(None, 'Kim', None)(7, 'James', 'Finance')</code></pre><p id="bd281f97894372cf2f75e298e8352cec" class="ne-p"><br></p><pre><code># 右连接 （目前不支持）cur.execute(&quot;SELECT emp_id, name, dept FROM company RIGHT OUTER JOIN department \            ON company.id = department.emp_id;&quot;)rows = cur.fetchall()for row in rows:    print (row)</code></pre><p id="1159245337aa7d8b5c8bb7282c6f3e33" class="ne-p"><br></p><pre><code>---------------------------------------------------------------------------<p>OperationalError                          Traceback (most recent call last)</p><p>&lt;ipython-input-41-ce0fc573748b&gt; in &lt;module&gt;<br>      1 # 右连接 （目前不支持）<br>      2 cur.execute(&quot;SELECT emp_id, name, dept FROM company RIGHT OUTER JOIN department <br>—-&gt; 3             ON company.id = department.emp_id;&quot;)<br>      4 rows = cur.fetchall()<br>      5 for row in rows:</p><p>OperationalError: RIGHT and FULL OUTER JOINs are not currently supported<br></code></pre></p><p id="3fce303448a175e15da0e7b0659114fc" class="ne-p"><br></p><pre><code># 右连接，交换两张表cur.execute(&quot;SELECT emp_id, name, dept FROM department LEFT OUTER JOIN company \            ON company.id = department.emp_id;&quot;)rows = cur.fetchall()for row in rows:    print (row)</code></pre><p id="55d317470f2ba1437cddb7a4ac6d2c7b" class="ne-p"><br></p><pre><code>(1, 'Paul', 'IT Builing')(2, 'Allen', 'Engineerin')(7, 'James', 'Finance')</code></pre><p id="f4413322e07b15405faa6c5665502c28" class="ne-p"><br></p><pre><code>sqlite&gt; SELECT EMP_ID, NAME, DEPT FROM COMPANY LEFT OUTER JOIN DEPARTMENT      ON COMPANY.ID = DEPARTMENT.EMP_ID;</code></pre><p id="255e497ca09a1374e370ccd6db61e5e7" class="ne-p"><br></p><pre><code>  File &quot;&lt;ipython-input-43-a0833b733075&gt;&quot;, line 1    sqlite&gt; SELECT EMP_ID, NAME, DEPT FROM COMPANY LEFT OUTER JOIN DEPARTMENT                        ^SyntaxError: invalid syntax</code></pre><p id="4de1a5b99162c916349425351210857c" class="ne-p"><br></p><h2 id="e0f028b0"><span class="ne-text">六、Excel文件操作</span></h2><p id="d446132460121d9b70c2511f4eada161" class="ne-p"><br></p><p id="64c8dfa7fa2314d25ded610d9964640c" class="ne-p"><span class="ne-text">pandas.read_excel(io, sheet_name=0, header=0, names=None, index_col=None, usecols=None, squeeze=False, dtype=None, engine=None, converters=None, true_values=None, false_values=None, skiprows=None, nrows=None, na_values=None, keep_default_na=True, verbose=False, parse_dates=False, date_parser=None, thousands=None, comment=None, skipfooter=0, convert_float=True, mangle_dupe_cols=True, **kwds)</span></p><p id="fa4f2975bd2ebe26f50a686e881357ad" class="ne-p"><br></p><p id="c11ff7f18ef55582a5c6a341a41cd2d7" class="ne-p"><span class="ne-text">df_fujian = pd.read_excel(&quot;./datafiles/fujian.xlsx&quot;,sheet_name='日数据')</span></p><p id="u48cdb6d9" class="ne-p"><span class="ne-text"></span></p><p id="ue4376dab" class="ne-p"><span class="ne-text"></span></p><h2 id="BPavn"><span class="ne-text">Jupyter Notebook的安装</span></h2><p id="u5ad7d5d0" class="ne-p"><span class="ne-text"></span></p><p id="ue271b7ca" class="ne-p"><span class="ne-text">一般有两种方法，第一种是下载Anaconda，自带python环境以及Jupyter Notebook环境，但这一般都是刚学机器学习那会的集成安装方式，</span><span class="ne-text" style="text-decoration: line-through">最主要的劝退原因是所占体积较大，所以这里介绍原生的安装方式，在纯Python环境下，使用自带的pip包管理工具下载，类似地像Pandas、Numpy等包也可以以此种方式安装</span><span class="ne-text">。</span></p><p id="u4d808c14" class="ne-p"><span class="ne-text"></span></p><p id="u97bce6d7" class="ne-p"><span class="ne-text">打脸YYDS，收回上面画斜线的文字，因为自己以前的笔记里面，有许多其他库，一个一个安装太繁杂了，所以还是下载Anaconda集成环境吧。</span></p><p id="ud6a0f5ad" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1640601860364-c314af96-93ca-44c7-a1f3-f56281bc0358.jpeg" width="52" id="JxlHZ" class="ne-image"></p><p id="ue9991ea5" class="ne-p"><span class="ne-text">具体下载配置参考之前的文章：</span><a href="https://www.wztlink1013.com/blog/mv7tir/" data-href="https://www.wztlink1013.com/blog/mv7tir/" target="_blank" class="ne-link"><span class="ne-text">Pycharm,Anaconda,JetBrains系列app相关总结 | 尼采般地抒情</span></a></p><p id="u64769e0e" class="ne-p"><span class="ne-text"></span></p><h3 id="f96oI"><span class="ne-text">安装python</span></h3><p id="u10ed1ff2" class="ne-p"><span class="ne-text">地址：</span><a href="https://www.python.org/downloads/windows/" data-href="https://www.python.org/downloads/windows/" target="_blank" class="ne-link"><span class="ne-text">https://www.python.org/downloads/windows/</span></a></p><p id="udb709210" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1640599312775-072daad3-4d63-44a3-9d12-f01c4bbf8e94.png" width="364" id="u9139fb50" class="ne-image"></p><p id="ucb9754ce" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1640599331716-24f74d29-d0d3-48d3-8ac8-98677a0a7f02.png" width="659.5" id="u67f784d6" class="ne-image"></p><p id="u0e08ea89" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1640599684114-22e00be7-1d4d-4429-89a3-749721cc6dc9.png" width="498.5" id="u77942fec" class="ne-image"></p><p id="u8017f8c2" class="ne-p"><span class="ne-text">安装完之后进入cmd查看</span></p><p id="u2fc63e69" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1640599838509-509dc0d6-0ead-4d97-8c9a-c99b9ee2451d.png" width="720" id="ubc4fd658" class="ne-image"></p><h3 id="lfC1n"><span class="ne-text">安装jupyter</span></h3><pre><code>pip install jupyter</code></pre><p id="ua6360957" class="ne-p"><span class="ne-text">安装成功之后，在项目文件夹下，打开powershell终端输入：jupyter notebook</span></p><p id="u718d4b67" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1640601099229-bf7d396d-3c7c-4971-9552-459fccf9b37a.png" width="720" id="u525810b2" class="ne-image"></p><h2 id="i67WN"><span class="ne-text">报错</span></h2><h3 id="JXf6m"><span class="ne-text">ValueError: check_hostname requires server_hostname</span></h3><p id="u3d78a6d7" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1640600263157-e7be09d6-1de3-4a8e-8387-5711d8c0814b.png" width="947" id="ue7f0bb3a" class="ne-image"></p><p id="u8cdf7c88" class="ne-p"><span class="ne-text">关掉tizi</span></p><h3 id="CESew"><span class="ne-text">ReadTimeoutError: HTTPSConnectionPool(host='files.pythonhosted.org', port=443): Read timed out.</span></h3><p id="uaa2d37ff" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1640600450333-c5b616f4-6f9c-41d5-ac8b-ad6a3a0cd5ad.png" width="782.5" id="u99c9113d" class="ne-image"></p><p id="u1b9a7409" class="ne-p"><span class="ne-text">按照报错信息，更新pip</span></p><p id="u2c890fd9" class="ne-p"><span class="ne-text"></span></p><h2 id="Mv5up"><span class="ne-text">数据分析</span></h2><p id="ucaad7850" class="ne-p"><span class="ne-text">本地数据的读取</span></p></div>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
          <category> 数据分析 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>编程习惯</title>
      <link href="/blog/ml46ei/"/>
      <url>/blog/ml46ei/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h2 id="cRcAi"><span class="ne-text">一、代码</span></h2><h3 id="a3d10465"><span class="ne-text">命名规范</span></h3><p id="u3ea2d7ee" class="ne-p"><br></p><p id="u2d8c5609" class="ne-p"><br></p><ul class="ne-ul"><li id="fa8cc678541c1b68b79893e8eb257f3e"><span class="ne-text">项目：小写字母    </span><code class="ne-code"><span class="ne-text">datastructure</span></code></li><li id="990994f9df02a6a64e43decb24f663f4"><span class="ne-text">包：</span><code class="ne-code"><span class="ne-text">com.公司名.项目名.模块名....</span></code><span class="ne-text">（其中模块名可以按照功能/逻辑来分）</span></li><li id="5d238a78c50acd49a5715377e0e122f6"><span class="ne-text">类：全部首字母大写，一般驼峰式命名 </span><code class="ne-code"><span class="ne-text">public class TestBan&#123;&#125;</span></code></li><li id="c88eb1339b67bc45c63c9f7ca90df614"><span class="ne-text">常量：全部大写字母 </span><code class="ne-code"><span class="ne-text">String RE_PRI = ‘wztlink’</span></code></li><li id="5b3d7da274102fd501d449a341d2d0c6"><span class="ne-text">变量：下划线方式  </span><code class="ne-code"><span class="ne-text">int pri_const</span></code></li><li id="5db8d22fbea6ce8e0e35aa3fa0877f70"><span class="ne-text">方法：首字母小写，如果有多个单词，单词首字母大写 </span><code class="ne-code"><span class="ne-text">public void toString()&#123;&#125;</span></code></li></ul><h3 id="f37651eb"><span class="ne-text">注释规范</span></h3><div data-type="info" class="ne-alert"><p id="u3be7ed8e" class="ne-p"><span class="ne-text">文件注释</span></p></div><p id="eaa3d0eeab2ef36eb453110b5e709dcc" class="ne-p"><br></p><pre><code>  / *    * 文件名：[文件名]    * 作者：〈版权〉    * 描述：〈描述〉    * 修改人：Wu ZuTao    * 修改时间：2020-06-06    * 修改内容：新增X方法    * 修改人：Wu ZuTao    * 修改时间：2020-07-01    * 修改内容：修改B模块    * /</code></pre><p id="uf4c216fb" class="ne-p"><br></p><div data-type="info" class="ne-alert"><p id="cedfb0413a7c30691786a2cea4475732" class="ne-p"><span class="ne-text">类和接口的注释：该注释放在class定义之前，using或package关键字之后。</span></p></div><p id="d93dd9b8ab3fbd352b2f943b687da803" class="ne-p"><br></p><pre><code>package com.wztlink.xxx;/**  * 注释内容  */  public class XxxManager</code></pre><p id="be1cafa2a3743e5a147fa5ac2e132638" class="ne-p"><br></p><pre><code>/ *  * 〈一句话功能简述〉   * 〈功能详细描述〉  * @author [作者]  * @version [版本号, YYYY-MM-DD]  * @see [相关类/方法]  * @since [产品/模块版本]  * @deprecated  */</code></pre><p id="b24e8ba5eb73c3ae4150735f32490e52" class="ne-p"><br></p><div data-type="info" class="ne-alert"><p id="u98762170" class="ne-p"><span class="ne-text">函数注释</span></p></div><p id="ebfa6c1305f820b434a51bfbc59b9651" class="ne-p"><br></p><pre><code> /**    * 类方法的详细使用说明    *    * @param 参数1 参数1的使用说明    * @return 返回结果的说明    * @throws 异常类型.错误代码 注明从此类方法中抛出异常的说明    */</code></pre><p id="f55eca77ab1c939509965c3362f36548" class="ne-p"><br></p><div data-type="info" class="ne-alert"><p id="u74773b75" class="ne-p"><span class="ne-text">方法内部、属性、必要语句</span></p></div><p id="b670d64f5b5600eccf71ddd6bf767261" class="ne-p"><br></p><pre><code>// 注释内容private String logType</code></pre><p id="00b5605c329d40945d3b1548aec0bf3a" class="ne-p"><br></p><div data-type="danger" class="ne-alert"><p id="u27dc6cac" class="ne-p"><span class="ne-text">注意事项</span></p></div><p id="b227d59673af19282388c323dcb4de3e" class="ne-p"><br></p><ul class="ne-ul"><li id="8777d6cbf19fcf281111c570ac743599"><span class="ne-text" style="text-decoration: underline">边写代码边注释，修改代码同时修改相应的注释</span><span class="ne-text">，以保证注释与代码的一致性。不再有用的注释要删除。</span></li><li id="df25634f9e421b0101e3c1c071a1c065"><span class="ne-text">避免在注释中使用缩写，特别是不常用缩写。说明：在使用缩写时或之前，应对缩写进行必要的说明。 注释应该放在被注释的代码前面，分行展示，但中间不留空行。</span></li><li id="8a2836894421a5b334f4a72d77791d95"><a href="https://blog.csdn.net/vbirdbest/article/details/80296136" data-href="https://blog.csdn.net/vbirdbest/article/details/80296136" target="_blank" class="ne-link"><span class="ne-text">javadoc使用规范</span></a></li></ul><h3 id="paZMo"><span class="ne-text">函数</span></h3><p id="3411d0d350dc604884013815e38afd0d" class="ne-p"><span class="ne-text">主入口函数和其他功能函数分开，如果是功能性函数，全部放到一个 </span><code class="ne-code"><span class="ne-text">Tools</span></code><span class="ne-text"> </span><span class="ne-text">函数里面</span></p><h3 id="d0oWP"><span class="ne-text">类</span></h3><p id="dc2ae38a4f68d1af60cdd7719b30e234" class="ne-p"><span class="ne-text">不要在自己类下定义自己的对象</span></p><h2 id="e066f6cd"><span class="ne-text">二、项目</span></h2><h3 id="mYCBV"><span class="ne-text" style="color: #000000">解决写不出代码的方法</span></h3><div class="ne-quote"><p id="ud814f11e" class="ne-p"><span class="ne-text">参考：</span><a href="https://www.cnblogs.com/luchuangao/p/6821210.html" data-href="https://www.cnblogs.com/luchuangao/p/6821210.html" target="_blank" class="ne-link"><span class="ne-text">https://www.cnblogs.com/luchuangao/p/6821210.html</span></a></p></div><p id="ub4b1da34" class="ne-p"><br></p><div class="ne-quote"><p id="039b8286126aaef433a126c8c308aa43" class="ne-p"><span class="ne-text" style="color: #0000FF">1、先分析实现的思路</span></p></div><p id="d9acb171f6a66414f5ff5c6750c7bc3e" class="ne-p"><span class="ne-text">拿到作业，按照要实现的功能，先分析去实现的思路。</span></p><p id="14919e736d2de8727f653dfefdb0833e" class="ne-p"><span class="ne-text">如果完全不知道该怎么去实现，一头雾水，最好先看看其他人事如何实现的，或者与老师或同学讨论。</span></p><p id="1737d97e845755d3196a8e60f158acf8" class="ne-p"><span class="ne-text">重点是要找到解决问题的办法，理清实现的思路。</span></p><p id="ae3ba1d67f148b26fa9611ae4f04a4ab" class="ne-p"><span class="ne-text">如果自己能想出几步来，那就先把这几步记录下来，然后重复上面的步骤。</span></p><div class="ne-quote"><p id="2e85eb844117437486f9f7d020152340" class="ne-p"><span class="ne-text" style="color: #0000FF">2、把实现的思路边分析边记录下来。</span></p></div><p id="b5ba506f0ed014a0dc5ca77ef6c44acf" class="ne-p"><span class="ne-text">在分析实现思路的时候，边分析，边写出来，使用中文写，写得详细点。</span></p><p id="3e68e22ad17e7a82753c3bf09748afbe" class="ne-p"><span class="ne-text">如果在编程工具里面写的话，直接写成注释，比如：</span></p><p id="cb8e19258bf48fc6d157bd7a3d41cab0" class="ne-p"><span class="ne-text">第一步是要干上面</span></p><p id="73726efd0a16a2d72e618c4519128ac2" class="ne-p"><span class="ne-text">第1.1要做什么</span></p><p id="f6ebcbfe90ef4cae981788fd004c7bf4" class="ne-p"><span class="ne-text">第1.2要做什么</span></p><p id="c25700e4692d8e38b80250c9e8df46b3" class="ne-p"><span class="ne-text">第二步是要干上面</span></p><p id="722e0082cd53d9fc0ec1504a059d6d87" class="ne-p"><span class="ne-text">第2.1要做什么</span></p><p id="4f7b095c857315709d00f58a6e4974b3" class="ne-p"><span class="ne-text">第2.2要做什么</span></p><p id="8385e3def47a35d9377da9ca74a708fe" class="ne-p"><span class="ne-text">...以此类推</span></p><p id="2ac109e78daf5b02eedd49c9ada7435a" class="ne-p"><span class="ne-text">遇到写不下去的地方，先看看是没有思路还是前面的思路没有想清楚</span></p><p id="f6b096db0c73ddeb7a7e45ef6794bfe0" class="ne-p"><span class="ne-text">如果是没有思路了，参见第一条处理。</span></p><p id="804b5277914b7549f05d1e9663161c9f" class="ne-p"><span class="ne-text">如果是前面的思路没有想清楚，那就返回来重新思考，一定要考虑明白。</span></p><p id="00cf76c60c17d1982df8ad4792715cff" class="ne-p"><span class="ne-text">这其实也是这个方法一个额外的好处，那就是能强迫你思考，并进行细致考虑。</span></p><div class="ne-quote"><p id="266f0ef294444190e2f60e3e8b4117e0" class="ne-p"><span class="ne-text" style="color: #0000FF">3、写实现代码</span></p></div><p id="561df27fed88fcd4d6ef33b28a6ac814" class="ne-p"><span class="ne-text">如果思路整理清楚了，实现思路的步骤也整理好了，这个时候再写代码，</span></p><p id="e9e7691aec2f4a0c3b35e8df59386cd3" class="ne-p"><span class="ne-text">几乎就是个翻译的过程，很容易实现。</span></p><p id="624c26a8687e91b99ef56005aa2dac00" class="ne-p"><span class="ne-text">如果只是几步思路清楚了，也没有关系，想清楚多少，就写多少代码，慢慢来。</span></p><div class="ne-quote"><p id="a2063cb0df7a9ba4d8d87663358dd216" class="ne-p"><span class="ne-text" style="color: #0000FF">4、有思路但是写不出代码的解决方法</span></p></div><p id="2fe670b17dd2b1efaa7bf0877d45402a" class="ne-p"><span class="ne-text">这种情况常出现在初学者身上，主要是代码写少了。（</span><span class="ne-text" style="color: #FF0000">这种情况需每日练习两百到三百行代码</span><span class="ne-text">）</span></p><p id="60d625798d2779c8811e6bdffe0b61b7" class="ne-p"><span class="ne-text">建议多看看别人怎么写的，积累代码的写法，这一次不会写不要紧。</span></p><p id="ebd969334a697151fd12287f198e690b" class="ne-p"><span class="ne-text">见过一回，下次会写九可以了，积少成多，写得多了，自己能实现的也就多了。</span></p><div class="ne-quote"><p id="8c4cab6cda7439751fda3419d742fc74" class="ne-p"><span class="ne-text" style="color: #0000FF">5、方法不一定照搬，可以变通使用</span></p></div><p id="63bb310237a72a774f6ed95f6120f92a" class="ne-p"><span class="ne-text">比如边分析、边写思路然后就编写代码也是可以的，只要能有助你思考，都可以。</span></p><div class="ne-quote"><p id="1b3d70d33840bed04489207c6d30913a" class="ne-p"><span class="ne-text" style="color: #0000FF">6、写不出代码</span></p></div><p id="a23fd97540c95215338e861627577b37" class="ne-p"><span class="ne-text">大多数人在写不出代码的时候，都不是完全写不出来，也不是一点都写不出来，请尽量把会的、能写出来的先写出来，多按照本文介绍的方法去练习，量变到质变，很快就能自己写出实现代码来。</span></p><p id="uc19156f2" class="ne-p"><br></p><h3 id="8Gbog"><span class="ne-text">提高代码阅读能力</span></h3><p id="6d73ca8d411a5fcd7bb87775b6cb7191" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1602593438617-6e64c23d-0230-4104-b1b5-6ccd512ad999.png" width="508.5" id="R0FDZ" class="ne-image"></p><p id="e1a3dd811264c066d8b04de630ef8967" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1602593456351-275ca8e5-583b-499b-aca4-e4295b312c55.png" width="504" id="T4RUm" class="ne-image"></p><p id="bec0e7d4d7a3420eb2e8361bd192d706" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1602593476552-c6a6f01f-1d45-40e7-93b5-be56bc08e0c7.png" width="505" id="GkcIC" class="ne-image"></p><p id="96a0cf20c790b982de4bc284f5f9ba63" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1602593492992-c4a224fc-10e7-478e-9424-c90da2b4805a.png" width="498" id="IOPvY" class="ne-image"></p><p id="163abbe7afbcec86d2dd62f3c3024982" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1602593510079-399972ba-bee4-4dbc-81c9-ae619486f7da.png" width="498" id="NibYg" class="ne-image"></p><p id="57229a2c5a5d64e3c7c415ac9ea2cfc3" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1602593528314-e583f78d-6f87-46d1-826d-841629871530.png" width="506.5" id="rKWh8" class="ne-image"></p><p id="eb2d25ec84ca119bc8a07317e41b52f1" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1602593547023-cbcc3eac-6350-4b92-856d-0cfd2a1ccf75.png" width="505.5" id="z7WrI" class="ne-image"></p><p id="44805dcc75484962ee5dac9752fc6db5" class="ne-p"><br></p><p id="9bf6738be659fb42d0c84b5f29f20889" class="ne-p"><br></p><p id="0148e6c74dd0f3bf64ad9a021219405b" class="ne-p"><br></p><p id="ab427e443d198d19d38dc400ed3bf103" class="ne-p"><br></p><p id="655894acfc8c083fe0b51e9bf8c20c36" class="ne-p"><br></p><p id="a975dd86ea240d66062e922f1b36a8a2" class="ne-p"><br></p><p id="0afe58cb877893cbeb19b19e7d8df9ec" class="ne-p"><br></p><p id="f83b7ac5ffc06f0e7ed980785a29ebeb" class="ne-p"><br></p><p id="6c63fcfd856169d0ff1652abd3d80504" class="ne-p"><br></p><p id="01f92f4dc440a41237e3b9e04b7d3e9e" class="ne-p"><br></p><p id="6b96f10752cee1322c85e39931c994b6" class="ne-p"><br></p><p id="af7801aae04291001008d90578276034" class="ne-p"><br></p></div>]]></content>
      
      
      <categories>
          
          <category> 计算机素养 </category>
          
          <category> 软件工程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>调试解决总结</title>
      <link href="/blog/mtigbx/"/>
      <url>/blog/mtigbx/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h2 id="YGnJL"><span class="ne-text">一、关于bug</span></h2><p id="66012c2a502d808da244fa38db6df37e" class="ne-p"><br></p><p id="fa505e242c51dbbd7113b962fa3cd800" class="ne-p"><span class="ne-text">在编写程序过程中，总会出现各种各样的bug，按bug得类型来分的话</span></p><p id="266294a03ba9f15d4897ee3167f31ec7" class="ne-p"><br></p><ul class="ne-ul"><li id="9aef971c2ad20eb4a569c5d6d4269b46"><span class="ne-text">程序的逻辑出错</span></li><li id="1c1003e8459e3e99cc5c736d2466438d"><span class="ne-text">程序语法出错编译器不能通过</span></li></ul><p id="332cd143c0eae528f9d7e48c3aa132ab" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1656489641864-8b7034fc-63aa-437e-ad29-db2d35dcc3d1.png" width="533" id="u5afa8d31" class="ne-image"></p><p id="c4e09377af13ae0c178dd46ae487b7e7" class="ne-p"><span class="ne-text">对待bug，心态端正，不抵触不畏惧不怕麻烦，要想着解bug就是这个职业的要务之一，有耐心，积极主动的去解决问题。一步一步的解决问题，所有的技术都是熟能生巧、</span></p><p id="009777801ce9462eb82f040a37b8aa84" class="ne-p"><br></p><h2 id="a6d0ba1a"><span class="ne-text">二、解决bug的一些方法</span></h2><p id="7366d2c45257eee8b3b8bbc4b0acbb77" class="ne-p"><br></p><h3 id="ecf497ea"><span class="ne-text">报错信息+理论知识</span></h3><p id="f562d8f51d6075cf014dec24400e0881" class="ne-p"><br></p><p id="86a4e7e83965f1fd620c639ad954e29f" class="ne-p"><span class="ne-text">当一个bug摆在面前，首先要做的就是要认真阅读展现出来的出错信息，这里面有几点需要注意</span></p><p id="ad16d0a5ed7d9cfbd52a98c5d0b6e555" class="ne-p"><br></p><div class="ne-quote"><p id="4a6d27cbd70ef87f805fd7ffa4c46ef4" class="ne-p"><strong><span class="ne-text">提高英语</span></strong></p></div><p id="e7a0f770d6e48199a40e2094714fd359" class="ne-p"><br></p><p id="13c68afd375310ce86763282284ecd86" class="ne-p"><span class="ne-text">专业词汇的积累、阅读能力等</span></p><p id="34ffd890072182c6be946e8b451c392c" class="ne-p"><br></p><div class="ne-quote"><p id="67177d46e876d536b33cf7409ab50796" class="ne-p"><strong><span class="ne-text">运用底层知识</span></strong></p></div><p id="cdeb4af40a04b3dcfe35f1b2cd713d86" class="ne-p"><br></p><p id="9416d9d9983f9f6e4014e7f576397484" class="ne-p"><span class="ne-text">学会运行所学过的理论知识，比如在编程过程中，出现路径相关的错误，首先是根据报错可以直接在代码里面更改为正确可运行代码，然后可以利用所学过的操作系统相关文件管理知识等来进一步底层分析之，最后可以旁通自己之前搭建环境过程种总是要配的环境变量，一起思考一起分析，发散性思考，触类旁通所学知识，运用之</span></p><p id="b904e53d2c79a3b602cf9064c37bb55b" class="ne-p"><br></p><div class="ne-quote"><p id="a479ea612710ccc5bdc81bbfc0187551" class="ne-p"><strong><span class="ne-text">IDE的Debug或print通法</span></strong></p></div><p id="7d5ad34d676803133af4250e174facc1" class="ne-p"><br></p><p id="65c0cca9629fc6c64f266256ae32322d" class="ne-p"><span class="ne-text">熟悉各种开发环境的debug</span></p><p id="af280d3b5ce6497c8a248dcd8cc1077c" class="ne-p"><br></p><h3 id="a20a4b60"><span class="ne-text">搜索引擎</span></h3><p id="6afa697d2e4eaa8c15893ae4d1682603" class="ne-p"><br></p><div class="ne-quote"><p id="ba082da2289a4b72bd190a3743cc7512" class="ne-p"><strong><span class="ne-text">一个原则</span></strong><span class="ne-text">：“遇事不决，大事谷歌，小事百度”</span></p></div><p id="b49c72eb4fd1dbccb559fcef585497dc" class="ne-p"><br></p><ul class="ne-ul"><li id="79d6dd0734b32d986af88cc133da5a84"><span class="ne-text">谷歌需要一些手段才能进行，总结下来就是</span><strong><span class="ne-text">搭建一个机场</span></strong><span class="ne-text">，方便，安全</span></li><li id="d6669d3d3e2eaeabcdbc0dacc3449086"><span class="ne-text">百度解决一些小问题，抑或是 </span><strong><span class="ne-text">“烂大街的易错知识”</span></strong></li><li id="1e231efa10bddb8a2423aa6b4c6b81a6"><span class="ne-text">相关编程论坛，比如Stack Overflow、CSDN、博客园等（还是要用谷歌）</span></li></ul><p id="1510c456f165ca97209f13470b88b2f7" class="ne-p"><br></p><div class="ne-quote"><p id="02c4fca7045aab418a5b8c2b718e4a96" class="ne-p"><strong><span class="ne-text">结果择优原则</span></strong></p></div><p id="cbc56dc437f7698c57265413de3057e2" class="ne-p"><br></p><ul class="ne-ul"><li id="e14d6472fad102501aa6c90250dc75bb"><span class="ne-text">环境统一：解决办法的环境需要和自己的bug的环境需要一致</span></li><li id="e4a7e577981d84131542492f30be1619"><span class="ne-text">非毁灭性原则：尽量不要做全局性的修改，比如用命令删除git的两个文件来改一个小bug，属实挖坑</span></li></ul><p id="95914e3345a7eb87c42510d8ce45dafd" class="ne-p"><br></p><div class="ne-quote"><p id="4ba9289640c46f626de3ff39ea99fcea" class="ne-p"><strong><span class="ne-text">擅用官方文档</span></strong></p></div><p id="930b92cda3ce5e3f1848d09ce5f31f18" class="ne-p"><br></p><p id="b50d178afb3e66cbb5cd07c495355a40" class="ne-p"><span class="ne-text">如果说出现的bug抑或是，使用某个知识出错，是在官方文档中能查到的，优先选择官方文档</span></p><p id="b2d23b46b0365005e51ef5d88b394370" class="ne-p"><br></p><p id="0bd80d3a26e67ba403b59c13f1be1d96" class="ne-p"><span class="ne-text">就比如在使用python数据分析的时候，许多时候，很多包（pandas、numpy、matplotlib等）更新比较快，而网上找的一般都是旧版本的指导。同时</span></p><p id="5860cd5a82a4b5d706a5d33e1d8fcd2b" class="ne-p"><span class="ne-text">官方文档讲解更加全面，不过这过程中，要注意提高自身英语水平！</span></p><p id="1daa677d49b38d4e0d29bb999737cc7f" class="ne-p"><br></p><h3 id="6365e864"><span class="ne-text">复盘与重构</span></h3><p id="cf6f698490fb9316336fc0b1a8fd3dc3" class="ne-p"><br></p><div class="ne-quote"><p id="19868e23b5dc6d3464647aa95f97e033" class="ne-p"><strong><span class="ne-text">复盘</span></strong></p></div><p id="1753d0d84e708130f476336b1fc3881d" class="ne-p"><br></p><p id="d1ee00a6d47db55e918320e4fd0691ee" class="ne-p"><span class="ne-text">去复现一个学习（复现代码）过程，</span><strong><span class="ne-text">复盘</span></strong><span class="ne-text">bug之前的工作，来从中找出可能有哪些细节会导致出现该bug。</span></p><p id="e40953d6d34cb8f504a415ba0fabd448" class="ne-p"><br></p><div class="ne-quote"><p id="89e5b7817af0268d5f85c10478ac7713" class="ne-p"><strong><span class="ne-text">重构</span></strong></p></div><p id="ffd8496993a2404cc6782cd131146a01" class="ne-p"><br></p><p id="e2769b91984adad643f1152fcd2b54c6" class="ne-p"><span class="ne-text">按照思路重写代码！再不行重装系统！</span></p><p id="bceb9f1fd543e4be7be7eb1f0c9dfb3b" class="ne-p"><br></p><p id="b1253e144af63d731f62c5d6c086c549" class="ne-p"><span class="ne-text">重构，让你的代码更优美和简洁~</span></p><p id="e1e87312accd7bc185fa5169ac812f19" class="ne-p"><br></p><p id="305c83708f6f5e0cdb45ebdb81da298a" class="ne-p"><span class="ne-text">重装，让你的世界焕然一新~</span></p><p id="e2f873428831e076541f35642d316093" class="ne-p"><br></p><h2 id="3801f7d3"><span class="ne-text">三、多记录多总结多仔细</span></h2><p id="6d1a3dba1c256003d91a8df37c003cda" class="ne-p"><br></p><div class="ne-quote"><p id="4105fed0a371f0e3cdfdc129a62cfbfd" class="ne-p"><span class="ne-text">bug遇见的多了，也就由“形同陌路”转变为“日久生情”了!</span></p><p id="0030fcc5949d9154c97521a40448aa8a" class="ne-p"><span class="ne-text">良好的编程习惯加快解决速度</span></p></div><p id="f8a2c372038e57aafa01615ab8dbad00" class="ne-p"><br></p><p id="e021c052bebc531c7d2d377b78f2219f" class="ne-p"><span class="ne-text">做事情还是粗心，百分之九十的bug都来源于粗心，</span></p><p id="b324a1c2477d0cb81e5b7af58dc78a8b" class="ne-p"><br></p><h2 id="f7152be2"><span class="ne-text">四、持续补充</span></h2><p id="30115e5ac7c72c18fe104caaed532e49" class="ne-p"><br></p><ul class="ne-ul"><li id="4cddd454664947d5295828475ba35e37"><span class="ne-text">在利用搜索引擎找到解决办法时候，不要 </span><strong><span class="ne-text">吃着嘴里的，想着锅里的</span></strong><span class="ne-text"> ，找到一个办法，先将其解决办法看懂看透彻，不要这个方法还没看透彻就看下一个答案。</span></li><li id="a5688fd49be2d52fd5bfe7b77235e13f"><span class="ne-text">学会提取关键词来搜索，能提高很大效率</span></li></ul></div>]]></content>
      
      
      <categories>
          
          <category> 计算机素养 </category>
          
          <category> 软件工程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>爬虫架构和Scrapy框架使用</title>
      <link href="/blog/zsvfxg/"/>
      <url>/blog/zsvfxg/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h2 id="06LW1"><span class="ne-text">一、爬虫基本架构</span></h2><h3 id="Lnbo2"><span class="ne-text">url管理模块</span></h3><ul class="ne-ul"><li id="19b318d6f7fd8f8ef5a4ed73dfa68f6b"><span class="ne-text">就是管理自己爬取的的网页不要重复爬取，避免爬取进入死循环</span></li><li id="04120bef43a32c763758ea51f2479fc4"><span class="ne-text">使用python当中的set数据结构</span></li></ul><h3 id="U9qGR"><span class="ne-text">网页下载模块</span></h3><div class="ne-quote"><p id="bc7a779a7eb5fde0eb46e87dd07fc4d4" class="ne-p"><span class="ne-text">将对应的url模块下载到本地或者读入内存</span></p></div><p id="cac49967d535765660d56c08516394ab" class="ne-p"><br></p><div class="ne-quote"><p id="4a9c20a474a0314b7b4bb94f6824ffc8" class="ne-p"><span class="ne-text">实现方式</span></p></div><ul class="ne-ul"><li id="8b4046fbcbd284db8abbe8ec32a4c45d"><span class="ne-text">通过url下载</span></li></ul><pre><code>from urllib.request import urlopen test_url = &quot;https://wztlink1013.github.io&quot;response = urlopen(test_url)print (response.getcode()) # 200 表示访问成功print (response.read())</code></pre><ul class="ne-ul"><li id="95a3ec36da8492c0b7fea2718ecb7282"><span class="ne-text">通过Request访问</span></li><li id="b23b0ffd885f0c37b378ebbcbf78b787"><span class="ne-text">通过cookie访问</span></li></ul><p id="4e82d816665971fb64def6bc2af007c2" class="ne-p"><br></p><h3 id="iH9BG"><span class="ne-text">网页解析模块</span></h3><div class="ne-quote"><p id="72408694e243bad0945cc164ac6203ac" class="ne-p"><span class="ne-text">从已经下载的网页中爬取数据，实现方式有：</span></p></div><ol class="ne-ol"><li id="95c8e6c9119a4b33497ce91fde5ff74d"><span class="ne-text">正则表达式</span></li><li id="a9af89ac8976afb1f4c5801df855b4b4"><span class="ne-text">html.parser</span></li><li id="8f47ba6d9424236e51498ed25775c50d"><strong><span class="ne-text">BeautifulSoup：结构化解析网页</span></strong></li><li id="3149a17d706dbdbc44ea96f01c26b1e7"><span class="ne-text">lxml</span></li><li id="eaabbd078ae950f3de098414f5096137"><span class="ne-text">结构化解析</span></li><li id="b0916f7269d3364f802e0393c1bb2f17"><span class="ne-text">DOM（Document Object Model），树形结构，就是html的基本骨架</span></li></ol><p id="5a1eab7c490d7413d08453bfe3e09504" class="ne-p"><br></p><h2 id="ivaaO"><span class="ne-text">二、BeautifulSoup解析网页</span></h2><h2 id="zd9oc"><span class="ne-text">三、Scrapy</span></h2><p id="b5047b1b914ad4550b4bfc75a04fe7fd" class="ne-p"><br></p><h3 id="f7040a32"><span class="ne-text">Scrapy基础</span></h3><ul class="ne-ul"><li id="5b44ec9293778c8fae12fbedfcef93c7"><span class="ne-text">是一个爬虫框架，同时易扩展，可以添加新的模块达到自定义扩展</span></li><li id="2341b509da69658e22d737addf0873aa"><span class="ne-text">输出格式多样：json，csv，xml等</span></li><li id="67cb41a49a7c88245dcee57590193045"><span class="ne-text">自动处理编码</span></li></ul><h3 id="e33875a5"><span class="ne-text">Scrapy框架架构图</span></h3><p id="a23b92b4878be1105e06a8a244f3c9f3" class="ne-p"><br></p><p id="310421e7be95c076c8d9262d10a11d9a" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/webp/1484158/1598673193957-7a7456b0-3de1-4c77-b849-cc2572555ed5.webp" width="416" id="K9ZSV" class="ne-image"></p><p id="871904825a7d4aa34f0fb0d809f19c46" class="ne-p"><br></p><div class="ne-quote"><p id="d5c4a911fc742c534f47046fadf1fc52" class="ne-p"><span class="ne-text">下载方法以及问题，在anaconda博客中</span></p></div><p id="78ee0bfdbb409439d11827606ee4b5bf" class="ne-p"><br></p><h2 id="4886ac04"><span class="ne-text">四、Scrapy使用</span></h2><p id="8bd2517d845e52d7b068dbcbedd6c09c" class="ne-p"><br></p><h3 id="5dda7f34"><span class="ne-text">使用SOP</span></h3><p id="cac70e819ecdfb307685840ea1df6aef" class="ne-p"><br></p><ul class="ne-ul"><li id="a7e587483a4f973721d7d61e06235f09"><span class="ne-text">创建工程</span></li></ul><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="ce7ef66ed1893a8502764221d10cb650"><span class="ne-text">键入</span><code class="ne-code"><span class="ne-text">cmd</span></code><span class="ne-text"> </span><code class="ne-code"><span class="ne-text">cd</span></code><span class="ne-text">到需要下载的目录下</span></li><li id="89b9fb982da6633a2eec31a939d4fd39"><span class="ne-text">输入</span><code class="ne-code"><span class="ne-text">scrapy startproject tutorial</span></code><span class="ne-text">（最后是项目名字）</span></li><li id="d39840093ac58c2d8e16d82987c231d3"><strong><span class="ne-text">!此后所有有关命令的操作，均在下一级文件夹下，也有是有cfg文件后缀的文件夹下</span></strong></li></ul></ul><ul class="ne-ul"><li id="220af3c14c2e7fa391e1e48ec760dd62"><span class="ne-text">定义Item，构造爬取的对象</span></li><li id="07179dbb9fe248016bda6814d5428f93"><span class="ne-text">编写spider，爬虫主体</span></li></ul><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="81c52aa0df49ac00c0a09a29e3d7813b"><code class="ne-code"><span class="ne-text">scrapy genspider amazon_spider https://……</span></code></li></ul></ul><ul class="ne-ul"><li id="5e122733b3ff5a1db7fee5a033659c55"><span class="ne-text">pipelines，默认return item</span></li><li id="9bd2919e24d9fe624e06cbf4edfac4f6"><span class="ne-text">编写其他配置，其中pipeline用于处理爬取后所得到的结果</span></li><li id="020b11e833e52ff2003cac307a4cde09"><span class="ne-text">执行爬虫</span></li></ul><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="140653cb451df1cf8fe965dca313f502"><code class="ne-code"><span class="ne-text">scrapy crawl amazon_spider</span></code></li></ul></ul><p id="bfa429401fe58953696b70f20a9f9d4e" class="ne-p"><br></p><h3 id="0dfbe902"><span class="ne-text">常用命令</span></h3><p id="c3c0738842ed3c37f6c5346281151043" class="ne-p"><br></p><h2 id="d17a0f0b"><span class="ne-text">参考</span></h2><p id="8af02097f08afc09430e0c63d28bce80" class="ne-p"><br></p><ul class="ne-ul"><li id="4e3ac598ec52649c64ff69b47941aa12"><span class="ne-text">查看其官方文档</span></li><li id="bac5e2f7c72a396ed88bd26637575e28"><a href="https://www.jianshu.com/p/8023fccd7206" data-href="https://www.jianshu.com/p/8023fccd7206" target="_blank" class="ne-link"><span class="ne-text">简书</span></a></li></ul></div>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
          <category> 数据分析 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JavaWeb学习笔记</title>
      <link href="/blog/tb3der/"/>
      <url>/blog/tb3der/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="u95da15b5" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2023/png/1484158/1673161445820-e9082e7b-8e06-4e95-a532-83ebdc48f7a3.png" width="326.6666564941406" id="ub1214ec9" class="ne-image"></p><p id="u73f18e98" class="ne-p"><span class="ne-text">前言：大二下封校javaweb课程学习笔记，javaweb技术过于老旧，还属于耦合式代码结构，不再适用于现代前端，本文只做笔记记录。</span></p><p id="u7086430d" class="ne-p"><span class="ne-text"></span></p><ul class="ne-ul"><li id="u790ba31a" data-lake-index-type="0"><span class="ne-text">课程大作业：</span><a href="https://github.com/wztlink1013/dormitory-management-system" data-href="https://github.com/wztlink1013/dormitory-management-system" target="_blank" class="ne-link"><span class="ne-text">https://github.com/wztlink1013/dormitory-management-system</span></a></li></ul><h1 id="Xur3R"><span class="ne-text">【第二章】JavaWeb概述</span></h1><h2 id="m8YWz"><span class="ne-text">一、XML</span></h2><p id="5e84886553b81a7eef0d1f572cf8b05c" class="ne-p"><br></p><p id="87019e12185ae093cec61bc4ebace559" class="ne-p"><code class="ne-code"><span class="ne-text">XML</span></code><span class="ne-text"> 是一种标记性语言，但是不同于 </span><code class="ne-code"><span class="ne-text">HTML</span></code><span class="ne-text"> ，目的其实就是用于传输数据，但是 </span><code class="ne-code"><span class="ne-text">HTML</span></code><span class="ne-text"> 的目的可以理解为展示</span></p><p id="1e17317244bf552bd7895485c9888795" class="ne-p"><br></p><div class="ne-quote"><p id="3ce07d60c8d777f97548e7641f2f15a3" class="ne-p"><span class="ne-text">网站建好之后，需要将自己的文章链接提交到百度/谷歌，通过部署生成的</span><code class="ne-code"><span class="ne-text">baidusitemap.xml</span></code><span class="ne-text">和</span><code class="ne-code"><span class="ne-text">sitemap.xml</span></code><span class="ne-text">文件，sitemap提交方式提交以达到目的。</span></p></div><p id="20db2d468e5a07f5b805e35b176d64dd" class="ne-p"><br></p><h3 id="d5f7f7a8"><span class="ne-text">XML语法</span></h3><p id="c7568c8dfcb43e50e16854541317521c" class="ne-p"><br></p><p id="cd3563e451b0195a771cea207a59d82a" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598670375381-0e3b13a8-6a22-47fb-8e8f-32c203fbf25d.png" width="461" id="LTz93" class="ne-image"></p><ul class="ne-ul"><li id="16e405cd46e8ce7b5ec04a78b69d74ea" data-lake-index-type="0"><span class="ne-text">文档声明：图中最上面一行</span></li><li id="08af62f32648e7a1a20c00a6a80cf207" data-lake-index-type="0"><span class="ne-text">元素定义：形式相当于 </span><code class="ne-code"><span class="ne-text">HTML</span></code><span class="ne-text"> 当中的标签，但不是标签，有根元素（一般只有一个），空元素等之分</span></li><li id="fd5b43a21022c0aac3738384aad6bcbc" data-lake-index-type="0"><span class="ne-text">属性定义：其中值需要用双引号或者单引号括起来</span></li><li id="9b13df05c038161d71f89f266b913434" data-lake-index-type="0"><span class="ne-text">注释：和 </span><code class="ne-code"><span class="ne-text">HTML</span></code><span class="ne-text"> 一样</span></li></ul><p id="68df66cfd5036c517446100a57724015" class="ne-p"><br></p><h3 id="19db8bdb"><span class="ne-text">DTD和Schema约束</span></h3><p id="8197464dbbc7634915a8829f4cdda8be" class="ne-p"><span class="ne-text">有些时候文档内可能内容语义有歧义，所以需要对其xml文件内容尽可能的加以约束，DTD和Schema两种方式</span></p><p id="197d6691e1c1c0057200a51c2c429d79" class="ne-p"><br></p><h2 id="b3e3926d"><span class="ne-text">二、HTTP协议</span></h2><div class="ne-quote"><p id="94ff31831f4f4069d3208899e8dee87d" class="ne-p"><span class="ne-text">生成的web项目和服务器之间的传输协议</span></p></div><p id="3281225c778b10bba1771b3dfa3c9371" class="ne-p"><br></p><p id="8c9fe41c2100e65508ae99e9e147c343" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598670375263-a1f1c0c1-0d94-4f9d-97ed-9d8e7e1d2495.png" width="305" id="z1db2" class="ne-image"></p><p id="a61cf3f91a1d24c407f42c2d197d9702" class="ne-p"><br></p><div class="ne-quote"><p id="3db1dc8507a46cd132cc86f0abd87703" class="ne-p"><span class="ne-text">其中http1.1版本比1.0版本优化的是对http请求可以同时进行多个请求和响应</span></p></div><p id="37b60c27b7e7d71c61fd580db6044d03" class="ne-p"><br></p><h3 id="74341368"><span class="ne-text">HTTP请求消息</span></h3><div class="ne-quote"><p id="45ff24ceedb95005a8da686d1bbe9eb3" class="ne-p"><span class="ne-text">客户端（web浏览器）向服务器发送请求，通常由请求行、请求头、实体内容三部分组成</span></p></div><ul class="ne-ul"><li id="f3cbc5748099a2e4336dc07e94d072af" data-lake-index-type="0"><span class="ne-text">请求行：请求方式，资源路径，http协议版本三部分组成。请求方式又有GET（所请求内容会在资源路径后面带上参数值，会有大小限制）和POST（安全，无大小限制）等方式</span></li></ul><p id="091428cb3248c27150c8ebd09f11a1f3" class="ne-p"><br></p><h3 id="a0aa718a"><span class="ne-text">HTTP响应消息</span></h3><div class="ne-quote"><p id="bfdf7deb8b4e50c931e3709b8bbd00ff" class="ne-p"><span class="ne-text">也由三部分组成，有资源状态行、响应消息头、实体内容</span></p></div><ul class="ne-ul"><li id="8ebd3a6f81084526eb14de6cde865bc5" data-lake-index-type="0"><span class="ne-text">资源状态行：协议版本 状态码 状态描述三部分组成。其中状态码有多种，常见的404就是服务器找不到相应请求的的资源</span></li></ul><p id="d3967797a81b179fa7781a95e5622f84" class="ne-p"><br></p><h2 id="c5519c96"><span class="ne-text">三、Tomcat</span></h2><p id="5b15d91aa7437eba9d7c3397ab87a61c" class="ne-p"><br></p><h3 id="0723454f"><span class="ne-text">关于Tomcat</span></h3><p id="a6f706e28806c009060db022b01b9419" class="ne-p"><br></p><p id="3c2ae53f11b96f047cba0dd475f452f6" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598670375411-c8675707-4396-48f4-b181-07310231b868.png" width="588" id="EMayQ" class="ne-image"></p><p id="db5bd98307e62954c0cb413e4c62fc29" class="ne-p"><br></p><h3 id="d783fe4f"><span class="ne-text">下载安装Tomcat</span></h3><p id="0ddd08390a0a5cd87d29cac1a36bf7ba" class="ne-p"><br></p><p id="2415b4dc7e0f9e2088030f1a6a6ee784" class="ne-p"><span class="ne-text">安装等方式参考博客</span></p><p id="0edcf51bdf0ac9033c4f08dd95e05fe5" class="ne-p"><br></p><h2 id="0d9aaaf8"><span class="ne-text">四、Web应用</span></h2><p id="5648f5018a79419e4e2d5d2ac3ff715b" class="ne-p"><br></p><h3 id="59683fbc"><span class="ne-text">简述</span></h3><p id="6c55ed41e02954fe2baf54f38d12ed74" class="ne-p"><br></p><div class="ne-quote"><p id="7c20ac0048449fb1032b61b1f0374494" class="ne-p"><span class="ne-text">web应用，就是一项工程，在编写web项目过程中，对文件按照“合乎规矩”的方式放置</span></p></div><p id="1b9f04ff208e3e0946d3ec3b7d5c31a2" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598670375598-ac6ece9f-6982-4a1d-a7d8-bc3c8b4ce0f7.png" width="476" id="IGXbX" class="ne-image"></p><p id="9aa181859e93263c04679bda12e5ab71" class="ne-p"><br></p><h3 id="dbcbbdea"><span class="ne-text">IDEA配置Tomcat</span></h3><p id="371201dc696e928fb7d7e3122e1e0717" class="ne-p"><br></p><p id="84747b6fc087c0fb7354698bf8ce4bef" class="ne-p"><span class="ne-text">搭建web开发环境</span></p><p id="8740d411dc9f4ce20979aa053f2cec87" class="ne-p"><br></p><p id="e2c528b3f837b28f3ac50c3238b54bd2" class="ne-p"><span class="ne-text">资源的访问，点击请求的页面跳转设置</span><code class="ne-code"><span class="ne-text">web.xml</span></code><span class="ne-text">中配置</span></p><p id="13f6a15fa38ec72846cdfad5a4ab71d8" class="ne-p"><br></p><div class="ne-quote"><p id="78d2fc170a0d10a9aca6a2412372b008" class="ne-p"><span class="ne-text">阮一峰的网站当中，有类似域名自动跳转，是否和域名解析有关呢？抑或是对web.xml进行了操作？</span></p></div><p id="6d1417e24a21e014224de790df8d0821" class="ne-p"><br></p><p id="3bd68fe342fbd9d9cb2c4b23a31d838d" class="ne-p"><span class="ne-text">对idea进行web开发 配置</span><a href="https://blog.csdn.net/ZTlink1013/article/details/104815639" data-href="https://blog.csdn.net/ZTlink1013/article/details/104815639" target="_blank" class="ne-link"><span class="ne-text">https://blog.csdn.net/ZTlink1013/article/details/104815639</span></a></p><p id="1d3e7592710e52f2d88a70d54337e96d" class="ne-p"><br></p><h1 id="uj23i"><span class="ne-text">【第三章】Servlet</span></h1><h2 id="14d15f0f"><span class="ne-text">一、什么是Servlet</span></h2><h3 id="7622ff83"><span class="ne-text">什么是Servlet</span></h3><p id="4ca993cfab70d1ca929c573608cfdfaa" class="ne-p"><br></p><div class="ne-quote"><p id="e44ffb20465c684f951739be67d58356" class="ne-p"><span class="ne-text">Servlet就是在服务器端的Java接口或者说是类（叫法有狭义广义之分），处理客户端传来的请求并作出相应的响应这么一个网络模块。</span></p></div><p id="e584920c84d31e1bf61b1cdecdae960b" class="ne-p"><br></p><ul class="ne-ul"><li id="035195c6da01f0f6f66063b45b17b0c1" data-lake-index-type="0"><span class="ne-text">请求：客户端传来的调用或是一系列行为，同时也包含了请求所需要的数据。</span></li><li id="39441e88a5b0ee14537cfc03634f77f0" data-lake-index-type="0"><span class="ne-text">响应：服务器根据客户端传来的请求做出响应，实时的展示给客户端。这之中Servlet相当于java类当中的一个接口，以请求来的信息作为输入，然后进行分析，做出相应。</span></li></ul><p id="a3dfdce98922ceac5fd71efab656f528" class="ne-p"><br></p><p id="5cc94f241502360f94687b9eb750ded4" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598670486756-3febd732-e4ee-413d-8868-a406760f5a22.png" width="472" id="JfLtz" class="ne-image"></p><p id="0062bc072137e713e2a689d2b1062628" class="ne-p"><br></p><h3 id="addc9ffb"><span class="ne-text">JSP和Servlet</span></h3><p id="2370309c847ebb7e458ea52c031ad60a" class="ne-p"><br></p><div class="ne-quote"><p id="995cb19a44e6e6491ea03a430beb9a20" class="ne-p"><span class="ne-text">servlet是控制层，jsp转换为servlet，用servlet来实现http请求。</span></p></div><p id="72afe9eefd85f0b168041b7960c97c41" class="ne-p"><br></p><p id="b096d4029394aec37834fbd8cde0bd8f" class="ne-p"><span class="ne-text">【1】JSP第一次运行的时候会编译成Servlet，驻留在内存中以供调用。</span></p><p id="1329292d23903d585273c1b88155fcbf" class="ne-p"><br></p><p id="770b938eba49555a5a0df875449e354f" class="ne-p"><span class="ne-text">【2】JSP是web开发技术，Servlet是服务器端运用的小程序，我们访问一个JSP页面时，服务器会将这个JSP页面转变成Servlet小程序运行得到结果后，反馈给用户端的浏览器。</span></p><p id="3265744d1002d4e30faffc2b89523df8" class="ne-p"><br></p><p id="b7e83051b69116fc21dc07870e4d5304" class="ne-p"><span class="ne-text">【3】Servlet相当于一个控制层再去调用相应的JavaBean处理数据,最后把结果返回给JSP。</span></p><p id="5f48c438f54946f2793685f51867871a" class="ne-p"><br></p><p id="273fa4590b8dd743b69515326c144f9f" class="ne-p"><span class="ne-text">【4】Servlet主要用于转向，将请求转向到相应的JSP页面。</span></p><p id="539aa69c4de7b6d1348ff9f965f6c519" class="ne-p"><br></p><p id="0a48965ff8bd7cb77d15d3538f3798de" class="ne-p"><span class="ne-text">【5】JSP更多的是进行页面显示，Servlet更多的是处理业务，即JSP是页面，Servlet是实现JSP的方法。</span></p><p id="829319010beb33296e7b629e1a5f5dba" class="ne-p"><br></p><p id="ef4e24864a85e0531b0b0114ed8c0ebe" class="ne-p"><span class="ne-text">【6】Servlet可以实现JSP的所有功能，但由于美工使用Servlet做界面非常困难，后来开发了JSP。</span></p><p id="2d0533fd606099de85a8a04f81a806b8" class="ne-p"><br></p><p id="c329391185a142b8d30643c536900449" class="ne-p"><span class="ne-text">【7】JSP技术开发网站的两种模式：JSP + JavaBean；JSP + Servlet + JavaBean（一般在多层应用中, JSP主要用作表现层,而Servlet则用作控制层,因为在JSP中放太多的代码不利于维护，而把这留给Servlet来实现,而大量的重复代码写在JavaBean中）。</span></p><p id="25d797eb6d8c26c1d0d725a0a65157b4" class="ne-p"><br></p><p id="a22926944ab62d698d215b89a38466cc" class="ne-p"><span class="ne-text">【8】二者之间的差别就是，开发界面是JSP直接可以编写。</span></p><p id="1e55cd614bfa23955ae33e28391f0836" class="ne-p"><br></p><p id="8523ce87146420e2bf0b2f4356ecc6d1" class="ne-p"><span class="ne-text">比如在JSP中写Table标记：</span><code class="ne-code"><span class="ne-text">&lt;table&gt;[数据]&lt;/table&gt;；</span></code></p><p id="42002731d37310dd0308181b4fcf29fc" class="ne-p"><br></p><p id="951b66153e368f2bbdd8686385b7cf93" class="ne-p"><span class="ne-text">Servlet需要加入：</span><code class="ne-code"><span class="ne-text">out.println(“&lt;table&gt;[数据]&lt;/table&gt;”)。</span></code></p><p id="39ef7656f5215114069ca8661ea4af7b" class="ne-p"><br></p><p id="e32464f639a23894944c912adbebee1f" class="ne-p"><span class="ne-text">JSP文件在被应用服务器(例如：Tomcat、Resin、Weblogic和Websphere),调用过之后，就被编译成为了Servlet文件。也就是说在网页上显示的其实是Servlet文件。Tomcat下面JSP文件编译之后生成的Servlet文件被放在了work文件夹下，JSP中的HTML代码在Servlet都被out出来，而JSP代码按照标签的不同会放在不同的位置。</span></p><p id="341937232ceb9e694630e9c5e65e1df8" class="ne-p"><br></p><p id="60d3582486cfbd8ac886815f3c348094" class="ne-p"><span class="ne-text">【9】JSP中嵌入JAVA代码，而Servlet中嵌入HTML代码。</span></p><p id="0f27858d413f601b4074255311da2c48" class="ne-p"><br></p><p id="5cd54d9fc4911d03573bbccd120d854a" class="ne-p"><span class="ne-text">【10】在一个标准的MVC架构中，Servlet作为Controller接受用户请求并转发给相应的Action处理，JSP作为View主要用来产生动态页面，EJB作为Model实现你的业务代码。</span></p><p id="e34439b7e36421bde7a228d4994572b7" class="ne-p"><br></p><h2 id="385bb557"><span class="ne-text">二、Servlet基础</span></h2><p id="bf79bab2cdffa5e8c8afa2ba7c4a7004" class="ne-p"><br></p><h3 id="df2332cc"><span class="ne-text">接口及其实现类</span></h3><p id="4d2df39762a23d220a9e3729bcd4eaff" class="ne-p"><br></p><p id="9bf4aa0b0f49ce55c08fbeb8c323e778" class="ne-p"><span class="ne-text">就是利用其类编写相关服务器端的相关运行代码</span></p><h3 id="176808a1"><span class="ne-text">生命周期</span></h3><p id="8108b18a5761cdd51ab00c49ff668bb0" class="ne-p"><br></p><p id="9342457c10e8fc91c313fc5161a9a66c" class="ne-p"><span class="ne-text">分三个阶段：初始化阶段-&gt;运行阶段-&gt;销毁阶段</span></p><h3 id="c0f78462"><span class="ne-text">HttpServlet类</span></h3><p id="fc1ba4bb9174c7618797686205287944" class="ne-p"><br></p><p id="15f314a1b2d8924af38d35a4e6f37e46" class="ne-p"><span class="ne-text">一般客户端和服务器之间都回使用  </span><code class="ne-code"><span class="ne-text">HTTP协议</span></code><span class="ne-text"> ，所以Servlet接口中就提供了一个抽象类</span><code class="ne-code"><span class="ne-text">javax.servlet.http.HttpServlet</span></code><span class="ne-text">，他是 </span><code class="ne-code"><span class="ne-text">GernericServlet</span></code><span class="ne-text"> 的一个子类，专门用来处理 </span><code class="ne-code"><span class="ne-text">HTTP协议</span></code><span class="ne-text"> 的servlet；具体程序中就是用该类</span></p><p id="aa5fde625e15f041d7cde52889145fce" class="ne-p"><br></p><div class="ne-quote"><p id="688031ad3277e502d504cd506a8f0d0c" class="ne-p"><span class="ne-text">HelloWordServlet.java</span></p></div><p id="cc61905bb9c829e1575bf2f6ede64fe6" class="ne-p"><br></p><pre><code><code>package cn.itcast.firstmyapp.servlet;<p>import java.io.IOException;<br>import java.io.PrintWriter;</p><p>import javax.servlet.ServletException;<br>import javax.servlet.http.HttpServlet;<br>import javax.servlet.http.HttpServletRequest;<br>import javax.servlet.http.HttpServletResponse;</p><p>public class HelloWordServlet extends HttpServlet &#123;</p><pre><code> protected void doGet(HttpServletRequest req, HttpServletResponse resp)            throws ServletException, IOException &#123;             System.out.println(&amp;quot;接受了客户端的请求-----------------------------&amp;quot;);     // 设置响应类型:        resp.setContentType(&amp;quot;text/html&amp;quot;);        // 获取输出流:        PrintWriter pw = resp.getWriter();        // 写入响应:        pw.write(&amp;quot;&amp;lt;h1&amp;gt;Hello, world!&amp;lt;/h1&amp;gt;&amp;quot;);        // 最后不要忘记flush强制输出:        pw.flush();    &#125;</code></pre><p>}</code><br></code></pre></p><p id="122cf52b455e179a330fa6311f6a4808" class="ne-p"><br></p><h2 id="70b547c4"><span class="ne-text">三、Servlet虚拟路径的映射</span></h2><p id="80497193b4cc9d117f7a3128536cafbf" class="ne-p"><br></p><h3 id="c4080971"><span class="ne-text">1. 多重映射</span></h3><div class="ne-quote"><p id="e028cdb2b05f70a7c9bd1f1df3b9f816" class="ne-p"><span class="ne-text">就相当于多加几个自己指定的访问路径，在web.xml中</span></p></div><p id="9bab8a916b92d85f2351c3a796afa9b2" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598670486704-cb7b6356-6317-47d3-85c4-a27582c41121.png" width="487" id="Cm4lh" class="ne-image"></p><p id="5cfd2224bc82de02690509f7d9b92c58" class="ne-p"><br></p><h3 id="45d851eb"><span class="ne-text">2. 映射路径下使用通配符</span></h3><div class="ne-quote"><p id="060dce3f29b0724464466cda95f832b8" class="ne-p"><span class="ne-text">在其中使用通配符，一个目录下的所有路径都可以访问，其中有完全目录匹配，目录匹配，扩展名匹配</span></p></div><p id="24615376a822ef7a6dbd8edcbb610c7f" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598670487060-fa223535-eabd-40c6-bf7e-088fc77c9c87.png" width="493" id="FGBmm" class="ne-image"></p><p id="e958641f6e459c63556ee8e4a0df54dd" class="ne-p"><br></p><h3 id="ede484bd"><span class="ne-text">3. 缺省</span></h3><p id="b0dab1f4c964e62c342221f7290dd6b6" class="ne-p"><span class="ne-text">通常作用是解决请求的资源找不到的情况，（404：请求的资源找不到）</span></p><h2 id="b92a7e97"><span class="ne-text">四、 </span><code class="ne-code"><span class="ne-text">ServletConfig</span></code><span class="ne-text"> 和 </span><code class="ne-code"><span class="ne-text">ServletContext</span></code><span class="ne-text"> </span></h2><p id="5c0aea729f0ca0321c760bba193de32a" class="ne-p"><br></p><div class="ne-quote"><p id="a99709c69da2cb9f9b629bd3a382db50" class="ne-p"><span class="ne-text">ServletConfig接口</span></p></div><p id="49fddfeec3d71ab2638f850302ac8609" class="ne-p"><br></p><p id="91ad288b3419f5c494acbb674e5cb567" class="ne-p"><span class="ne-text">类比于git根文件夹</span><code class="ne-code"><span class="ne-text">.ssh</span></code><span class="ne-text">下的config配置文件，它是servlet的配置对象，目的就是获取与servlet的初始化参数</span></p><p id="e307cabaf73b9951b3959b0e6bcc47ff" class="ne-p"><br></p><div class="ne-quote"><p id="bae134fd8f1a5de586729009cec51f0a" class="ne-p"><span class="ne-text">PS:会使用常用的接口方法</span></p></div><p id="01fdcf311b982c94b85df61fd47b776f" class="ne-p"><br></p><h1 id="R7SLd"><span class="ne-text">【第五章】会话技术</span></h1><h2 id="f2639692"><span class="ne-text">一、会话技术</span></h2><p id="f627049b25649804436485bc72718777" class="ne-p"><span class="ne-text">相当于在客户端和服务器端之间，记录一些用户信息，但是不能用上一章节的，因为那只能保存暂时的信息。 </span><code class="ne-code"><span class="ne-text">servlet</span></code><span class="ne-text"> 还提供两个对象 </span><code class="ne-code"><span class="ne-text">Cookie</span></code><span class="ne-text"> 和 </span><code class="ne-code"><span class="ne-text">Session</span></code><span class="ne-text"> 可以更好地更好地保存会话数据。</span></p><p id="4982765dc0ab314bd287087cd767d0f2" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598670565525-6a2b8b74-4105-447a-95ba-034020c747fe.png" width="601" id="H7o94" class="ne-image"></p><h1 id="VKJIv"><span class="ne-text">【第六章】JSP技术</span></h1><h2 id="9b6445d6"><span class="ne-text">一、JSP概述</span></h2><p id="b6c0fbde6367aba5f757e0d2caad016a" class="ne-p"><br></p><p id="4c6e7105ebeef5c38bf2d77a62980d41" class="ne-p"><span class="ne-text">一种新的编写动态网页的技术，虽然本质还是调用了 </span><code class="ne-code"><span class="ne-text">servlet</span></code><span class="ne-text"> ，但是相比前者要简单很多（前者向页面写数据麻烦，复杂），其组成可以简单理解为</span></p><p id="89c4399dd7008be7cb78d347d67e1597" class="ne-p" style="text-align: center"><code class="ne-code"><span class="ne-text">jsp = html + java + jsp自身</span></code></p><p id="deb48ea61d2f78170b1cc6f373d508a8" class="ne-p"><br></p><p id="eb445ab23fd0b84079171d328acaa6f5" class="ne-p"><span class="ne-text">调用servlet过程：</span></p><p id="85daca56eb0834af22ce5c09cfa66052" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598670585374-60fc5166-cb3c-433e-9794-bae3778a3cd8.png" width="477" id="qSgI4" class="ne-image"></p><p id="bf306f11855b719f8b71ce7cc3cd9c47" class="ne-p"><br></p><p id="fcb9b49259f7ec59cb6619b90ed76598" class="ne-p"><span class="ne-text">其中jsp生成java文件，编译成class文件所在目录（本来应该在tomcat的work路径下）：</span><code class="ne-code"><span class="ne-text">D:\project-java\.metadata\.plugins\org.eclipse.wst.server.core\tmp0\work\Catalina\localhost\demo-jsp\org\apache\jsp</span></code></p><p id="592ed3cc203703d685648811c3211c13" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598670585365-5f311403-0761-4643-aa17-931be713fc49.png" width="468" id="aROEK" class="ne-image"></p><p id="000aac780005a40cc7fd3f7c2d8cff5e" class="ne-p"><br></p><p id="f1503215e7aa439707d3486d83fdfb27" class="ne-p"><span class="ne-text">打开java文件之后可以看到相关对sevlet的继承</span></p><p id="a79e7d44d3d267e0d474a5c1fa7cd5c7" class="ne-p"><br></p><h2 id="ef846b89"><span class="ne-text">二、JSP语法</span></h2><p id="1fca6f970b00308ea34c0ff1a0b46f21" class="ne-p"><br></p><h3 id="07494b95"><span class="ne-text">jsp脚本元素</span></h3><p id="d2aba671e14792eaa136e398a314c579" class="ne-p"><br></p><p id="b5e0a6f27c50538fa0fc63f3b801fd2e" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598670585361-957371bf-bb37-407a-90e8-8f21175d6589.png" width="639" id="zr7hH" class="ne-image"></p><p id="30655c8d1daccf7a0e2823a2f37c8cbd" class="ne-p"><br></p><h3 id="dda4e70c"><span class="ne-text">jsp注释</span></h3><p id="ee5f003e4d31cfd49a7901849eeb0574" class="ne-p"><br></p><p id="7bc75b81a6886506300b9f25d0254f93" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598670585756-18f96e5c-8a74-4e14-8c16-55a9fd9124df.png" width="643" id="LgNrf" class="ne-image"></p><p id="29353c991a467a489c3a993b29b08d0b" class="ne-p"><br></p><h3 id="3b8d7fcb"><span class="ne-text">jsp指令</span></h3><p id="ee9a63c7e55005a5c0fcde1d0b9a519f" class="ne-p"><br></p><div class="ne-quote"><p id="50381928c1f1b3d4852fbf83d804cda0" class="ne-p"><span class="ne-text">page指令</span></p></div><p id="e5d1c5f206ad21a65404806eb522368a" class="ne-p"><br></p><p id="715fe5635a3bd16e0759221b8ff53cfa" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598670585347-a182a404-b425-4f70-80d6-712122944623.png" width="658" id="eHsBW" class="ne-image"></p><p id="91d121e789cf317c390951b64f3719ed" class="ne-p"><br></p><div class="ne-quote"><p id="156c9dbab7103c0c1ad925d211e4e91d" class="ne-p"><span class="ne-text">include指令</span></p></div><p id="3dd38011978f4acd9ce01d334c00bbc0" class="ne-p"><br></p><p id="879c06158de859cbe822a8b7cf1bf8e0" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598670585378-bbe2df4b-013e-4531-bece-2836e4b8bde0.png" width="677" id="NUHzD" class="ne-image"></p><p id="409ab4ad15244fc01ed82875fbf551f4" class="ne-p"><br></p><div class="ne-quote"><p id="62b682ac970ff8a9a96342f26b40f4b6" class="ne-p"><span class="ne-text">taglib指令</span></p></div><p id="e5beab2c35cf46c0b6dcf9c48e528a89" class="ne-p"><br></p><h3 id="9a456749"><span class="ne-text">jsp隐式对象</span></h3><p id="14066e20afd8fba3ed7614c78417fbae" class="ne-p"><br></p><p id="bf315810b5412253befa6b1753d1db15" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598670585348-c41424d0-e688-4ae6-809e-bcc33afec5e3.png" width="650" id="Z5fkm" class="ne-image"></p><h1 id="NeXMB"><span class="ne-text">【第九章】JDBC</span></h1><h2 id="8057578e"><span class="ne-text">一、什么是JDBC</span></h2><div class="ne-quote"><p id="dc80a2701370d38bead2f7754c1a76b2" class="ne-p"><span class="ne-text">使用数据库来存储和管理数据</span></p></div><p id="847dbeaf0bc15967966bd0745be53d83" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598670606448-7b5d3ec0-c6eb-4485-af84-34a1d99fa4a1.png" width="503" id="E6aOX" class="ne-image"></p><p id="3c16f97a1f3dbbdebbe56345dd6f1088" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598670606324-93a22794-21bb-42fc-9355-64c55411ea53.png" width="487" id="CgXyx" class="ne-image"></p><p id="eb4a0ddd3db11c7d1fe6f43c861af428" class="ne-p"><br></p><h2 id="2e55d434"><span class="ne-text">二、JDBC常用的API</span></h2><p id="5edd8befc57cb6088c44e12f2169e0fa" class="ne-p"><br></p><div class="ne-quote"><p id="983cf931227815c13d97334140fccea5" class="ne-p"><span class="ne-text">五个接口一个类（唯一的类）</span></p></div><p id="bce68f29648efb24109a8cc8c5fce5fd" class="ne-p"><br></p><p id="4c017b3ffd8e2deb10db5bee8c0317e6" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598670606334-40b58ccd-ef50-4048-a17a-819885cdcf87.png" width="649" id="lBHLh" class="ne-image"></p><p id="45ea7400ed613e7b5605471640b4864f" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598670606546-72057847-1b52-4b82-8f03-d2dcff6e0ed4.png" width="635" id="a5KOy" class="ne-image"></p><p id="3a50e0d5bc7fb565577dfd49081d8178" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598670606535-2996029c-eaf0-45ee-a778-614141ceea4f.png" width="624" id="G6Aec" class="ne-image"></p><h1 id="TMDnF"><span class="ne-text">【第十一章】JSP开发模型</span></h1><h2 id="24cc9c02"><span class="ne-text">一、JSP两种开发模式</span></h2><p id="34a30d85beb388e63cdc4957641359eb" class="ne-p"><br></p><p id="d03d20cc9754cc30f943e4b2434948d8" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598670623021-1406c5eb-f010-4d9f-a6fe-cd104b964450.png" width="998" id="XbJTY" class="ne-image"></p><p id="0c431fe2df3c3f5132ec2b77934b4e7e" class="ne-p"><br></p><h3 id="5eb83889"><span class="ne-text">JSP Model1</span></h3><p id="91596b7fa328fd70b5bfac2c7e200abc" class="ne-p"><br></p><p id="af18ff6cc3feaa48009d7afcdc1d8893" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598670623035-3dae1126-3986-4893-afbf-ce3aa250deb1.png" width="1220" id="bTCTH" class="ne-image"></p><p id="118b3e33dcbdc6817c9cffba0f20c847" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598670623082-df4cb3b4-1eb4-4590-a68f-f18a31a31816.png" width="579" id="Is4c9" class="ne-image"></p><p id="51a732c657cbb4e09df4917d08456cd2" class="ne-p"><br></p><h3 id="83d5f971"><span class="ne-text">JSP Model2</span></h3><p id="15d2cb3612bdfb77531d34a8eab48187" class="ne-p"><br></p><p id="00f94c86dcc4193c8363be62f04e9a17" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598670623814-f1853ddf-0ab6-443c-b90f-97147896aa3c.png" width="1045" id="gPlqN" class="ne-image"></p><p id="5c6872af10aef200bd56538482aa9222" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598670623035-37842a30-2e67-40d6-9b33-fc7a90a89037.png" width="523" id="oq4zV" class="ne-image"></p><p id="4d2f3eccfe01e591b4a56d2ad3bbc736" class="ne-p"><br></p><h2 id="38973f0b"><span class="ne-text">二、MVC设计模式</span></h2><p id="77497a9c4544bdb015fcf83eba122627" class="ne-p"><br></p><p id="e1c57d0ca139882b97b1945cb783a30e" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598670623024-0fbab2bd-139b-4e8e-806a-a010e86e6159.png" width="1185" id="AxOXe" class="ne-image"></p><p id="10df61d0a5558d052561e4e95eafaf97" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598670623036-c1e95730-c04c-44ab-a07d-be7d3ce47970.png" width="1138" id="fmGY7" class="ne-image"></p><p id="8bd4e192cd192c93660d24f3ad7b265b" class="ne-p"><br></p><h2 id="5ddf16b2"><span class="ne-text">三、JavaWeb开发中的三层架构</span></h2><p id="5beb94f4cb45c681c2a8fe5d4ff1014d" class="ne-p"><br></p><p id="213b1f60bd782d6fe061791ad1b0ce4e" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598670623143-02074466-5715-4efa-8b09-ee2a1489d94e.png" width="1077" id="oVGry" class="ne-image"></p><p id="33df85f41fa44d78b0f3c3436f547913" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598670623075-f2b2b6ce-ebd7-4712-86f3-61ee087aafbb.png" width="525" id="cVavj" class="ne-image"></p><p id="ae9f37c93cbd0dbca6d65d7f01e766cf" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598670622943-c73fc987-bbd4-4204-9a82-6a93ea4ac8ed.png" width="1066" id="XvkOG" class="ne-image"></p><p id="c7f671c4af7e797c1b81a98182f3ef02" class="ne-p"><br></p></div>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
          <category> 前端业务解决方案 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Git安装配置及Git命令总结</title>
      <link href="/blog/fnsge3/"/>
      <url>/blog/fnsge3/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h2 id="3c159820"><span class="ne-text">一、Git安装和本地用户全局配置</span></h2><h3 id="CAAPD"><span class="ne-text">Git的下载与安装</span></h3><ul class="ne-ul"><li id="2b9fe73bdb3c348c97b1499b05e85e28" data-lake-index-type="0"><span class="ne-text">进官网下载 </span><a href="https://git-scm.com/download/win" data-href="https://git-scm.com/download/win" target="_blank" class="ne-link"><span class="ne-text">https://git-scm.com/download/win</span></a><span class="ne-text"> 并且安装</span></li><li id="8401e923b718de70f34c519fdacd61cc" data-lake-index-type="0"><span class="ne-text">查看是否安装成功</span><code class="ne-code"><span class="ne-text">win + R</span></code><span class="ne-text">进入CMD输入git，出现git命令指南，则安装成功</span></li></ul><p id="cda637f43d8ed594201e12079b58def6" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1624934078835-17bc30b2-2f33-49b2-9d41-5d38ae309d5b.png" width="720" id="acr1I" class="ne-image"></p><p id="6e7f45d287a346806e54cd141f52e354" class="ne-p"><br></p><h3 id="O1HBu"><span class="ne-text">全局配置本地用户</span></h3><p id="u7a93fba1" class="ne-p"><span class="ne-text">在git Bash中进行下面配置，下面的账号名字和邮箱都是github的账号所使用的</span></p><p id="f306853e0c0325fc6d3aed788fdbfa5f" class="ne-p"><br></p><pre><code><code>git config --global user.name &quot;wztlink1013&quot;git config --global user.email &quot;wztlink1013@163.com&quot;</code></code></pre><p id="ecb8ff6fa82eb81c329ce7938e3c1337" class="ne-p"><br></p><div class="ne-quote"><p id="dfa539d717445f30a0ea67a0f25eb95f" class="ne-p"><span class="ne-text">其中：global表示全局可用，如果要设置局部可用，则只需要删除global即可</span></p></div><h3 id="cdZrf"><span class="ne-text">验证是否配置成功</span></h3><pre><code><code>git config --global --list</code></code></pre><p id="fe68c7dc905dbfa1d7b17a6293979690" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1624936078225-da481808-a48c-44d4-b462-8bd283f607b3.png" width="441" id="Ib8qE" class="ne-image"></p><h2 id="21431630"><span class="ne-text">二、SSH绑定Git和GitHub</span></h2><h3 id="kxSPj"><span class="ne-text">生成SSH密钥</span></h3><ol class="ne-ol"><li id="u15230470" data-lake-index-type="0"><span class="ne-text">输入以下命令，然后回车三下 </span><span class="ne-text" style="text-decoration: line-through">（有些时候要回车四下）</span></li></ol><pre><code><code>ssh-keygen -t rsa</code></code></pre><ol start="2" class="ne-ol"><li id="u8c3367ec" data-lake-index-type="0"><span class="ne-text">然后用户管理员文件夹下会生成下面两个文件id_rsa和</span><strong><span class="ne-text">id_rsa.pub</span></strong></li></ol><p id="2e700fa3904d6bc1021f7b27ab236131" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1624936245745-59fb92ec-8f9d-4ad8-8986-d9b245d56ed4.png" width="590" id="uDYmq" class="ne-image"></p><h3 id="Jzy1w"><span class="ne-text">GitHub上添加生成的SSH密钥</span></h3><ul class="ne-ul"><li id="u26dc105b" data-lake-index-type="0"><span class="ne-text">将上述</span><strong><span class="ne-text">id_rsa.pub</span></strong><span class="ne-text">的文件内容添加到GitHub上的ssh即可</span></li></ul><p id="uc0533b6f" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1658839202493-2b112709-a670-4e7b-a764-a791a0a01282.png" width="1125.926005464201" id="u3ac34598" class="ne-image"></p><h3 id="IgVkR"><span class="ne-text">验证是否绑定成功</span></h3><pre><code><code>ssh -T git@github.com</code></code></pre><ul class="ne-ul"><li id="6a0e4944f3cd68096c1066e9a3b26ef4" data-lake-index-type="0"><span class="ne-text">响应如下内容则证明绑定成功</span></li></ul><p id="u1e7edcd5" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1624936534567-668d781f-afc8-4753-85a0-09d7fabe3901.png" width="441" id="CHJEV" class="ne-image"></p><h4 id="t7QTi"><span class="ne-text">The authenticity of host 'github.com (xx.xxx.xxx.xx)' can't be established.</span></h4><p id="u58360036" class="ne-p"><span class="ne-text">出现该错误，原因为少了一个known_hosts文件，解决方法，直接键入yes，再回车。</span></p><h2 id="8338528d"><span class="ne-text">三、常用命令总结</span></h2><h3 id="5990883c"><span class="ne-text">git clone</span></h3><p id="44ec70d218885ff49cc7a5d2670b5555" class="ne-p"><span class="ne-text">本地没有git仓库，也没有</span><code class="ne-code"><span class="ne-text">git init</span></code><span class="ne-text">初始化仓库操作，需要先从GitHub上clone仓库下来：</span></p><pre><code><code>git clone https://github.com/wztlink1013/datastructure-algorithm.git</code></code></pre><p id="ude2f73f2" class="ne-p"><span class="ne-text">克隆仓库指定commit深度</span></p><div class="ne-quote"><p id="u410c3390" class="ne-p"><span class="ne-text">有的GitHub仓库存在很久，有很多commit历史，特别是曾经的某一次提交带有较大文件的情况，会导致后续clone工程大的问题</span></p><p id="u5cc1ea52" class="ne-p"><span class="ne-text">depth n参数代表克隆深度，不带该参数则克隆所有历史版本</span></p></div><pre><code><code>git clone git@github.com:wztlink1013/web-learn-notes.git --depth 1</code></code></pre><p id="ua5f95d9a" class="ne-p"><span class="ne-text">克隆指定分支下来</span></p><pre><code><code>git clone -b 指定分支名 git@github.com:wztlink1013/wztlink1013.github.io.git</code></code></pre><h3 id="wD4Ic"><span class="ne-text">常规提交代码</span></h3><p id="aab32beef4b4d2ea8b8041ade913c9bf" class="ne-p"><span class="ne-text">对本地文件夹进行一系列更改之后，执行命令：</span></p><pre><code><code># 查看仓库命令状态git status # 文件提交到文件缓冲区git add .   # 提交仓库并且添加提交信息git commmit -m &quot;描述本次修改信息&quot;    # 查看修改日志git log  # 再次查看git status   <h1 id="首次推送"><a href="#首次推送" class="headerlink" title="首次推送"></a>首次推送</h1><p>git push -u origin master</p><h1 id="非首次推送"><a href="#非首次推送" class="headerlink" title="非首次推送"></a>非首次推送</h1><p>git push origin master</code><br></code></pre></p><h3 id="49f0a49e"><span class="ne-text">git pull</span></h3><p id="8ab7cfd0020ecbb134739f4e2e7c4a67" class="ne-p"><span class="ne-text">使用git pull情况是，本地有git仓库，指之前已经进行git init等一系列命令对该文件夹操作过。比如下面的新建一个例子：</span></p><pre><code><code># 初始化本地仓库git init# 关联远程仓库git remote add origin https://github.com/wztlink1013/wztlink1013.github.io.git# 同步远程仓库和本地仓库git pull origin master</code></code></pre><div data-type="danger" class="ne-alert"><p id="500b18c0c9935a01e489252b00a20f7a" class="ne-p"><strong><span class="ne-text">注意</span></strong><span class="ne-text">：在进行本地仓库和远程仓库的文件交互时，一定要先pull再push，不然会出未知错误。</span></p></div><ol class="ne-ol"><li id="u1a371e83" data-lake-index-type="0"><span class="ne-text" style="text-decoration: line-through">将远程指定分支 拉取到 本地指定分支上：</span><strong><span class="ne-text" style="color: #E8323C">（当前分支也会被改变，可能需要先创建一个该名字的分支？？）</span></strong></li></ol><pre><code><code>git pull origin &lt;远程分支名&gt;:&lt;本地分支名&gt;</code></code></pre><ol start="2" class="ne-ol"><li id="u820a421d" data-lake-index-type="0"><span class="ne-text">将远程指定分支 拉取到 本地当前分支上：</span></li></ol><pre><code><code>git pull origin &lt;远程分支名&gt;</code></code></pre><ol start="3" class="ne-ol"><li id="u2ee989c5" data-lake-index-type="0"><span class="ne-text">将与本地当前分支同名的远程分支 拉取到 本地当前分支上(需先关联远程分支，方法见上)</span></li></ol><pre><code><code>git pull</code></code></pre><p id="uf6c1bf2f" class="ne-p"><span class="ne-text">在克隆远程项目的时候，本地分支会自动与远程仓库建立追踪关系，可以使用默认的origin来替代远程仓库名，</span></p><p id="u2b777eb8" class="ne-p"><span class="ne-text">所以，常用的命令就是 git pull origin &lt;远程仓库名&gt;，操作简单，安全可控。</span></p><h3 id="Q2YQG"><span class="ne-text">git push</span></h3><ol class="ne-ol"><li id="uae4107ca" data-lake-index-type="0"><span class="ne-text">将本地当前分支 推送到 远程指定分支上（注意：pull是远程在前本地在后，push相反）：</span></li></ol><pre><code><code>git push origin &lt;本地分支名&gt;:&lt;远程分支名&gt;</code></code></pre><ol start="2" class="ne-ol"><li id="ua65b5ec1" data-lake-index-type="0"><span class="ne-text">将本地当前分支 推送到 与本地当前分支同名的远程分支上（注意：pull是远程在前本地在后，push相反）：</span></li></ol><pre><code><code>git push origin &lt;本地分支名&gt;</code></code></pre><ol start="3" class="ne-ol"><li id="uc39d4be8" data-lake-index-type="0"><span class="ne-text">将本地当前分支 推送到 与本地当前分支同名的远程分支上(需先关联远程分支，见上)</span></li></ol><pre><code><code>git push</code></code></pre><p id="u808010f5" class="ne-p"><span class="ne-text">同样的，推荐使用第2种方式，git push origin &lt;远程同名分支名&gt;</span></p><ol start="4" class="ne-ol"><li id="u1ce2ee35" data-lake-index-type="0"><span class="ne-text">git push -u </span></li></ol><p id="uda1272d6" class="ne-p"><span class="ne-text">将本地分支与远程同名分支相关联（多用于首次push）</span></p><pre><code><code>git push --set-upstream origin &lt;本地分支名&gt;</code></code></pre><p id="uef5930d0" class="ne-p"><span class="ne-text">简写方式：</span></p><pre><code><code>git push -u origin &lt;本地分支名&gt;</code></code></pre><ol start="5" class="ne-ol"><li id="u5e069d83" data-lake-index-type="0"><span class="ne-text">git push -f</span></li></ol><pre><code><code>$ git push origin masterTo https://github.com/wztlink1013/website-source.git ! [rejected]        master -&gt; master (fetch first)error: failed to push some refs to 'https://github.com/wztlink1013/website-source.git'hint: Updates were rejected because the remote contains work that you dohint: not have locally. This is usually caused by another repository pushinghint: to the same ref. You may want to first integrate the remote changeshint: (e.g., 'git pull ...') before pushing again.hint: See the 'Note about fast-forwards' in 'git push --help' for details.</code></code></pre><ul class="ne-ul"><li id="u09246219" data-lake-index-type="0"><span class="ne-text">解决：强制性push</span></li></ul><pre><code><code>git push -f origin master</code></code></pre><h3 id="RJdz3"><span class="ne-text">git branch/checkout</span></h3><p id="u1e3e88ca" class="ne-p"><span class="ne-text">常规使用</span></p><pre><code><code># 从当前分支创建并切换新的分支git checkout -b 分支名  # 查看本地所有分支git branch # 切换到指定分支git checkout 指定分支名</code></code></pre><p id="ue6b34ac0" class="ne-p"><span class="ne-text">从远程拉取指定分支并切换</span></p><pre><code><code># 方法1git fetch origin dev-2.0-wzt:dev-2.0-wzt<h1 id="方法2"><a href="#方法2" class="headerlink" title="方法2"></a>方法2</h1><p>git fetch<br>git checkout -b dev-2.0-wzt origin/dev-2.0-wzt</code><br></code></pre></p><p id="u6ee8ea2e" class="ne-p"><span class="ne-text">删除指定分支</span></p><pre><code><code>git branch --delete dev-2.0-wzt1# error: The branch 'dev-2.0-wzt1' is not fully merged.# If you are sure you want to delete # it, run 'git branch -D dev-2.0-wzt1'.git branch -D dev-2.0-wzt1  # Deleted branch dev-2.0-wzt1 (was 63e7215).</code></code></pre><h3 id="lseEO"><span class="ne-text">git reset</span></h3><p id="u88a0728a" class="ne-p"><span class="ne-text">回退指定历史命令</span></p><p id="u2d3d8b4d" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1639990649778-2e3ec7b1-e554-47af-b8ca-dbad93bf23a0.png" width="931.5" id="u77bcd18c" class="ne-image"></p><pre><code><code>git reset --hard 9fba643590aeb5889c84029585848b93c3e64e5d</code></code></pre><p id="u6aae1be2" class="ne-p"><span class="ne-text">本地回退到指定commit之后，如果需要同步到远程分支之后，可以进行以下操作：</span></p><ol class="ne-ol"><li id="u6f5454bb" data-lake-index-type="0"><span class="ne-text">在GitHub上复制一个备份分支（因为强制命令会使得新提交的commit失效）</span></li><li id="ud4f4fdf8" data-lake-index-type="0"><span class="ne-text">使用强制push命令</span></li></ol><pre><code><code>git push origin -f main</code></code></pre><p id="u424a2353" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1664937067212-47e37526-ff2a-491a-a9d0-1e08890a4626.png" width="639.1666412684663" id="u6bbfed4f" class="ne-image"></p><h3 id="bTuTM"><span class="ne-text">git commit</span></h3><ul class="ne-ul"><li id="u894a1a33" data-lake-index-type="0"><span class="ne-text">git提交信息可以绑定指定的issues，普通使用则是在commit提交信息中</span><code class="ne-code"><span class="ne-text">#issue_id</span></code><span class="ne-text">即可，还有一些细节使用参考链接（</span><a href="https://stackoverflow.com/questions/1687262/link-to-the-issue-number-on-github-within-a-commit-message" data-href="https://stackoverflow.com/questions/1687262/link-to-the-issue-number-on-github-within-a-commit-message" target="_blank" class="ne-link"><span class="ne-text">https://stackoverflow.com/questions/1687262/link-to-the-issue-number-on-github-within-a-commit-message</span></a><span class="ne-text">）</span></li></ul><h3 id="N6cvf"><span class="ne-text">将当前修改内容提交新分支</span></h3><pre><code><code># 步骤1：在当前分支上的修改暂存起来git stash# 步骤2：暂存修改后，在本地新建分支（new_branch为新分支的名字）git checkout -b new_branch# 步骤3：将暂存的修改放到新建分支中git stash pop<h1 id="后续就是add-gt-push等操作了"><a href="#后续就是add-gt-push等操作了" class="headerlink" title="后续就是add -&gt; push等操作了"></a>后续就是add -&gt; push等操作了</h1></code></code></pre><h2 id="eedOF"><span class="ne-text">四丶其他</span></h2><h3 id="rJ3o6"><span class="ne-text"> [rejected] (would clobber existing tag)</span></h3><p id="uee7acf7c" class="ne-p"><span class="ne-text">vscode报错, 本地代码tags没有同步, 强制刷新本地标签</span></p><pre><code><code>git fetch --tags -f</code></code></pre></div>]]></content>
      
      
      <categories>
          
          <category> 计算机素养 </category>
          
          <category> Git和GitHub </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>GitHub Actions代码汇总</title>
      <link href="/blog/uwpbn0/"/>
      <url>/blog/uwpbn0/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h2 id="TEpBv"></h2><h2 id="MJWMh"><span class="ne-text">仓库文件夹备份</span></h2><pre><code>name: CIon: [watch]jobs:  build:    runs-on: ubuntu-latest    steps:    - uses: actions/checkout@v2    - name: 配置Git      run: |         git config --global user.name 'wztlink1013'         git config --global user.email '2550374815@qq.com'    - name: 在云端进行复制文件夹操作      env:        Github_Token: $&#123;&#123; secrets.TOKEN_GITHUBAPI &#125;&#125;      run: |         git clone https://$&#123;Github_Token&#125;@github.com/wztlink1013/website-source website-source        cd website-source        cp -r ./Secret文集/ ./backup/        git status        git add .        git commit -m &quot;backup&quot;        git push --force --quiet &quot;https://$&#123;Github_Token&#125;@github.com/wztlink1013/website-source&quot;  master:master</code></pre><h2 id="vFzCL"><span class="ne-text">博客CICD腾讯云函数</span></h2><h3 id="b6DTs"><span class="ne-text">Python2.7执行环境</span></h3><pre><code># -*- coding: utf8 -*-import requests<p>def main_handler(event, context):<br>    r = requests.post(&quot;<a href="https://api.github.com/repos/wztlink1013/Blog3.0/dispatches">https://api.github.com/repos/wztlink1013/Blog3.0/dispatches</a>&quot;,<br>    json=&#123;‘event_type’: &quot;run-it&quot;&#125;,<br>    headers = &#123;&quot;User-Agent&quot;:’curl/7.52.1’,<br>              ‘Content-Type’: ‘application/json’,<br>              ‘Accept’: ‘application/vnd.github.everest-preview+json’,<br>              ‘Authorization’: ‘token **********’&#125;)</p><pre><code>if r.status_code == 204:    return &amp;quot;This&#39;s OK!&amp;quot; else:    return r.status_code</code></pre><p></code></pre></p><h3 id="z3oLj"><span class="ne-text">触发器设置</span></h3><p id="340715b874c883b8bf4ab4cadc83964f" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1594789179624-938bb8c2-ac15-4ece-a5f1-001563e4f08b.png?x-oss-process=image%2Fresize%2Cw_1210" width="1210" id="OFWLm" class="ne-image"></p><h2 id="wQGMQ"><span class="ne-text">博客CICD阿里云函数</span></h2><h3 id="32bJh"><span class="ne-text">Python3执行环境</span></h3><pre><code># -*- coding: utf-8 -*-<p>import logging<br>import requests<br>OK = b’ok\n’</p><p>def handler(environ, start_response):<br>    status = ‘200 OK’<br>    response_headers = [(‘Content-type’, ‘text/plain’)]<br>    sync_yuque()<br>    start_response(status, response_headers)<br>    return [OK]</p><p>def sync_yuque():<br>    requests.post(&quot;<a href="https://api.github.com/repos/wztlink1013/Blog3.0/dispatches">https://api.github.com/repos/wztlink1013/Blog3.0/dispatches</a>&quot;,<br>    json=&#123;‘event_type’: &quot;run-it&quot;&#125;,<br>    headers=&#123;&quot;User-Agent&quot;:’curl/7.52.1’,<br>              ‘Content-Type’: ‘application/json’,<br>              ‘Accept’: ‘application/vnd.github.everest-preview+json’,<br>              ‘Authorization’: ‘token *********’&#125;)<br></code></pre></p><p id="c4750975c712ab801472e9f18b54d795" class="ne-p"><br></p></div>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
          <category> 博客技术 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CSS引入和特性</title>
      <link href="/blog/740ee349dcf540d24c44fd240dbbc87f/"/>
      <url>/blog/740ee349dcf540d24c44fd240dbbc87f/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="fdefba74db339c7fd0ecaff7bb6857f9" class="ne-p"><br></p><div data-type="info" class="ne-alert"><p id="495decaa10271bb0c9a022a3cc79761d" class="ne-p"><span class="ne-text">CSS(Cascading Style Sheets)  ，通常称为CSS样式表或层叠样式表（级联样式表）</span></p></div><h2 id="24FrL"><span class="ne-text">CSS引入</span></h2><h3 id="UoKmW"><span class="ne-text">行内式（内联样式）</span></h3><pre><code>&lt;div style=&quot;color: red; font-size: 12px;&quot;&gt;文字&lt;/div&gt;</code></pre><p id="00b1901eadd23b279f24eafe259a4dff" class="ne-p"><br></p><ul class="ne-ul"><li id="346f97a34544f45c62bd12163c65a4fe"><span class="ne-text">style其实就是标签的属性</span></li><li id="85c0e31687849e033d4fc0ecb89f6e82"><strong><span class="ne-text">样式属性和值中间是</span></strong><code class="ne-code"><strong><span class="ne-text">:</span></strong></code></li><li id="be284148ea165c28f1b88dc71b0405eb"><strong><span class="ne-text">多组属性值之间用</span></strong><code class="ne-code"><strong><span class="ne-text">;</span></strong></code><strong><span class="ne-text">隔开</span></strong></li></ul><h3 id="BpAyf"><span class="ne-text">内部样式表（内嵌样式表）</span></h3><pre><code>&lt;style&gt;     div &#123;         color: red;         font-size: 12px;     &#125;&lt;/style&gt;</code></pre><p id="0befc1eabdb80264b9398ff6c8ac457f" class="ne-p"><br></p><ul class="ne-ul"><li id="9ae5530eb2d81f718d91824d1b220fff"><span class="ne-text">style标签一般位于head标签中，理论可以放在HTML文档的任何地方。</span></li><li id="d194cef71b776f79abb0eb02ce612649"><span class="ne-text">type=&quot;text/css&quot;  在html5中可以省略。</span></li><li id="96f85dcb410ec04f58121aba0fcd1f52"><span class="ne-text">只能控制当前的页面</span></li></ul><p id="0b8dd88c882d1d2734a39de8a220bc96" class="ne-p"><br></p><h3 id="6zLrM"><span class="ne-text">外部样式表（外链式）</span></h3><pre><code>&lt;head&gt;  &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;css文件路径&quot;&gt;&lt;/head&gt;</code></pre><p id="33dac0e992c302fc6f8667490f4c4a88" class="ne-p"><br></p><ul class="ne-ul"><li id="44a5ceb547ff51487c1b7bb8544de922"><span class="ne-text">link 是个单标签</span></li><li id="55e4056ff3b3e903e62776df22bf1fa6"><span class="ne-text">link标签需要放在head头部标签中，并且指定link标签的三个属性</span></li></ul><table id="dJV4B" class="ne-table" style="width: 568px"><tbody><tr style="height: 33px"><td width="284"><p id="ua4d01f97" class="ne-p"><span class="ne-text">属性</span></p></td><td width="284"><p id="ud6129755" class="ne-p" style="text-align: left"><span class="ne-text">作用</span></p></td></tr><tr style="height: 33px"><td width="284"><p id="u33fed3c6" class="ne-p"><span class="ne-text">rel</span></p></td><td width="284"><p id="u62d4bbff" class="ne-p" style="text-align: left"><span class="ne-text">定义当前文档与被链接文档之间的关系，在这里需要指定为“stylesheet”，表示被链接的文档是一个样式表文件。</span></p></td></tr><tr style="height: 33px"><td width="284"><p id="u027f9b70" class="ne-p"><span class="ne-text">type</span></p></td><td width="284"><p id="u18454a24" class="ne-p" style="text-align: left"><span class="ne-text">定义所链接文档的类型，在这里需要指定为“text/CSS”，表示链接的外部文件为CSS样式表。我们都可以省略</span></p></td></tr><tr style="height: 33px"><td width="284"><p id="u96a50878" class="ne-p"><span class="ne-text">href</span></p></td><td width="284"><p id="ubf16cbe2" class="ne-p" style="text-align: left"><span class="ne-text">定义所链接外部样式表文件的URL，可以是相对路径，也可以是绝对路径。</span></p></td></tr></tbody></table><p id="05da89e6dedfb9a98e33f150e3fc46f4" class="ne-p"><br></p><p id="8fd966ac37481bdb0da195ec04b195d9" class="ne-p"><br></p><p id="2a8b984809bc2b05952f3cd16f264dcc" class="ne-p"><br></p><h2 id="51lsA"><span class="ne-text">CSS三大特性</span></h2><h3 id="giaIL"><span class="ne-text">层叠性</span></h3><p id="c75c2a8a436614456498c69871257578" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611551959470-031c2889-70e9-4982-96f9-9c144e5051b2.png" width="603" id="V5gO3" class="ne-image"></p><ul class="ne-ul"><li id="9b936beac8f8c5c2a4912079a33e636f"><span class="ne-text">概念：<br /></span><span class="ne-text">所谓层叠性是指多种CSS样式的叠加。<br /></span><span class="ne-text">是浏览器处理冲突的一个能力,如果一个属性通过两个相同选择器设置到同一个元素上，那么这个时候一个属性就会将另一个属性层叠掉</span></li><li id="f4a2737f014a7524f1d83f2a7629f65a"><span class="ne-text">原则：</span></li></ul><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="cb32e2604831a28dd7e26b601cc21a44"><span class="ne-text">样式冲突，遵循的原则是</span><strong><span class="ne-text">就近原则。</span></strong><span class="ne-text"> 那个样式离着结构近，就执行那个样式。</span></li><li id="75f375d8e165210ce53fc64ef9cb44cf"><span class="ne-text">样式不冲突，不会层叠</span></li></ul></ul><pre><code>CSS层叠性最后的执行口诀：  长江后浪推前浪，前浪死在沙滩上。</code></pre><p id="9b072339abd4252e59ab31ce39e5dc03" class="ne-p"><br></p><h3 id="GZ9NO"><span class="ne-text">继承性</span></h3><p id="cedc6417f3c8c35e1e6dddba608a4aa2" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611551970799-56adba75-8847-4db1-a411-148ff22f57ac.png" width="598" id="FlrFw" class="ne-image"></p><ul class="ne-ul"><li id="e0ac11b6deb5ed432cd57967edff1a85"><span class="ne-text">概念：<br /></span><span class="ne-text">子标签会继承父标签的某些样式，如文本颜色和字号。<br /></span><span class="ne-text">想要设置一个可继承的属性，只需将它应用于父元素即可。</span></li></ul><p id="60e39e3acb05b2a39cc05336d31c401a" class="ne-p"><span class="ne-text">简单的理解就是：  子承父业。</span></p><ul class="ne-ul"><li id="3df2fd3f70ab542f40f8149f364ee60f"><strong><span class="ne-text">注意</span></strong><span class="ne-text">：</span></li></ul><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="52a1e97a676230bc7f9be591a50ff054"><span class="ne-text">恰当地使用继承可以简化代码，降低CSS样式的复杂性。比如有很多子级孩子都需要某个样式，可以给父级指定一个，这些孩子继承过来就好了。</span></li><li id="61c91b2e2164f1507e25bf771219ae37"><span class="ne-text">子元素可以继承父元素的样式（</span><strong><span class="ne-text">text-，font-，line-这些元素开头的可以继承，以及color属性</span></strong><span class="ne-text">）</span></li></ul></ul><h3 id="9JW0v"><span class="ne-text">优先级</span></h3><p id="d5bf31c8bfda9ebb17681d1086a02778" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611551983122-6a6e2212-c740-40f6-bfa1-3b66ae0a9c46.png" width="599" id="ATZOo" class="ne-image"></p><ul class="ne-ul"><li id="8ac00d0c2b65e58c170ff7d13c205e5e"><span class="ne-text">概念：定义CSS样式时，经常出现两个或更多规则应用在同一元素上，此时，</span></li></ul><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="69c355c81d518cedce554ec70c247f22"><span class="ne-text">选择器相同，则执行层叠性</span></li><li id="c7756aa0fb2c8835a985705a2b43bf29"><span class="ne-text">选择器不同，就会出现优先级的问题。</span></li></ul></ul><div data-type="info" class="ne-alert"><p id="4f4ad24f4169c6ca19dfaeab9a5997e6" class="ne-p"><span class="ne-text">权重计算公式</span></p></div><p id="c37427b6372485819bad12420b198c43" class="ne-p"><span class="ne-text">关于CSS权重，我们需要一套计算公式来去计算，这个就是 CSS Specificity（特殊性）</span></p><table id="LanbR" class="ne-table" style="width: 750px"><tbody><tr style="height: 33px"><td width="375"><p id="ubd4da0a3" class="ne-p"><span class="ne-text">标签选择器</span></p></td><td width="375"><p id="ub4a11b61" class="ne-p"><span class="ne-text">计算权重公式</span></p></td></tr><tr style="height: 33px"><td width="375"><p id="uf1230f80" class="ne-p"><span class="ne-text">继承或者 *</span></p></td><td width="375"><p id="ud3c891b7" class="ne-p"><span class="ne-text">0,0,0,0</span></p></td></tr><tr style="height: 33px"><td width="375"><p id="uc3e3dbd5" class="ne-p"><span class="ne-text">每个元素（标签选择器）</span></p></td><td width="375"><p id="ubc7b5f83" class="ne-p"><span class="ne-text">0,0,0,1</span></p></td></tr><tr style="height: 33px"><td width="375"><p id="u9b847a1d" class="ne-p"><span class="ne-text">每个类，伪类</span></p></td><td width="375"><p id="ubc56155d" class="ne-p"><span class="ne-text">0,0,1,0</span></p></td></tr><tr style="height: 33px"><td width="375"><p id="ue6747e33" class="ne-p"><span class="ne-text">每个ID</span></p></td><td width="375"><p id="ub501574b" class="ne-p"><span class="ne-text">0,1,0,0</span></p></td></tr><tr style="height: 33px"><td width="375"><p id="ufff1b145" class="ne-p"><span class="ne-text">每个行内样式 style=&quot;&quot;</span></p></td><td width="375"><p id="u09d95f5d" class="ne-p"><span class="ne-text">1,0,0,0</span></p></td></tr><tr style="height: 33px"><td width="375"><p id="u24394b91" class="ne-p"><span class="ne-text">每个!important  重要的</span></p></td><td width="375"><p id="uf51c7951" class="ne-p"><span class="ne-text">∞ 无穷大</span></p></td></tr></tbody></table><ul class="ne-ul"><li id="195cf52ec1b403760c2c716841873efb"><span class="ne-text">值从左到右，左面的最大，一级大于一级，数位之间没有进制，级别之间不可超越。</span></li><li id="e0a7f97ac051063e30dcd2a168619ddd"><span class="ne-text">关于CSS权重，我们需要一套计算公式来去计算，这个就是 CSS Specificity（特殊性）</span></li><li id="e2ff8772c445471d7552d330ead9d526"><span class="ne-text">div {<br /></span><span class="ne-text">color: pink!important;<br /></span><span class="ne-text">}</span></li></ul><div data-type="info" class="ne-alert"><p id="1d1aefe9d3ebc0339692d3bb23b0a9c8" class="ne-p"><span class="ne-text">权重叠加</span></p></div><p id="38764e64e5d27976e38b96a54b47b332" class="ne-p"><span class="ne-text">我们经常用交集选择器，后代选择器等，是有多个基础选择器组合而成，那么此时，就会出现权重叠加。</span></p><p id="95a78de3cad8abec942a19d04f98d5b4" class="ne-p"><span class="ne-text">就是一个简单的加法计算</span></p><ul class="ne-ul"><li id="4da9a9baefce08f8e11c1b23c7f3b47e"><span class="ne-text">div ul  li   ------&gt;      0,0,0,3</span></li><li id="9a61760b700deb5690eb1d1aae4f256d"><span class="ne-text">.nav ul li   ------&gt;      0,0,1,2</span></li><li id="026d3e82d2036f8c7f398b351ce4e5ae"><span class="ne-text">a:hover      -----—&gt;   0,0,1,1</span></li><li id="569bc6beccece02a8656ad749e55f739"><span class="ne-text">.nav a       ------&gt;      0,0,1,1</span></li></ul><p id="43d873c80618908922e2dcca359cca94" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/jpg/1484158/1611549555499-d752a9dc-33fc-4649-95b6-58b25d08ef80.jpg" width="31" id="XMn3N" class="ne-image"><span class="ne-text"> 注意：</span></p><ol class="ne-ol"><li id="54f8fa7ec85b350def6b05d6483434c9"><span class="ne-text">数位之间没有进制 比如说： 0,0,0,5 + 0,0,0,5 =0,0,0,10 而不是 0,0, 1, 0， 所以不会存在10个div能赶上一个类选择器的情况。</span></li></ol><div data-type="info" class="ne-alert"><p id="45a5ae561bbb5c2001543cbb8125aa6a" class="ne-p"><span class="ne-text">继承的权重是0</span></p></div><p id="48deb4ae5ac96c3a9d565e179f4b2243" class="ne-p"><span class="ne-text">这个不难，但是忽略很容易绕晕。其实，我们修改样式，一定要看该标签有没有被选中。</span></p><p id="c40c86909e7c1bb487965eceaf0d6971" class="ne-p"><span class="ne-text">1） 如果选中了，那么以上面的公式来计权重。谁大听谁的。</span></p><p id="668ca512a339921e5ae0c626b2d530b9" class="ne-p"><span class="ne-text">2） 如果没有选中，那么权重是0，因为继承的权重为0.</span></p></div>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
          <category> HTML+CSS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>《世界上所有的夜晚》——那段难忘的谈吐</title>
      <link href="/essay/c47f3d9a749fd0229277f9e9604e69a2/"/>
      <url>/essay/c47f3d9a749fd0229277f9e9604e69a2/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="ud8b3f1df" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1622165460883-a7b33b3d-8426-46e7-ade7-e603c065322e.jpeg" width="135" id="uedac2836" class="ne-image"></p><p id="ubc8be0f2" class="ne-p" style="text-align: center"><br></p><p id="u30d31720" class="ne-p" style="text-align: left"><span class="ne-text" style="color: #111111; font-size: 14px">每本书，总会有那么一段让你记忆难忘。最难忘的是和蒋百嫂酒后那段谈吐，夜半作者打算回旅馆，却听见轰隆隆的响声，当看见冰柜里的那具尸体之后，仿佛像是探照灯照亮了一个人不愿流露的内心，悲凉，同情。每个人都有属于自己的夜晚，心灵寄居在此，有的看似洒脱却也痛苦无奈。</span></p><p id="u9fd7c745" class="ne-p" style="text-align: left"><span class="ne-text" style="color: #111111; font-size: 14px"></span></p><p id="u3760b15d" class="ne-p" style="text-align: left"><span class="ne-text" style="color: #111111; font-size: 14px">看完这本书，我才渐渐了解迟子建这个作家，不过非常尴尬，在此之前我一直以为迟子建是位男作家····作者真的是一个善于观察的生活记录者，很喜欢那样轻快的语言，迟子建是在我读书时期，让我喜欢上文学的人之一，高中那会，就喜欢蹲在书店的书架后面看他写的书，看完之后，心情甚是愉悦~～～回忆啊，那个下午放学到晚自习那段一个小时，总喜欢跑书店看一些神神叨叨的书</span></p><p id="ubf6a34bc" class="ne-p" style="text-align: left"><span class="ne-text" style="color: #111111; font-size: 14px"></span></p><p id="u0c2db998" class="ne-p"><span class="ne-text" style="color: #111111; font-size: 14px">每个人都有属于自己的夜晚，每个人都有属于自己的回忆 :-）</span></p><p id="u94367c57" class="ne-p"><br></p><hr id="zWNXp" class="ne-hr"><p id="u910ad56d" class="ne-p"><br></p><p id="u29e8bd35" class="ne-p"><span class="ne-text">《世界上所有的夜晚》迟子建的一本比较短的小说，这部小说，也是在那期间第一本我一天之内看完的一本小说，很多时候，我总是想起煤矿镇的那个村庄的人，事实上，那都是我们身边的人，也是那本书我内心深深的感知，这世上有很多不幸的人，这世上不止一个夜晚，有无数个人人牵挂的夜晚，这世上又只有一个夜晚，那个独自存在的灵魂的夜晚……</span></p><p id="uf4a332de" class="ne-p"><br></p><p id="u96555e86" class="ne-p"><br></p><hr id="WObKJ" class="ne-hr"><p id="u6b2bc270" class="ne-p"><br></p><p id="u506a2f5e" class="ne-p"><span class="ne-text">想想以前的一些悠闲经历， 上课偷偷式看小说 、备考期间，自我欺骗/麻痹式看小说 ，大学依旧是上课老喜欢在全班同学都认真听讲而我坐在后排靠窗角落看小说</span><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1622165717851-7436873d-a34b-48b7-a8fa-d32e45eb7e4b.jpeg" width="51" id="HxzJ4" class="ne-image"></p><p id="uf8a684f2" class="ne-p"><br></p><p id="uc20af8ee" class="ne-p"><br></p><p id="uc58eea44" class="ne-p"><span class="ne-text">然而现在， 快节奏的日常似乎霸占生活的全部 ，身边有这么优秀的环境，我忘却了曾经的那一丝快感……</span></p><p id="u5a4c0257" class="ne-p"><br></p><p id="ude9c354b" class="ne-p"><span class="ne-text">其实，生活本可以有一丝轻快，不用太过追求什么</span></p><p id="u33098461" class="ne-p"><br></p></div>]]></content>
      
      
      <categories>
          
          <category> 阅读 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>至暗之路</title>
      <link href="/essay/ew2l6r/"/>
      <url>/essay/ew2l6r/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content-editor-core lake-engine lake-typography-classic" data-lake-element="root" data-selection-undefined="%7B%22path%22%3A%5B%5B12%2C0%2C5%5D%2C%5B12%2C0%2C5%5D%5D%2C%22active%22%3Atrue%7D"><p data-lake-id="84fca8abe9d50557666319033f6713e2" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">一个人如若是他很强，一或者说在别人眼中看起来很强，那么他一定是有着他自己的一段至暗时光。</p><p data-lake-id="7c5ac138d2b9271acb9a6c4afb002989" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="c70128d04575f817fb31a00f159f4aaa" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">我们总是不喜欢往回看。往回看有两种情况，一种是你的过往是让你愉悦的，让你充满开心快乐，还有一种就是让你哽咽，不想多言，或是说，那段时光虽然让你收获很多，但是它并非是你很想经历的。至暗时光的确可以让自己变得更强，但是凡事你能得到就必然有舍弃，我觉得那段至暗时光让我舍弃的就是与他人的人情味。</p><p data-lake-id="c8a095e88296ed380c3d65eef501fb34" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="3294b573ac4ae1e75c99048de5494474" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">我的确很恨，恨为什么是我经受那种环境，一个本不是第一环境的人，却也落得个第一环境的人，就像是内壁中有遗留下的异世界的人一样，很愤懑，却也不得抒情。我觉得这可能就是古时候的诗人那般抒情吧，失意，惆怅，但唯一与身边人不同的就是，不会迷茫，内心却是异常的笃定，于是乎他开始变得与周围的人都不太一样，他开始学会跳出内壁，内壁下的人们就仿佛是用来衬托这个本不该落下的内壁之外的人，但，就像是那片沙漠尽头的那般高墙一般，他的落下，是因为他在他那个文明下触及到他不应该触及的所谓的“法律”。</p><p data-lake-id="89c53d091225673f5fafb8b50d54b47a" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="62c89cf900593957f41bf1b2d0c90bbc" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">“什么都不舍弃，就什么改变不了”</p><p data-lake-id="6b2f189f9ea9fbc97e7de0629176b65c" style="text-align: right; font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">——爱尔敏</p><p data-lake-id="6a7344e9eec3e23cd6843f8ba2c48055" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="8222eafcb027ff2688393174fc37470b" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">于是乎，他开始讨厌内壁下的种种，他觉得，在他那个文明，这不应该是他应该所接触的。他觉得，他不是内壁下的人们，他应该回到他所觉得的那个高级文明。所以，他的那种与世人抵触，让他踏上至暗时光，在此有必要提醒一点，至暗，不一定是贬义词，更多的时候，它是一种中性词。</p><p data-lake-id="351d69dfa1ae7a1aed67e18407434dbf" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="71a2b2a09b2d030f9a9cb466ef309776" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">“错的不是我，而是这个世界”</p><p data-lake-id="89dd753afe5dfd31fbb1dca994e19223" style="text-align: right; font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">——金木研</p><p data-lake-id="79a4b4832f341c7cde8a392400d93bbb" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="a68844bf16b3d944665ccdc664b4159f" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="3c75f8b7ba1c11af2289ca086bee2f9e" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p></div>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>GitHub Actions+语雀+serverless云函数实现hexo自动化部署</title>
      <link href="/blog/vyeuk3/"/>
      <url>/blog/vyeuk3/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h2 id="4XWuu"><span class="ne-text">一、整体思路</span></h2><p id="4016379116a379d18c4872818f1562f6" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1610002276789-6c7bf0a3-f39b-4a27-a493-01c2e579ec87.jpeg" width="2062" id="Rnqi1" class="ne-image"></p><p id="693f2b2afca1c9aa5067a9e02b334f9a" class="ne-p"><span class="ne-text"></span></p><ul class="ne-ul"><li id="09333828093ed067f8cf43b2529f880b"><span class="ne-text">【1】利用</span><code class="ne-code"><span class="ne-text">npm</span></code><span class="ne-text">插件</span><code class="ne-code"><span class="ne-text">yuque-hexo-lyrics</span></code><span class="ne-text">将语雀云端的文章同步到博客源码</span><code class="ne-code"><span class="ne-text">source/_posts</span></code><span class="ne-text">文件夹下。</span></li><li id="f98575c94e60b37a4c4ab20e038d2d4a"><span class="ne-text">【2】再利用</span><code class="ne-code"><span class="ne-text">GitHub Actions</span></code><span class="ne-text">自动化部署将GitHub私有仓库（</span><code class="ne-code"><span class="ne-text">website</span></code><span class="ne-text">）的博客源文件编译成静态博客文件并部署push到静态博客仓库（</span><code class="ne-code"><span class="ne-text">wztlink1013.github.io</span></code><span class="ne-text">）下。</span></li></ul><p id="66dea340fdf3da51b3e3b42e36fd70aa" class="ne-p"><br></p><div data-type="danger" class="ne-alert"><p id="1da0b75f62048cb4f4b43f7af57040f0" class="ne-p"><span class="ne-text">但是以上【1】【2】两种方式并不能解决语雀一发布文章就触发GitHub源码仓库的GitHub Actions</span></p></div><p id="3f3fc78a27c6d2caaf3dca2614c8b662" class="ne-p"><br></p><ul class="ne-ul"><li id="22924826abb1ece2bead19ffb295172c"><span class="ne-text">【3】所以需要中间</span><code class="ne-code"><span class="ne-text">TencentCloud</span></code><span class="ne-text">云函数/</span><code class="ne-code"><span class="ne-text">Aliyun</span></code><span class="ne-text">云函数，云函数的作用就是，语雀文章一经正式发布就触发云函数，从而云函数再触发GitHub私有的源码仓库下的</span><code class="ne-code"><span class="ne-text">GitHub Actions</span></code><span class="ne-text">达到编译静态博客的效果。</span></li></ul><p id="u91493ea8" class="ne-p"><span class="ne-text"></span></p><h2 id="eaGqv"><span class="ne-text">二、网站源文件配置</span></h2><div class="ne-quote"><p id="e5d00f608777a6cde25ae914395657e3" class="ne-p"><span class="ne-text">插件npm地址【暂未GitHub开源】：</span><a href="https://www.npmjs.com/package/yuque-hexo-lyrics" data-href="https://www.npmjs.com/package/yuque-hexo-lyrics" target="_blank" class="ne-link"><span class="ne-text">https://www.npmjs.com/package/yuque-hexo-lyrics</span></a></p></div><h3 id="JEJYA"><span class="ne-text">yuque-hexo-lyrics插件使用</span></h3><div data-type="info" class="ne-alert"><p id="5f4d6afaed5ca4bb0267ab435bef2350" class="ne-p"><span class="ne-text">本人基于yuque-hexo项目修改的进阶插件</span></p></div><p id="1161c5b8fba91d60db113e23742b67f6" class="ne-p"><span class="ne-text"></span></p><div class="ne-quote"><p id="b3a80d03dcc9e48b50664d0230755a46" class="ne-p"><span class="ne-text">【1】在开发环境当中下载插件（全局安装）</span></p></div><pre><code>npm i -g yuque-hexo-lyrics</code></pre><div class="ne-quote"><p id="9635a3cf7afa8c353a1727941c51f828" class="ne-p"><span class="ne-text">【2】相关hexo命令</span></p></div><pre><code>yuque-hexo-lyrics clean # 清缓存删除yuque文件夹 删除yuque.json文件(更新之后的插件不删除yuque.json)yuque-hexo-lyrics sync # 从云端拉取到本地</code></pre><div class="ne-quote"><p id="9f6540e268430a36a567ca9563355a3a" class="ne-p"><span class="ne-text">【3】特别需要注意的是：开发环境语雀Token变量的传入</span></p></div><p id="b7022720188d7016f5822e3b3cb9f145" class="ne-p"><span class="ne-text">语雀为了防止用户恶意多次拉取数据，出于对知识库安全性的调整，使用第三方 API 访问知识库，需要传入环境变量 </span><code class="ne-code"><span class="ne-text">YUQUE_TOKEN</span></code><span class="ne-text">，如果是本地使用建议使用环境变量，也可以是终端的方式输入</span><span class="ne-text">。</span></p><p id="99e2e3be707b30e19510c1232c92a67d" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1594788656022-fb5e7959-fa2a-4418-911b-773e3674afb8.png" width="484" id="vrXpA" class="ne-image"></p><p id="687a270681e92edb8f306ee46feebc8c" class="ne-p" style="text-align: left"><span class="ne-text">如果是在</span><code class="ne-code"><span class="ne-text">GitHub Actions</span></code><span class="ne-text">里面的环境执行</span><code class="ne-code"><span class="ne-text">yuque-hexo-lyrics sync</span></code><span class="ne-text">命令的时候，通过如下命令传入语雀的</span><code class="ne-code"><span class="ne-text">token</span></code></p><pre><code>YUQUE_TOKEN=$&#123;&#123; secrets.YUQUE_TOKEN &#125;&#125; yuque-hexo sync</code></pre><div class="ne-quote"><p id="a136077158d8c31393ed83ee1bed5e61" class="ne-p"><span class="ne-text">【4】最后的配置样式（本插件可以同时下载多个知识库）</span></p></div><pre><code>  &quot;yuqueConfig_blog&quot;: &#123;    &quot;baseUrl&quot;: &quot;https://www.yuque.com/api/v2&quot;,    &quot;login&quot;: &quot;wztlink1013&quot;,    &quot;repo&quot;: &quot;blog&quot;,    &quot;postPath&quot;: &quot;source/_posts/blog&quot;,    &quot;cachePath&quot;: &quot;yuque_blog.json&quot;,    &quot;mdNameFormat&quot;: &quot;slug&quot;,    &quot;onlyPublished&quot;: false,    &quot;onlyPublic&quot;: false,    &quot;adapter&quot;: &quot;hexo&quot;,    &quot;timeout&quot;: &quot;150s&quot;  &#125;,  &quot;yuqueConfig_essay&quot;: &#123;    &quot;baseUrl&quot;: &quot;https://www.yuque.com/api/v2&quot;,    &quot;login&quot;: &quot;wztlink1013&quot;,    &quot;repo&quot;: &quot;essay&quot;,    &quot;postPath&quot;: &quot;source/_posts/essay&quot;,    &quot;cachePath&quot;: &quot;yuque_essay.json&quot;,    &quot;mdNameFormat&quot;: &quot;slug&quot;,    &quot;onlyPublished&quot;: false,    &quot;onlyPublic&quot;: false,    &quot;adapter&quot;: &quot;hexo&quot;,    &quot;timeout&quot;: &quot;150s&quot;  &#125;,  &quot;yuqueConfig_dsal&quot;: &#123;    &quot;baseUrl&quot;: &quot;https://www.yuque.com/api/v2&quot;,    &quot;login&quot;: &quot;wztlink1013&quot;,    &quot;repo&quot;: &quot;dsal&quot;,    &quot;postPath&quot;: &quot;source/_posts/blog&quot;,    &quot;cachePath&quot;: &quot;yuque_dsal.json&quot;,    &quot;mdNameFormat&quot;: &quot;slug&quot;,    &quot;onlyPublished&quot;: false,    &quot;onlyPublic&quot;: false,    &quot;adapter&quot;: &quot;hexo&quot;,    &quot;timeout&quot;: &quot;150s&quot;  &#125;,  &quot;yuqueConfig_javascript&quot;: &#123;    &quot;baseUrl&quot;: &quot;https://www.yuque.com/api/v2&quot;,    &quot;login&quot;: &quot;wztlink1013&quot;,    &quot;repo&quot;: &quot;javascript&quot;,    &quot;postPath&quot;: &quot;source/_posts/blog&quot;,    &quot;cachePath&quot;: &quot;yuqueConfig_javascript.json&quot;,    &quot;mdNameFormat&quot;: &quot;slug&quot;,    &quot;onlyPublished&quot;: false,    &quot;onlyPublic&quot;: false,    &quot;adapter&quot;: &quot;hexo&quot;,    &quot;timeout&quot;: &quot;150s&quot;  &#125;,  &quot;scripts&quot;: &#123;    &quot;build&quot;: &quot;hexo generate&quot;,    &quot;clean&quot;: &quot;hexo clean&quot;,    &quot;deploy&quot;: &quot;hexo deploy&quot;,    &quot;server&quot;: &quot;hexo server&quot;  &#125;</code></pre><p id="2e220e29934e4caab7fbf25163b5b4df" class="ne-p"><span class="ne-text">更详细使用参考官方</span><a href="https://www.npmjs.com/package/yuque-hexo-lyrics" data-href="https://www.npmjs.com/package/yuque-hexo-lyrics" target="_blank" class="ne-link"><span class="ne-text">官方仓库</span></a><span class="ne-text">。</span></p><h3 id="rgoKe"><span class="ne-text">GitHub Actions文件的配置</span></h3><p id="a09e1a4fc7ecbc2b448cb31a3ad0a4d7" class="ne-p"><span class="ne-text">在博客源文件夹下新建如下</span><span class="ne-text">GitHub Actions</span><span class="ne-text">文件</span></p><p id="7a6c247e4896fc4886a41b459033f746" class="ne-p"><code class="ne-code"><span class="ne-text">.github/workflows/main.yml</span></code><span class="ne-text"> </span></p><p id="8b2fb837e7f745e7c16e2910e3e9e4d3" class="ne-p"><br></p><div class="ne-quote"><p id="5fa3cfd52518e36e13ac83a1fb87d460" class="ne-p"><span class="ne-text">文件内容配置如下</span></p></div><pre><code># workflow namename: website to wztlink1013.github.io CI/CD<p>on: [repository_dispatch, watch]</p><p>jobs:<br>  Deploy-Pages:<br>    name: website to wztlink1013.github.io<br>    runs-on: ubuntu-latest</p><pre><code>steps:# check it to your workflow can access it# from: https://github.com/actions/checkout- name: Checkout Repository master branch  uses: actions/checkout@main # from: https://github.com/actions/setup-node  - name: Setup Node.js 10.x   uses: actions/setup-node@main  with:    node-version: &amp;quot;10.x&amp;quot;- name: add Git infomations  run: |     git config --global user.name &#39;$&#123;&#123;secrets.GIT_NAME&#125;&#125;&#39;     git config --global user.email &#39;$&#123;&#123;secrets.GIT_EMAIL&#125;&#125;&#39;- name: submit commit infomations  run: |    git log --pretty=format:&amp;quot;%s from Github Actions at `date +&amp;quot;%Y-%m-%d %H:%M:%S&amp;quot;`&amp;quot; --date=short -n 1  &amp;gt; commit-message.log- name: npm istall hexo-cli、yuque-hexo、*  env:    YUQUE_TOKEN: $&#123;&#123; secrets.YUQUE_TOKEN &#125;&#125;  run: |    npm install hexo-cli -g    npm install yuque-hexo-lyrics -g    npm install- name: generate articles  run: |    hexo clean    yuque-hexo-lyrics clean    YUQUE_TOKEN=$&#123;&#123; secrets.YUQUE_TOKEN &#125;&#125; yuque-hexo-lyrics sync    hexo generate     - name: push wztlink1013.github.io repository  env:    Github_Pages: github.com/wztlink1013/wztlink1013.github.io    Github_Token: $&#123;&#123; secrets.token_GithubAPI &#125;&#125;  run: |      git clone https://$&#123;Github_Token&#125;@$&#123;Github_Pages&#125; .github_pages    mv .github_pages/.git/ ./public/    cd ./public/    git add .    git commit -F ../commit-message.log    git push --force --quiet &amp;quot;https://$&#123;Github_Token&#125;@$&#123;Github_Pages&#125;&amp;quot; master:master    </code></pre><p></code></pre></p><h2 id="CykMS"><span class="ne-text">三、Serverless云函数配置</span></h2><h3 id="C99fO"><span class="ne-text">腾讯云serverless</span></h3><div data-type="info" class="ne-alert"><p id="12afe219166d95e94c34e1e96aaf4baf" class="ne-p"><span class="ne-text">python2.7的配置</span></p></div><pre><code># -*- coding: utf8 -*-import requests<p>def main_handler(event, context):<br>    r = requests.post(&quot;<a href="https://api.github.com/repos/wztlink1013/website/dispatches">https://api.github.com/repos/wztlink1013/website/dispatches</a>&quot;,<br>    json=&#123;‘event_type’: &quot;run-it&quot;&#125;,<br>    headers = &#123;&quot;User-Agent&quot;:’curl/7.52.1’,<br>              ‘Content-Type’: ‘application/json’,<br>              ‘Accept’: ‘application/vnd.github.everest-preview+json’,<br>              ‘Authorization’: ‘token ***********’&#125;)</p><pre><code>if r.status_code == 204:    return &amp;quot;This&#39;s OK!&amp;quot; else:    return r.status_code</code></pre><p></code></pre></p><div data-type="info" class="ne-alert"><p id="9ac47632c743de995059f4b422cb26c9" class="ne-p"><span class="ne-text">触发器的设置</span></p></div><p id="358567e27aa5f5c43c465d6744659c9d" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1594789179624-938bb8c2-ac15-4ece-a5f1-001563e4f08b.png" width="605" id="zNnuw" class="ne-image"></p><h3 id="aONRK"><span class="ne-text">阿里云serverless</span></h3><p id="8d5a1bbfadec86b9382b91a1c81b8769" class="ne-p"><span class="ne-text">记录一下Hexo自动化部署过程中阿里云平台的原函数配置的python代码</span></p><div data-type="info" class="ne-alert"><p id="33dd79d73dc15f09e7f8fa5e5a8d5ca3" class="ne-p"><span class="ne-text">python2.7</span></p></div><pre><code># -*- coding: utf-8 -*-import loggingimport requests<h1 id="To-enable-the-initializer-feature-https-help-aliyun-com-document-detail-158208-html"><a href="#To-enable-the-initializer-feature-https-help-aliyun-com-document-detail-158208-html" class="headerlink" title="To enable the initializer feature (https://help.aliyun.com/document_detail/158208.html)"></a>To enable the initializer feature (<a href="https://help.aliyun.com/document_detail/158208.html">https://help.aliyun.com/document_detail/158208.html</a>)</h1><h1 id="please-implement-the-initializer-function-as-below："><a href="#please-implement-the-initializer-function-as-below：" class="headerlink" title="please implement the initializer function as below："></a>please implement the initializer function as below：</h1><h1 id="def-initializer-context"><a href="#def-initializer-context" class="headerlink" title="def initializer(context):"></a>def initializer(context):</h1><h1 id="logger-logging-getLogger"><a href="#logger-logging-getLogger" class="headerlink" title="logger = logging.getLogger()"></a>logger = logging.getLogger()</h1><h1 id="logger-info-‘initializing’"><a href="#logger-info-‘initializing’" class="headerlink" title="logger.info(‘initializing’)"></a>logger.info(‘initializing’)</h1><p>def handler(event, context):</p><h1 id="logger-logging-getLogger-1"><a href="#logger-logging-getLogger-1" class="headerlink" title="logger = logging.getLogger()"></a>logger = logging.getLogger()</h1><h1 id="logger-info-‘hello-world’"><a href="#logger-info-‘hello-world’" class="headerlink" title="logger.info(‘hello world’)"></a>logger.info(‘hello world’)</h1><h1 id="return-‘hello-world’"><a href="#return-‘hello-world’" class="headerlink" title="return ‘hello world’"></a>return ‘hello world’</h1><pre><code>r = requests.post(&amp;quot;https://api.github.com/repos/wztlink1013/blog-source/dispatches&amp;quot;,json=&#123;&#39;event_type&#39;: &amp;quot;run-it&amp;quot;&#125;,headers = &#123;&amp;quot;User-Agent&amp;quot;:&#39;curl/7.52.1&#39;,          &#39;Content-Type&#39;: &#39;application/json&#39;,          &#39;Accept&#39;: &#39;application/vnd.github.everest-preview+json&#39;,          &#39;Authorization&#39;: &#39;token f43964836a33dce244385bc303c8c20adc1bd52194&#39;&#125;)if r.status_code == 204:    return &amp;quot;This&#39;s OK!&amp;quot; else:    return r.status_code</code></pre><h1 id="coding-utf8"><a href="#coding-utf8" class="headerlink" title="# -- coding: utf8 --"></a># -<em>- coding: utf8 -</em>-</h1><h1 id="import-requests"><a href="#import-requests" class="headerlink" title="import requests"></a>import requests</h1><h1 id="def-main-handler-event-context"><a href="#def-main-handler-event-context" class="headerlink" title="def main_handler(event, context):"></a>def main_handler(event, context):</h1><h1 id="r-requests-post-quot-https-api-github-com-repos-wztlink1013-blog-source-dispatches-quot"><a href="#r-requests-post-quot-https-api-github-com-repos-wztlink1013-blog-source-dispatches-quot" class="headerlink" title="r = requests.post(&quot;https://api.github.com/repos/wztlink1013/blog-source/dispatches&quot;,"></a>r = requests.post(&quot;<a href="https://api.github.com/repos/wztlink1013/blog-source/dispatches">https://api.github.com/repos/wztlink1013/blog-source/dispatches</a>&quot;,</h1><h1 id="json-‘event-type’-quot-run-it-quot"><a href="#json-‘event-type’-quot-run-it-quot" class="headerlink" title="json={‘event_type’: &quot;run-it&quot;},"></a>json={‘event_type’: &quot;run-it&quot;},</h1><h1 id="headers-quot-User-Agent-quot-’curl-7-52-1’"><a href="#headers-quot-User-Agent-quot-’curl-7-52-1’" class="headerlink" title="headers = {&quot;User-Agent&quot;:’curl/7.52.1’,"></a>headers = {&quot;User-Agent&quot;:’curl/7.52.1’,</h1><h1 id="‘Content-Type’-‘application-json’"><a href="#‘Content-Type’-‘application-json’" class="headerlink" title="‘Content-Type’: ‘application/json’,"></a>‘Content-Type’: ‘application/json’,</h1><h1 id="‘Accept’-‘application-vnd-github-everest-preview-json’"><a href="#‘Accept’-‘application-vnd-github-everest-preview-json’" class="headerlink" title="‘Accept’: ‘application/vnd.github.everest-preview+json’,"></a>‘Accept’: ‘application/vnd.github.everest-preview+json’,</h1><h1 id="‘Authorization’-‘token-144a87bd45e62ff1cf30dc18880787917bc7865417’"><a href="#‘Authorization’-‘token-144a87bd45e62ff1cf30dc18880787917bc7865417’" class="headerlink" title="‘Authorization’: ‘token 144a87bd45e62ff1cf30dc18880787917bc7865417’})"></a>‘Authorization’: ‘token 144a87bd45e62ff1cf30dc18880787917bc7865417’})</h1><h1 id="if-r-status-code-204"><a href="#if-r-status-code-204" class="headerlink" title="if r.status_code == 204:"></a>if r.status_code == 204:</h1><h1 id="return-quot-This’s-OK-quot"><a href="#return-quot-This’s-OK-quot" class="headerlink" title="return &quot;This’s OK!&quot;"></a>return &quot;This’s OK!&quot;</h1><h1 id="else"><a href="#else" class="headerlink" title="else:"></a>else:</h1><h1 id="return-r-status-code"><a href="#return-r-status-code" class="headerlink" title="return r.status_code"></a>return r.status_code</h1><p></code></pre></p><div data-type="info" class="ne-alert"><p id="c1219572cef3387be9ec32898bbfe0e5" class="ne-p"><span class="ne-text">python3版本</span></p></div><pre><code># -*- coding: utf-8 -*-<p>import logging<br>import requests<br>OK = b’ok\n’</p><p>def handler(environ, start_response):<br>    status = ‘200 OK’<br>    response_headers = [(‘Content-type’, ‘text/plain’)]<br>    sync_yuque()<br>    start_response(status, response_headers)<br>    return [OK]</p><p>def sync_yuque():<br>    requests.post(&quot;<a href="https://api.github.com/repos/wztlink1013/Blog3.0/dispatches">https://api.github.com/repos/wztlink1013/Blog3.0/dispatches</a>&quot;,<br>    json=&#123;‘event_type’: &quot;run-it&quot;&#125;,<br>    headers=&#123;&quot;User-Agent&quot;:’curl/7.52.1’,<br>              ‘Content-Type’: ‘application/json’,<br>              ‘Accept’: ‘application/vnd.github.everest-preview+json’,<br>              ‘Authorization’: ‘token f43964836a33dce415385bc303c8c20adc1bd52194’&#125;)<br></code></pre></p><div data-type="info" class="ne-alert"><ul class="ne-ul"><li id="3c600909972be4f842c6d28b9c9e78f9"><span class="ne-text">触发器配置</span></li></ul></div><p id="2e5237f2bdcd6df56a544ceb0f6e7be9" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1608448464729-f5e542f2-0a6e-4817-bd93-b8cf6f67b8fa.png" width="773.5" id="V2THU" class="ne-image"></p><p id="8e9cf4466b6fd1baca7e130d23f326a6" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1608448488925-30baf354-0b23-490c-8b05-4b054ca1b868.png" width="522.5" id="vXRT1" class="ne-image"></p><h3 id="Ia0Tb"><span class="ne-text">【推荐】Vercel的serverless</span></h3><ul class="ne-ul"><li id="17ad4c77dd90f7c792974f75dd3a5c5f"><a href="https://github.com/wztlink1013/yuque-github-api" data-href="https://github.com/wztlink1013/yuque-github-api" target="_blank" class="ne-link"><span class="ne-text">https://github.com/wztlink1013/yuque-github-api</span></a></li></ul><h2 id="8LnNg"><span class="ne-text">四、语雀云端的配置</span></h2><p id="ba85c0f4a2299d376a43f55916f57c82" class="ne-p"><span class="ne-text">在所需要拉取的仓库中webhook中填入云函数所留下的那串网址，勾选所需要触发的选项即可。</span></p><p id="686a64a0b2b1b8cf91c94cc98d75ecda" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1624971959931-874c6c43-8c51-4c56-9b32-e952f8c87f6c.png" width="555.5" id="TI4F3" class="ne-image"></p><h2 id="BLygZ"><span class="ne-text">参考</span></h2><ul class="ne-ul"><li id="89c3356bf1b049a1bec201e225f16b30"><a href="https://github.com/x-cold/yuque-hexo" data-href="https://github.com/x-cold/yuque-hexo" target="_blank" class="ne-link"><span class="ne-text">yuque-hexo开发仓库</span></a></li><li id="74c1f2d07150fbd11374439ee411f94d"><a href="https://www.zhwei.cn/hexo-github-actions-yuque/" data-href="https://www.zhwei.cn/hexo-github-actions-yuque/" target="_blank" class="ne-link"><span class="ne-text">Hexo：语雀云端写作，Github Actions持续集成</span></a></li><li id="3e6686a9e74b880065e29a6141d20240"><a href="https://segmentfault.com/a/1190000017797561" data-href="https://segmentfault.com/a/1190000017797561" target="_blank" class="ne-link"><span class="ne-text">Hexo 博客终极玩法：云端写作，自动部署</span></a></li><li id="e30cf16dc70ad3935957ad81c54a9bd5"><a href="https://www.xiayinchang.top/post/b2362878.html" data-href="https://www.xiayinchang.top/post/b2362878.html" target="_blank" class="ne-link"><span class="ne-text">阿里云云函数使用用户</span></a></li><li id="f13bd285d7b7894c1ec10a631cf5be30"><a href="https://bbs.pediy.com/thread-260866.htm" data-href="https://bbs.pediy.com/thread-260866.htm" target="_blank" class="ne-link"><span class="ne-text">[原创]自动同步语雀文档到你的hexo博客</span></a></li><li id="b911ba9cb292fdbf0ee1067f802f15be"><a href="https://github.com/Zfour/yuque_vercel_webhook_api" data-href="https://github.com/Zfour/yuque_vercel_webhook_api" target="_blank" class="ne-link"><span class="ne-text">https://github.com/Zfour/yuque_vercel_webhook_api</span></a></li></ul></div>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
          <category> 博客技术 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>“什么都无法舍弃，什么也改变不了”</title>
      <link href="/essay/vattip/"/>
      <url>/essay/vattip/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><div data-type="info" class="ne-alert"><p id="a20d224c568e48b9d67847a2c66a8c01_p_0" class="ne-p"><span class="ne-text">什么也无法舍弃的人，也无法改变任何事情吧。</span></p><p id="29a52ba517268eadd4813c6ebff54c6c" class="ne-p"><span class="ne-text">——爱尔敏·阿诺德</span></p></div><p id="d8173a1c126e93f28da1959621eed651" class="ne-p"><br></p><p id="9f4295c4b66502d1fae7ef9d51f62576" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1620265214393-3e90a086-8121-4c96-8f09-6d9bd1406fd2.png" width="383.5" id="BxjYe" class="ne-image"></p><p id="5d9e8927bebce7d9f5ad1a0dac642b07" class="ne-p"><br></p><p id="c56d928fb271c2369e13ae507d602a01" class="ne-p"><code class="ne-code"><span class="ne-text">2021.04.28</span></code></p><p id="aeaec709b701125022bda16ec8b4428c" class="ne-p"><br></p><p id="b5e559fe6cc245e8780f5a4432c58b76" class="ne-p"><span class="ne-text">突然对舍弃有了一个新的见解，</span></p><p id="8a905f65ebde8c676cf8312b5f85038e" class="ne-p"><br></p><p id="d8101d0c005c5cab6da40da0df6e0666" class="ne-p"><span class="ne-text">舍弃，很多时候，不仅仅是执行者主观的做法，还有一种就是，被动的舍弃…</span></p><p id="68c1cfe69c29b6de58143967ad2628b5" class="ne-p"><br></p><p id="a1e6c7c422926c790fbcaeff4611a3e6" class="ne-p"><span class="ne-text">因为你注定要成为什么样的人，所以注定你必须要舍弃某些东西，那么这个时候，对这样的选择该怎么办呢？</span></p><p id="5c6b0d6963f3f0c1940d56ca3e0858bc" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1619589532108-e98a4fc8-907a-40c4-9e74-2eb76b34d311.jpeg" width="445" id="DNXMj" class="ne-image"></p><p id="6237e4d182036c59b12714c30fcdadb8" class="ne-p"><br></p><p id="8fc562f12f84f5e8d2983e5b525d27e3" class="ne-p"><code class="ne-code"><span class="ne-text">2021.04.29</span></code></p><p id="8e756937e73d9cf506f8c247ed4cc255" class="ne-p"><br></p><p id="f1a04263255875626989fd71a314597d" class="ne-p"><span class="ne-text">什么是得到呢？</span></p><p id="c4ba1f02d7262e7df9384295477b9619" class="ne-p"><br></p><p id="23f5049c28de938bba48c0cf22595779" class="ne-p"><span class="ne-text">也许，现在的你没得到，不代表今后的你不会得到，不同的时段，我们所在乎的还会一样吗？</span></p><p id="c861251c6ef0f076f314625f0ccdfb60" class="ne-p"><br></p></div>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>快节奏下的人们</title>
      <link href="/essay/gm1to9/"/>
      <url>/essay/gm1to9/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content-editor-core lake-engine lake-typography-classic" data-lake-element="root" data-selection-undefined="%7B%22path%22%3A%5B%5B10%2C0%2C48%5D%2C%5B10%2C0%2C48%5D%5D%2C%22active%22%3Atrue%7D"><p data-lake-id="a20d224c568e48b9d67847a2c66a8c01_p_0" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">如今的抒情，早已不知道为何变得如此奢侈</p><p data-lake-id="79eeea539b9d202e36b6faf150f4260b" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="58b2d7fe339545ff61bc6a7d7b962732" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">我们更多的是用心感受远行，而不是，来到一个地方，拍个照，发朋友圈，嗯，我来过，而已……</p><p data-lake-id="f5ca9b0380dd34579466b6f61bd45b0a" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="916cf591785d0dfa3c5b8380c7c10eba" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">什么时候，抒情也变得如此廉价</p><p data-lake-id="ce2a01aa01573a17990818ee709b9b12" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="bf7454c7494d1e86d5cd8bab0db34087" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="1526ef00699787ea894a90b00912c7a7" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">写东西更多的是一种抒发内心想法，简单且纯粹，就像是记录下来的，就是我的内心真实写照，</p><p data-lake-id="fbf163a1dd38817a952f15095e27ce62" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="f2f87ec4aed0ccc740746755a184ed94" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="97b22bf37303cadfc2842d6d0c242554" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">微商—自媒体—短视频，人们变得不仅是快节奏，更是一种焦虑，为什么会焦虑呢？因为这个社会太快了……</p></div>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
