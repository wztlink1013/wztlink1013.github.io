<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/HelloWorld/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<a id="more"></a>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;
</code></pre>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server
</code></pre>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate
</code></pre>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy
</code></pre>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>分治算法+归并排序</title>
    <url>/blog/ab9fkt/</url>
    <content><![CDATA[<h2 id="分治算法"><a href="#分治算法" class="headerlink" title="分治算法"></a>分治算法</h2><p>此前学习的<strong>递归设计方法</strong>，是针对规模大的问题拆成规模小的问题，并且规模大的问题和规模小的问题的解决办法相同。</p>
<p>分治算法与递归设计方法的不同之处就是，该规模较大的问题分解为多个不重叠的子问题，并将其称为<strong>“分而治之”</strong><br>**<br>分治的三个步骤：</p>
<ol>
<li>分解：将原问题分解为若干个规模较小、相互不重叠与原问题形式相同的子问题</li>
<li>解决：<ol>
<li>若子问题规模较小且易于解决时候直接解出</li>
<li>否则递归地解决各个子问题</li>
</ol>
</li>
<li>合并：将各个子问题的解个并未原问题的解</li>
</ol>
<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h3><ul>
<li>分解：将排序数组分解为左右两个相等的不重叠的数组</li>
<li>解决：递归</li>
<li>合并：将两个已经有序的数组合并为一个有序的数组</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1603617542157-07613fda-ebed-4924-bf6a-091c19b12fc7.png#align=left&amp;display=inline&amp;height=431&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=861&amp;originWidth=895&amp;size=74826&amp;status=done&amp;style=shadow&amp;width=447.5" alt="image.png"></p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3>]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>存储过程</title>
    <url>/blog/adiki8/</url>
    <content><![CDATA[<p>存储过程（Stored Procedure）是 SQL 语句和控制语句的预编译集合，以一个名称存储并作为一个单元处理。<br>其效率比函数更高。增强 SQL 语句的功能和灵活性。减少网络流量。<br>客户端重启，存储过程不会失效。定界符只对客户端有效，客户端重启，定界符失效。</p>
<blockquote>
<p>数据库系统有三层结构：客户端、DBMS、服务端。我们的各种请求都是通过客户端发送给 DBMS，DBMS 将 SQL 语句编译成二进制,然后执行，接着缓存在 DBMS 中（再次执行时效率提高），接着发送给数据库服务端，然后服务端再返回数据给 DBMS，DBMS 再返回给客户端显示。<br>而存储过程，是将某些常用的请求，在 DBMS 中编译好二进制存储在 DBMS 中，以后再发送同样请求，就免去了编译的开销。</p>
</blockquote>
<p>模块化编程，可以提高速度。但是可移植性不好。</p>
<h2 id="创建存储过程"><a href="#创建存储过程" class="headerlink" title="创建存储过程"></a>创建存储过程</h2><p>创建之前必须先选择(USE)数据库。</p>
<pre><code class="sql">CREATE
[DEFINER = {user|CURRENT_USER}]
PROCEDURE  sp_name([proc_parameter[,...]])
[characteristic ...] routine_body

proc_parameter:
[IN|OUT|INOUT] param_name type
</code></pre>
<h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><ul>
<li>IN，表示该参数的值必须在调用存储过程时指定</li>
<li>OUT，表示该参数的值可以被存储过程改变，并且可以被返回</li>
<li>INOUT，表示该参数的调用时指定，并且可以被改变和返回</li>
</ul>
<p>可以这样理解，IN 就是要传入的，值必须在调用时指定，不能返回（值传递），OUT 是返回的（指针传递）。INOUT 传入之后被返回的。</p>
<h3 id="过程体"><a href="#过程体" class="headerlink" title="过程体"></a>过程体</h3><ul>
<li>过程体由合法的 SQL 语句构成</li>
<li>过程体是绝大部分 SQL 语句</li>
<li>复合结构（超过两个 SQL 语句）使用 BEGIN…END</li>
<li>复合结构可以包含声明，循环，控制结构</li>
</ul>
<h2 id="调用存储过程"><a href="#调用存储过程" class="headerlink" title="调用存储过程"></a>调用存储过程</h2><pre><code class="sql">CALL sp_name[()]
</code></pre>
<p>如果存储过程没有参数，则调用的时候可以不加括号。</p>
<h2 id="删除存储过程"><a href="#删除存储过程" class="headerlink" title="删除存储过程"></a>删除存储过程</h2><p>用 DROP PROCDURE sp_name;</p>
<hr>
<p>我们应该已经发现了，所有 CREATE 创建的东西，都需要用 DROP 来删除。包括：<br>数据库、表、视图、触发器、函数、存储过程</p>
<h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><pre><code class="sql">delimiter //
CREATE PROCEDURE
  removeuserbyid(IN u_id INT UNSIGNED)
begin
  DELETE
  FROM   users
  WHERE  id = u_id;END//
  -- 调用
  CALL removeuserbyid(1)//
</code></pre>
<p>注意参数的名字不能和字段名相同。</p>
<pre><code class="sql">CREATE PROCEDURE
  remove2(IN p_id      INT signed,
          OUT usernums INT UNSIGNED)
begin
  DELETE
  FROM   users
  WHERE  id=p_id;

  SELECT count(id)
  FROM   users
  INTO   usernums;

end//
-- 调用
CALL remove2(2,@nums)//
-- 查看变量nums的值
SELECT @nums//
</code></pre>
<p>返回值存储在变量@nums 中。</p>
<h2 id="修改存储过程"><a href="#修改存储过程" class="headerlink" title="修改存储过程"></a>修改存储过程</h2><pre><code class="sql">ALTER PROCEDURE sp_name[characteristic ...]
COMMENT &#39;string&#39;
|{COUNTAINS SQL|NO SQL|READS SQL DATA|MODIFIES SQL DATA}
|SQL SECURITY{DEFINER|INVOKER}|
</code></pre>
<h2 id="与函数对比"><a href="#与函数对比" class="headerlink" title="与函数对比"></a>与函数对比</h2><p>存储过程实现的功能更复杂一些；而函数的针对性更强。<br>时间经常用存储过程对表作操作。<br>存储过程可以用多个返回值。<br>存储过程独立出现。<br>函数出现在其他 SQL 语句内部。</p>
]]></content>
      <categories>
        <category>Language</category>
      </categories>
  </entry>
  <entry>
    <title>数据库操作</title>
    <url>/blog/afuf5u/</url>
    <content><![CDATA[<h2 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h2><pre><code class="sql">CREATE {DATABASE|SCHEMA} [IF NOT EXISTS] db_name [DEFAULT] CHARCTER SET [=] charset_name;
</code></pre>
<blockquote>
<p>注意设置字符集的时候，utf-8 要写作 utf8。</p>
</blockquote>
<h2 id="使用数据库"><a href="#使用数据库" class="headerlink" title="使用数据库"></a>使用数据库</h2><blockquote>
<p>使用指定数据库</p>
</blockquote>
<pre><code class="sql">use DATABASE
go
</code></pre>
<h2 id="修改数据库"><a href="#修改数据库" class="headerlink" title="修改数据库"></a>修改数据库</h2><pre><code class="sql">ALTER {DATABASE|SCHEMA} db_name [DEFAUTL] CHARCTER SET [=] charset_name;
</code></pre>
<h3 id="修改数据库编码格式"><a href="#修改数据库编码格式" class="headerlink" title="修改数据库编码格式"></a>修改数据库编码格式</h3><pre><code>SET NAMES GBK;
</code></pre><p>GBK 也可以是其他编码格式。但这只是修改你客户端显示的编码格式。服务端并不变化。<br><strong>修改配置文件来改服务端编码</strong><br>打开/etc/my.cnf 文件<br>在[mysqld]条目下：增加</p>
<pre><code>character_set_server=utf8
init_connect=&#39;SET NAMES utf8&#39;
</code></pre><p>有时在数据库创建完成后，编码格式是无法修改的。只能删掉重新建。</p>
<h2 id="删除数据库"><a href="#删除数据库" class="headerlink" title="删除数据库"></a>删除数据库</h2><pre><code class="mysql">    DROP {DATABASE|SCHEMA} [IF EXISTS] db_name;
</code></pre>
]]></content>
      <categories>
        <category>Language</category>
      </categories>
  </entry>
  <entry>
    <title>IDEA环境下的Web开发bug汇总</title>
    <url>/blog/aiuif3/</url>
    <content><![CDATA[<h2 id="Unsupported-major-minor-version-52-0"><a href="#Unsupported-major-minor-version-52-0" class="headerlink" title="Unsupported major.minor version 52.0"></a>Unsupported major.minor version 52.0</h2><blockquote>
<p>版本过低</p>
</blockquote>
<pre><code class="java">[2021-02-07 08:25:52,537] Artifact javaweb-blog:war exploded: Error during artifact deployment. See server log for details.
</code></pre>
<pre><code class="java"> java.lang.UnsupportedClassVersionError: com/nic/filter/AdminFilter : Unsupported major.minor version 52.0 (unable to load class com.nic.filter.AdminFilter)
</code></pre>
<p>一直报错，网上找一直是说和 jdk 的版本有关，但是 jdk 的版本尝试更换几个都无效。事实上是 Tomcat 的版本问题，项目开始用的是 Tomcat8.1 升级至 8.5.34 即可（升级 Tomcat9 可以否？会对下兼容吗？trytry）</p>
<h2 id="org-apache-tomcat-util-descriptor-web-WebXml-setVersion-Unknown-version-string-4-0"><a href="#org-apache-tomcat-util-descriptor-web-WebXml-setVersion-Unknown-version-string-4-0" class="headerlink" title="org.apache.tomcat.util.descriptor.web.WebXml.setVersion Unknown version string [4.0]"></a>org.apache.tomcat.util.descriptor.web.WebXml.setVersion Unknown version string [4.0]</h2><blockquote>
<p>warning：4.0 太高</p>
</blockquote>
<pre><code class="java">org.apache.tomcat.util.descriptor.web.WebXml.setVersion Unknown version string [4.0]
</code></pre>
<ul>
<li>解决：<a href="https://blog.csdn.net/qq_32483145/article/details/80292463" target="_blank" rel="noopener">https://blog.csdn.net/qq_32483145/article/details/80292463</a></li>
</ul>
<h2 id="用到-servlet-的页面跳转-404"><a href="#用到-servlet-的页面跳转-404" class="headerlink" title="用到 servlet 的页面跳转 404"></a>用到 servlet 的页面跳转 404</h2><h3 id="web-xml-配置有误"><a href="#web-xml-配置有误" class="headerlink" title="web.xml 配置有误"></a>web.xml 配置有误</h3><p>页面能访问，也成功部署到 tomcat 下面的 weapps 文件夹下面，但是在进行页面跳转的过程中，会出现下面的 404 情况。分析之后是我这个项目是新建的一个空项目，然后代码是之前在 eclipse 下运行过的，而后直接将内容代码复制过来，却没复制 web.xml，导致现项目的 web.xml 是“空的”，无配置。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612753264339-b79c791c-6814-4c38-b42d-6b85bb9c1d5f.png#align=left&amp;display=inline&amp;height=144&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=288&amp;originWidth=1920&amp;size=37994&amp;status=done&amp;style=none&amp;width=960" alt="image.png"></p>
<h3 id="Tomcat-路径配置有误"><a href="#Tomcat-路径配置有误" class="headerlink" title="Tomcat 路径配置有误"></a>Tomcat 路径配置有误</h3><p>还有一种情况，就是 tomcat 配置过程中的那两个路径也要注意下<br>调整为如下配置，不然会出现访问/jsp-peojectname/jsp-peojectname/index.jsp 页面为 404 的情况<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612756924057-55c60ad3-85b8-4cf0-aa9d-6184bfbd296e.png#align=left&amp;display=inline&amp;height=78&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=156&amp;originWidth=1611&amp;size=17507&amp;status=done&amp;style=none&amp;width=805.5" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612756936656-72d837f5-46ef-4d35-8e39-e49d2c6f077d.png#align=left&amp;display=inline&amp;height=97&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=194&amp;originWidth=1611&amp;size=12795&amp;status=done&amp;style=none&amp;width=805.5" alt="image.png"></p>
<h3 id="其他类型错误"><a href="#其他类型错误" class="headerlink" title="其他类型错误"></a>其他类型错误</h3><p>可能还有其他类型错误，参考以下的总结</p>
<ul>
<li><a href="https://blog.csdn.net/DBC_121/article/details/79204340" target="_blank" rel="noopener">Web 开发：关于 Tomcat 出现 The origin server did not find a current representation for the target resourc…的问题</a></li>
</ul>
<h2 id="数据库报错"><a href="#数据库报错" class="headerlink" title="数据库报错"></a>数据库报错</h2><p>navicat 也不能查看该数据库</p>
<pre><code class="java">HTTP Status 500 – Internal Server Error
Type Exception Report

Message get connection error!

Description The server encountered an unexpected condition that prevented it from fulfilling the request.

Exception

java.lang.RuntimeException: get connection error!
    com.nic.util.JdbcUtil.getConnection(JdbcUtil.java:55)
    com.nic.dao.ArticleDao.findArticle(ArticleDao.java:56)
    com.nic.service.ArticleService.findArticle(ArticleService.java:20)
    com.nic.servlet.PostlistServlet.doGet(PostlistServlet.java:50)
    javax.servlet.http.HttpServlet.service(HttpServlet.java:635)
    javax.servlet.http.HttpServlet.service(HttpServlet.java:742)
    org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:52)
Root Cause

java.lang.ClassNotFoundException: com.mysql.jdbc.Driver
    org.apache.catalina.loader.WebappClassLoaderBase.loadClass(WebappClassLoaderBase.java:1309)
    org.apache.catalina.loader.WebappClassLoaderBase.loadClass(WebappClassLoaderBase.java:1137)
    java.lang.Class.forName0(Native Method)
    java.lang.Class.forName(Class.java:264)
    com.nic.util.JdbcUtil.getConnection(JdbcUtil.java:52)
    com.nic.dao.ArticleDao.findArticle(ArticleDao.java:56)
    com.nic.service.ArticleService.findArticle(ArticleService.java:20)
    com.nic.servlet.PostlistServlet.doGet(PostlistServlet.java:50)
    javax.servlet.http.HttpServlet.service(HttpServlet.java:635)
    javax.servlet.http.HttpServlet.service(HttpServlet.java:742)
    org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:52)
Note The full stack trace of the root cause is available in the server logs.

Apache Tomcat/8.5.34
</code></pre>
<p>初步分析是用的 phpstudy 里面的 mysql 数据库不能生效，删除电脑之前的 mysql，用 phpstudy 数据库恢复</p>
<hr>
<p>但是还会报错，判断应该是代码文件出错【不过不用将这个 jar 包导入到 lib 文件夹下（反而会报错），只需要将其导入到 tomcat 文件夹下的 lib 文件夹，即可】<br><a href="https://www.yuque.com/attachments/yuque/0/2021/jar/1484158/1612768356808-4c69cbaa-cbc7-4ebe-9232-423cad8ef54f.jar?_lake_card=%7B%22uid%22%3A%221612761483730-0%22%2C%22src%22%3A%22https%3A%2F%2Fwww.yuque.com%2Fattachments%2Fyuque%2F0%2F2021%2Fjar%2F1484158%2F1612768356808-4c69cbaa-cbc7-4ebe-9232-423cad8ef54f.jar%22%2C%22name%22%3A%22mysql-connector-java-5.1.49.jar%22%2C%22size%22%3A1006904%2C%22type%22%3A%22%22%2C%22ext%22%3A%22jar%22%2C%22progress%22%3A%7B%22percent%22%3A99%7D%2C%22status%22%3A%22done%22%2C%22percent%22%3A0%2C%22id%22%3A%22xrOhc%22%2C%22refSrc%22%3A%22https%3A%2F%2Fwww.yuque.com%2Fattachments%2Fyuque%2F0%2F2021%2Fjar%2F1484158%2F1612761486309-2d90c3e5-5a0c-4b57-95f5-5551ed944a23.jar%22%2C%22card%22%3A%22file%22%7D" target="_blank" rel="noopener">mysql-connector-java-5.1.49.jar</a>（或者直接上网搜再下载）<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612756117413-4649efa1-9274-4ae5-aa1a-463750acd571.png#align=left&amp;display=inline&amp;height=332&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=663&amp;originWidth=1291&amp;size=105075&amp;status=done&amp;style=shadow&amp;width=645.5" alt="image.png">~~</p>
]]></content>
      <categories>
        <category>Bug</category>
      </categories>
  </entry>
  <entry>
    <title>JAVA-抽象类和接口</title>
    <url>/blog/akog9h/</url>
    <content><![CDATA[<h2 id="概念名词"><a href="#概念名词" class="headerlink" title="概念名词"></a>概念名词</h2><ul>
<li><strong>接口</strong>：许多类的<strong>共同行为</strong>（包含非相关类），就当与给客户看的。</li>
<li><strong>抽象类</strong>：就相当于一个父类，该父类包含其子类的<strong>共性</strong>特征，就像是子类园和子类长方形，两个类可以有一个共同的父类，该父类定义为抽象类，其包含一个<strong>抽象方法</strong>，比如求面积或是求周长</li>
</ul>
<h2 id="接口的一些要点"><a href="#接口的一些要点" class="headerlink" title="接口的一些要点"></a>接口的一些要点</h2><blockquote>
<p><code>public interface List&lt;E&gt; { }</code></p>
</blockquote>
<ul>
<li>接口是一个<strong>写注释</strong>的好地方</li>
</ul>
<h2 id="抽象类的一些要点"><a href="#抽象类的一些要点" class="headerlink" title="抽象类的一些要点"></a>抽象类的一些要点</h2><blockquote>
<p><code>public abstract class AbstractList&lt;E&gt; implements List&lt;E&gt; { }</code> &gt; <code>public abstract class Test(){}</code> &gt; <code>public abstract double getTest(){}</code></p>
</blockquote>
<ul>
<li>抽象类当中的<strong>抽象方法</strong>要在其子类当中实现，因为抽象类“抽象”的以至于没有实例</li>
<li>包含抽象方法的类必定是抽象类</li>
<li><strong>抽象类的构造函数实现要加上 protected，因为其构造函数只被其子类所使用，在创建子类实例的时候，其父类构造函数被调用来初始化该父类的数据域</strong></li>
<li><strong>抽象类不可以 new 对象，不对外公开，只抽取公共代码，eg：ArrayList 和 LinkedList</strong></li>
<li><strong>抽象类可以不是先接口里面的部分函数</strong></li>
<li><strong>抽象类作用：放“公共代码”</strong></li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598686636557-2700f743-9f28-435a-b771-86bdf7b2b25c.png#align=left&amp;display=inline&amp;height=326&amp;margin=%5Bobject%20Object%5D&amp;originHeight=574&amp;originWidth=732&amp;size=0&amp;status=done&amp;style=shadow&amp;width=416" alt></p>
]]></content>
      <categories>
        <category>Language</category>
      </categories>
  </entry>
  <entry>
    <title>ANN神经网络</title>
    <url>/blog/apohu8/</url>
    <content><![CDATA[<h2 id="一、基本结构"><a href="#一、基本结构" class="headerlink" title="一、基本结构"></a>一、基本结构</h2><blockquote>
<p>神经网络基本结构<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685949882-81dbb96c-eafa-4294-aae3-242fd33fff2b.png#align=left&amp;display=inline&amp;height=324&amp;margin=%5Bobject%20Object%5D&amp;originHeight=324&amp;originWidth=858&amp;size=0&amp;status=done&amp;style=none&amp;width=858" alt> &gt; <img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685950067-4d0671d6-b294-4284-9eff-9409d230e91e.png#align=left&amp;display=inline&amp;height=470&amp;margin=%5Bobject%20Object%5D&amp;originHeight=470&amp;originWidth=768&amp;size=0&amp;status=done&amp;style=none&amp;width=768" alt></p>
</blockquote>
<blockquote>
<p>何为深度学习？<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685949953-b8d95ff1-6384-4e59-b3d6-1f8151f08204.png#align=left&amp;display=inline&amp;height=400&amp;margin=%5Bobject%20Object%5D&amp;originHeight=400&amp;originWidth=842&amp;size=0&amp;status=done&amp;style=none&amp;width=842" alt></p>
</blockquote>
<h2 id="二、感知器和激活函数"><a href="#二、感知器和激活函数" class="headerlink" title="二、感知器和激活函数"></a>二、感知器和激活函数</h2><blockquote>
<p>感知器<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685949922-e9c76c57-f1c5-4ff1-af82-25c35a4005b1.png#align=left&amp;display=inline&amp;height=514&amp;margin=%5Bobject%20Object%5D&amp;originHeight=514&amp;originWidth=802&amp;size=0&amp;status=done&amp;style=none&amp;width=802" alt></p>
</blockquote>
<blockquote>
<p>激活函数（其中 w 和 x 为向量点乘；b 为偏置，w0）<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685949961-18eeecb5-c82e-4f71-a543-9bd0c0f27043.png#align=left&amp;display=inline&amp;height=511&amp;margin=%5Bobject%20Object%5D&amp;originHeight=511&amp;originWidth=836&amp;size=0&amp;status=done&amp;style=none&amp;width=836" alt></p>
</blockquote>
<blockquote>
<p>激活函数的选择<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685950003-072268a5-122d-4340-85d5-85eeb04236fe.png#align=left&amp;display=inline&amp;height=538&amp;margin=%5Bobject%20Object%5D&amp;originHeight=538&amp;originWidth=861&amp;size=0&amp;status=done&amp;style=none&amp;width=861" alt></p>
</blockquote>
<h2 id="三、感知器的训练"><a href="#三、感知器的训练" class="headerlink" title="三、感知器的训练"></a>三、感知器的训练</h2><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685950698-fc03bb22-76e6-4328-9a6b-ee2168250fec.png#align=left&amp;display=inline&amp;height=529&amp;margin=%5Bobject%20Object%5D&amp;originHeight=529&amp;originWidth=872&amp;size=0&amp;status=done&amp;style=none&amp;width=872" alt></p>
<h2 id="四、简单代码实现"><a href="#四、简单代码实现" class="headerlink" title="四、简单代码实现"></a>四、简单代码实现</h2><pre><code class="python">from functools import reduce

class Perceptron(object):
    &#39;&#39;&#39;
    构造函数的初始化
    &#39;&#39;&#39;
    def __init__(self,input_num,activator):
        &#39;&#39;&#39;
        构造函数的初始化
        &#39;&#39;&#39;
        self.activator = activator
        self.weights = [0.0 for _ in range(input_num)]
        self.bias = 0.0
    def __str__(self):
        &#39;&#39;&#39;
        打印学习后的权重值和偏置项
        &#39;&#39;&#39;
        return &#39;weights\t:%s\nbias\t:%f\n&#39; %(self.weights,self.bias)
    def predict(self,input_vec):
        &#39;&#39;&#39;
        输入向量，输出感知器的计算结果
        &#39;&#39;&#39;
        return self.activator(
            reduce(lambda a,b: a+b,
                    list(map(lambda x,w: x*w,
                        input_vec,self.weights)
                 ),0.0)+self.bias)
    def train(self,input_vecs,labels,iteration,rate):
        &#39;&#39;&#39;
        输入训练数据：一组向量、与每个向量对应的label；以及训练轮数、学习率
        &#39;&#39;&#39;
        for i in range(iteration):
            self._one_iteration(input_vecs,labels,rate)
    def _one_iteration(self,input_vecs,labels,rate):
        &#39;&#39;&#39;
        迭代，把所有的训练数据过一遍
        &#39;&#39;&#39;
        samples = zip(input_vecs,labels)
        for (input_vec,label) in samples:
            output = self.predict(input_vec)
            self._update_weights(input_vec,output,label,rate)
    def _update_weights(self,input_vec,output,label,rate):
        &#39;&#39;&#39;
        按照感知器规则更新权重
        &#39;&#39;&#39;
        delta = label - output
        self.weights = map(
            lambda x, w:w+rate*delta*x,
            input_vec,self.weights)
        self.weights = list(self.weights)
        self.bias += rate*delta
def f(x):
    &#39;&#39;&#39;
    定义激活函数
    &#39;&#39;&#39;
    return 1 if x&gt;0 else 0
def get_training_dataset():
    &#39;&#39;&#39;
    训练数据
    &#39;&#39;&#39;
    input_vecs = [[1,1],[0,0],[1,0],[0,1]]
    labels = [1,0,0,0]
    return input_vecs,labels
def train_and_perceptron():
    &#39;&#39;&#39;
    训练感知器
    &#39;&#39;&#39;
    p = Perceptron(2,f)
    input_vecs,labels = get_training_dataset()
    p.train(input_vecs,labels,10,0.1)
    return p

if __name__ == &#39;__main__&#39;:
    and_perception = train_and_perceptron()
    print(and_perception)
    print(&#39;1 and 1 = %d&#39; % and_perception.predict([1,1]))
    print(&#39;0 and 0 = %d&#39; % and_perception.predict([0,0]))
    print(&#39;1 and 0 = %d&#39; % and_perception.predict([1,0]))
    print(&#39;0 and 1 = %d&#39; % and_perception.predict([0,1]))
</code></pre>
<blockquote>
<p>运行结果：<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685949806-ba54dca5-89a6-474a-809c-0b0238184755.png#align=left&amp;display=inline&amp;height=261&amp;margin=%5Bobject%20Object%5D&amp;originHeight=261&amp;originWidth=536&amp;size=0&amp;status=done&amp;style=none&amp;width=536" alt></p>
</blockquote>
]]></content>
      <categories>
        <category>MachingLearning</category>
      </categories>
  </entry>
  <entry>
    <title>P20. 有效的括号</title>
    <url>/blog/aritwv/</url>
    <content><![CDATA[<h2 id="问题思路"><a href="#问题思路" class="headerlink" title="问题思路"></a>问题思路</h2><p>将所有的左半边括号 push 到栈内，然后遇到右半边括号，就将其与栈顶元素匹配测试，若能匹配成功则继续匹配，反之输出 false。</p>
<p>在这之间注意比较当栈内没有元素了，而字符串还有待匹配的字符，输出 false，当栈内还有元素，外面与之匹配测试的右半边括号，也输出 false。</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="栈实现"><a href="#栈实现" class="headerlink" title="栈实现"></a>栈实现</h3><pre><code class="java">class Solution {
    public boolean isValid(String s) {
        Stack&lt;Character&gt; stack = new Stack&lt;&gt;();

        int len = s.length();
        for (int i=0;i&lt;len;i++) {
            char c = s.charAt(i);
            if (c == &#39;(&#39; || c == &#39;[&#39; || c == &#39;{&#39;) {
                stack.push(c);
            } else {
                if (stack.isEmpty()) return false;
                char left = stack.pop();
                if (left == &#39;(&#39; &amp;&amp; c !=&#39;)&#39;) return false;
                if (left == &#39;[&#39; &amp;&amp; c !=&#39;]&#39;) return false;
                if (left == &#39;{&#39; &amp;&amp; c !=&#39;}&#39;) return false;
            }
        }
        return stack.isEmpty();
    }
}
</code></pre>
<pre><code class="java">class Solution {
    public boolean isValid(String s) {
        Stack&lt;Character&gt; stack = new Stack&lt;&gt;();
        for (int i = 0; i&lt; s.length();i++){
            if (s.charAt(0) == &#39;)&#39; || s.charAt(0) == &#39;]&#39; || s.charAt(0) == &#39;}&#39;){
                return false;
            }
            if (s.charAt(i) == &#39;(&#39; || s.charAt(i) == &#39;[&#39; || s.charAt(i) == &#39;{&#39;){
                stack.push(s.charAt(i));
            }
            if (s.charAt(i) == &#39;)&#39; || s.charAt(i) == &#39;]&#39; || s.charAt(i) == &#39;}&#39;){
                if (s.charAt(i) == &#39;)&#39;){
                    if (stack.isEmpty() == true) {
                        return false;
                    }
                    if (stack.pop() != &#39;(&#39;)
                        return false;

                }
                if (s.charAt(i) == &#39;]&#39;){
                    if (stack.isEmpty() == true) {
                        return false;
                    }
                    if (stack.pop() != &#39;[&#39;)
                        return false;

                }
                if (s.charAt(i) == &#39;}&#39;){
                    if (stack.isEmpty() == true) {
                        return false;
                    }
                    if (stack.pop() != &#39;{&#39;)
                        return false;

                }
            }
        }
        if (stack.isEmpty() == true){
            return true;
        } else {
            return false;
        }

    }
}
</code></pre>
<h3 id="HashMap-实现"><a href="#HashMap-实现" class="headerlink" title="HashMap 实现"></a>HashMap 实现</h3><pre><code class="java">class Solution {
    private static HashMap&lt;Character, Character&gt; map = new HashMap&lt;&gt;();
    static {
        // key - value
        map.put(&#39;(&#39;, &#39;)&#39;);
        map.put(&#39;{&#39;, &#39;}&#39;);
        map.put(&#39;[&#39;, &#39;]&#39;);
    }

    public boolean isValid(String s) {
        Stack&lt;Character&gt; stack = new Stack&lt;&gt;();

        int len = s.length();
        for (int i = 0; i &lt; len; i++) {
            char c = s.charAt(i);
            if (map.containsKey(c)) { // 左括号
                stack.push(c);
            } else { // 右括号
                if (stack.isEmpty()) return false;

                if (c != map.get(stack.pop())) return false;
            }
        }
        return stack.isEmpty();
    }
}
</code></pre>
]]></content>
      <categories>
        <category>DataStructure</category>
      </categories>
      <tags>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>Eclipse的使用总结</title>
    <url>/blog/at014v/</url>
    <content><![CDATA[<h2 id="一、Eclipse-的下载与安装"><a href="#一、Eclipse-的下载与安装" class="headerlink" title="一、Eclipse 的下载与安装"></a>一、Eclipse 的下载与安装</h2><p><a href="https://www.eclipse.org/downloads/" target="_blank" rel="noopener">下载地址</a><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685180944-7ec7ebc3-8c39-44a7-9bec-85fded021a40.png#align=left&amp;display=inline&amp;height=441&amp;margin=%5Bobject%20Object%5D&amp;originHeight=441&amp;originWidth=1817&amp;size=0&amp;status=done&amp;style=none&amp;width=1817" alt></p>
<p><strong>注意不要下错版本，不然开发不了 web 环境</strong><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685180923-a106c8c7-aebe-4f0a-bc06-d166bfc8894d.png#align=left&amp;display=inline&amp;height=758&amp;margin=%5Bobject%20Object%5D&amp;originHeight=758&amp;originWidth=731&amp;size=0&amp;status=done&amp;style=none&amp;width=731" alt><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685180948-16e05303-0d11-454e-8bbd-71a11d7a3ef7.png#align=left&amp;display=inline&amp;height=763&amp;margin=%5Bobject%20Object%5D&amp;originHeight=763&amp;originWidth=741&amp;size=0&amp;status=done&amp;style=none&amp;width=741" alt><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685180925-0262b0ea-f7af-493b-85a5-d8e7cbd12751.png#align=left&amp;display=inline&amp;height=373&amp;margin=%5Bobject%20Object%5D&amp;originHeight=373&amp;originWidth=762&amp;size=0&amp;status=done&amp;style=none&amp;width=762" alt></p>
<h2 id="二、插件"><a href="#二、插件" class="headerlink" title="二、插件"></a>二、插件</h2><blockquote>
<p>进入：<code>Help Eclipse</code> <code>MarketPlace</code></p>
</blockquote>
<ul>
<li>Plugin1：Waka Time</li>
</ul>
<h2 id="三、使用"><a href="#三、使用" class="headerlink" title="三、使用"></a>三、使用</h2><h3 id="样式"><a href="#样式" class="headerlink" title="样式"></a>样式</h3><ul>
<li>字体设置</li>
<li>行数显示</li>
<li>更改工作空间的默认编码</li>
<li>代码增强显示，在设置中的<code>java</code>中的<code>content Assistant</code>中，将<code>.</code>改为<code>.ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789</code></li>
</ul>
<h3 id="导入已存在的项目"><a href="#导入已存在的项目" class="headerlink" title="导入已存在的项目"></a>导入已存在的项目</h3>]]></content>
      <categories>
        <category>Environment</category>
      </categories>
  </entry>
  <entry>
    <title>npm发布第一个包</title>
    <url>/blog/auczes/</url>
    <content><![CDATA[<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>在<a href="https://www.npmjs.com/" target="_blank" rel="noopener">https://www.npmjs.com/</a>注册的用户账号<br>新建一个文件夹<code>npm-wzutao</code>再次文件夹下进入 bash</p>
<p><strong>登录 npmjs</strong><br><code>npm login</code><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612782412366-aeecc92e-a5e0-4f3d-9172-c607a5c06199.png#align=left&amp;display=inline&amp;height=112&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=223&amp;originWidth=882&amp;size=27239&amp;status=done&amp;style=none&amp;width=441" alt="image.png"><br>初始化<br><code>npm init</code><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612782805229-e691af8b-0440-4fdb-baa6-63f5089017bb.png#align=left&amp;display=inline&amp;height=441&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=881&amp;originWidth=843&amp;size=81289&amp;status=done&amp;style=none&amp;width=421.5" alt="image.png"><br>然后在该文件夹下新建 index.js 文件，写入如下测试代码</p>
<pre><code class="javascript">exports.sum = function () {
  var res = 0;

  for (var i = 0; i &lt; arguments.length; i++) {
    res += arguments[i];
  }

  return res;
};
</code></pre>
<h2 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h2><p><code>npm publish</code><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612782959102-a6d78720-76a0-472a-b0d9-430c83ce7c8b.png#align=left&amp;display=inline&amp;height=196&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=392&amp;originWidth=761&amp;size=45114&amp;status=done&amp;style=none&amp;width=380.5" alt="image.png"><br>去官网可以搜索到<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612783041850-acf55586-80aa-4cf5-b19a-7f538396fadd.png#align=left&amp;display=inline&amp;height=380&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=759&amp;originWidth=1663&amp;size=82826&amp;status=done&amp;style=none&amp;width=831.5" alt="image.png"></p>
<h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><p>【1】本地更新版本号</p>
<p><code>npm version patch</code><br>1.0.1 版本，注意，是最后一位修改了增 1<br><code>npm version minor</code><br>1.1.0 版本，注意，是第二位修改了增 1<br><code>npm version major</code><br>2.0.0 版本，注意，是第一位修改了增 1</p>
<p>【2】修改远端的版本<br>提交到远端 npm 中<br><code>npm publish</code></p>
<h2 id="下载使用"><a href="#下载使用" class="headerlink" title="下载使用"></a>下载使用</h2><p>新建一个测试文件夹下载该包，会得到</p>
<pre><code>│  package-lock.json
│
└─node_modules
    └─npm-wzutao
            index.js
            package.json
</code></pre>]]></content>
      <categories>
        <category>Web</category>
      </categories>
  </entry>
  <entry>
    <title>约束</title>
    <url>/blog/bhcyvg/</url>
    <content><![CDATA[<h2 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h2><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>根据列的数目分为：</p>
<ul>
<li>列级约束<ul>
<li>对一个数据列建立的约束，称为列级约束</li>
<li>NOT NULL 和 DEFAULT 只有列级约束</li>
<li>其他三个有表级约束</li>
</ul>
</li>
<li>表级约束<ul>
<li>对多个数据列建立的约束，称为表级约束</li>
</ul>
</li>
</ul>
<p>列级约束可以在列定义时声明，也可以在列定义后声明。<br>表级约束只能在列定义后声明。</p>
<p>根据功能分为：</p>
<table>
<thead>
<tr>
<th>代码</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>NOT NULL</td>
<td>非空约束</td>
</tr>
<tr>
<td>PRIMARY KEY</td>
<td>主键约束</td>
</tr>
<tr>
<td>UNIQUE</td>
<td>唯一约束</td>
</tr>
<tr>
<td>DEFAULT</td>
<td>默认约束</td>
</tr>
<tr>
<td>FOREGIN KEY</td>
<td>外键约束</td>
</tr>
</tbody>
</table>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ul>
<li>父表和子表具有相同的存储引擎（–InnoDB–）</li>
<li>外键列和参照列必须具有相似的数据类型<ul>
<li>其中数字的长度或是否有符号必须相同</li>
<li>字符的长度可以不同</li>
</ul>
</li>
<li>外键列和参照列必须创建 _索引_，如果外键列不存在索引，MySQL 会自动帮其创建，但是不会自动帮参照列创建</li>
</ul>
<blockquote>
<p>父表：具有参照列的是父表，比如省份与人中的省份。<br>子表：具有外键列的是子表，比如人</p>
</blockquote>
<h3 id="外键约束的参照操作"><a href="#外键约束的参照操作" class="headerlink" title="外键约束的参照操作"></a>外键约束的参照操作</h3><ul>
<li>CASEADE //更新（删除）父表（中的行），子表也随之更新</li>
<li>SET NULL</li>
<li>RESTRICT</li>
<li>NO ACTION //标准的 SQL 关键字，功能与 MySQL 中的 RESTRICT 相同。</li>
</ul>
]]></content>
      <categories>
        <category>Language</category>
      </categories>
  </entry>
  <entry>
    <title>TSP问题</title>
    <url>/blog/bkbll1/</url>
    <content><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>假设有 n 个城市，各个城市与城市间的距离也已知，有一位旅行商需要途径所有的这 n 个城市，且每个城市只能且必须经过以此，求出一条路线，使得旅行商所走过的路程最短</p>
<h2 id="问题思路"><a href="#问题思路" class="headerlink" title="问题思路"></a>问题思路</h2><h2 id="代码思路"><a href="#代码思路" class="headerlink" title="代码思路"></a>代码思路</h2><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://jerkwin.github.io/2016/03/17/%E6%97%85%E8%A1%8C%E6%8E%A8%E9%94%80%E5%95%86%E9%97%AE%E9%A2%98TSP%E7%9A%84%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E8%A7%A3%E6%B3%95/" target="_blank" rel="noopener">旅行推销商问题 TSP 的动态规划解法</a></li>
<li><a href="https://blog.csdn.net/joekwok/article/details/4749713" target="_blank" rel="noopener">TSP(旅行者问题)——动态规划详解</a></li>
</ul>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>Photoshop使用</title>
    <url>/blog/bkthv9/</url>
    <content><![CDATA[<h2 id="基本工具"><a href="#基本工具" class="headerlink" title="基本工具"></a>基本工具</h2><blockquote>
<p>认识 PS===有许多功能 eg：绘画等等<br>准备工作===了解菜单栏；工具栏；基本功能</p>
</blockquote>
<h3 id="图层面板的认识"><a href="#图层面板的认识" class="headerlink" title="图层面板的认识"></a>图层面板的认识</h3><p>图层顺序 上一层遮挡下一层 蒙版也是图层<br>混合模式 就是这层图层与下一层混合叠加的效果<br>@@滤色 就是消去黑色深色只显示白色亮色的部分 案例光晕 用黑背景绘画光晕的图案选择滤色混合样式<br>图层样式<br>不透明<br>创建 删除 解锁</p>
<h3 id="图片的裁切"><a href="#图片的裁切" class="headerlink" title="图片的裁切"></a>图片的裁切</h3><p>选框工具不行===无法确定像素 不能缩放要显示的区域<br>裁剪工具不行===能确定像素 但不能缩放要显示的区域只是同时裁剪图片和画布<br>图像===大小不行–只是压缩图片和画布而已<br>画布大小（前提是图层不是背景层没有被锁定）<br>调整画布的大小+自由变换工具缩放+移动工具<br>我们想要的大小 调整图像等比例缩放 移动到我们要显示的区域</p>
<h3 id="蒙版作用"><a href="#蒙版作用" class="headerlink" title="蒙版作用"></a>蒙版作用</h3><p>蒙版只有白和黑 只是在通道建立一个白色的蒙版图层（默认全部显示；有选区时，选区是白色的非选区是黑色的）<br>黑透明，白不透明<br>画笔涂抹 透明度 流量<br>一般用来合成图片<br>对图像擦除的效果 但不影响原始图像的像素 便于后期修改<br>如果用橡皮擦会破坏原始素材</p>
<h3 id="正确校色"><a href="#正确校色" class="headerlink" title="正确校色"></a>正确校色</h3><p>图像-调整===对图像校色是不可逆的 不适合后期修改<br>创建新的填充和调整图层的按钮 添加带蒙版的调整图层<br>带蒙版的调整图层 是可逆的<br>如果想只对**一个图层作用 右击图层-创建剪切蒙版</p>
<h3 id="钢笔工具"><a href="#钢笔工具" class="headerlink" title="钢笔工具"></a>钢笔工具</h3><p>点击-点击===是直线<br>点击-点击不要松开手===拖动 就是曲线勒<br>alt+ 点击瞄点拖拉会产生操纵杆===并且把直线变成曲线<br>点击单个操纵杆会单独操纵一边的<br>crtl+ 移动瞄点<br>属性栏【自动添加/删除】打勾时 点击线能添加点 点击点不拖动能删除点<br>描绘到一半的没闭合的图层 要闭合的话就要先 ctrl 点击最后一点 在点击初始点<br>抠出的区域转为选区 选中图层 点击路径面板-将路径转为选区<br>这时候的选区可以 建立蒙版把他抠出来单独单独显示 这种抠图是可逆的</p>
<h3 id="修片时用到的工具"><a href="#修片时用到的工具" class="headerlink" title="修片时用到的工具"></a>修片时用到的工具</h3><p>红眼 ===记得是整个眼睛<br>污点 ===可以吧污点附近的像素自动修改污点 但是对麻子脸没用<br>修复画笔 ===把目标的像素填充涂抹的地方 并且能自动融合边缘<br>修补工具 ===框选一个目标选区 填充涂抹的地方 并且能自动融合边缘</p>
<p>##</p>
]]></content>
      <categories>
        <category>PostProduction</category>
      </categories>
  </entry>
  <entry>
    <title>JAVA-继承和多态</title>
    <url>/blog/bn6afv/</url>
    <content><![CDATA[<h2 id="extends-和-super"><a href="#extends-和-super" class="headerlink" title="extends 和 super"></a>extends 和 super</h2><ul>
<li><strong>子类继承父类用关键字 <code>extends</code> </strong></li>
<li>super 关键字作用有<ul>
<li>继承父类的构造函数</li>
<li>构造方法链</li>
<li>调用父类的方法（一般不怎么用）</li>
</ul>
</li>
</ul>
<h2 id="方法重写和方法重载"><a href="#方法重写和方法重载" class="headerlink" title="方法重写和方法重载"></a>方法重写和方法重载</h2><blockquote>
<p>方法重写注意要子类和父类的方法都得是一样的签名和返回类型</p>
</blockquote>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1600089343780-c8d0a28c-dc06-4aab-a331-9ac926a65498.png#align=left&amp;display=inline&amp;height=289&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=577&amp;originWidth=764&amp;size=325094&amp;status=done&amp;style=shadow&amp;width=382" alt="image.png"></p>
<p>为了避免编写程序过程中方法重载和方法重写的误用，使用<strong>重写标注 <code>@Override</code></strong> 来区分，系统可以检查方法的正确性。</p>
<h2 id="Object-类"><a href="#Object-类" class="headerlink" title="Object 类"></a>Object 类</h2><blockquote>
<p>java 中所有类都继承子 java.lang.Object 类，其中 toString 就是该类里面的方法之一，所有许多接口/类都会重写这个方法，手写的链表里面的该方法就是重写之后的方法</p>
</blockquote>
<h2 id="多态与动态绑定"><a href="#多态与动态绑定" class="headerlink" title="多态与动态绑定"></a>多态与动态绑定</h2><blockquote>
<p>多态</p>
</blockquote>
<p>使用夫类对象的地方都可以使用子类对象。也就意味着父类的变量可以引用子类型的对象</p>
<blockquote>
<p>动态绑定</p>
</blockquote>
<p>如果定义了一个父类的对象，该对象调用了一个方法，该方法不存在父类当中，但是存在其父类下面的多个子类当中，那么这个方法调用的是哪个子类当中的该方法呢？JVM 有这么一个机制，从“辈分最小的类”依次往上找，第一个找到含有该方法的类，则调用该类当中的那个方法<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1600138148812-5cc991ce-0577-4f01-b57c-bec631518a99.png#align=left&amp;display=inline&amp;height=109&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=217&amp;originWidth=960&amp;size=14420&amp;status=done&amp;style=shadow&amp;width=483" alt="image.png"><br>注：Cn 为父类，往后都是以此继承的子类</p>
<h2 id="对象转换"><a href="#对象转换" class="headerlink" title="对象转换"></a>对象转换</h2><blockquote>
<p>向下转换与向上转换</p>
</blockquote>
<pre><code class="java">Object o = new Student(); // 可以：因为Student的实例也是Object的实例

Student a = o; // (o是Object对象)不可以：因为“级别”的不可逆

Student s = Student(o); //向上转换
</code></pre>
<blockquote>
<p>instanceof</p>
</blockquote>
<p>如果一个对象不是 Student 实例，他就不能转换成 Student 类型的变量，会报错 <code>ClassCastException</code> 。因此，在此之前最好先确保该对象是另一个对象的实例，于是用到关键字 <code>instanceof</code></p>
<pre><code class="java">Object myObject = new Circle();
... // Some lines of code
/** Perform casting if myObject is an instance of Circle */
if (myObject instanceof Circle) {
  System.out.println(&quot;The circle diameter is &quot; +
    ((Circle)myObject).getDiameter());
  ...
}
</code></pre>
<h2 id="override"><a href="#override" class="headerlink" title="@override"></a>@override</h2><p>在重写父类的函数时，在方法前面加上<a href="https://www.yuque.com/Override" target="_blank" rel="noopener">@Override </a> 系统可以帮你检查方法的正确性。</p>
]]></content>
      <categories>
        <category>Language</category>
      </categories>
  </entry>
  <entry>
    <title>莱文斯坦距离(LD)问题</title>
    <url>/blog/bvk4ok/</url>
    <content><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p><strong>Levenshtein Distance</strong>也称<strong>莱文斯坦距离</strong></p>
<p>具体形式就是求一个字符串到另一个字符串所需要的<strong>最少操作步数</strong>，操作形式有：</p>
<ul>
<li>替换字母</li>
<li>删除字母</li>
<li>插入字母</li>
</ul>
<h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>利用动态规划思想，将其剖析为一个个子问题，用其子问题的解决方式来解决该问题。问题分解出来的子问题存在重叠的情况，这是区分分治算法的不同。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1603615056984-36cbce7c-c55e-456a-bb90-eb18471167e0.png#align=left&amp;display=inline&amp;height=335&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=670&amp;originWidth=1026&amp;size=202356&amp;status=done&amp;style=shadow&amp;width=513" alt="image.png"></p>
<p><strong>莱文斯坦的公式化</strong>表述为：<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1603614727015-dad259b0-7904-4e5d-9ec8-f4ac284af2e5.png#align=left&amp;display=inline&amp;height=94&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=188&amp;originWidth=874&amp;size=23400&amp;status=done&amp;style=shadow&amp;width=437" alt="image.png"></p>
<p>下面利用表格的形式来步步推出该字母所需要达到相应的目标字母序列的步数。</p>
<p>| |<br>| s | o | n |<br>| — | — | — | — | — |<br>|<br>| 0 | 1 | 2 | 3 |<br>| s | 1 | 0 | 1 | 2 |<br>| u | 2 | 1 | 1 | 2 |<br>| n | 3 | 2 | 2 | 1 |</p>
<p>记横（son）为 i 字符串序列，纵（sun）为 j 字符串序列。需要完成的字符串变换为 i-&gt;j。现举例格子数值该怎么填：</p>
<p>当到了第三行第三列的那一格，需要完成 s-&gt;s，有三种情况可以选择</p>
<ol>
<li>左操作(i-1,j)：删除 s 字符然后插入 s 字符===操作步数两步</li>
<li>上操作(i,j-1)：插入 s 字符然后删除 s 字符===操作步数两步</li>
<li>左上操作(i-1,j-1)：替换步骤，因为这个元素相同，故===操作步数零部</li>
</ol>
<p>然后选取上述三种情况最短步数的数值 0</p>
<p>然后再看第三行第四列，需要完成 so-&gt;s，</p>
<ol>
<li>左操作：删除 o===一步</li>
<li>上操作：插入 s 删除 so===三步</li>
<li>做上操作：替换 s 删除 o===两步</li>
</ol>
<p>综上应该填 1</p>
<p>其他格子也一样以上述方法填写。</p>
<p>有个作业遗留问题，在 CAAIS 里面每个得出的值右上标的 <code>U</code>  <code>L</code>  <code>0</code>  <code>1</code>  这些的依次顺序是怎么个顺序？<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1603615446981-23bea432-08ee-490a-9037-018ba6280c3b.png#align=left&amp;display=inline&amp;height=201&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=401&amp;originWidth=651&amp;size=49834&amp;status=done&amp;style=shadow&amp;width=325.5" alt="image.png"></p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><pre><code class="cpp">#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;ctime&gt;

const int LEN_NAME=100;

namespace NS_LSEditDist {
    using namespace std;
    void Initialization(const string &amp;x, const string &amp;y);
    int GetLSEditDist(const string &amp;x, const string &amp;y);
    void GetLSEdits(const string &amp;x, const string &amp;y);
    void Output(const string &amp;x, const string &amp;y, int OptD);
    void OutputE(const string &amp;x, const string &amp;y);
    void OutputP(const string &amp;x, const string &amp;y);
    static int m, n;
    static vector&lt;vector&lt;int&gt;&gt; E;
    static vector&lt;vector&lt;char&gt;&gt; P;
    static string xe, ye;
    void LSEditDistCaller(const string &amp;x, const string &amp;y)
    {
        Initialization(x, y);
        int OptD = GetLSEditDist(x, y);
        GetLSEdits(x, y);
        Output(x, y, OptD);
    }
    int GetLSEditDist(const string &amp;x, const string &amp;y)
    {
        for (int i = 1; i &lt;= m; i++)
            for (int j = 1; j &lt;= n; j++)
            {
                E[i][j] = min(E[i - 1][j] + 1,
                              min(E[i][j - 1] + 1,
                                  E[i - 1][j - 1] + (x[i - 1] != y[j - 1])));
                if (E[i][j] == E[i - 1][j] + 1)
                    P[i][j] = &#39;U&#39;;
                else if (E[i][j] == E[i][j - 1] + 1)
                    P[i][j] = &#39;L&#39;;
                else if (x[i - 1] != y[j - 1])
                    P[i][j] = &#39;1&#39;;
            }
        return E[m][n];
    }
    void GetLSEdits(const string &amp;x, const string &amp;y)
    {
        int i = m, j = n;
        while (i &gt; 0 || j &gt; 0)
        {
            if (P[i][j] == &#39;0&#39; || P[i][j] == &#39;1&#39;)
            {
                xe.insert(0, 1, x[i - 1]);
                ye.insert(0, 1, y[j - 1]);
                i--; j--;
            }
            else if (P[i][j] == &#39;U&#39;)
            {
                xe.insert(xe.begin(), x[i - 1]);
                ye.insert(ye.begin(), &#39;-&#39;);
                i--;
            }
            else
            {
                xe.insert(xe.begin(), &#39;-&#39;);
                ye.insert(ye.begin(), y[j - 1]);
                j--;
            }
        }
    }
    void Initialization(const string &amp;x, const string &amp;y)
    {
        m = x.length();
        n = y.length();
        E.clear();
        E.resize(m + 1, vector&lt;int&gt;(n + 1, 0));
        P.clear();
        P.resize(m + 1, vector&lt;char&gt;(n + 1, &#39;0&#39;));
        for (int j = 1; j &lt;= n; j++)
        {
            E[0][j] = j;
            P[0][j] = &#39;L&#39;;
        }
        for (int i = 1; i &lt;= m; i++)
        {
            E[i][0] = i;
            P[i][0] = &#39;U&#39;;
        }
        xe.clear();
        ye.clear();
    }
    void Output(const string &amp;x, const string &amp;y, int OptD)
    {
        printf(&quot;Levenshtein distance: \n&quot;);
        printf(&quot;Strings: %s, %s\n\n&quot;, x.c_str(), y.c_str());
        OutputE(x, y);
        OutputP(x, y);
        printf(&quot;Distance: %d\n&quot;, OptD);
        printf(&quot;Edited strings:\n&quot;);
        for (auto c : xe)
            printf(&quot;%2c&quot;, c);
        printf(&quot;\n&quot;);
        for (auto c : ye)
            printf(&quot;%2c&quot;, c);
        printf(&quot;\n\n&quot;);
    }
    void OutputE(const string &amp;x, const string &amp;y)
    {
        printf(&quot; E  &quot;);
        for (int j = 0; j &lt; n; j++)
            printf(&quot;%2c&quot;, y[j]);
        printf(&quot;\n&quot;);
        for (int i = 0; i &lt;= m; i++)
        {
            if (i == 0)
                printf(&quot;  &quot;);
            else
                printf(&quot;%2c&quot;, x[i - 1]);
            for (int j = 0; j &lt;= n; j++)
            {
                printf(&quot;%2d&quot;, E[i][j]);
            }
            printf(&quot;\n&quot;);
        }
        printf(&quot;\n&quot;);
    }
    void OutputP(const string &amp;x, const string &amp;y)
    {
        printf(&quot; P  &quot;);
        for (int j = 0; j &lt; n; j++)
            printf(&quot;%2c&quot;, y[j]);
        printf(&quot;\n&quot;);
        for (int i = 0; i &lt;= m; i++)
        {
            if (i == 0)
                printf(&quot;  &quot;);
            else
                printf(&quot;%2c&quot;, x[i - 1]);
            for (int j = 0; j &lt;= n; j++)
            {
                printf(&quot;%2c&quot;, P[i][j]);
            }
            printf(&quot;\n&quot;);
        }
        printf(&quot;\n&quot;);
    }
} //namespace NS_LSEditDist
char *rand_str(char *str,const int len)
{
    int i;
    for(i=0;i&lt;len;++i)
        str[i]=&#39;a&#39;+rand()%26;
    str[++i]=&#39;\0&#39;;
    return str;
}
using namespace NS_LSEditDist;
int main()
{
    vector&lt;vector&lt;string&gt;&gt; abs = {
            { &quot;water&quot;, &quot;wheat&quot; },
            { &quot;servant&quot;, &quot;reveal&quot; }
    };
    for (auto ab : abs)
    {
        string a = ab[0];
        string b = ab[1];
        LSEditDistCaller(a, b);
    }

    cout&lt;&lt;&quot;两个100位字符串的LevenShtein距离：&quot;&lt;&lt;endl;

    srand(time(NULL));
    int i;
    char name[LEN_NAME+1];
    string x = rand_str(name,LEN_NAME);
    string y = rand_str(name,LEN_NAME);

    cout&lt;&lt;&quot;字符串1：&quot;&lt;&lt;x&lt;&lt;endl;
    cout&lt;&lt;&quot;字符串2：&quot;&lt;&lt;y&lt;&lt;endl;

    LSEditDistCaller(x, y);
}
</code></pre>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://zh.wikipedia.org/wiki/%E8%90%8A%E6%96%87%E6%96%AF%E5%9D%A6%E8%B7%9D%E9%9B%A2" target="_blank" rel="noopener">莱文斯坦距离</a></li>
<li><a href="https://www.dazhuanlan.com/2019/12/06/5dea0cb03281f/" target="_blank" rel="noopener">理解 Levenshtein Distancee</a></li>
<li><a href="https://www.throwable.club/2020/03/08/learn-about-levenshtein-distance-algorithm/" target="_blank" rel="noopener">Levenshtein Distance（编辑距离）算法与使用场景</a></li>
</ul>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>动态数组设计</title>
    <url>/blog/bx5ouf/</url>
    <content><![CDATA[<h2 id="动态数组设计"><a href="#动态数组设计" class="headerlink" title="动态数组设计"></a>动态数组设计</h2><h3 id="接口设计"><a href="#接口设计" class="headerlink" title="接口设计"></a>接口设计</h3><pre><code class="java">public int size(); // 返回动态数组元素个数
public boolean isEmpty(); // 是否为空
public boolean contains(E element); // 是否包含某个元素
public void add(E element); // 在数组尾部添加元素
public E get(int index); // 返回index位置对应的元素
public E set(int index, E element); // 设置/更换index位置上的值
public void add (int index, E element); // 在index位置上添加元素
public E remove(int index); // 移除index位置上的值
public int indexOf(E element); // 查看元素的位置
public void clear(); // 清空动态数组所有元素
</code></pre>
<h3 id="private-设计"><a href="#private-设计" class="headerlink" title="private 设计"></a>private 设计</h3><pre><code class="java">// 元素的数量
private int size;
// 所有的元素
private E[] elements;

private static final int DEFAULT_CAPACITY = 10;
private static final int ELEMENT_NOT_FOUND = -1;

/**
     * 保证要有capacity的容量
     * @param capacity
     */
private void ensureCapacity(int capacity) {
    int oldCapacity = elements.length;
    if (oldCapacity &gt;= capacity) return;

    // 新容量为旧容量的1.5倍
    int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);
    E[] newElements = (E[]) new Object[newCapacity];
    for (int i = 0; i &lt; size; i++) {
        newElements[i] = elements[i];
    }
    elements = newElements;

    System.out.println(oldCapacity + &quot;扩容为&quot; + newCapacity);
}

private void outOfBounds(int index) {
    throw new IndexOutOfBoundsException(&quot;Index:&quot; + index + &quot;, Size:&quot; + size);
}

private void rangeCheck(int index) {
    if (index &lt; 0 || index &gt;= size) {
        outOfBounds(index);
    }
}

private void rangeCheckForAdd(int index) {
    if (index &lt; 0 || index &gt; size) {
        outOfBounds(index);
    }
}
</code></pre>
<h3 id="构造函数设计"><a href="#构造函数设计" class="headerlink" title="构造函数设计"></a>构造函数设计</h3><pre><code class="java">public ArrayList(int capaticy) {
    capaticy = (capaticy &lt; DEFAULT_CAPACITY) ? DEFAULT_CAPACITY : capaticy;
    elements = (E[]) new Object[capaticy];
}

public ArrayList() {
    this(DEFAULT_CAPACITY);
}
</code></pre>
<h3 id="重写输出"><a href="#重写输出" class="headerlink" title="重写输出"></a>重写输出</h3><pre><code class="java">@Override
public String toString() {
    // size=3, [99, 88, 77]
    StringBuilder string = new StringBuilder();
    string.append(&quot;size=&quot;).append(size).append(&quot;, [&quot;);
    for (int i = 0; i &lt; size; i++) {
        if (i != 0) {
            string.append(&quot;, &quot;);
        }

        string.append(elements[i]);

        //            if (i != size - 1) {
        //                string.append(&quot;, &quot;);
        //            }
    }
    string.append(&quot;]&quot;);
    return string.toString();
}
</code></pre>
]]></content>
      <categories>
        <category>DataStructure</category>
      </categories>
  </entry>
  <entry>
    <title>GitHub+PicGo构建免费图床及其高效使用</title>
    <url>/blog/bzf30z/</url>
    <content><![CDATA[<h2 id="一、搭建缘由"><a href="#一、搭建缘由" class="headerlink" title="一、搭建缘由"></a>一、搭建缘由</h2><p>一开始搭建博客，避免不了要用许多图片，最初使用七牛云来做博客图床，但是后来发现，七牛云只有 30 天的临时域名，hhhhhhh，果然啊，天下就没有免费的好事啊~后来就发现 GitHub 配合 PicGo 可以作图床，而且加上 jsDlivr 速度可观。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1602926956661-8671ebfe-4f99-494d-b759-a9c75cd67b41.png#align=left&amp;display=inline&amp;height=670&amp;margin=%5Bobject%20Object%5D&amp;originHeight=670&amp;originWidth=807&amp;size=0&amp;status=done&amp;style=stroke&amp;width=807" alt></p>
<h2 id="二、GitHub-相关配置"><a href="#二、GitHub-相关配置" class="headerlink" title="二、GitHub 相关配置"></a>二、GitHub 相关配置</h2><h3 id="新建-figure-图床仓库"><a href="#新建-figure-图床仓库" class="headerlink" title="新建 figure 图床仓库"></a>新建 figure 图床仓库</h3><p>常规新建仓库方式，命名 figure<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1602926957158-9c7f8749-4d8e-4bc9-9e1c-7d3db5a307b1.png#align=left&amp;display=inline&amp;height=241&amp;margin=%5Bobject%20Object%5D&amp;originHeight=241&amp;originWidth=1812&amp;size=0&amp;status=done&amp;style=stroke&amp;width=1812" alt></p>
<h3 id="生成一个-Token-密匙"><a href="#生成一个-Token-密匙" class="headerlink" title="生成一个 Token 密匙"></a>生成一个 Token 密匙</h3><p>点击 setting<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1602926956634-4c139fbc-0469-4749-89b8-f139226aa7d2.png#align=left&amp;display=inline&amp;height=904&amp;margin=%5Bobject%20Object%5D&amp;originHeight=904&amp;originWidth=1823&amp;size=0&amp;status=done&amp;style=stroke&amp;width=1823" alt><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1605839703428-b18e3c24-48e0-44ed-9715-81fcd822d4e8.png#align=left&amp;display=inline&amp;height=237&amp;margin=%5Bobject%20Object%5D&amp;originHeight=444&amp;originWidth=1120&amp;size=0&amp;status=done&amp;style=stroke&amp;width=599" alt><br><strong>只需要勾选第一个仓库选项就可以了！</strong></p>
<h2 id="三、PicGo-相关配置"><a href="#三、PicGo-相关配置" class="headerlink" title="三、PicGo 相关配置"></a>三、PicGo 相关配置</h2><h3 id="下载及注意事项"><a href="#下载及注意事项" class="headerlink" title="下载及注意事项"></a>下载及注意事项</h3><p><a href="https://github.com/Molunerfinn/PicGo/releases" target="_blank" rel="noopener">下载地址</a><br>注意：下载 picgo 时候，要科学上网</p>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1602926956815-db5cf455-f628-4c4d-9242-1687e15a7f03.png#align=left&amp;display=inline&amp;height=564&amp;margin=%5Bobject%20Object%5D&amp;originHeight=564&amp;originWidth=1002&amp;size=0&amp;status=done&amp;style=none&amp;width=1002" alt></p>
<h2 id="四、高效写博客"><a href="#四、高效写博客" class="headerlink" title="四、高效写博客"></a>四、高效写博客</h2><h3 id="Snipaste-截图软件"><a href="#Snipaste-截图软件" class="headerlink" title="Snipaste 截图软件"></a>Snipaste 截图软件</h3><blockquote>
<p><strong>常用</strong>快捷键【作者是用的惠普笔记本电脑，不同电脑键盘的使用方式会不一样】</p>
</blockquote>
<p>fn+f1：截屏（可编辑）<br>esc：退出<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1602926956785-4e12ba13-c4c6-4e5a-9758-5d3de27f9718.png#align=left&amp;display=inline&amp;height=446&amp;margin=%5Bobject%20Object%5D&amp;originHeight=446&amp;originWidth=553&amp;size=0&amp;status=done&amp;style=stroke&amp;width=553" alt></p>
<h3 id="结合-PicGo-使用"><a href="#结合-PicGo-使用" class="headerlink" title="结合 PicGo 使用"></a>结合 PicGo 使用</h3><p>PicGo+Snipaste 快捷键结合<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1602926956619-08d5eae3-3b21-42cc-a2d8-85d6d2f8ed62.png#align=left&amp;display=inline&amp;height=220&amp;margin=%5Bobject%20Object%5D&amp;originHeight=220&amp;originWidth=847&amp;size=0&amp;status=done&amp;style=stroke&amp;width=847" alt></p>
<h3 id="综合使用-SOP"><a href="#综合使用-SOP" class="headerlink" title="综合使用 SOP"></a>综合使用 SOP</h3><ol>
<li>按<code>fn+f1</code>截完图，再按<code>ctrl+c</code>将刚刚截图放到剪贴板</li>
<li>再按<code>ctrl+shift+p</code>使用 picgo 快捷键将剪贴板上的图片上传同时将此时图片的外链复制到剪贴板</li>
</ol>
<h2 id="五、相关补充"><a href="#五、相关补充" class="headerlink" title="五、相关补充"></a>五、相关补充</h2><h3 id="上传失败"><a href="#上传失败" class="headerlink" title="上传失败"></a>上传失败</h3><p><code>问题1：有些时候上传picgo时，会出现配置报错的情况</code></p>
<blockquote>
<p>方案 1：在 picgo 的配置中，改一下文件夹名字（相当于在仓库下新建一个文件夹），就比如本来存到 blogarticle3/文件夹下，改成 blogarticle4/就好了<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1602926956579-eafc7cfa-1e0b-41be-ae5b-c6560b8c7638.png#align=left&amp;display=inline&amp;height=186&amp;margin=%5Bobject%20Object%5D&amp;originHeight=186&amp;originWidth=1320&amp;size=0&amp;status=done&amp;style=none&amp;width=1320" alt><br>方案 2：将下图所示的<code>上传前重命名</code>打开同时<code>设置Server</code>内容开换成关，关换成开，玄学……<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1602926956785-fb091672-3c17-49db-a0e7-965e20c93f5c.png#align=left&amp;display=inline&amp;height=564&amp;margin=%5Bobject%20Object%5D&amp;originHeight=564&amp;originWidth=1002&amp;size=0&amp;status=done&amp;style=none&amp;width=1002" alt><br>方案 3：将 PicGo 软件叉掉重新运行。玄学····<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1602926957260-3a981036-cd74-4a90-8665-d2510470f2c9.png#align=left&amp;display=inline&amp;height=564&amp;margin=%5Bobject%20Object%5D&amp;originHeight=564&amp;originWidth=1002&amp;size=0&amp;status=done&amp;style=none&amp;width=1002" alt><br>方案 4（最优方案）：科学上网</p>
</blockquote>
<h3 id="关于插件"><a href="#关于插件" class="headerlink" title="关于插件"></a>关于插件</h3><p>在插件列表里面下载这三个拓展插件，其中两个国内的托管 coding 和 gitee，还有一个 github plus 版本，不过觉得国内的外链范围肯定是要小一点的应该，最好是优先使用 github 图床，coding 和 gitee 的作为文章使用，有关博客配置的使用 CDN 等。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1602926956548-b7b5ad1b-2586-42c5-8f7d-9dd17c265fcf.png#align=left&amp;display=inline&amp;height=341&amp;margin=%5Bobject%20Object%5D&amp;originHeight=341&amp;originWidth=771&amp;size=0&amp;status=done&amp;style=none&amp;width=771" alt></p>
<h4 id="Coding-配置"><a href="#Coding-配置" class="headerlink" title="Coding 配置"></a>Coding 配置</h4><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1602926956265-035a546d-2ecd-48c3-8eec-c9ef7779653b.png#align=left&amp;display=inline&amp;height=486&amp;margin=%5Bobject%20Object%5D&amp;originHeight=486&amp;originWidth=739&amp;size=0&amp;status=done&amp;style=none&amp;width=739" alt></p>
<h4 id="gitee-配置"><a href="#gitee-配置" class="headerlink" title="gitee 配置"></a>gitee 配置</h4><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1602926956286-859465c2-411f-4761-8921-526656b8a191.png#align=left&amp;display=inline&amp;height=568&amp;margin=%5Bobject%20Object%5D&amp;originHeight=568&amp;originWidth=778&amp;size=0&amp;status=done&amp;style=none&amp;width=778" alt></p>
<h4 id="GitHub-plus-配置"><a href="#GitHub-plus-配置" class="headerlink" title="GitHub plus 配置"></a>GitHub plus 配置</h4><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1602926956274-6e705ace-8e6f-4226-9fae-ffaaa66a2aa9.png#align=left&amp;display=inline&amp;height=517&amp;margin=%5Bobject%20Object%5D&amp;originHeight=517&amp;originWidth=727&amp;size=0&amp;status=done&amp;style=none&amp;width=727" alt></p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
  </entry>
  <entry>
    <title>RSA公钥密码算法</title>
    <url>/blog/ccd10c/</url>
    <content><![CDATA[<blockquote>
<p>最近利用自己曾经写过的一篇文章『<a href="https://www.wztlink1013.com/blog/bw80k6/">https://www.wztlink1013.com/blog/bw80k6/</a>』（利用一次抓包来复习学习过的计网知识）</p>
</blockquote>
<p>在分析 HTTPS 和 HTTP 这两个协议之间的区别的时候，我感觉 HTTPS 的 SSL(Secure Sockets Layer 安全套接字协议)证书很类似之前老师讲过的 RSA 算法，做此篇文章复习下 RSA 算法和加深 HTTPS 的理解。</p>
<p>在密码学当中，由对称密钥和非对称密钥之分。</p>
<h2 id="对称密钥"><a href="#对称密钥" class="headerlink" title="对称密钥"></a>对称密钥</h2><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612943343546-b8330998-9019-40a1-9759-12b459d5379b.png#align=left&amp;display=inline&amp;height=345&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=690&amp;originWidth=982&amp;size=266245&amp;status=done&amp;style=stroke&amp;width=491" alt="image.png"><br>用一个简单的凯撒密码例子来讲解一下对称密钥：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612943823633-5283daed-a125-46fd-a785-93851daf5269.png#align=left&amp;display=inline&amp;height=325&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=650&amp;originWidth=957&amp;size=205858&amp;status=done&amp;style=stroke&amp;width=478.5" alt="image.png"><br>上图是凯撒密码的定义，先说一下怎么用：</p>
<p>假如张三和李四两个人之间需要传输一段密码 apple，他们之间共同约定使用密钥-3（再上图表示就为 e 字母编程 b 字母了，以此类推），而这个算法是基于<a href="https://zh.wikipedia.org/wiki/%E6%A8%A1%E9%99%A4" target="_blank" rel="noopener">mod 运算</a>（在这里看成是一种加密/解密机制）的。</p>
<p>张三利用 mod 运算加密机制（mod 运算）将 apple 转换位 xmmfb<br>李四利用 mod 运算解密机制（mod 运算）将 xmmfb 转换位 apple</p>
<blockquote>
<p>a 为什么到 x：（0-3）mod26 可以看成（23-26）mod26=23，所以 a 往后退三位还是 x</p>
</blockquote>
<p>上述例子的加密机制和解密机制算法一样（mod 运算），实际上也可以不一样，不做详述。但是可以说名对称加密的密钥都一样，该例子中表现为-3</p>
<h2 id="RSA-公钥密码算法"><a href="#RSA-公钥密码算法" class="headerlink" title="RSA 公钥密码算法"></a>RSA 公钥密码算法</h2><p>RSA 公钥密码算法是非对称加密。</p>
<p>先说一下和上面的对称密钥的不同，很简单，不同之处就是对称密钥只有一个密钥，而非对称密钥有两个（我觉得严谨来说可以有多个，但在这里先局限地说有两个），而且一个叫公钥，一个叫密钥。</p>
<p>还是上面的张三李四例子，就相当于张三这次用公钥来加密 apple 这个单词，加密成一段密文，这段密文<strong>只能由密钥来解密</strong>，即便是你有了公钥，也不能将其解密。</p>
<p>然后来抛出几个问题来分析之：</p>
<blockquote>
<p>【Q1】公钥和密钥怎么来规定呢？我要是一个网络攻击者，我利用公钥来推理出密钥，那我岂不是直接解密了？！</p>
</blockquote>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612945567958-1cd39a87-ba61-4dd8-955e-1a4fc130378d.png#align=left&amp;display=inline&amp;height=290&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=579&amp;originWidth=474&amp;size=117414&amp;status=done&amp;style=stroke&amp;width=237" alt="image.png"><br>具体的相关 mod 运算在此不做详述</p>
<blockquote>
<p>【Q2】算法可靠与否</p>
</blockquote>
<p>为了保证严谨，同时也证明了这种算法的</p>
<ul>
<li>可行性，所计算出来的算法复杂度最高是 4 次方，对计算机而言，可计算</li>
<li>不可攻破，在学界，大数因子分解不可行，或者说，如今的科技还不能轻易的破解</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612945767363-ee62dad7-357d-42d3-a932-78cc10d29866.png#align=left&amp;display=inline&amp;height=337&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=674&amp;originWidth=985&amp;size=269673&amp;status=done&amp;style=stroke&amp;width=492.5" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612945781929-bea0946c-3f24-472d-a4d4-3c40abd83ee3.png#align=left&amp;display=inline&amp;height=244&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=487&amp;originWidth=987&amp;size=177512&amp;status=done&amp;style=stroke&amp;width=493.5" alt="image.png"></p>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>P224.基本计算器</title>
    <url>/blog/ckr31m/</url>
    <content><![CDATA[<h2 id="问题思路"><a href="#问题思路" class="headerlink" title="问题思路"></a>问题思路</h2><p>用栈来作为临时存取非括号的求和数。对字符串进行逐个遍历，然后对遇到的每个字符串进行判断</p>
<ul>
<li>数字：将其求和到 sum 当中</li>
<li>（：将上述 sum 和符号压入栈内</li>
<li>）：将栈内的元素取出与现有 sum 求和</li>
<li>+：直接走</li>
<li>-：直接走不过给下一个计算数提前加负号</li>
</ul>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><pre><code class="java">package com.wztlink1013.problems.leetcode.editor.cn;

// P224.基本计算器
//实现一个基本的计算器来计算一个简单的字符串表达式的值。
//
// 字符串表达式可以包含左括号 ( ，右括号 )，加号 + ，减号 -，非负整数和空格 。
//
// 示例 1:
//
// 输入: &quot;1 + 1&quot;
//输出: 2
//
//
// 示例 2:
//
// 输入: &quot; 2-1 + 2 &quot;
//输出: 3
//
// 示例 3:
//
// 输入: &quot;(1+(4+5+2)-3)+(6+8)&quot;
//输出: 23
//
// 说明：
//
//
// 你可以假设所给定的表达式都是有效的。
// 请不要使用内置的库函数 eval。
//
// Related Topics 栈 数学
// 👍 309 👎 0

import java.util.Stack;

public class P224BasicCalculator{
    public static void main(String[] args) {
        Solution solution = new P224BasicCalculator().new Solution();
        int key_1 = solution.calculate(&quot;7896979&quot;);
        int key_2 = solution.calculate(&quot;(23-2)-33+1111&quot;);
        System.out.println(key_1);
        System.out.println(key_2);
    }

//leetcode submit region begin(Prohibit modification and deletion)
class Solution {
    public int calculate(String s) {
        Stack&lt;Integer&gt; stack_1 = new Stack&lt;Integer&gt;();
        int sum = 0;
        int sign = 1;
        int num = 0;

        for (int i=0;i&lt;s.length();i++) {
            char ch = s.charAt(i);
            if (Character.isDigit(ch)) {
                num = 10 * num + (int) (ch - &#39;0&#39;);
            } else if (ch == &#39;+&#39;) {
                num = num * sign;
                sum = sum + num;
                sign = 1;
                num = 0;
            } else if (ch == &#39;-&#39;) {
                num = num * sign;
                sum = sum + num;
                sign = -1;
                num = 0;
            } else if (ch == &#39;(&#39;) {
                stack_1.push(sum);
                stack_1.push(sign);
                sum = 0;
                num = 0;
                sign = 1;
            } else if (ch == &#39;)&#39;) {
                num = num * sign;
                sum = sum + num;
                sum = stack_1.pop() * sum;
                sum = sum + stack_1.pop();
                num = 0;
                sign = 1;
            }

        }
        sum = sum + sign * num;
        return sum;
    }}
//leetcode submit region end(Prohibit modification and deletion)

}
</code></pre>
]]></content>
      <categories>
        <category>DataStructure</category>
      </categories>
      <tags>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>配置java开发环境</title>
    <url>/blog/cwqx6l/</url>
    <content><![CDATA[<h2 id="一、下载"><a href="#一、下载" class="headerlink" title="一、下载"></a>一、下载</h2><p><a href="https://www.oracle.com/cn/java/technologies/javase-downloads.html" target="_blank" rel="noopener">https://www.oracle.com/cn/java/technologies/javase-downloads.html</a></p>
<h2 id="二、环境变量配置"><a href="#二、环境变量配置" class="headerlink" title="二、环境变量配置"></a>二、环境变量配置</h2><p><strong>在系统变量下</strong></p>
<h3 id="CLASSPATH"><a href="#CLASSPATH" class="headerlink" title="CLASSPATH"></a>CLASSPATH</h3><blockquote>
<p>.;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar;%CATALINA_HOME%\common\lib\servlet-api.jar;</p>
</blockquote>
<p>其中<code>%CATALINA_HOME%\common\lib\servlet-api.jar;</code>为 tomcat 的加包配置</p>
<h3 id="JAVA-HOME"><a href="#JAVA-HOME" class="headerlink" title="JAVA_HOME"></a>JAVA_HOME</h3><blockquote>
<p>C:\Program Files\Java\jdk1.8.0_181</p>
</blockquote>
<h3 id="path"><a href="#path" class="headerlink" title="path"></a>path</h3><blockquote>
<p>%JAVA_HOME%\bin<br>%JAVA_HOME%\jre\bin</p>
</blockquote>
<h2 id="三、测试"><a href="#三、测试" class="headerlink" title="三、测试"></a>三、测试</h2><p>CMD 下输入<code>java -version</code></p>
]]></content>
      <categories>
        <category>Environment</category>
      </categories>
  </entry>
  <entry>
    <title>穷举+洗牌算法</title>
    <url>/blog/czgm7d/</url>
    <content><![CDATA[<h2 id="穷举思想"><a href="#穷举思想" class="headerlink" title="穷举思想"></a>穷举思想</h2><p>穷举法就是针对问题可能出现的结果，对其逐个进行测验并得出是否为符合要求的结果，穷举法也是许多高级算法中的某个部分。有点像高中数学里面的对问题进行分类讨论的过程中，寻找所有的情况的异曲同工之处。</p>
<h3 id="两部分组成"><a href="#两部分组成" class="headerlink" title="两部分组成"></a>两部分组成</h3><ol>
<li>系统化地枚举问题各种可能的候选解</li>
<li>检查验证每一个候选解是否满足问题的求解要求</li>
</ol>
<h3 id="穷举的抽象算法伪代码"><a href="#穷举的抽象算法伪代码" class="headerlink" title="穷举的抽象算法伪代码"></a>穷举的抽象算法伪代码</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1599469820927-b990d8a2-9025-4f33-becb-46a03890bf07.png#align=left&amp;display=inline&amp;height=323&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=645&amp;originWidth=1097&amp;size=223732&amp;status=done&amp;style=shadow&amp;width=548.5" alt="image.png"></p>
<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1599475674143-ee86ef49-1b68-4940-baef-e556f225e43d.png#align=left&amp;display=inline&amp;height=297&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=594&amp;originWidth=1056&amp;size=159618&amp;status=done&amp;style=shadow&amp;width=528" alt="image.png"></p>
<h2 id="问题思路"><a href="#问题思路" class="headerlink" title="问题思路"></a>问题思路</h2><ul>
<li>在 1~n-1 当中随机选择一个数 k1，将其与第 n 个数互换；</li>
<li>在 1~n-2 当中随机选择一个属 k2，将其与第 n-1 个数互换；</li>
<li>在第 i 轮之后，1~n-<strong>(i-1)</strong>当中选择一个数 ki，将其与第 n-<strong>(i-1)</strong>个数互换；</li>
</ul>
<h2 id="代码思路"><a href="#代码思路" class="headerlink" title="代码思路"></a>代码思路</h2><ul>
<li>在区间之间随机数的生成</li>
<li>交换函数</li>
<li>泛型：支持各种类型数据的“洗牌”</li>
</ul>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2>]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>VuePress初体验</title>
    <url>/blog/czl3oc/</url>
    <content><![CDATA[<h2 id="安装-Yarn"><a href="#安装-Yarn" class="headerlink" title="安装 Yarn"></a>安装 Yarn</h2><blockquote>
<p>Yarn 是为了弥补 npm 的一些缺陷而生的</p>
</blockquote>
<p>具体参考：<a href="https://zhuanlan.zhihu.com/p/27449990" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/27449990</a></p>
<h3 id="引导式安装"><a href="#引导式安装" class="headerlink" title="引导式安装"></a>引导式安装</h3><p><a href="https://classic.yarnpkg.com/zh-Hans/docs/install#windows-stable" target="_blank" rel="noopener">下载地址</a><br>使用 Windows 版的下载安装即可<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1608540352757-ed3ef592-f042-4262-9378-42aa9d053fcd.png#align=left&amp;display=inline&amp;height=35&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=69&amp;originWidth=433&amp;size=3803&amp;status=done&amp;style=none&amp;width=216.5" alt="image.png"></p>
<h3 id="bash-安装"><a href="#bash-安装" class="headerlink" title="bash 安装"></a>bash 安装</h3><p>在 bash 里面不能显示，在 bash 里面下载<br><code>npm install -g yarn</code> 即可</p>
<h2 id="将-VuePress-安装为本地依赖"><a href="#将-VuePress-安装为本地依赖" class="headerlink" title="将 VuePress 安装为本地依赖"></a>将 VuePress 安装为本地依赖</h2><h3 id="yarn-init"><a href="#yarn-init" class="headerlink" title="yarn init"></a>yarn init</h3><p>yarn init 出错</p>
<pre><code class="bash">error An unexpected error occurred: &quot;Can&#39;t answer a question unless a user TTY&quot;. info If you think t
</code></pre>
<p><strong>使用 cmd 或者 power shell 不要使用 bash</strong><br>**</p>
<h3 id="yarn-add-D-vuepress"><a href="#yarn-add-D-vuepress" class="headerlink" title="yarn add -D vuepress"></a>yarn add -D vuepress</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1608541125538-3124ff43-0574-4bfd-a290-908621b54644.png#align=left&amp;display=inline&amp;height=272&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=543&amp;originWidth=1920&amp;size=147908&amp;status=done&amp;style=none&amp;width=960" alt="image.png"></p>
<h3 id="创建一篇文章"><a href="#创建一篇文章" class="headerlink" title="创建一篇文章"></a>创建一篇文章</h3><p>在 bash 创建，在 powershell 里面创建会报错</p>
<pre><code class="bash">mkdir docs &amp;&amp; echo &#39;# Hello VuePress&#39; &gt; docs/README.md
</code></pre>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1608541380531-3ad1565f-0eef-4dac-bebf-64d1a131d7f3.png#align=left&amp;display=inline&amp;height=105&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=210&amp;originWidth=1160&amp;size=36343&amp;status=done&amp;style=none&amp;width=580" alt="image.png"></p>
<h3 id="添加脚本"><a href="#添加脚本" class="headerlink" title="添加脚本"></a>添加脚本</h3><pre><code class="json">{
  &quot;name&quot;: &quot;my-site&quot;,
  &quot;version&quot;: &quot;1.0.0&quot;,
  &quot;main&quot;: &quot;index.js&quot;,
  &quot;license&quot;: &quot;MIT&quot;,
  &quot;devDependencies&quot;: {
    &quot;vuepress&quot;: &quot;^1.7.1&quot;
  },
  &quot;scripts&quot;: {
    &quot;docs:dev&quot;: &quot;vuepress dev docs&quot;,
    &quot;docs:build&quot;: &quot;vuepress build docs&quot;
  }
}
</code></pre>
<h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1608541418296-b53b29dc-f6a9-480f-b65d-009a21c0d013.png#align=left&amp;display=inline&amp;height=237&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=474&amp;originWidth=951&amp;size=59046&amp;status=done&amp;style=none&amp;width=475.5" alt="image.png"><br>端口访问：<a href="http://localhost:8080/" target="_blank" rel="noopener">http://localhost:8080/</a></p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>vuepress</tag>
      </tags>
  </entry>
  <entry>
    <title>时间格式UTC、GMT、GST</title>
    <url>/blog/delag2/</url>
    <content><![CDATA[<h2 id="一、三者区别与关系"><a href="#一、三者区别与关系" class="headerlink" title="一、三者区别与关系"></a>一、三者区别与关系</h2><h3 id="UTC：世界标准时间"><a href="#UTC：世界标准时间" class="headerlink" title="UTC：世界标准时间"></a><strong>UTC：世界标准时间</strong></h3><p>协调世界时（英：Coordinated Universal Time ，法：Temps Universel Coordonné），又称世界统一时间，世界标准时间，国际协调时间。英文（CUT）和法文（TUC）的缩写不同，作为妥协，简称 UTC。</p>
<h3 id="GMT：格林尼治时间"><a href="#GMT：格林尼治时间" class="headerlink" title="GMT：格林尼治时间"></a><strong>GMT：格林尼治时间</strong></h3><p>世界时 UT   即格林尼治时间，格林尼治所在地的标准时间。以地球自转为基础的时间计量系统。地球自转的角度可用地方子午线相对于地球上的基本参考点的运动来度量。为了测量地球自转，人们在地球上选取了两个基本参考点：春分点（见分至点）和平太阳，由此确定的时间分别称为恒星时和平太阳时。</p>
<h3 id="GST：北京时间"><a href="#GST：北京时间" class="headerlink" title="GST：北京时间"></a><strong>GST：北京时间</strong></h3><p>在数据库中存放，或者给用户看的时间都是 GST 时间</p>
<h3 id="UTC-和-GST"><a href="#UTC-和-GST" class="headerlink" title="UTC 和 GST"></a><strong>UTC 和 GST</strong></h3><p>中国北京市的时间比 UTC<strong>早</strong> 8 小时</p>
<h2 id="二、UTC-与-GST-之间的转换"><a href="#二、UTC-与-GST-之间的转换" class="headerlink" title="二、UTC 与 GST 之间的转换"></a><strong>二、UTC 与 GST 之间的转换</strong></h2><h3 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h3><blockquote>
<p>2020-05-23T01:12:19.602Z</p>
</blockquote>
<ul>
<li>T：他表示后面跟的时间</li>
<li>Z：表示 UTC 统一时间</li>
<li>602：表示毫秒，如果为 6020，最后得到的时间，秒会增加 1 秒。000Z 意思就是 0 毫秒  utc 统一时间</li>
</ul>
<h3 id="java-实现"><a href="#java-实现" class="headerlink" title="java 实现"></a>java 实现</h3><pre><code class="java">package website;

import java.text.*;
import java.util.Date;

public class UTC_GST {
    public static void main(String[] args) throws ParseException {

        String date = &quot;2020-05-23T20:12:19.602Z&quot;;
        date = date.replace(&quot;Z&quot;, &quot; UTC&quot;);
        System.out.println(&quot;输入的UTC格式数据为：&quot;+date);

        SimpleDateFormat format = new SimpleDateFormat(&quot;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSS Z&quot;);
        Date d = format.parse(date);
        System.out.println(&quot;输出的背景格式数据为：&quot;+d);

    }
}
</code></pre>
<pre><code class="java">输入的UTC格式数据为：2020-05-23T20:12:19.602 UTC
输出的背景格式数据为：Sun May 24 04:12:19 CST 2020
</code></pre>
<pre><code class="java">package website;

import java.text.SimpleDateFormat;
import java.util.Date;

public class Format {
    public static void main(String[] args) {

        Date ss = new Date();
        System.out.println(&quot;一般日期输出：&quot; + ss);
        System.out.println(&quot;toString日期输出：&quot; + ss.toString());
        System.out.println(&quot;时间戳：&quot; + ss.getTime()+&quot;\n&quot;); // getTime返回的是1970年1月1号至今流逝的时间
        //Date aw = Calendar.getInstance().getTime();//获得时间的另一种方式，测试效果一样

        SimpleDateFormat format0 = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
        String time = format0.format(ss.getTime());//这个就是把时间戳经过处理得到期望格式的时间
        System.out.println(&quot;格式化结果0：&quot; + time + &quot;\n&quot;);

        SimpleDateFormat format1 = new SimpleDateFormat(&quot;yyyy年MM月dd日 HH时mm分ss秒&quot;);
        time = format1.format(ss.getTime());
        System.out.println(&quot;格式化结果1：&quot; + time + &quot;\n&quot;);
    }
}
</code></pre>
<pre><code class="java">一般日期输出：Sat May 23 15:03:25 CST 2020
toString日期输出：Sat May 23 15:03:25 CST 2020
时间戳：1590217405777

格式化结果0：2020-05-23 15:03:25

格式化结果1：2020年05月23日 15时03分25秒
</code></pre>
]]></content>
      <categories>
        <category>DataAnalysis</category>
      </categories>
  </entry>
  <entry>
    <title>P1. P18.两/四数之和</title>
    <url>/blog/dq9vp6/</url>
    <content><![CDATA[<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a>1. 两数之和</h3><pre><code class="java">class Solution {
    public int[] twoSum(int[] nums, int target) {
        for (int i = 0; i &lt; nums.length; i++) {
            for (int j = i + 1; j &lt; nums.length; j++) {
                if (nums[j] == target - nums[i]) {
                    return new int[] { i, j };
                }
            }
        }
        throw new IllegalArgumentException(&quot;No two sum solution&quot;);
    }
}
</code></pre>
<h3 id="18-四数之和"><a href="#18-四数之和" class="headerlink" title="18. 四数之和"></a>18. 四数之和</h3><pre><code class="java">class Solution {
    public List&lt;List&lt;Integer&gt;&gt; fourSum(int[] nums, int target) {
        List&lt;List&lt;Integer&gt;&gt; result = new LinkedList&lt;&gt;();
        int a = 0;
        int b = 1;
        int c = 2;
        int d = 3;
        for (int i=nums[a];i&lt;nums.length;++a){
            for (int j=nums[b];j&lt;nums.length;++b){
                for (int k=nums[c];k&lt;nums.length;++c){
                    for (int l=nums[d];l&lt;nums.length;++d){
                        if (i+j+k+l == target){
                            result.add(new LinkedList&lt;&gt;(Arrays.asList(i, j, k, l)));
                        }break;
                    }
                }
            }
        }
        return result;
    }
}
</code></pre>
<p>###</p>
]]></content>
      <categories>
        <category>DataStructure</category>
      </categories>
  </entry>
  <entry>
    <title>Premiere</title>
    <url>/blog/edproq/</url>
    <content><![CDATA[<blockquote>
<p>本文转载自：<a href="https://zhuanlan.zhihu.com/p/32130541" target="_blank" rel="noopener">5 分钟学会 Premiere 视频剪辑全流程</a></p>
</blockquote>
<h2 id="第-1-步，打开软件，新建项目"><a href="#第-1-步，打开软件，新建项目" class="headerlink" title="第 1 步，打开软件，新建项目"></a>第 1 步，打开软件，新建项目</h2><p><strong>a.</strong> 填写项目名称；</p>
<p><strong>b.</strong> 选择项目保存位置，建议建一个用于存放视频项目的文件夹；</p>
<p><strong>c.</strong> 其他的可以不用改动，点击“确定”。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1609848527644-14d127eb-6145-4323-8d7e-dc1b813b7d17.jpeg#align=left&amp;display=inline&amp;height=719&amp;margin=%5Bobject%20Object%5D&amp;originHeight=719&amp;originWidth=624&amp;size=0&amp;status=done&amp;style=none&amp;width=624" alt></p>
<p><strong>进入“面板”后</strong></p>
<p><strong>a.</strong> Ctrl+N 新建一个序列；</p>
<p><strong>b.</strong> 点击“设置”，编辑模式选择“自定义”；</p>
<p><strong>c.</strong> 帧速率我一般习惯用 23.976，也有的人喜欢用 24、25 或者是 30 帧；</p>
<p>（至于它们具体有什么区别，我在这里就不详细说了，你们可以自行百度一下）</p>
<p><strong>d.</strong> 帧大小也就是分辨率，我们通常设置为 1920*1080；</p>
<p><strong>e.</strong> 像素长宽比选择“方形像素”，场序选择“逐行”；</p>
<p><strong>f.</strong> 写上序列名称，其他的可以暂时先不研究。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1609848527668-82cc24b0-26f6-4cad-880e-b71650f5b9f4.jpeg#align=left&amp;display=inline&amp;height=797&amp;margin=%5Bobject%20Object%5D&amp;originHeight=797&amp;originWidth=720&amp;size=0&amp;status=done&amp;style=none&amp;width=720" alt></p>
<h2 id="第-2-步，将素材导入-PR"><a href="#第-2-步，将素材导入-PR" class="headerlink" title="第 2 步，将素材导入 PR"></a>第 2 步，将素材导入 PR</h2><p>在“项目面板”内的空白处单击右键导入素材，或者直接将素材选中拖入“项目面板”，如果直接选择一个文件夹的话，直接拖入项目面板，它会生成一个素材箱；</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/gif/1484158/1609848527661-1f047b51-da0e-4a8d-af96-6cadf1a8ab75.gif#align=left&amp;display=inline&amp;height=376&amp;margin=%5Bobject%20Object%5D&amp;originHeight=376&amp;originWidth=420&amp;size=0&amp;status=done&amp;style=none&amp;width=420" alt></p>
<p>也可以点击右下角的图标，新建一个素材箱，素材箱便于我们进行整理和归类。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/gif/1484158/1609848527781-1f3c610b-49e4-45e0-a13b-96df9b2fb96b.gif#align=left&amp;display=inline&amp;height=355&amp;margin=%5Bobject%20Object%5D&amp;originHeight=355&amp;originWidth=423&amp;size=0&amp;status=done&amp;style=none&amp;width=423" alt></p>
<p>除了视频和音频可以导入 PR 之外，图片和 GIF 都可以导入 PR 进行编辑。</p>
<h2 id="第-3-步，将素材拖入时间轴"><a href="#第-3-步，将素材拖入时间轴" class="headerlink" title="第 3 步，将素材拖入时间轴"></a>第 3 步，将素材拖入时间轴</h2><p><strong>剪辑工作需要在时间轴里面进行：</strong></p>
<p><strong>a.</strong> 先用鼠标点中素材不放，拖入时间轴的空白处松开就可以了；</p>
<p>（时间轴上的两个蓝条，上面的轨道是视频，下面的轨道是音频）</p>
<p><strong>b.</strong> 如果你觉得拖入整条素材太长，也可以先截选片段，鼠标按住视频画面不放，将截选的片段拖到时间轴上；</p>
<p><strong>c.</strong> 拖入时间轴后如果出现“剪辑不匹配警告”的提示，点击“保持现有设置”，然后右键点击素材，选择“缩放为帧大小”就可以了。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609848527688-a4109e9f-d436-4e57-9461-8945695f19c8.png#align=left&amp;display=inline&amp;height=228&amp;margin=%5Bobject%20Object%5D&amp;originHeight=228&amp;originWidth=523&amp;size=0&amp;status=done&amp;style=none&amp;width=523" alt></p>
<h2 id="第-4-步：剪辑（精剪）"><a href="#第-4-步：剪辑（精剪）" class="headerlink" title="第 4 步：剪辑（精剪）"></a>第 4 步：剪辑（精剪）</h2><p><strong>剪辑工作</strong>包括对素材进行<strong>裁剪</strong>、<strong>拼接</strong>，<strong>调色</strong>，添加<strong>配乐</strong>、<strong>音效</strong>，还可以添加<strong>转场</strong>、<strong>特效</strong>等等，关于这些进阶内容我们后面会有专门的课程进行深入地解析，这里就不多说了。</p>
<p>完成整个视频的制作以后，我们就可以进行</p>
<h2 id="第-5-步：渲染输出"><a href="#第-5-步：渲染输出" class="headerlink" title="第 5 步：渲染输出"></a>第 5 步：渲染输出</h2><p><strong>a.</strong> 在“文件”中，点击“导出”，选择“媒体”，弹出渲染设置面板；</p>
<p><strong>b.</strong> 格式我一般选择 H.264，预设选择“匹配源—高比特率”；</p>
<p><strong>c.</strong> 设置文件保存位置和文件名。</p>
<p>其他的参数可以不用改动，对于一般的用户来说这样的设置就够用了，最后点击“导出”就完成了。</p>
<p>以上内容是我为大家总结整理的 PR 剪辑的基本流程，它不是最全面的，但如果你掌握了前面所说的这些内容，简单地剪辑一个视频几乎没有什么问题了。</p>
]]></content>
      <categories>
        <category>Premiere</category>
      </categories>
  </entry>
  <entry>
    <title>JAVA-泛型</title>
    <url>/blog/ef1q5c/</url>
    <content><![CDATA[<p>###</p>
<p>类似 C++里面的模板，定义的时候就是直接在后面加上<e> <code>public class ArrayList&lt;E&gt;</code>  使用就是 <code>private E[] array</code> ;</e></p>
<p>##</p>
]]></content>
      <categories>
        <category>Language</category>
      </categories>
  </entry>
  <entry>
    <title>MySQL命令</title>
    <url>/blog/emv1ek/</url>
    <content><![CDATA[<h2 id="登陆命令"><a href="#登陆命令" class="headerlink" title="登陆命令"></a>登陆命令</h2><pre><code class="sql">mysql -u用户名 -p密码
</code></pre>
<p>用户名和-u 选项之间可以有空格，但是密码和-p 选项之间必须无空格。但是这样密码会是明文。你可以在键入-p 之后，回车再输入密码，就是密文。</p>
<h3 id="常用选项"><a href="#常用选项" class="headerlink" title="常用选项"></a>常用选项</h3><table>
<thead>
<tr>
<th>缩写</th>
<th>全写</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>-h</td>
<td>–host</td>
<td>主机</td>
</tr>
<tr>
<td>-p</td>
<td>–password</td>
<td>密码</td>
</tr>
<tr>
<td>-P</td>
<td>–port</td>
<td>端口</td>
</tr>
<tr>
<td>-V</td>
<td>–version</td>
<td>版本信息</td>
</tr>
<tr>
<td>-u</td>
<td>–user</td>
<td>用户</td>
</tr>
<tr>
<td></td>
<td>–prompt</td>
<td>修改提示符</td>
</tr>
</tbody>
</table>
<h4 id="–prompt"><a href="#–prompt" class="headerlink" title="–prompt"></a>–prompt</h4><p>–prompt 支持几个转义词组</p>
<ul>
<li>\h 主机名</li>
<li>\D 完整日期</li>
<li>\d 当前数据库</li>
<li>\u 当前用户</li>
</ul>
<h2 id="登陆之后"><a href="#登陆之后" class="headerlink" title="登陆之后"></a>登陆之后</h2><h3 id="退出"><a href="#退出" class="headerlink" title="退出"></a>退出</h3><ul>
<li>exit</li>
<li>quit</li>
<li>\q</li>
</ul>
<p>都能退出 mysql，系统显示 Bye。</p>
<h3 id="帮助"><a href="#帮助" class="headerlink" title="帮助"></a>帮助</h3><p>键入<code>help</code>或<code>\h</code>。</p>
<h3 id="显示信息"><a href="#显示信息" class="headerlink" title="显示信息"></a>显示信息</h3><p>select:</p>
<ul>
<li>version(); 版本信息</li>
<li>now(); 当前时间</li>
<li>user(); 用户@主机名</li>
</ul>
<h3 id="使用系统命令"><a href="#使用系统命令" class="headerlink" title="使用系统命令"></a>使用系统命令</h3><p><strong>!</strong> 后加 shell 命令可以在 mysql 中执行 shell 命令。</p>
<blockquote>
<p>gdb 使用 shell 加命令来执行 shell 命令。</p>
</blockquote>
]]></content>
      <categories>
        <category>Language</category>
      </categories>
  </entry>
  <entry>
    <title>🧙‍♂️算法分析与设计</title>
    <url>/blog/eq2l1v/</url>
    <content><![CDATA[<h2 id="形式化定义"><a href="#形式化定义" class="headerlink" title="形式化定义"></a>形式化定义</h2><p>对于一个问题，将其进行科学的分析研究，就需要对其进行更加严谨的形式化定义，其形式就类似于数学建模过程中的构建出<strong>数学模型</strong>一样，对其进行问题的抽象化提取，以及合理的公式化，就比如“0-1 背包”问题中：<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1600597354257-45eba2b3-641c-433a-8732-9b6c11a16061.png#align=left&amp;display=inline&amp;height=281&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=561&amp;originWidth=1065&amp;size=184609&amp;status=done&amp;style=shadow&amp;width=532.5" alt="image.png"></p>
<h2 id="判定性问题"><a href="#判定性问题" class="headerlink" title="判定性问题"></a>判定性问题</h2><p>类似于数学建模当中<strong>模型的求解</strong>，在给定模型以及约束条件的情况下求出符合该约束条件下的模型解：<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1600597489691-e0d838af-003e-404e-8a40-5145d2fefbad.png#align=left&amp;display=inline&amp;height=108&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=216&amp;originWidth=969&amp;size=73465&amp;status=done&amp;style=shadow&amp;width=484.5" alt="image.png"></p>
<h2 id="eg：Euclid-GCD-问题"><a href="#eg：Euclid-GCD-问题" class="headerlink" title="eg：Euclid-GCD 问题"></a>eg：Euclid-GCD 问题</h2><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>将每个整数分解为素因子的积，找出公共的素因子，它们的积即是 GCD</p>
<h3 id="问题思路"><a href="#问题思路" class="headerlink" title="问题思路"></a>问题思路</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1599360897754-ab7b7684-5565-471b-aece-1725b39196bb.png#align=left&amp;display=inline&amp;height=296&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=848&amp;originWidth=1131&amp;size=231186&amp;status=done&amp;style=shadow&amp;width=395" alt="image.png"></p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><pre><code class="java">package com.wztlink1013.al.EuclidGCD;
import java.util.Scanner;

public class Main {
    public static void main(String args[]){
        Scanner input = new Scanner(System.in);

        System.out.println(&quot;请输入两个大于零的自然数：&quot;);
        int a = input.nextInt();
        int b = input.nextInt();
        GCD(a,b);
        System.out.println(a + &quot;和&quot; + b + &quot;两个数的GCD值为：&quot; + GCD(a,b));
    }
    public static int GCD(int i, int j){
        int r;
        while (j != 0){
            r = i%j;
            i = j;
            j = r;
            System.out.println(&quot;a=&quot;+i+&quot;；b=&quot;+j+&quot;；r=&quot;+r);
        }
        return i;
    }
}

</code></pre>
<p>##</p>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>jsDelivr和Github构建免费CDN</title>
    <url>/blog/erx9hf/</url>
    <content><![CDATA[<h2 id="一、搭建缘由"><a href="#一、搭建缘由" class="headerlink" title="一、搭建缘由"></a>一、搭建缘由</h2><p>CDN 的全称是 Content Delivery Network，即内容分发网络。CDN 是构建在网络之上的内容分发网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。CDN 的关键技术主要有内容存储和分发技术。——百度百科</p>
<p>通俗来说就是提取外链，同时加速访问的好处。Github 的资源在国内加载速度比较慢，因此需要使用 CDN 加速来优化网站打开速度，jsDelivr + Github 便是免费且好用的 CDN，非常适合博客网站使用。</p>
<h2 id="二、GitHub-新建-CDN-仓库"><a href="#二、GitHub-新建-CDN-仓库" class="headerlink" title="二、GitHub 新建 CDN 仓库"></a>二、GitHub 新建 CDN 仓库</h2><p>在本地电脑进行一系列 clone/pull 等一系列操作，同时发布版本（最好上传一次就发布依次版本）<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1602926808858-fcdea51e-42b2-4582-b46d-e9c105842039.png#align=left&amp;display=inline&amp;height=950&amp;margin=%5Bobject%20Object%5D&amp;originHeight=950&amp;originWidth=1844&amp;size=0&amp;status=done&amp;style=none&amp;width=1844" alt><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1602926808290-99384f86-d857-415a-83e6-9be3b5bcf279.png#align=left&amp;display=inline&amp;height=953&amp;margin=%5Bobject%20Object%5D&amp;originHeight=953&amp;originWidth=1832&amp;size=0&amp;status=done&amp;style=none&amp;width=1832" alt></p>
<h2 id="三、使用-jsDlivr"><a href="#三、使用-jsDlivr" class="headerlink" title="三、使用 jsDlivr"></a>三、使用 jsDlivr</h2><p><strong><code>[https://cdn.jsdelivr.net/gh/wztlink1013/CDN-Volantis@](https://cdn.jsdelivr.net/gh/wztlink1013/CDN-Volantis@)版本号/文件夹/文件名.文件后缀</code></strong></p>
<p><strong>举个栗子</strong></p>
<ul>
<li><a href="https://cdn.jsdelivr.net/gh/wztlink1013/CDN@2.4/Pictures/blogbackground/fengbaobao_1.jpg" target="_blank" rel="noopener">https://cdn.jsdelivr.net/gh/wztlink1013/CDN@2.4/Pictures/blogbackground/fengbaobao_1.jpg</a></li>
<li><a href="https://cdn.jsdelivr.net/gh/moezx/cdn@3.1.3//The%20Pet%20Girl%20of%20Sakurasou.mp4" target="_blank" rel="noopener">https://cdn.jsdelivr.net/gh/moezx/cdn@3.1.3//The Pet Girl of Sakurasou.mp4</a></li>
</ul>
<blockquote>
<p>0、具体使用教程</p>
</blockquote>
<ul>
<li><a href="https://blog.wztlink1013.com/2020/02/25/Hexo/jsDelivr%E5%92%8CGitHub%E6%9E%84%E5%BB%BA%E5%85%8D%E8%B4%B9CDN/" target="_blank" rel="noopener">jsDelivr 和 Github 构建免费 CDN</a></li>
<li><a href="https://www.jsdelivr.com/" target="_blank" rel="noopener">jsdelivr 官网网站</a></li>
</ul>
<blockquote>
<p>1、加载任何 Github 发布、提交或分支</p>
</blockquote>
<ul>
<li><a href="https://cdn.jsdelivr.net/gh/user/repo@version/file" target="_blank" rel="noopener">https://cdn.jsdelivr.net/gh/user/repo@version/file</a></li>
</ul>
<blockquote>
<p>2、加载 jQuery v3.2.1</p>
</blockquote>
<ul>
<li><a href="https://cdn.jsdelivr.net/gh/jquery/jquery@3.2.1/dist/jquery.min.js" target="_blank" rel="noopener">https://cdn.jsdelivr.net/gh/jquery/jquery@3.2.1/dist/jquery.min.js</a></li>
</ul>
<blockquote>
<p>3、使用版本范围而不是特定版本</p>
</blockquote>
<ul>
<li><a href="https://cdn.jsdelivr.net/gh/jquery/jquery@3.2/dist/jquery.min.js" target="_blank" rel="noopener">https://cdn.jsdelivr.net/gh/jquery/jquery@3.2/dist/jquery.min.js</a></li>
<li><a href="https://cdn.jsdelivr.net/gh/jquery/jquery@3/dist/jquery.min.js" target="_blank" rel="noopener">https://cdn.jsdelivr.net/gh/jquery/jquery@3/dist/jquery.min.js</a></li>
</ul>
<blockquote>
<p>4、完全省略该版本以获取最新版本</p>
</blockquote>
<ul>
<li><a href="https://cdn.jsdelivr.net/gh/jquery/jquery/dist/jquery.min.js" target="_blank" rel="noopener">https://cdn.jsdelivr.net/gh/jquery/jquery/dist/jquery.min.js</a></li>
</ul>
<blockquote>
<p>5、将“.min”添加到任何 JS/CSS 文件中以获取缩小版本，如果不存在，将为会自动生成</p>
</blockquote>
<ul>
<li><a href="https://cdn.jsdelivr.net/gh/jquery/jquery@3.2.1/src/core.min.js" target="_blank" rel="noopener">https://cdn.jsdelivr.net/gh/jquery/jquery@3.2.1/src/core.min.js</a></li>
</ul>
<blockquote>
<p>6、在末尾添加 / 以获取资源目录列表</p>
</blockquote>
<ul>
<li><a href="https://cdn.jsdelivr.net/gh/jquery/jquery/" target="_blank" rel="noopener">https://cdn.jsdelivr.net/gh/jquery/jquery/</a></li>
</ul>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
  </entry>
  <entry>
    <title>线性搜索</title>
    <url>/blog/ete0k7/</url>
    <content><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1599481660030-a834223b-30e4-4a9e-a290-243f028112f2.png#align=left&amp;display=inline&amp;height=325&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=650&amp;originWidth=1040&amp;size=166464&amp;status=done&amp;style=shadow&amp;width=520" alt="image.png"></p>
<h2 id="问题思路"><a href="#问题思路" class="headerlink" title="问题思路"></a>问题思路</h2><h2 id="代码思路"><a href="#代码思路" class="headerlink" title="代码思路"></a>代码思路</h2><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2>]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>P150.逆波兰表达式求值</title>
    <url>/blog/ewoap5/</url>
    <content><![CDATA[<h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>对所给字符串进行遍历，遇到数字字符就压入栈 stack 内，遇到+-*/符号就 pop 处栈的两个元素，进行该字符运算处理</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><pre><code class="java">package com.wztlink1013.problems.leetcode.editor.cn;

// P150.逆波兰表达式求值
// P150.evaluate-reverse-polish-notation
//根据 逆波兰表示法，求表达式的值。
//
// 有效的运算符包括 +, -, *, / 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。
//
//
//
// 说明：
//
//
// 整数除法只保留整数部分。
// 给定逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。
//
//
//
//
// 示例 1：
//
// 输入: [&quot;2&quot;, &quot;1&quot;, &quot;+&quot;, &quot;3&quot;, &quot;*&quot;]
//输出: 9
//解释: 该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) = 9
//
//
// 示例 2：
//
// 输入: [&quot;4&quot;, &quot;13&quot;, &quot;5&quot;, &quot;/&quot;, &quot;+&quot;]
//输出: 6
//解释: 该算式转化为常见的中缀算术表达式为：(4 + (13 / 5)) = 6
//
//
// 示例 3：
//
// 输入: [&quot;10&quot;, &quot;6&quot;, &quot;9&quot;, &quot;3&quot;, &quot;+&quot;, &quot;-11&quot;, &quot;*&quot;, &quot;/&quot;, &quot;*&quot;, &quot;17&quot;, &quot;+&quot;, &quot;5&quot;, &quot;+&quot;]
//输出: 22
//解释:
//该算式转化为常见的中缀算术表达式为：
//  ((10 * (6 / ((9 + 3) * -11))) + 17) + 5
//= ((10 * (6 / (12 * -11))) + 17) + 5
//= ((10 * (6 / -132)) + 17) + 5
//= ((10 * 0) + 17) + 5
//= (0 + 17) + 5
//= 17 + 5
//= 22
//
//
//
// 逆波兰表达式：
//
// 逆波兰表达式是一种后缀表达式，所谓后缀就是指算符写在后面。
//
//
// 平常使用的算式则是一种中缀表达式，如 ( 1 + 2 ) * ( 3 + 4 ) 。
// 该算式的逆波兰表达式写法为 ( ( 1 2 + ) ( 3 4 + ) * ) 。
//
//
// 逆波兰表达式主要有以下两个优点：
//
//
// 去掉括号后表达式无歧义，上式即便写成 1 2 + 3 4 + * 也可以依据次序计算出正确结果。
// 适合用栈操作运算：遇到数字则入栈；遇到算符则取出栈顶两个数字进行计算，并将结果压入栈中。
//
// Related Topics 栈
// 👍 213 👎 0


import java.util.Stack;

public class P150EvaluateReversePolishNotation{
    public static void main(String[] args) {
        Solution solution = new P150EvaluateReversePolishNotation().new Solution();
        String[] tokens_1 = {&quot;10&quot;, &quot;6&quot;, &quot;9&quot;, &quot;3&quot;, &quot;+&quot;, &quot;-11&quot;, &quot;*&quot;, &quot;/&quot;, &quot;*&quot;, &quot;17&quot;, &quot;+&quot;, &quot;5&quot;, &quot;+&quot;};
        int temp = solution.evalRPN(tokens_1);
        System.out.println(temp);

    }

//leetcode submit region begin(Prohibit modification and deletion)
class Solution {
    public int evalRPN(String[] tokens) {
        Stack&lt;String&gt; stack = new Stack&lt;&gt;();

        String temp = &quot;0&quot;;
        stack.push(temp);

        for (String token : tokens) {
            int sum = 0;
            if (token.equals(&quot;+&quot;)) {
                sum += Integer.parseInt(stack.pop()) + Integer.parseInt(stack.pop());
                String str = String.valueOf(sum);
                stack.push(str);
            } else if (token.equals(&quot;-&quot;)) {
                int i = Integer.parseInt(stack.pop());
                int j = Integer.parseInt(stack.pop());
                sum += j-i;
                String str = String.valueOf(sum);
                stack.push(str);
            } else if (token.equals(&quot;*&quot;)) {
                sum += Integer.parseInt(stack.pop()) * Integer.parseInt(stack.pop());
                String str = String.valueOf(sum);
                stack.push(str);
            } else if (token.equals(&quot;/&quot;)) {
                int i = Integer.parseInt(stack.pop());
                int j = Integer.parseInt(stack.pop());
                sum += j / i;
                String str = String.valueOf(sum);
                stack.push(str);
            } else {
                stack.push(token);
            }
        }
        int result = Integer.parseInt(stack.pop());
        return result;
    }
}
//leetcode submit region end(Prohibit modification and deletion)

}
</code></pre>
]]></content>
      <categories>
        <category>DataStructure</category>
      </categories>
      <tags>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>Python-基本语法</title>
    <url>/blog/ewt4nc/</url>
    <content><![CDATA[<h2 id="一、基本语法"><a href="#一、基本语法" class="headerlink" title="一、基本语法"></a>一、基本语法</h2><ol>
<li>大事谷歌；小事百度【建立良好的编程式思维】</li>
<li>PEP8 中的一些良好约定【编程规范】</li>
<li>字符串格式化：<br>print(‘%s–%d–%s’%(‘wuzutao’,20,’尼采般地抒情’))<br>a. %i 是什么格式的那啥？‘</li>
<li>强制性类型转换：类 C</li>
<li><p>时间和日期：<br>from datetime import datetime<br>dt=datetime(2019,5,12,9,20)<br>print(dt.year,dt.month,dt.day)</p>
<blockquote>
<p>2019  5  12<br>dt.strftime(‘%Y/%m/%d %H:%M’)<br>#datetime 格式转化为字符串<br>‘2019/05/12 09:20’<br>datetime.strptime(‘20161203’, ‘%Y%m%d’) #字符串转化为 datetime 格式<br>datetime.datetime(2016, 12, 3, 0, 0)</p>
</blockquote>
</li>
<li><p>pass 函数<br>def f():<br>   #TODO: test pass<br>   pass</p>
</li>
<li><p>异常的处理<br>def test(x,y):<br>   try:</p>
<pre><code>   print(y/x)
</code></pre><p>   except:</p>
<pre><code>   print(&#39;输入的信息有误！&#39;)
</code></pre><blockquote>
<p>test(2,8)<br>test(‘e’,8)</p>
</blockquote>
</li>
<li><p>range 和 range 的区别！！！</p>
</li>
<li><p>对象传递和拷贝【类似 C 语言中的指针】 #变量传递、列表传递和 C 类似 #深拷贝和浅拷贝<br>import copy<br>a = [[1, 2, 3], [4, 5, 6]]<br>b = a<br>c = copy.copy(a)<br>d = copy.deepcopy(a)<br>print (‘a-id:’,id(a))#id 相当于内存里面的地址<br>print (‘b-id:’,id(b))<br>print (‘c-id:’,id(c))<br>print (‘d-id:’,id(d))<br>a.append(15)<br>a[1][2] = 10<br>print (a)<br>print (b)<br>print (c)<br>print (d)</p>
</li>
<li><p>a-id: 2171119139144<br>b-id: 2171119139144<br>c-id: 2171119848136<br>d-id: 2171119140744<br>[[1, 2, 3], [4, 5, 10], 15]<br>[[1, 2, 3], [4, 5, 10], 15]<br>[[1, 2, 3], [4, 5, 10]]<br>[[1, 2, 3], [4, 5, 6]]</p>
</li>
</ol>
<h2 id="二、数据结构"><a href="#二、数据结构" class="headerlink" title="二、数据结构"></a>二、数据结构</h2><h3 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h3><pre><code>    ○ #转换为元组（list-&gt;tuple, string-&gt;tuple）
    l = [1, 2, 3]
    print (tuple(l))
    str = (&#39;Hello ChinaHadoop&#39;)
    print (tuple(str))
    &gt;&gt;&gt;(1, 2, 3) (&#39;H&#39;, &#39;e&#39;, &#39;l&#39;, &#39;l&#39;, &#39;o&#39;, &#39; &#39;, &#39;C&#39;, &#39;h&#39;, &#39;i&#39;, &#39;n&#39;, &#39;a&#39;, &#39;H&#39;, &#39;a&#39;, &#39;d&#39;, &#39;o&#39;, &#39;o&#39;, &#39;p&#39;)
    ○ tup1 = (1, 2, 3)
    #嵌套元组:
    tup2 = ((1, 2, 3), (4, 5))
    print (tup2)
    #合并元组:
    tup1 + tup2
    ○ #拆包
    def test_1():
        r=(2,4,5,32)
        return r
    a, b, _, f=test_1()
    print(f)
    &gt;&gt;&gt; 32
    ○ # 元组列表迭代
    tuple_lst = [(1, 2), (3, 4), (5, 6)]
    for x, y in tuple_lst:
        print (x+y)
    &gt;&gt;&gt;3   7   11
    ○ # 计数器
    列表/元组.(&#39;需要查找里面的某个对象的个数&#39;)
</code></pre><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><pre><code>    ○ list里面可以有不同类型的元素
    ○ #合并列表
    lst_1=[352,2352,3,556]
    lst_2=[&#39;gew&#39;,&#39;f&#39;]
    &gt;lst_3 = lst_1 + lst_2
    &gt;lst_1.extend(lst_2)
    ○ #sort函数和sorted函数
    list_1=[23,54,346,222,4,1]
    print(list_1.sort())     #查查版本
    print(sorted(list_1))  #sorted是新起的一个列表
    lst_6 = [&#39;Welcome&#39;, &#39;to&#39;, &#39;Python&#39;, &#39;Data&#39;, &#39;Analysis&#39;, &#39;Course&#39;]
    lst_6.sort()
    print (lst_6)【!!!!打印出来是none===查查版本】
    &gt;&gt;&gt;[&#39;Analysis&#39;, &#39;Course&#39;, &#39;Data&#39;, &#39;Python&#39;, &#39;Welcome&#39;, &#39;to&#39;]
    lst_6.sort(key = len, reverse=True)
    print (lst_6)
    &gt;&gt;&gt;[&#39;Analysis&#39;, &#39;Welcome&#39;, &#39;Course&#39;, &#39;Python&#39;, &#39;Data&#39;, &#39;to&#39;]
</code></pre><h3 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h3><pre><code>    ○ #合并字典
    dict1 = {1:&#39;huhuhu&#39;}
    dict2 = {4: &#39;new1&#39;, 5: &#39;news&#39;}
    dict1.update(dict2)
    ○ #通过多个列表创建字典
    dict_3 = {}
    l1 = [32,543,6,2,7,4]
    l2 = reversed(l1)
    for i1, i2 in zip(l1, l2):
        dict_3[i1] = i2
    print (dict_3)
    &gt;&gt;&gt;{32: 4, 543: 7, 6: 2, 2: 6, 7: 543, 4: 32}
    &#39;&#39;&#39;hash函数来判断某个对象是否可以做键&#39;&#39;&#39;
    ○ &#39;&#39;&#39;位置赋值；默认赋值；关键字赋值——format&#39;&#39;&#39;
    &#39;&#39;&#39;遍历字典的方式变了：keys，values，items&#39;&#39;&#39;
    天行九歌={&#39;韩非&#39;:&#39;逆鳞&#39;,&#39;卫庄&#39;:&#39;鲨齿&#39;,&#39;盖聂&#39;:&#39;渊虹&#39;}
    print(天行九歌)
    for ren,jian in 天行九歌.items():
        print(&#39;{}--{}&#39;.format(ren,jian))
    &gt;&gt;&gt;
    {&#39;韩非&#39;: &#39;逆鳞&#39;, &#39;卫庄&#39;: &#39;鲨齿&#39;, &#39;盖聂&#39;: &#39;渊虹&#39;}
</code></pre><h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><pre><code>    ○ a1=[1,3,4,1,35,2352,75]
    b1=[3,2352,24354,4332432,54]
    a=set(a1)
    b=set(b1)
    print(a)
    print(b)
    a | b#并；a &amp; b#交；a - b#呃。。。；a ^ b#呃。。。；
    a.issubset(b)#判断子集
    &gt;&gt;&gt;False
    a.issuperset(b)#判断父集
    &gt;&gt;&gt;False
</code></pre><h2 id="三、高级特性"><a href="#三、高级特性" class="headerlink" title="三、高级特性"></a>三、高级特性</h2><h3 id="推导式"><a href="#推导式" class="headerlink" title="推导式"></a>推导式</h3><pre><code>    ○ str_lst = [&#39;Welcome&#39;, &#39;to&#39;, &#39;Python&#39;, &#39;Data&#39;, &#39;Analysis&#39;, &#39;Course&#39;]
    result = [x.upper() for x in str_lst if len(x) &gt; 4]
    print (result)
    &gt;&gt;&gt;[&#39;WELCOME&#39;, &#39;PYTHON&#39;, &#39;ANALYSIS&#39;, &#39;COURSE&#39;]
</code></pre><h3 id="多函数模式"><a href="#多函数模式" class="headerlink" title="多函数模式"></a>多函数模式</h3><pre><code>    ○ str_lst = [&#39;$1.123&#39;, &#39; $1123.454&#39;, &#39;$899.12312&#39;]

    def remove_space(str):
        &quot;&quot;&quot;
            remove space
        &quot;&quot;&quot;
        str_no_space = str.replace(&#39; &#39;, &#39;&#39;)
        return str_no_space

    def remove_dollar(str):
        &quot;&quot;&quot;
            remove $
        &quot;&quot;&quot;
        if &#39;$&#39; in str:
            return str.replace(&#39;$&#39;, &#39;&#39;)
        else:
            return str

    def clean_str_lst(str_lst, operations):
        &quot;&quot;&quot;
            clean string list
        &quot;&quot;&quot;
        result = []
        for item in str_lst:
            for op in operations:
                item = op(item)
            result.append(item)
        return result

    clean_operations = [remove_space, remove_dollar]
    result = clean_str_lst(str_lst, clean_operations)
    print (result)
    &gt;&gt;&gt;[&#39;1.123&#39;, &#39;1123.454&#39;, &#39;899.12312&#39;]
</code></pre><h3 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h3><pre><code>    ○ str_lst = [&#39;Welcome&#39;, &#39;to&#39;, &#39;Python&#39;, &#39;Data&#39;, &#39;Analysis&#39;, &#39;Course&#39;]
    str_lst.sort(key=lambda x:len(x)) # sort by length
    print (str_lst)

    str_lst.sort(key=lambda x:x[-1]) # sort by the last letter
    print (str_lst)
    &gt;&gt;&gt;
    [&#39;to&#39;, &#39;Data&#39;, &#39;Python&#39;, &#39;Course&#39;, &#39;Welcome&#39;, &#39;Analysis&#39;]
    [&#39;Data&#39;, &#39;Course&#39;, &#39;Welcome&#39;, &#39;Python&#39;, &#39;to&#39;, &#39;Analysis&#39;]
</code></pre><h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><pre><code>    ○ def gen_test():
        for i in range(3):
            yield i

    gen = gen_test() #此时不执行生成器
    type(gen)
    for i in gen:
        print(i)
    #用意何在呢？？！！
    &gt;&gt;&gt;0  1  2
</code></pre><h2 id="四、常用函数"><a href="#四、常用函数" class="headerlink" title="四、常用函数"></a>四、常用函数</h2><h3 id="序列函数-amp-zip-使用"><a href="#序列函数-amp-zip-使用" class="headerlink" title="序列函数&amp;zip 使用"></a>序列函数&amp;zip 使用</h3><pre><code>    a. enumerate函数
    list_11 = [&#39;Welcome&#39;, &#39;to&#39;, &#39;Python&#39;, &#39;Data&#39;, &#39;Analysis&#39;, &#39;Course&#39;]
    for i, item in enumerate(lst_6):
        print (&#39;%i-%s&#39; %(i, item))
    &gt;&gt;&gt;
    0-Analysis
    1-Welcome
    2-Course
    3-Python
    4-Data
    5-to
    str_dict = dict((i, item) for i, item in enumerate(list_11))
    print (str_dict)
    &gt;&gt;&gt;{0: &#39;Welcome&#39;, 1: &#39;to&#39;, 2: &#39;Python&#39;, 3: &#39;Data&#39;, 4: &#39;Analysis&#39;, 5: &#39;Course&#39;}
    b. zip压缩
    lst_6 = [&#39;Welcome&#39;, &#39;to&#39;, &#39;Python&#39;, &#39;Data&#39;, &#39;Analysis&#39;, &#39;Course&#39;]
    lst_8 = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]
    zip_lst = zip(lst_6, lst_8)
    print(list(zip_lst))
    #方式一：直接转化为列表
    print(dict(list(zip_lst)))
    #方式二：转化为字典
    for i in zip_lst:
        print (i)
    #方式三：直接遍历
    解压：
    print(*zip_lst)
    print(lst_6)
    c. reversed逆序输出
</code></pre><h3 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h3><pre><code>    a. #函数可以作为变量使用;也可以将函数作为参数使用
    import math
    def func_add(x, y, f):
        &quot;&quot;&quot;
            functional addition
        &quot;&quot;&quot;
        return f(x) + f(y)

    print (func_add(4, 25, math.sqrt))
    print (func_add(-4, 25, abs))
    &gt;&gt;&gt;7.0    29
</code></pre><h3 id="map-和-reduce"><a href="#map-和-reduce" class="headerlink" title="map 和 reduce"></a>map 和 reduce</h3><pre><code>    a. &#39;&#39;&#39;map函数&#39;&#39;&#39;
    list_1=[1,4,9]
    aaa = [x**2 for x in list_1]
    print (aaa)

    bbb = map(math.sqrt, aaa)
    print (bbb)
    &gt;&gt;&gt;
    [1, 16, 81]
</code></pre><map object at 0x000002145b2b77f0>

<h3 id="filter-函数"><a href="#filter-函数" class="headerlink" title="filter 函数"></a>filter 函数</h3><pre><code>    a. 天行=[&#39;韩非&#39;,&#39;卫庄&#39;,&#39;张良&#39;,&#39;盖聂&#39;,&#39;逆鳞&#39;]
    def fx(x):
        y=[&#39;逆鳞&#39;]
        if x in y:
            return x
    filtered_lst = filter(fx,天行)
    print(天行)
    print(list(filtered_lst))
    #注意python2和3的区别，很多时候要区别出来列表等序列，加上list很有必要
    &gt;&gt;&gt;
    [&#39;韩非&#39;, &#39;卫庄&#39;, &#39;张良&#39;, &#39;盖聂&#39;, &#39;逆鳞&#39;]
     [&#39;逆鳞&#39;]
</code></pre></map>]]></content>
      <categories>
        <category>Language</category>
      </categories>
  </entry>
  <entry>
    <title>JAVA-面向对象</title>
    <url>/blog/eywygo/</url>
    <content><![CDATA[<h2 id="一、面向对象思考"><a href="#一、面向对象思考" class="headerlink" title="一、面向对象思考"></a>一、面向对象思考</h2><h3 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h3><blockquote>
<p>就像是手工设计动态数组、链表等数据结构一样，要用<strong>设计</strong>这个字眼去面向对象思考。<br>同时还要关注类与类之间的关系有关联、聚集、组合，在设计多个类的过程中要有这些意识</p>
</blockquote>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1600086611076-d83aa284-7977-447d-9b25-0a0a67a12c3f.png#align=left&amp;display=inline&amp;height=189&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=377&amp;originWidth=1003&amp;size=316078&amp;status=done&amp;style=shadow&amp;width=501.5" alt="image.png"></p>
<h3 id="基本数据类型值及其包装类"><a href="#基本数据类型值及其包装类" class="headerlink" title="基本数据类型值及其包装类"></a>基本数据类型值及其包装类</h3><blockquote>
<p>都存在 java.lang 里面</p>
</blockquote>
<p>Integer、Long、Float、Double、Boolean、Character、Short、Byte<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1600087287006-c480d8fd-a6b5-4be9-bc43-3023e9fa4a0c.png#align=left&amp;display=inline&amp;height=264&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=527&amp;originWidth=989&amp;size=482466&amp;status=done&amp;style=stroke&amp;width=494.5" alt="image.png"></p>
<blockquote>
<p>基本数据类型和其对象化之后的包装类类型之间的自动转换</p>
</blockquote>
<p><code>Integer intObject = new Integer (2);</code>  等价于 <code>Integer intObject = 2;</code></p>
<blockquote>
<p>BigInteger 类和 BigDeciml 类用于表示任意大小和精度的整数或是二进制数</p>
</blockquote>
<h2 id="二、对象和类"><a href="#二、对象和类" class="headerlink" title="二、对象和类"></a>二、对象和类</h2><h3 id="OOP-阶梯图"><a href="#OOP-阶梯图" class="headerlink" title="OOP 阶梯图"></a>OOP 阶梯图</h3><blockquote>
<p>“OOP 阶梯图”—— 类的多个特性，同时以对象对基础</p>
</blockquote>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598686636493-3aecdbf5-1f94-4076-99dc-0ef0dac07331.png#align=left&amp;display=inline&amp;height=284&amp;margin=%5Bobject%20Object%5D&amp;originHeight=726&amp;originWidth=1328&amp;size=0&amp;status=done&amp;style=shadow&amp;width=520" alt></p>
<h3 id="类的组成"><a href="#类的组成" class="headerlink" title="类的组成"></a>类的组成</h3><blockquote>
<p>数据域、构造函数、方法（C++里面的说法是数据成员和成员函数）<br><strong>类中不能存在可执行语句</strong></p>
</blockquote>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598686636459-572d60ff-0740-4487-b3fd-9e2fa94b643f.png#align=left&amp;display=inline&amp;height=248&amp;margin=%5Bobject%20Object%5D&amp;originHeight=713&amp;originWidth=1387&amp;size=0&amp;status=done&amp;style=shadow&amp;width=482" alt></p>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><ul>
<li>和类同名、重载、没有返回值</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598686636454-ce95b4aa-9966-4024-82ae-b7cc296097db.png#align=left&amp;display=inline&amp;height=218&amp;margin=%5Bobject%20Object%5D&amp;originHeight=481&amp;originWidth=708&amp;size=0&amp;status=done&amp;style=shadow&amp;width=321" alt></p>
<ul>
<li><strong>构造函数初始化优先级</strong><blockquote>
<ol>
<li>静态成员变量初始化顺序高于非静态成员变量</li>
<li>成员变量的初始化顺序优于构造函数</li>
<li>静态成员变量只初始化一次，就是第一次被访问的时候</li>
<li>存在多个静态成员变量的时候，按照次序依次执行</li>
</ol>
</blockquote>
</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598686636495-c0c2fdf5-3919-475e-a2f7-a3888d97492d.png#align=left&amp;display=inline&amp;height=220&amp;margin=%5Bobject%20Object%5D&amp;originHeight=700&amp;originWidth=1404&amp;size=0&amp;status=done&amp;style=shadow&amp;width=441" alt></p>
<pre><code class="java">Window(2)
Window(1)
Window(2)
Window(3)
House()
Window(33)
f()
</code></pre>
<h3 id="数据域的默认值"><a href="#数据域的默认值" class="headerlink" title="数据域的默认值"></a>数据域的默认值</h3><blockquote>
<p><strong>对于对象而言，不赋值也会有默认的</strong>。之前的数组就是如此</p>
</blockquote>
<p>各个数据域按照之前的基本上的默认初值，如果是其他的类型，则空</p>
<h3 id="对象的创建和访问"><a href="#对象的创建和访问" class="headerlink" title="对象的创建和访问"></a>对象的创建和访问</h3><blockquote>
<ol>
<li>通过引用变量来访问对象，创建的类的对象被内存分配了内存空间，可以用引用变量来访问</li>
<li><strong>对象类型都需要用 new 来新建</strong></li>
</ol>
</blockquote>
<pre><code class="java">ClassName objectRefVar = new ClassName();

Circle myCircle = new Circle();
</code></pre>
<p><strong>使用成员变量和成员函数</strong></p>
<pre><code class="java">mycircle.radius
mycircle.getArea()
</code></pre>
<p><strong>调用静态函数，动态函数需要在自己类下面调用自己的函数</strong></p>
<h3 id="“炸宿舍”"><a href="#“炸宿舍”" class="headerlink" title="“炸宿舍”"></a>“炸宿舍”</h3><blockquote>
<p>关于老师提出来的炸宿舍例子</p>
</blockquote>
<p><strong>对象间的赋值和基本类型的赋值，能改变的一定是基本数值类型，所谓的数组名抑或是对象名，都只是地址映射</strong></p>
<h3 id="垃圾回收机制和-this"><a href="#垃圾回收机制和-this" class="headerlink" title="垃圾回收机制和 this"></a>垃圾回收机制和 this</h3><pre><code class="java">System.gc(); // 提醒垃圾回收
</code></pre>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1600086346479-3cc546b6-dab8-4fc5-a352-8f2fb2ea8065.png#align=left&amp;display=inline&amp;height=281&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=562&amp;originWidth=960&amp;size=48667&amp;status=done&amp;style=shadow&amp;width=480" alt="image.png"></p>
<h3 id="静态变量、常量和方法"><a href="#静态变量、常量和方法" class="headerlink" title="静态变量、常量和方法"></a>静态变量、常量和方法</h3><blockquote>
<p>静态成员变量：静态成员变量可以被类的所有实例共享（比如计数变量用到）<br>静态方法：不能访问类的实例成员<br>关于静态变量、静态方法、实例变量、实例方法</p>
</blockquote>
<h3 id="可见性修饰符"><a href="#可见性修饰符" class="headerlink" title="可见性修饰符"></a>可见性修饰符</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598686637158-0b08a6a1-5cd8-4aac-9133-1ad101cc8a52.png#align=left&amp;display=inline&amp;height=302&amp;margin=%5Bobject%20Object%5D&amp;originHeight=302&amp;originWidth=491&amp;size=0&amp;status=done&amp;style=stroke&amp;width=491" alt></p>
<h3 id="“析构函数”"><a href="#“析构函数”" class="headerlink" title="“析构函数”"></a>“析构函数”</h3><pre><code class="java">protected void finalize() throwsable {
    super.finalize();
    System.out.println(&quot;Person - finalize&quot;);
}
</code></pre>
<h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><p>内部类只给该类使用（私有自己用，同时写静态的），就如 LinkedList 类的设计</p>
<p>##</p>
]]></content>
      <categories>
        <category>Language</category>
      </categories>
  </entry>
  <entry>
    <title>js-Cannot set property &#39;innerHTML&#39; of null</title>
    <url>/blog/fg4az5/</url>
    <content><![CDATA[<h2 id="报错信息"><a href="#报错信息" class="headerlink" title="报错信息"></a>报错信息</h2><pre><code class="javascript">Cannot set property &#39;innerHTML&#39; of null
</code></pre>
<h2 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h2><p>如果 js 放在头部时，此时浏览器渲染未进入 dom 节点，因为提示为空，或者找不到。<br>所以把 js 代码放到最后或调用的对象后面就行了。id 元素在 script 脚本之后，不能引用，类似在使用变量之前对其进行定义一样。</p>
]]></content>
      <categories>
        <category>Bug</category>
      </categories>
  </entry>
  <entry>
    <title>IDEA配置Tomcat</title>
    <url>/blog/fgh5bc/</url>
    <content><![CDATA[<h2 id="一、Tomcat-的下载"><a href="#一、Tomcat-的下载" class="headerlink" title="一、Tomcat 的下载"></a>一、Tomcat 的下载</h2><h3 id="正常下载并安装"><a href="#正常下载并安装" class="headerlink" title="正常下载并安装"></a>正常下载并安装</h3><blockquote>
<p>！！！在此之前默认读者下载且配置好了 jdk 环境</p>
</blockquote>
<ul>
<li>进入该官网<a href="https://imgconvert.csdnimg.cn/aHR0cDovL3RvbWNhdC5hcGFjaGUub3JnLw?x-oss-process=image/format,png" target="_blank" rel="noopener">下载页面</a><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598787914511-a035ba93-0b7a-450b-b391-5d1452435ca7.png#align=left&amp;display=inline&amp;height=238&amp;margin=%5Bobject%20Object%5D&amp;originHeight=952&amp;originWidth=1842&amp;size=0&amp;status=done&amp;style=shadow&amp;width=461" alt></li>
<li>下载并解压到自己的相应盘区，再进入下图文件夹检验是否成功<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598787914448-2ef2e1a1-2966-4d35-8bfe-82162aa1588b.png#align=left&amp;display=inline&amp;height=273&amp;margin=%5Bobject%20Object%5D&amp;originHeight=727&amp;originWidth=1147&amp;size=0&amp;status=done&amp;style=shadow&amp;width=431" alt></li>
<li>点击第二个框不出现闪退情况则证明成功<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598787914507-87063aec-884a-4180-b124-568478d81bc0.png#align=left&amp;display=inline&amp;height=222&amp;margin=%5Bobject%20Object%5D&amp;originHeight=639&amp;originWidth=1223&amp;size=0&amp;status=done&amp;style=shadow&amp;width=425" alt></li>
<li>浏览器进入端口<a href="http://localhost:8080/" target="_blank" rel="noopener">http://localhost:8080/</a>上述配置成功则表明成功<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598787914624-248148e3-3f5f-45ca-ad93-c063216a7aff.png#align=left&amp;display=inline&amp;height=240&amp;margin=%5Bobject%20Object%5D&amp;originHeight=1030&amp;originWidth=1838&amp;size=0&amp;status=done&amp;style=shadow&amp;width=429" alt></li>
</ul>
<h3 id="过程中可能会出现的问题"><a href="#过程中可能会出现的问题" class="headerlink" title="过程中可能会出现的问题"></a>过程中可能会出现的问题</h3><ul>
<li>点击 startup.bat 文件出现闪退<br>电脑中 java jdk 有无（JAVA_HOME）</li>
<li>端口被占用<br>进入 Tomcat 文件夹下的 conf 文件下的 server.xml 文件，用记事本查找 8080，下面复制一个新的初始端口<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598787914513-8083bc6e-4c6f-436e-b0b0-98d3d70b9dea.png#align=left&amp;display=inline&amp;height=80&amp;margin=%5Bobject%20Object%5D&amp;originHeight=80&amp;originWidth=557&amp;size=0&amp;status=done&amp;style=none&amp;width=557" alt></li>
</ul>
<h2 id="二、IDEA-配置-Tomcat"><a href="#二、IDEA-配置-Tomcat" class="headerlink" title="二、IDEA 配置 Tomcat"></a>二、IDEA 配置 Tomcat</h2><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><ul>
<li>新建一个项目<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598787914503-6a4bf3f9-0e92-4bd3-bcde-e65af73510b8.png#align=left&amp;display=inline&amp;height=1060&amp;margin=%5Bobject%20Object%5D&amp;originHeight=1060&amp;originWidth=1457&amp;size=0&amp;status=done&amp;style=none&amp;width=1457" alt></li>
<li>编写 head/body 待会测试用<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598787914719-36f4cef3-db7c-4bd9-a43a-5c92f0afead2.png#align=left&amp;display=inline&amp;height=1080&amp;margin=%5Bobject%20Object%5D&amp;originHeight=1080&amp;originWidth=1842&amp;size=0&amp;status=done&amp;style=none&amp;width=1842" alt></li>
<li>相关配置<br>进入配置页面<img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598787914684-a3f47ea5-50df-450f-935d-f9ec086bc2cb.png#align=left&amp;display=inline&amp;height=1080&amp;margin=%5Bobject%20Object%5D&amp;originHeight=1080&amp;originWidth=1842&amp;size=0&amp;status=done&amp;style=none&amp;width=1842" alt><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598787914511-d1b72498-32cb-4868-8758-34fb3de3e798.png#align=left&amp;display=inline&amp;height=853&amp;margin=%5Bobject%20Object%5D&amp;originHeight=853&amp;originWidth=1343&amp;size=0&amp;status=done&amp;style=none&amp;width=1343" alt><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598787914585-5e3362d9-db50-4bdb-8640-f3a2f630bbbf.png#align=left&amp;display=inline&amp;height=932&amp;margin=%5Bobject%20Object%5D&amp;originHeight=932&amp;originWidth=1343&amp;size=0&amp;status=done&amp;style=none&amp;width=1343" alt></li>
</ul>
<h3 id="运行测试"><a href="#运行测试" class="headerlink" title="运行测试"></a>运行测试</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598787914608-c71c5263-ae91-472f-b760-cc3fbd78b81c.png#align=left&amp;display=inline&amp;height=1080&amp;margin=%5Bobject%20Object%5D&amp;originHeight=1080&amp;originWidth=1842&amp;size=0&amp;status=done&amp;style=none&amp;width=1842" alt><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598787914608-14ca2925-9dd2-4cfd-9399-597c08094743.png#align=left&amp;display=inline&amp;height=285&amp;margin=%5Bobject%20Object%5D&amp;originHeight=285&amp;originWidth=1836&amp;size=0&amp;status=done&amp;style=none&amp;width=1836" alt></p>
]]></content>
      <categories>
        <category>Environment</category>
      </categories>
  </entry>
  <entry>
    <title>P141. 环形链表</title>
    <url>/blog/fgkbg2/</url>
    <content><![CDATA[<pre><code class="java">/**
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
</code></pre>
<h2 id="141-环形链表"><a href="#141-环形链表" class="headerlink" title="141. 环形链表"></a>141. 环形链表</h2><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>给定一个链表，判断链表中是否有环。</p>
<p>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。</p>
<p>如果链表中存在环，则返回 true 。 否则，返回 false 。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1603195777983-5574f7c4-135c-45c2-aef2-6118e954bf68.png#align=left&amp;display=inline&amp;height=172&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=343&amp;originWidth=726&amp;size=36403&amp;status=done&amp;style=shadow&amp;width=363" alt="image.png"></p>
<h3 id="问题思路"><a href="#问题思路" class="headerlink" title="问题思路"></a>问题思路</h3><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><pre><code class="java">public class Solution {
    public boolean hasCycle(ListNode head) {
        if (head == null || head.next == null) return false;

        // TODO: 快慢指针
        ListNode slow = head;
        ListNode fast = head.next;
        while (fast != null &amp;&amp; fast.next != null) {
            slow = slow.next;
            fast = fast.next.next;
            if (slow == fast) return true; //如果能相遇则表示有环
        }
        return false; //不能相遇则没有环
    }
}
</code></pre>
]]></content>
      <categories>
        <category>DataStructure</category>
      </categories>
  </entry>
  <entry>
    <title>权限管理</title>
    <url>/blog/frgbbo/</url>
    <content><![CDATA[<h1 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h1><blockquote>
<p>本文所有操作，均可<strong>通过普通 SQL 语句更新系统表 user</strong>来实现相应的功能。</p>
</blockquote>
<h2 id="新建用户"><a href="#新建用户" class="headerlink" title="新建用户"></a>新建用户</h2><blockquote>
<p>基本格式</p>
</blockquote>
<pre><code class="sql">CREATE USER &#39;username&#39;@&#39;host&#39; IDENTIFIED BY &#39;password&#39;;
</code></pre>
<p>注意引号的位置，不要用一对引号把@也包含进来。@前面是用户名，后面是主机名，可以使用通配符<code>%</code></p>
<blockquote>
<p>实际上可以省略用户名和主机名处的引号，但如果使用了通配符则引号不能省略</p>
</blockquote>
<pre><code class="sql">CREATE USER &#39;jelly&#39;@&#39;%&#39; IDENTIFIED BY &#39;123456&#39;;
CREATE USER jelly@127.0.0.1;
CREATE USER jelly;
</code></pre>
<h2 id="删除用户"><a href="#删除用户" class="headerlink" title="删除用户"></a>删除用户</h2><pre><code class="sql">DROP USER user;
DROP USER jelly@&#39;%&#39;;
DROP USER jelly@localhost
</code></pre>
<h2 id="重命名用户"><a href="#重命名用户" class="headerlink" title="重命名用户"></a>重命名用户</h2><blockquote>
<p>例如：</p>
</blockquote>
<pre><code class="sql">RENAME USER &#39;jelly&#39;@&#39;%&#39; TO &#39;guodong&#39;@&#39;%&#39;;
</code></pre>
<h2 id="修改密码"><a href="#修改密码" class="headerlink" title="修改密码"></a>修改密码</h2><blockquote>
<p>例如：</p>
</blockquote>
<pre><code class="sql">SET PASSWORD FOR &#39;root&#39;@&#39;localhost&#39; = PASSWORD(&#39;123456&#39;);
</code></pre>
<blockquote>
<p>此外还可以使用 mysql 工具<code>mysqladmin</code>来修改<br>格式：<code>mysqladmin -u用户名 -p旧密码 password 新密码</code></p>
</blockquote>
<h1 id="权限管理"><a href="#权限管理" class="headerlink" title="权限管理"></a>权限管理</h1><table>
<thead>
<tr>
<th>权限范围</th>
<th>可用权限</th>
</tr>
</thead>
<tbody>
<tr>
<td>表权限</td>
<td><code>Select</code>, <code>Insert</code>, <code>Update</code>, <code>Delete</code>, <code>Create</code>, <code>Drop</code>, <code>Grant</code>, <code>References</code>, <code>Index</code>, <code>Alter</code></td>
</tr>
<tr>
<td>列权限</td>
<td><code>Select</code>, <code>Insert</code>, <code>Update</code>,<code>References</code></td>
</tr>
<tr>
<td>过程权限</td>
<td><code>Execute</code>, <code>Alter Routine</code>, <code>Grant</code></td>
</tr>
</tbody>
</table>
<h2 id="授权"><a href="#授权" class="headerlink" title="授权"></a>授权</h2><pre><code class="sql">GRANT SELECT ON *.*  TO jelly@&#39;%&#39;
//给一个用户（jelly）分配全部的操作权限
GRANT ALL PRIVILEGES ON *.*  TO jelly@&#39;%&#39;
</code></pre>
<p>%就是前面我们提到过的通配符，可以匹配 0 到 n 个字符。这里指的是该用户所登录的任何主机。</p>
<h2 id="取消授权"><a href="#取消授权" class="headerlink" title="取消授权"></a>取消授权</h2><p>语法：</p>
<pre><code class="sql">REVOKE privilege ON databasename.tablename FROM &#39;username&#39;@&#39;host&#39;;
</code></pre>
<p>例如：</p>
<pre><code class="sql">REVOKE SELECT ON test.user FROM &#39;jelly&#39;@&#39;%&#39;;
REVOKE ALL ON *.* FROM &#39;jelly&#39;@&#39;%&#39;;
</code></pre>
<blockquote>
<p><strong>GRANT</strong>和<strong>REVOKE</strong>对于用户而言，一个是<strong>TO</strong>，一个是<strong>FROM</strong></p>
</blockquote>
<h2 id="查看授权"><a href="#查看授权" class="headerlink" title="查看授权"></a>查看授权</h2><p>例如：</p>
<pre><code class="sql">SHOW GRANTS FOR &#39;jelly&#39;@&#39;%&#39;;
</code></pre>
<h2 id="刷新权限"><a href="#刷新权限" class="headerlink" title="刷新权限"></a>刷新权限</h2><pre><code class="sql">FLUSH PRIVILEGES
</code></pre>
<p>偶尔会出现，修改了操作系统表的权限，却没有及时更新的情况。可以用上述命令刷新。</p>
]]></content>
      <categories>
        <category>Language</category>
      </categories>
  </entry>
  <entry>
    <title>npm- ERR! Unexpected end of JSON input while parsing</title>
    <url>/blog/gcwu9h/</url>
    <content><![CDATA[<h2 id="报错信息"><a href="#报错信息" class="headerlink" title="报错信息"></a>报错信息</h2><pre><code class="bash">npm WARN deprecated circular-json@0.5.9: CircularJSON is in maintenance only, flatted is its successor.
npm ERR! Unexpected end of JSON input while parsing near &#39;...:&quot;~0.0.0&quot;,&quot;webpack-de&#39;

npm ERR! A complete log of this run can be found in:
npm ERR! C:\文件路径\npm-cache_logs\2018-12-13T10_24_02_151Z-debug.log
Package install failed, see above.
</code></pre>
<p>（具体的报错信息和这个类似）<br>升级 hexo5.0 过程中，npm i –save 出错，各种插件都不能很好的下载。</p>
<h2 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h2><p>在 node 安装目录下配置的 node_cache 目录里面 <code>D:\Develop\nodejs</code><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1603808754530-64316710-95b9-4e13-98dd-efda5197f782.png#align=left&amp;display=inline&amp;height=167&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=487&amp;originWidth=1128&amp;size=62358&amp;status=done&amp;style=shadow&amp;width=387" alt="image.png"><br>系统盘的 AppData/roaming 的文件夹并没有一个 npm 的缓存目录，安装 node 的时候将<code>D:\Develop\nodejs</code> 放到系统环境变量的 Path 路径了。</p>
<p>所以只需要一下两条命令即可</p>
<pre><code class="bash">npm cache clean --force

npm install
</code></pre>
<p>**</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://stackoverflow.com/questions/53759929/npm-err-unexpected-end-of-json-input-while-parsing" target="_blank" rel="noopener">stackoverflow-npm ERR! Unexpected end of JSON input while parsing</a></li>
<li><a href="https://www.ruanyifeng.com/blog/2016/01/npm-install.html" target="_blank" rel="noopener">阮一峰-npm 模块安装机制简介</a></li>
</ul>
]]></content>
      <categories>
        <category>Bug</category>
      </categories>
  </entry>
  <entry>
    <title>java-数组越界和格式输出</title>
    <url>/blog/ggg01q/</url>
    <content><![CDATA[<h2 id="一、数组越界"><a href="#一、数组越界" class="headerlink" title="一、数组越界"></a>一、数组越界</h2><pre><code>java.lang.ArrayIndexOutOfBoundsException
</code></pre><p>在进行判断条件的时候，注意 java 当中的数组“尾巴”不要溢出，数组 arr 的合法错误范围是[0, arr.length-1]</p>
<blockquote>
<ul>
<li>解决办法</li>
<li>①debug 看数组的尾巴部分输出情况【数组空间小的情况】</li>
<li>② 打印出遍历数组的索引值【通法】</li>
</ul>
</blockquote>
<p>回顾 java 初始化数组的方式：</p>
<ul>
<li>静态初始化：初始化时由程序员显式指定每个数组元素的初始值，有系统决定数组的长度</li>
</ul>
<blockquote>
<p>arrayName = new type[]{element1,element2,element3…}</p>
</blockquote>
<pre><code>int[] intArr;
intArr = new int[]{1,2,3,4,5,9};
或者
String[] strArr = {&quot;one&quot;,&quot;two&quot;,&quot;three&quot;};
</code></pre><ul>
<li>动态初始化：初始化时由程序员指定数组的长度，由系统初始化每个数组元素的默认值</li>
</ul>
<blockquote>
<p>arrayName = new type[length];</p>
</blockquote>
<pre><code>int[] price = new int[4];
</code></pre><h2 id="二、printf；println；print"><a href="#二、printf；println；print" class="headerlink" title="二、printf；println；print"></a>二、printf；println；print</h2><ul>
<li>printf：遇到浮点型数值，继承 C 语言里面的使用，<strong>格式化</strong>输出（注意，参数顺序）</li>
<li>print：就是一般的标准输出，但是不换行</li>
<li>println：比 print 多的就是最后会换行</li>
</ul>
<pre><code class="java">int i = 4;
double j = 5;
System.out.print(&quot;用print输出i:&quot;+ i);
System.out.println( &quot;用println输出i:&quot;+ i);
System.out.printf(&quot;i的值为%d,j的值为%f&quot;, i,j);
</code></pre>
<pre><code class="java">用print输出i:4用println输出i:4
i的值为4,j的值为5.000000
</code></pre>
<ul>
<li>printf 补充</li>
</ul>
<blockquote>
<p><code>%.2f</code>的意思是输出两位小数点<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1602926246151-1730c963-0816-46d1-bd3d-3a5cc7b30403.png#align=left&amp;display=inline&amp;height=589&amp;margin=%5Bobject%20Object%5D&amp;originHeight=589&amp;originWidth=1162&amp;size=0&amp;status=done&amp;style=none&amp;width=1162" alt></p>
</blockquote>
]]></content>
      <categories>
        <category>Bug</category>
      </categories>
  </entry>
  <entry>
    <title>贪心算法-Huffman算法</title>
    <url>/blog/ggu8v9/</url>
    <content><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>压缩算法，目的就是根据字母的出现频率来“按需分配”编码来优化编码方式。</p>
<p>比如：给出一串字母 <code>Huffman Coding</code>   ，按照计算机处理形式，会根据 ascll 码将这串字符编码，具体形式（十进制）就是 104 117 102 102 109 97 110 32 67 111 100 105 110 103，然后转换成二进制，最后会得到需要 97 个比特来存储。</p>
<h2 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h2><p>算法角度来讲对上述问题 ascll 编码方式是浪费空间的，优化方向是改变编码方式，根据字母出现的频率来“按需分配”进制位。</p>
<p>给出下面所给出的字母，以及出现的频率，来得到哈夫曼编码<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1605340774734-5ec5e8f1-0fae-47ff-8ded-dccf9611a3ad.png#align=left&amp;display=inline&amp;height=45&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=89&amp;originWidth=411&amp;size=4276&amp;status=done&amp;style=shadow&amp;width=205.5" alt="image.png"><br>先提出将频率小的依次加入。d 和 h 组合权值为 9(或者说 A 只是称呼方便)，然后将这个 9“替换 d 和 h”代入整个序列，在进行插入树操作，</p>
<blockquote>
<p>过程中，遵循数字大的在左数字小的在右原则（互换也没关系，只不过换的是二进制的 0 和 1）</p>
</blockquote>
<p>在进行到 E 的时候，此时的队列应该为 120 107 42 37，所以此时需要重新调整队列，然后进行到结束。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1605340899720-d8867a90-d01c-4bf6-8ec7-ca0e812a99dd.png#align=left&amp;display=inline&amp;height=221&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=443&amp;originWidth=376&amp;size=24239&amp;status=done&amp;style=shadow&amp;width=188" alt="image.png"><br>最后的编码结果为：<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1605341313840-61587c86-135d-4ba0-96aa-844868de1d56.png#align=left&amp;display=inline&amp;height=101&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=201&amp;originWidth=165&amp;size=4405&amp;status=done&amp;style=shadow&amp;width=82.5" alt="image.png"></p>
<h2 id="编码实现"><a href="#编码实现" class="headerlink" title="编码实现"></a>编码实现</h2><pre><code class="cpp">#include &lt;stdio.h&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
namespace NS_HuffmanCoding {
using namespace std;
void BuildHuffmanTree();
void Initialization(vector&lt;pair&lt;char, int&gt;&gt; chars);
void Finalization();
struct HFMNode {
  char Ch; int Freq;
  HFMNode* Left, * Right;
  HFMNode(char pCh, int pFreq, HFMNode* pLeft, HFMNode* pRight)
    : Ch(pCh), Freq(pFreq), Left(pLeft), Right(pRight) {}
  HFMNode(char pCh, int pFreq)
    : HFMNode(pCh, pFreq, NULL, NULL) {}
};
void MinHeapify(vector&lt;HFMNode*&gt;&amp; H);
void InsertH(vector&lt;HFMNode*&gt;&amp; H, HFMNode* node);
void SiftDown(vector&lt;HFMNode*&gt;&amp; H, int i);
void SiftUp(vector&lt;HFMNode*&gt;&amp; H, int i);
HFMNode* ExtractMin(vector&lt;HFMNode*&gt;&amp; H);
void DeleteANode(HFMNode* node);
void ShowInput(vector&lt;pair&lt;char, int&gt;&gt; chars);
void Output();
static vector&lt;HFMNode*&gt; Q;
void HuffmanCodingCaller(vector&lt;pair&lt;char, int&gt;&gt; chars)
{
  ShowInput(chars);
  Initialization(chars);
  BuildHuffmanTree();
  Output();
  Finalization();
}
void BuildHuffmanTree()
{
  char C = &#39;A&#39;;
  while (Q.size() &gt; 1)
  {
    HFMNode* x = ExtractMin(Q);
    HFMNode* y = ExtractMin(Q);
    HFMNode* z = new HFMNode(C++, x-&gt;Freq + y-&gt;Freq, x, y);
    InsertH(Q, z);
  }
}
HFMNode* ExtractMin(vector&lt;HFMNode*&gt;&amp; H)
{
  swap(H.front(), H.back());
  HFMNode* p = H.back();
  H.pop_back();
  if (!H.empty())
    SiftDown(H, 0);
  return p;
}
void SiftDown(vector&lt;HFMNode*&gt;&amp; H, int i)
{
    while ((i = (i &lt;&lt; 1) + 1) &lt; H.size()) {
        if ((i + 1 &lt; H.size()) &amp;&amp; (H[i + 1]-&gt;Freq &lt; H[i]-&gt;Freq))
            i = i + 1;
        if (H[(i - 1) &gt;&gt; 1]-&gt;Freq &gt; H[i]-&gt;Freq)
            swap(H[(i - 1) &gt;&gt; 1], H[i]);
        else break;
    }
}
void InsertH(vector&lt;HFMNode*&gt;&amp; H, HFMNode* node)
{
  H.push_back(node);
  SiftUp(H, H.size() - 1);
}
void SiftUp(vector&lt;HFMNode*&gt;&amp; H, int i)
{
  while (i &gt; 0 &amp;&amp; H[i]-&gt;Freq &lt; H[(i - 1) &gt;&gt; 1]-&gt;Freq) {
    swap(H[i], H[(i - 1) &gt;&gt; 1]);
    i = (i - 1) &gt;&gt; 1;
  }
}
void MinHeapify(vector&lt;HFMNode*&gt;&amp; H)
{
  for (int i = (H.size() &gt;&gt; 1) - 1; i &gt;= 0; i--) {
    SiftDown(H, i);
  }
}

void Initialization(vector&lt;pair&lt;char, int&gt;&gt; chars)
{
  Q.clear();
  for (auto ch : chars)
    Q.push_back(new HFMNode(ch.first, ch.second));
  MinHeapify(Q);
}
void Finalization()
{
  DeleteANode(Q[0]);
}
void DeleteANode(HFMNode* node)
{
  if (node-&gt;Left)
  {
    DeleteANode(node-&gt;Left);
    DeleteANode(node-&gt;Right);
  }
  delete node;
}
void ShowInput(vector&lt;pair&lt;char, int&gt;&gt; chars)
{
  printf(&quot;Huffman coding input: \n&quot;);
  for (auto c : chars)
    printf(&quot;%c,%d; &quot;, c.first, c.second);
  printf(&quot;\n&quot;);
}
static vector&lt;char&gt; coding;
static vector&lt;pair&lt;char, vector&lt;char&gt;&gt;&gt; codingList;
void GetHuffmanCoding(HFMNode* node)
{
  if (node-&gt;Left)
  {
    coding.push_back(&#39;0&#39;);
    GetHuffmanCoding(node-&gt;Left);
    coding.pop_back();
    coding.push_back(&#39;1&#39;);
    GetHuffmanCoding(node-&gt;Right);
    coding.pop_back();
  }
  else
  {
    codingList.push_back(pair&lt;char,
      vector&lt;char&gt;&gt;(node-&gt;Ch, coding));
  }
}
void Output()
{
  printf(&quot;Huffman coding:\n&quot;);
  coding.clear();
  codingList.clear();
  GetHuffmanCoding(Q[0]);
  sort(codingList.begin(), codingList.end());
  for (auto c1 : codingList)
  {
    printf(&quot;  %c: &quot;, c1.first);
    for (auto c2 : c1.second)
      printf(&quot;%c&quot;, c2);
    printf(&quot;\n&quot;);
  }
  printf(&quot;\n&quot;);
}
} //namespace NS_HuffmanCoding
using namespace NS_HuffmanCoding;
void TestHuffmanCoding()
{
  vector&lt;vector&lt;pair&lt;char, int&gt;&gt;&gt; charLists = {
      //Introduction to Algorithms
     {
        { {&#39;a&#39;,40}, {&#39;b&#39;,13}, {&#39;c&#39;,12},
          {&#39;d&#39;,16}, {&#39;e&#39;,9}, {&#39;f&#39;,5} },
     },
     //ÑÏÎµÃô
     {
        { {&#39;a&#39;,5}, {&#39;b&#39;,29}, {&#39;c&#39;,7}, {&#39;d&#39;,8},
          {&#39;e&#39;,14}, {&#39;f&#39;,23}, {&#39;g&#39;,3}, {&#39;h&#39;,11} },
     },
  };
  int n = charLists.size();
  for (int i = 0; i &lt; n; i++)
  {
    HuffmanCodingCaller(charLists[i]);
  }
}
</code></pre>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>P674. 最长连续递增序列</title>
    <url>/blog/guaorh/</url>
    <content><![CDATA[<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><pre><code class="java">package com.wztlink1013.problems.leetcode.editor.cn;

// P674.最长连续递增序列
// P674.longest-continuous-increasing-subsequence
//给定一个未经排序的整数数组，找到最长且 连续递增的子序列，并返回该序列的长度。
//
// 连续递增的子序列 可以由两个下标 l 和 r（l &lt; r）确定，如果对于每个 l &lt;= i &lt; r，都有 nums[i] &lt; nums[i + 1] ，那
//么子序列 [nums[l], nums[l + 1], ..., nums[r - 1], nums[r]] 就是连续递增子序列。
//
//
//
// 示例 1：
//
//
//输入：nums = [1,3,5,4,7]
//输出：3
//解释：最长连续递增序列是 [1,3,5], 长度为3。
//尽管 [1,3,5,7] 也是升序的子序列, 但它不是连续的，因为 5 和 7 在原数组里被 4 隔开。
//
//
// 示例 2：
//
//
//输入：nums = [2,2,2,2,2]
//输出：1
//解释：最长连续递增序列是 [2], 长度为1。
//
//
//
//
// 提示：
//
//
// 0 &lt;= nums.length &lt;= 104
// -109 &lt;= nums[i] &lt;= 109
//
// Related Topics 数组
// 👍 147 👎 0

public class P674LongestContinuousIncreasingSubsequence{
    public static void main(String[] args) {
        Solution solution = new P674LongestContinuousIncreasingSubsequence().new Solution();
        int [] nums = {1,3,5,7};
        int result = solution.findLengthOfLCIS(nums);
        System.out.println(result);
    }

//leetcode submit region begin(Prohibit modification and deletion)
class Solution {
    public int findLengthOfLCIS(int[] nums) {
        if (nums.length == 0) { return 0; }
        int result = 1;
        int count = 1;
        for (int i=0; i&lt;nums.length-1; i++) {
            if (nums[i] &lt; nums[i+1] ) {
                count++;
                if (result &lt; count) {result = count;}
            } else {
                if (result &lt; count) {result = count;}
                count = 1;
            }
        }
        return result;
    }
}
//leetcode submit region end(Prohibit modification and deletion)

}
</code></pre>
<h2 id="细节注意"><a href="#细节注意" class="headerlink" title="细节注意"></a>细节注意</h2><ul>
<li>56 行 count++</li>
<li>将 57 和 59 行代码删去，改为如下表达式赋值</li>
</ul>
<pre><code class="java">result = count &gt; result ? count : result;
</code></pre>
]]></content>
      <categories>
        <category>DataStructure</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>数据的清洗和规整（一）</title>
    <url>/blog/gvi1hn/</url>
    <content><![CDATA[<h2 id="一、数据预览：tail（）、head（）"><a href="#一、数据预览：tail（）、head（）" class="headerlink" title="一、数据预览：tail（）、head（）"></a>一、数据预览：tail（）、head（）</h2><pre><code class="python">import numpy as np
import pandas as pd
df_obj = pd.DataFrame(np.random.randn(5,4), columns = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;])
print(df_obj.tail())# 数据预览尾巴
print(df_obj.head())# 数据预览头部
</code></pre>
<pre><code>          a         b         c         d
0 -0.507788  0.213237  0.003150 -0.777312
1 -0.896653 -2.188016 -0.114848  0.167057
2 -1.131242 -0.142287 -1.027330  1.861814
3  0.369608  0.823453  1.030830 -0.041778
4 -0.647625  0.056791 -0.394078 -1.347718
          a         b         c         d
0 -0.507788  0.213237  0.003150 -0.777312
1 -0.896653 -2.188016 -0.114848  0.167057
2 -1.131242 -0.142287 -1.027330  1.861814
3  0.369608  0.823453  1.030830 -0.041778
4 -0.647625  0.056791 -0.394078 -1.347718
</code></pre><h2 id="二、数据描述：shape、info"><a href="#二、数据描述：shape、info" class="headerlink" title="二、数据描述：shape、info()"></a>二、数据描述：shape、info()</h2><pre><code class="python">print (&#39;数据集有%i行，%i列&#39; %(df_obj.shape[0], df_obj.shape[1]))
</code></pre>
<pre><code>数据集有5行，4列
</code></pre><pre><code class="python">print(df_obj.info())
</code></pre>
<pre><code>&lt;class &#39;pandas.core.frame.DataFrame&#39;&gt;
RangeIndex: 5 entries, 0 to 4
Data columns (total 4 columns):
a    5 non-null float64
b    5 non-null float64
c    5 non-null float64
d    5 non-null float64
dtypes: float64(4)
memory usage: 288.0 bytes
None
</code></pre><h2 id="三、数据统计：describe"><a href="#三、数据统计：describe" class="headerlink" title="三、数据统计：describe()"></a>三、数据统计：describe()</h2><pre><code class="python">print(df_obj.describe())
</code></pre>
<pre><code>              a         b         c         d
count  5.000000  5.000000  5.000000  5.000000
mean  -0.562740 -0.247365 -0.100455 -0.027587
std    0.573191  1.143294  0.747673  1.215808
min   -1.131242 -2.188016 -1.027330 -1.347718
25%   -0.896653 -0.142287 -0.394078 -0.777312
50%   -0.647625  0.056791 -0.114848 -0.041778
75%   -0.507788  0.213237  0.003150  0.167057
max    0.369608  0.823453  1.030830  1.861814
</code></pre><h2 id="四、pandas-不完全显示行列"><a href="#四、pandas-不完全显示行列" class="headerlink" title="四、pandas 不完全显示行列"></a>四、pandas 不完全显示行列</h2><pre><code>pd.set_option(&#39;display.max_rows&#39;, 100)        //显示的最大行数（避免只显示部分行数据）
pd.set_option(&#39;display.max_columns&#39;, 1000)    //显示的最大列数（避免列显示不全）
pd.set_option(&quot;display.max_colwidth&quot;, 1000)   //每一列最大的宽度（避免属性值或列名显示不全）
pd.set_option(&#39;display.width&#39;, 1000)          //每一行的宽度（避免换行）
</code></pre><h2 id="五、删除指定行列数据"><a href="#五、删除指定行列数据" class="headerlink" title="五、删除指定行列数据"></a>五、删除指定行列数据</h2><pre><code class="python">import pandas as pd
import numpy as np
</code></pre>
<pre><code class="python">dict_data = {&#39;A&#39;: 1.,
             &#39;B&#39;: pd.Timestamp(&#39;20161217&#39;),
             &#39;C&#39;: pd.Series(1, index=list(range(4)),dtype=&#39;float32&#39;),
             &#39;D&#39;: np.array([3] * 4,dtype=&#39;int32&#39;),
             &#39;E&#39; : pd.Categorical([&quot;Python&quot;,&quot;Java&quot;,&quot;C++&quot;,&quot;C#&quot;]),
             &#39;F&#39; : &#39;ChinaHadoop&#39; }
df_obj2 = pd.DataFrame(dict_data)
print(df_obj2)
</code></pre>
<pre><code>     A          B    C  D       E            F
0  1.0 2016-12-17  1.0  3  Python  ChinaHadoop
1  1.0 2016-12-17  1.0  3    Java  ChinaHadoop
2  1.0 2016-12-17  1.0  3     C++  ChinaHadoop
3  1.0 2016-12-17  1.0  3      C#  ChinaHadoop
</code></pre><h3 id="del"><a href="#del" class="headerlink" title="del"></a>del</h3><blockquote>
<p>删除列</p>
</blockquote>
<pre><code class="python">del df_obj2[&#39;A&#39;]
print (df_obj2.head())
</code></pre>
<pre><code>           B    C  D       E            F
0 2016-12-17  1.0  3  Python  ChinaHadoop
1 2016-12-17  1.0  3    Java  ChinaHadoop
2 2016-12-17  1.0  3     C++  ChinaHadoop
3 2016-12-17  1.0  3      C#  ChinaHadoop
</code></pre><h3 id="drop"><a href="#drop" class="headerlink" title="drop"></a>drop</h3><blockquote>
<p>删除行/列数据</p>
</blockquote>
<pre><code class="python">dict_data = {&#39;A&#39;: 1.,
             &#39;B&#39;: pd.Timestamp(&#39;20161217&#39;),
             &#39;C&#39;: pd.Series(1, index=list(range(4)),dtype=&#39;float32&#39;),
             &#39;D&#39;: np.array([3] * 4,dtype=&#39;int32&#39;),
             &#39;E&#39; : pd.Categorical([&quot;Python&quot;,&quot;Java&quot;,&quot;C++&quot;,&quot;C#&quot;]),
             &#39;F&#39; : &#39;ChinaHadoop&#39; }
df_obj3 = pd.DataFrame(dict_data,index = [&#39;sfd&#39;,&#39;sdfd&#39;,&#39;wer&#39;,&#39;rwer&#39;])
print (df_obj3.head(7))
print(df_obj3.drop(&#39;wer&#39;))#删除行
print(df_obj3.drop(&#39;F&#39;,axis=1))#删除列
</code></pre>
<pre><code>        A          B   C  D       E            F
sfd   1.0 2016-12-17 NaN  3  Python  ChinaHadoop
sdfd  1.0 2016-12-17 NaN  3    Java  ChinaHadoop
wer   1.0 2016-12-17 NaN  3     C++  ChinaHadoop
rwer  1.0 2016-12-17 NaN  3      C#  ChinaHadoop
        A          B   C  D       E            F
sfd   1.0 2016-12-17 NaN  3  Python  ChinaHadoop
sdfd  1.0 2016-12-17 NaN  3    Java  ChinaHadoop
rwer  1.0 2016-12-17 NaN  3      C#  ChinaHadoop
        A          B   C  D       E
sfd   1.0 2016-12-17 NaN  3  Python
sdfd  1.0 2016-12-17 NaN  3    Java
wer   1.0 2016-12-17 NaN  3     C++
rwer  1.0 2016-12-17 NaN  3      C#
</code></pre><h2 id="六、处理缺失数据"><a href="#六、处理缺失数据" class="headerlink" title="六、处理缺失数据"></a>六、处理缺失数据</h2><pre><code class="python">df_data = pd.DataFrame([np.random.randn(3), [1., np.nan, np.nan],
                       [4., np.nan, np.nan], [1., np.nan, 2.]])
df_data.head()
</code></pre>
<table>
<thead>
<tr>
<th></th>
<th>0</th>
<th>1</th>
<th>2</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>-0.702713</td>
<td>-0.991383</td>
<td>-1.058464</td>
</tr>
<tr>
<td>1</td>
<td>1.000000</td>
<td>NaN</td>
<td>NaN</td>
</tr>
<tr>
<td>2</td>
<td>4.000000</td>
<td>NaN</td>
<td>NaN</td>
</tr>
<tr>
<td>3</td>
<td>1.000000</td>
<td>NaN</td>
<td>2.000000</td>
</tr>
</tbody>
</table>
<h3 id="判断是否存在缺失值"><a href="#判断是否存在缺失值" class="headerlink" title="判断是否存在缺失值"></a>判断是否存在缺失值</h3><pre><code class="python">df_data.isnull()
</code></pre>
<table>
<thead>
<tr>
<th></th>
<th>0</th>
<th>1</th>
<th>2</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>False</td>
<td>False</td>
<td>False</td>
</tr>
<tr>
<td>1</td>
<td>False</td>
<td>True</td>
<td>True</td>
</tr>
<tr>
<td>2</td>
<td>False</td>
<td>True</td>
<td>True</td>
</tr>
<tr>
<td>3</td>
<td>False</td>
<td>True</td>
<td>False</td>
</tr>
</tbody>
</table>
<h3 id="丢弃缺失数据"><a href="#丢弃缺失数据" class="headerlink" title="丢弃缺失数据"></a>丢弃缺失数据</h3><pre><code class="python">print(df_data.dropna(axis=0))
#0是行；1是列
</code></pre>
<pre><code>          0         1         2
0 -0.702713 -0.991383 -1.058464
</code></pre><h3 id="填充缺失数据"><a href="#填充缺失数据" class="headerlink" title="填充缺失数据"></a>填充缺失数据</h3><pre><code class="python">df_data.fillna(-100.)
</code></pre>
<table>
<thead>
<tr>
<th></th>
<th>0</th>
<th>1</th>
<th>2</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>-0.702713</td>
<td>-0.991383</td>
<td>-1.058464</td>
</tr>
<tr>
<td>1</td>
<td>1.000000</td>
<td>-100.000000</td>
<td>-100.000000</td>
</tr>
<tr>
<td>2</td>
<td>4.000000</td>
<td>-100.000000</td>
<td>-100.000000</td>
</tr>
<tr>
<td>3</td>
<td>1.000000</td>
<td>-100.000000</td>
<td>2.000000</td>
</tr>
</tbody>
</table>
<p>##</p>
]]></content>
      <categories>
        <category>DataAnalysis</category>
      </categories>
  </entry>
  <entry>
    <title>hexo-部署出错at formatNunjucksError</title>
    <url>/blog/gw1d4z/</url>
    <content><![CDATA[<h2 id="报错信息"><a href="#报错信息" class="headerlink" title="报错信息"></a>报错信息</h2><p>GitHub Actions 流程中 hexo g 出现错误，具体错误在“Vue 笔记”中那篇文章中，有个地方用到了大括号嵌套的情况。</p>
<pre><code class="bash">    =====             Context Dump Ends            =====
    at formatNunjucksError (/home/runner/work/website/website/node_modules/hexo/lib/extend/tag.js:102:13)
    at Promise.fromCallback.catch.err (/home/runner/work/website/website/node_modules/hexo/lib/extend/tag.js:124:34)
    at tryCatcher (/home/runner/work/website/website/node_modules/bluebird/js/release/util.js:16:23)
    at Promise._settlePromiseFromHandler (/home/runner/work/website/website/node_modules/bluebird/js/release/promise.js:547:31)
    at Promise._settlePromise (/home/runner/work/website/website/node_modules/bluebird/js/release/promise.js:604:18)
    at Promise._settlePromise0 (/home/runner/work/website/website/node_modules/bluebird/js/release/promise.js:649:10)
    at Promise._settlePromises (/home/runner/work/website/website/node_modules/bluebird/js/release/promise.js:725:18)
    at _drainQueueStep (/home/runner/work/website/website/node_modules/bluebird/js/release/async.js:93:12)
    at _drainQueue (/home/runner/work/website/website/node_modules/bluebird/js/release/async.js:86:9)
    at Async._drainQueues (/home/runner/work/website/website/node_modules/bluebird/js/release/async.js:102:5)
    at Immediate.Async.drainQueues [as _onImmediate] (/home/runner/work/website/website/node_modules/bluebird/js/release/async.js:15:14)
    at runCallback (timers.js:705:18)
    at tryOnImmediate (timers.js:676:5)
    at processImmediate (timers.js:658:5)
Error: Process completed with exit code 2.
</code></pre>
<h2 id="问题分析与解决"><a href="#问题分析与解决" class="headerlink" title="问题分析与解决"></a>问题分析与解决</h2><p>上述代码中第二行其实已经说的很明确 <code>at formatNunjucksError</code><br>但是 hexo 中，渲染过程中用到的是 Nunjucks，在 Nunjucks 中双大括号被视为语法，所以报错。</p>
<h2 id="小记"><a href="#小记" class="headerlink" title="小记"></a>小记</h2><p><a href="https://www.wztlink1013.com/blog/pxpix4/">https://www.wztlink1013.com/blog/pxpix4/</a></p>
<p>其实之前遇到过类似的问题……写的博客还是要经常回顾……</p>
]]></content>
      <categories>
        <category>Bug</category>
      </categories>
  </entry>
  <entry>
    <title>.gitignore文件使用总结</title>
    <url>/blog/hgxgvd/</url>
    <content><![CDATA[<blockquote>
<p>这篇文章是根据博客园用户<a href="https://home.cnblogs.com/u/kevingrace/" target="_blank" rel="noopener">散尽浮华</a>整理来的，原文请看：<a href="https://www.cnblogs.com/kevingrace/p/5690241.html" target="_blank" rel="noopener">https://www.cnblogs.com/kevingrace/p/5690241.html</a></p>
</blockquote>
<p>在 Git 项目将要提交到 github 仓库的时候，有些时候我们想要将指定文件不 push，例如含有敏感信息类似 token 的文件，或者.class、.xml、等文件</p>
<h2 id="忽略指定文件的-push-的三种方式"><a href="#忽略指定文件的-push-的三种方式" class="headerlink" title="忽略指定文件的 push 的三种方式"></a>忽略指定文件的 push 的三种方式</h2><ul>
<li>方式一：在 Git 项目中定义.gitignore 文件</li>
<li>方式二：在 Git 项目的设置中指定排除文件</li>
<li>方式三：定义 Git 全局的 .gitignore 文件</li>
</ul>
<h2 id="语法规则"><a href="#语法规则" class="headerlink" title="语法规则"></a>语法规则</h2><pre><code>#               表示此为注释,将被Git忽略
*.a             表示忽略所有 .a 结尾的文件
!lib.a          表示但lib.a除外
/TODO           表示仅仅忽略项目根目录下的 TODO 文件，不包括 subdir/TODO
build/          表示忽略 build/目录下的所有文件，过滤整个build文件夹；
doc/*.txt       表示会忽略doc/notes.txt但不包括 doc/server/arch.txt

bin/:           表示忽略当前路径下的bin文件夹，该文件夹下的所有内容都会被忽略，不忽略 bin 文件
/bin:           表示忽略根目录下的bin文件
/*.c:           表示忽略cat.c，不忽略 build/cat.c
debug/*.obj:    表示忽略debug/io.obj，不忽略 debug/common/io.obj和tools/debug/io.obj
**/foo:         表示忽略/foo,a/foo,a/b/foo等
a/**/b:         表示忽略a/b, a/x/b,a/x/y/b等
!/bin/run.sh    表示不忽略bin目录下的run.sh文件
*.log:          表示忽略所有 .log 文件
config.php:     表示忽略当前路径的 config.php 文件

/mtk/           表示过滤整个文件夹
*.zip           表示过滤所有.zip文件
/mtk/do.c       表示过滤某个具体文件

被过滤掉的文件就不会出现在git仓库中（gitlab或github）了，当然本地库中还有，只是push的时候不会上传。

需要注意的是，gitignore还可以指定要将哪些文件添加到版本管理中，如下：
!*.zip
!/mtk/one.txt

唯一的区别就是规则开头多了一个感叹号，Git会将满足这类规则的文件添加到版本管理中。为什么要有两种规则呢？
想象一个场景：假如我们只需要管理/mtk/目录中的one.txt文件，这个目录中的其他文件都不需要管理，那么.gitignore规则应写为：：
/mtk/*
!/mtk/one.txt

假设我们只有过滤规则，而没有添加规则，那么我们就需要把/mtk/目录下除了one.txt以外的所有文件都写出来！
注意上面的/mtk/*不能写为/mtk/，否则父目录被前面的规则排除掉了，one.txt文件虽然加了!过滤规则，也不会生效！

----------------------------------------------------------------------------------
还有一些规则如下：
fd1/*
说明：忽略目录 fd1 下的全部内容；注意，不管是根目录下的 /fd1/ 目录，还是某个子目录 /child/fd1/ 目录，都会被忽略；

/fd1/*
说明：忽略根目录下的 /fd1/ 目录的全部内容；

/*
!.gitignore
!/fw/
/fw/*
!/fw/bin/
!/fw/sf/
说明：忽略全部内容，但是不忽略 .gitignore 文件、根目录下的 /fw/bin/ 和 /fw/sf/ 目录；注意要先对bin/的父目录使用!规则，使其不被排除。
</code></pre><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul>
<li>文章主要参考：<a href="https://www.cnblogs.com/kevingrace/p/5690241.html" target="_blank" rel="noopener">https://www.cnblogs.com/kevingrace/p/5690241.html</a></li>
</ul>
]]></content>
      <categories>
        <category>Environment</category>
      </categories>
  </entry>
  <entry>
    <title>Python-apply函数和入口函数</title>
    <url>/blog/hy14ic/</url>
    <content><![CDATA[<h2 id="pandas-之-apply-函数"><a href="#pandas-之-apply-函数" class="headerlink" title="pandas 之 apply 函数"></a>pandas 之 apply 函数</h2><pre><code>DataFrame.apply(func, axis=0, broadcast=False, raw=False, reduce=None, args=(), **kwds)
</code></pre><p>第一个参数，这个参数是函数，相当于 C/C++的函数指针。</p>
<p>这个函数需要自己实现，函数的传入参数根据 axis 来定，比如 axis = 1，就会把一行数据作为 Series 的数据<br>结构传入给自己实现的函数中，我们在函数中实现对 Series 不同属性之间的计算，返回一个结果，则 apply 函数<br>会自动遍历每一行 DataFrame 的数据，最后将所有结果组合成一个 Series 数据结构并返回。</p>
<h2 id="if-name-‘main’"><a href="#if-name-‘main’" class="headerlink" title="if name == ‘main’"></a>if <strong>name</strong> == ‘main’</h2><p><a href="https://zhuanlan.zhihu.com/p/34112508" target="_blank" rel="noopener">参考：知乎用户</a></p>
]]></content>
      <categories>
        <category>Language</category>
      </categories>
  </entry>
  <entry>
    <title>表查询操作</title>
    <url>/blog/igxqxi/</url>
    <content><![CDATA[<h2 id="基本词汇"><a href="#基本词汇" class="headerlink" title="基本词汇"></a>基本词汇</h2><blockquote>
<p>查询就是 SELECT 语句</p>
</blockquote>
<pre><code class="sql">SELECT  [ ALL | DISTINCT ]
        [ TOP expression [ PERCENT ] [ WITH TIES ] ]
    &lt;列名&gt;                                             /*指定要选择的列及其限定*/
    [ INTO &lt;表名&gt; ]                             /*INTO子句，指定结果存入新表*/
    [ FROM &lt;查询对象&gt; ]                        /*FROM子句，指定表或视图*/
    [ WHERE &lt;条件&gt; ]                             /*WHERE子句，指定查询条件*/
    [ GROUP BY &lt;分组表达式&gt;]                 /*GROUP BY子句，指定分组表达式*/
    [ HAVING &lt;分组统计条件&gt;]                 /*HAVING子句，指定分组统计条件*/
    [ ORDER BY &lt;排序表达式&gt; [ ASC | DESC ] ] /*ORDER子句，指定排序表达式和顺序*/

</code></pre>
<blockquote>
<p>说明：所有被使用的子句必须按语法说明中显示的顺序严格地排序。例如，一个 HAVING 子句必须位于 GROUP BY 子句之后，并位于 ORDER BY 子句之前。<br>SELECT 语句返回一个表的结果集，通常该结果集被称为表值表达式。</p>
</blockquote>
<h3 id="distinct"><a href="#distinct" class="headerlink" title="distinct"></a>distinct</h3><p>去掉重复的行</p>
<h3 id="where"><a href="#where" class="headerlink" title="where"></a>where</h3><blockquote>
<p>条件</p>
</blockquote>
<pre><code class="sql">select distinct Sname
        from Student
        where Sdept=&#39;CS&#39;
</code></pre>
<h3 id="as"><a href="#as" class="headerlink" title="as"></a>as</h3><pre><code class="sql">SELECT id AS userId，username AS uname
    FROM users;
</code></pre>
<p>查询出来的列名，就变成了别名。AS 其实可以省略，但可能会出现问题。</p>
<pre><code class="sql">SELECT id username  FROM users;
</code></pre>
<p>这样会将 username 视作 id 的别名。</p>
<h3 id="like"><a href="#like" class="headerlink" title="like"></a>like</h3><pre><code class="sql">SELECT 书名 AS BookName, 作译者 AS Author, 出版社 AS Press
FROM TBook
WHERE 书名 LIKE &#39;%SQL Server%&#39;
</code></pre>
<pre><code class="sql">select Sname, Sno, Ssex
    from Student
    where Sname not like &#39;刘_&#39;
</code></pre>
<h3 id="is-not"><a href="#is-not" class="headerlink" title="is not"></a>is not</h3><pre><code class="sql">select Sno, Cno
    from SC
    where Grade is not null
</code></pre>
<h3 id="and、or"><a href="#and、or" class="headerlink" title="and、or"></a>and、or</h3><pre><code class="sql">select Sname, Ssex
    from Student
    where Sdept=&#39;CS&#39; or Sdept=&#39;MA&#39; or Sdept=&#39;IS&#39;
</code></pre>
<blockquote>
<p>键可以不用引号，但是值要引号<br>列名又空格也需要加引号</p>
</blockquote>
<h3 id="top"><a href="#top" class="headerlink" title="top"></a>top</h3><blockquote>
<p>前五行数据</p>
</blockquote>
<pre><code class="sql">select top 5 *
    from rating
</code></pre>
<h3 id="not-in"><a href="#not-in" class="headerlink" title="not in"></a>not in</h3><pre><code class="sql">select Sname, Ssex
    from Student
    where Sdept not in (&#39;CS&#39;, &#39;MA&#39;, &#39;IS&#39;)
</code></pre>
<h3 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h3><ul>
<li>有公共的列，在前面表名以示区分</li>
<li>指明两个表的公共<strong>相等</strong>的列</li>
</ul>
<pre><code class="sql">select TLend.ISBN, TLend.借书时间, TLend.借书证号, TLend.图书ID, TLend.应还时间,TReader.姓名
from TReader,TLend, TBook
where TReader.借书证号 = TLend.借书证号
    and TBook.ISBN = TLend.ISBN
    and TLend.借书证号 = &#39;081101&#39;
    and TBook.书名 = &#39;SQL Server实用教程（第3版）&#39;
</code></pre>
<h3 id="join-on"><a href="#join-on" class="headerlink" title="join on"></a>join on</h3><pre><code class="sql">select 姓名
    from TReader join HLend
    on TReader.借书证号 = HLend.借书证号
    where (还书时间 - 借书时间)&gt;5
</code></pre>
<h3 id="count"><a href="#count" class="headerlink" title="count"></a>count</h3><pre><code class="sql">select count(*) 读者总数
    from TReader
</code></pre>
<h3 id="order-by"><a href="#order-by" class="headerlink" title="order by"></a>order by</h3><p>排序 ORDER BY</p>
<pre><code class="sql">select Sno, Grade
    from SC
    where Cno=&#39;3&#39;
    order by Grade desc
</code></pre>
<pre><code class="sql">SELECT *
        FROM users
    ORDER BY id DESC;
</code></pre>
<p>可以排序多个字段，如果第一个字段能排出结果，就不会用到第 2 个字段。比如：</p>
<pre><code class="sql">select *
    from Student
    order by Sdept asc, Sage desc
</code></pre>
<p>因为年龄 age 有相同的，继续排序就要用到 id 的降序。</p>
<h3 id="limit"><a href="#limit" class="headerlink" title="limit"></a>limit</h3><p>限制返回记录的数量 LIMIT</p>
<p>LIMIT 有两种语法结构，第一种比较常见。</p>
<pre><code class="sql">[LIMIT {[offset,] row_count|row_count OFFSET offset}]
</code></pre>
<p>起始位置，偏移量</p>
<pre><code class="sql">SELECT * FROM users ;
SELECT * FROM users LIMIT 3,2;
SELECT * FROM users LIMIT 2;
</code></pre>
<p>3，2：表示从第 3 条开始返回，返回两条记录。注意记录从 0 开始编号，即结果集中的从第 0 条开始。<br>如果 LIMIT 后面只有一个参数，认作是偏移量，起始位置缺省为 0。</p>
<h3 id="union"><a href="#union" class="headerlink" title="union"></a>union</h3><blockquote>
<p>合并查询结果 UNION</p>
</blockquote>
<p>在多条查询语句之间，使用<code>UNION</code>关键字会合并所有查询结果。<br>默认会去掉重复行，如果不想去掉重复行，请使用<code>UNION ALL</code><br>需要注意的是，要联合的查询结果必须有相同的列数（列名可以不同）</p>
<blockquote>
<p>去重效率比不去重效率低</p>
</blockquote>
<h2 id="group-by"><a href="#group-by" class="headerlink" title="group by"></a>group by</h2><pre><code class="sql">[GROUP BY {col_name|position} [ASC|DESC],...]
</code></pre>
<pre><code class="sql">select 专业, count(*) 不同专业人数
    from TReader
    group by 专业
</code></pre>
<h3 id="having"><a href="#having" class="headerlink" title="having"></a>having</h3><p>与 GROUP BY 分组联用。只对部分记录做分组操作。有两种用法，比如：</p>
<pre><code class="sql">SELECT sex,age
    FROM users
  GROUP BY sex
  HAVING age &gt; 35;
SELECT sex
    FROM users
  GROUP BY sex
  HAVING count(id) &gt;=2;
</code></pre>
<ul>
<li>第一种，注意后面的 HAVING 的字段必须在前面 SELECT 部分出现才行。</li>
<li>第二种，在 HAVING 后面使用<em>聚合函数</em>，前面无需出现相应字段。</li>
</ul>
<h3 id="asc、desc"><a href="#asc、desc" class="headerlink" title="asc、desc"></a>asc、desc</h3><p>排序升序 asc、降序 desc</p>
<pre><code class="sql">SELECT *
    FROM TReader
    WHERE 专业=&#39;计算机&#39;
    ORDER BY 出生时间 desc
</code></pre>
<p>##</p>
<h2 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h2><p>子查询（Subquery）是指嵌套在查询内部，且必须始终出现在圆括号内。外面的查询并非只是指的查找。可以包含的关键字或条件：</p>
<pre><code>DISTINCT、GROUP BY、ORDER BY、LIMIT、函数等
</code></pre><p>外层的查询可以是：</p>
<pre><code>SELECT、INSERT、UPDATE、SET、DO
</code></pre><h3 id="①-使用比较运算符的子查询"><a href="#①-使用比较运算符的子查询" class="headerlink" title="① 使用比较运算符的子查询"></a>① 使用比较运算符的子查询</h3><ul>
<li>比较运算符<blockquote>
<p>=,&gt;,&lt;,&gt;=,&lt;=,&lt;&gt;,!=,&lt;=&gt;</p>
</blockquote>
</li>
</ul>
<pre><code class="sql">SELECT *
    FROM av
  WHERE 身高&gt;=(
    SELECT AVG(身高)
    FROM av);
</code></pre>
<ul>
<li>修饰比较运算符<blockquote>
<p>使用 ANY、SOME、ALL，ANY 和 SOME 是等价的。</p>
</blockquote>
</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>ANY</th>
<th>ALL</th>
</tr>
</thead>
<tbody>
<tr>
<td>&gt;,&gt;=</td>
<td>最小值</td>
<td>最大值</td>
</tr>
<tr>
<td>&lt;,&lt;=</td>
<td>最大值</td>
<td>最小值</td>
</tr>
<tr>
<td>=,&lt;=&gt;</td>
<td>任意值</td>
<td></td>
</tr>
<tr>
<td>&lt;&gt;,!=</td>
<td></td>
<td>任意值</td>
</tr>
</tbody>
</table>
<pre><code class="sql">select emp.empno,emp.ename,emp.job,emp.sal
    from scott.emp
  where sal &gt;any(
    select sal
    from scott.emp
    where job=&quot;MANAGER&quot;);
</code></pre>
<p>等价于下边两步的执行过程：<br>（1）执行“select sal from scott.emp where job=”MANAGER””<br>（2）查询到 3 个薪水值 2975、2850 和 2450，父查询执行下列语句：<br>select emp.empno,emp.ename,emp.job,emp.sal from scott.emp where<strong> sal &gt;2975 or sal&gt;2850 or sal&gt;2450;</strong></p>
<h3 id="②-使用-not-in-的子查询"><a href="#②-使用-not-in-的子查询" class="headerlink" title="② 使用[not]in 的子查询"></a>② 使用[not]in 的子查询</h3><pre><code>operand comparison_operator [NOT] IN (subquery)
</code></pre><p>=ANY 和 IN 等效<br>!=ALL 和 NOT IN 等效</p>
<h3 id="③-使用-not-exists-的子查询"><a href="#③-使用-not-exists-的子查询" class="headerlink" title="③ 使用[not]exists 的子查询"></a>③ 使用[not]exists 的子查询</h3><p>如果子查询返回任何行，EXISTS 将返回 TRUE，否则返回 FALSE。<br>该类子查询使用较少</p>
]]></content>
      <categories>
        <category>Language</category>
      </categories>
  </entry>
  <entry>
    <title>206.反转链表</title>
    <url>/blog/ipiwza/</url>
    <content><![CDATA[<pre><code class="java">/**
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
</code></pre>
<h2 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206. 反转链表"></a>206. 反转链表</h2><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1603193588776-6539785f-f52d-494b-b7a1-2bc6cebf1e60.png#align=left&amp;display=inline&amp;height=136&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=271&amp;originWidth=725&amp;size=20430&amp;status=done&amp;style=shadow&amp;width=362.5" alt="image.png"></p>
<h3 id="问题思路"><a href="#问题思路" class="headerlink" title="问题思路"></a>问题思路</h3><ol>
<li><strong>利用外部空间：</strong>将所给链表存到 ArryList 里面或者是新的链表里面，然后再反转动态数组就可以了。</li>
<li><strong>快慢指针</strong>：</li>
<li><strong>递归解法</strong>：</li>
</ol>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p><strong>递归实现</strong></p>
<pre><code class="java">// 避免陷入死循环
if (head == null || head.next == null) return head;
ListNode newHead = reverseList(head.next); //此处递归，找到最后一个节点了
head.next.next = head; //重新指定节点指向（有两个next，注意少写）
head.next = null; //将最初的节点指向空
return newHead; //返回新的“倒置”头节点
</code></pre>
<p><strong>快慢指针</strong></p>
<pre><code class="java">class Solution {
    public ListNode reverseList(ListNode head) {
        // 避免陷入死循环
        if (head == null || head.next == null) return head;

        ListNode newHead = null;
        while (head != null){
            ListNode tmp = head.next;
            head.next = newHead;
            newHead = head;
            head = tmp;
        }
        return newHead;

    }
}
</code></pre>
<p>##</p>
]]></content>
      <categories>
        <category>DataStructure</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>GitHub多人协作功能Pull requests</title>
    <url>/blog/iwvugw/</url>
    <content><![CDATA[<h2 id="给出一个初始场景"><a href="#给出一个初始场景" class="headerlink" title="给出一个初始场景"></a>给出一个初始场景</h2><p>小吴和小王同时开发一个项目 project，该项目托管到 GitHub 上，假定该项目托管到小吴的 GitHub 上，小王要想同时开发这个 project，就必须要 fork 小吴的这个 project，最后两个人 GitHub 仓库是这个样子的：</p>
<p>小吴：xiaowu/project<br>小王：xiaowang/project</p>
<p>（需要明确一点，小吴小王各自的 project 仓库现在就相当各做各的事情了）</p>
<h2 id="具体工作场景"><a href="#具体工作场景" class="headerlink" title="具体工作场景"></a>具体工作场景</h2><p>小王的仓库 xiaowang/project 改了代码，想要 push 合并到小吴的仓库 xiaowu/project 中，这里分两种情况。</p>
<h3 id="第一种情况"><a href="#第一种情况" class="headerlink" title="第一种情况"></a>第一种情况</h3><p><strong>小王在从 fork 小吴仓库到现在这段期间，小吴没有对 xiaowu/project 做任何改动</strong></p>
<blockquote>
<p>处理方法：直接 Pull request<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1606915274704-123b219d-d7fe-4816-88c4-91ba11b5c466.png#align=left&amp;display=inline&amp;height=143&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=285&amp;originWidth=1917&amp;size=47997&amp;status=done&amp;style=shadow&amp;width=958.5" alt="image.png"> &gt; <img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1606915405152-c1e60a93-99fb-42d5-a7a5-87c564fe53d4.png#align=left&amp;display=inline&amp;height=270&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=540&amp;originWidth=1920&amp;size=80075&amp;status=done&amp;style=shadow&amp;width=960" alt="image.png"><br>可以看到 1 区域显示 Able to merge，表明这个 Pull request 对于双方是没有矛盾的</p>
</blockquote>
<h3 id="第二种情况"><a href="#第二种情况" class="headerlink" title="第二种情况"></a>第二种情况</h3><p><strong>小王在从 fork 小吴仓库到现在这段期间，小吴又在 xiaowu/project 里面做了改动，就相当于小王 fork 过后，两个人都对各自的仓库更新了，然后小王想将自己的改动推送到小吴那里</strong></p>
<blockquote>
<p><strong><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1606916524143-c5076532-2497-4923-986f-d442122e6de7.png#align=left&amp;display=inline&amp;height=287&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=574&amp;originWidth=1920&amp;size=91126&amp;status=done&amp;style=shadow&amp;width=960" alt="image.png"></strong> &gt; <strong>可以发现 1 处并没有那么顺利，因为产生了冲突，但是 2 处仍然可以新建一个 request 请求，先点击 2</strong> &gt; <strong><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1606916762342-e5215ae5-cf61-43ac-9051-f73c40de1fb1.png#align=left&amp;display=inline&amp;height=307&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=613&amp;originWidth=1191&amp;size=52688&amp;status=done&amp;style=shadow&amp;width=595.5" alt="image.png"></strong> &gt; <strong>点击之后会这样 👇</strong> &gt; <strong><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1606916826669-b406d584-50a7-49d5-9044-166bba4bc75f.png#align=left&amp;display=inline&amp;height=133&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=266&amp;originWidth=1284&amp;size=32978&amp;status=done&amp;style=shadow&amp;width=642" alt="image.png"></strong><br>1 处显示矛盾的文件（就是小吴和小王在各自的仓库都进行了更改）<br>我们点击 2 处<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1606916998671-6b369cf8-f6dc-4ad3-ba0b-d2f7006b7804.png#align=left&amp;display=inline&amp;height=198&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=396&amp;originWidth=1920&amp;size=65448&amp;status=done&amp;style=shadow&amp;width=960" alt="image.png"><br>接下来解决这个问题并且点击 Mark as resolved 按钮就可以了<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1606917076365-e79652f9-3c56-4259-87d4-b6e979af277d.png#align=left&amp;display=inline&amp;height=181&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=361&amp;originWidth=1920&amp;size=44612&amp;status=done&amp;style=shadow&amp;width=960" alt="image.png"> &gt; <img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1606917146702-bc316303-78f2-4746-94fa-72e4cda90dd0.png#align=left&amp;display=inline&amp;height=196&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=391&amp;originWidth=1920&amp;size=87061&amp;status=done&amp;style=shadow&amp;width=960" alt="image.png"><br>最后就会出现下面的图，接下来，小吴在他的 GitHub 上同意接受这个请求就可以了。（或者小王有权限小王自己接受也可以）<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1606917264180-37c25758-4db9-44f8-a3f6-0ca725d6c0fd.png#align=left&amp;display=inline&amp;height=435&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=869&amp;originWidth=1435&amp;size=132722&amp;status=done&amp;style=shadow&amp;width=717.5" alt="image.png"></p>
</blockquote>
]]></content>
      <categories>
        <category>Environment</category>
      </categories>
  </entry>
  <entry>
    <title>0-1背包问题</title>
    <url>/blog/kb5sse/</url>
    <content><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><h3 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h3><p>给定一组已知重量和价值的物品和一个容量已知的背包，求解在不超过背包容量情况下，选用那些物品放入背包，使得所选用的所有物品价值最大化。</p>
<table>
<thead>
<tr>
<th>物品总数 N</th>
<th>4</th>
</tr>
</thead>
<tbody>
<tr>
<td>背包容量 M</td>
<td>8</td>
</tr>
<tr>
<td>每个物品重量 wi</td>
<td>{5, 4, 3, 2}</td>
</tr>
<tr>
<td>每个物品价值 vi</td>
<td>{15, 10, 6, 2}</td>
</tr>
</tbody>
</table>
<h3 id="问题的判定性说法"><a href="#问题的判定性说法" class="headerlink" title="问题的判定性说法"></a>问题的判定性说法</h3><h3 id><a href="#" class="headerlink" title></a><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1600597489691-e0d838af-003e-404e-8a40-5145d2fefbad.png#align=left&amp;display=inline&amp;height=108&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=216&amp;originWidth=969&amp;size=73465&amp;status=done&amp;style=shadow&amp;width=484.5" alt="image.png"></h3><h3 id="问题的形式化定义"><a href="#问题的形式化定义" class="headerlink" title="问题的形式化定义"></a>问题的形式化定义</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1600597354257-45eba2b3-641c-433a-8732-9b6c11a16061.png#align=left&amp;display=inline&amp;height=281&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=561&amp;originWidth=1065&amp;size=184609&amp;status=done&amp;style=shadow&amp;width=532.5" alt="image.png"></p>
<h2 id="问题思路"><a href="#问题思路" class="headerlink" title="问题思路"></a>问题思路</h2><h3 id="动态规划思路"><a href="#动态规划思路" class="headerlink" title="动态规划思路"></a>动态规划思路</h3><p><strong>动态规划</strong>解决该问题，类似于<strong>莱文斯坦距离</strong>的解法类似。利用 CAAIS 数据来说明这个问题的解决思想。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1603943092299-49a0bc97-f2cf-4258-8dde-022b4aae06d1.png#align=left&amp;display=inline&amp;height=154&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=307&amp;originWidth=842&amp;size=44700&amp;status=done&amp;style=shadow&amp;width=421" alt="image.png"><br><strong>动态规划 DP 方程构造</strong><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1603943375703-889cea96-f3a0-41df-b806-386dca8bcc82.png#align=left&amp;display=inline&amp;height=112&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=223&amp;originWidth=1020&amp;size=23862&amp;status=done&amp;style=shadow&amp;width=510" alt="image.png"><br><strong>PS：V[i,j]表示在前 i 件物品中选择若干件放在承重为 j 的背包中，可以取得的最大价值</strong></p>
<p>（整张表格是从上往下，从左往右地填）<br>举例说明表格中的数值填法，<strong>倒数第二行倒数第四列的 16 4</strong>的填法：</p>
<ul>
<li>首先不满足 DP 方程的第一种和第二种情况</li>
<li>所以代入取最大值 max 函数<ul>
<li>V（i-1，j）：不选本物品（3，6），还是用之前的值，继承上面的第一个物品和第二个物品，DP 值为 15 U</li>
<li>V（i-1，j）+vi：用该容量（7）-所选物品的重量为 4，然后再查容量为 4 的时候 DP 值为 10，然后求出该情况 DP 是，10 加上该物品的价值，所以该情况下的 DP 值为 16，右上标为 4（CAAIS），值来源于前面容量为 4 的情况。</li>
</ul>
</li>
</ul>
<hr>
<p><strong>格子如上方式填就好了！</strong></p>
<h3 id="递归思路"><a href="#递归思路" class="headerlink" title="递归思路"></a>递归思路</h3><p>第二节课将递归的时候，也讲了这个问题的递归思路。不过复杂度记得是指数级的，暂时不写了~~</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="动态规划-Code"><a href="#动态规划-Code" class="headerlink" title="动态规划 Code"></a>动态规划 Code</h3><pre><code class="cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
using namespace std;
namespace NS_DP0_1Knapsack {
int DP0_1Knapsack(int n, int W, int *w, int *v);
void Output(int n, int W, int *w, int *v, int OptV);
static vector&lt;vector&lt;int&gt;&gt; V;
static vector&lt;int&gt; x;
void DP0_1KnapsackCaller(int n, int W, int *w, int *v)
{
    V.clear();
    V.resize(n + 1, vector&lt;int&gt;(W + 1, 0));
    x.resize(n + 1);
    int OptV = DP0_1Knapsack(n, W, w, v);
    Output(n, W, w, v, OptV);
}
int DP0_1Knapsack(int n, int W, int *w, int *v)
{
    for (int i = 1; i &lt;= n; i++)
        for (int j = 1; j &lt;= W; j++)
            if (j &lt; w[i - 1])
                V[i][j] = V[i - 1][j];
            else if (V[i - 1][j] &gt;=
                V[i - 1][j - w[i - 1]] + v[i - 1])
                V[i][j] = V[i - 1][j];
            else
                V[i][j] = V[i - 1][j - w[i - 1]] + v[i - 1];
    int j = W;
    for (int i = n; i &gt; 0; i--)
        if (V[i][j] == V[i - 1][j])
            x[i] = 0;
        else
        {   x[i] = 1; j -= w[i - 1];  }
    return V[n][W];
}
void Output(int n, int W, int *w, int *v, int OptV)
{
    //inputs
    printf(&quot;DP to solve 0-1 knapsack:\n&quot;);
    printf(&quot;%d items with knapsack capacity %d.\n&quot;, n , W);
    printf(&quot;%-6s: &quot;, &quot;Weight&quot;);
    for (int i = 0; i &lt; n; i++)
        printf(&quot;%3d&quot;, w[i]);
    printf(&quot;\n&quot;);
    printf(&quot;%-6s: &quot;, &quot;Value&quot;);
    for (int i = 0; i &lt; n; i++)
        printf(&quot;%3d&quot;, v[i]);
    printf(&quot;\n&quot;);
    //the value matrix
    printf(&quot;\nThe value matrix:\n&quot;);
    printf(&quot;  &quot;);
    for (int j = 0; j &lt;= W; j++)
        printf(&quot;%3d&quot;, j);
    printf(&quot;\n&quot;);
    for (int i = 0; i &lt;= n; i++)
    {
        printf(&quot;%2d&quot;, i);
        for (int j = 0; j &lt;= W; j++)
            printf(&quot;%3d&quot;, V[i][j]);
        printf(&quot;\n&quot;);
    }
    //solution
    printf(&quot;\nThe optimal value: %d\n&quot;, OptV);
    printf(&quot;The optimal solution:\n&quot;);
    for (int i = 1; i &lt;= n; i++)
        printf(&quot;%2d&quot;, x[i]);
    printf(&quot;\n\n&quot;);
}
} //namespace NS_DP0_1Knapsack
using namespace NS_DP0_1Knapsack;
int main()
{
    // 物品个数
    vector&lt;int&gt; N = { 4,  10};
    // 背包容量
    vector&lt;int&gt; W = { 8,  100};
    // 各物品重量
    vector&lt;vector&lt;int&gt;&gt; w = {
        { 5, 4, 3, 2 },
        { 4, 3, 7, 2, 9, 3, 1, 7, 2, 5 }
    };
    // 各物品价值
    vector&lt;vector&lt;int&gt;&gt; v = {
        { 15, 10, 6, 2 },
        { 15, 10, 6, 2, 23, 12, 33, 7, 22, 10 }
    };

    int m = N.size();
    for (int i = 0; i &lt; m; i++)
    {
        DP0_1KnapsackCaller(N[i], W[i], &amp;w[i][0], &amp;v[i][0]);
    }

    return 0;
}
</code></pre>
<h3 id="动态规划-Result"><a href="#动态规划-Result" class="headerlink" title="动态规划 Result"></a>动态规划 Result</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1603943258085-fac4811f-87e7-4eef-8194-ee47d88063a6.png#align=left&amp;display=inline&amp;height=379&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=757&amp;originWidth=1920&amp;size=74181&amp;status=done&amp;style=shadow&amp;width=960" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1603943276039-f6f74edf-4871-426d-8af8-e1a62edaf071.png#align=left&amp;display=inline&amp;height=276&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=552&amp;originWidth=1920&amp;size=66929&amp;status=done&amp;style=shadow&amp;width=960" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1603943291836-84a15101-d6e7-4c9f-91b5-1122afd7ac5c.png#align=left&amp;display=inline&amp;height=177&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=353&amp;originWidth=1920&amp;size=29292&amp;status=done&amp;style=shadow&amp;width=960" alt="image.png"></p>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>全排列问题</title>
    <url>/blog/kgaymi/</url>
    <content><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>给定 n 个有序元素的集合，列出其可能出现的排列。</p>
<h2 id="问题思路"><a href="#问题思路" class="headerlink" title="问题思路"></a>问题思路</h2><h2 id="代码思路"><a href="#代码思路" class="headerlink" title="代码思路"></a>代码思路</h2><ul>
<li>利用动态数组数据结构</li>
</ul>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><pre><code class="java">package com.wztlink1013.al._递归法_;
import java.util.ArrayList;

/**
 * 全排列问题
 * */

public class Permuting {
    static ArrayList&lt;Integer&gt; x  = new ArrayList&lt;Integer&gt;();
    static int N;
    static int cnt = 0;
    static int t;

    public static void main(String args[]) {
        int n = 10;
        Times.test(&quot;当n = &quot; + n + &quot;时候的耗费时间&quot;, new Times.Task() {
            public void execute() {
                PermutingCaller(n);
            }
        });
    }
    private static void PermutingCaller(int n) {
        N = n;
        for (int i = 0; i &lt; n; ++i)
            x.add(i + 1);
        Permuting(0);
    }
    private static void Permuting(int i) {
        if (i &lt; N - 1) {
            for (int j = i; j &lt; N; j++) {
                t = x.get(i);
                x.set(i, x.get(j));
                x.set(j, t);
                Permuting(i + 1);
                t = x.get(i);
                x.set(i, x.get(j));
                x.set(j, t);
            }
        }
        else
            OutputOnePermutation();
    }
    private static void OutputOnePermutation()
    {
        System.out.print(++cnt + &quot; : &quot;);
        for (int x : x)
            System.out.print(x + &quot; &quot;);
        System.out.println();
    }
}
</code></pre>
<blockquote>
<p>n:10</p>
</blockquote>
<blockquote>
<p>n</p>
</blockquote>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>P203. 移除链表元素</title>
    <url>/blog/kgpm3x/</url>
    <content><![CDATA[<pre><code class="java">/**
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
</code></pre>
<h2 id="203-移除链表元素"><a href="#203-移除链表元素" class="headerlink" title="203. 移除链表元素"></a>203. 移除链表元素</h2><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1603195857807-2e8c8296-2d79-4e36-b304-f02c4dee52b3.png#align=left&amp;display=inline&amp;height=100&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=200&amp;originWidth=729&amp;size=15034&amp;status=done&amp;style=shadow&amp;width=364.5" alt="image.png"></p>
<h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h3><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><pre><code class="java">class Solution {
    public ListNode removeElements(ListNode head, int val) {
        // 将整个链表想象成head+子链表
        if (head == null)
            return null;
        // 先处理子链表
        head.next = removeElements(head.next, val);
        // 再处理头结点
        return head.val == val ? head.next : head;
    }
}
</code></pre>
]]></content>
      <categories>
        <category>DataStructure</category>
      </categories>
  </entry>
  <entry>
    <title>数据可视化</title>
    <url>/blog/kt0kvc/</url>
    <content><![CDATA[<h2 id="一、GitHub-Juper-NoteBook-笔记"><a href="#一、GitHub-Juper-NoteBook-笔记" class="headerlink" title="一、GitHub Juper NoteBook 笔记"></a>一、GitHub Juper NoteBook 笔记</h2><ul>
<li><a href="https://github.com/wztlink1013/data-analysis-mining" target="_blank" rel="noopener">https://github.com/wztlink1013/data-analysis-mining</a></li>
</ul>
<h2 id="二、零碎总结"><a href="#二、零碎总结" class="headerlink" title="二、零碎总结"></a>二、零碎总结</h2><h3 id="matplotlib-调整子图间距，调整整体空白"><a href="#matplotlib-调整子图间距，调整整体空白" class="headerlink" title="matplotlib 调整子图间距，调整整体空白"></a>matplotlib 调整子图间距，调整整体空白</h3><pre><code class="python">fig.tight_layout() #调整整体空白
plt.subplots_adjust(wspace =0, hspace =0) #调整子图间距
</code></pre>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://mp.weixin.qq.com/s/DaQL6bqr0wu5iYt-cVkz6g" target="_blank" rel="noopener">Matplotlib 可视化最有价值的 50 个图表</a></li>
</ul>
]]></content>
      <categories>
        <category>DataAnalysis</category>
      </categories>
  </entry>
  <entry>
    <title>P83. 删除排序链表中的重复元素</title>
    <url>/blog/lg67md/</url>
    <content><![CDATA[<pre><code class="java">/**
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
</code></pre>
<h2 id="83-删除排序链表中的重复元素"><a href="#83-删除排序链表中的重复元素" class="headerlink" title="83. 删除排序链表中的重复元素"></a>83. 删除排序链表中的重复元素</h2><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1603195897467-fdb33dfe-a1c0-4963-b76a-2c978f565801.png#align=left&amp;display=inline&amp;height=177&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=354&amp;originWidth=727&amp;size=22776&amp;status=done&amp;style=shadow&amp;width=363.5" alt="image.png"></p>
<h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h3><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><pre><code class="java">class Solution {
    public ListNode deleteDuplicates(ListNode head) {
        // TODO: 快慢指针
        if (head == null) return head;
        ListNode slow = head;
        ListNode fast = head.next;
        while (fast != null){
            if (slow.val != fast.val) {
                slow.next = fast;
                slow = fast;
            }
            fast = fast.next;
        }
        slow.next = null;
        return head;
    }
}
// TODO: 单指针下一步
//class Solution {
//    public ListNode deleteDuplicates(ListNode head) {
//        ListNode cur = head;
//        while(cur != null &amp;&amp; cur.next != null) {
//            if(cur.val == cur.next.val) {
//                cur.next = cur.next.next;
//            } else {
//                cur = cur.next;
//            }
//        }
//        return head;
//    }
//}
</code></pre>
]]></content>
      <categories>
        <category>DataStructure</category>
      </categories>
  </entry>
  <entry>
    <title>git使用Token连接</title>
    <url>/blog/lg6q7n/</url>
    <content><![CDATA[<h2 id="一、应用"><a href="#一、应用" class="headerlink" title="一、应用"></a>一、应用</h2><p>多个终端使用，而且没必要配置 SSH 连接的情况，可以使用 GitHub Token 来连接使用。还有就是使用 GitHub Actions 时候用 Token 情况较 SSH 方便。</p>
<p>不同的托管平台使用语法会有差异，在此记录下 GitHub、Coding、Gitee 的使用</p>
<h2 id="二、GitHub"><a href="#二、GitHub" class="headerlink" title="二、GitHub"></a>二、GitHub</h2><p>GitHub 生成一个 Token：***</p>
<p>使用 SSH 情况：<code>git clone [https://github.com/wztlink1013/blog3.0.git](https://github.com/wztlink1013/blog3.0.git)</code></p>
<p>使用 Token 情况：<code>[https://x-access-token:**************@github.com/wztlink1013/blog3.0.git](https://x-access-token:**************@github.com/wztlink1013/blog3.0.git)</code></p>
<h2 id="三、Coding"><a href="#三、Coding" class="headerlink" title="三、Coding"></a>三、Coding</h2><p>在个人设置中设置一个访问令牌</p>
<ul>
<li>令牌用户名：####</li>
<li>令牌 Token：*</li>
</ul>
<p>使用 SSH 情况：<code>[https://e.coding.net/wztlink1013/project/repo.git](https://e.coding.net/wztlink1013/project/repo.git)</code><br>使用令牌情况：<code>[https://####:***********@e.coding.net/wztlink1013/project/repo.git](https://####:***********@e.coding.net/wztlink1013/project/repo.git)</code></p>
<h2 id="四、Gitee"><a href="#四、Gitee" class="headerlink" title="四、Gitee"></a>四、Gitee</h2><p>头像设置中申请私人令牌：**</p>
<p>使用 SSH 情况：<code>[https://gitee.com/user/repo.git](https://gitee.com/user/repo.git)</code></p>
<p>使用 Token 情况：<code>[https://oauth2:**********@gitee.com/user/repo.git](https://oauth2:**********@gitee.com/user/repo.git)</code></p>
<h2 id="五、GitHub-Actions-中的使用"><a href="#五、GitHub-Actions-中的使用" class="headerlink" title="五、GitHub Actions 中的使用"></a>五、GitHub Actions 中的使用</h2><pre><code class="bash">Github_Pages:  github.com/wztlink1013/wztlink1013.github.io
Github_Token:  ${{  secrets.token_GithubAPI  }}

git  push  --force  --quiet  &quot;https://${Github_Token}@${Github_Pages}&quot;
</code></pre>
<pre><code class="bash">Coding_Pages:  e.coding.net/wztlink1013/wztlink1013.git
Coding_Token:  ${{  secrets.token_CodingAPI  }}
Coding_Username:  ${{  secrets.Username_Coding  }}

git  push  --force  --quiet  &quot;https://${Coding_Username}:${Coding_Token}@${Coding_Pages}&quot;
</code></pre>
]]></content>
      <categories>
        <category>Environment</category>
      </categories>
  </entry>
  <entry>
    <title>IDEA-控制台输出中文乱码问题</title>
    <url>/blog/lkgrkx/</url>
    <content><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>在 java 实现 ping/tracert 两个命令时候，输出到控制台里面中文乱码。</p>
<h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>应该是调用了终端，而 windows 的终端默认是 GBK 的编码，所以要对其更改管用的 utf-8 编码，改为 GBK 编码。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1603613519544-dc851d0f-e0c0-4a0a-9a2d-0043285b3db0.png#align=left&amp;display=inline&amp;height=441&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=881&amp;originWidth=706&amp;size=74813&amp;status=done&amp;style=shadow&amp;width=353" alt="image.png"></p>
<h2 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h2><h3 id="编码更改"><a href="#编码更改" class="headerlink" title="编码更改"></a>编码更改</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1603613302488-7bd6d045-81c3-470c-a57c-05a020588fcd.png#align=left&amp;display=inline&amp;height=511&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=1022&amp;originWidth=1449&amp;size=141645&amp;status=done&amp;style=shadow&amp;width=724.5" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1603613687953-21f1bbc9-b0bc-4db4-a935-3fcf6275909f.png#align=left&amp;display=inline&amp;height=185&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=369&amp;originWidth=1920&amp;size=135691&amp;status=done&amp;style=shadow&amp;width=960" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1603613719305-ac9dc39b-2c6a-4350-9f31-49d48dbedfe5.png#align=left&amp;display=inline&amp;height=110&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=220&amp;originWidth=764&amp;size=24151&amp;status=done&amp;style=none&amp;width=382" alt="image.png"></p>
<ul>
<li><code>Reload</code> 表示使用新编码重新加载，新编码不会保存到文件中</li>
<li><code>Convert</code> 表示使用新编码进行转换，新编码会保存到文件中</li>
<li>含有中文的代码文件，<code>Convert</code> 之后可能会使中文变成乱码，所以在转换成请做好备份，不然可能出现转换过程变成乱码，无法还原</li>
</ul>
<h3 id="BOM-问题"><a href="#BOM-问题" class="headerlink" title="BOM 问题"></a>BOM 问题</h3><blockquote>
<p>BOM：byte-order mark 字节顺序标记<br><a href="https://zh.wikipedia.org/wiki/%E4%BD%8D%E5%85%83%E7%B5%84%E9%A0%86%E5%BA%8F%E8%A8%98%E8%99%9F" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E4%BD%8D%E5%85%83%E7%B5%84%E9%A0%86%E5%BA%8F%E8%A8%98%E8%99%9F</a></p>
</blockquote>
<p>可能会出现的问题有：</p>
<blockquote>
<p>编译报错：<code>找不到符号</code>、<code>未结束的字符串文字</code> 或者是 提示 <code>非法字符</code></p>
</blockquote>
<p>解决办法：有上述百科可知，UTF-8 编码分有 BOM 和无 BOM 两种分类。IDEA 打开 Eclipse 项目，会提示出现上述编译问题，因为<strong>Eclipse 默认是有 BOM 的文件编译</strong>，而<strong>IDEA 只能编译无 BOM 的文件编译</strong>，所以解决办法就是对项目进行<strong>BOM 去除</strong>操作。</p>
]]></content>
      <categories>
        <category>Bug</category>
      </categories>
  </entry>
  <entry>
    <title>👨‍💻编程习惯</title>
    <url>/blog/ml46ei/</url>
    <content><![CDATA[<h2 id="一、代码"><a href="#一、代码" class="headerlink" title="一、代码"></a>一、代码</h2><h3 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h3><ul>
<li>项目：小写字母 <code>datastructure</code></li>
<li>包：<code>com.公司名.项目名.模块名....</code>（其中模块名可以按照功能/逻辑来分）</li>
<li>类：全部首字母大写，一般驼峰式命名 <code>public class TestBan{}</code></li>
<li>常量：全部大写字母 <code>String RE_PRI = ‘wztlink’</code></li>
<li>变量：下划线方式  <code>int pri_const</code></li>
<li>方法：首字母小写，如果有多个单词，单词首字母大写 <code>public void toString(){}</code></li>
</ul>
<blockquote>
<ul>
<li>好的命名以及编程习惯：① 小/大驼峰命名 ② 匈牙利命名 ③ 下划线命名</li>
<li><a href="https://blog.csdn.net/ZCF1002797280/article/details/51495229" target="_blank" rel="noopener">https://blog.csdn.net/ZCF1002797280/article/details/51495229</a></li>
<li><a href="https://blog.csdn.net/z_h_s/article/details/24007249" target="_blank" rel="noopener">https://blog.csdn.net/z_h_s/article/details/24007249</a></li>
</ul>
</blockquote>
<h3 id="注释规范"><a href="#注释规范" class="headerlink" title="注释规范"></a>注释规范</h3><blockquote>
<p>文件注释</p>
</blockquote>
<pre><code class="java">  / *
    * 文件名：[文件名]
    * 作者：〈版权〉
    * 描述：〈描述〉
    * 修改人：Wu ZuTao
    * 修改时间：2020-06-06
    * 修改内容：新增X方法
    * 修改人：Wu ZuTao
    * 修改时间：2020-07-01
    * 修改内容：修改B模块
    * /
</code></pre>
<blockquote>
<p>类和接口注释</p>
</blockquote>
<p>类和接口的注释：该注释放在 class 定义之前，using 或 package 关键字之后。</p>
<pre><code class="java">package com.wztlink.xxx;
/**
  * 注释内容
  */
public class XxxManager
</code></pre>
<pre><code class="java">/ *
  * 〈一句话功能简述〉
  * 〈功能详细描述〉
  * @author [作者]
  * @version [版本号, YYYY-MM-DD]
  * @see [相关类/方法]
  * @since [产品/模块版本]
  * @deprecated
  */
</code></pre>
<blockquote>
<p>方法</p>
</blockquote>
<pre><code class="java"> /**
    * 类方法的详细使用说明
    *
    * @param 参数1 参数1的使用说明
    * @return 返回结果的说明
    * @throws 异常类型.错误代码 注明从此类方法中抛出异常的说明
    */
</code></pre>
<blockquote>
<p>方法内部、属性、必要语句</p>
</blockquote>
<pre><code class="java">// 注释内容
private String logType
</code></pre>
<blockquote>
<p>注意事项</p>
</blockquote>
<ul>
<li>边写代码边注释，修改代码同时修改相应的注释，以保证注释与代码的一致性。不再有用的注释要删除。</li>
<li>避免在注释中使用缩写，特别是不常用缩写。说明：在使用缩写时或之前，应对缩写进行必要的说明。 注释应该放在被注释的代码前面，分行展示，但中间不留空行。</li>
<li><a href="https://blog.csdn.net/vbirdbest/article/details/80296136" target="_blank" rel="noopener">javadoc 使用规范</a></li>
</ul>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>主入口函数和其他功能函数分开，如果是功能性函数，全部放到一个 <code>Tools</code>  函数里面</p>
<h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><p>不要在自己类下定义自己的对象</p>
<h2 id="二、项目"><a href="#二、项目" class="headerlink" title="二、项目"></a>二、项目</h2><h3 id="解决写不出代码的方法"><a href="#解决写不出代码的方法" class="headerlink" title="解决写不出代码的方法"></a>解决写不出代码的方法</h3><blockquote>
<p>1、先分析实现的思路</p>
</blockquote>
<p>拿到作业，按照要实现的功能，先分析去实现的思路。<br>如果完全不知道该怎么去实现，一头雾水，最好先看看其他人事如何实现的，或者与老师或同学讨论。<br>重点是要找到解决问题的办法，理清实现的思路。<br>如果自己能想出几步来，那就先把这几步记录下来，然后重复上面的步骤。</p>
<blockquote>
<p>2、把实现的思路边分析边记录下来。</p>
</blockquote>
<p>在分析实现思路的时候，边分析，边写出来，使用中文写，写得详细点。<br>如果在编程工具里面写的话，直接写成注释，比如：<br>第一步是要干上面<br>第 1.1 要做什么<br>第 1.2 要做什么<br>第二步是要干上面<br>第 2.1 要做什么<br>第 2.2 要做什么<br>…以此类推<br>遇到写不下去的地方，先看看是没有思路还是前面的思路没有想清楚<br>如果是没有思路了，参见第一条处理。<br>如果是前面的思路没有想清楚，那就返回来重新思考，一定要考虑明白。<br>这其实也是这个方法一个额外的好处，那就是能强迫你思考，并进行细致考虑。</p>
<blockquote>
<p>3、写实现代码</p>
</blockquote>
<p>如果思路整理清楚了，实现思路的步骤也整理好了，这个时候再写代码，<br>几乎就是个翻译的过程，很容易实现。<br>如果只是几步思路清楚了，也没有关系，想清楚多少，就写多少代码，慢慢来。</p>
<blockquote>
<p>4、有思路但是写不出代码的解决方法</p>
</blockquote>
<p>这种情况常出现在初学者身上，主要是代码写少了。（这种情况需每日练习两百到三百行代码）<br>建议多看看别人怎么写的，积累代码的写法，这一次不会写不要紧。<br>见过一回，下次会写九可以了，积少成多，写得多了，自己能实现的也就多了。</p>
<blockquote>
<p>5、方法不一定照搬，可以变通使用</p>
</blockquote>
<p>比如边分析、边写思路然后就编写代码也是可以的，只要能有助你思考，都可以。</p>
<blockquote>
<p>6、写不出代码</p>
</blockquote>
<p>大多数人在写不出代码的时候，都不是完全写不出来，也不是一点都写不出来，请尽量把会的、能写出来的先写出来，多按照本文介绍的方法去练习，量变到质变，很快就能自己写出实现代码来。</p>
<blockquote>
<p>参考：<a href="https://www.cnblogs.com/luchuangao/p/6821210.html" target="_blank" rel="noopener">https://www.cnblogs.com/luchuangao/p/6821210.html</a></p>
</blockquote>
<h3 id="提高代码阅读能力"><a href="#提高代码阅读能力" class="headerlink" title="提高代码阅读能力"></a>提高代码阅读能力</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1602593438617-6e64c23d-0230-4104-b1b5-6ccd512ad999.png#align=left&amp;display=inline&amp;height=100&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=199&amp;originWidth=1017&amp;size=53543&amp;status=done&amp;style=shadow&amp;width=508.5" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1602593456351-275ca8e5-583b-499b-aca4-e4295b312c55.png#align=left&amp;display=inline&amp;height=157&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=313&amp;originWidth=1008&amp;size=102518&amp;status=done&amp;style=shadow&amp;width=504" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1602593476552-c6a6f01f-1d45-40e7-93b5-be56bc08e0c7.png#align=left&amp;display=inline&amp;height=170&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=339&amp;originWidth=1010&amp;size=98037&amp;status=done&amp;style=shadow&amp;width=505" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1602593492992-c4a224fc-10e7-478e-9424-c90da2b4805a.png#align=left&amp;display=inline&amp;height=88&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=176&amp;originWidth=996&amp;size=51461&amp;status=done&amp;style=shadow&amp;width=498" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1602593510079-399972ba-bee4-4dbc-81c9-ae619486f7da.png#align=left&amp;display=inline&amp;height=202&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=403&amp;originWidth=996&amp;size=126977&amp;status=done&amp;style=shadow&amp;width=498" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1602593528314-e583f78d-6f87-46d1-826d-841629871530.png#align=left&amp;display=inline&amp;height=163&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=325&amp;originWidth=1013&amp;size=96139&amp;status=done&amp;style=shadow&amp;width=506.5" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1602593547023-cbcc3eac-6350-4b92-856d-0cfd2a1ccf75.png#align=left&amp;display=inline&amp;height=98&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=196&amp;originWidth=1011&amp;size=52272&amp;status=done&amp;style=shadow&amp;width=505.5" alt="image.png"></p>
]]></content>
      <categories>
        <category>软件工程</category>
      </categories>
  </entry>
  <entry>
    <title>对谷歌BERT模型的思考</title>
    <url>/blog/mssoff/</url>
    <content><![CDATA[<h2 id="why？"><a href="#why？" class="headerlink" title="why？"></a>why？</h2><blockquote>
<p>BERT 可以用来干什么？</p>
</blockquote>
<p>处理这种非结构化的数据以及之前学习到的情感分析</p>
<p>BERT 可以用于问答系统，情感分析，垃圾邮件过滤，命名实体识别，文档聚类等任务中，作为这些任务的基础设施即语言模型，</p>
<h2 id="what？"><a href="#what？" class="headerlink" title="what？"></a>what？</h2><p>是一个自然语言处理模型<br>提出了“训练词向量”概念，这是独特之处</p>
<p><strong>BERT 利用了 Transformer 的 encoder 部分。</strong><br><strong>BERT 的创新点在于它将双向 Transformer 用于语言模型，</strong><br>之前的模型是从左向右输入一个文本序列，或者将 left-to-right 和 right-to-left 的训练结合起来。实验的结果表明，双向训练的语言模型对语境的理解会比单向的语言模型更深刻，Transformer 是一种注意力机制，可以学习文本中单词之间的上下文关系的。Transformer 的原型包括两个独立的机制，一个 encoder 负责接收文本作为输入，一个 decoder 负责预测任务的结果。BERT 的目标是生成语言模型，所以只需要 encoder 机制。Transformer 的 encoder 是一次性读取整个文本序列，而不是从左到右或从右到左地按顺序读取，这个特征使得模型能够基于单词的两侧学习，相当于是一个双向的功能。 Transformer 的 encoder 部分，输入是一个 token 序列，先对其进行 embedding 称为向量，然后输入给神经网络，输出是大小为 H 的向量序列，每个向量对应着具有相同索引的 token。当我们在训练语言模型时，有一个挑战就是要定义一个预测目标，很多模型在一个序列中预测下一个单词，“The child came home from ___”双向的方法在这样的任务中是有限制的，为了克服这个问题，BERT 使用两个策略:</p>
<h3 id="Masked-LM-MLM"><a href="#Masked-LM-MLM" class="headerlink" title="Masked LM (MLM)"></a>Masked LM (MLM)</h3><p>论文中介绍了一种新技术叫做 Masked LM（MLM），在这个技术出现之前是无法进行双向语言模型训练的。在将单词序列输入给 BERT 之前，每个序列中有 15％ 的单词被 [MASK] token 替换。 然后模型尝试基于序列中其他未被 mask 的单词的上下文来预测被掩盖的原单词。</p>
<p>这样就需要：</p>
<ul>
<li>[x] 在 encoder 的输出上添加一个分类层</li>
<li>[x] 用嵌入矩阵乘以输出向量，将其转换为词汇的维度</li>
<li>[x] 用 softmax 计算词汇表中每个单词的概率</li>
</ul>
<p>BERT 的损失函数只考虑了 mask 的预测值，忽略了没有掩蔽的字的预测。这样的话，模型要比单向模型收敛得慢，不过结果的情境意识增加了。</p>
<p><strong>eg：my dog is hairy</strong></p>
<ul>
<li>有 80%的概率用“[mask]”标记来替换——my dog is [MASK]</li>
<li>有 10%的概率用随机采样的一个单词来替换——my dog is apple</li>
<li>有 10%的概率不做替换——my dog is hairy</li>
</ul>
<h3 id="Next-Sentence-Prediction-NSP"><a href="#Next-Sentence-Prediction-NSP" class="headerlink" title="Next Sentence Prediction (NSP)"></a>Next Sentence Prediction (NSP)</h3><p>在 BERT 的训练过程中，模型接收成对的句子作为输入，并且预测其中第二个句子是否在原始文档中也是后续句子。在训练期间，50％ 的输入对在原始文档中是前后关系，另外 50％ 中是从语料库中随机组成的，并且是与第一句断开的。为了帮助模型区分开训练中的两个句子，输入在进入模型之前要按以下方式进行处理：</p>
<ul>
<li>[x] 在第一个句子的开头插入 [CLS] 标记，在每个句子的末尾插入 [SEP] 标记。</li>
<li>[x] 将表示句子 A 或句子 B 的一个句子 embedding 添加到每个 token 上。</li>
<li>[x] 给每个 token 添加一个位置 embedding，来表示它在序列中的位置。</li>
<li>[x] 为了预测第二个句子是否是第一个句子的后续句子，用下面几个步骤来预测：</li>
<li>[x] 整个输入序列输入给 Transformer 模型</li>
<li>[x] 用一个简单的分类层将 [CLS] 标记的输出变换为 2×1 形状的向量</li>
<li>[x] 用 softmax 计算 IsNextSequence 的概率</li>
</ul>
<p>在训练 BERT 模型时，Masked LM 和 Next Sentence Prediction 是一起训练的，目标就是要最小化两种策略的组合损失函数。</p>
<h2 id="how？"><a href="#how？" class="headerlink" title="how？"></a>how？</h2><p>BERT 可以用于各种 NLP 任务，只需在核心模型中添加一个层.<br>例如：</p>
<ul>
<li>[x] 在分类任务中，例如情感分析等，只需要在 Transformer 的输出之上加一个分类层</li>
<li>[x] 在问答任务（例如 SQUAD v1.1）中，问答系统需要接收有关文本序列的 question，并且需要在序列中标记 answer。 可以使用 BERT 学习两个标记 answer 开始和结尾的向量来训练 Q＆A 模型。</li>
<li>[x] 在命名实体识别（NER）中，系统需要接收文本序列，标记文本中的各种类型的实体（人员，组织，日期等）。 可以用 BERT 将每个 token 的输出向量送到预测 NER 标签的分类层。</li>
</ul>
]]></content>
      <categories>
        <category>MachingLearning</category>
      </categories>
      <tags>
        <tag>bert</tag>
      </tags>
  </entry>
  <entry>
    <title>🐞[bug]解决总结</title>
    <url>/blog/mtigbx/</url>
    <content><![CDATA[<blockquote>
<p>好吧，学完软工之后，得用一个比较正式的词来描述——调试</p>
</blockquote>
<h2 id="一、关于-bug"><a href="#一、关于-bug" class="headerlink" title="一、关于 bug"></a>一、关于 bug</h2><p>在编写程序过程中，总会出现各种各样的 bug，按 bug 得类型来分的话</p>
<ul>
<li>程序的逻辑出错</li>
<li>程序语法出错编译器不能通过</li>
</ul>
<p>对待 bug，心态端正，不抵触不畏惧不怕麻烦，要想着解 bug 就是这个职业的要务之一，有耐心，积极主动的去解决问题。一步一步的解决问题，所有的技术都是熟能生巧、</p>
<h2 id="二、解决-bug-的一些方法"><a href="#二、解决-bug-的一些方法" class="headerlink" title="二、解决 bug 的一些方法"></a>二、解决 bug 的一些方法</h2><h3 id="报错信息-理论知识"><a href="#报错信息-理论知识" class="headerlink" title="报错信息+理论知识"></a>报错信息+理论知识</h3><p>当一个 bug 摆在面前，首先要做的就是要认真阅读展现出来的出错信息，这里面有几点需要注意</p>
<blockquote>
<p><strong>提高英语</strong></p>
</blockquote>
<p>专业词汇的积累、阅读能力等</p>
<blockquote>
<p><strong>运用底层知识</strong></p>
</blockquote>
<p>学会运行所学过的理论知识，比如在编程过程中，出现路径相关的错误，首先是根据报错可以直接在代码里面更改为正确可运行代码，然后可以利用所学过的操作系统相关文件管理知识等来进一步底层分析之，最后可以旁通自己之前搭建环境过程种总是要配的环境变量，一起思考一起分析，发散性思考，触类旁通所学知识，运用之</p>
<blockquote>
<p><strong>IDE 的 Debug 或 print 通法</strong></p>
</blockquote>
<p>熟悉各种开发环境的 debug</p>
<h3 id="搜索引擎"><a href="#搜索引擎" class="headerlink" title="搜索引擎"></a>搜索引擎</h3><blockquote>
<p><strong>一个原则</strong>：“遇事不决，大事谷歌，小事百度”</p>
</blockquote>
<ul>
<li>谷歌需要一些手段才能进行，总结下来就是<strong>搭建一个机场</strong>，方便，安全</li>
<li>百度解决一些小问题，抑或是 <strong>“烂大街的易错知识”</strong></li>
<li>相关编程论坛，比如 Stack Overflow、CSDN、博客园等（还是要用谷歌）</li>
</ul>
<blockquote>
<p><strong>结果择优原则</strong></p>
</blockquote>
<ul>
<li>环境统一：解决办法的环境需要和自己的 bug 的环境需要一致</li>
<li>非毁灭性原则：尽量不要做全局性的修改，比如用命令删除 git 的两个文件来改一个小 bug，属实挖坑</li>
</ul>
<blockquote>
<p><strong>擅用官方文档</strong></p>
</blockquote>
<p>如果说出现的 bug 抑或是，使用某个知识出错，是在官方文档中能查到的，优先选择官方文档</p>
<p>就比如在使用 python 数据分析的时候，许多时候，很多包（pandas、numpy、matplotlib 等）更新比较快，而网上找的一般都是旧版本的指导。同时<br>官方文档讲解更加全面，不过这过程中，要注意提高自身英语水平！</p>
<h3 id="“思维冥想体”"><a href="#“思维冥想体”" class="headerlink" title="“思维冥想体”"></a>“思维冥想体”</h3><blockquote>
<p><strong>地阶</strong></p>
</blockquote>
<p>运用万能学习方法，去复现一个学习（复现代码）过程，<strong>复盘</strong>bug 之前的工作，来从中找出可能有哪些细节会导致出现该 bug。</p>
<blockquote>
<p><strong>天阶</strong></p>
</blockquote>
<p>按照思路重写代码！再不行重装系统！</p>
<p>重构，让你的代码更优美和简洁~</p>
<p>重装，让你的世界焕然一新~</p>
<h2 id="三、多记录多总结多仔细"><a href="#三、多记录多总结多仔细" class="headerlink" title="三、多记录多总结多仔细"></a>三、多记录多总结多仔细</h2><blockquote>
<p>bug 遇见的多了，也就由“形同陌路”转变为“日久生情”了!<br>良好的编程习惯加快解决速度</p>
</blockquote>
<p>做事情还是粗心，百分之九十的 bug 都来源于粗心，</p>
<h2 id="四、持续补充"><a href="#四、持续补充" class="headerlink" title="四、持续补充"></a>四、持续补充</h2><ul>
<li>在利用搜索引擎找到解决办法时候，不要 <strong>吃着嘴里的，想着锅里的</strong> ，找到一个办法，先将其解决办法看懂看透彻，不要这个方法还没看透彻就看下一个答案。</li>
<li>学会提取关键词来搜索，能提高很大效率</li>
</ul>
]]></content>
      <categories>
        <category>软件工程</category>
      </categories>
  </entry>
  <entry>
    <title>递归+子集问题</title>
    <url>/blog/mz8hpp/</url>
    <content><![CDATA[<h2 id="一、递归"><a href="#一、递归" class="headerlink" title="一、递归"></a>一、递归</h2><h3 id="算法特点"><a href="#算法特点" class="headerlink" title="算法特点"></a>算法特点</h3><p>适用于递归解决的问题通常有两个特点：</p>
<ol>
<li>递归性：能将规模为 n 的问题简化为 n-1 的问题，并且规模为 n 的问题和规模为 n-1 的问题性质一样</li>
<li>可终结性：不能无限递归下去，小到一定程度能够得出结果</li>
</ol>
<blockquote>
<p>eg：前 n 个自然数的和、n 个数之和这两个问题就可以用递归来解决</p>
</blockquote>
<h3 id="递归和迭代"><a href="#递归和迭代" class="headerlink" title="递归和迭代"></a>递归和迭代</h3><p>递归问题也可以用迭代方式来解决（循环），这过程中，有一些普遍的特点就是：</p>
<ol>
<li>递归问题有较好的直觉性</li>
<li>迭代运行过程中调用太多的栈空间，因而运行效率相对优于递归</li>
</ol>
<h2 id="二、问题描述"><a href="#二、问题描述" class="headerlink" title="二、问题描述"></a>二、问题描述</h2><p>给定一个正整数 n，生成集合 {1,2,3,…n} 的所有子集</p>
<h2 id="三、问题思路"><a href="#三、问题思路" class="headerlink" title="三、问题思路"></a>三、问题思路</h2><blockquote>
<p>思路一：二进制法</p>
</blockquote>
<p>利用<strong>二进制</strong>“<strong>是否显现”</strong>的转换思路来解决这个问题，一个数字在子集当中就标记为 1 反之标记为 0，就比如 <code>n=3</code> ，输出： <code>{}{1,0,0}{0,1,0}{0,0,1}{1,1,0}{1,0,1}{0,1,1}{1,1,1}</code></p>
<h2 id="四、代码思路"><a href="#四、代码思路" class="headerlink" title="四、代码思路"></a>四、代码思路</h2><blockquote>
<p>思路一：利用动态数组数据结构</p>
</blockquote>
<p>输入的 n 就是动态数组的初始大小<br>然后依次利用“吞进来”和“吐出去”尾元素来实现</p>
<h2 id="五、代码实现"><a href="#五、代码实现" class="headerlink" title="五、代码实现"></a>五、代码实现</h2><pre><code class="java">package com.wztlink1013.al._递归法_;
/*
 * 作用：测量代码运行时间
 */
import java.text.SimpleDateFormat;
import java.util.Date;

public class Times {
    private static final SimpleDateFormat fmt = new SimpleDateFormat(&quot;HH:mm:ss.SSS&quot;);

    public interface Task {
        void execute();
    }

    public static void test(String title, Task task) {
        if (task == null) return;
        title = (title == null) ? &quot;&quot; : (&quot;【&quot; + title + &quot;】&quot;);
        System.out.println(title);
        System.out.println(&quot;开始：&quot; + fmt.format(new Date()));
        long begin = System.currentTimeMillis();
        task.execute();
        long end = System.currentTimeMillis();
        System.out.println(&quot;结束：&quot; + fmt.format(new Date()));
        double delta = (end - begin) / 1000.0;
        System.out.println(&quot;耗时：&quot; + delta + &quot;秒&quot;);
        System.out.println(&quot;-------------------------------------&quot;);
    }
}
</code></pre>
<pre><code class="java">package com.wztlink1013.al._递归法_;

import java.util.ArrayList;

/**
 * 子集问题
 */
public class SubSetting {
    static ArrayList&lt;Integer&gt; x  = new ArrayList&lt;Integer&gt;();
    static int cnt = 0;
    public static void main(String args[]) {
        int n = 4;
        Times.test(&quot;当n = &quot; + n + &quot;时候的耗费时间&quot;, new Times.Task() {
            public void execute() {
                Subsetting(n);
            }
        });
    }

    private static void Subsetting(int n) {
        if (n &gt; 0) {
            x.add(0);
            Subsetting(n - 1);
            x.remove(x.size() - 1);
            x.add(1);
            Subsetting(n - 1);
            x.remove(x.size() - 1);
        }else {
            OutputOneSubsetBinary();
            OutputOneSubset();
            System.out.print(&quot;\n&quot;);
        }
    }

    private static void OutputOneSubset() {
        System.out.printf(&quot;; {&quot;);
        int k = 0;
        for (int i = x.size() - 1; i &gt;=0; i--) {
            if (x.get(i) == 1) {
                if (k &gt; 0)
                    System.out.printf(&quot;,&quot;);
                System.out.printf(&quot;%d&quot;, x.size() - i);
                k++;
            }
        }
        System.out.printf(&quot;}&quot;);
    }

    private static void OutputOneSubsetBinary() {
        System.out.printf(&quot;%010d: &quot;, ++cnt);
        for (int i = x.size() - 1; i &gt;= 0; i--)
            System.out.printf(&quot;%d&quot;, x.get(i));
    }
}
</code></pre>
<p>运行结果：</p>
<blockquote>
<p>n：18（分钟）</p>
</blockquote>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1600319992252-d49865a4-9a9d-4c65-88c8-ea72f140bf85.png#align=left&amp;display=inline&amp;height=219&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=438&amp;originWidth=1920&amp;size=146634&amp;status=done&amp;style=none&amp;width=960" alt="image.png"></p>
<blockquote>
<p>n：19（分钟）</p>
</blockquote>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1600320121635-ea76638e-a4c2-4686-a017-0d97088dc417.png#align=left&amp;display=inline&amp;height=190&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=380&amp;originWidth=1920&amp;size=140804&amp;status=done&amp;style=none&amp;width=960" alt="image.png"></p>
<blockquote>
<p>n：20（分钟）</p>
</blockquote>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1600320284010-b885d1eb-01da-40d9-a098-f5d84744d847.png#align=left&amp;display=inline&amp;height=196&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=392&amp;originWidth=1920&amp;size=144176&amp;status=done&amp;style=none&amp;width=960" alt="image.png"></p>
<blockquote>
<p>n：21（分钟）</p>
</blockquote>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1600320620721-cf61057d-1eac-48d3-b724-36d0d21c4d1e.png#align=left&amp;display=inline&amp;height=160&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=319&amp;originWidth=1920&amp;size=129722&amp;status=done&amp;style=none&amp;width=960" alt="image.png"></p>
<blockquote>
<p>n：22（分钟）</p>
</blockquote>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1600321218265-60888e51-2006-4dd7-bbe0-60b336895b8c.png#align=left&amp;display=inline&amp;height=173&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=345&amp;originWidth=1920&amp;size=131717&amp;status=done&amp;style=none&amp;width=960" alt="image.png"></p>
<blockquote>
<p>n：23（分钟）</p>
</blockquote>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1600329834700-9cb11fdc-fec8-463d-934a-b140b45cc0ae.png#align=left&amp;display=inline&amp;height=193&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=386&amp;originWidth=1920&amp;size=146130&amp;status=done&amp;style=none&amp;width=960" alt="image.png"></p>
<blockquote>
<p>网上查的代码！</p>
</blockquote>
<pre><code class="java">class Main
{
    static void printSubsets(String[] set)
    {
        int n = set.length;
        for (int i = 0; i &lt; (1&lt;&lt;n); i++)
        {
            System.out.print(&quot;{ &quot;);
            for (int j = 0; j &lt; n; j++)
                if ((i &amp; (1 &lt;&lt; j)) &gt; 0)
                    System.out.print(set[j] + &quot; &quot;);
            System.out.println(&quot;}&quot;);
        }
    }
    public static void main(String[] args)
    {
        String[] set = {&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;,
                        &quot;5&quot;, &quot;6&quot;, &quot;7&quot;, &quot;8&quot;};
        printSubsets(set);
    }
}
</code></pre>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>链表C++设计</title>
    <url>/blog/nlhg88/</url>
    <content><![CDATA[<h2 id="一些概念"><a href="#一些概念" class="headerlink" title="一些概念"></a>一些概念</h2><blockquote>
<p>一些概念</p>
</blockquote>
<ul>
<li>首元结点：第一个有元素的结点</li>
<li>头结点：一般不放元素，“L”</li>
<li>头指针：指向链表的第一个结点，有头结点则为头结点的指针，反之，指向首元结点的指针<blockquote>
<p>参考资料：<a href="https://www.jianshu.com/p/73d56c3d228c" target="_blank" rel="noopener">https://www.jianshu.com/p/73d56c3d228c</a></p>
</blockquote>
</li>
</ul>
<h2 id="C-实现"><a href="#C-实现" class="headerlink" title="C++实现"></a>C++实现</h2><pre><code class="cpp">#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;iomanip&gt;
#include&lt;stdlib.h&gt;
using namespace std;


typedef struct LNode {
    int data; //结点的数据域
    struct LNode *next; //结点的指针域
}LNode, *LinkList; //LinkList为指向结构体LNode的指针类型

bool InitList_L(LinkList &amp;L)//构造一个空的单链表L//结构体指针类型变量做为函数的形式参数
{
    L=new LNode;     //生成新结点作为头结点，用头指针L指向头结点//变量名 = new 类型
    if(!L)
      return false;  //生成结点失败
    L-&gt;next=NULL;   //头结点的指针域置空
    return true;
}

void CreateList_H(LinkList &amp;L)//前插法创建单链表
{
    //输入n个元素的值，建立到头结点的单链表L
    int n;
    LinkList s; //定义一个所建立的结构体指针变量
    L=new LNode; //生成新结点作为头结点，用头指针L指向头结点
    L-&gt;next=NULL; //先建立一个带头结点的空链表
    cout &lt;&lt;&quot;请输入元素个数n：&quot; &lt;&lt; endl;
    cin&gt;&gt;n;
    cout &lt;&lt;&quot;请依次输入n个元素：&quot; &lt;&lt;endl;
    cout &lt;&lt;&quot;前插法创建单链表...&quot; &lt;&lt;endl;
    while(n--)
    {
        s=new LNode; //生成新结点s
        cin&gt;&gt;s-&gt;data; //输入元素值赋给新结点的数据域
        s-&gt;next=L-&gt;next;
        L-&gt;next=s; //将新结点s插入到头结点之后
    }
}

void CreateList_R(LinkList &amp;L)//尾插法创建单链表
{
    //输入n个元素的值，建立带表头结点的单链表L
    int n;
    LinkList s, r;
    L=new LNode;
    L-&gt;next=NULL; //先建立一个带头结点的空链表
    r=L; //尾指针r指向头结点
    cout &lt;&lt;&quot;请输入元素个数n：&quot; &lt;&lt;endl;
    cin&gt;&gt;n;
    cout &lt;&lt;&quot;请依次输入n个元素：&quot; &lt;&lt;endl;
    cout &lt;&lt;&quot;尾插法创建单链表...&quot; &lt;&lt;endl;
    while(n--)
    {
        s=new LNode;//生成新结点
        cin&gt;&gt;s-&gt;data; //输入元素值赋给新结点的数据域
        s-&gt;next=NULL;
        r-&gt;next=s;//将新结点s插入尾结点*r之后
        r=s;//r指向新的尾结点s
    }
}

bool GetElem_L(LinkList L, int i, int &amp;e)//单链表的取值
{
    //在带头结点的单链表L中查找第i个元素
    //用e记录L中第i个数据元素的值
    int j;
    LinkList p;
    p=L-&gt;next;//p指向首元结点
    j=1; //j为计数器
    while (j&lt;i &amp;&amp; p) //顺链域向后扫描，直到p指向第i个元素或p为空
    {
        p=p-&gt;next; //p指向下一个结点    类似结点的自加
        j++; //计数器j相应加1
    }
    if (!p || j&gt;i)
        return false; //i值不合法i＞n或i&lt;=0
    e=p-&gt;data; //取第i个结点的数据域
    return true;
}

bool LocateElem_L(LinkList L, int e) //按值查找
{
    //在带头结点的单链表L中查找值为e的元素
    LinkList p;
    p=L-&gt;next;
    while (p &amp;&amp; p-&gt;data!=e)//顺链域向后扫描，直到p为空或p所指结点的数据域等于e
        p=p-&gt;next; //p指向下一个结点
    if(!p)
        return false; //查找失败p为NULL
    return true;
}

bool ListInsert_L(LinkList &amp;L, int i, int e)//单链表的插入
{
    //在带头结点的单链表L中第i个位置插入值为e的新结点
    int j;
    LinkList p, s;
    p=L;
    j=0;
    while (p&amp;&amp;j&lt;i-1) //查找第i-1个结点，p指向该结点
    {
        p=p-&gt;next;
        j++;
    }
    if (!p || j&gt;i-1)//i＞n+1或者i＜1
        return false;
    s=new LNode;     //生成新结点
    s-&gt;data=e;       //将新结点的数据域置为e
    s-&gt;next=p-&gt;next; //将新结点的指针域指向结点ai
    p-&gt;next=s;       //将结点p的指针域指向结点s
    return true;
}

bool ListDelete_L(LinkList &amp;L, int i) //单链表的删除
{
    //在带头结点的单链表L中，删除第i个位置
    LinkList p, q;
    int j;
    p=L;
    j=0;
    while((p-&gt;next)&amp;&amp;(j&lt;i-1)) //查找第i-1个结点，p指向该结点
    {
        p=p-&gt;next;
        j++;
    }
    if (!(p-&gt;next)||(j&gt;i-1))//当i&gt;n或i&lt;1时，删除位置不合理
        return false;
    q=p-&gt;next;        //临时保存被删结点的地址以备释放空间
    p-&gt;next=q-&gt;next; //改变删除结点前驱结点的指针域
    delete q;        //释放被删除结点的空间
    return true;
}

void Listprint_L(LinkList L) //单链表的输出
{
    LinkList p;
    p=L-&gt;next;
    while (p)
    {
        cout&lt;&lt;p-&gt;data&lt;&lt;&quot;\t&quot;;
        p=p-&gt;next;
    }
    cout&lt;&lt;endl;
}

int main()
{
    int i,x,e,choose;
    LinkList L;
    cout &lt;&lt; &quot;1. 初始化\n&quot;;
    cout &lt;&lt; &quot;2. 创建单链表（前插法）\n&quot;;
    cout &lt;&lt; &quot;3. 创建单链表（尾插法）\n&quot;;
    cout &lt;&lt; &quot;4. 取值\n&quot;;
    cout &lt;&lt; &quot;5. 查找\n&quot;;
    cout &lt;&lt; &quot;6. 插入\n&quot;;
    cout &lt;&lt; &quot;7. 删除\n&quot;;
    cout &lt;&lt; &quot;8. 输出\n&quot;;
    cout &lt;&lt; &quot;0. 退出\n&quot;;
    choose=-1;
    while (choose!=0)
    {
        cout&lt;&lt;&quot;请输入数字选择:&quot;;
        cin&gt;&gt;choose;
        switch (choose)
        {
        case 1: //初始化一个空的单链表
            if (InitList_L(L))
                cout &lt;&lt; &quot;初始化一个空的单链表!\n&quot;;
            break;
        case 2: //创建单链表（前插法）
            CreateList_H(L);
            cout &lt;&lt; &quot;前插法创建单链表输出结果:\n&quot;;
            Listprint_L(L);
            break;
        case 3: //创建单链表（尾插法）
            CreateList_R(L);
            cout &lt;&lt; &quot;尾插法创建单链表输出结果:\n&quot;;
            Listprint_L(L);
            break;
        case 4: //单链表的按序号取值
            cout &lt;&lt; &quot;请输入一个位置i用来取值:&quot;;
            cin &gt;&gt; i;
            if (GetElem_L(L,i,e))
            {
                cout &lt;&lt; &quot;查找成功\n&quot;;
                cout &lt;&lt; &quot;第&quot; &lt;&lt; i &lt;&lt; &quot;个元素是：&quot;&lt;&lt;e&lt;&lt; endl;
            }
            else
                cout &lt;&lt; &quot;查找失败\n\n&quot;;
            break;
        case 5: //单链表的按值查找
            cout&lt;&lt;&quot;请输入所要查找元素x:&quot;;
            cin&gt;&gt;x;
            if (LocateElem_L(L,x))
                cout &lt;&lt; &quot;查找成功\n&quot;;
            else
                cout &lt;&lt; &quot;查找失败! &quot; &lt;&lt;endl;
            break;
        case 6: //单链表的插入
            cout &lt;&lt; &quot;请输入插入的位置和元素（用空格隔开）:&quot;;
            cin &gt;&gt; i;
            cin &gt;&gt; x;
            if (ListInsert_L(L, i, x))
                cout &lt;&lt; &quot;插入成功.\n\n&quot;;
            else
                cout &lt;&lt; &quot;插入失败!\n\n&quot;;
            break;
        case 7: //单链表的删除
            cout&lt;&lt;&quot;请输入所要删除的元素位置i:&quot;;
            cin&gt;&gt;i;
            if (ListDelete_L(L, i))
                cout&lt;&lt;&quot;删除成功!\n&quot;;
            else
                cout&lt;&lt;&quot;删除失败!\n&quot;;
            break;
        case 8: //单链表的输出
            cout &lt;&lt; &quot;当前单链表的数据元素分别为:\n&quot;;
            Listprint_L(L);
            cout &lt;&lt; endl;
            break;
        }
    }
    system(&quot;pause&quot;);
    return 0;
}
</code></pre>
]]></content>
      <categories>
        <category>DataStructure</category>
      </categories>
  </entry>
  <entry>
    <title>Jupyter使用总结</title>
    <url>/blog/ouipza/</url>
    <content><![CDATA[<h2 id="一、Jupyter-环境的搭建"><a href="#一、Jupyter-环境的搭建" class="headerlink" title="一、Jupyter 环境的搭建"></a>一、Jupyter 环境的搭建</h2><ol>
<li>pip 下载</li>
<li>跟随 anaconda 下载</li>
</ol>
<h2 id="二、高效使用，安装扩展插件"><a href="#二、高效使用，安装扩展插件" class="headerlink" title="二、高效使用，安装扩展插件"></a>二、高效使用，安装扩展插件</h2><p>一般只需要下面两条命令，就可以重新打开就可看见新安装的插件环境。</p>
<p><code>pip install jupyter_contrib_nbextensions</code></p>
<p>或者</p>
<p><code>jupyter contrib nbextension install</code></p>
<p>但是 pip 下载完，会出现 jupyter_contrib_nbextension 扩展功能后不显示 Nbextensions 标签的 bug，在此记录下解决的方式。</p>
<h2 id="三、扩展插件不显示的解决方法"><a href="#三、扩展插件不显示的解决方法" class="headerlink" title="三、扩展插件不显示的解决方法"></a>三、扩展插件不显示的解决方法</h2><ol>
<li>如果之前已经用上述两条命令之一安装了上述包，且用 pip list 查看的确成功安装，则依次进行下面删除命令（选 y）:<br><code>pip uninstall jupyter_contrib_nbextensions</code><br><code>pip uninstall jupyter_nbextensions_configurator</code></li>
<li>打开 Anaconda Prompt 窗口，执行第一个命令，用于安装 nbextensions:<br><code>pip install jupyter_contrib_nbextensions</code></li>
<li>再执行第下面命令，用于安装 javascript and css files:<br><code>jupyter contrib nbextension install --user</code></li>
<li>最后执行，用于安装 configurator:<br><code>pip install jupyter_nbextensions_configurator</code></li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://www.jiqizhixin.com/articles/2018-12-20-12" target="_blank" rel="noopener">五个常用插件 - 简书</a></li>
<li><a href="https://www.zhihu.com/question/59392251/answer/560977151" target="_blank" rel="noopener">如何优雅地使用 Jupyter？ - 量子位的回答 - 知乎</a></li>
<li><a href="https://blog.csdn.net/xiaodongxiexie/article/details/54633183" target="_blank" rel="noopener">jupyter 使用技巧</a></li>
</ul>
]]></content>
      <categories>
        <category>Environment</category>
      </categories>
  </entry>
  <entry>
    <title>CPP-LINKfatal error LNK1561: 必须定义入口点</title>
    <url>/blog/oyvpk4/</url>
    <content><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><pre><code class="cpp">LINK : fatal error LNK1561: 必须定义入口点
</code></pre>
<h2 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h2><p>每个应用程序(文件格式为 exe)都应该有个启动点，这个点就是 main 函数。缺少就会出现 link error 。</p>
<p>解决方法</p>
<ol>
<li>添加含有 main 函数的 CPP 文件</li>
<li>右击属性，在常规项中修改配置类型，将应用程序修改为库，动静态库</li>
</ol>
]]></content>
      <categories>
        <category>Bug</category>
      </categories>
  </entry>
  <entry>
    <title>SSH-登录报错</title>
    <url>/blog/pix070/</url>
    <content><![CDATA[<h2 id="一、报错信息"><a href="#一、报错信息" class="headerlink" title="一、报错信息"></a>一、报错信息</h2><pre><code class="bash">remote: Coding 提示: Authentication failed.
remote: 认证失败，请确认您输入了正确的账号密码。
fatal: Authentication failed for &#39;https://e.coding.net/wztlink1013/wztlink1013.git/&#39;
##[error]Process completed with exit code 128.
</code></pre>
<h2 id="二、分析并解决问题"><a href="#二、分析并解决问题" class="headerlink" title="二、分析并解决问题"></a>二、分析并解决问题</h2><p>自动化部署过程中，coding 认证出错，我觉得应该有两个可能性</p>
<ol>
<li>字面意思账号密码出错</li>
<li>SSH 密匙没有匹配到</li>
<li>在 GitHub Actions 上所配置的 Token 信息之间也修改了一次，会不会是忘了改用户名</li>
</ol>
<p>如果是第一种情况，已经进入控制面板中的凭据管理器，更改了 coding 在本机上的默认永久密码，不弹窗理论没事，但是无效，</p>
<p>根据上次在本机上克隆 coding 仓库也没有其任何反应，所以问题应该出在 ssh 密匙上面，进一步回想，自己重装电脑后，当时是打算不使用全局用户没加上 global 打算使用各个用户，但是最后又换成全局用户，所以生成的.ssh 文件夹下的 config 文件有被删除了，会不会是 config 里面的 coding host 被删除，就默认这个电脑只有初始化 github 用户呢？</p>
<p>好的，试验了一下，解决了在本地电脑 coding“不算用户”的问题，但是自动化部署的问题未解决</p>
<p>最后试一下 GitHub Actions 上是不是 coding 用户名之间忘了换一次，的确是……</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://www.jianshu.com/p/501277e1bada" target="_blank" rel="noopener">一台电脑利用秘钥绑定多个 ssh-key 账号（实 n</a></li>
</ul>
]]></content>
      <categories>
        <category>Bug</category>
      </categories>
  </entry>
  <entry>
    <title>HTTPS较HTTP安全在哪？</title>
    <url>/blog/pl8gro/</url>
    <content><![CDATA[<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612949716697-1ceb6a5c-fa5e-4129-9c0a-63e01ce75057.png#align=left&amp;display=inline&amp;height=51&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=56&amp;originWidth=615&amp;size=6666&amp;status=done&amp;style=shadow&amp;width=564" alt="image.png"></p>
<h2 id="HTTPS-的精妙之处"><a href="#HTTPS-的精妙之处" class="headerlink" title="HTTPS 的精妙之处"></a>HTTPS 的精妙之处</h2><p>在我写的算法相关文章里面，有一篇 RSA 相关的文章<a href="https://www.wztlink1013.com/blog/ccd10c/">https://www.wztlink1013.com/blog/ccd10c/</a>，里面解释了对称加密和的非对称加密</p>
<p>我觉得 HTTPS 的精妙之处就是在于它同时运用了<strong>对称加密（AES）</strong>和<strong>非对称加密（RSA）</strong>两种加密，下面我解释一下：</p>
<h2 id="HTTP-为何不安全？"><a href="#HTTP-为何不安全？" class="headerlink" title="HTTP 为何不安全？"></a>HTTP 为何不安全？</h2><p>客户端对服务端做出请求，然后服务端做出响应，这个大家都知道，但是 HTTP 是明文传输，我在<a href="https://www.wztlink1013.com/blog/bw80k6/">https://www.wztlink1013.com/blog/bw80k6/</a>这篇文章里面也详细抓包展示了 HTTP 的明文传输<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612946821326-d568e02e-1173-4af4-93c5-539275023ba3.png#align=left&amp;display=inline&amp;height=282&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=563&amp;originWidth=1544&amp;size=287151&amp;status=done&amp;style=stroke&amp;width=772" alt="image.png"><br>这样传输的信息就不安全，攻击者就能轻易得到，进一步讲，得到了就不安全吗？</p>
<ul>
<li>因为假如此时服务端响应给客户端的是很重要的诸如密码或者个人信息之类的敏感信息，就会被窃听</li>
<li>中途截取，将所传输的信息不完整等等</li>
</ul>
<h2 id="HTTPS-安全在哪？精妙之处！"><a href="#HTTPS-安全在哪？精妙之处！" class="headerlink" title="HTTPS 安全在哪？精妙之处！"></a>HTTPS 安全在哪？精妙之处！</h2><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612947167321-69c11c8d-9f8d-4f78-80a9-b2ee1c02e6b8.png#align=left&amp;display=inline&amp;height=259&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=517&amp;originWidth=992&amp;size=373859&amp;status=done&amp;style=stroke&amp;width=496" alt="image.png"><br>由上图所示，HTTPS 的协议栈相较 HTTP 协议栈多了安全层，也就是 SSL(安全套接层)或者 TSL(安全传输层)协议</p>
<ol>
<li><p>客户端向服务端发出一个 https 请求，其中端口位 443</p>
<blockquote>
<p>说明：采用 https 的网站都会有相应的 ssl 证书，在服务器那里，这个证书内容就是颁发的机构、到期时间……，而这个证书的形式就是以公钥的形式存在于服务器的。</p>
</blockquote>
</li>
<li><p>服务端响应给客户端这个证书（公钥的形式）</p>
</li>
<li>客户端解析响应来的公钥，因为需要验证这个 ssl 是不是伪造的还是过期了等等，假如验证不成功，就会如下：</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612948950125-219e56dd-b6cd-4245-8aa5-44ad8e6e381c.png#align=left&amp;display=inline&amp;height=38&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=75&amp;originWidth=605&amp;size=7708&amp;status=done&amp;style=stroke&amp;width=302.5" alt="image.png"></p>
<ol start="4">
<li>然后客户端（浏览器）利用这个公钥随机得出的私钥，然后将这个私钥发给服务端，以后客户端和服务端就可以利用这个密钥来解密双方传来传去的加密信息了<blockquote>
<p>说明：随机的出的私钥并不是那么“随机”，因为要保证不可攻破性，具体可以看我的 RSA 算法相关文章</p>
</blockquote>
</li>
</ol>
<hr>
<ol start="5">
<li>服务端将要展示给客户端的具体信息利用上述私钥来加密</li>
<li>客户端接收到服务端发过来的加密信息，用共同都有的私钥解密查看之<blockquote>
<p>整个过程对外人而言看到的都是加密后的信息，而不是明文</p>
</blockquote>
</li>
</ol>
<p>综上，56 条是采用了 AES 对称加密，而前面是利用 RSA 算法得到私钥</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li>这位博主（数据中心网络工程师）将 SSL 讲解的更加细致，可以常看：<a href="https://cshihong.github.io/2019/05/09/SSL%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/" target="_blank" rel="noopener">SSL/TLS 协议详解</a></li>
</ul>
]]></content>
      <categories>
        <category>计算机系统</category>
      </categories>
  </entry>
  <entry>
    <title>VScode使用</title>
    <url>/blog/pm7mpk/</url>
    <content><![CDATA[<h2 id="VScode-常用插件"><a href="#VScode-常用插件" class="headerlink" title="VScode 常用插件"></a>VScode 常用插件</h2><ul>
<li>[x] Markdown Preview Github Styling【Markdown】</li>
<li>[x] Markdown All in One【Markdown】</li>
<li>[ ] <del>GBKtoUTF8</del></li>
<li>[x] CodeRunner【编写 C/C++】</li>
<li>[x] C/C++【编写 C/C++】</li>
<li>[x] Chinese (simplified)Language pack for Visual Code【简体中文】</li>
<li>[x] [ ] <del>Bracket Pair Colorrizer 2 【优化大括号】</del></li>
<li>[ ] <del>background 【添加背景图片】</del></li>
<li>[ ] <del>AnsiComment</del></li>
<li>[x] vscode-icons【美化图标】</li>
<li>[ ] <del>Path Intellisense【补全】</del></li>
<li>[ ] <del>GitLens 【显示当前行 commit 信息，管理 git】</del></li>
<li>[ ] <del>Git History 【查看 commit 信息】</del></li>
<li>[x] Waka Time【记录软件编写各类语言时间分配】</li>
<li>[x] Todo Tree【优化 TODO：侧边栏】</li>
<li>[x] Todo Highlight【优化 TODO：高亮】</li>
<li>[x] language-stylus【hexo 博客】</li>
<li>[x] Live Server【运行 HTML】</li>
</ul>
<h2 id="VScode-编写-C-和-C-配置"><a href="#VScode-编写-C-和-C-配置" class="headerlink" title="VScode 编写 C 和 C++配置"></a>VScode 编写 C 和 C++配置</h2><blockquote>
<ul>
<li>下载插件 ✅CodeRunner【编写 C/C++】✅C/C++【编写 C/C++】</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>建立一个 <code>.vscode</code>  文件夹，然后在里面新建下面三个文件即可。</li>
</ul>
</blockquote>
<h3 id="launch-json"><a href="#launch-json" class="headerlink" title="launch.json"></a>launch.json</h3><pre><code class="json">// https://code.visualstudio.com/docs/cpp/launch-json-reference
{
  &quot;version&quot;: &quot;0.2.0&quot;,
  &quot;configurations&quot;: [
    {
      &quot;name&quot;: &quot;(gdb) Launch&quot;, // 配置名称，将会在启动配置的下拉菜单中显示
      &quot;type&quot;: &quot;cppdbg&quot;, // 配置类型，cppdbg对应cpptools提供的调试功能；可以认为此处只能是cppdbg
      &quot;request&quot;: &quot;launch&quot;, // 请求配置类型，可以为launch（启动）或attach（附加）
      &quot;program&quot;: &quot;${fileDirname}/${fileBasenameNoExtension}.exe&quot;, // 将要进行调试的程序的路径
      &quot;args&quot;: [], // 程序调试时传递给程序的命令行参数，一般设为空即可
      &quot;stopAtEntry&quot;: false, // 设为true时程序将暂停在程序入口处，相当于在main上打断点
      &quot;cwd&quot;: &quot;${workspaceFolder}&quot;, // 调试程序时的工作目录，此为工作区文件夹；改成${fileDirname}可变为文件所在目录
      &quot;environment&quot;: [], // 环境变量
      &quot;externalConsole&quot;: true, // 使用单独的cmd窗口，与其它IDE一致；为false时使用内置终端
      &quot;internalConsoleOptions&quot;: &quot;neverOpen&quot;, // 如果不设为neverOpen，调试时会跳到“调试控制台”选项卡，你应该不需要对gdb手动输命令吧？
      &quot;MIMode&quot;: &quot;gdb&quot;, // 指定连接的调试器，可以为gdb或lldb。但我没试过lldb
      &quot;miDebuggerPath&quot;: &quot;gdb.exe&quot;, // 调试器路径，Windows下后缀不能省略，Linux下则不要
      &quot;setupCommands&quot;: [
        {
          // 模板自带，好像可以更好地显示STL容器的内容，具体作用自行Google
          &quot;description&quot;: &quot;Enable pretty-printing for gdb&quot;,
          &quot;text&quot;: &quot;-enable-pretty-printing&quot;,
          &quot;ignoreFailures&quot;: false
        }
      ],
      &quot;preLaunchTask&quot;: &quot;Compile&quot; // 调试会话开始前执行的任务，一般为编译程序。与tasks.json的label相对应
    }
  ]
}
</code></pre>
<h3 id="settings-json"><a href="#settings-json" class="headerlink" title="settings.json"></a>settings.json</h3><pre><code class="json">{
  &quot;files.defaultLanguage&quot;: &quot;c&quot;, // ctrl+N新建文件后默认的语言
  &quot;editor.formatOnType&quot;: true, // 输入分号(C/C++的语句结束标识)后自动格式化当前这一行的代码
  &quot;editor.suggest.snippetsPreventQuickSuggestions&quot;: false, // clangd的snippets有很多的跳转点，不用这个就必须手动触发Intellisense了
  &quot;editor.acceptSuggestionOnEnter&quot;: &quot;off&quot;, // 我个人的习惯，按回车时一定是真正的换行，只有tab才会接受Intellisense
  // &quot;editor.snippetSuggestions&quot;: &quot;top&quot;, // （可选）snippets显示在补全列表顶端，默认是inline

  &quot;code-runner.runInTerminal&quot;: true, // 设置成false会在“输出”中输出，无法输入
  &quot;code-runner.executorMap&quot;: {
    &quot;c&quot;: &quot;gcc &#39;$fileName&#39; -o &#39;$fileNameWithoutExt.exe&#39; -Wall -O2 -m64 -lm -static-libgcc -std=c11 -fexec-charset=GBK &amp;&amp; &amp;&#39;./$fileNameWithoutExt.exe&#39;&quot;,
    &quot;cpp&quot;: &quot;g++ &#39;$fileName&#39; -o &#39;$fileNameWithoutExt.exe&#39; -Wall -O2 -m64 -static-libgcc -std=c++14 -fexec-charset=GBK &amp;&amp; &amp;&#39;./$fileNameWithoutExt.exe&#39;&quot;
    // &quot;c&quot;: &quot;gcc $fileName -o $fileNameWithoutExt.exe -Wall -O2 -m64 -lm -static-libgcc -std=c11 -fexec-charset=GBK &amp;&amp; $dir$fileNameWithoutExt.exe&quot;,
    // &quot;cpp&quot;: &quot;g++ $fileName -o $fileNameWithoutExt.exe -Wall -O2 -m64 -static-libgcc -std=c++14 -fexec-charset=GBK &amp;&amp; $dir$fileNameWithoutExt.exe&quot;
  }, // 右键run code时运行的命令；未注释的仅适用于PowerShell（Win10默认）和pwsh，文件名中有空格也可以编译运行；注释掉的适用于cmd（win7默认）、PS和bash，但文件名中有空格时无法运行
  &quot;code-runner.saveFileBeforeRun&quot;: true, // run code前保存
  &quot;code-runner.preserveFocus&quot;: true, // 若为false，run code后光标会聚焦到终端上。如果需要频繁输入数据可设为false
  &quot;code-runner.clearPreviousOutput&quot;: false, // 每次run code前清空属于code runner的终端消息，默认false
  &quot;code-runner.ignoreSelection&quot;: true, // 默认为false，效果是鼠标选中一块代码后可以单独执行，但C是编译型语言，不适合这样用
  &quot;code-runner.fileDirectoryAsCwd&quot;: true, // 将code runner终端的工作目录切换到文件目录再运行，对依赖cwd的程序产生影响；如果为false，executorMap要加cd $dir

  &quot;C_Cpp.clang_format_sortIncludes&quot;: true // 格式化时调整include的顺序（按字母排序）
}
</code></pre>
<h3 id="tasks-json"><a href="#tasks-json" class="headerlink" title="tasks.json"></a>tasks.json</h3><pre><code class="json">// https://code.visualstudio.com/docs/editor/tasks
{
  &quot;version&quot;: &quot;2.0.0&quot;,
  &quot;tasks&quot;: [
    {
      &quot;label&quot;: &quot;Compile&quot;, // 任务名称，与launch.json的preLaunchTask相对应
      &quot;command&quot;: &quot;gcc&quot;, // 要使用的编译器，C++用g++
      &quot;args&quot;: [
        &quot;${file}&quot;,
        &quot;-o&quot;, // 指定输出文件名，不加该参数则默认输出a.exe，Linux下默认a.out
        &quot;${fileDirname}/${fileBasenameNoExtension}.exe&quot;,
        &quot;-g&quot;, // 生成和调试有关的信息
        &quot;-m64&quot;, // 不知为何有时会生成16位应用而无法运行，加上此条可强制生成64位的
        &quot;-Wall&quot;, // 开启额外警告
        &quot;-static-libgcc&quot;, // 静态链接libgcc，一般都会加上
        &quot;-fexec-charset=GBK&quot; // 生成的程序使用GBK编码，不加这条会导致Win下输出中文乱码；繁体系统改成BIG5
        // &quot;-std=c11&quot;, // 要用的语言标准，根据自己的需要修改。c++可用c++14
      ], // 编译的命令，其实相当于VSC帮你在终端中输了这些东西
      &quot;type&quot;: &quot;process&quot;, // process是把预定义变量和转义解析后直接全部传给command；shell相当于先打开shell再输入命令，所以args还会经过shell再解析一遍
      &quot;group&quot;: {
        &quot;kind&quot;: &quot;build&quot;,
        &quot;isDefault&quot;: true // 不为true时ctrl shift B就要手动选择了
      },
      &quot;presentation&quot;: {
        &quot;echo&quot;: true,
        &quot;reveal&quot;: &quot;always&quot;, // 执行任务时是否跳转到终端面板，可以为always，silent，never。具体参见VSC的文档
        &quot;focus&quot;: false, // 设为true后可以使执行task时焦点聚集在终端，但对编译C/C++来说，设为true没有意义
        &quot;panel&quot;: &quot;shared&quot; // 不同的文件的编译信息共享一个终端面板
      },
      &quot;problemMatcher&quot;: &quot;$gcc&quot; // 捕捉编译时终端里的报错信息到问题面板中，修改代码后需要重新编译才会再次触发
      // 本来有Lint，再开problemMatcher就有双重报错，但MinGW的Lint效果实在太差了；用Clang可以注释掉
    }
  ]
}
</code></pre>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><ul>
<li>vscode 可以自定义 markdown 预览样式，css 文件以外链的方式放上</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://www.zhihu.com/question/30315894" target="_blank" rel="noopener">Visual Studio Code 如何编写运行 C、C++ 程序？</a></li>
<li><a href="https://segmentfault.com/a/1190000006697219" target="_blank" rel="noopener">vscode 插件推荐 - 献给所有前端工程师（2019.10.12 更新）</a></li>
<li><a href="https://blog.csdn.net/TriDiamond6/article/details/105604427?utm_source=app" target="_blank" rel="noopener">VSCode 插件大全｜ VSCode 高级玩家之第二篇</a></li>
</ul>
]]></content>
      <categories>
        <category>Environment</category>
      </categories>
  </entry>
  <entry>
    <title>P509. 斐波那契数</title>
    <url>/blog/pmd7dz/</url>
    <content><![CDATA[<h3 id="509-斐波那契数"><a href="#509-斐波那契数" class="headerlink" title="509. 斐波那契数"></a>509. 斐波那契数</h3><pre><code class="java">class Solution {
    // TODO: for循环实现
    public int fib(int N) {
        if (N &lt;= 1) return N;
        int first = 0;
        int second = 1;
        for (int i = 0; i &lt; N - 1; i++) {
            int sum = first + second;
            first = second;
            second = sum;
        }
        return second;
    }
//    // TODO: 递归实现O(2^n)
//    public int fib1(int n) {
//        if (n &lt;= 1) return n;
//        return fib1(n - 1) + fib1(n - 2);
//    }
//    // TODO: 首尾实现
//    public int fib3(int n) {
//        if (n &lt;= 1) return n;
//        int first = 0;
//        int second = 1;
//        while (n-- &gt; 1) {
//            second += first;
//            first = second - first;
//        }
//        return second;
//    }
}
</code></pre>
<h3 id="509-斐波那契数-1"><a href="#509-斐波那契数-1" class="headerlink" title="509. 斐波那契数"></a>509. 斐波那契数</h3><pre><code class="java">// 递归：O(2^n)
public static int fib1(int n) {
    if (n &lt;= 1) return n;
    return fib1(n - 1) + fib1(n - 2);
}

// for循环：O(n)
public static int fib2(int n) {
    if (n &lt;= 1) return n;
    int first = 0;
    int second = 1;
    for (int i = 0; i &lt; n - 1; i++) {
        int sum = first + second;
        first = second;
        second = sum;
    }
    return second;
}
// 首尾法
public static int fib3(int n) {
    if (n &lt;= 1) return n;

    int first = 0;
    int second = 1;
    while (n-- &gt; 1) {
        second += first;
        first = second - first;
    }
    return second;
}
// 特征方程解法：O（1）
public static int fib4(int n) {
    double c = Math.sqrt(5);
    return (int) (Math.pow((1+c) / 2, n) - Math.pow((1-c) / 2, c));
}
</code></pre>
]]></content>
      <categories>
        <category>DataStructure</category>
      </categories>
  </entry>
  <entry>
    <title>hexo-生成文章出错</title>
    <url>/blog/pxpix4/</url>
    <content><![CDATA[<h2 id="一、报错信息"><a href="#一、报错信息" class="headerlink" title="一、报错信息"></a>一、报错信息</h2><pre><code class="bash">hexo g
INFO  Start processing
FATAL Somethings wrong. Maybe you can find the solution here: https://hexo.io/docs/troubleshooting.html
Template render error: (unknown path)
  unexpected end of file
    at Object._prettifyError (D:\Blog\blog-wztlink1013-3.0\node_modules\nunjucks\src\lib.js:36:11)
    at Template.render (D:\Blog\blog-wztlink1013-3.0\node_modules\nunjucks\src\environment.js:536:21)
    at Environment.renderString (D:\Blog\blog-wztlink1013-3.0\node_modules\nunjucks\src\environment.js:378:17)
    at D:\Blog\blog-wztlink1013-3.0\node_modules\hexo\lib\extend\tag.js:120:48
    at tryCatcher (D:\Blog\blog-wztlink1013-3.0\node_modules\bluebird\js\release\util.js:16:23)
    at Function.Promise.fromNode.Promise.fromCallback (D:\Blog\blog-wztlink1013-3.0\node_modules\bluebird\js\release\promise.js:209:30)
    at Tag.render (D:\Blog\blog-wztlink1013-3.0\node_modules\hexo\lib\extend\tag.js:120:18)
    at Object.onRenderEnd (D:\Blog\blog-wztlink1013-3.0\node_modules\hexo\lib\hexo\post.js:291:22)
    at D:\Blog\blog-wztlink1013-3.0\node_modules\hexo\lib\hexo\render.js:79:21
    at tryCatcher (D:\Blog\blog-wztlink1013-3.0\node_modules\bluebird\js\release\util.js:16:23)
    at Promise._settlePromiseFromHandler (D:\Blog\blog-wztlink1013-3.0\node_modules\bluebird\js\release\promise.js:547:31)
    at Promise._settlePromise (D:\Blog\blog-wztlink1013-3.0\node_modules\bluebird\js\release\promise.js:604:18)
    at Promise._settlePromise0 (D:\Blog\blog-wztlink1013-3.0\node_modules\bluebird\js\release\promise.js:649:10)
    at Promise._settlePromises (D:\Blog\blog-wztlink1013-3.0\node_modules\bluebird\js\release\promise.js:729:18)
    at _drainQueueStep (D:\Blog\blog-wztlink1013-3.0\node_modules\bluebird\js\release\async.js:93:12)
    at _drainQueue (D:\Blog\blog-wztlink1013-3.0\node_modules\bluebird\js\release\async.js:86:9)
    at Async._drainQueues (D:\Blog\blog-wztlink1013-3.0\node_modules\bluebird\js\release\async.js:102:5)
    at Immediate.Async.drainQueues (D:\Blog\blog-wztlink1013-3.0\node_modules\bluebird\js\release\async.js:15:14)
    at processImmediate (internal/timers.js:456:21)
</code></pre>
<h2 id="二、分析并解决问题"><a href="#二、分析并解决问题" class="headerlink" title="二、分析并解决问题"></a>二、分析并解决问题</h2><p>根据报错信息，包 nunjucks、bluebird 使用异常</p>
<p>然后进到 node_modules 文件夹里面分别找到两个包，进入 README.md 进入官网，numjucks 包应该是渲染文章有关，期间出错应该是 markdown 文章里面所使用的标签与 nunjucks 模板引擎的标签冲突，</p>
<p>根据文档定位英文大括号的使用，定位文章使用带有大括号的 fancybox 标签，标签结束忘记加 end 而导致出错</p>
<h2 id="三、hexo-g-出错总结"><a href="#三、hexo-g-出错总结" class="headerlink" title="三、hexo g 出错总结"></a>三、hexo g 出错总结</h2><p>hexo g 出错总结多为文件格式出错，主题配置出错，抑或是文章格式出错等</p>
<h3 id="文章头部"><a href="#文章头部" class="headerlink" title="文章头部"></a>文章头部</h3><ul>
<li><em>hexo 相关文章报错，大多数为格式出错，文章头部的使用严格遵循 hexo 官方文档的使用，但是目录优化插件，使得文章头部的元信息更为简单化</em></li>
<li>减号<code>-</code>分隔符，注意头部 front-matter、markdown 行分隔。如果没有加 front-matter，文章还用了 markdown，会报错<br><code>YAMLException: end of the stream or a document separator is expected at line 6, column 1:</code></li>
<li>目录优化插件的使用</li>
</ul>
<h3 id="文章体"><a href="#文章体" class="headerlink" title="文章体"></a>文章体</h3><ul>
<li>英文大括号的使用要“有始有终”，Volantis 主题的大括号标签使用</li>
</ul>
<h3 id="空格问题"><a href="#空格问题" class="headerlink" title="空格问题"></a>空格问题</h3><pre><code class="bash">ERROR Process failed: _posts/yuque/外汇时间序列预测.md
YAMLException: end of the stream or a document separator is expected at line 2, column 11:
    categories:
              ^
    at generateError (D:\Blog\blog-wztlink1013-3.0\node_modules\js-yaml\lib\js-yaml\loader.js:167:10)
    at throwError (D:\Blog\blog-wztlink1013-3.0\node_modules\js-yaml\lib\js-yaml\loader.js:173:9)
    at readDocument (D:\Blog\blog-wztlink1013-3.0\node_modules\js-yaml\lib\js-yaml\loader.js:1545:5)
    at loadDocuments (D:\Blog\blog-wztlink1013-3.0\node_modules\js-yaml\lib\js-yaml\loader.js:1588:5)
    at Object.load (D:\Blog\blog-wztlink1013-3.0\node_modules\js-yaml\lib\js-yaml\loader.js:1614:19)
    at parseYAML (D:\Blog\blog-wztlink1013-3.0\node_modules\hexo-front-matter\lib\front_matter.js:78:23)
    at parse (D:\Blog\blog-wztlink1013-3.0\node_modules\hexo-front-matter\lib\front_matter.js:54:12)
    at D:\Blog\blog-wztlink1013-3.0\node_modules\hexo\lib\plugins\processor\post.js:48:20
    at tryCatcher (D:\Blog\blog-wztlink1013-3.0\node_modules\bluebird\js\release\util.js:16:23)
    at Promise._settlePromiseFromHandler (D:\Blog\blog-wztlink1013-3.0\node_modules\bluebird\js\release\promise.js:544:35)
    at Promise._settlePromise (D:\Blog\blog-wztlink1013-3.0\node_modules\bluebird\js\release\promise.js:604:18)
    at Promise._settlePromise0 (D:\Blog\blog-wztlink1013-3.0\node_modules\bluebird\js\release\promise.js:649:10)
    at Promise._settlePromises (D:\Blog\blog-wztlink1013-3.0\node_modules\bluebird\js\release\promise.js:729:18)
    at Promise._fulfill (D:\Blog\blog-wztlink1013-3.0\node_modules\bluebird\js\release\promise.js:673:18)
    at PromiseArray._resolve (D:\Blog\blog-wztlink1013-3.0\node_modules\bluebird\js\release\promise_array.js:127:19)
    at PromiseArray._promiseFulfilled (D:\Blog\blog-wztlink1013-3.0\node_modules\bluebird\js\release\promise_array.js:145:14)
    at PromiseArray._iterate (D:\Blog\blog-wztlink1013-3.0\node_modules\bluebird\js\release\promise_array.js:115:31)
    at PromiseArray.init [as _init] (D:\Blog\blog-wztlink1013-3.0\node_modules\bluebird\js\release\promise_array.js:79:10)
    at Promise._settlePromise (D:\Blog\blog-wztlink1013-3.0\node_modules\bluebird\js\release\promise.js:601:21)
    at Promise._settlePromise0 (D:\Blog\blog-wztlink1013-3.0\node_modules\bluebird\js\release\promise.js:649:10)
    at Promise._settlePromises (D:\Blog\blog-wztlink1013-3.0\node_modules\bluebird\js\release\promise.js:729:18)
    at Promise._fulfill (D:\Blog\blog-wztlink1013-3.0\node_modules\bluebird\js\release\promise.js:673:18)
    at PromiseArray._resolve (D:\Blog\blog-wztlink1013-3.0\node_modules\bluebird\js\release\promise_array.js:127:19)
    at PromiseArray._promiseFulfilled (D:\Blog\blog-wztlink1013-3.0\node_modules\bluebird\js\release\promise_array.js:145:14)
    at Promise._settlePromise (D:\Blog\blog-wztlink1013-3.0\node_modules\bluebird\js\release\promise.js:609:26)
    at Promise._settlePromise0 (D:\Blog\blog-wztlink1013-3.0\node_modules\bluebird\js\release\promise.js:649:10)
    at Promise._settlePromises (D:\Blog\blog-wztlink1013-3.0\node_modules\bluebird\js\release\promise.js:729:18)
    at Promise._fulfill (D:\Blog\blog-wztlink1013-3.0\node_modules\bluebird\js\release\promise.js:673:18)
INFO  Generating Baidu urls for last 1 posts
</code></pre>
<p>奇葩错误，在最上面的三个分隔符后面也要加空格，可能是语雀那边同步过来的文章问题</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://mozilla.github.io/nunjucks/cn/getting-started.html" target="_blank" rel="noopener">nunjucks 文档</a></li>
</ul>
]]></content>
      <categories>
        <category>Bug</category>
      </categories>
  </entry>
  <entry>
    <title>javaweb-8080端口被占用</title>
    <url>/blog/qi1md8/</url>
    <content><![CDATA[<h2 id="一、报错信息"><a href="#一、报错信息" class="headerlink" title="一、报错信息"></a>一、报错信息</h2><pre><code>localhost:8080 is already in use

Port 8080 required by Tomcat v8.0 Server at localhost is already in use. The server may already be running in another process, or a system process may be using the port. To start this server you will need to stop the other process or change the port number(s).

Error running Tomcat8: Address localhost:8080 is already in use
</code></pre><h2 id="一、分析并解决问题"><a href="#一、分析并解决问题" class="headerlink" title="一、分析并解决问题"></a>一、分析并解决问题</h2><blockquote>
<p>电脑中 8080 端口被占用，导致 web 项目不能运行</p>
</blockquote>
<blockquote>
<p>任务管理器关闭占用 8080 端口的程序</p>
</blockquote>
<h3 id="netstat-ano"><a href="#netstat-ano" class="headerlink" title="netstat -ano"></a>netstat -ano</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1602926284869-236a07ed-16de-4b45-9fb3-08aa10dd3df8.png#align=left&amp;display=inline&amp;height=600&amp;margin=%5Bobject%20Object%5D&amp;originHeight=600&amp;originWidth=1200&amp;size=0&amp;status=done&amp;style=none&amp;width=1200" alt></p>
<h3 id="tasklist"><a href="#tasklist" class="headerlink" title="tasklist"></a>tasklist</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1602926285001-7e1779f1-5c00-4f0d-ad38-20b653849c37.png#align=left&amp;display=inline&amp;height=221&amp;margin=%5Bobject%20Object%5D&amp;originHeight=221&amp;originWidth=1200&amp;size=0&amp;status=done&amp;style=none&amp;width=1200" alt><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1602926284877-544af23f-b422-49de-af28-86f9c7a37ce3.png#align=left&amp;display=inline&amp;height=183&amp;margin=%5Bobject%20Object%5D&amp;originHeight=183&amp;originWidth=1200&amp;size=0&amp;status=done&amp;style=none&amp;width=1200" alt></p>
<h3 id="任务管理器"><a href="#任务管理器" class="headerlink" title="任务管理器"></a>任务管理器</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1602926285182-6bfb20a5-33a4-4a6b-8969-eaae9b7c67e4.png#align=left&amp;display=inline&amp;height=550&amp;margin=%5Bobject%20Object%5D&amp;originHeight=550&amp;originWidth=834&amp;size=0&amp;status=done&amp;style=none&amp;width=834" alt></p>
]]></content>
      <categories>
        <category>Bug</category>
      </categories>
  </entry>
  <entry>
    <title>GitHub-CICD不同文件夹迁移</title>
    <url>/blog/qp5kuu/</url>
    <content><![CDATA[<h2 id="一、思路"><a href="#一、思路" class="headerlink" title="一、思路"></a>一、思路</h2><ul>
<li>仓库一：wztlink1013.github.io【master】</li>
<li>仓库二：test【gh-pages】</li>
</ul>
<p>将 test 仓库下 gh-pages 分支下的所有文件复制到文件夹 test，将 wztlink1013.github.io 仓库下 clone 到文件夹 wztlink1013.github.io 中，进入 wztlink1013.github.io 文件夹，然后通过命令将 test 文件夹复制到 wztlink1013 文件夹中，最后 push 到 wztlink1013.github.io 仓库中。</p>
<h2 id="二、编写脚本"><a href="#二、编写脚本" class="headerlink" title="二、编写脚本"></a>二、编写脚本</h2><pre><code class="bash">git config --global user.name &#39;wztlink1013&#39;
git config --global user.email &#39;2550374815@qq.com&#39;
git clone https://github.com/wztlink1013/test.git
git clone https://github.com/wztlink1013/wztlink1013.github.io.git
</code></pre>
<pre><code class="shell">cd wztlink1013.github.io
mkdir test
cd ..
xcopy .\test .\wztlink1013.github.io /e
</code></pre>
<pre><code class="bash">cd wztlink1013.github.io
git status
git add .
git commit -m &quot;add gh-pages files&quot;
git push &quot;https://${Github_Token}@github.com/wztlink1013/wztlink1013.github.io&quot;  master:master
</code></pre>
<h2 id="三、编写-GitHub-Actions"><a href="#三、编写-GitHub-Actions" class="headerlink" title="三、编写 GitHub Actions"></a>三、编写 GitHub Actions</h2><pre><code class="yaml">name: CI for wztlink1013.github.io

on: [push, watch]

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v2

      - name: 配置Git
        run: |
          git config --global user.name &#39;wztlink1013&#39; 
          git config --global user.email &#39;2550374815@qq.com&#39;
      - name: 在云端进行复制文件夹操作
        env:
          Github_Token: ${{ secrets.TOKEN_GITHUBAPI }}
        run: |
          git clone https://github.com/wztlink1013/visualization visualization
          git clone https://github.com/wztlink1013/wztlink1013.github.io .github_pages
          cd visualization
          rm -r .git
          rm -r .github
          cd ..
          cd .github_pages
          rm -r visualization
          cd ..
          mv visualization/ -f .github_pages/
          cd .github_pages
          git status
          git add .
          git commit -m &quot;add gh-pages files&quot;
          git push --force --quiet &quot;https://${Github_Token}@github.com/wztlink1013/wztlink1013.github.io&quot;  master:master
</code></pre>
]]></content>
      <categories>
        <category>Environment</category>
      </categories>
  </entry>
  <entry>
    <title>[转]java-找不到或无法加载主类</title>
    <url>/blog/qp81g3/</url>
    <content><![CDATA[<p><a href="https://www.cnblogs.com/wangxiaoha/p/6293340.html" target="_blank" rel="noopener">https://www.cnblogs.com/wangxiaoha/p/6293340.html</a></p>
<p><a href="https://bbs.csdn.net/topics/391862656?page=1" target="_blank" rel="noopener">https://bbs.csdn.net/topics/391862656?page=1</a></p>
<p><a href="https://blog.csdn.net/qinshijangshan/article/details/53048342?depth_1-utm_source=distribute.pc_relevant.none-task-blog-OPENSEARCH-1&amp;utm_source=distribute.pc_relevant.none-task-blog-OPENSEARCH-1" target="_blank" rel="noopener">https://blog.csdn.net/qinshijangshan/article/details/53048342?depth_1-utm_source=distribute.pc_relevant.none-task-blog-OPENSEARCH-1&amp;utm_source=distribute.pc_relevant.none-task-blog-OPENSEARCH-1</a></p>
<p><a href="https://blog.csdn.net/lanchunhui/article/details/76339252" target="_blank" rel="noopener">https://blog.csdn.net/lanchunhui/article/details/76339252</a></p>
<p><a href="https://blog.csdn.net/qq_37717853/article/details/78218606?depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1&amp;utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1" target="_blank" rel="noopener">eclipse 下的输入参数方式</a></p>
]]></content>
      <categories>
        <category>Bug</category>
      </categories>
  </entry>
  <entry>
    <title>重装系统</title>
    <url>/blog/qq1dno/</url>
    <content><![CDATA[<h2 id="一、关于重装"><a href="#一、关于重装" class="headerlink" title="一、关于重装"></a>一、关于重装</h2><h3 id="重装缘由"><a href="#重装缘由" class="headerlink" title="重装缘由"></a>重装缘由</h3><ul>
<li>电脑的空间太杂乱</li>
<li>环境配置混乱</li>
<li>网卡驱动出错<blockquote>
<p>总结几次重装步骤，为了今后出现类似情况，能够更快地重装电脑。</p>
</blockquote>
</li>
</ul>
<h3 id="重装好处"><a href="#重装好处" class="headerlink" title="重装好处"></a>重装好处</h3><p>电脑重装系统能解决大多数问题（对鄙人能解决 100%问题<del>//手动滑稽</del>），在此总结一下自己重装系统过程步骤以及遇到的问题。算了，我还是实实在在的滑稽一波吧~~~~<br><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/1484158/1607134929519-b05b7da1-a356-49e3-8048-d7c3707f509c.jpeg#align=left&amp;display=inline&amp;height=428&amp;margin=%5Bobject%20Object%5D&amp;name=KAPAI.jpg&amp;originHeight=640&amp;originWidth=437&amp;size=37555&amp;status=done&amp;style=shadow&amp;width=292" alt="KAPAI.jpg"></p>
<h2 id="二、重装系统-SOP"><a href="#二、重装系统-SOP" class="headerlink" title="二、重装系统 SOP"></a>二、重装系统 SOP</h2><h3 id="1-制作启动盘"><a href="#1-制作启动盘" class="headerlink" title="1. 制作启动盘"></a>1. 制作启动盘</h3><ul>
<li><a href="https://msdn.itellyou.cn/" target="_blank" rel="noopener">法一：MSDN 下载</a><br>① 迅雷下载  ② 网盘下载</li>
</ul>
<p>下载完镜像之后，再用 ULtralSO/ <a href="https://rufus.ie/zh_CN.html" target="_blank" rel="noopener">rufus</a> 软件刻录在 U 盘（大于 4G 的 U 盘）</p>
<ul>
<li><p><a href="https://www.microsoft.com/zh-cn/software-download/windows10" target="_blank" rel="noopener">法二：微软官方下载</a><br>网速不能太慢，WiFi 较快的可以用这个，不过下载的电脑原装 Windows 版本，不追求专业版本的 Windows，最好还是下这个吧。</p>
<blockquote>
<p>坑 1：如果下载的镜像大于 4G 左右，ULtralSO 不能刻录。<br>亮 2：官方下载，可以匹配自己电脑本来的版本；可以直接刻录在 U 盘，唯一不足应该就是网速问题。<br>坑 3：U 盘如果“身患重伤”，下个相关优化 U 盘软件处理一下</p>
</blockquote>
</li>
<li><p>（更新）<a href="http://www.kqidong.com/index.html" target="_blank" rel="noopener">法三：快启动</a>先用法一下好镜像。</p>
</li>
</ul>
<h3 id="2-正式重装"><a href="#2-正式重装" class="headerlink" title="2. 正式重装"></a>2. 正式重装</h3><ul>
<li>进入 bios 界面<br>开机刚要出现<code>HP</code>字样，一直点<code>_esc_</code>键，然后再设置开机进入启动盘</li>
<li>Next Wait 即可<br>格式化 C 盘 → 安装 → 等候 → 登录微软账号…</li>
</ul>
<h3 id="3-磁盘管理"><a href="#3-磁盘管理" class="headerlink" title="3. 磁盘管理"></a>3. 磁盘管理</h3><p><strong>磁盘管理器：根据需求将磁盘分区</strong><br>**</p>
<ul>
<li>相关问题 1：给 C 盘扩展时不能扩展？<blockquote>
<p>磁盘只有相邻卷才能扩展卷：解决办法就是把右边的磁盘删除（状态为未分配空间），然后用左边的磁盘合并之（使用扩展卷）</p>
</blockquote>
</li>
</ul>
<h3 id="4-关于破解"><a href="#4-关于破解" class="headerlink" title="4. 关于破解"></a>4. 关于破解</h3><p>首先有条件购买支持正版，支持同行，其次下载自己笔记本出厂 Windows 版本，则不需要激活码，自带</p>
<p>最后破解之：<code>hwid.kms38.gen.mk6</code>软件</p>
<h2 id="三、电脑备份相关工作"><a href="#三、电脑备份相关工作" class="headerlink" title="三、电脑备份相关工作"></a>三、电脑备份相关工作</h2><h3 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h3><ul>
<li><del>谷歌浏览器</del></li>
<li>Edge(最新)浏览器：<a href="https://www.microsoftedgeinsider.com/en-us/download" target="_blank" rel="noopener">下载地址（DEV 版本会消去插件开发者禁用状态）</a></li>
<li><del>谷歌访问助手插件 让谷歌先连上网 然后构建 SSR/</del> <strong>ByWave</strong></li>
<li>登录账号同步书签插件等设置（<del>谷歌需要梯子，</del>Edge 不需要）</li>
<li><del>下载<a href="http://www.carrotchou.blog/59.html" target="_blank" rel="noopener">IDM 下载器</a></del></li>
</ul>
<h3 id="文件备份及恢复"><a href="#文件备份及恢复" class="headerlink" title="文件备份及恢复"></a>文件备份及恢复</h3><ul>
<li>网盘常用文件夹备份（图片文件夹+个人信息文件夹）</li>
<li>GitHub 同步开发项目代码</li>
</ul>
<h3 id="开发环境的搭建"><a href="#开发环境的搭建" class="headerlink" title="开发环境的搭建"></a>开发环境的搭建</h3><ul>
<li>Git：配置全局用户 <del>（非个人电脑配置多用户环境</del>）</li>
<li>Nodejs</li>
<li>Unix：<del>VMware15，</del>Windows 子系统</li>
<li>Java：jdkjdk1.8.0_181、jrejdk1.8.0_181</li>
<li>MySQL</li>
</ul>
<h3 id="通用软件"><a href="#通用软件" class="headerlink" title="通用软件"></a>通用软件</h3><ul>
<li>百度网盘，<del>Dropbox，</del>迅雷</li>
<li>Bandizip</li>
<li>PDF：Adobe Acrobat DC <del>/福昕阅读器</del></li>
<li><del>有道翻译</del></li>
<li>Office2019（或者直接重装最新版 Win10 操作系统） <del>(已经集成 Onenote2016)，再另外下载 onenote 插件</del></li>
<li>Potplayer 播放器</li>
</ul>
<h3 id="社交软件"><a href="#社交软件" class="headerlink" title="社交软件"></a>社交软件</h3><p>QQ、微信、网易邮箱大师、网易云、酷狗<del>、Telegram</del></p>
<h3 id="IDE"><a href="#IDE" class="headerlink" title="IDE"></a>IDE</h3><ul>
<li>C&amp;C++：<a href="https://www.wztlink1013.com/blog/pm7mpk/">VScode（轻量）</a><del>、Clion、Codeblocks(次选)、VS2019(PC 空间大则优选)、VS2013</del></li>
<li>Python：Anaconda、Pycharm(<del>配置 nltk、tensorflow 等</del>)(<del>关于破解或</del> <strong>学生用户登录</strong>)</li>
<li>Java/JavaWeb：jdk、IDEA/Eclipse(配置 Tomcat)</li>
<li>Web：<a href="https://www.wztlink1013.com/blog/pm7mpk/">VScode</a> <del>/webstorm</del></li>
<li>DataBase：<a href="https://www.microsoft.com/zh-cn/download/confirmation.aspx?id=30438" target="_blank" rel="noopener">SQL Server 2008</a> 和 <a href="https://zhuanlan.zhihu.com/p/65630194" target="_blank" rel="noopener">安装教程</a> 、 Navicat Premium 12（MySQL）</li>
<li>Android：Android Studio、HBuilder X、微信开发者工具</li>
<li><del>OS：CPU Simulator</del></li>
<li><del>Matlab</del></li>
<li><del>研究-CAJViewer 7.3</del></li>
<li><del>研究-AxMath</del></li>
<li><del>研究-AxGlyph</del></li>
<li><a href="https://authy.com/download/" target="_blank" rel="noopener">Authy Desktop（二重验证）</a></li>
</ul>
<h3 id="后期制作"><a href="#后期制作" class="headerlink" title="后期制作"></a>后期制作</h3><p>Ps、Pr、Ae <del>、An、Au、EV 录频、Format factory 格式转换工厂</del></p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul>
<li><a href="https://www.yuque.com/install/desktop" target="_blank" rel="noopener">语雀</a></li>
<li><a href="https://github.com/Molunerfinn/PicGo" target="_blank" rel="noopener">PicGo</a> （全局代理下载）</li>
<li>Snipaste-2.3-64 位（网盘）</li>
<li><del>阿里云的 oss-browser</del></li>
<li><del>HexoClient</del></li>
<li><del>火萤桌面视频</del></li>
<li><del>Rainmeter</del></li>
</ul>
]]></content>
      <categories>
        <category>Environment</category>
      </categories>
  </entry>
  <entry>
    <title>MATLAB-概述</title>
    <url>/blog/rfeess/</url>
    <content><![CDATA[<h2 id="MATLAB-概述"><a href="#MATLAB-概述" class="headerlink" title="MATLAB 概述"></a>MATLAB 概述</h2><p>MATLAB(矩阵实验室)是数字计算，可视化和编程的第四代高级编程语言和交互式环境。MATLAB 是由 MathWorks 开发的。</p>
<p>它允许矩阵操纵，绘制功能和数据; 实现算法; 创建用户界面; 与其他语言编写的程序(包括 C 语言，C++，Java 和 FORTRAN)进行交互; 分析数据; 开发算法; 并创建模型和应用程序。</p>
<p>它有许多内置命令和数学函数，可以帮助您进行数学计算，生成图形和执行数值方法。</p>
<h2 id="MATLAB-计算数学"><a href="#MATLAB-计算数学" class="headerlink" title="MATLAB 计算数学"></a>MATLAB 计算数学</h2><p>MATLAB 用于计算数学的各个方面，以下是最常用的常用数学计算方法 -</p>
<ul>
<li>处理矩阵和数组</li>
<li>2D 和 3D 绘图和图形</li>
<li>线性代数</li>
<li>代数方程</li>
<li>非线性函数</li>
<li>统计</li>
<li>数据分析</li>
<li>微积分和微分方程</li>
<li>数值计算</li>
<li>积分</li>
<li>变换</li>
<li>曲线拟合</li>
<li>各种其他特殊功能</li>
</ul>
<h2 id="MATLAB-特点"><a href="#MATLAB-特点" class="headerlink" title="MATLAB 特点"></a>MATLAB 特点</h2><p>以下是 MATLAB 的基本特性 -</p>
<ul>
<li>它是数字计算，可视化和应用程序开发的高级语言。</li>
<li>它还为迭代探索，设计和解决问题提供了一个交互式环境。</li>
<li>它为线性代数，统计学，傅里叶分析，滤波，优化，数值积分和求解常微分方程提供了广泛的数学函数库。</li>
<li>它提供内置的图形，用于可视化数据和工具，用于创建自定义绘图。</li>
<li>MATLAB 编程接口提供了开发工具，以提高代码质量的可维护性并最大限度提高性能。</li>
<li>它提供使用自定义图形界面构建应用程序的工具。</li>
<li>它提供了基于 MATLAB 的算法与外部应用程序和语言(如 C 语言，Java，.NET 和 Microsoft Excel)集成的功能。</li>
</ul>
<h2 id="MATLAB-使用"><a href="#MATLAB-使用" class="headerlink" title="MATLAB 使用"></a>MATLAB 使用</h2><p>MATLAB 广泛应用于物理，化学，数学和所有工程流领域的科学与工程计算工具。 它用于一系列应用，包括</p>
<ul>
<li>信号处理和通信</li>
<li>图像和视频处理</li>
<li>控制系统</li>
<li>测试和测量</li>
<li>计算财务</li>
<li>计算生物学</li>
</ul>
]]></content>
      <categories>
        <category>Language</category>
      </categories>
  </entry>
  <entry>
    <title>JAVA-常用类</title>
    <url>/blog/rnsz9o/</url>
    <content><![CDATA[<h2 id="java-util-Date"><a href="#java-util-Date" class="headerlink" title="java.util.Date"></a>java.util.Date</h2><pre><code class="java">java.util.Date date = new java.util.Date();
System.out.println(date.toString());
</code></pre>
<pre><code>Sun Mar 09 13:50:19 EST 2020
</code></pre><h2 id="java-util-Random"><a href="#java-util-Random" class="headerlink" title="java.util.Random"></a>java.util.Random</h2><blockquote>
<p>Math.Random()：Math 类里面的随机数函数，范围是 0.0 到 0.1</p>
</blockquote>
<blockquote>
<p>java.util.Random</p>
</blockquote>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1600085762621-35c72adc-6c6e-4ab2-ac8b-d76d50e570e5.png#align=left&amp;display=inline&amp;height=176&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=352&amp;originWidth=899&amp;size=45653&amp;status=done&amp;style=shadow&amp;width=449.5" alt="image.png"></p>
<h2 id="javafx-geometry-Point2D"><a href="#javafx-geometry-Point2D" class="headerlink" title="javafx.geometry.Point2D"></a>javafx.geometry.Point2D</h2><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1600086091697-6fa8f4e4-137d-490a-8fe0-3546693a1f86.png#align=left&amp;display=inline&amp;height=103&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=206&amp;originWidth=960&amp;size=115357&amp;status=done&amp;style=shadow&amp;width=480" alt="image.png"></p>
<pre><code class="java">import java.util.Scanner;
import javafx.geometry.Point2D;
public class TestPoint2D {
public static void main(String[] args){

    Scanner input= new Scanner(System.in);
    System.out.println(&quot;Enter point1&#39;s x-,y-coordinates:&quot;);
    double x1=input.nextDouble();
    double y1=input.nextDouble();
    System.out.println(&quot;Enter point2&#39;s x-,y-coordinates:&quot;);
    double x2=input.nextDouble();
    double y2=input.nextDouble();
    Point2D p1 =new Point2D(x1,y1);
    Point2D p2 =new Point2D(x2,y2);
    System.out.println(&quot;p1 is&quot;+p1.toString());
    System.out.println(&quot;p2 is&quot;+p2.toString());
    System.out.println(&quot;distance is&quot;+p1.distance(p2));
    }
}
</code></pre>
<pre><code>Enter point1&#39;s x-,y-coordinates:
1 2
Enter point2&#39;s x-,y-coordinates:
3 4
p1 isPoint2D [x = 1.0, y = 2.0]
p2 isPoint2D [x = 3.0, y = 4.0]
distance is2.8284271247461903
</code></pre><h2 id="String-和-StringBuilder-和-StringBuffer"><a href="#String-和-StringBuilder-和-StringBuffer" class="headerlink" title="String 和 StringBuilder 和 StringBuffer"></a>String 和 StringBuilder 和 StringBuffer</h2><h2 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h2><h3 id="toString-方法"><a href="#toString-方法" class="headerlink" title="toString()方法"></a>toString()方法</h3><h3 id="equals-方法"><a href="#equals-方法" class="headerlink" title="equals()方法"></a>equals()方法</h3><blockquote>
<p>默认实现的方法</p>
</blockquote>
<pre><code class="java">public boolean equals(Object obj) {
    return (this == obj);
}
</code></pre>
<blockquote>
<p>重写例子</p>
</blockquote>
<pre><code class="java">public boolean equals(Object obj) {
    if (o instanceof Circe)
        return radius == ((Circle)o).radius;
    else
        return this == o;
}
</code></pre>
]]></content>
      <categories>
        <category>Language</category>
      </categories>
  </entry>
  <entry>
    <title>Python-qrcode和myqr花式二维码</title>
    <url>/blog/ro3p67/</url>
    <content><![CDATA[<h2 id="一、官方文档"><a href="#一、官方文档" class="headerlink" title="一、官方文档"></a>一、官方文档</h2><p><a href="https://pypi.org/project/qrcode/" target="_blank" rel="noopener">https://pypi.org/project/qrcode/</a></p>
<p><a href="https://pypi.org/project/MyQR/" target="_blank" rel="noopener">https://pypi.org/project/MyQR/</a></p>
<h2 id="二、下载包"><a href="#二、下载包" class="headerlink" title="二、下载包"></a>二、下载包</h2><p>pip install qrcode  #方法多，体量小</p>
<p>pip install myqr    #操作简单，功能强大</p>
<h2 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h2><h3 id="qrcode-一行字二维码"><a href="#qrcode-一行字二维码" class="headerlink" title="qrcode 一行字二维码"></a>qrcode 一行字二维码</h3><pre><code class="python">import qrcode

qrcode.make(&quot;不睡觉干嘛呢&quot;).get_image().show()   #设置URL必须添加http://
</code></pre>
<h3 id="qrcode-一行字二维码-1"><a href="#qrcode-一行字二维码-1" class="headerlink" title="qrcode 一行字二维码"></a>qrcode 一行字二维码</h3><pre><code class="python">import qrcode

text = input(&quot;输入文字或URL：&quot;)
img =qrcode.make(text)
img.save()                            #保存图片至本地目录，可以设定路径
img.show()
</code></pre>
<h3 id="qrcode-生成-logo-二维码"><a href="#qrcode-生成-logo-二维码" class="headerlink" title="qrcode 生成 logo 二维码"></a>qrcode 生成 logo 二维码</h3><pre><code class="python">from PIL import Image
import qrcode,os

def create_qrcode(url,qrcodename):
    qr = qrcode.QRCode(
        version=1,  # 设置容错率为最高
        error_correction=qrcode.ERROR_CORRECT_H, # 用于控制二维码的错误纠正程度
        box_size=8, # 控制二维码中每个格子的像素数，默认为10
        border=1, # 二维码四周留白，包含的格子数，默认为4
        #image_factory=None,  保存在模块根目录的image文件夹下
        #mask_pattern=None
    )

    qr.add_data(url) # QRCode.add_data(data)函数添加数据
    qr.make(fit=True)  # QRCode.make(fit=True)函数生成图片

    img = qr.make_image()
    img = img.convert(&quot;RGBA&quot;) # 二维码设为彩色
    logo = Image.open(&#39;xx.jpg&#39;) # 传gif生成的二维码也是没有动态效果的

    w , h = img.size
    logo_w , logo_h = logo.size
    factor = 4   # 默认logo最大设为图片的四分之一
    s_w = int(w / factor)
    s_h = int(h / factor)
    if logo_w &gt; s_w or logo_h &gt; s_h:
        logo_w = s_w
        logo_h = s_h

    logo = logo.resize((logo_w, logo_h), Image.ANTIALIAS)
    l_w = int((w - logo_w) / 2)
    l_h = int((h - logo_h) / 2)
    logo = logo.convert(&quot;RGBA&quot;)
    img.paste(logo, (l_w, l_h), logo)
    img.show()
    img.save(os.getcwd()+&#39;/&#39; + qrcodename + &#39;.png&#39;, quality=100)
</code></pre>
<h3 id="myqr-动态二维码"><a href="#myqr-动态二维码" class="headerlink" title="myqr 动态二维码"></a>myqr 动态二维码</h3><pre><code>相关参数：
    words：二维码内容，链接或者句子
    version：二维码大小，范围为[1,40]
    level：二维码纠错级别，范围为{L,M,Q,H}，H为最高级，默认。
    picture：自定义二维码背景图，支持格式为 .jpg，.png，.bmp，.gif，默认为黑白色
    colorized：二维码背景颜色，默认为 False，即黑白色
    contrast：对比度，值越高对比度越高，默认为 1.0
    brightness：亮度，值越高亮度越高，默认为 1.0，值常和对比度相同
    save_name：二维码名称，默认为 qrcode.png
    save_dir：二维码路径，默认为程序工作路径
</code></pre><pre><code class="python"># 调用库
from MyQR import myqr

# 函数部分
myqr.run(
    # 网址
    words=&#39;https://wztlink1013.com&#39;,
    # 控制边长，范围是1到40，数字越大边长越大，默认边长是取决于你输入的信息的长度和使用的纠错等级
    version=5,
    # 控制纠错水平，范围是L、M、Q、H，从左到右依次升高
    level=&#39;H&#39;,
    # 将QR二维码图像与一张同目录下的图片相结合，此处设置该图片，可以是gif
    picture=&#39;./input/girl.gif&#39;,
    # 默认是黑白(False)，可以选择彩色(True)
    colorized=True,
    # 调节图片的对比度，1.0 表示原始图片，更小的值表示更低对比度，更大反之。默认为1.0。
    contrast=1.0,
    # 调节图片的亮度，用法与contrast相同
    brightness=1.0,
    # 输出文件名，格式可以是jpg，png，bmp，gif
    save_name=&#39;girl.gif&#39;,
    save_dir=&#39;./output&#39;)
</code></pre>
]]></content>
      <categories>
        <category>Language</category>
      </categories>
      <tags>
        <tag>qrcode</tag>
        <tag>myqr</tag>
      </tags>
  </entry>
  <entry>
    <title>P729. 我的日程安排表 I</title>
    <url>/blog/rwfqhp/</url>
    <content><![CDATA[<h3 id="729-我的日程安排表-I"><a href="#729-我的日程安排表-I" class="headerlink" title="729. 我的日程安排表 I"></a>729. 我的日程安排表 I</h3><pre><code class="java">class MyCalendar {

    int [] month = new int[30];
    public MyCalendar() {


    }

    public boolean book(int start, int end) {
        boolean p = true;


        if (month[start] == 1) {
            p = false;
        }

        else {
            while (p) {
                int i = start;
                month[i] = 1;
                if (month[i+1] == 1) {
                    return p = false;
                }
                i = i+1;
            }
        }
        return p;
    }

}

</code></pre>
]]></content>
      <categories>
        <category>DataStructure</category>
      </categories>
  </entry>
  <entry>
    <title>软件工程知识小结</title>
    <url>/blog/sc6tzq/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>软件工程生命周期</p>
</blockquote>
<ol>
<li>问题定义</li>
<li>可行性研究</li>
<li>需求分析</li>
<li>总体设计</li>
<li>详细设计</li>
<li>编码和单元测试</li>
<li>综合测试</li>
<li>软件维护</li>
</ol>
<h2 id="可行性研究"><a href="#可行性研究" class="headerlink" title="可行性研究"></a>可行性研究</h2><blockquote>
<p>在了解问题定义之后，将其模型抽离出来，然后对其进行可行性分析，探索若干种解法，对每种解法仔细研究其可行性，从下面几种方面来考虑</p>
</blockquote>
<ol>
<li>技术可行性：能否用现又技术实现？</li>
<li>经济可行性：软件带来的经济效益能否大于软件的开发成本？</li>
<li>操作可行性：在用户组织之间是否具有操作可行性？</li>
</ol>
<p>必要时还有从法律和社会效益来研究其可行性。</p>
<blockquote>
<p>系统流程图<br>数据流图</p>
</blockquote>
<blockquote>
<p>成本/效益分析</p>
</blockquote>
<p>成本估计的几种方法</p>
<ul>
<li>代码行技术：根据每行代码的平均成本乘以行数就是大概的成本</li>
<li>任务分解技术：将整个声明周期划分不同阶段，估计每个不同阶段所花费的成本，一般都是各阶段的人数诚意平均工资再加这般</li>
<li>自动估计成本：根据程序来估计，一般要用到大量数据，才能保证这个估计有效（大数据时代应该很吃香，可以利用所搜集的大量数据来进行建模）</li>
</ul>
<p>成本/效益分析的方法</p>
<ul>
<li>货币的时间价值：这里面有年利率的概念，就是过 n 年之后，你手中的钱在 n 年之后会提升</li>
</ul>
<p>F=P（1+n）^n （P 元钱在 n 年后的价值）</p>
<ul>
<li>投资回收期：你所赚的钱等于你所投资的资金所花费的时间越短越好</li>
<li>纯收入：整个生命周期内，赚的钱减去你投资的钱</li>
</ul>
<h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><blockquote>
<p>与用户沟通获取需求的方法</p>
</blockquote>
<ul>
<li>访谈</li>
<li>面向数据流自顶向下求精</li>
<li>简易的应用规格说明技术</li>
<li>快速建立软件模型</li>
</ul>
<blockquote>
<p>根据结构化分析准则，需求分析过程应该建立三种模型，它们分别是？以及他们所用到的工具？</p>
</blockquote>
<ul>
<li>数据模型——E-R 图：就是数据库里面学到的实体-联系图</li>
<li>功能模型——数据流图：描述数据在系统中的转换的逻辑过程</li>
<li>行为模型——状态转换图：作为外部事件结果的系统行为</li>
</ul>
<blockquote>
<p>其他的工具还有</p>
</blockquote>
<ul>
<li>层次方框图（树形结构）</li>
<li>Warnier 图{大括号包裹）</li>
<li>IPO 图（方框-箭头；表格形式）</li>
</ul>
<h2 id="形式化说明技术"><a href="#形式化说明技术" class="headerlink" title="形式化说明技术"></a>形式化说明技术</h2><blockquote>
<p>软件工程所使用的方法可划分为下面三种</p>
</blockquote>
<ul>
<li>非形式化方法：用自然语言描述就是典型的非形式化方法</li>
<li>半形式化方法：利用 E-R 图描述就是半形式化方法</li>
<li>形式化方法：用到数学的技术，也就是说，如果一种方法用到坚实的数学基础，那么他就是形式化方法</li>
</ul>
<h2 id="总体设计"><a href="#总体设计" class="headerlink" title="总体设计"></a>总体设计</h2><blockquote>
<p>总体设计又称之为概要设计、初步设计</p>
</blockquote>
<blockquote>
<p>由哪两阶段组成呢？</p>
</blockquote>
<ul>
<li>系统设计阶段：确定系统的具体实现方案</li>
<li>结构设计阶段：确定软件结构</li>
</ul>
<blockquote>
<p>设计原理</p>
</blockquote>
<p><strong>模块</strong>是由边界元素限定的相邻程序元素（数据说明，可执行的语句）的序列，而且有一个总体标识符代表它</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1608815946283-167d2edb-f25b-45de-ade4-6041bddf45c2.png#align=left&amp;display=inline&amp;height=258&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=516&amp;originWidth=694&amp;size=141087&amp;status=done&amp;style=shadow&amp;width=347" alt="image.png"></p>
<p>模块之间的<strong>独立程度</strong>有两个标准来度量，分别是：</p>
<p>耦合：度量<strong>模块间</strong>的互相依赖程度</p>
<p>内聚：度量<strong>模块内部元素间</strong>的结合程度</p>
<p><strong>尽量使用数据耦合，少用控制耦合和特征耦合，限制公共环境耦合的范围，完全不用内容耦合</strong><br>**<br>7 种内聚优劣评分：功能内聚（10 分）偶然内聚（0 分）</p>
<blockquote>
<p>描绘软件结构的图形工具</p>
</blockquote>
<ul>
<li>层次图（树状）和 HIPO 图（带编号的层次图）</li>
<li>结构图</li>
</ul>
<blockquote>
<p>面向数据流的设计方法</p>
</blockquote>
<p>概念：面向数据流的设计方法就是把信息流映射成软件结构，同时信息流的结构决定了映射的方法</p>
<ul>
<li>变换流</li>
<li>事务流</li>
<li>设计过程</li>
</ul>
<h2 id="详细设计"><a href="#详细设计" class="headerlink" title="详细设计"></a>详细设计</h2><blockquote>
<p>结构程序设计</p>
</blockquote>
<p>只用 3 种控制结构就能实现任何单入口单出口的程序，这三种结构分别是顺序结构、选择结构、循环结构</p>
<blockquote>
<p>人机界面设计的设计问题有：</p>
</blockquote>
<ul>
<li>系统响应时间</li>
<li>用户帮助实施</li>
<li>出错信息处理</li>
<li>命令交互</li>
</ul>
<blockquote>
<p>人机界面设计的设计指南：</p>
</blockquote>
<ul>
<li>一般交互指南</li>
<li>信息显示指南</li>
<li>数据输入指南</li>
</ul>
<blockquote>
<p>过程设计的工具【重要】</p>
</blockquote>
<ol>
<li>程序流程图</li>
<li>盒图（N-S 图）</li>
<li>PAD 图</li>
<li>判定表</li>
<li>判定树</li>
<li>过程设计语言</li>
</ol>
<blockquote>
<p>面向数据结构的设计方法</p>
</blockquote>
<p><strong>两个最著名的方法为：Jackson 方法和 Warnier 方法</strong><br>**</p>
<blockquote>
<p>Jackson 方法</p>
</blockquote>
<p>只有顺序、选择、重复三种结构</p>
<p>要会用伪代码表示</p>
<blockquote>
<p>程序复杂程度的定量度量有 McCabe 方法和 Halstead 方法，只介绍前者</p>
</blockquote>
<ol>
<li>流图（给出伪代码画流图）</li>
<li>计算环形复杂度的方法</li>
</ol>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h2 id="维护"><a href="#维护" class="headerlink" title="维护"></a>维护</h2>]]></content>
      <categories>
        <category>软件工程</category>
      </categories>
  </entry>
  <entry>
    <title>P876. 链表的中间结点</title>
    <url>/blog/serpsb/</url>
    <content><![CDATA[<pre><code class="java">/**
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
</code></pre>
<h2 id="876-链表的中间结点"><a href="#876-链表的中间结点" class="headerlink" title="876. 链表的中间结点"></a>876. 链表的中间结点</h2><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1603195941092-8cd11b96-c174-425e-ab68-a7015110092e.png#align=left&amp;display=inline&amp;height=208&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=415&amp;originWidth=717&amp;size=49665&amp;status=done&amp;style=shadow&amp;width=358.5" alt="image.png"></p>
<h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h3><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><pre><code class="java">class Solution {
    public ListNode middleNode(ListNode head) {
        if (head.next == null) return head;
        if (head.next.next == null) return head.next;

        ListNode slow = head.next;
        ListNode fast = head.next.next;
        while (fast != null &amp;&amp; fast.next != null) {
            slow = slow.next;
            fast = fast.next.next;
            if (fast == null) return slow;
        }
        return slow;
    }
}
</code></pre>
]]></content>
      <categories>
        <category>DataStructure</category>
      </categories>
  </entry>
  <entry>
    <title>P486. 预测赢家</title>
    <url>/blog/srvbwz/</url>
    <content><![CDATA[<h3 id="486-预测赢家"><a href="#486-预测赢家" class="headerlink" title="486. 预测赢家"></a>486. 预测赢家</h3><pre><code class="java">class Solution {
    public boolean PredictTheWinner(int[] nums) {
        return total(nums, 0, nums.length - 1, 1) &gt;= 0;
    }

    public int total(int[] nums, int start, int end, int turn) {
        if (start == end) {
            return nums[start] * turn;
        }
        int scoreStart = nums[start] * turn + total(nums, start + 1, end, -turn);
        int scoreEnd = nums[end] * turn + total(nums, start, end - 1, -turn);
        return Math.max(scoreStart * turn, scoreEnd * turn) * turn;
//        if(turn == 1){
//            return Math.max(scoreStart ,scoreEnd );
//        }else{
//            return Math.min(scoreStart ,scoreEnd );
//        }
    }
}
</code></pre>
]]></content>
      <categories>
        <category>DataStructure</category>
      </categories>
  </entry>
  <entry>
    <title>表查询优化——索引</title>
    <url>/blog/tr2ahg/</url>
    <content><![CDATA[<h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><p>索引能提高查询效率，但是查询效率和修改效率一直是一个矛盾。</p>
<h2 id="普通索引"><a href="#普通索引" class="headerlink" title="普通索引"></a>普通索引</h2><pre><code class="mysql">-- 单独创建，colname为列名
CREATE INDEX indexname ON tablename(colname(length));
-- 也可以在修改表的时候创建
ALTER TABLE table_name ADD INDEX [index_name] (column_list)
-- 创建表的时候指定
CREATE TABLE mytable(
    ID INT NOT NULL,
    username VARCHAR(16) NOT NULL,
    INDEX [indexname] (username(length)
);
</code></pre>
<h2 id="唯一索引"><a href="#唯一索引" class="headerlink" title="唯一索引"></a>唯一索引</h2><p>索引列必须唯一，但可以为 NULL，不能有多个 NULL。</p>
<pre><code class="mysql">-- 单独创建
CREATE UNIQUE INDEX indexname ON tablename(colname(length));
-- 也可以在修改表的时候创建
ALTER TABLE table_name ADD UNIQUE [index_name] (column_list)
-- 创建表的时候指定
CREATE TABLE mytable(
    ID INT NOT NULL,
    username VARCHAR(16) NOT NULL,
    UNIQUE INDEX [indexname] (username(length)
);
</code></pre>
<h2 id="主键索引"><a href="#主键索引" class="headerlink" title="主键索引"></a>主键索引</h2><p>就是之前所说过的主键。不能使用<code>CREATE</code>语句单独创建。</p>
<pre><code class="mysql">-- 可以在修改表的时候创建
ALTER TABLE tablename ADD PRIMARY KEY (column_list);
-- 在表级定义主键
CREATE TABLE mytable(
    ID INT NOT NULL,
    username VARCHAR(16) NOT NULL,
    PRIMARY KEY(ID)
);
-- 在列级定义主键
CREATE TABLE mytable(
    ID INT NOT NULL PRIMARY KEY,
    username VARCHAR(16) NOT NULL
);
</code></pre>
<p>由上可知，有两种主键定义方法。但是两者不尽相同。在列级定义主键<strong>这样是无法指定多个字段做主键的</strong>，这中情况下只能在表级定义主键</p>
<h3 id="索引组织表"><a href="#索引组织表" class="headerlink" title="索引组织表"></a>索引组织表</h3><p>InnoDB 引擎中，表都是根据主键顺序组织存放的。称之为<code>索引组织表</code>。<br>在没有显示地声明主键的情况下，InnoDB 按照如下方式选择或创建主键：</p>
<ul>
<li>如果存在<code>非空</code>的<code>唯一约束</code>，则将该列视为主键</li>
<li>如果不存在，则自动创建一个 6 字节大小的指针</li>
</ul>
<p>如果表中有多个非空的唯一索引，那么 InnoDB 选择第一个定义的非空索引。这里依据的顺序是索引定义的顺序，而不是建表时列的顺序。</p>
<h3 id="rowid"><a href="#rowid" class="headerlink" title="_rowid"></a>_rowid</h3><p>在主键为单个列的时候，我们可以使用_rowid 来查看主键的值。</p>
<pre><code class="mysql">-- 比如：
SELECT *,_rowid FROM test;
</code></pre>
<h2 id="全文索引"><a href="#全文索引" class="headerlink" title="全文索引"></a>全文索引</h2><p>只有 InnodB 引擎支持</p>
]]></content>
      <categories>
        <category>Language</category>
      </categories>
  </entry>
  <entry>
    <title>python-路径和nltk</title>
    <url>/blog/uatg7m/</url>
    <content><![CDATA[<h2 id="一、路径相关"><a href="#一、路径相关" class="headerlink" title="一、路径相关"></a>一、路径相关</h2><h3 id="路径相关报错信息"><a href="#路径相关报错信息" class="headerlink" title="路径相关报错信息"></a>路径相关报错信息</h3><pre><code class="python">IOError: [Errno 2] No such file or directory
</code></pre>
<pre><code class="python">pandas.read_csv() 报错 OSError: Initializing from file failed
</code></pre>
<pre><code class="python">(unicode error) &#39;unicodeescape&#39; codec can&#39;t decode bytes in position 2-3: truncated \UXXXXXXXX escape [duplicate]
</code></pre>
<pre><code class="python">File b&#39;train.csv&#39; does not exist even though file exist
</code></pre>
<h3 id="分析与解决问题"><a href="#分析与解决问题" class="headerlink" title="分析与解决问题"></a>分析与解决问题</h3><p>编写 python 代码过程中，出现了类似这种一系列路径相关的错误，原因是，自己更改了<strong>相关文件夹/文件在电脑中的位置</strong>，解决办法就新建一个项目建一个全新路径或者修改现有路径</p>
<ul>
<li><code>\</code>绝对路径 会报错（转义字符）处理：① 双引号前面加一个 r②<code>\</code>换成<code>\\</code>（硬盘代号后面的第一个）</li>
<li><code>./</code>相对路径</li>
</ul>
<blockquote>
<p>三种解决方式<br><code>r&quot;C:\Users\YJG\Desktop\pi_digits.txt&quot;</code> &gt; <code>&quot;C:\\Users\\YJG\\Desktop\\pi_digits.txt&quot;</code> &gt; <code>&quot;C:/Users/YJG/Desktop/pi_digits.txt&quot;</code></p>
</blockquote>
<h3 id="PS：路径含中文"><a href="#PS：路径含中文" class="headerlink" title="PS：路径含中文"></a>PS：路径含中文</h3><p>假如路径、文件名都完整，还是报错的原因是这个参数中有中文，即使 Python3 已经支持中文，但是调用 pandas 的 read_csv()方法时，默认使用 C engine 作为 parser engine，而当文件名中含有中文的时候，用 C engine 在部分情况下就会出错。所以在调用 read_csv()方法时指定 engine 为 Python 就可以解决问题。根治：将路径编程全英文，这是必要素养习惯！</p>
<p><code>da4=pd.read_csv(xxxxxxxxxx,engine=&#39;python&#39;)</code></p>
<h3 id="PS：utf-8"><a href="#PS：utf-8" class="headerlink" title="PS：utf-8"></a>PS：utf-8</h3><pre><code>UnicodeDecodeError：: &#39;utf-8&#39; codec can&#39;t decode byte 0xc8 in position 0: invalid contin
</code></pre><blockquote>
<p>解决办法：<code>data_1 = pd.read_csv(data1, encoding = &#39;gb2312&#39;)</code>或者 gb2312 换成 gbk<br>参考：<a href="https://blog.csdn.net/qq_18888869/article/details/82625343" target="_blank" rel="noopener">https://blog.csdn.net/qq_18888869/article/details/82625343</a></p>
</blockquote>
<h2 id="二、nltk-相关"><a href="#二、nltk-相关" class="headerlink" title="二、nltk 相关"></a>二、nltk 相关</h2><h3 id="nltk-下载报错信息"><a href="#nltk-下载报错信息" class="headerlink" title="nltk 下载报错信息"></a>nltk 下载报错信息</h3><pre><code>bug:[WinError 10054] 远程主机强迫关闭了一个现有的连接
</code></pre><h3 id="分析与解决问题-1"><a href="#分析与解决问题-1" class="headerlink" title="分析与解决问题"></a>分析与解决问题</h3><p>原因：模型权重参数文件（.h5）较大，下载出现中断，下载失败</p>
<blockquote>
<ul>
<li>解决办法：手动下载模型，放到指定目录</li>
<li><code>C:\Users\XXX\AppData\Roaming</code></li>
</ul>
</blockquote>
<p><a href="https://pan.baidu.com/s/1oUsf-FgVAZnQAtZWRwiK4w" target="_blank" rel="noopener">下载地址</a>  （密码 9sar）</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://blog.csdn.net/zln_whu/article/details/103448420" target="_blank" rel="noopener">CSDN-103448420</a></li>
<li><a href="https://www.jianshu.com/p/0e1d51a7549d" target="_blank" rel="noopener">nltk 简书详细讲解</a></li>
</ul>
]]></content>
      <categories>
        <category>Bug</category>
      </categories>
  </entry>
  <entry>
    <title>C++匿名函数</title>
    <url>/blog/uq89oe/</url>
    <content><![CDATA[<h3 id="常用形式"><a href="#常用形式" class="headerlink" title="常用形式"></a>常用形式</h3><pre><code class="cpp">[](int x, int y) -&gt; int { int z = x + y; return z; } //这样显示指定返回类型:

[](int x, int y) { return x + y; } // 隐式返回类型
[](int&amp; x) { ++x; }   // 没有return语句 -&gt; lambda 函数的返回类型是&#39;void&#39;
[]() { ++global_x; }  // 没有参数,仅访问某个全局变量
[]{ ++global_x; }     // 与上一个相同,省略了()
</code></pre>
<h3 id="小例子"><a href="#小例子" class="headerlink" title="小例子"></a>小例子</h3><pre><code class="cpp">#include &lt;iostream&gt;

int main() {
    // lambda表达式
    auto multiply = [](int a, int b) -&gt; int { return a * b; };
    // 匿名函数调用
    auto result = multiply(2, 4);
    std::cout &lt;&lt; result &lt;&lt; std::endl;
    return 0;
}
</code></pre>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><blockquote>
<p>一些进一步用法<a href="https://www.cnblogs.com/pzhfei/archive/2013/01/14/lambda_expression.html" target="_blank" rel="noopener">https://www.cnblogs.com/pzhfei/archive/2013/01/14/lambda_expression.html</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Language</category>
      </categories>
  </entry>
  <entry>
    <title>GitHub Actions代码汇总</title>
    <url>/blog/uwpbn0/</url>
    <content><![CDATA[<h2 id="仓库文件夹备份"><a href="#仓库文件夹备份" class="headerlink" title="仓库文件夹备份"></a>仓库文件夹备份</h2><pre><code class="yaml">name: CI
on: [watch]
jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - name: 配置Git
        run: |
          git config --global user.name &#39;wztlink1013&#39; 
          git config --global user.email &#39;2550374815@qq.com&#39;
      - name: 在云端进行复制文件夹操作
        env:
          Github_Token: ${{ secrets.TOKEN_GITHUBAPI }}
        run: |
          git clone https://${Github_Token}@github.com/wztlink1013/website-source website-source
          cd website-source
          cp -r ./Secret文集/ ./backup/
          git status
          git add .
          git commit -m &quot;backup&quot;
          git push --force --quiet &quot;https://${Github_Token}@github.com/wztlink1013/website-source&quot;  master:master
</code></pre>
<h2 id="博客-CICD-腾讯云函数"><a href="#博客-CICD-腾讯云函数" class="headerlink" title="博客 CICD 腾讯云函数"></a>博客 CICD 腾讯云函数</h2><h3 id="Python2-7-执行环境"><a href="#Python2-7-执行环境" class="headerlink" title="Python2.7 执行环境"></a>Python2.7 执行环境</h3><pre><code class="python"># -*- coding: utf8 -*-
import requests

def main_handler(event, context):
    r = requests.post(&quot;https://api.github.com/repos/wztlink1013/Blog3.0/dispatches&quot;,
    json={&#39;event_type&#39;: &quot;run-it&quot;},
    headers = {&quot;User-Agent&quot;:&#39;curl/7.52.1&#39;,
              &#39;Content-Type&#39;: &#39;application/json&#39;,
              &#39;Accept&#39;: &#39;application/vnd.github.everest-preview+json&#39;,
              &#39;Authorization&#39;: &#39;token **********&#39;})

    if r.status_code == 204:
        return &quot;This&#39;s OK!&quot;
    else:
        return r.status_code
</code></pre>
<h3 id="触发器设置"><a href="#触发器设置" class="headerlink" title="触发器设置"></a>触发器设置</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1594789179624-938bb8c2-ac15-4ece-a5f1-001563e4f08b.png?x-oss-process=image%2Fresize%2Cw_1210#align=left&amp;display=inline&amp;height=564&amp;margin=%5Bobject%20Object%5D&amp;originHeight=564&amp;originWidth=1210&amp;status=done&amp;style=shadow&amp;width=1210" alt></p>
<h2 id="博客-CICD-阿里云函数"><a href="#博客-CICD-阿里云函数" class="headerlink" title="博客 CICD 阿里云函数"></a>博客 CICD 阿里云函数</h2><h3 id="Python3-执行环境"><a href="#Python3-执行环境" class="headerlink" title="Python3 执行环境"></a>Python3 执行环境</h3><pre><code class="python"># -*- coding: utf-8 -*-

import logging
import requests
OK = b&#39;ok\n&#39;

def handler(environ, start_response):
    status = &#39;200 OK&#39;
    response_headers = [(&#39;Content-type&#39;, &#39;text/plain&#39;)]
    sync_yuque()
    start_response(status, response_headers)
    return [OK]

def sync_yuque():
    requests.post(&quot;https://api.github.com/repos/wztlink1013/Blog3.0/dispatches&quot;,
    json={&#39;event_type&#39;: &quot;run-it&quot;},
    headers={&quot;User-Agent&quot;:&#39;curl/7.52.1&#39;,
              &#39;Content-Type&#39;: &#39;application/json&#39;,
              &#39;Accept&#39;: &#39;application/vnd.github.everest-preview+json&#39;,
              &#39;Authorization&#39;: &#39;token *********&#39;})
</code></pre>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
  </entry>
  <entry>
    <title>备份</title>
    <url>/blog/vab07n/</url>
    <content><![CDATA[<h1 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h1><p>如果是 MyISAM 的数据库引擎，那么直接复制相应的数据库文件即可。<br>如果是 InnoDB 则需要利用命令。这也是更为一般的普适方法。</p>
<p>利用 MySQL 提供的工具———— <strong>mysqldump</strong></p>
<h2 id="mysqldump"><a href="#mysqldump" class="headerlink" title="mysqldump"></a>mysqldump</h2><pre><code>mysqldump -uroot -p database_name [table_name1,...] &gt;pathname.sql
</code></pre><h3 id="备份数据库"><a href="#备份数据库" class="headerlink" title="备份数据库"></a>备份数据库</h3><p>使用时需指定用户名，并使用-p 选项，再回车后键入密码。实际上是利用的<a href="#%E9%87%8D%E5%AE%9A%E5%90%91">重定向</a>来生成一个 sql 脚本文件。<br>该文件中包含各个 sql 语句。</p>
<p>重定向符号后面的是 sql 文件的路径。Linux 请使用<code>/</code>来表示目录结构。Windows 可以用<code>\</code> 也可以用 <code>/</code>。<br>比如：</p>
<h4 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h4><pre><code>mysqldump -uroot -p world &gt;/home/jelly/config/world.sql
</code></pre><h4 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h4><pre><code>mysqldump -uroot -p world &gt;d:/config/world.sql
mysqldump -uroot -p world &gt;d:\config\world.sql**
</code></pre><h3 id="备份部分表"><a href="#备份部分表" class="headerlink" title="备份部分表"></a>备份部分表</h3><p>如果不想备份整个数据库，而是像备份某个表，那么在数据库后面指定表的名称。</p>
<h1 id="还原"><a href="#还原" class="headerlink" title="还原"></a>还原</h1><p>执行已备份的 sql 脚本文件。有两种方案：</p>
<h2 id="已连接数据库时"><a href="#已连接数据库时" class="headerlink" title="已连接数据库时"></a>已连接数据库时</h2><p>登录 mysql 命令行，使用 source 命令（与 mysqldump 不同，source 不是独立工具，而是 MySQL 内部命令）来执行 sql 脚本。<br>需要先创建一个数据库，然后切换到给数据库，再执行该命令。</p>
<pre><code>mysql&gt; source d:/tool/world.sql
</code></pre><h2 id="未连接数据库时"><a href="#未连接数据库时" class="headerlink" title="未连接数据库时"></a>未连接数据库时</h2><p>直接在 shell 的命令行执行：</p>
<pre><code>mysql -uroot -p &lt; /home/jelly/config/world.sql
</code></pre><h1 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h1><p>存储引擎是基于表的，不是基于数据库的。</p>
<table>
<thead>
<tr>
<th>功能</th>
<th style="text-align:center">MyISAM</th>
<th style="text-align:center">InnoDB</th>
<th style="text-align:center">Memory</th>
<th style="text-align:center">Archive</th>
</tr>
</thead>
<tbody>
<tr>
<td>存储限制</td>
<td style="text-align:center">256T</td>
<td style="text-align:center">64T</td>
<td style="text-align:center">有</td>
<td style="text-align:center">无</td>
</tr>
<tr>
<td>事务安全</td>
<td style="text-align:center">-</td>
<td style="text-align:center">支持</td>
<td style="text-align:center">-</td>
<td style="text-align:center">-</td>
</tr>
<tr>
<td>索引支持</td>
<td style="text-align:center">支持</td>
<td style="text-align:center">支持</td>
<td style="text-align:center">支持</td>
<td style="text-align:center">-</td>
</tr>
<tr>
<td>锁颗粒</td>
<td style="text-align:center">表锁</td>
<td style="text-align:center">行锁</td>
<td style="text-align:center">表锁</td>
<td style="text-align:center">行锁</td>
</tr>
<tr>
<td>数据压缩</td>
<td style="text-align:center">支持</td>
<td style="text-align:center">-</td>
<td style="text-align:center">-</td>
<td style="text-align:center">支持</td>
</tr>
<tr>
<td>外键</td>
<td style="text-align:center">-</td>
<td style="text-align:center">支持</td>
<td style="text-align:center">-</td>
<td style="text-align:center">-</td>
</tr>
</tbody>
</table>
<p>以上是常用引擎，另外还有其他存储引擎。</p>
]]></content>
      <categories>
        <category>DataBase</category>
      </categories>
  </entry>
  <entry>
    <title>⏱算法复杂度</title>
    <url>/blog/veggl2/</url>
    <content><![CDATA[<h2 id="一、算法优化方向"><a href="#一、算法优化方向" class="headerlink" title="一、算法优化方向"></a>一、算法优化方向</h2><ol>
<li>用尽量少的存储空间</li>
<li>用尽量少的执行步骤（执行时间）</li>
<li>具体情况，具体分析（空间换时间，时间换空间）</li>
</ol>
<h2 id="二、时间复杂度"><a href="#二、时间复杂度" class="headerlink" title="二、时间复杂度"></a>二、时间复杂度</h2><blockquote>
<p>估算程序指令的执行次数（执行时间）</p>
</blockquote>
<h3 id="大-O-估算法"><a href="#大-O-估算法" class="headerlink" title="大 O 估算法"></a>大 O 估算法</h3><blockquote>
<p>忽略常数、系数、低阶<br>常见的复杂度</p>
</blockquote>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1599393633525-ae152fa4-ab52-4436-a91a-4237888491db.png#align=left&amp;display=inline&amp;height=220&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=440&amp;originWidth=915&amp;size=109404&amp;status=done&amp;style=shadow&amp;width=457.5" alt="image.png"><br><code>Ο(1)＜Ο(logn)＜Ο(n)＜Ο(nlogn)＜Ο(n^2)＜Ο(n^3)＜…＜Ο(2^n)＜Ο(n!)&lt;O(n^n)</code></p>
<blockquote>
<p>当数据规模较小的时候</p>
</blockquote>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1599393701320-c1869593-be0a-4552-9b1c-8a6fb00d300c.png#align=left&amp;display=inline&amp;height=239&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=477&amp;originWidth=813&amp;size=162408&amp;status=done&amp;style=shadow&amp;width=406.5" alt="image.png"></p>
<blockquote>
<p>当数据规模较大的时候</p>
</blockquote>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1599395912246-1e996955-9150-4af1-b6d9-f7d15ce7d594.png#align=left&amp;display=inline&amp;height=253&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=597&amp;originWidth=1004&amp;size=174523&amp;status=done&amp;style=shadow&amp;width=426" alt="image.png"><br><a href="https://zh.numberempire.com/graphingcalculator.php" target="_blank" rel="noopener">函数图像绘制工具</a></p>
<h2 id="三、空间复杂度"><a href="#三、空间复杂度" class="headerlink" title="三、空间复杂度"></a>三、空间复杂度</h2><blockquote>
<p>估算所需占用的存储空间</p>
</blockquote>
<pre><code>空间复杂度(Space Complexity)是对一个算法在运行过程中临时占用存储空间大小的量度。一个算法在计算机存储器上所占用的存储空间，包括存储算法本身所占用的存储空间，算法的输入输出数据所占用的存储空间和算法在运行过程中临时占用的存储空间这三个方面。算法的输入输出数据所占用的存储空间是由要解决的问题决定的，是通过参数表由调用函数传递而来的，它不随本算法的不同而改变。存储算法本身所占用的存储空间与算法书写的长短成正比，要压缩这方面的存储空间，就必须编写出较短的算法。算法在运行过程中临时占用的存储空间随算法的不同而异，有的算法只需要占用少量的临时工作单元，而且不随问题规模的大小而改变，我们称这种算法是“就地\&quot;进行的，是节省存储的算法，如这一节介绍过的几个算法都是如此；有的算法需要占用的临时工作单元数与解决问题的规模n有关，它随着n的增大而增大，当n较大时，将占用较多的存储单元，例如将在第九章介绍的快速排序和归并排序算法就属于这种情况。

如当一个算法的空间复杂度为一个常量，即不随被处理数据量n的大小而改变时，可表示为O(1)；当一个算法的空间复杂度与以2为底的n的对数成正比时，可表示为0(10g2n)；当一个算法的空I司复杂度与n成线性比例关系时，可表示为0(n).若形参为数组，则只需要为它分配一个存储由实参传送来的一个地址指针的空间，即一个机器字长空间；若形参为引用方式，则也只需要为其分配存储一个地址的空间，用它来存储对应实参变量的地址，以便由系统自动引用实参变量。
</code></pre><p><a href="https://blog.csdn.net/zolalad/article/details/11848739" target="_blank" rel="noopener">参考：算法的时间复杂度和空间复杂度-总结</a></p>
<h2 id="最好最坏复杂度"><a href="#最好最坏复杂度" class="headerlink" title="最好最坏复杂度"></a>最好最坏复杂度</h2><h2 id="均摊复杂度"><a href="#均摊复杂度" class="headerlink" title="均摊复杂度"></a>均摊复杂度</h2><h2 id="复杂度震荡"><a href="#复杂度震荡" class="headerlink" title="复杂度震荡"></a>复杂度震荡</h2><h2 id="平均复杂度"><a href="#平均复杂度" class="headerlink" title="平均复杂度"></a>平均复杂度</h2><p>##</p>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>GitHub Actions+语雀+serverless云函数实现hexo自动化部署</title>
    <url>/blog/vyeuk3/</url>
    <content><![CDATA[<h2 id="一、整体思路"><a href="#一、整体思路" class="headerlink" title="一、整体思路"></a>一、整体思路</h2><p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1610002276789-6c7bf0a3-f39b-4a27-a493-01c2e579ec87.jpeg#align=left&amp;display=inline&amp;height=368&amp;margin=%5Bobject%20Object%5D&amp;name=yuque_diagram.jpg&amp;originHeight=368&amp;originWidth=2062&amp;size=71238&amp;status=done&amp;style=stroke&amp;width=2062" alt="yuque_diagram.jpg"><br>利用<code>npm</code>插件<code>yuque-hexo</code>将语雀云端的文章同步到博客源码<code>source/_posts/blog</code>文件夹下，再利用<code>GitHub Actions</code>自动化部署将 GitHub 私有仓库（<code>website</code>）的博客源文件编译成静态博客文件并部署 push 到静态博客仓库（<code>wztlink1013.github.io</code>）下。<br>但是这样并不能解决语雀一发布文章就触发 GitHub 源码仓库的<code>GitHub Actions</code>，所以需要中间<code>TencentCloud</code>云函数/<code>Aliyun</code>云函数，云函数的作用就是，语雀文章一经正式发布就触发云函数，从而云函数再触发 GitHub 私有的源码仓库下的<code>GitHub Actions</code>达到编译静态博客的效果。</p>
<h2 id="二、网站源文件配置"><a href="#二、网站源文件配置" class="headerlink" title="二、网站源文件配置"></a>二、网站源文件配置</h2><h3 id="yuque-hexo-插件"><a href="#yuque-hexo-插件" class="headerlink" title="yuque-hexo 插件"></a>yuque-hexo 插件</h3><blockquote>
<p>【1】在开发环境当中下载语雀插件（全局安装）</p>
</blockquote>
<pre><code class="bash">npm i -g yuque-hexo
</code></pre>
<blockquote>
<p>【2】相关 hexo 命令</p>
</blockquote>
<pre><code class="bash">yuque-hexo clean # 清缓存删除yuque文件夹 删除yuque.json文件
yuque-hexo sync # 从云端拉取到本地
DEBUG=yuque-hexo.* yuque-hexo sync # Debug
</code></pre>
<blockquote>
<p>【3】特别需要注意的是：开发环境语雀 Token 变量的传入</p>
</blockquote>
<p>语雀为了防止用户恶意多次拉取数据，出于对知识库安全性的调整，使用第三方 API 访问知识库，需要传入环境变量 <code>YUQUE_TOKEN</code>，如果是本地使用建议使用环境变量，也可以是终端的方式输入。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1594788656022-fb5e7959-fa2a-4418-911b-773e3674afb8.png#align=left&amp;display=inline&amp;height=145&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=290&amp;originWidth=968&amp;size=24274&amp;status=done&amp;style=shadow&amp;width=484" alt="image.png"><br>如果是在<code>GitHub Actions</code>里面的环境执行<code>yuque-hexo sync</code>命令的时候，通过如下命令传入语雀的<code>token</code></p>
<pre><code class="yaml">YUQUE_TOKEN=${{ secrets.YUQUE_TOKEN }} yuque-hexo sync
</code></pre>
<blockquote>
<p>【4】最后的配置样式</p>
</blockquote>
<pre><code class="json">  &quot;yuqueConfig&quot;: {
    &quot;baseUrl&quot;: &quot;https://www.yuque.com/api/v2&quot;,
    &quot;login&quot;: &quot;nicaibandishuqing&quot;,
    &quot;repo&quot;: &quot;blog&quot;,
    &quot;postPath&quot;: &quot;src/_posts/blog&quot;,
    &quot;cachePath&quot;: &quot;yuque.json&quot;,
    &quot;mdNameFormat&quot;: &quot;slug&quot;,
    &quot;onlyPublished&quot;: false,
    &quot;onlyPublic&quot;: true,
    &quot;adapter&quot;: &quot;markdown&quot;
  },
  &quot;scripts&quot;: {
    &quot;clean&quot;: &quot;hexo clean&quot;,
    &quot;build&quot;: &quot;hexo generate&quot;,
    &quot;server&quot;: &quot;hexo server&quot;,
    &quot;deploy&quot;: &quot;hexo deploy&quot;
  }
</code></pre>
<p>更详细使用参考官方<a href="https://github.com/x-cold/yuque-hexo" target="_blank" rel="noopener">官方仓库</a>。</p>
<h3 id="配置-GitHub-Actions-文件"><a href="#配置-GitHub-Actions-文件" class="headerlink" title="配置 GitHub Actions 文件"></a>配置 GitHub Actions 文件</h3><p>在博客源文件夹下新建如下 GitHub Actions 文件<br><code>.github/workflows/main.yml</code></p>
<blockquote>
<p>文件内容配置如下</p>
</blockquote>
<pre><code class="yaml"># workflow name
name: website to wztlink1013.github.io CI/CD

on: [repository_dispatch, watch]

jobs:
  Deploy-Pages:
    name: website to wztlink1013.github.io
    runs-on: ubuntu-latest

    steps:
      # check it to your workflow can access it
      # from: https://github.com/actions/checkout
      - name: Checkout Repository master branch
        uses: actions/checkout@main
      # from: https://github.com/actions/setup-node
      - name: Setup Node.js 10.x
        uses: actions/setup-node@main
        with:
          node-version: &quot;10.x&quot;

      - name: add Git infomations
        run: |
          git config --global user.name &#39;wztlink1013&#39; 
          git config --global user.email &#39;2550374815@qq.com&#39;

      - name: submit commit infomations
        run: |
          git log --pretty=format:&quot;%s from Github Actions at `date +&quot;%Y-%m-%d %H:%M:%S&quot;`&quot; --date=short -n 1  &gt; commit-message.log

      - name: npm istall hexo-cli、yuque-hexo、*
        env:
          YUQUE_TOKEN: ${{ secrets.YUQUE_TOKEN }}
        run: |
          npm install hexo-cli -g
          npm i -g yuque-hexo-haisawa
          npm i -g npm-wzutao
          npm install

      - name: generate articles
        run: |
          hexo clean
          yuque-hexo-haisawa clean
          npm-wzutao clean
          YUQUE_TOKEN=${{ secrets.YUQUE_TOKEN }} yuque-hexo-haisawa sync
          YUQUE_TOKEN=${{ secrets.YUQUE_TOKEN }} npm-wzutao sync
          hexo generate

      - name: push wztlink1013.github.io repository
        env:
          Github_Pages: github.com/wztlink1013/wztlink1013.github.io
          Github_Token: ${{ secrets.token_GithubAPI }}
        run: |
          git clone https://${Github_Token}@${Github_Pages} .github_pages
          mv .github_pages/.git/ ./build/
          cd ./build/
          git add .
          git commit -F ../commit-message.log
          git push --force --quiet &quot;https://${Github_Token}@${Github_Pages}&quot; master:master
</code></pre>
<blockquote>
<p><del>有个尚未清楚并解决的问题：语雀 Token 的值，通过 GitHub 仓库密匙的方式传不进去，只能以“裸露的方式传进去”</del><br>已解决：通过在仓库设置 secret，再用<code>$</code>方式引入即可。</p>
</blockquote>
<h2 id="三、Serverless-云函数配置"><a href="#三、Serverless-云函数配置" class="headerlink" title="三、Serverless 云函数配置"></a>三、Serverless 云函数配置</h2><h3 id="python2-7-的配置"><a href="#python2-7-的配置" class="headerlink" title="python2.7 的配置"></a>python2.7 的配置</h3><pre><code class="python"># -*- coding: utf8 -*-
import requests

def main_handler(event, context):
    r = requests.post(&quot;https://api.github.com/repos/wztlink1013/website/dispatches&quot;,
    json={&#39;event_type&#39;: &quot;run-it&quot;},
    headers = {&quot;User-Agent&quot;:&#39;curl/7.52.1&#39;,
              &#39;Content-Type&#39;: &#39;application/json&#39;,
              &#39;Accept&#39;: &#39;application/vnd.github.everest-preview+json&#39;,
              &#39;Authorization&#39;: &#39;token ***********&#39;})

    if r.status_code == 204:
        return &quot;This&#39;s OK!&quot;
    else:
        return r.status_code
</code></pre>
<h3 id="触发器的设置"><a href="#触发器的设置" class="headerlink" title="触发器的设置"></a>触发器的设置</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1594789179624-938bb8c2-ac15-4ece-a5f1-001563e4f08b.png#align=left&amp;display=inline&amp;height=282&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=583&amp;originWidth=1250&amp;size=50598&amp;status=done&amp;style=none&amp;width=605" alt="image.png"></p>
<h2 id="四、语雀云端的配置"><a href="#四、语雀云端的配置" class="headerlink" title="四、语雀云端的配置"></a>四、语雀云端的配置</h2><p>在所需要拉取的仓库中 webhook 中填入云函数所留下的那串网址，勾选所需要触发的选项即可。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1610002554569-c1487bca-1b0f-4334-86a9-7ac062cf5a44.png#align=left&amp;display=inline&amp;height=291&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=581&amp;originWidth=1084&amp;size=52514&amp;status=done&amp;style=shadow&amp;width=542" alt="image.png"></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://github.com/x-cold/yuque-hexo" target="_blank" rel="noopener">yuque-hexo 开发仓库</a></li>
<li><a href="https://www.zhwei.cn/hexo-github-actions-yuque/" target="_blank" rel="noopener">Hexo：语雀云端写作，Github Actions 持续集成</a></li>
<li><a href="https://segmentfault.com/a/1190000017797561" target="_blank" rel="noopener">Hexo 博客终极玩法：云端写作，自动部署</a></li>
<li><a href="https://www.xiayinchang.top/post/b2362878.html" target="_blank" rel="noopener">阿里云云函数使用用户</a></li>
<li><a href="https://bbs.pediy.com/thread-260866.htm" target="_blank" rel="noopener">[原创]自动同步语雀文档到你的 hexo 博客</a></li>
</ul>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>serverless</tag>
      </tags>
  </entry>
  <entry>
    <title>Navicat-1045报错</title>
    <url>/blog/wp9hok/</url>
    <content><![CDATA[<h2 id="一、报错信息"><a href="#一、报错信息" class="headerlink" title="一、报错信息"></a>一、报错信息</h2><pre><code>1045-Access denied for user root@localhost(using password:YES)
</code></pre><h2 id="二、问题分析与解决"><a href="#二、问题分析与解决" class="headerlink" title="二、问题分析与解决"></a>二、问题分析与解决</h2><p>不被接入，改 root 密码</p>
<p>在 mysql 控制台里面改密码</p>
<p><code>ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED WITH mysql_native_password BY &#39;你的密码&#39;;</code></p>
<p>刷新数据库</p>
<p><code>flush privileges;</code></p>
<p>退出</p>
<p><code>quit;</code></p>
<p>重启 Navicat 再次链接即可。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://blog.csdn.net/acoolgiser/article/details/82967317?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522159185926319725250149590%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=159185926319725250149590&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_ctr_v3-4-82967317.ecpm_v1_rank_ctr_v3&amp;utm_term=1045-Access+denied+for+user+ro" target="_blank" rel="noopener">acoolgiser</a></li>
<li><a href="https://blog.csdn.net/zhang_yu_ling/article/details/103177296?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522159185926319725250149590%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=159185926319725250149590&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_ctr_v3-2-103177296.ecpm_v1_rank_ctr_v3&amp;utm_term=1045-Access+denied+for+user+ro" target="_blank" rel="noopener">张张张 i</a></li>
</ul>
]]></content>
      <categories>
        <category>Bug</category>
      </categories>
  </entry>
  <entry>
    <title>yuque-未拉取成功</title>
    <url>/blog/wsmygb/</url>
    <content><![CDATA[<h2 id="一、报错信息"><a href="#一、报错信息" class="headerlink" title="一、报错信息"></a>一、报错信息</h2><pre><code class="bash">$ yuque-hexo sync
[INFO] clear previous directory.
[INFO] remove yuque posts: D:\Blog\blog-wztlink1013-3.0\source\yuque
Mon, 01 Jun 2020 04:02:22 GMT yuque-hexo deprecated TOKEN of yuque will be required while verion &gt;v1.6.0. at ..\..\Develop\nodejs\node_global\node_modules\yuque-hexo\lib\Downloader.js:39:19
[INFO] reading from local file: D:\Blog\blog-wztlink1013-3.0\yuque.json
[WARNING] Cannot find module &#39;D:\Blog\blog-wztlink1013-3.0\yuque.json&#39;
Require stack:
- D:\Develop\nodejs\node_global\node_modules\yuque-hexo\lib\Downloader.js
- D:\Develop\nodejs\node_global\node_modules\yuque-hexo\command\sync.js
- D:\Develop\nodejs\node_global\node_modules\yuque-hexo\node_modules\common-bin\lib\command.js
- D:\Develop\nodejs\node_global\node_modules\yuque-hexo\node_modules\common-bin\index.js
- D:\Develop\nodejs\node_global\node_modules\yuque-hexo\index.js
- D:\Develop\nodejs\node_global\node_modules\yuque-hexo\bin\yuque-hexo.js
⚠️  Error: fail to fetch article list, response: {&quot;status&quot;:401,&quot;message&quot;:&quot;Unauthorized&quot;}
⚠️  Command Error, enable `DEBUG=common-bin` for detail
</code></pre>
<h2 id="二、分析并解决问题"><a href="#二、分析并解决问题" class="headerlink" title="二、分析并解决问题"></a>二、分析并解决问题</h2><p>认证出错，应该和下面三个原因有关</p>
<ul>
<li>客户端将其身份验证凭据发送到服务器，但是服务器由于某种原因拒绝了凭据。</li>
<li>客户端无法在请求中提供任何身份验证凭据。</li>
<li>客户端由于某种原因被禁止。某些应用程序用来限制来自特定 IP 地址的访问请求，因此，如果身份验证不是问题，则可能是服务器端禁止。401 Unauthorized Errors</li>
</ul>
<p>也就是身份没有被验证，首先检查用户元信息相关</p>
<p>的确，配置都是没有问题的，然后去 issue 里面查看相关问题，了解到是语雀官方出于对知识库安全性的调整，需要使用第三方 API 访问知识库，需要传入环境变量 YUQUE_TOKEN。</p>
<p>然后根据两种指导方式，传入参数即可</p>
<ul>
<li>设置全局的环境变量 YUQUE_TOKEN</li>
<li>命令执行时传入环境变量<ul>
<li>mac / linux: YUQUE_TOKEN=xxx yuque-hexo sync</li>
<li>windows: set YUQUE_TOKEN=xxx &amp;&amp; yuque-hexo sync</li>
</ul>
</li>
</ul>
<p>传入之后会有一封邮件发过来，然后新开 git bash 窗口，重新键入命令即可</p>
<p>成功之后是这个样子的</p>
<pre><code class="bash">$ yuque-hexo sync
[INFO] clear previous directory.
[INFO] remove yuque posts: D:\Blog\blog-wztlink1013-3.0\source\_posts\yuque
[INFO] reading from local file: D:\Blog\blog-wztlink1013-3.0\yuque.json
[INFO] article amount: 2
[INFO] download articles done!
[INFO] writing to local file: D:\Blog\blog-wztlink1013-3.0\yuque.json
[INFO] create posts directory (if it not exists): D:\Blog\blog-wztlink1013-3.0\source\_posts\yuque
[INFO] generate post file: D:\Blog\blog-wztlink1013-3.0\source\_posts\yuque\hexo-test.md
[INFO] generate post file: D:\Blog\blog-wztlink1013-3.0\source\_posts\yuque\语雀文章测试.md
[INFO] yuque-hexo sync done!
</code></pre>
<h2 id="相关参考"><a href="#相关参考" class="headerlink" title="相关参考"></a>相关参考</h2><ul>
<li><a href="https://airbrake.io/blog/http-errors/401-unauthorized-error" target="_blank" rel="noopener">https://airbrake.io/blog/http-errors/401 U-unauthorized E-error:What It Is and How to Fix It</a></li>
<li><a href="https://www.yuguocong.cn/yuque/eg7hkp.html#Reference" target="_blank" rel="noopener">使用语雀编辑器写静态博客 https://www.yuguocong.cn/yuque/eg7hkp.html#Reference</a></li>
<li><a href="https://blog.csdn.net/Caoyang_He/article/details/82181695?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.nonecase&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.nonecase" target="_blank" rel="noopener">windows10 环境变量设置及理解环境变量</a></li>
</ul>
]]></content>
      <categories>
        <category>Bug</category>
      </categories>
  </entry>
  <entry>
    <title>JAVA-正则表达式</title>
    <url>/blog/xm1a2g/</url>
    <content><![CDATA[<h2 id="常见匹配符号"><a href="#常见匹配符号" class="headerlink" title="常见匹配符号"></a>常见匹配符号</h2><table>
<thead>
<tr>
<th style="text-align:center">正则表达式</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>.</code></td>
<td style="text-align:center">匹配所有单个字符，除了换行符（Linux 中换行是 <code>\n</code>，Windows 中换行是 <code>\r\n</code>）</td>
</tr>
<tr>
<td style="text-align:center"><code>^regex</code></td>
<td style="text-align:center">正则必须匹配字符串开头</td>
</tr>
<tr>
<td style="text-align:center"><code>regex$</code></td>
<td style="text-align:center">正则必须匹配字符串结尾</td>
</tr>
<tr>
<td style="text-align:center"><code>[abc]</code></td>
<td style="text-align:center">复选集定义，匹配字母 a 或 b 或 c</td>
</tr>
<tr>
<td style="text-align:center"><code>[abc][vz]</code></td>
<td style="text-align:center">复选集定义，匹配字母 a 或 b 或 c，后面跟着 v 或 z</td>
</tr>
<tr>
<td style="text-align:center"><code>[^abc]</code></td>
<td style="text-align:center">当插入符 <code>^</code> 在中括号中以第一个字符开始显示，则表示否定模式。此模式匹配所有字符，除了 a 或 b 或 c</td>
</tr>
<tr>
<td style="text-align:center"><code>[a-d1-7]</code></td>
<td style="text-align:center">范围匹配，匹配字母 a 到 d 和数字从 1 到 7 之间，但不匹配 d1</td>
</tr>
<tr>
<td style="text-align:center"><code>XZ</code></td>
<td style="text-align:center">匹配 X 后直接跟着 Z</td>
</tr>
<tr>
<td style="text-align:center">X&#124;Z</td>
<td style="text-align:center">匹配 X 或 Z</td>
</tr>
</tbody>
</table>
<h2 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h2><table>
<thead>
<tr>
<th style="text-align:center">正则表达式</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>\d</code></td>
<td style="text-align:center">匹配一个数字，是 <code>[0-9]</code> 的简写</td>
</tr>
<tr>
<td style="text-align:center"><code>\D</code></td>
<td style="text-align:center">匹配一个非数字，是 <code>[^0-9]</code> 的简写</td>
</tr>
<tr>
<td style="text-align:center"><code>\s</code></td>
<td style="text-align:center">匹配一个空格，是 <code>[ \t\n\x0b\r\f]</code> 的简写</td>
</tr>
<tr>
<td style="text-align:center"><code>\S</code></td>
<td style="text-align:center">匹配一个非空格</td>
</tr>
<tr>
<td style="text-align:center"><code>\w</code></td>
<td style="text-align:center">匹配一个单词字符（大小写字母、数字、下划线），是 <code>[a-zA-Z_0-9]</code> 的简写</td>
</tr>
<tr>
<td style="text-align:center"><code>\W</code></td>
<td style="text-align:center">匹配一个非单词字符（除了大小写字母、数字、下划线之外的字符），等同于 <code>[^\w]</code></td>
</tr>
</tbody>
</table>
<h2 id="限定符"><a href="#限定符" class="headerlink" title="限定符"></a>限定符</h2><p>| 正则表达式 | 描述 | 举例 |<br>| <code>*</code> | 匹配 &gt;=0 个，是 <code>{0,}</code> 的简写 | <code>X*</code> 表示匹配零个或多个字母 X，<code>.*</code> 表示匹配任何字符串 |<br>| :—: | :—: | :—: |<br>| <code>+</code> | 匹配 &gt;=1 个，是 <code>{1,}</code> 的简写 | <code>X+</code> 表示匹配一个或多个字母 X |<br>| <code>?</code> | 匹配 1 个或 0 个，是 <code>{0,1}</code> 的简写 | <code>X?</code> 表示匹配 0 个或 1 个字母 X |<br>| <code>{X}</code> | 只匹配 X 个字符 | <code>\d{3}</code> 表示匹配 3 个数字，<code>.{10}</code> 表示匹配任何长度是 10 的字符串 |<br>| <code>{X,Y}</code> | 匹配 &gt;=X 且 &lt;=Y 个 | <code>\d{1,4}</code> 表示匹配至少 1 个最多 4 个数字 |<br>| <code>*?</code> | 如果 <code>?</code> 是限定符 <code>*</code> 或 <code>+</code> 或 <code>?</code> 或 <code>{}</code> 后面的第一个字符，那么表示<strong>非贪婪模式</strong>（尽可能少的匹配字符），而不是默认的<strong>贪婪模式</strong> | |</p>
]]></content>
      <categories>
        <category>Language</category>
      </categories>
  </entry>
  <entry>
    <title>搭建Windows子系统Linux</title>
    <url>/blog/xnh83z/</url>
    <content><![CDATA[<h2 id="Windows-子系统-Linux"><a href="#Windows-子系统-Linux" class="headerlink" title="Windows 子系统 Linux"></a>Windows 子系统 Linux</h2><h3 id="子系统-Linux-下载安装"><a href="#子系统-Linux-下载安装" class="headerlink" title="子系统 Linux 下载安装"></a>子系统 Linux 下载安装</h3><p>在 windows 里面搜索 <code>windows功能</code><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1604913834448-30d164c9-e0a6-47f8-baac-03c5d6648186.png#align=left&amp;display=inline&amp;height=517&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=1033&amp;originWidth=1176&amp;size=659449&amp;status=done&amp;style=shadow&amp;width=588" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1604913865729-b20b3a35-ab49-48c9-be97-9f3c56d6d7a6.png#align=left&amp;display=inline&amp;height=295&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=590&amp;originWidth=623&amp;size=61833&amp;status=done&amp;style=shadow&amp;width=311.5" alt="image.png"><br>然后已知下一步操作即可，该过程中会有重启的过程。<br>之后重启之后在应用商店下载 Ubuntu 系统，如下。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1604913776014-38c5ce17-996d-4827-8c49-bb047b2f7d3c.png#align=left&amp;display=inline&amp;height=339&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=948&amp;originWidth=1200&amp;size=183352&amp;status=done&amp;style=shadow&amp;width=429" alt="image.png"><br>然后启动的时候，会有让自己输入用户名和密码的情况。输入确认就好了（<strong>输入密码的时候，终端内不会显示光标以及输入的字符！但是会有密码验证</strong>）</p>
<h3 id="子系统-Linux-文件目录"><a href="#子系统-Linux-文件目录" class="headerlink" title="子系统 Linux 文件目录"></a>子系统 Linux 文件目录</h3><p><code>C:\Users\wztli\AppData\Local\Packages\CanonicalGroupLimited.UbuntuonWindows_79rhkp1fndgsc\LocalState\rootfs\home\wztlink1013</code><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1604914117863-4fc253c2-1978-44b1-94c6-48e82a3ddf3a.png#align=left&amp;display=inline&amp;height=111&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=221&amp;originWidth=1468&amp;size=28524&amp;status=done&amp;style=shadow&amp;width=734" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1604914176405-056c5008-8168-40f8-a599-0e7951cad309.png#align=left&amp;display=inline&amp;height=293&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=585&amp;originWidth=1406&amp;size=115194&amp;status=done&amp;style=shadow&amp;width=703" alt="image.png"></p>
<h3 id="Linux-访问-Windows-文件"><a href="#Linux-访问-Windows-文件" class="headerlink" title="Linux 访问 Windows 文件"></a>Linux 访问 Windows 文件</h3><p>如下图中 1 所示，访问时，需要先将 Windows 磁盘挂载到/mnt 下面，然后就可以访问了。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1604914600884-f758bc8f-668d-4354-be9f-f9be774cfff1.png#align=left&amp;display=inline&amp;height=189&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=378&amp;originWidth=1122&amp;size=63616&amp;status=done&amp;style=shadow&amp;width=561" alt="image.png"></p>
]]></content>
      <categories>
        <category>Environment</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>搭建“文本三巨头”环境</title>
    <url>/blog/yhxiep/</url>
    <content><![CDATA[<h2 id="Vim"><a href="#Vim" class="headerlink" title="Vim"></a>Vim</h2><h3 id="Vim-下载安装"><a href="#Vim-下载安装" class="headerlink" title="Vim 下载安装"></a>Vim 下载安装</h3><p><a href="https://www.vim.org/download.php" target="_blank" rel="noopener">下载地址</a><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1608357192619-ac3d093e-c4e4-49fa-9a3b-8ead607b2160.png#align=left&amp;display=inline&amp;height=299&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=598&amp;originWidth=1919&amp;size=248340&amp;status=done&amp;style=none&amp;width=959.5" alt="image.png"><br>下载完之后 next 安装即可</p>
<h3 id="Vim-环境变量配置"><a href="#Vim-环境变量配置" class="headerlink" title="Vim 环境变量配置"></a>Vim 环境变量配置</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1608357482468-e6a53bc3-991d-4eda-aa2e-c5643b9617b0.png#align=left&amp;display=inline&amp;height=89&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=177&amp;originWidth=602&amp;size=11434&amp;status=done&amp;style=none&amp;width=301" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1608357463679-c00baef1-4e21-4405-8e79-f65afabe0370.png#align=left&amp;display=inline&amp;height=469&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=938&amp;originWidth=976&amp;size=105454&amp;status=done&amp;style=none&amp;width=488" alt="image.png"></p>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1608357601712-bc8f6f5b-6038-4358-8699-a7201ce8223e.png#align=left&amp;display=inline&amp;height=112&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=225&amp;originWidth=1468&amp;size=22708&amp;status=done&amp;style=none&amp;width=734" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1608357572830-fd4043b2-f02a-4c32-b9e7-677c4918ec19.png#align=left&amp;display=inline&amp;height=383&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=766&amp;originWidth=1442&amp;size=64262&amp;status=done&amp;style=none&amp;width=721" alt="image.png"></p>
<h2 id="zsh"><a href="#zsh" class="headerlink" title="zsh"></a>zsh</h2><h3 id="安装-Linux-子系统"><a href="#安装-Linux-子系统" class="headerlink" title="安装 Linux 子系统"></a>安装 Linux 子系统</h3><p>查看之前写的文章：<a href="https://www.wztlink1013.com/blog/xnh83z/">搭建 Windows 子系统 Linux - 尼采般地抒情</a></p>
<h3 id="安装-ConEmu"><a href="#安装-ConEmu" class="headerlink" title="安装 ConEmu"></a>安装 ConEmu</h3><p><a href="https://www.fosshub.com/ConEmu.html" target="_blank" rel="noopener">https://www.fosshub.com/ConEmu.html</a><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1608358847174-3a3b7ba1-45e8-4951-a943-debd2a09de43.png#align=left&amp;display=inline&amp;height=217&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=434&amp;originWidth=1904&amp;size=80285&amp;status=done&amp;style=none&amp;width=952" alt="image.png"><br>设置如下：<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1608358926353-c172728f-978e-47f7-9ec5-34472219ccdb.png#align=left&amp;display=inline&amp;height=376&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=751&amp;originWidth=1143&amp;size=84693&amp;status=done&amp;style=none&amp;width=571.5" alt="image.png"><br>确定后会进入以下界面<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1608358964494-c12c30a4-4b04-4463-b3d6-3c5fc21b607f.png#align=left&amp;display=inline&amp;height=359&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=717&amp;originWidth=970&amp;size=40132&amp;status=done&amp;style=none&amp;width=485" alt="image.png"></p>
<h3 id="安装并配置-zsh"><a href="#安装并配置-zsh" class="headerlink" title="安装并配置 zsh"></a>安装并配置 zsh</h3><p>进入页面 <code>sudo apt-get install -y zsh</code> ，输入密码：<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1608359167583-80d5f5fd-77e6-417d-ac0c-279dbfb55776.png#align=left&amp;display=inline&amp;height=300&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=600&amp;originWidth=960&amp;size=64893&amp;status=done&amp;style=none&amp;width=480" alt="image.png"><br>安装成功界面如下：<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1608360612991-863a5a2e-77a2-4bd7-b1b9-4ef6a79dcb86.png#align=left&amp;display=inline&amp;height=456&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=912&amp;originWidth=1908&amp;size=196509&amp;status=done&amp;style=none&amp;width=954" alt="image.png"></p>
<h3 id="安装-oh-my-zsh"><a href="#安装-oh-my-zsh" class="headerlink" title="安装 oh-my-zsh"></a>安装 oh-my-zsh</h3><p>sh -c “$(curl -fsSL <a href="https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh" target="_blank" rel="noopener">https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)”</a>%22)<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1608360763102-d6886d61-c954-4c15-adfc-ca42c0daf337.png#align=left&amp;display=inline&amp;height=411&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=821&amp;originWidth=1908&amp;size=125769&amp;status=done&amp;style=none&amp;width=954" alt="image.png"><br>上述文件夹在这里： <code>C:\Users\wztli\AppData\Local\Packages\CanonicalGroupLimited.UbuntuonWindows_79rhkp1fndgsc\LocalState\rootfs\home\wztlink1013</code></p>
<h2 id="tmux"><a href="#tmux" class="headerlink" title="tmux"></a>tmux</h2><h3 id="安装运行"><a href="#安装运行" class="headerlink" title="安装运行"></a>安装运行</h3><p>Ubuntu 系统命令行界面输入： <code>sudo apt install tmux</code></p>
<p>在 Ubuntu 系统输入并执行”tmux”命令，会进入 tmux 窗口</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://www.jianshu.com/p/5f7b83ca3952" target="_blank" rel="noopener">https://www.jianshu.com/p/5f7b83ca3952</a></li>
<li><a href="https://post.smzdm.com/p/a5k6e033/" target="_blank" rel="noopener">https://post.smzdm.com/p/a5k6e033/</a></li>
<li><a href="https://blog.csdn.net/qq_2300688967/article/details/81774297" target="_blank" rel="noopener">https://blog.csdn.net/qq_2300688967/article/details/81774297</a></li>
</ul>
]]></content>
      <categories>
        <category>Environment</category>
      </categories>
      <tags>
        <tag>vim</tag>
        <tag>zsh</tag>
        <tag>tmux</tag>
      </tags>
  </entry>
  <entry>
    <title>栈设计</title>
    <url>/blog/yxy6mv/</url>
    <content><![CDATA[<h2 id="栈的设计"><a href="#栈的设计" class="headerlink" title="栈的设计"></a>栈的设计</h2><h3 id="栈的特点"><a href="#栈的特点" class="headerlink" title="栈的特点"></a>栈的特点</h3><p>栈的最重要特点就是其元素的<strong>后进先出，先进后出</strong>。</p>
<h3 id="栈的接口设计"><a href="#栈的接口设计" class="headerlink" title="栈的接口设计"></a>栈的接口设计</h3><p>栈可以<strong>直接继承</strong>之前所学的 ArrayList 亦或是 List 接口。<br>这过程中需要注意，最好不要直接继承，因为如果直接继承，会将接口里面的其他方法也继承下来，会导致栈的对外接口不合理，解决办法就是在<strong>类设计内部 new 一个 private List 对象</strong>来设计栈。</p>
<pre><code class="java">int size(); // 元素的数量
boolean isEmpty(); // 栈是否为空
void push(E element); // 入栈
E pop(); // 出栈
E top(); // 获取栈顶元素
void clear(); // 清空栈
</code></pre>
<pre><code class="java">package com.wztlink1013.ds.stack;

import com.wztlink1013.ds.stack.list.ArrayList;
import com.wztlink1013.ds.stack.list.List;

public class Stack&lt;E&gt; {
    private List&lt;E&gt; list = new ArrayList&lt;&gt;();

    public void clear() {
        list.clear();
    }

    public int size() {
        return list.size();
    }

    public boolean isEmpty() {
        return list.isEmpty();
    }

    public void push(E element) {
        list.add(element);
    }

    public E pop() {
        return list.remove(list.size() - 1);
    }

    public E top() {
        return list.get(list.size() - 1);
    }
}
</code></pre>
<h2 id="栈的应用"><a href="#栈的应用" class="headerlink" title="栈的应用"></a>栈的应用</h2><p><strong>浏览器的前进和后退</strong>的功能。<br>假如有网页 a、b、c、d，依次点击 abc 三个网页，然后回退至 b 网页，这个时候，就相当于在 1 栈中有 ab 两个网页（且 b 为栈顶元素），c 暂时放到 2 栈中，此时依然可以使用回退前进功能，但是现在在 b 页面上在新输入 d 网页并进入，此时 2 栈被清空，d 为 1 栈的栈顶元素，在此时的 d 页面内，不能使用浏览器的前进功能，只能使用后退功能。</p>
<p>##</p>
]]></content>
      <categories>
        <category>DataStructure</category>
      </categories>
  </entry>
  <entry>
    <title>C++随机字符串生成函数</title>
    <url>/blog/zeszpb/</url>
    <content><![CDATA[<pre><code class="cpp">//C++ 随机字符串生成函数
#include&lt;iostream&gt;
#include&lt;ctime&gt;
using namespace std;

const int LEN_NAME=4;

char *rand_str(char *str,const int len)
{
    int i;
    for(i=0;i&lt;len;++i)
        str[i]=&#39;A&#39;+rand()%26;
    str[++i]=&#39;\0&#39;;
    return str;
}

void main()
{
    srand(time(NULL));
    int i;
    char name[LEN_NAME+1];

    for(i=0;i&lt;20;++i)
    {
        cout&lt;&lt;rand_str(name,LEN_NAME)&lt;&lt;endl;
    }
}
</code></pre>
]]></content>
      <categories>
        <category>Language</category>
      </categories>
  </entry>
  <entry>
    <title>sdnu-dboj-成绩管理-Movie</title>
    <url>/blog/zhdy1x/</url>
    <content><![CDATA[<blockquote>
<p>题目入口：<a href="http://db.itoi.sd.cn/problem/set" target="_blank" rel="noopener">http://db.itoi.sd.cn/problem/set</a></p>
</blockquote>
<h2 id="成绩管理相关题目"><a href="#成绩管理相关题目" class="headerlink" title="成绩管理相关题目"></a>成绩管理相关题目</h2><h3 id="Student-表"><a href="#Student-表" class="headerlink" title="Student 表"></a>Student 表</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1600849205116-d4263820-8bbb-4d01-b97b-a0363f4498e7.png#align=left&amp;display=inline&amp;height=216&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=432&amp;originWidth=722&amp;size=41200&amp;status=done&amp;style=shadow&amp;width=361" alt="image.png"></p>
<h3 id="Course-表"><a href="#Course-表" class="headerlink" title="Course 表"></a>Course 表</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1600849217512-41be815b-8bc4-4b6a-82c2-cbb4d335c9b9.png#align=left&amp;display=inline&amp;height=256&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=511&amp;originWidth=632&amp;size=38392&amp;status=done&amp;style=shadow&amp;width=316" alt="image.png"></p>
<h3 id="SC-表"><a href="#SC-表" class="headerlink" title="SC 表"></a>SC 表</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1600849229639-8d5cd91f-d87e-49e9-a1cd-9c563b64723f.png#align=left&amp;display=inline&amp;height=262&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=523&amp;originWidth=492&amp;size=32976&amp;status=done&amp;style=shadow&amp;width=246" alt="image.png"></p>
<h3 id="初始化-SQL-语句"><a href="#初始化-SQL-语句" class="headerlink" title="初始化 SQL 语句"></a>初始化 SQL 语句</h3><pre><code class="sql">SET NAMES utf8mb4;
SET FOREIGN_KEY_CHECKS = 0;

/*学生表*/
CREATE TABLE Student
(
    Sno  INT(9) PRIMARY KEY,
    Sname VARCHAR(10),
    Ssex  CHAR(2),
    Sage  TINYINT(3),
    Sdept VARCHAR(20)
);
INSERT INTO Student
VALUES (201215121, &#39;李勇&#39;, &#39;男&#39;, 20, &#39;CS&#39;),
     (201215122, &#39;刘晨&#39;, &#39;女&#39;, 19, &#39;CS&#39;),
    (201215123, &#39;王敏&#39;, &#39;女&#39;, 18, &#39;MA&#39;),
    (201215125, &#39;张立&#39;, &#39;男&#39;, 19, &#39;IS&#39;),
    (201215133, &#39;张三&#39;, &#39;男&#39;, 21, &#39;TE&#39;),
     (201215137, &#39;赵四&#39;, &#39;男&#39;, 23, &#39;TE&#39;),
     (201215139, &#39;田二&#39;, &#39;女&#39;, 24, &#39;CS&#39;),
     (201215140, &#39;李四&#39;, &#39;男&#39;, 21, &#39;CS&#39;),
     (201215141, &#39;郑五&#39;, &#39;女&#39;, 22, &#39;IS&#39;);

/*课程表*/
CREATE TABLE Course
(
    Cno      INT(4) PRIMARY KEY,
    Cname     VARCHAR(40),
    Cpno      INT(4),
    Ccredit     TINYINT(3),
    FOREIGN     KEY (Cpno) REFERENCES Course (Cno)
);
INSERT INTO Course
VALUES    (1, &#39;数据库&#39;, 5, 4),
        (2, &#39;数学&#39;, NULL, 2),
    (3, &#39;信息系统&#39;, 1, 4),
     (4, &#39;操作系统&#39;, 6, 3),
     (5, &#39;数据结构&#39;, 7, 4),
     (6, &#39;数据处理&#39;, NULL, 2),
     (7, &#39;PASCAL语言&#39;, 6, 4);

/*选课表*/
CREATE TABLE SC
(
    Sno  INT(9),
    Cno  INT(4),
    Grade SMALLINT(3),
    PRIMARY KEY (Sno, Cno),
/* 主码由两个属性构成，必须作为表级完整性进行定义*/
    FOREIGN KEY (Sno) REFERENCES Student (Sno),
/* 表级完整性约束条件，Sno是外码，被参照表是Student */
    FOREIGN KEY (Cno) REFERENCES Course (Cno)
/* 表级完整性约束条件， Cno是外码，被参照表是Course*/
);
INSERT INTO SC
VALUES (201215121, 1, 92),
            (201215121, 2, 85),
            (201215121, 3, 88),
            (201215122, 2, 90),
      (201215122, 3, 80),
            (201215122, 6, 59),
         (201215123, 1, 84),
         (201215125, 1, 60),
         (201215125, 3, 90),
         (201215133, 4, 87),
         (201215137, 2, 79),
         (201215139, 2, 80),
         (201215140, 2, 81);

SET FOREIGN_KEY_CHECKS = 1;
</code></pre>
<h3 id="问题代码"><a href="#问题代码" class="headerlink" title="问题代码"></a>问题代码</h3><pre><code class="sql">0
select Sno, Sname
        from Student
1
select Sname, Sno, Sdept
        from Student
2
select Sname, Sno, Sdept
        from Student
3
select distinct Sno
        from SC
4
select distinct Sname
        from Student
        where Sdept=&#39;CS&#39;
5
select Sname, Sage
    from Student
    where Sage&lt;20
6
select Sno
    from SC
    where Grade&lt;60
7
select Sname, Sdept, Sage
    from Student
    where Sage&gt;=20 and Sage&lt;=23
8
select Sname, Sdept, Sage
    from Student
    where Sage&lt;20 or Sage&gt;23
9
select Sname, Ssex
    from Student
    where Sdept=&#39;CS&#39; or Sdept=&#39;MA&#39; or Sdept=&#39;IS&#39;
10
select Sname, Ssex
    from Student
    where Sdept not in (&#39;CS&#39;, &#39;MA&#39;, &#39;IS&#39;)
11
select Sname, Sno, Ssex
    from Student
    where Sname like &#39;刘_&#39;
12
select Sname, Sno
    from Student
    where Sname like &#39;_立&#39;
13
select Sname, Sno, Ssex
    from Student
    where Sname not like &#39;刘_&#39;
14
select Sno, Cno
    from SC
    where Grade is not null
15
select Sname
    from Student
    where Sdept=&#39;CS&#39; and Sage&lt;20
16
select Sno, Grade
    from SC
    where Cno=&#39;3&#39;
    order by Grade desc
17
select *
    from Student
    order by Sdept asc, Sage desc
18
select count(Sno) as &#39;COUNT&#39;
    from Student
19
select count(Sno) as COUNT
        from (
        select Sno
                from SC
                group by sno) as test
20
select avg(Grade) as AVG
    from SC
    where Cno=&#39;1&#39;
21
select max(Grade) as MAX
    from SC
    where Cno=&#39;1&#39;
22
select SUM(Ccredit) as SUM
        from Course, SC
        where Course.Cno=SC.Cno
        and Sno=&#39;201215121&#39;
23
select Cno, count(Grade) as COUNT
        from SC
        group by Cno
24
select Sno
        from(
        select Sno, count(Grade) as COUNT
                from SC
                group by Sno
            )as test
        where COUNT&gt;2
25
select Sno, AVG(Grade) as AVG
        from SC
        group by Sno
        having AVG(Grade)&gt;=88
26
select Student.Sno, Sname, Ssex, Sage, Sdept, Cno, Grade
    from Student inner join SC
    on Student.Sno=SC.Sno
27
SELECT x.Cno, y.Cpno
        FROM Course x, Course y
        WHERE x.Cpno = y.Cno
28
select Student.Sno, Student.Sname
        from Student, SC
        where Student.Sno=SC.Sno
                and SC.Cno=&#39;2&#39;
                and SC.Grade&gt;80
29
select test.Sno, test.Sname, Course.Cname, test.Grade
    from Course join
        (select SC.Sno, SC.Cno, Student.Sname, SC.Grade
            from Student join SC
                on Student.Sno=SC.Sno)as test
        on Course.Cno=test.Cno
</code></pre>
<h2 id="Movie-相关题目"><a href="#Movie-相关题目" class="headerlink" title="Movie 相关题目"></a>Movie 相关题目</h2><pre><code class="sql">30
select title
        from movie
        where director=&#39;Steven Spielberg&#39;
31
select year
        from movie
        where mID in (
                select mID
                from rating
                where stars=&#39;4&#39; or stars=&#39;5&#39;
                )
        order by year asc
32
select title
        from movie
        where mID not in (
                select mID
                    from rating)
33
select name
        from reviewer
        where rID in (
                select rID
                        from rating
                        where ratingDate is null)
34
select reviewer.name, test.title, test.stars, test.ratingDate
from reviewer join (
    select movie.title, rating.rID, rating.stars, rating.ratingDate
    from movie join rating
    on movie.mID=rating.mID
    ) as test
on reviewer.rID=test.rID
order by reviewer.name, test.title, test.stars
35

37
select movie.title, rating_2.stars_avg as stars
from movie join (
    select mID, AVG(stars) as stars_avg
    from rating
    group by mID) as rating_2
on movie.mID=rating_2.mID
order by stars desc, title
38
select name
from reviewer
where rID in(
    select rID
    from rating
    group by rID
    having COUNT(rID)&gt;=3)
39
select name
from reviewer
where rID in (
select distinct rID
from rating
where mID in (
    select mID
    from movie
    where title=&#39;Gone with the Wind&#39;))
 40
 select temp.name as name, movie.title as title, temp.stars as stars
    from movie join (
        select rating.stars, reviewer.name, rating.mID
        from rating join reviewer
        on rating.rID=reviewer.rID) as temp
    on movie.mID=temp.mID
    where movie.director=temp.name

</code></pre>
]]></content>
      <categories>
        <category>DataStructure</category>
      </categories>
  </entry>
  <entry>
    <title>技术博客文章导航</title>
    <url>/blog/zn9uh7/</url>
    <content><![CDATA[<p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1612958614228-b6426c9b-8e8d-439a-a122-ba67b94fbf2f.jpeg#align=left&amp;display=inline&amp;height=380&amp;margin=%5Bobject%20Object%5D&amp;name=83945448_p0.jpg&amp;originHeight=2048&amp;originWidth=1448&amp;size=1103943&amp;status=done&amp;style=shadow&amp;width=269" alt="83945448_p0.jpg"></p>
<blockquote>
<p><a href="https://www.wztlink1013.com/blog/">https://www.wztlink1013.com/blog/</a>本站点为我个人技术博客、学习笔记站点</p>
</blockquote>
<table>
<thead>
<tr>
<th>文章分类</th>
<th>分类描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>Bug</td>
<td>日常学习、工作过程中遇到的问题做一个解决的总结</td>
</tr>
<tr>
<td>Environment</td>
<td>Git、GitHub 等开发工具的使用；开发环境的搭建总结</td>
</tr>
<tr>
<td>Hexo</td>
<td>没少折腾的玩意 ~</td>
</tr>
<tr>
<td>数据科学</td>
<td>Python 数据分析</td>
</tr>
<tr>
<td>数据库</td>
<td>我觉得数据库的知识是一个必须要会的模块，所以单独一个模块</td>
</tr>
<tr>
<td>数据结构</td>
<td>数据结构</td>
</tr>
<tr>
<td>算法</td>
<td>算法</td>
</tr>
<tr>
<td>编程语言</td>
<td>语言只是一个工具，既然是工具，就应该放在一块</td>
</tr>
<tr>
<td>人工智能</td>
<td>机器学习入门时写的几篇文章</td>
</tr>
<tr>
<td>后期制作</td>
<td>大学课程的一些笔记，更新少</td>
</tr>
<tr>
<td>Web 开发</td>
<td>Web 开发技术文章，大多是针对新技术</td>
</tr>
<tr>
<td>计算机系统</td>
<td>计算机操作系统、计算机网络</td>
</tr>
<tr>
<td>计算机结构</td>
<td>计算机组成原理、编译原理</td>
</tr>
<tr>
<td>软件工程</td>
<td>软件工程</td>
</tr>
</tbody>
</table>
<h2 id="Bug"><a href="#Bug" class="headerlink" title="Bug"></a>Bug</h2><p><a href="https://www.wztlink1013.com/blog/archives/2021/"><strong>2021 年</strong></a></p>
<ul>
<li><a href="https://www.wztlink1013.com/blog/aiuif3/">IDEA 环境下的 Web 开发 bug 汇总  </a>(2021/02/08 · 标签: ·)</li>
</ul>
<p><a href="https://www.wztlink1013.com/blog/archives/2020/"><strong>2020 年</strong></a></p>
<ul>
<li><a href="https://www.wztlink1013.com/blog/gw1d4z/">hexo-部署出错 at formatNunjucksError </a>(2020/12/03 · 标签: ·)</li>
<li><a href="https://www.wztlink1013.com/blog/gcwu9h/">npm- ERR! Unexpected end of JSON input while parsing </a>(2020/10/27 · 标签: ·)</li>
<li><a href="https://www.wztlink1013.com/blog/fg4az5/">js-Cannot set property ‘innerHTML’ of null </a>(2020/10/26 · 标签: ·)</li>
<li><a href="https://www.wztlink1013.com/blog/oyvpk4/">CPP-LINKfatal error LNK1561: 必须定义入口点  </a>(2020/10/25 · 标签: ·)</li>
<li><a href="https://www.wztlink1013.com/blog/lkgrkx/">IDEA-控制台输出中文乱码问题  </a>(2020/10/25 · 标签: ·)</li>
<li><a href="https://www.wztlink1013.com/blog/wp9hok/">Navicat-1045 报错  </a>(2020/06/11 · 标签: ·)</li>
<li><a href="https://www.wztlink1013.com/blog/wsmygb/">yuque-未拉取成功  </a>(2020/06/01 · 标签: ·)</li>
<li><a href="https://www.wztlink1013.com/blog/pxpix4/">hexo-生成文章出错  </a>(2020/05/31 · 标签: ·)</li>
<li><a href="https://www.wztlink1013.com/blog/pix070/">SSH-登录报错  </a>(2020/05/31 · 标签: ·)</li>
<li><a href="https://www.wztlink1013.com/blog/qp81g3/">[转]java-找不到或无法加载主类  </a>(2020/04/01 · 标签: ·)</li>
<li><a href="https://www.wztlink1013.com/blog/qi1md8/">javaweb-8080 端口被占用  </a>(2020/04/01 · 标签: ·)</li>
<li><a href="https://www.wztlink1013.com/blog/ggg01q/">java-数组越界和格式输出  </a>(2020/03/22 · 标签: ·)</li>
<li><a href="https://www.wztlink1013.com/blog/uatg7m/">python-路径和 nltk </a>(2020/02/07 · 标签: ·)</li>
</ul>
<h2 id="Environment"><a href="#Environment" class="headerlink" title="Environment"></a>Environment</h2><p><a href="https://www.wztlink1013.com/blog/archives/2021/"><strong>2021 年</strong></a></p>
<ul>
<li><a href="https://www.wztlink1013.com/blog/qi1ddv/">IDEA 创建 javaWeb 项目  </a>(2021/02/07 · 标签: ·)</li>
</ul>
<p><a href="https://www.wztlink1013.com/blog/archives/2020/"><strong>2020 年</strong></a></p>
<ul>
<li><a href="https://www.wztlink1013.com/blog/yhxiep/">搭建“文本三巨头”环境  </a>(2020/12/19 · 标签: <a href="https://www.wztlink1013.com/blog/tags/tmux/">tmux</a>, <a href="https://www.wztlink1013.com/blog/tags/vim/">vim</a> ·)</li>
<li><a href="https://www.wztlink1013.com/blog/iwvugw/">GitHub 多人协作功能 Pull requests </a>(2020/12/02 · 标签: ·)</li>
<li><a href="https://www.wztlink1013.com/blog/hgxgvd/">.gitignore 文件使用总结  </a>(2020/11/27 · 标签: ·)</li>
<li><a href="https://www.wztlink1013.com/blog/xnh83z/">搭建 Windows 子系统 Linux </a>(2020/11/09 · 标签: <a href="https://www.wztlink1013.com/blog/tags/Linux/">Linux</a> ·)</li>
<li><a href="https://www.wztlink1013.com/blog/qp5kuu/">GitHub-CICD 不同文件夹迁移  </a>(2020/08/14 · 标签: ·)</li>
<li><a href="https://www.wztlink1013.com/blog/lg6q7n/">git 使用 Token 连接  </a>(2020/07/08 · 标签: ·)</li>
<li><a href="https://www.wztlink1013.com/blog/fnsge3/">git 常见使用总结  </a>(2020/04/06 · 标签: ·)</li>
<li><a href="https://www.wztlink1013.com/blog/ro0lgm/">Eclipse 配置 Tomcat 创建 Servlet </a>(2020/04/02 · 标签: ·)</li>
<li><a href="https://www.wztlink1013.com/blog/fgh5bc/">IDEA 配置 Tomcat </a>(2020/04/02 · 标签: ·)</li>
<li><a href="https://www.wztlink1013.com/blog/at014v/">Eclipse 的使用总结  </a>(2020/04/02 · 标签: ·)</li>
<li><a href="https://www.wztlink1013.com/blog/nvlr2g/">DOS/CMD/Windows/提高开发效率  </a>(2020/02/24 · 标签: <a href="https://www.wztlink1013.com/blog/tags/CMD/">CMD</a>, <a href="https://www.wztlink1013.com/blog/tags/OS/">OS</a> ·)</li>
<li><a href="https://www.wztlink1013.com/blog/pm7mpk/">VScode 使用  </a>(2020/01/28 · 标签: ·)</li>
<li><a href="https://www.wztlink1013.com/blog/cwqx6l/">配置 java 开发环境  </a>(2020/01/27 · 标签: ·)</li>
<li><a href="https://www.wztlink1013.com/blog/mv7tir/">Anaconda+JetBrains 系列软件使用总结  </a>(2020/01/23 · 标签: ·)</li>
<li><a href="https://www.wztlink1013.com/blog/ouipza/">Jupyter 使用总结  </a>(2020/01/22 · 标签: ·)</li>
<li><a href="https://www.wztlink1013.com/blog/qq1dno/">重装系统  </a>(2020/01/18 · 标签: ·)</li>
</ul>
<h2 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h2><ul>
<li><a href="https://www.wztlink1013.com/blog/czl3oc/">VuePress 初体验  </a>(2020/12/21 · 标签: <a href="https://www.wztlink1013.com/blog/tags/vuepress/">vuepress</a> ·)</li>
<li><a href="https://www.wztlink1013.com/blog/uwpbn0/">GitHub Actions 代码汇总  </a>(2020/08/17 · 标签: ·)</li>
<li><a href="https://www.wztlink1013.com/blog/vyeuk3/">GitHub Actions+语雀+serverless 云函数实现 hexo 自动化部署  </a>(2020/07/15 · 标签: <a href="https://www.wztlink1013.com/blog/tags/serverless/">serverless</a> ·)</li>
<li><a href="https://www.wztlink1013.com/blog/bzf30z/">GitHub+PicGo 构建免费图床及其高效使用  </a>(2020/02/25 · 标签: ·)</li>
<li><a href="https://www.wztlink1013.com/blog/erx9hf/">jsDelivr 和 Github 构建免费 CDN </a>(2020/02/25 · 标签: ·)</li>
<li><a href="https://www.wztlink1013.com/HelloWorld/">Hello World </a>(2020/01/04 · 标签: <a href="https://www.wztlink1013.com/blog/tags/Hexo/">Hexo</a> ·)</li>
</ul>
<h2 id="数据科学"><a href="#数据科学" class="headerlink" title="数据科学"></a>数据科学</h2><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><h2 id="编程语言"><a href="#编程语言" class="headerlink" title="编程语言"></a>编程语言</h2><h2 id="人工智能"><a href="#人工智能" class="headerlink" title="人工智能"></a>人工智能</h2><h2 id="后期制作"><a href="#后期制作" class="headerlink" title="后期制作"></a>后期制作</h2><h2 id="Web-开发"><a href="#Web-开发" class="headerlink" title="Web 开发"></a>Web 开发</h2><h2 id="计算机系统"><a href="#计算机系统" class="headerlink" title="计算机系统"></a>计算机系统</h2><h2 id="计算机结构"><a href="#计算机结构" class="headerlink" title="计算机结构"></a>计算机结构</h2><h2 id="软件工程"><a href="#软件工程" class="headerlink" title="软件工程"></a>软件工程</h2>]]></content>
  </entry>
  <entry>
    <title>表基本操作</title>
    <url>/blog/zqbaxc/</url>
    <content><![CDATA[<h1 id="表基本操作"><a href="#表基本操作" class="headerlink" title="表基本操作"></a>表基本操作</h1><h2 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h2><pre><code class="sql">Create table student(
    Sno char(9),
    Same char(20),
    Ssex char(2),
    Sage smallint,
    Sdept char(20)
);
Create table course(
    Cno char(4),
    Cname char(40),
    Cpno char(4),
    Ccredit smallint
);
Create table sc(
    Sno char(9),
    Cno char(4),
    Grade smallint
);
Insert into student values(&#39;200215121&#39;,&#39;李勇&#39;,&#39;男&#39;,20,&#39;cs&#39;);
Insert into student values(&#39;200215122&#39;,&#39;刘晨&#39;,&#39;女&#39;,19,&#39;cs&#39;);
Insert into student values(&#39;200215123&#39;,&#39;王敏&#39;,&#39;女&#39;,18,&#39;ma&#39;);
Insert into student values(&#39;200515124&#39;,&#39;张立&#39;,&#39;男&#39;,19,&#39;is&#39;);
Insert into course values (&#39;1&#39;,&#39;数据库&#39;,&#39;5&#39;,4);
Insert into course values (&#39;2&#39;,&#39;数学&#39;,NULL,2);
Insert into course values(&#39;3&#39;,&#39;信息系统&#39;,&#39;1&#39;,4);
Insert into course values(&#39;4&#39;,&#39;操作系统&#39;,&#39;6&#39;,3);
Insert into course values(&#39;5&#39;,&#39;数据结构&#39;,&#39;7&#39;,4);
Insert into course values(&#39;6&#39;,&#39;数据处理&#39;,NULL,2);
Insert into course values(&#39;7&#39;,&#39;pascal语言&#39;,&#39;6&#39;,4);
Insert into sc values(&#39;200215121&#39;,&#39;1&#39;,92);
Insert into sc values(&#39;200215121&#39;,&#39;2&#39;,85);
Insert into sc values(&#39;200215121&#39;,&#39;3&#39;,88);
Insert into sc values(&#39;200215122&#39;,&#39;2&#39;,90);
Insert into sc values(&#39;200215122&#39;,&#39;3&#39;,80);
</code></pre>
<h2 id="查看表"><a href="#查看表" class="headerlink" title="查看表"></a>查看表</h2><pre><code class="sql">    SHOW TABLES [FROM db_name] [LIKE &#39;pattern&#39;|WHEAR expr];
</code></pre>
<h2 id="查看列（表的组织结构）"><a href="#查看列（表的组织结构）" class="headerlink" title="查看列（表的组织结构）"></a>查看列（表的组织结构）</h2><pre><code class="sql">    SHOW COLUMNS FROM tb_name;
    DESC tb_name;
</code></pre>
<p>以上两条语句都可以。</p>
<h2 id="查看表的内容"><a href="#查看表的内容" class="headerlink" title="查看表的内容"></a>查看表的内容</h2><pre><code class="sql">    SELECT * FROM tb_name;
</code></pre>
<h2 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h2><pre><code class="sql">    INSERT [INTO] tb_name [(col_name,...)] VALUES(val,...);
</code></pre>
<p>如果不指明任何字段名，那么插入的数据必须要包含所有的字段。</p>
<h1 id="插入记录"><a href="#插入记录" class="headerlink" title="插入记录"></a>插入记录</h1><p>共有三种 Insert 语句。</p>
<h2 id="INSERT"><a href="#INSERT" class="headerlink" title="INSERT"></a>INSERT</h2><pre><code class="sql">INSERT [INTO] tb_name [(col_name,.....)] {VALUE|VALUES} ({expr|DEFAULT},...) (...),...
</code></pre>
<ul>
<li>values 是标准 SQL 关键字，value 是 MySQL 自己的。</li>
<li>插入语句可以一次性插入多条记录。</li>
<li>值可以是：<ul>
<li>函数</li>
<li>数学表达式</li>
<li>等</li>
</ul>
</li>
</ul>
<p>默认值</p>
<p>在创建数据表的时候可以设置 DEFAUTL。</p>
<pre><code class="sql">CREATE TABLE users(
    id SAMLLINT UNSIGNED PRIMARY KEY AUTO_INCREMENT,
    username SAMLLINT VARCHAR(20) NOT NULL,
    password SAMLLINT VARCHAR(20) NOT NULL,
    age TINYINT UNSIGNED NOT NULL DEFAULT 10,
    sex BOOLEAN
);
</code></pre>
<p>INSERT 的时候如果为自动编号的字段（比如上表中主键 id）赋值的话，可写作 NULL，或 DEFAULT 就会采用默认值。<br>如果字段设置了 DEFAULT（比如上表中 age），那么值直接写 DEFAULT 就行，注意此时，不能为 NULL。例如：</p>
<pre><code class="sql">INSERT users VALUES(NULL,&#39;TOM&#39;,&#39;123&#39;,DEFAULT,1);
</code></pre>
<h2 id="INSERT…SET"><a href="#INSERT…SET" class="headerlink" title="INSERT…SET"></a>INSERT…SET</h2><pre><code class="sql">INSERT [INTO] tb_name SET col_name={expr|DEFAULT},...
</code></pre>
<p>采用了<a href="%E5%AD%90%E6%9F%A5%E8%AF%A2.md">子查询</a>。例如，上表中插入：</p>
<pre><code class="sql">INSERT users SET username=&#39;Ben&#39;,password=&#39;456&#39;;
</code></pre>
<p>因为 id，和 age 都有默认值，所以可以不写。而 sex 允许为空，也可以不写。</p>
<h2 id="INSERT…SELECT"><a href="#INSERT…SELECT" class="headerlink" title="INSERT…SELECT*"></a>INSERT…SELECT*</h2><p>将查找的结果写入记录中。</p>
<pre><code class="sql">INSERT test(username) SELECT username FROM users WHERE age &gt;=30;
</code></pre>
<h1 id="删除记录"><a href="#删除记录" class="headerlink" title="删除记录"></a>删除记录</h1><p>同样分为：</p>
<ul>
<li>单表删除</li>
<li>多表删除</li>
</ul>
<pre><code class="mysql">DELETE FROM tb_name [WHERE where_condition];
</code></pre>
<p>没有 where 部分则会删除全部记录。</p>
<h1 id="更新记录-单表更新"><a href="#更新记录-单表更新" class="headerlink" title="更新记录-单表更新"></a>更新记录-单表更新</h1><p>更新记录分为：</p>
<ul>
<li>单表更新</li>
<li>多表更新（要涉及连接）</li>
</ul>
<blockquote>
<p>单表更新</p>
</blockquote>
<pre><code class="mysql">UPDATE [LOW_PRIORITY] [IGNORE] tb_reference
SET col_name1={expr|DEFAULT} [,col_name2={expr|DEFAULT}]...
[WHERE where_condition]
</code></pre>
<p>不写 where 会更新全部的记录。</p>
<h1 id="更新记录-连接（多表更新）"><a href="#更新记录-连接（多表更新）" class="headerlink" title="更新记录-连接（多表更新）"></a>更新记录-连接（多表更新）</h1><h2 id="多表更新"><a href="#多表更新" class="headerlink" title="多表更新"></a>多表更新</h2><pre><code class="mysql">UPDATE table_references
SET col_name1={expr1|DEFAULT}
[,col_name2={expr2|DEFAULT}]...
[WHERE where_condition]
</code></pre>
<h2 id="CREATE…SELECT"><a href="#CREATE…SELECT" class="headerlink" title="CREATE…SELECT"></a>CREATE…SELECT</h2><p>创建数据表同时将查询结果写入到数据表</p>
<pre><code class="mysql">CREATE TABLE [IF NOT EXISTS]tb_name
[(create_definetion,...)]
select_statement
</code></pre>
<p>比如：</p>
<pre><code class="mysql">CREATE TABLE tall (
    tall_id SMALLINT UNSIGNED PRIMARY KEY AUTO_INCREMENT,
    num INT
) SELECT 身高 AS num FROM
    av
GROUP BY 身高;
</code></pre>
<p>创建新表 tall，并从 av 表中选取身高字段插入到 tall 表的 num 字段。</p>
<h2 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h2><h3 id="语法结构"><a href="#语法结构" class="headerlink" title="语法结构"></a>语法结构</h3><pre><code class="mysql">table_reference
{[INNER|CROSS] JOIN|{LELT|RIGHT}[OUTER] JOIN}
table_reference
ON conditional_expr
</code></pre>
<p>ON 为条件。<br>三种连接，即：</p>
<ul>
<li>内连接</li>
<li>左外连接</li>
<li>右外连接</li>
</ul>
<h4 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h4><p>显示左表及右表符合连接条件的记录（交集）</p>
<h4 id="左外连接"><a href="#左外连接" class="headerlink" title="左外连接"></a>左外连接</h4><p>显示左表的全部记录及右表符合连接条件的记录</p>
<h4 id="右外连接"><a href="#右外连接" class="headerlink" title="右外连接"></a>右外连接</h4><p>类别左外连接</p>
<h3 id="UPDATE-JOIN-SET"><a href="#UPDATE-JOIN-SET" class="headerlink" title="UPDATE..JOIN..SET"></a>UPDATE..JOIN..SET</h3><p>比如</p>
<pre><code class="mysql">UPDATE actor AS a
        INNER JOIN
    tall AS b ON a.tall = b.num
SET
    a.tall = b.tall_id;
</code></pre>
<p>依据实际情况，选择是否使用别名。（如果两个表中进行比较的字段名相同，则需要别名）<br>该语句完成了一个替换，将 actor 表中具体的身高数值，替换为 tall 表中身高的对应 id。</p>
<h1 id="修改数据表"><a href="#修改数据表" class="headerlink" title="修改数据表"></a>修改数据表</h1><p>所有的数据表的修改 SQL 语句的开头都是 ALTER TABLE+表名称。</p>
<h2 id="给表改名"><a href="#给表改名" class="headerlink" title="给表改名"></a>给表改名</h2><pre><code class="sql">ALTER TABLE tb_name RENAME {TO|AS} tb_new_name;
</code></pre>
<p>另外有个写法是：</p>
<pre><code class="sql">RENAME TABLE tb_name TO tb_new_name;
</code></pre>
<p>这句可以批量修改多个表的名称。</p>
<blockquote>
<p>尽量不要随意修改表的名称。对视图有影响。</p>
</blockquote>
<h2 id="添加-删除列"><a href="#添加-删除列" class="headerlink" title="添加/删除列"></a>添加/删除列</h2><h3 id="插入列"><a href="#插入列" class="headerlink" title="插入列"></a>插入列</h3><pre><code class="sql">ALTER TABLE tb_name ADD [COLUMN] col_name column_definition [FIRST|AFTER col_name];
</code></pre>
<p>默认会插入到表的最下面，指定 FIRST，则置于最上面，或者用<code>AFTER col_name</code> 指定为<code>col_name</code>的下面。</p>
<h3 id="删除列"><a href="#删除列" class="headerlink" title="删除列"></a>删除列</h3><pre><code class="sql">ALTER TABLE tb_name DROP col_name,DROP.....;
</code></pre>
<p>可以一次性删除多个列。</p>
<h2 id="修改列"><a href="#修改列" class="headerlink" title="修改列"></a>修改列</h2><h3 id="修改列定义"><a href="#修改列定义" class="headerlink" title="修改列定义"></a>修改列定义</h3><p>即修改列的属性。</p>
<pre><code class="sql">ALTER TABLE tb_name MODIFY col_name column_definition [FIRST|AFTER col_name];
</code></pre>
<p>比如：</p>
<pre><code class="sql">ALTER TABLE test ADD id SMALLINT unsigned KEY auto_increment first;
</code></pre>
<p>key 可以表示主键，无需 primary。fitrst 表示插入的位置。</p>
<blockquote>
<p>如果要修改的列已经是<code>主键</code>了，则修改列定义的时候再加上<code>主键</code>字段会报错。</p>
</blockquote>
<h3 id="修改列名"><a href="#修改列名" class="headerlink" title="修改列名"></a>修改列名</h3><pre><code class="sql">ALTER TABLE tb_name CHANGE col_name col_new_name column_definition [FIRST|AFTER col_name];
</code></pre>
<p>修改列名时，新列名后面要指明数据类型。</p>
<h3 id="修改列顺序"><a href="#修改列顺序" class="headerlink" title="修改列顺序"></a>修改列顺序</h3><p>其实同上，具体比如：</p>
<pre><code class="sql">ALTER TABLE `user` CHANGE `join_time` `join_time` DATE NULL DEFAULT NULL AFTER `role`;
</code></pre>
<p>把 join_time 列放到 role 列后面。</p>
<h2 id="修改约束"><a href="#修改约束" class="headerlink" title="修改约束"></a>修改约束</h2><h3 id="PRIMARY-KEY"><a href="#PRIMARY-KEY" class="headerlink" title="PRIMARY KEY"></a>PRIMARY KEY</h3><p>添加主键约束</p>
<pre><code class="sql">ALTER TABLE tb_name ADD [CONSTRAIN[symbol]] PRIMARY KEY [index.type] (index_col_name,.....);
</code></pre>
<p>删除主键约束</p>
<pre><code class="sql">ALTER TABLE tb_name DROP [index.type] PRIMARY KEY;
</code></pre>
<p>不需要指定列名，因为每个表只有一个主键。<br>注意！只有一个主键并不意味着主键只有一列。</p>
<h3 id="UNIQUE"><a href="#UNIQUE" class="headerlink" title="UNIQUE"></a>UNIQUE</h3><p>添加唯一约束</p>
<pre><code class="sql">ALTER TABLE tb_name ADD [index.type] unique(col_name);
</code></pre>
<p>删除唯一约束</p>
<pre><code class="sql">ALTER TABLE tb_name DROP [index.type] unique(col_name);
</code></pre>
<h3 id="DEFAULT"><a href="#DEFAULT" class="headerlink" title="DEFAULT"></a>DEFAULT</h3><pre><code class="sql">ALTER TABLE tb_name ALTER [COLUMN] col_name {SET DEFAULT literal|DROP DEFAULT};
for example:
ALTER TABLE users ALTER age SET DEFAULT 20;
</code></pre>
<h3 id="FOREIGN-KEY"><a href="#FOREIGN-KEY" class="headerlink" title="FOREIGN KEY"></a>FOREIGN KEY</h3><p>添加外键约束</p>
<pre><code class="sql">ALTER TABLE tb_name ADD [CONSTRAIN[symbol]] FOREIGN KEY [index_name](index_col_name,...)reference_definition;
for example:
ALTER TABLE users add FOREIGN KEY (pid) REFERENCE provinces (id);
</code></pre>
<p>删除外键约束</p>
<pre><code class="sql">ALTER TABLE tb_name DROP FOREIGN KEY fk_symbol;
</code></pre>
]]></content>
      <categories>
        <category>Language</category>
      </categories>
  </entry>
  <entry>
    <title>队列设计</title>
    <url>/blog/zqmygi/</url>
    <content><![CDATA[<h2 id="Queue-队列设计"><a href="#Queue-队列设计" class="headerlink" title="Queue 队列设计"></a>Queue 队列设计</h2><blockquote>
<p>在头尾两端进行操作，先进先出 FIFO</p>
</blockquote>
<p>队列的接口设计</p>
<pre><code class="java">int size(); //队列元素个数
boolean isEmpty(); //队列是否为空
void clear(); //清空队列元素
void enQueue(E element); //入队
E deQueue(); // 出队
E front(); //获取队列的头元素
</code></pre>
<pre><code class="java">package com.wztlink1013.ds.queue;

import com.wztlink1013.ds.queue.list.LinkedList;
import com.wztlink1013.ds.queue.list.List;

public class Queue&lt;E&gt; {
    private List&lt;E&gt; list = new LinkedList&lt;&gt;();

    public int size() {
        return list.size();
    }

    public boolean isEmpty() {
        return list.isEmpty();
    }

    public void clear() {
        list.clear();
    }

    public void enQueue(E element) {
        list.add(element);
    }

    public E deQueue() {
        return list.remove(0);
    }

    public E front() {
        return list.get(0);
    }
}
</code></pre>
<h2 id="Deque-双端队列设计"><a href="#Deque-双端队列设计" class="headerlink" title="Deque 双端队列设计"></a>Deque 双端队列设计</h2><blockquote>
<p>双端队列是能在头尾两端添加、删除的队列</p>
</blockquote>
<pre><code class="java">package com.wztlink1013.ds.queue;

import com.wztlink1013.ds.queue.list.LinkedList;
import com.wztlink1013.ds.queue.list.List;

public class Deque&lt;E&gt; {
    private List&lt;E&gt; list = new LinkedList&lt;&gt;();

    public int size() {
        return list.size();
    }

    public boolean isEmpty() {
        return list.isEmpty();
    }

    public void clear() {
        list.clear();
    }

    public void enQueueRear(E element) {
        list.add(element);
    }

    public E deQueueFront() {
        return list.remove(0);
    }

    public void enQueueFront(E element) {
        list.add(0, element);
    }

    public E deQueueRear() {
        return list.remove(list.size() - 1);
    }

    public E front() {
        return list.get(0);
    }

    public E rear() {
        return list.get(list.size() - 1);
    }
}
</code></pre>
]]></content>
      <categories>
        <category>DataStructure</category>
      </categories>
  </entry>
  <entry>
    <title>爬虫框架和Scrapy使用</title>
    <url>/blog/zsvfxg/</url>
    <content><![CDATA[<h2 id="一、爬虫基本架构"><a href="#一、爬虫基本架构" class="headerlink" title="一、爬虫基本架构"></a>一、爬虫基本架构</h2><h3 id="url-管理模块"><a href="#url-管理模块" class="headerlink" title="url 管理模块"></a>url 管理模块</h3><ul>
<li>就是管理自己爬取的的网页不要重复爬取，避免爬取进入死循环</li>
<li>使用 python 当中的 set 数据结构</li>
</ul>
<h3 id="网页下载模块"><a href="#网页下载模块" class="headerlink" title="网页下载模块"></a>网页下载模块</h3><blockquote>
<p>将对应的 url 模块下载到本地或者读入内存</p>
</blockquote>
<blockquote>
<p>实现方式</p>
</blockquote>
<ul>
<li>通过 url 下载</li>
</ul>
<pre><code class="python">from urllib.request import urlopen
test_url = &quot;https://wztlink1013.github.io&quot;
response = urlopen(test_url)
print (response.getcode()) # 200 表示访问成功
print (response.read())
</code></pre>
<ul>
<li>通过 Request 访问</li>
<li>通过 cookie 访问</li>
</ul>
<h3 id="网页解析模块"><a href="#网页解析模块" class="headerlink" title="网页解析模块"></a>网页解析模块</h3><blockquote>
<p>从已经下载的网页中爬取数据，实现方式有：</p>
</blockquote>
<ol>
<li>正则表达式</li>
<li>html.parser</li>
<li><strong>BeautifulSoup：结构化解析网页</strong></li>
<li>lxml</li>
<li>结构化解析</li>
<li>DOM（Document Object Model），树形结构，就是 html 的基本骨架</li>
</ol>
<h2 id="二、BeautifulSoup-解析网页"><a href="#二、BeautifulSoup-解析网页" class="headerlink" title="二、BeautifulSoup 解析网页"></a>二、BeautifulSoup 解析网页</h2><h2 id="三、Scrapy"><a href="#三、Scrapy" class="headerlink" title="三、Scrapy"></a>三、Scrapy</h2><h3 id="Scrapy-基础"><a href="#Scrapy-基础" class="headerlink" title="Scrapy 基础"></a>Scrapy 基础</h3><ul>
<li>是一个爬虫框架，同时易扩展，可以添加新的模块达到自定义扩展</li>
<li>输出格式多样：json，csv，xml 等</li>
<li>自动处理编码</li>
</ul>
<h3 id="Scrapy-框架架构图"><a href="#Scrapy-框架架构图" class="headerlink" title="Scrapy 框架架构图"></a>Scrapy 框架架构图</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/webp/1484158/1598673193957-7a7456b0-3de1-4c77-b849-cc2572555ed5.webp#align=left&amp;display=inline&amp;height=281&amp;margin=%5Bobject%20Object%5D&amp;originHeight=541&amp;originWidth=801&amp;size=0&amp;status=done&amp;style=shadow&amp;width=416" alt></p>
<blockquote>
<p>下载方法以及问题，在 anaconda 博客中</p>
</blockquote>
<h2 id="四、Scrapy-使用"><a href="#四、Scrapy-使用" class="headerlink" title="四、Scrapy 使用"></a>四、Scrapy 使用</h2><h3 id="使用-SOP"><a href="#使用-SOP" class="headerlink" title="使用 SOP"></a>使用 SOP</h3><ul>
<li>创建工程<ul>
<li>键入<code>cmd</code> <code>cd</code>到需要下载的目录下</li>
<li>输入<code>scrapy startproject tutorial</code>（最后是项目名字）</li>
<li><strong>!此后所有有关命令的操作，均在下一级文件夹下，也有是有 cfg 文件后缀的文件夹下</strong></li>
</ul>
</li>
<li>定义 Item，构造爬取的对象</li>
<li>编写 spider，爬虫主体<ul>
<li><code>scrapy genspider amazon_spider https://……</code></li>
</ul>
</li>
<li>pipelines，默认 return item</li>
<li>编写其他配置，其中 pipeline 用于处理爬取后所得到的结果</li>
<li>执行爬虫<ul>
<li><code>scrapy crawl amazon_spider</code></li>
</ul>
</li>
</ul>
<h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li>查看其官方文档</li>
<li><a href="https://www.jianshu.com/p/8023fccd7206" target="_blank" rel="noopener">简书</a></li>
</ul>
]]></content>
      <categories>
        <category>DataAnalysis</category>
      </categories>
  </entry>
  <entry>
    <title>鸟儿飞走了</title>
    <url>/essay/pyxkf8/</url>
    <content><![CDATA[<p>学校又要建楼了，地点是图书馆靠西边的那片树林。</p>
<p>去二餐的靠建筑工地的那条沿路上，总是听到叽叽喳喳的小鸟叫声，定睛一看，原来是因建筑而没有去路的小鸟，它们就在那片矮秃秃的草丛里面，就像是饿了的稚鸟在窝里面叽叽喳喳等它们母亲回来一般。</p>
<p>“济南一建”的速度真是快，短短一个月不到，那栋楼就建成有二、三层高楼那般模样，可我却不太喜欢它们这么快速度，因为那样，就会挡住我在 E 区各个楼道往学校南边观去的视线，正好挡住学校后面的双龙山，学校的小鸟也会少了，估计它们会生气般地往山上飞去，不再飞回来了。</p>
<p>为什么我会有些许的伤感……</p>
]]></content>
      <categories>
        <category>生活随笔</category>
      </categories>
  </entry>
  <entry>
    <title>榕树下的男孩和女孩</title>
    <url>/essay/rqlvig/</url>
    <content><![CDATA[<p>趁着伙伴们都还在睡觉那天还未入夜，他朝着桥的那头跑去，那天月亮高高挂起，像是蒙娜丽莎的那般深邃眼眸观望着他，突然，他像是被什么东西拍打了一下，男孩往后望去，是个小女孩，那女孩头发短短的，头发末梢还有些卷卷的，就像是柳树下的枝柳发梢一般，凌乱有致，最重要的是男孩被那饱含星辰大海的眼眸所吸引，还有那唇……小男孩突然一愣，回应道：“你是谁？”女孩说：“我练完了，想去桥的那头玩玩！”男孩惊讶之，连忙回应：“我也是”，榕树那边的风景亦是观之，却不能让我陶醉，说罢，小男孩帮那个小女孩整理一番身边的杂草，他想牵起哪个女孩的手，但是他并没有，他在害怕吗？不知道。我想可能是他没有这般前期过别人的手吧。</p>
<p>桥的那头好漂亮，哪里有些许的繁华，还有些唱作，同时传来了一阵阵的童谣响起，那个女孩心里一颤，她说，如熟悉的唱作，和我家乡一般，她说她听到了她儿时的童谣，男孩向她的眼眸观去，他像是看到了星辰，他瞬间感受到一种温度，是的！他喜欢上她了。</p>
<p>榕树下的人们，是有着各自的命运的，男孩和女孩，男孩子要往前走，因为这里的人们是不能停滞的。因为它们本该如此。</p>
<p>男孩终于忍不住了，他对女孩说：“你喜欢这个童谣吗？”女孩说：“好感动，能在这个地方听到这个童谣”，女孩有一个动作，她用手指收起了她的眼泪，男孩心里想着，桥是禁忌，按照他们的文明，那是他们不能逾越的禁忌。</p>
<p>旁边的蛐蛐们开始了，仿佛开始为那童谣奏乐了，周围很喧闹，但是他的内心足够安静的，一切都是那般静，那一瞬间，那个男孩就像静静地享受着这般安静与温暖，就像是圆月下的海面，波光涟漪却也有着阵阵波澜。</p>
<p>桥就像是时间的奴隶，夜深了，桥头的那根锁链开始叮叮叮~的响起，像是提醒着失足的孩子们该回去了，男孩和女孩的时间不读了，往日，男孩会跑着回桥的那头榕树下，来日再来看看这繁华的都市，然后回到榕树下面，因为本该如此，他比谁都清楚榕树下的他背负着怎么样的命运。</p>
<p>黑夜里，男孩再也看不见女孩的脸，月光很圆，周围的灯也是明亮着的，但男孩却觉得周围一切都是暗淡的，因为他再也看不见那深邃的眼眸。</p>
<p>女孩对男孩说：“谢谢你帮我越过那座桥，我才有了这般幸运，在这榕树下的文明之外还能听到这般旋律，谢谢你！”</p>
<p>但是男孩心里想要的不是这句谢谢，是她眼神之下的温暖的星辰大海，因为他一直往前走，修炼。</p>
<p>他想要在榕树下成为一个真正的男人，特立独行，无惧生死，因为他觉得，他本该如此！可今天，他似乎被他的脸庞融化了。</p>
<p>一路上，男孩和女孩说着话，他从来没有这般欣喜，来到榕树下面，这个新生的文明之下，可是，女孩的话却在变少。</p>
<p>回到榕树下，隧道已经慢慢如期开启，男孩和女孩要走了，男孩心里清楚着，他不会再见她了，他心里忧伤，却也无奈，因为，在此之下的文明，亦是如此，就像是之前所述的“内壁”那般文明、国度。或者还可以说，文明之间，男孩和女孩是不合适的，因为她走的和他走的路从一开始就是相反的道路，但在榕树下的男孩确实一直以来有着思想的精灵，他有些忍不住了，在女孩走向隧道那扇门之前那么一瞬，男孩大声说：“喂，你，你的眼睛很好看，虽然夜太黑，但我心里还记得，我喜欢你，喜欢你喜欢的童谣，喜欢你眼睛中的星辰大海！我从没有想过，在榕树下的文明，还能遇见此般的你。还有，我很喜欢你的微笑。”女孩说：“嗯。”</p>
<p>_2020.10.12 文渊楼 C 区 255 _<br><em>计网老师有点事没来上课，高保忠老师来代课了</em></p>
]]></content>
      <categories>
        <category>生活随笔</category>
      </categories>
  </entry>
  <entry>
    <title>数据的清洗和规整（二）</title>
    <url>/blog/dggm37/</url>
    <content><![CDATA[<h2 id="三、数据规整-连接-含索引"><a href="#三、数据规整-连接-含索引" class="headerlink" title="三、数据规整-连接-含索引"></a>三、数据规整-连接-含索引</h2><ul>
<li>数据连接 merge</li>
</ul>
<pre><code class="python">import pandas as pd
import numpy as np
</code></pre>
<pre><code class="python">df_obj1 = pd.DataFrame({&#39;key&#39;: [&#39;b&#39;, &#39;b&#39;, &#39;a&#39;, &#39;c&#39;, &#39;a&#39;, &#39;a&#39;, &#39;b&#39;],
                        &#39;data1&#39; : [&#39;sfd&#39;,&#39;fdsf&#39;,&#39;we&#39;,24,3253,234,23]})
df_obj2 = pd.DataFrame({&#39;key&#39;: [&#39;a&#39;, &#39;b&#39;, &#39;d&#39;],
                        &#39;data2&#39; : np.random.randint(0,10,3)})

print (df_obj1)
print (df_obj2)
</code></pre>
<pre><code>  key data1
0   b   sfd
1   b  fdsf
2   a    we
3   c    24
4   a  3253
5   a   234
6   b    23
  key  data2
0   a      0
1   b      6
2   d      6
</code></pre><h3 id="merge-和-on"><a href="#merge-和-on" class="headerlink" title="merge 和 on"></a>merge 和 on</h3><blockquote>
<p>默认将重叠列的列名作为“外键”进行连接</p>
</blockquote>
<pre><code class="python">pd.merge(df_obj1, df_obj2)
</code></pre>
<table>
<thead>
<tr>
<th></th>
<th>key</th>
<th>data1</th>
<th>data2</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>b</td>
<td>sfd</td>
<td>6</td>
</tr>
<tr>
<td>1</td>
<td>b</td>
<td>fdsf</td>
<td>6</td>
</tr>
<tr>
<td>2</td>
<td>b</td>
<td>23</td>
<td>6</td>
</tr>
<tr>
<td>3</td>
<td>a</td>
<td>we</td>
<td>0</td>
</tr>
<tr>
<td>4</td>
<td>a</td>
<td>3253</td>
<td>0</td>
</tr>
<tr>
<td>5</td>
<td>a</td>
<td>234</td>
<td>0</td>
</tr>
</tbody>
</table>
<pre><code class="python"># on显示指定“外键”
pd.merge(df_obj1, df_obj2, on=&#39;key&#39;)
</code></pre>
<table>
<thead>
<tr>
<th></th>
<th>key</th>
<th>data1</th>
<th>data2</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>b</td>
<td>sfd</td>
<td>6</td>
</tr>
<tr>
<td>1</td>
<td>b</td>
<td>fdsf</td>
<td>6</td>
</tr>
<tr>
<td>2</td>
<td>b</td>
<td>23</td>
<td>6</td>
</tr>
<tr>
<td>3</td>
<td>a</td>
<td>we</td>
<td>0</td>
</tr>
<tr>
<td>4</td>
<td>a</td>
<td>3253</td>
<td>0</td>
</tr>
<tr>
<td>5</td>
<td>a</td>
<td>234</td>
<td>0</td>
</tr>
</tbody>
</table>
<h3 id="left-on-和-right-on"><a href="#left-on-和-right-on" class="headerlink" title="left-on 和 right-on"></a>left-on 和 right-on</h3><pre><code class="python"># left_on，right_on分别指定左侧数据和右侧数据的“外键”

# 更改列名
df_obj1 = df_obj1.rename(columns={&#39;key&#39;:&#39;key1&#39;})
df_obj2 = df_obj2.rename(columns={&#39;key&#39;:&#39;key2&#39;})
</code></pre>
<pre><code class="python">print(df_obj1)
print(df_obj2)
</code></pre>
<pre><code>  key1 data1
0    b   sfd
1    b  fdsf
2    a    we
3    c    24
4    a  3253
5    a   234
6    b    23
  key2  data2
0    a      0
1    b      6
2    d      6
</code></pre><pre><code class="python">pd.merge(df_obj1, df_obj2, left_on=&#39;key1&#39;, right_on=&#39;key2&#39;)
</code></pre>
<table>
<thead>
<tr>
<th></th>
<th>key1</th>
<th>data1</th>
<th>key2</th>
<th>data2</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>b</td>
<td>sfd</td>
<td>b</td>
<td>6</td>
</tr>
<tr>
<td>1</td>
<td>b</td>
<td>fdsf</td>
<td>b</td>
<td>6</td>
</tr>
<tr>
<td>2</td>
<td>b</td>
<td>23</td>
<td>b</td>
<td>6</td>
</tr>
<tr>
<td>3</td>
<td>a</td>
<td>we</td>
<td>a</td>
<td>0</td>
</tr>
<tr>
<td>4</td>
<td>a</td>
<td>3253</td>
<td>a</td>
<td>0</td>
</tr>
<tr>
<td>5</td>
<td>a</td>
<td>234</td>
<td>a</td>
<td>0</td>
</tr>
</tbody>
</table>
<h3 id="how"><a href="#how" class="headerlink" title="how"></a>how</h3><pre><code class="python"># “外连接”
pd.merge(df_obj1, df_obj2, left_on=&#39;key1&#39;, right_on=&#39;key2&#39;, how=&#39;outer&#39;)
</code></pre>
<table>
<thead>
<tr>
<th></th>
<th>key1</th>
<th>data1</th>
<th>key2</th>
<th>data2</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>b</td>
<td>sfd</td>
<td>b</td>
<td>6.0</td>
</tr>
<tr>
<td>1</td>
<td>b</td>
<td>fdsf</td>
<td>b</td>
<td>6.0</td>
</tr>
<tr>
<td>2</td>
<td>b</td>
<td>23</td>
<td>b</td>
<td>6.0</td>
</tr>
<tr>
<td>3</td>
<td>a</td>
<td>we</td>
<td>a</td>
<td>0.0</td>
</tr>
<tr>
<td>4</td>
<td>a</td>
<td>3253</td>
<td>a</td>
<td>0.0</td>
</tr>
<tr>
<td>5</td>
<td>a</td>
<td>234</td>
<td>a</td>
<td>0.0</td>
</tr>
<tr>
<td>6</td>
<td>c</td>
<td>24</td>
<td>NaN</td>
<td>NaN</td>
</tr>
<tr>
<td>7</td>
<td>NaN</td>
<td>NaN</td>
<td>d</td>
<td>6.0</td>
</tr>
</tbody>
</table>
<pre><code class="python"># 左连接
pd.merge(df_obj1, df_obj2, left_on=&#39;key1&#39;, right_on=&#39;key2&#39;, how=&#39;left&#39;)
</code></pre>
<table>
<thead>
<tr>
<th></th>
<th>key1</th>
<th>data1</th>
<th>key2</th>
<th>data2</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>b</td>
<td>sfd</td>
<td>b</td>
<td>6.0</td>
</tr>
<tr>
<td>1</td>
<td>b</td>
<td>fdsf</td>
<td>b</td>
<td>6.0</td>
</tr>
<tr>
<td>2</td>
<td>a</td>
<td>we</td>
<td>a</td>
<td>0.0</td>
</tr>
<tr>
<td>3</td>
<td>c</td>
<td>24</td>
<td>NaN</td>
<td>NaN</td>
</tr>
<tr>
<td>4</td>
<td>a</td>
<td>3253</td>
<td>a</td>
<td>0.0</td>
</tr>
<tr>
<td>5</td>
<td>a</td>
<td>234</td>
<td>a</td>
<td>0.0</td>
</tr>
<tr>
<td>6</td>
<td>b</td>
<td>23</td>
<td>b</td>
<td>6.0</td>
</tr>
</tbody>
</table>
<pre><code class="python"># 右连接
pd.merge(df_obj1, df_obj2, left_on=&#39;key1&#39;, right_on=&#39;key2&#39;, how=&#39;right&#39;)
</code></pre>
<table>
<thead>
<tr>
<th></th>
<th>key1</th>
<th>data1</th>
<th>key2</th>
<th>data2</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>b</td>
<td>sfd</td>
<td>b</td>
<td>6</td>
</tr>
<tr>
<td>1</td>
<td>b</td>
<td>fdsf</td>
<td>b</td>
<td>6</td>
</tr>
<tr>
<td>2</td>
<td>b</td>
<td>23</td>
<td>b</td>
<td>6</td>
</tr>
<tr>
<td>3</td>
<td>a</td>
<td>we</td>
<td>a</td>
<td>0</td>
</tr>
<tr>
<td>4</td>
<td>a</td>
<td>3253</td>
<td>a</td>
<td>0</td>
</tr>
<tr>
<td>5</td>
<td>a</td>
<td>234</td>
<td>a</td>
<td>0</td>
</tr>
<tr>
<td>6</td>
<td>NaN</td>
<td>NaN</td>
<td>d</td>
<td>6</td>
</tr>
</tbody>
</table>
<h3 id="处理重复列名-suffixes"><a href="#处理重复列名-suffixes" class="headerlink" title="处理重复列名 suffixes"></a>处理重复列名 suffixes</h3><pre><code class="python"># 处理重复列名
df_obj1 = pd.DataFrame({&#39;key&#39;: [&#39;b&#39;, &#39;b&#39;, &#39;a&#39;, &#39;c&#39;, &#39;a&#39;, &#39;a&#39;, &#39;b&#39;],
                        &#39;data&#39; : np.random.randint(0,10,7)})
df_obj2 = pd.DataFrame({&#39;key&#39;: [&#39;a&#39;, &#39;b&#39;, &#39;d&#39;],
                        &#39;data&#39; : np.random.randint(0,10,3)})

pd.merge(df_obj1, df_obj2, on=&#39;key&#39;, suffixes=(&#39;_left&#39;, &#39;_right&#39;))
</code></pre>
<table>
<thead>
<tr>
<th></th>
<th>key</th>
<th>data_left</th>
<th>data_right</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>b</td>
<td>9</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>b</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>2</td>
<td>b</td>
<td>6</td>
<td>1</td>
</tr>
<tr>
<td>3</td>
<td>a</td>
<td>7</td>
<td>1</td>
</tr>
<tr>
<td>4</td>
<td>a</td>
<td>3</td>
<td>1</td>
</tr>
<tr>
<td>5</td>
<td>a</td>
<td>4</td>
<td>1</td>
</tr>
</tbody>
</table>
<pre><code class="python"># 按索引连接
df_obj3 = pd.DataFrame({&#39;key&#39;: [&#39;b&#39;, &#39;b&#39;, &#39;a&#39;, &#39;c&#39;, &#39;a&#39;, &#39;a&#39;, &#39;b&#39;],
                        &#39;data1&#39; : np.random.randint(0,10,7)})
df_obj4 = pd.DataFrame({&#39;data2&#39; : np.random.randint(0,10,3)}, index=[&#39;a&#39;, &#39;b&#39;, &#39;d&#39;])
</code></pre>
<pre><code class="python">print(df_obj3)
print(df_obj4)
</code></pre>
<pre><code>  key  data1
0   b      7
1   b      4
2   a      1
3   c      9
4   a      2
5   a      9
6   b      7
   data2
a      9
b      4
d      0
</code></pre><pre><code class="python">pd.merge(df_obj3, df_obj4, left_on=&#39;key&#39;, right_index=True)
</code></pre>
<table>
<thead>
<tr>
<th></th>
<th>key</th>
<th>data1</th>
<th>data2</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>b</td>
<td>7</td>
<td>4</td>
</tr>
<tr>
<td>1</td>
<td>b</td>
<td>4</td>
<td>4</td>
</tr>
<tr>
<td>6</td>
<td>b</td>
<td>7</td>
<td>4</td>
</tr>
<tr>
<td>2</td>
<td>a</td>
<td>1</td>
<td>9</td>
</tr>
<tr>
<td>4</td>
<td>a</td>
<td>2</td>
<td>9</td>
</tr>
<tr>
<td>5</td>
<td>a</td>
<td>9</td>
<td>9</td>
</tr>
</tbody>
</table>
<h3 id="按索引连接-right-index"><a href="#按索引连接-right-index" class="headerlink" title="按索引连接 right_index"></a>按索引连接 right_index</h3><pre><code class="python"># 按索引连接
df_obj1 = pd.DataFrame({&#39;key&#39;: [&#39;b&#39;, &#39;b&#39;, &#39;a&#39;, &#39;c&#39;, &#39;a&#39;, &#39;a&#39;, &#39;b&#39;],
                        &#39;data1&#39; : np.random.randint(0,10,7)})
df_obj2 = pd.DataFrame({&#39;data2&#39; : np.random.randint(0,10,3)}, index=[&#39;a&#39;, &#39;b&#39;, &#39;d&#39;])
</code></pre>
<pre><code class="python">print(df_obj1)
print(df_obj2)
</code></pre>
<pre><code>  key  data1
0   b      0
1   b      2
2   a      7
3   c      3
4   a      1
5   a      1
6   b      6
   data2
a      2
b      1
d      1
</code></pre><pre><code class="python">pd.merge(df_obj1, df_obj2, left_on=&#39;key&#39;, right_index=True)
</code></pre>
<table>
<thead>
<tr>
<th></th>
<th>key</th>
<th>data1</th>
<th>data2</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>b</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>b</td>
<td>2</td>
<td>1</td>
</tr>
<tr>
<td>6</td>
<td>b</td>
<td>6</td>
<td>1</td>
</tr>
<tr>
<td>2</td>
<td>a</td>
<td>7</td>
<td>2</td>
</tr>
<tr>
<td>4</td>
<td>a</td>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td>5</td>
<td>a</td>
<td>1</td>
<td>2</td>
</tr>
</tbody>
</table>
<h2 id="四、数据合并"><a href="#四、数据合并" class="headerlink" title="四、数据合并"></a>四、数据合并</h2><ul>
<li>数据合并 concat</li>
<li>按索引连接===right_index</li>
</ul>
<pre><code class="python">import numpy as np
import pandas as pd
</code></pre>
<h3 id="numpy-的-concat"><a href="#numpy-的-concat" class="headerlink" title="numpy 的 concat"></a>numpy 的 concat</h3><pre><code class="python">arr1 = np.random.randint(0, 10, (3, 4))
arr2 = np.random.randint(0, 10, (3, 4))

print (arr1)
print (arr2)
</code></pre>
<pre><code>[[6 0 3 2]
 [5 7 9 8]
 [5 8 0 3]]
[[6 5 7 9]
 [0 1 0 0]
 [1 1 1 7]]
</code></pre><pre><code class="python">np.concatenate([arr1, arr2])
</code></pre>
<pre><code>array([[6, 0, 3, 2],
       [5, 7, 9, 8],
       [5, 8, 0, 3],
       [6, 5, 7, 9],
       [0, 1, 0, 0],
       [1, 1, 1, 7]])
</code></pre><pre><code class="python">np.concatenate([arr1, arr2], axis=1)
</code></pre>
<pre><code>array([[6, 0, 3, 2, 6, 5, 7, 9],
       [5, 7, 9, 8, 0, 1, 0, 0],
       [5, 8, 0, 3, 1, 1, 1, 7]])
</code></pre><h3 id="series-上的-concat"><a href="#series-上的-concat" class="headerlink" title="series 上的 concat"></a>series 上的 concat</h3><pre><code class="python"># index 没有重复的情况
ser_obj1 = pd.Series(np.random.randint(0, 10, 5), index=range(0,5))
ser_obj2 = pd.Series(np.random.randint(0, 10, 4), index=range(5,9))
ser_obj3 = pd.Series(np.random.randint(0, 10, 3), index=range(9,12))
</code></pre>
<pre><code class="python">pd.concat([ser_obj1, ser_obj2, ser_obj3])
</code></pre>
<pre><code>0     0
1     4
2     5
3     1
4     9
5     7
6     8
7     5
8     0
9     5
10    9
11    0
dtype: int32
</code></pre><pre><code class="python">pd.concat([ser_obj1, ser_obj2, ser_obj3], axis=1)
</code></pre>
<table>
<thead>
<tr>
<th></th>
<th>0</th>
<th>1</th>
<th>2</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0.0</td>
<td>NaN</td>
<td>NaN</td>
</tr>
<tr>
<td>1</td>
<td>4.0</td>
<td>NaN</td>
<td>NaN</td>
</tr>
<tr>
<td>2</td>
<td>5.0</td>
<td>NaN</td>
<td>NaN</td>
</tr>
<tr>
<td>3</td>
<td>1.0</td>
<td>NaN</td>
<td>NaN</td>
</tr>
<tr>
<td>4</td>
<td>9.0</td>
<td>NaN</td>
<td>NaN</td>
</tr>
<tr>
<td>5</td>
<td>NaN</td>
<td>7.0</td>
<td>NaN</td>
</tr>
<tr>
<td>6</td>
<td>NaN</td>
<td>8.0</td>
<td>NaN</td>
</tr>
<tr>
<td>7</td>
<td>NaN</td>
<td>5.0</td>
<td>NaN</td>
</tr>
<tr>
<td>8</td>
<td>NaN</td>
<td>0.0</td>
<td>NaN</td>
</tr>
<tr>
<td>9</td>
<td>NaN</td>
<td>NaN</td>
<td>5.0</td>
</tr>
<tr>
<td>10</td>
<td>NaN</td>
<td>NaN</td>
<td>9.0</td>
</tr>
<tr>
<td>11</td>
<td>NaN</td>
<td>NaN</td>
<td>0.0</td>
</tr>
</tbody>
</table>
<pre><code class="python"># index 有重复的情况
ser_obj1 = pd.Series(np.random.randint(0, 10, 5), index=range(5))
ser_obj2 = pd.Series(np.random.randint(0, 10, 4), index=range(4))
ser_obj3 = pd.Series(np.random.randint(0, 10, 3), index=range(3))

print (ser_obj1)
print (ser_obj2)
print (ser_obj3)
</code></pre>
<pre><code>0    5
1    3
2    0
3    8
4    3
dtype: int32
0    5
1    3
2    2
3    1
dtype: int32
0    5
1    8
2    6
dtype: int32
</code></pre><pre><code class="python">pd.concat([ser_obj1, ser_obj2, ser_obj3])
</code></pre>
<pre><code>0    5
1    3
2    0
3    8
4    3
0    5
1    3
2    2
3    1
0    5
1    8
2    6
dtype: int32
</code></pre><pre><code class="python">pd.concat([ser_obj1, ser_obj2, ser_obj3], axis=1, join=&#39;inner&#39;)
</code></pre>
<table>
<thead>
<tr>
<th></th>
<th>0</th>
<th>1</th>
<th>2</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>5</td>
<td>5</td>
<td>5</td>
</tr>
<tr>
<td>1</td>
<td>3</td>
<td>3</td>
<td>8</td>
</tr>
<tr>
<td>2</td>
<td>0</td>
<td>2</td>
<td>6</td>
</tr>
</tbody>
</table>
<h3 id="dataframe-上的-concat"><a href="#dataframe-上的-concat" class="headerlink" title="dataframe 上的 concat"></a>dataframe 上的 concat</h3><pre><code class="python">df_obj1 = pd.DataFrame(np.random.randint(0, 10, (3, 2)), index=[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;],
                       columns=[&#39;A&#39;, &#39;B&#39;])
df_obj2 = pd.DataFrame(np.random.randint(0, 10, (2, 2)), index=[&#39;a&#39;, &#39;b&#39;],
                       columns=[&#39;C&#39;, &#39;D&#39;])
print (df_obj1)
print (df_obj2)
</code></pre>
<pre><code>   A  B
a  4  3
b  8  1
c  6  3
   C  D
a  1  3
b  8  2
</code></pre><pre><code class="python">pd.concat([df_obj1, df_obj2])
</code></pre>
<pre><code>C:\Users\wztli\Anaconda3\lib\site-packages\ipykernel_launcher.py:1: FutureWarning: Sorting because non-concatenation axis is not aligned. A future version
of pandas will change to not sort by default.

To accept the future behavior, pass &#39;sort=False&#39;.

To retain the current behavior and silence the warning, pass &#39;sort=True&#39;.

  &quot;&quot;&quot;Entry point for launching an IPython kernel.
</code></pre><table>
<thead>
<tr>
<th></th>
<th>A</th>
<th>B</th>
<th>C</th>
<th>D</th>
</tr>
</thead>
<tbody>
<tr>
<td>a</td>
<td>4.0</td>
<td>3.0</td>
<td>NaN</td>
<td>NaN</td>
</tr>
<tr>
<td>b</td>
<td>8.0</td>
<td>1.0</td>
<td>NaN</td>
<td>NaN</td>
</tr>
<tr>
<td>c</td>
<td>6.0</td>
<td>3.0</td>
<td>NaN</td>
<td>NaN</td>
</tr>
<tr>
<td>a</td>
<td>NaN</td>
<td>NaN</td>
<td>1.0</td>
<td>3.0</td>
</tr>
<tr>
<td>b</td>
<td>NaN</td>
<td>NaN</td>
<td>8.0</td>
<td>2.0</td>
</tr>
</tbody>
</table>
<pre><code class="python">pd.concat([df_obj1, df_obj2], axis=1)
</code></pre>
<pre><code>C:\Users\wztli\Anaconda3\lib\site-packages\ipykernel_launcher.py:1: FutureWarning: Sorting because non-concatenation axis is not aligned. A future version
of pandas will change to not sort by default.

To accept the future behavior, pass &#39;sort=False&#39;.

To retain the current behavior and silence the warning, pass &#39;sort=True&#39;.

  &quot;&quot;&quot;Entry point for launching an IPython kernel.
</code></pre><table>
<thead>
<tr>
<th></th>
<th>A</th>
<th>B</th>
<th>C</th>
<th>D</th>
</tr>
</thead>
<tbody>
<tr>
<td>a</td>
<td>4</td>
<td>3</td>
<td>1.0</td>
<td>3.0</td>
</tr>
<tr>
<td>b</td>
<td>8</td>
<td>1</td>
<td>8.0</td>
<td>2.0</td>
</tr>
<tr>
<td>c</td>
<td>6</td>
<td>3</td>
<td>NaN</td>
<td>NaN</td>
</tr>
</tbody>
</table>
<h2 id="五、数据重构"><a href="#五、数据重构" class="headerlink" title="五、数据重构"></a>五、数据重构</h2><pre><code class="python">import numpy as np
import pandas as pd
</code></pre>
<h3 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h3><pre><code class="python">df_obj = pd.DataFrame(np.random.randint(0,10, (5,2)), columns=[&#39;data1&#39;, &#39;data2&#39;])
df_obj
</code></pre>
<table>
<thead>
<tr>
<th></th>
<th>data1</th>
<th>data2</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0</td>
<td>4</td>
</tr>
<tr>
<td>1</td>
<td>6</td>
<td>2</td>
</tr>
<tr>
<td>2</td>
<td>9</td>
<td>8</td>
</tr>
<tr>
<td>3</td>
<td>7</td>
<td>0</td>
</tr>
<tr>
<td>4</td>
<td>3</td>
<td>1</td>
</tr>
</tbody>
</table>
<pre><code class="python">stacked = df_obj.stack()
print (stacked)
</code></pre>
<pre><code>0  data1    0
   data2    4
1  data1    6
   data2    2
2  data1    9
   data2    8
3  data1    7
   data2    0
4  data1    3
   data2    1
dtype: int32
</code></pre><pre><code class="python">print (type(stacked))
print (type(stacked.index))
</code></pre>
<pre><code>&lt;class &#39;pandas.core.series.Series&#39;&gt;
&lt;class &#39;pandas.core.indexes.multi.MultiIndex&#39;&gt;
</code></pre><h3 id="unstack"><a href="#unstack" class="headerlink" title="unstack"></a>unstack</h3><pre><code class="python"># 默认操作内层索引
stacked.unstack()
</code></pre>
<table>
<thead>
<tr>
<th></th>
<th>data1</th>
<th>data2</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0</td>
<td>4</td>
</tr>
<tr>
<td>1</td>
<td>6</td>
<td>2</td>
</tr>
<tr>
<td>2</td>
<td>9</td>
<td>8</td>
</tr>
<tr>
<td>3</td>
<td>7</td>
<td>0</td>
</tr>
<tr>
<td>4</td>
<td>3</td>
<td>1</td>
</tr>
</tbody>
</table>
<pre><code class="python"># 通过level指定操作索引的级别
stacked.unstack(level=0)
</code></pre>
<table>
<thead>
<tr>
<th></th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
</tr>
</thead>
<tbody>
<tr>
<td>data1</td>
<td>0</td>
<td>6</td>
<td>9</td>
<td>7</td>
<td>3</td>
</tr>
<tr>
<td>data2</td>
<td>4</td>
<td>2</td>
<td>8</td>
<td>0</td>
<td>1</td>
</tr>
</tbody>
</table>
<h2 id="六、数据转换"><a href="#六、数据转换" class="headerlink" title="六、数据转换"></a>六、数据转换</h2><pre><code class="python">import numpy as np
import pandas as pd
</code></pre>
<h3 id="重复数据-duplicates-函数"><a href="#重复数据-duplicates-函数" class="headerlink" title="重复数据 duplicates 函数"></a>重复数据 duplicates 函数</h3><pre><code class="python">df_obj = pd.DataFrame({&#39;data1&#39; : [&#39;a&#39;] * 4 + [&#39;b&#39;] * 4,
                       &#39;data2&#39; : np.random.randint(0, 4, 8)})
df_obj
</code></pre>
<table>
<thead>
<tr>
<th></th>
<th>data1</th>
<th>data2</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>a</td>
<td>3</td>
</tr>
<tr>
<td>1</td>
<td>a</td>
<td>2</td>
</tr>
<tr>
<td>2</td>
<td>a</td>
<td>2</td>
</tr>
<tr>
<td>3</td>
<td>a</td>
<td>1</td>
</tr>
<tr>
<td>4</td>
<td>b</td>
<td>0</td>
</tr>
<tr>
<td>5</td>
<td>b</td>
<td>2</td>
</tr>
<tr>
<td>6</td>
<td>b</td>
<td>2</td>
</tr>
<tr>
<td>7</td>
<td>b</td>
<td>1</td>
</tr>
</tbody>
</table>
<pre><code class="python">df_obj.duplicated()
</code></pre>
<pre><code>0    False
1    False
2     True
3    False
4    False
5    False
6     True
7    False
dtype: bool
</code></pre><pre><code class="python">df_obj.drop_duplicates()
</code></pre>
<table>
<thead>
<tr>
<th></th>
<th>data1</th>
<th>data2</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>a</td>
<td>3</td>
</tr>
<tr>
<td>1</td>
<td>a</td>
<td>2</td>
</tr>
<tr>
<td>3</td>
<td>a</td>
<td>1</td>
</tr>
<tr>
<td>4</td>
<td>b</td>
<td>0</td>
</tr>
<tr>
<td>5</td>
<td>b</td>
<td>2</td>
</tr>
<tr>
<td>7</td>
<td>b</td>
<td>1</td>
</tr>
</tbody>
</table>
<pre><code class="python">df_obj.drop_duplicates(&#39;data2&#39;)
</code></pre>
<table>
<thead>
<tr>
<th></th>
<th>data1</th>
<th>data2</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>a</td>
<td>3</td>
</tr>
<tr>
<td>1</td>
<td>a</td>
<td>2</td>
</tr>
<tr>
<td>3</td>
<td>a</td>
<td>1</td>
</tr>
<tr>
<td>4</td>
<td>b</td>
<td>0</td>
</tr>
</tbody>
</table>
<h3 id="map-函数"><a href="#map-函数" class="headerlink" title="map 函数"></a>map 函数</h3><pre><code class="python">ser_obj = pd.Series(np.random.randint(0,10,10))
ser_obj
</code></pre>
<pre><code>0    1
1    9
2    1
3    2
4    7
5    2
6    4
7    5
8    4
9    6
dtype: int32
</code></pre><pre><code class="python">ser_obj.map(lambda x : x ** 2)
</code></pre>
<pre><code>0     1
1    81
2     1
3     4
4    49
5     4
6    16
7    25
8    16
9    36
dtype: int64
</code></pre><h3 id="数据替换-repalce"><a href="#数据替换-repalce" class="headerlink" title="数据替换 repalce"></a>数据替换 repalce</h3><pre><code class="python"># 替换单个值
ser_obj.replace(0, -100)
</code></pre>
<pre><code>0    1
1    9
2    1
3    2
4    7
5    2
6    4
7    5
8    4
9    6
dtype: int32
</code></pre><pre><code class="python"># 替换多个值
ser_obj.replace([0, 2], -100)
</code></pre>
<pre><code>0      1
1      9
2      1
3   -100
4      7
5   -100
6      4
7      5
8      4
9      6
dtype: int32
</code></pre><pre><code class="python"># 替换多个值
ser_obj.replace([0, 2], [-100, -200])
</code></pre>
<pre><code>0      1
1      9
2      1
3   -200
4      7
5   -200
6      4
7      5
8      4
9      6
dtype: int64
</code></pre><pre><code class="python">ser_obj.map(lambda x : x ** 2)

#### 3. 数据替换repalce

# 替换单个值
ser_obj.replace(0, -100)

# 替换多个值
ser_obj.replace([0, 2], -100)

# 替换多个值
ser_obj.replace([0, 2], [-100, -200])
</code></pre>
<pre><code>0      1
1      9
2      1
3   -200
4      7
5   -200
6      4
7      5
8      4
9      6
dtype: int64
</code></pre>]]></content>
      <categories>
        <category>DataAnalysis</category>
      </categories>
  </entry>
  <entry>
    <title>JAVA-基础知识</title>
    <url>/blog/esofty/</url>
    <content><![CDATA[<h2 id="一、关于-JAVA"><a href="#一、关于-JAVA" class="headerlink" title="一、关于 JAVA"></a>一、关于 JAVA</h2><h3 id="Java-和-C-和-C"><a href="#Java-和-C-和-C" class="headerlink" title="Java 和 C 和 C++"></a>Java 和 C 和 C++</h3><ol>
<li>c 是面向过程的语言。c++和 Java 都是面向对象的。在 c 中没有类或者对象的概念。</li>
<li>java 运行在虚拟机上，号称与平台无关。也就是你开发的 java 程序无论是 unix，linux 还是 windows 都可以正常运行。但是实际上这是一个良好的愿望，实际跨平台时还会有各种各样的问题。c 和 c++都是直接编译成可执行文件，是否能跨平台主要看你用到的编译器特性是否有多平台支持。</li>
<li>因为 c 和 c 是直接编译成可执行文件，所以运行效率要比 java 高。至于 c 和 c 哪个更快，两种语言的拥趸已经吵了很多年。</li>
<li>java 因为是运行在虚拟机上，不需要考虑内存管理和垃圾回收机制。也是就你可以声明一个对象而不用考虑释放他，虚拟机帮你做这事情。而 c 和 c 语言本身没有多少内存管理的概念，写 c 和 c 程序如果用到指针就一定要考虑内存申请和释放。内存泄漏是 c 和 c++最头疼的问题。</li>
<li>代码重用：java 中有一个根类 object，所有的类都是其子类，通过这种方式将容器和算法分离，实现一种操作作用于多种对象，提高代码重用。c 中没有总根对象，但是 c 提供了另一个更强大的功能“模板”，同样高效地实现了一种操作作用于多种对象，提供了高效的代码重用方法。</li>
<li>数据结构：java 内建了丰富的数据结构：列表，集合等等（很久没用 java 了，有些记不太清）。而 c++则用“模板”同样提供了各种数据结构（容器）。</li>
<li>c 语言在一些比较低层，和硬件打交道的地方用得比较多。另外很多开源软件由于 unix/linux 开发习惯也大多采用 c 来开发。Java 是现在最流行的开发语言，c++比起 java 稍稍不那么流行一些，但是功能很强大。如能深入掌握，可以写出兼顾效率和美观的优秀代码。</li>
</ol>
<h3 id="多语言简略对比"><a href="#多语言简略对比" class="headerlink" title="多语言简略对比"></a>多语言简略对比</h3><blockquote>
<p><strong>Ideas are cheap, show me the code</strong>   学到了，学到了~</p>
</blockquote>
<pre><code>代码块：python通过缩进来确定代码块
复数：java、python有，C、Cplusplus没有
python：相对于java，python就是java的压缩版本
包、接口、API：我觉得java也好，python也好，正是因为这些模块组件化，才使得这些语言好很好的的健壮性
</code></pre><h2 id="二、数据类型；运算符；表达式"><a href="#二、数据类型；运算符；表达式" class="headerlink" title="二、数据类型；运算符；表达式"></a>二、数据类型；运算符；表达式</h2><h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><blockquote>
<p>常量、标识符和变量、数据类型</p>
</blockquote>
<blockquote>
<p><strong>JAVA 中除了下面 8 种数据类型其他的都是以对象（或者说类的实例）存在的</strong></p>
</blockquote>
<ul>
<li>string：要熟悉常用的函数<ul>
<li>length()：字符串的长度</li>
<li>charAt(i)：取字符串的第 i 个元素</li>
</ul>
</li>
<li>boolean（java 中需要全部写出来）<ul>
<li><code>true</code></li>
<li><code>false</code></li>
</ul>
</li>
<li>下面 6 中数值型数据类型</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598686524193-b62199d3-9dc6-4caa-a3c1-2484c7d6185c.png#align=left&amp;display=inline&amp;height=204&amp;margin=%5Bobject%20Object%5D&amp;originHeight=583&amp;originWidth=1192&amp;size=0&amp;status=done&amp;style=shadow&amp;width=418" alt></p>
<h3 id="运算符和表达式"><a href="#运算符和表达式" class="headerlink" title="运算符和表达式"></a>运算符和表达式</h3><ul>
<li>赋值语句，赋值表达式</li>
<li>输入输出：<strong>输入输出，要有记得清除的空间，close 的意识！</strong></li>
</ul>
<pre><code class="java">// 方式一
import java.util.Scanner;

Scanner input = new Scanner(System.in);
double radius = input.nextDouble();

// 方式二 : 好处就是避免项目工程中类当中重名的情况
java.util.Scanner input = new java.util.Scanner(System.in);
double radius = input.nextDouble();
</code></pre>
<ul>
<li><p>数值运算符</p>
<blockquote>
<p>+、-、*、/、%</p>
</blockquote>
</li>
<li><p>逻辑运算符<br><code>&amp;&amp;</code> <code>||</code> <code>!</code> <code>^</code>(异或：相同才为假)<br><code>&amp;</code> <code>|</code> <code>^</code> 位运算符：会先化成二进制对二进制码进行分析</p>
</li>
<li>运算符的优先级</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598686523840-d1395ecf-7d3c-416b-8ce8-5d11a0e3f313.png#align=left&amp;display=inline&amp;height=302&amp;margin=%5Bobject%20Object%5D&amp;originHeight=552&amp;originWidth=543&amp;size=0&amp;status=done&amp;style=none&amp;width=297" alt></p>
<h2 id="三、程序三大基本结构"><a href="#三、程序三大基本结构" class="headerlink" title="三、程序三大基本结构"></a>三、程序三大基本结构</h2><h3 id="顺序结构"><a href="#顺序结构" class="headerlink" title="顺序结构"></a>顺序结构</h3><h3 id="选择结构"><a href="#选择结构" class="headerlink" title="选择结构"></a>选择结构</h3><ul>
<li>if(){} else{}</li>
<li>switch</li>
</ul>
<pre><code class="java">public class Test {
   public static void main(String args[]){
      //char grade = args[0].charAt(0);
      char grade = &#39;C&#39;;

      switch(grade)
      {
         case &#39;A&#39; :
            System.out.println(&quot;优秀&quot;);
            break;
         case &#39;B&#39; :
         case &#39;C&#39; :
            System.out.println(&quot;良好&quot;);
            break;
         case &#39;D&#39; :
            System.out.println(&quot;及格&quot;);
            break;
         case &#39;F&#39; :
            System.out.println(&quot;你需要再努力努力&quot;);
            break;
         default :
            System.out.println(&quot;未知等级&quot;);
      }
      System.out.println(&quot;你的等级是 &quot; + grade);
   }
}
</code></pre>
<ul>
<li><strong>条件表达式</strong></li>
</ul>
<pre><code class="java">System.out.println((num % 2 == 0) ? &quot;num is even&quot; : &quot;num is odd&quot;);
</code></pre>
<h3 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h3><ul>
<li>while () {}</li>
<li>do {} while ();</li>
<li>for () {}</li>
<li>关于 break（跳出该级别的 for 循环）和 continue（后面的语句不读）</li>
<li>关于 return</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598686523958-c57b6b4d-e802-44e1-adc6-276167476c3d.png#align=left&amp;display=inline&amp;height=236&amp;margin=%5Bobject%20Object%5D&amp;originHeight=328&amp;originWidth=530&amp;size=0&amp;status=done&amp;style=shadow&amp;width=381" alt></p>
<ul>
<li>关于<strong>增强的 for 循环</strong>，在模板章节，配合 vector 使用，并发控制，高效使用</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598686523773-6d1af202-9aa9-4789-b931-b0671aac432f.png#align=left&amp;display=inline&amp;height=255&amp;margin=%5Bobject%20Object%5D&amp;originHeight=781&amp;originWidth=1128&amp;size=0&amp;status=done&amp;style=none&amp;width=369" alt><br>缺点：看不见索引</p>
<h2 id="四、方法"><a href="#四、方法" class="headerlink" title="四、方法"></a>四、方法</h2><h2 id="五、一维数组"><a href="#五、一维数组" class="headerlink" title="五、一维数组"></a>五、一维数组</h2><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><pre><code class="java">double [] array; // 声明数组方式一
double array []; // 生命数组方式二
</code></pre>
<p>创建好编译器会有初始值<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598686523691-98e6140a-a9e1-4218-9589-dc55ff35ed67.png#align=left&amp;display=inline&amp;height=79&amp;margin=%5Bobject%20Object%5D&amp;originHeight=240&amp;originWidth=895&amp;size=0&amp;status=done&amp;style=shadow&amp;width=293" alt></p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><pre><code class="java">double [] array = new double[10]; // 生命数组并且初始化数组大小
double [] array = {1.9, 2.9, 3.4, 3.5}; // 用值初始化数组
</code></pre>
<h3 id="相关属性"><a href="#相关属性" class="headerlink" title="相关属性"></a>相关属性</h3><blockquote>
<p>是一个对象，有自己的属性自己的方法</p>
</blockquote>
<p>String 里面长度 length 有()，也就是 String 里面是方法，而数组没有括号()（写成 array.length），理解为成员变量/属性，而不是方法（封装好了许多功能，体现出语言优越性）</p>
<h3 id="相关操作"><a href="#相关操作" class="headerlink" title="相关操作"></a>相关操作</h3><ul>
<li>[x] Initializing arrays with input values</li>
</ul>
<pre><code class="java">java.util.Scanner input = new java.util.Scanner(System.in);
for (int i=0;i&lt;mylist.length;i++)
    mylist[i] = input.nextDouble();
</code></pre>
<ul>
<li>[x] Initializing arrays with random values</li>
</ul>
<pre><code class="java">for (int i = 0; i &lt; myList.length; i++) {
  myList[i] = Math.random() * 100;
}
</code></pre>
<ul>
<li>[x] Printing arrays</li>
</ul>
<pre><code class="java">for (int i = 0; i &lt; myList.length; i++) {
  System.out.print(myList[i] + &quot; &quot;);
}
</code></pre>
<ul>
<li>[x] Summing all elements</li>
</ul>
<pre><code class="java">double total = 0;
for (int i = 0; i &lt; myList.length; i++) {
  total += myList[i];
}
</code></pre>
<ul>
<li>[x] Finding the largest element</li>
</ul>
<pre><code class="java">double max = myList[0];
for (int i = 1; i &lt; myList.length; i++) {
  if (myList[i] &gt; max) max = myList[i];
}
</code></pre>
<ul>
<li>[ ] Finding the smallest index of the largest element</li>
<li>[x] Random shuffling</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598686524154-f90809c6-aaae-46bf-b892-5e6f9ed63f50.png#align=left&amp;display=inline&amp;height=502&amp;margin=%5Bobject%20Object%5D&amp;originHeight=502&amp;originWidth=1168&amp;size=0&amp;status=done&amp;style=shadow&amp;width=1168" alt></p>
<ul>
<li>[x] Shifting elements</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598686523785-4984f380-9ca1-4e26-94c5-9c7de0a9c9a1.png#align=left&amp;display=inline&amp;height=470&amp;margin=%5Bobject%20Object%5D&amp;originHeight=470&amp;originWidth=1164&amp;size=0&amp;status=done&amp;style=shadow&amp;width=1164" alt></p>
<h3 id="数组的值传递"><a href="#数组的值传递" class="headerlink" title="数组的值传递"></a>数组的值传递</h3><blockquote>
<p><strong>java 核心知识点之一</strong></p>
</blockquote>
<p>数组名（数组地址）作为函数参数</p>
<p>java 当中是<strong>值传递</strong>的，没有引用没有指针的概念，所以在做函数参数当中，一直都是值传递，python 也是。</p>
<h3 id="Array-类"><a href="#Array-类" class="headerlink" title="Array 类"></a>Array 类</h3><blockquote>
<p>import java.util.Arrays;</p>
</blockquote>
<ul>
<li>[x] Array 类中常用的函数<blockquote>
<p>sort()、parallelSort()、fill()、toString()、binarySearch()（Binary Search 二分查找（事先得排好序））、equals()</p>
</blockquote>
</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598686524086-a8d0a2b1-81e5-4045-8cdf-21b40f26c53e.png#align=left&amp;display=inline&amp;height=224&amp;margin=%5Bobject%20Object%5D&amp;originHeight=488&amp;originWidth=1225&amp;size=0&amp;status=done&amp;style=shadow&amp;width=562" alt><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598686524588-f9bcf764-f194-42b9-9c16-3e1676e8964e.png#align=left&amp;display=inline&amp;height=593&amp;margin=%5Bobject%20Object%5D&amp;originHeight=736&amp;originWidth=662&amp;size=0&amp;status=done&amp;style=shadow&amp;width=533" alt></p>
<h2 id="六、多维数组"><a href="#六、多维数组" class="headerlink" title="六、多维数组"></a>六、多维数组</h2><h3 id="二维数组的创建、初始化"><a href="#二维数组的创建、初始化" class="headerlink" title="二维数组的创建、初始化"></a>二维数组的创建、初始化</h3><pre><code class="java">dataType[][] refVar = new dataType[10][10];

int[][] array = {
  {1, 2, 3},
  {4, 5, 6},
  {7, 8, 9},
  {10, 11, 12}
};
</code></pre>
<blockquote>
<p>数组长度的计算</p>
</blockquote>
<pre><code>array.length = 4
array[0].length = 3

array[4].length ==&gt; ArrayIndexOutOfBoundsException
</code></pre><h3 id="二维数组的相关操作"><a href="#二维数组的相关操作" class="headerlink" title="二维数组的相关操作"></a>二维数组的相关操作</h3><ul>
<li>[x] Initializing arrays with input values</li>
</ul>
<pre><code class="java">java.util.Scanner input = new Scanner(System.in);
System.out.println(&quot;Enter &quot; + matrix.length + &quot; rows and &quot; +
  matrix[0].length + &quot; columns: &quot;);
for (int row = 0; row &lt; matrix.length; row++) {
  for (int column = 0; column &lt; matrix[row].length; column++) {
    matrix[row][column] = input.nextInt();
  }
}
</code></pre>
<ul>
<li>[x] Initializing arrays with random values</li>
</ul>
<pre><code class="java">for (int row = 0; row &lt; matrix.length; row++) {
  for (int column = 0; column &lt; matrix[row].length; column++) {
    matrix[row][column] = (int)(Math.random() * 100);
  }
}
</code></pre>
<ul>
<li>[x] Printing arrays</li>
</ul>
<pre><code class="java">for (int row = 0; row &lt; matrix.length; row++) {
  for (int column = 0; column &lt; matrix[row].length; column++) {
    System.out.print(matrix[row][column] + &quot; &quot;);
  }

  System.out.println();
}
</code></pre>
<ul>
<li>[x] Summing all elements</li>
</ul>
<pre><code class="java">int total = 0;
for (int row = 0; row &lt; matrix.length; row++) {
  for (int column = 0; column &lt; matrix[row].length; column++) {
    total += matrix[row][column];
  }
}
</code></pre>
<ul>
<li>[x] Summing all elements by column</li>
</ul>
<pre><code class="java">for (int column = 0; column &lt; matrix[0].length; column++) {
  int total = 0;
  for (int row = 0; row &lt; matrix.length; row++)
    total += matrix[row][column];
  System.out.println(&quot;Sum for column &quot; + column + &quot; is &quot;
    + total);
}
</code></pre>
<ul>
<li>[x] Which row has the largest sum</li>
<li>[x] Finding the smallest index of the largest element</li>
<li>[x] Random shuffling</li>
</ul>
<pre><code class="java">for (int i = 0; i &lt; matrix.length; i++) {
  for (int j = 0; j &lt; matrix[i].length; j++) {
    int i1 = (int)(Math.random() * matrix.length);
    int j1 = (int)(Math.random() * matrix[i].length);
    // Swap matrix[i][j] with matrix[i1][j1]
    int temp = matrix[i][j];
    matrix[i][j] = matrix[i1][j1];
    matrix[i1][j1] = temp;
  }
}
</code></pre>
<h3 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h3><pre><code class="java">double[][][] scores = {
  {{7.5, 20.5}, {9.0, 22.5}, {15, 33.5}, {13, 21.5}, {15, 2.5}},
  {{4.5, 21.5}, {9.0, 22.5}, {15, 34.5}, {12, 20.5}, {14, 9.5}},
  {{6.5, 30.5}, {9.4, 10.5}, {11, 33.5}, {11, 23.5}, {10, 2.5}},
  {{6.5, 23.5}, {9.4, 32.5}, {13, 34.5}, {11, 20.5}, {16, 7.5}},
  {{8.5, 26.5}, {9.4, 52.5}, {13, 36.5}, {13, 24.5}, {16, 2.5}},
  {{9.5, 20.5}, {9.4, 42.5}, {13, 31.5}, {12, 20.5}, {16, 6.5}}
};

</code></pre>
]]></content>
      <categories>
        <category>Language</category>
      </categories>
  </entry>
  <entry>
    <title>git常见使用总结</title>
    <url>/blog/fnsge3/</url>
    <content><![CDATA[<h2 id="一、Git-安装和本地用户全局配置"><a href="#一、Git-安装和本地用户全局配置" class="headerlink" title="一、Git 安装和本地用户全局配置"></a>一、Git 安装和本地用户全局配置</h2><p>官网<a href="https://git-scm.com/download/win" target="_blank" rel="noopener">下载</a>并且安装</p>
<p>查看是否安装成功<code>win + R</code>进入 CMD 输入 git，出现 git 命令指南，则安装成功</p>
<p><strong>全局配置本地用户</strong>，在 git Bash 中进行下面配置（尽量仔细，检查一遍），下面的账号名字和邮箱都是 github 的账号所使用的</p>
<pre><code>git config --global user.name &quot;wztlink1013&quot;
git config --global user.email &quot;2550374815@qq.com&quot;
</code></pre><p>其中：global 表示全局可用，如果要设置局部可用，则只需要删除 global 即可</p>
<p>验证是否配置成功：<code>git config --global --list</code></p>
<h2 id="二、利用-SSH-绑定-Git-和-GitHub"><a href="#二、利用-SSH-绑定-Git-和-GitHub" class="headerlink" title="二、利用 SSH 绑定 Git 和 GitHub"></a>二、利用 SSH 绑定 Git 和 GitHub</h2><h3 id="生成"><a href="#生成" class="headerlink" title="生成"></a>生成</h3><p>输入<code>ssh-keygen -t rsa</code>，然后回车三下 <del>（有些时候要回车四下）</del></p>
<p>然后在用户管理员文件夹下生成两个文件夹 id_rsa 和 id_rsa.pub,将后者内容添加到 GitHub 上即可。</p>
<h3 id="添加"><a href="#添加" class="headerlink" title="添加"></a>添加</h3><p>在 github 上的 setting 上添加新的 ssh 即可</p>
<h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>在 git Bash 输入：<code>ssh -T git@github.com</code></p>
<ul>
<li>如果出现 Hi name !you are……证明绑定成功。</li>
<li>如果报错，则是因为少了一个文件，使用过程中直接点 yes。具体<a href="https://blog.csdn.net/qq_34446663/article/details/81106018" target="_blank" rel="noopener">解决原理</a></li>
</ul>
<h2 id="三、Git-向-GitHub-提交代码"><a href="#三、Git-向-GitHub-提交代码" class="headerlink" title="三、Git 向 GitHub 提交代码"></a>三、Git 向 GitHub 提交代码</h2><p>了解 pull 和 push</p>
<p><code>git push origin master</code></p>
<p><code>git pull origin master</code></p>
<h3 id="提交情况-1：clone"><a href="#提交情况-1：clone" class="headerlink" title="提交情况 1：clone"></a>提交情况 1：clone</h3><p>本地没有 git 仓库，也没有 git init 操作，需要先从 GitHub 下载</p>
<p>选定仓库克隆</p>
<blockquote>
<p>git clone <a href="https://github.com/wztlink1013/Python_DataAnalysis.git" target="_blank" rel="noopener">https://github.com/wztlink1013/Python_DataAnalysis.git</a></p>
</blockquote>
<p>对本地文件夹进行一系列更改之后，执行命令：</p>
<pre><code>git status   #查看仓库命令状态
git add .    #文件提交到文件缓冲区
git commmit -m &quot;描述本次修改信息&quot;    #提交仓库并且添加提交信息
git log  #查看修改日志
git status   #再次查看
</code></pre><p>push 到远程仓库</p>
<blockquote>
<p>首次推送：<code>git push -u origin master</code><br>非首次推送：<code>git push origin master</code></p>
</blockquote>
<h3 id="提交情况-2：pull"><a href="#提交情况-2：pull" class="headerlink" title="提交情况 2：pull"></a>提交情况 2：pull</h3><p>这种情况是，本地有 git 仓库，指之前已经进行 git init 等一系列命令对该文件夹操作过。新建一个例子：</p>
<blockquote>
<p><code>git init</code>初始化本地仓库<br><code>git remote add origin [https://github.com/guobinhit/springmvc-tutorial.git](https://github.com/guobinhit/springmvc-tutorial.git)</code>关联远程仓库<br><code>git pull origin master</code>同步远程仓库和本地仓库</p>
</blockquote>
<p>假如在本地新加文件：</p>
<blockquote>
<p>执行 git status 等命令<br>再执行<code>git push origin master</code>将本地新内容提交到远程仓库</p>
</blockquote>
<p><strong>注意！</strong>：在进行本地仓库和远程仓库的文件交互时，一定要先 pull 再 push，不然会出未知错误。</p>
<h2 id="四、常用命令总结"><a href="#四、常用命令总结" class="headerlink" title="四、常用命令总结"></a>四、常用命令总结</h2><h3 id="常规命令"><a href="#常规命令" class="headerlink" title="常规命令"></a>常规命令</h3><pre><code>git init
git status
git add
git commit
git log
git branch   #查看分支
git checkout    #切换分支
git merge   #合并分支
git branch -d   #删除分支
git tag #给分支添加标签
git remote -v   #查看相关信息
</code></pre><h3 id="git-push-f"><a href="#git-push-f" class="headerlink" title="git push -f"></a>git push -f</h3><p>报错信息</p>
<pre><code class="bash">$ git push origin master
To https://github.com/wztlink1013/website-source.git
 ! [rejected]        master -&gt; master (fetch first)
error: failed to push some refs to &#39;https://github.com/wztlink1013/website-source.git&#39;
hint: Updates were rejected because the remote contains work that you do
hint: not have locally. This is usually caused by another repository pushing
hint: to the same ref. You may want to first integrate the remote changes
hint: (e.g., &#39;git pull ...&#39;) before pushing again.
hint: See the &#39;Note about fast-forwards&#39; in &#39;git push --help&#39; for details.
</code></pre>
<p>分析并解决问题</p>
<blockquote>
<p>强制性 push</p>
</blockquote>
<pre><code class="bash">$ git push -f origin master
</code></pre>
<h3 id="文件夹相关命令"><a href="#文件夹相关命令" class="headerlink" title="文件夹相关命令"></a>文件夹相关命令</h3><blockquote>
<p>复制文件夹</p>
</blockquote>
<pre><code class="bash">cp  -r  ./js/  ./backup/
</code></pre>
<blockquote>
<p>移动文件夹</p>
</blockquote>
<pre><code class="bash">mv  visualization/  -f  .github_pages/
</code></pre>
<blockquote>
<p>删除文件夹</p>
</blockquote>
<pre><code class="bash">rm  -r  .git
</code></pre>
<h2 id="五、部署多个-github-coding-等账号"><a href="#五、部署多个-github-coding-等账号" class="headerlink" title="五、部署多个 github/+coding 等账号"></a>五、部署多个 github/+coding 等账号</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>好处：一台设备可以使用多个 github 账号/github+coding 等等多平台托管/搭建两个静态博客</p>
<p>取消全局用户配置（每建立一个新文件夹，需要输入使用账号），建立多个 ssh 密匙（如果是 github 账号+coding 账号+gitee 账号等）</p>
<p>SSH 的公钥是 GitHub 连接本地仓库和远程仓库的标识，一个公钥只能对应一个 GitHub 账户，一个相同的公钥不能上传到不同的 GitHub 账户</p>
<p>一台电脑，可以生成多对公私钥，可以通过配置，将不同的公钥上传到不同的 GitHub 账号，那么就不存在单个公钥绑定多个 GitHub 账号的情况存在了</p>
<h3 id="多密匙生成"><a href="#多密匙生成" class="headerlink" title="多密匙生成"></a>多密匙生成</h3><ul>
<li>先进来该文件夹（忽略图片上写的字）<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1597632490897-11718be6-6492-4ead-a739-1c92af25c648.png#align=left&amp;display=inline&amp;height=372&amp;margin=%5Bobject%20Object%5D&amp;originHeight=372&amp;originWidth=1215&amp;size=0&amp;status=done&amp;style=none&amp;width=1215" alt></li>
<li>创建新密匙方法一（首选）</li>
</ul>
<p><code>ssh-keygen -t rsa -f ~/.ssh/这里是新密钥名称 -C &quot;这里是你的邮箱&quot;</code></p>
<p>注意区别新密钥名称和旧密钥名称，不要相同！！</p>
<ul>
<li>创建新密匙方法二</li>
</ul>
<p>输入这个：<code>ssh-keygen -t rsa -C &quot;这里是你的邮箱&quot;</code></p>
<p>出现这两句：<br><code>Generating public/private rsa key pair.</code></p>
<p><code>Enter file in which to save the key (/c/Users/you/.ssh/id_rsa):</code></p>
<p>注意此时需要你输入新密钥的名称，同样要注意区别新密钥名称和旧密钥名称，不要相同，之后再两次回车。</p>
<h3 id="配置-config"><a href="#配置-config" class="headerlink" title="配置 config"></a>配置 config</h3><p>.ssh 根文件夹下没有 config 文件，需要新建</p>
<ul>
<li>新建 config 文件方法一</li>
</ul>
<p>在.ssh 根路径下键入该命令<code>touch config</code></p>
<ul>
<li>新建 config 文件方法二</li>
</ul>
<p>记事本新建文件 config 文件！！没有后缀</p>
<ul>
<li>输入内容</li>
</ul>
<pre><code>#第一个账号，默认使用的账号，不用做任何更改
Host github.com
    HostName github.com
    User git
    IdentityFile ~/.ssh/id_rsa

#第二个新账号，#&quot;xxxxxx&quot;为前缀名，可以任意设置，要记住，后面需要用到
Host xxxxxx.github.com
    HostName github.com
    User git
    IdentityFile ~/.ssh/这里是你创建的新密钥的名称
</code></pre><pre><code># one(one@gmail.com)
Host one.github.com
HostName github.com
PreferredAuthentications publickey
IdentityFile ~/.ssh/id_rsa_one
User one

# two(two@gmail.com)
Host two.github.com
HostName github.com
PreferredAuthentications publickey
IdentityFile ~/.ssh/id_rsa_two
User two
</code></pre><pre><code>Host myhost（这里是自定义的host简称，以后连接远程服务器就可以用命令ssh myhost）
HostName 主机名可用ip也可以是域名(如:github.com或者bitbucket.org)
Port 服务器open-ssh端口（默认：22,默认时一般不写此行）
PreferredAuthentications   配置登录时用什么权限认证--可设为publickey,password publickey,keyboard-interactive等
IdentityFile 证书文件路径（如~/.ssh/id_rsa_*)
User 登录用户名(如：git)
</code></pre><p>每个账号单独配置一个 Host，每个 Host 要取一个别名，一般为每个 Host 主要配置 HostName 和 IdentityFile 两个属性，配置完保存即可。</p>
<p>Host 的名字可以自定义名字，不过这个会影响 git 相关命令，例如：Host mygithub 这样定义的话，使用命令 git clone git@mygithub:PopFisher/AndroidRotateAnim.git，git@后面紧跟的名字改为 mygithub</p>
<blockquote>
<p><strong>mine</strong> &gt; <img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1597632490639-fd51b09d-c037-4fdb-bad3-e2e1d56d7aed.png#align=left&amp;display=inline&amp;height=637&amp;margin=%5Bobject%20Object%5D&amp;originHeight=637&amp;originWidth=999&amp;size=0&amp;status=done&amp;style=none&amp;width=999" alt></p>
</blockquote>
<h3 id="部署-SSH-key"><a href="#部署-SSH-key" class="headerlink" title="部署 SSH key"></a>部署 SSH key</h3><p>将根文件夹下的<code>wztlink1013.pub</code>文件复制到 github 上，coding/gitee 类似</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1597632490332-674f64ec-d09e-4351-a3cd-dbebc15a3a32.png#align=left&amp;display=inline&amp;height=872&amp;margin=%5Bobject%20Object%5D&amp;originHeight=872&amp;originWidth=1839&amp;size=0&amp;status=done&amp;style=none&amp;width=1839" alt><br>title 可以随便填</p>
<h3 id="清缓存，添-agent"><a href="#清缓存，添-agent" class="headerlink" title="清缓存，添 agent"></a>清缓存，添 agent</h3><p>在根目录下</p>
<pre><code>ssh-add -D
ssh-add xxxxxx #旧密钥名称，一般是id_rsa
ssh-add xxxxxx #新创建的密钥名称
</code></pre><p>如果执行以上命令出现错误：<code>Could not open a connection to your authentication agent.</code>，那么就需要先执行<code>ssh-agent bash</code>，再执行以上命令</p>
<h3 id="验证是否配置成功"><a href="#验证是否配置成功" class="headerlink" title="验证是否配置成功"></a>验证是否配置成功</h3><p>一下第一个是之前默认的 github 账号，默认即可，第二个是添加的</p>
<pre><code>ssh -T git@github.com
ssh -T git@xxxxxxx.github.com
</code></pre><p>出现<code>Hi 你的用户名! You&#39;ve successfully authenticated, but GitHub does not provide shell access.</code>则成功。</p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ul>
<li>取消全局用户名和邮箱配置（如果已经设置了全局的话）</li>
</ul>
<pre><code>git config --global --unset user.name
git config --global --unset user.email
</code></pre><ul>
<li>clone</li>
</ul>
<p>原来：<code>git clone git@github.com: wztlink1013/learngit.git</code></p>
<p>现在：</p>
<pre><code>git clone git@wztlink1013.github.com: wztlink1013/learngit.git
git clone git@twicename.github.com: twicename/learngit.git
</code></pre><ul>
<li>单独为每个 repo 设置 用户名/邮箱【以文件夹为单位】</li>
</ul>
<pre><code>git config user.name &quot;wztlink1013&quot;
git config user.email &quot;2550374815@qq.com&quot;

git config user.name &quot;twicename&quot;
git config user.email &quot;123456789@qq.com&quot;
</code></pre><p>如果报错：<code>fatal: not in a git directory</code>，说明没有进入.git 目录下，具体路径：其中.git 目录是隐藏的，需要你设置隐藏目录可见<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1597632490310-1580343b-946c-4d67-a063-d5cd11bc6136.png#align=left&amp;display=inline&amp;height=105&amp;margin=%5Bobject%20Object%5D&amp;originHeight=105&amp;originWidth=925&amp;size=0&amp;status=done&amp;style=none&amp;width=925" alt></p>
<p>执行<code>git config --list</code>查看设置是否成功</p>
<h2 id="六、参考资料"><a href="#六、参考资料" class="headerlink" title="六、参考资料"></a>六、参考资料</h2><ul>
<li><a href="https://github.com/guobinhit/cg-blog/blob/master/articles/github/README.md" target="_blank" rel="noopener">GitHub 简单使用 https://github.com/guobinhit/cg-blog/blob/master/articles/github/README.md</a></li>
<li><a href="https://www.itrhx.com/2019/01/18/A16-deploy-two-or-more-hexo-blogs/" target="_blank" rel="noopener">多账号 https://www.itrhx.com/2019/01/18/A16-deploy-two-or-more-hexo-blogs/</a></li>
<li><a href="https://blog.csdn.net/u013716535/article/details/78621775" target="_blank" rel="noopener">多账号 https://blog.csdn.net/u013716535/article/details/78621775</a></li>
<li><a href="https://blog.csdn.net/IT_xiao_bai/article/details/88563103?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task" target="_blank" rel="noopener">多账号 https://blog.csdn.net/IT_xiao_bai/article/details/88563103?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task</a></li>
</ul>
]]></content>
      <categories>
        <category>Environment</category>
      </categories>
  </entry>
  <entry>
    <title>贪心算法-Kruskal 算法</title>
    <url>/blog/ghf568/</url>
    <content><![CDATA[<h2 id="一些概念"><a href="#一些概念" class="headerlink" title="一些概念"></a>一些概念</h2><p><strong>连通图</strong></p>
<blockquote>
<p>在<a href="https://baike.baidu.com/item/%E5%9B%BE%E8%AE%BA/1433806" target="_blank" rel="noopener">图论</a>中，连通图基于连通的概念。在一个<a href="https://baike.baidu.com/item/%E6%97%A0%E5%90%91%E5%9B%BE/1680427" target="_blank" rel="noopener">无向图</a> G 中，若从<a href="https://baike.baidu.com/item/%E9%A1%B6%E7%82%B9/11030118" target="_blank" rel="noopener">顶点</a>i 到顶点 j 有路径相连（当然从 j 到 i 也一定有路径），则称 i 和 j 是连通的。如果 G 是<a href="https://baike.baidu.com/item/%E6%9C%89%E5%90%91%E5%9B%BE" target="_blank" rel="noopener">有向图</a>，那么连接 i 和 j 的路径中所有的边都必须同向。如果图中任意两点都是连通的，那么图被称作连通图。如果此图是有向图，则称为强连通图（注意：需要双向都有路径）。图的<a href="https://baike.baidu.com/item/%E8%BF%9E%E9%80%9A%E6%80%A7/6688865" target="_blank" rel="noopener">连通性</a>是图的基本性质。</p>
</blockquote>
<p><strong>生成树</strong></p>
<blockquote>
<p>包含图的全部顶点，边数最少的连通子图</p>
</blockquote>
<p><strong>最小生成树</strong></p>
<blockquote>
<p>总权值最小的生成树</p>
</blockquote>
<p>常见问题（该算法）就是求最小生成树。<br><strong>并查集</strong></p>
<blockquote>
<p>是一个数据结构，功能有查找 a 和 b 是否为同一组；将 a 和 b 合并为同一组。</p>
</blockquote>
<h2 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h2><p>把所有边按照权值全部按数值大小拿出来，然后按顺序选取每条边，利用并查集的思想，如果这条边的两个端点不属于同一集合，那么就将它们合并，直到所有的点都属于同一个集合为止。</p>
<p>比如有如下这么一个图：<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1605320252853-c5d445e4-aa0e-4279-b9fd-7477f23b1bc1.png#align=left&amp;display=inline&amp;height=95&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=189&amp;originWidth=438&amp;size=10882&amp;status=done&amp;style=shadow&amp;width=219" alt="image.png"><br>单独分析 ①② 边和 ③④ 边情况下，两个不在一个集合里面，<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1605320331669-51ec03dc-caf6-449d-9e8b-e4e62b9f35a6.png#align=left&amp;display=inline&amp;height=96&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=192&amp;originWidth=769&amp;size=21600&amp;status=done&amp;style=shadow&amp;width=384.5" alt="image.png"><br>不断重复，不断判断是否为同一个集合，不在同一个集合的话，就合并，持续如此。比方说当一直操作到权值为 3 的时候，此时就需要将左右两个集合合并了<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1605320497092-00097419-4852-44c4-884e-febd4d37eb65.png#align=left&amp;display=inline&amp;height=101&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=202&amp;originWidth=748&amp;size=22229&amp;status=done&amp;style=shadow&amp;width=374" alt="image.png"><br>最后的结果样式就为如下<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1605320612085-d893c759-4ef1-410c-976e-8f32ddfe6321.png#align=left&amp;display=inline&amp;height=146&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=292&amp;originWidth=780&amp;size=31319&amp;status=done&amp;style=shadow&amp;width=390" alt="image.png"></p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><pre><code class="cpp">#include &lt;stdio.h&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
namespace NS_KruskalMST {
using namespace std;
void KruskalMST();
int FindSet(int u);
void UnionSets(int u, int v);
void Initialization();
void GenEdges();
void MakeSets();
void Output(int v0);
#define INF INT_MAX
static int n;
static vector&lt;vector&lt;int&gt;&gt; WMatrix;
static vector&lt;pair&lt;pair&lt;int, int&gt;, int&gt;&gt; Edges;
//Node struct for the disjoint set
struct DJSNode {
    int Parent; int Rank;
    DJSNode(int p) : Parent(p), Rank(0) {}
};
static vector&lt;DJSNode&gt; DisjointSet;
static vector&lt;pair&lt;int, int&gt;&gt; MST;
//The adjacency list for MST
static vector&lt;vector&lt;int&gt;&gt; MSTList;
static vector&lt;int&gt; Prev;
void KruskalMSTCaller(int an,
    vector&lt;vector&lt;int&gt;&gt; &amp;wMatrix, int v0)
{
    n = an;
    WMatrix = wMatrix;
    Initialization();
    KruskalMST();
    Output(v0);
}
void KruskalMST()
{
    for (auto &amp;e: Edges)
    {
        int u = e.first.first;
        int v = e.first.second;
        int setU = FindSet(u);
        int setV = FindSet(v);
        if (setU != setV)
        {
            MST.push_back(e.first);
            if (MST.size() == n - 1)
                break;
            UnionSets(setU, setV);
        }
    }
}
int FindSet(int u)
{
    while (u != DisjointSet[u].Parent)
        u = DisjointSet[u].Parent;
        //For path compression:
        //DisjointSet[u].Parent =
        //    FindSet(DisjointSet[u].Parent);
    return u;
}
void UnionSets(int u, int v)
{
    if (DisjointSet[u].Rank &gt;= DisjointSet[v].Rank)
        DisjointSet[v].Parent = u;
    else
        DisjointSet[u].Parent = v;
    if (DisjointSet[u].Rank == DisjointSet[v].Rank)
        DisjointSet[u].Rank++;
}
void Initialization()
{
    GenEdges();
    sort(Edges.begin(), Edges.end(),
        [](pair&lt;pair&lt;int, int&gt;, int&gt;a,
            pair&lt;pair&lt;int, int&gt;, int&gt;b)
        {return a.second &lt; b.second; });
    MakeSets();
    MST.clear();
}
void GenEdges()
{
    Edges.clear();
    //Traverse the upper triangle of WMatrix
    for (int i = 0; i &lt; n - 1; i++)
    {
        for (int j = i + 1; j &lt; n; j++)
            if (WMatrix[i][j] != INF)
                Edges.push_back({ {i, j},
                    WMatrix[i][j] });
    }
}
void MakeSets()
{
    DisjointSet.clear();
    for (int i = 0; i &lt; n; i++)
        DisjointSet.push_back(DJSNode(i));
}
void OutputWMatrix()
{
    printf(&quot;n = %d\n&quot;, n);
    printf(&quot;The weight matrix:\n&quot;);
    printf(&quot;%3c&quot;, &#39; &#39;);
    for (int j = 0; j &lt; n; j++)
        printf(&quot;%3d&quot;, j + 1);
    printf(&quot;\n&quot;);
    for (int i = 0; i &lt; n; i++)
    {
        printf(&quot;%3d&quot;, i + 1);
        for (auto j : WMatrix[i])
            if (j &lt; INF)
                printf(&quot;%3d&quot;, j);
            else
                printf(&quot;%3c&quot;, &#39;*&#39;);
        printf(&quot;\n&quot;);
    }
}
void OutputPath(int u)
{
    if (Prev[u] == -1)
        printf(&quot;%d&quot;, u + 1);
    else
    {
        OutputPath(Prev[u]);
        printf(&quot;-%d&quot;, u + 1);
    }
}
void GenMSTList()
{
    MSTList.clear();
    MSTList.resize(n);
    for (auto &amp;e: MST)
    {
        MSTList[e.first].push_back(e.second);
        MSTList[e.second].push_back(e.first);
    }
}
void GenPrev(int v)
{
    for (auto &amp;u : MSTList[v])
        if (u != -1)
        {
            Prev[u] = v;
            auto w = find(MSTList[u].begin(),
                MSTList[u].end(), v);
            MSTList[u][w - MSTList[u].begin()] = -1;
            GenPrev(u);
        }
}
void Output(int v0)
{
    printf(&quot;Kruskal&#39;s MST algorithm\n&quot;);
    OutputWMatrix();
    int wSum = 0;
    for (int i = 0; i &lt; n - 1; i++)
        wSum += WMatrix[MST[i].first][MST[i].second];
    GenMSTList();
    Prev.clear();
    Prev.resize(n);
    Prev[v0] = -1;
    GenPrev(v0);
    printf(&quot;The MST edges:\n&quot;);
    printf(&quot;Edge Weight\n&quot;);
    for (auto &amp;e : MST)
        printf(&quot; %d-%d  %d\n&quot;, e.first + 1, e.second + 1,
            WMatrix[e.first][e.second]);
    printf(&quot;Total MST weight: %d\n&quot;, wSum);
    printf(&quot;The MST paths from vertex %d:\n&quot;, v0 + 1);
    for (int u = 0; u &lt; n; u++)
        if (u != v0)
        {
            printf(&quot;%3d: &quot;, u + 1);
            OutputPath(u);
            printf(&quot;\n&quot;);
        }
    printf(&quot;\n&quot;);
}
} //namespace NS_KruskalMST
using namespace NS_KruskalMST;
void TestKruskalMST(int v0 = 0)
{
    vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt; w = {
        //https://www.geeksforgeeks.org/
        //prims-minimum-spanning-tree-mst-greedy-algo-5/
        {
            {   0,  2,INF,  6,INF },
            {   2,  0,  3,  8,  5 },
            { INF,  3,  0,INF,  7 },
            {   6,  8,INF,  0,  9 },
            { INF,  5,  7,  9,  0 }
        },
        // Dijkstra&#39;s algorithm on Wikipedia
        {
            {   0,  7,  9,INF,INF, 14 },
            {   7,  0, 10, 15,INF,INF },
            {   9, 10,  0, 11,INF,  2 },
            { INF, 15, 11,  0,  6,INF },
            { INF,INF,INF,  6,  0,  9 },
            {  14,INF,  2,INF,  9,  0 },
        },
        //https://www.geeksforgeeks.org/
        //kruskals-minimum-spanning-tree-using-stl-in-c/
        {
            {   0,  4,INF,INF,INF,INF,INF,  8,INF },
            {   4,  0,  8,INF,INF,INF,INF, 11,INF },
            { INF,  8,  0,  7,INF,  4,INF,INF,  2 },
            { INF,INF,  7,  0,  9, 14,INF,INF,INF },
            { INF,INF,INF,  9,  0, 10,INF,INF,INF },
            { INF,INF,  4, 14, 10,  0,  2,INF,INF },
            { INF,INF,INF,INF,INF,  2,  0,  1,  6 },
            {   8, 11,INF,INF,INF,INF,  1,  0,  7 },
            { INF,INF,  2,INF,INF,INF,  6,  7,  0 },
        },
    };
    int k = w.size();
    for (int i = 0; i &lt; k; i++)
    {
      if (v0 &gt; w[i].size() - 1)
        v0 = w[i].size() - 1;
      KruskalMSTCaller(w[i].size(), w[i], v0);
    }
}
</code></pre>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>银行家算法（C++实现）</title>
    <url>/blog/kc645t/</url>
    <content><![CDATA[<h2 id="一、银行家算法"><a href="#一、银行家算法" class="headerlink" title="一、银行家算法"></a>一、银行家算法</h2><p><strong>功能：避免死锁</strong></p>
<blockquote>
<p>在银行中，客户申请贷款的数量是有限的，每个客户在第一次申请贷款时要声明完成该项目所需的最大资金量，在满足所有贷款要求时，客户应及时归还。银行家在客户申请的贷款数量不超过自己拥有的最大值时，都应尽量满足客户的需要。在这样的描述中，银行家就好比操作系统，资金就是资源，客户就相当于要申请资源的进程。</p>
</blockquote>
<h2 id="二、代码实现"><a href="#二、代码实现" class="headerlink" title="二、代码实现"></a>二、代码实现</h2><pre><code class="cpp">#include &lt;iostream&gt;
using namespace std;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
//定义全局变量
const int x=50,y=50; //x为进程个数 y为资源种类数
int Available[y]; //各资源可利用的数量
int Allocation[x][y]; //各进程当前已分配的资源数量
int Max[x][y]; //各进程对各类资源的最大需求数
int Need[x][y]; //尚需多少资源
int Request[y]; //申请多少资源
int Work[y]; //工作向量，表示系统可提供给进程继续运行所需的各类资源数量
int Finish[x]; //表示系统是否有足够的资源分配给进程，1为是
int p[x]; //存储安全序列
int i,j; //i表示进程，j表示资源
int n,m; //n为进程i的数量,m为资源j种类数
int l=0; //l用来记录有几个进程是Finish[i]=1的，当l=n是说明系统状态是安全的
int counter=0; //记数器,记录可执行的进程数
//函数声明
void chushihua(); //初始化函数
void safe(); //安全性算法
void show(); //函数show,输出当前状态
void bank(); //银行家算法
void jieshu(); //结束函数
void chushihua()
{
cout&lt;&lt;&quot;输入进程的数量: &quot;;//从此开始输入有关数据
cin&gt;&gt;n;
cout&lt;&lt;&quot;输入资源种类数: &quot;;
cin&gt;&gt;m;
cout&lt;&lt;endl&lt;&lt;&quot;输入各种资源当前可用的数量( &quot;&lt;&lt;m&lt;&lt;&quot; 种): &quot;&lt;&lt;endl;
for (j=0; j&lt;m; j++)//m为资源数
{
cout&lt;&lt;&quot;输入资源 &quot;&lt;&lt;j&lt;&lt;&quot; 可利用的数量Available[&quot;&lt;&lt;j&lt;&lt;&quot;]: &quot;;
cin&gt;&gt;Available[j]; //输入数字的过程
Work[j]=Available[j]; //初始化Work[j]，它的初始值就是当前可用的资源数
}
cout&lt;&lt;endl&lt;&lt;&quot;输入各进程当前已分配的资源数量Allocation[&quot;&lt;&lt;n&lt;&lt;&quot;][&quot;&lt;&lt;m&lt;&lt;&quot;]: &quot;&lt;&lt;endl;
for (i=0; i&lt;n; i++) //n为进程数
{
for (j=0; j&lt;m; j++)//m为资源数
{
cout&lt;&lt;&quot; 输入进程 &quot;&lt;&lt;i&lt;&lt;&quot; 当前已分配的资源 &quot;&lt;&lt;j&lt;&lt;&quot; 数量: &quot;;
cin&gt;&gt;Allocation[i][j];
}
cout&lt;&lt;endl;
Finish[i]=0;//初始化Finish[i]
}
cout&lt;&lt;endl&lt;&lt;&quot;输入各进程对各类资源的最大需求Max[&quot;&lt;&lt;n&lt;&lt;&quot;][&quot;&lt;&lt;m&lt;&lt;&quot;]: &quot;&lt;&lt;endl;
for (i=0; i&lt;n; i++)//n为进程数
{
for (j=0; j&lt;m; j++)//m为资源数
{
cout&lt;&lt;&quot; 输入进程 &quot;&lt;&lt;i&lt;&lt;&quot; 对资源 &quot;&lt;&lt;j&lt;&lt;&quot; 的最大需求数: &quot;;
cin&gt;&gt;Max[i][j];
if(Max[i][j]&gt;=Allocation[i][j]) //若最大需求大于已分配，则计算需求量
Need[i][j] = Max[i][j]-Allocation[i][j];
else
Need[i][j]=0;//Max小于已分配的时候，此类资源已足够不需再申请
}
cout&lt;&lt;endl;
}
cout&lt;&lt;endl&lt;&lt;&quot;初始化完成&quot;&lt;&lt;endl;
}
//安全性算法函数
void safe()
{
l=0;//l用来记录有几个进程是Finish[i]=1的，当l=n是说明系统状态是安全的
for (i=0; i&lt;n;i++)//n为进程数
{
if (Finish[i]==0)
{ //逐个查找Finish[i]==0的进程 条件一
counter=0; //记数器,记录有多少个进程已经执行
for (j=0; j&lt;m; j++)//m为资源数
{
if (Work[j]&gt;=Need[i][j])
counter=counter+1;//可用大于需求，记数，该进程可以执行
}
if(counter==m) //i进程的每类资源都符合Work[j]&gt;=Need[i][j] 条件二
{
p[l]=i; //存储安全序列
Finish[i]=1; //i进程标志为可分配
for (j=0; j&lt;m;j++)
Work[j]=Work[j]+Allocation[i][j]; //释放资源
l=l+1; //记数,现在有l个进程是安全的，当l=n时说明满足安全序列
i= -1; //从第一个进程开始继续寻找满足条件一二的进程
}
}
}
}
//显示当前状态函数
void show() //函数show,输出当前资源分配情况
{
int i,j; //局部变量，i表示进程，j表示资源
int All[y]; //各种资源的总数量
int L1; //局部变量L1
cout&lt;&lt;&quot;当前的状态为：&quot;&lt;&lt;endl;
cout&lt;&lt;&quot;各种资源的总数量:&quot;&lt;&lt;endl;
for (j=0;j&lt;m;j++)//m为资源数
{
cout&lt;&lt;&quot; 资源&quot;&lt;&lt;j&lt;&lt;&quot;: &quot;;
All[j]=Available[j]; //总数量=可用的+已分配的
for(i=0;i&lt;n;i++) //n为进程数
All[j]+=Allocation[i][j];
cout&lt;&lt;All[j]&lt;&lt;&quot; &quot;;
}
cout&lt;&lt;endl&lt;&lt;&quot;当前各种资源可用的量为(available):&quot;&lt;&lt;endl;
for(j=0;j&lt;m;j++)//m为资源数
cout&lt;&lt;&quot; 资源&quot;&lt;&lt;j&lt;&lt;&quot;: &quot;&lt;&lt;Available[j]&lt;&lt;&quot; &quot;;
cout&lt;&lt;endl&lt;&lt;&quot;各进程所需的最大资源量(Max): &quot;&lt;&lt;endl;
for(i=0;i&lt;m;i++)//m为资源数
{
cout&lt;&lt;&quot; 资源&quot;&lt;&lt;i&lt;&lt;&quot; &quot;;
}
cout&lt;&lt;endl;
for(L1=0;L1&lt;n;L1++)//n为进程数
{
cout&lt;&lt;&quot;进程&quot;&lt;&lt;L1&lt;&lt;&quot;: &quot;;
for (j=0;j&lt;m;j++)
cout&lt;&lt;Max[L1][j]&lt;&lt;&quot; &quot;;
cout&lt;&lt;endl;
}
cout&lt;&lt;endl&lt;&lt;&quot;各进程已经得到的资源量(allocation): &quot;&lt;&lt;endl;
for(i=0;i&lt;m;i++)//m为资源数
{
cout&lt;&lt;&quot; 资源&quot;&lt;&lt;i&lt;&lt;&quot; &quot;;
}
cout&lt;&lt;endl;
for(L1=0;L1&lt;n;L1++)//n为进程数
{
cout&lt;&lt;&quot;进程&quot;&lt;&lt;L1&lt;&lt;&quot;: &quot;;
for (j=0;j&lt;m;j++)
cout&lt;&lt;Allocation[L1][j]&lt;&lt;&quot; &quot;;
cout&lt;&lt;endl;
}
cout&lt;&lt;endl&lt;&lt;&quot;各进程还需要的资源量(need):&quot;&lt;&lt;endl;
for(i=0;i&lt;m;i++)//m为资源数
{
cout&lt;&lt;&quot; 资源&quot;&lt;&lt;i&lt;&lt;&quot; &quot;;
}
cout&lt;&lt;endl;
for(L1=0;L1&lt;n;L1++)
{
cout&lt;&lt;&quot;进程&quot;&lt;&lt;L1&lt;&lt;&quot;: &quot;;
for (j=0;j&lt;m;j++)
cout&lt;&lt;Need[L1][j]&lt;&lt;&quot; &quot;;
cout&lt;&lt;endl;
}
}
//银行家算法函数
void bank()
{
cout&lt;&lt;endl&lt;&lt;&quot;进程申请分配资源：&quot;&lt;&lt;endl;
int k=0; //用于输入进程编号
bool r=false; // 初值为假，输入Y继续申请则置为真
do{//输入请求
cout&lt;&lt;&quot;输入申请资源的进程(0-&quot;&lt;&lt;n-1&lt;&lt;&quot;): &quot;;
cin&gt;&gt;k;//进程编号
cout&lt;&lt;endl;
while(k&gt;n-1) //输入错误处理
{
cout&lt;&lt;endl&lt;&lt;&quot;无该进程号，重新输入：&quot;&lt;&lt;endl;
cout&lt;&lt;endl&lt;&lt;&quot;输入申请资源的进程(0--&quot;&lt;&lt;n-1&lt;&lt;&quot;): &quot;;
cin&gt;&gt;k;//进程编号
cout&lt;&lt;endl;
}
cout&lt;&lt;endl&lt;&lt;&quot;输入该进程申请各类资源的数量: &quot;&lt;&lt;endl;
for (j=0; j&lt;m; j++)//m为资源数
{
do{ //do……while 循环判断申请输入的情况
cout&lt;&lt;&quot;进程 &quot;&lt;&lt;k&lt;&lt;&quot; 申请资源[&quot;&lt;&lt;j&lt;&lt;&quot;]的数量:&quot;;
cin&gt;&gt;Request[j];//输入请求进程数
cout&lt;&lt;endl;
if(Request[j]&gt;Need[k][j]){ //申请大于需求量时出错，提示重新输入 cout&lt;&lt;&quot;申请量大于需要量!&quot;&lt;&lt;endl;
cout&lt;&lt;&quot;申请的资源&quot;&lt;&lt;j&lt;&lt;&quot;的数量为&quot;&lt;&lt;Request[j]&lt;&lt;&quot;,大于进程&quot;&lt;&lt;k&lt;&lt;&quot;对该资源需求量&quot;&lt;&lt;Need[k][j]&lt;&lt;&quot;。&quot;&lt;&lt;endl;
cout&lt;&lt;&quot;重新输入!&quot;&lt;&lt;endl;
}
//先判断是否申请大于需求量，再判断是否申请大于可利用量
else if(Request[j]&gt;Available[j]){ //申请大于可利用量， 应该阻塞等待
cout&lt;&lt;&quot;\n没有那么多资源，目前可利用资源&quot;&lt;&lt;j&lt;&lt;&quot;数量为&quot;&lt;&lt;Available[j]&lt;&lt;&quot;,本次申请不成功，进程等待!&quot;&lt;&lt;endl;
Finish[k]=0; //该进程等待
goto error; //goto语句跳转，结束本次申请
}
}while(Request[j]&gt;Need[k][j]); //Request[j]&gt;Available[j]
}
//改变Available、Allocation、Need的值
for (j=0; j&lt;m; j++) {//m为资源数
Available[j] = Available[j]-Request[j];//可用的资源数=可用的资源数-请求分配的资源数
Allocation[k][j] = Allocation[k][j]+Request[j];//已分配的资源数=已分配的资源数+请求的资源数
Need[k][j] = Need[k][j]-Request[j];//还需要的资源数=还需要的资源数-请求的资源数
Work[j] = Available[j];
}
safe(); //调用安全性算法函数，判断当前状态的安全性
if (l&lt;n)//l用来记录有几个进程是Finish[i]=1的，当l=n是说明系统状态是安全的
{
l=0;
cout&lt;&lt;&quot;\n试分配后,状态不安全,所以不予分配!恢复原状态&quot;&lt;&lt;endl;
//恢复数据
for (j=0; j&lt;m; j++)//m为资源数
{
Available[j] = Available[j]+Request[j];
Allocation[k][j] = Allocation[k][j]-Request[j];
Need[k][j] = Need[k][j]+Request[j];
Work[j] = Available[j];
}
for (i=0; i&lt;n; i++)//n为进程数
Finish[i]=0; //进程均置为未分配状态
}
else//l=n，即所有的Finish[i]=1,每一个进程均能执行
{
l=0;//判断标志
cout&lt;&lt;&quot;\n申请资源成功!!!&quot;&lt;&lt;endl;
for(j=0;j&lt;m;j++)//m为资源数
{
if(Need[k][j]==0);
else { //有一种资源还没全部申请到，则该进程不可执行，不能释放拥有的资源
l=1; //置l为1，作为判断标志
break;
}
}
if(l!=1){ //进程可以执行，则释放该进程的所有资源
for (j=0;j&lt;m;j++){//m为资源数
Available[j]=Available[j]+Allocation[k][j];
Allocation[k][j]=0;
}
cout&lt;&lt;&quot;该进程已得到所有需求资源，执行后将释放其所有拥有资源！&quot;&lt;&lt;endl;
}
l=0; //归零
cout&lt;&lt;&quot;\n安全的状态!&quot;&lt;&lt;endl;
cout&lt;&lt;&quot;安全序列为: &quot;;
cout&lt;&lt;endl&lt;&lt;&quot;进程&quot;&lt;&lt;&quot;(&quot;&lt;&lt;p[0]&lt;&lt;&quot;)&quot;; //输出安全序列，考虑显示格式，先输出第一个
Finish[0]=0;
for (i=1; i&lt;n; i++){
cout&lt;&lt;&quot;==&gt;&gt;&quot;&lt;&lt;&quot;进程&quot;&lt;&lt;&quot;(&quot;&lt;&lt;p[i]&lt;&lt;&quot;)&quot;;
Finish[i]=0; //所有进程置为未分配状态
}
cout&lt;&lt;endl&lt;&lt;endl;
}
show(); //显示当前状态
error: //申请大于可利用量， 应该阻塞等待,结束本次资源申请，GOTO 语句跳转至此
cout&lt;&lt;endl&lt;&lt;&quot;是否继续申请资源(y/n)或（Y/N）?&quot;;
char* b=new char; //输入y/n，判断是否继续申请 &lt;&lt;endl
cin&gt;&gt;b;
cout&lt;&lt;endl;
cout&lt;&lt;&quot;-------------------------------------------&quot;&lt;&lt;endl&lt;&lt;endl;
cout&lt;&lt;endl;
if(*b==&#39;y&#39;||*b==&#39;Y&#39;)
r=true;//继续申请
else{
r=false; //不继续申请
jieshu(); //调用结束函数
}
} while (r==true);
}
//结束函数
void jieshu()
{
cout&lt;&lt;endl&lt;&lt;endl;
cout&lt;&lt;&quot;\t\t 演示计算完毕&quot;&lt;&lt;endl;
cout&lt;&lt;endl&lt;&lt;endl;
}
//主函数
int main()
{
cout&lt;&lt;endl&lt;&lt;endl&lt;&lt;&quot;\t\t\t\t模拟银行家算法&quot;&lt;&lt;endl&lt;&lt;endl;
chushihua(); //初始化函数调用
cout&lt;&lt;endl;
show(); //输出当前状态
safe(); //判断当前状态的安全性
if (l&lt;n) //l在safe中是用来记录安全的进程的个数的
{
cout&lt;&lt;&quot;\n当前状态不安全，拒绝申请！&quot;&lt;&lt;endl;
cout&lt;&lt;endl;
return 0;
}
else
{
int i; //局部变量
l=0;
cout&lt;&lt;endl&lt;&lt;&quot;\n当前的状态是安全的!安全序列为:&quot;&lt;&lt;endl;
cout&lt;&lt;&quot;进程&quot;&lt;&lt;&quot;(&quot;&lt;&lt;p[0]&lt;&lt;&quot;)&quot;; //输出安全序列
for (i=1; i&lt;n; i++)
cout&lt;&lt;&quot;-&gt;&gt;&quot;&lt;&lt;&quot;进程&quot;&lt;&lt;&quot;(&quot;&lt;&lt;p[i]&lt;&lt;&quot;)&quot;;
for (i=0; i&lt;n; i++)
Finish[i]=0; //所有进程置为未分配状态
cout&lt;&lt;endl;
}
bank(); //调用银行家算法函数
cout&lt;&lt;&quot;\t\t 演示计算完毕&quot;&lt;&lt;endl;
return 0;
}

</code></pre>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>pandas基本知识</title>
    <url>/blog/li8bkt/</url>
    <content><![CDATA[<h2 id="一、Pandas-数据结构"><a href="#一、Pandas-数据结构" class="headerlink" title="一、Pandas 数据结构"></a>一、Pandas 数据结构</h2><pre><code class="python">import pandas as pd
</code></pre>
<h3 id="Series"><a href="#Series" class="headerlink" title="Series"></a>Series</h3><blockquote>
<ol>
<li>通过 list 构建 Series</li>
</ol>
</blockquote>
<pre><code class="python">ser_obj = pd.Series(range(10, 20,2))
print (type(ser_obj))
print(ser_obj)
</code></pre>
<pre><code>&lt;class &#39;pandas.core.series.Series&#39;&gt;
0    10
1    12
2    14
3    16
4    18
dtype: int64
</code></pre><pre><code class="python"># 获取数据
print (ser_obj.values)

# 获取索引
print (ser_obj.index)
#范围索引数据类型

# 预览数据
print (ser_obj.head(3))
#默认输出五行
</code></pre>
<pre><code>[10 12 14 16 18]
RangeIndex(start=0, stop=5, step=1)
0    10
1    12
2    14
dtype: int64
</code></pre><blockquote>
<ol start="2">
<li>通过 dict 构建 Series</li>
</ol>
</blockquote>
<pre><code class="python">year_data = {2001: 17.8, 2002: 20.1, 2003: 16.5,2004:324,2423:243}
ser_obj2 = pd.Series(year_data)
print (ser_obj2.head(2))
print (ser_obj2.index)
print(ser_obj2)
</code></pre>
<pre><code>2001    17.8
2002    20.1
dtype: float64
Int64Index([2001, 2002, 2003, 2004, 2423], dtype=&#39;int64&#39;)
2001     17.8
2002     20.1
2003     16.5
2004    324.0
2423    243.0
dtype: float64
</code></pre><pre><code class="python"># name属性【【【【【出问题了！！！】】】】】
ser_obj2.name = &#39;钱&#39;
ser_obj2.index.name = &#39;year&#39;
print (ser_obj2.head())
</code></pre>
<pre><code>year
2001     17.8
2002     20.1
2003     16.5
2004    324.0
2423    243.0
Name: 钱, dtype: float64
</code></pre><h3 id="DataFrame"><a href="#DataFrame" class="headerlink" title="DataFrame"></a>DataFrame</h3><blockquote>
<ol>
<li>通过 ndarray 构建 DataFrame</li>
</ol>
</blockquote>
<pre><code class="python">import numpy as np

array = np.random.rand(5,4)
print (array)

df_obj = pd.DataFrame(array,columns=[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;])
print (df_obj.head())
print(df_obj.sort_values(by=&#39;a&#39;, ascending=False))
</code></pre>
<pre><code>[[0.23496522 0.92258429 0.36447462 0.52634697]
 [0.73743514 0.88175941 0.48944212 0.4173522 ]
 [0.21214568 0.57148666 0.59496072 0.49490723]
 [0.7458542  0.74743907 0.70475157 0.28130394]
 [0.43805937 0.90300134 0.00730653 0.68203725]]
          a         b         c         d
0  0.234965  0.922584  0.364475  0.526347
1  0.737435  0.881759  0.489442  0.417352
2  0.212146  0.571487  0.594961  0.494907
3  0.745854  0.747439  0.704752  0.281304
4  0.438059  0.903001  0.007307  0.682037
          a         b         c         d
3  0.745854  0.747439  0.704752  0.281304
1  0.737435  0.881759  0.489442  0.417352
4  0.438059  0.903001  0.007307  0.682037
0  0.234965  0.922584  0.364475  0.526347
2  0.212146  0.571487  0.594961  0.494907
</code></pre><blockquote>
<ol start="2">
<li>通过 dict 构建 DataFrame</li>
</ol>
</blockquote>
<pre><code class="python">#一个键值对就相当于一列！！但是具体到字典里面的值所用到的一些函数还是不能很清楚
dict_data = {&#39;A&#39;: 1.,
             &#39;B&#39;: pd.Timestamp(&#39;20161217&#39;),
             &#39;C&#39;: pd.Series(1, index=list(range(4)),dtype=&#39;float32&#39;),
             &#39;D&#39;: np.array([3] * 4,dtype=&#39;int32&#39;),
             &#39;E&#39; : pd.Categorical([&quot;Python&quot;,&quot;Java&quot;,&quot;C++&quot;,&quot;C#&quot;]),
             &#39;F&#39; : &#39;ChinaHadoop&#39; }
df_obj2 = pd.DataFrame(dict_data)
print (df_obj2.head())
</code></pre>
<pre><code>     A          B    C  D       E            F
0  1.0 2016-12-17  1.0  3  Python  ChinaHadoop
1  1.0 2016-12-17  1.0  3    Java  ChinaHadoop
2  1.0 2016-12-17  1.0  3     C++  ChinaHadoop
3  1.0 2016-12-17  1.0  3      C#  ChinaHadoop
</code></pre><pre><code class="python"># 增加列
df_obj2[&#39;G&#39;] = df_obj2[&#39;D&#39;] + 4
print (df_obj2.head())
xxx = pd.DataFrame(df_obj2,columns=[&#39;A&#39;,&#39;B&#39;,&#39;C&#39;,&#39;D&#39;,&#39;E&#39;,&#39;F&#39;,&#39;G&#39;,&#39;H&#39;],index=[0,1,2,3,4])
print(xxx)
</code></pre>
<pre><code>     A          B    C  D       E            F  G
0  1.0 2016-12-17  1.0  3  Python  ChinaHadoop  7
1  1.0 2016-12-17  1.0  3    Java  ChinaHadoop  7
2  1.0 2016-12-17  1.0  3     C++  ChinaHadoop  7
3  1.0 2016-12-17  1.0  3      C#  ChinaHadoop  7
     A          B    C    D       E            F    G   H
0  1.0 2016-12-17  1.0  3.0  Python  ChinaHadoop  7.0 NaN
1  1.0 2016-12-17  1.0  3.0    Java  ChinaHadoop  7.0 NaN
2  1.0 2016-12-17  1.0  3.0     C++  ChinaHadoop  7.0 NaN
3  1.0 2016-12-17  1.0  3.0      C#  ChinaHadoop  7.0 NaN
4  NaN        NaT  NaN  NaN     NaN          NaN  NaN NaN
</code></pre><h3 id="Index"><a href="#Index" class="headerlink" title="Index"></a>Index</h3><pre><code class="python">print (type(ser_obj.index))
print (type(df_obj2.index))

print (df_obj2.index)
</code></pre>
<pre><code>&lt;class &#39;pandas.core.indexes.range.RangeIndex&#39;&gt;
&lt;class &#39;pandas.core.indexes.numeric.Int64Index&#39;&gt;
Int64Index([0, 1, 2, 3], dtype=&#39;int64&#39;)
</code></pre><pre><code class="python"># 索引对象不可变
df_obj2.index[0] = 2
</code></pre>
<pre><code>---------------------------------------------------------------------------

TypeError                                 Traceback (most recent call last)

&lt;ipython-input-10-6367894e76d8&gt; in &lt;module&gt;
      1 # 索引对象不可变
----&gt; 2 df_obj2.index[0] = 2


~\Anaconda3\lib\site-packages\pandas\core\indexes\base.py in __setitem__(self, key, value)
   4258
   4259     def __setitem__(self, key, value):
-&gt; 4260         raise TypeError(&quot;Index does not support mutable operations&quot;)
   4261
   4262     def __getitem__(self, key):


TypeError: Index does not support mutable operations
</code></pre><h2 id="二、Pandas-数据操作"><a href="#二、Pandas-数据操作" class="headerlink" title="二、Pandas 数据操作"></a>二、Pandas 数据操作</h2><h3 id="常用函数总结"><a href="#常用函数总结" class="headerlink" title="常用函数总结"></a>常用函数总结</h3><blockquote>
<p>·shape   获取数据的尺寸</p>
</blockquote>
<pre><code> 获得df的size：df.shape
 获得df中的行数：df.shape[0]
 获得df中的列数： df.shape[1]
 获得行索引信息：df.index
 获得列索引信息：df.colomns
</code></pre><blockquote>
<p>·values   获得 df 中的值===中文没用</p>
</blockquote>
<pre><code>df.values === 以列表的形式展现出来，去除了索引===dataframe类型数据转换成array类型
</code></pre><blockquote>
<p>·setindex 和 resetindex</p>
</blockquote>
<pre><code>reset_index可以还原索引，从新变为默认的整型索引
    DataFrame.reset_index(level=None, drop=False, inplace=False, col_level=0, col_fill=”)
    level控制了具体要还原的那个等级的索引
    drop为False则索引列会被还原为普通列，否则会丢失
set_index方法，设置单索引和复合索引抑或是添加索引。
    DataFrame.set_index(keys, drop=True, append=False, inplace=False, verify_integrity=False)
    append添加新索引，drop为False，inplace为True时，索引将会还原为列
</code></pre><blockquote>
<p>·iterrows（）遍历 DataFrame 中的数据</p>
</blockquote>
<pre><code>for index,row in df.iterrows():
</code></pre><blockquote>
<p>·split(sep,n,expand=false)</p>
</blockquote>
<pre><code>sep表示用于分割的字符；n表格分割成多少列；expand表示是否展开为数据款，True输出Series，False输出Dataframe。
字段拆分：是指按照固定的字符，拆分已有字符串
</code></pre><pre><code class="python">import pandas as pd
import numpy as np
</code></pre>
<h3 id="匿名函数应用"><a href="#匿名函数应用" class="headerlink" title="匿名函数应用"></a>匿名函数应用</h3><pre><code class="python"># Numpy ufunc 函数
df = pd.DataFrame(np.random.randn(5,4) - 1)
print (df)

print (np.abs(df))
</code></pre>
<pre><code>          0         1         2         3
0  0.624016 -2.695175 -1.211426 -0.386151
1 -1.335385 -1.315232 -0.305902 -0.361348
2 -0.349443 -2.032110  0.075995 -0.966725
3 -1.631192 -1.051390 -1.767981 -0.366663
4 -0.786178 -0.335846 -0.797992 -0.931216
          0         1         2         3
0  0.624016  2.695175  1.211426  0.386151
1  1.335385  1.315232  0.305902  0.361348
2  0.349443  2.032110  0.075995  0.966725
3  1.631192  1.051390  1.767981  0.366663
4  0.786178  0.335846  0.797992  0.931216
</code></pre><pre><code class="python"># 使用apply应用行或列数据
f = lambda x : x.max()
print (df.apply(f))
</code></pre>
<pre><code>0    0.624016
1   -0.335846
2    0.075995
3   -0.361348
dtype: float64
</code></pre><pre><code class="python"># 指定轴方向
print (df.apply(f, axis=1))
</code></pre>
<pre><code>0    0.624016
1   -0.305902
2    0.075995
3   -0.366663
4   -0.335846
dtype: float64
</code></pre><pre><code class="python"># 使用applymap应用到每个数据
f2 = lambda x : &#39;%.2f&#39; % x
print (df.applymap(f2))
</code></pre>
<pre><code>       0      1      2      3
0   0.62  -2.70  -1.21  -0.39
1  -1.34  -1.32  -0.31  -0.36
2  -0.35  -2.03   0.08  -0.97
3  -1.63  -1.05  -1.77  -0.37
4  -0.79  -0.34  -0.80  -0.93
</code></pre><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><pre><code class="python">s4 = pd.Series(range(10, 15), index = np.random.randint(5, size=5))
print (s4)
</code></pre>
<pre><code>4    10
1    11
4    12
1    13
1    14
dtype: int64
</code></pre><blockquote>
<ol>
<li>索引排序</li>
</ol>
</blockquote>
<pre><code class="python">
s4.sort_index()
</code></pre>
<pre><code>1    11
1    13
1    14
4    10
4    12
dtype: int64
</code></pre><pre><code class="python">df4 = pd.DataFrame(np.random.randn(3, 4),
                   index=np.random.randint(3, size=3),
                   columns=np.random.randint(4, size=4))
</code></pre>
<pre><code class="python">df4
</code></pre>
<table>
<thead>
<tr>
<th></th>
<th>2</th>
<th>1</th>
<th>3</th>
<th>1</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0.007031</td>
<td>1.261990</td>
<td>-1.647929</td>
<td>0.176549</td>
</tr>
<tr>
<td>1</td>
<td>-2.510698</td>
<td>-0.207659</td>
<td>0.628221</td>
<td>0.441352</td>
</tr>
<tr>
<td>0</td>
<td>-0.367051</td>
<td>1.536606</td>
<td>0.167158</td>
<td>-0.236129</td>
</tr>
</tbody>
</table>
<pre><code class="python">#df4.sort_index(ascending=False)
df4.sort_index(axis=1)
</code></pre>
<table>
<thead>
<tr>
<th></th>
<th>1</th>
<th>1</th>
<th>2</th>
<th>3</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>1.261990</td>
<td>0.176549</td>
<td>0.007031</td>
<td>-1.647929</td>
</tr>
<tr>
<td>1</td>
<td>-0.207659</td>
<td>0.441352</td>
<td>-2.510698</td>
<td>0.628221</td>
</tr>
<tr>
<td>0</td>
<td>1.536606</td>
<td>-0.236129</td>
<td>-0.367051</td>
<td>0.167158</td>
</tr>
</tbody>
</table>
<blockquote>
<ol start="2">
<li>按值排序</li>
</ol>
</blockquote>
<pre><code class="python">
#df.sortvalues(by=&#39;a&#39;, ascending=False) === 通过a的值
#    作用是对选定的一列数值（&#39;a&#39;）数据从上往下从小到大进行排序（如果传值没成功===设置本体覆盖，传值覆盖）
df4.sort_values(by=1)
</code></pre>
<pre><code>---------------------------------------------------------------------------

ValueError                                Traceback (most recent call last)

&lt;ipython-input-22-36ffa8ddd07d&gt; in &lt;module&gt;
      2 #df.sortvalues(by=&#39;a&#39;, ascending=False) === 通过a的值
      3 #    作用是对选定的一列数值（&#39;a&#39;）数据从上往下从小到大进行排序（如果传值没成功===设置本体覆盖，传值覆盖）
----&gt; 4 df4.sort_values(by=1)


~\Anaconda3\lib\site-packages\pandas\core\frame.py in sort_values(self, by, axis, ascending, inplace, kind, na_position)
   4991
   4992             by = by[0]
-&gt; 4993             k = self._get_label_or_level_values(by, axis=axis)
   4994
   4995             if isinstance(ascending, (tuple, list)):


~\Anaconda3\lib\site-packages\pandas\core\generic.py in _get_label_or_level_values(self, key, axis)
   1795                     key=key,
   1796                     label_axis_name=label_axis_name,
-&gt; 1797                     multi_message=multi_message,
   1798                 )
   1799             )


ValueError: The column label &#39;1&#39; is not unique.
</code></pre>]]></content>
      <categories>
        <category>DataAnalysis</category>
      </categories>
  </entry>
  <entry>
    <title>Numpy库使用总结</title>
    <url>/blog/mk2z96/</url>
    <content><![CDATA[<h2 id="一、NumPy"><a href="#一、NumPy" class="headerlink" title="一、NumPy"></a>一、NumPy</h2><h3 id="ndarray-理解多维数组"><a href="#ndarray-理解多维数组" class="headerlink" title="ndarray 理解多维数组"></a>ndarray 理解多维数组</h3><pre><code class="python">import numpy as np

# 生成指定维度的随机多维数据
#数学建模应该用不到
data = np.random.rand(2, 3)
print (data)
print (type(data))
#type是显示数据类型；shape显示维度；ndim维度个数;type另外的作用
</code></pre>
<pre><code>[[0.46686682 0.68844304 0.76663872]
 [0.70747721 0.47887587 0.25943412]]
&lt;class &#39;numpy.ndarray&#39;&gt;
</code></pre><blockquote>
<p>ndim, shape 和 dtype 属性</p>
</blockquote>
<pre><code class="python">print (&#39;维度个数&#39;, data.ndim)
print (&#39;各维度大小: &#39;, data.shape)
print (&#39;数据类型: &#39;, data.dtype)
</code></pre>
<pre><code>维度个数 2
各维度大小:  (2, 3)
数据类型:  float64
</code></pre><h3 id="创建-ndarray"><a href="#创建-ndarray" class="headerlink" title="创建 ndarray"></a>创建 ndarray</h3><pre><code class="python">&#39;&#39;&#39;1. array创建&#39;&#39;&#39;
# list转换为 ndarray
l = range(10)
data = np.array(l)
print (data)
print (data.shape)
print (data.ndim)
</code></pre>
<pre><code>[0 1 2 3 4 5 6 7 8 9]
(10,)
1
</code></pre><pre><code class="python"># 嵌套序列转换为ndarray
l2 = [range(10), range(10)]
#就这样形成了一个数组
data = np.array(l2)
print (data)
print (data.shape)
</code></pre>
<pre><code>[[0 1 2 3 4 5 6 7 8 9]
 [0 1 2 3 4 5 6 7 8 9]]
(2, 10)
</code></pre><pre><code class="python">&#39;&#39;&#39;2. zeros;ones;empty创建&#39;&#39;&#39;

# np.zeros
zeros_arr = np.zeros((3, 4))
#注意元组，这里经常报错
# np.ones
ones_arr = np.ones((2, 3))

# np.empty[不全为零，而且是随机的一些数字]
empty_arr = np.empty((3, 3))

# np.empty 指定数据类型
empty_int_arr = np.empty((3, 3), int)

print (zeros_arr)
print (&#39;-------------&#39;)
print (ones_arr)
print (&#39;-------------&#39;)
print (empty_arr)
print (&#39;-------------&#39;)
print (empty_int_arr)
</code></pre>
<pre><code>[[0. 0. 0. 0.]
 [0. 0. 0. 0.]
 [0. 0. 0. 0.]]
-------------
[[1. 1. 1.]
 [1. 1. 1.]]
-------------
[[0.000e+000 0.000e+000 0.000e+000]
 [0.000e+000 0.000e+000 2.174e-321]
 [0.000e+000 0.000e+000 0.000e+000]]
-------------
[[0 0 0]
 [0 0 0]
 [0 0 0]]
</code></pre><pre><code class="python"># np.arange()
#创建一系列连续的数算是numpy里面类似python里面range的功能
print (np.arange(10))
</code></pre>
<pre><code>[0 1 2 3 4 5 6 7 8 9]
</code></pre><h2 id="二、操作-nddarray"><a href="#二、操作-nddarray" class="headerlink" title="二、操作 nddarray"></a>二、操作 nddarray</h2><h3 id="矢量化-vectorization"><a href="#矢量化-vectorization" class="headerlink" title="矢量化 (vectorization)"></a>矢量化 (vectorization)</h3><pre><code class="python"># 矢量与矢量运算
arr = np.array([[1, 2, 3],
                [4, 5, 6]])

print (&quot;元素之间相乘：&quot;)
#注意区分矩阵之间的运算。这里的矢量原酸相当于是广播式的运算
print (arr * arr)

print (&quot;矩阵相加：&quot;)
print (arr + arr)
</code></pre>
<pre><code>元素之间相乘：
[[ 1  4  9]
 [16 25 36]]
矩阵相加：
[[ 2  4  6]
 [ 8 10 12]]
</code></pre><pre><code class="python"># 矢量与标量运算
print (1. / arr)
print (2. * arr)
</code></pre>
<pre><code>[[1.         0.5        0.33333333]
 [0.25       0.2        0.16666667]]
[[ 2.  4.  6.]
 [ 8. 10. 12.]]
</code></pre><h3 id="索引与切片"><a href="#索引与切片" class="headerlink" title="索引与切片"></a>索引与切片</h3><pre><code class="python"># 一维数组
arr1 = np.arange(10)
print (arr1)

print (arr1[2:5])
</code></pre>
<pre><code>[0 1 2 3 4 5 6 7 8 9]
[2 3 4]
</code></pre><pre><code class="python"># 多维数组
arr2 = np.arange(12).reshape(3,4)
#要学会定义多维数组，arange是形成12个随机数，之后的reshape是形成维数
#多维数组的空间含义就是比如：3.4.5=长4宽5高3
#还有点数就是应用函数
print (arr2)
</code></pre>
<pre><code>[[ 0  1  2  3]
 [ 4  5  6  7]
 [ 8  9 10 11]]
</code></pre><pre><code class="python">print (arr2[1])

print (arr2[0:2, 2:])

print (arr2[:, 1:3])
</code></pre>
<pre><code>[4 5 6 7]
[[2 3]
 [6 7]]
[[ 1  2]
 [ 5  6]
 [ 9 10]]
</code></pre><pre><code class="python"># 条件索引

# 找出 data_arr 中 2015年后的数据
data_arr = np.random.rand(3,3)
print (data_arr)

year_arr = np.array([[2000, 2001, 2000],
                     [2005, 2002, 2009],
                     [2001, 2003, 2010]])

is_year_after_2005 = year_arr &gt;= 2005
#:他会扩展成同类型的数组
print (is_year_after_2005, is_year_after_2005.dtype)

filtered_arr = data_arr[is_year_after_2005]

filtered_arr = data_arr[year_arr &gt;= 2005]
print (filtered_arr)
#中间的一些语句可以删除
#最后生成得是一维数组，进行数据过滤的时候很有用
</code></pre>
<pre><code>[[0.61482194 0.0249229  0.28525661]
 [0.05121173 0.37672803 0.86259463]
 [0.22648329 0.4581513  0.18620441]]
[[False False False]
 [ True False  True]
 [False False  True]] bool
[0.05121173 0.86259463 0.18620441]
</code></pre><pre><code class="python"># 多个条件&amp; |
filtered_arr = data_arr[(year_arr &lt;= 2005) &amp; (year_arr % 2 == 0)]
print (filtered_arr)
</code></pre>
<pre><code>[0.61482194 0.28525661 0.37672803]
</code></pre><h3 id="转置-transpose"><a href="#转置-transpose" class="headerlink" title="转置 === transpose"></a>转置 === transpose</h3><pre><code class="python">arr = np.random.rand(2,3)
print (arr)
print (arr.transpose())
</code></pre>
<pre><code>[[0.01538974 0.47573964 0.90684253]
 [0.93683601 0.64306611 0.63846634]]
[[0.01538974 0.93683601]
 [0.47573964 0.64306611]
 [0.90684253 0.63846634]]
</code></pre><pre><code class="python">#高维数组的转换(图像里面会用得到转换维度)

arr3d = np.random.rand(2,3,4)
print (arr3d)
print (&#39;----------------------&#39;)
print (arr3d.transpose((1,0,2))) # 多维数组的转置和定义不会
</code></pre>
<pre><code>[[[0.18074837 0.64652003 0.80527972 0.67800268]
  [0.95766577 0.2498768  0.00304503 0.7058178 ]
  [0.12523549 0.18796252 0.72463798 0.15352211]]

 [[0.38808013 0.31075033 0.53082474 0.32254431]
  [0.6861262  0.02999367 0.70980993 0.09099878]
  [0.14987301 0.78237398 0.90159408 0.82897071]]]
----------------------
[[[0.18074837 0.64652003 0.80527972 0.67800268]
  [0.38808013 0.31075033 0.53082474 0.32254431]]

 [[0.95766577 0.2498768  0.00304503 0.7058178 ]
  [0.6861262  0.02999367 0.70980993 0.09099878]]

 [[0.12523549 0.18796252 0.72463798 0.15352211]
  [0.14987301 0.78237398 0.90159408 0.82897071]]]
</code></pre><h3 id="ndarray-数据类型转化-astype"><a href="#ndarray-数据类型转化-astype" class="headerlink" title="ndarray 数据类型转化 === astype"></a>ndarray 数据类型转化 === astype</h3><pre><code class="python">zeros_float_arr = np.zeros((3, 4), dtype=np.float64)
print (zeros_float_arr)
print (zeros_float_arr.dtype)

# astype转换数据类型
zeros_int_arr = zeros_float_arr.astype(np.int32)
print (zeros_int_arr)
print (zeros_int_arr.dtype)
</code></pre>
<pre><code>[[0. 0. 0. 0.]
 [0. 0. 0. 0.]
 [0. 0. 0. 0.]]
float64
[[0 0 0 0]
 [0 0 0 0]
 [0 0 0 0]]
int32
</code></pre><h3 id="文本文件的读取"><a href="#文本文件的读取" class="headerlink" title="文本文件的读取"></a>文本文件的读取</h3><pre><code class="python"># loadtxt
filename = &#39;./presidential_polls.csv&#39;
data_array = np.loadtxt(filename,      # 文件名
                        delimiter=&#39;,&#39;, # 指定里面的元素分隔符
                        dtype=str,     # 指定数据类型
                        usecols=(0,2,3)) # 指定读取的列索引号
print (data_array, data_array.shape)
</code></pre>
<pre><code>[[&#39;cycle&#39; &#39;type&#39; &#39;matchup&#39;]
 [&#39;2016&#39; &#39;&quot;polls-plus&quot;&#39; &#39;&quot;Clinton vs. Trump vs. Johnson&quot;&#39;]
 [&#39;2016&#39; &#39;&quot;polls-plus&quot;&#39; &#39;&quot;Clinton vs. Trump vs. Johnson&quot;&#39;]
 ...
 [&#39;2016&#39; &#39;&quot;polls-only&quot;&#39; &#39;&quot;Clinton vs. Trump vs. Johnson&quot;&#39;]
 [&#39;2016&#39; &#39;&quot;polls-only&quot;&#39; &#39;&quot;Clinton vs. Trump vs. Johnson&quot;&#39;]
 [&#39;2016&#39; &#39;&quot;polls-only&quot;&#39; &#39;&quot;Clinton vs. Trump vs. Johnson&quot;&#39;]] (10237, 3)
</code></pre><pre><code class="python"># loadtxt, 明确指定每列数据的类型
filename = &#39;./presidential_polls.csv&#39;
data_array = np.loadtxt(filename,      # 文件名
                        delimiter=&#39;,&#39;, # 分隔符
                        skiprows=1,
                        dtype={&#39;names&#39;:(&#39;cycle&#39;, &#39;type&#39;, &#39;matchup&#39;),
                               &#39;formats&#39;:(&#39;i4&#39;, &#39;S15&#39;, &#39;S50&#39;)},     # 数据类型
                        usecols=(0,2,3)) # 指定读取的列索引号

print (data_array, data_array.shape) # 读取的结果是一维的数组，每个元素是一个元组
</code></pre>
<pre><code>[(2016, b&#39;&quot;polls-plus&quot;&#39;, b&#39;&quot;Clinton vs. Trump vs. Johnson&quot;&#39;)
 (2016, b&#39;&quot;polls-plus&quot;&#39;, b&#39;&quot;Clinton vs. Trump vs. Johnson&quot;&#39;)
 (2016, b&#39;&quot;polls-plus&quot;&#39;, b&#39;&quot;Clinton vs. Trump vs. Johnson&quot;&#39;) ...
 (2016, b&#39;&quot;polls-only&quot;&#39;, b&#39;&quot;Clinton vs. Trump vs. Johnson&quot;&#39;)
 (2016, b&#39;&quot;polls-only&quot;&#39;, b&#39;&quot;Clinton vs. Trump vs. Johnson&quot;&#39;)
 (2016, b&#39;&quot;polls-only&quot;&#39;, b&#39;&quot;Clinton vs. Trump vs. Johnson&quot;&#39;)] (10236,)
</code></pre><h2 id="三、np-的常用函数"><a href="#三、np-的常用函数" class="headerlink" title="三、np 的常用函数"></a>三、np 的常用函数</h2><h3 id="转置-transpose-1"><a href="#转置-transpose-1" class="headerlink" title="转置 transpose"></a>转置 transpose</h3><pre><code class="python">import numpy as np
</code></pre>
<pre><code class="python">arr = np.random.rand(2,3)
print (arr)
print (arr.transpose())
</code></pre>
<pre><code>[[0.78485041 0.88817969 0.34809014]
 [0.32744286 0.97539301 0.94401872]]
[[0.78485041 0.32744286]
 [0.88817969 0.97539301]
 [0.34809014 0.94401872]]
</code></pre><pre><code class="python">#高维数组的转换(图像里面会用得到转换维度)
#不懂这里！！！
arr3d = np.random.rand(2,3,4)
print (arr3d)
print (&#39;----------------------&#39;)
print (arr3d.transpose((1,0,2))) # 多维数组的转置和定义不会
</code></pre>
<pre><code>[[[0.28492549 0.60197236 0.45582367 0.21992479]
  [0.1747163  0.69201365 0.85460359 0.65311699]
  [0.62189644 0.25217555 0.16347156 0.29831219]]

 [[0.42826733 0.81396165 0.187138   0.560564  ]
  [0.10162186 0.66419751 0.03261665 0.06969256]
  [0.55461652 0.55020586 0.50693591 0.31741807]]]
----------------------
[[[0.28492549 0.60197236 0.45582367 0.21992479]
  [0.42826733 0.81396165 0.187138   0.560564  ]]

 [[0.1747163  0.69201365 0.85460359 0.65311699]
  [0.10162186 0.66419751 0.03261665 0.06969256]]

 [[0.62189644 0.25217555 0.16347156 0.29831219]
  [0.55461652 0.55020586 0.50693591 0.31741807]]]
</code></pre><h3 id="ceil-和-floor-和-rint-和-isnan"><a href="#ceil-和-floor-和-rint-和-isnan" class="headerlink" title="ceil 和 floor 和 rint 和 isnan"></a>ceil 和 floor 和 rint 和 isnan</h3><pre><code class="python">arr = np.random.randn(2,3)

print (arr)
print (np.ceil(arr))
#向上最接近的整数
print (np.floor(arr))
#向下最接近的整数
print (np.rint(arr))
#四舍五入
print (np.isnan(arr))
#判断元素是否为NaN
#笔记上还有其他的函数
</code></pre>
<pre><code>[[ 0.262106   -1.33680008 -1.08562543]
 [ 0.3990978   0.1410074   0.64278274]]
[[ 1. -1. -1.]
 [ 1.  1.  1.]]
[[ 0. -2. -2.]
 [ 0.  0.  0.]]
[[ 0. -1. -1.]
 [ 0.  0.  1.]]
[[False False False]
 [False False False]]
</code></pre><h3 id="where"><a href="#where" class="headerlink" title="where"></a>where</h3><pre><code class="python">arr = np.random.randn(3,4)
print (arr)

np.where(arr &gt; 0, 1, -1)
#（条件，满足输出，不满足输出）
</code></pre>
<pre><code>[[ 2.04688394  0.48063737  1.20876913 -0.93412937]
 [-0.43427472 -1.47755481  0.36882256 -0.08943138]
 [-0.2847686   0.96915893  0.32641235  0.28346922]]





array([[ 1,  1,  1, -1],
       [-1, -1,  1, -1],
       [-1,  1,  1,  1]])
</code></pre><h3 id="sum"><a href="#sum" class="headerlink" title="sum"></a>sum</h3><pre><code class="python">arr = np.arange(10).reshape(5,2)
print (arr)

print (np.sum(arr))
print (np.sum(arr, axis=0))
print (np.sum(arr, axis=1))
</code></pre>
<pre><code>[[0 1]
 [2 3]
 [4 5]
 [6 7]
 [8 9]]
45
[20 25]
[ 1  5  9 13 17]
</code></pre><h3 id="all-和-any"><a href="#all-和-any" class="headerlink" title="all 和 any"></a>all 和 any</h3><pre><code class="python">import numpy as np
arr = np.random.randn(2,3)
print (arr)

print (np.any(arr &gt; 0))
#有一个就对
print (np.all(arr &gt; 0))
#全部对才对
&#39;&#39;&#39;
·用处就是判断一组数据当中，是否===有点类似布尔类型的
·这个也可以应用在pandas中的DataFrame中
&#39;&#39;&#39;
</code></pre>
<pre><code>[[-1.020184   -0.48466272 -0.8496271 ]
 [ 0.88815825 -0.81911857  0.64570539]]
True
False





&#39;\n·用处就是判断一组数据当中，是否===有点类似布尔类型的\n·这个也可以应用在pandas中的DataFrame中\n&#39;
</code></pre><h3 id="unique"><a href="#unique" class="headerlink" title="unique"></a>unique</h3><pre><code class="python">arr = np.array([[1, 2, 1], [2, 3, 4]])
print (arr)
print (np.unique(arr))
</code></pre>
<pre><code>[[1 2 1]
 [2 3 4]]
[1 2 3 4]
</code></pre>]]></content>
      <categories>
        <category>DataAnalysis</category>
      </categories>
  </entry>
  <entry>
    <title>Anaconda+JetBrains系列软件使用总结</title>
    <url>/blog/mv7tir/</url>
    <content><![CDATA[<h2 id="一、Anaconda-和-Pycharm-下载与配置"><a href="#一、Anaconda-和-Pycharm-下载与配置" class="headerlink" title="一、Anaconda 和 Pycharm 下载与配置"></a>一、Anaconda 和 Pycharm 下载与配置</h2><h3 id="下载-Anaconda-且配置"><a href="#下载-Anaconda-且配置" class="headerlink" title="下载 Anaconda 且配置"></a>下载 Anaconda 且配置</h3><ul>
<li>（更新）下载了 anaconda 就不要单独下载 python，之前下的也删掉，以此避免路径冲突</li>
<li>方式一：<strong>迅雷下载</strong>（推荐）；方式二：提取链接<strong>网盘下载</strong>；方式三：清华镜像下载，下载完安装【直接 next 即可】</li>
<li><strong>测试</strong>：<code>win + R</code> 进入终端输入<code>conda</code>出现 conda 命令使用指南，即证明成功安装</li>
<li><strong>配置环境变量</strong>：在<strong>系统变量</strong>path 路径中加入下面配置（具体路径具体填写）</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1606634508207-8eb4dda2-6dbe-4162-b7eb-93cc5b35dc0e.png#align=left&amp;display=inline&amp;height=107&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=169&amp;originWidth=467&amp;size=7789&amp;status=done&amp;style=shadow&amp;width=296" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1606634439956-bfa830a0-ece9-4caa-9bf7-641b14dafd70.png#align=left&amp;display=inline&amp;height=41&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=81&amp;originWidth=645&amp;size=5266&amp;status=done&amp;style=shadow&amp;width=322.5" alt="image.png"></p>
<h3 id="下载-Pycharm-且配置"><a href="#下载-Pycharm-且配置" class="headerlink" title="下载 Pycharm 且配置"></a>下载 Pycharm 且配置</h3><ul>
<li><p><strong>下载版本</strong><a href="https://www.jetbrains.com/pycharm/download/" target="_blank" rel="noopener">社区/专业</a>：专业版本需要激活码，社区版本功能基本能应付日常使用</p>
<blockquote>
<p>（大学学生时期可以用学生邮箱申请使用 JetBrains 系列软件，我的方法是先认证 GitHub 学生认证，然后直接从 GitHub 那边认证 JetBrains 软件的使用权，当然也可以直接用学生邮箱去 JetBrains 官网认证）</p>
</blockquote>
</li>
<li><p><strong>❗ 补充：取消上面用学生邮箱去申请 JetBrains 系列软件使用方法。先去 GitHub 申请学生包，然后通过 GitHub 已认证的 GitHub 账号再去申请 JetBrains 系列软件较为方便 <a href="https://www.jetbrains.com/zh-cn/community/education/?_ga=2.186354217.1063699871.1594345232-1379189663.1590592761#students" target="_blank" rel="noopener">JetBrains 申请链接 🔗</a></strong></p>
</li>
<li>Pycharm 使用 Anaconda 的配置 （ <strong>❗ 补充：下面貌似是社区版本的添加方式，但是专业版本会自动识别</strong> ）：</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685306285-e6ca8228-9234-4c7f-97f3-9d7fc26e0728.png#align=left&amp;display=inline&amp;height=266&amp;margin=%5Bobject%20Object%5D&amp;originHeight=1077&amp;originWidth=1843&amp;size=0&amp;status=done&amp;style=shadow&amp;width=456" alt></p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685306347-9a79eaf2-93cf-4ed4-b008-9e49aa66ad7e.png#align=left&amp;display=inline&amp;height=324&amp;margin=%5Bobject%20Object%5D&amp;originHeight=885&amp;originWidth=1227&amp;size=0&amp;status=done&amp;style=shadow&amp;width=449" alt></p>
<h2 id="二、Anaconda-环境管理"><a href="#二、Anaconda-环境管理" class="headerlink" title="二、Anaconda 环境管理"></a>二、Anaconda 环境管理</h2><h3 id="pip-conda-Miniconda-Anaconda"><a href="#pip-conda-Miniconda-Anaconda" class="headerlink" title="pip,conda,Miniconda,Anaconda"></a>pip,conda,Miniconda,Anaconda</h3><ul>
<li>pip 包管理工具，python 官方认证</li>
<li>conda 是一种通用包管理系统，旨在构建和管理任何语言和任何类型的软件。包管理与 pip 的使用类似，环境管理则允许用户方便地安装不同版本的 python 并可以快速切换。</li>
<li>Anaconda 则是一个打包的集合，里面预装好了 conda、某个版本的 python、众多 packages、科学计算工具等等，就是把很多常用的不常用的库都给你装好了。同时利用配置/工具/命令 conda 来进行 package 和<strong>environment</strong>的管理。</li>
<li>Miniconda，它只包含最基本的内容——python 与 conda，以及相关的必须依赖项，对于空间要求严格的用户，Miniconda 是一种选择。就只包含最基本的东西，其他的库得自己装。</li>
</ul>
<blockquote>
<p>pip 下载/管理经常 bug，用 conda 结合 anaconda/miniconda 方便使用</p>
</blockquote>
<h3 id="Python-相关包路径的查看"><a href="#Python-相关包路径的查看" class="headerlink" title="Python 相关包路径的查看"></a>Python 相关包路径的查看</h3><ul>
<li><code>win+R</code>   输入<code>cmd</code>   输入<code>python</code> 输入<code>import sys</code> 输入<code>sys.path</code></li>
<li>标准库：anaconda 文件夹下的 lib 文件夹</li>
<li>第三方库：下述代码中的文件夹 <code>C:\Users\wztli\Anaconda3\Lib\site-packages</code></li>
</ul>
<h3 id="Sklearn-包安装失败总结"><a href="#Sklearn-包安装失败总结" class="headerlink" title="Sklearn 包安装失败总结"></a>Sklearn 包安装失败总结</h3><p>安装 scikit-learn 包，导入 sklearn 的 Bug</p>
<pre><code class="powershell">ImportError: DLL load failed: 找不到指定的模块
</code></pre>
<p><code>scikit-learn</code>的下载会对 numpy、scipy、joblib 三个库相应版本有所要求，总之如果用 anaconda 的话，全部更新为最新即可（<a href="https://www.lfd.uci.edu/~gohlke/pythonlibs/" target="_blank" rel="noopener">参考 whl 版本</a>）</p>
<blockquote>
<ul>
<li><code>C:\Users\wztli\Anaconda3\pkgs\scikit-learn-0.21.3-py37h6288b17_0\Lib\site-packages\sklearn\datasets\data</code></li>
<li>数据集在电脑中的位置</li>
</ul>
</blockquote>
<h3 id="Scrapy-包安装失败总结"><a href="#Scrapy-包安装失败总结" class="headerlink" title="Scrapy 包安装失败总结"></a>Scrapy 包安装失败总结</h3><ul>
<li>pip 下载可能会失败</li>
<li>使用 conda（镜像）下载<code>conda install -c scrapinghub scrapy</code></li>
</ul>
<h2 id="三、JetBrains-系列软件的高效使用"><a href="#三、JetBrains-系列软件的高效使用" class="headerlink" title="三、JetBrains 系列软件的高效使用"></a>三、JetBrains 系列软件的高效使用</h2><h3 id="JetBrains-之初始配置"><a href="#JetBrains-之初始配置" class="headerlink" title="JetBrains 之初始配置"></a>JetBrains 之初始配置</h3><blockquote>
<p>界面字体大小、代码字体大小、主题默认（dark）、背景图片（看心情）</p>
</blockquote>
<ul>
<li>字体相关<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685306645-d747b801-f817-475d-93e7-a9357a6f810b.png#align=left&amp;display=inline&amp;height=284&amp;margin=%5Bobject%20Object%5D&amp;originHeight=886&amp;originWidth=1227&amp;size=0&amp;status=done&amp;style=none&amp;width=393" alt></li>
<li>主题相关<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685306383-6425ce01-32e1-4216-b62e-def25d1e9dc7.png#align=left&amp;display=inline&amp;height=287&amp;margin=%5Bobject%20Object%5D&amp;originHeight=886&amp;originWidth=1227&amp;size=0&amp;status=done&amp;style=none&amp;width=398" alt></li>
</ul>
<h3 id="JetBrains-之-Debug-断点调试"><a href="#JetBrains-之-Debug-断点调试" class="headerlink" title="JetBrains 之 Debug 断点调试"></a>JetBrains 之 Debug 断点调试</h3><blockquote>
<p>断点调试是优于打印输出的一种调试程序的一种手段（Pycharm 编辑器，其他系列软件也一样）</p>
</blockquote>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685306462-78e560c3-6150-4b08-b806-34919a36f0a2.png#align=left&amp;display=inline&amp;height=283&amp;margin=%5Bobject%20Object%5D&amp;originHeight=397&amp;originWidth=769&amp;size=0&amp;status=done&amp;style=shadow&amp;width=548" alt></p>
<blockquote>
<ul>
<li>Ctrl+F5（左上角）：（return “project”）重新 debug 该文件</li>
<li>F9：（resume program）一个断点接着一个断点走，不按行走（eg：有循环会随着 i 一步一步走完）</li>
<li>F8：（step over） 一行一行走代码</li>
<li>F7：（step into） 进入函数内部</li>
<li>Alt+shift+F7：（step into mycode）遇到自己函数   进去</li>
<li>shift+F8：（step out）跳出，进入函数后，跳出来</li>
<li>Alt+F10：（show execution point）指针显示当前断点旁边</li>
<li><strong>Show Python Prompt</strong>按键<br>交互式调试命令</li>
</ul>
</blockquote>
<h3 id="JetBrains-之-GitHub-使用"><a href="#JetBrains-之-GitHub-使用" class="headerlink" title="JetBrains 之 GitHub 使用"></a>JetBrains 之 GitHub 使用</h3><ol>
<li>配置 Git 和 GitHub（先连接本地 git，然后登录 GitHub）<br>页面   依次点击<code>File</code> <code>Setting</code> <code>Version Control</code> <code>GitHub</code>然后登录账户进行配置</li>
<li>将项目新建在 GitHub<br>菜单栏 依次点击 <code>VCS</code> <code>Import into Version Control</code> <code>Share Project on GitHub</code></li>
<li><strong>将项目克隆在本地</strong> <code>VCS</code> <code>Get from Version Control</code></li>
</ol>
<h3 id="JetBrains-之-TODO-使用"><a href="#JetBrains-之-TODO-使用" class="headerlink" title="JetBrains 之 TODO 使用"></a>JetBrains 之 TODO 使用</h3><p>便于编写大型代码，将注释加上前缀以便分类处理，以下图片展示<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685306509-efc968a4-bf76-44f3-8347-52cbb5a7cc73.png#align=left&amp;display=inline&amp;height=689&amp;margin=%5Bobject%20Object%5D&amp;originHeight=689&amp;originWidth=1890&amp;size=0&amp;status=done&amp;style=none&amp;width=1890" alt></p>
<p>参考：</p>
<ul>
<li><a href="https://www.jetbrains.com/help/pycharm/using-todo.html" target="_blank" rel="noopener">TODO 的使用官方文档</a></li>
<li><a href="https://blog.csdn.net/weixin_34277853/article/details/94205060?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-5&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-5" target="_blank" rel="noopener">TODO 的用法</a></li>
</ul>
<h3 id="JetBrains-之插件枚举"><a href="#JetBrains-之插件枚举" class="headerlink" title="JetBrains 之插件枚举"></a>JetBrains 之插件枚举</h3><ul>
<li>Waka Time：持续记录自己的 IDE 以及编程语言的使用时长</li>
<li>leetcode editor：leetcode 刷题插件</li>
</ul>
<h3 id="JetBrains-之初用警告"><a href="#JetBrains-之初用警告" class="headerlink" title="JetBrains 之初用警告"></a>JetBrains 之初用警告</h3><p>一般下载完开始使用，IDE 会报一个 <code>Windows安全中心</code> 的警告</p>
<pre><code>Windows Defender might be impacting your build performance. PyCharm checked the following directorie
</code></pre><p>解决：<img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685306961-bcb04392-e8c2-4f3a-a7f0-d2d1516afe70.png#align=left&amp;display=inline&amp;height=700&amp;margin=%5Bobject%20Object%5D&amp;originHeight=700&amp;originWidth=1184&amp;size=0&amp;status=done&amp;style=none&amp;width=1184" alt><br>然后再进入排除项添加报错的文件夹即可</p>
<h3 id="JetBrains-之-IDEA-的-leetcode-插件"><a href="#JetBrains-之-IDEA-的-leetcode-插件" class="headerlink" title="JetBrains 之 IDEA 的 leetcode 插件"></a>JetBrains 之 IDEA 的 leetcode 插件</h3><blockquote>
<p>记录一些配置</p>
</blockquote>
<ul>
<li>勾选 Custom Template 和 Plugin Update</li>
<li>TempFilePath</li>
</ul>
<pre><code>D:\project-java\datastructure\src\com\wztlink1013\problems
</code></pre><ul>
<li>CodeFileName</li>
</ul>
<pre><code>P${question.frontendQuestionId}$!velocityTool.camelCaseName(${question.titleSlug})
</code></pre><ul>
<li>CodeTemplate</li>
</ul>
<pre><code>package com.wztlink1013.problems.leetcode.editor.cn;

${question.content}
public class P${question.frontendQuestionId}$!velocityTool.camelCaseName(${question.titleSlug}){
    public static void main(String[] args) {
        Solution solution = new P${question.frontendQuestionId}$!velocityTool.camelCaseName(${question.titleSlug})().new Solution();

    }

${question.code}
}
</code></pre><p>参考：<br><a href="https://blog.csdn.net/yxf19034516/article/details/106087994/" target="_blank" rel="noopener">IDEA 的 LeetCode 力扣插件设置与使用</a><br><a href="https://hacpai.com/article/1575547715310" target="_blank" rel="noopener">IDEA 的 LeetCode 刷题插件 leetcode editor</a></p>
]]></content>
      <categories>
        <category>Environment</category>
      </categories>
  </entry>
  <entry>
    <title>链表JAVA设计</title>
    <url>/blog/nkn2os/</url>
    <content><![CDATA[<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p>链表是一种数据结构，和<strong>数组同级</strong>。之前的 ArrayList 数据结构，其实现原理是数组，而 LinkedList 的实现原理就是链表了。链表在进行循环遍历时效率不高，但是插入和删除时优势明显。<br>单向链表是一种线性表，实际上是由<strong>节点（Node）</strong>组成的，一个链表拥有不定数量的节点。其数据在<strong>内存中存储是不连续的</strong>，它存储的数据分散在内存中，每个结点只能也只有它能知道下一个结点的存储位置。由 N 各节点（Node）组成单向链表，每一个 Node 记录本 Node 的数据及下一个 Node。向外暴露的只有一个头节点（Head），<strong>我们对链表的所有操作，都是直接或者间接地通过其头节点来进行的。</strong><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1603194076184-195f3044-1083-4244-9eeb-d86c96a37e6f.png#align=left&amp;display=inline&amp;height=98&amp;margin=%5Bobject%20Object%5D&amp;originHeight=98&amp;originWidth=491&amp;size=0&amp;status=done&amp;style=shadow&amp;width=491" alt><br>上图中最左边的节点即为头结点（Head），但是添加节点的顺序是从右向左的，添加的新节点会被作为新节点。最先添加的节点对下一节点的引用可以为空。引用是引用下一个节点而非下一个节点的对象。因为有着不断的引用，所以<strong>头节点就可以操作所有节点</strong>了。<br>下图描述了单向链表存储情况。存储是分散的，每一个节点只要记录下一节点，就把所有数据串了起来，形成了一个单向链表。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1603194105521-d31f8e78-7f2a-4c60-8838-57e15707e27b.png#align=left&amp;display=inline&amp;height=219&amp;margin=%5Bobject%20Object%5D&amp;originHeight=219&amp;originWidth=195&amp;size=0&amp;status=done&amp;style=shadow&amp;width=195" alt><br>节点（Node）是由一个需要储存的对象及对下一个节点的引用组成的。也就是说，节点拥有两个成员：储存的对象、对下一个节点的引用。下面图是具体的说明：<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1603194124335-fc6fc00c-35fb-44e1-a01c-de4b8b5531af.png#align=left&amp;display=inline&amp;height=207&amp;margin=%5Bobject%20Object%5D&amp;originHeight=207&amp;originWidth=370&amp;size=0&amp;status=done&amp;style=shadow&amp;width=370" alt></p>
<h2 id="关于链表的指向"><a href="#关于链表的指向" class="headerlink" title="关于链表的指向"></a>关于链表的指向</h2><h3 id="何为指向？"><a href="#何为指向？" class="headerlink" title="何为指向？"></a>何为指向？</h3><p>链表的所有操作主要就是理解——<strong>“指向”</strong><br>每个节点的<strong>next</strong>用来存放<strong>下一个节点的“地址”</strong><br><strong>每个节点的自身就是地址</strong>，相当于 C 语言中数组的数组名就是本数组的地址</p>
<h3 id="谁指向谁？"><a href="#谁指向谁？" class="headerlink" title="谁指向谁？"></a>谁指向谁？</h3><p><strong>根处：目标</strong><br><strong>箭头处：地址仓库</strong></p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1599309003706-ad779a14-1678-4d0c-86f2-b147752bd252.png#align=left&amp;display=inline&amp;height=293&amp;margin=%5Bobject%20Object%5D&amp;originHeight=594&amp;originWidth=955&amp;size=0&amp;status=done&amp;style=shadow&amp;width=471" alt><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1599309003751-ffeee4d8-9662-416e-8f46-5cf5edf03114.png#align=left&amp;display=inline&amp;height=363&amp;margin=%5Bobject%20Object%5D&amp;originHeight=725&amp;originWidth=938&amp;size=0&amp;status=done&amp;style=shadow&amp;width=469" alt><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1599309003658-46b3e7db-e6dc-4d13-baea-e7e44075e8bc.png#align=left&amp;display=inline&amp;height=295&amp;margin=%5Bobject%20Object%5D&amp;originHeight=626&amp;originWidth=975&amp;size=0&amp;status=done&amp;style=shadow&amp;width=459" alt></p>
<h3 id="指向错位？"><a href="#指向错位？" class="headerlink" title="指向错位？"></a>指向错位？</h3><p><strong>第一个元素节点即为 head        </strong></p>
<h2 id="LinkedList-和-ArrayList-的设计"><a href="#LinkedList-和-ArrayList-的设计" class="headerlink" title="LinkedList 和 ArrayList 的设计"></a>LinkedList 和 ArrayList 的设计</h2><blockquote>
<p>同时设计 LinkedList 和 ArrayList</p>
</blockquote>
<p><strong>LinkedList</strong>不需要构造函数，<strong>ArrayList</strong>需要，后者需要一个容量的初始化。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1603191040309-0ed4b536-89c0-449d-85cc-e763afcb73ea.png#align=left&amp;display=inline&amp;height=300&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=600&amp;originWidth=557&amp;size=89515&amp;status=done&amp;style=shadow&amp;width=278.5" alt="image.png"></p>
<h3 id="接口-List-设计"><a href="#接口-List-设计" class="headerlink" title="接口 List 设计"></a>接口 List 设计</h3><blockquote>
<p>只用来<strong>声明对外接口</strong>，不能声明</p>
</blockquote>
<pre><code class="java">package com.wztlink1013.ds.linkedlist;

/**
 * fun：实现ArrayList和LinkedList的接口
 *
 */

public interface List&lt;E&gt; {
    static final int ELEMENT_NOT_FOUND = -1;

    /**
     * 元素的数量[抽象类中实现]
     * @return
     */
    int size();

    /**
     * 是否为空[抽象类中实现]
     * @return
     */
    boolean isEmpty();

    /**
     * 是否包含某个元素[抽象类中实现]
     * @param element
     * @return
     */
    boolean contains(E element);

    /**
     * 添加元素到尾部[抽象类中实现]
     * @param element
     */
    void add(E element);

    /**
     * 清除所有元素[实现类中实现]
     */
    void clear();

    /**
     * 获取index位置的元素[实现类中实现]
     * @param index
     * @return
     */
    E get(int index);

    /**
     * 设置index位置的元素[实现类中实现]
     * @param index
     * @param element
     * @return 原来的元素ֵ
     */
    E set(int index, E element);

    /**
     * 在index位置插入一个元素[实现类中实现]
     * @param index
     * @param element
     */
    void add(int index, E element);

    /**
     * 删除index位置的元素[实现类中实现]
     * @param index
     * @return
     */
    E remove(int index);

    /**
     * 查看元素的索引[实现类中实现]
     * @param element
     * @return
     */
    int indexOf(E element);
}

</code></pre>
<h3 id="抽象类-AbstractList-设计"><a href="#抽象类-AbstractList-设计" class="headerlink" title="抽象类 AbstractList 设计"></a>抽象类 AbstractList 设计</h3><blockquote>
<p>放 ArrayList 和 LinkedList 的公共代码</p>
<ul>
<li>实现 List 接口类的共同代码</li>
<li>ArrayList 和 LinkedList 都用得到但是不对外公开的代码</li>
</ul>
<p>声明抽象类 abstract，就意味着可以不用全部实现接口 List 里面的所有方法</p>
</blockquote>
<pre><code class="java">package com.wztlink1013.ds.linkedlist;

/**
 * fun：放ArrayList和LinkedList公共代码的抽象类（父类）
 *
 */

public abstract class AbstractList&lt;E&gt; implements List&lt;E&gt; {

    protected int size;
    /**
     * 元素的数量
     * @return
     */
    public int size() {
        return size;
    }

    /**
     * 是否为空
     * @return
     */
    public boolean isEmpty() {
        return size == 0;
    }

    /**
     * 是否包含某个元素
     * @param element
     * @return
     */
    public boolean contains(E element) {
        return indexOf(element) != ELEMENT_NOT_FOUND;
    }

    /**
     * 添加元素到尾部
     * @param element
     */
    public void add(E element) {
        add(size, element);
    }

    /**
     * 下面三个是ArrayList和LinkedList两个实现类中的公共代码
     * */
    protected void outOfBounds(int index) {
        throw new IndexOutOfBoundsException(&quot;Index:&quot; + index + &quot;, Size:&quot; + size);
    }

    protected void rangeCheck(int index) {
        if (index &lt; 0 || index &gt;= size) {
            outOfBounds(index);
        }
    }

    protected void rangeCheckForAdd(int index) {
        if (index &lt; 0 || index &gt; size) {
            outOfBounds(index);
        }
    }
}

</code></pre>
<h3 id="ArrayList-设计"><a href="#ArrayList-设计" class="headerlink" title="ArrayList 设计"></a>ArrayList 设计</h3><blockquote>
</blockquote>
<pre><code class="java">package com.wztlink1013.ds.linkedlist;

/**
 *fun：实现动态数组
 */
@SuppressWarnings(&quot;unchecked&quot;)
public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; {
    private E[] elements;

    private static final int DEFAULT_CAPACITY = 10;

    public ArrayList(int capaticy) {
        capaticy = (capaticy &lt; DEFAULT_CAPACITY) ? DEFAULT_CAPACITY : capaticy;
        elements = (E[]) new Object[capaticy];
    }

    public ArrayList() {
        this(DEFAULT_CAPACITY);
    }


    @Override
    public void clear() {
        for (int i = 0; i &lt; size; i++) {
            elements[i] = null;
        }
        size = 0;
    }

    @Override
    public E get(int index) {
        rangeCheck(index);
        return elements[index];
    }

    @Override
    public E set(int index, E element) {
        rangeCheck(index);

        E old = elements[index];
        elements[index] = element;
        return old;
    }

    @Override
    public void add(int index, E element) {
        rangeCheckForAdd(index);

        ensureCapacity(size + 1);

        for (int i = size; i &gt; index; i--) {
            elements[i] = elements[i - 1];
        }
        elements[index] = element;
        size++;
    }

    @Override
    public E remove(int index) {
        rangeCheck(index);

        E old = elements[index];
        for (int i = index + 1; i &lt; size; i++) {
            elements[i - 1] = elements[i];
        }
        elements[--size] = null;
        return old;
    }

    @Override
    public int indexOf(E element) {
        if (element == null) {  // 1
            for (int i = 0; i &lt; size; i++) {
                if (elements[i] == null) return i;
            }
        } else {
            for (int i = 0; i &lt; size; i++) {
                if (element.equals(elements[i])) return i; // n
            }
        }
        return ELEMENT_NOT_FOUND;
    }


    /**
     * 保证要有capacity的容量
     * @param capacity
     */
    private void ensureCapacity(int capacity) {
        int oldCapacity = elements.length;
        if (oldCapacity &gt;= capacity) return;

        // 新容量为旧容量的1.5倍
        int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);
        E[] newElements = (E[]) new Object[newCapacity];
        for (int i = 0; i &lt; size; i++) {
            newElements[i] = elements[i];
        }
        elements = newElements;

        System.out.println(oldCapacity + &quot;扩容为&quot; + newCapacity);
    }

    @Override
    public String toString() {
        // size=3, [99, 88, 77]
        StringBuilder string = new StringBuilder();
        string.append(&quot;size=&quot;).append(size).append(&quot;, [&quot;);
        for (int i = 0; i &lt; size; i++) {
            if (i != 0) {
                string.append(&quot;, &quot;);
            }

            string.append(elements[i]);

        }
        string.append(&quot;]&quot;);
        return string.toString();
    }

    /**
     * 新添加功能
     */
    public int search(E element){
        for (int i = 0;i&lt;size;i++){
            if (element == elements[i]){
                return i;
            }
        }
        return ELEMENT_NOT_FOUND;
    }

}

</code></pre>
<h3 id="LinkedList-设计"><a href="#LinkedList-设计" class="headerlink" title="LinkedList 设计"></a>LinkedList 设计</h3><pre><code class="java">package com.wztlink1013.ds.linkedlist;

/**
 *fun：链表的实现
 */
@SuppressWarnings(&quot;unchecked&quot;)
public class LinkedList&lt;E&gt; extends AbstractList&lt;E&gt; {
    private Node&lt;E&gt; first;
    private Node&lt;E&gt; last;

    private static class Node&lt;E&gt; {
        E element;
        Node&lt;E&gt; prev;
        Node&lt;E&gt; next;
        public Node(E element, Node&lt;E&gt; next) {
            this.element = element;
            this.next = next;
        }
    }

    @Override
    public void clear() {
        size = 0;
        first = null;
        last = null;
    }

    @Override
    public E get(int index) {
        return node(index).element;
    }

    @Override
    public E set(int index, E element) {
        Node&lt;E&gt; node = node(index);
        E old = node.element;
        node.element = element;
        return old;
    }

    @Override
    public void add(int index, E element) {
        if (index == 0){
            first = new Node&lt;&gt;(element, first);
        } else {
            Node&lt;E&gt; prev = node(index - 1);
            prev.next = new Node&lt;&gt;(element, prev.next);
        }
        size++;
    }

    @Override
    public E remove(int index) {
//        Node&lt;E&gt; node = first;
//        if (index == 0) {
//            first = first.next;
//        } else {
//            Node&lt;E&gt; prev = node(index -1);
//            node = prev.next;
//            prev.next = node.next;
//        }
        rangeCheck(index);

        Node&lt;E&gt; node = node(index);
        Node&lt;E&gt; prev = node.prev;
        Node&lt;E&gt; next = node.next;

        if (prev == null) { // index == 0
            first = next;
        } else {
            prev.next = next;
        }

        if (next == null) { // index == size - 1
            last = prev;
        } else {
            next.prev = prev;
        }

        size--;
        return node.element;
    }

    @Override
    public int indexOf(E element) {
        if (element == null) {
            Node&lt;E&gt; node = first;
            for (int i = 0; i &lt; size; i++) {
                if (node.element == null) return i;

                node = node.next;
            }
        } else {
            Node&lt;E&gt; node = first;
            for (int i = 0; i &lt; size; i++) {
                if (element.equals(node.element)) return i;

                node = node.next;
            }
        }
        return ELEMENT_NOT_FOUND;
    }

    /**
     * 获取index位置对应的节点对象
     * @param index
     * @return
     */
    private Node&lt;E&gt; node(int index) {
        rangeCheck(index);

        if (index &lt; (size &gt;&gt; 1)) {
            Node&lt;E&gt; node = first;
            for (int i = 0; i &lt; index; i++) {
                node = node.next;
            }
            return node;
        } else {
            Node&lt;E&gt; node = last;
            for (int i = size - 1; i &gt; index; i--) {
                node = node.prev;
            }
            return node;
        }
    }

    @Override
    public String toString() {
        StringBuilder string = new StringBuilder();
        string.append(&quot;size=&quot;).append(size).append(&quot;, [&quot;);
        Node&lt;E&gt; node = first;
        for (int i = 0; i &lt; size; i++) {
            if (i != 0) {
                string.append(&quot;, &quot;);
            }

            string.append(node);

            node = node.next;
        }
        string.append(&quot;]&quot;);
        return string.toString();
    }
}
</code></pre>
<p>##</p>
]]></content>
      <categories>
        <category>DataStructure</category>
      </categories>
  </entry>
  <entry>
    <title>DOS/CMD/Windows/提高开发效率</title>
    <url>/blog/nvlr2g/</url>
    <content><![CDATA[<h2 id="一、快捷键"><a href="#一、快捷键" class="headerlink" title="一、快捷键"></a>一、快捷键</h2><blockquote>
<p>很多软件的快捷键使用相通，在不确定的情况下，先试试其他软件的快捷键的使用方法</p>
</blockquote>
<h3 id="Windows-快捷键"><a href="#Windows-快捷键" class="headerlink" title="Windows 快捷键"></a>Windows 快捷键</h3><blockquote>
<p><strong>HP 惠普笔记本</strong></p>
</blockquote>
<pre><code class="powershell">Win+E                  打开文件管器
Win+D                  显示桌面
Win+L                  锁计算机
Win+V：                                打开剪贴板
Win+PgUp：                            在桌面选定左上角软件/文件
Win+PgDown：                        在桌面选定右下角软件/文件
Win+G                                    录频选项
Win+alt+G                            直接录频

alt+F4                关闭当前程序

ctrl+shift+Esc/ctrl+alt+delete：任务管理器
ctrl+F                文本或网页中查找（退出一般按ESC）
ctrl+A                选中所有文本
</code></pre>
<h3 id="Eclipse-快捷键"><a href="#Eclipse-快捷键" class="headerlink" title="Eclipse 快捷键"></a>Eclipse 快捷键</h3><blockquote>
<p>ctrl+shift+L：eclipse 所有快捷键<br><code>//</code>注释：<code>ctrl+shift+c</code>（添加和注释都是这样）或者<code>ctrl+/</code> &gt; <code>/**/</code>注释：添加<code>ctrl+shift+/</code>   取消<code>ctrl+shift+\</code></p>
</blockquote>
<pre><code>Alt+方向键：                    将当前行向上或者向下移动
ctrl+m：                            编辑窗口最大化（反复两次按即取消）
ctrl+.及ctrl+1：            下一个错误及快速修改
Control+O:                         快速概要,迅速的跳到一个方法或者属性，只需要输入名字的头几个字母。

shift+home/end：                选中一行
ctrl+pgup/pgdn：                切换页面（浏览器打开的页面/编辑器的多窗口）
</code></pre><h3 id="VScode-快捷键"><a href="#VScode-快捷键" class="headerlink" title="VScode 快捷键"></a>VScode 快捷键</h3><pre><code>ctrl+shift+c                直接进入博客根目录下的CMD模式
</code></pre><h3 id="Pycharm-JetBrains-快捷键"><a href="#Pycharm-JetBrains-快捷键" class="headerlink" title="Pycharm/JetBrains 快捷键"></a>Pycharm/JetBrains 快捷键</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685666000-0fb595f1-51e4-4e71-8547-96aa0b938148.png#align=left&amp;display=inline&amp;height=397&amp;margin=%5Bobject%20Object%5D&amp;originHeight=397&amp;originWidth=769&amp;size=0&amp;status=done&amp;style=none&amp;width=769" alt></p>
<pre><code>Ctrl+F5（左上角）：（return &quot;project&quot;）重新debug该文件
F9：（resume program）一个断点接着一个断点走，不按行走（eg：有循环会随着i一步一步走完）
F8：（step over） 一行一行走代码
F7：（step into） 进入函数内部
Alt+shift+F7：（step into mycode）遇到自己函数  进去
shift+F8：（step out）跳出，进入函数后，跳出来
Alt+F10：（show execution point）指针显示当前断点旁边
**Show Python Prompt**按键,交互式调试命令
</code></pre><h2 id="二、CMD-之常用命令"><a href="#二、CMD-之常用命令" class="headerlink" title="二、CMD 之常用命令"></a>二、CMD 之常用命令</h2><blockquote>
<ul>
<li>使用 help 命令，查看所有的 dos 命令</li>
<li>找到命令之后，使用 <code>命令+ /?</code>来查看该命令下的其他属性</li>
<li>DOS 不区分大小写</li>
</ul>
</blockquote>
<h3 id="磁盘-文件夹相关"><a href="#磁盘-文件夹相关" class="headerlink" title="磁盘/文件夹相关"></a>磁盘/文件夹相关</h3><ul>
<li><code>d:</code> <code>e:</code> 进入不同的盘</li>
<li><code>cd:</code> 进入指定文件夹。注意：只在<strong>该磁盘</strong>才有效</li>
<li><code>dir</code> 查看当前目录下的所有文件，使用 dir /?来查看其它用法</li>
<li>创建和删除目录<ul>
<li>md 目录名（文件夹） //创建目录</li>
<li>rd   目录名（文件夹） //删除目录</li>
</ul>
</li>
<li>cd .. 返回上一级文件夹</li>
<li><p>复制文件:把一个文件移动（就是剪切+复制）到另一个地方。甚至可以改后缀</p>
<blockquote>
<p>move 路径\文件名 路径\文件名</p>
</blockquote>
</li>
<li><p>删除文件</p>
<blockquote>
<p>//这个是专门删除文件的，不能删除文件夹<br>del 文件名</p>
</blockquote>
</li>
<li><p><strong>生成文件树</strong></p>
<blockquote>
<p>tree /f &gt;tree.txt</p>
</blockquote>
</li>
</ul>
<h3 id="网络相关"><a href="#网络相关" class="headerlink" title="网络相关"></a>网络相关</h3><ul>
<li><code>ipconfig</code> 查看本机 ip</li>
<li><code>cls</code> 清除屏幕</li>
<li>ping<blockquote>
<p>//用来测试网络是否畅通<br>ping ip(主机名)</p>
</blockquote>
</li>
</ul>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><pre><code>复制内容：右键弹出快捷菜单，选择“标记(K)”，然后选中所需复制的内容，然后右键即可

粘贴内容：右键弹出快捷菜单，选择“粘贴(P)”
</code></pre><ul>
<li>在文件夹空白处按住 Shift，然后右键弹出快捷菜单，可以看到“在此处打开命令行窗口”</li>
<li>tab 补齐功能！！！</li>
<li>文件及目录名中不能包含下列任何字符：\ / : * ? “ &lt; &gt; |</li>
</ul>
<h2 id="三、CMD-之默认非-utf-8-编码"><a href="#三、CMD-之默认非-utf-8-编码" class="headerlink" title="三、CMD 之默认非 utf-8 编码"></a>三、CMD 之默认非 utf-8 编码</h2><p>运行 java 程序时候，如果代码中有中文，会出现中文报错乱码情况/</p>
<h3 id="治标方法"><a href="#治标方法" class="headerlink" title="治标方法"></a>治标方法</h3><p><code>CMD</code> 中输入 <code>chcp 65001</code> 进入 utf-8 模式下的的控制台，再运行程序</p>
<h3 id="治本方法"><a href="#治本方法" class="headerlink" title="治本方法"></a>治本方法</h3><p><a href="https://blog.csdn.net/gulang03/article/details/81771343" target="_blank" rel="noopener">博文 1</a>  <a href="https://blog.csdn.net/runAndRun/article/details/103072938?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task" target="_blank" rel="noopener">博文 2</a>注意：自己已经再注册表中增加了一行 tuf-8 编码数据，以后要留意、<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685666566-625a520c-ff9d-4eea-8fba-3a8c4f8f696e.png#align=left&amp;display=inline&amp;height=24&amp;margin=%5Bobject%20Object%5D&amp;originHeight=24&amp;originWidth=660&amp;size=0&amp;status=done&amp;style=none&amp;width=660" alt></p>
<h2 id="四、CMD-之运行-JAVA"><a href="#四、CMD-之运行-JAVA" class="headerlink" title="四、CMD 之运行 JAVA"></a>四、CMD 之运行 JAVA</h2><h3 id="CMD-运行-java-程序"><a href="#CMD-运行-java-程序" class="headerlink" title="CMD 运行 java 程序"></a>CMD 运行 java 程序</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685666652-cb97d69b-664c-4506-a24f-1dc5b8220a02.png#align=left&amp;display=inline&amp;height=940&amp;margin=%5Bobject%20Object%5D&amp;originHeight=940&amp;originWidth=902&amp;size=0&amp;status=done&amp;style=none&amp;width=902" alt></p>
<h3 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h3><blockquote>
<p>main 主函数可以看成一个普通的方法，也可以传递实参来调用普通方法<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685666759-75d2a062-c52d-4c49-acce-7310a0280f24.png#align=left&amp;display=inline&amp;height=214&amp;margin=%5Bobject%20Object%5D&amp;originHeight=214&amp;originWidth=1070&amp;size=0&amp;status=done&amp;style=none&amp;width=1070" alt></p>
</blockquote>
<hr>
<blockquote>
<p>向 main 方法传递字符串<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685666878-98ce351e-4485-4381-bcfe-4b9121226fc9.png#align=left&amp;display=inline&amp;height=778&amp;margin=%5Bobject%20Object%5D&amp;originHeight=778&amp;originWidth=1098&amp;size=0&amp;status=done&amp;style=none&amp;width=1098" alt></p>
</blockquote>
<h3 id="CMD-下运行-Java-中文乱码"><a href="#CMD-下运行-Java-中文乱码" class="headerlink" title="CMD 下运行 Java 中文乱码"></a>CMD 下运行 Java 中文乱码</h3><p><code>javac -encoding utf-8 test.java</code></p>
<p>还是上面的问题，DOS 默认使用的编码是 GBK,这里需要再编译的时候制定使用的编码</p>
<h2 id="五、笔记本触摸板"><a href="#五、笔记本触摸板" class="headerlink" title="五、笔记本触摸板"></a>五、笔记本触摸板</h2><h3 id="笔记本触摸屏使用"><a href="#笔记本触摸屏使用" class="headerlink" title="笔记本触摸屏使用"></a>笔记本触摸屏使用</h3><ul>
<li><strong>单指</strong>：“确定键”<br>点击===相当于左键确定<br>先点击 不放拖动 ===拖拽</li>
<li><strong>双指</strong>：“右键、滑动、拉伸旋转键”<br>点击=相当于右键（鼠标）<br>先点击   不放左右拖动上下拖动=滑页功能<br>等比例拉伸或者旋转</li>
<li><strong>三指</strong>：“页面切换键”<br>点击=查找<br>先点击   不放   上下拖动=多页面模式、纯桌面模式切换<br>先点击   不放   左右拖动===页面切换类似 alt+tab</li>
<li><strong>四指</strong>：“设置键”<br>点击===设置/操作中心</li>
</ul>
<h3 id="实现手写输入功能"><a href="#实现手写输入功能" class="headerlink" title="实现手写输入功能"></a>实现手写输入功能</h3><ul>
<li>第一步：安装 SoftStylus 手写软件</li>
</ul>
<p>本身没有预装 SoftStylus 手写软件的，首先登录 HP 官方网站，查询并下载手写软件，然后安装手写软件。如果已预装手写软件，建议运行 Software Setup 软件，将手写软件升级到最新版本，以提高手写识别成功率。</p>
<ul>
<li>第二步：设置手写识别速度</li>
</ul>
<p>运行手写软件，点击设置图标进入“参数”界面，然后可根据需要配置识别速度。如果是初次使用手写功能，刚开始建议将识别速度降低，一旦习惯了使用手写功能，应该将识别速度调为最快，这样在 QQ 聊天或编辑文档时，以应对较快的手写输入连写。</p>
<ul>
<li>第三步：设置各种热键</li>
</ul>
<p>此外，替换选项可设置在主窗口上显示最多可选择字符，这个应该根据笔记本屏幕大小而定，例如 14 英寸屏幕可设置为 7，而 12 英寸屏幕应该设为 4，最后建议开启“汉字预览”功能，切换到“热键”选项页，然后可根据需要自定义各种热键。</p>
<ul>
<li>第四步：设置手写窗口外观</li>
</ul>
<p>如果经常使用手写功能，建议切换到“一般”选项页，勾寻操作系统起动时运行 SoftStylus”复选框，最后切换到“外观”选项页，并调节窗口透明度、画笔宽度和墨色。如果是 QQ 聊天，建议将画笔宽度调细一点，且墨色应该设为黑色。</p>
<ul>
<li>第五步：使用手写进行聊天</li>
</ul>
<p>设置完毕后，单击“确认”按钮，当你在 QQ 聊天或编辑文档时，如想使用手写输入，只需按下前面设置的快捷键，即可马上弹出手写输入界面。<br>这个时候，就可以用手指在触摸板上比划，文字就会显示在界面里，最后出现在聊天窗口中，很方便。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li>W<a href="https://www.jianshu.com/p/7bd7574d94c8" target="_blank" rel="noopener">indows 常用快捷键与快捷指令</a></li>
</ul>
]]></content>
      <categories>
        <category>Environment</category>
      </categories>
      <tags>
        <tag>CMD</tag>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机组成原理知识点回顾</title>
    <url>/blog/pnf49g/</url>
    <content><![CDATA[<blockquote>
<p>利用一些基本的问题简单回顾一下这学期学的计组的基本知识点。</p>
</blockquote>
<h2 id="概论"><a href="#概论" class="headerlink" title="概论"></a>概论</h2><blockquote>
<p>电子数字计算机和电子模拟计算机的区别是什么？</p>
</blockquote>
<p>电子数字计算机处理的信息是<strong>离散</strong>的，运算过程是离散的<br>电子模拟计算机处理的信号时<strong>连续</strong>的，运算过程是连续的</p>
<blockquote>
<p>冯诺依曼计算机的特点是什么？其中最主要的一点是什么？</p>
</blockquote>
<ol>
<li>计算机由运算器、控制器、存储器、输入系统、输出系统<strong>五大部件</strong>组成（注意中央处理器是运算器和控制器的合称）</li>
<li>计算机内部由<strong>二进制编码</strong>指令和数据</li>
<li>将编好的数据和程序<strong>先放</strong>入存储器中，然后<strong>再启动</strong>计算机工作</li>
</ol>
<p>其中最主要的一点是第三点最主要！</p>
<h2 id="数据的机器层次表示"><a href="#数据的机器层次表示" class="headerlink" title="数据的机器层次表示"></a>数据的机器层次表示</h2><blockquote>
<p>机器数的原码+反码+补码表示</p>
</blockquote>
<p>定点小数表示：阶码：小数点位数；尾数：在小数那里编码即可</p>
<p>真值就是加正负所表现出来的</p>
<blockquote>
<p>给定计算机字长位数，知道各种情况下表示数值的范围</p>
</blockquote>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1608863188017-8f6c8d66-710e-4880-8559-af59c6e37609.png#align=left&amp;display=inline&amp;height=356&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=712&amp;originWidth=1315&amp;size=336629&amp;status=done&amp;style=shadow&amp;width=657.5" alt="image.png"></p>
<h2 id="数值的机器运算"><a href="#数值的机器运算" class="headerlink" title="数值的机器运算"></a>数值的机器运算</h2><blockquote>
<p>定点加减运算+判断结果是否溢出</p>
</blockquote>
<ol>
<li>先写出两个数的补码（减法运算转换为加法运算即可）</li>
<li>然后进行二进制加法运算（遵循 0+0=0，1+0=1，0+1=1，1+1=10 向高位进位）</li>
<li>判断是否溢出【00：结果为正无溢出；01：正溢；10：负溢；11 结果为负无溢出】</li>
<li>将[X+Y]补转换为[X+Y]真值<blockquote>
<p>定点乘法运算：原码一位乘法运算+补码一位乘法运算</p>
</blockquote>
</li>
</ol>
<p>原码一位乘法运算：</p>
<ol>
<li>先写出 X 和 Y 的绝对值|X|和|Y|</li>
<li>让 00.0……和|X|相加同时判断|Y|的最后一位（如果为 1 加|X|如果是 0 加 0）</li>
<li>加完之后右移一位，再判断，加了再判断，啥时候那个分隔符分没了，就好了……………</li>
<li>最后判断真值符号</li>
</ol>
<p>我写的个啥………………逃</p>
<p>补码一位乘法运算：</p>
<ol>
<li>写出[X]补[-X]补[Y]补</li>
<li>在[Y]补码尾巴后面加一个 0，判断最后两位，（00 加 0；10 加[-X]补；01 加[X]补；11 加 0）</li>
<li>让 00.000……加上上面判断的加上某某</li>
<li>又一直这样下去下去……</li>
<li>把补码换成原码即可……</li>
</ol>
<p>…………逃 🤣</p>
<h2 id="指令系统"><a href="#指令系统" class="headerlink" title="指令系统"></a>指令系统</h2><blockquote>
<p>什么叫主程序和子程序？调用子程序还可以采用哪几种方法保存返回地址？画出图说明调用子程序的过程。</p>
</blockquote>
<p>主程序：<strong>通常</strong>的程序<br><strong><br>子程序：可以被反复调用、</strong>公用<strong>的程序，只要知道其</strong>入口地址**，就可以调用之，其就是我们编程常写的函数</p>
<p>保存返回地址的方法：</p>
<ul>
<li>子程序的第一个<strong>子单元</strong>存放返回地址，然后从第二个字单元开始执行子程序</li>
<li><strong>寄存器</strong>存放</li>
<li><strong>堆栈</strong>保存</li>
</ul>
<p>以堆栈保存返回地址的方法来说明调用子程序的过程：<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1608774330112-3e8bf3df-1091-4476-aa72-e9757e36a3e6.png#align=left&amp;display=inline&amp;height=77&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=154&amp;originWidth=242&amp;size=22896&amp;status=done&amp;style=shadow&amp;width=121" alt="image.png"></p>
<blockquote>
<p>如果某计算机调用子程序保存返回地址是上个问题的第一种方式，有这么几个问题：</p>
<ol>
<li>为这种方法设计一条从子程序转到主程序的返回指令</li>
<li>怎么在主程序和子程序之间进行传参</li>
<li>可否用于子程序嵌套</li>
<li>可否用于子程序的递归</li>
<li>如果将该种方式改为第三种方式（堆栈方式），可否完成 4</li>
</ol>
</blockquote>
<ol>
<li>使用间接寻址方式</li>
</ol>
<table>
<thead>
<tr>
<th>JMP</th>
<th>@</th>
<th>子程序首地址</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<ol start="2">
<li>可以利用寄存器或主存单元进行主、子程序间的参数传递</li>
<li>可以。返回的地址都放在子程序的第一个单元</li>
<li>不可以。会破坏其内部结构</li>
<li>可以。因为堆栈具有后进先出功能</li>
</ol>
<h2 id="存储系统和结构"><a href="#存储系统和结构" class="headerlink" title="存储系统和结构"></a>存储系统和结构</h2><blockquote>
<p>如何区别存储器和寄存器？两者是一回事说法对吗？</p>
</blockquote>
<p>两者不是一回事。</p>
<p>存储器是在<strong>CPU</strong>外边，用来存放数据和程序的，访问存储器的<strong>速度</strong>较慢；</p>
<p>寄存器数据 CPU 的一部分，访问寄存器的速度很快。<br>**</p>
<blockquote>
<p>存储器的主要功能是什么？为什么把存储系统分成若干个不同层次？主要有那些层次？</p>
</blockquote>
<p>存储器的主要功能：存储数据和程序</p>
<p>存储系统是有几个<strong>容量、速度、价格</strong>不同的存储器用硬件、软件、软硬件相结合起来的系统。分成若干个不同层次是因为考虑到不同存储器的价格因素、存储速度、存储容量三个因素。</p>
<ol>
<li>高速缓存</li>
<li>主存</li>
<li>辅存</li>
</ol>
<p>其中 12 又称之为 Cache-主存存储层次，23 又称之为主存-辅存存储层次。</p>
<blockquote>
<p>动态 RAM 为什么要刷新？一般有几种刷新方式？各有什么优缺点？</p>
</blockquote>
<p><strong>为了维持 DRAM 的记忆单元的存储信息</strong></p>
<ul>
<li><strong>集中式</strong>刷新</li>
</ul>
<p>优点：<strong>读写操作</strong>不受刷新工作的影响，<strong>存取速度</strong>高</p>
<p>缺点：存储容量越大，死区越长</p>
<ul>
<li><strong>分散式</strong>刷新</li>
</ul>
<p>优点：没有死区</p>
<p>缺点：加长了系统的<strong>存取周期</strong>，降低了整机的速度，并且刷新过于频繁，没有充分利用允许的最大刷新间隔</p>
<ul>
<li><strong>异步式</strong>刷新</li>
</ul>
<p>异步式虽然有死区，但是比几种方式的<strong>死区小</strong>得多，而且<strong>减少了刷新次数</strong>，是比较实用的一种刷新方式。</p>
<h2 id="中央处理器"><a href="#中央处理器" class="headerlink" title="中央处理器"></a>中央处理器</h2><hr>
<blockquote>
<p>控制器有哪几种控制方式？各有何特点？</p>
</blockquote>
<ul>
<li><strong>同步</strong>控制方式</li>
</ul>
<p>该控制方式各项操作都由统一的<strong>时序信号</strong>完成，并且在每个及其周期中产生统一的<strong>节拍电位和工作脉冲</strong>。这种方式设计简单，但是对于许多<strong>单指令</strong>来说，有太多的<strong>空闲时间</strong>，造成时间浪费，影响指令执行速度。</p>
<ul>
<li><strong>异步</strong>控制方式</li>
</ul>
<p>该控制方式的各项操作都<strong>不由统一的时序信号</strong>完成，而是由指令本身或部件的具体情况决定，因此这种控制方式的效率高，时间能够合理利用，但是该控制方式也比较复杂。</p>
<ul>
<li><strong>联合</strong>控制方式</li>
</ul>
<p>是由上面的同步控制方式和异步控制方式相结合的方式。</p>
<hr>
<blockquote>
<p>什么是三级时序系统？</p>
</blockquote>
<p>三级时序系统是指<strong>机器周期</strong>、<strong>节拍</strong>、<strong>工作脉冲</strong></p>
<p>具体所属关系是：每个指令周期划分若干个机器周期，每个机器周期划分若干个节拍，每个节拍划分 1 个或几个工作脉冲。</p>
<hr>
<blockquote>
<p>控制器有哪些基本功能？可分为哪几类？分类的依据是什么？</p>
</blockquote>
<p>基本功能：</p>
<ul>
<li>从主存中<strong>取出一条指令</strong>，并指出下一跳指令在主存中的位置</li>
<li>对指令进行<strong>译码或是测试</strong>，产生相应的操作控制信号，以便启动规定的工作</li>
<li>指挥并控制<strong>CPU</strong>，主存和输入输出设备之间的<strong>数据流动</strong></li>
</ul>
<p>分类：</p>
<ul>
<li><strong>组合逻辑</strong>型</li>
<li><strong>存储逻辑</strong>型</li>
<li>组合逻辑和存储逻辑<strong>结合</strong>型</li>
</ul>
<p>分类的依据：<br>在于控制器的核心——<strong>微操作信号发生器的实现方法不同</strong>。</p>
<hr>
<blockquote>
<p>中央处理器有哪些功能？它是由那些基本部件构成的？</p>
</blockquote>
<p>构成：</p>
<ul>
<li>控制器</li>
<li>运算器</li>
</ul>
<p>功能：<br>对数据流和指令流在时间上和空间上进行正确的控制。当然，对于冯诺依曼结构的计算机而言，数据流是基于指令流的操作而驱动的。</p>
<hr>
<blockquote>
<p>中央处理器有哪几个主要寄存器？说说他们的结构和功能？</p>
</blockquote>
<p>寄存器的功能就是用来存放程序运行过程中的中间结果、最终结果以及控制、状态信息的。</p>
<ul>
<li>通用寄存器</li>
</ul>
<p>用来存放原始数据和运算结果，有的还可以作为变址寄存器、计数器、地址指针等</p>
<ul>
<li>专用寄存器</li>
</ul>
<p>是用来完成某些特定功能的寄存器：程序计数器（PC）、指令寄存器（IR）、存储器地址寄存器（MAR）、存储器数据寄存器（MDR）、程序状态字寄存器（PSWR）等</p>
<blockquote>
<p>以单指令为例，简要说明下列部件在计算机的取值周期和执行周期的作用。</p>
</blockquote>
<ul>
<li>程序计数器（PC）：存放指令地址</li>
<li>指令寄存器（IR）：存放当前指令</li>
<li>存储器地址寄存器（MAR）：进行算术逻辑运算</li>
<li>存储器数据寄存器（MDR）：存放写入或读出的数据/指令</li>
<li>程序状态字寄存器（PSWR）：存放写入或读出的数据/指令的地址</li>
</ul>
<hr>
<blockquote>
<p>什么是指令周期？什么是 CPU 周期？他们之间有什么关系？</p>
</blockquote>
<p>指令周期：指<strong>取指令</strong>、<strong>分析指令</strong>到<strong>执行指令</strong>所花费的所有时间</p>
<p>CPU 周期：也叫<strong>机器周期</strong>，是指完成一个基本操作所花费的时间<br>一个指令周期划分为多个 CPU 周期</p>
<hr>
<h2 id="【总线-外部设备】nothing"><a href="#【总线-外部设备】nothing" class="headerlink" title="【总线+外部设备】nothing"></a>【总线+外部设备】nothing</h2><h2 id="输入输出系统"><a href="#输入输出系统" class="headerlink" title="输入输出系统"></a>输入输出系统</h2><hr>
<blockquote>
<p>什么是计机的输入输出系统？输入输出设备有哪些编址方式？有什么特点？</p>
</blockquote>
<p>输入输出系统：包括输入输出<strong>接口</strong>和输入输出信息<strong>传送</strong>控制方式，是计算机系统中最具有<strong>多样性</strong>和<strong>复杂性</strong>的部分。</p>
<p>编址方式：</p>
<ul>
<li><strong>独立编址</strong></li>
</ul>
<p>优点：指令易于区分，译码简单，主存空间不会减少</p>
<p>缺点：增加了控制线 I/ORead 和 I/OWrite 信号</p>
<ul>
<li><strong>统一编址</strong></li>
</ul>
<p>优点：总线结构简单，全部访存类指令都可用于控制外设，可直接对外设寄存器进行各种运算</p>
<p>缺点：占用主存一部分地址，缩小了可用的主存空间</p>
<hr>
<blockquote>
<p>什么是 I/O 接口？I/O 接口有哪些特点和功能？接口有哪些类型？</p>
</blockquote>
<p>主机和外设之间的交接界面</p>
<p>特点：<br>实现信息交换</p>
<p>功能：</p>
<ul>
<li>实现主机和外设的通信联络控制</li>
<li>进行地址译码和设备选择</li>
<li>实现数据缓冲</li>
<li>完成数据格式的变换</li>
<li>传递控制命令和状态信息</li>
</ul>
<p>类型：</p>
<ul>
<li>串行接口</li>
<li>并行接口</li>
</ul>
<hr>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1608728980150-18e3d2ee-cc80-4187-b38c-14c78554e979.png#align=left&amp;display=inline&amp;height=152&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=198&amp;originWidth=766&amp;size=190453&amp;status=done&amp;style=none&amp;width=589" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1608729028676-c983dd94-3689-431d-bf54-76bbb5b01f75.png#align=left&amp;display=inline&amp;height=80&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=160&amp;originWidth=788&amp;size=111323&amp;status=done&amp;style=none&amp;width=394" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1608729049887-aee5cd74-e49d-44d1-88b2-bcdc511ff3c3.png#align=left&amp;display=inline&amp;height=107&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=214&amp;originWidth=968&amp;size=213320&amp;status=done&amp;style=none&amp;width=484" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1608729065956-47dc5b50-caaa-44a1-a54e-8e3f5ae2192a.png#align=left&amp;display=inline&amp;height=172&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=343&amp;originWidth=687&amp;size=119088&amp;status=done&amp;style=none&amp;width=343.5" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1608729081886-f27d6175-e541-4379-b158-0093a23b693d.png#align=left&amp;display=inline&amp;height=139&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=277&amp;originWidth=922&amp;size=156708&amp;status=done&amp;style=none&amp;width=461" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1608729097801-61fd270b-1608-48ab-b1fa-a951febba5d6.png#align=left&amp;display=inline&amp;height=87&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=173&amp;originWidth=907&amp;size=129678&amp;status=done&amp;style=none&amp;width=453.5" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1608729108461-95f5d6e5-efd6-4acf-a2c7-fb72f6052d25.png#align=left&amp;display=inline&amp;height=71&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=141&amp;originWidth=897&amp;size=100962&amp;status=done&amp;style=none&amp;width=448.5" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1608729131667-e6955db4-4b2c-4efb-ad1f-3acf8ccc5e48.png#align=left&amp;display=inline&amp;height=315&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=630&amp;originWidth=974&amp;size=493234&amp;status=done&amp;style=none&amp;width=487" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1608729144873-1a207e20-98d9-4e44-b40e-c1a81a54b667.png#align=left&amp;display=inline&amp;height=195&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=390&amp;originWidth=968&amp;size=379559&amp;status=done&amp;style=none&amp;width=484" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1608729157489-b3899992-00d9-405b-8f02-9619f08d9960.png#align=left&amp;display=inline&amp;height=193&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=386&amp;originWidth=938&amp;size=349548&amp;status=done&amp;style=none&amp;width=469" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1608729176250-7499ab5f-2a40-4514-92f3-afc46c739936.png#align=left&amp;display=inline&amp;height=275&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=549&amp;originWidth=1005&amp;size=475058&amp;status=done&amp;style=none&amp;width=502.5" alt="image.png"></p>
]]></content>
      <categories>
        <category>计算机结构和组成</category>
      </categories>
      <tags>
        <tag>计组</tag>
      </tags>
  </entry>
  <entry>
    <title>IDEA创建javaWeb项目</title>
    <url>/blog/qi1ddv/</url>
    <content><![CDATA[<h2 id="一、Tomcat-下载"><a href="#一、Tomcat-下载" class="headerlink" title="一、Tomcat 下载"></a>一、Tomcat 下载</h2><h3 id="1-下载并安装"><a href="#1-下载并安装" class="headerlink" title="1. 下载并安装"></a>1. 下载并安装</h3><blockquote>
<p>假如不是集成开发环境（比如 phpstudy），电脑要有 jdk 环境</p>
</blockquote>
<p>【1】官网下载：<a href="http://tomcat.apache.org/" target="_blank" rel="noopener">http://tomcat.apache.org/</a></p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598787914511-a035ba93-0b7a-450b-b391-5d1452435ca7.png#align=left&amp;display=inline&amp;height=220&amp;margin=%5Bobject%20Object%5D&amp;originHeight=952&amp;originWidth=1842&amp;size=0&amp;status=done&amp;style=shadow&amp;width=425" alt><br>【2】下载并解压到自己的相应盘区，再检验是否成功<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598787914448-2ef2e1a1-2966-4d35-8bfe-82162aa1588b.png#align=left&amp;display=inline&amp;height=273&amp;margin=%5Bobject%20Object%5D&amp;originHeight=727&amp;originWidth=1147&amp;size=0&amp;status=done&amp;style=shadow&amp;width=431" alt><br>点击第二个框不出现闪退情况则证明成功<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598787914507-87063aec-884a-4180-b124-568478d81bc0.png#align=left&amp;display=inline&amp;height=222&amp;margin=%5Bobject%20Object%5D&amp;originHeight=639&amp;originWidth=1223&amp;size=0&amp;status=done&amp;style=shadow&amp;width=425" alt><br>【3】浏览器进入端口<a href="http://localhost:8080/" target="_blank" rel="noopener">http://localhost:8080/</a>上述配置成功则表明成功<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598787914624-248148e3-3f5f-45ca-ad93-c063216a7aff.png#align=left&amp;display=inline&amp;height=270&amp;margin=%5Bobject%20Object%5D&amp;originHeight=1030&amp;originWidth=1838&amp;size=0&amp;status=done&amp;style=shadow&amp;width=482" alt></p>
<h3 id="2-过程中可能会出现的问题"><a href="#2-过程中可能会出现的问题" class="headerlink" title="2. 过程中可能会出现的问题"></a>2. 过程中可能会出现的问题</h3><p>【1】点击 startup.bat 文件出现闪退</p>
<blockquote>
<p>电脑中 java jdk 有无（JAVA_HOME）</p>
</blockquote>
<p>【2】端口被占用</p>
<blockquote>
<p>进入 Tomcat 文件夹下的 conf 文件下的 server.xml 文件，用记事本查找 8080，下面复制一个新的初始端口<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598787914513-8083bc6e-4c6f-436e-b0b0-98d3d70b9dea.png#align=left&amp;display=inline&amp;height=80&amp;margin=%5Bobject%20Object%5D&amp;originHeight=80&amp;originWidth=557&amp;size=0&amp;status=done&amp;style=shadow&amp;width=557" alt></p>
</blockquote>
<h2 id="二、利用-IDEA-创建一个-JavaWeb-项目"><a href="#二、利用-IDEA-创建一个-JavaWeb-项目" class="headerlink" title="二、利用 IDEA 创建一个 JavaWeb 项目"></a>二、利用 IDEA 创建一个 JavaWeb 项目</h2><h3 id="1-创建新项目"><a href="#1-创建新项目" class="headerlink" title="1. 创建新项目"></a>1. 创建新项目</h3><p>依次点击：<code>File</code>-&gt; <code>New</code>-&gt; <code>Project</code><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612697874347-fef7ad38-7ff2-4567-89a9-f5d47a1f4824.png#align=left&amp;display=inline&amp;height=316&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=812&amp;originWidth=1202&amp;size=104672&amp;status=done&amp;style=none&amp;width=468" alt="image.png"></p>
<h3 id="2-项目工程配置"><a href="#2-项目工程配置" class="headerlink" title="2. 项目工程配置"></a>2. 项目工程配置</h3><p>【1】在<code>WEB-INF</code>下创建两个空文件夹 <code>classes</code> <code>lib</code></p>
<blockquote>
<p>目的：</p>
<ul>
<li>classes 文件夹用于存放编译后的 class 文件</li>
<li>lib 文件夹用于存放依赖的 jar 包</li>
</ul>
</blockquote>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612697966439-ab639870-61ab-429e-919a-4109c8cefdc5.png#align=left&amp;display=inline&amp;height=237&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=473&amp;originWidth=469&amp;size=29009&amp;status=done&amp;style=none&amp;width=234.5" alt="image.png"><br>【2】依次点击<code>file</code> -&gt; <code>Project Structure</code></p>
<blockquote>
<p>目的：将后面编译的 class 文件默认生成到刚刚新建的 classes 目录下</p>
</blockquote>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612698144393-24e78472-430b-47a4-b423-e091597bb4f3.png#align=left&amp;display=inline&amp;height=364&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=727&amp;originWidth=1535&amp;size=95789&amp;status=done&amp;style=none&amp;width=767.5" alt="image.png"><br>【3】依次点击<code>file</code> -&gt; <code>Project Structure</code></p>
<blockquote>
<p>目的：添加 jar 包依赖<br>（项目所需要的 jar 包都放到刚刚新建的 lib 文件夹）<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612698241583-99ff6441-6e2a-4776-addb-9f8f1eda6636.png#align=left&amp;display=inline&amp;height=268&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=535&amp;originWidth=1274&amp;size=68026&amp;status=done&amp;style=none&amp;width=637" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612698274993-98e1b314-c726-41e6-973e-1dbb07ef7312.png#align=left&amp;display=inline&amp;height=169&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=337&amp;originWidth=546&amp;size=22322&amp;status=done&amp;style=none&amp;width=273" alt="image.png"><br>【4】配置打包方式 Artifacts<br><del>点击 Artifacts 选项卡，IDEA 会为该项目自动创建一个名为“JavaWeb:war exploded”的打包方式，表示 打包成 war 包，并且是文件展开性的，输出路径为当前项目下的 out 文件夹，保持默认即可。另外勾选下“Build on make”，表示编译的时候就打包部署，勾选“Show content of elements”，表示显示详细的内容列表。</del></p>
</blockquote>
<p><em>如果按照上面说的，那么会发现发布的项目并没有在 tomcat 目录下的 webapps 目录下，如果项目以前在其他电脑抑或是其他环境下运行过，可能会导致项目的很多子页面默认 URL404。</em><br><del><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612711385355-7645f327-ad5c-40aa-a165-b975f957ebe3.png#align=left&amp;display=inline&amp;height=239&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=479&amp;originWidth=884&amp;size=112691&amp;status=done&amp;style=shadow&amp;width=442" alt="image.png"></del><br>正确解决办法：项目一开始依次点击<code>file</code> -&gt; <code>Project Structure</code></p>
<blockquote>
<p>1 区域：将 output 路径指定到<code>tomcat</code>的<code>webapps</code>下面（新建一个本项目的同名文件夹）<br>2 区域：Output Layout 就是配置这个路径里面生成的所有文件<br>3 区域：将右边的文件内容脱拉到左边的 3 区域即可</p>
</blockquote>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612763067214-29b72122-e8c6-4df1-a112-50ffb6c43084.png#align=left&amp;display=inline&amp;height=327&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=653&amp;originWidth=1535&amp;size=81034&amp;status=done&amp;style=none&amp;width=767.5" alt="image.png"></p>
<h3 id="3-Tomcat-配置"><a href="#3-Tomcat-配置" class="headerlink" title="3. Tomcat 配置"></a>3. Tomcat 配置</h3><p>【1】点击如下位置进入 tomcat 容器编辑板块<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612698536983-4544013a-5e2a-43d7-ae31-7aa5c871fb3a.png#align=left&amp;display=inline&amp;height=151&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=301&amp;originWidth=1920&amp;size=55468&amp;status=done&amp;style=none&amp;width=960" alt="image.png"><br>【2】默认会自动给我们生成一个 Tomcat 容器，基本上只需要配置<code>Deployment</code>即可，如果没有默认生成就新建一个。其中<code>Application server</code>填写本地 tomcat 的安装目录文件夹即可（因为一台电脑开发可能会有多个 tomcat 版本）<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612711521404-673143aa-f3fd-4b37-aed1-919d0ea1de1f.png#align=left&amp;display=inline&amp;height=370&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=740&amp;originWidth=1163&amp;size=152940&amp;status=done&amp;style=none&amp;width=581.5" alt="image.png"></p>
<blockquote>
<p>❗ ❗ ❗ 如果要换不同版本的 tomcat 来运行项目，改如下地方：</p>
<ol>
<li>先将上面图片<code>Application server</code>tomcat 版本更换至新的 tomcat 版本</li>
<li>去<code>2. 项目工程配置</code>步骤中，减去原先的 tomcat，加上新的 tomcat</li>
</ol>
</blockquote>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612698612335-158bfcb3-3016-478c-b86a-770ad57ad2a9.png#align=left&amp;display=inline&amp;height=511&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=1022&amp;originWidth=1611&amp;size=111169&amp;status=done&amp;style=none&amp;width=805.5" alt="image.png"></p>
<blockquote>
<p>此处的 Application context 是指定本工程的根目录</p>
</blockquote>
<h3 id="4-结果测试"><a href="#4-结果测试" class="headerlink" title="4. 结果测试"></a>4. 结果测试</h3><p>在<code>index.jsp</code>文件下添加显示代码<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612698732177-5bedf912-6a16-47d4-ab96-d5527b9567d1.png#align=left&amp;display=inline&amp;height=271&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=542&amp;originWidth=1879&amp;size=244164&amp;status=done&amp;style=none&amp;width=939.5" alt="image.png"><br>直接运行<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612698844575-2952fffc-3616-43f1-be90-138dbe0df86d.png#align=left&amp;display=inline&amp;height=128&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=256&amp;originWidth=1107&amp;size=40673&amp;status=done&amp;style=shadow&amp;width=553.5" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612698866551-55b0f5c6-fc7e-423a-8c59-2af2cbe08953.png#align=left&amp;display=inline&amp;height=152&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=303&amp;originWidth=827&amp;size=28375&amp;status=done&amp;style=shadow&amp;width=413.5" alt="image.png"></p>
<blockquote>
<p>如果在 Tomcat 配置过程中的部署路径为 <code>/</code> ，会出现下面第二张图的结果，都能访问，但是最好还是上面的方式，符合服务器“一个文件夹一个站点”的思想，路径访问的相关问题不会挖坑。</p>
</blockquote>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612698976241-4d798089-9581-4cdf-893b-dbbc11b18057.png#align=left&amp;display=inline&amp;height=511&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=1022&amp;originWidth=1611&amp;size=101904&amp;status=done&amp;style=none&amp;width=805.5" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612698989649-0fdabed2-a690-450a-b11f-3900a477a68a.png#align=left&amp;display=inline&amp;height=170&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=340&amp;originWidth=862&amp;size=27789&amp;status=done&amp;style=shadow&amp;width=431" alt="image.png"></p>
<h3 id="❗-JavaWeb-项目结构分析"><a href="#❗-JavaWeb-项目结构分析" class="headerlink" title="❗ JavaWeb 项目结构分析"></a>❗ JavaWeb 项目结构分析</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612752142869-4f7db98f-6d15-4ce5-be4b-1e0e13dcab08.png#align=left&amp;display=inline&amp;height=444&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=888&amp;originWidth=321&amp;size=43193&amp;status=done&amp;style=none&amp;width=160.5" alt="image.png"></p>
<ul>
<li>src 文件夹：编写的 java 代码，编译后会放到 WEB-INF 文件夹下的 classes 文件夹</li>
<li>web 文件夹：web 应用程序的根目录，web 应用程序所有的文件都在该目录下</li>
<li>WEB-INF：客户不能直接通过浏览器进行访问<ul>
<li>classes：存放 servlet 和其他有用的 class 文件（编译后的）</li>
<li>lib：存放 web 应用程序所需要的 jar 包</li>
<li>web.xml：存放部署和配置信息的文件（当前 WEB 项目的核心配置，Servlet2.5 必须有，3.0 以后可省略）</li>
</ul>
</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://blog.csdn.net/m0_37499059/article/details/78806617" target="_blank" rel="noopener">Intellij idea 创建 javaWeb 项目</a></li>
<li><a href="https://blog.csdn.net/c_little_white/article/details/89435646?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.control&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.control" target="_blank" rel="noopener">IDEA 启动 tomcat 不报错，tomcat 的 webapps 文件夹没有项目文件，项目的默认 URL404</a></li>
</ul>
]]></content>
      <categories>
        <category>Environment</category>
      </categories>
  </entry>
  <entry>
    <title>ping、traceroute命令编程实现</title>
    <url>/blog/qlrcf6/</url>
    <content><![CDATA[<h2 id="ping-和-tracert"><a href="#ping-和-tracert" class="headerlink" title="ping 和 tracert"></a>ping 和 tracert</h2><h3 id="ping-和-tracert-命令"><a href="#ping-和-tracert-命令" class="headerlink" title="ping 和 tracert 命令"></a>ping 和 tracert 命令</h3><p><strong>ping</strong>命令一般用来测试两台机器或者机器和服务器之间网络是否连通。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1603437323252-a3bf1470-c4ae-450a-b0fd-4d83281aab46.png#align=left&amp;display=inline&amp;height=156&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=311&amp;originWidth=1439&amp;size=57273&amp;status=done&amp;style=shadow&amp;width=719.5" alt="image.png"><br><strong>tracert</strong>命令显示数据报到达目标主机途中所经过的路径（路由器），并且显示到达每个节点（路由器）的花费时间，显示的信息比 ping 出来的信息要多，要详细。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1603437358485-aef50645-6ff9-4395-bbae-0bfe22ce3dc1.png#align=left&amp;display=inline&amp;height=269&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=538&amp;originWidth=1436&amp;size=63435&amp;status=done&amp;style=shadow&amp;width=718" alt="image.png"></p>
<h3 id="编程实现"><a href="#编程实现" class="headerlink" title="编程实现"></a>编程实现</h3><h4 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h4><pre><code class="java">import java.net.InetAddress;
import java.net.MalformedURLException;
import java.net.URL;
import java.net.UnknownHostException;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;

import java.util.Scanner;

public class CommandUtil {

    String tracert = &quot;tracert -h 10 &quot;; //模拟tracert命令
    String ping = &quot;ping&quot;;//模拟 ping 命令
    String routePrint = &quot;route print -4&quot;;//模拟route print命令

    public static void main(String args[]){

        String input = null;

        @SuppressWarnings(&quot;resource&quot;)
        Scanner scanner = new Scanner(System.in);
        //利用while循环接收输入的命令行参数
        while(true){

            System.out.println(&quot;Please input destination server IP address ：\n&quot;);

            input = scanner.next();

            CommandUtil host = new CommandUtil();

            host.tracert = host.tracert + &quot; &quot; + input;

            host.ping = host.ping + &quot; &quot; + input;

            try {

                host.command(host.routePrint);

            } catch (IOException exception) {

                exception.printStackTrace();
            }

            try {

                host.command(host.tracert) ;

            } catch (IOException exception) {

                exception.printStackTrace();
            }

            try {

                host.command(host.ping);

            } catch (IOException exception) {

                exception.printStackTrace();
            }

            InetAddress ipAddress;

            try {

                ipAddress = InetAddress.getByName(input);

                System.out.println(&quot;IP address : &quot;+ipAddress);

            } catch (UnknownHostException exception) {

                exception.printStackTrace();
            }

            URL url;

            try {
                url = new URL(&quot;http&quot;,input,80,&quot;index.html&quot;);

                System.out.println();//输出服务器地址

                System.out.println(&quot;Get the Server-Name# : &quot;+url.getHost());

                System.out.println();//输出首页文件

                System.out.println(&quot;Get the default file# : &quot;+url.getFile());

                System.out.println();//输出首页协议和端口

                System.out.println(&quot;Get the protocol# : &quot;+url.getProtocol()+&quot; &quot;+url.getPort());

                System.out.println();

            } catch (MalformedURLException e) {

                e.printStackTrace();
            }

            System.out.println();

            try {

                System.out.println(&quot;Get serverName &amp; IPAddress：&quot;+InetAddress.getByName(input));

            } catch (UnknownHostException e) {

                e.printStackTrace();
            }

            long freeMemory = Runtime.getRuntime().freeMemory();

            System.out.println(&quot;Surplus memory of JVM: &quot;+freeMemory+&quot;B&quot;);

        }
    }
    //模拟 tracert 命令

    StringBuffer commandResult = null;

    private void command(String tracerCommand) throws IOException{
        //第一步：创建进程(是接口不必初始化)

        //1.通过Runtime类的getRuntime().exec()传入需要运行的命令参数

        System.out.println();

        System.out.println(InetAddress.getByName(&quot;localhost&quot;)+&quot; is tracking the destination server...&quot;);

        Process process = Runtime.getRuntime().exec(tracerCommand);

        readResult(process.getInputStream());

        process.destroy();
    }
    //第二步：通过输入流来将命令执行结果输出到控制台

    private void readResult(InputStream inputStream) throws IOException{

        commandResult = new StringBuffer();  //初始化命令行

        String commandInfo = null; //定义用于接收命令行执行结果的字符串

        BufferedReader bufferedReader =
                new BufferedReader(new InputStreamReader(inputStream));

        while ( (commandInfo = bufferedReader.readLine()) != null)  {

            System.out.println(commandInfo);
        }
        bufferedReader.close();
    }
}
</code></pre>
<h4 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h4><pre><code>D:\Java\jdk1.8.0_181\bin\java.exe &quot;-javaagent:D:\JetBrains\IntelliJ IDEA 2020.1.3\lib\idea_rt.jar=39614:D:\JetBrains\IntelliJ IDEA 2020.1.3\bin&quot; -Dfile.encoding=GBK -classpath D:\Java\jdk1.8.0_181\jre\lib\charsets.jar;D:\Java\jdk1.8.0_181\jre\lib\deploy.jar;D:\Java\jdk1.8.0_181\jre\lib\ext\access-bridge-64.jar;D:\Java\jdk1.8.0_181\jre\lib\ext\cldrdata.jar;D:\Java\jdk1.8.0_181\jre\lib\ext\dnsns.jar;D:\Java\jdk1.8.0_181\jre\lib\ext\jaccess.jar;D:\Java\jdk1.8.0_181\jre\lib\ext\jfxrt.jar;D:\Java\jdk1.8.0_181\jre\lib\ext\localedata.jar;D:\Java\jdk1.8.0_181\jre\lib\ext\nashorn.jar;D:\Java\jdk1.8.0_181\jre\lib\ext\sunec.jar;D:\Java\jdk1.8.0_181\jre\lib\ext\sunjce_provider.jar;D:\Java\jdk1.8.0_181\jre\lib\ext\sunmscapi.jar;D:\Java\jdk1.8.0_181\jre\lib\ext\sunpkcs11.jar;D:\Java\jdk1.8.0_181\jre\lib\ext\zipfs.jar;D:\Java\jdk1.8.0_181\jre\lib\javaws.jar;D:\Java\jdk1.8.0_181\jre\lib\jce.jar;D:\Java\jdk1.8.0_181\jre\lib\jfr.jar;D:\Java\jdk1.8.0_181\jre\lib\jfxswt.jar;D:\Java\jdk1.8.0_181\jre\lib\jsse.jar;D:\Java\jdk1.8.0_181\jre\lib\management-agent.jar;D:\Java\jdk1.8.0_181\jre\lib\plugin.jar;D:\Java\jdk1.8.0_181\jre\lib\resources.jar;D:\Java\jdk1.8.0_181\jre\lib\rt.jar;D:\project-java\jiwang\out\production\jiwang CommandUtil
Please input destination server IP address ：

baidu.com

localhost/127.0.0.1 is tracking the destination server...
===========================================================================
接口列表
  6...b4 b6 86 df cc 9d ......Realtek PCIe GbE Family Controller
 11...0c 54 15 fb 33 95 ......Microsoft Wi-Fi Direct Virtual Adapter
 14...0e 54 15 fb 33 94 ......Microsoft Wi-Fi Direct Virtual Adapter #2
 16...0c 54 15 fb 33 94 ......Intel(R) Dual Band Wireless-AC 3168
 17...0c 54 15 fb 33 98 ......Bluetooth Device (Personal Area Network)
  1...........................Software Loopback Interface 1
===========================================================================

IPv4 路由表
===========================================================================
活动路由:
网络目标        网络掩码          网关       接口   跃点数
          0.0.0.0          0.0.0.0      192.168.2.1    192.168.2.132     35
        127.0.0.0        255.0.0.0            在链路上         127.0.0.1    331
        127.0.0.1  255.255.255.255            在链路上         127.0.0.1    331
  127.255.255.255  255.255.255.255            在链路上         127.0.0.1    331
      192.168.2.0    255.255.255.0            在链路上     192.168.2.132    291
    192.168.2.132  255.255.255.255            在链路上     192.168.2.132    291
    192.168.2.255  255.255.255.255            在链路上     192.168.2.132    291
        224.0.0.0        240.0.0.0            在链路上         127.0.0.1    331
        224.0.0.0        240.0.0.0            在链路上     192.168.2.132    291
  255.255.255.255  255.255.255.255            在链路上         127.0.0.1    331
  255.255.255.255  255.255.255.255            在链路上     192.168.2.132    291
===========================================================================
永久路由:
  无

localhost/127.0.0.1 is tracking the destination server...

通过最多 10 个跃点跟踪
到 baidu.com [39.156.69.79] 的路由:

  1     1 ms     1 ms     1 ms  RM2100.lan [192.168.2.1]
  2     *        *        *     请求超时。
  3     *        *        *     请求超时。
  4     4 ms     3 ms     3 ms  192.168.100.253
  5     4 ms     5 ms    10 ms  192.168.100.114
  6     3 ms     3 ms     3 ms  192.168.100.118
  7     *        *        *     请求超时。
  8     *        *        *     请求超时。
  9     *        *        *     请求超时。
 10     *        *        *     请求超时。

跟踪完成。

localhost/127.0.0.1 is tracking the destination server...

正在 Ping baidu.com [39.156.69.79] 具有 32 字节的数据:
来自 39.156.69.79 的回复: 字节=32 时间=20ms TTL=48
来自 39.156.69.79 的回复: 字节=32 时间=20ms TTL=48
来自 39.156.69.79 的回复: 字节=32 时间=20ms TTL=48
来自 39.156.69.79 的回复: 字节=32 时间=20ms TTL=48

39.156.69.79 的 Ping 统计信息:
    数据包: 已发送 = 4，已接收 = 4，丢失 = 0 (0% 丢失)，
往返行程的估计时间(以毫秒为单位):
    最短 = 20ms，最长 = 20ms，平均 = 20ms
IP address : baidu.com/39.156.69.79

Get the Server-Name# : baidu.com

Get the default file# : index.html

Get the protocol# : http 80


Get serverName &amp; IPAddress：baidu.com/39.156.69.79
Surplus memory of JVM: 124194640B
</code></pre>]]></content>
      <categories>
        <category>计算机系统</category>
      </categories>
  </entry>
  <entry>
    <title>Eclipse配置Tomcat创建Servlet</title>
    <url>/blog/ro0lgm/</url>
    <content><![CDATA[<h2 id="一、Eclipse-的下载与安装与使用"><a href="#一、Eclipse-的下载与安装与使用" class="headerlink" title="一、Eclipse 的下载与安装与使用"></a>一、Eclipse 的下载与安装与使用</h2><p><a href="https://www.eclipse.org/downloads/" target="_blank" rel="noopener">下载地址</a><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685043597-84e5ed4c-8ad9-496b-997d-fd84136d0a86.png#align=left&amp;display=inline&amp;height=441&amp;margin=%5Bobject%20Object%5D&amp;originHeight=441&amp;originWidth=1817&amp;size=0&amp;status=done&amp;style=none&amp;width=1817" alt></p>
<p><strong>注意不要下错版本，不然开发不了 web 环境</strong><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685043623-2432fa56-57df-4b19-bbcf-d7f803db63d3.png#align=left&amp;display=inline&amp;height=758&amp;margin=%5Bobject%20Object%5D&amp;originHeight=758&amp;originWidth=731&amp;size=0&amp;status=done&amp;style=none&amp;width=731" alt><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685043608-ed00c908-2eb3-4a07-bcd4-c93a58aed494.png#align=left&amp;display=inline&amp;height=763&amp;margin=%5Bobject%20Object%5D&amp;originHeight=763&amp;originWidth=741&amp;size=0&amp;status=done&amp;style=none&amp;width=741" alt><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685043479-aac1b3ff-f51d-4dce-8313-4e10d2e78bbb.png#align=left&amp;display=inline&amp;height=373&amp;margin=%5Bobject%20Object%5D&amp;originHeight=373&amp;originWidth=762&amp;size=0&amp;status=done&amp;style=none&amp;width=762" alt></p>
<h2 id="二、Tomcat-的下载与配置"><a href="#二、Tomcat-的下载与配置" class="headerlink" title="二、Tomcat 的下载与配置"></a>二、Tomcat 的下载与配置</h2><p><a href="https://tomcat.apache.org/download-90.cgi" target="_blank" rel="noopener">下载地址</a><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685043712-245a08a5-48cd-4446-ae4b-2ac442f09a44.png#align=left&amp;display=inline&amp;height=729&amp;margin=%5Bobject%20Object%5D&amp;originHeight=729&amp;originWidth=1829&amp;size=0&amp;status=done&amp;style=none&amp;width=1829" alt><br><strong>一直下一步即可</strong><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685043478-1e8b6460-5b48-424e-8f2d-db26d6bbce42.png#align=left&amp;display=inline&amp;height=485&amp;margin=%5Bobject%20Object%5D&amp;originHeight=485&amp;originWidth=623&amp;size=0&amp;status=done&amp;style=none&amp;width=623" alt><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685043417-e391db44-2cd9-4c7c-8e6b-1f131ab95769.png#align=left&amp;display=inline&amp;height=283&amp;margin=%5Bobject%20Object%5D&amp;originHeight=283&amp;originWidth=624&amp;size=0&amp;status=done&amp;style=none&amp;width=624" alt></p>
<p>打开浏览器 键入 <a href="http://localhost:8080" target="_blank" rel="noopener">http://localhost:8080</a> 进入页面则表示安装成功</p>
<p>添加环境变量，以下全在系统环境变量下配置<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685043418-feddef63-fcb3-45ce-ac5a-33dd94d77655.png#align=left&amp;display=inline&amp;height=450&amp;margin=%5Bobject%20Object%5D&amp;originHeight=450&amp;originWidth=1089&amp;size=0&amp;status=done&amp;style=none&amp;width=1089" alt><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685043499-20fddab9-abfb-4d0d-9c6d-956933ee59be.png#align=left&amp;display=inline&amp;height=24&amp;margin=%5Bobject%20Object%5D&amp;originHeight=24&amp;originWidth=704&amp;size=0&amp;status=done&amp;style=none&amp;width=704" alt></p>
<pre><code>TOMCAT_HOME：C:\Program Files\Apache Software Foundation\Tomcat 9.0
CATALINA_BASE：C:\Program Files\Apache Software Foundation\Tomcat 9.0;
CATALINA_HOME：C:\Program Files\Apache Software Foundation\Tomcat 9.0;
在classpath当中加入%CATALINA_HOME%\common\lib\servlet-api.jar;
在path中加入%CATALINA_HOME%\bin;
</code></pre><p>打开浏览器 键入 <a href="http://localhost:8080" target="_blank" rel="noopener">http://localhost:8080</a> 进入页面则表示配置成功</p>
<h2 id="三、Eclipse-配置-Tomcat"><a href="#三、Eclipse-配置-Tomcat" class="headerlink" title="三、Eclipse 配置 Tomcat"></a>三、Eclipse 配置 Tomcat</h2><p><strong>让 Tomcat 服务器显示在控制台上，将 Web 应用部署到 Tomcat 中</strong></p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685043589-c8022021-1185-4c41-b114-630856e16984.png#align=left&amp;display=inline&amp;height=350&amp;margin=%5Bobject%20Object%5D&amp;originHeight=350&amp;originWidth=1837&amp;size=0&amp;status=done&amp;style=none&amp;width=1837" alt><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685043661-236843dd-f3ea-433e-b23a-254cc0a41c9b.png#align=left&amp;display=inline&amp;height=958&amp;margin=%5Bobject%20Object%5D&amp;originHeight=958&amp;originWidth=1217&amp;size=0&amp;status=done&amp;style=none&amp;width=1217" alt><br>点击<code>Window</code> → <code>Show View</code> → <code>Servers</code> 也可以在控制台点击<code>Servers</code><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685043514-556e9b3f-1003-40ff-9066-70349be51101.png#align=left&amp;display=inline&amp;height=790&amp;margin=%5Bobject%20Object%5D&amp;originHeight=790&amp;originWidth=1600&amp;size=0&amp;status=done&amp;style=none&amp;width=1600" alt><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685043568-aa8984a7-e9e9-4206-a922-f3386127191d.png#align=left&amp;display=inline&amp;height=597&amp;margin=%5Bobject%20Object%5D&amp;originHeight=597&amp;originWidth=597&amp;size=0&amp;status=done&amp;style=none&amp;width=597" alt><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685043484-23195297-3636-47d7-bf44-ee0151382f87.png#align=left&amp;display=inline&amp;height=766&amp;margin=%5Bobject%20Object%5D&amp;originHeight=766&amp;originWidth=1478&amp;size=0&amp;status=done&amp;style=none&amp;width=1478" alt><br><strong>双击点击</strong><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685043403-e34d7544-8144-4516-bb7c-53adbabac167.png#align=left&amp;display=inline&amp;height=290&amp;margin=%5Bobject%20Object%5D&amp;originHeight=290&amp;originWidth=1375&amp;size=0&amp;status=done&amp;style=none&amp;width=1375" alt></p>
<h2 id="四、Eclipse-使用-Servlet"><a href="#四、Eclipse-使用-Servlet" class="headerlink" title="四、Eclipse 使用 Servlet"></a>四、Eclipse 使用 Servlet</h2><h3 id="创建-web-工程"><a href="#创建-web-工程" class="headerlink" title="创建 web 工程"></a>创建 web 工程</h3><p><strong>创建过程中，要记得勾选生成 web.xml 文件选项</strong><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685043545-0429f9cf-3910-4401-85da-08dd0118e9b1.png#align=left&amp;display=inline&amp;height=277&amp;margin=%5Bobject%20Object%5D&amp;originHeight=277&amp;originWidth=1838&amp;size=0&amp;status=done&amp;style=none&amp;width=1838" alt><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685043538-d98f2569-40d6-4c3a-8111-9c3d6702052a.png#align=left&amp;display=inline&amp;height=382&amp;margin=%5Bobject%20Object%5D&amp;originHeight=382&amp;originWidth=820&amp;size=0&amp;status=done&amp;style=none&amp;width=820" alt></p>
<h3 id="添加相关文件"><a href="#添加相关文件" class="headerlink" title="添加相关文件"></a>添加相关文件</h3><p><strong>添加下面的四个文件</strong><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685043712-c178c180-3c3a-44a2-9518-671033558337.png#align=left&amp;display=inline&amp;height=1015&amp;margin=%5Bobject%20Object%5D&amp;originHeight=1015&amp;originWidth=1831&amp;size=0&amp;status=done&amp;style=none&amp;width=1831" alt></p>
<blockquote>
<p>HelloWordServlet.java</p>
</blockquote>
<pre><code class="java">package cn.itcast.firstmyapp.servlet;

import java.io.IOException;
import java.io.PrintWriter;

import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

public class HelloWordServlet extends HttpServlet {

     protected void doGet(HttpServletRequest req, HttpServletResponse resp)
                throws ServletException, IOException {

         System.out.println(&quot;接受了客户端的请求----------------------------------------------------&quot;);
         // 设置响应类型:
            resp.setContentType(&quot;text/html&quot;);
            // 获取输出流:
            PrintWriter pw = resp.getWriter();
            // 写入响应:
            pw.write(&quot;&lt;h1&gt;Hello, world!&lt;/h1&gt;&quot;);
            // 最后不要忘记flush强制输出:
            pw.flush();
        }

}
</code></pre>
<blockquote>
<p>web.xml<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685043517-5459e979-8525-4be9-8dab-d38f0857ef56.png#align=left&amp;display=inline&amp;height=627&amp;margin=%5Bobject%20Object%5D&amp;originHeight=627&amp;originWidth=1178&amp;size=0&amp;status=done&amp;style=none&amp;width=1178" alt></p>
</blockquote>
<h3 id="运行并查看结果"><a href="#运行并查看结果" class="headerlink" title="运行并查看结果"></a>运行并查看结果</h3><p><strong>运行</strong><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685043718-5d90186b-8040-4098-b1d4-bb1f67740382.png#align=left&amp;display=inline&amp;height=761&amp;margin=%5Bobject%20Object%5D&amp;originHeight=761&amp;originWidth=1434&amp;size=0&amp;status=done&amp;style=none&amp;width=1434" alt><br>然后查看 console 部分<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685043524-efeaf228-713b-43e1-ba15-375060ef20d2.png#align=left&amp;display=inline&amp;height=300&amp;margin=%5Bobject%20Object%5D&amp;originHeight=300&amp;originWidth=1449&amp;size=0&amp;status=done&amp;style=none&amp;width=1449" alt><br><strong>服务器响应情况</strong></p>
<blockquote>
<p>出现下图则说明成功<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685043360-fd5bb570-f56a-429a-ad0e-627646447132.png#align=left&amp;display=inline&amp;height=190&amp;margin=%5Bobject%20Object%5D&amp;originHeight=190&amp;originWidth=1318&amp;size=0&amp;status=done&amp;style=none&amp;width=1318" alt></p>
</blockquote>
<blockquote>
<p>还可以回到控制台查看请求成功情况<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685043568-b62922c0-c458-4c71-bd9c-800f57b356de.png#align=left&amp;display=inline&amp;height=322&amp;margin=%5Bobject%20Object%5D&amp;originHeight=322&amp;originWidth=1445&amp;size=0&amp;status=done&amp;style=none&amp;width=1445" alt></p>
</blockquote>
<h2 id="五、过程中出现的问题"><a href="#五、过程中出现的问题" class="headerlink" title="五、过程中出现的问题"></a>五、过程中出现的问题</h2><h3 id="IDEA-上的部署"><a href="#IDEA-上的部署" class="headerlink" title="IDEA 上的部署"></a>IDEA 上的部署</h3><p>一开始从 tomcat 部署是完成的，具体参考我的 csdn 一篇小文章<a href="https://blog.csdn.net/ZTlink1013/article/details/104815639" target="_blank" rel="noopener">地址</a>。但是在后面使用 Servlet 的时候，不能成功部署，具体原因【图片内容来自<a href="https://blog.csdn.net/HughGilbert/article/details/56424137" target="_blank" rel="noopener">链接</a>！！】<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685043902-5708dbdc-79d7-4e16-9e6d-d5571c5de758.png#align=left&amp;display=inline&amp;height=921&amp;margin=%5Bobject%20Object%5D&amp;originHeight=921&amp;originWidth=941&amp;size=0&amp;status=done&amp;style=stroke&amp;width=941" alt></p>
<blockquote>
<p>暂时分析：是和 idea 下的根目录下的某个配置文件的默认配置有关，需要更改相关内容，暂时不折腾了。先记录下，有空再折腾，先学习。还是 eclipse 好配置···</p>
</blockquote>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul>
<li><a href="https://blog.csdn.net/weixin_34026276/article/details/93834823?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task" target="_blank" rel="noopener">https://blog.csdn.net/weixin_34026276/article/details/93834823?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task</a></li>
<li><a href="https://blog.csdn.net/qq_38190185/article/details/88198794?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task" target="_blank" rel="noopener">https://blog.csdn.net/qq_38190185/article/details/88198794?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task</a></li>
<li><a href="https://www.yiibai.com/servlet/creating-servlet-in-eclipse-ide.html" target="_blank" rel="noopener">直接创建 Servlet</a></li>
<li>快捷键：<a href="https://www.open-open.com/bbs/view/1320934157953" target="_blank" rel="noopener">https://www.open-open.com/bbs/view/1320934157953</a></li>
</ul>
]]></content>
      <categories>
        <category>Environment</category>
      </categories>
  </entry>
  <entry>
    <title>数据库中的函数</title>
    <url>/blog/sbxidb/</url>
    <content><![CDATA[<h1 id="字符（串）函数"><a href="#字符（串）函数" class="headerlink" title="字符（串）函数"></a>字符（串）函数</h1><p>函数可以在 MySQL 提示符中，直接用 SELECT 语句测试。<br>比如 <strong>SELECT USER();</strong></p>
<h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><ul>
<li>字符函数</li>
<li>数值运算符与函数</li>
<li>比较运算符与函数</li>
<li>日期时间函数</li>
<li>信息函数</li>
<li>聚合函数</li>
<li>加密函数</li>
</ul>
<h2 id="字符（串）函数-1"><a href="#字符（串）函数-1" class="headerlink" title="字符（串）函数"></a>字符（串）函数</h2><table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>CONCAT</td>
<td>字符串连接</td>
</tr>
<tr>
<td>CONCAT_WS</td>
<td>同上，但指定连接符</td>
</tr>
<tr>
<td>FORMAT</td>
<td>数字格式化</td>
</tr>
<tr>
<td>LOWER</td>
<td>转换成小写字母</td>
</tr>
<tr>
<td>UPPER</td>
<td>转换成大写字母</td>
</tr>
<tr>
<td>LEFT</td>
<td>获取左侧字符</td>
</tr>
<tr>
<td>RIGHT</td>
<td>获取右侧字符</td>
</tr>
<tr>
<td>LENGTH</td>
<td>获取长度</td>
</tr>
<tr>
<td>LTRIM</td>
<td>删除前导空格</td>
</tr>
<tr>
<td>RTRIM</td>
<td>删除后续空格</td>
</tr>
<tr>
<td>TRIM</td>
<td>删除前后空格</td>
</tr>
<tr>
<td>SUBSTRING</td>
<td>字符串截取</td>
</tr>
<tr>
<td>[NOT] LIKE</td>
<td>模式匹配</td>
</tr>
<tr>
<td>REPEAT</td>
<td>重复字符串</td>
</tr>
<tr>
<td>REPLACE</td>
<td>字符串替换</td>
</tr>
</tbody>
</table>
<h3 id="CONCAT"><a href="#CONCAT" class="headerlink" title="CONCAT"></a>CONCAT</h3><p>参数个数不限，连接成一个字符串<br>已知 test 表的内如如下：</p>
<pre><code>+----+------------+-----------+
| id | first_name | last_name |
+----+------------+-----------+
|  1 | A          | B         |
|  2 | C          | D         |
|  3 | tom%       | 123       |
|  4 | NULL       | 11        |
|  5 | 11         | 22        |
|  6 | AA         | BB        |
|  7 | CC         | DD        |
+----+------------+-----------+
</code></pre><p>test 表中有两个字段 first_name,和 last_name，调用连接函数之后：</p>
<pre><code class="mysql">SELECT CONCAT(first_name,last_name)AS full_name FROM test;

+-----------+
| full_name |
+-----------+
| AB        |
| CD        |
| tom%123   |
| NULL      |
| 1122      |
| AABB      |
| CCDD      |
+-----------+
</code></pre>
<h3 id="CONCAT-WS"><a href="#CONCAT-WS" class="headerlink" title="CONCAT_WS"></a>CONCAT_WS</h3><p>参数至少有三个，第一参数为要连接字符串的分隔符，后面的都是待连接的字符串。</p>
<pre><code class="mysql">SELECT CONCAT_WS(&#39;-&#39;,1992,10,17);

+---------------------------+
| CONCAT_WS(&#39;-&#39;,1992,10,17) |
+---------------------------+
| 1992-10-17                |
+---------------------------+
</code></pre>
<h3 id="FORMAT"><a href="#FORMAT" class="headerlink" title="FORMAT"></a>FORMAT</h3><p>将数字格式化为字符串。第二个参数为小数的位数。</p>
<pre><code class="mysql">SELECT FORMAT(12345.67,2);
</code></pre>
<p>结果为千分位:</p>
<pre><code>+--------------------+
| FORMAT(12345.67,2) |
+--------------------+
| 12,345.67          |
+--------------------+
</code></pre><h3 id="LOWER-UPPER"><a href="#LOWER-UPPER" class="headerlink" title="LOWER/UPPER"></a>LOWER/UPPER</h3><p>顾名思义，不再解释</p>
<h3 id="LEFT-RIGHT"><a href="#LEFT-RIGHT" class="headerlink" title="LEFT/RIGHT"></a>LEFT/RIGHT</h3><p>获取左（右）侧第几个字符。</p>
<pre><code>SELECT LEFT(&#39;MySQL&#39;,2);
</code></pre><h3 id="LENGTH"><a href="#LENGTH" class="headerlink" title="LENGTH"></a>LENGTH</h3><p>获取字符串长度。SQL Server 中是 len 函数。MySQL 中没有 len 函数。</p>
<h3 id="LTRIM-RTRIM"><a href="#LTRIM-RTRIM" class="headerlink" title="LTRIM/RTRIM"></a>LTRIM/RTRIM</h3><p>删除前导/后续空格</p>
<h3 id="SUBSTRING"><a href="#SUBSTRING" class="headerlink" title="SUBSTRING"></a>SUBSTRING</h3><p>与其他语言中一样，截取子串的三个参数分别为：</p>
<ul>
<li>原字符串</li>
<li>起始位置（注意下标从 1 算起；可以为负数，即从右数起）</li>
<li>截取长度（缺省为截取到结尾）</li>
</ul>
<h3 id="NOT-LIKE"><a href="#NOT-LIKE" class="headerlink" title="[NOT] LIKE"></a>[NOT] LIKE</h3><pre><code>SELECT FROM &#39;MySQL&#39; LIKE &#39;M%&#39;;
</code></pre><p>结果为 1，即 true。</p>
<ul>
<li>%代表 0 个或多个字符。</li>
<li>_代表任意一个字符。</li>
</ul>
<blockquote>
<p>关于转义<br>当要匹配的字符中含有特殊字符(比如%)时，需要转义。\，貌似\也可以<br>SELECT CONCAT(first_name,last_name)AS full_name FROM test WHERE first_name LIKE’%%’;</p>
</blockquote>
<p>也可以自己指定<br>SELECT CONCAT(first_name,last_name)AS full_name FROM test WHERE first_name LIKE’%1%’ ESCAPE ‘1’;</p>
<h3 id="TRIM"><a href="#TRIM" class="headerlink" title="TRIM"></a>TRIM</h3><p>缺省可以删除前后空格，也可以删除指定的字符。</p>
<pre><code class="mysql">-- 删除??MySQL???前面的？
SELECT TRIM(LEADING &#39;?&#39; FROM &#39;??MySQL???&#39;);
-- 删除后面的？
SELECT TRIM(TRAILING &#39;?&#39; FROM &#39;??MySQL???&#39;);
-- 删除前后的？
SELECT TRIM(BOTH &#39;?&#39; FROM &#39;??MySQL???&#39;);
</code></pre>
<h3 id="REPEAT"><a href="#REPEAT" class="headerlink" title="REPEAT"></a>REPEAT</h3><p>重复某一字符串多少次</p>
<pre><code class="mysql">SELECT REPEAT(&#39;ab&#39;,2);
</code></pre>
<p>结果是：</p>
<pre><code>+----------------+
| REPEAT(&#39;ab&#39;,2) |
+----------------+
| abab           |
+----------------+
</code></pre><h3 id="REPLACE"><a href="#REPLACE" class="headerlink" title="REPLACE"></a>REPLACE</h3><pre><code class="mysql">-- 去掉所有的？
SELECT REPLACE(&#39;??MySQL&#39;,&#39;?&#39;,&#39;&#39;);
</code></pre>
<p>注意！替换的时候也可以一换多，多换一。</p>
<h1 id="数值运算和比较运算"><a href="#数值运算和比较运算" class="headerlink" title="数值运算和比较运算"></a>数值运算和比较运算</h1><h2 id="数值运算"><a href="#数值运算" class="headerlink" title="数值运算"></a>数值运算</h2><table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>CEIL()</td>
<td>进一取整</td>
</tr>
<tr>
<td>DIV</td>
<td>整数除法</td>
</tr>
<tr>
<td>FLOOR()</td>
<td>舍一取整</td>
</tr>
<tr>
<td>MOD</td>
<td>模运算</td>
</tr>
<tr>
<td>POWER()</td>
<td>幂运算</td>
</tr>
<tr>
<td>ROUND()</td>
<td>四舍五入</td>
</tr>
<tr>
<td>TRUNCARE()</td>
<td>数字截取</td>
</tr>
</tbody>
</table>
<h3 id="CEIL-FLOOR-ROUND"><a href="#CEIL-FLOOR-ROUND" class="headerlink" title="CEIL/FLOOR/ROUND"></a>CEIL/FLOOR/ROUND</h3><p>前两者为对应操作。一个向上取整，一个向下取整。第三个 ROUND 为四舍五入。</p>
<h3 id="DIV-MOD"><a href="#DIV-MOD" class="headerlink" title="DIV/MOD"></a>DIV/MOD</h3><p>两者并非函数，而是 <strong>运算符</strong>。</p>
<pre><code class="mysql">SELECT 5 DIV 2;
SELECT 7 MOD 3;
</code></pre>
<p>MOD 与%等价，就是模运算，与别不同的是，MySQL 中支持浮点数取模。</p>
<h3 id="POWER"><a href="#POWER" class="headerlink" title="POWER"></a>POWER</h3><p>幂运算</p>
<h3 id="TRUNCARE"><a href="#TRUNCARE" class="headerlink" title="TRUNCARE"></a>TRUNCARE</h3><p>所谓的数字截取，就是对数字逐位的截断。</p>
<pre><code class="mysql">SELECT TRUNCATE(125.123, 1);
SELECT TRUNCATE(125.123, 0);
SELECT TRUNCATE(125.123, - 1);
</code></pre>
<h2 id="运算的结果分别为：125-1、125-0-120"><a href="#运算的结果分别为：125-1、125-0-120" class="headerlink" title="运算的结果分别为：125.1、125.0,120"></a>运算的结果分别为：125.1、125.0,120</h2><h2 id="比较运算符与函数"><a href="#比较运算符与函数" class="headerlink" title="比较运算符与函数"></a>比较运算符与函数</h2><table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>[NOT] BETWEEN…AND…</td>
<td>[不]在范围内</td>
</tr>
<tr>
<td>[NOT] IN()</td>
<td>[不]在列出的值范围内</td>
</tr>
<tr>
<td>IS [NOT] NULL</td>
<td>[不]为空</td>
</tr>
</tbody>
</table>
<h1 id="日期时间函数"><a href="#日期时间函数" class="headerlink" title="日期时间函数"></a>日期时间函数</h1><table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>NOW()</td>
<td>当前日期和时间</td>
</tr>
<tr>
<td>CURDATE()</td>
<td>当前日期</td>
</tr>
<tr>
<td>CURTIME()</td>
<td>当前时间</td>
</tr>
<tr>
<td>DATE_ADD()</td>
<td>日期变化</td>
</tr>
<tr>
<td>DATEDIFF()</td>
<td>日期差值</td>
</tr>
<tr>
<td>DATE_FORMATE()</td>
<td>日期格式化</td>
</tr>
</tbody>
</table>
<h3 id="NOW-CURDATE-CURTIME"><a href="#NOW-CURDATE-CURTIME" class="headerlink" title="NOW/CURDATE/CURTIME"></a>NOW/CURDATE/CURTIME</h3><p>可以把 NOW 看作是 CURDATE 和 CURTIME 的综合</p>
<h3 id="DATE-ADD"><a href="#DATE-ADD" class="headerlink" title="DATE_ADD"></a>DATE_ADD</h3><p>实现日志的增减，加为正数，减为负数</p>
<pre><code class="mysql">SELECT DATE_ADD(CURDATE(),INTERVAL 3 WEEK);
</code></pre>
<p>WEEK,也可以是 DAY，YEAR<br>与之相对的还有一个 DATE_SUB 函数。</p>
<h3 id="DATEDIFF"><a href="#DATEDIFF" class="headerlink" title="DATEDIFF"></a>DATEDIFF</h3><p>获取两个日期之间的差值，左边减去右边，值为天数。</p>
<pre><code class="mysql">SELECT DATEDIFF(&#39;2014-10-11&#39;,&#39;2014-09-06&#39;);
</code></pre>
<h3 id="DATE-FORMAT"><a href="#DATE-FORMAT" class="headerlink" title="DATE_FORMAT()"></a>DATE_FORMAT()</h3><p>日期格式化为其他形式，比如：</p>
<pre><code class="mysql">SELECT DATE_FORMAT(&#39;2014-11-01&#39;,&#39;%m/%d/%Y&#39;);
</code></pre>
<p>结果为：<br>11/01/2014<br>如果是小写的 y，则格式化为 11/01/14</p>
<h1 id="信息函数"><a href="#信息函数" class="headerlink" title="信息函数"></a>信息函数</h1><table>
<thead>
<tr>
<th>名称</th>
<th>函数</th>
</tr>
</thead>
<tbody>
<tr>
<td>CONNECTIOIN_ID</td>
<td>连接 ID</td>
</tr>
<tr>
<td>DATABASE</td>
<td>当前数据库</td>
</tr>
<tr>
<td>LAST_INSERT_ID</td>
<td>最后插入记录 ID</td>
</tr>
<tr>
<td>USER</td>
<td>当前用户</td>
</tr>
<tr>
<td>VERSION</td>
<td>版本信息</td>
</tr>
</tbody>
</table>
<h3 id="CONNECTION-ID"><a href="#CONNECTION-ID" class="headerlink" title="CONNECTION_ID"></a>CONNECTION_ID</h3><p>第一连接就是 1，以此类推。</p>
<h3 id="DATABASE"><a href="#DATABASE" class="headerlink" title="DATABASE"></a>DATABASE</h3><h3 id="LAST-INSERT-ID"><a href="#LAST-INSERT-ID" class="headerlink" title="LAST_INSERT_ID"></a>LAST_INSERT_ID</h3><p>当一条语句插入多条记录的时候，它只返回第一条记录的 ID。</p>
<h3 id="USER"><a href="#USER" class="headerlink" title="USER"></a>USER</h3><p>返回当前用户。MYSQL 中的用户的完整用户名是 <strong>用户名@登录主机</strong></p>
<h3 id="VERSION"><a href="#VERSION" class="headerlink" title="VERSION"></a>VERSION</h3><p>MySQL 版本号</p>
<h1 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h1><table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>AVG</td>
<td>平均值</td>
</tr>
<tr>
<td>COUNT</td>
<td>计数</td>
</tr>
<tr>
<td>MAX</td>
<td>最大值</td>
</tr>
<tr>
<td>MIN</td>
<td>最小值</td>
</tr>
<tr>
<td>SUM</td>
<td>求和</td>
</tr>
</tbody>
</table>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ul>
<li>聚合函数只有一个返回值！</li>
<li>不能直接用 SELECT 加函数名的形式来调用，必须针对字段！</li>
<li>优先级<ul>
<li>聚合函数优先级小于 WHERE 语句，不能用来 WHERE 后面。</li>
<li>聚合函数优先级大于 HAVING，可以用在 HAVING 后面。</li>
</ul>
</li>
</ul>
<h2 id="COUNT"><a href="#COUNT" class="headerlink" title="COUNT"></a>COUNT</h2><ul>
<li>COUNT(*)统计 null</li>
<li>COUNT(字段)不统计 null</li>
<li>COUNT(1)可统计</li>
</ul>
<h1 id="自定义函数"><a href="#自定义函数" class="headerlink" title="自定义函数"></a>自定义函数</h1><p>UDF(User-defined function)</p>
<h2 id="创建自定义函数"><a href="#创建自定义函数" class="headerlink" title="创建自定义函数"></a>创建自定义函数</h2><pre><code class="mysql">CREATE FUCNTION function_name
RETURNS
{STRING|INTEGER|REAL|DECIMAL}
RETURN
routine_body
</code></pre>
<h2 id="函数体"><a href="#函数体" class="headerlink" title="函数体"></a>函数体</h2><p>上面的 routine_body 指代函数体。其构成：</p>
<ul>
<li>函数体由合法的 SQL 语句构成</li>
<li>函数体可以是简单的 SELECT 或 INSERT 语句</li>
<li>函数体如果为符合结构则使用 BEGIN…END 语句</li>
<li>符合结构可以包含声明，循环，控制结构</li>
</ul>
<h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><p><code>来源慕课网</code></p>
<pre><code class="mysql">-- 无参数
CREATE function f()
RETURNS VARCHAR(30)
  RETURN Date_format(Now(), &#39;%Y年%m月%d日 %H点：%i分：%s秒&#39;);
</code></pre>
<pre><code class="mysql">-- 带参数
CREATE function f2(num1 SMALLINT UNSIGNED,
                   num2 SMALLINT UNSIGNED)
RETURNS FLOAT(10, 2) UNSIGNED
  RETURN ( num1 + num2 ) / 2;
</code></pre>
<pre><code>--  复合结构的函数体
DELIMITER //
CREATE function
  adduser(username VARCHAR(20)) returns INT UNSIGNED
BEGIN
  INSERT test
         (
                username
         )
         VALUES
         (
                username
         );

  RETURN Last_insert_id();
END//
</code></pre><p>三个要点：</p>
<ul>
<li>首先因为函数体内有分号，所以我们要修改定界符，避免函数中途停止。使用 DELIMITER 指定新的定界符为//。</li>
<li>然后，因为函数体内有多条 SQL 语句，所以我们要用 BEGIN…END 包裹。</li>
<li>RETURN 在 BEGIN…END 结构内部。并且必须有 RETURN。默认情况下，RETURN 后面的语句会在屏幕上打印出来。</li>
</ul>
<h2 id="删除函数"><a href="#删除函数" class="headerlink" title="删除函数"></a>删除函数</h2><pre><code class="mysql">DROP FUCNTION [IF EXISTS] function_name;
</code></pre>
<p>一次只能删除一个函数。</p>
<h1 id="加密函数"><a href="#加密函数" class="headerlink" title="加密函数"></a>加密函数</h1><table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>MD5</td>
<td>信息摘要算法</td>
</tr>
<tr>
<td>PASSWORD</td>
<td>密码算法</td>
</tr>
</tbody>
</table>
<p>用于 WEB 页面用 MD5 算法保存用户密码<br>用户本地用户，用 PASSWORD 修改密码。比如</p>
<pre><code class="sql">UPDATE user SET Password=PASSWORD(&#39;newpassword&#39;) where USER=&#39;root&#39;;
</code></pre>
<p>注意 user 表在系统数据库 mysql 下。执行命令之前请<code>USE mysql</code>。</p>
]]></content>
      <categories>
        <category>Language</category>
      </categories>
  </entry>
  <entry>
    <title>JavaWeb学习笔记</title>
    <url>/blog/tb3der/</url>
    <content><![CDATA[<h1 id="【第二章】JavaWeb-概述"><a href="#【第二章】JavaWeb-概述" class="headerlink" title="【第二章】JavaWeb 概述"></a>【第二章】JavaWeb 概述</h1><h2 id="一、XML"><a href="#一、XML" class="headerlink" title="一、XML"></a>一、XML</h2><p><code>XML</code>  是一种标记性语言，但是不同于 <code>HTML</code> ，目的其实就是用于传输数据，但是 <code>HTML</code>  的目的可以理解为展示</p>
<blockquote>
<p>网站建好之后，需要将自己的文章链接提交到百度/谷歌，通过部署生成的<code>baidusitemap.xml</code>和<code>sitemap.xml</code>文件，sitemap 提交方式提交以达到目的。</p>
</blockquote>
<h3 id="XML-语法"><a href="#XML-语法" class="headerlink" title="XML 语法"></a>XML 语法</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598670375381-0e3b13a8-6a22-47fb-8e8f-32c203fbf25d.png#align=left&amp;display=inline&amp;height=207&amp;margin=%5Bobject%20Object%5D&amp;originHeight=388&amp;originWidth=866&amp;size=0&amp;status=done&amp;style=shadow&amp;width=461" alt></p>
<ul>
<li>文档声明：图中最上面一行</li>
<li>元素定义：形式相当于 <code>HTML</code>  当中的标签，但不是标签，有根元素（一般只有一个），空元素等之分</li>
<li>属性定义：其中值需要用双引号或者单引号括起来</li>
<li>注释：和 <code>HTML</code>  一样</li>
</ul>
<h3 id="DTD-和-Schema-约束"><a href="#DTD-和-Schema-约束" class="headerlink" title="DTD 和 Schema 约束"></a>DTD 和 Schema 约束</h3><p>有些时候文档内可能内容语义有歧义，所以需要对其 xml 文件内容尽可能的加以约束，DTD 和 Schema 两种方式</p>
<h2 id="二、HTTP-协议"><a href="#二、HTTP-协议" class="headerlink" title="二、HTTP 协议"></a>二、HTTP 协议</h2><blockquote>
<p>生成的 web 项目和服务器之间的传输协议</p>
</blockquote>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598670375263-a1f1c0c1-0d94-4f9d-97ed-9d8e7e1d2495.png#align=left&amp;display=inline&amp;height=127&amp;margin=%5Bobject%20Object%5D&amp;originHeight=127&amp;originWidth=305&amp;size=0&amp;status=done&amp;style=shadow&amp;width=305" alt></p>
<blockquote>
<p>其中 http1.1 版本比 1.0 版本优化的是对 http 请求可以同时进行多个请求和响应</p>
</blockquote>
<h3 id="HTTP-请求消息"><a href="#HTTP-请求消息" class="headerlink" title="HTTP 请求消息"></a>HTTP 请求消息</h3><blockquote>
<p>客户端（web 浏览器）向服务器发送请求，通常由请求行、请求头、实体内容三部分组成</p>
</blockquote>
<ul>
<li>请求行：请求方式，资源路径，http 协议版本三部分组成。请求方式又有 GET（所请求内容会在资源路径后面带上参数值，会有大小限制）和 POST（安全，无大小限制）等方式</li>
</ul>
<h3 id="HTTP-响应消息"><a href="#HTTP-响应消息" class="headerlink" title="HTTP 响应消息"></a>HTTP 响应消息</h3><blockquote>
<p>也由三部分组成，有资源状态行、响应消息头、实体内容</p>
</blockquote>
<ul>
<li>资源状态行：协议版本 状态码 状态描述三部分组成。其中状态码有多种，常见的 404 就是服务器找不到相应请求的的资源</li>
</ul>
<h2 id="三、Tomcat"><a href="#三、Tomcat" class="headerlink" title="三、Tomcat"></a>三、Tomcat</h2><h3 id="关于-Tomcat"><a href="#关于-Tomcat" class="headerlink" title="关于 Tomcat"></a>关于 Tomcat</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598670375411-c8675707-4396-48f4-b181-07310231b868.png#align=left&amp;display=inline&amp;height=174&amp;margin=%5Bobject%20Object%5D&amp;originHeight=250&amp;originWidth=844&amp;size=0&amp;status=done&amp;style=shadow&amp;width=588" alt></p>
<h3 id="下载安装-Tomcat"><a href="#下载安装-Tomcat" class="headerlink" title="下载安装 Tomcat"></a>下载安装 Tomcat</h3><p>安装等方式参考博客 <a href="https://blog.csdn.net/ZTlink1013/article/details/104815639" target="_blank" rel="noopener">https://blog.csdn.net/ZTlink1013/article/details/104815639</a></p>
<h2 id="四、Web-应用"><a href="#四、Web-应用" class="headerlink" title="四、Web 应用"></a>四、Web 应用</h2><h3 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h3><blockquote>
<p>web 应用，就是一项工程，在编写 web 项目过程中，对文件按照“合乎规矩”的方式放置</p>
</blockquote>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598670375598-ac6ece9f-6982-4a1d-a7d8-bc3c8b4ce0f7.png#align=left&amp;display=inline&amp;height=352&amp;margin=%5Bobject%20Object%5D&amp;originHeight=614&amp;originWidth=830&amp;size=0&amp;status=done&amp;style=shadow&amp;width=476" alt></p>
<h3 id="IDEA-配置-Tomcat"><a href="#IDEA-配置-Tomcat" class="headerlink" title="IDEA 配置 Tomcat"></a>IDEA 配置 Tomcat</h3><p>搭建 web 开发环境</p>
<p>资源的访问，点击请求的页面跳转设置<code>web.xml</code>中配置</p>
<blockquote>
<p>阮一峰的网站当中，有类似域名自动跳转，是否和域名解析有关呢？抑或是对 web.xml 进行了操作？</p>
</blockquote>
<p>对 idea 进行 web 开发 配置<a href="https://blog.csdn.net/ZTlink1013/article/details/104815639" target="_blank" rel="noopener">https://blog.csdn.net/ZTlink1013/article/details/104815639</a></p>
<h1 id="【第三章】Servlet"><a href="#【第三章】Servlet" class="headerlink" title="【第三章】Servlet"></a>【第三章】Servlet</h1><h2 id="一、什么是-Servlet"><a href="#一、什么是-Servlet" class="headerlink" title="一、什么是 Servlet"></a>一、什么是 Servlet</h2><h3 id="什么是-Servlet"><a href="#什么是-Servlet" class="headerlink" title="什么是 Servlet"></a>什么是 Servlet</h3><blockquote>
<p>Servlet 就是在服务器端的 Java 接口或者说是类（叫法有狭义广义之分），处理客户端传来的请求并作出相应的响应这么一个网络模块。</p>
</blockquote>
<ul>
<li>请求：客户端传来的调用或是一系列行为，同时也包含了请求所需要的数据。</li>
<li>响应：服务器根据客户端传来的请求做出响应，实时的展示给客户端。这之中 Servlet 相当于 java 类当中的一个接口，以请求来的信息作为输入，然后进行分析，做出相应。</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598670486756-3febd732-e4ee-413d-8868-a406760f5a22.png#align=left&amp;display=inline&amp;height=134&amp;margin=%5Bobject%20Object%5D&amp;originHeight=222&amp;originWidth=783&amp;size=0&amp;status=done&amp;style=shadow&amp;width=472" alt></p>
<h3 id="JSP-和-Servlet"><a href="#JSP-和-Servlet" class="headerlink" title="JSP 和 Servlet"></a>JSP 和 Servlet</h3><blockquote>
<p>servlet 是控制层，jsp 转换为 servlet，用 servlet 来实现 http 请求。</p>
</blockquote>
<p>【1】JSP 第一次运行的时候会编译成 Servlet，驻留在内存中以供调用。</p>
<p>【2】JSP 是 web 开发技术，Servlet 是服务器端运用的小程序，我们访问一个 JSP 页面时，服务器会将这个 JSP 页面转变成 Servlet 小程序运行得到结果后，反馈给用户端的浏览器。</p>
<p>【3】Servlet 相当于一个控制层再去调用相应的 JavaBean 处理数据,最后把结果返回给 JSP。</p>
<p>【4】Servlet 主要用于转向，将请求转向到相应的 JSP 页面。</p>
<p>【5】JSP 更多的是进行页面显示，Servlet 更多的是处理业务，即 JSP 是页面，Servlet 是实现 JSP 的方法。</p>
<p>【6】Servlet 可以实现 JSP 的所有功能，但由于美工使用 Servlet 做界面非常困难，后来开发了 JSP。</p>
<p>【7】JSP 技术开发网站的两种模式：JSP + JavaBean；JSP + Servlet + JavaBean（一般在多层应用中, JSP 主要用作表现层,而 Servlet 则用作控制层,因为在 JSP 中放太多的代码不利于维护，而把这留给 Servlet 来实现,而大量的重复代码写在 JavaBean 中）。</p>
<p>【8】二者之间的差别就是，开发界面是 JSP 直接可以编写。</p>
<p>比如在 JSP 中写 Table 标记：<code>&lt;table&gt;[数据]&lt;/table&gt;；</code></p>
<p>Servlet 需要加入：<code>out.println(“&lt;table&gt;[数据]&lt;/table&gt;”)。</code></p>
<p>JSP 文件在被应用服务器(例如：Tomcat、Resin、Weblogic 和 Websphere),调用过之后，就被编译成为了 Servlet 文件。也就是说在网页上显示的其实是 Servlet 文件。Tomcat 下面 JSP 文件编译之后生成的 Servlet 文件被放在了 work 文件夹下，JSP 中的 HTML 代码在 Servlet 都被 out 出来，而 JSP 代码按照标签的不同会放在不同的位置。</p>
<p>【9】JSP 中嵌入 JAVA 代码，而 Servlet 中嵌入 HTML 代码。</p>
<p>【10】在一个标准的 MVC 架构中，Servlet 作为 Controller 接受用户请求并转发给相应的 Action 处理，JSP 作为 View 主要用来产生动态页面，EJB 作为 Model 实现你的业务代码。</p>
<h2 id="二、Servlet-基础"><a href="#二、Servlet-基础" class="headerlink" title="二、Servlet 基础"></a>二、Servlet 基础</h2><h3 id="接口及其实现类"><a href="#接口及其实现类" class="headerlink" title="接口及其实现类"></a>接口及其实现类</h3><p>就是利用其类编写相关服务器端的相关运行代码</p>
<h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p>分三个阶段：初始化阶段-&gt;运行阶段-&gt;销毁阶段</p>
<h3 id="HttpServlet-类"><a href="#HttpServlet-类" class="headerlink" title="HttpServlet 类"></a>HttpServlet 类</h3><p>一般客户端和服务器之间都回使用 <code>HTTP协议</code> ，所以 Servlet 接口中就提供了一个抽象类<code>javax.servlet.http.HttpServlet</code>，他是 <code>GernericServlet</code>  的一个子类，专门用来处理 <code>HTTP协议</code>  的 servlet；具体程序中就是用该类</p>
<blockquote>
<p>HelloWordServlet.java</p>
</blockquote>
<pre><code class="java">package cn.itcast.firstmyapp.servlet;

import java.io.IOException;
import java.io.PrintWriter;

import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

public class HelloWordServlet extends HttpServlet {

     protected void doGet(HttpServletRequest req, HttpServletResponse resp)
                throws ServletException, IOException {

         System.out.println(&quot;接受了客户端的请求-----------------------------&quot;);
         // 设置响应类型:
            resp.setContentType(&quot;text/html&quot;);
            // 获取输出流:
            PrintWriter pw = resp.getWriter();
            // 写入响应:
            pw.write(&quot;&lt;h1&gt;Hello, world!&lt;/h1&gt;&quot;);
            // 最后不要忘记flush强制输出:
            pw.flush();
        }

}
</code></pre>
<h2 id="三、Servlet-虚拟路径的映射"><a href="#三、Servlet-虚拟路径的映射" class="headerlink" title="三、Servlet 虚拟路径的映射"></a>三、Servlet 虚拟路径的映射</h2><h3 id="1-多重映射"><a href="#1-多重映射" class="headerlink" title="1. 多重映射"></a>1. 多重映射</h3><blockquote>
<p>就相当于多加几个自己指定的访问路径，在 web.xml 中</p>
</blockquote>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598670486704-cb7b6356-6317-47d3-85c4-a27582c41121.png#align=left&amp;display=inline&amp;height=221&amp;margin=%5Bobject%20Object%5D&amp;originHeight=455&amp;originWidth=1003&amp;size=0&amp;status=done&amp;style=shadow&amp;width=487" alt></p>
<h3 id="2-映射路径下使用通配符"><a href="#2-映射路径下使用通配符" class="headerlink" title="2. 映射路径下使用通配符"></a>2. 映射路径下使用通配符</h3><blockquote>
<p>在其中使用通配符，一个目录下的所有路径都可以访问，其中有完全目录匹配，目录匹配，扩展名匹配</p>
</blockquote>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598670487060-fa223535-eabd-40c6-bf7e-088fc77c9c87.png#align=left&amp;display=inline&amp;height=92&amp;margin=%5Bobject%20Object%5D&amp;originHeight=106&amp;originWidth=568&amp;size=0&amp;status=done&amp;style=shadow&amp;width=493" alt></p>
<h3 id="3-缺省"><a href="#3-缺省" class="headerlink" title="3. 缺省"></a>3. 缺省</h3><p>通常作用是解决请求的资源找不到的情况，（404：请求的资源找不到）</p>
<h2 id="四、-ServletConfig-和-ServletContext"><a href="#四、-ServletConfig-和-ServletContext" class="headerlink" title="四、 ServletConfig  和 ServletContext"></a>四、 <code>ServletConfig</code>  和 <code>ServletContext</code></h2><blockquote>
<p>ServletConfig 接口</p>
</blockquote>
<p>类比于 git 根文件夹<code>.ssh</code>下的 config 配置文件，它是 servlet 的配置对象，目的就是获取与 servlet 的初始化参数</p>
<blockquote>
<p>PS:会使用常用的接口方法</p>
</blockquote>
<h1 id="【第五章】会话技术"><a href="#【第五章】会话技术" class="headerlink" title="【第五章】会话技术"></a>【第五章】会话技术</h1><h2 id="一、会话技术"><a href="#一、会话技术" class="headerlink" title="一、会话技术"></a>一、会话技术</h2><p>相当于在客户端和服务器端之间，记录一些用户信息，但是不能用上一章节的，因为那只能保存暂时的信息。 <code>servlet</code>  还提供两个对象 <code>Cookie</code>  和 <code>Session</code>  可以更好地更好地保存会话数据。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598670565525-6a2b8b74-4105-447a-95ba-034020c747fe.png#align=left&amp;display=inline&amp;height=117&amp;margin=%5Bobject%20Object%5D&amp;originHeight=215&amp;originWidth=1105&amp;size=0&amp;status=done&amp;style=shadow&amp;width=601" alt></p>
<h1 id="【第六章】JSP-技术"><a href="#【第六章】JSP-技术" class="headerlink" title="【第六章】JSP 技术"></a>【第六章】JSP 技术</h1><h2 id="一、JSP-概述"><a href="#一、JSP-概述" class="headerlink" title="一、JSP 概述"></a>一、JSP 概述</h2><p>一种新的编写动态网页的技术，虽然本质还是调用了 <code>servlet</code> ，但是相比前者要简单很多（前者向页面写数据麻烦，复杂），其组成可以简单理解为<br><code>jsp = html + java + jsp自身</code></p>
<p>调用 servlet 过程：<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598670585374-60fc5166-cb3c-433e-9794-bae3778a3cd8.png#align=left&amp;display=inline&amp;height=251&amp;margin=%5Bobject%20Object%5D&amp;originHeight=479&amp;originWidth=910&amp;size=0&amp;status=done&amp;style=shadow&amp;width=477" alt></p>
<p>其中 jsp 生成 java 文件，编译成 class 文件所在目录（本来应该在 tomcat 的 work 路径下）：<code>D:\project-java\.metadata\.plugins\org.eclipse.wst.server.core\tmp0\work\Catalina\localhost\demo-jsp\org\apache\jsp</code><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598670585365-5f311403-0761-4643-aa17-931be713fc49.png#align=left&amp;display=inline&amp;height=71&amp;margin=%5Bobject%20Object%5D&amp;originHeight=71&amp;originWidth=468&amp;size=0&amp;status=done&amp;style=shadow&amp;width=468" alt></p>
<p>打开 java 文件之后可以看到相关对 sevlet 的继承</p>
<h2 id="二、JSP-语法"><a href="#二、JSP-语法" class="headerlink" title="二、JSP 语法"></a>二、JSP 语法</h2><h3 id="jsp-脚本元素"><a href="#jsp-脚本元素" class="headerlink" title="jsp 脚本元素"></a>jsp 脚本元素</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598670585361-957371bf-bb37-407a-90e8-8f21175d6589.png#align=left&amp;display=inline&amp;height=169&amp;margin=%5Bobject%20Object%5D&amp;originHeight=295&amp;originWidth=1117&amp;size=0&amp;status=done&amp;style=shadow&amp;width=639" alt></p>
<h3 id="jsp-注释"><a href="#jsp-注释" class="headerlink" title="jsp 注释"></a>jsp 注释</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598670585756-18f96e5c-8a74-4e14-8c16-55a9fd9124df.png#align=left&amp;display=inline&amp;height=118&amp;margin=%5Bobject%20Object%5D&amp;originHeight=118&amp;originWidth=643&amp;size=0&amp;status=done&amp;style=shadow&amp;width=643" alt></p>
<h3 id="jsp-指令"><a href="#jsp-指令" class="headerlink" title="jsp 指令"></a>jsp 指令</h3><blockquote>
<p>page 指令</p>
</blockquote>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598670585347-a182a404-b425-4f70-80d6-712122944623.png#align=left&amp;display=inline&amp;height=146&amp;margin=%5Bobject%20Object%5D&amp;originHeight=224&amp;originWidth=1007&amp;size=0&amp;status=done&amp;style=shadow&amp;width=658" alt></p>
<blockquote>
<p>include 指令</p>
</blockquote>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598670585378-bbe2df4b-013e-4531-bece-2836e4b8bde0.png#align=left&amp;display=inline&amp;height=142&amp;margin=%5Bobject%20Object%5D&amp;originHeight=185&amp;originWidth=884&amp;size=0&amp;status=done&amp;style=shadow&amp;width=677" alt></p>
<blockquote>
<p>taglib 指令</p>
</blockquote>
<h3 id="jsp-隐式对象"><a href="#jsp-隐式对象" class="headerlink" title="jsp 隐式对象"></a>jsp 隐式对象</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598670585348-c41424d0-e688-4ae6-809e-bcc33afec5e3.png#align=left&amp;display=inline&amp;height=195&amp;margin=%5Bobject%20Object%5D&amp;originHeight=274&amp;originWidth=912&amp;size=0&amp;status=done&amp;style=shadow&amp;width=650" alt></p>
<h1 id="【第九章】JDBC"><a href="#【第九章】JDBC" class="headerlink" title="【第九章】JDBC"></a>【第九章】JDBC</h1><h2 id="一、什么是-JDBC"><a href="#一、什么是-JDBC" class="headerlink" title="一、什么是 JDBC"></a>一、什么是 JDBC</h2><blockquote>
<p>使用数据库来存储和管理数据</p>
</blockquote>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598670606448-7b5d3ec0-c6eb-4485-af84-34a1d99fa4a1.png#align=left&amp;display=inline&amp;height=338&amp;margin=%5Bobject%20Object%5D&amp;originHeight=778&amp;originWidth=1159&amp;size=0&amp;status=done&amp;style=shadow&amp;width=503" alt><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598670606324-93a22794-21bb-42fc-9355-64c55411ea53.png#align=left&amp;display=inline&amp;height=99&amp;margin=%5Bobject%20Object%5D&amp;originHeight=200&amp;originWidth=983&amp;size=0&amp;status=done&amp;style=shadow&amp;width=487" alt></p>
<h2 id="二、JDBC-常用的-API"><a href="#二、JDBC-常用的-API" class="headerlink" title="二、JDBC 常用的 API"></a>二、JDBC 常用的 API</h2><blockquote>
<p>五个接口一个类（唯一的类）</p>
</blockquote>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598670606334-40b58ccd-ef50-4048-a17a-819885cdcf87.png#align=left&amp;display=inline&amp;height=197&amp;margin=%5Bobject%20Object%5D&amp;originHeight=282&amp;originWidth=931&amp;size=0&amp;status=done&amp;style=shadow&amp;width=649" alt><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598670606546-72057847-1b52-4b82-8f03-d2dcff6e0ed4.png#align=left&amp;display=inline&amp;height=249&amp;margin=%5Bobject%20Object%5D&amp;originHeight=392&amp;originWidth=1001&amp;size=0&amp;status=done&amp;style=shadow&amp;width=635" alt><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598670606535-2996029c-eaf0-45ee-a778-614141ceea4f.png#align=left&amp;display=inline&amp;height=112&amp;margin=%5Bobject%20Object%5D&amp;originHeight=136&amp;originWidth=755&amp;size=0&amp;status=done&amp;style=shadow&amp;width=624" alt></p>
<h1 id="【第十一章】JSP-开发模型"><a href="#【第十一章】JSP-开发模型" class="headerlink" title="【第十一章】JSP 开发模型"></a>【第十一章】JSP 开发模型</h1><h2 id="一、JSP-两种开发模式"><a href="#一、JSP-两种开发模式" class="headerlink" title="一、JSP 两种开发模式"></a>一、JSP 两种开发模式</h2><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598670623021-1406c5eb-f010-4d9f-a6fe-cd104b964450.png#align=left&amp;display=inline&amp;height=54&amp;margin=%5Bobject%20Object%5D&amp;originHeight=54&amp;originWidth=998&amp;size=0&amp;status=done&amp;style=shadow&amp;width=998" alt></p>
<h3 id="JSP-Model1"><a href="#JSP-Model1" class="headerlink" title="JSP Model1"></a>JSP Model1</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598670623035-3dae1126-3986-4893-afbf-ce3aa250deb1.png#align=left&amp;display=inline&amp;height=178&amp;margin=%5Bobject%20Object%5D&amp;originHeight=178&amp;originWidth=1220&amp;size=0&amp;status=done&amp;style=shadow&amp;width=1220" alt><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598670623082-df4cb3b4-1eb4-4590-a68f-f18a31a31816.png#align=left&amp;display=inline&amp;height=210&amp;margin=%5Bobject%20Object%5D&amp;originHeight=469&amp;originWidth=1291&amp;size=0&amp;status=done&amp;style=shadow&amp;width=579" alt></p>
<h3 id="JSP-Model2"><a href="#JSP-Model2" class="headerlink" title="JSP Model2"></a>JSP Model2</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598670623814-f1853ddf-0ab6-443c-b90f-97147896aa3c.png#align=left&amp;display=inline&amp;height=242&amp;margin=%5Bobject%20Object%5D&amp;originHeight=242&amp;originWidth=1045&amp;size=0&amp;status=done&amp;style=shadow&amp;width=1045" alt><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598670623035-37842a30-2e67-40d6-9b33-fc7a90a89037.png#align=left&amp;display=inline&amp;height=208&amp;margin=%5Bobject%20Object%5D&amp;originHeight=515&amp;originWidth=1297&amp;size=0&amp;status=done&amp;style=shadow&amp;width=523" alt></p>
<h2 id="二、MVC-设计模式"><a href="#二、MVC-设计模式" class="headerlink" title="二、MVC 设计模式"></a>二、MVC 设计模式</h2><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598670623024-0fbab2bd-139b-4e8e-806a-a010e86e6159.png#align=left&amp;display=inline&amp;height=204&amp;margin=%5Bobject%20Object%5D&amp;originHeight=204&amp;originWidth=1185&amp;size=0&amp;status=done&amp;style=shadow&amp;width=1185" alt><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598670623036-c1e95730-c04c-44ab-a07d-be7d3ce47970.png#align=left&amp;display=inline&amp;height=105&amp;margin=%5Bobject%20Object%5D&amp;originHeight=105&amp;originWidth=1138&amp;size=0&amp;status=done&amp;style=shadow&amp;width=1138" alt></p>
<h2 id="三、JavaWeb-开发中的三层架构"><a href="#三、JavaWeb-开发中的三层架构" class="headerlink" title="三、JavaWeb 开发中的三层架构"></a>三、JavaWeb 开发中的三层架构</h2><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598670623143-02074466-5715-4efa-8b09-ee2a1489d94e.png#align=left&amp;display=inline&amp;height=153&amp;margin=%5Bobject%20Object%5D&amp;originHeight=153&amp;originWidth=1077&amp;size=0&amp;status=done&amp;style=shadow&amp;width=1077" alt><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598670623075-f2b2b6ce-ebd7-4712-86f3-61ee087aafbb.png#align=left&amp;display=inline&amp;height=198&amp;margin=%5Bobject%20Object%5D&amp;originHeight=499&amp;originWidth=1326&amp;size=0&amp;status=done&amp;style=shadow&amp;width=525" alt><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598670622943-c73fc987-bbd4-4204-9a82-6a93ea4ac8ed.png#align=left&amp;display=inline&amp;height=224&amp;margin=%5Bobject%20Object%5D&amp;originHeight=224&amp;originWidth=1066&amp;size=0&amp;status=done&amp;style=shadow&amp;width=1066" alt></p>
]]></content>
      <categories>
        <category>Web</category>
      </categories>
  </entry>
  <entry>
    <title>C和C++遗忘知识</title>
    <url>/blog/uakfgc/</url>
    <content><![CDATA[<h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><p>相关概念的理解容易混淆，记住之前学习理解的一个准则！<code>*p 的理解意义就是p 所指向的那个东西</code></p>
<ul>
<li>取地址符&amp;</li>
<li>解引用运算符*</li>
</ul>
<blockquote>
<p><a href="https://blog.csdn.net/soonfly/article/details/51131141" target="_blank" rel="noopener">https://blog.csdn.net/soonfly/article/details/51131141</a></p>
</blockquote>
<h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><ul>
<li><p>一些概念</p>
<blockquote>
<ul>
<li>结构体:构造（定义新的数据类型）</li>
<li>结构体变量:定义（两种）；结构体变量访问结构体里面的成员：<code>.</code>；指针访问成员的时候<code>-&gt;</code></li>
<li>结构体数组：变量很多</li>
<li>结构体指针：指向结构体变量的指针，定义：<code>struct Student *p</code>；指向结构体数组的指针</li>
</ul>
</blockquote>
</li>
<li><p>C 里面的<strong>结构体、共用体、枚举体</strong>根据这几类来构造新的数据类型，比如链表的初始实现，就是利用指针和结构体来实现</p>
</li>
<li><strong>typedef</strong>给结构体制定新的类型名  eg：计数专用变量<code>typedef int Count</code></li>
</ul>
<h2 id="C-相对-C"><a href="#C-相对-C" class="headerlink" title="C++相对 C"></a>C++相对 C</h2><p>C 语言是一种混合型语言（20 世纪 80 年代兴起），它保留了 C 语言所有的优点，同时又增添了面向对象的编程机制，我们可以将 C 语言视为 C 语言的改进和扩展。</p>
<p>基于 C 语言开发的 C 语言兼容 C 语言，因此用 C 语言编写的程序基本上可以不做改动地用于 C。相对于 C 语言，C++语言对 C 语言的功能做了一定的扩充，同时增添了面向对象编程机制。引入面向对象编程机制，主要是为了提高开发效率。</p>
<p>早期 C 许多的工作是对于 C 的强化和净化，并把完全兼容 C 作为强制性要求。C89、C99 中许多的改进正是从 C 中所引进。可见，Stroustrup 对 C 语言的贡献非常之大。今天不管你对 C 怎么看，C 的确扩展和进化了 C，对 C 造成了深远的影响。</p>
<ol>
<li>在 C 兼容 C 的过程中遇到了不少设计实现上的麻烦；以及守旧的 K&amp;R C 程序员对 Stroustrup 的批评。很多人说 C 的恶梦恶梦就是要去兼容于 C，这并不无道理（Java 就干的比 C++彻底得多），但这并不是 Stroustrup 考虑的，Stroustrup 一边在使尽浑身解数来兼容 C，另一方面在拼命地优化 C。</li>
<li>C 最大的竞争对手正是 C，他的目的就是——C 能做到的，C 也必须做到，而且要做的更好。大家觉得是不是做到了？有多少做到了，有多少还没有做到？</li>
<li>对于同时关注的运行效率和开发效率的程序员，Stroustrup 多次强调 C 的目标是——“在保证效率与 C 语言相当的情况下，加强程序的组织性；能保证同样功能的程序，C 更短小”，这正是浅封装的核心思想。而不是过渡设计的 OO。</li>
<li>《C 演化和设计》这本书中举了很多例子来回应那些批评 C 有运行性能问题的人。C 在其第二个版本中，引入了虚函数机制，这是 C 效率最大的瓶颈了，但我个人认为虚函数就是多了一次加法运算，但让我们的代码能有更好的组织，极大增加了程序的阅读和降底了维护成本。（注：Lippman 的《深入探索 C 对象模型》也说明了 C 不比 C 的程序在运行性能低。Bruce 的《Think in C++》也说 C++和 C 的性能相差只有 5%）</li>
<li>这本书中还讲了一些 C++的痛苦的取舍，印象最深的就是多重继承，提出，拿掉，再被提出，反复很多次，大家在得与失中不断地辩论和取舍。这个过程让我最大的收获是——a) 对于任何一种设计都有好有坏，都只能偏重一方，b) 完全否定式的批评是不好的心态，好的心态应该是建设性地批评。</li>
</ol>
<p>相对运行于虚拟机语言，C/C 直接以静态形式把源程序编译为目标平台的机器码。一般而言，C/C 程序在编译及链接时可进行的优化最丰富，启动时的速度最快，运行时的额外内存开销最少。而 C/C 相对动态语言也减少了运行时的动态类型检测。此外，C/C 的运行行为是确定的，且不会有额外行为，也不会有如垃圾收集(GC)而造成的不确定性延迟，而且 C/C 的数据结构在内存中的布局也是确定的。有时 C 的一些功能会使程序性能优于 C，当中以内联和模版最为突出，这两项功能使 C 标准库的 sort()通常比 C 标准库的 qsort()快多倍(C 可用宏或人手编码去解决此问题)。另一方面，C/C 能直接映射机器码，之间没有另一层中间语言，因此可以做底层优化，例如使用内部(intrinsic)函数和嵌入汇编语言。然而，许多 C++的性能优点并非免费午餐，代价包括较长的编译链接时间和较易出错，因而增加开发时间和成本。</p>
<h2 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h2><p>C++模板知识</p>
<ul>
<li>函数模板</li>
<li>类模板<br>STL 概述当中，vector 容器，顺序容器：向量 vector、列表 list、双端队列 deque</li>
</ul>
<blockquote>
<p><a href="https://www.cnblogs.com/mr-wid/archive/2013/01/22/2871105.html" target="_blank" rel="noopener">https://www.cnblogs.com/mr-wid/archive/2013/01/22/2871105.html</a></p>
</blockquote>
<h2 id="C-常用字符函数"><a href="#C-常用字符函数" class="headerlink" title="C 常用字符函数"></a>C 常用字符函数</h2><p>Printf()<br>Scanf()<br>Putchar()<br>Getchar()<br>Puts(str)<br>Gets(str)<br>Strcat(str1,str2)：连接字符串<br>复制函数：将 str2 复制给 str1<br>Strcpy(str1,str2)<br>在 C++里面会报错<br>解决 ①：将函数 strcpy 改成 strcpy_s,中间加一个参数——复制的长度</p>
<p>Strncpy(str1,str2,n)：复制函数，将 str2 的前 n 个字符复制给 str1<br>Strlen(str)：检测 str 的字符串长度<br>Fopen(文件名，使用文件方式）<br>fclose（文件指针）</p>
<h2 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h2><p>v I/O 流<br>scanf===cin&gt;&gt; &gt;&gt;endl;<br>Print===cout&lt;&lt; &lt;&lt;endl;<br>换行符：endl 和 “\n”<br>v 注释<br>/*  */<br>//<br>v const 定义常量<br>之前 C 语言里面用的是宏定义#define Π 3.1415927，但是宏定义有时候太“死板”</p>
<h2 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h2><p>类的形式？<br>Class wuzutao<br>{<br>private：</p>
<pre><code>    public：

    protect：

}；
数据成员
成员函数：
    类内实现=和普通函数的实现一样
    类外实现=void Date：：Display（）{}
</code></pre><p>类定义对象？<br>① 花括号内定义<br>② 花括号外定义</p>
<p>访问对象？<br>访问的是类内的成员<br>① 圆点访问形式<br>② 指针访问形式</p>
<p>this 指针？<br>每个成员函数都会有一个特殊的隐含指针——this 指针。<br>调用形式：cout&lt;&lt;this&lt;year&lt;day&lt;&lt;endl;</p>
<h3 id="构造函数和析构函数"><a href="#构造函数和析构函数" class="headerlink" title="构造函数和析构函数"></a>构造函数和析构函数</h3><p>构造函数的作用就是适当地给类进行初始化的作用<br>无参数的构造函数<br>带参数的构造函数</p>
<p>拷贝构造函数，这里不是太懂！<br>拷贝构造函数声明<br>拷贝构造函数定义和实现</p>
<p>析构函数<br>一般默认，如果自己写的话就是<br>析构函数的声明：<br>~类名（）；<br>析构函数的定义和实现：<br>类名：：~类名（）{……}</p>
<h2 id="数据的共享和保护"><a href="#数据的共享和保护" class="headerlink" title="数据的共享和保护"></a>数据的共享和保护</h2><h3 id="数据共享-static"><a href="#数据共享-static" class="headerlink" title="数据共享 static"></a>数据共享 static</h3><ol>
<li>静态数据成员<br>声明：static 数据类型 静态数据成员名；<br>初始化在类结束和类中函数实现的中间<br>之后访问（通过类名/对象名来访问）：<br>私有的静态成员只能通过间接的方式来访问===静态成员函数<br>对象名.公有静态成员变量名<br>对象名::公有静态成员变量名</li>
<li>静态成员函数<br>没有 this 指针<br>声明：static 返回值类型 静态成员函数名（形参表）<br>之后访问（通过类名/对象名来访问）：<br>类名::静态成员函数名（实参表）<br>类名.静态成员函数名（实参表）</li>
</ol>
<h3 id="数据保护-const"><a href="#数据保护-const" class="headerlink" title="数据保护 const"></a>数据保护 const</h3><ol>
<li>常数据成员<br>有些时候，希望不用全局变量，因为这样不好移植，所以用到 const 场数据类型，相当于每次用不同场合用到这个类，都是这些用到这些固定的数据<br>一般结合 static 来避免数据赘余<br>eg：类 Circle 中<br>定义：const double PI；<br>初始化只能在构造函数后面的初始化列表中：Circle （double r=0）：PI（3.1415926）<ol>
<li>常成员函数<br>只访问类中的数据而不修改类中的数据成员，最好用到常成员函数<br>eg：只访问类中的半径<br>声明：Double GetRadius（）const；<br>实现：double Circle：：GetRadius（）const{……}</li>
<li>常对象<br>所定义的常对象 p1 在之后就不会被改变了<br>形式：const Person p1（17，“wu”）；</li>
</ol>
</li>
</ol>
<h2 id="类和类之间的关系"><a href="#类和类之间的关系" class="headerlink" title="类和类之间的关系"></a>类和类之间的关系</h2><h3 id="类的组合"><a href="#类的组合" class="headerlink" title="类的组合"></a>类的组合</h3><p>直观：B 类中有 A 类定义的对象</p>
<p>构造函数的顺序：<br>对象成员的构造函数<br>自身的构造函数</p>
<p>构造函数有参数的时候：<br>怎么个表现形式呢？<br><strong>B 类中 B 的构造函数后面带有 A 类在 B 类中所定义的对象，这个对象的参数用做左边 B 类构造函数的参数、</strong></p>
<h3 id="类的依赖"><a href="#类的依赖" class="headerlink" title="类的依赖"></a>类的依赖</h3><p>赌徒和骰子，这就是一种依赖关系，如果用组合关系的话，就会影响到生命周期问题</p>
<p>Class 🎲{}；<br>Class 🕵️‍♂️<br>{<br>public：<br>Void play（🎲1，🎲2，🎲3）<br>{……}<br>}；</p>
<h3 id="类的继承和派生"><a href="#类的继承和派生" class="headerlink" title="类的继承和派生"></a>类的继承和派生</h3><p>一、派生类的定义：<br>父类 class Base{}<br>派生子类：单一继承 class Derived：public Base{}；<br>多重继承 Class Derived：public Base1，pretect Base2{}；<br>继承的类型：<br>单一继承：只有一个基类<br>多重继承：有多个基类</p>
<p>继承方式：<br>private 继承：所有的数据成员都为子类的的私有成员<br>public 继承：父类的数据类型怎样，在子类类型不变<br>protect 继承：所有的数据成员和成员函数都为字类的保护成员<br>ps：① 父类的 private 数据成员和成员函数不能被子类所继承<br>② 一般很少用 protect 和 private 两种继承，因为两种改变了之前基类的访问属性，限制了这些的进一步派生，所以很少使用</p>
<p>二、派生类的构造和析构<br>构造和析构的调用顺序：<br>① 所有虚基类的构造函数<br>② 基类的构造函数<br>③ 对象成员的构造函数<br>④ 自身派生类的构造函数<br>ps：析构函数的调用顺序则正好相反、<br>虚基类保证调用一次构造函数。两个子类都有同一个基类的虚基类继承，构造函数只调用一次<br>带参数的构造函数：<br>子类里面，构造函数的初始化要连带着基类的构造函数的初始化<br>eg：classA(int a,int b,int c):classB(a*2),classC(a,b){}</p>
<p>三、同名冲突和解决方案<br>解决 ① 双冒号法：：<br>基类和子类当中有相同名字的数据成员和成员函数，<br>访问的时候：相同的名字：：数据成员/成员函数<br>解决 ② 定义虚基类 virtual<br>eg：class furniture{}；<br>Class sofa ：virtual public furniture{}；<br>Class bed：virtual public furniture{}；<br>Class sofabed：public sofa，public bed{}；</p>
<p>四、赋值兼容规则</p>
]]></content>
      <categories>
        <category>Language</category>
      </categories>
  </entry>
  <entry>
    <title>机器学习scikit-learn库的使用</title>
    <url>/blog/wgv3ak/</url>
    <content><![CDATA[<h2 id="一、机器学习的一些概念"><a href="#一、机器学习的一些概念" class="headerlink" title="一、机器学习的一些概念"></a>一、机器学习的一些概念</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ul>
<li>特征：一组数据的多个属性</li>
<li>标签：人为指定特征</li>
<li>监督学习：就像分类（离散化的标签），回归（连续性的标签）、【“有标准答案”】</li>
<li>无监督学习：就像聚类【“无标准答案”】</li>
<li><strong>数据</strong>：是机器学习的命脉</li>
</ul>
<h3 id="基本框架图"><a href="#基本框架图" class="headerlink" title="基本框架图"></a>基本框架图</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598686130909-116e16a4-e86a-46e0-93fb-ac0263257056.png#align=left&amp;display=inline&amp;height=271&amp;margin=%5Bobject%20Object%5D&amp;originHeight=692&amp;originWidth=1157&amp;size=0&amp;status=done&amp;style=shadow&amp;width=453" alt><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598686131288-431d8fe6-bf3f-4f3e-9986-9b282e9e2982.png#align=left&amp;display=inline&amp;height=356&amp;margin=%5Bobject%20Object%5D&amp;originHeight=651&amp;originWidth=869&amp;size=0&amp;status=done&amp;style=shadow&amp;width=475" alt></p>
<h2 id="二、机器学习的一些阶段-步骤"><a href="#二、机器学习的一些阶段-步骤" class="headerlink" title="二、机器学习的一些阶段/步骤"></a>二、机器学习的一些阶段/步骤</h2><h3 id="sklearn-相关提及"><a href="#sklearn-相关提及" class="headerlink" title="sklearn 相关提及"></a>sklearn 相关提及</h3><p><a href="https://scikit-learn.org/stable/testimonials/testimonials.html" target="_blank" rel="noopener">官网 scikit-learn</a></p>
<ol>
<li>包含聚类、分类、回归等算法<br>eg：随机森林、k-means、SVM 等</li>
<li>包含模型筛选、降维、预处理等算法</li>
<li>要特别注意安装该包使用要注意的细节，具体参考上一篇博客</li>
</ol>
<h3 id="sklearn-处理机器学习的一般化-sop"><a href="#sklearn-处理机器学习的一般化-sop" class="headerlink" title="sklearn 处理机器学习的一般化 sop"></a>sklearn 处理机器学习的一般化 sop</h3><ol>
<li><strong>准备数据集</strong><ul>
<li><a href>数据分析</a>:（利用 np.reshape()成二维(n_samples,n_features)）</li>
<li>划分数据集：train_test_split()</li>
<li>特征工程：特征的提取、特征的归一化 nomalization</li>
</ul>
</li>
<li><strong>选择模型</strong><ul>
<li>根据不同场景选择合适的模型:<a href="https://scikit-learn.org/stable/tutorial/machine_learning_map/index.html" target="_blank" rel="noopener">scikit-learn 的模型选择路线图</a></li>
<li>分类、聚类、回归……</li>
</ul>
</li>
<li>在训练集上<strong>训练模型</strong>，并调整参数<ul>
<li>经验选定参数</li>
<li>交叉验证确定最优的参数 cross validation</li>
</ul>
</li>
<li>在测试集上<strong>测试模型</strong><ul>
<li>predict 预测、score 真实值预测值评分、etc</li>
</ul>
</li>
<li><strong>保存模型</strong><ul>
<li><code>import pickle</code></li>
</ul>
</li>
</ol>
<h3 id="主成分分析：将特征降维"><a href="#主成分分析：将特征降维" class="headerlink" title="主成分分析：将特征降维"></a>主成分分析：将特征降维</h3><ul>
<li>统计学相关知识：方差（衡量在一个维度的偏差）、协方差（衡量一个维度是否对另一个维度有影响 cov（x，y））</li>
<li>线代相关知识：特征值、特征向量、协方差向量</li>
<li>PCA</li>
</ul>
<p><a href="http://q5e49p23n.bkt.clouddn.com/scikit_pca.html" target="_blank" rel="noopener">相关代码 html 页面</a></p>
<h2 id="三、通过-scikit-learn-认识机器学习"><a href="#三、通过-scikit-learn-认识机器学习" class="headerlink" title="三、通过 scikit-learn 认识机器学习"></a>三、通过 scikit-learn 认识机器学习</h2><h3 id="加载示例数据集"><a href="#加载示例数据集" class="headerlink" title="加载示例数据集"></a>加载示例数据集</h3><pre><code class="python">from sklearn import datasets
iris = datasets.load_iris()#用sklearn自身配带的数据
digits = datasets.load_digits()
# C:\Users\wztli\Anaconda3\pkgs\scikit-learn-0.21.3-py37h6288b17_0\Lib\site-packages\sklearn\datasets\data
# 数据集在电脑中的位置
</code></pre>
<pre><code class="python"># 查看数据集
# iris
print(iris.data[:5])
print(iris.data.shape)
print(iris.target_names)
print(iris.target)
</code></pre>
<pre><code class="python">[[5.1 3.5 1.4 0.2]
 [4.9 3.  1.4 0.2]
 [4.7 3.2 1.3 0.2]
 [4.6 3.1 1.5 0.2]
 [5.  3.6 1.4 0.2]]
(150, 4)
[&#39;setosa&#39; &#39;versicolor&#39; &#39;virginica&#39;]
[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 2
 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
 2 2]
</code></pre>
<pre><code class="python"># digits
print(digits.data)
print(digits.data.shape)
print(digits.target_names)
print(digits.target)
</code></pre>
<pre><code class="python">[[ 0.  0.  5. ...  0.  0.  0.]
 [ 0.  0.  0. ... 10.  0.  0.]
 [ 0.  0.  0. ... 16.  9.  0.]
 ...
 [ 0.  0.  1. ...  6.  0.  0.]
 [ 0.  0.  2. ... 12.  0.  0.]
 [ 0.  0. 10. ... 12.  1.  0.]]
(1797, 64)
[0 1 2 3 4 5 6 7 8 9]
[0 1 2 ... 8 9 8]
</code></pre>
<h3 id="在训练集上训练模型"><a href="#在训练集上训练模型" class="headerlink" title="在训练集上训练模型"></a>在训练集上训练模型</h3><pre><code class="python"># 手动划分训练集、测试集
n_test = 100 # 测试样本个数
train_X = digits.data[:-n_test, :]
train_y = digits.target[:-n_test]

test_X = digits.data[-n_test:, :]
y_true = digits.target[-n_test:]
</code></pre>
<pre><code class="python"># 选择SVM模型
from sklearn import svm

svm_model = svm.SVC(gamma=0.001, C=100.)
# svm_model = svm.SVC(gamma=100., C=1.)

# 训练模型
svm_model.fit(train_X, train_y)
#训练要放入两个参数：样本的特征数据，样本的标签
</code></pre>
<pre><code class="python">SVC(C=100.0, cache_size=200, class_weight=None, coef0=0.0,
    decision_function_shape=&#39;ovr&#39;, degree=3, gamma=0.001, kernel=&#39;rbf&#39;,
    max_iter=-1, probability=False, random_state=None, shrinking=True,
    tol=0.001, verbose=False)
</code></pre>
<pre><code class="python"># 选择LR（逻辑回归）模型
from sklearn.linear_model import LogisticRegression

lr_model = LogisticRegression()
# 训练模型
lr_model.fit(train_X, train_y)
</code></pre>
<pre><code class="python">C:\Users\wztli\Anaconda3\lib\site-packages\sklearn\linear_model\logistic.py:432: FutureWarning: Default solver will be changed to &#39;lbfgs&#39; in 0.22. Specify a solver to silence this warning.
  FutureWarning)
C:\Users\wztli\Anaconda3\lib\site-packages\sklearn\linear_model\logistic.py:469: FutureWarning: Default multi_class will be changed to &#39;auto&#39; in 0.22. Specify the multi_class option to silence this warning.
  &quot;this warning.&quot;, FutureWarning)





LogisticRegression(C=1.0, class_weight=None, dual=False, fit_intercept=True,
                   intercept_scaling=1, l1_ratio=None, max_iter=100,
                   multi_class=&#39;warn&#39;, n_jobs=None, penalty=&#39;l2&#39;,
                   random_state=None, solver=&#39;warn&#39;, tol=0.0001, verbose=0,
                   warm_start=False)
</code></pre>
<h3 id="在测试集上测试模型"><a href="#在测试集上测试模型" class="headerlink" title="在测试集上测试模型"></a>在测试集上测试模型</h3><pre><code class="python">y_pred_svm = svm_model.predict(test_X)
y_pred_lr = lr_model.predict(test_X)
</code></pre>
<pre><code class="python"># 查看结果
# 评价指标
from sklearn.metrics import accuracy_score

#print &#39;预测标签：&#39;, y_pred
#print &#39;真实标签：&#39;, y_true

print(&#39;SVM结果：&#39;, accuracy_score(y_true, y_pred_svm))
print(&#39;LR结果：&#39;, accuracy_score(y_true, y_pred_lr))
</code></pre>
<pre><code class="python">SVM结果： 0.98
LR结果： 0.94
</code></pre>
<h3 id="保存模型"><a href="#保存模型" class="headerlink" title="保存模型"></a>保存模型</h3><pre><code class="python">import pickle

with open(&#39;svm_model.pkl&#39;, &#39;wb&#39;) as f:
    pickle.dump(svm_model, f)
</code></pre>
<pre><code class="python">import numpy as np

# 重新加载模型进行预测
with open(&#39;svm_model.pkl&#39;, &#39;rb&#39;) as f:
    model = pickle.load(f)

random_samples_index = np.random.randint(0, 1796, 5)
random_samples = digits.data[random_samples_index, :]
random_targets = digits.target[random_samples_index]

random_predict = model.predict(random_samples)

print(random_predict)
print(random_targets)
</code></pre>
<pre><code class="python">[2 2 1 3 8]
[2 2 1 3 8]
</code></pre>
<h2 id="四、scikit-learn-入门"><a href="#四、scikit-learn-入门" class="headerlink" title="四、scikit-learn 入门"></a>四、scikit-learn 入门</h2><h3 id="准备数据集"><a href="#准备数据集" class="headerlink" title="准备数据集"></a>准备数据集</h3><pre><code class="python">import numpy as np
from sklearn.model_selection import train_test_split
</code></pre>
<pre><code class="python">X = np.random.randint(0, 100, (10, 4))
y = np.random.randint(0, 4, 10)
y.sort()

print(&#39;样本：&#39;)
print(X)
print(&#39;标签：&#39;, y)
</code></pre>
<pre><code class="python">样本：
[[43 43 18 78]
 [74 24 42 37]
 [36 69 84 47]
 [70 62 77 30]
 [87 38  3 96]
 [68 67 24  7]
 [66 36 72 72]
 [12 94 87 72]
 [66  5 92  6]
 [41 59 60 91]]
标签： [0 0 0 2 2 2 2 3 3 3]
</code></pre>
<pre><code class="python"># 分割训练集、测试集
# random_state确保每次随机分割得到相同的结果
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=1/3., random_state=7)

print(&#39;训练集：&#39;)
print(X_train)
print(y_train)

print(&#39;测试集：&#39;)
print(X_test)
print(y_test)
</code></pre>
<pre><code class="python">训练集：
[[63 56  7 42]
 [40 47 17 23]
 [41 31 26  8]
 [79 30 22 88]
 [54 85 48 54]
 [89 73 77 41]]
[0 1 1 0 1 1]
测试集：
[[ 3  0 42 86]
 [42 96 83 38]
 [33 45  8 37]
 [ 1 44 75  7]]
[1 1 0 0]
</code></pre>
<pre><code class="python"># 特征归一化
from sklearn import preprocessing

x1 = np.random.randint(0, 1000, 5).reshape(5,1)
x2 = np.random.randint(0, 10, 5).reshape(5, 1)
x3 = np.random.randint(0, 100000, 5).reshape(5, 1)

X = np.concatenate([x1, x2, x3], axis=1)
print(X)
</code></pre>
<pre><code class="python">[[  353     4 27241]
 [  999     4 34684]
 [  911     4 78606]
 [  310     6 44593]
 [  817     9  6356]]
</code></pre>
<pre><code class="python">print(preprocessing.scale(X))
</code></pre>
<pre><code class="python">[[-1.12443958 -0.71443451 -0.46550183]
 [ 1.11060033 -0.71443451 -0.15209341]
 [ 0.80613669 -0.71443451  1.69736578]
 [-1.27321159  0.30618622  0.26515287]
 [ 0.48091416  1.83711731 -1.34492342]]
</code></pre>
<pre><code class="python"># 生成分类数据进行验证scale的必要性
from sklearn.datasets import make_classification
import matplotlib.pyplot as plt
%matplotlib inline

X, y = make_classification(n_samples=300, n_features=2, n_redundant=0, n_informative=2,
                           random_state=25, n_clusters_per_class=1, scale=100)

plt.scatter(X[:,0], X[:,1], c=y)
plt.show()
</code></pre>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598686130636-3a18d8f2-51cb-4b04-8a0f-a40cf1d0b9b6.png#align=left&amp;display=inline&amp;height=248&amp;margin=%5Bobject%20Object%5D&amp;originHeight=248&amp;originWidth=384&amp;size=0&amp;status=done&amp;style=none&amp;width=384" alt></p>
<pre><code class="python">from sklearn import svm

# 注释掉以下这句表示不进行特征归一化
X = preprocessing.scale(X)

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=1/3., random_state=7)
svm_classifier = svm.SVC()
svm_classifier.fit(X_train, y_train)
svm_classifier.score(X_test, y_test)
</code></pre>
<pre><code class="python">C:\Users\wztli\Anaconda3\lib\site-packages\sklearn\svm\base.py:193: FutureWarning: The default value of gamma will change from &#39;auto&#39; to &#39;scale&#39; in version 0.22 to account better for unscaled features. Set gamma explicitly to &#39;auto&#39; or &#39;scale&#39; to avoid this warning.
  &quot;avoid this warning.&quot;, FutureWarning)





0.25
</code></pre>
<h3 id="训练模型"><a href="#训练模型" class="headerlink" title="训练模型"></a>训练模型</h3><pre><code class="python"># 回归模型
from sklearn import datasets

boston_data = datasets.load_boston()
X = boston_data.data
y = boston_data.target

print(&#39;样本：&#39;)
print(X[:5, :])
print(&#39;标签：&#39;)
print(y[:5])
</code></pre>
<pre><code class="python">样本：
[[6.3200e-03 1.8000e+01 2.3100e+00 0.0000e+00 5.3800e-01 6.5750e+00
  6.5200e+01 4.0900e+00 1.0000e+00 2.9600e+02 1.5300e+01 3.9690e+02
  4.9800e+00]
 [2.7310e-02 0.0000e+00 7.0700e+00 0.0000e+00 4.6900e-01 6.4210e+00
  7.8900e+01 4.9671e+00 2.0000e+00 2.4200e+02 1.7800e+01 3.9690e+02
  9.1400e+00]
 [2.7290e-02 0.0000e+00 7.0700e+00 0.0000e+00 4.6900e-01 7.1850e+00
  6.1100e+01 4.9671e+00 2.0000e+00 2.4200e+02 1.7800e+01 3.9283e+02
  4.0300e+00]
 [3.2370e-02 0.0000e+00 2.1800e+00 0.0000e+00 4.5800e-01 6.9980e+00
  4.5800e+01 6.0622e+00 3.0000e+00 2.2200e+02 1.8700e+01 3.9463e+02
  2.9400e+00]
 [6.9050e-02 0.0000e+00 2.1800e+00 0.0000e+00 4.5800e-01 7.1470e+00
  5.4200e+01 6.0622e+00 3.0000e+00 2.2200e+02 1.8700e+01 3.9690e+02
  5.3300e+00]]
标签：
[24.  21.6 34.7 33.4 36.2]
</code></pre>
<pre><code class="python"># 选择线性回顾模型
from sklearn.linear_model import LinearRegression

lr_model = LinearRegression()
</code></pre>
<pre><code class="python">from sklearn.model_selection import train_test_split

# 分割训练集、测试集
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=1/3., random_state=7)
</code></pre>
<pre><code class="python"># 训练模型
lr_model.fit(X_train, y_train)
</code></pre>
<pre><code class="python">LinearRegression(copy_X=True, fit_intercept=True, n_jobs=None, normalize=False)
</code></pre>
<pre><code class="python"># 返回参数
lr_model.get_params()
</code></pre>
<pre><code class="python">{&#39;copy_X&#39;: True, &#39;fit_intercept&#39;: True, &#39;n_jobs&#39;: None, &#39;normalize&#39;: False}
</code></pre>
<pre><code class="python">lr_model.score(X_train, y_train)
</code></pre>
<pre><code class="python">0.7598132492351114
</code></pre>
<pre><code class="python">lr_model.score(X_test, y_test)
</code></pre>
<pre><code class="python">0.6693852753319398
</code></pre>
<h3 id="交叉验证"><a href="#交叉验证" class="headerlink" title="交叉验证"></a>交叉验证</h3><pre><code class="python">from sklearn import datasets
from sklearn.model_selection import train_test_split, cross_val_score
from sklearn.neighbors import KNeighborsClassifier
import matplotlib.pyplot as plt
%matplotlib inline

iris = datasets.load_iris()
X = iris.data
y = iris.target

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=1/3., random_state=10)

k_range = range(1, 31)
cv_scores = []
for n in k_range:
    knn = KNeighborsClassifier(n)
    scores = cross_val_score(knn, X_train, y_train, cv=10, scoring=&#39;accuracy&#39;) # 分类问题使用
    #scores = cross_val_score(knn, X_train, y_train, cv=10, scoring=&#39;neg_mean_squared_error&#39;) # 回归问题使用
    cv_scores.append(scores.mean())

plt.plot(k_range, cv_scores)
plt.xlabel(&#39;K&#39;)
plt.ylabel(&#39;Accuracy&#39;)
plt.show()
</code></pre>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598686130618-179a3dfa-9ffd-4f45-9cc2-d6f63e1ad2b9.png#align=left&amp;display=inline&amp;height=262&amp;margin=%5Bobject%20Object%5D&amp;originHeight=262&amp;originWidth=392&amp;size=0&amp;status=done&amp;style=none&amp;width=392" alt></p>
<pre><code class="python"># 选择最优的K
best_knn = KNeighborsClassifier(n_neighbors=5)
best_knn.fit(X_train, y_train)
print(best_knn.score(X_test, y_test))
print(best_knn.predict(X_test))
</code></pre>
<pre><code class="python">0.96
[1 2 0 1 0 1 2 1 0 1 1 2 1 0 0 2 1 0 0 0 2 2 2 0 1 0 1 1 1 2 1 1 2 2 2 0 2
 2 2 2 0 0 1 0 1 0 1 2 2 2]
</code></pre>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://github.com/wztlink1013/scikit-learn" target="_blank" rel="noopener">scikit-learn 中文文档 github</a>文中链接为英文文档</li>
<li><a href="https://blog.csdn.net/Little_Fire/article/details/81062447" target="_blank" rel="noopener">解释 iris 数据集</a></li>
</ul>
]]></content>
      <categories>
        <category>MachingLearning</category>
      </categories>
      <tags>
        <tag>sklearn</tag>
        <tag>scikit-learn</tag>
      </tags>
  </entry>
  <entry>
    <title>[转]uni-app相关知识</title>
    <url>/blog/ytoag7/</url>
    <content><![CDATA[<blockquote>
<ul>
<li>本文转载自：<a href="https://ask.dcloud.net.cn/article/35657" target="_blank" rel="noopener">白话 uni-app </a></li>
<li>添加部分细节自己写的内容</li>
</ul>
</blockquote>
<h2 id="uni-app-相对传统的变化"><a href="#uni-app-相对传统的变化" class="headerlink" title="uni-app 相对传统的变化"></a>uni-app 相对传统的变化</h2><h3 id="网络模型的变化"><a href="#网络模型的变化" class="headerlink" title="网络模型的变化"></a>网络模型的变化</h3><p>之前学习的<code>javaweb</code>形式的是“相互嵌套”类型的，<code>jsp</code>代码里面可以有<code>html</code>代码。</p>
<p>以前网页大多是 b/s，服务端代码混合在页面里；<br>现在是 c/s，前后端分离，通过 js api(类似 ajax 的<code>uni.request</code>)获取 json 数据，把数据绑定在界面上渲染。</p>
<h3 id="文件类型变化"><a href="#文件类型变化" class="headerlink" title="文件类型变化"></a>文件类型变化</h3><p>.vue 文件通过编译，编译 js 文件</p>
<h3 id="代码架构大变动"><a href="#代码架构大变动" class="headerlink" title="代码架构大变动"></a>代码架构大变动</h3><p>以前的 HTML 代码节点，有 html 大节点，还有 script 和 style 两个小结点</p>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot; /&gt;
    &lt;title&gt;&lt;/title&gt;
    &lt;script type=&quot;text/javascript&quot;&gt;&lt;/script&gt;
    &lt;style type=&quot;text/css&quot;&gt;&lt;/style&gt;
  &lt;/head&gt;
  &lt;body&gt;&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>现在 template 是一级节点，用于写<strong>tag 组件</strong>，script 和 style 是并列的一级节点，也就是有 3 个一级节点</p>
<pre><code class="vue">&lt;template&gt;
  &lt;view&gt;
    注意必须有一个view，且只能有一个根view。所有内容写在这个view下面。
  &lt;/view&gt;
&lt;/template&gt;

&lt;script&gt;
export default {};
&lt;/script&gt;

&lt;style&gt;&lt;/style&gt;
</code></pre>
<ul>
<li><a href="https://cn.vuejs.org/v2/guide/single-file-components.html" target="_blank" rel="noopener">Vue 单文件组件</a></li>
</ul>
<p>###</p>
<h3 id="组件-标签的变化"><a href="#组件-标签的变化" class="headerlink" title="组件/标签的变化"></a>组件/标签的变化</h3><p>下为 html 标签和 uni-app 内置组件的映射表：<br>（其实老的 HTML 标签也可以在 uni-app 里使用，uni-app 编译器会在编译时把老标签转为新标签，比如把 div 编译成 view。但不推荐这种用法，调试 H5 端时容易混乱。）</p>
<ul>
<li>div 改成 <a href="https://uniapp.dcloud.io/component/view" target="_blank" rel="noopener">view</a></li>
<li>span、font 改成 <a href="https://uniapp.dcloud.io/component/text" target="_blank" rel="noopener">text</a></li>
<li>a 改成 <a href="https://uniapp.dcloud.io/component/navigator" target="_blank" rel="noopener">navigator</a></li>
<li>img 改成 <a href="https://uniapp.dcloud.io/component/image" target="_blank" rel="noopener">image</a></li>
<li><a href="https://uniapp.dcloud.io/component/input" target="_blank" rel="noopener">input</a> 还在，但 type 属性改成了 confirmtype</li>
<li><a href="https://uniapp.dcloud.io/component/form" target="_blank" rel="noopener">form</a>、<a href="https://uniapp.dcloud.io/component/button" target="_blank" rel="noopener">button</a>、<a href="https://uniapp.dcloud.io/component/checkbox" target="_blank" rel="noopener">checkbox</a>、<a href="https://uniapp.dcloud.io/component/radio" target="_blank" rel="noopener">radio</a>、<a href="https://uniapp.dcloud.io/component/label" target="_blank" rel="noopener">label</a>、<a href="https://uniapp.dcloud.io/component/textarea" target="_blank" rel="noopener">textarea</a>、<a href="https://uniapp.dcloud.io/component/canvas" target="_blank" rel="noopener">canvas</a>、<a href="https://uniapp.dcloud.io/component/video" target="_blank" rel="noopener">video</a> 这些还在。</li>
<li>select 改成 <a href="https://uniapp.dcloud.io/component/picker" target="_blank" rel="noopener">picker</a></li>
<li>iframe 改成 <a href="https://uniapp.dcloud.io/component/web-view" target="_blank" rel="noopener">web-view</a></li>
<li>ul、li 没有了，都用 view 替代</li>
<li>audio 不再推荐使用，改成 api 方式，<a href="https://uniapp.dcloud.io/api/media/background-audio-manager?id=getbackgroundaudiomanager" target="_blank" rel="noopener">背景音频 api 文档</a></li>
</ul>
<p><strong>除了改动外，新增了一批手机端常用的新组件</strong><br>**</p>
<ul>
<li>scroll-view <a href="https://uniapp.dcloud.io/component/scroll-view" target="_blank" rel="noopener">可区域滚动视图容器</a></li>
<li>swiper <a href="https://uniapp.dcloud.io/component/swiper" target="_blank" rel="noopener">可滑动区域视图容器</a></li>
<li>icon <a href="https://uniapp.dcloud.io/component/icon" target="_blank" rel="noopener">图标</a></li>
<li>rich-text <a href="https://uniapp.dcloud.io/component/rich-text" target="_blank" rel="noopener">富文本（不可执行 js，但可渲染各种文字格式和图片）</a></li>
<li>progress <a href="https://uniapp.dcloud.io/component/progress" target="_blank" rel="noopener">进度条</a></li>
<li>slider <a href="https://uniapp.dcloud.io/component/slider" target="_blank" rel="noopener">滑块指示器</a></li>
<li>switch <a href="https://uniapp.dcloud.io/component/switch" target="_blank" rel="noopener">开关选择器</a></li>
<li>camera <a href="https://uniapp.dcloud.io/component/camera" target="_blank" rel="noopener">相机</a></li>
<li>live-player <a href="https://uniapp.dcloud.io/component/live-player" target="_blank" rel="noopener">直播</a></li>
<li>map <a href="https://uniapp.dcloud.io/component/map" target="_blank" rel="noopener">地图</a></li>
<li>cover-view <a href="https://uniapp.dcloud.io/component/cover-view?id=cover-view" target="_blank" rel="noopener">可覆盖原生组件的视图容器</a><br>cover-view 需要多强调几句，uni-app 的非 h5 端的 video、map、canvas、textarea 是原生组件，层级高于其他组件。如需覆盖原生组件，则需要使用 cover-view 组件。详见<a href="https://uniapp.dcloud.net.cn/component/native-component" target="_blank" rel="noopener">层级介绍</a></li>
</ul>
<p>除了内置组件，还有很多开源的扩展组件，把常用操作都进行封装，DCloud 建立了插件市场收录这些扩展组件，详见<a href="https://ext.dcloud.net.cn/" target="_blank" rel="noopener">插件市场</a></p>
<p>**</p>
<h3 id="工程结构和页面管理"><a href="#工程结构和页面管理" class="headerlink" title="工程结构和页面管理"></a>工程结构和页面管理</h3><p>uni-app 的工程结构有单独的要求，<a href="https://uniapp.dcloud.io/frame?id=%e7%9b%ae%e5%bd%95%e7%bb%93%e6%9e%84" target="_blank" rel="noopener">详见</a></p>
<p>每个可显示的页面，都必须在 <a href="https://uniapp.dcloud.io/collocation/pages" target="_blank" rel="noopener">pages.json</a> 中注册。如果你开发过小程序，那么 pages.json 类似 app.json。如果你熟悉 vue，这里没有 vue 的路由，都是在 pages.json 里管理。</p>
<p>原来工程的首页一般是 index.html 或 default.html，是在 web server 里配的。而 uni-app 的首页，是在 pages.json 里配的，page 节点下第一个页面就是首页。一般在/pages/xx 的目录下。</p>
<p>app 和小程序中，为了提升体验，页面提供了原生的导航栏和底部 tabbar，注意这些配置是在 pages.json 中做，而不是在 vue 页面里创建，但点击事件的监听在显示的 vue 页面中做。</p>
<p>如果你熟悉小程序开发的话，对比变化如下：</p>
<ul>
<li>原来 app.json 被一拆为二。页面管理，被挪入了 uni-app 的 pages.json；非页面管理，挪入了 manifest.json</li>
<li>原来的 app.js 和 app.wxss 被合并到了 app.vue 中</li>
</ul>
<h2 id="文件导入方式变化"><a href="#文件导入方式变化" class="headerlink" title="文件导入方式变化"></a>文件导入方式变化</h2><h3 id="js-引入方式"><a href="#js-引入方式" class="headerlink" title="js 引入方式"></a>js 引入方式</h3><p>以前通过<code>script `</code>src <code>、</code> link <code></code>href <code>引入外部的 js 和 css；
现在是**es6**的写法，</code>import`引入外部的 js 模块(注意不是文件)或 css<br>以前</p>
<pre><code class="javascript">&lt;script src=&quot;js/jquery-1.10.2.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;
&lt;link href=&quot;css/bootstrap.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot;/&gt;
</code></pre>
<p>现在</p>
<blockquote>
<p>js 要 require 进来，变成了对象。</p>
</blockquote>
<p>在 hello uni-app 项目的 common 目录有一个工具类<code>util.js</code>，可以在 hello uni-app 中搜索这个例子查看。</p>
<pre><code class="javascript">&lt;script&gt;
  var util = require(&#39;../../../common/util.js&#39;); //require这个js模块 var
  formatedPlayTime = util.formatTime(playTime); //调用js模块的方法
&lt;/script&gt;
</code></pre>
<p>而在这个<code>util.js</code>里，要把之前的 function 封装为对象的方法<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1604048264989-b4591bb0-e4bc-4581-aae5-bf7615f268b4.png#align=left&amp;display=inline&amp;height=231&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=606&amp;originWidth=1331&amp;size=70716&amp;status=done&amp;style=shadow&amp;width=508" alt="image.png"><br>当然还有一些高级的用法</p>
<pre><code class="javascript">var dateUtils = require(&quot;../../../common/util.js&quot;).dateUtils; //直接使用js模块的属性。在hello uni-app有示例
import * as echarts from &quot;/components/echarts/echarts.simple.min.js&quot;; //将js导入并重命名为echarts，然后使用echarts.来继续执行方法。
</code></pre>
<h3 id="CSS-引入方式"><a href="#CSS-引入方式" class="headerlink" title="CSS 引入方式"></a>CSS 引入方式</h3><pre><code class="css">&lt;style&gt;
    @import &quot;./common/uni.css&quot;;
    .uni-hello-text{
        color:#7A7E83;
    }
&lt;/style&gt;
</code></pre>
<p><strong>改全局样式：</strong>在根目录下的 app.vue 里写入，每个页面都会加载 app.vue 里的样式。</p>
<h3 id="组件导入"><a href="#组件导入" class="headerlink" title="组件导入"></a>组件导入</h3><p>类似 hexo 博客主题设计一样，能以组件的形式模块化导入。<br>如下是导入一个角标的组件库，在页面上显示一个 abc 并且右上角有个数字角标 1，<a href="http://ext.dcloud.net.cn/plugin?id=21" target="_blank" rel="noopener">详见</a></p>
<pre><code class="vue">&lt;template&gt;
  &lt;view&gt;
    &lt;uni-badge text=&quot;abc&quot; :inverted=&quot;true&quot;&gt;&lt;/uni-badge
    &gt;&lt;!--3.使用组件--&gt;
  &lt;/view&gt;
&lt;/template&gt;
&lt;script&gt;
import uniBadge from &quot;../../../components/uni-badge.vue&quot;; //1.导入组件（这步属于传统vue规范，但在uni-app的easycom下可以省略这步）
export default {
  data() {
    return {};
  },
  components: {
    uniBadge, //2.注册组件（这步属于传统vue规范，但在uni-app的easycom下可以省略这步）
  },
};
&lt;/script&gt;
</code></pre>
<p>如需要全局导入 vue 组件，即每个页面都可以直接使用而不用引用和注册的话，在项目根目录下的 main.js 里处理。如下是 hello uni-app 里的例子。</p>
<pre><code class="javascript">//main.js
import pageHead from &quot;./components/page-head.vue&quot;; //导入
Vue.component(&quot;page-head&quot;, pageHead); //注册。注册后在每个vue的page页面里可以直接使用&lt;page-head&gt;&lt;/page-head&gt;组件。
</code></pre>
<p>上述的组件使用方式属于传统 vue 的概念。uni-app 2.7 以后推出了更简单的组件使用技术<a href="https://uniapp.dcloud.net.cn/collocation/pages?id=easycom" target="_blank" rel="noopener">easycom</a>，无需引用和注册组件，直接在 template 区域使用组件即可。</p>
<h2 id="js-的变化"><a href="#js-的变化" class="headerlink" title="js 的变化"></a>js 的变化</h2><p>js 的变化，分为<strong>运行环境变化</strong>、<strong>数据绑定模式变化</strong>、<strong>api 变化</strong>3 部分。</p>
<h3 id="运行环境从浏览器变成-v8-引擎"><a href="#运行环境从浏览器变成-v8-引擎" class="headerlink" title="运行环境从浏览器变成 v8 引擎"></a>运行环境从浏览器变成 v8 引擎</h3><p>标准 js 语法和 api 都支持，比如 if、for、settimeout、indexOf 等。</p>
<p>但<strong>浏览器专用的</strong>window、document、navigator、location 对象，包括 cookie 等存储，<strong>只有在浏览器中才有</strong>，app 和小程序都不支持。</p>
<blockquote>
<p>可能有些人以为 js 等于浏览器里的 js。其实 js 是 ECMAScript 组织管理的，浏览器中的 js 是 w3c 组织基于 js 规范补充了 window、document、navigator、location 等专用对象。</p>
</blockquote>
<p>在 uni-app 的各个端中，除了 h5 端，其他端的 js 都运行在一个独立的 v8 引擎下，不是在浏览器中，所以浏览器的对象无法使用。如果你做过小程序开发，对此应当很了解。<br><strong>这意味着依赖 document 的很多 HTML 的库，比如 jqurey 无法使用。</strong><br>当然 app 和小程序支持 web-view 组件，里面可以加载标准 HTML，这种页面仍然支持浏览器专用对象 window、document、navigator、location。</p>
<h3 id="以前的-dom-操作，改成-vue-的-MVVM-模式"><a href="#以前的-dom-操作，改成-vue-的-MVVM-模式" class="headerlink" title="以前的 dom 操作，改成 vue 的 MVVM 模式"></a>以前的 dom 操作，改成 vue 的 MVVM 模式</h3><p>现在前端趋势是去 dom 化，改用<strong>mvvm 模式，</strong>更简洁的写法，大幅减少代码行数，同时差量渲染性能更好。<br>uni-app 使用 vue 的数据绑定方式解决 js 和 dom 界面交互的问题。<br>如果你想改变某个 dom 元素的显示内容，比如一个 view 的显示文字：<br><strong>以前</strong>是给 view 设 id，然后 js 里通过选择器获取 dom 元素，进一步通过 js 进行赋值操作，修改 dom 元素的属性或值。<br>如下演示了一段代码，页面中有个显示的文字区和一个按钮，点击按钮后会修改文字区的值</p>
<pre><code class="html">&lt;html&gt;
  &lt;head&gt;
    &lt;script type=&quot;text/javascript&quot;&gt;
      document.addEventListener(&quot;DOMContentLoaded&quot;, function () {
        document.getElementById(&quot;spana&quot;).innerText = &quot;456&quot;;
      });
      function changetextvalue() {
        document.getElementById(&quot;spana&quot;).innerText = &quot;789&quot;;
      }
    &lt;/script&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;span id=&quot;spana&quot;&gt;123&lt;/span&gt;
    &lt;button type=&quot;button&quot; onclick=&quot;changetextvalue()&quot;&gt;修改为789&lt;/button&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>现在的做法，是<strong>vue 的绑定模式</strong>，给这个<strong>dom 元素绑定一个 js 变量</strong>，在 script 中修改 js 变量的值，dom 会自动变化，页面会自动更新渲染</p>
<pre><code class="vue">&lt;template&gt;
  &lt;view&gt;
    &lt;text&gt;{{ textvalue }}&lt;/text
    &gt;&lt;!-- 这里演示了组件值的绑定 --&gt;
    &lt;button :type=&quot;buttontype&quot; @click=&quot;changetextvalue()&quot;&gt;修改为789&lt;/button
    &gt;&lt;!-- 这里演示了属性和事件的绑定 --&gt;
  &lt;/view&gt;
&lt;/template&gt;
&lt;script&gt;
export default {
  data() {
    return {
      textvalue: &quot;123&quot;,
      buttontype: &quot;primary&quot;,
    };
  },
  onLoad() {
    this.textvalue = &quot;456&quot;; //这里修改textvalue的值，其实123都来不及显示就变成了456
  },
  methods: {
    changetextvalue() {
      this.textvalue = &quot;789&quot;; //这里修改textvalue的值，页面自动刷新为789
    },
  },
};
&lt;/script&gt;
</code></pre>
<p>注意上述代码中的 <code>export default {}</code> 里的 <code>data(): {return { }}</code>。<br>在 vue 的设计中，这里存放着页面中需要绑定的数据，写在 data 里，才能被界面正确的绑定和渲染。<br>注意：uni-app 的 vue 页面是 vue 的单文件组件规范，按照 vue 的定义只接受 function，必须用 return 包起来。<br>如果你学过小程序的数据绑定，但不了解 vue，要注意：</p>
<ul>
<li>小程序的数据绑定参考了 vue，但自己修改了一些。在 uni-app 中只支持标准的 vue，不支持小程序的数据绑定语法</li>
<li>小程序里的 setData 在 uni-app 里并不存在，因为 vue 是自动双向数据绑定的。直接通过赋值方式修改数据，如果数据绑定到界面上，界面会自动更新渲染</li>
</ul>
<p>从上述示例，还可看出事件的写法变化。</p>
<ul>
<li>以前，元素的事件是用 onxxx=””，里面写一段 js 或引用 function 的 name，比如上述代码中的<code>onclick=&quot;changetextvalue()&quot;</code></li>
<li>现在，需要在 js 的<code>export default {}</code> 里的 <code>methods: {}</code> 里写一个方法，然后在组件中使用<code>@click=&quot;changetextvalue()&quot;</code></li>
</ul>
<p>在 js 中，与 data 和 methods 平级的，如上述示例代码中的<code>onload()</code>，称为生命周期。在普通 vue 页面里的生命周期叫页面生命周期。在项目根目录的 app.vue 文件中的生命周期叫应用生命周期。<br>除了<code>onload</code>，还有<code>onready</code>等很多生命周期，具体见<a href="https://uniapp.dcloud.io/collocation/frame/lifecycle" target="_blank" rel="noopener">uni-app 的生命周期</a><br>在高级用法里，<strong>vue 支持给组件设 ref（引用标记）</strong>，这类似于之前 html 中给一个 dom 元素设 id，然后在 js 中也可以用<code>this.$refs.xxx</code>来获取。如下：</p>
<pre><code class="vue">&lt;template&gt;
  &lt;view&gt;
    &lt;view ref=&quot;testview&quot;&gt;11111&lt;/view&gt;
    &lt;button @click=&quot;getTest&quot;&gt;获取test节点&lt;/button&gt;
  &lt;/view&gt;
&lt;/template&gt;
&lt;script&gt;
export default {
  methods: {
    getTest() {
      console.log(this.$refs.testview);
    },
  },
};
&lt;/script&gt;
</code></pre>
<h3 id="js-api-的变化"><a href="#js-api-的变化" class="headerlink" title="js api 的变化"></a>js api 的变化</h3><p>因为 uni-app 的 api 是<strong>参考小程序</strong>的，所以<strong>和浏览器的 js api</strong>有很多不同，如</p>
<ol>
<li>alert,confirm 改成 <a href="https://uniapp.dcloud.io/api/ui/prompt?id=showmodal" target="_blank" rel="noopener">uni.showmodel</a></li>
<li>ajax 改成 <a href="https://uniapp.dcloud.io/api/request/request" target="_blank" rel="noopener">uni.request</a></li>
<li>cookie、session 没有了，local.storage 改成 <a href="https://uniapp.dcloud.io/api/storage/storage?id=setstorage" target="_blank" rel="noopener">uni.storage</a></li>
</ol>
<p>uni-app 的 js api 还有很多，但基本就是小程序的 api，把 wx.xxx 改为 uni.xxx 即可。<a href="https://uniapp.dcloud.io/api/README" target="_blank" rel="noopener">详见</a><br>uni-app 在不同的端，支持条件编译，无限制的使用各端独有的 api，<a href="https://uniapp.dcloud.io/platform" target="_blank" rel="noopener">详见条件编译</a></p>
<h2 id="css-的变化"><a href="#css-的变化" class="headerlink" title="css 的变化"></a>css 的变化</h2><p><strong>标准的 css 基本都是支持的。</strong></p>
<h3 id="选择器方面"><a href="#选择器方面" class="headerlink" title="选择器方面"></a>选择器方面</h3><blockquote>
<p>有 2 个变化：</p>
</blockquote>
<ol>
<li>*选择器不支持；</li>
<li>元素选择器里没有 body，改为了 page。微信小程序即是如此。</li>
</ol>
<pre><code class="css">page {
}
</code></pre>
<ul>
<li><strong>单位方面：</strong>px 无法动态适应不同宽度的屏幕，rem 无法用于 nvue/weex。如果想使用根据屏幕宽度自适应的单位，推荐使用 rpx，全端支持。 <a href="https://uniapp.dcloud.io/frame?id=%e5%b0%ba%e5%af%b8%e5%8d%95%e4%bd%8d" target="_blank" rel="noopener">尺寸单位文档</a></li>
<li><strong>布局方面：</strong>uni-app 推荐使用 flex 布局，这个布局思路和传统流式布局有点区别。但 flex 的特色在于，不管是什么技术都支持这种排版，web、小程序/快应用、weex/rn、原生的 iOS、Android 开发，全都支持 flex。它是通吃所有端的新一代布局方案。相关教程请自行百度学习。</li>
</ul>
<h3 id="flex"><a href="#flex" class="headerlink" title="flex"></a>flex</h3><p>uni-app 的 vue 文件里支持所有 web 排版方式，不管是流式还是 flex。但 nvue 里，只支持 flex，因为它在 app 端是使用原生排版引擎渲染的。<br><strong>注意 css 里背景图和字体文件，尽量不要大于 40k，因为会影响性能。在小程序端，如果要大于 40k，需放到服务器侧远程引用或 base64 后引入，不能放到本地作为独立文件引用。</strong></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://uniapp.dcloud.net.cn/" target="_blank" rel="noopener">https://uniapp.dcloud.net.cn/</a></li>
<li><a href="https://cn.vuejs.org/index.html" target="_blank" rel="noopener">https://cn.vuejs.org/index.html</a></li>
<li>官方教程：<a href="https://ke.qq.com/course/343370" target="_blank" rel="noopener">uni-app 跨平台框架官方教程</a></li>
<li><a href="https://ask.dcloud.net.cn/article/35657" target="_blank" rel="noopener">白话 uni-app </a></li>
<li>微信官方文档：<a href="https://developers.weixin.qq.com/doc/" target="_blank" rel="noopener">https://developers.weixin.qq.com/doc/</a></li>
</ul>
]]></content>
      <categories>
        <category>Mobile</category>
      </categories>
  </entry>
  <entry>
    <title>利用WireShark捕获并分析以太网报文结构</title>
    <url>/blog/bw80k6/</url>
    <content><![CDATA[<blockquote>
<p>学习网络协议分析工具 WireShark，利用 WireShark 捕获并分析以太网报文结构，最重要的是后面超星网登录案例分析，用实际例子将计网的所学知识串起来。<br>文章更新内容说明：无线上网和有线上网的 MAC 地址是不一样的<br>【查看本地地址的截图是在家里的查看，wireshark 的使用是在学校】</p>
</blockquote>
<h2 id="查看信息"><a href="#查看信息" class="headerlink" title="查看信息"></a>查看信息</h2><h3 id="查看本地的-mac-地址"><a href="#查看本地的-mac-地址" class="headerlink" title="查看本地的 mac 地址"></a>查看本地的 mac 地址</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612839562082-cbc1fcf8-a520-4820-bafc-e26f07ba1177.png#align=left&amp;display=inline&amp;height=248&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=496&amp;originWidth=1920&amp;size=78833&amp;status=done&amp;style=shadow&amp;width=960" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612839610832-5568023d-da16-41af-b95e-1787acadf747.png#align=left&amp;display=inline&amp;height=402&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=804&amp;originWidth=1335&amp;size=109239&amp;status=done&amp;style=shadow&amp;width=667.5" alt="image.png"></p>
<h3 id="ping-命令"><a href="#ping-命令" class="headerlink" title="ping 命令"></a>ping 命令</h3><blockquote>
<p>先使用 ping 命令找到需要抓包的网站的 ip 地址</p>
</blockquote>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612845955475-12f08386-5ec4-4b3f-8cbf-56059d79677c.png#align=left&amp;display=inline&amp;height=162&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=323&amp;originWidth=828&amp;size=51064&amp;status=done&amp;style=shadow&amp;width=414" alt="image.png"></p>
<h2 id="WireShark-使用"><a href="#WireShark-使用" class="headerlink" title="WireShark 使用"></a>WireShark 使用</h2><h3 id="WireShark-使用及面板功能区域"><a href="#WireShark-使用及面板功能区域" class="headerlink" title="WireShark 使用及面板功能区域"></a>WireShark 使用及面板功能区域</h3><p>进入软件，若成功适配电脑网卡，则出现如下类似接口列表<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1603434019601-cc879af3-8784-4ada-83dc-642d64e02981.png#align=left&amp;display=inline&amp;height=329&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=1038&amp;originWidth=1920&amp;size=115692&amp;status=done&amp;style=shadow&amp;width=608" alt="image.png"><br>直接双击上图中 WLAN 行即可抓包，也可以如下设置网卡启动抓包<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1603434096441-73c67d75-4e36-4e76-ae3c-0a8b8976da28.png#align=left&amp;display=inline&amp;height=301&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=911&amp;originWidth=1920&amp;size=114148&amp;status=done&amp;style=shadow&amp;width=634" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1603431676018-f4988b52-5aef-4d92-8b9b-15109a08adab.png#align=left&amp;display=inline&amp;height=345&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=1033&amp;originWidth=1920&amp;size=207427&amp;status=done&amp;style=shadow&amp;width=641" alt="image.png"></p>
<h3 id="1-区域-显示过滤器"><a href="#1-区域-显示过滤器" class="headerlink" title="1 区域-显示过滤器"></a>1 区域-显示过滤器</h3><blockquote>
<p>为过滤 ip 地址区域。相关表达式语法有</p>
</blockquote>
<ol>
<li>协议过滤。比如 TCP，只显示 TCP 协议。</li>
<li>IP 过滤。比如 ip.src == 192.168.1.102,显示源地址为 192.168.1.102，</li>
</ol>
<p>ip.dst == 192.168.1.102, 目标地址为 192.168.1.102。</p>
<ol start="3">
<li>端口过滤。   tcp.port ==80,   端口为 80 的</li>
</ol>
<p>tcp.srcport == 80,只显示 TCP 协议的愿端口为 80 的。</p>
<ol start="4">
<li>Http 模式过滤。http.request.method==”GET”,   只显示 HTTP GET 方法的。</li>
<li>逻辑运算符为 AND/ OR</li>
</ol>
<h3 id="2-区域-获取的数据包"><a href="#2-区域-获取的数据包" class="headerlink" title="2 区域-获取的数据包"></a>2 区域-获取的数据包</h3><blockquote>
<p>封包列表(Packet List Pane)</p>
</blockquote>
<h3 id="3-区域-单个数据包各层详细内容"><a href="#3-区域-单个数据包各层详细内容" class="headerlink" title="3 区域-单个数据包各层详细内容"></a>3 区域-单个数据包各层详细内容</h3><blockquote>
<p>选定的封包详细信息 (Packet Details Pane)</p>
</blockquote>
<ol>
<li>Frame:物理层的数据帧概况。</li>
</ol>
<pre><code class="http">Frame 165: 74 bytes on wire (592 bits), 74 bytes captured (592 bits) on interface \Device\NPF_{B016AB5D-3088-41BD-8997-48F19D9DEBFA}, id 0 //165号帧，对方发送74字节，实际收到74字节
    Interface id: 0 (\Device\NPF_{B016AB5D-3088-41BD-8997-48F19D9DEBFA}) //接口id为0
        Interface name: \Device\NPF_{B016AB5D-3088-41BD-8997-48F19D9DEBFA}
        Interface description: WLAN
    Encapsulation type: Ethernet (1) //封装类型
    Arrival Time: Oct 23, 2020 13:37:43.372763000 中国标准时间//捕获日期和时间（中国标准时间）
    [Time shift for this packet: 0.000000000 seconds]
    Epoch Time: 1603431463.372763000 seconds
    [Time delta from previous captured frame: 0.008472000 seconds]//与前一包时间间隔
    [Time delta from previous displayed frame: 0.000000000 seconds]
    [Time since reference or first frame: 36.349570000 seconds]//此包与第一帧的时间间隔
    Frame Number: 165//帧序号
    Frame Length: 74 bytes (592 bits)//帧长度
    Capture Length: 74 bytes (592 bits)//捕获字节长度
    [Frame is marked: False]//是否做了标记
    [Frame is ignored: False]//是否被忽略
    [Protocols in frame: eth:ethertype:ip:icmp:data]//帧内封装的协议层次结构
    [Coloring Rule Name: ICMP]//着色标记的协议名称
    [Coloring Rule String: icmp || icmpv6]//着色规则显示的字符串
</code></pre>
<ol start="2">
<li>Ethernet II:数据链路层以太网帧头部信息。</li>
</ol>
<pre><code class="http">Ethernet II, Src: IntelCor_fb:33:94 (0c:54:15:fb:33:94), Dst: HuaweiTe_da:ff:f3 (7c:a1:77:da:ff:f3)
    Destination: HuaweiTe_da:ff:f3 (7c:a1:77:da:ff:f3)//目的MAC地址
    Source: IntelCor_fb:33:94 (0c:54:15:fb:33:94)//源MAC地址（就是我电脑的MAC地址）
    Type: IPv4 (0x0800)//0x0800表示使用IP协议
</code></pre>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1603432754493-20843464-3bbb-4c01-9ceb-e781759a583d.png#align=left&amp;display=inline&amp;height=280&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=559&amp;originWidth=1920&amp;size=110051&amp;status=done&amp;style=shadow&amp;width=960" alt="image.png"></p>
<ol start="3">
<li>Internet Protocol Version 4:互联网层 IP 包头部信息。</li>
</ol>
<pre><code class="http">Internet Protocol Version 4, Src: 192.168.43.36, Dst: 39.156.66.18
    0100 .... = Version: 4//互联网协议IPv4
    .... 0101 = Header Length: 20 bytes (5)//IP包头部长度
    Differentiated Services Field: 0x00 (DSCP: CS0, ECN: Not-ECT)//差分服务字段
    Total Length: 60//IP包的总长度
    Identification: 0xdf8c (57228)//标志字段
    Flags: 0x0000//标记字段
    Fragment offset: 0//分的偏移量
    Time to live: 128//生存期TTL
    Protocol: ICMP (1)//此包内封装的上层协议为TCP
    Header checksum: 0x05ba [validation disabled]//头部数据的校验和
    [Header checksum status: Unverified]
    Source: 192.168.43.36//来源IP地址
    Destination: 39.156.66.18//目标IP地址
</code></pre>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1603433033837-c88714a1-eaa1-45cb-b836-5672e4515eee.png#align=left&amp;display=inline&amp;height=189&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=378&amp;originWidth=640&amp;size=84901&amp;status=done&amp;style=shadow&amp;width=320" alt="image.png"></p>
<ol start="4">
<li>Transmission Control Protocol:传输层 T 的数据段头部信息，此处是 TCP。</li>
</ol>
<pre><code class="http">Transmission Control Protocol, Src Port: 80 (80), Dst Port: 50362 (50362), Seq: 1025, Ack: 447, Len: 714
Source Port: 80 (80) //源端口号
Destination Port: 50362 (50362) //目标端口号
Sequence number: 1025 (relative sequence number) //序列号（相对序列号）
[Next sequence number: 1739 (relative sequence number)] //下一个序列号
Acknowledgment number: 447    (relative ack number) //确认序列号
Header Length: 20 bytes  //头部长度
.... 0000 0001 1000 = Flags: 0x018 (PSH, ACK) //TCP标记长度
Window size value: 5896  //流量控制的窗口大小
Checksum: 0x915b [validation disabled] //TCP数据段的校验和
</code></pre>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1603433149527-0125377e-b64b-4e32-9eb0-e122d0c111cb.png#align=left&amp;display=inline&amp;height=190&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=379&amp;originWidth=579&amp;size=89043&amp;status=done&amp;style=shadow&amp;width=289.5" alt="image.png"></p>
<ol start="5">
<li><p>Hypertext Transfer Protocol:应用层的信息，此处是 HTTP 协议。</p>
</li>
<li><p>Data（312 bytes）：数据。</p>
</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1603434354567-45e84cc7-63a9-4136-adde-85c377345e92.png#align=left&amp;display=inline&amp;height=147&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=347&amp;originWidth=1920&amp;size=49744&amp;status=done&amp;style=shadow&amp;width=813" alt="image.png"></p>
<h2 id="超星网登录案例分析"><a href="#超星网登录案例分析" class="headerlink" title="超星网登录案例分析"></a>超星网登录案例分析</h2><h3 id="网站请求和响应"><a href="#网站请求和响应" class="headerlink" title="网站请求和响应"></a>网站请求和响应</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612849248230-2f38b355-ee1f-4ee1-8b8a-291e64f4e1bd.png#align=left&amp;display=inline&amp;height=356&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=711&amp;originWidth=1920&amp;size=230540&amp;status=done&amp;style=none&amp;width=960" alt="image.png"></p>
<h3 id="发送请求相应协议"><a href="#发送请求相应协议" class="headerlink" title="发送请求相应协议"></a>发送请求相应协议</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612849740094-cbdefdda-f504-43f3-9e41-ac8dc8029fd3.png#align=left&amp;display=inline&amp;height=440&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=880&amp;originWidth=1920&amp;size=208371&amp;status=done&amp;style=none&amp;width=960" alt="image.png"></p>
<h3 id="收到响应相应协议"><a href="#收到响应相应协议" class="headerlink" title="收到响应相应协议"></a>收到响应相应协议</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612849811431-437bd72d-ac54-4c28-b731-9e128b6b998f.png#align=left&amp;display=inline&amp;height=441&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=881&amp;originWidth=1918&amp;size=151717&amp;status=done&amp;style=stroke&amp;width=959" alt="image.png"></p>
<blockquote>
<p>接下来的 7 个小节内容来具体对数据报头做出分析 ❗</p>
</blockquote>
<h3 id="Hypertext-Transfer-Protocol"><a href="#Hypertext-Transfer-Protocol" class="headerlink" title="Hypertext Transfer Protocol"></a>Hypertext Transfer Protocol</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612849851243-b18b3e15-f21e-4998-bcfe-45c0b92aabde.png#align=left&amp;display=inline&amp;height=339&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=678&amp;originWidth=1920&amp;size=99636&amp;status=done&amp;style=shadow&amp;width=960" alt="image.png"></p>
<blockquote>
<p>HTTP 协议定义了客户端和服务器之间交互的消息内容和步骤，大家按照固定的步骤和格式进行通信<br>根据 URL 可以定位请求资源的位置，但是对于这个资源可能还有多种处理方法，比如是请求资源还是要删除指定资源？</p>
</blockquote>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612851558692-ed870a9e-f619-4235-bb98-85d22557340f.png#align=left&amp;display=inline&amp;height=493&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=985&amp;originWidth=1920&amp;size=489577&amp;status=done&amp;style=none&amp;width=960" alt="image.png"><br>这个时候<strong>浏览器</strong>将需要请求的信息，按照 HTTP 协议约定的格式，封装成为 HTTP 请求报文<br>HTTP 主要请求方法为 GET 和 POST<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612851687862-c1a44f57-065b-4547-93bb-4ae9b1f9cb95.png#align=left&amp;display=inline&amp;height=190&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=379&amp;originWidth=693&amp;size=117900&amp;status=done&amp;style=shadow&amp;width=346.5" alt="image.png"></p>
<blockquote>
<p>请求报文和响应报文的具体形式参考课本</p>
</blockquote>
<h3 id="Line-based-text-data"><a href="#Line-based-text-data" class="headerlink" title="Line-based text data"></a>Line-based text data</h3><p>这里面内容就是请求成功所返回的 Html 代码<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612851995920-233bc149-948d-43e1-a549-fc2887c23163.png#align=left&amp;display=inline&amp;height=353&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=706&amp;originWidth=1920&amp;size=159705&amp;status=done&amp;style=none&amp;width=960" alt="image.png"></p>
<h3 id="Transmission-Control-Protocol"><a href="#Transmission-Control-Protocol" class="headerlink" title="Transmission Control Protocol"></a>Transmission Control Protocol</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612852359910-50409417-8113-4600-bbb6-6d0e02db4894.png#align=left&amp;display=inline&amp;height=356&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=712&amp;originWidth=1920&amp;size=104306&amp;status=done&amp;style=none&amp;width=960" alt="image.png"><br>这个数据报传输使用的可靠的 TCP 协议，而不是 UDP，所以会有相应的滑动窗口、流量控制等等相关机制，还有三次握手，四次挥手……<br>（插个眼，日后再复习一下……）<br><img src="https://cdn.nlark.com/yuque/0/2021/gif/1484158/1612852762215-ba49fa51-55e0-440d-afa7-b567540e39a2.gif#align=left&amp;display=inline&amp;height=151&amp;margin=%5Bobject%20Object%5D&amp;name=huaji-779c5947261d2633.gif&amp;originHeight=151&amp;originWidth=218&amp;size=163714&amp;status=done&amp;style=none&amp;width=218" alt="huaji-779c5947261d2633.gif"><br>（插眼专用图/滑稽）</p>
<h3 id="Internet-Protocol-Version-4"><a href="#Internet-Protocol-Version-4" class="headerlink" title="Internet Protocol Version 4"></a>Internet Protocol Version 4</h3><p>好了，接下来到了 IP 层，需要给上面来的数据报加上 IP 头部，IP 数据报结构如下：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612853140617-ff243167-abb7-4c65-b5c3-b0bbaa77b5aa.png#align=left&amp;display=inline&amp;height=237&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=474&amp;originWidth=892&amp;size=244750&amp;status=done&amp;style=stroke&amp;width=446" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612853444183-7fa048ef-3e75-4586-82a7-ac9cc58c3630.png#align=left&amp;display=inline&amp;height=203&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=405&amp;originWidth=1920&amp;size=105587&amp;status=done&amp;style=stroke&amp;width=960" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612852425531-82ec984f-ac3b-4f8a-a06e-0c48080815f6.png#align=left&amp;display=inline&amp;height=353&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=706&amp;originWidth=1920&amp;size=107520&amp;status=done&amp;style=none&amp;width=960" alt="image.png"><br>比如说<code>45</code>这个字节这具体表现是 ip 数据报的第一行和第二行的具体信息，IP 版本为 IPv4，报头长度为二十个字节，往后的各个字段都是这样一一对应的关系，具体还要加强对那张 ip 数据报结构图的理解，要了然于胸。</p>
<h3 id="Ethernet-II-Src"><a href="#Ethernet-II-Src" class="headerlink" title="Ethernet II, Src"></a>Ethernet II, Src</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612853924295-ea6fe64c-bc90-4e49-ad4e-5ff212448fdc.png#align=left&amp;display=inline&amp;height=214&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=428&amp;originWidth=904&amp;size=226429&amp;status=done&amp;style=stroke&amp;width=452" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612850191706-18807d7d-16b5-44fa-a436-5c2b7c4ed5ed.png#align=left&amp;display=inline&amp;height=321&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=641&amp;originWidth=1920&amp;size=151109&amp;status=done&amp;style=none&amp;width=960" alt="image.png"></p>
<blockquote>
<p>图中三个方框的 14 个字节对应以太网 MAC 帧的前 14 个字节：前 6 个字节是目的地址，接下来的 6 个字节是源地址，最后两个字节是类型字段(用来标志上一层使用的是什么协议，以便把收到的 MAC 帧的数据交给上一层的这个协议。0x8000 代表上层使用的是 IP 数据报)，后面是数据部分。<br>另外：wireshark 把 8 字节的前序（前同步码）和 4 字节的 FCS（帧开始界定符）都给过滤掉了，所以捕获到的帧里看不到这两部分。</p>
</blockquote>
<h3 id="Frame-75"><a href="#Frame-75" class="headerlink" title="Frame 75"></a>Frame 75</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612852486656-87756b19-ff3d-4833-9af9-d2006a401068.png#align=left&amp;display=inline&amp;height=353&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=706&amp;originWidth=1920&amp;size=135359&amp;status=done&amp;style=none&amp;width=960" alt="image.png"></p>
<ul>
<li>对方发送 5520 字节，实际收到 5520 字节</li>
<li>第一行表示接口位 0 号</li>
</ul>
<h3 id="总体数据表示"><a href="#总体数据表示" class="headerlink" title="总体数据表示"></a>总体数据表示</h3><p>其实在计算机看来，网络中的数据传输就是传输下面的这些字节</p>
<blockquote>
<p>一个字节由八个位组成，而位就是我们通常所说的二进制中的 0 或 1</p>
</blockquote>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612852578885-9519d1d0-a72d-409b-a480-f8554b87fd0d.png#align=left&amp;display=inline&amp;height=299&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=598&amp;originWidth=1918&amp;size=138039&amp;status=done&amp;style=stroke&amp;width=959" alt="image.png"></p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><h3 id="Wireshark-抓不到-HTTPS-数据包"><a href="#Wireshark-抓不到-HTTPS-数据包" class="headerlink" title="Wireshark 抓不到 HTTPS 数据包"></a>Wireshark 抓不到 HTTPS 数据包</h3><blockquote>
<p>有些时候 HTTP 包也抓不到抑或是抓的不全，用如下方式解决即可。</p>
</blockquote>
<p>在 C 盘根目录下创建如下目录和文件，.log 就是后缀不要 txt<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612847971131-6c3c2084-c6d8-41ae-8a82-8a4df65748b8.png#align=left&amp;display=inline&amp;height=112&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=224&amp;originWidth=811&amp;size=14570&amp;status=done&amp;style=shadow&amp;width=405.5" alt="image.png"><br>添加环境变量<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612848066208-6f22250b-e74d-4156-aa31-c5de17d2e812.png#align=left&amp;display=inline&amp;height=236&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=471&amp;originWidth=968&amp;size=35366&amp;status=done&amp;style=none&amp;width=484" alt="image.png"><br>进入 wireshark 软件<br><code>编辑 `</code>首选项 <code></code>Protocols`<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612848155164-ace1e002-1971-4910-8d04-cf9c388eb5cd.png#align=left&amp;display=inline&amp;height=496&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=992&amp;originWidth=1362&amp;size=89975&amp;status=done&amp;style=none&amp;width=681" alt="image.png"></p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul>
<li><a href="https://www.cnblogs.com/linyfeng/p/9496126.html" target="_blank" rel="noopener">wireshark 抓包新手使用教程</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/82498482" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/82498482</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/264942536" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/264942536</a></li>
<li><a href="https://blog.csdn.net/zam183/article/details/103783785" target="_blank" rel="noopener">https://blog.csdn.net/zam183/article/details/103783785</a></li>
<li>TODO: <a href="https://www.cnblogs.com/zhaopei/p/12152139.html#autoid-2-6" target="_blank" rel="noopener">Wireshark 抓包，带你快速入门</a></li>
<li>TODO: <a href="https://www.cnblogs.com/noteless/p/10256470.html#21" target="_blank" rel="noopener">网络是如何连接的？网络发展简介（四）</a></li>
</ul>
]]></content>
      <categories>
        <category>计算机系统</category>
      </categories>
  </entry>
  <entry>
    <title>数据的本地读取</title>
    <url>/blog/lb8ugs/</url>
    <content><![CDATA[<h2 id="一、TXT-文件操作"><a href="#一、TXT-文件操作" class="headerlink" title="一、TXT 文件操作"></a>一、TXT 文件操作</h2><h3 id="读取全部内容"><a href="#读取全部内容" class="headerlink" title="读取全部内容"></a>读取全部内容</h3><pre><code class="python">import numpy as np
import pandas as pd
</code></pre>
<pre><code class="python">txt_filename = &#39;./files/python_wiki.txt&#39;

# 打开文件
file_obj = open(txt_filename,&#39;r&#39;)

# 读取整个文件内容
all_content = file_obj.read()

# 关闭文件
file_obj.close()

print (all_content)
</code></pre>
<pre><code>Python is a widely used high-level, general-purpose, interpreted, dynamic programming language.[24][25] Its design philosophy emphasizes code readability, and its syntax allows programmers to express concepts in fewer lines of code than possible in languages such as C++ or Java.[26][27] The language provides constructs intended to enable writing clear programs on both a small and large scale.[28]
Python supports multiple programming paradigms, including object-oriented, imperative and functional programming or procedural styles. It features a dynamic type system and automatic memory management and has a large and comprehensive standard library.[29]
Python interpreters are available for many operating systems, allowing Python code to run on a wide variety of systems. CPython, the reference implementation of Python, is open source software[30] and has a community-based development model, as do nearly all of its variant implementations. CPython is managed by the non-profit Python Software Foundation.
</code></pre><h3 id="逐行读取"><a href="#逐行读取" class="headerlink" title="逐行读取"></a>逐行读取</h3><pre><code class="python">txt_filename = &#39;./files/python_wiki.txt&#39;

# 打开文件
file_obj = open(txt_filename, &#39;r&#39;)

# 逐行读取
line1 = file_obj.readline()
print (line1)
</code></pre>
<pre><code>Python is a widely used high-level, general-purpose, interpreted, dynamic programming language.[24][25] Its design philosophy emphasizes code readability, and its syntax allows programmers to express concepts in fewer lines of code than possible in languages such as C++ or Java.[26][27] The language provides constructs intended to enable writing clear programs on both a small and large scale.[28]
</code></pre><pre><code class="python"># 继续读下一行【不会全部读完】
line2 = file_obj.readline()
print (line2)

# 关闭文件
file_obj.close()
</code></pre>
<pre><code>Python supports multiple programming paradigms, including object-oriented, imperative and functional programming or procedural styles. It features a dynamic type system and automatic memory management and has a large and comprehensive standard library.[29]
</code></pre><h3 id="读取全部内容，返回列表"><a href="#读取全部内容，返回列表" class="headerlink" title="读取全部内容，返回列表"></a>读取全部内容，返回列表</h3><pre><code class="python">txt_filename = &#39;./files/python_wiki.txt&#39;

# 打开文件
file_obj = open(txt_filename, &#39;r&#39;)

lines = file_obj.readlines()

for i, line in enumerate(lines):
    print (&#39;%i: %s&#39; %(i, line))

# 关闭文件
file_obj.close()
</code></pre>
<pre><code>0: Python is a widely used high-level, general-purpose, interpreted, dynamic programming language.[24][25] Its design philosophy emphasizes code readability, and its syntax allows programmers to express concepts in fewer lines of code than possible in languages such as C++ or Java.[26][27] The language provides constructs intended to enable writing clear programs on both a small and large scale.[28]

1: Python supports multiple programming paradigms, including object-oriented, imperative and functional programming or procedural styles. It features a dynamic type system and automatic memory management and has a large and comprehensive standard library.[29]

2: Python interpreters are available for many operating systems, allowing Python code to run on a wide variety of systems. CPython, the reference implementation of Python, is open source software[30] and has a community-based development model, as do nearly all of its variant implementations. CPython is managed by the non-profit Python Software Foundation.
</code></pre><h3 id="写操作"><a href="#写操作" class="headerlink" title="写操作"></a>写操作</h3><pre><code class="python">txt_filename = &#39;./files/test_write.txt&#39;

# 打开文件
file_obj = open(txt_filename, &#39;w&#39;)

# 写入全部内容
file_obj.write(&quot;《Python数据分析》&quot;)
file_obj.close()
</code></pre>
<pre><code class="python">txt_filename = &#39;./files/test_write.txt&#39;

# 打开文件
file_obj = open(txt_filename, &#39;w&#39;)

# 写入字符串列表
lines = [&#39;这是第%i行\n&#39; %n for n in range(10)]
file_obj.writelines(lines)
file_obj.close()
</code></pre>
<h3 id="with-语句"><a href="#with-语句" class="headerlink" title="with 语句"></a>with 语句</h3><pre><code class="python">txt_filename = &#39;./files/test_write.txt&#39;
with open(txt_filename, &#39;r&#39;) as f_obj:
    print (f_obj.read())
</code></pre>
<pre><code>这是第0行
这是第1行
这是第2行
这是第3行
这是第4行
这是第5行
这是第6行
这是第7行
这是第8行
这是第9行
</code></pre><h2 id="二、CSV-文件操作"><a href="#二、CSV-文件操作" class="headerlink" title="二、CSV 文件操作"></a>二、CSV 文件操作</h2><h3 id="pandas-读-csv-文件"><a href="#pandas-读-csv-文件" class="headerlink" title="pandas 读 csv 文件"></a>pandas 读 csv 文件</h3><blockquote>
<p>根据路径导入数据以及指定的列</p>
</blockquote>
<pre><code class="python">import pandas as pd
filename = &#39;./files/presidential_polls.csv&#39;
df = pd.read_csv(filename, usecols=[&#39;cycle&#39;, &#39;type&#39;, &#39;startdate&#39;])#导入指定列
print (type(df))
print (df.head())
</code></pre>
<pre><code>&lt;class &#39;pandas.core.frame.DataFrame&#39;&gt;
   cycle        type   startdate
0   2016  polls-plus  10/25/2016
1   2016  polls-plus  10/27/2016
2   2016  polls-plus  10/27/2016
3   2016  polls-plus  10/20/2016
4   2016  polls-plus  10/20/2016
</code></pre><blockquote>
<p>引用指定的列</p>
</blockquote>
<pre><code class="python">cycle_se = df[&#39;cycle&#39;]
print (type(cycle_se))
print (cycle_se.head())
</code></pre>
<pre><code>&lt;class &#39;pandas.core.series.Series&#39;&gt;
0    2016
1    2016
2    2016
3    2016
4    2016
Name: cycle, dtype: int64
</code></pre><blockquote>
<p>多层索引成 dataframe 类型</p>
</blockquote>
<pre><code class="python">filename = &#39;./files/presidential_polls.csv&#39;
df1 = pd.read_csv(filename,usecols=[&#39;cycle&#39;, &#39;type&#39;, &#39;startdate&#39;,&#39;state&#39;,&#39;grade&#39;],index_col = [&#39;state&#39;,&#39;grade&#39;])
print(df1.head())
</code></pre>
<pre><code>                cycle        type   startdate
state    grade
U.S.     B       2016  polls-plus  10/25/2016
         A+      2016  polls-plus  10/27/2016
Virginia A+      2016  polls-plus  10/27/2016
Florida  A       2016  polls-plus  10/20/2016
U.S.     B+      2016  polls-plus  10/20/2016
</code></pre><blockquote>
<p>跳过指定的行</p>
</blockquote>
<pre><code class="python">filename = &#39;./files/presidential_polls.csv&#39;
df2 = pd.read_csv(filename,usecols=[&#39;cycle&#39;, &#39;type&#39;, &#39;startdate&#39;,&#39;state&#39;,&#39;grade&#39;],skiprows=[1, 2, 3])
print(df2.head())
</code></pre>
<pre><code>   cycle        type         state   startdate grade
0   2016  polls-plus       Florida  10/20/2016     A
1   2016  polls-plus          U.S.  10/20/2016    B+
2   2016  polls-plus          U.S.  10/22/2016     A
3   2016  polls-plus          U.S.  10/26/2016    A-
4   2016  polls-plus  Pennsylvania  10/25/2016    B-
</code></pre><h3 id="pandas-写-csv-文件"><a href="#pandas-写-csv-文件" class="headerlink" title="pandas 写 csv 文件"></a>pandas 写 csv 文件</h3><blockquote>
<p>·to_csv 里面的 index 参数作用？===可能是不要索引的意思。</p>
</blockquote>
<pre><code class="python">filename = &#39;./files/pandas_output.csv&#39;
df.to_csv(filename, index=None)
</code></pre>
<h2 id="三、JSON-文件操作"><a href="#三、JSON-文件操作" class="headerlink" title="三、JSON 文件操作"></a>三、JSON 文件操作</h2><h3 id="json-读操作"><a href="#json-读操作" class="headerlink" title="json 读操作"></a>json 读操作</h3><pre><code class="python">import json

filename = &#39;./files/global_temperature.json&#39;
with open(filename, &#39;r&#39;) as f_obj:
    json_data = json.load(f_obj)

# 返回值是dict类型
print (type(json_data))
</code></pre>
<pre><code>&lt;class &#39;dict&#39;&gt;
</code></pre><pre><code class="python">print (json_data.keys())
</code></pre>
<pre><code>dict_keys([&#39;description&#39;, &#39;data&#39;])
</code></pre><h3 id="json-转-CSV"><a href="#json-转-CSV" class="headerlink" title="json 转 CSV"></a>json 转 CSV</h3><pre><code class="python">#print json_data[&#39;data&#39;].keys()
print (json_data[&#39;data&#39;].values())
</code></pre>
<pre><code>dict_values([&#39;-0.1247&#39;, &#39;-0.0707&#39;, &#39;-0.0710&#39;, &#39;-0.1481&#39;, &#39;-0.2099&#39;, &#39;-0.2220&#39;, &#39;-0.2101&#39;, &#39;-0.2559&#39;, &#39;-0.1541&#39;, &#39;-0.1032&#39;, &#39;-0.3233&#39;, &#39;-0.2552&#39;, &#39;-0.3079&#39;, &#39;-0.3221&#39;, &#39;-0.2828&#39;, &#39;-0.2279&#39;, &#39;-0.0971&#39;, &#39;-0.1232&#39;, &#39;-0.2578&#39;, &#39;-0.1172&#39;, &#39;-0.0704&#39;, &#39;-0.1471&#39;, &#39;-0.2535&#39;, &#39;-0.3442&#39;, &#39;-0.4240&#39;, &#39;-0.2967&#39;, &#39;-0.2208&#39;, &#39;-0.3767&#39;, &#39;-0.4441&#39;, &#39;-0.4332&#39;, &#39;-0.3862&#39;, &#39;-0.4367&#39;, &#39;-0.3318&#39;, &#39;-0.3205&#39;, &#39;-0.1444&#39;, &#39;-0.0747&#39;, &#39;-0.2979&#39;, &#39;-0.3193&#39;, &#39;-0.2118&#39;, &#39;-0.2082&#39;, &#39;-0.2152&#39;, &#39;-0.1517&#39;, &#39;-0.2318&#39;, &#39;-0.2161&#39;, &#39;-0.2510&#39;, &#39;-0.1464&#39;, &#39;-0.0618&#39;, &#39;-0.1506&#39;, &#39;-0.1749&#39;, &#39;-0.2982&#39;, &#39;-0.1016&#39;, &#39;-0.0714&#39;, &#39;-0.1214&#39;, &#39;-0.2481&#39;, &#39;-0.1075&#39;, &#39;-0.1445&#39;, &#39;-0.1173&#39;, &#39;-0.0204&#39;, &#39;-0.0318&#39;, &#39;-0.0157&#39;, &#39;0.0927&#39;, &#39;0.1974&#39;, &#39;0.1549&#39;, &#39;0.1598&#39;, &#39;0.2948&#39;, &#39;0.1754&#39;, &#39;-0.0013&#39;, &#39;-0.0455&#39;, &#39;-0.0471&#39;, &#39;-0.0550&#39;, &#39;-0.1579&#39;, &#39;-0.0095&#39;, &#39;0.0288&#39;, &#39;0.0997&#39;, &#39;-0.1118&#39;, &#39;-0.1305&#39;, &#39;-0.1945&#39;, &#39;0.0538&#39;, &#39;0.1145&#39;, &#39;0.0640&#39;, &#39;0.0252&#39;, &#39;0.0818&#39;, &#39;0.0924&#39;, &#39;0.1100&#39;, &#39;-0.1461&#39;, &#39;-0.0752&#39;, &#39;-0.0204&#39;, &#39;-0.0112&#39;, &#39;-0.0282&#39;, &#39;0.0937&#39;, &#39;0.0383&#39;, &#39;-0.0775&#39;, &#39;0.0280&#39;, &#39;0.1654&#39;, &#39;-0.0698&#39;, &#39;0.0060&#39;, &#39;-0.0769&#39;, &#39;0.1996&#39;, &#39;0.1139&#39;, &#39;0.2288&#39;, &#39;0.2651&#39;, &#39;0.3024&#39;, &#39;0.1836&#39;, &#39;0.3429&#39;, &#39;0.1510&#39;, &#39;0.1357&#39;, &#39;0.2308&#39;, &#39;0.3710&#39;, &#39;0.3770&#39;, &#39;0.2982&#39;, &#39;0.4350&#39;, &#39;0.4079&#39;, &#39;0.2583&#39;, &#39;0.2857&#39;, &#39;0.3420&#39;, &#39;0.4593&#39;, &#39;0.3225&#39;, &#39;0.5185&#39;, &#39;0.6335&#39;, &#39;0.4427&#39;, &#39;0.4255&#39;, &#39;0.5455&#39;, &#39;0.6018&#39;, &#39;0.6145&#39;, &#39;0.5806&#39;, &#39;0.6583&#39;, &#39;0.6139&#39;, &#39;0.6113&#39;, &#39;0.5415&#39;, &#39;0.6354&#39;, &#39;0.7008&#39;, &#39;0.5759&#39;, &#39;0.6219&#39;, &#39;0.6687&#39;, &#39;0.7402&#39;, &#39;0.8990&#39;])
</code></pre><pre><code class="python"># 转换key
year_str_lst = json_data[&#39;data&#39;].keys()
year_lst = [int(year_str) for year_str in year_str_lst]
print (year_lst)
</code></pre>
<pre><code>[1880, 1881, 1882, 1883, 1884, 1885, 1886, 1887, 1888, 1889, 1890, 1891, 1892, 1893, 1894, 1895, 1896, 1897, 1898, 1899, 1900, 1901, 1902, 1903, 1904, 1905, 1906, 1907, 1908, 1909, 1910, 1911, 1912, 1913, 1914, 1915, 1916, 1917, 1918, 1919, 1920, 1921, 1922, 1923, 1924, 1925, 1926, 1927, 1928, 1929, 1930, 1931, 1932, 1933, 1934, 1935, 1936, 1937, 1938, 1939, 1940, 1941, 1942, 1943, 1944, 1945, 1946, 1947, 1948, 1949, 1950, 1951, 1952, 1953, 1954, 1955, 1956, 1957, 1958, 1959, 1960, 1961, 1962, 1963, 1964, 1965, 1966, 1967, 1968, 1969, 1970, 1971, 1972, 1973, 1974, 1975, 1976, 1977, 1978, 1979, 1980, 1981, 1982, 1983, 1984, 1985, 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015]
</code></pre><pre><code class="python"># 转换value
temp_str_lst = json_data[&#39;data&#39;].values()
temp_lst = [float(temp_str) for temp_str in temp_str_lst]
print (temp_lst)
</code></pre>
<pre><code>[-0.1247, -0.0707, -0.071, -0.1481, -0.2099, -0.222, -0.2101, -0.2559, -0.1541, -0.1032, -0.3233, -0.2552, -0.3079, -0.3221, -0.2828, -0.2279, -0.0971, -0.1232, -0.2578, -0.1172, -0.0704, -0.1471, -0.2535, -0.3442, -0.424, -0.2967, -0.2208, -0.3767, -0.4441, -0.4332, -0.3862, -0.4367, -0.3318, -0.3205, -0.1444, -0.0747, -0.2979, -0.3193, -0.2118, -0.2082, -0.2152, -0.1517, -0.2318, -0.2161, -0.251, -0.1464, -0.0618, -0.1506, -0.1749, -0.2982, -0.1016, -0.0714, -0.1214, -0.2481, -0.1075, -0.1445, -0.1173, -0.0204, -0.0318, -0.0157, 0.0927, 0.1974, 0.1549, 0.1598, 0.2948, 0.1754, -0.0013, -0.0455, -0.0471, -0.055, -0.1579, -0.0095, 0.0288, 0.0997, -0.1118, -0.1305, -0.1945, 0.0538, 0.1145, 0.064, 0.0252, 0.0818, 0.0924, 0.11, -0.1461, -0.0752, -0.0204, -0.0112, -0.0282, 0.0937, 0.0383, -0.0775, 0.028, 0.1654, -0.0698, 0.006, -0.0769, 0.1996, 0.1139, 0.2288, 0.2651, 0.3024, 0.1836, 0.3429, 0.151, 0.1357, 0.2308, 0.371, 0.377, 0.2982, 0.435, 0.4079, 0.2583, 0.2857, 0.342, 0.4593, 0.3225, 0.5185, 0.6335, 0.4427, 0.4255, 0.5455, 0.6018, 0.6145, 0.5806, 0.6583, 0.6139, 0.6113, 0.5415, 0.6354, 0.7008, 0.5759, 0.6219, 0.6687, 0.7402, 0.899]
</code></pre><pre><code class="python">import pandas as pd

# 构建 dataframe
year_se = pd.Series(year_lst, name = &#39;year&#39;)
temp_se = pd.Series(temp_lst, name = &#39;temperature&#39;)
result_df = pd.concat([year_se, temp_se], axis = 1)
print (result_df.head())

# 保存csv
result_df.to_csv(&#39;./files/json_to_csv.csv&#39;, index = None)
</code></pre>
<pre><code>   year  temperature
0  1880      -0.1247
1  1881      -0.0707
2  1882      -0.0710
3  1883      -0.1481
4  1884      -0.2099
</code></pre><h3 id="写-json-操作"><a href="#写-json-操作" class="headerlink" title="写 json 操作"></a>写 json 操作</h3><pre><code class="python">book_dict = [{&#39;书名&#39;:&#39;无声告白&#39;, &#39;作者&#39;:&#39;伍绮诗&#39;}, {&#39;书名&#39;:&#39;我不是潘金莲&#39;, &#39;作者&#39;:&#39;刘震云&#39;}, {&#39;书名&#39;:&#39;沉默的大多数 (王小波集)&#39;, &#39;作者&#39;:&#39;王小波&#39;}]

filename = &#39;./files/json_output.json&#39;
with open(filename, &#39;w&#39;) as f_obj:
    f_obj.write(json.dumps(book_dict, ensure_ascii=False))
# 不需要加, encoding=&#39;utf-8&#39;参数
</code></pre>
<h2 id="四、SQLite-基本操作"><a href="#四、SQLite-基本操作" class="headerlink" title="四、SQLite 基本操作"></a>四、SQLite 基本操作</h2><h3 id="连接数据库"><a href="#连接数据库" class="headerlink" title="连接数据库"></a>连接数据库</h3><pre><code class="python">import sqlite3

db_path = &#39;./files/test.sqlite&#39;

conn = sqlite3.connect(db_path)
cur = conn.cursor()
conn.text_factory = str  # 处理中文
</code></pre>
<h3 id="获取基本信息"><a href="#获取基本信息" class="headerlink" title="获取基本信息"></a>获取基本信息</h3><pre><code class="python">cur.execute(&#39;SELECT SQLITE_VERSION()&#39;)

print (&#39;SQLite版本：%s&#39; %str(cur.fetchone()[0]))
</code></pre>
<pre><code>SQLite版本：3.30.0
</code></pre><h3 id="逐条插入数据"><a href="#逐条插入数据" class="headerlink" title="逐条插入数据"></a>逐条插入数据</h3><pre><code class="python">cur.execute(&quot;DROP TABLE IF EXISTS book&quot;)
cur.execute(&quot;CREATE TABLE book(id INT, name TEXT, price DOUBLE)&quot;)
cur.execute(&quot;INSERT INTO book VALUES(1,&#39;肖秀荣考研书系列:肖秀荣(2017)考研政治命题人终极预测4套卷&#39;,14.40)&quot;)
cur.execute(&quot;INSERT INTO book VALUES(2,&#39;法医秦明作品集:幸存者+清道夫+尸语者+无声的证词+第十一根手指(套装共5册) (两种封面随机发货)&#39;,100.00)&quot;)
cur.execute(&quot;INSERT INTO book VALUES(3,&#39;活着本来单纯:丰子恺散文漫画精品集(收藏本)&#39;,30.90)&quot;)
cur.execute(&quot;INSERT INTO book VALUES(4,&#39;自在独行:贾平凹的独行世界&#39;,26.80)&quot;)
cur.execute(&quot;INSERT INTO book VALUES(5,&#39;当你的才华还撑不起你的梦想时&#39;,23.00)&quot;)
cur.execute(&quot;INSERT INTO book VALUES(6,&#39;巨人的陨落(套装共3册)&#39;,84.90)&quot;)
cur.execute(&quot;INSERT INTO book VALUES(7,&#39;孤独深处(收录雨果奖获奖作品《北京折叠》)&#39;,21.90)&quot;)
cur.execute(&quot;INSERT INTO book VALUES(8,&#39;世界知名企业员工指定培训教材:所谓情商高,就是会说话&#39;,22.00)&quot;)
</code></pre>
<pre><code>&lt;sqlite3.Cursor at 0x2d2d64e7c00&gt;
</code></pre><h3 id="批量插入数据"><a href="#批量插入数据" class="headerlink" title="批量插入数据"></a>批量插入数据</h3><pre><code class="python">books = (
    (9, &#39;人间草木&#39;, 30.00),
    (10,&#39;你的善良必须有点锋芒&#39;, 20.50),
    (11, &#39;这么慢,那么美&#39;, 24.80),
    (12, &#39;考拉小巫的英语学习日记:写给为梦想而奋斗的人(全新修订版)&#39;, 23.90)
)
cur.executemany(&quot;INSERT INTO book VALUES(?, ?, ?)&quot;, books)
</code></pre>
<pre><code>&lt;sqlite3.Cursor at 0x2d2d64e7c00&gt;
</code></pre><pre><code class="python">conn.commit()
</code></pre>
<h3 id="查找数据"><a href="#查找数据" class="headerlink" title="查找数据"></a>查找数据</h3><pre><code class="python">cur.execute(&#39;SELECT * FROM book&#39;)
rows = cur.fetchall()

# 通过索引号访问
for row in rows:
    print (&#39;序号: %i, 书名: %s, 价格: %.2f&#39; %(row[0], row[1], row[2]))
</code></pre>
<pre><code>序号: 1, 书名: 肖秀荣考研书系列:肖秀荣(2017)考研政治命题人终极预测4套卷, 价格: 14.40
序号: 2, 书名: 法医秦明作品集:幸存者+清道夫+尸语者+无声的证词+第十一根手指(套装共5册) (两种封面随机发货), 价格: 100.00
序号: 3, 书名: 活着本来单纯:丰子恺散文漫画精品集(收藏本), 价格: 30.90
序号: 4, 书名: 自在独行:贾平凹的独行世界, 价格: 26.80
序号: 5, 书名: 当你的才华还撑不起你的梦想时, 价格: 23.00
序号: 6, 书名: 巨人的陨落(套装共3册), 价格: 84.90
序号: 7, 书名: 孤独深处(收录雨果奖获奖作品《北京折叠》), 价格: 21.90
序号: 8, 书名: 世界知名企业员工指定培训教材:所谓情商高,就是会说话, 价格: 22.00
序号: 9, 书名: 人间草木, 价格: 30.00
序号: 10, 书名: 你的善良必须有点锋芒, 价格: 20.50
序号: 11, 书名: 这么慢,那么美, 价格: 24.80
序号: 12, 书名: 考拉小巫的英语学习日记:写给为梦想而奋斗的人(全新修订版), 价格: 23.90
</code></pre><pre><code class="python">conn.row_factory = sqlite3.Row
cur = conn.cursor()
cur.execute(&#39;SELECT * FROM book&#39;)
rows = cur.fetchall()

# 通过列名访问
for row in rows:
    print (&#39;序号: %i, 书名: %s, 价格: %.2f&#39; %(row[&#39;id&#39;], row[&#39;name&#39;], row[&#39;price&#39;]))
</code></pre>
<pre><code>序号: 1, 书名: 肖秀荣考研书系列:肖秀荣(2017)考研政治命题人终极预测4套卷, 价格: 14.40
序号: 2, 书名: 法医秦明作品集:幸存者+清道夫+尸语者+无声的证词+第十一根手指(套装共5册) (两种封面随机发货), 价格: 100.00
序号: 3, 书名: 活着本来单纯:丰子恺散文漫画精品集(收藏本), 价格: 30.90
序号: 4, 书名: 自在独行:贾平凹的独行世界, 价格: 26.80
序号: 5, 书名: 当你的才华还撑不起你的梦想时, 价格: 23.00
序号: 6, 书名: 巨人的陨落(套装共3册), 价格: 84.90
序号: 7, 书名: 孤独深处(收录雨果奖获奖作品《北京折叠》), 价格: 21.90
序号: 8, 书名: 世界知名企业员工指定培训教材:所谓情商高,就是会说话, 价格: 22.00
序号: 9, 书名: 人间草木, 价格: 30.00
序号: 10, 书名: 你的善良必须有点锋芒, 价格: 20.50
序号: 11, 书名: 这么慢,那么美, 价格: 24.80
序号: 12, 书名: 考拉小巫的英语学习日记:写给为梦想而奋斗的人(全新修订版), 价格: 23.90
</code></pre><pre><code class="python">conn.close()
</code></pre>
<h2 id="五、SQLite-json-操作"><a href="#五、SQLite-json-操作" class="headerlink" title="五、SQLite_json 操作"></a>五、SQLite_json 操作</h2><pre><code class="python">import sqlite3

db_path = &#39;./files/test_join.sqlite&#39;

conn = sqlite3.connect(db_path)
cur = conn.cursor()
</code></pre>
<pre><code class="python"># 建 depaetment 表，并插入数据
cur.execute(&quot;DROP TABLE IF EXISTS department&quot;)
cur.execute(&quot;CREATE TABLE department(\
                id INT PRIMARY KEY NOT NULL, \
                dept CHAR(50) NOT NULL, \
                emp_id INT NOT NULL)&quot;)
depts = (
        (1, &#39;IT Builing&#39;, 1),
        (2, &#39;Engineerin&#39;, 2),
        (3, &#39;Finance&#39;, 7)
)
cur.executemany(&quot;INSERT INTO department VALUES(?, ?, ?)&quot;, depts)
</code></pre>
<pre><code>&lt;sqlite3.Cursor at 0x2d2d64f70a0&gt;
</code></pre><pre><code class="python">conn.commit()
</code></pre>
<h3 id="CROSS-JOIN-交叉连接"><a href="#CROSS-JOIN-交叉连接" class="headerlink" title="CROSS JOIN 交叉连接"></a>CROSS JOIN 交叉连接</h3><pre><code class="python">cur.execute(&quot;SELECT emp_id, name, dept FROM company CROSS JOIN department;&quot;)
rows = cur.fetchall()
for row in rows:
    print (row)
</code></pre>
<pre><code class="python"># 建 company 表，并插入数据
cur.execute(&quot;DROP TABLE IF EXISTS company&quot;)
cur.execute(&quot;CREATE TABLE company(\
                    id INT PRIMARY KEY NOT NULL, \
                    name CHAR(50) NOT NULL, \
                    age INT NOT NULL, \
                    address CHAR(50) NOT NULL,\
                    salary DOUBLE NOT NULL)&quot;)
companies = (
        (1, &#39;Paul&#39;, 32, &#39;California&#39;, 20000.0),
        (2, &#39;Allen&#39;, 25, &#39;Texas&#39;, 15000.0),
        (3, &#39;Teddy&#39;, 23, &#39;Norway&#39;, 20000.0),
        (4, &#39;Mark&#39;, 25, &#39;Rich-Mond&#39;, 65000.0),
        (5, &#39;David&#39;, 27, &#39;Texas&#39;, 85000.0),
        (6, &#39;Kim&#39;, 22, &#39;South-Hall&#39;, 45000.0),
        (7, &#39;James&#39;, 24, &#39;Houston&#39;, 10000.0)
)
cur.executemany(&quot;INSERT INTO company VALUES (?, ?, ?, ?, ?)&quot;, companies)
</code></pre>
<pre><code>&lt;sqlite3.Cursor at 0x2d2d64f70a0&gt;
</code></pre><h3 id="INNER-JOIN-内连接"><a href="#INNER-JOIN-内连接" class="headerlink" title="INNER JOIN 内连接"></a>INNER JOIN 内连接</h3><pre><code class="python">cur.execute(&quot;SELECT emp_id, name, dept FROM company INNER JOIN department \
            ON company.id = department.emp_id;&quot;)
rows = cur.fetchall()
for row in rows:
    print (row)
</code></pre>
<pre><code>(1, &#39;Paul&#39;, &#39;IT Builing&#39;)
(2, &#39;Allen&#39;, &#39;Engineerin&#39;)
(7, &#39;James&#39;, &#39;Finance&#39;)
</code></pre><h3 id="OUTER-JOIN-外连接"><a href="#OUTER-JOIN-外连接" class="headerlink" title="OUTER JOIN 外连接"></a>OUTER JOIN 外连接</h3><pre><code class="python"># 左连接
cur.execute(&quot;SELECT emp_id, name, dept FROM company LEFT OUTER JOIN department \
            ON company.id = department.emp_id;&quot;)
rows = cur.fetchall()
for row in rows:
    print (row)
</code></pre>
<pre><code>(1, &#39;Paul&#39;, &#39;IT Builing&#39;)
(2, &#39;Allen&#39;, &#39;Engineerin&#39;)
(None, &#39;Teddy&#39;, None)
(None, &#39;Mark&#39;, None)
(None, &#39;David&#39;, None)
(None, &#39;Kim&#39;, None)
(7, &#39;James&#39;, &#39;Finance&#39;)
</code></pre><pre><code class="python"># 右连接 （目前不支持）
cur.execute(&quot;SELECT emp_id, name, dept FROM company RIGHT OUTER JOIN department \
            ON company.id = department.emp_id;&quot;)
rows = cur.fetchall()
for row in rows:
    print (row)
</code></pre>
<pre><code>---------------------------------------------------------------------------

OperationalError                          Traceback (most recent call last)

&lt;ipython-input-41-ce0fc573748b&gt; in &lt;module&gt;
      1 # 右连接 （目前不支持）
      2 cur.execute(&quot;SELECT emp_id, name, dept FROM company RIGHT OUTER JOIN department \
----&gt; 3             ON company.id = department.emp_id;&quot;)
      4 rows = cur.fetchall()
      5 for row in rows:


OperationalError: RIGHT and FULL OUTER JOINs are not currently supported
</code></pre><pre><code class="python"># 右连接，交换两张表
cur.execute(&quot;SELECT emp_id, name, dept FROM department LEFT OUTER JOIN company \
            ON company.id = department.emp_id;&quot;)
rows = cur.fetchall()
for row in rows:
    print (row)
</code></pre>
<pre><code>(1, &#39;Paul&#39;, &#39;IT Builing&#39;)
(2, &#39;Allen&#39;, &#39;Engineerin&#39;)
(7, &#39;James&#39;, &#39;Finance&#39;)
</code></pre><pre><code class="python">sqlite&gt; SELECT EMP_ID, NAME, DEPT FROM COMPANY LEFT OUTER JOIN DEPARTMENT
      ON COMPANY.ID = DEPARTMENT.EMP_ID;
</code></pre>
<pre><code>  File &quot;&lt;ipython-input-43-a0833b733075&gt;&quot;, line 1
    sqlite&gt; SELECT EMP_ID, NAME, DEPT FROM COMPANY LEFT OUTER JOIN DEPARTMENT
                        ^
SyntaxError: invalid syntax
</code></pre><h2 id="六、Excel-文件操作"><a href="#六、Excel-文件操作" class="headerlink" title="六、Excel 文件操作"></a>六、Excel 文件操作</h2><p>pandas.read_excel(io, sheet_name=0, header=0, names=None, index_col=None, usecols=None, squeeze=False, dtype=None, engine=None, converters=None, true_values=None, false_values=None, skiprows=None, nrows=None, na_values=None, keep_default_na=True, verbose=False, parse_dates=False, date_parser=None, thousands=None, comment=None, skipfooter=0, convert_float=True, mangle_dupe_cols=True, **kwds)</p>
<p>df_fujian = pd.read_excel(“./datafiles/fujian.xlsx”,sheet_name=’日数据’)</p>
]]></content>
      <categories>
        <category>DataAnalysis</category>
      </categories>
  </entry>
  <entry>
    <title>Pandas使用——各种索引</title>
    <url>/blog/nfqdqf/</url>
    <content><![CDATA[<h2 id="一、基本索引"><a href="#一、基本索引" class="headerlink" title="一、基本索引"></a>一、基本索引</h2><pre><code class="python">import pandas as pd
import numpy as np
</code></pre>
<h3 id="Series-索引"><a href="#Series-索引" class="headerlink" title="Series 索引"></a>Series 索引</h3><pre><code class="python">ser_obj1 = pd.Series(range(5), index = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;])
print (ser_obj1.head())
</code></pre>
<pre><code>a    0
b    1
c    2
d    3
e    4
dtype: int64
</code></pre><pre><code class="python">&#39;&#39;&#39;1. 行索引&#39;&#39;&#39;
print(&#39;行索引====================================================================&#39;)
print (ser_obj1[&#39;b&#39;])
print (ser_obj1[0])
print(&#39;切片索引====================================================================&#39;)
&#39;&#39;&#39;2. 切片索引&#39;&#39;&#39;
print (ser_obj1[1:3])
print (ser_obj1[&#39;b&#39;:&#39;d&#39;])
print(&#39;不连续索引索引====================================================================&#39;)
#注意会不会包含尾巴。。
&#39;&#39;&#39;3. 不连续索引&#39;&#39;&#39;
print (ser_obj1[[0, 2, 4]])
print (ser_obj1[[&#39;a&#39;, &#39;e&#39;]])
print(&#39;布尔索引====================================================================&#39;)
&#39;&#39;&#39;4. 布尔索引&#39;&#39;&#39;
#是对里面的值进行判断，不是对索引
ser_bool = ser_obj1 &gt; 2
print (ser_bool)
print (ser_obj1[ser_bool])#运用的方式
print (ser_obj1[ser_obj1 &gt; 2])
</code></pre>
<pre><code>行索引====================================================================
1
0
切片索引====================================================================
b    1
c    2
dtype: int64
b    1
c    2
d    3
dtype: int64
不连续索引索引====================================================================
a    0
c    2
e    4
dtype: int64
a    0
e    4
dtype: int64
布尔索引====================================================================
a    False
b    False
c    False
d     True
e     True
dtype: bool
d    3
e    4
dtype: int64
d    3
e    4
dtype: int64
</code></pre><h3 id="Dataframe-索引"><a href="#Dataframe-索引" class="headerlink" title="Dataframe 索引"></a>Dataframe 索引</h3><pre><code class="python">df_obj1 = pd.DataFrame(np.random.randn(5,4), columns = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;])
print (df_obj1.head())
</code></pre>
<pre><code>          a         b         c         d
0 -0.720611 -0.002543 -0.084255 -0.583719
1  0.174715  0.288090 -0.254462 -1.669668
2 -1.872654 -0.466842 -0.481040 -1.735558
3  1.147668  1.205686  0.625582 -2.111863
4  1.177882  0.049581 -0.404098 -0.497125
</code></pre><pre><code class="python">&#39;&#39;&#39;0. 转换成行索引的话===方式一：transpose或者T&#39;&#39;&#39;
bb=df_obj1.transpose()
print(df_obj1.T)
print(bb)
&#39;&#39;&#39;0. 转换成行索引的话===方式二：重构&#39;&#39;&#39;
</code></pre>
<pre><code>          0         1         2         3         4
a -0.720611  0.174715 -1.872654  1.147668  1.177882
b -0.002543  0.288090 -0.466842  1.205686  0.049581
c -0.084255 -0.254462 -0.481040  0.625582 -0.404098
d -0.583719 -1.669668 -1.735558 -2.111863 -0.497125
          0         1         2         3         4
a -0.720611  0.174715 -1.872654  1.147668  1.177882
b -0.002543  0.288090 -0.466842  1.205686  0.049581
c -0.084255 -0.254462 -0.481040  0.625582 -0.404098
d -0.583719 -1.669668 -1.735558 -2.111863 -0.497125





&#39;0. 转换成行索引的话===方式二：重构/重塑===还没有完全明白&#39;
</code></pre><pre><code class="python">&#39;&#39;&#39;1. 列索引=====默认为列索引来操作&#39;&#39;&#39;
print (&#39;列索引&#39;)
print(df_obj1.b)#当成属性来获取值
print(&#39;===================&#39;)
print (df_obj1[&#39;a&#39;]) # 返回Series类型
print (type(df_obj1[&#39;a&#39;]))
print (df_obj1[[&#39;a&#39;]]) # 返回DataFrame类型
print (type(df_obj1[[&#39;a&#39;]]))
&#39;&#39;&#39;2. 不连续索引&#39;&#39;&#39;
print (&#39;不连续索引&#39;)
print (df_obj1[[&#39;a&#39;,&#39;c&#39;]])
print (df_obj1[[&#39;a&#39;,&#39;c&#39;]])
</code></pre>
<pre><code>列索引
0   -0.002543
1    0.288090
2   -0.466842
3    1.205686
4    0.049581
Name: b, dtype: float64
===================
0   -0.720611
1    0.174715
2   -1.872654
3    1.147668
4    1.177882
Name: a, dtype: float64
&lt;class &#39;pandas.core.series.Series&#39;&gt;
          a
0 -0.720611
1  0.174715
2 -1.872654
3  1.147668
4  1.177882
&lt;class &#39;pandas.core.frame.DataFrame&#39;&gt;
不连续索引
          a         c
0 -0.720611 -0.084255
1  0.174715 -0.254462
2 -1.872654 -0.481040
3  1.147668  0.625582
4  1.177882 -0.404098
          a         c
0 -0.720611 -0.084255
1  0.174715 -0.254462
2 -1.872654 -0.481040
3  1.147668  0.625582
4  1.177882 -0.404098
</code></pre><h3 id="三种索引方式"><a href="#三种索引方式" class="headerlink" title="三种索引方式"></a>三种索引方式</h3><pre><code class="python">print(ser_obj1)
print(&#39;============================&#39;)
print(df_obj1)
</code></pre>
<pre><code>a    0
b    1
c    2
d    3
e    4
dtype: int64
============================
          a         b         c         d
0 -0.720611 -0.002543 -0.084255 -0.583719
1  0.174715  0.288090 -0.254462 -1.669668
2 -1.872654 -0.466842 -0.481040 -1.735558
3  1.147668  1.205686  0.625582 -2.111863
4  1.177882  0.049581 -0.404098 -0.497125
</code></pre><pre><code class="python">&#39;&#39;&#39;1. 标签索引 loc===用的是index和column的值索引【标签索引】&#39;&#39;&#39;
# Series
print (ser_obj1[&#39;b&#39;:&#39;d&#39;])
print (ser_obj1.loc[&#39;b&#39;:&#39;d&#39;])

# DataFrame
print (df_obj1[[&#39;a&#39;]])
print (df_obj1.loc[0:2,&#39;a&#39;:&#39;c&#39;])
</code></pre>
<pre><code>b    1
c    2
d    3
dtype: int64
b    1
c    2
d    3
dtype: int64
          a
0 -0.720611
1  0.174715
2 -1.872654
3  1.147668
4  1.177882
          a         b         c
0 -0.720611 -0.002543 -0.084255
1  0.174715  0.288090 -0.254462
2 -1.872654 -0.466842 -0.481040
</code></pre><pre><code class="python">&#39;&#39;&#39;2. 位置索引 iloc====用的是index和column的默认0，1，2，3···的值索引【位置索引】&#39;&#39;&#39;
print (ser_obj1[1:3])
print (ser_obj1.iloc[1:3])

# DataFrame
print (df_obj1.iloc[0:2, 0:2])
# 注意和df_obj.loc[0:2, &#39;a&#39;]的区别 = = = 行和列：都不包括尾巴
</code></pre>
<pre><code>b    1
c    2
dtype: int64
b    1
c    2
dtype: int64
          a         b
0 -0.720611 -0.002543
1  0.174715  0.288090
</code></pre><pre><code class="python">&#39;&#39;&#39;3. 混合索引 ix===先按标签索引loc尝试操作，然后再按位置索引iloc尝试操作&#39;&#39;&#39;
print (ser_obj1.ix[1:3])
print (ser_obj1.ix[&#39;b&#39;:&#39;c&#39;])

# DataFrame
print (df_obj1.ix[0:2, 0:3])
</code></pre>
<pre><code>b    1
c    2
dtype: int64
b    1
c    2
dtype: int64
          a         b         c
0 -0.720611 -0.002543 -0.084255
1  0.174715  0.288090 -0.254462
2 -1.872654 -0.466842 -0.481040
</code></pre><h2 id="二、Pandas-层级索引"><a href="#二、Pandas-层级索引" class="headerlink" title="二、Pandas 层级索引"></a>二、Pandas 层级索引</h2><h3 id="构造层级索引"><a href="#构造层级索引" class="headerlink" title="构造层级索引"></a>构造层级索引</h3><pre><code class="python">ser_obj = pd.Series(np.random.randn(12),
                    index=[[&#39;a&#39;, &#39;a&#39;, &#39;a&#39;, &#39;b&#39;, &#39;b&#39;, &#39;b&#39;, &#39;c&#39;, &#39;c&#39;, &#39;c&#39;, &#39;d&#39;, &#39;d&#39;, &#39;d&#39;],
                           [0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2]])
#列表里面的列表
print (ser_obj)
</code></pre>
<pre><code>a  0   -0.373441
   1    0.615976
   2    0.959092
b  0    1.743670
   1   -0.791517
   2   -0.774013
c  0    1.271094
   1   -0.723264
   2    0.253038
d  0   -0.767791
   1    0.419253
   2   -0.691644
dtype: float64
</code></pre><ul>
<li>MultiIndex 索引对象</li>
</ul>
<pre><code class="python">print (type(ser_obj.index))
print (ser_obj.index)
</code></pre>
<pre><code>&lt;class &#39;pandas.core.indexes.multi.MultiIndex&#39;&gt;
MultiIndex([(&#39;a&#39;, 0),
            (&#39;a&#39;, 1),
            (&#39;a&#39;, 2),
            (&#39;b&#39;, 0),
            (&#39;b&#39;, 1),
            (&#39;b&#39;, 2),
            (&#39;c&#39;, 0),
            (&#39;c&#39;, 1),
            (&#39;c&#39;, 2),
            (&#39;d&#39;, 0),
            (&#39;d&#39;, 1),
            (&#39;d&#39;, 2)],
           )
</code></pre><h3 id="选取子集"><a href="#选取子集" class="headerlink" title="选取子集"></a>选取子集</h3><pre><code class="python"># 外层选取
print (ser_obj[&#39;c&#39;])
</code></pre>
<pre><code>0    1.271094
1   -0.723264
2    0.253038
dtype: float64
</code></pre><pre><code class="python"># 内层选取
print (ser_obj[:, 2])
</code></pre>
<pre><code>a    0.959092
b   -0.774013
c    0.253038
d   -0.691644
dtype: float64
</code></pre><h3 id="交换分层顺序"><a href="#交换分层顺序" class="headerlink" title="交换分层顺序"></a>交换分层顺序</h3><pre><code class="python">df_obj2 = pd.DataFrame(np.random.randn(6,4), columns = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;],index=[[&#39;a&#39;, &#39;a&#39;, &#39;a&#39;, &#39;b&#39;, &#39;b&#39;,&#39;b&#39;],[1, 2, 3, 1, 2,3]])
#print (df_obj1.swaplevel())
print (df_obj2)
</code></pre>
<pre><code>            a         b         c         d
a 1  0.273776 -0.018659  1.512727 -0.088091
  2 -0.410883 -1.488943  0.917268  1.179941
  3 -0.237532 -0.823717  0.189495  1.060476
b 1  0.727872  0.323352  0.443786  0.780510
  2 -1.407645 -0.059689  1.439843 -1.700740
  3 -0.377628 -0.137348 -0.739980  0.122528
</code></pre><h3 id="交换并排序分层"><a href="#交换并排序分层" class="headerlink" title="交换并排序分层"></a>交换并排序分层</h3><pre><code class="python">print (df_obj2.swaplevel().sortvalues(by=&#39;a&#39;))
#Series没有这个内置函数sortlevel===dataframe有
</code></pre>
<h2 id="三、透视表和交叉表"><a href="#三、透视表和交叉表" class="headerlink" title="三、透视表和交叉表"></a>三、透视表和交叉表</h2><pre><code class="python">dataset_path = &#39;./data/starcraft.csv&#39;
df_data = pd.read_csv(dataset_path, usecols=[&#39;LeagueIndex&#39;, &#39;Age&#39;, &#39;HoursPerWeek&#39;,
                                             &#39;TotalHours&#39;, &#39;APM&#39;])
print(df_data.head())
</code></pre>
<pre><code>   LeagueIndex   Age  HoursPerWeek  TotalHours       APM
0            5  27.0          10.0      3000.0  143.7180
1            5  23.0          10.0      5000.0  129.2322
2            4  30.0          10.0       200.0   69.9612
3            3  19.0          20.0       400.0  107.6016
4            3  32.0          10.0       500.0  122.8908
</code></pre><h3 id="透视表"><a href="#透视表" class="headerlink" title="透视表"></a>透视表</h3><pre><code class="python">pd.pivot_table(df_data,
               index=[&#39;Age&#39;],
               columns=[&#39;LeagueIndex&#39;],
               aggfunc=np.sum)
</code></pre>
<table>
<thead>
<tr>
<th></th>
<th>APM</th>
<th>HoursPerWeek</th>
<th>TotalHours</th>
</tr>
</thead>
<tbody>
<tr>
<td>LeagueIndex</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>5</td>
<td>6</td>
<td>7</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>…</td>
<td>5</td>
<td>6</td>
<td>7</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>5</td>
<td>6</td>
<td>7</td>
</tr>
<tr>
<td>Age</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>16.0</td>
<td>1062.44754</td>
<td>2919.70434</td>
<td>4851.9222</td>
<td>5149.7310</td>
<td>7787.37780</td>
<td>9042.1722</td>
<td>386.7774</td>
<td>324.0</td>
<td>720.0</td>
<td>778.0</td>
<td>…</td>
<td>1220.0</td>
<td>1280.0</td>
<td>56.0</td>
<td>4307.0</td>
<td>13143.0</td>
<td>29211.0</td>
<td>23581.0</td>
<td>49233.0</td>
<td>51320.0</td>
<td>3000.0</td>
</tr>
<tr>
<td>17.0</td>
<td>655.67280</td>
<td>1661.01540</td>
<td>4181.8920</td>
<td>5525.3586</td>
<td>10052.72100</td>
<td>8310.0858</td>
<td>573.8286</td>
<td>184.0</td>
<td>378.0</td>
<td>664.0</td>
<td>…</td>
<td>1460.0</td>
<td>1116.0</td>
<td>104.0</td>
<td>2044.0</td>
<td>7423.0</td>
<td>16602.0</td>
<td>24005.0</td>
<td>53375.0</td>
<td>45421.0</td>
<td>12700.0</td>
</tr>
<tr>
<td>18.0</td>
<td>704.47680</td>
<td>3300.41040</td>
<td>4847.2152</td>
<td>8763.0783</td>
<td>10988.66100</td>
<td>9134.7240</td>
<td>618.5790</td>
<td>204.0</td>
<td>548.0</td>
<td>886.0</td>
<td>…</td>
<td>1644.0</td>
<td>1194.0</td>
<td>164.0</td>
<td>3570.0</td>
<td>11471.0</td>
<td>21037.0</td>
<td>46034.0</td>
<td>1056486.0</td>
<td>50378.0</td>
<td>3200.0</td>
</tr>
<tr>
<td>19.0</td>
<td>734.55600</td>
<td>2216.81880</td>
<td>5183.7888</td>
<td>8030.1960</td>
<td>9271.09260</td>
<td>11955.6030</td>
<td>696.7770</td>
<td>126.0</td>
<td>458.0</td>
<td>950.0</td>
<td>…</td>
<td>962.0</td>
<td>1642.0</td>
<td>168.0</td>
<td>2355.0</td>
<td>8467.0</td>
<td>31861.0</td>
<td>39705.0</td>
<td>44697.0</td>
<td>70331.0</td>
<td>4166.0</td>
</tr>
<tr>
<td>20.0</td>
<td>1624.89660</td>
<td>2147.23200</td>
<td>4211.5686</td>
<td>10596.2070</td>
<td>10871.65440</td>
<td>14291.8692</td>
<td>NaN</td>
<td>328.0</td>
<td>288.0</td>
<td>654.0</td>
<td>…</td>
<td>1290.0</td>
<td>1816.0</td>
<td>NaN</td>
<td>7212.0</td>
<td>6325.0</td>
<td>20174.0</td>
<td>55083.0</td>
<td>64170.0</td>
<td>105131.0</td>
<td>NaN</td>
</tr>
<tr>
<td>21.0</td>
<td>780.67950</td>
<td>1578.02880</td>
<td>3949.3062</td>
<td>8689.8804</td>
<td>11954.91660</td>
<td>13165.7649</td>
<td>867.3474</td>
<td>162.0</td>
<td>270.0</td>
<td>580.0</td>
<td>…</td>
<td>1446.0</td>
<td>1858.0</td>
<td>62.0</td>
<td>3377.0</td>
<td>7673.0</td>
<td>19095.0</td>
<td>42296.0</td>
<td>68739.0</td>
<td>82061.0</td>
<td>3180.0</td>
</tr>
<tr>
<td>22.0</td>
<td>674.59860</td>
<td>2147.50980</td>
<td>4379.3424</td>
<td>7818.7302</td>
<td>10473.28380</td>
<td>10165.8672</td>
<td>493.1586</td>
<td>146.0</td>
<td>372.0</td>
<td>680.0</td>
<td>…</td>
<td>1304.0</td>
<td>1448.0</td>
<td>112.0</td>
<td>4225.0</td>
<td>10861.0</td>
<td>23030.0</td>
<td>57996.0</td>
<td>84330.0</td>
<td>67069.0</td>
<td>6950.0</td>
</tr>
<tr>
<td>23.0</td>
<td>359.65980</td>
<td>1575.06120</td>
<td>4602.7416</td>
<td>7616.9298</td>
<td>8292.86160</td>
<td>6131.1936</td>
<td>1799.6520</td>
<td>46.0</td>
<td>320.0</td>
<td>598.0</td>
<td>…</td>
<td>998.0</td>
<td>726.0</td>
<td>296.0</td>
<td>896.0</td>
<td>12350.0</td>
<td>23081.0</td>
<td>40025.0</td>
<td>56097.0</td>
<td>43176.0</td>
<td>14290.0</td>
</tr>
<tr>
<td>24.0</td>
<td>439.43040</td>
<td>1717.55340</td>
<td>2876.8572</td>
<td>5503.7736</td>
<td>7292.32740</td>
<td>7240.4076</td>
<td>428.6538</td>
<td>116.0</td>
<td>344.0</td>
<td>406.0</td>
<td>…</td>
<td>668.0</td>
<td>1048.0</td>
<td>36.0</td>
<td>2070.0</td>
<td>9543.0</td>
<td>25421.0</td>
<td>35384.0</td>
<td>36147.0</td>
<td>43114.0</td>
<td>2250.0</td>
</tr>
<tr>
<td>25.0</td>
<td>572.61420</td>
<td>1178.02440</td>
<td>2201.6388</td>
<td>4710.9924</td>
<td>6168.19260</td>
<td>2200.6362</td>
<td>361.4550</td>
<td>124.0</td>
<td>166.0</td>
<td>268.0</td>
<td>…</td>
<td>682.0</td>
<td>256.0</td>
<td>52.0</td>
<td>2440.0</td>
<td>5846.0</td>
<td>11270.0</td>
<td>26610.0</td>
<td>40681.0</td>
<td>14890.0</td>
<td>3300.0</td>
</tr>
<tr>
<td>26.0</td>
<td>418.70874</td>
<td>1165.96680</td>
<td>1794.1890</td>
<td>3139.2852</td>
<td>4016.67060</td>
<td>3301.8498</td>
<td>408.2202</td>
<td>96.0</td>
<td>148.0</td>
<td>272.0</td>
<td>…</td>
<td>418.0</td>
<td>354.0</td>
<td>60.0</td>
<td>1608.0</td>
<td>3417.0</td>
<td>10548.0</td>
<td>16839.0</td>
<td>20100.0</td>
<td>17663.0</td>
<td>2300.0</td>
</tr>
<tr>
<td>27.0</td>
<td>359.17320</td>
<td>1164.15960</td>
<td>1426.4550</td>
<td>2850.1320</td>
<td>3498.30300</td>
<td>2040.8454</td>
<td>NaN</td>
<td>40.0</td>
<td>152.0</td>
<td>226.0</td>
<td>…</td>
<td>340.0</td>
<td>164.0</td>
<td>NaN</td>
<td>1100.0</td>
<td>3615.0</td>
<td>7525.0</td>
<td>15935.0</td>
<td>19770.0</td>
<td>11796.0</td>
<td>NaN</td>
</tr>
<tr>
<td>28.0</td>
<td>333.84240</td>
<td>479.34000</td>
<td>1152.5958</td>
<td>2205.8778</td>
<td>1992.60540</td>
<td>521.7666</td>
<td>NaN</td>
<td>28.0</td>
<td>90.0</td>
<td>220.0</td>
<td>…</td>
<td>186.0</td>
<td>44.0</td>
<td>NaN</td>
<td>466.0</td>
<td>1860.0</td>
<td>7901.0</td>
<td>15370.0</td>
<td>10872.0</td>
<td>2500.0</td>
<td>NaN</td>
</tr>
<tr>
<td>29.0</td>
<td>236.74020</td>
<td>695.88480</td>
<td>568.2594</td>
<td>1447.5906</td>
<td>1398.78540</td>
<td>715.9404</td>
<td>NaN</td>
<td>54.0</td>
<td>56.0</td>
<td>80.0</td>
<td>…</td>
<td>180.0</td>
<td>106.0</td>
<td>NaN</td>
<td>2490.0</td>
<td>2000.0</td>
<td>3816.0</td>
<td>8220.0</td>
<td>10292.0</td>
<td>5950.0</td>
<td>NaN</td>
</tr>
<tr>
<td>30.0</td>
<td>125.53740</td>
<td>441.14160</td>
<td>733.6416</td>
<td>743.4468</td>
<td>578.32020</td>
<td>123.3774</td>
<td>NaN</td>
<td>14.0</td>
<td>54.0</td>
<td>76.0</td>
<td>…</td>
<td>90.0</td>
<td>28.0</td>
<td>NaN</td>
<td>210.0</td>
<td>2440.0</td>
<td>4370.0</td>
<td>6310.0</td>
<td>3440.0</td>
<td>1500.0</td>
<td>NaN</td>
</tr>
<tr>
<td>31.0</td>
<td>41.58600</td>
<td>314.92980</td>
<td>659.2626</td>
<td>1166.7606</td>
<td>315.53460</td>
<td>200.1708</td>
<td>NaN</td>
<td>12.0</td>
<td>36.0</td>
<td>68.0</td>
<td>…</td>
<td>12.0</td>
<td>16.0</td>
<td>NaN</td>
<td>200.0</td>
<td>1300.0</td>
<td>3500.0</td>
<td>8710.0</td>
<td>1050.0</td>
<td>1500.0</td>
<td>NaN</td>
</tr>
<tr>
<td>32.0</td>
<td>179.14380</td>
<td>315.54180</td>
<td>457.5174</td>
<td>541.8996</td>
<td>66.19740</td>
<td>NaN</td>
<td>NaN</td>
<td>40.0</td>
<td>56.0</td>
<td>68.0</td>
<td>…</td>
<td>10.0</td>
<td>NaN</td>
<td>NaN</td>
<td>1600.0</td>
<td>860.0</td>
<td>2300.0</td>
<td>6040.0</td>
<td>800.0</td>
<td>NaN</td>
<td>NaN</td>
</tr>
<tr>
<td>33.0</td>
<td>198.77880</td>
<td>153.34680</td>
<td>284.8218</td>
<td>116.7516</td>
<td>245.45166</td>
<td>NaN</td>
<td>NaN</td>
<td>32.0</td>
<td>12.0</td>
<td>42.0</td>
<td>…</td>
<td>60.0</td>
<td>NaN</td>
<td>NaN</td>
<td>1200.0</td>
<td>220.0</td>
<td>2065.0</td>
<td>1130.0</td>
<td>2050.0</td>
<td>NaN</td>
<td>NaN</td>
</tr>
<tr>
<td>34.0</td>
<td>49.11360</td>
<td>276.88260</td>
<td>268.4100</td>
<td>340.7124</td>
<td>174.54540</td>
<td>NaN</td>
<td>NaN</td>
<td>12.0</td>
<td>56.0</td>
<td>28.0</td>
<td>…</td>
<td>14.0</td>
<td>NaN</td>
<td>NaN</td>
<td>150.0</td>
<td>3380.0</td>
<td>1150.0</td>
<td>2400.0</td>
<td>2764.0</td>
<td>NaN</td>
<td>NaN</td>
</tr>
<tr>
<td>35.0</td>
<td>229.31280</td>
<td>54.04680</td>
<td>170.4930</td>
<td>634.7688</td>
<td>115.06440</td>
<td>NaN</td>
<td>NaN</td>
<td>54.0</td>
<td>8.0</td>
<td>26.0</td>
<td>…</td>
<td>12.0</td>
<td>NaN</td>
<td>NaN</td>
<td>1350.0</td>
<td>500.0</td>
<td>1950.0</td>
<td>3800.0</td>
<td>800.0</td>
<td>NaN</td>
<td>NaN</td>
</tr>
<tr>
<td>36.0</td>
<td>NaN</td>
<td>150.13140</td>
<td>333.6474</td>
<td>73.6980</td>
<td>NaN</td>
<td>NaN</td>
<td>NaN</td>
<td>NaN</td>
<td>16.0</td>
<td>40.0</td>
<td>…</td>
<td>NaN</td>
<td>NaN</td>
<td>NaN</td>
<td>NaN</td>
<td>500.0</td>
<td>1950.0</td>
<td>400.0</td>
<td>NaN</td>
<td>NaN</td>
<td>NaN</td>
</tr>
<tr>
<td>37.0</td>
<td>22.05960</td>
<td>49.89600</td>
<td>44.9682</td>
<td>NaN</td>
<td>451.13160</td>
<td>NaN</td>
<td>NaN</td>
<td>12.0</td>
<td>30.0</td>
<td>6.0</td>
<td>…</td>
<td>32.0</td>
<td>NaN</td>
<td>NaN</td>
<td>300.0</td>
<td>125.0</td>
<td>600.0</td>
<td>NaN</td>
<td>1800.0</td>
<td>NaN</td>
<td>NaN</td>
</tr>
<tr>
<td>38.0</td>
<td>71.59500</td>
<td>NaN</td>
<td>334.6878</td>
<td>NaN</td>
<td>NaN</td>
<td>NaN</td>
<td>NaN</td>
<td>16.0</td>
<td>NaN</td>
<td>46.0</td>
<td>…</td>
<td>NaN</td>
<td>NaN</td>
<td>NaN</td>
<td>300.0</td>
<td>NaN</td>
<td>2280.0</td>
<td>NaN</td>
<td>NaN</td>
<td>NaN</td>
<td>NaN</td>
</tr>
<tr>
<td>39.0</td>
<td>29.87640</td>
<td>NaN</td>
<td>53.7690</td>
<td>86.7246</td>
<td>NaN</td>
<td>NaN</td>
<td>NaN</td>
<td>10.0</td>
<td>NaN</td>
<td>12.0</td>
<td>…</td>
<td>NaN</td>
<td>NaN</td>
<td>NaN</td>
<td>500.0</td>
<td>NaN</td>
<td>450.0</td>
<td>500.0</td>
<td>NaN</td>
<td>NaN</td>
<td>NaN</td>
</tr>
<tr>
<td>40.0</td>
<td>38.55900</td>
<td>51.83580</td>
<td>107.4684</td>
<td>NaN</td>
<td>NaN</td>
<td>NaN</td>
<td>NaN</td>
<td>12.0</td>
<td>14.0</td>
<td>26.0</td>
<td>…</td>
<td>NaN</td>
<td>NaN</td>
<td>NaN</td>
<td>150.0</td>
<td>500.0</td>
<td>1080.0</td>
<td>NaN</td>
<td>NaN</td>
<td>NaN</td>
<td>NaN</td>
</tr>
<tr>
<td>41.0</td>
<td>NaN</td>
<td>108.45720</td>
<td>77.6472</td>
<td>NaN</td>
<td>NaN</td>
<td>NaN</td>
<td>NaN</td>
<td>NaN</td>
<td>12.0</td>
<td>14.0</td>
<td>…</td>
<td>NaN</td>
<td>NaN</td>
<td>NaN</td>
<td>NaN</td>
<td>450.0</td>
<td>800.0</td>
<td>NaN</td>
<td>NaN</td>
<td>NaN</td>
<td>NaN</td>
</tr>
<tr>
<td>43.0</td>
<td>NaN</td>
<td>86.05860</td>
<td>NaN</td>
<td>NaN</td>
<td>NaN</td>
<td>NaN</td>
<td>NaN</td>
<td>NaN</td>
<td>10.0</td>
<td>NaN</td>
<td>…</td>
<td>NaN</td>
<td>NaN</td>
<td>NaN</td>
<td>NaN</td>
<td>730.0</td>
<td>NaN</td>
<td>NaN</td>
<td>NaN</td>
<td>NaN</td>
<td>NaN</td>
</tr>
<tr>
<td>44.0</td>
<td>NaN</td>
<td>NaN</td>
<td>NaN</td>
<td>89.5266</td>
<td>NaN</td>
<td>NaN</td>
<td>NaN</td>
<td>NaN</td>
<td>NaN</td>
<td>NaN</td>
<td>…</td>
<td>NaN</td>
<td>NaN</td>
<td>NaN</td>
<td>NaN</td>
<td>NaN</td>
<td>NaN</td>
<td>500.0</td>
<td>NaN</td>
<td>NaN</td>
<td>NaN</td>
</tr>
</tbody>
</table>
<p>28 rows × 21 columns</p>
<pre><code class="python">pd.pivot_table(df_data,
               index=[&#39;Age&#39;],
               columns=[&#39;LeagueIndex&#39;],
               aggfunc=np.sum,
               fill_value=-100.)
</code></pre>
<table>
<thead>
<tr>
<th></th>
<th>APM</th>
<th>HoursPerWeek</th>
<th>TotalHours</th>
</tr>
</thead>
<tbody>
<tr>
<td>LeagueIndex</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>5</td>
<td>6</td>
<td>7</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>…</td>
<td>5</td>
<td>6</td>
<td>7</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>5</td>
<td>6</td>
<td>7</td>
</tr>
<tr>
<td>Age</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>16.0</td>
<td>1062.44754</td>
<td>2919.70434</td>
<td>4851.9222</td>
<td>5149.7310</td>
<td>7787.37780</td>
<td>9042.1722</td>
<td>386.7774</td>
<td>324</td>
<td>720</td>
<td>778</td>
<td>…</td>
<td>1220</td>
<td>1280</td>
<td>56</td>
<td>4307</td>
<td>13143</td>
<td>29211</td>
<td>23581</td>
<td>49233</td>
<td>51320</td>
<td>3000</td>
</tr>
<tr>
<td>17.0</td>
<td>655.67280</td>
<td>1661.01540</td>
<td>4181.8920</td>
<td>5525.3586</td>
<td>10052.72100</td>
<td>8310.0858</td>
<td>573.8286</td>
<td>184</td>
<td>378</td>
<td>664</td>
<td>…</td>
<td>1460</td>
<td>1116</td>
<td>104</td>
<td>2044</td>
<td>7423</td>
<td>16602</td>
<td>24005</td>
<td>53375</td>
<td>45421</td>
<td>12700</td>
</tr>
<tr>
<td>18.0</td>
<td>704.47680</td>
<td>3300.41040</td>
<td>4847.2152</td>
<td>8763.0783</td>
<td>10988.66100</td>
<td>9134.7240</td>
<td>618.5790</td>
<td>204</td>
<td>548</td>
<td>886</td>
<td>…</td>
<td>1644</td>
<td>1194</td>
<td>164</td>
<td>3570</td>
<td>11471</td>
<td>21037</td>
<td>46034</td>
<td>1056486</td>
<td>50378</td>
<td>3200</td>
</tr>
<tr>
<td>19.0</td>
<td>734.55600</td>
<td>2216.81880</td>
<td>5183.7888</td>
<td>8030.1960</td>
<td>9271.09260</td>
<td>11955.6030</td>
<td>696.7770</td>
<td>126</td>
<td>458</td>
<td>950</td>
<td>…</td>
<td>962</td>
<td>1642</td>
<td>168</td>
<td>2355</td>
<td>8467</td>
<td>31861</td>
<td>39705</td>
<td>44697</td>
<td>70331</td>
<td>4166</td>
</tr>
<tr>
<td>20.0</td>
<td>1624.89660</td>
<td>2147.23200</td>
<td>4211.5686</td>
<td>10596.2070</td>
<td>10871.65440</td>
<td>14291.8692</td>
<td>-100.0000</td>
<td>328</td>
<td>288</td>
<td>654</td>
<td>…</td>
<td>1290</td>
<td>1816</td>
<td>-100</td>
<td>7212</td>
<td>6325</td>
<td>20174</td>
<td>55083</td>
<td>64170</td>
<td>105131</td>
<td>-100</td>
</tr>
<tr>
<td>21.0</td>
<td>780.67950</td>
<td>1578.02880</td>
<td>3949.3062</td>
<td>8689.8804</td>
<td>11954.91660</td>
<td>13165.7649</td>
<td>867.3474</td>
<td>162</td>
<td>270</td>
<td>580</td>
<td>…</td>
<td>1446</td>
<td>1858</td>
<td>62</td>
<td>3377</td>
<td>7673</td>
<td>19095</td>
<td>42296</td>
<td>68739</td>
<td>82061</td>
<td>3180</td>
</tr>
<tr>
<td>22.0</td>
<td>674.59860</td>
<td>2147.50980</td>
<td>4379.3424</td>
<td>7818.7302</td>
<td>10473.28380</td>
<td>10165.8672</td>
<td>493.1586</td>
<td>146</td>
<td>372</td>
<td>680</td>
<td>…</td>
<td>1304</td>
<td>1448</td>
<td>112</td>
<td>4225</td>
<td>10861</td>
<td>23030</td>
<td>57996</td>
<td>84330</td>
<td>67069</td>
<td>6950</td>
</tr>
<tr>
<td>23.0</td>
<td>359.65980</td>
<td>1575.06120</td>
<td>4602.7416</td>
<td>7616.9298</td>
<td>8292.86160</td>
<td>6131.1936</td>
<td>1799.6520</td>
<td>46</td>
<td>320</td>
<td>598</td>
<td>…</td>
<td>998</td>
<td>726</td>
<td>296</td>
<td>896</td>
<td>12350</td>
<td>23081</td>
<td>40025</td>
<td>56097</td>
<td>43176</td>
<td>14290</td>
</tr>
<tr>
<td>24.0</td>
<td>439.43040</td>
<td>1717.55340</td>
<td>2876.8572</td>
<td>5503.7736</td>
<td>7292.32740</td>
<td>7240.4076</td>
<td>428.6538</td>
<td>116</td>
<td>344</td>
<td>406</td>
<td>…</td>
<td>668</td>
<td>1048</td>
<td>36</td>
<td>2070</td>
<td>9543</td>
<td>25421</td>
<td>35384</td>
<td>36147</td>
<td>43114</td>
<td>2250</td>
</tr>
<tr>
<td>25.0</td>
<td>572.61420</td>
<td>1178.02440</td>
<td>2201.6388</td>
<td>4710.9924</td>
<td>6168.19260</td>
<td>2200.6362</td>
<td>361.4550</td>
<td>124</td>
<td>166</td>
<td>268</td>
<td>…</td>
<td>682</td>
<td>256</td>
<td>52</td>
<td>2440</td>
<td>5846</td>
<td>11270</td>
<td>26610</td>
<td>40681</td>
<td>14890</td>
<td>3300</td>
</tr>
<tr>
<td>26.0</td>
<td>418.70874</td>
<td>1165.96680</td>
<td>1794.1890</td>
<td>3139.2852</td>
<td>4016.67060</td>
<td>3301.8498</td>
<td>408.2202</td>
<td>96</td>
<td>148</td>
<td>272</td>
<td>…</td>
<td>418</td>
<td>354</td>
<td>60</td>
<td>1608</td>
<td>3417</td>
<td>10548</td>
<td>16839</td>
<td>20100</td>
<td>17663</td>
<td>2300</td>
</tr>
<tr>
<td>27.0</td>
<td>359.17320</td>
<td>1164.15960</td>
<td>1426.4550</td>
<td>2850.1320</td>
<td>3498.30300</td>
<td>2040.8454</td>
<td>-100.0000</td>
<td>40</td>
<td>152</td>
<td>226</td>
<td>…</td>
<td>340</td>
<td>164</td>
<td>-100</td>
<td>1100</td>
<td>3615</td>
<td>7525</td>
<td>15935</td>
<td>19770</td>
<td>11796</td>
<td>-100</td>
</tr>
<tr>
<td>28.0</td>
<td>333.84240</td>
<td>479.34000</td>
<td>1152.5958</td>
<td>2205.8778</td>
<td>1992.60540</td>
<td>521.7666</td>
<td>-100.0000</td>
<td>28</td>
<td>90</td>
<td>220</td>
<td>…</td>
<td>186</td>
<td>44</td>
<td>-100</td>
<td>466</td>
<td>1860</td>
<td>7901</td>
<td>15370</td>
<td>10872</td>
<td>2500</td>
<td>-100</td>
</tr>
<tr>
<td>29.0</td>
<td>236.74020</td>
<td>695.88480</td>
<td>568.2594</td>
<td>1447.5906</td>
<td>1398.78540</td>
<td>715.9404</td>
<td>-100.0000</td>
<td>54</td>
<td>56</td>
<td>80</td>
<td>…</td>
<td>180</td>
<td>106</td>
<td>-100</td>
<td>2490</td>
<td>2000</td>
<td>3816</td>
<td>8220</td>
<td>10292</td>
<td>5950</td>
<td>-100</td>
</tr>
<tr>
<td>30.0</td>
<td>125.53740</td>
<td>441.14160</td>
<td>733.6416</td>
<td>743.4468</td>
<td>578.32020</td>
<td>123.3774</td>
<td>-100.0000</td>
<td>14</td>
<td>54</td>
<td>76</td>
<td>…</td>
<td>90</td>
<td>28</td>
<td>-100</td>
<td>210</td>
<td>2440</td>
<td>4370</td>
<td>6310</td>
<td>3440</td>
<td>1500</td>
<td>-100</td>
</tr>
<tr>
<td>31.0</td>
<td>41.58600</td>
<td>314.92980</td>
<td>659.2626</td>
<td>1166.7606</td>
<td>315.53460</td>
<td>200.1708</td>
<td>-100.0000</td>
<td>12</td>
<td>36</td>
<td>68</td>
<td>…</td>
<td>12</td>
<td>16</td>
<td>-100</td>
<td>200</td>
<td>1300</td>
<td>3500</td>
<td>8710</td>
<td>1050</td>
<td>1500</td>
<td>-100</td>
</tr>
<tr>
<td>32.0</td>
<td>179.14380</td>
<td>315.54180</td>
<td>457.5174</td>
<td>541.8996</td>
<td>66.19740</td>
<td>-100.0000</td>
<td>-100.0000</td>
<td>40</td>
<td>56</td>
<td>68</td>
<td>…</td>
<td>10</td>
<td>-100</td>
<td>-100</td>
<td>1600</td>
<td>860</td>
<td>2300</td>
<td>6040</td>
<td>800</td>
<td>-100</td>
<td>-100</td>
</tr>
<tr>
<td>33.0</td>
<td>198.77880</td>
<td>153.34680</td>
<td>284.8218</td>
<td>116.7516</td>
<td>245.45166</td>
<td>-100.0000</td>
<td>-100.0000</td>
<td>32</td>
<td>12</td>
<td>42</td>
<td>…</td>
<td>60</td>
<td>-100</td>
<td>-100</td>
<td>1200</td>
<td>220</td>
<td>2065</td>
<td>1130</td>
<td>2050</td>
<td>-100</td>
<td>-100</td>
</tr>
<tr>
<td>34.0</td>
<td>49.11360</td>
<td>276.88260</td>
<td>268.4100</td>
<td>340.7124</td>
<td>174.54540</td>
<td>-100.0000</td>
<td>-100.0000</td>
<td>12</td>
<td>56</td>
<td>28</td>
<td>…</td>
<td>14</td>
<td>-100</td>
<td>-100</td>
<td>150</td>
<td>3380</td>
<td>1150</td>
<td>2400</td>
<td>2764</td>
<td>-100</td>
<td>-100</td>
</tr>
<tr>
<td>35.0</td>
<td>229.31280</td>
<td>54.04680</td>
<td>170.4930</td>
<td>634.7688</td>
<td>115.06440</td>
<td>-100.0000</td>
<td>-100.0000</td>
<td>54</td>
<td>8</td>
<td>26</td>
<td>…</td>
<td>12</td>
<td>-100</td>
<td>-100</td>
<td>1350</td>
<td>500</td>
<td>1950</td>
<td>3800</td>
<td>800</td>
<td>-100</td>
<td>-100</td>
</tr>
<tr>
<td>36.0</td>
<td>-100.00000</td>
<td>150.13140</td>
<td>333.6474</td>
<td>73.6980</td>
<td>-100.00000</td>
<td>-100.0000</td>
<td>-100.0000</td>
<td>-100</td>
<td>16</td>
<td>40</td>
<td>…</td>
<td>-100</td>
<td>-100</td>
<td>-100</td>
<td>-100</td>
<td>500</td>
<td>1950</td>
<td>400</td>
<td>-100</td>
<td>-100</td>
<td>-100</td>
</tr>
<tr>
<td>37.0</td>
<td>22.05960</td>
<td>49.89600</td>
<td>44.9682</td>
<td>-100.0000</td>
<td>451.13160</td>
<td>-100.0000</td>
<td>-100.0000</td>
<td>12</td>
<td>30</td>
<td>6</td>
<td>…</td>
<td>32</td>
<td>-100</td>
<td>-100</td>
<td>300</td>
<td>125</td>
<td>600</td>
<td>-100</td>
<td>1800</td>
<td>-100</td>
<td>-100</td>
</tr>
<tr>
<td>38.0</td>
<td>71.59500</td>
<td>-100.00000</td>
<td>334.6878</td>
<td>-100.0000</td>
<td>-100.00000</td>
<td>-100.0000</td>
<td>-100.0000</td>
<td>16</td>
<td>-100</td>
<td>46</td>
<td>…</td>
<td>-100</td>
<td>-100</td>
<td>-100</td>
<td>300</td>
<td>-100</td>
<td>2280</td>
<td>-100</td>
<td>-100</td>
<td>-100</td>
<td>-100</td>
</tr>
<tr>
<td>39.0</td>
<td>29.87640</td>
<td>-100.00000</td>
<td>53.7690</td>
<td>86.7246</td>
<td>-100.00000</td>
<td>-100.0000</td>
<td>-100.0000</td>
<td>10</td>
<td>-100</td>
<td>12</td>
<td>…</td>
<td>-100</td>
<td>-100</td>
<td>-100</td>
<td>500</td>
<td>-100</td>
<td>450</td>
<td>500</td>
<td>-100</td>
<td>-100</td>
<td>-100</td>
</tr>
<tr>
<td>40.0</td>
<td>38.55900</td>
<td>51.83580</td>
<td>107.4684</td>
<td>-100.0000</td>
<td>-100.00000</td>
<td>-100.0000</td>
<td>-100.0000</td>
<td>12</td>
<td>14</td>
<td>26</td>
<td>…</td>
<td>-100</td>
<td>-100</td>
<td>-100</td>
<td>150</td>
<td>500</td>
<td>1080</td>
<td>-100</td>
<td>-100</td>
<td>-100</td>
<td>-100</td>
</tr>
<tr>
<td>41.0</td>
<td>-100.00000</td>
<td>108.45720</td>
<td>77.6472</td>
<td>-100.0000</td>
<td>-100.00000</td>
<td>-100.0000</td>
<td>-100.0000</td>
<td>-100</td>
<td>12</td>
<td>14</td>
<td>…</td>
<td>-100</td>
<td>-100</td>
<td>-100</td>
<td>-100</td>
<td>450</td>
<td>800</td>
<td>-100</td>
<td>-100</td>
<td>-100</td>
<td>-100</td>
</tr>
<tr>
<td>43.0</td>
<td>-100.00000</td>
<td>86.05860</td>
<td>-100.0000</td>
<td>-100.0000</td>
<td>-100.00000</td>
<td>-100.0000</td>
<td>-100.0000</td>
<td>-100</td>
<td>10</td>
<td>-100</td>
<td>…</td>
<td>-100</td>
<td>-100</td>
<td>-100</td>
<td>-100</td>
<td>730</td>
<td>-100</td>
<td>-100</td>
<td>-100</td>
<td>-100</td>
<td>-100</td>
</tr>
<tr>
<td>44.0</td>
<td>-100.00000</td>
<td>-100.00000</td>
<td>-100.0000</td>
<td>89.5266</td>
<td>-100.00000</td>
<td>-100.0000</td>
<td>-100.0000</td>
<td>-100</td>
<td>-100</td>
<td>-100</td>
<td>…</td>
<td>-100</td>
<td>-100</td>
<td>-100</td>
<td>-100</td>
<td>-100</td>
<td>-100</td>
<td>500</td>
<td>-100</td>
<td>-100</td>
<td>-100</td>
</tr>
</tbody>
</table>
<p>28 rows × 21 columns</p>
<h3 id="交叉表"><a href="#交叉表" class="headerlink" title="交叉表"></a>交叉表</h3><pre><code class="python">pd.crosstab(df_data[&#39;LeagueIndex&#39;],
            df_data[&#39;Age&#39;])
</code></pre>
<table>
<thead>
<tr>
<th>Age</th>
<th>16.0</th>
<th>17.0</th>
<th>18.0</th>
<th>19.0</th>
<th>20.0</th>
<th>21.0</th>
<th>22.0</th>
<th>23.0</th>
<th>24.0</th>
<th>25.0</th>
<th>…</th>
<th>34.0</th>
<th>35.0</th>
<th>36.0</th>
<th>37.0</th>
<th>38.0</th>
<th>39.0</th>
<th>40.0</th>
<th>41.0</th>
<th>43.0</th>
<th>44.0</th>
</tr>
</thead>
<tbody>
<tr>
<td>LeagueIndex</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>1</td>
<td>18</td>
<td>9</td>
<td>13</td>
<td>12</td>
<td>22</td>
<td>12</td>
<td>12</td>
<td>6</td>
<td>9</td>
<td>11</td>
<td>…</td>
<td>1</td>
<td>5</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>2</td>
<td>38</td>
<td>22</td>
<td>38</td>
<td>32</td>
<td>25</td>
<td>23</td>
<td>28</td>
<td>24</td>
<td>24</td>
<td>18</td>
<td>…</td>
<td>5</td>
<td>1</td>
<td>2</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>2</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>3</td>
<td>48</td>
<td>43</td>
<td>56</td>
<td>53</td>
<td>47</td>
<td>44</td>
<td>47</td>
<td>47</td>
<td>32</td>
<td>26</td>
<td>…</td>
<td>3</td>
<td>3</td>
<td>5</td>
<td>1</td>
<td>4</td>
<td>1</td>
<td>2</td>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>4</td>
<td>45</td>
<td>49</td>
<td>78</td>
<td>71</td>
<td>97</td>
<td>81</td>
<td>75</td>
<td>72</td>
<td>52</td>
<td>45</td>
<td>…</td>
<td>4</td>
<td>7</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>5</td>
<td>55</td>
<td>71</td>
<td>81</td>
<td>68</td>
<td>80</td>
<td>96</td>
<td>81</td>
<td>59</td>
<td>58</td>
<td>51</td>
<td>…</td>
<td>2</td>
<td>1</td>
<td>0</td>
<td>2</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>6</td>
<td>50</td>
<td>51</td>
<td>56</td>
<td>73</td>
<td>86</td>
<td>83</td>
<td>68</td>
<td>42</td>
<td>48</td>
<td>15</td>
<td>…</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>7</td>
<td>2</td>
<td>3</td>
<td>3</td>
<td>4</td>
<td>0</td>
<td>5</td>
<td>3</td>
<td>9</td>
<td>2</td>
<td>2</td>
<td>…</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
</tbody>
</table>
<p>7 rows × 28 columns</p>
<pre><code class="python">pd.crosstab(df_data[&#39;LeagueIndex&#39;],
            [df_data[&#39;Age&#39;], df_data[&#39;HoursPerWeek&#39;]])
</code></pre>
<table>
<thead>
<tr>
<th>Age</th>
<th>16.0</th>
<th>…</th>
<th>39.0</th>
<th>40.0</th>
<th>41.0</th>
<th>43.0</th>
<th>44.0</th>
</tr>
</thead>
<tbody>
<tr>
<td>HoursPerWeek</td>
<td>0.0</td>
<td>2.0</td>
<td>4.0</td>
<td>6.0</td>
<td>8.0</td>
<td>10.0</td>
<td>12.0</td>
<td>14.0</td>
<td>16.0</td>
<td>20.0</td>
<td>…</td>
<td>12.0</td>
<td>10.0</td>
<td>12.0</td>
<td>14.0</td>
<td>16.0</td>
<td>4.0</td>
<td>8.0</td>
<td>14.0</td>
<td>10.0</td>
<td>6.0</td>
</tr>
<tr>
<td>LeagueIndex</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>3</td>
<td>1</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>3</td>
<td>…</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>2</td>
<td>0</td>
<td>0</td>
<td>2</td>
<td>1</td>
<td>0</td>
<td>9</td>
<td>4</td>
<td>4</td>
<td>3</td>
<td>3</td>
<td>…</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>3</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>6</td>
<td>7</td>
<td>6</td>
<td>6</td>
<td>7</td>
<td>2</td>
<td>1</td>
<td>…</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>4</td>
<td>0</td>
<td>2</td>
<td>5</td>
<td>1</td>
<td>6</td>
<td>4</td>
<td>3</td>
<td>6</td>
<td>3</td>
<td>1</td>
<td>…</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>5</td>
<td>0</td>
<td>1</td>
<td>2</td>
<td>1</td>
<td>3</td>
<td>8</td>
<td>3</td>
<td>6</td>
<td>3</td>
<td>6</td>
<td>…</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>6</td>
<td>1</td>
<td>1</td>
<td>4</td>
<td>2</td>
<td>1</td>
<td>1</td>
<td>4</td>
<td>3</td>
<td>1</td>
<td>7</td>
<td>…</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>7</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>…</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
</tbody>
</table>
<p>7 rows × 325 columns</p>
]]></content>
      <categories>
        <category>DataAnalysis</category>
      </categories>
  </entry>
  <entry>
    <title>Pandas使用——分组聚合</title>
    <url>/blog/oq4xcx/</url>
    <content><![CDATA[<h2 id="一、分组"><a href="#一、分组" class="headerlink" title="一、分组"></a>一、分组</h2><h3 id="GroupBy-对象"><a href="#GroupBy-对象" class="headerlink" title="GroupBy 对象"></a>GroupBy 对象</h3><blockquote>
<p>· groupedby 函数中的参数：</p>
</blockquote>
<pre><code>as_index的作用：控制聚合输出是否以组标签为索引值，默认为True，就是分层次的索引，若为False多加一列默认索引索引，相当于非其他数据排序好了。
但是这两组标签索引值不同有什么作用呢？=== 作用就是，根据的一列是否为索引列。
sort_values的作用：对选定的一列数值数据从上往下从小到大进行排序（如果传值没成功===设置本体覆盖，传值覆盖）
</code></pre><pre><code class="python">import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.pyplot
%matplotlib inline
</code></pre>
<pre><code class="python">dict_obj = {&#39;key1&#39; : [&#39;a&#39;, &#39;b&#39;, &#39;a&#39;, &#39;b&#39;,
                      &#39;a&#39;, &#39;b&#39;, &#39;a&#39;, &#39;a&#39;],
            &#39;key2&#39; : [&#39;one&#39;, &#39;one&#39;, &#39;two&#39;, &#39;three&#39;,
                      &#39;two&#39;, &#39;two&#39;, &#39;one&#39;, &#39;three&#39;],
            &#39;data1&#39;: np.random.randn(8),
            &#39;data2&#39;: np.random.randn(8)}
df_obj = pd.DataFrame(dict_obj)
print (df_obj)
</code></pre>
<pre><code>  key1   key2     data1     data2
0    a    one -0.147612 -0.348087
1    b    one -0.992986  0.902458
2    a    two  0.547541 -0.310040
3    b  three  0.458871 -1.895392
4    a    two  1.224041  0.220150
5    b    two -0.200124 -1.562237
6    a    one  1.539144 -0.758716
7    a  three  0.385845  0.074309
</code></pre><pre><code class="python">&#39;&#39;&#39;1. dataframe根据key2进行分组&#39;&#39;&#39;
print(df_obj.groupby(&#39;key2&#39;)[&#39;key1&#39;].count())

print (type(df_obj.groupby(&#39;key1&#39;)))
#没有可视化的输出
</code></pre>
<pre><code>key2
one      3
three    2
two      3
Name: key1, dtype: int64
&lt;class &#39;pandas.core.groupby.generic.DataFrameGroupBy&#39;&gt;
</code></pre><pre><code class="python">&#39;&#39;&#39;2. 指定列根据key1进行分组&#39;&#39;&#39;
print (type(df_obj[&#39;data1&#39;].groupby(df_obj[&#39;key1&#39;])))
</code></pre>
<pre><code>&lt;class &#39;pandas.core.groupby.generic.SeriesGroupBy&#39;&gt;
</code></pre><pre><code class="python"># 分组运算
grouped1 = df_obj.groupby(&#39;key1&#39;,as_index=False)
print (grouped1.mean())

grouped2 = df_obj[&#39;data1&#39;].groupby(df_obj[&#39;key1&#39;])#指定某一列的数据在该索引下进行分组并且加以聚合
print (grouped2.mean())
</code></pre>
<pre><code>  key1     data1     data2
0    a  0.709792 -0.224477
1    b -0.244746 -0.851723
key1
a    0.709792
b   -0.244746
Name: data1, dtype: float64
</code></pre><pre><code class="python">&#39;&#39;&#39;3. 按自定义key分组，列表&#39;&#39;&#39;
self_def_key = [1, 1, 2, 2, 2, 1, 1, 1]
df_obj.groupby(self_def_key).mean()
</code></pre>
<table>
<thead>
<tr>
<th></th>
<th>data1</th>
<th>data2</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>0.116853</td>
<td>-0.338455</td>
</tr>
<tr>
<td>2</td>
<td>0.743484</td>
<td>-0.661761</td>
</tr>
</tbody>
</table>
<pre><code class="python">df_obj
</code></pre>
<table>
<thead>
<tr>
<th></th>
<th>key1</th>
<th>key2</th>
<th>data1</th>
<th>data2</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>a</td>
<td>one</td>
<td>-0.147612</td>
<td>-0.348087</td>
</tr>
<tr>
<td>1</td>
<td>b</td>
<td>one</td>
<td>-0.992986</td>
<td>0.902458</td>
</tr>
<tr>
<td>2</td>
<td>a</td>
<td>two</td>
<td>0.547541</td>
<td>-0.310040</td>
</tr>
<tr>
<td>3</td>
<td>b</td>
<td>three</td>
<td>0.458871</td>
<td>-1.895392</td>
</tr>
<tr>
<td>4</td>
<td>a</td>
<td>two</td>
<td>1.224041</td>
<td>0.220150</td>
</tr>
<tr>
<td>5</td>
<td>b</td>
<td>two</td>
<td>-0.200124</td>
<td>-1.562237</td>
</tr>
<tr>
<td>6</td>
<td>a</td>
<td>one</td>
<td>1.539144</td>
<td>-0.758716</td>
</tr>
<tr>
<td>7</td>
<td>a</td>
<td>three</td>
<td>0.385845</td>
<td>0.074309</td>
</tr>
</tbody>
</table>
<pre><code class="python">&#39;&#39;&#39;4. 按多个列多层分组 = = = 通过列表&#39;&#39;&#39;
grouped2 = df_obj.groupby([&#39;key1&#39;, &#39;key2&#39;],as_index=False)
print (grouped2.mean())
print(&#39;--------比较asindex的差异-------&#39;)
grouped2 = df_obj.groupby([&#39;key1&#39;, &#39;key2&#39;],as_index=True)
print (grouped2.mean())
</code></pre>
<pre><code>  key1   key2     data1     data2
0    a    one  0.695766 -0.553401
1    a  three  0.385845  0.074309
2    a    two  0.885791 -0.044945
3    b    one -0.992986  0.902458
4    b  three  0.458871 -1.895392
5    b    two -0.200124 -1.562237
--------比较asindex的差异-------
               data1     data2
key1 key2
a    one    0.695766 -0.553401
     three  0.385845  0.074309
     two    0.885791 -0.044945
b    one   -0.992986  0.902458
     three  0.458871 -1.895392
     two   -0.200124 -1.562237
</code></pre><pre><code class="python"># 多层分组按key的顺序进行===和上面的asindex作用一样，把所选取的列数据当成索引，这才是区别之处
grouped3 = df_obj.groupby([&#39;key2&#39;, &#39;key1&#39;])
print (grouped3.mean())
print (&#39;=============================================&#39;)
&#39;&#39;&#39;PS：如果想按照列进行分组聚合运算 === unstack===也可以通过转置&#39;&#39;&#39;
print (grouped3.mean().unstack())
</code></pre>
<pre><code>               data1     data2
key2  key1
one   a     0.695766 -0.553401
      b    -0.992986  0.902458
three a     0.385845  0.074309
      b     0.458871 -1.895392
two   a     0.885791 -0.044945
      b    -0.200124 -1.562237
=============================================
          data1               data2
key1          a         b         a         b
key2
one    0.695766 -0.992986 -0.553401  0.902458
three  0.385845  0.458871  0.074309 -1.895392
two    0.885791 -0.200124 -0.044945 -1.562237
</code></pre><h3 id="GroupBy-对象遍历迭代"><a href="#GroupBy-对象遍历迭代" class="headerlink" title="GroupBy 对象遍历迭代"></a>GroupBy 对象遍历迭代</h3><pre><code class="python">grouped1
</code></pre>
<pre><code>&lt;pandas.core.groupby.generic.DataFrameGroupBy object at 0x000001AF5B5F9088&gt;
</code></pre><pre><code class="python"># 单层分组
print(grouped1.head(5))
print(&quot;------------------------------------分割线------------------------------------------&quot;)
for group_name, group_data in grouped1:
    print (group_name)
    print (group_data[&#39;data1&#39;])
</code></pre>
<pre><code>  key1   key2     data1     data2
0    a    one -0.147612 -0.348087
1    b    one -0.992986  0.902458
2    a    two  0.547541 -0.310040
3    b  three  0.458871 -1.895392
4    a    two  1.224041  0.220150
5    b    two -0.200124 -1.562237
6    a    one  1.539144 -0.758716
7    a  three  0.385845  0.074309
------------------------------------分割线------------------------------------------
a
0   -0.147612
2    0.547541
4    1.224041
6    1.539144
7    0.385845
Name: data1, dtype: float64
b
1   -0.992986
3    0.458871
5   -0.200124
Name: data1, dtype: float64
</code></pre><pre><code class="python"># 多层分组
for group_name, group_data in grouped2:
    print (group_name)
    print (group_data)
</code></pre>
<pre><code>(&#39;a&#39;, &#39;one&#39;)
  key1 key2     data1     data2
0    a  one -0.147612 -0.348087
6    a  one  1.539144 -0.758716
(&#39;a&#39;, &#39;three&#39;)
  key1   key2     data1     data2
7    a  three  0.385845  0.074309
(&#39;a&#39;, &#39;two&#39;)
  key1 key2     data1    data2
2    a  two  0.547541 -0.31004
4    a  two  1.224041  0.22015
(&#39;b&#39;, &#39;one&#39;)
  key1 key2     data1     data2
1    b  one -0.992986  0.902458
(&#39;b&#39;, &#39;three&#39;)
  key1   key2     data1     data2
3    b  three  0.458871 -1.895392
(&#39;b&#39;, &#39;two&#39;)
  key1 key2     data1     data2
5    b  two -0.200124 -1.562237
</code></pre><pre><code class="python"># GroupBy对象转换list
print(grouped1.mean())
list(grouped1)
</code></pre>
<pre><code>  key1     data1     data2
0    a  0.709792 -0.224477
1    b -0.244746 -0.851723





[(&#39;a&#39;,   key1   key2     data1     data2
  0    a    one -0.147612 -0.348087
  2    a    two  0.547541 -0.310040
  4    a    two  1.224041  0.220150
  6    a    one  1.539144 -0.758716
  7    a  three  0.385845  0.074309), (&#39;b&#39;,   key1   key2     data1     data2
  1    b    one -0.992986  0.902458
  3    b  three  0.458871 -1.895392
  5    b    two -0.200124 -1.562237)]
</code></pre><pre><code class="python"># GroupBy对象转换dict
dict(list(grouped1))
</code></pre>
<pre><code>{&#39;a&#39;:   key1   key2     data1     data2
 0    a    one -0.147612 -0.348087
 2    a    two  0.547541 -0.310040
 4    a    two  1.224041  0.220150
 6    a    one  1.539144 -0.758716
 7    a  three  0.385845  0.074309, &#39;b&#39;:   key1   key2     data1     data2
 1    b    one -0.992986  0.902458
 3    b  three  0.458871 -1.895392
 5    b    two -0.200124 -1.562237}
</code></pre><pre><code class="python"># 按列分组
print (df_obj.dtypes)

# 按数据类型分组
df_obj.groupby(df_obj.dtypes, axis=1).size()
df_obj.groupby(df_obj.dtypes, axis=1).sum()
</code></pre>
<pre><code>key1      object
key2      object
data1    float64
data2    float64
dtype: object
</code></pre><h3 id="其他分组方法"><a href="#其他分组方法" class="headerlink" title="其他分组方法"></a>其他分组方法</h3><ol>
<li>其实列表也是分组的一种方式<br>===用到列表时候，一般都是多层索引了</li>
</ol>
<pre><code class="python">df_obj2 = pd.DataFrame(np.random.randint(1, 10, (5,5)),
                       columns=[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;],
                       index=[&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;])
df_obj2.ix[1, 1:4] = np.NaN
df_obj2
</code></pre>
<pre><code>C:\Users\wztli\Anaconda3\lib\site-packages\ipykernel_launcher.py:4: FutureWarning:
.ix is deprecated. Please use
.loc for label based indexing or
.iloc for positional indexing

See the documentation here:
http://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#ix-indexer-is-deprecated
  after removing the cwd from sys.path.
</code></pre><table>
<thead>
<tr>
<th></th>
<th>a</th>
<th>b</th>
<th>c</th>
<th>d</th>
<th>e</th>
</tr>
</thead>
<tbody>
<tr>
<td>A</td>
<td>4</td>
<td>2.0</td>
<td>6.0</td>
<td>5.0</td>
<td>9</td>
</tr>
<tr>
<td>B</td>
<td>5</td>
<td>NaN</td>
<td>NaN</td>
<td>NaN</td>
<td>6</td>
</tr>
<tr>
<td>C</td>
<td>2</td>
<td>3.0</td>
<td>8.0</td>
<td>6.0</td>
<td>3</td>
</tr>
<tr>
<td>D</td>
<td>9</td>
<td>5.0</td>
<td>6.0</td>
<td>5.0</td>
<td>9</td>
</tr>
<tr>
<td>E</td>
<td>4</td>
<td>1.0</td>
<td>6.0</td>
<td>2.0</td>
<td>1</td>
</tr>
</tbody>
</table>
<ol>
<li>通过字典分组</li>
</ol>
<pre><code class="python"># 通过字典分组
mapping_dict = {&#39;A&#39;:&#39;python&#39;, &#39;B&#39;:&#39;python&#39;, &#39;C&#39;:&#39;java&#39;, &#39;D&#39;:&#39;C&#39;, &#39;E&#39;:&#39;java&#39;}
#df_obj2.groupby(mapping_dict, axis=1).size()
#df_obj2.groupby(mapping_dict, axis=1).count() # 非NaN的个数
print(df_obj2.groupby(mapping_dict, axis=0).sum())
</code></pre>
<pre><code>        a    b     c    d   e
C       9  5.0   6.0  5.0   9
java    6  4.0  14.0  8.0   4
python  9  2.0   6.0  5.0  15
</code></pre><ol start="2">
<li>通过函数分组</li>
</ol>
<pre><code class="python"># 通过函数分组
df_obj3 = pd.DataFrame(np.random.randint(1, 10, (5,5)),
                       columns=[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;],
                       index=[&#39;AA&#39;, &#39;BBB&#39;, &#39;CC&#39;, &#39;D&#39;, &#39;EE&#39;])
#df_obj3

def group_key(idx):
    &quot;&quot;&quot;
        idx 为列索引或行索引
    &quot;&quot;&quot;
    #return idx
    return len(idx)

df_obj3.groupby(group_key).size()

# 以上自定义函数等价于
#df_obj3.groupby(len).size()
</code></pre>
<pre><code>1    1
2    3
3    1
dtype: int64
</code></pre><ol start="3">
<li>通过层级索引级别分组</li>
</ol>
<pre><code class="python"># 通过索引级别分组
columns = pd.MultiIndex.from_arrays([[&#39;Python&#39;, &#39;Java&#39;, &#39;Python&#39;, &#39;Java&#39;, &#39;Python&#39;],
                                     [&#39;A&#39;, &#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;B&#39;]], names=[&#39;language&#39;, &#39;index&#39;])
df_obj4 = pd.DataFrame(np.random.randint(1, 10, (5, 5)), columns=columns)
df_obj4
</code></pre>
<table>
<thead>
<tr>
<th>language</th>
<th>Python</th>
<th>Java</th>
<th>Python</th>
<th>Java</th>
<th>Python</th>
</tr>
</thead>
<tbody>
<tr>
<td>index</td>
<td>A</td>
<td>A</td>
<td>B</td>
<td>C</td>
<td>B</td>
</tr>
<tr>
<td>0</td>
<td>4</td>
<td>6</td>
<td>8</td>
<td>8</td>
<td>4</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>3</td>
<td>2</td>
<td>3</td>
<td>5</td>
</tr>
<tr>
<td>2</td>
<td>3</td>
<td>1</td>
<td>1</td>
<td>5</td>
<td>6</td>
</tr>
<tr>
<td>3</td>
<td>2</td>
<td>9</td>
<td>3</td>
<td>1</td>
<td>9</td>
</tr>
<tr>
<td>4</td>
<td>4</td>
<td>1</td>
<td>5</td>
<td>6</td>
<td>6</td>
</tr>
</tbody>
</table>
<pre><code class="python"># 根据language进行分组
df_obj4.groupby(level=&#39;language&#39;, axis=1).sum()
df_obj4.groupby(level=&#39;index&#39;, axis=1).sum()
</code></pre>
<table>
<thead>
<tr>
<th>index</th>
<th>A</th>
<th>B</th>
<th>C</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>10</td>
<td>12</td>
<td>8</td>
</tr>
<tr>
<td>1</td>
<td>4</td>
<td>7</td>
<td>3</td>
</tr>
<tr>
<td>2</td>
<td>4</td>
<td>7</td>
<td>5</td>
</tr>
<tr>
<td>3</td>
<td>11</td>
<td>12</td>
<td>1</td>
</tr>
<tr>
<td>4</td>
<td>5</td>
<td>11</td>
<td>6</td>
</tr>
</tbody>
</table>
<h2 id="二、聚合"><a href="#二、聚合" class="headerlink" title="二、聚合"></a>二、聚合</h2><pre><code class="python">dict_obj = {&#39;key1&#39; : [&#39;a&#39;, &#39;b&#39;, &#39;a&#39;, &#39;b&#39;,
                      &#39;a&#39;, &#39;b&#39;, &#39;a&#39;, &#39;a&#39;],
            &#39;key2&#39; : [&#39;one&#39;, &#39;one&#39;, &#39;two&#39;, &#39;three&#39;,
                      &#39;two&#39;, &#39;two&#39;, &#39;one&#39;, &#39;three&#39;],
            &#39;data1&#39;: np.random.randint(1,10, 8),
            &#39;data2&#39;: np.random.randint(1,10, 8)}
df_obj5 = pd.DataFrame(dict_obj)
print (df_obj5)
</code></pre>
<pre><code>  key1   key2  data1  data2
0    a    one      9      4
1    b    one      6      7
2    a    two      9      4
3    b  three      9      6
4    a    two      6      2
5    b    two      3      3
6    a    one      1      1
7    a  three      2      6
</code></pre><h3 id="内置的聚合函数"><a href="#内置的聚合函数" class="headerlink" title="内置的聚合函数"></a>内置的聚合函数</h3><pre><code class="python">df_obj5
</code></pre>
<table>
<thead>
<tr>
<th></th>
<th>key1</th>
<th>key2</th>
<th>data1</th>
<th>data2</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>a</td>
<td>one</td>
<td>9</td>
<td>4</td>
</tr>
<tr>
<td>1</td>
<td>b</td>
<td>one</td>
<td>6</td>
<td>7</td>
</tr>
<tr>
<td>2</td>
<td>a</td>
<td>two</td>
<td>9</td>
<td>4</td>
</tr>
<tr>
<td>3</td>
<td>b</td>
<td>three</td>
<td>9</td>
<td>6</td>
</tr>
<tr>
<td>4</td>
<td>a</td>
<td>two</td>
<td>6</td>
<td>2</td>
</tr>
<tr>
<td>5</td>
<td>b</td>
<td>two</td>
<td>3</td>
<td>3</td>
</tr>
<tr>
<td>6</td>
<td>a</td>
<td>one</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>7</td>
<td>a</td>
<td>three</td>
<td>2</td>
<td>6</td>
</tr>
</tbody>
</table>
<pre><code class="python"># 内置的聚合函数
#print (df_obj5.groupby(&#39;key1&#39;).sum())
#print (df_obj5.groupby(&#39;key1&#39;).max())
#print (df_obj5.groupby(&#39;key1&#39;).min())
print (df_obj5.groupby(&#39;key1&#39;).mean())
#print (df_obj5.groupby(&#39;key1&#39;).size())
#print (df_obj5.groupby(&#39;key1&#39;).count())
#print (df_obj5.groupby(&#39;key1&#39;).describe())
&#39;&#39;&#39;
count：分组中非NA的值
std：标准差
var：方差
median：非NA中的中位数
mean：非NA的平均值
25%||50%||75%是什么意思==不造？
&#39;&#39;&#39;
</code></pre>
<pre><code>      data1     data2
key1
a       5.4  3.400000
b       6.0  5.333333





&#39;\ncount：分组中非NA的值\nstd：标准差\nvar：方差\nmedian：非NA中的中位数\nmean：非NA的平均值\n25%||50%||75%是什么意思==不造？\n&#39;
</code></pre><h3 id="自定义聚合函数"><a href="#自定义聚合函数" class="headerlink" title="自定义聚合函数"></a>自定义聚合函数</h3><pre><code class="python"># 自定义聚合函数
def peak_range(df):
    &quot;&quot;&quot;
        返回数值范围
    &quot;&quot;&quot;
    #print type(df) #参数为索引所对应的记录
    return df.max() - df.min()

print (df_obj5.groupby(&#39;key1&#39;).agg(peak_range))
#print df_obj.groupby(&#39;key1&#39;).agg(lambda df : df.max() - df.min())
#默认列名就是函数名。
</code></pre>
<pre><code>      data1  data2
key1
a         8      5
b         6      4
</code></pre><ol start="3">
<li>同时应用多个聚合函数：agg</li>
</ol>
<pre><code class="python"># 同时应用多个聚合函数：agg
print (df_obj.groupby(&#39;key1&#39;).agg([&#39;mean&#39;, &#39;std&#39;, &#39;count&#39;]))
</code></pre>
<pre><code>         data1                     data2
          mean       std count      mean       std count
key1
a     0.709792  0.674293     5 -0.224477  0.385674     5
b    -0.244746  0.726957     3 -0.851723  1.528271     3
</code></pre><pre><code class="python">print (df_obj.groupby(&#39;key1&#39;).agg([&#39;mean&#39;, &#39;std&#39;, &#39;count&#39;, (&#39;range&#39;, peak_range)])) # 通过元组提供新的列名
</code></pre>
<pre><code>         data1                               data2
          mean       std count     range      mean       std count     range
key1
a     0.709792  0.674293     5  1.686756 -0.224477  0.385674     5  0.978865
b    -0.244746  0.726957     3  1.451857 -0.851723  1.528271     3  2.797850
</code></pre><pre><code class="python"># 每列作用不同的聚合函数
dict_mapping = {&#39;data1&#39;:&#39;mean&#39;,
                &#39;data2&#39;:&#39;sum&#39;}
print (df_obj.groupby(&#39;key1&#39;).agg(dict_mapping))
</code></pre>
<pre><code>         data1     data2
key1
a     0.709792 -1.122384
b    -0.244746 -2.555170
</code></pre><pre><code class="python">dict_mapping = {&#39;data1&#39;:[&#39;mean&#39;,&#39;max&#39;],
                &#39;data2&#39;:&#39;sum&#39;}
print (df_obj.groupby(&#39;key1&#39;).agg(dict_mapping))
</code></pre>
<pre><code>         data1               data2
          mean       max       sum
key1
a     0.709792  1.539144 -1.122384
b    -0.244746  0.458871 -2.555170
</code></pre><h2 id="三、分组运算"><a href="#三、分组运算" class="headerlink" title="三、分组运算"></a>三、分组运算</h2><pre><code class="python">import pandas as pd
import numpy as np
</code></pre>
<h3 id="分组和对齐"><a href="#分组和对齐" class="headerlink" title="分组和对齐"></a>分组和对齐</h3><pre><code class="python">s1 = pd.Series(range(10, 20), index = range(10))
s2 = pd.Series(range(20, 25), index = range(5))
print (&#39;s1: &#39; )
print (s1)
print(&#39;===========================&#39;)
print (&#39;s2: &#39;)
print (s2)
</code></pre>
<pre><code>s1:
0    10
1    11
2    12
3    13
4    14
5    15
6    16
7    17
8    18
9    19
dtype: int64
===========================
s2:
0    20
1    21
2    22
3    23
4    24
dtype: int64
</code></pre><pre><code class="python"># Series 对齐运算
s1 + s2
print(s1+s2)
</code></pre>
<pre><code>0    30.0
1    32.0
2    34.0
3    36.0
4    38.0
5     NaN
6     NaN
7     NaN
8     NaN
9     NaN
dtype: float64
</code></pre><pre><code class="python">df1 = pd.DataFrame(np.ones((2,2)), columns = [&#39;a&#39;, &#39;b&#39;])
df2 = pd.DataFrame(np.ones((3,3)), columns = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;])

print (&#39;df1: &#39;)
print (df1)
print (&#39;=================&#39;)
print (&#39;df2: &#39;)
print (df2)
</code></pre>
<pre><code>df1:
     a    b
0  1.0  1.0
1  1.0  1.0
=================
df2:
     a    b    c
0  1.0  1.0  1.0
1  1.0  1.0  1.0
2  1.0  1.0  1.0
</code></pre><pre><code class="python"># DataFrame对齐操作
print(df1 + df2)
</code></pre>
<pre><code>     a    b   c
0  2.0  2.0 NaN
1  2.0  2.0 NaN
2  NaN  NaN NaN
</code></pre><p>① 常用运算函数</p>
<pre><code class="python">
# 填充未对齐的数据进行运算
print(s1.add(s2, fill_value = -1))
</code></pre>
<pre><code>0    30.0
1    32.0
2    34.0
3    36.0
4    38.0
5    14.0
6    15.0
7    16.0
8    17.0
9    18.0
dtype: float64
</code></pre><pre><code class="python">df1.sub(df2, fill_value = 2.)
#sub函数
</code></pre>
<table>
<thead>
<tr>
<th></th>
<th>a</th>
<th>b</th>
<th>c</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0.0</td>
<td>0.0</td>
<td>1.0</td>
</tr>
<tr>
<td>1</td>
<td>0.0</td>
<td>0.0</td>
<td>1.0</td>
</tr>
<tr>
<td>2</td>
<td>1.0</td>
<td>1.0</td>
<td>1.0</td>
</tr>
</tbody>
</table>
<pre><code class="python"># 填充NaN
s3 = s1 + s2
print (s3)
</code></pre>
<pre><code>0    30.0
1    32.0
2    34.0
3    36.0
4    38.0
5     NaN
6     NaN
7     NaN
8     NaN
9     NaN
dtype: float64
</code></pre><pre><code class="python">s3_filled = s3.fillna(-1)
print (s3)
</code></pre>
<pre><code>0    30.0
1    32.0
2    34.0
3    36.0
4    38.0
5     NaN
6     NaN
7     NaN
8     NaN
9     NaN
dtype: float64
</code></pre><pre><code class="python">df3 = df1 + df2
print (df3)
</code></pre>
<pre><code>     a    b   c
0  2.0  2.0 NaN
1  2.0  2.0 NaN
2  NaN  NaN NaN
</code></pre><pre><code class="python">df3.fillna(100, inplace = True)
print (df3)
</code></pre>
<pre><code>       a      b      c
0    2.0    2.0  100.0
1    2.0    2.0  100.0
2  100.0  100.0  100.0
</code></pre><h3 id="统计计算-VS-聚合运算"><a href="#统计计算-VS-聚合运算" class="headerlink" title="统计计算 VS 聚合运算"></a>统计计算 VS 聚合运算</h3><pre><code class="python">df_obj1 = pd.DataFrame(np.random.randn(5,4), columns = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;])
print(df_obj1)
</code></pre>
<pre><code>          a         b         c         d
0 -0.542708  0.201376  1.111431  1.784324
1  0.583422  0.231096 -2.801967  0.568497
2 -0.577329 -1.668581 -0.842126  1.803080
3 -0.128431 -1.769619  2.089983  0.209761
4  0.493981 -1.571405  0.690019 -0.215292
</code></pre><pre><code class="python">print(df_obj1.sum(axis=1))
print(&#39;=====================================&#39;)
print(df_obj1.max())
print(&#39;=====================================&#39;)
print(df_obj1.min(axis=1))
</code></pre>
<pre><code>0    2.554423
1   -1.418952
2   -1.284956
3    0.401694
4   -0.602698
dtype: float64
=====================================
a    0.583422
b    0.231096
c    2.089983
d    1.803080
dtype: float64
=====================================
0   -0.542708
1   -2.801967
2   -1.668581
3   -1.769619
4   -1.571405
dtype: float64
</code></pre><h3 id="数据分组运算"><a href="#数据分组运算" class="headerlink" title="数据分组运算"></a>数据分组运算</h3><pre><code class="python"># 分组运算后保持shape
dict_obj = {&#39;key1&#39; : [&#39;a&#39;, &#39;b&#39;, &#39;a&#39;, &#39;b&#39;,
                      &#39;a&#39;, &#39;b&#39;, &#39;a&#39;, &#39;a&#39;],
            &#39;key2&#39; : [&#39;one&#39;, &#39;one&#39;, &#39;two&#39;, &#39;three&#39;,
                      &#39;two&#39;, &#39;two&#39;, &#39;one&#39;, &#39;three&#39;],
            &#39;data1&#39;: np.random.randint(1, 10, 8),
            &#39;data2&#39;: np.random.randint(1, 10, 8)}
df_obj = pd.DataFrame(dict_obj)
df_obj
</code></pre>
<table>
<thead>
<tr>
<th></th>
<th>key1</th>
<th>key2</th>
<th>data1</th>
<th>data2</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>a</td>
<td>one</td>
<td>4</td>
<td>3</td>
</tr>
<tr>
<td>1</td>
<td>b</td>
<td>one</td>
<td>4</td>
<td>4</td>
</tr>
<tr>
<td>2</td>
<td>a</td>
<td>two</td>
<td>9</td>
<td>6</td>
</tr>
<tr>
<td>3</td>
<td>b</td>
<td>three</td>
<td>8</td>
<td>2</td>
</tr>
<tr>
<td>4</td>
<td>a</td>
<td>two</td>
<td>3</td>
<td>3</td>
</tr>
<tr>
<td>5</td>
<td>b</td>
<td>two</td>
<td>6</td>
<td>2</td>
</tr>
<tr>
<td>6</td>
<td>a</td>
<td>one</td>
<td>4</td>
<td>1</td>
</tr>
<tr>
<td>7</td>
<td>a</td>
<td>three</td>
<td>2</td>
<td>2</td>
</tr>
</tbody>
</table>
<pre><code class="python"># 按key1分组后，计算data1，data2的统计信息======并附加到原始表格中
k1_sum = df_obj.groupby(&#39;key1&#39;).sum().add_prefix(&#39;sum_&#39;)
print(k1_sum)
print(&#39;================================&#39;)
print(df_obj)
</code></pre>
<pre><code>      sum_data1  sum_data2
key1
a            22         15
b            18          8
================================
  key1   key2  data1  data2
0    a    one      4      3
1    b    one      4      4
2    a    two      9      6
3    b  three      8      2
4    a    two      3      3
5    b    two      6      2
6    a    one      4      1
7    a  three      2      2
</code></pre><ol>
<li>merge 方法</li>
</ol>
<pre><code class="python"># 方法1，使用merge
pd.merge(df_obj, k1_sum, left_on=&#39;key1&#39;, right_index=True)
</code></pre>
<table>
<thead>
<tr>
<th></th>
<th>key1</th>
<th>key2</th>
<th>data1</th>
<th>data2</th>
<th>sum_data1</th>
<th>sum_data2</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>a</td>
<td>one</td>
<td>4</td>
<td>3</td>
<td>22</td>
<td>15</td>
</tr>
<tr>
<td>2</td>
<td>a</td>
<td>two</td>
<td>9</td>
<td>6</td>
<td>22</td>
<td>15</td>
</tr>
<tr>
<td>4</td>
<td>a</td>
<td>two</td>
<td>3</td>
<td>3</td>
<td>22</td>
<td>15</td>
</tr>
<tr>
<td>6</td>
<td>a</td>
<td>one</td>
<td>4</td>
<td>1</td>
<td>22</td>
<td>15</td>
</tr>
<tr>
<td>7</td>
<td>a</td>
<td>three</td>
<td>2</td>
<td>2</td>
<td>22</td>
<td>15</td>
</tr>
<tr>
<td>1</td>
<td>b</td>
<td>one</td>
<td>4</td>
<td>4</td>
<td>18</td>
<td>8</td>
</tr>
<tr>
<td>3</td>
<td>b</td>
<td>three</td>
<td>8</td>
<td>2</td>
<td>18</td>
<td>8</td>
</tr>
<tr>
<td>5</td>
<td>b</td>
<td>two</td>
<td>6</td>
<td>2</td>
<td>18</td>
<td>8</td>
</tr>
</tbody>
</table>
<ol start="2">
<li>transform 方法</li>
</ol>
<pre><code class="python"># 方法2，使用transform
k1_sum_tf = df_obj.groupby(&#39;key1&#39;).transform(np.sum).add_prefix(&#39;sum_&#39;)
df_obj[k1_sum_tf.columns] = k1_sum_tf
df_obj
</code></pre>
<table>
<thead>
<tr>
<th></th>
<th>key1</th>
<th>key2</th>
<th>data1</th>
<th>data2</th>
<th>sum_key2</th>
<th>sum_data1</th>
<th>sum_data2</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>a</td>
<td>one</td>
<td>4</td>
<td>3</td>
<td>onetwotwoonethree</td>
<td>22</td>
<td>15</td>
</tr>
<tr>
<td>1</td>
<td>b</td>
<td>one</td>
<td>4</td>
<td>4</td>
<td>onethreetwo</td>
<td>18</td>
<td>8</td>
</tr>
<tr>
<td>2</td>
<td>a</td>
<td>two</td>
<td>9</td>
<td>6</td>
<td>onetwotwoonethree</td>
<td>22</td>
<td>15</td>
</tr>
<tr>
<td>3</td>
<td>b</td>
<td>three</td>
<td>8</td>
<td>2</td>
<td>onethreetwo</td>
<td>18</td>
<td>8</td>
</tr>
<tr>
<td>4</td>
<td>a</td>
<td>two</td>
<td>3</td>
<td>3</td>
<td>onetwotwoonethree</td>
<td>22</td>
<td>15</td>
</tr>
<tr>
<td>5</td>
<td>b</td>
<td>two</td>
<td>6</td>
<td>2</td>
<td>onethreetwo</td>
<td>18</td>
<td>8</td>
</tr>
<tr>
<td>6</td>
<td>a</td>
<td>one</td>
<td>4</td>
<td>1</td>
<td>onetwotwoonethree</td>
<td>22</td>
<td>15</td>
</tr>
<tr>
<td>7</td>
<td>a</td>
<td>three</td>
<td>2</td>
<td>2</td>
<td>onetwotwoonethree</td>
<td>22</td>
<td>15</td>
</tr>
</tbody>
</table>
<ol start="3">
<li>自定义函数</li>
</ol>
<pre><code class="python"># 自定义函数传入transform
def diff_mean(s):
    &quot;&quot;&quot;
        返回数据与均值的差值
    &quot;&quot;&quot;
    return s - s.mean()

df_obj.groupby(&#39;key1&#39;).transform(diff_mean)
</code></pre>
<table>
<thead>
<tr>
<th></th>
<th>data1</th>
<th>data2</th>
<th>sum_data1</th>
<th>sum_data2</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>-0.4</td>
<td>0.000000</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>-2.0</td>
<td>1.333333</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>2</td>
<td>4.6</td>
<td>3.000000</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>3</td>
<td>2.0</td>
<td>-0.666667</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>4</td>
<td>-1.4</td>
<td>0.000000</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>5</td>
<td>0.0</td>
<td>-0.666667</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>6</td>
<td>-0.4</td>
<td>-2.000000</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>7</td>
<td>-2.4</td>
<td>-1.000000</td>
<td>0</td>
<td>0</td>
</tr>
</tbody>
</table>
<pre><code class="python">dataset_path = &#39;./data/starcraft.csv&#39;
df_data = pd.read_csv(dataset_path, usecols=[&#39;LeagueIndex&#39;, &#39;Age&#39;, &#39;HoursPerWeek&#39;,
                                             &#39;TotalHours&#39;, &#39;APM&#39;])
</code></pre>
<ul>
<li>apply</li>
</ul>
<pre><code class="python">def top_n(df, n=3, column=&#39;APM&#39;):
    &quot;&quot;&quot;
        返回每个分组按 column 的 top n 数据
    &quot;&quot;&quot;
    return df.sort_values(by=column, ascending=False)[:n]

df_data.groupby(&#39;LeagueIndex&#39;).apply(top_n)
</code></pre>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th>LeagueIndex</th>
<th>Age</th>
<th>HoursPerWeek</th>
<th>TotalHours</th>
<th>APM</th>
</tr>
</thead>
<tbody>
<tr>
<td>LeagueIndex</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>1</td>
<td>2214</td>
<td>1</td>
<td>20.0</td>
<td>12.0</td>
<td>730.0</td>
<td>172.9530</td>
</tr>
<tr>
<td></td>
<td>2246</td>
<td>1</td>
<td>27.0</td>
<td>8.0</td>
<td>250.0</td>
<td>141.6282</td>
</tr>
<tr>
<td></td>
<td>1753</td>
<td>1</td>
<td>20.0</td>
<td>28.0</td>
<td>100.0</td>
<td>139.6362</td>
</tr>
<tr>
<td>2</td>
<td>3062</td>
<td>2</td>
<td>20.0</td>
<td>6.0</td>
<td>100.0</td>
<td>179.6250</td>
</tr>
<tr>
<td></td>
<td>3229</td>
<td>2</td>
<td>16.0</td>
<td>24.0</td>
<td>110.0</td>
<td>156.7380</td>
</tr>
<tr>
<td></td>
<td>1520</td>
<td>2</td>
<td>29.0</td>
<td>6.0</td>
<td>250.0</td>
<td>151.6470</td>
</tr>
<tr>
<td>3</td>
<td>1557</td>
<td>3</td>
<td>22.0</td>
<td>6.0</td>
<td>200.0</td>
<td>226.6554</td>
</tr>
<tr>
<td></td>
<td>484</td>
<td>3</td>
<td>19.0</td>
<td>42.0</td>
<td>450.0</td>
<td>220.0692</td>
</tr>
<tr>
<td></td>
<td>2883</td>
<td>3</td>
<td>16.0</td>
<td>8.0</td>
<td>800.0</td>
<td>208.9500</td>
</tr>
<tr>
<td>4</td>
<td>2688</td>
<td>4</td>
<td>26.0</td>
<td>24.0</td>
<td>990.0</td>
<td>249.0210</td>
</tr>
<tr>
<td></td>
<td>1759</td>
<td>4</td>
<td>16.0</td>
<td>6.0</td>
<td>75.0</td>
<td>229.9122</td>
</tr>
<tr>
<td></td>
<td>2637</td>
<td>4</td>
<td>23.0</td>
<td>24.0</td>
<td>650.0</td>
<td>227.2272</td>
</tr>
<tr>
<td>5</td>
<td>3277</td>
<td>5</td>
<td>18.0</td>
<td>16.0</td>
<td>950.0</td>
<td>372.6426</td>
</tr>
<tr>
<td></td>
<td>93</td>
<td>5</td>
<td>17.0</td>
<td>36.0</td>
<td>720.0</td>
<td>335.4990</td>
</tr>
<tr>
<td></td>
<td>202</td>
<td>5</td>
<td>37.0</td>
<td>14.0</td>
<td>800.0</td>
<td>327.7218</td>
</tr>
<tr>
<td>6</td>
<td>734</td>
<td>6</td>
<td>16.0</td>
<td>28.0</td>
<td>730.0</td>
<td>389.8314</td>
</tr>
<tr>
<td></td>
<td>2746</td>
<td>6</td>
<td>16.0</td>
<td>28.0</td>
<td>4000.0</td>
<td>350.4114</td>
</tr>
<tr>
<td></td>
<td>1810</td>
<td>6</td>
<td>21.0</td>
<td>14.0</td>
<td>730.0</td>
<td>323.2506</td>
</tr>
<tr>
<td>7</td>
<td>3127</td>
<td>7</td>
<td>23.0</td>
<td>42.0</td>
<td>2000.0</td>
<td>298.7952</td>
</tr>
<tr>
<td></td>
<td>104</td>
<td>7</td>
<td>21.0</td>
<td>24.0</td>
<td>1000.0</td>
<td>286.4538</td>
</tr>
<tr>
<td></td>
<td>1654</td>
<td>7</td>
<td>18.0</td>
<td>98.0</td>
<td>700.0</td>
<td>236.0316</td>
</tr>
<tr>
<td>8</td>
<td>3393</td>
<td>8</td>
<td>NaN</td>
<td>NaN</td>
<td>NaN</td>
<td>375.8664</td>
</tr>
<tr>
<td></td>
<td>3373</td>
<td>8</td>
<td>NaN</td>
<td>NaN</td>
<td>NaN</td>
<td>364.8504</td>
</tr>
<tr>
<td></td>
<td>3372</td>
<td>8</td>
<td>NaN</td>
<td>NaN</td>
<td>NaN</td>
<td>355.3518</td>
</tr>
</tbody>
</table>
<pre><code class="python"># apply函数接收的参数会传入自定义的函数中
df_data.groupby(&#39;LeagueIndex&#39;).apply(top_n, n=2, column=&#39;Age&#39;)
</code></pre>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th>LeagueIndex</th>
<th>Age</th>
<th>HoursPerWeek</th>
<th>TotalHours</th>
<th>APM</th>
</tr>
</thead>
<tbody>
<tr>
<td>LeagueIndex</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>1</td>
<td>3146</td>
<td>1</td>
<td>40.0</td>
<td>12.0</td>
<td>150.0</td>
<td>38.5590</td>
</tr>
<tr>
<td></td>
<td>3040</td>
<td>1</td>
<td>39.0</td>
<td>10.0</td>
<td>500.0</td>
<td>29.8764</td>
</tr>
<tr>
<td>2</td>
<td>920</td>
<td>2</td>
<td>43.0</td>
<td>10.0</td>
<td>730.0</td>
<td>86.0586</td>
</tr>
<tr>
<td></td>
<td>2437</td>
<td>2</td>
<td>41.0</td>
<td>4.0</td>
<td>200.0</td>
<td>54.2166</td>
</tr>
<tr>
<td>3</td>
<td>1258</td>
<td>3</td>
<td>41.0</td>
<td>14.0</td>
<td>800.0</td>
<td>77.6472</td>
</tr>
<tr>
<td></td>
<td>2972</td>
<td>3</td>
<td>40.0</td>
<td>10.0</td>
<td>500.0</td>
<td>60.5970</td>
</tr>
<tr>
<td>4</td>
<td>1696</td>
<td>4</td>
<td>44.0</td>
<td>6.0</td>
<td>500.0</td>
<td>89.5266</td>
</tr>
<tr>
<td></td>
<td>1729</td>
<td>4</td>
<td>39.0</td>
<td>8.0</td>
<td>500.0</td>
<td>86.7246</td>
</tr>
<tr>
<td>5</td>
<td>202</td>
<td>5</td>
<td>37.0</td>
<td>14.0</td>
<td>800.0</td>
<td>327.7218</td>
</tr>
<tr>
<td></td>
<td>2745</td>
<td>5</td>
<td>37.0</td>
<td>18.0</td>
<td>1000.0</td>
<td>123.4098</td>
</tr>
<tr>
<td>6</td>
<td>3069</td>
<td>6</td>
<td>31.0</td>
<td>8.0</td>
<td>800.0</td>
<td>133.1790</td>
</tr>
<tr>
<td></td>
<td>2706</td>
<td>6</td>
<td>31.0</td>
<td>8.0</td>
<td>700.0</td>
<td>66.9918</td>
</tr>
<tr>
<td>7</td>
<td>2813</td>
<td>7</td>
<td>26.0</td>
<td>36.0</td>
<td>1300.0</td>
<td>188.5512</td>
</tr>
<tr>
<td></td>
<td>1992</td>
<td>7</td>
<td>26.0</td>
<td>24.0</td>
<td>1000.0</td>
<td>219.6690</td>
</tr>
<tr>
<td>8</td>
<td>3340</td>
<td>8</td>
<td>NaN</td>
<td>NaN</td>
<td>NaN</td>
<td>189.7404</td>
</tr>
<tr>
<td></td>
<td>3341</td>
<td>8</td>
<td>NaN</td>
<td>NaN</td>
<td>NaN</td>
<td>287.8128</td>
</tr>
</tbody>
</table>
<ul>
<li>禁止分组 group_keys=False</li>
</ul>
<pre><code class="python">df_data.groupby(&#39;LeagueIndex&#39;, group_keys=False).apply(top_n)
</code></pre>
<table>
<thead>
<tr>
<th></th>
<th>LeagueIndex</th>
<th>Age</th>
<th>HoursPerWeek</th>
<th>TotalHours</th>
<th>APM</th>
</tr>
</thead>
<tbody>
<tr>
<td>2214</td>
<td>1</td>
<td>20.0</td>
<td>12.0</td>
<td>730.0</td>
<td>172.9530</td>
</tr>
<tr>
<td>2246</td>
<td>1</td>
<td>27.0</td>
<td>8.0</td>
<td>250.0</td>
<td>141.6282</td>
</tr>
<tr>
<td>1753</td>
<td>1</td>
<td>20.0</td>
<td>28.0</td>
<td>100.0</td>
<td>139.6362</td>
</tr>
<tr>
<td>3062</td>
<td>2</td>
<td>20.0</td>
<td>6.0</td>
<td>100.0</td>
<td>179.6250</td>
</tr>
<tr>
<td>3229</td>
<td>2</td>
<td>16.0</td>
<td>24.0</td>
<td>110.0</td>
<td>156.7380</td>
</tr>
<tr>
<td>1520</td>
<td>2</td>
<td>29.0</td>
<td>6.0</td>
<td>250.0</td>
<td>151.6470</td>
</tr>
<tr>
<td>1557</td>
<td>3</td>
<td>22.0</td>
<td>6.0</td>
<td>200.0</td>
<td>226.6554</td>
</tr>
<tr>
<td>484</td>
<td>3</td>
<td>19.0</td>
<td>42.0</td>
<td>450.0</td>
<td>220.0692</td>
</tr>
<tr>
<td>2883</td>
<td>3</td>
<td>16.0</td>
<td>8.0</td>
<td>800.0</td>
<td>208.9500</td>
</tr>
<tr>
<td>2688</td>
<td>4</td>
<td>26.0</td>
<td>24.0</td>
<td>990.0</td>
<td>249.0210</td>
</tr>
<tr>
<td>1759</td>
<td>4</td>
<td>16.0</td>
<td>6.0</td>
<td>75.0</td>
<td>229.9122</td>
</tr>
<tr>
<td>2637</td>
<td>4</td>
<td>23.0</td>
<td>24.0</td>
<td>650.0</td>
<td>227.2272</td>
</tr>
<tr>
<td>3277</td>
<td>5</td>
<td>18.0</td>
<td>16.0</td>
<td>950.0</td>
<td>372.6426</td>
</tr>
<tr>
<td>93</td>
<td>5</td>
<td>17.0</td>
<td>36.0</td>
<td>720.0</td>
<td>335.4990</td>
</tr>
<tr>
<td>202</td>
<td>5</td>
<td>37.0</td>
<td>14.0</td>
<td>800.0</td>
<td>327.7218</td>
</tr>
<tr>
<td>734</td>
<td>6</td>
<td>16.0</td>
<td>28.0</td>
<td>730.0</td>
<td>389.8314</td>
</tr>
<tr>
<td>2746</td>
<td>6</td>
<td>16.0</td>
<td>28.0</td>
<td>4000.0</td>
<td>350.4114</td>
</tr>
<tr>
<td>1810</td>
<td>6</td>
<td>21.0</td>
<td>14.0</td>
<td>730.0</td>
<td>323.2506</td>
</tr>
<tr>
<td>3127</td>
<td>7</td>
<td>23.0</td>
<td>42.0</td>
<td>2000.0</td>
<td>298.7952</td>
</tr>
<tr>
<td>104</td>
<td>7</td>
<td>21.0</td>
<td>24.0</td>
<td>1000.0</td>
<td>286.4538</td>
</tr>
<tr>
<td>1654</td>
<td>7</td>
<td>18.0</td>
<td>98.0</td>
<td>700.0</td>
<td>236.0316</td>
</tr>
<tr>
<td>3393</td>
<td>8</td>
<td>NaN</td>
<td>NaN</td>
<td>NaN</td>
<td>375.8664</td>
</tr>
<tr>
<td>3373</td>
<td>8</td>
<td>NaN</td>
<td>NaN</td>
<td>NaN</td>
<td>364.8504</td>
</tr>
<tr>
<td>3372</td>
<td>8</td>
<td>NaN</td>
<td>NaN</td>
<td>NaN</td>
<td>355.3518</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>DataAnalysis</category>
      </categories>
  </entry>
  <entry>
    <title>[转]操作系统核心知识点</title>
    <url>/blog/spobqi/</url>
    <content><![CDATA[<blockquote>
<ul>
<li>本文转载自：<a href="https://www.cnblogs.com/cxuanBlog/p/13297199.html" target="_blank" rel="noopener">5 万字、97 张图总结操作系统核心知识点 - 程序员 cxuan - 博客园</a></li>
<li>添加部分细节自己写的内容</li>
</ul>
</blockquote>
<p>这不是一篇教你如何创建一个操作系统的文章，相反，这是一篇指导性文章，教你从几个方面来理解操作系统。首先你需要知道你为什么要看这篇文章以及为什么要学习操作系统。</p>
<h2 id="搞清楚几个问题"><a href="#搞清楚几个问题" class="headerlink" title="搞清楚几个问题"></a>搞清楚几个问题</h2><p>首先你要搞明白你学习操作系统的目的是什么？操作系统的重要性如何？学习操作系统会给我带来什么？下面我会从这几个方面为你回答下。</p>
<p>操作系统也是一种软件，但是操作系统是一种非常复杂的软件。操作系统提供了几种抽象模型</p>
<ul>
<li>文件：对 I/O 设备的抽象</li>
<li>虚拟内存：对程序存储器的抽象</li>
<li>进程：对一个正在运行程序的抽象</li>
<li>虚拟机：对整个操作系统的抽象</li>
</ul>
<p>这些抽象和我们的日常开发息息相关。搞清楚了操作系统是如何抽象的，才能培养我们的抽象性思维和开发思路。</p>
<p>很多问题都和操作系统相关，操作系统是解决这些问题的基础。如果你不学习操作系统，可能会想着从框架层面来解决，那是你了解的还不够深入，当你学习了操作系统后，能够培养你的全局性思维。</p>
<p>学习操作系统我们能够有效的解决<code>并发</code>问题，并发几乎是互联网的重中之重了，这也从侧面说明了学习操作系统的重要性。</p>
<p>学习操作系统的重点不是让你从头制造一个操作系统，而是告诉你<strong>操作系统是如何工作的</strong>，能够让你对计算机底层有所了解，打实你的基础。</p>
<p>相信你一定清楚什么是编程</p>
<p><strong>Data structures + Algorithms = Programming</strong></p>
<p>操作系统内部会涉及到众多的数据结构和算法描述，能够让你了解算法的基础上，让你编写更优秀的程序。</p>
<p>我认为可以把计算机比作一栋楼</p>
<p>计算机的底层相当于就是楼的根基，计算机应用相当于就是楼的外形，而操作系统就相当于是告诉你大楼的构造原理，编写高质量的软件就相当于是告诉你构建一个稳定的房子。</p>
<h2 id="认识操作系统"><a href="#认识操作系统" class="headerlink" title="认识操作系统"></a>认识操作系统</h2><p>在了解操作系统前，你需要先知道一下什么是计算机系统：现代计算机系统由<strong>一个或多个处理器、主存、打印机、键盘、鼠标、显示器、网络接口以及各种输入/输出设备构成的系统</strong>。这些都属于<code>硬件</code>的范畴。我们程序员不会直接和这些硬件打交道，并且每位程序员不可能会掌握所有计算机系统的细节。</p>
<p>所以计算机科学家在硬件的基础之上，安装了一层软件，这层软件能够根据用户输入的指令达到控制硬件的效果，从而满足用户的需求，这样的软件称为 <code>操作系统</code>，它的任务就是为用户程序提供一个更好、更简单、更清晰的计算机模型。也就是说，操作系统相当于是一个中间层，为用户层和硬件提供各自的借口，屏蔽了不同应用和硬件之间的差异，达到统一标准的作用。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829342-133c5955-ce6b-4c7a-9b0e-74e4a24c0f14.png#align=left&amp;display=inline&amp;height=401&amp;margin=%5Bobject%20Object%5D&amp;originHeight=401&amp;originWidth=698&amp;size=0&amp;status=done&amp;style=none&amp;width=698" alt></p>
<p>上面一个操作系统的简化图，最底层是硬件，硬件包括<strong>芯片、电路板、磁盘、键盘、显示器</strong>等我们上面提到的设备，在硬件之上是软件。大部分计算机有两种运行模式：<code>内核态</code> 和 <code>用户态</code>，软件中最基础的部分是<code>操作系统</code>，它运行在 <code>内核态</code> 中。操作系统具有硬件的访问权，可以执行机器能够运行的任何指令。软件的其余部分运行在 <code>用户态</code> 下。</p>
<p>在大概了解到操作系统之后，我们先来认识一下硬件都有哪些</p>
<h2 id="计算机硬件"><a href="#计算机硬件" class="headerlink" title="计算机硬件"></a>计算机硬件</h2><p>计算机硬件是计算机的重要组成部分，其中包含了 5 个重要的组成部分：<strong>运算器、控制器、存储器、输入设备、输出设备</strong>。</p>
<ul>
<li><code>运算器</code>：运算器最主要的功能是对数据和信息进行加工和运算。它是计算机中执行算数和各种逻辑运算的部件。运算器的基本运算包括加、减、乘、除、移位等操作，这些是由 <code>算术逻辑单元(Arithmetic&amp;logical Unit)</code> 实现的。而运算器主要由算数逻辑单元和寄存器构成。</li>
<li><code>控制器</code>：指按照指定顺序改变主电路或控制电路的部件，它主要起到了控制命令执行的作用，完成协调和指挥整个计算机系统的操作。控制器是由程序计数器、指令寄存器、解码译码器等构成。</li>
</ul>
<blockquote>
<p>运算器和控制器共同组成了 CPU</p>
</blockquote>
<ul>
<li><code>存储器</code>：存储器就是计算机的<code>记忆设备</code>，顾名思义，存储器可以保存信息。存储器分为两种，一种是主存，也就是内存，它是 CPU 主要交互对象，还有一种是外存，比如硬盘软盘等。下面是现代计算机系统的存储架构</li>
<li><code>输入设备</code>：输入设备是给计算机获取外部信息的设备，它主要包括键盘和鼠标。</li>
<li><code>输出设备</code>：输出设备是给用户呈现根据输入设备获取的信息经过一系列的计算后得到显示的设备，它主要包括显示器、打印机等。</li>
</ul>
<p>这五部分也是冯诺伊曼的体系结构，它认为计算机必须具有如下功能：</p>
<p>把需要的程序和数据送至计算机中。必须具有长期记忆程序、数据、中间结果及最终运算结果的能力。能够完成各种算术、逻辑运算和数据传送等数据加工处理的能力。能够根据需要控制程序走向，并能根据指令控制机器的各部件协调操作。能够按照要求将处理结果输出给用户。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829342-9ed0fc8c-06fb-431d-8db6-2caaca0abc0f.png#align=left&amp;display=inline&amp;height=287&amp;margin=%5Bobject%20Object%5D&amp;originHeight=287&amp;originWidth=721&amp;size=0&amp;status=done&amp;style=none&amp;width=721" alt></p>
<p>下面是一张 intel 家族产品图，是一个详细的计算机硬件分类，我们在根据图中涉及到硬件进行介绍</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829351-810b3b3e-2849-45d3-96c8-62280633f4a6.png#align=left&amp;display=inline&amp;height=534&amp;margin=%5Bobject%20Object%5D&amp;originHeight=534&amp;originWidth=747&amp;size=0&amp;status=done&amp;style=none&amp;width=747" alt></p>
<ul>
<li><code>总线(Buses)</code>：在整个系统中运行的是称为总线的电气管道的集合，这些总线在组件之间来回传输字节信息。通常总线被设计成传送定长的字节块，也就是 <code>字(word)</code>。字中的字节数（字长）是一个基本的系统参数，各个系统中都不尽相同。现在大部分的字都是 4 个字节（32 位）或者 8 个字节（64 位）。</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829372-677cad04-111e-4904-a865-109bf7e95c9c.png#align=left&amp;display=inline&amp;height=280&amp;margin=%5Bobject%20Object%5D&amp;originHeight=280&amp;originWidth=731&amp;size=0&amp;status=done&amp;style=none&amp;width=731" alt></p>
<ul>
<li><code>I/O 设备(I/O Devices)</code>：Input/Output 设备是系统和外部世界的连接。上图中有四类 I/O 设备：用于用户输入的键盘和鼠标，用于用户输出的显示器，一个磁盘驱动用来长时间的保存数据和程序。刚开始的时候，可执行程序就保存在磁盘上。<br>每个 I/O 设备连接 I/O 总线都被称为<code>控制器(controller)</code> 或者是 <code>适配器(Adapter)</code>。控制器和适配器之间的主要区别在于封装方式。控制器是 I/O 设备本身或者系统的主印制板电路（通常称作主板）上的芯片组。而适配器则是一块插在主板插槽上的卡。无论组织形式如何，它们的最终目的都是彼此交换信息。</li>
<li><code>主存(Main Memory)</code>，主存是一个<code>临时存储设备</code>，而不是永久性存储，磁盘是 <code>永久性存储</code> 的设备。主存既保存程序，又保存处理器执行流程所处理的数据。从物理组成上说，主存是由一系列 <code>DRAM(dynamic random access memory)</code> 动态随机存储构成的集合。逻辑上说，内存就是一个线性的字节数组，有它唯一的地址编号，从 0 开始。一般来说，组成程序的每条机器指令都由不同数量的字节构成，C 程序变量相对应的数据项的大小根据类型进行变化。比如，在 Linux 的 x86-64 机器上，short 类型的数据需要 2 个字节，int 和 float 需要 4 个字节，而 long 和 double 需要 8 个字节。</li>
<li><code>处理器(Processor)</code>，<code>CPU(central processing unit)</code> 或者简单的处理器，是解释（并执行）存储在主存储器中的指令的引擎。处理器的核心大小为一个字的存储设备（或寄存器），称为<code>程序计数器(PC)</code>。在任何时刻，PC 都指向主存中的某条机器语言指令（即含有该条指令的地址）。<br>从系统通电开始，直到系统断电，处理器一直在不断地执行程序计数器指向的指令，再更新程序计数器，使其指向下一条指令。处理器根据其指令集体系结构定义的指令模型进行操作。在这个模型中，指令按照严格的顺序执行，执行一条指令涉及执行一系列的步骤。处理器从程序计数器指向的内存中读取指令，解释指令中的位，执行该指令指示的一些简单操作，然后更新程序计数器以指向下一条指令。指令与指令之间可能连续，可能不连续（比如 jmp 指令就不会顺序读取）</li>
</ul>
<p>下面是 CPU 可能执行简单操作的几个步骤</p>
<ul>
<li><code>加载(Load)</code>：从主存中拷贝一个字节或者一个字到内存中，覆盖寄存器先前的内容</li>
<li><code>存储(Store)</code>：将寄存器中的字节或字复制到主存储器中的某个位置，从而覆盖该位置的先前内容</li>
<li><code>操作(Operate)</code>：把两个寄存器的内容复制到 <code>ALU(Arithmetic logic unit)</code> 。把两个字进行算术运算，并把结果存储在寄存器中，重写寄存器先前的内容。</li>
</ul>
<blockquote>
<p>算术逻辑单元（ALU）是对数字二进制数执行算术和按位运算的组合数字电子电路。</p>
</blockquote>
<ul>
<li><code>跳转(jump)</code>：从指令中抽取一个字，把这个字复制到<code>程序计数器(PC)</code> 中，覆盖原来的值</li>
</ul>
<h2 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h2><p>关于进程和线程，你需要理解下面这张脑图中的重点</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829389-4c3de174-e023-4600-b910-b01112bd2f4c.png#align=left&amp;display=inline&amp;height=736&amp;margin=%5Bobject%20Object%5D&amp;originHeight=736&amp;originWidth=734&amp;size=0&amp;status=done&amp;style=none&amp;width=734" alt></p>
<h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>操作系统中最核心的概念就是 <code>进程</code>，进程是对正在运行中的程序的一个抽象。操作系统的其他所有内容都是围绕着进程展开的。</p>
<p>在多道程序处理的系统中，CPU 会在<code>进程</code>间快速切换，使每个程序运行几十或者几百毫秒。然而，严格意义来说，在某一个瞬间，CPU 只能运行一个进程，然而我们如果把时间定位为 1 秒内的话，它可能运行多个进程。这样就会让我们产生<code>并行</code>的错觉。因为 CPU 执行速度很快，进程间的换进换出也非常迅速，因此我们很难对多个并行进程进行跟踪。所以，操作系统的设计者开发了用于描述并行的一种概念模型（顺序进程），使得并行更加容易理解和分析。</p>
<h3 id="进程模型"><a href="#进程模型" class="headerlink" title="进程模型"></a>进程模型</h3><p>一个进程就是一个正在执行的程序的实例，进程也包括程序计数器、寄存器和变量的当前值。从概念上来说，每个进程都有各自的虚拟 CPU，但是实际情况是 CPU 会在各个进程之间进行来回切换。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829609-9880b940-5163-45d4-8ef6-b559ab53b55d.png#align=left&amp;display=inline&amp;height=351&amp;margin=%5Bobject%20Object%5D&amp;originHeight=351&amp;originWidth=455&amp;size=0&amp;status=done&amp;style=none&amp;width=455" alt></p>
<p>如上图所示，这是一个具有 4 个程序的多道处理程序，在进程不断切换的过程中，程序计数器也在不同的变化。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829415-2d4059be-d447-4abf-8e77-2df51d6cc6a1.png#align=left&amp;display=inline&amp;height=338&amp;margin=%5Bobject%20Object%5D&amp;originHeight=338&amp;originWidth=647&amp;size=0&amp;status=done&amp;style=none&amp;width=647" alt></p>
<p>在上图中，这 4 道程序被抽象为 4 个拥有各自控制流程（即每个自己的程序计数器）的进程，并且每个程序都独立的运行。当然，实际上只有一个物理程序计数器，每个程序要运行时，其逻辑程序计数器会装载到物理程序计数器中。当程序运行结束后，其物理程序计数器就会是真正的程序计数器，然后再把它放回进程的逻辑计数器中。</p>
<p>从下图我们可以看到，在观察足够长的一段时间后，所有的进程都运行了，<strong>但在任何一个给定的瞬间仅有一个进程真正运行</strong>。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829611-a49b5e88-0d0e-42c3-a103-485b6e5c984b.png#align=left&amp;display=inline&amp;height=274&amp;margin=%5Bobject%20Object%5D&amp;originHeight=274&amp;originWidth=578&amp;size=0&amp;status=done&amp;style=none&amp;width=578" alt></p>
<p>因此，当我们说一个 CPU 只能真正一次运行一个进程的时候，即使有 2 个核（或 CPU），<strong>每一个核也只能一次运行一个线程</strong>。</p>
<p>由于 CPU 会在各个进程之间来回快速切换，所以每个进程在 CPU 中的运行时间是无法确定的。并且当同一个进程再次在 CPU 中运行时，其在 CPU 内部的运行时间往往也是不固定的。</p>
<p>这里的关键思想是<code>认识到一个进程所需的条件</code>，进程是某一类特定活动的总和，它有程序、输入输出以及状态。</p>
<h3 id="进程的创建"><a href="#进程的创建" class="headerlink" title="进程的创建"></a>进程的创建</h3><p>操作系统需要一些方式来创建进程。下面是一些创建进程的方式</p>
<ul>
<li>系统初始化（init）：启动操作系统时，通常会创建若干个进程。</li>
<li>正在运行的程序执行了创建进程的系统调用（比如 fork）</li>
<li>用户请求创建一个新进程：在许多交互式系统中，输入一个命令或者双击图标就可以启动程序，以上任意一种操作都可以选择开启一个新的进程，在基本的 UNIX 系统中运行 X，新进程将接管启动它的窗口。</li>
<li>初始化一个批处理工作</li>
</ul>
<p>从技术上讲，在所有这些情况下，让现有流程执行流程是通过创建系统调用来创建新流程的。该进程可能是正在运行的用户进程，是从键盘或鼠标调用的系统进程或批处理程序。这些就是系统调用创建新进程的过程。该系统调用告诉操作系统创建一个新进程，并直接或间接指示在其中运行哪个程序。</p>
<p>在 UNIX 中，仅有一个系统调用来创建一个新的进程，这个系统调用就是 <code>fork</code>。这个调用会创建一个与调用进程相关的副本。在 fork 后，一个父进程和子进程会有相同的<code>内存映像</code>，相同的环境字符串和相同的打开文件。</p>
<p>在 Windows 中，情况正相反，一个简单的 Win32 功能调用 <code>CreateProcess</code>，会处理流程创建并将正确的程序加载到新的进程中。这个调用会有 10 个参数，包括了需要执行的程序、输入给程序的命令行参数、各种安全属性、有关打开的文件是否继承控制位、优先级信息、进程所需要创建的窗口规格以及指向一个结构的指针，在该结构中新创建进程的信息被返回给调用者。<strong>在 Windows 中，从一开始父进程的地址空间和子进程的地址空间就是不同的</strong>。</p>
<h3 id="进程的终止"><a href="#进程的终止" class="headerlink" title="进程的终止"></a>进程的终止</h3><p>进程在创建之后，它就开始运行并做完成任务。然而，没有什么事儿是永不停歇的，包括进程也一样。进程早晚会发生终止，但是通常是由于以下情况触发的</p>
<ul>
<li><code>正常退出(自愿的)</code> ： 多数进程是由于完成了工作而终止。当编译器完成了所给定程序的编译之后，编译器会执行一个系统调用告诉操作系统它完成了工作。这个调用在 UNIX 中是 <code>exit</code> ，在 Windows 中是 <code>ExitProcess</code>。</li>
<li><code>错误退出(自愿的)</code>：比如执行一条不存在的命令，于是编译器就会提醒并退出。</li>
<li><code>严重错误(非自愿的)</code></li>
<li><code>被其他进程杀死(非自愿的)</code> ： 某个进程执行系统调用告诉操作系统杀死某个进程。在 UNIX 中，这个系统调用是 kill。在 Win32 中对应的函数是 <code>TerminateProcess</code>（注意不是系统调用）。</li>
</ul>
<h3 id="进程的层次结构"><a href="#进程的层次结构" class="headerlink" title="进程的层次结构"></a>进程的层次结构</h3><p>在一些系统中，当一个进程创建了其他进程后，父进程和子进程就会以某种方式进行关联。子进程它自己就会创建更多进程，从而形成一个进程层次结构。</p>
<h4 id="UNIX-进程体系"><a href="#UNIX-进程体系" class="headerlink" title="UNIX 进程体系"></a>UNIX 进程体系</h4><p>在 UNIX 中，进程和它的所有子进程以及子进程的子进程共同组成一个进程组。当用户从键盘中发出一个信号后，该信号被发送给当前与键盘相关的进程组中的所有成员（它们通常是在当前窗口创建的所有活动进程）。每个进程可以分别捕获该信号、忽略该信号或采取默认的动作，即被信号 kill 掉。整个操作系统中所有的进程都隶属于一个单个以 init 为根的进程树。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829468-bff503cb-cf97-4853-aca3-35db5bb67312.png#align=left&amp;display=inline&amp;height=192&amp;margin=%5Bobject%20Object%5D&amp;originHeight=192&amp;originWidth=615&amp;size=0&amp;status=done&amp;style=none&amp;width=615" alt></p>
<h4 id="Windows-进程体系"><a href="#Windows-进程体系" class="headerlink" title="Windows 进程体系"></a>Windows 进程体系</h4><p>相反，Windows 中没有进程层次的概念，Windows 中所有进程都是平等的，唯一类似于层次结构的是在创建进程的时候，父进程得到一个特别的令牌（称为句柄），该句柄可以用来控制子进程。然而，这个令牌可能也会移交给别的操作系统，这样就不存在层次结构了。而在 UNIX 中，进程不能剥夺其子进程的 <code>进程权</code>。（这样看来，还是 Windows 比较<code>渣</code>）。</p>
<h3 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h3><p>尽管每个进程是一个独立的实体，有其自己的程序计数器和内部状态，但是，进程之间仍然需要相互帮助。当一个进程开始运行时，它可能会经历下面这几种状态</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829472-6b2e277f-f4b9-4f38-805d-e9ac73f33129.png#align=left&amp;display=inline&amp;height=495&amp;margin=%5Bobject%20Object%5D&amp;originHeight=495&amp;originWidth=734&amp;size=0&amp;status=done&amp;style=none&amp;width=734" alt></p>
<p>图中会涉及三种状态</p>
<ol>
<li><code>运行态</code>，运行态指的就是进程实际占用 CPU 时间片运行时</li>
<li><code>就绪态</code>，就绪态指的是可运行，但因为其他进程正在运行而处于就绪状态</li>
<li><code>阻塞态</code>，除非某种外部事件发生，否则进程不能运行</li>
</ol>
<h3 id="进程的实现"><a href="#进程的实现" class="headerlink" title="进程的实现"></a>进程的实现</h3><p>操作系统为了执行进程间的切换，会维护着一张表，这张表就是 <code>进程表(process table)</code>。每个进程占用一个进程表项。该表项包含了进程状态的重要信息，包括程序计数器、堆栈指针、内存分配状况、所打开文件的状态、账号和调度信息，以及其他在进程由运行态转换到就绪态或阻塞态时所必须保存的信息。</p>
<p>下面展示了一个典型系统中的关键字段</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829487-6d8a6e92-d068-48a8-b5a0-9e5b74f9ab3f.png#align=left&amp;display=inline&amp;height=500&amp;margin=%5Bobject%20Object%5D&amp;originHeight=500&amp;originWidth=749&amp;size=0&amp;status=done&amp;style=none&amp;width=749" alt></p>
<p>第一列内容与<code>进程管理</code>有关，第二列内容与 <code>存储管理</code>有关，第三列内容与<code>文件管理</code>有关。</p>
<p>现在我们应该对进程表有个大致的了解了，就可以在对单个 CPU 上如何运行多个顺序进程的错觉做更多的解释。与每一 I/O 类相关联的是一个称作 <code>中断向量(interrupt vector)</code> 的位置（靠近内存底部的固定区域）。它包含中断服务程序的入口地址。假设当一个磁盘中断发生时，用户进程 3 正在运行，则中断硬件将程序计数器、程序状态字、有时还有一个或多个寄存器压入堆栈，计算机随即跳转到中断向量所指示的地址。这就是硬件所做的事情。然后软件就随即接管一切剩余的工作。</p>
<p>当中断结束后，操作系统会调用一个 C 程序来处理中断剩下的工作。在完成剩下的工作后，会使某些进程就绪，接着调用调度程序，决定随后运行哪个进程。然后将控制权转移给一段汇编语言代码，为当前的进程装入寄存器值以及内存映射并启动该进程运行，下面显示了中断处理和调度的过程。</p>
<ol>
<li>硬件压入堆栈程序计数器等</li>
<li>硬件从中断向量装入新的程序计数器</li>
<li>汇编语言过程保存寄存器的值</li>
<li>汇编语言过程设置新的堆栈</li>
<li>C 中断服务器运行（典型的读和缓存写入）</li>
<li>调度器决定下面哪个程序先运行</li>
<li>C 过程返回至汇编代码</li>
<li>汇编语言过程开始运行新的当前进程</li>
</ol>
<p>一个进程在执行过程中可能被中断数千次，但关键每次中断后，被中断的进程都返回到与中断发生前完全相同的状态。</p>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>在传统的操作系统中，每个进程都有一个地址空间和一个控制线程。事实上，这是大部分进程的定义。不过，在许多情况下，经常存在同一地址空间中运行多个控制线程的情形，这些线程就像是分离的进程。下面我们就着重探讨一下什么是线程</p>
<h3 id="线程的使用"><a href="#线程的使用" class="headerlink" title="线程的使用"></a>线程的使用</h3><p>或许这个疑问也是你的疑问，为什么要在进程的基础上再创建一个线程的概念，准确的说，这其实是进程模型和线程模型的讨论，回答这个问题，可能需要分三步来回答</p>
<ul>
<li>多线程之间会共享同一块地址空间和所有可用数据的能力，这是进程所不具备的</li>
<li>线程要比进程<code>更轻量级</code>，由于线程更轻，所以它比进程更容易创建，也更容易撤销。在许多系统中，创建一个线程要比创建一个进程快 10 - 100 倍。</li>
<li>第三个原因可能是性能方面的探讨，如果多个线程都是 CPU 密集型的，那么并不能获得性能上的增强，但是如果存在着大量的计算和大量的 I/O 处理，拥有多个线程能在这些活动中彼此重叠进行，从而会加快应用程序的执行速度</li>
</ul>
<h3 id="经典的线程模型"><a href="#经典的线程模型" class="headerlink" title="经典的线程模型"></a>经典的线程模型</h3><p>进程中拥有一个执行的线程，通常简写为 <code>线程(thread)</code>。线程会有程序计数器，用来记录接着要执行哪一条指令；线程实际上 CPU 上调度执行的实体。</p>
<p>下图我们可以看到三个传统的进程，每个进程有自己的地址空间和单个控制线程。每个线程都在不同的地址空间中运行</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829491-73cfd311-e3e5-4381-886b-f904f3c8ca5c.png#align=left&amp;display=inline&amp;height=466&amp;margin=%5Bobject%20Object%5D&amp;originHeight=466&amp;originWidth=658&amp;size=0&amp;status=done&amp;style=none&amp;width=658" alt></p>
<p>下图中，我们可以看到有一个进程三个线程的情况。每个线程都在相同的地址空间中运行。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829501-7e5370fc-b9ec-4804-a862-9c86e00bf231.png#align=left&amp;display=inline&amp;height=429&amp;margin=%5Bobject%20Object%5D&amp;originHeight=429&amp;originWidth=640&amp;size=0&amp;status=done&amp;style=none&amp;width=640" alt></p>
<p>线程不像是进程那样具备较强的独立性。同一个进程中的所有线程都会有完全一样的地址空间，这意味着它们也共享同样的全局变量。由于每个线程都可以访问进程地址空间内每个内存地址，<strong>因此一个线程可以读取、写入甚至擦除另一个线程的堆栈</strong>。线程之间除了共享同一内存空间外，还具有如下不同的内容</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829530-1ce4e3bb-f3b4-4fae-bd6b-2a09cb86e2d3.png#align=left&amp;display=inline&amp;height=333&amp;margin=%5Bobject%20Object%5D&amp;originHeight=333&amp;originWidth=583&amp;size=0&amp;status=done&amp;style=none&amp;width=583" alt></p>
<p>上图左边的是同一个进程中<code>每个线程共享</code>的内容，上图右边是<code>每个线程</code>中的内容。也就是说左边的列表是进程的属性，右边的列表是线程的属性。</p>
<p><strong>线程之间的状态转换和进程之间的状态转换是一样的</strong>。</p>
<p>每个线程都会有自己的堆栈，如下图所示</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829586-41932660-4ab5-42e2-bbb1-bbd660b183f6.png#align=left&amp;display=inline&amp;height=482&amp;margin=%5Bobject%20Object%5D&amp;originHeight=482&amp;originWidth=682&amp;size=0&amp;status=done&amp;style=none&amp;width=682" alt></p>
<h4 id="线程系统调用"><a href="#线程系统调用" class="headerlink" title="线程系统调用"></a>线程系统调用</h4><p>进程通常会从当前的某个单线程开始，然后这个线程通过调用一个库函数（比如 <code>thread_create</code> ）创建新的线程。线程创建的函数会要求指定新创建线程的名称。创建的线程通常都返回一个线程标识符，该标识符就是新线程的名字。</p>
<p>当一个线程完成工作后，可以通过调用一个函数（比如 <code>thread_exit</code>）来退出。紧接着线程消失，状态变为终止，不能再进行调度。在某些线程的运行过程中，可以通过调用函数例如 <code>thread_join</code> ，表示一个线程可以等待另一个线程退出。这个过程阻塞调用线程直到等待特定的线程退出。在这种情况下，线程的创建和终止非常类似于进程的创建和终止。</p>
<p>另一个常见的线程是调用 <code>thread_yield</code>，它允许线程自动放弃 CPU 从而让另一个线程运行。这样一个调用还是很重要的，因为不同于进程，线程是无法利用时钟中断强制让线程让出 CPU 的。</p>
<h3 id="POSIX-线程"><a href="#POSIX-线程" class="headerlink" title="POSIX 线程"></a>POSIX 线程</h3><p><code>POSIX 线程 通常称为 pthreads</code>是一种独立于语言而存在的执行模型，以及并行执行模型。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829568-3bded50a-8029-4644-9e42-c2c6ddf60ca1.png#align=left&amp;display=inline&amp;height=645&amp;margin=%5Bobject%20Object%5D&amp;originHeight=645&amp;originWidth=639&amp;size=0&amp;status=done&amp;style=none&amp;width=639" alt></p>
<p>它允许程序控制时间上重叠的多个不同的工作流程。每个工作流程都称为一个线程，可以通过调用 POSIX Threads API 来实现对这些流程的创建和控制。可以把它理解为线程的标准。</p>
<blockquote>
<p>POSIX Threads 的实现在许多类似且符合 POSIX 的操作系统上可用，例如 <strong>FreeBSD、NetBSD、OpenBSD、Linux、macOS、Android、Solaris</strong>，它在现有 Windows API 之上实现了<strong>pthread</strong>。<br>IEEE 是世界上最大的技术专业组织，致力于为人类的利益而发展技术。</p>
</blockquote>
<table>
<thead>
<tr>
<th>线程调用</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>pthread_create</td>
<td>创建一个新线程</td>
</tr>
<tr>
<td>pthread_exit</td>
<td>结束调用的线程</td>
</tr>
<tr>
<td>pthread_join</td>
<td>等待一个特定的线程退出</td>
</tr>
<tr>
<td>pthread_yield</td>
<td>释放 CPU 来运行另外一个线程</td>
</tr>
<tr>
<td>pthread_attr_init</td>
<td>创建并初始化一个线程的属性结构</td>
</tr>
<tr>
<td>pthread_attr_destory</td>
<td>删除一个线程的属性结构</td>
</tr>
</tbody>
</table>
<p>所有的 Pthreads 都有特定的属性，每一个都含有标识符、一组寄存器（包括程序计数器）和一组存储在结构中的属性。这个属性包括堆栈大小、调度参数以及其他线程需要的项目。</p>
<h3 id="线程实现"><a href="#线程实现" class="headerlink" title="线程实现"></a>线程实现</h3><p>主要有三种实现方式</p>
<ul>
<li>在用户空间中实现线程；</li>
<li>在内核空间中实现线程；</li>
<li>在用户和内核空间中混合实现线程。</li>
</ul>
<p>下面我们分开讨论一下</p>
<h4 id="在用户空间中实现线程"><a href="#在用户空间中实现线程" class="headerlink" title="在用户空间中实现线程"></a>在用户空间中实现线程</h4><p>第一种方法是把整个线程包放在用户空间中，内核对线程一无所知，它不知道线程的存在。所有的这类实现都有同样的通用结构</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829565-1733358e-dbe8-4e1e-ab32-50b95d98a6e3.png#align=left&amp;display=inline&amp;height=466&amp;margin=%5Bobject%20Object%5D&amp;originHeight=466&amp;originWidth=599&amp;size=0&amp;status=done&amp;style=none&amp;width=599" alt></p>
<p>线程在运行时系统之上运行，运行时系统是管理线程过程的集合，包括前面提到的四个过程： pthread_create, pthread_exit, pthread_join 和 pthread_yield。</p>
<h3 id="在内核中实现线程"><a href="#在内核中实现线程" class="headerlink" title="在内核中实现线程"></a>在内核中实现线程</h3><p>当某个线程希望创建一个新线程或撤销一个已有线程时，它会进行一个系统调用，这个系统调用通过对线程表的更新来完成线程创建或销毁工作。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829600-91569966-c35c-4db1-858b-f7fcae7729c3.png#align=left&amp;display=inline&amp;height=515&amp;margin=%5Bobject%20Object%5D&amp;originHeight=515&amp;originWidth=600&amp;size=0&amp;status=done&amp;style=none&amp;width=600" alt></p>
<p>内核中的线程表持有每个线程的寄存器、状态和其他信息。这些信息和用户空间中的线程信息相同，但是位置却被放在了内核中而不是用户空间中。另外，内核还维护了一张进程表用来跟踪系统状态。</p>
<p>所有能够阻塞的调用都会通过系统调用的方式来实现，当一个线程阻塞时，内核可以进行选择，是运行在同一个进程中的另一个线程（如果有就绪线程的话）还是运行一个另一个进程中的线程。但是在用户实现中，运行时系统始终运行自己的线程，直到内核剥夺它的 CPU 时间片（或者没有可运行的线程存在了）为止。</p>
<h3 id="混合实现"><a href="#混合实现" class="headerlink" title="混合实现"></a>混合实现</h3><p>结合用户空间和内核空间的优点，设计人员采用了一种<code>内核级线程</code>的方式，然后将用户级线程与某些或者全部内核线程多路复用起来</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829624-481cc859-db6d-4516-8dc4-6ea9f958c022.png#align=left&amp;display=inline&amp;height=463&amp;margin=%5Bobject%20Object%5D&amp;originHeight=463&amp;originWidth=647&amp;size=0&amp;status=done&amp;style=none&amp;width=647" alt></p>
<p>在这种模型中，编程人员可以自由控制用户线程和内核线程的数量，具有很大的灵活度。采用这种方法，内核只识别内核级线程，并对其进行调度。其中一些内核级线程会被多个用户级线程多路复用。</p>
<h2 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h2><p>进程是需要频繁的和其他进程进行交流的。下面我们会一起讨论有关 <code>进程间通信(Inter Process Communication, IPC)</code> 的问题。大致来说，进程间的通信机制可以分为 6 种</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829616-22b9e251-36fa-4a65-8102-204b899c01ca.png#align=left&amp;display=inline&amp;height=602&amp;margin=%5Bobject%20Object%5D&amp;originHeight=602&amp;originWidth=772&amp;size=0&amp;status=done&amp;style=none&amp;width=772" alt></p>
<p>下面我们分别对其进行概述</p>
<h3 id="信号-signal"><a href="#信号-signal" class="headerlink" title="信号 signal"></a>信号 signal</h3><p>信号是 UNIX 系统最先开始使用的进程间通信机制，因为 Linux 是继承于 UNIX 的，所以 Linux 也支持信号机制，通过向一个或多个进程发送<code>异步事件信号</code>来实现，信号可以从键盘或者访问不存在的位置等地方产生；信号通过 shell 将任务发送给子进程。</p>
<p>你可以在 Linux 系统上输入 <code>kill -l</code> 来列出系统使用的信号，下面是我提供的一些信号</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829652-e25e8aaa-523f-49e7-91a6-13af7872483a.png#align=left&amp;display=inline&amp;height=269&amp;margin=%5Bobject%20Object%5D&amp;originHeight=269&amp;originWidth=736&amp;size=0&amp;status=done&amp;style=none&amp;width=736" alt></p>
<p>进程可以选择忽略发送过来的信号，但是有两个是不能忽略的：<code>SIGSTOP</code> 和 <code>SIGKILL</code> 信号。SIGSTOP 信号会通知当前正在运行的进程执行关闭操作，SIGKILL 信号会通知当前进程应该被杀死。除此之外，进程可以选择它想要处理的信号，进程也可以选择阻止信号，如果不阻止，可以选择自行处理，也可以选择进行内核处理。如果选择交给内核进行处理，那么就执行默认处理。</p>
<p>操作系统会中断目标程序的进程来向其发送信号、在任何非原子指令中，执行都可以中断，如果进程已经注册了新号处理程序，那么就执行进程，如果没有注册，将采用默认处理的方式。</p>
<h3 id="管道-pipe"><a href="#管道-pipe" class="headerlink" title="管道 pipe"></a>管道 pipe</h3><p>Linux 系统中的进程可以通过建立管道 pipe 进行通信</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829658-0cfbf5f9-97b3-4972-8205-7953cdab82b7.png#align=left&amp;display=inline&amp;height=413&amp;margin=%5Bobject%20Object%5D&amp;originHeight=413&amp;originWidth=729&amp;size=0&amp;status=done&amp;style=none&amp;width=729" alt></p>
<p>在两个进程之间，可以建立一个通道，一个进程向这个通道里写入字节流，另一个进程从这个管道中读取字节流。管道是同步的，当进程尝试从空管道读取数据时，该进程会被阻塞，直到有可用数据为止。shell 中的<code>管线 pipelines</code> 就是用管道实现的，当 shell 发现输出</p>
<pre><code class="null">sort &lt;f | head
</code></pre>
<p>它会创建两个进程，一个是 sort，一个是 head，sort，会在这两个应用程序之间建立一个管道使得 sort 进程的标准输出作为 head 程序的标准输入。sort 进程产生的输出就不用写到文件中了，如果管道满了系统会停止 sort 以等待 head 读出数据</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829684-0f55014e-302f-4dbe-9ea8-9ee4d6c9fdeb.png#align=left&amp;display=inline&amp;height=396&amp;margin=%5Bobject%20Object%5D&amp;originHeight=396&amp;originWidth=488&amp;size=0&amp;status=done&amp;style=none&amp;width=488" alt></p>
<p>管道实际上就是 <code>|</code>，两个应用程序不知道有管道的存在，一切都是由 shell 管理和控制的。</p>
<h3 id="共享内存-shared-memory"><a href="#共享内存-shared-memory" class="headerlink" title="共享内存 shared memory"></a>共享内存 shared memory</h3><p>两个进程之间还可以通过共享内存进行进程间通信，其中两个或者多个进程可以访问公共内存空间。两个进程的共享工作是通过共享内存完成的，一个进程所作的修改可以对另一个进程可见(很像线程间的通信)。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829708-7158a6ec-203c-42aa-96bb-7946e3fb959a.png#align=left&amp;display=inline&amp;height=249&amp;margin=%5Bobject%20Object%5D&amp;originHeight=249&amp;originWidth=659&amp;size=0&amp;status=done&amp;style=none&amp;width=659" alt></p>
<p>在使用共享内存前，需要经过一系列的调用流程，流程如下</p>
<ul>
<li>创建共享内存段或者使用已创建的共享内存段<code>(shmget())</code></li>
<li>将进程附加到已经创建的内存段中<code>(shmat())</code></li>
<li>从已连接的共享内存段分离进程<code>(shmdt())</code></li>
<li>对共享内存段执行控制操作<code>(shmctl())</code></li>
</ul>
<h3 id="先入先出队列-FIFO"><a href="#先入先出队列-FIFO" class="headerlink" title="先入先出队列 FIFO"></a>先入先出队列 FIFO</h3><p>先入先出队列 FIFO 通常被称为 <code>命名管道(Named Pipes)</code>，命名管道的工作方式与常规管道非常相似，但是确实有一些明显的区别。未命名的管道没有备份文件：操作系统负责维护内存中的缓冲区，用来将字节从写入器传输到读取器。一旦写入或者输出终止的话，缓冲区将被回收，传输的数据会丢失。相比之下，命名管道具有支持文件和独特 API ，命名管道在文件系统中作为设备的专用文件存在。当所有的进程通信完成后，命名管道将保留在文件系统中以备后用。命名管道具有严格的 FIFO 行为</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829713-f872efe8-5031-4f02-89ad-8c8351a854c7.png#align=left&amp;display=inline&amp;height=192&amp;margin=%5Bobject%20Object%5D&amp;originHeight=192&amp;originWidth=584&amp;size=0&amp;status=done&amp;style=none&amp;width=584" alt></p>
<p>写入的第一个字节是读取的第一个字节，写入的第二个字节是读取的第二个字节，依此类推。</p>
<h3 id="消息队列-Message-Queue"><a href="#消息队列-Message-Queue" class="headerlink" title="消息队列 Message Queue"></a>消息队列 Message Queue</h3><p>一听到消息队列这个名词你可能不知道是什么意思，消息队列是用来描述内核寻址空间内的内部链接列表。可以按几种不同的方式将消息按顺序发送到队列并从队列中检索消息。每个消息队列由 IPC 标识符唯一标识。消息队列有两种模式，一种是<code>严格模式</code>， 严格模式就像是 FIFO 先入先出队列似的，消息顺序发送，顺序读取。还有一种模式是 <code>非严格模式</code>，消息的顺序性不是非常重要。</p>
<h3 id="套接字-Socket"><a href="#套接字-Socket" class="headerlink" title="套接字 Socket"></a>套接字 Socket</h3><p>还有一种管理两个进程间通信的是使用 <code>socket</code>，socket 提供端到端的双相通信。一个套接字可以与一个或多个进程关联。就像管道有命令管道和未命名管道一样，套接字也有两种模式，套接字一般用于两个进程之间的网络通信，网络套接字需要来自诸如<code>TCP（传输控制协议）</code>或较低级别<code>UDP（用户数据报协议）</code>等基础协议的支持。</p>
<p>套接字有以下几种分类</p>
<ul>
<li><code>顺序包套接字(Sequential Packet Socket)</code>： 此类套接字为最大长度固定的数据报提供可靠的连接。此连接是双向的并且是顺序的。</li>
<li><code>数据报套接字(Datagram Socket)</code>：数据包套接字支持双向数据流。数据包套接字接受消息的顺序与发送者可能不同。</li>
<li><code>流式套接字(Stream Socket)</code>：流套接字的工作方式类似于电话对话，提供双向可靠的数据流。</li>
<li><code>原始套接字(Raw Socket)</code>： 可以使用原始套接字访问基础通信协议。</li>
</ul>
<h2 id="调度"><a href="#调度" class="headerlink" title="调度"></a>调度</h2><p>当一个计算机是多道程序设计系统时，会频繁的有很多进程或者线程来同时竞争 CPU 时间片。当两个或两个以上的进程/线程处于就绪状态时，就会发生这种情况。如果只有一个 CPU 可用，那么必须选择接下来哪个进程/线程可以运行。操作系统中有一个叫做 <code>调度程序(scheduler)</code> 的角色存在，它就是做这件事儿的，该程序使用的算法叫做 <code>调度算法(scheduling algorithm)</code> 。</p>
<h3 id="调度算法的分类"><a href="#调度算法的分类" class="headerlink" title="调度算法的分类"></a>调度算法的分类</h3><p>毫无疑问，不同的环境下需要不同的调度算法。之所以出现这种情况，是因为不同的应用程序和不同的操作系统有不同的目标。也就是说，在不同的系统中，调度程序的优化也是不同的。这里有必要划分出三种环境</p>
<ul>
<li><code>批处理(Batch)</code> : 商业领域</li>
<li><code>交互式(Interactive)</code> ： 交互式用户环境</li>
<li><code>实时(Real time)</code></li>
</ul>
<h3 id="批处理中的调度"><a href="#批处理中的调度" class="headerlink" title="批处理中的调度"></a>批处理中的调度</h3><p>现在让我们把目光从一般性的调度转换为特定的调度算法。下面我们会探讨在批处理中的调度。</p>
<h4 id="先来先服务"><a href="#先来先服务" class="headerlink" title="先来先服务"></a>先来先服务</h4><p>最简单的非抢占式调度算法的设计就是 <code>先来先服务(first-come,first-serverd)</code>。当第一个任务从外部进入系统时，将会立即启动并允许运行任意长的时间。它不会因为运行时间太长而中断。当其他作业进入时，它们排到就绪队列尾部。当正在运行的进程阻塞，处于等待队列的第一个进程就开始运行。当一个阻塞的进程重新处于就绪态时，它会像一个新到达的任务，会排在队列的末尾，即排在所有进程最后。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829697-a9e6978f-5f26-4491-8a57-4691ea81546b.png#align=left&amp;display=inline&amp;height=622&amp;margin=%5Bobject%20Object%5D&amp;originHeight=622&amp;originWidth=709&amp;size=0&amp;status=done&amp;style=none&amp;width=709" alt></p>
<p>这个算法的强大之处在于易于理解和编程，在这个算法中，一个单链表记录了所有就绪进程。要选取一个进程运行，只要从该队列的头部移走一个进程即可；要添加一个新的作业或者阻塞一个进程，只要把这个作业或进程附加在队列的末尾即可。这是很简单的一种实现。</p>
<h4 id="最短作业优先"><a href="#最短作业优先" class="headerlink" title="最短作业优先"></a>最短作业优先</h4><p>批处理中，第二种调度算法是 <code>最短作业优先(Shortest Job First)</code>，我们假设运行时间已知。例如，一家保险公司，因为每天要做类似的工作，所以人们可以相当精确地预测处理 1000 个索赔的一批作业需要多长时间。当输入队列中有若干个同等重要的作业被启动时，调度程序应使用最短优先作业算法</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829752-b3677366-5828-45be-9c62-d182dce0a26e.png#align=left&amp;display=inline&amp;height=200&amp;margin=%5Bobject%20Object%5D&amp;originHeight=200&amp;originWidth=695&amp;size=0&amp;status=done&amp;style=none&amp;width=695" alt></p>
<blockquote>
<p>需要注意的是，在所有的进程都可以运行的情况下，最短作业优先的算法才是最优的。</p>
</blockquote>
<h4 id="最短剩余时间优先"><a href="#最短剩余时间优先" class="headerlink" title="最短剩余时间优先"></a>最短剩余时间优先</h4><p>最短作业优先的抢占式版本被称作为 <code>最短剩余时间优先(Shortest Remaining Time Next)</code> 算法。使用这个算法，调度程序总是选择剩余运行时间最短的那个进程运行。</p>
<h3 id="交互式系统中的调度"><a href="#交互式系统中的调度" class="headerlink" title="交互式系统中的调度"></a>交互式系统中的调度</h3><p>交互式系统中在个人计算机、服务器和其他系统中都是很常用的，所以有必要来探讨一下交互式调度</p>
<h4 id="轮询调度"><a href="#轮询调度" class="headerlink" title="轮询调度"></a>轮询调度</h4><p>一种最古老、最简单、最公平并且最广泛使用的算法就是 <code>轮询算法(round-robin)</code>。每个进程都会被分配一个时间段，称为<code>时间片(quantum)</code>，在这个时间片内允许进程运行。如果时间片结束时进程还在运行的话，则抢占一个 CPU 并将其分配给另一个进程。如果进程在时间片结束前阻塞或结束，则 CPU 立即进行切换。轮询算法比较容易实现。调度程序所做的就是维护一个可运行进程的列表，就像下图中的 a，当一个进程用完时间片后就被移到队列的末尾，就像下图的 b。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829772-8a1f4a69-9934-4cf9-b1bd-80a69f410e13.png#align=left&amp;display=inline&amp;height=485&amp;margin=%5Bobject%20Object%5D&amp;originHeight=485&amp;originWidth=724&amp;size=0&amp;status=done&amp;style=none&amp;width=724" alt></p>
<h4 id="优先级调度"><a href="#优先级调度" class="headerlink" title="优先级调度"></a>优先级调度</h4><p>轮询调度假设了所有的进程是同等重要的。但事实情况可能不是这样。例如，在一所大学中的等级制度，首先是院长，然后是教授、秘书、后勤人员，最后是学生。这种将外部情况考虑在内就实现了<code>优先级调度(priority scheduling)</code></p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829781-669962be-9966-4de1-be47-f3e9822459eb.png#align=left&amp;display=inline&amp;height=162&amp;margin=%5Bobject%20Object%5D&amp;originHeight=162&amp;originWidth=678&amp;size=0&amp;status=done&amp;style=none&amp;width=678" alt></p>
<p>它的基本思想很明确，每个进程都被赋予一个优先级，优先级高的进程优先运行。</p>
<h4 id="多级队列"><a href="#多级队列" class="headerlink" title="多级队列"></a>多级队列</h4><p>最早使用优先级调度的系统是 <code>CTSS(Compatible TimeSharing System)</code>。CTSS 在每次切换前都需要将当前进程换出到磁盘，并从磁盘上读入一个新进程。为 CPU 密集型进程设置较长的时间片比频繁地分给他们很短的时间要更有效（减少交换次数）。另一方面，如前所述，长时间片的进程又会影响到响应时间，解决办法是设置优先级类。属于最高优先级的进程运行一个时间片，次高优先级进程运行 2 个时间片，再下面一级运行 4 个时间片，以此类推。当一个进程用完分配的时间片后，它被移到下一类。</p>
<h4 id="最短进程优先"><a href="#最短进程优先" class="headerlink" title="最短进程优先"></a>最短进程优先</h4><p>最短进程优先是根据进程过去的行为进行推测，并执行估计运行时间最短的那一个。假设每个终端上每条命令的预估运行时间为 <code>T0</code>，现在假设测量到其下一次运行时间为 <code>T1</code>，可以用两个值的加权来改进估计时间，即<code>aT0+ (1- 1)T1</code>。通过选择 a 的值，可以决定是尽快忘掉老的运行时间，还是在一段长时间内始终记住它们。当 a = 1/2 时，可以得到下面这个序列</p>
<p><img src="/Users/mr.l/Library/Application Support/typora-user-images/image-20200220120452410.png" alt="image-20200220120452410"></p>
<p>可以看到，在三轮过后，T0 在新的估计值中所占比重下降至 1/8。</p>
<h4 id="保证调度"><a href="#保证调度" class="headerlink" title="保证调度"></a>保证调度</h4><p>一种完全不同的调度方法是对用户做出明确的性能保证。一种实际而且容易实现的保证是：若用户工作时有 n 个用户登录，则每个用户将获得 CPU 处理能力的 1/n。类似地，在一个有 n 个进程运行的单用户系统中，若所有的进程都等价，则每个进程将获得 1/n 的 CPU 时间。</p>
<h4 id="彩票调度"><a href="#彩票调度" class="headerlink" title="彩票调度"></a>彩票调度</h4><p>对用户进行承诺并在随后兑现承诺是一件好事，不过很难实现。但是存在着一种简单的方式，有一种既可以给出预测结果而又有一种比较简单的实现方式的算法，就是 <code>彩票调度(lottery scheduling)</code>算法。</p>
<p>其基本思想是为进程提供各种系统资源（例如 CPU 时间）的彩票。当做出一个调度决策的时候，就随机抽出一张彩票，拥有彩票的进程将获得该资源。在应用到 CPU 调度时，系统可以每秒持有 50 次抽奖，每个中奖者将获得比如 20 毫秒的 CPU 时间作为奖励。</p>
<h4 id="公平分享调度"><a href="#公平分享调度" class="headerlink" title="公平分享调度"></a>公平分享调度</h4><p>到目前为止，我们假设被调度的都是各个进程自身，而不用考虑该进程的拥有者是谁。结果是，如果用户 1 启动了 9 个进程，而用户 2 启动了一个进程，使用轮转或相同优先级调度算法，那么用户 1 将得到 90 % 的 CPU 时间，而用户 2 将之得到 10 % 的 CPU 时间。</p>
<p>为了阻止这种情况的出现，一些系统在调度前会把进程的拥有者考虑在内。在这种模型下，每个用户都会分配一些 CPU 时间，而调度程序会选择进程并强制执行。因此如果两个用户每个都会有 50% 的 CPU 时间片保证，那么无论一个用户有多少个进程，都将获得相同的 CPU 份额。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829805-f1649640-92c0-4cc0-9d11-d33091868df3.png#align=left&amp;display=inline&amp;height=106&amp;margin=%5Bobject%20Object%5D&amp;originHeight=106&amp;originWidth=681&amp;size=0&amp;status=done&amp;style=none&amp;width=681" alt></p>
<h3 id="实时系统中的调度"><a href="#实时系统中的调度" class="headerlink" title="实时系统中的调度"></a>实时系统中的调度</h3><p><code>实时系统(real-time)</code> 是一个时间扮演了重要作用的系统。实时系统可以分为两类，<code>硬实时(hard real time)</code> 和 <code>软实时(soft real time)</code> 系统，前者意味着必须要满足绝对的截止时间；后者的含义是虽然不希望偶尔错失截止时间，但是可以容忍。</p>
<p>实时系统中的事件可以按照响应方式进一步分类为<code>周期性(以规则的时间间隔发生)</code>事件或 <code>非周期性(发生时间不可预知)</code>事件。一个系统可能要响应多个周期性事件流，根据每个事件处理所需的时间，可能甚至无法处理所有事件。例如，如果有 m 个周期事件，事件 i 以周期 Pi 发生，并需要 Ci 秒 CPU 时间处理一个事件，那么可以处理负载的条件是</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829813-d541b483-e6c2-4e61-b29d-faf9719ce83f.png#align=left&amp;display=inline&amp;height=81&amp;margin=%5Bobject%20Object%5D&amp;originHeight=81&amp;originWidth=180&amp;size=0&amp;status=done&amp;style=none&amp;width=180" alt></p>
<p>只有满足这个条件的实时系统称为<code>可调度的</code>，这意味着它实际上能够被实现。一个不满足此检验标准的进程不能被调度，因为这些进程共同需要的 CPU 时间总和大于 CPU 能提供的时间。</p>
<p>下面我们来了解一下内存管理，你需要知道的知识点如下</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829871-ad9be6cd-aa53-4acc-b245-5dd76199a6ba.png#align=left&amp;display=inline&amp;height=380&amp;margin=%5Bobject%20Object%5D&amp;originHeight=380&amp;originWidth=742&amp;size=0&amp;status=done&amp;style=none&amp;width=742" alt></p>
<h2 id="地址空间"><a href="#地址空间" class="headerlink" title="地址空间"></a>地址空间</h2><p>如果要使多个应用程序同时运行在内存中，必须要解决两个问题：<code>保护</code>和 <code>重定位</code>。第一种解决方式是用<code>保护密钥标记内存块</code>，并将执行过程的密钥与提取的每个存储字的密钥进行比较。这种方式只能解决第一种问题（破坏操作系统），但是不能解决多进程在内存中同时运行的问题。</p>
<p>还有一种更好的方式是创造一个存储器抽象：<code>地址空间(the address space)</code>。就像进程的概念创建了一种抽象的 CPU 来运行程序，地址空间也创建了一种抽象内存供程序使用。</p>
<h4 id="基址寄存器和变址寄存器"><a href="#基址寄存器和变址寄存器" class="headerlink" title="基址寄存器和变址寄存器"></a>基址寄存器和变址寄存器</h4><p>最简单的办法是使用<code>动态重定位(dynamic relocation)</code>技术，它就是通过一种简单的方式将每个进程的地址空间映射到物理内存的不同区域。还有一种方式是使用基址寄存器和变址寄存器。</p>
<ul>
<li>基址寄存器：存储数据内存的起始位置</li>
<li>变址寄存器：存储应用程序的长度。</li>
</ul>
<p>每当进程引用内存以获取指令或读取、写入数据时，CPU 都会自动将<code>基址值</code>添加到进程生成的地址中，然后再将其发送到内存总线上。同时，它检查程序提供的地址是否大于或等于<code>变址寄存器</code> 中的值。如果程序提供的地址要超过变址寄存器的范围，那么会产生错误并中止访问。</p>
<h3 id="交换技术"><a href="#交换技术" class="headerlink" title="交换技术"></a>交换技术</h3><p>在程序运行过程中，经常会出现内存不足的问题。</p>
<p>针对上面内存不足的问题，提出了两种处理方式：最简单的一种方式就是<code>交换(swapping)</code>技术，即把一个进程完整的调入内存，然后再内存中运行一段时间，再把它放回磁盘。空闲进程会存储在磁盘中，所以这些进程在没有运行时不会占用太多内存。另外一种策略叫做<code>虚拟内存(virtual memory)</code>，虚拟内存技术能够允许应用程序部分的运行在内存中。下面我们首先先探讨一下交换</p>
<h4 id="交换过程"><a href="#交换过程" class="headerlink" title="交换过程"></a>交换过程</h4><p>下面是一个交换过程</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829844-31f0d41e-db06-4f4a-86d4-15250999e2dd.png#align=left&amp;display=inline&amp;height=349&amp;margin=%5Bobject%20Object%5D&amp;originHeight=349&amp;originWidth=724&amp;size=0&amp;status=done&amp;style=none&amp;width=724" alt></p>
<p>刚开始的时候，只有进程 A 在内存中，然后从创建进程 B 和进程 C 或者从磁盘中把它们换入内存，然后在图 d 中，A 被换出内存到磁盘中，最后 A 重新进来。因为图 g 中的进程 A 现在到了不同的位置，所以在装载过程中需要被重新定位，或者在交换程序时通过软件来执行；或者在程序执行期间通过硬件来重定位。基址寄存器和变址寄存器就适用于这种情况。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829879-4fde9a55-0c36-4d7d-948a-49841539d0c8.png#align=left&amp;display=inline&amp;height=469&amp;margin=%5Bobject%20Object%5D&amp;originHeight=469&amp;originWidth=696&amp;size=0&amp;status=done&amp;style=none&amp;width=696" alt></p>
<p>交换在内存创建了多个 <code>空闲区(hole)</code>，内存会把所有的空闲区尽可能向下移动合并成为一个大的空闲区。这项技术称为<code>内存紧缩(memory compaction)</code>。但是这项技术通常不会使用，因为这项技术会消耗很多 CPU 时间。</p>
<h3 id="空闲内存管理"><a href="#空闲内存管理" class="headerlink" title="空闲内存管理"></a>空闲内存管理</h3><p>在进行内存动态分配时，操作系统必须对其进行管理。大致上说，有两种监控内存使用的方式</p>
<ul>
<li><code>位图(bitmap)</code></li>
<li><code>空闲列表(free lists)</code></li>
</ul>
<h4 id="使用位图的存储管理"><a href="#使用位图的存储管理" class="headerlink" title="使用位图的存储管理"></a>使用位图的存储管理</h4><p>使用位图方法时，内存可能被划分为小到几个字或大到几千字节的分配单元。每个分配单元对应于位图中的一位，0 表示空闲， 1 表示占用（或者相反）。一块内存区域和其对应的位图如下</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829887-83af6188-e02c-4437-8739-40021e8a2957.png#align=left&amp;display=inline&amp;height=303&amp;margin=%5Bobject%20Object%5D&amp;originHeight=303&amp;originWidth=734&amp;size=0&amp;status=done&amp;style=none&amp;width=734" alt></p>
<p><code>位图</code>提供了一种简单的方法在固定大小的内存中跟踪内存的使用情况，因为<strong>位图的大小取决于内存和分配单元的大小</strong>。这种方法有一个问题是，当决定为把具有 k 个分配单元的进程放入内存时，<code>内容管理器(memory manager)</code> 必须搜索位图，在位图中找出能够运行 k 个连续 0 位的串。在位图中找出制定长度的连续 0 串是一个很耗时的操作，这是位图的缺点。（可以简单理解为在杂乱无章的数组中，找出具有一大长串空闲的数组单元）</p>
<h4 id="使用链表进行管理"><a href="#使用链表进行管理" class="headerlink" title="使用链表进行管理"></a>使用链表进行管理</h4><p>另一种记录内存使用情况的方法是，维护一个记录已分配内存段和空闲内存段的链表，段会包含进程或者是两个进程的空闲区域。可用上面的图 c <strong>来表示内存的使用情况</strong>。链表中的每一项都可以代表一个 <code>空闲区(H)</code> 或者是<code>进程(P)</code>的起始标志，长度和下一个链表项的位置。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829908-832c7960-d7cc-45fc-a029-b803b86a6bf9.png#align=left&amp;display=inline&amp;height=432&amp;margin=%5Bobject%20Object%5D&amp;originHeight=432&amp;originWidth=695&amp;size=0&amp;status=done&amp;style=none&amp;width=695" alt></p>
<p>当按照地址顺序在链表中存放进程和空闲区时，有几种算法可以为创建的进程（或者从磁盘中换入的进程）分配内存。我们先假设内存管理器知道应该分配多少内存，最简单的算法是使用 <code>首次适配(first fit)</code>。内存管理器会沿着段列表进行扫描，直到找个一个足够大的空闲区为止。 除非空闲区大小和要分配的空间大小一样，否则将空闲区分为两部分，一部分供进程使用；一部分生成新的空闲区。首次适配算法是一种速度很快的算法，因为它会尽可能的搜索链表。</p>
<p>首次适配的一个小的变体是 <code>下次适配(next fit)</code>。它和首次匹配的工作方式相同，只有一个不同之处那就是下次适配在每次找到合适的空闲区时就会记录当时的位置，以便下次寻找空闲区时从上次结束的地方开始搜索，而不是像首次匹配算法那样每次都会从头开始搜索。</p>
<p>另外一个著名的并且广泛使用的算法是 <code>最佳适配(best fit)</code>。最佳适配会从头到尾寻找整个链表，找出能够容纳进程的最小空闲区。</p>
<h2 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h2><p>尽管基址寄存器和变址寄存器用来创建地址空间的抽象，但是这有一个其他的问题需要解决：<code>管理软件的不断增大(managing bloatware)</code>。虚拟内存的基本思想是，每个程序都有自己的地址空间，这个地址空间被划分为多个称为<code>页面(page)</code>的块。每一页都是连续的地址范围。这些页被映射到物理内存，但并不是所有的页都必须在内存中才能运行程序。当程序引用到一部分在物理内存中的地址空间时，硬件会立刻执行必要的映射。当程序引用到一部分不在物理内存中的地址空间时，由操作系统负责将缺失的部分装入物理内存并重新执行失败的指令。</p>
<h3 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h3><p>大部分使用虚拟内存的系统中都会使用一种 <code>分页(paging)</code> 技术。在任何一台计算机上，程序会引用使用一组内存地址。当程序执行</p>
<pre><code class="assembly">MOV REG,1000
</code></pre>
<p>这条指令时，它会把内存地址为 1000 的内存单元的内容复制到 REG 中（或者相反，这取决于计算机）。地址可以通过索引、基址寄存器、段寄存器或其他方式产生。</p>
<p>这些程序生成的地址被称为 <code>虚拟地址(virtual addresses)</code> 并形成<code>虚拟地址空间(virtual address space)</code>，在没有虚拟内存的计算机上，系统直接将虚拟地址送到内存中线上，读写操作都使用同样地址的物理内存。<strong>在使用虚拟内存时，虚拟地址不会直接发送到内存总线上</strong>。相反，会使用 <code>MMU(Memory Management Unit)</code> 内存管理单元把<strong>虚拟地址映射为物理内存地址</strong>，像下图这样</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829902-6db577d7-0921-4635-82f1-62f7fe723b48.png#align=left&amp;display=inline&amp;height=326&amp;margin=%5Bobject%20Object%5D&amp;originHeight=326&amp;originWidth=710&amp;size=0&amp;status=done&amp;style=none&amp;width=710" alt></p>
<p>下面这幅图展示了这种映射是如何工作的</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829922-b5a208d9-6807-4201-b95a-50c300ec3f1e.png#align=left&amp;display=inline&amp;height=728&amp;margin=%5Bobject%20Object%5D&amp;originHeight=728&amp;originWidth=701&amp;size=0&amp;status=done&amp;style=none&amp;width=701" alt></p>
<p>页表给出虚拟地址与物理内存地址之间的映射关系。每一页起始于 4096 的倍数位置，结束于 4095 的位置，所以 4K 到 8K 实际为 4096 - 8191 ，8K - 12K 就是 8192 - 12287</p>
<p>在这个例子中，我们可能有一个 16 位地址的计算机，地址从 0 - 64 K - 1，这些是<code>虚拟地址</code>。然而只有 32 KB 的物理地址。所以虽然可以编写 64 KB 的程序，但是程序无法全部调入内存运行，在磁盘上必须有一个最多 64 KB 的程序核心映像的完整副本，以保证程序片段在需要时被调入内存。</p>
<h3 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h3><p>虚拟页号可作为页表的索引用来找到虚拟页中的内容。由页表项可以找到页框号（如果有的话）。然后把页框号拼接到偏移量的高位端，以替换掉虚拟页号，形成物理地址。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829940-3af1fa95-4f53-459f-88e6-dc9540fc58fa.png#align=left&amp;display=inline&amp;height=555&amp;margin=%5Bobject%20Object%5D&amp;originHeight=555&amp;originWidth=726&amp;size=0&amp;status=done&amp;style=none&amp;width=726" alt></p>
<p>因此，页表的目的是把虚拟页映射到页框中。从数学上说，页表是一个函数，它的参数是虚拟页号，结果是物理页框号。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829970-f9085cee-e3ce-49a6-a175-31095f33b104.png#align=left&amp;display=inline&amp;height=226&amp;margin=%5Bobject%20Object%5D&amp;originHeight=226&amp;originWidth=549&amp;size=0&amp;status=done&amp;style=none&amp;width=549" alt></p>
<p>通过这个函数可以把虚拟地址中的虚拟页转换为页框，从而形成物理地址。</p>
<h4 id="页表项的结构"><a href="#页表项的结构" class="headerlink" title="页表项的结构"></a>页表项的结构</h4><p>下面我们探讨一下页表项的具体结构，上面你知道了页表项的大致构成，是由页框号和在/不在位构成的，现在我们来具体探讨一下页表项的构成</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829994-5ecf9cda-4a6f-418e-b786-bf4a2a05e7c3.png#align=left&amp;display=inline&amp;height=297&amp;margin=%5Bobject%20Object%5D&amp;originHeight=297&amp;originWidth=701&amp;size=0&amp;status=done&amp;style=none&amp;width=701" alt></p>
<p>页表项的结构是与机器相关的，但是不同机器上的页表项大致相同。上面是一个页表项的构成，不同计算机的页表项可能不同，但是一般来说都是 32 位的。页表项中最重要的字段就是<code>页框号(Page frame number)</code>。毕竟，页表到页框最重要的一步操作就是要把此值映射过去。下一个比较重要的就是<code>在/不在</code>位，如果此位上的值是 1，那么页表项是有效的并且能够被<code>使用</code>。如果此值是 0 的话，则表示该页表项对应的虚拟页面<code>不在</code>内存中，访问该页面会引起一个<code>缺页异常(page fault)</code>。</p>
<p><code>保护位(Protection)</code> 告诉我们哪一种访问是允许的，啥意思呢？最简单的表示形式是这个域只有一位，<strong>0 表示可读可写，1 表示的是只读</strong>。</p>
<p><code>修改位(Modified)</code> 和 <code>访问位(Referenced)</code> 会跟踪页面的使用情况。当一个页面被写入时，硬件会自动的设置修改位。修改位在页面重新分配页框时很有用。如果一个页面已经被修改过（即它是 <code>脏</code> 的），则必须把它写回磁盘。如果一个页面没有被修改过（即它是 <code>干净</code>的），那么重新分配时这个页框会被直接丢弃，因为磁盘上的副本仍然是有效的。这个位有时也叫做 <code>脏位(dirty bit)</code>，因为它反映了页面的状态。</p>
<p><code>访问位(Referenced)</code> 在页面被访问时被设置，不管是读还是写。这个值能够帮助操作系统在发生缺页中断时选择要淘汰的页。不再使用的页要比正在使用的页更适合被淘汰。这个位在后面要讨论的<code>页面置换</code>算法中作用很大。</p>
<p>最后一位用于禁止该页面被高速缓存，这个功能对于映射到设备寄存器还是内存中起到了关键作用。通过这一位可以禁用高速缓存。具有独立的 I/O 空间而不是用内存映射 I/O 的机器来说，并不需要这一位。</p>
<h2 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h2><p>下面我们就来探讨一下有哪些页面置换算法。</p>
<h3 id="最优页面置换算法"><a href="#最优页面置换算法" class="headerlink" title="最优页面置换算法"></a>最优页面置换算法</h3><p>最优的页面置换算法的工作流程如下：在缺页中断发生时，这些页面之一将在下一条指令（包含该指令的页面）上被引用。其他页面则可能要到 10、100 或者 1000 条指令后才会被访问。每个页面都可以用在该页首次被访问前所要执行的指令数作为标记。</p>
<p>最优化的页面算法表明应该标记最大的页面。如果一个页面在 800 万条指令内不会被使用，另外一个页面在 600 万条指令内不会被使用，则置换前一个页面，从而把需要调入这个页面而发生的缺页中断推迟。计算机也像人类一样，会把不愿意做的事情尽可能的往后拖。</p>
<p>这个算法最大的问题时无法实现。当缺页中断发生时，操作系统无法知道各个页面的下一次将在什么时候被访问。这种算法在实际过程中根本不会使用。</p>
<h3 id="最近未使用页面置换算法"><a href="#最近未使用页面置换算法" class="headerlink" title="最近未使用页面置换算法"></a>最近未使用页面置换算法</h3><p>为了能够让操作系统收集页面使用信息，大部分使用虚拟地址的计算机都有两个状态位，R 和 M，来和每个页面进行关联。<strong>每当引用页面（读入或写入）时都设置 R，写入（即修改）页面时设置 M</strong>，这些位包含在每个页表项中，就像下面所示</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830000-886bdae7-531d-42ce-86c1-970d3c0fd287.png#align=left&amp;display=inline&amp;height=288&amp;margin=%5Bobject%20Object%5D&amp;originHeight=288&amp;originWidth=644&amp;size=0&amp;status=done&amp;style=none&amp;width=644" alt></p>
<p>因为每次访问时都会更新这些位，因此由<code>硬件</code>来设置它们非常重要。一旦某个位被设置为 1，就会一直保持 1 直到操作系统下次来修改此位。</p>
<p>如果硬件没有这些位，那么可以使用操作系统的<code>缺页中断</code>和<code>时钟中断</code>机制来进行模拟。当启动一个进程时，将其所有的页面都标记为<code>不在内存</code>；一旦访问任何一个页面就会引发一次缺页中断，此时操作系统就可以设置 <code>R 位(在它的内部表中)</code>，修改页表项使其指向正确的页面，并设置为 <code>READ ONLY</code> 模式，然后重新启动引起缺页中断的指令。如果页面随后被修改，就会发生另一个缺页异常。从而允许操作系统设置 M 位并把页面的模式设置为 <code>READ/WRITE</code>。</p>
<p>可以用 R 位和 M 位来构造一个简单的页面置换算法：当启动一个进程时，操作系统将其所有页面的两个位都设置为 0。R 位定期的被清零（在每个时钟中断）。用来将最近未引用的页面和已引用的页面分开。</p>
<p>当出现缺页中断后，操作系统会检查所有的页面，并根据它们的 R 位和 M 位将当前值分为四类：</p>
<ul>
<li>第 0 类：没有引用 R，没有修改 M</li>
<li>第 1 类：没有引用 R，已修改 M</li>
<li>第 2 类：引用 R ，没有修改 M</li>
<li>第 3 类：已被访问 R，已被修改 M</li>
</ul>
<p>尽管看起来好像无法实现第一类页面，但是当第三类页面的 R 位被时钟中断清除时，它们就会发生。时钟中断不会清除 M 位，因为需要这个信息才能知道是否写回磁盘中。清除 R 但不清除 M 会导致出现一类页面。</p>
<p><code>NRU(Not Recently Used)</code> 算法从编号最小的非空类中随机删除一个页面。此算法隐含的思想是，在一个时钟内（约 20 ms）淘汰一个已修改但是没有被访问的页面要比一个大量引用的未修改页面好，NRU 的主要优点是<strong>易于理解并且能够有效的实现</strong>。</p>
<h3 id="先进先出页面置换算法"><a href="#先进先出页面置换算法" class="headerlink" title="先进先出页面置换算法"></a>先进先出页面置换算法</h3><p>另一种开销较小的方式是使用 <code>FIFO(First-In,First-Out)</code> 算法，这种类型的数据结构也适用在页面置换算法中。由操作系统维护一个所有在当前内存中的页面的链表，最早进入的放在表头，最新进入的页面放在表尾。在发生缺页异常时，会把头部的页移除并且把新的页添加到表尾。</p>
<h3 id="第二次机会页面置换算法"><a href="#第二次机会页面置换算法" class="headerlink" title="第二次机会页面置换算法"></a>第二次机会页面置换算法</h3><p>我们上面学到的 FIFO 链表页面有个<code>缺陷</code>，那就是出链和入链并不会进行 check <code>检查</code>，这样就会容易把经常使用的页面置换出去，为了避免这一问题，我们对该算法做一个简单的修改：我们检查最老页面的 <code>R 位</code>，如果是 0 ，那么这个页面就是最老的而且没有被使用，那么这个页面就会被立刻换出。如果 R 位是 1，那么就清除此位，此页面会被放在链表的尾部，修改它的装入时间就像刚放进来的一样。然后继续搜索。</p>
<p>这种算法叫做 <code>第二次机会(second chance)</code>算法，就像下面这样，我们看到页面 A 到 H 保留在链表中，并按到达内存的时间排序。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830001-d17523cc-7d04-4aa5-9b91-7cb47cc26508.png#align=left&amp;display=inline&amp;height=372&amp;margin=%5Bobject%20Object%5D&amp;originHeight=372&amp;originWidth=731&amp;size=0&amp;status=done&amp;style=none&amp;width=731" alt></p>
<p>a）按照先进先出的方法排列的页面；b）在时刻 20 处发生缺页异常中断并且 A 的 R 位已经设置时的页面链表。</p>
<p>假设缺页异常发生在时刻 20 处，这时最老的页面是 A ，它是在 0 时刻到达的。如果 A 的 R 位是 0，那么它将被淘汰出内存，或者把它写回磁盘（如果它已经被修改过），或者只是简单的放弃（如果它是未被修改过）。另一方面，如果它的 R 位已经设置了，则将 A 放到链表的尾部并且重新设置<code>装入时间</code>为当前时刻（20 处），然后清除 R 位。然后从 B 页面开始继续搜索合适的页面。</p>
<p>寻找第二次机会的是在最近的时钟间隔中未被访问过的页面。如果所有的页面都被访问过，该算法就会被简化为单纯的 <code>FIFO 算法</code>。具体来说，假设图 a 中所有页面都设置了 R 位。操作系统将页面依次移到链表末尾，每次都在添加到末尾时清除 R 位。最后，算法又会回到页面 A，此时的 R 位已经被清除，那么页面 A 就会被执行出链处理，因此算法能够正常结束。</p>
<h3 id="时钟页面置换算法"><a href="#时钟页面置换算法" class="headerlink" title="时钟页面置换算法"></a>时钟页面置换算法</h3><p>一种比较好的方式是把所有的页面都保存在一个类似钟面的环形链表中，一个表针指向最老的页面。如下图所示</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830029-543aeeff-242c-4b6f-a9a4-87fa9b101280.png#align=left&amp;display=inline&amp;height=532&amp;margin=%5Bobject%20Object%5D&amp;originHeight=532&amp;originWidth=669&amp;size=0&amp;status=done&amp;style=none&amp;width=669" alt></p>
<p>当缺页错误出现时，算法首先检查表针指向的页面，如果它的 R 位是 0 就淘汰该页面，并把新的页面插入到这个位置，然后把表针向前移动一位；如果 R 位是 1 就清除 R 位并把表针前移一个位置。重复这个过程直到找到了一个 R 位为 0 的页面位置。了解这个算法的工作方式，就明白为什么它被称为 <code>时钟(clokc)</code>算法了。</p>
<h3 id="最近最少使用页面置换算法"><a href="#最近最少使用页面置换算法" class="headerlink" title="最近最少使用页面置换算法"></a>最近最少使用页面置换算法</h3><p>在前面几条指令中频繁使用的页面和可能在后面的几条指令中被使用。反过来说，已经很久没有使用的页面有可能在未来一段时间内仍不会被使用。这个思想揭示了一个可以实现的算法：在缺页中断时，置换未使用时间最长的页面。这个策略称为 <code>LRU(Least Recently Used)</code> ，最近最少使用页面置换算法。</p>
<p>虽然 LRU 在理论上是可以实现的，但是从长远看来代价比较高。为了完全实现 LRU，会在内存中维护一个所有页面的链表，最频繁使用的页位于表头，最近最少使用的页位于表尾。困难的是在每次内存引用时更新整个链表。在链表中找到一个页面，删除它，然后把它移动到表头是一个非常耗时的操作，即使使用<code>硬件</code>来实现也是一样的费时。</p>
<h3 id="用软件模拟-LRU"><a href="#用软件模拟-LRU" class="headerlink" title="用软件模拟 LRU"></a>用软件模拟 LRU</h3><p>尽管上面的 LRU 算法在原则上是可以实现的，<strong>但是很少有机器能够拥有那些特殊的硬件</strong>。上面是硬件的实现方式，那么现在考虑要用<code>软件</code>来实现 LRU 。一种可以实现的方案是 <code>NFU(Not Frequently Used，最不常用)</code>算法。它需要一个软件计数器来和每个页面关联，初始化的时候是 0 。在每个时钟中断时，操作系统会浏览内存中的所有页，会将每个页面的 R 位（0 或 1）加到它的计数器上。这个计数器大体上跟踪了各个页面访问的频繁程度。当缺页异常出现时，则置换计数器值最小的页面。</p>
<p>只需要对 NFU 做一个简单的修改就可以让它模拟 LRU，这个修改有两个步骤</p>
<ul>
<li>首先，在 R 位被添加进来之前先把计数器右移一位；</li>
<li>第二步，R 位被添加到最左边的位而不是最右边的位。</li>
</ul>
<p>修改以后的算法称为 <code>老化(aging)</code> 算法，下图解释了老化算法是如何工作的。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830078-9cab6ac9-f2fa-4395-b8d5-57b61a80e6d3.png#align=left&amp;display=inline&amp;height=415&amp;margin=%5Bobject%20Object%5D&amp;originHeight=415&amp;originWidth=747&amp;size=0&amp;status=done&amp;style=none&amp;width=747" alt></p>
<p>我们假设在第一个时钟周期内页面 0 - 5 的 R 位依次是 1，0，1，0，1，1，（也就是页面 0 是 1，页面 1 是 0，页面 2 是 1 这样类推）。也就是说，<strong>在 0 个时钟周期到 1 个时钟周期之间，0，2，4，5 都被引用了</strong>，从而把它们的 R 位设置为 1，剩下的设置为 0 。在相关的六个计数器被右移之后 R 位被添加到 <code>左侧</code> ，就像上图中的 a。剩下的四列显示了接下来的四个时钟周期内的六个计数器变化。</p>
<blockquote>
<p>CPU 正在以某个频率前进，该频率的周期称为<code>时钟滴答</code>或<code>时钟周期</code>。一个 100Mhz 的处理器每秒将接收 100,000,000 个时钟滴答。</p>
</blockquote>
<p>当缺页异常出现时，将<code>置换（就是移除）</code>计数器值最小的页面。如果一个页面在前面 4 个时钟周期内都没有被访问过，那么它的计数器应该会有四个连续的 0 ，因此它的值肯定要比前面 3 个时钟周期内都没有被访问过的页面的计数器小。</p>
<p>这个算法与 LRU 算法有两个重要的区别：看一下上图中的 <code>e</code>，第三列和第五列</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830053-3463258f-69af-41f6-94ed-94a15761844e.png#align=left&amp;display=inline&amp;height=429&amp;margin=%5Bobject%20Object%5D&amp;originHeight=429&amp;originWidth=763&amp;size=0&amp;status=done&amp;style=none&amp;width=763" alt></p>
<h3 id="工作集时钟页面置换算法"><a href="#工作集时钟页面置换算法" class="headerlink" title="工作集时钟页面置换算法"></a>工作集时钟页面置换算法</h3><p>当缺页异常发生后，需要扫描整个页表才能确定被淘汰的页面，因此基本工作集算法还是比较浪费时间的。一个对基本工作集算法的提升是基于时钟算法但是却使用工作集的信息，这种算法称为<code>WSClock(工作集时钟)</code>。由于它的实现简单并且具有高性能，因此在实践中被广泛应用。</p>
<p>与时钟算法一样，所需的数据结构是一个以页框为元素的循环列表，就像下面这样</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830081-e96444ca-dda9-4c3f-9af5-e0db74d03a6f.png#align=left&amp;display=inline&amp;height=588&amp;margin=%5Bobject%20Object%5D&amp;originHeight=588&amp;originWidth=705&amp;size=0&amp;status=done&amp;style=none&amp;width=705" alt></p>
<p>工作集时钟页面置换算法的操作：a) 和 b) 给出 R = 1 时所发生的情形；c) 和 d) 给出 R = 0 的例子</p>
<p>最初的时候，该表是空的。当装入第一个页面后，把它加载到该表中。随着更多的页面的加入，它们形成一个环形结构。每个表项包含来自基本工作集算法的上次使用时间，以及 R 位（已标明）和 M 位（未标明）。</p>
<p>与时钟算法一样，在每个缺页异常时，首先检查指针指向的页面。如果 R 位被是设置为 1，该页面在当前时钟周期内就被使用过，那么该页面就不适合被淘汰。然后把该页面的 R 位置为 0，指针指向下一个页面，并重复该算法。该事件序列化后的状态参见图 b。</p>
<p>现在考虑指针指向的页面 R = 0 时会发生什么，参见图 c，如果页面的使用期限大于 t 并且页面为被访问过，那么这个页面就不会在工作集中，并且在磁盘上会有一个此页面的副本。申请重新调入一个新的页面，并把新的页面放在其中，如图 d 所示。另一方面，如果页面被修改过，就不能重新申请页面，因为这个页面在磁盘上没有有效的副本。为了避免由于调度写磁盘操作引起的进程切换，指针继续向前走，算法继续对下一个页面进行操作。毕竟，有可能存在一个老的，没有被修改过的页面可以立即使用。</p>
<p>原则上来说，所有的页面都有可能因为<code>磁盘I/O</code> 在某个时钟周期内被调度。为了降低磁盘阻塞，需要设置一个限制，即最大只允许写回 n 个页面。一旦达到该限制，就不允许调度新的写操作。</p>
<p>那么就有个问题，指针会绕一圈回到原点的，如果回到原点，它的起始点会发生什么？这里有两种情况：</p>
<ul>
<li>至少调度了一次写操作</li>
<li>没有调度过写操作</li>
</ul>
<p>在第一种情况中，指针仅仅是不停的移动，寻找一个未被修改过的页面。由于已经调度了一个或者多个写操作，最终会有某个写操作完成，它的页面会被标记为未修改。置换遇到的第一个未被修改过的页面，这个页面不一定是第一个被调度写操作的页面，因为硬盘驱动程序为了优化性能可能会把写操作重排序。</p>
<p>对于第二种情况，所有的页面都在工作集中，否则将至少调度了一个写操作。由于缺乏额外的信息，最简单的方法就是置换一个未被修改的页面来使用，扫描中需要记录未被修改的页面的位置，如果不存在未被修改的页面，就选定当前页面并把它写回磁盘。</p>
<h3 id="页面置换算法小结"><a href="#页面置换算法小结" class="headerlink" title="页面置换算法小结"></a>页面置换算法小结</h3><p>我们到现在已经研究了各种页面置换算法，现在我们来一个简单的总结，算法的总结归纳如下</p>
<table>
<thead>
<tr>
<th>算法</th>
<th>注释</th>
</tr>
</thead>
<tbody>
<tr>
<td>最优算法</td>
<td>不可实现，但可以用作基准</td>
</tr>
<tr>
<td>NRU(最近未使用) 算法</td>
<td>和 LRU 算法很相似</td>
</tr>
<tr>
<td>FIFO(先进先出) 算法</td>
<td>有可能会抛弃重要的页面</td>
</tr>
<tr>
<td>第二次机会算法</td>
<td>比 FIFO 有较大的改善</td>
</tr>
<tr>
<td>时钟算法</td>
<td>实际使用</td>
</tr>
<tr>
<td>LRU(最近最少)算法</td>
<td>比较优秀，但是很难实现</td>
</tr>
<tr>
<td>NFU(最不经常食用)算法</td>
<td>和 LRU 很类似</td>
</tr>
<tr>
<td>老化算法</td>
<td>近似 LRU 的高效算法</td>
</tr>
<tr>
<td>工作集算法</td>
<td>实施起来开销很大</td>
</tr>
<tr>
<td>工作集时钟算法</td>
<td>比较有效的算法</td>
</tr>
</tbody>
</table>
<ul>
<li><code>最优算法</code>在当前页面中置换最后要访问的页面。不幸的是，没有办法来判定哪个页面是最后一个要访问的，<code>因此实际上该算法不能使用</code>。然而，它可以作为衡量其他算法的标准。</li>
<li><code>NRU</code> 算法根据 R 位和 M 位的状态将页面氛围四类。从编号最小的类别中随机选择一个页面。NRU 算法易于实现，但是性能不是很好。存在更好的算法。</li>
<li><code>FIFO</code> 会跟踪页面加载进入内存中的顺序，并把页面放入一个链表中。有可能删除存在时间最长但是还在使用的页面，因此这个算法也不是一个很好的选择。</li>
<li><code>第二次机会</code>算法是对 FIFO 的一个修改，它会在删除页面之前检查这个页面是否仍在使用。如果页面正在使用，就会进行保留。这个改进大大提高了性能。</li>
<li><code>时钟</code> 算法是第二次机会算法的另外一种实现形式，时钟算法和第二次算法的性能差不多，但是会花费更少的时间来执行算法。</li>
<li><code>LRU</code> 算法是一个非常优秀的算法，但是没有<code>特殊的硬件(TLB)</code>很难实现。如果没有硬件，就不能使用 LRU 算法。</li>
<li><code>NFU</code> 算法是一种近似于 LRU 的算法，它的性能不是非常好。</li>
<li><code>老化</code> 算法是一种更接近 LRU 算法的实现，并且可以更好的实现，因此是一个很好的选择</li>
<li>最后两种算法都使用了工作集算法。工作集算法提供了合理的性能开销，但是它的实现比较复杂。<code>WSClock</code> 是另外一种变体，它不仅能够提供良好的性能，而且可以高效地实现。</li>
</ul>
<p>总之，<strong>最好的算法是老化算法和 WSClock 算法</strong>。他们分别是基于 LRU 和工作集算法。他们都具有良好的性能并且能够被有效的实现。还存在其他一些好的算法，但实际上这两个可能是最重要的。</p>
<p>下面来聊一聊文件系统，你需要知道下面这些知识点</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830114-09f30aaf-25b8-44c3-992a-577e4c3a833c.png#align=left&amp;display=inline&amp;height=657&amp;margin=%5Bobject%20Object%5D&amp;originHeight=657&amp;originWidth=721&amp;size=0&amp;status=done&amp;style=none&amp;width=721" alt></p>
<h2 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h2><h3 id="文件命名"><a href="#文件命名" class="headerlink" title="文件命名"></a>文件命名</h3><p>文件是一种抽象机制，它提供了一种方式用来存储信息以及在后面进行读取。可能任何一种机制最重要的特性就是管理对象的命名方式。在创建一个文件后，它会给文件一个命名。当进程终止时，文件会继续存在，并且其他进程可以使用<code>名称访问该文件</code>。</p>
<p>文件命名规则对于不同的操作系统来说是不一样的，但是所有现代操作系统都允许使用 1 - 8 个字母的字符串作为合法文件名。</p>
<p>某些文件区分大小写字母，而大多数则不区分。<code>UNIX</code> 属于第一类；历史悠久的 <code>MS-DOS</code> 属于第二类（顺便说一句，尽管 MS-DOS 历史悠久，但 MS-DOS 仍在嵌入式系统中非常广泛地使用，因此它绝不是过时的）；因此，UNIX 系统会有三种不同的命名文件：<code>maria</code>、<code>Maria</code>、<code>MARIA</code> 。在 MS-DOS ，所有这些命名都属于相同的文件。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830120-5ba4f13c-ee71-46f2-a110-e2eaf1dbf324.png#align=left&amp;display=inline&amp;height=302&amp;margin=%5Bobject%20Object%5D&amp;originHeight=302&amp;originWidth=691&amp;size=0&amp;status=done&amp;style=none&amp;width=691" alt></p>
<p>许多操作系统支持两部分的文件名，它们之间用 <code>.</code> 分隔开，比如文件名 <code>prog.c</code>。原点后面的文件称为 <code>文件扩展名(file extension)</code> ，文件扩展名通常表示文件的一些信息。一些常用的文件扩展名以及含义如下图所示</p>
<table>
<thead>
<tr>
<th>扩展名</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>bak</td>
<td>备份文件</td>
</tr>
<tr>
<td>c</td>
<td>c 源程序文件</td>
</tr>
<tr>
<td>gif</td>
<td>符合图形交换格式的图像文件</td>
</tr>
<tr>
<td>hlp</td>
<td>帮助文件</td>
</tr>
<tr>
<td>html</td>
<td>WWW 超文本标记语言文档</td>
</tr>
<tr>
<td>jpg</td>
<td>符合 JPEG 编码标准的静态图片</td>
</tr>
<tr>
<td>mp3</td>
<td>符合 MP3 音频编码格式的音乐文件</td>
</tr>
<tr>
<td>mpg</td>
<td>符合 MPEG 编码标准的电影</td>
</tr>
<tr>
<td>o</td>
<td>目标文件（编译器输出格式，尚未链接）</td>
</tr>
<tr>
<td>pdf</td>
<td>pdf 格式的文件</td>
</tr>
<tr>
<td>ps</td>
<td>PostScript 文件</td>
</tr>
<tr>
<td>tex</td>
<td>为 TEX 格式化程序准备的输入文件</td>
</tr>
<tr>
<td>txt</td>
<td>文本文件</td>
</tr>
<tr>
<td>zip</td>
<td>压缩文件</td>
</tr>
</tbody>
</table>
<p>在 UNIX 系统中，文件扩展名只是一种约定，操作系统并不强制采用。</p>
<h3 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h3><p>文件的构造有多种方式。下图列出了常用的三种构造方式</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830179-1cd3ea7b-cf21-432f-a8e4-c2d8f317e0ff.png#align=left&amp;display=inline&amp;height=426&amp;margin=%5Bobject%20Object%5D&amp;originHeight=426&amp;originWidth=728&amp;size=0&amp;status=done&amp;style=none&amp;width=728" alt></p>
<p>三种不同的文件。 a) 字节序列 。b) 记录序列。c) 树</p>
<p>上图中的 a 是一种无结构的字节序列，操作系统不关心序列的内容是什么，操作系统能看到的就是<code>字节(bytes)</code>。其文件内容的任何含义只在用户程序中进行解释。UNIX 和 Windows 都采用这种办法。</p>
<p>图 b 表示在文件结构上的第一部改进。在这个模型中，文件是具有固定长度记录的序列，每个记录都有其内部结构。 把文件作为记录序列的核心思想是：<strong>读操作返回一个记录，而写操作重写或者追加一个记录</strong>。第三种文件结构如上图 c 所示。在这种组织结构中，文件由一颗<code>记录树</code>构成，记录树的长度不一定相同，每个记录树都在记录中的固定位置包含一个<code>key</code> 字段。这棵树按 key 进行排序，从而可以对特定的 key 进行快速查找。</p>
<h3 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h3><p>很多操作系统支持多种文件类型。例如，UNIX（同样包括 OS X）和 Windows 都具有常规的文件和目录。除此之外，UNIX 还具有<code>字符特殊文件(character special file)</code> 和 <code>块特殊文件(block special file)</code>。<code>常规文件(Regular files)</code> 是包含有用户信息的文件。用户一般使用的文件大都是常规文件，常规文件一般包括 <strong>可执行文件、文本文件、图像文件</strong>，从常规文件读取数据或将数据写入时，内核会根据文件系统的规则执行操作，是写入可能被延迟，记录日志或者接受其他操作。</p>
<h3 id="文件访问"><a href="#文件访问" class="headerlink" title="文件访问"></a>文件访问</h3><p>早期的操作系统只有一种访问方式：<code>序列访问(sequential access)</code>。在这些系统中，进程可以按照顺序读取所有的字节或文件中的记录，但是不能跳过并乱序执行它们。顺序访问文件是可以返回到起点的，需要时可以多次读取该文件。当存储介质是磁带而不是磁盘时，顺序访问文件很方便。</p>
<p>在使用磁盘来存储文件时，可以不按照顺序读取文件中的字节或者记录，或者按照关键字而不是位置来访问记录。这种能够以任意次序进行读取的称为<code>随机访问文件(random access file)</code>。许多应用程序都需要这种方式。</p>
<p>随机访问文件对许多应用程序来说都必不可少，例如，数据库系统。如果乘客打电话预定某航班机票，订票程序必须能够直接访问航班记录，而不必先读取其他航班的成千上万条记录。</p>
<p>有两种方法可以指示从何处开始读取文件。第一种方法是直接使用 <code>read</code> 从头开始读取。另一种是用一个特殊的 <code>seek</code> 操作设置当前位置，在 seek 操作后，从这个当前位置顺序地开始读文件。UNIX 和 Windows 使用的是后面一种方式。</p>
<h3 id="文件属性"><a href="#文件属性" class="headerlink" title="文件属性"></a>文件属性</h3><p>文件包括文件名和数据。除此之外，所有的操作系统还会保存其他与文件相关的信息，如文件创建的日期和时间、文件大小。我们可以称这些为文件的<code>属性(attributes)</code>。有些人也喜欢把它们称作 <code>元数据(metadata)</code>。文件的属性在不同的系统中差别很大。文件的属性只有两种状态：<code>设置(set)</code> 和 <code>清除(clear)</code>。</p>
<h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h3><p>使用文件的目的是用来存储信息并方便以后的检索。对于存储和检索，不同的系统提供了不同的操作。以下是与文件有关的最常用的一些系统调用：</p>
<ol>
<li><code>Create</code>，创建不包含任何数据的文件。调用的目的是表示文件即将建立，并对文件设置一些属性。</li>
<li><code>Delete</code>，当文件不再需要，必须删除它以释放内存空间。为此总会有一个系统调用来删除文件。</li>
<li><code>Open</code>，在使用文件之前，必须先打开文件。这个调用的目的是允许系统将属性和磁盘地址列表保存到主存中，用来以后的快速访问。</li>
<li><code>Close</code>，当所有进程完成时，属性和磁盘地址不再需要，因此应关闭文件以释放表空间。很多系统限制进程打开文件的个数，以此达到鼓励用户关闭不再使用的文件。磁盘以块为单位写入，关闭文件时会强制写入最后一<code>块</code>，即使这个块空间内部还不满。</li>
<li><code>Read</code>，数据从文件中读取。通常情况下，读取的数据来自文件的当前位置。调用者必须指定需要读取多少数据，并且提供存放这些数据的缓冲区。</li>
<li><code>Write</code>，向文件写数据，写操作一般也是从文件的当前位置开始进行。如果当前位置是文件的末尾，则会直接追加进行写入。如果当前位置在文件中，则现有数据被覆盖，并且永远消失。</li>
<li><code>append</code>，使用 append 只能向文件末尾添加数据。</li>
<li><code>seek</code>，对于随机访问的文件，要指定从何处开始获取数据。通常的方法是用 seek 系统调用把当前位置指针指向文件中的特定位置。seek 调用结束后，就可以从指定位置开始读写数据了。</li>
<li><code>get attributes</code>，进程运行时通常需要读取文件属性。</li>
<li><code>set attributes</code>，用户可以自己设置一些文件属性，甚至是在文件创建之后，实现该功能的是 set attributes 系统调用。</li>
<li><code>rename</code>，用户可以自己更改已有文件的名字，rename 系统调用用于这一目的。</li>
</ol>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><p>文件系统通常提供<code>目录(directories)</code> 或者 <code>文件夹(folders)</code> 用于记录文件的位置，在很多系统中目录本身也是文件，下面我们会讨论关于文件，他们的组织形式、属性和可以对文件进行的操作。</p>
<h3 id="一级目录系统"><a href="#一级目录系统" class="headerlink" title="一级目录系统"></a>一级目录系统</h3><p>目录系统最简单的形式是有一个能够包含所有文件的目录。这种目录被称为<code>根目录(root directory)</code>，由于根目录的唯一性，所以其名称并不重要。在最早期的个人计算机中，这种系统很常见，部分原因是因为只有一个用户。下面是一个单层目录系统的例子</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830155-ca95d416-207a-46d6-89dd-77c398a175d3.png#align=left&amp;display=inline&amp;height=306&amp;margin=%5Bobject%20Object%5D&amp;originHeight=306&amp;originWidth=500&amp;size=0&amp;status=done&amp;style=none&amp;width=500" alt></p>
<p>含有四个文件的单层目录系统</p>
<p>该目录中有四个文件。这种设计的优点在于简单，并且能够快速定位文件，毕竟只有一个地方可以检索。这种目录组织形式现在一般用于简单的嵌入式设备（如数码相机和某些便携式音乐播放器）上使用。</p>
<h3 id="层次目录系统"><a href="#层次目录系统" class="headerlink" title="层次目录系统"></a>层次目录系统</h3><p>对于简单的应用而言，一般都用单层目录方式，但是这种组织形式并不适合于现代计算机，因为现代计算机含有成千上万个文件和文件夹。如果都放在根目录下，查找起来会非常困难。为了解决这一问题，出现了<code>层次目录系统(Hierarchical Directory Systems)</code>，也称为<code>目录树</code>。通过这种方式，可以用很多目录把文件进行分组。进而，如果多个用户共享同一个文件服务器，比如公司的网络系统，每个用户可以为自己的目录树拥有自己的私人根目录。这种方式的组织结构如下</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830190-cdcd48b8-b7ca-4597-b41d-d61089e0250d.png#align=left&amp;display=inline&amp;height=447&amp;margin=%5Bobject%20Object%5D&amp;originHeight=447&amp;originWidth=699&amp;size=0&amp;status=done&amp;style=none&amp;width=699" alt></p>
<p>根目录含有目录 A、B 和 C ，分别属于不同的用户，其中两个用户个字创建了<code>子目录</code>。用户可以创建任意数量的子目录，现代文件系统都是按照这种方式组织的。</p>
<h3 id="路径名"><a href="#路径名" class="headerlink" title="路径名"></a>路径名</h3><p>当目录树组织文件系统时，需要有某种方法指明文件名。常用的方法有两种，第一种方式是每个文件都会用一个<code>绝对路径名(absolute path name)</code>，它由根目录到文件的路径组成。</p>
<p>另外一种指定文件名的方法是 <code>相对路径名(relative path name)</code>。它常常和 <code>工作目录(working directory)</code> （也称作 <code>当前目录(current directory)</code>）一起使用。用户可以指定一个目录作为当前工作目录。例如，如果当前目录是 <code>/usr/ast</code>，那么绝对路径 <code>/usr/ast/mailbox</code>可以直接使用 <code>mailbox</code> 来引用。</p>
<h3 id="目录操作"><a href="#目录操作" class="headerlink" title="目录操作"></a>目录操作</h3><p>不同文件中管理目录的系统调用的差别比管理文件的系统调用差别大。为了了解这些系统调用有哪些以及它们怎样工作，下面给出一个例子（取自 UNIX）。</p>
<ol>
<li><code>Create</code>，创建目录，除了目录项 <code>.</code> 和 <code>..</code> 外，目录内容为空。</li>
<li><code>Delete</code>，删除目录，只有空目录可以删除。只包含 <code>.</code> 和 <code>..</code> 的目录被认为是空目录，这两个目录项通常不能删除</li>
<li><code>opendir</code>，目录内容可被读取。例如，未列出目录中的全部文件，程序必须先打开该目录，然后读其中全部文件的文件名。与打开和读文件相同，在读目录前，必须先打开文件。</li>
<li><code>closedir</code>，读目录结束后，应该关闭目录用于释放内部表空间。</li>
<li><code>readdir</code>，系统调用 readdir 返回打开目录的下一个目录项。以前也采用 read 系统调用来读取目录，但是这种方法有一个缺点：程序员必须了解和处理目录的内部结构。相反，不论采用哪一种目录结构，readdir 总是以标准格式返回一个目录项。</li>
<li><code>rename</code>，在很多方面目录和文件都相似。文件可以更换名称，目录也可以。</li>
<li><code>link</code>，链接技术允许在多个目录中出现同一个文件。这个系统调用指定一个存在的文件和一个路径名，并建立从该文件到路径所指名字的链接。这样，可以在多个目录中出现同一个文件。有时也被称为<code>硬链接(hard link)</code>。</li>
<li><code>unlink</code>，删除目录项。如果被解除链接的文件只出现在一个目录中，则将它从文件中删除。如果它出现在多个目录中，则只删除指定路径名的链接，依然保留其他路径名的链接。在 UNIX 中，用于删除文件的系统调用就是 unlink。</li>
</ol>
<h2 id="文件系统的实现"><a href="#文件系统的实现" class="headerlink" title="文件系统的实现"></a>文件系统的实现</h2><h3 id="文件系统布局"><a href="#文件系统布局" class="headerlink" title="文件系统布局"></a>文件系统布局</h3><p>文件系统存储在<code>磁盘</code>中。大部分的磁盘能够划分出一到多个分区，叫做<code>磁盘分区(disk partitioning)</code> 或者是<code>磁盘分片(disk slicing)</code>。每个分区都有独立的文件系统，每块分区的文件系统可以不同。磁盘的 0 号分区称为 <code>主引导记录(Master Boot Record, MBR)</code>，用来<code>引导(boot)</code> 计算机。在 MBR 的结尾是<code>分区表(partition table)</code>。每个分区表给出每个分区由开始到结束的地址。</p>
<p>当计算机开始引 boot 时，BIOS 读入并执行 MBR。</p>
<h4 id="引导块"><a href="#引导块" class="headerlink" title="引导块"></a>引导块</h4><p>MBR 做的第一件事就是<code>确定活动分区</code>，读入它的第一个块，称为<code>引导块(boot block)</code> 并执行。引导块中的程序将加载分区中的操作系统。为了一致性，每个分区都会从引导块开始，即使引导块不包含操作系统。引导块占据文件系统的前 4096 个字节，从磁盘上的字节偏移量 0 开始。引导块可用于启动操作系统。</p>
<p>除了从引导块开始之外，磁盘分区的布局是随着文件系统的不同而变化的。通常文件系统会包含一些属性，如下</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830178-416c1399-355d-4e11-aaad-360c3071d651.png#align=left&amp;display=inline&amp;height=419&amp;margin=%5Bobject%20Object%5D&amp;originHeight=419&amp;originWidth=725&amp;size=0&amp;status=done&amp;style=none&amp;width=725" alt></p>
<p>文件系统布局</p>
<h4 id="超级块"><a href="#超级块" class="headerlink" title="超级块"></a>超级块</h4><p>紧跟在引导块后面的是 <code>超级块(Superblock)</code>，超级块 的大小为 4096 字节，从磁盘上的字节偏移 4096 开始。超级块包含文件系统的所有关键参数</p>
<ul>
<li>文件系统的大小</li>
<li>文件系统中的数据块数</li>
<li>指示文件系统状态的标志</li>
<li>分配组大小</li>
</ul>
<p>在计算机启动或者文件系统首次使用时，超级块会被读入内存。</p>
<h4 id="空闲空间块"><a href="#空闲空间块" class="headerlink" title="空闲空间块"></a>空闲空间块</h4><p>接着是文件系统中<code>空闲块</code>的信息，例如，可以用位图或者指针列表的形式给出。</p>
<p><strong>BitMap 位图或者 Bit vector 位向量</strong></p>
<p>位图或位向量是一系列位或位的集合，其中每个位对应一个磁盘块，该位可以采用两个值：0 和 1，0 表示已分配该块，而 1 表示一个空闲块。下图中的磁盘上给定的磁盘块实例（分配了绿色块）可以用 16 位的位图表示为：0000111000000110。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830202-8aab8dd3-4293-45ca-ab73-fdf893584edc.png#align=left&amp;display=inline&amp;height=428&amp;margin=%5Bobject%20Object%5D&amp;originHeight=428&amp;originWidth=395&amp;size=0&amp;status=done&amp;style=none&amp;width=395" alt></p>
<p><strong>使用链表进行管理</strong></p>
<p>在这种方法中，空闲磁盘块链接在一起，即一个空闲块包含指向下一个空闲块的指针。第一个磁盘块的块号存储在磁盘上的单独位置，也缓存在内存中。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830218-bc0ef6e9-c0df-4495-9a7f-4bd5161d4bef.png#align=left&amp;display=inline&amp;height=422&amp;margin=%5Bobject%20Object%5D&amp;originHeight=422&amp;originWidth=432&amp;size=0&amp;status=done&amp;style=none&amp;width=432" alt></p>
<h4 id="碎片"><a href="#碎片" class="headerlink" title="碎片"></a>碎片</h4><p>这里不得不提一个叫做<code>碎片(fragment)</code>的概念，也称为片段。一般零散的单个数据通常称为片段。 磁盘块可以进一步分为固定大小的分配单元，片段只是在驱动器上彼此不相邻的文件片段。</p>
<h4 id="inode"><a href="#inode" class="headerlink" title="inode"></a>inode</h4><p>然后在后面是一个 <code>inode(index node)</code>，也称作索引节点。它是一个数组的结构，每个文件有一个 inode，inode 非常重要，它说明了文件的方方面面。每个索引节点都存储对象数据的属性和磁盘块位置</p>
<p>有一种简单的方法可以找到它们 <code>ls -lai</code> 命令。让我们看一下根文件系统：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830231-757b0e6a-7a82-4ec8-9a1c-15b9999e0185.png#align=left&amp;display=inline&amp;height=228&amp;margin=%5Bobject%20Object%5D&amp;originHeight=228&amp;originWidth=725&amp;size=0&amp;status=done&amp;style=none&amp;width=725" alt></p>
<p>inode 节点主要包括了以下信息</p>
<ul>
<li>模式/权限（保护）</li>
<li>所有者 ID</li>
<li>组 ID</li>
<li>文件大小</li>
<li>文件的硬链接数</li>
<li>上次访问时间</li>
<li>最后修改时间</li>
<li>inode 上次修改时间</li>
</ul>
<p>文件分为两部分，索引节点和块。一旦创建后，每种类型的块数是固定的。你不能增加分区上 inode 的数量，也不能增加磁盘块的数量。</p>
<p>紧跟在 inode 后面的是根目录，它存放的是文件系统目录树的根部。最后，磁盘的其他部分存放了其他所有的目录和文件。</p>
<h3 id="文件的实现"><a href="#文件的实现" class="headerlink" title="文件的实现"></a>文件的实现</h3><p>最重要的问题是记录各个文件分别用到了哪些磁盘块。不同的系统采用了不同的方法。下面我们会探讨一下这些方式。分配背后的主要思想是<code>有效利用文件空间</code>和<code>快速访问文件</code> ，主要有三种分配方案</p>
<ul>
<li>连续分配</li>
<li>链表分配</li>
<li>索引分配</li>
</ul>
<h4 id="连续分配"><a href="#连续分配" class="headerlink" title="连续分配"></a>连续分配</h4><p>最简单的分配方案是把每个文件作为一连串连续数据块存储在磁盘上。因此，在具有 1KB 块的磁盘上，将为 50 KB 文件分配 50 个连续块。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830290-96589d90-fa12-43fb-a38a-8ece59db8fcd.png#align=left&amp;display=inline&amp;height=267&amp;margin=%5Bobject%20Object%5D&amp;originHeight=267&amp;originWidth=708&amp;size=0&amp;status=done&amp;style=none&amp;width=708" alt></p>
<p>使用连续空间存储文件</p>
<p>上面展示了 40 个连续的内存块。从最左侧的 0 块开始。初始状态下，还没有装载文件，因此磁盘是空的。接着，从磁盘开始处（块 0 ）处开始写入占用 4 块长度的内存 A 。然后是一个占用 6 块长度的内存 B，会直接在 A 的末尾开始写。</p>
<p>注意每个文件都会在新的文件块开始写，所以如果文件 A 只占用了 <code>3 又 1/2</code> 个块，那么最后一个块的部分内存会被浪费。在上面这幅图中，总共展示了 7 个文件，每个文件都会从上个文件的末尾块开始写新的文件块。</p>
<p>连续的磁盘空间分配有两个优点。</p>
<ul>
<li>第一，连续文件存储实现起来比较简单，只需要记住两个数字就可以：一个是第一个块的文件地址和文件的块数量。给定第一个块的编号，可以通过简单的加法找到任何其他块的编号。</li>
<li>第二点是读取性能比较强，可以通过一次操作从文件中读取整个文件。只需要一次寻找第一个块。后面就不再需要寻道时间和旋转延迟，所以数据会以全带宽进入磁盘。</li>
</ul>
<p>因此，连续的空间分配具有<code>实现简单</code>、<code>高性能</code>的特点。</p>
<p>不幸的是，连续空间分配也有很明显的不足。随着时间的推移，磁盘会变得很零碎。下图解释了这种现象</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830262-ef7ce9d8-c4b9-488c-a2d3-48d7888ffe1f.png#align=left&amp;display=inline&amp;height=250&amp;margin=%5Bobject%20Object%5D&amp;originHeight=250&amp;originWidth=700&amp;size=0&amp;status=done&amp;style=none&amp;width=700" alt></p>
<p>这里有两个文件 D 和 F 被删除了。当删除一个文件时，此文件所占用的块也随之释放，就会在磁盘空间中留下一些空闲块。磁盘并不会在这个位置挤压掉空闲块，因为这会复制空闲块之后的所有文件，可能会有上百万的块，这个量级就太大了。</p>
<h4 id="链表分配"><a href="#链表分配" class="headerlink" title="链表分配"></a>链表分配</h4><p>第二种存储文件的方式是为每个文件构造磁盘块链表，每个文件都是磁盘块的链接列表，就像下面所示</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830296-9199d50b-5e5b-43f4-a62b-dc0b1ef02d6d.png#align=left&amp;display=inline&amp;height=472&amp;margin=%5Bobject%20Object%5D&amp;originHeight=472&amp;originWidth=739&amp;size=0&amp;status=done&amp;style=none&amp;width=739" alt></p>
<p>以磁盘块的链表形式存储文件</p>
<p>每个块的第一个字作为指向下一块的指针，块的其他部分存放数据。如果上面这张图你看的不是很清楚的话，可以看看整个的链表分配方案</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830272-99171e3f-0aae-4fa7-b127-e43f64daed7d.png#align=left&amp;display=inline&amp;height=548&amp;margin=%5Bobject%20Object%5D&amp;originHeight=548&amp;originWidth=717&amp;size=0&amp;status=done&amp;style=none&amp;width=717" alt></p>
<p>与连续分配方案不同，这一方法可以充分利用每个磁盘块。除了最后一个磁盘块外，不会因为磁盘碎片而浪费存储空间。同样，在目录项中，只要存储了第一个文件块，那么其他文件块也能够被找到。</p>
<p>另一方面，在链表的分配方案中，尽管顺序读取非常方便，但是随机访问却很困难（这也是数组和链表数据结构的一大区别）。</p>
<p>还有一个问题是，由于指针会占用一些字节，每个磁盘块实际存储数据的字节数并不再是 2 的整数次幂。虽然这个问题并不会很严重，但是这种方式降低了程序运行效率。许多程序都是以长度为 2 的整数次幂来读写磁盘，由于每个块的前几个字节被指针所使用，所以要读出一个完成的块大小信息，就需要当前块的信息和下一块的信息拼凑而成，因此就引发了查找和拼接的开销。</p>
<h4 id="使用内存表进行链表分配"><a href="#使用内存表进行链表分配" class="headerlink" title="使用内存表进行链表分配"></a>使用内存表进行链表分配</h4><p>由于连续分配和链表分配都有其不可忽视的缺点。所以提出了使用内存中的表来解决分配问题。取出每个磁盘块的指针字，把它们放在内存的一个表中，就可以解决上述链表的两个不足之处。下面是一个例子</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830309-8180ae56-d298-4224-a60b-d472bd7dff53.png#align=left&amp;display=inline&amp;height=448&amp;margin=%5Bobject%20Object%5D&amp;originHeight=448&amp;originWidth=499&amp;size=0&amp;status=done&amp;style=none&amp;width=499" alt></p>
<p>上图表示了链表形成的磁盘块的内容。这两个图中都有两个文件，文件 A 依次使用了磁盘块地址 <strong>4、7、 2、 10、 12</strong>，文件 B 使用了<strong>6、3、11 和 14</strong>。也就是说，文件 A 从地址 4 处开始，顺着链表走就能找到文件 A 的全部磁盘块。同样，从第 6 块开始，顺着链走到最后，也能够找到文件 B 的全部磁盘块。你会发现，这两个链表都以不属于有效磁盘编号的特殊标记（-1）结束。内存中的这种表格称为 <code>文件分配表(File Application Table,FAT)</code>。</p>
<h3 id="目录的实现"><a href="#目录的实现" class="headerlink" title="目录的实现"></a>目录的实现</h3><p>文件只有打开后才能够被读取。在文件打开后，操作系统会使用用户提供的路径名来定位磁盘中的目录。目录项提供了查找文件磁盘块所需要的信息。根据系统的不同，提供的信息也不同，可能提供的信息是整个文件的磁盘地址，或者是第一个块的数量（两个链表方案）或 inode 的数量。不过不管用那种情况，目录系统的主要功能就是 <strong>将文件的 ASCII 码的名称映射到定位数据所需的信息上</strong>。</p>
<h3 id="共享文件"><a href="#共享文件" class="headerlink" title="共享文件"></a>共享文件</h3><p>当多个用户在同一个项目中工作时，他们通常需要共享文件。如果这个共享文件同时出现在多个用户目录下，那么他们协同工作起来就很方便。下面的这张图我们在上面提到过，但是有一个更改的地方，就是 <strong>C 的一个文件也出现在了 B 的目录下</strong>。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830321-b6391c5b-3b64-4089-9c4e-9a9afd09875c.png#align=left&amp;display=inline&amp;height=559&amp;margin=%5Bobject%20Object%5D&amp;originHeight=559&amp;originWidth=743&amp;size=0&amp;status=done&amp;style=none&amp;width=743" alt></p>
<p>如果按照如上图的这种组织方式而言，那么 B 的目录与该共享文件的联系称为 <code>链接(link)</code>。那么文件系统现在就是一个 <code>有向无环图(Directed Acyclic Graph, 简称 DAG)</code>，而不是一棵树了。</p>
<h3 id="日志结构文件系统"><a href="#日志结构文件系统" class="headerlink" title="日志结构文件系统"></a>日志结构文件系统</h3><p>技术的改变会给当前的文件系统带来压力。这种情况下，CPU 会变得越来越快，磁盘会变得越来越大并且越来越便宜（但不会越来越快）。内存容量也是以指数级增长。但是磁盘的寻道时间（除了固态盘，因为固态盘没有寻道时间）并没有获得提高。</p>
<p>为此，<code>Berkeley</code> 设计了一种全新的文件系统，试图缓解这个问题，这个文件系统就是 <code>日志结构文件系统(Log-structured File System, LFS)</code>。旨在解决以下问题。</p>
<ul>
<li>不断增长的系统内存</li>
<li>顺序 I/O 性能胜过随机 I/O 性能</li>
<li>现有低效率的文件系统</li>
<li>文件系统不支持 RAID（虚拟化）</li>
</ul>
<p>另一方面，当时的文件系统不论是 UNIX 还是 FFS，都有大量的随机读写（在 FFS 中创建一个新文件至少需要 5 次随机写），因此成为整个系统的性能瓶颈。同时因为 <code>Page cache</code> 的存在，作者认为随机读不是主要问题：随着越来越大的内存，大部分的读操作都能被 cache，因此 LFS 主要要解决的是减少对硬盘的随机写操作。</p>
<p>在这种设计中，inode 甚至具有与 UNIX 中相同的结构，但是现在它们分散在整个日志中，而不是位于磁盘上的固定位置。所以，inode 很定位。为了能够找到 inode ，维护了一个由 inode 索引的 <code>inode map(inode 映射)</code>。表项 i 指向磁盘中的第 i 个 inode 。这个映射保存在磁盘中，但是也保存在缓存中，因此，使用最频繁的部分大部分时间都在内存中。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830360-ead8d1cc-da6e-40bc-896b-4350498bf5c8.png#align=left&amp;display=inline&amp;height=348&amp;margin=%5Bobject%20Object%5D&amp;originHeight=348&amp;originWidth=732&amp;size=0&amp;status=done&amp;style=none&amp;width=732" alt></p>
<p>到目前为止，所有写入最初都缓存在<code>内存</code>中，并且追加在<code>日志末尾</code>，所有缓存的写入都定期在单个段中写入磁盘。所以，现在打开文件也就意味着用映射定位文件的索引节点。一旦 inode 被定位后，磁盘块的地址就能够被找到。所有这些块本身都将位于日志中某处的分段中。</p>
<p>真实情况下的磁盘容量是有限的，所以最终日志会占满整个磁盘空间，这种情况下就会出现没有新的磁盘块被写入到日志中。幸运的是，许多现有段可能具有不再需要的块。例如，如果一个文件被覆盖了，那么它的 inode 将被指向新的块，但是旧的磁盘块仍在先前写入的段中占据着空间。</p>
<p>为了处理这个问题，LFS 有一个<code>清理(clean)</code>线程，它会循环扫描日志并对日志进行压缩。首先，通过查看日志中第一部分的信息来查看其中存在哪些索引节点和文件。它会检查当前 inode 的映射来查看 inode 否在在当前块中，是否仍在被使用。如果不是，该信息将被丢弃。如果仍然在使用，那么 inode 和块就会进入内存等待写回到下一个段中。然后原来的段被标记为空闲，以便日志可以用来存放新的数据。用这种方法，清理线程遍历日志，从后面移走旧的段，然后将有效的数据放入内存等待写到下一个段中。由此一来整个磁盘会形成一个大的<code>环形缓冲区</code>，写线程将新的段写在前面，而清理线程则清理后面的段。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830348-81e32c04-1184-4cdb-8403-2efeeb68787c.png#align=left&amp;display=inline&amp;height=236&amp;margin=%5Bobject%20Object%5D&amp;originHeight=236&amp;originWidth=631&amp;size=0&amp;status=done&amp;style=none&amp;width=631" alt></p>
<h3 id="日志文件系统"><a href="#日志文件系统" class="headerlink" title="日志文件系统"></a>日志文件系统</h3><p>虽然日志结构系统的设计很优雅，但是由于它们和现有的文件系统不相匹配，因此还没有广泛使用。不过，从日志文件结构系统衍生出来一种新的日志系统，叫做<code>日志文件系统</code>，它会记录系统下一步将要做什么的日志。微软的 <code>NTFS</code> 文件系统、Linux 的 <code>ext3</code> 就使用了此日志。 <code>OS X</code> 将日志系统作为可供选项。为了看清它是如何工作的，我们下面讨论一个例子，比如 <code>移除文件</code> ，这个操作在 UNIX 中需要三个步骤完成：</p>
<ul>
<li>在目录中删除文件</li>
<li>释放 inode 到空闲 inode 池</li>
<li>将所有磁盘块归还给空闲磁盘池。</li>
</ul>
<h3 id="虚拟文件系统"><a href="#虚拟文件系统" class="headerlink" title="虚拟文件系统"></a>虚拟文件系统</h3><p>UNIX 操作系统使用一种 <code>虚拟文件系统(Virtual File System, VFS)</code> 来尝试将多种文件系统构成一个有序的结构。关键的思想是抽象出所有文件系统都共有的部分，并将这部分代码放在一层，这一层再调用具体文件系统来管理数据。下面是一个 VFS 的系统结构</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830356-635b72b4-bcf2-434f-9719-c83b191da6cf.png#align=left&amp;display=inline&amp;height=345&amp;margin=%5Bobject%20Object%5D&amp;originHeight=345&amp;originWidth=675&amp;size=0&amp;status=done&amp;style=none&amp;width=675" alt></p>
<p>还是那句经典的话，在计算机世界中，任何解决不了的问题都可以加个<code>代理</code>来解决。所有和文件相关的系统调用在最初的处理上都指向虚拟文件系统。这些来自用户进程的调用，都是标准的 <code>POSIX 系统调用</code>，比如 open、read、write 和 seek 等。VFS 对用户进程有一个 <code>上层</code> 接口，这个接口就是著名的 POSIX 接口。</p>
<h2 id="文件系统的管理和优化"><a href="#文件系统的管理和优化" class="headerlink" title="文件系统的管理和优化"></a>文件系统的管理和优化</h2><p>能够使文件系统工作是一回事，能够使文件系统高效、稳定的工作是另一回事，下面我们就来探讨一下文件系统的管理和优化。</p>
<h3 id="磁盘空间管理"><a href="#磁盘空间管理" class="headerlink" title="磁盘空间管理"></a>磁盘空间管理</h3><p>文件通常存在磁盘中，所以如何管理磁盘空间是一个操作系统的设计者需要考虑的问题。在文件上进行存有两种策略：<strong>分配 n 个字节的连续磁盘空间；或者把文件拆分成多个并不一定连续的块</strong>。在存储管理系统中，主要有<code>分段管理</code>和 <code>分页管理</code> 两种方式。</p>
<p>正如我们所看到的，按<code>连续字节序列</code>存储文件有一个明显的问题，当文件扩大时，有可能需要在磁盘上移动文件。内存中分段也有同样的问题。不同的是，相对于把文件从磁盘的一个位置移动到另一个位置，内存中段的移动操作要快很多。因此，几乎所有的文件系统都把文件分割成固定大小的块来存储。</p>
<h4 id="块大小"><a href="#块大小" class="headerlink" title="块大小"></a>块大小</h4><p>一旦把文件分为固定大小的块来存储，就会出现问题，块的大小是多少？按照<strong>磁盘组织方式，扇区、磁道和柱面显然都可以作为分配单位</strong>。在分页系统中，分页大小也是主要因素。</p>
<p>拥有大的块尺寸意味着每个文件，甚至 1 字节文件，都要占用一个柱面空间，也就是说小文件浪费了大量的磁盘空间。另一方面，小块意味着大部分文件将会跨越多个块，因此需要多次搜索和旋转延迟才能读取它们，从而降低了性能。因此，如果分配的块<code>太大</code>会浪费<code>空间</code>；分配的块<code>太小</code>会浪费<code>时间</code>。</p>
<h4 id="记录空闲块"><a href="#记录空闲块" class="headerlink" title="记录空闲块"></a>记录空闲块</h4><p>一旦指定了块大小，下一个问题就是怎样跟踪空闲块。有两种方法被广泛采用，如下图所示</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830365-86ca166a-5dd1-4e96-b9b4-2966e2d87565.png#align=left&amp;display=inline&amp;height=476&amp;margin=%5Bobject%20Object%5D&amp;originHeight=476&amp;originWidth=753&amp;size=0&amp;status=done&amp;style=none&amp;width=753" alt></p>
<p>第一种方法是采用<code>磁盘块链表</code>，链表的每个块中包含极可能多的空闲磁盘块号。对于 1 KB 的块和 32 位的磁盘块号，空闲表中每个块包含有 255 个空闲的块号。考虑 1 TB 的硬盘，拥有大概十亿个磁盘块。为了存储全部地址块号，如果每块可以保存 255 个块号，则需要将近 400 万个块。通常，空闲块用于保存空闲列表，因此存储基本上是空闲的。</p>
<p>另一种空闲空间管理的技术是<code>位图(bitmap)</code>，n 个块的磁盘需要 n 位位图。在位图中，空闲块用 1 表示，已分配的块用 0 表示。对于 1 TB 硬盘的例子，需要 10 亿位表示，即需要大约 130 000 个 1 KB 块存储。很明显，和 32 位链表模型相比，位图需要的空间更少，因为每个块使用 1 位。只有当磁盘快满的时候，链表需要的块才会比位图少。</p>
<h3 id="磁盘配额"><a href="#磁盘配额" class="headerlink" title="磁盘配额"></a>磁盘配额</h3><p>为了防止一些用户占用太多的磁盘空间，多用户操作通常提供一种<code>磁盘配额(enforcing disk quotas)</code>的机制。系统管理员为每个用户分配<strong>最大的文件和块分配</strong>，并且操作系统确保用户不会超过其配额。我们下面会谈到这一机制。</p>
<p>在用户打开一个文件时，操作系统会找到<code>文件属性</code>和<code>磁盘地址</code>，并把它们送入内存中的打开文件表。其中一个属性告诉<code>文件所有者</code>是谁。任何有关文件的增加都会记到所有者的配额中。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830397-dc14e657-f7ce-4c0e-a2fc-dae37cdce37e.png#align=left&amp;display=inline&amp;height=532&amp;margin=%5Bobject%20Object%5D&amp;originHeight=532&amp;originWidth=681&amp;size=0&amp;status=done&amp;style=none&amp;width=681" alt></p>
<p>配额表中记录了每个用户的配额</p>
<p>第二张表包含了每个用户当前打开文件的配额记录，即使是其他人打开该文件也一样。如上图所示，该表的内容是从被打开文件的所有者的磁盘配额文件中提取出来的。当所有文件关闭时，该记录被写回配额文件。</p>
<p>当在打开文件表中建立一新表项时，会产生一个指向所有者配额记录的指针。每次向文件中添加一个块时，文件所有者所用数据块的总数也随之增加，并会同时增加<code>硬限制</code>和<code>软限制</code>的检查。可以超出软限制，但硬限制不可以超出。当已达到硬限制时，再往文件中添加内容将引发错误。同样，对文件数目也存在类似的检查。</p>
<h3 id="文件系统备份"><a href="#文件系统备份" class="headerlink" title="文件系统备份"></a>文件系统备份</h3><p>做文件备份很耗费时间而且也很浪费空间，这会引起下面几个问题。首先，是要<strong>备份整个文件还是仅备份一部分呢</strong>？一般来说，只是备份特定目录及其下的全部文件，而不是备份整个文件系统。</p>
<p>其次，对上次未修改过的文件再进行备份是一种浪费，因而产生了一种<code>增量转储(incremental dumps)</code> 的思想。最简单的增量转储的形式就是<code>周期性</code>的做全面的备份，而每天只对增量转储完成后发生变化的文件做单个备份。</p>
<p>稍微好一点的方式是只备份最近一次转储以来更改过的文件。当然，这种做法极大的缩减了转储时间，但恢复起来却更复杂，因为<strong>最近的全面转储先要全部恢复，随后按逆序进行增量转储</strong>。为了方便恢复，人们往往使用更复杂的转储模式。</p>
<p>第三，既然待转储的往往是海量数据，那么在将其写入磁带之前对文件进行压缩就很有必要。但是，如果在备份过程中出现了文件损坏的情况，就会导致破坏压缩算法，从而使整个磁带无法读取。所以在备份前是否进行文件压缩需慎重考虑。</p>
<p>第四，对正在使用的文件系统做备份是很难的。如果在转储过程中要添加，删除和修改文件和目录，则转储结果可能不一致。因此，因为转储过程中需要花费数个小时的时间，所以有必要在晚上将系统脱机进行备份，然而这种方式的接受程度并不高。所以，人们修改了转储算法，记下文件系统的<code>瞬时快照</code>，即复制关键的数据结构，然后需要把将来对文件和目录所做的修改复制到块中，而不是到处更新他们。</p>
<p>磁盘转储到备份磁盘上有两种方案：<strong>物理转储和逻辑转储</strong>。<code>物理转储(physical dump)</code> 是从磁盘的 0 块开始，依次将所有磁盘块按照顺序写入到输出磁盘，并在复制最后一个磁盘时停止。这种程序的万无一失性是其他程序所不具备的。</p>
<p>第二个需要考虑的是<strong>坏块的转储</strong>。制造大型磁盘而没有瑕疵是不可能的，所以也会存在一些<code>坏块(bad blocks)</code>。有时进行低级格式化后，坏块会被检测出来并进行标记，这种情况的解决办法是用磁盘末尾的一些空闲块所替换。</p>
<p>然而，一些块在格式化后会变坏，在这种情况下操作系统可以检测到它们。通常情况下，它可以通过创建一个由所有坏块组成的<code>文件</code>来解决问题，确保它们不会出现在空闲池中并且永远不会被分配。<strong>那么此文件是完全不可读的</strong>。如果磁盘控制器将所有的坏块重新映射，物理转储还是能够正常工作的。</p>
<p>Windows 系统有<code>分页文件(paging files)</code> 和 <code>休眠文件(hibernation files)</code> 。它们在文件还原时不发挥作用，同时也不应该在第一时间进行备份。</p>
<h3 id="文件系统的一致性"><a href="#文件系统的一致性" class="headerlink" title="文件系统的一致性"></a>文件系统的一致性</h3><p>影响可靠性的一个因素是文件系统的一致性。许多文件系统读取磁盘块、修改磁盘块、再把它们写回磁盘。如果系统在所有块写入之前崩溃，文件系统就会处于一种<code>不一致(inconsistent)</code>的状态。如果某些尚未写回的块是索引节点块，目录块或包含空闲列表的块，则此问题是很严重的。</p>
<p>为了处理文件系统一致性问题，大部分计算机都会有应用程序来检查文件系统的一致性。例如，UNIX 有 <code>fsck</code>；Windows 有 <code>sfc</code>，每当引导系统时（尤其是在崩溃后），都可以运行该程序。</p>
<p>可以进行两种一致性检查：<strong>块的一致性检查和文件的一致性检查</strong>。为了检查块的一致性，应用程序会建立两张表，每个包含一个计数器的块，最初设置为 0 。第一个表中的计数器跟踪该块在文件中出现的次数，第二张表中的计数器记录每个块在空闲列表、空闲位图中出现的频率。</p>
<h3 id="文件系统性能"><a href="#文件系统性能" class="headerlink" title="文件系统性能"></a>文件系统性能</h3><p>访问磁盘的效率要比内存满的多，是时候又祭出这张图了</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830422-af95403a-f195-4d9e-8125-0d05ec7651ff.png#align=left&amp;display=inline&amp;height=312&amp;margin=%5Bobject%20Object%5D&amp;originHeight=312&amp;originWidth=711&amp;size=0&amp;status=done&amp;style=none&amp;width=711" alt></p>
<p>从内存读一个 32 位字大概是 10ns，从硬盘上读的速率大概是 100MB/S，对每个 32 位字来说，效率会慢了四倍，另外，还要加上 5 - 10 ms 的寻道时间等其他损耗，如果只访问一个字，内存要比磁盘快百万数量级。所以磁盘优化是很有必要的，下面我们会讨论几种优化方式</p>
<h4 id="高速缓存"><a href="#高速缓存" class="headerlink" title="高速缓存"></a>高速缓存</h4><p>最常用的减少磁盘访问次数的技术是使用 <code>块高速缓存(block cache)</code> 或者 <code>缓冲区高速缓存(buffer cache)</code>。高速缓存指的是一系列的块，它们在逻辑上属于磁盘，但实际上基于性能的考虑被保存在内存中。</p>
<p>管理高速缓存有不同的算法，常用的算法是：检查全部的读请求，查看在高速缓存中是否有所需要的块。如果存在，可执行读操作而无须访问磁盘。如果检查块不再高速缓存中，那么首先把它读入高速缓存，再复制到所需的地方。之后，对同一个块的请求都通过<code>高速缓存</code>来完成。</p>
<p>高速缓存的操作如下图所示</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830486-9b7cd7d5-cd58-485e-8fb9-7c5f918fb69a.png#align=left&amp;display=inline&amp;height=262&amp;margin=%5Bobject%20Object%5D&amp;originHeight=262&amp;originWidth=733&amp;size=0&amp;status=done&amp;style=none&amp;width=733" alt></p>
<p>由于在高速缓存中有许多块，所以需要某种方法快速确定所需的块是否存在。常用方法是将设备和磁盘地址进行散列操作，然后，在散列表中查找结果。具有相同散列值的块在一个链表中连接在一起（这个数据结构是不是很像 HashMap?），这样就可以沿着冲突链查找其他块。</p>
<p>如果高速缓存<code>已满</code>，此时需要调入新的块，则要把原来的某一块调出高速缓存，如果要调出的块在上次调入后已经被修改过，则需要把它写回磁盘。</p>
<h4 id="块提前读"><a href="#块提前读" class="headerlink" title="块提前读"></a>块提前读</h4><p>第二个明显提高文件系统的性能是，在需要用到块之前，试图<code>提前</code>将其写入高速缓存，从而<code>提高命中率</code>。许多文件都是顺序读取。如果请求文件系统在某个文件中生成块 k，文件系统执行相关操作并且在完成之后，会检查高速缓存，以便确定块 k + 1 是否已经在高速缓存。如果不在，文件系统会为 k + 1 安排一个预读取，因为文件希望在用到该块的时候能够直接从高速缓存中读取。</p>
<p>当然，块提前读取策略只适用于实际顺序读取的文件。对随机访问的文件，提前读丝毫不起作用。甚至还会造成阻碍。</p>
<h4 id="减少磁盘臂运动"><a href="#减少磁盘臂运动" class="headerlink" title="减少磁盘臂运动"></a>减少磁盘臂运动</h4><p>高速缓存和块提前读并不是提高文件系统性能的唯一方法。另一种重要的技术是<strong>把有可能顺序访问的块放在一起，当然最好是在同一个柱面上，从而减少磁盘臂的移动次数</strong>。当写一个输出文件时，文件系统就必须按照要求一次一次地分配磁盘块。如果用位图来记录空闲块，并且整个位图在内存中，那么选择与前一块最近的空闲块是很容易的。如果用空闲表，并且链表的一部分存在磁盘上，要分配紧邻的空闲块就会困难很多。</p>
<h4 id="磁盘碎片整理"><a href="#磁盘碎片整理" class="headerlink" title="磁盘碎片整理"></a>磁盘碎片整理</h4><p>在初始安装操作系统后，文件就会被不断的创建和清除，于是磁盘会产生很多的碎片，在创建一个文件时，它使用的块会散布在整个磁盘上，降低性能。删除文件后，回收磁盘块，可能会造成空穴。</p>
<p>磁盘性能可以通过如下方式恢复：移动文件使它们相互挨着，并把所有的至少是大部分的空闲空间放在一个或多个大的连续区域内。Windows 有一个程序 <code>defrag</code> 就是做这个事儿的。Windows 用户会经常使用它，SSD 除外。</p>
<p>磁盘碎片整理程序会在让文件系统上很好地运行。Linux 文件系统（特别是 ext2 和 ext3）由于其选择磁盘块的方式，在磁盘碎片整理上一般不会像 Windows 一样困难，因此很少需要手动的磁盘碎片整理。而且，固态硬盘并不受磁盘碎片的影响，事实上，在固态硬盘上做磁盘碎片整理反倒是多此一举，不仅没有提高性能，反而磨损了固态硬盘。所以碎片整理只会缩短固态硬盘的寿命。</p>
<p>下面我们来探讨一下 I/O 流程问题。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830481-2693434c-6334-4f5a-a152-75454e91d275.png#align=left&amp;display=inline&amp;height=474&amp;margin=%5Bobject%20Object%5D&amp;originHeight=474&amp;originWidth=752&amp;size=0&amp;status=done&amp;style=none&amp;width=752" alt></p>
<h2 id="I-O-设备"><a href="#I-O-设备" class="headerlink" title="I/O 设备"></a>I/O 设备</h2><p>什么是 I/O 设备？I/O 设备又叫做输入/输出设备，它是人类用来和计算机进行通信的外部硬件。输入/输出设备能够向计算机<code>发送数据（输出）</code>并从计算机<code>接收数据（输入）</code>。</p>
<p><code>I/O 设备(I/O devices)</code>可以分成两种：<code>块设备(block devices)</code> 和 <code>字符设备(character devices)</code>。</p>
<h4 id="块设备"><a href="#块设备" class="headerlink" title="块设备"></a>块设备</h4><p>块设备是一个能存储<code>固定大小块</code>信息的设备，它支持<strong>以固定大小的块，扇区或群集读取和（可选）写入数据</strong>。每个块都有自己的<code>物理地址</code>。通常块的大小在 512 - 65536 之间。所有传输的信息都会以<code>连续</code>的块为单位。块设备的基本特征是每个块都较为对立，能够独立的进行读写。常见的块设备有 <strong>硬盘、蓝光光盘、USB 盘</strong></p>
<p>与字符设备相比，块设备通常需要较少的引脚。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830476-de4c28f8-7881-487b-9bc3-11bf81770f23.png#align=left&amp;display=inline&amp;height=257&amp;margin=%5Bobject%20Object%5D&amp;originHeight=257&amp;originWidth=700&amp;size=0&amp;status=done&amp;style=none&amp;width=700" alt></p>
<h4 id="块设备的缺点"><a href="#块设备的缺点" class="headerlink" title="块设备的缺点"></a>块设备的缺点</h4><p>基于给定固态存储器的块设备比基于相同类型的存储器的字节寻址要慢一些，因为必须在块的开头开始读取或写入。所以，要读取该块的任何部分，必须寻找到该块的开始，读取整个块，如果不使用该块，则将其丢弃。要写入块的一部分，必须寻找到块的开始，将整个块读入内存，修改数据，再次寻找到块的开头处，然后将整个块写回设备。</p>
<h4 id="字符设备"><a href="#字符设备" class="headerlink" title="字符设备"></a>字符设备</h4><p>另一类 I/O 设备是<code>字符设备</code>。字符设备以<code>字符</code>为单位发送或接收一个字符流，而不考虑任何块结构。字符设备是不可寻址的，也没有任何寻道操作。常见的字符设备有 <strong>打印机、网络设备、鼠标、以及大多数与磁盘不同的设备</strong>。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830510-e704b09f-ae66-45ce-bde4-66fd175dc769.png#align=left&amp;display=inline&amp;height=322&amp;margin=%5Bobject%20Object%5D&amp;originHeight=322&amp;originWidth=703&amp;size=0&amp;status=done&amp;style=none&amp;width=703" alt></p>
<h3 id="设备控制器"><a href="#设备控制器" class="headerlink" title="设备控制器"></a>设备控制器</h3><p>设备控制器是处理 CPU 传入和传出信号的系统。设备通过插头和插座连接到计算机，并且插座连接到设备控制器。设备控制器从连接的设备处接收数据，并将其存储在控制器内部的一些<code>特殊目的寄存器(special purpose registers)</code> 也就是本地缓冲区中。</p>
<p>每个设备控制器都会有一个应用程序与之对应，设备控制器通过应用程序的接口通过中断与操作系统进行通信。设备控制器是硬件，而设备驱动程序是软件。</p>
<h3 id="内存映射-I-O"><a href="#内存映射-I-O" class="headerlink" title="内存映射 I/O"></a>内存映射 I/O</h3><p>每个控制器都会有几个寄存器用来和 CPU 进行通信。通过写入这些寄存器，操作系统可以命令设备发送数据，接收数据、开启或者关闭设备等。通过从这些寄存器中读取信息，操作系统能够知道设备的状态，是否准备接受一个新命令等。</p>
<p>为了控制<code>寄存器</code>，许多设备都会有<code>数据缓冲区(data buffer)</code>，来供系统进行读写。</p>
<p>那么问题来了，CPU 如何与设备寄存器和设备数据缓冲区进行通信呢？存在两个可选的方式。第一种方法是，每个控制寄存器都被分配一个 <code>I/O 端口(I/O port)</code>号，这是一个 8 位或 16 位的整数。所有 I/O 端口的集合形成了受保护的 I/O 端口空间，以便普通用户程序无法访问它（只有操作系统可以访问）。使用特殊的 I/O 指令像是</p>
<pre><code class="assembly">IN REG,PORT
</code></pre>
<p>CPU 可以读取控制寄存器 PORT 的内容并将结果放在 CPU 寄存器 REG 中。类似的，使用</p>
<pre><code class="assembly">OUT PORT,REG
</code></pre>
<p>CPU 可以将 REG 的内容写到控制寄存器中。大多数早期计算机，包括几乎所有大型主机，如 IBM 360 及其所有后续机型，都是以这种方式工作的。</p>
<p>第二个方法是 PDP-11 引入的，它将<strong>所有控制寄存器映射到内存空间</strong>中。</p>
<h3 id="直接内存访问"><a href="#直接内存访问" class="headerlink" title="直接内存访问"></a>直接内存访问</h3><p>无论一个 CPU 是否具有内存映射 I/O，它都需要寻址设备控制器以便与它们交换数据。CPU 可以从 I/O 控制器每次请求一个字节的数据，但是这么做会浪费 CPU 时间，所以经常会用到一种称为<code>直接内存访问(Direct Memory Access)</code> 的方案。为了简化，我们假设 CPU 通过单一的系统总线访问所有的设备和内存，该总线连接 CPU 、内存和 I/O 设备，如下图所示</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830508-9d21c036-35f6-4f66-a119-b33cd2ebffa9.png#align=left&amp;display=inline&amp;height=351&amp;margin=%5Bobject%20Object%5D&amp;originHeight=351&amp;originWidth=720&amp;size=0&amp;status=done&amp;style=none&amp;width=720" alt></p>
<p>DMA 传送操作</p>
<p>现代操作系统实际更为复杂，但是原理是相同的。如果硬件有 <code>DMA 控制器</code>，那么操作系统只能使用 DMA。有时这个控制器会集成到磁盘控制器和其他控制器中，但这种设计需要在每个设备上都装有一个分离的 DMA 控制器。单个的 DMA 控制器可用于向多个设备传输，这种传输往往同时进行。</p>
<h4 id="DMA-工作原理"><a href="#DMA-工作原理" class="headerlink" title="DMA 工作原理"></a>DMA 工作原理</h4><p>首先 CPU 通过设置 DMA 控制器的寄存器对它进行编程，所以 DMA 控制器知道将什么数据传送到什么地方。DMA 控制器还要向磁盘控制器发出一个命令，通知它从磁盘读数据到其内部的缓冲区并检验校验和。当有效数据位于磁盘控制器的缓冲区中时，DMA 就可以开始了。</p>
<p>DMA 控制器通过在总线上发出一个<code>读请求</code>到磁盘控制器而发起 DMA 传送，这是第二步。这个读请求就像其他读请求一样，磁盘控制器并不知道或者并不关心它是来自 CPU 还是来自 DMA 控制器。通常情况下，要写的内存地址在总线的地址线上，所以当磁盘控制器去匹配下一个字时，它知道将该字写到什么地方。写到内存就是另外一个总线循环了，这是第三步。当写操作完成时，磁盘控制器在总线上发出一个应答信号到 DMA 控制器，这是第四步。</p>
<p>然后，DMA 控制器会增加内存地址并减少字节数量。如果字节数量仍然大于 0 ，就会循环步骤 2 - 步骤 4 ，直到字节计数变为 0 。此时，DMA 控制器会打断 CPU 并告诉它传输已经完成了。</p>
<h3 id="重温中断"><a href="#重温中断" class="headerlink" title="重温中断"></a>重温中断</h3><p>在一台个人计算机体系结构中，中断结构会如下所示</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830529-8f149c71-9817-4096-a8df-b613c0308a0c.png#align=left&amp;display=inline&amp;height=320&amp;margin=%5Bobject%20Object%5D&amp;originHeight=320&amp;originWidth=719&amp;size=0&amp;status=done&amp;style=none&amp;width=719" alt></p>
<p>中断是怎样发生的</p>
<p>当一个 I/O 设备完成它的工作后，它就会产生一个中断（默认操作系统已经开启中断），它通过在总线上声明已分配的信号来实现此目的。主板上的中断控制器芯片会检测到这个信号，然后执行中断操作。</p>
<h4 id="精确中断和不精确中断"><a href="#精确中断和不精确中断" class="headerlink" title="精确中断和不精确中断"></a>精确中断和不精确中断</h4><p>使机器处于良好状态的中断称为<code>精确中断(precise interrupt)</code>。这样的中断具有四个属性：</p>
<ul>
<li>PC （程序计数器）保存在一个已知的地方</li>
<li>PC 所指向的指令之前所有的指令已经完全执行</li>
<li>PC 所指向的指令之后所有的指令都没有执行</li>
<li>PC 所指向的指令的执行状态是已知的</li>
</ul>
<p>不满足以上要求的中断称为 <code>不精确中断(imprecise interrupt)</code>，不精确中断让人很头疼。上图描述了不精确中断的现象。指令的执行时序和完成度具有不确定性，而且恢复起来也非常麻烦。</p>
<h2 id="IO-软件原理"><a href="#IO-软件原理" class="headerlink" title="IO 软件原理"></a>IO 软件原理</h2><h3 id="I-O-软件目标"><a href="#I-O-软件目标" class="headerlink" title="I/O 软件目标"></a>I/O 软件目标</h3><h4 id="设备独立性"><a href="#设备独立性" class="headerlink" title="设备独立性"></a>设备独立性</h4><p>I/O 软件设计一个很重要的目标就是<code>设备独立性(device independence)</code>。这意味着<strong>我们能够编写访问任何设备的应用程序，而不用事先指定特定的设备</strong>。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830529-e4825574-4e1c-43fa-adf0-519f0ea1c7f7.png#align=left&amp;display=inline&amp;height=403&amp;margin=%5Bobject%20Object%5D&amp;originHeight=403&amp;originWidth=500&amp;size=0&amp;status=done&amp;style=none&amp;width=500" alt></p>
<h4 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h4><p>除了<code>设备独立性</code>外，I/O 软件实现的第二个重要的目标就是<code>错误处理(error handling)</code>。通常情况下来说，错误应该交给<code>硬件</code>层面去处理。如果设备控制器发现了读错误的话，它会尽可能的去修复这个错误。如果设备控制器处理不了这个问题，那么设备驱动程序应该进行处理，设备驱动程序会再次尝试读取操作，很多错误都是偶然性的，如果设备驱动程序无法处理这个错误，才会把错误向上抛到硬件层面（上层）进行处理，很多时候，上层并不需要知道下层是如何解决错误的。</p>
<h4 id="同步和异步传输"><a href="#同步和异步传输" class="headerlink" title="同步和异步传输"></a>同步和异步传输</h4><p>I/O 软件实现的第三个目标就是 <code>同步(synchronous)</code> 和 <code>异步(asynchronous，即中断驱动)</code>传输。这里先说一下同步和异步是怎么回事吧。</p>
<p>同步传输中数据通常以块或帧的形式发送。发送方和接收方在数据传输之前应该具有<code>同步时钟</code>。而在异步传输中，数据通常以字节或者字符的形式发送，异步传输则不需要同步时钟，但是会在传输之前向数据添加<code>奇偶校验位</code>。大部分<code>物理IO(physical I/O)</code> 是异步的。物理 I/O 中的 CPU 是很聪明的，CPU 传输完成后会转而做其他事情，它和中断心灵相通，等到中断发生后，CPU 才会回到传输这件事情上来。</p>
<h4 id="缓冲"><a href="#缓冲" class="headerlink" title="缓冲"></a>缓冲</h4><p>I/O 软件的最后一个问题是<code>缓冲(buffering)</code>。通常情况下，从一个设备发出的数据不会直接到达最后的设备。其间会经过一系列的校验、检查、缓冲等操作才能到达。</p>
<h4 id="共享和独占"><a href="#共享和独占" class="headerlink" title="共享和独占"></a>共享和独占</h4><p>I/O 软件引起的最后一个问题就是共享设备和独占设备的问题。有些 I/O 设备能够被许多用户共同使用。一些设备比如磁盘，让多个用户使用一般不会产生什么问题，但是某些设备必须具有独占性，即只允许单个用户使用完成后才能让其他用户使用。</p>
<p>一共有三种控制 I/O 设备的方法</p>
<ul>
<li>使用程序控制 I/O</li>
<li>使用中断驱动 I/O</li>
<li>使用 DMA 驱动 I/O</li>
</ul>
<h2 id="I-O-层次结构"><a href="#I-O-层次结构" class="headerlink" title="I/O 层次结构"></a>I/O 层次结构</h2><p>I/O 软件通常组织成四个层次，它们的大致结构如下图所示</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830546-fa05a772-fc02-4957-ba1d-1e5a82d78de2.png#align=left&amp;display=inline&amp;height=372&amp;margin=%5Bobject%20Object%5D&amp;originHeight=372&amp;originWidth=733&amp;size=0&amp;status=done&amp;style=none&amp;width=733" alt></p>
<p>下面我们具体的来探讨一下上面的层次结构</p>
<h3 id="中断处理程序"><a href="#中断处理程序" class="headerlink" title="中断处理程序"></a>中断处理程序</h3><p>在计算机系统中，中断就像女人的脾气一样无时无刻都在产生，中断的出现往往是让人很不爽的。中断处理程序又被称为<code>中断服务程序</code> 或者是 <code>ISR(Interrupt Service Routines)</code>，它是最靠近硬件的一层。中断处理程序由硬件中断、软件中断或者是软件异常启动产生的中断，用于实现设备驱动程序或受保护的操作模式（例如系统调用）之间的转换。</p>
<p>中断处理程序负责处理中断发生时的所有操作，操作完成后阻塞，然后启动中断驱动程序来解决阻塞。通常会有三种通知方式，依赖于不同的具体实现</p>
<ul>
<li>信号量实现中：在信号量上使用 <code>up</code> 进行通知；</li>
<li>管程实现：对管程中的条件变量执行 <code>signal</code> 操作</li>
<li>还有一些情况是发送一些消息</li>
</ul>
<h3 id="设备驱动程序"><a href="#设备驱动程序" class="headerlink" title="设备驱动程序"></a>设备驱动程序</h3><p>每个连接到计算机的 I/O 设备都需要有某些特定设备的代码对其进行控制。这些提供 I/O 设备到设备控制器转换的过程的代码称为 <code>设备驱动程序(Device driver)</code>。</p>
<p>设备控制器的主要功能有下面这些</p>
<ul>
<li>接收和识别命令：设备控制器可以接受来自 CPU 的指令，并进行识别。设备控制器内部也会有寄存器，用来存放指令和参数</li>
<li>进行数据交换：CPU、控制器和设备之间会进行数据的交换，CPU 通过总线把指令发送给控制器，或从控制器中并行地读出数据；控制器将数据写入指定设备。</li>
<li>地址识别：每个硬件设备都有自己的地址，设备控制器能够识别这些不同的地址，来达到控制硬件的目的，此外，为使 CPU 能向寄存器中写入或者读取数据，这些寄存器都应具有唯一的地址。</li>
<li>差错检测：设备控制器还具有对设备传递过来的数据进行检测的功能。</li>
</ul>
<p>在这种情况下，设备控制器会阻塞，直到中断来解除阻塞状态。还有一种情况是操作是可以无延迟的完成，所以驱动程序不需要阻塞。在第一种情况下，操作系统可能被中断唤醒；第二种情况下操作系统不会被休眠。</p>
<p>设备驱动程序必须是<code>可重入</code>的，因为设备驱动程序会阻塞和唤醒然后再次阻塞。驱动程序不允许进行系统调用，但是它们通常需要与内核的其余部分进行交互。</p>
<h3 id="与设备无关的-I-O-软件"><a href="#与设备无关的-I-O-软件" class="headerlink" title="与设备无关的 I/O 软件"></a>与设备无关的 I/O 软件</h3><p>I/O 软件有两种，一种是我们上面介绍过的基于特定设备的，还有一种是<code>设备无关性</code>的，设备无关性也就是不需要特定的设备。设备驱动程序与设备无关的软件之间的界限取决于具体的系统。下面显示的功能由设备无关的软件实现</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830586-059b4da8-ea81-4a5a-b884-3377ca39d976.png#align=left&amp;display=inline&amp;height=331&amp;margin=%5Bobject%20Object%5D&amp;originHeight=331&amp;originWidth=428&amp;size=0&amp;status=done&amp;style=none&amp;width=428" alt></p>
<p>与设备无关的软件的基本功能是对所有设备执行公共的 I/O 功能，并且向用户层软件提供一个统一的接口。</p>
<h4 id="缓冲-1"><a href="#缓冲-1" class="headerlink" title="缓冲"></a>缓冲</h4><p>无论是对于块设备还是字符设备来说，缓冲都是一个非常重要的考量标准。缓冲技术应用广泛，但它也有缺点。如果数据被缓冲次数太多，会影响性能。</p>
<h4 id="错误处理-1"><a href="#错误处理-1" class="headerlink" title="错误处理"></a>错误处理</h4><p>在 I/O 中，出错是一种再正常不过的情况了。当出错发生时，操作系统必须尽可能处理这些错误。有一些错误是只有特定的设备才能处理，有一些是由框架进行处理，这些错误和特定的设备无关。</p>
<p>I/O 错误的一类是程序员<code>编程</code>错误，比如还没有打开文件前就读流，或者不关闭流导致内存溢出等等。这类问题由程序员处理；另外一类是实际的 I/O 错误，例如向一个磁盘坏块写入数据，无论怎么写都写入不了。这类问题由驱动程序处理，驱动程序处理不了交给硬件处理，这个我们上面也说过。</p>
<h4 id="设备驱动程序统一接口"><a href="#设备驱动程序统一接口" class="headerlink" title="设备驱动程序统一接口"></a>设备驱动程序统一接口</h4><p>我们在操作系统概述中说到，操作系统一个非常重要的功能就是屏蔽了硬件和软件的差异性，为硬件和软件提供了统一的标准，这个标准还体现在为设备驱动程序提供统一的接口，因为不同的硬件和厂商编写的设备驱动程序不同，所以如果为每个驱动程序都单独提供接口的话，这样没法搞，所以必须统一。</p>
<h4 id="分配和释放"><a href="#分配和释放" class="headerlink" title="分配和释放"></a>分配和释放</h4><p>一些设备例如打印机，它只能由一个进程来使用，这就需要操作系统根据实际情况判断是否能够对设备的请求进行检查，判断是否能够接受其他请求，一种比较简单直接的方式是在特殊文件上执行 <code>open</code>操作。如果设备不可用，那么直接 open 会导致失败。还有一种方式是不直接导致失败，而是让其阻塞，等到另外一个进程释放资源后，在进行 open 打开操作。这种方式就把选择权交给了用户，由用户判断是否应该等待。</p>
<h4 id="设备无关的块"><a href="#设备无关的块" class="headerlink" title="设备无关的块"></a>设备无关的块</h4><p>不同的磁盘会具有不同的扇区大小，但是软件不会关心扇区大小，只管存储就是了。一些字符设备可以一次一个字节的交付数据，而其他的设备则以较大的单位交付数据，这些差异也可以隐藏起来。</p>
<h3 id="用户空间的-I-O-软件"><a href="#用户空间的-I-O-软件" class="headerlink" title="用户空间的 I/O 软件"></a>用户空间的 I/O 软件</h3><p>虽然大部分 I/O 软件都在内核结构中，但是还有一些在用户空间实现的 I/O 软件，凡事没有绝对。一些 I/O 软件和库过程在用户空间存在，然后以提供系统调用的方式实现。</p>
<h2 id="盘"><a href="#盘" class="headerlink" title="盘"></a>盘</h2><p>盘可以说是硬件里面比较简单的构造了，同时也是最重要的。下面我们从盘谈起，聊聊它的物理构造</p>
<h3 id="盘硬件"><a href="#盘硬件" class="headerlink" title="盘硬件"></a>盘硬件</h3><p>盘会有很多种类型。其中最简单的构造就是<code>磁盘(magnetic hard disks)</code>， 也被称为 <code>hard disk,HDD</code>等。磁盘通常与安装在磁臂上的磁头配对，磁头可将数据读取或者将数据写入磁盘，因此磁盘的读写速度都同样快。在磁盘中，数据是随机访问的，这也就说明可以通过任意的顺序来<code>存储</code>和<code>检索</code>单个数据块，所以你可以在任意位置放置磁盘来让磁头读取，磁盘是一种<code>非易失性</code>的设备，即使断电也能永久保留。</p>
<h4 id="磁盘"><a href="#磁盘" class="headerlink" title="磁盘"></a>磁盘</h4><p>为了组织和检索数据，会将磁盘组织成特定的结构，这些特定的结构就是<strong>磁道、扇区和柱面</strong></p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830596-8b2a7f11-b5c9-4a00-b0c9-436889b099a8.png#align=left&amp;display=inline&amp;height=448&amp;margin=%5Bobject%20Object%5D&amp;originHeight=448&amp;originWidth=498&amp;size=0&amp;status=done&amp;style=none&amp;width=498" alt></p>
<p>磁盘被组织成柱面形式，每个盘用轴相连，每一个柱面包含若干磁道，每个磁道由若干扇区组成。软盘上大约每个磁道有 8 - 32 个扇区，硬盘上每条磁道上扇区的数量可达几百个，磁头大约是 1 - 16 个。</p>
<p>对于磁盘驱动程序来说，一个非常重要的特性就是控制器是否能够同时控制两个或者多个驱动器进行磁道寻址，这就是<code>重叠寻道(overlapped seek)</code>。对于控制器来说，它能够控制一个磁盘驱动程序完成寻道操作，同时让其他驱动程序等待寻道结束。控制器也可以在一个驱动程序上进行读写草哦做，与此同时让另外的驱动器进行寻道操作，但是软盘控制器不能在两个驱动器上进行读写操作。</p>
<h4 id="RAID"><a href="#RAID" class="headerlink" title="RAID"></a>RAID</h4><p>RAID 称为 <code>磁盘冗余阵列</code>，简称 <code>磁盘阵列</code>。利用虚拟化技术把多个硬盘结合在一起，成为一个或多个磁盘阵列组，目的是提升性能或数据冗余。</p>
<p>RAID 有不同的级别</p>
<ul>
<li>RAID 0 - 无容错的条带化磁盘阵列</li>
<li>RAID 1 - 镜像和双工</li>
<li>RAID 2 - 内存式纠错码</li>
<li>RAID 3 - 比特交错奇偶校验</li>
<li>RAID 4 - 块交错奇偶校验</li>
<li>RAID 5 - 块交错分布式奇偶校验</li>
<li>RAID 6 - P + Q 冗余</li>
</ul>
<h4 id="磁盘格式化"><a href="#磁盘格式化" class="headerlink" title="磁盘格式化"></a>磁盘格式化</h4><p>磁盘由一堆铝的、合金或玻璃的盘片组成，磁盘刚被创建出来后，没有任何信息。磁盘在使用前必须经过<code>低级格式化(low-levvel format)</code>，下面是一个扇区的格式</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830611-1b106d56-fbdb-4e79-b2b5-e5bd2778a387.png#align=left&amp;display=inline&amp;height=86&amp;margin=%5Bobject%20Object%5D&amp;originHeight=86&amp;originWidth=638&amp;size=0&amp;status=done&amp;style=none&amp;width=638" alt></p>
<p>前导码相当于是标示扇区的开始位置，通常以位模式开始，前导码还包括<code>柱面号</code>、<code>扇区号</code>等一些其他信息。紧随前导码后面的是数据区，数据部分的大小由低级格式化程序来确定。大部分磁盘使用 512 字节的扇区。数据区后面是 ECC，ECC 的全称是 <strong>error correction code</strong> ，<code>数据纠错码</code>，它与普通的错误检测不同，ECC 还可以用于恢复读错误。ECC 阶段的大小由不同的磁盘制造商实现。ECC 大小的设计标准取决于<strong>设计者愿意牺牲多少磁盘空间来提高可靠性</strong>，以及程序可以处理的 ECC 的复杂程度。通常情况下 ECC 是 16 位，除此之外，硬盘一般具有一定数量的备用扇区，用于替换制造缺陷的扇区。</p>
<h3 id="磁盘臂调度算法"><a href="#磁盘臂调度算法" class="headerlink" title="磁盘臂调度算法"></a>磁盘臂调度算法</h3><p>下面我们来探讨一下关于影响磁盘读写的算法，一般情况下，影响磁盘快读写的时间由下面几个因素决定</p>
<ul>
<li>寻道时间 - 寻道时间指的就是将磁盘臂移动到需要读取磁盘块上的时间</li>
<li>旋转延迟 - 等待合适的扇区旋转到磁头下所需的时间</li>
<li>实际数据的读取或者写入时间</li>
</ul>
<p>这三种时间参数也是磁盘寻道的过程。一般情况下，寻道时间对总时间的影响最大，所以，有效的降低寻道时间能够提高磁盘的读取速度。</p>
<p>如果磁盘驱动程序每次接收一个请求并按照接收顺序完成请求，这种处理方式也就是 <code>先来先服务(First-Come, First-served, FCFS)</code> ，这种方式很难优化寻道时间。因为每次都会按照顺序处理，不管顺序如何，有可能这次读完后需要等待一个磁盘旋转一周才能继续读取，而其他柱面能够马上进行读取，这种情况下每次请求也会排队。</p>
<p>通常情况下，磁盘在进行寻道时，其他进程会产生其他的磁盘请求。磁盘驱动程序会维护一张表，表中会记录着柱面号当作索引，每个柱面未完成的请求会形成链表，链表头存放在表的相应表项中。</p>
<p>一种对先来先服务的算法改良的方案是使用 <code>最短路径优先(SSF)</code> 算法，下面描述了这个算法。</p>
<p>假如我们在对磁道 6 号进行寻址时，同时发生了对 11 , 2 , 4, 14, 8, 15, 3 的请求，如果采用先来先服务的原则，如下图所示</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830646-2dfee703-9a35-47c9-880c-2c620d64464a.png#align=left&amp;display=inline&amp;height=427&amp;margin=%5Bobject%20Object%5D&amp;originHeight=427&amp;originWidth=762&amp;size=0&amp;status=done&amp;style=none&amp;width=762" alt></p>
<p>我们可以计算一下磁盘臂所跨越的磁盘数量为 5 + 9 + 2 + 10 + 6 + 7 + 12 = 51，相当于是跨越了 51 次盘面，如果使用最短路径优先，我们来计算一下跨越的盘面</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830629-e3cda6d4-2317-438b-a377-9e5dc5a3a802.png#align=left&amp;display=inline&amp;height=381&amp;margin=%5Bobject%20Object%5D&amp;originHeight=381&amp;originWidth=709&amp;size=0&amp;status=done&amp;style=none&amp;width=709" alt></p>
<p>跨越的磁盘数量为 4 + 1 + 1 + 4 + 3 + 3 + 1 = 17 ，相比 51 足足省了两倍的时间。</p>
<p>但是，最短路径优先的算法也不是完美无缺的，这种算法照样存在问题，那就是<code>优先级</code> 问题，</p>
<p>这里有一个原型可以参考就是我们日常生活中的电梯，电梯使用一种<code>电梯算法(elevator algorithm)</code> 来进行调度，从而满足协调效率和公平性这两个相互冲突的目标。电梯一般会保持向一个方向移动，直到在那个方向上没有请求为止，然后改变方向。</p>
<p>电梯算法需要维护一个<code>二进制位</code>，也就是当前的方向位：<code>UP(向上)</code>或者是 <code>DOWN(向下)</code>。当一个请求处理完成后，磁盘或电梯的驱动程序会检查该位，如果此位是 UP 位，磁盘臂或者电梯仓移到下一个更高跌未完成的请求。如果高位没有未完成的请求，则取相反方向。当方向位是 <code>DOWN</code> 时，同时存在一个低位的请求，磁盘臂会转向该点。如果不存在的话，那么它只是停止并等待。</p>
<p>我们举个例子来描述一下电梯算法，比如各个柱面得到服务的顺序是 4，7，10，14，9，6，3，1 ，那么它的流程图如下</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830648-6e8afe9c-f2fd-4c64-8db9-7f68930d0a27.png#align=left&amp;display=inline&amp;height=425&amp;margin=%5Bobject%20Object%5D&amp;originHeight=425&amp;originWidth=710&amp;size=0&amp;status=done&amp;style=none&amp;width=710" alt></p>
<p>所以电梯算法需要跨越的盘面数量是 3 + 3 + 4 + 5 + 3 + 3 + 1 = 22</p>
<p>电梯算法通常情况下不如 SSF 算法。</p>
<h3 id="错误处理-2"><a href="#错误处理-2" class="headerlink" title="错误处理"></a>错误处理</h3><p>一般坏块有两种处理办法，一种是在控制器中进行处理；一种是在操作系统层面进行处理。</p>
<p>这两种方法经常替换使用，比如一个具有 30 个数据扇区和两个备用扇区的磁盘，其中扇区 4 是有瑕疵的。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830690-4489f1b3-d4a8-49d6-bd29-1becb143d418.png#align=left&amp;display=inline&amp;height=367&amp;margin=%5Bobject%20Object%5D&amp;originHeight=367&amp;originWidth=423&amp;size=0&amp;status=done&amp;style=none&amp;width=423" alt></p>
<p>控制器能做的事情就是将备用扇区之一重新映射。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830735-2f51c8ae-a37f-4673-9781-a2519263c63f.png#align=left&amp;display=inline&amp;height=464&amp;margin=%5Bobject%20Object%5D&amp;originHeight=464&amp;originWidth=500&amp;size=0&amp;status=done&amp;style=none&amp;width=500" alt></p>
<p>还有一种处理方式是将所有的扇区都向上移动一个扇区</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830717-1dc1be76-6eff-4891-8d89-843a7110e6a8.png#align=left&amp;display=inline&amp;height=460&amp;margin=%5Bobject%20Object%5D&amp;originHeight=460&amp;originWidth=497&amp;size=0&amp;status=done&amp;style=none&amp;width=497" alt></p>
<p>上面这这两种情况下控制器都必须知道哪个扇区，可以通过内部的表来跟踪这一信息，或者通过重写前导码来给出重新映射的扇区号。如果是重写前导码，那么涉及移动的方式必须重写后面所有的前导码，但是最终会提供良好的性能。</p>
<h3 id="稳定存储器"><a href="#稳定存储器" class="headerlink" title="稳定存储器"></a>稳定存储器</h3><p>磁盘经常会出现错误，导致好的扇区会变成坏扇区，驱动程序也有可能挂掉。RAID 可以对扇区出错或者是驱动器崩溃提出保护，然而 RAID 却不能对坏数据中的写错误提供保护，也不能对写操作期间的崩溃提供保护，这样就会破坏原始数据。</p>
<p>我们期望磁盘能够准确无误的工作，但是事实情况是不可能的，但是我们能够知道的是，一个磁盘子系统具有如下特性：当一个写命令发给它时，磁盘要么正确地写数据，要么什么也不做，让现有的数据完整无误的保留。这样的系统称为 <code>稳定存储器(stable storage)</code>。 稳定存储器的目标就是不惜一切代价保证磁盘的一致性。</p>
<p>稳定存储器使用两个一对相同的磁盘，对应的块一同工作形成一个无差别的块。稳定存储器为了实现这个目的，定义了下面三种操作：</p>
<ul>
<li><code>稳定写(stable write)</code></li>
<li><code>稳定读(stable read)</code></li>
<li><code>崩溃恢复(crash recovery)</code></li>
</ul>
<h2 id="时钟"><a href="#时钟" class="headerlink" title="时钟"></a>时钟</h2><p><code>时钟(Clocks)</code> 也被称为<code>定时器(timers)</code>，时钟/定时器对任何程序系统来说都是必不可少的。时钟负责维护时间、防止一个进程长期占用 CPU 时间等其他功能。<code>时钟软件(clock software)</code> 也是一种设备驱动的方式。下面我们就来对时钟进行介绍，一般都是先讨论硬件再介绍软件，采用由下到上的方式，也是告诉你，底层是最重要的。</p>
<h3 id="时钟硬件"><a href="#时钟硬件" class="headerlink" title="时钟硬件"></a>时钟硬件</h3><p>在计算机中有两种类型的时钟，这些时钟与现实生活中使用的时钟完全不一样。</p>
<ul>
<li>比较简单的一种时钟被连接到 110 V 或 220 V 的电源线上，这样每个<code>电压周期</code>会产生一个中断，大概是 50 - 60 HZ。这些时钟过去一直占据支配地位。</li>
<li>另外的一种时钟由晶体振荡器、计数器和寄存器组成，示意图如下所示</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830741-6daaaf06-0552-44b1-bf19-85729fd25288.png#align=left&amp;display=inline&amp;height=503&amp;margin=%5Bobject%20Object%5D&amp;originHeight=503&amp;originWidth=627&amp;size=0&amp;status=done&amp;style=none&amp;width=627" alt></p>
<p>这种时钟称为<code>可编程时钟</code> ，可编程时钟有两种模式，一种是 <code>一键式(one-shot mode)</code>，当时钟启动时，会把存储器中的值复制到计数器中，然后，每次晶体的振荡器的脉冲都会使计数器 -1。当计数器变为 0 时，会产生一个中断，并停止工作，直到软件再一次显示启动。还有一种模式时 <code>方波(square-wave mode)</code> 模式，在这种模式下，当计数器变为 0 并产生中断后，存储寄存器的值会自动复制到计数器中，这种周期性的中断称为一个时钟周期。</p>
<h3 id="时钟软件"><a href="#时钟软件" class="headerlink" title="时钟软件"></a>时钟软件</h3><p>时钟硬件所做的工作只是根据已知的时间间隔产生中断，而其他的工作都是由<code>时钟软件</code>来完成，一般操作系统的不同，时钟软件的具体实现也不同，但是一般都会包括以下这几点</p>
<ul>
<li>维护一天的时间</li>
<li>阻止进程运行的时间超过其指定时间</li>
<li>统计 CPU 的使用情况</li>
<li>处理用户进程的警告系统调用</li>
<li>为系统各个部分提供看门狗定时器</li>
<li>完成概要剖析，监视和信息收集</li>
</ul>
<h3 id="软定时器"><a href="#软定时器" class="headerlink" title="软定时器"></a>软定时器</h3><p>时钟软件也被称为可编程时钟，可以设置它以程序需要的任何速率引发中断。时钟软件触发的中断是一种硬中断，但是某些应用程序对于硬中断来说是不可接受的。</p>
<p>这时候就需要一种<code>软定时器(soft timer)</code> 避免了中断，无论何时当内核因为某种原因呢在运行时，它返回用户态之前都会检查时钟来了解软定时器是否到期。如果软定时器到期，则执行被调度的事件也无需切换到内核态，因为本身已经处于内核态中。这种方式避免了频繁的内核态和用户态之前的切换，提高了程序运行效率。</p>
<p>软定时器因为不同的原因切换进入内核态的速率不同，原因主要有</p>
<ul>
<li>系统调用</li>
<li>TLB 未命中</li>
<li>缺页异常</li>
<li>I/O 中断</li>
<li>CPU 变得空闲</li>
</ul>
<p>死锁问题也是操作系统非常重要的一类问题</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830748-305133ff-5324-4e46-b119-74609aedd401.png#align=left&amp;display=inline&amp;height=286&amp;margin=%5Bobject%20Object%5D&amp;originHeight=286&amp;originWidth=721&amp;size=0&amp;status=done&amp;style=none&amp;width=721" alt></p>
<h2 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h2><p>大部分的死锁都和资源有关，在进程对设备、文件具有独占性（排他性）时会产生死锁。我们把这类需要排他性使用的对象称为<code>资源(resource)</code>。资源主要分为 <strong>可抢占资源和不可抢占资源</strong></p>
<h3 id="可抢占资源和不可抢占资源"><a href="#可抢占资源和不可抢占资源" class="headerlink" title="可抢占资源和不可抢占资源"></a>可抢占资源和不可抢占资源</h3><p>资源主要有可抢占资源和不可抢占资源。<code>可抢占资源(preemptable resource)</code> 可以从拥有它的进程中抢占而不会造成其他影响，内存就是一种可抢占性资源，任何进程都能够抢先获得内存的使用权。</p>
<p><code>不可抢占资源(nonpreemtable resource)</code> 指的是除非引起错误或者异常，否则进程无法抢占指定资源，这种不可抢占的资源比如有光盘，在进程执行调度的过程中，其他进程是不能得到该资源的。</p>
<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>如果要对死锁进行一个定义的话，下面的定义比较贴切</p>
<p><strong>如果一组进程中的每个进程都在等待一个事件，而这个事件只能由该组中的另一个进程触发，这种情况会导致死锁</strong>。</p>
<h3 id="资源死锁的条件"><a href="#资源死锁的条件" class="headerlink" title="资源死锁的条件"></a>资源死锁的条件</h3><p>针对我们上面的描述，资源死锁可能出现的情况主要有</p>
<ul>
<li>互斥条件：每个资源都被分配给了一个进程或者资源是可用的</li>
<li>保持和等待条件：已经获取资源的进程被认为能够获取新的资源</li>
<li>不可抢占条件：分配给一个进程的资源不能强制的从其他进程抢占资源，它只能由占有它的进程显示释放</li>
<li>循环等待：死锁发生时，系统中一定有两个或者两个以上的进程组成一个循环，循环中的每个进程都在等待下一个进程释放的资源。</li>
</ul>
<p>发生死锁时，上面的情况必须同时会发生。如果其中任意一个条件不会成立，死锁就不会发生。可以通过破坏其中任意一个条件来破坏死锁，下面这些破坏条件就是我们探讨的重点</p>
<h3 id="死锁模型"><a href="#死锁模型" class="headerlink" title="死锁模型"></a>死锁模型</h3><p>Holt 在 1972 年提出对死锁进行建模，建模的标准如下：</p>
<ul>
<li>圆形表示进程</li>
<li>方形表示资源</li>
</ul>
<p>从资源节点到进程节点表示资源已经被进程占用，如下图所示</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830760-e22f0a74-94ab-4be7-9b39-3f611c32823a.png#align=left&amp;display=inline&amp;height=352&amp;margin=%5Bobject%20Object%5D&amp;originHeight=352&amp;originWidth=331&amp;size=0&amp;status=done&amp;style=none&amp;width=331" alt></p>
<p>在上图中表示当前资源 R 正在被 A 进程所占用</p>
<p>由进程节点到资源节点的有向图表示当前进程正在请求资源，并且该进程已经被阻塞，处于等待这个资源的状态</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830813-2b57251b-055b-4664-b040-89f60d1d43c4.png#align=left&amp;display=inline&amp;height=363&amp;margin=%5Bobject%20Object%5D&amp;originHeight=363&amp;originWidth=345&amp;size=0&amp;status=done&amp;style=none&amp;width=345" alt></p>
<p>在上图中，表示的含义是进程 B 正在请求资源 S 。Holt 认为，死锁的描述应该如下</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830811-a3afe75e-0c48-40b9-8fa4-e74d132d9b58.png#align=left&amp;display=inline&amp;height=381&amp;margin=%5Bobject%20Object%5D&amp;originHeight=381&amp;originWidth=485&amp;size=0&amp;status=done&amp;style=none&amp;width=485" alt></p>
<p>这是一个死锁的过程，进程 C 等待资源 T 的释放，资源 T 却已经被进程 D 占用，进程 D 等待请求占用资源 U ，资源 U 却已经被线程 C 占用，从而形成环。</p>
<p>有四种处理死锁的策略：</p>
<ul>
<li>忽略死锁带来的影响（惊呆了）</li>
<li>检测死锁并回复死锁，死锁发生时对其进行检测，一旦发生死锁后，采取行动解决问题</li>
<li>通过仔细分配资源来避免死锁</li>
<li>通过破坏死锁产生的四个条件之一来避免死锁</li>
</ul>
<p>下面我们分别介绍一下这四种方法</p>
<h2 id="鸵鸟算法"><a href="#鸵鸟算法" class="headerlink" title="鸵鸟算法"></a>鸵鸟算法</h2><p>最简单的解决办法就是使用<code>鸵鸟算法(ostrich algorithm)</code>，把头埋在沙子里，假装问题根本没有发生。每个人看待这个问题的反应都不同。数学家认为死锁是不可接受的，必须通过有效的策略来防止死锁的产生。工程师想要知道问题发生的频次，系统因为其他原因崩溃的次数和死锁带来的严重后果。如果死锁发生的频次很低，而经常会由于硬件故障、编译器错误等其他操作系统问题导致系统崩溃，那么大多数工程师不会修复死锁。</p>
<h2 id="死锁检测和恢复"><a href="#死锁检测和恢复" class="headerlink" title="死锁检测和恢复"></a>死锁检测和恢复</h2><p>第二种技术是死锁的检测和恢复。这种解决方式不会尝试去阻止死锁的出现。相反，这种解决方案会希望死锁尽可能的出现，在监测到死锁出现后，对其进行恢复。下面我们就来探讨一下死锁的检测和恢复的几种方式</p>
<h3 id="每种类型一个资源的死锁检测方式"><a href="#每种类型一个资源的死锁检测方式" class="headerlink" title="每种类型一个资源的死锁检测方式"></a>每种类型一个资源的死锁检测方式</h3><p>每种资源类型都有一个资源是什么意思？我们经常提到的打印机就是这样的，资源只有打印机，但是设备都不会超过一个。</p>
<p>可以通过构造一张资源分配表来检测这种错误，比如我们上面提到的</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830848-f4bc59e7-89e2-4e78-909c-e8dcd1718ebe.png#align=left&amp;display=inline&amp;height=381&amp;margin=%5Bobject%20Object%5D&amp;originHeight=381&amp;originWidth=475&amp;size=0&amp;status=done&amp;style=none&amp;width=475" alt></p>
<p>如果这张图包含了一个或一个以上的环，那么死锁就存在，处于这个环中任意一个进程都是死锁的进程。</p>
<h3 id="每种类型多个资源的死锁检测方式"><a href="#每种类型多个资源的死锁检测方式" class="headerlink" title="每种类型多个资源的死锁检测方式"></a>每种类型多个资源的死锁检测方式</h3><p>如果有多种相同的资源存在，就需要采用另一种方法来检测死锁。可以通过构造一个矩阵来检测从 P1 -&gt; Pn 这 n 个进程中的死锁。</p>
<p>现在我们提供一种基于矩阵的算法来检测从 P1 到 Pn 这 n 个进程中的死锁。假设资源类型为 m，E1 代表资源类型 1，E2 表示资源类型 2 ，Ei 代表资源类型 i (1 &lt;= i &lt;= m)。E 表示的是 <code>现有资源向量(existing resource vector)</code>，代表每种已存在的资源总数。</p>
<p>现在我们就需要构造两个数组：C 表示的是<code>当前分配矩阵(current allocation matrix)</code> ，R 表示的是 <code>请求矩阵(request matrix)</code>。Ci 表示的是 Pi 持有每一种类型资源的资源数。所以，Cij 表示 Pi 持有资源 j 的数量。Rij 表示 Pi 所需要获得的资源 j 的数量</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830847-d4f0a077-7abd-4507-a720-337bc99b121e.png#align=left&amp;display=inline&amp;height=302&amp;margin=%5Bobject%20Object%5D&amp;originHeight=302&amp;originWidth=686&amp;size=0&amp;status=done&amp;style=none&amp;width=686" alt></p>
<p>一般来说，已分配资源 j 的数量加起来再和所有可供使用的资源数相加 = 该类资源的总数。</p>
<p>死锁的检测就是基于向量的比较。每个进程起初都是没有被标记过的，算法会开始对进程做标记，进程被标记后说明进程被执行了，不会进入死锁，当算法结束时，任何没有被标记过的进程都会被判定为死锁进程。</p>
<p>上面我们探讨了两种检测死锁的方式，那么现在你知道怎么检测后，你何时去做死锁检测呢？一般来说，有两个考量标准：</p>
<ul>
<li>每当有资源请求时就去检测，这种方式会占用昂贵的 CPU 时间。</li>
<li>每隔 k 分钟检测一次，或者当 CPU 使用率降低到某个标准下去检测。考虑到 CPU 效率的原因，如果死锁进程达到一定数量，就没有多少进程可以运行，所以 CPU 会经常空闲。</li>
</ul>
<h3 id="从死锁中恢复"><a href="#从死锁中恢复" class="headerlink" title="从死锁中恢复"></a>从死锁中恢复</h3><p>上面我们探讨了如何检测进程死锁，我们最终的目的肯定是想让程序能够正常的运行下去，所以针对检测出来的死锁，我们要对其进行恢复，下面我们会探讨几种死锁的恢复方式</p>
<h4 id="通过抢占进行恢复"><a href="#通过抢占进行恢复" class="headerlink" title="通过抢占进行恢复"></a>通过抢占进行恢复</h4><p>在某些情况下，可能会临时将某个资源从它的持有者转移到另一个进程。比如在不通知原进程的情况下，将某个资源从进程中强制取走给其他进程使用，使用完后又送回。这种恢复方式一般比较困难而且有些简单粗暴，并不可取。</p>
<h4 id="通过回滚进行恢复"><a href="#通过回滚进行恢复" class="headerlink" title="通过回滚进行恢复"></a>通过回滚进行恢复</h4><p>如果系统设计者和机器操作员知道有可能发生死锁，那么就可以定期检查流程。进程的检测点意味着进程的状态可以被写入到文件以便后面进行恢复。检测点不仅包含<code>存储映像(memory image)</code>，还包含<code>资源状态(resource state)</code>。一种更有效的解决方式是不要覆盖原有的检测点，而是每出现一个检测点都要把它写入到文件中，这样当进程执行时，就会有一系列的检查点文件被累积起来。</p>
<p>为了进行恢复，要从上一个较早的检查点上开始，这样所需要资源的进程会回滚到上一个时间点，在这个时间点上，死锁进程还没有获取所需要的资源，可以在此时对其进行资源分配。</p>
<h4 id="杀死进程恢复"><a href="#杀死进程恢复" class="headerlink" title="杀死进程恢复"></a>杀死进程恢复</h4><p>最简单有效的解决方案是直接杀死一个死锁进程。但是杀死一个进程可能照样行不通，这时候就需要杀死别的资源进行恢复。</p>
<p>另外一种方式是选择一个环外的进程作为牺牲品来释放进程资源。</p>
<h2 id="死锁避免"><a href="#死锁避免" class="headerlink" title="死锁避免"></a>死锁避免</h2><p>我们上面讨论的是如何检测出现死锁和如何恢复死锁，下面我们探讨几种规避死锁的方式</p>
<h3 id="单个资源的银行家算法"><a href="#单个资源的银行家算法" class="headerlink" title="单个资源的银行家算法"></a>单个资源的银行家算法</h3><p>银行家算法是 Dijkstra 在 1965 年提出的一种调度算法，它本身是一种死锁的调度算法。它的模型是基于一个城镇中的银行家，银行家向城镇中的客户承诺了一定数量的贷款额度。算法要做的就是判断请求是否会进入一种不安全的状态。如果是，就拒绝请求，如果请求后系统是安全的，就接受该请求。</p>
<p>类似的，还有多个资源的银行家算法，读者可以自行了解。</p>
<h2 id="破坏死锁"><a href="#破坏死锁" class="headerlink" title="破坏死锁"></a>破坏死锁</h2><p>死锁本质上是无法避免的，因为它需要获得未知的资源和请求，但是死锁是满足四个条件后才出现的，它们分别是</p>
<ul>
<li>互斥</li>
<li>保持和等待</li>
<li>不可抢占</li>
<li>循环等待</li>
</ul>
<p>我们分别对这四个条件进行讨论，按理说破坏其中的任意一个条件就能够破坏死锁</p>
<h3 id="破坏互斥条件"><a href="#破坏互斥条件" class="headerlink" title="破坏互斥条件"></a>破坏互斥条件</h3><p>我们首先考虑的就是<strong>破坏互斥使用条件</strong>。如果资源不被一个进程独占，那么死锁肯定不会产生。如果两个打印机同时使用一个资源会造成混乱，打印机的解决方式是使用 <code>假脱机打印机(spooling printer)</code> ，这项技术可以允许多个进程同时产生输出，在这种模型中，实际请求打印机的唯一进程是打印机守护进程，也称为后台进程。后台进程不会请求其他资源。我们可以消除打印机的死锁。</p>
<p>后台进程通常被编写为能够输出完整的文件后才能打印，假如两个进程都占用了假脱机空间的一半，而这两个进程都没有完成全部的输出，就会导致死锁。</p>
<p>因此，尽量做到尽可能少的进程可以请求资源。</p>
<h3 id="破坏保持等待的条件"><a href="#破坏保持等待的条件" class="headerlink" title="破坏保持等待的条件"></a>破坏保持等待的条件</h3><p>第二种方式是如果我们能阻止持有资源的进程请求其他资源，我们就能够消除死锁。一种实现方式是让所有的进程开始执行前请求全部的资源。如果所需的资源可用，进程会完成资源的分配并运行到结束。如果有任何一个资源处于频繁分配的情况，那么没有分配到资源的进程就会等待。</p>
<p>很多进程<strong>无法在执行完成前就知道到底需要多少资源</strong>，如果知道的话，就可以使用银行家算法；还有一个问题是这样<strong>无法合理有效利用资源</strong>。</p>
<p>还有一种方式是进程在请求其他资源时，先释放所占用的资源，然后再尝试一次获取全部的资源。</p>
<h3 id="破坏不可抢占条件"><a href="#破坏不可抢占条件" class="headerlink" title="破坏不可抢占条件"></a>破坏不可抢占条件</h3><p>破坏不可抢占条件也是可以的。可以通过虚拟化的方式来避免这种情况。</p>
<h3 id="破坏循环等待条件"><a href="#破坏循环等待条件" class="headerlink" title="破坏循环等待条件"></a>破坏循环等待条件</h3><p>现在就剩最后一个条件了，循环等待条件可以通过多种方法来破坏。一种方式是制定一个标准，一个进程在任何时候只能使用一种资源。如果需要另外一种资源，必须释放当前资源。对于需要将大文件从磁带复制到打印机的过程，此限制是不可接受的。</p>
<p>另一种方式是将所有的资源统一编号，如下图所示</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830860-d72b0344-264f-4bfe-91f7-43d5b4121f58.png#align=left&amp;display=inline&amp;height=268&amp;margin=%5Bobject%20Object%5D&amp;originHeight=268&amp;originWidth=419&amp;size=0&amp;status=done&amp;style=none&amp;width=419" alt></p>
<p>进程可以在任何时间提出请求，但是所有的请求都必须按照资源的顺序提出。如果按照此分配规则的话，那么资源分配之间不会出现环。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830858-19d66189-e808-4999-879e-3e2e8d4273f0.png#align=left&amp;display=inline&amp;height=281&amp;margin=%5Bobject%20Object%5D&amp;originHeight=281&amp;originWidth=423&amp;size=0&amp;status=done&amp;style=none&amp;width=423" alt></p>
<p>尽管通过这种方式来消除死锁，但是编号的顺序不可能让每个进程都会接受。</p>
<h2 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h2><p>下面我们来探讨一下其他问题，包括 <strong>通信死锁、活锁是什么、饥饿问题和两阶段加锁</strong></p>
<h3 id="两阶段加锁"><a href="#两阶段加锁" class="headerlink" title="两阶段加锁"></a>两阶段加锁</h3><p>虽然很多情况下死锁的避免和预防都能处理，但是效果并不好。随着时间的推移，提出了很多优秀的算法用来处理死锁。例如在数据库系统中，一个经常发生的操作是请求锁住一些记录，然后更新所有锁定的记录。当同时有多个进程运行时，就会有死锁的风险。</p>
<p>一种解决方式是使用 <code>两阶段提交(two-phase locking)</code>。顾名思义分为两个阶段，一阶段是进程尝试一次锁定它需要的所有记录。如果成功后，才会开始第二阶段，第二阶段是执行更新并释放锁。第一阶段并不做真正有意义的工作。</p>
<p>如果在第一阶段某个进程所需要的记录已经被加锁，那么该进程会释放所有锁定的记录并重新开始第一阶段。从某种意义上来说，这种方法类似于预先请求所有必需的资源或者是在进行一些不可逆的操作之前请求所有的资源。</p>
<p>不过在一般的应用场景中，两阶段加锁的策略并不通用。如果一个进程缺少资源就会半途中断并重新开始的方式是不可接受的。</p>
<h3 id="通信死锁"><a href="#通信死锁" class="headerlink" title="通信死锁"></a>通信死锁</h3><p>我们上面一直讨论的是资源死锁，资源死锁是一种死锁类型，但并不是唯一类型，还有通信死锁，也就是两个或多个进程在发送消息时出现的死锁。进程 A 给进程 B 发了一条消息，然后进程 A 阻塞直到进程 B 返回响应。假设请求消息丢失了，那么进程 A 在一直等着回复，进程 B 也会阻塞等待请求消息到来，这时候就产生<code>死锁</code>。</p>
<p>尽管会产生死锁，但是这并不是一个资源死锁，因为 A 并没有占据 B 的资源。事实上，通信死锁并没有完全可见的资源。根据死锁的定义来说：每个进程因为等待其他进程引起的事件而产生阻塞，这就是一种死锁。相较于最常见的通信死锁，我们把上面这种情况称为<code>通信死锁(communication deadlock)</code>。</p>
<p>通信死锁不能通过调度的方式来避免，但是可以使用通信中一个非常重要的概念来避免：<code>超时(timeout)</code>。在通信过程中，只要一个信息被发出后，发送者就会启动一个定时器，定时器会记录消息的超时时间，如果超时时间到了但是消息还没有返回，就会认为消息已经丢失并重新发送，通过这种方式，可以避免通信死锁。</p>
<p>但是并非所有网络通信发生的死锁都是通信死锁，也存在资源死锁，下面就是一个典型的资源死锁。</p>
<p>当一个数据包从主机进入路由器时，会被放入一个缓冲区，然后再传输到另外一个路由器，再到另一个，以此类推直到目的地。缓冲区都是资源并且数量有限。如下图所示，每个路由器都有 10 个缓冲区（实际上有很多）。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830887-98d92f9c-72d1-4710-a487-1bd4dc953b7c.png#align=left&amp;display=inline&amp;height=322&amp;margin=%5Bobject%20Object%5D&amp;originHeight=322&amp;originWidth=702&amp;size=0&amp;status=done&amp;style=none&amp;width=702" alt></p>
<p>假如路由器 A 的所有数据需要发送到 B ，B 的所有数据包需要发送到 D，然后 D 的所有数据包需要发送到 A 。没有数据包可以移动，因为在另一端没有缓冲区可用，这就是一个典型的资源死锁。</p>
<h3 id="活锁"><a href="#活锁" class="headerlink" title="活锁"></a>活锁</h3><p>某些情况下，当进程意识到它不能获取所需要的下一个锁时，就会尝试礼貌的释放已经获得的锁，然后等待非常短的时间再次尝试获取。可以想像一下这个场景：当两个人在狭路相逢的时候，都想给对方让路，相同的步调会导致双方都无法前进。</p>
<p>现在假想有一对并行的进程用到了两个资源。它们分别尝试获取另一个锁失败后，两个进程都会释放自己持有的锁，再次进行尝试，这个过程会一直进行重复。很明显，这个过程中没有进程阻塞，但是进程仍然不会向下执行，这种状况我们称之为 <code>活锁(livelock)</code>。</p>
<h3 id="饥饿"><a href="#饥饿" class="headerlink" title="饥饿"></a>饥饿</h3><p>与死锁和活锁的一个非常相似的问题是 <code>饥饿(starvvation)</code>。想象一下你什么时候会饿？一段时间不吃东西是不是会饿？对于进程来讲，最重要的就是资源，如果一段时间没有获得资源，那么进程会产生饥饿，这些进程会永远得不到服务。</p>
<p>我们假设打印机的分配方案是每次都会分配给最小文件的进程，那么要打印大文件的进程会永远得不到服务，导致进程饥饿，进程会无限制的推后，虽然它没有阻塞。</p>
]]></content>
      <categories>
        <category>计算机系统</category>
      </categories>
  </entry>
</search>
