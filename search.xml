<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>对平侠谈个人成长的一些感悟</title>
      <link href="essay/coeh8m/"/>
      <url>essay/coeh8m/</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1624096824333-d7a7a173-78ce-487b-8924-11e04875f913.png#height=1080&id=SJV2T&margin=%5Bobject%20Object%5D&name=Snipaste_2021-06-19_17-46-32.png&originHeight=1080&originWidth=1920&originalType=binary%E2%88%B6=1&size=1582632&status=done&style=none&width=1920" alt="Snipaste_2021-06-19_17-46-32.png"></p><p>前言：近期看到平侠作者发布的一篇文章『<a href="https://www.yuque.com/zenany/up/be_independent">从高效能人士的七个习惯谈成长</a>』，作者对个人成长精炼出来三个要素：心态、格局、魄力，对应《高效能人士的七个习惯》就是积极主动、以始为终、要事第一这三点。这三点算是对个人成长的比较好的概括了，总的来说，这篇文章对近期有些烦躁的自己算是重新点亮了一盏明灯。</p><hr><h2 id="积极主动的心态"><a href="#积极主动的心态" class="headerlink" title="积极主动的心态"></a>积极主动的心态</h2><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1624097233676-35f38d3c-7383-430a-9ca3-19551b956320.png#clientId=udc483ace-a964-4&from=paste&height=348&id=u5b8ae4a2&margin=%5Bobject%20Object%5D&name=Snipaste_2020-12-21_11-03-35.png&originHeight=1080&originWidth=1920&originalType=binary%E2%88%B6=2&size=1220501&status=done&style=none&taskId=ufae73ef0-8344-46dc-b1b0-d8a2bca7c0c&width=618.0208740234375" alt="Snipaste_2020-12-21_11-03-35.png"><br>作者说的这句话“<strong>接受无法改变的，改变有可能改变的</strong>”，我想应该是和李开复前辈的理念一样——“<strong>有勇气改变可以改变的，有胸怀接受不可改变的事情</strong>”，李开复其实后面还说道，“<strong>用智慧区分两者的不同</strong>”。其实说白了，就是对所处之境，所遇之事永远抱有一个乐观豁达的心态。</p><p>近期或然有些许同感，很多所有人都懂的道理，对一些人而言，由于性格的缘故，总要比别人接受的晚，再深点讲其实是内心不想接受罢了，抵触，就像是一个孩子被家长训话，就有些桀骜不驯的孩子，知道是这样的，知道这样是不对的，但就是愿意被性格被情绪所控制，但一旦懂得了并接受了这个所有人都懂的道理，成长加速度就会提升甚至赶超同龄人了，这或许就是成长吧。</p><blockquote><p>天下事，难易相成。在做事的过程中，有顺境，有逆境，难在始终保持积极主动的心态。<br>顺境：比较容易做到积极主动，但也容易产生懈怠，需要顺势而为，不可懈怠，快速扩大成果。<br>逆境：往往正是考验积极主动的时候，需要摆正心态，重塑信心，主动寻找改变的契机。</p></blockquote><p>作者这段话我觉得很不错，特别是对逆境的态度——始终坚持积极主动的心态。</p><p>积极主动的心态其实每个人或多或少都会，但是一直坚持的人，很少，也很难，但也正因是难，才要坚持不是么？（算是把自己好好教育了一番的感觉</p><p>三分钟不开刀无痛苦的历练，在这个文明制度下，不存在。</p><h2 id="以始为终的格局"><a href="#以始为终的格局" class="headerlink" title="以始为终的格局"></a>以始为终的格局</h2><p>换一个本人一直贯彻的学习方法中的一句话就是“以结果为导向”，以结果为导向的这种思维，在计算机专业里面特别好使，简单说明就是对于同一个技术，一个大作业比课堂上课一学期好使（我可没说我不好好听课<img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1624095112125-51056426-2c52-4bbf-9d7f-128cd1fac489.png#height=68&id=aZJCK&margin=%5Bobject%20Object%5D&name=1F18FB8EB4B76CFAC0B29A0A81E144E1.png&originHeight=68&originWidth=74&originalType=binary%E2%88%B6=1&size=6617&status=done&style=none&width=74" alt="1F18FB8EB4B76CFAC0B29A0A81E144E1.png">）<br>​</p><p>对于把这种思维转到职业规划与发展里面，亦是如此，划分阶段的话，就如作者的三步，确定终点——推演路径——制定计划。虽然我不太习惯制定这种人生抑或是职业计划，但不得不承认，这种方式是有效果的。<br>​</p><p>作者所推荐的他的师傅 <a href="https://www.zhihu.com/people/wuduoyi">nwind</a> 传授的 <a href="https://baike.baidu.com/item/%E9%A9%AC%E9%B9%A4%E5%87%8C/5566647">马鹤凌老先生</a> 的总结：<a href="https://github.com/zenany/zenany.github.io/blob/master/_posts/about_time_and_knowledge_management.md">此生理想、近期计划、今日功课</a>。仔细看了看，感觉也在强调计划的操作必要性。此刻，突然想到了兵长内心打算跟随团长的心理独白</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1624096040600-e72f1c6f-cd5e-4421-a75c-9e5e8ac3edb7.png#height=366&id=bwQJL&margin=%5Bobject%20Object%5D&name=Snipaste_2021-06-19_17-46-54.png&originHeight=1080&originWidth=1920&originalType=binary%E2%88%B6=1&size=1705432&status=done&style=none&width=650.9954223632812" alt="Snipaste_2021-06-19_17-46-54.png"><br>“<strong>好吧，我就跟着你好了，埃尔文·史密斯</strong>”<br>​</p><h2 id="要事第一的魄力"><a href="#要事第一的魄力" class="headerlink" title="要事第一的魄力"></a>要事第一的魄力</h2><p>作者想要表达的是“专注当下，取舍果断”。</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1624096754794-70a837ba-bd73-4a01-a20d-712bfe4266fe.png#height=355&id=Di3jA&margin=%5Bobject%20Object%5D&name=image.png&originHeight=430&originWidth=765&originalType=binary%E2%88%B6=1&size=661296&status=done&style=none&width=632" alt="image.png"></p><p>舍弃的精神，我觉得我有，作者所描述的今后我可能会遇到的工作方面，也有对职业的持续发展道路方面的，作者的三个问题值得记录：</p><blockquote><p>1、我能为团队和公司带来什么？<br>2、我从身边的人身上可以学到什么？<br>3、我真正想做的事是什么？</p></blockquote><p>时时刻刻想着这三个问题，其实结果还是比较显而易见的……</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>所有的职业终点都是NPC</title>
      <link href="essay/dpauku/"/>
      <url>essay/dpauku/</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1623929248579-c01331e1-d895-4f58-bf92-026465a16a65.png#clientId=u43e23ad8-c9db-4&from=paste&height=540&id=u7e92ea60&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1080&originWidth=1920&originalType=binary%E2%88%B6=2&size=3331025&status=done&style=none&taskId=ud8484b86-49fd-4d9c-b9b3-5f6812ef7c0&width=960" alt="image.png"></p><blockquote><p>非玩家角色或称非操控角色（英语：Non-Player Character，NPC），是指角色扮演游戏中非玩家控制的角色。<br>​</p></blockquote><blockquote><p>NPC 是游戏背景中，非主角（狭义上来说还要求非敌人）的陪衬人物。玩家借由他们与游戏互动。在桌上角色扮演游戏里，NPC 是由游戏主持者操纵，而在电脑角色扮演游戏里，则是由程序默认的剧本来决定 NPC 的反应，由游戏的人工智能做出控制。部分 NPC 有时可变成可操控角色<br>​</p></blockquote><blockquote><p>——维基百科</p></blockquote><p>​</p><p>如果将一个人人生的职业经历划分为两段，第一段就像是打怪升级的攻略者，而后一段我想就是 NPC 吧<br>​</p><p>现在的我就像是一个攻略者，利用对这个文明框架的种种，去攻略眼前的所有困难，但是，我似乎也看到了今后处在 NPC 角色的我……<br>​</p><p>如果把人生喻成一场游戏，那么我觉得人生的意义则是，<strong>用一颗勇敢的心，去攻略眼前的一个个困难</strong>。<br>​</p><p>​</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>文明框架下美好的事物是什么样的？</title>
      <link href="essay/logfxx/"/>
      <url>essay/logfxx/</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1623724816738-638c68c5-a58d-4855-a83f-8040d78aba26.jpeg#height=1080&id=AqhVV&originHeight=1080&originWidth=1440&originalType=binary%E2%88%B6=1&status=done&style=none&width=1440"></p><p>文明，历史的长久以往，让我们这个文明慢慢趋于一种某一方面而言的制度体系，或许对大多数人而言，这是一种常态，但对我而言，文明是框架。我并没有用束缚这个较为偏激的字眼去形容，而是用的框架。</p><p>我们所喜欢的事物，至少我喜欢的事物，拆开了讲，许许多多都是都是被框架所限定，生活、思维、情感、甚至是内心，那为什么框架要限定出我们所定义出来的幸福呢？我脑海中浮现的答案是文明，是制度……</p><p>地球最初的生命，或许只是造物主偷偷在一个水球中放下了能进行光合作用的一些小生物，进而演化成了我们此般文明景象罢了，我们都是进化而来的生物，而生物遵循了生物法则，长久以往的人们制定了无数有益于生存下去的制度、规则，而在这样的大环境下生活着，有一种奇妙的事物叫做快乐抑或是幸福。</p><p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1623724819065-43292e39-1cfe-4dd4-b4a9-9cbf05167e4a.jpeg#height=1080&id=jClko&originHeight=1080&originWidth=1440&originalType=binary%E2%88%B6=1&status=done&style=none&width=1440"></p><p>人生的终极目标是什么？我又在一直追寻着什么啊？</p><p>我对自己问了一个特别大的问题，甚至有些幼稚的问题，或许我的潜意识里面想过这问题，但是又像是模模糊糊，如果用此刻大脑中的思绪来回答，我应该会回答：文明框架下的快乐和幸福。这个回答看起来是那么的简单易懂，却又有一些伤感与妥协，我站的太低了，我将自己死死地按在一个没有实体的框架下面，多么的悲怆，似乎就像是一台机器去做那些连幸福都定义好了的事情，</p><p>突然想到了一些人，无间道里面的刘建明和人间失格里面的叶藏，描述这两个人最好的状态就是无间，无间地狱，真的是艺术，描述的彻彻底底，佛教的思想：轮回、开悟、涅槃，而那两个人，无止境的在无间地狱轮回……想想这个文明制度下的种种，细思极恐</p><p>人活着就是为了生活更快乐，更幸福，而幸福的生活要自己努力争取来的。<br>​</p><p>我总是又在想，温柔的人为什么也会被</p><hr><p>2021.06.16<br>​</p><p>“<strong>我不喜欢那些正确的人，那些从没堕落过、从没犯过错的人。生活的美未曾在他们面前展开过。</strong>”一个文学家在所沉浸的文学世界中的独白。<br>​</p><p>真正的文学家总让人感觉是一个怪人，而我却独爱这般不被束缚的精神因子。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>内部排序的各种方法</title>
      <link href="blog/garbxb/"/>
      <url>blog/garbxb/</url>
      
        <content type="html"><![CDATA[<blockquote><p>排序按照所占用的计算机内部存储设备，可以分为：<strong>内部排序</strong>和<strong>外部排序</strong> &gt; <strong>内部排序：</strong>占用的是内存，待排序序列全部放在内存加以排序处理<br><strong>外部排序：</strong>占用的是外存，数据量比较大，内存空间不足以一次性全部容纳数据的情况</p></blockquote><p>**<br><strong><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1623667337022-44c54af8-5961-43d6-8fa4-46ef3f6ec71f.png#align=left&display=inline&height=250&margin=%5Bobject%20Object%5D&name=image.png&originHeight=499&originWidth=1130&size=412707&status=done&style=stroke&width=565" alt="image.png"></strong></p><h2 id="一、插入类排序"><a href="#一、插入类排序" class="headerlink" title="一、插入类排序"></a>一、插入类排序</h2><p>将无序的子序列插入到有序序列中</p><h3 id="直接插入"><a href="#直接插入" class="headerlink" title="直接插入"></a>直接插入</h3><p>将元素序列走一遍，走到某个元素时，将其插入到已走过的已排序序列中，这样可以保证走完所有元素，然后所有的元素都是排序好的。<br>数据结构选用的时顺序表</p><pre><code class="cpp">/* 直接插入排序 */void insertSort(SqList &amp;S) &#123;    for (int i = 2; i &lt;= S.length;++i) &#123;        if (S.data[i]&lt; S.data[i-1])&#123;            S.data[0] = S.data[i];            S.data[i] = S.data[i - 1];            int j;            for (j = i - 2; S.data[0] &lt;= S.data[j];--j)                S.data[j + 1] = S.data[j];            S.data[j + 1] = S.data[0];        &#125;    &#125;&#125;</code></pre><h3 id="折半插入"><a href="#折半插入" class="headerlink" title="折半插入"></a>折半插入</h3><p>在直接插入的过程中，找到一个元素，然后再需要从后往前依次查找“该在”的位置，对其查找进行了折半优化</p><pre><code class="cpp">/* 折半插入排序 */void BinsertSort(SqList &amp;S) &#123;    for (int i = 2; i &lt;= S.length;i++) &#123;        S.data[0] = S.data[i];        int low = 1;        int high = i - 1;        while (low &lt;= high) &#123;            int m = (low + high) / 2;            if (S.data[0]&lt;S.data[m]) high = m - 1;            else low = m + 1;        &#125;        int j;        for (j = i - 1; j &gt;= high + 1;--j)            S.data[j + 1] = S.data[j];        S.data[high + 1] = S.data[0];    &#125;&#125;</code></pre><h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><pre><code class="cpp">/* 希尔排序 */void ShellInsert (SqList &amp;L, int dk) &#123;    for (int i = dk + 1; i &lt;= L.length;++i) &#123;        if (L.data[i]&lt;L.data[i-dk]) &#123;            L.data[0] = L.data[i];            int j;            for (j = i - dk; j &gt; 0 &amp;&amp; L.data[0] &lt; L.data[j]; j -= dk)                L.data[j + dk] = L.data[j];            L.data[j + dk] = L.data[0];        &#125;    &#125;&#125;void ShellSort (SqList &amp;L, int dt[],int t) &#123;    for (int k = 0; k &lt; t;++k) &#123;        ShellInsert(L, dt[k]);    &#125;&#125;</code></pre><h2 id="二、交换类排序"><a href="#二、交换类排序" class="headerlink" title="二、交换类排序"></a>二、交换类排序</h2><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><pre><code class="cpp">/* 冒泡排序 */void BubbleSort(SqList &amp;L) &#123;    int m = L.length - 1;    int flag = 1;    while ((m&gt;0) &amp;&amp; (flag == 1)) &#123;        flag = 0;        for (int j = 1; j &lt;= m;j++ )            if (L.data[j]&gt;L.data[j+1]) &#123;                flag = 1;                int t = L.data[j];                L.data[j] = L.data[j + 1];                L.data[j + 1] = t;            &#125;        --m;    &#125;&#125;</code></pre><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><pre><code class="cpp">/* 快速排序 */int Partition (SqList &amp;L, int low, int high) &#123;    L.data[0] = L.data[low];    int pivotkey = L.data[low];    while (low &lt; high) &#123;        while (low&lt;high &amp;&amp; L.data[high]&gt;=pivotkey)            --high;        L.data[low] = L.data[high];        while (low&lt;high &amp;&amp; L.data[low]&lt;=pivotkey)            ++low;        L.data[high] = L.data[low];    &#125;    L.data[low] = L.data[0];    return low;&#125;void Qsort(SqList &amp;L, int low, int high) &#123;    if (low&lt;high)&#123;        int pivoloc = Partition(L, low, high);        Qsort(L, low, pivoloc - 1);        Qsort(L, pivoloc + 1, high);    &#125;&#125;void QuickSort(SqList &amp;L) &#123;    Qsort(L, 1, L.length);&#125;</code></pre><h2 id="三、选择类排序"><a href="#三、选择类排序" class="headerlink" title="三、选择类排序"></a>三、选择类排序</h2><h3 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h3><pre><code class="cpp">/* 简单选择排序 */void SelectSort(SqList &amp;L) &#123;    for (int i = 1; i &lt; L.length;i++) &#123;        int k = i;        for (int j = i + 1; j &lt;= L.length;++j)            if (L.data[j]&lt;L.data[k])                k = j;            if (k != i) &#123;                int t = L.data[i];                L.data[i] = L.data[k];                L.data[k] = t;            &#125;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
          <category> 排序算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>一个梦——“梦中姑娘”</title>
      <link href="essay/di14o2/"/>
      <url>essay/di14o2/</url>
      
        <content type="html"><![CDATA[<div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">空调+风扇睡觉->易着凉->易做梦因着凉而做的梦大多不是自然醒，此般崩坏醒……</div><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1623127396847-7144e32c-9f84-4c90-ad75-307f781827a5.png#height=1377&id=IChRS&originHeight=1377&originWidth=1080&originalType=binary%E2%88%B6=1&status=done&style=none&width=1080"></p><hr>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>《人间失格》——“纯真无垢的信任算是罪过吗？”</title>
      <link href="essay/am0q19/"/>
      <url>essay/am0q19/</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1622964551715-a700f7e7-b3e8-45c5-9d80-787cbb0c66f3.png#height=400&id=u8cf446b6&margin=%5Bobject%20Object%5D&name=image.png&originHeight=400&originWidth=400&originalType=binary%E2%88%B6=1&size=88088&status=done&style=stroke&width=400" alt="image.png"></p><div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">“纯真无垢的信任算是罪过吗？”</div><p>经历了小时候的“看脸色行事”、中学寄读、与家庭隔绝任何关系……</p><p>回归抑郁惆怅的那会日常状态，常去的那家酒馆，将自己灌得烂醉，突然有一天，遇见的不懂何为污秽的童贞的由子润湿了生来敏感的叶藏……</p><div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">“即便因为这样日后遭逢再大的悲哀也无所谓，我一定要放纵地享受眼前这极度的欢乐，哪怕这一生仅有这一次。”</div><p>还记得『无间道』里面说的「八大地狱之最，称为无间地狱，为无间断遭受大苦大意，故有此名」</p><p>人会变吗？不知道，但我知道敏感的人不易变……</p><div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">四周的气氛蓦地变得异样紧张。两个人从楼顶天台走到二楼,再从二楼往底楼我的屋子走去。在楼梯上堀木停住了脚步,用手指着前面小声说道:“你看!”我家那间屋子上方的小窗户正敞开着,从那儿可以看到里面的光景。<p>只见屋子里亮着电灯,有两只动物正在干着什么。我顿时觉得头晕目眩、呼吸急促,但同时心里却在暗自低语—这也算是一出人间粉戏吧,这也算是人类的本性吧,没什么好大惊小怪的—我甚至忘记了出手去解救由子,只是久久地呆立在楼梯中间。</div></p><p>“解救”这个一词我不是很理解，我看了两遍，不知道由子是被迫的还是自愿的，但是根据后文的由子对叶藏的眼神躲避的情节，我感觉是自愿的……<br>​</p><div style="background: #FFF3F3;padding:10px;border: 1px solid #DEB8BE;border-radius:5px;margin-bottom:5px;">每当我唤她时，她总是身体冷不丁一哆嗦，视线也不知道该投向哪里好。无论我再怎么装痴装疯胡言乱语以逗她一笑，她都一副茫然不知所措、坐立不安、战战兢兢的样子，和我说话时还心不在焉地乱用敬语。</div>​<hr><p>原文里面的天台上的叶藏心理……<br>​</p><div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">我则像逃命似的一个人又冲回到天台，躺在地上，仰望含满雨气的夏日夜空。此时，袭遍我全身的情感不是愤怒，也不是厌恶，更不是悲伤，而是极度的恐惧。那不是面对墓地中诸多幽灵时的恐惧，倒更像是在神社的杉树林间，撞见身着白衣的神明时的那种来自太古的、凶暴恶戾的、令人噤默失语般的恐惧。从那晚起，我开始少年白头，我越发对世间所有的一切失去信心，越发对人产生无止境的怀疑，从此诀别了对人世生活所抱有的全部期待、喜悦、共鸣。事实上，这也是我整个人生中起到决定性作用的一个事件，仿佛被人迎面一刀砍中眉间，日后无论我与任何人接触，那伤口便会隐隐作痛。</div>​<p>丧，十分丧……这一段，以前看的极度压抑，现在看的十分同情，敏感的叶藏遇到这种事情，真的是上天的无间地狱的惩罚吗？那现在这个时代的人呢？</p><hr><div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">“纯真无垢的信任算是罪过吗？”“纯真无垢的信任之心，难道真是罪恶之源吗？！”</div><p>作者说着两次，好像文中还有相似强调的话语，对于一个敏感的人的内心最信任人而言，则算是一种无言的崩溃把，堕入人间地狱……</p><p>作者不解……</p><p>第一次看这本书对此我是感到抑郁，全程压抑，但是现在看来，感受到的是一个敏感的人对周围的无奈与妥协，到最后那纯真无垢的信任之心也已死……</p><p>这样的人生是何等的失望……</p>]]></content>
      
      
      <categories>
          
          <category> 一书一世界 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>DL角色获取和技能介绍</title>
      <link href="essay/qtpk8a/"/>
      <url>essay/qtpk8a/</url>
      
        <content type="html"><![CDATA[<p>这是加密文章！</p>]]></content>
      
      
      <categories>
          
          <category> 游戏娱乐 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>《人生》之高加林的爱情我也曾有过……</title>
      <link href="essay/mh44ds/"/>
      <url>essay/mh44ds/</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1622168235721-f78e67ae-65fa-4208-bdf6-1bbad23a55a8.png#height=387&id=u836e58b6&margin=%5Bobject%20Object%5D&name=81676418_p0.png&originHeight=1663&originWidth=1255&originalType=binary%E2%88%B6=1&size=2307612&status=done&style=stroke&width=291.7477111816406" alt="81676418_p0.png"><br>以前看的，今天突然有一些很深的感悟</p><p>高加林把纯情美丽、聪慧贤淑的刘巧珍这块“金子”丢了，突然想到相似的自己、想到了守恒、想到了辗转反侧却也难忘的心思……</p><p>守恒律，总觉得这世界上任何东西<br>这世界上的事情，总是守恒的，人和人之间的情感，爱情、人情味、亲情</p><p>还记得路遥的《人生》最后说，加林失去了自己人生中最重要的金子，我觉得这也是守恒的，从一开始，高加林就获得了自己的“金子”，然而呢，没珍惜……一开始高加林的教师职位被强拉下来，这的确是人生的不公，但是这也迎来了上天送给他的巧珍这颗金子，而后呢，他又放弃了巧珍这颗金子，追寻另外的一个女人，到最后，这个金子也没了</p><p><strong>现实是如此的相似，我曾经也失去过金子，她非常漂亮，些许单纯，些许霸道，还喜欢看言情小说……我们和书里面的主人公一摸一样，真就一模一样，原因无他，在当时看来，在当时周围整个世界看来，读书谈啥恋爱……那时的我，很懵懂···后来我就进高中了，她好像是去一个技术学院还是直接工作，我忘了，有一次我上 QQ 了，那会应该是高一，她真好也在，便和她聊起天，那会她好朋友也在，我们三个是朋友，那会我们一起聊天，突然她朋友来一句“你啥时候和我家 XXX 表白呢”……</strong><br><strong>是的，那会，又是在读书……我不记得我当时是怎么回应的了，我只知道我当时挺想看看她的……</strong></p><p><strong>我大学期间，她生娃了，很漂亮但不帅……</strong></p><p><strong>我苦笑、却又辗转反侧……</strong></p>]]></content>
      
      
      <categories>
          
          <category> 一书一世界 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>微信屏蔽的不只有网易云的『性格主导色』</title>
      <link href="essay/qgtwsr/"/>
      <url>essay/qgtwsr/</url>
      
        <content type="html"><![CDATA[<p>网易云『性格主导色』活动页面遭微信屏蔽，在微信软件中点击活动页面会出现以下警告内容。我倒是见怪不怪，因为被屏蔽的不只有网易云的『性格主导色』，还有许许多多默不作声的外链，细想之，我个人的看法是与其说这是一种为了维护绿色上网环境，倒不如说是对当下自媒体崛起的一种流量上的恐慌……</p><p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1622096165024-de751f5a-0c8f-4d21-8fe9-da41dbf459bf.jpeg#height=257&id=gsk95&margin=%5Bobject%20Object%5D&name=Screenshot_20210527_141510_com.tencent.mm.jpg&originHeight=855&originWidth=1176&originalType=binary%E2%88%B6=1&size=90586&status=done&style=stroke&width=354" alt="Screenshot_20210527_141510_com.tencent.mm.jpg"></p><p>现如今自媒体的崛起，广告的投放不单单是微信，短视频平台，某站平台等这些更加吸引广大用户的娱乐平台的崛起，说白了，自媒体的崛起给腾讯造成了流量上的恐慌，倘若在 B 站动漫里面推广一些产品，不比下面这种每天都看的心烦的广告好得多<img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1622097105798-a36f91ad-5589-4393-8a28-1d152e214c18.jpeg#height=52&id=y9K8r&originHeight=52&originWidth=52&originalType=binary%E2%88%B6=1&status=done&style=none&width=52">……<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1622095673079-588276fc-6d38-4886-8d9c-be90b62f0f63.png#height=267&id=C71oi&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1112&originWidth=1176&originalType=binary%E2%88%B6=1&size=895660&status=done&style=stroke&width=282" alt="image.png"><br>但是作为腾讯的这种机制是说为了维护用户体验，保留用户的权益……就我个人而言，我所知道的不仅仅是这个事件被屏蔽，还有之前的语雀链接在微信也不能打开，另外近期，在 QQ 里面我打开自己的网站，也是无效的，会提示非官方网站，许多博客站点都被屏蔽了<img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1622097255080-95d8e27c-375d-4629-b118-4f74c1273e9c.jpeg#height=58&id=XPRrb&originHeight=58&originWidth=62&originalType=binary%E2%88%B6=1&status=done&style=none&width=62">，总的来说，像上面那种广告是不会被屏蔽的，但是像一些外链现在十有八九是会被屏蔽的，不管这外链是低质量内容还是有不错内容的站点。</p><hr><hr><p>给自己测了下这个主导色，除了蓝色是对的，<strong>其他的都扯淡</strong>……<img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1622098043031-f48fc2c7-e8d9-416f-acd6-925a9528af2e.jpeg#height=48&id=ohPur&originHeight=48&originWidth=48&originalType=binary%E2%88%B6=1&status=done&style=none&width=48"></p><p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1622097912666-9ca03aa8-58f6-4f2e-a5e0-02145b87cb74.jpeg#height=3256&id=u0e97d042&margin=%5Bobject%20Object%5D&name=QQ%E5%9B%BE%E7%89%8720210527%E6%94%BE140915.jpg&originHeight=3256&originWidth=1176&originalType=binary%E2%88%B6=1&size=520401&status=done&style=none&width=1176" alt="QQ图片20210527放140915.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>《活着》（18年读书笔记）</title>
      <link href="essay/rcexdl/"/>
      <url>essay/rcexdl/</url>
      
        <content type="html"><![CDATA[<div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">今天突然打开电脑里面的OneNote，发现以前还真写过不少东西……记得当时看这本书的时候，是在一个下午，一个最深的场景主人公他儿子死了，那个清晨黎明两三点，富贵从医院背着儿子往家走的时候，那个场景，针对心酸……有些许微风，夹杂着些许露水……阵阵凉意~</div><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1622032573540-7113b1ee-f2f6-419f-a75b-577f79de0a27.png#align=left&display=inline&height=366&margin=%5Bobject%20Object%5D&name=image.png&originHeight=732&originWidth=1343&size=191674&status=done&style=stroke&width=671.5" alt="image.png"></p><div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">18年写的</div><p>《活着》有感</p><p>每个人的人生都不一样，但是我们都活着。</p><p>——有感</p><p>“我知道黄昏正在准瞬即逝，黑夜从天而降了。我看到广阔的土地袒露着结实的胸膛，那是召唤的姿态，就像女人召唤者她们的儿女，土地召唤着黑夜来临。”活着是一种姿态，一种哲学，主人公福贵的人生是不幸的，在那个时代生活的艰辛，身边的人都离他而去，他几乎失去了一切，但是他活着，活得无奈，活得平庸，活的平凡，但活出了活着的意义。每个人对于活着都会有不同的人生感悟，我们的人生都不一样，因为我们都活着。</p><p>一个人的人生会因为一个人的一次行为而改变，而改变正是一个人活着意义所在。赌博让福贵的家庭从家财万贯到穷困潦倒，我一直觉得一个有故事的人一定会是曾经经历了什么。这次赔债过程中，福贵的爹爹也去世了，再混的子女遇见这等事谁不会心里塌了一片天，可能一切对于当时的他来讲很沉重，但是已经发生了。紧接着的又是妻子家珍被她爹带回家。这里我最感触深的是单纯，天真无邪的凤霞。送给龙二钱的时候，被国民党强制性的拉去充炮兵，就这样又和妻子孩子失去联系，在每天的炮火里，唯一的牵挂也只有老婆孩子了，对啊，人只有在最失意的时候才会想起身边的人，才会珍惜所拥有的，曾经对妻子的漠不关心现在会有牵挂，</p><p>在人民公社之后，百姓的日子日益变得破败不堪，我没有过也没有见过那时代的人，但是我长辈见过。小说有一个片段我觉得挺真实，凤霞用锄头挖到一个地瓜，但是却被村里其他人抢去，可能许多读者看到这不会有太多感触，但我是农村人，我对于此有些许的感触。在决定把凤霞送给别人家的时候，那真的真的是走到尽头了，<br>感触最深的就是，凤霞一天晚上偷偷跑回家，当福贵打开家门，凤霞望着自己的爹娘，说不出话，也听不见别人的话，当福贵决定送凤霞到城里人家时，他说了一句话“就是全家都饿死，也不送凤霞回去”，那一刻，我觉得很温暖，我相信，那是真正的父爱。活着为了什么，我觉得就是为了那些生活中的感动，一个人来到这个世界上，一定都是不容易的，有爱自己的父母，这些一切的一切都是会使得情大于现实。</p><p>原本已经不错的日子最后还是发生了不幸，儿子有庆离开了人世…那天晚上的福贵抱着有庆在回家的路上走走停停，停停走走，不是得停下坐在田埂看看自己的儿子，摸着儿子的脸庞，那时间我的眼眶真的湿了。不知道为什么，看到那时候我想起了我的父母…</p><p>原本凤霞和二喜的婚姻可以让这个不幸的家庭融入点暖和的血液，只是老天还是无情，凤霞的接生让小的来到这个世上，而大的永远离开了。读到这，我的内心真的很难让我往下看了，因为在父母而言，自己的子女都早于自己离开人世，白发人送黑发人，这是怎样的一种伤感，谁能接受这样的现实呢？只是活着终究要活着。之后的生活家珍走了，走的坦然，走之前的家珍说过一句“下辈子还做你的女人，下辈子还和你过”，让我觉得，这是历经苦难之后真正的爱情。爱情是两情相悦，是无言的天长地久，我敬重他们的真爱。福贵晚年也离不开现实的摧残，二喜、苦根也都离开人世了，苦根还那么小，那么的天真，再往后，就是福贵的和老牛的余生了。</p><p>远处的池塘边，有一头老牛在池边喝水，一位老人慢慢的走去。</p><p>尽管《活着》不是一部老师所要求的自传，但我恰恰觉得这是这个世界里许多平凡的人的自传，是那些这个社会中底层人民的生活真实写照，是那些渺小的生命，却能活出活着的意义。</p><p>福贵，福贵的牛，福贵的爹，龙二，家丁长根，老全，春生，家珍，凤霞，有庆，二喜，苦根<br>和龙二赌博输了家底导致生活破败，爹爹去世了，家珍被她爹带回家<br>被国名党拉去充炮兵，结识老全，春生，战败之际，投降回到家里见到老婆孩子<br>人民公社的成立以及之后的潦倒生活，文革<br>把凤霞送给别人家，最后还是情大于现实，留下凤霞一家人生活着<br>有庆献血离去，凤霞接生出血离去，家珍身子体弱离去，二喜工作事故离去，苦根吃豆子死去</p><p>反过来我们也可以说，<strong>因为我们都活着，从而我们的人生可以选择得不一样</strong>。</p><p>作者是以第一人称来塑造富贵这个人物形象，最后的最后只有富贵和他的老牛，不幸的人生，却告诉我们一个人生哲学：活着本身的意义就是活着。</p>]]></content>
      
      
      <categories>
          
          <category> 一书一世界 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>『境界的彼方』</title>
      <link href="essay/wvwrcu/"/>
      <url>essay/wvwrcu/</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.nlark.com/yuque/0/2021/jpg/1484158/1623940888474-c6aa4c62-7d9d-44df-b0ab-bd198c263434.jpg#align=left&display=inline&height=1128&margin=%5Bobject%20Object%5D&originHeight=1128&originWidth=2003&status=done&style=none&width=2003"></p><p>两个特殊身份的角色在一起发生的战斗纯爱番……栗山未来是有着“被诅咒血脉”的异界士少女，神原秋人是有着寄居在体内强大妖梦的半妖（最大的反派竟是主角自己<img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1623926928373-713cb502-b0c8-43a3-ae20-e45a5b4d6828.jpeg#align=left&display=inline&height=58&id=hqw9a&margin=%5Bobject%20Object%5D&originHeight=58&originWidth=79&status=done&style=none&width=79"></p><hr><p>虚幻之影一战<br>这算是秋人解开未来心结的剧情了，男主</p><p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1623927006789-0efec99a-7362-4b1f-8118-0f139cb451a3.jpeg#align=left&display=inline&height=481&id=jD2t5&margin=%5Bobject%20Object%5D&originHeight=481&originWidth=1024&status=done&style=none&width=1024"></p><p>当一个纯爱的人突然有一天闯进缺爱的人世界，这个人就不再孤独，他的余生也注定会因此而改变……</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1623927008770-1000842b-b921-4257-9ffe-3698a435f1ef.png#align=left&display=inline&height=1080&id=EBka9&margin=%5Bobject%20Object%5D&originHeight=1080&originWidth=1920&status=done&style=none&width=1920"></p><p>受过爱的缺爱的人做出的抉择往往不会像常人一样……</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1623927010160-66e09e34-7c86-4ac5-af4d-0097251e4f26.png#align=left&display=inline&height=1080&id=WSDbg&margin=%5Bobject%20Object%5D&originHeight=1080&originWidth=1920&status=done&style=none&width=1920"></p><p>这个是真的呆萌……</p><p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1623927004531-2156628e-e34f-415b-9ff1-a2b53d98f167.jpeg#align=left&display=inline&height=481&id=KMadh&margin=%5Bobject%20Object%5D&originHeight=481&originWidth=1024&status=done&style=none&width=1024"></p>]]></content>
      
      
      <categories>
          
          <category> 人生影视课 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Duel Links (国际服)卡组记录</title>
      <link href="essay/yg1lnk/"/>
      <url>essay/yg1lnk/</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1623035630831-4814054c-1310-41fc-ae32-8d0ec23f93c3.png#height=982&id=ufe0f7d1c&margin=%5Bobject%20Object%5D&name=Snipaste_2021-06-07_10-43-08.png&originHeight=982&originWidth=1666&originalType=binary%E2%88%B6=1&size=1539932&status=done&style=none&width=1666" alt="Snipaste_2021-06-07_10-43-08.png"></p><ul><li><a href="https://www.duellinksmeta.com/">YuGiOh! Duel Links Meta</a></li><li><a href="https://ygodl.com/">决斗链接中文网 – 游戏王决斗链接 | 决斗链接国际服</a></li></ul><h2 id="青眼白龙"><a href="#青眼白龙" class="headerlink" title="青眼白龙"></a>青眼白龙</h2><blockquote><p>参考：</p><ul><li><a href="https://xw.qq.com/amphtml/20210324A0C6Q000">2021.03.28 决斗链接国际服萌新攻略：青眼白龙卡组讲解附对局思路 腾讯网</a></li><li><a href="https://ygodl.com/52075.html">2021.04.21 上王卡组 白龙上王</a></li><li><a href="https://ygodl.com/25253.html">2020.03.17 卡组攻略 白龙卡组构筑指南</a></li></ul></blockquote><h3 id="卡组构筑"><a href="#卡组构筑" class="headerlink" title="卡组构筑"></a>卡组构筑</h3><div style="background: #FFFBE6;padding:10px;border: 1px solid #C3C3C3;border-radius:5px;margin-bottom:5px;">技能</div><ul><li>进化后最强龙族</li></ul><p>​</p><div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">基础构筑</div><ul><li><strong>1/1 青眼亚白龙</strong></li><li><strong>3/3 太古的百石</strong></li><li><strong>1/1 白灵龙</strong></li><li><strong>2/3 青之眼贤士</strong></li><li><strong>1/1 传说的白石</strong></li><li><strong>3/3 青眼白龙</strong></li><li><strong>1 青之眼少女</strong></li><li>4 青之眼祭司</li><li>1 青之眼的巫女</li><li>3 青之眼的守护人</li><li>球茎</li><li>1 宇宙智者</li><li>风筝机人</li><li>1 栗子球</li></ul><p>​</p><div style="background: #edf9e8;padding:10px;border: 1px solid #c2d2b5;border-radius:5px;margin-bottom:5px;">魔法陷阱</div><ul><li><p><strong>2/3 调和的宝牌</strong></p><blockquote><p>主动将白石送墓，还能用于过牌，加大先手做出<strong>精灵龙</strong>的概率，羁绊不够的情况下可能会卡手。建议下 2~3 张（下两张调和的话可去掉传说的白石，下三张调和的话建议加一张传说的白石增加胡牌概率）</p></blockquote></li><li><p><strong>0/1 龙之觉醒旋律（亚白）</strong></p><blockquote><p>可主动丢掉手牌的废件（说的就是你白灵龙），或者丢白石，检索卡组的亚白龙和白龙，此卡加上一张 cost 和任意协调就能先手做出精灵龙，此卡在国际服物理限一。</p></blockquote></li><li><p><strong>1/2-3 远古规则（手召百灵龙、青眼白龙 for 精灵龙）</strong></p><blockquote><p>特殊召唤手牌的白龙或白灵龙，一定程度上润滑白龙卡手的缺陷<br>远古规则的投入让白龙卡组更容易在第一回合做出青眼精灵龙进行压制，青眼精灵龙能压制对面的墓地，还能二速跳苍眼银龙进行躲坑，在目前环境是个合格的终端</p></blockquote></li><li><p><strong>2-3 因果切断（灵活换下面的）</strong></p><blockquote><p>版本答案，强力的抗性大怪都一般都能抗破坏，唯独没有抗除外的，好用<br>处理具有破坏抗性的怪以及对面的终端，或断对面的初动，让依靠通召的卡组停牌<br>此外因果切断还能配合太古的白石，主动将太古的白石送墓，让己方卡组启动<br>（注：白石是白龙卡组的重要启动点）</p></blockquote></li><li><p>狡猾陷坑</p><blockquote><p>自己墓地没陷阱卡时可以炸两怪，很赚。墓地有陷阱时当成手牌资源丢弃<br>一换二的神卡，配合精灵龙对对面进行前场和墓地的压制，如果成功发动，那么将会在接下来的对局中给己方带来巨大的优势，更可能让胜利直接导向己方，拿下本局胜利。</p></blockquote></li><li><p>雷破</p><blockquote><p>灵活性较高，可以炸对面一卡，毕竟因果只能切怪兽</p></blockquote></li><li><p>敌人控制器</p></li></ul><p>​</p><div style="background: #FFF3F3;padding:10px;border: 1px solid #DEB8BE;border-radius:5px;margin-bottom:5px;">额外卡组</div><ul><li>2 青眼精灵龙</li><li>2 苍眼银龙</li><li><strong>2 圣刻神龙-九柱神</strong></li><li>1 灼银之机龙</li></ul><h3 id="卡片途径"><a href="#卡片途径" class="headerlink" title="卡片途径"></a>卡片途径</h3><div style="background: #fffbe6;padding:10px;border: 1px solid #e0d1b1;border-radius:5px;margin-bottom:5px;">青眼双爆裂龙，真青眼究极龙，青眼究极龙均为**技能**自带</div><ul><li><input checked="" disabled="" type="checkbox"> <strong>【1】青眼亚白龙：</strong><del>四周年登陆奖励</del></li><li><input checked="" disabled="" type="checkbox"> <strong>【3】太古的白石：</strong><del>19 小包，黄金包 3，2021 青眼构筑，UR 梦想券</del></li><li><input checked="" disabled="" type="checkbox"> <strong>【3】白灵龙：</strong><del>2018 青眼，2021 青眼构筑，SR 梦想券</del></li><li><input disabled="" type="checkbox"> <strong>【2/3】青之眼贤士：</strong><del>26 大包（抽完），</del><strong>SR 梦想券</strong></li><li><input checked="" disabled="" type="checkbox"> <strong>【1】传说的白石：</strong><del>15 大包，SR 梦想券</del></li><li><input checked="" disabled="" type="checkbox"> <strong>【3】青眼白龙：</strong><del>解锁海马，圭平获得</del></li></ul><hr><ul><li><input disabled="" type="checkbox"> <strong>【2/3】调和的宝牌：</strong>16 大包，<del>2021 青眼构筑</del>，<strong>UR 梦想券</strong></li><li><input disabled="" type="checkbox"> <strong>【0/1】龙之觉醒旋律</strong>：DM 海马 45 级升级奖励</li><li><input checked="" disabled="" type="checkbox"> <strong>【3】远古规则：</strong><del>DM 圭平 23 级升级奖励，排位 R 券</del></li><li><input disabled="" type="checkbox"> <strong>【2/3】因果切断：</strong>29 小包<del>，白银包 2（2 张；还有协调的口香糖），</del><strong>SR 梦想券</strong></li><li><input checked="" disabled="" type="checkbox"> <strong>【1】狡猾的陷坑：</strong><del>11 小包，白银包 2（2 张；还有协调的口香糖），SR 梦想券</del></li></ul><hr><ul><li><input checked="" disabled="" type="checkbox"> <strong>【1/1】青眼精灵龙：</strong><del>26 大包，UR 梦想券</del></li><li><input disabled="" type="checkbox"> <strong>【0】灼银之机龙：</strong>20 大包，UR 梦想券</li><li><input checked="" disabled="" type="checkbox"> <strong>【1/1】苍眼银龙：</strong><del>15 大包，2021 青眼构筑，SR 梦想券</del></li><li><input disabled="" type="checkbox"> <strong>【0】圣刻神龙-九柱神：</strong>32 大包</li><li><input disabled="" type="checkbox"> <strong>【0】鬼岩城：</strong>卡片商人处兑换</li></ul><h3 id="对战思路"><a href="#对战思路" class="headerlink" title="对战思路"></a>对战思路</h3><hr><p><strong>一、和水产的对局思路：</strong><br>白龙打水产比较劣势，水产一般会配备<strong>狡猾陷坑</strong>，<strong>月之书</strong>，<strong>禁忌的圣枪</strong>，水产一但拿到先手，<strong>深渊潜伏者</strong>和<strong>海皇的重甲兵/狙击手</strong>配合不仅能封墓而且还能二速炸卡，白龙吃一炸或者吃一本书基本就无法展开，而白龙的后场水产也能用<strong>禁忌的圣枪</strong>来应对，所以一但后手，且对面不卡手，这局基本宣告结束了。</p><p><strong>先攻思路：</strong>能做精灵龙尽量做精灵龙，精灵龙可以压制<strong>海皇的重甲兵</strong>效果，还能随时跳苍眼，先手站个精灵龙比站三个白板龙更稳，后场有因果的话还能打断对面展开（注：技能皆不如连锁），先手精灵龙加上后场的话，基本可以将这局胜利收入囊中。</p><p><strong>后攻思路：</strong>对面先手做出<strong>深渊潜伏者，</strong>加上后场，建议直接右上角快速胜利。</p><hr><p><strong>二、和棍凳堕天使的对局思路：</strong><br>白龙打棍凳堕天使是大优，棍凳堕天使本家只有迪赛亚有 3000 打点，一但迪赛亚被解，堕天使就连普通白龙都过不了，不过现在堕天使都是携带<strong>等级调整</strong>技能，会压血线出<strong>希望皇霍普雷</strong>，只要小心别被霍普雷一刀斩，和堕天使的对局将会毫无难度。</p><hr><p><strong>三、和雷龙的对局思路：</strong><br>雷龙，卡手率比白龙还高，但拥有 OTK（即一回杀）的能力，是目前唯一一副活跃在 T 表的 OTK 卡组，雷龙具有强大的资源利用能力，也正是因为如此，才能负担起浑源龙的消耗，目前雷龙一般是挂光道轴，光道轴能快速积累墓地资源，供给给浑源龙，跳出浑源龙炸卡，进而 OTK。</p><p><strong>先攻思路：</strong>老样子，先手做出精灵龙，看准对面墓地，一但有光暗怪兽三体，马上跳<strong>苍眼银龙，</strong>因为浑源龙炸卡不取对象，浑源龙出场的那一刻跳苍眼已经晚了<strong>，苍眼银龙</strong>有防破坏和取对象抗性，浑源龙炸不了，雷龙最高打点 3100，如果想过银龙，还会对手牌质量有要求，很难实现斩杀，一但熬过这回合，白龙下回合可以反打，将胜利收入囊中。</p><p><strong>后攻思路：</strong>对面场上站了保镖的话，可以先用贤士骗保镖的康，然后用亚白炸掉保镖，然后出精灵龙，剩下操作的就和上面的一样，如果没骗掉，则还是优先出精灵龙，打开时点在对面回合用用因果处理掉保镖，然后依旧是上面的操作。</p><hr><p><strong>大篇幅的对局思路分享以上三个，还有几个卡组的对局思路稍微讲解一下</strong></p><p><strong>和炎王对局：</strong>精灵龙压住墓地的对面不死鸟防止诈尸，因果用来处理大象或者不死鸟。</p><p><strong>和月光对局：</strong>先攻时怪兽一律防守表示防止对面偷鸡，二姐可以用因果处理，注意墓地红狐，红狐会康因果，大姐可以用双爆裂龙处理。</p><p><strong>和三金对局：</strong>用因果切对面的初动或对面终端，对面回合用白灵龙吹场地，三金初动被断后很难与白龙抗衡。</p><hr><h2 id="流星龙"><a href="#流星龙" class="headerlink" title="流星龙"></a>流星龙</h2><blockquote><p>参考：</p><ul><li><a href="https://ygodl.com/intdecks/intrm?tags1=%E6%B5%81%E6%98%9F%E9%BE%99">流星龙 标签</a></li><li><a href="https://ygodl.com/53592.html">2021.05.21 娱乐卡组 心得分享 娱乐流星龙</a></li></ul></blockquote><p>游星卡组简直就是娱娱乐乐啊<img src="https://cdn.nlark.com/yuque/0/2021/gif/1484158/1622028564214-fa4b454f-c46f-49ca-b816-0528ce4b8211.gif#height=48&id=lJwbe&originHeight=48&originWidth=48&originalType=binary%E2%88%B6=1&status=done&style=none&width=48">，打排位是不可能的，这辈子都不可能的！！</p><p>休闲 pvp、打打 NPC 还是可以的<img src="https://cdn.nlark.com/yuque/0/2021/gif/1484158/1622028602455-8684ba72-3d24-4c3e-bbcf-99085960438f.gif#height=100&id=cv7nD&originHeight=100&originWidth=100&originalType=binary%E2%88%B6=1&status=done&style=none&width=100">……<br>​</p><h2 id="排位等级"><a href="#排位等级" class="headerlink" title="排位等级"></a>排位等级</h2><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1623065821383-e8538232-b66d-431c-af74-0b996875afac.png#clientId=u9ff4eee1-1f8c-4&from=paste&height=261&id=udaec3859&margin=%5Bobject%20Object%5D&name=image.png&originHeight=521&originWidth=1107&originalType=binary%E2%88%B6=2&size=41141&status=done&taskId=u826dbed0-cdc2-4232-a5fa-2d13390ebf5&width=553.5" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1623065832590-78822a7a-6547-4564-b786-069c328f1f60.png#clientId=u9ff4eee1-1f8c-4&from=paste&height=137&id=u004c7cc9&margin=%5Bobject%20Object%5D&name=image.png&originHeight=273&originWidth=1108&originalType=binary%E2%88%B6=2&size=48879&status=done&taskId=u162f34c4-2694-4e29-9419-234e74662f8&width=554" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> 游戏娱乐 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>实验八——校园最短路（Dijkstra+Floyd）</title>
      <link href="blog/rxx0ab/"/>
      <url>blog/rxx0ab/</url>
      
        <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>1、给出校园中常用的几个点，如教室 550、文宗楼、三个食堂、大操场、宿舍楼（自定）、校门口、体育场；<br>2、画图并给出其邻接矩阵（请合作完成）；<br>3、用 floyd 算法求每对顶点间的最短路。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1622701735560-677cf8e1-e3f6-4c6a-9288-500eefaae6d4.png#align=left&display=inline&height=433&id=VrPJt&margin=%5Bobject%20Object%5D&name=image.png&originHeight=866&originWidth=1091&size=116035&status=done&style=stroke&width=545.5" alt="image.png"></p><hr><div style="background: #FFFBE6;padding:10px;border: 1px solid #C3C3C3;border-radius:5px;margin-bottom:5px;">迪杰斯特拉（Dijkstra）算法</div><p>Dijkstra 算法是经典的单源最短路径算法，用于计算源点到其它所有顶点的最短路径。在图 G=(V,E) 中，假设每条边 E[i] 的权值距离为 w[i]，找到由源点 v0 到其余各点的最短路径。<br>适用：不含负权重的图</p><p>算法当中，对图的遍历方式为 BFS（广度优先遍历）</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1622703321484-ea1fa3e2-34db-4827-8048-cd68231125cb.png#align=left&display=inline&height=113&id=MRDfH&margin=%5Bobject%20Object%5D&name=image.png&originHeight=225&originWidth=561&size=19395&status=done&style=none&width=280.5" alt="image.png"></p><pre><code class="cpp">/** * C++: Floyd算法获取最短路径(邻接矩阵) * */#include &lt;iomanip&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;bits/stdc++.h&gt;using namespace std;// 边的结构体class EData&#123;    public:        char start; // 边的起点        char end;   // 边的终点        int weight; // 边的权重    public:        EData()&#123;&#125;        EData(char s, char e, int w):start(s),end(e),weight(w)&#123;&#125;&#125;;class MatrixUDG &#123;    #define MAX    100    #define INF    (~(0x1&lt;&lt;31))        // 无穷大(即0X7FFFFFFF)    private:        char mVexs[MAX];    // 顶点集合        int mVexNum;             // 顶点数        int mEdgNum;             // 边数        int mMatrix[MAX][MAX];   // 邻接矩阵    public:        // 创建图(自己输入数据)        MatrixUDG();        // 创建图(用已提供的矩阵)        //MatrixUDG(char vexs[], int vlen, char edges[][2], int elen);        MatrixUDG(char vexs[], int vlen, int matrix[][9]);        ~MatrixUDG();        // 深度优先搜索遍历图        void DFS();        // 广度优先搜索（类似于树的层次遍历）        void BFS();        // prim最小生成树(从start开始生成最小生成树)        void prim(int start);        // 克鲁斯卡尔（Kruskal)最小生成树        void kruskal();        // Dijkstra最短路径        void dijkstra(int vs, int vexs[], int dist[]);        // Floyd最短路径        void floyd(int path[][MAX], int dist[][MAX]);        // 打印矩阵队列图        void print();    private:        // 读取一个输入字符        char readChar();        // 返回ch在mMatrix矩阵中的位置        int getPosition(char ch);        // 返回顶点v的第一个邻接顶点的索引，失败则返回-1        int firstVertex(int v);        // 返回顶点v相对于w的下一个邻接顶点的索引，失败则返回-1        int nextVertex(int v, int w);        // 深度优先搜索遍历图的递归实现        void DFS(int i, int *visited);        // 获取图中的边        EData* getEdges();        // 对边按照权值大小进行排序(由小到大)        void sortEdges(EData* edges, int elen);        // 获取i的终点        int getEnd(int vends[], int i);&#125;;/* * 创建图(自己输入数据) */MatrixUDG::MatrixUDG()&#123;    char c1, c2;    int i, j, weight, p1, p2;    // 输入&quot;顶点数&quot;和&quot;边数&quot;    cout &lt;&lt; &quot;input vertex number: &quot;;    cin &gt;&gt; mVexNum;    cout &lt;&lt; &quot;input edge number: &quot;;    cin &gt;&gt; mEdgNum;    if ( mVexNum &lt; 1 || mEdgNum &lt; 1 || (mEdgNum &gt; (mVexNum * (mVexNum-1))))    &#123;        cout &lt;&lt; &quot;input error: invalid parameters!&quot; &lt;&lt; endl;        return ;    &#125;    // 初始化&quot;顶点&quot;    for (i = 0; i &lt; mVexNum; i++)    &#123;        cout &lt;&lt; &quot;vertex(&quot; &lt;&lt; i &lt;&lt; &quot;): &quot;;        mVexs[i] = readChar();    &#125;    // 1. 初始化&quot;边&quot;的权值    for (i = 0; i &lt; mVexNum; i++)    &#123;        for (j = 0; j &lt; mVexNum; j++)        &#123;            if (i==j)                mMatrix[i][j] = 0;            else                mMatrix[i][j] = INF;        &#125;    &#125;    // 2. 初始化&quot;边&quot;的权值: 根据用户的输入进行初始化    for (i = 0; i &lt; mEdgNum; i++)    &#123;        // 读取边的起始顶点，结束顶点，权值        cout &lt;&lt; &quot;edge(&quot; &lt;&lt; i &lt;&lt; &quot;): &quot;;        c1 = readChar();        c2 = readChar();        cin &gt;&gt; weight;        p1 = getPosition(c1);        p2 = getPosition(c2);        if (p1==-1 || p2==-1)        &#123;            cout &lt;&lt; &quot;input error: invalid edge!&quot; &lt;&lt; endl;            return ;        &#125;        mMatrix[p1][p2] = weight;        mMatrix[p2][p1] = weight;    &#125;&#125;/* * 创建图(用已提供的矩阵) * * 参数说明： *     vexs  -- 顶点数组 *     vlen  -- 顶点数组的长度 *     matrix-- 矩阵(数据) */MatrixUDG::MatrixUDG(char vexs[], int vlen, int matrix[][9])&#123;    int i, j;    // 初始化&quot;顶点数&quot;和&quot;边数&quot;    mVexNum = vlen;    // 初始化&quot;顶点&quot;    for (i = 0; i &lt; mVexNum; i++)        mVexs[i] = vexs[i];    // 初始化&quot;边&quot;    for (i = 0; i &lt; mVexNum; i++)        for (j = 0; j &lt; mVexNum; j++)            mMatrix[i][j] = matrix[i][j];    // 统计边的数目    for (i = 0; i &lt; mVexNum; i++)        for (j = 0; j &lt; mVexNum; j++)            if (i!=j &amp;&amp; mMatrix[i][j]!=INF)                mEdgNum++;    mEdgNum /= 2;&#125;/* * 析构函数 */MatrixUDG::~MatrixUDG()&#123;&#125;/* * 返回ch在mMatrix矩阵中的位置 */int MatrixUDG::getPosition(char ch)&#123;    int i;    for(i=0; i&lt;mVexNum; i++)        if(mVexs[i]==ch)            return i;    return -1;&#125;/* * 读取一个输入字符 */char MatrixUDG::readChar()&#123;    char ch;    do &#123;        cin &gt;&gt; ch;    &#125; while(!((ch&gt;=&#39;a&#39;&amp;&amp;ch&lt;=&#39;z&#39;) || (ch&gt;=&#39;A&#39;&amp;&amp;ch&lt;=&#39;Z&#39;)));    return ch;&#125;/* * 返回顶点v的第一个邻接顶点的索引，失败则返回-1 */int MatrixUDG::firstVertex(int v)&#123;    int i;    if (v&lt;0 || v&gt;(mVexNum-1))        return -1;    for (i = 0; i &lt; mVexNum; i++)        if (mMatrix[v][i]!=0 &amp;&amp; mMatrix[v][i]!=INF)            return i;    return -1;&#125;/* * 返回顶点v相对于w的下一个邻接顶点的索引，失败则返回-1 */int MatrixUDG::nextVertex(int v, int w)&#123;    int i;    if (v&lt;0 || v&gt;(mVexNum-1) || w&lt;0 || w&gt;(mVexNum-1))        return -1;    for (i = w + 1; i &lt; mVexNum; i++)        if (mMatrix[v][i]!=0 &amp;&amp; mMatrix[v][i]!=INF)            return i;    return -1;&#125;/* * 深度优先搜索遍历图的递归实现 */void MatrixUDG::DFS(int i, int *visited)&#123;    int w;    visited[i] = 1;    cout &lt;&lt; mVexs[i] &lt;&lt; &quot; &quot;;    // 遍历该顶点的所有邻接顶点。若是没有访问过，那么继续往下走    for (w = firstVertex(i); w &gt;= 0; w = nextVertex(i, w))    &#123;        if (!visited[w])            DFS(w, visited);    &#125;&#125;/* * 深度优先搜索遍历图 */void MatrixUDG::DFS()&#123;    int i;    int visited[MAX];       // 顶点访问标记    // 初始化所有顶点都没有被访问    for (i = 0; i &lt; mVexNum; i++)        visited[i] = 0;    cout &lt;&lt; &quot;DFS: &quot;;    for (i = 0; i &lt; mVexNum; i++)    &#123;        //printf(&quot;\n== LOOP(%d)\n&quot;, i);        if (!visited[i])            DFS(i, visited);    &#125;    cout &lt;&lt; endl;&#125;/* * 广度优先搜索（类似于树的层次遍历） */void MatrixUDG::BFS()&#123;    int head = 0;    int rear = 0;    int queue[MAX];     // 辅组队列    int visited[MAX];   // 顶点访问标记    int i, j, k;    for (i = 0; i &lt; mVexNum; i++)        visited[i] = 0;    cout &lt;&lt; &quot;BFS: &quot;;    for (i = 0; i &lt; mVexNum; i++)    &#123;        if (!visited[i])        &#123;            visited[i] = 1;            cout &lt;&lt; mVexs[i] &lt;&lt; &quot; &quot;;            queue[rear++] = i;  // 入队列        &#125;        while (head != rear)        &#123;            j = queue[head++];  // 出队列            for (k = firstVertex(j); k &gt;= 0; k = nextVertex(j, k)) //k是为访问的邻接顶点            &#123;                if (!visited[k])                &#123;                    visited[k] = 1;                    cout &lt;&lt; mVexs[k] &lt;&lt; &quot; &quot;;                    queue[rear++] = k;                &#125;            &#125;        &#125;    &#125;    cout &lt;&lt; endl;&#125;/* * 打印矩阵队列图 */void MatrixUDG::print()&#123;    int i,j;    cout &lt;&lt; &quot;Martix Graph:&quot; &lt;&lt; endl;    for (i = 0; i &lt; mVexNum; i++)    &#123;        for (j = 0; j &lt; mVexNum; j++)            cout &lt;&lt; setw(10) &lt;&lt; mMatrix[i][j] &lt;&lt; &quot; &quot;;        cout &lt;&lt; endl;    &#125;&#125;/* * prim最小生成树 * * 参数说明： *   start -- 从图中的第start个元素开始，生成最小树 */void MatrixUDG::prim(int start)&#123;    int min,i,j,k,m,n,sum;    int index=0;         // prim最小树的索引，即prims数组的索引    char prims[MAX];     // prim最小树的结果数组    int weights[MAX];    // 顶点间边的权值    // prim最小生成树中第一个数是&quot;图中第start个顶点&quot;，因为是从start开始的。    prims[index++] = mVexs[start];    // 初始化&quot;顶点的权值数组&quot;，    // 将每个顶点的权值初始化为&quot;第start个顶点&quot;到&quot;该顶点&quot;的权值。    for (i = 0; i &lt; mVexNum; i++ )        weights[i] = mMatrix[start][i];    // 将第start个顶点的权值初始化为0。    // 可以理解为&quot;第start个顶点到它自身的距离为0&quot;。    weights[start] = 0;    for (i = 0; i &lt; mVexNum; i++)    &#123;        // 由于从start开始的，因此不需要再对第start个顶点进行处理。        if(start == i)            continue;        j = 0;        k = 0;        min = INF;        // 在未被加入到最小生成树的顶点中，找出权值最小的顶点。        while (j &lt; mVexNum)        &#123;            // 若weights[j]=0，意味着&quot;第j个节点已经被排序过&quot;(或者说已经加入了最小生成树中)。            if (weights[j] != 0 &amp;&amp; weights[j] &lt; min)            &#123;                min = weights[j];                k = j;            &#125;            j++;        &#125;        // 经过上面的处理后，在未被加入到最小生成树的顶点中，权值最小的顶点是第k个顶点。        // 将第k个顶点加入到最小生成树的结果数组中        prims[index++] = mVexs[k];        // 将&quot;第k个顶点的权值&quot;标记为0，意味着第k个顶点已经排序过了(或者说已经加入了最小树结果中)。        weights[k] = 0;        // 当第k个顶点被加入到最小生成树的结果数组中之后，更新其它顶点的权值。        for (j = 0 ; j &lt; mVexNum; j++)        &#123;            // 当第j个节点没有被处理，并且需要更新时才被更新。            if (weights[j] != 0 &amp;&amp; mMatrix[k][j] &lt; weights[j])                weights[j] = mMatrix[k][j];        &#125;    &#125;    // 计算最小生成树的权值    sum = 0;    for (i = 1; i &lt; index; i++)    &#123;        min = INF;        // 获取prims[i]在mMatrix中的位置        n = getPosition(prims[i]);        // 在vexs[0...i]中，找出到j的权值最小的顶点。        for (j = 0; j &lt; i; j++)        &#123;            m = getPosition(prims[j]);            if (mMatrix[m][n]&lt;min)                min = mMatrix[m][n];        &#125;        sum += min;    &#125;    // 打印最小生成树    cout &lt;&lt; &quot;PRIM(&quot; &lt;&lt; mVexs[start] &lt;&lt; &quot;)=&quot; &lt;&lt; sum &lt;&lt; &quot;: &quot;;    for (i = 0; i &lt; index; i++)        cout &lt;&lt; prims[i] &lt;&lt; &quot; &quot;;    cout &lt;&lt; endl;&#125;/* * 获取图中的边 */EData* MatrixUDG::getEdges()&#123;    int i,j;    int index=0;    EData *edges;    edges = new EData[mEdgNum];    for (i=0; i &lt; mVexNum; i++)    &#123;        for (j=i+1; j &lt; mVexNum; j++)        &#123;            if (mMatrix[i][j]!=INF)            &#123;                edges[index].start  = mVexs[i];                edges[index].end    = mVexs[j];                edges[index].weight = mMatrix[i][j];                index++;            &#125;        &#125;    &#125;    return edges;&#125;/* * 对边按照权值大小进行排序(由小到大) */void MatrixUDG::sortEdges(EData* edges, int elen)&#123;    int i,j;    for (i=0; i&lt;elen; i++)    &#123;        for (j=i+1; j&lt;elen; j++)        &#123;            if (edges[i].weight &gt; edges[j].weight)            &#123;                // 交换&quot;边i&quot;和&quot;边j&quot;                swap(edges[i], edges[j]);            &#125;        &#125;    &#125;&#125;/* * 获取i的终点 */int MatrixUDG::getEnd(int vends[], int i)&#123;    while (vends[i] != 0)        i = vends[i];    return i;&#125;/* * 克鲁斯卡尔（Kruskal)最小生成树 */void MatrixUDG::kruskal()&#123;    int i,m,n,p1,p2;    int length;    int index = 0;          // rets数组的索引    int vends[MAX]=&#123;0&#125;;     // 用于保存&quot;已有最小生成树&quot;中每个顶点在该最小树中的终点。    EData rets[MAX];        // 结果数组，保存kruskal最小生成树的边    EData *edges;           // 图对应的所有边    // 获取&quot;图中所有的边&quot;    edges = getEdges();    // 将边按照&quot;权&quot;的大小进行排序(从小到大)    sortEdges(edges, mEdgNum);    for (i=0; i&lt;mEdgNum; i++)    &#123;        p1 = getPosition(edges[i].start);      // 获取第i条边的&quot;起点&quot;的序号        p2 = getPosition(edges[i].end);        // 获取第i条边的&quot;终点&quot;的序号        m = getEnd(vends, p1);                 // 获取p1在&quot;已有的最小生成树&quot;中的终点        n = getEnd(vends, p2);                 // 获取p2在&quot;已有的最小生成树&quot;中的终点        // 如果m!=n，意味着&quot;边i&quot;与&quot;已经添加到最小生成树中的顶点&quot;没有形成环路        if (m != n)        &#123;            vends[m] = n;                       // 设置m在&quot;已有的最小生成树&quot;中的终点为n            rets[index++] = edges[i];           // 保存结果        &#125;    &#125;    delete[] edges;    // 统计并打印&quot;kruskal最小生成树&quot;的信息    length = 0;    for (i = 0; i &lt; index; i++)        length += rets[i].weight;    cout &lt;&lt; &quot;Kruskal=&quot; &lt;&lt; length &lt;&lt; &quot;: &quot;;    for (i = 0; i &lt; index; i++)        cout &lt;&lt; &quot;(&quot; &lt;&lt; rets[i].start &lt;&lt; &quot;,&quot; &lt;&lt; rets[i].end &lt;&lt; &quot;) &quot;;    cout &lt;&lt; endl;&#125;/* * Dijkstra最短路径。 * 即，统计图中&quot;顶点vs&quot;到其它各个顶点的最短路径。 * * 参数说明： *       vs -- 起始顶点(start vertex)。即计算&quot;顶点vs&quot;到其它顶点的最短路径。 *     prev -- 前驱顶点数组。即，prev[i]的值是&quot;顶点vs&quot;到&quot;顶点i&quot;的最短路径所经历的全部顶点中，位于&quot;顶点i&quot;之前的那个顶点。 *     dist -- 长度数组。即，dist[i]是&quot;顶点vs&quot;到&quot;顶点i&quot;的最短路径的长度。 */void MatrixUDG::dijkstra(int vs, int prev[], int dist[])&#123;    int i,j,k;    int min;    int tmp;    int flag[MAX];      // flag[i]=1表示&quot;顶点vs&quot;到&quot;顶点i&quot;的最短路径已成功获取。    // 初始化    for (i = 0; i &lt; mVexNum; i++)    &#123;        flag[i] = 0;              // 顶点i的最短路径还没获取到。        prev[i] = 0;              // 顶点i的前驱顶点为0。        dist[i] = mMatrix[vs][i]; // 顶点i的最短路径为&quot;顶点vs&quot;到&quot;顶点i&quot;的权。    &#125;    // 对&quot;顶点vs&quot;自身进行初始化    flag[vs] = 1;    dist[vs] = 0;    // 遍历mVexNum-1次；每次找出一个顶点的最短路径。    for (i = 1; i &lt; mVexNum; i++)    &#123;        // 寻找当前最小的路径；        // 即，在未获取最短路径的顶点中，找到离vs最近的顶点(k)。        min = INF;        for (j = 0; j &lt; mVexNum; j++)        &#123;            if (flag[j]==0 &amp;&amp; dist[j]&lt;min)            &#123;                min = dist[j];                k = j;            &#125;        &#125;        // 标记&quot;顶点k&quot;为已经获取到最短路径        flag[k] = 1;        // 修正当前最短路径和前驱顶点        // 即，当已经&quot;顶点k的最短路径&quot;之后，更新&quot;未获取最短路径的顶点的最短路径和前驱顶点&quot;。        for (j = 0; j &lt; mVexNum; j++)        &#123;            tmp = (mMatrix[k][j]==INF ? INF : (min + mMatrix[k][j]));            if (flag[j] == 0 &amp;&amp; (tmp  &lt; dist[j]) )            &#123;                dist[j] = tmp;                prev[j] = k;            &#125;        &#125;    &#125;    // 打印dijkstra最短路径的结果    cout &lt;&lt; &quot;dijkstra(&quot; &lt;&lt; mVexs[vs] &lt;&lt; &quot;): &quot; &lt;&lt; endl;    for (i = 0; i &lt; mVexNum; i++)        cout &lt;&lt; &quot;  shortest(&quot; &lt;&lt; mVexs[vs] &lt;&lt; &quot;, &quot; &lt;&lt; mVexs[i] &lt;&lt; &quot;)=&quot; &lt;&lt; dist[i] &lt;&lt; endl;&#125;/* * floyd最短路径。 * 即，统计图中各个顶点间的最短路径。 * * 参数说明： *     path -- 路径。path[i][j]=k表示，&quot;顶点i&quot;到&quot;顶点j&quot;的最短路径会经过顶点k。 *     dist -- 长度数组。即，dist[i][j]=sum表示，&quot;顶点i&quot;到&quot;顶点j&quot;的最短路径的长度是sum。 */void MatrixUDG::floyd(int path[][MAX], int dist[][MAX])&#123;    int i,j,k;    int tmp;    // 初始化    for (i = 0; i &lt; mVexNum; i++)    &#123;        for (j = 0; j &lt; mVexNum; j++)        &#123;            dist[i][j] = mMatrix[i][j];    // &quot;顶点i&quot;到&quot;顶点j&quot;的路径长度为&quot;i到j的权值&quot;。            path[i][j] = j;                // &quot;顶点i&quot;到&quot;顶点j&quot;的最短路径是经过顶点j。        &#125;    &#125;    // 计算最短路径    for (k = 0; k &lt; mVexNum; k++)    &#123;        for (i = 0; i &lt; mVexNum; i++)        &#123;            for (j = 0; j &lt; mVexNum; j++)            &#123;                // 如果经过下标为k顶点路径比原两点间路径更短，则更新dist[i][j]和path[i][j]                tmp = (dist[i][k]==INF || dist[k][j]==INF) ? INF : (dist[i][k] + dist[k][j]);                if (dist[i][j] &gt; tmp)                &#123;                    // &quot;i到j最短路径&quot;对应的值设，为更小的一个(即经过k)                    dist[i][j] = tmp;                    // &quot;i到j最短路径&quot;对应的路径，经过k                    path[i][j] = path[i][k];                &#125;            &#125;        &#125;    &#125;    char dot[] = &#123;&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;, &#39;G&#39;, &#39;H&#39;, &#39;I&#39;&#125;;    // 打印floyd最短路径的结果    cout &lt;&lt; &quot;floyd各个地点的最短路径矩阵如下: &quot; &lt;&lt; endl;    cout &lt;&lt; &quot;    &quot;;    for (int k = 0;k&lt;9;k++)&#123;        cout &lt;&lt; dot[k] &lt;&lt; &quot;    &quot;;    &#125;    cout &lt;&lt; &quot;\n&quot;;    for (i = 0; i &lt; mVexNum; i++)&#123;        cout &lt;&lt; dot[i] &lt;&lt; &quot;: &quot;;        for (j = 0; j &lt; mVexNum; j++)            cout &lt;&lt; setw(2) &lt;&lt; dist[i][j] &lt;&lt; &quot;  &quot;;        cout &lt;&lt; endl;    &#125;&#125;int main()&#123;    int prev[MAX] = &#123;0&#125;;    int dist[MAX] = &#123;0&#125;;    int path[MAX][MAX] = &#123;0&#125;;    // 用于保存floyd路径    int floy[MAX][MAX] = &#123;0&#125;;    // 用于保存floyd长度    char vexs[] = &#123;&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;, &#39;G&#39;, &#39;H&#39;, &#39;I&#39;&#125;;    int matrix[][9] = &#123;                      /*A*//*B*//*C*//*D*//*E*//*F*//*G*//*H*//*I*/      /*A西门*/     &#123;   0,  615, 435, 210, 790,  INF,  INF, INF, INF&#125;,      /*B550教室*/  &#123; 615,   0,  144, 620, 380,   822, INF, INF, INF&#125;,      /*C文宗楼*/   &#123; 435,  144,   0,   INF,   265,   INF, INF, INF, INF&#125;,      /*D二餐*/     &#123; 210, 620,   INF,   0,   480, INF, INF, INF, 170&#125;,      /*E图书馆*/   &#123; 790, 380,   265,   480,   0,   620,   735, 310, 700&#125;,      /*F北门*/     &#123; INF, 822,   INF,   INF,   620,   0,   500, INF, INF&#125;,      /*G体育馆*/   &#123; INF, INF,   INF,   INF,   735,   500,   0, 556, INF&#125;,      /*H一餐*/     &#123;  INF,   INF,   INF, INF,   310,   INF,   556, 0, 420&#125;,      /*I16号楼*/   &#123;  INF, INF, INF, 170,   700,   INF,   INF, 420, 0&#125;&#125;;    int vlen = sizeof(vexs)/sizeof(vexs[0]);    MatrixUDG* pG;    // 自定义&quot;图&quot;(输入矩阵队列)    //pG = new MatrixUDG();    // 采用已有的&quot;图&quot;    pG = new MatrixUDG(vexs, vlen, matrix);    //pG-&gt;print();   // 打印图    //pG-&gt;DFS();     // 深度优先遍历    //pG-&gt;BFS();     // 广度优先遍历    //pG-&gt;prim(0);   // prim算法生成最小生成树    //pG-&gt;kruskal(); // Kruskal算法生成最小生成树    // dijkstra算法获取&quot;第4个顶点&quot;到其它各个顶点的最短距离    //pG-&gt;dijkstra(3, prev, dist);    // floyd算法获取各个顶点之间的最短距离    pG-&gt;floyd(path, floy);    return 0;&#125;</code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://houbb.github.io/2020/01/23/data-struct-learn-03-graph-dijkstra">图最短路径算法之迪杰斯特拉算法（Dijkstra）</a></li><li><a href="https://www.cnblogs.com/skywang12345/p/3711526.html">Floyd 算法(二)之 C++详解</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
          <category> 贪心算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Prim最小生成树算法</title>
      <link href="blog/zxbb8i/"/>
      <url>blog/zxbb8i/</url>
      
        <content type="html"><![CDATA[<p>这是加密文章！</p>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
          <category> 贪心算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>图的遍历——DFS（深度优先）、BFS（广度优先）</title>
      <link href="blog/ztiag3/"/>
      <url>blog/ztiag3/</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1621307069176-74d6900b-6edd-4e7a-b761-789df7a17cfe.png#align=left&display=inline&height=273&id=W9sKH&margin=%5Bobject%20Object%5D&name=image.png&originHeight=545&originWidth=1126&size=159926&status=done&style=stroke&width=563" alt="image.png"></p><div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">用邻接矩阵和邻接表两种图的存储形式实现DFS、BFS算法，并附例子实现。总的来说，邻接矩阵比较好处理，没有邻接表处理那么复杂，但是数组永远不能规避的一个缺点就是内存的占用较邻接表高。</div><h2 id="一、深度优先搜索算法（Depth-First-Search）"><a href="#一、深度优先搜索算法（Depth-First-Search）" class="headerlink" title="一、深度优先搜索算法（Depth-First-Search）"></a>一、深度优先搜索算法（Depth-First-Search）</h2><h3 id="算法说明"><a href="#算法说明" class="headerlink" title="算法说明"></a>算法说明</h3><p><strong>访问步骤：</strong></p><blockquote><ul><li>访问顶点 v；</li><li>依次从 v 的未被访问的邻接点出发，对图进行深度优先遍历；直至图中和 v 有路径相通的顶点都被访问；</li><li>若此时图中尚有顶点未被访问，则从一个未被访问的顶点出发，重新进行深度优先遍历，直到图中所有顶点均被访问过为止。</li></ul></blockquote><p><strong>核心代码就是利用递归，以及标志数组的设定，每次访问数组元素的那一行，对那行链表进行遍历，每遍历一个链表结点，就将“其”所在的那个数组元素“点亮”。如果标志数组里面的所有元素都被访问了，说明遍历完了</strong></p><p><strong>深度优先搜索类似于树里面遍历算法当中的先序遍历。</strong></p><h3 id="邻接矩阵的-DFS-代码"><a href="#邻接矩阵的-DFS-代码" class="headerlink" title="邻接矩阵的 DFS 代码"></a>邻接矩阵的 DFS 代码</h3><p>以这个无向图为例<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1621329549870-b2fd8a63-a532-4860-8e46-a79cc52a7e0f.png#align=left&display=inline&height=156&id=Xvwlk&margin=%5Bobject%20Object%5D&name=image.png&originHeight=311&originWidth=394&size=45059&status=done&style=stroke&width=197" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1621329584016-32d023fe-dc14-4c0d-90e1-7afe6fcc9cd2.png#align=left&display=inline&height=106&id=XY5Cd&margin=%5Bobject%20Object%5D&name=image.png&originHeight=212&originWidth=455&size=9480&status=done&style=none&width=227.5" alt="image.png"></p><pre><code class="cpp">#include&lt;bits/stdc++.h&gt;using namespace std;#define MVNum 100#define MaxInt 32767typedef char VerTexType;typedef int ArcType;/** * 邻接矩阵存储形式 */typedef struct &#123;    /* data */    VerTexType vexs[MVNum]; //顶点表    ArcType arcs[MVNum][MVNum]; //邻接矩阵    int vexnum, arcnum; //图的当前顶点和边数&#125;AMGraph;/** * 确定v在G中的位置，即顶点数组的下标 */int LocateVex(AMGraph &amp;G, char v) &#123;    for (int i = 0; i &lt; G.vexnum;i++) &#123;        if (v == G.vexs[i])&#123;            return i;        &#125;    &#125;&#125;/** * 如果创建无向图 */void CreateUDN(AMGraph &amp;G) &#123;    // 采用邻接矩阵表示法，创建无向图G    cout &lt;&lt; &quot;请输入顶点数和边数：&quot; &lt;&lt; endl;    cin &gt;&gt; G.vexnum &gt;&gt; G.arcnum; //输入顶点数和边数    // 初始化顶点    for (int i = 0; i &lt; G.vexnum;i++)&#123;        cout &lt;&lt; &quot;请输入第&quot; &lt;&lt; i &lt;&lt; &quot;个顶点值&quot; &lt;&lt; endl;        cin &gt;&gt; G.vexs[i];    &#125;    // 初始化邻接矩阵的边的权值为最大值    for (int i = 0; i &lt; G.vexnum;i++) &#123;        for (int j = 0; j &lt; G.vexnum;j++) &#123;            G.arcs[i][j] = 0;        &#125;    &#125;    // 构造邻接矩阵    for (int k = 0; k &lt; G.arcnum;k++) &#123;        cout &lt;&lt; &quot;请输入每条边所依附的顶点：&quot; &lt;&lt; endl;        char v1, v2;        int w = 1; //一条边所依附的顶点和权值        cin &gt;&gt; v1 &gt;&gt; v2;        int i = LocateVex(G, v1);        int j = LocateVex(G, v2);        G.arcs[i][j] = w;        G.arcs[j][i] = w;    &#125;&#125;/** * 打印输出图 */void Display(AMGraph &amp;G) &#123;    for (int i = 0; i &lt; G.vexnum;i++) &#123;        for (int j = 0; j &lt; G.vexnum;j++) &#123;            cout &lt;&lt; G.arcs[i][j] &lt;&lt; &quot; &quot;;        &#125;        cout &lt;&lt; endl;    &#125;&#125;//----邻接矩阵的DFS遍历----//访问标志数组，其初值为falsebool visited[MVNum];/** * 图G为邻接矩阵类型，从第v个顶点出发深度优先搜索遍历图G */void DFS_AM(AMGraph &amp;G, int v) &#123;    //访问第v个顶点，并置访问标志数组相应分量值为true    cout&lt;&lt;v;    visited[v] = true;    //依次检查邻接矩阵v所在的行    for(int w = 0; w &lt; G.vexnum; w++)        //G.arcs[v][w] != 0表示w是v的邻接点，!visited[w]表示未访问到        if((G.arcs[v][w] != 0) &amp;&amp; (!visited[w]))            DFS_AM(G, w);    //递归调用DFS_AM&#125;/** * 图G的储存类型任意，对非连通图G做深度优先遍历 */void DFSTraverse(AMGraph &amp;G) &#123;    //访问标志数组初始化    for(int v = 0; v &lt; G.vexnum; v++)        visited[v] = false;    //循环调用DFS    for(int v = 0; v &lt; G.vexnum; v++)        if(!visited[v])            DFS_AM(G, v); //对尚未访问的顶点调用DFS&#125;int main() &#123;    AMGraph test;    CreateUDN(test);    Display(test);    DFSTraverse(test);    return 0;&#125;</code></pre><h3 id="邻接表的-DFS-代码"><a href="#邻接表的-DFS-代码" class="headerlink" title="邻接表的 DFS 代码"></a>邻接表的 DFS 代码</h3><p>举之前上课的一张 PPT 例子（元素插入为后插法）<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1621333199678-46b6841b-415b-46e8-b0f6-0d0407284b15.png#align=left&display=inline&height=413&id=HmOsr&margin=%5Bobject%20Object%5D&name=image.png&originHeight=826&originWidth=1108&size=102467&status=done&style=none&width=554" alt="image.png"><br>结果<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1621333246481-117ec0ea-ab95-43be-ac13-75712fdf1e2b.png#align=left&display=inline&height=107&id=KjOYY&margin=%5Bobject%20Object%5D&name=image.png&originHeight=214&originWidth=444&size=26415&status=done&style=none&width=222" alt="image.png"></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;#define MVNum 100#define MaxInt 32767typedef char VerTexType;typedef int OtherInfo;/** * 邻接表存储 *//** * 存储结构 */typedef struct ArcNode &#123;  //边结点    int adjvex;  //该边所指向的结点的位置    struct ArcNode *nextarc; //指向下一条边的指针    OtherInfo info;   //和边相关的其他信息&#125;ArcNode;typedef struct VNode &#123;   //顶点信息    VerTexType data;  //数据域，存放顶点vi的名称或其他有关信息    ArcNode *firstarc;  //指向第一条依附该顶点的边的指针&#125;VNode, AdjList[MVNum]; //AdjList表示邻接表的类型typedef struct &#123;    AdjList vertices;    int vexnum, arcnum; //图当前的顶点数和边数&#125;ALGragh; //邻接表（Adjacency List）/** * 找到v顶点在图的顶点数组中的位置 */int LocateVex(ALGragh &amp;G, char v) &#123;    for (int i = 0; i &lt; G.vexnum;i++) &#123;        if (v == G.vertices[i].data) &#123;            return i;        &#125;    &#125;&#125;/** * 邻接表创建无向图 */void CreateUDG(ALGragh &amp;G) &#123;    cout &lt;&lt; &quot;请输入顶点数和边数：&quot; &lt;&lt; endl;    cin &gt;&gt; G.vexnum &gt;&gt; G.arcnum; // 邻接表的顶点数和边数    // 初始化顶点数组    for (int i = 0; i &lt; G.vexnum;i++) &#123;        cin &gt;&gt; G.vertices[i].data; // 初始化顶点数组里面的结点data        G.vertices[i].firstarc = NULL; // 初始化顶点数组里面的结点next域    &#125;    // 初始化所有的边    for (int k = 0; k &lt; G.arcnum;k++) &#123;        char v1, v2;        cout &lt;&lt; &quot;请输入每条边所依附的顶点：&quot; &lt;&lt; endl;        cin &gt;&gt; v1 &gt;&gt; v2;        int i = LocateVex(G, v1); // 找到v1在顶点数组的下标        int j = LocateVex(G, v2); // 找到v2在顶点数组的下标        // 下面建立p1和p2是因为无向图，如果是有向图就没必要了只需要p1        // 前插        ArcNode *p1 = new ArcNode;        p1-&gt;adjvex = j;        p1-&gt;nextarc = G.vertices[i].firstarc;        G.vertices[i].firstarc = p1;        ArcNode *p2 = new ArcNode;        p2-&gt;adjvex = i;        p2-&gt;nextarc = G.vertices[j].firstarc;        G.vertices[j].firstarc = p2;    &#125;&#125;/** * 打印输出图 */void Display(ALGragh &amp;G) &#123;    for (int i = 0; i &lt; G.vexnum;i++) &#123;        cout &lt;&lt; &quot;结点&quot; &lt;&lt; i &lt;&lt; &quot;：&quot;;        // 复制选中的节点数组中的结点        VNode p;        p = G.vertices[i];        if (p.firstarc != NULL)&#123;            ArcNode *temp;            temp = G.vertices[i].firstarc;            while (temp != NULL) &#123;                cout &lt;&lt; temp-&gt;adjvex&lt;&lt;&quot; &quot;;                temp = temp-&gt;nextarc;            &#125;            cout &lt;&lt; &quot;\n&quot;;        &#125;    &#125;&#125;//----邻接表的DFS遍历----bool visited[MVNum];                                                    //访问标志数组，其初值为falsevoid DFS_AL(ALGragh G, int v)&#123;//图G为邻接表类型，从从第v个顶点出发深度优先搜索遍历图G    cout&lt;&lt;v;                                                            //访问第v个顶点，并置访问标志数组相应分量值为true    visited[v] = true;    ArcNode *p;    p = G.vertices[v].firstarc;                                         //p指向v的边链表的第一个边结点    while(p != NULL)    &#123;       int w = p-&gt;adjvex;                                               //w是v的邻接点        if(!visited[w])                                                 //如果w未访问            DFS_AL(G, w);                                               //递归调用DFS_AL        p = p-&gt;nextarc;                                                 //p指向下一个结点    &#125;&#125;void DFSTraverse(ALGragh G)&#123;//图G的储存类型任意，对非连通图G做深度优先遍历    for(int v = 0; v &lt; G.vexnum; v++)                                   //访问标志数组初始化        visited[v] = false;    for(int v = 0; v &lt; G.vexnum; v++)                                   //循环调用DFS        if(!visited[v])            DFS_AL(G, v);                                                  //对尚未访问的顶点调用DFS&#125;int main() &#123;    ALGragh test;    CreateUDG(test);    // Display(test);    DFSTraverse(test);&#125;</code></pre><h2 id="二、广度优先搜索算法（Breadth-First-Search）"><a href="#二、广度优先搜索算法（Breadth-First-Search）" class="headerlink" title="二、广度优先搜索算法（Breadth-First-Search）"></a>二、广度优先搜索算法（Breadth-First-Search）</h2><h3 id="算法说明-1"><a href="#算法说明-1" class="headerlink" title="算法说明"></a>算法说明</h3><p>从某个顶点 V0 出发，并在访问此顶点之后依次访问 V0 的所有未被访问过的邻接点，之后按这些顶点被访问的先后次序依次访问它们的邻接点，直至图中所有和 V0 有路径相通的顶点都被访问到。<br>若此时图中尚有顶点未被访问，则另选图中一个未曾被访问的顶点作起始点，重复上述过程，直至图中所有顶点都被访问到为止。</p><h3 id="邻接矩阵的-BFS-代码"><a href="#邻接矩阵的-BFS-代码" class="headerlink" title="邻接矩阵的 BFS 代码"></a>邻接矩阵的 BFS 代码</h3><p>还是这个例子<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1621329549870-b2fd8a63-a532-4860-8e46-a79cc52a7e0f.png#align=left&display=inline&height=156&id=bbWIn&margin=%5Bobject%20Object%5D&name=image.png&originHeight=311&originWidth=394&size=45059&status=done&style=stroke&width=197" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1621338913834-3f2453f3-c56d-4401-9e26-2de805587a04.png#align=left&display=inline&height=125&id=hRiOt&margin=%5Bobject%20Object%5D&name=image.png&originHeight=250&originWidth=457&size=12403&status=done&style=none&width=228.5" alt="image.png"></p><pre><code class="cpp">#include&lt;bits/stdc++.h&gt;using namespace std;#define MVNum 100#define MaxInt 32767typedef char VerTexType;typedef int ArcType;/** * 邻接矩阵的bfs代码 */typedef struct &#123;    /* data */    VerTexType vexs[MVNum]; //顶点表    ArcType arcs[MVNum][MVNum]; //邻接矩阵    int vexnum, arcnum; //图的当前顶点和边数&#125;AMGraph;/** * 确定v在G中的位置，即顶点数组的下标 */int LocateVex(AMGraph &amp;G, char v) &#123;    for (int i = 0; i &lt; G.vexnum;i++) &#123;        if (v == G.vexs[i])&#123;            return i;        &#125;    &#125;&#125;/** * 创建无向网 * 如果创建无向图 */void CreateUDN(AMGraph &amp;G) &#123;    // 采用邻接矩阵表示法，创建无向图G    cout &lt;&lt; &quot;请输入顶点数和边数：&quot; &lt;&lt; endl;    cin &gt;&gt; G.vexnum &gt;&gt; G.arcnum; //输入顶点数和边数    // 初始化顶点    for (int i = 0; i &lt; G.vexnum;i++)&#123;        cout &lt;&lt; &quot;请输入第&quot; &lt;&lt; i &lt;&lt; &quot;个顶点值&quot; &lt;&lt; endl;        cin &gt;&gt; G.vexs[i];    &#125;    // 初始化邻接矩阵的边的权值为最大值    for (int i = 0; i &lt; G.vexnum;i++) &#123;        for (int j = 0; j &lt; G.vexnum;j++) &#123;            G.arcs[i][j] = 0;        &#125;    &#125;    // 构造邻接矩阵    for (int k = 0; k &lt; G.arcnum;k++) &#123;        cout &lt;&lt; &quot;请输入每条边所依附的顶点：&quot; &lt;&lt; endl;        char v1, v2;        int w = 1; //一条边所依附的顶点和权值        cin &gt;&gt; v1 &gt;&gt; v2;        int i = LocateVex(G, v1);        int j = LocateVex(G, v2);        G.arcs[i][j] = w;        G.arcs[j][i] = w;    &#125;&#125;/** * 打印输出图 */void Display(AMGraph &amp;G) &#123;    for (int i = 0; i &lt; G.vexnum;i++) &#123;        for (int j = 0; j &lt; G.vexnum;j++) &#123;            cout &lt;&lt; G.arcs[i][j] &lt;&lt; &quot; &quot;;        &#125;        cout &lt;&lt; endl;    &#125;&#125;//----邻接矩阵的BFS遍历----bool visited[MVNum];void BFS_AM(AMGraph G, int v)&#123;//按广度优先非递归遍历连通图G    cout&lt;&lt;v;    visited[v] = true; //访问第v个顶点，并置访问标志数组相应分量值为true    queue&lt;int&gt; Q;    Q.push(v);    while(!Q.empty())    &#123;        int u = Q.front(); //队头元素出队并置为u        Q.pop();        for(int w = 0; w &lt; G.vexnum; w++)            if((G.arcs[u][w] != 0) &amp;&amp; (!visited[w])) //G.arcs[v][w] != 0表示w是v的邻接点，!visited[w]表示未访问到                                            //w为u的尚未访问的邻接顶点            &#123;                cout&lt;&lt;w;                visited[w] = true; //访问w，并置访问标志数组相应分量值为true                Q.push(w); //w进队            &#125;    &#125;&#125;void BFSTraverse(AMGraph &amp;G) &#123;    //访问标志数组初始化    for(int v = 0; v &lt; G.vexnum; v++)        visited[v] = false;    //循环调用BFS    for(int v = 0; v &lt; G.vexnum; v++)        if(!visited[v])            BFS_AM(G, v); //对尚未访问的顶点调用BFS&#125;int main() &#123;    AMGraph test;    CreateUDN(test);    Display(test);    // DFSTraverse(test);    BFSTraverse(test);    return 0;&#125;</code></pre><h3 id="邻接表的-BFS-代码"><a href="#邻接表的-BFS-代码" class="headerlink" title="邻接表的 BFS 代码"></a>邻接表的 BFS 代码</h3><p>还用和 DFS 一样的例子<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1621339344717-55530db9-253b-451d-af57-b591ff17353e.png#align=left&display=inline&height=311&id=I73u9&margin=%5Bobject%20Object%5D&name=image.png&originHeight=621&originWidth=834&size=114652&status=done&style=none&width=417" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1621390194148-da12a2e4-1f85-491b-9e53-3848ac4e4a4c.png#align=left&display=inline&height=80&margin=%5Bobject%20Object%5D&name=image.png&originHeight=159&originWidth=334&size=6124&status=done&style=none&width=167" alt="image.png"></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;#define MVNum 100#define MaxInt 32767typedef char VerTexType;typedef int OtherInfo;/** * 邻接表的bfs代码 *//** * 存储结构 */typedef struct ArcNode &#123;  //边结点    int adjvex;  //该边所指向的结点的位置    struct ArcNode *nextarc; //指向下一条边的指针    OtherInfo info;   //和边相关的其他信息&#125;ArcNode;typedef struct VNode &#123;   //顶点信息    VerTexType data;  //数据域，存放顶点vi的名称或其他有关信息    ArcNode *firstarc;  //指向第一条依附该顶点的边的指针&#125;VNode, AdjList[MVNum]; //AdjList表示邻接表的类型typedef struct &#123;    AdjList vertices;    int vexnum, arcnum; //图当前的顶点数和边数&#125;ALGraph; //邻接表（Adjacency List）/** * 找到v顶点在图的顶点数组中的位置 */int LocateVex(ALGraph &amp;G, char v) &#123;    for (int i = 0; i &lt; G.vexnum;i++) &#123;        if (v == G.vertices[i].data) &#123;            return i;        &#125;    &#125;&#125;/** * 邻接表创建无向图 */void CreateUDG(ALGraph &amp;G) &#123;    cout &lt;&lt; &quot;请输入顶点数和边数：&quot; &lt;&lt; endl;    cin &gt;&gt; G.vexnum &gt;&gt; G.arcnum; // 邻接表的顶点数和边数    // 初始化顶点数组    for (int i = 0; i &lt; G.vexnum;i++) &#123;        cin &gt;&gt; G.vertices[i].data; // 初始化顶点数组里面的结点data        G.vertices[i].firstarc = NULL; // 初始化顶点数组里面的结点next域    &#125;    // 初始化所有的边    for (int k = 0; k &lt; G.arcnum;k++) &#123;        char v1, v2;        cout &lt;&lt; &quot;请输入每条边所依附的顶点：&quot; &lt;&lt; endl;        cin &gt;&gt; v1 &gt;&gt; v2;        int i = LocateVex(G, v1); // 找到v1在顶点数组的下标        int j = LocateVex(G, v2); // 找到v2在顶点数组的下标        // 下面建立p1和p2是因为无向图，如果是有向图就没必要了只需要p1        // 前插        ArcNode *p1 = new ArcNode;        p1-&gt;adjvex = j;        p1-&gt;nextarc = G.vertices[i].firstarc;        G.vertices[i].firstarc = p1;        ArcNode *p2 = new ArcNode;        p2-&gt;adjvex = i;        p2-&gt;nextarc = G.vertices[j].firstarc;        G.vertices[j].firstarc = p2;    &#125;&#125;/** * 打印输出图 */void Display(ALGraph &amp;G) &#123;    for (int i = 0; i &lt; G.vexnum;i++) &#123;        cout &lt;&lt; &quot;结点&quot; &lt;&lt; i &lt;&lt; &quot;：&quot;;        // 复制选中的节点数组中的结点        VNode p;        p = G.vertices[i];        if (p.firstarc != NULL)&#123;            ArcNode *temp;            temp = G.vertices[i].firstarc;            while (temp != NULL) &#123;                cout &lt;&lt; temp-&gt;adjvex&lt;&lt;&quot; &quot;;                temp = temp-&gt;nextarc;            &#125;            cout &lt;&lt; &quot;\n&quot;;        &#125;    &#125;&#125;//----邻接表的BFS遍历----bool visited[MVNum];int FirstAdjvex(ALGraph&amp; G, int u)&#123;    int w = G.vertices[u].firstarc-&gt;adjvex;    return w;&#125;int NextAdjVex(ALGraph&amp; G, int u, int w)&#123;    ArcNode *temp = G.vertices[u].firstarc;    while (temp-&gt;adjvex != w)    &#123;        temp = temp-&gt;nextarc;    &#125;    if (temp-&gt;nextarc)        return temp-&gt;nextarc-&gt;adjvex;    else        return -1;    delete temp;&#125;void BFS_AL(ALGraph&amp; G, int v)&#123;    cout &lt;&lt; v;    visited[v] = true;    queue&lt;int&gt; Q;    Q.push(v);    int u = v;    while (!Q.empty())&#123;        u = Q.front();        Q.pop();        for (int w = FirstAdjvex(G, u); w &gt;= 0; w = NextAdjVex(G, u, w))&#123;            if (!visited[w])&#123;                cout &lt;&lt;w;                visited[w] = true;                Q.push(w);            &#125;        &#125;    &#125;&#125;void BFSTraverse(ALGraph &amp;G) &#123;    //访问标志数组初始化    for(int v = 0; v &lt; G.vexnum; v++)        visited[v] = false;    //循环调用BFS    for(int v = 0; v &lt; G.vexnum; v++)        if(!visited[v])            BFS_AL(G, v); //对尚未访问的顶点调用BFS&#125;int main() &#123;    ALGraph test;    CreateUDG(test);    Display(test);    BFSTraverse(test);&#125;</code></pre><div style="background: #FFF3F3;padding:10px;border: 1px solid #DEB8BE;border-radius:5px;margin-bottom:5px;">【插眼】为啥我写的一个函数不需要队列也可以？？？直接将顶点数组的一个元素后面接的链表遍历不就好了，然后再遍历标志数组元素值部位true的不就好了。。。为啥要压队列呀？莫不是哪里有隐藏的bug，插个眼！！！</div><p><img src="https://cdn.nlark.com/yuque/0/2021/gif/1484158/1621340205400-d534997e-4b20-4f0e-8db6-4a91e39c68b6.gif#align=left&display=inline&height=134&id=Ivn4n&margin=%5Bobject%20Object%5D&originHeight=134&originWidth=218&status=done&style=stroke&width=218"></p><div style="background: #edf9e8;padding:10px;border: 1px solid #c2d2b5;border-radius:5px;margin-bottom:5px;">【拔眼】这样是一种特殊情况，只适合图的各个结点是按照层次标号的，并且放入标志数组也是按照顺序放入的……</div><p>插眼代码如下：</p><pre><code class="cpp">void BFS_AL(ALGraph &amp;G, int v)&#123;//按广度优先非递归遍历连通图G    cout&lt;&lt;v;    visited[v] = true;    //访问第v个顶点，并置访问标志数组相应分量值为true    ArcNode *p;    p = G.vertices[v].firstarc;    if (p != NULL) &#123;        while(p != NULL) &#123;            if (!visited[p-&gt;adjvex])&#123;                cout &lt;&lt; p-&gt;adjvex;            &#125;            visited[p-&gt;adjvex] = true;            p = p-&gt;nextarc;        &#125;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> DataStructure </category>
          
          <category> 图结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>图的各种存储</title>
      <link href="blog/gqpli5/"/>
      <url>blog/gqpli5/</url>
      
        <content type="html"><![CDATA[<p>数据结构一般就四种关系</p><ul><li>集合</li><li>线性</li><li>树</li><li>图</li></ul><h2 id="图的一些术语"><a href="#图的一些术语" class="headerlink" title="图的一些术语"></a>图的一些术语</h2><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1621256644397-9e2a9a9a-c3f9-4bfe-af9d-d3eec44c16b2.png#align=left&display=inline&height=351&id=ue0b15b96&margin=%5Bobject%20Object%5D&name=image.png&originHeight=702&originWidth=998&size=434452&status=done&style=stroke&width=499" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1621256670453-caccc927-2510-4119-9452-a588b6f590e5.png#align=left&display=inline&height=291&id=u1e1a40e2&margin=%5Bobject%20Object%5D&name=image.png&originHeight=581&originWidth=952&size=365443&status=done&style=stroke&width=476" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1621256694543-32b41537-3bc7-4515-b8e9-eb56b026d2a7.png#align=left&display=inline&height=334&id=uee62fe0a&margin=%5Bobject%20Object%5D&name=image.png&originHeight=667&originWidth=940&size=432681&status=done&style=stroke&width=470" alt="image.png"></p><h2 id="图存储：邻接矩阵"><a href="#图存储：邻接矩阵" class="headerlink" title="图存储：邻接矩阵"></a>图存储：邻接矩阵</h2><div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">创建无向网</div><pre><code class="cpp">#include&lt;bits/stdc++.h&gt;using namespace std;#define MVNum 100#define MaxInt 32767typedef char VerTexType;typedef int ArcType;/** * 邻接矩阵存储形式 */typedef struct &#123;    /* data */    VerTexType vexs[MVNum]; //顶点表    ArcType arcs[MVNum][MVNum]; //邻接矩阵    int vexnum, arcnum; //图的当前顶点和边数&#125;AMGraph;/** * 确定v在G中的位置，即顶点数组的下标 */int LocateVex(AMGraph &amp;G, char v) &#123;    for (int i = 0; i &lt; G.vexnum;i++) &#123;        if (v == G.vexs[i])&#123;            return i;        &#125;    &#125;&#125;/** * 创建无向网 * 如果创建无向图 */void CreateUDN(AMGraph &amp;G) &#123;    // 采用邻接矩阵表示法，创建无向图G    cout &lt;&lt; &quot;请输入顶点数和边数：&quot; &lt;&lt; endl;    cin &gt;&gt; G.vexnum &gt;&gt; G.arcnum; //输入顶点数和边数    // 初始化顶点    for (int i = 0; i &lt; G.vexnum;i++)&#123;        cout &lt;&lt; &quot;请输入第&quot; &lt;&lt; i &lt;&lt; &quot;个顶点值&quot; &lt;&lt; endl;        cin &gt;&gt; G.vexs[i];    &#125;    // 初始化邻接矩阵的边的权值为最大值    for (int i = 0; i &lt; G.vexnum;i++) &#123;        for (int j = 0; j &lt; G.vexnum;j++) &#123;            G.arcs[i][j] = MaxInt;        &#125;    &#125;    // 构造邻接矩阵    for (int k = 0; k &lt; G.arcnum;k++) &#123;        cout &lt;&lt; &quot;请输入每条边所依附的顶点和权值：&quot; &lt;&lt; endl;        char v1, v2;        int w; //一条边所依附的顶点和权值        cin &gt;&gt; v1 &gt;&gt; v2 &gt;&gt; w;        int i = LocateVex(G, v1);        int j = LocateVex(G, v2);        G.arcs[i][j] = w;        G.arcs[j][i] = w;    &#125;&#125;void Display(AMGraph &amp;G) &#123;    for (int i = 0; i &lt; G.vexnum;i++) &#123;        for (int j = 0; j &lt; G.vexnum;j++) &#123;            cout &lt;&lt; G.arcs[i][j] &lt;&lt; &quot; &quot;;        &#125;        cout &lt;&lt; endl;    &#125;&#125;int main() &#123;    AMGraph test;    // CreateUDN(test);    Display(test);&#125;</code></pre><div style="background: #FFFBE6;padding:10px;border: 1px solid #C3C3C3;border-radius:5px;margin-bottom:5px;">创建无向图</div>对`CreateUDN` 进行处理：<ul><li>G.arcs[i][j] = MaxInt;改为 G.arcs[i][j] = 0;</li><li>将 w 改为常量 1 即可</li></ul><div style="background: #FFFBE6;padding:10px;border: 1px solid #C3C3C3;border-radius:5px;margin-bottom:5px;">创建有向网</div>对`CreateUDN` 进行处理：<ul><li>删除 G.arcs[j][i] = w;</li></ul><div style="background: #FFFBE6;padding:10px;border: 1px solid #C3C3C3;border-radius:5px;margin-bottom:5px;">创建有向图</div>对`CreateUDN` 进行处理：<ul><li>删除 G.arcs[j][i] = w;</li></ul><h2 id="图存储：邻接表"><a href="#图存储：邻接表" class="headerlink" title="图存储：邻接表"></a>图存储：邻接表</h2><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;#define MVNum 100#define MaxInt 32767typedef char VerTexType;typedef int OtherInfo;/** * 邻接表存储 *//** * 存储结构 */typedef struct ArcNode &#123;                      //边结点    int adjvex;                             //该边所指向的结点的位置    struct ArcNode *nextarc;                //指向下一条边的指针    OtherInfo info;                         //和边相关的其他信息&#125;ArcNode;typedef struct VNode &#123;                        //顶点信息    VerTexType data;                        //数据域，存放顶点vi的名称或其他有关信息    ArcNode *firstarc;                      //指向第一条依附该顶点的边的指针&#125;VNode, AdjList[MVNum];                     //AdjList表示邻接表的类型typedef struct &#123;    AdjList vertices;    int vexnum, arcnum;                     //图当前的顶点数和边数&#125;ALGragh;                                   //邻接表（Adjacency List）/** * 找到v顶点在图中的位置 */int LocateVex(ALGragh &amp;G, char v) &#123;    for (int i = 0; i &lt; G.vexnum;i++) &#123;        if (v == G.vertices[i].data) &#123;            return i;        &#125;    &#125;&#125;/** * 邻接表创建无向图 */void CreateUDG(ALGragh &amp;G) &#123;    cin &gt;&gt; G.vexnum &gt;&gt; G.arcnum; // 邻接表的顶点数和边数    for (int i = 0; i &lt; G.vexnum;i++) &#123;        cin &gt;&gt; G.vertices[i].data;        G.vertices[i].firstarc = NULL;    &#125;    for (int k = 0; k &lt; G.arcnum;k++) &#123;        char v1, v2;        cin &gt;&gt; v1 &gt;&gt; v2;        int i = LocateVex(G, v1);        int j = LocateVex(G, v2);        ArcNode *p1 = new ArcNode;        p1-&gt;adjvex = j;        p1-&gt;nextarc = G.vertices[i].firstarc;        G.vertices[i].firstarc = p1;        ArcNode *p2 = new ArcNode;        p2-&gt;adjvex = i;        p2-&gt;nextarc = G.vertices[j].firstarc;        G.vertices[j].firstarc = p1;    &#125;&#125;</code></pre><h2 id="有向图：十字链表存储"><a href="#有向图：十字链表存储" class="headerlink" title="有向图：十字链表存储"></a>有向图：十字链表存储</h2><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef int Status;#define OK 1;//----有向图的十字链表储存表示----#define MAX_VERTEX_NUM 20typedef char VerTexType;typedef int InfoType;typedef struct ArcBox&#123;    int tailvex, headvex;                   //该弧的头尾和头顶点的位置    struct ArcBox *hlink, *tlink;            //分别为弧头相同和弧尾相同的链域    InfoType *info;                         //该弧相关信息的指针&#125;ArcBox;typedef struct VexNode&#123;    VerTexType data;    ArcBox *firstin, *firstout;             //分别指向该顶点的第一项入弧和出弧&#125;VexNode;typedef struct&#123;    VexNode xlist[MAX_VERTEX_NUM];          //表头向量    int vexnum, arcnum;                     //有向图的当前顶点数和弧数&#125;OLGraph;                                   //十字链表（Orthogonal List）</code></pre><h2 id="无向图：邻接多重表存储"><a href="#无向图：邻接多重表存储" class="headerlink" title="无向图：邻接多重表存储"></a>无向图：邻接多重表存储</h2><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef int Status;#define OK 1;//----无向图的邻接多重表储存表示----#define MAX_VERTEX_NUM 20typedef char VerTexType;typedef int InfoType;typedef enum&#123;    unvisited, visited                     //枚举unvisited是0，visited是1，注意没有分号&#125;VisitIf;typedef struct EBox&#123;    VisitIf mark;                           //访问标记    int ivex, jvex;                         //该边依附的两个顶点的位置    struct EBox *ilink, *jlink;             //分别指向依附这两个顶点的下一条边    InfoType *info;                         //该边的信息指针&#125;EBox;typedef struct VexBox&#123;    VerTexType data;    EBox *firstedge;                        //指向第一条依附该顶点的边&#125;VexBox;typedef struct&#123;    VexBox adjmulist[MAX_VERTEX_NUM];    int vexnum, arcnum;                     //无向图当前的顶点数和边数&#125;AMLGraph;                                  //邻接多重表(Adjacency Multilist)</code></pre><h2 id="其他：边集数组"><a href="#其他：边集数组" class="headerlink" title="其他：边集数组"></a>其他：边集数组</h2><h2 id="其他：链式前向星"><a href="#其他：链式前向星" class="headerlink" title="其他：链式前向星"></a>其他：链式前向星</h2>]]></content>
      
      
      <categories>
          
          <category> DataStructure </category>
          
          <category> 图结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>『灵笼』——灵魂的牢笼</title>
      <link href="essay/pnapfw/"/>
      <url>essay/pnapfw/</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1621244428291-8f947575-4da5-4938-a3fa-09f21bed0925.png#align=left&display=inline&height=1080&id=ijJPU&margin=%5Bobject%20Object%5D&name=Snipaste_2021-05-17_17-38-3d5.png&originHeight=1080&originWidth=1920&size=17146&status=done&style=none&width=1920" alt="Snipaste_2021-05-17_17-38-3d5.png"></p><p>看了五集，觉得剧情设定方面有浓浓的进击的巨人和 Darling in the franxx 这两部番那味了（去论坛看了看，果然有吐槽的…不过都在说巨人，我更加觉得和国家队的世界观很像）…但不管怎么说，剧情设定和画质方面在国漫里面也是可圈可点～</p><p>灵笼，灵魂的牢笼，就像是巨壁<br>重立体，立体机动装置（就不能叫个重装甲啥的，害<img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1621243721740-de5b6182-0bb1-4971-95bf-1309c0fdfb1d.jpeg#align=left&display=inline&height=58&id=rboSG&margin=%5Bobject%20Object%5D&originHeight=58&originWidth=79&status=done&style=stroke&width=79"><br>猎荒者，调查兵团<br>荷光者，宪兵团<br>……</p><p>我之前对 darling 里面的是『心』这个人物，我当时的感受是整部番的点睛之笔，在世界观的角度上，拉伸高度，在灵笼这里被设定为佩妮这个角色……<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1621244183522-a0ab8144-4141-4887-895b-a5b3e6230613.png#align=left&display=inline&height=1080&id=VgAwl&margin=%5Bobject%20Object%5D&name=Snipaste_2021-05-17_17-35-00.png&originHeight=1080&originWidth=1920&size=1267727&status=done&style=none&width=1920" alt="Snipaste_2021-05-17_17-35-00.png"></p><p>这些说实话，感受的挺多了，用这部番里面的一个词就是——躯壳。希望后面的剧情能挖掘出作品的闪光之处～</p><hr><p>EP6<br><img src="https://cdn.nlark.com/yuque/0/2021/jpg/1484158/1621262671765-0831d8b9-f8eb-4a16-acc0-1b8d622ff5b8.jpg#align=left&display=inline&height=146&id=OlIMX&margin=%5Bobject%20Object%5D&originHeight=815&originWidth=1975&status=done&style=none&width=354"><br><img src="https://cdn.nlark.com/yuque/0/2021/jpg/1484158/1621262686893-e61922ea-e1b5-4fa8-82ac-cabc2ef60391.jpg#align=left&display=inline&height=805&id=fQ07I&margin=%5Bobject%20Object%5D&originHeight=805&originWidth=1349&status=done&style=none&width=1349"><br>不管这个世界再怎么变，人性永远在那，就像爱情……</p><p>或许我在想，即便这个世界颠倒了，文明是一个全新的面貌，人性或许是那诸多不变的点之一。</p><hr><p><img src="https://cdn.nlark.com/yuque/0/2021/jpg/1484158/1621472984542-d6010263-d430-4ab7-ac8d-4f911c4d4bf3.jpg#align=left&display=inline&height=834&id=mKa4W&margin=%5Bobject%20Object%5D&originHeight=834&originWidth=2083&status=done&style=none&width=2083"><br>万万没想到系列，冉冰居然凉凉～</p><hr><p>终章+特别篇<br><img src="https://cdn.nlark.com/yuque/0/2021/jpg/1484158/1621473001235-cb79d2e3-6a7e-4556-92b4-33ea9d442010.jpg#align=left&display=inline&height=824&id=gBT7O&margin=%5Bobject%20Object%5D&originHeight=824&originWidth=1996&status=done&style=none&width=1996"></p><p>这波用灯塔来反衬地面幸存者的存在的意义，都知道噬极兽会以人类的情感来孕育，灯塔是颁布三大法令来限制灯塔上的人的情感，以此来让灯塔幸存于这乱世，地面幸存者则是相反，情感不但不能舍弃，反而要坚守</p><p>至于白月魁，直接将这部番提升到修仙境界了<img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1622037065067-007f3642-a1e3-4f60-862b-af2e1013c8ec.jpeg#align=left&display=inline&height=77&id=MR71l&margin=%5Bobject%20Object%5D&originHeight=77&originWidth=77&status=done&style=none&width=77">，就是人类中靠修炼而成的外挂，和阿克曼一族利威尔兵长是一类人，人类最强。</p><p><img src="https://cdn.nlark.com/yuque/0/2021/jpg/1484158/1621473476256-6440f355-2230-47d7-9a2d-cc3a92afa850.jpg#align=left&display=inline&height=1128&id=TxJXz&margin=%5Bobject%20Object%5D&originHeight=1128&originWidth=2400&status=done&style=none&width=2400"></p>]]></content>
      
      
      <categories>
          
          <category> 人生影视课 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[转]竞赛常用STL容器详解</title>
      <link href="blog/porzdi/"/>
      <url>blog/porzdi/</url>
      
        <content type="html"><![CDATA[<blockquote><p>转载自：<a href="https://blog.csdn.net/weixin_43844677/article/details/104902417">https://blog.csdn.net/weixin_43844677/article/details/104902417</a><br>部分内容个人修改补充</p></blockquote><h2 id="一、-概述"><a href="#一、-概述" class="headerlink" title="一、 概述"></a>一、 概述</h2><p>在算法竞赛中，使用 C++语言的占很大比例，而几乎没有人使用 C 语言，其中核心的原因就是 C++包含 STL 容器库，能够极大地减少选手在赛场上为了一些基础数据结构而浪费的时间。诚然，花一两分钟实现一个 stack、queue 甚至 priority_queue 都不是什么大问题，但如果需要实现 BBST（Balanced Binary Search Tree）的情况呢？如果可以的话，我们总是希望不要手写红黑树、动态数组的。那么 STL 容器库的出现就像雪中送炭一样了。它们覆盖了竞赛中最基础的需要（张昆玮树、主席树这种东西肯定不会包含的），让你在面对非数据结构题的时候能够不因数据结构部分的代码而分心。<br>关于 STL 容器的相关问题非常细，经常成为面试中的考题，这里我们仅讨论一些必须的内容，然后只谈论在竞赛中的具体使用。<br>首先给出一张表格（来自 cppreference）：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1621221298404-a6bf5daf-fd5b-4504-a4d0-f80b17dc5899.png#height=845&id=Rv9rY&originHeight=845&originWidth=1778&originalType=binary%E2%88%B6=1&size=0&status=done&style=none&width=1778"><br>这张表格中给出了各种容器支持的成员函数，在大多数停留在 C++14 和 C++11 版本的测试平台中，只有紫色、绿色部分是可用的。<br>在考察具体的容器的时候，出于竞赛中的需要，我们不会涵盖以上的全部，而是着重关注以下几点：</p><ol><li><strong>随机访问</strong></li><li><strong>插入和删除</strong></li><li><strong>端点访问</strong></li><li><strong>迭代器类型（总结以上几点）</strong></li><li><strong>时间复杂度</strong></li></ol><p>事实上，综合以上几点，就可以得出一个容器的作用。容器的作用是由它支持的操作及其时间复杂度决定的，并不是说，容器的名字叫做 set 我就一定把它当作集合来用。从 ADT 的角度来说，<strong>数据结构=接口+接口的复杂度</strong>。而从另一个角度来看，容器内部支持的逻辑操作决定了它能够使用的迭代器类型，而这决定了外部可能存在哪些接口，因此也可以说<strong>数据结构=内部存储+迭代器</strong>。这样两种观点，能够在使用的层面加强我们对于 STL 容器的理解。<br>方便起见，这里先列出一个汇总的表格，包含了竞赛中常用的几种数据结构：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1621221298080-23300f65-22c0-48b6-895a-324e3793fed5.png#height=355&id=PnAJG&originHeight=355&originWidth=857&originalType=binary%E2%88%B6=1&size=0&status=done&style=none&width=857"><br>这里的表格只给出了很简单的内容，本文末尾会给出两个总结性的表格，给出具体操作的函数名和时间复杂度。</p><h2 id="二、-迭代器"><a href="#二、-迭代器" class="headerlink" title="二、 迭代器"></a>二、 迭代器</h2><h3 id="2-1-迭代器与遍历"><a href="#2-1-迭代器与遍历" class="headerlink" title="2.1.迭代器与遍历"></a>2.1.迭代器与遍历</h3><p>操作一个容器，无法脱离它提供的工具——<strong>迭代器</strong>。即使没有使用过容器，我们也一定使用过最基本的方式遍历一个数组：</p><pre><code>for (int i = 0; i &lt;n;i++)    //......</code></pre><p>不严格地说，这里的”i”就可以视作一个最原始的迭代器。事实上，对于藉由它，我们可以访问一个容器内的全部内容——这就是我们所说的“遍历”，这能够让我们对内部数据进行基于元素的操作。<br>事实上，一个真正的迭代器需要符合很多要求。STL 容器所配备的迭代器都属于 C++迭代器库规定的六种之一，它们是：</p><ol><li><strong>遗留输入迭代器</strong></li><li><strong>遗留向前迭代器</strong></li><li><strong>遗留双向迭代器</strong></li><li><strong>遗留随机访问迭代器</strong></li><li><strong>遗留输出迭代器</strong></li><li><strong>遗留连续迭代器</strong></li></ol><p>这些名字看起来很唬人，让我们来一点一点解释。<br>首先，它们都是“<strong>遗留迭代器</strong>”，这意味着它们都：（以下假设 i 是迭代器）</p><ul><li>可<strong>解引用</strong>（*i 得到元素）</li><li>可<strong>前自增</strong>（++i 得到下一位置）</li></ul><p>这也就是为何我们能藉由迭代器来完成遍历容器内元素的操作。<br>下面给出上文提到的六种迭代器的实际含义，虽然大多数情况下竞赛中用不到这些原理，但偶尔会有基于手动遍历的技巧性操作，这时候也许需要你对迭代器有一定的认知：<br><strong>遗留输入迭代器：</strong><br>在<strong>遗留迭代器</strong>的基础上，</p><ul><li>可<strong>不等比较</strong>（i!=j 有定义）</li><li>可<strong>后自增</strong>（i++有定义）</li></ul><p>但：<strong>自增后，先前值可能失效。</strong>也就是说，当你访问第 1 个元素时，可能无法通过这个迭代器的拷贝访问第 0 个元素。<br><strong>遗留向前迭代器：</strong><br>在<strong>遗留输入迭代器</strong>的基础上，</p><ul><li><strong>自增后保证先前值不失效。</strong></li></ul><p><strong>遗留双向迭代器：</strong><br>在<strong>遗留向前迭代器</strong>的基础上，</p><ul><li>可<strong>前自减</strong>（–i 有定义）</li><li>可<strong>后自减</strong>（i–有定义）</li></ul><p><strong>遗留随机访问迭代器：</strong><br>在<strong>遗留双向迭代器</strong>的基础上，</p><ul><li>有<strong>下标</strong>运算符（i[n]有定义）</li><li>有<strong>比较</strong>运算符（&gt;、&lt;、&gt;=、&lt;=有定义）</li><li>可按<strong>增量移动</strong>（+、-、+=、-=有定义）</li></ul><p>且：<strong>迭代器移动只耗费常数时间。</strong><br>_若以上迭代器满足<strong>遗留输出迭代器</strong>的标准，那么称它们是“可变迭代器”。_<br><strong>遗留输出迭代器：</strong><br>在<strong>遗留迭代器</strong>的基础上：</p><ul><li>可<strong>赋值</strong>（*i=something 有定义）</li><li>可<strong>后自增</strong></li></ul><p>_若以上迭代器满足<strong>遗留连续迭代器</strong>的标准，那么称它们是“连续迭代器”。_<br><strong>遗留连续迭代器：</strong><br>在<strong>遗留迭代器</strong>的基础上：</p><ul><li>逻辑相邻元素在内存中也相邻，</li><li>即：<code>*(i + n)</code> 等价于 <code>*(std::addressof(*i) + n)</code></li></ul><p>以上涉及的运算，不仅需要定义，并且需要符合功能要求。同时，部分操作有特例存在。例如，即使迭代器可解引用，也无法对尾后迭代器或孤立迭代器解引用。<br>那么，如果知道某个容器的迭代器类型，对比一下它们支持的操作，你就能知道自己的一些奇思妙想能否实现了。例如：两头向中间访问、一次跳过多个元素、多个迭代器同时访问……<br>那么，在复杂的环境下，例如访问的同时涉及插入和删除，这些操作还能按照我的意图运行吗？这就是我们要讨论的下一个问题了。如果说以上内容更偏向于实务开发，那么这个问题在竞赛中就更加常见了，它就是“迭代器失效”问题。</p><h3 id="2-2-迭代器失效"><a href="#2-2-迭代器失效" class="headerlink" title="2.2. 迭代器失效"></a>2.2. 迭代器失效</h3><p>容器的一些操作会使得先前声明的迭代器失去它应有的作用，这种限制来自于容器底层的实现。例如在 vector 中，即使在尾部插入一个新元素也可能因为导致空间达到临界值而使得数据全部被移动到新空间，从而使全部迭代器失效。<br>大体来说，删除总会使得迭代器失效，而插入有些情况会使其失效。具体的情形见下表：（同样来自 cppreference）<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1621221298154-92c7bf87-74b3-4fd5-9f62-d7ab6e5aa25b.png#height=525&id=N6O99&originHeight=525&originWidth=982&originalType=binary%E2%88%B6=1&size=0&status=done&style=none&width=982"><br>除此之外，尾后迭代器有一些特殊情形需要考虑，例如 vector 的尾后迭代器总是会被非法化、除了删除首元素外的修改操作都会非法化 deque 的尾后迭代器，等等。</p><h3 id="2-3-尾后迭代器"><a href="#2-3-尾后迭代器" class="headerlink" title="2.3. 尾后迭代器"></a>2.3. 尾后迭代器</h3><p>另一个要注意的点是，一般来说一个容器的 begin()返回的是指向容器内首个元素的迭代器，而 end()指向的却不是尾部元素，而是<strong>尾后</strong>——一个不存在的元素，我们也常常把这种位置称为“哨兵”。这一点好像恰好和其他参数为一个区间的函数，如 sort(), substr()等，对应了起来——似乎编程中所有涉及区间的操作，都是使用左开右闭区间来表示的——也就是说，end()表示尾后。这是为什么呢？<br>考虑对一个具有<strong>普通遗留迭代器</strong>的容器进行迭代，应当怎么写呢？似乎很简单：</p><pre><code>for (auto i = x.begin(); i != x.end(); i++)</code></pre><p>看到这里，你应当已经明白了：大多数容器不具有遗留连续迭代器的性质，那就不存在像<code>i &lt; x.end()</code>这种操作，因此无法像迭代一个数组一样以一个偏序比较作为条件，那么就必须有一个哨兵作为实际可以访问到的截止位，这个哨兵就是 end()。</p><h2 id="三、-Vector"><a href="#三、-Vector" class="headerlink" title="三、 Vector"></a>三、 Vector</h2><h3 id="3-1-总览"><a href="#3-1-总览" class="headerlink" title="3.1.总览"></a>3.1.总览</h3><p>那么，我们就开始讲每个具体的容器了。在各节中，我们会依次介绍每个容器的用途、迭代器类型、插查删操作及其复杂度，有必要的时候，我们还会介绍一些其他的小 trick。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1621221298034-6e429607-ece3-4c15-bd6a-e02efaf4d4f6.png#height=263&id=STppH&originHeight=263&originWidth=669&originalType=binary%E2%88%B6=1&size=0&status=done&style=none&width=669"><br>我们看到，Vector 与其他 STL 容器最大的区别就在于，只要元素不为 bool 类型（bool 类型因内存对齐而不连续），它是唯一使用<strong>连续迭代器</strong>的，即使对于全部情况，它也符合遗留随机访问迭代器，从而支持以常数复杂度通过下标运算符随机访问。这使得我们可以直接将其作为升级版的数组使用——数组的功能全部被它继承，而它又自带了其他一些便捷的函数——因此 vector 又被称为 <strong>“动态数组”</strong> 。<br>它底层的数据结构使用的是静态数组，实现动态扩容的奥秘在于，它在每一次容量占用达到阈值时就进行一次翻倍扩容，从而保证了均摊  O ( 1 ) O(1) O(1)的时间复杂度，而又能节省空间。</p><h3 id="3-2-常见用法"><a href="#3-2-常见用法" class="headerlink" title="3.2.常见用法"></a>3.2.常见用法</h3><p>在 C++11 中，在具有 begin()和 end()的范围上进行迭代，有一种简便写法，那就是</p><pre><code>for (auto&amp; v : container)</code></pre><p>它等价于</p><pre><code>for (auto&amp; v = container.begin(); v != container.end(); v++)</code></pre><p>这里的 auto 利用了 C++11 的另一个特性——类型推导，这只是一个语法糖，它使我们不必写上 container::iterator 这一串复杂的类型，而在程序运行中与完整键入的并无区别。而 auto 后面加的&amp;代表 v 是一个左值引用，那么我们就可以通过 v 来修改容器中的元素。而如果我们想避免这种修改，可以去掉&amp;，这时 v 就是一个右值拷贝。<br>以一个 int 类型动态数组为例，我们可以这样输出：</p><pre><code>vector&lt;int&gt; arr;for (auto v : arr)    cout&lt;&lt;v;</code></pre><p>而读入可以这样写：</p><pre><code>for (int i = 1; i &lt;= n; i++)&#123;    cin&gt;&gt;temp;    arr.push_back(temp);&#125;</code></pre><p>当然，同程序员们默认的一样，它的下标是从 0 开始的。<br>vector 是否可以写高维数组呢？如果你经常在 Leetcode 上刷题，应当见过二维数组的这种写法：<code>vector&lt;vector&lt;int&gt;&gt;</code>。高维数组以此类推即可。在访问上，这种写法与<code>int arr[][]</code>没有任何区别。</p><h2 id="四、List"><a href="#四、List" class="headerlink" title="四、List"></a>四、List</h2><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1621221298094-bbd53e64-b82a-4b51-aa3a-f354b3bd7023.png#height=325&id=D1lAx&originHeight=325&originWidth=669&originalType=binary%E2%88%B6=1&size=0&status=done&style=none&width=669"><br>可以看到，list 实际上就是一个<strong>双向链表</strong>，因此对于插入和删除的操作具有优秀的时间表现。当然也很容易想到，list 是无法实现常数时间随机访问的，insert 和 erase 看起来时间复杂度为  O ( 1 ) O(1) O(1)，但在实际应用中，找到插入位置往往就需要  O ( n ) O(n) O(n)的时间。<br>与 list 相似的，STL 中还存在一个单向链表 forward_list。由于不需要反向链，它的空间占用有所减小，不过这一点在竞赛中不怎么需要，所以那种结构了解即可。</p><h2 id="五、Stack"><a href="#五、Stack" class="headerlink" title="五、Stack"></a>五、Stack</h2><h3 id="5-1-总览"><a href="#5-1-总览" class="headerlink" title="5.1.总览"></a>5.1.总览</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1621221298067-e4b7c1aa-ec7e-4535-a505-59440ac713db.png#height=181&id=Sfmf5&originHeight=181&originWidth=669&originalType=binary%E2%88%B6=1&size=0&status=done&style=none&width=669"><br>相比于精心构造的数据结构，stack 似乎更应当被称为一种“包装器”，它在底层实现的基础上屏蔽掉了一些功能，从而使自身表现得更像一个物理栈。对于它和 queue，我们不需要多费口舌，也许这是仅有的两种我们可以自己实现而不会使代码冗长的数据结构了。但无论怎么说，有一个构造好的容器使用总是好的，它可以防止我们在底层的操作上犯一些愚蠢的错误。</p><h3 id="5-2-常见用法"><a href="#5-2-常见用法" class="headerlink" title="5.2.常见用法"></a>5.2.常见用法</h3><p>那么，这里就实际给出使用 stack 完成 DFS 的过程，以下是一段代码片段：</p><pre><code>vector&lt;int&gt; edges[N];    stack&lt;int&gt; dfs;    /*............*/    dfs.push(v0);    vis[v0] = true;    while (!dfs.empty())    &#123;        bool tag = false;        int now = dfs.top();        prt.push_back(now);        for (auto v : edges[now])            if (!vis[v])            &#123;                dfs.push(v);                vis[v] = true;                tag = true;                break;            &#125;        if (!tag)            dfs.pop();    &#125;</code></pre><h2 id="六、Deque-及其延伸"><a href="#六、Deque-及其延伸" class="headerlink" title="六、Deque 及其延伸"></a>六、Deque 及其延伸</h2><h3 id="6-1-Deque"><a href="#6-1-Deque" class="headerlink" title="6.1.Deque"></a>6.1.Deque</h3><p>虽然实际使用时很少见，但 deque 是很多 STL 容器的基础，stack 和 queue 都由它封装而来，它也支持相当多的操作，详见下表：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1621221298045-e627f316-cc63-4992-817c-f8025c1474df.png#height=378&id=yw0ii&originHeight=378&originWidth=669&originalType=binary%E2%88%B6=1&size=0&status=done&style=none&width=669"><br>值得注意的是，该容器的迭代器非法化情形比较有趣，其原理也是面试题常考的内容，建议结合 STL 源码深入分析。<br>结合上表，发现它与 List 的区别主要在于，它能够实现常数时间随机访问，但内部插入、删除却需要线性时间，这也符合他们底层实现：链表和数组的区别，也正是这一点使得它们的迭代器一个是双向而另一个是随机访问。多进行这种思考，由<strong>底层实现——容器——迭代器——操作</strong>转为<strong>底层实现——迭代器——操作</strong>，是一名程序员获得抽象思维的重要方式。</p><h3 id="6-2-Queue"><a href="#6-2-Queue" class="headerlink" title="6.2.Queue"></a>6.2.Queue</h3><h4 id="6-2-1-总览"><a href="#6-2-1-总览" class="headerlink" title="6.2.1.总览"></a>6.2.1.总览</h4><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1621221298045-979ccd1c-9d0c-4971-8323-beeb278dfecb.png#height=209&id=LTTqa&originHeight=209&originWidth=669&originalType=binary%E2%88%B6=1&size=0&status=done&style=none&width=669"><br>queue 就是我们常说的<strong>队列</strong>了。同 stack 一样，它是很常见而且简单的数据结构，同样由 deque 封装得来。当然，由于 deque 和 list 都满足它的底层实现的要求，因此你可以指明换用 list 作为你的 queue 的底层实现：</p><pre><code>queue&lt;int, list&lt;int&gt;&gt; myQue;</code></pre><p>由于 STL 容器都使用模板类，因此在实际开发中，你完全可以将所有容器的分配器、底层容器自主实现。</p><h4 id="6-2-2-常见用法"><a href="#6-2-2-常见用法" class="headerlink" title="6.2.2.常见用法"></a>6.2.2.常见用法</h4><p>queue 用来实现 BFS 应该是最常见的用法了，以下和 stack 一样给出一个代码片段：</p><pre><code>queue&lt;int&gt; que;    while (!que.empty())    &#123;        int now = que.front();        que.pop();        if (success(pos[now]))            return true;        for (int i = 0; i &lt; n; i++)            if (!vis[i] &amp;&amp; dis[now][i] &lt;= limit)            &#123;                que.push(i);                vis[i] = true;            &#125;    &#125;</code></pre><h3 id="6-3-Priority-Queue"><a href="#6-3-Priority-Queue" class="headerlink" title="6.3.Priority_Queue"></a>6.3.Priority_Queue</h3><h4 id="6-3-1-总览"><a href="#6-3-1-总览" class="headerlink" title="6.3.1.总览"></a>6.3.1.总览</h4><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1621221298072-4aa3333f-4fe3-4f4e-8f10-212345e22947.png#height=205&id=Qei4g&originHeight=205&originWidth=669&originalType=binary%E2%88%B6=1&size=0&status=done&style=none&width=669"><br>priority_queue 实现了优先队列这一 ADT，也就是我们常说的 <strong>“堆”</strong> 。但要明晰的是，优先队列是一种 ADT，而堆是它的一种具体实现。在默认状态下，priority_queue 实现的是大根堆，但你可以通过模板特化从而实现小根堆，甚至是自己定义的规则。</p><h4 id="6-3-2-常见用法"><a href="#6-3-2-常见用法" class="headerlink" title="6.3.2.常见用法"></a>6.3.2.常见用法</h4><p>实现小根堆的方式很简单:</p><pre><code>priority_queue&lt;int, vector&lt;int&gt;, std::greater&lt;int&gt;&gt; myHeap;</code></pre><p>其中第一个参数为元素类型，第二个类型为底层实现，默认为 vector，但 STL 库中的 deque 也符合要求。第三个参数为你的比较类型。priority_queue 会按照这一比较偏序将<strong>最末序</strong>的元素作为“最大元素”。<br>在 sort 函数中自己构造函数对象以指定排序方式的写法非常基础，但其实在优先队列中指定排序方式的写法也并不困难。在 sort 中，我们传入一个函数指针，sort 函数调用这个函数，获得它的返回值，从而得到元素之间的偏序。而在模板类中，由于<strong>需要在编译期就特化类</strong>，所以我们无法传入一个函数，而必须传入一个<strong>类</strong>。堆在排序时会<strong>调用其构造函数</strong>，获得构造函数的返回值，这整体上与我们给 sort 传参无异。<br>大多数情况下，我们可以使用 STL 提供的编译器函数库中的比较运算，例如小于是 less，大于等于是 greater_equal，等等。上面用于实现小根堆的 greater 源码如下：</p><pre><code>template&lt;typename _Tp&gt;    struct greater : public binary_function&lt;_Tp, _Tp, bool&gt;    &#123;        bool        operator()(const _Tp&amp; __x, const _Tp&amp; __y) const        &#123;     return __x &gt; __y; &#125;    &#125;;</code></pre><p>然而观察这一函数，它最终还是要调用具体类型的比较运算。那么如果我们给容器的类不具有偏序，或者我们需要特别指定偏序怎么办呢？下面给出一个实例。<br>例如，在图的搜索中我们需要存储点和它到源点的距离，那么我们的元素可能是这样的：</p><pre><code>typename int Vertex;typename int Distance;typename pair&lt;Vertex, Distance&gt; Dest;</code></pre><p>在 Dijkstra 算法中，用堆优化时我们需要建立边权的小根堆，那么就可以这样自建比较类型（我们知道自己要使用的类型，就不需要写成模板类了）：</p><pre><code>struct myGreater : public binary_function&lt;Dest, Dest, bool&gt;&#123;    bool operator() (const Dest &amp;lhs, const Dest &amp;rhs) const    &#123;     return lhs.second &gt; rhs.second; &#125;&#125;</code></pre><p>于是就可以这样建立基于边权的小根堆：</p><pre><code>priority_queue&lt;Dest, vector&lt;Dest&gt;, myGreater&gt; myHeap;</code></pre><h2 id="七、Set-及-Multiset"><a href="#七、Set-及-Multiset" class="headerlink" title="七、Set 及 Multiset"></a>七、Set 及 Multiset</h2><h3 id="7-1-总览"><a href="#7-1-总览" class="headerlink" title="7.1. 总览"></a>7.1. 总览</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1621221298126-cd7b73e2-055e-4325-8270-dadc26949011.png#height=210&id=fntg7&originHeight=210&originWidth=669&originalType=binary%E2%88%B6=1&size=0&status=done&style=none&width=669"><br>set 对应的 ADT 是<strong>集合</strong>：它支持元素的存储和查找，同时符合抽象意义上的集合要求——<strong>不允许出现重复元素</strong>。</p><h3 id="7-2-常见用法"><a href="#7-2-常见用法" class="headerlink" title="7.2. 常见用法"></a>7.2. 常见用法</h3><p>set 的一个重要用途就是<strong>排序同时去重</strong>。在 BST 家族中，理论表现最好的是 Fibonacci-heap，但由于常数过大，实际表现最好的数据结构其实是 set 所采用的底层结构红黑树。如果说排序去重可以通过使用一个 sort 函数加手工来完成，那么需要<strong>支持插入和查找</strong>的题目呢？莫非我们要手写 RBT 吗？这时候，一个深受考验的 set 无疑是广大竞赛选手的福音。<br>当然，在更多的情况下，我们需要<strong>允许数据中出现重复</strong>的元素，那么<strong>可以使用 multiset</strong>这种数据结构，它在其他地方与 set 无异，唯一的区别在于它允许重复元素的出现。<br>在容器中，find 函数在找不到对象的时候一般会返回 end，那么查找可以写作：</p><pre><code>if (c.find(x) != c.end())    //do something...</code></pre><h2 id="八、Map"><a href="#八、Map" class="headerlink" title="八、Map"></a>八、Map</h2><h3 id="8-1-总览"><a href="#8-1-总览" class="headerlink" title="8.1. 总览"></a>8.1. 总览</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1621221298068-5d1c0d5a-095f-44a8-92cd-fa4bc119ab01.png#height=209&id=dyk1Y&originHeight=209&originWidth=669&originalType=binary%E2%88%B6=1&size=0&status=done&style=none&width=669"></p><h3 id="8-2-常见用法"><a href="#8-2-常见用法" class="headerlink" title="8.2. 常见用法"></a>8.2. 常见用法</h3><p>map 和 set 非常类似，只不过它的数据是<strong>键值对</strong>而非一个单独的键，而<strong>键是唯一的</strong>。如果给它的用途举个例子，可以是存储源点到所有可达点的访问记录。<br>当然，同 map 一样，它也有允许键不唯一的版本，那就是<strong>multimap</strong>。本质上，<code>multimap&lt;Key, T&gt;</code>等价于<code>multiset&lt;pair&lt;Key, T&gt;, Comp&lt;pair&lt;Key, T&gt;&gt;, std::allocator&lt;std::pair&lt;Key, T&gt;&gt;&gt;</code>，其中 Comp 是自主实现的依据 Key 的比较类型。<br>也就是说，map 和 set 和 priority_queue 一样，支持特化比较类型，特化的方式也是一样的。只不过实际使用的时候，不要忘记最后一个模板参数，那是用于生成元素空间的分配器。</p><h2 id="九、总结"><a href="#九、总结" class="headerlink" title="九、总结"></a>九、总结</h2><p>本文最后，给出一个表格以供检索，相比于 cppreference 的总结，这里只列出了竞赛中常用的一些操作及其复杂度。begin()和 end()虽然较为常用，不过由于是全体容器必备的，所以不再列出。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1621221298131-b854f40d-40b6-42fb-a901-467032ef3583.png#height=164&id=Pt0mu&originHeight=164&originWidth=1321&originalType=binary%E2%88%B6=1&size=0&status=done&style=none&width=1321"><br>这样，这篇文章也就基本结束了。可以看到，为了照顾特定的使用需求，本文对容器具体的实现未做过多探讨，反而对通常不太重视的迭代器部分做了一定的讲解。在竞赛中掌握这些内容，已经能够满足几乎全部的需求了。但在实际应用中，掌握这些内容甚至不足以通过一个大厂的面试。例如，deque 的若是对容器原理有兴趣，可以找市面上评价较好的 STL 源码解读类书籍学习。</p>]]></content>
      
      
      <categories>
          
          <category> DataStructure </category>
          
          <category> 其他知识 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>多一些沉稳，少一点浮躁</title>
      <link href="essay/wrlggf/"/>
      <url>essay/wrlggf/</url>
      
        <content type="html"><![CDATA[<div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">在自己、同学、父母身上学到的一些关于沉稳和浮躁的相关感悟。</div>​<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1621129502175-8304c744-6269-4ca9-a89f-7180dbd6911c.png#clientId=u24aab093-34a5-4&from=ui&id=ue9157375&margin=%5Bobject%20Object%5D&name=81820014_p0.png&originHeight=822&originWidth=1920&originalType=binary&size=2480417&status=done&style=none&taskId=u45c6efd3-08f2-4e70-a006-a5bd0449320" alt="81820014_p0.png"></p><p><strong>多一些沉稳，少一些浮躁</strong><br>​</p><p>真正的技术人是不断去学习技术的，抑或是精进自己已有的技术，而不是像一个井底之蛙，不踏踏实实做技术，只想着一步登云，对技术而言，哪来的精进可言<br>​</p><p>这个节奏下面，很多人很多时候被生活牵着走，不再是我们过生活，而是生活过着我们，少了一些风情雅致，多了一些功利与欲望，就像是越肤浅的人，越浮躁，一新急于求成，功利心太重。越是有实力，能将生活活出自我的人越是沉稳安静，不急不躁，踏实努力，以梦为马，执笔为声！</p><p>上面说到功利了，于是乎想到了我父母做生意的那路历程，做生意不可能一直起势，有起就有落，可在一些人眼中，他们所看到的，永远只有起势和高光……大学三年之下，A 同学想着年薪百万，B 同学想着开公司，我觉得这都是可以的，我相信年轻的资本在人生历程中是占比很足的，但是现在细想，那些话的字体行间透露着些许的浮躁，我暂且用野心来代替那些话，我相信野心这个词，但这三年在学校的生活与对社会的前驱认知告诉我，野心是基于沉稳之上的，野心是基于踏实之上，野心更是对理想而拆解成一系列目标并予以实施的基础上的，多一些沉稳，少一些浮躁……</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>实验7——哈夫曼树</title>
      <link href="blog/fyhtb2/"/>
      <url>blog/fyhtb2/</url>
      
        <content type="html"><![CDATA[<h2 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h2><p>已知某系统在通信联络中只可能出现 n 种字符，其概率从键盘输入。试创建哈夫曼树。</p><h2 id="实验要求"><a href="#实验要求" class="headerlink" title="实验要求"></a>实验要求</h2><p>1、从键盘输入 n, 以及 n 个字符的概率。<br>例如：已知某系统在通信联络中只可能出现 n 种字符，其概率分别为   0.05, 0.29, 0.07, 0.08, 0.14, 0.23, 0.03, 0.11，试设计哈夫曼编码创建哈夫曼树。<br>2、用顺序存储。<br>3、输出结果如下<br> <img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1620964210279-ee3848d0-d031-4dc0-a850-3ae179b7a317.png#align=left&display=inline&height=194&id=lteAK&margin=%5Bobject%20Object%5D&name=image.png&originHeight=234&originWidth=377&size=83624&status=done&style=none&width=312" alt="image.png"><br>交作业时间：下次上机前</p><h2 id="实验代码"><a href="#实验代码" class="headerlink" title="实验代码"></a>实验代码</h2><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;int n, m, s1, s2;typedef struct HTNode&#123;    int weight, parent, lchild, rchild, pos;    bool operator&lt;(const HTNode &amp;a)const   &#123;       return a.weight &lt; weight;   &#125;&#125;HTNode, *HuffmanTree;priority_queue&lt;HTNode&gt;P;void Select(HuffmanTree &amp;HT, int ii, int &amp;s1, int &amp;s2)&#123;    HTNode t = P.top();    s1 = t.pos;    P.pop();    t = P.top();    s2 = t.pos;    P.pop();&#125;void CreateHuffmantree(HuffmanTree &amp;HT, int n)&#123;    if(n &lt;= 1)        return;    m = 2 * n - 1;    HT = new HTNode[m + 1];    for(int i = 1; i &lt;= m; i++)    &#123;        HT[i].parent = 0;        HT[i].lchild = 0;        HT[i].rchild = 0;    &#125;    for(int i = 1; i &lt;= n; ++i)    &#123;        cin &gt;&gt; HT[i].weight;        HT[i].pos = i;        P.push(HT[i]);    &#125;    for(int i = n + 1; i &lt;= m; i++)    &#123;        Select(HT, i - 1, s1, s2);        HT[s1].parent = i;        HT[s2].parent = i;        HT[i].lchild = s1;        HT[i].rchild = s2;        HT[i].weight = HT[s1].weight + HT[s2].weight;        HT[i].pos = i ;        P.push(HT[i]);    &#125;&#125;int main()&#123;    HuffmanTree HT;    cout &lt;&lt; &quot;请输入哈夫曼树的叶子结点个数：&quot;;    cin &gt;&gt; n;    cout &lt;&lt; &quot;请输入每个叶子结点的权值：&quot; &lt;&lt; &#39;\n&#39;;    CreateHuffmantree(HT, n);    for(int i = 1; i &lt;= 2 * n - 1; ++i)    &#123;        cout &lt;&lt; &quot;结点序号 &quot; &lt;&lt; i &lt;&lt; &quot; 权重 &quot; &lt;&lt; HT[i].weight        &lt;&lt; &quot; parent &quot; &lt;&lt; HT[i].parent &lt;&lt; &quot; lchild &quot; &lt;&lt; HT[i].lchild        &lt;&lt; &quot; rchild &quot; &lt;&lt; HT[i].rchild &lt;&lt; &#39;\n&#39;;    &#125;&#125;</code></pre><h2 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h2><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1621215937466-2f1ef720-c7ae-4103-bf0b-0f75855059ff.png#align=left&display=inline&height=246&id=mQROC&margin=%5Bobject%20Object%5D&name=image.png&originHeight=491&originWidth=738&size=72930&status=done&style=none&width=369" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> DataStructure </category>
          
          <category> 树结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>实验6——二叉树的创建与遍历</title>
      <link href="blog/ggimdr/"/>
      <url>blog/ggimdr/</url>
      
        <content type="html"><![CDATA[<h2 id="实验报告"><a href="#实验报告" class="headerlink" title="实验报告"></a>实验报告</h2><div style="background: #FFFBE6;padding:10px;border: 1px solid #C3C3C3;border-radius:5px;margin-bottom:5px;">编写一个程序，实现二叉树的各种运算，并在此基础上设计一个程序完成如下功能：</div><blockquote><p>（1）创建一棵二叉树（用键盘按照<strong>先序遍历</strong>序列输入一个字符串生成二叉树）；<br>（2）输出前序、中序、后序遍历的遍历序列；  <br>（3）统计并输出二叉树的的结点个数；<br>（4）输出二叉树的叶子结点的个数；(选做)</p></blockquote><div style="background: #FFFBE6;padding:10px;border: 1px solid #C3C3C3;border-radius:5px;margin-bottom:5px;">实验要求：</div><blockquote><p>用键盘输入一个字符串，按照<strong>满二叉树的特点</strong>生成一棵二叉树。</p></blockquote><div style="background: #FFFBE6;padding:10px;border: 1px solid #C3C3C3;border-radius:5px;margin-bottom:5px;">测试用例要求：</div><blockquote><p>如下二叉树的输入字符串为：ABD###C#E##<br>书写方法：碰到#说明该二叉树是一棵空树，注意分配（下面缺两个左右补两个#，缺一个左/右子树，补一个#）</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1620295747111-4774a4a6-b617-4f26-a0c3-f9f1bdb386cc.png#align=left&display=inline&height=139&margin=%5Bobject%20Object%5D&name=image.png&originHeight=278&originWidth=470&size=10375&status=done&style=stroke&width=235" alt="image.png"></p><div style="background: #FFFBE6;padding:10px;border: 1px solid #C3C3C3;border-radius:5px;margin-bottom:5px;">二叉链表的结点类型：</div><pre><code class="cpp">Typedef structure  tnode&#123;    int   data;    structure  tnode   *lchild, *rchild;&#125;bitree,*bitlink ;</code></pre><h2 id="遍历二叉树算法"><a href="#遍历二叉树算法" class="headerlink" title="遍历二叉树算法"></a>遍历二叉树算法</h2><div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">把一颗树遍历完，有下面三种方法：波兰表达式 ->  先序遍历二叉树中缀表达式 -> 中序遍历二叉树逆波兰表达式 -> 后序遍历二叉树</div><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1620298049502-63346474-7a61-45cf-88a8-56c66954d894.png#align=left&display=inline&height=335&margin=%5Bobject%20Object%5D&name=image.png&originHeight=670&originWidth=771&size=277201&status=done&style=stroke&width=385.5" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1620298098593-6760a592-4907-4662-a4be-404dde35d246.png#align=left&display=inline&height=208&margin=%5Bobject%20Object%5D&name=image.png&originHeight=416&originWidth=590&size=90670&status=done&style=stroke&width=295" alt="image.png"></p><blockquote><p>各种遍历结果<br>先序：-+a<em>b-cd/ef<br>中序：a+b</em>c-d-e/f<br>后序：abcd-*+ef/-</p></blockquote><h2 id="实验代码"><a href="#实验代码" class="headerlink" title="实验代码"></a>实验代码</h2><p>用上面的二叉树作为例子：</p><pre><code class="cpp">#include&lt;bits/stdc++.h&gt;using namespace std;typedef int Status;typedef char TElemType;#define OVERFLOW -1#define ERROR 0#define OK 1char ch;/** * 采用二叉链表的存储形式 */typedef struct BiTNode&#123;    TElemType data;    struct BiTNode *lchild, *rchild;&#125;BiTNode, *BiTree;/** * 创建一棵二叉树 */void CreateBiTree(BiTree &amp;T) &#123;    //按先序次序输入二叉树中结点的值，创建二叉链表表示的二叉树T    TElemType ch;    cin&gt;&gt;ch;    if(ch == &#39;#&#39;)&#123;//递归结束，建空树        T = NULL;    &#125; else &#123;        T = new BiTNode;        T-&gt;data = ch;        CreateBiTree(T-&gt;lchild);        CreateBiTree(T-&gt;rchild);    &#125;&#125;/** * 先序遍历 */void PreOrderTraverse(BiTree &amp;T)&#123;//先序遍历二叉树T的递归算法    if(T)                               //若二叉树非空    &#123;        cout &lt;&lt; T-&gt;data &lt;&lt; &quot; &quot;;                  //访问根结点        PreOrderTraverse(T-&gt;lchild);     //中序遍历左子树        PreOrderTraverse(T-&gt;rchild);     //中序遍历右子树    &#125;&#125;/** * 中序遍历 */void InOrderTraverse(BiTree &amp;T) &#123;    if (T) &#123;        InOrderTraverse(T-&gt;lchild);        cout &lt;&lt; T-&gt;data &lt;&lt; &quot; &quot;;        InOrderTraverse(T-&gt;rchild);    &#125;&#125;/** * 后序遍历 */void PostOrderTraverse(BiTree &amp;T)&#123;//后序遍历二叉树T的递归算法    if(T)                               //若二叉树非空    &#123;        PostOrderTraverse(T-&gt;lchild);   //中序遍历左子树        PostOrderTraverse(T-&gt;rchild);   //中序遍历右子树        cout &lt;&lt; T-&gt;data &lt;&lt; &quot; &quot;;                 //访问根结点    &#125;&#125;/** * 统计二叉树中节点个数 */int NodeCount (BiTree &amp;T) &#123;    if (T == NULL) &#123;        return 0;    &#125; else &#123;        return NodeCount(T-&gt;lchild) + NodeCount(T-&gt;rchild) + 1;    &#125;&#125;/** * 二叉树中叶结点个数 */int LeavesCount (BiTree &amp;T) &#123;    if (T == NULL) &#123;        return 0;    &#125; else if (T-&gt;lchild == NULL &amp;&amp; T-&gt;rchild == NULL) &#123;        return LeavesCount(T-&gt;lchild) + LeavesCount(T-&gt;rchild) + 1;    &#125;    else &#123;        return LeavesCount(T-&gt;lchild) + LeavesCount(T-&gt;rchild);    &#125;&#125;int main() &#123;    BiTree test = new BiTNode;    cout &lt;&lt; &quot;请输入一个字符串以生成二叉树：&quot;;    CreateBiTree(test);    cout &lt;&lt;&quot;\n&quot;&lt;&lt; &quot;先序遍历结果：&quot;;    PreOrderTraverse(test);    cout &lt;&lt;&quot;\n&quot;&lt;&lt; &quot;中序遍历结果：&quot;;    InOrderTraverse(test);    cout &lt;&lt;&quot;\n&quot;&lt;&lt; &quot;后序遍历结果：&quot;;    PostOrderTraverse(test);    cout &lt;&lt;&quot;\n&quot;&lt;&lt; &quot;二叉树结点个数：&quot;&lt;&lt;NodeCount(test);    cout &lt;&lt;&quot;\n&quot;&lt;&lt; &quot;二叉树叶结点个数：&quot;&lt;&lt;LeavesCount(test);&#125;</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1620302765118-f27235d1-7167-40ae-ab80-dc23494d55cc.png#align=left&display=inline&height=129&margin=%5Bobject%20Object%5D&name=image.png&originHeight=258&originWidth=1025&size=38229&status=done&style=none&width=512.5" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> DataStructure </category>
          
          <category> 树结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>实验5——波兰/逆波兰表达式求值（栈）</title>
      <link href="blog/iyb7wi/"/>
      <url>blog/iyb7wi/</url>
      
        <content type="html"><![CDATA[<h2 id="实验报告"><a href="#实验报告" class="headerlink" title="实验报告"></a>实验报告</h2><p>实验五：实现用波兰表达式（先序）和逆波兰表达式（后序）求算术表达式的值<br>要求：仅用一个栈实现（并且用原生单链表实现）<br>测试用例：4+2*3-10/5<br>交作业时间：5 月 14 日</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>两个步骤：</p><ol><li><strong>将给定的表达式转换为波兰表达式/逆波兰表达式</strong></li><li><strong>对转换后的式子进行计算</strong></li></ol><p>学习遍历二叉树，利用前序/中序/后序表达式的时候，经常有一个问题就是：</p><ul><li><input checked="" disabled="" type="checkbox"> 给出中缀表达式，【写出&amp;&amp;编程出】后序（逆波兰）表达式</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1620306330357-a83abeff-56a3-44f1-b837-82051f46e3b5.png#align=left&display=inline&height=175&id=ZAX5A&margin=%5Bobject%20Object%5D&name=image.png&originHeight=754&originWidth=1023&size=63695&status=done&style=none&width=237" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1620306352380-f6eef790-b72d-4e1d-9da1-6597ec5ae11d.png#align=left&display=inline&height=176&id=zESCQ&margin=%5Bobject%20Object%5D&name=image.png&originHeight=610&originWidth=1021&size=59737&status=done&style=none&width=294" alt="image.png"><br>上面的是课堂上在纸上的书写，那么如何将其用编程语言实现呢？思路应该是这样的：</p><ul><li><p>遍历表达式：对遍历的元素进行判断</p></li><li><p>是运算符？操作数？还是括号呢？对其相应的判断</p><ul><li>操作数</li><li>运算符：+-*/</li><li>括号</li></ul></li><li><p><input checked="" disabled="" type="checkbox">  个位数/双位数……的字符处理</p></li><li><p><input checked="" disabled="" type="checkbox">  给出中缀表达式，【写出&amp;&amp;编程出】前序（波兰）表达式</p></li></ul><p>如果写出了逆波兰表达式，转换为波兰表达式只需要将<code>（</code>变为<code>）</code>，同时遍历从后往前遍历即可</p><p>最后的结果逆置</p><ul><li><input checked="" disabled="" type="checkbox"> 最后的计算，波兰和逆波兰不能写成一个函数，因为减数和被减数，除数和被除数的缘故</li></ul><h2 id="实验代码"><a href="#实验代码" class="headerlink" title="实验代码"></a>实验代码</h2><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1620979662957-690a9050-8a82-4170-816b-ffcff99f38d7.png#align=left&display=inline&height=220&margin=%5Bobject%20Object%5D&name=Snipaste_2021-05-14_11-20-30.png&originHeight=220&originWidth=500&size=13118&status=done&style=none&width=500" alt="Snipaste_2021-05-14_11-20-30.png"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1620979669021-d90e4ff6-feb6-4df9-9f6a-d7176b25d258.png#align=left&display=inline&height=202&margin=%5Bobject%20Object%5D&name=Snipaste_2021-05-14_11-20-43.png&originHeight=202&originWidth=446&size=12040&status=done&style=none&width=446" alt="Snipaste_2021-05-14_11-20-43.png"></p><pre><code class="cpp">#include&lt;bits/stdc++.h&gt;using namespace std;/** * 波兰表达式/逆波兰表达式求解运算表达式 * *//** * 单链表的存储结构 */typedef struct LNode &#123;    string data; //数据域    struct LNode *next; //指针域&#125;Lnode, *LinkList; //LinkList为指向结构体LNode的指针类型/* 初始化链表 */void InitList(LinkList &amp;L) &#123;    L = new LNode;    L-&gt;next = NULL;&#125;/* 打印 */void TraverseList(LinkList &amp; L)&#123;        LNode *p = new LNode;        p = L-&gt;next;        // cout &lt;&lt; &quot;此中缀表达式链表打印的结果为：&quot;;        while (p != NULL)        &#123;            cout &lt;&lt; p-&gt;data;            p = p-&gt;next;        &#125;        cout &lt;&lt; &quot;\n&quot;;&#125;/* 逆置 */void ReverseList(LinkList &amp;L) &#123;    LNode *p = L-&gt;next;    L-&gt;next = NULL;    while(p)    &#123;        LNode *q = p-&gt;next;        p-&gt;next = L-&gt;next;        L-&gt;next = p;        p = q;    &#125;&#125;/** * 初始化用户输入的链表 */void Center(LinkList &amp;L,string s) &#123;    InitList(L);    LinkList p = L;    string temp = &quot;&quot;;    for (int i = 0; i &lt; s.length();i++)&#123;        // 处理双位数字情况        if (isdigit(s[i])) &#123;            // 该字符为数字            temp = temp + s[i];            if (!isdigit(s[i+1])) &#123;                // 下一个不是数字，而是字符，将temp后插                LinkList node = new LNode;                node-&gt;data = temp;                node-&gt;next = NULL;                p-&gt;next = node;                p = node;                // 将temp重置                temp = &quot;&quot;;                continue;            &#125;            continue;        &#125;        // 后插到L尾巴上        LinkList node = new LNode;        node-&gt;data = s[i];        node-&gt;next = NULL;        p-&gt;next = node;        p = node;    &#125;&#125;/** * 将表达式转换为波兰表达式/逆波兰表达式 * 第二个参数对逆波兰而言是左括号，第三个参数对逆波兰而言是右括号 * 对波兰而言反过来 */void Transition(LinkList &amp;L, string l, string r)&#123;    // 定义一个栈用来处理    stack&lt;string&gt; stack;    LinkList p = L-&gt;next;    LinkList result = new LNode;    InitList(result);    LinkList result_a = result;    while(p != NULL) &#123;        if (p-&gt;data == l) &#123;            stack.push(p-&gt;data);        &#125; else if(p-&gt;data == r) &#123;            while(stack.top() != l)&#123;                LinkList temp = new LNode;                temp-&gt;data = stack.top();                temp-&gt;next = NULL;                result_a-&gt;next = temp;                result_a = temp;                stack.pop();            &#125;            if (stack.top() == l)&#123;                stack.pop();            &#125;        &#125; else if(p-&gt;data == &quot;+&quot; || p-&gt;data == &quot;-&quot;) &#123;            if (stack.size() != 0) &#123;                if (stack.top() == &quot;*&quot; || stack.top() == &quot;/&quot;)&#123;                    for (int i = 0; i &lt; stack.size();i++) &#123;                        if (stack.top() == l) &#123;                            break;                        &#125;                        LinkList temp = new LNode;                        temp-&gt;data = stack.top();                        temp-&gt;next = NULL;                        result_a-&gt;next = temp;                        result_a = temp;                        stack.pop();                    &#125;                &#125;            &#125;            stack.push(p-&gt;data);        &#125; else if(p-&gt;data == &quot;*&quot; || p-&gt;data == &quot;/&quot;) &#123;            stack.push(p-&gt;data);        &#125; else &#123;            LinkList temp = new LNode;            temp-&gt;data = p-&gt;data;            temp-&gt;next = NULL;            result_a-&gt;next = temp;            result_a = temp;        &#125;        p = p-&gt;next;    &#125;    // TraverseList(result);    for (int i = 0; i &lt; stack.size();i++) &#123;        LinkList temp = new LNode;        temp-&gt;data = stack.top();        temp-&gt;next = NULL;        result_a-&gt;next = temp;        result_a = temp;        stack.pop();    &#125;    // 上一个操作总是不能清空栈的最后一个元素    LinkList temp = new LNode;    temp-&gt;data = stack.top();    temp-&gt;next = NULL;    result_a-&gt;next = temp;    result_a = temp;    stack.pop();    L = result;&#125;/** * 计算 */void EvaulTree(LinkList &amp;L) &#123;    // 定义一个栈用来处理    stack&lt;string&gt; stack;    LinkList p = L-&gt;next;    while(p != NULL) &#123;        if (p-&gt;data == &quot;+&quot;)&#123;            int x = stoi(stack.top());            stack.pop();            int y = stoi(stack.top());            stack.pop();            stack.push(to_string(y + x));        &#125; else if(p-&gt;data == &quot;-&quot;) &#123;            int x = stoi(stack.top());            stack.pop();            int y = stoi(stack.top());            stack.pop();            stack.push(to_string(y - x));        &#125; else if(p-&gt;data == &quot;*&quot;) &#123;            int x = stoi(stack.top());            stack.pop();            int y = stoi(stack.top());            stack.pop();            stack.push(to_string(y * x));        &#125; else if(p-&gt;data == &quot;/&quot;) &#123;            int x = stoi(stack.top());            stack.pop();            int y = stoi(stack.top());            stack.pop();            stack.push(to_string(y / x));        &#125; else &#123;            stack.push(p-&gt;data);        &#125;        p = p-&gt;next;    &#125;    while (!stack.empty())&#123;        cout &lt;&lt; stoi(stack.top());        stack.pop();    &#125;&#125;void EvaulTree_polish(LinkList &amp;L) &#123;    // 定义一个栈用来处理    stack&lt;string&gt; stack;    LinkList p = L-&gt;next;    while(p != NULL) &#123;        if (p-&gt;data == &quot;+&quot;)&#123;            int x = stoi(stack.top());            stack.pop();            int y = stoi(stack.top());            stack.pop();            stack.push(to_string(x + y));        &#125; else if(p-&gt;data == &quot;-&quot;) &#123;            int x = stoi(stack.top());            stack.pop();            int y = stoi(stack.top());            stack.pop();            stack.push(to_string(x - y));        &#125; else if(p-&gt;data == &quot;*&quot;) &#123;            int x = stoi(stack.top());            stack.pop();            int y = stoi(stack.top());            stack.pop();            stack.push(to_string(x * y));        &#125; else if(p-&gt;data == &quot;/&quot;) &#123;            int x = stoi(stack.top());            stack.pop();            int y = stoi(stack.top());            stack.pop();            stack.push(to_string(x / y));        &#125; else &#123;            stack.push(p-&gt;data);        &#125;        p = p-&gt;next;    &#125;    while (!stack.empty())&#123;        cout &lt;&lt; stoi(stack.top());        stack.pop();    &#125;&#125;int main () &#123;    cout &lt;&lt; &quot;------------------------------------&quot;&lt;&lt;&quot;\n&quot;;    string s;    cout &lt;&lt; &quot;请输入运算表达式：&quot;&lt;&lt;&quot;\n&quot;;    cin &gt;&gt; s;    LinkList test_reversepolish = new LNode;    InitList(test_reversepolish);    LinkList test_polish = new LNode;    InitList(test_polish);    Center(test_reversepolish, s);    Center(test_polish, s);    cout &lt;&lt; &quot;------------------------------------&quot;&lt;&lt;&quot;\n&quot;;    // 波兰表达式    ReverseList(test_polish);    Transition(test_polish, &quot;)&quot;, &quot;(&quot;);    cout &lt;&lt; &quot;波兰表达式为：&quot;;    ReverseList(test_polish);    TraverseList(test_polish);    cout &lt;&lt; &quot;波兰表达式计算结果为：&quot;;    ReverseList(test_polish);    EvaulTree_polish(test_polish);    cout &lt;&lt; &quot;\n&quot;&lt;&lt;&quot;------------------------------------&quot;&lt;&lt;&quot;\n&quot;;    // 逆波兰表达式    Transition(test_reversepolish, &quot;(&quot;, &quot;)&quot;);    cout &lt;&lt; &quot;逆波兰表达式为：&quot;;    TraverseList(test_reversepolish);    cout &lt;&lt; &quot;逆波兰表达式计算结果为：&quot;;    EvaulTree(test_reversepolish);    cout &lt;&lt; &quot;\n&quot;&lt;&lt;&quot;------------------------------------&quot;&lt;&lt;&quot;\n&quot;;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> DataStructure </category>
          
          <category> Problems </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>BF和KMP模式匹配算法</title>
      <link href="blog/ah7arw/"/>
      <url>blog/ah7arw/</url>
      
        <content type="html"><![CDATA[<div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">在进行字符串匹配的相关程序中，看一个子串是否在一个主串里面，有著名的Brute-Force和基于此改进的KMP算法，具体学习记录如下：</div><h2 id="Brute-Force"><a href="#Brute-Force" class="headerlink" title="Brute-Force"></a>Brute-Force</h2><blockquote><p>给出一个主串和一个子串<br>主串：s = ababc<strong>abcac</strong>bab<br>子串：t = abcac</p></blockquote><p>①BF 算法算是一种暴力算法，首先是查看 t 的第一字母 a 和上面 s 的第一个字母比较相同，所以接着比较比到各自的第三个字符也就是，aba、abc 发现不同，</p><p>② 再递推比较，t 回到第一个字母 a，这时 s 回到第二个字符（因为第一个字符已经比过了）相当于 babcabcacbab 和 abcac 两个字符串进行比较，很明显第一个字符就不一样，</p><p>③ 再递推比较……</p><p>按常理来思考，这样总能得出结果，但是在此基础上，可以有进一步的优化操作，怎么说？<img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1617677082076-945e1a85-4b75-40ad-a413-46f7e514b7f4.jpeg#align=left&display=inline&height=59&margin=%5Bobject%20Object%5D&name=huaji1558a846ddf2e12b.jpeg&originHeight=59&originWidth=55&size=703&status=done&style=stroke&width=55" alt="huaji1558a846ddf2e12b.jpeg"><br>在上面的第 ② 步里面，我们总是一步一步递推，那我们能不能一次性推好几步呢？就根据已经匹配了的那串字母。</p><p>具体表现为：① 已经发现是第三个字符不同，那我们就根据前面两个相同的字符（ab）推出第 ② 步推两步，为什么根据相同的 ab，第 ② 个步骤就可以一次性走两步？</p><h2 id="KMP-算法"><a href="#KMP-算法" class="headerlink" title="KMP 算法"></a>KMP 算法</h2><h3 id="算法详述"><a href="#算法详述" class="headerlink" title="算法详述"></a>算法详述</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1617677082076-945e1a85-4b75-40ad-a413-46f7e514b7f4.jpeg#align=left&display=inline&height=59&margin=%5Bobject%20Object%5D&name=huaji1558a846ddf2e12b.jpeg&originHeight=59&originWidth=55&size=703&status=done&style=stroke&width=55" alt="huaji1558a846ddf2e12b.jpeg">先学会用，理论日后再补…… 🕊</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1620286656388-6b7c4ae0-8c01-4ae5-9451-9d17c63a23bb.png#align=left&display=inline&height=70&margin=%5Bobject%20Object%5D&name=image.png&originHeight=139&originWidth=725&size=10548&status=done&style=stroke&width=362.5" alt="image.png"></p><h3 id="计算-next-函数值"><a href="#计算-next-函数值" class="headerlink" title="计算 next 函数值"></a>计算 next 函数值</h3><blockquote><p>（3）串“ababaaababaa”的 next 数组为（  ）。<br>A．012345678999   B．012121111212   C．011234223456    D．0123012322345<br>答案：C</p></blockquote><table><thead><tr><th>j</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th><th>11</th><th>12</th></tr></thead><tbody><tr><td>t</td><td>a</td><td>b</td><td>a</td><td>b</td><td>a</td><td>a</td><td>a</td><td>b</td><td>a</td><td>b</td><td>a</td><td>a</td></tr><tr><td>next(j)</td><td>0</td><td>1</td><td>1</td><td>2</td><td>3</td><td>4</td><td>2</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td></tr></tbody></table><p>方法：<br>①next 数组第一位永远是 0，1；<br>②next(j) = 前序列相同元素个数 + 1；</p><p>eg：当 t = 6：<br>前面的序列为 ababa，可以看出相同的子序列为 aba，相同元素个数为 3，所以 next(6) = 3 + 1 = 4</p><p>注意：不能“全覆盖”，比如当 j = 2 时候，前面的 a 不能看成 a = a 序列，这样就变成 next(2) = 2 了；</p><h3 id="计算-next-函数修正值"><a href="#计算-next-函数修正值" class="headerlink" title="计算 next 函数修正值"></a>计算 next 函数修正值</h3><blockquote><p>（4）串“ababaabab”的 nextval 为（  ）。<br>A．010104101      B．010102101      C．010100011       D．010101011  <br>答案：A</p></blockquote><table><thead><tr><th>j</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th></tr></thead><tbody><tr><td>t</td><td>a</td><td>b</td><td>a</td><td>b</td><td>a</td><td>a</td><td>b</td><td>a</td><td>b</td></tr><tr><td>next(j)</td><td>0</td><td>1</td><td>1</td><td>2</td><td>3</td><td>4</td><td>2</td><td>3</td><td>4</td></tr><tr><td>nextval(j)</td><td>0</td><td>1</td><td>0</td><td>1</td><td>0</td><td>4</td><td>1</td><td>0</td><td>1</td></tr></tbody></table><p>方法：<br>① 先列举出 next(j)，求 nextval(j)是基于 next(j)的；<br>② 求 nextval(j)，先看求 next(j)的值，记这个值为 x；<br>③ 在表格中找出 j = x 的那一列，如果这一列的 t 值和 ② 步骤中的 t 值相同，则结果为 j = x 这一列的 nextval(j)值，如果不相同，则结果为所要求的那一列的 next(j)值；</p><p>eg：当 j = 5 时：<br>此时 next(j) = 3，就去 j = 3 那一列看到 t = a，和 j = 5 一列的 t 值 a 相同，所以结果为 j = 3 一列的 nextval 值 0</p><p>eg：当 j = 6 时：<br>此时 next(j) = 4，就去 j = 4 那一列看到 t = b，和 j = 6 一列的 t 值不相同，所以结果为 j = 6 一列的 next 值 4</p><h3 id="具体匹配情况"><a href="#具体匹配情况" class="headerlink" title="具体匹配情况"></a>具体匹配情况</h3><blockquote><p>（2）设目标为 t=“abcaabbabcabaacbacba”,模式为 p=“abcabaa”<br>① 计算模式 p 的 naxtval 函数值；<br>② 不写出算法,只画出利用 KMP 算法进行模式匹配时每一趟的匹配过程。</p></blockquote><p>答案：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1620290726560-b77d1aa1-b7ed-4561-95b4-0e8f7e643ca9.png#align=left&display=inline&height=161&margin=%5Bobject%20Object%5D&name=image.png&originHeight=321&originWidth=723&size=31460&status=done&style=stroke&width=361.5" alt="image.png"></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre><code class="cpp">#include&lt;bits/stdc++.h&gt;using namespace std;typedef int Status;typedef int ElemType;#define OVERFLOW -1#define ERROR 0#define OK 1//------串的顺序存储结构-----#define MAXLEN 225typedef struct&#123;    char ch[MAXLEN + 1];    //存储串的一维数组，从下标为1的数组分量开始存储的，下标为0的分量闲置不用    int length;             //串的当前长度&#125;SString;//------串的堆式顺序存储结构-----typedef struct&#123;    char *ch;       //若是非空串，则按串长分配存储区，否则ch为NULL    int length;     //串的当前长度&#125;HString;HString S, T;//-----串的链式存储结构-----#define CHUNKSIZE 80typedef struct Chunk&#123;    char ch[CHUNKSIZE];    struct Chunk *next;&#125;Chunk;typedef struct&#123;    Chunk *head, *tail;     //串的头指针和尾指针    int length;             //串的当前长度&#125;LString;// //1、生成串// StrAssign(&amp;T, chars)// //2、复制// StrCopy(&amp;T, S)// //3、判空// StrEmpty(S)// //4、比较// StrCompare(S, T)// //5、长度// StrLength(S)// //6、清空// ClearString(&amp;S)// //7、联接// Concat(&amp;T, S1, S2)// //8、子串// SubString(⋐, S, pos, len)//9、串的模式匹配_BF算法 O(n * m)int Index_BF(HString S, HString T, int pos)&#123;//返回模式T在主串s中第pos个字符开始第一次出现的位置。若不存在，则返回值为0 //其中，T非空，1&lt;=pos&lt;=S.length    int i = pos, j = 1;                     //初始化    while(i &lt;= S.length &amp;&amp; j &lt;= T.length)   //两串均未比较到串尾    &#123;        if(S.ch[i] == T.ch[j])              //继续比较后继字符        &#123;            i++;            j++;        &#125;        else                                //指针后退重新开始匹配        &#123;            i = i - j + 2;                  //i=i-j+1回到i的起点，+2到下一个字符            j = 1;        &#125;    &#125;    if(j &gt; T.length)            return i - T.length;            //匹配成功，返回T在S中第一次出现的位置        else            return 0;&#125;//9、串的模式匹配_KMP算法求next数组void get_next(HString, int next[])&#123;//求模式串T的next函数值并存入数组next    int j = 1, t = 0;    next[1] = 0;    while(j &lt; T.length)    &#123;        if(t == 0 || T.ch[j] == T.ch[t])        &#123;            t++;            j++;            next[j] = t;        &#125;        else            t = next[t];    &#125;&#125;//9、串的模式匹配_KMP算法求nextval数组void get_nextval(HString T, int nextval[])&#123;//求模式串T的next函数修正值并存入数组nextval    int j = 1, t = 0;    nextval[1] = 0;    while(j &lt; T.length)    &#123;        if(t == 0 || T.ch[j] == T.ch[t])        &#123;            t++;            j++;            if(T.ch[j] != T.ch[t])                nextval[j] = t;            else                nextval[j] = nextval[t];        &#125;        else            t = nextval[t];    &#125;&#125;//9、串的模式匹配_KMP算法 O(n + m)int Index_KMP(HString S, HString T, int pos, int next[])&#123;//利用模式串T的next函数求T在主串S中第pos个字符之后的位置 //其中，T非空，1&lt;=pos&lt;=S.length    int i = pos, j = 1;    while(i &lt;= S.length &amp;&amp; j &lt;= S.length)   //两个串均未比较到串尾    &#123;        if(j == 0 || S.ch[i] == T.ch[i])    //继续比较后继字符        &#123;            i++;            j++;        &#125;        else            j = next[j];                    //模式串向右移动        if(j &gt; T.length)                    //匹配成功            return i - T.length;        else            return 0;    &#125;&#125;// //10、插入// Strlnsert(&amp;S, pos, T)// //11、删除// StrDelete(&amp;S, pos, len)// //12、销毁// DestroyString(&amp;S)</code></pre>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
          <category> 其他算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>《文城》有感</title>
      <link href="essay/ll4lrz/"/>
      <url>essay/ll4lrz/</url>
      
        <content type="html"><![CDATA[<blockquote><p>文城（《活着》作者余华时隔 8 年，全新长篇重磅归来。关于一个人和他一生的寻找，以及一群人和一个汹涌的年代。他原本不属于这里，但许多人的牵挂和眼泪都留在了他身上） (余华)</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2021/webp/1484158/1620263368423-1137b0d5-338f-4b67-8710-05113a05e2cf.webp#align=left&display=inline&height=352&id=q1Cav&margin=%5Bobject%20Object%5D&originHeight=2468&originWidth=1716&size=0&status=done&style=stroke&width=245"></p><ul><li>您在位置 #275-277 的标注 | 添加于 2021 年 4 月 28 日星期三 下午 2:27:12</li></ul><div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">她一边说一边笑，她的眼睛闪闪发亮，这是林祥福第一次见到小美这样的神态。一个在屋子里走动时只有木屐声响的女子，一个不会笑出声音而是将笑意含在嘴角的女子，此刻容光焕发了。</div><ul><li>您在位置 #289-289 的标注 | 添加于 2021 年 4 月 28 日星期三 下午 2:29:19</li></ul><div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">刚才屋顶被砸出的洞口纷纷落下来碗大的雨雹，砸到地上后犹如花开花谢。</div><ul><li>您在位置 #330-330 的标注 | 添加于 2021 年 4 月 28 日星期三 下午 2:33:05</li></ul><div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">“天下棺材七尺三。”</div><ul><li>您在位置 #474-476 的标注 | 添加于 2021 年 4 月 28 日星期三 下午 2:46:24</li></ul><div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">人生在世祸福难测，有一门技艺在身能够逢凶化吉，技艺是怎么也不会败落的。林祥福觉得自己的木工技艺应该更上一层楼，应该继续去拜师学艺。</div><ul><li>您在位置 #818-819 的标注 | 添加于 2021 年 4 月 28 日星期三 下午 3:09:19</li></ul><div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">晚霞在明净的天空里燃烧般通红，岸上的田地里传来耕牛回家的哞哞叫声，炊烟正在袅袅升起。</div>]]></content>
      
      
      <categories>
          
          <category> 一书一世界 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>『无间道』有感</title>
      <link href="essay/ebd5c2/"/>
      <url>essay/ebd5c2/</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1620262818767-a8f3dd82-2eb8-49c4-a240-42f1618ae335.png#align=left&display=inline&height=540&id=p3dbG&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1080&originWidth=1920&size=2070221&status=done&style=none&width=960" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1620262714711-9a4e8bf0-56f2-4db0-9c48-9f05243e19e7.png#align=left&display=inline&height=540&id=zT0rR&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1080&originWidth=1920&size=1926079&status=done&style=none&width=960" alt="image.png"></p><p>上个礼拜看的，我觉得这无间道三部曲算是港片的鼻祖地位的，因为传神……</p><p>对刘建明和阿仁，我只想说，<strong>有的人死去，人已经解脱了，有的人，看似风生水起，实则，已堕入无间地狱</strong>。</p><p>还有一句“我只想做个好人”，初听之下就像是步入正途之下的光明大道，实则细想实在是<strong>鬼魅</strong>。</p><p>这里面还有很多关于佛教的一些摘录，感觉很值得揣摩，在此摘录一番</p><div style="background: #FFFBE6;padding:10px;border: 1px solid #C3C3C3;border-radius:5px;margin-bottom:5px;">《涅槃经》第十九卷「八大地狱之最，称为无间地狱，为无间断遭受大苦大意，故有此名。」</div><div style="background: #FFFBE6;padding:10px;border: 1px solid #C3C3C3;border-radius:5px;margin-bottom:5px;">「无间有三，时无间，空无间，受业无间。犯忤逆罪这永堕此界，尽受终极之无间。」</div><div style="background: #FFFBE6;padding:10px;border: 1px solid #C3C3C3;border-radius:5px;margin-bottom:5px;">地藏菩萨本愿经卷上：「如是本辈，当堕无间地狱，千万亿劫，以此连绵，求出无期。」</div><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1620262755423-85be1e40-abd1-4879-abc5-94e82b6a913a.png#align=left&display=inline&height=540&id=jfQ8C&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1080&originWidth=1920&size=2866623&status=done&style=none&width=960" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> 人生影视课 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>『DARLING in the FRANXX』</title>
      <link href="essay/lwgmc6/"/>
      <url>essay/lwgmc6/</url>
      
        <content type="html"><![CDATA[<div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">Darling in the FranXX （比翼之吻）</div><p>这部番我觉得从世界观的角度来说构思很新奇，贯穿全篇则为——人性。</p><p>世界观颠覆了以往的人类美的一面，将人类的人格寄存于“爸爸”的手掌之下，欲望促使人类的人形暴露，但同时人性的一些闪光点，也在悄然萌发。</p><p>zero two 和广的爱情，就像是我之前写的『缺爱』一篇，zero two 的缺爱的极端时刻，被广的光辉所拯救了，成年之际，广的失意落魄被 zero two 口中的 darling 所拯救；</p><p>还有心的圣母形象，忘了对满的感情和生育的知识，这是我觉得这部番里面特别重要的一个点睛之笔。</p><p>我们很难去理性的分析这些人物角色，但是贯穿这些的我想就是人性最为光辉的各个闪光点吧……</p><p>转载一篇文章，片中几个机体的命名——对应的都是植物</p><blockquote><p><a href="https://movie.douban.com/review/9225938/">片中几个机体的命名——对应的都是植物</a></p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1619577542480-78f1ab01-405e-411c-ae14-537958ecf49e.jpeg#align=left&display=inline&height=540&id=u4f75054a&margin=%5Bobject%20Object%5D&originHeight=1080&originWidth=1920&status=done&style=none&width=960"></p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1619485267464-dd9642d5-df67-4a97-8419-8e5fc3a709a9.png#align=left&display=inline&height=1200&id=QP1th&margin=%5Bobject%20Object%5D&name=85308871_p0.png&originHeight=1200&originWidth=1600&size=309762&status=done&style=none&width=1600" alt="85308871_p0.png"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1619485230506-60d08215-4e79-42cb-9ba0-d3b5681edec4.png#align=left&display=inline&height=1261&id=U6MD4&margin=%5Bobject%20Object%5D&name=87980648_p0.png&originHeight=1261&originWidth=2000&size=2542419&status=done&style=none&width=2000" alt="87980648_p0.png"><br><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1619485170602-d19ab096-b1e2-4001-a419-4e1cc1c5a8ba.jpeg#align=left&display=inline&height=1040&id=LdgD5&margin=%5Bobject%20Object%5D&name=87883532_p0.jpg&originHeight=1040&originWidth=700&size=166056&status=done&style=none&width=700" alt="87883532_p0.jpg"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1619485191278-d20ca434-1141-41f5-a73e-db7b54f34d4e.png#align=left&display=inline&height=5000&id=Y2Du1&margin=%5Bobject%20Object%5D&name=87324495_p0.png&originHeight=5000&originWidth=3000&size=5878321&status=done&style=none&width=3000" alt="87324495_p0.png"></p>]]></content>
      
      
      <categories>
          
          <category> 人生影视课 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>《平凡的世界》有感</title>
      <link href="essay/hhd57l/"/>
      <url>essay/hhd57l/</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1622032253532-9007acd3-e5c9-4e15-9839-7412bf52d680.jpeg#height=350&id=gdmS8&originHeight=350&originWidth=350&originalType=binary%E2%88%B6=1&size=0&status=done&style=stroke&width=350"><br>平凡的世界（路遥著长篇小说）</p><hr><p>21.06.12<br>​</p><p>经历了一件事，心碎。<br>今天的我懂得到什么叫成长，就像最后的少平那样，笔直地走向那条铁路，坚毅，成长……<br>​</p><p>“少平，你要记得，你与其他人不一样，你是一个有另外世界的人，你的心不应该只在这，而是在远方，那个充满光的地方”<br>​</p><p>这话湿了眼眶……</p><hr><p>21.02.21 号整理家里书架时候写的</p><p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1619483066100-b7e6b34c-9232-4dda-859f-02f28ceec07c.jpeg#height=4095&id=fX4yb&originHeight=4095&originWidth=1125&originalType=binary%E2%88%B6=1&status=done&style=none&width=1125"></p>]]></content>
      
      
      <categories>
          
          <category> 一书一世界 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>我变了吗？</title>
      <link href="essay/ogyb5h/"/>
      <url>essay/ogyb5h/</url>
      
        <content type="html"><![CDATA[<p>这是加密文章！</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>应用层及网络应用万维网的HTTP协议</title>
      <link href="blog/re05fo/"/>
      <url>blog/re05fo/</url>
      
        <content type="html"><![CDATA[<h2 id="为什么需要应用层呢？"><a href="#为什么需要应用层呢？" class="headerlink" title="为什么需要应用层呢？"></a>为什么需要应用层呢？</h2><div style="background: #FFFBE6;padding:10px;border: 1px solid #C3C3C3;border-radius:5px;margin-bottom:5px;">为什么需要应用层呢？</div><p>应用层的上一层，也就是传输层其实就已经搭建好了传输信息的框架，但是为什么还需要应用层这一层，因为<strong>传输层传的太简单，只实现我给你传过去，不全面有不足之处，用课上老师的话说，各层的宗旨就是尽力而为，举一些传输层心有余而力不足的地方：</strong></p><ul><li>客户端发送的是什么数据类型的文件</li><li>数据的长度，传输一次的数据长度为多长，一次是否传得完？什么时候传完？（TCP 的流量控制）</li><li>数据的压缩方式，服务端如何知道客户端对数据是否压缩抑或是压缩算法是什么？</li></ul><p>而对于上述三个问题，在应用层给出相应的解决方案：</p><ul><li>数据的类型，HTTP Header： Content-Type</li><li>数据的长度，HTTP Header： Content-Length</li><li>数据的压缩方式，HTTP Header： Accept-Encoding</li></ul><h2 id="搞清互联网和万维网主次"><a href="#搞清互联网和万维网主次" class="headerlink" title="搞清互联网和万维网主次"></a>搞清互联网和万维网主次</h2><p>之前上课的时候，这里一直被忽视了，有一个主次概念需要搞清楚，<strong>万维网（WWW）是一个网络应用，万维网应用是一种基于客户/服务器体系结构的网络应用</strong>『应用层的协议都是基于客户服务器方式的，即便是 P2P 对等通信方式，实质上也是一种特殊的客户服务器方式』<strong>，它是一个网络应用</strong>，相应地，在互联网里面，还有文件传输（FTP)、电子邮件 E-mail、远程登录（Telnet）等这些应用。所以引用对互联网还可以说成：<strong>是线路、协议以及通过 TCP/IP 协议实现数据电子传输的硬件和软件的集合体</strong>。</p><p>万维网这个应用还包括一些部件：万维网浏览器，万维网服务器，玩万维网文档的格式标准，以及一个应用层协议等等，这样就将 HTTP 的来源就串起来了。</p><p>理解了主次，再从“主”依次理解“次”</p><ul><li>先理解许多应用协议都要使用的<strong>域名系统（DNS）</strong>，这是基础中的基础</li><li>文件传送协议：具体应用就是云主机的使用吧</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1618625750527-7aa85753-4d61-4400-8e86-f8f2c6ae0c41.png#align=left&display=inline&height=104&margin=%5Bobject%20Object%5D&name=image.png&originHeight=207&originWidth=219&size=11364&status=done&style=none&width=109.5" alt="image.png"></p><ul><li>远程登录协议：书上只讲了 TELNET，具体应用 XSHELL 的 SSH 也是</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1618625847438-b61068f8-a3d5-43b0-8cd3-eefb3aeac42d.png#align=left&display=inline&height=100&margin=%5Bobject%20Object%5D&name=image.png&originHeight=199&originWidth=200&size=9164&status=done&style=none&width=100" alt="image.png"></p><ul><li><strong>万维网及其主要协议</strong></li><li>电子邮件</li></ul><h2 id="万维网是什么？有什么用？"><a href="#万维网是什么？有什么用？" class="headerlink" title="万维网是什么？有什么用？"></a>万维网是什么？有什么用？</h2><blockquote><p>用课本的概念：万维网用链接的方式能非常方便地从互联网上的一个站点访问另一个站点（也就是所谓的“链接到另一个站点”），从而主动地按需获取丰富的信息。</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1618626263044-e610396b-b7b5-4f11-a8f5-1499f0f7f5d8.png#align=left&display=inline&height=226&margin=%5Bobject%20Object%5D&name=image.png&originHeight=451&originWidth=955&size=63032&status=done&style=stroke&width=477.5" alt="image.png"><br>要达到这样的构想，架构这样的系统需要解决哪些问题呢？<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1618626404243-cf649c67-a499-46a3-a163-aad61a17c9b7.png#align=left&display=inline&height=104&margin=%5Bobject%20Object%5D&name=image.png&originHeight=208&originWidth=1132&size=50697&status=done&style=stroke&width=566" alt="image.png"></p><ol><li>利用 URL</li><li>HTTP 协议（基于 TCP）</li><li>HTML：就是超文本标记语言，这里不再赘述</li><li>搜索工具：搜索引擎工具，谷歌、百度……</li></ol><h2 id="HTTP-协议"><a href="#HTTP-协议" class="headerlink" title="HTTP 协议"></a>HTTP 协议</h2><h3 id="HTTP-的报文结构"><a href="#HTTP-的报文结构" class="headerlink" title="HTTP 的报文结构"></a>HTTP 的报文结构</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1618626839900-2a58c82a-1c27-427e-a902-6b21e3458b12.png#align=left&display=inline&height=397&margin=%5Bobject%20Object%5D&name=image.png&originHeight=793&originWidth=858&size=171966&status=done&style=stroke&width=429" alt="image.png"></p><h3 id="请求报文实例"><a href="#请求报文实例" class="headerlink" title="请求报文实例"></a>请求报文实例</h3><p>请求行中的方法，就是对所请求对象进行的操作，具体有以下一些方法：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1618627091156-cd978f06-4e39-41ea-9652-0ceddab98bb7.png#align=left&display=inline&height=175&margin=%5Bobject%20Object%5D&name=image.png&originHeight=349&originWidth=682&size=46050&status=done&style=stroke&width=341" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1618627123440-4ed5d351-96a7-4228-a9fe-aaff7e5bb9e2.png#align=left&display=inline&height=186&margin=%5Bobject%20Object%5D&name=image.png&originHeight=371&originWidth=949&size=77130&status=done&style=stroke&width=474.5" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1618627710005-1577f282-ff85-4fd2-a6ae-51187928044e.png#align=left&display=inline&height=298&margin=%5Bobject%20Object%5D&name=image.png&originHeight=596&originWidth=885&size=140277&status=done&style=stroke&width=442.5" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1618627722921-07c819d7-b873-4644-8cb0-844ff27450d0.png#align=left&display=inline&height=68&margin=%5Bobject%20Object%5D&name=image.png&originHeight=136&originWidth=828&size=19552&status=done&style=stroke&width=414" alt="image.png"><br>具体在浏览器的显示为：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1618627622010-49ba1876-a555-41a6-85b6-f23bc458ac82.png#align=left&display=inline&height=331&margin=%5Bobject%20Object%5D&name=image.png&originHeight=662&originWidth=1248&size=73626&status=done&style=stroke&width=624" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1618627640727-1204203a-4f3e-4fff-a388-fa47224fd7a0.png#align=left&display=inline&height=163&margin=%5Bobject%20Object%5D&name=image.png&originHeight=325&originWidth=1237&size=35473&status=done&style=stroke&width=618.5" alt="image.png"></p><h3 id="本地存储和-Cookie"><a href="#本地存储和-Cookie" class="headerlink" title="本地存储和 Cookie"></a>本地存储和 Cookie</h3><p>自己搭建个人网站的时候，有这么一个功能，<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1618627885598-f7d86695-ab4b-47b1-84de-1f7131daf095.png#align=left&display=inline&height=72&margin=%5Bobject%20Object%5D&name=image.png&originHeight=143&originWidth=1920&size=24745&status=done&style=none&width=960" alt="image.png"><br>对用户在本地浏览器里面点击这个伸缩布局按钮，下一次再打开网站，浏览器会记住这个布局，我是使用的 localSession 这个对象方法，因为是静态网站，这样实现还是比较友好的<img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1618628002219-e1725906-d456-4930-bba7-cc800938c02f.png#align=left&display=inline&height=268&margin=%5Bobject%20Object%5D&name=image.png&originHeight=536&originWidth=1920&size=183363&status=done&style=none&width=960" alt="image.png"><br>这是静态站点使用的友好方式，比较灵活的还有 Cookie 方式，特别是在动态网站的搭建过程中。<br>在 Node.js 框架 Express 里面利用“express-session”插件来使用 Cookie。</p><ul><li>Cookie 会记录客户端和服务端之间的信息</li><li>每次请求都会默认携带 Cookie</li><li>会被加密，安全</li></ul><p>关于安全问题，课本上的表述是这样的：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1618628510004-3df5120d-f238-4a6c-9dc8-e9c803283163.png#align=left&display=inline&height=245&margin=%5Bobject%20Object%5D&name=image.png&originHeight=490&originWidth=931&size=87665&status=done&style=stroke&width=465.5" alt="image.png"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>《计算机网络》第 7 版——谢希仁</li><li><a href="https://www.html.cn/qa/other/21226.html">万维网和互联网的区别是什么？</a></li><li><a href="https://www.zhihu.com/question/368324676/answer/988997873">为什么需要，以及如何设计应用层协议？</a></li><li><a href="https://blog.csdn.net/u010076558/article/details/17620719">几种远程控制协议</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> ComputerNetwork </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>实验4——超市排队机（队列）</title>
      <link href="blog/zgiaxv/"/>
      <url>blog/zgiaxv/</url>
      
        <content type="html"><![CDATA[<h2 id="实验任务"><a href="#实验任务" class="headerlink" title="实验任务"></a>实验任务</h2><p>实验 4：队列的链式表示和实现<br>    要求：某小超市有两个排队机，构建 2 个用带头结点的单链表队列 QA 和 QB, 实现下列操作<br>       1、初始化队列(清空)；<br>       2、入队；<br>       3、出队;<br>       4、求队列长度；<br>       5、判断队列是否为空；<br>       6、判断队列是否为满；<br>       7、对于队列 QA 和 QB，如果其中一个队列的售货员下班，则自动甩到另一个队列后面。<br>截止日期：4 月 22 日</p><h2 id="实验讨论"><a href="#实验讨论" class="headerlink" title="实验讨论"></a>实验讨论</h2><div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">觉得问题里面有bug</div><p>对问题判满的疑惑与解决，第六个问题对链对判满是否有意义，如果是链式存储，数据结构本身判断满没有意义，但是考虑到是小型超市，超市空间不大，所以对其进行一开始的用户自己输入两个队列的最大长度。</p><p>但是这样又有一个问题，在问题 7 中，如果一个队列的售货员下班了，这个队列的所有人排到另一个队列中，那如果新队列的长度超出用户输入的队列最大长度呢？考虑到实际问题，这个问题不打算解决了，让他们挤挤……</p><h2 id="代码代码"><a href="#代码代码" class="headerlink" title="代码代码"></a>代码代码</h2><pre><code class="cpp">#include&lt;bits/stdc++.h&gt;using namespace std;typedef int Status;typedef int QElemType;#define OVERFLOW -1#define ERROR 0#define OK 1/**    实验4：队列的链式表示和实现    要求：某小超市有两个排队机，构建2个用带头结点的单链表队列QA和QB, 实现下列操作        1、初始化队列(清空)；        2、入队；        3、出队;        4、求队列长度；        5、判断队列是否为空；        6、判断队列是否为满；        7、对于队列QA和QB，如果其中一个队列的售货员下班，则自动甩到另一个队列后面。 *//* 存储形式 */typedef struct QNode&#123; //链队用的结点    QElemType data;    struct QNode *next;&#125;QNode,*QueuePtr;typedef struct &#123;    QueuePtr front;    QueuePtr rear;&#125;LinkQueue;/* 初始化 */Status InitQueue(LinkQueue &amp;queue) &#123;    queue.front = queue.rear = new QNode;    queue.front-&gt;next = NULL;    return OK;&#125;/* 求队列长度 */Status QueueLength(LinkQueue &amp;queue) &#123;    int count = 0;    if (queue.rear == queue.front) &#123;        return count;    &#125;    QueuePtr temp = queue.front;    while (temp != queue.rear) &#123;        count++;        temp = temp-&gt;next;    &#125;    return count;&#125;/* 入队 */Status EnQueue(LinkQueue &amp;queue, QElemType e, int length) &#123;    if (QueueLength(queue) &lt;length) &#123;        QueuePtr temp = new QNode;        temp-&gt;data = e;        temp-&gt;next = NULL;        queue.rear-&gt;next = temp;        queue.rear = temp;        return OK;    &#125; else &#123;        cout &lt;&lt; &quot;队已经满了，不能再入元素了&quot;&lt;&lt; &quot;\n&quot;;        return ERROR;    &#125;&#125;/* 出队 */Status DeQueue(LinkQueue &amp;queue) &#123;    if (queue.front == queue.rear) &#123;        return OVERFLOW;    &#125;    // 有必要定义一个p，不然头结点会掉    QueuePtr p = queue.front-&gt;next;    QElemType e = p-&gt;data;    queue.front-&gt;next = p-&gt;next;    // 考虑最后一个元素被删，队尾指针指向头结点    if (queue.rear == p) &#123;        queue.rear = queue.front;    &#125;    return e;&#125;/* 取队头元素 */// Status GetHead(LinkQueue &amp;queue) &#123;//     if (queue.front != queue.rear)&#123;//         return queue.front-&gt;next-&gt;data;//     &#125;// &#125;/* 判断队列是否为空 */bool QueueIsEmpty(LinkQueue &amp;queue) &#123;    if (queue.rear == queue.front) &#123;        return true;    &#125; else &#123;        return false;    &#125;&#125;/** * 判断队列是否为满 * 不是很理解为什么链队需要判断是否为满呢？ * 采用输入链队长度，利用链队函数来判断 * 那么入队的代码需要输入length参数来判断是否还能让元素入队 */bool QueueIsFull(LinkQueue &amp;queue, int length) &#123;    if (QueueLength(queue) == length) &#123;        return true;    &#125; else &#123;        return false;    &#125;&#125;/* 一个队列甩到另一个队列 */Status QueueMove(LinkQueue &amp;queue_delete,LinkQueue &amp;queue_add) &#123;    queue_add.rear-&gt;next = queue_delete.front-&gt;next;    queue_add.rear = queue_delete.rear;    return OK;&#125;/* 遍历查看队列元素 */Status DisplayQueue(LinkQueue &amp;queue) &#123;    LinkQueue L = queue;    while (L.front-&gt;next != NULL) &#123;        cout &lt;&lt; L.front-&gt;next-&gt;data &lt;&lt; &quot; &quot;;        L.front = L.front-&gt;next;    &#125;    cout &lt;&lt; &quot;\n&quot;;    return OK;&#125;int main() &#123;    cout&lt;&lt;&quot;------------------------链队菜单----------------------&quot;&lt;&lt;&#39;\n&#39;;    cout&lt;&lt;&quot;操作0：退出程序&quot;&lt;&lt;&#39;\n&#39;;    cout&lt;&lt;&quot;操作1：初始化两队列&quot;&lt;&lt;&#39;\n&#39;;    cout&lt;&lt;&quot;操作2：入队操作&quot;&lt;&lt;&#39;\n&#39;;    cout&lt;&lt;&quot;操作3：出队操作&quot;&lt;&lt;&#39;\n&#39;;    cout&lt;&lt;&quot;操作4：判断判断链队是否为空&quot;&lt;&lt;&#39;\n&#39;;    cout&lt;&lt;&quot;操作5：判断判断链队是否为满&quot;&lt;&lt;&#39;\n&#39;;    cout&lt;&lt;&quot;操作6：售货员偷懒选项&quot;&lt;&lt;&#39;\n&#39;;    cout&lt;&lt;&quot;操作7：查看队列&quot;&lt;&lt;&#39;\n&#39;;    cout&lt;&lt;&quot;操作8：求队列长度&quot;&lt;&lt;&#39;\n&#39;;    cout&lt;&lt;&quot;--------------------------------------------------------&quot;&lt;&lt;&#39;\n&#39;;    int a, length,flag = 1;    cout &lt;&lt; &quot;请输入你希望排队机最多能排的人数：&quot;&lt;&lt;&quot;\n&quot;&lt;&lt;&quot;\n&quot;;    cin &gt;&gt; length;    LinkQueue QA,QB;    while(flag)    &#123;        cout&lt;&lt;&#39;\n&#39;&lt;&lt;&quot;请选择要执行的操作：&quot;;        while(cin&gt;&gt;a)        &#123;            if(a &lt; 0 || a &gt; 8)                cout&lt;&lt;&quot;请选择正确操作编号：&quot;;            else                break;        &#125;        switch(a)        &#123;            case 0:            &#123;                cout&lt;&lt;&quot;正在退出程序中……&quot;&lt;&lt;&#39;\n&#39;;                flag = 0;                break;            &#125;            case 1:            &#123;                cout&lt;&lt;&quot;初始化QA、QB队列中……&quot;&lt;&lt;&#39;\n&#39;;                InitQueue(QA);                InitQueue(QB);                break;            &#125;            case 2:            &#123;                cout&lt;&lt;&quot;请输入入队的队列（QA输入1，QB输入2）&quot;&lt;&lt;&#39;\n&#39;;                int select_queue;                cin &gt;&gt; select_queue;                if (select_queue == 1) &#123;                    cout&lt;&lt;&quot;请输入入QA队的队列的元素&quot;&lt;&lt;&#39;\n&#39;;                    int select_queue_A;                    cin &gt;&gt; select_queue_A;                    EnQueue(QA, select_queue_A, length);                &#125; else if (select_queue == 2) &#123;                    cout&lt;&lt;&quot;请输入入QB队的队列的元素&quot;&lt;&lt;&#39;\n&#39;;                    int select_queue_B;                    cin &gt;&gt; select_queue_B;                    EnQueue(QB, select_queue_B, length);                &#125; else &#123;                    cout &lt;&lt; &quot;输入有误！&quot;&lt;&lt; &quot;\n&quot;;                &#125;                break;            &#125;            case 3:            &#123;                cout&lt;&lt;&quot;请输入需要出队的队列（QA输入1，QB输入2）&quot;&lt;&lt;&#39;\n&#39;;                int select_queue;                cin &gt;&gt; select_queue;                if (select_queue == 1) &#123;                    DeQueue(QA);                &#125; else if (select_queue == 2) &#123;                    DeQueue(QB);                &#125; else &#123;                    cout &lt;&lt; &quot;输入有误！&quot;&lt;&lt; &quot;\n&quot;;                &#125;                break;            &#125;            case 4:            &#123;                cout&lt;&lt;&quot;请输入需要判空的队列（QA输入1，QB输入2）&quot;&lt;&lt;&#39;\n&#39;;                int select_queue;                cin &gt;&gt; select_queue;                if (select_queue == 1) &#123;                    cout &lt;&lt; &quot;QA队列为空吗？&quot;&lt;&lt; boolalpha &lt;&lt; QueueIsEmpty(QA) &lt;&lt; &quot;\n&quot;;                &#125; else if (select_queue == 2) &#123;                    cout &lt;&lt; &quot;QB队列为空吗？&quot;&lt;&lt; boolalpha &lt;&lt; QueueIsEmpty(QB) &lt;&lt; &quot;\n&quot;;                &#125; else &#123;                    cout &lt;&lt; &quot;输入有误！&quot;&lt;&lt; &quot;\n&quot;;                &#125;                break;            &#125;            case 5:            &#123;                cout&lt;&lt;&quot;请输入需要判满的队列（QA输入1，QB输入2）&quot;&lt;&lt;&#39;\n&#39;;                int select_queue;                cin &gt;&gt; select_queue;                if (select_queue == 1) &#123;                    cout &lt;&lt; &quot;QA队列为满吗？&quot;&lt;&lt; boolalpha &lt;&lt; QueueIsFull(QA,length) &lt;&lt; &quot;\n&quot;;                &#125; else if (select_queue == 2) &#123;                    cout &lt;&lt; &quot;QB队列为满吗？&quot;&lt;&lt; boolalpha &lt;&lt; QueueIsFull(QB,length) &lt;&lt; &quot;\n&quot;;                &#125; else &#123;                    cout &lt;&lt; &quot;输入有误！&quot;&lt;&lt; &quot;\n&quot;;                &#125;                break;            &#125;            case 6:            &#123;                cout&lt;&lt;&quot;请输入下班的售货员（QA输入1，QB输入2）&quot;&lt;&lt;&#39;\n&#39;;                int select_queue;                cin &gt;&gt; select_queue;                if (select_queue == 1) &#123;                    QueueMove(QA, QB);                &#125; else if (select_queue == 2) &#123;                    QueueMove(QB, QA);                &#125; else &#123;                    cout &lt;&lt; &quot;输入有误！&quot;&lt;&lt; &quot;\n&quot;;                &#125;                break;            &#125;            case 7:            &#123;                cout&lt;&lt;&quot;请输入要查看的队列（QA输入1，QB输入2）&quot;&lt;&lt;&#39;\n&#39;;                int select_queue;                cin &gt;&gt; select_queue;                if (select_queue == 1) &#123;                    DisplayQueue(QA);                &#125; else if (select_queue == 2) &#123;                    DisplayQueue(QB);                &#125; else &#123;                    cout &lt;&lt; &quot;输入有误！&quot;&lt;&lt; &quot;\n&quot;;                &#125;                break;            &#125;            case 8:            &#123;                cout&lt;&lt;&quot;请输入要查看的队列的长度（QA输入1，QB输入2）&quot;&lt;&lt;&#39;\n&#39;;                int select_queue;                cin &gt;&gt; select_queue;                if (select_queue == 1) &#123;                    cout&lt;&lt;QueueLength(QA)&lt;&lt; &quot;\n&quot;;                &#125; else if (select_queue == 2) &#123;                    cout&lt;&lt;QueueLength(QB)&lt;&lt; &quot;\n&quot;;                &#125; else &#123;                    cout &lt;&lt; &quot;输入有误！&quot;&lt;&lt; &quot;\n&quot;;                &#125;                break;            &#125;        &#125;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> DataStructure </category>
          
          <category> Problems </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++队列顺序和链式实现及操作</title>
      <link href="blog/fbfgft/"/>
      <url>blog/fbfgft/</url>
      
        <content type="html"><![CDATA[<h2 id="顺序循环队列"><a href="#顺序循环队列" class="headerlink" title="顺序循环队列"></a>顺序循环队列</h2><pre><code class="cpp">#include&lt;bits/stdc++.h&gt;using namespace std;typedef int Status;typedef int QElemType;#define OVERFLOW -1#define ERROR 0#define OK 1#define MAXSIZE 100/** * 循环队列——队列的顺序表示和实现 * * 操作：初始化、队列长度、入队、出队、取队头元素 *//* 存储形式 */typedef struct &#123;    QElemType *base;    int front;    int rear;&#125; SqQueue;/* 初始化 */Status InitQueue(SqQueue &amp;queue) &#123;    // 初始化这个base地址为一个有最大容量的数组初地址    queue.base = new int[MAXSIZE];    if (!queue.base) &#123;        return OVERFLOW;    &#125;    queue.front = queue.rear = 0;    return OK;&#125;/* 求队列长度 */Status QueueLength(SqQueue &amp;queue) &#123;    return (queue.rear - queue.front + MAXSIZE) % MAXSIZE;&#125;/* 入队 */Status EnQueue(SqQueue &amp;queue, QElemType e) &#123;    if ((queue.rear+1)%MAXSIZE == queue.front) &#123;        return OVERFLOW;    &#125;    queue.base[queue.rear] = e;    queue.rear = (queue.rear + 1) % MAXSIZE;    return OK;&#125;/* 出队 */Status DeQueue(SqQueue &amp;queue) &#123;    if ((queue.rear+1)%MAXSIZE == queue.front) &#123;        return OVERFLOW;    &#125;    QElemType e = queue.base[queue.front];    queue.front = (queue.front + 1) % MAXSIZE; //队头指针+1    return e;&#125;/* 取队头元素 */Status GetHead(SqQueue &amp;queue) &#123;    if (queue.front != queue.rear) &#123;        return queue.base[queue.front];    &#125;&#125;int main() &#123;    SqQueue test;    InitQueue(test);    EnQueue(test, 10);    EnQueue(test, 15);    EnQueue(test, 20);    cout &lt;&lt; &quot;队列长度为：&quot; &lt;&lt; QueueLength(test) &lt;&lt; &quot;\n&quot;;    cout &lt;&lt; GetHead(test)&lt;&lt;&quot; &quot;&lt;&lt; GetHead(test)&lt;&lt;&quot; &quot;&lt;&lt; GetHead(test)&lt;&lt;&quot; &quot;&lt;&lt;&quot;\n&quot;;    cout &lt;&lt; DeQueue(test)&lt;&lt;&quot; &quot;&lt;&lt; DeQueue(test)&lt;&lt;&quot; &quot;&lt;&lt; DeQueue(test)&lt;&lt;&quot; &quot;&lt;&lt;&quot;\n&quot;;&#125;</code></pre><h2 id="链队"><a href="#链队" class="headerlink" title="链队"></a>链队</h2><pre><code class="cpp">#include&lt;bits/stdc++.h&gt;using namespace std;typedef int Status;typedef int QElemType;#define OVERFLOW -1#define ERROR 0#define OK 1#define MAXSIZE 100/** * 链队——队列的链式表示和实现 * * 操作：初始化、入队、出队、取队头元素 *//* 存储形式 */typedef struct QNode&#123; //链队用的结点    QElemType data;    struct QNode *next;&#125;QNode,*QueuePtr;typedef struct &#123;    QueuePtr front;    QueuePtr rear;&#125;LinkQueue;/* 初始化 */Status InitQueue(LinkQueue &amp;queue) &#123;    queue.front = queue.rear = new QNode;    queue.front-&gt;next = NULL;    return OK;&#125;/* 入队 */Status EnQueue(LinkQueue &amp;queue, QElemType e) &#123;    QueuePtr temp = new QNode;    temp-&gt;data = e;    temp-&gt;next = NULL;    queue.rear-&gt;next = temp;    queue.rear = temp;    return OK;&#125;/* 出队 */Status DeQueue(LinkQueue &amp;queue) &#123;    if (queue.front == queue.rear) &#123;        return OVERFLOW;    &#125;    QElemType e = queue.front-&gt;next-&gt;data;    queue.front-&gt;next = queue.front-&gt;next-&gt;next;    // 考虑最后一个元素被删，队尾指针指向头结点    if (queue.rear == queue.front) &#123;        queue.front = queue.rear;    &#125;    return e;&#125;/* 取队头元素 */Status GetHead(LinkQueue &amp;queue) &#123;    if (queue.front != queue.rear)&#123;        return queue.front-&gt;next-&gt;data;    &#125;&#125;int main() &#123;    LinkQueue test;    InitQueue(test);    EnQueue(test, 10);    EnQueue(test, 15);    EnQueue(test, 20);    // cout &lt;&lt; &quot;队列长度为：&quot; &lt;&lt; QueueLength(test) &lt;&lt; &quot;\n&quot;;    cout &lt;&lt; GetHead(test)&lt;&lt;&quot; &quot;&lt;&lt; GetHead(test)&lt;&lt;&quot; &quot;&lt;&lt; GetHead(test)&lt;&lt;&quot; &quot;&lt;&lt;&quot;\n&quot;;    cout &lt;&lt; DeQueue(test)&lt;&lt;&quot; &quot;&lt;&lt; DeQueue(test)&lt;&lt;&quot; &quot;&lt;&lt; DeQueue(test)&lt;&lt;&quot; &quot;&lt;&lt;&quot;\n&quot;;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> DataStructure </category>
          
          <category> 线结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++栈顺序和链式实现及操作</title>
      <link href="blog/tlzqah/"/>
      <url>blog/tlzqah/</url>
      
        <content type="html"><![CDATA[<div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">存储形式以及操作和顺序表和链表差不多，需要的操作也少，学栈和队列，感觉只是抽离出来这两种便于在应用层面使用</div><h2 id="顺序栈"><a href="#顺序栈" class="headerlink" title="顺序栈"></a>顺序栈</h2><pre><code class="cpp">#include&lt;bits/stdc++.h&gt;typedef int Status;typedef int SElemType;#define OVERFLOW -1#define ERROR 0#define OK 1#define MAXSIZE 100using namespace std;/** * 顺序栈 * * 顺序栈的基本操作：初始化、入栈、出栈、取栈顶元素 *//* 顺序栈的存储形式 */typedef struct &#123;    SElemType *base;    SElemType *top;    int stacksize;&#125; SqStack;/* 初始化 */Status InitSqStack(SqStack &amp;stack) &#123;    // 为栈分配容量    stack.base = new int[MAXSIZE];    // 分配失败返回失败值    if (!stack.base) &#123;        return OVERFLOW;    &#125;    // 让栈顶地址初始为栈底地址    stack.top = stack.base;    // 初始化容量    stack.stacksize = MAXSIZE;    return OK;&#125;/* 入栈 */Status Push(SqStack &amp;stack, SElemType e) &#123;    if (stack.top - stack.base == stack.stacksize) &#123;        return OVERFLOW;    &#125;    *stack.top = e; // 先在top位置赋值    stack.top++; // 将top地址++    return OK;&#125;/* 出栈 */Status Pop(SqStack &amp;stack) &#123;    // 空栈返回异常    if (stack.top == stack.base) &#123;        return OVERFLOW;    &#125;    stack.top--; // 栈顶地址减1    return *stack.top; // 返回此时“栈顶”元素&#125;/* 取栈顶元素 */Status GetTop (SqStack &amp;stack) &#123;    // 空栈返回异常    if (stack.top == stack.base) &#123;        return OVERFLOW;    &#125;    // stack.top--; // 栈顶地址减1，这是和出栈的区别    return *(stack.top-1); // 返回此时“栈顶”元素&#125;int main() &#123;    SqStack test;    InitSqStack(test);    Push(test, 10);    Push(test, 15);    Push(test, 20);    cout &lt;&lt; GetTop(test)&lt;&lt;&quot; &quot;&lt;&lt; GetTop(test)&lt;&lt;&quot; &quot;&lt;&lt; GetTop(test)&lt;&lt;&quot; &quot;&lt;&lt;&quot;\n&quot;;    cout &lt;&lt; Pop(test)&lt;&lt;&quot; &quot;&lt;&lt; Pop(test)&lt;&lt;&quot; &quot;&lt;&lt; Pop(test)&lt;&lt;&quot; &quot;&lt;&lt;&quot;\n&quot;;&#125;</code></pre><h2 id="链栈"><a href="#链栈" class="headerlink" title="链栈"></a>链栈</h2><pre><code class="cpp">#include&lt;bits/stdc++.h&gt;typedef int Status;typedef int SElemType;#define OVERFLOW -1#define ERROR 0#define OK 1#define MAXSIZE 100using namespace std;/** * 链栈 * * 链栈的基本操作：初始化、入栈、出栈、取栈顶元素 *//* 链栈的存储形式 */typedef struct StackNode&#123;    SElemType data;    struct StackNode *next;&#125; StackNode, *LinkStack;/** * 初始化 * 不设头结点 */Status InitLinkStack(LinkStack &amp;stack) &#123;    stack = NULL; // 栈顶元素置空    return OK;&#125;/* 入栈 */Status Push(LinkStack &amp;stack, SElemType e) &#123;    // 不能用LinkStack这样声明结点变量，需要new一个内存空间    LinkStack temp = new StackNode;    temp-&gt;data = e;    temp-&gt;next = stack;    stack = temp;    return OK;&#125;/* 出栈 */Status Pop (LinkStack &amp;stack) &#123;    SElemType i = stack-&gt;data;    stack = stack-&gt;next;    return i;&#125;/* 取栈顶元素 */Status GetTop (LinkStack &amp;stack) &#123;    return stack-&gt;data;&#125;int main() &#123;    LinkStack test;    InitLinkStack(test);    Push(test, 10);    Push(test, 15);    Push(test, 20);    cout &lt;&lt; GetTop(test)&lt;&lt;&quot; &quot;&lt;&lt; GetTop(test)&lt;&lt;&quot; &quot;&lt;&lt; GetTop(test)&lt;&lt;&quot; &quot;&lt;&lt;&quot;\n&quot;;    cout &lt;&lt; Pop(test)&lt;&lt;&quot; &quot;&lt;&lt; Pop(test)&lt;&lt;&quot; &quot;&lt;&lt; Pop(test)&lt;&lt;&quot; &quot;&lt;&lt;&quot;\n&quot;;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> DataStructure </category>
          
          <category> 线结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>缺爱</title>
      <link href="essay/xikynq/"/>
      <url>essay/xikynq/</url>
      
        <content type="html"><![CDATA[<div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">《刀剑神域》《东京食尸鬼》《进击的巨人》的一些关于“缺爱”这个词的一些感悟……</div><p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1620269016472-0205bffa-da28-4411-9950-1b94025de0f7.jpeg#height=310&id=u9b47b8b9&margin=%5Bobject%20Object%5D&originHeight=619&originWidth=1100&originalType=binary%E2%88%B6=1&status=done&style=none&width=550"></p><p>缺爱的人，内心总有一些渴望，渴望被关爱，渴望被呵护，渴望对方是自己心里想要的模样……这种渴望是一种游走在刀尖上的隐式力量，甚至，会让一个人人格变化，变成一个我们都不在认识的人……</p><p>尤吉欧缺的是从小的青梅竹马爱丽丝的爱，在面对最高祭司的亲昵……当然，尤吉欧的强大就强大在，他无条件相信挚友桐人，即便是那般情形，他也从刀尖上走向了正确的道路。金木研缺少的是母爱，的佣人，缺少的是家主的关爱</p><p>兵长利威尔，就更不用说了，人类中外挂，绝对的强者，他缺少的不仅是亲人的爱，更是这个世界的压抑与社会的动荡，地下生活，从小就仰头看不见天空，低头被人唾弃，这缺的简直是一个世界啊，他心里也是多么珍视自己的爱和他人的爱，最初的两个小伙伴，再到利威尔整个班，还有……佩特拉……</p><p>如果说这个世界真有一种至暗力量，缺爱或许也是其一呢~这个世界谁都没错，错的是这个世界，那么 我又为何一直低头呢？这就是缺爱的至暗力量……</p><p>生活中，也有很多啊，跟班，小时候的孩子，经常有跟班一说，如果你是和别人相爱的人，那么你可以给对方更多一点的爱，如果你是为人父母，你可以更加爱自己的子女，爱，从来都不嫌多，两个人之间的爱情也是一样</p><p>人与人之间，不要让对方、让彼此缺爱……</p><p>你仔细看看，缺爱的人好多，小什造，又何尝不是，</p><p>这部剧好就好在，没有没有对错，没有哪一方是绝对的正确，贯穿全剧的就是一句话——“错的不是我，而是这个世界”</p><p>写着写着，简直我就要黑化一般<img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1618565453724-89af8f91-a000-4be3-bddd-cb1708cc5065.jpeg#height=52&id=fQUdE&originHeight=52&originWidth=52&originalType=binary%E2%88%B6=1&status=done&style=stroke&width=52"></p><p><code>2021.05.06</code></p><p>上网搜了一下，缺爱还是有相应的词条的：<a href="https://baike.baidu.com/item/%E7%BC%BA%E7%88%B1/4544029">缺爱·百度百科</a></p><blockquote><p>缺爱：一般指缺少关爱的孩子的一种心情表现形式，着调于凄凉寂寞的非乐观主义。缺爱的孩子性格往往和普通孩子不一样，思想也成熟的早一点，但是较容易走极端。<br>——百度百科</p></blockquote><blockquote><p>表现：缺爱的孩子性格往往和普通孩子不一样，思想也成熟的早一点，但是容易走极端，比较叛逆，一般能力较强，事业心强，但在内心里缺乏安全感，不论拥有再多，始终担忧如果有一天失去了怎么办。<br>缺爱的孩子比较喜欢自己一个人不声不响的做事，性格比较孤僻，一般让人看上去会形容他“感觉这个人有很多心事”。</p></blockquote><blockquote><p>对于爱情，缺爱的孩子比较“慢热”，心里有恐惧感，害怕如果我投入了结果会怎样…… 但是一旦投入了，就会比较偏激的把自己认为好的全部给对方。不管这爱是亲情，友情，爱情，他都是全方位的去考虑去付出。因为他缺少爱，他全身心的付出内心里也是希望对方能像他一样全身心付出的对他好。如果没有得到期望中的回报或者被人所不屑，心中必然是由爱生恨，他们的爱恨往往比较极端。</p></blockquote><blockquote><p>单亲家庭的孩子、孤儿、重男轻女家庭的女儿、重小轻大家庭的大孩一般都会存在缺爱的现象，这是一个比较普遍的现象。</p></blockquote><blockquote><p>缺爱的孩子需要社会的关心，不然容易变坏，社会上这样的例子很多。<br>——百度百科</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>实验3——求LA和LB(用单链表表示)的并和交集</title>
      <link href="blog/tw2cvt/"/>
      <url>blog/tw2cvt/</url>
      
        <content type="html"><![CDATA[<h2 id="实验要求"><a href="#实验要求" class="headerlink" title="实验要求"></a>实验要求</h2><p>求两个集合 LA 和 LB(用单链表表示)的并和交集<br>要求：在实验二的基础上，使用单链表表示集合。编写两个算法（求交算法和求并算法），并输出最终的结果。<br>测试用例：集合 A 为{3，4，1，6}，集合 A 为{2，3，6，7}，<br>           交集为{3，6}<br>           并集为{1，2，3，4，6，7}<br>交作业时间：4 月 16 日</p><h2 id="实验代码"><a href="#实验代码" class="headerlink" title="实验代码"></a>实验代码</h2><pre><code class="cpp">#include&lt;bits/stdc++.h&gt;using namespace std;/** * 求两个集合LA和LB(用单链表表示)的并和交集 *//* 单链表的存储结构 */typedef struct LNode &#123;    int data; //数据域    struct LNode *next; //指针域&#125;Lnode, *LinkList; //LinkList为指向结构体LNode的指针类型/* 初始化链表 */void InitList(LinkList &amp;L) &#123;    L = new LNode;    L-&gt;next = NULL;&#125;/* 创建：后插 */void CreateList_R(LinkList &amp;L, int n) &#123;    cout &lt;&lt; &quot;请输入&quot; &lt;&lt; n &lt;&lt; &quot;个数字&quot;&lt;&lt; &quot;\n&quot;;    InitList(L);    // 定义一个在下面循环用来一直操作所加元素的结点p来指向头结点L    LinkList p = L;    for (int i = 0; i &lt; n;i++) &#123;        LinkList q = new Lnode;        q-&gt;next = NULL;        cin &gt;&gt; q-&gt;data;        p-&gt;next = q;        p = q; //为了下一次    &#125;&#125;/* 打印 */void TraverseList(LinkList &amp; L)&#123;        LinkList p = new LNode;        p = L-&gt;next;        cout &lt;&lt; &quot;此链表打印的结果为：&quot;&lt;&lt; &quot;\n&quot;;        while (p != NULL)        &#123;            cout &lt;&lt; p-&gt;data &lt;&lt; &quot; &quot;;            p = p-&gt;next;        &#125;        cout &lt;&lt; &quot;\n&quot;;&#125;/* 排序单链表 */void sort(LinkList &amp;L) &#123;&#125;/* jiao算法 */void jiao(LinkList &amp;A,LinkList &amp;B) &#123;    // 用双循环得出共有的元素并输出    LinkList p;    InitList(p);    A = A-&gt;next;    B = B-&gt;next;    while (A != NULL ) &#123;        LinkList copy_b = B;        while(copy_b != NULL) &#123;            if (A-&gt;data == copy_b-&gt;data) &#123;                LinkList temp = new Lnode;                temp-&gt;data = copy_b-&gt;data;                temp-&gt;next = p-&gt;next;                p-&gt;next = temp;                break;            &#125; else &#123;                copy_b = copy_b-&gt;next;            &#125;        &#125;        A = A-&gt;next;    &#125;    while(p-&gt;next != NULL) &#123;        cout &lt;&lt; p-&gt;next-&gt;data &lt;&lt; &quot; &quot;;        p = p-&gt;next;    &#125;&#125;/* bing算法 */void bing(LinkList &amp;A,LinkList &amp;B) &#123;    LinkList p = A;    LinkList s = B;    A = A-&gt;next;    B = B-&gt;next;    while (A != NULL ) &#123;        LinkList copy_b = B;        while(copy_b != NULL) &#123;            if (A-&gt;data == copy_b-&gt;data) &#123;                // cout &lt;&lt; A-&gt;data &lt;&lt; &quot;\n&quot;;                // 在p链里面删除A-&gt;data值                LinkList q = p;                while(q-&gt;next != NULL) &#123;                    if (q-&gt;next-&gt;data == A-&gt;data) &#123;                        q-&gt;next = q-&gt;next-&gt;next;                        break;                    &#125; else &#123;                        q = q-&gt;next;                    &#125;                &#125;                break;            &#125; else &#123;                copy_b = copy_b-&gt;next;            &#125;        &#125;        A = A-&gt;next;    &#125;    // 将p链表连接到s链表上    LinkList result = p;    while (p != NULL) &#123;        if (p-&gt;next == NULL) &#123;            p-&gt;next = s-&gt;next;            break;        &#125;        p = p-&gt;next;    &#125;    while(result-&gt;next != NULL) &#123;        cout &lt;&lt; result-&gt;next-&gt;data &lt;&lt; &quot; &quot;;        result = result-&gt;next;    &#125;&#125;int main() &#123;    LinkList list_A;    LinkList list_B;    InitList(list_A);    InitList(list_B);    CreateList_R(list_A, 6);    CreateList_R(list_B, 6);    LinkList list_C = list_A;    LinkList list_D = list_B;    cout &lt;&lt;&quot;A、B交集的值为：&quot;;    jiao(list_A, list_B);    cout &lt;&lt;&quot;\n&quot;&lt;&lt;&quot;A、B并集的值为：&quot;;    bing(list_C, list_D);&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> DataStructure </category>
          
          <category> Problems </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>“ 错的不是我，是这个世界”</title>
      <link href="essay/lu9dks/"/>
      <url>essay/lu9dks/</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1619799998545-a5718c40-08b7-4571-84a2-c79b4396d498.jpeg#height=1112&id=WX9p5&margin=%5Bobject%20Object%5D&name=Screenshot_20210429_234712_edit_1449910826681363.jpg&originHeight=1112&originWidth=2154&originalType=binary&size=349927&status=done&style=none&width=2154" alt="Screenshot_20210429_234712_edit_1449910826681363.jpg"><br>不……不是我的错<br>不对 都是我 都是我的错</p><p>事到如今 你还在说这么显而易见的事实<br>你就像这样责备自己 不断地责备自己</p><p>只是一味地责备自己 结果一点也没有改变<br>变成这样到底是谁的错<br>偶然 事故 运气<br><strong>运气是不存在的 那只是情况和情况的不同组合</strong><br>那又是谁制造了这种情况 是谁呢？<br>就是你啊<br><strong>世界上所有的不利因素都是因为当事人的能力不足</strong><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1618470547319-c45591d3-8c94-4a78-8e1d-83174784522b.png#height=540&id=u3e621b1a&margin=%5Bobject%20Object%5D&originHeight=1080&originWidth=1920&originalType=binary&size=607833&status=done&style=stroke&width=960"></p><p>事实如此<br>话说回来 一切的开端<br><strong>也就是因为你是一个不谙世事的笨蛋啊</strong><br>因为你是笨蛋 然后被我欺骗<br>还被医生动了手脚<br>所以变成了怪物</p><p>全部都是你的错<br>于其伤害他人 不如成为被伤害的那一方<br>所以你遇到这种事<br>如果你足够强到能够杀死壁虎的话<br>那两人就能得救了哦<br>或者如果你选择了男人的话 那个女人就可能得救了<br>那个时候也是如此<br><strong>如果你有足够实力的话</strong></p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1618470834142-4bea4e83-48a2-41fd-9246-e1f0b27c04e5.png#height=540&id=u8e685db7&margin=%5Bobject%20Object%5D&originHeight=1080&originWidth=1920&originalType=binary&size=1038551&status=done&style=stroke&width=960"></p><p>从今往后也一样<br>董香 雏实 英<br>你所珍视的人</p><p>明白了吗<br>这就是你所选择的生活方式<br>你所选择的未来啊<br>为什么要哭泣呢 为什么要呐喊呢<br>与其伤害他人 你选择成为被伤害的那一方不是吗<br>既温柔又美好<br>看似你两者都选择了<br>但实际上你两者都失去了<br>你的母亲也是如此</p><p>你其实也希望她这么做吧<br>请你……不要再说了</p><p>为什么<br>为什么留下我一个人<br>我不要孤单一人<br>我好希望你能够选择我啊</p><p>没错 金木<br><strong>『每个人都有必须舍弃某一边才能保护重要事物的时刻』</strong><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1618471315132-4f0b9cc2-ba10-4c59-8c6f-73475002e472.png#height=540&id=u5f1533bb&margin=%5Bobject%20Object%5D&originHeight=1080&originWidth=1920&originalType=binary&size=2481642&status=done&style=stroke&width=960"></p><p><strong>没做到这一点 只是软弱罢了</strong><br><strong>没有舍弃的坚强 缺乏深刻的觉悟</strong><br>你还能继续做被伤害的那一方吗<br>你还能原谅壁虎这种人吗</p><p>无法……无法原谅</p><p>你最重要的英 还有安定区的同伴们<br>都有可能遇到那种事</p><p><strong>你拥有做到这些的力量吗</strong><br><strong>我有…</strong><br><strong>那也就是你要接受我的意思吗</strong><br><strong>不对</strong><br><strong>并不是这样</strong><br><strong>我只要超越你就好了</strong><br><strong>即使这是错误的选择也没关系吗</strong><br><strong>『错的人不是我 错误的是…这个世界』</strong><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1618471631139-459ab7b1-8de4-439a-ba90-47ec64a973db.png#height=540&id=u359998a2&margin=%5Bobject%20Object%5D&originHeight=1080&originWidth=1920&originalType=binary&size=3208423&status=done&style=stroke&width=960"></p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1618471714779-46f493f2-f76d-4ae8-8016-82a8acc51e66.png#height=540&id=u0b809119&margin=%5Bobject%20Object%5D&originHeight=1080&originWidth=1920&originalType=binary&size=1977959&status=done&style=stroke&width=960"></p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1618472037932-fcffb7e6-0ca2-4f68-9c3d-52d865fd05ca.png#height=540&id=u82016ac2&margin=%5Bobject%20Object%5D&originHeight=1080&originWidth=1920&originalType=binary&size=2748009&status=done&style=stroke&width=960"></p><pre><code>教えて 教えてよその仕組みを僕の中に誰がいるの？壊れた 壊れたよこの世界で君が笑う何も見えずに壊れた僕なんてさ息を止めてほどけない もう ほどけないよ真実さえ freeze壊せる 壊せない狂える 狂えないあなたを見つけて 揺れた歪んだ世界にだんだん僕は透き通って見えなくなって見つけないで 僕のことを見つめないで誰かが描いた世界の中であなたを傷つけたくはないよ覚えていて 僕のことを鮮やかなまま無限に広がる孤独が絡まる無邪気に笑った記憶が刺さって動けない 動けない動けない 動けない動けない 動けないよUnravelling the world変わってしまった 変えられなかった2つが絡まる 2人が滅びる壊せる 壊せない狂える 狂えないあなたを汚せないよ 揺れた歪んだ世界にだんだん僕は透き通って見えなくなって見つけないで 僕のことを見つめないで誰かが仕組んだ孤独な罠に未来がほどけてしまう前に思い出して 僕のことを鮮やかなまま忘れないで 忘れないで忘れないで 忘れないで変わってしまったことに paralyze変えられないことだらけの paradise覚えていて 僕のことを教えて教えて僕の中に誰がいるの？</code></pre>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数据结构期中试题</title>
      <link href="blog/vq1his/"/>
      <url>blog/vq1his/</url>
      
        <content type="html"><![CDATA[<p>这是加密文章！</p>]]></content>
      
      
      <categories>
          
          <category> DataStructure </category>
          
          <category> 其他知识 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>art-template模板</title>
      <link href="blog/qhgult/"/>
      <url>blog/qhgult/</url>
      
        <content type="html"><![CDATA[<h2 id="art-template-和-express-art-template"><a href="#art-template-和-express-art-template" class="headerlink" title="art-template 和 express-art-template"></a>art-template 和 express-art-template</h2><div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">为了是art-template模板引擎能够更好地和Express框架配合，模板引擎官方在源art-template模板引擎的基础上封装了express-art-template，所以在使用Espress框架时候，这两个模块都要下载。</div><ul><li>art-template 官网：<a href="https://aui.github.io/art-template/zh-cn/docs/">https://aui.github.io/art-template/zh-cn/docs/</a></li><li>关于模板引擎：<a href="https://segmentfault.com/a/1190000020478061">6 个常见 JS 模板引擎</a></li></ul><h3 id="使用模板渲染情况下声明"><a href="#使用模板渲染情况下声明" class="headerlink" title="使用模板渲染情况下声明"></a>使用模板渲染情况下声明</h3><pre><code class="javascript">// 渲染后缀为art的模板时，所使用的模板引擎是什么app.engine(&quot;art&quot;, require(&quot;express-art-template&quot;));// 告诉express框架模板的位置app.set(&quot;views&quot;, path.join(__dirname, &quot;views&quot;));// 告诉express框架模板的默认后缀是什么app.set(&quot;view engine&quot;, &quot;art&quot;);</code></pre><h3 id="关于绝对-相对路径的引用"><a href="#关于绝对-相对路径的引用" class="headerlink" title="关于绝对/相对路径的引用"></a>关于绝对/相对路径的引用</h3><p><strong>模板资源里面引用静态资源的路径要用绝对路径</strong>。怎么使用绝对路径呢，类似 hexo 静态博客一样，前面加一个“/”即可是根目录路径下，再进行根目录路径下路径写法</p>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
          <category> node </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>MongoDB数据库学习笔记</title>
      <link href="blog/nwt63v/"/>
      <url>blog/nwt63v/</url>
      
        <content type="html"><![CDATA[<div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">对node.js支持较好，逻辑和MySQL一样，都是增删改查操作，导入，删除数据库等，都是一样的道理</div><h2 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h2><h3 id="下载及文档"><a href="#下载及文档" class="headerlink" title="下载及文档"></a>下载及文档</h3><ul><li>monggoDB 下载<a href="https://www.mongodb.com/try/download/community">https://www.mongodb.com/try/download/community</a></li><li>compass（可视化图形软件）下载<a href="https://www.mongodb.com/try/download/compass">https://www.mongodb.com/try/download/compass</a></li><li><a href="https://docs.mongodb.com/">官方英文文档</a></li><li><a href="https://docs.mongoing.com/">MongoDB 中文手册|官方文档中文版</a></li><li><a href="https://www.runoob.com/mongodb/mongodb-tutorial.html">https://www.runoob.com/mongodb/mongodb-tutorial.html</a></li></ul><h3 id="bug：不能开启-mongoDB"><a href="#bug：不能开启-mongoDB" class="headerlink" title="bug：不能开启 mongoDB"></a>bug：不能开启 mongoDB</h3><div style="background: #FFF3F3;padding:10px;border: 1px solid #DEB8BE;border-radius:5px;margin-bottom:5px;">原因：权限不足</div>~~有个问题：monggoDB数据库导入操作命令不能使用……~~用win+x点击![image.png](https://cdn.nlark.com/yuque/0/2021/png/1484158/1618147295109-5eac5ca0-1432-40dd-8917-530d76e11669.png#align=left&display=inline&height=198&margin=%5Bobject%20Object%5D&name=image.png&originHeight=396&originWidth=452&size=19182&status=done&style=none&width=226)然后在输入net start mongoDB即可（在此之前先关闭将start混成stop）<h3 id="和之前学过的数据库对比"><a href="#和之前学过的数据库对比" class="headerlink" title="和之前学过的数据库对比"></a>和之前学过的数据库对比</h3><p>和之前学过的数据库的概念有点出入，不是表、行、列的概念，对比如下<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1618190322743-0d9c69f2-c6a3-4819-b317-2e1587c47915.png#align=left&display=inline&height=403&margin=%5Bobject%20Object%5D&name=image.png&originHeight=805&originWidth=1149&size=141839&status=done&style=stroke&width=574.5" alt="image.png"></p><h2 id="mongoose"><a href="#mongoose" class="headerlink" title="mongoose"></a>mongoose</h2><h3 id="下载及文档-1"><a href="#下载及文档-1" class="headerlink" title="下载及文档"></a>下载及文档</h3><ul><li>下载 mongoose 第三方模块，让 node 链接 monggoDB 数据库</li><li>GitHub：<a href="https://github.com/Automattic/mongoose">https://github.com/Automattic/mongoose</a></li></ul><h3 id="连接数据库语句"><a href="#连接数据库语句" class="headerlink" title="连接数据库语句"></a>连接数据库语句</h3><p>在此之前打开数据库</p><pre><code class="javascript">// 链接数据库const mongoose = require(&quot;mongoose&quot;);mongoose  .connect(&quot;mongodb://localhost/blog&quot;, &#123;    useNewUrlParser: true,    useUnifiedTopology: true,  &#125;)  .then(() =&gt; &#123;    console.log(&quot;数据库连接成功&quot;);  &#125;)  .catch(() =&gt; &#123;    console.log(&quot;数据库连接失败&quot;);  &#125;);</code></pre><p>然后再将这个 js 文件 require 到 appjs 里面使用</p><h3 id="创建集合（SQL-里面的表）"><a href="#创建集合（SQL-里面的表）" class="headerlink" title="创建集合（SQL 里面的表）"></a>创建集合（SQL 里面的表）</h3><div style="background: #FFF3F3;padding:10px;border: 1px solid #DEB8BE;border-radius:5px;margin-bottom:5px;">在node下面的第三方模块mongoose下面进行相应操作</div><ul><li>先利用函数 mongoose 的 schema 函数构建一个规则</li><li>然后利用 model 函数创建一个集合并且用上这个规则</li></ul><pre><code class="javascript">// 创建一个集合(相当于sql里面的设定一个表)规则const couseSchema = new mongoose.Schema(&#123;  name: String,  authing: String,  isPublished: Boolean,&#125;);// 创建一个集合(并且应用上面的规则)const Course = mongoose.model(&quot;Course&quot;, couseSchema);</code></pre><h3 id="增-gt-文档（SQL-行）"><a href="#增-gt-文档（SQL-行）" class="headerlink" title="增-&gt;文档（SQL 行）"></a>增-&gt;文档（SQL 行）</h3><ul><li>create 函数</li><li>可以打印相关信息（doc 和 err）</li></ul><pre><code class="javascript">Course.create(&#123; name: &quot;名字&quot;, authing: &quot;作者&quot;, isPublished: true &#125;)  .then((doc) =&gt; console.log(doc))  .catch((err) =&gt; console.log(err));Course.create(  &#123; name: &quot;名字2&quot;, authing: &quot;作者2&quot;, isPublished: true &#125;,  (err, doc) =&gt; &#123;    console.log(err);    console.log(doc);  &#125;);</code></pre><ul><li>也可以创建一个对象赋值给一个变量，然后该变量利用函数 save 即可保存到数据库</li></ul><h3 id="删-gt-文档"><a href="#删-gt-文档" class="headerlink" title="删-&gt;文档"></a>删-&gt;文档</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1618193509511-9db6090c-af4e-4b61-af0b-4c510f97e270.png#align=left&display=inline&height=108&margin=%5Bobject%20Object%5D&name=image.png&originHeight=216&originWidth=836&size=14045&status=done&style=none&width=418" alt="image.png"></p><h3 id="改-gt-文档"><a href="#改-gt-文档" class="headerlink" title="改-&gt;文档"></a>改-&gt;文档</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1618193516298-a99483c7-1ac8-4528-b8d4-eac82af0f4e5.png#align=left&display=inline&height=88&margin=%5Bobject%20Object%5D&name=image.png&originHeight=175&originWidth=873&size=16353&status=done&style=none&width=436.5" alt="image.png"></p><h3 id="查-gt-文档"><a href="#查-gt-文档" class="headerlink" title="查-&gt;文档"></a>查-&gt;文档</h3><ul><li>查询函数 findOne：返回第一个文档</li><li>查询函数 find：查询所有包含条件的数据</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1618193492560-5e65f58f-91c2-4364-96b2-d1a19ebc24e8.png#align=left&display=inline&height=229&margin=%5Bobject%20Object%5D&name=image.png&originHeight=458&originWidth=990&size=42673&status=done&style=none&width=495" alt="image.png"></p><h3 id="mongoose-验证（SQL-约束）"><a href="#mongoose-验证（SQL-约束）" class="headerlink" title="mongoose 验证（SQL 约束）"></a>mongoose 验证（SQL 约束）</h3><p>required: true 必传字段<br>minlength：3 字符串最小长度<br>maxlength: 20 字符串最大长度<br>min: 2 数值最小为 2<br>max: 100 数值最大为 100<br>enum: [‘html’, ‘css’, ‘javascript’, ‘node.js’]<br>trim: true 去除字符串两边的空格<br>validate: 自定义验证器<br>default: 默认值</p><p>获取错误信息：error.errors[‘字段名称’].message</p><h3 id="集合关联"><a href="#集合关联" class="headerlink" title="集合关联"></a>集合关联</h3><p>相当于声明两个表的各自的字段在逻辑上是一样的，且存在形式也是一样的<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1618194147182-4a490fd5-0d2f-4cba-8ea4-f75e1aaab012.png#align=left&display=inline&height=241&margin=%5Bobject%20Object%5D&name=image.png&originHeight=482&originWidth=849&size=34473&status=done&style=none&width=424.5" alt="image.png"></p><h2 id="密码加密-bcrypt"><a href="#密码加密-bcrypt" class="headerlink" title="密码加密 bcrypt"></a>密码加密 bcrypt</h2><p>只能加密不能解密<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1618212451573-f1fb8a4f-f6c7-4964-adcb-f5abccca858b.png#align=left&display=inline&height=65&margin=%5Bobject%20Object%5D&name=image.png&originHeight=130&originWidth=436&size=9832&status=done&style=none&width=218" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
          <category> node </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Express框架</title>
      <link href="blog/bcbngo/"/>
      <url>blog/bcbngo/</url>
      
        <content type="html"><![CDATA[<h2 id="express"><a href="#express" class="headerlink" title="express"></a>express</h2><div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">一款Node.js的web应用框架</div><div style="background: #FFF3F3;padding:10px;border: 1px solid #DEB8BE;border-radius:5px;margin-bottom:5px;">学会**只看官方文档学会框架**，不看其他博客教程/视频教程</div><ul><li>官网：<a href="https://expressjs.com/">https://expressjs.com/</a></li><li>中文版本（4.1 版本）：<a href="https://expressjs.com/zh-cn/">https://expressjs.com/zh-cn/</a></li></ul><h3 id="常用方法小结"><a href="#常用方法小结" class="headerlink" title="常用方法小结"></a>常用方法小结</h3><blockquote><ul><li>官网：<a href="https://expressjs.com/en/4x/api.html">https://expressjs.com/en/4x/api.html</a></li><li>记录一些常用方法</li></ul></blockquote><div style="background: #FFF3F3;padding:10px;border: 1px solid #DEB8BE;border-radius:5px;margin-bottom:5px;">英语可太重要了！！！太影响看文档了……![huajif07e7f9f783b2e6.jpeg](https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1618150299557-f6486158-ec14-4678-8b7c-aeec205e5053.jpeg#align=left&display=inline&height=90&margin=%5Bobject%20Object%5D&name=huajif07e7f9f783b2e6.jpeg&originHeight=90&originWidth=62&size=1957&status=done&style=none&width=62)趁着还没工作，要赶紧吧英语提高下</div><ul><li>最初导入赋值给一个变量，然后再生成一个 web 网站服务器， <code>const app = express();</code></li><li>set 方法：</li></ul><p><a href="https://expressjs.com/en/4x/api.html#app.set">https://expressjs.com/en/4x/api.html#app.set</a>：</p><ul><li>use 方法：</li></ul><p><a href="https://expressjs.com/en/4x/api.html#app.use">https://expressjs.com/en/4x/api.html#app.use</a><br><a href="https://www.jianshu.com/p/1d92463ebb69">https://www.jianshu.com/p/1d92463ebb69</a></p><p>简单而言就是，当路由规则为多个路径匹配规则时（Router 时）用 use，一个或者很少时，用 get 或者 post</p><ul><li>engine 方法</li><li>listen 方法：监听端口</li><li>static 方法：初始化静态资源文件夹，如果静态资源文件夹有多个，要写多个</li></ul><h3 id="关于-express-Router"><a href="#关于-express-Router" class="headerlink" title="关于 express.Router()"></a>关于 express.Router()</h3><p>就相当于两个系列路径下的路由操作，两个“类”对象<br>具体使用参考官网说明：<a href="https://expressjs.com/zh-cn/guide/routing.html#express-router">https://expressjs.com/zh-cn/guide/routing.html#express-router</a></p><h2 id="三方依赖-body-parser"><a href="#三方依赖-body-parser" class="headerlink" title="三方依赖 body-parser"></a>三方依赖 body-parser</h2><ul><li>参考：<a href="https://github.com/expressjs/body-parser">https://github.com/expressjs/body-parser</a></li></ul><p>作用就是将 post 请求过来的参数进行处理</p><ul><li>参考：<a href="https://segmentfault.com/a/1190000004407008">bodyParser 中间件的研究</a></li></ul><p><code>bodyParser.urlencoded</code>则是用来解析我们通常的 form 表单提交的数据，也就是请求头中包含这样的信息： <code>Content-Type: application/x-www-form-urlencoded</code>，具体还有好几种，github 里面详说了</p><p><code>app.use(bodyPaser.urlencoded(&#123;extended: false&#125;));</code>  意思就是当为 false 的时候使用 querystring 党委 true 的时候使用 qs</p><h2 id="三方依赖-express-session"><a href="#三方依赖-express-session" class="headerlink" title="三方依赖 express-session"></a>三方依赖 express-session</h2><p>设置 Cookie，<code>app.use(session(&#123;secret: &#39;secret key&#39;&#125;));</code><br>当参数为 secret 时候，通过设置的 secret 字符串，来计算 hash 值并放在 cookie 中，使产生的 signedCookie 防篡改</p><p>还有其他的参数：</p><ul><li>name: 设置 cookie 中，保存 session 的字段名称，默认为 connect.sid</li><li>store: session 的存储方式，默认为存放在内存中，我们可以自定义 redis 等</li><li>genid: 生成一个新的 session_id 时，默认为使用 uid2 这个 npm 包</li><li>rolling: 每个请求都重新设置一个 cookie，默认为 false</li><li>resave: 即使 session 没有被修改，也保存 session 值，默认为 true</li><li>saveUninitialized：强制未初始化的 session 保存到数据库</li><li>secret: 通过设置的 secret 字符串，来计算 hash 值并放在 cookie 中，使产生的 signedCookie 防篡改</li><li>cookie : 设置存放 sessionid 的 cookie 的相关选项</li></ul>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
          <category> node </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>应用层下的域名系统DNS</title>
      <link href="blog/lz0ywx/"/>
      <url>blog/lz0ywx/</url>
      
        <content type="html"><![CDATA[<p>域名系统 DNS 的作用就是域名解析为 IP 地址，因为在网络中传输的是字节，从之前学过的报文结构就可以得知，但是为何不直接在报文中直接传输域名呢？因为 IP 地址长度是固定的 32 位（如果是 IPV6 就是固定的 128 位），而域名长度不是固定长度的，及其处理比较困难。所以将域名解析成 IP 地址这个任务就交给了域名服务器了。</p><h2 id="理解什么是域名服务器？"><a href="#理解什么是域名服务器？" class="headerlink" title="理解什么是域名服务器？"></a>理解什么是域名服务器？</h2><p>域名服务器构成了 DNS 中的分布式网络系统，其功能主要是为内外主机提供域名与 IP 地址的互相解析映射服务。域名服务器分布在互联网的各子网中，每个域名服务器负责管理连接到本子网的所有主机，并为其提供服务。</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1618645215420-4ee27962-12d4-467b-81e6-f932e4c82a2a.png#align=left&display=inline&height=226&margin=%5Bobject%20Object%5D&name=image.png&originHeight=452&originWidth=1090&size=77271&status=done&style=stroke&width=545" alt="image.png"><br>域名服务器分为上面所表示的根域名服务器、顶级域名服务器、权限域名服务器、还有本地域名服务器（在本地电脑里面）</p><h3 id="关于本地域名服务器"><a href="#关于本地域名服务器" class="headerlink" title="关于本地域名服务器"></a>关于本地域名服务器</h3><p>本地电脑就有<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1618647707183-7e8f7af0-a3ab-455b-b702-18f82644471b.png#align=left&display=inline&height=398&margin=%5Bobject%20Object%5D&name=image.png&originHeight=796&originWidth=662&size=58470&status=done&style=none&width=331" alt="image.png"></p><h3 id="关于根域名服务器"><a href="#关于根域名服务器" class="headerlink" title="关于根域名服务器"></a>关于根域名服务器</h3><blockquote><p>关于根域名服务器，这里面有个有趣的话题，参考这篇文章：<br><a href="https://segmentfault.com/a/1190000023696737">美国如果把根域名服务器封了，中国会从网络上消失？</a></p></blockquote><h2 id="理解什么是域名注册商？"><a href="#理解什么是域名注册商？" class="headerlink" title="理解什么是域名注册商？"></a>理解什么是域名注册商？</h2><blockquote><p>域名服务器之所以能知道域名与 IP 地址的映射信息，是因为我们在域名服务商那里提交了域名记录。购买了一个域名之后，我们需要在域名服务商那里设置域名解析的记录，域名服务商把这些记录推送到权威域名服务器，这样我们的域名才能正式生效。<br>常见的域名服务商有阿里云、腾讯云等等……</p></blockquote><h3 id="注册域名注册商"><a href="#注册域名注册商" class="headerlink" title="注册域名注册商"></a>注册域名注册商</h3><p>要成为域名注册商需要提权，具体参考：<a href="https://baike.baidu.com/item/%E5%9F%9F%E5%90%8D%E6%B3%A8%E5%86%8C%E5%95%86">https://baike.baidu.com/item/%E5%9F%9F%E5%90%8D%E6%B3%A8%E5%86%8C%E5%95%86</a><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1618646601711-fca612d8-b2cd-4c22-8417-5938c415c7ce.png#align=left&display=inline&height=85&margin=%5Bobject%20Object%5D&name=image.png&originHeight=169&originWidth=1064&size=19679&status=done&style=stroke&width=532" alt="image.png"></p><h3 id="ICANN"><a href="#ICANN" class="headerlink" title="ICANN"></a>ICANN</h3><p>『互联网名称与数字地址分配机构』<br>可以看看发展历程<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1618646847974-89e834aa-7e05-4788-aebb-ac3a084362e4.png#align=left&display=inline&height=382&margin=%5Bobject%20Object%5D&name=image.png&originHeight=763&originWidth=1107&size=424236&status=done&style=none&width=553.5" alt="image.png"><br>不仅如此，包含全球的域名相关信息的 ICANN 的数据库管控方式也是极为严格，<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1618646929122-b3d35ad5-9a28-4fd2-a56f-1b7164cd51ff.png#align=left&display=inline&height=242&margin=%5Bobject%20Object%5D&name=image.png&originHeight=485&originWidth=1111&size=135338&status=done&style=stroke&width=555.5" alt="image.png"><br>像极了电影里面的情节<img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1618646983840-652fc715-3b53-427d-9722-86890ccbe07a.jpeg#align=left&display=inline&height=59&margin=%5Bobject%20Object%5D&name=huaji1558a846ddf2e12b.jpeg&originHeight=59&originWidth=55&size=703&status=done&style=stroke&width=55" alt="huaji1558a846ddf2e12b.jpeg"><br>具体参考：<a href="https://baike.baidu.com/item/%E4%BA%92%E8%81%94%E7%BD%91%E5%90%8D%E7%A7%B0%E4%B8%8E%E6%95%B0%E5%AD%97%E5%9C%B0%E5%9D%80%E5%88%86%E9%85%8D%E6%9C%BA%E6%9E%84/2775450?fromtitle=ICANN&fromid=6807198">https://baike.baidu.com/item/%E4%BA%92%E8%81%94%E7%BD%91%E5%90%8D%E7%A7%B0%E4%B8%8E%E6%95%B0%E5%AD%97%E5%9C%B0%E5%9D%80%E5%88%86%E9%85%8D%E6%9C%BA%E6%9E%84/2775450?fromtitle=ICANN&amp;fromid=6807198</a></p><h2 id="域名解析过程"><a href="#域名解析过程" class="headerlink" title="域名解析过程"></a>域名解析过程</h2><div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">了解了上面一些DNS宏观的设计方式，再来到域名解析就比较好理解了，域名解析就是将域名解析为IP地址，它怎么解析呢？利用在域名服务器里面查找有没有相关的解析记录。</div><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1618647354829-7da7d070-ba2e-404d-937d-45dcfb2faf25.png#align=left&display=inline&height=329&margin=%5Bobject%20Object%5D&name=image.png&originHeight=657&originWidth=1293&size=150691&status=done&style=stroke&width=646.5" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1618647396384-6ec5030a-0fdf-46c5-9ebb-1d257d92f2c9.png#align=left&display=inline&height=333&margin=%5Bobject%20Object%5D&name=image.png&originHeight=665&originWidth=943&size=175373&status=done&style=stroke&width=471.5" alt="image.png"></p><h2 id="使用工具查看-DNS-查询过程"><a href="#使用工具查看-DNS-查询过程" class="headerlink" title="使用工具查看 DNS 查询过程"></a>使用工具查看 DNS 查询过程</h2><h3 id="Linux-下的-dig-命令"><a href="#Linux-下的-dig-命令" class="headerlink" title="Linux 下的 dig 命令"></a>Linux 下的 dig 命令</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1618649698238-46345e66-fccd-4ad5-b99c-76db7072c62f.png#align=left&display=inline&height=360&margin=%5Bobject%20Object%5D&name=image.png&originHeight=720&originWidth=1440&size=88912&status=done&style=none&width=720" alt="image.png"></p><h3 id="Windows-下的-trance-命令"><a href="#Windows-下的-trance-命令" class="headerlink" title="Windows 下的 trance 命令"></a>Windows 下的 trance 命令</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1618649719833-b58925d7-4a25-4bdc-897b-e7bb281efed5.png#align=left&display=inline&height=360&margin=%5Bobject%20Object%5D&name=image.png&originHeight=720&originWidth=1440&size=100070&status=done&style=none&width=720" alt="image.png"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://github.com/ruanyf/articles/blob/master/2016/2016-06-15-dns.md">DNS 原理入门 - 阮一峰的网络日志</a></li><li><a href="https://segmentfault.com/a/1190000023696737">https://segmentfault.com/a/1190000023696737</a></li><li><a href="https://baike.baidu.com/item/%E5%9F%9F%E5%90%8D%E6%B3%A8%E5%86%8C%E5%95%86">https://baike.baidu.com/item/%E5%9F%9F%E5%90%8D%E6%B3%A8%E5%86%8C%E5%95%86</a></li><li><a href="https://baike.baidu.com/item/%E4%BA%92%E8%81%94%E7%BD%91%E5%90%8D%E7%A7%B0%E4%B8%8E%E6%95%B0%E5%AD%97%E5%9C%B0%E5%9D%80%E5%88%86%E9%85%8D%E6%9C%BA%E6%9E%84/2775450?fromtitle=ICANN&fromid=6807198">https://baike.baidu.com/item/%E4%BA%92%E8%81%94%E7%BD%91%E5%90%8D%E7%A7%B0%E4%B8%8E%E6%95%B0%E5%AD%97%E5%9C%B0%E5%9D%80%E5%88%86%E9%85%8D%E6%9C%BA%E6%9E%84/2775450?fromtitle=ICANN&amp;fromid=6807198</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> ComputerNetwork </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>本地数据存储</title>
      <link href="blog/bzdwkx/"/>
      <url>blog/bzdwkx/</url>
      
        <content type="html"><![CDATA[<h3 id="本地存储特性"><a href="#本地存储特性" class="headerlink" title="本地存储特性"></a>本地存储特性</h3><ul><li>数据存储在用户浏览器中</li><li>设置、读取方便、甚至页面刷新不丢失数据</li><li>容量较大，sessionStorage 约 5M、localStorage 约 20M</li><li>只能存储字符串，可以将对象 JSON.stringify() 编码后存储</li></ul><h3 id="window-sessionStorage"><a href="#window-sessionStorage" class="headerlink" title="window.sessionStorage"></a>window.sessionStorage</h3><p>1、生命周期为关闭浏览器窗口<br>2、在同一个窗口(页面)下数据可以共享<br>3、以键值对的形式存储使用<br>存储数据：</p><pre><code class="javascript">sessionStorage.setItem(key, value);</code></pre><p>获取数据：</p><pre><code class="javascript">sessionStorage.getItem(key);</code></pre><p>删除数据：</p><pre><code class="javascript">sessionStorage.removeItem(key);</code></pre><p>清空数据：(所有都清除掉)</p><pre><code class="javascript">sessionStorage.clear();</code></pre><h3 id="window-localStorage"><a href="#window-localStorage" class="headerlink" title="window.localStorage"></a>window.localStorage</h3><p>1、声明周期永久生效，除非手动删除 否则关闭页面也会存在<br>2、可以多窗口（页面）共享（同一浏览器可以共享）<br>3.   以键值对的形式存储使用<br>存储数据：</p><pre><code class="javascript">localStorage.setItem(key, value);</code></pre><p>获取数据：</p><pre><code class="javascript">localStorage.getItem(key);</code></pre><p>删除数据：</p><pre><code class="javascript">localStorage.removeItem(key);</code></pre><p>清空数据：(所有都清除掉)</p><pre><code class="javascript">localStorage.clear();</code></pre>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
          <category> BOM </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>返回顶部</title>
      <link href="blog/hip69d/"/>
      <url>blog/hip69d/</url>
      
        <content type="html"><![CDATA[<ol><li>带有动画的返回顶部</li><li>此时可以继续使用我们封装的动画函数</li><li>只需要把所有的 left 相关的值改为 跟 页面垂直滚动距离相关就可以了</li><li>页面滚动了多少，可以通过 window.pageYOffset 得到</li><li>最后是页面滚动，使用 window.scroll(x,y)</li></ol><pre><code class="javascript">//1. 获取元素var sliderbar = document.querySelector(&quot;.slider-bar&quot;);var banner = document.querySelector(&quot;.banner&quot;);// banner.offestTop 就是被卷去头部的大小 一定要写到滚动的外面var bannerTop = banner.offsetTop;// 当我们侧边栏固定定位之后应该变化的数值var sliderbarTop = sliderbar.offsetTop - bannerTop;// 获取main 主体元素var main = document.querySelector(&quot;.main&quot;);var goBack = document.querySelector(&quot;.goBack&quot;);var mainTop = main.offsetTop;// 2. 页面滚动事件 scrolldocument.addEventListener(&quot;scroll&quot;, function () &#123;  // console.log(11);  // window.pageYOffset 页面被卷去的头部  // console.log(window.pageYOffset);  // 3 .当我们页面被卷去的头部大于等于了 172 此时 侧边栏就要改为固定定位  if (window.pageYOffset &gt;= bannerTop) &#123;    sliderbar.style.position = &quot;fixed&quot;;    sliderbar.style.top = sliderbarTop + &quot;px&quot;;  &#125; else &#123;    sliderbar.style.position = &quot;absolute&quot;;    sliderbar.style.top = &quot;300px&quot;;  &#125;  // 4. 当我们页面滚动到main盒子，就显示 goback模块  if (window.pageYOffset &gt;= mainTop) &#123;    goBack.style.display = &quot;block&quot;;  &#125; else &#123;    goBack.style.display = &quot;none&quot;;  &#125;&#125;);// 3. 当我们点击了返回顶部模块，就让窗口滚动的页面的最上方goBack.addEventListener(&quot;click&quot;, function () &#123;  // 里面的x和y 不跟单位的 直接写数字即可  // window.scroll(0, 0);  // 因为是窗口滚动 所以对象是window  animate(window, 0);&#125;);</code></pre>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
          <category> JavaScript特效 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>筋斗云</title>
      <link href="blog/rnbgda/"/>
      <url>blog/rnbgda/</url>
      
        <content type="html"><![CDATA[<ol><li>利用动画函数做动画效果</li><li>原先筋斗云的起始位置是 0</li><li>鼠标经过某个小 li，把当前小 li 的 offsetLeft 位置做为目标值即可</li><li>鼠标离开某个小 li，就把目标值设为 0</li><li>如果点击了某个小 li， 就把 li 当前的位置存储起来，做为筋斗云的起始位置</li></ol><pre><code class="javascript">window.addEventListener(&quot;load&quot;, function () &#123;  // 1. 获取元素  var cloud = document.querySelector(&quot;.cloud&quot;);  var c_nav = document.querySelector(&quot;.c-nav&quot;);  var lis = c_nav.querySelectorAll(&quot;li&quot;);  // 2. 给所有的小li绑定事件  // 这个current 做为筋斗云的起始位置  var current = 0;  for (var i = 0; i &lt; lis.length; i++) &#123;    // (1) 鼠标经过把当前小li 的位置做为目标值    lis[i].addEventListener(&quot;mouseenter&quot;, function () &#123;      animate(cloud, this.offsetLeft);    &#125;);    // (2) 鼠标离开就回到起始的位置    lis[i].addEventListener(&quot;mouseleave&quot;, function () &#123;      animate(cloud, current);    &#125;);    // (3) 当我们鼠标点击，就把当前位置做为目标值    lis[i].addEventListener(&quot;click&quot;, function () &#123;      current = this.offsetLeft;    &#125;);  &#125;&#125;);</code></pre>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
          <category> JavaScript特效 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>轮播图</title>
      <link href="blog/inhz2t/"/>
      <url>blog/inhz2t/</url>
      
        <content type="html"><![CDATA[<p>轮播图也称为焦点图，是网页中比较常见的网页特效。<br>功能需求： 1.鼠标经过轮播图模块，左右按钮显示，离开隐藏左右按钮。 2.点击右侧按钮一次，图片往左播放一张，以此类推，左侧按钮同理。 3.图片播放的同时，下面小圆圈模块跟随一起变化。 4.点击小圆圈，可以播放相应图片。 5.鼠标不经过轮播图，轮播图也会自动播放图片。 6.鼠标经过，轮播图模块， 自动播放停止。</p><pre><code class="javascript">window.addEventListener(&quot;load&quot;, function () &#123;  // 1. 获取元素  var arrow_l = document.querySelector(&quot;.arrow-l&quot;);  var arrow_r = document.querySelector(&quot;.arrow-r&quot;);  var focus = document.querySelector(&quot;.focus&quot;);  var focusWidth = focus.offsetWidth;  // 2. 鼠标经过focus 就显示隐藏左右按钮  focus.addEventListener(&quot;mouseenter&quot;, function () &#123;    arrow_l.style.display = &quot;block&quot;;    arrow_r.style.display = &quot;block&quot;;    clearInterval(timer);    timer = null; // 清除定时器变量  &#125;);  focus.addEventListener(&quot;mouseleave&quot;, function () &#123;    arrow_l.style.display = &quot;none&quot;;    arrow_r.style.display = &quot;none&quot;;    timer = setInterval(function () &#123;      //手动调用点击事件      arrow_r.click();    &#125;, 2000);  &#125;);  // 3. 动态生成小圆圈  有几张图片，我就生成几个小圆圈  var ul = focus.querySelector(&quot;ul&quot;);  var ol = focus.querySelector(&quot;.circle&quot;);  // console.log(ul.children.length);  for (var i = 0; i &lt; ul.children.length; i++) &#123;    // 创建一个小li    var li = document.createElement(&quot;li&quot;);    // 记录当前小圆圈的索引号 通过自定义属性来做    li.setAttribute(&quot;index&quot;, i);    // 把小li插入到ol 里面    ol.appendChild(li);    // 4. 小圆圈的排他思想 我们可以直接在生成小圆圈的同时直接绑定点击事件    li.addEventListener(&quot;click&quot;, function () &#123;      // 干掉所有人 把所有的小li 清除 current 类名      for (var i = 0; i &lt; ol.children.length; i++) &#123;        ol.children[i].className = &quot;&quot;;      &#125;      // 留下我自己  当前的小li 设置current 类名      this.className = &quot;current&quot;;      // 5. 点击小圆圈，移动图片 当然移动的是 ul      // ul 的移动距离 小圆圈的索引号 乘以 图片的宽度 注意是负值      // 当我们点击了某个小li 就拿到当前小li 的索引号      var index = this.getAttribute(&quot;index&quot;);      // 当我们点击了某个小li 就要把这个li 的索引号给 num      num = index;      // 当我们点击了某个小li 就要把这个li 的索引号给 circle      circle = index;      // num = circle = index;      console.log(focusWidth);      console.log(index);      animate(ul, -index * focusWidth);    &#125;);  &#125;  // 把ol里面的第一个小li设置类名为 current  ol.children[0].className = &quot;current&quot;;  // 6. 克隆第一张图片(li)放到ul 最后面  var first = ul.children[0].cloneNode(true);  ul.appendChild(first);  // 7. 点击右侧按钮， 图片滚动一张  var num = 0;  // circle 控制小圆圈的播放  var circle = 0;  // flag 节流阀  var flag = true;  arrow_r.addEventListener(&quot;click&quot;, function () &#123;    if (flag) &#123;      flag = false; // 关闭节流阀      // 如果走到了最后复制的一张图片，此时 我们的ul 要快速复原 left 改为 0      if (num == ul.children.length - 1) &#123;        ul.style.left = 0;        num = 0;      &#125;      num++;      animate(ul, -num * focusWidth, function () &#123;        flag = true; // 打开节流阀      &#125;);      // 8. 点击右侧按钮，小圆圈跟随一起变化 可以再声明一个变量控制小圆圈的播放      circle++;      // 如果circle == 4 说明走到最后我们克隆的这张图片了 我们就复原      if (circle == ol.children.length) &#123;        circle = 0;      &#125;      // 调用函数      circleChange();    &#125;  &#125;);  // 9. 左侧按钮做法  arrow_l.addEventListener(&quot;click&quot;, function () &#123;    if (flag) &#123;      flag = false;      if (num == 0) &#123;        num = ul.children.length - 1;        ul.style.left = -num * focusWidth + &quot;px&quot;;      &#125;      num--;      animate(ul, -num * focusWidth, function () &#123;        flag = true;      &#125;);      // 点击左侧按钮，小圆圈跟随一起变化 可以再声明一个变量控制小圆圈的播放      circle--;      // 如果circle &lt; 0  说明第一张图片，则小圆圈要改为第4个小圆圈（3）      // if (circle &lt; 0) &#123;      //     circle = ol.children.length - 1;      // &#125;      circle = circle &lt; 0 ? ol.children.length - 1 : circle;      // 调用函数      circleChange();    &#125;  &#125;);  function circleChange() &#123;    // 先清除其余小圆圈的current类名    for (var i = 0; i &lt; ol.children.length; i++) &#123;      ol.children[i].className = &quot;&quot;;    &#125;    // 留下当前的小圆圈的current类名    ol.children[circle].className = &quot;current&quot;;  &#125;  // 10. 自动播放轮播图  var timer = setInterval(function () &#123;    //手动调用点击事件    arrow_r.click();  &#125;, 2000);&#125;);</code></pre><h3 id="1-2-2-节流阀"><a href="#1-2-2-节流阀" class="headerlink" title="1.2.2. 节流阀"></a>1.2.2. 节流阀</h3><p>防止轮播图按钮连续点击造成播放过快。<br>节流阀目的：当上一个函数动画内容执行完毕，再去执行下一个函数动画，让事件无法连续触发。<br>核心实现思路：利用回调函数，添加一个变量来控制，锁住函数和解锁函数。<br>开始设置一个变量 var flag= true;<br>If(flag){flag = false; do something}       关闭水龙头<br>利用回调函数动画执行完毕， flag = true     打开水龙头</p>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
          <category> JavaScript特效 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript数组对象总结</title>
      <link href="blog/bui5kv/"/>
      <url>blog/bui5kv/</url>
      
        <content type="html"><![CDATA[<div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">用的实在太多，记录一下<ul><li><a href="https://www.w3school.com.cn/js/js_arrays.asp">https://www.w3school.com.cn/js/js_arrays.asp</a></div></li></ul><h2 id="关于-JavaScript-数组"><a href="#关于-JavaScript-数组" class="headerlink" title="关于 JavaScript 数组"></a>关于 JavaScript 数组</h2><ul><li>在数组中可以<strong>存放任意类型的元素</strong>（Java 和 C++就不行）</li></ul><h2 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h2><h3 id="new-创建"><a href="#new-创建" class="headerlink" title="new 创建"></a>new 创建</h3><pre><code class="javascript">// 创建一个新的空数组var arr = new Array();</code></pre><h3 id="数组字面量创建"><a href="#数组字面量创建" class="headerlink" title="数组字面量创建"></a>数组字面量创建</h3><pre><code class="javascript">//创建空的数组var  数组名 = []；// 创建并初始化var arr = [&quot;什么&quot;, 12, 12.3, true];</code></pre><ul><li>数组中可以存放任意类型的数据（和之前学的面向对象语言就不一样）,并且这过程中，不会默认全部转为字符型的</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1617847324086-6b19cf64-7e76-47e7-a2a2-f8fdc70a7f13.png#align=left&display=inline&height=107&margin=%5Bobject%20Object%5D&name=image.png&originHeight=214&originWidth=519&size=16759&status=done&style=none&width=259.5" alt="image.png"></p><h2 id="获取数组中的元素"><a href="#获取数组中的元素" class="headerlink" title="获取数组中的元素"></a>获取数组中的元素</h2><blockquote><p>和 JAVA 一样</p></blockquote><ul><li>索引 (下标) ：用来访问数组元素的序号（数组下标从 0 开始）。</li><li>数组可以通过索引来访问、设置、修改对应的数组元素，可以通过“数组名[索引]”的形式来获取数组中的元素。</li><li>如果访问时数组没有和索引值对应的元素，则得到的值是 undefined</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1617846647997-6c89b538-4c83-4d3f-aca9-0d6a9f84665a.png#align=left&display=inline&height=114&margin=%5Bobject%20Object%5D&name=image.png&originHeight=227&originWidth=412&size=10710&status=done&style=none&width=206" alt="image.png"></p><h2 id="常用操作及内置方法"><a href="#常用操作及内置方法" class="headerlink" title="常用操作及内置方法"></a>常用操作及内置方法</h2><h3 id="forEach-遍历方法（ES5）"><a href="#forEach-遍历方法（ES5）" class="headerlink" title="forEach 遍历方法（ES5）"></a>forEach 遍历方法（ES5）</h3><blockquote><p>之前的是利用 length 和 for 循环</p><ul><li>如果设置的 length 属性值大于数组的元素个数，则会在数组末尾出现空白元素；</li><li>如果设置的 length 属性值小于数组的元素个数，则会把超过该值的数组元素删除</li></ul></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1617847044831-7515a626-65a9-4ac1-a3e1-b82500f30b6a.png#align=left&display=inline&height=263&margin=%5Bobject%20Object%5D&name=image.png&originHeight=525&originWidth=629&size=38476&status=done&style=none&width=314.5" alt="image.png"></p><h3 id="filter-过滤数组元素方法（ES5）"><a href="#filter-过滤数组元素方法（ES5）" class="headerlink" title="filter 过滤数组元素方法（ES5）"></a>filter 过滤数组元素方法（ES5）</h3><blockquote><p>返回的是数组</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1617847804428-c83b113a-7c47-4d2e-8853-7d338c932c48.png#align=left&display=inline&height=134&margin=%5Bobject%20Object%5D&name=image.png&originHeight=268&originWidth=743&size=31543&status=done&style=none&width=371.5" alt="image.png"></p><h3 id="some-是否含有某元素方法（ES5）"><a href="#some-是否含有某元素方法（ES5）" class="headerlink" title="some 是否含有某元素方法（ES5）"></a>some 是否含有某元素方法（ES5）</h3><blockquote><p>找到满足条件的第一个元素就终止查找</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1617847942959-75bec661-25b0-4896-b8a7-3e7fce596504.png#align=left&display=inline&height=53&margin=%5Bobject%20Object%5D&name=image.png&originHeight=105&originWidth=680&size=9440&status=done&style=none&width=340" alt="image.png"></p><h3 id="数组中新增元素的几种方法"><a href="#数组中新增元素的几种方法" class="headerlink" title="数组中新增元素的几种方法"></a>数组中新增元素的几种方法</h3><ul><li>push 函数在末尾添加元素（可以一个可以多个），返回添加后的数组长度<ul><li>第一个参数必须</li></ul></li><li>unshift 函数相对 push 函数不同，是在前面<ul><li>第一个参数必须</li></ul></li><li>splice 既可以添加，也可以删除<ul><li>第一个参数必须，表示在第几个元素位置进行操作</li><li>第二个参数必须，决定了是添加还是删除，为 0 删除，为正整数 x 则表示删除 x 个</li><li>后面的参数表示要添加的元素</li></ul></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1617849001307-4a9cb62d-9f41-49ca-b1b7-0bd86958f21f.png#align=left&display=inline&height=239&margin=%5Bobject%20Object%5D&name=image.png&originHeight=477&originWidth=1041&size=53659&status=done&style=none&width=520.5" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1617849029408-6c31170f-eb49-47a8-ab54-baa47cb2c387.png#align=left&display=inline&height=225&margin=%5Bobject%20Object%5D&name=image.png&originHeight=450&originWidth=1121&size=62603&status=done&style=none&width=560.5" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> DataStructure </category>
          
          <category> 其他知识 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>综合实验2——约瑟夫环</title>
      <link href="blog/itu2g5/"/>
      <url>blog/itu2g5/</url>
      
        <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>设有 n 个人围坐在圆桌周围，现从某个位置 m(1≤m≤n)上的人开始报数，报数到 k 的人就站出来。下一个人，即原来的第 k+1 个位置上的人，又从 1 开始报数，再报数到 k 的人站出来。依次重复下去，直到全部的人都站出来为止。试设计一个程序求出这 n 个人的<strong>出列顺序</strong>。</p><h2 id="问题要求"><a href="#问题要求" class="headerlink" title="问题要求"></a>问题要求</h2><ol><li>构造一个具有 n 个结点的循环单链表，用于存储圆桌周围的人的编号，链表结点的 data 域存放桌子周围的人的编号。</li><li>为保持程序的通用性,问题中的 n、m、k 可由用户从键盘输入.</li><li>要求编写函数模拟约瑟夫问题的实现过程,并输出 n 个人的出列顺序。</li></ol><h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>这个问题和综合实验一的思路一样，都是利用循环单链表（所以理论上之前的狐狸逮兔子应该用顺序表，而我用了链表<img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1617761762269-2745323d-e497-4442-984b-fe31e817f25a.jpeg#align=left&display=inline&height=90&margin=%5Bobject%20Object%5D&name=huajif07e7f9f783b2e6.jpeg&originHeight=90&originWidth=62&size=1957&status=done&style=stroke&width=62" alt="huajif07e7f9f783b2e6.jpeg">）。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>写代码过程中，题目没看清楚，一开始以为是被选中的人还呆在环里面，就导致我的指针指了一下午的寂寞……<img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1617799608465-1b5ed521-81ea-4434-a2bb-3d104e6ea038.jpeg#align=left&display=inline&height=56&margin=%5Bobject%20Object%5D&name=huaji-336495ce81a39782.jpeg&originHeight=56&originWidth=52&size=3550&status=done&style=stroke&width=52" alt="huaji-336495ce81a39782.jpeg">，不说了，交实验报告去了……</p><pre><code class="cpp">#include&lt;bits/stdc++.h&gt;using namespace std;/** * 定义一个单链表 */typedef struct LNode &#123;    int data;    struct LNode *next;&#125;Lnode, *LinkList;/** * 初始化单链表 */void InitList(LinkList &amp;L) &#123;    L = new LNode;    L-&gt;next = NULL;    L-&gt;data = 1;&#125;/* 初始化循环链表的初始值 */void init_add(LinkList &amp;L, int n) &#123;    InitList(L);    LinkList p = L;    for (int i = 2; i &lt;= n;i++) &#123;        LinkList p_temp = new Lnode;        p_temp-&gt;data = i;        if (i == n) &#123;            p_temp-&gt;next = L;            p-&gt;next = p_temp;        &#125; else &#123;            p_temp-&gt;next = p-&gt;next;            p-&gt;next = p_temp;            p = p-&gt;next;        &#125;    &#125;&#125;void joseph_ring(LinkList &amp;L, int n, int m, int k) &#123;    init_add(L, n);    LinkList p = L;    for (int i = 0; i&lt; m; i++) &#123;        p = p-&gt;next;    &#125;    while(p-&gt;next != p) &#123;        for (int j = 1; j&lt; k; j++) &#123;            if (j == k-1) &#123;                cout&lt;&lt;p-&gt;next-&gt;data&lt;&lt;&quot;号出来&quot;&lt;&lt;&quot;\n&quot;;                p-&gt;next = p-&gt;next-&gt;next;                p = p-&gt;next;            &#125; else &#123;                p = p-&gt;next;            &#125;        &#125;    &#125;    cout&lt;&lt; p-&gt;data&lt;&lt;&quot;号出来&quot;&lt;&lt;&quot;\n&quot;;&#125;int main()&#123;    cout &lt;&lt; &quot;请依次输入人数n、报数位置m、报到指定值就站起来的k值&quot; &lt;&lt; &quot;\n&quot;;    int n, m, k;    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;    LinkList p;    joseph_ring(p, n, m, k);&#125;</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1618305848004-50b702f4-e85f-410e-8310-bbd0c16ecac2.png#align=left&display=inline&height=136&margin=%5Bobject%20Object%5D&name=image.png&originHeight=272&originWidth=933&size=35832&status=done&style=none&width=466.5" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> DataStructure </category>
          
          <category> Problems </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>综合实验1——狐狸逮兔子</title>
      <link href="blog/bexxoi/"/>
      <url>blog/bexxoi/</url>
      
        <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>围绕着山顶有 10 个圆形排列的洞,狐狸要吃兔子,兔子说:”可以,但必须找到我,我就藏于这 10 个洞中,你先到 1 号洞找,第二次隔 1 个洞(即 3 号洞)找,第二次隔 2 个洞(即 6 号洞)找,以后如此类推,次数不限.”但狐狸从早到晚进进出出了 1000 次,仍没有找到兔子.问:兔子究竟藏在那个洞里?</p><h2 id="问题要求"><a href="#问题要求" class="headerlink" title="问题要求"></a>问题要求</h2><ol><li>设计一种存储方式用于存储山洞,元素的下标表示山洞的编号,元素的值为 1 表示狐狸没有进过山洞,为 0 表示狐狸进过该山洞.</li><li>为保持程序的通用性,山洞的数目和狐狸进出山洞的次数不一定为题设的 10 和 1000,可由用户从键盘输入.</li><li>要求编写函数模拟狐狸逮兔子的过程,并输出兔子可能的藏身之处.</li></ol><p>注：实验报告中要求说明采用了什么存储结构。</p><h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>这实际上是一个反复查找线性表的过程.<br><del>定义一个顺序表,用具有 10 个元素的顺序表来表示这 10 个洞.每个元素表示围绕山顶的一个洞,下标为洞的编号.对所有洞设置初始标志为 1,然后通过 1000 次循环,对每次所进之洞修改标志为 0,最后输出标志为 1 的洞,即兔子藏身的洞</del>.<br>定义了一个单链表，将其转换为循环链表，利用循环链表来解决了这个问题。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="cpp">#include&lt;bits/stdc++.h&gt;using namespace std;typedef struct LNode &#123;    int data;    int flag;    struct LNode *next;&#125;Lnode, *LinkList;int main() &#123;    LinkList L;    L = new LNode;    L-&gt;data = 1;    L-&gt;flag = 1;    L-&gt;next = NULL;    for (int i = 1; i &lt; 10;i++) &#123;        LinkList p;        p = new LNode;        p-&gt;data = 11-i;        p-&gt;flag = 1;        p-&gt;next = L-&gt;next;        L-&gt;next = p;        if (i == 1)&#123;            p-&gt;next = L;        &#125;    &#125;    LinkList s;    s = new LNode;    s = L;    for (int i = 0; i &lt; 1000;i++) &#123;        s-&gt;flag = 0;        for (int j = 0; j &lt; i+2;j++) &#123;            s = s-&gt;next;        &#125;    &#125;    cout &lt;&lt; &quot;最终结果：&quot;&lt;&lt; &quot;\n&quot;;    for (int i = 0; i &lt; 10;i++)&#123;        cout &lt;&lt; L-&gt;data &lt;&lt;&quot;洞&quot;&lt;&lt; &quot; &quot; &lt;&lt; L-&gt;flag &lt;&lt; &quot;\n&quot;;        L = L-&gt;next;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> DataStructure </category>
          
          <category> Problems </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>写代码总结</title>
      <link href="blog/fit037/"/>
      <url>blog/fit037/</url>
      
        <content type="html"><![CDATA[<p>这是加密文章！</p>]]></content>
      
      
      <categories>
          
          <category> DataStructure </category>
          
          <category> 其他知识 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++串</title>
      <link href="blog/hcwio0/"/>
      <url>blog/hcwio0/</url>
      
        <content type="html"><![CDATA[<h2 id="课后一些问题"><a href="#课后一些问题" class="headerlink" title="课后一些问题"></a>课后一些问题</h2><p>（1）串是一种特殊的线性表，其特殊性体现在（  ）。<br> A．可以顺序存储             **  B．数据元素是一个字符   **   <br>C．可以链式存储               D．数据元素可以是多个字符若  <br>答案：B</p><p>（2）串下面关于串的的叙述中，（  ）是不正确的？  <br>A．串是字符的有限序列          <strong>B．空串是由空格构成的串</strong><br>C．模式匹配是串的一种重要运算  D．串既可以采用顺序存储，也可以采用链式存储<br>答案：B<br>解释：空格常常是串的字符集合中的一个元素，有一个或多个空格组成的串成为空格串，零个字符的串成为空串，其长度为零。</p><p>（5）串的长度是指（  ）。<br>A．串中所含不同字母的个数    **   B．串中所含字符的个数**<br>C．串中所含不同字符的个数       D．串中所含非空格字符的个数<br>答案：B<br>解释：串中字符的数目称为串的长度。</p>]]></content>
      
      
      <categories>
          
          <category> DataStructure </category>
          
          <category> 线结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>今年的清明有点不一样</title>
      <link href="essay/nyh946/"/>
      <url>essay/nyh946/</url>
      
        <content type="html"><![CDATA[<p>还是在昨天，济南这边下了一场不小的雨，图书馆外的风甚是喧嚣，今天却又是格外晴朗…</p><p>和三月份回学校那天一样，南昌下着大雨，在去昌北机场大巴的车上，鹏鹏打电话和我说华哥死了的时候，那会儿我是很突然的，还没反应过来，人就懵了…车窗外的雨下的愈来愈大</p><p>以前，亲戚长辈们总和我们后辈说，不要学华哥，说是没出息，那会我不懂，我不懂的是什么叫出息，更不懂人们眼中的出息叫什么，我只知道他是我哥，我很喜欢和他玩。</p><p>小时候某年过节那会，亲戚朋友们都聚在一起，大人们都在那谈论电动摩特车，我在一旁听着，想跃跃欲试，我和身旁的华哥说，借他车去路上试试，华哥二话不说把我带到路上把车子开动，我凭着刚才他们大人们的三言两句，三下五除二车子就被我骑的老远，然后手不由自主地加速，车子越来越快，那一瞬间我突然想起来我忘了问刹车在哪…那一瞬间我实实在在感受到了相对速度的感念，车子走了，我屁股着地了～事后华哥笑着和我爸妈说，没多大事…</p><p>这个世界上，我一直相信人不止一面，在人们面前展示的一面，或许是普通的一面，可能一个人的表面是不被人所喜爱的，有几分不羁放纵，也可以是洒脱，当然也有那种特别讨别人喜的那种性格，但我也说了，人是复杂的，有的人在别人看来很没出息，没有大作为，可是，人心很好，当亲朋好友有困难，他会第一时间帮忙，和长辈说话，他会很认真倾听…当人类文明被创建那会，就注定会有框架来定义某些事情的标准。</p><p>我一直对自己说，平生这辈不做一个庸俗之人，尽管身处这个文明有很多的框架…</p><p>已故之人，定当缅怀之，下飞机已经是傍晚六点那会，夕阳洒在那诺大的跑道上，那般场景太容易调动情感，</p><p>在飞机上的一个半小时，我应该是离华哥最近的吧…<br><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1617606456340-0908688d-ae97-4581-9cdd-53c767da919d.jpeg#height=472&id=RgO7L&margin=%5Bobject%20Object%5D&name=IMG_20210109_164434.jpg&originHeight=3648&originWidth=2736&originalType=binary&size=1434606&status=done&style=none&width=354" alt="IMG_20210109_164434.jpg"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1617606104878-d295f451-12db-4207-b53a-9bfa1b250017.jpeg#height=472&id=jTfMO&margin=%5Bobject%20Object%5D&name=IMG_20210109_180755.jpg&originHeight=3648&originWidth=2736&originalType=binary&size=1847977&status=done&style=none&width=354" alt="IMG_20210109_180755.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>轮子哥……</title>
      <link href="essay/las4ft/"/>
      <url>essay/las4ft/</url>
      
        <content type="html"><![CDATA[<p>一时造轮子一时爽，一直造轮子，一直爽……</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>jQuery使用笔记</title>
      <link href="blog/aa9fsh/"/>
      <url>blog/aa9fsh/</url>
      
        <content type="html"><![CDATA[<p><code>jQuery</code>只是对原生的<code>JavaScript</code>进行封装，说白了就是封装成伪数组，所以记住它的一些调用方法就可以了</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://jquery.cuishifeng.cn/">jQuery API 速查表 –作者：Shifone</a></li><li><a href="https://www.processon.com/view/link/5b7d6458e4b0534c9bb76ad9#map">jQuery 思维导图</a></li></ul><h2 id="一些特性"><a href="#一些特性" class="headerlink" title="一些特性"></a>一些特性</h2><ul><li><code>$</code>符号：jq 里面的顶级对象</li><li>入口函数：在 DOM 里面的 DOMContentLoaded，在$里面直接赋予入口函数即可</li><li>jq 对象和 DOM 对象：</li></ul><p>两者之间的函数调用不能互换（因为是被封装成了伪数组）<br>jq 转换为 DOM：加数组下标即可（因为是被封装成了伪数组，利用索引即可）<br>DOM 转换为 jq：使用$符号即可（括号不加引号），或者是 get(索引值)</p><h2 id="常用-API"><a href="#常用-API" class="headerlink" title="常用 API"></a>常用 API</h2><h3 id="选择器操作"><a href="#选择器操作" class="headerlink" title="选择器操作"></a>选择器操作</h3><ul><li>元素获取：之前的 CSS 选择器（基础选择器、复合选择器）怎么写，这里直接就放到$里面即可</li></ul><p>筛选选择器<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1617359781992-e02802ae-f357-4987-a8a0-46cc0c5be69a.png#height=165&id=yL3dG&margin=%5Bobject%20Object%5D&name=image.png&originHeight=249&originWidth=793&originalType=binary%E2%88%B6=1&size=49996&status=done&style=none&width=524" alt="image.png"></p><ul><li>隐式迭代：如果获取的元素是一个数组，那么对其赋予的新操作，会隐式遍历</li><li>元素属性操作：css(“属性”,”值”)函数</li><li>元素节点操作</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1617359820567-38b9fad2-deb7-429f-9d21-8f9676563426.png#height=262&id=G7Yck&margin=%5Bobject%20Object%5D&name=image.png&originHeight=344&originWidth=709&originalType=binary%E2%88%B6=1&size=63602&status=done&style=none&width=541" alt="image.png"></p><ul><li>事件：.mouseover()、.click()</li><li>.show()、.hide()：元素显示和隐藏</li><li>$(this)当前这个对象</li></ul><h3 id="样式操作"><a href="#样式操作" class="headerlink" title="样式操作"></a>样式操作</h3><p>样式的操作还是和之前的 DOM 一样，有两种，一种是逐个设置该元素的属性和值，另一种就是改变其类，jq 里面也是这个大题思路，不过有不同</p><ul><li>单一设置：.css()函数，一个参数的时候，返回该参数的值，两个参数的时候，即赋予该属性及值</li><li>clsss 设置</li></ul><p>.addClass(“类名”)：如果该元素没有该类，则加上<br>.removeClass()：移除指定类名<br>.toggle()：如果该元素有该类则删除，如果没有该类则加上</p><ul><li>class 设置和 DOM 里面 className 区别是前者不会删除原本的类，后者会</li></ul><h3 id="效果操作"><a href="#效果操作" class="headerlink" title="效果操作"></a>效果操作</h3><p>jq 封装了很多的效果，具体可以详查相关文档     <br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1617361907950-d1d89194-401d-46aa-9471-34139e3e00df.png#height=149&id=SD9oO&margin=%5Bobject%20Object%5D&name=image.png&originHeight=298&originWidth=703&originalType=binary%E2%88%B6=1&size=42060&status=done&style=stroke&width=351.5" alt="image.png"></p><h3 id="属性操作"><a href="#属性操作" class="headerlink" title="属性操作"></a>属性操作</h3><ul><li>prop()：得到/设置元素固有的属性及值</li><li>attr()：得到/设置元素自定义的属性及值</li><li>data()：数据缓存</li></ul><h3 id="内容文本值操作"><a href="#内容文本值操作" class="headerlink" title="内容文本值操作"></a>内容文本值操作</h3><ul><li>html()：相当于 innerHTML</li><li>text()：相当于 innerText</li><li>val()：操作表单的值（没有参数是获取值，有一个参数是设置）</li></ul><h3 id="元素操作"><a href="#元素操作" class="headerlink" title="元素操作"></a>元素操作</h3><div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">遍历</div><blockquote><p>第一种表达：</p></blockquote><ul><li><p>$(“div”).each(function(index,ele){XXXX})</p></li><li><p>其中 index 是索引号，ele 得到的是 DOM 对象</p><blockquote><p>第二种表达</p></blockquote></li><li><p>$.each(Object,function(index,ele){XXXXX})</p></li><li><p>主要用于数据处理</p></li></ul><div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">创建</div><p>直接在$里面双引号加上需要创建的标签</p><div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">添加</div><blockquote><p>第一种关系：添加生成父子关系</p></blockquote><ul><li><p>append(“”)</p></li><li><p>prepend(“”)</p><blockquote><p>第二种关系：添加生成兄弟关系</p></blockquote></li><li><p>after(“”)</p></li><li><p>before(“”)</p></li></ul><div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">删除</div><ul><li>remove()：移除选定节点</li><li>empty()：清空所选节点的左右子节点</li><li>html(“”)：将所选节点的 html 内容制空（相当于删除节点了）</li></ul><h3 id="尺寸、位置操作"><a href="#尺寸、位置操作" class="headerlink" title="尺寸、位置操作"></a>尺寸、位置操作</h3><div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">尺寸操作</div>![image.png](https://cdn.nlark.com/yuque/0/2021/png/1484158/1617364626783-b5a50ec5-eeb2-4447-bc15-c7c209ae1d08.png#height=152&id=AIKMv&margin=%5Bobject%20Object%5D&name=image.png&originHeight=303&originWidth=1166&originalType=binary∶=1&size=133998&status=done&style=none&width=583)参数为空：返回值参数为一个值：设置<div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">位置操作</div><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1617364679986-4ff0b4c0-8622-4111-9c4b-c6571bd278db.png#height=127&id=SdHbS&margin=%5Bobject%20Object%5D&name=image.png&originHeight=253&originWidth=1246&originalType=binary%E2%88%B6=1&size=75964&status=done&style=stroke&width=623" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1617364688980-2d85f32d-a51c-48ae-85a9-fc9f613536e5.png#height=144&id=AO6QL&margin=%5Bobject%20Object%5D&name=image.png&originHeight=288&originWidth=1179&originalType=binary%E2%88%B6=1&size=78029&status=done&style=stroke&width=589.5" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1617364699038-74aa84bc-20ec-4427-9485-311ebaf9d066.png#height=120&id=jllHI&margin=%5Bobject%20Object%5D&name=image.png&originHeight=240&originWidth=1047&originalType=binary%E2%88%B6=1&size=62052&status=done&style=stroke&width=523.5" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
          <category> jQuery </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Node.js学习笔记</title>
      <link href="blog/node_note/"/>
      <url>blog/node_note/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>Node.js</strong>就是模块化开发，有两方面组成：</p></blockquote><blockquote><ol><li>ECMAScript</li><li>Node 的模块 API</li></ol><p><strong>模块化开发</strong>有两种</p><ol><li>前端网页使用 JavaScript 外链，</li><li>使用 nodejs 加载模块化开发构建</li></ol></blockquote><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>在命令行加上 node 文件名即可运行该 js 文件了，根据实际开发，一般都下载第三方模块 nodemon，所以一般命令都改为 nodemon 开头</p><h3 id="模块之导出"><a href="#模块之导出" class="headerlink" title="模块之导出"></a>模块之导出</h3><div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">和es6的导入导出方式逻辑一样，知识形式不一样，导出有两种方式，第二种类似es6里面的“打包”导出</div><blockquote><p>【第一种方式】</p></blockquote><ul><li>就是在模块里面定义好变量/方法，然后利用 <code>exports.let_1= let_1;</code> <code>exports.fun_1 = fun_1;</code>这种形式，一个个导出</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1618149585979-d1ff5498-d0e1-46ce-b115-ceeadf7f0df9.png#height=150&id=AsGvL&margin=%5Bobject%20Object%5D&name=image.png&originHeight=300&originWidth=865&originalType=binary%E2%88%B6=1&size=23380&status=done&style=none&width=432.5" alt="image.png"></p><blockquote><p>【第二种方式】module.exports.version = version;</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1618149597438-9300a103-0fd7-42df-9307-06079ef423c0.png#height=98&id=UAHtB&margin=%5Bobject%20Object%5D&name=image.png&originHeight=196&originWidth=844&originalType=binary%E2%88%B6=1&size=15904&status=done&style=none&width=422" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1618149609536-ea32c674-9e2d-48fb-92bc-d2c7bf0d294c.png#height=220&id=bm9kI&margin=%5Bobject%20Object%5D&name=image.png&originHeight=440&originWidth=931&originalType=binary%E2%88%B6=1&size=27252&status=done&style=none&width=465.5" alt="image.png"></p><h3 id="模块之导入"><a href="#模块之导入" class="headerlink" title="模块之导入"></a>模块之导入</h3><p>const a = require(‘文件路径’);</p><h3 id="模块之查找规则"><a href="#模块之查找规则" class="headerlink" title="模块之查找规则"></a>模块之查找规则</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1618118075531-995293d3-ee92-4f22-a49c-cb5114639b20.png#height=204&id=IaKuE&margin=%5Bobject%20Object%5D&name=image.png&originHeight=408&originWidth=864&originalType=binary%E2%88%B6=1&size=43167&status=done&style=stroke&width=432" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1618118082503-8414faae-297b-4cd7-a304-c80f7a635a35.png#height=216&id=SJfTf&margin=%5Bobject%20Object%5D&name=image.png&originHeight=432&originWidth=769&originalType=binary%E2%88%B6=1&size=35142&status=done&style=stroke&width=384.5" alt="image.png"></p><h3 id="异步式-I-O"><a href="#异步式-I-O" class="headerlink" title="异步式 I/O"></a>异步式 I/O</h3><p>提高效率，防止阻塞这种情况</p><h3 id="事件式编程"><a href="#事件式编程" class="headerlink" title="事件式编程"></a>事件式编程</h3><p>注意事件循环机制</p><h2 id="系统模块"><a href="#系统模块" class="headerlink" title="系统模块"></a>系统模块</h2><h3 id="全局对象-global"><a href="#全局对象-global" class="headerlink" title="全局对象 global"></a>全局对象 global</h3><p>Node.js 和之前学过的浏览器对象区分之就是，浏览器中全局对象是 window，但是 Node.js 的全局对象是 global（也可以不写、省略）</p><hr><p>process 对象：<br>关于进程的一个对象，也是 global 的属性之一，是一个和操作系统的简单接口。重点了解 nextTick()函数，这个函数可以将事件循环设置一个任务，提高运行效率<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1622768098753-4f933f75-ea23-41d9-80d3-c8dd46f2e123.png#height=41&id=jU6pu&margin=%5Bobject%20Object%5D&name=image.png&originHeight=82&originWidth=914&originalType=binary%E2%88%B6=1&size=24551&status=done&style=none&width=457" alt="image.png"></p><hr><p>console 对象：<br>log 在控制台中输出；error 输出错误信息；trace 输出错误信息调用栈（就是错在什么地方）</p><hr><ul><li>setTimeout()     设置超时<strong>定时器</strong></li><li>clearTimeout()   清除超时时定时器</li><li>setInterval()       设置间歇<strong>定时器</strong></li><li>clearInterval()   清除间歇定时器</li></ul><h3 id="常用工具-util-chalk-美化"><a href="#常用工具-util-chalk-美化" class="headerlink" title="常用工具 util+chalk 美化"></a>常用工具 util+chalk 美化</h3><ul><li><input checked="" disabled="" type="checkbox"> util.inherits</li></ul><p>不过感觉这个已经没有多大必要了，这个是实现原型间继承的相关封装，但是现在 ES6 已经有了 class 的概念了（虽然底层还是之前那套），这个工具用的不多</p><hr><ul><li><input checked="" disabled="" type="checkbox"> util.inspect</li></ul><p>目的就是将对象转换为字符串，比如将错误信息更加美观的展示在控制台，就可以自定义，但是可以直接用 chalk 模块在实现这个美化控制台输出的工作。</p><pre><code class="javascript">&quot;use strict&quot;;const chalk = require(&quot;chalk&quot;);module.exports = &#123;  info(...args) &#123;    const prefix = chalk.green(&quot;[INFO]&quot;);    args.unshift(prefix);    console.log.apply(console, args);  &#125;,  warn(...args) &#123;    const prefix = chalk.yellow(&quot;[WARNING]&quot;);    args.unshift(prefix);    console.log.apply(console, args);  &#125;,  error(...args) &#123;    const prefix = chalk.red(&quot;[ERROR]&quot;);    args.unshift(prefix);    console.log.apply(console, args);  &#125;,&#125;;</code></pre><pre><code class="javascript">out.info(  `Current yuque-hexo-lyrics version is $&#123;chalk.yellow(    pkg.version  )&#125;, and the latest version is $&#123;chalk.green(update.latest)&#125;. Please update!`);out.info(  &quot;View more detail: https://github.com/wztlink1013/yuque-hexo-lyrics#changelog&quot;);</code></pre><hr><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1622768731741-7021257f-2878-4ab3-91e2-e8335b26e89a.png#height=66&id=i7Qyl&margin=%5Bobject%20Object%5D&name=image.png&originHeight=131&originWidth=1023&originalType=binary%E2%88%B6=1&size=44439&status=done&style=none&width=511.5" alt="image.png"></p><hr><ul><li><input disabled="" type="checkbox"> events 事件发射器</li></ul><h3 id="fs-文件操作"><a href="#fs-文件操作" class="headerlink" title="fs 文件操作"></a>fs 文件操作</h3><p>读取文件、写入文件、创建文件夹</p><h3 id="path-路径操作"><a href="#path-路径操作" class="headerlink" title="path 路径操作"></a>path 路径操作</h3><p>一般都是路径字符串拼接 join</p><p><code>__dirname</code>当前目录名</p><h3 id="http"><a href="#http" class="headerlink" title="http"></a>http</h3><p>可以创建 web 服务器，原生，框架 Express 的使用优于此</p><h3 id="url"><a href="#url" class="headerlink" title="url"></a>url</h3><h2 id="第三方模块"><a href="#第三方模块" class="headerlink" title="第三方模块"></a>第三方模块</h2><p>第三方模块的两种存在形式</p><ol><li>以 js 文件的形式存在，提供实现项目具体功能的 API 接口。===jQuery</li><li>以命令行工具形式存在，辅助项目开发===下面的</li></ol><div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">npm：第三方模块的管理工具===使用hexo过程中就是用的这个</div><h3 id="nodemon"><a href="#nodemon" class="headerlink" title="nodemon"></a>nodemon</h3><p>npm install nodemon –g<br>作用就是，开发过程中，修改了文件，控制台命令行就会根据文件的修改自动运行<br>使用方法：将运行命令中的 node 换成 nodemon</p><h3 id="nrm"><a href="#nrm" class="headerlink" title="nrm"></a>nrm</h3><p>npm 是国外的，有时候下载速度慢，可以使用国内的镜像源<br>npm install nrm –g</p><p>查询可用下载地址列表 nrm ls<br>切换 npm 下载地址 nrm use 下载地址名称<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1618114858407-e5ccfaf9-7265-4f9f-966d-a2a5b7644465.png#height=227&id=josRO&margin=%5Bobject%20Object%5D&name=image.png&originHeight=453&originWidth=1058&originalType=binary%E2%88%B6=1&size=71441&status=done&style=none&width=529" alt="image.png"><br>报错不能用了</p><h3 id="gulp"><a href="#gulp" class="headerlink" title="gulp"></a>gulp</h3><p>基于 node 平台开发的前端构建工具，将机械化操作编写成任务，想要执行机械化操作时执行一个命令行命令任务就能自动执行了，用机器代替手工，提高开发效率。</p><p>作用：</p><ul><li>项目上线，HTML、CSS、JS 文件压缩合并</li><li>语法转换（es6、less …）</li><li>公共文件抽离</li><li>修改文件浏览器自动刷新</li></ul><div style="background: #FFF3F3;padding:10px;border: 1px solid #DEB8BE;border-radius:5px;margin-bottom:5px;">使用，**由于之前的设置了node的系统环境变量**，所以现在不能下载到项目文件夹目录下了。全局安装gulp和glup的命令行工具glup-cli（下载不成功），和自己之前配置的环境出错了</div><p>glup 本身提供的 api 函数很少，官网到目前更新只有下面几个，具体使用方法，使用的时候去查</p><ul><li><a href="https://github.com/gulpjs/gulp">https://github.com/gulpjs/gulp</a></li><li><a href="https://gulpjs.com/docs/en/getting-started/quick-start">https://gulpjs.com/docs/en/getting-started/quick-start</a>（不用梯子）</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1618116553456-e1d3daca-1c2e-45b4-9f78-bd1b5cb8bce7.png#height=372&id=ue44L&margin=%5Bobject%20Object%5D&name=image.png&originHeight=743&originWidth=490&originalType=binary%E2%88%B6=1&size=44893&status=done&style=stroke&width=245" alt="image.png"></p><p>gulp 有很多插件，根据插件下载相应需要的功能插件</p><ul><li>gulp-htmlmin ：html 文件压缩</li><li>gulp-csso ：压缩 css</li><li>gulp-babel ：JavaScript 语法转化</li><li>gulp-less: less 语法转化</li><li>gulp-uglify ：压缩混淆 JavaScript</li><li>gulp-file-include 公共文件包含</li><li>browsersync 浏览器实时同步</li></ul><h3 id="Express"><a href="#Express" class="headerlink" title="Express"></a>Express</h3><p>Node.js 创建 web 服务器，一个创建 web 服务器的框架</p>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
          <category> node </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>预处理器stylus笔记</title>
      <link href="blog/zsiw5e/"/>
      <url>blog/zsiw5e/</url>
      
        <content type="html"><![CDATA[<p>CSS 预处理器优化 CSS 的开发</p><div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">CSS 的预处理器，给 CSS 添加了可编程的特性，也就是说，在 stylus 中可以使用变量、函数、判断、循环一系列 CSS 没有的东西来编写样式文件，这个文件可编译成 CSS 文件</div><h2 id="note"><a href="#note" class="headerlink" title="note"></a>note</h2><ul><li>“[]”：中括号内容，是定义属性的方式</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.zhangxinxu.com/jq/stylus/">stylus 中文版参考文档之综述——张鑫旭</a></li><li><a href="https://stylus.bootcss.com/">富于表现力、动态的、健壮的 CSS</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Language </category>
          
          <category> CSS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CSS的媒体查询</title>
      <link href="blog/mio9h2/"/>
      <url>blog/mio9h2/</url>
      
        <content type="html"><![CDATA[<h3 id="媒体查询（CSS3）"><a href="#媒体查询（CSS3）" class="headerlink" title="媒体查询（CSS3）"></a>媒体查询（CSS3）</h3><div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">@media：注意@符号</div><pre><code class="css">@media mediatype and|not|only (media feature) &#123;    CSS-Code;&#125;</code></pre><h3 id="mediatype-查询类型"><a href="#mediatype-查询类型" class="headerlink" title="mediatype 查询类型"></a>mediatype 查询类型</h3><div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">将不同的终端设备划分成不同的类型，称为媒体类型</div><p><img src="https://cdn.nlark.com/yuque/0/2021/jpg/1484158/1615360325196-c449a080-4612-4814-b5da-5a61b1da1c0b.jpg#align=left&display=inline&height=193&margin=%5Bobject%20Object%5D&originHeight=193&originWidth=915&status=done&style=stroke&width=915"></p><h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">关键字将媒体类型或多个媒体特性连接到一起做为媒体查询的条件。</div><ul><li>and：可以将多个媒体特性连接到一起，相当于“且”的意思。</li><li>not：排除某个媒体类型，相当于“非”的意思，可以省略。</li><li>only：指定某个特定的媒体类型，可以省略。</li></ul><h3 id="媒体特性"><a href="#媒体特性" class="headerlink" title="媒体特性"></a>媒体特性</h3><div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">每种媒体类型都具体各自不同的特性，根据不同媒体类型的媒体特性设置不同的展示风格。我们暂且了解三个。</div><p><img src="https://cdn.nlark.com/yuque/0/2021/jpg/1484158/1615360325364-d6cd0d1a-1ec7-4bd1-a67e-3fadde7c4381.jpg#align=left&display=inline&height=195&margin=%5Bobject%20Object%5D&originHeight=195&originWidth=918&status=done&style=stroke&width=918"></p><h3 id="媒体查询书写规则"><a href="#媒体查询书写规则" class="headerlink" title="媒体查询书写规则"></a>媒体查询书写规则</h3><div style="background: #FFF3F3;padding:10px;border: 1px solid #DEB8BE;border-radius:5px;margin-bottom:5px;">为了防止混乱，媒体查询我们要按照从小到大或者从大到小的顺序来写,但是我们最喜欢的还是从小到大来写，这样代码更简洁</div>]]></content>
      
      
      <categories>
          
          <category> Language </category>
          
          <category> CSS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>GitHub基于Issue的软件项目管理</title>
      <link href="blog/hgbehz/"/>
      <url>blog/hgbehz/</url>
      
        <content type="html"><![CDATA[<div style="background: #FFFBE6;padding:10px;border: 1px solid #C3C3C3;border-radius:5px;margin-bottom:5px;">在进行GitHub项目开发过程中，途中会有一些新想法，遇见的新bug等问题，提出的一些新灵感等等都可以利用GitHub每个项目自带的issues（议题）来进行管理、跟踪并且加以解决。传统的软件项目管理还有Milestones（里程碑）、Projects（画板）来一并进行项目的开发，GitHub在2020年还新增加了Discussion（讨论区）模块，进一步提高软件项目的管理工作。</div><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616655875686-d8387a58-3c42-4442-b6b5-1cd2b0c68a5f.png#height=129&id=vUGI2&margin=%5Bobject%20Object%5D&name=image.png&originHeight=258&originWidth=1893&originalType=binary%E2%88%B6=1&size=52796&status=done&style=stroke&width=946.5" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616656006240-dd9c58bd-6675-487e-aab0-58878e9fcb29.png#height=128&id=PmAcn&margin=%5Bobject%20Object%5D&name=image.png&originHeight=255&originWidth=1895&originalType=binary%E2%88%B6=1&size=48535&status=done&style=stroke&width=947.5" alt="image.png"></p><h2 id="Issue-标签类型总结"><a href="#Issue-标签类型总结" class="headerlink" title="Issue 标签类型总结"></a>Issue 标签类型总结</h2><h3 id="GitHub-默认标签"><a href="#GitHub-默认标签" class="headerlink" title="GitHub 默认标签"></a>GitHub 默认标签</h3><table><thead><tr><th>bug</th><th>提出一个 bug</th><th>颜色默认</th></tr></thead><tbody><tr><td>documentation</td><td>详查文档</td><td>颜色默认</td></tr><tr><td>duplicate</td><td>这是个重复的问题</td><td>颜色默认</td></tr><tr><td>enhancement</td><td>增强和改进</td><td>颜色默认</td></tr><tr><td>good first issue</td><td>好的想法/灵感</td><td>颜色默认</td></tr><tr><td>help wanted</td><td>使用过程中不明白的地方</td><td>颜色默认</td></tr><tr><td>invalid</td><td>该问题看起来没有意义</td><td>颜色默认</td></tr><tr><td>question</td><td>请提供进一步资料</td><td>颜色默认</td></tr><tr><td>wontfix</td><td>项目设计初衷如此</td><td>颜色默认</td></tr></tbody></table><h3 id="自需添加"><a href="#自需添加" class="headerlink" title="自需添加"></a>自需添加</h3><table><thead><tr><th>debugging</th><th>正在调试</th></tr></thead><tbody><tr><td>fixed</td><td>已被修复</td></tr></tbody></table><blockquote><p>持续更新……</p></blockquote><h2 id="Discussion-的新革新"><a href="#Discussion-的新革新" class="headerlink" title="Discussion 的新革新"></a>Discussion 的新革新</h2><p>传统的流程是提出 issues 之后，根据不同的 issue 来跟进画板（Project）的内容。</p><p>上面的做法其实有一个思维上的 bug，一些灵感之类的不好放上去，使用 Discussion 之后，可以在 Discussion 里面放上想法、灵感等，实际开发从这里面的一个的一个具体的评论转换到实际的 issue 里面</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="http://www.ruanyifeng.com/blog/2017/08/issue.html">http://www.ruanyifeng.com/blog/2017/08/issue.html</a></li><li><a href="https://github.com/volantis-x/hexo-theme-volantis/">https://github.com/volantis-x/hexo-theme-volantis/</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> VersionControlSystem </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Git push出(10054)/(port 443：time out)错</title>
      <link href="blog/tttk33/"/>
      <url>blog/tttk33/</url>
      
        <content type="html"><![CDATA[<h2 id="报错信息"><a href="#报错信息" class="headerlink" title="报错信息"></a>报错信息</h2><div style="background: #FFF3F3;padding:10px;border: 1px solid #DEB8BE;border-radius:5px;margin-bottom:5px;">Git push出(10054)/(port 443：time out)错</div><div style="background: #FFF3F3;padding:10px;border: 1px solid #DEB8BE;border-radius:5px;margin-bottom:5px;">git push error: RPC failed; curl 56 OpenSSL SSL_read: SSL_ERROR_SYSCALL, errno 10054</div><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1615710474939-e30bb4c2-806b-4db3-a467-09ca14264ebd.png#height=330&id=eU1ev&margin=%5Bobject%20Object%5D&name=image.png&originHeight=659&originWidth=1172&originalType=binary&size=785473&status=done&style=none&width=586" alt="image.png"></p><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>由于 Http 协议错误，当 pull 或者 clone 的时候，或者是 github 某个 CDN 被伟大的墙屏蔽所致。</p><h2 id="解决办法-1"><a href="#解决办法-1" class="headerlink" title="解决办法 1"></a>解决办法 1</h2><pre><code class="bash">//10054复制下面的git config http.postBuffer 524288000//443复制下面的git config --global --unset http.proxygit config --global --unset https.proxy</code></pre><h2 id="解决办法-2"><a href="#解决办法-2" class="headerlink" title="解决办法 2"></a>解决办法 2</h2><p>在<a href="https://www.ipaddress.com/">https://www.ipaddress.com/</a>里面查找下面三个域名的 ip 地址</p><ul><li>github.com</li><li>github.global.ssl.fastly.net</li><li>codeload.github.com</li></ul><p>将其添加到本电脑 hosts 文件当中<br><code>C:\Windows\System32\drivers\etc\hosts</code> <br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1615339105733-afb66a55-d96e-4dba-9650-a9d3cb8324fa.png#height=56&id=EhSLV&margin=%5Bobject%20Object%5D&name=image.png&originHeight=112&originWidth=490&originalType=binary&size=10992&status=done&style=none&width=245" alt="image.png"><br>CMD 窗口刷新 DNS 缓存<br><code>ipconfig /flushdns</code></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.cnblogs.com/mmzs/p/12039888.html">https://www.cnblogs.com/mmzs/p/12039888.html</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Bug </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++链表(单、循环、双向)设计及操作</title>
      <link href="blog/gu92gu/"/>
      <url>blog/gu92gu/</url>
      
        <content type="html"><![CDATA[<div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">这篇文章，打算详细记录下链表的相关知识，毕竟是基础中的基础。首先是先记录下在一开始学习过程中的些许疑惑/C的遗忘，然后记录各种代码（实验报告代码，单链表各种操作代码总结，循环链表代码，双向链表代码）</div><h2 id="实验要求"><a href="#实验要求" class="headerlink" title="实验要求"></a>实验要求</h2><blockquote><p>1、创建一个带头结点的单链表（头指针为 head），且遍历此链表（输出链表中各结点的值）；<br>2、查找单链表中的第 i 个结点，并输出结点元素的值；</p></blockquote><blockquote><p>3、在单链表中的第 i 个结点前插入一个结点值为 e 的正整数(从外部输入);</p></blockquote><blockquote><p>4、删除单链表中的第 j 个结点；</p></blockquote><blockquote><p>*5、将单链表中的各结点就地逆序（不允许另建一个链表）；</p></blockquote><h2 id="概念理解"><a href="#概念理解" class="headerlink" title="概念理解"></a>概念理解</h2><h3 id="链表数据结构"><a href="#链表数据结构" class="headerlink" title="链表数据结构"></a>链表数据结构</h3><p>链表是一种数据结构，和<strong>数组同级</strong>。之前 JAVA 里面的 ArrayList 数据结构，其实现原理是数组，而 JAVA 的 LinkedList 的实现原理就是链表了。链表在进行循环遍历时效率不高，但是插入和删除时优势明显，其实 C/C++抑或是 JAVA 这些数据结构都一样——地址……引用……</p><p>单向链表是一种线性表，实际上是由<strong>节点（Node）</strong>组成的，一个链表拥有不定数量的节点。其数据在<strong>内存中存储是不连续的</strong>，它存储的数据分散在内存中，每个结点只能也只有它能知道下一个结点的存储位置。由 N 各节点（Node）组成单向链表，每一个 Node 记录本 Node 的数据及下一个 Node。向外暴露的只有一个头节点（Head），<strong>我们对链表的所有操作，都是直接或者间接地通过其头节点来进行的。</strong><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1603194076184-195f3044-1083-4244-9eeb-d86c96a37e6f.png#align=left&display=inline&height=98&margin=%5Bobject%20Object%5D&originHeight=98&originWidth=491&size=0&status=done&style=shadow&width=491"><br>上图中最左边的节点即为头结点（Head），但是添加节点的顺序是从右向左的，添加的新节点会被作为新节点。最先添加的节点对下一节点的引用可以为空。引用是引用下一个节点而非下一个节点的对象。因为有着不断的引用，所以<strong>头节点就可以操作所有节点</strong>了。</p><p>下图描述了单向链表存储情况。存储是分散的，每一个节点只要记录下一节点，就把所有数据串了起来，形成了一个单向链表。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1603194105521-d31f8e78-7f2a-4c60-8838-57e15707e27b.png#align=left&display=inline&height=219&margin=%5Bobject%20Object%5D&originHeight=219&originWidth=195&size=0&status=done&style=stroke&width=195"><br>节点（Node）是由一个需要储存的对象及对下一个节点的引用组成的。也就是说，节点拥有两个成员：储存的对象、对下一个节点的引用。下面图是具体的说明：<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1603194124335-fc6fc00c-35fb-44e1-a01c-de4b8b5531af.png#align=left&display=inline&height=207&margin=%5Bobject%20Object%5D&originHeight=207&originWidth=370&size=0&status=done&style=stroke&width=370"></p><h3 id="关于链表的指向"><a href="#关于链表的指向" class="headerlink" title="关于链表的指向"></a>关于链表的指向</h3><blockquote><p>【1】何为指向？</p></blockquote><p>个人觉得链表的相关问题及操作就是理解链表的<strong>“指向”</strong>这么个概念，先明确以下几点</p><ul><li>每个节点的<strong>next</strong>用来存放<strong>下一个节点的“地址”</strong></li><li><strong>每个节点的自身就是地址</strong>，相当于 C 语言中数组的数组名就是本数组的地址</li></ul><blockquote><p>【2】谁指向谁？</p></blockquote><p><strong>总结：做题用下面总结的方法，绝对好使</strong><br><strong><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1616501415627-ee5d1008-a07d-4acb-821b-e227b5cb7ad8.jpeg#align=left&display=inline&height=59&margin=%5Bobject%20Object%5D&name=huaji1558a846ddf2e12b.jpeg&originHeight=59&originWidth=55&size=703&status=done&style=stroke&width=55" alt="huaji1558a846ddf2e12b.jpeg"></strong></p><ul><li><strong>读的时候：从左往右读，一般左边是某某的 next 域，右边是具体的结点</strong></li><li><strong>画的时候：在图中表示为等号左边指向等号右边</strong></li></ul><p>**<br>例子：<br>① <code>node.next = prev.next;</code><br>② <code>prev.next = node</code><br>读法：<br>①“node 的 next 指向 prev 的下一个结点”<br>（用指针的概念通俗地说，其实就是 prev 的下一个结点的地址由 prev 的指针域里面赋值给了 node 的 next 指针域里面）<br>②“prev 的 next 指向 node 这个结点”<br>（还可以这么说：将 node 赋值给 prev 的 next，也就是说 prev 的下一个结点是 node）<br>**</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1599309003706-ad779a14-1678-4d0c-86f2-b147752bd252.png#align=left&display=inline&height=204&margin=%5Bobject%20Object%5D&originHeight=594&originWidth=955&size=0&status=done&style=stroke&width=328"><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1599309003751-ffeee4d8-9662-416e-8f46-5cf5edf03114.png#align=left&display=inline&height=250&margin=%5Bobject%20Object%5D&originHeight=725&originWidth=938&size=0&status=done&style=stroke&width=324"><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1599309003658-46b3e7db-e6dc-4d13-baea-e7e44075e8bc.png#align=left&display=inline&height=221&margin=%5Bobject%20Object%5D&originHeight=626&originWidth=975&size=0&status=done&style=stroke&width=344"></p><blockquote><p>【3】指向错位？</p></blockquote><p><strong>关注第一个元素节点是不是 head，因为有的链表不声明头节点（head），直接就是第一个结点就是元素结点</strong></p><h3 id="关于-p-L-的理解"><a href="#关于-p-L-的理解" class="headerlink" title="关于 p=L 的理解"></a>关于 p=L 的理解</h3><p>写代码的时候，还经常遇到下面的情况<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616501697301-b63e6312-d8f9-4130-8d25-2d3becd75038.png#align=left&display=inline&height=53&margin=%5Bobject%20Object%5D&name=image.png&originHeight=106&originWidth=466&size=9439&status=done&style=none&width=233" alt="image.png"><br>p、L 就是指向结点的指针类型，将 L 的值赋给 p，也就是 p、L 指向同一个结点。具体理解可以用下面一个例子来说明：<br>下面图片这个函数就是在一个单链表中，功能就是指定 i 位置插入 e 值。下图箭头处如果 TraverseList 返回的是 p 那么得出的链表结果就是从插入的那个元素往后这样一个部分链表，返回的是 L 就是想要的结果，p 的功能有点类似在 L 的中间做了手脚……<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616501856348-955542eb-258d-473f-b003-c53881275937.png#align=left&display=inline&height=331&margin=%5Bobject%20Object%5D&name=image.png&originHeight=662&originWidth=740&size=62693&status=done&style=none&width=370" alt="image.png"></p><h2 id="各种代码"><a href="#各种代码" class="headerlink" title="各种代码"></a>各种代码</h2><h3 id="实验报告代码"><a href="#实验报告代码" class="headerlink" title="实验报告代码"></a>实验报告代码</h3><pre><code class="cpp">#include&lt;bits/stdc++.h&gt;using namespace std;typedef struct LNode &#123;    int data;    struct LNode *next;&#125;Lnode, *LinkList;LinkList L;void InitList(LinkList &amp;L) &#123;    L = new LNode;    L-&gt;next = NULL;&#125;void CreateList_H(LinkList &amp;L) &#123;    InitList(L);    int n;    cout &lt;&lt; &quot;请输入要使用前插法插入的元素个数：&quot;;    cin &gt;&gt; n;    for (int i = 0; i &lt; n; i++)&#123;        LNode *p = new LNode;        cin &gt;&gt; p-&gt;data;        p-&gt;next = L-&gt;next;        L-&gt;next = p;    &#125;&#125;void TraverseList(LinkList &amp;L)&#123;    LNode *p = new LNode;    p = L-&gt;next;    cout &lt;&lt; &quot;此链表打印的结果为：&quot;&lt;&lt;&quot;\n&quot;;    while (p != NULL)&#123;        cout &lt;&lt; p-&gt;data &lt;&lt; &quot; &quot;;        p = p-&gt;next;    &#125;    cout &lt;&lt; &quot;\n&quot;;&#125;void GetElem(LinkList &amp;L) &#123;    int n;    cout &lt;&lt; &quot;请输入要查询的链表中第i个数：&quot;;    cin &gt;&gt; n;    LNode *p = new LNode;    p = L;    for (int i = 0; i &lt; n;i++)&#123;        p = p-&gt;next;    &#125;    cout &lt;&lt; &quot;查询的结果为：&quot; &lt;&lt; p-&gt;data&lt;&lt;&quot;\n&quot;;&#125;void ListInsert(LinkList &amp;L)&#123;    LNode *p = new LNode;    p = L;    int n;    int e;    cout &lt;&lt; &quot;请分别输入要在第n个位置插入的e值：&quot;;    cin &gt;&gt; n&gt;&gt; e ;    for (int i = 0; i &lt; n;i++) &#123;        if (n == i+1)&#123;            LNode *temp = new LNode;            temp-&gt;data = e;            temp-&gt;next = p-&gt;next;            p-&gt;next = temp;            break;        &#125;        p = p-&gt;next;    &#125;    TraverseList(L); // 直接返回L就可以了，之前返回p是不可以的！！！唉，大意了~&#125;void ListDelete(LinkList &amp;L)&#123;    cout &lt;&lt; &quot;请输入要删除的第j个位置的j值：&quot;;    LNode *p = new LNode;    p = L;    int j;    cin &gt;&gt; j;    for (int i = 0; i &lt; j;i++) &#123;        if (j == i+1) &#123;            p-&gt;next = p-&gt;next-&gt;next;            break;        &#125;        p = p-&gt;next;    &#125;    TraverseList(L);&#125;void ReverseList(LinkList &amp;L) &#123;    LNode *p = L-&gt;next;    L-&gt;next = NULL;    while(p)    &#123;        LNode *q = p-&gt;next;        p-&gt;next = L-&gt;next;        L-&gt;next = p;        p = q;    &#125;    cout &lt;&lt; &quot;通过逆置之后……&quot;;    TraverseList(L);&#125;int main() &#123;    LNode *test = new LNode;    CreateList_H(test);//1    TraverseList(test);//1    GetElem(test);//2    ListInsert(test);//3    ListDelete(test);//4    ReverseList(test);//5&#125;</code></pre><h3 id="单链表各种操作代码总结"><a href="#单链表各种操作代码总结" class="headerlink" title="单链表各种操作代码总结"></a>单链表各种操作代码总结</h3><ul><li><input checked="" disabled="" type="checkbox"> 单链表存储形式</li></ul><pre><code class="cpp">typedef struct LNode &#123;    int data; //数据域    struct LNode *next; //指针域&#125;Lnode, *LinkList; //LinkList为指向结构体LNode的指针类型</code></pre><ul><li><input checked="" disabled="" type="checkbox"> 初始化</li><li><input checked="" disabled="" type="checkbox"> 创建：前插法</li><li><input checked="" disabled="" type="checkbox"> 创建：后插法</li><li><input checked="" disabled="" type="checkbox"> 取值</li><li><input checked="" disabled="" type="checkbox"> 插值</li><li><input checked="" disabled="" type="checkbox"> 删除</li><li><input checked="" disabled="" type="checkbox"> 打印</li><li><input checked="" disabled="" type="checkbox"> <strong>逆置</strong></li></ul><p>逆置多用前插的思想</p><pre><code class="cpp">void ReverseList(LinkList &amp;L) &#123;    LNode *p = L-&gt;next;    L-&gt;next = NULL;    while(p) &#123;        LinkList q = p-&gt;next;        p-&gt;next = L-&gt;next;        L-&gt;next = p;        p = q;    &#125;&#125;</code></pre><p>所有操作如下</p><pre><code class="cpp">#include&lt;bits/stdc++.h&gt;using namespace std;/** * 单链表 * * 链表的基本操作：初始化、创建（前插、后插）、取值、查找、插值、删除、打印、逆置 *//* 单链表的存储结构 */typedef struct LNode &#123;    int data; //数据域    struct LNode *next; //指针域&#125;Lnode, *LinkList; //LinkList为指向结构体LNode的指针类型/* 初始化链表 */void InitList(LinkList &amp;L) &#123;    L = new LNode;    L-&gt;next = NULL;&#125;/* 创建：前插 */void CreateList_H(LinkList &amp;L, int n) &#123;    InitList(L);    for (int i = 0; i &lt; n; i++)&#123;        LNode *p = new LNode;        cin &gt;&gt; p-&gt;data;        p-&gt;next = L-&gt;next;        L-&gt;next = p;    &#125;&#125;/* 创建：后插 */void CreateList_R(LinkList &amp;L, int n) &#123;    cout &lt;&lt; &quot;请输入&quot; &lt;&lt; n &lt;&lt; &quot;个数字&quot;&lt;&lt; &quot;\n&quot;;    InitList(L);    // 定义一个在下面循环用来一直操作所加元素的结点p来指向头结点L    LinkList p = L;    for (int i = 0; i &lt; n;i++) &#123;        LinkList q = new Lnode;        q-&gt;next = NULL;        cin &gt;&gt; q-&gt;data;        p-&gt;next = q;        p = q; //为了下一次    &#125;&#125;/* 取值 */void GetElem(LinkList &amp;L, int n) &#123;    LinkList p = L;    for (int i = 0; i &lt; n;i++)&#123;        p = p-&gt;next;    &#125;    cout &lt;&lt;n&lt;&lt;&quot;的值为：&quot; &lt;&lt; p-&gt;data&lt;&lt;&quot;\n&quot;&lt;&lt;&quot;\n&quot;;&#125;/* 查找 */void SearchElem(LinkList &amp;L, int ele) &#123;    LinkList p = L;    int count = 0;    while (p-&gt;data != ele) &#123;        p = p-&gt;next;        count++;    &#125;    cout &lt;&lt;ele&lt;&lt;&quot;这个值的索引位置是：&quot;&lt;&lt; count&lt;&lt;&quot;\n&quot;;&#125;/* 插值：在第n个位置插入ele值*/void ListInsert(LinkList &amp;L, int n, int ele)&#123;    LinkList p = L;    for (int i = 0; i &lt; n;i++) &#123;        if (n == i+1)&#123;            LinkList temp = new LNode;            temp-&gt;data = ele;            temp-&gt;next = p-&gt;next;            p-&gt;next = temp;            break;        &#125;        p = p-&gt;next;    &#125;    TraverseList(L);&#125;/* 删除：删除第j个位置的值 */void ListDelete(LinkList &amp;L, int j)&#123;    LinkList p = L;    for (int i = 0; i &lt; j;i++) &#123;        if (j == i+1) &#123;            p-&gt;next = p-&gt;next-&gt;next;            break;        &#125;        p = p-&gt;next;    &#125;    TraverseList(L);&#125;/* 打印 */void TraverseList(LinkList &amp; L)&#123;        LNode *p = new LNode;        p = L-&gt;next;        cout &lt;&lt; &quot;此链表打印的结果为：&quot;             &lt;&lt; &quot;\n&quot;;        while (p != NULL)        &#123;            cout &lt;&lt; p-&gt;data &lt;&lt; &quot; &quot;;            p = p-&gt;next;        &#125;        cout &lt;&lt; &quot;\n&quot;;&#125;/* 逆置 */void ReverseList(LinkList &amp;L) &#123;    LNode *p = L-&gt;next;    L-&gt;next = NULL;    while(p)    &#123;        LNode *q = p-&gt;next;        p-&gt;next = L-&gt;next;        L-&gt;next = p;        p = q;    &#125;    cout &lt;&lt; &quot;通过逆置之后……&quot;;    TraverseList(L);&#125;int main() &#123;    // LNode *test = new LNode;    LinkList test;    // struct LNode *test;    CreateList_R(test,4);    SearchElem(test, 3);    // cout &lt;&lt; GetEle(test, 2);    // TraverseList(test);    // GetElem(test,2);    // ListInsert(test);    // ListDelete(test);    // ReverseList(test);&#125;</code></pre><h3 id="循环链表代码"><a href="#循环链表代码" class="headerlink" title="循环链表代码"></a>循环链表代码</h3><p>* 循环链表其实只需要注意最后一个结点所指向的下一个结点为头结点 L 就好了</p><ul><li>还要注意头结点存不存元素</li><li>还有判断的时候条件不是单链表那样判断是否为空了，而是是否为头结点的值了</li></ul><pre><code class="cpp">#include&lt;bits/stdc++.h&gt;using namespace std;/** * 循环链表 * * 循环链表其实只需要注意最后一个结点所指向的下一个结点为头结点L就好了 * 还要注意头结点存不存元素 * 还有判断的时候条件不是单链表那样判断是否为空了，而是是否为头结点的值了 *//* 定义一个单链表 */typedef struct LNode &#123;    int data;    struct LNode *next;&#125;Lnode, *LinkList;/** * 初始化单链表 */void InitList(LinkList &amp;L) &#123;    L = new LNode;    L-&gt;next = NULL;&#125;/** * 初始化单链表并将其变成循环链表 */void CircleList(LinkList &amp;L, int n) &#123;    InitList(L);    // 初始化第一个结点的值    L-&gt;data = 1;    LinkList p = L;    for (int i = 2; i &lt;= n; i++) &#123;        LinkList temp = new Lnode;        temp-&gt;data = i;        if (i == n) &#123;            temp-&gt;next = L;            p-&gt;next = temp;            break;        &#125;        temp-&gt;next = NULL;        p-&gt;next = temp;        p = p-&gt;next;    &#125;&#125;/** * 打印输出用来测试是否为循环链表 */void PrintList(LinkList &amp;L, int n) &#123;    LinkList p = L;    for (int i = 0; i &lt; n;i++) &#123;        cout &lt;&lt; p-&gt;data &lt;&lt; &quot; &quot;;        p = p-&gt;next;    &#125;&#125;int main() &#123;    LinkList test;    CircleList(test,5);    PrintList(test, 12);&#125;</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1618307254729-8f60bc5d-be41-47fe-a2ad-466715cc740e.png#align=left&display=inline&height=45&margin=%5Bobject%20Object%5D&name=image.png&originHeight=90&originWidth=596&size=22406&status=done&style=none&width=298" alt="image.png"></p><h3 id="双向链表代码"><a href="#双向链表代码" class="headerlink" title="双向链表代码"></a>双向链表代码</h3><ul><li>双向链表从某种意义上来说，更加简单了，因为可操作的“指向更多了”，但正因为这样，所以每次指向操作之后，检查一下有没有“落单的指向”</li><li>删除某个结点的时候，一定要记得删除哪个结点，就操作哪个结点</li></ul><pre><code class="cpp">#include&lt;bits/stdc++.h&gt;using namespace std;/** * 双向链表 *//* 双向链表的存储结构 */typedef struct DuLNode &#123;    int data;    struct DuLNode *prior;    struct DuLNode *next;&#125;DuLnode, *DuLinkList;/* 双向链表的初始化 */void InitDuLinkList(DuLinkList &amp;L) &#123;    L = new DuLNode;    L-&gt;prior = NULL;    L-&gt;next = NULL;&#125;int main() &#123;    DuLinkList L;    InitDuLinkList(L);    // 初始化初始节点值为100    L-&gt;data = 100;    // 在L结点前面插值50    DuLinkList L_prior;    L_prior-&gt;data = 50;    L_prior-&gt;next = L;    L-&gt;prior = NULL;    L-&gt;prior = L_prior;    // 在L结点后面插值150    DuLinkList L_next;    L_next-&gt;data = 150;    L_next-&gt;prior = L;    L_next-&gt;next = NULL;    L-&gt;next = L_next;    cout &lt;&lt; L_prior-&gt;data &lt;&lt; &quot; &quot; &lt;&lt; L_prior-&gt;next-&gt;data &lt;&lt; &quot; &quot; &lt;&lt; L_prior-&gt;next-&gt;next-&gt;data&lt;&lt;&quot;\n&quot;;    // 在50和100之间插值75（只操作L结点）    DuLinkList L_prior_L;    L_prior_L-&gt;data = 75;    L_prior_L-&gt;prior = L-&gt;prior;    L-&gt;prior-&gt;next = L_prior_L;    L_prior_L-&gt;next = L;    L-&gt;prior = L_prior_L;    cout &lt;&lt; L-&gt;prior-&gt;prior-&gt;data &lt;&lt; &quot; &quot; &lt;&lt; L-&gt;prior-&gt;data &lt;&lt; &quot; &quot; &lt;&lt; L-&gt;data &lt;&lt;&quot; &quot;&lt;&lt; L-&gt;next-&gt;data&lt;&lt;&quot;\n&quot;;    // 删除75这个值的结点(记住一点，删除哪个结点就操作哪个结点)    L_prior_L-&gt;next-&gt;prior = L_prior_L-&gt;prior;    L_prior_L-&gt;prior-&gt;next = L_prior_L-&gt;next;    cout &lt;&lt; L-&gt;prior-&gt;data &lt;&lt; &quot; &quot; &lt;&lt; L-&gt;data &lt;&lt; &quot; &quot; &lt;&lt; L-&gt;next-&gt;data &lt;&lt; &quot;\n&quot;;&#125;</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1618309282126-1ad3d5c4-1d3e-425f-b474-27f33261ead6.png#align=left&display=inline&height=92&margin=%5Bobject%20Object%5D&name=image.png&originHeight=183&originWidth=526&size=39489&status=done&style=none&width=263" alt="image.png"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="http://shangdixinxi.com/detail-1507915.html">链表 p-&gt;next=q-&gt;next,q-&gt;next=p,q=p;的一些解释</a></li><li><a href="https://blog.csdn.net/weixin_44135282/article/details/90348885">p-&gt;next=q 与 q=p-&gt;next 区分</a></li><li><a href="https://www.jianshu.com/p/73d56c3d228c">数据结构：链表</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> DataStructure </category>
          
          <category> 线结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数据结构综述+复习</title>
      <link href="blog/kcce4yhndt7f/"/>
      <url>blog/kcce4yhndt7f/</url>
      
        <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1620296634645-5f5db231-d7ce-41c7-b68f-01d430ebdcf4.png#height=305&id=L4k06&margin=%5Bobject%20Object%5D&name=image.png&originHeight=609&originWidth=1116&originalType=binary%E2%88%B6=1&size=61263&status=done&style=stroke&width=558" alt="image.png"></p><h2 id="线结构"><a href="#线结构" class="headerlink" title="线结构"></a>线结构</h2><ul><li><p>顺序表、单链表（单链表最为基础，最为重要）</p></li><li><p>栈和队列</p><blockquote><p>操作受限的链表</p></blockquote></li><li><p>串</p><blockquote><p>内容受限的线性表</p></blockquote></li><li><p>数组</p><blockquote><p>多维数组求地址</p></blockquote></li><li><p>广义表</p><blockquote><p>概念，和首位</p></blockquote></li></ul><h2 id="树结构"><a href="#树结构" class="headerlink" title="树结构"></a>树结构</h2><ul><li>二叉树的五条性质烂熟于胸，性质 3 的证明</li><li>遍历二叉树：前序、中序、后序</li><li>线索二叉树</li><li>树都可以转换为二叉树：左儿子右兄弟法</li><li>森林转换为二叉树：森林中的所有树变成二叉树，然后将其各个根节点变成左右兄弟类型</li><li>哈夫曼树，哈夫曼编码：外排序用到</li></ul><h2 id="图结构"><a href="#图结构" class="headerlink" title="图结构"></a>图结构</h2><ul><li><p>邻接矩阵、邻接表（有向图、无向图）、逆邻接表</p><blockquote><p>十字链表、邻接多重链表（不要求）</p></blockquote></li><li><p>图的遍历：BFS（主要）、DFS（主要）、层次遍历（一层一层遍历）</p></li><li><p>连通性问题：最小生成树，为了解决 n 个顶点连接起来（工程应用）</p><ul><li>Prim 算法（稠密图用）</li><li>Kruskal 算法（稀疏图用）</li></ul></li><li><p>最短路径问题</p><ul><li>算法 1：一点到其他个各点：Dijaskal 算法</li><li>算法 2：每一对顶点之间：Floyd 算法</li></ul></li><li><p>关键路径问题</p><ul><li>AOV 网：拓扑排序</li><li>AOE 网：关键路径（工程问题）</li></ul></li></ul><p>​</p><div style="background: #FFF3F3;padding:10px;border: 1px solid #DEB8BE;border-radius:5px;margin-bottom:5px;">下面的查找和排序放到算法分类里面总结了</div>​<h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><ul><li>静态查找<ul><li>顺序</li><li>折半</li><li>分块</li></ul></li><li>动态查找<ul><li>二叉排序树：构造</li><li>AVL（平衡二叉排序树）</li></ul></li><li>B-树<ul><li>B+树，一个结点放多关键字</li></ul></li><li>哈希（Hash）表及其查找：解决冲突的办法</li></ul><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><ul><li>插入排序<ul><li><strong>直接</strong></li><li>折半</li><li>希尔</li></ul></li><li>快速排序<ul><li><strong>冒泡（交换排序）</strong></li><li>快速排序</li></ul></li><li>选择排序<ul><li><strong>简单选择排序</strong></li><li>树形排序</li><li>堆排序</li></ul></li><li>归并（K 路）（用到外部排序里面多，复杂度高）</li><li>基数排序（筒）</li></ul>]]></content>
      
      
      <categories>
          
          <category> DataStructure </category>
          
          <category> 其他知识 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>es函数</title>
      <link href="blog/egols2d1kxs2/"/>
      <url>blog/egols2d1kxs2/</url>
      
        <content type="html"><![CDATA[<div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">基本上和之前学过的语言一样，return语句、continue语句、break语句、函数的传参用法基本都一样，记录一下js的特征用法：</div><h2 id="函数定义使用"><a href="#函数定义使用" class="headerlink" title="函数定义使用"></a>函数定义使用</h2><p>不像之前的 C++、JAVA 那样需要一个返回值来声明，JavaScript 里面直接一个关键字就搞定了，如果里面有 return 就返回 return 的值，没有则返回 undefined。下面记录一下 js 里面的三种函数声明方式和不同情况下的使用场景。</p><h3 id="function-关键字"><a href="#function-关键字" class="headerlink" title="function 关键字"></a>function 关键字</h3><blockquote><p>自定义函数方式(命名函数)利用函数关键字 function 自定义函数方式</p></blockquote><pre><code class="javascript">// 声明定义方式function fn() &#123;...&#125;// 调用fn();</code></pre><ul><li>调用函数的代码既可以放到声明函数的前面，也可以放在声明函数的后面</li></ul><h3 id="匿名函数表达式"><a href="#匿名函数表达式" class="headerlink" title="匿名函数表达式"></a>匿名函数表达式</h3><div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">:::> 函数表达式方式(匿名函数）> 【C++11里面也有匿名函数的用法，基本上就是**匿名函数表达式**】<pre><code class="javascript">// 这是函数表达式写法，匿名函数后面跟分号结束var fn = function()&#123;...&#125;；// 调用的方式，函数调用必须写到函数体下面fn();</code></pre><ul><li>这个 fn 里面存储的是一个函数</li><li>函数表达式方式原理跟声明变量方式是一致的</li><li>函数调用的代码必须写到函数体后面</li></ul><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><ul><li>所有函数都是 Function 的对象，函数也是对象</li></ul><pre><code class="javascript">var f = new Function(&#39;a&#39;, &#39;b&#39;, &#39;console.log(a + b)&#39;);f(1, 2);var fn = new Function(&#39;参数1&#39;,&#39;参数2&#39;..., &#39;函数体&#39;)</code></pre><hr><h3 id="立即调用函数"><a href="#立即调用函数" class="headerlink" title="立即调用函数"></a>立即调用函数</h3><p>两种表达方式</p><ul><li>(function(){})()</li><li>(function(){}())</li></ul><p>与立即执行函数相关的知识还有在函数前面加上一些符号（！、<del>、+……）会对函数的返回值进行相应的操作，其中加上</del>的意思是对返回值进行按位取反的操作，具体参考下面的参考资料<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1617956106484-c021320c-100a-49b5-a668-99928bf3a720.png#align=left&display=inline&height=273&id=ll11Y&margin=%5Bobject%20Object%5D&name=image.png&originHeight=709&originWidth=1230&size=75306&status=done&style=none&width=472.98846435546875" alt="image.png"><br>参考：<a href="https://blog.csdn.net/hot_cool/article/details/77567166">https://blog.csdn.net/hot_cool/article/details/77567166</a></p><h2 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h2><h3 id="arguments"><a href="#arguments" class="headerlink" title="arguments"></a>arguments</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1617851666624-a963acb7-8a97-43bc-9998-35738a1a1a7f.png#align=left&display=inline&height=306&id=OVrKI&margin=%5Bobject%20Object%5D&name=image.png&originHeight=612&originWidth=935&size=236202&status=done&style=stroke&width=467.5" alt="image.png"><br>当不确定有多少个参数传递的时候，可以用 arguments 来获取。JavaScript 中，arguments 实际上它是当前函数的一个内置对象。所有函数都内置了一个 arguments 对象，arguments 对象中存储了传递的所有实参。arguments 展示形式是一个伪数组，因此可以进行遍历。伪数组具有以下特点：</p><ul><li>具有 length 属性</li><li>按索引方式储存数据</li><li>不具有数组的 push , pop 等方法<br>注意：在函数内部使用该对象，用此对象获取函数调用时传的实参。</li></ul><h3 id="箭头函数（ES6）里面的不同"><a href="#箭头函数（ES6）里面的不同" class="headerlink" title="箭头函数（ES6）里面的不同"></a>箭头函数（ES6）里面的不同</h3><p>es6 的箭头函数用起来很方便，但是一个不方便的就是在这里面 arguments 不能用了<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1617852137156-ea361bcf-a64d-40e7-9ad4-de9ad5a2789d.png#align=left&display=inline&height=151&id=FOFeI&margin=%5Bobject%20Object%5D&name=image.png&originHeight=301&originWidth=928&size=43847&status=done&style=none&width=464" alt="image.png"><br>如果非要用的化，将这个箭头函数放在一个普通函数里面，让箭头函数接受这个普通函数的参数<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1617852218090-65cab2f5-0088-41e5-95fa-0845a253fcbd.png#align=left&display=inline&height=102&id=kFJpX&margin=%5Bobject%20Object%5D&name=image.png&originHeight=203&originWidth=754&size=27598&status=done&style=stroke&width=377" alt="image.png"></p><h3 id="关于值传递"><a href="#关于值传递" class="headerlink" title="关于值传递"></a>关于值传递</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1617852230127-5b2394d1-82c0-48a4-8bbb-385f5d27760b.png#align=left&display=inline&height=54&id=Iq2ke&margin=%5Bobject%20Object%5D&name=image.png&originHeight=108&originWidth=813&size=28188&status=done&style=stroke&width=406.5" alt="image.png"></p><h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><h3 id="几个常用-this-指向"><a href="#几个常用-this-指向" class="headerlink" title="几个常用 this 指向"></a>几个常用 this 指向</h3><ul><li>全局作用域或者普通函数中 this 指向全局对象 window（定时器里面的 this 指向 window）</li><li>方法调用中谁调用 this 指向谁</li><li>构造函数中 this 指向构造函数的实例</li></ul><pre><code class="js">&lt;button&gt;点击&lt;/button&gt;    &lt;script&gt;        // this 指向问题 一般情况下this的最终指向的是那个调用它的对象        // 1. 全局作用域或者普通函数中this指向全局对象window（ 注意定时器里面的this指向window）        console.log(this);        function fn() &#123;            console.log(this);        &#125;        window.fn();        window.setTimeout(function() &#123;            console.log(this);        &#125;, 1000);        // 2. 方法调用中谁调用this指向谁        var o = &#123;            sayHi: function() &#123;                console.log(this); // this指向的是 o 这个对象            &#125;        &#125;        o.sayHi();        var btn = document.querySelector(&#39;button&#39;);        btn.addEventListener(&#39;click&#39;, function() &#123;                console.log(this); // 事件处理函数中的this指向的是btn这个按钮对象            &#125;)        // 3. 构造函数中this指向构造函数的实例        function Fun() &#123;            console.log(this); // this 指向的是fun 实例对象        &#125;        var fun = new Fun();    &lt;/script&gt;</code></pre><h3 id="函数内部的-this-指向"><a href="#函数内部的-this-指向" class="headerlink" title="函数内部的 this 指向"></a>函数内部的 this 指向</h3><p>这些 this 的指向，是当我们调用函数的时候确定的。调用方式的不同决定了 this 的指向不同<br>一般指向我们的调用者.</p><h3 id="改变函数内部-this-指向"><a href="#改变函数内部-this-指向" class="headerlink" title="改变函数内部 this 指向"></a>改变函数内部 this 指向</h3><div style="background: #FFFBE6;padding:10px;border: 1px solid #C3C3C3;border-radius:5px;margin-bottom:5px;">call方法</div>call()方法调用一个对象。简单理解为调用函数的方式，但是它可以改变函数的 this 指向应用场景:  经常做继承.```jsvar o = {    name: 'andy'} function fn(a, b) {      console.log(this);      console.log(a+b)};fn(1,2)// 此时的this指向的是window 运行结果为3fn.call(o,1,2)//此时的this指向的是对象o,参数使用逗号隔开,运行结果为3```<div style="background: #FFFBE6;padding:10px;border: 1px solid #C3C3C3;border-radius:5px;margin-bottom:5px;">apply方法</div>apply() 方法调用一个函数。简单理解为调用函数的方式，但是它可以改变函数的 this 指向。应用场景:  经常跟数组有关系```jsvar o = {    name: 'andy'} function fn(a, b) {      console.log(this);      console.log(a+b)};fn()// 此时的this指向的是window 运行结果为3fn.apply(o,[1,2])//此时的this指向的是对象o,参数使用数组传递 运行结果为3```<div style="background: #FFFBE6;padding:10px;border: 1px solid #C3C3C3;border-radius:5px;margin-bottom:5px;">bind方法</div>bind() 方法不会调用函数,但是能改变函数内部this 指向,返回的是原函数改变this之后产生的新函数如果只是想改变 this 指向，并且不想调用这个函数的时候，可以使用bind应用场景:不调用函数,但是还想改变this指向```jsvar o = { name: 'andy' };function fn(a, b) {    console.log(this);    console.log(a + b);};var f = fn.bind(o, 1, 2); //此处的f是bind返回的新函数f();//调用新函数  this指向的是对象o 参数使用逗号隔开```<div style="background: #FFFBE6;padding:10px;border: 1px solid #C3C3C3;border-radius:5px;margin-bottom:5px;">call、apply、bind三者的异同</div><ul><li>共同点 : 都可以改变 this 指向</li><li>不同点:<ul><li>call 和 apply 会调用函数, 并且改变函数内部 this 指向.</li><li>call 和 apply 传递的参数不一样,call 传递参数使用逗号隔开,apply 使用数组传递</li><li>bind 不会调用函数, 可以改变函数内部 this 指向.</li></ul></li><li>应用场景<ol><li> call 经常做继承.</li><li> apply 经常跟数组有关系. 比如借助于数学对象实现数组最大值最小值</li><li> bind 不调用函数,但是还想改变 this 指向. 比如改变定时器内部的 this 指向.</li></ol></li></ul><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>闭包（closure）指有权访问另一个函数作用域中变量的函数。简单理解就是 ，一个作用域可以访问另外一个函数内部的局部变量。</p><h3 id="闭包的作用"><a href="#闭包的作用" class="headerlink" title="闭包的作用"></a>闭包的作用</h3><p>作用：延伸变量的作用范围。</p><pre><code class="javascript">function fn() &#123;  var num = 10;  function fun() &#123;    console.log(num);  &#125;  return fun;&#125;var f = fn();f();</code></pre><h3 id="闭包的案例"><a href="#闭包的案例" class="headerlink" title="闭包的案例"></a>闭包的案例</h3><ol><li>利用闭包的方式得到当前 li 的索引号</li></ol><pre><code class="js">for (var i = 0; i &lt; lis.length; i++) &#123;  // 利用for循环创建了4个立即执行函数  // 立即执行函数也成为小闭包因为立即执行函数里面的任何一个函数都可以使用它的i这变量  (function (i) &#123;    lis[i].onclick = function () &#123;      console.log(i);    &#125;;  &#125;)(i);&#125;</code></pre><ol start="2"><li>闭包应用-3 秒钟之后,打印所有 li 元素的内容</li></ol><pre><code class="js">for (var i = 0; i &lt; lis.length; i++) &#123;  (function (i) &#123;    setTimeout(function () &#123;      console.log(lis[i].innerHTML);    &#125;, 3000);  &#125;)(i);&#125;</code></pre><ol start="3"><li>闭包应用-计算打车价格</li></ol><pre><code class="js">/*需求分析打车起步价13(3公里内),  之后每多一公里增加 5块钱.  用户输入公里数就可以计算打车价格如果有拥堵情况,总价格多收取10块钱拥堵费*/var car = (function () &#123;  var start = 13; // 起步价  局部变量  var total = 0; // 总价  局部变量  return &#123;    // 正常的总价    price: function (n) &#123;      if (n &lt;= 3) &#123;        total = start;      &#125; else &#123;        total = start + (n - 3) * 5;      &#125;      return total;    &#125;,    // 拥堵之后的费用    yd: function (flag) &#123;      return flag ? total + 10 : total;    &#125;,  &#125;;&#125;)();console.log(car.price(5)); // 23console.log(car.yd(true)); // 33</code></pre><pre><code class="js">var name = &quot;The Window&quot;;   var object = &#123;     name: &quot;My Object&quot;,     getNameFunc: function() &#123;     return function() &#123;     return this.name;     &#125;;   &#125; &#125;;console.log(object.getNameFunc()())-----------------------------------------------------------------------------------var name = &quot;The Window&quot;;　　  var object = &#123;　　　　    name: &quot;My Object&quot;,    getNameFunc: function() &#123;    var that = this;    return function() &#123;    return that.name;    &#125;;  &#125;&#125;;console.log(object.getNameFunc()())</code></pre><h2 id="简单-复杂数据类型传参"><a href="#简单-复杂数据类型传参" class="headerlink" title="简单/复杂数据类型传参"></a>简单/复杂数据类型传参</h2><pre><code>**简单类型**（**基本数据类型**、**值类型**）：在存储时变量中存储的是值本身，包括string ，number，boolean，undefined，null**复杂数据类型（引用类型）**：在存储时变量中存储的仅仅是地址（引用），通过 new 关键字创建的对象（系统对象、自定义对象），如 Object、Array、Date等；</code></pre><h3 id="堆栈存储区别"><a href="#堆栈存储区别" class="headerlink" title="堆栈存储区别"></a>堆栈存储区别</h3><p>堆栈空间分配区别：<br>1、栈（操作系统）：由操作系统自动分配释放存放函数的参数值、局部变量的值等。其操作方式类似于数据结构中的栈；<br>简单数据类型存放到栈里面<br>2、堆（操作系统）：存储复杂类型(对象)，一般由程序员分配释放，若程序员不释放，由垃圾回收机制回收。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611885075555-12234777-10f8-4df1-8a9f-e61078298520.png#align=left&display=inline&height=138&margin=%5Bobject%20Object%5D&name=image.png&originHeight=275&originWidth=476&size=16662&status=done&style=none&width=238" alt="image.png"><br>简单数据类型的存储方式：值类型变量的数据直接存放在变量（栈空间）中<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611885085102-7ebb3c36-ffc2-4a5b-af50-c8e377f92cef.png#align=left&display=inline&height=121&margin=%5Bobject%20Object%5D&name=image.png&originHeight=241&originWidth=789&size=33962&status=done&style=stroke&width=394.5" alt="image.png"><br>复杂数据类型的存储方式：引用类型变量（栈空间）里存放的是地址，真正的对象实例存放在堆空间中<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611885116525-3f8ac293-e955-40f9-bbff-1aa589b53efa.png#align=left&display=inline&height=130&margin=%5Bobject%20Object%5D&name=image.png&originHeight=259&originWidth=558&size=26906&status=done&style=stroke&width=279" alt="image.png"></p><h3 id="简单类型传参"><a href="#简单类型传参" class="headerlink" title="简单类型传参"></a>简单类型传参</h3><pre><code>函数的形参也可以看做是一个变量，当我们把一个值类型变量作为参数传给函数的形参时，其实是把变量在栈空间里的值复制了一份给形参，那么在方法内部对形参做任何修改，都不会影响到的外部变量。</code></pre><pre><code class="js">function fn(a) &#123;    a++;    console.log(a);&#125;var x = 10;fn(x);console.log(x)；</code></pre><pre><code>    运行结果如下：</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611885126655-4b3507e8-a666-4dae-b1c5-ecd0ad9f8bdb.png#align=left&display=inline&height=98&margin=%5Bobject%20Object%5D&name=image.png&originHeight=195&originWidth=364&size=6181&status=done&style=stroke&width=182" alt="image.png"></p><h3 id="复杂数据类型传参"><a href="#复杂数据类型传参" class="headerlink" title="复杂数据类型传参"></a>复杂数据类型传参</h3><pre><code>函数的形参也可以看做是一个变量，当我们把引用类型变量传给形参时，其实是把变量在栈空间里保存的堆地址复制给了形参，形参和实参其实保存的是同一个堆地址，所以操作的是同一个对象。</code></pre><pre><code class="JavaScript">function Person(name) &#123;    this.name = name;&#125;function f1(x) &#123; // x = p    console.log(x.name); // 2. 这个输出什么 ?    x.name = &quot;张学友&quot;;    console.log(x.name); // 3. 这个输出什么 ?&#125;var p = new Person(&quot;刘德华&quot;);console.log(p.name);    // 1. 这个输出什么 ?f1(p);console.log(p.name);    // 4. 这个输出什么 ?</code></pre><pre><code>    运行结果如下：</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611885137269-b37442f2-ea5b-45ce-a974-ff4676772c47.png#align=left&display=inline&height=163&margin=%5Bobject%20Object%5D&name=image.png&originHeight=325&originWidth=345&size=22422&status=done&style=stroke&width=172.5" alt="image.png"></p><h2 id="理解-js-里面的任务执行机制"><a href="#理解-js-里面的任务执行机制" class="headerlink" title="理解 js 里面的任务执行机制"></a>理解 js 里面的任务执行机制</h2><p>相关概念</p><ul><li><input disabled="" type="checkbox"> 异步编程</li><li><input disabled="" type="checkbox"> Javascript 的事件循环</li><li><input disabled="" type="checkbox"> 任务队列</li><li><input disabled="" type="checkbox"> 微任务队列</li><li><input disabled="" type="checkbox"> ……</li></ul><p>以下代码执行的结果是什么？</p><pre><code class="javascript">console.log(1);setTimeout(function () &#123;  console.log(3);&#125;, 3000);console.log(2);</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616040077613-888913ee-a30f-453e-8ebf-c0fd62fde8ea.png#align=left&display=inline&height=60&id=neUVv&margin=%5Bobject%20Object%5D&name=image.png&originHeight=119&originWidth=1014&size=5961&status=done&style=stroke&width=507" alt="image.png"><br>以下代码执行的结果是什么？</p><pre><code class="javascript">console.log(1);setTimeout(function () &#123;  console.log(3);&#125;, 0);console.log(2);</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616040090596-2a14e894-a341-48a9-ba3e-71bbf0d66045.png#align=left&display=inline&height=63&id=bnEfE&margin=%5Bobject%20Object%5D&name=image.png&originHeight=125&originWidth=1021&size=6181&status=done&style=stroke&width=510.5" alt="image.png"></p><h3 id="啥是单线程"><a href="#啥是单线程" class="headerlink" title="啥是单线程"></a>啥是单线程</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518364671-590b3d5b-f91b-481d-9102-3e8caa4c6075.png#align=left&display=inline&height=90&id=ZFI00&margin=%5Bobject%20Object%5D&originHeight=90&originWidth=726&status=done&style=none&width=726"><br>单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。如果前一个任务耗时很长，后一个任务就不得不一直等着。<br>这样所导致的问题是： 如果 JS 执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞的感觉。</p><h3 id="同步任务和异步任务"><a href="#同步任务和异步任务" class="headerlink" title="同步任务和异步任务"></a>同步任务和异步任务</h3><pre><code>单线程导致的问题就是后面的任务等待前面任务完成，如果前面任务很耗时（比如读取网络数据），后面任务不得不一直等待！！为了解决这个问题，利用多核 CPU 的计算能力，HTML5 提出 Web Worker 标准，允许 JavaScript 脚本创建多个线程，但是子线程完全受主线程控制。于是，JS 中出现了**同步任务**和**异步任务**。</code></pre><blockquote><p><img src="https://cdn.nlark.com/yuque/0/2021/gif/1484158/1622775361143-bbbae322-0d9e-4dff-bb5f-9c727a926563.gif#align=left&display=inline&height=43&id=q4R2o&margin=%5Bobject%20Object%5D&originHeight=43&originWidth=42&status=done&style=none&width=42"><strong>操作系统忘完了</strong></p></blockquote><p>JS 中所有任务可以分成两种，一种是同步任务（synchronous），另一种是异步任务（asynchronous）。<br><strong>【同步任务】</strong>指的是：<br>在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务；<br><strong>【异步任务】</strong>指的是：<br>不进入主线程、而进入<strong>“任务队列”</strong>的任务，当主线程中的任务运行完了，才会从”任务队列”取出异步任务放入主线程执行。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518364776-7168ea9f-39dc-4395-9d07-0a72969f568d.png#align=left&display=inline&height=432&id=uGzao&margin=%5Bobject%20Object%5D&originHeight=432&originWidth=746&status=done&style=stroke&width=746"></p><h3 id="JS-执行机制（事件循环）"><a href="#JS-执行机制（事件循环）" class="headerlink" title="JS 执行机制（事件循环）"></a>JS 执行机制（事件循环）</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518364833-4eb43c01-9779-4e8d-99a7-2f651cafb1b3.png#align=left&display=inline&height=390&id=MDARJ&margin=%5Bobject%20Object%5D&originHeight=390&originWidth=768&status=done&style=stroke&width=768"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518364890-56fd3e4e-9faa-48d5-a69f-85f0d3bfec1f.png#align=left&display=inline&height=379&id=nvj0H&margin=%5Bobject%20Object%5D&originHeight=379&originWidth=819&status=done&style=stroke&width=819"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518364949-71e82dea-e99d-4755-bb73-1c4d68acf4eb.png#align=left&display=inline&height=44&id=mZ4Kh&margin=%5Bobject%20Object%5D&originHeight=44&originWidth=838&status=done&style=stroke&width=838"></p><blockquote><p>例子</p></blockquote><pre><code class="javascript">console.log(&quot;主线程：第一个&quot;);document.onclick = function () &#123;  console.log(&quot;点击事件开始&quot;);&#125;;setTimeout(function () &#123;  console.log(&quot;定时器3s&quot;);&#125;, 3000);setTimeout(function () &#123;  console.log(&quot;定时器1s&quot;);&#125;, 1000);console.log(&quot;主线程：最后一个&quot;);</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1622776526386-add5d6e7-7b7f-4e5c-98af-f9189c7282ca.png#align=left&display=inline&height=232&id=u6ef71c6b&margin=%5Bobject%20Object%5D&name=image.png&originHeight=464&originWidth=796&size=129597&status=done&style=none&width=398" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1622776561826-eb27e6c9-623e-4bc1-85b4-78ee987e86d5.png#align=left&display=inline&height=113&id=u5336dfef&margin=%5Bobject%20Object%5D&name=image.png&originHeight=225&originWidth=922&size=36281&status=done&style=none&width=461" alt="image.png"></p><h3 id="JS-创建异步任务枚举"><a href="#JS-创建异步任务枚举" class="headerlink" title="JS 创建异步任务枚举"></a>JS 创建异步任务枚举</h3><blockquote><p>参考：</p><ul><li><a href="https://juejin.cn/post/6844903832388894727">理解 JavaScript 概念系列–异步任务</a></li><li><a href="https://juejin.cn/post/6844903760280420366">JS 异步编程六种方案</a></li></ul></blockquote><h3 id="期约-Promise"><a href="#期约-Promise" class="headerlink" title="期约 Promise"></a>期约 Promise</h3><ul><li><a href="https://www.cnblogs.com/lvdabao/p/es6-promise-1.html">大白话讲解 Promise（一）</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
          <category> ECMAScript </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>DOM事件</title>
      <link href="blog/wgzidzz85o76/"/>
      <url>blog/wgzidzz85o76/</url>
      
        <content type="html"><![CDATA[<h2 id="事件（低阶）"><a href="#事件（低阶）" class="headerlink" title="事件（低阶）"></a>事件（低阶）</h2><blockquote><p>事件三要素</p></blockquote><ul><li>Who(事件源)：触发事件的元素</li><li>What(事件类型)： eg 绑定 click 点击事件</li><li>How(事件处理程序)：事件触发后要执行的代码(函数赋值形式)，事件处理函数**</li></ul><h3 id="常见鼠标事件"><a href="#常见鼠标事件" class="headerlink" title="常见鼠标事件"></a>常见鼠标事件</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518355975-babb3ede-4626-4ccd-9507-eb4c35c58439.png#align=left&display=inline&height=318&margin=%5Bobject%20Object%5D&originHeight=318&originWidth=714&status=done&style=stroke&width=714"></p><h3 id="addEventListener"><a href="#addEventListener" class="headerlink" title="addEventListener()"></a>addEventListener()</h3><blockquote><p>事件监听（IE9 以后支持）</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518360715-05c708e0-db51-4791-b3cc-14ca89b6d9bc.png#align=left&display=inline&height=61&margin=%5Bobject%20Object%5D&originHeight=61&originWidth=707&status=done&style=none&width=707"><br>eventTarget.addEventListener()方法将指定的监听器注册到 eventTarget（目标对象）上，当该对象触发指定的事件时，就会执行事件处理函数。</p><ul><li>type：监听事件类型 click……（不要加 on，要记得加引号）</li><li>listener：监听函数（触发之后进行什么样的行为（函数））</li><li>useCapture：默认 false</li></ul><pre><code class="javascript">var class_down = document.getElementsByClassName(&quot;entry-thumb&quot;);var over_img_back_index = class_down[0].getElementsByTagName(&quot;img&quot;);over_img_back_index[0].addEventListener(&quot;mouseover&quot;, function () &#123;  alert(&quot;鼠标经过左侧图片，触发至即将跳转到首页&quot;);  location.href = &quot;https://www.wztlink1013.com&quot;;&#125;);</code></pre><h3 id="attachEvent"><a href="#attachEvent" class="headerlink" title="attachEvent()"></a>attachEvent()</h3><blockquote><p>事件监听（IE678 支持）</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518360822-32bdd41a-9d13-4b76-93db-3f503b39bba7.png#align=left&display=inline&height=52&margin=%5Bobject%20Object%5D&originHeight=52&originWidth=696&status=done&style=none&width=696"></p><ul><li>和 addEventListener()功能一样，不过这是老版本只带两个参数，而且第一个参数要加 on</li></ul><h3 id="兼容性解决注册事件"><a href="#兼容性解决注册事件" class="headerlink" title="兼容性解决注册事件"></a>兼容性解决注册事件</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518360652-874303ea-a903-4f8c-93a0-a90c193c661b.png#align=left&display=inline&height=361&margin=%5Bobject%20Object%5D&originHeight=361&originWidth=867&status=done&style=stroke&width=867"><br>封装一个函数，函数中判断浏览器的类型：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518360935-9054e419-704a-402e-969c-a572f0f322e0.png#align=left&display=inline&height=266&margin=%5Bobject%20Object%5D&originHeight=266&originWidth=643&status=done&style=none&width=643"></p><h3 id="解绑事件"><a href="#解绑事件" class="headerlink" title="解绑事件"></a>解绑事件</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518360992-53947cad-916b-4b2a-baf9-0587c30a33d9.png#align=left&display=inline&height=241&margin=%5Bobject%20Object%5D&originHeight=241&originWidth=737&status=done&style=stroke&width=737"></p><pre><code class="html">&lt;div&gt;1&lt;/div&gt;&lt;div&gt;2&lt;/div&gt;&lt;div&gt;3&lt;/div&gt;&lt;script&gt;  var divs = document.querySelectorAll(&quot;div&quot;);  divs[0].onclick = function () &#123;    alert(11);    // 1. 传统方式删除事件    divs[0].onclick = null;  &#125;;  // 2. removeEventListener 删除事件  divs[1].addEventListener(&quot;click&quot;, fn); // 里面的fn 不需要调用加小括号  function fn() &#123;    alert(22);    divs[1].removeEventListener(&quot;click&quot;, fn);  &#125;  // 3. detachEvent  divs[2].attachEvent(&quot;onclick&quot;, fn1);  function fn1() &#123;    alert(33);    divs[2].detachEvent(&quot;onclick&quot;, fn1);  &#125;&lt;/script&gt;</code></pre><blockquote><p>**删除事件兼容性解决方案 **</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518361056-6ce22708-00af-43e8-943d-466fe8fcb053.png#align=left&display=inline&height=269&margin=%5Bobject%20Object%5D&originHeight=269&originWidth=713&status=done&style=none&width=713"></p><h2 id="常用鼠标事件"><a href="#常用鼠标事件" class="headerlink" title="常用鼠标事件"></a>常用鼠标事件</h2><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518361860-3dea106f-9140-4836-8e7d-2f160b94435b.png#align=left&display=inline&height=305&margin=%5Bobject%20Object%5D&originHeight=305&originWidth=683&status=done&style=stroke&width=683"></p><h3 id="Demo：禁止选中文字和禁止右键菜单"><a href="#Demo：禁止选中文字和禁止右键菜单" class="headerlink" title="Demo：禁止选中文字和禁止右键菜单"></a>Demo：禁止选中文字和禁止右键菜单</h3><blockquote><p>【1】禁止鼠标选中</p></blockquote><ul><li>selectstart 开始选中</li></ul><pre><code class="javascript">document.addEventListener(&quot;selectstart&quot;, function (e) &#123;  e.preventDefault();&#125;);</code></pre><blockquote><p>【2】禁止鼠标右键菜单</p></blockquote><ul><li>contextmenu 主要控制应该合适显示上下文菜单，主要用于程序员取消默认的上下文菜单</li></ul><pre><code class="javascript">document.addEventListener(&quot;contextmenu&quot;, function (e) &#123;  e.preventDefault();&#125;);</code></pre><h3 id="鼠标事件对象"><a href="#鼠标事件对象" class="headerlink" title="鼠标事件对象"></a>鼠标事件对象</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518361978-034f2af6-14fa-4ddb-bd8b-2eabe289eb59.png#align=left&display=inline&height=308&margin=%5Bobject%20Object%5D&originHeight=308&originWidth=703&status=done&style=stroke&width=703"></p><h3 id="Demo：获取鼠标在页面的坐标"><a href="#Demo：获取鼠标在页面的坐标" class="headerlink" title="Demo：获取鼠标在页面的坐标"></a>Demo：获取鼠标在页面的坐标</h3><pre><code class="html">&lt;script&gt;  // 鼠标事件对象 MouseEvent  document.addEventListener(&quot;click&quot;, function (e) &#123;    console.log(&quot;client 鼠标在可视区的x和y坐标&quot;);    console.log(e.clientX);    console.log(e.clientY);    console.log(&quot;---------------------&quot;);    console.log(&quot;page 鼠标在页面文档的x和y坐标&quot;);    console.log(e.pageX);    console.log(e.pageY);    console.log(&quot;---------------------&quot;);    console.log(&quot;screen 鼠标在电脑屏幕的x和y坐标&quot;);    console.log(e.screenX);    console.log(e.screenY);  &#125;);&lt;/script&gt;</code></pre><h3 id="Demo：跟随鼠标的天使"><a href="#Demo：跟随鼠标的天使" class="headerlink" title="Demo：跟随鼠标的天使"></a>Demo：跟随鼠标的天使</h3><pre><code class="html">&lt;img src=&quot;images/angel.gif&quot; alt=&quot;&quot; /&gt;&lt;script&gt;  var pic = document.querySelector(&quot;img&quot;);  document.addEventListener(&quot;mousemove&quot;, function (e) &#123;    // 1. mousemove只要我们鼠标移动1px 就会触发这个事件    // 2.核心原理： 每次鼠标移动，我们都会获得最新的鼠标坐标，    // 把这个x和y坐标做为图片的top和left 值就可以移动图片    var x = e.pageX;    var y = e.pageY;    console.log(&quot;x坐标是&quot; + x, &quot;y坐标是&quot; + y);    //3 . 千万不要忘记给left 和top 添加px 单位    pic.style.left = x - 50 + &quot;px&quot;;    pic.style.top = y - 40 + &quot;px&quot;;  &#125;);&lt;/script&gt;</code></pre><h3 id="mouseenter-和-mouseover-的区别"><a href="#mouseenter-和-mouseover-的区别" class="headerlink" title="mouseenter 和 mouseover 的区别"></a>mouseenter 和 mouseover 的区别</h3><ul><li>当鼠标移动到元素上时就会触发 mouseenter 事件</li><li>类似 mouseover，它们两者之间的差别是</li><li>mouseover 鼠标经过自身盒子会触发，经过子盒子还会触发。mouseenter  只会经过自身盒子触发</li><li>之所以这样，就是因为 mouseenter 不会冒泡</li><li>跟 mouseenter 搭配鼠标离开 mouseleave  同样不会冒泡</li></ul><h2 id="常用键盘事件"><a href="#常用键盘事件" class="headerlink" title="常用键盘事件"></a>常用键盘事件</h2><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518362322-f21797ca-1e8e-4702-a243-4e76a8458b7e.png#align=left&display=inline&height=143&margin=%5Bobject%20Object%5D&originHeight=143&originWidth=701&status=done&style=stroke&width=701"></p><ul><li>三个事件执行的顺序是：keydown-&gt;keypress-&gt;keyup</li></ul><pre><code class="html">&lt;script&gt;  // 常用的键盘事件  //1. keyup 按键弹起的时候触发  document.addEventListener(&quot;keyup&quot;, function () &#123;    console.log(&quot;我弹起了&quot;);  &#125;);  //3. keypress 按键按下的时候触发  不能识别功能键 比如 ctrl shift 左右箭头啊  document.addEventListener(&quot;keypress&quot;, function () &#123;    console.log(&quot;我按下了press&quot;);  &#125;);  //2. keydown 按键按下的时候触发  能识别功能键 比如 ctrl shift 左右箭头啊  document.addEventListener(&quot;keydown&quot;, function () &#123;    console.log(&quot;我按下了down&quot;);  &#125;);  // 4. 三个事件的执行顺序  keydown -- keypress -- keyup&lt;/script&gt;</code></pre><h3 id="键盘事件对象"><a href="#键盘事件对象" class="headerlink" title="键盘事件对象"></a>键盘事件对象</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518362443-95c05d9c-6850-4cc3-a35e-c972b1723658.png#align=left&display=inline&height=78&margin=%5Bobject%20Object%5D&originHeight=78&originWidth=700&status=done&style=stroke&width=700"></p><ul><li>onkeydown 和 onkeyup 不区分字母大小写，onkeypress 区分字母大小写（使用更多的前面两个，能够识别所有键，包括功能键）</li><li>keypress 不识别功能键，但是 keyCode 属性能够区分大小写，返回不同的 ASCII 值<blockquote><p><strong>使用 keyCode 属性判断用户按下哪个键</strong></p></blockquote></li></ul><pre><code class="html">&lt;script&gt;  // 键盘事件对象中的keyCode属性可以得到相应键的ASCII码值  document.addEventListener(&quot;keyup&quot;, function (e) &#123;    console.log(&quot;up:&quot; + e.keyCode);    // 我们可以利用keycode返回的ASCII码值来判断用户按下了那个键    if (e.keyCode === 65) &#123;      alert(&quot;您按下的a键&quot;);    &#125; else &#123;      alert(&quot;您没有按下a键&quot;);    &#125;  &#125;);  document.addEventListener(&quot;keypress&quot;, function (e) &#123;    // console.log(e);    console.log(&quot;press:&quot; + e.keyCode);  &#125;);&lt;/script&gt;</code></pre><h3 id="Demo：模拟京东按键输入内容"><a href="#Demo：模拟京东按键输入内容" class="headerlink" title="Demo：模拟京东按键输入内容"></a>Demo：模拟京东按键输入内容</h3><ul><li>当我们按下 s 键， 光标就定位到搜索框（文本框获得焦点）。</li><li>注意：触发获得焦点事件，可以使用 元素对象.focus()</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616211826182-452dfe9b-0c03-4fe3-845c-afc16697e3ee.png#align=left&display=inline&height=442&margin=%5Bobject%20Object%5D&name=image.png&originHeight=883&originWidth=1920&size=1657927&status=done&style=stroke&width=960" alt="image.png"></p><h3 id="Demo：模拟京东快递单号查询"><a href="#Demo：模拟京东快递单号查询" class="headerlink" title="Demo：模拟京东快递单号查询"></a>Demo：模拟京东快递单号查询</h3><p>要求：当我们在文本框中输入内容时，文本框上面自动显示大字号的内容。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518362646-5b0c1da3-32dd-40b4-8b42-1bbb3065c01c.png#align=left&display=inline&height=259&margin=%5Bobject%20Object%5D&originHeight=259&originWidth=551&status=done&style=stroke&width=551"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518362734-9740cabb-bd4d-48ce-824d-001b5913b804.png#align=left&display=inline&height=288&margin=%5Bobject%20Object%5D&originHeight=288&originWidth=751&status=done&style=none&width=751"></p><pre><code class="js">&lt;div class=&quot;search&quot;&gt;        &lt;div class=&quot;con&quot;&gt;123&lt;/div&gt;        &lt;input type=&quot;text&quot; placeholder=&quot;请输入您的快递单号&quot; class=&quot;jd&quot;&gt;    &lt;/div&gt;    &lt;script&gt;        // 获取要操作的元素        var con = document.querySelector(&#39;.con&#39;);        var jd_input = document.querySelector(&#39;.jd&#39;);        // 给输入框注册keyup事件        jd_input.addEventListener(&#39;keyup&#39;, function() &#123;                // 判断输入框内容是否为空                if (this.value == &#39;&#39;) &#123;                    // 为空，隐藏放大提示盒子                    con.style.display = &#39;none&#39;;                &#125; else &#123;                    // 不为空，显示放大提示盒子，设置盒子的内容                    con.style.display = &#39;block&#39;;                    con.innerText = this.value;                &#125;            &#125;)        // 给输入框注册失去焦点事件，隐藏放大提示盒子        jd_input.addEventListener(&#39;blur&#39;, function() &#123;                con.style.display = &#39;none&#39;;            &#125;)        // 给输入框注册获得焦点事件        jd_input.addEventListener(&#39;focus&#39;, function() &#123;            // 判断输入框内容是否为空            if (this.value !== &#39;&#39;) &#123;                // 不为空则显示提示盒子                con.style.display = &#39;block&#39;;            &#125;        &#125;)    &lt;/script&gt;</code></pre><h2 id="事件（高阶）"><a href="#事件（高阶）" class="headerlink" title="事件（高阶）"></a>事件（高阶）</h2><h3 id="DOM-事件流"><a href="#DOM-事件流" class="headerlink" title="DOM 事件流"></a>DOM 事件流</h3><pre><code>html中的标签都是相互嵌套的，我们可以将元素想象成一个盒子装一个盒子，document是最外面的大盒子。当你单击一个div时，同时你也单击了div的父元素，甚至整个页面。那么是先执行父元素的单击事件，还是先执行div的单击事件 ？？？</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518361114-2ab6ad14-e27a-4626-88bd-abbc2badfc0b.png#align=left&display=inline&height=70&margin=%5Bobject%20Object%5D&originHeight=70&originWidth=696&status=done&style=stroke&width=696"></p><blockquote><p>比如：我们给页面中的一个 div 注册了单击事件，当你单击了 div 时，也就单击了 body，单击了 html，单击了 document。</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518361173-9a6bf5d3-a273-4294-b849-0ebaf79da603.png#align=left&display=inline&height=196&margin=%5Bobject%20Object%5D&originHeight=196&originWidth=268&status=done&style=none&width=268"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518361248-0ea0959b-c350-4780-9437-8561fe69f36d.png#align=left&display=inline&height=72&margin=%5Bobject%20Object%5D&originHeight=72&originWidth=751&status=done&style=none&width=751"></p><pre><code>当时的2大浏览器霸主谁也不服谁！IE 提出从目标元素开始，然后一层一层向外接收事件并响应，也就是冒泡型事件流。Netscape（网景公司）提出从最外层开始，然后一层一层向内接收事件并响应，也就是捕获型事件流。江湖纷争，武林盟主也脑壳疼！！！最终，w3c 采用折中的方式，平息了战火，制定了统一的标准 —--— 先捕获再冒泡。现代浏览器都遵循了此标准，所以当事件发生时，会经历3个阶段。</code></pre><p>DOM 事件流会经历 3 个阶段：</p><ol><li><p> 捕获阶段</p></li><li><p> 当前目标阶段</p></li><li><p>冒泡阶段</p><pre><code> 我们向水里面扔一块石头，首先它会有一个下降的过程，这个过程就可以理解为从最顶层向事件发生的最具体元素（目标点）的捕获过程；之后会产生泡泡，会在最低点（ 最具体元素）之后漂浮到水面上，这个过程相当于事件冒泡。</code></pre><p> <img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518361302-fa0b37f5-a8ec-4898-82b6-e136cd291951.png#align=left&display=inline&height=271&margin=%5Bobject%20Object%5D&originHeight=271&originWidth=498&status=done&style=none&width=498"><br> <img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518361362-b8b1f065-da6a-40c5-8782-b265699cdd49.png#align=left&display=inline&height=370&margin=%5Bobject%20Object%5D&originHeight=370&originWidth=757&status=done&style=none&width=757"><br> <strong>事件冒泡</strong></p></li></ol><pre><code class="js">&lt;div class=&quot;father&quot;&gt;        &lt;div class=&quot;son&quot;&gt;son盒子&lt;/div&gt;    &lt;/div&gt;    &lt;script&gt;        // onclick 和 attachEvent（ie） 在冒泡阶段触发        // 冒泡阶段 如果addEventListener 第三个参数是 false 或者 省略        // son -&gt; father -&gt;body -&gt; html -&gt; document        var son = document.querySelector(&#39;.son&#39;);        // 给son注册单击事件        son.addEventListener(&#39;click&#39;, function() &#123;            alert(&#39;son&#39;);        &#125;, false);        // 给father注册单击事件        var father = document.querySelector(&#39;.father&#39;);        father.addEventListener(&#39;click&#39;, function() &#123;            alert(&#39;father&#39;);        &#125;, false);        // 给document注册单击事件，省略第3个参数        document.addEventListener(&#39;click&#39;, function() &#123;            alert(&#39;document&#39;);        &#125;)    &lt;/script&gt;</code></pre><p><strong>事件捕获</strong></p><pre><code class="js">&lt;div class=&quot;father&quot;&gt;        &lt;div class=&quot;son&quot;&gt;son盒子&lt;/div&gt;    &lt;/div&gt;    &lt;script&gt;        // 如果addEventListener() 第三个参数是 true 那么在捕获阶段触发        // document -&gt; html -&gt; body -&gt; father -&gt; son         var son = document.querySelector(&#39;.son&#39;);        // 给son注册单击事件，第3个参数为true         son.addEventListener(&#39;click&#39;, function() &#123;             alert(&#39;son&#39;);         &#125;, true);         var father = document.querySelector(&#39;.father&#39;);        // 给father注册单击事件，第3个参数为true         father.addEventListener(&#39;click&#39;, function() &#123;             alert(&#39;father&#39;);         &#125;, true);        // 给document注册单击事件，第3个参数为true        document.addEventListener(&#39;click&#39;, function() &#123;            alert(&#39;document&#39;);        &#125;, true)    &lt;/script&gt;</code></pre><h3 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h3><h4 id="什么是事件对象"><a href="#什么是事件对象" class="headerlink" title="什么是事件对象"></a>什么是事件对象</h4><p>事件发生后，跟事件相关的一系列信息数据的集合都放到这个对象里面，这个对象就是事件对象。<br>比如：</p><ol><li>谁绑定了这个事件。</li><li>鼠标触发事件的话，会得到鼠标的相关信息，如鼠标位置。</li><li>键盘触发事件的话，会得到键盘的相关信息，如按了哪个键。</li></ol><h4 id="事件对象的使用"><a href="#事件对象的使用" class="headerlink" title="事件对象的使用"></a>事件对象的使用</h4><p>事件触发发生时就会产生事件对象，并且系统会以实参的形式传给事件处理函数。<br>所以，在事件处理函数中声明 1 个形参用来接收事件对象。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518361420-28ca3202-57b2-48ab-83cb-620191320123.png#align=left&display=inline&height=259&margin=%5Bobject%20Object%5D&originHeight=259&originWidth=681&status=done&style=none&width=681"></p><h4 id="事件对象的兼容性处理"><a href="#事件对象的兼容性处理" class="headerlink" title="事件对象的兼容性处理"></a>事件对象的兼容性处理</h4><p>事件对象本身的获取存在兼容问题：</p><ol><li>标准浏览器中是浏览器给方法传递的参数，只需要定义形参 e 就可以获取到。</li><li>在 IE6~8 中，浏览器不会给方法传递参数，如果需要的话，需要到 window.event 中获取查找。</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518361484-fb99b58d-4733-4716-b625-a14e1cd02938.png#align=left&display=inline&height=71&margin=%5Bobject%20Object%5D&originHeight=71&originWidth=660&status=done&style=none&width=660"></p><pre><code>只要“||”前面为false, 不管“||”后面是true 还是 false，都返回 “||” 后面的值。只要“||”前面为true, 不管“||”后面是true 还是 false，都返回 “||” 前面的值。</code></pre><pre><code class="js">&lt;div&gt;123&lt;/div&gt;    &lt;script&gt;        var div = document.querySelector(&#39;div&#39;);        div.onclick = function(e) &#123;                // 事件对象                e = e || window.event;                console.log(e);        &#125;    &lt;/script&gt;</code></pre><h4 id="事件对象的属性和方法"><a href="#事件对象的属性和方法" class="headerlink" title="事件对象的属性和方法"></a>事件对象的属性和方法</h4><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518361541-14665361-d721-4083-8cb2-d2088c6dc0cc.png#align=left&display=inline&height=273&margin=%5Bobject%20Object%5D&originHeight=273&originWidth=698&status=done&style=none&width=698"></p><h4 id="e-target-和-this-的区别"><a href="#e-target-和-this-的区别" class="headerlink" title="e.target 和 this 的区别"></a>e.target 和 this 的区别</h4><ul><li>this 是事件绑定的元素（绑定这个事件处理函数的元素） 。</li><li>e.target 是事件触发的元素。</li></ul><pre><code>常情况下terget 和 this是一致的，但有一种情况不同，那就是在事件冒泡时（父子元素有相同事件，单击子元素，父元素的事件处理函数也会被触发执行），    这时候this指向的是父元素，因为它是绑定事件的元素对象，    而target指向的是子元素，因为他是触发事件的那个具体元素对象。</code></pre><pre><code class="js">&lt;div&gt;123&lt;/div&gt;    &lt;script&gt;        var div = document.querySelector(&#39;div&#39;);        div.addEventListener(&#39;click&#39;, function(e) &#123;            // e.target 和 this指向的都是div            console.log(e.target);            console.log(this);        &#125;);    &lt;/script&gt;</code></pre><p>事件冒泡下的 e.target 和 this</p><pre><code class="js">&lt;ul&gt;        &lt;li&gt;abc&lt;/li&gt;        &lt;li&gt;abc&lt;/li&gt;        &lt;li&gt;abc&lt;/li&gt;    &lt;/ul&gt;    &lt;script&gt;        var ul = document.querySelector(&#39;ul&#39;);        ul.addEventListener(&#39;click&#39;, function(e) &#123;              // 我们给ul 绑定了事件  那么this 就指向ul              console.log(this); // ul              // e.target 触发了事件的对象 我们点击的是li e.target 指向的就是li              console.log(e.target); // li        &#125;);    &lt;/script&gt;</code></pre><h3 id="阻止默认行为"><a href="#阻止默认行为" class="headerlink" title="阻止默认行为"></a>阻止默认行为</h3><blockquote><p>html 中一些标签有默认行为，例如 a 标签被单击后，默认会进行页面跳转。</p></blockquote><pre><code class="js">&lt;a href=&quot;http://www.baidu.com&quot;&gt;百度&lt;/a&gt;    &lt;script&gt;        // 2. 阻止默认行为 让链接不跳转        var a = document.querySelector(&#39;a&#39;);        a.addEventListener(&#39;click&#39;, function(e) &#123;             e.preventDefault(); //  dom 标准写法        &#125;);        // 3. 传统的注册方式        a.onclick = function(e) &#123;            // 普通浏览器 e.preventDefault();  方法            e.preventDefault();            // 低版本浏览器 ie678  returnValue  属性            e.returnValue = false;            // 我们可以利用return false 也能阻止默认行为 没有兼容性问题            return false;        &#125;    &lt;/script&gt;</code></pre><h3 id="阻止事件冒泡"><a href="#阻止事件冒泡" class="headerlink" title="阻止事件冒泡"></a>阻止事件冒泡</h3><p>事件冒泡本身的特性，会带来的坏处，也会带来的好处。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518361625-d482ad01-1332-4d91-b951-664b337c86f3.png#align=left&display=inline&height=182&margin=%5Bobject%20Object%5D&originHeight=182&originWidth=667&status=done&style=none&width=667"></p><pre><code class="js">&lt;div class=&quot;father&quot;&gt;        &lt;div class=&quot;son&quot;&gt;son儿子&lt;/div&gt;    &lt;/div&gt;    &lt;script&gt;        var son = document.querySelector(&#39;.son&#39;);        // 给son注册单击事件        son.addEventListener(&#39;click&#39;, function(e) &#123;            alert(&#39;son&#39;);            e.stopPropagation(); // stop 停止  Propagation 传播            window.event.cancelBubble = true; // 非标准 cancel 取消 bubble 泡泡        &#125;, false);        var father = document.querySelector(&#39;.father&#39;);        // 给father注册单击事件        father.addEventListener(&#39;click&#39;, function() &#123;            alert(&#39;father&#39;);        &#125;, false);        // 给document注册单击事件        document.addEventListener(&#39;click&#39;, function() &#123;            alert(&#39;document&#39;);        &#125;)    &lt;/script&gt;</code></pre><p><strong>阻止事件冒泡的兼容性处理</strong><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518361680-f20195f2-69b6-4d72-a6d5-6a5d08646b73.png#align=left&display=inline&height=167&margin=%5Bobject%20Object%5D&originHeight=167&originWidth=685&status=done&style=none&width=685"></p><h3 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h3><p>事件冒泡本身的特性，会带来的坏处，也会带来的好处。</p><h4 id="什么是事件委托"><a href="#什么是事件委托" class="headerlink" title="什么是事件委托"></a>什么是事件委托</h4><pre><code>把事情委托给别人，代为处理。</code></pre><p>事件委托也称为事件代理，在 jQuery 里面称为事件委派。</p><blockquote><p>说白了就是，不给子元素注册事件，给父元素注册事件，把处理代码在父元素的事件中执行。</p></blockquote><p><strong>生活中的代理：</strong><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518361736-9861e13e-f31a-4425-b062-883b21374fce.png#align=left&display=inline&height=159&margin=%5Bobject%20Object%5D&originHeight=159&originWidth=689&status=done&style=none&width=689"><br><strong>js 事件中的代理：</strong><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518361805-81024b8b-f5e4-488a-91fa-d8ffa16d04fa.png#align=left&display=inline&height=278&margin=%5Bobject%20Object%5D&originHeight=278&originWidth=698&status=done&style=none&width=698"></p><h4 id="事件委托的原理"><a href="#事件委托的原理" class="headerlink" title="事件委托的原理"></a>事件委托的原理</h4><pre><code>给父元素注册事件，利用事件冒泡，当子元素的事件触发，会冒泡到父元素，然后去控制相应的子元素。</code></pre><h4 id="事件委托的作用"><a href="#事件委托的作用" class="headerlink" title="事件委托的作用"></a>事件委托的作用</h4><ul><li>我们只操作了一次 DOM ，提高了程序的性能。</li><li>动态新创建的子元素，也拥有事件。</li></ul><pre><code class="js">&lt;ul&gt;        &lt;li&gt;知否知否，点我应有弹框在手！&lt;/li&gt;        &lt;li&gt;知否知否，点我应有弹框在手！&lt;/li&gt;        &lt;li&gt;知否知否，点我应有弹框在手！&lt;/li&gt;        &lt;li&gt;知否知否，点我应有弹框在手！&lt;/li&gt;        &lt;li&gt;知否知否，点我应有弹框在手！&lt;/li&gt;    &lt;/ul&gt;    &lt;script&gt;        // 事件委托的核心原理：给父节点添加侦听器， 利用事件冒泡影响每一个子节点        var ul = document.querySelector(&#39;ul&#39;);        ul.addEventListener(&#39;click&#39;, function(e) &#123;            // e.target 这个可以得到我们点击的对象            e.target.style.backgroundColor = &#39;pink&#39;;        &#125;)    &lt;/script&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
          <category> DOM </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>es面向对象</title>
      <link href="blog/zfpg9dfgehog/"/>
      <url>blog/zfpg9dfgehog/</url>
      
        <content type="html"><![CDATA[<div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">对于实现面向对象这一块，JavaScript可谓是我见过最恶心的一门语言，现在发现之前学的C++或是Java简直不要太正规……JavaScript首先在ES6没有出来之前，利用一个叫原型的一系列机制来用一段很长的代码来实现类的继承，说白了就是在函数里面默认给你加个一个叫原型的对象属性，再利用一系列指向来完成所谓的继承。在ES6之后，才有了形式上的类class及其对象，以及一个单词extends就搞定的继承，虽说搞定，但这里面的机制还是原型相关知识，记录学习一下。不管是原型也好，新加的class也罢，就一个目的——**为了实现面向对象**。从两个体系来展开详述。</div><h2 id="原始值和引用值"><a href="#原始值和引用值" class="headerlink" title="原始值和引用值"></a>原始值和引用值</h2><p>这里面 Java 和 JavaScript 都是只有引用的概念，但是在 C/C++里面，就有指针的概念<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1617868682681-90191ec3-c5b2-415f-9e38-df2706301e0c.png#align=left&display=inline&height=173&margin=%5Bobject%20Object%5D&name=image.png&originHeight=346&originWidth=931&size=136387&status=done&style=none&width=465.5" alt="image.png"></p><ul><li>参考：<a href="https://blog.csdn.net/u012443286/article/details/79496742">谈谈 JavaScript 中的变量、指针和引用</a></li></ul><h2 id="体系一：原型"><a href="#体系一：原型" class="headerlink" title="体系一：原型"></a>体系一：原型</h2><h3 id="构造函数原型"><a href="#构造函数原型" class="headerlink" title="构造函数原型"></a>构造函数原型</h3><p>每个构造函数里面都有一个属性，这个属性叫 prototype，<strong>指向另一个对象</strong>（有什么用？在后面原型链就会发现有用了），并且这个属性是一个对象，叫做构造函数原型</p><blockquote><p>这样可以解决一个问题，就是创建不同实例，这些事例所用的方法都是同一个内存下的方法，实现共享</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1622631532174-610cc30a-7a6e-4ac5-ac53-adc0359b06f1.png#align=left&display=inline&height=245&margin=%5Bobject%20Object%5D&name=image.png&originHeight=489&originWidth=1029&size=268026&status=done&style=none&width=514.5" alt="image.png"></p><h3 id="对象原型"><a href="#对象原型" class="headerlink" title="对象原型"></a>对象原型</h3><p>每个对象里面都有<strong>proto</strong>属性，这个叫对象原型，这个玩意指向<strong>构造函数的 prototype 对象</strong></p><blockquote><p><strong>proto</strong>对象原型的意义就在于为对象的查找机制提供一个方向，或者说一条路线，但是它是一个非标准属性，因此实际开发中，不可以使用这个属性，它只是内部指向原型对象 prototype</p></blockquote><h3 id="constructor-构造函数"><a href="#constructor-构造函数" class="headerlink" title="constructor 构造函数"></a>constructor 构造函数</h3><ol><li>对象原型（ <strong>proto</strong>）和构造函数（prototype）原型对象里面都有一个属性 constructor 属性 ，constructor 我们称为构造函数，因为它<strong>指回构造函数本身</strong>。</li><li>constructor 主要用于记录该对象引用于哪个构造函数，它可以让原型对象重新指向原来的构造函数。</li><li>一般情况下，对象的方法都在构造函数的原型对象中设置。如果有多个对象的方法，我们可以给原型对象采取对象形式赋值，但是这样就会覆盖构造函数原型对象原来的内容，这样修改后的原型对象 constructor   就不再指向当前构造函数了。此时，我们可以在修改后的原型对象中，添加一个 constructor 指向原来的构造函数。</li></ol><h3 id="原型链和成员查找机制"><a href="#原型链和成员查找机制" class="headerlink" title="原型链和成员查找机制"></a>原型链和成员查找机制</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1622632967349-b2adf38c-b51f-445b-b4c8-7d0408e96390.png#align=left&display=inline&height=251&margin=%5Bobject%20Object%5D&name=image.png&originHeight=501&originWidth=1002&size=152264&status=done&style=none&width=501" alt="image.png"></p><h3 id="原型体系中的继承"><a href="#原型体系中的继承" class="headerlink" title="原型体系中的继承"></a>原型体系中的继承</h3><p>call 方法可以改变一个函数的指向</p><ol><li>继承父构造函数里面的属性</li></ol><pre><code class="javascript">// 1. 父构造函数function Father(uname, age) &#123;  // this 指向父构造函数的对象实例  this.uname = uname;  this.age = age;&#125;// 2 .子构造函数function Son(uname, age, score) &#123;  // this 指向子构造函数的对象实例  // 3.使用call方式实现子继承父的属性  Father.call(this, uname, age);  this.score = score;&#125;var son = new Son(&quot;刘德华&quot;, 18, 100);console.log(son);</code></pre><ol start="2"><li>继承方法</li></ol><pre><code class="js">// 1. 父构造函数function Father(uname, age) &#123;  // this 指向父构造函数的对象实例  this.uname = uname;  this.age = age;&#125;Father.prototype.money = function () &#123;  console.log(100000);&#125;;// 2 .子构造函数function Son(uname, age, score) &#123;  // this 指向子构造函数的对象实例  Father.call(this, uname, age);  this.score = score;&#125;// Son.prototype = Father.prototype;  这样直接赋值会有问题,如果修改了子原型对象,父原型对象也会跟着一起变化Son.prototype = new Father();// 如果利用对象的形式修改了原型对象,别忘了利用constructor 指回原来的构造函数Son.prototype.constructor = Son;// 这个是子构造函数专门的方法Son.prototype.exam = function () &#123;  console.log(&quot;孩子要考试&quot;);&#125;;var son = new Son(&quot;刘德华&quot;, 18, 100);console.log(son);</code></pre><h2 id="体系二：类-class-【ES6】"><a href="#体系二：类-class-【ES6】" class="headerlink" title="体系二：类(class)【ES6】"></a>体系二：类(class)【ES6】</h2><p>在 ES6 中新增加了类的概念，可以使用 class 关键字声明一个类，之后以这个类来实例化对象。类抽象了对象的公共部分，它泛指某一大类（class）对象特指某一个，通过类实例化一个具体的对象。其创建的方式和之前学过的语言很类似。<br>在 ES6 中类没有变量提升，所以必须先定义类，才能通过类实例化对象</p><h3 id="创建-继承-使用"><a href="#创建-继承-使用" class="headerlink" title="创建+继承+使用"></a>创建+继承+使用</h3><pre><code class="javascript">// 奥特曼类class Aoteman &#123;  // 构造函数里面放共有属性、方法  constructor(name, age) &#123;    this.name = name;    this.age = age;  &#125;  Ability(abi) &#123;    console.log(this.name + &quot; can &quot; + abi);  &#125;&#125;// 假奥特曼类 继承 奥特曼class Jia extends Aoteman &#123;  constructor(x, y) &#123;    // 继承父类的构造函数    super(x, y);    // 方便写自己的函数    this.x = x;    this.y = y;  &#125;  // 自己内部的函数  Chuiniu() &#123;    console.log(this.x + &quot; chuiniu&quot;);  &#125;&#125;// 创建迪迦对象let dijia = new Aoteman(&quot;dijia&quot;, 100);console.log(dijia);dijia.Ability(&quot;X-ray&quot;);let dijia_jia = new Jia(&quot;dijia_jia&quot;, 50);dijia_jia.Ability(&quot;xxx&quot;);dijia_jia.Chuiniu();</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1622622728600-59f47873-c895-4686-b771-f1f538198f26.png#align=left&display=inline&height=77&margin=%5Bobject%20Object%5D&name=image.png&originHeight=153&originWidth=882&size=14744&status=done&style=none&width=441" alt="image.png"></p><h2 id="对象：一系列创建"><a href="#对象：一系列创建" class="headerlink" title="对象：一系列创建"></a>对象：一系列创建</h2><h3 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h3><p>属性和方法的调用：<br>属性可以用”.”和[“属性名”]来调用<br>方法用”.”来调用</p><h3 id="模式工厂"><a href="#模式工厂" class="headerlink" title="模式工厂"></a>模式工厂</h3><p>new 一个空对象，<code>let obj = new Object();</code><br>然后利用”.”的方式给其添加属性和方法<br>内置的 Object()构造函数<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1622623002064-1297005b-76a6-4d94-9b12-a83cf709e3a1.png#align=left&display=inline&height=215&margin=%5Bobject%20Object%5D&name=image.png&originHeight=429&originWidth=1059&size=99843&status=done&style=shadow&width=529.5" alt="image.png"></p><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><blockquote><p>构造函数：是一种特殊的函数，主要用来初始化对象，即为对象成员变量赋初始值，它总与 new 运算符一起使用。我们可以把对象中一些公共的属性和方法抽取出来，然后封装到这个函数里面。</p></blockquote><pre><code class="javascript">function 构造函数名(形参1,形参2,形参3) &#123;     this.属性名1 = 参数1;     this.属性名2 = 参数2;     this.属性名3 = 参数3;     this.方法名 = 函数体;&#125;let obj = new 构造函数名(实参1，实参2，实参3)</code></pre><ul><li>构造函数约定<strong>首字母大写</strong>。</li><li>函数内的属性和方法前面需要添加 <strong>this</strong> ，表示当前对象的属性和方法。</li><li>构造函数中<strong>不需要 return 返回结果</strong>。</li><li>当我们创建对象的时候，<strong>必须用 new 来调用构造函数</strong>。</li></ul><h3 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1622623181327-bd4b5d09-8525-4c59-b550-9af381526f23.png#align=left&display=inline&height=264&margin=%5Bobject%20Object%5D&name=image.png&originHeight=527&originWidth=1059&size=125271&status=done&style=shadow&width=529.5" alt="image.png"><br>下面详述什么是原型</p><h2 id="对象：Object-内置方法使用"><a href="#对象：Object-内置方法使用" class="headerlink" title="对象：Object 内置方法使用"></a>对象：Object 内置方法使用</h2><h3 id="对象迭代"><a href="#对象迭代" class="headerlink" title="对象迭代"></a>对象迭代</h3><div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">for...in 语句用于对数组或者对象的属性进行循环操作。</div>其语法如下：```jsfor (变量 in 对象名字) {    // 在此执行代码}```<ul><li>语法中的变量是自定义的，它需要符合命名规范，通常我们会将这个变量写为 k 或者 key。书里面建议用 const 来加持。</li></ul><pre><code class="javascript">for (let k in obj) &#123;  console.log(k); // 这里的 k 是属性名  console.log(obj[k]); // 这里的 obj[k] 是属性值&#125;</code></pre><div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">Object.keys(对象)获取属性名</div>```javascriptvar obj = {     id: 1,     pname: '小米',     price: 1999,     num: 2000};var result = Object.keys(obj)console.log(result)//[id，pname,price,num]```<h3 id="Object-defineProperty"><a href="#Object-defineProperty" class="headerlink" title="Object.defineProperty"></a>Object.defineProperty</h3><p>Object.defineProperty 设置或修改对象中的属性</p><pre><code class="javascript">Object.defineProperty(对象，修改或新增的属性名，&#123;        value:修改或新增的属性的值,        writable:true/false,//如果值为false 不允许修改这个属性值        enumerable: false,//enumerable 如果值为false 则不允许遍历    configurable: false  //configurable 如果为false 则不允许删除这个属性 属性是否可以被删除或是否可以再次修改特性&#125;)</code></pre><h2 id="面向对象设计：tab-栏切换"><a href="#面向对象设计：tab-栏切换" class="headerlink" title="面向对象设计：tab 栏切换"></a>面向对象设计：tab 栏切换</h2><h3 id="功能需求"><a href="#功能需求" class="headerlink" title="功能需求"></a>功能需求</h3><ol><li>点击 tab 栏,可以切换效果.</li><li>点击 + 号, 可以添加 tab 项和内容项.</li><li>点击 x 号, 可以删除当前的 tab 项和内容项.</li><li>双击 tab 项文字或者内容项文字可以修改里面的文字内容</li></ol><h3 id="案例准备"><a href="#案例准备" class="headerlink" title="案例准备"></a>案例准备</h3><ol><li>获取到标题元素</li><li>获取到内容元素</li><li>获取到删除的小按钮 x 号</li><li>新建 js 文件,定义类,添加需要的属性方法(切换,删除,增加,修改)</li><li>时刻注意 this 的指向问题</li></ol><h3 id="切换"><a href="#切换" class="headerlink" title="切换"></a>切换</h3><ul><li>为获取到的标题绑定点击事件,展示对应的内容区域,存储对应的索引</li></ul><pre><code class="js">this.lis[i].index = i;this.lis[i].onclick = this.toggleTab;</code></pre><ul><li>使用排他,实现只有一个元素的显示</li></ul><pre><code class="js">toggleTab() &#123;   //将所有的标题与内容类样式全部移除     for (var i = 0; i &lt; this.lis.length; i++) &#123;     this.lis[i].className = &#39;&#39;;     this.sections[i].className = &#39;&#39;;     &#125;   //为当前的标题添加激活样式     this.className = &#39;liactive&#39;;    //为当前的内容添加激活样式     that.sections[this.index].className = &#39;conactive&#39;;  &#125;</code></pre><h3 id="添加"><a href="#添加" class="headerlink" title="添加"></a>添加</h3><ul><li>为添加按钮+ 绑定点击事件</li></ul><pre><code class="js">this.add.onclick = this.addTab;</code></pre><ul><li>实现标题与内容的添加,做好排他处理</li></ul><pre><code class="js">addTab() &#123;    that.clearClass();    // (1) 创建li元素和section元素    var random = Math.random();    var li = &#39;&lt;li class=&quot;liactive&quot;&gt;&lt;span&gt;新选项卡&lt;/span&gt;&lt;span class=&quot;iconfont icon-guanbi&quot;&gt;                &lt;/span&gt;&lt;/li&gt;&#39;;    var section = &#39;&lt;section class=&quot;conactive&quot;&gt;测试 &#39; + random + &#39;&lt;/section&gt;&#39;;    // (2) 把这两个元素追加到对应的父元素里面    that.ul.insertAdjacentHTML(&#39;beforeend&#39;, li);    that.fsection.insertAdjacentHTML(&#39;beforeend&#39;, section);    that.init();    &#125;</code></pre><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><ul><li>为元素的删除按钮 x 绑定点击事件</li></ul><pre><code class="js">this.remove[i].onclick = this.removeTab;</code></pre><ul><li>获取到点击的删除按钮的所在的父元素的所有,删除对应的标题与内容</li></ul><pre><code class="js">removeTab(e) &#123;     e.stopPropagation(); // 阻止冒泡 防止触发li 的切换点击事件     var index = this.parentNode.index;     console.log(index);     // 根据索引号删除对应的li 和section   remove()方法可以直接删除指定的元素     that.lis[index].remove();     that.sections[index].remove();     that.init();     // 当我们删除的不是选中状态的li 的时候,原来的选中状态li保持不变     if (document.querySelector(&#39;.liactive&#39;)) return;     // 当我们删除了选中状态的这个li 的时候, 让它的前一个li 处于选定状态     index--;     // 手动调用我们的点击事件  不需要鼠标触发     that.lis[index] &amp;&amp; that.lis[index].click(); &#125;</code></pre><h3 id="编辑"><a href="#编辑" class="headerlink" title="编辑"></a>编辑</h3><ul><li>为元素(标题与内容)绑定双击事件</li></ul><pre><code class="javascript">this.spans[i].ondblclick = this.editTab;this.sections[i].ondblclick = this.editTab;</code></pre><ul><li>在双击事件处理文本选中状态,修改内部 DOM 节点,实现新旧 value 值的传递</li></ul><pre><code class="js">editTab() &#123;    var str = this.innerHTML;    // 双击禁止选定文字    window.getSelection ? window.getSelection().removeAllRanges() :                     document.selection.empty();    // alert(11);      this.innerHTML = &#39;&lt;input type=&quot;text&quot; /&gt;&#39;;      var input = this.children[0];      input.value = str;      input.select(); // 文本框里面的文字处于选定状态      // 当我们离开文本框就把文本框里面的值给span      input.onblur = function() &#123;      this.parentNode.innerHTML = this.value;      &#125;;      // 按下回车也可以把文本框里面的值给span      input.onkeyup = function(e) &#123;      if (e.keyCode === 13) &#123;      // 手动调用表单失去焦点事件  不需要鼠标离开操作      this.blur();      &#125;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
          <category> ECMAScript </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>jQuery3</title>
      <link href="blog/3_day03_jquery/"/>
      <url>blog/3_day03_jquery/</url>
      
        <content type="html"><![CDATA[<p>学习目标：</p><blockquote><p>能够说出 4 种常见的注册事件<br>能够说出 on 绑定事件的优势<br>能够说出 jQuery 事件委派的优点以及方式<br>能够说出绑定事件与解绑事件<br>能够说出 jQuery 对象的拷贝方法<br>能够说出 jQuery 多库共存的 2 种方法<br>能够使用 jQuery 插件</p></blockquote><h2 id="1-1-jQuery-事件注册"><a href="#1-1-jQuery-事件注册" class="headerlink" title="1.1. jQuery 事件注册"></a>1.1. jQuery 事件注册</h2><pre><code>jQuery 为我们提供了方便的事件注册机制，是开发人员抑郁操作优缺点如下：</code></pre><ul><li>优点: 操作简单，且不用担心事件覆盖等问题。</li><li>缺点: 普通的事件注册不能做事件委托，且无法实现事件解绑，需要借助其他方法。</li></ul><p><strong>语法</strong><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616073493434-c3ba216b-4d64-4229-b788-30947c24ab77.png#align=left&display=inline&height=220&margin=%5Bobject%20Object%5D&originHeight=220&originWidth=620&status=done&style=none&width=620"><br><strong>演示代码</strong></p><pre><code class="javascript">&lt;body&gt;    &lt;div&gt;&lt;/div&gt;    &lt;script&gt;        $(function() &#123;            // 1. 单个事件注册            $(&quot;div&quot;).click(function() &#123;                $(this).css(&quot;background&quot;, &quot;purple&quot;);            &#125;);            $(&quot;div&quot;).mouseenter(function() &#123;                $(this).css(&quot;background&quot;, &quot;skyblue&quot;);            &#125;);        &#125;)    &lt;/script&gt;&lt;/body&gt;</code></pre><h2 id="1-2-jQuery-事件处理"><a href="#1-2-jQuery-事件处理" class="headerlink" title="1.2. jQuery 事件处理"></a>1.2. jQuery 事件处理</h2><pre><code>因为普通注册事件方法的不足，jQuery又开发了多个处理方法，重点讲解如下：</code></pre><ul><li>on(): 用于事件绑定，目前最好用的事件绑定方法</li><li>off(): 事件解绑</li><li>trigger() / triggerHandler(): 事件触发</li></ul><h3 id="1-2-1-事件处理-on-绑定事件"><a href="#1-2-1-事件处理-on-绑定事件" class="headerlink" title="1.2.1 事件处理 on() 绑定事件"></a>1.2.1 事件处理 on() 绑定事件</h3><pre><code>因为普通注册事件方法的不足，jQuery又创建了多个新的事件绑定方法bind() / live() / delegate() / on()等，其中最好用的是: on()</code></pre><p><strong>语法</strong><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616073493540-3a234b93-0493-427d-9113-4a801e391e60.png#align=left&display=inline&height=276&margin=%5Bobject%20Object%5D&originHeight=276&originWidth=620&status=done&style=none&width=620"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616073493614-d618db76-bdb5-4284-a6c3-433bf44340b2.png#align=left&display=inline&height=200&margin=%5Bobject%20Object%5D&originHeight=200&originWidth=620&status=done&style=none&width=620"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616073493684-be1891f4-c228-49eb-ac9d-47e233dafaad.png#align=left&display=inline&height=235&margin=%5Bobject%20Object%5D&originHeight=235&originWidth=620&status=done&style=none&width=620"><br><strong>演示代码</strong></p><pre><code class="javascript">&lt;body&gt;    &lt;div&gt;&lt;/div&gt;    &lt;ul&gt;        &lt;li&gt;我们都是好孩子&lt;/li&gt;        &lt;li&gt;我们都是好孩子&lt;/li&gt;        &lt;li&gt;我们都是好孩子&lt;/li&gt;    &lt;/ul&gt;    &lt;ol&gt;&lt;/ol&gt;    &lt;script&gt;        $(function() &#123;            // (1) on可以绑定1个或者多个事件处理程序            // $(&quot;div&quot;).on(&#123;            //     mouseenter: function() &#123;            //         $(this).css(&quot;background&quot;, &quot;skyblue&quot;);            //     &#125;,            //     click: function() &#123;            //         $(this).css(&quot;background&quot;, &quot;purple&quot;);            //     &#125;            // &#125;);            $(&quot;div&quot;).on(&quot;mouseenter mouseleave&quot;, function() &#123;                $(this).toggleClass(&quot;current&quot;);            &#125;);            // (2) on可以实现事件委托（委派）            // click 是绑定在ul 身上的，但是 触发的对象是 ul 里面的小li            // $(&quot;ul li&quot;).click();            $(&quot;ul&quot;).on(&quot;click&quot;, &quot;li&quot;, function() &#123;                alert(11);            &#125;);            // (3) on可以给未来动态创建的元素绑定事件            $(&quot;ol&quot;).on(&quot;click&quot;, &quot;li&quot;, function() &#123;                alert(11);            &#125;)            var li = $(&quot;&lt;li&gt;我是后来创建的&lt;/li&gt;&quot;);            $(&quot;ol&quot;).append(li);        &#125;)    &lt;/script&gt;&lt;/body&gt;</code></pre><h3 id="1-2-2-案例：发布微博案例"><a href="#1-2-2-案例：发布微博案例" class="headerlink" title="1.2.2. 案例：发布微博案例"></a>1.2.2. 案例：发布微博案例</h3><blockquote><p>1.点击发布按钮， 动态创建一个小 li，放入文本框的内容和删除按钮， 并且添加到 ul 中。 2.点击的删除按钮，可以删除当前的微博留言。</p></blockquote><pre><code>代码实现略。(详情参考源代码)</code></pre><h3 id="1-2-3-事件处理-off-解绑事件"><a href="#1-2-3-事件处理-off-解绑事件" class="headerlink" title="1.2.3. 事件处理 off() 解绑事件"></a>1.2.3. 事件处理 off() 解绑事件</h3><pre><code>当某个事件上面的逻辑，在特定需求下不需要的时候，可以把该事件上的逻辑移除，这个过程我们称为事件解绑。jQuery 为我们提供 了多种事件解绑方法：die() / undelegate() / off() 等，甚至还有只触发一次的事件绑定方法 one()，在这里我们重点讲解一下 off() ;</code></pre><p><strong>语法</strong><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616073493756-82ebfacb-9794-47bf-8776-6b7d80437782.png#align=left&display=inline&height=226&margin=%5Bobject%20Object%5D&originHeight=226&originWidth=620&status=done&style=none&width=620"><br><strong>演示代码</strong></p><pre><code class="javascript">&lt;body&gt;    &lt;div&gt;&lt;/div&gt;    &lt;ul&gt;        &lt;li&gt;我们都是好孩子&lt;/li&gt;        &lt;li&gt;我们都是好孩子&lt;/li&gt;        &lt;li&gt;我们都是好孩子&lt;/li&gt;    &lt;/ul&gt;    &lt;p&gt;我是一个P标签&lt;/p&gt;    &lt;script&gt;        $(function() &#123;              // 事件绑定            $(&quot;div&quot;).on(&#123;                click: function() &#123;                    console.log(&quot;我点击了&quot;);                &#125;,                mouseover: function() &#123;                    console.log(&#39;我鼠标经过了&#39;);                &#125;            &#125;);            $(&quot;ul&quot;).on(&quot;click&quot;, &quot;li&quot;, function() &#123;                alert(11);            &#125;);            // 1. 事件解绑 off            // $(&quot;div&quot;).off();  // 这个是解除了div身上的所有事件            $(&quot;div&quot;).off(&quot;click&quot;); // 这个是解除了div身上的点击事件            $(&quot;ul&quot;).off(&quot;click&quot;, &quot;li&quot;);            // 2. one() 但是它只能触发事件一次            $(&quot;p&quot;).one(&quot;click&quot;, function() &#123;                alert(11);            &#125;)        &#125;)    &lt;/script&gt;&lt;/body&gt;</code></pre><h3 id="1-2-4-事件处理-trigger-自动触发事件"><a href="#1-2-4-事件处理-trigger-自动触发事件" class="headerlink" title="1.2.4. 事件处理 trigger() 自动触发事件"></a>1.2.4. 事件处理 trigger() 自动触发事件</h3><pre><code>有些时候，在某些特定的条件下，我们希望某些事件能够自动触发, 比如轮播图自动播放功能跟点击右侧按钮一致。可以利用定时器自动触发右侧按钮点击事件，不必鼠标点击触发。由此 jQuery 为我们提供了两个自动触发事件 trigger() 和 triggerHandler() ;</code></pre><p><strong>语法</strong><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616073493822-a72c8dfb-7860-407e-b410-60c073ed48d7.png#align=left&display=inline&height=146&margin=%5Bobject%20Object%5D&originHeight=146&originWidth=620&status=done&style=none&width=620"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616073493901-f1048b8f-64aa-4cf6-98df-0ea9245e813e.png#align=left&display=inline&height=134&margin=%5Bobject%20Object%5D&originHeight=134&originWidth=620&status=done&style=none&width=620"><br><strong>演示代码</strong></p><pre><code class="javascript">&lt;body&gt;    &lt;div&gt;&lt;/div&gt;    &lt;input type=&quot;text&quot;&gt;    &lt;script&gt;    $(function() &#123;      // 绑定事件      $(&quot;div&quot;).on(&quot;click&quot;, function() &#123;        alert(11);      &#125;);      // 自动触发事件      // 1. 元素.事件()      // $(&quot;div&quot;).click();会触发元素的默认行为      // 2. 元素.trigger(&quot;事件&quot;)      // $(&quot;div&quot;).trigger(&quot;click&quot;);会触发元素的默认行为      $(&quot;input&quot;).trigger(&quot;focus&quot;);      // 3. 元素.triggerHandler(&quot;事件&quot;) 就是不会触发元素的默认行为      $(&quot;input&quot;).on(&quot;focus&quot;, function() &#123;        $(this).val(&quot;你好吗&quot;);      &#125;);      // 一个会获取焦点，一个不会      $(&quot;div&quot;).triggerHandler(&quot;click&quot;);      // $(&quot;input&quot;).triggerHandler(&quot;focus&quot;);    &#125;);    &lt;/script&gt;&lt;/body&gt;</code></pre><h2 id="1-3-jQuery-事件对象"><a href="#1-3-jQuery-事件对象" class="headerlink" title="1.3. jQuery 事件对象"></a>1.3. jQuery 事件对象</h2><pre><code>jQuery 对DOM中的事件对象 event 进行了封装，兼容性更好，获取更方便，使用变化不大。事件被触发，就会有事件对象的产生。</code></pre><p><strong>语法</strong><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616073493975-78588b8f-4bb7-4720-b637-d256b2831b0b.png#align=left&display=inline&height=121&margin=%5Bobject%20Object%5D&originHeight=121&originWidth=635&status=done&style=none&width=635"><br><strong>演示代码</strong></p><pre><code class="javascript">&lt;body&gt;    &lt;div&gt;&lt;/div&gt;    &lt;script&gt;        $(function() &#123;            $(document).on(&quot;click&quot;, function() &#123;                console.log(&quot;点击了document&quot;);            &#125;)            $(&quot;div&quot;).on(&quot;click&quot;, function(event) &#123;                // console.log(event);                console.log(&quot;点击了div&quot;);                event.stopPropagation();            &#125;)        &#125;)    &lt;/script&gt;&lt;/body&gt;</code></pre><p>注意：jQuery 中的 event 对象使用，可以借鉴 API 和 DOM 中的 event 。</p><h2 id="1-4-jQuery-拷贝对象"><a href="#1-4-jQuery-拷贝对象" class="headerlink" title="1.4. jQuery 拷贝对象"></a>1.4. jQuery 拷贝对象</h2><pre><code>jQuery中分别为我们提供了两套快速获取和设置元素尺寸和位置的API，方便易用，内容如下。</code></pre><p><strong>语法</strong><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616073494039-54be8373-5ba6-4c40-af84-3c6e7cd37d79.png#align=left&display=inline&height=274&margin=%5Bobject%20Object%5D&originHeight=274&originWidth=620&status=done&style=none&width=620"><br><strong>演示代码</strong></p><pre><code class="javascript">&lt;script&gt;        $(function() &#123;               // 1.合并数据            var targetObj = &#123;&#125;;            var obj = &#123;                id: 1,                name: &quot;andy&quot;            &#125;;            // $.extend(target, obj);            $.extend(targetObj, obj);            console.log(targetObj);               // 2. 会覆盖 targetObj 里面原来的数据            var targetObj = &#123;                id: 0            &#125;;            var obj = &#123;                id: 1,                name: &quot;andy&quot;            &#125;;            // $.extend(target, obj);            $.extend(targetObj, obj);            console.log(targetObj);        &#125;)    &lt;/script&gt;</code></pre><h2 id="1-5-jQuery-多库共存"><a href="#1-5-jQuery-多库共存" class="headerlink" title="1.5. jQuery 多库共存"></a>1.5. jQuery 多库共存</h2><pre><code>实际开发中，很多项目连续开发十多年，jQuery版本不断更新，最初的 jQuery 版本无法满足需求，这时就需要保证在旧有版本正常运行的情况下，新的功能使用新的jQuery版本实现，这种情况被称为，jQuery 多库共存。</code></pre><p><strong>语法</strong><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616073494111-229f7c73-4d09-4074-bd62-0da6a2f0db40.png#align=left&display=inline&height=112&margin=%5Bobject%20Object%5D&originHeight=112&originWidth=620&status=done&style=none&width=620"><br><strong>演示代码</strong></p><pre><code class="javascript">&lt;script&gt;    $(function() &#123;          // 让jquery 释放对$ 控制权 让用自己决定          var suibian = jQuery.noConflict();          console.log(suibian(&quot;span&quot;));    &#125;)&lt;/script&gt;</code></pre><h2 id="1-6-jQuery-插件"><a href="#1-6-jQuery-插件" class="headerlink" title="1.6. jQuery 插件"></a>1.6. jQuery 插件</h2><pre><code>jQuery 功能比较有限，想要更复杂的特效效果，可以借助于 jQuery 插件完成。 这些插件也是依赖于jQuery来完成的，所以必须要先引入</code></pre><p>jQuery 文件，因此也称为 jQuery 插件。<br>jQuery 插件常用的网站：</p><ol><li>jQuery 插件库 <a href="http://www.jq22.com/">http://www.jq22.com/</a></li><li>jQuery 之家 <a href="http://www.htmleaf.com/">http://www.htmleaf.com/</a></li></ol><p>jQuery 插件使用步骤：</p><ol start="3"><li>引入相关文件。（jQuery 文件 和 插件文件）</li><li>复制相关 html、css、js (调用插件)。</li></ol><h3 id="1-4-1-瀑布流插件（重点讲解）"><a href="#1-4-1-瀑布流插件（重点讲解）" class="headerlink" title="1.4.1. 瀑布流插件（重点讲解）"></a>1.4.1. 瀑布流插件（重点讲解）</h3><pre><code>我们学习的第一个插件是jQuery之家的开源插件，瀑布流。我们将重点详细讲解，从找到插件所在网页，然后点击下载代码，到插件的使用等，后面的插件使用可参考瀑布流插件的使用。</code></pre><p><strong>下载位置</strong><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616073494174-fb4a286c-0558-4af1-98d7-08102ae5bb99.png#align=left&display=inline&height=500&margin=%5Bobject%20Object%5D&originHeight=500&originWidth=1200&status=done&style=none&width=1200"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616073494257-d73dc383-f99b-465d-908e-703a4c023f36.png#align=left&display=inline&height=77&margin=%5Bobject%20Object%5D&originHeight=77&originWidth=318&status=done&style=none&width=318"><br><strong>代码演示</strong><br>插件的使用三点： 1. 引入 css. 2.引入 JS 3.引入 html。 （有的简单插件只需引入 html 和 js，甚至有的只需引入 js）</p><ul><li>1.引入 css.</li></ul><pre><code class="javascript">&lt;link rel=&quot;stylesheet&quot; href=&quot;css/normalize.css&quot;&gt;&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;css/default.css&quot;&gt;&lt;!-- 下面的样式代码为页面布局，可以引入，也可以自己写，自己设计页面样式，一般为直接引入，方便 --&gt;&lt;style type=&quot;text/css&quot;&gt;  #gallery-wrapper &#123;    position: relative;    max-width: 75%;    width: 75%;    margin: 50px auto;  &#125;  img.thumb &#123;    width: 100%;    max-width: 100%;    height: auto;  &#125;  .white-panel &#123;    position: absolute;    background: white;    border-radius: 5px;    box-shadow: 0px 1px 2px rgba(0, 0, 0, 0.3);    padding: 10px;  &#125;  .white-panel h1 &#123;    font-size: 1em;  &#125;  .white-panel h1 a &#123;    color: #A92733;  &#125;  .white-panel:hover &#123;    box-shadow: 1px 1px 10px rgba(0, 0, 0, 0.5);    margin-top: -5px;    -webkit-transition: all 0.3s ease-in-out;    -moz-transition: all 0.3s ease-in-out;    -o-transition: all 0.3s ease-in-out;    transition: all 0.3s ease-in-out;  &#125;&lt;/style&gt;</code></pre><ul><li>2.引入 js.</li></ul><pre><code class="javascript">&lt;!-- 前两个必须引入 --&gt;&lt;script src=&quot;js/jquery-1.11.0.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;js/pinterest_grid.js&quot;&gt;&lt;/script&gt;&lt;!-- 下面的为启动瀑布流代码，参数可调节属性，具体功能可参考readme.html --&gt;&lt;script type=&quot;text/javascript&quot;&gt;    $(function() &#123;      $(&quot;#gallery-wrapper&quot;).pinterest_grid(&#123;          no_columns: 5,          padding_x: 15,          padding_y: 10,          margin_bottom: 50,          single_column_breakpoint: 700      &#125;);    &#125;);&lt;/script&gt;</code></pre><ul><li>3.引入 html.</li></ul><pre><code class="javascript">&lt;!-- html结构一般为事先写好，很难修改结构，但可以修改内容及图片的多少（article标签） --&gt;    &lt;section id=&quot;gallery-wrapper&quot;&gt;        &lt;article class=&quot;white-panel&quot;&gt;            &lt;img src=&quot;images/P_000.jpg&quot; class=&quot;thumb&quot;&gt;            &lt;h1&gt;&lt;a href=&quot;#&quot;&gt;我是轮播图片1&lt;/a&gt;&lt;/h1&gt;            &lt;p&gt;里面很精彩哦&lt;/p&gt;        &lt;/article&gt;        &lt;article class=&quot;white-panel&quot;&gt;            &lt;img src=&quot;images/P_005.jpg&quot; class=&quot;thumb&quot;&gt;            &lt;h1&gt;&lt;a href=&quot;#&quot;&gt;我是轮播图片1&lt;/a&gt;&lt;/h1&gt;            &lt;p&gt;里面很精彩哦&lt;/p&gt;        &lt;/article&gt;        &lt;article class=&quot;white-panel&quot;&gt;            &lt;img src=&quot;images/P_006.jpg&quot; class=&quot;thumb&quot;&gt;            &lt;h1&gt;&lt;a href=&quot;#&quot;&gt;我是轮播图片1&lt;/a&gt;&lt;/h1&gt;            &lt;p&gt;里面很精彩哦&lt;/p&gt;        &lt;/article&gt;        &lt;article class=&quot;white-panel&quot;&gt;            &lt;img src=&quot;images/P_007.jpg&quot; class=&quot;thumb&quot;&gt;            &lt;h1&gt;&lt;a href=&quot;#&quot;&gt;我是轮播图片1&lt;/a&gt;&lt;/h1&gt;            &lt;p&gt;里面很精彩哦&lt;/p&gt;        &lt;/article&gt;    &lt;/section&gt;</code></pre><p>总结：jQuery 插件就是引入别人写好的：html 、css、js （有时也可以只引入一部分，读懂后也可以修改部分内容）</p><h3 id="1-4-2-图片懒加载插件"><a href="#1-4-2-图片懒加载插件" class="headerlink" title="1.4.2. 图片懒加载插件"></a>1.4.2. 图片懒加载插件</h3><pre><code>图片的懒加载就是：当页面滑动到有图片的位置，图片才进行加载，用以提升页面打开的速度及用户体验。（下载略）</code></pre><p><strong>代码演示</strong><br>懒加载只需引入 html 和 js 操作 即可，此插件不涉及 css。</p><ul><li>1.引入 js</li></ul><pre><code class="javascript">&lt;script src=&quot;js/EasyLazyload.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt;       lazyLoadInit(&#123;           showTime: 1100,           onLoadBackEnd: function(i, e) &#123;             console.log(&quot;onLoadBackEnd:&quot; + i);           &#125;,           onLoadBackStart: function(i, e) &#123;             console.log(&quot;onLoadBackStart:&quot; + i);           &#125;     &#125;);&lt;/script&gt;</code></pre><ul><li>2.引入 html</li></ul><pre><code class="javascript">&lt;img data-lazy-src=&quot;upload/floor-1-3.png&quot; alt=&quot;&quot;&gt;</code></pre><h3 id="1-4-3-全屏滚动插件"><a href="#1-4-3-全屏滚动插件" class="headerlink" title="1.4.3. 全屏滚动插件"></a>1.4.3. 全屏滚动插件</h3><pre><code>全屏滚动插件比较大，所以，一般大型插件都会有帮助文档，或者网站。全屏滚动插件介绍比较详细的网站为：</code></pre><p><a href="http://www.dowebok.com/demo/2014/77/">http://www.dowebok.com/demo/2014/77/</a><br><strong>代码演示</strong><br>全屏滚动因为有多重形式，所以不一样的风格 html 和 css 也不一样，但是 js 变化不大。所以下面只演示 js 的引入，html 和 css 引入根据自己实际<br>项目需要使用哪种风格引入对应的 HTML 和 CSS。</p><pre><code class="javascript">&lt;script src=&quot;js/jquery.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;js/fullpage.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt;      $(function() &#123;          $(&#39;#dowebok&#39;).fullpage(&#123;            sectionsColor: [&#39;pink&#39;, &#39;#4BBFC3&#39;, &#39;#7BAABE&#39;, &#39;#f90&#39;],            navigation: true          &#125;);    &#125;);&lt;/script&gt;</code></pre><p>注意：实际开发，一般复制文件，然后在文件中进行修改和添加功能。</p><h3 id="1-4-4-bootstrap-组件"><a href="#1-4-4-bootstrap-组件" class="headerlink" title="1.4.4. bootstrap 组件"></a>1.4.4. bootstrap 组件</h3><pre><code>Bootstrap是 Twitter 公司设计的基于HTML、CSS、JavaScript开发的简洁、直观、强悍的前端开发框架，他依靠jQuery实现，且支持响应式</code></pre><p>布局，使得 Web 开发更加方便快捷。<br><strong>凡是在软件开发中用到了软件的复用，被复用的部分都可以称为组件，凡是在应用程序中已经预留接口的组件就是插件</strong>。Bootstrap 组件使<br>用非常方便: 1.引入 bootstrap 相关 css 和 js 2.去官网复制 html<br><strong>代码演示</strong></p><ol><li>引入 bootstrap 相关 css 和 js</li></ol><pre><code class="javascript">&lt;link rel=&quot;stylesheet&quot; href=&quot;bootstrap/css/bootstrap.min.css&quot;&gt;&lt;script src=&quot;bootstrap/js/jquery.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;bootstrap/js/bootstrap.min.js&quot;&gt;&lt;/script&gt;</code></pre><ol start="2"><li>去官网复制 html 的功能模块</li></ol><pre><code class="javascript">&lt;div class=&quot;container&quot;&gt;        &lt;!-- Single button --&gt;        &lt;div class=&quot;btn-group&quot;&gt;            &lt;button type=&quot;button&quot; class=&quot;btn btn-default dropdown-toggle&quot; data-toggle=&quot;dropdown&quot; aria-haspopup=&quot;true&quot; aria-expanded=&quot;false&quot;&gt;              Action &lt;span class=&quot;caret&quot;&gt;&lt;/span&gt;            &lt;/button&gt;            &lt;ul class=&quot;dropdown-menu&quot;&gt;                &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Action&lt;/a&gt;&lt;/li&gt;                &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Another action&lt;/a&gt;&lt;/li&gt;                &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Something else here&lt;/a&gt;&lt;/li&gt;                &lt;li role=&quot;separator&quot; class=&quot;divider&quot;&gt;&lt;/li&gt;                &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Separated link&lt;/a&gt;&lt;/li&gt;            &lt;/ul&gt;         &lt;/div&gt;    &lt;/div&gt;</code></pre><h3 id="1-4-5-bootstrap-插件（JS）"><a href="#1-4-5-bootstrap-插件（JS）" class="headerlink" title="1.4.5. bootstrap 插件（JS）"></a>1.4.5. bootstrap 插件（JS）</h3><pre><code>bootstrap中的js插件其实也是组件的一部分，只不过是需要js调用功能的组件，所以一般bootstrap的js插件一般会伴随着js代码（有的也可以</code></pre><p>省略 js，用属性实现）。<br>步骤： 1.引入 bootstrap 相关 css 和 js 2.去官网复制 html 3.复制 js 代码，启动 js 插件。<br><strong>代码演示</strong></p><ol><li>引入 bootstrap 相关 css 和 js</li></ol><pre><code class="javascript">&lt;link rel=&quot;stylesheet&quot; href=&quot;bootstrap/css/bootstrap.min.css&quot;&gt;&lt;script src=&quot;bootstrap/js/jquery.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;bootstrap/js/bootstrap.min.js&quot;&gt;&lt;/script&gt;</code></pre><ol start="2"><li>去官网复制 html 的功能模块</li></ol><pre><code class="javascript">&lt;!-- 模态框 --&gt;&lt;!-- Large modal --&gt;&lt;button type=&quot;button&quot; class=&quot;btn btn-primary&quot; data-toggle=&quot;modal&quot; data-target=&quot;.bs-example-modal-lg&quot;&gt;Large modal&lt;/button&gt;&lt;div class=&quot;modal fade bs-example-modal-lg&quot; tabindex=&quot;-1&quot; role=&quot;dialog&quot; aria-labelledby=&quot;myLargeModalLabel&quot;&gt;    &lt;div class=&quot;modal-dialog modal-lg&quot; role=&quot;document&quot;&gt;        &lt;div class=&quot;modal-content&quot;&gt;            里面就是模态框        &lt;/div&gt;    &lt;/div&gt;&lt;/div&gt;</code></pre><ol start="3"><li>复制 js 代码，启动 js 插件。</li></ol><pre><code class="javascript">&lt;script&gt;  // 当我们点击了自己定义的按钮，就弹出模态框 $(&quot;.myBtn&quot;).on(&quot;click&quot;, function()&#123;&quot; &quot;&#125;  &#123;    // alert(11);    $(&quot;#btn&quot;).modal()  &#125;  )&lt;/script&gt;</code></pre><h3 id="1-4-6-bootstrap-案例-阿里百秀"><a href="#1-4-6-bootstrap-案例-阿里百秀" class="headerlink" title="1.4.6. bootstrap 案例-阿里百秀"></a>1.4.6. bootstrap 案例-阿里百秀</h3><blockquote><p>1.通过调用组件实现导航栏 2.通过调用插件实现登录 3.通过调用插件标签页实现 tab 栏</p></blockquote><pre><code>代码实现略。(详情参考源代码)</code></pre><h2 id="1-7-综合案例-toDoList-案例分析（代码略）"><a href="#1-7-综合案例-toDoList-案例分析（代码略）" class="headerlink" title="1.7. 综合案例: toDoList 案例分析（代码略）"></a>1.7. 综合案例: toDoList 案例分析（代码略）</h2><h3 id="1-7-1-案例：案例介绍"><a href="#1-7-1-案例：案例介绍" class="headerlink" title="1.7.1 案例：案例介绍"></a>1.7.1 案例：案例介绍</h3><pre><code class="javascript">// 1. 文本框里面输入内容，按下回车，就可以生成待办事项。// 2. 点击待办事项复选框，就可以把当前数据添加到已完成事项里面。// 3. 点击已完成事项复选框，就可以把当前数据添加到待办事项里面。// 4. 但是本页面内容刷新页面不会丢失。</code></pre><h3 id="1-7-2-案例：toDoList-分析"><a href="#1-7-2-案例：toDoList-分析" class="headerlink" title="1.7.2 案例：toDoList 分析"></a>1.7.2 案例：toDoList 分析</h3><pre><code class="javascript">// 1. 刷新页面不会丢失数据，因此需要用到本地存储 localStorage// 2. 核心思路： 不管按下回车，还是点击复选框，都是把本地存储的数据加载到页面中，这样保证刷新关闭页面不会丢失数据// 3. 存储的数据格式：var todolist =  [&#123; title : ‘xxx’, done: false&#125;]// 4. 注意点1： 本地存储 localStorage 里面只能存储字符串格式 ，因此需要把对象转换为字符串 JSON.stringify(data)。// 5. 注意点2： 获取本地存储数据，需要把里面的字符串转换为对象格式JSON.parse() 我们才能使用里面的数据。</code></pre><h3 id="1-7-3-案例：toDoList-按下回车把新数据添加到本地存储里面"><a href="#1-7-3-案例：toDoList-按下回车把新数据添加到本地存储里面" class="headerlink" title="1.7.3 案例：toDoList 按下回车把新数据添加到本地存储里面"></a>1.7.3 案例：toDoList 按下回车把新数据添加到本地存储里面</h3><pre><code class="javascript">// 1.切记： 页面中的数据，都要从本地存储里面获取，这样刷新页面不会丢失数据，所以先要把数据保存到本地存储里面。// 2.利用事件对象.keyCode判断用户按下回车键（13）。// 3.声明一个数组，保存数据。// 4.先要读取本地存储原来的数据（声明函数 getData()），放到这个数组里面。// 5.之后把最新从表单获取过来的数据，追加到数组里面。// 6.最后把数组存储给本地存储 (声明函数 savaDate())</code></pre><h3 id="1-7-4-案例：toDoList-本地存储数据渲染加载到页面"><a href="#1-7-4-案例：toDoList-本地存储数据渲染加载到页面" class="headerlink" title="1.7.4 案例：toDoList 本地存储数据渲染加载到页面"></a>1.7.4 案例：toDoList 本地存储数据渲染加载到页面</h3><pre><code class="javascript">// 1.因为后面也会经常渲染加载操作，所以声明一个函数 load，方便后面调用// 2.先要读取本地存储数据。（数据不要忘记转换为对象格式）// 3.之后遍历这个数据（$.each()），有几条数据，就生成几个小li 添加到 ol 里面。// 4.每次渲染之前，先把原先里面 ol 的内容清空，然后渲染加载最新的数据。</code></pre><h3 id="1-7-5-案例：toDoList-删除操作"><a href="#1-7-5-案例：toDoList-删除操作" class="headerlink" title="1.7.5 案例：toDoList 删除操作"></a>1.7.5 案例：toDoList 删除操作</h3><pre><code class="javascript">// 1.点击里面的a链接，不是删除的li，而是删除本地存储对应的数据。// 2.核心原理：先获取本地存储数据，删除对应的数据，保存给本地存储，重新渲染列表li// 3.我们可以给链接自定义属性记录当前的索引号// 4.根据这个索引号删除相关的数据----数组的splice(i, 1)方法// 5.存储修改后的数据，然后存储给本地存储// 6.重新渲染加载数据列表// 7.因为a是动态创建的，我们使用on方法绑定事件</code></pre><h3 id="1-7-6-案例：toDoList-正在进行和已完成选项操作"><a href="#1-7-6-案例：toDoList-正在进行和已完成选项操作" class="headerlink" title="1.7.6 案例：toDoList 正在进行和已完成选项操作"></a>1.7.6 案例：toDoList 正在进行和已完成选项操作</h3><pre><code class="javascript">// 1.当我们点击了小的复选框，修改本地存储数据，再重新渲染数据列表。// 2.点击之后，获取本地存储数据。// 3.修改对应数据属性 done 为当前复选框的checked状态。// 4.之后保存数据到本地存储// 5.重新渲染加载数据列表// 6.load 加载函数里面，新增一个条件,如果当前数据的done为true 就是已经完成的，就把列表渲染加载到 ul 里面// 7.如果当前数据的done 为false， 则是待办事项，就把列表渲染加载到 ol 里面</code></pre><h3 id="1-7-7-案例：toDoList-统计正在进行个数和已经完成个数"><a href="#1-7-7-案例：toDoList-统计正在进行个数和已经完成个数" class="headerlink" title="1.7.7 案例：toDoList 统计正在进行个数和已经完成个数"></a>1.7.7 案例：toDoList 统计正在进行个数和已经完成个数</h3><pre><code class="javascript">// 1.在我们load 函数里面操作// 2.声明2个变量 ：todoCount 待办个数  doneCount 已完成个数// 3.当进行遍历本地存储数据的时候， 如果 数据done为 false， 则 todoCount++, 否则 doneCount++// 4.最后修改相应的元素 text()</code></pre><h2 id="1-8-今日总结"><a href="#1-8-今日总结" class="headerlink" title="1.8. 今日总结"></a>1.8. 今日总结</h2><p><img src="images/%E6%80%BB%E7%BB%93.png#"></p>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
          <category> jQuery </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>jQuery2</title>
      <link href="blog/2_day02_jquery/"/>
      <url>blog/2_day02_jquery/</url>
      
        <content type="html"><![CDATA[<p>学习目标：</p><blockquote><p>能够操作 jQuery 属性<br>能够操作 jQuery 元素<br>能够操作 jQuery 元素尺寸、位置</p></blockquote><h2 id="1-1-jQuery-属性操作"><a href="#1-1-jQuery-属性操作" class="headerlink" title="1.1. jQuery 属性操作"></a>1.1. jQuery 属性操作</h2><pre><code>jQuery 常用属性操作有三种：prop() / attr() / data() ;</code></pre><h3 id="1-1-1-元素固有属性值-prop"><a href="#1-1-1-元素固有属性值-prop" class="headerlink" title="1.1.1 元素固有属性值 prop()"></a>1.1.1 元素固有属性值 prop()</h3><pre><code>所谓元素固有属性就是元素本身自带的属性，比如 [ 元素里面的 href ，比如  元素里面的 type。]()</code></pre><p><strong>语法</strong><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616073492194-d6d9ff5b-5c98-495b-bebb-c3be7790bbf4.png#align=left&display=inline&height=185&margin=%5Bobject%20Object%5D&originHeight=185&originWidth=619&status=done&style=none&width=619"><br>注意：prop() 除了普通属性操作，更适合操作表单属性：disabled / checked / selected 等。</p><h3 id="1-1-2-元素自定义属性值-attr"><a href="#1-1-2-元素自定义属性值-attr" class="headerlink" title="1.1.2 元素自定义属性值 attr()"></a>1.1.2 元素自定义属性值 attr()</h3><pre><code>用户自己给元素添加的属性，我们称为自定义属性。 比如给 div 添加 index =“1”。</code></pre><p><strong>语法</strong><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616073492261-f36c35ad-cba6-4c24-ac2d-18781c30b41a.png#align=left&display=inline&height=231&margin=%5Bobject%20Object%5D&originHeight=231&originWidth=616&status=done&style=none&width=616"><br>注意：attr() 除了普通属性操作，更适合操作自定义属性。（该方法也可以获取 H5 自定义属性）</p><h3 id="1-1-3-数据缓存-data"><a href="#1-1-3-数据缓存-data" class="headerlink" title="1.1.3 数据缓存 data()"></a>1.1.3 数据缓存 data()</h3><pre><code>data() 方法可以在指定的元素上存取数据，并不会修改 DOM 元素结构。一旦页面刷新，之前存放的数据都将被移除。</code></pre><p><strong>语法</strong><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616073492334-8d7a046e-854f-4449-a169-2820244ff75f.png#align=left&display=inline&height=169&margin=%5Bobject%20Object%5D&originHeight=169&originWidth=616&status=done&style=none&width=616"><br>注意：同时，还可以读取 HTML5 自定义属性 data-index ，得到的是数字型。<br><strong>演示代码</strong></p><pre><code class="javascript">&lt;body&gt;    &lt;a href=&quot;http://www.itcast.cn&quot; title=&quot;都挺好&quot;&gt;都挺好&lt;/a&gt;    &lt;input type=&quot;checkbox&quot; name=&quot;&quot; id=&quot;&quot; checked&gt;    &lt;div index=&quot;1&quot; data-index=&quot;2&quot;&gt;我是div&lt;/div&gt;    &lt;span&gt;123&lt;/span&gt;    &lt;script&gt;        $(function() &#123;            //1. element.prop(&quot;属性名&quot;) 获取元素固有的属性值            console.log($(&quot;a&quot;).prop(&quot;href&quot;));            $(&quot;a&quot;).prop(&quot;title&quot;, &quot;我们都挺好&quot;);            $(&quot;input&quot;).change(function() &#123;                console.log($(this).prop(&quot;checked&quot;));            &#125;);            // console.log($(&quot;div&quot;).prop(&quot;index&quot;));            // 2. 元素的自定义属性 我们通过 attr()            console.log($(&quot;div&quot;).attr(&quot;index&quot;));            $(&quot;div&quot;).attr(&quot;index&quot;, 4);            console.log($(&quot;div&quot;).attr(&quot;data-index&quot;));            // 3. 数据缓存 data() 这个里面的数据是存放在元素的内存里面            $(&quot;span&quot;).data(&quot;uname&quot;, &quot;andy&quot;);            console.log($(&quot;span&quot;).data(&quot;uname&quot;));            // 这个方法获取data-index h5自定义属性 第一个 不用写data-  而且返回的是数字型            console.log($(&quot;div&quot;).data(&quot;index&quot;));        &#125;)    &lt;/script&gt;&lt;/body&gt;</code></pre><h3 id="1-1-4-案例：购物车案例模块-全选"><a href="#1-1-4-案例：购物车案例模块-全选" class="headerlink" title="1.1.4 案例：购物车案例模块-全选"></a>1.1.4 案例：购物车案例模块-全选</h3><blockquote><p>1.全选思路：里面 3 个小的复选框按钮（j-checkbox）选中状态（checked）跟着全选按钮（checkall）走。 2.因为 checked 是复选框的固有属性，此时我们需要利用 prop()方法获取和设置该属性。 3.把全选按钮状态赋值给 3 小复选框就可以了。 4.当我们每次点击小的复选框按钮，就来判断： 5.如果小复选框被选中的个数等于 3 就应该把全选按钮选上，否则全选按钮不选。<br>6.:checked 选择器 :checked 查找被选中的表单元素。</p></blockquote><pre><code>代码实现略。(详情参考源代码)</code></pre><h2 id="1-2-jQuery-文本属性值"><a href="#1-2-jQuery-文本属性值" class="headerlink" title="1.2. jQuery 文本属性值"></a>1.2. jQuery 文本属性值</h2><pre><code>jQuery的文本属性值常见操作有三种：html() / text() / val() ; 分别对应JS中的 innerHTML 、innerText 和 value 属性。</code></pre><h3 id="1-2-1-jQuery-内容文本值"><a href="#1-2-1-jQuery-内容文本值" class="headerlink" title="1.2.1 jQuery 内容文本值"></a>1.2.1 jQuery 内容文本值</h3><pre><code>常见操作有三种：html() / text() / val() ; 分别对应JS中的 innerHTML 、innerText 和 value 属性，主要针对元素的内容还有表单的值操作。</code></pre><p><strong>语法</strong><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616073492400-d8ee58ad-1d5e-42a0-a07f-52d7558fb341.png#align=left&display=inline&height=425&margin=%5Bobject%20Object%5D&originHeight=425&originWidth=663&status=done&style=none&width=663"><br>注意：html() 可识别标签，text() 不识别标签。<br><strong>演示代码</strong></p><pre><code class="javascript">&lt;body&gt;    &lt;div&gt;        &lt;span&gt;我是内容&lt;/span&gt;    &lt;/div&gt;    &lt;input type=&quot;text&quot; value=&quot;请输入内容&quot;&gt;    &lt;script&gt;        // 1. 获取设置元素内容 html()        console.log($(&quot;div&quot;).html());        // $(&quot;div&quot;).html(&quot;123&quot;);        // 2. 获取设置元素文本内容 text()        console.log($(&quot;div&quot;).text());        $(&quot;div&quot;).text(&quot;123&quot;);        // 3. 获取设置表单值 val()        console.log($(&quot;input&quot;).val());        $(&quot;input&quot;).val(&quot;123&quot;);    &lt;/script&gt;&lt;/body&gt;</code></pre><h3 id="1-2-2-案例：购物车案例模块-增减商品数量"><a href="#1-2-2-案例：购物车案例模块-增减商品数量" class="headerlink" title="1.2.2. 案例：购物车案例模块-增减商品数量"></a>1.2.2. 案例：购物车案例模块-增减商品数量</h3><blockquote><p>1.核心思路：首先声明一个变量，当我们点击+号（increment），就让这个值++，然后赋值给文本框。 2.注意 1： 只能增加本商品的数量， 就是当前+号的兄弟文本框（itxt）的值。 3.修改表单的值是 val() 方法 4.注意 2： 这个变量初始值应该是这个文本框的值，在这个值的基础上++。要获取表单的值 5.减号（decrement）思路同理，但是如果文本框的值是 1，就不能再减了。</p></blockquote><pre><code>代码实现略。(详情参考源代码)</code></pre><h3 id="1-2-3-案例：购物车案例模块-修改商品小计"><a href="#1-2-3-案例：购物车案例模块-修改商品小计" class="headerlink" title="1.2.3. 案例：购物车案例模块-修改商品小计"></a>1.2.3. 案例：购物车案例模块-修改商品小计</h3><blockquote><p>1.核心思路：每次点击+号或者-号，根据文本框的值 乘以 当前商品的价格 就是 商品的小计 2.注意 1： 只能增加本商品的小计， 就是当前商品的小计模块（p-sum） 3.修改普通元素的内容是 text() 方法 4.注意 2： 当前商品的价格，要把￥符号去掉再相乘 截取字符串 substr(1)<br>5.parents(‘选择器’) 可以返回指定祖先元素 6.最后计算的结果如果想要保留 2 位小数 通过 toFixed(2) 方法 7.用户也可以直接修改表单里面的值，同样要计算小计。 用表单 change 事件 8.用最新的表单内的值 乘以 单价即可 但是还是当前商品小计</p></blockquote><pre><code>代码实现略。(详情参考源代码)</code></pre><h2 id="1-3-jQuery-元素操作"><a href="#1-3-jQuery-元素操作" class="headerlink" title="1.3. jQuery 元素操作"></a>1.3. jQuery 元素操作</h2><pre><code>jQuery 元素操作主要讲的是用jQuery方法，操作标签的遍历、创建、添加、删除等操作。</code></pre><h3 id="1-3-1-遍历元素"><a href="#1-3-1-遍历元素" class="headerlink" title="1.3.1. 遍历元素"></a>1.3.1. 遍历元素</h3><pre><code>jQuery 隐式迭代是对同一类元素做了同样的操作。 如果想要给同一类元素做不同操作，就需要用到遍历。</code></pre><p><strong>语法 1</strong><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616073492472-0f31ef63-133b-40cf-b438-391dde571eb4.png#align=left&display=inline&height=177&margin=%5Bobject%20Object%5D&originHeight=177&originWidth=622&status=done&style=none&width=622"><br>注意：此方法用于遍历 jQuery 对象中的每一项，回调函数中元素为 DOM 对象，想要使用 jQuery 方法需要转换。<br><strong>语法 2</strong><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616073492553-9c2ac31d-49a0-4e91-bf4e-d2279e74ff32.png#align=left&display=inline&height=146&margin=%5Bobject%20Object%5D&originHeight=146&originWidth=617&status=done&style=none&width=617"><br>注意：此方法用于遍历 jQuery 对象中的每一项，回调函数中元素为 DOM 对象，想要使用 jQuery 方法需要转换。<br><strong>演示代码</strong></p><pre><code class="javascript">&lt;body&gt;    &lt;div&gt;1&lt;/div&gt;    &lt;div&gt;2&lt;/div&gt;    &lt;div&gt;3&lt;/div&gt;    &lt;script&gt;        $(function() &#123;            // 如果针对于同一类元素做不同操作，需要用到遍历元素（类似for，但是比for强大）            var sum = 0;            var arr = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;];            // 1. each() 方法遍历元素            $(&quot;div&quot;).each(function(i, domEle) &#123;                // 回调函数第一个参数一定是索引号  可以自己指定索引号号名称                // console.log(i);                // 回调函数第二个参数一定是 dom 元素对象，也是自己命名                // console.log(domEle);  // 使用jQuery方法需要转换 $(domEle)                $(domEle).css(&quot;color&quot;, arr[i]);                sum += parseInt($(domEle).text());            &#125;)            console.log(sum);            // 2. $.each() 方法遍历元素 主要用于遍历数据，处理数据            // $.each($(&quot;div&quot;), function(i, ele) &#123;            //     console.log(i);            //     console.log(ele);            // &#125;);            // $.each(arr, function(i, ele) &#123;            //     console.log(i);            //     console.log(ele);            // &#125;)            $.each(&#123;                name: &quot;andy&quot;,                age: 18            &#125;, function(i, ele) &#123;                console.log(i); // 输出的是 name age 属性名                console.log(ele); // 输出的是 andy  18 属性值            &#125;)        &#125;)    &lt;/script&gt;&lt;/body&gt;</code></pre><h3 id="1-3-2-案例：购物车案例模块-计算总计和总额"><a href="#1-3-2-案例：购物车案例模块-计算总计和总额" class="headerlink" title="1.3.2. 案例：购物车案例模块-计算总计和总额"></a>1.3.2. 案例：购物车案例模块-计算总计和总额</h3><blockquote><p>1.把所有文本框中的值相加就是总额数量，总计同理。 2.文本框里面的值不同，如果想要相加需要用 each() 遍历，声明一个变量做计数器，累加即可。</p></blockquote><pre><code>代码实现略。(详情参考源代码)</code></pre><h3 id="1-3-3-创建、添加、删除"><a href="#1-3-3-创建、添加、删除" class="headerlink" title="1.3.3. 创建、添加、删除"></a>1.3.3. 创建、添加、删除</h3><pre><code>jQuery方法操作元素的创建、添加、删除方法很多，则重点使用部分，如下：</code></pre><p><strong>语法总和</strong><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616073492632-06694ce7-f376-454f-9c85-c4f7a0ba0338.png#align=left&display=inline&height=115&margin=%5Bobject%20Object%5D&originHeight=115&originWidth=624&status=done&style=none&width=624"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616073492709-dbf5e1ae-fcee-4283-8cc2-5ecb0bcc1b83.png#align=left&display=inline&height=206&margin=%5Bobject%20Object%5D&originHeight=206&originWidth=623&status=done&style=none&width=623"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616073492783-28f74b87-b629-477d-9ca2-47e4588c4b96.png#align=left&display=inline&height=208&margin=%5Bobject%20Object%5D&originHeight=208&originWidth=621&status=done&style=none&width=621"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616073492861-e9f292d0-aaf9-4b05-b013-77a589f3bf2a.png#align=left&display=inline&height=230&margin=%5Bobject%20Object%5D&originHeight=230&originWidth=625&status=done&style=none&width=625"><br>注意：以上只是元素的创建、添加、删除方法的常用方法，其他方法请参详 API。<br><strong>案例代码</strong></p><pre><code class="js">&lt;body&gt;    &lt;ul&gt;        &lt;li&gt;原先的li&lt;/li&gt;    &lt;/ul&gt;    &lt;div class=&quot;test&quot;&gt;我是原先的div&lt;/div&gt;    &lt;script&gt;        $(function() &#123;            // 1. 创建元素            var li = $(&quot;&lt;li&gt;我是后来创建的li&lt;/li&gt;&quot;);            // 2. 添加元素            //     2.1 内部添加            // $(&quot;ul&quot;).append(li);  内部添加并且放到内容的最后面            $(&quot;ul&quot;).prepend(li); // 内部添加并且放到内容的最前面            //  2.2 外部添加            var div = $(&quot;&lt;div&gt;我是后妈生的&lt;/div&gt;&quot;);            // $(&quot;.test&quot;).after(div);            $(&quot;.test&quot;).before(div);            // 3. 删除元素            // $(&quot;ul&quot;).remove(); 可以删除匹配的元素 自杀            // $(&quot;ul&quot;).empty(); // 可以删除匹配的元素里面的子节点 孩子            $(&quot;ul&quot;).html(&quot;&quot;); // 可以删除匹配的元素里面的子节点 孩子        &#125;)    &lt;/script&gt;&lt;/body&gt;</code></pre><h3 id="1-3-4-案例：购物车案例模块-删除商品模块"><a href="#1-3-4-案例：购物车案例模块-删除商品模块" class="headerlink" title="1.3.4 案例：购物车案例模块-删除商品模块"></a>1.3.4 案例：购物车案例模块-删除商品模块</h3><blockquote><p>1.核心思路：把商品 remove() 删除元素即可 2.有三个地方需要删除： 1. 商品后面的删除按钮 2. 删除选中的商品 3. 清理购物车 3.商品后面的删除按钮： 一定是删除当前的商品，所以从 $(this) 出发 4.删除选中的商品： 先判断小的复选框按钮是否选中状态，如果是选中，则删除对应的商品 5.清理购物车： 则是把所有的商品全部删掉</p></blockquote><pre><code>代码实现略。(详情参考源代码)</code></pre><h3 id="1-3-5-案例：购物车案例模块-选中商品添加背景"><a href="#1-3-5-案例：购物车案例模块-选中商品添加背景" class="headerlink" title="1.3.5 案例：购物车案例模块-选中商品添加背景"></a>1.3.5 案例：购物车案例模块-选中商品添加背景</h3><blockquote><p>1.核心思路：选中的商品添加背景，不选中移除背景即可 2.全选按钮点击：如果全选是选中的，则所有的商品添加背景，否则移除背景 3.小的复选框点击： 如果是选中状态，则当前商品添加背景，否则移除背景 4.这个背景，可以通过类名修改，添加类和删除类</p></blockquote><pre><code>代码实现略。(详情参考源代码)</code></pre><h2 id="1-4-jQuery-尺寸、位置操作"><a href="#1-4-jQuery-尺寸、位置操作" class="headerlink" title="1.4. jQuery 尺寸、位置操作"></a>1.4. jQuery 尺寸、位置操作</h2><pre><code>jQuery中分别为我们提供了两套快速获取和设置元素尺寸和位置的API，方便易用，内容如下。</code></pre><h3 id="1-4-1-jQuery-尺寸操作"><a href="#1-4-1-jQuery-尺寸操作" class="headerlink" title="1.4.1. jQuery 尺寸操作"></a>1.4.1. jQuery 尺寸操作</h3><pre><code> jQuery 尺寸操作包括元素宽高的获取和设置，且不一样的API对应不一样的盒子模型。</code></pre><p><strong>语法</strong><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616073492939-79b5b959-2700-496c-adb0-d049e25f6490.png#align=left&display=inline&height=260&margin=%5Bobject%20Object%5D&originHeight=260&originWidth=629&status=done&style=none&width=629"><br><strong>代码演示</strong></p><pre><code class="javascript">&lt;body&gt;    &lt;div&gt;&lt;/div&gt;    &lt;script&gt;        $(function() &#123;            // 1. width() / height() 获取设置元素 width和height大小            console.log($(&quot;div&quot;).width());            // $(&quot;div&quot;).width(300);            // 2. innerWidth() / innerHeight()  获取设置元素 width和height + padding 大小            console.log($(&quot;div&quot;).innerWidth());            // 3. outerWidth()  / outerHeight()  获取设置元素 width和height + padding + border 大小            console.log($(&quot;div&quot;).outerWidth());            // 4. outerWidth(true) / outerHeight(true) 获取设置 width和height + padding + border + margin            console.log($(&quot;div&quot;).outerWidth(true));        &#125;)    &lt;/script&gt;&lt;/body&gt;</code></pre><pre><code>注意：有了这套 API 我们将可以快速获取和子的宽高，至于其他属性想要获取和设置，还要使用 css() 等方法配合。</code></pre><h3 id="1-4-2-jQuery-位置操作"><a href="#1-4-2-jQuery-位置操作" class="headerlink" title="1.4.2. jQuery 位置操作"></a>1.4.2. jQuery 位置操作</h3><pre><code>jQuery的位置操作主要有三个： offset()、position()、scrollTop()/scrollLeft() , 具体介绍如下:</code></pre><p><strong>语法</strong><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616073493024-1b363784-6614-4dd9-8ddc-dd97531a3cb6.png#align=left&display=inline&height=129&margin=%5Bobject%20Object%5D&originHeight=129&originWidth=663&status=done&style=none&width=663"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616073493095-d18b82ae-83d0-465b-bf27-4fb9449ee6c6.png#align=left&display=inline&height=151&margin=%5Bobject%20Object%5D&originHeight=151&originWidth=663&status=done&style=none&width=663"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616073493171-f3d23a41-7256-4fe7-9818-1624a3ab45ce.png#align=left&display=inline&height=100&margin=%5Bobject%20Object%5D&originHeight=100&originWidth=663&status=done&style=none&width=663"><br><strong>代码演示</strong></p><pre><code class="javascript">&lt;body&gt;    &lt;div class=&quot;father&quot;&gt;        &lt;div class=&quot;son&quot;&gt;&lt;/div&gt;    &lt;/div&gt;    &lt;div class=&quot;back&quot;&gt;返回顶部&lt;/div&gt;    &lt;div class=&quot;container&quot;&gt;&lt;/div&gt;    &lt;script&gt;        $(function() &#123;            // 1. 获取设置距离文档的位置（偏移） offset            console.log($(&quot;.son&quot;).offset());            console.log($(&quot;.son&quot;).offset().top);            // $(&quot;.son&quot;).offset(&#123;            //     top: 200,            //     left: 200            // &#125;);            // 2. 获取距离带有定位父级位置（偏移） position   如果没有带有定位的父级，则以文档为准            // 这个方法只能获取不能设置偏移            console.log($(&quot;.son&quot;).position());            // $(&quot;.son&quot;).position(&#123;            //     top: 200,            //     left: 200            // &#125;);              // 3. 被卷去的头部              $(document).scrollTop(100);            // 被卷去的头部 scrollTop()  / 被卷去的左侧 scrollLeft()            // 页面滚动事件            var boxTop = $(&quot;.container&quot;).offset().top;            $(window).scroll(function() &#123;                // console.log(11);                console.log($(document).scrollTop());                if ($(document).scrollTop() &gt;= boxTop) &#123;                    $(&quot;.back&quot;).fadeIn();                &#125; else &#123;                    $(&quot;.back&quot;).fadeOut();                &#125;            &#125;);            // 返回顶部            $(&quot;.back&quot;).click(function() &#123;                // $(document).scrollTop(0);                $(&quot;body, html&quot;).stop().animate(&#123;                    scrollTop: 0                &#125;);                // $(document).stop().animate(&#123;                //     scrollTop: 0                // &#125;); 不能是文档而是 html和body元素做动画            &#125;)        &#125;)    &lt;/script&gt;&lt;/body&gt;</code></pre><h3 id="1-4-3-案例：带有动画的返回顶部"><a href="#1-4-3-案例：带有动画的返回顶部" class="headerlink" title="1.4.3. 案例：带有动画的返回顶部"></a>1.4.3. 案例：带有动画的返回顶部</h3><blockquote><p>1.核心原理： 使用 animate 动画返回顶部。<br>2.animate 动画函数里面有个 scrollTop 属性，可以设置位置 3.但是是元素做动画，因此 $(“body,html”).animate({scrollTop: 0})</p></blockquote><pre><code>代码实现略。(详情参考源代码)</code></pre><h3 id="1-4-4-案例：-品优购电梯导航（上）"><a href="#1-4-4-案例：-品优购电梯导航（上）" class="headerlink" title="1.4.4. 案例： 品优购电梯导航（上）"></a>1.4.4. 案例： 品优购电梯导航（上）</h3><blockquote><p>1.当我们滚动到 今日推荐 模块，就让电梯导航显示出来 2.点击电梯导航页面可以滚动到相应内容区域 3.核心算法：因为电梯导航模块和内容区模块一一对应的 4.当我们点击电梯导航某个小模块，就可以拿到当前小模块的索引号 5.就可以把 animate 要移动的距离求出来：当前索引号内容区模块它的 offset().top 6.然后执行动画即可</p></blockquote><pre><code>代码实现略。(详情参考源代码)</code></pre><h3 id="1-4-5-案例：品优购电梯导航（下）"><a href="#1-4-5-案例：品优购电梯导航（下）" class="headerlink" title="1.4.5. 案例：品优购电梯导航（下）"></a>1.4.5. 案例：品优购电梯导航（下）</h3><blockquote><p>1.当我们点击电梯导航某个小 li， 当前小 li 添加 current 类，兄弟移除类名 2.当我们页面滚动到内容区域某个模块， 左侧电梯导航，相对应的小 li 模块，也会添加 current 类， 兄弟移除 current 类。 3.触发的事件是页面滚动，因此这个功能要写到页面滚动事件里面。 4.需要用到 each，遍历内容区域大模块。 each 里面能拿到内容区域每一个模块元素和索引号 5.判断的条件： 被卷去的头部 大于等于 内容区域里面每个模块的 offset().top 6.就利用这个索引号找到相应的电梯导航小 li 添加类。</p></blockquote><pre><code>代码实现略。(详情参考源代码)</code></pre><h2 id="1-5-今日总结"><a href="#1-5-今日总结" class="headerlink" title="1.5. 今日总结"></a>1.5. 今日总结</h2><p><img src="images/%E6%80%BB%E7%BB%93.png#"></p>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
          <category> jQuery </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>jQuery1</title>
      <link href="blog/1_day01_jquery/"/>
      <url>blog/1_day01_jquery/</url>
      
        <content type="html"><![CDATA[<p>学习目标：</p><blockquote><p>能够说出什么是 jQuery<br>能够说出 jQuery 的优点<br>能够简单使用 jQuery<br>能够说出 DOM 对象和 jQuery 对象的区别<br>能够写出常用的 jQuery 选择器<br>能够操作 jQuery 样式<br>能够写出常用的 jQuery 动画</p></blockquote><h2 id="1-1-jQuery-介绍"><a href="#1-1-jQuery-介绍" class="headerlink" title="1.1. jQuery 介绍"></a>1.1. jQuery 介绍</h2><h3 id="1-1-1-JavaScript-库"><a href="#1-1-1-JavaScript-库" class="headerlink" title="1.1.1 JavaScript 库"></a>1.1.1 JavaScript 库</h3><pre><code>JavaScript库：即 library，是一个封装好的特定的集合（方法和函数）。从封装一大堆函数的角度理解库，就是在这个库中，封装了很多预先定义好的函数在里面，比如动画animate、hide、show，比如获取元素等。</code></pre><blockquote><p>简单理解： 就是一个 JS 文件，里面对我们原生 js 代码进行了封装，存放到里面。这样我们可以快速高效的使用这些封装好的功能了。<br>比如 jQuery，就是为了快速方便的操作 DOM，里面基本都是函数（方法）。</p></blockquote><pre><code>常见的JavaScript 库：jQuery、Prototype、YUI、Dojo、Ext JS、移动端的zepto等，这些库都是对原生 JavaScript 的封装，内部都是用 JavaScript 实现的，我们主要学习的是 jQuery。</code></pre><h3 id="1-1-2-jQuery-的概念"><a href="#1-1-2-jQuery-的概念" class="headerlink" title="1.1.2 jQuery 的概念"></a>1.1.2 jQuery 的概念</h3><pre><code>jQuery总体概况如下 :</code></pre><ul><li><p>jQuery 是一个快速、简洁的 JavaScript 库，其设计的宗旨是“write Less，Do More”，即倡导写更少的代码，做更多的事情。</p></li><li><p>j 就是 JavaScript； Query 查询； 意思就是查询 js，把 js 中的 DOM 操作做了封装，我们可以快速的查询使用里面的功能。</p></li><li><p>jQuery 封装了 JavaScript 常用的功能代码，优化了 DOM 操作、事件处理、动画设计和 Ajax 交互。</p></li><li><p>学习 jQuery 本质： 就是学习调用这些函数（方法）。</p></li><li><p>jQuery 出现的目的是加快前端人员的开发速度，我们可以非常方便的调用和使用它，从而提高开发效率。<br><img src="images/jQuery%E6%A6%82%E8%BF%B0.jpg#"></p></li></ul><h3 id="1-1-3-jQuery-的优点"><a href="#1-1-3-jQuery-的优点" class="headerlink" title="1.1.3 jQuery 的优点"></a>1.1.3 jQuery 的优点</h3><ol><li>轻量级。核心文件才几十 kb，不会影响页面加载速度。</li><li>跨浏览器兼容，基本兼容了现在主流的浏览器。</li><li>链式编程、隐式迭代。</li><li>对事件、样式、动画支持，大大简化了 DOM 操作。</li><li>支持插件扩展开发。有着丰富的第三方的插件，例如：树形菜单、日期控件、轮播图等。</li><li>免费、开源。</li></ol><h2 id="1-2-jQuery-的基本使用"><a href="#1-2-jQuery-的基本使用" class="headerlink" title="1.2. jQuery 的基本使用"></a>1.2. jQuery 的基本使用</h2><h3 id="1-2-1-jQuery-的下载"><a href="#1-2-1-jQuery-的下载" class="headerlink" title="1.2.1 jQuery 的下载"></a>1.2.1 jQuery 的下载</h3><pre><code>jQuery的官网地址： [https://jquery.com/](https://jquery.com/)，官网即可下载最新版本。</code></pre><blockquote><p>各个版本的下载：<a href="https://code.jquery.com/">https://code.jquery.com/</a></p></blockquote><pre><code>版本介绍：</code></pre><blockquote><p>1x ：兼容 IE 678 等低版本浏览器， 官网不再更新<br>2x ：不兼容 IE 678 等低版本浏览器， 官网不再更新<br>3x ：不兼容 IE 678 等低版本浏览器， 是官方主要更新维护的版本</p></blockquote><h3 id="1-2-2-体验-jQuery"><a href="#1-2-2-体验-jQuery" class="headerlink" title="1.2.2. 体验 jQuery"></a>1.2.2. 体验 jQuery</h3><pre><code>步骤：</code></pre><ul><li>引入 jQuery 文件。</li><li>在文档最末尾插入 script 标签，书写体验代码。</li><li>$(‘div’).hide() 可以隐藏盒子。</li></ul><h3 id="1-2-3-jQuery-的入口函数"><a href="#1-2-3-jQuery-的入口函数" class="headerlink" title="1.2.3. jQuery 的入口函数"></a>1.2.3. jQuery 的入口函数</h3><pre><code>jQuery中常见的两种入口函数：</code></pre><pre><code class="javascript">// 第一种: 简单易用。$(function () &#123;    ...  // 此处是页面 DOM 加载完成的入口&#125;) ;// 第二种: 繁琐，但是也可以实现$(document).ready(function()&#123;   ...  //  此处是页面DOM加载完成的入口&#125;);</code></pre><pre><code>总结：</code></pre><ol><li>等着 DOM 结构渲染完毕即可执行内部代码，不必等到所有外部资源加载完成，jQuery 帮我们完成了封装。</li><li>相当于原生 js 中的 DOMContentLoaded。</li><li>不同于原生 js 中的 load 事件是等页面文档、外部的 js 文件、css 文件、图片加载完毕才执行内部代码。</li><li>更推荐使用第一种方式。</li></ol><h3 id="1-2-4-jQuery-中的顶级对象"><a href="#1-2-4-jQuery-中的顶级对象" class="headerlink" title="1.2.4. jQuery 中的顶级对象$"></a>1.2.4. jQuery 中的顶级对象$</h3><ol><li>$是 jQuery 的别称，在代码中可以使用 jQuery 代替，但一般为了方便，通常都直接使用 $ 。</li><li>$是jQuery的顶级对象，相当于原生JavaScript中的 window。把元素利用$包装成 jQuery 对象，就可以调用 jQuery 的方法。</li></ol><h3 id="1-2-5-jQuery-对象和-DOM-对象"><a href="#1-2-5-jQuery-对象和-DOM-对象" class="headerlink" title="1.2.5. jQuery 对象和 DOM 对象"></a>1.2.5. jQuery 对象和 DOM 对象</h3><pre><code>使用 jQuery 方法和原生JS获取的元素是不一样的，总结如下 :</code></pre><ol><li>用原生 JS 获取来的对象就是 DOM 对象</li><li>jQuery 方法获取的元素就是 jQuery 对象。</li><li>jQuery 对象本质是： 利用$对 DOM 对象包装后产生的对象（伪数组形式存储）。<blockquote><p>注意：<br>只有 jQuery 对象才能使用 jQuery 方法，DOM 对象则使用原生的 JavaScirpt 方法。</p></blockquote></li></ol><p><img src="images/jQuery%E5%AF%B9%E8%B1%A1%E5%92%8CDOM%E5%AF%B9%E8%B1%A1.png#"></p><h3 id="1-2-6-jQuery-对象和-DOM-对象转换"><a href="#1-2-6-jQuery-对象和-DOM-对象转换" class="headerlink" title="1.2.6. jQuery 对象和 DOM 对象转换"></a>1.2.6. jQuery 对象和 DOM 对象转换</h3><pre><code>DOM 对象与 jQuery 对象之间是可以相互转换的。因为原生js 比 jQuery 更大，原生的一些属性和方法 jQuery没有给我们封装. 要想使用这些属性和方法需要把jQuery对象转换为DOM对象才能使用。</code></pre><pre><code class="javascript">// 1.DOM对象转换成jQuery对象，方法只有一种var box = document.getElementById(&quot;box&quot;); // 获取DOM对象var jQueryObject = $(box); // 把DOM对象转换为 jQuery 对象// 2.jQuery 对象转换为 DOM 对象有两种方法：//   2.1 jQuery对象[索引值]var domObject1 = $(&quot;div&quot;)[0];//   2.2 jQuery对象.get(索引值)var domObject2 = $(&quot;div&quot;).get(0);</code></pre><p>总结：实际开发比较常用的是把 DOM 对象转换为 jQuery 对象，这样能够调用功能更加强大的 jQuery 中的方法。</p><h2 id="1-3-jQuery-选择器"><a href="#1-3-jQuery-选择器" class="headerlink" title="1.3. jQuery 选择器"></a>1.3. jQuery 选择器</h2><pre><code>原生 JS 获取元素方式很多，很杂，而且兼容性情况不一致，因此 jQuery 给我们做了封装，使获取元素统一标准。</code></pre><h3 id="1-3-1-基础选择器"><a href="#1-3-1-基础选择器" class="headerlink" title="1.3.1. 基础选择器"></a>1.3.1. 基础选择器</h3><pre><code class="js">$(&quot;选择器&quot;); //  里面选择器直接写 CSS 选择器即可，但是要加引号</code></pre><pre><code>![](images/%E5%9F%BA%E7%A1%80%E9%80%89%E6%8B%A9%E5%99%A8.png#)</code></pre><h3 id="1-3-2-层级选择器"><a href="#1-3-2-层级选择器" class="headerlink" title="1.3.2. 层级选择器"></a>1.3.2. 层级选择器</h3><pre><code>层级选择器最常用的两个分别为：后代选择器和子代选择器。![](images/%E5%B1%82%E7%BA%A7%E9%80%89%E6%8B%A9%E5%99%A8.png#)</code></pre><p><strong>基础选择器和层级选择器案例代码</strong></p><pre><code class="javascript">&lt;body&gt;    &lt;div&gt;我是div&lt;/div&gt;    &lt;div class=&quot;nav&quot;&gt;我是nav div&lt;/div&gt;    &lt;p&gt;我是p&lt;/p&gt;    &lt;ul&gt;        &lt;li&gt;我是ul 的&lt;/li&gt;        &lt;li&gt;我是ul 的&lt;/li&gt;        &lt;li&gt;我是ul 的&lt;/li&gt;    &lt;/ul&gt;    &lt;script&gt;        $(function() &#123;            console.log($(&quot;.nav&quot;));            console.log($(&quot;ul li&quot;));        &#125;)    &lt;/script&gt;&lt;/body&gt;</code></pre><h3 id="1-3-3-筛选选择器"><a href="#1-3-3-筛选选择器" class="headerlink" title="1.3.3. 筛选选择器"></a>1.3.3. 筛选选择器</h3><pre><code>筛选选择器，顾名思义就是在所有的选项中选择满足条件的进行筛选选择。常见如下 :</code></pre><p><img src="images/%E7%AD%9B%E9%80%89%E9%80%89%E6%8B%A9%E5%99%A8.png#"><br><strong>案例代码</strong></p><pre><code class="js">&lt;body&gt;    &lt;ul&gt;        &lt;li&gt;多个里面筛选几个&lt;/li&gt;        &lt;li&gt;多个里面筛选几个&lt;/li&gt;        &lt;li&gt;多个里面筛选几个&lt;/li&gt;        &lt;li&gt;多个里面筛选几个&lt;/li&gt;        &lt;li&gt;多个里面筛选几个&lt;/li&gt;        &lt;li&gt;多个里面筛选几个&lt;/li&gt;    &lt;/ul&gt;    &lt;ol&gt;        &lt;li&gt;多个里面筛选几个&lt;/li&gt;        &lt;li&gt;多个里面筛选几个&lt;/li&gt;        &lt;li&gt;多个里面筛选几个&lt;/li&gt;        &lt;li&gt;多个里面筛选几个&lt;/li&gt;        &lt;li&gt;多个里面筛选几个&lt;/li&gt;        &lt;li&gt;多个里面筛选几个&lt;/li&gt;    &lt;/ol&gt;    &lt;script&gt;        $(function() &#123;            $(&quot;ul li:first&quot;).css(&quot;color&quot;, &quot;red&quot;);            $(&quot;ul li:eq(2)&quot;).css(&quot;color&quot;, &quot;blue&quot;);            $(&quot;ol li:odd&quot;).css(&quot;color&quot;, &quot;skyblue&quot;);            $(&quot;ol li:even&quot;).css(&quot;color&quot;, &quot;pink&quot;);        &#125;)    &lt;/script&gt;&lt;/body&gt;</code></pre><p>另: jQuery 中还有一些筛选方法，类似 DOM 中的通过一个节点找另外一个节点，父、子、兄以外有所加强。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616073490928-8c91de0f-b9b1-41c3-8a06-ab51b23cfb98.png#align=left&display=inline&height=471&margin=%5Bobject%20Object%5D&originHeight=471&originWidth=1002&status=done&style=none&width=1002"><br>偏重于记忆，演示代码略。</p><h3 id="1-3-4-知识铺垫"><a href="#1-3-4-知识铺垫" class="headerlink" title="1.3.4 知识铺垫"></a>1.3.4 知识铺垫</h3><ul><li>jQuery 设置样式</li></ul><pre><code class="javascript">$(&quot;div&quot;).css(&quot;属性&quot;, &quot;值&quot;);</code></pre><ul><li>jQuery 里面的排他思想</li></ul><pre><code class="javascript">// 想要多选一的效果，排他思想：当前元素设置样式，其余的兄弟元素清除样式。$(this).css(“color”,”red”);$(this).siblings(). css(“color”,””);</code></pre><ul><li>隐式迭代</li></ul><pre><code class="javascript">// 遍历内部 DOM 元素（伪数组形式存储）的过程就叫做隐式迭代。// 简单理解：给匹配到的所有元素进行循环遍历，执行相应的方法，而不用我们再进行循环，简化我们的操作，方便我们调用。$(&quot;div&quot;).hide(); // 页面中所有的div全部隐藏，不用循环操作</code></pre><ul><li>链式编程</li></ul><pre><code class="javascript">// 链式编程是为了节省代码量，看起来更优雅。$(this).css(&quot;color&quot;, &quot;red&quot;).sibling().css(&quot;color&quot;, &quot;&quot;);</code></pre><h3 id="1-3-5-案例：淘宝服饰精品案例"><a href="#1-3-5-案例：淘宝服饰精品案例" class="headerlink" title="1.3.5 案例：淘宝服饰精品案例"></a>1.3.5 案例：淘宝服饰精品案例</h3><blockquote><p>思路分析: 1.核心原理：鼠标经过左侧盒子某个小 li，就让内容区盒子相对应图片显示，其余的图片隐藏。 2.需要得到当前小 li 的索引号，就可以显示对应索引号的图片<br>3.jQuery 得到当前元素索引号 $(this).index() 4.中间对应的图片，可以通过 eq(index) 方法去选择 5.显示元素 show() 隐藏元素 hide()</p></blockquote><pre><code>代码实现略。(详情参考源代码)</code></pre><h2 id="1-4-jQuery-样式操作"><a href="#1-4-jQuery-样式操作" class="headerlink" title="1.4. jQuery 样式操作"></a>1.4. jQuery 样式操作</h2><pre><code>jQuery中常用的样式操作有两种：css() 和 设置类样式方法</code></pre><h3 id="1-4-1-方法-1-操作-css-方法"><a href="#1-4-1-方法-1-操作-css-方法" class="headerlink" title="1.4.1. 方法 1: 操作 css 方法"></a>1.4.1. 方法 1: 操作 css 方法</h3><pre><code>jQuery 可以使用 css 方法来修改简单元素样式； 也可以操作类，修改多个样式。常用以下三种形式 :</code></pre><pre><code class="javascript">// 1.参数只写属性名，则是返回属性值var strColor = $(this).css(&#39;color&#39;);// 2.  参数是属性名，属性值，逗号分隔，是设置一组样式，属性必须加引号，值如果是数字可以不用跟单位和引号$(this).css(&#39;&#39;color&#39;&#39;, &#39;&#39;red&#39;&#39;);// 3.  参数可以是对象形式，方便设置多组样式。属性名和属性值用冒号隔开， 属性可以不用加引号$(this).css(&#123; &quot;color&quot;:&quot;white&quot;,&quot;font-size&quot;:&quot;20px&quot;&#125;);</code></pre><pre><code>注意：css() 多用于样式少时操作，多了则不太方便。</code></pre><h3 id="1-4-2-方法-2-设置类样式方法"><a href="#1-4-2-方法-2-设置类样式方法" class="headerlink" title="1.4.2. 方法 2: 设置类样式方法"></a>1.4.2. 方法 2: 设置类样式方法</h3><pre><code>作用等同于以前的 classList，可以操作类样式， 注意操作类里面的参数不要加点。常用的三种设置类样式方法：</code></pre><pre><code class="javascript">// 1.添加类$(&quot;div&quot;).addClass(&quot;current&quot;);// 2.删除类$(&quot;div&quot;).removeClass(&quot;current&quot;);// 3.切换类$(&quot;div&quot;).toggleClass(&quot;current&quot;);</code></pre><pre><code>注意：</code></pre><ol><li>设置类样式方法比较适合样式多时操作，可以弥补 css()的不足。</li><li>原生 JS 中 className 会覆盖元素原先里面的类名，jQuery 里面类操作只是对指定类进行操作，不影响原先的类名。</li></ol><h3 id="1-4-3-案例：tab-栏切换"><a href="#1-4-3-案例：tab-栏切换" class="headerlink" title="1.4.3. 案例：tab 栏切换"></a>1.4.3. 案例：tab 栏切换</h3><blockquote><p>思路分析: 1.点击上部的 li，当前 li 添加 current 类，其余兄弟移除类。 2.点击的同时，得到当前 li 的索引号 3.让下部里面相应索引号的 item 显示，其余的 item 隐藏</p></blockquote><pre><code>代码实现略。(详情参考源代码)</code></pre><h2 id="1-5-jQuery-效果"><a href="#1-5-jQuery-效果" class="headerlink" title="1.5. jQuery 效果"></a>1.5. jQuery 效果</h2><pre><code>jQuery 给我们封装了很多动画效果，最为常见的如下：</code></pre><ul><li>显示隐藏：show() / hide() / toggle() ;</li><li>划入画出：slideDown() / slideUp() / slideToggle() ;</li><li>淡入淡出：fadeIn() / fadeOut() / fadeToggle() / fadeTo() ;</li><li>自定义动画：animate() ;<blockquote><p>注意：<br>动画或者效果一旦触发就会执行，如果多次触发，就造成多个动画或者效果排队执行。<br>jQuery 为我们提供另一个方法，可以停止动画排队：stop() ;</p></blockquote></li></ul><h3 id="1-5-1-显示隐藏"><a href="#1-5-1-显示隐藏" class="headerlink" title="1.5.1. 显示隐藏"></a>1.5.1. 显示隐藏</h3><pre><code>显示隐藏动画，常见有三个方法：show() / hide() / toggle() ;语法规范如下:</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616073491028-773a9d46-839b-4afc-bee1-17d55ed0a4ad.png#align=left&display=inline&height=260&margin=%5Bobject%20Object%5D&originHeight=260&originWidth=624&status=done&style=none&width=624"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616073491164-e18ddc74-6cd9-4758-98be-8a4ba4a5659b.png#align=left&display=inline&height=260&margin=%5Bobject%20Object%5D&originHeight=260&originWidth=624&status=done&style=none&width=624"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616073491265-475bb990-b1e3-4aa8-b58a-089a14539935.png#align=left&display=inline&height=284&margin=%5Bobject%20Object%5D&originHeight=284&originWidth=625&status=done&style=none&width=625"><br><strong>代码演示</strong></p><pre><code class="javascript">&lt;body&gt;    &lt;button&gt;显示&lt;/button&gt;    &lt;button&gt;隐藏&lt;/button&gt;    &lt;button&gt;切换&lt;/button&gt;    &lt;div&gt;&lt;/div&gt;    &lt;script&gt;        $(function() &#123;            $(&quot;button&quot;).eq(0).click(function() &#123;                $(&quot;div&quot;).show(1000, function() &#123;                    alert(1);                &#125;);            &#125;)            $(&quot;button&quot;).eq(1).click(function() &#123;                $(&quot;div&quot;).hide(1000, function() &#123;                    alert(1);                &#125;);            &#125;)            $(&quot;button&quot;).eq(2).click(function() &#123;              $(&quot;div&quot;).toggle(1000);            &#125;)            // 一般情况下，我们都不加参数直接显示隐藏就可以了        &#125;);    &lt;/script&gt;&lt;/body&gt;</code></pre><h3 id="1-5-2-滑入滑出"><a href="#1-5-2-滑入滑出" class="headerlink" title="1.5.2. 滑入滑出"></a>1.5.2. 滑入滑出</h3><pre><code>滑入滑出动画，常见有三个方法：slideDown() / slideUp() / slideToggle() ;语法规范如下:</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616073491339-dc77fd79-125f-48b7-a6e8-3d44db54fba8.png#align=left&display=inline&height=260&margin=%5Bobject%20Object%5D&originHeight=260&originWidth=624&status=done&style=none&width=624"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616073491433-2cf9c8e4-43ce-4c72-849f-2d23bf822215.png#align=left&display=inline&height=260&margin=%5Bobject%20Object%5D&originHeight=260&originWidth=624&status=done&style=none&width=624"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616073491518-8e00011c-f004-4d1b-81f4-e0ade442f00f.png#align=left&display=inline&height=250&margin=%5Bobject%20Object%5D&originHeight=250&originWidth=624&status=done&style=none&width=624"><br><strong>代码演示</strong></p><pre><code class="javascript">&lt;body&gt;    &lt;button&gt;下拉滑动&lt;/button&gt;    &lt;button&gt;上拉滑动&lt;/button&gt;    &lt;button&gt;切换滑动&lt;/button&gt;    &lt;div&gt;&lt;/div&gt;    &lt;script&gt;        $(function() &#123;            $(&quot;button&quot;).eq(0).click(function() &#123;                // 下滑动 slideDown()                $(&quot;div&quot;).slideDown();            &#125;)            $(&quot;button&quot;).eq(1).click(function() &#123;                // 上滑动 slideUp()                $(&quot;div&quot;).slideUp(500);            &#125;)            $(&quot;button&quot;).eq(2).click(function() &#123;                // 滑动切换 slideToggle()                $(&quot;div&quot;).slideToggle(500);            &#125;);        &#125;);    &lt;/script&gt;&lt;/body&gt;</code></pre><blockquote><p>小案例：下拉菜单略（详情参看源码）。</p></blockquote><h3 id="1-5-3-淡入淡出"><a href="#1-5-3-淡入淡出" class="headerlink" title="1.5.3 淡入淡出"></a>1.5.3 淡入淡出</h3><pre><code>淡入淡出动画，常见有四个方法：fadeIn() / fadeOut() / fadeToggle() / fadeTo() ;语法规范如下:</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616073491592-b675c8b8-6d7a-40b5-a4be-d51dc9bd1c86.png#align=left&display=inline&height=260&margin=%5Bobject%20Object%5D&originHeight=260&originWidth=624&status=done&style=none&width=624"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616073491668-703fa0c6-d2f4-48e6-a78c-5db0cb33df17.png#align=left&display=inline&height=250&margin=%5Bobject%20Object%5D&originHeight=250&originWidth=624&status=done&style=none&width=624"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616073491743-2587d517-38fd-4633-9273-d99234bb35e4.png#align=left&display=inline&height=260&margin=%5Bobject%20Object%5D&originHeight=260&originWidth=624&status=done&style=none&width=624"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616073491838-9409127c-665d-4c7e-b4b0-180ef10ffa61.png#align=left&display=inline&height=255&margin=%5Bobject%20Object%5D&originHeight=255&originWidth=664&status=done&style=none&width=664"><br><strong>代码演示</strong></p><pre><code class="javascript">&lt;body&gt;    &lt;button&gt;淡入效果&lt;/button&gt;    &lt;button&gt;淡出效果&lt;/button&gt;    &lt;button&gt;淡入淡出切换&lt;/button&gt;    &lt;button&gt;修改透明度&lt;/button&gt;    &lt;div&gt;&lt;/div&gt;    &lt;script&gt;        $(function() &#123;            $(&quot;button&quot;).eq(0).click(function() &#123;                // 淡入 fadeIn()                $(&quot;div&quot;).fadeIn(1000);            &#125;)            $(&quot;button&quot;).eq(1).click(function() &#123;                // 淡出 fadeOut()                $(&quot;div&quot;).fadeOut(1000);            &#125;)            $(&quot;button&quot;).eq(2).click(function() &#123;                // 淡入淡出切换 fadeToggle()                $(&quot;div&quot;).fadeToggle(1000);            &#125;);            $(&quot;button&quot;).eq(3).click(function() &#123;                //  修改透明度 fadeTo() 这个速度和透明度要必须写                $(&quot;div&quot;).fadeTo(1000, 0.5);            &#125;);        &#125;);    &lt;/script&gt;&lt;/body&gt;</code></pre><h3 id="1-5-4-自定义动画"><a href="#1-5-4-自定义动画" class="headerlink" title="1.5.4 自定义动画"></a>1.5.4 自定义动画</h3><pre><code>自定义动画非常强大，通过参数的传递可以模拟以上所有动画，方法为：animate() ;语法规范如下:</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616073491922-87ac5de5-e3b5-410a-afee-89e862531e62.png#align=left&display=inline&height=280&margin=%5Bobject%20Object%5D&originHeight=280&originWidth=624&status=done&style=none&width=624"><br><strong>代码演示</strong></p><pre><code class="javascript">&lt;body&gt;  &lt;button&gt;动起来&lt;/button&gt;  &lt;div&gt;&lt;/div&gt;  &lt;script&gt;    $(function()&#123;&quot; &quot;&#125;    &#123;$(&quot;button&quot;).click(function () &#123;      $(&quot;div&quot;).animate(        &#123;          left: 500,          top: 300,          opacity: 0.4,          width: 500,        &#125;,        500      );    &#125;)&#125;    )  &lt;/script&gt;&lt;/body&gt;</code></pre><h3 id="1-5-5-停止动画排队"><a href="#1-5-5-停止动画排队" class="headerlink" title="1.5.5 停止动画排队"></a>1.5.5 停止动画排队</h3><pre><code>动画或者效果一旦触发就会执行，如果多次触发，就造成多个动画或者效果排队执行。停止动画排队的方法为：stop() ;</code></pre><ul><li><p>stop() 方法用于停止动画或效果。</p></li><li><p>stop() 写到动画或者效果的前面， 相当于停止结束上一次的动画。</p><pre><code>  总结: 每次使用动画之前，先调用 stop() ,在调用动画。</code></pre></li></ul><h3 id="1-5-6-事件切换"><a href="#1-5-6-事件切换" class="headerlink" title="1.5.6. 事件切换"></a>1.5.6. 事件切换</h3><pre><code>jQuery中为我们添加了一个新事件 hover() ; 功能类似 css 中的伪类 :hover 。介绍如下</code></pre><p><strong>语法</strong></p><pre><code class="javascript">hover([over,]out)     // 其中over和out为两个函数</code></pre><ul><li>over:鼠标移到元素上要触发的函数（相当于 mouseenter）</li><li>out:鼠标移出元素要触发的函数（相当于 mouseleave）</li><li>如果只写一个函数，则鼠标经过和离开都会触发它</li></ul><p><strong>hover 事件和停止动画排列案例</strong></p><pre><code class="javascript">&lt;body&gt;    &lt;ul class=&quot;nav&quot;&gt;        &lt;li&gt;            &lt;a href=&quot;#&quot;&gt;微博&lt;/a&gt;            &lt;ul&gt;&lt;li&gt;&lt;a href=&quot;&quot;&gt;私信&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;&quot;&gt;评论&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;&quot;&gt;@我&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;        &lt;/li&gt;        &lt;li&gt;            &lt;a href=&quot;#&quot;&gt;微博&lt;/a&gt;            &lt;ul&gt;&lt;li&gt;&lt;a href=&quot;&quot;&gt;私信&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;&quot;&gt;评论&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;&quot;&gt;@我&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;        &lt;/li&gt;    &lt;/ul&gt;    &lt;script&gt;        $(function() &#123;            // 鼠标经过            // $(&quot;.nav&gt;li&quot;).mouseover(function() &#123;            //     // $(this) jQuery 当前元素  this不要加引号            //     // show() 显示元素  hide() 隐藏元素            //     $(this).children(&quot;ul&quot;).slideDown(200);            // &#125;);            // // 鼠标离开            // $(&quot;.nav&gt;li&quot;).mouseout(function() &#123;            //     $(this).children(&quot;ul&quot;).slideUp(200);            // &#125;);            // 1. 事件切换 hover 就是鼠标经过和离开的复合写法            // $(&quot;.nav&gt;li&quot;).hover(function() &#123;            //     $(this).children(&quot;ul&quot;).slideDown(200);            // &#125;, function() &#123;            //     $(this).children(&quot;ul&quot;).slideUp(200);            // &#125;);            // 2. 事件切换 hover  如果只写一个函数，那么鼠标经过和鼠标离开都会触发这个函数            $(&quot;.nav&gt;li&quot;).hover(function() &#123;                // stop 方法必须写到动画的前面                $(this).children(&quot;ul&quot;).stop().slideToggle();            &#125;);        &#125;)    &lt;/script&gt;&lt;/body&gt;</code></pre><h3 id="1-5-7-案例：王者荣耀手风琴效果"><a href="#1-5-7-案例：王者荣耀手风琴效果" class="headerlink" title="1.5.7. 案例：王者荣耀手风琴效果"></a>1.5.7. 案例：王者荣耀手风琴效果</h3><blockquote><p>思路分析: 1.鼠标经过某个小 li 有两步操作： 2.当前小 li 宽度变为 224px， 同时里面的小图片淡出，大图片淡入 3.其余兄弟小 li 宽度变为 69px， 小图片淡入， 大图片淡出</p></blockquote><pre><code>代码实现略。(详情参考源代码)</code></pre><h2 id="1-6-今日总结"><a href="#1-6-今日总结" class="headerlink" title="1.6. 今日总结"></a>1.6. 今日总结</h2><p><img src="images/%E6%80%BB%E7%BB%93.png#"></p>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
          <category> jQuery </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>无障碍网页标准规范</title>
      <link href="blog/ubp558/"/>
      <url>blog/ubp558/</url>
      
        <content type="html"><![CDATA[<p>关于无障碍网页标准规范</p><ul><li><a href="https://www.cnblogs.com/chenzeyongjsj/p/7524879.html">无障碍网页标准规范</a></li><li><a href="https://www.zhangxinxu.com/wordpress/2017/05/html-tabindex/">HTML tabindex 属性与 web 网页键盘无障碍访问</a></li><li><a href="https://blog.csdn.net/TalonZhang/article/details/84261950">CSS 轮廓（outline）属性详解及 outline 与 border 的区别</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
          <category> 网站相关 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>英语阅读</title>
      <link href="blog/iaxlbh/"/>
      <url>blog/iaxlbh/</url>
      
        <content type="html"><![CDATA[<p>这是加密文章！</p>]]></content>
      
      
      <categories>
          
          <category> Language </category>
          
          <category> English </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>计算方法各实验流程图汇总</title>
      <link href="blog/hizlew/"/>
      <url>blog/hizlew/</url>
      
        <content type="html"><![CDATA[<blockquote><p>大三计算方法课程所有实验报告的流程图，做个存档，以备不时之需~~<img src="https://cdn.nlark.com/yuque/0/2021/gif/1484158/1616633908079-3d59dbee-c4dc-4c51-899f-0708e3570b0d.gif#align=left&display=inline&height=100&margin=%5Bobject%20Object%5D&name=A13E7D78C08B2131588EDD8D9F6FE5EB.gif&originHeight=100&originWidth=100&size=10263&status=done&style=stroke&width=100" alt="A13E7D78C08B2131588EDD8D9F6FE5EB.gif"><br>目录</p><ul><li>非线性方程的解法</li><li>线性方程组的解法</li><li>Hermite 插值</li><li>最小二乘算法</li><li>正态分布表复现</li></ul></blockquote><h2 id="非线性方程的解法"><a href="#非线性方程的解法" class="headerlink" title="非线性方程的解法"></a>非线性方程的解法</h2><p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1616633632638-fc4a4508-6a92-4c8e-ae80-6d7326f9e13a.jpeg#align=left&display=inline&height=555&margin=%5Bobject%20Object%5D&name=yuque_diagram.jpg&originHeight=1728&originWidth=1258&size=109866&status=done&style=stroke&width=404" alt="yuque_diagram.jpg"></p><h2 id="线性方程组的解法"><a href="#线性方程组的解法" class="headerlink" title="线性方程组的解法"></a>线性方程组的解法</h2><p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1616633672598-12d949b6-91f6-4b78-9825-21bd836c6dee.jpeg#align=left&display=inline&height=538&margin=%5Bobject%20Object%5D&name=yuque_diagram.jpg&originHeight=2050&originWidth=1697&size=226328&status=done&style=stroke&width=445" alt="yuque_diagram.jpg"></p><h2 id="Hermite-插值"><a href="#Hermite-插值" class="headerlink" title="Hermite 插值"></a>Hermite 插值</h2><p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1616633702383-7da5e39f-e899-4034-acdd-7e0c417a1487.jpeg#align=left&display=inline&height=667&margin=%5Bobject%20Object%5D&name=yuque_diagram.jpg&originHeight=2610&originWidth=1796&size=225117&status=done&style=stroke&width=459" alt="yuque_diagram.jpg"></p><h2 id="最小二乘算法"><a href="#最小二乘算法" class="headerlink" title="最小二乘算法"></a>最小二乘算法</h2><p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1616633760214-e8df0fdd-19f5-44a7-97dc-7d3e5b05e0d3.jpeg#align=left&display=inline&height=819&margin=%5Bobject%20Object%5D&name=yuque_diagram.jpg&originHeight=2177&originWidth=1380&size=162211&status=done&style=stroke&width=519" alt="yuque_diagram.jpg"></p><h2 id="正态分布表复现"><a href="#正态分布表复现" class="headerlink" title="正态分布表复现"></a>正态分布表复现</h2><p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1616633788535-61ef6425-b386-4a92-b3d8-44a136c3ee88.jpeg#align=left&display=inline&height=1027&margin=%5Bobject%20Object%5D&name=yuque_diagram.jpg&originHeight=1748&originWidth=708&size=98744&status=done&style=stroke&width=416" alt="yuque_diagram.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
          <category> 其他算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[转]前端PS操作</title>
      <link href="blog/gqw2qf/"/>
      <url>blog/gqw2qf/</url>
      
        <content type="html"><![CDATA[<h2 id="ps-基本操作以及常用快捷键："><a href="#ps-基本操作以及常用快捷键：" class="headerlink" title="ps 基本操作以及常用快捷键："></a>ps 基本操作以及常用快捷键：</h2><p>因为网页美工大部分效果图都是利用 ps 来做的，所以，以后我们大部分切图工作都是在 ps 里面完成。</p><ul><li>文件–打开 – 可以打开 我们要测量的图片</li><li>ctrl+r 可以打开标尺 或者 视图 – 标尺</li><li>右击标尺， 把里面的单位改为 像素</li><li>ctrl+ 加号 键 可以 放大 视图 ctrl+ 减号 缩小视图</li><li>按住空格键， 鼠标可以 变成小手 ，拖动 ps 视图</li><li>用选区 拖动 可以 测量 大小</li><li>ctrl+ d 可以取消选区 或者旁边空白处点击一下也可以取消选区</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611549556960-d43dc95b-ceed-4eb5-bc70-d527bfd6790f.png#align=left&display=inline&height=440&margin=%5Bobject%20Object%5D&originHeight=440&originWidth=849&status=done&style=stroke&width=849"></p><h2 id="Photoshop-切图"><a href="#Photoshop-切图" class="headerlink" title="Photoshop 切图"></a>Photoshop 切图</h2><p><strong>常见的图片格式</strong></p><pre><code>1. jpg图像格式：JPEG（.JPG）对色彩的信息保留较好，高清，颜色较多，我们产品类的图片经常用jpg格式的2. gif图像格式：GIF格式最多只能储存256色，所以通常用来显示简单图形及字体，但是可以保存透明背景和动画效果3. png图像格式是一种新兴的网络图形格式，结合了GIF和JPEG的优点，具有存储形式丰富的特点，能够保持透明背景4. PSD图像格式PSD格式是Photoshop的专用格式，里面可以存放图层、通道、遮罩等多种设计草稿。</code></pre><p>PS 切图 可以 分为 利用切片工具切图 以及 利用 PS 的插件快速切图。</p><h3 id="1-PS-切片工具"><a href="#1-PS-切片工具" class="headerlink" title="1). PS 切片工具"></a>1). PS 切片工具</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611549558330-2bb506e1-9230-4d4c-a031-7de0b5d2077a.png#align=left&display=inline&height=246&margin=%5Bobject%20Object%5D&originHeight=246&originWidth=306&status=done&style=none&width=306"><br>ps 切图片，分两大步：<br><strong>1). 用切片选中图片</strong></p><ul><li><p>利用切片工具手动划出</p></li><li><p>图层菜单—新建基于图层的切片</p></li><li><p>利用辅助线 来切图 – 基于参考线的切片<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611549558387-e6ea82e1-e85f-4b2e-a724-7eb095932273.png#align=left&display=inline&height=106&margin=%5Bobject%20Object%5D&originHeight=106&originWidth=640&status=done&style=none&width=640"></p></li></ul><p><strong>2). 导出切片</strong><br>文件菜单 – 存储为 web 设备所用格式 —- 选择 我们要的图片格式 —- 点存储 — 别忘了选中的切片</p><blockquote><p>辅助线和切片使用及清除</p></blockquote><p>视图菜单– 清除 辅助线/ 清除切片</p><h3 id="2-切图插件"><a href="#2-切图插件" class="headerlink" title="2). 切图插件"></a>2). 切图插件</h3><p>Cutterman 是一款运行在 photoshop 中的插件，能够自动将你需要的图层进行输出， 以替代传统的手工 “导出 web 所用格式” 以及使用切片工具进行挨个切图的繁琐流程。 它支持各种各样的图片尺寸、格式、形态输出，方便你在 pc、ios、Android 等端上使用。 它不需要你记住一堆的语法、规则，纯点击操作，方便、快捷，易于上手。<br>官网: <a href="http://www.cutterman.cn/zh/cutterman">http://www.cutterman.cn/zh/cutterman</a><br>注意： cutterman 插件要求你的 ps 必须是完整版，不能是绿色版，所以大家需要从新安装完整版本。<br><img src="https://cdn.nlark.com/yuque/0/2021/gif/1484158/1611549558445-f9023a37-7339-4590-907e-a71d004899ff.gif#align=left&display=inline&height=569&margin=%5Bobject%20Object%5D&originHeight=569&originWidth=644&status=done&style=stroke&width=644"></p>]]></content>
      
      
      <categories>
          
          <category> PostProduction </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>布局之rem和响应式</title>
      <link href="blog/rm1i2lgosgh2/"/>
      <url>blog/rm1i2lgosgh2/</url>
      
        <content type="html"><![CDATA[<h2 id="rem"><a href="#rem" class="headerlink" title="rem"></a>rem</h2><h3 id="rem-单位"><a href="#rem-单位" class="headerlink" title="rem 单位"></a>rem 单位</h3><p>rem (root em)是一个相对单位，类似于 em，em 是父元素字体大小。</p><div style="background: #FFF3F3;padding:10px;border: 1px solid #DEB8BE;border-radius:5px;margin-bottom:5px;">不同的是rem的基准是相对于html元素的字体大小。</div>比如，根元素（html）设置font-size=12px; 非根元素设置width:2rem; 则换成px表示就是24px。```css/* 根html 为 12px */html {   font-size: 12px;}/* 此时 div 的字体大小就是 24px */       div {    font-size: 2rem;}```rem的优势：父元素文字大小可能不一致， 但是整个页面只有一个html，可以很好来控制整个页面的元素大小。<h3 id="rem-适配方案"><a href="#rem-适配方案" class="headerlink" title="rem 适配方案"></a>rem 适配方案</h3><p>1.让一些不能等比自适应的元素，达到当设备尺寸发生改变的时候，等比例适配当前设备。 2.使用媒体查询根据不同设备按比例设置 html 的字体大小，然后页面元素使用 rem 做尺寸单位，当 html 字体大小变化元素尺寸也会发生变化，从而达到等比缩放的适配。<br>技术方案：<br>1.less+rem+媒体查询<br>2.lflexible.js+rem<br>总结：<br>两种方案现在都存在。<br>方案 2 更简单，现阶段大家无需了解里面的 js 代码。</p><h3 id="rem-适配方案-1"><a href="#rem-适配方案-1" class="headerlink" title="rem 适配方案 1"></a>rem 适配方案 1</h3><p>① 假设设计稿是 750px<br>② 假设我们把整个屏幕划分为 15 等份（划分标准不一可以是 20 份也可以是 10 等份）<br>③ 每一份作为 html 字体大小，这里就是 50px<br>④ 那么在 320px 设备的时候，字体大小为 320/15 就是 21.33px<br>⑤ 用我们页面元素的大小除以不同的 html 字体大小会发现他们比例还是相同的<br>⑥ 比如我们以 750 为标准设计稿<br>⑦ 一个 100_100 像素的页面元素在 750 屏幕下， 就是 100/ 50 转换为 rem 是 2rem_2rem 比例是 1 比 1<br>⑧320 屏幕下， html 字体大小为 21.33 则 2rem= 42.66px 此时宽和高都是 42.66 但是宽和高的比例还是 1 比 1<br>⑨ 但是已经能实现不同屏幕下 页面元素盒子等比例缩放的效果<br>总结：<br>① 最后的公式：页面元素的 rem 值 = 页面元素值（px） / （屏幕宽度 / 划分的份数）<br>② 屏幕宽度/划分的份数就是 htmlfont-size 的大小<br>③ 或者：页面元素的 rem 值 = 页面元素值（px） / html font-size 字体大小</p><h3 id="苏宁首页"><a href="#苏宁首页" class="headerlink" title="苏宁首页"></a>苏宁首页</h3><p>苏宁首页地址 ：<a href="m.suning.com">苏宁首页</a><br>1、 技术选型<br>方案：我们采取单独制作移动页面方案<br>技术：布局采取 rem 适配布局（less + rem + 媒体查询）<br>设计图： 本设计图采用 750px 设计尺寸<br>2、搭建文件结构<br><img src="https://cdn.nlark.com/yuque/0/2021/jpg/1484158/1615360325682-7e3f3397-a6e1-47eb-9774-d632ea98c710.jpg#align=left&display=inline&height=263&margin=%5Bobject%20Object%5D&originHeight=263&originWidth=466&status=done&style=stroke&width=466"><br>3、设置视口标签以及引入初始化样式</p><pre><code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no,         initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;css/normalize.css&quot;&gt;</code></pre><p>4、设置公共 common.less 文件</p><ul><li>新建 common.less 设置好最常见的屏幕尺寸，利用媒体查询设置不同的 html 字体大小，因为除了首页其他页面也需要</li><li>我们关心的尺寸有 320px、360px、375px、384px、400px、414px、424px、480px、540px、720px、750px</li><li>划分的份数我们定为 15 等份</li><li>因为我们 pc 端也可以打开我们苏宁移动端首页，我们默认 html 字体大小为 50px，注意这句话写到最上面</li></ul><h3 id="rem-适配方案-2"><a href="#rem-适配方案-2" class="headerlink" title="rem 适配方案 2"></a>rem 适配方案 2</h3><p>手机淘宝团队出的简洁高效 移动端适配库<br>我们再也不需要在写不同屏幕的媒体查询，因为里面 js 做了处理<br>它的原理是把当前设备划分为 10 等份，但是不同设备下，比例还是一致的。<br>我们要做的，就是确定好我们当前设备的 html 文字大小就可以了<br>比如当前设计稿是 750px， 那么我们只需要把 html 文字大小设置为 75px(750px / 10) 就可以<br>里面页面元素 rem 值： 页面元素的 px 值 / 75<br>剩余的，让 flexible.js 来去算<br>github 地址：<a href="https://link.jianshu.com/?t=https://github.com/amfe/lib-flexible">https://github.com/amfe/lib-flexible</a><br>总结：<br>因为 flexible 是默认将屏幕分为 10 等分<br>但是当屏幕大于 750 的时候希望不要再去重置 html 字体了<br>所以要自己通过媒体查询设置一下<br>并且要把权重提到最高<br>VSCode px 转换 rem 插件 cssrem<br>因为 cssrem 中 css 自动转化为 rem 是参照默认插件的 16 转换的所以需要自己配置<br><img src="https://cdn.nlark.com/yuque/0/2021/jpg/1484158/1615360325777-63efe343-7fb5-46ff-a976-757d50df3556.jpg#align=left&display=inline&height=536&margin=%5Bobject%20Object%5D&originHeight=536&originWidth=713&status=done&style=stroke&width=713"><img src="https://cdn.nlark.com/yuque/0/2021/jpg/1484158/1615360325891-a1820b7f-bdbf-47e8-b04b-723db8329cf8.jpg#align=left&display=inline&height=544&margin=%5Bobject%20Object%5D&originHeight=544&originWidth=566&status=done&style=stroke&width=566"></p><h2 id="响应式开发原理"><a href="#响应式开发原理" class="headerlink" title="响应式开发原理"></a>响应式开发原理</h2><h3 id="响应式开发原理-1"><a href="#响应式开发原理-1" class="headerlink" title="响应式开发原理"></a>响应式开发原理</h3><div style="background: #edf9e8;padding:10px;border: 1px solid #c2d2b5;border-radius:5px;margin-bottom:5px;">就是使用媒体查询针对不同宽度的设备进行布局和样式的设置，从而适配不同设备的目的</div>设备的划分情况<ul><li>小于 768 的为超小屏幕（手机）</li><li>768~992 之间的为小屏设备（平板）</li><li>992~1200 的中等屏幕（桌面显示器）</li><li>大于 1200 的宽屏设备（大桌面显示器）</li></ul><h3 id="响应式布局容器"><a href="#响应式布局容器" class="headerlink" title="响应式布局容器"></a>响应式布局容器</h3><div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">响应式需要一个父级做为布局容器，来配合子级元素来实现变化效果。原理就是在不同屏幕下，通过媒体查询来改变这个布局容器的大小，再改变里面子元素的排列方式和大小，从而实现不同屏幕下，看到不同的页面布局和样式变化。</div>父容器版心的尺寸划分<ul><li>超小屏幕（手机，小于 768px）：设置宽度为 100%</li><li>小屏幕（平板，大于等于 768px）：设置宽度为 750px</li><li>中等屏幕（桌面显示器，大于等于 992px）：宽度设置为 970px</li><li>大屏幕（大桌面显示器，大于等于 1200px）：宽度设置为 1170px</li></ul><p>但是我们也可以根据实际情况自己定义划分</p>]]></content>
      
      
      <categories>
          
          <category> Language </category>
          
          <category> CSS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>bootstrap框架</title>
      <link href="blog/dd8ibp9ica8w/"/>
      <url>blog/dd8ibp9ica8w/</url>
      
        <content type="html"><![CDATA[<p>这是加密文章！</p>]]></content>
      
      
      <categories>
          
          <category> Language </category>
          
          <category> CSS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>布局之流式（百分比）</title>
      <link href="blog/oxqtosvrfeg8/"/>
      <url>blog/oxqtosvrfeg8/</url>
      
        <content type="html"><![CDATA[<h2 id="meta-标签-viewport"><a href="#meta-标签-viewport" class="headerlink" title="meta 标签 viewport"></a>meta 标签 viewport</h2><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1615360134988-de179521-dfc1-419f-a1b6-5e45b5b40096.png#align=left&display=inline&height=451&margin=%5Bobject%20Object%5D&originHeight=451&originWidth=1043&status=done&style=none&width=1043"></p><h2 id="normalize-css"><a href="#normalize-css" class="headerlink" title="normalize.css"></a>normalize.css</h2><p>移动端 CSS 初始化推荐使用 normalize.css/<br>Normalize.css：保护了有价值的默认值<br>Normalize.css：修复了浏览器的 bug<br>Normalize.css：是模块化的<br>Normalize.css：拥有详细的文档<br>官网地址： <a href="http://necolas.github.io/normalize.css/">http://necolas.github.io/normalize.css/</a></p><h2 id="box-sizing"><a href="#box-sizing" class="headerlink" title="box-sizing"></a>box-sizing</h2><div style="background: #FFF3F3;padding:10px;border: 1px solid #DEB8BE;border-radius:5px;margin-bottom:5px;">传统模式宽度计算：盒子的宽度 = CSS中设置的width + border + padding</div><div style="background: #edf9e8;padding:10px;border: 1px solid #c2d2b5;border-radius:5px;margin-bottom:5px;">CSS3盒子模型：盒子的宽度=  CSS中设置的宽度width 里面包含了 border 和 padding</div>也就是说，我们的CSS3中的盒子模型， padding 和 border 不会撑大盒子了```css/*CSS3盒子模型*/box-sizing: border-box;/*传统盒子模型*/box-sizing: content-box;```移动端可以全部CSS3 盒子模型<div style="background: #FFF3F3;padding:10px;border: 1px solid #DEB8BE;border-radius:5px;margin-bottom:5px;">PC端如果完全需要兼容，我们就用传统模式，如果不考虑兼容性，我们就选择 CSS3 盒子模型</div><pre><code class="css">-webkit-box-sizing: border-box              /* CSS3盒模型 */-moz-box-sizing: border-box                 /* CSS3盒模型 */box-sizing: border-box                      /* CSS3盒模型 */</code></pre><h3 id="移动端特殊样式"><a href="#移动端特殊样式" class="headerlink" title="移动端特殊样式"></a>移动端特殊样式</h3><pre><code class="css">/*CSS3盒子模型*/box-sizing: border-box;-webkit-box-sizing: border-box;/*点击高亮我们需要清除清除  设置为transparent 完成透明*/-webkit-tap-highlight-color: transparent;/*在移动端浏览器默认的外观在iOS上加上这个属性才能给按钮和输入框自定义样式*/-webkit-appearance: none;/*禁用长按页面时的弹出菜单*/img,a &#123;  -webkit-touch-callout: none;&#125;</code></pre><h2 id="移动端常见布局"><a href="#移动端常见布局" class="headerlink" title="移动端常见布局"></a>移动端常见布局</h2><h3 id="移动端单独制作"><a href="#移动端单独制作" class="headerlink" title="移动端单独制作"></a>移动端单独制作</h3><div style="background: #edf9e8;padding:10px;border: 1px solid #c2d2b5;border-radius:5px;margin-bottom:5px;">流式布局（百分比布局）</div>流式布局，就是百分比布局，也称非固定像素布局。通过盒子的宽度设置成百分比来根据屏幕的宽度来进行伸缩，不受固定像素的限制，内容向两侧填充。流式布局方式是移动web开发使用的比较常见的布局方式。]]></content>
      
      
      <categories>
          
          <category> Language </category>
          
          <category> CSS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>布局之flex</title>
      <link href="blog/ogynfghwtsa7/"/>
      <url>blog/ogynfghwtsa7/</url>
      
        <content type="html"><![CDATA[<h2 id="1-0-传统布局和-flex-布局对比"><a href="#1-0-传统布局和-flex-布局对比" class="headerlink" title="1.0 传统布局和 flex 布局对比"></a>1.0 传统布局和 flex 布局对比</h2><h3 id="1-1-传统布局"><a href="#1-1-传统布局" class="headerlink" title="1.1 传统布局"></a>1.1 传统布局</h3><ul><li>兼容性好</li><li>布局繁琐</li><li>局限性，不能再移动端很好的布局</li></ul><h3 id="1-2-flex-布局"><a href="#1-2-flex-布局" class="headerlink" title="1.2 flex 布局"></a>1.2 flex 布局</h3><ul><li>操作方便，布局极其简单，移动端使用比较广泛</li><li>pc 端浏览器支持情况比较差</li><li>IE11 或更低版本不支持 flex 或仅支持部分</li></ul><h3 id="1-3-建议"><a href="#1-3-建议" class="headerlink" title="1.3 建议"></a>1.3 建议</h3><ul><li>如果是 pc 端页面布局，还是采用传统方式</li><li>如果是移动端或者是不考虑兼容的 pc 则采用 flex</li></ul><h2 id="2-0-flex-布局原理"><a href="#2-0-flex-布局原理" class="headerlink" title="2.0 flex 布局原理"></a>2.0 flex 布局原理</h2><ul><li>flex 是 flexible Box 的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性，任何一个容器都可以指定为 flex 布局。</li><li>当我们为父盒子设为 flex 布局以后，子元素的 float、clear 和 vertical-align 属性将失效。</li><li>flex 布局又叫伸缩布局 、弹性布局 、伸缩盒布局 、弹性盒布局</li><li>采用 Flex 布局的元素，称为 Flex 容器（flex</li></ul><p>container），简称”容器”。它的所有子元素自动成为容器成员，称为 Flex 项目（flex<br>item），简称”项目”。<br><strong>总结</strong>：就是通过给父盒子添加 flex 属性，来控制子盒子的位置和排列方式</p><h2 id="3-0-父项常见属性"><a href="#3-0-父项常见属性" class="headerlink" title="3.0 父项常见属性"></a>3.0 父项常见属性</h2><ul><li>flex-direction：设置主轴的方向</li><li>justify-content：设置主轴上的子元素排列方式</li><li>flex-wrap：设置子元素是否换行</li><li>align-content：设置侧轴上的子元素的排列方式（多行）</li><li>align-items：设置侧轴上的子元素排列方式（单行）</li><li>flex-flow：复合属性，相当于同时设置了 flex-direction 和 flex-wrap</li></ul><h3 id="3-1-flex-direction-设置主轴的方向"><a href="#3-1-flex-direction-设置主轴的方向" class="headerlink" title="3.1 flex-direction 设置主轴的方向"></a>3.1 flex-direction 设置主轴的方向</h3><ul><li>在 flex 布局中，是分为主轴和侧轴两个方向，同样的叫法有 ： 行和列、x 轴和 y 轴</li><li>默认主轴方向就是 x 轴方向，水平向右</li><li>默认侧轴方向就是 y 轴方向，水平向下</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1615561167817-709457f2-58f3-47b2-82f2-36a27c5ffbac.png#align=left&display=inline&height=227&margin=%5Bobject%20Object%5D&name=image.png&originHeight=453&originWidth=970&size=44867&status=done&style=none&width=485" alt="image.png"></p><ul><li>注意： 主轴和侧轴是会变化的，就看 flex-direction 设置谁为主轴，剩下的就是侧轴。而我们的子元素是跟着主轴来排列的</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1615561179498-b513941e-0741-403e-a156-bf3794692e74.png#align=left&display=inline&height=182&margin=%5Bobject%20Object%5D&name=image.png&originHeight=363&originWidth=927&size=149158&status=done&style=none&width=463.5" alt="image.png"></p><h3 id="3-2-justify-content-设置主轴上的子元素排列方式"><a href="#3-2-justify-content-设置主轴上的子元素排列方式" class="headerlink" title="3.2 justify-content 设置主轴上的子元素排列方式"></a>3.2 justify-content 设置主轴上的子元素排列方式</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1615561189187-37fb2250-6a7a-4b7e-8da7-8bfbed134942.png#align=left&display=inline&height=216&margin=%5Bobject%20Object%5D&name=image.png&originHeight=432&originWidth=1228&size=383001&status=done&style=none&width=614" alt="image.png"></p><h3 id="3-3-flex-wrap-设置是否换行"><a href="#3-3-flex-wrap-设置是否换行" class="headerlink" title="3.3 flex-wrap 设置是否换行"></a>3.3 flex-wrap 设置是否换行</h3><ul><li>默认情况下，项目都排在一条线（又称”轴线”）上。flex-wrap 属性定义，flex 布局中默认是不换行的。</li><li>nowrap 不换行</li><li>wrap 换行</li></ul><h3 id="3-4-align-items-设置侧轴上的子元素排列方式（单行-）"><a href="#3-4-align-items-设置侧轴上的子元素排列方式（单行-）" class="headerlink" title="3.4 align-items 设置侧轴上的子元素排列方式（单行 ）"></a>3.4 align-items 设置侧轴上的子元素排列方式（单行 ）</h3><ul><li>该属性是控制子项在侧轴（默认是 y 轴）上的排列方式 在子项为单项（单行）的时候使用</li><li>flex-start 从头部开始</li><li>flex-end 从尾部开始</li><li>center 居中显示</li><li>stretch 拉伸</li></ul><h3 id="3-5-align-content-设置侧轴上的子元素的排列方式（多行）"><a href="#3-5-align-content-设置侧轴上的子元素的排列方式（多行）" class="headerlink" title="3.5 align-content 设置侧轴上的子元素的排列方式（多行）"></a>3.5 align-content 设置侧轴上的子元素的排列方式（多行）</h3><p>设置子项在侧轴上的排列方式 并且只能用于子项出现 换行 的情况（多行），在单行下是没有效果的。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1615561203043-769de419-37f6-47ac-8a01-7353fb2fbcd4.png#align=left&display=inline&height=271&margin=%5Bobject%20Object%5D&name=image.png&originHeight=541&originWidth=1084&size=429763&status=done&style=none&width=542" alt="image.png"></p><h3 id="3-6-align-content-和-align-items-区别"><a href="#3-6-align-content-和-align-items-区别" class="headerlink" title="3.6 align-content 和 align-items 区别"></a>3.6 align-content 和 align-items 区别</h3><ul><li>align-items 适用于单行情况下， 只有上对齐、下对齐、居中和 拉伸</li><li>align-content 适应于换行（多行）的情况下（单行情况下无效）， 可以设置 上对齐、下对齐、居中、拉伸以及平均分配剩余空间等属性值。</li><li>总结就是单行找 align-items 多行找 align-content</li></ul><h3 id="3-7-flex-flow-属性是-flex-direction-和-flex-wrap-属性的复合属性"><a href="#3-7-flex-flow-属性是-flex-direction-和-flex-wrap-属性的复合属性" class="headerlink" title="3.7 flex-flow 属性是 flex-direction 和 flex-wrap 属性的复合属性"></a>3.7 flex-flow 属性是 flex-direction 和 flex-wrap 属性的复合属性</h3><pre><code>flex-flow:row wrap;</code></pre><h2 id="4-0-flex-布局子项常见属性"><a href="#4-0-flex-布局子项常见属性" class="headerlink" title="4.0 flex 布局子项常见属性"></a>4.0 flex 布局子项常见属性</h2><ul><li>flex 子项目占的份数</li><li>align-self 控制子项自己在侧轴的排列方式</li><li>order 属性定义子项的排列顺序（前后顺序）</li></ul><h3 id="4-1-flex-属性"><a href="#4-1-flex-属性" class="headerlink" title="4.1 flex 属性"></a>4.1 flex 属性</h3><p>flex 属性定义子项目分配剩余空间，用 flex 来表示占多少份数。</p><pre><code>.item &#123;    flex: &lt;number&gt;; /* 默认值 0 */&#125;</code></pre><h3 id="4-2-align-self-控制子项自己在侧轴上的排列方式"><a href="#4-2-align-self-控制子项自己在侧轴上的排列方式" class="headerlink" title="4.2 align-self 控制子项自己在侧轴上的排列方式"></a>4.2 align-self 控制子项自己在侧轴上的排列方式</h3><p>align-self 属性允许单个项目有与其他项目不一样的对齐方式，可覆盖 align-items 属性。<br>默认值为 auto，表示继承父元素的 align-items 属性，如果没有父元素，则等同于 stretch。</p><pre><code>span:nth-child(2) &#123;      /* 设置自己在侧轴上的排列方式 */      align-self: flex-end;&#125;</code></pre><h3 id="4-3-order-属性定义项目的排列顺序"><a href="#4-3-order-属性定义项目的排列顺序" class="headerlink" title="4.3 order 属性定义项目的排列顺序"></a>4.3 order 属性定义项目的排列顺序</h3><p>数值越小，排列越靠前，默认为 0。<br>注意：和 z-index 不一样。</p><pre><code>.item &#123;    order: &lt;number&gt;;&#125;</code></pre><h2 id="5-0-携程网首页案例制作"><a href="#5-0-携程网首页案例制作" class="headerlink" title="5.0 携程网首页案例制作"></a>5.0 携程网首页案例制作</h2><p>携程网链接：<a href="http://m.ctrip.com/">http://m.ctrip.com</a> 1.技术选型<br>方案：我们采取单独制作移动页面方案<br>技术：布局采取 flex 布局 2.搭建相关文件夹<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1615561216425-7cb96807-082c-4f58-a8e6-7fd089ad6c35.png#align=left&display=inline&height=140&margin=%5Bobject%20Object%5D&name=image.png&originHeight=279&originWidth=388&size=95052&status=done&style=none&width=194" alt="image.png"> 3.设置视口标签以及引入初始化样式</p><pre><code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no,initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;css/normalize.css&quot;&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;css/index.css&quot;&gt;</code></pre><p>4.常用初始化样式</p><pre><code>body &#123;  max-width: 540px;  min-width: 320px;  margin: 0 auto;  font: normal 14px/1.5 Tahoma,&quot;Lucida Grande&quot;,Verdana,&quot;Microsoft Yahei&quot;,STXihei,hei;  color: #000;  background: #f2f2f2;  overflow-x: hidden;  -webkit-tap-highlight-color: transparent;&#125;</code></pre><p>5.模块名字划分<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1615561231614-a9ccc256-3219-41a4-a610-588d72137519.png#align=left&display=inline&height=404&margin=%5Bobject%20Object%5D&name=image.png&originHeight=808&originWidth=1035&size=777724&status=done&style=none&width=517.5" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> Language </category>
          
          <category> CSS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CSS/CSS3选择器总结</title>
      <link href="blog/01_html5css3_day01/"/>
      <url>blog/01_html5css3_day01/</url>
      
        <content type="html"><![CDATA[<p>这是加密文章！</p>]]></content>
      
      
      <categories>
          
          <category> Language </category>
          
          <category> CSS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CSS3的2D效果</title>
      <link href="blog/02_html5css3_day02/"/>
      <url>blog/02_html5css3_day02/</url>
      
        <content type="html"><![CDATA[<p>这是加密文章！</p>]]></content>
      
      
      <categories>
          
          <category> Language </category>
          
          <category> CSS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CSS3的3D效果</title>
      <link href="blog/03_html5css3_day03/"/>
      <url>blog/03_html5css3_day03/</url>
      
        <content type="html"><![CDATA[<p>这是加密文章！</p>]]></content>
      
      
      <categories>
          
          <category> Language </category>
          
          <category> CSS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JAVA当中栈和队列常用方法</title>
      <link href="blog/oylyeh/"/>
      <url>blog/oylyeh/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Java 里有一个叫做 Stack 的类，却没有叫做 Queue 的类（它是个接口名字）。当需要使用栈时，Java 已不推荐使用 Stack，而是推荐使用更高效的 ArrayDeque；</p></blockquote><blockquote><p>既然 Queue 只是一个接口，当需要使用队列时也就首选 ArrayDeque 了（次选是 LinkedList）。</p></blockquote><h2 id="队列常用方法"><a href="#队列常用方法" class="headerlink" title="队列常用方法"></a>队列常用方法</h2><blockquote><p>初始化</p></blockquote><pre><code class="java">import java.util.LinkedList;import java.util.Queue;Queue&lt;Integer&gt; queue_input = new LinkedList&lt;&gt;();</code></pre><table><thead><tr><th>Queue Method</th><th>Equivalent Deque Method</th><th>说明</th></tr></thead><tbody><tr><td>add(e)</td><td>addLast(e)</td><td>向队尾插入元素，失败则抛出异常</td></tr><tr><td>offer(e)</td><td>offerLast(e)</td><td>向队尾插入元素，失败则返回 false，offer(E e)操作是专为容量受限的队列实现而设计的，在大多数实现中，插入操作不会失败</td></tr><tr><td>remove()</td><td>removeFirst()</td><td>获取并删除队首元素，失败则抛出异常</td></tr><tr><td>poll()</td><td>pollFirst()</td><td>获取并删除队首元素，失败则返回 null</td></tr><tr><td>element()</td><td>getFirst()</td><td>获取但不删除队首元素，失败则抛出异常</td></tr><tr><td>peek()</td><td>peekFirst()</td><td>获取但不删除队首元素，失败则返回 null</td></tr></tbody></table><h2 id="栈常用方法"><a href="#栈常用方法" class="headerlink" title="栈常用方法"></a>栈常用方法</h2><table><thead><tr><th>Stack Method</th><th>Equivalent Deque Method</th><th>说明</th></tr></thead><tbody><tr><td>push(e)</td><td>addFirst(e)</td><td>向栈顶插入元素，失败则抛出异常</td></tr><tr><td>无</td><td>offerFirst(e)</td><td>向栈顶插入元素，失败则返回 false</td></tr><tr><td>pop()</td><td>removeFirst()</td><td>获取并删除栈顶元素，失败则抛出异常</td></tr><tr><td>无</td><td>pollFirst()</td><td>获取并删除栈顶元素，失败则返回 null</td></tr><tr><td>peek()</td><td>peekFirst()</td><td>获取但不删除栈顶元素，失败则抛出异常</td></tr><tr><td>无</td><td>peekFirst()</td><td>获取但不删除栈顶元素，失败则返回 null</td></tr></tbody></table><h2 id="关于-ArrayDeque"><a href="#关于-ArrayDeque" class="headerlink" title="关于 ArrayDeque"></a>关于 ArrayDeque</h2><blockquote><p>ArrayDeque 和 LinkedList 是 Deque 的两个通用实现，由于官方更推荐使用 AarryDeque 用作栈和队列，<br>从名字可以看出 ArrayDeque 底层通过数组实现，为了满足可以同时在数组两端插入或删除元素的需求，该数组还必须是循环的，即循环数组（circular array），也就是说数组的任何一点都可能被看作起点或者终点。ArrayDeque 是非线程安全的（not thread-safe），当多个线程同时使用的时候，需要程序员手动同步；另外，该容器不允许放入 null 元素。</p></blockquote><pre><code class="java">import java.util.*;public class ArrayDequeStack &#123;    public static void main(String[] args) &#123;        ArrayDeque stack = new ArrayDeque();        // 依次将三个元素push入“栈”，先进后出        stack.push(&quot;疯狂Java讲义&quot;);        stack.push(&quot;轻量级Java EE企业应用实战&quot;);        stack.push(&quot;疯狂Android讲义&quot;);        System.out.println(stack); // [疯狂Android讲义, 轻量级Java EE企业应用实战, 疯狂Java讲义]        System.out.println(stack.peek()); // 疯狂Android讲义        System.out.println(stack); // [疯狂Android讲义, 轻量级Java EE企业应用实战, 疯狂Java讲义]        System.out.println(stack.pop()); // 疯狂Android讲义        System.out.println(stack);//[轻量级Java EE企业应用实战, 疯狂Java讲义]        // 当做队列来使用,先进先出        ArrayDeque queue = new ArrayDeque();        queue.offer(&quot;疯狂Java讲义&quot;);        queue.offer(&quot;轻量级JavaEE企业应用实践&quot;);        queue.offer(&quot;疯狂Android讲义&quot;);        System.out.println(queue); //[疯狂Java讲义, 轻量级JavaEE企业应用实践, 疯狂Android讲义]        // 访问队列头部元素，但不将其poll出队列        System.out.println(queue.peek());        System.out.println(queue);        // poll出第一个元素        System.out.println(queue.poll());        System.out.println(queue);// [轻量级JavaEE企业应用实践, 疯狂Android讲义]    &#125;&#125;</code></pre><pre><code>[疯狂Android讲义, 轻量级Java EE企业应用实战, 疯狂Java讲义]疯狂Android讲义[疯狂Android讲义, 轻量级Java EE企业应用实战, 疯狂Java讲义]疯狂Android讲义[轻量级Java EE企业应用实战, 疯狂Java讲义][疯狂Java讲义, 轻量级JavaEE企业应用实践, 疯狂Android讲义]疯狂Java讲义[疯狂Java讲义, 轻量级JavaEE企业应用实践, 疯狂Android讲义]疯狂Java讲义[轻量级JavaEE企业应用实践, 疯狂Android讲义]</code></pre><p>例子参考：<a href="https://www.cnblogs.com/jiqing9006/p/6107491.html">https://www.cnblogs.com/jiqing9006/p/6107491.html</a></p>]]></content>
      
      
      <categories>
          
          <category> DataStructure </category>
          
          <category> 线结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>P225/232. 队列和栈的相互实现</title>
      <link href="blog/le21wf/"/>
      <url>blog/le21wf/</url>
      
        <content type="html"><![CDATA[<p>简单实现一下，熟悉一下写题目，这几天找找状态……<img src="https://cdn.nlark.com/yuque/0/2021/gif/1484158/1615278756585-fb0d9f38-8031-472f-9a19-8545be93a548.gif#align=left&display=inline&height=100&margin=%5Bobject%20Object%5D&name=huaji-6f8ff8999ff5ed9a.gif&originHeight=100&originWidth=100&size=12637&status=done&style=none&width=100" alt="huaji-6f8ff8999ff5ed9a.gif"></p><h2 id="P232-栈实现队列"><a href="#P232-栈实现队列" class="headerlink" title="P232. 栈实现队列"></a>P232. 栈实现队列</h2><pre><code class="java">package com.wztlink1013.problems.leetcode.editor.cn;// P232.用栈实现队列// P232.implement-queue-using-stacks//请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（push、pop、peek、empty）：//// 实现 MyQueue 类：////// void push(int x) 将元素 x 推到队列的末尾// int pop() 从队列的开头移除并返回元素// int peek() 返回队列开头的元素// boolean empty() 如果队列为空，返回 true ；否则，返回 false////////// 说明：////// 你只能使用标准的栈操作 —— 也就是只有 push to top, peek/pop from top, size, 和 is empty 操作是合法的。//// 你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。////////// 进阶：////// 你能否实现每个操作均摊时间复杂度为 O(1) 的队列？换句话说，执行 n 个操作的总时间复杂度为 O(n) ，即使其中一个操作可能花费较长时间。////////// 示例：//////输入：//[&quot;MyQueue&quot;, &quot;push&quot;, &quot;push&quot;, &quot;peek&quot;, &quot;pop&quot;, &quot;empty&quot;]//[[], [1], [2], [], [], []]//输出：//[null, null, null, 1, 1, false]////解释：//MyQueue myQueue = new MyQueue();//myQueue.push(1); // queue is: [1]//myQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue)//myQueue.peek(); // return 1//myQueue.pop(); // return 1, queue is [2]//myQueue.empty(); // return false//////////////// 提示：////// 1 &lt;= x &lt;= 9// 最多调用 100 次 push、pop、peek 和 empty// 假设所有操作都是有效的 （例如，一个空的队列不会调用 pop 或者 peek 操作）//// Related Topics 栈 设计// 👍 361 👎 0import java.util.Stack;public class P232ImplementQueueUsingStacks&#123;    public void main(String[] args) &#123;        MyQueue myQueue = new MyQueue();        //本地调试需要将MyQueue类和主函数加上静态static修饰字        //具体解释：https://www.cnblogs.com/dolphin0520/p/3799052.html        myQueue.push(1); // queue is: [1]        myQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue)        myQueue.pop();        myQueue.peek();//        myQueue.peek(); // return 1//        myQueue.pop(); // return 1, queue is [2]//        myQueue.empty(); // return false//        System.out.println(myQueue);    &#125;//leetcode submit region begin(Prohibit modification and deletion)class MyQueue &#123;    Stack&lt;Integer&gt; stack_input = new Stack&lt;&gt;();    Stack&lt;Integer&gt; stack_output = new Stack&lt;&gt;();    /** Initialize your data structure here. */    public MyQueue() &#123;//        Stack&lt;Integer&gt; stack_input = new Stack&lt;&gt;();//        Stack&lt;Integer&gt; stack_output = new Stack&lt;&gt;();    &#125;    /** Push element x to the back of queue. */    public void push(int x) &#123;        stack_input.push(x);        int temp = stack_input.size();        if (stack_output.size() == 0) &#123;            for (int i=0; i&lt;temp; i++)&#123;                stack_output.push(stack_input.pop());            &#125;        &#125;    &#125;    /** Removes the element from in front of queue and returns that element. */    public int pop() &#123;        int temp = stack_input.size();        if (stack_output.size() == 0) &#123;            for (int i=0; i&lt;temp; i++)&#123;                stack_output.push(stack_input.pop());            &#125;        &#125;        return stack_output.pop();    &#125;    /** Get the front element. */    public int peek() &#123;        int temp = stack_input.size();        if (stack_output.size() == 0) &#123;            for (int i=0; i&lt;temp; i++)&#123;                stack_output.push(stack_input.pop());            &#125;        &#125;        return stack_output.peek();    &#125;    /** Returns whether the queue is empty. */    public boolean empty() &#123;        if (stack_input.size() == 0 &amp;&amp; stack_output.size() == 0) &#123;            return true;        &#125;        return false;    &#125;&#125;/** * Your MyQueue object will be instantiated and called as such: * MyQueue obj = new MyQueue(); * obj.push(x); * int param_2 = obj.pop(); * int param_3 = obj.peek(); * boolean param_4 = obj.empty(); *///leetcode submit region end(Prohibit modification and deletion)&#125;</code></pre><h2 id="P225-队列实现栈"><a href="#P225-队列实现栈" class="headerlink" title="P225. 队列实现栈"></a>P225. 队列实现栈</h2><pre><code class="java">package com.wztlink1013.problems.leetcode.editor.cn;// P225.用队列实现栈// P225.implement-stack-using-queues//请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通队列的全部四种操作（push、top、pop 和 empty）。//// 实现 MyStack 类：////// void push(int x) 将元素 x 压入栈顶。// int pop() 移除并返回栈顶元素。// int top() 返回栈顶元素。// boolean empty() 如果栈是空的，返回 true ；否则，返回 false 。////////// 注意：////// 你只能使用队列的基本操作 —— 也就是 push to back、peek/pop from front、size 和 is empty 这些操作。// 你所使用的语言也许不支持队列。 你可以使用 list （列表）或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。////////// 示例：//////输入：//[&quot;MyStack&quot;, &quot;push&quot;, &quot;push&quot;, &quot;top&quot;, &quot;pop&quot;, &quot;empty&quot;]//[[], [1], [2], [], [], []]//输出：//[null, null, null, 2, 2, false]////解释：//MyStack myStack = new MyStack();//myStack.push(1);//myStack.push(2);//myStack.top(); // 返回 2//myStack.pop(); // 返回 2//myStack.empty(); // 返回 False////////// 提示：////// 1 &lt;= x &lt;= 9// 最多调用100 次 push、pop、top 和 empty// 每次调用 pop 和 top 都保证栈不为空////////// 进阶：你能否实现每种操作的均摊时间复杂度为 O(1) 的栈？换句话说，执行 n 个操作的总时间复杂度 O(n) ，尽管其中某个操作可能需要比其他操作更长的//时间。你可以使用两个以上的队列。// Related Topics 栈 设计// 👍 291 👎 0import java.util.LinkedList;import java.util.Queue;public class P225ImplementStackUsingQueues&#123;    public void main(String[] args) &#123;//        Solution solution = new P225ImplementStackUsingQueues().new Solution();    &#125;//leetcode submit region begin(Prohibit modification and deletion)class MyStack &#123;    Queue&lt;Integer&gt; queue_input = new LinkedList&lt;&gt;();    Queue&lt;Integer&gt; queue_output = new LinkedList&lt;&gt;();    /** Initialize your data structure here. */    public MyStack() &#123;    &#125;    /** Push element x onto stack. */    public void push(int x) &#123;        queue_input.add(x);    &#125;    /** Removes the element on top of the stack and returns that element. */    public int pop() &#123;        int temp_2 = queue_input.size();        for (int i=0; i&lt;temp_2; i++) &#123;            queue_output.add(queue_input.remove());        &#125;        int temp_3 = queue_output.size();        for (int i=0; i&lt;temp_3-1; i++) &#123;            queue_input.add(queue_output.remove());        &#125;        return queue_output.remove();    &#125;    /** Get the top element. */    public int top() &#123;        int top = 0;        int temp_4 = queue_input.size();        for (int i=0; i&lt;temp_4; i++) &#123;            queue_output.add(queue_input.remove());        &#125;        int temp_5 = queue_output.size();        for (int i=0; i&lt;temp_5; i++) &#123;            if (i == temp_5-1) &#123;                top = queue_output.element();            &#125;            queue_input.add(queue_output.remove());        &#125;        return top;    &#125;    /** Returns whether the stack is empty. */    public boolean empty() &#123;        if (queue_input.size() == 0 &amp;&amp; queue_output.size() == 0) &#123;            return true;        &#125;        return false;    &#125;&#125;/** * Your MyStack object will be instantiated and called as such: * MyStack obj = new MyStack(); * obj.push(x); * int param_2 = obj.pop(); * int param_3 = obj.top(); * boolean param_4 = obj.empty(); *///leetcode submit region end(Prohibit modification and deletion)&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> DataStructure </category>
          
          <category> Problems </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[转]Web前端开发规范手册</title>
      <link href="blog/hzgils/"/>
      <url>blog/hzgils/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.yuque.com/attachments/yuque/0/2021/doc/1484158/1615198335419-0cd2d26e-1dba-443a-b5d5-bd14b66a5aa7.doc?_lake_card=%7B%22uid%22:%221615198334226-0%22,%22src%22:%22https://www.yuque.com/attachments/yuque/0/2021/doc/1484158/1615198335419-0cd2d26e-1dba-443a-b5d5-bd14b66a5aa7.doc%22,%22name%22:%22Web%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83%E6%89%8B%E5%86%8C.doc%22,%22size%22:190976,%22type%22:%22application/msword%22,%22ext%22:%22doc%22,%22progress%22:%7B%22percent%22:99%7D,%22status%22:%22done%22,%22percent%22:0,%22id%22:%22y3HBz%22,%22card%22:%22file%22%7D">Web 前端开发规范手册.doc</a> **</p><h2 id="一、规范目的"><a href="#一、规范目的" class="headerlink" title="一、规范目的**"></a>一、规范目的**</h2><p>为提高团队协作效率, 便于后台人员添加功能及前端后期优化维护, 输出高质量的文档, 特制订此文档. 本规范文档一经确认,前端开发人员必须按本文档规范进行前台页面开发. 本文档如有不对或者不合适的地方请及时提出, 经讨论决定后可以更改此文档.</p><h2 id="二、文件规范"><a href="#二、文件规范" class="headerlink" title="二、文件规范"></a>二、文件规范</h2><h3 id="文件命名规则"><a href="#文件命名规则" class="headerlink" title="文件命名规则"></a>文件命名规则</h3><p>文件名称统一用小写的英文字母、数字和下划线的组合，其中不得包含汉字、空格和特殊字符；命名原则的指导思想一是使得你自己和工作组的每一个成员能够方便的理解每一个文件的意义，二是当我们在文件夹中使用“按名称排例”的命令时，同一种大类的文件能够排列在一起，以便我们查找、修改、替换、计算负载量等等操作。</p><h4 id="HTML-的命名原则"><a href="#HTML-的命名原则" class="headerlink" title="HTML 的命名原则"></a>HTML 的命名原则</h4><p>引文件统一使用<code>index.htm index.html index.asp</code>文件名（小写）<br>各子页命名的原则首先应该以栏目名的英语翻译取单一单词为名称</p><blockquote><p>关于我们 \ aboutus<br>信息反馈 \ feedback<br>产 品 \ product</p></blockquote><p>如果栏目名称多而复杂并不好以英文单词命名，则统一使用该栏目名称拼音或拼音的首字母表示；<br>每一个目录中应该包含一个缺省的 html 文件，文件名统一用<code>index.htm index.html index.asp</code>；</p><h4 id="图片的命名原则"><a href="#图片的命名原则" class="headerlink" title="图片的命名原则"></a>图片的命名原则</h4><p>图片的名称分为头尾两部分，用下划线隔开，头部分表示此图片的大类性质<br>例如：广告、标志、菜单、按钮等等。<br>放置在页面顶部的广告、装饰图案等长方形的图片取名： banner<br>标志性的图片取名为： logo<br>在页面上位置不固定并且带有链接的小图片我们取名为 button<br>在页面上某一个位置连续出现，性质相同的链接栏目的图片我们取名： menu<br>装饰用的照片我们取名： pic<br>不带链接表示标题的图片我们取名： title<br>范例：<code>banner_sohu.gif banner_sina.gif menu_aboutus.gif menu_job.gif title_news.gif logo_police.gif logo_national.gif pic_people.jpg</code>鼠标感应效果图片命名规范为”图片名+_+on/off”。<br>例如：<code>menu1_on.gif menu1_off.gif</code></p><h4 id="javascript-的命名原则"><a href="#javascript-的命名原则" class="headerlink" title="javascript 的命名原则"></a>javascript 的命名原则</h4><p>例如：广告条的 javascript 文件名为 ad.js  弹出窗口的 javascript 文件名为 pop.js</p><h4 id="动态语言文件命名原则"><a href="#动态语言文件命名原则" class="headerlink" title="动态语言文件命名原则"></a>动态语言文件命名原则</h4><p>以性质<em>描述，描述可以有多个单词，用“</em>”隔开，性质一般是该页面得概要。<br>范例：<code>register_form.asp register_post.asp topic_lock.asp</code>**</p><h3 id="文件存放位置规范"><a href="#文件存放位置规范" class="headerlink" title="文件存放位置规范"></a>文件存放位置规范</h3><p>** **</p><table><thead><tr><th>_Root</th><th></th><th></th></tr></thead><tbody><tr><td></td><td>cn</td><td>存放中文 HTML 文件</td></tr><tr><td></td><td>en</td><td>存放英文 HTML 文件</td></tr><tr><td></td><td>flash</td><td>存放 Flash 文件</td></tr><tr><td></td><td>images</td><td>存放图片文件</td></tr><tr><td></td><td>imagestudio</td><td>存放 PSD 源文件</td></tr><tr><td></td><td>flashstudio</td><td>存放 flash 源文件</td></tr><tr><td></td><td>inc</td><td>存放 include 文件</td></tr><tr><td></td><td>library</td><td>存放 DW 库文件</td></tr><tr><td></td><td>media</td><td>存放多媒体文件</td></tr><tr><td></td><td>project</td><td>存放工程项目资料</td></tr><tr><td></td><td>temp</td><td>存放客户原始资料</td></tr><tr><td></td><td>js</td><td>存放 JavaScript 脚本</td></tr><tr><td></td><td>css</td><td>存放 CSS 文件</td></tr></tbody></table><p>** **<br>** **</p><h3 id="CSS-书写规范"><a href="#CSS-书写规范" class="headerlink" title="CSS 书写规范"></a>CSS 书写规范</h3><p>*<strong>*基本原则： **<br>** **<br>CSS 样式可细分为 3 类：自定义样式、重新定义 HTML 样式、链接状态样式。 1.样式为设计师自定义的新 CSS 样式，影响被使用本样式的区域，用于完成网页中局部的样式设定。样式名 “</strong>.<strong>”+“相应样式效果描述的单词或缩写”例：“ <strong>.shadow</strong> ”<br>文字样式样式名“</strong>.<strong>no”+“字号”+“行距”+“颜色缩写”例：“</strong>.no12** ”** <strong>、“ <strong>.no12-24</strong> ” 2. 义 HTML 样式为设计师重新定义已有的 HTML 标签样式，影响全部的被设定标签样式，用于统一网页中某一标签的样式定义。样式名“HTML 标签”例：</strong>hr { border: 1px dotted #333333 }** 3. 态样式为设计师对链接不同状态设定特殊样式，影响被使用本样式区域中的链接。<br>该样式写法有 2 种： a.nav:link   nav.a:link  第一种只能修饰**<a><strong>标签中；第二种可以修饰所有包含有</strong><a>**标签的其他标签。<br>页面内的样式加载必须用链接方式<link rel="stylesheet" type="text/css" href="style/style.css"></p><p><strong>注意细则：</strong></p><p>1.     协作开发及分工: i 会根据各个模块, 同时根据页面相似程序, 事先写好大体框架文件, 分配给前端人员实现内部结构&amp;表现&amp;行为; 共用 css 文件 base.css 由 i 书写, 协作开发过程中, 每个页面请务必都要引入, 此文件包含 reset 及头部底部样式,此文件不可随意修改;<br>2.     class 与 id 的使用: id 是唯一的并是父级的, class 是可以重复的并是子级的, 所以 id 仅使用在大的模块上, class 可用在重复使用率高及子级中; id 原则上都是由我分发框架文件时命名的, 为 JavaScript 预留钩子的除外;<br>3.     为 JavaScript 预留钩子的命名, 请以 js* 起始, 比如: js_hide, js_show;<br>4.     class 与 id 命名: 大的框架命名比如 header/footer/wrapper/left/right 之类的在 2 中由 i 统一命名.其他样式名称由 小写英文&amp; 数字 &amp; * 来组合命名, 如 i_comment, fontred, width200; 避免使用中文拼音, 尽量使用简易的单词组合; 总之, 命名要语义化, 简明化.<br>5.     规避 class 与 id 命名(此条重要, 若有不明白请及时与 i 沟通): <br>a, 通过从属写法规避, 示例见 d;<br>b, 取父级元素 id/class 命名部分命名, 示例见 d;<br>c, 重复使用率高的命名, 请以自己代号加下划线起始, 比如 i_clear;<br>d, a,b 两条, 适用于在 2 中已建好框架的页面, 如, 要在 2 中已建好框架的页面代码<div id="mainnav"></div>中加入新的 div 元素,<br>按 a 命名法则: <div id="mainnav"><div class="firstnav">…</div></div>,<br>样式写法:  #mainnav .firstnav{…….}<br>按 b 命名法则: <div id="mainnav"><div class="main_firstnav">…</div></div>,<br>样式写法: .main_firstnav{…….}<br>6.     css 属性书写顺序, 建议遵循 布局定位属性–&gt;自身属性–&gt;文本属性–&gt;其他属性.此条可根据自身习惯书写, 但尽量保证同类属性写在一起. 属性列举: 布局定位属性主要包括: margin、padding、float（包括 clear）、position（相应的 top,right,bottom,left）、display、visibility、overflow 等；自身属性主要包括: width &amp; height &amp; background &amp; border; 文本属性主要包括：font、color、text-align、text-decoration、text-indent 等；其他属性包括: list-style(列表样式)、vertical-vlign、cursor、z-index(层叠顺序)、zoom 等.我所列出的这些属性只是最常用到的, 并不代表全部;<br>7.     书写代码前, 考虑并提高样式重复使用率;<br>8.     充分利用 html 自身属性及样式继承原理减少代码量, 比如:</p><ul class="list"><li>这儿是标题列表<span>2010-09-15</span></ul>定义ul.list li{position:relative}  ul.list li span{position:absolute; right:0}即可实现日期居右显示9.     样式表中中文字体名, 请务必转码成unicode码, 以避免编码错误时乱码;10.   背景图片请尽可能使用sprite技术, 减小http请求, 考虑到多人协作开发, sprite按模块制作;11.   使用table标签时(尽量避免使用table标签), 请不要用width/ height/cellspacing/cellpadding等table属性直接定义表现, 应尽可能的利用table自身私有属性分离结构与表现, 如thead,tr,th,td,tbody,tfoot,colgroup,scope; (cellspaing及cellpadding的css控制方法: table{border:0;margin:0;border-collapse:collapse;} table th, table td{padding:0;} , base.css文件中我会初始化表格样式)12.   杜绝使用<meta http-equiv="X-UA-Compatible" content="IE=7" /> 兼容ie8;13.   用png图片做图片时, 要求图片格式为png-8格式,若png-8实在影响图片质量或其中有半透明效果, 请为ie6单独定义背景:background:none;_filter:progid:DXImageTransform.Microsoft.AlphaImageLoader(sizingMethod=crop, src=’img/bg.png’);14.   避免兼容性属性的使用, 比如text-shadow || css3的相关属性;15.   减少使用影响性能的属性, 比如position:absolute || float ;16.   必须为大区块样式添加注释, 小区块适量注释;17.   代码缩进与格式: 建议单行书写, 可根据自身习惯, 后期优化i会统一处理;  **命名规则：<p>*_<br>头：header<br>  内容：content/container<br>  尾：footer<br>  导航：nav<br>  侧栏：sidebar<br>  栏目：column<br>  页面外围控制整体布局宽度：wrapper<br>  左右中：left right center<br>  登录条：loginbar<br>  标志：logo<br>  广告：banner<br>  页面主体：main<br>  热点：hot<br>  新闻：news<br>  下载：download<br>  子导航：subnav<br>  菜单：menu<br>  子菜单：submenu<br>  搜索：search<br>  友情链接：friendlink<br>  页脚：footer<br>  版权：copyright<br>  滚动：scroll<br>  内容：content<br>  标签页：tab<br>  文章列表：list<br>  提示信息：msg<br>  小技巧：tips<br>  栏目标题：title<br>  加入：joinus<br>  指南：guild<br>  服务：service<br>  注册：regsiter<br>  状态：status<br>  投票：vote<br>  合作伙伴：partner<br>(二)注释的写法:<br>  /_ Footer <em>/<br>  内容区<br>  /</em> End Footer */<br>(三)id 的命名:<br>  (1)页面结构<br>  容器: container<br>  页头：header<br>  内容：content/container<br>  页面主体：main<br>  页尾：footer<br>  导航：nav<br>  侧栏：sidebar<br>  栏目：column<br>  页面外围控制整体布局宽度：wrapper<br>  左右中：left right center</p><p>(2)导航<br>  导航：nav<br>  主导航：mainbav<br>  子导航：subnav<br>  顶导航：topnav<br>  边导航：sidebar<br>  左导航：leftsidebar<br>  右导航：rightsidebar<br>  菜单：menu<br>  子菜单：submenu<br>  标题: title<br>  摘要: summary</p><p>(3)功能<br>  标志：logo<br>  广告：banner<br>  登陆：login<br>  登录条：loginbar<br>  注册：regsiter<br>  搜索：search<br>  功能区：shop<br>  标题：title<br>  加入：joinus<br>  状态：status<br>  按钮：btn<br>  滚动：scroll<br>  标签页：tab<br>  文章列表：list<br>  提示信息：msg<br>  当前的: current<br>  小技巧：tips<br>  图标: icon<br>  注释：note<br>  指南：guild<br>  服务：service<br>  热点：hot<br>  新闻：news<br>  下载：download<br>  投票：vote<br>  合作伙伴：partner<br>  友情链接：link<br>  版权：copyright\</p><p>**基本样式： **</p><pre><code class="cpp">/* CSS Document */body &#123;margin:0; padding:0; font:12px &quot;\5B8B\4F53&quot;,san-serif;background:#fff;&#125;div,dl,dt,dd,ul,ol,li,h1,h2,h3,h4,h5,h6,pre,form,fieldset,input,textarea,blockquote,p&#123;padding:0; margin:0;&#125;table,td,tr,th&#123;font-size:12px;&#125;li&#123;list-style-type:none;&#125;img&#123;vertical-align:top;border:0;&#125;ol,ul &#123;list-style:none;&#125;h1,h2,h3,h4,h5,h6 &#123;font-size:12px; font-weight:normal;&#125;address,cite,code,em,th &#123;font-weight:normal; font-style:normal;&#125;.fB&#123;font-weight:bold;&#125;.f12px&#123;font-size:12px;&#125;.f14px&#123;font-size:14px;&#125;.left&#123;float:left;&#125;.right&#123;float:right;&#125;a &#123;color:#2b2b2b; text-decoration:none;&#125;a:visited &#123;text-decoration:none;&#125;a:hover &#123;color:#ba2636;text-decoration:underline;&#125;a:active &#123;color:#ba2636;&#125;</code></pre><p>重定义的最先，伪类其次，自定义最后，便于自己和他人阅读！</p><p>不同浏览器上字号保持一致，字号建议用点数 pt 和像素 px 来定义，pt 一般使用中文宋体的 9pt  和 11pt，px 一般使用中文宋体 12px  和 14.7px  这是经过优化的字号，黑体字或者宋体字加粗时，一般选用 11pt  和 14.7px  的字号比较合适。中英文混排时，我们尽可能的将英文和数字定义为 verdana  和 arial  两种字体。<br>** **<br>** **</p><h3 id="html-书写规范"><a href="#html-书写规范" class="headerlink" title="html 书写规范"></a>html 书写规范</h3><p>**1.       网页制作细节 —- head 区代码规范 **<br>head 区是指 HTML 代码的<head>和</head>之间的内容。<br>必须加入的标签<br>a)       公司版权注释   <!--- The site is designed by EHM,Inc 07/2005 ---><br>b)       网页显示字符集<br>简体中文：<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=gb2312"><br>繁体中文：<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8"><br>英 语：<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8"><br>c)       网页制作者信息   <META name="author" content="webmaster@maketown.com"><br>d)       网站简介   <META NAME="DESCRIPTION" CONTENT="xxxxxxxxxxxxxxxxxxxxxxxxxx"><br>e)       搜索关键字   <META NAME="keywords" CONTENT="xxxx,xxxx,xxx,xxxxx,xxxx,"><br>f)        网页的 css 规范 <LINK href="../css/style.css" rel="stylesheet" type="text/css"><br>g)       网页标题   <title>xxxxxxxxxxxxxxxxxx</title><br>可以选择加入的标签<br>a)       设定网页的到期时间。一旦网页过期，必须到服务器上重新调阅。</p><META HTTP-EQUIV="expires" CONTENT="Wed, 26 Feb 1997 08：21：57 GMT"> b)      禁止浏览器从本地机的缓存中调阅页面内容。<META HTTP-EQUIV="Pragma" CONTENT="no-cache">c)      用来防止别人在框架里调用你的页面。<META HTTP-EQUIV="Window-target" CONTENT="_top">d)      自动跳转。<META HTTP-EQUIV="Refresh" CONTENT="5;URL=http：//www.yahoo.com">  5指时间停留5秒e)      网页搜索机器人向导。用来告诉搜索机器人哪些页面需要索引，哪些页面不需要索引。<META NAME="robots" CONTENT="none">CONTENT的参数有all,none,index,noindex,follow,nofollow。默认是all。 f)       收藏夹图标  <link rel = "Shortcut Icon" href="favicon.ico">g)      所有的javascript的调用尽量采取外部调用. <SCRIPT LANGUAGE="JavaScript" SRC="script/xxxxx.js"></SCRIPT> h)      附<body>标签： <body>标签不属于head区，这里强调一下，为了保证浏览器的兼容性，必须设置页面背景<body bgcolor="#FFFFFF"><p><strong>2.       网页制作细节 —- 字体</strong><br><strong>1. <strong>在设定字体样式时对于</strong>文字字号样式</strong>和<strong>行间距</strong>应必须使用 CSS 样式表。禁止在页面中出现 <font size=?> 标记。</p><p>**2.**在网页中中文应首选使用宋体。英文和数字首选使用 verdana  和 arial  两种字体。一般使用中文宋体的 9pt  和 11pt 或 12px  和 14.7px  这是经过优化的字号，黑体字或者宋体字加粗时，一般选用 11pt  和 14.7px  的字号比较合适。</p><p>**3. **为了最大程度的发挥浏览器自动排版的功能，在一段完整的文字中请尽量不要使用<br> 来人工干预分段。</p><p>**4.**不同语种的文字之间应该有一个半角空格，但避头的符号之前和避尾的符号之后除外，汉字之间的标点要用全角标点，英文字母和数字周围的括号应该使用半角括号。</p><p>**5. **请不要在网页中连续出现多于一个的    也尽量少使用全角空格（英文字符集下，全角空格会变成乱码），空白应该尽量使用 text-indent, padding, margin, hspace, vspace 以及透明的 gif 图片来实现。</p><p>**6. **行距建议用百分比来定义，常用的两个行距的值是 line-height:120%/150%.</p><p>**7. **排版中我们经常会遇到需要进行首行缩进的处理，不要使用    或者全角空格来达到效果，规范的做法是在样式表中定义 p { text-indent: 2em; } 然后给每一段加上 <p> 标记，注意，一般情况下，请不要省略 </p> 结束标记 。</p><p><strong>3.       网页制作细节 —- 链接</strong><br>**1. **网站中的链接路径全部采用相对路径，一般链接到某一目录下的缺省文件的链接路径不必写全名，如我们不必这样：<a href=”aboutus/index.htm”> 而应该这样：<a href=”aboutus/”>，所有内页指向首页的链接写成<a href=”/”></p><p>**2. **在浏览器里，当我们点击空链接时，它会自动将当前页面重置到首端，从而影响用户正常的阅读内容，我们用代码“javascript:void(null)”代替原来的“#”标记</p><p><strong>4.       网页制作细节 —- 表格</strong><br>1px 表格 style=”border-collapse: collapse”<br>实例如下：</p><table border="1" cellspacing="0" width="32" height="32" style="border-collapse: collapse"bordercolor="#000000" cellpadding="0"> <tr> <td></td></tr></table>设置亮、暗边框颜色表格有亮边框（bordercolorlight）和暗边框（bordercolordark）两个属性可以对表格样式设置。<table border="1" width="500" bordercolorlight="#000000" bordercolordark="#FFFFFF"><p>在写 <table> 互相嵌套时，严格按照的规范，对于单独的一个<table>来说，<table><tr>对齐，<td> 缩进两个半角空格，<td> 中如果还有嵌套的表格，<table>也缩进两个半角空格，如果<td>中没有任何嵌套的表格，</td> 结束标记应该与 <td> 处于同一行，不要换行，<br>如我们注意在源代码中不应有这样的代码：<br>**<td><img src=\*\***”../images/sample.gif”> **<br><strong></td></strong><br>而应该是这样的：<br><strong><td><img src=\*\***”../images/sample.gif”></td></strong><br>这是因为浏览器认为换行相当于一个半角空格，以上不规范的写法相当于无意中增加一个半角空格，如果确实有必要增加一个半角空格，也应该这样写：<br>**<td><img src=****”../images/sample.gif”> </td></p><p>**一个网页要尽量避免用整个一张大表格，所有的内容都嵌套在这个大表格之内，因为浏览器在解释页面的元素时，是以表格为单位逐一显示，如果一张网页是嵌套在一个大表格之内，那么很可能造成的后果就是，当浏览者敲入网址，他要先面对一片空白很长时间，然后所有的网页内容同时出现。如果必须这样做，请使用 <tbody>标记，以便能够使这个大表格分块显示</p><p><strong>5.       网页制作细节 —- 下载速度</strong><br>首页 Flash 网页大小应限定在 200K 以下，尽可能的使用矢量图形和<strong>Action</strong>来减小动画大小。非首页静态页面含图片大小应限定在 70K 左右，尽可能的使用背景颜色替换大块同色图片。</p><p><strong>6.       网页制作细节 —- include</strong><br>asp 标准写法<!--#include file="inc/index_top.asp" --><br>jsp 标准写法 &lt;%@ include file=”../inc/index_top..jsp” %&gt;</p><p><strong>7.       网页制作细节 —- Alt 和 Title</strong> <br>都是提示性语言标签，请注意它们之间的区别。 <br>在我们浏览网页时，当鼠标停留在图片对象或文字链接上时，在鼠标的右下角有时会出现一个提示信息框。对目标进行一定的注释说明。在一些场合，它的作用是很重要的。<br>alt 用来给图片来提示的。Title 用来给链接文字或普通文字提示的。<br>用法如下：</p><p Title="给链接文字提示">文字</p><a href="#" Title="给链接文字提示">文字</a> <img src="图片.gif" alt="给图片提示"><p><strong>8.       网页制作细节 —- 缓存</strong> <br>网页不会被缓存<br>HTM 网页</p><META HTTP-EQUIV="pragma" CONTENT="no-cache"> <META HTTP-EQUIV="Cache-Control" CONTENT="no-cache, must-revalidate"> <META HTTP-EQUIV="expires" CONTENT="0">ASP网页 Response.Expires = -1 Response.ExpiresAbsolute = Now() - 1 Response.cachecontrol = "no-cache"<p><strong>9.       网页制作细节 —- 浏览器兼容性</strong><br>创建站点时，应该明白访问者可能使用各种 Web 浏览器。在已知的其他设计限制下，尽可能将站点设计为具有最大的浏览器兼容性。<br>目前使用的 Web 浏览器有二十多种，大多数已发行了多个版本。即使您只针对使用 Netscape Navigator 和 Microsoft Internet Explorer 的大多数 Web 用户，但您应明确并不是每个人都在使用这两种浏览器的最新版本。<br>您的站点越复杂（在布局、动画、多媒体内容和交互方面），跨浏览器兼容的可能性就越小。例如，并非所有的浏览器都可以运行 JavaScript。不使用特殊字符的纯文本页面或许能够在任何浏览器中正确显示，但比起有效地使用图形、布局和交互的页面，这样的页面在美感上可能要差得多。所以，应尽量在最佳效果设计和最大浏览器兼容性设计之间取得平衡。<br>所有的 HTML 标签的属性都要用单引号或者双引号括起，即我们应该写 <a href=”url”>而不 是 <a href=url>.</p><p><strong>10.     图片处理细节 —- banner</strong><br>全尺寸 banner 为 468X60px，半尺寸 banner 为 234X60px，小 banner 为 88X31px。<br>另外 120X90，120X60 也是小图标的标准尺寸。全尺寸 banner 不超过 14K。<br>普遍的 banner 尺寸 760X100，750X120，468X60，468X95，728X90，585X140<br>次级页的 pip 尺寸 360X300，336X280<br>游标:100X100 或 120X120<br>** **</p><p><strong>11.     图片处理细节 —- LOGO 的国际标准规范</strong><br>为了便于 INTERNET 上信息的传播，一个统一的国际标准是需要的。实际上已经有了这样的一整套标准。其中关于网站的 LOGO，目前有三种规格：<br>88<em>31 这是互联网上最普遍的 LOGO 规格。<br>120</em>60 这种规格用于一般大小的 LOGO。<br>120*90 这种规格用于大型 LOGO。</p><p>**12.     图片处理细节 —- 页面修饰图片处理<br>**图片经过优化以加快下载的速度,有较佳的视觉空间效果，用图要与页面风格、页面内容相符；制作精美，细节处理得当。<br>** **</p><h3 id="JavaScript-书写规范"><a href="#JavaScript-书写规范" class="headerlink" title="JavaScript 书写规范"></a>JavaScript 书写规范</h3><p>1.     书写过程中, 每行代码结束必须有分号; 原则上所有功能均根据 XXX 项目需求原生开发, 以避免网上 down 下来的代码造成的代码污染(沉冗代码 || 与现有代码冲突 || …);<br>2.     库引入: 原则上仅引入 jQuery 库, 若需引入第三方库, 须与团队其他人员讨论决定;<br>3.     变量命名: 驼峰式命名. 原生 JavaScript 变量要求是纯英文字母, 首字母须小写, 如 iTaoLun; jQuery 变量要求首字符为’_‘, 其他与原生 JavaScript 规则相同, 如: _iTaoLun; 另, 要求变量集中声明, 避免全局变量.<br>4.     类命名: 首字母大写, 驼峰式命名. 如 ITaoLun;<br>5.     函数命名: 首字母小写驼峰式命名. 如 iTaoLun();<br>6.     命名语义化, 尽可能利用英文单词或其缩写;<br>7.     尽量避免使用存在兼容性及消耗资源的方法或属性, 比如 eval() &amp; innerText;<br>8.     后期优化中, JavaScript 非注释类中文字符须转换成 unicode 编码使用, 以避免编码错误时乱码显示;<br>9.     代码结构明了, 加适量注释. 提高函数重用率;<br>10.   注重与 html 分离, 减小 reflow, 注重性能.</p><h3 id="图片规范"><a href="#图片规范" class="headerlink" title="图片规范"></a>图片规范</h3><p>1.     所有页面元素类图片均放入 img 文件夹, 测试用图片放于 img/demoimg 文件夹;<br>2.     图片格式仅限于 gif || png || jpg;<br>3.     命名全部用小写英文字母 || 数字 || _ 的组合，其中不得包含汉字 || 空格 || 特殊字符；尽量用易懂的词汇, 便于团队其他成员理解; 另, 命名分头尾两部分, 用下划线隔开, 比如 ad_left01.gif || btn_submit.gif;<br>4.     在保证视觉效果的情况下选择最小的图片格式与图片质量, 以减少加载时间;<br>5.     尽量避免使用半透明的 png 图片(若使用, 请参考 css 规范相关说明);<br>6.     运用 css sprite 技术集中小的背景图或图标, 减小页面 http 请求, 但注意, 请务必在对应的 sprite psd 源图中划参考线, 并保存至 img 目录下.</p><h3 id="注释规范"><a href="#注释规范" class="headerlink" title="注释规范"></a>注释规范</h3><p>1.     html 注释: 注释格式 <!--这儿是注释-->, ‘–’只能在注释的始末位置,不可置入注释文字区域;<br>2.     css 注释: 注释格式 /<em>这儿是注释</em>/;<br>3.     JavaScript 注释, 单行注释使用’//这儿是单行注释’ ,多行注释使用 /_ 这儿有多行注释 _/;**</p><h3 id="浏览器兼容性-CSS-hack"><a href="#浏览器兼容性-CSS-hack" class="headerlink" title="浏览器兼容性 CSS hack"></a>浏览器兼容性 CSS hack</h3><p>** **<br><strong>一、标识区别：</strong><br>区别 IE6,IE7,IE8,FF。</p><ol><li>IE 都能识别* ; 标准浏览器(如 FF)不能识别*；</li><li>IE6 能识别*，但不能识别!important; IE6 在样式前面加_</li><li>IE7 能识别*，也能识别!important;</li><li>IE8 能识别\ 9 例如：background:red \9;</li><li>firefox 不能识别*，但能识别!important;</li></ol><p>1．IE6 和 firefox 的区别：<br>background:orange;*background:blue;<br>意思就是火狐浏览器的背景颜色是橙色,而 IE 浏览器的背景色是蓝色. 2. IE6 和 IE7 的区别：<br>background:green !important;background:blue;<br>意思指的是:IE7 的背景颜色是绿色,IE6 的背景颜色是蓝色 3. IE7 和 FF 的区别：<br>background:orange; *background:green;<br>意思指的是:火狐浏览器的背景颜色是橙色,而 IE7 的背景颜色是绿色 4. FF，IE7，IE6 的区别：<br>background:orange;<br>*background:green !important;<br>*background:blue;<br>意思是火狐浏览器的的背景橙色,IE7 浏览器的背景颜色是绿色,而 IE6 浏览器的颜色是蓝色.</p><p><strong>二、实践建议</strong><br>(1).  开发平台的选择<br>在 Firefox 上编写 CSS, 同时兼容其他浏览器的. 这样做肯定会比在 IE 做好再到别的浏览器兼容来得容易, 因为 IE 对老标准支持还是很不错的, 而 IE 的一些特有功能人家却不支持. 所以推荐以 Firefox 结合 Firebug 扩展作为平台。<br>(2).  CSS Hack 的顺序<br>使用 Firefox 作为平台, 只要代码写得够标准, 其实要 Hack 的地方不会很多的, IE 以外的浏览器几乎都不会有问题, 所以可以暂时忽略,<br>顺序如下：Firefox -&gt; IE6 -&gt; IE7 -&gt; 其他<br>(3).   Hack 的方法<br>说到方法有两种, 一种是在不同文件中处理, 另一种则是在同一个文件中处理. 其实作用是相同的, 只是出发点不一样而已.</p><ol><li>同一文件中处理.<br>如: id=”bgcolor”的控件要在 IE6 中显示蓝色, IE7 中显示绿色, Firefox 等其他浏览器中显示红色。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1615198441633-b7a4ec59-1c24-4fd0-b2e2-51ee115ab46b.png#align=left&display=inline&height=107&margin=%5Bobject%20Object%5D&name=image.png&originHeight=213&originWidth=928&size=124593&status=done&style=none&width=464" alt="image.png"><br>IE6 不认 !important,也不认 _+html.所以 IE6 只能是 blue.<br>IE7 认 !important,也认 _+html,优先度: (*+html + !important) &gt; !important &gt; +html. IE7 可以是 red, blue 和 green,但 green 的优先度最高.<br>Firefox 和其他浏览器都认 !important. !important 优先, Firefox 可以是 red 和 blue,但 red 优先度高.上述的优先符号均是 CSS3 标准允许的,其他浏览器也还有其他的 Hack 方法,但我迄今还没遇到过 Firefox 正常, IE 以外的其他浏览器不正常的情况,所以无可分享.只要代码规范,相信这种情况的发生应该是很罕见 (JavaScript 除外). 2.不同文件中处理.<br>为什么同一文件中可以处理还要写在多个文件里面针对不同的浏览器?这是为了欺骗 W3C 的验证工具,其实只需要两个文件,一个是针对所有浏览器的,一个只为 IE 服务.将所有符合 W3C 的代码写到一个里面去,而一些 IE 中必须的,又不能通过 W3C 验证的代码 (如: cursor:hand;)放到另一个文件中,再用下面的方法导入.<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1615198452546-d3348c0f-fba9-484d-97f7-76a98ffc4b3f.png#align=left&display=inline&height=94&margin=%5Bobject%20Object%5D&name=image.png&originHeight=187&originWidth=922&size=147490&status=done&style=none&width=461" alt="image.png"></li></ol><h2 id="CSS-书写规范-1"><a href="#CSS-书写规范-1" class="headerlink" title="CSS 书写规范"></a>CSS 书写规范</h2><p>开始就形成良好的书写规范，是你专业的开始。</p><h3 id="空格规范"><a href="#空格规范" class="headerlink" title="空格规范"></a>空格规范</h3><p>【强制】 选择器 与 { 之间必须包含空格。<br>示例：</p><pre><code class="css">.selector &#123;&#125;</code></pre><p>【强制】 属性名 与之后的 : 之间不允许包含空格， : 与 属性值 之间必须包含空格。<br>示例：</p><pre><code class="css">font-size: 12px;</code></pre><h3 id="选择器规范"><a href="#选择器规范" class="headerlink" title="选择器规范"></a>选择器规范</h3><p>【强制】 并集选择器，每个选择器声明必须独占一行。<br>示例：</p><pre><code>/* good */.post,.page,.comment &#123;    line-height: 1.5;&#125;/* bad */.post, .page, .comment &#123;    line-height: 1.5;&#125;</code></pre><p>【建议】 一般情况情况下，选择器的嵌套层级应不大于 3 级，位置靠后的限定条件应尽可能精确。<br>示例：</p><pre><code class="css">/* good */#username input &#123;&#125;.comment .avatar &#123;&#125;/* bad */.page .header .login input &#123;&#125;.comment div * &#123;&#125;</code></pre><h3 id="属性规范"><a href="#属性规范" class="headerlink" title="属性规范"></a>属性规范</h3><p>【强制】 属性定义必须另起一行。<br>示例：</p><pre><code class="css">/* good */.selector &#123;  margin: 0;  padding: 0;&#125;/* bad */.selector &#123;  margin: 0;  padding: 0;&#125;</code></pre><p>【强制】 属性定义后必须以分号结尾。<br>示例：</p><pre><code class="css">/* good */.selector &#123;  margin: 0;&#125;/* bad */.selector &#123;  margin: 0;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
          <category> Web其他 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>sublime使用说明</title>
      <link href="blog/ngapny/"/>
      <url>blog/ngapny/</url>
      
        <content type="html"><![CDATA[<p>最常用的<br>1、新建文件-输入”html:xt”后   按”Ctrl+E 键”或 “tab 键” ,可快速生成 xhtml 1.0 的模板<br>2、新建文件-输入”html:5”后   按”Ctrl+E 键”或 “tab 键” ,可快速生成 HTML5 的模板<br>3、新建文件-输入”!”后   按”Ctrl+E 键”或 “tab 键” ,可快速生成 HTML5 的模板<br>Ctrl+Shift+ [     折叠代码 (在 CSS 中表示紧凑格式，在 html 中为折叠代码)<br>Ctrl+Shift+ ]     折叠代码 (在 CSS 中表示扩张格式，在 html 中为恢复折叠代码)<br>Ctrl+Shift+C   CSS 属性排序<br>Ctrl+Alt+N       快速创建文件(填上文件扩展名可生成模板，例如：demo.html)<br>Ctrl+Alt+K       刪除不必要的空白<br>Ctrl+Shift+Alt+F   格式化 JS 代码<br>Ctrl+Shift+Alt+M 压缩 CSS/JS 代码(生成结果为：文件名.min.css、文件名.min.js)<br>F1      Chrome 浏览器预览<br>F2     Firefox 浏览器预览<br>F3     IE 浏览器预览<br>F4     打开调色盘<br>F11     全屏<br>F12     默认浏览器预览<br>按住鼠标滚轮下拉可多行编辑</p><hr><p>Ctrl+D 选词 （反复按快捷键，即可继续向下同时选中下一个相同的文本进行同时编辑）<br>Ctrl+G 跳转到相应的行<br>Ctrl+J 合并行（已选择需要合并的多行时）<br>Ctrl+L 选择整行（按住-继续选择下行）<br>Ctrl+M 光标移动至括号内开始或结束的位置<br>Ctrl+T 词互换<br>Ctrl+U 软撤销<br>Ctrl+P 查找当前项目中的文件和快速搜索；输入 @ 查找文件主标题/函数；或者输入 : 跳转到文件某行；<br>Ctrl+R 快速列出/跳转到某个函数<br>Ctrl+K Backspace 从光标处删除至行首<br>Ctrl+K+B 开启/关闭侧边栏<br>Ctrl+KK 从光标处删除至行尾<br>Ctrl+K+T 折叠属性<br>Ctrl+K+U 改为大写<br>Ctrl+K+L 改为小写<br>Ctrl+K+0 展开所有<br>Ctrl+Enter 插入行后（快速换行）<br>Ctrl+Tab 当前窗口中的标签页切换<br>Ctrl+Shift+A 选择光标位置父标签对儿<br>Ctrl+Shift+D 复制光标所在整行，插入在该行之前<br>ctrl+shift+F 在文件夹内查找，与普通编辑器不同的地方是 sublime 允许添加多个文件夹进行查找<br>Ctrl+Shift+K 删除整行<br>Ctrl+Shift+L 鼠标选中多行（按下快捷键），即可同时编辑这些行<br>Ctrl+Shift+M 选择括号内的内容（按住-继续选择父括号）<br>Ctrl+Shift+P 打开命令面板<br>Ctrl+Shift+/ 注释已选择内容<br>Ctrl+Shift+↑ 可以移动此行代码，与上行互换<br>Ctrl+Shift+↓ 可以移动此行代码，与下行互换<br>Ctrl+Shift+[ 折叠代码<br>Ctrl+Shift+] 展开代码<br>Ctrl+Shift+Enter 光标前插入行<br>Ctrl+PageDown 、Ctrl+PageUp 文件按开启的前后顺序切换<br>Ctrl+Z 撤销<br>Ctrl+Y 恢复撤销<br>Ctrl+F2 设置/取消书签<br>Ctrl+/ 注释整行（如已选择内容，同“Ctrl+Shift+/”效果）<br>Ctrl+鼠标左键 可以同时选择要编辑的多处文本<br>Shift+鼠标右键（或使用鼠标中键）可以用鼠标进行竖向多行选择<br>Shift+F2 上一个书签<br>Shift+Tab 去除缩进<br>Alt+Shift+1（非小键盘）窗口分屏，恢复默认 1 屏<br>Alt+Shift+2 左右分屏-2 列<br>Alt+Shift+3 左右分屏-3 列<br>Alt+Shift+4 左右分屏-4 列<br>Alt+Shift+5 等分 4 屏<br>Alt+Shift+8 垂直分屏-2 屏<br>Alt+Shift+9 垂直分屏-3 屏<br>Ctrl+Shift+分屏序号 将当前焦点页分配到分屏序号页<br>Alt+. 闭合当前标签<br>Alt+F3 选中文本按下快捷键，即可一次性选择全部的相同文本进行同时编辑<br>Tab 缩进 自动完成<br>F2 下一个书签<br>F6 检测语法错误<br>F9 行排序(按 a-z)</p>]]></content>
      
      
      <categories>
          
          <category> Environment </category>
          
          <category> 工具使用 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[转]《周易》</title>
      <link href="essay/kxd8zv/"/>
      <url>essay/kxd8zv/</url>
      
        <content type="html"><![CDATA[<p>周易（易经）</p><h2 id="第一卦-乾-乾为天-乾上乾下"><a href="#第一卦-乾-乾为天-乾上乾下" class="headerlink" title="第一卦 乾 乾为天 乾上乾下"></a>第一卦 乾 乾为天 乾上乾下</h2><p>乾：元，亨，利，贞。</p><p>上九：亢龙有悔。用九：见群龙 无首，吉。<br>九五：飞龙在天，利见大人。<br>九四：或跃在渊，无咎。<br>九三：君子终日乾乾，夕惕若，厉无咎。<br>九二：见龙再田，利见大人。<br>初九：潜龙，勿用。</p><p>彖曰：大哉乾元，万物资始，乃统天。云行雨施，品物流形。大明始终，六位时成，时乘六龙以御天。乾道变化，各正性命，保合大和，乃利贞。首出庶物，万国咸宁。</p><p>象曰：天行健，君子以自强不息。潜龙勿用，阳在下也。见龙再田，德施普也。终日乾乾，反复道也。或跃在渊，进无咎也。飞龙在天，大人造也。亢龙有悔，盈不可久也。用 九，天德不可为首也。</p><p>文言曰：「元者，善之长也，亨者，嘉之会也，利者，义之和也，贞者，事之干也。君子体仁，足以长人；嘉会，足以合礼；利物，足以和义；贞固，足以干事。君子行此四者， 故曰：乾：元亨利贞。」</p><p>初九曰：「潜龙勿用。」何谓也？子曰：「龙德而隐者也。不易乎世，不成乎名；遯世而无闷，不见是而无闷；乐则行之，忧则违之；确乎其不可拔，乾龙也。」</p><p>九二曰：「见龙在田，利见大人。」何谓也？子曰：「龙德而正中者也。庸言之信，庸行之谨，闲邪存其诚，善世而不伐，德博而化。易曰：「见龙在田，利见大人。」君德 也。」</p><p>九三曰：「君子终日乾乾，夕惕若，厉无咎。」何谓也？子曰：「君子进德修业，忠信，所以进德也。修辞立其诚，所以居业也。知至至之，可与几也。知终终之，可与存义 也。是故，居上位而不骄，在下位而不忧。故乾乾，因其时而惕，虽危而无咎矣。」</p><p>九四：「或跃在渊，无咎。」何谓也？子曰：「上下无常，非为邪也。进退无恒，非离群也。君子进德修业，欲及时也，故无咎。」</p><p>九五曰：「飞龙在天，利见大人。」何谓也？子曰：「同声相应，同气相求；水流湿，火就燥；云从龙，风从虎。圣人作，而万物覩，本乎天者亲上，本乎地者亲下，则各从其 类也。</p><p>上九曰：「亢龙有悔。」何谓也？子曰：「贵而无位，高而无民，贤人在下而无辅，是以动而有悔也。」</p><p>乾龙勿用，下也。见龙在田，时舍也。终日乾乾，行事也。或跃在渊，自试也。飞龙在天，上治也。亢龙有悔，穷之灾也。乾元用九，天下治也。</p><p>乾龙勿用，阳气潜藏。见龙在田，天下文明。终日乾乾，与时偕行。或跃在渊，乾道乃革。飞龙在天，乃位乎天德。亢龙有悔，与时偕极。乾元用九，乃见天则。</p><p>乾元者，始而亨者也。利贞者，性情也。乾始能以美利利天下，不言所利。大矣哉！大哉乾乎？刚健中正，纯粹精也。六爻发挥，旁通情也。时乘六龙，以御天也。云行雨施，天 下平也。</p><p>君子以成德为行，日可见之行也。潜之为言也，隐而未见，行而未成，是以君子弗用也。</p><p>君子学以聚之，问以辩之，宽以居之，仁以行之。易曰：「见龙在田，利见大人。」君德也。</p><p>九三，重刚而不中，上不在天，下不在田。故乾乾，因其时而惕，虽危无咎矣。</p><p>九四，重刚而不中，上不在天，下不在田，中不在人，故或之。或之者，疑之也，故无咎。</p><p>夫大人者，与天地合其德，与日月合其明，与四时合其序，与鬼神合其吉凶。先天下而天弗违，后天而奉天时。天且弗违，而况於人乎？况於鬼神乎？</p><p>亢之为言也，知进而不知退，知存而不知亡，知得而不知丧。其唯圣人乎？知进退存亡，而不失其正者，其为圣人乎？</p><h2 id="第二卦-坤-坤为地-坤上坤下"><a href="#第二卦-坤-坤为地-坤上坤下" class="headerlink" title="第二卦 坤 坤为地 坤上坤下"></a>第二卦 坤 坤为地 坤上坤下</h2><p>坤：元，亨，利牝马之贞。君子有攸往，先迷后得主，利西南得朋，东北丧朋。安贞，</p><p>吉。</p><p>彖曰：至哉坤元，万物资生，乃顺承天。坤厚载物，德合无疆。含弘光大，品物咸亨。</p><p>牝马地类，行地无疆，柔顺利贞。君子攸行，先迷失道，后顺得常。西南得朋，乃与类行；</p><p>东北丧朋，乃终有庆。安贞之吉，应地无疆。</p><p>象曰：地势坤，君子以厚德载物。</p><p>初六：履霜，坚冰至。象曰：履霜坚冰，阴始凝也。驯致其道，至坚冰也。</p><p>六二：直，方，大，不习无不利。象曰：六二之动，直以方也。不习无不利，地道光</p><p>也。</p><p>六三：含章可贞。或从王事，无成有终。象曰：含章可贞；以时发也。或从王事，知光</p><p>大也。</p><p>六四：括囊；无咎，无誉。象曰：括囊无咎，慎不害也。</p><p>六五：黄裳，元吉。象曰：黄裳元吉，文在中也。</p><p>上六：战龙於野，其血玄黄。象曰：战龙於野，其道穷也。</p><p>用六：利永贞。象曰：用六永贞，以大终也。</p><p>文言曰：坤至柔，而动也刚，至静而德方，后得主而有常，含万物而化光。坤其道顺</p><p>乎？承天而时行。</p><p>积善之家，必有馀庆；积不善之家，必有馀殃。臣弑其君，子弑其父，非一朝一夕之</p><p>故，其所由来者渐矣，由辩之不早辩也。易曰：「履霜坚冰至。」盖言顺也。</p><p>直其正也，方其义也。君子敬以直内，义以方外，敬义立，而德不孤。「直，方，大，</p><p>不习无不利」；则不疑其所行也。</p><p>阴虽有美，含之；以从王事，弗敢成也。地道也，妻道也，臣道也。地道无成，而代有</p><p>终也。</p><p>天地变化，草木蕃；天地闭，贤人隐。易曰：「括囊；无咎，无誉。」盖言谨也。</p><p>君子黄中通理，正位居体，美在其中，而畅於四支，发於事业，美之至也。</p><p>阴疑於阳，必战。为其嫌於无阳也，故称龙焉。犹未离其类也，故称血焉。夫玄黄者，</p><p>天地之杂也，天玄而地黄。</p><h2 id="第三卦-屯-水雷屯-坎上震下"><a href="#第三卦-屯-水雷屯-坎上震下" class="headerlink" title="第三卦 屯 水雷屯 坎上震下"></a>第三卦 屯 水雷屯 坎上震下</h2><p>屯：元，亨，利，贞，勿用，有攸往，利建侯。</p><p>彖曰：屯，刚柔始交而难生，动乎险中，大亨贞。雷雨之动满盈，天造草昧，宜建侯而不宁。</p><p>象曰：云，雷，屯；君子以经纶。</p><p>初九：磐桓；利居贞，利建侯。象曰：虽磐桓，志 行正也。以贵下贱，大得民也。</p><p>六二：屯如(辶颤)如，乘马班如。匪寇婚媾，女子贞不字，十年乃字。象曰：六二之难，乘 刚也。十年乃字，反常也。</p><p>六三：既鹿无虞，惟入于林中，君子几不如舍，往吝。象曰：既鹿无虞，以纵禽也。君子舍之，往吝穷也。</p><p>六四：乘马班如，求婚媾，无不利。象曰：求而往，明也。</p><p>九五：屯其膏，小贞吉，大贞凶。象曰：屯其膏，施未光也。</p><p>上六：乘马班如，泣血涟如。象曰：泣血涟如，何可长也。</p><h2 id="第四卦-蒙-山水蒙-艮上坎下"><a href="#第四卦-蒙-山水蒙-艮上坎下" class="headerlink" title="第四卦 蒙 山水蒙 艮上坎下"></a>第四卦 蒙 山水蒙 艮上坎下</h2><p>蒙：亨。匪我求童蒙，童蒙求我。初噬告，再三渎，渎则不告。利贞。</p><p>彖曰：蒙，山下有险，险而止，蒙。蒙亨，以亨行时中也。匪我求童蒙，童蒙求我，志应也。初噬告，以刚中也。再三渎，渎则不告，渎蒙也。蒙以养正，圣功也。</p><p>象曰：山下出 泉，蒙；君子以果行育德。</p><p>初六：发蒙，利用刑人，用说桎梏，以往吝。象曰：利用刑人，以正法也。</p><p>九二：包蒙吉；纳妇吉；子克家。象曰：子克家，刚柔接也。</p><p>六三：勿用娶女；见金夫，不有躬，无攸利。象曰：勿用娶女，行不顺也。</p><p>六四：困蒙，吝。象曰：困蒙之吝，独远实也。</p><p>六五：童蒙，吉。象曰：童蒙之吉，顺以巽也。</p><p>上九：击蒙；不利为寇，利御寇。象曰：利用御寇，上下顺也。</p><h2 id="第五卦-需-水天需-坎上乾下"><a href="#第五卦-需-水天需-坎上乾下" class="headerlink" title="第五卦 需 水天需 坎上乾下"></a>第五卦 需 水天需 坎上乾下</h2><p>需：有孚，光亨，贞吉。利涉大川。</p><p>彖曰：需，须也；险在前也。刚健而不陷，其义不困穷矣。需有孚，光亨，贞吉。位乎天位，以正中也。利涉大川，往有功也。</p><p>象曰：云上於天，需；君子以饮食宴乐。</p><p>初九：需 于郊。利用恒，无咎。象曰：需于郊，不犯难行也。利用恒，无咎；未失常也。</p><p>九二：需于沙。小有言，终吉。象曰：需于沙，衍在中也。虽小有言，以终吉也。</p><p>九三：需于泥，致寇至。象曰：需于泥，灾在外也。自我致寇，敬慎不败也。</p><p>六四：需于血，出自穴。象曰：需于血，顺以听也。</p><p>九五：需于酒食，贞吉。象曰：酒食贞吉，以中正也。</p><p>上六：入于穴，有不速之客三人 来，敬之终吉。象曰：不速之客来，敬之终吉。虽不当位，未大失也。</p><h2 id="第六卦-讼-天水讼-乾上坎下"><a href="#第六卦-讼-天水讼-乾上坎下" class="headerlink" title="第六卦 讼 天水讼 乾上坎下"></a>第六卦 讼 天水讼 乾上坎下</h2><p>讼：有孚，窒。惕中吉。终凶。利见大人，不利涉大川。</p><p>彖曰：讼，上刚下险，险而健讼。讼有孚窒，惕中吉，刚来而得中也。终凶；讼不可成也。利见大人；尚中正也。不利涉大川；入于渊也。</p><p>象曰：天与水违行，讼；君子以作事谋始。</p><p>初六：不永所事，小有言，终吉。象曰：不 永所事，讼不可长也。虽有小言，其辩明也。</p><p>九二：不克讼，归而逋，其邑人三百户，无眚。象曰：不克讼，归而逋也。自下讼上，患至掇也。</p><p>六三：食旧德，贞厉，终吉，或从王事，无成。象曰：食旧德，从上吉也。</p><p>九四：不克讼，复自命，渝安贞，吉。象曰：复即命，渝安贞；不失也。</p><p>九五：讼元吉。象曰：讼元吉，以中正也。</p><p>上九：或锡之鞶带，终朝三褫之。象曰：以讼受服，亦不足敬也。</p><h2 id="第七卦-师-地水师-坤上坎下"><a href="#第七卦-师-地水师-坤上坎下" class="headerlink" title="第七卦 师 地水师 坤上坎下"></a>第七卦 师 地水师 坤上坎下</h2><p>师：贞，丈人，吉无咎。</p><p>彖曰：师，众也，贞正也，能以众正，可以王矣。刚中而应，行险而顺，以此毒天下，而民从之，吉又何咎矣。</p><p>象曰：地中有水，师；君子以容民畜众。</p><p>初六：师出以律，否臧凶。象曰：师出以律， 失律凶也。</p><p>九二：在师中，吉无咎，王三锡命。象曰：在师中吉，承天宠也。王三锡命，怀万邦也。</p><p>六三：师或舆尸，凶。象曰：师或舆尸，大无功也。</p><p>六四：师左次，无咎。象曰：左次无咎，未失常也。</p><p>六五：田有禽，利执言，无咎。长子帅师，弟子舆尸，贞凶。象曰：长子帅师，以中行也。弟子舆师，使不当也。</p><p>上六：大君有命，开国承家，小人勿用。象曰：大君有命，以正功也。小人勿用，必乱邦也。</p><h2 id="第八卦-比-水地比-坎上坤下"><a href="#第八卦-比-水地比-坎上坤下" class="headerlink" title="第八卦 比 水地比 坎上坤下"></a>第八卦 比 水地比 坎上坤下</h2><p>比：吉。原筮元永贞，无咎。不宁方来，后夫凶。</p><p>彖曰：比，吉也，比，辅也，下顺从也。原筮元永贞，无咎，以刚中也。不宁方来，上下应也。后夫凶，其道穷也。</p><p>象曰：地上有水，比；先王以建万国，亲诸侯。</p><p>初六：有孚比之，无咎。有孚盈缶，终 来有他，吉。象曰：比之初六，有他吉也。</p><p>六二：比自内，贞吉。象曰：比之自内，不自失也。</p><p>六三：比之匪人。象曰：比之匪人，不亦伤乎！</p><p>六四：外比之，贞吉。象曰：外比於贤，以从上也。</p><p>九五：显比，王用三驱，失前禽。邑人不诫，吉。象曰：显比之吉，位正中也。舍逆取顺，失前禽也。邑人不诫，上使中也。</p><p>上六：比之无首，凶。象曰：比之无首，无所终也。</p><h2 id="第九卦-小畜-风天小畜-巽上乾下"><a href="#第九卦-小畜-风天小畜-巽上乾下" class="headerlink" title="第九卦 小畜 风天小畜 巽上乾下"></a>第九卦 小畜 风天小畜 巽上乾下</h2><p>小畜：亨。密云不雨，自我西郊。</p><p>彖曰：小畜；柔得位，而上下应之，曰小畜。健而巽，刚中而志行，乃亨。密云不雨，尚往也。自我西郊，施未行也。</p><p>象曰：风行天上，小畜；君子以懿文德。</p><p>初九：复自道，何其咎，吉。象曰：复自道， 其义吉也。</p><p>九二：牵复，吉。象曰：牵复在中，亦不自失也。</p><p>九三：舆说辐，夫妻反目。象曰：夫 妻反目，不能正室也。</p><p>六四：有孚，血去惕出，无咎。象曰：有孚惕出，上合志也。</p><p>九五：有孚挛如，富以其邻。象曰：有孚挛如，不独富也。</p><p>上九：既雨既处，尚德载，妇贞厉。月几望，君子征凶。象曰：既雨既处，德积载也。君子征凶，有所疑也。</p><h2 id="第十卦-履-天泽履-乾上兑下"><a href="#第十卦-履-天泽履-乾上兑下" class="headerlink" title="第十卦 履 天泽履 乾上兑下"></a>第十卦 履 天泽履 乾上兑下</h2><p>履：履虎尾，不咥人，亨。</p><p>彖曰：履，柔履刚也。说而应乎乾，是以履虎尾，不咥人，亨。刚中正，履帝位而不疚，光明也。</p><p>象曰：上天下泽，履；君子以辨上下，安民志。</p><p>初九：素履，往无咎。象曰：素履之 往，独行愿也。</p><p>九二：履道坦坦，幽人贞吉。象曰：幽人贞吉，中不自乱也。</p><p>六三：眇能视，跛能履，履虎尾，咥人，凶。武人为于大君。象曰：眇能视；不足以有明也。跛能履；不足以与行也。咥人之凶；位不当也。武人为于大君；志刚也。</p><p>九四：履虎尾，愬愬终吉。象曰：愬愬终吉，志行也。</p><p>九五：夬履，贞厉。象曰：夬履贞厉，位正当也。</p><p>上九：视履考祥，其旋元吉。象曰：元吉在上，大有庆也。</p><h2 id="第十一卦-泰-天地泰-坤上乾下"><a href="#第十一卦-泰-天地泰-坤上乾下" class="headerlink" title="第十一卦 泰 天地泰 坤上乾下"></a>第十一卦 泰 天地泰 坤上乾下</h2><p>泰：小往大来，吉亨。</p><p>彖曰：泰，小往大来，吉亨。则是天地交，而万物通也；上下交，而其志同也。内阳而外阴，内健而外顺，内君子而外小人，君子道长，小人道消也。</p><p>象曰：天地交泰，后以财（裁）成天地之道，辅相天地之宜，以左右民。</p><p>初九：拔茅 茹，以其夤，征吉。象曰：拔茅征吉，志在外也。</p><p>九二：包荒，用冯河，不遐遗，朋亡，得尚于中行。象曰：包荒，得尚于中行，以光大也。</p><p>九三：无平不陂，无往不复，艰贞无咎。勿恤其孚，于食有福。象曰：无往不复，天地际也。</p><p>六四：翩翩不富，以其邻，不戒以孚。象曰：翩翩不富，皆失实也。不戒以孚，中心愿也。</p><p>六五：帝乙归妹，以祉元吉。象曰：以祉元吉，中以行愿也。</p><p>上六：城复于隍，勿用师。自邑告命，贞吝。象曰：城复于隍，其命乱也。</p><h2 id="第十二卦-否-地天否-乾上坤下"><a href="#第十二卦-否-地天否-乾上坤下" class="headerlink" title="第十二卦 否 地天否 乾上坤下"></a>第十二卦 否 地天否 乾上坤下</h2><p>否：否之匪人，不利君子贞，大往小来。</p><p>彖曰：否之匪人，不利君子贞。大往小来，则是天地不交，而万物不通也；上下不交，而天下无邦也。内阴而外阳，内柔而外刚，内小人而外君子。小人道长，君子道消也。</p><p>象曰：天地不交，否；君子以俭德辟难，不可荣以禄。</p><p>初六：拔茅茹，以其夤，贞吉 亨。象曰：拔茅贞吉，志在君也。</p><p>六二：包承。小人吉，大人否亨。象曰：大人否亨，不乱群也。</p><p>六三：包羞。象曰：包羞，位不当也。</p><p>九四：有命无咎，畴离祉。象曰：有命无咎，志行也。</p><p>九五：休否，大人吉。其亡其亡，系于苞桑。象曰：大人之吉，位正当也。</p><p>上九：倾否，先否后喜。象曰：否终则倾，何可长也。</p><h2 id="第十三卦-同人-天火同人-乾上离下"><a href="#第十三卦-同人-天火同人-乾上离下" class="headerlink" title="第十三卦 同人 天火同人 乾上离下"></a>第十三卦 同人 天火同人 乾上离下</h2><p>同人：同人于野，亨。利涉大川，利君子贞。</p><p>彖曰：同人，柔得位得中，而应乎乾，曰同人。同人曰，同人于野，亨。利涉大川，乾行也。文明以健，中正而应，君子正也。唯君子为能通天下之志。</p><p>象曰：天与火，同人；君子以类族辨物。</p><p>初九：同人于门，无咎。象曰：出门同人，又 谁咎也。</p><p>六二：同人于宗，吝。象曰：同人于宗，吝道也。</p><p>九三：伏戎于莽，升其高陵，三岁不兴。象曰：伏戎于莽，敌刚也。三岁不兴，安行也。</p><p>九四：乘其墉，弗克攻，吉。象曰：乘其墉，义弗克也，其吉，则困而反则也。</p><p>九五：同人，先号啕而后笑。大师克相遇。象曰：同人之先，以中直也。大师相遇，言相克也。</p><p>上九：同人于郊，无悔。象曰：同人于郊，志未得也。</p><h2 id="第十四卦-大有-火天大有-离上乾下"><a href="#第十四卦-大有-火天大有-离上乾下" class="headerlink" title="第十四卦 大有 火天大有 离上乾下"></a>第十四卦 大有 火天大有 离上乾下</h2><p>大有：元亨。 彖曰：大有，柔得尊位，大中而上下应之，曰大有。其德刚健而文明，应乎天而时行，是以元亨。</p><p>象曰：火在天上，大有；君子以竭恶扬善，顺天休命。</p><p>初九：无交害，匪咎，艰则无 咎。象曰：大有初九，无交害也。</p><p>九二：大车以载，有攸往，无咎。象曰：大车以载，积中不败也。</p><p>九三：公用亨于天子，小人弗克。象曰：公用亨于天子，小人害也。九四：匪其彭，无咎。象曰：匪其彭，无咎；明辨晰也。</p><p>六五：厥孚交如，威如；吉。象曰：厥孚交如，信以发志也。威如之吉，易而无备也。</p><p>上九：自天佑之，吉无不利。象曰：大有上吉，自天佑也。</p><h2 id="第十五卦-谦-地山谦-坤上艮下"><a href="#第十五卦-谦-地山谦-坤上艮下" class="headerlink" title="第十五卦 谦 地山谦 坤上艮下"></a>第十五卦 谦 地山谦 坤上艮下</h2><p>谦：亨，君子有终。</p><p>彖曰：谦，亨，天道下济而光明，地道卑而上行。天道亏盈而益谦，地道变盈而流谦，鬼神害盈而福谦，人道恶盈而好谦。谦尊而光，卑而不可踰，君子之终也。</p><p>象曰：地中有山，谦；君子以裒多益寡，称物平施。</p><p>初六：谦谦君子，用涉大川，吉。 象曰：谦谦君子，卑以自牧也。</p><p>六二：鸣谦，贞吉。象曰：鸣谦贞吉，中心得也。</p><p>九三：劳谦君子，有终吉。象曰：劳谦君子，万民服也。</p><p>六四：无不利，(扌为)谦。象曰：无不利，(扌为)谦；不违则也。</p><p>六五：不富，以其邻，利用侵伐，无不利。象曰：利用侵伐，征不服也。</p><p>上六：鸣谦，利用行师，征邑国。象曰：鸣谦，志未得也。可用行师，征邑国也。</p><h2 id="第十六卦豫-雷地豫-震上坤下"><a href="#第十六卦豫-雷地豫-震上坤下" class="headerlink" title="第十六卦豫 雷地豫 震上坤下"></a>第十六卦豫 雷地豫 震上坤下</h2><p>豫：利建侯行师。</p><p>彖曰：豫，刚应而志行，顺以动，豫。豫，顺以动，故天地如之，而况建侯行师乎？天地以顺动，故日月不过，而四时不忒；圣人以顺动，则刑罚清而民服。豫之时义大矣哉！</p><p>象曰：雷出地奋，豫。先王以作乐崇德，殷荐之上帝，以配祖考。</p><p>初六：鸣豫，凶。象 曰：初六鸣豫，志穷凶也。</p><p>六二：介于石，不终日，贞吉。象曰：不终日，贞吉；以中正也。</p><p>六三：盱豫，悔。迟有悔。象曰：盱豫有悔，位不当也。</p><p>九四：由豫，大有得。勿疑。朋盍簪。象曰：由豫，大有得；志大行也。</p><p>六五：贞疾，恒不死。象曰：六五贞疾，乘刚也。恒不死，中未亡也。</p><p>上六：冥豫，成有渝，无咎。象曰：冥豫在上，何可长也。</p><h2 id="第十七卦-随-泽雷随-兑上震下"><a href="#第十七卦-随-泽雷随-兑上震下" class="headerlink" title="第十七卦 随 泽雷随 兑上震下"></a>第十七卦 随 泽雷随 兑上震下</h2><p>随：元亨利贞，无咎。</p><p>彖曰：随，刚来而下柔，动而说，随。大亨贞，无咎，而天下随时，随之时义大矣哉！</p><p>象曰：泽中有雷，随；君子以  晦入宴息。</p><p>初九：官有渝，贞吉。出门交有功。象曰： 官有渝，从正吉也。出门交有功，不失也。</p><p>六二：系小子，失丈夫。象曰：系小子，弗兼与也。</p><p>六三：系丈夫，失小子。随有求得，利居贞。象曰：系丈夫，志舍下也。</p><p>九四：随有获，贞凶。有孚在道，以明，何咎。象曰：随有获，其义凶也。有孚在道，明功也。</p><p>九五：孚于嘉，吉。象曰：孚于嘉，吉；位正中也。</p><p>上六：拘系之，乃从维之。王用亨于西山。象曰：拘系之，上穷也。</p><h2 id="第十八卦-蛊-山风蛊-艮上巽下"><a href="#第十八卦-蛊-山风蛊-艮上巽下" class="headerlink" title="第十八卦 蛊 山风蛊 艮上巽下"></a>第十八卦 蛊 山风蛊 艮上巽下</h2><p>蛊：元亨，利涉大川。先甲三日，后甲三日。</p><p>彖曰：蛊，刚上而柔下，巽而止，蛊。蛊，元亨，而天下治也。利涉大川，往有事也。先甲三日，后甲三日，终则有始，天行也。</p><p>象曰：山下有风，蛊；君子以振民育德。</p><p>初六：干父之蛊，有子，考无咎，厉终吉。象 曰：干父之蛊，意承考也。</p><p>九二：干母之蛊，不可贞。象曰：干母之蛊，得中道也。</p><p>九三：干父小有晦，无大咎。象曰：干父之蛊，终无咎也。</p><p>六四：裕父之蛊，往见吝。象曰：裕父之蛊，往未得也。</p><p>六五：干父之蛊，用誉。象曰：干父之蛊；承以德也。</p><p>上九：不事王侯，高尚其事。象曰：不事王侯，志可则也。</p><h2 id="第十九卦-临-地泽临-坤上兑下"><a href="#第十九卦-临-地泽临-坤上兑下" class="headerlink" title="第十九卦 临 地泽临 坤上兑下"></a>第十九卦 临 地泽临 坤上兑下</h2><p>临：元，亨，利，贞。至于八月有凶。</p><p>彖曰：临，刚浸而长。说而顺，刚中而应，大亨以正，天之道也。至于八月有凶，消不久也。</p><p>象曰：泽上有地，临；君子以教思无穷，容保民无疆。</p><p>初九：咸临，贞吉。象曰：咸临 贞吉，志行正也。</p><p>九二：咸临，吉无不利。象曰：咸临，吉无不利；未顺命也。</p><p>六三：甘临，无攸利。既忧之，无咎。象曰：甘临，位不当也。既忧之，咎不长也。</p><p>六四：至临，无咎。象曰：至临无咎，位当也。</p><p>六五：知临，大君之宜，吉。象曰：大君之宜，行中之谓也。</p><p>上六：敦临，吉无咎。象曰：敦临之吉，志在内也。</p><h2 id="第二十卦-观-风地观-巽上坤下"><a href="#第二十卦-观-风地观-巽上坤下" class="headerlink" title="第二十卦 观 风地观 巽上坤下"></a>第二十卦 观 风地观 巽上坤下</h2><p>观：盥而不荐，有孚 □ 若。</p><p>彖曰：大观在上，顺而巽，中正以观天下。观，盥而不荐，有孚颙若，下观而化也。观天之神道，而四时不忒，圣人以神道设教，而天下服矣。</p><p>象曰：风行地上，观；先王以省方，观民设教。</p><p>初六：童观，小人无咎，君子吝。象 曰：初六童观，小人道也。</p><p>六二：窥观，利女贞。象曰：窥观女贞，亦可丑也。</p><p>六三：观我生，进退。象曰：观我生，进退；未失道也。</p><p>六四：观国之光，利用宾于王。象曰：观国之光，尚宾也。</p><p>九五：观我生，君子无咎。象曰：观我生，观民也。</p><p>上九：观其生，君子无咎。象曰：观其生，志未平也。</p><h2 id="第二十一卦-噬嗑-火雷噬嗑-离上震下"><a href="#第二十一卦-噬嗑-火雷噬嗑-离上震下" class="headerlink" title="第二十一卦 噬嗑 火雷噬嗑 离上震下"></a>第二十一卦 噬嗑 火雷噬嗑 离上震下</h2><p>噬嗑：亨。利用狱。</p><p>彖曰：颐中有物，曰噬嗑，噬嗑而亨。刚柔分，动而明，雷电合而章。柔得中而上行，虽不当位，利用狱也。</p><p>象曰：雷电噬嗑；先王以明罚敕法。</p><p>初九：履校灭趾，无咎。象曰：履校灭趾，不行 也。</p><p>六二：噬肤灭鼻，无咎。象曰：噬肤灭鼻，乘刚也。</p><p>六三：噬腊肉，遇毒；小吝，无咎。象曰：遇毒，位不当也。</p><p>九四：噬乾胏，得金矢，利艰贞，吉。象曰：利艰贞吉，未光也。六五：噬乾肉，得黄金，贞厉，无咎。象曰：贞厉无咎，得当也。</p><p>上九：何校灭耳，凶。象曰：何校灭耳，聪不明也。</p><h2 id="第二十二卦-贲-山火贲-艮上离下"><a href="#第二十二卦-贲-山火贲-艮上离下" class="headerlink" title="第二十二卦 贲 山火贲 艮上离下"></a>第二十二卦 贲 山火贲 艮上离下</h2><p>贲：亨。小利有所往。</p><p>彖曰：贲，亨；柔来而文刚，故亨。分刚上而文柔，故小利有攸往。天文也；文明以止，人文也。观乎天文，以察时变；观乎人文，以化成天下。</p><p>象曰：山下有火，贲；君子以明庶政，无敢折狱。</p><p>初九：贲其趾，舍车而徒。象曰：舍 车而徒，义弗乘也。</p><p>六二：贲其须。象曰：贲其须，与上兴也。</p><p>九三：贲如濡如，永贞吉。象曰：永贞之吉，终莫之陵也。</p><p>六四：贲如皤如，白马翰如，匪寇婚媾。象曰：六四，当位疑也。匪寇婚媾，终无尤也。</p><p>六五：贲于丘园，束帛戋戋，吝，终吉。象曰：六五之吉，有喜也。</p><p>上九：白贲，无咎。象曰：白贲无咎，上得志也。</p><h2 id="第二十三卦-剥-山地剥-艮上坤下"><a href="#第二十三卦-剥-山地剥-艮上坤下" class="headerlink" title="第二十三卦 剥 山地剥 艮上坤下"></a>第二十三卦 剥 山地剥 艮上坤下</h2><p>剥：不利有攸往。</p><p>彖曰：剥，剥也，柔变刚也。不利有攸往，小人长也。顺而止之，观象也。君子尚消息盈虚，天行也。</p><p>象曰：山附地上，剥；上以厚下，安宅。</p><p>初六：剥(爿木)以足，蔑贞凶。象曰：剥(爿木)以足，以灭下也。</p><p>六二：剥(爿木)以辨，蔑贞凶。象曰：剥(爿木)以辨，未有与也。</p><p>六三：剥之，无咎。象曰：剥之无咎，失上下也。</p><p>六四：剥(爿木)以肤，凶。象曰：剥(爿木)以肤，切近灾也。</p><p>六五：贯鱼，以宫人宠，无不利。象曰：以宫人宠，终无尤也。</p><p>上九：硕果不食，君子得舆，小人剥庐。象曰：君子得舆，民所载也。小人剥庐，终不可用也。</p><h2 id="第二十四卦-复-地雷复-坤上震下"><a href="#第二十四卦-复-地雷复-坤上震下" class="headerlink" title="第二十四卦 复 地雷复 坤上震下"></a>第二十四卦 复 地雷复 坤上震下</h2><p>复：亨。出入无疾，朋来无咎。反复其道，七日来复，利有攸往。</p><p>彖曰：复亨；刚反，动而以顺行，是以出入无疾，朋来无咎。反复其道，七日来复，天行也。利有攸往，刚长也。复其见天地之心乎？</p><p>象曰：雷在地中，复；先王以至日闭关，商旅不行，后不省方。</p><p>初九：不复远，无只 悔，元吉。象曰：不远之复，以修身也。</p><p>六二：休复，吉。象曰：休复之吉，以下仁也。</p><p>六三：频复，厉无咎。象曰：频复之厉，义无咎也。</p><p>六四：中行独复。象曰：中行独复，以从道也。</p><p>六五：敦复，无悔。象曰：敦复无悔，中以自考也。</p><p>上六：迷复，凶，有灾眚。用行师，终有大败，以其国君，凶；至于十年，不克征。象曰：迷复之凶，反君道也。</p><h2 id="第二十五卦-无妄-天雷无妄-乾上震下"><a href="#第二十五卦-无妄-天雷无妄-乾上震下" class="headerlink" title="第二十五卦 无妄 天雷无妄 乾上震下"></a>第二十五卦 无妄 天雷无妄 乾上震下</h2><p>无妄：元，亨，利，贞。其匪正有眚，不利有攸往。</p><p>彖曰：无妄，刚自外来，而为主於内。动而健，刚中而应，大亨以正，天之命也。其匪正有眚，不利有攸往。无妄之往，何之矣？天命不佑，行矣哉？</p><p>象曰：天下雷行，物与无妄；先王以茂对时，育万物。</p><p>初九：无妄，往吉。象曰：无妄 之往，得志也。</p><p>六二：不耕获，不菑畲，则利有攸往。象曰：不耕获，未富也。</p><p>六三：无妄之灾，或系之牛，行人之得，邑人之灾。象曰：行人得牛，邑人灾也。</p><p>九四：可贞，无咎。象曰：可贞无咎，固有之也。 九五：无妄之疾，勿药有喜。象曰：无妄之药，不可试也。</p><p>上九：无妄，行有眚，无攸利。象曰：无妄之行，穷之灾也。</p><h2 id="第二十六卦-大畜-山天大畜-艮上乾下"><a href="#第二十六卦-大畜-山天大畜-艮上乾下" class="headerlink" title="第二十六卦 大畜 山天大畜 艮上乾下"></a>第二十六卦 大畜 山天大畜 艮上乾下</h2><p>大畜：利贞，不家食吉，利涉大川。</p><p>彖曰：大畜，刚健笃实辉光，日新其德，刚上而尚贤。能止健，大正也。不家食吉，养贤也。利涉大川，应乎天也。</p><p>象曰：天在山中，大畜；君子以多识前言往行，以畜其德。</p><p>初九：有厉利已。象曰：有 厉利已，不犯灾也。</p><p>九二：舆说辐。象曰：舆说辐，中无尤也。</p><p>九三：良马逐，利艰贞。曰闲舆卫，利有攸往。象曰：利有攸往，上合志也。</p><p>六四：童豕之牿，元吉。象曰：六四元吉，有喜也。</p><p>六五：豶豕之牙，吉。象曰：六五之吉，有庆也。</p><p>上九：何天之衢，亨。象曰：何天之衢，道大行也。</p><h2 id="第二十七卦-颐-山雷颐-艮上震下"><a href="#第二十七卦-颐-山雷颐-艮上震下" class="headerlink" title="第二十七卦 颐 山雷颐 艮上震下"></a>第二十七卦 颐 山雷颐 艮上震下</h2><p>颐：贞吉。观颐，自求口实。</p><p>彖曰：颐贞吉，养正则吉也。观颐，观其所养也；自求口实，观其自养也。天地养万物，圣人养贤，以及万民；颐之时义大矣哉！</p><p>象曰：山下有雷，颐；君子以慎言语，节饮食。</p><p>初九：舍尔灵龟，观我朵颐，凶。象 曰：观我朵颐，亦不足贵也。</p><p>六二：颠颐，拂经，于丘颐，征凶。象曰：六二征凶，行失类也。</p><p>六三：拂颐，贞凶，十年勿用，无攸利。象曰：十年勿用，道大悖也。</p><p>六四：颠颐吉，虎视眈眈，其欲逐逐，无咎。象曰：颠颐之吉，上施光也。</p><p>六五：拂经，居贞吉，不可涉大川。象曰：居贞之吉，顺以从上也。</p><p>上九：由颐，厉吉，利涉大川。象曰：由颐厉吉，大有庆也。</p><h2 id="第二十八卦-大过-泽风大过-兑上巽下"><a href="#第二十八卦-大过-泽风大过-兑上巽下" class="headerlink" title="第二十八卦 大过 泽风大过 兑上巽下"></a>第二十八卦 大过 泽风大过 兑上巽下</h2><p>大过：栋桡，利有攸往，亨。</p><p>彖曰：大过，大者过也。栋桡，本末弱也。刚过而中，巽而说行，利有攸往，乃亨。大过之时义大矣哉！</p><p>象曰：泽灭木，大过；君子以独立不惧，（辶豚）世无闷。</p><p>初六：藉用白茅，无咎。象曰：藉用白茅，柔在下也。</p><p>九二：枯杨生稊，老夫得其女妻，无不利。象曰：老夫女妻，过以相与也。</p><p>九三：栋桡，凶。象曰：栋桡之凶，不可以有辅也。</p><p>九四：栋隆，吉；有它吝。象曰：栋隆之吉，不桡乎下也。</p><p>九五：枯杨生华，老妇得士夫，无咎无誉。象曰：枯杨生华，何可久也。老妇士夫，亦可丑也。</p><p>上六：过涉灭顶，凶，无咎。象曰：过涉之凶，不可咎也。</p><h2 id="第二十九卦-坎-坎为水-坎上坎下"><a href="#第二十九卦-坎-坎为水-坎上坎下" class="headerlink" title="第二十九卦 坎 坎为水 坎上坎下"></a>第二十九卦 坎 坎为水 坎上坎下</h2><p>坎：习坎，有孚，维心亨，行有尚。</p><p>彖曰：习坎，重险也。水流而不盈，行险而不失其信。维心亨，乃以刚中也。行有尚，往有功也。天险不可升也，地险山川丘陵也，王公设险以守其国，坎之时用大矣哉！</p><p>象曰：水洊至，习坎；君子以常德行，习教事。</p><p>初六：习坎，入于坎窞，凶。象曰：习坎入坎，失道凶也。</p><p>九二：坎有险，求小得。象曰：求小得，未出中也。</p><p>六三：来之坎坎，险且枕，入于坎窞，勿用。象曰：来之坎坎，终无功也。</p><p>六四：樽酒簋贰，用缶，纳约自牖，终无咎。象曰：樽酒簋贰，刚柔际也。</p><p>九五：坎不盈，只既平，无咎。象曰：坎不盈，中未大也。</p><p>上六：用徽繹，置于丛棘，三岁不得，凶。象曰：上六失道，凶三岁也。</p><h2 id="第三十卦-离-离为火-离上离下"><a href="#第三十卦-离-离为火-离上离下" class="headerlink" title="第三十卦 离 离为火 离上离下"></a>第三十卦 离 离为火 离上离下</h2><p>离：利贞，亨。畜牝牛，吉。</p><p>彖曰：离，丽也；日月丽乎天，百谷草木丽乎土，重明以丽乎正，乃化成天下。柔丽乎中正，故亨；是以畜牝牛吉也。</p><p>象曰：明两作离，大人以继明照于四方。</p><p>初九：履错然，敬之无咎。象曰：履错之敬， 以辟咎也。</p><p>六二：黄离，元吉。象曰：黄离元吉，得中道也。</p><p>九三：日昃之离，不鼓缶而歌，则大耋之嗟，凶。象曰：日昃之离，何可久也。</p><p>九四：突如其来如，焚如，死如，弃如。象曰：突如其来如，无所容也。</p><p>六五：出涕沱若，戚嗟若，吉。象曰：六五之吉，离王公也。</p><p>上九：王用出征，有嘉折首，获其匪丑，无咎。象曰：王用出征，以正邦也。</p><h2 id="第三十一卦-咸-泽山咸-兑上艮下"><a href="#第三十一卦-咸-泽山咸-兑上艮下" class="headerlink" title="第三十一卦 咸 泽山咸 兑上艮下"></a>第三十一卦 咸 泽山咸 兑上艮下</h2><p>咸：亨，利贞，取女吉。</p><p>彖曰：咸，感也。柔上而刚下，二气感应以相与，止而说，男下女，是以亨利贞，取女吉也。天地感而万物化生，圣人感人心而天下和平；观其所感，而天地万物之情可见矣！</p><p>象曰：山上有泽，咸；君子以虚受人。</p><p>初六：咸其拇。象曰：咸其拇，志在外也。</p><p>六二：咸其腓，凶，居吉。象曰：虽凶，居吉，顺不害也。</p><p>九三：咸其股，执其随，往吝。象曰：咸其股，亦不处也。志在随人，所执下也。</p><p>九四：贞吉悔亡，憧憧往来，朋从尔思。象曰：贞吉悔亡，未感害也。憧憧往来，未光大也。</p><p>九五：咸其脢，无悔。象曰：咸其脢，志末也。</p><p>上六：咸其辅，颊，舌。象曰：咸其辅，颊，舌，滕口说也。</p><h2 id="第三十二卦-恒-雷风恒-震上巽下"><a href="#第三十二卦-恒-雷风恒-震上巽下" class="headerlink" title="第三十二卦 恒 雷风恒 震上巽下"></a>第三十二卦 恒 雷风恒 震上巽下</h2><p>恒：亨，无咎，利贞，利有攸往。</p><p>彖曰：恒，久也。刚上而柔下，雷风相与，巽而动，刚柔皆应，恒。恒亨无咎，利贞；久於其道也，天地之道，恒久而不已也。利有攸往，终则有始也。日月得天，而能久照，四 时变化，而能久成，圣人久於其道，而天下化成；观其所恒，而天地万物之情可见矣！</p><p>象曰：雷风，恒；君子以立不易方。</p><p>初六：浚恒，贞凶，无攸利。象曰：浚恒之凶，始 求深也。</p><p>九二：悔亡。象曰：九二悔亡，能久中也。</p><p>九三：不恒其德，或承之羞，贞吝。象曰：不恒其德，无所容也。</p><p>九四：田无禽。象曰：久非其位，安得禽也。</p><p>六五：恒其德，贞，妇人吉，夫子凶。象曰：妇人贞吉，从一而终也。夫子制义，从妇凶也。</p><p>上六：振恒，凶。象曰：振恒在上，大无功也。</p><h2 id="第三十三卦-遁-天山遁-乾上艮下"><a href="#第三十三卦-遁-天山遁-乾上艮下" class="headerlink" title="第三十三卦 遁 天山遁 乾上艮下"></a>第三十三卦 遁 天山遁 乾上艮下</h2><p>遁：亨，小利贞。 彖曰：遁亨，遁而亨也。刚当位而应，与时行也。小利贞，浸而长也。遁之时义大矣哉！</p><p>象曰：天下有山，遁；君子以远小人，不恶而严。</p><p>初六：遁尾，厉，勿用有攸往。象曰：遁尾之厉，不往何灾也。</p><p>六二：执之用黄牛之革，莫之胜说。象曰：执用黄牛，固志也。</p><p>九三：系遁，有疾厉，畜臣妾吉。象曰：系遁之厉，有疾惫也。畜臣妾吉，不可大事也。</p><p>九四：好 □ 君子吉，小人否。象曰：君子好遁，小人否也。</p><p>九五：嘉遁，贞吉。象曰：嘉遁贞吉，以正志也。</p><p>上九：肥遁，无不利。象曰：肥遁，无不利；无所疑也。</p><h2 id="第三十四卦-大壮-雷天大壮-震上乾下"><a href="#第三十四卦-大壮-雷天大壮-震上乾下" class="headerlink" title="第三十四卦 大壮 雷天大壮 震上乾下"></a>第三十四卦 大壮 雷天大壮 震上乾下</h2><p>大壮：利贞。 彖曰：大壮，大者壮也。刚以动，故壮。大壮利贞；大者正也。正大而天地之情可见矣！</p><p>象曰：雷在天上，大壮；君子以非礼勿履。</p><p>初九：壮于趾，征凶，有孚。象曰：壮于 趾，其孚穷也。</p><p>九二：贞吉。象曰：九二贞吉，以中也。</p><p>九三：小人用壮，君子用罔，贞厉。羝羊触藩，羸其角。象曰：小人用壮，君子罔也。</p><p>九四：贞吉悔亡，藩决不羸，壮于大舆之輹。象曰：藩决不羸，尚往也。</p><p>六五：丧羊于易，无悔。象曰：丧羊于易，位不当也。</p><p>上六：羝羊触藩，不能退，不能遂，无攸利，艰则吉。象曰：不能退，不能遂，不祥也。艰则吉，咎不长也。</p><h2 id="第三十五卦-晋-火地晋-离上坤下"><a href="#第三十五卦-晋-火地晋-离上坤下" class="headerlink" title="第三十五卦 晋 火地晋 离上坤下"></a>第三十五卦 晋 火地晋 离上坤下</h2><p>晋：康侯用锡马蕃庶，昼日三接。</p><p>彖曰：晋，进也。明出地上，顺而丽乎大明，柔进而上行。是以康侯用锡马蕃庶，昼日三接也。</p><p>象曰：明出地上，晋；君子以自昭明德。</p><p>初六：晋如，摧如，贞吉。罔孚，裕无咎。象 曰：晋如，摧如；独行正也。裕无咎；未受命也。</p><p>六二：晋如，愁如，贞吉。受兹介福，于其王母。象曰：受之介福，以中正也。</p><p>六三：众允，悔亡。象曰：众允之，志上行也。</p><p>九四：晋如硕鼠，贞厉。象曰：硕鼠贞厉，位不当也。</p><p>六五：悔亡，失得勿恤，往吉无不利。象曰：失得勿恤，往有庆也。</p><p>上九：晋其角，维用伐邑，厉吉无咎，贞吝。象曰：维用伐邑，道未光也。</p><h2 id="第三十六卦-明夷-地火明夷-坤上离下"><a href="#第三十六卦-明夷-地火明夷-坤上离下" class="headerlink" title="第三十六卦 明夷 地火明夷 坤上离下"></a>第三十六卦 明夷 地火明夷 坤上离下</h2><p>明夷：利艰贞。 彖曰：明入地中，明夷。内文明而外柔顺，以蒙大难，文王以之。利艰贞，晦其明也，内难而能正其志，箕子以之。</p><p>象曰：明入地中，明夷；君子以莅众，用晦而明。</p><p>初九：明夷于飞，垂其翼。君子于 行，三日不食，有攸往，主人有言。象曰：君子于行，义不食也。</p><p>六二：明夷，夷于左股，用拯马壮，吉。象曰：六二之吉，顺以则也。</p><p>九三：明夷于南狩，得其大首，不可疾贞。象曰：南狩之志，乃大得也。</p><p>六四：入于左腹，获明夷之心，出于门庭。象曰：入于左腹，获心意也。</p><p>六五：箕子之明夷，利贞。象曰：箕子之贞，明不可息也。</p><p>上六：不明晦，初登于天，后入于地。象曰：初登于天，照四国也。后入于地，失则也。</p><h2 id="第三十七卦-家人-风火家人-巽上离下"><a href="#第三十七卦-家人-风火家人-巽上离下" class="headerlink" title="第三十七卦 家人 风火家人 巽上离下"></a>第三十七卦 家人 风火家人 巽上离下</h2><p>家人：利女贞。</p><p>彖曰：家人，女正位乎内，男正位乎外，男女正，天地之大义也。家人有严君焉，父母之谓也。父父，子子，兄兄，弟弟，夫夫，妇妇，而家道正；正家而天下定矣。</p><p>象曰：风自火出，家人；君子以言有物，而行有恒。</p><p>初九：闲有家，悔亡。象曰：闲有家，志未变也。</p><p>六二：无攸遂，在中馈，贞吉。象曰：六二之吉，顺以巽也。</p><p>九三：家人嗃嗃，悔厉吉；妇子嘻嘻，终吝。象曰：家人嗃嗃，未失也；妇子嘻嘻，失家节也。</p><p>六四：富家，大吉。象曰：富家大吉，顺在位也。</p><p>九五：王假有家，勿恤吉。象曰：王假有家，交相爱也。</p><p>上九：有孚威如，终吉。象曰：威如之吉，反身之谓也。</p><h2 id="第三十八卦-睽-火泽睽-离上兑下"><a href="#第三十八卦-睽-火泽睽-离上兑下" class="headerlink" title="第三十八卦 睽 火泽睽 离上兑下"></a>第三十八卦 睽 火泽睽 离上兑下</h2><p>睽：小事吉。</p><p>彖曰：睽，火动而上，泽动而下；二女同居，其志不同行；说而丽乎明，柔进而上行，得中而应乎刚；是以小事吉。天地睽，而其事同也；男女睽，而其志通也；万物睽，而其事 类也；睽之时用大矣哉！</p><p>象曰：上火下泽，睽；君子以同而异。</p><p>初九：悔亡，丧马勿逐，自复；见恶人无咎。象 曰：见恶人，以辟咎也。</p><p>九二：遇主于巷，无咎。象曰：遇主于巷，未失道也。</p><p>六三：见舆曳，其牛掣，其人天且劓，无初有终。象曰：见舆曳，位不当也。无初有终，遇刚也。</p><p>九四：睽孤，遇元夫，交孚，厉无咎。象曰：交孚无咎，志行也。</p><p>六五：悔亡，厥宗噬肤，往何咎。象曰：厥宗噬肤，往有庆也。</p><p>上九：睽孤，见豕负涂，载鬼一车，先张之弧，后说之弧，匪寇婚媾，往遇雨则吉。象曰：遇雨之吉，群疑亡也。</p><h2 id="第三十九卦-蹇-水山蹇-坎上艮下"><a href="#第三十九卦-蹇-水山蹇-坎上艮下" class="headerlink" title="第三十九卦 蹇 水山蹇 坎上艮下"></a>第三十九卦 蹇 水山蹇 坎上艮下</h2><p>蹇：利西南，不利东北；利见大人，贞吉。</p><p>彖曰：蹇，难也，险在前也。见险而能止，知矣哉！蹇利西南，往得中也；不利东北，其道穷也。利见大人，往有功也。当位贞吉，以正邦也。蹇之时用大矣哉！</p><p>象曰：山上有水，蹇；君子以反身修德。</p><p>初六：往蹇，来誉。象曰：往蹇来誉，宜待也。</p><p>六二：王臣蹇蹇，匪躬之故。象曰：王臣蹇蹇，终无尤也。</p><p>九三：往蹇来反。象曰：往蹇来反，内喜之也。</p><p>六四：往蹇来连。象曰：往蹇来连，当位实也。</p><p>九五：大蹇朋来。象曰：大蹇朋来，以中节也。</p><p>上六：往蹇来硕，吉；利见大人。象曰：往蹇来硕，志在内也。利见大人，以从贵也。</p><h2 id="第四十卦-解-雷水解-震上坎下"><a href="#第四十卦-解-雷水解-震上坎下" class="headerlink" title="第四十卦 解 雷水解 震上坎下"></a>第四十卦 解 雷水解 震上坎下</h2><p>解：利西南，无所往，其来复吉。有攸往，夙吉。</p><p>彖曰：解，险以动，动而免乎险，解。解利西南，往得众也。其来复吉，乃得中也。有攸往夙吉，往有功也。天地解，而雷雨作，雷雨作，而百果草木皆甲坼，解之时义大矣哉！</p><p>象曰：雷雨作，解；君子以赦过宥罪。</p><p>初六：无咎。象曰：刚柔之际，义无咎也。</p><p>九二：田获三狐，得黄矢，贞吉。象曰：九二贞吉，得中道也。</p><p>六三：负且乘，致寇至，贞吝。象曰：负且乘，亦可丑也，自我致戎，又谁咎也。</p><p>九四：解而拇，朋至斯孚。象曰：解而拇，未当位也。</p><p>六五：君子维有解，吉；有孚于小人。象曰：君子有解，小人退也。</p><p>上六：公用射隼，于高墉之上，获之，无不利。象曰：公用射隼，以解悖也。</p><h2 id="第四十一卦-损-山泽损-艮上兑下"><a href="#第四十一卦-损-山泽损-艮上兑下" class="headerlink" title="第四十一卦 损 山泽损 艮上兑下"></a>第四十一卦 损 山泽损 艮上兑下</h2><p>损：有孚，元吉，无咎，可贞，利有攸往？曷之用，二簋可用享。</p><p>彖曰：损，损下益上，其道上行。损而有孚，元吉，无咎，可贞，利有攸往。曷之用？二簋可用享；二簋应有时。损刚益柔有时，损益盈虚，与时偕行。</p><p>象曰：山下有泽，损；君子以惩忿窒欲。</p><p>初九：已事遄往，无咎，酌损之。象曰：已事 遄往，尚合志也。</p><p>九二：利贞，征凶，弗损益之。象曰：九二利贞，中以为志也。</p><p>六三：三人行，则损一人；一人行，则得其友。象曰：一人行，三则疑也。</p><p>六四：损其疾，使遄有喜，无咎。象曰：损其疾，亦可喜也。</p><p>六五：或益之，十朋之龟弗克违，元吉。象曰：六五元吉，自上佑也。</p><p>上九：弗损益之，无咎，贞吉，利有攸往，得臣无家。象曰：弗损益之，大得志也。</p><h2 id="第四十二卦-益-风雷益-巽上震下"><a href="#第四十二卦-益-风雷益-巽上震下" class="headerlink" title="第四十二卦 益 风雷益 巽上震下"></a>第四十二卦 益 风雷益 巽上震下</h2><p>益：利有攸往，利涉大川。</p><p>彖曰：益，损上益下，民说无疆，自上下下，其道大光。利有攸往，中正有庆。利涉大川，木道乃行。益动而巽，日进无疆。天施地生，其益无方。凡益之道，与时偕行。</p><p>象曰：风雷，益；君子以见善则迁，有过则改。</p><p>初九：利用为大作，元吉，无咎。象 曰：元吉无咎，下不厚事也。</p><p>六二：或益之，十朋之龟弗克违，永贞吉。王用享于帝，吉。象曰：或益之，自外来也。</p><p>六三：益之用凶事，无咎。有孚中行，告公用圭。象曰：益用凶事，固有之也。</p><p>六四：中行，告公从。利用为依迁国。象曰：告公从，以益志也。</p><p>九五：有孚惠心，勿问元吉。有孚惠我德。象曰：有孚惠心，勿问之矣。惠我德，大得志也。</p><p>上九：莫益之，或击之，立心勿恒，凶。象曰：莫益之，偏辞也。或击之，自外来也。</p><h2 id="第四十三卦-夬-泽天夬-兑上乾下"><a href="#第四十三卦-夬-泽天夬-兑上乾下" class="headerlink" title="第四十三卦 夬 泽天夬 兑上乾下"></a>第四十三卦 夬 泽天夬 兑上乾下</h2><p>夬：扬于王庭，孚号，有厉，告自邑，不利即戎，利有攸往。</p><p>彖曰：夬，决也，刚决柔也。健而说，决而和，扬于王庭，柔乘五刚也。孚号有厉，其危乃光也。告自邑，不利即戎，所尚乃穷也。利有攸往，刚长乃终也。</p><p>象曰：泽上于天，夬；君子以施禄及下，居德则忌。</p><p>初九：壮于前趾，往不胜为吝。 象曰：不胜而往，咎也。</p><p>九二：惕号，莫夜有戎，勿恤。象曰：莫夜有戎，得中道也。</p><p>九三：壮于，有凶。君子夬夬，独行遇雨，若濡有愠，无咎。象曰：君子夬夬，终无咎也。</p><p>九四：臀无肤，其行次且。牵羊悔亡，闻言不信。象曰：其行次且，位不当也。闻言不信，聪不明也。</p><p>九五：苋陆夬夬，中行无咎。象曰：中行无咎，中未光也。</p><p>上六：无号，终有凶。象曰：无号之凶，终不可长也。</p><h2 id="第四十四卦-姤-天风姤-乾上巽下"><a href="#第四十四卦-姤-天风姤-乾上巽下" class="headerlink" title="第四十四卦 姤 天风姤 乾上巽下"></a>第四十四卦 姤 天风姤 乾上巽下</h2><p>姤：女壮，勿用取女。</p><p>彖曰：姤，遇也，柔遇刚也。勿用取女，不可与长也。天地相遇，品物咸章也。刚遇中正，天下大行也。姤之时义大矣哉！</p><p>象曰：天下有风，姤；后以施命诰四方。</p><p>初六：系于金柅，贞吉，有攸往，见凶， 羸豕踟躅。象曰：系于金柅，柔道牵也。</p><p>九二：包有鱼，无咎，不利宾。象曰：包有鱼，义不及宾也。</p><p>九三：臀无肤，其行次且，厉，无大咎。象曰：其行次且，行未牵也。</p><p>九四：包无鱼，起凶。象曰：无鱼之凶，远民也。</p><p>九五：以杞包瓜，含章，有陨自天。象曰：九五含章，中正也。有陨自天，志不舍命也。</p><p>上九：姤其角，吝，无咎。象曰：姤其角，上穷吝也。</p><h2 id="第四十五卦-萃-泽地萃-兑上坤下"><a href="#第四十五卦-萃-泽地萃-兑上坤下" class="headerlink" title="第四十五卦 萃 泽地萃 兑上坤下"></a>第四十五卦 萃 泽地萃 兑上坤下</h2><p>萃：亨。王假有庙，利见大人，亨，利贞。用大牲吉，利有攸往。</p><p>彖曰：萃，聚也；顺以说，刚中而应，故聚也。王假有庙，致孝享也。利见大人亨，聚以正也。用大牲吉，利有攸往，顺天命也。观其所聚，而天地万物之情可见矣。</p><p>象曰：泽上於地，萃；君子以除戎器，戒不虞。</p><p>初六：有孚不终，乃乱乃萃，若号一握 为笑，勿恤，往无咎。象曰：乃乱乃萃，其志乱也。</p><p>六二：引吉，无咎，孚乃利用禴。象曰：引吉无咎，中未变也。</p><p>六三：萃如，嗟如，无攸利，往无咎，小吝。象曰：往无咎，上巽也。</p><p>九四：大吉，无咎。象曰：大吉无咎，位不当也。</p><p>九五：萃有位，无咎。匪孚，元永贞，悔亡。象曰：萃有位，志未光也。</p><p>上六：赍咨涕洟，无咎。象曰：赍咨涕洟，未安上也。</p><h2 id="第四十六卦-升-地风升-坤上巽下"><a href="#第四十六卦-升-地风升-坤上巽下" class="headerlink" title="第四十六卦 升 地风升 坤上巽下"></a>第四十六卦 升 地风升 坤上巽下</h2><p>升：元亨，用见大人，勿恤，南征吉。</p><p>彖曰：柔以时升，巽而顺，刚中而应，是以大亨。用见大人，勿恤；有庆也。南征吉，志行也。</p><p>象曰：地中生木，升；君子以顺德，积小以高大。</p><p>初六：允升，大吉。象曰：允升大 吉，上合志也。</p><p>九二：孚乃利用禴，无咎。象曰：九二之孚，有喜也。</p><p>九三：升虚邑。象曰：升虚邑，无所疑也。</p><p>六四：王用亨于岐山，吉无咎。象曰：王用亨于岐山，顺事也。</p><p>六五：贞吉，升阶。象曰：贞吉升阶，大得志也。</p><p>上六：冥升，利于不息之贞。象曰：冥升在上，消不富也。</p><h2 id="第四十七卦-困-泽水困-兑上坎下"><a href="#第四十七卦-困-泽水困-兑上坎下" class="headerlink" title="第四十七卦 困 泽水困 兑上坎下"></a>第四十七卦 困 泽水困 兑上坎下</h2><p>困：亨，贞，大人吉，无咎，有言不信。</p><p>彖曰：困，刚掩也。险以说，困而不失其所，亨；其唯君子乎？贞大人吉，以刚中也。有言不信，尚口乃穷也。</p><p>象曰：泽无水，困；君子以致命遂志。</p><p>初六：臀困于株木，入于幽谷，三岁不见。象 曰：入于幽谷，幽不明也。</p><p>九二：困于酒食，朱绂方来，利用亨祀，征凶，无咎。象曰：困于酒食，中有庆也。</p><p>六三：困于石，据于蒺藜，入于其宫，不见其妻，凶。象曰：据于蒺藜，乘刚也。入于其宫，不见其妻，不祥也。</p><p>九四：来徐徐，困于金车，吝，有终。象曰：来徐徐，志在下也。虽不当位，有与也。</p><p>九五：劓刖，困于赤绂，乃徐有说，利用祭祀。象曰：劓刖，志未得也。乃徐有说，以中直也。利用祭祀，受福也。</p><p>上六：困于葛藟，于臲卼，曰动悔。有悔，征吉。象曰：困于葛藟，未当也。动悔，有悔吉，行也。</p><h2 id="第四十八卦-井-水风井-坎上巽下"><a href="#第四十八卦-井-水风井-坎上巽下" class="headerlink" title="第四十八卦 井 水风井 坎上巽下"></a>第四十八卦 井 水风井 坎上巽下</h2><p>井：改邑不改井，无丧无得，往来井井。汔至，亦未繘井，羸其瓶，凶。</p><p>彖曰：巽乎水而上水，井；井养而不穷也。改邑不改井，乃以刚中也。汔至亦未繘井，未有功也。羸其瓶，是以凶也。</p><p>象曰：木上有水，井；君子以劳民劝相。</p><p>初六：井泥不食，旧井无禽。象曰：井泥不 食，下也。旧井无禽，时舍也。</p><p>九二：井谷射鲋，瓮敝漏。象曰：井谷射鲋，无与也。</p><p>九三：井渫不食，为我民恻，可用汲，王明，并受其福。象曰：井渫不食，行恻也。求王明，受福也。</p><p>六四：井甃，无咎。象曰：井甃无咎，修井也。</p><p>九五：井冽，寒泉食。象曰：寒泉之食，中正也。</p><p>上六：井收勿幕，有孚无吉。象曰：元吉在上，大成也。</p><h2 id="第四十九卦-革-泽火革-兑上离下"><a href="#第四十九卦-革-泽火革-兑上离下" class="headerlink" title="第四十九卦 革 泽火革 兑上离下"></a>第四十九卦 革 泽火革 兑上离下</h2><p>革：己日乃孚，元亨利贞，悔亡。</p><p>彖曰：革，水火相息，二女同居，其志不相得，曰革。己日乃孚；革而信也。文明以说，大亨以正，革而当，其悔乃亡。天地革而四时成，汤武革命，顺乎天而应乎人，革之时 义大矣哉！ 象曰：泽中有火，革；君子以治历明时。初九：巩用黄牛之革。</p><p>象曰：巩用黄牛，不可 以有为也。</p><p>六二：己日乃革之，征吉，无咎。象曰：己日革之，行有嘉也。</p><p>九三：征凶，贞厉，革言三就，有孚。象曰：革言三就，又何之矣。</p><p>九四：悔亡，有孚改命，吉。象曰：改命之吉，信志也。</p><p>九五：大人虎变，未占有孚。象曰：大人虎变，其文炳也。</p><p>上六：君子豹变，小人革面，征凶，居贞吉。象曰：君子豹变，其文蔚也。小人革面，顺以从君也。</p><h2 id="第五十卦-鼎-火风鼎-离上巽下"><a href="#第五十卦-鼎-火风鼎-离上巽下" class="headerlink" title="第五十卦 鼎 火风鼎 离上巽下"></a>第五十卦 鼎 火风鼎 离上巽下</h2><p>鼎：元吉，亨。</p><p>彖曰：鼎，象也。以木巽火，亨饪也。圣人亨以享上帝，而大亨以养圣贤。巽而耳目聪明，柔进而上行，得中而应乎刚，是以元亨。</p><p>象曰：木上有火，鼎；君子以正位凝命。</p><p>初六：鼎颠趾，利出否，得妾以其子，无咎。 象曰：鼎颠趾，未悖也。利出否，以从贵也。</p><p>九二：鼎有实，我仇有疾，不我能即，吉。象曰：鼎有实，慎所之也。我仇有疾，终无尤也。</p><p>九三：鼎耳革，其行塞，雉膏不食，方雨亏悔，终吉。象曰：鼎耳革，失其义也。</p><p>九四：鼎折足，覆公 □，其形渥，凶。象曰：覆公束，信如何也。</p><p>六五：鼎黄耳金铉，利贞。象曰：鼎黄耳，中以为实也。</p><p>上九：鼎玉铉，大吉，无不利。象曰：玉铉在上，刚柔节也。</p><h2 id="第五十一卦震-震为雷-震上震下"><a href="#第五十一卦震-震为雷-震上震下" class="headerlink" title="第五十一卦震 震为雷 震上震下"></a>第五十一卦震 震为雷 震上震下</h2><p>震：亨。震来虩虩，笑言哑哑。震惊百里，不丧匕鬯。</p><p>彖曰：震，亨。震来虩虩，恐致福也。笑言哑哑，后有则也。震惊百里，惊远而惧迩也。出可以守宗庙社稷，以为祭主也。</p><p>象曰：洊雷，震；君子以恐惧修身。</p><p>初九：震来虩虩，后笑言哑哑，吉。象曰： 震来虩虩，恐致福也。笑言哑哑，后有则也。</p><p>六二：震来厉，亿丧贝，跻于九陵，勿逐，七日得。象曰：震来厉，乘刚也。</p><p>六三：震苏苏，震行无眚。象曰：震苏苏，位不当也。</p><p>九四：震遂泥。象曰：震遂泥，未光也。</p><p>六五：震往来厉，亿无丧，有事。象曰：震往来厉，危行也。其事在中，大无丧也。</p><p>上六：震索索，视矍矍，征凶。震不于其躬，于其邻，无咎。婚媾有言。象曰：震索索，未得中也。虽凶无咎，畏邻戒也。</p><h2 id="第五十二卦-艮-艮为山-艮上艮下"><a href="#第五十二卦-艮-艮为山-艮上艮下" class="headerlink" title="第五十二卦 艮 艮为山 艮上艮下"></a>第五十二卦 艮 艮为山 艮上艮下</h2><p>艮：艮其背，不获其身，行其庭，不见其人，无咎。</p><p>彖曰：艮，止也。时止则止，时行则行，动静不失其时，其道光明。艮其止，止其所也。上下敌应，不相与也。是以不获其身，行其庭不见其人，无咎也。</p><p>象曰：兼山，艮；君子以思不出其位。</p><p>初六：艮其趾，无咎，利永贞。象曰：艮其趾， 未失正也。</p><p>六二：艮其腓，不拯其随，其心不快。象曰：不拯其随，未退听也。</p><p>九三：艮其限，列其夤，厉薰心。象曰：艮其限，危薰心也。</p><p>六四：艮其身，无咎。象曰：艮其身，止诸躬也。</p><p>六五：艮其辅，言有序，悔亡。象曰：艮其辅，以中正也。</p><p>上九：敦艮，吉。象曰：敦艮之吉，以厚终也。</p><h2 id="第五十三卦-渐-风山渐-巽上艮下"><a href="#第五十三卦-渐-风山渐-巽上艮下" class="headerlink" title="第五十三卦 渐 风山渐 巽上艮下"></a>第五十三卦 渐 风山渐 巽上艮下</h2><p>渐：女归吉，利贞。</p><p>彖曰：渐之进也，女归吉也。进得位，往有功也。进以正，可以正邦也。其位刚，得中也。止而巽，动不穷也。</p><p>象曰：山上有木，渐；君子以居贤德，善俗。</p><p>初六：鸿渐于干，小子厉，有言，无咎。 象曰：小子之厉，义无咎也。</p><p>六二：鸿渐于磐，饮食衍衍，吉。象曰：饮食衍衍，不素饱也。</p><p>九三：鸿渐于陆，夫征不复，妇孕不育，凶；利御寇。象曰：夫征不复，离群丑也。妇孕不育，失其道也。利用御寇，顺相保也。</p><p>六四：鸿渐于木，或得其桷，无咎。象曰：或得其桷，顺以巽也。</p><p>九五：鸿渐于陵，妇三岁不孕，终莫之胜，吉。象曰：终莫之胜，吉；得所愿也。</p><p>上九：鸿渐于逵，其羽可用为仪，吉。象曰：其羽可用为仪，吉；不可乱也。</p><h2 id="第五十四卦-归妹-雷泽归妹-震上兑下"><a href="#第五十四卦-归妹-雷泽归妹-震上兑下" class="headerlink" title="第五十四卦 归妹 雷泽归妹 震上兑下"></a>第五十四卦 归妹 雷泽归妹 震上兑下</h2><p>归妹：征凶，无攸利。</p><p>彖曰：归妹，天地之大义也。天地不交，而万物不兴，归妹人之终始也。说以动，所归妹也。征凶，位不当也。无攸利，柔乘刚也。</p><p>象曰：泽上有雷，归妹；君子以永终知敝。</p><p>初九：归妹以娣，跛能履，征吉。象曰：归 妹以娣，以恒也。跛能履吉，相承也。</p><p>九二：眇能视，利幽人之贞。象曰：利幽人之贞，未变常也。</p><p>六三：归妹以须，反归以娣。象曰：归妹以须，未当也。</p><p>九四：归妹愆期，迟归有时。象曰：愆期之志，有待而行也。</p><p>六五：帝乙归妹，其君之袂，不如其娣之袂良，月几望，吉。象曰：帝乙归妹，不如其娣之袂良也。其位在中，以贵行也。</p><p>上六：女承筐无实，士刲羊无血，无攸利。象曰：上六无实，承虚筐也。</p><h2 id="第五十五卦-丰-雷火-丰震上离下"><a href="#第五十五卦-丰-雷火-丰震上离下" class="headerlink" title="第五十五卦 丰 雷火 丰震上离下"></a>第五十五卦 丰 雷火 丰震上离下</h2><p>丰：亨，王假之，勿忧，宜日中。</p><p>彖曰：丰，大也。明以动，故丰。王假之，尚大也。勿忧宜日中，宜照天下也。日中则昃，月盈则食，天地盈虚，与时消息，而况人於人乎？况於鬼神乎？</p><p>象曰：雷电皆至，丰；君子以折狱致刑。</p><p>初九：遇其配主，虽旬无咎，往有尚。象曰： 虽旬无咎，过旬灾也。</p><p>六二：丰其蔀，日中见斗，往得疑疾，有孚发若，吉。象曰：有孚发若，信以发志也。</p><p>九三：丰其沛，日中见昧，折其右肱，无咎。象曰：丰其沛，不可大事也。折其右肱，终不可用也。</p><p>九四：丰其蔀，日中见斗，遇其夷主，吉。象曰：丰其蔀，位不当也。日中见斗，幽不明也。遇其夷主，吉；行也。</p><p>六五：来章，有庆誉，吉。象曰：六五之吉，有庆也。</p><p>上六：丰其屋，蔀其家，窥其户，阒其无人，三岁不见，凶。象曰：丰其屋，天际翔也。窥其户，阒其无人，自藏也。</p><h2 id="第五十六卦-旅-火山旅-离上艮下"><a href="#第五十六卦-旅-火山旅-离上艮下" class="headerlink" title="第五十六卦 旅 火山旅 离上艮下"></a>第五十六卦 旅 火山旅 离上艮下</h2><p>旅：小亨，旅贞吉。</p><p>彖曰：旅，小亨，柔得中乎外，而顺乎刚，止而丽乎明，是以小亨，旅贞吉也。旅之时义大矣哉！</p><p>象曰：山上有火，旅；君子以明慎用刑，而不留狱。</p><p>初六：旅琐琐，斯其所取灾。象 曰：旅琐琐，志穷灾也。</p><p>六二：旅即次，怀其资，得童仆贞。象曰：得童仆贞，终无尤也。</p><p>九三：旅焚其次，丧其童仆，贞厉。象曰：旅焚其次，亦以伤矣。以旅与下，其义丧也。</p><p>九四：旅于处，得其资斧，我心不快。象曰：旅于处，未得位也。得其资斧，心未快也。</p><p>六五：射雉一矢亡，终以誉命。象曰：终以誉命，上逮也。</p><p>上九：鸟焚其巢，旅人先笑后号啕。丧牛于易，凶。象曰：以旅在上，其义焚也。丧牛于易，终莫之闻也。</p><h2 id="第五十七卦-巽-巽为风-巽上巽下"><a href="#第五十七卦-巽-巽为风-巽上巽下" class="headerlink" title="第五十七卦 巽 巽为风 巽上巽下"></a>第五十七卦 巽 巽为风 巽上巽下</h2><p>巽：小亨，利攸往，利见大人。</p><p>彖曰：重巽以申命，刚巽乎中正而志行。柔皆顺乎刚，是以小亨，利有攸往，利见大人。</p><p>象曰：随风，巽；君子以申命行事。</p><p>初六：进退，利武人之贞。象曰：进退，志疑也。 利武人之贞，志治也。</p><p>九二：巽在床下。用史巫纷若，吉无咎。象曰：纷若之吉，得中也。</p><p>九三：频巽，吝。象曰：频巽之吝，志穷也。</p><p>六四：悔亡，田获三品。象曰：田获三品，有功也。</p><p>九五：贞吉悔亡，无不利。无初有终，先庚三日，后庚三日，吉。象曰：九五之吉，位正中也。</p><p>上九：巽在床下，丧其资斧，贞凶。象曰：巽在 □ 下，上穷也。丧其资斧，正乎凶也。</p><h2 id="第五十八卦-兑-兑为泽-兑上兑下"><a href="#第五十八卦-兑-兑为泽-兑上兑下" class="headerlink" title="第五十八卦 兑 兑为泽 兑上兑下"></a>第五十八卦 兑 兑为泽 兑上兑下</h2><p>兑：亨，利贞。</p><p>彖曰：兑，说也。刚中而柔外，说以利贞，是以顺乎天，而应乎人。说以先民，民忘其劳；说以犯难，民忘其死；说之大，民劝矣哉！</p><p>象曰：丽泽，兑；君子以朋友讲习。</p><p>初九：和兑，吉。象曰：和兑之吉，行未疑也。</p><p>九二：孚兑，吉，悔亡。象曰：孚兑之吉，信志也。</p><p>六三：来兑，凶。象曰：来兑之凶，位不当也。</p><p>九四：商兑，未宁，介疾有喜。象曰：九四之喜，有庆也。</p><p>九五：孚于剥，有厉。象曰：孚于剥，位正当也。</p><p>上六：引兑。象曰：上六引兑，未光也。</p><h2 id="第五十九卦-涣-风水涣-巽上坎下"><a href="#第五十九卦-涣-风水涣-巽上坎下" class="headerlink" title="第五十九卦 涣 风水涣 巽上坎下"></a>第五十九卦 涣 风水涣 巽上坎下</h2><p>涣：亨。王假有庙，利涉大川，利贞。</p><p>彖曰：涣，亨。刚来而不穷，柔得位乎外而上同。王假有庙，王乃在中也。利涉大川，乘木有功也。</p><p>象曰：风行水上，涣；先王以享于帝立庙。</p><p>初六：用拯马壮，吉。象曰：初六之吉，顺 也。</p><p>九二：涣奔其机，悔亡。象曰：涣奔其机，得愿也。</p><p>六三：涣其躬，无悔。象曰：涣其躬，志在外也。</p><p>六四：涣其群，元吉。涣有丘，匪夷所思。象曰：涣其群，元吉；光大也。</p><p>九五：涣汗其大号，涣王居，无咎。象曰：王居无咎，正位也。</p><p>上九：涣其血，去逖出，无咎。象曰：涣其血，远害也。</p><h2 id="第六十卦-节-水泽节-坎上兑下"><a href="#第六十卦-节-水泽节-坎上兑下" class="headerlink" title="第六十卦 节 水泽节 坎上兑下"></a>第六十卦 节 水泽节 坎上兑下</h2><p>节：亨。苦节不可贞。</p><p>彖曰：节，亨，刚柔分，而刚得中。苦节不可贞，其道穷也。说以行险，当位以节，中正以通。天地节而四时成，节以制度，不伤财，不害民。</p><p>象曰：泽上有水，节；君子以制数度，议德行。</p><p>初九：不出户庭，无咎。象曰：不出户 庭，知通塞也。</p><p>九二：不出门庭，凶。象曰：不出门庭，失时极也。</p><p>六三：不节若，则嗟若，无咎。象曰：不节之嗟，又谁咎也。</p><p>六四：安节，亨。象曰：安节之亨，承上道也。</p><p>九五：甘节，吉；往有尚。象曰：甘节之吉，居位中也。</p><p>上六：苦节，贞凶，悔亡。象曰：苦节贞凶，其道穷也。</p><h2 id="第六十一卦-中孚-风泽中孚-巽上兑下"><a href="#第六十一卦-中孚-风泽中孚-巽上兑下" class="headerlink" title="第六十一卦 中孚 风泽中孚 巽上兑下"></a>第六十一卦 中孚 风泽中孚 巽上兑下</h2><p>中孚：豚鱼吉，利涉大川，利贞。</p><p>彖曰：中孚，柔在内而刚得中。说而巽，孚，乃化邦也。豚鱼吉，信及豚鱼也。利涉大川，乘木舟虚也。中孚以利贞，乃应乎天也。</p><p>象曰：泽上有风，中孚；君子以议狱缓死。</p><p>初九：虞吉，有他不燕。象曰：初九虞吉， 志未变也。</p><p>九二：鸣鹤在阴，其子和之，我有好爵，吾与尔靡之。象曰：其子和之，中心愿也。</p><p>六三：得敌，或鼓或罢，或泣或歌。象曰：可鼓或罢，位不当也。</p><p>六四：月几望，马匹亡，无咎。象曰：马匹亡，绝类上也。</p><p>九五：有孚挛如，无咎。象曰：有孚挛如，位正当也。</p><p>上九：翰音登于天，贞凶。象曰：翰音登于天，何可长也。</p><h2 id="第六十二卦-小过-雷山小过-震上艮下"><a href="#第六十二卦-小过-雷山小过-震上艮下" class="headerlink" title="第六十二卦 小过 雷山小过 震上艮下"></a>第六十二卦 小过 雷山小过 震上艮下</h2><p>小过：亨，利贞，可小事，不可大事。飞鸟遗之音，不宜上宜下，大吉。</p><p>彖曰：小过，小者过而亨也。过以利贞，与时行也。柔得中，是以小事吉也。刚失位而不中，是以不可大事也。有飞鸟之象焉，有飞鸟遗之音，不宜上宜下，大吉；上逆而下顺 也。</p><p>象曰：山上有雷，小过；君子以行过乎恭，丧过乎哀，用过乎俭。</p><p>初六：飞鸟以凶。象 曰：飞鸟以凶，不可如何也。</p><p>六二：过其祖，遇其妣；不及其君，遇其臣；无咎。象曰：不及其君，臣不可过也。</p><p>九三：弗过防之，从或戕之，凶。象曰：从或戕之，凶如何也。</p><p>九四：无咎，弗过遇之。往厉必戒，勿用永贞。象曰：弗过遇之，位不当也。往厉必戒，终不可长也。</p><p>六五：密云不雨，自我西郊，公弋取彼在穴。象曰：密云不雨，已上也。</p><p>上六：弗遇过之，飞鸟离之，凶，是谓灾眚。象曰：弗遇过之，已亢也。</p><h2 id="第六十三卦-既济-水火既济-坎上离下"><a href="#第六十三卦-既济-水火既济-坎上离下" class="headerlink" title="第六十三卦 既济 水火既济 坎上离下"></a>第六十三卦 既济 水火既济 坎上离下</h2><p>既济：亨，小利贞，初吉终乱。</p><p>彖曰：既济，亨，小者亨也。利贞，刚柔正而位当也。初吉，柔得中也。终止则乱，其道穷也。</p><p>象曰：水在火上，既济；君子以思患而预防之。</p><p>初九：曳其轮，濡其尾，无咎。象曰： 曳其轮，义无咎也。</p><p>六二：妇丧其茀，勿逐，七日得。象曰：七日得，以中道也。</p><p>九三：高宗伐鬼方，三年克之，小人勿用。象曰：三年克之，惫也。</p><p>六四：（纟需）有衣袽，终日戒。象曰：终日戒，有所疑也。</p><p>九五：东邻杀牛，不如西邻之禴祭，实受其福。象曰：东邻杀牛，不如西邻之时也；实受其福，吉大来也。</p><p>上六：濡其首，厉。象曰：濡其首厉，何可久也。</p><h2 id="第六十四卦-未济-火水未济-离上坎下"><a href="#第六十四卦-未济-火水未济-离上坎下" class="headerlink" title="第六十四卦 未济 火水未济 离上坎下"></a>第六十四卦 未济 火水未济 离上坎下</h2><p>未济：亨，小狐汔济，濡其尾，无攸利。</p><p>彖曰：未济，亨；柔得中也。小狐汔济，未出中也。濡其尾，无攸利；不续终也。虽不当位，刚柔应也。</p><p>象曰：火在水上，未济；君子以慎辨物居方。</p><p>初六：濡其尾，吝。象曰：濡其尾，亦不 知极也。</p><p>九二：曳其轮，贞吉。象曰：九二贞吉，中以行正也。</p><p>六三：未济，征凶，利涉大川。象曰：未济征凶，位不当也。</p><p>九四：贞吉，悔亡，震用伐鬼方，三年有赏于大国。象曰：贞吉悔亡，志行也。</p><p>六五：贞吉，无悔，君子之光，有孚，吉。象曰：君子之光，其晖吉也。</p><p>上九：有孚于饮酒，无咎，濡其首，有孚失是。象曰：饮酒濡首，亦不知节也</p><p>全文完</p>]]></content>
      
      
      <categories>
          
          <category> 一书一世界 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>站点文章导航</title>
      <link href="blog/guide_post/"/>
      <url>blog/guide_post/</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1622192869413-b170ca0a-ff41-434d-bafb-5499b6b3636e.jpeg#clientId=u1fd0526c-da52-4&from=ui&height=308&id=ucc1528f2&margin=%5Bobject%20Object%5D&name=52853677_p0.jpg&originHeight=900&originWidth=1600&originalType=binary%E2%88%B6=1&size=903023&status=done&style=none&taskId=ub717e977-8ca5-48aa-b578-baf0ef60d0d&width=548.0208740234375" alt="52853677_p0.jpg"><br>​</p><div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">建站初衷就是从大学伊始做一些文字记录，站点所有文章大类分两类：『技术』和『随笔』，具体的文章整理我是依据文章分类来划分的，下面内容会详述之。所有文章都可能二次修改，比如更新，增加，删除内容等。</div><div style="background: #edf9e8;padding:10px;border: 1px solid #c2d2b5;border-radius:5px;margin-bottom:5px;">✨欢迎交流！</div><h2 id="一、技术博客相关"><a href="#一、技术博客相关" class="headerlink" title="一、技术博客相关"></a>一、技术博客相关</h2><div style="background: #fffbe6;padding:10px;border: 1px solid #e0d1b1;border-radius:5px;margin-bottom:5px;">对技术的分类比较细，是因为想让自己的CS知识体系在不断的学习过程中不断完善精进。</div><div style="background: #FFF3F3;padding:10px;border: 1px solid #DEB8BE;border-radius:5px;margin-bottom:5px;">注意：部分文章为个人知识学习笔记，其排版抑或是内容可能不会完整，个人笔记方式为搭建知识框架，其内容不一定全部书写记录。</div>​<table><thead><tr><th>分类</th><th>描述</th></tr></thead><tbody><tr><td>Algorithm</td><td>『算法』及其相关刷题的总结</td></tr><tr><td>Bug</td><td>开发过程中遇到的各种需要记录的『bug』</td></tr><tr><td>ComputerNetwork</td><td>『计算机网络』相关知识</td></tr><tr><td>ComputerOperatingSystem</td><td>『操作系统』相关知识</td></tr><tr><td>ComputerOrganization</td><td>『计算机组成原理』相关知识</td></tr><tr><td>DataAnalysis</td><td>『Python 数据分析』技术</td></tr><tr><td>DataBase</td><td>『数据库』相关知识</td></tr><tr><td>DataStructure</td><td>『数据结构』及其相关刷题的总结</td></tr><tr><td>Environment</td><td>『开发环境』的搭建+『开发工具』使用的总结</td></tr><tr><td>Hexo</td><td>『Hexo』博客相关</td></tr><tr><td>Language</td><td>各种『编程语言』+外语（英语）总结</td></tr><tr><td>MachingLearning</td><td>曾经的几篇『机器学习』文章</td></tr><tr><td>PostProduction</td><td>『后期制作』</td></tr><tr><td>SoftwareEngineering</td><td>『软件工程』相关知识</td></tr><tr><td>VersionControlSystem</td><td>版本控制系统（『Git 和 GitHub』使用）</td></tr><tr><td>Web</td><td>web 相关知识（该分类太大，日后还会细分）</td></tr></tbody></table><h2 id="二、生活随笔相关"><a href="#二、生活随笔相关" class="headerlink" title="二、生活随笔相关"></a>二、生活随笔相关</h2><div style="background: #fffbe6;padding:10px;border: 1px solid #e0d1b1;border-radius:5px;margin-bottom:5px;">生活随笔的分类并没有上面技术博客那么细致，是因为我大多数是随心随性写随笔，不想太拘束于文本的框架。</div>​<table><thead><tr><th>分类</th><th>描述</th></tr></thead><tbody><tr><td>一书一世界</td><td>对读过的书所做的一些文笔放在这</td></tr><tr><td>人生影视课</td><td>对观过的影视所做的一些文笔放在这</td></tr><tr><td>异世界</td><td>异世界的通感……</td></tr><tr><td>随笔</td><td>除了上面的具体分类，其他文章放在这</td></tr><tr><td>游戏娱乐</td><td>游戏娱乐</td></tr></tbody></table><blockquote><p>另外，如果你想了解博主，可以前往『<a href="https://www.wztlink1013.com/about/">https://www.wztlink1013.com/about/</a>』页面查看~</p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>RSA公钥密码算法</title>
      <link href="blog/ccd10c/"/>
      <url>blog/ccd10c/</url>
      
        <content type="html"><![CDATA[<blockquote><p>最近利用自己曾经写过的一篇文章『<a href="https://www.wztlink1013.com/blog/bw80k6/">https://www.wztlink1013.com/blog/bw80k6/</a>』（利用一次抓包来复习学习过的计网知识）</p></blockquote><p>在分析 HTTPS 和 HTTP 这两个协议之间的区别的时候，我感觉 HTTPS 的 SSL(Secure Sockets Layer 安全套接字协议)证书很类似之前老师讲过的 RSA 算法，做此篇文章复习下 RSA 算法和加深 HTTPS 的理解。</p><p>在密码学当中，由对称密钥和非对称密钥之分。</p><h2 id="对称密钥"><a href="#对称密钥" class="headerlink" title="对称密钥"></a>对称密钥</h2><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612943343546-b8330998-9019-40a1-9759-12b459d5379b.png#align=left&display=inline&height=345&margin=%5Bobject%20Object%5D&name=image.png&originHeight=690&originWidth=982&size=266245&status=done&style=stroke&width=491" alt="image.png"><br>用一个简单的凯撒密码例子来讲解一下对称密钥：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612943823633-5283daed-a125-46fd-a785-93851daf5269.png#align=left&display=inline&height=325&margin=%5Bobject%20Object%5D&name=image.png&originHeight=650&originWidth=957&size=205858&status=done&style=stroke&width=478.5" alt="image.png"><br>上图是凯撒密码的定义，先说一下怎么用：</p><p>假如张三和李四两个人之间需要传输一段密码 apple，他们之间共同约定使用密钥-3（再上图表示就为 e 字母编程 b 字母了，以此类推），而这个算法是基于<a href="https://zh.wikipedia.org/wiki/%E6%A8%A1%E9%99%A4">mod 运算</a>（在这里看成是一种加密/解密机制）的。</p><p>张三利用 mod 运算加密机制（mod 运算）将 apple 转换位 xmmfb<br>李四利用 mod 运算解密机制（mod 运算）将 xmmfb 转换位 apple</p><blockquote><p>a 为什么到 x：（0-3）mod26 可以看成（23-26）mod26=23，所以 a 往后退三位还是 x</p></blockquote><p>上述例子的加密机制和解密机制算法一样（mod 运算），实际上也可以不一样，不做详述。但是可以说名对称加密的密钥都一样，该例子中表现为-3</p><h2 id="RSA-公钥密码算法"><a href="#RSA-公钥密码算法" class="headerlink" title="RSA 公钥密码算法"></a>RSA 公钥密码算法</h2><p>RSA 公钥密码算法是非对称加密。</p><p>先说一下和上面的对称密钥的不同，很简单，不同之处就是对称密钥只有一个密钥，而非对称密钥有两个（我觉得严谨来说可以有多个，但在这里先局限地说有两个），而且一个叫公钥，一个叫密钥。</p><p>还是上面的张三李四例子，就相当于张三这次用公钥来加密 apple 这个单词，加密成一段密文，这段密文<strong>只能由密钥来解密</strong>，即便是你有了公钥，也不能将其解密。</p><p>然后来抛出几个问题来分析之：</p><blockquote><p>【Q1】公钥和密钥怎么来规定呢？我要是一个网络攻击者，我利用公钥来推理出密钥，那我岂不是直接解密了？！</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612945567958-1cd39a87-ba61-4dd8-955e-1a4fc130378d.png#align=left&display=inline&height=290&margin=%5Bobject%20Object%5D&name=image.png&originHeight=579&originWidth=474&size=117414&status=done&style=stroke&width=237" alt="image.png"><br>具体的相关 mod 运算在此不做详述</p><blockquote><p>【Q2】算法可靠与否</p></blockquote><p>为了保证严谨，同时也证明了这种算法的</p><ul><li>可行性，所计算出来的算法复杂度最高是 4 次方，对计算机而言，可计算</li><li>不可攻破，在学界，大数因子分解不可行，或者说，如今的科技还不能轻易的破解</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612945767363-ee62dad7-357d-42d3-a932-78cc10d29866.png#align=left&display=inline&height=337&margin=%5Bobject%20Object%5D&name=image.png&originHeight=674&originWidth=985&size=269673&status=done&style=stroke&width=492.5" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612945781929-bea0946c-3f24-472d-a4d4-3c40abd83ee3.png#align=left&display=inline&height=244&margin=%5Bobject%20Object%5D&name=image.png&originHeight=487&originWidth=987&size=177512&status=done&style=stroke&width=493.5" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
          <category> RSA算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>HTTPS较HTTP安全在哪？</title>
      <link href="blog/pl8gro/"/>
      <url>blog/pl8gro/</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612949716697-1ceb6a5c-fa5e-4129-9c0a-63e01ce75057.png#align=left&display=inline&height=51&margin=%5Bobject%20Object%5D&name=image.png&originHeight=56&originWidth=615&size=6666&status=done&style=shadow&width=564" alt="image.png"></p><h2 id="HTTPS-的精妙之处"><a href="#HTTPS-的精妙之处" class="headerlink" title="HTTPS 的精妙之处"></a>HTTPS 的精妙之处</h2><p>在我写的算法相关文章里面，有一篇 RSA 相关的文章<a href="https://www.wztlink1013.com/blog/ccd10c/">https://www.wztlink1013.com/blog/ccd10c/</a>，里面解释了对称加密和的非对称加密</p><p>我觉得 HTTPS 的精妙之处就是在于它同时运用了<strong>对称加密（AES）</strong>和<strong>非对称加密（RSA）</strong>两种加密，下面我解释一下：</p><h2 id="HTTP-为何不安全？"><a href="#HTTP-为何不安全？" class="headerlink" title="HTTP 为何不安全？"></a>HTTP 为何不安全？</h2><p>客户端对服务端做出请求，然后服务端做出响应，这个大家都知道，但是 HTTP 是明文传输，我在<a href="https://www.wztlink1013.com/blog/bw80k6/">https://www.wztlink1013.com/blog/bw80k6/</a>这篇文章里面也详细抓包展示了 HTTP 的明文传输<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612946821326-d568e02e-1173-4af4-93c5-539275023ba3.png#align=left&display=inline&height=282&margin=%5Bobject%20Object%5D&name=image.png&originHeight=563&originWidth=1544&size=287151&status=done&style=stroke&width=772" alt="image.png"><br>这样传输的信息就不安全，攻击者就能轻易得到，进一步讲，得到了就不安全吗？</p><ul><li>因为假如此时服务端响应给客户端的是很重要的诸如密码或者个人信息之类的敏感信息，就会被窃听</li><li>中途截取，将所传输的信息不完整等等</li></ul><h2 id="HTTPS-安全在哪？精妙之处！"><a href="#HTTPS-安全在哪？精妙之处！" class="headerlink" title="HTTPS 安全在哪？精妙之处！"></a>HTTPS 安全在哪？精妙之处！</h2><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612947167321-69c11c8d-9f8d-4f78-80a9-b2ee1c02e6b8.png#align=left&display=inline&height=259&margin=%5Bobject%20Object%5D&name=image.png&originHeight=517&originWidth=992&size=373859&status=done&style=stroke&width=496" alt="image.png"><br>由上图所示，HTTPS 的协议栈相较 HTTP 协议栈多了安全层，也就是 SSL(安全套接层)或者 TSL(安全传输层)协议</p><ol><li><p>客户端向服务端发出一个 https 请求，其中端口位 443</p><blockquote><p>说明：采用 https 的网站都会有相应的 ssl 证书，在服务器那里，这个证书内容就是颁发的机构、到期时间……，而这个证书的形式就是以公钥的形式存在于服务器的。</p></blockquote></li><li><p>服务端响应给客户端这个证书（公钥的形式）</p></li><li><p>客户端解析响应来的公钥，因为需要验证这个 ssl 是不是伪造的还是过期了等等，假如验证不成功，就会如下：</p></li></ol><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612948950125-219e56dd-b6cd-4245-8aa5-44ad8e6e381c.png#align=left&display=inline&height=38&margin=%5Bobject%20Object%5D&name=image.png&originHeight=75&originWidth=605&size=7708&status=done&style=stroke&width=302.5" alt="image.png"></p><ol start="4"><li>然后客户端（浏览器）利用这个公钥随机得出的私钥，然后将这个私钥发给服务端，以后客户端和服务端就可以利用这个密钥来解密双方传来传去的加密信息了<blockquote><p>说明：随机的出的私钥并不是那么“随机”，因为要保证不可攻破性，具体可以看我的 RSA 算法相关文章</p></blockquote></li></ol><hr><ol start="5"><li>服务端将要展示给客户端的具体信息利用上述私钥来加密</li><li>客户端接收到服务端发过来的加密信息，用共同都有的私钥解密查看之<blockquote><p>整个过程对外人而言看到的都是加密后的信息，而不是明文</p></blockquote></li></ol><p>综上，56 条是采用了 AES 对称加密，而前面是利用 RSA 算法得到私钥</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>这位博主（数据中心网络工程师）将 SSL 讲解的更加细致，可以常看：<a href="https://cshihong.github.io/2019/05/09/SSL%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/">SSL/TLS 协议详解</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> ComputerNetwork </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>关于CDN的一些概念</title>
      <link href="blog/fxzcy3/"/>
      <url>blog/fxzcy3/</url>
      
        <content type="html"><![CDATA[<h2 id="CDN-回源"><a href="#CDN-回源" class="headerlink" title="CDN 回源"></a>CDN 回源</h2><p>cdn 回源是什么意思？CDN 回源包括回源地址和加速<a href="https://www.west.cn/services/domain/">域名</a>。常规的 CDN 都是回源的。即：当有用户访问某一个 URL 的时候，如果被解析到的那个 CDN 节点没有缓存响应的内容，或者是缓存已经到期，就会回源站去获取。如果没有人访问，那么 CDN 节点不会主动去源站拿的。<br>回源地址：可以使回源域名，也可以是回源 IP，主要作用是 CDN 加速节点同步更新的一个地址；<br>加速域名：使用 CDN<a href="https://www.west.cn/cloudhost/">服务器</a>需要加速的一个域名，一般会将加速域名做别名解析为 CDN 运营商提供的域名，来做 CDN 加速访问。<br><a href="https://www.west.cn/docs/wp-content/uploads/2018/05/n-40.jpg"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1612941062375-753094ca-dc39-494d-abaf-022708a631a3.jpeg#align=left&display=inline&height=300&margin=%5Bobject%20Object%5D&originHeight=300&originWidth=581&size=0&status=done&style=stroke&width=581"></a><br>回源域名一般是 cdn 领域的专业术语，通常情况下，是直接用 ip 进行回源的，但是如果客户源站有多个 ip，并且 ip 地址会经常变化，对于 cdn 厂商来说，为了避免经常更改配置（回源 ip），会采用回源域名方式进行回源，这样即使源站的 ip 变化了，也不影响原有的配置。<br>CDN 本来是给网站加速的，但是有时会因为不合适的回源策略给服务器带来负担，只有选择正确的策略才能给自己的网站带来更高的访问效率。</p><h2 id="网站优化"><a href="#网站优化" class="headerlink" title="网站优化"></a>网站优化</h2><h3 id="Gzip-智能压缩"><a href="#Gzip-智能压缩" class="headerlink" title="Gzip 智能压缩"></a>Gzip 智能压缩</h3><p>gzip 是 GNUzip 的缩写，最早用于 UNIX 系统的文件压缩</p><p>HTTP 协议上的 gzip 编码是一种用来改进 web 应用程序性能的技术，web 服务器和客户端（浏览器）必须共同支持 gzip<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612939525023-772b71d1-11ea-4f13-8629-500d71865e16.png#align=left&display=inline&height=352&margin=%5Bobject%20Object%5D&name=image.png&originHeight=703&originWidth=1091&size=127314&status=done&style=stroke&width=545.5" alt="image.png"></p><h3 id="Brotli-智能压缩"><a href="#Brotli-智能压缩" class="headerlink" title="Brotli 智能压缩"></a>Brotli 智能压缩</h3><p>也是一种静态资源压缩算法，并且也支持 HTTPS</p><h3 id="页面压缩"><a href="#页面压缩" class="headerlink" title="页面压缩"></a>页面压缩</h3><p>去除掉页面的注释或空格提高传输效率</p><h3 id="302-调度"><a href="#302-调度" class="headerlink" title="302 调度"></a>302 调度</h3><p><a href="https://cloud.tencent.com/developer/article/1445728">CDN 系列学习文章（三）——302 调度</a></p><p>作者：深蓝加菲<br>链接：<a href="https://www.zhihu.com/question/32148047/answer/70920110">https://www.zhihu.com/question/32148047/answer/70920110</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><p>一般是两者结合，DNS 做省市级别和跨运营商的调度， 302 做基于内容和精确 IP 的精确调度<br>DNS 的优点：<br>DNS 系统是天然的分布式结构<br>客户端本机，LDNS 都可以实现 cache，<strong>架构本身就能实现高的伸缩性和性能</strong></p><hr><p>DNS 的缺点：<br>DNS 并不是为 GSLB 设计的<br>GSLB 基于 local DNS 的地址判断，<strong>粒度较粗</strong>。而且 LDNS 可能和 end user 网络距离很远。<br>用户可能会设置错误的 Local DNS，该服务器和用户实际距离较远，比如 8.8.8.8 等(edns-client-subnet 可以部分解决该问题)<br>DNS 请求里面<strong>不会带有内容信息</strong>，GSLB 只能拥有 LDNS ip 信息，无法针对内容作出更加灵活的判断<br>因为 DNS reply TTL，所以某个用户一段时间内的请求都会导向同一个 site (解决：趋向于较短的 TTL)<br>因为 local dns 缓存和 TTL 的存在，你很难判断某次的返回会对负载有多大影响<br>某些 Local DNS 会忽略 DNS TTL 信息，而采用固定的 TTL 时间，对此我们无能为力<br>电信系统倾向于直接使用 ip 地址访问，不使用域名</p><hr><p>302 的优点：<br>可以直接得到 end user ip 和内容的地址，可以<strong>做出精确的 redirect</strong><br>每个请求都需要访问 GSLB,可以做出单独的处理<br>可以在一个点方便的作出统计和认证</p><hr><p>302 的缺点：<br>需要应用层协议支持(http / rtsp)<br>一般有重定向次数限制<br>GSLB 需要处理较多的请求，却没有 LDNS 作为 cache<br>GSLB 暴露给 end user ， 容易遭受攻击<br>用户访问 GSLB 本身就会带来时延，可能深圳的用户需要访问北京的 GSLB<br>单点故障(可以通过 GSLB 服务群集解决)<br>某些应用对 URL 变化敏感，比如 WEB<br>某些客户端支持不好(中文字符集等问题)</p><h3 id="TLS1-3"><a href="#TLS1-3" class="headerlink" title="TLS1.3"></a>TLS1.3</h3><p>TLS 1.3 是一种全新的加密协议，它既能提高终端用户的访问速度，又能增强安全性</p><h3 id="HTTP-2-Server-Push"><a href="#HTTP-2-Server-Push" class="headerlink" title="HTTP/2 + Server Push"></a>HTTP/2 + Server Push</h3><h3 id="WebP-自适应"><a href="#WebP-自适应" class="headerlink" title="WebP 自适应"></a>WebP 自适应</h3><p>WebP 自适应功能是 CDN 平台智能判断客户端浏览器是否支持 WebP 解码，如支持则返回 WebP 格式图片，否则返回原图，客户端以及源站无需任何改动。开启该特性，可以有效节省 CDN 传输带宽，加速图片渲染速度。</p><h2 id="网站防攻击"><a href="#网站防攻击" class="headerlink" title="网站防攻击"></a>网站防攻击</h2><h3 id="IP-限制访问"><a href="#IP-限制访问" class="headerlink" title="IP 限制访问"></a>IP 限制访问</h3><h3 id="CC-防护"><a href="#CC-防护" class="headerlink" title="CC 防护"></a>CC 防护</h3>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
          <category> 网站相关 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>『Re：从零开始的异世界生活』</title>
      <link href="essay/ghnpqy/"/>
      <url>essay/ghnpqy/</url>
      
        <content type="html"><![CDATA[<div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">“我可是经历过死亡的人！”</div>第一次听到486说这句话的时候，我是有很大的感触的，甚至是共鸣，因为，见过地狱的人啊……被历史所记载下来的人，总有异于常人的行为准则。<p>希特勒，大三寒假在家那会在家看了郭伟强作者译作的《希特勒》一书，以前，我觉得我或多或少了解那个恶魔，因为二战，我觉得这人应该是人们脑海中残酷战争的人形代表吧。或在少年时期，一个人的精神和心智都是极其可变的……</p><p>如果把思维换一下来思考，如果，我明天就死了，那么现在的我会做出什么样的行为呢？因为懂得地狱的可怕，那可怕来自心里面的恐惧、来自亲人爱人的离去、来自一切想要去守护的人的离去……</p><p>见过地狱的人啊。</p><div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">如果真爱有颜色，那么一定是蓝色</div>]]></content>
      
      
      <categories>
          
          <category> 人生影视课 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>『进击的巨人』是信仰</title>
      <link href="essay/ebg1s8/"/>
      <url>essay/ebg1s8/</url>
      
        <content type="html"><![CDATA[<hr><p>21.05更</p><p><del>海的那边，是自由。</del></p><p>海的那边，是杀千刀的jsc<img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1623928492929-ffc048a0-5a85-4f9c-81d6-c71ceda450b5.jpeg#align=left&display=inline&height=75&id=uLVJZ&margin=%5Bobject%20Object%5D&originHeight=75&originWidth=75&status=done&style=none&width=75"></p><h2 id=""><a href="#" class="headerlink" title=""></a><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1623928497065-1e541eba-d224-4125-acee-eb249a83bb3b.jpeg#align=left&display=inline&height=50&id=oqhQI&margin=%5Bobject%20Object%5D&originHeight=50&originWidth=50&status=done&style=none&width=50"></h2><p>兵长永远是最强的……</p><div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">你刚才玩的挺开心啊~</div><p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1619319047360-440f4560-ea7d-4751-822c-0451f0fa40f0.jpeg#align=left&display=inline&height=814&id=u0d61af7a&margin=%5Bobject%20Object%5D&name=011.jpg&originHeight=814&originWidth=1100&size=466024&status=done&style=none&width=1100" alt="011.jpg"></p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1619482927278-c7d820d9-9797-45ff-89a6-3fc5b4a10304.png#align=left&display=inline&height=1080&id=GvVBt&margin=%5Bobject%20Object%5D&name=04.png&originHeight=1080&originWidth=1920&size=1897071&status=done&style=none&width=1920" alt="04.png"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1619482904818-7bc6ef93-00d8-4fc1-ac3b-75338fb25a41.png#align=left&display=inline&height=1080&id=LStyO&margin=%5Bobject%20Object%5D&name=Snipaste_2020-12-21_11-03-35.png&originHeight=1080&originWidth=1920&size=1220501&status=done&style=none&width=1920" alt="Snipaste_2020-12-21_11-03-35.png"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1619482905865-3e7b798f-1888-4ecc-86fd-8200bc78b73b.png#align=left&display=inline&height=1080&id=ExxI6&margin=%5Bobject%20Object%5D&name=Snipaste_2021-01-18_12-39-58.png&originHeight=1080&originWidth=1920&size=926577&status=done&style=none&width=1920" alt="Snipaste_2021-01-18_12-39-58.png"></p><p>![ZE5}I@{<del>]L4$KBF{[@DYK3Q(1).png](<a href="https://cdn.nlark.com/yuque/0/2021/png/1484158/1619482909799-aec5bedb-ce37-4f2c-959a-b15c3bd34e8f.png#align=left&amp;display=inline&amp;height=1080&amp;id=W3TmY&amp;margin=%5Bobject%20Object%5D&amp;name=ZE5%7DI%40%7B">https://cdn.nlark.com/yuque/0/2021/png/1484158/1619482909799-aec5bedb-ce37-4f2c-959a-b15c3bd34e8f.png#align=left&amp;display=inline&amp;height=1080&amp;id=W3TmY&amp;margin=%5Bobject%20Object%5D&amp;name=ZE5%7DI%40%7B</a></del>%5DL4%24KBF%7B%5B%40DYK3Q%281%29.png&amp;originHeight=1080&amp;originWidth=1920&amp;size=1435340&amp;status=done&amp;style=none&amp;width=1920)</p>]]></content>
      
      
      <categories>
          
          <category> 人生影视课 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>npm从发布第一个包学起</title>
      <link href="blog/auczes/"/>
      <url>blog/auczes/</url>
      
        <content type="html"><![CDATA[<h2 id="npm-init"><a href="#npm-init" class="headerlink" title="npm init"></a>npm init</h2><p>在<a href="https://www.npmjs.com/">https://www.npmjs.com/</a>注册的用户账号<br>新建一个文件夹<code>npm-wzutao</code>再次文件夹下进入 bash</p><p><strong>登录 npmjs</strong><br><code>npm login</code><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612782412366-aeecc92e-a5e0-4f3d-9172-c607a5c06199.png#align=left&display=inline&height=112&margin=%5Bobject%20Object%5D&name=image.png&originHeight=223&originWidth=882&size=27239&status=done&style=none&width=441" alt="image.png"><br>初始化<br><code>npm init</code><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612782805229-e691af8b-0440-4fdb-baa6-63f5089017bb.png#align=left&display=inline&height=441&margin=%5Bobject%20Object%5D&name=image.png&originHeight=881&originWidth=843&size=81289&status=done&style=none&width=421.5" alt="image.png"><br>然后在该文件夹下新建 index.js 文件，写入如下测试代码</p><pre><code class="javascript">exports.sum = function () &#123;  var res = 0;  for (var i = 0; i &lt; arguments.length; i++) &#123;    res += arguments[i];  &#125;  return res;&#125;;</code></pre><h2 id="npm-publish"><a href="#npm-publish" class="headerlink" title="npm publish"></a>npm publish</h2><p><code>npm publish</code><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612782959102-a6d78720-76a0-472a-b0d9-430c83ce7c8b.png#align=left&display=inline&height=196&margin=%5Bobject%20Object%5D&name=image.png&originHeight=392&originWidth=761&size=45114&status=done&style=none&width=380.5" alt="image.png"><br>去官网可以搜索到<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612783041850-acf55586-80aa-4cf5-b19a-7f538396fadd.png#align=left&display=inline&height=380&margin=%5Bobject%20Object%5D&name=image.png&originHeight=759&originWidth=1663&size=82826&status=done&style=stroke&width=831.5" alt="image.png"></p><h2 id="npm-publish-1"><a href="#npm-publish-1" class="headerlink" title="npm publish"></a>npm publish</h2><p>【1】本地更新版本号</p><p><code>npm version patch</code><br>1.0.1 版本，注意，是最后一位修改了增 1<br><code>npm version minor</code><br>1.1.0 版本，注意，是第二位修改了增 1<br><code>npm version major </code><br>2.0.0 版本，注意，是第一位修改了增 1</p><p>【2】修改远端的版本<br>提交到远端 npm 中<br><code>npm publish </code></p><h2 id="npm-install"><a href="#npm-install" class="headerlink" title="npm install"></a>npm install</h2><p>新建一个测试文件夹下载该包，会得到</p><pre><code>│  package-lock.json│└─node_modules    └─npm-wzutao            index.js            package.json</code></pre><h2 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a>package.json</h2><p>项目依赖和开发依赖</p><ul><li>项目依赖就是这个产品线上运营所依赖的模块，在文件的 dependencies 字段</li></ul><p>npm install 包名</p><ul><li>开发依赖就是项目的开发阶段需要依赖，线上运营阶段不需要依赖的第三方包，称为开发依赖，devDependencies 字段</li></ul><p>npm install 包名 –save-dev</p><ul><li>npm install –production，在本地下载依赖的包</li><li>里面的 script 使用：npm run XXX</li></ul><h2 id="package-lock-json"><a href="#package-lock-json" class="headerlink" title="package-lock.json"></a>package-lock.json</h2><ul><li>锁定包的版本，确保再次下载时不会因为包版本不同而产生问题</li><li>加快下载速度，因为该文件中已经记录了项目所依赖第三方包的树状结构和包的下载地址，重新安装时只需下载即可，不需要做额外的工作</li></ul>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
          <category> node </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>IDEA环境下的Web开发bug汇总</title>
      <link href="blog/aiuif3/"/>
      <url>blog/aiuif3/</url>
      
        <content type="html"><![CDATA[<h2 id="Unsupported-major-minor-version-52-0"><a href="#Unsupported-major-minor-version-52-0" class="headerlink" title="Unsupported major.minor version 52.0"></a>Unsupported major.minor version 52.0</h2><blockquote><p>版本过低</p></blockquote><pre><code class="java">[2021-02-07 08:25:52,537] Artifact javaweb-blog:war exploded: Error during artifact deployment. See server log for details.</code></pre><pre><code class="java"> java.lang.UnsupportedClassVersionError: com/nic/filter/AdminFilter : Unsupported major.minor version 52.0 (unable to load class com.nic.filter.AdminFilter)</code></pre><p>一直报错，网上找一直是说和 jdk 的版本有关，但是 jdk 的版本尝试更换几个都无效。事实上是 Tomcat 的版本问题，项目开始用的是 Tomcat8.1 升级至 8.5.34 即可（升级 Tomcat9 可以否？会对下兼容吗？trytry）</p><h2 id="org-apache-tomcat-util-descriptor-web-WebXml-setVersion-Unknown-version-string-4-0"><a href="#org-apache-tomcat-util-descriptor-web-WebXml-setVersion-Unknown-version-string-4-0" class="headerlink" title="org.apache.tomcat.util.descriptor.web.WebXml.setVersion Unknown version string [4.0]"></a>org.apache.tomcat.util.descriptor.web.WebXml.setVersion Unknown version string [4.0]</h2><blockquote><p>warning：4.0 太高</p></blockquote><pre><code class="java">org.apache.tomcat.util.descriptor.web.WebXml.setVersion Unknown version string [4.0]</code></pre><ul><li>解决：<a href="https://blog.csdn.net/qq_32483145/article/details/80292463">https://blog.csdn.net/qq_32483145/article/details/80292463</a></li></ul><h2 id="用到-servlet-的页面跳转-404"><a href="#用到-servlet-的页面跳转-404" class="headerlink" title="用到 servlet 的页面跳转 404"></a>用到 servlet 的页面跳转 404</h2><h3 id="web-xml-配置有误"><a href="#web-xml-配置有误" class="headerlink" title="web.xml 配置有误"></a>web.xml 配置有误</h3><p>页面能访问，也成功部署到 tomcat 下面的 weapps 文件夹下面，但是在进行页面跳转的过程中，会出现下面的 404 情况。分析之后是我这个项目是新建的一个空项目，然后代码是之前在 eclipse 下运行过的，而后直接将内容代码复制过来，却没复制 web.xml，导致现项目的 web.xml 是“空的”，无配置。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612753264339-b79c791c-6814-4c38-b42d-6b85bb9c1d5f.png#align=left&display=inline&height=144&margin=%5Bobject%20Object%5D&name=image.png&originHeight=288&originWidth=1920&size=37994&status=done&style=none&width=960" alt="image.png"></p><h3 id="Tomcat-路径配置有误"><a href="#Tomcat-路径配置有误" class="headerlink" title="Tomcat 路径配置有误"></a>Tomcat 路径配置有误</h3><p>还有一种情况，就是 tomcat 配置过程中的那两个路径也要注意下<br>调整为如下配置，不然会出现访问/jsp-peojectname/jsp-peojectname/index.jsp 页面为 404 的情况<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612756924057-55c60ad3-85b8-4cf0-aa9d-6184bfbd296e.png#align=left&display=inline&height=78&margin=%5Bobject%20Object%5D&name=image.png&originHeight=156&originWidth=1611&size=17507&status=done&style=none&width=805.5" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612756936656-72d837f5-46ef-4d35-8e39-e49d2c6f077d.png#align=left&display=inline&height=97&margin=%5Bobject%20Object%5D&name=image.png&originHeight=194&originWidth=1611&size=12795&status=done&style=none&width=805.5" alt="image.png"></p><h3 id="其他类型错误"><a href="#其他类型错误" class="headerlink" title="其他类型错误"></a>其他类型错误</h3><p>可能还有其他类型错误，参考以下的总结</p><ul><li><a href="https://blog.csdn.net/DBC_121/article/details/79204340">Web 开发：关于 Tomcat 出现 The origin server did not find a current representation for the target resourc…的问题</a></li></ul><h2 id="数据库报错"><a href="#数据库报错" class="headerlink" title="数据库报错"></a>数据库报错</h2><p>navicat 也不能查看该数据库</p><pre><code class="java">HTTP Status 500 – Internal Server ErrorType Exception ReportMessage get connection error!Description The server encountered an unexpected condition that prevented it from fulfilling the request.Exceptionjava.lang.RuntimeException: get connection error!    com.nic.util.JdbcUtil.getConnection(JdbcUtil.java:55)    com.nic.dao.ArticleDao.findArticle(ArticleDao.java:56)    com.nic.service.ArticleService.findArticle(ArticleService.java:20)    com.nic.servlet.PostlistServlet.doGet(PostlistServlet.java:50)    javax.servlet.http.HttpServlet.service(HttpServlet.java:635)    javax.servlet.http.HttpServlet.service(HttpServlet.java:742)    org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:52)Root Causejava.lang.ClassNotFoundException: com.mysql.jdbc.Driver    org.apache.catalina.loader.WebappClassLoaderBase.loadClass(WebappClassLoaderBase.java:1309)    org.apache.catalina.loader.WebappClassLoaderBase.loadClass(WebappClassLoaderBase.java:1137)    java.lang.Class.forName0(Native Method)    java.lang.Class.forName(Class.java:264)    com.nic.util.JdbcUtil.getConnection(JdbcUtil.java:52)    com.nic.dao.ArticleDao.findArticle(ArticleDao.java:56)    com.nic.service.ArticleService.findArticle(ArticleService.java:20)    com.nic.servlet.PostlistServlet.doGet(PostlistServlet.java:50)    javax.servlet.http.HttpServlet.service(HttpServlet.java:635)    javax.servlet.http.HttpServlet.service(HttpServlet.java:742)    org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:52)Note The full stack trace of the root cause is available in the server logs.Apache Tomcat/8.5.34</code></pre><p>初步分析是用的 phpstudy 里面的 mysql 数据库不能生效，删除电脑之前的 mysql，用 phpstudy 数据库恢复</p><hr><p>但是还会报错，判断应该是代码文件出错【不过不用将这个 jar 包导入到 lib 文件夹下（反而会报错），只需要将其导入到 tomcat 文件夹下的 lib 文件夹，即可】<br><a href="https://www.yuque.com/attachments/yuque/0/2021/jar/1484158/1612768356808-4c69cbaa-cbc7-4ebe-9232-423cad8ef54f.jar?_lake_card=%7B%22uid%22:%221612761483730-0%22,%22src%22:%22https://www.yuque.com/attachments/yuque/0/2021/jar/1484158/1612768356808-4c69cbaa-cbc7-4ebe-9232-423cad8ef54f.jar%22,%22name%22:%22mysql-connector-java-5.1.49.jar%22,%22size%22:1006904,%22type%22:%22%22,%22ext%22:%22jar%22,%22progress%22:%7B%22percent%22:99%7D,%22status%22:%22done%22,%22percent%22:0,%22id%22:%22xrOhc%22,%22refSrc%22:%22https://www.yuque.com/attachments/yuque/0/2021/jar/1484158/1612761486309-2d90c3e5-5a0c-4b57-95f5-5551ed944a23.jar%22,%22card%22:%22file%22%7D">mysql-connector-java-5.1.49.jar</a>（或者直接上网搜再下载）<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612756117413-4649efa1-9274-4ae5-aa1a-463750acd571.png#align=left&display=inline&height=332&margin=%5Bobject%20Object%5D&name=image.png&originHeight=663&originWidth=1291&size=105075&status=done&style=shadow&width=645.5" alt="image.png">~~</p>]]></content>
      
      
      <categories>
          
          <category> Bug </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>IDEA创建javaWeb项目</title>
      <link href="blog/qi1ddv/"/>
      <url>blog/qi1ddv/</url>
      
        <content type="html"><![CDATA[<h2 id="一、Tomcat-下载"><a href="#一、Tomcat-下载" class="headerlink" title="一、Tomcat 下载"></a>一、Tomcat 下载</h2><h3 id="1-下载并安装"><a href="#1-下载并安装" class="headerlink" title="1. 下载并安装"></a>1. 下载并安装</h3><blockquote><p>假如不是集成开发环境（比如 phpstudy），电脑要有 jdk 环境</p></blockquote><p>【1】官网下载：<a href="http://tomcat.apache.org/">http://tomcat.apache.org/</a></p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598787914511-a035ba93-0b7a-450b-b391-5d1452435ca7.png#align=left&display=inline&height=220&margin=%5Bobject%20Object%5D&originHeight=952&originWidth=1842&size=0&status=done&style=shadow&width=425"><br>【2】下载并解压到自己的相应盘区，再检验是否成功<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598787914448-2ef2e1a1-2966-4d35-8bfe-82162aa1588b.png#align=left&display=inline&height=273&margin=%5Bobject%20Object%5D&originHeight=727&originWidth=1147&size=0&status=done&style=shadow&width=431"><br>点击第二个框不出现闪退情况则证明成功<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598787914507-87063aec-884a-4180-b124-568478d81bc0.png#align=left&display=inline&height=222&margin=%5Bobject%20Object%5D&originHeight=639&originWidth=1223&size=0&status=done&style=shadow&width=425"><br>【3】浏览器进入端口<a href="http://localhost:8080/">http://localhost:8080/</a>上述配置成功则表明成功<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598787914624-248148e3-3f5f-45ca-ad93-c063216a7aff.png#align=left&display=inline&height=270&margin=%5Bobject%20Object%5D&originHeight=1030&originWidth=1838&size=0&status=done&style=shadow&width=482"></p><h3 id="2-过程中可能会出现的问题"><a href="#2-过程中可能会出现的问题" class="headerlink" title="2. 过程中可能会出现的问题"></a>2. 过程中可能会出现的问题</h3><p>【1】点击 startup.bat 文件出现闪退</p><blockquote><p>电脑中 java jdk 有无（JAVA_HOME）</p></blockquote><p>【2】端口被占用</p><blockquote><p>进入 Tomcat 文件夹下的 conf 文件下的 server.xml 文件，用记事本查找 8080，下面复制一个新的初始端口<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598787914513-8083bc6e-4c6f-436e-b0b0-98d3d70b9dea.png#align=left&display=inline&height=80&margin=%5Bobject%20Object%5D&originHeight=80&originWidth=557&size=0&status=done&style=shadow&width=557"></p></blockquote><h2 id="二、利用-IDEA-创建一个-JavaWeb-项目"><a href="#二、利用-IDEA-创建一个-JavaWeb-项目" class="headerlink" title="二、利用 IDEA 创建一个 JavaWeb 项目"></a>二、利用 IDEA 创建一个 JavaWeb 项目</h2><h3 id="1-创建新项目"><a href="#1-创建新项目" class="headerlink" title="1. 创建新项目"></a>1. 创建新项目</h3><p>依次点击：<code>File </code>-&gt; <code>New </code>-&gt; <code>Project</code><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612697874347-fef7ad38-7ff2-4567-89a9-f5d47a1f4824.png#align=left&display=inline&height=316&margin=%5Bobject%20Object%5D&name=image.png&originHeight=812&originWidth=1202&size=104672&status=done&style=none&width=468" alt="image.png"></p><h3 id="2-项目工程配置"><a href="#2-项目工程配置" class="headerlink" title="2. 项目工程配置"></a>2. 项目工程配置</h3><p>【1】在<code>WEB-INF</code>下创建两个空文件夹 <code>classes</code> <code>lib</code></p><blockquote><p>目的：</p><ul><li>classes 文件夹用于存放编译后的 class 文件</li><li>lib 文件夹用于存放依赖的 jar 包</li></ul></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612697966439-ab639870-61ab-429e-919a-4109c8cefdc5.png#align=left&display=inline&height=237&margin=%5Bobject%20Object%5D&name=image.png&originHeight=473&originWidth=469&size=29009&status=done&style=none&width=234.5" alt="image.png"><br>【2】依次点击<code>file</code> -&gt; <code>Project Structure</code></p><blockquote><p>目的：将后面编译的 class 文件默认生成到刚刚新建的 classes 目录下</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612698144393-24e78472-430b-47a4-b423-e091597bb4f3.png#align=left&display=inline&height=364&margin=%5Bobject%20Object%5D&name=image.png&originHeight=727&originWidth=1535&size=95789&status=done&style=none&width=767.5" alt="image.png"><br>【3】依次点击<code>file</code> -&gt; <code>Project Structure</code></p><blockquote><p>目的：添加 jar 包依赖<br>（项目所需要的 jar 包都放到刚刚新建的 lib 文件夹）<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612698241583-99ff6441-6e2a-4776-addb-9f8f1eda6636.png#align=left&display=inline&height=268&margin=%5Bobject%20Object%5D&name=image.png&originHeight=535&originWidth=1274&size=68026&status=done&style=none&width=637" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612698274993-98e1b314-c726-41e6-973e-1dbb07ef7312.png#align=left&display=inline&height=169&margin=%5Bobject%20Object%5D&name=image.png&originHeight=337&originWidth=546&size=22322&status=done&style=none&width=273" alt="image.png"><br>【4】配置打包方式 Artifacts<br><del>点击 Artifacts 选项卡，IDEA 会为该项目自动创建一个名为“JavaWeb:war exploded”的打包方式，表示 打包成 war 包，并且是文件展开性的，输出路径为当前项目下的 out 文件夹，保持默认即可。另外勾选下“Build on make”，表示编译的时候就打包部署，勾选“Show content of elements”，表示显示详细的内容列表。</del></p></blockquote><p><em>如果按照上面说的，那么会发现发布的项目并没有在 tomcat 目录下的 webapps 目录下，如果项目以前在其他电脑抑或是其他环境下运行过，可能会导致项目的很多子页面默认 URL404。</em><br><del><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612711385355-7645f327-ad5c-40aa-a165-b975f957ebe3.png#align=left&display=inline&height=239&margin=%5Bobject%20Object%5D&name=image.png&originHeight=479&originWidth=884&size=112691&status=done&style=shadow&width=442" alt="image.png"></del><br>正确解决办法：项目一开始依次点击<code>file</code> -&gt; <code>Project Structure</code></p><blockquote><p>1 区域：将 output 路径指定到<code>tomcat</code>的<code>webapps</code>下面（新建一个本项目的同名文件夹）<br>2 区域：Output Layout 就是配置这个路径里面生成的所有文件<br>3 区域：将右边的文件内容脱拉到左边的 3 区域即可</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612763067214-29b72122-e8c6-4df1-a112-50ffb6c43084.png#align=left&display=inline&height=327&margin=%5Bobject%20Object%5D&name=image.png&originHeight=653&originWidth=1535&size=81034&status=done&style=none&width=767.5" alt="image.png"></p><h3 id="3-Tomcat-配置"><a href="#3-Tomcat-配置" class="headerlink" title="3. Tomcat 配置"></a>3. Tomcat 配置</h3><p>【1】点击如下位置进入 tomcat 容器编辑板块<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612698536983-4544013a-5e2a-43d7-ae31-7aa5c871fb3a.png#align=left&display=inline&height=151&margin=%5Bobject%20Object%5D&name=image.png&originHeight=301&originWidth=1920&size=55468&status=done&style=none&width=960" alt="image.png"><br>【2】默认会自动给我们生成一个 Tomcat 容器，基本上只需要配置<code>Deployment</code>即可，如果没有默认生成就新建一个。其中<code>Application server</code>填写本地 tomcat 的安装目录文件夹即可（因为一台电脑开发可能会有多个 tomcat 版本）<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612711521404-673143aa-f3fd-4b37-aed1-919d0ea1de1f.png#align=left&display=inline&height=370&margin=%5Bobject%20Object%5D&name=image.png&originHeight=740&originWidth=1163&size=152940&status=done&style=none&width=581.5" alt="image.png"></p><blockquote><p>❗ ❗ ❗ 如果要换不同版本的 tomcat 来运行项目，改如下地方：</p><ol><li>先将上面图片<code>Application server</code>tomcat 版本更换至新的 tomcat 版本</li><li>去<code>2. 项目工程配置</code>步骤中，减去原先的 tomcat，加上新的 tomcat</li></ol></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612698612335-158bfcb3-3016-478c-b86a-770ad57ad2a9.png#align=left&display=inline&height=511&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1022&originWidth=1611&size=111169&status=done&style=none&width=805.5" alt="image.png"></p><blockquote><p>此处的 Application context 是指定本工程的根目录</p></blockquote><h3 id="4-结果测试"><a href="#4-结果测试" class="headerlink" title="4. 结果测试"></a>4. 结果测试</h3><p>在<code>index.jsp</code>文件下添加显示代码<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612698732177-5bedf912-6a16-47d4-ab96-d5527b9567d1.png#align=left&display=inline&height=271&margin=%5Bobject%20Object%5D&name=image.png&originHeight=542&originWidth=1879&size=244164&status=done&style=none&width=939.5" alt="image.png"><br>直接运行<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612698844575-2952fffc-3616-43f1-be90-138dbe0df86d.png#align=left&display=inline&height=128&margin=%5Bobject%20Object%5D&name=image.png&originHeight=256&originWidth=1107&size=40673&status=done&style=shadow&width=553.5" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612698866551-55b0f5c6-fc7e-423a-8c59-2af2cbe08953.png#align=left&display=inline&height=152&margin=%5Bobject%20Object%5D&name=image.png&originHeight=303&originWidth=827&size=28375&status=done&style=shadow&width=413.5" alt="image.png"></p><blockquote><p>如果在 Tomcat 配置过程中的部署路径为 <code>/</code> ，会出现下面第二张图的结果，都能访问，但是最好还是上面的方式，符合服务器“一个文件夹一个站点”的思想，路径访问的相关问题不会挖坑。</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612698976241-4d798089-9581-4cdf-893b-dbbc11b18057.png#align=left&display=inline&height=511&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1022&originWidth=1611&size=101904&status=done&style=none&width=805.5" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612698989649-0fdabed2-a690-450a-b11f-3900a477a68a.png#align=left&display=inline&height=170&margin=%5Bobject%20Object%5D&name=image.png&originHeight=340&originWidth=862&size=27789&status=done&style=shadow&width=431" alt="image.png"></p><h3 id="❗-JavaWeb-项目结构分析"><a href="#❗-JavaWeb-项目结构分析" class="headerlink" title="❗ JavaWeb 项目结构分析"></a>❗ JavaWeb 项目结构分析</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612752142869-4f7db98f-6d15-4ce5-be4b-1e0e13dcab08.png#align=left&display=inline&height=444&margin=%5Bobject%20Object%5D&name=image.png&originHeight=888&originWidth=321&size=43193&status=done&style=none&width=160.5" alt="image.png"></p><ul><li>src 文件夹：编写的 java 代码，编译后会放到 WEB-INF 文件夹下的 classes 文件夹</li><li>web 文件夹：web 应用程序的根目录，web 应用程序所有的文件都在该目录下</li><li>WEB-INF：客户不能直接通过浏览器进行访问<ul><li>classes：存放 servlet 和其他有用的 class 文件（编译后的）</li><li>lib：存放 web 应用程序所需要的 jar 包</li><li>web.xml：存放部署和配置信息的文件（当前 WEB 项目的核心配置，Servlet2.5 必须有，3.0 以后可省略）</li></ul></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://blog.csdn.net/m0_37499059/article/details/78806617">Intellij idea 创建 javaWeb 项目</a></li><li><a href="https://blog.csdn.net/c_little_white/article/details/89435646?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.control">IDEA 启动 tomcat 不报错，tomcat 的 webapps 文件夹没有项目文件，项目的默认 URL404</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Environment </category>
          
          <category> 环境配置 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>BOM各种长宽的总结</title>
      <link href="blog/5_day05_webapis/"/>
      <url>blog/5_day05_webapis/</url>
      
        <content type="html"><![CDATA[<h2 id="其他关于长宽"><a href="#其他关于长宽" class="headerlink" title="其他关于长宽"></a><strong>其他关于长宽</strong></h2><h3 id="window-innerWidth-和-innerHeight"><a href="#window-innerWidth-和-innerHeight" class="headerlink" title="window.innerWidth 和 innerHeight"></a>window.innerWidth 和 innerHeight</h3><ul><li>表示文档显示区域的宽高，不包括工具栏和地址栏等区域；</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1617937380778-c1f24a67-c63e-49d1-9907-f7fe91880e9f.png#align=left&display=inline&height=238&margin=%5Bobject%20Object%5D&name=image.png&originHeight=476&originWidth=1236&size=64616&status=done&style=stroke&width=618" alt="image.png"></p><h3 id="window-pageYOffset-和-pageXOffset"><a href="#window-pageYOffset-和-pageXOffset" class="headerlink" title="window.pageYOffset 和 pageXOffset"></a>window.pageYOffset 和 pageXOffset</h3><p>ie9 往后才支持的“被卷去”的长度<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1617938014655-932453ea-63bc-4bc1-8388-63b41417892d.png#align=left&display=inline&height=210&margin=%5Bobject%20Object%5D&name=image.png&originHeight=420&originWidth=1234&size=62349&status=done&style=none&width=617" alt="image.png"></p><h3 id="鼠标事件对象-event"><a href="#鼠标事件对象-event" class="headerlink" title="鼠标事件对象 event"></a>鼠标事件对象 event</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518361978-034f2af6-14fa-4ddb-bd8b-2eabe289eb59.png#align=left&display=inline&height=308&margin=%5Bobject%20Object%5D&originHeight=308&originWidth=703&status=done&style=stroke&width=703"></p><h2 id="元素偏移量-offset"><a href="#元素偏移量-offset" class="headerlink" title="元素偏移量 offset"></a>元素偏移量 offset</h2><h3 id="offset-概述"><a href="#offset-概述" class="headerlink" title="offset 概述"></a>offset 概述</h3><blockquote><p>offset 翻译过来就是偏移量， 我们使用 offset 系列相关属性可以动态的得到该元素的位置（偏移）、大小等。</p></blockquote><ul><li><p>获得元素距离带有定位父元素的位置</p></li><li><p>获得元素自身的大小（宽度高度）</p></li><li><p>注意：返回的数值都不带单位</p></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616067042341-17b54a01-de40-4ad5-8a54-ad61317d27ae.png#align=left&display=inline&height=157&margin=%5Bobject%20Object%5D&name=image.png&originHeight=313&originWidth=1044&size=201699&status=done&style=stroke&width=522" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616068060630-5d0eeb72-5a55-48c4-8e60-1e0f2cd4afed.png#align=left&display=inline&height=440&margin=%5Bobject%20Object%5D&name=image.png&originHeight=880&originWidth=1920&size=2504958&status=done&style=stroke&width=960" alt="image.png"></p><h3 id="offset-与-style-区别"><a href="#offset-与-style-区别" class="headerlink" title="offset 与 style 区别"></a>offset 与 style 区别</h3><p>【1】offset</p><ul><li><p>offset 可以得到任意样式表中的样式值</p></li><li><p>offset 系列获得的数值是没有单位的</p></li><li><p><strong>offsetWidth 包含 padding+border+width</strong></p></li><li><p>offsetWidth 等属性是只读属性，只能获取不能赋值</p></li></ul><blockquote><p>所以，我们想要获取元素大小位置，用 offset 更合适</p></blockquote><p>【2】style</p><ul><li><p>style 只能得到<strong>行内样式表中的样式值</strong></p></li><li><p>style.width 获得的是带有单位的字符串</p></li><li><p>style.width 获得不包含 padding 和 border 的值</p></li><li><p>style.width 是可读写属性，可以获取也可以赋值</p></li></ul><blockquote><p>所以，我们想要给元素更改值，则需要用 style 改变<br><strong>因为平时我们都是给元素注册触摸事件，所以重点记住 targetTocuhes</strong></p></blockquote><h3 id="Demo：获取鼠标在盒子内的坐标"><a href="#Demo：获取鼠标在盒子内的坐标" class="headerlink" title="Demo：获取鼠标在盒子内的坐标"></a>Demo：获取鼠标在盒子内的坐标</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616069445575-c9a9b51d-665d-4f26-96bb-768a9415a230.png#align=left&display=inline&height=429&margin=%5Bobject%20Object%5D&name=image.png&originHeight=857&originWidth=1920&size=2461932&status=done&style=stroke&width=960" alt="image.png"></p><pre><code class="javascript">box.addEventListener(&quot;mousemove&quot;, function (e) &#123;  if (e.pageX &gt; box_left + box.width) &#123;    var ture_width = e.pageX - box_left + box_width;  &#125; else &#123;    var ture_width = e.pageX - box_left;  &#125;  if (e.pageY &gt; box_top + box_height) &#123;    var ture_height = e.pageY - box_top + box_height;  &#125; else &#123;    var ture_height = e.pageY - box_top;  &#125;  this.innerHTML = &quot;x坐标是&quot; + ture_width + &quot; y坐标是&quot; + ture_height;&#125;);</code></pre><h3 id="Demo：模态框拖拽"><a href="#Demo：模态框拖拽" class="headerlink" title="Demo：模态框拖拽"></a>Demo：模态框拖拽</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616210051320-8b04d6a8-efc0-4a78-a985-80fdc0a0c238.png#align=left&display=inline&height=440&margin=%5Bobject%20Object%5D&name=image.png&originHeight=879&originWidth=1920&size=63982&status=done&style=stroke&width=960" alt="image.png"></p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;  &lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot; /&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;    &lt;title&gt;Document&lt;/title&gt;    &lt;style&gt;      * &#123;        padding: 0px;        margin: 0px;      &#125;      a &#123;        text-decoration: none;        color: #000000;      &#125;      .login-header &#123;        width: 100%;        text-align: center;        height: 30px;        line-height: 30px;        font-size: 24px;      &#125;      .login-bg &#123;        display: none;        width: 100%;        height: 100%;        position: fixed;        top: 0px;        left: 0px;        background: rgba(0, 0, 0, 0.3);      &#125;      .login &#123;        display: none;        width: 512px;        height: 280px;        position: fixed;        left: 50%;        top: 50%;        z-index: 9999;        border: #ebebeb solid 1px;        background-color: #ffffff;        box-shadow: 0px 0px 20px #ddd;        transform: translate(-50%, -50%);      &#125;      .login-title &#123;        width: 100%;        margin: 10px 0 0 0;        text-align: center;        line-height: 40px;        height: 40px;        font-size: 18px;        position: relative;        cursor: move;      &#125;      .login-title span &#123;        position: absolute;        width: 40px;        height: 40px;        font-size: 12px;        background: #ffffff;        border: #ebebeb solid 1px;        right: -20px;        top: -30px;        border-radius: 50%;      &#125;      .login-input-content &#123;        margin: 20px 0 0 0;      &#125;      .login-input &#123;        overflow: hidden;        margin: 0px 0px 20px 0px;      &#125;      .login-input label &#123;        float: left;        width: 90px;        padding-right: 10px;        text-align: right;        line-height: 35px;        height: 35px;        font-size: 14px;      &#125;      .login-input input.list-input &#123;        float: left;        line-height: 35px;        height: 35px;        width: 350px;        border: #ebebeb 1px solid;        text-indent: 5px;      &#125;      .login-input input.button-login &#123;        display: block;        border: 1px #ebebeb solid;        height: 35px;        width: 50%;        margin: 20px auto;      &#125;    &lt;/style&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;div class=&quot;login-header&quot;&gt;      &lt;a id=&quot;link&quot; href=&quot;javascript:;&quot;&gt;点击，弹出登录框&lt;/a&gt;    &lt;/div&gt;    &lt;div id=&quot;loginBg&quot; class=&quot;login-bg&quot;&gt;&lt;/div&gt;    &lt;div id=&quot;login&quot; class=&quot;login&quot;&gt;      &lt;div class=&quot;login-title&quot;&gt;        登录会员        &lt;span          &gt;&lt;a id=&quot;closeBtn&quot; href=&quot;javascript:; &quot; class=&quot;close-login&quot;            &gt;关闭&lt;/a          &gt;&lt;/span        &gt;      &lt;/div&gt;      &lt;div class=&quot;login-input-content&quot;&gt;        &lt;div class=&quot;login-input&quot;&gt;          &lt;label&gt;用户名：&lt;/label&gt;          &lt;input            type=&quot;text&quot;            placeholder=&quot;请输入用户名&quot;            name=&quot;info[username]&quot;            id=&quot;username&quot;            class=&quot;list-input&quot;          /&gt;        &lt;/div&gt;        &lt;div class=&quot;login-input&quot;&gt;          &lt;label&gt;登录密码：&lt;/label&gt;          &lt;input            type=&quot;password&quot;            placeholder=&quot;请输入登录密码&quot;            name=&quot;info[password]&quot;            id=&quot;password&quot;            class=&quot;list-input&quot;          /&gt;        &lt;/div&gt;        &lt;div class=&quot;login-input&quot;&gt;          &lt;input type=&quot;button&quot; class=&quot;button-login&quot; value=&quot;登录会员&quot; /&gt;        &lt;/div&gt;      &lt;/div&gt;    &lt;/div&gt;    &lt;script&gt;      var link = document.getElementById(&quot;link&quot;);      var loginBg = document.getElementById(&quot;loginBg&quot;);      var login = document.getElementById(&quot;login&quot;);      var closeBtn = document.getElementById(&quot;closeBtn&quot;);      link.addEventListener(&quot;click&quot;, function () &#123;        loginBg.style.display = &quot;block&quot;;        login.style.display = &quot;block&quot;;      &#125;);      closeBtn.addEventListener(&quot;click&quot;, function () &#123;        loginBg.style.display = &quot;none&quot;;        login.style.display = &quot;none&quot;;      &#125;);      login.addEventListener(&quot;mousedown&quot;, function (e) &#123;        var x = e.pageX - login.offsetLeft;        var y = e.pageY - login.offsetTop;        document.addEventListener(&quot;mousemove&quot;, move);        function move(e) &#123;          login.style.left = e.pageX - x + &quot;px&quot;;          login.style.top = e.pageY - y + &quot;px&quot;;        &#125;        document.addEventListener(&quot;mouseup&quot;, function () &#123;          document.removeEventListener(&quot;mousemove&quot;, move);        &#125;);      &#125;);    &lt;/script&gt;  &lt;/body&gt;&lt;/html&gt;</code></pre><h2 id="元素可视区-client-系列"><a href="#元素可视区-client-系列" class="headerlink" title="元素可视区 client 系列"></a>元素可视区 client 系列</h2><h3 id="client-概述"><a href="#client-概述" class="headerlink" title="client 概述"></a>client 概述</h3><p>client 翻译过来就是客户端，我们使用 client 系列的相关属性来获取元素可视区的相关信息。通过 client<br>系列的相关属性可以动态的得到该元素的边框大小、元素大小等。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616070278053-25f4dbb3-2991-4ce4-b1ec-cb3a94f80c0c.png#align=left&display=inline&height=129&margin=%5Bobject%20Object%5D&name=image.png&originHeight=257&originWidth=1030&size=138269&status=done&style=stroke&width=515" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616070286487-4d2a07f6-46b7-4af4-be5c-134ac01d6b48.png#align=left&display=inline&height=150&margin=%5Bobject%20Object%5D&name=image.png&originHeight=299&originWidth=572&size=37702&status=done&style=stroke&width=286" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616070508648-c56b354b-77e7-4afb-9072-0385ac38782f.png#align=left&display=inline&height=441&margin=%5Bobject%20Object%5D&name=image.png&originHeight=881&originWidth=1920&size=1850210&status=done&style=stroke&width=960" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616070554658-21dea2fb-5942-4f60-9205-71bc2a022a79.png#align=left&display=inline&height=440&margin=%5Bobject%20Object%5D&name=image.png&originHeight=879&originWidth=1920&size=1704838&status=done&style=stroke&width=960" alt="image.png"></p><h3 id="淘宝-flexible-js-源码分析"><a href="#淘宝-flexible-js-源码分析" class="headerlink" title="淘宝 flexible.js 源码分析"></a>淘宝 flexible.js 源码分析</h3><ul><li>立即执行函数  (function(){})()  或者 (function(){}())</li><li>主要作用： 创建一个独立的作用域。 避免了命名冲突问题</li><li>下面三种情况都会刷新页面都会触发 load 事件。<ul><li>a 标签的超链接</li><li>F5 或者刷新按钮（强制刷新）</li><li>前进后退按钮<blockquote><p>但是 火狐中，有个特点，有个“往返缓存”，这个缓存中不仅保存着页面数据，还保存了 DOM 和 JavaScript 的状态；实际上是将整个页面都保存在了内存里。</p></blockquote></li></ul></li></ul><p>所以此时后退按钮不能刷新页面。</p><p>此时可以使用 pageshow 事件来触发。，这个事件在页面显示时触发，无论页面是否来自缓存。在重新加载页面中，pageshow 会在 load 事件触发后触发；根据事件对象中的 persisted 来判断是否是缓存中的页面触发的 pageshow 事件</p><p><code>注意这个事件给window添加。</code></p><pre><code class="javascript">(function flexible(window, document) &#123;  // 获取的html 的根元素  var docEl = document.documentElement;  // dpr 物理像素比  var dpr = window.devicePixelRatio || 1;  // adjust body font size  设置我们body 的字体大小  function setBodyFontSize() &#123;    // 如果页面中有body 这个元素 就设置body的字体大小    if (document.body) &#123;      document.body.style.fontSize = 12 * dpr + &quot;px&quot;;    &#125; else &#123;      // 如果页面中没有body 这个元素，则等着 我们页面主要的DOM元素加载完毕再去设置body      // 的字体大小      document.addEventListener(&quot;DOMContentLoaded&quot;, setBodyFontSize);    &#125;  &#125;  setBodyFontSize();  // set 1rem = viewWidth / 10    设置我们html 元素的文字大小  function setRemUnit() &#123;    var rem = docEl.clientWidth / 10;    docEl.style.fontSize = rem + &quot;px&quot;;  &#125;  setRemUnit();  // reset rem unit on page resize  当我们页面尺寸大小发生变化的时候，要重新设置下rem 的大小  window.addEventListener(&quot;resize&quot;, setRemUnit);  // pageshow 是我们重新加载页面触发的事件  window.addEventListener(&quot;pageshow&quot;, function (e) &#123;    // e.persisted 返回的是true 就是说如果这个页面是从缓存取过来的页面，也需要从新计算一下rem 的大小    if (e.persisted) &#123;      setRemUnit();    &#125;  &#125;);  // detect 0.5px supports  有些移动端的浏览器不支持0.5像素的写法  if (dpr &gt;= 2) &#123;    var fakeBody = document.createElement(&quot;body&quot;);    var testElement = document.createElement(&quot;div&quot;);    testElement.style.border = &quot;.5px solid transparent&quot;;    fakeBody.appendChild(testElement);    docEl.appendChild(fakeBody);    if (testElement.offsetHeight === 1) &#123;      docEl.classList.add(&quot;hairlines&quot;);    &#125;    docEl.removeChild(fakeBody);  &#125;&#125;)(window, document);</code></pre><h2 id="元素滚动-scroll-系列"><a href="#元素滚动-scroll-系列" class="headerlink" title="元素滚动 scroll 系列"></a>元素滚动 scroll 系列</h2><h3 id="scroll-概述"><a href="#scroll-概述" class="headerlink" title="scroll 概述"></a>scroll 概述</h3><p>scroll 翻译过来就是滚动的，我们使用 scroll 系列的相关属性可以动态的得到该元素的大小、滚动距离等。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616070606903-ad20b10d-b146-4d60-bcc8-b202127dbac2.png#align=left&display=inline&height=131&margin=%5Bobject%20Object%5D&name=image.png&originHeight=261&originWidth=1056&size=145855&status=done&style=stroke&width=528" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616070615035-e5456585-8b3a-4c5a-8e1d-e4affd0e7fd2.png#align=left&display=inline&height=223&margin=%5Bobject%20Object%5D&name=image.png&originHeight=445&originWidth=421&size=102675&status=done&style=stroke&width=210.5" alt="image.png"></p><h3 id="页面被卷去的头部"><a href="#页面被卷去的头部" class="headerlink" title="页面被卷去的头部"></a>页面被卷去的头部</h3><p>如果浏览器的高（或宽）度不足以显示整个页面时，会自动出现滚动条。当滚动条向下滚动时，页面上面被隐藏掉的高度，我们就称为页面被卷去的头部。滚动条在滚动时会触发 onscroll 事件。</p><h3 id="页面被卷去的头部兼容性解决方案"><a href="#页面被卷去的头部兼容性解决方案" class="headerlink" title="页面被卷去的头部兼容性解决方案"></a>页面被卷去的头部兼容性解决方案</h3><p>需要注意的是，页面被卷去的头部，有兼容性问题，因此被卷去的头部通常有如下几种写法：</p><ol><li>声明了 DTD，使用 document.documentElement.scrollTop</li><li>未声明 DTD，使用   document.body.scrollTop</li><li>新方法 window.pageYOffset 和 window.pageXOffset，IE9 开始支持</li><li>微信里面浏览也会有相关兼容性的问题，所以需要兼容行解决</li></ol><pre><code class="javascript">function getScroll() &#123;    return &#123;      left: window.pageXOffset || document.documentElement.scrollLeft || document.body.scrollLeft||0,      top: window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0    &#125;; &#125;使用的时候  getScroll().left</code></pre><h2 id="三大系列总结"><a href="#三大系列总结" class="headerlink" title="三大系列总结"></a>三大系列总结</h2><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616070740695-1045516b-2b85-4697-874b-32fe2b1cbe5b.png#align=left&display=inline&height=113&margin=%5Bobject%20Object%5D&name=image.png&originHeight=226&originWidth=1105&size=140561&status=done&style=stroke&width=552.5" alt="image.png"><br>他们主要用法：</p><ol><li>offset 系列 经常用于获得元素位置     offsetLeft  offsetTop</li><li>client 经常用于获取元素大小   clientWidth clientHeight</li><li>scroll 经常用于获取滚动距离  scrollTop  scrollLeft</li><li>注意页面滚动的距离通过 window.pageXOffset   获得</li></ol><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="-1"><a href="#-1" class="headerlink" title=""></a></h2>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
          <category> BOM </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>移动端事件及特效</title>
      <link href="blog/7_day07_webapis/"/>
      <url>blog/7_day07_webapis/</url>
      
        <content type="html"><![CDATA[<h2 id="触屏事件"><a href="#触屏事件" class="headerlink" title="触屏事件"></a>触屏事件</h2><h3 id="1-1-1-触屏事件概述"><a href="#1-1-1-触屏事件概述" class="headerlink" title="1.1.1 触屏事件概述"></a>1.1.1 触屏事件概述</h3><p>移动端浏览器兼容性较好，我们不需要考虑以前 JS 的兼容性问题，可以放心的使用原生 JS 书写效果，但是移动端也有自己独特的地方。比如触屏事件 touch（也称触摸事件），Android 和 IOS 都有。touch 对象代表一个触摸点。触摸点可能是一根手指，也可能是一根触摸笔。触屏事件可响应用户手指（或触控笔）对屏幕或者触控板操作。<br>常见的触屏事件如下：<br><img src="images%5C%E5%9B%BE%E7%89%871.png#"></p><h3 id="1-1-2-触摸事件对象（TouchEvent）"><a href="#1-1-2-触摸事件对象（TouchEvent）" class="headerlink" title="1.1.2 触摸事件对象（TouchEvent）"></a>1.1.2 触摸事件对象（TouchEvent）</h3><p>TouchEvent  是一类描述手指在触摸平面（触摸屏、触摸板等）的状态变化的事件。这类事件用于描述一个或多个触点，使开发者可以检测触点的移动，触点的增加和减少，等等<br>touchstart、touchmove、touchend 三个事件都会各自有事件对象。<br>触摸事件对象重点我们看三个常见对象列表：<br><img src="images%5C%E5%9B%BE%E7%89%872.png#"></p><blockquote><p><strong>因为平时我们都是给元素注册触摸事件，所以重点记住 targetTocuhes</strong></p></blockquote><h3 id="1-1-3-移动端拖动元素"><a href="#1-1-3-移动端拖动元素" class="headerlink" title="1.1.3 移动端拖动元素"></a>1.1.3 移动端拖动元素</h3><ol><li>touchstart、touchmove、touchend 可以实现拖动元素</li><li>但是拖动元素需要当前手指的坐标值 我们可以使用   targetTouches[0] 里面的 pageX 和 pageY</li><li>移动端拖动的原理：    手指移动中，计算出手指移动的距离。然后用盒子原来的位置 + 手指移动的距离</li><li>手指移动的距离：   手指滑动中的位置 减去   手指刚开始触摸的位置</li></ol><p>拖动元素三步曲：<br>（1） 触摸元素 touchstart：  获取手指初始坐标，同时获得盒子原来的位置<br>（2） 移动手指 touchmove：  计算手指的滑动距离，并且移动盒子<br>（3） 离开手指 touchend:</p><blockquote><p><strong>注意： 手指移动也会触发滚动屏幕所以这里要阻止默认的屏幕滚动 e.preventDefault();</strong></p></blockquote><h2 id="1-2-移动端常见特效"><a href="#1-2-移动端常见特效" class="headerlink" title="1.2. 移动端常见特效"></a>1.2. 移动端常见特效</h2><h3 id="1-2-1-案例-移动轮播图"><a href="#1-2-1-案例-移动轮播图" class="headerlink" title="1.2.1 案例: 移动轮播图"></a>1.2.1 案例: 移动轮播图</h3><p><code>移动端轮播图功能和基本PC端一致。</code></p><ol><li>可以自动播放图片</li><li>手指可以拖动播放轮播图</li></ol><h3 id="1-2-2-案例分析"><a href="#1-2-2-案例分析" class="headerlink" title="1.2.2. 案例分析:"></a>1.2.2. 案例分析:</h3><ol><li><p>自动播放功能</p></li><li><p>开启定时器</p></li><li><p>移动端移动，可以使用 translate 移动</p></li><li><p>想要图片优雅的移动，请添加过渡效果<img src="images%5C1551795152(1).jpg#"></p></li><li><p>自动播放功能-无缝滚动</p></li><li><p>注意，我们判断条件是要等到图片滚动完毕再去判断，就是过渡完成后判断</p></li><li><p>此时需要添加检测过渡完成事件   transitionend</p></li><li><p>判断条件：如果索引号等于 3 说明走到最后一张图片，此时 索引号要复原为 0</p></li><li><p>此时图片，去掉过渡效果，然后移动</p></li><li><p>如果索引号小于 0， 说明是倒着走， 索引号等于 2</p></li><li><p>此时图片，去掉过渡效果，然后移动<br><img src="images%5C1551795483(1).jpg#"></p></li></ol><h2 id="1-2-3-classList-属性"><a href="#1-2-3-classList-属性" class="headerlink" title="1.2.3 classList 属性"></a>1.2.3 classList 属性</h2><p>classList 属性是 HTML5 新增的一个属性，返回元素的类名。但是 ie10 以上版本支持。<br>该属性用于在元素中添加，移除及切换 CSS 类。有以下方法<br><strong>添加类：</strong><br>element.classList.add（’类名’）；</p><pre><code class="javascript">focus.classList.add(&quot;current&quot;);</code></pre><p><strong>移除类：</strong><br>element.classList.remove（’类名’）;</p><pre><code class="javascript">focus.classList.remove(&quot;current&quot;);</code></pre><p><strong>切换类：</strong><br>element.classList.toggle（’类名’）;</p><pre><code class="javascript">focus.classList.toggle(&quot;current&quot;);</code></pre><p><code>注意:以上方法里面，所有类名都不带点</code></p><h3 id="1-2-4-案例分析"><a href="#1-2-4-案例分析" class="headerlink" title="1.2.4. 案例分析"></a>1.2.4. 案例分析</h3><ol><li><p>小圆点跟随变化效果</p></li><li><p>把 ol 里面 li 带有 current 类名的选出来去掉类名 remove</p></li><li><p>让当前索引号的小 li 加上 current   add</p></li><li><p>但是，是等着过渡结束之后变化，所以这个写到 transitionend 事件里面<br><img src="images%5C1551796072(1).jpg#"></p></li><li><p>手指滑动轮播图</p></li><li><p>本质就是 ul 跟随手指移动，简单说就是移动端拖动元素</p></li><li><p>触摸元素 touchstart：  获取手指初始坐标</p></li><li><p>移动手指 touchmove：  计算手指的滑动距离，并且移动盒子</p></li><li><p>离开手指 touchend:   根据滑动的距离分不同的情况</p></li><li><p>如果移动距离小于某个像素   就回弹原来位置</p></li><li><p>如果移动距离大于某个像素就上一张下一张滑动。</p></li><li><p>滑动也分为左滑动和右滑动判断的标准是 移动距离正负 如果是负值就是左滑 反之右滑</p></li><li><p>如果是左滑就播放下一张 （index++）</p></li><li><p>如果是右滑就播放上一张   (index–)</p></li></ol><p><img src="images%5C1551796363(1).jpg#"><br><img src="images%5C1551796502(1).jpg#"></p><h3 id="1-3-1-案例：返回顶部"><a href="#1-3-1-案例：返回顶部" class="headerlink" title="1.3.1. 案例：返回顶部"></a>1.3.1. 案例：返回顶部</h3><p>当页面滚动某个地方，就显示，否则隐藏<br>点击可以返回顶部</p><h3 id="1-3-2-案例分析"><a href="#1-3-2-案例分析" class="headerlink" title="1.3.2.案例分析"></a>1.3.2.案例分析</h3><ol><li>滚动某个地方显示</li><li>事件：scroll 页面滚动事件</li><li>如果被卷去的头部（window.pageYOffset ）大于某个数值</li><li>点击，window.scroll(0,0)  返回顶部</li></ol><p><img src="images%5C1551797003(1).jpg#"></p><h2 id="1-4-click-延时解决方案"><a href="#1-4-click-延时解决方案" class="headerlink" title="1.4. click 延时解决方案"></a>1.4. click 延时解决方案</h2><p>移动端 click 事件会有 300ms 的延时，原因是移动端屏幕双击会缩放(double tap to zoom) 页面。<br>解决方案： 1. 禁用缩放。 浏览器禁用默认的双击缩放行为并且去掉 300ms 的点击延迟。</p><pre><code class="html">&lt;meta name=&quot;viewport&quot; content=&quot;user-scalable=no&quot; /&gt;</code></pre><pre><code>2.利用touch事件自己封装这个事件解决300ms 延迟。原理就是：</code></pre><ol><li>当我们手指触摸屏幕，记录当前触摸时间</li><li>当我们手指离开屏幕， 用离开的时间减去触摸的时间</li><li>如果时间小于 150ms，并且没有滑动过屏幕， 那么我们就定义为点击</li></ol><p>代码如下:</p><pre><code class="javascript">//封装tap，解决click 300ms 延时function tap (obj, callback) &#123;        var isMove = false;        var startTime = 0; // 记录触摸时候的时间变量        obj.addEventListener(&#39;touchstart&#39;, function (e) &#123;            startTime = Date.now(); // 记录触摸时间        &#125;);        obj.addEventListener(&#39;touchmove&#39;, function (e) &#123;            isMove = true;  // 看看是否有滑动，有滑动算拖拽，不算点击        &#125;);        obj.addEventListener(&#39;touchend&#39;, function (e) &#123;            if (!isMove &amp;&amp; (Date.now() - startTime) &lt; 150) &#123;  // 如果手指触摸和离开时间小于150ms 算点击                callback &amp;&amp; callback(); // 执行回调函数            &#125;            isMove = false;  //  取反 重置            startTime = 0;        &#125;);&#125;//调用  tap(div, function()&#123;   // 执行代码  &#125;);</code></pre><ol start="3"><li>使用插件。fastclick 插件解决 300ms 延迟。<br><img src="images%5C1551797533(1).jpg#"></li></ol><h2 id="1-5-移动端常用开发插件"><a href="#1-5-移动端常用开发插件" class="headerlink" title="1.5. 移动端常用开发插件"></a>1.5. 移动端常用开发插件</h2><h3 id="1-5-1-什么是插件"><a href="#1-5-1-什么是插件" class="headerlink" title="1.5.1. 什么是插件"></a>1.5.1. 什么是插件</h3><p>移动端要求的是快速开发，所以我们经常会借助于一些插件来帮我完成操作，那么什么是插件呢？<br>JS 插件是 js 文件，它遵循一定规范编写，方便程序展示效果，拥有特定功能且方便调用。如轮播图和瀑布流插件。<br>特点：它一般是为了解决某个问题而专门存在，其功能单一，并且比较小。<br>我们以前写的 animate.js 也算一个最简单的插件<br>fastclick 插件解决 300ms 延迟。 使用延时<br>GitHub 官网地址： <a href="https://github.com/ftlabs/fastclick">https://</a><a href="https://github.com/ftlabs/fastclick">github.com/ftlabs/fastclick</a></p><h3 id="1-5-2-插件的使用"><a href="#1-5-2-插件的使用" class="headerlink" title="1.5.2. 插件的使用"></a>1.5.2. 插件的使用</h3><ol><li><p>引入 js 插件文件。</p></li><li><p>按照规定语法使用。</p></li><li><p>fastclick 插件解决 300ms 延迟。 使用延时</p></li><li><p>GitHub 官网地址： <a href="https://github.com/ftlabs/fastclick">https://github.com/ftlabs/fastclick</a></p></li></ol><pre><code class="javascript">if (&quot;addEventListener&quot; in document) &#123;  document.addEventListener(    &quot;DOMContentLoaded&quot;,    function () &#123;      FastClick.attach(document.body);    &#125;,    false  );&#125;</code></pre><h3 id="1-5-3-Swiper-插件的使用"><a href="#1-5-3-Swiper-插件的使用" class="headerlink" title="1.5.3. Swiper 插件的使用"></a>1.5.3. Swiper 插件的使用</h3><p>中文官网地址： <a href="https://www.swiper.com.cn/">https://www.swiper.com.cn/</a></p><ol><li>引入插件相关文件。</li><li>按照规定语法使用</li></ol><h3 id="1-5-4-其他移动端常见插件"><a href="#1-5-4-其他移动端常见插件" class="headerlink" title="1.5.4. 其他移动端常见插件"></a>1.5.4. 其他移动端常见插件</h3><p>lsuperslide： <a href="http://www.superslide2.com/">http://www.superslide2.com/</a><br>l iscroll： <a href="https://github.com/cubiq/iscroll">https://github.com/cubiq/iscroll</a></p><h3 id="1-5-5-插件的使用总结"><a href="#1-5-5-插件的使用总结" class="headerlink" title="1.5.5. 插件的使用总结"></a>1.5.5. 插件的使用总结</h3><p>1.确认插件实现的功能 2.去官网查看使用说明 3.下载插件 4.打开 demo 实例文件，查看需要引入的相关文件，并且引入 5.复制 demo 实例文件中的结构 html，样式 css 以及 js 代码</p><h3 id="1-5-6-移动端视频插件-zy-media-js"><a href="#1-5-6-移动端视频插件-zy-media-js" class="headerlink" title="1.5.6. 移动端视频插件 zy.media.js"></a>1.5.6. 移动端视频插件 zy.media.js</h3><p>H5 给我们提供了 video 标签，但是浏览器的支持情况不同。<br>不同的视频格式文件，我们可以通过 source 解决。<br>但是外观样式，还有暂停，播放，全屏等功能我们只能自己写代码解决。<br>这个时候我们可以使用插件方式来制作。<br>我们可以通过 JS 修改元素的大小、颜色、位置等样式。</p><h2 id="1-6-移动端常用开发框架"><a href="#1-6-移动端常用开发框架" class="headerlink" title="1.6. 移动端常用开发框架"></a>1.6. 移动端常用开发框架</h2><h3 id="1-6-1-移动端视频插件-zy-media-js"><a href="#1-6-1-移动端视频插件-zy-media-js" class="headerlink" title="1.6.1. 移动端视频插件 zy.media.js"></a>1.6.1. 移动端视频插件 zy.media.js</h3><p>框架，顾名思义就是一套架构，它会基于自身的特点向用户提供一套较为完整的解决方案。框架的控制权在框架本身，使用者要按照框架所规定的某种规范进行开发。<br>插件一般是为了解决某个问题而专门存在，其功能单一，并且比较小。<br>前端常用的框架有 Bootstrap、Vue、Angular、React 等。既能开发 PC 端，也能开发移动端<br>前端常用的移动端插件有 swiper、superslide、iscroll 等。<br>框架： 大而全，一整套解决方案<br>插件： 小而专一，某个功能的解决方案</p><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
          <category> BOM </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>window五大对象</title>
      <link href="blog/window_five_obj_webapis/"/>
      <url>blog/window_five_obj_webapis/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是-BOM"><a href="#什么是-BOM" class="headerlink" title="什么是 BOM"></a>什么是 BOM</h2><p>BOM（Browser Object Model）即浏览器对象模型，它提供了独立于内容而与浏览器窗口进行交互的对象，其核心对象是 window。<br>BOM 由一系列相关的对象构成，并且每个对象都提供了很多方法与属性。<br>BOM 缺乏标准，JavaScript 语法的标准化组织是 ECMA，DOM 的标准化组织是 W3C，BOM 最初是 Netscape 浏览器标准的一部分。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518362800-e37d0116-7afb-4099-9d0e-d06e4a1e5127.png#align=left&display=inline&height=207&margin=%5Bobject%20Object%5D&originHeight=207&originWidth=866&status=done&style=stroke&width=866"><br>BOM 比 DOM 更大，它包含 DOM。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518362856-04ac0f7c-e251-4985-ba14-9d8839bd2fcf.png#align=left&display=inline&height=214&margin=%5Bobject%20Object%5D&originHeight=214&originWidth=629&status=done&style=stroke&width=629"></p><h2 id="window-对象"><a href="#window-对象" class="headerlink" title="window 对象"></a>window 对象</h2><h3 id="window-alert、window-prompt"><a href="#window-alert、window-prompt" class="headerlink" title="window.alert、window.prompt"></a>window.alert、window.prompt</h3><ul><li>是 js 访问浏览器窗口的一个接口</li><li>之前学的这两种输入输出都是 window 的对象方法，window.alert 的 window 可以省略</li></ul><h3 id="window-name"><a href="#window-name" class="headerlink" title="window.name"></a>window.name</h3><p>window.name 的使用</p><ul><li>参考：<a href="https://www.zhangxinxu.com/wordpress/2019/09/window-name/">https://www.zhangxinxu.com/wordpress/2019/09/window-name/</a>（基本没啥用了）</li></ul><h3 id="window-onload-和-DOMContentLoaded"><a href="#window-onload-和-DOMContentLoaded" class="headerlink" title="window.onload 和 DOMContentLoaded"></a>window.onload 和 DOMContentLoaded</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518362978-a9a37865-ed21-4388-9d6b-9c95cf4e2c03.png#align=left&display=inline&height=134&margin=%5Bobject%20Object%5D&originHeight=134&originWidth=697&status=done&style=none&width=697"></p><ul><li>窗口 (页面）加载事件</li><li><strong>当文档内容完全加载完成</strong>会触发该事件(包括图像、脚本文件、CSS 文件等), 就调用的处理函数。</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518363060-d1b0c898-d05e-45d2-b969-d625f094716e.png#align=left&display=inline&height=175&margin=%5Bobject%20Object%5D&originHeight=175&originWidth=717&status=done&style=stroke&width=717"></p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518363117-b08edff8-a5e7-4d72-af87-30d266da9644.png#align=left&display=inline&height=84&margin=%5Bobject%20Object%5D&originHeight=84&originWidth=692&status=done&style=none&width=692"><br>事件触发时，仅当 DOM 加载完成，不包括样式表，图片，flash 等等。<br>IE9 以上才支持<br>适用场景：如果页面的图片很多的话, 从用户访问到 onload 触发可能需要较长的时间, 交互效果就不能实现，必然影响用户的体验，此时用 DOMContentLoaded 事件比较合适。</p><pre><code class="js">&lt;script&gt;        window.addEventListener(&#39;load&#39;, function() &#123;            var btn = document.querySelector(&#39;button&#39;);            btn.addEventListener(&#39;click&#39;, function() &#123;                alert(&#39;点击我&#39;);            &#125;)        &#125;)        window.addEventListener(&#39;load&#39;, function() &#123;            alert(22);        &#125;)        document.addEventListener(&#39;DOMContentLoaded&#39;, function() &#123;            alert(33);        &#125;)    &lt;/script&gt;</code></pre><h3 id="window-onresize"><a href="#window-onresize" class="headerlink" title="window.onresize"></a>window.onresize</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518363174-36e0247a-e870-47b7-ad70-a39e8204f778.png#align=left&display=inline&height=117&margin=%5Bobject%20Object%5D&originHeight=117&originWidth=698&status=done&style=none&width=698"></p><ul><li><p>window.onresize 是调整窗口大小加载事件, 当触发时就调用的处理函数。</p></li><li><p>只要窗口大小发生像素变化，就会触发这个事件。</p></li><li><p>利用这个事件完成响应式布局</p></li><li><p>window.innerWidth 当前屏幕的宽度</p></li></ul><pre><code class="javascript">&lt;script&gt;        // 注册页面加载事件        window.addEventListener(&#39;load&#39;, function() &#123;            var div = document.querySelector(&#39;div&#39;);            // 注册调整窗口大小事件            window.addEventListener(&#39;resize&#39;, function() &#123;                // window.innerWidth 获取窗口大小                console.log(&#39;变化了&#39;);                if (window.innerWidth &lt;= 800) &#123;                    div.style.display = &#39;none&#39;;                &#125; else &#123;                    div.style.display = &#39;block&#39;;                &#125;            &#125;)        &#125;)    &lt;/script&gt;    &lt;div&gt;&lt;/div&gt;</code></pre><h3 id="setTimeout-和-clearTimeout"><a href="#setTimeout-和-clearTimeout" class="headerlink" title="setTimeout()和 clearTimeout()"></a>setTimeout()和 clearTimeout()</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518363237-7fb4b99d-18cc-4621-9153-99ee3b219faa.png#align=left&display=inline&height=50&margin=%5Bobject%20Object%5D&originHeight=50&originWidth=695&status=done&style=stroke&width=695"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518363294-245f3e69-65be-425b-8390-cedcea50e6b9.png#align=left&display=inline&height=31&margin=%5Bobject%20Object%5D&originHeight=31&originWidth=687&status=done&style=stroke&width=687"></p><ul><li>默认的延迟毫秒数默认是 0，单位必须是毫秒</li><li>通常定义了一个这种函数就给其“名”，赋予其一个标识符，因为一个项目里面可能有很多的定时器。<blockquote><p>什么是回调函数呢？</p></blockquote></li></ul><p>普通函数是按照代码顺序直接调用。回调，就是回头调用的意思。上一件事干完，再回头再调用这个函数。例如：定时器中的调用函数，事件处理函数，也是回调函数。element.onclick = function(){}   或者  element.addEventListener(“click”, fn);   里面的 函数也是回调函数。</p><pre><code class="js">&lt;script&gt;        // 回调函数是一个匿名函数         setTimeout(function() &#123;             console.log(&#39;时间到了&#39;);         &#125;, 2000);        function callback() &#123;            console.log(&#39;爆炸了&#39;);        &#125;        // 回调函数是一个有名函数        var timer1 = setTimeout(callback, 3000);        var timer2 = setTimeout(callback, 5000);    &lt;/script&gt;</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518363519-c36076ed-0e62-471c-a193-001186cebc77.png#align=left&display=inline&height=51&margin=%5Bobject%20Object%5D&originHeight=51&originWidth=703&status=done&style=none&width=703"></p><ul><li>类似在炸弹爆炸前拆除的意思</li></ul><pre><code class="js">&lt;button&gt;点击停止定时器&lt;/button&gt;    &lt;script&gt;        var btn = document.querySelector(&#39;button&#39;);        // 开启定时器        var timer = setTimeout(function() &#123;            console.log(&#39;爆炸了&#39;);        &#125;, 5000);        // 给按钮注册单击事件        btn.addEventListener(&#39;click&#39;, function() &#123;            // 停止定时器            clearTimeout(timer);        &#125;)    &lt;/script&gt;</code></pre><h3 id="setInterval-和-clearInterval"><a href="#setInterval-和-clearInterval" class="headerlink" title="setInterval()和 clearInterval()"></a>setInterval()和 clearInterval()</h3><ul><li>会多次进行调用，直到清除</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616033160668-637ca99a-723f-4f14-9576-6de4f4fdd383.png#align=left&display=inline&height=50&margin=%5Bobject%20Object%5D&name=image.png&originHeight=99&originWidth=1438&size=41629&status=done&style=none&width=719" alt="image.png"></p><h3 id="Demo：倒计时"><a href="#Demo：倒计时" class="headerlink" title="Demo：倒计时"></a>Demo：倒计时</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616035667401-0c467c6a-2509-4b0c-a1b3-ea2a9b3d4f85.png#align=left&display=inline&height=82&margin=%5Bobject%20Object%5D&name=image.png&originHeight=163&originWidth=316&size=3932&status=done&style=stroke&width=158" alt="image.png"></p><pre><code class="javascript">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;    &lt;style&gt;        div &#123;            margin: 200px;        &#125;        span &#123;            display: inline-block;            width: 40px;            height: 40px;            background-color: #333;            font-size: 20px;            color: #fff;            text-align: center;            line-height: 40px;        &#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;div&gt;        &lt;span class=&quot;hour&quot;&gt;1&lt;/span&gt;        &lt;span class=&quot;minute&quot;&gt;2&lt;/span&gt;        &lt;span class=&quot;second&quot;&gt;3&lt;/span&gt;    &lt;/div&gt;    &lt;script&gt;        // 1. 获取元素        var hour = document.querySelector(&#39;.hour&#39;); // 小时的黑色盒子        var minute = document.querySelector(&#39;.minute&#39;); // 分钟的黑色盒子        var second = document.querySelector(&#39;.second&#39;); // 秒数的黑色盒子        var inputTime = +new Date(&#39;2021-3-18 19:00:00&#39;); // 返回的是用户输入时间总的毫秒数        countDown(); // 我们先调用一次这个函数，防止第一次刷新页面有空白        // 2. 开启定时器        setInterval(countDown, 1000);        function countDown() &#123;            var nowTime = +new Date(); // 返回的是当前时间总的毫秒数            var times = (inputTime - nowTime) / 1000; // times是剩余时间总的秒数            var h = parseInt(times / 60 / 60 % 24); //时            h = h &lt; 10 ? &#39;0&#39; + h : h;            hour.innerHTML = h; // 把剩余的小时给 小时黑色盒子            var m = parseInt(times / 60 % 60); // 分            m = m &lt; 10 ? &#39;0&#39; + m : m;            minute.innerHTML = m;            var s = parseInt(times % 60); // 当前的秒            s = s &lt; 10 ? &#39;0&#39; + s : s;            second.innerHTML = s;        &#125;    &lt;/script&gt;&lt;/body&gt;&lt;/html</code></pre><h3 id="Demo：短信倒计时"><a href="#Demo：短信倒计时" class="headerlink" title="Demo：短信倒计时"></a>Demo：短信倒计时</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616036201989-deced5f6-9ec3-4392-8e1d-cf10d7c1c55b.png#align=left&display=inline&height=42&margin=%5Bobject%20Object%5D&name=image.png&originHeight=63&originWidth=959&size=11368&status=done&style=none&width=641" alt="image.png"></p><blockquote><p>案例：发送短信倒计时<br>同时这个例子还用到了闭包的相关知识</p></blockquote><p>点击按钮后，该按钮 60 秒之内不能再次点击，防止重复发送短信。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518363854-8efb51de-f962-4ce9-b686-4166d4ef3bfe.png#align=left&display=inline&height=40&margin=%5Bobject%20Object%5D&originHeight=40&originWidth=364&status=done&style=stroke&width=364"></p><pre><code class="js">手机号码： &lt;input type=&quot;number&quot;&gt; &lt;button&gt;发送&lt;/button&gt;    &lt;script&gt;        var btn = document.querySelector(&#39;button&#39;);        // 全局变量，定义剩下的秒数        var time = 3;        // 注册单击事件        btn.addEventListener(&#39;click&#39;, function() &#123;            // 禁用按钮            btn.disabled = true;            // 开启定时器            var timer = setInterval(function() &#123;                // 判断剩余秒数                if (time == 0) &#123;                    // 清除定时器和复原按钮                    clearInterval(timer);                    btn.disabled = false;                    btn.innerHTML = &#39;发送&#39;;                &#125; else &#123;                    btn.innerHTML = &#39;还剩下&#39; + time + &#39;秒&#39;;                    time--;                &#125;            &#125;, 1000);        &#125;);    &lt;/script&gt;</code></pre><h2 id="location-对象"><a href="#location-对象" class="headerlink" title="location 对象"></a>location 对象</h2><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518363970-e7ae6f17-8fa0-4cda-bd5c-a486dbad0410.png#align=left&display=inline&height=56&margin=%5Bobject%20Object%5D&originHeight=56&originWidth=722&status=done&style=none&width=722"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518364029-47b8981f-8ef1-4978-8760-2be8bc0c5e96.png#align=left&display=inline&height=177&margin=%5Bobject%20Object%5D&originHeight=177&originWidth=723&status=done&style=none&width=723"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518364086-8b3e0045-e245-4c0a-b484-4e038b829a6b.png#align=left&display=inline&height=240&margin=%5Bobject%20Object%5D&originHeight=240&originWidth=684&status=done&style=none&width=684"></p><h3 id="location-对象常用属性"><a href="#location-对象常用属性" class="headerlink" title="location 对象常用属性"></a>location 对象常用属性</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518364152-c5c0aa45-eb47-49d3-81ce-2318a6bc8497.png#align=left&display=inline&height=240&margin=%5Bobject%20Object%5D&originHeight=240&originWidth=705&status=done&style=none&width=705"></p><h3 id="location-对象常见方法"><a href="#location-对象常见方法" class="headerlink" title="location 对象常见方法"></a>location 对象常见方法</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518364490-f3c87eef-a34f-4378-9b69-03ea18f2fb26.png#align=left&display=inline&height=153&margin=%5Bobject%20Object%5D&originHeight=153&originWidth=728&status=done&style=none&width=728"></p><pre><code class="js">&lt;button&gt;点击&lt;/button&gt;    &lt;script&gt;        var btn = document.querySelector(&#39;button&#39;);        btn.addEventListener(&#39;click&#39;, function() &#123;            // 记录浏览历史，所以可以实现后退功能            // location.assign(&#39;http://www.itcast.cn&#39;);            // 不记录浏览历史，所以不可以实现后退功能            // location.replace(&#39;http://www.itcast.cn&#39;);            location.reload(true);        &#125;)    &lt;/script&gt;</code></pre><h3 id="Demo：5-秒钟自动跳转页面"><a href="#Demo：5-秒钟自动跳转页面" class="headerlink" title="Demo：5 秒钟自动跳转页面"></a>Demo：5 秒钟自动跳转页面</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616038766425-7b736d4a-8329-4912-879c-7eb5924745f5.png#align=left&display=inline&height=260&margin=%5Bobject%20Object%5D&name=image.png&originHeight=519&originWidth=798&size=756606&status=done&style=stroke&width=399" alt="image.png"></p><pre><code class="javascript">var img = document.getElementsByTagName(&quot;img&quot;);img[0].addEventListener(&quot;click&quot;, function () &#123;  console.log(&quot;运行到了这里1&quot;);  setTimeout(function () &#123;    location.href = &quot;https://www.wztlink1013.com&quot;;    console.log(&quot;运行到了这里&quot;);  &#125;, 5000);&#125;);</code></pre><h3 id="Demo：获取-URL-参数"><a href="#Demo：获取-URL-参数" class="headerlink" title="Demo：获取 URL 参数"></a>Demo：获取 URL 参数</h3><blockquote><p>login.html</p></blockquote><pre><code class="html">&lt;body&gt;  &lt;form action=&quot;index.html&quot;&gt;    用户名： &lt;input type=&quot;text&quot; name=&quot;uname&quot; /&gt;    &lt;input type=&quot;submit&quot; value=&quot;登录&quot; /&gt;  &lt;/form&gt;&lt;/body&gt;</code></pre><blockquote><p>index.html</p></blockquote><p>收到 login 页面传来的参数后<img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616039288488-d1884566-894d-4a15-a677-9227934a5eb9.png#align=left&display=inline&height=28&margin=%5Bobject%20Object%5D&name=image.png&originHeight=55&originWidth=341&size=3107&status=done&style=stroke&width=170.5" alt="image.png"></p><pre><code class="html">&lt;div&gt;&lt;/div&gt;&lt;script&gt;  console.log(location.search); // ?uname=wztlink1013  // 1.先去掉？  substr(&#39;起始的位置&#39;，截取几个字符);  var params = location.search.substr(1); // uname=wztlink1013  console.log(params);  // 2. 利用=把字符串分割为数组 split(&#39;=&#39;);  var arr = params.split(&quot;=&quot;);  console.log(arr); // [&quot;uname&quot;, &quot;wztlink1013&quot;]  var div = document.querySelector(&quot;div&quot;);  // 3.把数据写入div中  div.innerHTML = arr[1] + &quot;欢迎您&quot;;&lt;/script&gt;</code></pre><h2 id="navigator-对象"><a href="#navigator-对象" class="headerlink" title="navigator 对象"></a>navigator 对象</h2><p>navigator 对象包含有关浏览器的信息，它有很多属性，我们最常用的是 userAgent，该属性可以返回由客户机发送服务器的 user-agent 头部的值。<br>下面前端代码可以判断用户那个终端打开页面，实现跳转，比如：</p><pre><code class="javascript">if (  navigator.userAgent.match(    /(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i  )) &#123;  window.location.href = &quot;https://www.wztlink1013.com/m/index.html&quot;; //手机页面&#125; else &#123;  window.location.href = &quot;https://www.wztlink1013.com/p/index.html&quot;; //电脑页面&#125;</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616072483887-50d05057-73f8-49b7-8761-8f68defe6194.png#align=left&display=inline&height=441&margin=%5Bobject%20Object%5D&name=image.png&originHeight=881&originWidth=1920&size=1468471&status=done&style=stroke&width=960" alt="image.png"></p><h2 id="history-对象"><a href="#history-对象" class="headerlink" title="history 对象"></a>history 对象</h2><pre><code>window对象给我们提供了一个 history对象，与浏览器历史记录进行交互。该对象包含用户（在浏览器窗口中）访问过的URL。</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518364555-790a838f-2446-45bd-886e-686c75286b2c.png#align=left&display=inline&height=148&margin=%5Bobject%20Object%5D&originHeight=148&originWidth=731&status=done&style=none&width=731"></p><h2 id="screen-对象"><a href="#screen-对象" class="headerlink" title="screen 对象"></a>screen 对象</h2><table><thead><tr><th align="left">属性</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><a href="https://www.runoob.com/jsref/prop-screen-availheight.html">availHeight</a></td><td align="left">返回屏幕的高度（不包括 Windows 任务栏）</td></tr><tr><td align="left"><a href="https://www.runoob.com/jsref/prop-screen-availwidth.html">availWidth</a></td><td align="left">返回屏幕的宽度（不包括 Windows 任务栏）</td></tr><tr><td align="left"><a href="https://www.runoob.com/jsref/prop-screen-colordepth.html">colorDepth</a></td><td align="left">返回目标设备或缓冲器上的调色板的比特深度</td></tr><tr><td align="left"><a href="https://www.runoob.com/jsref/prop-screen-height.html">height</a></td><td align="left">返回屏幕的总高度</td></tr><tr><td align="left"><a href="https://www.runoob.com/jsref/prop-screen-pixeldepth.html">pixelDepth</a></td><td align="left">返回屏幕的颜色分辨率（每象素的位数）</td></tr><tr><td align="left"><a href="https://www.runoob.com/jsref/prop-screen-width.html">width</a></td><td align="left">返回屏幕的总宽度</td></tr></tbody></table><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616073065915-eee3a4aa-52a8-4200-9d15-9e66f5c4fba5.png#align=left&display=inline&height=881&margin=%5Bobject%20Object%5D&name=Snipaste_2021-03-18_21-09-08.png&originHeight=881&originWidth=1920&size=697028&status=done&style=stroke&width=1920" alt="Snipaste_2021-03-18_21-09-08.png"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616073033094-e0640f15-e1a2-4f9d-9937-aad687e2bfbe.png#align=left&display=inline&height=540&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1080&originWidth=620&size=196090&status=done&style=stroke&width=310" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
          <category> BOM </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>动画函数封装</title>
      <link href="blog/6_day06_webapis/"/>
      <url>blog/6_day06_webapis/</url>
      
        <content type="html"><![CDATA[<h2 id="动画函数封装"><a href="#动画函数封装" class="headerlink" title="动画函数封装"></a>动画函数封装</h2><h3 id="动画实现原理"><a href="#动画实现原理" class="headerlink" title="动画实现原理"></a>动画实现原理</h3><blockquote><p>核心原理：通过定时器 setInterval() 不断移动盒子位置。</p></blockquote><p>实现步骤：</p><ol><li>获得盒子当前位置</li><li>让盒子在当前位置加上 1 个移动距离</li><li>利用定时器不断重复这个操作</li><li>加一个结束定时器的条件</li><li>注意此元素需要添加定位，才能使用 element.style.left</li></ol><h3 id="动画函数给不同元素记录不同定时器"><a href="#动画函数给不同元素记录不同定时器" class="headerlink" title="动画函数给不同元素记录不同定时器"></a>动画函数给不同元素记录不同定时器</h3><p>如果多个元素都使用这个动画函数，每次都要 var 声明定时器。我们可以给不同的元素使用不同的定时器（自己专门用自己的定时器）。</p><blockquote><p>核心原理：利用 JS 是一门动态语言，可以很方便的给当前对象添加属性。</p></blockquote><pre><code class="javascript">function animate(obj, target) &#123;  // 当我们不断的点击按钮，这个元素的速度会越来越快，因为开启了太多的定时器  // 解决方案就是 让我们元素只有一个定时器执行  // 先清除以前的定时器，只保留当前的一个定时器执行  clearInterval(obj.timer);  obj.timer = setInterval(function () &#123;    if (obj.offsetLeft &gt;= target) &#123;      // 停止动画 本质是停止定时器      clearInterval(obj.timer);    &#125;    obj.style.left = obj.offsetLeft + 1 + &quot;px&quot;;  &#125;, 30);&#125;</code></pre><p>**</p><h3 id="缓动效果原理"><a href="#缓动效果原理" class="headerlink" title="缓动效果原理"></a>缓动效果原理</h3><p>缓动动画就是让元素运动速度有所变化，最常见的是让速度慢慢停下来<br>思路：</p><ol><li>让盒子每次移动的距离慢慢变小，速度就会慢慢落下来。</li><li>核心算法： (目标值 - 现在的位置)   /  10    做为每次移动的距离步长</li><li>停止的条件是： 让当前盒子位置等于目标位置就停止定时器</li><li>注意步长值需要取整</li></ol><h3 id="动画函数多个目标值之间移动"><a href="#动画函数多个目标值之间移动" class="headerlink" title="动画函数多个目标值之间移动"></a>动画函数多个目标值之间移动</h3><p>可以让动画函数从 800 移动到 500。<br>当我们点击按钮时候，判断步长是正值还是负值 1.如果是正值，则步长往大了取整 2.如果是负值，则步长 向小了取整</p><h3 id="动函数添加回调函数"><a href="#动函数添加回调函数" class="headerlink" title="动函数添加回调函数"></a>动函数添加回调函数</h3><p>回调函数原理：函数可以作为一个参数。将这个函数作为参数传到另一个函数里面，当那个函数执行完之后，再执行传进去的这个函数，这个过程就叫做回调。<br>回调函数写的位置：定时器结束的位置。</p><h3 id="动画完整版代码"><a href="#动画完整版代码" class="headerlink" title="动画完整版代码:"></a>动画完整版代码:</h3><pre><code class="javascript">function animate(obj, target, callback) &#123;  // console.log(callback);  callback = function() &#123;&#125;  调用的时候 callback()  // 先清除以前的定时器，只保留当前的一个定时器执行  clearInterval(obj.timer);  obj.timer = setInterval(function () &#123;    // 步长值写到定时器的里面    // 把我们步长值改为整数 不要出现小数的问题    // var step = Math.ceil((target - obj.offsetLeft) / 10);    var step = (target - obj.offsetLeft) / 10;    step = step &gt; 0 ? Math.ceil(step) : Math.floor(step);    if (obj.offsetLeft == target) &#123;      // 停止动画 本质是停止定时器      clearInterval(obj.timer);      // 回调函数写到定时器结束里面      // if (callback) &#123;      //     // 调用函数      //     callback();      // &#125;      callback &amp;&amp; callback();    &#125;    // 把每次加1 这个步长值改为一个慢慢变小的值  步长公式：(目标值 - 现在的位置) / 10    obj.style.left = obj.offsetLeft + step + &quot;px&quot;;  &#125;, 15);&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
          <category> JavaScript特效 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>DOM节点操作</title>
      <link href="blog/2_day02_webapis/"/>
      <url>blog/2_day02_webapis/</url>
      
        <content type="html"><![CDATA[<h3 id="节点概述"><a href="#节点概述" class="headerlink" title="节点概述"></a>节点概述</h3><p>网页中的所有内容都是节点（标签、属性、文本、注释等），在 DOM 中，节点使用 node 来表示。HTML DOM 树中的所有节点均可通过 JavaScript 进行访问，所有 HTML 元素（节点）均可被修改，也可以创建或删除。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518358489-a0521202-b32d-46a9-9b8d-f0cfe9afc455.png#align=left&display=inline&height=236&margin=%5Bobject%20Object%5D&originHeight=236&originWidth=432&status=done&style=stroke&width=432"><br>一般地，节点至少拥有 nodeType（节点类型）、nodeName（节点名称）和 nodeValue（节点值）这三个基本属性。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518358548-9283575f-7aef-450d-bc6e-b9d3a4384cc2.png#align=left&display=inline&height=148&margin=%5Bobject%20Object%5D&originHeight=148&originWidth=666&status=done&style=stroke&width=666"></p><blockquote><p>节点层级：利用 DOM 树可以把节点划分为不同的层级关系，常见的是<strong>父子兄层级关系</strong>。</p></blockquote><h2 id="父节点"><a href="#父节点" class="headerlink" title="父节点"></a>父节点</h2><h3 id="node-parentNode"><a href="#node-parentNode" class="headerlink" title="node.parentNode"></a>node.parentNode</h3><ul><li>返回某节点的父节点，最近的一个父节点</li><li>如果没有父节点，则返回 null</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616056309357-b2a256d0-2a4d-4983-80f9-1eed069c3890.png#align=left&display=inline&height=354&margin=%5Bobject%20Object%5D&name=image.png&originHeight=708&originWidth=1920&size=1164429&status=done&style=stroke&width=960" alt="image.png"></p><h2 id="子节点"><a href="#子节点" class="headerlink" title="子节点"></a>子节点</h2><h3 id="parentNode-childNodes"><a href="#parentNode-childNodes" class="headerlink" title="parentNode.childNodes"></a>parentNode.childNodes</h3><ul><li>返回指定节点的子节点的集合，会即时更新</li><li>会返回所有的节点（包含元素节点、文本节点等）</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616056553404-55b8fe19-9bea-413d-9cb1-6554380831af.png#align=left&display=inline&height=281&margin=%5Bobject%20Object%5D&name=image.png&originHeight=561&originWidth=1920&size=936204&status=done&style=stroke&width=960" alt="image.png"></p><h3 id="parentNode-children"><a href="#parentNode-children" class="headerlink" title="parentNode.children"></a>parentNode.children</h3><ul><li>只读属性</li><li>只返回元素节点</li><li>非标准，但是各个浏览器都支持</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616056710609-4bb68282-b6ae-4240-b9be-a9faea530ab2.png#align=left&display=inline&height=435&margin=%5Bobject%20Object%5D&name=image.png&originHeight=870&originWidth=1920&size=1444600&status=done&style=stroke&width=960" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616057002507-4244db60-7bf0-4e95-b68b-acb4d4d62d8d.png#align=left&display=inline&height=318&margin=%5Bobject%20Object%5D&name=image.png&originHeight=635&originWidth=1920&size=1036129&status=done&style=stroke&width=960" alt="image.png"></p><h3 id="parent-firstChild"><a href="#parent-firstChild" class="headerlink" title="parent.firstChild"></a>parent.firstChild</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616057242192-2bb01e66-de7d-4220-afc2-499adbdcc3de.png#align=left&display=inline&height=225&margin=%5Bobject%20Object%5D&name=image.png&originHeight=449&originWidth=1920&size=719099&status=done&style=stroke&width=960" alt="image.png"></p><ul><li>返回第一个子节点，找不到返回 null，包含所有节点</li></ul><h3 id="parent-lastChild"><a href="#parent-lastChild" class="headerlink" title="parent.lastChild"></a>parent.lastChild</h3><ul><li>返回最后一个子节点，找不到返回 null，包含所有节点</li></ul><h3 id="parent-firstElementChild"><a href="#parent-firstElementChild" class="headerlink" title="parent.firstElementChild"></a>parent.firstElementChild</h3><ul><li>返回第一个子元素节点，找不到返回 null</li><li>IE9 以上支持</li></ul><h3 id="parent-lastElementChild"><a href="#parent-lastElementChild" class="headerlink" title="parent.lastElementChild"></a>parent.lastElementChild</h3><ul><li>返回最后一个子元素节点，找不到返回 null</li><li>IE9 以上支持</li></ul><h3 id="首末节点兼容方案"><a href="#首末节点兼容方案" class="headerlink" title="首末节点兼容方案"></a>首末节点兼容方案</h3><blockquote><p>实际开发中，firstChild 和 lastChild 包含其他节点，操作不方便，而 firstElementChild 和 lastElementChild 又有兼容性问题，那么我们如何获取第一个子元素节点或最后一个子元素节点呢？</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616057537841-77a6605b-5d29-4cf2-b750-0cd916841cdd.png#align=left&display=inline&height=303&margin=%5Bobject%20Object%5D&name=image.png&originHeight=606&originWidth=1920&size=992223&status=done&style=stroke&width=960" alt="image.png"></p><h2 id="兄弟节点"><a href="#兄弟节点" class="headerlink" title="兄弟节点"></a>兄弟节点</h2><p><strong>下一个兄弟节点</strong><br><img src="../../../../../%E5%A4%87%E8%AF%BE%E8%B5%84%E6%96%99/20190220-%E8%AF%BE%E4%BB%B6%E5%88%B6%E4%BD%9C/Web%20APIs/Web%20APIs-day02/4-%E7%AC%94%E8%AE%B0/images/1550973538696.png#"><br><strong>上一个兄弟节点</strong><br><img src="../../../../../%E5%A4%87%E8%AF%BE%E8%B5%84%E6%96%99/20190220-%E8%AF%BE%E4%BB%B6%E5%88%B6%E4%BD%9C/Web%20APIs/Web%20APIs-day02/4-%E7%AC%94%E8%AE%B0/images/1550973558511.png#"></p><pre><code class="js">&lt;div&gt;我是div&lt;/div&gt;    &lt;span&gt;我是span&lt;/span&gt;    &lt;script&gt;        var div = document.querySelector(&#39;div&#39;);        // 1.nextSibling 下一个兄弟节点 包含元素节点或者 文本节点等等        console.log(div.nextSibling);        console.log(div.previousSibling);        // 2. nextElementSibling 得到下一个兄弟元素节点        console.log(div.nextElementSibling);        console.log(div.previousElementSibling);    &lt;/script&gt;</code></pre><p><strong>下一个兄弟元素节点（有兼容性问题）</strong><br><img src="../../../../../%E5%A4%87%E8%AF%BE%E8%B5%84%E6%96%99/20190220-%E8%AF%BE%E4%BB%B6%E5%88%B6%E4%BD%9C/Web%20APIs/Web%20APIs-day02/4-%E7%AC%94%E8%AE%B0/images/1550973610223.png#"><br><strong>上一个兄弟元素节点（有兼容性问题）</strong><br><img src="../../../../../%E5%A4%87%E8%AF%BE%E8%B5%84%E6%96%99/20190220-%E8%AF%BE%E4%BB%B6%E5%88%B6%E4%BD%9C/Web%20APIs/Web%20APIs-day02/4-%E7%AC%94%E8%AE%B0/images/1550973630150.png#"><br><img src="../../../../../%E5%A4%87%E8%AF%BE%E8%B5%84%E6%96%99/20190220-%E8%AF%BE%E4%BB%B6%E5%88%B6%E4%BD%9C/Web%20APIs/Web%20APIs-day02/4-%E7%AC%94%E8%AE%B0/images/1550973722805.png#"><br><img src="../../../../../%E5%A4%87%E8%AF%BE%E8%B5%84%E6%96%99/20190220-%E8%AF%BE%E4%BB%B6%E5%88%B6%E4%BD%9C/Web%20APIs/Web%20APIs-day02/4-%E7%AC%94%E8%AE%B0/images/1550973799759.png#"></p><pre><code class="js">function getNextElementSibling(element) &#123;  var el = element;  while ((el = el.nextSibling)) &#123;    if (el.nodeType === 1) &#123;      return el;    &#125;  &#125;  return null;&#125;</code></pre><h2 id="创建结点"><a href="#创建结点" class="headerlink" title="创建结点"></a>创建结点</h2><h3 id="document-createElement"><a href="#document-createElement" class="headerlink" title="document.createElement()"></a>document.createElement()</h3><ul><li>document.createElement(‘tagName’)</li><li>动态创建元素节点</li></ul><h3 id="node-cloneNode"><a href="#node-cloneNode" class="headerlink" title="node.cloneNode()"></a>node.cloneNode()</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518359854-90c1339a-ca41-47e5-86b1-189336c186d3.png#align=left&display=inline&height=248&margin=%5Bobject%20Object%5D&originHeight=248&originWidth=726&status=done&style=stroke&width=726"></p><pre><code class="html">&lt;ul&gt;  &lt;li&gt;1111&lt;/li&gt;  &lt;li&gt;2&lt;/li&gt;  &lt;li&gt;3&lt;/li&gt;&lt;/ul&gt;&lt;script&gt;  var ul = document.querySelector(&quot;ul&quot;);  // 1. node.cloneNode(); 括号为空或者里面是false 浅拷贝 只复制标签不复制里面的内容  // 2. node.cloneNode(true); 括号为true 深拷贝 复制标签复制里面的内容  var lili = ul.children[0].cloneNode(true);  ul.appendChild(lili);&lt;/script&gt;</code></pre><h3 id="Demo：动态生成表格"><a href="#Demo：动态生成表格" class="headerlink" title="Demo：动态生成表格"></a>Demo：动态生成表格</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518359913-8e1af74d-0a30-4370-83ea-4974ad83d2b8.png#align=left&display=inline&height=268&margin=%5Bobject%20Object%5D&originHeight=268&originWidth=718&status=done&style=stroke&width=718"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518359980-7b2a19b1-47dd-41cb-8f9b-93d64873fb6f.png#align=left&display=inline&height=288&margin=%5Bobject%20Object%5D&originHeight=288&originWidth=751&status=done&style=stroke&width=751"></p><pre><code class="html">&lt;script&gt;  // 1.先去准备好学生的数据  var datas = [    &#123;      name: &quot;魏璎珞&quot;,      subject: &quot;JavaScript&quot;,      score: 100,    &#125;,    &#123;      name: &quot;弘历&quot;,      subject: &quot;JavaScript&quot;,      score: 98,    &#125;,    &#123;      name: &quot;傅恒&quot;,      subject: &quot;JavaScript&quot;,      score: 99,    &#125;,    &#123;      name: &quot;明玉&quot;,      subject: &quot;JavaScript&quot;,      score: 88,    &#125;,    &#123;      name: &quot;大猪蹄子&quot;,      subject: &quot;JavaScript&quot;,      score: 0,    &#125;,  ];  // 2. 往tbody 里面创建行： 有几个人（通过数组的长度）我们就创建几行  var tbody = document.querySelector(&quot;tbody&quot;);  // 遍历数组  for (var i = 0; i &lt; datas.length; i++) &#123;    // 1. 创建 tr行    var tr = document.createElement(&quot;tr&quot;);    tbody.appendChild(tr);    // 2. 行里面创建单元格td 单元格的数量取决于每个对象里面的属性个数    // 使用for in遍历学生对象    for (var k in datas[i]) &#123;      // 创建单元格      var td = document.createElement(&quot;td&quot;);      // 把对象里面的属性值 datas[i][k] 给 td      td.innerHTML = datas[i][k];      tr.appendChild(td);    &#125;    // 3. 创建有删除2个字的单元格    var td = document.createElement(&quot;td&quot;);    td.innerHTML = &#39;&lt;a href=&quot;javascript:;&quot;&gt;删除 &lt;/a&gt;&#39;;    tr.appendChild(td);  &#125;  // 4. 删除操作 开始  var as = document.querySelectorAll(&quot;a&quot;);  for (var i = 0; i &lt; as.length; i++) &#123;    as[i].onclick = function () &#123;      // 点击a 删除 当前a 所在的行(链接的爸爸的爸爸)  node.removeChild(child)      tbody.removeChild(this.parentNode.parentNode);    &#125;;  &#125;&lt;/script&gt;</code></pre><h3 id="创建元素的三种方式对比"><a href="#创建元素的三种方式对比" class="headerlink" title="创建元素的三种方式对比"></a>创建元素的三种方式对比</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518360041-a233aa10-7238-46f4-bb78-2438898c8950.png#align=left&display=inline&height=346&margin=%5Bobject%20Object%5D&originHeight=346&originWidth=759&status=done&style=stroke&width=759"></p><pre><code class="html">&lt;script&gt;  // 三种创建元素方式区别  // 1. document.write() 创建元素  如果页面文档流加载完毕，再调用这句话会导致页面重绘  var btn = document.querySelector(&quot;button&quot;);  btn.onclick = function () &#123;    document.write(&quot;&lt;div&gt;123&lt;/div&gt;&quot;);  &#125;;  // 2. innerHTML 创建元素  var inner = document.querySelector(&quot;.inner&quot;);  for (var i = 0; i &lt;= 100; i++) &#123;    inner.innerHTML += &#39;&lt;a href=&quot;#&quot;&gt;百度&lt;/a&gt;&#39;;  &#125;  var arr = [];  for (var i = 0; i &lt;= 100; i++) &#123;    arr.push(&#39;&lt;a href=&quot;#&quot;&gt;百度&lt;/a&gt;&#39;);  &#125;  inner.innerHTML = arr.join(&quot;&quot;);  // 3. document.createElement() 创建元素  var create = document.querySelector(&quot;.create&quot;);  for (var i = 0; i &lt;= 100; i++) &#123;    var a = document.createElement(&quot;a&quot;);    create.appendChild(a);  &#125;&lt;/script&gt;</code></pre><blockquote><p>innerTHML 和 createElement 效率对比</p></blockquote><p><strong>innerHTML 字符串拼接方式（效率低）</strong></p><pre><code class="html">&lt;script&gt;  function fn() &#123;    var d1 = +new Date();    var str = &quot;&quot;;    for (var i = 0; i &lt; 1000; i++) &#123;      document.body.innerHTML +=        &#39;&lt;div style=&quot;width:100px; height:2px; border:1px solid blue;&quot;&gt;&lt;/div&gt;&#39;;    &#125;    var d2 = +new Date();    console.log(d2 - d1);  &#125;  fn();&lt;/script&gt;</code></pre><p><strong>createElement 方式（效率一般）</strong></p><pre><code class="html">&lt;script&gt;  function fn() &#123;    var d1 = +new Date();    for (var i = 0; i &lt; 1000; i++) &#123;      var div = document.createElement(&quot;div&quot;);      div.style.width = &quot;100px&quot;;      div.style.height = &quot;2px&quot;;      div.style.border = &quot;1px solid red&quot;;      document.body.appendChild(div);    &#125;    var d2 = +new Date();    console.log(d2 - d1);  &#125;  fn();&lt;/script&gt;</code></pre><p><strong>innerHTML 数组方式（效率高）</strong></p><pre><code class="html">&lt;script&gt;  function fn() &#123;    var d1 = +new Date();    var array = [];    for (var i = 0; i &lt; 1000; i++) &#123;      array.push(        &#39;&lt;div style=&quot;width:100px; height:2px; border:1px solid blue;&quot;&gt;&lt;/div&gt;&#39;      );    &#125;    document.body.innerHTML = array.join(&quot;&quot;);    var d2 = +new Date();    console.log(d2 - d1);  &#125;  fn();&lt;/script&gt;</code></pre><h2 id="插入结点"><a href="#插入结点" class="headerlink" title="插入结点"></a>插入结点</h2><h3 id="node-appendChild"><a href="#node-appendChild" class="headerlink" title="node.appendChild()"></a>node.appendChild()</h3><ul><li>node.appendChild(child)</li><li>添加到父节点的子节点列表末尾</li></ul><h3 id="node-insertBefore"><a href="#node-insertBefore" class="headerlink" title="node.insertBefore()"></a>node.insertBefore()</h3><ul><li>node.insertBefore(child,指定元素)</li><li>将一个节点添加到父节点的指定子节点前面</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616058396292-0ab90d78-37b9-4851-96bf-2e2bf5fb13cd.png#align=left&display=inline&height=422&margin=%5Bobject%20Object%5D&name=image.png&originHeight=844&originWidth=1920&size=1419443&status=done&style=stroke&width=960" alt="image.png"></p><h3 id="Demo：简单版发布留言"><a href="#Demo：简单版发布留言" class="headerlink" title="Demo：简单版发布留言"></a>Demo：简单版发布留言</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518359458-b8cd80e8-0c64-4c8f-8d76-2cfcdbce3f48.png#align=left&display=inline&height=152&margin=%5Bobject%20Object%5D&originHeight=152&originWidth=337&status=done&style=stroke&width=337"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518359516-1b352ba3-c851-49d8-aeff-5af5668b1d71.png#align=left&display=inline&height=161&margin=%5Bobject%20Object%5D&originHeight=161&originWidth=727&status=done&style=stroke&width=727"></p><pre><code class="html">&lt;body&gt;  &lt;textarea name=&quot;&quot; id=&quot;&quot;&gt;&lt;/textarea&gt;  &lt;button&gt;发布&lt;/button&gt;  &lt;ul&gt;&lt;/ul&gt;  &lt;script&gt;    // 1. 获取元素    var btn = document.querySelector(&quot;button&quot;);    var text = document.querySelector(&quot;textarea&quot;);    var ul = document.querySelector(&quot;ul&quot;);    // 2. 注册事件    btn.onclick = function () &#123;      if (text.value == &quot;&quot;) &#123;        alert(&quot;您没有输入内容&quot;);        return false;      &#125; else &#123;        // console.log(text.value);        // (1) 创建元素        var li = document.createElement(&quot;li&quot;);        // 先有li 才能赋值        li.innerHTML = text.value;        // (2) 添加元素        // ul.appendChild(li);        ul.insertBefore(li, ul.children[0]);      &#125;    &#125;;  &lt;/script&gt;&lt;/body&gt;</code></pre><h2 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h2><h3 id="node-removeChild"><a href="#node-removeChild" class="headerlink" title="node.removeChild()"></a>node.removeChild()</h3><ul><li>node.removeChild() 方法从 node 节点中删除一个子节点，返回删除的节点。</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616060281051-79e7f85a-572a-4e31-b204-b5dbdaff1e60.png#align=left&display=inline&height=435&margin=%5Bobject%20Object%5D&name=image.png&originHeight=870&originWidth=1920&size=1459532&status=done&style=stroke&width=960" alt="image.png"></p><h3 id="Demo：删除留言"><a href="#Demo：删除留言" class="headerlink" title="Demo：删除留言"></a>Demo：删除留言</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518359732-302df5c2-5149-4e89-89dd-e99586f91651.png#align=left&display=inline&height=210&margin=%5Bobject%20Object%5D&originHeight=210&originWidth=361&status=done&style=stroke&width=361"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518359795-1a54681c-6264-48c2-a670-28b1f41c4388.png#align=left&display=inline&height=155&margin=%5Bobject%20Object%5D&originHeight=155&originWidth=718&status=done&style=none&width=718"></p><pre><code class="html">&lt;textarea name=&quot;&quot; id=&quot;&quot;&gt;&lt;/textarea&gt;&lt;button&gt;发布&lt;/button&gt;&lt;ul&gt;&lt;/ul&gt;&lt;script&gt;  // 1. 获取元素  var btn = document.querySelector(&quot;button&quot;);  var text = document.querySelector(&quot;textarea&quot;);  var ul = document.querySelector(&quot;ul&quot;);  // 2. 注册事件  btn.onclick = function () &#123;    if (text.value == &quot;&quot;) &#123;      alert(&quot;您没有输入内容&quot;);      return false;    &#125; else &#123;      // console.log(text.value);      // (1) 创建元素      var li = document.createElement(&quot;li&quot;);      // 先有li 才能赋值      li.innerHTML = text.value + &quot;&lt;a href=&#39;javascript:;&#39;&gt;删除&lt;/a&gt;&quot;;      // (2) 添加元素      // ul.appendChild(li);      ul.insertBefore(li, ul.children[0]);      // (3) 删除元素 删除的是当前链接的li  它的父亲      var as = document.querySelectorAll(&quot;a&quot;);      for (var i = 0; i &lt; as.length; i++) &#123;        as[i].onclick = function () &#123;          // 删除的是 li 当前a所在的li  this.parentNode;          ul.removeChild(this.parentNode);        &#125;;      &#125;    &#125;  &#125;;&lt;/script&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
          <category> DOM </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>DOM元素操作</title>
      <link href="blog/1_day01_webapis/"/>
      <url>blog/1_day01_webapis/</url>
      
        <content type="html"><![CDATA[<h2 id="API-和-Web-API-和-SDK"><a href="#API-和-Web-API-和-SDK" class="headerlink" title="API 和 Web API 和 SDK"></a>API 和 Web API 和 SDK</h2><blockquote><p>文档：<a href="https://developer.mozilla.org/zh-CN/docs/Web/API">https://developer.mozilla.org/zh-CN/docs/Web/API</a></p></blockquote><div style="background: #FFFBE6;padding:10px;border: 1px solid #C3C3C3;border-radius:5px;margin-bottom:5px;">API（Application Programming Interface，应用程序编程接口）是一些预先定义的函数，目的是提供应用程序与开发人员基于某软件或硬件得以访问一组例程的能力，而又无需访问源码，无需理解其内部工作机制细节，只需直接调用使用即可。</div><div style="background: #FFFBE6;padding:10px;border: 1px solid #C3C3C3;border-radius:5px;margin-bottom:5px;">Web API 是浏览器提供的一套操作浏览器功能和页面元素的 API ( BOM 和 DOM )。</div><div style="background: #FFFBE6;padding:10px;border: 1px solid #C3C3C3;border-radius:5px;margin-bottom:5px;">[https://www.zhihu.com/question/21691705](https://www.zhihu.com/question/21691705)</div><h2 id="DOM-总结"><a href="#DOM-总结" class="headerlink" title="DOM 总结"></a>DOM 总结</h2><p>关于 dom 操作，我们主要针对于元素的操作。主要有创建、增、删、改、查、属性操作、事件操作。<br>【1】创建<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518360222-db94e8d0-f9a7-459d-8a24-88b745237bd5.png#align=left&display=inline&height=115&margin=%5Bobject%20Object%5D&originHeight=115&originWidth=691&status=done&style=stroke&width=691"><br>【2】增<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518360287-480d224a-a047-4ef5-8bba-92845d85b573.png#align=left&display=inline&height=85&margin=%5Bobject%20Object%5D&originHeight=85&originWidth=720&status=done&style=stroke&width=720"><br>【3】删<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518360367-4e96254b-5fd8-4f7e-8fb3-29143718f08d.png#align=left&display=inline&height=49&margin=%5Bobject%20Object%5D&originHeight=49&originWidth=695&status=done&style=stroke&width=695"><br>【4】改<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518360436-7e94f916-24d1-4e97-84fe-6fc6ba6d68fb.png#align=left&display=inline&height=191&margin=%5Bobject%20Object%5D&originHeight=191&originWidth=731&status=done&style=stroke&width=731"><br>【5】查<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518360497-cfec4566-ac5b-46c6-995d-8db307167137.png#align=left&display=inline&height=181&margin=%5Bobject%20Object%5D&originHeight=181&originWidth=703&status=done&style=stroke&width=703"><br>【6】属性操作<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518360564-6e2cf7dd-fa5e-48fe-bcdb-be69ea87065c.png#align=left&display=inline&height=157&margin=%5Bobject%20Object%5D&originHeight=157&originWidth=722&status=done&style=stroke&width=722"><br>【7】事件操作（重点）</p><h2 id="获取元素"><a href="#获取元素" class="headerlink" title="获取元素"></a>获取元素</h2><h3 id="getElementById"><a href="#getElementById" class="headerlink" title="getElementById"></a>getElementById</h3><ul><li>语法：document.getElementById(id)</li><li>作用：根据 ID 获取元素对象</li><li>参数：id 值，区分大小写的字符串</li><li>返回值：元素对象 或 null</li></ul><p>**</p><pre><code class="javascript">var test_id = document.getElementById(&quot;indexLogo&quot;);</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616048539813-60fc22f6-0d07-482c-aaae-0227b1f55206.png#align=left&display=inline&height=280&margin=%5Bobject%20Object%5D&name=image.png&originHeight=560&originWidth=916&size=53785&status=done&style=stroke&width=458" alt="image.png"></p><h3 id="getElementsByTagName"><a href="#getElementsByTagName" class="headerlink" title="getElementsByTagName"></a>getElementsByTagName</h3><ul><li>语法：document.getElementsByTagName(‘标签名’) 或者 element.getElementsByTagName(‘标签名’)</li><li>作用：根据标签名获取元素对象</li><li>参数：标签名</li><li>返回值：元素对象集合（伪数组，数组元素是元素对象）**</li></ul><pre><code class="javascript">var test_tag = document.getElementsByTagName(&quot;p&quot;);</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616048909454-bdfb7dbc-18e4-4449-abc6-800e87b42380.png#align=left&display=inline&height=442&margin=%5Bobject%20Object%5D&name=image.png&originHeight=884&originWidth=1920&size=1760479&status=done&style=stroke&width=960" alt="image.png"></p><ul><li>getElementsByTagName()获取到是动态集合，即：当页面增加了标签，这个集合中也就增加了元素。</li><li>由上面的图可以知道，得到的不是一个对象，而是一个对象集合，所以要操作具体的一个 p 就要遍历，然后再进行操作（抑或是对其当作节点再进行操作）</li></ul><h3 id="getElementsByClassName"><a href="#getElementsByClassName" class="headerlink" title="getElementsByClassName"></a>getElementsByClassName</h3><h3 id=""><a href="#" class="headerlink" title=""></a><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616049522946-8c892471-1b04-4b04-b56f-630420bdb654.png#align=left&display=inline&height=440&margin=%5Bobject%20Object%5D&name=image.png&originHeight=880&originWidth=1920&size=312821&status=done&style=stroke&width=960" alt="image.png"></h3><h3 id="querySelector"><a href="#querySelector" class="headerlink" title="querySelector"></a>querySelector</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616049685312-55929307-c68b-4e1d-b6b5-1845c0d5a878.png#align=left&display=inline&height=226&margin=%5Bobject%20Object%5D&name=image.png&originHeight=451&originWidth=1920&size=239671&status=done&style=stroke&width=960" alt="image.png"></p><h3 id="querySelectorAll"><a href="#querySelectorAll" class="headerlink" title="querySelectorAll"></a>querySelectorAll</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616049810063-ee5595dc-89bb-47cc-aa9a-c9446ed97d6f.png#align=left&display=inline&height=306&margin=%5Bobject%20Object%5D&name=image.png&originHeight=612&originWidth=1920&size=288375&status=done&style=stroke&width=960" alt="image.png"></p><ul><li>如果是选择器，需要加符号 <code>querySelectorAll(&#39;#box1&#39;)</code> **</li></ul><h3 id="获取-body-html-对象"><a href="#获取-body-html-对象" class="headerlink" title="获取 body/html 对象"></a>获取 body/html 对象</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616050005999-ac944be2-9612-41ac-89f7-9fa04c4d3912.png#align=left&display=inline&height=442&margin=%5Bobject%20Object%5D&name=image.png&originHeight=884&originWidth=1920&size=301673&status=done&style=stroke&width=960" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518355850-2e015c88-50b7-400e-9593-c7e21a9068b5.png#align=left&display=inline&height=272&margin=%5Bobject%20Object%5D&originHeight=272&originWidth=748&status=done&style=none&width=748"></p><h2 id="操作元素内容-属性"><a href="#操作元素内容-属性" class="headerlink" title="操作元素内容/属性"></a>操作元素内容/属性</h2><p>JavaScript 的 DOM 操作可以改变网页内容、结构和样式，我们可以利用 DOM 操作元素来改变元素里面的内容、属性等。（注意：这些操作都是通过元素对象的属性实现的）</p><h4 id="-1"><a href="#-1" class="headerlink" title=""></a><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518357274-e26496b9-3fdb-47de-85be-fd6aea949767.png#align=left&display=inline&height=253&margin=%5Bobject%20Object%5D&originHeight=424&originWidth=741&status=done&style=stroke&width=442"></h4><h3 id="innerText-和-innerHTML"><a href="#innerText-和-innerHTML" class="headerlink" title="innerText 和 innerHTML"></a>innerText 和 innerHTML</h3><ul><li>获取内容时的区别：innerText 会去除空格和换行，而 innerHTML 会保留空格和换行</li><li>设置内容时的区别：innerText 不会识别 html，而 innerHTML 会识别</li><li>小记：是属性，不是方法！要用赋值的形式，而不是带参数的形式</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616053295394-7fe7d51d-3ce6-4f51-9898-9e0e62b207c4.png#align=left&display=inline&height=441&margin=%5Bobject%20Object%5D&name=image.png&originHeight=881&originWidth=1920&size=1394439&status=done&style=stroke&width=960" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616053546675-78ea1659-1dee-4b43-aa1a-82aad00e1795.png#align=left&display=inline&height=440&margin=%5Bobject%20Object%5D&name=image.png&originHeight=879&originWidth=1920&size=1397046&status=done&style=stroke&width=960" alt="image.png"></p><h3 id="改变元素属性操作"><a href="#改变元素属性操作" class="headerlink" title="改变元素属性操作"></a>改变元素属性操作</h3><h3 id="-2"><a href="#-2" class="headerlink" title=""></a><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616053829361-6faff7b2-0d8f-41c6-b909-6b72ff3b5401.png#align=left&display=inline&height=352&margin=%5Bobject%20Object%5D&name=image.png&originHeight=703&originWidth=1920&size=639610&status=done&style=stroke&width=960" alt="image.png"></h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616054507713-8b717792-1d98-4477-a9e8-db7417b87f34.png#align=left&display=inline&height=440&margin=%5Bobject%20Object%5D&name=image.png&originHeight=880&originWidth=1920&size=169274&status=done&style=stroke&width=960" alt="image.png"></p><h3 id="element-style"><a href="#element-style" class="headerlink" title="element.style"></a>element.style</h3><h3 id="-3"><a href="#-3" class="headerlink" title=""></a><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616053829361-6faff7b2-0d8f-41c6-b909-6b72ff3b5401.png#align=left&display=inline&height=352&margin=%5Bobject%20Object%5D&name=image.png&originHeight=703&originWidth=1920&size=639610&status=done&style=stroke&width=960" alt="image.png"></h3><ul><li>元素对象的 style 属性也是一个对象！</li><li>元素对象.style.样式属性 = 值;</li><li>其中样式属性的命名不再是中间有-的，而是驼峰命名，eg：backgroundColor</li><li>js 修改的 style 样式操作，产生的是行内样式，css 权重较高</li></ul><h3 id="element-className"><a href="#element-className" class="headerlink" title="element.className"></a>element.className</h3><ul><li>元素对象.className = 值;</li><li>因为 class 是关键字，所有使用 className，覆盖原先的类名</li></ul><pre><code class="html">&lt;body&gt;  &lt;div class=&quot;first&quot;&gt;文本&lt;/div&gt;  &lt;script&gt;    // 1. 使用 element.style 获得修改元素样式  如果样式比较少 或者 功能简单的情况下使用    var test = document.querySelector(&quot;div&quot;);    test.onclick = function () &#123;      // 2. 我们可以通过 修改元素的className更改元素的样式 适合于样式较多或者功能复杂的情况      // 3. 如果想要保留原先的类名，我们可以这么做 多类名选择器      // this.className = &#39;change&#39;;      this.className = &quot;first change&quot;;    &#125;;  &lt;/script&gt;&lt;/body&gt;</code></pre><h2 id="自定义元素属性"><a href="#自定义元素属性" class="headerlink" title="自定义元素属性"></a>自定义元素属性</h2><h3 id="element-getAttribute"><a href="#element-getAttribute" class="headerlink" title="element.getAttribute"></a>element.getAttribute</h3><ul><li>和 element.属性不同的是，获取的是自定义属性的值，而 element.属性获取的是内置的属性</li></ul><pre><code class="html">&lt;div id=&quot;demo&quot; index=&quot;1&quot; class=&quot;nav&quot;&gt;&lt;/div&gt;&lt;script&gt;  var div = document.querySelector(&quot;div&quot;);  // 1. 获取元素的属性值  // (1) element.属性  console.log(div.id);  //(2) element.getAttribute(&#39;属性&#39;)  get得到获取 attribute 属性的意思 我们程序员自己添加的属性我们称为自定义属性 index  console.log(div.getAttribute(&quot;id&quot;));  console.log(div.getAttribute(&quot;index&quot;));&lt;/script&gt;</code></pre><h3 id="element-setAttribute"><a href="#element-setAttribute" class="headerlink" title="element.setAttribute"></a>element.setAttribute</h3><ul><li>element.setAttribute(‘属性’,’值’)；</li></ul><pre><code class="javascript">// 2. 设置元素属性值// (1) element.属性= &#39;值&#39;div.id = &quot;test&quot;;div.className = &quot;navs&quot;;// (2) element.setAttribute(&#39;属性&#39;, &#39;值&#39;);  主要针对于自定义属性div.setAttribute(&quot;index&quot;, 2);div.setAttribute(&quot;class&quot;, &quot;footer&quot;); // class 特殊  这里面写的就是</code></pre><h3 id="element-removeAttribute"><a href="#element-removeAttribute" class="headerlink" title="element.removeAttribute"></a>element.removeAttribute</h3><pre><code class="javascript">// class 不是className// 3 移除属性 removeAttribute(属性)div.removeAttribute(&quot;index&quot;);</code></pre><h3 id="Demo：tab-栏"><a href="#Demo：tab-栏" class="headerlink" title="Demo：tab 栏"></a>Demo：tab 栏</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518358239-8396b94f-cc87-4ff3-bc86-20c652a2fe8f.png#align=left&display=inline&height=272&margin=%5Bobject%20Object%5D&originHeight=272&originWidth=786&status=done&style=stroke&width=786"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518358314-a1d9f6be-a9c3-4693-8b11-eec0665df297.png#align=left&display=inline&height=290&margin=%5Bobject%20Object%5D&originHeight=290&originWidth=744&status=done&style=stroke&width=744"></p><pre><code class="html">&lt;script&gt;  // 获取元素  var tab_list = document.querySelector(&quot;.tab_list&quot;);  var lis = tab_list.querySelectorAll(&quot;li&quot;);  var items = document.querySelectorAll(&quot;.item&quot;);  // for循环，给选项卡绑定点击事件  for (var i = 0; i &lt; lis.length; i++) &#123;    // 开始给5个小li 设置索引号    lis[i].setAttribute(&quot;index&quot;, i);    lis[i].onclick = function () &#123;      // 1. 上的模块选项卡，当前这一个底色会是红色，其余不变（排他思想）      // 干掉所有人 其余的li清除 class 这个类      for (var i = 0; i &lt; lis.length; i++) &#123;        lis[i].className = &quot;&quot;;      &#125;      // 留下我自己      this.className = &quot;current&quot;;      // 2. 下面的显示内容模块      var index = this.getAttribute(&quot;index&quot;);      console.log(index);      // 干掉所有人 让其余的item 这些div 隐藏      for (var i = 0; i &lt; items.length; i++) &#123;        items[i].style.display = &quot;none&quot;;      &#125;      // 留下我自己 让对应的item 显示出来      items[index].style.display = &quot;block&quot;;    &#125;;  &#125;&lt;/script&gt;</code></pre><h3 id="element-dataset"><a href="#element-dataset" class="headerlink" title="element.dataset"></a>element.dataset</h3><p>自定义属性目的：是为了保存并使用数据。有些数据可以保存到页面中而不用保存到数据库中。<br>自定义属性获取是通过 getAttribute(‘属性’) 获取。<br>但是有些自定义属性很容易引起歧义，不容易判断是元素的内置属性还是自定义属性。<br>H5 给我们新增了自定义属性：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518358371-b2d8cb33-5750-4e13-be06-27c86768b244.png#align=left&display=inline&height=196&margin=%5Bobject%20Object%5D&originHeight=196&originWidth=705&status=done&style=stroke&width=705"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518358431-0a046321-c303-4333-9e0d-57875144f3e5.png#align=left&display=inline&height=125&margin=%5Bobject%20Object%5D&originHeight=125&originWidth=691&status=done&style=stroke&width=691"></p><pre><code class="html">&lt;div getTime=&quot;20&quot; data-index=&quot;2&quot; data-list-name=&quot;andy&quot;&gt;&lt;/div&gt;&lt;script&gt;  var div = document.querySelector(&quot;div&quot;);  // console.log(div.getTime);  console.log(div.getAttribute(&quot;getTime&quot;));  div.setAttribute(&quot;data-time&quot;, 20);  console.log(div.getAttribute(&quot;data-index&quot;));  console.log(div.getAttribute(&quot;data-list-name&quot;));  // h5新增的获取自定义属性的方法 它只能获取data-开头的  // dataset 是一个集合里面存放了所有以data开头的自定义属性  console.log(div.dataset);  console.log(div.dataset.index);  console.log(div.dataset[&quot;index&quot;]);  // 如果自定义属性里面有多个-链接的单词，我们获取的时候采取 驼峰命名法  console.log(div.dataset.listName);  console.log(div.dataset[&quot;listName&quot;]);&lt;/script&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
          <category> DOM </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>es内置对象</title>
      <link href="blog/fc3rdkwoum2b/"/>
      <url>blog/fc3rdkwoum2b/</url>
      
        <content type="html"><![CDATA[<div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">文档学习：[https://developer.mozilla.org/zh-CN/docs/Web/JavaScript](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript)</div><h2 id="内置对象体系"><a href="#内置对象体系" class="headerlink" title="内置对象体系"></a>内置对象体系</h2><ul><li><strong>Date</strong></li><li><strong>RegExp</strong></li><li><strong>Array</strong>、定型数组</li><li>在代码执行就已经存在的：global、Math</li><li>三个基本类型的包装：Boolean、Number、String</li><li>ES6 增强的集合对象：Map、WeakMap、Set、WeakSet</li></ul><h2 id="相关零碎知识记录"><a href="#相关零碎知识记录" class="headerlink" title="相关零碎知识记录"></a>相关零碎知识记录</h2><p>数组和对象可以赋值解构，</p><hr><p>剩余参数是以数组的形式存在的</p><hr><h2 id="Array-的扩展方法（★★）"><a href="#Array-的扩展方法（★★）" class="headerlink" title="Array 的扩展方法（★★）"></a>Array 的扩展方法（★★）</h2><h4 id="扩展运算符（展开语法）"><a href="#扩展运算符（展开语法）" class="headerlink" title="扩展运算符（展开语法）"></a>扩展运算符（展开语法）</h4><p>扩展运算符可以将数组或者对象转为用逗号分隔的参数序列</p><pre><code class="javascript">let ary = [1, 2, 3]; ...ary  // 1, 2, 3 console.log(...ary);    // 1 2 3,相当于下面的代码 console.log(1,2,3);</code></pre><h5 id="扩展运算符可以应用于合并数组"><a href="#扩展运算符可以应用于合并数组" class="headerlink" title="扩展运算符可以应用于合并数组"></a>扩展运算符可以应用于合并数组</h5><pre><code class="javascript">// 方法一let ary1 = [1, 2, 3];let ary2 = [3, 4, 5];let ary3 = [...ary1, ...ary2];// 方法二ary1.push(...ary2);</code></pre><h5 id="将类数组或可遍历对象转换为真正的数组"><a href="#将类数组或可遍历对象转换为真正的数组" class="headerlink" title="将类数组或可遍历对象转换为真正的数组"></a>将类数组或可遍历对象转换为真正的数组</h5><pre><code class="javascript">let oDivs = document.getElementsByTagName(&quot;div&quot;);oDivs = [...oDivs];</code></pre><h4 id="构造函数方法：Array-from"><a href="#构造函数方法：Array-from" class="headerlink" title="构造函数方法：Array.from()"></a>构造函数方法：Array.from()</h4><p>将伪数组或可遍历对象转换为真正的数组</p><pre><code class="javascript">//定义一个集合let arrayLike = &#123;  0: &quot;a&quot;,  1: &quot;b&quot;,  2: &quot;c&quot;,  length: 3,&#125;;//转成数组let arr2 = Array.from(arrayLike); // [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]</code></pre><p>方法还可以接受第二个参数，作用类似于数组的 map 方法，用来对每个元素进行处理，将处理后的值放入返回的数组</p><pre><code class="javascript">let arrayLike = &#123;  0: 1,  1: 2,  length: 2,&#125;;let newAry = Array.from(arrayLike, (item) =&gt; item * 2); //[2,4]</code></pre><p>注意：如果是对象，那么属性需要写对应的索引</p><h4 id="实例方法：find"><a href="#实例方法：find" class="headerlink" title="实例方法：find()"></a>实例方法：find()</h4><p>用于找出第一个符合条件的数组成员，如果没有找到返回 undefined</p><pre><code class="javascript">let ary = [  &#123;    id: 1,    name: &quot;张三&quot;,  &#125;,  &#123;    id: 2,    name: &quot;李四&quot;,  &#125;,];let target = ary.find((item, index) =&gt; item.id == 2); //找数组里面符合条件的值，当数组中元素id等于2的查找出来，注意，只会匹配第一个</code></pre><h4 id="实例方法：findIndex"><a href="#实例方法：findIndex" class="headerlink" title="实例方法：findIndex()"></a>实例方法：findIndex()</h4><p>用于找出第一个符合条件的数组成员的位置，如果没有找到返回-1</p><pre><code class="javascript">let ary = [1, 5, 10, 15];let index = ary.findIndex((value, index) =&gt; value &gt; 9);console.log(index); // 2</code></pre><h4 id="实例方法：includes"><a href="#实例方法：includes" class="headerlink" title="实例方法：includes()"></a>实例方法：includes()</h4><p>判断某个数组是否包含给定的值，返回布尔值。</p><pre><code class="javascript">[1, 2, 3]  .includes(2) // true  [(1, 2, 3)].includes(4); // false</code></pre><h2 id="String-的扩展方法"><a href="#String-的扩展方法" class="headerlink" title="String 的扩展方法"></a>String 的扩展方法</h2><h4 id="模板字符串（★★★）"><a href="#模板字符串（★★★）" class="headerlink" title="模板字符串（★★★）"></a>模板字符串（★★★）</h4><p>ES6 新增的创建字符串的方式，使用反引号定义</p><pre><code class="javascript">let name = `zhangsan`;</code></pre><h5 id="模板字符串中可以解析变量"><a href="#模板字符串中可以解析变量" class="headerlink" title="模板字符串中可以解析变量"></a>模板字符串中可以解析变量</h5><pre><code class="javascript">let name = &quot;张三&quot;;let sayHello = `hello,my name is $&#123;name&#125;`; // hello, my name is zhangsan</code></pre><h5 id="模板字符串中可以换行"><a href="#模板字符串中可以换行" class="headerlink" title="模板字符串中可以换行"></a>模板字符串中可以换行</h5><pre><code class="javascript">let result = &#123;  name: &quot;zhangsan&quot;,  age: 20,  sex: &quot;男&quot;,&#125;;let html = ` &lt;div&gt;     &lt;span&gt;$&#123;result.name&#125;&lt;/span&gt;     &lt;span&gt;$&#123;result.age&#125;&lt;/span&gt;     &lt;span&gt;$&#123;result.sex&#125;&lt;/span&gt; &lt;/div&gt; `;</code></pre><h5 id="在模板字符串中可以调用函数"><a href="#在模板字符串中可以调用函数" class="headerlink" title="在模板字符串中可以调用函数"></a>在模板字符串中可以调用函数</h5><pre><code class="javascript">const sayHello = function () &#123;  return &quot;哈哈哈哈 追不到我吧 我就是这么强大&quot;;&#125;;let greet = `$&#123;sayHello()&#125; 哈哈哈哈`;console.log(greet); // 哈哈哈哈 追不到我吧 我就是这么强大 哈哈哈哈</code></pre><h4 id="实例方法：startsWith-和-endsWith"><a href="#实例方法：startsWith-和-endsWith" class="headerlink" title="实例方法：startsWith() 和 endsWith()"></a>实例方法：startsWith() 和 endsWith()</h4><ul><li>startsWith()：表示参数字符串是否在原字符串的头部，返回布尔值</li><li>endsWith()：表示参数字符串是否在原字符串的尾部，返回布尔值</li></ul><pre><code class="javascript">let str = &quot;Hello world!&quot;;str.startsWith(&quot;Hello&quot;); // truestr.endsWith(&quot;!&quot;); // true</code></pre><h4 id="实例方法：repeat"><a href="#实例方法：repeat" class="headerlink" title="实例方法：repeat()"></a>实例方法：repeat()</h4><p>repeat 方法表示将原字符串重复 n 次，返回一个新字符串</p><pre><code class="javascript">&quot;x&quot;.repeat(3); // &quot;xxx&quot;&quot;hello&quot;.repeat(2); // &quot;hellohello&quot;</code></pre><h2 id="Set-数据结构（★★）"><a href="#Set-数据结构（★★）" class="headerlink" title="Set 数据结构（★★）"></a>Set 数据结构（★★）</h2><p>ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。<br>Set 本身是一个构造函数，用来生成 Set 数据结构</p><pre><code class="javascript">const s = new Set();</code></pre><p>Set 函数可以接受一个数组作为参数，用来初始化。</p><pre><code class="javascript">const set = new Set([1, 2, 3, 4, 4]); //&#123;1, 2, 3, 4&#125;</code></pre><h4 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h4><ul><li>add(value)：添加某个值，返回 Set 结构本身</li><li>delete(value)：删除某个值，返回一个布尔值，表示删除是否成功</li><li>has(value)：返回一个布尔值，表示该值是否为 Set 的成员</li><li>clear()：清除所有成员，没有返回值</li></ul><pre><code class="javascript">const s = new Set();s.add(1).add(2).add(3); // 向 set 结构中添加值s.delete(2); // 删除 set 结构中的2值s.has(1); // 表示 set 结构中是否有1这个值 返回布尔值s.clear(); // 清除 set 结构中的所有值//注意：删除的是元素的值，不是代表的索引</code></pre><h4 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h4><p>Set 结构的实例与数组一样，也拥有 forEach 方法，用于对每个成员执行某种操作，没有返回值。</p><pre><code class="javascript">s.forEach((value) =&gt; console.log(value));</code></pre>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
          <category> ECMAScript </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Shadowsocks使用总结</title>
      <link href="blog/qt0mw3de2tcn/"/>
      <url>blog/qt0mw3de2tcn/</url>
      
        <content type="html"><![CDATA[<p>这是加密文章！</p>]]></content>
      
      
      <categories>
          
          <category> ComputerNetwork </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>es基本语法</title>
      <link href="blog/uz1d072engtt/"/>
      <url>blog/uz1d072engtt/</url>
      
        <content type="html"><![CDATA[<h2 id="知识架构"><a href="#知识架构" class="headerlink" title="知识架构"></a>知识架构</h2><h3 id="第一大类：ECMAScript"><a href="#第一大类：ECMAScript" class="headerlink" title="第一大类：ECMAScript"></a>第一大类：ECMAScript</h3><ul><li><p><input checked="" disabled="" type="checkbox">  基本语法</p><ul><li>【补充】JavaScript 语言介绍</li><li>变量</li><li>基本数据类型</li><li>运算符和表达式</li><li>流程控制语句</li></ul></li><li><p><input checked="" disabled="" type="checkbox">  函数</p><ul><li>常规基础知识</li><li>闭包</li><li>JavaScript 运行机制（单线程，异步任务机制……）</li></ul></li><li><p><input checked="" disabled="" type="checkbox">  引用</p><blockquote><p>文档学习：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript</a></p></blockquote><ul><li>基本引用类型：Date、RegExp、原始包装、Global、Math 等</li><li>集合引用类型：Object、Array、Map、WeakMap、Set、WeakSet</li></ul></li><li><p><input checked="" disabled="" type="checkbox">  面向对象</p><ul><li>体系一：原型</li><li>体系二：类【ES6 后出来的】</li><li>关于对象的创建和内置方法</li></ul></li></ul><hr><ul><li><input disabled="" type="checkbox"> 迭代器和生成器</li><li><input disabled="" type="checkbox"> 代理和反射</li><li><input disabled="" type="checkbox"> canvas 技术</li><li><input disabled="" type="checkbox"> 表单脚本</li><li><input disabled="" type="checkbox"> JavaScript API</li><li><input disabled="" type="checkbox"> 错误处理和调试</li><li><input disabled="" type="checkbox"> 处理 XML</li><li><input disabled="" type="checkbox"> JSON 技术</li><li><input disabled="" type="checkbox"> 网络请求和远程资源</li><li><input disabled="" type="checkbox"> 模块化</li><li><input disabled="" type="checkbox"> 工作者线程</li><li><input disabled="" type="checkbox"> 最佳实践</li><li><input checked="" disabled="" type="checkbox"> 严格模式</li></ul><h3 id="第二大类：DOM"><a href="#第二大类：DOM" class="headerlink" title="第二大类：DOM"></a>第二大类：DOM</h3><ul><li><input checked="" disabled="" type="checkbox"> 一些对结点的基本操作<ul><li>元素获取</li><li>属性操作</li></ul></li><li><input checked="" disabled="" type="checkbox"> 事件</li></ul><h3 id="第三大类：BOM"><a href="#第三大类：BOM" class="headerlink" title="第三大类：BOM"></a>第三大类：BOM</h3><ul><li><input checked="" disabled="" type="checkbox"> 常用对象</li><li><input disabled="" type="checkbox"> window 对象</li><li><input disabled="" type="checkbox"> location 对象</li><li><input disabled="" type="checkbox"> navigator 对象</li><li><input disabled="" type="checkbox"> screen 对象</li><li><input disabled="" type="checkbox"> history 对象</li><li><input disabled="" type="checkbox"> 客户端检测</li><li><input checked="" disabled="" type="checkbox"> 客户端存储</li></ul><h2 id="JavaScript-编程语言"><a href="#JavaScript-编程语言" class="headerlink" title="JavaScript 编程语言"></a>JavaScript 编程语言</h2><h3 id="解释型语言和编译型语言"><a href="#解释型语言和编译型语言" class="headerlink" title="解释型语言和编译型语言"></a>解释型语言和编译型语言</h3><p>计算机不能直接理解任何除机器语言以外的语言，所以必须要把程序员所写的程序语言翻译成机器语言才能执行程序。程序语言翻译成机器语言的工具，被称为翻译器。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611883945965-edfd63f6-b312-4daa-990e-aa7fb8d29640.png#align=left&display=inline&height=82&margin=%5Bobject%20Object%5D&name=image.png&originHeight=163&originWidth=614&size=25533&status=done&style=none&width=307" alt="image.png"></p><ul><li>翻译器翻译的方式有两种：一个是编译，另外一个是解释。两种方式之间的区别在于翻译的时间点不同</li><li>编译器是在代码执行之前进行编译，生成中间代码文件</li><li>解释器是在运行时进行及时解释，并立即执行(当编译器以解释方式运行的时候，也称之为解释器)<blockquote><p>执行过程</p></blockquote></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611883933551-3185c915-4a31-4151-a6c6-9212e11d336c.png#align=left&display=inline&height=246&margin=%5Bobject%20Object%5D&name=image.png&originHeight=492&originWidth=825&size=122185&status=done&style=none&width=412.5" alt="image.png"></p><h3 id="JavaScript-是什么"><a href="#JavaScript-是什么" class="headerlink" title="JavaScript 是什么"></a>JavaScript 是什么</h3><ul><li><p>JavaScript 是世界上最流行的语言之一，是一种运行在客户端的脚本语言 （Script == 脚本）</p></li><li><p>脚本语言：不需要编译，运行过程中由 js 解释器( js 引擎）逐行来进行解释并执行</p></li><li><p>现在也可以基于 Node.js 技术进行服务器端编程</p></li></ul><h3 id="JavaScript-的作用"><a href="#JavaScript-的作用" class="headerlink" title="JavaScript 的作用"></a>JavaScript 的作用</h3><ul><li>表单动态校验（密码强度检测） （ JS 产生最初的目的 ）</li><li>网页特效</li><li>服务端开发(Node.js)</li><li>桌面程序(Electron)</li><li>App(Cordova)</li><li>控制硬件-物联网(Ruff)</li><li>游戏开发(cocos2d-js)</li></ul><h3 id="浏览器执行-JS-简介"><a href="#浏览器执行-JS-简介" class="headerlink" title="浏览器执行 JS 简介"></a>浏览器执行 JS 简介</h3><p><strong>浏览器分成两部分：渲染引擎和 JS 引擎</strong><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611883433929-789dc835-fd39-43fb-8212-9580ee9e69a6.png#align=left&display=inline&height=132&margin=%5Bobject%20Object%5D&name=image.png&originHeight=263&originWidth=839&size=73081&status=done&style=stroke&width=419.5" alt="image.png"></p><pre><code>浏览器本身并不会执行JS代码，而是通过内置 JavaScript 引擎(解释器) 来执行 JS 代码 。JS 引擎执行代码时逐行解释每一句源码（转换为机器语言），然后由计算机去执行，所以 JavaScript 语言归为脚本语言，会逐行解释执行。</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611883443893-9e920247-6cbf-4713-85cb-c76eeb34013c.png#align=left&display=inline&height=149&margin=%5Bobject%20Object%5D&name=image.png&originHeight=297&originWidth=816&size=53400&status=done&style=stroke&width=408" alt="image.png"></p><h3 id="JavaScript-的组成"><a href="#JavaScript-的组成" class="headerlink" title="JavaScript 的组成"></a>JavaScript 的组成</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611883453712-2dfb6f14-cf77-4475-ad87-5826124bc43f.png#align=left&display=inline&height=189&margin=%5Bobject%20Object%5D&name=image.png&originHeight=378&originWidth=825&size=47608&status=done&style=stroke&width=412.5" alt="image.png"></p><ol><li><p><strong>ECMAScript</strong><br>        ECMAScript 是由 ECMA 国际（ 原欧洲计算机制造商协会）进行标准化的一门编程语言，这种语言在万维网上应用广泛，它往往被称为 JavaScript 或 JScript，但实际上后两者是 ECMAScript 语言的实现和扩展。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611883470657-6e9bb00b-781e-46d3-99e7-64afd35e3758.png#align=left&display=inline&height=138&margin=%5Bobject%20Object%5D&name=image.png&originHeight=276&originWidth=841&size=27667&status=done&style=stroke&width=420.5" alt="image.png"><br>ECMAScript：规定了 JS 的编程语法和基础核心知识，是所有浏览器厂商共同遵守的一套 JS 语法工业标准。<br>更多参看 MDN: <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/JavaScript_technologies_overview">MDN 手册</a></p></li><li><p><strong>DOM——文档对象模型</strong><br><strong>文档对象模型</strong>（DocumentObject Model，简称 DOM），是 W3C 组织推荐的处理可扩展标记语言的标准编程接口。通过 DOM 提供的接口可以对页面上的各种元素进行操作（大小、位置、颜色等）</p></li><li><p><strong>BOM——浏览器对象模型</strong><br><strong>浏览器对象模型</strong>(Browser Object Model，简称 BOM) 是指浏览器对象模型，它提供了独立于内容的、可以与浏览器窗口进行互动的对象结构。通过 BOM 可以操作浏览器窗口，比如弹出框、控制浏览器跳转、获取分辨率等。</p></li></ol><h3 id="JavaScript-初体验"><a href="#JavaScript-初体验" class="headerlink" title="JavaScript 初体验"></a>JavaScript 初体验</h3><pre><code>JS 有3种书写位置，分别为行内、内嵌和外部。</code></pre><ol><li>行内式</li></ol><pre><code class="html">&lt;input type=&quot;button&quot; value=&quot;点我试试&quot; onclick=&quot;alert(&#39;Hello World&#39;)&quot; /&gt;</code></pre><ul><li>可以将单行或少量 JS 代码写在 HTML 标签的事件属性中（以 on 开头的属性），如：onclick</li><li>注意单双引号的使用：在 HTML 中我们推荐使用双引号, JS 中我们推荐使用单引号</li><li>可读性差， 在 html 中编写 JS 大量代码时，不方便阅读；</li><li>引号易错，引号多层嵌套匹配时，非常容易弄混；</li><li>特殊情况下使用</li></ul><ol start="2"><li>内嵌式</li></ol><pre><code class="html">&lt;script&gt;  alert(&quot;Hello  World~!&quot;);&lt;/script&gt;</code></pre><ul><li>可以将多行 JS 代码写到 script 标签中</li><li>内嵌 JS 是学习时常用的方式</li></ul><ol start="2"><li>外部 JS 文件</li></ol><pre><code class="html">&lt;script src=&quot;my.js&quot;&gt;&lt;/script&gt;</code></pre><ul><li>利于 HTML 页面代码结构化，把大段 JS 代码独立到 HTML 页面之外，既美观，也方便文件级别的复用</li><li>引用外部 JS 文件的 script 标签中间不可以写代码</li><li>适合于 JS 代码量比较大的情况</li></ul><h3 id="JavaScript-输入输出"><a href="#JavaScript-输入输出" class="headerlink" title="JavaScript 输入输出"></a>JavaScript 输入输出</h3><blockquote><p>调试有两种，一种是 debug，一种是 print 大法，js 输入输出依靠浏览器来“可视化”输入输出</p></blockquote><ul><li>prompt：可以输入</li><li>alert：输出</li><li>console.log()：输出</li></ul><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>JavaScript 里面的变量使用可谓是一言难尽，用<em>《JavaScript 高级程序设计》</em>书里面说的就是：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1617866042752-0faeefea-8db4-4432-b4ce-afe96f10375a.png#align=left&display=inline&height=19&margin=%5Bobject%20Object%5D&name=image.png&originHeight=38&originWidth=332&size=8076&status=done&style=none&width=166" alt="image.png">，总结一下变量一些重点知识。</p><h3 id="var-和-let-和-const"><a href="#var-和-let-和-const" class="headerlink" title="var 和 let 和 const"></a>var 和 let 和 const</h3><p><strong>【1】var</strong></p><ul><li>在全局区域声明是全局变量</li><li>在<strong>函数里面</strong>用 var 声明变量的时候是局部变量，但是省略 var 的时候，就变成全局变量了（坑……），好在严格模式下如果在函数里面这样定义会报错</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1617867733497-db043164-d28e-48e8-8bd7-2a9b1d30203a.png#align=left&display=inline&height=63&margin=%5Bobject%20Object%5D&name=image.png&originHeight=126&originWidth=789&size=36005&status=done&style=none&width=394.5" alt="image.png"></p><ul><li>会变量提升，把所有变量声明都拉到函数作用域的顶部，所以在同一个域里面，var 定义的变量，先使用在定义也是可以的。</li><li>可以多次定义赋值<blockquote><p>var i = 0;<br>var i = 0;</p></blockquote></li></ul><p><strong>【2】let</strong></p><ul><li>作用范围：块作用域</li><li>会有冗余声明（不可以多次定义赋值）</li><li>不会变量提升，俗称“暂时性死区”</li></ul><p><strong>【3】const</strong></p><ul><li>作用范围：块作用域</li><li><strong>声明变量必须同时初始化变量</strong></li><li>尝试修改变量的值报错</li><li>不允许重复声明</li><li>但对对象操作就不一样了</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1617866749694-8c13df91-894d-41ba-a6bf-4545875594be.png#align=left&display=inline&height=39&margin=%5Bobject%20Object%5D&name=image.png&originHeight=78&originWidth=900&size=29349&status=done&style=none&width=450" alt="image.png"></p><h3 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h3><p>因为 var 可以多次声明这一个特点，就产生出了一个问题，在函数里面声明一个变量，在函数外也声明一个同名的变量，就会导致接下来的代码使用哪一个变量的情况。分析是哪个其实也好办，就是看调用的这个函数离哪个声明的变量最近，哪个最近取哪个。</p><p><strong>作用域链有其解决的办法，那就是利用作用域链，但是使用 let 和 const 更为方便</strong>。</p><p>比如：循环迭代过程中<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1617867856859-e30d58a7-ff23-4c94-9690-fa18931b1274.png#align=left&display=inline&height=133&margin=%5Bobject%20Object%5D&name=image.png&originHeight=265&originWidth=930&size=74043&status=done&style=none&width=465" alt="image.png"></p><h3 id="预解析和代码执行"><a href="#预解析和代码执行" class="headerlink" title="预解析和代码执行"></a>预解析和代码执行</h3><p>浏览器的 js 解析器当中，会将 js 代码分两步执行，分别为，预解析和执行代码</p><ul><li>预解析：在当前作用域下, JS 代码执行之前，浏览器会默认把带有 var 和 function 声明的变量在内存中进行提前声明或者定义</li><li>代码执行： 从上到下执行 JS 语句</li></ul><h3 id="使用风格"><a href="#使用风格" class="headerlink" title="使用风格"></a>使用风格</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1617866793247-8f59e0d0-c674-4bbb-927d-c0def061ef4b.png#align=left&display=inline&height=143&margin=%5Bobject%20Object%5D&name=image.png&originHeight=285&originWidth=906&size=116098&status=done&style=none&width=453" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1617866805218-d141595e-4964-4c77-8b8a-e0396af6ecc9.png#align=left&display=inline&height=40&margin=%5Bobject%20Object%5D&name=image.png&originHeight=79&originWidth=896&size=25485&status=done&style=none&width=448" alt="image.png"></p><h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><h3 id="JavaScript-和-java-比较"><a href="#JavaScript-和-java-比较" class="headerlink" title="JavaScript 和 java 比较"></a>JavaScript 和 java 比较</h3><ul><li>JAVA 有八种基本数据类型（byte、short、int、long、float、double、string、boolean）</li><li>JavaScript 有六种基本类型（值类型）（Number、String、Boolean、Undefined、Null、Symbol（es6））<blockquote><p>注：Symbol 是 ES6 引入了一种新的原始数据类型，表示独一无二的值。</p></blockquote></li></ul><p><strong>在 java 中除了以上八种，其他都是以对象 Object（或者说类的实例）存在的，JavaScript 也一样！</strong><br>**<br>【在 Java.lang 里面有上述八种包装类，在 JavaScript 里面也有相应的概念称之为——包装对象】</p><h3 id="自动确定类型机制"><a href="#自动确定类型机制" class="headerlink" title="自动确定类型机制"></a>自动确定类型机制</h3><p>JavaScript 是一种弱类型或者说动态语言。这意味着不用提前声明变量的类型，在程序运行过程中，类型会被自动确定，这是和 Java 基本类型不同的一点。</p><pre><code class="javascript">var age = 10; // 这是一个数字型var forsome = &quot;是的&quot;; // 这是一个字符串</code></pre><p>在代码运行时，变量的数据类型是由 <strong>JS 引擎</strong> 根据 = 右边变量值的数据类型来判断 的，运行完毕之后， 变量就确定了数据类型。<strong>JavaScript 拥有动态类型，同时也意味着相同的变量可用作不同的类型</strong></p><h3 id="number"><a href="#number" class="headerlink" title="number"></a>number</h3><p>JavaScript 数字类型既可以保存整数，也可以保存小数(浮点数）。</p><table><thead><tr><th>Number.MAX_VALUE</th><th>最大值</th></tr></thead><tbody><tr><td>Number.MIN_VALUE</td><td>最小值</td></tr><tr><td>Infinity</td><td>正无穷大</td></tr><tr><td>-Infinity</td><td>负无穷大</td></tr><tr><td>NaN</td><td>非数值</td></tr></tbody></table><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1617862223224-4f56c586-004a-476a-b000-b6ab21d9d76f.png#align=left&display=inline&height=33&margin=%5Bobject%20Object%5D&name=image.png&originHeight=66&originWidth=535&size=5962&status=done&style=none&width=267.5" alt="image.png"><br>isNaN()：用来判断一个变量是否为非数字的类型，返回 true 或者 false<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1617862345109-761be59e-466e-4e76-ae90-de038b1eb668.png#align=left&display=inline&height=76&margin=%5Bobject%20Object%5D&name=image.png&originHeight=151&originWidth=329&size=16886&status=done&style=none&width=164.5" alt="image.png"></p><h3 id="string"><a href="#string" class="headerlink" title="string"></a>string</h3><ul><li>转义符：和 java 一样</li></ul><table><thead><tr><th>转义符</th><th>解释说明</th></tr></thead><tbody><tr><td>\n</td><td>换行符，n 是 newline 的意思</td></tr><tr><td>\ \</td><td>斜杠 \</td></tr><tr><td>‘</td><td>‘ 单引号</td></tr><tr><td>“</td><td>”双引号</td></tr><tr><td>\t</td><td>tab 缩进</td></tr><tr><td>\b</td><td>空格 ，b 是 blank 的意思</td></tr></tbody></table><ul><li>字符串长度：通过字符串的 length 属性可以获取整个字符串的长度。</li></ul><pre><code>var strMsg = &quot;一串文字&quot;;alert(strMsg.length); // 显示 4</code></pre><div style="background: #FFF3F3;padding:10px;border: 1px solid #DEB8BE;border-radius:5px;margin-bottom:5px;">Java里面基本数据类型比如定义了一串字符，是没有相应长度length属性一说的，除非new一个字符的对象。JavaScript里面也有相应的机制，称之为——**“包装对象”**，可以直接使用length属性，指的是与数值、字符串、布尔值分别相对应的Number、String、Boolean三个原生对象。这三个原生对象可以把原始类型的值变成（包装成）对象，和Java里面一样。</div><ul><li>字符串拼接：和 java 一样，用一个+号就好了</li></ul><h3 id="boolean"><a href="#boolean" class="headerlink" title="boolean"></a>boolean</h3><p>布尔类型有两个值：true 和 false ，其中 true 表示真（对），而 false 表示假（错）。<br>布尔型和数字型相加的时候， true 的值为 1 ，false 的值为 0。</p><pre><code class="js">console.log(true + 1); // 2console.log(false + 1); // 1</code></pre><h3 id="undefined"><a href="#undefined" class="headerlink" title="undefined"></a>undefined</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1617863116062-5457a96b-062e-4262-a093-ea6e30c005cb.png#align=left&display=inline&height=227&margin=%5Bobject%20Object%5D&name=image.png&originHeight=454&originWidth=1012&size=39117&status=done&style=stroke&width=506" alt="image.png"></p><h3 id="null"><a href="#null" class="headerlink" title="null"></a>null</h3><ul><li>参考教程：<a href="https://javascript.ruanyifeng.com/grammar/types.html#toc2">https://javascript.ruanyifeng.com/grammar/types.html#toc2</a></li></ul><h3 id="symbol"><a href="#symbol" class="headerlink" title="symbol"></a>symbol</h3><h3 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h3><p>typeof 可用来获取检测变量的数据类型<br>使用表单、prompt 获取过来的数据默认是字符串类型的，此时就不能直接简单的进行加法运算，而需要转换变量的数据类型</p><div style="background: #FFFBE6;padding:10px;border: 1px solid #C3C3C3;border-radius:5px;margin-bottom:5px;">转换为字符串</div>![image.png](https://cdn.nlark.com/yuque/0/2021/png/1484158/1611884006311-4cc74b07-40ae-4551-a5ee-123ed7b531d7.png#align=left&display=inline&height=115&margin=%5Bobject%20Object%5D&name=image.png&originHeight=172&originWidth=777&size=60609&status=done&style=stroke&width=518)<div style="background: #FFFBE6;padding:10px;border: 1px solid #C3C3C3;border-radius:5px;margin-bottom:5px;">转换为数字型</div>![image.png](https://cdn.nlark.com/yuque/0/2021/png/1484158/1611883972878-dc6e6b6f-2647-4c90-964e-4a12a8cd271d.png#align=left&display=inline&height=133&margin=%5Bobject%20Object%5D&name=image.png&originHeight=200&originWidth=771&size=80709&status=done&style=stroke&width=512)<div style="background: #FFFBE6;padding:10px;border: 1px solid #C3C3C3;border-radius:5px;margin-bottom:5px;">转换为布尔型</div>![image.png](https://cdn.nlark.com/yuque/0/2021/png/1484158/1611883959498-4386a41d-d371-4d23-b461-f6af72de9475.png#align=left&display=inline&height=68&margin=%5Bobject%20Object%5D&name=image.png&originHeight=101&originWidth=774&size=21014&status=done&style=stroke&width=520)> 当参数为： ''、0、NaN、null、undefined，转换为false，其他都转换称true<h2 id="运算符和表达式"><a href="#运算符和表达式" class="headerlink" title="运算符和表达式"></a>运算符和表达式</h2><blockquote><p>几乎和 java 里面一样，但是有一些不同</p></blockquote><h3 id="基本"><a href="#基本" class="headerlink" title="基本"></a>基本</h3><ul><li>+-*/%</li><li>i++和++i 区别</li><li>==和===区别就是后者要求值和数据类型都相等，前者只要求值</li><li>&amp;&amp;与||或!非</li></ul><h3 id="逻辑与和逻辑或"><a href="#逻辑与和逻辑或" class="headerlink" title="逻辑与和逻辑或"></a>逻辑与和逻辑或</h3><ul><li>逻辑与</li></ul><pre><code class="javascript">console.log(123 &amp;&amp; 456); // 456console.log(0 &amp;&amp; 456); // 0console.log(123 &amp;&amp; 456 &amp;&amp; 789); // 789</code></pre><ul><li>逻辑或</li></ul><pre><code class="javascript">console.log(123 || 456); //  123console.log(0 || 456); //  456console.log(123 || 456 || 789); //  123</code></pre><h2 id="程序三大基本结构"><a href="#程序三大基本结构" class="headerlink" title="程序三大基本结构"></a>程序三大基本结构</h2><h3 id="顺序结构"><a href="#顺序结构" class="headerlink" title="顺序结构"></a>顺序结构</h3><p>浏览器引擎对 js 代码是从上往下依次执行的！所以 js 代码的位置，以及代码与代码相互依赖的关系顺序都要注意。</p><h3 id="选择结构"><a href="#选择结构" class="headerlink" title="选择结构"></a>选择结构</h3><p>和 Java 一样，都有 if 语句、switch 语句、三元条件表达式</p><pre><code class="javascript">switch (表达式) &#123;  case value1:    // 表达式 等于 value1 时要执行的代码    break;  case value2:    // 表达式 等于 value2 时要执行的代码    break;  default:  // 表达式 不等于任何一个 value 时要执行的代码&#125;</code></pre><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Conditional_Operator">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Conditional_Operator</a></li></ul><h3 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h3><p>和 Java 一样都有，都有 for(){}、while(){}、do{}while()三种结构，以及 continue、break 两个关键字，用法完全一样，在 java 里面有增强的 for 循环一说，js 也有相应的增强的 for 循环。</p><p>for-in 语句<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1622620171596-8dc93211-66d7-4bff-aa7a-f0a1f25fef6b.png#align=left&display=inline&height=169&margin=%5Bobject%20Object%5D&name=image.png&originHeight=337&originWidth=1072&size=122831&status=done&style=none&width=536" alt="image.png"><br>for-of 语句<br>遍历可迭代对象的元素</p>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
          <category> ECMAScript </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>英语写作</title>
      <link href="blog/skg9onyu1w1p/"/>
      <url>blog/skg9onyu1w1p/</url>
      
        <content type="html"><![CDATA[<p>这是加密文章！</p>]]></content>
      
      
      <categories>
          
          <category> Language </category>
          
          <category> English </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CSS定位</title>
      <link href="blog/qfka5bkr6swg/"/>
      <url>blog/qfka5bkr6swg/</url>
      
        <content type="html"><![CDATA[<h2 id="CSS-布局的三种机制"><a href="#CSS-布局的三种机制" class="headerlink" title="CSS 布局的三种机制"></a>CSS 布局的三种机制</h2><blockquote><p>网页布局的核心 —— 就是<strong>用 CSS 来摆放盒子位置</strong>。<br>CSS 提供了 &gt; <strong>3 种机制</strong>来设置盒子的摆放位置，分别是&gt; <strong>普通流</strong>、&gt; <strong>浮动</strong>和&gt; <strong>定位</strong></p></blockquote><blockquote><p><strong>【1】普通流</strong>（<strong>标准流</strong>）</p></blockquote><p>可以让盒子上下排列或者左右排列的</p><ul><li><p><strong>块级元素</strong>会独占一行，<strong>从上向下</strong>顺序排列；</p><ul><li>常用元素：div、hr、p、h1~h6、ul、ol、dl、form、table</li></ul></li><li><p><strong>行内元素</strong>会按照顺序，<strong>从左到右</strong>顺序排列，碰到父元素边缘则自动换行；</p><ul><li>常用元素：span、a、i、em 等<blockquote><p><strong>【2】浮动</strong></p></blockquote></li></ul></li><li><p>让盒子从普通流中<strong>浮</strong>起来 —— <strong>让多个盒子(div)水平排列成一行</strong>。</p></li><li><p>可以让多个块级元素一行显示 或者 左右对齐盒子 浮动的盒子就是按照顺序左右排列</p><blockquote><p><strong>【3】定位</strong></p></blockquote></li><li><p>将盒子<strong>定</strong>在某一个<strong>位</strong>置 自由的漂浮在其他盒子的上面 —— CSS 离不开定位，特别是后面的 js 特效。</p></li><li><p>定位最大的特点是有层叠的概念，就是可以让多个盒子 前后 叠压来显示。 但是每个盒子需要测量数值。</p><blockquote><p><strong>【结论】</strong></p><ul><li>标准流在最底层</li><li>浮动的盒子在中间层</li><li>定位的盒子在最上层</li></ul></blockquote></li></ul><h2 id="定位详解"><a href="#定位详解" class="headerlink" title="定位详解"></a>定位详解</h2><p>定位也是用来布局的，它有两部分组成：</p><blockquote><p><code>定位 = 定位模式 + 边偏移</code></p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611552456483-b258a0b4-d5e2-43ab-af99-f6eef921bacb.png#align=left&display=inline&height=182&margin=%5Bobject%20Object%5D&name=image.png&originHeight=364&originWidth=602&size=24287&status=done&style=stroke&width=301" alt="image.png"></p><h3 id="边偏移"><a href="#边偏移" class="headerlink" title="边偏移"></a>边偏移</h3><p>简单说， 我们定位的盒子，是通过边偏移来移动位置的。<br>在 CSS 中，通过 <code>top</code>、<code>bottom</code>、<code>left</code> 和 <code>right</code> 属性定义元素的<strong>边偏移</strong>：（方位名词）</p><table><thead><tr><th>边偏移属性</th><th align="left">示例</th><th>描述</th></tr></thead><tbody><tr><td><code>top</code></td><td align="left"><code>top: 80px</code></td><td><strong>顶端</strong>偏移量，定义元素相对于其父元素<strong>上边线的距离</strong>。</td></tr><tr><td><code>bottom</code></td><td align="left"><code>bottom: 80px</code></td><td><strong>底部</strong>偏移量，定义元素相对于其父元素<strong>下边线的距离</strong>。</td></tr><tr><td><code>left</code></td><td align="left"><code>left: 80px</code></td><td><strong>左侧</strong>偏移量，定义元素相对于其父元素<strong>左边线的距离</strong>。</td></tr><tr><td><code>right</code></td><td align="left"><code>right: 80px</code></td><td><strong>右侧</strong>偏移量，定义元素相对于其父元素<strong>右边线的距离</strong></td></tr></tbody></table><p>定位的盒子有了边偏移才有价值。 一般情况下，凡是有定位地方必定有边偏移。</p><h3 id="static"><a href="#static" class="headerlink" title="static"></a>static</h3><ul><li><strong>静态定位</strong>是元素的默认定位方式，无定位的意思。它相当于 border 里面的 none， 不要定位的时候用。</li><li>静态定位 按照标准流特性摆放位置，它没有边偏移。</li><li>静态定位在布局时我们几乎不用的</li></ul><h3 id="relative"><a href="#relative" class="headerlink" title="relative"></a>relative</h3><ul><li><strong>相对定位</strong>是元素<strong>相对</strong>于它原来在标准流中的位置 来说的。（自恋型）**</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611552470167-bd2f5289-4670-4b1f-9b22-1361f8cd58d0.png#align=left&display=inline&height=190&margin=%5Bobject%20Object%5D&name=image.png&originHeight=634&originWidth=1216&size=93835&status=done&style=stroke&width=365" alt="image.png"><br>相对定位的特点：（务必记住）</p><ul><li>相对于 自己原来在标准流中位置来移动的</li><li>原来<strong>在标准流的区域继续占有</strong>，后面的盒子仍然以标准流的方式对待它。</li></ul><h3 id="absolute"><a href="#absolute" class="headerlink" title="absolute"></a>absolute</h3><blockquote><p><strong>【1】绝对定位</strong>是元素以带有定位的父级元素来移动位置 （拼爹型）</p></blockquote><ul><li><p><strong>完全脱标</strong>：完全不占位置，完全镂空</p></li><li><p><strong>父元素没有定位：</strong>则以<strong>浏览器</strong>为准定位（Document 文档）。</p></li><li><p><strong>父元素要有定位：</strong>将元素依据最近的已经定位（绝对、固定或相对定位）的父元素（祖先）进行定位。</p></li><li><p>绝对是以带有定位的父级元素来移动位置， 如果父级都没有定位，则以浏览器文档为准移动位置</p></li><li><p>不保留原来的位置，完全是脱标的。</p></li></ul><blockquote><p>【2】子级元素使用绝对定位时，父级元素就要用相对定位</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611552541033-59cb288a-ccb1-4ccb-aa4c-e4550e99edf0.png#align=left&display=inline&height=459&margin=%5Bobject%20Object%5D&name=image.png&originHeight=918&originWidth=1234&size=93786&status=done&style=stroke&width=617" alt="image.png"></p><blockquote><p><strong>分析</strong></p></blockquote><ul><li><strong>方向箭头</strong>叠加在其他图片上方，应该使用<strong>绝对定位</strong>，因为<strong>绝对定位完全脱标</strong>，完全不占位置。</li><li><strong>父级盒子</strong>应该使用<strong>相对定位</strong>，因为<strong>相对定位不脱标</strong>，后续盒子仍然以标准流的方式对待它。</li><li>如果父级盒子也使用<strong>绝对定位</strong>，会完全脱标，那么下方的<strong>广告盒子</strong>会上移，这显然不是我们想要的。</li></ul><h3 id="fixed"><a href="#fixed" class="headerlink" title="fixed"></a>fixed</h3><ul><li><strong>固定定位</strong>是<strong>绝对定位</strong>的一种特殊形式： （认死理型）</li><li><strong>完全脱标</strong> —— 完全不占位置；</li><li>只认<strong>浏览器的可视窗口</strong> —— <code>浏览器可视窗口 + 边偏移属性</code> 来设置元素的位置；<ul><li>跟父元素没有任何关系；单独使用的</li><li>不随滚动条滚动。<blockquote><p>案例演练：固定定位案例。</p></blockquote></li></ul></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611552558881-329f4f76-7ace-4fdd-840d-40a651c628ad.png#align=left&display=inline&height=256&margin=%5Bobject%20Object%5D&name=image.png&originHeight=512&originWidth=1221&size=93480&status=done&style=stroke&width=610.5" alt="image.png"><br><strong>提示</strong>：IE 6 等低版本浏览器不支持固定定位。</p><h3 id="Demo：轮播图"><a href="#Demo：轮播图" class="headerlink" title="Demo：轮播图"></a>Demo：轮播图</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616243009664-321f94d9-d92b-4503-9ff3-beaf87f2413e.png#align=left&display=inline&height=272&margin=%5Bobject%20Object%5D&name=image.png&originHeight=544&originWidth=1920&size=28507&status=done&style=stroke&width=960" alt="image.png"></p><blockquote><p>圆角矩形设置 4 个角</p></blockquote><ul><li>圆角矩形可以为 4 个角分别设置圆度， 但是是有顺序的</li></ul><pre><code class="css">border-top-left-radius: 20px;border-top-right-radius: 20px;border-bottom-right-radius: 20px;border-bottom-left-radius: 20px;</code></pre><ul><li>如果 4 个角，数值相同</li></ul><pre><code class="css">border-radius: 15px;</code></pre><ul><li>里面数值不同，我们也可以按照简写的形式，还是遵循的顺时针。</li></ul><pre><code class="css">border-radius: 左上角 右上角 右下角 左下角;</code></pre><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;  &lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot; /&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;    &lt;title&gt;Document&lt;/title&gt;    &lt;style&gt;      * &#123;        padding: 0;        margin: 0;      &#125;      li &#123;        list-style: none;      &#125;      .box &#123;        width: 400px;        height: 300px;        background-color: tan;        position: relative;        margin: 0 auto;      &#125;      .row_left &#123;        position: absolute;        width: 20px;        height: 30px;        top: 50%;        left: 0;        margin-top: -15px;        border: 1px darkgoldenrod solid;        line-height: 30px;        border-top-right-radius: 30px;        border-bottom-right-radius: 30px;        text-align: left;      &#125;      .row_right &#123;        position: absolute;        width: 20px;        height: 30px;        top: 50%;        right: 0;        margin-top: -15px;        border: 1px darkgoldenrod solid;        line-height: 30px;        border-top-left-radius: 30px;        border-bottom-left-radius: 30px;        text-align: right;      &#125;      .bottom_dots &#123;        position: absolute;        width: 110px;        height: 22px;        bottom: 10px;        left: 50%;        margin-left: -50px;        border: springgreen 1px solid;        border-radius: 10px;      &#125;      .row_left:hover,      .row_right:hover &#123;        background-color: yellowgreen;      &#125;      .bottom_dots li &#123;        float: left;        width: 20px;        height: 20px;        border-radius: 50%;        border: steelblue solid 1px;      &#125;      .bottom_dots .current &#123;        background-color: tomato;      &#125;    &lt;/style&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;div class=&quot;box&quot;&gt;      &lt;div class=&quot;row_left&quot;&gt;&lt;&lt;/div&gt;      &lt;div class=&quot;row_right&quot;&gt;&gt;&lt;/div&gt;      &lt;ul class=&quot;bottom_dots&quot;&gt;        &lt;li&gt;&lt;/li&gt;        &lt;li class=&quot;current&quot;&gt;&lt;/li&gt;        &lt;li&gt;&lt;/li&gt;        &lt;li&gt;&lt;/li&gt;        &lt;li&gt;&lt;/li&gt;      &lt;/ul&gt;    &lt;/div&gt;  &lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="Demo：网站右下角快捷功能"><a href="#Demo：网站右下角快捷功能" class="headerlink" title="Demo：网站右下角快捷功能"></a>Demo：网站右下角快捷功能</h3><ul><li><strong>注意</strong>：不要同时使用 <code>left</code> 和 <code>right</code> 和边偏移属性。**</li><li><strong>固定定位</strong>的应用场景：<strong>固定在浏览器可视窗口某个位置的布局</strong>；</li><li>在使用固定和绝对定位时，如果盒子中没有内容，需要指定宽度，下面的例子又宽度</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616239742720-28510068-3322-4b73-ad28-8a345ba5f8c6.png#align=left&display=inline&height=297&margin=%5Bobject%20Object%5D&name=image.png&originHeight=593&originWidth=1920&size=187411&status=done&style=stroke&width=960" alt="image.png"></p><h2 id="定位的相关问题"><a href="#定位的相关问题" class="headerlink" title="定位的相关问题"></a>定位的相关问题</h2><h3 id="绝对定位的盒子居中"><a href="#绝对定位的盒子居中" class="headerlink" title="绝对定位的盒子居中"></a>绝对定位的盒子居中</h3><blockquote><p><strong>注意</strong>：<strong>绝对定位/固定定位的盒子</strong>不能通过设置 <code>margin: auto</code> 设置<strong>水平居中</strong>。</p></blockquote><p>在使用<strong>绝对定位</strong>时要想实现水平居中，可以按照下面的方法：</p><ol><li><code>left: 50%;</code>：让<strong>盒子的左侧</strong>移动到<strong>父级元素的水平中心位置</strong>；</li><li><code>margin-left: -100px;</code>：让盒子<strong>向左</strong>移动<strong>自身宽度的一半</strong>。</li></ol><p>整体居中如下设置<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616240730926-4415dd36-b842-4cc8-b0a2-49345b503a43.png#align=left&display=inline&height=892&margin=%5Bobject%20Object%5D&name=Snipaste_2021-03-20_19-44-47.png&originHeight=892&originWidth=1920&size=76602&status=done&style=stroke&width=1920" alt="Snipaste_2021-03-20_19-44-47.png"></p><h3 id="z-index"><a href="#z-index" class="headerlink" title="z-index"></a>z-index</h3><ul><li>在使用<strong>定位</strong>布局时，可能会<strong>出现盒子重叠的情况</strong>。</li><li>加了定位的盒子，默认<strong>后来者居上</strong>， 后面的盒子会压住前面的盒子。</li><li>应用 <code>z-index</code> 层叠等级属性可以<strong>调整盒子的堆叠顺序</strong>。如下图所示：</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611552609219-135cc13d-9a4e-411e-bac1-3b3fcad55d5e.png#align=left&display=inline&height=186&margin=%5Bobject%20Object%5D&name=image.png&originHeight=371&originWidth=1245&size=36112&status=done&style=stroke&width=622.5" alt="image.png"></p><blockquote><p><code>z-index</code> 的特性如下：</p></blockquote><ul><li><strong>属性值</strong>：<strong>正整数</strong>、<strong>负整数</strong>或 <strong>0</strong>，默认值是 0，数值越大，盒子越靠上；</li><li>如果<strong>属性值相同</strong>，则按照书写顺序，<strong>后来居上</strong>；</li><li><strong>数字后面不能加单位</strong>。</li><li><strong>注意</strong>：<code>z-index</code> 只能应用于<strong>相对定位</strong>、<strong>绝对定位</strong>和<strong>固定定位</strong>的元素，其他<strong>标准流</strong>、<strong>浮动</strong>和<strong>静态定位</strong>无效。</li></ul><h3 id="定位改变-display-属性"><a href="#定位改变-display-属性" class="headerlink" title="定位改变 display 属性"></a>定位改变 display 属性</h3><p>前面我们讲过，display 是显示模式，可以改变显示模式有以下方式:</p><ul><li>可以用 inline-block 转换为行内块</li><li>可以用浮动 float 默认转换为行内块（类似，并不完全一样，因为浮动是脱标的）</li><li>绝对定位和固定定位也和浮动类似， 默认转换的特性转换为行内块。</li></ul><p>所以说， 一个行内的盒子，如果加了<strong>浮动</strong>、<strong>固定定位</strong>和<strong>绝对定位</strong>，不用转换，就可以给这个盒子直接设置宽度和高度等。</p><blockquote><p><strong>同时注意：</strong></p></blockquote><p>浮动元素、绝对定位(固定定位）元素的都不会触发外边距合并的问题。 （我们以前是用 padding border overflow 解决的）<br>也就是说，我们给盒子改为了浮动或者定位，就不会有垂直外边距合并的问题了。</p>]]></content>
      
      
      <categories>
          
          <category> Language </category>
          
          <category> CSS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CSS浮动</title>
      <link href="blog/vgixv5vex3i8/"/>
      <url>blog/vgixv5vex3i8/</url>
      
        <content type="html"><![CDATA[<h2 id="浮动详解"><a href="#浮动详解" class="headerlink" title="浮动详解"></a>浮动详解</h2><h3 id="为什么需要浮动"><a href="#为什么需要浮动" class="headerlink" title="为什么需要浮动"></a>为什么需要浮动</h3><ul><li><p>多个盒子(div)水平排列成一行</p></li><li><p>实现盒子的左右对齐</p></li><li><p>行内块（inline-block）它可以实现多个元素一行显示，但是中间会有空白缝隙，不能满足以上第一个问题。</p></li><li><p>行内块（inline-block）不能实现以上第二个问题，盒子左右对齐</p></li></ul><h3 id="浮动特点"><a href="#浮动特点" class="headerlink" title="浮动特点"></a>浮动特点</h3><blockquote><p><strong>概念</strong>：元素的浮动是指<strong>设置了浮动属性的元素</strong>会</p></blockquote><ul><li><p>脱离标准普通流的控制</p></li><li><p>移动到指定位置</p><blockquote><p>作用</p></blockquote></li><li><p><strong>让多个盒子(div)水平排列成一行</strong>，使得浮动成为布局的重要手段。</p></li><li><p>可以实现盒子的左右对齐等等..</p></li><li><p>浮动最早是用来<strong>控制图片</strong>，实现<strong>文字环绕图片的效果</strong>。</p><blockquote><p>语法</p></blockquote></li></ul><pre><code class="css">选择器 &#123;  float: 属性值;&#125;</code></pre><table><thead><tr><th>属性值</th><th>描述</th></tr></thead><tbody><tr><td><strong>none</strong></td><td>元素不浮动（<strong>默认值</strong>）</td></tr><tr><td><strong>left</strong></td><td>元素向<strong>左</strong>浮动</td></tr><tr><td><strong>right</strong></td><td>元素向<strong>右</strong>浮动</td></tr></tbody></table><blockquote><p>特点 1：浮</p></blockquote><ul><li>浮动——浮浮~~~漂浮在普通流的上面。 脱离标准流。 俗称 “脱标”</li><li><code>float</code> 属性会让盒子漂浮在标准流的上面，所以第二个标准流的盒子跑到浮动盒子的底下了。</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616233538999-0a7d098b-a897-491c-b25c-36f34eb7b193.png#align=left&display=inline&height=440&margin=%5Bobject%20Object%5D&name=image.png&originHeight=880&originWidth=1920&size=139927&status=done&style=stroke&width=960" alt="image.png"></p><ul><li><p>上图问题 1 处出现文字被撑开的情况，似乎和预想的有一丢丢的不尽如意，原因是对于文本和行内元素来说依然是占用空间的</p><blockquote><p>特点 2：漏</p></blockquote></li><li><p>浮动——漏漏~ 浮动的盒子，把自己原来的位置漏给下面标准流的盒子，就是不占有原来位置，是脱离标准流的，我们俗称 “脱标”。</p><blockquote><p>特点 3：特</p></blockquote></li><li><p>浮动——特性 float 属性会改变元素 display 属性。</p></li><li><p>任何元素都可以浮动。浮动元素会生成一个块级框，而不论它本身是何种元素。 生成的块级框和我们前面的行内块极其相似，所以出现了上面浮里面的例子当中父元素里面的文字被撑开的情况</p></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616234017630-4391a0b4-6214-42ba-a1f2-cd44c1a99f94.png#align=left&display=inline&height=330&margin=%5Bobject%20Object%5D&name=image.png&originHeight=660&originWidth=1920&size=116474&status=done&style=stroke&width=960" alt="image.png"></p><ul><li>**浮动的元素互相贴靠一起的，但是如果父级宽度装不下这些浮动的盒子， ****多出的盒子会另起一行对齐**</li></ul><h3 id="Demo：浮动-标准流的布局"><a href="#Demo：浮动-标准流的布局" class="headerlink" title="Demo：浮动+标准流的布局"></a>Demo：浮动+标准流的布局</h3><blockquote><p>浮动和标准流的父盒子搭配</p></blockquote><p>我们知道，浮动是脱标的，会影响下面的标准流元素，此时，我们需要给浮动的元素添加一个标准流的父亲，这样，最大化的减小了对其他标准流的影响。**<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616236830103-21860906-bc1f-48a8-8fb1-a5011f02a551.png#align=left&display=inline&height=334&margin=%5Bobject%20Object%5D&name=image.png&originHeight=667&originWidth=1920&size=71026&status=done&style=stroke&width=960" alt="image.png"></p><h2 id="浮动的相关问题"><a href="#浮动的相关问题" class="headerlink" title="浮动的相关问题"></a>浮动的相关问题</h2><h3 id="浮动元素与父盒子的关系"><a href="#浮动元素与父盒子的关系" class="headerlink" title="浮动元素与父盒子的关系"></a>浮动元素与父盒子的关系</h3><ul><li>子盒子的浮动参照父盒子对齐</li><li>不会与父盒子的边框重叠，也不会超过父盒子的内边距</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616237499108-fe82abe6-42c1-4f37-ad68-d45c3f78cd11.png#align=left&display=inline&height=152&margin=%5Bobject%20Object%5D&name=image.png&originHeight=303&originWidth=1920&size=33264&status=done&style=stroke&width=960" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616237548311-79fb762c-6f7d-45c0-b316-14a12ba92098.png#align=left&display=inline&height=90&margin=%5Bobject%20Object%5D&name=image.png&originHeight=179&originWidth=1920&size=8431&status=done&style=stroke&width=960" alt="image.png"></p><h3 id="浮动元素与兄弟盒子的关系"><a href="#浮动元素与兄弟盒子的关系" class="headerlink" title="浮动元素与兄弟盒子的关系"></a>浮动元素与兄弟盒子的关系</h3><p>在一个父级盒子中，如果<strong>前一个兄弟盒子</strong>是：</p><ul><li><strong>浮动</strong>的，那么<strong>当前盒子</strong>会与前一个盒子的顶部对齐；</li><li><strong>普通流</strong>的，那么<strong>当前盒子</strong>会显示在前一个兄弟盒子的下方。</li><li>浮动只会影响当前的或者是后面的标准流盒子，不会影响前面的标准流。</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2021/jpg/1484158/1611549557830-9fdd5350-af70-4793-8dba-cc3c06214b72.jpg#align=left&display=inline&height=553&margin=%5Bobject%20Object%5D&originHeight=553&originWidth=486&status=done&style=stroke&width=486"></p><ul><li><strong>如果一个盒子里面有多个子盒子，如果其中一个盒子浮动了，其他兄弟也应该浮动。防止引起问题</strong></li></ul><h3 id="为什么要清除浮动"><a href="#为什么要清除浮动" class="headerlink" title="为什么要清除浮动"></a>为什么要清除浮动</h3><ul><li>因为父级盒子很多情况下，不方便给高度，但是子盒子浮动就不占有位置，最后父级盒子高度为 0，就影响了下面的标准流盒子</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616238120449-097b5efe-31ea-43f9-b393-4e64e9836530.png#align=left&display=inline&height=135&margin=%5Bobject%20Object%5D&name=image.png&originHeight=270&originWidth=1920&size=32856&status=done&style=stroke&width=960" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616238209810-a8b31f63-37b3-4289-a691-e52ab55f8203.png#align=left&display=inline&height=101&margin=%5Bobject%20Object%5D&name=image.png&originHeight=201&originWidth=1920&size=20171&status=done&style=stroke&width=960" alt="image.png"></p><ul><li>总结：由于浮动元素不再占用原文档流的位置，所以它会对后面的元素排版产生影响，准确地说，并不是清除浮动，而是<strong>清除浮动后造成的影响</strong></li><li><strong>所以还是最好利用一个标准流为父盒子，里面套数个浮动盒子最为好用</strong><blockquote><p><strong>清除浮动本质：</strong> &gt; <strong>清除浮动主要为了解决父级元素因为子级浮动引起内部高度为 0 的问题</strong>&gt; <strong>。清除浮动之后， 父级就会根据浮动的子盒子自动检测高度。父级有了高度，就不会影响下面的标准流了</strong></p></blockquote></li></ul><h3 id="清除浮动的方法"><a href="#清除浮动的方法" class="headerlink" title="清除浮动的方法"></a>清除浮动的方法</h3><ul><li>clear 属性用于清除浮动<table><thead><tr><th>属性值</th><th>描述</th></tr></thead><tbody><tr><td>left</td><td>不允许左侧有浮动元素（清除左侧浮动的影响）</td></tr><tr><td>right</td><td>不允许右侧有浮动元素（清除右侧浮动的影响）</td></tr><tr><td>both</td><td>同时清除左右两侧浮动的影响</td></tr></tbody></table></li></ul><h4 id="clear-both"><a href="#clear-both" class="headerlink" title="clear:both"></a>clear:both</h4><p>是 W3C 推荐的做法是通过在浮动元素末尾添加一个空的标签例如 <code>&lt;div style=”clear:both”&gt;&lt;/div&gt;</code>，或则其他标签 br 等亦可。</p><ul><li>优点： 通俗易懂，书写方便</li><li>缺点： 添加许多无意义的标签，结构化较差。</li></ul><h4 id="overflow-hidden"><a href="#overflow-hidden" class="headerlink" title="overflow: hidden;"></a>overflow: hidden;</h4><p>可以给父级添加： overflow 为 hidden| auto| scroll   都可以实现。</p><ul><li>优点： 代码简洁</li><li>缺点： 内容增多时候容易造成不会自动换行导致内容被隐藏掉，无法显示需要溢出的元素。</li></ul><h4 id="使用-after-伪元素清除浮动"><a href="#使用-after-伪元素清除浮动" class="headerlink" title="使用 after 伪元素清除浮动"></a>使用 after 伪元素清除浮动</h4><blockquote><p><strong>:after 方式为空元素额外标签法的升级版，好处是不用单独加标签了</strong></p></blockquote><pre><code class="css">.clearfix:after &#123;  content: &quot;&quot;;  display: block;  height: 0;  clear: both;  visibility: hidden;&#125;.clearfix &#123;  *zoom: 1;&#125; /* IE6、7 专有 */</code></pre><ul><li>优点： 符合闭合浮动思想 结构语义化正确</li><li>缺点： 由于 IE6-7 不支持:after，使用 zoom:1 触发 hasLayout。</li><li>代表网站： 百度、淘宝网、网易等</li></ul><h4 id="使用双伪元素清除浮动"><a href="#使用双伪元素清除浮动" class="headerlink" title="使用双伪元素清除浮动"></a>使用双伪元素清除浮动</h4><pre><code class="css">.clearfix:before,.clearfix:after &#123;  content: &quot;&quot;;  display: table;&#125;.clearfix:after &#123;  clear: both;&#125;.clearfix &#123;  *zoom: 1;&#125;</code></pre><ul><li><p>优点： 代码更简洁</p></li><li><p>缺点： 由于 IE6-7 不支持:after，使用 zoom:1 触发 hasLayout。</p></li><li><p>代表网站： 小米、腾讯等</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Language </category>
          
          <category> CSS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CSS盒模型</title>
      <link href="blog/dnp4byvzqz87/"/>
      <url>blog/dnp4byvzqz87/</url>
      
        <content type="html"><![CDATA[<h2 id="border"><a href="#border" class="headerlink" title="border"></a>border</h2><h3 id="border-综合"><a href="#border-综合" class="headerlink" title="border 综合"></a>border 综合</h3><table><thead><tr><th>属性</th><th align="center">作用</th></tr></thead><tbody><tr><td>border-width</td><td align="center">定义边框粗细，单位是 px</td></tr><tr><td>border-style</td><td align="center">边框的样式</td></tr><tr><td>border-color</td><td align="center">边框颜色</td></tr></tbody></table><blockquote><p>【1】border-style</p></blockquote><ul><li>none：没有边框即忽略所有边框的宽度（默认值）</li><li>solid：边框为单实线(最为常用的)</li><li>dashed：边框为虚线</li><li>dotted：边框为点线<blockquote><p>【2】综合设置：盒子边框写法总结表</p></blockquote></li></ul><pre><code class="css">border: 1px solid red;</code></pre><blockquote><p>【3】很多情况下，我们不需要指定 4 个边框，我们是可以单独给 4 个边框分别指定的。</p></blockquote><table><thead><tr><th align="left">上边框</th><th align="left">下边框</th><th align="left">左边框</th><th align="left">右边框</th></tr></thead><tbody><tr><td align="left">border-top-style:样式;</td><td align="left">border-bottom-style:样式;</td><td align="left">border-left-style:样式;</td><td align="left">border-right-style:样式;</td></tr><tr><td align="left">border-top-width:宽度;</td><td align="left">border- bottom-width:宽度;</td><td align="left">border-left-width:宽度;</td><td align="left">border-right-width:宽度;</td></tr><tr><td align="left">border-top-color:颜色;</td><td align="left">border- bottom-color:颜色;</td><td align="left">border-left-color:颜色;</td><td align="left">border-right-color:颜色;</td></tr><tr><td align="left">border-top:宽度 样式 颜色;</td><td align="left">border-bottom:宽度 样式 颜色;</td><td align="left">border-left:宽度 样式 颜色;</td><td align="left">border-right:宽度 样式 颜色;</td></tr></tbody></table><blockquote><p>表格的细线边框</p></blockquote><ul><li><p>通过表格的<code>cellspacing=&quot;0&quot;</code>,将单元格与单元格之间的距离设置为 0，</p></li><li><p>但是两个单元格之间的边框会出现重叠，从而使边框变粗</p></li><li><p>通过 css 属性：</p></li></ul><pre><code>table&#123; border-collapse:collapse; &#125;</code></pre><ul><li>collapse 单词是合并的意思</li><li>border-collapse:collapse; 表示相邻边框合并在一起。</li></ul><pre><code class="css">&lt;style&gt;    table &#123;        width: 500px;        height: 300px;        border: 1px solid red;    &#125;    td &#123;        border: 1px solid red;        text-align: center;    &#125;    table, td &#123;        border-collapse: collapse;  /*合并相邻边框*/    &#125;&lt;/style&gt;</code></pre><h3 id="border-radius"><a href="#border-radius" class="headerlink" title="border-radius"></a>border-radius</h3><ul><li>语法：</li></ul><pre><code class="css">border-radius: length;</code></pre><ul><li><p>其中每一个值可以为 数值或百分比的形式。</p></li><li><p>让一个正方形（让这个盒子 width 和 height 相等）变成圆圈</p></li></ul><pre><code class="css">border-radius: 50%;</code></pre><ul><li>百分比会是表示高度和宽度的一半的情况</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616160100879-1ec56967-ea20-4bd2-8327-519c75d1367f.png#align=left&display=inline&height=345&margin=%5Bobject%20Object%5D&name=image.png&originHeight=689&originWidth=1920&size=1162765&status=done&style=stroke&width=960" alt="image.png"></p><h3 id="box-shadow"><a href="#box-shadow" class="headerlink" title="box-shadow"></a>box-shadow</h3><ul><li>语法:</li></ul><pre><code class="css">box-shadow: 水平阴影 垂直阴影 模糊距离（虚实） 阴影尺寸（影子大小） 阴影颜色  内/外阴影；;</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611549557136-9945210f-61eb-44df-af61-5eb070818e6f.png#align=left&display=inline&height=306&margin=%5Bobject%20Object%5D&originHeight=306&originWidth=862&status=done&style=stroke&width=862"></p><ul><li>前两个属性是必须写的。其余的可以省略。</li><li>外阴影 (outset) 是默认的 但是不能写 想要内阴影可以写 inset</li></ul><h2 id="padding"><a href="#padding" class="headerlink" title="padding"></a>padding</h2><blockquote><p>内边距：padding 属性用于设置内边距。 <strong>是指 边框与内容之间的距离。</strong></p></blockquote><h3 id="padding-综合"><a href="#padding-综合" class="headerlink" title="padding 综合"></a>padding 综合</h3><table><thead><tr><th>属性</th><th align="left">作用</th></tr></thead><tbody><tr><td>padding-left</td><td align="left">左内边距</td></tr><tr><td>padding-right</td><td align="left">右内边距</td></tr><tr><td>padding-top</td><td align="left">上内边距</td></tr><tr><td>padding-bottom</td><td align="left">下内边距</td></tr></tbody></table><p>当我们给盒子指定 padding 值之后， 发生了 2 件事情：</p><ol><li>内容和边框 有了距离，添加了内边距。</li><li>盒子会变大了。</li></ol><p><strong>注意： 后面跟几个数值表示的意思是不一样的。</strong><br>我们分开写有点麻烦，我们可以不可以简写呢？</p><table><thead><tr><th>值的个数</th><th>表达意思</th></tr></thead><tbody><tr><td>1 个值</td><td>padding：上下左右内边距;</td></tr><tr><td>2 个值</td><td>padding: 上下内边距 左右内边距 ；</td></tr><tr><td>3 个值</td><td>padding：上内边距 左右内边距 下内边距；</td></tr><tr><td>4 个值</td><td>padding: 上内边距 右内边距 下内边距 左内边距 ；</td></tr></tbody></table><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611552112041-a7ed9154-18bb-478e-867f-92e7837719ea.png#align=left&display=inline&height=152&margin=%5Bobject%20Object%5D&name=image.png&originHeight=303&originWidth=409&size=41892&status=done&style=stroke&width=204.5" alt="image.png">**</p><h3 id="内盒尺寸计算（元素实际大小）"><a href="#内盒尺寸计算（元素实际大小）" class="headerlink" title="内盒尺寸计算（元素实际大小）"></a>内盒尺寸计算（元素实际大小）</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611552122666-74470517-33eb-4212-b483-430e2bbd0ee5.png#align=left&display=inline&height=154&margin=%5Bobject%20Object%5D&name=image.png&originHeight=308&originWidth=347&size=26383&status=done&style=stroke&width=173.5" alt="image.png"></p><ul><li><p>宽度：Element Height = content height + padding + border （Height 为内容高度）</p></li><li><p>高度：Element Width = content width + padding + border （Width 为内容宽度）</p></li><li><p>盒子的实际的大小 = 内容的宽度和高度 + 内边距 + 边框</p></li></ul><h3 id="内边距撑大盒子的解决方案"><a href="#内边距撑大盒子的解决方案" class="headerlink" title="内边距撑大盒子的解决方案"></a>内边距撑大盒子的解决方案</h3><blockquote><p>问题：会撑大原来的盒子</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611552148703-03f4e9a2-62c0-4ef6-bcc9-daca7a48972f.png#align=left&display=inline&height=187&margin=%5Bobject%20Object%5D&name=image.png&originHeight=602&originWidth=1127&size=112122&status=done&style=stroke&width=350" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611552164629-96bb4847-362e-4c50-ad11-9bf86c3cd22e.png#align=left&display=inline&height=213&margin=%5Bobject%20Object%5D&name=image.png&originHeight=715&originWidth=1186&size=132784&status=done&style=stroke&width=353" alt="image.png"></p><blockquote><p>解决方案【1】：通过给设置了宽高的盒子，减去相应的内边距的值，维持盒子原有的大小</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611552179527-c1060669-e26e-4c16-b0eb-0fa78c03b45b.png#align=left&display=inline&height=215&margin=%5Bobject%20Object%5D&name=image.png&originHeight=610&originWidth=1113&size=111733&status=done&style=stroke&width=393" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611552188919-c9493a98-9f8f-4ba4-942c-83d9fd2a033f.png#align=left&display=inline&height=238&margin=%5Bobject%20Object%5D&name=image.png&originHeight=687&originWidth=1145&size=127523&status=done&style=stroke&width=397" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611552197848-242d4e3f-1cdd-4f31-b86b-e42b549e2094.png#align=left&display=inline&height=223&margin=%5Bobject%20Object%5D&name=image.png&originHeight=667&originWidth=1189&size=128129&status=done&style=stroke&width=397" alt="image.png"><br>关于根据下列代码计算 盒子宽高下列说法正确的是（）</p><pre><code class="css">div &#123;  width: 200px;  height: 200px;  border: 1px solid #000000;  border-top: 5px solid blue;  padding: 50px;  padding-left: 100px;&#125;</code></pre><ul><li>(A) 宽度为 200px 高度为 200px</li><li>(B) 宽度为 352px 高度为 306px</li><li>(C) 宽度为 302px 高度为 307px</li><li>(D) 宽度为 302px 高度为 252px</li></ul><p>w 200 + 150 + 2 = 352<br>h 200 + 100 + 6 = 306</p><blockquote><p>解决方案【2】：设置 box-sizing 属性</p></blockquote><pre><code class="css">-moz-box-sizing: border-box; /*Firefox3.5+*/-webkit-box-sizing: border-box; /*Safari3.2+*/-o-box-sizing: border-box; /*Opera9.6*/-ms-box-sizing: border-box; /*IE8*/box-sizing: border-box; /*W3C标准(IE9+，Safari5.1+,Chrome10.0+,Opera10.6+都符合box-sizing的w3c标准语法)*/</code></pre><p>注意：box-sizing 属性是 CSS3 的属性，IE 低版本不支持，注意兼容性<br>参考：</p><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/box-sizing">https://developer.mozilla.org/zh-CN/docs/Web/CSS/box-sizing</a></li><li><a href="https://www.zhihu.com/question/31031251">https://www.zhihu.com/question/31031251</a></li></ul><h3 id="内边距不影响盒子大小情况"><a href="#内边距不影响盒子大小情况" class="headerlink" title="内边距不影响盒子大小情况"></a>内边距不影响盒子大小情况</h3><blockquote><p>如果没有给一个盒子指定宽度， 此时，如果给这个盒子指定 padding， 则不会撑开盒子。</p></blockquote><h2 id="margin"><a href="#margin" class="headerlink" title="margin"></a>margin</h2><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611552211186-1bc52b3c-f2d9-418b-99d8-582718465af1.png#align=left&display=inline&height=250&margin=%5Bobject%20Object%5D&name=image.png&originHeight=500&originWidth=950&size=49287&status=done&style=stroke&width=475" alt="image.png"><br>margin 属性用于设置外边距。 margin 就是控制<strong>盒子和盒子之间的距离</strong></p><h3 id="padding-综合-1"><a href="#padding-综合-1" class="headerlink" title="padding 综合"></a>padding 综合</h3><table><thead><tr><th>属性</th><th align="left">作用</th></tr></thead><tbody><tr><td>margin-left</td><td align="left">左外边距</td></tr><tr><td>margin-right</td><td align="left">右外边距</td></tr><tr><td>margin-top</td><td align="left">上外边距</td></tr><tr><td>margin-bottom</td><td align="left">下外边距</td></tr></tbody></table><p>margin 值的简写 （复合写法）代表意思 跟 padding 完全相同。</p><h2 id="display"><a href="#display" class="headerlink" title="display"></a>display</h2><h3 id="什么是标签显示模式"><a href="#什么是标签显示模式" class="headerlink" title="什么是标签显示模式"></a>什么是标签显示模式</h3><ul><li><p>什么是标签的显示模式？<br>标签以什么方式进行显示，比如 div 自己占一行， 比如 span 一行可以放很多个</p></li><li><p>作用：<br>我们网页的标签非常多，再不同地方会用到不同类型的标签，以便更好的完成我们的网页。</p></li><li><p>标签的类型(分类)<br>HTML 标签一般分为块标签和行内标签两种类型，它们也称块元素和行内元素。</p></li></ul><h3 id="块级元素-block-level"><a href="#块级元素-block-level" class="headerlink" title="块级元素(block-level)"></a>块级元素(block-level)</h3><ul><li>例：</li></ul><pre><code>常见的块元素有&lt;h1&gt;~&lt;h6&gt;、&lt;p&gt;、&lt;div&gt;、&lt;ul&gt;、&lt;ol&gt;、&lt;li&gt;等，其中&lt;div&gt;标签是最典型的块元素。</code></pre><ul><li>块级元素的特点</li></ul><p>（1）比较霸道，自己独占一行<br>（2）高度，宽度、外边距以及内边距都可以控制。<br>（3）宽度默认是容器（父级宽度）的 100%<br>（4）是一个容器及盒子，里面可以放行内或者块级元素。</p><ul><li>只有 文字才 能组成段落 因此 p 里面不能放块级元素，特别是 p 不能放 div</li><li>同理还有这些标签 h1,h2,h3,h4,h5,h6,dt，他们都是文字类块级标签，里面不能放其他块级元素。</li></ul><h3 id="行内元素-inline-level"><a href="#行内元素-inline-level" class="headerlink" title="行内元素(inline-level)"></a>行内元素(inline-level)</h3><ul><li>例：</li></ul><pre><code>常见的行内元素有&lt;a&gt;、&lt;strong&gt;、&lt;b&gt;、&lt;em&gt;、&lt;i&gt;、&lt;del&gt;、&lt;s&gt;、&lt;ins&gt;、&lt;u&gt;、&lt;span&gt;等，其中&lt;span&gt;标签最典型的行内元素。有的地方也成内联元素</code></pre><ul><li>行内元素的特点：</li></ul><p>（1）相邻行内元素在一行上，一行可以显示多个。<br>（2）高、宽直接设置是无效的。<br>（3）默认宽度就是它本身内容的宽度。<br>（4）<strong>行内元素只能容纳文本或则其他行内元素。</strong></p><ul><li>链接里面不能再放链接。</li><li>特殊情况 a 里面可以放块级元素，但是给 a 转换一下块级模式最安全。</li></ul><h3 id="行内块元素（inline-block）"><a href="#行内块元素（inline-block）" class="headerlink" title="行内块元素（inline-block）"></a>行内块元素（inline-block）</h3><ul><li>例：</li></ul><pre><code>在行内元素中有几个特殊的标签——&lt;img /&gt;、&lt;input /&gt;、&lt;td&gt;，可以对它们设置宽高和对齐属性，有些资料可能会称它们为行内块元素。</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611551937533-f958d872-1942-4aee-8533-8671afa1dc82.png#align=left&display=inline&height=258&margin=%5Bobject%20Object%5D&name=image.png&originHeight=515&originWidth=1217&size=75676&status=done&style=stroke&width=608.5" alt="image.png"></p><ul><li>行内块元素的特点：<br>（1）和相邻行内元素（行内块）在一行上,但是之间会有空白缝隙。一行可以显示多个<br>（2）默认宽度就是它本身内容的宽度。<br>（3）高度，行高、外边距以及内边距都可以控制。</li></ul><h3 id="display-1"><a href="#display-1" class="headerlink" title="display"></a>display</h3><ul><li>块转行内：display:inline;</li><li>行内转块：display:block;</li><li>块、行内元素转换为行内块： display: inline-block;</li></ul><p>此阶段，我们只需关心这三个，其他的是我们后面的工作。</p><h2 id="盒模型的相关问题"><a href="#盒模型的相关问题" class="headerlink" title="盒模型的相关问题"></a>盒模型的相关问题</h2><h3 id="块级盒子水平居中"><a href="#块级盒子水平居中" class="headerlink" title="块级盒子水平居中"></a>块级盒子水平居中</h3><ul><li>一个块级盒子实现水平居中必须：<ul><li>盒子必须指定了宽度（width）</li><li>然后就给<strong>左右的外边距都设置为 auto</strong>，</li></ul></li></ul><p>实际工作中常用这种方式进行网页布局，示例代码如下：</p><pre><code class="css">.header &#123;  width: 960px;  margin: 0 auto;&#125;</code></pre><p>常见的写法，以下下三种都可以。</p><ul><li>margin-left: auto; margin-right: auto;</li><li>margin: auto;</li><li>margin: 0 auto;</li></ul><h3 id="文字居中和盒子居中区别"><a href="#文字居中和盒子居中区别" class="headerlink" title="文字居中和盒子居中区别"></a>文字居中和盒子居中区别</h3><ol><li>盒子内的文字水平居中是 text-align: center, 而且还可以让行内元素和行内块居中对齐</li><li>块级盒子水平居中左右 margin 改为 auto</li></ol><pre><code class="css">text-align: center; /*  文字 行内元素 行内块元素水平居中 */margin: 10px auto; /* 块级盒子水平居中  左右margin 改为 auto 就阔以了 上下margin都可以 */</code></pre><h3 id="插入图片和背景图片区别"><a href="#插入图片和背景图片区别" class="headerlink" title="插入图片和背景图片区别"></a>插入图片和背景图片区别</h3><ol><li>插入图片 我们用的最多 比如产品展示类 移动位置只能靠盒模型 padding margin</li><li>背景图片我们一般用于小图标背景 或者 超大背景图片 背景图片 只能通过 background-position</li></ol><pre><code class="css">img &#123;  width: 200px; /* 插入图片更改大小 width 和 height */  height: 210px;  margin-top: 30px; /* 插入图片更改位置 可以用margin 或padding  盒模型 */  margin-left: 50px; /* 插入当图片也是一个盒子 */&#125;div &#123;  width: 400px;  height: 400px;  border: 1px solid purple;  background: #fff url(images/sun.jpg) no-repeat;  background-position: 30px 50px; /* 背景图片更改位置 我用 background-position */&#125;</code></pre><h3 id="清除元素的默认内外边距"><a href="#清除元素的默认内外边距" class="headerlink" title="清除元素的默认内外边距"></a>清除元素的默认内外边距</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611552224242-7158d827-f872-4872-9c9d-598c846d74b9.png#align=left&display=inline&height=178&margin=%5Bobject%20Object%5D&name=image.png&originHeight=355&originWidth=1075&size=48809&status=done&style=stroke&width=537.5" alt="image.png"><br>为了更灵活方便地控制网页中的元素，制作网页时，我们需要将元素的默认内外边距清除<br>代码：</p><pre><code class="css">* &#123;  padding: 0; /* 清除内边距 */  margin: 0; /* 清除外边距 */&#125;</code></pre><ul><li>行内元素为了照顾兼容性， 尽量只设置左右内外边距， 不要设置上下内外边距。</li></ul><h3 id="margin-塌陷问题"><a href="#margin-塌陷问题" class="headerlink" title="margin 塌陷问题"></a>margin 塌陷问题</h3><p>使用 margin 定义块元素的<strong>垂直外边距</strong>时，可能会出现外边距的合并。</p><blockquote><p>相邻块元素垂直外边距的合并</p></blockquote><ul><li>当上下相邻的两个块元素相遇时，如果上面的元素有下外边距 margin-bottom</li><li>下面的元素有上外边距 margin-top，则他们之间的垂直间距不是 margin-bottom 与 margin-top 之和</li><li><strong>取两个值中的较大者</strong>这种现象被称为相邻块元素垂直外边距的合并（也称外边距塌陷）。</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611549556832-735ecd9b-2e20-4413-a635-cedc3692442f.png#align=left&display=inline&height=309&margin=%5Bobject%20Object%5D&originHeight=309&originWidth=504&status=done&style=stroke&width=504"><br>**解决方案：****尽量给只给一个盒子添加 margin 值**。</p><blockquote><p>嵌套块元素垂直外边距的合并（塌陷）</p></blockquote><ul><li>对于两个嵌套关系的块元素，如果父元素没有上内边距及边框</li><li>父元素的上外边距会与子元素的上外边距发生合并</li><li>合并后的外边距为两者中的较大者</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611549556894-4dc0bcd3-d5ed-467c-b725-bf4477a4e93c.png#align=left&display=inline&height=195&margin=%5Bobject%20Object%5D&originHeight=195&originWidth=504&status=done&style=stroke&width=504"><br><strong>解决方案：</strong></p><ol><li>可以为父元素定义上边框。</li><li>可以为父元素定义上内边距</li><li>可以为父元素添加 overflow:hidden。</li></ol><p>还有其他方法，比如浮动、固定、绝对定位的盒子不会有问题，后面咱们再总结。。。</p><h3 id="盒子模型布局稳定性"><a href="#盒子模型布局稳定性" class="headerlink" title="盒子模型布局稳定性"></a>盒子模型布局稳定性</h3><ul><li>根据稳定性来分：按照 优先使用 宽度 （width） 其次 使用内边距（padding） 再次 外边距（margin）。</li><li>margin 会有外边距合并 还有 ie6 下面 margin 加倍的 bug（讨厌）所以最后使用。</li><li>padding 会影响盒子大小， 需要进行加减计算（麻烦） 其次使用。</li><li>width 没有问题，经常使用宽度剩余法 高度剩余法来做。</li></ul><h3 id="line-height-的问题"><a href="#line-height-的问题" class="headerlink" title="line-height 的问题"></a>line-height 的问题</h3><blockquote><p>【1】行高测量</p></blockquote><p>行高的测量方法：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611549555568-b660d3a6-0153-453f-ae22-fc831f79d659.png#align=left&display=inline&height=183&margin=%5Bobject%20Object%5D&originHeight=291&originWidth=648&status=done&style=stroke&width=407"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611549555629-ba0bce7a-f7b1-49ff-89aa-c14496ccbcb6.png#align=left&display=inline&height=148&margin=%5Bobject%20Object%5D&originHeight=291&originWidth=800&status=done&style=stroke&width=408"></p><blockquote><p>【2】单行文本垂直居中</p></blockquote><p>行高我们利用最多的一个地方是： 可以让单行文本在盒子中垂直居中对齐。</p><blockquote><p><strong>文字的行高等于盒子的高度。</strong></p></blockquote><p>这里情况些许复杂，开始学习，我们可以先从简单地方入手学会。<br>行高 = 上距离 + 内容高度 + 下距离<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611549555695-02bf584b-9ece-45fe-a081-52aaf565d20d.png#align=left&display=inline&height=312&margin=%5Bobject%20Object%5D&originHeight=174&originWidth=391&status=done&style=stroke&width=700"><br>上距离和下距离总是相等的，因此文字看上去是垂直居中的。<br><strong>行高和高度的三种关系</strong></p><ul><li>如果 行高 等 高度 文字会 垂直居中</li><li>如果行高 大于 高度 文字会 偏下</li><li>如果行高小于高度 文字会 偏上</li></ul><h3 id=""><a href="#" class="headerlink" title=""></a></h3>]]></content>
      
      
      <categories>
          
          <category> Language </category>
          
          <category> CSS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CSS字体和背景</title>
      <link href="blog/sideak09lpko/"/>
      <url>blog/sideak09lpko/</url>
      
        <content type="html"><![CDATA[<h2 id="字体相关"><a href="#字体相关" class="headerlink" title="字体相关"></a>字体相关</h2><h3 id="font-size"><a href="#font-size" class="headerlink" title="font-size"></a>font-size</h3><ul><li>作用：<br>font-size 属性用于设置字号</li></ul><pre><code class="css">p &#123;  font-size: 20px;&#125;</code></pre><ul><li>单位：<ul><li>可以使用相对长度单位，也可以使用绝对长度单位。</li><li>相对长度单位比较常用，推荐使用像素单位 px，绝对长度单位使用较少。</li></ul></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611549554219-97b92fc6-0b55-4946-a903-080b2dfa44fa.png#align=left&display=inline&height=308&margin=%5Bobject%20Object%5D&originHeight=308&originWidth=637&status=done&style=stroke&width=637"><br><strong>注意：</strong></p><ul><li>我们文字大小以后，基本就用 px 了，其他单位很少使用</li><li>谷歌浏览器默认的文字大小为 16px</li><li>但是不同浏览器可能默认显示的字号大小不一致，我们尽量给一个明确值大小，不要默认大小。一般给 body 指定整个页面文字的大小</li></ul><h3 id="font-family"><a href="#font-family" class="headerlink" title="font-family"></a>font-family</h3><pre><code>p&#123; font-family:&quot;微软雅黑&quot;;&#125;</code></pre><ul><li>网页中常用的字体有宋体、微软雅黑、黑体等，例如将网页中所有段落文本的字体设置为微软雅黑</li><li>可以同时指定多个字体，中间以逗号隔开，表示如果浏览器不支持第一个字体，则会尝试下一个，直到找到合适的字体， 如果都没有，则以我们电脑默认的字体为准。</li></ul><pre><code>p&#123;font-family: Arial,&quot;Microsoft Yahei&quot;, &quot;微软雅黑&quot;;&#125;</code></pre><blockquote><p>常用技巧：</p><ol><li>各种字体之间必须使用英文状态下的逗号隔开。</li><li>中文字体需要加英文状态下的引号，英文字体一般不需要加引号。当需要设置英文字体时，英文字体名必须位于中文字体名之前。</li><li>如果字体名中包含空格、#、$等符号，则该字体必须加英文状态下的单引号或双引号，例如 font-family: “Times New Roman”;。</li><li>尽量使用系统默认字体，保证在任何用户的浏览器中都能正确显示。</li></ol></blockquote><h3 id=""><a href="#" class="headerlink" title=""></a></h3><blockquote><p>CSS Unicode 字体</p></blockquote><ul><li><p>为什么使用 Unicode 字体</p><ul><li>在 CSS 中设置字体名称，直接写中文是可以的。但是在文件编码（GB2312、UTF-8 等）不匹配时会产生乱码的错误。</li><li>xp 系统不支持 类似微软雅黑的中文。</li></ul></li><li><p>解决方案一： 你可以使用英文来替代。 比如<code>font-family:&quot;Microsoft Yahei&quot;</code>。</p></li><li><p>解决方案二： 在 CSS 直接使用 Unicode 编码来写字体名称可以避免这些错误。使用 Unicode 写中文字体名称，浏览器是可以正确的解析的，记住！是在 CSS 里面</p></li></ul><pre><code class="css">font-family: &quot;\5FAE\8F6F\96C5\9ED1&quot;;   表示设置字体为“微软雅黑”。</code></pre><table><thead><tr><th>字体名称</th><th>英文名称</th><th>Unicode 编码</th></tr></thead><tbody><tr><td>宋体</td><td>SimSun</td><td>\5B8B\4F53</td></tr><tr><td>新宋体</td><td>NSimSun</td><td>\65B0\5B8B\4F53</td></tr><tr><td>黑体</td><td>SimHei</td><td>\9ED1\4F53</td></tr><tr><td>微软雅黑</td><td>Microsoft YaHei</td><td>\5FAE\8F6F\96C5\9ED1</td></tr><tr><td>楷体_GB2312</td><td>KaiTi_GB2312</td><td>\6977\4F53_GB2312</td></tr><tr><td>隶书</td><td>LiSu</td><td>\96B6\4E66</td></tr><tr><td>幼园</td><td>YouYuan</td><td>\5E7C\5706</td></tr><tr><td>华文细黑</td><td>STXihei</td><td>\534E\6587\7EC6\9ED1</td></tr><tr><td>细明体</td><td>MingLiU</td><td>\7EC6\660E\4F53</td></tr><tr><td>新细明体</td><td>PMingLiU</td><td>\65B0\7EC6\660E\4F53</td></tr></tbody></table><p>为了照顾不同电脑的字体安装问题，我们尽量只使用宋体和微软雅黑中文字体</p><h3 id="font-weight"><a href="#font-weight" class="headerlink" title="font-weight"></a>font-weight</h3><ul><li>在 html 中使用 b 和 strong 标签是文本加粗。</li><li>可以使用 CSS 来实现，但是 CSS 是没有语义的。<table><thead><tr><th>属性值</th><th align="left">描述</th></tr></thead><tbody><tr><td>normal</td><td align="left">默认值（不加粗的）</td></tr><tr><td>bold</td><td align="left">定义粗体（加粗的）</td></tr><tr><td>100~900</td><td align="left">400 等同于 normal，而 700 等同于 bold</td></tr></tbody></table></li></ul><h3 id="font-style"><a href="#font-style" class="headerlink" title="font-style"></a>font-style</h3><ul><li>在 html 中字体倾斜用 i 和 em 标签，</li><li>可以使用 CSS 来实现，但是 CSS 是没有语义的</li></ul><p>font-style 属性用于定义字体风格，如设置斜体、倾斜或正常字体，其可用属性值如下：</p><table><thead><tr><th>属性</th><th align="left">作用</th></tr></thead><tbody><tr><td>normal</td><td align="left">默认值，浏览器会显示标准的字体样式 font-style: normal;</td></tr><tr><td>italic</td><td align="left">浏览器会显示斜体的字体样式。</td></tr></tbody></table><h3 id="font-综合设置"><a href="#font-综合设置" class="headerlink" title="font 综合设置"></a>font 综合设置</h3><ul><li>基本语法格式如下：</li></ul><pre><code class="css">选择器 &#123;  font: font-style font-weight font-size/line-height font-family;&#125;</code></pre><ul><li>使用 font 属性时，必须按上面语法格式中的顺序书写，不能更换顺序，各个属性以<strong>空格</strong>隔开。</li><li>其中不需要设置的属性可以省略（取默认值），但必须保留 font-size 和 font-family 属性，否则 font 属性将不起作用。</li></ul><h3 id="color"><a href="#color" class="headerlink" title="color"></a>color</h3><ul><li>作用：color 属性用于定义文本的颜色，</li><li>一般选用十六进制的</li><li>其取值方式有如下 3 种：</li></ul><table><thead><tr><th align="left">表示表示</th><th align="left">属性值</th></tr></thead><tbody><tr><td align="left">预定义的颜色值</td><td align="left">red，green，blue，还有我们的御用色 pink</td></tr><tr><td align="left">十六进制</td><td align="left">#FF0000，#FF6600，#29D794</td></tr><tr><td align="left">RGB 代码</td><td align="left">rgb(255,0,0)或 rgb(100%,0%,0%)</td></tr></tbody></table><h3 id="text-align"><a href="#text-align" class="headerlink" title="text-align"></a>text-align</h3><ul><li><p>文本水平对齐方式：text-align 属性用于设置文本内容的水平对齐，相当于 html 中的 align 对齐属性</p></li><li><p>其可用属性值如下：</p></li></ul><table><thead><tr><th>属性</th><th align="center">解释</th></tr></thead><tbody><tr><td>left</td><td align="center">左对齐（默认值）</td></tr><tr><td>right</td><td align="center">右对齐</td></tr><tr><td>center</td><td align="center">居中对齐</td></tr></tbody></table><ul><li>注意：<br>是让盒子里面的内容水平居中， 而不是让盒子居中对齐</li></ul><h3 id="TODO-line-height"><a href="#TODO-line-height" class="headerlink" title="TODO: line-height"></a>TODO: line-height</h3><ul><li><p>行间距：line-height 属性用于设置行间距，就是行与行之间的距离，即字符的垂直间距，一般称为行高。</p></li><li><p>单位：line-height 常用的属性值单位有三种，分别为像素 px，相对值 em 和百分比%，实际工作中使用最多的是像素 px</p></li></ul><pre><code>一般情况下，行距比字号大7.8像素左右就可以了。line-height: 24px;</code></pre><h3 id="text-indent"><a href="#text-indent" class="headerlink" title="text-indent"></a>text-indent</h3><ul><li><p>作用：text-indent 属性用于设置首行文本的缩进，</p></li><li><p>其属性值可为不同单位的数值、em 字符宽度的倍数、或相对于浏览器窗口宽度的百分比%，允许使用负值,</p></li><li><p>建议使用 em 作为设置单位，<strong>1em 就是一个字的宽度 如果是汉字的段落， 1em 就是一个汉字的宽度</strong></p></li></ul><pre><code class="css">p &#123;  /*行间距*/  line-height: 25px;  /*首行缩进2个字  em  1个em 就是1个字的大小*/  text-indent: 2em;&#125;</code></pre><h3 id="text-decoration"><a href="#text-decoration" class="headerlink" title="text-decoration"></a>text-decoration</h3><ul><li>text-decoration 通常我们用于给链接修改装饰效果<table><thead><tr><th>值</th><th>描述</th></tr></thead><tbody><tr><td>none</td><td>默认。定义标准的文本。 取消下划线（最常用）</td></tr><tr><td>underline</td><td>定义文本下的一条线。下划线 也是我们链接自带的（常用）</td></tr><tr><td>overline</td><td>定义文本上的一条线。（不用）</td></tr><tr><td>line-through</td><td>定义穿过文本下的一条线。（不常用）</td></tr></tbody></table></li></ul><h2 id="背景相关"><a href="#背景相关" class="headerlink" title="背景相关"></a>背景相关</h2><h3 id="background-color"><a href="#background-color" class="headerlink" title="background-color"></a>background-color</h3><ul><li>background-color: 颜色值;</li><li>默认的值是 transparent   透明的</li></ul><h3 id="background-image"><a href="#background-image" class="headerlink" title="background-image"></a>background-image</h3><ul><li>background-image : url(images/demo.png);</li><li>背景图片后面的地址，url 不要加引号。</li></ul><pre><code class="css">background-image: none | url (url);</code></pre><table><thead><tr><th>参数</th><th align="center">作用</th></tr></thead><tbody><tr><td>none</td><td align="center">无背景图（默认的）</td></tr><tr><td>url</td><td align="center">使用绝对或相对地址指定背景图像</td></tr></tbody></table><h3 id="background-repeat"><a href="#background-repeat" class="headerlink" title="background-repeat"></a>background-repeat</h3><ul><li>语法：</li></ul><pre><code class="css">background-repeat: repeat | no-repeat | repeat-x | repeat-y;</code></pre><table><thead><tr><th>参数</th><th align="center">作用</th></tr></thead><tbody><tr><td>repeat</td><td align="center">背景图像在纵向和横向上平铺（默认的）</td></tr><tr><td>no-repeat</td><td align="center">背景图像不平铺</td></tr><tr><td>repeat-x</td><td align="center">背景图像在横向上平铺</td></tr><tr><td>repeat-y</td><td align="center">背景图像在纵向平铺</td></tr></tbody></table><h3 id="background-position"><a href="#background-position" class="headerlink" title="background-position"></a>background-position</h3><ul><li>语法：</li></ul><pre><code class="css">background-position : length || lengthbackground-position : position || position</code></pre><ul><li><p>参数解释</p><table><thead><tr><th>参数</th><th align="center">值</th></tr></thead><tbody><tr><td>length</td><td align="center">百分数</td></tr><tr><td>position</td><td align="center">top</td></tr></tbody></table></li><li><p>必须先指定 background-image 属性</p></li><li><p>position 后面是 x 坐标和 y 坐标。 可以使用方位名词或者 精确单位。</p></li><li><p>如果指定两个值，两个值都是方位名字，则两个值前后顺序无关，比如 left top 和 top left 效果一致</p></li><li><p>如果只指定了一个方位名词，另一个值默认居中对齐。</p></li><li><p>如果 position 后面是精确坐标， 那么第一个，肯定是 x 第二的一定是 y</p></li><li><p>如果只指定一个数值,那该数值一定是 x 坐标，另一个默认垂直居中</p></li><li><p>如果指定的两个值是 精确单位和方位名字混合使用，则第一个值是 x 坐标，第二个值是 y 坐标</p></li><li><p><strong>实际工作用的最多的，就是背景图片居中对齐了。</strong></p></li></ul><h3 id="background-attachment"><a href="#background-attachment" class="headerlink" title="background-attachment"></a>background-attachment</h3><ul><li><p>背景附着就是解释背景是滚动的还是固定的</p></li><li><p>语法：</p></li></ul><pre><code class="css">background-attachment: scroll | fixed;</code></pre><table><thead><tr><th>参数</th><th align="center">作用</th></tr></thead><tbody><tr><td>scroll</td><td align="center">背景图像是随对象内容滚动</td></tr><tr><td>fixed</td><td align="center">背景图像固定</td></tr></tbody></table><h3 id="background-size"><a href="#background-size" class="headerlink" title="background-size"></a>background-size</h3><blockquote><p>background-size 属性规定背景图像的尺寸</p></blockquote><ul><li>两个参数：分别是长度和宽度</li><li>一个参数：就是宽度，高度跟着宽度等比拉伸</li><li><strong>也可以是百分比，相对父盒子</strong></li><li>cover：类似按着右下角光标，把背景图像扩展至足够大，以使背景图像完全覆盖背景区域。</li><li>contain：把图像扩展至最大尺寸，以使其宽度和高度完全适应内容区域</li></ul><h3 id="背景简写"><a href="#背景简写" class="headerlink" title="背景简写"></a>背景简写</h3><ul><li>background：属性的值的书写顺序官方并没有强制标准的。</li><li>background: 背景颜色 背景图片地址 背景平铺 背景滚动 背景位置;</li><li>语法：</li></ul><pre><code class="css">background: blue url(image.jpg) repeat-y scroll center top;</code></pre><h3 id="背景透明-CSS3"><a href="#背景透明-CSS3" class="headerlink" title="背景透明(CSS3)"></a>背景透明(CSS3)</h3><ul><li>语法：</li></ul><pre><code class="css">background: rgba(0, 0, 0, 0);</code></pre><ul><li>最后一个参数是 alpha 透明度 取值范围 0~1 之间</li><li>我们习惯把 0.3 的 0 省略掉 这样写 background: rgba(0, 0, 0, .3);</li><li>注意： 背景半透明是指盒子背景半透明， 盒子里面的内容不受影响</li><li>因为是 CSS3 ，所以 低于 ie9 的版本是不支持的。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Language </category>
          
          <category> CSS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>HTML5总结</title>
      <link href="blog/vxz6aq7m0szt/"/>
      <url>blog/vxz6aq7m0szt/</url>
      
        <content type="html"><![CDATA[<h2 id="HTML5"><a href="#HTML5" class="headerlink" title="HTML5"></a>HTML5</h2><div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">新版本的 HTML 语言，定义了新的标签、特性和属性</div><h3 id="常用文档"><a href="#常用文档" class="headerlink" title="常用文档"></a>常用文档</h3><blockquote><p>W3C : <a href="http://www.w3school.com.cn/">http://www.w3school.com.cn/</a><br>MDN: <a href="https://developer.mozilla.org/zh-CN/">https://developer.mozilla.org/zh-CN/</a><br>菜鸟：<a href="https://www.runoob.com/">https://www.runoob.com/</a></p></blockquote><h3 id="扩展的内容"><a href="#扩展的内容" class="headerlink" title="扩展的内容"></a>扩展的内容</h3><ul><li>语义化标签</li><li>本地存储</li><li>兼容特性</li><li>2D、3D</li><li>动画、过渡</li><li>CSS3 特性</li><li>性能与集成</li></ul><h2 id="HTML5-文档结构-语义化标签"><a href="#HTML5-文档结构-语义化标签" class="headerlink" title="HTML5 文档结构/语义化标签"></a>HTML5 文档结构/语义化标签</h2><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616663386514-c6d53c70-d47f-4e40-b6f8-4a0f0596489b.png#align=left&display=inline&height=215&margin=%5Bobject%20Object%5D&name=image.png&originHeight=429&originWidth=669&size=51321&status=done&style=stroke&width=334.5" alt="image.png"></p><ul><li><a href="https://www.jianshu.com/p/c41b88217834">https://www.jianshu.com/p/c41b88217834</a></li><li><a href="https://juejin.cn/post/6844903544995184653">https://juejin.cn/post/6844903544995184653</a></li></ul><h2 id="lt-DOCTYPE-gt"><a href="#lt-DOCTYPE-gt" class="headerlink" title="&lt;!DOCTYPE&gt;"></a>&lt;!DOCTYPE&gt;</h2><ul><li>html5 的文档类型声明：声明位于文档中的最前面的位置，处于 标签之前。此标签可告知浏览器文档使用哪种 HTML 或 XHTML 规范。</li><li>一些老网站可能用的还是老版本的文档类型比如 XHTML 之类的，但是我们学的是 HTML5,而且 HTML5 的文档类型兼容很好(向下兼容的原则)</li></ul><h2 id="charset"><a href="#charset" class="headerlink" title="charset"></a>charset</h2><ul><li>html5 文档编码格式的指定</li></ul><pre><code class="html">&lt;meta charset=&quot;UTF-8&quot; /&gt;</code></pre><blockquote><p>字符集(Character set)是多个字符的集合。<br>计算机要准确的处理各种字符集文字，需要进行字符编码，以便计算机能够识别和存储各种文字。</p></blockquote><p>utf-8 是目前最常用的字符集编码方式，常用的字符集编码方式还有 gbk 和 gb2312。</p><ul><li>gb2312 简单中文 包括 6763 个汉字</li><li>BIG5 繁体中文 港澳台等用</li><li>GBK 包含全部中文字符 是 GB2312 的扩展，加入对繁体字的支持，兼容 GB2312</li><li>UTF-8 则基本包含全世界所有国家需要用到的字符</li></ul><h2 id="多媒体音频标签"><a href="#多媒体音频标签" class="headerlink" title="多媒体音频标签"></a>多媒体音频标签</h2><ol><li>多媒体标签有两个，分别是</li></ol><ul><li>音频  – <code>audio</code></li><li>视频  – <code>video</code></li></ul><ol start="2"><li><code>audio</code> 标签说明</li></ol><ul><li>可以在不使用标签的情况下，也能够原生的支持音频格式文件的播放，</li><li>但是：播放格式是有限的</li></ul><ol start="3"><li><p>audio 支持的音频格式</p><ul><li>audio 目前支持三种格式</li></ul></li><li><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1615560874331-7786480d-ad33-403e-976d-73e235a0f3ec.png#align=left&display=inline&height=130&margin=%5Bobject%20Object%5D&name=image.png&originHeight=260&originWidth=1179&size=48950&status=done&style=none&width=589.5" alt="image.png"></p></li><li><p>audio 的参数<img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1615560883989-c202ee16-7e45-4c86-ac47-3e3ba07fc2a7.png#align=left&display=inline&height=210&margin=%5Bobject%20Object%5D&name=image.png&originHeight=420&originWidth=1203&size=105644&status=done&style=none&width=601.5" alt="image.png"></p></li></ol><p>5、audio 代码演示</p><pre><code class="css">&lt;body&gt;  &lt;!-- 注意：在 chrome 浏览器中已经禁用了 autoplay 属性 --&gt;  &lt;!-- &lt;audio src=&quot;./media/snow.mp3&quot; controls autoplay&gt;&lt;/audio&gt; --&gt;  &lt;!--    因为不同浏览器支持不同的格式，所以我们采取的方案是这个音频准备多个文件   --&gt;  &lt;audio controls&gt;    &lt;source src=&quot;./media/snow.mp3&quot; type=&quot;audio/mpeg&quot; /&gt;  &lt;/audio&gt;&lt;/body&gt;</code></pre><h2 id="多媒体视频标签"><a href="#多媒体视频标签" class="headerlink" title="多媒体视频标签"></a>多媒体视频标签</h2><ol><li>video 视频标签<ul><li>目前支持三种格式</li></ul></li><li><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1615560894436-db88d851-871b-4758-9b78-9b9892711139.png#align=left&display=inline&height=141&margin=%5Bobject%20Object%5D&name=image.png&originHeight=281&originWidth=1211&size=137376&status=done&style=none&width=605.5" alt="image.png"></li><li>语法格式</li></ol><pre><code class="html">&lt;video src=&quot;./media/video.mp4&quot; controls=&quot;controls&quot;&gt;&lt;/video&gt;</code></pre><ol><li>video 参数<img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1615560905874-4a6cc88d-8941-4f8c-9c89-05ce01e229fb.png#align=left&display=inline&height=301&margin=%5Bobject%20Object%5D&name=image.png&originHeight=602&originWidth=1193&size=396225&status=done&style=none&width=596.5" alt="image.png"></li><li>video 代码演示</li></ol><pre><code class="html">&lt;body&gt;  &lt;!-- &lt;video src=&quot;./media/video.mp4&quot; controls=&quot;controls&quot;&gt;&lt;/video&gt; --&gt;  &lt;!-- 谷歌浏览器禁用了自动播放功能，如果想自动播放，需要添加 muted 属性 --&gt;  &lt;video controls=&quot;controls&quot; autoplay muted loop poster=&quot;./media/pig.jpg&quot;&gt;    &lt;source src=&quot;./media/video.mp4&quot; type=&quot;video/mp4&quot; /&gt;    &lt;source src=&quot;./media/video.ogg&quot; type=&quot;video/ogg&quot; /&gt;  &lt;/video&gt;&lt;/body&gt;</code></pre><ol><li>多媒体标签总结</li></ol><ul><li>音频标签与视频标签使用基本一致</li><li>多媒体标签在不同浏览器下情况不同，存在兼容性问题</li><li>谷歌浏览器把音频和视频标签的自动播放都禁止了</li><li>谷歌浏览器中视频添加 muted 标签可以自己播放</li><li>注意：重点记住使用方法以及自动播放即可，其他属性可以在使用时查找对应的手册</li></ul><h2 id="新增-input-标签"><a href="#新增-input-标签" class="headerlink" title="新增 input 标签"></a>新增 input 标签</h2><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1615560920848-b6218b7e-57ed-4da9-889e-ff00dd8df1c2.png#align=left&display=inline&height=376&margin=%5Bobject%20Object%5D&name=image.png&originHeight=752&originWidth=1259&size=176698&status=done&style=none&width=629.5" alt="image.png"></p><h2 id="新增表单属性"><a href="#新增表单属性" class="headerlink" title="新增表单属性"></a>新增表单属性</h2><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1615560931257-0c5b2693-9baf-4129-a502-e22ebc14c89e.png#align=left&display=inline&height=251&margin=%5Bobject%20Object%5D&name=image.png&originHeight=502&originWidth=1217&size=155890&status=done&style=none&width=608.5" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> Language </category>
          
          <category> HTML </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>HTML总结</title>
      <link href="blog/vtwy70ohpnm5/"/>
      <url>blog/vtwy70ohpnm5/</url>
      
        <content type="html"><![CDATA[<h2 id="常用文档"><a href="#常用文档" class="headerlink" title="常用文档"></a>常用文档</h2><blockquote><p>W3C : <a href="http://www.w3school.com.cn/">http://www.w3school.com.cn/</a><br>MDN: <a href="https://developer.mozilla.org/zh-CN/">https://developer.mozilla.org/zh-CN/</a><br>菜鸟：<a href="https://www.runoob.com/">https://www.runoob.com/</a></p></blockquote><h2 id="排版标签"><a href="#排版标签" class="headerlink" title="排版标签"></a>排版标签</h2><ul><li>h：标题</li><li>p：段落</li><li>hr（单）：横线</li><li>br（单）：换行</li><li>blockquote：引用</li><li>pre：预定义格式<blockquote><p>标签可定义预格式化的文本。 被包围在   标签 元素中的文本通常会保留空格和换行符。而文本也会呈现为等宽字体。</p></blockquote></li></ul><h2 id="文本格式化标签"><a href="#文本格式化标签" class="headerlink" title="文本格式化标签"></a>文本格式化标签</h2><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611547659083-2c64e035-b906-47c8-84e1-67b8e747e361.png#align=left&display=inline&height=434&margin=%5Bobject%20Object%5D&originHeight=434&originWidth=1054&status=done&style=none&width=1054"></p><ul><li>b 只是加粗 strong 除了可以加粗还有 强调的意思，语义更强烈。</li></ul><h2 id="img（单）"><a href="#img（单）" class="headerlink" title="img（单）"></a>img（单）</h2><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611547659339-b5fd80fe-ed24-42d9-8d70-ab9fe086449d.png#align=left&display=inline&height=439&margin=%5Bobject%20Object%5D&originHeight=439&originWidth=997&status=done&style=none&width=997"><br>border 后面我们会用 css 来做，这里童鞋们就记住这个 border 单词就好了<br>**注意: **</p><ol><li>标签可以拥有多个属性，必须写在开始标签中，位于标签名后面。</li><li>属性之间不分先后顺序，标签名与属性、属性与属性之间均以空格分开。</li><li>任何标签的属性都有默认值，省略该属性则取默认值。</li><li>采取 键值对 的格式 key=”value” 的格式</li></ol><p>比如:<br>此处有练习题<br><strong>重点掌握点：</strong></p><ul><li>请说出 图像标签那个属性是必须要写的？ img src 图片的路径</li><li>请说出 图像标签中 alt 和 title 属性区别？ alt 图片显示不出，文字就显示 title 鼠标经过图片的时候显示文字</li></ul><h2 id="a"><a href="#a" class="headerlink" title="a**"></a>a**</h2><ul><li>href：必须要的属性</li><li>target=“_blank”：新窗口打开</li></ul><h2 id="div-和-span"><a href="#div-和-span" class="headerlink" title="div 和 span"></a>div 和 span</h2><blockquote><p>标准流布局</p></blockquote><ul><li>div 标签 用来布局的，但是现在一行只能放一个 div</li><li>span 标签 用来布局的，一行上可以放好多个 span</li></ul><h2 id="base"><a href="#base" class="headerlink" title="base"></a>base</h2><ul><li>base 可以设置整体链接的打开状态<blockquote><p>最常用的就是<base target="_blank" /></p></blockquote></li></ul><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="lang"><a href="#lang" class="headerlink" title="lang"></a>lang</h2><pre><code class="html">&lt;html lang=&quot;en&quot;&gt;  指定html 语言种类&lt;/html&gt;</code></pre><p>最常见的 2 个：</p><ol><li><code>en</code>定义语言为英语</li><li><code>zh-CN</code>定义语言为中文</li></ol><ul><li>指定该 html 标签 内容 所用的语言为中文**</li><li>简单来说，可能对于程序来说没有太大的作用，但是它可以告诉浏览器，搜索引擎，一些处理 Html 的程序对页面语言内容来做一些对应的处理或者事情。</li></ul><h2 id="table"><a href="#table" class="headerlink" title="table"></a>table</h2><h3 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h3><ul><li>展示数据</li><li>让数据显示整齐规范</li><li>表格属性需要注意的</li></ul><p>平时开发的我们这三个参数 border、cellpadding、cellspacing 为 0，但在 HTML5 里面，后两者属性设置无效，利用 <code>border-collapse: collapse;</code> 来设置，将 th 和 td 设置为 0</p><ul><li>浏览器会默认包裹 tbody 标签</li><li>HTML5 里面用 thead,tbody,tfoot 来标注内容，更加清晰**</li></ul><h3 id="合并单元格"><a href="#合并单元格" class="headerlink" title="合并单元格"></a>合并单元格</h3><p>合并单元格是我们比较常用的一个操作，但是不会合并的很复杂。</p><blockquote><p>【1】合并单元格 2 种方式</p></blockquote><ul><li>跨行合并：rowspan=”合并单元格的个数”</li><li>跨列合并：colspan=”合并单元格的个数”<blockquote><p>【2】合并单元格顺序<br>**合并的顺序我们按照 先上 后下 先左 后右 的顺序 **</p></blockquote></li></ul><p>跟我们以前学习汉字的书写顺序完全一致。</p><blockquote><p>【3】合并单元格三步曲</p></blockquote><ol><li>先确定是跨行还是跨列合并</li><li>根据 先上 后下 先左 后右的原则找到目标单元格 然后写上 合并方式 还有 要合并的单元格数量 比如 ：</li><li>删除多余的单元格 单元格</li></ol><h2 id="ul、ol、dl"><a href="#ul、ol、dl" class="headerlink" title="ul、ol、dl"></a>ul、ol、dl</h2><h3 id="去掉列表默认的样式"><a href="#去掉列表默认的样式" class="headerlink" title="去掉列表默认的样式"></a>去掉列表默认的样式</h3><p>无序和有序列表前面默认的列表样式，在不同浏览器显示效果不一样，而且也比较难看，所以，我们一般上来就直接去掉这些列表样式就行了。 代码如下</p><pre><code class="css">li &#123;  list-style: none;&#125;</code></pre><h2 id="form"><a href="#form" class="headerlink" title="form"></a>form</h2><ul><li>表单目的是为了收集用户信息。</li></ul><p>在我们网页中， 我们也需要跟用户进行交互，收集用户资料，此时也需要表单。</p><blockquote><p>在 HTML 中，一个完整的表单通常由表单控件（也称为表单元素）、提示信息和表单域 3 个部分构成。</p></blockquote><ul><li>**表单控件： **包含了具体的表单功能项，如单行文本输入框、密码输入框、复选框、提交按钮、重置按钮等。</li><li><strong>提示信息：</strong>一个表单中通常还需要包含一些说明性的文字，提示用户进行填写和操作。</li><li><strong>表单域：</strong>他相当于一个容器，用来容纳所有的表单控件和提示信息，可以通过他定义处理表单数据所用程序的 url 地址，以及数据提交到服务器的方法。如果不定义表单域，表单中的数据就无法传送到后台服务器。</li></ul><h3 id="input"><a href="#input" class="headerlink" title="input"></a>input</h3><ul><li>常用属性：</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611547661035-9721cb68-5232-4cbf-8bf5-01b447ed3f3f.png#align=left&display=inline&height=456&margin=%5Bobject%20Object%5D&originHeight=456&originWidth=950&status=done&style=none&width=950"></p><ul><li><p>value 默认的文本值。 有些表单想刚打开页面就默认显示几个文字，就可以通过这个 value 来设置。</p><blockquote><p>name 属性后面的值，是我们自己定义的。</p></blockquote></li><li><p>name 表单的名字， 这样，后台可以通过这个 name 属性找到这个表单。 页面中的表单很多，name 主要作用就是用于区别不同的表单。</p></li><li><p>radio 如果是一组，我们必须给他们命名相同的名字 name 这样就可以在同一个组里面多个选其中的一个</p></li><li><p>name 属性，我们现在用的较少， 但是，当我们学 ajax 和后台的时候，是必须的。</p><blockquote><p>checked 属性</p></blockquote></li><li><p>默认选中状态。 较常见于 单选按钮和复选按钮。</p></li></ul><h3 id="label"><a href="#label" class="headerlink" title="label"></a>label</h3><ul><li>用于绑定一个表单元素, 当点击 label 标签的时候, 被绑定的表单元素就会获得输入焦点。<blockquote><p>两种绑定方式</p></blockquote></li></ul><ol><li>第一种用法就是用 label 直接包括 input 表单。</li></ol><pre><code class="html">&lt;label&gt;  用户名： &lt;input type=&quot;radio&quot; name=&quot;usename&quot; value=&quot;请输入用户名&quot; /&gt;&lt;/label&gt;</code></pre><p>适合单个表单选择</p><ol start="2"><li>第二种用法 for 属性规定 label 与哪个表单元素绑定。</li></ol><pre><code class="html">&lt;label for=&quot;sex&quot;&gt;男&lt;/label&gt; &lt;input type=&quot;radio&quot; name=&quot;sex&quot; id=&quot;sex&quot; /&gt;</code></pre><h3 id="textarea"><a href="#textarea" class="headerlink" title="textarea"></a>textarea</h3><h3 id="select"><a href="#select" class="headerlink" title="select**"></a>select**</h3><ul><li><select> 中至少包含一对 option</li><li>在 option 中定义 selected =” selected “时，当前项即为默认选中项。</li><li>但是我们实际开发会用的比较少</li></ul><h3 id="form-表单域"><a href="#form-表单域" class="headerlink" title="form 表单域"></a>form 表单域</h3><ul><li><p>收集的用户信息怎么传递给服务器：通过 form 表单域</p></li><li><p>目的：在 HTML 中，form 标签被用于定义表单域，以实现用户信息的收集和传递，form 中的所有内容都会被提交给服务器。</p></li></ul><pre><code class="html">&lt;form action=&quot;url地址&quot; method=&quot;提交方式&quot; name=&quot;表单名称&quot;&gt;各种表单控件&lt;/form&gt;</code></pre><ul><li>每一个 form 至少含有一个 submit 类型的 input 标签（点击 submit 提交到 form 中的 action 地址当中），然后接收的 html 页面（服务端）利用类似以下的代码进行处理 url 得到前者页面所传过来的参数，以便在服务端进行利用</li></ul><pre><code class="javascript">&lt;script&gt;  console.log(location.search); // ?uname=andy // 1.先去掉？  substr(&#39;起始的位置&#39;，截取几个字符); var params = location.search.substr(1); //  uname=andy console.log(params); // 2. 利用=把字符串分割为数组 split(&#39;=&#39;); var  arr = params.split(&#39;=&#39;); console.log(arr); // [&quot;uname&quot;, &quot;ANDY&quot;] var div =  document.querySelector(&#39;div&#39;); // 3.把数据写入div中 div.innerHTML = arr[1] +  &#39;欢迎您&#39;;&lt;/script&gt;</code></pre><ul><li><p><strong>常用属性</strong></p><table><thead><tr><th>属性</th><th align="left">属性值</th><th>作用</th></tr></thead><tbody><tr><td>action</td><td align="left">url 地址</td><td>用于指定接收并处理表单数据的服务器程序的 url 地址。</td></tr><tr><td>method</td><td align="left">get/post</td><td>用于设置表单数据的提交方式，其取值为 get 或 post。</td></tr><tr><td>name</td><td align="left">名称</td><td>用于指定表单的名称，以区分同一个页面中的多个表单。</td></tr></tbody></table></li><li><p>每个表单都应该有自己表单域。我们现在做页面，不写看不到效果，但是 如果后面学 ajax 后台交互的时候，必须需要 form 表单域。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Language </category>
          
          <category> HTML </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>P674. 最长连续递增序列</title>
      <link href="blog/guaorh/"/>
      <url>blog/guaorh/</url>
      
        <content type="html"><![CDATA[<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><pre><code class="java">package com.wztlink1013.problems.leetcode.editor.cn;// P674.最长连续递增序列// P674.longest-continuous-increasing-subsequence//给定一个未经排序的整数数组，找到最长且 连续递增的子序列，并返回该序列的长度。//// 连续递增的子序列 可以由两个下标 l 和 r（l &lt; r）确定，如果对于每个 l &lt;= i &lt; r，都有 nums[i] &lt; nums[i + 1] ，那//么子序列 [nums[l], nums[l + 1], ..., nums[r - 1], nums[r]] 就是连续递增子序列。//////// 示例 1：//////输入：nums = [1,3,5,4,7]//输出：3//解释：最长连续递增序列是 [1,3,5], 长度为3。//尽管 [1,3,5,7] 也是升序的子序列, 但它不是连续的，因为 5 和 7 在原数组里被 4 隔开。////// 示例 2：//////输入：nums = [2,2,2,2,2]//输出：1//解释：最长连续递增序列是 [2], 长度为1。////////// 提示：////// 0 &lt;= nums.length &lt;= 104// -109 &lt;= nums[i] &lt;= 109//// Related Topics 数组// 👍 147 👎 0public class P674LongestContinuousIncreasingSubsequence&#123;    public static void main(String[] args) &#123;        Solution solution = new P674LongestContinuousIncreasingSubsequence().new Solution();        int [] nums = &#123;1,3,5,7&#125;;        int result = solution.findLengthOfLCIS(nums);        System.out.println(result);    &#125;//leetcode submit region begin(Prohibit modification and deletion)class Solution &#123;    public int findLengthOfLCIS(int[] nums) &#123;        if (nums.length == 0) &#123; return 0; &#125;        int result = 1;        int count = 1;        for (int i=0; i&lt;nums.length-1; i++) &#123;            if (nums[i] &lt; nums[i+1] ) &#123;                count++;                if (result &lt; count) &#123;result = count;&#125;            &#125; else &#123;                if (result &lt; count) &#123;result = count;&#125;                count = 1;            &#125;        &#125;        return result;    &#125;&#125;//leetcode submit region end(Prohibit modification and deletion)&#125;</code></pre><h2 id="细节注意"><a href="#细节注意" class="headerlink" title="细节注意"></a>细节注意</h2><ul><li>56 行 count++</li><li>将 57 和 59 行代码删去，改为如下表达式赋值</li></ul><pre><code class="java">result = count &gt; result ? count : result;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
          <category> Problems </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>🔒尼采般地抒情主题</title>
      <link href="blog/kh2axb/"/>
      <url>blog/kh2axb/</url>
      
        <content type="html"><![CDATA[<p>这是加密文章！</p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Web开发学习路线</title>
      <link href="blog/zt3hsu/"/>
      <url>blog/zt3hsu/</url>
      
        <content type="html"><![CDATA[<h2 id="一些参考链接"><a href="#一些参考链接" class="headerlink" title="一些参考链接"></a>一些参考链接</h2><ul><li><a href="https://roadmap.sh/">Developer Roadmaps</a></li><li><a href="https://juejin.cn/post/6844904078825226248#heading-11">2020 年最新前端学习路线</a></li><li><a href="https://study.163.com/curricula/cs.htm">顶尖中文大学计算机专业课程体系</a></li></ul><h2 id="一些练习网站"><a href="#一些练习网站" class="headerlink" title="一些练习网站"></a>一些练习网站</h2><ul><li><a href="https://juejin.cn/post/6844903449222447112">JavaScript 常用练习网站收集</a></li><li><a href="https://segmentfault.com/a/1190000021966814">Web 中高级前端面试题集合（200+）</a></li><li><a href="https://juejin.cn/post/6847902225423925255">2020 最新：100 道有答案的前端面试题（上）</a></li></ul><h2 id="Web-开发者学习路线图"><a href="#Web-开发者学习路线图" class="headerlink" title="Web 开发者学习路线图"></a>Web 开发者学习路线图</h2><blockquote><p>以下路线图主要展示了成为前端开发者、后端开发者或运维开发者的技术学习路线</p></blockquote><h2 id=""><a href="#" class="headerlink" title=""></a><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609833408435-2a3a1e3a-f33f-4584-9273-0914c4a1e245.png#height=464&id=KJn3x&originHeight=464&originWidth=1099&originalType=binary&size=0&status=done&style=stroke&width=1099"></h2><p><img src="https://cdn.nlark.com/yuque/0/2020/jpeg/1484158/1608521842740-7d5b05fb-4fb4-4153-92e1-1fe663cdde21.jpeg#height=1292&id=Qh4iJ&margin=%5Bobject%20Object%5D&name=1607305999286.jpeg&originHeight=1292&originWidth=854&originalType=binary&size=169058&status=done&style=stroke&width=854" alt="1607305999286.jpeg"></p><h2 id="前端学习路线图"><a href="#前端学习路线图" class="headerlink" title="前端学习路线图"></a>前端学习路线图</h2><blockquote><p>主要还是掌握好 HTML、CSS、JavaScript。框架太多不需要多去了解，学习一两个即可，可以多关注 Vue。</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609827489287-7894f725-843f-4b18-81a8-131eeedfe815.png#height=2345&id=pBsKY&originHeight=3449&originWidth=1215&originalType=binary&size=0&status=done&style=stroke&width=826"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609833432771-b6e59488-0e1c-4e89-a751-9ce34c9783db.png#height=1529&id=bgWbL&originHeight=1529&originWidth=1218&originalType=binary&size=0&status=done&style=shadow&width=1218"><br><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1619482675611-cf7c1ab1-fd24-4b59-a24a-b235e93c7bb7.jpeg#height=2484&id=zyEHm&margin=%5Bobject%20Object%5D&name=%E5%8D%83%E9%94%8BHTML5%E5%A4%A7%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E6%94%BB%E7%95%A5.jpg&originHeight=2484&originWidth=3424&originalType=binary&size=3878264&status=done&style=none&width=3424" alt="千锋HTML5大前端学习攻略.jpg"></p><h2 id="后端学习路线图"><a href="#后端学习路线图" class="headerlink" title="后端学习路线图"></a>后端学习路线图</h2><blockquote><p>后端技术还是倾向于 PHP 和 Python。</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609831229139-6055875b-6e13-4556-8952-30bdecf71be7.png#height=2070&id=m2vdK&originHeight=3053&originWidth=1196&originalType=binary&size=0&status=done&style=shadow&width=811"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609833456024-bf2e2f71-7be7-49db-b968-6d883fce8b60.png#height=1882&id=eNVTO&originHeight=1882&originWidth=1285&originalType=binary&size=0&status=done&style=shadow&width=1285"></p><h2 id="运维学习路线图"><a href="#运维学习路线图" class="headerlink" title="运维学习路线图"></a>运维学习路线图</h2><blockquote><p>学好 Linux、Nginx、MySql、Docker。关注各大云服务商，简化的运维成本。</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609833486774-eef202cb-90f0-417b-be9e-d4b68c740155.png#height=1738&id=M00gY&originHeight=1738&originWidth=1360&originalType=binary&size=0&status=done&style=stroke&width=1360"></p>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
          <category> Web其他 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Vue学习笔记</title>
      <link href="blog/qwv5oz/"/>
      <url>blog/qwv5oz/</url>
      
        <content type="html"><![CDATA[<h2 id="一些函数"><a href="#一些函数" class="headerlink" title="一些函数"></a>一些函数</h2><ul><li>this：应该就是创建的 Vue 这个对象， <code>this.message = this.message.split(&#39;&#39;).reverse().join(&#39;&#39;)</code></li><li>字符串函数<ul><li>split()，join()：拆开，组合</li></ul></li><li>component：定义组件<ul><li>data：必须是一个函数，data 选项必须是一个函数，不然</li><li>props：声明为属性，再该组件的 template 下可以直接使用</li><li>template：组件模板</li><li>methods 等等 Vue 属性都有</li></ul></li><li>Object.freeze()：会阻止其响应式更新，系统无法再追踪变化</li><li>＄：用来区分 Vue 实例和变量，Vue 实例用＄， <code>vm.$el === document.getElementById(&#39;example&#39;)</code></li><li>input 里面的 key：防止切换输入形式值不变的情况 <code>&lt;input placeholder=&quot;Enter your username&quot; key=&quot;username-input&quot;&gt;</code></li></ul><h2 id="Vue-实例属性"><a href="#Vue-实例属性" class="headerlink" title="Vue 实例属性"></a>Vue 实例属性</h2><ul><li>el：绑定 dom</li><li>data：数据域</li><li>methods：定义方法</li><li>生命周期相关函数，可以在不同阶段添加不同代码<ul><li>created</li><li>mounted</li><li>updated</li><li>destroyed 等</li></ul></li><li>computed：计算属性</li><li>watch：侦听器</li></ul><h2 id="插值、指令"><a href="#插值、指令" class="headerlink" title="插值、指令"></a>插值、指令</h2><ul><li><p><code>&#123; &#123; </code> <code>&#125; &#125;</code> ：插值为文本</p></li><li><p>v-once：一次性插值</p></li><li><p>v-html：插入并显示为 html 代码</p></li><li><p><strong>v-bind：显示信息【简写：英文冒号:】</strong></p></li><li><p><code>v-on:click=&quot;函数触发&quot;</code> ：事件监听器【简写： <code>@</code> 符号】</p><ul><li>v-on:click=”greet”：其中 greet 是 Vue 实例中 methods 中的一个方法</li><li>事件修饰符</li><li>.stop</li><li>.prevent</li><li>.capture</li><li>.self</li><li>.once</li><li>.passive</li><li>＄ emit：子组件可以使用 $emit 触发父组件的自定义事件。</li><li>vm.$emit( event, arg ) //触发当前实例上的事件</li><li>vm.$on( event, fn );//监听 event 事件后运行 fn</li></ul></li><li><p>v-if=”表达式”：</p><blockquote><p>v-else：搭配用的还可以有<br>v-else-if<br>v-if 优先级弱于 v-for</p></blockquote></li><li><p>v-show：与 v-if 不同的是不管怎样都会被渲染</p></li><li><p>v-for=”num in nums”：循环</p><blockquote><p>支持第二个参数（即索引值）<br>也可以直接循环对象，可以将将对象的各个属性值全部打印出来<br>组件使用 v-for 的时候，key 值是必须的 1</p></blockquote></li><li><p>v-model：表单输入和应用状态之间的双向绑定</p></li></ul><h2 id="数组相关"><a href="#数组相关" class="headerlink" title="数组相关"></a>数组相关</h2><blockquote><p>具体也可以参考 MDN 上的这几个函数介绍</p></blockquote><ul><li><p>push()：对一个对象数组添加一个元素，注意形式 <code>app_test_list.items.push(&#123;text:&quot;用push添加元素&quot;&#125;);</code></p></li><li><p>pop()：</p></li><li><p>shift()</p></li><li><p>unshift()</p></li><li><p>splice()</p></li><li><p>sort()</p></li><li><p>reverse()</p></li><li><p>filter()</p></li><li><p>concat()</p></li><li><p>slice()</p></li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul><li>属性值之间使用冒号</li><li>只有赋值才是等号</li><li>对象内的属性之间用逗号分隔开</li></ul>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
          <category> Vue </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>《软件工程导论》知识总结</title>
      <link href="blog/sc6tzq/"/>
      <url>blog/sc6tzq/</url>
      
        <content type="html"><![CDATA[<div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">大三上期末知识点回顾</div>​<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1623288164521-ad52e1f8-1a29-4976-ac2b-c45d7d5aa773.png#clientId=u1334fe7c-731d-4&from=paste&id=uca9222ff&margin=%5Bobject%20Object%5D&name=image.png&originHeight=500&originWidth=356&originalType=url%E2%88%B6=2&size=280972&status=done&style=none&taskId=uc6edaa46-2a0d-48f3-94df-c35e33a2bab" alt="image.png"></p><h2 id="一、传统方法学"><a href="#一、传统方法学" class="headerlink" title="一、传统方法学"></a>一、传统方法学</h2><blockquote><p>软件工程生命周期</p></blockquote><ol><li>问题定义</li><li>可行性研究</li><li>需求分析</li><li>总体设计</li><li>详细设计</li><li>编码和单元测试</li><li>综合测试</li><li>软件维护</li></ol><h3 id="可行性研究"><a href="#可行性研究" class="headerlink" title="可行性研究"></a>可行性研究</h3><blockquote><p>在了解问题定义之后，将其模型抽离出来，然后对其进行可行性分析，探索若干种解法，对每种解法仔细研究其可行性，从下面几种方面来考虑</p></blockquote><ol><li>技术可行性：能否用现又技术实现？</li><li>经济可行性：软件带来的经济效益能否大于软件的开发成本？</li><li>操作可行性：在用户组织之间是否具有操作可行性？</li></ol><p>必要时还有从法律和社会效益来研究其可行性。</p><blockquote><p>系统流程图<br>数据流图</p></blockquote><blockquote><p>成本/效益分析</p></blockquote><p>成本估计的几种方法</p><ul><li>代码行技术：根据每行代码的平均成本乘以行数就是大概的成本</li><li>任务分解技术：将整个声明周期划分不同阶段，估计每个不同阶段所花费的成本，一般都是各阶段的人数诚意平均工资再加这般</li><li>自动估计成本：根据程序来估计，一般要用到大量数据，才能保证这个估计有效（大数据时代应该很吃香，可以利用所搜集的大量数据来进行建模）</li></ul><p>成本/效益分析的方法</p><ul><li>货币的时间价值：这里面有年利率的概念，就是过 n 年之后，你手中的钱在 n 年之后会提升</li></ul><p>F=P（1+n）^n （P 元钱在 n 年后的价值）</p><ul><li>投资回收期：你所赚的钱等于你所投资的资金所花费的时间越短越好</li><li>纯收入：整个生命周期内，赚的钱减去你投资的钱</li></ul><h3 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h3><blockquote><p>与用户沟通获取需求的方法</p></blockquote><ul><li>访谈</li><li>面向数据流自顶向下求精</li><li>简易的应用规格说明技术</li><li>快速建立软件模型</li></ul><blockquote><p>根据结构化分析准则，需求分析过程应该建立三种模型，它们分别是？以及他们所用到的工具？</p></blockquote><ul><li>数据模型——E-R 图：就是数据库里面学到的实体-联系图</li><li>功能模型——数据流图：描述数据在系统中的转换的逻辑过程</li><li>行为模型——状态转换图：作为外部事件结果的系统行为</li></ul><blockquote><p>其他的工具还有</p></blockquote><ul><li>层次方框图（树形结构）</li><li>Warnier 图{大括号包裹）</li><li>IPO 图（方框-箭头；表格形式）</li></ul><h3 id="形式化说明技术"><a href="#形式化说明技术" class="headerlink" title="形式化说明技术"></a>形式化说明技术</h3><blockquote><p>软件工程所使用的方法可划分为下面三种</p></blockquote><ul><li>非形式化方法：用自然语言描述就是典型的非形式化方法</li><li>半形式化方法：利用 E-R 图描述就是半形式化方法</li><li>形式化方法：用到数学的技术，也就是说，如果一种方法用到坚实的数学基础，那么他就是形式化方法</li></ul><h3 id="总体设计"><a href="#总体设计" class="headerlink" title="总体设计"></a>总体设计</h3><blockquote><p>总体设计又称之为概要设计、初步设计</p></blockquote><blockquote><p>由哪两阶段组成呢？</p></blockquote><ul><li>系统设计阶段：确定系统的具体实现方案</li><li>结构设计阶段：确定软件结构</li></ul><blockquote><p>设计原理</p></blockquote><p><strong>模块</strong>是由边界元素限定的相邻程序元素（数据说明，可执行的语句）的序列，而且有一个总体标识符代表它</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1608815946283-167d2edb-f25b-45de-ade4-6041bddf45c2.png#height=258&id=LdPtL&margin=%5Bobject%20Object%5D&name=image.png&originHeight=516&originWidth=694&originalType=binary%E2%88%B6=1&size=141087&status=done&style=shadow&width=347" alt="image.png"></p><p>模块之间的<strong>独立程度</strong>有两个标准来度量，分别是：</p><p>耦合：度量<strong>模块间</strong>的互相依赖程度</p><p>内聚：度量<strong>模块内部元素间</strong>的结合程度</p><p><strong>尽量使用数据耦合，少用控制耦合和特征耦合，限制公共环境耦合的范围，完全不用内容耦合</strong><br><strong>​</strong></p><p>7 种内聚优劣评分：功能内聚（10 分）偶然内聚（0 分）</p><blockquote><p>描绘软件结构的图形工具</p></blockquote><ul><li>层次图（树状）和 HIPO 图（带编号的层次图）</li><li>结构图</li></ul><blockquote><p>面向数据流的设计方法</p></blockquote><p>概念：面向数据流的设计方法就是把信息流映射成软件结构，同时信息流的结构决定了映射的方法</p><ul><li>变换流</li><li>事务流</li><li>设计过程</li></ul><h3 id="详细设计"><a href="#详细设计" class="headerlink" title="详细设计"></a>详细设计</h3><blockquote><p>结构程序设计</p></blockquote><p>只用 3 种控制结构就能实现任何单入口单出口的程序，这三种结构分别是顺序结构、选择结构、循环结构</p><blockquote><p>人机界面设计的设计问题有：</p></blockquote><ul><li>系统响应时间</li><li>用户帮助实施</li><li>出错信息处理</li><li>命令交互</li></ul><blockquote><p>人机界面设计的设计指南：</p></blockquote><ul><li>一般交互指南</li><li>信息显示指南</li><li>数据输入指南</li></ul><blockquote><p>过程设计的工具【重要】</p></blockquote><ol><li>程序流程图</li><li>盒图（N-S 图）</li><li>PAD 图</li><li>判定表</li><li>判定树</li><li>过程设计语言</li></ol><blockquote><p>面向数据结构的设计方法</p></blockquote><p><strong>两个最著名的方法为：Jackson 方法和 Warnier 方法</strong><br><strong>​</strong></p><blockquote><p>Jackson 方法</p></blockquote><p>只有顺序、选择、重复三种结构</p><p>要会用伪代码表示</p><blockquote><p>程序复杂程度的定量度量有 McCabe 方法和 Halstead 方法，只介绍前者</p></blockquote><ol><li>流图（给出伪代码画流图）</li><li>计算环形复杂度的方法</li></ol><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>实现 = 编码 + 调试<br>​</p><p>实际过程中，调试所花费的时间远大于编码的时间</p><h3 id="维护"><a href="#维护" class="headerlink" title="维护"></a>维护</h3><hr><h2 id="二、面向对象方法学"><a href="#二、面向对象方法学" class="headerlink" title="二、面向对象方法学"></a>二、面向对象方法学</h2><p>由三部分组成：分析，设计，实现<br>​</p><h2 id="三、软件项目管理"><a href="#三、软件项目管理" class="headerlink" title="三、软件项目管理"></a>三、软件项目管理</h2><p>本章节探讨的是实际<strong>软件项目管理</strong>的相关工作，软件项目管理是软件项目一经启动就开始实施的一系列工作，其首先需要探讨的就是软件项目的相关估算，具体的有<strong>软件规模的估算、工作量的估算</strong>和<strong>完成项目估算</strong>，由上述的估算再对其进行制定一套完整的<strong>进度计划方案</strong>和<strong>人员组织方案</strong>，在整个项目过程中，还需要动态的<strong>软件配置管理</strong>，最后还介绍了<strong>软件质量的保证</strong>和<strong>软件能力成熟度模型</strong>这两个软件完成收尾的相关概念。</p><p>作者想要解决软件危机相关问题，具体而言就印证“后人哀之而不鉴之，亦是后人而复哀后人也”这句古话，所以一套系统的软件项目管理出来了。</p><h3 id="估算工作"><a href="#估算工作" class="headerlink" title="估算工作"></a>估算工作</h3><p><strong>估算软件规模</strong>有两种方法：代码行估算和功能点估算<br>代码行技术就是利用代码的行数来进行估算的，会根据几个有经验的工作者利用一个公式来进行估算（最小可能的规模+最大可能的规模+最可能的规模）/6，得到的结果有两种，第一种是规模小的时候，单位行，第二种是规模大的时候，单位是千行。<br>功能点技术就比较复杂了，它涉及到五个相关信息域特征的概念，分别是输入项数，输出项数，查询项数，主文件数，外部接口项数，再利用一系列步骤公式得到这个软件的功能点估算，最后得到的是功能点数 FP。<br>具体可以参考：<a href="https://wiki.mbalib.com/wiki/%E5%8A%9F%E8%83%BD%E7%82%B9%E4%BC%B0%E7%AE%97%E6%B3%95">功能点估算法 | MBA 智库</a><br><strong>估算工作量</strong>有三种方法<br>构造的函数模型的有静态单变量模型、动态多变量模型、COCOMO2 模型这三种模型，得到的结果单位是人月（pm）。    <br>静态单变量是基于上一个估算软件规模得出的代码行/功能点结果这一个变量函数，有一些相应的前人总结的公式<br>多变量模型，顾名思义，多个变量不止一个变量，有项目持续时间，特殊技术因子，生产率参数，也有相应的函数，可以去查查。<br>COCOMO2 模型 略、<br><strong>估算开发时间</strong><br>利用上一步骤得到的所估算的工作量，有一系列模型将工作量的值带进去就会得到相应的开发时间值。书中介绍了 Walston_Felix、原始的 COCOMO 模型、COCOMO2 模型、Putnam 模型。</p><hr><h3 id="制定进度计划表-图"><a href="#制定进度计划表-图" class="headerlink" title="制定进度计划表/图"></a>制定进度计划表/图</h3><p>得到开发时间，然后就是根据人员人员数量的资源来自定计划，有两种可视化方法：<br>第一种就是<strong>Gantt 图</strong>：典型的异于流水作业的一种方法，动态调配人员来完成工作<br>第二种就是<strong>工程网络</strong>：用箭头和圆圈来表示整个项目流程，优于 Gantt 图的就是能够实际根据实际项目中的潜力任务来跟踪观察，具体说就是有些任务可能在实际过程中，用原先指定的时间或人员不一定能高效完成，逾期或是提前很久完成等等这种情况。<br>工程网络功能可以估算工程的进度，在工程网络里面加上一些时间数字，可以灵活地查看并计算工程的计划时间。<br>工程网络还可以计算出机动时间。<br>其实在实际过程中，这两种方法都是并用的。</p><hr><h3 id="人员组织"><a href="#人员组织" class="headerlink" title="人员组织"></a>人员组织</h3><p>人员组织在所经历的阶段中，经过多次变革，书中介绍有，最初的民主制程序员组 👉 主程序员<br>组 👉 现代程序员组<br>只介绍现代程序员组，其实这个在历史中也分两种，第一种是根据职能不同分成两个组长，这种方式不能根治这过程中的软件危机，不详细讲述，第二种就是现在常说的项目经理管理下调配的，项目经理管多个组长，各个组长管理下面的多个程序员，并且，在组长与组长之间可以进行该层的交流，程序员层也一样，但是项目经理就是在该项目中的天花板了，没人管得了……</p><hr><h3 id="软件配置管理、质量保证、能力成熟度模型"><a href="#软件配置管理、质量保证、能力成熟度模型" class="headerlink" title="软件配置管理、质量保证、能力成熟度模型"></a>软件配置管理、质量保证、能力成熟度模型</h3><p>这三个就是项目管理过程中一些概念之类的，其中软件配置管理讲究动态二字，因为随着时间抑或是用户需求的推移，软件配置势必会改变，这时候就需要即时更新相应配置<br>后两者是对软件完成的收尾相关工作了。</p>]]></content>
      
      
      <categories>
          
          <category> SoftwareEngineering </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成原理知识点回顾</title>
      <link href="blog/pnf49g/"/>
      <url>blog/pnf49g/</url>
      
        <content type="html"><![CDATA[<blockquote><p>利用一些基本的问题简单回顾一下这学期学的计组的基本知识点。</p></blockquote><h2 id="概论"><a href="#概论" class="headerlink" title="概论"></a>概论</h2><blockquote><p>电子数字计算机和电子模拟计算机的区别是什么？</p></blockquote><p>电子数字计算机处理的信息是<strong>离散</strong>的，运算过程是离散的<br>电子模拟计算机处理的信号时<strong>连续</strong>的，运算过程是连续的</p><blockquote><p>冯诺依曼计算机的特点是什么？其中最主要的一点是什么？</p></blockquote><ol><li>计算机由运算器、控制器、存储器、输入系统、输出系统<strong>五大部件</strong>组成（注意中央处理器是运算器和控制器的合称）</li><li>计算机内部由<strong>二进制编码</strong>指令和数据</li><li>将编好的数据和程序<strong>先放</strong>入存储器中，然后<strong>再启动</strong>计算机工作</li></ol><p>其中最主要的一点是第三点最主要！</p><h2 id="数据的机器层次表示"><a href="#数据的机器层次表示" class="headerlink" title="数据的机器层次表示"></a>数据的机器层次表示</h2><blockquote><p>机器数的原码+反码+补码表示</p></blockquote><p>定点小数表示：阶码：小数点位数；尾数：在小数那里编码即可</p><p>真值就是加正负所表现出来的</p><blockquote><p>给定计算机字长位数，知道各种情况下表示数值的范围</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1608863188017-8f6c8d66-710e-4880-8559-af59c6e37609.png#align=left&display=inline&height=356&margin=%5Bobject%20Object%5D&name=image.png&originHeight=712&originWidth=1315&size=336629&status=done&style=shadow&width=657.5" alt="image.png"></p><h2 id="数值的机器运算"><a href="#数值的机器运算" class="headerlink" title="数值的机器运算"></a>数值的机器运算</h2><blockquote><p>定点加减运算+判断结果是否溢出</p></blockquote><ol><li>先写出两个数的补码（减法运算转换为加法运算即可）</li><li>然后进行二进制加法运算（遵循 0+0=0，1+0=1，0+1=1，1+1=10 向高位进位）</li><li>判断是否溢出【00：结果为正无溢出；01：正溢；10：负溢；11 结果为负无溢出】</li><li>将[X+Y]补转换为[X+Y]真值<blockquote><p>定点乘法运算：原码一位乘法运算+补码一位乘法运算</p></blockquote></li></ol><p>原码一位乘法运算：</p><ol><li>先写出 X 和 Y 的绝对值|X|和|Y|</li><li>让 00.0……和|X|相加同时判断|Y|的最后一位（如果为 1 加|X|如果是 0 加 0）</li><li>加完之后右移一位，再判断，加了再判断，啥时候那个分隔符分没了，就好了……………</li><li>最后判断真值符号</li></ol><p>我写的个啥………………逃</p><p>补码一位乘法运算：</p><ol><li>写出[X]补[-X]补[Y]补</li><li>在[Y]补码尾巴后面加一个 0，判断最后两位，（00 加 0；10 加[-X]补；01 加[X]补；11 加 0）</li><li>让 00.000……加上上面判断的加上某某</li><li>又一直这样下去下去……</li><li>把补码换成原码即可……</li></ol><p>…………逃 🤣</p><h2 id="指令系统"><a href="#指令系统" class="headerlink" title="指令系统"></a>指令系统</h2><blockquote><p>什么叫主程序和子程序？调用子程序还可以采用哪几种方法保存返回地址？画出图说明调用子程序的过程。</p></blockquote><p>主程序：<strong>通常</strong>的程序<br>**<br>子程序：可以被反复调用、<strong>公用</strong>的程序，只要知道其**入口地址**，就可以调用之，其就是我们编程常写的函数</p><p>保存返回地址的方法：</p><ul><li>子程序的第一个<strong>子单元</strong>存放返回地址，然后从第二个字单元开始执行子程序</li><li><strong>寄存器</strong>存放</li><li><strong>堆栈</strong>保存</li></ul><p>以堆栈保存返回地址的方法来说明调用子程序的过程：<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1608774330112-3e8bf3df-1091-4476-aa72-e9757e36a3e6.png#align=left&display=inline&height=77&margin=%5Bobject%20Object%5D&name=image.png&originHeight=154&originWidth=242&size=22896&status=done&style=shadow&width=121" alt="image.png"></p><blockquote><p>如果某计算机调用子程序保存返回地址是上个问题的第一种方式，有这么几个问题：</p><ol><li>为这种方法设计一条从子程序转到主程序的返回指令</li><li>怎么在主程序和子程序之间进行传参</li><li>可否用于子程序嵌套</li><li>可否用于子程序的递归</li><li>如果将该种方式改为第三种方式（堆栈方式），可否完成 4</li></ol></blockquote><ol><li>使用间接寻址方式</li></ol><table><thead><tr><th>JMP</th><th>@</th><th>子程序首地址</th></tr></thead></table><ol start="2"><li>可以利用寄存器或主存单元进行主、子程序间的参数传递</li><li>可以。返回的地址都放在子程序的第一个单元</li><li>不可以。会破坏其内部结构</li><li>可以。因为堆栈具有后进先出功能</li></ol><h2 id="存储系统和结构"><a href="#存储系统和结构" class="headerlink" title="存储系统和结构"></a>存储系统和结构</h2><blockquote><p>如何区别存储器和寄存器？两者是一回事说法对吗？</p></blockquote><p>两者不是一回事。</p><p>存储器是在<strong>CPU</strong>外边，用来存放数据和程序的，访问存储器的<strong>速度</strong>较慢；</p><p>寄存器数据 CPU 的一部分，访问寄存器的速度很快。<br>**</p><blockquote><p>存储器的主要功能是什么？为什么把存储系统分成若干个不同层次？主要有那些层次？</p></blockquote><p>存储器的主要功能：存储数据和程序</p><p>存储系统是有几个<strong>容量、速度、价格</strong>不同的存储器用硬件、软件、软硬件相结合起来的系统。分成若干个不同层次是因为考虑到不同存储器的价格因素、存储速度、存储容量三个因素。</p><ol><li>高速缓存</li><li>主存</li><li>辅存</li></ol><p>其中 12 又称之为 Cache-主存存储层次，23 又称之为主存-辅存存储层次。</p><blockquote><p>动态 RAM 为什么要刷新？一般有几种刷新方式？各有什么优缺点？</p></blockquote><p><strong>为了维持 DRAM 的记忆单元的存储信息</strong></p><ul><li><strong>集中式</strong>刷新</li></ul><p>优点：<strong>读写操作</strong>不受刷新工作的影响，<strong>存取速度</strong>高</p><p>缺点：存储容量越大，死区越长</p><ul><li><strong>分散式</strong>刷新</li></ul><p>优点：没有死区</p><p>缺点：加长了系统的<strong>存取周期</strong>，降低了整机的速度，并且刷新过于频繁，没有充分利用允许的最大刷新间隔</p><ul><li><strong>异步式</strong>刷新</li></ul><p>异步式虽然有死区，但是比几种方式的<strong>死区小</strong>得多，而且<strong>减少了刷新次数</strong>，是比较实用的一种刷新方式。</p><h2 id="中央处理器"><a href="#中央处理器" class="headerlink" title="中央处理器"></a>中央处理器</h2><hr><blockquote><p>控制器有哪几种控制方式？各有何特点？</p></blockquote><ul><li><strong>同步</strong>控制方式</li></ul><p>该控制方式各项操作都由统一的<strong>时序信号</strong>完成，并且在每个及其周期中产生统一的<strong>节拍电位和工作脉冲</strong>。这种方式设计简单，但是对于许多<strong>单指令</strong>来说，有太多的<strong>空闲时间</strong>，造成时间浪费，影响指令执行速度。</p><ul><li><strong>异步</strong>控制方式</li></ul><p>该控制方式的各项操作都<strong>不由统一的时序信号</strong>完成，而是由指令本身或部件的具体情况决定，因此这种控制方式的效率高，时间能够合理利用，但是该控制方式也比较复杂。</p><ul><li><strong>联合</strong>控制方式</li></ul><p>是由上面的同步控制方式和异步控制方式相结合的方式。</p><hr><blockquote><p>什么是三级时序系统？</p></blockquote><p>三级时序系统是指<strong>机器周期</strong>、<strong>节拍</strong>、<strong>工作脉冲</strong></p><p>具体所属关系是：每个指令周期划分若干个机器周期，每个机器周期划分若干个节拍，每个节拍划分 1 个或几个工作脉冲。</p><hr><blockquote><p>控制器有哪些基本功能？可分为哪几类？分类的依据是什么？</p></blockquote><p>基本功能：</p><ul><li>从主存中<strong>取出一条指令</strong>，并指出下一跳指令在主存中的位置</li><li>对指令进行<strong>译码或是测试</strong>，产生相应的操作控制信号，以便启动规定的工作</li><li>指挥并控制<strong>CPU</strong>，主存和输入输出设备之间的<strong>数据流动</strong></li></ul><p>分类：</p><ul><li><strong>组合逻辑</strong>型</li><li><strong>存储逻辑</strong>型</li><li>组合逻辑和存储逻辑<strong>结合</strong>型</li></ul><p>分类的依据：<br>在于控制器的核心——<strong>微操作信号发生器的实现方法不同</strong>。</p><hr><blockquote><p>中央处理器有哪些功能？它是由那些基本部件构成的？</p></blockquote><p>构成：</p><ul><li>控制器</li><li>运算器</li></ul><p>功能：<br>对数据流和指令流在时间上和空间上进行正确的控制。当然，对于冯诺依曼结构的计算机而言，数据流是基于指令流的操作而驱动的。</p><hr><blockquote><p>中央处理器有哪几个主要寄存器？说说他们的结构和功能？</p></blockquote><p>寄存器的功能就是用来存放程序运行过程中的中间结果、最终结果以及控制、状态信息的。</p><ul><li>通用寄存器</li></ul><p>用来存放原始数据和运算结果，有的还可以作为变址寄存器、计数器、地址指针等</p><ul><li>专用寄存器</li></ul><p>是用来完成某些特定功能的寄存器：程序计数器（PC）、指令寄存器（IR）、存储器地址寄存器（MAR）、存储器数据寄存器（MDR）、程序状态字寄存器（PSWR）等</p><blockquote><p>以单指令为例，简要说明下列部件在计算机的取值周期和执行周期的作用。</p></blockquote><ul><li>程序计数器（PC）：存放指令地址</li><li>指令寄存器（IR）：存放当前指令</li><li>存储器地址寄存器（MAR）：进行算术逻辑运算</li><li>存储器数据寄存器（MDR）：存放写入或读出的数据/指令</li><li>程序状态字寄存器（PSWR）：存放写入或读出的数据/指令的地址</li></ul><hr><blockquote><p>什么是指令周期？什么是 CPU 周期？他们之间有什么关系？</p></blockquote><p>指令周期：指<strong>取指令</strong>、<strong>分析指令</strong>到<strong>执行指令</strong>所花费的所有时间</p><p>CPU 周期：也叫<strong>机器周期</strong>，是指完成一个基本操作所花费的时间<br>一个指令周期划分为多个 CPU 周期</p><hr><h2 id="【总线-外部设备】nothing"><a href="#【总线-外部设备】nothing" class="headerlink" title="【总线+外部设备】nothing"></a>【总线+外部设备】nothing</h2><h2 id="输入输出系统"><a href="#输入输出系统" class="headerlink" title="输入输出系统"></a>输入输出系统</h2><hr><blockquote><p>什么是计机的输入输出系统？输入输出设备有哪些编址方式？有什么特点？</p></blockquote><p>输入输出系统：包括输入输出<strong>接口</strong>和输入输出信息<strong>传送</strong>控制方式，是计算机系统中最具有<strong>多样性</strong>和<strong>复杂性</strong>的部分。</p><p>编址方式：</p><ul><li><strong>独立编址</strong></li></ul><p>优点：指令易于区分，译码简单，主存空间不会减少</p><p>缺点：增加了控制线 I/ORead 和 I/OWrite 信号</p><ul><li><strong>统一编址</strong></li></ul><p>优点：总线结构简单，全部访存类指令都可用于控制外设，可直接对外设寄存器进行各种运算</p><p>缺点：占用主存一部分地址，缩小了可用的主存空间</p><hr><blockquote><p>什么是 I/O 接口？I/O 接口有哪些特点和功能？接口有哪些类型？</p></blockquote><p>主机和外设之间的交接界面</p><p>特点：<br>实现信息交换</p><p>功能：</p><ul><li>实现主机和外设的通信联络控制</li><li>进行地址译码和设备选择</li><li>实现数据缓冲</li><li>完成数据格式的变换</li><li>传递控制命令和状态信息</li></ul><p>类型：</p><ul><li>串行接口</li><li>并行接口</li></ul><hr><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1608728980150-18e3d2ee-cc80-4187-b38c-14c78554e979.png#align=left&display=inline&height=152&margin=%5Bobject%20Object%5D&name=image.png&originHeight=198&originWidth=766&size=190453&status=done&style=none&width=589" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1608729028676-c983dd94-3689-431d-bf54-76bbb5b01f75.png#align=left&display=inline&height=80&margin=%5Bobject%20Object%5D&name=image.png&originHeight=160&originWidth=788&size=111323&status=done&style=none&width=394" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1608729049887-aee5cd74-e49d-44d1-88b2-bcdc511ff3c3.png#align=left&display=inline&height=107&margin=%5Bobject%20Object%5D&name=image.png&originHeight=214&originWidth=968&size=213320&status=done&style=none&width=484" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1608729065956-47dc5b50-caaa-44a1-a54e-8e3f5ae2192a.png#align=left&display=inline&height=172&margin=%5Bobject%20Object%5D&name=image.png&originHeight=343&originWidth=687&size=119088&status=done&style=none&width=343.5" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1608729081886-f27d6175-e541-4379-b158-0093a23b693d.png#align=left&display=inline&height=139&margin=%5Bobject%20Object%5D&name=image.png&originHeight=277&originWidth=922&size=156708&status=done&style=none&width=461" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1608729097801-61fd270b-1608-48ab-b1fa-a951febba5d6.png#align=left&display=inline&height=87&margin=%5Bobject%20Object%5D&name=image.png&originHeight=173&originWidth=907&size=129678&status=done&style=none&width=453.5" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1608729108461-95f5d6e5-efd6-4acf-a2c7-fb72f6052d25.png#align=left&display=inline&height=71&margin=%5Bobject%20Object%5D&name=image.png&originHeight=141&originWidth=897&size=100962&status=done&style=none&width=448.5" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1608729131667-e6955db4-4b2c-4efb-ad1f-3acf8ccc5e48.png#align=left&display=inline&height=315&margin=%5Bobject%20Object%5D&name=image.png&originHeight=630&originWidth=974&size=493234&status=done&style=none&width=487" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1608729144873-1a207e20-98d9-4e44-b40e-c1a81a54b667.png#align=left&display=inline&height=195&margin=%5Bobject%20Object%5D&name=image.png&originHeight=390&originWidth=968&size=379559&status=done&style=none&width=484" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1608729157489-b3899992-00d9-405b-8f02-9619f08d9960.png#align=left&display=inline&height=193&margin=%5Bobject%20Object%5D&name=image.png&originHeight=386&originWidth=938&size=349548&status=done&style=none&width=469" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1608729176250-7499ab5f-2a40-4514-92f3-afc46c739936.png#align=left&display=inline&height=275&margin=%5Bobject%20Object%5D&name=image.png&originHeight=549&originWidth=1005&size=475058&status=done&style=none&width=502.5" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> ComputerOrganization </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>VuePress初体验</title>
      <link href="blog/czl3oc/"/>
      <url>blog/czl3oc/</url>
      
        <content type="html"><![CDATA[<h2 id="安装-Yarn"><a href="#安装-Yarn" class="headerlink" title="安装 Yarn"></a>安装 Yarn</h2><blockquote><p>Yarn 是为了弥补 npm 的一些缺陷而生的</p></blockquote><p>具体参考：<a href="https://zhuanlan.zhihu.com/p/27449990">https://zhuanlan.zhihu.com/p/27449990</a></p><h3 id="引导式安装"><a href="#引导式安装" class="headerlink" title="引导式安装"></a>引导式安装</h3><p><a href="https://classic.yarnpkg.com/zh-Hans/docs/install#windows-stable">下载地址</a><br>使用 Windows 版的下载安装即可<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1608540352757-ed3ef592-f042-4262-9378-42aa9d053fcd.png#height=35&id=cUHeI&margin=%5Bobject%20Object%5D&name=image.png&originHeight=69&originWidth=433&originalType=binary%E2%88%B6=1&size=3803&status=done&style=none&width=216.5" alt="image.png"></p><h3 id="bash-安装"><a href="#bash-安装" class="headerlink" title="bash 安装"></a>bash 安装</h3><p>在 bash 里面不能显示，在 bash 里面下载<br><code>npm install -g yarn</code> 即可</p><h2 id="将-VuePress-安装为本地依赖"><a href="#将-VuePress-安装为本地依赖" class="headerlink" title="将 VuePress 安装为本地依赖"></a>将 VuePress 安装为本地依赖</h2><h3 id="yarn-init"><a href="#yarn-init" class="headerlink" title="yarn init"></a>yarn init</h3><p>yarn init 出错</p><pre><code class="bash">error An unexpected error occurred: &quot;Can&#39;t answer a question unless a user TTY&quot;. info If you think t</code></pre><p><strong>使用 cmd 或者 power shell 不要使用 bash</strong><br><strong>​</strong></p><h3 id="yarn-add-D-vuepress"><a href="#yarn-add-D-vuepress" class="headerlink" title="yarn add -D vuepress"></a>yarn add -D vuepress</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1608541125538-3124ff43-0574-4bfd-a290-908621b54644.png#height=272&id=wwNV3&margin=%5Bobject%20Object%5D&name=image.png&originHeight=543&originWidth=1920&originalType=binary%E2%88%B6=1&size=147908&status=done&style=none&width=960" alt="image.png"></p><h3 id="创建一篇文章"><a href="#创建一篇文章" class="headerlink" title="创建一篇文章"></a>创建一篇文章</h3><p>在 bash 创建，在 powershell 里面创建会报错</p><pre><code class="bash">mkdir docs &amp;&amp; echo &#39;# Hello VuePress&#39; &gt; docs/README.md</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1608541380531-3ad1565f-0eef-4dac-bebf-64d1a131d7f3.png#height=105&id=RwhmG&margin=%5Bobject%20Object%5D&name=image.png&originHeight=210&originWidth=1160&originalType=binary%E2%88%B6=1&size=36343&status=done&style=none&width=580" alt="image.png"></p><h3 id="添加脚本"><a href="#添加脚本" class="headerlink" title="添加脚本"></a>添加脚本</h3><pre><code class="json">&#123;  &quot;name&quot;: &quot;my-site&quot;,  &quot;version&quot;: &quot;1.0.0&quot;,  &quot;main&quot;: &quot;index.js&quot;,  &quot;license&quot;: &quot;MIT&quot;,  &quot;devDependencies&quot;: &#123;    &quot;vuepress&quot;: &quot;^1.7.1&quot;  &#125;,  &quot;scripts&quot;: &#123;    &quot;docs:dev&quot;: &quot;vuepress dev docs&quot;,    &quot;docs:build&quot;: &quot;vuepress build docs&quot;  &#125;&#125;</code></pre><h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1608541418296-b53b29dc-f6a9-480f-b65d-009a21c0d013.png#height=237&id=YrVlg&margin=%5Bobject%20Object%5D&name=image.png&originHeight=474&originWidth=951&originalType=binary%E2%88%B6=1&size=59046&status=done&style=none&width=475.5" alt="image.png"><br>端口访问：<a href="http://localhost:8080/">http://localhost:8080/</a></p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[转]低谷</title>
      <link href="essay/vpzzbr/"/>
      <url>essay/vpzzbr/</url>
      
        <content type="html"><![CDATA[<blockquote><p>不要害怕低谷，这是上天给你的升级时间<br>有个好玩的现象，我这里的畅销书，绝大多数是在作者低谷的时候写出来的。比如创业失败、被公司裁员、或者身体不好在家休息等等。</p></blockquote><blockquote><p>为什么呢？因为事业上升时，人被事情推着走，每天忙忙碌碌，没有一块时间思考和复盘。<br>进入低谷后，时间充足，可以好好整理思想了，把以前的经验体系化，于是一本畅销书横空出世。更重要的是，这本书已成为他的视野催化剂，走向人生的第二巅峰。</p></blockquote><blockquote><p>低谷不可怕，可怕的是一蹶不振啊。</p></blockquote><blockquote><p><strong>转载自：写书哥（同微博）</strong></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CSS的高级使用技巧</title>
      <link href="blog/rpd10b/"/>
      <url>blog/rpd10b/</url>
      
        <content type="html"><![CDATA[<p>这是加密文章！</p>]]></content>
      
      
      <categories>
          
          <category> Language </category>
          
          <category> CSS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>搭建“文本三巨头”环境</title>
      <link href="blog/yhxiep/"/>
      <url>blog/yhxiep/</url>
      
        <content type="html"><![CDATA[<h2 id="Vim"><a href="#Vim" class="headerlink" title="Vim"></a>Vim</h2><h3 id="Vim-下载安装"><a href="#Vim-下载安装" class="headerlink" title="Vim 下载安装"></a>Vim 下载安装</h3><p><a href="https://www.vim.org/download.php">下载地址</a><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1608357192619-ac3d093e-c4e4-49fa-9a3b-8ead607b2160.png#align=left&display=inline&height=299&margin=%5Bobject%20Object%5D&name=image.png&originHeight=598&originWidth=1919&size=248340&status=done&style=none&width=959.5" alt="image.png"><br>下载完之后 next 安装即可</p><h3 id="Vim-环境变量配置"><a href="#Vim-环境变量配置" class="headerlink" title="Vim 环境变量配置"></a>Vim 环境变量配置</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1608357482468-e6a53bc3-991d-4eda-aa2e-c5643b9617b0.png#align=left&display=inline&height=89&margin=%5Bobject%20Object%5D&name=image.png&originHeight=177&originWidth=602&size=11434&status=done&style=none&width=301" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1608357463679-c00baef1-4e21-4405-8e79-f65afabe0370.png#align=left&display=inline&height=469&margin=%5Bobject%20Object%5D&name=image.png&originHeight=938&originWidth=976&size=105454&status=done&style=none&width=488" alt="image.png"></p><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1608357601712-bc8f6f5b-6038-4358-8699-a7201ce8223e.png#align=left&display=inline&height=112&margin=%5Bobject%20Object%5D&name=image.png&originHeight=225&originWidth=1468&size=22708&status=done&style=none&width=734" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1608357572830-fd4043b2-f02a-4c32-b9e7-677c4918ec19.png#align=left&display=inline&height=383&margin=%5Bobject%20Object%5D&name=image.png&originHeight=766&originWidth=1442&size=64262&status=done&style=none&width=721" alt="image.png"></p><h2 id="zsh"><a href="#zsh" class="headerlink" title="zsh"></a>zsh</h2><h3 id="安装-Linux-子系统"><a href="#安装-Linux-子系统" class="headerlink" title="安装 Linux 子系统"></a>安装 Linux 子系统</h3><p>查看之前写的文章：<a href="https://www.wztlink1013.com/blog/xnh83z/">搭建 Windows 子系统 Linux - 尼采般地抒情</a></p><h3 id="安装-ConEmu"><a href="#安装-ConEmu" class="headerlink" title="安装 ConEmu"></a>安装 ConEmu</h3><p><a href="https://www.fosshub.com/ConEmu.html">https://www.fosshub.com/ConEmu.html</a><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1608358847174-3a3b7ba1-45e8-4951-a943-debd2a09de43.png#align=left&display=inline&height=217&margin=%5Bobject%20Object%5D&name=image.png&originHeight=434&originWidth=1904&size=80285&status=done&style=none&width=952" alt="image.png"><br>设置如下：<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1608358926353-c172728f-978e-47f7-9ec5-34472219ccdb.png#align=left&display=inline&height=376&margin=%5Bobject%20Object%5D&name=image.png&originHeight=751&originWidth=1143&size=84693&status=done&style=none&width=571.5" alt="image.png"><br>确定后会进入以下界面<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1608358964494-c12c30a4-4b04-4463-b3d6-3c5fc21b607f.png#align=left&display=inline&height=359&margin=%5Bobject%20Object%5D&name=image.png&originHeight=717&originWidth=970&size=40132&status=done&style=none&width=485" alt="image.png"></p><h3 id="安装并配置-zsh"><a href="#安装并配置-zsh" class="headerlink" title="安装并配置 zsh"></a>安装并配置 zsh</h3><p>进入页面 <code>sudo apt-get install -y zsh</code> ，输入密码：<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1608359167583-80d5f5fd-77e6-417d-ac0c-279dbfb55776.png#align=left&display=inline&height=300&margin=%5Bobject%20Object%5D&name=image.png&originHeight=600&originWidth=960&size=64893&status=done&style=none&width=480" alt="image.png"><br>安装成功界面如下：<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1608360612991-863a5a2e-77a2-4bd7-b1b9-4ef6a79dcb86.png#align=left&display=inline&height=456&margin=%5Bobject%20Object%5D&name=image.png&originHeight=912&originWidth=1908&size=196509&status=done&style=none&width=954" alt="image.png"></p><h3 id="安装-oh-my-zsh"><a href="#安装-oh-my-zsh" class="headerlink" title="安装 oh-my-zsh"></a>安装 oh-my-zsh</h3><p>sh -c “$(curl -fsSL <a href="https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh">https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)”</a>%22)<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1608360763102-d6886d61-c954-4c15-adfc-ca42c0daf337.png#align=left&display=inline&height=411&margin=%5Bobject%20Object%5D&name=image.png&originHeight=821&originWidth=1908&size=125769&status=done&style=none&width=954" alt="image.png"><br>上述文件夹在这里： <code>C:\Users\wztli\AppData\Local\Packages\CanonicalGroupLimited.UbuntuonWindows_79rhkp1fndgsc\LocalState\rootfs\home\wztlink1013</code></p><h2 id="tmux"><a href="#tmux" class="headerlink" title="tmux"></a>tmux</h2><h3 id="安装运行"><a href="#安装运行" class="headerlink" title="安装运行"></a>安装运行</h3><p>Ubuntu 系统命令行界面输入： <code>sudo apt install tmux</code></p><p>在 Ubuntu 系统输入并执行”tmux”命令，会进入 tmux 窗口</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.jianshu.com/p/5f7b83ca3952">https://www.jianshu.com/p/5f7b83ca3952</a></li><li><a href="https://post.smzdm.com/p/a5k6e033/">https://post.smzdm.com/p/a5k6e033/</a></li><li><a href="https://blog.csdn.net/qq_2300688967/article/details/81774297">https://blog.csdn.net/qq_2300688967/article/details/81774297</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Environment </category>
          
          <category> 环境配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vim </tag>
            
            <tag> zsh </tag>
            
            <tag> tmux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P150.逆波兰表达式求值</title>
      <link href="blog/ewoap5/"/>
      <url>blog/ewoap5/</url>
      
        <content type="html"><![CDATA[<h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>对所给字符串进行遍历，遇到数字字符就压入栈 stack 内，遇到+-*/符号就 pop 处栈的两个元素，进行该字符运算处理</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><pre><code class="java">package com.wztlink1013.problems.leetcode.editor.cn;// P150.逆波兰表达式求值// P150.evaluate-reverse-polish-notation//根据 逆波兰表示法，求表达式的值。//// 有效的运算符包括 +, -, *, / 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。//////// 说明：////// 整数除法只保留整数部分。// 给定逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。////////// 示例 1：//// 输入: [&quot;2&quot;, &quot;1&quot;, &quot;+&quot;, &quot;3&quot;, &quot;*&quot;]//输出: 9//解释: 该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) = 9////// 示例 2：//// 输入: [&quot;4&quot;, &quot;13&quot;, &quot;5&quot;, &quot;/&quot;, &quot;+&quot;]//输出: 6//解释: 该算式转化为常见的中缀算术表达式为：(4 + (13 / 5)) = 6////// 示例 3：//// 输入: [&quot;10&quot;, &quot;6&quot;, &quot;9&quot;, &quot;3&quot;, &quot;+&quot;, &quot;-11&quot;, &quot;*&quot;, &quot;/&quot;, &quot;*&quot;, &quot;17&quot;, &quot;+&quot;, &quot;5&quot;, &quot;+&quot;]//输出: 22//解释://该算式转化为常见的中缀算术表达式为：//  ((10 * (6 / ((9 + 3) * -11))) + 17) + 5//= ((10 * (6 / (12 * -11))) + 17) + 5//= ((10 * (6 / -132)) + 17) + 5//= ((10 * 0) + 17) + 5//= (0 + 17) + 5//= 17 + 5//= 22//////// 逆波兰表达式：//// 逆波兰表达式是一种后缀表达式，所谓后缀就是指算符写在后面。////// 平常使用的算式则是一种中缀表达式，如 ( 1 + 2 ) * ( 3 + 4 ) 。// 该算式的逆波兰表达式写法为 ( ( 1 2 + ) ( 3 4 + ) * ) 。////// 逆波兰表达式主要有以下两个优点：////// 去掉括号后表达式无歧义，上式即便写成 1 2 + 3 4 + * 也可以依据次序计算出正确结果。// 适合用栈操作运算：遇到数字则入栈；遇到算符则取出栈顶两个数字进行计算，并将结果压入栈中。//// Related Topics 栈// 👍 213 👎 0import java.util.Stack;public class P150EvaluateReversePolishNotation&#123;    public static void main(String[] args) &#123;        Solution solution = new P150EvaluateReversePolishNotation().new Solution();        String[] tokens_1 = &#123;&quot;10&quot;, &quot;6&quot;, &quot;9&quot;, &quot;3&quot;, &quot;+&quot;, &quot;-11&quot;, &quot;*&quot;, &quot;/&quot;, &quot;*&quot;, &quot;17&quot;, &quot;+&quot;, &quot;5&quot;, &quot;+&quot;&#125;;        int temp = solution.evalRPN(tokens_1);        System.out.println(temp);    &#125;//leetcode submit region begin(Prohibit modification and deletion)class Solution &#123;    public int evalRPN(String[] tokens) &#123;        Stack&lt;String&gt; stack = new Stack&lt;&gt;();        String temp = &quot;0&quot;;        stack.push(temp);        for (String token : tokens) &#123;            int sum = 0;            if (token.equals(&quot;+&quot;)) &#123;                sum += Integer.parseInt(stack.pop()) + Integer.parseInt(stack.pop());                String str = String.valueOf(sum);                stack.push(str);            &#125; else if (token.equals(&quot;-&quot;)) &#123;                int i = Integer.parseInt(stack.pop());                int j = Integer.parseInt(stack.pop());                sum += j-i;                String str = String.valueOf(sum);                stack.push(str);            &#125; else if (token.equals(&quot;*&quot;)) &#123;                sum += Integer.parseInt(stack.pop()) * Integer.parseInt(stack.pop());                String str = String.valueOf(sum);                stack.push(str);            &#125; else if (token.equals(&quot;/&quot;)) &#123;                int i = Integer.parseInt(stack.pop());                int j = Integer.parseInt(stack.pop());                sum += j / i;                String str = String.valueOf(sum);                stack.push(str);            &#125; else &#123;                stack.push(token);            &#125;        &#125;        int result = Integer.parseInt(stack.pop());        return result;    &#125;&#125;//leetcode submit region end(Prohibit modification and deletion)&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> DataStructure </category>
          
          <category> Problems </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>hexo-部署出错at formatNunjucksError</title>
      <link href="blog/gw1d4z/"/>
      <url>blog/gw1d4z/</url>
      
        <content type="html"><![CDATA[<h2 id="报错信息"><a href="#报错信息" class="headerlink" title="报错信息"></a>报错信息</h2><p>GitHub Actions 流程中 hexo g 出现错误，具体错误在“Vue 笔记”中那篇文章中，有个地方用到了大括号嵌套的情况。</p><pre><code class="bash">    =====             Context Dump Ends            =====    at formatNunjucksError (/home/runner/work/website/website/node_modules/hexo/lib/extend/tag.js:102:13)    at Promise.fromCallback.catch.err (/home/runner/work/website/website/node_modules/hexo/lib/extend/tag.js:124:34)    at tryCatcher (/home/runner/work/website/website/node_modules/bluebird/js/release/util.js:16:23)    at Promise._settlePromiseFromHandler (/home/runner/work/website/website/node_modules/bluebird/js/release/promise.js:547:31)    at Promise._settlePromise (/home/runner/work/website/website/node_modules/bluebird/js/release/promise.js:604:18)    at Promise._settlePromise0 (/home/runner/work/website/website/node_modules/bluebird/js/release/promise.js:649:10)    at Promise._settlePromises (/home/runner/work/website/website/node_modules/bluebird/js/release/promise.js:725:18)    at _drainQueueStep (/home/runner/work/website/website/node_modules/bluebird/js/release/async.js:93:12)    at _drainQueue (/home/runner/work/website/website/node_modules/bluebird/js/release/async.js:86:9)    at Async._drainQueues (/home/runner/work/website/website/node_modules/bluebird/js/release/async.js:102:5)    at Immediate.Async.drainQueues [as _onImmediate] (/home/runner/work/website/website/node_modules/bluebird/js/release/async.js:15:14)    at runCallback (timers.js:705:18)    at tryOnImmediate (timers.js:676:5)    at processImmediate (timers.js:658:5)Error: Process completed with exit code 2.</code></pre><h2 id="问题分析与解决"><a href="#问题分析与解决" class="headerlink" title="问题分析与解决"></a>问题分析与解决</h2><p>上述代码中第二行其实已经说的很明确 <code> at formatNunjucksError</code><br>但是 hexo 中，渲染过程中用到的是 Nunjucks，在 Nunjucks 中双大括号被视为语法，所以报错。</p><h2 id="小记"><a href="#小记" class="headerlink" title="小记"></a>小记</h2><p><a href="https://www.wztlink1013.com/blog/pxpix4/">https://www.wztlink1013.com/blog/pxpix4/</a></p><p>其实之前遇到过类似的问题……写的博客还是要经常回顾……</p>]]></content>
      
      
      <categories>
          
          <category> Bug </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>GitHub多人协作功能Pull requests</title>
      <link href="blog/iwvugw/"/>
      <url>blog/iwvugw/</url>
      
        <content type="html"><![CDATA[<h2 id="给出一个初始场景"><a href="#给出一个初始场景" class="headerlink" title="给出一个初始场景"></a>给出一个初始场景</h2><p>小吴和小王同时开发一个项目 project，该项目托管到 GitHub 上，假定该项目托管到小吴的 GitHub 上，小王要想同时开发这个 project，就必须要 fork 小吴的这个 project，最后两个人 GitHub 仓库是这个样子的：<br>​</p><p>小吴：xiaowu/project<br>小王：xiaowang/project<br>​</p><p>（需要明确一点，小吴小王各自的 project 仓库现在就相当各做各的事情了）</p><h2 id="具体工作场景"><a href="#具体工作场景" class="headerlink" title="具体工作场景"></a>具体工作场景</h2><p>小王的仓库 xiaowang/project 改了代码，想要 push 合并到小吴的仓库 xiaowu/project 中，这里分两种情况。</p><h3 id="第一种情况"><a href="#第一种情况" class="headerlink" title="第一种情况"></a>第一种情况</h3><p><strong>小王在从 fork 小吴仓库到现在这段期间，小吴没有对 xiaowu/project 做任何改动</strong></p><blockquote><p>处理方法：直接 Pull request<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1606915274704-123b219d-d7fe-4816-88c4-91ba11b5c466.png#height=143&id=e0K97&margin=%5Bobject%20Object%5D&name=image.png&originHeight=285&originWidth=1917&originalType=binary%E2%88%B6=1&size=47997&status=done&style=shadow&width=958.5" alt="image.png"> &gt; <img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1606915405152-c1e60a93-99fb-42d5-a7a5-87c564fe53d4.png#height=270&id=Of4D4&margin=%5Bobject%20Object%5D&name=image.png&originHeight=540&originWidth=1920&originalType=binary%E2%88%B6=1&size=80075&status=done&style=shadow&width=960" alt="image.png"><br>可以看到 1 区域显示 Able to merge，表明这个 Pull request 对于双方是没有矛盾的</p></blockquote><h3 id="第二种情况"><a href="#第二种情况" class="headerlink" title="第二种情况"></a>第二种情况</h3><p><strong>小王在从 fork 小吴仓库到现在这段期间，小吴又在 xiaowu/project 里面做了改动，就相当于小王 fork 过后，两个人都对各自的仓库更新了，然后小王想将自己的改动推送到小吴那里</strong></p><blockquote><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1606916524143-c5076532-2497-4923-986f-d442122e6de7.png#height=287&id=YBom8&margin=%5Bobject%20Object%5D&name=image.png&originHeight=574&originWidth=1920&originalType=binary%E2%88%B6=1&size=91126&status=done&style=shadow&width=960" alt="image.png"> &gt; <strong>可以发现 1 处并没有那么顺利，因为产生了冲突，但是 2 处仍然可以新建一个 request 请求，先点击 2</strong> &gt; <img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1606916762342-e5215ae5-cf61-43ac-9051-f73c40de1fb1.png#height=307&id=F7o57&margin=%5Bobject%20Object%5D&name=image.png&originHeight=613&originWidth=1191&originalType=binary%E2%88%B6=1&size=52688&status=done&style=shadow&width=595.5" alt="image.png"> &gt; <strong>点击之后会这样 👇</strong> &gt; <img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1606916826669-b406d584-50a7-49d5-9044-166bba4bc75f.png#height=133&id=D3ARz&margin=%5Bobject%20Object%5D&name=image.png&originHeight=266&originWidth=1284&originalType=binary%E2%88%B6=1&size=32978&status=done&style=shadow&width=642" alt="image.png"><br>1 处显示矛盾的文件（就是小吴和小王在各自的仓库都进行了更改）<br>我们点击 2 处<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1606916998671-6b369cf8-f6dc-4ad3-ba0b-d2f7006b7804.png#height=198&id=nRTI1&margin=%5Bobject%20Object%5D&name=image.png&originHeight=396&originWidth=1920&originalType=binary%E2%88%B6=1&size=65448&status=done&style=shadow&width=960" alt="image.png"><br>接下来解决这个问题并且点击 Mark as resolved 按钮就可以了<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1606917076365-e79652f9-3c56-4259-87d4-b6e979af277d.png#height=181&id=UNqSw&margin=%5Bobject%20Object%5D&name=image.png&originHeight=361&originWidth=1920&originalType=binary%E2%88%B6=1&size=44612&status=done&style=shadow&width=960" alt="image.png"> &gt; <img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1606917146702-bc316303-78f2-4746-94fa-72e4cda90dd0.png#height=196&id=jhbAg&margin=%5Bobject%20Object%5D&name=image.png&originHeight=391&originWidth=1920&originalType=binary%E2%88%B6=1&size=87061&status=done&style=shadow&width=960" alt="image.png"><br>最后就会出现下面的图，接下来，小吴在他的 GitHub 上同意接受这个请求就可以了。（或者小王有权限小王自己接受也可以）<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1606917264180-37c25758-4db9-44f8-a3f6-0ca725d6c0fd.png#height=435&id=Z5Awy&margin=%5Bobject%20Object%5D&name=image.png&originHeight=869&originWidth=1435&originalType=binary%E2%88%B6=1&size=132722&status=done&style=shadow&width=717.5" alt="image.png"></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> VersionControlSystem </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>P224.基本计算器</title>
      <link href="blog/ckr31m/"/>
      <url>blog/ckr31m/</url>
      
        <content type="html"><![CDATA[<h2 id="问题思路"><a href="#问题思路" class="headerlink" title="问题思路"></a>问题思路</h2><p>用栈来作为临时存取非括号的求和数。对字符串进行逐个遍历，然后对遇到的每个字符串进行判断</p><ul><li>数字：将其求和到 sum 当中</li><li>（：将上述 sum 和符号压入栈内</li><li>）：将栈内的元素取出与现有 sum 求和</li><li>+：直接走</li><li>-：直接走不过给下一个计算数提前加负号</li></ul><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><pre><code class="java">package com.wztlink1013.problems.leetcode.editor.cn;// P224.基本计算器//实现一个基本的计算器来计算一个简单的字符串表达式的值。//// 字符串表达式可以包含左括号 ( ，右括号 )，加号 + ，减号 -，非负整数和空格 。//// 示例 1://// 输入: &quot;1 + 1&quot;//输出: 2////// 示例 2://// 输入: &quot; 2-1 + 2 &quot;//输出: 3//// 示例 3://// 输入: &quot;(1+(4+5+2)-3)+(6+8)&quot;//输出: 23//// 说明：////// 你可以假设所给定的表达式都是有效的。// 请不要使用内置的库函数 eval。//// Related Topics 栈 数学// 👍 309 👎 0import java.util.Stack;public class P224BasicCalculator&#123;    public static void main(String[] args) &#123;        Solution solution = new P224BasicCalculator().new Solution();        int key_1 = solution.calculate(&quot;7896979&quot;);        int key_2 = solution.calculate(&quot;(23-2)-33+1111&quot;);        System.out.println(key_1);        System.out.println(key_2);    &#125;//leetcode submit region begin(Prohibit modification and deletion)class Solution &#123;    public int calculate(String s) &#123;        Stack&lt;Integer&gt; stack_1 = new Stack&lt;Integer&gt;();        int sum = 0;        int sign = 1;        int num = 0;        for (int i=0;i&lt;s.length();i++) &#123;            char ch = s.charAt(i);            if (Character.isDigit(ch)) &#123;                num = 10 * num + (int) (ch - &#39;0&#39;);            &#125; else if (ch == &#39;+&#39;) &#123;                num = num * sign;                sum = sum + num;                sign = 1;                num = 0;            &#125; else if (ch == &#39;-&#39;) &#123;                num = num * sign;                sum = sum + num;                sign = -1;                num = 0;            &#125; else if (ch == &#39;(&#39;) &#123;                stack_1.push(sum);                stack_1.push(sign);                sum = 0;                num = 0;                sign = 1;            &#125; else if (ch == &#39;)&#39;) &#123;                num = num * sign;                sum = sum + num;                sum = stack_1.pop() * sum;                sum = sum + stack_1.pop();                num = 0;                sign = 1;            &#125;        &#125;        sum = sum + sign * num;        return sum;    &#125;&#125;//leetcode submit region end(Prohibit modification and deletion)&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> DataStructure </category>
          
          <category> Problems </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>sdnu-dboj-成绩管理-Movie</title>
      <link href="blog/zhdy1x/"/>
      <url>blog/zhdy1x/</url>
      
        <content type="html"><![CDATA[<blockquote><p>题目入口：<a href="http://db.itoi.sd.cn/problem/set">http://db.itoi.sd.cn/problem/set</a></p></blockquote><h2 id="成绩管理相关题目"><a href="#成绩管理相关题目" class="headerlink" title="成绩管理相关题目"></a>成绩管理相关题目</h2><h3 id="Student-表"><a href="#Student-表" class="headerlink" title="Student 表"></a>Student 表</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1600849205116-d4263820-8bbb-4d01-b97b-a0363f4498e7.png#align=left&display=inline&height=216&margin=%5Bobject%20Object%5D&name=image.png&originHeight=432&originWidth=722&size=41200&status=done&style=shadow&width=361" alt="image.png"></p><h3 id="Course-表"><a href="#Course-表" class="headerlink" title="Course 表"></a>Course 表</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1600849217512-41be815b-8bc4-4b6a-82c2-cbb4d335c9b9.png#align=left&display=inline&height=256&margin=%5Bobject%20Object%5D&name=image.png&originHeight=511&originWidth=632&size=38392&status=done&style=shadow&width=316" alt="image.png"></p><h3 id="SC-表"><a href="#SC-表" class="headerlink" title="SC 表"></a>SC 表</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1600849229639-8d5cd91f-d87e-49e9-a1cd-9c563b64723f.png#align=left&display=inline&height=262&margin=%5Bobject%20Object%5D&name=image.png&originHeight=523&originWidth=492&size=32976&status=done&style=shadow&width=246" alt="image.png"></p><h3 id="初始化-SQL-语句"><a href="#初始化-SQL-语句" class="headerlink" title="初始化 SQL 语句"></a>初始化 SQL 语句</h3><pre><code class="sql">SET NAMES utf8mb4;SET FOREIGN_KEY_CHECKS = 0;/*学生表*/CREATE TABLE Student(    Sno  INT(9) PRIMARY KEY,    Sname VARCHAR(10),    Ssex  CHAR(2),    Sage  TINYINT(3),    Sdept VARCHAR(20));INSERT INTO StudentVALUES (201215121, &#39;李勇&#39;, &#39;男&#39;, 20, &#39;CS&#39;),     (201215122, &#39;刘晨&#39;, &#39;女&#39;, 19, &#39;CS&#39;),    (201215123, &#39;王敏&#39;, &#39;女&#39;, 18, &#39;MA&#39;),    (201215125, &#39;张立&#39;, &#39;男&#39;, 19, &#39;IS&#39;),    (201215133, &#39;张三&#39;, &#39;男&#39;, 21, &#39;TE&#39;),     (201215137, &#39;赵四&#39;, &#39;男&#39;, 23, &#39;TE&#39;),     (201215139, &#39;田二&#39;, &#39;女&#39;, 24, &#39;CS&#39;),     (201215140, &#39;李四&#39;, &#39;男&#39;, 21, &#39;CS&#39;),     (201215141, &#39;郑五&#39;, &#39;女&#39;, 22, &#39;IS&#39;);/*课程表*/CREATE TABLE Course(    Cno      INT(4) PRIMARY KEY,    Cname     VARCHAR(40),    Cpno      INT(4),    Ccredit     TINYINT(3),    FOREIGN     KEY (Cpno) REFERENCES Course (Cno));INSERT INTO CourseVALUES    (1, &#39;数据库&#39;, 5, 4),        (2, &#39;数学&#39;, NULL, 2),    (3, &#39;信息系统&#39;, 1, 4),     (4, &#39;操作系统&#39;, 6, 3),     (5, &#39;数据结构&#39;, 7, 4),     (6, &#39;数据处理&#39;, NULL, 2),     (7, &#39;PASCAL语言&#39;, 6, 4);/*选课表*/CREATE TABLE SC(    Sno  INT(9),    Cno  INT(4),    Grade SMALLINT(3),    PRIMARY KEY (Sno, Cno),/* 主码由两个属性构成，必须作为表级完整性进行定义*/    FOREIGN KEY (Sno) REFERENCES Student (Sno),/* 表级完整性约束条件，Sno是外码，被参照表是Student */    FOREIGN KEY (Cno) REFERENCES Course (Cno)/* 表级完整性约束条件， Cno是外码，被参照表是Course*/);INSERT INTO SCVALUES (201215121, 1, 92),            (201215121, 2, 85),            (201215121, 3, 88),            (201215122, 2, 90),      (201215122, 3, 80),            (201215122, 6, 59),         (201215123, 1, 84),         (201215125, 1, 60),         (201215125, 3, 90),         (201215133, 4, 87),         (201215137, 2, 79),         (201215139, 2, 80),         (201215140, 2, 81);SET FOREIGN_KEY_CHECKS = 1;</code></pre><h3 id="问题代码"><a href="#问题代码" class="headerlink" title="问题代码"></a>问题代码</h3><pre><code class="sql">0select Sno, Sname        from Student1select Sname, Sno, Sdept        from Student2select Sname, Sno, Sdept        from Student3select distinct Sno        from SC4select distinct Sname        from Student        where Sdept=&#39;CS&#39;5select Sname, Sage    from Student    where Sage&lt;206select Sno    from SC    where Grade&lt;607select Sname, Sdept, Sage    from Student    where Sage&gt;=20 and Sage&lt;=238select Sname, Sdept, Sage    from Student    where Sage&lt;20 or Sage&gt;239select Sname, Ssex    from Student    where Sdept=&#39;CS&#39; or Sdept=&#39;MA&#39; or Sdept=&#39;IS&#39;10select Sname, Ssex    from Student    where Sdept not in (&#39;CS&#39;, &#39;MA&#39;, &#39;IS&#39;)11select Sname, Sno, Ssex    from Student    where Sname like &#39;刘_&#39;12select Sname, Sno    from Student    where Sname like &#39;_立&#39;13select Sname, Sno, Ssex    from Student    where Sname not like &#39;刘_&#39;14select Sno, Cno    from SC    where Grade is not null15select Sname    from Student    where Sdept=&#39;CS&#39; and Sage&lt;2016select Sno, Grade    from SC    where Cno=&#39;3&#39;    order by Grade desc17select *    from Student    order by Sdept asc, Sage desc18select count(Sno) as &#39;COUNT&#39;    from Student19select count(Sno) as COUNT        from (        select Sno                from SC                group by sno) as test20select avg(Grade) as AVG    from SC    where Cno=&#39;1&#39;21select max(Grade) as MAX    from SC    where Cno=&#39;1&#39;22select SUM(Ccredit) as SUM        from Course, SC        where Course.Cno=SC.Cno        and Sno=&#39;201215121&#39;23select Cno, count(Grade) as COUNT        from SC        group by Cno24select Sno        from(        select Sno, count(Grade) as COUNT                from SC                group by Sno            )as test        where COUNT&gt;225select Sno, AVG(Grade) as AVG        from SC        group by Sno        having AVG(Grade)&gt;=8826select Student.Sno, Sname, Ssex, Sage, Sdept, Cno, Grade    from Student inner join SC    on Student.Sno=SC.Sno27SELECT x.Cno, y.Cpno        FROM Course x, Course y        WHERE x.Cpno = y.Cno28select Student.Sno, Student.Sname        from Student, SC        where Student.Sno=SC.Sno                and SC.Cno=&#39;2&#39;                and SC.Grade&gt;8029select test.Sno, test.Sname, Course.Cname, test.Grade    from Course join        (select SC.Sno, SC.Cno, Student.Sname, SC.Grade            from Student join SC                on Student.Sno=SC.Sno)as test        on Course.Cno=test.Cno</code></pre><h2 id="Movie-相关题目"><a href="#Movie-相关题目" class="headerlink" title="Movie 相关题目"></a>Movie 相关题目</h2><pre><code class="sql">30select title        from movie        where director=&#39;Steven Spielberg&#39;31select year        from movie        where mID in (                select mID                from rating                where stars=&#39;4&#39; or stars=&#39;5&#39;                )        order by year asc32select title        from movie        where mID not in (                select mID                    from rating)33select name        from reviewer        where rID in (                select rID                        from rating                        where ratingDate is null)34select reviewer.name, test.title, test.stars, test.ratingDatefrom reviewer join (    select movie.title, rating.rID, rating.stars, rating.ratingDate    from movie join rating    on movie.mID=rating.mID    ) as teston reviewer.rID=test.rIDorder by reviewer.name, test.title, test.stars3537select movie.title, rating_2.stars_avg as starsfrom movie join (    select mID, AVG(stars) as stars_avg    from rating    group by mID) as rating_2on movie.mID=rating_2.mIDorder by stars desc, title38select namefrom reviewerwhere rID in(    select rID    from rating    group by rID    having COUNT(rID)&gt;=3)39select namefrom reviewerwhere rID in (select distinct rIDfrom ratingwhere mID in (    select mID    from movie    where title=&#39;Gone with the Wind&#39;)) 40 select temp.name as name, movie.title as title, temp.stars as stars    from movie join (        select rating.stars, reviewer.name, rating.mID        from rating join reviewer        on rating.rID=reviewer.rID) as temp    on movie.mID=temp.mID    where movie.director=temp.name</code></pre>]]></content>
      
      
      <categories>
          
          <category> DataBase </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>P509. 斐波那契数</title>
      <link href="blog/pmd7dz/"/>
      <url>blog/pmd7dz/</url>
      
        <content type="html"><![CDATA[<h3 id="509-斐波那契数"><a href="#509-斐波那契数" class="headerlink" title="509. 斐波那契数"></a>509. 斐波那契数</h3><pre><code class="java">class Solution &#123;    // TODO: for循环实现    public int fib(int N) &#123;        if (N &lt;= 1) return N;        int first = 0;        int second = 1;        for (int i = 0; i &lt; N - 1; i++) &#123;            int sum = first + second;            first = second;            second = sum;        &#125;        return second;    &#125;//    // TODO: 递归实现O(2^n)//    public int fib1(int n) &#123;//        if (n &lt;= 1) return n;//        return fib1(n - 1) + fib1(n - 2);//    &#125;//    // TODO: 首尾实现//    public int fib3(int n) &#123;//        if (n &lt;= 1) return n;//        int first = 0;//        int second = 1;//        while (n-- &gt; 1) &#123;//            second += first;//            first = second - first;//        &#125;//        return second;//    &#125;&#125;</code></pre><h3 id="509-斐波那契数-1"><a href="#509-斐波那契数-1" class="headerlink" title="509. 斐波那契数"></a>509. 斐波那契数</h3><pre><code class="java">// 递归：O(2^n)public static int fib1(int n) &#123;    if (n &lt;= 1) return n;    return fib1(n - 1) + fib1(n - 2);&#125;// for循环：O(n)public static int fib2(int n) &#123;    if (n &lt;= 1) return n;    int first = 0;    int second = 1;    for (int i = 0; i &lt; n - 1; i++) &#123;        int sum = first + second;        first = second;        second = sum;    &#125;    return second;&#125;// 首尾法public static int fib3(int n) &#123;    if (n &lt;= 1) return n;    int first = 0;    int second = 1;    while (n-- &gt; 1) &#123;        second += first;        first = second - first;    &#125;    return second;&#125;// 特征方程解法：O（1）public static int fib4(int n) &#123;    double c = Math.sqrt(5);    return (int) (Math.pow((1+c) / 2, n) - Math.pow((1-c) / 2, c));&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
          <category> 递归算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>P729. 我的日程安排表 I</title>
      <link href="blog/rwfqhp/"/>
      <url>blog/rwfqhp/</url>
      
        <content type="html"><![CDATA[<h3 id="729-我的日程安排表-I"><a href="#729-我的日程安排表-I" class="headerlink" title="729. 我的日程安排表 I"></a>729. 我的日程安排表 I</h3><pre><code class="java">class MyCalendar &#123;    int [] month = new int[30];    public MyCalendar() &#123;    &#125;    public boolean book(int start, int end) &#123;        boolean p = true;        if (month[start] == 1) &#123;            p = false;        &#125;        else &#123;            while (p) &#123;                int i = start;                month[i] = 1;                if (month[i+1] == 1) &#123;                    return p = false;                &#125;                i = i+1;            &#125;        &#125;        return p;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
          <category> Problems </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>P876. 链表的中间结点</title>
      <link href="blog/serpsb/"/>
      <url>blog/serpsb/</url>
      
        <content type="html"><![CDATA[<pre><code class="java">/** * public class ListNode &#123; *     int val; *     ListNode next; *     ListNode(int x) &#123; val = x; &#125; * &#125; */</code></pre><h2 id="876-链表的中间结点"><a href="#876-链表的中间结点" class="headerlink" title="876. 链表的中间结点"></a>876. 链表的中间结点</h2><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1603195941092-8cd11b96-c174-425e-ab68-a7015110092e.png#align=left&display=inline&height=208&margin=%5Bobject%20Object%5D&name=image.png&originHeight=415&originWidth=717&size=49665&status=done&style=shadow&width=358.5" alt="image.png"></p><h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h3><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><pre><code class="java">class Solution &#123;    public ListNode middleNode(ListNode head) &#123;        if (head.next == null) return head;        if (head.next.next == null) return head.next;        ListNode slow = head.next;        ListNode fast = head.next.next;        while (fast != null &amp;&amp; fast.next != null) &#123;            slow = slow.next;            fast = fast.next.next;            if (fast == null) return slow;        &#125;        return slow;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> DataStructure </category>
          
          <category> Problems </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>P83. 删除排序链表中的重复元素</title>
      <link href="blog/lg67md/"/>
      <url>blog/lg67md/</url>
      
        <content type="html"><![CDATA[<pre><code class="java">/** * public class ListNode &#123; *     int val; *     ListNode next; *     ListNode(int x) &#123; val = x; &#125; * &#125; */</code></pre><h2 id="83-删除排序链表中的重复元素"><a href="#83-删除排序链表中的重复元素" class="headerlink" title="83. 删除排序链表中的重复元素"></a>83. 删除排序链表中的重复元素</h2><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1603195897467-fdb33dfe-a1c0-4963-b76a-2c978f565801.png#align=left&display=inline&height=177&margin=%5Bobject%20Object%5D&name=image.png&originHeight=354&originWidth=727&size=22776&status=done&style=stroke&width=363.5" alt="image.png"></p><h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h3><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><pre><code class="java">class Solution &#123;    public ListNode deleteDuplicates(ListNode head) &#123;        // TODO: 快慢指针        if (head == null) return head;        ListNode slow = head;        ListNode fast = head.next;        while (fast != null)&#123;            if (slow.val != fast.val) &#123;                slow.next = fast;                slow = fast;            &#125;            fast = fast.next;        &#125;        slow.next = null;        return head;    &#125;&#125;// TODO: 单指针下一步//class Solution &#123;//    public ListNode deleteDuplicates(ListNode head) &#123;//        ListNode cur = head;//        while(cur != null &amp;&amp; cur.next != null) &#123;//            if(cur.val == cur.next.val) &#123;//                cur.next = cur.next.next;//            &#125; else &#123;//                cur = cur.next;//            &#125;//        &#125;//        return head;//    &#125;//&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> DataStructure </category>
          
          <category> Problems </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>P203. 移除链表元素</title>
      <link href="blog/kgpm3x/"/>
      <url>blog/kgpm3x/</url>
      
        <content type="html"><![CDATA[<pre><code class="java">/** * public class ListNode &#123; *     int val; *     ListNode next; *     ListNode(int x) &#123; val = x; &#125; * &#125; */</code></pre><h2 id="203-移除链表元素"><a href="#203-移除链表元素" class="headerlink" title="203. 移除链表元素"></a>203. 移除链表元素</h2><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1603195857807-2e8c8296-2d79-4e36-b304-f02c4dee52b3.png#align=left&display=inline&height=100&margin=%5Bobject%20Object%5D&name=image.png&originHeight=200&originWidth=729&size=15034&status=done&style=shadow&width=364.5" alt="image.png"></p><h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h3><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><pre><code class="java">class Solution &#123;    public ListNode removeElements(ListNode head, int val) &#123;        // 将整个链表想象成head+子链表        if (head == null)            return null;        // 先处理子链表        head.next = removeElements(head.next, val);        // 再处理头结点        return head.val == val ? head.next : head;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> DataStructure </category>
          
          <category> Problems </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>P141. 环形链表</title>
      <link href="blog/fgkbg2/"/>
      <url>blog/fgkbg2/</url>
      
        <content type="html"><![CDATA[<pre><code class="java">/** * public class ListNode &#123; *     int val; *     ListNode next; *     ListNode(int x) &#123; val = x; &#125; * &#125; */</code></pre><h2 id="141-环形链表"><a href="#141-环形链表" class="headerlink" title="141. 环形链表"></a>141. 环形链表</h2><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>给定一个链表，判断链表中是否有环。</p><p>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。</p><p>如果链表中存在环，则返回 true 。 否则，返回 false 。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1603195777983-5574f7c4-135c-45c2-aef2-6118e954bf68.png#align=left&display=inline&height=172&margin=%5Bobject%20Object%5D&name=image.png&originHeight=343&originWidth=726&size=36403&status=done&style=shadow&width=363" alt="image.png"></p><h3 id="问题思路"><a href="#问题思路" class="headerlink" title="问题思路"></a>问题思路</h3><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><pre><code class="java">public class Solution &#123;    public boolean hasCycle(ListNode head) &#123;        if (head == null || head.next == null) return false;        // TODO: 快慢指针        ListNode slow = head;        ListNode fast = head.next;        while (fast != null &amp;&amp; fast.next != null) &#123;            slow = slow.next;            fast = fast.next.next;            if (slow == fast) return true; //如果能相遇则表示有环        &#125;        return false; //不能相遇则没有环    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> DataStructure </category>
          
          <category> Problems </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>.gitignore文件使用总结</title>
      <link href="blog/hgxgvd/"/>
      <url>blog/hgxgvd/</url>
      
        <content type="html"><![CDATA[<div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">在Git项目将要提交到github仓库的时候，有些时候我们想要将指定文件不push，例如含有敏感信息类似token的文件，或者.class、.xml、等文件</div>​<h2 id="忽略指定文件的-push-的三种方式"><a href="#忽略指定文件的-push-的三种方式" class="headerlink" title="忽略指定文件的 push 的三种方式"></a>忽略指定文件的 push 的三种方式</h2><ul><li>方式一：在 Git 项目中定义.gitignore 文件</li><li>方式二：在 Git 项目的设置中指定排除文件</li><li>方式三：定义 Git 全局的 .gitignore 文件</li></ul><h2 id="语法规则"><a href="#语法规则" class="headerlink" title="语法规则"></a>语法规则</h2><pre><code>#               表示此为注释,将被Git忽略*.a             表示忽略所有 .a 结尾的文件!lib.a          表示但lib.a除外/TODO           表示仅仅忽略项目根目录下的 TODO 文件，不包括 subdir/TODObuild/          表示忽略 build/目录下的所有文件，过滤整个build文件夹；doc/*.txt       表示会忽略doc/notes.txt但不包括 doc/server/arch.txtbin/:           表示忽略当前路径下的bin文件夹，该文件夹下的所有内容都会被忽略，不忽略 bin 文件/bin:           表示忽略根目录下的bin文件/*.c:           表示忽略cat.c，不忽略 build/cat.cdebug/*.obj:    表示忽略debug/io.obj，不忽略 debug/common/io.obj和tools/debug/io.obj**/foo:         表示忽略/foo,a/foo,a/b/foo等a/**/b:         表示忽略a/b, a/x/b,a/x/y/b等!/bin/run.sh    表示不忽略bin目录下的run.sh文件*.log:          表示忽略所有 .log 文件config.php:     表示忽略当前路径的 config.php 文件/mtk/           表示过滤整个文件夹*.zip           表示过滤所有.zip文件/mtk/do.c       表示过滤某个具体文件被过滤掉的文件就不会出现在git仓库中（gitlab或github）了，当然本地库中还有，只是push的时候不会上传。需要注意的是，gitignore还可以指定要将哪些文件添加到版本管理中，如下：!*.zip!/mtk/one.txt唯一的区别就是规则开头多了一个感叹号，Git会将满足这类规则的文件添加到版本管理中。为什么要有两种规则呢？想象一个场景：假如我们只需要管理/mtk/目录中的one.txt文件，这个目录中的其他文件都不需要管理，那么.gitignore规则应写为：：/mtk/*!/mtk/one.txt假设我们只有过滤规则，而没有添加规则，那么我们就需要把/mtk/目录下除了one.txt以外的所有文件都写出来！注意上面的/mtk/*不能写为/mtk/，否则父目录被前面的规则排除掉了，one.txt文件虽然加了!过滤规则，也不会生效！----------------------------------------------------------------------------------还有一些规则如下：fd1/*说明：忽略目录 fd1 下的全部内容；注意，不管是根目录下的 /fd1/ 目录，还是某个子目录 /child/fd1/ 目录，都会被忽略；/fd1/*说明：忽略根目录下的 /fd1/ 目录的全部内容；/*!.gitignore!/fw//fw/*!/fw/bin/!/fw/sf/说明：忽略全部内容，但是不忽略 .gitignore 文件、根目录下的 /fw/bin/ 和 /fw/sf/ 目录；注意要先对bin/的父目录使用!规则，使其不被排除。</code></pre><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li>文章主要参考：<a href="https://www.cnblogs.com/kevingrace/p/5690241.html">https://www.cnblogs.com/kevingrace/p/5690241.html</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> VersionControlSystem </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>《围城》有感</title>
      <link href="essay/obs0vr/"/>
      <url>essay/obs0vr/</url>
      
        <content type="html"><![CDATA[<p>持续记录读这本书的所思所感所悟</p><div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">“城外的人想进来，城内的人想出去”</div><div style="background: #edf9e8;padding:10px;border: 1px solid #c2d2b5;border-radius:5px;margin-bottom:5px;">这真的是一种人生态度，每次用这句话对一系列问题进行思考的时候，我总喜欢在后面加上一句“活在当下，知足常乐”。</div><p>还是坐在教室里面的一些遐想…</p><p>我很难去想象一个没有选择权利的人会怎么样度过这么一生。这是一个极端，也是一个愿以安于现状的人的一种解脱，</p><p>还没看完，下次再写吧</p><hr><p>最大的围城，或许就是知识分子之间的吧，就像是一个圈子，这个圈子吧所谓的知识分子划分出来，而这个圈子里面的人或许又如井底的青蛙一样，甚至也不想出去呢~</p><p>滑稽的人呀，一切都貌似在追求一些虚无缥缈般地事物一样，易碎<code>fragile</code> ……</p>]]></content>
      
      
      <categories>
          
          <category> 一书一世界 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>计算方法课小记</title>
      <link href="essay/sdzqr3/"/>
      <url>essay/sdzqr3/</url>
      
        <content type="html"><![CDATA[<p>上计算方法课的那个老师，我严重怀疑他有山东口音，他讲话，一开始简直听不清，可能是我还不习惯山东话的缘故吧~可就是在那样的课堂里面，在那些个周里面，我真的是潜移默化般地学到了许多到许多……</p><p>大三上学期选了一门计算方法这门课，当时选的人不太多，四十几个吧，当时都是说这门课太难了，需要用到许多之前学习的高数、线代、概率统计等知识，我选这门课，一是自己比较喜欢数学，想着今后应该不做科研了，与数学不出意外应该是不会再相见了，还想再最后学习一下自己最喜欢的科目，也算是一种情怀吧~哈哈，在一个原因就是，这门课四个学分，四个学分！！</p><p>老师经常和我们说，算法就是解决实际问题，以前我们学的立刻当中，结果就是是与不是，但是这门课里面，没有对错，他经常让我们看到一个问题，不要立马去看树上的解答，他说书很局限思维，起初我不以为意，渐渐地，我发现了这位老师说的的确对，我记得有一次课是讲求积分，我一直觉得我高数学的还行，老师让我们尽自己所想，想出所有的解决方案，来解决求一个正态分布表这么个简单的问题，老师一再强调让我们不要有正确答案的想法，有解决方案即可，那次我记得那个问题同学们给出的解决方案有许许多多，插值、拟合、泰勒多项式展开、幂级数展开、求面积，多点函数值……</p><p>其实从那个时候，我对算法这个事物有了进一步的认识，就像这位常年带学校 ACM 队的老师所说，算法就是解决实际问题，没有什么对错，只有精度，优化，算法亦是如此，其实那个时候，我对算法设计与分析那门课程里面谈及的各种算法问题，各种算法思想，也有了更加一步的上帝视角来观望。</p><p>算法就是解决实际问题，手上敲的代码亦是如此。</p><p>他和我们说，我们现在在学校里面学的这些知识出去是用不到的，那为什么还学呢？</p><p>能力。他的这个回答，和我的回答一样，身处在这个技术迭代极快的情况下，更何况是计算机行业，我们要学的实在太多了，但是又如老师所言，但那些底层次的知识，那些思想，是我们这些学习者要学习的，我想老师想表达的更是一种万变不离其中的意味吧。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>博客与前端历程</title>
      <link href="essay/sgyoz3/"/>
      <url>essay/sgyoz3/</url>
      
        <content type="html"><![CDATA[<div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">大三上学期，学习计算机网络的应用层那里，我才知道我常写的原来叫博客……</div><h2 id="学习就要做笔记"><a href="#学习就要做笔记" class="headerlink" title="学习就要做笔记"></a>学习就要做笔记</h2><p>大二上学期期末那会，当时复习操作系统那会在想，为什么我现在想不起来我大一的 C 语言的一些知识呢？学过的知识过了许久没有记录，没有可以供自己想起的那般线索，还有什么意义呢？于是，那时我就想着在网上弄一个电子笔记吧。</p><p>于是，我认识了 Onenote，Onenote 很灵活，以至于太过灵活，不太适合发布文章，用了一段时间，想了想我还是想以发布文章的角色来做笔记</p><p>于是期末那段时间我就平时在网上搜适合我做电子笔记的平台，当时改不知道什么是博客，但是看~~很多人 ~~程序员都有自己的网站写点东西，于是就对其感兴趣了<br>再后来就发现很多人都拥有自己的个人网站，而且建立也很简单，一个 GitHub 就可以了，那会就一直玩 GitHub，利用 GitHub Pages 搭建了一个静态网站</p><p>疫情期间正好有一门选修课是 JavaWeb，那会我就接触了 CS 架构模型</p><p>疫情期间，在家发现网上有好多的博客大神。突然有那么一刹那，我突然意识到，我想写的不是笔记，也不是零零碎碎的小想法，我要写的是一篇篇博客，一篇篇文章呀！</p><p>从那之后，对前端就慢慢了解，前端很难，水很深，需要的自学能力甚至赶超其他行业。</p><h2 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h2><p>其实一直喜欢数据，大一那会，人工智能，机器学习啥的，都特别火，那会我也就学了 python，然后数据分析，那会我就挺喜欢数据分析挖掘的，将一堆杂乱的数据经过处理之后，就可以变成各种自己需要的各种数据，还能出图，matplotlib 包，我就特别喜欢用这个画各种图</p><p>2021.04.26 更<br>好的，已入前端坑 🙃，两个字——鬼魅～</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>万物守恒</title>
      <link href="essay/ipgq2m/"/>
      <url>essay/ipgq2m/</url>
      
        <content type="html"><![CDATA[<p>什么都是守恒的，我一直觉得这世界上很多事物都是守恒的</p><ul><li>有过很顺的时候，也有过身处逆境</li><li>有过巅峰，也有过没落</li><li>有些时候，你帮助陌生人，到某个时候，你也会被他人帮助</li><li>盛极一时的罗马，最后也败于自己</li><li>秦的大一统，也终将没落</li></ul>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++匿名函数</title>
      <link href="blog/uq89oe/"/>
      <url>blog/uq89oe/</url>
      
        <content type="html"><![CDATA[<h3 id="常用形式"><a href="#常用形式" class="headerlink" title="常用形式"></a>常用形式</h3><pre><code class="cpp">[](int x, int y) -&gt; int &#123; int z = x + y; return z; &#125; //这样显示指定返回类型:[](int x, int y) &#123; return x + y; &#125; // 隐式返回类型[](int&amp; x) &#123; ++x; &#125;   // 没有return语句 -&gt; lambda 函数的返回类型是&#39;void&#39;[]() &#123; ++global_x; &#125;  // 没有参数,仅访问某个全局变量[]&#123; ++global_x; &#125;     // 与上一个相同,省略了()</code></pre><h3 id="小例子"><a href="#小例子" class="headerlink" title="小例子"></a>小例子</h3><pre><code class="cpp">#include &lt;iostream&gt;int main() &#123;    // lambda表达式    auto multiply = [](int a, int b) -&gt; int &#123; return a * b; &#125;;    // 匿名函数调用    auto result = multiply(2, 4);    std::cout &lt;&lt; result &lt;&lt; std::endl;    return 0;&#125;</code></pre><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><blockquote><p>一些进一步用法<a href="https://www.cnblogs.com/pzhfei/archive/2013/01/14/lambda_expression.html">https://www.cnblogs.com/pzhfei/archive/2013/01/14/lambda_expression.html</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Language </category>
          
          <category> CPlusPlus </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Huffman编码算法</title>
      <link href="blog/ggu8v9/"/>
      <url>blog/ggu8v9/</url>
      
        <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>压缩算法，目的就是根据字母的出现频率来“按需分配”编码来优化编码方式。</p><p>比如：给出一串字母 <code>Huffman Coding</code>   ，按照计算机处理形式，会根据 ascll 码将这串字符编码，具体形式（十进制）就是 104 117 102 102 109 97 110 32 67 111 100 105 110 103，然后转换成二进制，最后会得到需要 97 个比特来存储。</p><h2 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h2><p>算法角度来讲对上述问题 ascll 编码方式是浪费空间的，优化方向是改变编码方式，根据字母出现的频率来“按需分配”进制位。</p><p>给出下面所给出的字母，以及出现的频率，来得到哈夫曼编码<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1605340774734-5ec5e8f1-0fae-47ff-8ded-dccf9611a3ad.png#height=45&id=pbDsY&margin=%5Bobject%20Object%5D&name=image.png&originHeight=89&originWidth=411&originalType=binary&size=4276&status=done&style=shadow&width=205.5" alt="image.png"><br>先提出将频率小的依次加入。d 和 h 组合权值为 9(或者说 A 只是称呼方便)，然后将这个 9“替换 d 和 h”代入整个序列，在进行插入树操作，</p><blockquote><p>过程中，遵循数字大的在左数字小的在右原则（互换也没关系，只不过换的是二进制的 0 和 1）</p></blockquote><p>在进行到 E 的时候，此时的队列应该为 120 107 42 37，所以此时需要重新调整队列，然后进行到结束。</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1605340899720-d8867a90-d01c-4bf6-8ec7-ca0e812a99dd.png#height=222&id=vJM66&margin=%5Bobject%20Object%5D&name=image.png&originHeight=443&originWidth=376&originalType=binary&size=24239&status=done&style=shadow&width=188" alt="image.png"><br>最后的编码结果为：<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1605341313840-61587c86-135d-4ba0-96aa-844868de1d56.png#height=101&id=ENEj4&margin=%5Bobject%20Object%5D&name=image.png&originHeight=201&originWidth=165&originalType=binary&size=4405&status=done&style=shadow&width=82.5" alt="image.png"></p><h2 id="编码实现"><a href="#编码实现" class="headerlink" title="编码实现"></a>编码实现</h2><pre><code class="cpp">#include &lt;stdio.h&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;namespace NS_HuffmanCoding &#123;using namespace std;void BuildHuffmanTree();void Initialization(vector&lt;pair&lt;char, int&gt;&gt; chars);void Finalization();struct HFMNode &#123;  char Ch; int Freq;  HFMNode* Left, * Right;  HFMNode(char pCh, int pFreq, HFMNode* pLeft, HFMNode* pRight)    : Ch(pCh), Freq(pFreq), Left(pLeft), Right(pRight) &#123;&#125;  HFMNode(char pCh, int pFreq)    : HFMNode(pCh, pFreq, NULL, NULL) &#123;&#125;&#125;;void MinHeapify(vector&lt;HFMNode*&gt;&amp; H);void InsertH(vector&lt;HFMNode*&gt;&amp; H, HFMNode* node);void SiftDown(vector&lt;HFMNode*&gt;&amp; H, int i);void SiftUp(vector&lt;HFMNode*&gt;&amp; H, int i);HFMNode* ExtractMin(vector&lt;HFMNode*&gt;&amp; H);void DeleteANode(HFMNode* node);void ShowInput(vector&lt;pair&lt;char, int&gt;&gt; chars);void Output();static vector&lt;HFMNode*&gt; Q;void HuffmanCodingCaller(vector&lt;pair&lt;char, int&gt;&gt; chars)&#123;  ShowInput(chars);  Initialization(chars);  BuildHuffmanTree();  Output();  Finalization();&#125;void BuildHuffmanTree()&#123;  char C = &#39;A&#39;;  while (Q.size() &gt; 1)  &#123;    HFMNode* x = ExtractMin(Q);    HFMNode* y = ExtractMin(Q);    HFMNode* z = new HFMNode(C++, x-&gt;Freq + y-&gt;Freq, x, y);    InsertH(Q, z);  &#125;&#125;HFMNode* ExtractMin(vector&lt;HFMNode*&gt;&amp; H)&#123;  swap(H.front(), H.back());  HFMNode* p = H.back();  H.pop_back();  if (!H.empty())    SiftDown(H, 0);  return p;&#125;void SiftDown(vector&lt;HFMNode*&gt;&amp; H, int i)&#123;    while ((i = (i &lt;&lt; 1) + 1) &lt; H.size()) &#123;        if ((i + 1 &lt; H.size()) &amp;&amp; (H[i + 1]-&gt;Freq &lt; H[i]-&gt;Freq))            i = i + 1;        if (H[(i - 1) &gt;&gt; 1]-&gt;Freq &gt; H[i]-&gt;Freq)            swap(H[(i - 1) &gt;&gt; 1], H[i]);        else break;    &#125;&#125;void InsertH(vector&lt;HFMNode*&gt;&amp; H, HFMNode* node)&#123;  H.push_back(node);  SiftUp(H, H.size() - 1);&#125;void SiftUp(vector&lt;HFMNode*&gt;&amp; H, int i)&#123;  while (i &gt; 0 &amp;&amp; H[i]-&gt;Freq &lt; H[(i - 1) &gt;&gt; 1]-&gt;Freq) &#123;    swap(H[i], H[(i - 1) &gt;&gt; 1]);    i = (i - 1) &gt;&gt; 1;  &#125;&#125;void MinHeapify(vector&lt;HFMNode*&gt;&amp; H)&#123;  for (int i = (H.size() &gt;&gt; 1) - 1; i &gt;= 0; i--) &#123;    SiftDown(H, i);  &#125;&#125;void Initialization(vector&lt;pair&lt;char, int&gt;&gt; chars)&#123;  Q.clear();  for (auto ch : chars)    Q.push_back(new HFMNode(ch.first, ch.second));  MinHeapify(Q);&#125;void Finalization()&#123;  DeleteANode(Q[0]);&#125;void DeleteANode(HFMNode* node)&#123;  if (node-&gt;Left)  &#123;    DeleteANode(node-&gt;Left);    DeleteANode(node-&gt;Right);  &#125;  delete node;&#125;void ShowInput(vector&lt;pair&lt;char, int&gt;&gt; chars)&#123;  printf(&quot;Huffman coding input: \n&quot;);  for (auto c : chars)    printf(&quot;%c,%d; &quot;, c.first, c.second);  printf(&quot;\n&quot;);&#125;static vector&lt;char&gt; coding;static vector&lt;pair&lt;char, vector&lt;char&gt;&gt;&gt; codingList;void GetHuffmanCoding(HFMNode* node)&#123;  if (node-&gt;Left)  &#123;    coding.push_back(&#39;0&#39;);    GetHuffmanCoding(node-&gt;Left);    coding.pop_back();    coding.push_back(&#39;1&#39;);    GetHuffmanCoding(node-&gt;Right);    coding.pop_back();  &#125;  else  &#123;    codingList.push_back(pair&lt;char,      vector&lt;char&gt;&gt;(node-&gt;Ch, coding));  &#125;&#125;void Output()&#123;  printf(&quot;Huffman coding:\n&quot;);  coding.clear();  codingList.clear();  GetHuffmanCoding(Q[0]);  sort(codingList.begin(), codingList.end());  for (auto c1 : codingList)  &#123;    printf(&quot;  %c: &quot;, c1.first);    for (auto c2 : c1.second)      printf(&quot;%c&quot;, c2);    printf(&quot;\n&quot;);  &#125;  printf(&quot;\n&quot;);&#125;&#125; //namespace NS_HuffmanCodingusing namespace NS_HuffmanCoding;void TestHuffmanCoding()&#123;  vector&lt;vector&lt;pair&lt;char, int&gt;&gt;&gt; charLists = &#123;      //Introduction to Algorithms     &#123;        &#123; &#123;&#39;a&#39;,40&#125;, &#123;&#39;b&#39;,13&#125;, &#123;&#39;c&#39;,12&#125;,          &#123;&#39;d&#39;,16&#125;, &#123;&#39;e&#39;,9&#125;, &#123;&#39;f&#39;,5&#125; &#125;,     &#125;,     //ÑÏÎµÃô     &#123;        &#123; &#123;&#39;a&#39;,5&#125;, &#123;&#39;b&#39;,29&#125;, &#123;&#39;c&#39;,7&#125;, &#123;&#39;d&#39;,8&#125;,          &#123;&#39;e&#39;,14&#125;, &#123;&#39;f&#39;,23&#125;, &#123;&#39;g&#39;,3&#125;, &#123;&#39;h&#39;,11&#125; &#125;,     &#125;,  &#125;;  int n = charLists.size();  for (int i = 0; i &lt; n; i++)  &#123;    HuffmanCodingCaller(charLists[i]);  &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
          <category> 贪心算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Kruskal最小生成树算法</title>
      <link href="blog/ghf568/"/>
      <url>blog/ghf568/</url>
      
        <content type="html"><![CDATA[<h2 id="一些概念"><a href="#一些概念" class="headerlink" title="一些概念"></a>一些概念</h2><p><strong>连通图</strong></p><blockquote><p>在<a href="https://baike.baidu.com/item/%E5%9B%BE%E8%AE%BA/1433806">图论</a>中，连通图基于连通的概念。在一个<a href="https://baike.baidu.com/item/%E6%97%A0%E5%90%91%E5%9B%BE/1680427">无向图</a> G 中，若从<a href="https://baike.baidu.com/item/%E9%A1%B6%E7%82%B9/11030118">顶点</a>i 到顶点 j 有路径相连（当然从 j 到 i 也一定有路径），则称 i 和 j 是连通的。如果 G 是<a href="https://baike.baidu.com/item/%E6%9C%89%E5%90%91%E5%9B%BE">有向图</a>，那么连接 i 和 j 的路径中所有的边都必须同向。如果图中任意两点都是连通的，那么图被称作连通图。如果此图是有向图，则称为强连通图（注意：需要双向都有路径）。图的<a href="https://baike.baidu.com/item/%E8%BF%9E%E9%80%9A%E6%80%A7/6688865">连通性</a>是图的基本性质。</p></blockquote><p><strong>生成树</strong></p><blockquote><p>包含图的全部顶点，边数最少的连通子图</p></blockquote><p><strong>最小生成树</strong></p><blockquote><p>总权值最小的生成树</p></blockquote><p>常见问题（该算法）就是求最小生成树。<br><strong>并查集</strong></p><blockquote><p>是一个数据结构，功能有查找 a 和 b 是否为同一组；将 a 和 b 合并为同一组。</p></blockquote><h2 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h2><p><code>Kruskal——克鲁斯卡尔算法</code></p><div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">贪心算法四个字总结：目前最优</div><p>把所有边按照权值全部按数值大小拿出来，然后按顺序选取每条边，利用并查集的思想，如果这条边的两个端点不属于同一集合，那么就将它们合并，直到所有的点都属于同一个集合为止。</p><p>比如有如下这么一个图：<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1605320252853-c5d445e4-aa0e-4279-b9fd-7477f23b1bc1.png#align=left&display=inline&height=95&id=Hx7aL&margin=%5Bobject%20Object%5D&name=image.png&originHeight=189&originWidth=438&size=10882&status=done&style=shadow&width=219" alt="image.png"><br>单独分析 ①② 边和 ③④ 边情况下，两个不在一个集合里面，<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1605320331669-51ec03dc-caf6-449d-9e8b-e4e62b9f35a6.png#align=left&display=inline&height=96&id=PuNRa&margin=%5Bobject%20Object%5D&name=image.png&originHeight=192&originWidth=769&size=21600&status=done&style=shadow&width=384.5" alt="image.png"><br>不断重复，不断判断是否为同一个集合，不在同一个集合的话，就合并，持续如此。比方说当一直操作到权值为 3 的时候，此时就需要将左右两个集合合并了<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1605320497092-00097419-4852-44c4-884e-febd4d37eb65.png#align=left&display=inline&height=101&id=wsUam&margin=%5Bobject%20Object%5D&name=image.png&originHeight=202&originWidth=748&size=22229&status=done&style=shadow&width=374" alt="image.png"><br>最后的结果样式就为如下<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1605320612085-d893c759-4ef1-410c-976e-8f32ddfe6321.png#align=left&display=inline&height=146&id=adOCr&margin=%5Bobject%20Object%5D&name=image.png&originHeight=292&originWidth=780&size=31319&status=done&style=shadow&width=390" alt="image.png"></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><pre><code class="cpp">#include &lt;stdio.h&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;namespace NS_KruskalMST &#123;using namespace std;void KruskalMST();int FindSet(int u);void UnionSets(int u, int v);void Initialization();void GenEdges();void MakeSets();void Output(int v0);#define INF INT_MAXstatic int n;static vector&lt;vector&lt;int&gt;&gt; WMatrix;static vector&lt;pair&lt;pair&lt;int, int&gt;, int&gt;&gt; Edges;//Node struct for the disjoint setstruct DJSNode &#123;    int Parent; int Rank;    DJSNode(int p) : Parent(p), Rank(0) &#123;&#125;&#125;;static vector&lt;DJSNode&gt; DisjointSet;static vector&lt;pair&lt;int, int&gt;&gt; MST;//The adjacency list for MSTstatic vector&lt;vector&lt;int&gt;&gt; MSTList;static vector&lt;int&gt; Prev;void KruskalMSTCaller(int an,    vector&lt;vector&lt;int&gt;&gt; &amp;wMatrix, int v0)&#123;    n = an;    WMatrix = wMatrix;    Initialization();    KruskalMST();    Output(v0);&#125;void KruskalMST()&#123;    for (auto &amp;e: Edges)    &#123;        int u = e.first.first;        int v = e.first.second;        int setU = FindSet(u);        int setV = FindSet(v);        if (setU != setV)        &#123;            MST.push_back(e.first);            if (MST.size() == n - 1)                break;            UnionSets(setU, setV);        &#125;    &#125;&#125;int FindSet(int u)&#123;    while (u != DisjointSet[u].Parent)        u = DisjointSet[u].Parent;        //For path compression:        //DisjointSet[u].Parent =        //    FindSet(DisjointSet[u].Parent);    return u;&#125;void UnionSets(int u, int v)&#123;    if (DisjointSet[u].Rank &gt;= DisjointSet[v].Rank)        DisjointSet[v].Parent = u;    else        DisjointSet[u].Parent = v;    if (DisjointSet[u].Rank == DisjointSet[v].Rank)        DisjointSet[u].Rank++;&#125;void Initialization()&#123;    GenEdges();    sort(Edges.begin(), Edges.end(),        [](pair&lt;pair&lt;int, int&gt;, int&gt;a,            pair&lt;pair&lt;int, int&gt;, int&gt;b)        &#123;return a.second &lt; b.second; &#125;);    MakeSets();    MST.clear();&#125;void GenEdges()&#123;    Edges.clear();    //Traverse the upper triangle of WMatrix    for (int i = 0; i &lt; n - 1; i++)    &#123;        for (int j = i + 1; j &lt; n; j++)            if (WMatrix[i][j] != INF)                Edges.push_back(&#123; &#123;i, j&#125;,                    WMatrix[i][j] &#125;);    &#125;&#125;void MakeSets()&#123;    DisjointSet.clear();    for (int i = 0; i &lt; n; i++)        DisjointSet.push_back(DJSNode(i));&#125;void OutputWMatrix()&#123;    printf(&quot;n = %d\n&quot;, n);    printf(&quot;The weight matrix:\n&quot;);    printf(&quot;%3c&quot;, &#39; &#39;);    for (int j = 0; j &lt; n; j++)        printf(&quot;%3d&quot;, j + 1);    printf(&quot;\n&quot;);    for (int i = 0; i &lt; n; i++)    &#123;        printf(&quot;%3d&quot;, i + 1);        for (auto j : WMatrix[i])            if (j &lt; INF)                printf(&quot;%3d&quot;, j);            else                printf(&quot;%3c&quot;, &#39;*&#39;);        printf(&quot;\n&quot;);    &#125;&#125;void OutputPath(int u)&#123;    if (Prev[u] == -1)        printf(&quot;%d&quot;, u + 1);    else    &#123;        OutputPath(Prev[u]);        printf(&quot;-%d&quot;, u + 1);    &#125;&#125;void GenMSTList()&#123;    MSTList.clear();    MSTList.resize(n);    for (auto &amp;e: MST)    &#123;        MSTList[e.first].push_back(e.second);        MSTList[e.second].push_back(e.first);    &#125;&#125;void GenPrev(int v)&#123;    for (auto &amp;u : MSTList[v])        if (u != -1)        &#123;            Prev[u] = v;            auto w = find(MSTList[u].begin(),                MSTList[u].end(), v);            MSTList[u][w - MSTList[u].begin()] = -1;            GenPrev(u);        &#125;&#125;void Output(int v0)&#123;    printf(&quot;Kruskal&#39;s MST algorithm\n&quot;);    OutputWMatrix();    int wSum = 0;    for (int i = 0; i &lt; n - 1; i++)        wSum += WMatrix[MST[i].first][MST[i].second];    GenMSTList();    Prev.clear();    Prev.resize(n);    Prev[v0] = -1;    GenPrev(v0);    printf(&quot;The MST edges:\n&quot;);    printf(&quot;Edge Weight\n&quot;);    for (auto &amp;e : MST)        printf(&quot; %d-%d  %d\n&quot;, e.first + 1, e.second + 1,            WMatrix[e.first][e.second]);    printf(&quot;Total MST weight: %d\n&quot;, wSum);    printf(&quot;The MST paths from vertex %d:\n&quot;, v0 + 1);    for (int u = 0; u &lt; n; u++)        if (u != v0)        &#123;            printf(&quot;%3d: &quot;, u + 1);            OutputPath(u);            printf(&quot;\n&quot;);        &#125;    printf(&quot;\n&quot;);&#125;&#125; //namespace NS_KruskalMSTusing namespace NS_KruskalMST;void TestKruskalMST(int v0 = 0)&#123;    vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt; w = &#123;        //https://www.geeksforgeeks.org/        //prims-minimum-spanning-tree-mst-greedy-algo-5/        &#123;            &#123;   0,  2,INF,  6,INF &#125;,            &#123;   2,  0,  3,  8,  5 &#125;,            &#123; INF,  3,  0,INF,  7 &#125;,            &#123;   6,  8,INF,  0,  9 &#125;,            &#123; INF,  5,  7,  9,  0 &#125;        &#125;,        // Dijkstra&#39;s algorithm on Wikipedia        &#123;            &#123;   0,  7,  9,INF,INF, 14 &#125;,            &#123;   7,  0, 10, 15,INF,INF &#125;,            &#123;   9, 10,  0, 11,INF,  2 &#125;,            &#123; INF, 15, 11,  0,  6,INF &#125;,            &#123; INF,INF,INF,  6,  0,  9 &#125;,            &#123;  14,INF,  2,INF,  9,  0 &#125;,        &#125;,        //https://www.geeksforgeeks.org/        //kruskals-minimum-spanning-tree-using-stl-in-c/        &#123;            &#123;   0,  4,INF,INF,INF,INF,INF,  8,INF &#125;,            &#123;   4,  0,  8,INF,INF,INF,INF, 11,INF &#125;,            &#123; INF,  8,  0,  7,INF,  4,INF,INF,  2 &#125;,            &#123; INF,INF,  7,  0,  9, 14,INF,INF,INF &#125;,            &#123; INF,INF,INF,  9,  0, 10,INF,INF,INF &#125;,            &#123; INF,INF,  4, 14, 10,  0,  2,INF,INF &#125;,            &#123; INF,INF,INF,INF,INF,  2,  0,  1,  6 &#125;,            &#123;   8, 11,INF,INF,INF,INF,  1,  0,  7 &#125;,            &#123; INF,INF,  2,INF,INF,INF,  6,  7,  0 &#125;,        &#125;,    &#125;;    int k = w.size();    for (int i = 0; i &lt; k; i++)    &#123;      if (v0 &gt; w[i].size() - 1)        v0 = w[i].size() - 1;      KruskalMSTCaller(w[i].size(), w[i], v0);    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
          <category> 贪心算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>api学习笔记</title>
      <link href="blog/frhg9i/"/>
      <url>blog/frhg9i/</url>
      
        <content type="html"><![CDATA[<h3 id="uniapp-官方里面的-API-相关信息"><a href="#uniapp-官方里面的-API-相关信息" class="headerlink" title="uniapp 官方里面的 API 相关信息"></a>uniapp 官方里面的 API 相关信息</h3><blockquote><p>列表的详情接口</p></blockquote><h4 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h4><ul><li>api<ul><li><a href="https://unidemo.dcloud.net.cn/api/news">https://unidemo.dcloud.net.cn/api/news</a></li></ul></li><li>返回数据格式<ul><li>post_id 新闻 id 如 ： 72980</li><li>title 标题</li><li>created_at 创建时间</li><li>author_avatar 图标</li></ul></li></ul><h4 id="详情"><a href="#详情" class="headerlink" title="详情"></a>详情</h4><ul><li><p><strong>地址</strong></p><blockquote><p><a href="https://unidemo.dcloud.net.cn/api/news/36kr/">https://unidemo.dcloud.net.cn/api/news/36kr/</a> + id（id 为新闻 id，上个页面传过来的）</p></blockquote></li><li><p><strong>使用 rich-text 【富文本组件】来展示新闻内容</strong></p></li></ul><p><code>&lt;rich-text class=&quot;richText&quot; :nodes=&quot;strings&quot;&gt;&lt;/rich-text&gt;</code></p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://blog.csdn.net/m15801872696/article/details/90141941?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.pc_relevant_is_cache&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.pc_relevant_is_cache">简单 api 的使用教程</a></li><li><a href="http://www.ruanyifeng.com/blog/2014/05/restful_api.html">阮一峰-RESTful API 设计指南</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
          <category> Vue </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>🔒GitHub Actions仓库分离代码分析</title>
      <link href="blog/xvletn/"/>
      <url>blog/xvletn/</url>
      
        <content type="html"><![CDATA[<p>这是加密文章！</p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>搭建Windows子系统Linux</title>
      <link href="blog/xnh83z/"/>
      <url>blog/xnh83z/</url>
      
        <content type="html"><![CDATA[<h2 id="Windows-子系统-Linux"><a href="#Windows-子系统-Linux" class="headerlink" title="Windows 子系统 Linux"></a>Windows 子系统 Linux</h2><h3 id="子系统-Linux-下载安装"><a href="#子系统-Linux-下载安装" class="headerlink" title="子系统 Linux 下载安装"></a>子系统 Linux 下载安装</h3><p>在 windows 里面搜索 <code>windows功能</code> <br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1604913834448-30d164c9-e0a6-47f8-baac-03c5d6648186.png#align=left&display=inline&height=517&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1033&originWidth=1176&size=659449&status=done&style=shadow&width=588" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1604913865729-b20b3a35-ab49-48c9-be97-9f3c56d6d7a6.png#align=left&display=inline&height=295&margin=%5Bobject%20Object%5D&name=image.png&originHeight=590&originWidth=623&size=61833&status=done&style=shadow&width=311.5" alt="image.png"><br>然后已知下一步操作即可，该过程中会有重启的过程。<br>之后重启之后在应用商店下载 Ubuntu 系统，如下。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1604913776014-38c5ce17-996d-4827-8c49-bb047b2f7d3c.png#align=left&display=inline&height=339&margin=%5Bobject%20Object%5D&name=image.png&originHeight=948&originWidth=1200&size=183352&status=done&style=shadow&width=429" alt="image.png"><br>然后启动的时候，会有让自己输入用户名和密码的情况。输入确认就好了（<strong>输入密码的时候，终端内不会显示光标以及输入的字符！但是会有密码验证</strong>）</p><h3 id="子系统-Linux-文件目录"><a href="#子系统-Linux-文件目录" class="headerlink" title="子系统 Linux 文件目录"></a>子系统 Linux 文件目录</h3><p><code>C:\Users\wztli\AppData\Local\Packages\CanonicalGroupLimited.UbuntuonWindows_79rhkp1fndgsc\LocalState\rootfs\home\wztlink1013</code> <br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1604914117863-4fc253c2-1978-44b1-94c6-48e82a3ddf3a.png#align=left&display=inline&height=111&margin=%5Bobject%20Object%5D&name=image.png&originHeight=221&originWidth=1468&size=28524&status=done&style=shadow&width=734" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1604914176405-056c5008-8168-40f8-a599-0e7951cad309.png#align=left&display=inline&height=293&margin=%5Bobject%20Object%5D&name=image.png&originHeight=585&originWidth=1406&size=115194&status=done&style=shadow&width=703" alt="image.png"></p><h3 id="Linux-访问-Windows-文件"><a href="#Linux-访问-Windows-文件" class="headerlink" title="Linux 访问 Windows 文件"></a>Linux 访问 Windows 文件</h3><p>如下图中 1 所示，访问时，需要先将 Windows 磁盘挂载到/mnt 下面，然后就可以访问了。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1604914600884-f758bc8f-668d-4354-be9f-f9be774cfff1.png#align=left&display=inline&height=189&margin=%5Bobject%20Object%5D&name=image.png&originHeight=378&originWidth=1122&size=63616&status=done&style=shadow&width=561" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> Environment </category>
          
          <category> 环境配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GitHub Pages相关使用</title>
      <link href="blog/di1z9u/"/>
      <url>blog/di1z9u/</url>
      
        <content type="html"><![CDATA[<div style="background: #FFFBE6;padding:10px;border: 1px solid #C3C3C3;border-radius:5px;margin-bottom:5px;">GitHub Pages是GitHub软件的一个页面展示功能，它可以让展示用户的个人信息，也可以为你在GitHub上存放的一个项目定制一个介绍页面（纯静态网站）</div>​<blockquote><p>官网地址：<a href="https://pages.github.com/">https://pages.github.com/</a></p></blockquote><h2 id="xxxx-github-io-仓库的创建"><a href="#xxxx-github-io-仓库的创建" class="headerlink" title="xxxx.github.io 仓库的创建"></a>xxxx.github.io 仓库的创建</h2><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616657760639-b6e36a91-6822-4ea2-9dc4-649ec5ef9768.png#height=126&id=uq7fd&margin=%5Bobject%20Object%5D&name=image.png&originHeight=251&originWidth=1893&originalType=binary%E2%88%B6=1&size=44413&status=done&style=stroke&width=946.5" alt="image.png"><br>创建一个用户名.github.io 的仓库，这个仓库的主分支下的静态网页就可以被访问到了，比如我创建的 wztlink1013.github.io 仓库，访问<a href="https://wztlink1013.github.io就可以访问了./">https://wztlink1013.github.io就可以访问了。</a></p><div style="background: #FFFBE6;padding:10px;border: 1px solid #C3C3C3;border-radius:5px;margin-bottom:5px;">需要注意的有：<ul><li>仓库必须有 index.html 文件</div></li></ul><h2 id="gh-pages-分支的使用"><a href="#gh-pages-分支的使用" class="headerlink" title="gh-pages 分支的使用"></a>gh-pages 分支的使用</h2><p>其他仓库（非 wztlink1013.github.io 仓库）下新建 gh-pages 分支，则 gh-pages 分支下的静态网页会被访问到，比如<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616658110985-fab12af6-362b-4fca-838c-78441e834197.png#height=340&id=GVSVP&margin=%5Bobject%20Object%5D&name=image.png&originHeight=679&originWidth=1891&originalType=binary%E2%88%B6=1&size=159234&status=done&style=stroke&width=945.5" alt="image.png"></p><h2 id="私有仓库下的共有-Pages"><a href="#私有仓库下的共有-Pages" class="headerlink" title="私有仓库下的共有 Pages"></a>私有仓库下的共有 Pages</h2><blockquote><p>Caution: This repository is private but the published site will be public.</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1605229290479-7c20a062-56f7-4f20-af37-b3354ca69daf.png#height=304&id=kY2We&margin=%5Bobject%20Object%5D&name=image.png&originHeight=857&originWidth=1252&originalType=binary%E2%88%B6=1&size=87132&status=done&style=stroke&width=444" alt="image.png"></p><div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">简单解释一下就是，仓库虽然是私有的，但是gh-pages下的静态页面将会被公开。</div><h2 id="gh-pages-分支下的静态-css-js-资源加载失败"><a href="#gh-pages-分支下的静态-css-js-资源加载失败" class="headerlink" title="gh-pages 分支下的静态 css/js 资源加载失败"></a>gh-pages 分支下的静态 css/js 资源加载失败</h2><div style="background: #FFF3F3;padding:10px;border: 1px solid #DEB8BE;border-radius:5px;margin-bottom:5px;">单个仓库下的gh-pages分支，可能导致静态网页css/js等文件加载不了，问题出在网站的css/js的引用方面上</div><div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">更改_yaml文件下的root的路径即可</div><p><strong>参考：</strong></p><ul><li><a href="https://blog.csdn.net/simple_the_best/article/details/53403787">https://blog.csdn.net/simple_the_best/article/details/53403787</a></li></ul><h2 id="使用-issues-搭建博客"><a href="#使用-issues-搭建博客" class="headerlink" title="使用 issues 搭建博客"></a>使用 issues 搭建博客</h2><p>这个就比较会玩了，将 GitHub 的 API 接口玩的溜溜的……<img src="https://cdn.nlark.com/yuque/0/2021/gif/1484158/1616657583331-5d034146-804a-44e8-a90e-994f86de946a.gif#height=90&id=NXawR&margin=%5Bobject%20Object%5D&name=huaji53f28867be2378c3.gif&originHeight=90&originWidth=90&originalType=binary%E2%88%B6=1&size=8805&status=done&style=none&width=90" alt="huaji53f28867be2378c3.gif"><br>先插个眼，日后技术学到家再来玩玩这个<img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1616657633200-0f3a1324-21c2-4165-a23f-9a86ac69f399.jpeg#height=50&id=K09k5&margin=%5Bobject%20Object%5D&name=huaji-19bbf9b05f8aad09.jpeg&originHeight=50&originWidth=51&originalType=binary%E2%88%B6=1&size=969&status=done&style=none&width=51" alt="huaji-19bbf9b05f8aad09.jpeg"><strong>​</strong><br><strong>参考：</strong></p><ul><li><a href="https://github.com/Pines-Cheng/blog">https://github.com/Pines-Cheng/blog</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> VersionControlSystem </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>一个梦——“一切都太迟了”</title>
      <link href="essay/gx3g8t/"/>
      <url>essay/gx3g8t/</url>
      
        <content type="html"><![CDATA[<p>那天早上，老康起得很早，五点就起床了，说是要坐车去考教资，然后我突然迷迷糊糊被他起床的动静吵醒了，那天早上，我终于想起了什么…原来，黑魔法是存在的！！！</p><p><strong>和一批人上山</strong><br>有好几伙人，同时登上山顶，像是被什么所指引那般，都像是阻止什么，又好像是为了得到什么……</p><p><strong>我的境遇</strong><br>山顶那个小栈好像是取某个物品，</p><p>夜晚某个时辰，周围突然陷入黑暗，所有人都匆匆忙忙跑下山，那个客栈里面，大量的黑烟逐渐弥漫开来，我们都内心里面清楚，太迟了，我们都太迟了！</p><p>我赶紧跑下山，摔到了一个村庄，然后一直跑，跑到我那个伙伴的家里，我看到了我那副眼镜，然后一直跑，跑回我自己的地方了</p>]]></content>
      
      
      <categories>
          
          <category> 异世界 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[转]uni-app相关知识</title>
      <link href="blog/ytoag7/"/>
      <url>blog/ytoag7/</url>
      
        <content type="html"><![CDATA[<blockquote><ul><li>本文转载自：<a href="https://ask.dcloud.net.cn/article/35657">白话 uni-app </a></li><li>添加部分细节自己写的内容</li></ul></blockquote><h2 id="uni-app-相对传统的变化"><a href="#uni-app-相对传统的变化" class="headerlink" title="uni-app 相对传统的变化"></a>uni-app 相对传统的变化</h2><h3 id="网络模型的变化"><a href="#网络模型的变化" class="headerlink" title="网络模型的变化"></a>网络模型的变化</h3><p>之前学习的<code>javaweb</code>形式的是“相互嵌套”类型的，<code>jsp</code>代码里面可以有<code>html</code>代码。</p><p>以前网页大多是 b/s，服务端代码混合在页面里；<br>现在是 c/s，前后端分离，通过 js api(类似 ajax 的<code>uni.request</code>)获取 json 数据，把数据绑定在界面上渲染。</p><h3 id="文件类型变化"><a href="#文件类型变化" class="headerlink" title="文件类型变化"></a>文件类型变化</h3><p>.vue 文件通过编译，编译 js 文件</p><h3 id="代码架构大变动"><a href="#代码架构大变动" class="headerlink" title="代码架构大变动"></a>代码架构大变动</h3><p>以前的 HTML 代码节点，有 html 大节点，还有 script 和 style 两个小结点</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html&gt;  &lt;head&gt;    &lt;meta charset=&quot;utf-8&quot; /&gt;    &lt;title&gt;&lt;/title&gt;    &lt;script type=&quot;text/javascript&quot;&gt;&lt;/script&gt;    &lt;style type=&quot;text/css&quot;&gt;&lt;/style&gt;  &lt;/head&gt;  &lt;body&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>现在 template 是一级节点，用于写<strong>tag 组件</strong>，script 和 style 是并列的一级节点，也就是有 3 个一级节点</p><pre><code class="vue">&lt;template&gt;  &lt;view&gt;    注意必须有一个view，且只能有一个根view。所有内容写在这个view下面。  &lt;/view&gt;&lt;/template&gt;&lt;script&gt;export default &#123;&#125;;&lt;/script&gt;&lt;style&gt;&lt;/style&gt;</code></pre><ul><li><a href="https://cn.vuejs.org/v2/guide/single-file-components.html">Vue 单文件组件</a></li></ul><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="组件-标签的变化"><a href="#组件-标签的变化" class="headerlink" title="组件/标签的变化"></a>组件/标签的变化</h3><p>下为 html 标签和 uni-app 内置组件的映射表：<br>（其实老的 HTML 标签也可以在 uni-app 里使用，uni-app 编译器会在编译时把老标签转为新标签，比如把 div 编译成 view。但不推荐这种用法，调试 H5 端时容易混乱。）</p><ul><li>div 改成 <a href="https://uniapp.dcloud.io/component/view">view</a></li><li>span、font 改成 <a href="https://uniapp.dcloud.io/component/text">text</a></li><li>a 改成 <a href="https://uniapp.dcloud.io/component/navigator">navigator</a></li><li>img 改成 <a href="https://uniapp.dcloud.io/component/image">image</a></li><li><a href="https://uniapp.dcloud.io/component/input">input</a> 还在，但 type 属性改成了 confirmtype</li><li><a href="https://uniapp.dcloud.io/component/form">form</a>、<a href="https://uniapp.dcloud.io/component/button">button</a>、<a href="https://uniapp.dcloud.io/component/checkbox">checkbox</a>、<a href="https://uniapp.dcloud.io/component/radio">radio</a>、<a href="https://uniapp.dcloud.io/component/label">label</a>、<a href="https://uniapp.dcloud.io/component/textarea">textarea</a>、<a href="https://uniapp.dcloud.io/component/canvas">canvas</a>、<a href="https://uniapp.dcloud.io/component/video">video</a> 这些还在。</li><li>select 改成 <a href="https://uniapp.dcloud.io/component/picker">picker</a></li><li>iframe 改成 <a href="https://uniapp.dcloud.io/component/web-view">web-view</a></li><li>ul、li 没有了，都用 view 替代</li><li>audio 不再推荐使用，改成 api 方式，<a href="https://uniapp.dcloud.io/api/media/background-audio-manager?id=getbackgroundaudiomanager">背景音频 api 文档</a></li></ul><p><strong>除了改动外，新增了一批手机端常用的新组件</strong></p><ul><li>scroll-view <a href="https://uniapp.dcloud.io/component/scroll-view">可区域滚动视图容器</a></li><li>swiper <a href="https://uniapp.dcloud.io/component/swiper">可滑动区域视图容器</a></li><li>icon <a href="https://uniapp.dcloud.io/component/icon">图标</a></li><li>rich-text <a href="https://uniapp.dcloud.io/component/rich-text">富文本（不可执行 js，但可渲染各种文字格式和图片）</a></li><li>progress <a href="https://uniapp.dcloud.io/component/progress">进度条</a></li><li>slider <a href="https://uniapp.dcloud.io/component/slider">滑块指示器</a></li><li>switch <a href="https://uniapp.dcloud.io/component/switch">开关选择器</a></li><li>camera <a href="https://uniapp.dcloud.io/component/camera">相机</a></li><li>live-player <a href="https://uniapp.dcloud.io/component/live-player">直播</a></li><li>map <a href="https://uniapp.dcloud.io/component/map">地图</a></li><li>cover-view <a href="https://uniapp.dcloud.io/component/cover-view?id=cover-view">可覆盖原生组件的视图容器</a><br>cover-view 需要多强调几句，uni-app 的非 h5 端的 video、map、canvas、textarea 是原生组件，层级高于其他组件。如需覆盖原生组件，则需要使用 cover-view 组件。详见<a href="https://uniapp.dcloud.net.cn/component/native-component">层级介绍</a></li></ul><p>除了内置组件，还有很多开源的扩展组件，把常用操作都进行封装，DCloud 建立了插件市场收录这些扩展组件，详见<a href="https://ext.dcloud.net.cn/">插件市场</a></p><h3 id="工程结构和页面管理"><a href="#工程结构和页面管理" class="headerlink" title="工程结构和页面管理"></a>工程结构和页面管理</h3><p>uni-app 的工程结构有单独的要求，<a href="https://uniapp.dcloud.io/frame?id=%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84">详见</a></p><p>每个可显示的页面，都必须在 <a href="https://uniapp.dcloud.io/collocation/pages">pages.json</a> 中注册。如果你开发过小程序，那么 pages.json 类似 app.json。如果你熟悉 vue，这里没有 vue 的路由，都是在 pages.json 里管理。</p><p>原来工程的首页一般是 index.html 或 default.html，是在 web server 里配的。而 uni-app 的首页，是在 pages.json 里配的，page 节点下第一个页面就是首页。一般在/pages/xx 的目录下。</p><p>app 和小程序中，为了提升体验，页面提供了原生的导航栏和底部 tabbar，注意这些配置是在 pages.json 中做，而不是在 vue 页面里创建，但点击事件的监听在显示的 vue 页面中做。</p><p>如果你熟悉小程序开发的话，对比变化如下：</p><ul><li>原来 app.json 被一拆为二。页面管理，被挪入了 uni-app 的 pages.json；非页面管理，挪入了 manifest.json</li><li>原来的 app.js 和 app.wxss 被合并到了 app.vue 中</li></ul><h2 id="文件导入方式变化"><a href="#文件导入方式变化" class="headerlink" title="文件导入方式变化"></a>文件导入方式变化</h2><h3 id="js-引入方式"><a href="#js-引入方式" class="headerlink" title="js 引入方式"></a>js 引入方式</h3><p>以前通过<code>script ``src</code>、<code>link ``href</code>引入外部的 js 和 css；<br>现在是<strong>es6</strong>的写法，<code>import</code>引入外部的 js 模块(注意不是文件)或 css<br>以前</p><pre><code class="javascript">&lt;script src=&quot;js/jquery-1.10.2.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;&lt;link href=&quot;css/bootstrap.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot;/&gt;</code></pre><p>现在</p><blockquote><p>js 要 require 进来，变成了对象。</p></blockquote><p>在 hello uni-app 项目的 common 目录有一个工具类<code>util.js</code>，可以在 hello uni-app 中搜索这个例子查看。</p><pre><code class="javascript">&lt;script&gt;  var util = require(&#39;../../../common/util.js&#39;); //require这个js模块 var  formatedPlayTime = util.formatTime(playTime); //调用js模块的方法&lt;/script&gt;</code></pre><p>而在这个<code>util.js</code>里，要把之前的 function 封装为对象的方法<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1604048264989-b4591bb0-e4bc-4581-aae5-bf7615f268b4.png#height=231&id=wkQ3w&margin=%5Bobject%20Object%5D&name=image.png&originHeight=606&originWidth=1331&originalType=binary&size=70716&status=done&style=shadow&width=508" alt="image.png"><br>当然还有一些高级的用法</p><pre><code class="javascript">var dateUtils = require(&quot;../../../common/util.js&quot;).dateUtils; //直接使用js模块的属性。在hello uni-app有示例import * as echarts from &quot;/components/echarts/echarts.simple.min.js&quot;; //将js导入并重命名为echarts，然后使用echarts.来继续执行方法。</code></pre><h3 id="CSS-引入方式"><a href="#CSS-引入方式" class="headerlink" title="CSS 引入方式"></a>CSS 引入方式</h3><pre><code class="css">&lt;style&gt;    @import &quot;./common/uni.css&quot;;    .uni-hello-text&#123;        color:#7A7E83;    &#125;&lt;/style&gt;</code></pre><p><strong>改全局样式：</strong>在根目录下的 app.vue 里写入，每个页面都会加载 app.vue 里的样式。</p><h3 id="组件导入"><a href="#组件导入" class="headerlink" title="组件导入"></a>组件导入</h3><p>类似 hexo 博客主题设计一样，能以组件的形式模块化导入。<br>如下是导入一个角标的组件库，在页面上显示一个 abc 并且右上角有个数字角标 1，<a href="http://ext.dcloud.net.cn/plugin?id=21">详见</a></p><pre><code class="vue">&lt;template&gt;  &lt;view&gt;    &lt;uni-badge text=&quot;abc&quot; :inverted=&quot;true&quot;&gt;&lt;/uni-badge    &gt;&lt;!--3.使用组件--&gt;  &lt;/view&gt;&lt;/template&gt;&lt;script&gt;import uniBadge from &quot;../../../components/uni-badge.vue&quot;; //1.导入组件（这步属于传统vue规范，但在uni-app的easycom下可以省略这步）export default &#123;  data() &#123;    return &#123;&#125;;  &#125;,  components: &#123;    uniBadge, //2.注册组件（这步属于传统vue规范，但在uni-app的easycom下可以省略这步）  &#125;,&#125;;&lt;/script&gt;</code></pre><p>如需要全局导入 vue 组件，即每个页面都可以直接使用而不用引用和注册的话，在项目根目录下的 main.js 里处理。如下是 hello uni-app 里的例子。</p><pre><code class="javascript">//main.jsimport pageHead from &quot;./components/page-head.vue&quot;; //导入Vue.component(&quot;page-head&quot;, pageHead); //注册。注册后在每个vue的page页面里可以直接使用&lt;page-head&gt;&lt;/page-head&gt;组件。</code></pre><p>上述的组件使用方式属于传统 vue 的概念。uni-app 2.7 以后推出了更简单的组件使用技术<a href="https://uniapp.dcloud.net.cn/collocation/pages?id=easycom">easycom</a>，无需引用和注册组件，直接在 template 区域使用组件即可。</p><h2 id="js-的变化"><a href="#js-的变化" class="headerlink" title="js 的变化"></a>js 的变化</h2><p>js 的变化，分为<strong>运行环境变化</strong>、<strong>数据绑定模式变化</strong>、<strong>api 变化</strong>3 部分。</p><h3 id="运行环境从浏览器变成-v8-引擎"><a href="#运行环境从浏览器变成-v8-引擎" class="headerlink" title="运行环境从浏览器变成 v8 引擎"></a>运行环境从浏览器变成 v8 引擎</h3><p>标准 js 语法和 api 都支持，比如 if、for、settimeout、indexOf 等。</p><p>但<strong>浏览器专用的</strong>window、document、navigator、location 对象，包括 cookie 等存储，<strong>只有在浏览器中才有</strong>，app 和小程序都不支持。</p><blockquote><p>可能有些人以为 js 等于浏览器里的 js。其实 js 是 ECMAScript 组织管理的，浏览器中的 js 是 w3c 组织基于 js 规范补充了 window、document、navigator、location 等专用对象。</p></blockquote><p>在 uni-app 的各个端中，除了 h5 端，其他端的 js 都运行在一个独立的 v8 引擎下，不是在浏览器中，所以浏览器的对象无法使用。如果你做过小程序开发，对此应当很了解。<br><strong>这意味着依赖 document 的很多 HTML 的库，比如 jqurey 无法使用。</strong><br>当然 app 和小程序支持 web-view 组件，里面可以加载标准 HTML，这种页面仍然支持浏览器专用对象 window、document、navigator、location。</p><h3 id="以前的-dom-操作，改成-vue-的-MVVM-模式"><a href="#以前的-dom-操作，改成-vue-的-MVVM-模式" class="headerlink" title="以前的 dom 操作，改成 vue 的 MVVM 模式"></a>以前的 dom 操作，改成 vue 的 MVVM 模式</h3><p>现在前端趋势是去 dom 化，改用<strong>mvvm 模式，</strong>更简洁的写法，大幅减少代码行数，同时差量渲染性能更好。<br>uni-app 使用 vue 的数据绑定方式解决 js 和 dom 界面交互的问题。<br>如果你想改变某个 dom 元素的显示内容，比如一个 view 的显示文字：<br><strong>以前</strong>是给 view 设 id，然后 js 里通过选择器获取 dom 元素，进一步通过 js 进行赋值操作，修改 dom 元素的属性或值。<br>如下演示了一段代码，页面中有个显示的文字区和一个按钮，点击按钮后会修改文字区的值</p><pre><code class="html">&lt;html&gt;  &lt;head&gt;    &lt;script type=&quot;text/javascript&quot;&gt;      document.addEventListener(&quot;DOMContentLoaded&quot;, function () &#123;        document.getElementById(&quot;spana&quot;).innerText = &quot;456&quot;;      &#125;);      function changetextvalue() &#123;        document.getElementById(&quot;spana&quot;).innerText = &quot;789&quot;;      &#125;    &lt;/script&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;span id=&quot;spana&quot;&gt;123&lt;/span&gt;    &lt;button type=&quot;button&quot; onclick=&quot;changetextvalue()&quot;&gt;修改为789&lt;/button&gt;  &lt;/body&gt;&lt;/html&gt;</code></pre><p>现在的做法，是<strong>vue 的绑定模式</strong>，给这个<strong>dom 元素绑定一个 js 变量</strong>，在 script 中修改 js 变量的值，dom 会自动变化，页面会自动更新渲染</p><pre><code class="vue">&lt;template&gt;  &lt;view&gt;    &lt;text&gt;&#123;&#123; textvalue &#125;&#125;&lt;/text    &gt;&lt;!-- 这里演示了组件值的绑定 --&gt;    &lt;button :type=&quot;buttontype&quot; @click=&quot;changetextvalue()&quot;&gt;修改为789&lt;/button    &gt;&lt;!-- 这里演示了属性和事件的绑定 --&gt;  &lt;/view&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  data() &#123;    return &#123;      textvalue: &quot;123&quot;,      buttontype: &quot;primary&quot;,    &#125;;  &#125;,  onLoad() &#123;    this.textvalue = &quot;456&quot;; //这里修改textvalue的值，其实123都来不及显示就变成了456  &#125;,  methods: &#123;    changetextvalue() &#123;      this.textvalue = &quot;789&quot;; //这里修改textvalue的值，页面自动刷新为789    &#125;,  &#125;,&#125;;&lt;/script&gt;</code></pre><p>注意上述代码中的 <code>export default &#123;&#125;</code> 里的 <code>data(): &#123;return &#123; &#125;&#125;</code>。<br>在 vue 的设计中，这里存放着页面中需要绑定的数据，写在 data 里，才能被界面正确的绑定和渲染。<br>注意：uni-app 的 vue 页面是 vue 的单文件组件规范，按照 vue 的定义只接受 function，必须用 return 包起来。<br>如果你学过小程序的数据绑定，但不了解 vue，要注意：</p><ul><li>小程序的数据绑定参考了 vue，但自己修改了一些。在 uni-app 中只支持标准的 vue，不支持小程序的数据绑定语法</li><li>小程序里的 setData 在 uni-app 里并不存在，因为 vue 是自动双向数据绑定的。直接通过赋值方式修改数据，如果数据绑定到界面上，界面会自动更新渲染</li></ul><p>从上述示例，还可看出事件的写法变化。</p><ul><li>以前，元素的事件是用 onxxx=””，里面写一段 js 或引用 function 的 name，比如上述代码中的<code>onclick=&quot;changetextvalue()&quot;</code></li><li>现在，需要在 js 的<code>export default &#123;&#125;</code> 里的 <code>methods: &#123;&#125;</code> 里写一个方法，然后在组件中使用<code>@click=&quot;changetextvalue()&quot;</code></li></ul><p>在 js 中，与 data 和 methods 平级的，如上述示例代码中的<code>onload()</code>，称为生命周期。在普通 vue 页面里的生命周期叫页面生命周期。在项目根目录的 app.vue 文件中的生命周期叫应用生命周期。<br>除了<code>onload</code>，还有<code>onready</code>等很多生命周期，具体见<a href="https://uniapp.dcloud.io/collocation/frame/lifecycle">uni-app 的生命周期</a><br>在高级用法里，<strong>vue 支持给组件设 ref（引用标记）</strong>，这类似于之前 html 中给一个 dom 元素设 id，然后在 js 中也可以用<code>this.$refs.xxx</code>来获取。如下：</p><pre><code class="vue">&lt;template&gt;  &lt;view&gt;    &lt;view ref=&quot;testview&quot;&gt;11111&lt;/view&gt;    &lt;button @click=&quot;getTest&quot;&gt;获取test节点&lt;/button&gt;  &lt;/view&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  methods: &#123;    getTest() &#123;      console.log(this.$refs.testview);    &#125;,  &#125;,&#125;;&lt;/script&gt;</code></pre><h3 id="js-api-的变化"><a href="#js-api-的变化" class="headerlink" title="js api 的变化"></a>js api 的变化</h3><p>因为 uni-app 的 api 是<strong>参考小程序</strong>的，所以<strong>和浏览器的 js api</strong>有很多不同，如</p><ol><li>alert,confirm 改成 <a href="https://uniapp.dcloud.io/api/ui/prompt?id=showmodal">uni.showmodel</a></li><li>ajax 改成 <a href="https://uniapp.dcloud.io/api/request/request">uni.request</a></li><li>cookie、session 没有了，local.storage 改成 <a href="https://uniapp.dcloud.io/api/storage/storage?id=setstorage">uni.storage</a></li></ol><p>uni-app 的 js api 还有很多，但基本就是小程序的 api，把 wx.xxx 改为 uni.xxx 即可。<a href="https://uniapp.dcloud.io/api/README">详见</a><br>uni-app 在不同的端，支持条件编译，无限制的使用各端独有的 api，<a href="https://uniapp.dcloud.io/platform">详见条件编译</a></p><h2 id="css-的变化"><a href="#css-的变化" class="headerlink" title="css 的变化"></a>css 的变化</h2><p><strong>标准的 css 基本都是支持的。</strong></p><h3 id="选择器方面"><a href="#选择器方面" class="headerlink" title="选择器方面"></a>选择器方面</h3><blockquote><p>有 2 个变化：</p></blockquote><ol><li>*选择器不支持；</li><li>元素选择器里没有 body，改为了 page。微信小程序即是如此。</li></ol><pre><code class="css">page &#123;&#125;</code></pre><ul><li><strong>单位方面：</strong>px 无法动态适应不同宽度的屏幕，rem 无法用于 nvue/weex。如果想使用根据屏幕宽度自适应的单位，推荐使用 rpx，全端支持。 <a href="https://uniapp.dcloud.io/frame?id=%E5%B0%BA%E5%AF%B8%E5%8D%95%E4%BD%8D">尺寸单位文档</a></li><li><strong>布局方面：</strong>uni-app 推荐使用 flex 布局，这个布局思路和传统流式布局有点区别。但 flex 的特色在于，不管是什么技术都支持这种排版，web、小程序/快应用、weex/rn、原生的 iOS、Android 开发，全都支持 flex。它是通吃所有端的新一代布局方案。相关教程请自行百度学习。</li></ul><h3 id="flex"><a href="#flex" class="headerlink" title="flex"></a>flex</h3><p>uni-app 的 vue 文件里支持所有 web 排版方式，不管是流式还是 flex。但 nvue 里，只支持 flex，因为它在 app 端是使用原生排版引擎渲染的。<br><strong>注意 css 里背景图和字体文件，尽量不要大于 40k，因为会影响性能。在小程序端，如果要大于 40k，需放到服务器侧远程引用或 base64 后引入，不能放到本地作为独立文件引用。</strong></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://uniapp.dcloud.net.cn/">https://uniapp.dcloud.net.cn/</a></li><li><a href="https://cn.vuejs.org/index.html">https://cn.vuejs.org/index.html</a></li><li>官方教程：<a href="https://ke.qq.com/course/343370">uni-app 跨平台框架官方教程</a></li><li><a href="https://ask.dcloud.net.cn/article/35657">白话 uni-app </a></li><li>微信官方文档：<a href="https://developers.weixin.qq.com/doc/">https://developers.weixin.qq.com/doc/</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
          <category> Web其他 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++广义表</title>
      <link href="blog/gosz5u/"/>
      <url>blog/gosz5u/</url>
      
        <content type="html"><![CDATA[<h2 id="广义表举例"><a href="#广义表举例" class="headerlink" title="广义表举例"></a>广义表举例</h2><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1620291002536-6b098e81-6400-4139-876b-9ef890f1dc71.png#align=left&display=inline&height=183&margin=%5Bobject%20Object%5D&name=image.png&originHeight=366&originWidth=1337&size=242885&status=done&style=stroke&width=668.5" alt="image.png"></p><h2 id="广义表的-3-个重要结论"><a href="#广义表的-3-个重要结论" class="headerlink" title="广义表的 3 个重要结论"></a>广义表的 3 个重要结论</h2><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1620291048426-17db6fbb-8972-4d82-980e-6ff303f55752.png#align=left&display=inline&height=359&margin=%5Bobject%20Object%5D&name=image.png&originHeight=718&originWidth=1409&size=353253&status=done&style=stroke&width=704.5" alt="image.png"></p><h2 id="广义表的运算"><a href="#广义表的运算" class="headerlink" title="广义表的运算"></a>广义表的运算</h2><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1620291080210-d88e7855-41ed-45be-a433-1a60a64d3220.png#align=left&display=inline&height=291&margin=%5Bobject%20Object%5D&name=image.png&originHeight=581&originWidth=1390&size=377721&status=done&style=stroke&width=695" alt="image.png"></p><h2 id="一些题目"><a href="#一些题目" class="headerlink" title="一些题目"></a>一些题目</h2><blockquote><p>（13）广义表 A=(a,b,(c,d),(e,(f,g)))，则 Head(Tail(Head(Tail(Tail(A)))))的值为（  ）。<br>A．(g)            B．(d)             C．c            D．d</p></blockquote><p>答案：D<br>解释：Tail(A)=(b,(c,d),(e,(f,g)))；Tail(Tail(A))=( (c,d),(e,(f,g)))； Head(Tail(Tail(A)))= (c,d)；Tail(Head(Tail(Tail(A))))=(d)；Head(Tail(Head(Tail(Tail(A)))))=d。</p><blockquote><p>（14）广义表((a,b,c,d))的表头是（  ），表尾是（  ）。<br>A．a              B．( )             C．(a,b,c,d)      D．(b,c,d)</p></blockquote><p>答案：C、B<br>解释：表头为非空广义表的第一个元素，可以是一个单原子，也可以是一个子表，((a,b,c,d))的表头为一个子表(a,b,c,d)；表尾为除去表头之外，由其余元素构成的表，表为一定是个广义表，((a,b,c,d))的表尾为空表( )。</p><blockquote><p>（15）设广义表 L=((a,b,c))，则 L 的长度和深度分别为（  ）。<br>A．1 和 1          B．1 和 3          C．1 和 2          D．2 和 3</p></blockquote><p>答案：C<br>解释：广义表的深度是指广义表中展开后所含括号的层数，广义表的长度是指广义表中所含元素的个数。根据定义易知 L 的长度为 1，深度为 2。</p>]]></content>
      
      
      <categories>
          
          <category> DataStructure </category>
          
          <category> 线结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>周围的喧嚣</title>
      <link href="essay/nqm77s/"/>
      <url>essay/nqm77s/</url>
      
        <content type="html"><![CDATA[<p>现在的文章，喧嚣</p><p>动不动一篇文章出来个广告</p><p>目的性太强</p><p>为了写而写，就像是，文字什么时候变得这么苍白</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>js-Cannot set property &#39;innerHTML&#39; of null</title>
      <link href="blog/fg4az5/"/>
      <url>blog/fg4az5/</url>
      
        <content type="html"><![CDATA[<h2 id="报错信息"><a href="#报错信息" class="headerlink" title="报错信息"></a>报错信息</h2><pre><code class="javascript">Cannot set property &#39;innerHTML&#39; of null</code></pre><h2 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h2><p>如果 js 放在头部时，此时浏览器渲染未进入 dom 节点，因为提示为空，或者找不到。<br>所以把 js 代码放到最后或调用的对象后面就行了。id 元素在 script 脚本之后，不能引用，类似在使用变量之前对其进行定义一样。</p>]]></content>
      
      
      <categories>
          
          <category> Bug </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>npm- ERR! Unexpected end of JSON input while parsing</title>
      <link href="blog/gcwu9h/"/>
      <url>blog/gcwu9h/</url>
      
        <content type="html"><![CDATA[<h2 id="报错信息"><a href="#报错信息" class="headerlink" title="报错信息"></a>报错信息</h2><pre><code class="bash">npm WARN deprecated circular-json@0.5.9: CircularJSON is in maintenance only, flatted is its successor.npm ERR! Unexpected end of JSON input while parsing near &#39;...:&quot;~0.0.0&quot;,&quot;webpack-de&#39;npm ERR! A complete log of this run can be found in:npm ERR! C:\文件路径\npm-cache_logs\2018-12-13T10_24_02_151Z-debug.logPackage install failed, see above.</code></pre><p>（具体的报错信息和这个类似）<br>升级 hexo5.0 过程中，npm i –save 出错，各种插件都不能很好的下载。</p><h2 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h2><p>在 node 安装目录下配置的 node_cache 目录里面 <code>D:\Develop\nodejs</code> <br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1603808754530-64316710-95b9-4e13-98dd-efda5197f782.png#align=left&display=inline&height=167&margin=%5Bobject%20Object%5D&name=image.png&originHeight=487&originWidth=1128&size=62358&status=done&style=shadow&width=387" alt="image.png"><br>系统盘的 AppData/roaming 的文件夹并没有一个 npm 的缓存目录，安装 node 的时候将<code>D:\Develop\nodejs</code> 放到系统环境变量的 Path 路径了。</p><p>所以只需要一下两条命令即可</p><pre><code class="bash">npm cache clean --forcenpm install</code></pre><p>**</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://stackoverflow.com/questions/53759929/npm-err-unexpected-end-of-json-input-while-parsing">stackoverflow-npm ERR! Unexpected end of JSON input while parsing</a></li><li><a href="https://www.ruanyifeng.com/blog/2016/01/npm-install.html">阮一峰-npm 模块安装机制简介</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Bug </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>《许三观卖血记》</title>
      <link href="essay/ghwn6o/"/>
      <url>essay/ghwn6o/</url>
      
        <content type="html"><![CDATA[<p>===有一个场景我记得很清楚，当许玉兰被批斗的时候，许三观送饭，在饭下面藏着几块肉，那样的场景，温情脉脉<br>还有在家里的时候，玉兰说出自己曾经的种种不堪的事情的时候，许三观为了在几个儿子面前维护玉兰，也同等说出自己的许多不堪的事<br>我觉得，这种关系，才像是一起经历过苦难的夫妻作为，那个家庭场景，老实说，我感到很有温度</p><p>===小说最后，让我有点痛心的就是三个儿子对许三观说出的一番话。<br>子女永远不知道自己父母付出的有多少<br>好在身边一直有的是玉兰。</p><p>===突然又想到《活着》，突然又想到富贵的人生似乎更为惨淡，一生下来，经历种种苦楚，最后的人生和一头老牛在田野远远望去<br>家珍，还有一个女儿，一个儿子…说实话，他们的结局，也是挺悲惨的……</p>]]></content>
      
      
      <categories>
          
          <category> 一书一世界 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CPP-LINK : fatal error LNK1561: 必须定义入口点</title>
      <link href="blog/oyvpk4/"/>
      <url>blog/oyvpk4/</url>
      
        <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><pre><code class="cpp">LINK : fatal error LNK1561: 必须定义入口点</code></pre><h2 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h2><p>每个应用程序(文件格式为 exe)都应该有个启动点，这个点就是 main 函数。缺少就会出现 link error 。</p><p>解决方法</p><ol><li>添加含有 main 函数的 CPP 文件</li><li>右击属性，在常规项中修改配置类型，将应用程序修改为库，动静态库</li></ol>]]></content>
      
      
      <categories>
          
          <category> Bug </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>分治算法+归并排序</title>
      <link href="blog/ab9fkt/"/>
      <url>blog/ab9fkt/</url>
      
        <content type="html"><![CDATA[<h2 id="分治算法"><a href="#分治算法" class="headerlink" title="分治算法"></a>分治算法</h2><p>此前学习的<strong>递归设计方法</strong>，是针对规模大的问题拆成规模小的问题，并且规模大的问题和规模小的问题的解决办法相同。</p><p>分治算法与递归设计方法的不同之处就是，该规模较大的问题分解为多个不重叠的子问题，并将其称为<strong>“分而治之”</strong><br>**<br>分治的三个步骤：</p><ol><li>分解：将原问题分解为若干个规模较小、相互不重叠与原问题形式相同的子问题</li><li>解决：<ol><li>若子问题规模较小且易于解决时候直接解出</li><li>否则递归地解决各个子问题</li></ol></li><li>合并：将各个子问题的解个并未原问题的解</li></ol><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h3><ul><li>分解：将排序数组分解为左右两个相等的不重叠的数组</li><li>解决：递归</li><li>合并：将两个已经有序的数组合并为一个有序的数组</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1603617542157-07613fda-ebed-4924-bf6a-091c19b12fc7.png#align=left&display=inline&height=431&margin=%5Bobject%20Object%5D&name=image.png&originHeight=861&originWidth=895&size=74826&status=done&style=shadow&width=447.5" alt="image.png"></p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
          <category> 分治算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>IDEA-控制台输出中文乱码问题</title>
      <link href="blog/lkgrkx/"/>
      <url>blog/lkgrkx/</url>
      
        <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>在 java 实现 ping/tracert 两个命令时候，输出到控制台里面中文乱码。</p><h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>应该是调用了终端，而 windows 的终端默认是 GBK 的编码，所以要对其更改管用的 utf-8 编码，改为 GBK 编码。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1603613519544-dc851d0f-e0c0-4a0a-9a2d-0043285b3db0.png#align=left&display=inline&height=441&margin=%5Bobject%20Object%5D&name=image.png&originHeight=881&originWidth=706&size=74813&status=done&style=shadow&width=353" alt="image.png"></p><h2 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h2><h3 id="编码更改"><a href="#编码更改" class="headerlink" title="编码更改"></a>编码更改</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1603613302488-7bd6d045-81c3-470c-a57c-05a020588fcd.png#align=left&display=inline&height=511&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1022&originWidth=1449&size=141645&status=done&style=shadow&width=724.5" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1603613687953-21f1bbc9-b0bc-4db4-a935-3fcf6275909f.png#align=left&display=inline&height=185&margin=%5Bobject%20Object%5D&name=image.png&originHeight=369&originWidth=1920&size=135691&status=done&style=shadow&width=960" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1603613719305-ac9dc39b-2c6a-4350-9f31-49d48dbedfe5.png#align=left&display=inline&height=110&margin=%5Bobject%20Object%5D&name=image.png&originHeight=220&originWidth=764&size=24151&status=done&style=none&width=382" alt="image.png"></p><ul><li><code>Reload</code> 表示使用新编码重新加载，新编码不会保存到文件中</li><li><code>Convert</code> 表示使用新编码进行转换，新编码会保存到文件中</li><li>含有中文的代码文件，<code>Convert</code> 之后可能会使中文变成乱码，所以在转换成请做好备份，不然可能出现转换过程变成乱码，无法还原</li></ul><h3 id="BOM-问题"><a href="#BOM-问题" class="headerlink" title="BOM 问题"></a>BOM 问题</h3><blockquote><p>BOM：byte-order mark 字节顺序标记<br><a href="https://zh.wikipedia.org/wiki/%E4%BD%8D%E5%85%83%E7%B5%84%E9%A0%86%E5%BA%8F%E8%A8%98%E8%99%9F">https://zh.wikipedia.org/wiki/%E4%BD%8D%E5%85%83%E7%B5%84%E9%A0%86%E5%BA%8F%E8%A8%98%E8%99%9F</a></p></blockquote><p>可能会出现的问题有：</p><blockquote><p>编译报错：<code>找不到符号</code>、<code>未结束的字符串文字</code> 或者是 提示 <code>非法字符</code></p></blockquote><p>解决办法：有上述百科可知，UTF-8 编码分有 BOM 和无 BOM 两种分类。IDEA 打开 Eclipse 项目，会提示出现上述编译问题，因为<strong>Eclipse 默认是有 BOM 的文件编译</strong>，而<strong>IDEA 只能编译无 BOM 的文件编译</strong>，所以解决办法就是对项目进行<strong>BOM 去除</strong>操作。</p>]]></content>
      
      
      <categories>
          
          <category> Bug </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>莱文斯坦距离(LD)问题</title>
      <link href="blog/bvk4ok/"/>
      <url>blog/bvk4ok/</url>
      
        <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p><strong>Levenshtein Distance</strong>也称<strong>莱文斯坦距离</strong></p><p>具体形式就是求一个字符串到另一个字符串所需要的<strong>最少操作步数</strong>，操作形式有：</p><ul><li>替换字母</li><li>删除字母</li><li>插入字母</li></ul><h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>利用动态规划思想，将其剖析为一个个子问题，用其子问题的解决方式来解决该问题。问题分解出来的子问题存在重叠的情况，这是区分分治算法的不同。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1603615056984-36cbce7c-c55e-456a-bb90-eb18471167e0.png#align=left&display=inline&height=335&margin=%5Bobject%20Object%5D&name=image.png&originHeight=670&originWidth=1026&size=202356&status=done&style=shadow&width=513" alt="image.png"></p><p><strong>莱文斯坦的公式化</strong>表述为：<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1603614727015-dad259b0-7904-4e5d-9ec8-f4ac284af2e5.png#align=left&display=inline&height=94&margin=%5Bobject%20Object%5D&name=image.png&originHeight=188&originWidth=874&size=23400&status=done&style=shadow&width=437" alt="image.png"></p><p>下面利用表格的形式来步步推出该字母所需要达到相应的目标字母序列的步数。</p><p>| |<br>| s | o | n |<br>| — | — | — | — | — |<br>|<br>| 0 | 1 | 2 | 3 |<br>| s | 1 | 0 | 1 | 2 |<br>| u | 2 | 1 | 1 | 2 |<br>| n | 3 | 2 | 2 | 1 |</p><p>记横（son）为 i 字符串序列，纵（sun）为 j 字符串序列。需要完成的字符串变换为 i-&gt;j。现举例格子数值该怎么填：</p><p>当到了第三行第三列的那一格，需要完成 s-&gt;s，有三种情况可以选择</p><ol><li>左操作(i-1,j)：删除 s 字符然后插入 s 字符===操作步数两步</li><li>上操作(i,j-1)：插入 s 字符然后删除 s 字符===操作步数两步</li><li>左上操作(i-1,j-1)：替换步骤，因为这个元素相同，故===操作步数零部</li></ol><p>然后选取上述三种情况最短步数的数值 0</p><p>然后再看第三行第四列，需要完成 so-&gt;s，</p><ol><li>左操作：删除 o===一步</li><li>上操作：插入 s 删除 so===三步</li><li>做上操作：替换 s 删除 o===两步</li></ol><p>综上应该填 1</p><p>其他格子也一样以上述方法填写。</p><p>有个作业遗留问题，在 CAAIS 里面每个得出的值右上标的 <code>U</code>  <code>L</code>  <code>0</code>  <code>1</code>  这些的依次顺序是怎么个顺序？<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1603615446981-23bea432-08ee-490a-9037-018ba6280c3b.png#align=left&display=inline&height=201&margin=%5Bobject%20Object%5D&name=image.png&originHeight=401&originWidth=651&size=49834&status=done&style=shadow&width=325.5" alt="image.png"></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><pre><code class="cpp">#include &lt;string&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;ctime&gt;const int LEN_NAME=100;namespace NS_LSEditDist &#123;    using namespace std;    void Initialization(const string &amp;x, const string &amp;y);    int GetLSEditDist(const string &amp;x, const string &amp;y);    void GetLSEdits(const string &amp;x, const string &amp;y);    void Output(const string &amp;x, const string &amp;y, int OptD);    void OutputE(const string &amp;x, const string &amp;y);    void OutputP(const string &amp;x, const string &amp;y);    static int m, n;    static vector&lt;vector&lt;int&gt;&gt; E;    static vector&lt;vector&lt;char&gt;&gt; P;    static string xe, ye;    void LSEditDistCaller(const string &amp;x, const string &amp;y)    &#123;        Initialization(x, y);        int OptD = GetLSEditDist(x, y);        GetLSEdits(x, y);        Output(x, y, OptD);    &#125;    int GetLSEditDist(const string &amp;x, const string &amp;y)    &#123;        for (int i = 1; i &lt;= m; i++)            for (int j = 1; j &lt;= n; j++)            &#123;                E[i][j] = min(E[i - 1][j] + 1,                              min(E[i][j - 1] + 1,                                  E[i - 1][j - 1] + (x[i - 1] != y[j - 1])));                if (E[i][j] == E[i - 1][j] + 1)                    P[i][j] = &#39;U&#39;;                else if (E[i][j] == E[i][j - 1] + 1)                    P[i][j] = &#39;L&#39;;                else if (x[i - 1] != y[j - 1])                    P[i][j] = &#39;1&#39;;            &#125;        return E[m][n];    &#125;    void GetLSEdits(const string &amp;x, const string &amp;y)    &#123;        int i = m, j = n;        while (i &gt; 0 || j &gt; 0)        &#123;            if (P[i][j] == &#39;0&#39; || P[i][j] == &#39;1&#39;)            &#123;                xe.insert(0, 1, x[i - 1]);                ye.insert(0, 1, y[j - 1]);                i--; j--;            &#125;            else if (P[i][j] == &#39;U&#39;)            &#123;                xe.insert(xe.begin(), x[i - 1]);                ye.insert(ye.begin(), &#39;-&#39;);                i--;            &#125;            else            &#123;                xe.insert(xe.begin(), &#39;-&#39;);                ye.insert(ye.begin(), y[j - 1]);                j--;            &#125;        &#125;    &#125;    void Initialization(const string &amp;x, const string &amp;y)    &#123;        m = x.length();        n = y.length();        E.clear();        E.resize(m + 1, vector&lt;int&gt;(n + 1, 0));        P.clear();        P.resize(m + 1, vector&lt;char&gt;(n + 1, &#39;0&#39;));        for (int j = 1; j &lt;= n; j++)        &#123;            E[0][j] = j;            P[0][j] = &#39;L&#39;;        &#125;        for (int i = 1; i &lt;= m; i++)        &#123;            E[i][0] = i;            P[i][0] = &#39;U&#39;;        &#125;        xe.clear();        ye.clear();    &#125;    void Output(const string &amp;x, const string &amp;y, int OptD)    &#123;        printf(&quot;Levenshtein distance: \n&quot;);        printf(&quot;Strings: %s, %s\n\n&quot;, x.c_str(), y.c_str());        OutputE(x, y);        OutputP(x, y);        printf(&quot;Distance: %d\n&quot;, OptD);        printf(&quot;Edited strings:\n&quot;);        for (auto c : xe)            printf(&quot;%2c&quot;, c);        printf(&quot;\n&quot;);        for (auto c : ye)            printf(&quot;%2c&quot;, c);        printf(&quot;\n\n&quot;);    &#125;    void OutputE(const string &amp;x, const string &amp;y)    &#123;        printf(&quot; E  &quot;);        for (int j = 0; j &lt; n; j++)            printf(&quot;%2c&quot;, y[j]);        printf(&quot;\n&quot;);        for (int i = 0; i &lt;= m; i++)        &#123;            if (i == 0)                printf(&quot;  &quot;);            else                printf(&quot;%2c&quot;, x[i - 1]);            for (int j = 0; j &lt;= n; j++)            &#123;                printf(&quot;%2d&quot;, E[i][j]);            &#125;            printf(&quot;\n&quot;);        &#125;        printf(&quot;\n&quot;);    &#125;    void OutputP(const string &amp;x, const string &amp;y)    &#123;        printf(&quot; P  &quot;);        for (int j = 0; j &lt; n; j++)            printf(&quot;%2c&quot;, y[j]);        printf(&quot;\n&quot;);        for (int i = 0; i &lt;= m; i++)        &#123;            if (i == 0)                printf(&quot;  &quot;);            else                printf(&quot;%2c&quot;, x[i - 1]);            for (int j = 0; j &lt;= n; j++)            &#123;                printf(&quot;%2c&quot;, P[i][j]);            &#125;            printf(&quot;\n&quot;);        &#125;        printf(&quot;\n&quot;);    &#125;&#125; //namespace NS_LSEditDistchar *rand_str(char *str,const int len)&#123;    int i;    for(i=0;i&lt;len;++i)        str[i]=&#39;a&#39;+rand()%26;    str[++i]=&#39;\0&#39;;    return str;&#125;using namespace NS_LSEditDist;int main()&#123;    vector&lt;vector&lt;string&gt;&gt; abs = &#123;            &#123; &quot;water&quot;, &quot;wheat&quot; &#125;,            &#123; &quot;servant&quot;, &quot;reveal&quot; &#125;    &#125;;    for (auto ab : abs)    &#123;        string a = ab[0];        string b = ab[1];        LSEditDistCaller(a, b);    &#125;    cout&lt;&lt;&quot;两个100位字符串的LevenShtein距离：&quot;&lt;&lt;endl;    srand(time(NULL));    int i;    char name[LEN_NAME+1];    string x = rand_str(name,LEN_NAME);    string y = rand_str(name,LEN_NAME);    cout&lt;&lt;&quot;字符串1：&quot;&lt;&lt;x&lt;&lt;endl;    cout&lt;&lt;&quot;字符串2：&quot;&lt;&lt;y&lt;&lt;endl;    LSEditDistCaller(x, y);&#125;</code></pre><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://zh.wikipedia.org/wiki/%E8%90%8A%E6%96%87%E6%96%AF%E5%9D%A6%E8%B7%9D%E9%9B%A2">莱文斯坦距离</a></li><li><a href="https://www.dazhuanlan.com/2019/12/06/5dea0cb03281f/">理解 Levenshtein Distancee</a></li><li><a href="https://www.throwable.club/2020/03/08/learn-about-levenshtein-distance-algorithm/">Levenshtein Distance（编辑距离）算法与使用场景</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
          <category> 动态规划算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>利用WireShark捕获并分析以太网报文结构</title>
      <link href="blog/bw80k6/"/>
      <url>blog/bw80k6/</url>
      
        <content type="html"><![CDATA[<blockquote><p>学习网络协议分析工具 WireShark，利用 WireShark 捕获并分析以太网报文结构，最重要的是后面超星网登录案例分析，用实际例子将计网的所学知识串起来。</p></blockquote><blockquote><p>文章更新内容说明：无线上网和有线上网的 MAC 地址是不一样的<br>【查看本地地址的截图是在家里的查看，wireshark 的使用是在学校】</p></blockquote><h2 id="查看信息"><a href="#查看信息" class="headerlink" title="查看信息"></a>查看信息</h2><h3 id="查看本地的-mac-地址"><a href="#查看本地的-mac-地址" class="headerlink" title="查看本地的 mac 地址"></a>查看本地的 mac 地址</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612839562082-cbc1fcf8-a520-4820-bafc-e26f07ba1177.png#align=left&display=inline&height=248&margin=%5Bobject%20Object%5D&name=image.png&originHeight=496&originWidth=1920&size=78833&status=done&style=shadow&width=960" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612839610832-5568023d-da16-41af-b95e-1787acadf747.png#align=left&display=inline&height=402&margin=%5Bobject%20Object%5D&name=image.png&originHeight=804&originWidth=1335&size=109239&status=done&style=shadow&width=667.5" alt="image.png"></p><h3 id="ping-命令"><a href="#ping-命令" class="headerlink" title="ping 命令"></a>ping 命令</h3><blockquote><p>先使用 ping 命令找到需要抓包的网站的 ip 地址</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612845955475-12f08386-5ec4-4b3f-8cbf-56059d79677c.png#align=left&display=inline&height=162&margin=%5Bobject%20Object%5D&name=image.png&originHeight=323&originWidth=828&size=51064&status=done&style=shadow&width=414" alt="image.png"></p><h2 id="WireShark-使用"><a href="#WireShark-使用" class="headerlink" title="WireShark 使用"></a>WireShark 使用</h2><h3 id="WireShark-使用及面板功能区域"><a href="#WireShark-使用及面板功能区域" class="headerlink" title="WireShark 使用及面板功能区域"></a>WireShark 使用及面板功能区域</h3><p>进入软件，若成功适配电脑网卡，则出现如下类似接口列表<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1603434019601-cc879af3-8784-4ada-83dc-642d64e02981.png#align=left&display=inline&height=329&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1038&originWidth=1920&size=115692&status=done&style=shadow&width=608" alt="image.png"><br>直接双击上图中 WLAN 行即可抓包，也可以如下设置网卡启动抓包<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1603434096441-73c67d75-4e36-4e76-ae3c-0a8b8976da28.png#align=left&display=inline&height=301&margin=%5Bobject%20Object%5D&name=image.png&originHeight=911&originWidth=1920&size=114148&status=done&style=shadow&width=634" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1603431676018-f4988b52-5aef-4d92-8b9b-15109a08adab.png#align=left&display=inline&height=345&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1033&originWidth=1920&size=207427&status=done&style=shadow&width=641" alt="image.png"></p><h3 id="1-区域-显示过滤器"><a href="#1-区域-显示过滤器" class="headerlink" title="1 区域-显示过滤器"></a>1 区域-显示过滤器</h3><blockquote><p>为过滤 ip 地址区域。相关表达式语法有</p></blockquote><ol><li>协议过滤。比如 TCP，只显示 TCP 协议。</li><li>IP 过滤。比如 ip.src == 192.168.1.102,显示源地址为 192.168.1.102，</li></ol><p>ip.dst == 192.168.1.102, 目标地址为 192.168.1.102。</p><ol start="3"><li>端口过滤。   tcp.port ==80,   端口为 80 的</li></ol><p>tcp.srcport == 80,只显示 TCP 协议的愿端口为 80 的。</p><ol start="4"><li>Http 模式过滤。http.request.method==”GET”,   只显示 HTTP GET 方法的。</li><li>逻辑运算符为 AND/ OR</li></ol><h3 id="2-区域-获取的数据包"><a href="#2-区域-获取的数据包" class="headerlink" title="2 区域-获取的数据包"></a>2 区域-获取的数据包</h3><blockquote><p>封包列表(Packet List Pane)</p></blockquote><h3 id="3-区域-单个数据包各层详细内容"><a href="#3-区域-单个数据包各层详细内容" class="headerlink" title="3 区域-单个数据包各层详细内容"></a>3 区域-单个数据包各层详细内容</h3><blockquote><p>选定的封包详细信息 (Packet Details Pane)</p></blockquote><ol><li>Frame:物理层的数据帧概况。</li></ol><pre><code class="http">Frame 165: 74 bytes on wire (592 bits), 74 bytes captured (592 bits) on interface \Device\NPF_&#123;B016AB5D-3088-41BD-8997-48F19D9DEBFA&#125;, id 0 //165号帧，对方发送74字节，实际收到74字节    Interface id: 0 (\Device\NPF_&#123;B016AB5D-3088-41BD-8997-48F19D9DEBFA&#125;) //接口id为0        Interface name: \Device\NPF_&#123;B016AB5D-3088-41BD-8997-48F19D9DEBFA&#125;        Interface description: WLAN    Encapsulation type: Ethernet (1) //封装类型    Arrival Time: Oct 23, 2020 13:37:43.372763000 中国标准时间//捕获日期和时间（中国标准时间）    [Time shift for this packet: 0.000000000 seconds]    Epoch Time: 1603431463.372763000 seconds    [Time delta from previous captured frame: 0.008472000 seconds]//与前一包时间间隔    [Time delta from previous displayed frame: 0.000000000 seconds]    [Time since reference or first frame: 36.349570000 seconds]//此包与第一帧的时间间隔    Frame Number: 165//帧序号    Frame Length: 74 bytes (592 bits)//帧长度    Capture Length: 74 bytes (592 bits)//捕获字节长度    [Frame is marked: False]//是否做了标记    [Frame is ignored: False]//是否被忽略    [Protocols in frame: eth:ethertype:ip:icmp:data]//帧内封装的协议层次结构    [Coloring Rule Name: ICMP]//着色标记的协议名称    [Coloring Rule String: icmp || icmpv6]//着色规则显示的字符串</code></pre><ol start="2"><li>Ethernet II:数据链路层以太网帧头部信息。</li></ol><pre><code class="http">Ethernet II, Src: IntelCor_fb:33:94 (0c:54:15:fb:33:94), Dst: HuaweiTe_da:ff:f3 (7c:a1:77:da:ff:f3)    Destination: HuaweiTe_da:ff:f3 (7c:a1:77:da:ff:f3)//目的MAC地址    Source: IntelCor_fb:33:94 (0c:54:15:fb:33:94)//源MAC地址（就是我电脑的MAC地址）    Type: IPv4 (0x0800)//0x0800表示使用IP协议</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1603432754493-20843464-3bbb-4c01-9ceb-e781759a583d.png#align=left&display=inline&height=280&margin=%5Bobject%20Object%5D&name=image.png&originHeight=559&originWidth=1920&size=110051&status=done&style=shadow&width=960" alt="image.png"></p><ol start="3"><li>Internet Protocol Version 4:互联网层 IP 包头部信息。</li></ol><pre><code class="http">Internet Protocol Version 4, Src: 192.168.43.36, Dst: 39.156.66.18    0100 .... = Version: 4//互联网协议IPv4    .... 0101 = Header Length: 20 bytes (5)//IP包头部长度    Differentiated Services Field: 0x00 (DSCP: CS0, ECN: Not-ECT)//差分服务字段    Total Length: 60//IP包的总长度    Identification: 0xdf8c (57228)//标志字段    Flags: 0x0000//标记字段    Fragment offset: 0//分的偏移量    Time to live: 128//生存期TTL    Protocol: ICMP (1)//此包内封装的上层协议为TCP    Header checksum: 0x05ba [validation disabled]//头部数据的校验和    [Header checksum status: Unverified]    Source: 192.168.43.36//来源IP地址    Destination: 39.156.66.18//目标IP地址</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1603433033837-c88714a1-eaa1-45cb-b836-5672e4515eee.png#align=left&display=inline&height=189&margin=%5Bobject%20Object%5D&name=image.png&originHeight=378&originWidth=640&size=84901&status=done&style=shadow&width=320" alt="image.png"></p><ol start="4"><li>Transmission Control Protocol:传输层 T 的数据段头部信息，此处是 TCP。</li></ol><pre><code class="http">Transmission Control Protocol, Src Port: 80 (80), Dst Port: 50362 (50362), Seq: 1025, Ack: 447, Len: 714Source Port: 80 (80) //源端口号Destination Port: 50362 (50362) //目标端口号Sequence number: 1025 (relative sequence number) //序列号（相对序列号）[Next sequence number: 1739 (relative sequence number)] //下一个序列号Acknowledgment number: 447    (relative ack number) //确认序列号Header Length: 20 bytes  //头部长度.... 0000 0001 1000 = Flags: 0x018 (PSH, ACK) //TCP标记长度Window size value: 5896  //流量控制的窗口大小Checksum: 0x915b [validation disabled] //TCP数据段的校验和</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1603433149527-0125377e-b64b-4e32-9eb0-e122d0c111cb.png#align=left&display=inline&height=190&margin=%5Bobject%20Object%5D&name=image.png&originHeight=379&originWidth=579&size=89043&status=done&style=shadow&width=289.5" alt="image.png"></p><ol start="5"><li><p>Hypertext Transfer Protocol:应用层的信息，此处是 HTTP 协议。</p></li><li><p>Data（312 bytes）：数据。</p></li></ol><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1603434354567-45e84cc7-63a9-4136-adde-85c377345e92.png#align=left&display=inline&height=147&margin=%5Bobject%20Object%5D&name=image.png&originHeight=347&originWidth=1920&size=49744&status=done&style=shadow&width=813" alt="image.png"></p><h2 id="超星网登录案例分析"><a href="#超星网登录案例分析" class="headerlink" title="超星网登录案例分析"></a>超星网登录案例分析</h2><h3 id="网站请求和响应"><a href="#网站请求和响应" class="headerlink" title="网站请求和响应"></a>网站请求和响应</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612849248230-2f38b355-ee1f-4ee1-8b8a-291e64f4e1bd.png#align=left&display=inline&height=356&margin=%5Bobject%20Object%5D&name=image.png&originHeight=711&originWidth=1920&size=230540&status=done&style=none&width=960" alt="image.png"></p><h3 id="发送请求相应协议"><a href="#发送请求相应协议" class="headerlink" title="发送请求相应协议"></a>发送请求相应协议</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612849740094-cbdefdda-f504-43f3-9e41-ac8dc8029fd3.png#align=left&display=inline&height=440&margin=%5Bobject%20Object%5D&name=image.png&originHeight=880&originWidth=1920&size=208371&status=done&style=none&width=960" alt="image.png"></p><h3 id="收到响应相应协议"><a href="#收到响应相应协议" class="headerlink" title="收到响应相应协议"></a>收到响应相应协议</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612849811431-437bd72d-ac54-4c28-b731-9e128b6b998f.png#align=left&display=inline&height=441&margin=%5Bobject%20Object%5D&name=image.png&originHeight=881&originWidth=1918&size=151717&status=done&style=stroke&width=959" alt="image.png"></p><blockquote><p>接下来的 7 个小节内容来具体对数据报头做出分析 ❗</p></blockquote><h3 id="Hypertext-Transfer-Protocol"><a href="#Hypertext-Transfer-Protocol" class="headerlink" title="Hypertext Transfer Protocol"></a>Hypertext Transfer Protocol</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612849851243-b18b3e15-f21e-4998-bcfe-45c0b92aabde.png#align=left&display=inline&height=339&margin=%5Bobject%20Object%5D&name=image.png&originHeight=678&originWidth=1920&size=99636&status=done&style=shadow&width=960" alt="image.png"></p><blockquote><p>HTTP 协议定义了客户端和服务器之间交互的消息内容和步骤，大家按照固定的步骤和格式进行通信<br>根据 URL 可以定位请求资源的位置，但是对于这个资源可能还有多种处理方法，比如是请求资源还是要删除指定资源？</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612851558692-ed870a9e-f619-4235-bb98-85d22557340f.png#align=left&display=inline&height=493&margin=%5Bobject%20Object%5D&name=image.png&originHeight=985&originWidth=1920&size=489577&status=done&style=none&width=960" alt="image.png"><br>这个时候<strong>浏览器</strong>将需要请求的信息，按照 HTTP 协议约定的格式，封装成为 HTTP 请求报文<br>HTTP 主要请求方法为 GET 和 POST<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612851687862-c1a44f57-065b-4547-93bb-4ae9b1f9cb95.png#align=left&display=inline&height=190&margin=%5Bobject%20Object%5D&name=image.png&originHeight=379&originWidth=693&size=117900&status=done&style=shadow&width=346.5" alt="image.png"></p><blockquote><p>请求报文和响应报文的具体形式参考课本</p></blockquote><h3 id="Line-based-text-data"><a href="#Line-based-text-data" class="headerlink" title="Line-based text data"></a>Line-based text data</h3><p>这里面内容就是请求成功所返回的 Html 代码<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612851995920-233bc149-948d-43e1-a549-fc2887c23163.png#align=left&display=inline&height=353&margin=%5Bobject%20Object%5D&name=image.png&originHeight=706&originWidth=1920&size=159705&status=done&style=none&width=960" alt="image.png"></p><h3 id="Transmission-Control-Protocol"><a href="#Transmission-Control-Protocol" class="headerlink" title="Transmission Control Protocol"></a>Transmission Control Protocol</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612852359910-50409417-8113-4600-bbb6-6d0e02db4894.png#align=left&display=inline&height=356&margin=%5Bobject%20Object%5D&name=image.png&originHeight=712&originWidth=1920&size=104306&status=done&style=none&width=960" alt="image.png"><br>这个数据报传输使用的可靠的 TCP 协议，而不是 UDP，所以会有相应的滑动窗口、流量控制等等相关机制，还有三次握手，四次挥手……<br>（插个眼，日后再复习一下……）<br><img src="https://cdn.nlark.com/yuque/0/2021/gif/1484158/1612852762215-ba49fa51-55e0-440d-afa7-b567540e39a2.gif#align=left&display=inline&height=151&margin=%5Bobject%20Object%5D&name=huaji-779c5947261d2633.gif&originHeight=151&originWidth=218&size=163714&status=done&style=none&width=218" alt="huaji-779c5947261d2633.gif"><br>（插眼专用图/滑稽）</p><h3 id="Internet-Protocol-Version-4"><a href="#Internet-Protocol-Version-4" class="headerlink" title="Internet Protocol Version 4"></a>Internet Protocol Version 4</h3><p>好了，接下来到了 IP 层，需要给上面来的数据报加上 IP 头部，IP 数据报结构如下：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612853140617-ff243167-abb7-4c65-b5c3-b0bbaa77b5aa.png#align=left&display=inline&height=237&margin=%5Bobject%20Object%5D&name=image.png&originHeight=474&originWidth=892&size=244750&status=done&style=stroke&width=446" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612853444183-7fa048ef-3e75-4586-82a7-ac9cc58c3630.png#align=left&display=inline&height=203&margin=%5Bobject%20Object%5D&name=image.png&originHeight=405&originWidth=1920&size=105587&status=done&style=stroke&width=960" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612852425531-82ec984f-ac3b-4f8a-a06e-0c48080815f6.png#align=left&display=inline&height=353&margin=%5Bobject%20Object%5D&name=image.png&originHeight=706&originWidth=1920&size=107520&status=done&style=none&width=960" alt="image.png"><br>比如说<code>45 </code>这个字节这具体表现是 ip 数据报的第一行和第二行的具体信息，IP 版本为 IPv4，报头长度为二十个字节，往后的各个字段都是这样一一对应的关系，具体还要加强对那张 ip 数据报结构图的理解，要了然于胸。</p><h3 id="Ethernet-II-Src"><a href="#Ethernet-II-Src" class="headerlink" title="Ethernet II, Src"></a>Ethernet II, Src</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612853924295-ea6fe64c-bc90-4e49-ad4e-5ff212448fdc.png#align=left&display=inline&height=214&margin=%5Bobject%20Object%5D&name=image.png&originHeight=428&originWidth=904&size=226429&status=done&style=stroke&width=452" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612850191706-18807d7d-16b5-44fa-a436-5c2b7c4ed5ed.png#align=left&display=inline&height=321&margin=%5Bobject%20Object%5D&name=image.png&originHeight=641&originWidth=1920&size=151109&status=done&style=none&width=960" alt="image.png"></p><blockquote><p>图中三个方框的 14 个字节对应以太网 MAC 帧的前 14 个字节：前 6 个字节是目的地址，接下来的 6 个字节是源地址，最后两个字节是类型字段(用来标志上一层使用的是什么协议，以便把收到的 MAC 帧的数据交给上一层的这个协议。0x8000 代表上层使用的是 IP 数据报)，后面是数据部分。<br>另外：wireshark 把 8 字节的前序（前同步码）和 4 字节的 FCS（帧开始界定符）都给过滤掉了，所以捕获到的帧里看不到这两部分。</p></blockquote><h3 id="Frame-75"><a href="#Frame-75" class="headerlink" title="Frame 75"></a>Frame 75</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612852486656-87756b19-ff3d-4833-9af9-d2006a401068.png#align=left&display=inline&height=353&margin=%5Bobject%20Object%5D&name=image.png&originHeight=706&originWidth=1920&size=135359&status=done&style=none&width=960" alt="image.png"></p><ul><li>对方发送 5520 字节，实际收到 5520 字节</li><li>第一行表示接口位 0 号</li></ul><h3 id="总体数据表示"><a href="#总体数据表示" class="headerlink" title="总体数据表示"></a>总体数据表示</h3><p>其实在计算机看来，网络中的数据传输就是传输下面的这些字节</p><blockquote><p>一个字节由八个位组成，而位就是我们通常所说的二进制中的 0 或 1</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612852578885-9519d1d0-a72d-409b-a480-f8554b87fd0d.png#align=left&display=inline&height=299&margin=%5Bobject%20Object%5D&name=image.png&originHeight=598&originWidth=1918&size=138039&status=done&style=stroke&width=959" alt="image.png"></p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><h3 id="Wireshark-抓不到-HTTPS-数据包"><a href="#Wireshark-抓不到-HTTPS-数据包" class="headerlink" title="Wireshark 抓不到 HTTPS 数据包"></a>Wireshark 抓不到 HTTPS 数据包</h3><blockquote><p>有些时候 HTTP 包也抓不到抑或是抓的不全，用如下方式解决即可。</p></blockquote><p>在 C 盘根目录下创建如下目录和文件，.log 就是后缀不要 txt<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612847971131-6c3c2084-c6d8-41ae-8a82-8a4df65748b8.png#align=left&display=inline&height=112&margin=%5Bobject%20Object%5D&name=image.png&originHeight=224&originWidth=811&size=14570&status=done&style=shadow&width=405.5" alt="image.png"><br>添加环境变量<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612848066208-6f22250b-e74d-4156-aa31-c5de17d2e812.png#align=left&display=inline&height=236&margin=%5Bobject%20Object%5D&name=image.png&originHeight=471&originWidth=968&size=35366&status=done&style=none&width=484" alt="image.png"><br>进入 wireshark 软件<br><code>编辑 ``首选项</code> <code>Protocols</code><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612848155164-ace1e002-1971-4910-8d04-cf9c388eb5cd.png#align=left&display=inline&height=496&margin=%5Bobject%20Object%5D&name=image.png&originHeight=992&originWidth=1362&size=89975&status=done&style=none&width=681" alt="image.png"></p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="https://www.cnblogs.com/linyfeng/p/9496126.html">wireshark 抓包新手使用教程</a></li><li><a href="https://zhuanlan.zhihu.com/p/82498482">https://zhuanlan.zhihu.com/p/82498482</a></li><li><a href="https://zhuanlan.zhihu.com/p/264942536">https://zhuanlan.zhihu.com/p/264942536</a></li><li><a href="https://blog.csdn.net/zam183/article/details/103783785">https://blog.csdn.net/zam183/article/details/103783785</a></li><li>TODO: <a href="https://www.cnblogs.com/zhaopei/p/12152139.html#autoid-2-6">Wireshark 抓包，带你快速入门</a></li><li>TODO: <a href="https://www.cnblogs.com/noteless/p/10256470.html#21">网络是如何连接的？网络发展简介（四）</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> ComputerNetwork </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ping、traceroute命令编程实现</title>
      <link href="blog/qlrcf6/"/>
      <url>blog/qlrcf6/</url>
      
        <content type="html"><![CDATA[<h3 id="ping-和-tracert-命令"><a href="#ping-和-tracert-命令" class="headerlink" title="ping 和 tracert 命令"></a>ping 和 tracert 命令</h3><p><strong>ping</strong>命令一般用来测试两台机器或者机器和服务器之间网络是否连通。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1603437323252-a3bf1470-c4ae-450a-b0fd-4d83281aab46.png#align=left&display=inline&height=156&margin=%5Bobject%20Object%5D&name=image.png&originHeight=311&originWidth=1439&size=57273&status=done&style=shadow&width=719.5" alt="image.png"><br><strong>tracert</strong>命令显示数据报到达目标主机途中所经过的路径（路由器），并且显示到达每个节点（路由器）的花费时间，显示的信息比 ping 出来的信息要多，要详细。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1603437358485-aef50645-6ff9-4395-bbae-0bfe22ce3dc1.png#align=left&display=inline&height=269&margin=%5Bobject%20Object%5D&name=image.png&originHeight=538&originWidth=1436&size=63435&status=done&style=shadow&width=718" alt="image.png"></p><h3 id="编程实现"><a href="#编程实现" class="headerlink" title="编程实现"></a>编程实现</h3><h4 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h4><pre><code class="java">import java.net.InetAddress;import java.net.MalformedURLException;import java.net.URL;import java.net.UnknownHostException;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStream;import java.io.InputStreamReader;import java.util.Scanner;public class CommandUtil &#123;    String tracert = &quot;tracert -h 10 &quot;; //模拟tracert命令    String ping = &quot;ping&quot;;//模拟 ping 命令    String routePrint = &quot;route print -4&quot;;//模拟route print命令    public static void main(String args[])&#123;        String input = null;        @SuppressWarnings(&quot;resource&quot;)        Scanner scanner = new Scanner(System.in);        //利用while循环接收输入的命令行参数        while(true)&#123;            System.out.println(&quot;Please input destination server IP address ：\n&quot;);            input = scanner.next();            CommandUtil host = new CommandUtil();            host.tracert = host.tracert + &quot; &quot; + input;            host.ping = host.ping + &quot; &quot; + input;            try &#123;                host.command(host.routePrint);            &#125; catch (IOException exception) &#123;                exception.printStackTrace();            &#125;            try &#123;                host.command(host.tracert) ;            &#125; catch (IOException exception) &#123;                exception.printStackTrace();            &#125;            try &#123;                host.command(host.ping);            &#125; catch (IOException exception) &#123;                exception.printStackTrace();            &#125;            InetAddress ipAddress;            try &#123;                ipAddress = InetAddress.getByName(input);                System.out.println(&quot;IP address : &quot;+ipAddress);            &#125; catch (UnknownHostException exception) &#123;                exception.printStackTrace();            &#125;            URL url;            try &#123;                url = new URL(&quot;http&quot;,input,80,&quot;index.html&quot;);                System.out.println();//输出服务器地址                System.out.println(&quot;Get the Server-Name# : &quot;+url.getHost());                System.out.println();//输出首页文件                System.out.println(&quot;Get the default file# : &quot;+url.getFile());                System.out.println();//输出首页协议和端口                System.out.println(&quot;Get the protocol# : &quot;+url.getProtocol()+&quot; &quot;+url.getPort());                System.out.println();            &#125; catch (MalformedURLException e) &#123;                e.printStackTrace();            &#125;            System.out.println();            try &#123;                System.out.println(&quot;Get serverName &amp; IPAddress：&quot;+InetAddress.getByName(input));            &#125; catch (UnknownHostException e) &#123;                e.printStackTrace();            &#125;            long freeMemory = Runtime.getRuntime().freeMemory();            System.out.println(&quot;Surplus memory of JVM: &quot;+freeMemory+&quot;B&quot;);        &#125;    &#125;    //模拟 tracert 命令    StringBuffer commandResult = null;    private void command(String tracerCommand) throws IOException&#123;        //第一步：创建进程(是接口不必初始化)        //1.通过Runtime类的getRuntime().exec()传入需要运行的命令参数        System.out.println();        System.out.println(InetAddress.getByName(&quot;localhost&quot;)+&quot; is tracking the destination server...&quot;);        Process process = Runtime.getRuntime().exec(tracerCommand);        readResult(process.getInputStream());        process.destroy();    &#125;    //第二步：通过输入流来将命令执行结果输出到控制台    private void readResult(InputStream inputStream) throws IOException&#123;        commandResult = new StringBuffer();  //初始化命令行        String commandInfo = null; //定义用于接收命令行执行结果的字符串        BufferedReader bufferedReader =                new BufferedReader(new InputStreamReader(inputStream));        while ( (commandInfo = bufferedReader.readLine()) != null)  &#123;            System.out.println(commandInfo);        &#125;        bufferedReader.close();    &#125;&#125;</code></pre><h4 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h4><pre><code>D:\Java\jdk1.8.0_181\bin\java.exe &quot;-javaagent:D:\JetBrains\IntelliJ IDEA 2020.1.3\lib\idea_rt.jar=39614:D:\JetBrains\IntelliJ IDEA 2020.1.3\bin&quot; -Dfile.encoding=GBK -classpath D:\Java\jdk1.8.0_181\jre\lib\charsets.jar;D:\Java\jdk1.8.0_181\jre\lib\deploy.jar;D:\Java\jdk1.8.0_181\jre\lib\ext\access-bridge-64.jar;D:\Java\jdk1.8.0_181\jre\lib\ext\cldrdata.jar;D:\Java\jdk1.8.0_181\jre\lib\ext\dnsns.jar;D:\Java\jdk1.8.0_181\jre\lib\ext\jaccess.jar;D:\Java\jdk1.8.0_181\jre\lib\ext\jfxrt.jar;D:\Java\jdk1.8.0_181\jre\lib\ext\localedata.jar;D:\Java\jdk1.8.0_181\jre\lib\ext\nashorn.jar;D:\Java\jdk1.8.0_181\jre\lib\ext\sunec.jar;D:\Java\jdk1.8.0_181\jre\lib\ext\sunjce_provider.jar;D:\Java\jdk1.8.0_181\jre\lib\ext\sunmscapi.jar;D:\Java\jdk1.8.0_181\jre\lib\ext\sunpkcs11.jar;D:\Java\jdk1.8.0_181\jre\lib\ext\zipfs.jar;D:\Java\jdk1.8.0_181\jre\lib\javaws.jar;D:\Java\jdk1.8.0_181\jre\lib\jce.jar;D:\Java\jdk1.8.0_181\jre\lib\jfr.jar;D:\Java\jdk1.8.0_181\jre\lib\jfxswt.jar;D:\Java\jdk1.8.0_181\jre\lib\jsse.jar;D:\Java\jdk1.8.0_181\jre\lib\management-agent.jar;D:\Java\jdk1.8.0_181\jre\lib\plugin.jar;D:\Java\jdk1.8.0_181\jre\lib\resources.jar;D:\Java\jdk1.8.0_181\jre\lib\rt.jar;D:\project-java\jiwang\out\production\jiwang CommandUtilPlease input destination server IP address ：baidu.comlocalhost/127.0.0.1 is tracking the destination server...===========================================================================接口列表  6...b4 b6 86 df cc 9d ......Realtek PCIe GbE Family Controller 11...0c 54 15 fb 33 95 ......Microsoft Wi-Fi Direct Virtual Adapter 14...0e 54 15 fb 33 94 ......Microsoft Wi-Fi Direct Virtual Adapter #2 16...0c 54 15 fb 33 94 ......Intel(R) Dual Band Wireless-AC 3168 17...0c 54 15 fb 33 98 ......Bluetooth Device (Personal Area Network)  1...........................Software Loopback Interface 1===========================================================================IPv4 路由表===========================================================================活动路由:网络目标        网络掩码          网关       接口   跃点数          0.0.0.0          0.0.0.0      192.168.2.1    192.168.2.132     35        127.0.0.0        255.0.0.0            在链路上         127.0.0.1    331        127.0.0.1  255.255.255.255            在链路上         127.0.0.1    331  127.255.255.255  255.255.255.255            在链路上         127.0.0.1    331      192.168.2.0    255.255.255.0            在链路上     192.168.2.132    291    192.168.2.132  255.255.255.255            在链路上     192.168.2.132    291    192.168.2.255  255.255.255.255            在链路上     192.168.2.132    291        224.0.0.0        240.0.0.0            在链路上         127.0.0.1    331        224.0.0.0        240.0.0.0            在链路上     192.168.2.132    291  255.255.255.255  255.255.255.255            在链路上         127.0.0.1    331  255.255.255.255  255.255.255.255            在链路上     192.168.2.132    291===========================================================================永久路由:  无localhost/127.0.0.1 is tracking the destination server...通过最多 10 个跃点跟踪到 baidu.com [39.156.69.79] 的路由:  1     1 ms     1 ms     1 ms  RM2100.lan [192.168.2.1]  2     *        *        *     请求超时。  3     *        *        *     请求超时。  4     4 ms     3 ms     3 ms  192.168.100.253  5     4 ms     5 ms    10 ms  192.168.100.114  6     3 ms     3 ms     3 ms  192.168.100.118  7     *        *        *     请求超时。  8     *        *        *     请求超时。  9     *        *        *     请求超时。 10     *        *        *     请求超时。跟踪完成。localhost/127.0.0.1 is tracking the destination server...正在 Ping baidu.com [39.156.69.79] 具有 32 字节的数据:来自 39.156.69.79 的回复: 字节=32 时间=20ms TTL=48来自 39.156.69.79 的回复: 字节=32 时间=20ms TTL=48来自 39.156.69.79 的回复: 字节=32 时间=20ms TTL=48来自 39.156.69.79 的回复: 字节=32 时间=20ms TTL=4839.156.69.79 的 Ping 统计信息:    数据包: 已发送 = 4，已接收 = 4，丢失 = 0 (0% 丢失)，往返行程的估计时间(以毫秒为单位):    最短 = 20ms，最长 = 20ms，平均 = 20msIP address : baidu.com/39.156.69.79Get the Server-Name# : baidu.comGet the default file# : index.htmlGet the protocol# : http 80Get serverName &amp; IPAddress：baidu.com/39.156.69.79Surplus memory of JVM: 124194640B</code></pre>]]></content>
      
      
      <categories>
          
          <category> ComputerNetwork </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++随机字符串生成函数</title>
      <link href="blog/zeszpb/"/>
      <url>blog/zeszpb/</url>
      
        <content type="html"><![CDATA[<pre><code class="cpp">//C++ 随机字符串生成函数#include&lt;iostream&gt;#include&lt;ctime&gt;using namespace std;const int LEN_NAME=4;char *rand_str(char *str,const int len)&#123;    int i;    for(i=0;i&lt;len;++i)        str[i]=&#39;A&#39;+rand()%26;    str[++i]=&#39;\0&#39;;    return str;&#125;void main()&#123;    srand(time(NULL));    int i;    char name[LEN_NAME+1];    for(i=0;i&lt;20;++i)    &#123;        cout&lt;&lt;rand_str(name,LEN_NAME)&lt;&lt;endl;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Language </category>
          
          <category> CPlusPlus </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JAVA-正则表达式</title>
      <link href="blog/xm1a2g/"/>
      <url>blog/xm1a2g/</url>
      
        <content type="html"><![CDATA[<h2 id="常见匹配符号"><a href="#常见匹配符号" class="headerlink" title="常见匹配符号"></a>常见匹配符号</h2><p>| 正则表达式  |                                               描述                                                |<br>| :———: | :———————————————————————————————–: | ———– |<br>|     <code>.</code>     |           匹配所有单个字符，除了换行符（Linux 中换行是 <code>\n</code>，Windows 中换行是 <code>\r\n</code>）            |<br>|  <code>^regex</code>   |                                      正则必须匹配字符串开头                                       |<br>|  <code>regex$</code>   |                                      正则必须匹配字符串结尾                                       |<br>|   <code>[abc]</code>   |                                 复选集定义，匹配字母 a 或 b 或 c                                  |<br>| <code>[abc][vz]</code> |                         复选集定义，匹配字母 a 或 b 或 c，后面跟着 v 或 z                         |<br>|  <code>[^abc]</code>   | 当插入符 <code>^</code> 在中括号中以第一个字符开始显示，则表示否定模式。此模式匹配所有字符，除了 a 或 b 或 c |<br>| <code>[a-d1-7]</code>  |                    范围匹配，匹配字母 a 到 d 和数字从 1 到 7 之间，但不匹配 d1                    |<br>|    <code>XZ</code>     |                                        匹配 X 后直接跟着 Z                                        |<br>|      X      |                                                 Z                                                 | 匹配 X 或 Z |</p><h2 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h2><table><thead><tr><th align="center">正则表达式</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center"><code>\d</code></td><td align="center">匹配一个数字，是 <code>[0-9]</code> 的简写</td></tr><tr><td align="center"><code>\D</code></td><td align="center">匹配一个非数字，是 <code>[^0-9]</code> 的简写</td></tr><tr><td align="center"><code>\s</code></td><td align="center">匹配一个空格，是 <code>[ \t\n\x0b\r\f]</code> 的简写</td></tr><tr><td align="center"><code>\S</code></td><td align="center">匹配一个非空格</td></tr><tr><td align="center"><code>\w</code></td><td align="center">匹配一个单词字符（大小写字母、数字、下划线），是 <code>[a-zA-Z_0-9]</code> 的简写</td></tr><tr><td align="center"><code>\W</code></td><td align="center">匹配一个非单词字符（除了大小写字母、数字、下划线之外的字符），等同于 <code>[^\w]</code></td></tr></tbody></table><h2 id="限定符"><a href="#限定符" class="headerlink" title="限定符"></a>限定符</h2><p>| 正则表达式 | 描述 | 举例 |<br>| <code>*</code> | 匹配 &gt;=0 个，是 <code>&#123;0,&#125;</code> 的简写 | <code>X*</code> 表示匹配零个或多个字母 X，<code>.*</code> 表示匹配任何字符串 |<br>| :—: | :—: | :—: |<br>| <code>+</code> | 匹配 &gt;=1 个，是 <code>&#123;1,&#125;</code> 的简写 | <code>X+</code> 表示匹配一个或多个字母 X |<br>| <code>?</code> | 匹配 1 个或 0 个，是 <code>&#123;0,1&#125;</code> 的简写 | <code>X?</code> 表示匹配 0 个或 1 个字母 X |<br>| <code>&#123;X&#125;</code> | 只匹配 X 个字符 | <code>\d&#123;3&#125;</code> 表示匹配 3 个数字，<code>.&#123;10&#125;</code> 表示匹配任何长度是 10 的字符串 |<br>| <code>&#123;X,Y&#125;</code> | 匹配 &gt;=X 且 &lt;=Y 个 | <code>\d&#123;1,4&#125;</code> 表示匹配至少 1 个最多 4 个数字 |<br>| <code>*?</code> | 如果 <code>?</code> 是限定符 <code>*</code> 或 <code>+</code> 或 <code>?</code> 或 <code>&#123;&#125;</code> 后面的第一个字符，那么表示<strong>非贪婪模式</strong>（尽可能少的匹配字符），而不是默认的<strong>贪婪模式</strong> | |</p>]]></content>
      
      
      <categories>
          
          <category> Language </category>
          
          <category> JAVA </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JAVA-继承和多态</title>
      <link href="blog/bn6afv/"/>
      <url>blog/bn6afv/</url>
      
        <content type="html"><![CDATA[<h2 id="extends-和-super"><a href="#extends-和-super" class="headerlink" title="extends 和 super"></a>extends 和 super</h2><ul><li>**子类继承父类用关键字 <code>extends</code> **</li><li>super 关键字作用有<ul><li>继承父类的构造函数</li><li>构造方法链</li><li>调用父类的方法（一般不怎么用）</li></ul></li></ul><h2 id="方法重写和方法重载"><a href="#方法重写和方法重载" class="headerlink" title="方法重写和方法重载"></a>方法重写和方法重载</h2><blockquote><p>方法重写注意要子类和父类的方法都得是一样的签名和返回类型</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1600089343780-c8d0a28c-dc06-4aab-a331-9ac926a65498.png#align=left&display=inline&height=289&margin=%5Bobject%20Object%5D&name=image.png&originHeight=577&originWidth=764&size=325094&status=done&style=shadow&width=382" alt="image.png"></p><p>为了避免编写程序过程中方法重载和方法重写的误用，使用<strong>重写标注 <code>@Override</code></strong> 来区分，系统可以检查方法的正确性。</p><h2 id="Object-类"><a href="#Object-类" class="headerlink" title="Object 类"></a>Object 类</h2><blockquote><p>java 中所有类都继承子 java.lang.Object 类，其中 toString 就是该类里面的方法之一，所有许多接口/类都会重写这个方法，手写的链表里面的该方法就是重写之后的方法</p></blockquote><h2 id="多态与动态绑定"><a href="#多态与动态绑定" class="headerlink" title="多态与动态绑定"></a>多态与动态绑定</h2><blockquote><p>多态</p></blockquote><p>使用夫类对象的地方都可以使用子类对象。也就意味着父类的变量可以引用子类型的对象</p><blockquote><p>动态绑定</p></blockquote><p>如果定义了一个父类的对象，该对象调用了一个方法，该方法不存在父类当中，但是存在其父类下面的多个子类当中，那么这个方法调用的是哪个子类当中的该方法呢？JVM 有这么一个机制，从“辈分最小的类”依次往上找，第一个找到含有该方法的类，则调用该类当中的那个方法<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1600138148812-5cc991ce-0577-4f01-b57c-bec631518a99.png#align=left&display=inline&height=109&margin=%5Bobject%20Object%5D&name=image.png&originHeight=217&originWidth=960&size=14420&status=done&style=shadow&width=483" alt="image.png"><br>注：Cn 为父类，往后都是以此继承的子类</p><h2 id="对象转换"><a href="#对象转换" class="headerlink" title="对象转换"></a>对象转换</h2><blockquote><p>向下转换与向上转换</p></blockquote><pre><code class="java">Object o = new Student(); // 可以：因为Student的实例也是Object的实例Student a = o; // (o是Object对象)不可以：因为“级别”的不可逆Student s = Student(o); //向上转换</code></pre><blockquote><p>instanceof</p></blockquote><p>如果一个对象不是 Student 实例，他就不能转换成 Student 类型的变量，会报错 <code>ClassCastException</code> 。因此，在此之前最好先确保该对象是另一个对象的实例，于是用到关键字 <code>instanceof</code></p><pre><code class="java">Object myObject = new Circle();... // Some lines of code/** Perform casting if myObject is an instance of Circle */if (myObject instanceof Circle) &#123;  System.out.println(&quot;The circle diameter is &quot; +    ((Circle)myObject).getDiameter());  ...&#125;</code></pre><h2 id="override"><a href="#override" class="headerlink" title="@override"></a>@override</h2><p>在重写父类的函数时，在方法前面加上<a href="https://www.yuque.com/Override">@Override </a> 系统可以帮你检查方法的正确性。</p>]]></content>
      
      
      <categories>
          
          <category> Language </category>
          
          <category> JAVA </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JAVA-抽象类和接口</title>
      <link href="blog/akog9h/"/>
      <url>blog/akog9h/</url>
      
        <content type="html"><![CDATA[<h2 id="概念名词"><a href="#概念名词" class="headerlink" title="概念名词"></a>概念名词</h2><ul><li><strong>接口</strong>：许多类的<strong>共同行为</strong>（包含非相关类），就当与给客户看的。</li><li><strong>抽象类</strong>：就相当于一个父类，该父类包含其子类的<strong>共性</strong>特征，就像是子类园和子类长方形，两个类可以有一个共同的父类，该父类定义为抽象类，其包含一个<strong>抽象方法</strong>，比如求面积或是求周长</li></ul><h2 id="接口的一些要点"><a href="#接口的一些要点" class="headerlink" title="接口的一些要点"></a>接口的一些要点</h2><blockquote><p><code>public interface List&lt;E&gt; &#123; &#125;</code></p></blockquote><ul><li>接口是一个<strong>写注释</strong>的好地方</li></ul><h2 id="抽象类的一些要点"><a href="#抽象类的一些要点" class="headerlink" title="抽象类的一些要点"></a>抽象类的一些要点</h2><blockquote><p><code>public abstract class AbstractList&lt;E&gt; implements List&lt;E&gt; &#123; &#125;</code> &gt; <code>public abstract class Test()&#123;&#125;</code> &gt; <code>public abstract double getTest()&#123;&#125;</code></p></blockquote><ul><li>抽象类当中的<strong>抽象方法</strong>要在其子类当中实现，因为抽象类“抽象”的以至于没有实例</li><li>包含抽象方法的类必定是抽象类</li><li><strong>抽象类的构造函数实现要加上 protected，因为其构造函数只被其子类所使用，在创建子类实例的时候，其父类构造函数被调用来初始化该父类的数据域</strong></li><li><strong>抽象类不可以 new 对象，不对外公开，只抽取公共代码，eg：ArrayList 和 LinkedList</strong></li><li><strong>抽象类可以不是先接口里面的部分函数</strong></li><li><strong>抽象类作用：放“公共代码”</strong></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598686636557-2700f743-9f28-435a-b771-86bdf7b2b25c.png#align=left&display=inline&height=326&margin=%5Bobject%20Object%5D&originHeight=574&originWidth=732&size=0&status=done&style=shadow&width=416"></p>]]></content>
      
      
      <categories>
          
          <category> Language </category>
          
          <category> JAVA </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JAVA队列设计</title>
      <link href="blog/zqmygi/"/>
      <url>blog/zqmygi/</url>
      
        <content type="html"><![CDATA[<h2 id="Queue-队列设计"><a href="#Queue-队列设计" class="headerlink" title="Queue 队列设计"></a>Queue 队列设计</h2><blockquote><p>在头尾两端进行操作，先进先出 FIFO</p></blockquote><p>队列的接口设计</p><pre><code class="java">int size(); //队列元素个数boolean isEmpty(); //队列是否为空void clear(); //清空队列元素void enQueue(E element); //入队E deQueue(); // 出队E front(); //获取队列的头元素</code></pre><pre><code class="java">package com.wztlink1013.ds.queue;import com.wztlink1013.ds.queue.list.LinkedList;import com.wztlink1013.ds.queue.list.List;public class Queue&lt;E&gt; &#123;    private List&lt;E&gt; list = new LinkedList&lt;&gt;();    public int size() &#123;        return list.size();    &#125;    public boolean isEmpty() &#123;        return list.isEmpty();    &#125;    public void clear() &#123;        list.clear();    &#125;    public void enQueue(E element) &#123;        list.add(element);    &#125;    public E deQueue() &#123;        return list.remove(0);    &#125;    public E front() &#123;        return list.get(0);    &#125;&#125;</code></pre><h2 id="Deque-双端队列设计"><a href="#Deque-双端队列设计" class="headerlink" title="Deque 双端队列设计"></a>Deque 双端队列设计</h2><blockquote><p>双端队列是能在头尾两端添加、删除的队列</p></blockquote><pre><code class="java">package com.wztlink1013.ds.queue;import com.wztlink1013.ds.queue.list.LinkedList;import com.wztlink1013.ds.queue.list.List;public class Deque&lt;E&gt; &#123;    private List&lt;E&gt; list = new LinkedList&lt;&gt;();    public int size() &#123;        return list.size();    &#125;    public boolean isEmpty() &#123;        return list.isEmpty();    &#125;    public void clear() &#123;        list.clear();    &#125;    public void enQueueRear(E element) &#123;        list.add(element);    &#125;    public E deQueueFront() &#123;        return list.remove(0);    &#125;    public void enQueueFront(E element) &#123;        list.add(0, element);    &#125;    public E deQueueRear() &#123;        return list.remove(list.size() - 1);    &#125;    public E front() &#123;        return list.get(0);    &#125;    public E rear() &#123;        return list.get(list.size() - 1);    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> DataStructure </category>
          
          <category> 线结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++顺序表设计</title>
      <link href="blog/nlhg88/"/>
      <url>blog/nlhg88/</url>
      
        <content type="html"><![CDATA[<div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">类似一个简易版本的数组</div><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><ul><li><input checked="" disabled="" type="checkbox"> 顺序表存储形式</li></ul><pre><code class="cpp">/* 顺序表的存储形式就是连续存储空间，地址连续的，其实就是数组 */typedef struct &#123;    int *arr;    int length;&#125;SqList;</code></pre><ul><li><input checked="" disabled="" type="checkbox"> 打印</li><li><input checked="" disabled="" type="checkbox"> 取值</li><li><input checked="" disabled="" type="checkbox"> 查找</li><li><input checked="" disabled="" type="checkbox"> 插入</li><li><input checked="" disabled="" type="checkbox"> 删除</li><li><input checked="" disabled="" type="checkbox"> 升序</li><li><input checked="" disabled="" type="checkbox"> 逆置</li></ul><pre><code class="cpp">#include&lt;bits/stdc++.h&gt;using namespace std;#define MAXSIZE 100/** * 顺序表 * * 顺序表的基本操作： 初始化、打印、取值、查找、插入、删除、升序、逆置 *//* 顺序表的存储形式就是连续存储空间，地址连续的，其实就是数组 */typedef struct &#123;    int *arr;    int length;&#125;SqList;/* 初始化 */void InitList(SqList &amp;L)&#123;    L.arr = new int[MAXSIZE];    if (!L.arr) exit(-1);    L.length = 0;&#125;/* 初始化添加元素 */void ListInsert(SqList &amp;L) &#123;    cout &lt;&lt; &quot;请输入元素个数n：&quot;;    int n;    cin &gt;&gt; n;    for (int i = 0; i &lt; n;i++)&#123;        cin &gt;&gt; L.arr[i];        L.length++;    &#125;&#125;/* 打印 */void TraverseList(SqList &amp;L) &#123;    cout &lt;&lt; &quot;该顺序表元素遍历结果为：&quot;;    for (int i = 0; i &lt; L.length;i++) &#123;        cout &lt;&lt; L.arr[i] &lt;&lt; &#39; &#39;;    &#125;    cout &lt;&lt; &quot;\n&quot;;&#125;/* 最大值 */void NumberMax (SqList &amp;L)&#123;    cout &lt;&lt; &quot;该顺序表最大值为：&quot;;    int max = L.arr[0];    for (int i = 0; i &lt; L.length;i++) &#123;        if(L.arr[i]&gt;max)            max = L.arr[i];    &#125;    cout &lt;&lt; max&lt;&lt;&quot;\n&quot;;&#125;/* 插值 */void InsertOneElement (SqList &amp;L) &#123;    cout &lt;&lt; &quot;请分别输入在n位置插入的e值：&quot;;    int n;    int e;    cin &gt;&gt; n &gt;&gt; e;    for (int i = L.length - 1; i &gt;= n-1;i--)&#123;        L.arr[i + 1] = L.arr[i];    &#125;    L.arr[n-1] = e;    L.length++;    cout &lt;&lt; &quot;\n&quot;&lt;&lt;&quot;插入值之后的顺序表为：&quot;;    TraverseList(L);&#125;/* 删除 */void DeleteOneElement (SqList &amp;L) &#123;    cout &lt;&lt; &quot;请输入要删除n位置的n值：&quot;;    int n;    cin &gt;&gt; n;    for (int i = 0; i &lt; L.length;i++)&#123;        if (i&gt;=n-1)&#123;            L.arr[i] = L.arr[i + 1];        &#125;    &#125;    L.length--;    cout &lt;&lt; &quot;\n&quot;&lt;&lt;&quot;删除值之后的顺序表为：&quot;;    TraverseList(L);&#125;/* 升序 */void IncrList (SqList &amp;L) &#123;    cout &lt;&lt; &quot;升序之后的顺序表为：&quot;;    for (int i = 0; i &lt; L.length;i++)&#123;        for (int j = 0; j &lt; L.length;j++)&#123;            if (L.arr[j]&gt;L.arr[i]) &#123;                int temp;                temp = L.arr[j];                L.arr[j] = L.arr[i];                L.arr[i] = temp;            &#125;        &#125;    &#125;    TraverseList(L);&#125;/* 逆置 */void ReverseList (SqList &amp;L) &#123;    cout &lt;&lt; &quot;逆序之后……&quot;;    for (int i = 0; i &lt; L.length / 2;i++)&#123;        int temp;        temp = L.arr[i];        L.arr[i] = L.arr[L.length-i-1];        L.arr[L.length-i-1] = temp;    &#125;    TraverseList(L);&#125;int main () &#123;    SqList test;    InitList(test);//1    ListInsert(test);//1    TraverseList(test);//1    NumberMax(test);//2    InsertOneElement(test);//3    DeleteOneElement(test);//4    IncrList(test);//5    ReverseList(test);//6&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> DataStructure </category>
          
          <category> 线结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>P20. 有效的括号</title>
      <link href="blog/aritwv/"/>
      <url>blog/aritwv/</url>
      
        <content type="html"><![CDATA[<h2 id="问题思路"><a href="#问题思路" class="headerlink" title="问题思路"></a>问题思路</h2><p>将所有的左半边括号 push 到栈内，然后遇到右半边括号，就将其与栈顶元素匹配测试，若能匹配成功则继续匹配，反之输出 false。</p><p>在这之间注意比较当栈内没有元素了，而字符串还有待匹配的字符，输出 false，当栈内还有元素，外面与之匹配测试的右半边括号，也输出 false。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="栈实现"><a href="#栈实现" class="headerlink" title="栈实现"></a>栈实现</h3><pre><code class="java">class Solution &#123;    public boolean isValid(String s) &#123;        Stack&lt;Character&gt; stack = new Stack&lt;&gt;();        int len = s.length();        for (int i=0;i&lt;len;i++) &#123;            char c = s.charAt(i);            if (c == &#39;(&#39; || c == &#39;[&#39; || c == &#39;&#123;&#39;) &#123;                stack.push(c);            &#125; else &#123;                if (stack.isEmpty()) return false;                char left = stack.pop();                if (left == &#39;(&#39; &amp;&amp; c !=&#39;)&#39;) return false;                if (left == &#39;[&#39; &amp;&amp; c !=&#39;]&#39;) return false;                if (left == &#39;&#123;&#39; &amp;&amp; c !=&#39;&#125;&#39;) return false;            &#125;        &#125;        return stack.isEmpty();    &#125;&#125;</code></pre><pre><code class="java">class Solution &#123;    public boolean isValid(String s) &#123;        Stack&lt;Character&gt; stack = new Stack&lt;&gt;();        for (int i = 0; i&lt; s.length();i++)&#123;            if (s.charAt(0) == &#39;)&#39; || s.charAt(0) == &#39;]&#39; || s.charAt(0) == &#39;&#125;&#39;)&#123;                return false;            &#125;            if (s.charAt(i) == &#39;(&#39; || s.charAt(i) == &#39;[&#39; || s.charAt(i) == &#39;&#123;&#39;)&#123;                stack.push(s.charAt(i));            &#125;            if (s.charAt(i) == &#39;)&#39; || s.charAt(i) == &#39;]&#39; || s.charAt(i) == &#39;&#125;&#39;)&#123;                if (s.charAt(i) == &#39;)&#39;)&#123;                    if (stack.isEmpty() == true) &#123;                        return false;                    &#125;                    if (stack.pop() != &#39;(&#39;)                        return false;                &#125;                if (s.charAt(i) == &#39;]&#39;)&#123;                    if (stack.isEmpty() == true) &#123;                        return false;                    &#125;                    if (stack.pop() != &#39;[&#39;)                        return false;                &#125;                if (s.charAt(i) == &#39;&#125;&#39;)&#123;                    if (stack.isEmpty() == true) &#123;                        return false;                    &#125;                    if (stack.pop() != &#39;&#123;&#39;)                        return false;                &#125;            &#125;        &#125;        if (stack.isEmpty() == true)&#123;            return true;        &#125; else &#123;            return false;        &#125;    &#125;&#125;</code></pre><h3 id="HashMap-实现"><a href="#HashMap-实现" class="headerlink" title="HashMap 实现"></a>HashMap 实现</h3><pre><code class="java">class Solution &#123;    private static HashMap&lt;Character, Character&gt; map = new HashMap&lt;&gt;();    static &#123;        // key - value        map.put(&#39;(&#39;, &#39;)&#39;);        map.put(&#39;&#123;&#39;, &#39;&#125;&#39;);        map.put(&#39;[&#39;, &#39;]&#39;);    &#125;    public boolean isValid(String s) &#123;        Stack&lt;Character&gt; stack = new Stack&lt;&gt;();        int len = s.length();        for (int i = 0; i &lt; len; i++) &#123;            char c = s.charAt(i);            if (map.containsKey(c)) &#123; // 左括号                stack.push(c);            &#125; else &#123; // 右括号                if (stack.isEmpty()) return false;                if (c != map.get(stack.pop())) return false;            &#125;        &#125;        return stack.isEmpty();    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> DataStructure </category>
          
          <category> Problems </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JAVA栈设计</title>
      <link href="blog/yxy6mv/"/>
      <url>blog/yxy6mv/</url>
      
        <content type="html"><![CDATA[<h2 id="栈的设计"><a href="#栈的设计" class="headerlink" title="栈的设计"></a>栈的设计</h2><h3 id="栈的特点"><a href="#栈的特点" class="headerlink" title="栈的特点"></a>栈的特点</h3><p>栈的最重要特点就是其元素的<strong>后进先出，先进后出</strong>。</p><h3 id="栈的接口设计"><a href="#栈的接口设计" class="headerlink" title="栈的接口设计"></a>栈的接口设计</h3><p>栈可以<strong>直接继承</strong>之前所学的 ArrayList 亦或是 List 接口。<br>这过程中需要注意，最好不要直接继承，因为如果直接继承，会将接口里面的其他方法也继承下来，会导致栈的对外接口不合理，解决办法就是在<strong>类设计内部 new 一个 private List 对象</strong>来设计栈。</p><pre><code class="java">int size(); // 元素的数量boolean isEmpty(); // 栈是否为空void push(E element); // 入栈E pop(); // 出栈E top(); // 获取栈顶元素void clear(); // 清空栈</code></pre><pre><code class="java">package com.wztlink1013.ds.stack;import com.wztlink1013.ds.stack.list.ArrayList;import com.wztlink1013.ds.stack.list.List;public class Stack&lt;E&gt; &#123;    private List&lt;E&gt; list = new ArrayList&lt;&gt;();    public void clear() &#123;        list.clear();    &#125;    public int size() &#123;        return list.size();    &#125;    public boolean isEmpty() &#123;        return list.isEmpty();    &#125;    public void push(E element) &#123;        list.add(element);    &#125;    public E pop() &#123;        return list.remove(list.size() - 1);    &#125;    public E top() &#123;        return list.get(list.size() - 1);    &#125;&#125;</code></pre><h2 id="栈的应用"><a href="#栈的应用" class="headerlink" title="栈的应用"></a>栈的应用</h2><p><strong>浏览器的前进和后退</strong>的功能。<br>假如有网页 a、b、c、d，依次点击 abc 三个网页，然后回退至 b 网页，这个时候，就相当于在 1 栈中有 ab 两个网页（且 b 为栈顶元素），c 暂时放到 2 栈中，此时依然可以使用回退前进功能，但是现在在 b 页面上在新输入 d 网页并进入，此时 2 栈被清空，d 为 1 栈的栈顶元素，在此时的 d 页面内，不能使用浏览器的前进功能，只能使用后退功能。</p><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
      
      
      <categories>
          
          <category> DataStructure </category>
          
          <category> 线结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>yuque-未拉取成功</title>
      <link href="blog/wsmygb/"/>
      <url>blog/wsmygb/</url>
      
        <content type="html"><![CDATA[<h2 id="一、报错信息"><a href="#一、报错信息" class="headerlink" title="一、报错信息"></a>一、报错信息</h2><pre><code class="bash">$ yuque-hexo sync[INFO] clear previous directory.[INFO] remove yuque posts: D:\Blog\blog-wztlink1013-3.0\source\yuqueMon, 01 Jun 2020 04:02:22 GMT yuque-hexo deprecated TOKEN of yuque will be required while verion &gt;v1.6.0. at ..\..\Develop\nodejs\node_global\node_modules\yuque-hexo\lib\Downloader.js:39:19[INFO] reading from local file: D:\Blog\blog-wztlink1013-3.0\yuque.json[WARNING] Cannot find module &#39;D:\Blog\blog-wztlink1013-3.0\yuque.json&#39;Require stack:- D:\Develop\nodejs\node_global\node_modules\yuque-hexo\lib\Downloader.js- D:\Develop\nodejs\node_global\node_modules\yuque-hexo\command\sync.js- D:\Develop\nodejs\node_global\node_modules\yuque-hexo\node_modules\common-bin\lib\command.js- D:\Develop\nodejs\node_global\node_modules\yuque-hexo\node_modules\common-bin\index.js- D:\Develop\nodejs\node_global\node_modules\yuque-hexo\index.js- D:\Develop\nodejs\node_global\node_modules\yuque-hexo\bin\yuque-hexo.js⚠️  Error: fail to fetch article list, response: &#123;&quot;status&quot;:401,&quot;message&quot;:&quot;Unauthorized&quot;&#125;⚠️  Command Error, enable `DEBUG=common-bin` for detail</code></pre><h2 id="二、分析并解决问题"><a href="#二、分析并解决问题" class="headerlink" title="二、分析并解决问题"></a>二、分析并解决问题</h2><p>认证出错，应该和下面三个原因有关</p><ul><li>客户端将其身份验证凭据发送到服务器，但是服务器由于某种原因拒绝了凭据。</li><li>客户端无法在请求中提供任何身份验证凭据。</li><li>客户端由于某种原因被禁止。某些应用程序用来限制来自特定 IP 地址的访问请求，因此，如果身份验证不是问题，则可能是服务器端禁止。401 Unauthorized Errors</li></ul><p>也就是身份没有被验证，首先检查用户元信息相关</p><p>的确，配置都是没有问题的，然后去 issue 里面查看相关问题，了解到是语雀官方出于对知识库安全性的调整，需要使用第三方 API 访问知识库，需要传入环境变量 YUQUE_TOKEN。</p><p>然后根据两种指导方式，传入参数即可</p><ul><li>设置全局的环境变量 YUQUE_TOKEN</li><li>命令执行时传入环境变量<ul><li>mac / linux: YUQUE_TOKEN=xxx yuque-hexo sync</li><li>windows: set YUQUE_TOKEN=xxx &amp;&amp; yuque-hexo sync</li></ul></li></ul><p>传入之后会有一封邮件发过来，然后新开 git bash 窗口，重新键入命令即可</p><p>成功之后是这个样子的</p><pre><code class="bash">$ yuque-hexo sync[INFO] clear previous directory.[INFO] remove yuque posts: D:\Blog\blog-wztlink1013-3.0\source\_posts\yuque[INFO] reading from local file: D:\Blog\blog-wztlink1013-3.0\yuque.json[INFO] article amount: 2[INFO] download articles done![INFO] writing to local file: D:\Blog\blog-wztlink1013-3.0\yuque.json[INFO] create posts directory (if it not exists): D:\Blog\blog-wztlink1013-3.0\source\_posts\yuque[INFO] generate post file: D:\Blog\blog-wztlink1013-3.0\source\_posts\yuque\hexo-test.md[INFO] generate post file: D:\Blog\blog-wztlink1013-3.0\source\_posts\yuque\语雀文章测试.md[INFO] yuque-hexo sync done!</code></pre><h2 id="相关参考"><a href="#相关参考" class="headerlink" title="相关参考"></a>相关参考</h2><ul><li><a href="https://airbrake.io/blog/http-errors/401-unauthorized-error">https://airbrake.io/blog/http-errors/401 U-unauthorized E-error:What It Is and How to Fix It</a></li><li><a href="https://www.yuguocong.cn/yuque/eg7hkp.html#Reference">使用语雀编辑器写静态博客 https://www.yuguocong.cn/yuque/eg7hkp.html#Reference</a></li><li><a href="https://blog.csdn.net/Caoyang_He/article/details/82181695?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.nonecase&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.nonecase">windows10 环境变量设置及理解环境变量</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Bug </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>python-路径和nltk</title>
      <link href="blog/uatg7m/"/>
      <url>blog/uatg7m/</url>
      
        <content type="html"><![CDATA[<h2 id="一、路径相关"><a href="#一、路径相关" class="headerlink" title="一、路径相关"></a>一、路径相关</h2><h3 id="路径相关报错信息"><a href="#路径相关报错信息" class="headerlink" title="路径相关报错信息"></a>路径相关报错信息</h3><pre><code class="python">IOError: [Errno 2] No such file or directory</code></pre><pre><code class="python">pandas.read_csv() 报错 OSError: Initializing from file failed</code></pre><pre><code class="python">(unicode error) &#39;unicodeescape&#39; codec can&#39;t decode bytes in position 2-3: truncated \UXXXXXXXX escape [duplicate]</code></pre><pre><code class="python">File b&#39;train.csv&#39; does not exist even though file exist</code></pre><h3 id="分析与解决问题"><a href="#分析与解决问题" class="headerlink" title="分析与解决问题"></a>分析与解决问题</h3><p>编写 python 代码过程中，出现了类似这种一系列路径相关的错误，原因是，自己更改了<strong>相关文件夹/文件在电脑中的位置</strong>，解决办法就新建一个项目建一个全新路径或者修改现有路径</p><ul><li><code>\</code>绝对路径 会报错（转义字符）处理：① 双引号前面加一个 r②<code>\</code>换成<code>\\</code>（硬盘代号后面的第一个）</li><li><code>./</code>相对路径</li></ul><blockquote><p>三种解决方式<br><code>r&quot;C:\Users\YJG\Desktop\pi_digits.txt&quot;</code> &gt; <code>&quot;C:\\Users\\YJG\\Desktop\\pi_digits.txt&quot;</code> &gt; <code>&quot;C:/Users/YJG/Desktop/pi_digits.txt&quot;</code></p></blockquote><h3 id="PS：路径含中文"><a href="#PS：路径含中文" class="headerlink" title="PS：路径含中文"></a>PS：路径含中文</h3><p>假如路径、文件名都完整，还是报错的原因是这个参数中有中文，即使 Python3 已经支持中文，但是调用 pandas 的 read_csv()方法时，默认使用 C engine 作为 parser engine，而当文件名中含有中文的时候，用 C engine 在部分情况下就会出错。所以在调用 read_csv()方法时指定 engine 为 Python 就可以解决问题。根治：将路径编程全英文，这是必要素养习惯！</p><p><code>da4=pd.read_csv(xxxxxxxxxx,engine=&#39;python&#39;)</code></p><h3 id="PS：utf-8"><a href="#PS：utf-8" class="headerlink" title="PS：utf-8"></a>PS：utf-8</h3><pre><code>UnicodeDecodeError：: &#39;utf-8&#39; codec can&#39;t decode byte 0xc8 in position 0: invalid contin</code></pre><blockquote><p>解决办法：<code>data_1 = pd.read_csv(data1, encoding = &#39;gb2312&#39;)</code>或者 gb2312 换成 gbk<br>参考：<a href="https://blog.csdn.net/qq_18888869/article/details/82625343">https://blog.csdn.net/qq_18888869/article/details/82625343</a></p></blockquote><h2 id="二、nltk-相关"><a href="#二、nltk-相关" class="headerlink" title="二、nltk 相关"></a>二、nltk 相关</h2><h3 id="nltk-下载报错信息"><a href="#nltk-下载报错信息" class="headerlink" title="nltk 下载报错信息"></a>nltk 下载报错信息</h3><pre><code>bug:[WinError 10054] 远程主机强迫关闭了一个现有的连接</code></pre><h3 id="分析与解决问题-1"><a href="#分析与解决问题-1" class="headerlink" title="分析与解决问题"></a>分析与解决问题</h3><p>原因：模型权重参数文件（.h5）较大，下载出现中断，下载失败</p><blockquote><ul><li>解决办法：手动下载模型，放到指定目录</li><li><code>C:\Users\XXX\AppData\Roaming</code></li></ul></blockquote><p><a href="https://pan.baidu.com/s/1oUsf-FgVAZnQAtZWRwiK4w">下载地址</a>  （密码 9sar）</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://blog.csdn.net/zln_whu/article/details/103448420">CSDN-103448420</a></li><li><a href="https://www.jianshu.com/p/0e1d51a7549d">nltk 简书详细讲解</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Bug </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>javaweb-8080端口被占用</title>
      <link href="blog/qi1md8/"/>
      <url>blog/qi1md8/</url>
      
        <content type="html"><![CDATA[<h2 id="一、报错信息"><a href="#一、报错信息" class="headerlink" title="一、报错信息"></a>一、报错信息</h2><pre><code>localhost:8080 is already in usePort 8080 required by Tomcat v8.0 Server at localhost is already in use. The server may already be running in another process, or a system process may be using the port. To start this server you will need to stop the other process or change the port number(s).Error running Tomcat8: Address localhost:8080 is already in use</code></pre><h2 id="一、分析并解决问题"><a href="#一、分析并解决问题" class="headerlink" title="一、分析并解决问题"></a>一、分析并解决问题</h2><blockquote><p>电脑中 8080 端口被占用，导致 web 项目不能运行</p></blockquote><blockquote><p>任务管理器关闭占用 8080 端口的程序</p></blockquote><h3 id="netstat-ano"><a href="#netstat-ano" class="headerlink" title="netstat -ano"></a>netstat -ano</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1602926284869-236a07ed-16de-4b45-9fb3-08aa10dd3df8.png#align=left&display=inline&height=600&margin=%5Bobject%20Object%5D&originHeight=600&originWidth=1200&size=0&status=done&style=none&width=1200"></p><h3 id="tasklist"><a href="#tasklist" class="headerlink" title="tasklist"></a>tasklist</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1602926285001-7e1779f1-5c00-4f0d-ad38-20b653849c37.png#align=left&display=inline&height=221&margin=%5Bobject%20Object%5D&originHeight=221&originWidth=1200&size=0&status=done&style=none&width=1200"><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1602926284877-544af23f-b422-49de-af28-86f9c7a37ce3.png#align=left&display=inline&height=183&margin=%5Bobject%20Object%5D&originHeight=183&originWidth=1200&size=0&status=done&style=none&width=1200"></p><h3 id="任务管理器"><a href="#任务管理器" class="headerlink" title="任务管理器"></a>任务管理器</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1602926285182-6bfb20a5-33a4-4a6b-8969-eaae9b7c67e4.png#align=left&display=inline&height=550&margin=%5Bobject%20Object%5D&originHeight=550&originWidth=834&size=0&status=done&style=none&width=834"></p>]]></content>
      
      
      <categories>
          
          <category> Bug </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>java-数组越界和格式输出</title>
      <link href="blog/ggg01q/"/>
      <url>blog/ggg01q/</url>
      
        <content type="html"><![CDATA[<h2 id="一、数组越界"><a href="#一、数组越界" class="headerlink" title="一、数组越界"></a>一、数组越界</h2><pre><code>java.lang.ArrayIndexOutOfBoundsException</code></pre><p>在进行判断条件的时候，注意 java 当中的数组“尾巴”不要溢出，数组 arr 的合法错误范围是[0, arr.length-1]</p><blockquote><ul><li>解决办法</li><li>①debug 看数组的尾巴部分输出情况【数组空间小的情况】</li><li>② 打印出遍历数组的索引值【通法】</li></ul></blockquote><p>回顾 java 初始化数组的方式：</p><ul><li>静态初始化：初始化时由程序员显式指定每个数组元素的初始值，有系统决定数组的长度</li></ul><blockquote><p>arrayName = new type[]{element1,element2,element3…}</p></blockquote><pre><code>int[] intArr;intArr = new int[]&#123;1,2,3,4,5,9&#125;;或者String[] strArr = &#123;&quot;one&quot;,&quot;two&quot;,&quot;three&quot;&#125;;</code></pre><ul><li>动态初始化：初始化时由程序员指定数组的长度，由系统初始化每个数组元素的默认值</li></ul><blockquote><p>arrayName = new type[length];</p></blockquote><pre><code>int[] price = new int[4];</code></pre><h2 id="二、printf；println；print"><a href="#二、printf；println；print" class="headerlink" title="二、printf；println；print"></a>二、printf；println；print</h2><ul><li>printf：遇到浮点型数值，继承 C 语言里面的使用，<strong>格式化</strong>输出（注意，参数顺序）</li><li>print：就是一般的标准输出，但是不换行</li><li>println：比 print 多的就是最后会换行</li></ul><pre><code class="java">int i = 4;double j = 5;System.out.print(&quot;用print输出i:&quot;+ i);System.out.println( &quot;用println输出i:&quot;+ i);System.out.printf(&quot;i的值为%d,j的值为%f&quot;, i,j);</code></pre><pre><code class="java">用print输出i:4用println输出i:4i的值为4,j的值为5.000000</code></pre><ul><li>printf 补充</li></ul><blockquote><p><code>%.2f</code>的意思是输出两位小数点<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1602926246151-1730c963-0816-46d1-bd3d-3a5cc7b30403.png#align=left&display=inline&height=589&margin=%5Bobject%20Object%5D&originHeight=589&originWidth=1162&size=0&status=done&style=none&width=1162"></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Bug </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[转]java-找不到或无法加载主类</title>
      <link href="blog/qp81g3/"/>
      <url>blog/qp81g3/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/wangxiaoha/p/6293340.html">https://www.cnblogs.com/wangxiaoha/p/6293340.html</a></p><p><a href="https://bbs.csdn.net/topics/391862656?page=1">https://bbs.csdn.net/topics/391862656?page=1</a></p><p><a href="https://blog.csdn.net/qinshijangshan/article/details/53048342?depth_1-utm_source=distribute.pc_relevant.none-task-blog-OPENSEARCH-1&utm_source=distribute.pc_relevant.none-task-blog-OPENSEARCH-1">https://blog.csdn.net/qinshijangshan/article/details/53048342?depth_1-utm_source=distribute.pc_relevant.none-task-blog-OPENSEARCH-1&amp;utm_source=distribute.pc_relevant.none-task-blog-OPENSEARCH-1</a></p><p><a href="https://blog.csdn.net/lanchunhui/article/details/76339252">https://blog.csdn.net/lanchunhui/article/details/76339252</a></p><p><a href="https://blog.csdn.net/qq_37717853/article/details/78218606?depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1&utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1">eclipse 下的输入参数方式</a></p>]]></content>
      
      
      <categories>
          
          <category> Bug </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>hexo-生成文章出错</title>
      <link href="blog/pxpix4/"/>
      <url>blog/pxpix4/</url>
      
        <content type="html"><![CDATA[<h2 id="一、报错信息"><a href="#一、报错信息" class="headerlink" title="一、报错信息"></a>一、报错信息</h2><pre><code class="bash">hexo gINFO  Start processingFATAL Somethings wrong. Maybe you can find the solution here: https://hexo.io/docs/troubleshooting.htmlTemplate render error: (unknown path)  unexpected end of file    at Object._prettifyError (D:\Blog\blog-wztlink1013-3.0\node_modules\nunjucks\src\lib.js:36:11)    at Template.render (D:\Blog\blog-wztlink1013-3.0\node_modules\nunjucks\src\environment.js:536:21)    at Environment.renderString (D:\Blog\blog-wztlink1013-3.0\node_modules\nunjucks\src\environment.js:378:17)    at D:\Blog\blog-wztlink1013-3.0\node_modules\hexo\lib\extend\tag.js:120:48    at tryCatcher (D:\Blog\blog-wztlink1013-3.0\node_modules\bluebird\js\release\util.js:16:23)    at Function.Promise.fromNode.Promise.fromCallback (D:\Blog\blog-wztlink1013-3.0\node_modules\bluebird\js\release\promise.js:209:30)    at Tag.render (D:\Blog\blog-wztlink1013-3.0\node_modules\hexo\lib\extend\tag.js:120:18)    at Object.onRenderEnd (D:\Blog\blog-wztlink1013-3.0\node_modules\hexo\lib\hexo\post.js:291:22)    at D:\Blog\blog-wztlink1013-3.0\node_modules\hexo\lib\hexo\render.js:79:21    at tryCatcher (D:\Blog\blog-wztlink1013-3.0\node_modules\bluebird\js\release\util.js:16:23)    at Promise._settlePromiseFromHandler (D:\Blog\blog-wztlink1013-3.0\node_modules\bluebird\js\release\promise.js:547:31)    at Promise._settlePromise (D:\Blog\blog-wztlink1013-3.0\node_modules\bluebird\js\release\promise.js:604:18)    at Promise._settlePromise0 (D:\Blog\blog-wztlink1013-3.0\node_modules\bluebird\js\release\promise.js:649:10)    at Promise._settlePromises (D:\Blog\blog-wztlink1013-3.0\node_modules\bluebird\js\release\promise.js:729:18)    at _drainQueueStep (D:\Blog\blog-wztlink1013-3.0\node_modules\bluebird\js\release\async.js:93:12)    at _drainQueue (D:\Blog\blog-wztlink1013-3.0\node_modules\bluebird\js\release\async.js:86:9)    at Async._drainQueues (D:\Blog\blog-wztlink1013-3.0\node_modules\bluebird\js\release\async.js:102:5)    at Immediate.Async.drainQueues (D:\Blog\blog-wztlink1013-3.0\node_modules\bluebird\js\release\async.js:15:14)    at processImmediate (internal/timers.js:456:21)</code></pre><h2 id="二、分析并解决问题"><a href="#二、分析并解决问题" class="headerlink" title="二、分析并解决问题"></a>二、分析并解决问题</h2><p>根据报错信息，包 nunjucks、bluebird 使用异常</p><p>然后进到 node_modules 文件夹里面分别找到两个包，进入 README.md 进入官网，numjucks 包应该是渲染文章有关，期间出错应该是 markdown 文章里面所使用的标签与 nunjucks 模板引擎的标签冲突，</p><p>根据文档定位英文大括号的使用，定位文章使用带有大括号的 fancybox 标签，标签结束忘记加 end 而导致出错</p><h2 id="三、hexo-g-出错总结"><a href="#三、hexo-g-出错总结" class="headerlink" title="三、hexo g 出错总结"></a>三、hexo g 出错总结</h2><p>hexo g 出错总结多为文件格式出错，主题配置出错，抑或是文章格式出错等</p><h3 id="文章头部"><a href="#文章头部" class="headerlink" title="文章头部"></a>文章头部</h3><ul><li><em>hexo 相关文章报错，大多数为格式出错，文章头部的使用严格遵循 hexo 官方文档的使用，但是目录优化插件，使得文章头部的元信息更为简单化</em></li><li>减号<code>-</code>分隔符，注意头部 front-matter、markdown 行分隔。如果没有加 front-matter，文章还用了 markdown，会报错<br><code>YAMLException: end of the stream or a document separator is expected at line 6, column 1:</code></li><li>目录优化插件的使用</li></ul><h3 id="文章体"><a href="#文章体" class="headerlink" title="文章体"></a>文章体</h3><ul><li>英文大括号的使用要“有始有终”，Volantis 主题的大括号标签使用</li></ul><h3 id="空格问题"><a href="#空格问题" class="headerlink" title="空格问题"></a>空格问题</h3><pre><code class="bash">ERROR Process failed: _posts/yuque/外汇时间序列预测.mdYAMLException: end of the stream or a document separator is expected at line 2, column 11:    categories:              ^    at generateError (D:\Blog\blog-wztlink1013-3.0\node_modules\js-yaml\lib\js-yaml\loader.js:167:10)    at throwError (D:\Blog\blog-wztlink1013-3.0\node_modules\js-yaml\lib\js-yaml\loader.js:173:9)    at readDocument (D:\Blog\blog-wztlink1013-3.0\node_modules\js-yaml\lib\js-yaml\loader.js:1545:5)    at loadDocuments (D:\Blog\blog-wztlink1013-3.0\node_modules\js-yaml\lib\js-yaml\loader.js:1588:5)    at Object.load (D:\Blog\blog-wztlink1013-3.0\node_modules\js-yaml\lib\js-yaml\loader.js:1614:19)    at parseYAML (D:\Blog\blog-wztlink1013-3.0\node_modules\hexo-front-matter\lib\front_matter.js:78:23)    at parse (D:\Blog\blog-wztlink1013-3.0\node_modules\hexo-front-matter\lib\front_matter.js:54:12)    at D:\Blog\blog-wztlink1013-3.0\node_modules\hexo\lib\plugins\processor\post.js:48:20    at tryCatcher (D:\Blog\blog-wztlink1013-3.0\node_modules\bluebird\js\release\util.js:16:23)    at Promise._settlePromiseFromHandler (D:\Blog\blog-wztlink1013-3.0\node_modules\bluebird\js\release\promise.js:544:35)    at Promise._settlePromise (D:\Blog\blog-wztlink1013-3.0\node_modules\bluebird\js\release\promise.js:604:18)    at Promise._settlePromise0 (D:\Blog\blog-wztlink1013-3.0\node_modules\bluebird\js\release\promise.js:649:10)    at Promise._settlePromises (D:\Blog\blog-wztlink1013-3.0\node_modules\bluebird\js\release\promise.js:729:18)    at Promise._fulfill (D:\Blog\blog-wztlink1013-3.0\node_modules\bluebird\js\release\promise.js:673:18)    at PromiseArray._resolve (D:\Blog\blog-wztlink1013-3.0\node_modules\bluebird\js\release\promise_array.js:127:19)    at PromiseArray._promiseFulfilled (D:\Blog\blog-wztlink1013-3.0\node_modules\bluebird\js\release\promise_array.js:145:14)    at PromiseArray._iterate (D:\Blog\blog-wztlink1013-3.0\node_modules\bluebird\js\release\promise_array.js:115:31)    at PromiseArray.init [as _init] (D:\Blog\blog-wztlink1013-3.0\node_modules\bluebird\js\release\promise_array.js:79:10)    at Promise._settlePromise (D:\Blog\blog-wztlink1013-3.0\node_modules\bluebird\js\release\promise.js:601:21)    at Promise._settlePromise0 (D:\Blog\blog-wztlink1013-3.0\node_modules\bluebird\js\release\promise.js:649:10)    at Promise._settlePromises (D:\Blog\blog-wztlink1013-3.0\node_modules\bluebird\js\release\promise.js:729:18)    at Promise._fulfill (D:\Blog\blog-wztlink1013-3.0\node_modules\bluebird\js\release\promise.js:673:18)    at PromiseArray._resolve (D:\Blog\blog-wztlink1013-3.0\node_modules\bluebird\js\release\promise_array.js:127:19)    at PromiseArray._promiseFulfilled (D:\Blog\blog-wztlink1013-3.0\node_modules\bluebird\js\release\promise_array.js:145:14)    at Promise._settlePromise (D:\Blog\blog-wztlink1013-3.0\node_modules\bluebird\js\release\promise.js:609:26)    at Promise._settlePromise0 (D:\Blog\blog-wztlink1013-3.0\node_modules\bluebird\js\release\promise.js:649:10)    at Promise._settlePromises (D:\Blog\blog-wztlink1013-3.0\node_modules\bluebird\js\release\promise.js:729:18)    at Promise._fulfill (D:\Blog\blog-wztlink1013-3.0\node_modules\bluebird\js\release\promise.js:673:18)INFO  Generating Baidu urls for last 1 posts</code></pre><p>奇葩错误，在最上面的三个分隔符后面也要加空格，可能是语雀那边同步过来的文章问题</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://mozilla.github.io/nunjucks/cn/getting-started.html">nunjucks 文档</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Bug </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>SSH-登录报错</title>
      <link href="blog/pix070/"/>
      <url>blog/pix070/</url>
      
        <content type="html"><![CDATA[<hr><h2 id="一、报错信息"><a href="#一、报错信息" class="headerlink" title="一、报错信息"></a>一、报错信息</h2><pre><code class="bash">remote: Coding 提示: Authentication failed.remote: 认证失败，请确认您输入了正确的账号密码。fatal: Authentication failed for &#39;https://e.coding.net/wztlink1013/wztlink1013.git/&#39;##[error]Process completed with exit code 128.</code></pre><h2 id="二、分析并解决问题"><a href="#二、分析并解决问题" class="headerlink" title="二、分析并解决问题"></a>二、分析并解决问题</h2><p>自动化部署过程中，coding 认证出错，我觉得应该有两个可能性</p><ol><li>字面意思账号密码出错</li><li>SSH 密匙没有匹配到</li><li>在 GitHub Actions 上所配置的 Token 信息之间也修改了一次，会不会是忘了改用户名</li></ol><p>如果是第一种情况，已经进入控制面板中的凭据管理器，更改了 coding 在本机上的默认永久密码，不弹窗理论没事，但是无效，</p><p>根据上次在本机上克隆 coding 仓库也没有其任何反应，所以问题应该出在 ssh 密匙上面，进一步回想，自己重装电脑后，当时是打算不使用全局用户没加上 global 打算使用各个用户，但是最后又换成全局用户，所以生成的.ssh 文件夹下的 config 文件有被删除了，会不会是 config 里面的 coding host 被删除，就默认这个电脑只有初始化 github 用户呢？</p><p>好的，试验了一下，解决了在本地电脑 coding“不算用户”的问题，但是自动化部署的问题未解决</p><p>最后试一下 GitHub Actions 上是不是 coding 用户名之间忘了换一次，的确是……</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.jianshu.com/p/501277e1bada">一台电脑利用秘钥绑定多个 ssh-key 账号（实 n</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Bug </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Navicat-1045报错</title>
      <link href="blog/wp9hok/"/>
      <url>blog/wp9hok/</url>
      
        <content type="html"><![CDATA[<h2 id="一、报错信息"><a href="#一、报错信息" class="headerlink" title="一、报错信息"></a>一、报错信息</h2><pre><code>1045-Access denied for user root@localhost(using password:YES)</code></pre><h2 id="二、问题分析与解决"><a href="#二、问题分析与解决" class="headerlink" title="二、问题分析与解决"></a>二、问题分析与解决</h2><p>不被接入，改 root 密码</p><p>在 mysql 控制台里面改密码</p><p><code>ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED WITH mysql_native_password BY &#39;你的密码&#39;;</code></p><p>刷新数据库</p><p><code>flush privileges;</code></p><p>退出</p><p><code>quit;</code></p><p>重启 Navicat 再次链接即可。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://blog.csdn.net/acoolgiser/article/details/82967317?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522159185926319725250149590%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=159185926319725250149590&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_ctr_v3-4-82967317.ecpm_v1_rank_ctr_v3&utm_term=1045-Access+denied+for+user+ro">acoolgiser</a></li><li><a href="https://blog.csdn.net/zhang_yu_ling/article/details/103177296?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522159185926319725250149590%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=159185926319725250149590&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_ctr_v3-2-103177296.ecpm_v1_rank_ctr_v3&utm_term=1045-Access+denied+for+user+ro">张张张 i</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Bug </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>『斩·赤红之瞳』</title>
      <link href="essay/vbkkpv/"/>
      <url>essay/vbkkpv/</url>
      
        <content type="html"><![CDATA[<p>赤瞳的“葬送！”永远无敌，威尔的乡巴佬（贵族）战车甚是让人怀念！<br><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1620268429108-34b6b7b4-9e0e-44f5-aec6-6ea523773328.jpeg#align=left&display=inline&height=60&id=tBuFQ&margin=%5Bobject%20Object%5D&originHeight=60&originWidth=60&status=done&style=stroke&width=60"></p><p>最喜欢威尔这个角色，有自己的信仰，却又不被信仰所蒙蔽双眼！<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1620268376141-97fd7be2-f256-442b-970d-1ab2b6b29214.png#align=left&display=inline&height=540&id=u9c94a2b1&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1080&originWidth=1920&size=3241587&status=done&style=stroke&width=960" alt="image.png"></p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1619317355425-0fe5d175-5fc4-4e3c-b6e0-ecef02d26cf6.png#align=left&display=inline&height=1080&id=uf72f0f30&margin=%5Bobject%20Object%5D&name=592276.png&originHeight=1080&originWidth=1920&size=2185020&status=done&style=none&width=1920" alt="592276.png"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1619403236436-3b1f1084-70d1-470c-8033-8da759333d26.png#align=left&display=inline&height=2039&id=KgBwl&margin=%5Bobject%20Object%5D&name=81852880_p0.png&originHeight=2039&originWidth=1378&size=2849409&status=done&style=none&width=1378" alt="81852880_p0.png"><br><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1619403320717-174bfe62-fc0d-4470-ade4-dfaec764e1a8.jpeg#align=left&display=inline&height=1080&id=OBENY&margin=%5Bobject%20Object%5D&name=605796.jpg&originHeight=1080&originWidth=1920&size=1144117&status=done&style=none&width=1920" alt="605796.jpg"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1619403335035-06379a53-3aa1-4ed1-8194-864aa0423edf.png#align=left&display=inline&height=1359&id=BZQXf&margin=%5Bobject%20Object%5D&name=610221.png&originHeight=1359&originWidth=1920&size=3173404&status=done&style=none&width=1920" alt="610221.png"><br><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1619403340923-d3a0d8f3-2a53-4f2d-ae07-18c5a4d10d3b.jpeg#align=left&display=inline&height=1080&id=poIeY&margin=%5Bobject%20Object%5D&name=554303.jpg&originHeight=1080&originWidth=1920&size=187185&status=done&style=none&width=1920" alt="554303.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 人生影视课 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>榕树下的男孩和女孩</title>
      <link href="essay/rqlvig/"/>
      <url>essay/rqlvig/</url>
      
        <content type="html"><![CDATA[<p>趁着伙伴们都还在睡觉那天还未入夜，他朝着桥的那头跑去，那天月亮高高挂起，像是蒙娜丽莎的那般深邃眼眸观望着他，突然，他像是被什么东西拍打了一下，男孩往后望去，是个小女孩，那女孩头发短短的，头发末梢还有些卷卷的，就像是柳树下的枝柳发梢一般，凌乱有致，最重要的是男孩被那饱含星辰大海的眼眸所吸引，还有那唇……小男孩突然一愣，回应道：“你是谁？”女孩说：“我练完了，想去桥的那头玩玩！”男孩惊讶之，连忙回应：“我也是”，榕树那边的风景亦是观之，却不能让我陶醉，说罢，小男孩帮那个小女孩整理一番身边的杂草，他想牵起哪个女孩的手，但是他并没有，他在害怕吗？不知道。我想可能是他没有这般前期过别人的手吧。</p><p>桥的那头好漂亮，哪里有些许的繁华，还有些唱作，同时传来了一阵阵的童谣响起，那个女孩心里一颤，她说，如熟悉的唱作，和我家乡一般，她说她听到了她儿时的童谣，男孩向她的眼眸观去，他像是看到了星辰，他瞬间感受到一种温度，是的！他喜欢上她了。</p><p>榕树下的人们，是有着各自的命运的，男孩和女孩，男孩子要往前走，因为这里的人们是不能停滞的。因为它们本该如此。</p><p>男孩终于忍不住了，他对女孩说：“你喜欢这个童谣吗？”女孩说：“好感动，能在这个地方听到这个童谣”，女孩有一个动作，她用手指收起了她的眼泪，男孩心里想着，桥是禁忌，按照他们的文明，那是他们不能逾越的禁忌。</p><p>旁边的蛐蛐们开始了，仿佛开始为那童谣奏乐了，周围很喧闹，但是他的内心足够安静的，一切都是那般静，那一瞬间，那个男孩就像静静地享受着这般安静与温暖，就像是圆月下的海面，波光涟漪却也有着阵阵波澜。</p><p>桥就像是时间的奴隶，夜深了，桥头的那根锁链开始叮叮叮~的响起，像是提醒着失足的孩子们该回去了，男孩和女孩的时间不读了，往日，男孩会跑着回桥的那头榕树下，来日再来看看这繁华的都市，然后回到榕树下面，因为本该如此，他比谁都清楚榕树下的他背负着怎么样的命运。</p><p>黑夜里，男孩再也看不见女孩的脸，月光很圆，周围的灯也是明亮着的，但男孩却觉得周围一切都是暗淡的，因为他再也看不见那深邃的眼眸。</p><p>女孩对男孩说：“谢谢你帮我越过那座桥，我才有了这般幸运，在这榕树下的文明之外还能听到这般旋律，谢谢你！”</p><p>但是男孩心里想要的不是这句谢谢，是她眼神之下的温暖的星辰大海，因为他一直往前走，修炼。</p><p>他想要在榕树下成为一个真正的男人，特立独行，无惧生死，因为他觉得，他本该如此！可今天，他似乎被他的脸庞融化了。</p><p>一路上，男孩和女孩说着话，他从来没有这般欣喜，来到榕树下面，这个新生的文明之下，可是，女孩的话却在变少。</p><p>回到榕树下，隧道已经慢慢如期开启，男孩和女孩要走了，男孩心里清楚着，他不会再见她了，他心里忧伤，却也无奈，因为，在此之下的文明，亦是如此，就像是之前所述的“内壁”那般文明、国度。或者还可以说，文明之间，男孩和女孩是不合适的，因为她走的和他走的路从一开始就是相反的道路，但在榕树下的男孩确实一直以来有着思想的精灵，他有些忍不住了，在女孩走向隧道那扇门之前那么一瞬，男孩大声说：“喂，你，你的眼睛很好看，虽然夜太黑，但我心里还记得，我喜欢你，喜欢你喜欢的童谣，喜欢你眼睛中的星辰大海！我从没有想过，在榕树下的文明，还能遇见此般的你。还有，我很喜欢你的微笑。”女孩说：“嗯。”</p><p>_2020.10.12 文渊楼 C 区 255 _<br><em>计网老师有点事没来上课，高保忠老师来代课了</em></p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>鸟儿飞走了</title>
      <link href="essay/pyxkf8/"/>
      <url>essay/pyxkf8/</url>
      
        <content type="html"><![CDATA[<p>学校又要建楼了，地点是图书馆靠西边的那片树林。</p><p>去二餐的靠建筑工地的那条沿路上，总是听到叽叽喳喳的小鸟叫声，定睛一看，原来是因建筑而没有去路的小鸟，它们就在那片矮秃秃的草丛里面，就像是饿了的稚鸟在窝里面叽叽喳喳等它们母亲回来一般。</p><p>“济南一建”的速度真是快，短短一个月不到，那栋楼就建成有二、三层高楼那般模样，可我却不太喜欢它们这么快速度，因为那样，就会挡住我在 E 区各个楼道往学校南边观去的视线，正好挡住学校后面的双龙山，学校的小鸟也会少了，估计它们会生气般地往山上飞去，不再飞回来了。</p><p>为什么我会有些许的伤感……</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>对待问题要静心处理</title>
      <link href="essay/wgtfly/"/>
      <url>essay/wgtfly/</url>
      
        <content type="html"><![CDATA[<p>在配置安卓环境的时候，遇到 sdk 漏下载的情况，中间有几次心态爆炸，遇到问题发现自己还是不能很好的解决</p><p>这过程中，S 同学说到他配置环境用到了三天，最后成功了，而且，他的环境远劣于我，突然让我想到一句话，<strong>谁都会遇到问题，甚至遇到的问题都一样</strong>。但是不同的人会有不同的处理方式以及对待问题的态度，我的心真的还不够静，甚至可以说，依旧那么浮躁…</p><p>遇到困难，要静下心来，纸上得来终觉浅，绝知此事要躬行啊～</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>备份</title>
      <link href="blog/vab07n/"/>
      <url>blog/vab07n/</url>
      
        <content type="html"><![CDATA[<h1 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h1><p>如果是 MyISAM 的数据库引擎，那么直接复制相应的数据库文件即可。<br>如果是 InnoDB 则需要利用命令。这也是更为一般的普适方法。</p><p>利用 MySQL 提供的工具———— <strong>mysqldump</strong></p><h2 id="mysqldump"><a href="#mysqldump" class="headerlink" title="mysqldump"></a>mysqldump</h2><pre><code>mysqldump -uroot -p database_name [table_name1,...] &gt;pathname.sql</code></pre><h3 id="备份数据库"><a href="#备份数据库" class="headerlink" title="备份数据库"></a>备份数据库</h3><p>使用时需指定用户名，并使用-p 选项，再回车后键入密码。实际上是利用的<a href="#%E9%87%8D%E5%AE%9A%E5%90%91">重定向</a>来生成一个 sql 脚本文件。<br>该文件中包含各个 sql 语句。</p><p>重定向符号后面的是 sql 文件的路径。Linux 请使用<code>/</code>来表示目录结构。Windows 可以用<code>\</code> 也可以用 <code>/</code>。<br>比如：</p><h4 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h4><pre><code>mysqldump -uroot -p world &gt;/home/jelly/config/world.sql</code></pre><h4 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h4><pre><code>mysqldump -uroot -p world &gt;d:/config/world.sqlmysqldump -uroot -p world &gt;d:\config\world.sql**</code></pre><h3 id="备份部分表"><a href="#备份部分表" class="headerlink" title="备份部分表"></a>备份部分表</h3><p>如果不想备份整个数据库，而是像备份某个表，那么在数据库后面指定表的名称。</p><h1 id="还原"><a href="#还原" class="headerlink" title="还原"></a>还原</h1><p>执行已备份的 sql 脚本文件。有两种方案：</p><h2 id="已连接数据库时"><a href="#已连接数据库时" class="headerlink" title="已连接数据库时"></a>已连接数据库时</h2><p>登录 mysql 命令行，使用 source 命令（与 mysqldump 不同，source 不是独立工具，而是 MySQL 内部命令）来执行 sql 脚本。<br>需要先创建一个数据库，然后切换到给数据库，再执行该命令。</p><pre><code>mysql&gt; source d:/tool/world.sql</code></pre><h2 id="未连接数据库时"><a href="#未连接数据库时" class="headerlink" title="未连接数据库时"></a>未连接数据库时</h2><p>直接在 shell 的命令行执行：</p><pre><code>mysql -uroot -p &lt; /home/jelly/config/world.sql</code></pre><h1 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h1><p>存储引擎是基于表的，不是基于数据库的。</p><table><thead><tr><th>功能</th><th align="center">MyISAM</th><th align="center">InnoDB</th><th align="center">Memory</th><th align="center">Archive</th></tr></thead><tbody><tr><td>存储限制</td><td align="center">256T</td><td align="center">64T</td><td align="center">有</td><td align="center">无</td></tr><tr><td>事务安全</td><td align="center">-</td><td align="center">支持</td><td align="center">-</td><td align="center">-</td></tr><tr><td>索引支持</td><td align="center">支持</td><td align="center">支持</td><td align="center">支持</td><td align="center">-</td></tr><tr><td>锁颗粒</td><td align="center">表锁</td><td align="center">行锁</td><td align="center">表锁</td><td align="center">行锁</td></tr><tr><td>数据压缩</td><td align="center">支持</td><td align="center">-</td><td align="center">-</td><td align="center">支持</td></tr><tr><td>外键</td><td align="center">-</td><td align="center">支持</td><td align="center">-</td><td align="center">-</td></tr></tbody></table><p>以上是常用引擎，另外还有其他存储引擎。</p>]]></content>
      
      
      <categories>
          
          <category> DataBase </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>MySQL命令</title>
      <link href="blog/emv1ek/"/>
      <url>blog/emv1ek/</url>
      
        <content type="html"><![CDATA[<h2 id="登陆命令"><a href="#登陆命令" class="headerlink" title="登陆命令"></a>登陆命令</h2><pre><code class="sql">mysql -u用户名 -p密码</code></pre><p>用户名和-u 选项之间可以有空格，但是密码和-p 选项之间必须无空格。但是这样密码会是明文。你可以在键入-p 之后，回车再输入密码，就是密文。</p><h3 id="常用选项"><a href="#常用选项" class="headerlink" title="常用选项"></a>常用选项</h3><table><thead><tr><th>缩写</th><th>全写</th><th>描述</th></tr></thead><tbody><tr><td>-h</td><td>–host</td><td>主机</td></tr><tr><td>-p</td><td>–password</td><td>密码</td></tr><tr><td>-P</td><td>–port</td><td>端口</td></tr><tr><td>-V</td><td>–version</td><td>版本信息</td></tr><tr><td>-u</td><td>–user</td><td>用户</td></tr><tr><td></td><td>–prompt</td><td>修改提示符</td></tr></tbody></table><h4 id="–prompt"><a href="#–prompt" class="headerlink" title="–prompt"></a>–prompt</h4><p>–prompt 支持几个转义词组</p><ul><li>\h 主机名</li><li>\D 完整日期</li><li>\d 当前数据库</li><li>\u 当前用户</li></ul><h2 id="登陆之后"><a href="#登陆之后" class="headerlink" title="登陆之后"></a>登陆之后</h2><h3 id="退出"><a href="#退出" class="headerlink" title="退出"></a>退出</h3><ul><li>exit</li><li>quit</li><li>\q</li></ul><p>都能退出 mysql，系统显示 Bye。</p><h3 id="帮助"><a href="#帮助" class="headerlink" title="帮助"></a>帮助</h3><p>键入<code>help</code>或<code>\h</code>。</p><h3 id="显示信息"><a href="#显示信息" class="headerlink" title="显示信息"></a>显示信息</h3><p>select:</p><ul><li>version(); 版本信息</li><li>now(); 当前时间</li><li>user(); 用户@主机名</li></ul><h3 id="使用系统命令"><a href="#使用系统命令" class="headerlink" title="使用系统命令"></a>使用系统命令</h3><p><strong>!</strong> 后加 shell 命令可以在 mysql 中执行 shell 命令。</p><blockquote><p>gdb 使用 shell 加命令来执行 shell 命令。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> DataBase </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>权限管理</title>
      <link href="blog/frgbbo/"/>
      <url>blog/frgbbo/</url>
      
        <content type="html"><![CDATA[<h1 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h1><blockquote><p>本文所有操作，均可<strong>通过普通 SQL 语句更新系统表 user</strong>来实现相应的功能。</p></blockquote><h2 id="新建用户"><a href="#新建用户" class="headerlink" title="新建用户"></a>新建用户</h2><blockquote><p>基本格式</p></blockquote><pre><code class="sql">CREATE USER &#39;username&#39;@&#39;host&#39; IDENTIFIED BY &#39;password&#39;;</code></pre><p>注意引号的位置，不要用一对引号把@也包含进来。@前面是用户名，后面是主机名，可以使用通配符<code>%</code></p><blockquote><p>实际上可以省略用户名和主机名处的引号，但如果使用了通配符则引号不能省略</p></blockquote><pre><code class="sql">CREATE USER &#39;jelly&#39;@&#39;%&#39; IDENTIFIED BY &#39;123456&#39;;CREATE USER jelly@127.0.0.1;CREATE USER jelly;</code></pre><h2 id="删除用户"><a href="#删除用户" class="headerlink" title="删除用户"></a>删除用户</h2><pre><code class="sql">DROP USER user;DROP USER jelly@&#39;%&#39;;DROP USER jelly@localhost</code></pre><h2 id="重命名用户"><a href="#重命名用户" class="headerlink" title="重命名用户"></a>重命名用户</h2><blockquote><p>例如：</p></blockquote><pre><code class="sql">RENAME USER &#39;jelly&#39;@&#39;%&#39; TO &#39;guodong&#39;@&#39;%&#39;;</code></pre><h2 id="修改密码"><a href="#修改密码" class="headerlink" title="修改密码"></a>修改密码</h2><blockquote><p>例如：</p></blockquote><pre><code class="sql">SET PASSWORD FOR &#39;root&#39;@&#39;localhost&#39; = PASSWORD(&#39;123456&#39;);</code></pre><blockquote><p>此外还可以使用 mysql 工具<code>mysqladmin</code>来修改<br>格式：<code>mysqladmin -u用户名 -p旧密码 password 新密码</code></p></blockquote><h1 id="权限管理"><a href="#权限管理" class="headerlink" title="权限管理"></a>权限管理</h1><table><thead><tr><th>权限范围</th><th>可用权限</th></tr></thead><tbody><tr><td>表权限</td><td><code>Select</code>, <code>Insert</code>, <code>Update</code>, <code>Delete</code>, <code>Create</code>, <code>Drop</code>, <code>Grant</code>, <code>References</code>, <code>Index</code>, <code>Alter</code></td></tr><tr><td>列权限</td><td><code>Select</code>, <code>Insert</code>, <code>Update</code>,<code>References</code></td></tr><tr><td>过程权限</td><td><code>Execute</code>, <code>Alter Routine</code>, <code>Grant</code></td></tr></tbody></table><h2 id="授权"><a href="#授权" class="headerlink" title="授权"></a>授权</h2><pre><code class="sql">GRANT SELECT ON *.*  TO jelly@&#39;%&#39;//给一个用户（jelly）分配全部的操作权限GRANT ALL PRIVILEGES ON *.*  TO jelly@&#39;%&#39;</code></pre><p>%就是前面我们提到过的通配符，可以匹配 0 到 n 个字符。这里指的是该用户所登录的任何主机。</p><h2 id="取消授权"><a href="#取消授权" class="headerlink" title="取消授权"></a>取消授权</h2><p>语法：</p><pre><code class="sql">REVOKE privilege ON databasename.tablename FROM &#39;username&#39;@&#39;host&#39;;</code></pre><p>例如：</p><pre><code class="sql">REVOKE SELECT ON test.user FROM &#39;jelly&#39;@&#39;%&#39;;REVOKE ALL ON *.* FROM &#39;jelly&#39;@&#39;%&#39;;</code></pre><blockquote><p><strong>GRANT</strong>和<strong>REVOKE</strong>对于用户而言，一个是<strong>TO</strong>，一个是<strong>FROM</strong></p></blockquote><h2 id="查看授权"><a href="#查看授权" class="headerlink" title="查看授权"></a>查看授权</h2><p>例如：</p><pre><code class="sql">SHOW GRANTS FOR &#39;jelly&#39;@&#39;%&#39;;</code></pre><h2 id="刷新权限"><a href="#刷新权限" class="headerlink" title="刷新权限"></a>刷新权限</h2><pre><code class="sql">FLUSH PRIVILEGES</code></pre><p>偶尔会出现，修改了操作系统表的权限，却没有及时更新的情况。可以用上述命令刷新。</p>]]></content>
      
      
      <categories>
          
          <category> DataBase </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数据库中的函数</title>
      <link href="blog/sbxidb/"/>
      <url>blog/sbxidb/</url>
      
        <content type="html"><![CDATA[<h1 id="字符（串）函数"><a href="#字符（串）函数" class="headerlink" title="字符（串）函数"></a>字符（串）函数</h1><p>函数可以在 MySQL 提示符中，直接用 SELECT 语句测试。<br>比如 <strong>SELECT USER();</strong></p><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><ul><li>字符函数</li><li>数值运算符与函数</li><li>比较运算符与函数</li><li>日期时间函数</li><li>信息函数</li><li>聚合函数</li><li>加密函数</li></ul><h2 id="字符（串）函数-1"><a href="#字符（串）函数-1" class="headerlink" title="字符（串）函数"></a>字符（串）函数</h2><table><thead><tr><th>名称</th><th>描述</th></tr></thead><tbody><tr><td>CONCAT</td><td>字符串连接</td></tr><tr><td>CONCAT_WS</td><td>同上，但指定连接符</td></tr><tr><td>FORMAT</td><td>数字格式化</td></tr><tr><td>LOWER</td><td>转换成小写字母</td></tr><tr><td>UPPER</td><td>转换成大写字母</td></tr><tr><td>LEFT</td><td>获取左侧字符</td></tr><tr><td>RIGHT</td><td>获取右侧字符</td></tr><tr><td>LENGTH</td><td>获取长度</td></tr><tr><td>LTRIM</td><td>删除前导空格</td></tr><tr><td>RTRIM</td><td>删除后续空格</td></tr><tr><td>TRIM</td><td>删除前后空格</td></tr><tr><td>SUBSTRING</td><td>字符串截取</td></tr><tr><td>[NOT] LIKE</td><td>模式匹配</td></tr><tr><td>REPEAT</td><td>重复字符串</td></tr><tr><td>REPLACE</td><td>字符串替换</td></tr></tbody></table><h3 id="CONCAT"><a href="#CONCAT" class="headerlink" title="CONCAT"></a>CONCAT</h3><p>参数个数不限，连接成一个字符串<br>已知 test 表的内如如下：</p><pre><code>+----+------------+-----------+| id | first_name | last_name |+----+------------+-----------+|  1 | A          | B         ||  2 | C          | D         ||  3 | tom%       | 123       ||  4 | NULL       | 11        ||  5 | 11         | 22        ||  6 | AA         | BB        ||  7 | CC         | DD        |+----+------------+-----------+</code></pre><p>test 表中有两个字段 first_name,和 last_name，调用连接函数之后：</p><pre><code class="mysql">SELECT CONCAT(first_name,last_name)AS full_name FROM test;+-----------+| full_name |+-----------+| AB        || CD        || tom%123   || NULL      || 1122      || AABB      || CCDD      |+-----------+</code></pre><h3 id="CONCAT-WS"><a href="#CONCAT-WS" class="headerlink" title="CONCAT_WS"></a>CONCAT_WS</h3><p>参数至少有三个，第一参数为要连接字符串的分隔符，后面的都是待连接的字符串。</p><pre><code class="mysql">SELECT CONCAT_WS(&#39;-&#39;,1992,10,17);+---------------------------+| CONCAT_WS(&#39;-&#39;,1992,10,17) |+---------------------------+| 1992-10-17                |+---------------------------+</code></pre><h3 id="FORMAT"><a href="#FORMAT" class="headerlink" title="FORMAT"></a>FORMAT</h3><p>将数字格式化为字符串。第二个参数为小数的位数。</p><pre><code class="mysql">SELECT FORMAT(12345.67,2);</code></pre><p>结果为千分位:</p><pre><code>+--------------------+| FORMAT(12345.67,2) |+--------------------+| 12,345.67          |+--------------------+</code></pre><h3 id="LOWER-UPPER"><a href="#LOWER-UPPER" class="headerlink" title="LOWER/UPPER"></a>LOWER/UPPER</h3><p>顾名思义，不再解释</p><h3 id="LEFT-RIGHT"><a href="#LEFT-RIGHT" class="headerlink" title="LEFT/RIGHT"></a>LEFT/RIGHT</h3><p>获取左（右）侧第几个字符。</p><pre><code>SELECT LEFT(&#39;MySQL&#39;,2);</code></pre><h3 id="LENGTH"><a href="#LENGTH" class="headerlink" title="LENGTH"></a>LENGTH</h3><p>获取字符串长度。SQL Server 中是 len 函数。MySQL 中没有 len 函数。</p><h3 id="LTRIM-RTRIM"><a href="#LTRIM-RTRIM" class="headerlink" title="LTRIM/RTRIM"></a>LTRIM/RTRIM</h3><p>删除前导/后续空格</p><h3 id="SUBSTRING"><a href="#SUBSTRING" class="headerlink" title="SUBSTRING"></a>SUBSTRING</h3><p>与其他语言中一样，截取子串的三个参数分别为：</p><ul><li>原字符串</li><li>起始位置（注意下标从 1 算起；可以为负数，即从右数起）</li><li>截取长度（缺省为截取到结尾）</li></ul><h3 id="NOT-LIKE"><a href="#NOT-LIKE" class="headerlink" title="[NOT] LIKE"></a>[NOT] LIKE</h3><pre><code>SELECT FROM &#39;MySQL&#39; LIKE &#39;M%&#39;;</code></pre><p>结果为 1，即 true。</p><ul><li>%代表 0 个或多个字符。</li><li>_代表任意一个字符。</li></ul><blockquote><p>关于转义<br>当要匹配的字符中含有特殊字符(比如%)时，需要转义。\，貌似\也可以<br>SELECT CONCAT(first_name,last_name)AS full_name FROM test WHERE first_name LIKE’%%’;</p></blockquote><p>也可以自己指定<br>SELECT CONCAT(first_name,last_name)AS full_name FROM test WHERE first_name LIKE’%1%’ ESCAPE ‘1’;</p><h3 id="TRIM"><a href="#TRIM" class="headerlink" title="TRIM"></a>TRIM</h3><p>缺省可以删除前后空格，也可以删除指定的字符。</p><pre><code class="mysql">-- 删除??MySQL???前面的？SELECT TRIM(LEADING &#39;?&#39; FROM &#39;??MySQL???&#39;);-- 删除后面的？SELECT TRIM(TRAILING &#39;?&#39; FROM &#39;??MySQL???&#39;);-- 删除前后的？SELECT TRIM(BOTH &#39;?&#39; FROM &#39;??MySQL???&#39;);</code></pre><h3 id="REPEAT"><a href="#REPEAT" class="headerlink" title="REPEAT"></a>REPEAT</h3><p>重复某一字符串多少次</p><pre><code class="mysql">SELECT REPEAT(&#39;ab&#39;,2);</code></pre><p>结果是：</p><pre><code>+----------------+| REPEAT(&#39;ab&#39;,2) |+----------------+| abab           |+----------------+</code></pre><h3 id="REPLACE"><a href="#REPLACE" class="headerlink" title="REPLACE"></a>REPLACE</h3><pre><code class="mysql">-- 去掉所有的？SELECT REPLACE(&#39;??MySQL&#39;,&#39;?&#39;,&#39;&#39;);</code></pre><p>注意！替换的时候也可以一换多，多换一。</p><h1 id="数值运算和比较运算"><a href="#数值运算和比较运算" class="headerlink" title="数值运算和比较运算"></a>数值运算和比较运算</h1><h2 id="数值运算"><a href="#数值运算" class="headerlink" title="数值运算"></a>数值运算</h2><table><thead><tr><th>名称</th><th>描述</th></tr></thead><tbody><tr><td>CEIL()</td><td>进一取整</td></tr><tr><td>DIV</td><td>整数除法</td></tr><tr><td>FLOOR()</td><td>舍一取整</td></tr><tr><td>MOD</td><td>模运算</td></tr><tr><td>POWER()</td><td>幂运算</td></tr><tr><td>ROUND()</td><td>四舍五入</td></tr><tr><td>TRUNCARE()</td><td>数字截取</td></tr></tbody></table><h3 id="CEIL-FLOOR-ROUND"><a href="#CEIL-FLOOR-ROUND" class="headerlink" title="CEIL/FLOOR/ROUND"></a>CEIL/FLOOR/ROUND</h3><p>前两者为对应操作。一个向上取整，一个向下取整。第三个 ROUND 为四舍五入。</p><h3 id="DIV-MOD"><a href="#DIV-MOD" class="headerlink" title="DIV/MOD"></a>DIV/MOD</h3><p>两者并非函数，而是 <strong>运算符</strong>。</p><pre><code class="mysql">SELECT 5 DIV 2;SELECT 7 MOD 3;</code></pre><p>MOD 与%等价，就是模运算，与别不同的是，MySQL 中支持浮点数取模。</p><h3 id="POWER"><a href="#POWER" class="headerlink" title="POWER"></a>POWER</h3><p>幂运算</p><h3 id="TRUNCARE"><a href="#TRUNCARE" class="headerlink" title="TRUNCARE"></a>TRUNCARE</h3><p>所谓的数字截取，就是对数字逐位的截断。</p><pre><code class="mysql">SELECT TRUNCATE(125.123, 1);SELECT TRUNCATE(125.123, 0);SELECT TRUNCATE(125.123, - 1);</code></pre><h2 id="运算的结果分别为：125-1、125-0-120"><a href="#运算的结果分别为：125-1、125-0-120" class="headerlink" title="运算的结果分别为：125.1、125.0,120"></a>运算的结果分别为：125.1、125.0,120</h2><h2 id="比较运算符与函数"><a href="#比较运算符与函数" class="headerlink" title="比较运算符与函数"></a>比较运算符与函数</h2><table><thead><tr><th>名称</th><th>描述</th></tr></thead><tbody><tr><td>[NOT] BETWEEN…AND…</td><td>[不]在范围内</td></tr><tr><td>[NOT] IN()</td><td>[不]在列出的值范围内</td></tr><tr><td>IS [NOT] NULL</td><td>[不]为空</td></tr></tbody></table><h1 id="日期时间函数"><a href="#日期时间函数" class="headerlink" title="日期时间函数"></a>日期时间函数</h1><table><thead><tr><th>名称</th><th>描述</th></tr></thead><tbody><tr><td>NOW()</td><td>当前日期和时间</td></tr><tr><td>CURDATE()</td><td>当前日期</td></tr><tr><td>CURTIME()</td><td>当前时间</td></tr><tr><td>DATE_ADD()</td><td>日期变化</td></tr><tr><td>DATEDIFF()</td><td>日期差值</td></tr><tr><td>DATE_FORMATE()</td><td>日期格式化</td></tr></tbody></table><h3 id="NOW-CURDATE-CURTIME"><a href="#NOW-CURDATE-CURTIME" class="headerlink" title="NOW/CURDATE/CURTIME"></a>NOW/CURDATE/CURTIME</h3><p>可以把 NOW 看作是 CURDATE 和 CURTIME 的综合</p><h3 id="DATE-ADD"><a href="#DATE-ADD" class="headerlink" title="DATE_ADD"></a>DATE_ADD</h3><p>实现日志的增减，加为正数，减为负数</p><pre><code class="mysql">SELECT DATE_ADD(CURDATE(),INTERVAL 3 WEEK);</code></pre><p>WEEK,也可以是 DAY，YEAR<br>与之相对的还有一个 DATE_SUB 函数。</p><h3 id="DATEDIFF"><a href="#DATEDIFF" class="headerlink" title="DATEDIFF"></a>DATEDIFF</h3><p>获取两个日期之间的差值，左边减去右边，值为天数。</p><pre><code class="mysql">SELECT DATEDIFF(&#39;2014-10-11&#39;,&#39;2014-09-06&#39;);</code></pre><h3 id="DATE-FORMAT"><a href="#DATE-FORMAT" class="headerlink" title="DATE_FORMAT()"></a>DATE_FORMAT()</h3><p>日期格式化为其他形式，比如：</p><pre><code class="mysql">SELECT DATE_FORMAT(&#39;2014-11-01&#39;,&#39;%m/%d/%Y&#39;);</code></pre><p>结果为：<br>11/01/2014<br>如果是小写的 y，则格式化为 11/01/14</p><h1 id="信息函数"><a href="#信息函数" class="headerlink" title="信息函数"></a>信息函数</h1><table><thead><tr><th>名称</th><th>函数</th></tr></thead><tbody><tr><td>CONNECTIOIN_ID</td><td>连接 ID</td></tr><tr><td>DATABASE</td><td>当前数据库</td></tr><tr><td>LAST_INSERT_ID</td><td>最后插入记录 ID</td></tr><tr><td>USER</td><td>当前用户</td></tr><tr><td>VERSION</td><td>版本信息</td></tr></tbody></table><h3 id="CONNECTION-ID"><a href="#CONNECTION-ID" class="headerlink" title="CONNECTION_ID"></a>CONNECTION_ID</h3><p>第一连接就是 1，以此类推。</p><h3 id="DATABASE"><a href="#DATABASE" class="headerlink" title="DATABASE"></a>DATABASE</h3><h3 id="LAST-INSERT-ID"><a href="#LAST-INSERT-ID" class="headerlink" title="LAST_INSERT_ID"></a>LAST_INSERT_ID</h3><p>当一条语句插入多条记录的时候，它只返回第一条记录的 ID。</p><h3 id="USER"><a href="#USER" class="headerlink" title="USER"></a>USER</h3><p>返回当前用户。MYSQL 中的用户的完整用户名是 <strong>用户名@登录主机</strong></p><h3 id="VERSION"><a href="#VERSION" class="headerlink" title="VERSION"></a>VERSION</h3><p>MySQL 版本号</p><h1 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h1><table><thead><tr><th>名称</th><th>描述</th></tr></thead><tbody><tr><td>AVG</td><td>平均值</td></tr><tr><td>COUNT</td><td>计数</td></tr><tr><td>MAX</td><td>最大值</td></tr><tr><td>MIN</td><td>最小值</td></tr><tr><td>SUM</td><td>求和</td></tr></tbody></table><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ul><li>聚合函数只有一个返回值！</li><li>不能直接用 SELECT 加函数名的形式来调用，必须针对字段！</li><li>优先级<ul><li>聚合函数优先级小于 WHERE 语句，不能用来 WHERE 后面。</li><li>聚合函数优先级大于 HAVING，可以用在 HAVING 后面。</li></ul></li></ul><h2 id="COUNT"><a href="#COUNT" class="headerlink" title="COUNT"></a>COUNT</h2><ul><li>COUNT(*)统计 null</li><li>COUNT(字段)不统计 null</li><li>COUNT(1)可统计</li></ul><h1 id="自定义函数"><a href="#自定义函数" class="headerlink" title="自定义函数"></a>自定义函数</h1><p>UDF(User-defined function)</p><h2 id="创建自定义函数"><a href="#创建自定义函数" class="headerlink" title="创建自定义函数"></a>创建自定义函数</h2><pre><code class="mysql">CREATE FUCNTION function_nameRETURNS&#123;STRING|INTEGER|REAL|DECIMAL&#125;RETURNroutine_body</code></pre><h2 id="函数体"><a href="#函数体" class="headerlink" title="函数体"></a>函数体</h2><p>上面的 routine_body 指代函数体。其构成：</p><ul><li>函数体由合法的 SQL 语句构成</li><li>函数体可以是简单的 SELECT 或 INSERT 语句</li><li>函数体如果为符合结构则使用 BEGIN…END 语句</li><li>符合结构可以包含声明，循环，控制结构</li></ul><h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><p><code>来源慕课网</code></p><pre><code class="mysql">-- 无参数CREATE function f()RETURNS VARCHAR(30)  RETURN Date_format(Now(), &#39;%Y年%m月%d日 %H点：%i分：%s秒&#39;);</code></pre><pre><code class="mysql">-- 带参数CREATE function f2(num1 SMALLINT UNSIGNED,                   num2 SMALLINT UNSIGNED)RETURNS FLOAT(10, 2) UNSIGNED  RETURN ( num1 + num2 ) / 2;</code></pre><pre><code>--  复合结构的函数体DELIMITER //CREATE function  adduser(username VARCHAR(20)) returns INT UNSIGNEDBEGIN  INSERT test         (                username         )         VALUES         (                username         );  RETURN Last_insert_id();END//</code></pre><p>三个要点：</p><ul><li>首先因为函数体内有分号，所以我们要修改定界符，避免函数中途停止。使用 DELIMITER 指定新的定界符为//。</li><li>然后，因为函数体内有多条 SQL 语句，所以我们要用 BEGIN…END 包裹。</li><li>RETURN 在 BEGIN…END 结构内部。并且必须有 RETURN。默认情况下，RETURN 后面的语句会在屏幕上打印出来。</li></ul><h2 id="删除函数"><a href="#删除函数" class="headerlink" title="删除函数"></a>删除函数</h2><pre><code class="mysql">DROP FUCNTION [IF EXISTS] function_name;</code></pre><p>一次只能删除一个函数。</p><h1 id="加密函数"><a href="#加密函数" class="headerlink" title="加密函数"></a>加密函数</h1><table><thead><tr><th>名称</th><th>描述</th></tr></thead><tbody><tr><td>MD5</td><td>信息摘要算法</td></tr><tr><td>PASSWORD</td><td>密码算法</td></tr></tbody></table><p>用于 WEB 页面用 MD5 算法保存用户密码<br>用户本地用户，用 PASSWORD 修改密码。比如</p><pre><code class="sql">UPDATE user SET Password=PASSWORD(&#39;newpassword&#39;) where USER=&#39;root&#39;;</code></pre><p>注意 user 表在系统数据库 mysql 下。执行命令之前请<code>USE mysql</code>。</p>]]></content>
      
      
      <categories>
          
          <category> DataBase </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>表查询优化——索引</title>
      <link href="blog/tr2ahg/"/>
      <url>blog/tr2ahg/</url>
      
        <content type="html"><![CDATA[<h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><p>索引能提高查询效率，但是查询效率和修改效率一直是一个矛盾。</p><h2 id="普通索引"><a href="#普通索引" class="headerlink" title="普通索引"></a>普通索引</h2><pre><code class="mysql">-- 单独创建，colname为列名CREATE INDEX indexname ON tablename(colname(length));-- 也可以在修改表的时候创建ALTER TABLE table_name ADD INDEX [index_name] (column_list)-- 创建表的时候指定CREATE TABLE mytable(    ID INT NOT NULL,    username VARCHAR(16) NOT NULL,    INDEX [indexname] (username(length));</code></pre><h2 id="唯一索引"><a href="#唯一索引" class="headerlink" title="唯一索引"></a>唯一索引</h2><p>索引列必须唯一，但可以为 NULL，不能有多个 NULL。</p><pre><code class="mysql">-- 单独创建CREATE UNIQUE INDEX indexname ON tablename(colname(length));-- 也可以在修改表的时候创建ALTER TABLE table_name ADD UNIQUE [index_name] (column_list)-- 创建表的时候指定CREATE TABLE mytable(    ID INT NOT NULL,    username VARCHAR(16) NOT NULL,    UNIQUE INDEX [indexname] (username(length));</code></pre><h2 id="主键索引"><a href="#主键索引" class="headerlink" title="主键索引"></a>主键索引</h2><p>就是之前所说过的主键。不能使用<code>CREATE</code>语句单独创建。</p><pre><code class="mysql">-- 可以在修改表的时候创建ALTER TABLE tablename ADD PRIMARY KEY (column_list);-- 在表级定义主键CREATE TABLE mytable(    ID INT NOT NULL,    username VARCHAR(16) NOT NULL,    PRIMARY KEY(ID));-- 在列级定义主键CREATE TABLE mytable(    ID INT NOT NULL PRIMARY KEY,    username VARCHAR(16) NOT NULL);</code></pre><p>由上可知，有两种主键定义方法。但是两者不尽相同。在列级定义主键<strong>这样是无法指定多个字段做主键的</strong>，这中情况下只能在表级定义主键</p><h3 id="索引组织表"><a href="#索引组织表" class="headerlink" title="索引组织表"></a>索引组织表</h3><p>InnoDB 引擎中，表都是根据主键顺序组织存放的。称之为<code>索引组织表</code>。<br>在没有显示地声明主键的情况下，InnoDB 按照如下方式选择或创建主键：</p><ul><li>如果存在<code>非空</code>的<code>唯一约束</code>，则将该列视为主键</li><li>如果不存在，则自动创建一个 6 字节大小的指针</li></ul><p>如果表中有多个非空的唯一索引，那么 InnoDB 选择第一个定义的非空索引。这里依据的顺序是索引定义的顺序，而不是建表时列的顺序。</p><h3 id="rowid"><a href="#rowid" class="headerlink" title="_rowid"></a>_rowid</h3><p>在主键为单个列的时候，我们可以使用_rowid 来查看主键的值。</p><pre><code class="mysql">-- 比如：SELECT *,_rowid FROM test;</code></pre><h2 id="全文索引"><a href="#全文索引" class="headerlink" title="全文索引"></a>全文索引</h2><p>只有 InnodB 引擎支持</p>]]></content>
      
      
      <categories>
          
          <category> DataBase </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>约束</title>
      <link href="blog/bhcyvg/"/>
      <url>blog/bhcyvg/</url>
      
        <content type="html"><![CDATA[<h2 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h2><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>根据列的数目分为：</p><ul><li>列级约束<ul><li>对一个数据列建立的约束，称为列级约束</li><li>NOT NULL 和 DEFAULT 只有列级约束</li><li>其他三个有表级约束</li></ul></li><li>表级约束<ul><li>对多个数据列建立的约束，称为表级约束</li></ul></li></ul><p>列级约束可以在列定义时声明，也可以在列定义后声明。<br>表级约束只能在列定义后声明。</p><p>根据功能分为：</p><table><thead><tr><th>代码</th><th>描述</th></tr></thead><tbody><tr><td>NOT NULL</td><td>非空约束</td></tr><tr><td>PRIMARY KEY</td><td>主键约束</td></tr><tr><td>UNIQUE</td><td>唯一约束</td></tr><tr><td>DEFAULT</td><td>默认约束</td></tr><tr><td>FOREGIN KEY</td><td>外键约束</td></tr></tbody></table><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ul><li>父表和子表具有相同的存储引擎（–InnoDB–）</li><li>外键列和参照列必须具有相似的数据类型<ul><li>其中数字的长度或是否有符号必须相同</li><li>字符的长度可以不同</li></ul></li><li>外键列和参照列必须创建 _索引_，如果外键列不存在索引，MySQL 会自动帮其创建，但是不会自动帮参照列创建</li></ul><blockquote><p>父表：具有参照列的是父表，比如省份与人中的省份。<br>子表：具有外键列的是子表，比如人</p></blockquote><h3 id="外键约束的参照操作"><a href="#外键约束的参照操作" class="headerlink" title="外键约束的参照操作"></a>外键约束的参照操作</h3><ul><li>CASEADE //更新（删除）父表（中的行），子表也随之更新</li><li>SET NULL</li><li>RESTRICT</li><li>NO ACTION //标准的 SQL 关键字，功能与 MySQL 中的 RESTRICT 相同。</li></ul>]]></content>
      
      
      <categories>
          
          <category> DataBase </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数据库操作</title>
      <link href="blog/afuf5u/"/>
      <url>blog/afuf5u/</url>
      
        <content type="html"><![CDATA[<h2 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h2><pre><code class="sql">CREATE &#123;DATABASE|SCHEMA&#125; [IF NOT EXISTS] db_name [DEFAULT] CHARCTER SET [=] charset_name;</code></pre><blockquote><p>注意设置字符集的时候，utf-8 要写作 utf8。</p></blockquote><h2 id="使用数据库"><a href="#使用数据库" class="headerlink" title="使用数据库"></a>使用数据库</h2><blockquote><p>使用指定数据库</p></blockquote><pre><code class="sql">use DATABASEgo</code></pre><h2 id="修改数据库"><a href="#修改数据库" class="headerlink" title="修改数据库"></a>修改数据库</h2><pre><code class="sql">ALTER &#123;DATABASE|SCHEMA&#125; db_name [DEFAUTL] CHARCTER SET [=] charset_name;</code></pre><h3 id="修改数据库编码格式"><a href="#修改数据库编码格式" class="headerlink" title="修改数据库编码格式"></a>修改数据库编码格式</h3><pre><code>SET NAMES GBK;</code></pre><p>GBK 也可以是其他编码格式。但这只是修改你客户端显示的编码格式。服务端并不变化。<br><strong>修改配置文件来改服务端编码</strong><br>打开/etc/my.cnf 文件<br>在[mysqld]条目下：增加</p><pre><code>character_set_server=utf8init_connect=&#39;SET NAMES utf8&#39;</code></pre><p>有时在数据库创建完成后，编码格式是无法修改的。只能删掉重新建。</p><h2 id="删除数据库"><a href="#删除数据库" class="headerlink" title="删除数据库"></a>删除数据库</h2><pre><code class="mysql">    DROP &#123;DATABASE|SCHEMA&#125; [IF EXISTS] db_name;</code></pre>]]></content>
      
      
      <categories>
          
          <category> DataBase </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>表查询操作</title>
      <link href="blog/igxqxi/"/>
      <url>blog/igxqxi/</url>
      
        <content type="html"><![CDATA[<h2 id="基本词汇"><a href="#基本词汇" class="headerlink" title="基本词汇"></a>基本词汇</h2><blockquote><p>查询就是 SELECT 语句</p></blockquote><pre><code class="sql">SELECT  [ ALL | DISTINCT ]        [ TOP expression [ PERCENT ] [ WITH TIES ] ]    &lt;列名&gt;                                             /*指定要选择的列及其限定*/    [ INTO &lt;表名&gt; ]                             /*INTO子句，指定结果存入新表*/    [ FROM &lt;查询对象&gt; ]                        /*FROM子句，指定表或视图*/    [ WHERE &lt;条件&gt; ]                             /*WHERE子句，指定查询条件*/    [ GROUP BY &lt;分组表达式&gt;]                 /*GROUP BY子句，指定分组表达式*/    [ HAVING &lt;分组统计条件&gt;]                 /*HAVING子句，指定分组统计条件*/    [ ORDER BY &lt;排序表达式&gt; [ ASC | DESC ] ] /*ORDER子句，指定排序表达式和顺序*/</code></pre><blockquote><p>说明：所有被使用的子句必须按语法说明中显示的顺序严格地排序。例如，一个 HAVING 子句必须位于 GROUP BY 子句之后，并位于 ORDER BY 子句之前。<br>SELECT 语句返回一个表的结果集，通常该结果集被称为表值表达式。</p></blockquote><h3 id="distinct"><a href="#distinct" class="headerlink" title="distinct"></a>distinct</h3><p>去掉重复的行</p><h3 id="where"><a href="#where" class="headerlink" title="where"></a>where</h3><blockquote><p>条件</p></blockquote><pre><code class="sql">select distinct Sname        from Student        where Sdept=&#39;CS&#39;</code></pre><h3 id="as"><a href="#as" class="headerlink" title="as"></a>as</h3><pre><code class="sql">SELECT id AS userId，username AS uname    FROM users;</code></pre><p>查询出来的列名，就变成了别名。AS 其实可以省略，但可能会出现问题。</p><pre><code class="sql">SELECT id username  FROM users;</code></pre><p>这样会将 username 视作 id 的别名。</p><h3 id="like"><a href="#like" class="headerlink" title="like"></a>like</h3><pre><code class="sql">SELECT 书名 AS BookName, 作译者 AS Author, 出版社 AS PressFROM TBookWHERE 书名 LIKE &#39;%SQL Server%&#39;</code></pre><pre><code class="sql">select Sname, Sno, Ssex    from Student    where Sname not like &#39;刘_&#39;</code></pre><h3 id="is-not"><a href="#is-not" class="headerlink" title="is not"></a>is not</h3><pre><code class="sql">select Sno, Cno    from SC    where Grade is not null</code></pre><h3 id="and、or"><a href="#and、or" class="headerlink" title="and、or"></a>and、or</h3><pre><code class="sql">select Sname, Ssex    from Student    where Sdept=&#39;CS&#39; or Sdept=&#39;MA&#39; or Sdept=&#39;IS&#39;</code></pre><blockquote><p>键可以不用引号，但是值要引号<br>列名又空格也需要加引号</p></blockquote><h3 id="top"><a href="#top" class="headerlink" title="top"></a>top</h3><blockquote><p>前五行数据</p></blockquote><pre><code class="sql">select top 5 *    from rating</code></pre><h3 id="not-in"><a href="#not-in" class="headerlink" title="not in"></a>not in</h3><pre><code class="sql">select Sname, Ssex    from Student    where Sdept not in (&#39;CS&#39;, &#39;MA&#39;, &#39;IS&#39;)</code></pre><h3 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h3><ul><li>有公共的列，在前面表名以示区分</li><li>指明两个表的公共<strong>相等</strong>的列</li></ul><pre><code class="sql">select TLend.ISBN, TLend.借书时间, TLend.借书证号, TLend.图书ID, TLend.应还时间,TReader.姓名from TReader,TLend, TBookwhere TReader.借书证号 = TLend.借书证号    and TBook.ISBN = TLend.ISBN    and TLend.借书证号 = &#39;081101&#39;    and TBook.书名 = &#39;SQL Server实用教程（第3版）&#39;</code></pre><h3 id="join-on"><a href="#join-on" class="headerlink" title="join on"></a>join on</h3><pre><code class="sql">select 姓名    from TReader join HLend    on TReader.借书证号 = HLend.借书证号    where (还书时间 - 借书时间)&gt;5</code></pre><h3 id="count"><a href="#count" class="headerlink" title="count"></a>count</h3><pre><code class="sql">select count(*) 读者总数    from TReader</code></pre><h3 id="order-by"><a href="#order-by" class="headerlink" title="order by"></a>order by</h3><p>排序 ORDER BY</p><pre><code class="sql">select Sno, Grade    from SC    where Cno=&#39;3&#39;    order by Grade desc</code></pre><pre><code class="sql">SELECT *        FROM users    ORDER BY id DESC;</code></pre><p>可以排序多个字段，如果第一个字段能排出结果，就不会用到第 2 个字段。比如：</p><pre><code class="sql">select *    from Student    order by Sdept asc, Sage desc</code></pre><p>因为年龄 age 有相同的，继续排序就要用到 id 的降序。</p><h3 id="limit"><a href="#limit" class="headerlink" title="limit"></a>limit</h3><p>限制返回记录的数量 LIMIT</p><p>LIMIT 有两种语法结构，第一种比较常见。</p><pre><code class="sql">[LIMIT &#123;[offset,] row_count|row_count OFFSET offset&#125;]</code></pre><p>起始位置，偏移量</p><pre><code class="sql">SELECT * FROM users ;SELECT * FROM users LIMIT 3,2;SELECT * FROM users LIMIT 2;</code></pre><p>3，2：表示从第 3 条开始返回，返回两条记录。注意记录从 0 开始编号，即结果集中的从第 0 条开始。<br>如果 LIMIT 后面只有一个参数，认作是偏移量，起始位置缺省为 0。</p><h3 id="union"><a href="#union" class="headerlink" title="union"></a>union</h3><blockquote><p>合并查询结果 UNION</p></blockquote><p>在多条查询语句之间，使用<code>UNION</code>关键字会合并所有查询结果。<br>默认会去掉重复行，如果不想去掉重复行，请使用<code>UNION ALL</code><br>需要注意的是，要联合的查询结果必须有相同的列数（列名可以不同）</p><blockquote><p>去重效率比不去重效率低</p></blockquote><h2 id="group-by"><a href="#group-by" class="headerlink" title="group by"></a>group by</h2><pre><code class="sql">[GROUP BY &#123;col_name|position&#125; [ASC|DESC],...]</code></pre><pre><code class="sql">select 专业, count(*) 不同专业人数    from TReader    group by 专业</code></pre><h3 id="having"><a href="#having" class="headerlink" title="having"></a>having</h3><p>与 GROUP BY 分组联用。只对部分记录做分组操作。有两种用法，比如：</p><pre><code class="sql">SELECT sex,age    FROM users  GROUP BY sex  HAVING age &gt; 35;SELECT sex    FROM users  GROUP BY sex  HAVING count(id) &gt;=2;</code></pre><ul><li>第一种，注意后面的 HAVING 的字段必须在前面 SELECT 部分出现才行。</li><li>第二种，在 HAVING 后面使用<em>聚合函数</em>，前面无需出现相应字段。</li></ul><h3 id="asc、desc"><a href="#asc、desc" class="headerlink" title="asc、desc"></a>asc、desc</h3><p>排序升序 asc、降序 desc</p><pre><code class="sql">SELECT *    FROM TReader    WHERE 专业=&#39;计算机&#39;    ORDER BY 出生时间 desc</code></pre><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h2><p>子查询（Subquery）是指嵌套在查询内部，且必须始终出现在圆括号内。外面的查询并非只是指的查找。可以包含的关键字或条件：</p><pre><code>DISTINCT、GROUP BY、ORDER BY、LIMIT、函数等</code></pre><p>外层的查询可以是：</p><pre><code>SELECT、INSERT、UPDATE、SET、DO</code></pre><h3 id="①-使用比较运算符的子查询"><a href="#①-使用比较运算符的子查询" class="headerlink" title="① 使用比较运算符的子查询"></a>① 使用比较运算符的子查询</h3><ul><li>比较运算符<blockquote><p>=,&gt;,&lt;,&gt;=,&lt;=,&lt;&gt;,!=,&lt;=&gt;</p></blockquote></li></ul><pre><code class="sql">SELECT *    FROM av  WHERE 身高&gt;=(    SELECT AVG(身高)    FROM av);</code></pre><ul><li>修饰比较运算符<blockquote><p>使用 ANY、SOME、ALL，ANY 和 SOME 是等价的。</p></blockquote></li></ul><table><thead><tr><th></th><th>ANY</th><th>ALL</th></tr></thead><tbody><tr><td>&gt;,&gt;=</td><td>最小值</td><td>最大值</td></tr><tr><td>&lt;,&lt;=</td><td>最大值</td><td>最小值</td></tr><tr><td>=,&lt;=&gt;</td><td>任意值</td><td></td></tr><tr><td>&lt;&gt;,!=</td><td></td><td>任意值</td></tr></tbody></table><pre><code class="sql">select emp.empno,emp.ename,emp.job,emp.sal    from scott.emp  where sal &gt;any(    select sal    from scott.emp    where job=&quot;MANAGER&quot;);</code></pre><p>等价于下边两步的执行过程：<br>（1）执行“select sal from scott.emp where job=”MANAGER””<br>（2）查询到 3 个薪水值 2975、2850 和 2450，父查询执行下列语句：<br>select emp.empno,emp.ename,emp.job,emp.sal from scott.emp where** sal &gt;2975 or sal&gt;2850 or sal&gt;2450;**</p><h3 id="②-使用-not-in-的子查询"><a href="#②-使用-not-in-的子查询" class="headerlink" title="② 使用[not]in 的子查询"></a>② 使用[not]in 的子查询</h3><pre><code>operand comparison_operator [NOT] IN (subquery)</code></pre><p>=ANY 和 IN 等效<br>!=ALL 和 NOT IN 等效</p><h3 id="③-使用-not-exists-的子查询"><a href="#③-使用-not-exists-的子查询" class="headerlink" title="③ 使用[not]exists 的子查询"></a>③ 使用[not]exists 的子查询</h3><p>如果子查询返回任何行，EXISTS 将返回 TRUE，否则返回 FALSE。<br>该类子查询使用较少</p>]]></content>
      
      
      <categories>
          
          <category> DataBase </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>表基本操作</title>
      <link href="blog/zqbaxc/"/>
      <url>blog/zqbaxc/</url>
      
        <content type="html"><![CDATA[<h1 id="表基本操作"><a href="#表基本操作" class="headerlink" title="表基本操作"></a>表基本操作</h1><h2 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h2><pre><code class="sql">Create table student(    Sno char(9),    Same char(20),    Ssex char(2),    Sage smallint,    Sdept char(20));Create table course(    Cno char(4),    Cname char(40),    Cpno char(4),    Ccredit smallint);Create table sc(    Sno char(9),    Cno char(4),    Grade smallint);Insert into student values(&#39;200215121&#39;,&#39;李勇&#39;,&#39;男&#39;,20,&#39;cs&#39;);Insert into student values(&#39;200215122&#39;,&#39;刘晨&#39;,&#39;女&#39;,19,&#39;cs&#39;);Insert into student values(&#39;200215123&#39;,&#39;王敏&#39;,&#39;女&#39;,18,&#39;ma&#39;);Insert into student values(&#39;200515124&#39;,&#39;张立&#39;,&#39;男&#39;,19,&#39;is&#39;);Insert into course values (&#39;1&#39;,&#39;数据库&#39;,&#39;5&#39;,4);Insert into course values (&#39;2&#39;,&#39;数学&#39;,NULL,2);Insert into course values(&#39;3&#39;,&#39;信息系统&#39;,&#39;1&#39;,4);Insert into course values(&#39;4&#39;,&#39;操作系统&#39;,&#39;6&#39;,3);Insert into course values(&#39;5&#39;,&#39;数据结构&#39;,&#39;7&#39;,4);Insert into course values(&#39;6&#39;,&#39;数据处理&#39;,NULL,2);Insert into course values(&#39;7&#39;,&#39;pascal语言&#39;,&#39;6&#39;,4);Insert into sc values(&#39;200215121&#39;,&#39;1&#39;,92);Insert into sc values(&#39;200215121&#39;,&#39;2&#39;,85);Insert into sc values(&#39;200215121&#39;,&#39;3&#39;,88);Insert into sc values(&#39;200215122&#39;,&#39;2&#39;,90);Insert into sc values(&#39;200215122&#39;,&#39;3&#39;,80);</code></pre><h2 id="查看表"><a href="#查看表" class="headerlink" title="查看表"></a>查看表</h2><pre><code class="sql">    SHOW TABLES [FROM db_name] [LIKE &#39;pattern&#39;|WHEAR expr];</code></pre><h2 id="查看列（表的组织结构）"><a href="#查看列（表的组织结构）" class="headerlink" title="查看列（表的组织结构）"></a>查看列（表的组织结构）</h2><pre><code class="sql">    SHOW COLUMNS FROM tb_name;    DESC tb_name;</code></pre><p>以上两条语句都可以。</p><h2 id="查看表的内容"><a href="#查看表的内容" class="headerlink" title="查看表的内容"></a>查看表的内容</h2><pre><code class="sql">    SELECT * FROM tb_name;</code></pre><h2 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h2><pre><code class="sql">    INSERT [INTO] tb_name [(col_name,...)] VALUES(val,...);</code></pre><p>如果不指明任何字段名，那么插入的数据必须要包含所有的字段。</p><h1 id="插入记录"><a href="#插入记录" class="headerlink" title="插入记录"></a>插入记录</h1><p>共有三种 Insert 语句。</p><h2 id="INSERT"><a href="#INSERT" class="headerlink" title="INSERT"></a>INSERT</h2><pre><code class="sql">INSERT [INTO] tb_name [(col_name,.....)] &#123;VALUE|VALUES&#125; (&#123;expr|DEFAULT&#125;,...) (...),...</code></pre><ul><li>values 是标准 SQL 关键字，value 是 MySQL 自己的。</li><li>插入语句可以一次性插入多条记录。</li><li>值可以是：<ul><li>函数</li><li>数学表达式</li><li>等</li></ul></li></ul><p>默认值</p><p>在创建数据表的时候可以设置 DEFAUTL。</p><pre><code class="sql">CREATE TABLE users(    id SAMLLINT UNSIGNED PRIMARY KEY AUTO_INCREMENT,    username SAMLLINT VARCHAR(20) NOT NULL,    password SAMLLINT VARCHAR(20) NOT NULL,    age TINYINT UNSIGNED NOT NULL DEFAULT 10,    sex BOOLEAN);</code></pre><p>INSERT 的时候如果为自动编号的字段（比如上表中主键 id）赋值的话，可写作 NULL，或 DEFAULT 就会采用默认值。<br>如果字段设置了 DEFAULT（比如上表中 age），那么值直接写 DEFAULT 就行，注意此时，不能为 NULL。例如：</p><pre><code class="sql">INSERT users VALUES(NULL,&#39;TOM&#39;,&#39;123&#39;,DEFAULT,1);</code></pre><h2 id="INSERT…SET"><a href="#INSERT…SET" class="headerlink" title="INSERT…SET"></a>INSERT…SET</h2><pre><code class="sql">INSERT [INTO] tb_name SET col_name=&#123;expr|DEFAULT&#125;,...</code></pre><p>采用了<a href="%E5%AD%90%E6%9F%A5%E8%AF%A2.md">子查询</a>。例如，上表中插入：</p><pre><code class="sql">INSERT users SET username=&#39;Ben&#39;,password=&#39;456&#39;;</code></pre><p>因为 id，和 age 都有默认值，所以可以不写。而 sex 允许为空，也可以不写。</p><h2 id="INSERT…SELECT"><a href="#INSERT…SELECT" class="headerlink" title="INSERT…SELECT*"></a>INSERT…SELECT*</h2><p>将查找的结果写入记录中。</p><pre><code class="sql">INSERT test(username) SELECT username FROM users WHERE age &gt;=30;</code></pre><h1 id="删除记录"><a href="#删除记录" class="headerlink" title="删除记录"></a>删除记录</h1><p>同样分为：</p><ul><li>单表删除</li><li>多表删除</li></ul><pre><code class="mysql">DELETE FROM tb_name [WHERE where_condition];</code></pre><p>没有 where 部分则会删除全部记录。</p><h1 id="更新记录-单表更新"><a href="#更新记录-单表更新" class="headerlink" title="更新记录-单表更新"></a>更新记录-单表更新</h1><p>更新记录分为：</p><ul><li>单表更新</li><li>多表更新（要涉及连接）</li></ul><blockquote><p>单表更新</p></blockquote><pre><code class="mysql">UPDATE [LOW_PRIORITY] [IGNORE] tb_referenceSET col_name1=&#123;expr|DEFAULT&#125; [,col_name2=&#123;expr|DEFAULT&#125;]...[WHERE where_condition]</code></pre><p>不写 where 会更新全部的记录。</p><h1 id="更新记录-连接（多表更新）"><a href="#更新记录-连接（多表更新）" class="headerlink" title="更新记录-连接（多表更新）"></a>更新记录-连接（多表更新）</h1><h2 id="多表更新"><a href="#多表更新" class="headerlink" title="多表更新"></a>多表更新</h2><pre><code class="mysql">UPDATE table_referencesSET col_name1=&#123;expr1|DEFAULT&#125;[,col_name2=&#123;expr2|DEFAULT&#125;]...[WHERE where_condition]</code></pre><h2 id="CREATE…SELECT"><a href="#CREATE…SELECT" class="headerlink" title="CREATE…SELECT"></a>CREATE…SELECT</h2><p>创建数据表同时将查询结果写入到数据表</p><pre><code class="mysql">CREATE TABLE [IF NOT EXISTS]tb_name[(create_definetion,...)]select_statement</code></pre><p>比如：</p><pre><code class="mysql">CREATE TABLE tall (    tall_id SMALLINT UNSIGNED PRIMARY KEY AUTO_INCREMENT,    num INT) SELECT 身高 AS num FROM    avGROUP BY 身高;</code></pre><p>创建新表 tall，并从 av 表中选取身高字段插入到 tall 表的 num 字段。</p><h2 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h2><h3 id="语法结构"><a href="#语法结构" class="headerlink" title="语法结构"></a>语法结构</h3><pre><code class="mysql">table_reference&#123;[INNER|CROSS] JOIN|&#123;LELT|RIGHT&#125;[OUTER] JOIN&#125;table_referenceON conditional_expr</code></pre><p>ON 为条件。<br>三种连接，即：</p><ul><li>内连接</li><li>左外连接</li><li>右外连接</li></ul><h4 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h4><p>显示左表及右表符合连接条件的记录（交集）</p><h4 id="左外连接"><a href="#左外连接" class="headerlink" title="左外连接"></a>左外连接</h4><p>显示左表的全部记录及右表符合连接条件的记录</p><h4 id="右外连接"><a href="#右外连接" class="headerlink" title="右外连接"></a>右外连接</h4><p>类别左外连接</p><h3 id="UPDATE-JOIN-SET"><a href="#UPDATE-JOIN-SET" class="headerlink" title="UPDATE..JOIN..SET"></a>UPDATE..JOIN..SET</h3><p>比如</p><pre><code class="mysql">UPDATE actor AS a        INNER JOIN    tall AS b ON a.tall = b.numSET    a.tall = b.tall_id;</code></pre><p>依据实际情况，选择是否使用别名。（如果两个表中进行比较的字段名相同，则需要别名）<br>该语句完成了一个替换，将 actor 表中具体的身高数值，替换为 tall 表中身高的对应 id。</p><h1 id="修改数据表"><a href="#修改数据表" class="headerlink" title="修改数据表"></a>修改数据表</h1><p>所有的数据表的修改 SQL 语句的开头都是 ALTER TABLE+表名称。</p><h2 id="给表改名"><a href="#给表改名" class="headerlink" title="给表改名"></a>给表改名</h2><pre><code class="sql">ALTER TABLE tb_name RENAME &#123;TO|AS&#125; tb_new_name;</code></pre><p>另外有个写法是：</p><pre><code class="sql">RENAME TABLE tb_name TO tb_new_name;</code></pre><p>这句可以批量修改多个表的名称。</p><blockquote><p>尽量不要随意修改表的名称。对视图有影响。</p></blockquote><h2 id="添加-删除列"><a href="#添加-删除列" class="headerlink" title="添加/删除列"></a>添加/删除列</h2><h3 id="插入列"><a href="#插入列" class="headerlink" title="插入列"></a>插入列</h3><pre><code class="sql">ALTER TABLE tb_name ADD [COLUMN] col_name column_definition [FIRST|AFTER col_name];</code></pre><p>默认会插入到表的最下面，指定 FIRST，则置于最上面，或者用<code>AFTER col_name</code> 指定为<code>col_name</code>的下面。</p><h3 id="删除列"><a href="#删除列" class="headerlink" title="删除列"></a>删除列</h3><pre><code class="sql">ALTER TABLE tb_name DROP col_name,DROP.....;</code></pre><p>可以一次性删除多个列。</p><h2 id="修改列"><a href="#修改列" class="headerlink" title="修改列"></a>修改列</h2><h3 id="修改列定义"><a href="#修改列定义" class="headerlink" title="修改列定义"></a>修改列定义</h3><p>即修改列的属性。</p><pre><code class="sql">ALTER TABLE tb_name MODIFY col_name column_definition [FIRST|AFTER col_name];</code></pre><p>比如：</p><pre><code class="sql">ALTER TABLE test ADD id SMALLINT unsigned KEY auto_increment first;</code></pre><p>key 可以表示主键，无需 primary。fitrst 表示插入的位置。</p><blockquote><p>如果要修改的列已经是<code>主键</code>了，则修改列定义的时候再加上<code>主键</code>字段会报错。</p></blockquote><h3 id="修改列名"><a href="#修改列名" class="headerlink" title="修改列名"></a>修改列名</h3><pre><code class="sql">ALTER TABLE tb_name CHANGE col_name col_new_name column_definition [FIRST|AFTER col_name];</code></pre><p>修改列名时，新列名后面要指明数据类型。</p><h3 id="修改列顺序"><a href="#修改列顺序" class="headerlink" title="修改列顺序"></a>修改列顺序</h3><p>其实同上，具体比如：</p><pre><code class="sql">ALTER TABLE `user` CHANGE `join_time` `join_time` DATE NULL DEFAULT NULL AFTER `role`;</code></pre><p>把 join_time 列放到 role 列后面。</p><h2 id="修改约束"><a href="#修改约束" class="headerlink" title="修改约束"></a>修改约束</h2><h3 id="PRIMARY-KEY"><a href="#PRIMARY-KEY" class="headerlink" title="PRIMARY KEY"></a>PRIMARY KEY</h3><p>添加主键约束</p><pre><code class="sql">ALTER TABLE tb_name ADD [CONSTRAIN[symbol]] PRIMARY KEY [index.type] (index_col_name,.....);</code></pre><p>删除主键约束</p><pre><code class="sql">ALTER TABLE tb_name DROP [index.type] PRIMARY KEY;</code></pre><p>不需要指定列名，因为每个表只有一个主键。<br>注意！只有一个主键并不意味着主键只有一列。</p><h3 id="UNIQUE"><a href="#UNIQUE" class="headerlink" title="UNIQUE"></a>UNIQUE</h3><p>添加唯一约束</p><pre><code class="sql">ALTER TABLE tb_name ADD [index.type] unique(col_name);</code></pre><p>删除唯一约束</p><pre><code class="sql">ALTER TABLE tb_name DROP [index.type] unique(col_name);</code></pre><h3 id="DEFAULT"><a href="#DEFAULT" class="headerlink" title="DEFAULT"></a>DEFAULT</h3><pre><code class="sql">ALTER TABLE tb_name ALTER [COLUMN] col_name &#123;SET DEFAULT literal|DROP DEFAULT&#125;;for example:ALTER TABLE users ALTER age SET DEFAULT 20;</code></pre><h3 id="FOREIGN-KEY"><a href="#FOREIGN-KEY" class="headerlink" title="FOREIGN KEY"></a>FOREIGN KEY</h3><p>添加外键约束</p><pre><code class="sql">ALTER TABLE tb_name ADD [CONSTRAIN[symbol]] FOREIGN KEY [index_name](index_col_name,...)reference_definition;for example:ALTER TABLE users add FOREIGN KEY (pid) REFERENCE provinces (id);</code></pre><p>删除外键约束</p><pre><code class="sql">ALTER TABLE tb_name DROP FOREIGN KEY fk_symbol;</code></pre>]]></content>
      
      
      <categories>
          
          <category> DataBase </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>0-1背包问题</title>
      <link href="blog/kb5sse/"/>
      <url>blog/kb5sse/</url>
      
        <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><h3 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h3><p>给定一组已知重量和价值的物品和一个容量已知的背包，求解在不超过背包容量情况下，选用那些物品放入背包，使得所选用的所有物品价值最大化。</p><table><thead><tr><th>物品总数 N</th><th>4</th></tr></thead><tbody><tr><td>背包容量 M</td><td>8</td></tr><tr><td>每个物品重量 wi</td><td>{5, 4, 3, 2}</td></tr><tr><td>每个物品价值 vi</td><td>{15, 10, 6, 2}</td></tr></tbody></table><h3 id="问题的判定性说法"><a href="#问题的判定性说法" class="headerlink" title="问题的判定性说法"></a>问题的判定性说法</h3><h3 id=""><a href="#" class="headerlink" title=""></a><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1600597489691-e0d838af-003e-404e-8a40-5145d2fefbad.png#align=left&display=inline&height=108&margin=%5Bobject%20Object%5D&name=image.png&originHeight=216&originWidth=969&size=73465&status=done&style=shadow&width=484.5" alt="image.png"></h3><h3 id="问题的形式化定义"><a href="#问题的形式化定义" class="headerlink" title="问题的形式化定义"></a>问题的形式化定义</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1600597354257-45eba2b3-641c-433a-8732-9b6c11a16061.png#align=left&display=inline&height=281&margin=%5Bobject%20Object%5D&name=image.png&originHeight=561&originWidth=1065&size=184609&status=done&style=shadow&width=532.5" alt="image.png"></p><h2 id="问题思路"><a href="#问题思路" class="headerlink" title="问题思路"></a>问题思路</h2><h3 id="动态规划思路"><a href="#动态规划思路" class="headerlink" title="动态规划思路"></a>动态规划思路</h3><p><strong>动态规划</strong>解决该问题，类似于<strong>莱文斯坦距离</strong>的解法类似。利用 CAAIS 数据来说明这个问题的解决思想。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1603943092299-49a0bc97-f2cf-4258-8dde-022b4aae06d1.png#align=left&display=inline&height=154&margin=%5Bobject%20Object%5D&name=image.png&originHeight=307&originWidth=842&size=44700&status=done&style=shadow&width=421" alt="image.png"><br><strong>动态规划 DP 方程构造</strong><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1603943375703-889cea96-f3a0-41df-b806-386dca8bcc82.png#align=left&display=inline&height=112&margin=%5Bobject%20Object%5D&name=image.png&originHeight=223&originWidth=1020&size=23862&status=done&style=shadow&width=510" alt="image.png"><br><strong>PS：V[i,j]表示在前 i 件物品中选择若干件放在承重为 j 的背包中，可以取得的最大价值</strong></p><p>（整张表格是从上往下，从左往右地填）<br>举例说明表格中的数值填法，<strong>倒数第二行倒数第四列的 16 4</strong>的填法：</p><ul><li>首先不满足 DP 方程的第一种和第二种情况</li><li>所以代入取最大值 max 函数<ul><li>V（i-1，j）：不选本物品（3，6），还是用之前的值，继承上面的第一个物品和第二个物品，DP 值为 15 U</li><li>V（i-1，j）+vi：用该容量（7）-所选物品的重量为 4，然后再查容量为 4 的时候 DP 值为 10，然后求出该情况 DP 是，10 加上该物品的价值，所以该情况下的 DP 值为 16，右上标为 4（CAAIS），值来源于前面容量为 4 的情况。</li></ul></li></ul><hr><p><strong>格子如上方式填就好了！</strong></p><h3 id="递归思路"><a href="#递归思路" class="headerlink" title="递归思路"></a>递归思路</h3><p>第二节课将递归的时候，也讲了这个问题的递归思路。不过复杂度记得是指数级的，暂时不写了~~</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="动态规划-Code"><a href="#动态规划-Code" class="headerlink" title="动态规划 Code"></a>动态规划 Code</h3><pre><code class="cpp">#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;namespace NS_DP0_1Knapsack &#123;int DP0_1Knapsack(int n, int W, int *w, int *v);void Output(int n, int W, int *w, int *v, int OptV);static vector&lt;vector&lt;int&gt;&gt; V;static vector&lt;int&gt; x;void DP0_1KnapsackCaller(int n, int W, int *w, int *v)&#123;    V.clear();    V.resize(n + 1, vector&lt;int&gt;(W + 1, 0));    x.resize(n + 1);    int OptV = DP0_1Knapsack(n, W, w, v);    Output(n, W, w, v, OptV);&#125;int DP0_1Knapsack(int n, int W, int *w, int *v)&#123;    for (int i = 1; i &lt;= n; i++)        for (int j = 1; j &lt;= W; j++)            if (j &lt; w[i - 1])                V[i][j] = V[i - 1][j];            else if (V[i - 1][j] &gt;=                V[i - 1][j - w[i - 1]] + v[i - 1])                V[i][j] = V[i - 1][j];            else                V[i][j] = V[i - 1][j - w[i - 1]] + v[i - 1];    int j = W;    for (int i = n; i &gt; 0; i--)        if (V[i][j] == V[i - 1][j])            x[i] = 0;        else        &#123;   x[i] = 1; j -= w[i - 1];  &#125;    return V[n][W];&#125;void Output(int n, int W, int *w, int *v, int OptV)&#123;    //inputs    printf(&quot;DP to solve 0-1 knapsack:\n&quot;);    printf(&quot;%d items with knapsack capacity %d.\n&quot;, n , W);    printf(&quot;%-6s: &quot;, &quot;Weight&quot;);    for (int i = 0; i &lt; n; i++)        printf(&quot;%3d&quot;, w[i]);    printf(&quot;\n&quot;);    printf(&quot;%-6s: &quot;, &quot;Value&quot;);    for (int i = 0; i &lt; n; i++)        printf(&quot;%3d&quot;, v[i]);    printf(&quot;\n&quot;);    //the value matrix    printf(&quot;\nThe value matrix:\n&quot;);    printf(&quot;  &quot;);    for (int j = 0; j &lt;= W; j++)        printf(&quot;%3d&quot;, j);    printf(&quot;\n&quot;);    for (int i = 0; i &lt;= n; i++)    &#123;        printf(&quot;%2d&quot;, i);        for (int j = 0; j &lt;= W; j++)            printf(&quot;%3d&quot;, V[i][j]);        printf(&quot;\n&quot;);    &#125;    //solution    printf(&quot;\nThe optimal value: %d\n&quot;, OptV);    printf(&quot;The optimal solution:\n&quot;);    for (int i = 1; i &lt;= n; i++)        printf(&quot;%2d&quot;, x[i]);    printf(&quot;\n\n&quot;);&#125;&#125; //namespace NS_DP0_1Knapsackusing namespace NS_DP0_1Knapsack;int main()&#123;    // 物品个数    vector&lt;int&gt; N = &#123; 4,  10&#125;;    // 背包容量    vector&lt;int&gt; W = &#123; 8,  100&#125;;    // 各物品重量    vector&lt;vector&lt;int&gt;&gt; w = &#123;        &#123; 5, 4, 3, 2 &#125;,        &#123; 4, 3, 7, 2, 9, 3, 1, 7, 2, 5 &#125;    &#125;;    // 各物品价值    vector&lt;vector&lt;int&gt;&gt; v = &#123;        &#123; 15, 10, 6, 2 &#125;,        &#123; 15, 10, 6, 2, 23, 12, 33, 7, 22, 10 &#125;    &#125;;    int m = N.size();    for (int i = 0; i &lt; m; i++)    &#123;        DP0_1KnapsackCaller(N[i], W[i], &amp;w[i][0], &amp;v[i][0]);    &#125;    return 0;&#125;</code></pre><h3 id="动态规划-Result"><a href="#动态规划-Result" class="headerlink" title="动态规划 Result"></a>动态规划 Result</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1603943258085-fac4811f-87e7-4eef-8194-ee47d88063a6.png#align=left&display=inline&height=379&margin=%5Bobject%20Object%5D&name=image.png&originHeight=757&originWidth=1920&size=74181&status=done&style=shadow&width=960" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1603943276039-f6f74edf-4871-426d-8af8-e1a62edaf071.png#align=left&display=inline&height=276&margin=%5Bobject%20Object%5D&name=image.png&originHeight=552&originWidth=1920&size=66929&status=done&style=shadow&width=960" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1603943291836-84a15101-d6e7-4c9f-91b5-1122afd7ac5c.png#align=left&display=inline&height=177&margin=%5Bobject%20Object%5D&name=image.png&originHeight=353&originWidth=1920&size=29292&status=done&style=shadow&width=960" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
          <category> 动态规划算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>TSP问题</title>
      <link href="blog/bkbll1/"/>
      <url>blog/bkbll1/</url>
      
        <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>假设有 n 个城市，各个城市与城市间的距离也已知，有一位旅行商需要途径所有的这 n 个城市，且每个城市只能且必须经过以此，求出一条路线，使得旅行商所走过的路程最短</p><h2 id="问题思路"><a href="#问题思路" class="headerlink" title="问题思路"></a>问题思路</h2><h2 id="代码思路"><a href="#代码思路" class="headerlink" title="代码思路"></a>代码思路</h2><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://jerkwin.github.io/2016/03/17/%E6%97%85%E8%A1%8C%E6%8E%A8%E9%94%80%E5%95%86%E9%97%AE%E9%A2%98TSP%E7%9A%84%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E8%A7%A3%E6%B3%95/">旅行推销商问题 TSP 的动态规划解法</a></li><li><a href="https://blog.csdn.net/joekwok/article/details/4749713">TSP(旅行者问题)——动态规划详解</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
          <category> 动态规划算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>全排列问题</title>
      <link href="blog/kgaymi/"/>
      <url>blog/kgaymi/</url>
      
        <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>给定 n 个有序元素的集合，列出其可能出现的排列。</p><h2 id="问题思路"><a href="#问题思路" class="headerlink" title="问题思路"></a>问题思路</h2><h2 id="代码思路"><a href="#代码思路" class="headerlink" title="代码思路"></a>代码思路</h2><ul><li>利用动态数组数据结构</li></ul><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><pre><code class="java">package com.wztlink1013.al._递归法_;import java.util.ArrayList;/** * 全排列问题 * */public class Permuting &#123;    static ArrayList&lt;Integer&gt; x  = new ArrayList&lt;Integer&gt;();    static int N;    static int cnt = 0;    static int t;    public static void main(String args[]) &#123;        int n = 10;        Times.test(&quot;当n = &quot; + n + &quot;时候的耗费时间&quot;, new Times.Task() &#123;            public void execute() &#123;                PermutingCaller(n);            &#125;        &#125;);    &#125;    private static void PermutingCaller(int n) &#123;        N = n;        for (int i = 0; i &lt; n; ++i)            x.add(i + 1);        Permuting(0);    &#125;    private static void Permuting(int i) &#123;        if (i &lt; N - 1) &#123;            for (int j = i; j &lt; N; j++) &#123;                t = x.get(i);                x.set(i, x.get(j));                x.set(j, t);                Permuting(i + 1);                t = x.get(i);                x.set(i, x.get(j));                x.set(j, t);            &#125;        &#125;        else            OutputOnePermutation();    &#125;    private static void OutputOnePermutation()    &#123;        System.out.print(++cnt + &quot; : &quot;);        for (int x : x)            System.out.print(x + &quot; &quot;);        System.out.println();    &#125;&#125;</code></pre><blockquote><p>n:10</p></blockquote><blockquote><p>n</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
          <category> 递归算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>线性搜索</title>
      <link href="blog/ete0k7/"/>
      <url>blog/ete0k7/</url>
      
        <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1599481660030-a834223b-30e4-4a9e-a290-243f028112f2.png#align=left&display=inline&height=325&margin=%5Bobject%20Object%5D&name=image.png&originHeight=650&originWidth=1040&size=166464&status=done&style=shadow&width=520" alt="image.png"></p><h2 id="问题思路"><a href="#问题思路" class="headerlink" title="问题思路"></a>问题思路</h2><h2 id="代码思路"><a href="#代码思路" class="headerlink" title="代码思路"></a>代码思路</h2><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
          <category> 穷举算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>穷举算法+百元买百兔、素性测试、洗牌问题</title>
      <link href="blog/czgm7d/"/>
      <url>blog/czgm7d/</url>
      
        <content type="html"><![CDATA[<h2 id="穷举思想"><a href="#穷举思想" class="headerlink" title="穷举思想"></a>穷举思想</h2><p>穷举法就是针对问题可能出现的结果，对其逐个进行测验并得出是否为符合要求的结果，穷举法也是许多高级算法中的某个部分。<strong>有点像高中数学里面的对问题进行分类讨论</strong>的过程中，寻找所有的情况的异曲同工之处。</p><h3 id="两部分组成"><a href="#两部分组成" class="headerlink" title="两部分组成"></a>两部分组成</h3><ol><li>系统化地枚举问题各种可能的候选解</li><li>检查验证每一个候选解是否满足问题的求解要求</li></ol><h3 id="穷举的抽象算法伪代码"><a href="#穷举的抽象算法伪代码" class="headerlink" title="穷举的抽象算法伪代码"></a>穷举的抽象算法伪代码</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1599469820927-b990d8a2-9025-4f33-becb-46a03890bf07.png#align=left&display=inline&height=323&margin=%5Bobject%20Object%5D&name=image.png&originHeight=645&originWidth=1097&size=223732&status=done&style=stroke&width=548.5" alt="image.png"></p><h2 id="百元买百兔问题"><a href="#百元买百兔问题" class="headerlink" title="百元买百兔问题"></a>百元买百兔问题</h2><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1621393290050-0aa37db7-c08b-407b-8088-c4ede29b80b5.png#align=left&display=inline&height=392&margin=%5Bobject%20Object%5D&name=image.png&originHeight=784&originWidth=1119&size=232684&status=done&style=stroke&width=559.5" alt="image.png"></p><h2 id="洗牌问题"><a href="#洗牌问题" class="headerlink" title="洗牌问题"></a>洗牌问题</h2><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1599475674143-ee86ef49-1b68-4940-baef-e556f225e43d.png#align=left&display=inline&height=297&margin=%5Bobject%20Object%5D&name=image.png&originHeight=594&originWidth=1056&size=159618&status=done&style=stroke&width=528" alt="image.png"></p><h3 id="问题思路"><a href="#问题思路" class="headerlink" title="问题思路"></a>问题思路</h3><ul><li>在 1~n-1 当中随机选择一个数 k1，将其与第 n 个数互换；</li><li>在 1~n-2 当中随机选择一个属 k2，将其与第 n-1 个数互换；</li><li>在第 i 轮之后，1~n-**(i-1)<strong>当中选择一个数 ki，将其与第 n-</strong>(i-1)**个数互换；</li></ul><h3 id="代码思路"><a href="#代码思路" class="headerlink" title="代码思路"></a>代码思路</h3><ul><li>在区间之间随机数的生成</li><li>交换函数</li><li>泛型：支持各种类型数据的“洗牌”</li></ul>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
          <category> 穷举算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>递归算法+子集问题</title>
      <link href="blog/mz8hpp/"/>
      <url>blog/mz8hpp/</url>
      
        <content type="html"><![CDATA[<h2 id="一、递归"><a href="#一、递归" class="headerlink" title="一、递归"></a>一、递归</h2><h3 id="算法特点"><a href="#算法特点" class="headerlink" title="算法特点"></a>算法特点</h3><p>适用于递归解决的问题通常有两个特点：</p><ol><li>递归性：能将规模为 n 的问题简化为 n-1 的问题，并且规模为 n 的问题和规模为 n-1 的问题性质一样</li><li>可终结性：不能无限递归下去，小到一定程度能够得出结果</li></ol><blockquote><p>eg：前 n 个自然数的和、n 个数之和这两个问题就可以用递归来解决</p></blockquote><h3 id="递归和迭代"><a href="#递归和迭代" class="headerlink" title="递归和迭代"></a>递归和迭代</h3><p>递归问题也可以用迭代方式来解决（循环），这过程中，有一些普遍的特点就是：</p><ol><li>递归问题有较好的直觉性</li><li>迭代运行过程中调用太多的栈空间，因而运行效率相对优于递归</li></ol><h2 id="二、问题描述"><a href="#二、问题描述" class="headerlink" title="二、问题描述"></a>二、问题描述</h2><p>给定一个正整数 n，生成集合 {1,2,3,…n} 的所有子集</p><h2 id="三、问题思路"><a href="#三、问题思路" class="headerlink" title="三、问题思路"></a>三、问题思路</h2><blockquote><p>思路一：二进制法</p></blockquote><p>利用<strong>二进制</strong>“<strong>是否显现”</strong>的转换思路来解决这个问题，一个数字在子集当中就标记为 1 反之标记为 0，就比如 <code>n=3</code> ，输出： <code>&#123;&#125;&#123;1,0,0&#125;&#123;0,1,0&#125;&#123;0,0,1&#125;&#123;1,1,0&#125;&#123;1,0,1&#125;&#123;0,1,1&#125;&#123;1,1,1&#125;</code></p><h2 id="四、代码思路"><a href="#四、代码思路" class="headerlink" title="四、代码思路"></a>四、代码思路</h2><blockquote><p>思路一：利用动态数组数据结构</p></blockquote><p>输入的 n 就是动态数组的初始大小<br>然后依次利用“吞进来”和“吐出去”尾元素来实现</p><h2 id="五、代码实现"><a href="#五、代码实现" class="headerlink" title="五、代码实现"></a>五、代码实现</h2><pre><code class="java">package com.wztlink1013.al._递归法_;/* * 作用：测量代码运行时间 */import java.text.SimpleDateFormat;import java.util.Date;public class Times &#123;    private static final SimpleDateFormat fmt = new SimpleDateFormat(&quot;HH:mm:ss.SSS&quot;);    public interface Task &#123;        void execute();    &#125;    public static void test(String title, Task task) &#123;        if (task == null) return;        title = (title == null) ? &quot;&quot; : (&quot;【&quot; + title + &quot;】&quot;);        System.out.println(title);        System.out.println(&quot;开始：&quot; + fmt.format(new Date()));        long begin = System.currentTimeMillis();        task.execute();        long end = System.currentTimeMillis();        System.out.println(&quot;结束：&quot; + fmt.format(new Date()));        double delta = (end - begin) / 1000.0;        System.out.println(&quot;耗时：&quot; + delta + &quot;秒&quot;);        System.out.println(&quot;-------------------------------------&quot;);    &#125;&#125;</code></pre><pre><code class="java">package com.wztlink1013.al._递归法_;import java.util.ArrayList;/** * 子集问题 */public class SubSetting &#123;    static ArrayList&lt;Integer&gt; x  = new ArrayList&lt;Integer&gt;();    static int cnt = 0;    public static void main(String args[]) &#123;        int n = 4;        Times.test(&quot;当n = &quot; + n + &quot;时候的耗费时间&quot;, new Times.Task() &#123;            public void execute() &#123;                Subsetting(n);            &#125;        &#125;);    &#125;    private static void Subsetting(int n) &#123;        if (n &gt; 0) &#123;            x.add(0);            Subsetting(n - 1);            x.remove(x.size() - 1);            x.add(1);            Subsetting(n - 1);            x.remove(x.size() - 1);        &#125;else &#123;            OutputOneSubsetBinary();            OutputOneSubset();            System.out.print(&quot;\n&quot;);        &#125;    &#125;    private static void OutputOneSubset() &#123;        System.out.printf(&quot;; &#123;&quot;);        int k = 0;        for (int i = x.size() - 1; i &gt;=0; i--) &#123;            if (x.get(i) == 1) &#123;                if (k &gt; 0)                    System.out.printf(&quot;,&quot;);                System.out.printf(&quot;%d&quot;, x.size() - i);                k++;            &#125;        &#125;        System.out.printf(&quot;&#125;&quot;);    &#125;    private static void OutputOneSubsetBinary() &#123;        System.out.printf(&quot;%010d: &quot;, ++cnt);        for (int i = x.size() - 1; i &gt;= 0; i--)            System.out.printf(&quot;%d&quot;, x.get(i));    &#125;&#125;</code></pre><p>运行结果：</p><blockquote><p>n：18（分钟）</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1600319992252-d49865a4-9a9d-4c65-88c8-ea72f140bf85.png#align=left&display=inline&height=219&margin=%5Bobject%20Object%5D&name=image.png&originHeight=438&originWidth=1920&size=146634&status=done&style=none&width=960" alt="image.png"></p><blockquote><p>n：19（分钟）</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1600320121635-ea76638e-a4c2-4686-a017-0d97088dc417.png#align=left&display=inline&height=190&margin=%5Bobject%20Object%5D&name=image.png&originHeight=380&originWidth=1920&size=140804&status=done&style=none&width=960" alt="image.png"></p><blockquote><p>n：20（分钟）</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1600320284010-b885d1eb-01da-40d9-a098-f5d84744d847.png#align=left&display=inline&height=196&margin=%5Bobject%20Object%5D&name=image.png&originHeight=392&originWidth=1920&size=144176&status=done&style=none&width=960" alt="image.png"></p><blockquote><p>n：21（分钟）</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1600320620721-cf61057d-1eac-48d3-b724-36d0d21c4d1e.png#align=left&display=inline&height=160&margin=%5Bobject%20Object%5D&name=image.png&originHeight=319&originWidth=1920&size=129722&status=done&style=none&width=960" alt="image.png"></p><blockquote><p>n：22（分钟）</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1600321218265-60888e51-2006-4dd7-bbe0-60b336895b8c.png#align=left&display=inline&height=173&margin=%5Bobject%20Object%5D&name=image.png&originHeight=345&originWidth=1920&size=131717&status=done&style=none&width=960" alt="image.png"></p><blockquote><p>n：23（分钟）</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1600329834700-9cb11fdc-fec8-463d-934a-b140b45cc0ae.png#align=left&display=inline&height=193&margin=%5Bobject%20Object%5D&name=image.png&originHeight=386&originWidth=1920&size=146130&status=done&style=none&width=960" alt="image.png"></p><blockquote><p>网上查的代码！</p></blockquote><pre><code class="java">class Main&#123;    static void printSubsets(String[] set)    &#123;        int n = set.length;        for (int i = 0; i &lt; (1&lt;&lt;n); i++)        &#123;            System.out.print(&quot;&#123; &quot;);            for (int j = 0; j &lt; n; j++)                if ((i &amp; (1 &lt;&lt; j)) &gt; 0)                    System.out.print(set[j] + &quot; &quot;);            System.out.println(&quot;&#125;&quot;);        &#125;    &#125;    public static void main(String[] args)    &#123;        String[] set = &#123;&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;,                        &quot;5&quot;, &quot;6&quot;, &quot;7&quot;, &quot;8&quot;&#125;;        printSubsets(set);    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
          <category> 递归算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JAVA-常用类</title>
      <link href="blog/rnsz9o/"/>
      <url>blog/rnsz9o/</url>
      
        <content type="html"><![CDATA[<h2 id="java-util-Date"><a href="#java-util-Date" class="headerlink" title="java.util.Date"></a>java.util.Date</h2><pre><code class="java">java.util.Date date = new java.util.Date();System.out.println(date.toString());</code></pre><pre><code>Sun Mar 09 13:50:19 EST 2020</code></pre><h2 id="java-util-Random"><a href="#java-util-Random" class="headerlink" title="java.util.Random"></a>java.util.Random</h2><blockquote><p>Math.Random()：Math 类里面的随机数函数，范围是 0.0 到 0.1</p></blockquote><blockquote><p>java.util.Random</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1600085762621-35c72adc-6c6e-4ab2-ac8b-d76d50e570e5.png#align=left&display=inline&height=176&margin=%5Bobject%20Object%5D&name=image.png&originHeight=352&originWidth=899&size=45653&status=done&style=shadow&width=449.5" alt="image.png"></p><h2 id="javafx-geometry-Point2D"><a href="#javafx-geometry-Point2D" class="headerlink" title="javafx.geometry.Point2D"></a>javafx.geometry.Point2D</h2><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1600086091697-6fa8f4e4-137d-490a-8fe0-3546693a1f86.png#align=left&display=inline&height=103&margin=%5Bobject%20Object%5D&name=image.png&originHeight=206&originWidth=960&size=115357&status=done&style=shadow&width=480" alt="image.png"></p><pre><code class="java">import java.util.Scanner;import javafx.geometry.Point2D;public class TestPoint2D &#123;public static void main(String[] args)&#123;    Scanner input= new Scanner(System.in);    System.out.println(&quot;Enter point1&#39;s x-,y-coordinates:&quot;);    double x1=input.nextDouble();    double y1=input.nextDouble();    System.out.println(&quot;Enter point2&#39;s x-,y-coordinates:&quot;);    double x2=input.nextDouble();    double y2=input.nextDouble();    Point2D p1 =new Point2D(x1,y1);    Point2D p2 =new Point2D(x2,y2);    System.out.println(&quot;p1 is&quot;+p1.toString());    System.out.println(&quot;p2 is&quot;+p2.toString());    System.out.println(&quot;distance is&quot;+p1.distance(p2));    &#125;&#125;</code></pre><pre><code>Enter point1&#39;s x-,y-coordinates:1 2Enter point2&#39;s x-,y-coordinates:3 4p1 isPoint2D [x = 1.0, y = 2.0]p2 isPoint2D [x = 3.0, y = 4.0]distance is2.8284271247461903</code></pre><h2 id="String-和-StringBuilder-和-StringBuffer"><a href="#String-和-StringBuilder-和-StringBuffer" class="headerlink" title="String 和 StringBuilder 和 StringBuffer"></a>String 和 StringBuilder 和 StringBuffer</h2><h2 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h2><h3 id="toString-方法"><a href="#toString-方法" class="headerlink" title="toString()方法"></a>toString()方法</h3><h3 id="equals-方法"><a href="#equals-方法" class="headerlink" title="equals()方法"></a>equals()方法</h3><blockquote><p>默认实现的方法</p></blockquote><pre><code class="java">public boolean equals(Object obj) &#123;    return (this == obj);&#125;</code></pre><blockquote><p>重写例子</p></blockquote><pre><code class="java">public boolean equals(Object obj) &#123;    if (o instanceof Circe)        return radius == ((Circle)o).radius;    else        return this == o;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Language </category>
          
          <category> JAVA </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>P206.反转链表</title>
      <link href="blog/ipiwza/"/>
      <url>blog/ipiwza/</url>
      
        <content type="html"><![CDATA[<pre><code class="java">/** * public class ListNode &#123; *     int val; *     ListNode next; *     ListNode(int x) &#123; val = x; &#125; * &#125; */</code></pre><h2 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206. 反转链表"></a>206. 反转链表</h2><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1603193588776-6539785f-f52d-494b-b7a1-2bc6cebf1e60.png#align=left&display=inline&height=136&margin=%5Bobject%20Object%5D&name=image.png&originHeight=271&originWidth=725&size=20430&status=done&style=shadow&width=362.5" alt="image.png"></p><h3 id="问题思路"><a href="#问题思路" class="headerlink" title="问题思路"></a>问题思路</h3><ol><li><strong>利用外部空间：</strong>将所给链表存到 ArryList 里面或者是新的链表里面，然后再反转动态数组就可以了。</li><li><strong>快慢指针</strong>：</li><li><strong>递归解法</strong>：</li></ol><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p><strong>递归实现</strong></p><pre><code class="java">// 避免陷入死循环if (head == null || head.next == null) return head;ListNode newHead = reverseList(head.next); //此处递归，找到最后一个节点了head.next.next = head; //重新指定节点指向（有两个next，注意少写）head.next = null; //将最初的节点指向空return newHead; //返回新的“倒置”头节点</code></pre><p><strong>快慢指针</strong></p><pre><code class="java">class Solution &#123;    public ListNode reverseList(ListNode head) &#123;        // 避免陷入死循环        if (head == null || head.next == null) return head;        ListNode newHead = null;        while (head != null)&#123;            ListNode tmp = head.next;            head.next = newHead;            newHead = head;            head = tmp;        &#125;        return newHead;    &#125;&#125;</code></pre><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
      
      
      <categories>
          
          <category> DataStructure </category>
          
          <category> Problems </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>算法复杂度</title>
      <link href="blog/veggl2/"/>
      <url>blog/veggl2/</url>
      
        <content type="html"><![CDATA[<p>这是加密文章！</p>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
          <category> 算法综述 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>算法分析与设计课程综述</title>
      <link href="blog/eq2l1v/"/>
      <url>blog/eq2l1v/</url>
      
        <content type="html"><![CDATA[<div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">算法分析与设计两门课程的学习笔记</div><h2 id="形式化定义"><a href="#形式化定义" class="headerlink" title="形式化定义"></a>形式化定义</h2><p>对于一个问题，将其进行科学的分析研究，就需要对其进行更加严谨的形式化定义，其形式就类似于数学建模过程中的构建出<strong>数学模型</strong>一样，对其进行问题的抽象化提取，以及合理的公式化，就比如“0-1 背包”问题中：<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1600597354257-45eba2b3-641c-433a-8732-9b6c11a16061.png#align=left&display=inline&height=281&id=FfSoK&margin=%5Bobject%20Object%5D&name=image.png&originHeight=561&originWidth=1065&size=184609&status=done&style=shadow&width=532.5" alt="image.png"></p><h2 id="判定性问题"><a href="#判定性问题" class="headerlink" title="判定性问题"></a>判定性问题</h2><p>类似于数学建模当中<strong>模型的求解</strong>，在给定模型以及约束条件的情况下求出符合该约束条件下的模型解：<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1600597489691-e0d838af-003e-404e-8a40-5145d2fefbad.png#align=left&display=inline&height=108&id=ZMrl3&margin=%5Bobject%20Object%5D&name=image.png&originHeight=216&originWidth=969&size=73465&status=done&style=shadow&width=484.5" alt="image.png"></p><h2 id="例子：Euclid-GCD-问题"><a href="#例子：Euclid-GCD-问题" class="headerlink" title="例子：Euclid-GCD 问题"></a>例子：Euclid-GCD 问题</h2><p>问题描述<br>将每个整数分解为素因子的积，找出公共的素因子，它们的积即是 GCD<br>问题思路<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1599360897754-ab7b7684-5565-471b-aece-1725b39196bb.png#align=left&display=inline&height=296&id=zBWoT&margin=%5Bobject%20Object%5D&name=image.png&originHeight=848&originWidth=1131&size=231186&status=done&style=shadow&width=395" alt="image.png"><br>代码实现</p><pre><code class="java">package com.wztlink1013.al.EuclidGCD;import java.util.Scanner;public class Main &#123;    public static void main(String args[])&#123;        Scanner input = new Scanner(System.in);        System.out.println(&quot;请输入两个大于零的自然数：&quot;);        int a = input.nextInt();        int b = input.nextInt();        GCD(a,b);        System.out.println(a + &quot;和&quot; + b + &quot;两个数的GCD值为：&quot; + GCD(a,b));    &#125;    public static int GCD(int i, int j)&#123;        int r;        while (j != 0)&#123;            r = i%j;            i = j;            j = r;            System.out.println(&quot;a=&quot;+i+&quot;；b=&quot;+j+&quot;；r=&quot;+r);        &#125;        return i;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
          <category> 算法综述 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>P486. 预测赢家</title>
      <link href="blog/srvbwz/"/>
      <url>blog/srvbwz/</url>
      
        <content type="html"><![CDATA[<h3 id="486-预测赢家"><a href="#486-预测赢家" class="headerlink" title="486. 预测赢家"></a>486. 预测赢家</h3><pre><code class="java">class Solution &#123;    public boolean PredictTheWinner(int[] nums) &#123;        return total(nums, 0, nums.length - 1, 1) &gt;= 0;    &#125;    public int total(int[] nums, int start, int end, int turn) &#123;        if (start == end) &#123;            return nums[start] * turn;        &#125;        int scoreStart = nums[start] * turn + total(nums, start + 1, end, -turn);        int scoreEnd = nums[end] * turn + total(nums, start, end - 1, -turn);        return Math.max(scoreStart * turn, scoreEnd * turn) * turn;//        if(turn == 1)&#123;//            return Math.max(scoreStart ,scoreEnd );//        &#125;else&#123;//            return Math.min(scoreStart ,scoreEnd );//        &#125;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
          <category> Problems </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>P1. P18.两/四数之和</title>
      <link href="blog/dq9vp6/"/>
      <url>blog/dq9vp6/</url>
      
        <content type="html"><![CDATA[<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a>1. 两数之和</h3><pre><code class="java">class Solution &#123;    public int[] twoSum(int[] nums, int target) &#123;        for (int i = 0; i &lt; nums.length; i++) &#123;            for (int j = i + 1; j &lt; nums.length; j++) &#123;                if (nums[j] == target - nums[i]) &#123;                    return new int[] &#123; i, j &#125;;                &#125;            &#125;        &#125;        throw new IllegalArgumentException(&quot;No two sum solution&quot;);    &#125;&#125;</code></pre><h3 id="18-四数之和"><a href="#18-四数之和" class="headerlink" title="18. 四数之和"></a>18. 四数之和</h3><pre><code class="java">class Solution &#123;    public List&lt;List&lt;Integer&gt;&gt; fourSum(int[] nums, int target) &#123;        List&lt;List&lt;Integer&gt;&gt; result = new LinkedList&lt;&gt;();        int a = 0;        int b = 1;        int c = 2;        int d = 3;        for (int i=nums[a];i&lt;nums.length;++a)&#123;            for (int j=nums[b];j&lt;nums.length;++b)&#123;                for (int k=nums[c];k&lt;nums.length;++c)&#123;                    for (int l=nums[d];l&lt;nums.length;++d)&#123;                        if (i+j+k+l == target)&#123;                            result.add(new LinkedList&lt;&gt;(Arrays.asList(i, j, k, l)));                        &#125;break;                    &#125;                &#125;            &#125;        &#125;        return result;    &#125;&#125;</code></pre><h3 id=""><a href="#" class="headerlink" title=""></a></h3>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
          <category> Problems </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JAVA-泛型</title>
      <link href="blog/ef1q5c/"/>
      <url>blog/ef1q5c/</url>
      
        <content type="html"><![CDATA[<p>类似 C++里面的模板</p><ul><li>定义的时候就是直接在后面加上<E>，比如： <code>public class ArrayList&lt;E&gt;</code></li><li>使用就是 <code>private E[] array</code> ;</li></ul><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="-1"><a href="#-1" class="headerlink" title=""></a></h2>]]></content>
      
      
      <categories>
          
          <category> Language </category>
          
          <category> JAVA </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JAVA动态数组设计</title>
      <link href="blog/bx5ouf/"/>
      <url>blog/bx5ouf/</url>
      
        <content type="html"><![CDATA[<h3 id="接口设计"><a href="#接口设计" class="headerlink" title="接口设计"></a>接口设计</h3><pre><code class="java">public int size(); // 返回动态数组元素个数public boolean isEmpty(); // 是否为空public boolean contains(E element); // 是否包含某个元素public void add(E element); // 在数组尾部添加元素public E get(int index); // 返回index位置对应的元素public E set(int index, E element); // 设置/更换index位置上的值public void add (int index, E element); // 在index位置上添加元素public E remove(int index); // 移除index位置上的值public int indexOf(E element); // 查看元素的位置public void clear(); // 清空动态数组所有元素</code></pre><h3 id="private-设计"><a href="#private-设计" class="headerlink" title="private 设计"></a>private 设计</h3><pre><code class="java">// 元素的数量private int size;// 所有的元素private E[] elements;private static final int DEFAULT_CAPACITY = 10;private static final int ELEMENT_NOT_FOUND = -1;/**     * 保证要有capacity的容量     * @param capacity     */private void ensureCapacity(int capacity) &#123;    int oldCapacity = elements.length;    if (oldCapacity &gt;= capacity) return;    // 新容量为旧容量的1.5倍    int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);    E[] newElements = (E[]) new Object[newCapacity];    for (int i = 0; i &lt; size; i++) &#123;        newElements[i] = elements[i];    &#125;    elements = newElements;    System.out.println(oldCapacity + &quot;扩容为&quot; + newCapacity);&#125;private void outOfBounds(int index) &#123;    throw new IndexOutOfBoundsException(&quot;Index:&quot; + index + &quot;, Size:&quot; + size);&#125;private void rangeCheck(int index) &#123;    if (index &lt; 0 || index &gt;= size) &#123;        outOfBounds(index);    &#125;&#125;private void rangeCheckForAdd(int index) &#123;    if (index &lt; 0 || index &gt; size) &#123;        outOfBounds(index);    &#125;&#125;</code></pre><h3 id="构造函数设计"><a href="#构造函数设计" class="headerlink" title="构造函数设计"></a>构造函数设计</h3><pre><code class="java">public ArrayList(int capaticy) &#123;    capaticy = (capaticy &lt; DEFAULT_CAPACITY) ? DEFAULT_CAPACITY : capaticy;    elements = (E[]) new Object[capaticy];&#125;public ArrayList() &#123;    this(DEFAULT_CAPACITY);&#125;</code></pre><h3 id="重写输出"><a href="#重写输出" class="headerlink" title="重写输出"></a>重写输出</h3><pre><code class="java">@Overridepublic String toString() &#123;    // size=3, [99, 88, 77]    StringBuilder string = new StringBuilder();    string.append(&quot;size=&quot;).append(size).append(&quot;, [&quot;);    for (int i = 0; i &lt; size; i++) &#123;        if (i != 0) &#123;            string.append(&quot;, &quot;);        &#125;        string.append(elements[i]);        //            if (i != size - 1) &#123;        //                string.append(&quot;, &quot;);        //            &#125;    &#125;    string.append(&quot;]&quot;);    return string.toString();&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> DataStructure </category>
          
          <category> 线结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JAVA链表设计</title>
      <link href="blog/nkn2os/"/>
      <url>blog/nkn2os/</url>
      
        <content type="html"><![CDATA[<h2 id="LinkedList-和-ArrayList-的设计"><a href="#LinkedList-和-ArrayList-的设计" class="headerlink" title="LinkedList 和 ArrayList 的设计"></a>LinkedList 和 ArrayList 的设计</h2><blockquote><p>同时设计 LinkedList 和 ArrayList</p></blockquote><ul><li><strong>LinkedList</strong>不需要构造函数</li><li><strong>ArrayList</strong>需要，后者需要一个容量的初始化。</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1603191040309-0ed4b536-89c0-449d-85cc-e763afcb73ea.png#align=left&display=inline&height=300&margin=%5Bobject%20Object%5D&name=image.png&originHeight=600&originWidth=557&size=89515&status=done&style=stroke&width=278.5" alt="image.png"></p><h3 id="接口-List-设计"><a href="#接口-List-设计" class="headerlink" title="接口 List 设计"></a>接口 List 设计</h3><blockquote><p>只用来<strong>声明对外接口</strong>，不能声明</p></blockquote><pre><code class="java">package com.wztlink1013.ds.linkedlist;/** * fun：实现ArrayList和LinkedList的接口 * */public interface List&lt;E&gt; &#123;    static final int ELEMENT_NOT_FOUND = -1;    /**     * 元素的数量[抽象类中实现]     * @return     */    int size();    /**     * 是否为空[抽象类中实现]     * @return     */    boolean isEmpty();    /**     * 是否包含某个元素[抽象类中实现]     * @param element     * @return     */    boolean contains(E element);    /**     * 添加元素到尾部[抽象类中实现]     * @param element     */    void add(E element);    /**     * 清除所有元素[实现类中实现]     */    void clear();    /**     * 获取index位置的元素[实现类中实现]     * @param index     * @return     */    E get(int index);    /**     * 设置index位置的元素[实现类中实现]     * @param index     * @param element     * @return 原来的元素ֵ     */    E set(int index, E element);    /**     * 在index位置插入一个元素[实现类中实现]     * @param index     * @param element     */    void add(int index, E element);    /**     * 删除index位置的元素[实现类中实现]     * @param index     * @return     */    E remove(int index);    /**     * 查看元素的索引[实现类中实现]     * @param element     * @return     */    int indexOf(E element);&#125;</code></pre><h3 id="抽象类-AbstractList-设计"><a href="#抽象类-AbstractList-设计" class="headerlink" title="抽象类 AbstractList 设计"></a>抽象类 AbstractList 设计</h3><blockquote><p>放 ArrayList 和 LinkedList 的公共代码</p><ul><li><strong>实现 List 接口类</strong>的共同代码</li><li>ArrayList 和 LinkedList 都用得到但是不对外公开的代码</li></ul><p>声明抽象类 abstract，就意味着可以不用全部实现接口 List 里面的所有方法</p></blockquote><pre><code class="java">package com.wztlink1013.ds.linkedlist;/** * fun：放ArrayList和LinkedList公共代码的抽象类（父类） * */public abstract class AbstractList&lt;E&gt; implements List&lt;E&gt; &#123;    protected int size;    /**     * 元素的数量     * @return     */    public int size() &#123;        return size;    &#125;    /**     * 是否为空     * @return     */    public boolean isEmpty() &#123;        return size == 0;    &#125;    /**     * 是否包含某个元素     * @param element     * @return     */    public boolean contains(E element) &#123;        return indexOf(element) != ELEMENT_NOT_FOUND;    &#125;    /**     * 添加元素到尾部     * @param element     */    public void add(E element) &#123;        add(size, element);    &#125;    /**     * 下面三个是ArrayList和LinkedList两个实现类中的公共代码     * */    protected void outOfBounds(int index) &#123;        throw new IndexOutOfBoundsException(&quot;Index:&quot; + index + &quot;, Size:&quot; + size);    &#125;    protected void rangeCheck(int index) &#123;        if (index &lt; 0 || index &gt;= size) &#123;            outOfBounds(index);        &#125;    &#125;    protected void rangeCheckForAdd(int index) &#123;        if (index &lt; 0 || index &gt; size) &#123;            outOfBounds(index);        &#125;    &#125;&#125;</code></pre><h3 id="ArrayList-设计"><a href="#ArrayList-设计" class="headerlink" title="ArrayList 设计"></a>ArrayList 设计</h3><pre><code class="java">package com.wztlink1013.ds.linkedlist;/** *fun：实现动态数组 */@SuppressWarnings(&quot;unchecked&quot;)public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; &#123;    private E[] elements;    private static final int DEFAULT_CAPACITY = 10;    public ArrayList(int capaticy) &#123;        capaticy = (capaticy &lt; DEFAULT_CAPACITY) ? DEFAULT_CAPACITY : capaticy;        elements = (E[]) new Object[capaticy];    &#125;    public ArrayList() &#123;        this(DEFAULT_CAPACITY);    &#125;    @Override    public void clear() &#123;        for (int i = 0; i &lt; size; i++) &#123;            elements[i] = null;        &#125;        size = 0;    &#125;    @Override    public E get(int index) &#123;        rangeCheck(index);        return elements[index];    &#125;    @Override    public E set(int index, E element) &#123;        rangeCheck(index);        E old = elements[index];        elements[index] = element;        return old;    &#125;    @Override    public void add(int index, E element) &#123;        rangeCheckForAdd(index);        ensureCapacity(size + 1);        for (int i = size; i &gt; index; i--) &#123;            elements[i] = elements[i - 1];        &#125;        elements[index] = element;        size++;    &#125;    @Override    public E remove(int index) &#123;        rangeCheck(index);        E old = elements[index];        for (int i = index + 1; i &lt; size; i++) &#123;            elements[i - 1] = elements[i];        &#125;        elements[--size] = null;        return old;    &#125;    @Override    public int indexOf(E element) &#123;        if (element == null) &#123;  // 1            for (int i = 0; i &lt; size; i++) &#123;                if (elements[i] == null) return i;            &#125;        &#125; else &#123;            for (int i = 0; i &lt; size; i++) &#123;                if (element.equals(elements[i])) return i; // n            &#125;        &#125;        return ELEMENT_NOT_FOUND;    &#125;    /**     * 保证要有capacity的容量     * @param capacity     */    private void ensureCapacity(int capacity) &#123;        int oldCapacity = elements.length;        if (oldCapacity &gt;= capacity) return;        // 新容量为旧容量的1.5倍        int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);        E[] newElements = (E[]) new Object[newCapacity];        for (int i = 0; i &lt; size; i++) &#123;            newElements[i] = elements[i];        &#125;        elements = newElements;        System.out.println(oldCapacity + &quot;扩容为&quot; + newCapacity);    &#125;    @Override    public String toString() &#123;        // size=3, [99, 88, 77]        StringBuilder string = new StringBuilder();        string.append(&quot;size=&quot;).append(size).append(&quot;, [&quot;);        for (int i = 0; i &lt; size; i++) &#123;            if (i != 0) &#123;                string.append(&quot;, &quot;);            &#125;            string.append(elements[i]);        &#125;        string.append(&quot;]&quot;);        return string.toString();    &#125;    /**     * 新添加功能     */    public int search(E element)&#123;        for (int i = 0;i&lt;size;i++)&#123;            if (element == elements[i])&#123;                return i;            &#125;        &#125;        return ELEMENT_NOT_FOUND;    &#125;&#125;</code></pre><h3 id="LinkedList-设计"><a href="#LinkedList-设计" class="headerlink" title="LinkedList 设计"></a>LinkedList 设计</h3><pre><code class="java">package com.wztlink1013.ds.linkedlist;/** *fun：链表的实现 */@SuppressWarnings(&quot;unchecked&quot;)public class LinkedList&lt;E&gt; extends AbstractList&lt;E&gt; &#123;    private Node&lt;E&gt; first;    private Node&lt;E&gt; last;    private static class Node&lt;E&gt; &#123;        E element;        Node&lt;E&gt; prev;        Node&lt;E&gt; next;        public Node(E element, Node&lt;E&gt; next) &#123;            this.element = element;            this.next = next;        &#125;    &#125;    @Override    public void clear() &#123;        size = 0;        first = null;        last = null;    &#125;    @Override    public E get(int index) &#123;        return node(index).element;    &#125;    @Override    public E set(int index, E element) &#123;        Node&lt;E&gt; node = node(index);        E old = node.element;        node.element = element;        return old;    &#125;    @Override    public void add(int index, E element) &#123;        if (index == 0)&#123;            first = new Node&lt;&gt;(element, first);        &#125; else &#123;            Node&lt;E&gt; prev = node(index - 1);            prev.next = new Node&lt;&gt;(element, prev.next);        &#125;        size++;    &#125;    @Override    public E remove(int index) &#123;//        Node&lt;E&gt; node = first;//        if (index == 0) &#123;//            first = first.next;//        &#125; else &#123;//            Node&lt;E&gt; prev = node(index -1);//            node = prev.next;//            prev.next = node.next;//        &#125;        rangeCheck(index);        Node&lt;E&gt; node = node(index);        Node&lt;E&gt; prev = node.prev;        Node&lt;E&gt; next = node.next;        if (prev == null) &#123; // index == 0            first = next;        &#125; else &#123;            prev.next = next;        &#125;        if (next == null) &#123; // index == size - 1            last = prev;        &#125; else &#123;            next.prev = prev;        &#125;        size--;        return node.element;    &#125;    @Override    public int indexOf(E element) &#123;        if (element == null) &#123;            Node&lt;E&gt; node = first;            for (int i = 0; i &lt; size; i++) &#123;                if (node.element == null) return i;                node = node.next;            &#125;        &#125; else &#123;            Node&lt;E&gt; node = first;            for (int i = 0; i &lt; size; i++) &#123;                if (element.equals(node.element)) return i;                node = node.next;            &#125;        &#125;        return ELEMENT_NOT_FOUND;    &#125;    /**     * 获取index位置对应的节点对象     * @param index     * @return     */    private Node&lt;E&gt; node(int index) &#123;        rangeCheck(index);        if (index &lt; (size &gt;&gt; 1)) &#123;            Node&lt;E&gt; node = first;            for (int i = 0; i &lt; index; i++) &#123;                node = node.next;            &#125;            return node;        &#125; else &#123;            Node&lt;E&gt; node = last;            for (int i = size - 1; i &gt; index; i--) &#123;                node = node.prev;            &#125;            return node;        &#125;    &#125;    @Override    public String toString() &#123;        StringBuilder string = new StringBuilder();        string.append(&quot;size=&quot;).append(size).append(&quot;, [&quot;);        Node&lt;E&gt; node = first;        for (int i = 0; i &lt; size; i++) &#123;            if (i != 0) &#123;                string.append(&quot;, &quot;);            &#125;            string.append(node);            node = node.next;        &#125;        string.append(&quot;]&quot;);        return string.toString();    &#125;&#125;</code></pre><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
      
      
      <categories>
          
          <category> DataStructure </category>
          
          <category> 线结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>对谷歌BERT模型的思考</title>
      <link href="blog/mssoff/"/>
      <url>blog/mssoff/</url>
      
        <content type="html"><![CDATA[<h2 id="why？"><a href="#why？" class="headerlink" title="why？"></a>why？</h2><blockquote><p>BERT 可以用来干什么？</p></blockquote><p>处理这种非结构化的数据以及之前学习到的情感分析</p><p>BERT 可以用于问答系统，情感分析，垃圾邮件过滤，命名实体识别，文档聚类等任务中，作为这些任务的基础设施即语言模型，</p><h2 id="what？"><a href="#what？" class="headerlink" title="what？"></a>what？</h2><p>是一个自然语言处理模型<br>提出了“训练词向量”概念，这是独特之处</p><p><strong>BERT 利用了 Transformer 的 encoder 部分。</strong><br><strong>BERT 的创新点在于它将双向 Transformer 用于语言模型，</strong><br>之前的模型是从左向右输入一个文本序列，或者将 left-to-right 和 right-to-left 的训练结合起来。实验的结果表明，双向训练的语言模型对语境的理解会比单向的语言模型更深刻，Transformer 是一种注意力机制，可以学习文本中单词之间的上下文关系的。Transformer 的原型包括两个独立的机制，一个 encoder 负责接收文本作为输入，一个 decoder 负责预测任务的结果。BERT 的目标是生成语言模型，所以只需要 encoder 机制。Transformer 的 encoder 是一次性读取整个文本序列，而不是从左到右或从右到左地按顺序读取，这个特征使得模型能够基于单词的两侧学习，相当于是一个双向的功能。 Transformer 的 encoder 部分，输入是一个 token 序列，先对其进行 embedding 称为向量，然后输入给神经网络，输出是大小为 H 的向量序列，每个向量对应着具有相同索引的 token。当我们在训练语言模型时，有一个挑战就是要定义一个预测目标，很多模型在一个序列中预测下一个单词，“The child came home from ___”双向的方法在这样的任务中是有限制的，为了克服这个问题，BERT 使用两个策略:</p><h3 id="Masked-LM-MLM"><a href="#Masked-LM-MLM" class="headerlink" title="Masked LM (MLM)"></a>Masked LM (MLM)</h3><p>论文中介绍了一种新技术叫做 Masked LM（MLM），在这个技术出现之前是无法进行双向语言模型训练的。在将单词序列输入给 BERT 之前，每个序列中有 15％ 的单词被 [MASK] token 替换。 然后模型尝试基于序列中其他未被 mask 的单词的上下文来预测被掩盖的原单词。</p><p>这样就需要：</p><ul><li><input checked="" disabled="" type="checkbox"> 在 encoder 的输出上添加一个分类层</li><li><input checked="" disabled="" type="checkbox"> 用嵌入矩阵乘以输出向量，将其转换为词汇的维度</li><li><input checked="" disabled="" type="checkbox"> 用 softmax 计算词汇表中每个单词的概率</li></ul><p>BERT 的损失函数只考虑了 mask 的预测值，忽略了没有掩蔽的字的预测。这样的话，模型要比单向模型收敛得慢，不过结果的情境意识增加了。</p><p><strong>eg：my dog is hairy</strong></p><ul><li>有 80%的概率用“[mask]”标记来替换——my dog is [MASK]</li><li>有 10%的概率用随机采样的一个单词来替换——my dog is apple</li><li>有 10%的概率不做替换——my dog is hairy</li></ul><h3 id="Next-Sentence-Prediction-NSP"><a href="#Next-Sentence-Prediction-NSP" class="headerlink" title="Next Sentence Prediction (NSP)"></a>Next Sentence Prediction (NSP)</h3><p>在 BERT 的训练过程中，模型接收成对的句子作为输入，并且预测其中第二个句子是否在原始文档中也是后续句子。在训练期间，50％ 的输入对在原始文档中是前后关系，另外 50％ 中是从语料库中随机组成的，并且是与第一句断开的。为了帮助模型区分开训练中的两个句子，输入在进入模型之前要按以下方式进行处理：</p><ul><li><input checked="" disabled="" type="checkbox"> 在第一个句子的开头插入 [CLS] 标记，在每个句子的末尾插入 [SEP] 标记。</li><li><input checked="" disabled="" type="checkbox"> 将表示句子 A 或句子 B 的一个句子 embedding 添加到每个 token 上。</li><li><input checked="" disabled="" type="checkbox"> 给每个 token 添加一个位置 embedding，来表示它在序列中的位置。</li><li><input checked="" disabled="" type="checkbox"> 为了预测第二个句子是否是第一个句子的后续句子，用下面几个步骤来预测：</li><li><input checked="" disabled="" type="checkbox"> 整个输入序列输入给 Transformer 模型</li><li><input checked="" disabled="" type="checkbox"> 用一个简单的分类层将 [CLS] 标记的输出变换为 2×1 形状的向量</li><li><input checked="" disabled="" type="checkbox"> 用 softmax 计算 IsNextSequence 的概率</li></ul><p>在训练 BERT 模型时，Masked LM 和 Next Sentence Prediction 是一起训练的，目标就是要最小化两种策略的组合损失函数。</p><h2 id="how？"><a href="#how？" class="headerlink" title="how？"></a>how？</h2><p>BERT 可以用于各种 NLP 任务，只需在核心模型中添加一个层.<br>例如：</p><ul><li><input checked="" disabled="" type="checkbox"> 在分类任务中，例如情感分析等，只需要在 Transformer 的输出之上加一个分类层</li><li><input checked="" disabled="" type="checkbox"> 在问答任务（例如 SQUAD v1.1）中，问答系统需要接收有关文本序列的 question，并且需要在序列中标记 answer。 可以使用 BERT 学习两个标记 answer 开始和结尾的向量来训练 Q＆A 模型。</li><li><input checked="" disabled="" type="checkbox"> 在命名实体识别（NER）中，系统需要接收文本序列，标记文本中的各种类型的实体（人员，组织，日期等）。 可以用 BERT 将每个 token 的输出向量送到预测 NER 标签的分类层。</li></ul>]]></content>
      
      
      <categories>
          
          <category> MachingLearning </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>银行家算法</title>
      <link href="blog/kc645t/"/>
      <url>blog/kc645t/</url>
      
        <content type="html"><![CDATA[<h2 id="一、银行家算法"><a href="#一、银行家算法" class="headerlink" title="一、银行家算法"></a>一、银行家算法</h2><p><strong>功能：避免死锁</strong></p><blockquote><p>在银行中，客户申请贷款的数量是有限的，每个客户在第一次申请贷款时要声明完成该项目所需的最大资金量，在满足所有贷款要求时，客户应及时归还。银行家在客户申请的贷款数量不超过自己拥有的最大值时，都应尽量满足客户的需要。在这样的描述中，银行家就好比操作系统，资金就是资源，客户就相当于要申请资源的进程。</p></blockquote><h2 id="二、代码实现"><a href="#二、代码实现" class="headerlink" title="二、代码实现"></a>二、代码实现</h2><pre><code class="cpp">#include &lt;iostream&gt;using namespace std;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;/* 定义全局变量 */const int    x = 50, y = 50;                                 /* x为进程个数 y为资源种类数 */int        Available[y];                                   /* 各资源可利用的数量 */int        Allocation[x][y];                               /* 各进程当前已分配的资源数量 */int        Max[x][y];                                      /* 各进程对各类资源的最大需求数 */int        Need[x][y];                                     /* 尚需多少资源 */int        Request[y];                                     /* 申请多少资源 */int        Work[y];                                        /* 工作向量，表示系统可提供给进程继续运行所需的各类资源数量 */int        Finish[x];                                      /* 表示系统是否有足够的资源分配给进程，1为是 */int        p[x];                                           /* 存储安全序列 */int        i, j;                                           /* i表示进程，j表示资源 */int        n, m;                                           /* n为进程i的数量,m为资源j种类数 */int        l    = 0;                                    /* l用来记录有几个进程是Finish[i]=1的，当l=n是说明系统状态是安全的 */int        counter = 0;                                    /* 记数器,记录可执行的进程数 *//* 函数声明 */void chushihua();                                               /* 初始化函数 */void safe();                                                    /* 安全性算法 */void show();                                                    /* 函数show,输出当前状态 */void bank();                                                    /* 银行家算法 */void jieshu();                                                  /* 结束函数 */void chushihua()&#123;    cout &lt;&lt; &quot;输入进程的数量: &quot;;                                    /* 从此开始输入有关数据 */    cin &gt;&gt; n;    cout &lt;&lt; &quot;输入资源种类数: &quot;;    cin &gt;&gt; m;    cout &lt;&lt; endl &lt;&lt; &quot;输入各种资源当前可用的数量( &quot; &lt;&lt; m &lt;&lt; &quot; 种): &quot; &lt;&lt; endl;    for ( j = 0; j &lt; m; j++ )                               /* m为资源数 */    &#123;        cout &lt;&lt; &quot;输入资源 &quot; &lt;&lt; j &lt;&lt; &quot; 可利用的数量Available[&quot; &lt;&lt; j &lt;&lt; &quot;]: &quot;;        cin &gt;&gt; Available[j];                            /* 输入数字的过程 */        Work[j] = Available[j];                         /* 初始化Work[j]，它的初始值就是当前可用的资源数 */    &#125;    cout &lt;&lt; endl &lt;&lt; &quot;输入各进程当前已分配的资源数量Allocation[&quot; &lt;&lt; n &lt;&lt; &quot;][&quot; &lt;&lt; m &lt;&lt; &quot;]: &quot; &lt;&lt; endl;    for ( i = 0; i &lt; n; i++ )                               /* n为进程数 */    &#123;        for ( j = 0; j &lt; m; j++ )                       /* m为资源数 */        &#123;            cout &lt;&lt; &quot; 输入进程 &quot; &lt;&lt; i &lt;&lt; &quot; 当前已分配的资源 &quot; &lt;&lt; j &lt;&lt; &quot; 数量: &quot;;            cin &gt;&gt; Allocation[i][j];        &#125;        cout &lt;&lt; endl;        Finish[i] = 0;                                  /* 初始化Finish[i] */    &#125;    cout &lt;&lt; endl &lt;&lt; &quot;输入各进程对各类资源的最大需求Max[&quot; &lt;&lt; n &lt;&lt; &quot;][&quot; &lt;&lt; m &lt;&lt; &quot;]: &quot; &lt;&lt; endl;    for ( i = 0; i &lt; n; i++ )                               /* n为进程数 */    &#123;        for ( j = 0; j &lt; m; j++ )                       /* m为资源数 */        &#123;            cout &lt;&lt; &quot; 输入进程 &quot; &lt;&lt; i &lt;&lt; &quot; 对资源 &quot; &lt;&lt; j &lt;&lt; &quot; 的最大需求数: &quot;;            cin &gt;&gt; Max[i][j];            if ( Max[i][j] &gt;= Allocation[i][j] )    /* 若最大需求大于已分配，则计算需求量 */                Need[i][j] = Max[i][j] - Allocation[i][j];            else                Need[i][j] = 0;                 /* Max小于已分配的时候，此类资源已足够不需再申请 */        &#125;        cout &lt;&lt; endl;    &#125;    cout &lt;&lt; endl &lt;&lt; &quot;初始化完成&quot; &lt;&lt; endl;&#125;/* 安全性算法函数 */void safe()&#123;    l = 0;                                                                  /* l用来记录有几个进程是Finish[i]=1的，当l=n是说明系统状态是安全的 */    for ( i = 0; i &lt; n; i++ )                                               /* n为进程数 */    &#123;        if ( Finish[i] == 0 )        &#123;                                                               /* 逐个查找Finish[i]==0的进程 条件一 */            counter = 0;                                            /* 记数器,记录有多少个进程已经执行 */            for ( j = 0; j &lt; m; j++ )                               /* m为资源数 */            &#123;                if ( Work[j] &gt;= Need[i][j] )                    counter = counter + 1;                  /* 可用大于需求，记数，该进程可以执行 */            &#125;            if ( counter == m )                                     /* i进程的每类资源都符合Work[j]&gt;=Need[i][j] 条件二 */            &#123;                p[l]        = i;                            /* 存储安全序列 */                Finish[i]    = 1;                            /* i进程标志为可分配 */                for ( j = 0; j &lt; m; j++ )                    Work[j] = Work[j] + Allocation[i][j];   /* 释放资源 */                l    = l + 1;                                /* 记数,现在有l个进程是安全的，当l=n时说明满足安全序列 */                i    = -1;                                   /* 从第一个进程开始继续寻找满足条件一二的进程 */            &#125;        &#125;    &#125;&#125;/* 显示当前状态函数 */void show()                                     /* 函数show,输出当前资源分配情况 */&#123;    int    i, j;                           /* 局部变量，i表示进程，j表示资源 */    int    All[y];                         /* 各种资源的总数量 */    int    L1;                             /* 局部变量L1 */    cout &lt;&lt; &quot;当前的状态为：&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;各种资源的总数量:&quot; &lt;&lt; endl;    for ( j = 0; j &lt; m; j++ )               /* m为资源数 */    &#123;        cout &lt;&lt; &quot; 资源&quot; &lt;&lt; j &lt;&lt; &quot;: &quot;;        All[j] = Available[j];          /* 总数量=可用的+已分配的 */        for ( i = 0; i &lt; n; i++ )       /* n为进程数 */            All[j] += Allocation[i][j];        cout &lt;&lt; All[j] &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl &lt;&lt; &quot;当前各种资源可用的量为(available):&quot; &lt;&lt; endl;    for ( j = 0; j &lt; m; j++ )               /* m为资源数 */        cout &lt;&lt; &quot; 资源&quot; &lt;&lt; j &lt;&lt; &quot;: &quot; &lt;&lt; Available[j] &lt;&lt; &quot; &quot;;    cout &lt;&lt; endl &lt;&lt; &quot;各进程所需的最大资源量(Max): &quot; &lt;&lt; endl;    for ( i = 0; i &lt; m; i++ )               /* m为资源数 */    &#123;        cout &lt;&lt; &quot; 资源&quot; &lt;&lt; i &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;    for ( L1 = 0; L1 &lt; n; L1++ )            /* n为进程数 */    &#123;        cout &lt;&lt; &quot;进程&quot; &lt;&lt; L1 &lt;&lt; &quot;: &quot;;        for ( j = 0; j &lt; m; j++ )            cout &lt;&lt; Max[L1][j] &lt;&lt; &quot; &quot;;        cout &lt;&lt; endl;    &#125;    cout &lt;&lt; endl &lt;&lt; &quot;各进程已经得到的资源量(allocation): &quot; &lt;&lt; endl;    for ( i = 0; i &lt; m; i++ )       /* m为资源数 */    &#123;        cout &lt;&lt; &quot; 资源&quot; &lt;&lt; i &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;    for ( L1 = 0; L1 &lt; n; L1++ )    /* n为进程数 */    &#123;        cout &lt;&lt; &quot;进程&quot; &lt;&lt; L1 &lt;&lt; &quot;: &quot;;        for ( j = 0; j &lt; m; j++ )            cout &lt;&lt; Allocation[L1][j] &lt;&lt; &quot; &quot;;        cout &lt;&lt; endl;    &#125;    cout &lt;&lt; endl &lt;&lt; &quot;各进程还需要的资源量(need):&quot; &lt;&lt; endl;    for ( i = 0; i &lt; m; i++ ) /* m为资源数 */    &#123;        cout &lt;&lt; &quot; 资源&quot; &lt;&lt; i &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;    for ( L1 = 0; L1 &lt; n; L1++ )    &#123;        cout &lt;&lt; &quot;进程&quot; &lt;&lt; L1 &lt;&lt; &quot;: &quot;;        for ( j = 0; j &lt; m; j++ )            cout &lt;&lt; Need[L1][j] &lt;&lt; &quot; &quot;;        cout &lt;&lt; endl;    &#125;&#125;/* 银行家算法函数 */void bank()&#123;    cout &lt;&lt; endl &lt;&lt; &quot;进程申请分配资源：&quot; &lt;&lt; endl;    int    k    = 0;                                                            /* 用于输入进程编号 */    bool    r    = false;                                                        /* 初值为假，输入Y继续申请则置为真 */    do                                                                              /* 输入请求 */    &#123;        cout &lt;&lt; &quot;输入申请资源的进程(0-&quot; &lt;&lt; n - 1 &lt;&lt; &quot;): &quot;;        cin &gt;&gt; k;                                                               /* 进程编号 */        cout &lt;&lt; endl;        while ( k &gt; n - 1 )                                                     /* 输入错误处理 */        &#123;            cout &lt;&lt; endl &lt;&lt; &quot;无该进程号，重新输入：&quot; &lt;&lt; endl;            cout &lt;&lt; endl &lt;&lt; &quot;输入申请资源的进程(0--&quot; &lt;&lt; n - 1 &lt;&lt; &quot;): &quot;;            cin &gt;&gt; k;                                                       /* 进程编号 */            cout &lt;&lt; endl;        &#125;        cout &lt;&lt; endl &lt;&lt; &quot;输入该进程申请各类资源的数量: &quot; &lt;&lt; endl;        for ( j = 0; j &lt; m; j++ )                                               /* m为资源数 */        &#123;            do                                                              /* do……while 循环判断申请输入的情况 */            &#123;                cout &lt;&lt; &quot;进程 &quot; &lt;&lt; k &lt;&lt; &quot; 申请资源[&quot; &lt;&lt; j &lt;&lt; &quot;]的数量:&quot;;                cin &gt;&gt; Request[j];                                      /* 输入请求进程数 */                cout &lt;&lt; endl;                if ( Request[j] &gt; Need[k][j] )                          /* 申请大于需求量时出错，提示重新输入 cout&lt;&lt;&quot;申请量大于需要量!&quot;&lt;&lt;endl; */                &#123;                    cout &lt;&lt; &quot;申请的资源&quot; &lt;&lt; j &lt;&lt; &quot;的数量为&quot; &lt;&lt; Request[j] &lt;&lt; &quot;,大于进程&quot; &lt;&lt; k &lt;&lt; &quot;对该资源需求量&quot; &lt;&lt; Need[k][j] &lt;&lt; &quot;。&quot; &lt;&lt; endl;                    cout &lt;&lt; &quot;重新输入!&quot; &lt;&lt; endl;                &#125;/* 先判断是否申请大于需求量，再判断是否申请大于可利用量 */                else if ( Request[j] &gt; Available[j] )                   /* 申请大于可利用量， 应该阻塞等待 */                &#123;                    cout &lt;&lt; &quot;\n没有那么多资源，目前可利用资源&quot; &lt;&lt; j &lt;&lt; &quot;数量为&quot; &lt;&lt; Available[j] &lt;&lt; &quot;,本次申请不成功，进程等待!&quot; &lt;&lt; endl;                    Finish[k] = 0;                                  /* 该进程等待 */                    goto error;                                     /* goto语句跳转，结束本次申请 */                &#125;            &#125;            while ( Request[j] &gt; Need[k][j] );                              /* Request[j]&gt;Available[j] */        &#125;/* 改变Available、Allocation、Need的值 */        for ( j = 0; j &lt; m; j++ )                                               /* m为资源数 */        &#123;            Available[j]        = Available[j] - Request[j];            /* 可用的资源数=可用的资源数-请求分配的资源数 */            Allocation[k][j]    = Allocation[k][j] + Request[j];        /* 已分配的资源数=已分配的资源数+请求的资源数 */            Need[k][j]        = Need[k][j] - Request[j];              /* 还需要的资源数=还需要的资源数-请求的资源数 */            Work[j]            = Available[j];        &#125;        safe();                                                                 /* 调用安全性算法函数，判断当前状态的安全性 */        if ( l &lt; n )                                                            /* l用来记录有几个进程是Finish[i]=1的，当l=n是说明系统状态是安全的 */        &#123;            l = 0;            cout &lt;&lt; &quot;\n试分配后,状态不安全,所以不予分配!恢复原状态&quot; &lt;&lt; endl;/* 恢复数据 */            for ( j = 0; j &lt; m; j++ )                                       /* m为资源数 */            &#123;                Available[j]        = Available[j] + Request[j];                Allocation[k][j]    = Allocation[k][j] - Request[j];                Need[k][j]        = Need[k][j] + Request[j];                Work[j]            = Available[j];            &#125;            for ( i = 0; i &lt; n; i++ )                                       /* n为进程数 */                Finish[i] = 0;                                          /* 进程均置为未分配状态 */        &#125;else  &#123; /* l=n，即所有的Finish[i]=1,每一个进程均能执行 */            l = 0;                                                          /* 判断标志 */            cout &lt;&lt; &quot;\n申请资源成功!!!&quot; &lt;&lt; endl;            for ( j = 0; j &lt; m; j++ )                                       /* m为资源数 */            &#123;                if ( Need[k][j] == 0 )                    ;                else &#123;                                                  /*有一种资源还没全部申请到，则该进程不可执行，不能释放拥有的资源 */                    l = 1;                                          /* 置l为1，作为判断标志 */                    break;                &#125;            &#125;            if ( l != 1 )                                                   /* 进程可以执行，则释放该进程的所有资源 */            &#123;                for ( j = 0; j &lt; m; j++ )                               /* m为资源数 */                &#123;                    Available[j]        = Available[j] + Allocation[k][j];                    Allocation[k][j]    = 0;                &#125;                cout &lt;&lt; &quot;该进程已得到所有需求资源，执行后将释放其所有拥有资源！&quot; &lt;&lt; endl;            &#125;            l = 0;                                                          /* 归零 */            cout &lt;&lt; &quot;\n安全的状态!&quot; &lt;&lt; endl;            cout &lt;&lt; &quot;安全序列为: &quot;;            cout &lt;&lt; endl &lt;&lt; &quot;进程&quot; &lt;&lt; &quot;(&quot; &lt;&lt; p[0] &lt;&lt; &quot;)&quot;;                     /* 输出安全序列，考虑显示格式，先输出第一个 */            Finish[0] = 0;            for ( i = 1; i &lt; n; i++ )            &#123;                cout &lt;&lt; &quot;==&gt;&gt;&quot; &lt;&lt; &quot;进程&quot; &lt;&lt; &quot;(&quot; &lt;&lt; p[i] &lt;&lt; &quot;)&quot;;                Finish[i] = 0;                                          /* 所有进程置为未分配状态 */            &#125;            cout &lt;&lt; endl &lt;&lt; endl;        &#125;        show();                                                                 /* 显示当前状态 */error:                                                                                  /* 申请大于可利用量， 应该阻塞等待,结束本次资源申请，GOTO 语句跳转至此 */        cout &lt;&lt; endl &lt;&lt; &quot;是否继续申请资源(y/n)或（Y/N）?&quot;;        char* b = new char;                                                     /* 输入y/n，判断是否继续申请 &lt;&lt;endl */        cin &gt;&gt; b;        cout &lt;&lt; endl;        cout &lt;&lt; &quot;-------------------------------------------&quot; &lt;&lt; endl &lt;&lt; endl;        cout &lt;&lt; endl;        if ( *b == &#39;y&#39; || *b == &#39;Y&#39; )            r = true;                                                       /* 继续申请 */        else&#123;            r = false;                                                      /*不继续申请 */            jieshu();                                                       /* 调用结束函数 */        &#125;    &#125;    while ( r == true );&#125;/* 结束函数 */void jieshu()&#123;    cout &lt;&lt; endl &lt;&lt; endl;    cout &lt;&lt; &quot;\t\t 演示计算完毕&quot; &lt;&lt; endl;    cout &lt;&lt; endl &lt;&lt; endl;&#125;/* 主函数 */int main()&#123;    cout &lt;&lt; endl &lt;&lt; endl &lt;&lt; &quot;\t\t\t\t模拟银行家算法&quot; &lt;&lt; endl &lt;&lt; endl;    chushihua();                                    /* 初始化函数调用 */    cout &lt;&lt; endl;    show();                                         /* 输出当前状态 */    safe();                                         /* 判断当前状态的安全性 */    if ( l &lt; n )                                    /* l在safe中是用来记录安全的进程的个数的 */    &#123;        cout &lt;&lt; &quot;\n当前状态不安全，拒绝申请！&quot; &lt;&lt; endl;        cout &lt;&lt; endl;        return(0);    &#125;else  &#123;        int i;                                  /* 局部变量 */        l = 0;        cout &lt;&lt; endl &lt;&lt; &quot;\n当前的状态是安全的!安全序列为:&quot; &lt;&lt; endl;        cout &lt;&lt; &quot;进程&quot; &lt;&lt; &quot;(&quot; &lt;&lt; p[0] &lt;&lt; &quot;)&quot;;     /* 输出安全序列 */        for ( i = 1; i &lt; n; i++ )            cout &lt;&lt; &quot;-&gt;&gt;&quot; &lt;&lt; &quot;进程&quot; &lt;&lt; &quot;(&quot; &lt;&lt; p[i] &lt;&lt; &quot;)&quot;;        for ( i = 0; i &lt; n; i++ )            Finish[i] = 0;                  /* 所有进程置为未分配状态 */        cout &lt;&lt; endl;    &#125;    bank();                                         /* 调用银行家算法函数 */    cout &lt;&lt; &quot;\t\t 演示计算完毕&quot; &lt;&lt; endl;    return(0);&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
          <category> 其他算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Hexo+GitHub Pages搭建个人静态网站</title>
      <link href="blog/yo1xhz/"/>
      <url>blog/yo1xhz/</url>
      
        <content type="html"><![CDATA[<div style="background: #FFF3F3;padding:10px;border: 1px solid #DEB8BE;border-radius:5px;margin-bottom:5px;">这篇文章的内容~~可能早已过时~~为旧版，因为该文章搭建的为个人首次使用Hexo的记录，经历一年多之后，和现在使用会有差异，日后会更新</div><h2 id="一、环境安装与配置"><a href="#一、环境安装与配置" class="headerlink" title="一、环境安装与配置"></a>一、环境安装与配置</h2><h3 id="Node-的下载与安装"><a href="#Node-的下载与安装" class="headerlink" title="Node 的下载与安装"></a>Node 的下载与安装</h3><p>下载<a href="https://nodejs.org/en/">Node.js</a>并<a href="https://www.jianshu.com/p/03a76b2e7e00">安装</a></p><blockquote><p>目的：安装博客框架，渲染主题等</p></blockquote><p><strong>环境变量的配置如下：</strong><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598689982868-fbf91716-ba29-4dad-bf41-0f63d098073e.png#align=left&display=inline&height=152&margin=%5Bobject%20Object%5D&originHeight=457&originWidth=1223&size=0&status=done&style=stroke&width=406"><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1605175859452-1313ca4d-9cc1-44be-9b51-bb684f548cf2.png#align=left&display=inline&height=187&margin=%5Bobject%20Object%5D&name=image.png&originHeight=927&originWidth=1792&size=143623&status=done&style=stroke&width=361" alt="image.png"></p><h3 id="安装-Hexo"><a href="#安装-Hexo" class="headerlink" title="安装 Hexo"></a>安装 Hexo</h3><p><code>npm install -g hexo-cli</code></p><h3 id="申请-GitHub-Pages"><a href="#申请-GitHub-Pages" class="headerlink" title="申请 GitHub Pages"></a>申请 GitHub Pages</h3><p>在 github 上申请 github pages，在账户下创建一个仓库名为 <code>wztlink1013.github.io</code>的仓库，则这个仓库下的 main 分支下的前端代码就会被发布成成网页（必须要由 index.html 文件）。</p><blockquote><p>访问：<a href="https://wztlink1013.github.io/">https://wztlink1013.github.io</a></p></blockquote><h2 id="二、搭建博客"><a href="#二、搭建博客" class="headerlink" title="二、搭建博客"></a>二、搭建博客</h2><h3 id="创建并初始化文件夹"><a href="#创建并初始化文件夹" class="headerlink" title="创建并初始化文件夹"></a>创建并初始化文件夹</h3><p>这里面所有文件就相当于所搭建博客网页所有源文件</p><p>进入文件打开<code>git bash</code>输入<code>hexo init</code>出现<code>INFO Start blogging with Hexo!</code>则证明初始化成功，此时 blog 文件夹里面会有一些站点文件<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616727001925-a02dabbf-4792-492e-bf5d-fed01a85eafc.png#align=left&display=inline&height=120&margin=%5Bobject%20Object%5D&name=image.png&originHeight=239&originWidth=1894&size=46813&status=done&style=none&width=947" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616727028761-75106936-43e9-4879-9c25-4596074efc43.png#align=left&display=inline&height=436&margin=%5Bobject%20Object%5D&name=image.png&originHeight=872&originWidth=1894&size=154103&status=done&style=none&width=947" alt="image.png"></p><pre><code>node_modules：各种插件的安装文件夹scaffolds：模板文件夹（new的对象的模板）source：资源文件夹themes：主题文件夹（相当于“衣裳”）_config.yml：站点配置文件package.json：应用程序的信息</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616727087774-de9b7013-31f1-4f4b-8018-4dc47b46d075.png#align=left&display=inline&height=517&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1034&originWidth=1920&size=866676&status=done&style=none&width=960" alt="image.png"></p><h3 id="相关命令"><a href="#相关命令" class="headerlink" title="相关命令"></a>相关命令</h3><pre><code class="bash">hexo clean   #清除缓存，网页正常情况下可以忽略此条命令hexo n &quot;博客名称&quot;  # hexo new &quot;博客名称&quot;hexo p  # hexo publishhexo g  # hexo generate  # 生成静态网页hexo s  # hexo server  # 启动服务预览；Hexo 会监视文件变动并自动更新，无须重启服务器。        hexo server -s   #静态模式        hexo server -p 5000   #更改端口        hexo server -i 192.168.1.1   #自定义IPhexo d  # hexo deploy  # 部署                hexo deploy --message &quot;哈哈，hexo deploy --message 双引号内容就可以提交commit信息了&quot;</code></pre><blockquote><ol><li>部署命令不能简写了，因为下载了豆瓣的相关插件，只能 hexo deploy</li><li>将博客根目录源代码备份到 git 仓库中命令：hexo b 或者 hexo backup</li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C/C++遗忘知识总结</title>
      <link href="blog/uakfgc/"/>
      <url>blog/uakfgc/</url>
      
        <content type="html"><![CDATA[<div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">相当于记个流水帐了~菜鸡永远没有对任何知识都会的时候![huaji-779c5947261d2633.gif](https://cdn.nlark.com/yuque/0/2021/gif/1484158/1618304475795-4149058a-4d7c-49b6-8956-e22568cb4888.gif#align=left&display=inline&height=151&margin=%5Bobject%20Object%5D&name=huaji-779c5947261d2633.gif&originHeight=151&originWidth=218&size=163714&status=done&style=none&width=218)</div><h2 id="C-指针"><a href="#C-指针" class="headerlink" title="C 指针"></a>C 指针</h2><p>相关概念的理解容易混淆，记住之前学习理解的一个准则！<code>*p 的理解意义就是p 所指向的那个东西</code></p><ul><li>取地址符 <code>&amp;</code></li><li>解引用运算符 <code>*</code><blockquote><p>参考：</p><ul><li><a href="https://blog.csdn.net/soonfly/article/details/51131141">https://blog.csdn.net/soonfly/article/details/51131141</a></li></ul></blockquote></li></ul><ul><li>有 3 个用途<blockquote><ol><li>乘号（Multiply）： 2*3 就是 6</li><li>声明指针（Pointer Statement）： int a =5; int* ptr=&a;就是声明变量 a 是 5，把 a 的地址附到指针 ptr 上</li><li>解引用 （Dereference）： <em>ptr 单独拿出来就是找出 ptr 指针指向的值，按照第二点的说法就是 5.<br>&amp;叫做取地址符号<br>• 一般指针只能接受一个内存地址而不能接受一个值<br>• int a =5; int</em> ptr=a;就是错误的，指针不能接受一个值<br>• int a =5; int* ptr=&a;才对，把 a 的地址给指针 ptr<br>指针理解的话你可以这么想。<br>你问我书在哪。我说在书架第一层。<br>你问我书在哪。我说在那个桌子上的纸条上写着位置。这样的话那个纸条就是指针。<br>纸条上写着，书在书架第一层，这就是地址，他并不是书的实体<br>真正的书在书架第一层，顺着地址去找吧</li></ol></blockquote></li></ul><h2 id="C-结构体"><a href="#C-结构体" class="headerlink" title="C 结构体"></a>C 结构体</h2><h3 id="一些概念"><a href="#一些概念" class="headerlink" title="一些概念"></a>一些概念</h3><blockquote><ul><li>结构体:构造（定义新的数据类型）</li><li>结构体变量:定义（两种）；结构体变量访问结构体里面的成员：<code>.</code>；指针访问成员的时候<code>-&gt;</code></li><li>结构体数组：变量很多</li><li>结构体指针：指向结构体变量的指针，定义：<code>struct Student *p</code>；指向结构体数组的指针</li></ul></blockquote><ul><li>C 里面的<strong>结构体、共用体、枚举体</strong>根据这几类来构造新的数据类型，比如链表的初始实现，就是利用指针和结构体来实现</li><li><strong>typedef</strong>给结构体制定新的类型名  eg：计数专用变量<code>typedef int Count</code></li></ul><h3 id="单链表的存储结构"><a href="#单链表的存储结构" class="headerlink" title="单链表的存储结构"></a>单链表的存储结构</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616502801770-db341786-acc5-4024-966b-8793c339cc89.png#align=left&display=inline&height=116&margin=%5Bobject%20Object%5D&name=image.png&originHeight=231&originWidth=989&size=38948&status=done&style=none&width=494.5" alt="image.png"><br>上面的代码可以分解为：</p><pre><code class="cpp">typedef struct LNode LNode;         //将结构体类型struct LNode重命名为LNodetypedef struct LNode *LinkList;     //将struct LNode *重命名为LinkList</code></pre><blockquote><p>创建的时候，可以有下面三种方法<br>【L 是指向结构体类型（struct LNode 型）指针变量】</p></blockquote><ol><li>LinkList L;</li><li>struct LNode * L</li><li>LNode *L = new LNode;</li></ol><p>只不过是用第 1 种方式创建更加简单，具体的使用，new 的时候一般使用前者，定义一个该类型变量的时候一般用后者</p><p>LinkList L；理解：一个结构体变量的指针就是该结构体变量所占据的内存段的起始地址，而我定义的是 LinkList 而不是 int，只是和计算机说明我需要的内存不一样了这种作用</p><p>参考：<a href="https://blog.csdn.net/GRoads/article/details/104155255">https://blog.csdn.net/GRoads/article/details/104155255</a></p><h2 id="C-的函数参数引用-amp-理解"><a href="#C-的函数参数引用-amp-理解" class="headerlink" title="C++的函数参数引用&amp;理解"></a>C++的函数参数引用&amp;理解</h2><p>在学习单链表的时候，编写前插法的函数，函数参数传递的是&amp;L 而不是*L，这个相关知识的解释，参考这个帖子<a href="https://fishc.com.cn/thread-98021-1-1.html">https://fishc.com.cn/thread-98021-1-1.html</a>，里面的榜首答案下图这么一句话<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616504219420-872367f1-be2c-4afe-89e5-12ecbfe817dc.png#align=left&display=inline&height=165&margin=%5Bobject%20Object%5D&name=image.png&originHeight=330&originWidth=1658&size=55429&status=done&style=stroke&width=829" alt="image.png"></p><ul><li>函数传递&amp;：为引用参数，传递给引用于传递指针的效果是一样的，【只是个别名，不是取值！！】<a href="https://blog.csdn.net/weibo1230123/article/details/78910179">https://blog.csdn.net/weibo1230123/article/details/78910179</a></li><li>代码实操以下</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616504292045-802c3bc2-ebbc-49aa-8764-7852def70548.png#align=left&display=inline&height=219&margin=%5Bobject%20Object%5D&name=image.png&originHeight=438&originWidth=755&size=47238&status=done&style=none&width=377.5" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616504341193-3d82d795-ebab-42c9-bc2c-3b6f0fe04e2e.png#align=left&display=inline&height=214&margin=%5Bobject%20Object%5D&name=image.png&originHeight=428&originWidth=854&size=49466&status=done&style=none&width=427" alt="image.png"><br>图 1 是可以运行的，图 2 不可以（传递错误的格式）<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616504560727-4aacc3bb-139a-46be-aafb-5ba50bbae0b3.png#align=left&display=inline&height=107&margin=%5Bobject%20Object%5D&name=image.png&originHeight=214&originWidth=1062&size=77047&status=done&style=none&width=531" alt="image.png"><br>函数参数的传递，还要好好再复习复习……</p><h2 id="类-C-中-new、delete"><a href="#类-C-中-new、delete" class="headerlink" title="类 C 中 new、delete"></a>类 C 中 new、delete</h2><p>在数据结构课程里面的类 C 语言里面，new、delete 分别为在内存中分配/释放空间</p><h2 id="C-值-STL"><a href="#C-值-STL" class="headerlink" title="C++值 STL"></a>C++值 STL</h2><h3 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h3><ul><li>函数模板</li><li>类模板<br>STL 概述当中，vector 容器，顺序容器：向量 vector、列表 list、双端队列 deque<blockquote><p><a href="https://www.cnblogs.com/mr-wid/archive/2013/01/22/2871105.html">https://www.cnblogs.com/mr-wid/archive/2013/01/22/2871105.html</a></p></blockquote></li></ul><h2 id="C-之-define"><a href="#C-之-define" class="headerlink" title="C 之#define"></a>C 之#define</h2><p>C 语言中，可以用 #define 定义一个标识符来表示一个常量。其特点是：定义的标识符不占内存，只是一个临时的符号，预编译后这个符号就不存在了。</p><p>预编译又叫预处理。预编译不是编译，而是编译前的处理。这个操作是在正式编译之前由系统自动完成的。</p><ul><li><p><a href="http://c.biancheng.net/view/187.html">http://c.biancheng.net/view/187.html</a></p></li><li><p>const 定义常量</p></li><li><p>之前 C 语言里面用的是宏定义#define Π 3.1415927，但是宏定义有时候太“死板”</p></li></ul><h2 id="C-头文件"><a href="#C-头文件" class="headerlink" title="C++头文件"></a>C++头文件</h2><div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">- C语言中的头文件以.h后缀，C++中头文件不加后缀。- C语言中的string.h头文件，C++用cstring，- C语言中的math头文件，C++使用cmath头文件<p>这不只是形式上的改变，其实现也有所不同。</div></p><h3 id="using-namespace-std"><a href="#using-namespace-std" class="headerlink" title="using namespace std;"></a>using namespace std;</h3><p>C++标准库中所有标识符并定义于一个名为 std 的命名空间中，std 称为标准命名空间（standard，标准的）。</p><h3 id="iostream"><a href="#iostream" class="headerlink" title="iostream"></a>iostream</h3><p>C++中的输入、输出头文件 iostream<br>i ——input 输入<br>o ——output 输出<br>stream —— 流</p><h3 id="iomanip"><a href="#iomanip" class="headerlink" title="iomanip"></a>iomanip</h3><table><thead><tr><th>操作符</th><th>功能</th></tr></thead><tbody><tr><td>setfill(char c)</td><td>设置以 c 表示的填充字符</td></tr><tr><td>setprecision(int n)</td><td>设置以 n 表示的数值精度</td></tr><tr><td>setw(int n)</td><td>设置以 n 表示的域宽</td></tr></tbody></table><pre><code class="cpp">#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &lt;cmath&gt;using namespace std;int main()&#123;    double num=sqrt(3.0);    for (int i = 0; i &lt; 6; i++)&#123;        cout &lt;&lt;&quot;当精度为&quot;&lt;&lt;i&lt;&lt;&quot;时：&quot;&lt;&lt;setprecision(i)&lt;&lt;num&lt;&lt;endl;//设置不同的精度    &#125;    cout &lt;&lt; &quot;当前cout精度为：&quot; &lt;&lt;cout.precision() &lt;&lt; endl;    cout &lt;&lt; &quot;当前域宽：&quot; &lt;&lt;cout.width() &lt;&lt; endl;    cout &lt;&lt; &quot;==================================&quot;        &lt;&lt; &quot;\n&quot;;    cout &lt;&lt;setw(7)&lt;&lt;num &lt;&lt; endl; //默认是右对齐    cout &lt;&lt; &quot;当前填充字符：&quot; &lt;&lt; endl;    cout&lt;&lt;setfill(&#39;*&#39;) &lt;&lt;setw(10)&lt;&lt;num &lt;&lt; endl; //setfill()函数可以直接插入流中    return 0;&#125;</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1621218267138-b3d7bcad-1567-4448-9839-e339c6bcb922.png#align=left&display=inline&height=170&margin=%5Bobject%20Object%5D&name=image.png&originHeight=340&originWidth=720&size=32960&status=done&style=none&width=360" alt="image.png"></p><ul><li>参考：<a href="https://blog.csdn.net/akof1314/article/details/4625888">https://blog.csdn.net/akof1314/article/details/4625888</a></li></ul><h3 id="bits-stdc-h"><a href="#bits-stdc-h" class="headerlink" title="bits/stdc++.h"></a>bits/stdc++.h</h3><ul><li>万能头文件：几乎包含所有的可用到的 C++库函数</li><li>缺点<ul><li>编译时间慢，具有不可移植的问题，很多编译器和 oj 不支持，虽然现在 noip 支持了…</li><li>如果你用了 bits/stdc++.h，那么你很大几率就会用 using namespace std;而不是 using std::cin; using std::cout;这样的。这会导致你的某些变量或函数已经被包含了而你不知道（关键字作为函数名）</li><li>还有很重要的一点，就是用 bits 很占内存，某些卡内存的题根本用不了</li></ul></li><li>具体头文件内容</li></ul><pre><code class="cpp">// C++ includes used for precompiling -*- C++ -*-// Copyright (C) 2003-2013 Free Software Foundation, Inc.//// This file is part of the GNU ISO C++ Library.  This library is free// software; you can redistribute it and/or modify it under the// terms of the GNU General Public License as published by the// Free Software Foundation; either version 3, or (at your option)// any later version.// This library is distributed in the hope that it will be useful,// but WITHOUT ANY WARRANTY; without even the implied warranty of// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the// GNU General Public License for more details.// Under Section 7 of GPL version 3, you are granted additional// permissions described in the GCC Runtime Library Exception, version// 3.1, as published by the Free Software Foundation.// You should have received a copy of the GNU General Public License and// a copy of the GCC Runtime Library Exception along with this program;// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see// &lt;Licenses - GNU Project - Free Software Foundation&gt;./** @file stdc++.h *  This is an implementation file for a precompiled header. */// 17.4.1.2 Headers// C#ifndef _GLIBCXX_NO_ASSERT#include &lt;cassert&gt;#endif#include &lt;cctype&gt;#include &lt;cerrno&gt;#include &lt;cfloat&gt;#include &lt;ciso646&gt;#include &lt;climits&gt;#include &lt;clocale&gt;#include &lt;cmath&gt;#include &lt;csetjmp&gt;#include &lt;csignal&gt;#include &lt;cstdarg&gt;#include &lt;cstddef&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;ctime&gt;#if __cplusplus &gt;= 201103L#include &lt;ccomplex&gt;#include &lt;cfenv&gt;#include &lt;cinttypes&gt;#include &lt;cstdalign&gt;#include &lt;cstdbool&gt;#include &lt;cstdint&gt;#include &lt;ctgmath&gt;#include &lt;cwchar&gt;#include &lt;cwctype&gt;#endif// C++#include &lt;algorithm&gt;#include &lt;bitset&gt;#include &lt;complex&gt;#include &lt;deque&gt;#include &lt;exception&gt;#include &lt;fstream&gt;#include &lt;functional&gt;#include &lt;iomanip&gt;#include &lt;ios&gt;#include &lt;iosfwd&gt;#include &lt;iostream&gt;#include &lt;istream&gt;#include &lt;iterator&gt;#include &lt;limits&gt;#include &lt;list&gt;#include &lt;locale&gt;#include &lt;map&gt;#include &lt;memory&gt;#include &lt;new&gt;#include &lt;numeric&gt;#include &lt;ostream&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;sstream&gt;#include &lt;stack&gt;#include &lt;stdexcept&gt;#include &lt;streambuf&gt;#include &lt;string&gt;#include &lt;typeinfo&gt;#include &lt;utility&gt;#include &lt;valarray&gt;#include &lt;vector&gt;#if __cplusplus &gt;= 201103L#include &lt;array&gt;#include &lt;atomic&gt;#include &lt;chrono&gt;#include &lt;condition_variable&gt;#include &lt;forward_list&gt;#include &lt;future&gt;#include &lt;initializer_list&gt;#include &lt;mutex&gt;#include &lt;random&gt;#include &lt;ratio&gt;#include &lt;regex&gt;#include &lt;scoped_allocator&gt;#include &lt;system_error&gt;#include &lt;thread&gt;#include &lt;tuple&gt;#include &lt;typeindex&gt;#include &lt;type_traits&gt;#include &lt;unordered_map&gt;#include &lt;unordered_set&gt;#endif</code></pre><p>C++</p><h2 id="【大一-C-和-C-笔记】"><a href="#【大一-C-和-C-笔记】" class="headerlink" title="【大一 C 和 C++笔记】"></a>【大一 C 和 C++笔记】</h2><div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">当时在OneNote的一些小记</div><h3 id="C-常用字符函数"><a href="#C-常用字符函数" class="headerlink" title="C 常用字符函数"></a>C 常用字符函数</h3><p>Printf()<br>Scanf()<br>Putchar()<br>Getchar()<br>Puts(str)<br>Gets(str)<br>Strcat(str1,str2)：连接字符串<br>复制函数：将 str2 复制给 str1<br>Strcpy(str1,str2)<br>在 C++里面会报错<br>解决 ①：将函数 strcpy 改成 strcpy_s,中间加一个参数——复制的长度</p><p>Strncpy(str1,str2,n)：复制函数，将 str2 的前 n 个字符复制给 str1<br>Strlen(str)：检测 str 的字符串长度<br>Fopen(文件名，使用文件方式）<br>fclose（文件指针）</p><h3 id="I-O-改进"><a href="#I-O-改进" class="headerlink" title="I/O 改进"></a>I/O 改进</h3><ul><li>scanf===cin&gt;&gt; &gt;&gt;endl;</li><li>Print===cout&lt;&lt; &lt;&lt;endl;</li><li>换行符：endl 和 “\n”</li></ul><h3 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h3><p>类的形式？<br>Class wuzutao<br>{<br>private：</p><pre><code>    public：    protect：&#125;；数据成员成员函数：    类内实现=和普通函数的实现一样    类外实现=void Date：：Display（）&#123;&#125;</code></pre><p>类定义对象？<br>① 花括号内定义<br>② 花括号外定义</p><p>访问对象？<br>访问的是类内的成员<br>① 圆点访问形式<br>② 指针访问形式</p><p>this 指针？<br>每个成员函数都会有一个特殊的隐含指针——this 指针。<br>调用形式：cout&lt;&lt;this&lt;year&lt;day&lt;&lt;endl;</p><p><strong>构造函数和析构函数</strong><br>构造函数的作用就是适当地给类进行初始化的作用<br>无参数的构造函数<br>带参数的构造函数</p><p>拷贝构造函数，这里不是太懂！<br>拷贝构造函数声明<br>拷贝构造函数定义和实现</p><p>析构函数<br>一般默认，如果自己写的话就是<br>析构函数的声明：<br><del>类名（）；<br>析构函数的定义和实现：<br>类名：：</del>类名（）{……}</p><h3 id="数据的共享和保护"><a href="#数据的共享和保护" class="headerlink" title="数据的共享和保护"></a>数据的共享和保护</h3><p><strong>数据共享 static</strong></p><ol><li>静态数据成员<br>声明：static 数据类型 静态数据成员名；<br>初始化在类结束和类中函数实现的中间<br>之后访问（通过类名/对象名来访问）：<br>私有的静态成员只能通过间接的方式来访问===静态成员函数<br>对象名.公有静态成员变量名<br>对象名::公有静态成员变量名</li><li>静态成员函数<br>没有 this 指针<br>声明：static 返回值类型 静态成员函数名（形参表）<br>之后访问（通过类名/对象名来访问）：<br>类名::静态成员函数名（实参表）<br>类名.静态成员函数名（实参表）</li></ol><p><strong>数据保护 const</strong></p><ol><li>常数据成员<br>有些时候，希望不用全局变量，因为这样不好移植，所以用到 const 场数据类型，相当于每次用不同场合用到这个类，都是这些用到这些固定的数据<br>一般结合 static 来避免数据赘余<br>eg：类 Circle 中<br>定义：const double PI；<br>初始化只能在构造函数后面的初始化列表中：Circle （double r=0）：PI（3.1415926）<ol><li>常成员函数<br>只访问类中的数据而不修改类中的数据成员，最好用到常成员函数<br>eg：只访问类中的半径<br>声明：Double GetRadius（）const；<br>实现：double Circle：：GetRadius（）const{……}</li><li>常对象<br>所定义的常对象 p1 在之后就不会被改变了<br>形式：const Person p1（17，“wu”）；</li></ol></li></ol><h3 id="类和类之间的关系"><a href="#类和类之间的关系" class="headerlink" title="类和类之间的关系"></a>类和类之间的关系</h3><p><strong>类的组合</strong><br>直观：B 类中有 A 类定义的对象</p><p>构造函数的顺序：<br>对象成员的构造函数<br>自身的构造函数</p><p>构造函数有参数的时候：<br>怎么个表现形式呢？<br><strong>B 类中 B 的构造函数后面带有 A 类在 B 类中所定义的对象，这个对象的参数用做左边 B 类构造函数的参数、</strong></p><p><strong>类的依赖</strong><br>赌徒和骰子，这就是一种依赖关系，如果用组合关系的话，就会影响到生命周期问题</p><p>Class 🎲{}；<br>Class 🕵️‍♂️<br>{<br>public：<br>Void play（🎲1，🎲2，🎲3）<br>{……}<br>}；<br><strong>类的继承和派生</strong><br>一、派生类的定义：<br>父类 class Base{}<br>派生子类：单一继承 class Derived：public Base{}；<br>多重继承 Class Derived：public Base1，pretect Base2{}；<br>继承的类型：<br>单一继承：只有一个基类<br>多重继承：有多个基类</p><p>继承方式：<br>private 继承：所有的数据成员都为子类的的私有成员<br>public 继承：父类的数据类型怎样，在子类类型不变<br>protect 继承：所有的数据成员和成员函数都为字类的保护成员<br>ps：① 父类的 private 数据成员和成员函数不能被子类所继承<br>② 一般很少用 protect 和 private 两种继承，因为两种改变了之前基类的访问属性，限制了这些的进一步派生，所以很少使用</p><p>二、派生类的构造和析构<br>构造和析构的调用顺序：<br>① 所有虚基类的构造函数<br>② 基类的构造函数<br>③ 对象成员的构造函数<br>④ 自身派生类的构造函数<br>ps：析构函数的调用顺序则正好相反、<br>虚基类保证调用一次构造函数。两个子类都有同一个基类的虚基类继承，构造函数只调用一次<br>带参数的构造函数：<br>子类里面，构造函数的初始化要连带着基类的构造函数的初始化<br>eg：classA(int a,int b,int c):classB(a*2),classC(a,b){}</p><p>三、同名冲突和解决方案<br>解决 ① 双冒号法：：<br>基类和子类当中有相同名字的数据成员和成员函数，<br>访问的时候：相同的名字：：数据成员/成员函数<br>解决 ② 定义虚基类 virtual<br>eg：class furniture{}；<br>Class sofa ：virtual public furniture{}；<br>Class bed：virtual public furniture{}；<br>Class sofabed：public sofa，public bed{}；</p><p>四、赋值兼容规则</p><h3 id="主函数"><a href="#主函数" class="headerlink" title="主函数"></a>主函数</h3><p>主函数 main()是程序的入口，每个程序都需要一个主函数。主函数返回值为 int 型。<br>int main()<br>{<br>cout&lt;&lt;”hello,world!”&lt;&lt;endl;<br>return 0;<br>}  <br>注意：程序末尾返回 0</p><h3 id=""><a href="#" class="headerlink" title=""></a></h3>]]></content>
      
      
      <categories>
          
          <category> Language </category>
          
          <category> CPlusPlus </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JAVA-面向对象</title>
      <link href="blog/eywygo/"/>
      <url>blog/eywygo/</url>
      
        <content type="html"><![CDATA[<h2 id="一、面向对象思考"><a href="#一、面向对象思考" class="headerlink" title="一、面向对象思考"></a>一、面向对象思考</h2><h3 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h3><blockquote><p>就像是手工设计动态数组、链表等数据结构一样，要用<strong>设计</strong>这个字眼去面向对象思考。<br>同时还要关注类与类之间的关系有关联、聚集、组合，在设计多个类的过程中要有这些意识</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1600086611076-d83aa284-7977-447d-9b25-0a0a67a12c3f.png#align=left&display=inline&height=189&margin=%5Bobject%20Object%5D&name=image.png&originHeight=377&originWidth=1003&size=316078&status=done&style=stroke&width=501.5" alt="image.png"><br>就像是之前的数据结构课程一样，像那样就是面向过程，全都是写函数来实现操作</p><h3 id="基本数据类型值及其包装类"><a href="#基本数据类型值及其包装类" class="headerlink" title="基本数据类型值及其包装类"></a>基本数据类型值及其包装类</h3><blockquote><p>都存在 java.lang 里面</p></blockquote><p>Integer、Long、Float、Double、Boolean、Character、Short、Byte<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1600087287006-c480d8fd-a6b5-4be9-bc43-3023e9fa4a0c.png#align=left&display=inline&height=264&margin=%5Bobject%20Object%5D&name=image.png&originHeight=527&originWidth=989&size=482466&status=done&style=stroke&width=494.5" alt="image.png"></p><blockquote><p>基本数据类型和其对象化之后的包装类类型之间的自动转换</p></blockquote><p><code>Integer intObject = new Integer (2);</code>  等价于 <code>Integer intObject = 2;</code></p><blockquote><p>BigInteger 类和 BigDeciml 类用于表示任意大小和精度的整数或是二进制数</p></blockquote><h2 id="二、对象和类"><a href="#二、对象和类" class="headerlink" title="二、对象和类"></a>二、对象和类</h2><h3 id="OOP-阶梯图"><a href="#OOP-阶梯图" class="headerlink" title="OOP 阶梯图"></a>OOP 阶梯图</h3><blockquote><p>“OOP 阶梯图”—— 类的多个特性，同时以对象对基础</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598686636493-3aecdbf5-1f94-4076-99dc-0ef0dac07331.png#align=left&display=inline&height=216&margin=%5Bobject%20Object%5D&originHeight=726&originWidth=1328&size=0&status=done&style=stroke&width=396"></p><h3 id="类的组成"><a href="#类的组成" class="headerlink" title="类的组成"></a>类的组成</h3><blockquote><p>数据域、构造函数、方法（C++里面的说法是数据成员和成员函数）<br><strong>类中不能存在可执行语句</strong></p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598686636459-572d60ff-0740-4487-b3fd-9e2fa94b643f.png#align=left&display=inline&height=248&margin=%5Bobject%20Object%5D&originHeight=713&originWidth=1387&size=0&status=done&style=shadow&width=482"></p><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><ul><li>和类同名、重载、没有返回值</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598686636454-ce95b4aa-9966-4024-82ae-b7cc296097db.png#align=left&display=inline&height=218&margin=%5Bobject%20Object%5D&originHeight=481&originWidth=708&size=0&status=done&style=stroke&width=321"></p><ul><li><strong>构造函数初始化优先级</strong><blockquote><ol><li>静态成员变量初始化顺序高于非静态成员变量</li><li>成员变量的初始化顺序优于构造函数</li><li>静态成员变量只初始化一次，就是第一次被访问的时候</li><li>存在多个静态成员变量的时候，按照次序依次执行</li></ol></blockquote></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598686636495-c0c2fdf5-3919-475e-a2f7-a3888d97492d.png#align=left&display=inline&height=220&margin=%5Bobject%20Object%5D&originHeight=700&originWidth=1404&size=0&status=done&style=stroke&width=441"></p><pre><code class="java">Window(2)Window(1)Window(2)Window(3)House()Window(33)f()</code></pre><h3 id="数据域的默认值"><a href="#数据域的默认值" class="headerlink" title="数据域的默认值"></a>数据域的默认值</h3><blockquote><p><strong>对于对象而言，不赋值也会有默认的</strong>。之前的数组就是如此</p></blockquote><p>各个数据域按照之前的基本上的默认初值，如果是其他的类型，则空</p><h3 id="对象的创建和访问"><a href="#对象的创建和访问" class="headerlink" title="对象的创建和访问"></a>对象的创建和访问</h3><blockquote><ol><li>通过引用变量来访问对象，创建的类的对象被内存分配了内存空间，可以用引用变量来访问</li><li><strong>对象类型都需要用 new 来新建</strong></li></ol></blockquote><pre><code class="java">ClassName objectRefVar = new ClassName();Circle myCircle = new Circle();</code></pre><p><strong>使用成员变量和成员函数</strong></p><pre><code class="java">mycircle.radiusmycircle.getArea()</code></pre><p><strong>调用静态函数，动态函数需要在自己类下面调用自己的函数</strong></p><h3 id="“炸宿舍”"><a href="#“炸宿舍”" class="headerlink" title="“炸宿舍”"></a>“炸宿舍”</h3><blockquote><p>关于老师提出来的炸宿舍例子</p></blockquote><p><strong>对象间的赋值和基本类型的赋值，能改变的一定是基本数值类型，所谓的数组名抑或是对象名，都只是地址映射</strong></p><h3 id="垃圾回收机制和-this"><a href="#垃圾回收机制和-this" class="headerlink" title="垃圾回收机制和 this"></a>垃圾回收机制和 this</h3><pre><code class="java">System.gc(); // 提醒垃圾回收</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1600086346479-3cc546b6-dab8-4fc5-a352-8f2fb2ea8065.png#align=left&display=inline&height=281&margin=%5Bobject%20Object%5D&name=image.png&originHeight=562&originWidth=960&size=48667&status=done&style=shadow&width=480" alt="image.png"></p><h3 id="静态变量、常量和方法"><a href="#静态变量、常量和方法" class="headerlink" title="静态变量、常量和方法"></a>静态变量、常量和方法</h3><blockquote><p>静态成员变量：静态成员变量可以被类的所有实例共享（比如计数变量用到）<br>静态方法：不能访问类的实例成员<br>关于静态变量、静态方法、实例变量、实例方法</p></blockquote><h3 id="可见性修饰符"><a href="#可见性修饰符" class="headerlink" title="可见性修饰符"></a>可见性修饰符</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598686637158-0b08a6a1-5cd8-4aac-9133-1ad101cc8a52.png#align=left&display=inline&height=302&margin=%5Bobject%20Object%5D&originHeight=302&originWidth=491&size=0&status=done&style=stroke&width=491"></p><h3 id="“析构函数”"><a href="#“析构函数”" class="headerlink" title="“析构函数”"></a>“析构函数”</h3><pre><code class="java">protected void finalize() throwsable &#123;    super.finalize();    System.out.println(&quot;Person - finalize&quot;);&#125;</code></pre><h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><p>内部类只给该类使用（私有自己用，同时写静态的），就如 LinkedList 类的设计</p><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
      
      
      <categories>
          
          <category> Language </category>
          
          <category> JAVA </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JAVA-基础知识</title>
      <link href="blog/esofty/"/>
      <url>blog/esofty/</url>
      
        <content type="html"><![CDATA[<h2 id="一、关于-JAVA"><a href="#一、关于-JAVA" class="headerlink" title="一、关于 JAVA"></a>一、关于 JAVA</h2><h3 id="Java-和-C-和-C"><a href="#Java-和-C-和-C" class="headerlink" title="Java 和 C 和 C++"></a>Java 和 C 和 C++</h3><ol><li>c 是面向过程的语言。c++和 Java 都是面向对象的。在 c 中没有类或者对象的概念。</li><li>java 运行在虚拟机上，号称与平台无关。也就是你开发的 java 程序无论是 unix，linux 还是 windows 都可以正常运行。但是实际上这是一个良好的愿望，实际跨平台时还会有各种各样的问题。c 和 c++都是直接编译成可执行文件，是否能跨平台主要看你用到的编译器特性是否有多平台支持。</li><li>因为 c 和 c 是直接编译成可执行文件，所以运行效率要比 java 高。至于 c 和 c 哪个更快，两种语言的拥趸已经吵了很多年。</li><li>java 因为是运行在虚拟机上，不需要考虑内存管理和垃圾回收机制。也是就你可以声明一个对象而不用考虑释放他，虚拟机帮你做这事情。而 c 和 c 语言本身没有多少内存管理的概念，写 c 和 c 程序如果用到指针就一定要考虑内存申请和释放。内存泄漏是 c 和 c++最头疼的问题。</li><li>代码重用：java 中有一个根类 object，所有的类都是其子类，通过这种方式将容器和算法分离，实现一种操作作用于多种对象，提高代码重用。c 中没有总根对象，但是 c 提供了另一个更强大的功能“模板”，同样高效地实现了一种操作作用于多种对象，提供了高效的代码重用方法。</li><li>数据结构：java 内建了丰富的数据结构：列表，集合等等（很久没用 java 了，有些记不太清）。而 c++则用“模板”同样提供了各种数据结构（容器）。</li><li>c 语言在一些比较低层，和硬件打交道的地方用得比较多。另外很多开源软件由于 unix/linux 开发习惯也大多采用 c 来开发。Java 是现在最流行的开发语言，c++比起 java 稍稍不那么流行一些，但是功能很强大。如能深入掌握，可以写出兼顾效率和美观的优秀代码。</li></ol><h3 id="多语言简略对比"><a href="#多语言简略对比" class="headerlink" title="多语言简略对比"></a>多语言简略对比</h3><blockquote><p><strong>Ideas are cheap, show me the code</strong>   学到了，学到了~</p></blockquote><pre><code>代码块：python通过缩进来确定代码块复数：java、python有，C、Cplusplus没有python：相对于java，python就是java的压缩版本包、接口、API：我觉得java也好，python也好，正是因为这些模块组件化，才使得这些语言好很好的的健壮性</code></pre><h2 id="二、数据类型；运算符；表达式"><a href="#二、数据类型；运算符；表达式" class="headerlink" title="二、数据类型；运算符；表达式"></a>二、数据类型；运算符；表达式</h2><h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><blockquote><p>常量、标识符和变量、数据类型</p></blockquote><blockquote><p><strong>JAVA 中除了下面 8 种数据类型其他的都是以对象（或者说类的实例）存在的</strong></p></blockquote><ul><li>string：要熟悉常用的函数<ul><li>length()：字符串的长度</li><li>charAt(i)：取字符串的第 i 个元素</li></ul></li><li>boolean（java 中需要全部写出来）<ul><li><code>true</code></li><li><code>false</code></li></ul></li><li>下面 6 中数值型数据类型</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598686524193-b62199d3-9dc6-4caa-a3c1-2484c7d6185c.png#align=left&display=inline&height=204&margin=%5Bobject%20Object%5D&originHeight=583&originWidth=1192&size=0&status=done&style=shadow&width=418"></p><h3 id="运算符和表达式"><a href="#运算符和表达式" class="headerlink" title="运算符和表达式"></a>运算符和表达式</h3><ul><li>赋值语句，赋值表达式</li><li>输入输出：<strong>输入输出，要有记得清除的空间，close 的意识！</strong></li></ul><pre><code class="java">// 方式一import java.util.Scanner;Scanner input = new Scanner(System.in);double radius = input.nextDouble();// 方式二 : 好处就是避免项目工程中类当中重名的情况java.util.Scanner input = new java.util.Scanner(System.in);double radius = input.nextDouble();</code></pre><ul><li><p>数值运算符</p><blockquote><p>+、-、*、/、%</p></blockquote></li><li><p>逻辑运算符<br><code>&amp;&amp;</code> <code>||</code> <code>!</code> <code>^</code>(异或：相同才为假)<br><code>&amp;</code> <code>|</code> <code>^</code> 位运算符：会先化成二进制对二进制码进行分析</p></li><li><p>运算符的优先级</p></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598686523840-d1395ecf-7d3c-416b-8ce8-5d11a0e3f313.png#align=left&display=inline&height=302&margin=%5Bobject%20Object%5D&originHeight=552&originWidth=543&size=0&status=done&style=none&width=297"></p><h2 id="三、程序三大基本结构"><a href="#三、程序三大基本结构" class="headerlink" title="三、程序三大基本结构"></a>三、程序三大基本结构</h2><h3 id="顺序结构"><a href="#顺序结构" class="headerlink" title="顺序结构"></a>顺序结构</h3><h3 id="选择结构"><a href="#选择结构" class="headerlink" title="选择结构"></a>选择结构</h3><ul><li>if(){} else{}</li><li>switch</li></ul><pre><code class="java">public class Test &#123;   public static void main(String args[])&#123;      //char grade = args[0].charAt(0);      char grade = &#39;C&#39;;      switch(grade)      &#123;         case &#39;A&#39; :            System.out.println(&quot;优秀&quot;);            break;         case &#39;B&#39; :         case &#39;C&#39; :            System.out.println(&quot;良好&quot;);            break;         case &#39;D&#39; :            System.out.println(&quot;及格&quot;);            break;         case &#39;F&#39; :            System.out.println(&quot;你需要再努力努力&quot;);            break;         default :            System.out.println(&quot;未知等级&quot;);      &#125;      System.out.println(&quot;你的等级是 &quot; + grade);   &#125;&#125;</code></pre><ul><li><strong>条件表达式</strong></li></ul><pre><code class="java">System.out.println((num % 2 == 0) ? &quot;num is even&quot; : &quot;num is odd&quot;);</code></pre><h3 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h3><ul><li>while () {}</li><li>do {} while ();</li><li>for () {}</li><li>关于 break（跳出该级别的 for 循环）和 continue（后面的语句不读）</li><li>关于 return</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598686523958-c57b6b4d-e802-44e1-adc6-276167476c3d.png#align=left&display=inline&height=236&margin=%5Bobject%20Object%5D&originHeight=328&originWidth=530&size=0&status=done&style=shadow&width=381"></p><ul><li>关于<strong>增强的 for 循环</strong>，在模板章节，配合 vector 使用，并发控制，高效使用</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598686523773-6d1af202-9aa9-4789-b931-b0671aac432f.png#align=left&display=inline&height=255&margin=%5Bobject%20Object%5D&originHeight=781&originWidth=1128&size=0&status=done&style=none&width=369"><br>缺点：看不见索引</p><h2 id="四、方法"><a href="#四、方法" class="headerlink" title="四、方法"></a>四、方法</h2>]]></content>
      
      
      <categories>
          
          <category> Language </category>
          
          <category> JAVA </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[转]操作系统核心知识点</title>
      <link href="blog/spobqi/"/>
      <url>blog/spobqi/</url>
      
        <content type="html"><![CDATA[<blockquote><blockquote><ul><li>本文转载自：<a href="https://www.cnblogs.com/cxuanBlog/p/13297199.html">5 万字、97 张图总结操作系统核心知识点 - 程序员 cxuan - 博客园</a></li></ul></blockquote></blockquote><blockquote><ul><li>添加部分细节自己写的内容</li></ul></blockquote><p>这不是一篇教你如何创建一个操作系统的文章，相反，这是一篇指导性文章，教你从几个方面来理解操作系统。首先你需要知道你为什么要看这篇文章以及为什么要学习操作系统。</p><h2 id="搞清楚几个问题"><a href="#搞清楚几个问题" class="headerlink" title="搞清楚几个问题"></a>搞清楚几个问题</h2><p>首先你要搞明白你学习操作系统的目的是什么？操作系统的重要性如何？学习操作系统会给我带来什么？下面我会从这几个方面为你回答下。</p><p>操作系统也是一种软件，但是操作系统是一种非常复杂的软件。操作系统提供了几种抽象模型</p><ul><li>文件：对 I/O 设备的抽象</li><li>虚拟内存：对程序存储器的抽象</li><li>进程：对一个正在运行程序的抽象</li><li>虚拟机：对整个操作系统的抽象</li></ul><p>这些抽象和我们的日常开发息息相关。搞清楚了操作系统是如何抽象的，才能培养我们的抽象性思维和开发思路。</p><p>很多问题都和操作系统相关，操作系统是解决这些问题的基础。如果你不学习操作系统，可能会想着从框架层面来解决，那是你了解的还不够深入，当你学习了操作系统后，能够培养你的全局性思维。</p><p>学习操作系统我们能够有效的解决<code>并发</code>问题，并发几乎是互联网的重中之重了，这也从侧面说明了学习操作系统的重要性。</p><p>学习操作系统的重点不是让你从头制造一个操作系统，而是告诉你<strong>操作系统是如何工作的</strong>，能够让你对计算机底层有所了解，打实你的基础。</p><p>相信你一定清楚什么是编程</p><p><strong>Data structures + Algorithms = Programming</strong></p><p>操作系统内部会涉及到众多的数据结构和算法描述，能够让你了解算法的基础上，让你编写更优秀的程序。</p><p>我认为可以把计算机比作一栋楼</p><p>计算机的底层相当于就是楼的根基，计算机应用相当于就是楼的外形，而操作系统就相当于是告诉你大楼的构造原理，编写高质量的软件就相当于是告诉你构建一个稳定的房子。</p><h2 id="认识操作系统"><a href="#认识操作系统" class="headerlink" title="认识操作系统"></a>认识操作系统</h2><p>在了解操作系统前，你需要先知道一下什么是计算机系统：现代计算机系统由<strong>一个或多个处理器、主存、打印机、键盘、鼠标、显示器、网络接口以及各种输入/输出设备构成的系统</strong>。这些都属于<code>硬件</code>的范畴。我们程序员不会直接和这些硬件打交道，并且每位程序员不可能会掌握所有计算机系统的细节。</p><p>所以计算机科学家在硬件的基础之上，安装了一层软件，这层软件能够根据用户输入的指令达到控制硬件的效果，从而满足用户的需求，这样的软件称为 <code>操作系统</code>，它的任务就是为用户程序提供一个更好、更简单、更清晰的计算机模型。也就是说，操作系统相当于是一个中间层，为用户层和硬件提供各自的借口，屏蔽了不同应用和硬件之间的差异，达到统一标准的作用。</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829342-133c5955-ce6b-4c7a-9b0e-74e4a24c0f14.png#align=left&display=inline&height=401&margin=%5Bobject%20Object%5D&originHeight=401&originWidth=698&size=0&status=done&style=none&width=698"></p><p>上面一个操作系统的简化图，最底层是硬件，硬件包括<strong>芯片、电路板、磁盘、键盘、显示器</strong>等我们上面提到的设备，在硬件之上是软件。大部分计算机有两种运行模式：<code>内核态</code> 和 <code>用户态</code>，软件中最基础的部分是<code>操作系统</code>，它运行在 <code>内核态</code> 中。操作系统具有硬件的访问权，可以执行机器能够运行的任何指令。软件的其余部分运行在 <code>用户态</code> 下。</p><p>在大概了解到操作系统之后，我们先来认识一下硬件都有哪些</p><h2 id="计算机硬件"><a href="#计算机硬件" class="headerlink" title="计算机硬件"></a>计算机硬件</h2><p>计算机硬件是计算机的重要组成部分，其中包含了 5 个重要的组成部分：<strong>运算器、控制器、存储器、输入设备、输出设备</strong>。</p><ul><li><code>运算器</code>：运算器最主要的功能是对数据和信息进行加工和运算。它是计算机中执行算数和各种逻辑运算的部件。运算器的基本运算包括加、减、乘、除、移位等操作，这些是由 <code>算术逻辑单元(Arithmetic&amp;logical Unit)</code> 实现的。而运算器主要由算数逻辑单元和寄存器构成。</li><li><code>控制器</code>：指按照指定顺序改变主电路或控制电路的部件，它主要起到了控制命令执行的作用，完成协调和指挥整个计算机系统的操作。控制器是由程序计数器、指令寄存器、解码译码器等构成。</li></ul><blockquote><p>运算器和控制器共同组成了 CPU</p></blockquote><ul><li><code>存储器</code>：存储器就是计算机的<code>记忆设备</code>，顾名思义，存储器可以保存信息。存储器分为两种，一种是主存，也就是内存，它是 CPU 主要交互对象，还有一种是外存，比如硬盘软盘等。下面是现代计算机系统的存储架构</li><li><code>输入设备</code>：输入设备是给计算机获取外部信息的设备，它主要包括键盘和鼠标。</li><li><code>输出设备</code>：输出设备是给用户呈现根据输入设备获取的信息经过一系列的计算后得到显示的设备，它主要包括显示器、打印机等。</li></ul><p>这五部分也是冯诺伊曼的体系结构，它认为计算机必须具有如下功能：</p><p>把需要的程序和数据送至计算机中。必须具有长期记忆程序、数据、中间结果及最终运算结果的能力。能够完成各种算术、逻辑运算和数据传送等数据加工处理的能力。能够根据需要控制程序走向，并能根据指令控制机器的各部件协调操作。能够按照要求将处理结果输出给用户。</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829342-9ed0fc8c-06fb-431d-8db6-2caaca0abc0f.png#align=left&display=inline&height=287&margin=%5Bobject%20Object%5D&originHeight=287&originWidth=721&size=0&status=done&style=none&width=721"></p><p>下面是一张 intel 家族产品图，是一个详细的计算机硬件分类，我们在根据图中涉及到硬件进行介绍</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829351-810b3b3e-2849-45d3-96c8-62280633f4a6.png#align=left&display=inline&height=534&margin=%5Bobject%20Object%5D&originHeight=534&originWidth=747&size=0&status=done&style=none&width=747"></p><ul><li><code>总线(Buses)</code>：在整个系统中运行的是称为总线的电气管道的集合，这些总线在组件之间来回传输字节信息。通常总线被设计成传送定长的字节块，也就是 <code>字(word)</code>。字中的字节数（字长）是一个基本的系统参数，各个系统中都不尽相同。现在大部分的字都是 4 个字节（32 位）或者 8 个字节（64 位）。</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829372-677cad04-111e-4904-a865-109bf7e95c9c.png#align=left&display=inline&height=280&margin=%5Bobject%20Object%5D&originHeight=280&originWidth=731&size=0&status=done&style=none&width=731"></p><ul><li><code>I/O 设备(I/O Devices)</code>：Input/Output 设备是系统和外部世界的连接。上图中有四类 I/O 设备：用于用户输入的键盘和鼠标，用于用户输出的显示器，一个磁盘驱动用来长时间的保存数据和程序。刚开始的时候，可执行程序就保存在磁盘上。<br>每个 I/O 设备连接 I/O 总线都被称为<code>控制器(controller)</code> 或者是 <code>适配器(Adapter)</code>。控制器和适配器之间的主要区别在于封装方式。控制器是 I/O 设备本身或者系统的主印制板电路（通常称作主板）上的芯片组。而适配器则是一块插在主板插槽上的卡。无论组织形式如何，它们的最终目的都是彼此交换信息。</li><li><code>主存(Main Memory)</code>，主存是一个<code>临时存储设备</code>，而不是永久性存储，磁盘是 <code>永久性存储</code> 的设备。主存既保存程序，又保存处理器执行流程所处理的数据。从物理组成上说，主存是由一系列 <code>DRAM(dynamic random access memory)</code> 动态随机存储构成的集合。逻辑上说，内存就是一个线性的字节数组，有它唯一的地址编号，从 0 开始。一般来说，组成程序的每条机器指令都由不同数量的字节构成，C 程序变量相对应的数据项的大小根据类型进行变化。比如，在 Linux 的 x86-64 机器上，short 类型的数据需要 2 个字节，int 和 float 需要 4 个字节，而 long 和 double 需要 8 个字节。</li><li><code>处理器(Processor)</code>，<code>CPU(central processing unit)</code> 或者简单的处理器，是解释（并执行）存储在主存储器中的指令的引擎。处理器的核心大小为一个字的存储设备（或寄存器），称为<code>程序计数器(PC)</code>。在任何时刻，PC 都指向主存中的某条机器语言指令（即含有该条指令的地址）。<br>从系统通电开始，直到系统断电，处理器一直在不断地执行程序计数器指向的指令，再更新程序计数器，使其指向下一条指令。处理器根据其指令集体系结构定义的指令模型进行操作。在这个模型中，指令按照严格的顺序执行，执行一条指令涉及执行一系列的步骤。处理器从程序计数器指向的内存中读取指令，解释指令中的位，执行该指令指示的一些简单操作，然后更新程序计数器以指向下一条指令。指令与指令之间可能连续，可能不连续（比如 jmp 指令就不会顺序读取）</li></ul><p>下面是 CPU 可能执行简单操作的几个步骤</p><ul><li><code>加载(Load)</code>：从主存中拷贝一个字节或者一个字到内存中，覆盖寄存器先前的内容</li><li><code>存储(Store)</code>：将寄存器中的字节或字复制到主存储器中的某个位置，从而覆盖该位置的先前内容</li><li><code>操作(Operate)</code>：把两个寄存器的内容复制到 <code>ALU(Arithmetic logic unit)</code> 。把两个字进行算术运算，并把结果存储在寄存器中，重写寄存器先前的内容。</li></ul><blockquote><p>算术逻辑单元（ALU）是对数字二进制数执行算术和按位运算的组合数字电子电路。</p></blockquote><ul><li><code>跳转(jump)</code>：从指令中抽取一个字，把这个字复制到<code>程序计数器(PC)</code> 中，覆盖原来的值</li></ul><h2 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h2><p>关于进程和线程，你需要理解下面这张脑图中的重点</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829389-4c3de174-e023-4600-b910-b01112bd2f4c.png#align=left&display=inline&height=736&margin=%5Bobject%20Object%5D&originHeight=736&originWidth=734&size=0&status=done&style=none&width=734"></p><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>操作系统中最核心的概念就是 <code>进程</code>，进程是对正在运行中的程序的一个抽象。操作系统的其他所有内容都是围绕着进程展开的。</p><p>在多道程序处理的系统中，CPU 会在<code>进程</code>间快速切换，使每个程序运行几十或者几百毫秒。然而，严格意义来说，在某一个瞬间，CPU 只能运行一个进程，然而我们如果把时间定位为 1 秒内的话，它可能运行多个进程。这样就会让我们产生<code>并行</code>的错觉。因为 CPU 执行速度很快，进程间的换进换出也非常迅速，因此我们很难对多个并行进程进行跟踪。所以，操作系统的设计者开发了用于描述并行的一种概念模型（顺序进程），使得并行更加容易理解和分析。</p><h3 id="进程模型"><a href="#进程模型" class="headerlink" title="进程模型"></a>进程模型</h3><p>一个进程就是一个正在执行的程序的实例，进程也包括程序计数器、寄存器和变量的当前值。从概念上来说，每个进程都有各自的虚拟 CPU，但是实际情况是 CPU 会在各个进程之间进行来回切换。</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829609-9880b940-5163-45d4-8ef6-b559ab53b55d.png#align=left&display=inline&height=351&margin=%5Bobject%20Object%5D&originHeight=351&originWidth=455&size=0&status=done&style=none&width=455"></p><p>如上图所示，这是一个具有 4 个程序的多道处理程序，在进程不断切换的过程中，程序计数器也在不同的变化。</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829415-2d4059be-d447-4abf-8e77-2df51d6cc6a1.png#align=left&display=inline&height=338&margin=%5Bobject%20Object%5D&originHeight=338&originWidth=647&size=0&status=done&style=none&width=647"></p><p>在上图中，这 4 道程序被抽象为 4 个拥有各自控制流程（即每个自己的程序计数器）的进程，并且每个程序都独立的运行。当然，实际上只有一个物理程序计数器，每个程序要运行时，其逻辑程序计数器会装载到物理程序计数器中。当程序运行结束后，其物理程序计数器就会是真正的程序计数器，然后再把它放回进程的逻辑计数器中。</p><p>从下图我们可以看到，在观察足够长的一段时间后，所有的进程都运行了，<strong>但在任何一个给定的瞬间仅有一个进程真正运行</strong>。</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829611-a49b5e88-0d0e-42c3-a103-485b6e5c984b.png#align=left&display=inline&height=274&margin=%5Bobject%20Object%5D&originHeight=274&originWidth=578&size=0&status=done&style=none&width=578"></p><p>因此，当我们说一个 CPU 只能真正一次运行一个进程的时候，即使有 2 个核（或 CPU），<strong>每一个核也只能一次运行一个线程</strong>。</p><p>由于 CPU 会在各个进程之间来回快速切换，所以每个进程在 CPU 中的运行时间是无法确定的。并且当同一个进程再次在 CPU 中运行时，其在 CPU 内部的运行时间往往也是不固定的。</p><p>这里的关键思想是<code>认识到一个进程所需的条件</code>，进程是某一类特定活动的总和，它有程序、输入输出以及状态。</p><h3 id="进程的创建"><a href="#进程的创建" class="headerlink" title="进程的创建"></a>进程的创建</h3><p>操作系统需要一些方式来创建进程。下面是一些创建进程的方式</p><ul><li>系统初始化（init）：启动操作系统时，通常会创建若干个进程。</li><li>正在运行的程序执行了创建进程的系统调用（比如 fork）</li><li>用户请求创建一个新进程：在许多交互式系统中，输入一个命令或者双击图标就可以启动程序，以上任意一种操作都可以选择开启一个新的进程，在基本的 UNIX 系统中运行 X，新进程将接管启动它的窗口。</li><li>初始化一个批处理工作</li></ul><p>从技术上讲，在所有这些情况下，让现有流程执行流程是通过创建系统调用来创建新流程的。该进程可能是正在运行的用户进程，是从键盘或鼠标调用的系统进程或批处理程序。这些就是系统调用创建新进程的过程。该系统调用告诉操作系统创建一个新进程，并直接或间接指示在其中运行哪个程序。</p><p>在 UNIX 中，仅有一个系统调用来创建一个新的进程，这个系统调用就是 <code>fork</code>。这个调用会创建一个与调用进程相关的副本。在 fork 后，一个父进程和子进程会有相同的<code>内存映像</code>，相同的环境字符串和相同的打开文件。</p><p>在 Windows 中，情况正相反，一个简单的 Win32 功能调用 <code>CreateProcess</code>，会处理流程创建并将正确的程序加载到新的进程中。这个调用会有 10 个参数，包括了需要执行的程序、输入给程序的命令行参数、各种安全属性、有关打开的文件是否继承控制位、优先级信息、进程所需要创建的窗口规格以及指向一个结构的指针，在该结构中新创建进程的信息被返回给调用者。<strong>在 Windows 中，从一开始父进程的地址空间和子进程的地址空间就是不同的</strong>。</p><h3 id="进程的终止"><a href="#进程的终止" class="headerlink" title="进程的终止"></a>进程的终止</h3><p>进程在创建之后，它就开始运行并做完成任务。然而，没有什么事儿是永不停歇的，包括进程也一样。进程早晚会发生终止，但是通常是由于以下情况触发的</p><ul><li><code>正常退出(自愿的)</code> ： 多数进程是由于完成了工作而终止。当编译器完成了所给定程序的编译之后，编译器会执行一个系统调用告诉操作系统它完成了工作。这个调用在 UNIX 中是 <code>exit</code> ，在 Windows 中是 <code>ExitProcess</code>。</li><li><code>错误退出(自愿的)</code>：比如执行一条不存在的命令，于是编译器就会提醒并退出。</li><li><code>严重错误(非自愿的)</code></li><li><code>被其他进程杀死(非自愿的)</code> ： 某个进程执行系统调用告诉操作系统杀死某个进程。在 UNIX 中，这个系统调用是 kill。在 Win32 中对应的函数是 <code>TerminateProcess</code>（注意不是系统调用）。</li></ul><h3 id="进程的层次结构"><a href="#进程的层次结构" class="headerlink" title="进程的层次结构"></a>进程的层次结构</h3><p>在一些系统中，当一个进程创建了其他进程后，父进程和子进程就会以某种方式进行关联。子进程它自己就会创建更多进程，从而形成一个进程层次结构。</p><h4 id="UNIX-进程体系"><a href="#UNIX-进程体系" class="headerlink" title="UNIX 进程体系"></a>UNIX 进程体系</h4><p>在 UNIX 中，进程和它的所有子进程以及子进程的子进程共同组成一个进程组。当用户从键盘中发出一个信号后，该信号被发送给当前与键盘相关的进程组中的所有成员（它们通常是在当前窗口创建的所有活动进程）。每个进程可以分别捕获该信号、忽略该信号或采取默认的动作，即被信号 kill 掉。整个操作系统中所有的进程都隶属于一个单个以 init 为根的进程树。</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829468-bff503cb-cf97-4853-aca3-35db5bb67312.png#align=left&display=inline&height=192&margin=%5Bobject%20Object%5D&originHeight=192&originWidth=615&size=0&status=done&style=none&width=615"></p><h4 id="Windows-进程体系"><a href="#Windows-进程体系" class="headerlink" title="Windows 进程体系"></a>Windows 进程体系</h4><p>相反，Windows 中没有进程层次的概念，Windows 中所有进程都是平等的，唯一类似于层次结构的是在创建进程的时候，父进程得到一个特别的令牌（称为句柄），该句柄可以用来控制子进程。然而，这个令牌可能也会移交给别的操作系统，这样就不存在层次结构了。而在 UNIX 中，进程不能剥夺其子进程的 <code>进程权</code>。（这样看来，还是 Windows 比较<code>渣</code>）。</p><h3 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h3><p>尽管每个进程是一个独立的实体，有其自己的程序计数器和内部状态，但是，进程之间仍然需要相互帮助。当一个进程开始运行时，它可能会经历下面这几种状态</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829472-6b2e277f-f4b9-4f38-805d-e9ac73f33129.png#align=left&display=inline&height=495&margin=%5Bobject%20Object%5D&originHeight=495&originWidth=734&size=0&status=done&style=none&width=734"></p><p>图中会涉及三种状态</p><ol><li><code>运行态</code>，运行态指的就是进程实际占用 CPU 时间片运行时</li><li><code>就绪态</code>，就绪态指的是可运行，但因为其他进程正在运行而处于就绪状态</li><li><code>阻塞态</code>，除非某种外部事件发生，否则进程不能运行</li></ol><h3 id="进程的实现"><a href="#进程的实现" class="headerlink" title="进程的实现"></a>进程的实现</h3><p>操作系统为了执行进程间的切换，会维护着一张表，这张表就是 <code>进程表(process table)</code>。每个进程占用一个进程表项。该表项包含了进程状态的重要信息，包括程序计数器、堆栈指针、内存分配状况、所打开文件的状态、账号和调度信息，以及其他在进程由运行态转换到就绪态或阻塞态时所必须保存的信息。</p><p>下面展示了一个典型系统中的关键字段</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829487-6d8a6e92-d068-48a8-b5a0-9e5b74f9ab3f.png#align=left&display=inline&height=500&margin=%5Bobject%20Object%5D&originHeight=500&originWidth=749&size=0&status=done&style=none&width=749"></p><p>第一列内容与<code>进程管理</code>有关，第二列内容与 <code>存储管理</code>有关，第三列内容与<code>文件管理</code>有关。</p><p>现在我们应该对进程表有个大致的了解了，就可以在对单个 CPU 上如何运行多个顺序进程的错觉做更多的解释。与每一 I/O 类相关联的是一个称作 <code>中断向量(interrupt vector)</code> 的位置（靠近内存底部的固定区域）。它包含中断服务程序的入口地址。假设当一个磁盘中断发生时，用户进程 3 正在运行，则中断硬件将程序计数器、程序状态字、有时还有一个或多个寄存器压入堆栈，计算机随即跳转到中断向量所指示的地址。这就是硬件所做的事情。然后软件就随即接管一切剩余的工作。</p><p>当中断结束后，操作系统会调用一个 C 程序来处理中断剩下的工作。在完成剩下的工作后，会使某些进程就绪，接着调用调度程序，决定随后运行哪个进程。然后将控制权转移给一段汇编语言代码，为当前的进程装入寄存器值以及内存映射并启动该进程运行，下面显示了中断处理和调度的过程。</p><ol><li>硬件压入堆栈程序计数器等</li><li>硬件从中断向量装入新的程序计数器</li><li>汇编语言过程保存寄存器的值</li><li>汇编语言过程设置新的堆栈</li><li>C 中断服务器运行（典型的读和缓存写入）</li><li>调度器决定下面哪个程序先运行</li><li>C 过程返回至汇编代码</li><li>汇编语言过程开始运行新的当前进程</li></ol><p>一个进程在执行过程中可能被中断数千次，但关键每次中断后，被中断的进程都返回到与中断发生前完全相同的状态。</p><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>在传统的操作系统中，每个进程都有一个地址空间和一个控制线程。事实上，这是大部分进程的定义。不过，在许多情况下，经常存在同一地址空间中运行多个控制线程的情形，这些线程就像是分离的进程。下面我们就着重探讨一下什么是线程</p><h3 id="线程的使用"><a href="#线程的使用" class="headerlink" title="线程的使用"></a>线程的使用</h3><p>或许这个疑问也是你的疑问，为什么要在进程的基础上再创建一个线程的概念，准确的说，这其实是进程模型和线程模型的讨论，回答这个问题，可能需要分三步来回答</p><ul><li>多线程之间会共享同一块地址空间和所有可用数据的能力，这是进程所不具备的</li><li>线程要比进程<code>更轻量级</code>，由于线程更轻，所以它比进程更容易创建，也更容易撤销。在许多系统中，创建一个线程要比创建一个进程快 10 - 100 倍。</li><li>第三个原因可能是性能方面的探讨，如果多个线程都是 CPU 密集型的，那么并不能获得性能上的增强，但是如果存在着大量的计算和大量的 I/O 处理，拥有多个线程能在这些活动中彼此重叠进行，从而会加快应用程序的执行速度</li></ul><h3 id="经典的线程模型"><a href="#经典的线程模型" class="headerlink" title="经典的线程模型"></a>经典的线程模型</h3><p>进程中拥有一个执行的线程，通常简写为 <code>线程(thread)</code>。线程会有程序计数器，用来记录接着要执行哪一条指令；线程实际上 CPU 上调度执行的实体。</p><p>下图我们可以看到三个传统的进程，每个进程有自己的地址空间和单个控制线程。每个线程都在不同的地址空间中运行</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829491-73cfd311-e3e5-4381-886b-f904f3c8ca5c.png#align=left&display=inline&height=466&margin=%5Bobject%20Object%5D&originHeight=466&originWidth=658&size=0&status=done&style=none&width=658"></p><p>下图中，我们可以看到有一个进程三个线程的情况。每个线程都在相同的地址空间中运行。</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829501-7e5370fc-b9ec-4804-a862-9c86e00bf231.png#align=left&display=inline&height=429&margin=%5Bobject%20Object%5D&originHeight=429&originWidth=640&size=0&status=done&style=none&width=640"></p><p>线程不像是进程那样具备较强的独立性。同一个进程中的所有线程都会有完全一样的地址空间，这意味着它们也共享同样的全局变量。由于每个线程都可以访问进程地址空间内每个内存地址，<strong>因此一个线程可以读取、写入甚至擦除另一个线程的堆栈</strong>。线程之间除了共享同一内存空间外，还具有如下不同的内容</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829530-1ce4e3bb-f3b4-4fae-bd6b-2a09cb86e2d3.png#align=left&display=inline&height=333&margin=%5Bobject%20Object%5D&originHeight=333&originWidth=583&size=0&status=done&style=none&width=583"></p><p>上图左边的是同一个进程中<code>每个线程共享</code>的内容，上图右边是<code>每个线程</code>中的内容。也就是说左边的列表是进程的属性，右边的列表是线程的属性。</p><p><strong>线程之间的状态转换和进程之间的状态转换是一样的</strong>。</p><p>每个线程都会有自己的堆栈，如下图所示</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829586-41932660-4ab5-42e2-bbb1-bbd660b183f6.png#align=left&display=inline&height=482&margin=%5Bobject%20Object%5D&originHeight=482&originWidth=682&size=0&status=done&style=none&width=682"></p><h4 id="线程系统调用"><a href="#线程系统调用" class="headerlink" title="线程系统调用"></a>线程系统调用</h4><p>进程通常会从当前的某个单线程开始，然后这个线程通过调用一个库函数（比如 <code>thread_create</code> ）创建新的线程。线程创建的函数会要求指定新创建线程的名称。创建的线程通常都返回一个线程标识符，该标识符就是新线程的名字。</p><p>当一个线程完成工作后，可以通过调用一个函数（比如 <code>thread_exit</code>）来退出。紧接着线程消失，状态变为终止，不能再进行调度。在某些线程的运行过程中，可以通过调用函数例如 <code>thread_join</code> ，表示一个线程可以等待另一个线程退出。这个过程阻塞调用线程直到等待特定的线程退出。在这种情况下，线程的创建和终止非常类似于进程的创建和终止。</p><p>另一个常见的线程是调用 <code>thread_yield</code>，它允许线程自动放弃 CPU 从而让另一个线程运行。这样一个调用还是很重要的，因为不同于进程，线程是无法利用时钟中断强制让线程让出 CPU 的。</p><h3 id="POSIX-线程"><a href="#POSIX-线程" class="headerlink" title="POSIX 线程"></a>POSIX 线程</h3><p><code>POSIX 线程 通常称为 pthreads</code>是一种独立于语言而存在的执行模型，以及并行执行模型。</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829568-3bded50a-8029-4644-9e42-c2c6ddf60ca1.png#align=left&display=inline&height=645&margin=%5Bobject%20Object%5D&originHeight=645&originWidth=639&size=0&status=done&style=none&width=639"></p><p>它允许程序控制时间上重叠的多个不同的工作流程。每个工作流程都称为一个线程，可以通过调用 POSIX Threads API 来实现对这些流程的创建和控制。可以把它理解为线程的标准。</p><blockquote><p>POSIX Threads 的实现在许多类似且符合 POSIX 的操作系统上可用，例如 <strong>FreeBSD、NetBSD、OpenBSD、Linux、macOS、Android、Solaris</strong>，它在现有 Windows API 之上实现了<strong>pthread</strong>。<br>IEEE 是世界上最大的技术专业组织，致力于为人类的利益而发展技术。</p></blockquote><table><thead><tr><th>线程调用</th><th>描述</th></tr></thead><tbody><tr><td>pthread_create</td><td>创建一个新线程</td></tr><tr><td>pthread_exit</td><td>结束调用的线程</td></tr><tr><td>pthread_join</td><td>等待一个特定的线程退出</td></tr><tr><td>pthread_yield</td><td>释放 CPU 来运行另外一个线程</td></tr><tr><td>pthread_attr_init</td><td>创建并初始化一个线程的属性结构</td></tr><tr><td>pthread_attr_destory</td><td>删除一个线程的属性结构</td></tr></tbody></table><p>所有的 Pthreads 都有特定的属性，每一个都含有标识符、一组寄存器（包括程序计数器）和一组存储在结构中的属性。这个属性包括堆栈大小、调度参数以及其他线程需要的项目。</p><h3 id="线程实现"><a href="#线程实现" class="headerlink" title="线程实现"></a>线程实现</h3><p>主要有三种实现方式</p><ul><li>在用户空间中实现线程；</li><li>在内核空间中实现线程；</li><li>在用户和内核空间中混合实现线程。</li></ul><p>下面我们分开讨论一下</p><h4 id="在用户空间中实现线程"><a href="#在用户空间中实现线程" class="headerlink" title="在用户空间中实现线程"></a>在用户空间中实现线程</h4><p>第一种方法是把整个线程包放在用户空间中，内核对线程一无所知，它不知道线程的存在。所有的这类实现都有同样的通用结构</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829565-1733358e-dbe8-4e1e-ab32-50b95d98a6e3.png#align=left&display=inline&height=466&margin=%5Bobject%20Object%5D&originHeight=466&originWidth=599&size=0&status=done&style=none&width=599"></p><p>线程在运行时系统之上运行，运行时系统是管理线程过程的集合，包括前面提到的四个过程： pthread_create, pthread_exit, pthread_join 和 pthread_yield。</p><h3 id="在内核中实现线程"><a href="#在内核中实现线程" class="headerlink" title="在内核中实现线程"></a>在内核中实现线程</h3><p>当某个线程希望创建一个新线程或撤销一个已有线程时，它会进行一个系统调用，这个系统调用通过对线程表的更新来完成线程创建或销毁工作。</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829600-91569966-c35c-4db1-858b-f7fcae7729c3.png#align=left&display=inline&height=515&margin=%5Bobject%20Object%5D&originHeight=515&originWidth=600&size=0&status=done&style=none&width=600"></p><p>内核中的线程表持有每个线程的寄存器、状态和其他信息。这些信息和用户空间中的线程信息相同，但是位置却被放在了内核中而不是用户空间中。另外，内核还维护了一张进程表用来跟踪系统状态。</p><p>所有能够阻塞的调用都会通过系统调用的方式来实现，当一个线程阻塞时，内核可以进行选择，是运行在同一个进程中的另一个线程（如果有就绪线程的话）还是运行一个另一个进程中的线程。但是在用户实现中，运行时系统始终运行自己的线程，直到内核剥夺它的 CPU 时间片（或者没有可运行的线程存在了）为止。</p><h3 id="混合实现"><a href="#混合实现" class="headerlink" title="混合实现"></a>混合实现</h3><p>结合用户空间和内核空间的优点，设计人员采用了一种<code>内核级线程</code>的方式，然后将用户级线程与某些或者全部内核线程多路复用起来</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829624-481cc859-db6d-4516-8dc4-6ea9f958c022.png#align=left&display=inline&height=463&margin=%5Bobject%20Object%5D&originHeight=463&originWidth=647&size=0&status=done&style=none&width=647"></p><p>在这种模型中，编程人员可以自由控制用户线程和内核线程的数量，具有很大的灵活度。采用这种方法，内核只识别内核级线程，并对其进行调度。其中一些内核级线程会被多个用户级线程多路复用。</p><h2 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h2><p>进程是需要频繁的和其他进程进行交流的。下面我们会一起讨论有关 <code>进程间通信(Inter Process Communication, IPC)</code> 的问题。大致来说，进程间的通信机制可以分为 6 种</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829616-22b9e251-36fa-4a65-8102-204b899c01ca.png#align=left&display=inline&height=602&margin=%5Bobject%20Object%5D&originHeight=602&originWidth=772&size=0&status=done&style=none&width=772"></p><p>下面我们分别对其进行概述</p><h3 id="信号-signal"><a href="#信号-signal" class="headerlink" title="信号 signal"></a>信号 signal</h3><p>信号是 UNIX 系统最先开始使用的进程间通信机制，因为 Linux 是继承于 UNIX 的，所以 Linux 也支持信号机制，通过向一个或多个进程发送<code>异步事件信号</code>来实现，信号可以从键盘或者访问不存在的位置等地方产生；信号通过 shell 将任务发送给子进程。</p><p>你可以在 Linux 系统上输入 <code>kill -l</code> 来列出系统使用的信号，下面是我提供的一些信号</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829652-e25e8aaa-523f-49e7-91a6-13af7872483a.png#align=left&display=inline&height=269&margin=%5Bobject%20Object%5D&originHeight=269&originWidth=736&size=0&status=done&style=none&width=736"></p><p>进程可以选择忽略发送过来的信号，但是有两个是不能忽略的：<code>SIGSTOP</code> 和 <code>SIGKILL</code> 信号。SIGSTOP 信号会通知当前正在运行的进程执行关闭操作，SIGKILL 信号会通知当前进程应该被杀死。除此之外，进程可以选择它想要处理的信号，进程也可以选择阻止信号，如果不阻止，可以选择自行处理，也可以选择进行内核处理。如果选择交给内核进行处理，那么就执行默认处理。</p><p>操作系统会中断目标程序的进程来向其发送信号、在任何非原子指令中，执行都可以中断，如果进程已经注册了新号处理程序，那么就执行进程，如果没有注册，将采用默认处理的方式。</p><h3 id="管道-pipe"><a href="#管道-pipe" class="headerlink" title="管道 pipe"></a>管道 pipe</h3><p>Linux 系统中的进程可以通过建立管道 pipe 进行通信</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829658-0cfbf5f9-97b3-4972-8205-7953cdab82b7.png#align=left&display=inline&height=413&margin=%5Bobject%20Object%5D&originHeight=413&originWidth=729&size=0&status=done&style=none&width=729"></p><p>在两个进程之间，可以建立一个通道，一个进程向这个通道里写入字节流，另一个进程从这个管道中读取字节流。管道是同步的，当进程尝试从空管道读取数据时，该进程会被阻塞，直到有可用数据为止。shell 中的<code>管线 pipelines</code> 就是用管道实现的，当 shell 发现输出</p><pre><code class="null">sort &lt;f | head</code></pre><p>它会创建两个进程，一个是 sort，一个是 head，sort，会在这两个应用程序之间建立一个管道使得 sort 进程的标准输出作为 head 程序的标准输入。sort 进程产生的输出就不用写到文件中了，如果管道满了系统会停止 sort 以等待 head 读出数据</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829684-0f55014e-302f-4dbe-9ea8-9ee4d6c9fdeb.png#align=left&display=inline&height=396&margin=%5Bobject%20Object%5D&originHeight=396&originWidth=488&size=0&status=done&style=none&width=488"></p><p>管道实际上就是 <code>|</code>，两个应用程序不知道有管道的存在，一切都是由 shell 管理和控制的。</p><h3 id="共享内存-shared-memory"><a href="#共享内存-shared-memory" class="headerlink" title="共享内存 shared memory"></a>共享内存 shared memory</h3><p>两个进程之间还可以通过共享内存进行进程间通信，其中两个或者多个进程可以访问公共内存空间。两个进程的共享工作是通过共享内存完成的，一个进程所作的修改可以对另一个进程可见(很像线程间的通信)。</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829708-7158a6ec-203c-42aa-96bb-7946e3fb959a.png#align=left&display=inline&height=249&margin=%5Bobject%20Object%5D&originHeight=249&originWidth=659&size=0&status=done&style=none&width=659"></p><p>在使用共享内存前，需要经过一系列的调用流程，流程如下</p><ul><li>创建共享内存段或者使用已创建的共享内存段<code>(shmget())</code></li><li>将进程附加到已经创建的内存段中<code>(shmat())</code></li><li>从已连接的共享内存段分离进程<code>(shmdt())</code></li><li>对共享内存段执行控制操作<code>(shmctl())</code></li></ul><h3 id="先入先出队列-FIFO"><a href="#先入先出队列-FIFO" class="headerlink" title="先入先出队列 FIFO"></a>先入先出队列 FIFO</h3><p>先入先出队列 FIFO 通常被称为 <code>命名管道(Named Pipes)</code>，命名管道的工作方式与常规管道非常相似，但是确实有一些明显的区别。未命名的管道没有备份文件：操作系统负责维护内存中的缓冲区，用来将字节从写入器传输到读取器。一旦写入或者输出终止的话，缓冲区将被回收，传输的数据会丢失。相比之下，命名管道具有支持文件和独特 API ，命名管道在文件系统中作为设备的专用文件存在。当所有的进程通信完成后，命名管道将保留在文件系统中以备后用。命名管道具有严格的 FIFO 行为</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829713-f872efe8-5031-4f02-89ad-8c8351a854c7.png#align=left&display=inline&height=192&margin=%5Bobject%20Object%5D&originHeight=192&originWidth=584&size=0&status=done&style=none&width=584"></p><p>写入的第一个字节是读取的第一个字节，写入的第二个字节是读取的第二个字节，依此类推。</p><h3 id="消息队列-Message-Queue"><a href="#消息队列-Message-Queue" class="headerlink" title="消息队列 Message Queue"></a>消息队列 Message Queue</h3><p>一听到消息队列这个名词你可能不知道是什么意思，消息队列是用来描述内核寻址空间内的内部链接列表。可以按几种不同的方式将消息按顺序发送到队列并从队列中检索消息。每个消息队列由 IPC 标识符唯一标识。消息队列有两种模式，一种是<code>严格模式</code>， 严格模式就像是 FIFO 先入先出队列似的，消息顺序发送，顺序读取。还有一种模式是 <code>非严格模式</code>，消息的顺序性不是非常重要。</p><h3 id="套接字-Socket"><a href="#套接字-Socket" class="headerlink" title="套接字 Socket"></a>套接字 Socket</h3><p>还有一种管理两个进程间通信的是使用 <code>socket</code>，socket 提供端到端的双相通信。一个套接字可以与一个或多个进程关联。就像管道有命令管道和未命名管道一样，套接字也有两种模式，套接字一般用于两个进程之间的网络通信，网络套接字需要来自诸如<code>TCP（传输控制协议）</code>或较低级别<code>UDP（用户数据报协议）</code>等基础协议的支持。</p><p>套接字有以下几种分类</p><ul><li><code>顺序包套接字(Sequential Packet Socket)</code>： 此类套接字为最大长度固定的数据报提供可靠的连接。此连接是双向的并且是顺序的。</li><li><code>数据报套接字(Datagram Socket)</code>：数据包套接字支持双向数据流。数据包套接字接受消息的顺序与发送者可能不同。</li><li><code>流式套接字(Stream Socket)</code>：流套接字的工作方式类似于电话对话，提供双向可靠的数据流。</li><li><code>原始套接字(Raw Socket)</code>： 可以使用原始套接字访问基础通信协议。</li></ul><h2 id="调度"><a href="#调度" class="headerlink" title="调度"></a>调度</h2><p>当一个计算机是多道程序设计系统时，会频繁的有很多进程或者线程来同时竞争 CPU 时间片。当两个或两个以上的进程/线程处于就绪状态时，就会发生这种情况。如果只有一个 CPU 可用，那么必须选择接下来哪个进程/线程可以运行。操作系统中有一个叫做 <code>调度程序(scheduler)</code> 的角色存在，它就是做这件事儿的，该程序使用的算法叫做 <code>调度算法(scheduling algorithm)</code> 。</p><h3 id="调度算法的分类"><a href="#调度算法的分类" class="headerlink" title="调度算法的分类"></a>调度算法的分类</h3><p>毫无疑问，不同的环境下需要不同的调度算法。之所以出现这种情况，是因为不同的应用程序和不同的操作系统有不同的目标。也就是说，在不同的系统中，调度程序的优化也是不同的。这里有必要划分出三种环境</p><ul><li><code>批处理(Batch)</code> : 商业领域</li><li><code>交互式(Interactive)</code> ： 交互式用户环境</li><li><code>实时(Real time)</code></li></ul><h3 id="批处理中的调度"><a href="#批处理中的调度" class="headerlink" title="批处理中的调度"></a>批处理中的调度</h3><p>现在让我们把目光从一般性的调度转换为特定的调度算法。下面我们会探讨在批处理中的调度。</p><h4 id="先来先服务"><a href="#先来先服务" class="headerlink" title="先来先服务"></a>先来先服务</h4><p>最简单的非抢占式调度算法的设计就是 <code>先来先服务(first-come,first-serverd)</code>。当第一个任务从外部进入系统时，将会立即启动并允许运行任意长的时间。它不会因为运行时间太长而中断。当其他作业进入时，它们排到就绪队列尾部。当正在运行的进程阻塞，处于等待队列的第一个进程就开始运行。当一个阻塞的进程重新处于就绪态时，它会像一个新到达的任务，会排在队列的末尾，即排在所有进程最后。</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829697-a9e6978f-5f26-4491-8a57-4691ea81546b.png#align=left&display=inline&height=622&margin=%5Bobject%20Object%5D&originHeight=622&originWidth=709&size=0&status=done&style=none&width=709"></p><p>这个算法的强大之处在于易于理解和编程，在这个算法中，一个单链表记录了所有就绪进程。要选取一个进程运行，只要从该队列的头部移走一个进程即可；要添加一个新的作业或者阻塞一个进程，只要把这个作业或进程附加在队列的末尾即可。这是很简单的一种实现。</p><h4 id="最短作业优先"><a href="#最短作业优先" class="headerlink" title="最短作业优先"></a>最短作业优先</h4><p>批处理中，第二种调度算法是 <code>最短作业优先(Shortest Job First)</code>，我们假设运行时间已知。例如，一家保险公司，因为每天要做类似的工作，所以人们可以相当精确地预测处理 1000 个索赔的一批作业需要多长时间。当输入队列中有若干个同等重要的作业被启动时，调度程序应使用最短优先作业算法</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829752-b3677366-5828-45be-9c62-d182dce0a26e.png#align=left&display=inline&height=200&margin=%5Bobject%20Object%5D&originHeight=200&originWidth=695&size=0&status=done&style=none&width=695"></p><blockquote><p>需要注意的是，在所有的进程都可以运行的情况下，最短作业优先的算法才是最优的。</p></blockquote><h4 id="最短剩余时间优先"><a href="#最短剩余时间优先" class="headerlink" title="最短剩余时间优先"></a>最短剩余时间优先</h4><p>最短作业优先的抢占式版本被称作为 <code>最短剩余时间优先(Shortest Remaining Time Next)</code> 算法。使用这个算法，调度程序总是选择剩余运行时间最短的那个进程运行。</p><h3 id="交互式系统中的调度"><a href="#交互式系统中的调度" class="headerlink" title="交互式系统中的调度"></a>交互式系统中的调度</h3><p>交互式系统中在个人计算机、服务器和其他系统中都是很常用的，所以有必要来探讨一下交互式调度</p><h4 id="轮询调度"><a href="#轮询调度" class="headerlink" title="轮询调度"></a>轮询调度</h4><p>一种最古老、最简单、最公平并且最广泛使用的算法就是 <code>轮询算法(round-robin)</code>。每个进程都会被分配一个时间段，称为<code>时间片(quantum)</code>，在这个时间片内允许进程运行。如果时间片结束时进程还在运行的话，则抢占一个 CPU 并将其分配给另一个进程。如果进程在时间片结束前阻塞或结束，则 CPU 立即进行切换。轮询算法比较容易实现。调度程序所做的就是维护一个可运行进程的列表，就像下图中的 a，当一个进程用完时间片后就被移到队列的末尾，就像下图的 b。</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829772-8a1f4a69-9934-4cf9-b1bd-80a69f410e13.png#align=left&display=inline&height=485&margin=%5Bobject%20Object%5D&originHeight=485&originWidth=724&size=0&status=done&style=none&width=724"></p><h4 id="优先级调度"><a href="#优先级调度" class="headerlink" title="优先级调度"></a>优先级调度</h4><p>轮询调度假设了所有的进程是同等重要的。但事实情况可能不是这样。例如，在一所大学中的等级制度，首先是院长，然后是教授、秘书、后勤人员，最后是学生。这种将外部情况考虑在内就实现了<code>优先级调度(priority scheduling)</code></p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829781-669962be-9966-4de1-be47-f3e9822459eb.png#align=left&display=inline&height=162&margin=%5Bobject%20Object%5D&originHeight=162&originWidth=678&size=0&status=done&style=none&width=678"></p><p>它的基本思想很明确，每个进程都被赋予一个优先级，优先级高的进程优先运行。</p><h4 id="多级队列"><a href="#多级队列" class="headerlink" title="多级队列"></a>多级队列</h4><p>最早使用优先级调度的系统是 <code>CTSS(Compatible TimeSharing System)</code>。CTSS 在每次切换前都需要将当前进程换出到磁盘，并从磁盘上读入一个新进程。为 CPU 密集型进程设置较长的时间片比频繁地分给他们很短的时间要更有效（减少交换次数）。另一方面，如前所述，长时间片的进程又会影响到响应时间，解决办法是设置优先级类。属于最高优先级的进程运行一个时间片，次高优先级进程运行 2 个时间片，再下面一级运行 4 个时间片，以此类推。当一个进程用完分配的时间片后，它被移到下一类。</p><h4 id="最短进程优先"><a href="#最短进程优先" class="headerlink" title="最短进程优先"></a>最短进程优先</h4><p>最短进程优先是根据进程过去的行为进行推测，并执行估计运行时间最短的那一个。假设每个终端上每条命令的预估运行时间为 <code>T0</code>，现在假设测量到其下一次运行时间为 <code>T1</code>，可以用两个值的加权来改进估计时间，即<code>aT0+ (1- 1)T1</code>。通过选择 a 的值，可以决定是尽快忘掉老的运行时间，还是在一段长时间内始终记住它们。当 a = 1/2 时，可以得到下面这个序列</p><p>![image-20200220120452410](/Users/mr.l/Library/Application Support/typora-user-images/image-20200220120452410.png)</p><p>可以看到，在三轮过后，T0 在新的估计值中所占比重下降至 1/8。</p><h4 id="保证调度"><a href="#保证调度" class="headerlink" title="保证调度"></a>保证调度</h4><p>一种完全不同的调度方法是对用户做出明确的性能保证。一种实际而且容易实现的保证是：若用户工作时有 n 个用户登录，则每个用户将获得 CPU 处理能力的 1/n。类似地，在一个有 n 个进程运行的单用户系统中，若所有的进程都等价，则每个进程将获得 1/n 的 CPU 时间。</p><h4 id="彩票调度"><a href="#彩票调度" class="headerlink" title="彩票调度"></a>彩票调度</h4><p>对用户进行承诺并在随后兑现承诺是一件好事，不过很难实现。但是存在着一种简单的方式，有一种既可以给出预测结果而又有一种比较简单的实现方式的算法，就是 <code>彩票调度(lottery scheduling)</code>算法。</p><p>其基本思想是为进程提供各种系统资源（例如 CPU 时间）的彩票。当做出一个调度决策的时候，就随机抽出一张彩票，拥有彩票的进程将获得该资源。在应用到 CPU 调度时，系统可以每秒持有 50 次抽奖，每个中奖者将获得比如 20 毫秒的 CPU 时间作为奖励。</p><h4 id="公平分享调度"><a href="#公平分享调度" class="headerlink" title="公平分享调度"></a>公平分享调度</h4><p>到目前为止，我们假设被调度的都是各个进程自身，而不用考虑该进程的拥有者是谁。结果是，如果用户 1 启动了 9 个进程，而用户 2 启动了一个进程，使用轮转或相同优先级调度算法，那么用户 1 将得到 90 % 的 CPU 时间，而用户 2 将之得到 10 % 的 CPU 时间。</p><p>为了阻止这种情况的出现，一些系统在调度前会把进程的拥有者考虑在内。在这种模型下，每个用户都会分配一些 CPU 时间，而调度程序会选择进程并强制执行。因此如果两个用户每个都会有 50% 的 CPU 时间片保证，那么无论一个用户有多少个进程，都将获得相同的 CPU 份额。</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829805-f1649640-92c0-4cc0-9d11-d33091868df3.png#align=left&display=inline&height=106&margin=%5Bobject%20Object%5D&originHeight=106&originWidth=681&size=0&status=done&style=none&width=681"></p><h3 id="实时系统中的调度"><a href="#实时系统中的调度" class="headerlink" title="实时系统中的调度"></a>实时系统中的调度</h3><p><code>实时系统(real-time)</code> 是一个时间扮演了重要作用的系统。实时系统可以分为两类，<code>硬实时(hard real time)</code> 和 <code>软实时(soft real time)</code> 系统，前者意味着必须要满足绝对的截止时间；后者的含义是虽然不希望偶尔错失截止时间，但是可以容忍。</p><p>实时系统中的事件可以按照响应方式进一步分类为<code>周期性(以规则的时间间隔发生)</code>事件或 <code>非周期性(发生时间不可预知)</code>事件。一个系统可能要响应多个周期性事件流，根据每个事件处理所需的时间，可能甚至无法处理所有事件。例如，如果有 m 个周期事件，事件 i 以周期 Pi 发生，并需要 Ci 秒 CPU 时间处理一个事件，那么可以处理负载的条件是</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829813-d541b483-e6c2-4e61-b29d-faf9719ce83f.png#align=left&display=inline&height=81&margin=%5Bobject%20Object%5D&originHeight=81&originWidth=180&size=0&status=done&style=none&width=180"></p><p>只有满足这个条件的实时系统称为<code>可调度的</code>，这意味着它实际上能够被实现。一个不满足此检验标准的进程不能被调度，因为这些进程共同需要的 CPU 时间总和大于 CPU 能提供的时间。</p><p>下面我们来了解一下内存管理，你需要知道的知识点如下</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829871-ad9be6cd-aa53-4acc-b245-5dd76199a6ba.png#align=left&display=inline&height=380&margin=%5Bobject%20Object%5D&originHeight=380&originWidth=742&size=0&status=done&style=none&width=742"></p><h2 id="地址空间"><a href="#地址空间" class="headerlink" title="地址空间"></a>地址空间</h2><p>如果要使多个应用程序同时运行在内存中，必须要解决两个问题：<code>保护</code>和 <code>重定位</code>。第一种解决方式是用<code>保护密钥标记内存块</code>，并将执行过程的密钥与提取的每个存储字的密钥进行比较。这种方式只能解决第一种问题（破坏操作系统），但是不能解决多进程在内存中同时运行的问题。</p><p>还有一种更好的方式是创造一个存储器抽象：<code>地址空间(the address space)</code>。就像进程的概念创建了一种抽象的 CPU 来运行程序，地址空间也创建了一种抽象内存供程序使用。</p><h4 id="基址寄存器和变址寄存器"><a href="#基址寄存器和变址寄存器" class="headerlink" title="基址寄存器和变址寄存器"></a>基址寄存器和变址寄存器</h4><p>最简单的办法是使用<code>动态重定位(dynamic relocation)</code>技术，它就是通过一种简单的方式将每个进程的地址空间映射到物理内存的不同区域。还有一种方式是使用基址寄存器和变址寄存器。</p><ul><li>基址寄存器：存储数据内存的起始位置</li><li>变址寄存器：存储应用程序的长度。</li></ul><p>每当进程引用内存以获取指令或读取、写入数据时，CPU 都会自动将<code>基址值</code>添加到进程生成的地址中，然后再将其发送到内存总线上。同时，它检查程序提供的地址是否大于或等于<code>变址寄存器</code> 中的值。如果程序提供的地址要超过变址寄存器的范围，那么会产生错误并中止访问。</p><h3 id="交换技术"><a href="#交换技术" class="headerlink" title="交换技术"></a>交换技术</h3><p>在程序运行过程中，经常会出现内存不足的问题。</p><p>针对上面内存不足的问题，提出了两种处理方式：最简单的一种方式就是<code>交换(swapping)</code>技术，即把一个进程完整的调入内存，然后再内存中运行一段时间，再把它放回磁盘。空闲进程会存储在磁盘中，所以这些进程在没有运行时不会占用太多内存。另外一种策略叫做<code>虚拟内存(virtual memory)</code>，虚拟内存技术能够允许应用程序部分的运行在内存中。下面我们首先先探讨一下交换</p><h4 id="交换过程"><a href="#交换过程" class="headerlink" title="交换过程"></a>交换过程</h4><p>下面是一个交换过程</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829844-31f0d41e-db06-4f4a-86d4-15250999e2dd.png#align=left&display=inline&height=349&margin=%5Bobject%20Object%5D&originHeight=349&originWidth=724&size=0&status=done&style=none&width=724"></p><p>刚开始的时候，只有进程 A 在内存中，然后从创建进程 B 和进程 C 或者从磁盘中把它们换入内存，然后在图 d 中，A 被换出内存到磁盘中，最后 A 重新进来。因为图 g 中的进程 A 现在到了不同的位置，所以在装载过程中需要被重新定位，或者在交换程序时通过软件来执行；或者在程序执行期间通过硬件来重定位。基址寄存器和变址寄存器就适用于这种情况。</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829879-4fde9a55-0c36-4d7d-948a-49841539d0c8.png#align=left&display=inline&height=469&margin=%5Bobject%20Object%5D&originHeight=469&originWidth=696&size=0&status=done&style=none&width=696"></p><p>交换在内存创建了多个 <code>空闲区(hole)</code>，内存会把所有的空闲区尽可能向下移动合并成为一个大的空闲区。这项技术称为<code>内存紧缩(memory compaction)</code>。但是这项技术通常不会使用，因为这项技术会消耗很多 CPU 时间。</p><h3 id="空闲内存管理"><a href="#空闲内存管理" class="headerlink" title="空闲内存管理"></a>空闲内存管理</h3><p>在进行内存动态分配时，操作系统必须对其进行管理。大致上说，有两种监控内存使用的方式</p><ul><li><code>位图(bitmap)</code></li><li><code>空闲列表(free lists)</code></li></ul><h4 id="使用位图的存储管理"><a href="#使用位图的存储管理" class="headerlink" title="使用位图的存储管理"></a>使用位图的存储管理</h4><p>使用位图方法时，内存可能被划分为小到几个字或大到几千字节的分配单元。每个分配单元对应于位图中的一位，0 表示空闲， 1 表示占用（或者相反）。一块内存区域和其对应的位图如下</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829887-83af6188-e02c-4437-8739-40021e8a2957.png#align=left&display=inline&height=303&margin=%5Bobject%20Object%5D&originHeight=303&originWidth=734&size=0&status=done&style=none&width=734"></p><p><code>位图</code>提供了一种简单的方法在固定大小的内存中跟踪内存的使用情况，因为<strong>位图的大小取决于内存和分配单元的大小</strong>。这种方法有一个问题是，当决定为把具有 k 个分配单元的进程放入内存时，<code>内容管理器(memory manager)</code> 必须搜索位图，在位图中找出能够运行 k 个连续 0 位的串。在位图中找出制定长度的连续 0 串是一个很耗时的操作，这是位图的缺点。（可以简单理解为在杂乱无章的数组中，找出具有一大长串空闲的数组单元）</p><h4 id="使用链表进行管理"><a href="#使用链表进行管理" class="headerlink" title="使用链表进行管理"></a>使用链表进行管理</h4><p>另一种记录内存使用情况的方法是，维护一个记录已分配内存段和空闲内存段的链表，段会包含进程或者是两个进程的空闲区域。可用上面的图 c <strong>来表示内存的使用情况</strong>。链表中的每一项都可以代表一个 <code>空闲区(H)</code> 或者是<code>进程(P)</code>的起始标志，长度和下一个链表项的位置。</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829908-832c7960-d7cc-45fc-a029-b803b86a6bf9.png#align=left&display=inline&height=432&margin=%5Bobject%20Object%5D&originHeight=432&originWidth=695&size=0&status=done&style=none&width=695"></p><p>当按照地址顺序在链表中存放进程和空闲区时，有几种算法可以为创建的进程（或者从磁盘中换入的进程）分配内存。我们先假设内存管理器知道应该分配多少内存，最简单的算法是使用 <code>首次适配(first fit)</code>。内存管理器会沿着段列表进行扫描，直到找个一个足够大的空闲区为止。 除非空闲区大小和要分配的空间大小一样，否则将空闲区分为两部分，一部分供进程使用；一部分生成新的空闲区。首次适配算法是一种速度很快的算法，因为它会尽可能的搜索链表。</p><p>首次适配的一个小的变体是 <code>下次适配(next fit)</code>。它和首次匹配的工作方式相同，只有一个不同之处那就是下次适配在每次找到合适的空闲区时就会记录当时的位置，以便下次寻找空闲区时从上次结束的地方开始搜索，而不是像首次匹配算法那样每次都会从头开始搜索。</p><p>另外一个著名的并且广泛使用的算法是 <code>最佳适配(best fit)</code>。最佳适配会从头到尾寻找整个链表，找出能够容纳进程的最小空闲区。</p><h2 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h2><p>尽管基址寄存器和变址寄存器用来创建地址空间的抽象，但是这有一个其他的问题需要解决：<code>管理软件的不断增大(managing bloatware)</code>。虚拟内存的基本思想是，每个程序都有自己的地址空间，这个地址空间被划分为多个称为<code>页面(page)</code>的块。每一页都是连续的地址范围。这些页被映射到物理内存，但并不是所有的页都必须在内存中才能运行程序。当程序引用到一部分在物理内存中的地址空间时，硬件会立刻执行必要的映射。当程序引用到一部分不在物理内存中的地址空间时，由操作系统负责将缺失的部分装入物理内存并重新执行失败的指令。</p><h3 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h3><p>大部分使用虚拟内存的系统中都会使用一种 <code>分页(paging)</code> 技术。在任何一台计算机上，程序会引用使用一组内存地址。当程序执行</p><pre><code class="assembly">MOV REG,1000</code></pre><p>这条指令时，它会把内存地址为 1000 的内存单元的内容复制到 REG 中（或者相反，这取决于计算机）。地址可以通过索引、基址寄存器、段寄存器或其他方式产生。</p><p>这些程序生成的地址被称为 <code>虚拟地址(virtual addresses)</code> 并形成<code>虚拟地址空间(virtual address space)</code>，在没有虚拟内存的计算机上，系统直接将虚拟地址送到内存中线上，读写操作都使用同样地址的物理内存。<strong>在使用虚拟内存时，虚拟地址不会直接发送到内存总线上</strong>。相反，会使用 <code>MMU(Memory Management Unit)</code> 内存管理单元把<strong>虚拟地址映射为物理内存地址</strong>，像下图这样</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829902-6db577d7-0921-4635-82f1-62f7fe723b48.png#align=left&display=inline&height=326&margin=%5Bobject%20Object%5D&originHeight=326&originWidth=710&size=0&status=done&style=none&width=710"></p><p>下面这幅图展示了这种映射是如何工作的</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829922-b5a208d9-6807-4201-b95a-50c300ec3f1e.png#align=left&display=inline&height=728&margin=%5Bobject%20Object%5D&originHeight=728&originWidth=701&size=0&status=done&style=none&width=701"></p><p>页表给出虚拟地址与物理内存地址之间的映射关系。每一页起始于 4096 的倍数位置，结束于 4095 的位置，所以 4K 到 8K 实际为 4096 - 8191 ，8K - 12K 就是 8192 - 12287</p><p>在这个例子中，我们可能有一个 16 位地址的计算机，地址从 0 - 64 K - 1，这些是<code>虚拟地址</code>。然而只有 32 KB 的物理地址。所以虽然可以编写 64 KB 的程序，但是程序无法全部调入内存运行，在磁盘上必须有一个最多 64 KB 的程序核心映像的完整副本，以保证程序片段在需要时被调入内存。</p><h3 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h3><p>虚拟页号可作为页表的索引用来找到虚拟页中的内容。由页表项可以找到页框号（如果有的话）。然后把页框号拼接到偏移量的高位端，以替换掉虚拟页号，形成物理地址。</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829940-3af1fa95-4f53-459f-88e6-dc9540fc58fa.png#align=left&display=inline&height=555&margin=%5Bobject%20Object%5D&originHeight=555&originWidth=726&size=0&status=done&style=none&width=726"></p><p>因此，页表的目的是把虚拟页映射到页框中。从数学上说，页表是一个函数，它的参数是虚拟页号，结果是物理页框号。</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829970-f9085cee-e3ce-49a6-a175-31095f33b104.png#align=left&display=inline&height=226&margin=%5Bobject%20Object%5D&originHeight=226&originWidth=549&size=0&status=done&style=none&width=549"></p><p>通过这个函数可以把虚拟地址中的虚拟页转换为页框，从而形成物理地址。</p><h4 id="页表项的结构"><a href="#页表项的结构" class="headerlink" title="页表项的结构"></a>页表项的结构</h4><p>下面我们探讨一下页表项的具体结构，上面你知道了页表项的大致构成，是由页框号和在/不在位构成的，现在我们来具体探讨一下页表项的构成</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829994-5ecf9cda-4a6f-418e-b786-bf4a2a05e7c3.png#align=left&display=inline&height=297&margin=%5Bobject%20Object%5D&originHeight=297&originWidth=701&size=0&status=done&style=none&width=701"></p><p>页表项的结构是与机器相关的，但是不同机器上的页表项大致相同。上面是一个页表项的构成，不同计算机的页表项可能不同，但是一般来说都是 32 位的。页表项中最重要的字段就是<code>页框号(Page frame number)</code>。毕竟，页表到页框最重要的一步操作就是要把此值映射过去。下一个比较重要的就是<code>在/不在</code>位，如果此位上的值是 1，那么页表项是有效的并且能够被<code>使用</code>。如果此值是 0 的话，则表示该页表项对应的虚拟页面<code>不在</code>内存中，访问该页面会引起一个<code>缺页异常(page fault)</code>。</p><p><code>保护位(Protection)</code> 告诉我们哪一种访问是允许的，啥意思呢？最简单的表示形式是这个域只有一位，<strong>0 表示可读可写，1 表示的是只读</strong>。</p><p><code>修改位(Modified)</code> 和 <code>访问位(Referenced)</code> 会跟踪页面的使用情况。当一个页面被写入时，硬件会自动的设置修改位。修改位在页面重新分配页框时很有用。如果一个页面已经被修改过（即它是 <code>脏</code> 的），则必须把它写回磁盘。如果一个页面没有被修改过（即它是 <code>干净</code>的），那么重新分配时这个页框会被直接丢弃，因为磁盘上的副本仍然是有效的。这个位有时也叫做 <code>脏位(dirty bit)</code>，因为它反映了页面的状态。</p><p><code>访问位(Referenced)</code> 在页面被访问时被设置，不管是读还是写。这个值能够帮助操作系统在发生缺页中断时选择要淘汰的页。不再使用的页要比正在使用的页更适合被淘汰。这个位在后面要讨论的<code>页面置换</code>算法中作用很大。</p><p>最后一位用于禁止该页面被高速缓存，这个功能对于映射到设备寄存器还是内存中起到了关键作用。通过这一位可以禁用高速缓存。具有独立的 I/O 空间而不是用内存映射 I/O 的机器来说，并不需要这一位。</p><h2 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h2><p>下面我们就来探讨一下有哪些页面置换算法。</p><h3 id="最优页面置换算法"><a href="#最优页面置换算法" class="headerlink" title="最优页面置换算法"></a>最优页面置换算法</h3><p>最优的页面置换算法的工作流程如下：在缺页中断发生时，这些页面之一将在下一条指令（包含该指令的页面）上被引用。其他页面则可能要到 10、100 或者 1000 条指令后才会被访问。每个页面都可以用在该页首次被访问前所要执行的指令数作为标记。</p><p>最优化的页面算法表明应该标记最大的页面。如果一个页面在 800 万条指令内不会被使用，另外一个页面在 600 万条指令内不会被使用，则置换前一个页面，从而把需要调入这个页面而发生的缺页中断推迟。计算机也像人类一样，会把不愿意做的事情尽可能的往后拖。</p><p>这个算法最大的问题时无法实现。当缺页中断发生时，操作系统无法知道各个页面的下一次将在什么时候被访问。这种算法在实际过程中根本不会使用。</p><h3 id="最近未使用页面置换算法"><a href="#最近未使用页面置换算法" class="headerlink" title="最近未使用页面置换算法"></a>最近未使用页面置换算法</h3><p>为了能够让操作系统收集页面使用信息，大部分使用虚拟地址的计算机都有两个状态位，R 和 M，来和每个页面进行关联。<strong>每当引用页面（读入或写入）时都设置 R，写入（即修改）页面时设置 M</strong>，这些位包含在每个页表项中，就像下面所示</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830000-886bdae7-531d-42ce-86c1-970d3c0fd287.png#align=left&display=inline&height=288&margin=%5Bobject%20Object%5D&originHeight=288&originWidth=644&size=0&status=done&style=none&width=644"></p><p>因为每次访问时都会更新这些位，因此由<code>硬件</code>来设置它们非常重要。一旦某个位被设置为 1，就会一直保持 1 直到操作系统下次来修改此位。</p><p>如果硬件没有这些位，那么可以使用操作系统的<code>缺页中断</code>和<code>时钟中断</code>机制来进行模拟。当启动一个进程时，将其所有的页面都标记为<code>不在内存</code>；一旦访问任何一个页面就会引发一次缺页中断，此时操作系统就可以设置 <code>R 位(在它的内部表中)</code>，修改页表项使其指向正确的页面，并设置为 <code>READ ONLY</code> 模式，然后重新启动引起缺页中断的指令。如果页面随后被修改，就会发生另一个缺页异常。从而允许操作系统设置 M 位并把页面的模式设置为 <code>READ/WRITE</code>。</p><p>可以用 R 位和 M 位来构造一个简单的页面置换算法：当启动一个进程时，操作系统将其所有页面的两个位都设置为 0。R 位定期的被清零（在每个时钟中断）。用来将最近未引用的页面和已引用的页面分开。</p><p>当出现缺页中断后，操作系统会检查所有的页面，并根据它们的 R 位和 M 位将当前值分为四类：</p><ul><li>第 0 类：没有引用 R，没有修改 M</li><li>第 1 类：没有引用 R，已修改 M</li><li>第 2 类：引用 R ，没有修改 M</li><li>第 3 类：已被访问 R，已被修改 M</li></ul><p>尽管看起来好像无法实现第一类页面，但是当第三类页面的 R 位被时钟中断清除时，它们就会发生。时钟中断不会清除 M 位，因为需要这个信息才能知道是否写回磁盘中。清除 R 但不清除 M 会导致出现一类页面。</p><p><code>NRU(Not Recently Used)</code> 算法从编号最小的非空类中随机删除一个页面。此算法隐含的思想是，在一个时钟内（约 20 ms）淘汰一个已修改但是没有被访问的页面要比一个大量引用的未修改页面好，NRU 的主要优点是<strong>易于理解并且能够有效的实现</strong>。</p><h3 id="先进先出页面置换算法"><a href="#先进先出页面置换算法" class="headerlink" title="先进先出页面置换算法"></a>先进先出页面置换算法</h3><p>另一种开销较小的方式是使用 <code>FIFO(First-In,First-Out)</code> 算法，这种类型的数据结构也适用在页面置换算法中。由操作系统维护一个所有在当前内存中的页面的链表，最早进入的放在表头，最新进入的页面放在表尾。在发生缺页异常时，会把头部的页移除并且把新的页添加到表尾。</p><h3 id="第二次机会页面置换算法"><a href="#第二次机会页面置换算法" class="headerlink" title="第二次机会页面置换算法"></a>第二次机会页面置换算法</h3><p>我们上面学到的 FIFO 链表页面有个<code>缺陷</code>，那就是出链和入链并不会进行 check <code>检查</code>，这样就会容易把经常使用的页面置换出去，为了避免这一问题，我们对该算法做一个简单的修改：我们检查最老页面的 <code>R 位</code>，如果是 0 ，那么这个页面就是最老的而且没有被使用，那么这个页面就会被立刻换出。如果 R 位是 1，那么就清除此位，此页面会被放在链表的尾部，修改它的装入时间就像刚放进来的一样。然后继续搜索。</p><p>这种算法叫做 <code>第二次机会(second chance)</code>算法，就像下面这样，我们看到页面 A 到 H 保留在链表中，并按到达内存的时间排序。</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830001-d17523cc-7d04-4aa5-9b91-7cb47cc26508.png#align=left&display=inline&height=372&margin=%5Bobject%20Object%5D&originHeight=372&originWidth=731&size=0&status=done&style=none&width=731"></p><p>a）按照先进先出的方法排列的页面；b）在时刻 20 处发生缺页异常中断并且 A 的 R 位已经设置时的页面链表。</p><p>假设缺页异常发生在时刻 20 处，这时最老的页面是 A ，它是在 0 时刻到达的。如果 A 的 R 位是 0，那么它将被淘汰出内存，或者把它写回磁盘（如果它已经被修改过），或者只是简单的放弃（如果它是未被修改过）。另一方面，如果它的 R 位已经设置了，则将 A 放到链表的尾部并且重新设置<code>装入时间</code>为当前时刻（20 处），然后清除 R 位。然后从 B 页面开始继续搜索合适的页面。</p><p>寻找第二次机会的是在最近的时钟间隔中未被访问过的页面。如果所有的页面都被访问过，该算法就会被简化为单纯的 <code>FIFO 算法</code>。具体来说，假设图 a 中所有页面都设置了 R 位。操作系统将页面依次移到链表末尾，每次都在添加到末尾时清除 R 位。最后，算法又会回到页面 A，此时的 R 位已经被清除，那么页面 A 就会被执行出链处理，因此算法能够正常结束。</p><h3 id="时钟页面置换算法"><a href="#时钟页面置换算法" class="headerlink" title="时钟页面置换算法"></a>时钟页面置换算法</h3><p>一种比较好的方式是把所有的页面都保存在一个类似钟面的环形链表中，一个表针指向最老的页面。如下图所示</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830029-543aeeff-242c-4b6f-a9a4-87fa9b101280.png#align=left&display=inline&height=532&margin=%5Bobject%20Object%5D&originHeight=532&originWidth=669&size=0&status=done&style=none&width=669"></p><p>当缺页错误出现时，算法首先检查表针指向的页面，如果它的 R 位是 0 就淘汰该页面，并把新的页面插入到这个位置，然后把表针向前移动一位；如果 R 位是 1 就清除 R 位并把表针前移一个位置。重复这个过程直到找到了一个 R 位为 0 的页面位置。了解这个算法的工作方式，就明白为什么它被称为 <code>时钟(clokc)</code>算法了。</p><h3 id="最近最少使用页面置换算法"><a href="#最近最少使用页面置换算法" class="headerlink" title="最近最少使用页面置换算法"></a>最近最少使用页面置换算法</h3><p>在前面几条指令中频繁使用的页面和可能在后面的几条指令中被使用。反过来说，已经很久没有使用的页面有可能在未来一段时间内仍不会被使用。这个思想揭示了一个可以实现的算法：在缺页中断时，置换未使用时间最长的页面。这个策略称为 <code>LRU(Least Recently Used)</code> ，最近最少使用页面置换算法。</p><p>虽然 LRU 在理论上是可以实现的，但是从长远看来代价比较高。为了完全实现 LRU，会在内存中维护一个所有页面的链表，最频繁使用的页位于表头，最近最少使用的页位于表尾。困难的是在每次内存引用时更新整个链表。在链表中找到一个页面，删除它，然后把它移动到表头是一个非常耗时的操作，即使使用<code>硬件</code>来实现也是一样的费时。</p><h3 id="用软件模拟-LRU"><a href="#用软件模拟-LRU" class="headerlink" title="用软件模拟 LRU"></a>用软件模拟 LRU</h3><p>尽管上面的 LRU 算法在原则上是可以实现的，<strong>但是很少有机器能够拥有那些特殊的硬件</strong>。上面是硬件的实现方式，那么现在考虑要用<code>软件</code>来实现 LRU 。一种可以实现的方案是 <code>NFU(Not Frequently Used，最不常用)</code>算法。它需要一个软件计数器来和每个页面关联，初始化的时候是 0 。在每个时钟中断时，操作系统会浏览内存中的所有页，会将每个页面的 R 位（0 或 1）加到它的计数器上。这个计数器大体上跟踪了各个页面访问的频繁程度。当缺页异常出现时，则置换计数器值最小的页面。</p><p>只需要对 NFU 做一个简单的修改就可以让它模拟 LRU，这个修改有两个步骤</p><ul><li>首先，在 R 位被添加进来之前先把计数器右移一位；</li><li>第二步，R 位被添加到最左边的位而不是最右边的位。</li></ul><p>修改以后的算法称为 <code>老化(aging)</code> 算法，下图解释了老化算法是如何工作的。</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830078-9cab6ac9-f2fa-4395-b8d5-57b61a80e6d3.png#align=left&display=inline&height=415&margin=%5Bobject%20Object%5D&originHeight=415&originWidth=747&size=0&status=done&style=none&width=747"></p><p>我们假设在第一个时钟周期内页面 0 - 5 的 R 位依次是 1，0，1，0，1，1，（也就是页面 0 是 1，页面 1 是 0，页面 2 是 1 这样类推）。也就是说，<strong>在 0 个时钟周期到 1 个时钟周期之间，0，2，4，5 都被引用了</strong>，从而把它们的 R 位设置为 1，剩下的设置为 0 。在相关的六个计数器被右移之后 R 位被添加到 <code>左侧</code> ，就像上图中的 a。剩下的四列显示了接下来的四个时钟周期内的六个计数器变化。</p><blockquote><p>CPU 正在以某个频率前进，该频率的周期称为<code>时钟滴答</code>或<code>时钟周期</code>。一个 100Mhz 的处理器每秒将接收 100,000,000 个时钟滴答。</p></blockquote><p>当缺页异常出现时，将<code>置换（就是移除）</code>计数器值最小的页面。如果一个页面在前面 4 个时钟周期内都没有被访问过，那么它的计数器应该会有四个连续的 0 ，因此它的值肯定要比前面 3 个时钟周期内都没有被访问过的页面的计数器小。</p><p>这个算法与 LRU 算法有两个重要的区别：看一下上图中的 <code>e</code>，第三列和第五列</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830053-3463258f-69af-41f6-94ed-94a15761844e.png#align=left&display=inline&height=429&margin=%5Bobject%20Object%5D&originHeight=429&originWidth=763&size=0&status=done&style=none&width=763"></p><h3 id="工作集时钟页面置换算法"><a href="#工作集时钟页面置换算法" class="headerlink" title="工作集时钟页面置换算法"></a>工作集时钟页面置换算法</h3><p>当缺页异常发生后，需要扫描整个页表才能确定被淘汰的页面，因此基本工作集算法还是比较浪费时间的。一个对基本工作集算法的提升是基于时钟算法但是却使用工作集的信息，这种算法称为<code>WSClock(工作集时钟)</code>。由于它的实现简单并且具有高性能，因此在实践中被广泛应用。</p><p>与时钟算法一样，所需的数据结构是一个以页框为元素的循环列表，就像下面这样</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830081-e96444ca-dda9-4c3f-9af5-e0db74d03a6f.png#align=left&display=inline&height=588&margin=%5Bobject%20Object%5D&originHeight=588&originWidth=705&size=0&status=done&style=none&width=705"></p><p>工作集时钟页面置换算法的操作：a) 和 b) 给出 R = 1 时所发生的情形；c) 和 d) 给出 R = 0 的例子</p><p>最初的时候，该表是空的。当装入第一个页面后，把它加载到该表中。随着更多的页面的加入，它们形成一个环形结构。每个表项包含来自基本工作集算法的上次使用时间，以及 R 位（已标明）和 M 位（未标明）。</p><p>与时钟算法一样，在每个缺页异常时，首先检查指针指向的页面。如果 R 位被是设置为 1，该页面在当前时钟周期内就被使用过，那么该页面就不适合被淘汰。然后把该页面的 R 位置为 0，指针指向下一个页面，并重复该算法。该事件序列化后的状态参见图 b。</p><p>现在考虑指针指向的页面 R = 0 时会发生什么，参见图 c，如果页面的使用期限大于 t 并且页面为被访问过，那么这个页面就不会在工作集中，并且在磁盘上会有一个此页面的副本。申请重新调入一个新的页面，并把新的页面放在其中，如图 d 所示。另一方面，如果页面被修改过，就不能重新申请页面，因为这个页面在磁盘上没有有效的副本。为了避免由于调度写磁盘操作引起的进程切换，指针继续向前走，算法继续对下一个页面进行操作。毕竟，有可能存在一个老的，没有被修改过的页面可以立即使用。</p><p>原则上来说，所有的页面都有可能因为<code>磁盘I/O</code> 在某个时钟周期内被调度。为了降低磁盘阻塞，需要设置一个限制，即最大只允许写回 n 个页面。一旦达到该限制，就不允许调度新的写操作。</p><p>那么就有个问题，指针会绕一圈回到原点的，如果回到原点，它的起始点会发生什么？这里有两种情况：</p><ul><li>至少调度了一次写操作</li><li>没有调度过写操作</li></ul><p>在第一种情况中，指针仅仅是不停的移动，寻找一个未被修改过的页面。由于已经调度了一个或者多个写操作，最终会有某个写操作完成，它的页面会被标记为未修改。置换遇到的第一个未被修改过的页面，这个页面不一定是第一个被调度写操作的页面，因为硬盘驱动程序为了优化性能可能会把写操作重排序。</p><p>对于第二种情况，所有的页面都在工作集中，否则将至少调度了一个写操作。由于缺乏额外的信息，最简单的方法就是置换一个未被修改的页面来使用，扫描中需要记录未被修改的页面的位置，如果不存在未被修改的页面，就选定当前页面并把它写回磁盘。</p><h3 id="页面置换算法小结"><a href="#页面置换算法小结" class="headerlink" title="页面置换算法小结"></a>页面置换算法小结</h3><p>我们到现在已经研究了各种页面置换算法，现在我们来一个简单的总结，算法的总结归纳如下</p><table><thead><tr><th>算法</th><th>注释</th></tr></thead><tbody><tr><td>最优算法</td><td>不可实现，但可以用作基准</td></tr><tr><td>NRU(最近未使用) 算法</td><td>和 LRU 算法很相似</td></tr><tr><td>FIFO(先进先出) 算法</td><td>有可能会抛弃重要的页面</td></tr><tr><td>第二次机会算法</td><td>比 FIFO 有较大的改善</td></tr><tr><td>时钟算法</td><td>实际使用</td></tr><tr><td>LRU(最近最少)算法</td><td>比较优秀，但是很难实现</td></tr><tr><td>NFU(最不经常食用)算法</td><td>和 LRU 很类似</td></tr><tr><td>老化算法</td><td>近似 LRU 的高效算法</td></tr><tr><td>工作集算法</td><td>实施起来开销很大</td></tr><tr><td>工作集时钟算法</td><td>比较有效的算法</td></tr></tbody></table><ul><li><code>最优算法</code>在当前页面中置换最后要访问的页面。不幸的是，没有办法来判定哪个页面是最后一个要访问的，<code>因此实际上该算法不能使用</code>。然而，它可以作为衡量其他算法的标准。</li><li><code>NRU</code> 算法根据 R 位和 M 位的状态将页面氛围四类。从编号最小的类别中随机选择一个页面。NRU 算法易于实现，但是性能不是很好。存在更好的算法。</li><li><code>FIFO</code> 会跟踪页面加载进入内存中的顺序，并把页面放入一个链表中。有可能删除存在时间最长但是还在使用的页面，因此这个算法也不是一个很好的选择。</li><li><code>第二次机会</code>算法是对 FIFO 的一个修改，它会在删除页面之前检查这个页面是否仍在使用。如果页面正在使用，就会进行保留。这个改进大大提高了性能。</li><li><code>时钟</code> 算法是第二次机会算法的另外一种实现形式，时钟算法和第二次算法的性能差不多，但是会花费更少的时间来执行算法。</li><li><code>LRU</code> 算法是一个非常优秀的算法，但是没有<code>特殊的硬件(TLB)</code>很难实现。如果没有硬件，就不能使用 LRU 算法。</li><li><code>NFU</code> 算法是一种近似于 LRU 的算法，它的性能不是非常好。</li><li><code>老化</code> 算法是一种更接近 LRU 算法的实现，并且可以更好的实现，因此是一个很好的选择</li><li>最后两种算法都使用了工作集算法。工作集算法提供了合理的性能开销，但是它的实现比较复杂。<code>WSClock</code> 是另外一种变体，它不仅能够提供良好的性能，而且可以高效地实现。</li></ul><p>总之，<strong>最好的算法是老化算法和 WSClock 算法</strong>。他们分别是基于 LRU 和工作集算法。他们都具有良好的性能并且能够被有效的实现。还存在其他一些好的算法，但实际上这两个可能是最重要的。</p><p>下面来聊一聊文件系统，你需要知道下面这些知识点</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830114-09f30aaf-25b8-44c3-992a-577e4c3a833c.png#align=left&display=inline&height=657&margin=%5Bobject%20Object%5D&originHeight=657&originWidth=721&size=0&status=done&style=none&width=721"></p><h2 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h2><h3 id="文件命名"><a href="#文件命名" class="headerlink" title="文件命名"></a>文件命名</h3><p>文件是一种抽象机制，它提供了一种方式用来存储信息以及在后面进行读取。可能任何一种机制最重要的特性就是管理对象的命名方式。在创建一个文件后，它会给文件一个命名。当进程终止时，文件会继续存在，并且其他进程可以使用<code>名称访问该文件</code>。</p><p>文件命名规则对于不同的操作系统来说是不一样的，但是所有现代操作系统都允许使用 1 - 8 个字母的字符串作为合法文件名。</p><p>某些文件区分大小写字母，而大多数则不区分。<code>UNIX</code> 属于第一类；历史悠久的 <code>MS-DOS</code> 属于第二类（顺便说一句，尽管 MS-DOS 历史悠久，但 MS-DOS 仍在嵌入式系统中非常广泛地使用，因此它绝不是过时的）；因此，UNIX 系统会有三种不同的命名文件：<code>maria</code>、<code>Maria</code>、<code>MARIA</code> 。在 MS-DOS ，所有这些命名都属于相同的文件。</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830120-5ba4f13c-ee71-46f2-a110-e2eaf1dbf324.png#align=left&display=inline&height=302&margin=%5Bobject%20Object%5D&originHeight=302&originWidth=691&size=0&status=done&style=none&width=691"></p><p>许多操作系统支持两部分的文件名，它们之间用 <code>.</code> 分隔开，比如文件名 <code>prog.c</code>。原点后面的文件称为 <code>文件扩展名(file extension)</code> ，文件扩展名通常表示文件的一些信息。一些常用的文件扩展名以及含义如下图所示</p><table><thead><tr><th>扩展名</th><th>含义</th></tr></thead><tbody><tr><td>bak</td><td>备份文件</td></tr><tr><td>c</td><td>c 源程序文件</td></tr><tr><td>gif</td><td>符合图形交换格式的图像文件</td></tr><tr><td>hlp</td><td>帮助文件</td></tr><tr><td>html</td><td>WWW 超文本标记语言文档</td></tr><tr><td>jpg</td><td>符合 JPEG 编码标准的静态图片</td></tr><tr><td>mp3</td><td>符合 MP3 音频编码格式的音乐文件</td></tr><tr><td>mpg</td><td>符合 MPEG 编码标准的电影</td></tr><tr><td>o</td><td>目标文件（编译器输出格式，尚未链接）</td></tr><tr><td>pdf</td><td>pdf 格式的文件</td></tr><tr><td>ps</td><td>PostScript 文件</td></tr><tr><td>tex</td><td>为 TEX 格式化程序准备的输入文件</td></tr><tr><td>txt</td><td>文本文件</td></tr><tr><td>zip</td><td>压缩文件</td></tr></tbody></table><p>在 UNIX 系统中，文件扩展名只是一种约定，操作系统并不强制采用。</p><h3 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h3><p>文件的构造有多种方式。下图列出了常用的三种构造方式</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830179-1cd3ea7b-cf21-432f-a8e4-c2d8f317e0ff.png#align=left&display=inline&height=426&margin=%5Bobject%20Object%5D&originHeight=426&originWidth=728&size=0&status=done&style=none&width=728"></p><p>三种不同的文件。 a) 字节序列 。b) 记录序列。c) 树</p><p>上图中的 a 是一种无结构的字节序列，操作系统不关心序列的内容是什么，操作系统能看到的就是<code>字节(bytes)</code>。其文件内容的任何含义只在用户程序中进行解释。UNIX 和 Windows 都采用这种办法。</p><p>图 b 表示在文件结构上的第一部改进。在这个模型中，文件是具有固定长度记录的序列，每个记录都有其内部结构。 把文件作为记录序列的核心思想是：<strong>读操作返回一个记录，而写操作重写或者追加一个记录</strong>。第三种文件结构如上图 c 所示。在这种组织结构中，文件由一颗<code>记录树</code>构成，记录树的长度不一定相同，每个记录树都在记录中的固定位置包含一个<code>key</code> 字段。这棵树按 key 进行排序，从而可以对特定的 key 进行快速查找。</p><h3 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h3><p>很多操作系统支持多种文件类型。例如，UNIX（同样包括 OS X）和 Windows 都具有常规的文件和目录。除此之外，UNIX 还具有<code>字符特殊文件(character special file)</code> 和 <code>块特殊文件(block special file)</code>。<code>常规文件(Regular files)</code> 是包含有用户信息的文件。用户一般使用的文件大都是常规文件，常规文件一般包括 <strong>可执行文件、文本文件、图像文件</strong>，从常规文件读取数据或将数据写入时，内核会根据文件系统的规则执行操作，是写入可能被延迟，记录日志或者接受其他操作。</p><h3 id="文件访问"><a href="#文件访问" class="headerlink" title="文件访问"></a>文件访问</h3><p>早期的操作系统只有一种访问方式：<code>序列访问(sequential access)</code>。在这些系统中，进程可以按照顺序读取所有的字节或文件中的记录，但是不能跳过并乱序执行它们。顺序访问文件是可以返回到起点的，需要时可以多次读取该文件。当存储介质是磁带而不是磁盘时，顺序访问文件很方便。</p><p>在使用磁盘来存储文件时，可以不按照顺序读取文件中的字节或者记录，或者按照关键字而不是位置来访问记录。这种能够以任意次序进行读取的称为<code>随机访问文件(random access file)</code>。许多应用程序都需要这种方式。</p><p>随机访问文件对许多应用程序来说都必不可少，例如，数据库系统。如果乘客打电话预定某航班机票，订票程序必须能够直接访问航班记录，而不必先读取其他航班的成千上万条记录。</p><p>有两种方法可以指示从何处开始读取文件。第一种方法是直接使用 <code>read</code> 从头开始读取。另一种是用一个特殊的 <code>seek</code> 操作设置当前位置，在 seek 操作后，从这个当前位置顺序地开始读文件。UNIX 和 Windows 使用的是后面一种方式。</p><h3 id="文件属性"><a href="#文件属性" class="headerlink" title="文件属性"></a>文件属性</h3><p>文件包括文件名和数据。除此之外，所有的操作系统还会保存其他与文件相关的信息，如文件创建的日期和时间、文件大小。我们可以称这些为文件的<code>属性(attributes)</code>。有些人也喜欢把它们称作 <code>元数据(metadata)</code>。文件的属性在不同的系统中差别很大。文件的属性只有两种状态：<code>设置(set)</code> 和 <code>清除(clear)</code>。</p><h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h3><p>使用文件的目的是用来存储信息并方便以后的检索。对于存储和检索，不同的系统提供了不同的操作。以下是与文件有关的最常用的一些系统调用：</p><ol><li><code>Create</code>，创建不包含任何数据的文件。调用的目的是表示文件即将建立，并对文件设置一些属性。</li><li><code>Delete</code>，当文件不再需要，必须删除它以释放内存空间。为此总会有一个系统调用来删除文件。</li><li><code>Open</code>，在使用文件之前，必须先打开文件。这个调用的目的是允许系统将属性和磁盘地址列表保存到主存中，用来以后的快速访问。</li><li><code>Close</code>，当所有进程完成时，属性和磁盘地址不再需要，因此应关闭文件以释放表空间。很多系统限制进程打开文件的个数，以此达到鼓励用户关闭不再使用的文件。磁盘以块为单位写入，关闭文件时会强制写入最后一<code>块</code>，即使这个块空间内部还不满。</li><li><code>Read</code>，数据从文件中读取。通常情况下，读取的数据来自文件的当前位置。调用者必须指定需要读取多少数据，并且提供存放这些数据的缓冲区。</li><li><code>Write</code>，向文件写数据，写操作一般也是从文件的当前位置开始进行。如果当前位置是文件的末尾，则会直接追加进行写入。如果当前位置在文件中，则现有数据被覆盖，并且永远消失。</li><li><code>append</code>，使用 append 只能向文件末尾添加数据。</li><li><code>seek</code>，对于随机访问的文件，要指定从何处开始获取数据。通常的方法是用 seek 系统调用把当前位置指针指向文件中的特定位置。seek 调用结束后，就可以从指定位置开始读写数据了。</li><li><code>get attributes</code>，进程运行时通常需要读取文件属性。</li><li><code>set attributes</code>，用户可以自己设置一些文件属性，甚至是在文件创建之后，实现该功能的是 set attributes 系统调用。</li><li><code>rename</code>，用户可以自己更改已有文件的名字，rename 系统调用用于这一目的。</li></ol><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><p>文件系统通常提供<code>目录(directories)</code> 或者 <code>文件夹(folders)</code> 用于记录文件的位置，在很多系统中目录本身也是文件，下面我们会讨论关于文件，他们的组织形式、属性和可以对文件进行的操作。</p><h3 id="一级目录系统"><a href="#一级目录系统" class="headerlink" title="一级目录系统"></a>一级目录系统</h3><p>目录系统最简单的形式是有一个能够包含所有文件的目录。这种目录被称为<code>根目录(root directory)</code>，由于根目录的唯一性，所以其名称并不重要。在最早期的个人计算机中，这种系统很常见，部分原因是因为只有一个用户。下面是一个单层目录系统的例子</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830155-ca95d416-207a-46d6-89dd-77c398a175d3.png#align=left&display=inline&height=306&margin=%5Bobject%20Object%5D&originHeight=306&originWidth=500&size=0&status=done&style=none&width=500"></p><p>含有四个文件的单层目录系统</p><p>该目录中有四个文件。这种设计的优点在于简单，并且能够快速定位文件，毕竟只有一个地方可以检索。这种目录组织形式现在一般用于简单的嵌入式设备（如数码相机和某些便携式音乐播放器）上使用。</p><h3 id="层次目录系统"><a href="#层次目录系统" class="headerlink" title="层次目录系统"></a>层次目录系统</h3><p>对于简单的应用而言，一般都用单层目录方式，但是这种组织形式并不适合于现代计算机，因为现代计算机含有成千上万个文件和文件夹。如果都放在根目录下，查找起来会非常困难。为了解决这一问题，出现了<code>层次目录系统(Hierarchical Directory Systems)</code>，也称为<code>目录树</code>。通过这种方式，可以用很多目录把文件进行分组。进而，如果多个用户共享同一个文件服务器，比如公司的网络系统，每个用户可以为自己的目录树拥有自己的私人根目录。这种方式的组织结构如下</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830190-cdcd48b8-b7ca-4597-b41d-d61089e0250d.png#align=left&display=inline&height=447&margin=%5Bobject%20Object%5D&originHeight=447&originWidth=699&size=0&status=done&style=none&width=699"></p><p>根目录含有目录 A、B 和 C ，分别属于不同的用户，其中两个用户个字创建了<code>子目录</code>。用户可以创建任意数量的子目录，现代文件系统都是按照这种方式组织的。</p><h3 id="路径名"><a href="#路径名" class="headerlink" title="路径名"></a>路径名</h3><p>当目录树组织文件系统时，需要有某种方法指明文件名。常用的方法有两种，第一种方式是每个文件都会用一个<code>绝对路径名(absolute path name)</code>，它由根目录到文件的路径组成。</p><p>另外一种指定文件名的方法是 <code>相对路径名(relative path name)</code>。它常常和 <code>工作目录(working directory)</code> （也称作 <code>当前目录(current directory)</code>）一起使用。用户可以指定一个目录作为当前工作目录。例如，如果当前目录是 <code>/usr/ast</code>，那么绝对路径 <code>/usr/ast/mailbox</code>可以直接使用 <code>mailbox</code> 来引用。</p><h3 id="目录操作"><a href="#目录操作" class="headerlink" title="目录操作"></a>目录操作</h3><p>不同文件中管理目录的系统调用的差别比管理文件的系统调用差别大。为了了解这些系统调用有哪些以及它们怎样工作，下面给出一个例子（取自 UNIX）。</p><ol><li><code>Create</code>，创建目录，除了目录项 <code>.</code> 和 <code>..</code> 外，目录内容为空。</li><li><code>Delete</code>，删除目录，只有空目录可以删除。只包含 <code>.</code> 和 <code>..</code> 的目录被认为是空目录，这两个目录项通常不能删除</li><li><code>opendir</code>，目录内容可被读取。例如，未列出目录中的全部文件，程序必须先打开该目录，然后读其中全部文件的文件名。与打开和读文件相同，在读目录前，必须先打开文件。</li><li><code>closedir</code>，读目录结束后，应该关闭目录用于释放内部表空间。</li><li><code>readdir</code>，系统调用 readdir 返回打开目录的下一个目录项。以前也采用 read 系统调用来读取目录，但是这种方法有一个缺点：程序员必须了解和处理目录的内部结构。相反，不论采用哪一种目录结构，readdir 总是以标准格式返回一个目录项。</li><li><code>rename</code>，在很多方面目录和文件都相似。文件可以更换名称，目录也可以。</li><li><code>link</code>，链接技术允许在多个目录中出现同一个文件。这个系统调用指定一个存在的文件和一个路径名，并建立从该文件到路径所指名字的链接。这样，可以在多个目录中出现同一个文件。有时也被称为<code>硬链接(hard link)</code>。</li><li><code>unlink</code>，删除目录项。如果被解除链接的文件只出现在一个目录中，则将它从文件中删除。如果它出现在多个目录中，则只删除指定路径名的链接，依然保留其他路径名的链接。在 UNIX 中，用于删除文件的系统调用就是 unlink。</li></ol><h2 id="文件系统的实现"><a href="#文件系统的实现" class="headerlink" title="文件系统的实现"></a>文件系统的实现</h2><h3 id="文件系统布局"><a href="#文件系统布局" class="headerlink" title="文件系统布局"></a>文件系统布局</h3><p>文件系统存储在<code>磁盘</code>中。大部分的磁盘能够划分出一到多个分区，叫做<code>磁盘分区(disk partitioning)</code> 或者是<code>磁盘分片(disk slicing)</code>。每个分区都有独立的文件系统，每块分区的文件系统可以不同。磁盘的 0 号分区称为 <code>主引导记录(Master Boot Record, MBR)</code>，用来<code>引导(boot)</code> 计算机。在 MBR 的结尾是<code>分区表(partition table)</code>。每个分区表给出每个分区由开始到结束的地址。</p><p>当计算机开始引 boot 时，BIOS 读入并执行 MBR。</p><h4 id="引导块"><a href="#引导块" class="headerlink" title="引导块"></a>引导块</h4><p>MBR 做的第一件事就是<code>确定活动分区</code>，读入它的第一个块，称为<code>引导块(boot block)</code> 并执行。引导块中的程序将加载分区中的操作系统。为了一致性，每个分区都会从引导块开始，即使引导块不包含操作系统。引导块占据文件系统的前 4096 个字节，从磁盘上的字节偏移量 0 开始。引导块可用于启动操作系统。</p><p>除了从引导块开始之外，磁盘分区的布局是随着文件系统的不同而变化的。通常文件系统会包含一些属性，如下</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830178-416c1399-355d-4e11-aaad-360c3071d651.png#align=left&display=inline&height=419&margin=%5Bobject%20Object%5D&originHeight=419&originWidth=725&size=0&status=done&style=none&width=725"></p><p>文件系统布局</p><h4 id="超级块"><a href="#超级块" class="headerlink" title="超级块"></a>超级块</h4><p>紧跟在引导块后面的是 <code>超级块(Superblock)</code>，超级块 的大小为 4096 字节，从磁盘上的字节偏移 4096 开始。超级块包含文件系统的所有关键参数</p><ul><li>文件系统的大小</li><li>文件系统中的数据块数</li><li>指示文件系统状态的标志</li><li>分配组大小</li></ul><p>在计算机启动或者文件系统首次使用时，超级块会被读入内存。</p><h4 id="空闲空间块"><a href="#空闲空间块" class="headerlink" title="空闲空间块"></a>空闲空间块</h4><p>接着是文件系统中<code>空闲块</code>的信息，例如，可以用位图或者指针列表的形式给出。</p><p><strong>BitMap 位图或者 Bit vector 位向量</strong></p><p>位图或位向量是一系列位或位的集合，其中每个位对应一个磁盘块，该位可以采用两个值：0 和 1，0 表示已分配该块，而 1 表示一个空闲块。下图中的磁盘上给定的磁盘块实例（分配了绿色块）可以用 16 位的位图表示为：0000111000000110。</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830202-8aab8dd3-4293-45ca-ab73-fdf893584edc.png#align=left&display=inline&height=428&margin=%5Bobject%20Object%5D&originHeight=428&originWidth=395&size=0&status=done&style=none&width=395"></p><p><strong>使用链表进行管理</strong></p><p>在这种方法中，空闲磁盘块链接在一起，即一个空闲块包含指向下一个空闲块的指针。第一个磁盘块的块号存储在磁盘上的单独位置，也缓存在内存中。</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830218-bc0ef6e9-c0df-4495-9a7f-4bd5161d4bef.png#align=left&display=inline&height=422&margin=%5Bobject%20Object%5D&originHeight=422&originWidth=432&size=0&status=done&style=none&width=432"></p><h4 id="碎片"><a href="#碎片" class="headerlink" title="碎片"></a>碎片</h4><p>这里不得不提一个叫做<code>碎片(fragment)</code>的概念，也称为片段。一般零散的单个数据通常称为片段。 磁盘块可以进一步分为固定大小的分配单元，片段只是在驱动器上彼此不相邻的文件片段。</p><h4 id="inode"><a href="#inode" class="headerlink" title="inode"></a>inode</h4><p>然后在后面是一个 <code>inode(index node)</code>，也称作索引节点。它是一个数组的结构，每个文件有一个 inode，inode 非常重要，它说明了文件的方方面面。每个索引节点都存储对象数据的属性和磁盘块位置</p><p>有一种简单的方法可以找到它们 <code>ls -lai</code> 命令。让我们看一下根文件系统：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830231-757b0e6a-7a82-4ec8-9a1c-15b9999e0185.png#align=left&display=inline&height=228&margin=%5Bobject%20Object%5D&originHeight=228&originWidth=725&size=0&status=done&style=none&width=725"></p><p>inode 节点主要包括了以下信息</p><ul><li>模式/权限（保护）</li><li>所有者 ID</li><li>组 ID</li><li>文件大小</li><li>文件的硬链接数</li><li>上次访问时间</li><li>最后修改时间</li><li>inode 上次修改时间</li></ul><p>文件分为两部分，索引节点和块。一旦创建后，每种类型的块数是固定的。你不能增加分区上 inode 的数量，也不能增加磁盘块的数量。</p><p>紧跟在 inode 后面的是根目录，它存放的是文件系统目录树的根部。最后，磁盘的其他部分存放了其他所有的目录和文件。</p><h3 id="文件的实现"><a href="#文件的实现" class="headerlink" title="文件的实现"></a>文件的实现</h3><p>最重要的问题是记录各个文件分别用到了哪些磁盘块。不同的系统采用了不同的方法。下面我们会探讨一下这些方式。分配背后的主要思想是<code>有效利用文件空间</code>和<code>快速访问文件</code> ，主要有三种分配方案</p><ul><li>连续分配</li><li>链表分配</li><li>索引分配</li></ul><h4 id="连续分配"><a href="#连续分配" class="headerlink" title="连续分配"></a>连续分配</h4><p>最简单的分配方案是把每个文件作为一连串连续数据块存储在磁盘上。因此，在具有 1KB 块的磁盘上，将为 50 KB 文件分配 50 个连续块。</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830290-96589d90-fa12-43fb-a38a-8ece59db8fcd.png#align=left&display=inline&height=267&margin=%5Bobject%20Object%5D&originHeight=267&originWidth=708&size=0&status=done&style=none&width=708"></p><p>使用连续空间存储文件</p><p>上面展示了 40 个连续的内存块。从最左侧的 0 块开始。初始状态下，还没有装载文件，因此磁盘是空的。接着，从磁盘开始处（块 0 ）处开始写入占用 4 块长度的内存 A 。然后是一个占用 6 块长度的内存 B，会直接在 A 的末尾开始写。</p><p>注意每个文件都会在新的文件块开始写，所以如果文件 A 只占用了 <code>3 又 1/2</code> 个块，那么最后一个块的部分内存会被浪费。在上面这幅图中，总共展示了 7 个文件，每个文件都会从上个文件的末尾块开始写新的文件块。</p><p>连续的磁盘空间分配有两个优点。</p><ul><li>第一，连续文件存储实现起来比较简单，只需要记住两个数字就可以：一个是第一个块的文件地址和文件的块数量。给定第一个块的编号，可以通过简单的加法找到任何其他块的编号。</li><li>第二点是读取性能比较强，可以通过一次操作从文件中读取整个文件。只需要一次寻找第一个块。后面就不再需要寻道时间和旋转延迟，所以数据会以全带宽进入磁盘。</li></ul><p>因此，连续的空间分配具有<code>实现简单</code>、<code>高性能</code>的特点。</p><p>不幸的是，连续空间分配也有很明显的不足。随着时间的推移，磁盘会变得很零碎。下图解释了这种现象</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830262-ef7ce9d8-c4b9-488c-a2d3-48d7888ffe1f.png#align=left&display=inline&height=250&margin=%5Bobject%20Object%5D&originHeight=250&originWidth=700&size=0&status=done&style=none&width=700"></p><p>这里有两个文件 D 和 F 被删除了。当删除一个文件时，此文件所占用的块也随之释放，就会在磁盘空间中留下一些空闲块。磁盘并不会在这个位置挤压掉空闲块，因为这会复制空闲块之后的所有文件，可能会有上百万的块，这个量级就太大了。</p><h4 id="链表分配"><a href="#链表分配" class="headerlink" title="链表分配"></a>链表分配</h4><p>第二种存储文件的方式是为每个文件构造磁盘块链表，每个文件都是磁盘块的链接列表，就像下面所示</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830296-9199d50b-5e5b-43f4-a62b-dc0b1ef02d6d.png#align=left&display=inline&height=472&margin=%5Bobject%20Object%5D&originHeight=472&originWidth=739&size=0&status=done&style=none&width=739"></p><p>以磁盘块的链表形式存储文件</p><p>每个块的第一个字作为指向下一块的指针，块的其他部分存放数据。如果上面这张图你看的不是很清楚的话，可以看看整个的链表分配方案</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830272-99171e3f-0aae-4fa7-b127-e43f64daed7d.png#align=left&display=inline&height=548&margin=%5Bobject%20Object%5D&originHeight=548&originWidth=717&size=0&status=done&style=none&width=717"></p><p>与连续分配方案不同，这一方法可以充分利用每个磁盘块。除了最后一个磁盘块外，不会因为磁盘碎片而浪费存储空间。同样，在目录项中，只要存储了第一个文件块，那么其他文件块也能够被找到。</p><p>另一方面，在链表的分配方案中，尽管顺序读取非常方便，但是随机访问却很困难（这也是数组和链表数据结构的一大区别）。</p><p>还有一个问题是，由于指针会占用一些字节，每个磁盘块实际存储数据的字节数并不再是 2 的整数次幂。虽然这个问题并不会很严重，但是这种方式降低了程序运行效率。许多程序都是以长度为 2 的整数次幂来读写磁盘，由于每个块的前几个字节被指针所使用，所以要读出一个完成的块大小信息，就需要当前块的信息和下一块的信息拼凑而成，因此就引发了查找和拼接的开销。</p><h4 id="使用内存表进行链表分配"><a href="#使用内存表进行链表分配" class="headerlink" title="使用内存表进行链表分配"></a>使用内存表进行链表分配</h4><p>由于连续分配和链表分配都有其不可忽视的缺点。所以提出了使用内存中的表来解决分配问题。取出每个磁盘块的指针字，把它们放在内存的一个表中，就可以解决上述链表的两个不足之处。下面是一个例子</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830309-8180ae56-d298-4224-a60b-d472bd7dff53.png#align=left&display=inline&height=448&margin=%5Bobject%20Object%5D&originHeight=448&originWidth=499&size=0&status=done&style=none&width=499"></p><p>上图表示了链表形成的磁盘块的内容。这两个图中都有两个文件，文件 A 依次使用了磁盘块地址 <strong>4、7、 2、 10、 12</strong>，文件 B 使用了<strong>6、3、11 和 14</strong>。也就是说，文件 A 从地址 4 处开始，顺着链表走就能找到文件 A 的全部磁盘块。同样，从第 6 块开始，顺着链走到最后，也能够找到文件 B 的全部磁盘块。你会发现，这两个链表都以不属于有效磁盘编号的特殊标记（-1）结束。内存中的这种表格称为 <code>文件分配表(File Application Table,FAT)</code>。</p><h3 id="目录的实现"><a href="#目录的实现" class="headerlink" title="目录的实现"></a>目录的实现</h3><p>文件只有打开后才能够被读取。在文件打开后，操作系统会使用用户提供的路径名来定位磁盘中的目录。目录项提供了查找文件磁盘块所需要的信息。根据系统的不同，提供的信息也不同，可能提供的信息是整个文件的磁盘地址，或者是第一个块的数量（两个链表方案）或 inode 的数量。不过不管用那种情况，目录系统的主要功能就是 <strong>将文件的 ASCII 码的名称映射到定位数据所需的信息上</strong>。</p><h3 id="共享文件"><a href="#共享文件" class="headerlink" title="共享文件"></a>共享文件</h3><p>当多个用户在同一个项目中工作时，他们通常需要共享文件。如果这个共享文件同时出现在多个用户目录下，那么他们协同工作起来就很方便。下面的这张图我们在上面提到过，但是有一个更改的地方，就是 <strong>C 的一个文件也出现在了 B 的目录下</strong>。</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830321-b6391c5b-3b64-4089-9c4e-9a9afd09875c.png#align=left&display=inline&height=559&margin=%5Bobject%20Object%5D&originHeight=559&originWidth=743&size=0&status=done&style=none&width=743"></p><p>如果按照如上图的这种组织方式而言，那么 B 的目录与该共享文件的联系称为 <code>链接(link)</code>。那么文件系统现在就是一个 <code>有向无环图(Directed Acyclic Graph, 简称 DAG)</code>，而不是一棵树了。</p><h3 id="日志结构文件系统"><a href="#日志结构文件系统" class="headerlink" title="日志结构文件系统"></a>日志结构文件系统</h3><p>技术的改变会给当前的文件系统带来压力。这种情况下，CPU 会变得越来越快，磁盘会变得越来越大并且越来越便宜（但不会越来越快）。内存容量也是以指数级增长。但是磁盘的寻道时间（除了固态盘，因为固态盘没有寻道时间）并没有获得提高。</p><p>为此，<code>Berkeley</code> 设计了一种全新的文件系统，试图缓解这个问题，这个文件系统就是 <code>日志结构文件系统(Log-structured File System, LFS)</code>。旨在解决以下问题。</p><ul><li>不断增长的系统内存</li><li>顺序 I/O 性能胜过随机 I/O 性能</li><li>现有低效率的文件系统</li><li>文件系统不支持 RAID（虚拟化）</li></ul><p>另一方面，当时的文件系统不论是 UNIX 还是 FFS，都有大量的随机读写（在 FFS 中创建一个新文件至少需要 5 次随机写），因此成为整个系统的性能瓶颈。同时因为 <code>Page cache</code> 的存在，作者认为随机读不是主要问题：随着越来越大的内存，大部分的读操作都能被 cache，因此 LFS 主要要解决的是减少对硬盘的随机写操作。</p><p>在这种设计中，inode 甚至具有与 UNIX 中相同的结构，但是现在它们分散在整个日志中，而不是位于磁盘上的固定位置。所以，inode 很定位。为了能够找到 inode ，维护了一个由 inode 索引的 <code>inode map(inode 映射)</code>。表项 i 指向磁盘中的第 i 个 inode 。这个映射保存在磁盘中，但是也保存在缓存中，因此，使用最频繁的部分大部分时间都在内存中。</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830360-ead8d1cc-da6e-40bc-896b-4350498bf5c8.png#align=left&display=inline&height=348&margin=%5Bobject%20Object%5D&originHeight=348&originWidth=732&size=0&status=done&style=none&width=732"></p><p>到目前为止，所有写入最初都缓存在<code>内存</code>中，并且追加在<code>日志末尾</code>，所有缓存的写入都定期在单个段中写入磁盘。所以，现在打开文件也就意味着用映射定位文件的索引节点。一旦 inode 被定位后，磁盘块的地址就能够被找到。所有这些块本身都将位于日志中某处的分段中。</p><p>真实情况下的磁盘容量是有限的，所以最终日志会占满整个磁盘空间，这种情况下就会出现没有新的磁盘块被写入到日志中。幸运的是，许多现有段可能具有不再需要的块。例如，如果一个文件被覆盖了，那么它的 inode 将被指向新的块，但是旧的磁盘块仍在先前写入的段中占据着空间。</p><p>为了处理这个问题，LFS 有一个<code>清理(clean)</code>线程，它会循环扫描日志并对日志进行压缩。首先，通过查看日志中第一部分的信息来查看其中存在哪些索引节点和文件。它会检查当前 inode 的映射来查看 inode 否在在当前块中，是否仍在被使用。如果不是，该信息将被丢弃。如果仍然在使用，那么 inode 和块就会进入内存等待写回到下一个段中。然后原来的段被标记为空闲，以便日志可以用来存放新的数据。用这种方法，清理线程遍历日志，从后面移走旧的段，然后将有效的数据放入内存等待写到下一个段中。由此一来整个磁盘会形成一个大的<code>环形缓冲区</code>，写线程将新的段写在前面，而清理线程则清理后面的段。</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830348-81e32c04-1184-4cdb-8403-2efeeb68787c.png#align=left&display=inline&height=236&margin=%5Bobject%20Object%5D&originHeight=236&originWidth=631&size=0&status=done&style=none&width=631"></p><h3 id="日志文件系统"><a href="#日志文件系统" class="headerlink" title="日志文件系统"></a>日志文件系统</h3><p>虽然日志结构系统的设计很优雅，但是由于它们和现有的文件系统不相匹配，因此还没有广泛使用。不过，从日志文件结构系统衍生出来一种新的日志系统，叫做<code>日志文件系统</code>，它会记录系统下一步将要做什么的日志。微软的 <code>NTFS</code> 文件系统、Linux 的 <code>ext3</code> 就使用了此日志。 <code>OS X</code> 将日志系统作为可供选项。为了看清它是如何工作的，我们下面讨论一个例子，比如 <code>移除文件</code> ，这个操作在 UNIX 中需要三个步骤完成：</p><ul><li>在目录中删除文件</li><li>释放 inode 到空闲 inode 池</li><li>将所有磁盘块归还给空闲磁盘池。</li></ul><h3 id="虚拟文件系统"><a href="#虚拟文件系统" class="headerlink" title="虚拟文件系统"></a>虚拟文件系统</h3><p>UNIX 操作系统使用一种 <code>虚拟文件系统(Virtual File System, VFS)</code> 来尝试将多种文件系统构成一个有序的结构。关键的思想是抽象出所有文件系统都共有的部分，并将这部分代码放在一层，这一层再调用具体文件系统来管理数据。下面是一个 VFS 的系统结构</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830356-635b72b4-bcf2-434f-9719-c83b191da6cf.png#align=left&display=inline&height=345&margin=%5Bobject%20Object%5D&originHeight=345&originWidth=675&size=0&status=done&style=none&width=675"></p><p>还是那句经典的话，在计算机世界中，任何解决不了的问题都可以加个<code>代理</code>来解决。所有和文件相关的系统调用在最初的处理上都指向虚拟文件系统。这些来自用户进程的调用，都是标准的 <code>POSIX 系统调用</code>，比如 open、read、write 和 seek 等。VFS 对用户进程有一个 <code>上层</code> 接口，这个接口就是著名的 POSIX 接口。</p><h2 id="文件系统的管理和优化"><a href="#文件系统的管理和优化" class="headerlink" title="文件系统的管理和优化"></a>文件系统的管理和优化</h2><p>能够使文件系统工作是一回事，能够使文件系统高效、稳定的工作是另一回事，下面我们就来探讨一下文件系统的管理和优化。</p><h3 id="磁盘空间管理"><a href="#磁盘空间管理" class="headerlink" title="磁盘空间管理"></a>磁盘空间管理</h3><p>文件通常存在磁盘中，所以如何管理磁盘空间是一个操作系统的设计者需要考虑的问题。在文件上进行存有两种策略：<strong>分配 n 个字节的连续磁盘空间；或者把文件拆分成多个并不一定连续的块</strong>。在存储管理系统中，主要有<code>分段管理</code>和 <code>分页管理</code> 两种方式。</p><p>正如我们所看到的，按<code>连续字节序列</code>存储文件有一个明显的问题，当文件扩大时，有可能需要在磁盘上移动文件。内存中分段也有同样的问题。不同的是，相对于把文件从磁盘的一个位置移动到另一个位置，内存中段的移动操作要快很多。因此，几乎所有的文件系统都把文件分割成固定大小的块来存储。</p><h4 id="块大小"><a href="#块大小" class="headerlink" title="块大小"></a>块大小</h4><p>一旦把文件分为固定大小的块来存储，就会出现问题，块的大小是多少？按照<strong>磁盘组织方式，扇区、磁道和柱面显然都可以作为分配单位</strong>。在分页系统中，分页大小也是主要因素。</p><p>拥有大的块尺寸意味着每个文件，甚至 1 字节文件，都要占用一个柱面空间，也就是说小文件浪费了大量的磁盘空间。另一方面，小块意味着大部分文件将会跨越多个块，因此需要多次搜索和旋转延迟才能读取它们，从而降低了性能。因此，如果分配的块<code>太大</code>会浪费<code>空间</code>；分配的块<code>太小</code>会浪费<code>时间</code>。</p><h4 id="记录空闲块"><a href="#记录空闲块" class="headerlink" title="记录空闲块"></a>记录空闲块</h4><p>一旦指定了块大小，下一个问题就是怎样跟踪空闲块。有两种方法被广泛采用，如下图所示</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830365-86ca166a-5dd1-4e96-b9b4-2966e2d87565.png#align=left&display=inline&height=476&margin=%5Bobject%20Object%5D&originHeight=476&originWidth=753&size=0&status=done&style=none&width=753"></p><p>第一种方法是采用<code>磁盘块链表</code>，链表的每个块中包含极可能多的空闲磁盘块号。对于 1 KB 的块和 32 位的磁盘块号，空闲表中每个块包含有 255 个空闲的块号。考虑 1 TB 的硬盘，拥有大概十亿个磁盘块。为了存储全部地址块号，如果每块可以保存 255 个块号，则需要将近 400 万个块。通常，空闲块用于保存空闲列表，因此存储基本上是空闲的。</p><p>另一种空闲空间管理的技术是<code>位图(bitmap)</code>，n 个块的磁盘需要 n 位位图。在位图中，空闲块用 1 表示，已分配的块用 0 表示。对于 1 TB 硬盘的例子，需要 10 亿位表示，即需要大约 130 000 个 1 KB 块存储。很明显，和 32 位链表模型相比，位图需要的空间更少，因为每个块使用 1 位。只有当磁盘快满的时候，链表需要的块才会比位图少。</p><h3 id="磁盘配额"><a href="#磁盘配额" class="headerlink" title="磁盘配额"></a>磁盘配额</h3><p>为了防止一些用户占用太多的磁盘空间，多用户操作通常提供一种<code>磁盘配额(enforcing disk quotas)</code>的机制。系统管理员为每个用户分配<strong>最大的文件和块分配</strong>，并且操作系统确保用户不会超过其配额。我们下面会谈到这一机制。</p><p>在用户打开一个文件时，操作系统会找到<code>文件属性</code>和<code>磁盘地址</code>，并把它们送入内存中的打开文件表。其中一个属性告诉<code>文件所有者</code>是谁。任何有关文件的增加都会记到所有者的配额中。</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830397-dc14e657-f7ce-4c0e-a2fc-dae37cdce37e.png#align=left&display=inline&height=532&margin=%5Bobject%20Object%5D&originHeight=532&originWidth=681&size=0&status=done&style=none&width=681"></p><p>配额表中记录了每个用户的配额</p><p>第二张表包含了每个用户当前打开文件的配额记录，即使是其他人打开该文件也一样。如上图所示，该表的内容是从被打开文件的所有者的磁盘配额文件中提取出来的。当所有文件关闭时，该记录被写回配额文件。</p><p>当在打开文件表中建立一新表项时，会产生一个指向所有者配额记录的指针。每次向文件中添加一个块时，文件所有者所用数据块的总数也随之增加，并会同时增加<code>硬限制</code>和<code>软限制</code>的检查。可以超出软限制，但硬限制不可以超出。当已达到硬限制时，再往文件中添加内容将引发错误。同样，对文件数目也存在类似的检查。</p><h3 id="文件系统备份"><a href="#文件系统备份" class="headerlink" title="文件系统备份"></a>文件系统备份</h3><p>做文件备份很耗费时间而且也很浪费空间，这会引起下面几个问题。首先，是要<strong>备份整个文件还是仅备份一部分呢</strong>？一般来说，只是备份特定目录及其下的全部文件，而不是备份整个文件系统。</p><p>其次，对上次未修改过的文件再进行备份是一种浪费，因而产生了一种<code>增量转储(incremental dumps)</code> 的思想。最简单的增量转储的形式就是<code>周期性</code>的做全面的备份，而每天只对增量转储完成后发生变化的文件做单个备份。</p><p>稍微好一点的方式是只备份最近一次转储以来更改过的文件。当然，这种做法极大的缩减了转储时间，但恢复起来却更复杂，因为<strong>最近的全面转储先要全部恢复，随后按逆序进行增量转储</strong>。为了方便恢复，人们往往使用更复杂的转储模式。</p><p>第三，既然待转储的往往是海量数据，那么在将其写入磁带之前对文件进行压缩就很有必要。但是，如果在备份过程中出现了文件损坏的情况，就会导致破坏压缩算法，从而使整个磁带无法读取。所以在备份前是否进行文件压缩需慎重考虑。</p><p>第四，对正在使用的文件系统做备份是很难的。如果在转储过程中要添加，删除和修改文件和目录，则转储结果可能不一致。因此，因为转储过程中需要花费数个小时的时间，所以有必要在晚上将系统脱机进行备份，然而这种方式的接受程度并不高。所以，人们修改了转储算法，记下文件系统的<code>瞬时快照</code>，即复制关键的数据结构，然后需要把将来对文件和目录所做的修改复制到块中，而不是到处更新他们。</p><p>磁盘转储到备份磁盘上有两种方案：<strong>物理转储和逻辑转储</strong>。<code>物理转储(physical dump)</code> 是从磁盘的 0 块开始，依次将所有磁盘块按照顺序写入到输出磁盘，并在复制最后一个磁盘时停止。这种程序的万无一失性是其他程序所不具备的。</p><p>第二个需要考虑的是<strong>坏块的转储</strong>。制造大型磁盘而没有瑕疵是不可能的，所以也会存在一些<code>坏块(bad blocks)</code>。有时进行低级格式化后，坏块会被检测出来并进行标记，这种情况的解决办法是用磁盘末尾的一些空闲块所替换。</p><p>然而，一些块在格式化后会变坏，在这种情况下操作系统可以检测到它们。通常情况下，它可以通过创建一个由所有坏块组成的<code>文件</code>来解决问题，确保它们不会出现在空闲池中并且永远不会被分配。<strong>那么此文件是完全不可读的</strong>。如果磁盘控制器将所有的坏块重新映射，物理转储还是能够正常工作的。</p><p>Windows 系统有<code>分页文件(paging files)</code> 和 <code>休眠文件(hibernation files)</code> 。它们在文件还原时不发挥作用，同时也不应该在第一时间进行备份。</p><h3 id="文件系统的一致性"><a href="#文件系统的一致性" class="headerlink" title="文件系统的一致性"></a>文件系统的一致性</h3><p>影响可靠性的一个因素是文件系统的一致性。许多文件系统读取磁盘块、修改磁盘块、再把它们写回磁盘。如果系统在所有块写入之前崩溃，文件系统就会处于一种<code>不一致(inconsistent)</code>的状态。如果某些尚未写回的块是索引节点块，目录块或包含空闲列表的块，则此问题是很严重的。</p><p>为了处理文件系统一致性问题，大部分计算机都会有应用程序来检查文件系统的一致性。例如，UNIX 有 <code>fsck</code>；Windows 有 <code>sfc</code>，每当引导系统时（尤其是在崩溃后），都可以运行该程序。</p><p>可以进行两种一致性检查：<strong>块的一致性检查和文件的一致性检查</strong>。为了检查块的一致性，应用程序会建立两张表，每个包含一个计数器的块，最初设置为 0 。第一个表中的计数器跟踪该块在文件中出现的次数，第二张表中的计数器记录每个块在空闲列表、空闲位图中出现的频率。</p><h3 id="文件系统性能"><a href="#文件系统性能" class="headerlink" title="文件系统性能"></a>文件系统性能</h3><p>访问磁盘的效率要比内存满的多，是时候又祭出这张图了</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830422-af95403a-f195-4d9e-8125-0d05ec7651ff.png#align=left&display=inline&height=312&margin=%5Bobject%20Object%5D&originHeight=312&originWidth=711&size=0&status=done&style=none&width=711"></p><p>从内存读一个 32 位字大概是 10ns，从硬盘上读的速率大概是 100MB/S，对每个 32 位字来说，效率会慢了四倍，另外，还要加上 5 - 10 ms 的寻道时间等其他损耗，如果只访问一个字，内存要比磁盘快百万数量级。所以磁盘优化是很有必要的，下面我们会讨论几种优化方式</p><h4 id="高速缓存"><a href="#高速缓存" class="headerlink" title="高速缓存"></a>高速缓存</h4><p>最常用的减少磁盘访问次数的技术是使用 <code>块高速缓存(block cache)</code> 或者 <code>缓冲区高速缓存(buffer cache)</code>。高速缓存指的是一系列的块，它们在逻辑上属于磁盘，但实际上基于性能的考虑被保存在内存中。</p><p>管理高速缓存有不同的算法，常用的算法是：检查全部的读请求，查看在高速缓存中是否有所需要的块。如果存在，可执行读操作而无须访问磁盘。如果检查块不再高速缓存中，那么首先把它读入高速缓存，再复制到所需的地方。之后，对同一个块的请求都通过<code>高速缓存</code>来完成。</p><p>高速缓存的操作如下图所示</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830486-9b7cd7d5-cd58-485e-8fb9-7c5f918fb69a.png#align=left&display=inline&height=262&margin=%5Bobject%20Object%5D&originHeight=262&originWidth=733&size=0&status=done&style=none&width=733"></p><p>由于在高速缓存中有许多块，所以需要某种方法快速确定所需的块是否存在。常用方法是将设备和磁盘地址进行散列操作，然后，在散列表中查找结果。具有相同散列值的块在一个链表中连接在一起（这个数据结构是不是很像 HashMap?），这样就可以沿着冲突链查找其他块。</p><p>如果高速缓存<code>已满</code>，此时需要调入新的块，则要把原来的某一块调出高速缓存，如果要调出的块在上次调入后已经被修改过，则需要把它写回磁盘。</p><h4 id="块提前读"><a href="#块提前读" class="headerlink" title="块提前读"></a>块提前读</h4><p>第二个明显提高文件系统的性能是，在需要用到块之前，试图<code>提前</code>将其写入高速缓存，从而<code>提高命中率</code>。许多文件都是顺序读取。如果请求文件系统在某个文件中生成块 k，文件系统执行相关操作并且在完成之后，会检查高速缓存，以便确定块 k + 1 是否已经在高速缓存。如果不在，文件系统会为 k + 1 安排一个预读取，因为文件希望在用到该块的时候能够直接从高速缓存中读取。</p><p>当然，块提前读取策略只适用于实际顺序读取的文件。对随机访问的文件，提前读丝毫不起作用。甚至还会造成阻碍。</p><h4 id="减少磁盘臂运动"><a href="#减少磁盘臂运动" class="headerlink" title="减少磁盘臂运动"></a>减少磁盘臂运动</h4><p>高速缓存和块提前读并不是提高文件系统性能的唯一方法。另一种重要的技术是<strong>把有可能顺序访问的块放在一起，当然最好是在同一个柱面上，从而减少磁盘臂的移动次数</strong>。当写一个输出文件时，文件系统就必须按照要求一次一次地分配磁盘块。如果用位图来记录空闲块，并且整个位图在内存中，那么选择与前一块最近的空闲块是很容易的。如果用空闲表，并且链表的一部分存在磁盘上，要分配紧邻的空闲块就会困难很多。</p><h4 id="磁盘碎片整理"><a href="#磁盘碎片整理" class="headerlink" title="磁盘碎片整理"></a>磁盘碎片整理</h4><p>在初始安装操作系统后，文件就会被不断的创建和清除，于是磁盘会产生很多的碎片，在创建一个文件时，它使用的块会散布在整个磁盘上，降低性能。删除文件后，回收磁盘块，可能会造成空穴。</p><p>磁盘性能可以通过如下方式恢复：移动文件使它们相互挨着，并把所有的至少是大部分的空闲空间放在一个或多个大的连续区域内。Windows 有一个程序 <code>defrag</code> 就是做这个事儿的。Windows 用户会经常使用它，SSD 除外。</p><p>磁盘碎片整理程序会在让文件系统上很好地运行。Linux 文件系统（特别是 ext2 和 ext3）由于其选择磁盘块的方式，在磁盘碎片整理上一般不会像 Windows 一样困难，因此很少需要手动的磁盘碎片整理。而且，固态硬盘并不受磁盘碎片的影响，事实上，在固态硬盘上做磁盘碎片整理反倒是多此一举，不仅没有提高性能，反而磨损了固态硬盘。所以碎片整理只会缩短固态硬盘的寿命。</p><p>下面我们来探讨一下 I/O 流程问题。</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830481-2693434c-6334-4f5a-a152-75454e91d275.png#align=left&display=inline&height=474&margin=%5Bobject%20Object%5D&originHeight=474&originWidth=752&size=0&status=done&style=none&width=752"></p><h2 id="I-O-设备"><a href="#I-O-设备" class="headerlink" title="I/O 设备"></a>I/O 设备</h2><p>什么是 I/O 设备？I/O 设备又叫做输入/输出设备，它是人类用来和计算机进行通信的外部硬件。输入/输出设备能够向计算机<code>发送数据（输出）</code>并从计算机<code>接收数据（输入）</code>。</p><p><code>I/O 设备(I/O devices)</code>可以分成两种：<code>块设备(block devices)</code> 和 <code>字符设备(character devices)</code>。</p><h4 id="块设备"><a href="#块设备" class="headerlink" title="块设备"></a>块设备</h4><p>块设备是一个能存储<code>固定大小块</code>信息的设备，它支持<strong>以固定大小的块，扇区或群集读取和（可选）写入数据</strong>。每个块都有自己的<code>物理地址</code>。通常块的大小在 512 - 65536 之间。所有传输的信息都会以<code>连续</code>的块为单位。块设备的基本特征是每个块都较为对立，能够独立的进行读写。常见的块设备有 <strong>硬盘、蓝光光盘、USB 盘</strong></p><p>与字符设备相比，块设备通常需要较少的引脚。</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830476-de4c28f8-7881-487b-9bc3-11bf81770f23.png#align=left&display=inline&height=257&margin=%5Bobject%20Object%5D&originHeight=257&originWidth=700&size=0&status=done&style=none&width=700"></p><h4 id="块设备的缺点"><a href="#块设备的缺点" class="headerlink" title="块设备的缺点"></a>块设备的缺点</h4><p>基于给定固态存储器的块设备比基于相同类型的存储器的字节寻址要慢一些，因为必须在块的开头开始读取或写入。所以，要读取该块的任何部分，必须寻找到该块的开始，读取整个块，如果不使用该块，则将其丢弃。要写入块的一部分，必须寻找到块的开始，将整个块读入内存，修改数据，再次寻找到块的开头处，然后将整个块写回设备。</p><h4 id="字符设备"><a href="#字符设备" class="headerlink" title="字符设备"></a>字符设备</h4><p>另一类 I/O 设备是<code>字符设备</code>。字符设备以<code>字符</code>为单位发送或接收一个字符流，而不考虑任何块结构。字符设备是不可寻址的，也没有任何寻道操作。常见的字符设备有 <strong>打印机、网络设备、鼠标、以及大多数与磁盘不同的设备</strong>。</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830510-e704b09f-ae66-45ce-bde4-66fd175dc769.png#align=left&display=inline&height=322&margin=%5Bobject%20Object%5D&originHeight=322&originWidth=703&size=0&status=done&style=none&width=703"></p><h3 id="设备控制器"><a href="#设备控制器" class="headerlink" title="设备控制器"></a>设备控制器</h3><p>设备控制器是处理 CPU 传入和传出信号的系统。设备通过插头和插座连接到计算机，并且插座连接到设备控制器。设备控制器从连接的设备处接收数据，并将其存储在控制器内部的一些<code>特殊目的寄存器(special purpose registers)</code> 也就是本地缓冲区中。</p><p>每个设备控制器都会有一个应用程序与之对应，设备控制器通过应用程序的接口通过中断与操作系统进行通信。设备控制器是硬件，而设备驱动程序是软件。</p><h3 id="内存映射-I-O"><a href="#内存映射-I-O" class="headerlink" title="内存映射 I/O"></a>内存映射 I/O</h3><p>每个控制器都会有几个寄存器用来和 CPU 进行通信。通过写入这些寄存器，操作系统可以命令设备发送数据，接收数据、开启或者关闭设备等。通过从这些寄存器中读取信息，操作系统能够知道设备的状态，是否准备接受一个新命令等。</p><p>为了控制<code>寄存器</code>，许多设备都会有<code>数据缓冲区(data buffer)</code>，来供系统进行读写。</p><p>那么问题来了，CPU 如何与设备寄存器和设备数据缓冲区进行通信呢？存在两个可选的方式。第一种方法是，每个控制寄存器都被分配一个 <code>I/O 端口(I/O port)</code>号，这是一个 8 位或 16 位的整数。所有 I/O 端口的集合形成了受保护的 I/O 端口空间，以便普通用户程序无法访问它（只有操作系统可以访问）。使用特殊的 I/O 指令像是</p><pre><code class="assembly">IN REG,PORT</code></pre><p>CPU 可以读取控制寄存器 PORT 的内容并将结果放在 CPU 寄存器 REG 中。类似的，使用</p><pre><code class="assembly">OUT PORT,REG</code></pre><p>CPU 可以将 REG 的内容写到控制寄存器中。大多数早期计算机，包括几乎所有大型主机，如 IBM 360 及其所有后续机型，都是以这种方式工作的。</p><p>第二个方法是 PDP-11 引入的，它将<strong>所有控制寄存器映射到内存空间</strong>中。</p><h3 id="直接内存访问"><a href="#直接内存访问" class="headerlink" title="直接内存访问"></a>直接内存访问</h3><p>无论一个 CPU 是否具有内存映射 I/O，它都需要寻址设备控制器以便与它们交换数据。CPU 可以从 I/O 控制器每次请求一个字节的数据，但是这么做会浪费 CPU 时间，所以经常会用到一种称为<code>直接内存访问(Direct Memory Access)</code> 的方案。为了简化，我们假设 CPU 通过单一的系统总线访问所有的设备和内存，该总线连接 CPU 、内存和 I/O 设备，如下图所示</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830508-9d21c036-35f6-4f66-a119-b33cd2ebffa9.png#align=left&display=inline&height=351&margin=%5Bobject%20Object%5D&originHeight=351&originWidth=720&size=0&status=done&style=none&width=720"></p><p>DMA 传送操作</p><p>现代操作系统实际更为复杂，但是原理是相同的。如果硬件有 <code>DMA 控制器</code>，那么操作系统只能使用 DMA。有时这个控制器会集成到磁盘控制器和其他控制器中，但这种设计需要在每个设备上都装有一个分离的 DMA 控制器。单个的 DMA 控制器可用于向多个设备传输，这种传输往往同时进行。</p><h4 id="DMA-工作原理"><a href="#DMA-工作原理" class="headerlink" title="DMA 工作原理"></a>DMA 工作原理</h4><p>首先 CPU 通过设置 DMA 控制器的寄存器对它进行编程，所以 DMA 控制器知道将什么数据传送到什么地方。DMA 控制器还要向磁盘控制器发出一个命令，通知它从磁盘读数据到其内部的缓冲区并检验校验和。当有效数据位于磁盘控制器的缓冲区中时，DMA 就可以开始了。</p><p>DMA 控制器通过在总线上发出一个<code>读请求</code>到磁盘控制器而发起 DMA 传送，这是第二步。这个读请求就像其他读请求一样，磁盘控制器并不知道或者并不关心它是来自 CPU 还是来自 DMA 控制器。通常情况下，要写的内存地址在总线的地址线上，所以当磁盘控制器去匹配下一个字时，它知道将该字写到什么地方。写到内存就是另外一个总线循环了，这是第三步。当写操作完成时，磁盘控制器在总线上发出一个应答信号到 DMA 控制器，这是第四步。</p><p>然后，DMA 控制器会增加内存地址并减少字节数量。如果字节数量仍然大于 0 ，就会循环步骤 2 - 步骤 4 ，直到字节计数变为 0 。此时，DMA 控制器会打断 CPU 并告诉它传输已经完成了。</p><h3 id="重温中断"><a href="#重温中断" class="headerlink" title="重温中断"></a>重温中断</h3><p>在一台个人计算机体系结构中，中断结构会如下所示</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830529-8f149c71-9817-4096-a8df-b613c0308a0c.png#align=left&display=inline&height=320&margin=%5Bobject%20Object%5D&originHeight=320&originWidth=719&size=0&status=done&style=none&width=719"></p><p>中断是怎样发生的</p><p>当一个 I/O 设备完成它的工作后，它就会产生一个中断（默认操作系统已经开启中断），它通过在总线上声明已分配的信号来实现此目的。主板上的中断控制器芯片会检测到这个信号，然后执行中断操作。</p><h4 id="精确中断和不精确中断"><a href="#精确中断和不精确中断" class="headerlink" title="精确中断和不精确中断"></a>精确中断和不精确中断</h4><p>使机器处于良好状态的中断称为<code>精确中断(precise interrupt)</code>。这样的中断具有四个属性：</p><ul><li>PC （程序计数器）保存在一个已知的地方</li><li>PC 所指向的指令之前所有的指令已经完全执行</li><li>PC 所指向的指令之后所有的指令都没有执行</li><li>PC 所指向的指令的执行状态是已知的</li></ul><p>不满足以上要求的中断称为 <code>不精确中断(imprecise interrupt)</code>，不精确中断让人很头疼。上图描述了不精确中断的现象。指令的执行时序和完成度具有不确定性，而且恢复起来也非常麻烦。</p><h2 id="IO-软件原理"><a href="#IO-软件原理" class="headerlink" title="IO 软件原理"></a>IO 软件原理</h2><h3 id="I-O-软件目标"><a href="#I-O-软件目标" class="headerlink" title="I/O 软件目标"></a>I/O 软件目标</h3><h4 id="设备独立性"><a href="#设备独立性" class="headerlink" title="设备独立性"></a>设备独立性</h4><p>I/O 软件设计一个很重要的目标就是<code>设备独立性(device independence)</code>。这意味着<strong>我们能够编写访问任何设备的应用程序，而不用事先指定特定的设备</strong>。</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830529-e4825574-4e1c-43fa-adf0-519f0ea1c7f7.png#align=left&display=inline&height=403&margin=%5Bobject%20Object%5D&originHeight=403&originWidth=500&size=0&status=done&style=none&width=500"></p><h4 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h4><p>除了<code>设备独立性</code>外，I/O 软件实现的第二个重要的目标就是<code>错误处理(error handling)</code>。通常情况下来说，错误应该交给<code>硬件</code>层面去处理。如果设备控制器发现了读错误的话，它会尽可能的去修复这个错误。如果设备控制器处理不了这个问题，那么设备驱动程序应该进行处理，设备驱动程序会再次尝试读取操作，很多错误都是偶然性的，如果设备驱动程序无法处理这个错误，才会把错误向上抛到硬件层面（上层）进行处理，很多时候，上层并不需要知道下层是如何解决错误的。</p><h4 id="同步和异步传输"><a href="#同步和异步传输" class="headerlink" title="同步和异步传输"></a>同步和异步传输</h4><p>I/O 软件实现的第三个目标就是 <code>同步(synchronous)</code> 和 <code>异步(asynchronous，即中断驱动)</code>传输。这里先说一下同步和异步是怎么回事吧。</p><p>同步传输中数据通常以块或帧的形式发送。发送方和接收方在数据传输之前应该具有<code>同步时钟</code>。而在异步传输中，数据通常以字节或者字符的形式发送，异步传输则不需要同步时钟，但是会在传输之前向数据添加<code>奇偶校验位</code>。大部分<code>物理IO(physical I/O)</code> 是异步的。物理 I/O 中的 CPU 是很聪明的，CPU 传输完成后会转而做其他事情，它和中断心灵相通，等到中断发生后，CPU 才会回到传输这件事情上来。</p><h4 id="缓冲"><a href="#缓冲" class="headerlink" title="缓冲"></a>缓冲</h4><p>I/O 软件的最后一个问题是<code>缓冲(buffering)</code>。通常情况下，从一个设备发出的数据不会直接到达最后的设备。其间会经过一系列的校验、检查、缓冲等操作才能到达。</p><h4 id="共享和独占"><a href="#共享和独占" class="headerlink" title="共享和独占"></a>共享和独占</h4><p>I/O 软件引起的最后一个问题就是共享设备和独占设备的问题。有些 I/O 设备能够被许多用户共同使用。一些设备比如磁盘，让多个用户使用一般不会产生什么问题，但是某些设备必须具有独占性，即只允许单个用户使用完成后才能让其他用户使用。</p><p>一共有三种控制 I/O 设备的方法</p><ul><li>使用程序控制 I/O</li><li>使用中断驱动 I/O</li><li>使用 DMA 驱动 I/O</li></ul><h2 id="I-O-层次结构"><a href="#I-O-层次结构" class="headerlink" title="I/O 层次结构"></a>I/O 层次结构</h2><p>I/O 软件通常组织成四个层次，它们的大致结构如下图所示</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830546-fa05a772-fc02-4957-ba1d-1e5a82d78de2.png#align=left&display=inline&height=372&margin=%5Bobject%20Object%5D&originHeight=372&originWidth=733&size=0&status=done&style=none&width=733"></p><p>下面我们具体的来探讨一下上面的层次结构</p><h3 id="中断处理程序"><a href="#中断处理程序" class="headerlink" title="中断处理程序"></a>中断处理程序</h3><p>在计算机系统中，中断就像女人的脾气一样无时无刻都在产生，中断的出现往往是让人很不爽的。中断处理程序又被称为<code>中断服务程序</code> 或者是 <code>ISR(Interrupt Service Routines)</code>，它是最靠近硬件的一层。中断处理程序由硬件中断、软件中断或者是软件异常启动产生的中断，用于实现设备驱动程序或受保护的操作模式（例如系统调用）之间的转换。</p><p>中断处理程序负责处理中断发生时的所有操作，操作完成后阻塞，然后启动中断驱动程序来解决阻塞。通常会有三种通知方式，依赖于不同的具体实现</p><ul><li>信号量实现中：在信号量上使用 <code>up</code> 进行通知；</li><li>管程实现：对管程中的条件变量执行 <code>signal</code> 操作</li><li>还有一些情况是发送一些消息</li></ul><h3 id="设备驱动程序"><a href="#设备驱动程序" class="headerlink" title="设备驱动程序"></a>设备驱动程序</h3><p>每个连接到计算机的 I/O 设备都需要有某些特定设备的代码对其进行控制。这些提供 I/O 设备到设备控制器转换的过程的代码称为 <code>设备驱动程序(Device driver)</code>。</p><p>设备控制器的主要功能有下面这些</p><ul><li>接收和识别命令：设备控制器可以接受来自 CPU 的指令，并进行识别。设备控制器内部也会有寄存器，用来存放指令和参数</li><li>进行数据交换：CPU、控制器和设备之间会进行数据的交换，CPU 通过总线把指令发送给控制器，或从控制器中并行地读出数据；控制器将数据写入指定设备。</li><li>地址识别：每个硬件设备都有自己的地址，设备控制器能够识别这些不同的地址，来达到控制硬件的目的，此外，为使 CPU 能向寄存器中写入或者读取数据，这些寄存器都应具有唯一的地址。</li><li>差错检测：设备控制器还具有对设备传递过来的数据进行检测的功能。</li></ul><p>在这种情况下，设备控制器会阻塞，直到中断来解除阻塞状态。还有一种情况是操作是可以无延迟的完成，所以驱动程序不需要阻塞。在第一种情况下，操作系统可能被中断唤醒；第二种情况下操作系统不会被休眠。</p><p>设备驱动程序必须是<code>可重入</code>的，因为设备驱动程序会阻塞和唤醒然后再次阻塞。驱动程序不允许进行系统调用，但是它们通常需要与内核的其余部分进行交互。</p><h3 id="与设备无关的-I-O-软件"><a href="#与设备无关的-I-O-软件" class="headerlink" title="与设备无关的 I/O 软件"></a>与设备无关的 I/O 软件</h3><p>I/O 软件有两种，一种是我们上面介绍过的基于特定设备的，还有一种是<code>设备无关性</code>的，设备无关性也就是不需要特定的设备。设备驱动程序与设备无关的软件之间的界限取决于具体的系统。下面显示的功能由设备无关的软件实现</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830586-059b4da8-ea81-4a5a-b884-3377ca39d976.png#align=left&display=inline&height=331&margin=%5Bobject%20Object%5D&originHeight=331&originWidth=428&size=0&status=done&style=none&width=428"></p><p>与设备无关的软件的基本功能是对所有设备执行公共的 I/O 功能，并且向用户层软件提供一个统一的接口。</p><h4 id="缓冲-1"><a href="#缓冲-1" class="headerlink" title="缓冲"></a>缓冲</h4><p>无论是对于块设备还是字符设备来说，缓冲都是一个非常重要的考量标准。缓冲技术应用广泛，但它也有缺点。如果数据被缓冲次数太多，会影响性能。</p><h4 id="错误处理-1"><a href="#错误处理-1" class="headerlink" title="错误处理"></a>错误处理</h4><p>在 I/O 中，出错是一种再正常不过的情况了。当出错发生时，操作系统必须尽可能处理这些错误。有一些错误是只有特定的设备才能处理，有一些是由框架进行处理，这些错误和特定的设备无关。</p><p>I/O 错误的一类是程序员<code>编程</code>错误，比如还没有打开文件前就读流，或者不关闭流导致内存溢出等等。这类问题由程序员处理；另外一类是实际的 I/O 错误，例如向一个磁盘坏块写入数据，无论怎么写都写入不了。这类问题由驱动程序处理，驱动程序处理不了交给硬件处理，这个我们上面也说过。</p><h4 id="设备驱动程序统一接口"><a href="#设备驱动程序统一接口" class="headerlink" title="设备驱动程序统一接口"></a>设备驱动程序统一接口</h4><p>我们在操作系统概述中说到，操作系统一个非常重要的功能就是屏蔽了硬件和软件的差异性，为硬件和软件提供了统一的标准，这个标准还体现在为设备驱动程序提供统一的接口，因为不同的硬件和厂商编写的设备驱动程序不同，所以如果为每个驱动程序都单独提供接口的话，这样没法搞，所以必须统一。</p><h4 id="分配和释放"><a href="#分配和释放" class="headerlink" title="分配和释放"></a>分配和释放</h4><p>一些设备例如打印机，它只能由一个进程来使用，这就需要操作系统根据实际情况判断是否能够对设备的请求进行检查，判断是否能够接受其他请求，一种比较简单直接的方式是在特殊文件上执行 <code>open</code>操作。如果设备不可用，那么直接 open 会导致失败。还有一种方式是不直接导致失败，而是让其阻塞，等到另外一个进程释放资源后，在进行 open 打开操作。这种方式就把选择权交给了用户，由用户判断是否应该等待。</p><h4 id="设备无关的块"><a href="#设备无关的块" class="headerlink" title="设备无关的块"></a>设备无关的块</h4><p>不同的磁盘会具有不同的扇区大小，但是软件不会关心扇区大小，只管存储就是了。一些字符设备可以一次一个字节的交付数据，而其他的设备则以较大的单位交付数据，这些差异也可以隐藏起来。</p><h3 id="用户空间的-I-O-软件"><a href="#用户空间的-I-O-软件" class="headerlink" title="用户空间的 I/O 软件"></a>用户空间的 I/O 软件</h3><p>虽然大部分 I/O 软件都在内核结构中，但是还有一些在用户空间实现的 I/O 软件，凡事没有绝对。一些 I/O 软件和库过程在用户空间存在，然后以提供系统调用的方式实现。</p><h2 id="盘"><a href="#盘" class="headerlink" title="盘"></a>盘</h2><p>盘可以说是硬件里面比较简单的构造了，同时也是最重要的。下面我们从盘谈起，聊聊它的物理构造</p><h3 id="盘硬件"><a href="#盘硬件" class="headerlink" title="盘硬件"></a>盘硬件</h3><p>盘会有很多种类型。其中最简单的构造就是<code>磁盘(magnetic hard disks)</code>， 也被称为 <code>hard disk,HDD</code>等。磁盘通常与安装在磁臂上的磁头配对，磁头可将数据读取或者将数据写入磁盘，因此磁盘的读写速度都同样快。在磁盘中，数据是随机访问的，这也就说明可以通过任意的顺序来<code>存储</code>和<code>检索</code>单个数据块，所以你可以在任意位置放置磁盘来让磁头读取，磁盘是一种<code>非易失性</code>的设备，即使断电也能永久保留。</p><h4 id="磁盘"><a href="#磁盘" class="headerlink" title="磁盘"></a>磁盘</h4><p>为了组织和检索数据，会将磁盘组织成特定的结构，这些特定的结构就是<strong>磁道、扇区和柱面</strong></p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830596-8b2a7f11-b5c9-4a00-b0c9-436889b099a8.png#align=left&display=inline&height=448&margin=%5Bobject%20Object%5D&originHeight=448&originWidth=498&size=0&status=done&style=none&width=498"></p><p>磁盘被组织成柱面形式，每个盘用轴相连，每一个柱面包含若干磁道，每个磁道由若干扇区组成。软盘上大约每个磁道有 8 - 32 个扇区，硬盘上每条磁道上扇区的数量可达几百个，磁头大约是 1 - 16 个。</p><p>对于磁盘驱动程序来说，一个非常重要的特性就是控制器是否能够同时控制两个或者多个驱动器进行磁道寻址，这就是<code>重叠寻道(overlapped seek)</code>。对于控制器来说，它能够控制一个磁盘驱动程序完成寻道操作，同时让其他驱动程序等待寻道结束。控制器也可以在一个驱动程序上进行读写草哦做，与此同时让另外的驱动器进行寻道操作，但是软盘控制器不能在两个驱动器上进行读写操作。</p><h4 id="RAID"><a href="#RAID" class="headerlink" title="RAID"></a>RAID</h4><p>RAID 称为 <code>磁盘冗余阵列</code>，简称 <code>磁盘阵列</code>。利用虚拟化技术把多个硬盘结合在一起，成为一个或多个磁盘阵列组，目的是提升性能或数据冗余。</p><p>RAID 有不同的级别</p><ul><li>RAID 0 - 无容错的条带化磁盘阵列</li><li>RAID 1 - 镜像和双工</li><li>RAID 2 - 内存式纠错码</li><li>RAID 3 - 比特交错奇偶校验</li><li>RAID 4 - 块交错奇偶校验</li><li>RAID 5 - 块交错分布式奇偶校验</li><li>RAID 6 - P + Q 冗余</li></ul><h4 id="磁盘格式化"><a href="#磁盘格式化" class="headerlink" title="磁盘格式化"></a>磁盘格式化</h4><p>磁盘由一堆铝的、合金或玻璃的盘片组成，磁盘刚被创建出来后，没有任何信息。磁盘在使用前必须经过<code>低级格式化(low-levvel format)</code>，下面是一个扇区的格式</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830611-1b106d56-fbdb-4e79-b2b5-e5bd2778a387.png#align=left&display=inline&height=86&margin=%5Bobject%20Object%5D&originHeight=86&originWidth=638&size=0&status=done&style=none&width=638"></p><p>前导码相当于是标示扇区的开始位置，通常以位模式开始，前导码还包括<code>柱面号</code>、<code>扇区号</code>等一些其他信息。紧随前导码后面的是数据区，数据部分的大小由低级格式化程序来确定。大部分磁盘使用 512 字节的扇区。数据区后面是 ECC，ECC 的全称是 <strong>error correction code</strong> ，<code>数据纠错码</code>，它与普通的错误检测不同，ECC 还可以用于恢复读错误。ECC 阶段的大小由不同的磁盘制造商实现。ECC 大小的设计标准取决于<strong>设计者愿意牺牲多少磁盘空间来提高可靠性</strong>，以及程序可以处理的 ECC 的复杂程度。通常情况下 ECC 是 16 位，除此之外，硬盘一般具有一定数量的备用扇区，用于替换制造缺陷的扇区。</p><h3 id="磁盘臂调度算法"><a href="#磁盘臂调度算法" class="headerlink" title="磁盘臂调度算法"></a>磁盘臂调度算法</h3><p>下面我们来探讨一下关于影响磁盘读写的算法，一般情况下，影响磁盘快读写的时间由下面几个因素决定</p><ul><li>寻道时间 - 寻道时间指的就是将磁盘臂移动到需要读取磁盘块上的时间</li><li>旋转延迟 - 等待合适的扇区旋转到磁头下所需的时间</li><li>实际数据的读取或者写入时间</li></ul><p>这三种时间参数也是磁盘寻道的过程。一般情况下，寻道时间对总时间的影响最大，所以，有效的降低寻道时间能够提高磁盘的读取速度。</p><p>如果磁盘驱动程序每次接收一个请求并按照接收顺序完成请求，这种处理方式也就是 <code>先来先服务(First-Come, First-served, FCFS)</code> ，这种方式很难优化寻道时间。因为每次都会按照顺序处理，不管顺序如何，有可能这次读完后需要等待一个磁盘旋转一周才能继续读取，而其他柱面能够马上进行读取，这种情况下每次请求也会排队。</p><p>通常情况下，磁盘在进行寻道时，其他进程会产生其他的磁盘请求。磁盘驱动程序会维护一张表，表中会记录着柱面号当作索引，每个柱面未完成的请求会形成链表，链表头存放在表的相应表项中。</p><p>一种对先来先服务的算法改良的方案是使用 <code>最短路径优先(SSF)</code> 算法，下面描述了这个算法。</p><p>假如我们在对磁道 6 号进行寻址时，同时发生了对 11 , 2 , 4, 14, 8, 15, 3 的请求，如果采用先来先服务的原则，如下图所示</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830646-2dfee703-9a35-47c9-880c-2c620d64464a.png#align=left&display=inline&height=427&margin=%5Bobject%20Object%5D&originHeight=427&originWidth=762&size=0&status=done&style=none&width=762"></p><p>我们可以计算一下磁盘臂所跨越的磁盘数量为 5 + 9 + 2 + 10 + 6 + 7 + 12 = 51，相当于是跨越了 51 次盘面，如果使用最短路径优先，我们来计算一下跨越的盘面</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830629-e3cda6d4-2317-438b-a377-9e5dc5a3a802.png#align=left&display=inline&height=381&margin=%5Bobject%20Object%5D&originHeight=381&originWidth=709&size=0&status=done&style=none&width=709"></p><p>跨越的磁盘数量为 4 + 1 + 1 + 4 + 3 + 3 + 1 = 17 ，相比 51 足足省了两倍的时间。</p><p>但是，最短路径优先的算法也不是完美无缺的，这种算法照样存在问题，那就是<code>优先级</code> 问题，</p><p>这里有一个原型可以参考就是我们日常生活中的电梯，电梯使用一种<code>电梯算法(elevator algorithm)</code> 来进行调度，从而满足协调效率和公平性这两个相互冲突的目标。电梯一般会保持向一个方向移动，直到在那个方向上没有请求为止，然后改变方向。</p><p>电梯算法需要维护一个<code>二进制位</code>，也就是当前的方向位：<code>UP(向上)</code>或者是 <code>DOWN(向下)</code>。当一个请求处理完成后，磁盘或电梯的驱动程序会检查该位，如果此位是 UP 位，磁盘臂或者电梯仓移到下一个更高跌未完成的请求。如果高位没有未完成的请求，则取相反方向。当方向位是 <code>DOWN</code> 时，同时存在一个低位的请求，磁盘臂会转向该点。如果不存在的话，那么它只是停止并等待。</p><p>我们举个例子来描述一下电梯算法，比如各个柱面得到服务的顺序是 4，7，10，14，9，6，3，1 ，那么它的流程图如下</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830648-6e8afe9c-f2fd-4c64-8db9-7f68930d0a27.png#align=left&display=inline&height=425&margin=%5Bobject%20Object%5D&originHeight=425&originWidth=710&size=0&status=done&style=none&width=710"></p><p>所以电梯算法需要跨越的盘面数量是 3 + 3 + 4 + 5 + 3 + 3 + 1 = 22</p><p>电梯算法通常情况下不如 SSF 算法。</p><h3 id="错误处理-2"><a href="#错误处理-2" class="headerlink" title="错误处理"></a>错误处理</h3><p>一般坏块有两种处理办法，一种是在控制器中进行处理；一种是在操作系统层面进行处理。</p><p>这两种方法经常替换使用，比如一个具有 30 个数据扇区和两个备用扇区的磁盘，其中扇区 4 是有瑕疵的。</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830690-4489f1b3-d4a8-49d6-bd29-1becb143d418.png#align=left&display=inline&height=367&margin=%5Bobject%20Object%5D&originHeight=367&originWidth=423&size=0&status=done&style=none&width=423"></p><p>控制器能做的事情就是将备用扇区之一重新映射。</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830735-2f51c8ae-a37f-4673-9781-a2519263c63f.png#align=left&display=inline&height=464&margin=%5Bobject%20Object%5D&originHeight=464&originWidth=500&size=0&status=done&style=none&width=500"></p><p>还有一种处理方式是将所有的扇区都向上移动一个扇区</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830717-1dc1be76-6eff-4891-8d89-843a7110e6a8.png#align=left&display=inline&height=460&margin=%5Bobject%20Object%5D&originHeight=460&originWidth=497&size=0&status=done&style=none&width=497"></p><p>上面这这两种情况下控制器都必须知道哪个扇区，可以通过内部的表来跟踪这一信息，或者通过重写前导码来给出重新映射的扇区号。如果是重写前导码，那么涉及移动的方式必须重写后面所有的前导码，但是最终会提供良好的性能。</p><h3 id="稳定存储器"><a href="#稳定存储器" class="headerlink" title="稳定存储器"></a>稳定存储器</h3><p>磁盘经常会出现错误，导致好的扇区会变成坏扇区，驱动程序也有可能挂掉。RAID 可以对扇区出错或者是驱动器崩溃提出保护，然而 RAID 却不能对坏数据中的写错误提供保护，也不能对写操作期间的崩溃提供保护，这样就会破坏原始数据。</p><p>我们期望磁盘能够准确无误的工作，但是事实情况是不可能的，但是我们能够知道的是，一个磁盘子系统具有如下特性：当一个写命令发给它时，磁盘要么正确地写数据，要么什么也不做，让现有的数据完整无误的保留。这样的系统称为 <code>稳定存储器(stable storage)</code>。 稳定存储器的目标就是不惜一切代价保证磁盘的一致性。</p><p>稳定存储器使用两个一对相同的磁盘，对应的块一同工作形成一个无差别的块。稳定存储器为了实现这个目的，定义了下面三种操作：</p><ul><li><code>稳定写(stable write)</code></li><li><code>稳定读(stable read)</code></li><li><code>崩溃恢复(crash recovery)</code></li></ul><h2 id="时钟"><a href="#时钟" class="headerlink" title="时钟"></a>时钟</h2><p><code>时钟(Clocks)</code> 也被称为<code>定时器(timers)</code>，时钟/定时器对任何程序系统来说都是必不可少的。时钟负责维护时间、防止一个进程长期占用 CPU 时间等其他功能。<code>时钟软件(clock software)</code> 也是一种设备驱动的方式。下面我们就来对时钟进行介绍，一般都是先讨论硬件再介绍软件，采用由下到上的方式，也是告诉你，底层是最重要的。</p><h3 id="时钟硬件"><a href="#时钟硬件" class="headerlink" title="时钟硬件"></a>时钟硬件</h3><p>在计算机中有两种类型的时钟，这些时钟与现实生活中使用的时钟完全不一样。</p><ul><li>比较简单的一种时钟被连接到 110 V 或 220 V 的电源线上，这样每个<code>电压周期</code>会产生一个中断，大概是 50 - 60 HZ。这些时钟过去一直占据支配地位。</li><li>另外的一种时钟由晶体振荡器、计数器和寄存器组成，示意图如下所示</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830741-6daaaf06-0552-44b1-bf19-85729fd25288.png#align=left&display=inline&height=503&margin=%5Bobject%20Object%5D&originHeight=503&originWidth=627&size=0&status=done&style=none&width=627"></p><p>这种时钟称为<code>可编程时钟</code> ，可编程时钟有两种模式，一种是 <code>一键式(one-shot mode)</code>，当时钟启动时，会把存储器中的值复制到计数器中，然后，每次晶体的振荡器的脉冲都会使计数器 -1。当计数器变为 0 时，会产生一个中断，并停止工作，直到软件再一次显示启动。还有一种模式时 <code>方波(square-wave mode)</code> 模式，在这种模式下，当计数器变为 0 并产生中断后，存储寄存器的值会自动复制到计数器中，这种周期性的中断称为一个时钟周期。</p><h3 id="时钟软件"><a href="#时钟软件" class="headerlink" title="时钟软件"></a>时钟软件</h3><p>时钟硬件所做的工作只是根据已知的时间间隔产生中断，而其他的工作都是由<code>时钟软件</code>来完成，一般操作系统的不同，时钟软件的具体实现也不同，但是一般都会包括以下这几点</p><ul><li>维护一天的时间</li><li>阻止进程运行的时间超过其指定时间</li><li>统计 CPU 的使用情况</li><li>处理用户进程的警告系统调用</li><li>为系统各个部分提供看门狗定时器</li><li>完成概要剖析，监视和信息收集</li></ul><h3 id="软定时器"><a href="#软定时器" class="headerlink" title="软定时器"></a>软定时器</h3><p>时钟软件也被称为可编程时钟，可以设置它以程序需要的任何速率引发中断。时钟软件触发的中断是一种硬中断，但是某些应用程序对于硬中断来说是不可接受的。</p><p>这时候就需要一种<code>软定时器(soft timer)</code> 避免了中断，无论何时当内核因为某种原因呢在运行时，它返回用户态之前都会检查时钟来了解软定时器是否到期。如果软定时器到期，则执行被调度的事件也无需切换到内核态，因为本身已经处于内核态中。这种方式避免了频繁的内核态和用户态之前的切换，提高了程序运行效率。</p><p>软定时器因为不同的原因切换进入内核态的速率不同，原因主要有</p><ul><li>系统调用</li><li>TLB 未命中</li><li>缺页异常</li><li>I/O 中断</li><li>CPU 变得空闲</li></ul><p>死锁问题也是操作系统非常重要的一类问题</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830748-305133ff-5324-4e46-b119-74609aedd401.png#align=left&display=inline&height=286&margin=%5Bobject%20Object%5D&originHeight=286&originWidth=721&size=0&status=done&style=none&width=721"></p><h2 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h2><p>大部分的死锁都和资源有关，在进程对设备、文件具有独占性（排他性）时会产生死锁。我们把这类需要排他性使用的对象称为<code>资源(resource)</code>。资源主要分为 <strong>可抢占资源和不可抢占资源</strong></p><h3 id="可抢占资源和不可抢占资源"><a href="#可抢占资源和不可抢占资源" class="headerlink" title="可抢占资源和不可抢占资源"></a>可抢占资源和不可抢占资源</h3><p>资源主要有可抢占资源和不可抢占资源。<code>可抢占资源(preemptable resource)</code> 可以从拥有它的进程中抢占而不会造成其他影响，内存就是一种可抢占性资源，任何进程都能够抢先获得内存的使用权。</p><p><code>不可抢占资源(nonpreemtable resource)</code> 指的是除非引起错误或者异常，否则进程无法抢占指定资源，这种不可抢占的资源比如有光盘，在进程执行调度的过程中，其他进程是不能得到该资源的。</p><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>如果要对死锁进行一个定义的话，下面的定义比较贴切</p><p><strong>如果一组进程中的每个进程都在等待一个事件，而这个事件只能由该组中的另一个进程触发，这种情况会导致死锁</strong>。</p><h3 id="资源死锁的条件"><a href="#资源死锁的条件" class="headerlink" title="资源死锁的条件"></a>资源死锁的条件</h3><p>针对我们上面的描述，资源死锁可能出现的情况主要有</p><ul><li>互斥条件：每个资源都被分配给了一个进程或者资源是可用的</li><li>保持和等待条件：已经获取资源的进程被认为能够获取新的资源</li><li>不可抢占条件：分配给一个进程的资源不能强制的从其他进程抢占资源，它只能由占有它的进程显示释放</li><li>循环等待：死锁发生时，系统中一定有两个或者两个以上的进程组成一个循环，循环中的每个进程都在等待下一个进程释放的资源。</li></ul><p>发生死锁时，上面的情况必须同时会发生。如果其中任意一个条件不会成立，死锁就不会发生。可以通过破坏其中任意一个条件来破坏死锁，下面这些破坏条件就是我们探讨的重点</p><h3 id="死锁模型"><a href="#死锁模型" class="headerlink" title="死锁模型"></a>死锁模型</h3><p>Holt 在 1972 年提出对死锁进行建模，建模的标准如下：</p><ul><li>圆形表示进程</li><li>方形表示资源</li></ul><p>从资源节点到进程节点表示资源已经被进程占用，如下图所示</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830760-e22f0a74-94ab-4be7-9b39-3f611c32823a.png#align=left&display=inline&height=352&margin=%5Bobject%20Object%5D&originHeight=352&originWidth=331&size=0&status=done&style=none&width=331"></p><p>在上图中表示当前资源 R 正在被 A 进程所占用</p><p>由进程节点到资源节点的有向图表示当前进程正在请求资源，并且该进程已经被阻塞，处于等待这个资源的状态</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830813-2b57251b-055b-4664-b040-89f60d1d43c4.png#align=left&display=inline&height=363&margin=%5Bobject%20Object%5D&originHeight=363&originWidth=345&size=0&status=done&style=none&width=345"></p><p>在上图中，表示的含义是进程 B 正在请求资源 S 。Holt 认为，死锁的描述应该如下</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830811-a3afe75e-0c48-40b9-8fa4-e74d132d9b58.png#align=left&display=inline&height=381&margin=%5Bobject%20Object%5D&originHeight=381&originWidth=485&size=0&status=done&style=none&width=485"></p><p>这是一个死锁的过程，进程 C 等待资源 T 的释放，资源 T 却已经被进程 D 占用，进程 D 等待请求占用资源 U ，资源 U 却已经被线程 C 占用，从而形成环。</p><p>有四种处理死锁的策略：</p><ul><li>忽略死锁带来的影响（惊呆了）</li><li>检测死锁并回复死锁，死锁发生时对其进行检测，一旦发生死锁后，采取行动解决问题</li><li>通过仔细分配资源来避免死锁</li><li>通过破坏死锁产生的四个条件之一来避免死锁</li></ul><p>下面我们分别介绍一下这四种方法</p><h2 id="鸵鸟算法"><a href="#鸵鸟算法" class="headerlink" title="鸵鸟算法"></a>鸵鸟算法</h2><p>最简单的解决办法就是使用<code>鸵鸟算法(ostrich algorithm)</code>，把头埋在沙子里，假装问题根本没有发生。每个人看待这个问题的反应都不同。数学家认为死锁是不可接受的，必须通过有效的策略来防止死锁的产生。工程师想要知道问题发生的频次，系统因为其他原因崩溃的次数和死锁带来的严重后果。如果死锁发生的频次很低，而经常会由于硬件故障、编译器错误等其他操作系统问题导致系统崩溃，那么大多数工程师不会修复死锁。</p><h2 id="死锁检测和恢复"><a href="#死锁检测和恢复" class="headerlink" title="死锁检测和恢复"></a>死锁检测和恢复</h2><p>第二种技术是死锁的检测和恢复。这种解决方式不会尝试去阻止死锁的出现。相反，这种解决方案会希望死锁尽可能的出现，在监测到死锁出现后，对其进行恢复。下面我们就来探讨一下死锁的检测和恢复的几种方式</p><h3 id="每种类型一个资源的死锁检测方式"><a href="#每种类型一个资源的死锁检测方式" class="headerlink" title="每种类型一个资源的死锁检测方式"></a>每种类型一个资源的死锁检测方式</h3><p>每种资源类型都有一个资源是什么意思？我们经常提到的打印机就是这样的，资源只有打印机，但是设备都不会超过一个。</p><p>可以通过构造一张资源分配表来检测这种错误，比如我们上面提到的</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830848-f4bc59e7-89e2-4e78-909c-e8dcd1718ebe.png#align=left&display=inline&height=381&margin=%5Bobject%20Object%5D&originHeight=381&originWidth=475&size=0&status=done&style=none&width=475"></p><p>如果这张图包含了一个或一个以上的环，那么死锁就存在，处于这个环中任意一个进程都是死锁的进程。</p><h3 id="每种类型多个资源的死锁检测方式"><a href="#每种类型多个资源的死锁检测方式" class="headerlink" title="每种类型多个资源的死锁检测方式"></a>每种类型多个资源的死锁检测方式</h3><p>如果有多种相同的资源存在，就需要采用另一种方法来检测死锁。可以通过构造一个矩阵来检测从 P1 -&gt; Pn 这 n 个进程中的死锁。</p><p>现在我们提供一种基于矩阵的算法来检测从 P1 到 Pn 这 n 个进程中的死锁。假设资源类型为 m，E1 代表资源类型 1，E2 表示资源类型 2 ，Ei 代表资源类型 i (1 &lt;= i &lt;= m)。E 表示的是 <code>现有资源向量(existing resource vector)</code>，代表每种已存在的资源总数。</p><p>现在我们就需要构造两个数组：C 表示的是<code>当前分配矩阵(current allocation matrix)</code> ，R 表示的是 <code>请求矩阵(request matrix)</code>。Ci 表示的是 Pi 持有每一种类型资源的资源数。所以，Cij 表示 Pi 持有资源 j 的数量。Rij 表示 Pi 所需要获得的资源 j 的数量</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830847-d4f0a077-7abd-4507-a720-337bc99b121e.png#align=left&display=inline&height=302&margin=%5Bobject%20Object%5D&originHeight=302&originWidth=686&size=0&status=done&style=none&width=686"></p><p>一般来说，已分配资源 j 的数量加起来再和所有可供使用的资源数相加 = 该类资源的总数。</p><p>死锁的检测就是基于向量的比较。每个进程起初都是没有被标记过的，算法会开始对进程做标记，进程被标记后说明进程被执行了，不会进入死锁，当算法结束时，任何没有被标记过的进程都会被判定为死锁进程。</p><p>上面我们探讨了两种检测死锁的方式，那么现在你知道怎么检测后，你何时去做死锁检测呢？一般来说，有两个考量标准：</p><ul><li>每当有资源请求时就去检测，这种方式会占用昂贵的 CPU 时间。</li><li>每隔 k 分钟检测一次，或者当 CPU 使用率降低到某个标准下去检测。考虑到 CPU 效率的原因，如果死锁进程达到一定数量，就没有多少进程可以运行，所以 CPU 会经常空闲。</li></ul><h3 id="从死锁中恢复"><a href="#从死锁中恢复" class="headerlink" title="从死锁中恢复"></a>从死锁中恢复</h3><p>上面我们探讨了如何检测进程死锁，我们最终的目的肯定是想让程序能够正常的运行下去，所以针对检测出来的死锁，我们要对其进行恢复，下面我们会探讨几种死锁的恢复方式</p><h4 id="通过抢占进行恢复"><a href="#通过抢占进行恢复" class="headerlink" title="通过抢占进行恢复"></a>通过抢占进行恢复</h4><p>在某些情况下，可能会临时将某个资源从它的持有者转移到另一个进程。比如在不通知原进程的情况下，将某个资源从进程中强制取走给其他进程使用，使用完后又送回。这种恢复方式一般比较困难而且有些简单粗暴，并不可取。</p><h4 id="通过回滚进行恢复"><a href="#通过回滚进行恢复" class="headerlink" title="通过回滚进行恢复"></a>通过回滚进行恢复</h4><p>如果系统设计者和机器操作员知道有可能发生死锁，那么就可以定期检查流程。进程的检测点意味着进程的状态可以被写入到文件以便后面进行恢复。检测点不仅包含<code>存储映像(memory image)</code>，还包含<code>资源状态(resource state)</code>。一种更有效的解决方式是不要覆盖原有的检测点，而是每出现一个检测点都要把它写入到文件中，这样当进程执行时，就会有一系列的检查点文件被累积起来。</p><p>为了进行恢复，要从上一个较早的检查点上开始，这样所需要资源的进程会回滚到上一个时间点，在这个时间点上，死锁进程还没有获取所需要的资源，可以在此时对其进行资源分配。</p><h4 id="杀死进程恢复"><a href="#杀死进程恢复" class="headerlink" title="杀死进程恢复"></a>杀死进程恢复</h4><p>最简单有效的解决方案是直接杀死一个死锁进程。但是杀死一个进程可能照样行不通，这时候就需要杀死别的资源进行恢复。</p><p>另外一种方式是选择一个环外的进程作为牺牲品来释放进程资源。</p><h2 id="死锁避免"><a href="#死锁避免" class="headerlink" title="死锁避免"></a>死锁避免</h2><p>我们上面讨论的是如何检测出现死锁和如何恢复死锁，下面我们探讨几种规避死锁的方式</p><h3 id="单个资源的银行家算法"><a href="#单个资源的银行家算法" class="headerlink" title="单个资源的银行家算法"></a>单个资源的银行家算法</h3><p>银行家算法是 Dijkstra 在 1965 年提出的一种调度算法，它本身是一种死锁的调度算法。它的模型是基于一个城镇中的银行家，银行家向城镇中的客户承诺了一定数量的贷款额度。算法要做的就是判断请求是否会进入一种不安全的状态。如果是，就拒绝请求，如果请求后系统是安全的，就接受该请求。</p><p>类似的，还有多个资源的银行家算法，读者可以自行了解。</p><h2 id="破坏死锁"><a href="#破坏死锁" class="headerlink" title="破坏死锁"></a>破坏死锁</h2><p>死锁本质上是无法避免的，因为它需要获得未知的资源和请求，但是死锁是满足四个条件后才出现的，它们分别是</p><ul><li>互斥</li><li>保持和等待</li><li>不可抢占</li><li>循环等待</li></ul><p>我们分别对这四个条件进行讨论，按理说破坏其中的任意一个条件就能够破坏死锁</p><h3 id="破坏互斥条件"><a href="#破坏互斥条件" class="headerlink" title="破坏互斥条件"></a>破坏互斥条件</h3><p>我们首先考虑的就是<strong>破坏互斥使用条件</strong>。如果资源不被一个进程独占，那么死锁肯定不会产生。如果两个打印机同时使用一个资源会造成混乱，打印机的解决方式是使用 <code>假脱机打印机(spooling printer)</code> ，这项技术可以允许多个进程同时产生输出，在这种模型中，实际请求打印机的唯一进程是打印机守护进程，也称为后台进程。后台进程不会请求其他资源。我们可以消除打印机的死锁。</p><p>后台进程通常被编写为能够输出完整的文件后才能打印，假如两个进程都占用了假脱机空间的一半，而这两个进程都没有完成全部的输出，就会导致死锁。</p><p>因此，尽量做到尽可能少的进程可以请求资源。</p><h3 id="破坏保持等待的条件"><a href="#破坏保持等待的条件" class="headerlink" title="破坏保持等待的条件"></a>破坏保持等待的条件</h3><p>第二种方式是如果我们能阻止持有资源的进程请求其他资源，我们就能够消除死锁。一种实现方式是让所有的进程开始执行前请求全部的资源。如果所需的资源可用，进程会完成资源的分配并运行到结束。如果有任何一个资源处于频繁分配的情况，那么没有分配到资源的进程就会等待。</p><p>很多进程<strong>无法在执行完成前就知道到底需要多少资源</strong>，如果知道的话，就可以使用银行家算法；还有一个问题是这样<strong>无法合理有效利用资源</strong>。</p><p>还有一种方式是进程在请求其他资源时，先释放所占用的资源，然后再尝试一次获取全部的资源。</p><h3 id="破坏不可抢占条件"><a href="#破坏不可抢占条件" class="headerlink" title="破坏不可抢占条件"></a>破坏不可抢占条件</h3><p>破坏不可抢占条件也是可以的。可以通过虚拟化的方式来避免这种情况。</p><h3 id="破坏循环等待条件"><a href="#破坏循环等待条件" class="headerlink" title="破坏循环等待条件"></a>破坏循环等待条件</h3><p>现在就剩最后一个条件了，循环等待条件可以通过多种方法来破坏。一种方式是制定一个标准，一个进程在任何时候只能使用一种资源。如果需要另外一种资源，必须释放当前资源。对于需要将大文件从磁带复制到打印机的过程，此限制是不可接受的。</p><p>另一种方式是将所有的资源统一编号，如下图所示</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830860-d72b0344-264f-4bfe-91f7-43d5b4121f58.png#align=left&display=inline&height=268&margin=%5Bobject%20Object%5D&originHeight=268&originWidth=419&size=0&status=done&style=none&width=419"></p><p>进程可以在任何时间提出请求，但是所有的请求都必须按照资源的顺序提出。如果按照此分配规则的话，那么资源分配之间不会出现环。</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830858-19d66189-e808-4999-879e-3e2e8d4273f0.png#align=left&display=inline&height=281&margin=%5Bobject%20Object%5D&originHeight=281&originWidth=423&size=0&status=done&style=none&width=423"></p><p>尽管通过这种方式来消除死锁，但是编号的顺序不可能让每个进程都会接受。</p><h2 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h2><p>下面我们来探讨一下其他问题，包括 <strong>通信死锁、活锁是什么、饥饿问题和两阶段加锁</strong></p><h3 id="两阶段加锁"><a href="#两阶段加锁" class="headerlink" title="两阶段加锁"></a>两阶段加锁</h3><p>虽然很多情况下死锁的避免和预防都能处理，但是效果并不好。随着时间的推移，提出了很多优秀的算法用来处理死锁。例如在数据库系统中，一个经常发生的操作是请求锁住一些记录，然后更新所有锁定的记录。当同时有多个进程运行时，就会有死锁的风险。</p><p>一种解决方式是使用 <code>两阶段提交(two-phase locking)</code>。顾名思义分为两个阶段，一阶段是进程尝试一次锁定它需要的所有记录。如果成功后，才会开始第二阶段，第二阶段是执行更新并释放锁。第一阶段并不做真正有意义的工作。</p><p>如果在第一阶段某个进程所需要的记录已经被加锁，那么该进程会释放所有锁定的记录并重新开始第一阶段。从某种意义上来说，这种方法类似于预先请求所有必需的资源或者是在进行一些不可逆的操作之前请求所有的资源。</p><p>不过在一般的应用场景中，两阶段加锁的策略并不通用。如果一个进程缺少资源就会半途中断并重新开始的方式是不可接受的。</p><h3 id="通信死锁"><a href="#通信死锁" class="headerlink" title="通信死锁"></a>通信死锁</h3><p>我们上面一直讨论的是资源死锁，资源死锁是一种死锁类型，但并不是唯一类型，还有通信死锁，也就是两个或多个进程在发送消息时出现的死锁。进程 A 给进程 B 发了一条消息，然后进程 A 阻塞直到进程 B 返回响应。假设请求消息丢失了，那么进程 A 在一直等着回复，进程 B 也会阻塞等待请求消息到来，这时候就产生<code>死锁</code>。</p><p>尽管会产生死锁，但是这并不是一个资源死锁，因为 A 并没有占据 B 的资源。事实上，通信死锁并没有完全可见的资源。根据死锁的定义来说：每个进程因为等待其他进程引起的事件而产生阻塞，这就是一种死锁。相较于最常见的通信死锁，我们把上面这种情况称为<code>通信死锁(communication deadlock)</code>。</p><p>通信死锁不能通过调度的方式来避免，但是可以使用通信中一个非常重要的概念来避免：<code>超时(timeout)</code>。在通信过程中，只要一个信息被发出后，发送者就会启动一个定时器，定时器会记录消息的超时时间，如果超时时间到了但是消息还没有返回，就会认为消息已经丢失并重新发送，通过这种方式，可以避免通信死锁。</p><p>但是并非所有网络通信发生的死锁都是通信死锁，也存在资源死锁，下面就是一个典型的资源死锁。</p><p>当一个数据包从主机进入路由器时，会被放入一个缓冲区，然后再传输到另外一个路由器，再到另一个，以此类推直到目的地。缓冲区都是资源并且数量有限。如下图所示，每个路由器都有 10 个缓冲区（实际上有很多）。</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830887-98d92f9c-72d1-4710-a487-1bd4dc953b7c.png#align=left&display=inline&height=322&margin=%5Bobject%20Object%5D&originHeight=322&originWidth=702&size=0&status=done&style=none&width=702"></p><p>假如路由器 A 的所有数据需要发送到 B ，B 的所有数据包需要发送到 D，然后 D 的所有数据包需要发送到 A 。没有数据包可以移动，因为在另一端没有缓冲区可用，这就是一个典型的资源死锁。</p><h3 id="活锁"><a href="#活锁" class="headerlink" title="活锁"></a>活锁</h3><p>某些情况下，当进程意识到它不能获取所需要的下一个锁时，就会尝试礼貌的释放已经获得的锁，然后等待非常短的时间再次尝试获取。可以想像一下这个场景：当两个人在狭路相逢的时候，都想给对方让路，相同的步调会导致双方都无法前进。</p><p>现在假想有一对并行的进程用到了两个资源。它们分别尝试获取另一个锁失败后，两个进程都会释放自己持有的锁，再次进行尝试，这个过程会一直进行重复。很明显，这个过程中没有进程阻塞，但是进程仍然不会向下执行，这种状况我们称之为 <code>活锁(livelock)</code>。</p><h3 id="饥饿"><a href="#饥饿" class="headerlink" title="饥饿"></a>饥饿</h3><p>与死锁和活锁的一个非常相似的问题是 <code>饥饿(starvvation)</code>。想象一下你什么时候会饿？一段时间不吃东西是不是会饿？对于进程来讲，最重要的就是资源，如果一段时间没有获得资源，那么进程会产生饥饿，这些进程会永远得不到服务。</p><p>我们假设打印机的分配方案是每次都会分配给最小文件的进程，那么要打印大文件的进程会永远得不到服务，导致进程饥饿，进程会无限制的推后，虽然它没有阻塞。</p>]]></content>
      
      
      <categories>
          
          <category> ComputerOperatingSystem </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Git使用Token连接</title>
      <link href="blog/lg6q7n/"/>
      <url>blog/lg6q7n/</url>
      
        <content type="html"><![CDATA[<h2 id="一、应用"><a href="#一、应用" class="headerlink" title="一、应用"></a>一、应用</h2><p>多个终端使用，而且没必要配置 SSH 连接的情况，可以使用 GitHub Token 来连接使用。还有就是使用 GitHub Actions 时候用 Token 情况较 SSH 方便。</p><p>不同的托管平台使用语法会有差异，在此记录下 GitHub、Coding、Gitee 的使用</p><h2 id="二、GitHub"><a href="#二、GitHub" class="headerlink" title="二、GitHub"></a>二、GitHub</h2><p>GitHub 生成一个 Token：***</p><p>使用 SSH 情况：<code>git clone [https://github.com/wztlink1013/blog3.0.git](https://github.com/wztlink1013/blog3.0.git)</code></p><p>使用 Token 情况：<code>[https://x-access-token:**************@github.com/wztlink1013/blog3.0.git](https://x-access-token:**************@github.com/wztlink1013/blog3.0.git)</code></p><h2 id="三、Coding"><a href="#三、Coding" class="headerlink" title="三、Coding"></a>三、Coding</h2><p>在个人设置中设置一个访问令牌</p><ul><li>令牌用户名：####</li><li>令牌 Token：*</li></ul><p>使用 SSH 情况：<code>[https://e.coding.net/wztlink1013/project/repo.git](https://e.coding.net/wztlink1013/project/repo.git)</code><br>使用令牌情况：<code>[https://####:***********@e.coding.net/wztlink1013/project/repo.git](https://####:***********@e.coding.net/wztlink1013/project/repo.git)</code></p><h2 id="四、Gitee"><a href="#四、Gitee" class="headerlink" title="四、Gitee"></a>四、Gitee</h2><p>头像设置中申请私人令牌：**</p><p>使用 SSH 情况：<code>[https://gitee.com/user/repo.git](https://gitee.com/user/repo.git)</code></p><p>使用 Token 情况：<code>[https://oauth2:**********@gitee.com/user/repo.git](https://oauth2:**********@gitee.com/user/repo.git)</code></p><h2 id="五、GitHub-Actions-中的使用"><a href="#五、GitHub-Actions-中的使用" class="headerlink" title="五、GitHub Actions 中的使用"></a>五、GitHub Actions 中的使用</h2><pre><code class="bash">Github_Pages:  github.com/wztlink1013/wztlink1013.github.ioGithub_Token:  $&#123;&#123;  secrets.token_GithubAPI  &#125;&#125;git  push  --force  --quiet  &quot;https://$&#123;Github_Token&#125;@$&#123;Github_Pages&#125;&quot;</code></pre><pre><code class="bash">Coding_Pages:  e.coding.net/wztlink1013/wztlink1013.gitCoding_Token:  $&#123;&#123;  secrets.token_CodingAPI  &#125;&#125;Coding_Username:  $&#123;&#123;  secrets.Username_Coding  &#125;&#125;git  push  --force  --quiet  &quot;https://$&#123;Coding_Username&#125;:$&#123;Coding_Token&#125;@$&#123;Coding_Pages&#125;&quot;</code></pre>]]></content>
      
      
      <categories>
          
          <category> VersionControlSystem </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>GitHub Actions使用之不同仓库文件夹迁移</title>
      <link href="blog/qp5kuu/"/>
      <url>blog/qp5kuu/</url>
      
        <content type="html"><![CDATA[<div style="background: #FFF3F3;padding:10px;border: 1px solid #DEB8BE;border-radius:5px;margin-bottom:5px;">弃用：繁琐<br>新思路：走CDN回源</div>​<h2 id="一、思路"><a href="#一、思路" class="headerlink" title="一、思路"></a>一、思路</h2><ul><li>仓库一：wztlink1013.github.io【master】</li><li>仓库二：test【gh-pages】</li></ul><p><del>将 test 仓库下 gh-pages 分支下的所有文件复制到文件夹 test，在 wztlink1013.github.io 仓库下 clone 到文件夹 wztlink1013.github.io 中，进入 wztlink1013.github.io 文件夹，然后通过命令将 test 文件夹复制到 wztlink1013 文件夹中，最后 push 到 wztlink1013.github.io 仓库中。</del></p><h2 id="二、编写脚本"><a href="#二、编写脚本" class="headerlink" title="二、编写脚本"></a>二、编写脚本</h2><pre><code class="bash">git config --global user.name &#39;wztlink1013&#39;git config --global user.email &#39;2550374815@qq.com&#39;git clone https://github.com/wztlink1013/test.gitgit clone https://github.com/wztlink1013/wztlink1013.github.io.git</code></pre><pre><code class="shell">cd wztlink1013.github.iomkdir testcd ..xcopy .\test .\wztlink1013.github.io /e</code></pre><pre><code class="bash">cd wztlink1013.github.iogit statusgit add .git commit -m &quot;add gh-pages files&quot;git push &quot;https://$&#123;Github_Token&#125;@github.com/wztlink1013/wztlink1013.github.io&quot;  master:master</code></pre><h2 id="三、编写-GitHub-Actions"><a href="#三、编写-GitHub-Actions" class="headerlink" title="三、编写 GitHub Actions"></a>三、编写 GitHub Actions</h2><pre><code class="yaml">name: CI for wztlink1013.github.ioon: [push, watch]jobs:  build:    runs-on: ubuntu-latest    steps:      - uses: actions/checkout@v2      - name: 配置Git        run: |          git config --global user.name &#39;wztlink1013&#39;           git config --global user.email &#39;email@qq.com&#39;      - name: 在云端进行复制文件夹操作        env:          Github_Token: $&#123;&#123; secrets.TOKEN_GITHUBAPI &#125;&#125;        run: |          git clone https://github.com/wztlink1013/visualization visualization          git clone https://github.com/wztlink1013/wztlink1013.github.io .github_pages          cd visualization          rm -r .git          rm -r .github          cd ..          cd .github_pages          rm -r visualization          cd ..          mv visualization/ -f .github_pages/          cd .github_pages          git status          git add .          git commit -m &quot;add gh-pages files&quot;          git push --force --quiet &quot;https://$&#123;Github_Token&#125;@github.com/wztlink1013/wztlink1013.github.io&quot;  master:master</code></pre>]]></content>
      
      
      <categories>
          
          <category> VersionControlSystem </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>重装系统</title>
      <link href="blog/qq1dno/"/>
      <url>blog/qq1dno/</url>
      
        <content type="html"><![CDATA[<h2 id="一、关于重装"><a href="#一、关于重装" class="headerlink" title="一、关于重装"></a>一、关于重装</h2><h3 id="重装缘由"><a href="#重装缘由" class="headerlink" title="重装缘由"></a>重装缘由</h3><ul><li>电脑的空间太杂乱</li><li>环境配置混乱</li><li>网卡驱动出错<blockquote><p>总结几次重装步骤，为了今后出现类似情况，能够更快地重装电脑。</p></blockquote></li></ul><h3 id="重装好处"><a href="#重装好处" class="headerlink" title="重装好处"></a>重装好处</h3><p>电脑重装系统能解决大多数问题（对鄙人能解决 100%问题<del>//手动滑稽</del>），在此总结一下自己重装系统过程步骤以及遇到的问题。算了，我还是实实在在的滑稽一波吧~~~~​~~<br><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1623852232741-fd7fae39-8fd9-4aa3-83a9-afcc140cb856.jpeg#id=JlIiw&originHeight=58&originWidth=79&originalType=binary%E2%88%B6=1&status=done&style=none"></p><h2 id="二、重装系统-SOP"><a href="#二、重装系统-SOP" class="headerlink" title="二、重装系统 SOP"></a>二、重装系统 SOP</h2><h3 id="1-制作启动盘"><a href="#1-制作启动盘" class="headerlink" title="1. 制作启动盘"></a>1. 制作启动盘</h3><ul><li><a href="https://msdn.itellyou.cn/">法一：MSDN 下载</a><br>① 迅雷下载  ② 网盘下载</li></ul><p>下载完镜像之后，再用 ULtralSO/ <a href="https://rufus.ie/zh_CN.html">rufus</a> 软件刻录在 U 盘（大于 4G 的 U 盘）</p><ul><li><p><a href="https://www.microsoft.com/zh-cn/software-download/windows10">法二：微软官方下载</a><br>网速不能太慢，WiFi 较快的可以用这个，不过下载的电脑原装 Windows 版本，不追求专业版本的 Windows，最好还是下这个吧。</p><blockquote><p>坑 1：如果下载的镜像大于 4G 左右，ULtralSO 不能刻录。<br>亮 2：官方下载，可以匹配自己电脑本来的版本；可以直接刻录在 U 盘，唯一不足应该就是网速问题。<br>坑 3：U 盘如果“身患重伤”，下个相关优化 U 盘软件处理一下</p></blockquote></li><li><p>（更新）<a href="http://www.kqidong.com/index.html">法三：快启动</a>先用法一下好镜像。</p></li></ul><h3 id="2-正式重装"><a href="#2-正式重装" class="headerlink" title="2. 正式重装"></a>2. 正式重装</h3><ul><li>进入 bios 界面<br>开机刚要出现<code>HP</code>字样，一直点<code>_esc_</code>键，然后再设置开机进入启动盘</li><li>Next Wait 即可<br>格式化 C 盘 → 安装 → 等候 → 登录微软账号…</li></ul><h3 id="3-磁盘管理"><a href="#3-磁盘管理" class="headerlink" title="3. 磁盘管理"></a>3. 磁盘管理</h3><p><strong>磁盘管理器：根据需求将磁盘分区</strong><br><strong>​</strong></p><ul><li>相关问题 1：给 C 盘扩展时不能扩展？<blockquote><p>磁盘只有相邻卷才能扩展卷：解决办法就是把右边的磁盘删除（状态为未分配空间），然后用左边的磁盘合并之（使用扩展卷）</p></blockquote></li></ul><h3 id="4-关于破解"><a href="#4-关于破解" class="headerlink" title="4. 关于破解"></a>4. 关于破解</h3><ul><li>有条件购买支持正版，支持同行</li><li>下载自己笔记本出厂 Windows 版本，则不需要激活码，自带</li><li>最后破解之：<code>hwid.kms38.gen.mk6</code>软件</li></ul><h2 id="三、电脑备份相关工作"><a href="#三、电脑备份相关工作" class="headerlink" title="三、电脑备份相关工作"></a>三、电脑备份相关工作</h2><h3 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h3><ul><li><input disabled="" type="checkbox"> <del>谷歌浏览器</del></li><li><input checked="" disabled="" type="checkbox"> Edge(最新)浏览器：<a href="https://www.microsoftedgeinsider.com/en-us/download">下载地址（DEV 版本会消去插件开发者禁用状态）</a></li><li><input checked="" disabled="" type="checkbox"> <del>谷歌访问助手插件 让谷歌先连上网 然后构建 SSR/</del> <a href="https://bywave.io/clientarea.php"><strong>ByWave</strong></a></li><li><input checked="" disabled="" type="checkbox"> 登录账号同步书签插件等设置（<del>谷歌需要 fq，</del>Edge 不需要）</li><li><input disabled="" type="checkbox"> <del>下载</del><a href="http://www.carrotchou.blog/59.html"><del>IDM 下载器</del></a></li></ul><h3 id="开发环境的搭建"><a href="#开发环境的搭建" class="headerlink" title="开发环境的搭建"></a>开发环境的搭建</h3><ul><li><input checked="" disabled="" type="checkbox"> Git（全局用户）：<a href="https://www.wztlink1013.com/blog/fnsge3/">Git 常见使用+多账号同设备部署总结 | 尼采般地抒情</a></li><li><input checked="" disabled="" type="checkbox"> Nodejs：<a href="https://www.wztlink1013.com/blog/yo1xhz/">Hexo+GitHub Pages 搭建个人静态网站 | 尼采般地抒情</a></li><li><input checked="" disabled="" type="checkbox"> Java（jdkjdk1.8.0_181，jrejdk1.8.0_181）：<a href="https://www.wztlink1013.com/blog/cwqx6l/">配置 java 开发环境 | 尼采般地抒情</a></li><li><input disabled="" type="checkbox"> MySQL</li><li><input disabled="" type="checkbox"> Unix：VMware15，Windows 子系统（开发三剑客）</li></ul><h3 id="文件备份及恢复"><a href="#文件备份及恢复" class="headerlink" title="文件备份及恢复"></a>文件备份及恢复</h3><ul><li><input checked="" disabled="" type="checkbox"> <strong>百度网盘</strong>常用文件夹备份（图片文件夹+个人信息文件夹）</li><li><input checked="" disabled="" type="checkbox"> <strong>GitHub</strong>同步开发项目代码</li></ul><h3 id="通用软件"><a href="#通用软件" class="headerlink" title="通用软件"></a>通用软件</h3><ul><li><input checked="" disabled="" type="checkbox"> 百度网盘，<del>Dropbox，迅雷</del></li><li><input checked="" disabled="" type="checkbox"> Bandizip</li><li><input checked="" disabled="" type="checkbox"> PDF：Adobe Acrobat DC <del>/福昕阅读器</del></li><li><input checked="" disabled="" type="checkbox"> Potplayer 播放器</li><li><input disabled="" type="checkbox"> <del>有道翻译</del></li><li><input disabled="" type="checkbox"> Office2019（或者直接重装最新版 Win10 操作系统） <del>(已经集成 Onenote2016)，再另外下载 onenote 插件</del></li></ul><h3 id="社交软件"><a href="#社交软件" class="headerlink" title="社交软件"></a>社交软件</h3><ul><li><input checked="" disabled="" type="checkbox"> QQ、微信、网易邮箱大师、网易云、酷狗</li><li><input disabled="" type="checkbox"> <del>Telegram</del></li></ul><h3 id="开发工具"><a href="#开发工具" class="headerlink" title="开发工具"></a>开发工具</h3><ul><li><input checked="" disabled="" type="checkbox"> Web：<a href="https://code.visualstudio.com/download">vscode</a></li><li><input checked="" disabled="" type="checkbox"> C&amp;C++：<a href="https://www.wztlink1013.com/blog/pm7mpk/">VScode（搭配 C/C++开发插件使用）</a><del>、Clion、Codeblocks(次选)、VS2019(PC 空间大则优选)、VS2013</del></li><li><input disabled="" type="checkbox"> Python：Anaconda、Pycharm(<del>配置 nltk、tensorflow 等</del>)(<del>关于破解或</del> <strong>学生用户登录</strong>)</li><li><input disabled="" type="checkbox"> Java/JavaWeb：jdk、IDEA/Eclipse(配置 Tomcat)</li><li><input disabled="" type="checkbox"> DataBase：<a href="https://www.microsoft.com/zh-cn/download/confirmation.aspx?id=30438">SQL Server 2008</a> 和 <a href="https://zhuanlan.zhihu.com/p/65630194">安装教程</a> 、 Navicat Premium 12（MySQL）</li><li><input disabled="" type="checkbox"> Android：Android Studio、HBuilder X、微信开发者工具</li><li><input disabled="" type="checkbox"> OS：CPU Simulator</li><li><input disabled="" type="checkbox"> Matlab</li><li><input disabled="" type="checkbox"> 研究-CAJViewer 7.3</li><li><input disabled="" type="checkbox"> 研究-AxMath</li><li><input disabled="" type="checkbox"> 研究-AxGlyph</li><li><input disabled="" type="checkbox"> 服务器：</li></ul><h3 id="后期制作"><a href="#后期制作" class="headerlink" title="后期制作"></a>后期制作</h3><ul><li><input checked="" disabled="" type="checkbox"> Ps</li><li><input disabled="" type="checkbox"> Pr、Ae</li><li><input disabled="" type="checkbox"> <del>An、Au、EV 录频、Format factory 格式转换工厂</del></li></ul><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul><li><input checked="" disabled="" type="checkbox"> <a href="https://www.yuque.com/install/desktop">语雀桌面客户端</a></li><li><input checked="" disabled="" type="checkbox"> <a href="https://authy.com/download/">Authy Desktop（二重验证）</a></li><li><input checked="" disabled="" type="checkbox"> Snipaste-2.3-64 位（网盘）</li><li><input disabled="" type="checkbox"> 阿里云的 oss-browser</li><li><input disabled="" type="checkbox"> HexoClient</li><li><input disabled="" type="checkbox"> 火萤桌面视频</li><li><input disabled="" type="checkbox"> Rainmeter</li><li><input disabled="" type="checkbox"> <a href="https://github.com/Molunerfinn/PicGo">PicGo</a> （全局代理下载）</li><li><input disabled="" type="checkbox"> steam</li><li><input disabled="" type="checkbox"> qq 飞车</li></ul>]]></content>
      
      
      <categories>
          
          <category> Environment </category>
          
          <category> 环境配置 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>编程习惯</title>
      <link href="blog/ml46ei/"/>
      <url>blog/ml46ei/</url>
      
        <content type="html"><![CDATA[<h2 id="一、代码"><a href="#一、代码" class="headerlink" title="一、代码"></a>一、代码</h2><h3 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h3><ul><li>项目：小写字母 <code>datastructure</code></li><li>包：<code>com.公司名.项目名.模块名....</code>（其中模块名可以按照功能/逻辑来分）</li><li>类：全部首字母大写，一般驼峰式命名 <code>public class TestBan&#123;&#125;</code></li><li>常量：全部大写字母 <code>String RE_PRI = ‘wztlink’</code></li><li>变量：下划线方式  <code>int pri_const</code></li><li>方法：首字母小写，如果有多个单词，单词首字母大写 <code>public void toString()&#123;&#125;</code></li></ul><h3 id="注释规范"><a href="#注释规范" class="headerlink" title="注释规范"></a>注释规范</h3><div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">文件注释</div><pre><code class="java">  / *    * 文件名：[文件名]    * 作者：〈版权〉    * 描述：〈描述〉    * 修改人：Wu ZuTao    * 修改时间：2020-06-06    * 修改内容：新增X方法    * 修改人：Wu ZuTao    * 修改时间：2020-07-01    * 修改内容：修改B模块    * /</code></pre><div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">类和接口的注释：该注释放在class定义之前，using或package关键字之后。</div><pre><code class="java">package com.wztlink.xxx;/**  * 注释内容  */public class XxxManager</code></pre><pre><code class="java">/ *  * 〈一句话功能简述〉  * 〈功能详细描述〉  * @author [作者]  * @version [版本号, YYYY-MM-DD]  * @see [相关类/方法]  * @since [产品/模块版本]  * @deprecated  */</code></pre><div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">函数注释</div><pre><code class="java"> /**    * 类方法的详细使用说明    *    * @param 参数1 参数1的使用说明    * @return 返回结果的说明    * @throws 异常类型.错误代码 注明从此类方法中抛出异常的说明    */</code></pre><div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">方法内部、属性、必要语句</div><pre><code class="java">// 注释内容private String logType</code></pre><div style="background: #FFF3F3;padding:10px;border: 1px solid #DEB8BE;border-radius:5px;margin-bottom:5px;">注意事项</div><ul><li>边写代码边注释，修改代码同时修改相应的注释，以保证注释与代码的一致性。不再有用的注释要删除。</li><li>避免在注释中使用缩写，特别是不常用缩写。说明：在使用缩写时或之前，应对缩写进行必要的说明。 注释应该放在被注释的代码前面，分行展示，但中间不留空行。</li><li><a href="https://blog.csdn.net/vbirdbest/article/details/80296136">javadoc 使用规范</a></li></ul><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>主入口函数和其他功能函数分开，如果是功能性函数，全部放到一个 <code>Tools</code>  函数里面</p><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><p>不要在自己类下定义自己的对象</p><h2 id="二、项目"><a href="#二、项目" class="headerlink" title="二、项目"></a>二、项目</h2><h3 id="解决写不出代码的方法"><a href="#解决写不出代码的方法" class="headerlink" title="解决写不出代码的方法"></a>解决写不出代码的方法</h3><blockquote><p>参考：<a href="https://www.cnblogs.com/luchuangao/p/6821210.html">https://www.cnblogs.com/luchuangao/p/6821210.html</a></p></blockquote><blockquote><p>1、先分析实现的思路</p></blockquote><p>拿到作业，按照要实现的功能，先分析去实现的思路。<br>如果完全不知道该怎么去实现，一头雾水，最好先看看其他人事如何实现的，或者与老师或同学讨论。<br>重点是要找到解决问题的办法，理清实现的思路。<br>如果自己能想出几步来，那就先把这几步记录下来，然后重复上面的步骤。</p><blockquote><p>2、把实现的思路边分析边记录下来。</p></blockquote><p>在分析实现思路的时候，边分析，边写出来，使用中文写，写得详细点。<br>如果在编程工具里面写的话，直接写成注释，比如：<br>第一步是要干上面<br>第 1.1 要做什么<br>第 1.2 要做什么<br>第二步是要干上面<br>第 2.1 要做什么<br>第 2.2 要做什么<br>…以此类推<br>遇到写不下去的地方，先看看是没有思路还是前面的思路没有想清楚<br>如果是没有思路了，参见第一条处理。<br>如果是前面的思路没有想清楚，那就返回来重新思考，一定要考虑明白。<br>这其实也是这个方法一个额外的好处，那就是能强迫你思考，并进行细致考虑。</p><blockquote><p>3、写实现代码</p></blockquote><p>如果思路整理清楚了，实现思路的步骤也整理好了，这个时候再写代码，<br>几乎就是个翻译的过程，很容易实现。<br>如果只是几步思路清楚了，也没有关系，想清楚多少，就写多少代码，慢慢来。</p><blockquote><p>4、有思路但是写不出代码的解决方法</p></blockquote><p>这种情况常出现在初学者身上，主要是代码写少了。（这种情况需每日练习两百到三百行代码）<br>建议多看看别人怎么写的，积累代码的写法，这一次不会写不要紧。<br>见过一回，下次会写九可以了，积少成多，写得多了，自己能实现的也就多了。</p><blockquote><p>5、方法不一定照搬，可以变通使用</p></blockquote><p>比如边分析、边写思路然后就编写代码也是可以的，只要能有助你思考，都可以。</p><blockquote><p>6、写不出代码</p></blockquote><p>大多数人在写不出代码的时候，都不是完全写不出来，也不是一点都写不出来，请尽量把会的、能写出来的先写出来，多按照本文介绍的方法去练习，量变到质变，很快就能自己写出实现代码来。</p><h3 id="提高代码阅读能力"><a href="#提高代码阅读能力" class="headerlink" title="提高代码阅读能力"></a>提高代码阅读能力</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1602593438617-6e64c23d-0230-4104-b1b5-6ccd512ad999.png#height=100&id=R0FDZ&margin=%5Bobject%20Object%5D&name=image.png&originHeight=199&originWidth=1017&originalType=binary%E2%88%B6=1&size=53543&status=done&style=shadow&width=508.5" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1602593456351-275ca8e5-583b-499b-aca4-e4295b312c55.png#height=157&id=T4RUm&margin=%5Bobject%20Object%5D&name=image.png&originHeight=313&originWidth=1008&originalType=binary%E2%88%B6=1&size=102518&status=done&style=shadow&width=504" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1602593476552-c6a6f01f-1d45-40e7-93b5-be56bc08e0c7.png#height=170&id=GkcIC&margin=%5Bobject%20Object%5D&name=image.png&originHeight=339&originWidth=1010&originalType=binary%E2%88%B6=1&size=98037&status=done&style=shadow&width=505" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1602593492992-c4a224fc-10e7-478e-9424-c90da2b4805a.png#height=88&id=IOPvY&margin=%5Bobject%20Object%5D&name=image.png&originHeight=176&originWidth=996&originalType=binary%E2%88%B6=1&size=51461&status=done&style=shadow&width=498" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1602593510079-399972ba-bee4-4dbc-81c9-ae619486f7da.png#height=202&id=NibYg&margin=%5Bobject%20Object%5D&name=image.png&originHeight=403&originWidth=996&originalType=binary%E2%88%B6=1&size=126977&status=done&style=shadow&width=498" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1602593528314-e583f78d-6f87-46d1-826d-841629871530.png#height=163&id=rKWh8&margin=%5Bobject%20Object%5D&name=image.png&originHeight=325&originWidth=1013&originalType=binary%E2%88%B6=1&size=96139&status=done&style=shadow&width=506.5" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1602593547023-cbcc3eac-6350-4b92-856d-0cfd2a1ccf75.png#height=98&id=z7WrI&margin=%5Bobject%20Object%5D&name=image.png&originHeight=196&originWidth=1011&originalType=binary%E2%88%B6=1&size=52272&status=done&style=shadow&width=505.5" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> SoftwareEngineering </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>调试解决总结</title>
      <link href="blog/mtigbx/"/>
      <url>blog/mtigbx/</url>
      
        <content type="html"><![CDATA[<h2 id="一、关于-bug"><a href="#一、关于-bug" class="headerlink" title="一、关于 bug"></a>一、关于 bug</h2><p>在编写程序过程中，总会出现各种各样的 bug，按 bug 得类型来分的话</p><ul><li>程序的逻辑出错</li><li>程序语法出错编译器不能通过</li></ul><p>对待 bug，心态端正，不抵触不畏惧不怕麻烦，要想着解 bug 就是这个职业的要务之一，有耐心，积极主动的去解决问题。一步一步的解决问题，所有的技术都是熟能生巧、</p><h2 id="二、解决-bug-的一些方法"><a href="#二、解决-bug-的一些方法" class="headerlink" title="二、解决 bug 的一些方法"></a>二、解决 bug 的一些方法</h2><h3 id="报错信息-理论知识"><a href="#报错信息-理论知识" class="headerlink" title="报错信息+理论知识"></a>报错信息+理论知识</h3><p>当一个 bug 摆在面前，首先要做的就是要认真阅读展现出来的出错信息，这里面有几点需要注意</p><blockquote><p><strong>提高英语</strong></p></blockquote><p>专业词汇的积累、阅读能力等</p><blockquote><p><strong>运用底层知识</strong></p></blockquote><p>学会运行所学过的理论知识，比如在编程过程中，出现路径相关的错误，首先是根据报错可以直接在代码里面更改为正确可运行代码，然后可以利用所学过的操作系统相关文件管理知识等来进一步底层分析之，最后可以旁通自己之前搭建环境过程种总是要配的环境变量，一起思考一起分析，发散性思考，触类旁通所学知识，运用之</p><blockquote><p><strong>IDE 的 Debug 或 print 通法</strong></p></blockquote><p>熟悉各种开发环境的 debug</p><h3 id="搜索引擎"><a href="#搜索引擎" class="headerlink" title="搜索引擎"></a>搜索引擎</h3><blockquote><p><strong>一个原则</strong>：“遇事不决，大事谷歌，小事百度”</p></blockquote><ul><li>谷歌需要一些手段才能进行，总结下来就是<strong>搭建一个机场</strong>，方便，安全</li><li>百度解决一些小问题，抑或是 <strong>“烂大街的易错知识”</strong></li><li>相关编程论坛，比如 Stack Overflow、CSDN、博客园等（还是要用谷歌）</li></ul><blockquote><p><strong>结果择优原则</strong></p></blockquote><ul><li>环境统一：解决办法的环境需要和自己的 bug 的环境需要一致</li><li>非毁灭性原则：尽量不要做全局性的修改，比如用命令删除 git 的两个文件来改一个小 bug，属实挖坑</li></ul><blockquote><p><strong>擅用官方文档</strong></p></blockquote><p>如果说出现的 bug 抑或是，使用某个知识出错，是在官方文档中能查到的，优先选择官方文档</p><p>就比如在使用 python 数据分析的时候，许多时候，很多包（pandas、numpy、matplotlib 等）更新比较快，而网上找的一般都是旧版本的指导。同时<br>官方文档讲解更加全面，不过这过程中，要注意提高自身英语水平！</p><h3 id="复盘与重构"><a href="#复盘与重构" class="headerlink" title="复盘与重构"></a>复盘与重构</h3><blockquote><p><strong>复盘</strong></p></blockquote><p>去复现一个学习（复现代码）过程，<strong>复盘</strong>bug 之前的工作，来从中找出可能有哪些细节会导致出现该 bug。</p><blockquote><p><strong>重构</strong></p></blockquote><p>按照思路重写代码！再不行重装系统！</p><p>重构，让你的代码更优美和简洁~</p><p>重装，让你的世界焕然一新~</p><h2 id="三、多记录多总结多仔细"><a href="#三、多记录多总结多仔细" class="headerlink" title="三、多记录多总结多仔细"></a>三、多记录多总结多仔细</h2><blockquote><p>bug 遇见的多了，也就由“形同陌路”转变为“日久生情”了!<br>良好的编程习惯加快解决速度</p></blockquote><p>做事情还是粗心，百分之九十的 bug 都来源于粗心，</p><h2 id="四、持续补充"><a href="#四、持续补充" class="headerlink" title="四、持续补充"></a>四、持续补充</h2><ul><li>在利用搜索引擎找到解决办法时候，不要 <strong>吃着嘴里的，想着锅里的</strong> ，找到一个办法，先将其解决办法看懂看透彻，不要这个方法还没看透彻就看下一个答案。</li><li>学会提取关键词来搜索，能提高很大效率</li></ul>]]></content>
      
      
      <categories>
          
          <category> SoftwareEngineering </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JavaWeb学习笔记</title>
      <link href="blog/tb3der/"/>
      <url>blog/tb3der/</url>
      
        <content type="html"><![CDATA[<div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">大二下学期上课笔记</div><h1 id="【第二章】JavaWeb-概述"><a href="#【第二章】JavaWeb-概述" class="headerlink" title="【第二章】JavaWeb 概述"></a>【第二章】JavaWeb 概述</h1><h2 id="一、XML"><a href="#一、XML" class="headerlink" title="一、XML"></a>一、XML</h2><p><code>XML</code>  是一种标记性语言，但是不同于 <code>HTML</code> ，目的其实就是用于传输数据，但是 <code>HTML</code>  的目的可以理解为展示</p><blockquote><p>网站建好之后，需要将自己的文章链接提交到百度/谷歌，通过部署生成的<code>baidusitemap.xml</code>和<code>sitemap.xml</code>文件，sitemap 提交方式提交以达到目的。</p></blockquote><h3 id="XML-语法"><a href="#XML-语法" class="headerlink" title="XML 语法"></a>XML 语法</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598670375381-0e3b13a8-6a22-47fb-8e8f-32c203fbf25d.png#align=left&display=inline&height=207&margin=%5Bobject%20Object%5D&originHeight=388&originWidth=866&size=0&status=done&style=shadow&width=461"></p><ul><li>文档声明：图中最上面一行</li><li>元素定义：形式相当于 <code>HTML</code>  当中的标签，但不是标签，有根元素（一般只有一个），空元素等之分</li><li>属性定义：其中值需要用双引号或者单引号括起来</li><li>注释：和 <code>HTML</code>  一样</li></ul><h3 id="DTD-和-Schema-约束"><a href="#DTD-和-Schema-约束" class="headerlink" title="DTD 和 Schema 约束"></a>DTD 和 Schema 约束</h3><p>有些时候文档内可能内容语义有歧义，所以需要对其 xml 文件内容尽可能的加以约束，DTD 和 Schema 两种方式</p><h2 id="二、HTTP-协议"><a href="#二、HTTP-协议" class="headerlink" title="二、HTTP 协议"></a>二、HTTP 协议</h2><blockquote><p>生成的 web 项目和服务器之间的传输协议</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598670375263-a1f1c0c1-0d94-4f9d-97ed-9d8e7e1d2495.png#align=left&display=inline&height=127&margin=%5Bobject%20Object%5D&originHeight=127&originWidth=305&size=0&status=done&style=shadow&width=305"></p><blockquote><p>其中 http1.1 版本比 1.0 版本优化的是对 http 请求可以同时进行多个请求和响应</p></blockquote><h3 id="HTTP-请求消息"><a href="#HTTP-请求消息" class="headerlink" title="HTTP 请求消息"></a>HTTP 请求消息</h3><blockquote><p>客户端（web 浏览器）向服务器发送请求，通常由请求行、请求头、实体内容三部分组成</p></blockquote><ul><li>请求行：请求方式，资源路径，http 协议版本三部分组成。请求方式又有 GET（所请求内容会在资源路径后面带上参数值，会有大小限制）和 POST（安全，无大小限制）等方式</li></ul><h3 id="HTTP-响应消息"><a href="#HTTP-响应消息" class="headerlink" title="HTTP 响应消息"></a>HTTP 响应消息</h3><blockquote><p>也由三部分组成，有资源状态行、响应消息头、实体内容</p></blockquote><ul><li>资源状态行：协议版本 状态码 状态描述三部分组成。其中状态码有多种，常见的 404 就是服务器找不到相应请求的的资源</li></ul><h2 id="三、Tomcat"><a href="#三、Tomcat" class="headerlink" title="三、Tomcat"></a>三、Tomcat</h2><h3 id="关于-Tomcat"><a href="#关于-Tomcat" class="headerlink" title="关于 Tomcat"></a>关于 Tomcat</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598670375411-c8675707-4396-48f4-b181-07310231b868.png#align=left&display=inline&height=174&margin=%5Bobject%20Object%5D&originHeight=250&originWidth=844&size=0&status=done&style=shadow&width=588"></p><h3 id="下载安装-Tomcat"><a href="#下载安装-Tomcat" class="headerlink" title="下载安装 Tomcat"></a>下载安装 Tomcat</h3><p>安装等方式参考博客</p><h2 id="四、Web-应用"><a href="#四、Web-应用" class="headerlink" title="四、Web 应用"></a>四、Web 应用</h2><h3 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h3><blockquote><p>web 应用，就是一项工程，在编写 web 项目过程中，对文件按照“合乎规矩”的方式放置</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598670375598-ac6ece9f-6982-4a1d-a7d8-bc3c8b4ce0f7.png#align=left&display=inline&height=352&margin=%5Bobject%20Object%5D&originHeight=614&originWidth=830&size=0&status=done&style=shadow&width=476"></p><h3 id="IDEA-配置-Tomcat"><a href="#IDEA-配置-Tomcat" class="headerlink" title="IDEA 配置 Tomcat"></a>IDEA 配置 Tomcat</h3><p>搭建 web 开发环境</p><p>资源的访问，点击请求的页面跳转设置<code>web.xml</code>中配置</p><blockquote><p>阮一峰的网站当中，有类似域名自动跳转，是否和域名解析有关呢？抑或是对 web.xml 进行了操作？</p></blockquote><p>对 idea 进行 web 开发 配置<a href="https://blog.csdn.net/ZTlink1013/article/details/104815639">https://blog.csdn.net/ZTlink1013/article/details/104815639</a></p><h1 id="【第三章】Servlet"><a href="#【第三章】Servlet" class="headerlink" title="【第三章】Servlet"></a>【第三章】Servlet</h1><h2 id="一、什么是-Servlet"><a href="#一、什么是-Servlet" class="headerlink" title="一、什么是 Servlet"></a>一、什么是 Servlet</h2><h3 id="什么是-Servlet"><a href="#什么是-Servlet" class="headerlink" title="什么是 Servlet"></a>什么是 Servlet</h3><blockquote><p>Servlet 就是在服务器端的 Java 接口或者说是类（叫法有狭义广义之分），处理客户端传来的请求并作出相应的响应这么一个网络模块。</p></blockquote><ul><li>请求：客户端传来的调用或是一系列行为，同时也包含了请求所需要的数据。</li><li>响应：服务器根据客户端传来的请求做出响应，实时的展示给客户端。这之中 Servlet 相当于 java 类当中的一个接口，以请求来的信息作为输入，然后进行分析，做出相应。</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598670486756-3febd732-e4ee-413d-8868-a406760f5a22.png#align=left&display=inline&height=134&margin=%5Bobject%20Object%5D&originHeight=222&originWidth=783&size=0&status=done&style=shadow&width=472"></p><h3 id="JSP-和-Servlet"><a href="#JSP-和-Servlet" class="headerlink" title="JSP 和 Servlet"></a>JSP 和 Servlet</h3><blockquote><p>servlet 是控制层，jsp 转换为 servlet，用 servlet 来实现 http 请求。</p></blockquote><p>【1】JSP 第一次运行的时候会编译成 Servlet，驻留在内存中以供调用。</p><p>【2】JSP 是 web 开发技术，Servlet 是服务器端运用的小程序，我们访问一个 JSP 页面时，服务器会将这个 JSP 页面转变成 Servlet 小程序运行得到结果后，反馈给用户端的浏览器。</p><p>【3】Servlet 相当于一个控制层再去调用相应的 JavaBean 处理数据,最后把结果返回给 JSP。</p><p>【4】Servlet 主要用于转向，将请求转向到相应的 JSP 页面。</p><p>【5】JSP 更多的是进行页面显示，Servlet 更多的是处理业务，即 JSP 是页面，Servlet 是实现 JSP 的方法。</p><p>【6】Servlet 可以实现 JSP 的所有功能，但由于美工使用 Servlet 做界面非常困难，后来开发了 JSP。</p><p>【7】JSP 技术开发网站的两种模式：JSP + JavaBean；JSP + Servlet + JavaBean（一般在多层应用中, JSP 主要用作表现层,而 Servlet 则用作控制层,因为在 JSP 中放太多的代码不利于维护，而把这留给 Servlet 来实现,而大量的重复代码写在 JavaBean 中）。</p><p>【8】二者之间的差别就是，开发界面是 JSP 直接可以编写。</p><p>比如在 JSP 中写 Table 标记：<code>&lt;table&gt;[数据]&lt;/table&gt;；</code></p><p>Servlet 需要加入：<code>out.println(“&lt;table&gt;[数据]&lt;/table&gt;”)。</code></p><p>JSP 文件在被应用服务器(例如：Tomcat、Resin、Weblogic 和 Websphere),调用过之后，就被编译成为了 Servlet 文件。也就是说在网页上显示的其实是 Servlet 文件。Tomcat 下面 JSP 文件编译之后生成的 Servlet 文件被放在了 work 文件夹下，JSP 中的 HTML 代码在 Servlet 都被 out 出来，而 JSP 代码按照标签的不同会放在不同的位置。</p><p>【9】JSP 中嵌入 JAVA 代码，而 Servlet 中嵌入 HTML 代码。</p><p>【10】在一个标准的 MVC 架构中，Servlet 作为 Controller 接受用户请求并转发给相应的 Action 处理，JSP 作为 View 主要用来产生动态页面，EJB 作为 Model 实现你的业务代码。</p><h2 id="二、Servlet-基础"><a href="#二、Servlet-基础" class="headerlink" title="二、Servlet 基础"></a>二、Servlet 基础</h2><h3 id="接口及其实现类"><a href="#接口及其实现类" class="headerlink" title="接口及其实现类"></a>接口及其实现类</h3><p>就是利用其类编写相关服务器端的相关运行代码</p><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p>分三个阶段：初始化阶段-&gt;运行阶段-&gt;销毁阶段</p><h3 id="HttpServlet-类"><a href="#HttpServlet-类" class="headerlink" title="HttpServlet 类"></a>HttpServlet 类</h3><p>一般客户端和服务器之间都回使用 <code>HTTP协议</code> ，所以 Servlet 接口中就提供了一个抽象类<code>javax.servlet.http.HttpServlet</code>，他是 <code>GernericServlet</code>  的一个子类，专门用来处理 <code>HTTP协议</code>  的 servlet；具体程序中就是用该类</p><blockquote><p>HelloWordServlet.java</p></blockquote><pre><code class="java">package cn.itcast.firstmyapp.servlet;import java.io.IOException;import java.io.PrintWriter;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;public class HelloWordServlet extends HttpServlet &#123;     protected void doGet(HttpServletRequest req, HttpServletResponse resp)                throws ServletException, IOException &#123;         System.out.println(&quot;接受了客户端的请求-----------------------------&quot;);         // 设置响应类型:            resp.setContentType(&quot;text/html&quot;);            // 获取输出流:            PrintWriter pw = resp.getWriter();            // 写入响应:            pw.write(&quot;&lt;h1&gt;Hello, world!&lt;/h1&gt;&quot;);            // 最后不要忘记flush强制输出:            pw.flush();        &#125;&#125;</code></pre><h2 id="三、Servlet-虚拟路径的映射"><a href="#三、Servlet-虚拟路径的映射" class="headerlink" title="三、Servlet 虚拟路径的映射"></a>三、Servlet 虚拟路径的映射</h2><h3 id="1-多重映射"><a href="#1-多重映射" class="headerlink" title="1. 多重映射"></a>1. 多重映射</h3><blockquote><p>就相当于多加几个自己指定的访问路径，在 web.xml 中</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598670486704-cb7b6356-6317-47d3-85c4-a27582c41121.png#align=left&display=inline&height=221&margin=%5Bobject%20Object%5D&originHeight=455&originWidth=1003&size=0&status=done&style=shadow&width=487"></p><h3 id="2-映射路径下使用通配符"><a href="#2-映射路径下使用通配符" class="headerlink" title="2. 映射路径下使用通配符"></a>2. 映射路径下使用通配符</h3><blockquote><p>在其中使用通配符，一个目录下的所有路径都可以访问，其中有完全目录匹配，目录匹配，扩展名匹配</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598670487060-fa223535-eabd-40c6-bf7e-088fc77c9c87.png#align=left&display=inline&height=92&margin=%5Bobject%20Object%5D&originHeight=106&originWidth=568&size=0&status=done&style=shadow&width=493"></p><h3 id="3-缺省"><a href="#3-缺省" class="headerlink" title="3. 缺省"></a>3. 缺省</h3><p>通常作用是解决请求的资源找不到的情况，（404：请求的资源找不到）</p><h2 id="四、-ServletConfig-和-ServletContext"><a href="#四、-ServletConfig-和-ServletContext" class="headerlink" title="四、 ServletConfig  和 ServletContext"></a>四、 <code>ServletConfig</code>  和 <code>ServletContext</code></h2><blockquote><p>ServletConfig 接口</p></blockquote><p>类比于 git 根文件夹<code>.ssh</code>下的 config 配置文件，它是 servlet 的配置对象，目的就是获取与 servlet 的初始化参数</p><blockquote><p>PS:会使用常用的接口方法</p></blockquote><h1 id="【第五章】会话技术"><a href="#【第五章】会话技术" class="headerlink" title="【第五章】会话技术"></a>【第五章】会话技术</h1><h2 id="一、会话技术"><a href="#一、会话技术" class="headerlink" title="一、会话技术"></a>一、会话技术</h2><p>相当于在客户端和服务器端之间，记录一些用户信息，但是不能用上一章节的，因为那只能保存暂时的信息。 <code>servlet</code>  还提供两个对象 <code>Cookie</code>  和 <code>Session</code>  可以更好地更好地保存会话数据。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598670565525-6a2b8b74-4105-447a-95ba-034020c747fe.png#align=left&display=inline&height=117&margin=%5Bobject%20Object%5D&originHeight=215&originWidth=1105&size=0&status=done&style=shadow&width=601"></p><h1 id="【第六章】JSP-技术"><a href="#【第六章】JSP-技术" class="headerlink" title="【第六章】JSP 技术"></a>【第六章】JSP 技术</h1><h2 id="一、JSP-概述"><a href="#一、JSP-概述" class="headerlink" title="一、JSP 概述"></a>一、JSP 概述</h2><p>一种新的编写动态网页的技术，虽然本质还是调用了 <code>servlet</code> ，但是相比前者要简单很多（前者向页面写数据麻烦，复杂），其组成可以简单理解为<br><code>jsp = html + java + jsp自身</code></p><p>调用 servlet 过程：<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598670585374-60fc5166-cb3c-433e-9794-bae3778a3cd8.png#align=left&display=inline&height=251&margin=%5Bobject%20Object%5D&originHeight=479&originWidth=910&size=0&status=done&style=shadow&width=477"></p><p>其中 jsp 生成 java 文件，编译成 class 文件所在目录（本来应该在 tomcat 的 work 路径下）：<code>D:\project-java\.metadata\.plugins\org.eclipse.wst.server.core\tmp0\work\Catalina\localhost\demo-jsp\org\apache\jsp</code><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598670585365-5f311403-0761-4643-aa17-931be713fc49.png#align=left&display=inline&height=71&margin=%5Bobject%20Object%5D&originHeight=71&originWidth=468&size=0&status=done&style=shadow&width=468"></p><p>打开 java 文件之后可以看到相关对 sevlet 的继承</p><h2 id="二、JSP-语法"><a href="#二、JSP-语法" class="headerlink" title="二、JSP 语法"></a>二、JSP 语法</h2><h3 id="jsp-脚本元素"><a href="#jsp-脚本元素" class="headerlink" title="jsp 脚本元素"></a>jsp 脚本元素</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598670585361-957371bf-bb37-407a-90e8-8f21175d6589.png#align=left&display=inline&height=169&margin=%5Bobject%20Object%5D&originHeight=295&originWidth=1117&size=0&status=done&style=shadow&width=639"></p><h3 id="jsp-注释"><a href="#jsp-注释" class="headerlink" title="jsp 注释"></a>jsp 注释</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598670585756-18f96e5c-8a74-4e14-8c16-55a9fd9124df.png#align=left&display=inline&height=118&margin=%5Bobject%20Object%5D&originHeight=118&originWidth=643&size=0&status=done&style=shadow&width=643"></p><h3 id="jsp-指令"><a href="#jsp-指令" class="headerlink" title="jsp 指令"></a>jsp 指令</h3><blockquote><p>page 指令</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598670585347-a182a404-b425-4f70-80d6-712122944623.png#align=left&display=inline&height=146&margin=%5Bobject%20Object%5D&originHeight=224&originWidth=1007&size=0&status=done&style=shadow&width=658"></p><blockquote><p>include 指令</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598670585378-bbe2df4b-013e-4531-bece-2836e4b8bde0.png#align=left&display=inline&height=142&margin=%5Bobject%20Object%5D&originHeight=185&originWidth=884&size=0&status=done&style=shadow&width=677"></p><blockquote><p>taglib 指令</p></blockquote><h3 id="jsp-隐式对象"><a href="#jsp-隐式对象" class="headerlink" title="jsp 隐式对象"></a>jsp 隐式对象</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598670585348-c41424d0-e688-4ae6-809e-bcc33afec5e3.png#align=left&display=inline&height=195&margin=%5Bobject%20Object%5D&originHeight=274&originWidth=912&size=0&status=done&style=shadow&width=650"></p><h1 id="【第九章】JDBC"><a href="#【第九章】JDBC" class="headerlink" title="【第九章】JDBC"></a>【第九章】JDBC</h1><h2 id="一、什么是-JDBC"><a href="#一、什么是-JDBC" class="headerlink" title="一、什么是 JDBC"></a>一、什么是 JDBC</h2><blockquote><p>使用数据库来存储和管理数据</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598670606448-7b5d3ec0-c6eb-4485-af84-34a1d99fa4a1.png#align=left&display=inline&height=338&margin=%5Bobject%20Object%5D&originHeight=778&originWidth=1159&size=0&status=done&style=shadow&width=503"><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598670606324-93a22794-21bb-42fc-9355-64c55411ea53.png#align=left&display=inline&height=99&margin=%5Bobject%20Object%5D&originHeight=200&originWidth=983&size=0&status=done&style=shadow&width=487"></p><h2 id="二、JDBC-常用的-API"><a href="#二、JDBC-常用的-API" class="headerlink" title="二、JDBC 常用的 API"></a>二、JDBC 常用的 API</h2><blockquote><p>五个接口一个类（唯一的类）</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598670606334-40b58ccd-ef50-4048-a17a-819885cdcf87.png#align=left&display=inline&height=197&margin=%5Bobject%20Object%5D&originHeight=282&originWidth=931&size=0&status=done&style=shadow&width=649"><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598670606546-72057847-1b52-4b82-8f03-d2dcff6e0ed4.png#align=left&display=inline&height=249&margin=%5Bobject%20Object%5D&originHeight=392&originWidth=1001&size=0&status=done&style=shadow&width=635"><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598670606535-2996029c-eaf0-45ee-a778-614141ceea4f.png#align=left&display=inline&height=112&margin=%5Bobject%20Object%5D&originHeight=136&originWidth=755&size=0&status=done&style=shadow&width=624"></p><h1 id="【第十一章】JSP-开发模型"><a href="#【第十一章】JSP-开发模型" class="headerlink" title="【第十一章】JSP 开发模型"></a>【第十一章】JSP 开发模型</h1><h2 id="一、JSP-两种开发模式"><a href="#一、JSP-两种开发模式" class="headerlink" title="一、JSP 两种开发模式"></a>一、JSP 两种开发模式</h2><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598670623021-1406c5eb-f010-4d9f-a6fe-cd104b964450.png#align=left&display=inline&height=54&margin=%5Bobject%20Object%5D&originHeight=54&originWidth=998&size=0&status=done&style=shadow&width=998"></p><h3 id="JSP-Model1"><a href="#JSP-Model1" class="headerlink" title="JSP Model1"></a>JSP Model1</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598670623035-3dae1126-3986-4893-afbf-ce3aa250deb1.png#align=left&display=inline&height=178&margin=%5Bobject%20Object%5D&originHeight=178&originWidth=1220&size=0&status=done&style=shadow&width=1220"><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598670623082-df4cb3b4-1eb4-4590-a68f-f18a31a31816.png#align=left&display=inline&height=210&margin=%5Bobject%20Object%5D&originHeight=469&originWidth=1291&size=0&status=done&style=shadow&width=579"></p><h3 id="JSP-Model2"><a href="#JSP-Model2" class="headerlink" title="JSP Model2"></a>JSP Model2</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598670623814-f1853ddf-0ab6-443c-b90f-97147896aa3c.png#align=left&display=inline&height=242&margin=%5Bobject%20Object%5D&originHeight=242&originWidth=1045&size=0&status=done&style=shadow&width=1045"><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598670623035-37842a30-2e67-40d6-9b33-fc7a90a89037.png#align=left&display=inline&height=208&margin=%5Bobject%20Object%5D&originHeight=515&originWidth=1297&size=0&status=done&style=shadow&width=523"></p><h2 id="二、MVC-设计模式"><a href="#二、MVC-设计模式" class="headerlink" title="二、MVC 设计模式"></a>二、MVC 设计模式</h2><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598670623024-0fbab2bd-139b-4e8e-806a-a010e86e6159.png#align=left&display=inline&height=204&margin=%5Bobject%20Object%5D&originHeight=204&originWidth=1185&size=0&status=done&style=shadow&width=1185"><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598670623036-c1e95730-c04c-44ab-a07d-be7d3ce47970.png#align=left&display=inline&height=105&margin=%5Bobject%20Object%5D&originHeight=105&originWidth=1138&size=0&status=done&style=shadow&width=1138"></p><h2 id="三、JavaWeb-开发中的三层架构"><a href="#三、JavaWeb-开发中的三层架构" class="headerlink" title="三、JavaWeb 开发中的三层架构"></a>三、JavaWeb 开发中的三层架构</h2><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598670623143-02074466-5715-4efa-8b09-ee2a1489d94e.png#align=left&display=inline&height=153&margin=%5Bobject%20Object%5D&originHeight=153&originWidth=1077&size=0&status=done&style=shadow&width=1077"><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598670623075-f2b2b6ce-ebd7-4712-86f3-61ee087aafbb.png#align=left&display=inline&height=198&margin=%5Bobject%20Object%5D&originHeight=499&originWidth=1326&size=0&status=done&style=shadow&width=525"><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598670622943-c73fc987-bbd4-4204-9a82-6a93ea4ac8ed.png#align=left&display=inline&height=224&margin=%5Bobject%20Object%5D&originHeight=224&originWidth=1066&size=0&status=done&style=shadow&width=1066"></p>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
          <category> 网站相关 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>GitHub Actions代码汇总</title>
      <link href="blog/uwpbn0/"/>
      <url>blog/uwpbn0/</url>
      
        <content type="html"><![CDATA[<h2 id="仓库文件夹备份"><a href="#仓库文件夹备份" class="headerlink" title="仓库文件夹备份"></a>仓库文件夹备份</h2><pre><code class="yaml">name: CIon: [watch]jobs:  build:    runs-on: ubuntu-latest    steps:      - uses: actions/checkout@v2      - name: 配置Git        run: |          git config --global user.name &#39;wztlink1013&#39;           git config --global user.email &#39;2550374815@qq.com&#39;      - name: 在云端进行复制文件夹操作        env:          Github_Token: $&#123;&#123; secrets.TOKEN_GITHUBAPI &#125;&#125;        run: |          git clone https://$&#123;Github_Token&#125;@github.com/wztlink1013/website-source website-source          cd website-source          cp -r ./Secret文集/ ./backup/          git status          git add .          git commit -m &quot;backup&quot;          git push --force --quiet &quot;https://$&#123;Github_Token&#125;@github.com/wztlink1013/website-source&quot;  master:master</code></pre><h2 id="博客-CICD-腾讯云函数"><a href="#博客-CICD-腾讯云函数" class="headerlink" title="博客 CICD 腾讯云函数"></a>博客 CICD 腾讯云函数</h2><h3 id="Python2-7-执行环境"><a href="#Python2-7-执行环境" class="headerlink" title="Python2.7 执行环境"></a>Python2.7 执行环境</h3><pre><code class="python"># -*- coding: utf8 -*-import requestsdef main_handler(event, context):    r = requests.post(&quot;https://api.github.com/repos/wztlink1013/Blog3.0/dispatches&quot;,    json=&#123;&#39;event_type&#39;: &quot;run-it&quot;&#125;,    headers = &#123;&quot;User-Agent&quot;:&#39;curl/7.52.1&#39;,              &#39;Content-Type&#39;: &#39;application/json&#39;,              &#39;Accept&#39;: &#39;application/vnd.github.everest-preview+json&#39;,              &#39;Authorization&#39;: &#39;token **********&#39;&#125;)    if r.status_code == 204:        return &quot;This&#39;s OK!&quot;    else:        return r.status_code</code></pre><h3 id="触发器设置"><a href="#触发器设置" class="headerlink" title="触发器设置"></a>触发器设置</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1594789179624-938bb8c2-ac15-4ece-a5f1-001563e4f08b.png?x-oss-process=image/resize,w_1210#align=left&display=inline&height=564&margin=%5Bobject%20Object%5D&originHeight=564&originWidth=1210&status=done&style=shadow&width=1210"></p><h2 id="博客-CICD-阿里云函数"><a href="#博客-CICD-阿里云函数" class="headerlink" title="博客 CICD 阿里云函数"></a>博客 CICD 阿里云函数</h2><h3 id="Python3-执行环境"><a href="#Python3-执行环境" class="headerlink" title="Python3 执行环境"></a>Python3 执行环境</h3><pre><code class="python"># -*- coding: utf-8 -*-import loggingimport requestsOK = b&#39;ok\n&#39;def handler(environ, start_response):    status = &#39;200 OK&#39;    response_headers = [(&#39;Content-type&#39;, &#39;text/plain&#39;)]    sync_yuque()    start_response(status, response_headers)    return [OK]def sync_yuque():    requests.post(&quot;https://api.github.com/repos/wztlink1013/Blog3.0/dispatches&quot;,    json=&#123;&#39;event_type&#39;: &quot;run-it&quot;&#125;,    headers=&#123;&quot;User-Agent&quot;:&#39;curl/7.52.1&#39;,              &#39;Content-Type&#39;: &#39;application/json&#39;,              &#39;Accept&#39;: &#39;application/vnd.github.everest-preview+json&#39;,              &#39;Authorization&#39;: &#39;token *********&#39;&#125;)</code></pre>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Git常见使用+多账号同设备部署总结</title>
      <link href="blog/fnsge3/"/>
      <url>blog/fnsge3/</url>
      
        <content type="html"><![CDATA[<h2 id="一、Git-安装和本地用户全局配置"><a href="#一、Git-安装和本地用户全局配置" class="headerlink" title="一、Git 安装和本地用户全局配置"></a>一、Git 安装和本地用户全局配置</h2><p>官网<a href="https://git-scm.com/download/win">https://git-scm.com/download/win</a>并且安装</p><p>查看是否安装成功<code>win + R</code>进入 CMD 输入 git，出现 git 命令指南，则安装成功</p><p><strong>全局配置本地用户</strong>，在 git Bash 中进行下面配置（尽量仔细，检查一遍），下面的账号名字和邮箱都是 github 的账号所使用的</p><pre><code class="bash">git config --global user.name &quot;wztlink1013&quot;git config --global user.email &quot;email@qq.com&quot;</code></pre><p>其中：global 表示全局可用，如果要设置局部可用，则只需要删除 global 即可</p><p>验证是否配置成功：<code>git config --global --list</code></p><h2 id="二、利用-SSH-绑定-Git-和-GitHub"><a href="#二、利用-SSH-绑定-Git-和-GitHub" class="headerlink" title="二、利用 SSH 绑定 Git 和 GitHub"></a>二、利用 SSH 绑定 Git 和 GitHub</h2><h3 id="生成"><a href="#生成" class="headerlink" title="生成"></a>生成</h3><p>输入<code>ssh-keygen -t rsa</code>，然后回车三下 <del>（有些时候要回车四下）</del></p><p>然后在用户管理员文件夹下生成两个文件夹 id_rsa 和 id_rsa.pub,将后者内容添加到 GitHub 上即可。</p><h3 id="添加"><a href="#添加" class="headerlink" title="添加"></a>添加</h3><p>在 github 上的 setting 上添加新的 ssh 即可</p><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>在 git Bash 输入：<code>ssh -T git@github.com</code></p><ul><li>如果出现 Hi name !you are……证明绑定成功。</li><li>如果报错，则是因为少了一个文件，使用过程中直接点 yes。具体<a href="https://blog.csdn.net/qq_34446663/article/details/81106018">解决原理</a></li></ul><h2 id="三、Git-向-GitHub-提交代码"><a href="#三、Git-向-GitHub-提交代码" class="headerlink" title="三、Git 向 GitHub 提交代码"></a>三、Git 向 GitHub 提交代码</h2><p>了解 pull 和 push</p><p><code>git push origin master</code></p><p><code>git pull origin master</code></p><h3 id="提交情况-1：clone"><a href="#提交情况-1：clone" class="headerlink" title="提交情况 1：clone"></a>提交情况 1：clone</h3><p>本地没有 git 仓库，也没有 git init 操作，需要先从 GitHub 下载</p><p>选定仓库克隆</p><blockquote><p>git clone <a href="https://github.com/wztlink1013/Python_DataAnalysis.git">https://github.com/wztlink1013/Python_DataAnalysis.git</a></p></blockquote><p>对本地文件夹进行一系列更改之后，执行命令：</p><pre><code>git status   #查看仓库命令状态git add .    #文件提交到文件缓冲区git commmit -m &quot;描述本次修改信息&quot;    #提交仓库并且添加提交信息git log  #查看修改日志git status   #再次查看</code></pre><p>push 到远程仓库</p><blockquote><p>首次推送：<code>git push -u origin master</code><br>非首次推送：<code>git push origin master</code></p></blockquote><h3 id="提交情况-2：pull"><a href="#提交情况-2：pull" class="headerlink" title="提交情况 2：pull"></a>提交情况 2：pull</h3><p>这种情况是，本地有 git 仓库，指之前已经进行 git init 等一系列命令对该文件夹操作过。新建一个例子：</p><blockquote><p><code>git init</code>初始化本地仓库<br><code>git remote add origin [https://github.com/guobinhit/springmvc-tutorial.git](https://github.com/guobinhit/springmvc-tutorial.git)</code>关联远程仓库<br><code>git pull origin master</code>同步远程仓库和本地仓库</p></blockquote><p>假如在本地新加文件：</p><blockquote><p>执行 git status 等命令<br>再执行<code>git push origin master</code>将本地新内容提交到远程仓库</p></blockquote><p><strong>注意！</strong>：在进行本地仓库和远程仓库的文件交互时，一定要先 pull 再 push，不然会出未知错误。</p><h2 id="四、常用命令总结"><a href="#四、常用命令总结" class="headerlink" title="四、常用命令总结"></a>四、常用命令总结</h2><h3 id="常规命令"><a href="#常规命令" class="headerlink" title="常规命令"></a>常规命令</h3><pre><code>git initgit statusgit addgit commitgit loggit branch   #查看分支git checkout    #切换分支git merge   #合并分支git branch -d   #删除分支git tag #给分支添加标签git remote -v   #查看相关信息</code></pre><h3 id="git-push-f"><a href="#git-push-f" class="headerlink" title="git push -f"></a>git push -f</h3><p>报错信息</p><pre><code class="bash">$ git push origin masterTo https://github.com/wztlink1013/website-source.git ! [rejected]        master -&gt; master (fetch first)error: failed to push some refs to &#39;https://github.com/wztlink1013/website-source.git&#39;hint: Updates were rejected because the remote contains work that you dohint: not have locally. This is usually caused by another repository pushinghint: to the same ref. You may want to first integrate the remote changeshint: (e.g., &#39;git pull ...&#39;) before pushing again.hint: See the &#39;Note about fast-forwards&#39; in &#39;git push --help&#39; for details.</code></pre><p>分析并解决问题</p><blockquote><p>强制性 push</p></blockquote><pre><code class="bash">$ git push -f origin master</code></pre><h3 id="文件夹相关命令"><a href="#文件夹相关命令" class="headerlink" title="文件夹相关命令"></a>文件夹相关命令</h3><blockquote><p>复制文件夹</p></blockquote><pre><code class="bash">cp  -r  ./js/  ./backup/</code></pre><blockquote><p>移动文件夹</p></blockquote><pre><code class="bash">mv  visualization/  -f  .github_pages/</code></pre><blockquote><p>删除文件夹</p></blockquote><pre><code class="bash">rm  -r  .git</code></pre><h2 id="五、部署多个-github-coding-等账号"><a href="#五、部署多个-github-coding-等账号" class="headerlink" title="五、部署多个 github/+coding 等账号"></a>五、部署多个 github/+coding 等账号</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>好处：一台设备可以使用多个 github 账号/github+coding 等等多平台托管/搭建两个静态博客</p><p>取消全局用户配置（每建立一个新文件夹，需要输入使用账号），建立多个 ssh 密匙（如果是 github 账号+coding 账号+gitee 账号等）</p><p>SSH 的公钥是 GitHub 连接本地仓库和远程仓库的标识，一个公钥只能对应一个 GitHub 账户，一个相同的公钥不能上传到不同的 GitHub 账户</p><p>一台电脑，可以生成多对公私钥，可以通过配置，将不同的公钥上传到不同的 GitHub 账号，那么就不存在单个公钥绑定多个 GitHub 账号的情况存在了</p><h3 id="多密匙生成"><a href="#多密匙生成" class="headerlink" title="多密匙生成"></a>多密匙生成</h3><ul><li>先进来该文件夹（忽略图片上写的字）<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1597632490897-11718be6-6492-4ead-a739-1c92af25c648.png#height=372&id=rIi3X&originHeight=372&originWidth=1215&originalType=binary%E2%88%B6=1&size=0&status=done&style=none&width=1215"></li><li>创建新密匙方法一（首选）</li></ul><p><code>ssh-keygen -t rsa -f ~/.ssh/这里是新密钥名称 -C &quot;这里是你的邮箱&quot;</code></p><p>注意区别新密钥名称和旧密钥名称，不要相同！！</p><ul><li>创建新密匙方法二</li></ul><p>输入这个：<code>ssh-keygen -t rsa -C &quot;这里是你的邮箱&quot;</code></p><p>出现这两句：<br><code>Generating public/private rsa key pair.</code></p><p><code>Enter file in which to save the key (/c/Users/you/.ssh/id_rsa):</code></p><p>注意此时需要你输入新密钥的名称，同样要注意区别新密钥名称和旧密钥名称，不要相同，之后再两次回车。</p><h3 id="配置-config"><a href="#配置-config" class="headerlink" title="配置 config"></a>配置 config</h3><p>.ssh 根文件夹下没有 config 文件，需要新建</p><ul><li>新建 config 文件方法一</li></ul><p>在.ssh 根路径下键入该命令<code>touch config</code></p><ul><li>新建 config 文件方法二</li></ul><p>记事本新建文件 config 文件！！没有后缀</p><ul><li>输入内容</li></ul><pre><code>#第一个账号，默认使用的账号，不用做任何更改Host github.com    HostName github.com    User git    IdentityFile ~/.ssh/id_rsa#第二个新账号，#&quot;xxxxxx&quot;为前缀名，可以任意设置，要记住，后面需要用到Host xxxxxx.github.com    HostName github.com    User git    IdentityFile ~/.ssh/这里是你创建的新密钥的名称</code></pre><pre><code># one(one@gmail.com)Host one.github.comHostName github.comPreferredAuthentications publickeyIdentityFile ~/.ssh/id_rsa_oneUser one# two(two@gmail.com)Host two.github.comHostName github.comPreferredAuthentications publickeyIdentityFile ~/.ssh/id_rsa_twoUser two</code></pre><pre><code>Host myhost（这里是自定义的host简称，以后连接远程服务器就可以用命令ssh myhost）HostName 主机名可用ip也可以是域名(如:github.com或者bitbucket.org)Port 服务器open-ssh端口（默认：22,默认时一般不写此行）PreferredAuthentications   配置登录时用什么权限认证--可设为publickey,password publickey,keyboard-interactive等IdentityFile 证书文件路径（如~/.ssh/id_rsa_*)User 登录用户名(如：git)</code></pre><p>每个账号单独配置一个 Host，每个 Host 要取一个别名，一般为每个 Host 主要配置 HostName 和 IdentityFile 两个属性，配置完保存即可。</p><p>Host 的名字可以自定义名字，不过这个会影响 git 相关命令，例如：Host mygithub 这样定义的话，使用命令 git clone git@mygithub:PopFisher/AndroidRotateAnim.git，git@后面紧跟的名字改为 mygithub</p><blockquote><p><strong>mine</strong> &gt; <img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1597632490639-fd51b09d-c037-4fdb-bad3-e2e1d56d7aed.png#height=637&id=uEqZT&originHeight=637&originWidth=999&originalType=binary%E2%88%B6=1&size=0&status=done&style=none&width=999"></p></blockquote><h3 id="部署-SSH-key"><a href="#部署-SSH-key" class="headerlink" title="部署 SSH key"></a>部署 SSH key</h3><p>将根文件夹下的<code>wztlink1013.pub</code>文件复制到 github 上，coding/gitee 类似</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1597632490332-674f64ec-d09e-4351-a3cd-dbebc15a3a32.png#height=872&id=P7hWK&originHeight=872&originWidth=1839&originalType=binary%E2%88%B6=1&size=0&status=done&style=none&width=1839"><br>title 可以随便填</p><h3 id="清缓存，添-agent"><a href="#清缓存，添-agent" class="headerlink" title="清缓存，添 agent"></a>清缓存，添 agent</h3><p>在根目录下</p><pre><code>ssh-add -Dssh-add xxxxxx #旧密钥名称，一般是id_rsassh-add xxxxxx #新创建的密钥名称</code></pre><p>如果执行以上命令出现错误：<code>Could not open a connection to your authentication agent.</code>，那么就需要先执行<code>ssh-agent bash</code>，再执行以上命令</p><h3 id="验证是否配置成功"><a href="#验证是否配置成功" class="headerlink" title="验证是否配置成功"></a>验证是否配置成功</h3><p>一下第一个是之前默认的 github 账号，默认即可，第二个是添加的</p><pre><code>ssh -T git@github.comssh -T git@xxxxxxx.github.com</code></pre><p>出现<code>Hi 你的用户名! You&#39;ve successfully authenticated, but GitHub does not provide shell access.</code>则成功。</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ul><li>取消全局用户名和邮箱配置（如果已经设置了全局的话）</li></ul><pre><code>git config --global --unset user.namegit config --global --unset user.email</code></pre><ul><li>clone</li></ul><p>原来：<code>git clone git@github.com: wztlink1013/learngit.git</code></p><p>现在：</p><pre><code>git clone git@wztlink1013.github.com: wztlink1013/learngit.gitgit clone git@twicename.github.com: twicename/learngit.git</code></pre><ul><li>单独为每个 repo 设置 用户名/邮箱【以文件夹为单位】</li></ul><pre><code>git config user.name &quot;wztlink1013&quot;git config user.email &quot;2550374815@qq.com&quot;git config user.name &quot;twicename&quot;git config user.email &quot;123456789@qq.com&quot;</code></pre><p>如果报错：<code>fatal: not in a git directory</code>，说明没有进入.git 目录下，具体路径：其中.git 目录是隐藏的，需要你设置隐藏目录可见<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1597632490310-1580343b-946c-4d67-a063-d5cd11bc6136.png#height=105&id=oPGRx&originHeight=105&originWidth=925&originalType=binary%E2%88%B6=1&size=0&status=done&style=none&width=925"></p><p>执行<code>git config --list</code>查看设置是否成功</p><h2 id="六、参考资料"><a href="#六、参考资料" class="headerlink" title="六、参考资料"></a>六、参考资料</h2><ul><li><a href="https://github.com/guobinhit/cg-blog/blob/master/articles/github/README.md">GitHub 简单使用 https://github.com/guobinhit/cg-blog/blob/master/articles/github/README.md</a></li><li><a href="https://www.itrhx.com/2019/01/18/A16-deploy-two-or-more-hexo-blogs/">多账号 https://www.itrhx.com/2019/01/18/A16-deploy-two-or-more-hexo-blogs/</a></li><li><a href="https://blog.csdn.net/u013716535/article/details/78621775">多账号 https://blog.csdn.net/u013716535/article/details/78621775</a></li><li><a href="https://blog.csdn.net/IT_xiao_bai/article/details/88563103?depth_1-utm_source=distribute.pc_relevant.none-task&utm_source=distribute.pc_relevant.none-task">多账号 https://blog.csdn.net/IT_xiao_bai/article/details/88563103?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> VersionControlSystem </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JAVA数组学习笔记</title>
      <link href="blog/3a4bb6f2744b1bed337d1f558ee3ec0e/"/>
      <url>blog/3a4bb6f2744b1bed337d1f558ee3ec0e/</url>
      
        <content type="html"><![CDATA[<div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">JAVA课程中讲到数组这类数据结构的笔记，做此记录</div><h2 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h2><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><pre><code class="java">double [] array; // 声明数组方式一double array []; // 生命数组方式二</code></pre><p>创建好编译器会有初始值<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598686523691-98e6140a-a9e1-4218-9589-dc55ff35ed67.png#align=left&display=inline&height=79&margin=%5Bobject%20Object%5D&originHeight=240&originWidth=895&size=0&status=done&style=shadow&width=293"></p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><pre><code class="java">double [] array = new double[10]; // 生命数组并且初始化数组大小double [] array = &#123;1.9, 2.9, 3.4, 3.5&#125;; // 用值初始化数组</code></pre><h3 id="相关属性"><a href="#相关属性" class="headerlink" title="相关属性"></a>相关属性</h3><blockquote><p>是一个对象，有自己的属性自己的方法</p></blockquote><p>String 里面长度 length 有()，也就是 String 里面是方法，而数组没有括号()（写成 array.length），理解为成员变量/属性，而不是方法（封装好了许多功能，体现出语言优越性）</p><h3 id="相关操作"><a href="#相关操作" class="headerlink" title="相关操作"></a>相关操作</h3><ul><li><input checked="" disabled="" type="checkbox"> Initializing arrays with input values</li></ul><pre><code class="java">java.util.Scanner input = new java.util.Scanner(System.in);for (int i=0;i&lt;mylist.length;i++)    mylist[i] = input.nextDouble();</code></pre><ul><li><input checked="" disabled="" type="checkbox"> Initializing arrays with random values</li></ul><pre><code class="java">for (int i = 0; i &lt; myList.length; i++) &#123;  myList[i] = Math.random() * 100;&#125;</code></pre><ul><li><input checked="" disabled="" type="checkbox"> Printing arrays</li></ul><pre><code class="java">for (int i = 0; i &lt; myList.length; i++) &#123;  System.out.print(myList[i] + &quot; &quot;);&#125;</code></pre><ul><li><input checked="" disabled="" type="checkbox"> Summing all elements</li></ul><pre><code class="java">double total = 0;for (int i = 0; i &lt; myList.length; i++) &#123;  total += myList[i];&#125;</code></pre><ul><li><input checked="" disabled="" type="checkbox"> Finding the largest element</li></ul><pre><code class="java">double max = myList[0];for (int i = 1; i &lt; myList.length; i++) &#123;  if (myList[i] &gt; max) max = myList[i];&#125;</code></pre><ul><li><input disabled="" type="checkbox"> Finding the smallest index of the largest element</li><li><input checked="" disabled="" type="checkbox"> Random shuffling</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598686524154-f90809c6-aaae-46bf-b892-5e6f9ed63f50.png#align=left&display=inline&height=502&margin=%5Bobject%20Object%5D&originHeight=502&originWidth=1168&size=0&status=done&style=shadow&width=1168"></p><ul><li><input checked="" disabled="" type="checkbox"> Shifting elements</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598686523785-4984f380-9ca1-4e26-94c5-9c7de0a9c9a1.png#align=left&display=inline&height=470&margin=%5Bobject%20Object%5D&originHeight=470&originWidth=1164&size=0&status=done&style=shadow&width=1164"></p><h3 id="数组的值传递"><a href="#数组的值传递" class="headerlink" title="数组的值传递"></a>数组的值传递</h3><blockquote><p><strong>java 核心知识点之一</strong></p></blockquote><p>数组名（数组地址）作为函数参数</p><p>java 当中是<strong>值传递</strong>的，没有引用没有指针的概念，所以在做函数参数当中，一直都是值传递，python 也是。</p><h3 id="Array-类"><a href="#Array-类" class="headerlink" title="Array 类"></a>Array 类</h3><blockquote><p>import java.util.Arrays;</p></blockquote><ul><li><input checked="" disabled="" type="checkbox"> Array 类中常用的函数<blockquote><p>sort()、parallelSort()、fill()、toString()、binarySearch()（Binary Search 二分查找（事先得排好序））、equals()</p></blockquote></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598686524086-a8d0a2b1-81e5-4045-8cdf-21b40f26c53e.png#align=left&display=inline&height=224&margin=%5Bobject%20Object%5D&originHeight=488&originWidth=1225&size=0&status=done&style=shadow&width=562"><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598686524588-f9bcf764-f194-42b9-9c16-3e1676e8964e.png#align=left&display=inline&height=593&margin=%5Bobject%20Object%5D&originHeight=736&originWidth=662&size=0&status=done&style=shadow&width=533"></p><h2 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h2><h3 id="二维数组的创建、初始化"><a href="#二维数组的创建、初始化" class="headerlink" title="二维数组的创建、初始化"></a>二维数组的创建、初始化</h3><pre><code class="java">dataType[][] refVar = new dataType[10][10];int[][] array = &#123;  &#123;1, 2, 3&#125;,  &#123;4, 5, 6&#125;,  &#123;7, 8, 9&#125;,  &#123;10, 11, 12&#125;&#125;;</code></pre><blockquote><p>数组长度的计算</p></blockquote><pre><code>array.length = 4array[0].length = 3array[4].length ==&gt; ArrayIndexOutOfBoundsException</code></pre><h3 id="二维数组的相关操作"><a href="#二维数组的相关操作" class="headerlink" title="二维数组的相关操作"></a>二维数组的相关操作</h3><ul><li><input checked="" disabled="" type="checkbox"> Initializing arrays with input values</li></ul><pre><code class="java">java.util.Scanner input = new Scanner(System.in);System.out.println(&quot;Enter &quot; + matrix.length + &quot; rows and &quot; +  matrix[0].length + &quot; columns: &quot;);for (int row = 0; row &lt; matrix.length; row++) &#123;  for (int column = 0; column &lt; matrix[row].length; column++) &#123;    matrix[row][column] = input.nextInt();  &#125;&#125;</code></pre><ul><li><input checked="" disabled="" type="checkbox"> Initializing arrays with random values</li></ul><pre><code class="java">for (int row = 0; row &lt; matrix.length; row++) &#123;  for (int column = 0; column &lt; matrix[row].length; column++) &#123;    matrix[row][column] = (int)(Math.random() * 100);  &#125;&#125;</code></pre><ul><li><input checked="" disabled="" type="checkbox"> Printing arrays</li></ul><pre><code class="java">for (int row = 0; row &lt; matrix.length; row++) &#123;  for (int column = 0; column &lt; matrix[row].length; column++) &#123;    System.out.print(matrix[row][column] + &quot; &quot;);  &#125;  System.out.println();&#125;</code></pre><ul><li><input checked="" disabled="" type="checkbox"> Summing all elements</li></ul><pre><code class="java">int total = 0;for (int row = 0; row &lt; matrix.length; row++) &#123;  for (int column = 0; column &lt; matrix[row].length; column++) &#123;    total += matrix[row][column];  &#125;&#125;</code></pre><ul><li><input checked="" disabled="" type="checkbox"> Summing all elements by column</li></ul><pre><code class="java">for (int column = 0; column &lt; matrix[0].length; column++) &#123;  int total = 0;  for (int row = 0; row &lt; matrix.length; row++)    total += matrix[row][column];  System.out.println(&quot;Sum for column &quot; + column + &quot; is &quot;    + total);&#125;</code></pre><ul><li><input checked="" disabled="" type="checkbox"> Which row has the largest sum</li><li><input checked="" disabled="" type="checkbox"> Finding the smallest index of the largest element</li><li><input checked="" disabled="" type="checkbox"> Random shuffling</li></ul><pre><code class="java">for (int i = 0; i &lt; matrix.length; i++) &#123;  for (int j = 0; j &lt; matrix[i].length; j++) &#123;    int i1 = (int)(Math.random() * matrix.length);    int j1 = (int)(Math.random() * matrix[i].length);    // Swap matrix[i][j] with matrix[i1][j1]    int temp = matrix[i][j];    matrix[i][j] = matrix[i1][j1];    matrix[i1][j1] = temp;  &#125;&#125;</code></pre><h3 id="多维数组-1"><a href="#多维数组-1" class="headerlink" title="多维数组"></a>多维数组</h3><pre><code class="java">double[][][] scores = &#123;  &#123;&#123;7.5, 20.5&#125;, &#123;9.0, 22.5&#125;, &#123;15, 33.5&#125;, &#123;13, 21.5&#125;, &#123;15, 2.5&#125;&#125;,  &#123;&#123;4.5, 21.5&#125;, &#123;9.0, 22.5&#125;, &#123;15, 34.5&#125;, &#123;12, 20.5&#125;, &#123;14, 9.5&#125;&#125;,  &#123;&#123;6.5, 30.5&#125;, &#123;9.4, 10.5&#125;, &#123;11, 33.5&#125;, &#123;11, 23.5&#125;, &#123;10, 2.5&#125;&#125;,  &#123;&#123;6.5, 23.5&#125;, &#123;9.4, 32.5&#125;, &#123;13, 34.5&#125;, &#123;11, 20.5&#125;, &#123;16, 7.5&#125;&#125;,  &#123;&#123;8.5, 26.5&#125;, &#123;9.4, 52.5&#125;, &#123;13, 36.5&#125;, &#123;13, 24.5&#125;, &#123;16, 2.5&#125;&#125;,  &#123;&#123;9.5, 20.5&#125;, &#123;9.4, 42.5&#125;, &#123;13, 31.5&#125;, &#123;12, 20.5&#125;, &#123;16, 6.5&#125;&#125;&#125;;</code></pre>]]></content>
      
      
      <categories>
          
          <category> DataStructure </category>
          
          <category> 线结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>《世界上所有的夜晚》之那段难忘的谈吐</title>
      <link href="essay/c47f3d9a749fd0229277f9e9604e69a2/"/>
      <url>essay/c47f3d9a749fd0229277f9e9604e69a2/</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1622165460883-a7b33b3d-8426-46e7-ade7-e603c065322e.jpeg#align=left&display=inline&height=199&id=uedac2836&margin=%5Bobject%20Object%5D&originHeight=397&originWidth=270&status=done&style=stroke&width=135"></p><p>每本书，总会有那么一段让你记忆难忘。最难忘的是和蒋百嫂酒后那段谈吐，夜半作者打算回旅馆却听见轰隆隆的响声，看见冰柜里的那具尸体之后，很是心酸感动，每个人都有属于自己的夜晚，心灵寄居在此，有的看似洒脱却也痛苦无奈<br>看完这本书，我才渐渐了解迟子建这个作家，不过非常抱歉，在此之前我一直以为迟子建是位男作家····作者真的是一个善于观察的生活记录者，很喜欢那样轻快的语言，迟子建是在我读书时期，让我喜欢上文学的人之一，高中那会，就喜欢屯在书店的书架后面看他写的书，看完之后，心情甚是愉悦~回忆啊<br>每个人都有属于自己的夜晚，每个人都有属于自己的回忆 :-）</p><hr><p>《世界上所有的夜晚》迟子建的一本比较短的小说，这部小说，也是在那期间第一本我一天之内看完的一本小说，很多时候，我总是想起煤矿镇的那个村庄的人，事实上，那都是我们身边的人，也是那本书我内心深深的感知，这世上有很多不幸的人，这世上不止一个夜晚，有无数个人人牵挂的夜晚，这世上又只有一个夜晚，那个独自存在的灵魂的夜晚……</p><hr><p>想想以前的一些悠闲经历， 上课偷偷式看小说 、备考期间，自我欺骗/麻痹式看小说 、上课老喜欢在全班同学都认真听讲而我坐在后排靠窗角落看小说<img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1622165717851-7436873d-a34b-48b7-a8fa-d32e45eb7e4b.jpeg#align=left&display=inline&height=50&id=HxzJ4&margin=%5Bobject%20Object%5D&originHeight=50&originWidth=51&status=done&style=none&width=51"></p><p>然而现在， 快节奏的日常似乎霸占生活的全部 ，身边有这么优秀的环境，我忘却了曾经的那一丝快感……</p><p>其实，生活本可以有一丝轻快，不用太过追求什么</p>]]></content>
      
      
      <categories>
          
          <category> 一书一世界 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CSS引入和特性</title>
      <link href="blog/740ee349dcf540d24c44fd240dbbc87f/"/>
      <url>blog/740ee349dcf540d24c44fd240dbbc87f/</url>
      
        <content type="html"><![CDATA[<div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">CSS(Cascading Style Sheets)  ，通常称为CSS样式表或层叠样式表（级联样式表）</div><h2 id="CSS-引入"><a href="#CSS-引入" class="headerlink" title="CSS 引入"></a>CSS 引入</h2><h3 id="行内式（内联样式）"><a href="#行内式（内联样式）" class="headerlink" title="行内式（内联样式）"></a>行内式（内联样式）</h3><pre><code class="html">&lt;div style=&quot;color: red; font-size: 12px;&quot;&gt;文字&lt;/div&gt;</code></pre><ul><li>style 其实就是标签的属性</li><li><strong>样式属性和值中间是<code>:</code></strong></li><li><strong>多组属性值之间用<code>;</code>隔开</strong></li></ul><h3 id="内部样式表（内嵌样式表）"><a href="#内部样式表（内嵌样式表）" class="headerlink" title="内部样式表（内嵌样式表）"></a>内部样式表（内嵌样式表）</h3><pre><code class="css">&lt;style&gt;     div &#123;         color: red;         font-size: 12px;     &#125;&lt;/style&gt;</code></pre><ul><li>style 标签一般位于 head 标签中，理论可以放在 HTML 文档的任何地方。</li><li>type=”text/css”   在 html5 中可以省略。</li><li>只能控制当前的页面</li></ul><h3 id="外部样式表（外链式）"><a href="#外部样式表（外链式）" class="headerlink" title="外部样式表（外链式）"></a>外部样式表（外链式）</h3><pre><code class="html">&lt;head&gt;  &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;css文件路径&quot; /&gt;&lt;/head&gt;</code></pre><ul><li>link 是个单标签</li><li>link 标签需要放在 head 头部标签中，并且指定 link 标签的三个属性<table><thead><tr><th>属性</th><th align="left">作用</th></tr></thead><tbody><tr><td>rel</td><td align="left">定义当前文档与被链接文档之间的关系，在这里需要指定为“stylesheet”，表示被链接的文档是一个样式表文件。</td></tr><tr><td>type</td><td align="left">定义所链接文档的类型，在这里需要指定为“text/CSS”，表示链接的外部文件为 CSS 样式表。我们都可以省略</td></tr><tr><td>href</td><td align="left">定义所链接外部样式表文件的 URL，可以是相对路径，也可以是绝对路径。</td></tr></tbody></table></li></ul><h2 id="CSS-三大特性"><a href="#CSS-三大特性" class="headerlink" title="CSS 三大特性"></a>CSS 三大特性</h2><h3 id="层叠性"><a href="#层叠性" class="headerlink" title="层叠性"></a>层叠性</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611551959470-031c2889-70e9-4982-96f9-9c144e5051b2.png#align=left&display=inline&height=262&margin=%5Bobject%20Object%5D&name=image.png&originHeight=523&originWidth=1206&size=99603&status=done&style=stroke&width=603" alt="image.png"></p><ul><li><p>概念：<br>所谓层叠性是指多种 CSS 样式的叠加。<br>是浏览器处理冲突的一个能力,如果一个属性通过两个相同选择器设置到同一个元素上，那么这个时候一个属性就会将另一个属性层叠掉</p></li><li><p>原则：</p><ul><li>样式冲突，遵循的原则是<strong>就近原则。</strong> 那个样式离着结构近，就执行那个样式。</li><li>样式不冲突，不会层叠</li></ul></li></ul><pre><code>CSS层叠性最后的执行口诀：  长江后浪推前浪，前浪死在沙滩上。</code></pre><h3 id="继承性"><a href="#继承性" class="headerlink" title="继承性"></a>继承性</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611551970799-56adba75-8847-4db1-a411-148ff22f57ac.png#align=left&display=inline&height=264&margin=%5Bobject%20Object%5D&name=image.png&originHeight=528&originWidth=1196&size=98408&status=done&style=stroke&width=598" alt="image.png"></p><ul><li>概念：<br>子标签会继承父标签的某些样式，如文本颜色和字号。<br>想要设置一个可继承的属性，只需将它应用于父元素即可。</li></ul><p>简单的理解就是：   子承父业。</p><ul><li><strong>注意</strong>：<ul><li>恰当地使用继承可以简化代码，降低 CSS 样式的复杂性。比如有很多子级孩子都需要某个样式，可以给父级指定一个，这些孩子继承过来就好了。</li><li>子元素可以继承父元素的样式（<strong>text-，font-，line-这些元素开头的可以继承，以及 color 属性</strong>）</li></ul></li></ul><h3 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611551983122-6a6e2212-c740-40f6-bfa1-3b66ae0a9c46.png#align=left&display=inline&height=246&margin=%5Bobject%20Object%5D&name=image.png&originHeight=491&originWidth=1198&size=91467&status=done&style=none&width=599" alt="image.png"></p><ul><li>概念：定义 CSS 样式时，经常出现两个或更多规则应用在同一元素上，此时，<ul><li>选择器相同，则执行层叠性</li><li>选择器不同，就会出现优先级的问题。<div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">权重计算公式</div>关于CSS权重，我们需要一套计算公式来去计算，这个就是 CSS Specificity（特殊性）</li></ul></li></ul><table><thead><tr><th>标签选择器</th><th>计算权重公式</th></tr></thead><tbody><tr><td>继承或者 *</td><td>0,0,0,0</td></tr><tr><td>每个元素（标签选择器）</td><td>0,0,0,1</td></tr><tr><td>每个类，伪类</td><td>0,0,1,0</td></tr><tr><td>每个 ID</td><td>0,1,0,0</td></tr><tr><td>每个行内样式 style=””</td><td>1,0,0,0</td></tr><tr><td>每个!important 重要的</td><td>∞ 无穷大</td></tr></tbody></table><ul><li><p>值从左到右，左面的最大，一级大于一级，数位之间没有进制，级别之间不可超越。</p></li><li><p>关于 CSS 权重，我们需要一套计算公式来去计算，这个就是 CSS Specificity（特殊性）</p></li><li><p>div {<br>color: pink!important;<br>}</p><div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">权重叠加</div>我们经常用交集选择器，后代选择器等，是有多个基础选择器组合而成，那么此时，就会出现权重叠加。就是一个简单的加法计算</li><li><p>div ul  li   ——&gt;      0,0,0,3</p></li><li><p>.nav ul li   ——&gt;      0,0,1,2</p></li><li><p>a:hover      —–—&gt;   0,0,1,1</p></li><li><p>.nav a       ——&gt;      0,0,1,1</p></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2021/jpg/1484158/1611549555499-d752a9dc-33fc-4649-95b6-58b25d08ef80.jpg#align=left&display=inline&height=31&margin=%5Bobject%20Object%5D&originHeight=31&originWidth=31&status=done&style=none&width=31"> 注意：</p><ol><li>数位之间没有进制 比如说： 0,0,0,5 + 0,0,0,5 =0,0,0,10 而不是 0,0, 1, 0， 所以不会存在 10 个 div 能赶上一个类选择器的情况。<div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">继承的权重是0</div>这个不难，但是忽略很容易绕晕。其实，我们修改样式，一定要看该标签有没有被选中。1） 如果选中了，那么以上面的公式来计权重。谁大听谁的。2） 如果没有选中，那么权重是0，因为继承的权重为0.</li></ol>]]></content>
      
      
      <categories>
          
          <category> Language </category>
          
          <category> CSS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>至暗之路</title>
      <link href="essay/ew2l6r/"/>
      <url>essay/ew2l6r/</url>
      
        <content type="html"><![CDATA[<p>一个人如若是他很强，一或者说在别人眼中看起来很强，那么他一定是有着他自己的一段至暗时光。</p><p>我们总是不喜欢往回看。往回看有两种情况，一种是你的过往是让你愉悦的，让你充满开心快乐，还有一种就是让你哽咽，不想多言，或是说，那段时光虽然让你收获很多，但是它并非是你很想经历的。至暗时光的确可以让自己变得更强，但是凡事你能得到就必然有舍弃，我觉得那段至暗时光让我舍弃的就是与他人的人情味。</p><p>我的确很恨，恨为什么是我经受那种环境，一个本不是第一环境的人，却也落得个第一环境的人，就像是内壁中有遗留下的异世界的人一样，很愤懑，却也不得抒情。我觉得这可能就是古时候的诗人那般抒情吧，失意，惆怅，但唯一与身边人不同的就是，不会迷茫，内心却是异常的笃定，于是乎他开始变得与周围的人都不太一样，他开始学会跳出内壁，内壁下的人们就仿佛是用来衬托这个本不该落下的内壁之外的人，但，就像是那片沙漠尽头的那般高墙一般，他的落下，是因为他在他那个文明下触及到他不应该触及的所谓的“法律”。</p><p>“什么都不舍弃，就什么改变不了”<br>——爱尔敏</p><p>于是乎，他开始讨厌内壁下的种种，他觉得，在他那个文明，这不应该是他应该所接触的。他觉得，他不是内壁下的人们，他应该回到他所觉得的那个高级文明。所以，他的那种与世人抵触，让他踏上至暗时光，在此有必要提醒一点，至暗，不一定是贬义词，更多的时候，它是一种中性词。</p><p>“错的不是我，而是这个世界”<br>——金木研</p>]]></content>
      
      
      <categories>
          
          <category> 异世界 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>🔒个人网站搭建方案</title>
      <link href="blog/xx0b72/"/>
      <url>blog/xx0b72/</url>
      
        <content type="html"><![CDATA[<p>这是加密文章！</p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>GitHub Actions+语雀+serverless云函数实现hexo自动化部署</title>
      <link href="blog/vyeuk3/"/>
      <url>blog/vyeuk3/</url>
      
        <content type="html"><![CDATA[<h2 id="一、整体思路"><a href="#一、整体思路" class="headerlink" title="一、整体思路"></a>一、整体思路</h2><p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1610002276789-6c7bf0a3-f39b-4a27-a493-01c2e579ec87.jpeg#height=368&id=Rnqi1&margin=%5Bobject%20Object%5D&name=yuque_diagram.jpg&originHeight=368&originWidth=2062&originalType=binary%E2%88%B6=1&size=71238&status=done&style=stroke&width=2062" alt="yuque_diagram.jpg"><br>【1】利用<code>npm</code>插件<code>yuque-hexo</code>将语雀云端的文章同步到博客源码<code>source/_posts/blog</code>文件夹下。</p><p>【2】再利用<code>GitHub Actions</code>自动化部署将 GitHub 私有仓库（<code>website</code>）的博客源文件编译成静态博客文件并部署 push 到静态博客仓库（<code>wztlink1013.github.io</code>）下。</p><p>但是以上【1】【2】两种方式并不能解决语雀一发布文章就触发 GitHub 源码仓库的<code>GitHub Actions</code></p><p>【3】所以需要中间<code>TencentCloud</code>云函数/<code>Aliyun</code>云函数，云函数的作用就是，语雀文章一经正式发布就触发云函数，从而云函数再触发 GitHub 私有的源码仓库下的<code>GitHub Actions</code>达到编译静态博客的效果。</p><h2 id="二、网站源文件配置"><a href="#二、网站源文件配置" class="headerlink" title="二、网站源文件配置"></a>二、网站源文件配置</h2><blockquote><p><a href="https://github.com/x-cold/yuque-hexo">官方仓库</a></p></blockquote><h3 id="yuque-hexo-插件"><a href="#yuque-hexo-插件" class="headerlink" title="yuque-hexo 插件"></a>yuque-hexo 插件</h3><blockquote><p>【1】在开发环境当中下载语雀插件（全局安装）</p></blockquote><pre><code class="bash">npm i -g yuque-hexo</code></pre><blockquote><p>【2】相关 hexo 命令</p></blockquote><pre><code class="bash">yuque-hexo clean # 清缓存删除yuque文件夹 删除yuque.json文件(更新之后的插件不删除yuque.json)yuque-hexo sync # 从云端拉取到本地DEBUG=yuque-hexo.* yuque-hexo sync # Debug</code></pre><blockquote><p>【3】特别需要注意的是：开发环境语雀 Token 变量的传入</p></blockquote><p>语雀为了防止用户恶意多次拉取数据，出于对知识库安全性的调整，使用第三方 API 访问知识库，需要传入环境变量 <code>YUQUE_TOKEN</code>，如果是本地使用建议使用环境变量，也可以是终端的方式输入。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1594788656022-fb5e7959-fa2a-4418-911b-773e3674afb8.png#height=145&id=vrXpA&margin=%5Bobject%20Object%5D&name=image.png&originHeight=290&originWidth=968&originalType=binary%E2%88%B6=1&size=24274&status=done&style=shadow&width=484" alt="image.png"><br>如果是在<code>GitHub Actions</code>里面的环境执行<code>yuque-hexo sync</code>命令的时候，通过如下命令传入语雀的<code>token</code></p><pre><code class="yaml">YUQUE_TOKEN=$&#123;&#123; secrets.YUQUE_TOKEN &#125;&#125; yuque-hexo sync</code></pre><blockquote><p>【4】最后的配置样式</p></blockquote><pre><code class="json">  &quot;yuqueConfig&quot;: &#123;    &quot;baseUrl&quot;: &quot;https://www.yuque.com/api/v2&quot;,    &quot;login&quot;: &quot;nicaibandishuqing&quot;,    &quot;repo&quot;: &quot;blog&quot;,    &quot;postPath&quot;: &quot;src/_posts/blog&quot;,    &quot;cachePath&quot;: &quot;yuque.json&quot;,    &quot;mdNameFormat&quot;: &quot;slug&quot;,    &quot;onlyPublished&quot;: false,    &quot;onlyPublic&quot;: true,    &quot;adapter&quot;: &quot;markdown&quot;  &#125;,  &quot;scripts&quot;: &#123;    &quot;clean&quot;: &quot;hexo clean&quot;,    &quot;build&quot;: &quot;hexo generate&quot;,    &quot;server&quot;: &quot;hexo server&quot;,    &quot;deploy&quot;: &quot;hexo deploy&quot;  &#125;</code></pre><p>更详细使用参考官方<a href="https://github.com/x-cold/yuque-hexo">官方仓库</a>。</p><h3 id="配置-GitHub-Actions-文件"><a href="#配置-GitHub-Actions-文件" class="headerlink" title="配置 GitHub Actions 文件"></a>配置 GitHub Actions 文件</h3><p>在博客源文件夹下新建如下 GitHub Actions 文件<br><code>.github/workflows/main.yml</code></p><blockquote><p>文件内容配置如下</p></blockquote><pre><code class="yaml"># workflow namename: website to wztlink1013.github.io CI/CDon: [repository_dispatch, watch]jobs:  Deploy-Pages:    name: website to wztlink1013.github.io    runs-on: ubuntu-latest    steps:      # check it to your workflow can access it      # from: https://github.com/actions/checkout      - name: Checkout Repository master branch        uses: actions/checkout@main      # from: https://github.com/actions/setup-node      - name: Setup Node.js 10.x        uses: actions/setup-node@main        with:          node-version: &quot;10.x&quot;      - name: add Git infomations        run: |          git config --global user.name &#39;$&#123;&#123;secrets.GIT_NAME&#125;&#125;&#39;           git config --global user.email &#39;$&#123;&#123;secrets.GIT_EMAIL&#125;&#125;&#39;      - name: submit commit infomations        run: |          git log --pretty=format:&quot;%s from Github Actions at `date +&quot;%Y-%m-%d %H:%M:%S&quot;`&quot; --date=short -n 1  &gt; commit-message.log      - name: npm istall hexo-cli、yuque-hexo、*        env:          YUQUE_TOKEN: $&#123;&#123; secrets.YUQUE_TOKEN &#125;&#125;        run: |          npm install hexo-cli -g          npm i -g yuque-hexo-haisawa          npm i -g yuque-hexo-w-dsal          npm i -g npm-wzutao          npm install      - name: generate articles        run: |          hexo clean          yuque-hexo-haisawa clean          yuque-hexo-w-dsal clean          npm-wzutao clean          YUQUE_TOKEN=$&#123;&#123; secrets.YUQUE_TOKEN &#125;&#125; yuque-hexo-haisawa sync          YUQUE_TOKEN=$&#123;&#123; secrets.YUQUE_TOKEN &#125;&#125; npm-wzutao sync          YUQUE_TOKEN=$&#123;&#123; secrets.YUQUE_TOKEN &#125;&#125; yuque-hexo-w-dsal sync          cd ./src/_posts/          mv ./dsal/* ./blog/          cd ../../          hexo generate      - name: push wztlink1013.github.io repository        env:          Github_Pages: github.com/wztlink1013/wztlink1013.github.io          Github_Token: $&#123;&#123; secrets.token_GithubAPI &#125;&#125;        run: |          git clone https://$&#123;Github_Token&#125;@$&#123;Github_Pages&#125; .github_pages          mv .github_pages/.git/ ./build/          cd ./build/          git add .          git commit -F ../commit-message.log          git push --force --quiet &quot;https://$&#123;Github_Token&#125;@$&#123;Github_Pages&#125;&quot; master:master</code></pre><blockquote><p><del>有个尚未清楚并解决的问题：语雀 Token 的值，通过 GitHub 仓库密匙的方式传不进去，只能以“裸露的方式传进去”</del><br>已解决：通过在仓库设置 secret，再用<code>$&#123;&#123; secrets.YUQUE_TOKEN &#125;&#125;</code>方式引入即可。</p></blockquote><h2 id="三、Serverless-云函数配置"><a href="#三、Serverless-云函数配置" class="headerlink" title="三、Serverless 云函数配置"></a>三、Serverless 云函数配置</h2><h3 id="腾讯云-serverless"><a href="#腾讯云-serverless" class="headerlink" title="腾讯云 serverless"></a>腾讯云 serverless</h3><div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">1. python2.7的配置</div>```python# -*- coding: utf8 -*-import requests<p>def main_handler(event, context):<br>r = requests.post(“<a href="https://api.github.com/repos/wztlink1013/website/dispatches&quot;">https://api.github.com/repos/wztlink1013/website/dispatches&quot;</a>,<br>json={‘event_type’: “run-it”},<br>headers = {“User-Agent”:’curl/7.52.1’,<br>‘Content-Type’: ‘application/json’,<br>‘Accept’: ‘application/vnd.github.everest-preview+json’,<br>‘Authorization’: ‘token <strong><strong>***</strong></strong>‘})</p><pre><code>if r.status_code == 204:    return &quot;This&#39;s OK!&quot;else:    return r.status_code</code></pre><pre><code>&lt;div style=&quot;background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;&quot;&gt;2. 触发器的设置&lt;/div&gt;![image.png](https://cdn.nlark.com/yuque/0/2020/png/1484158/1594789179624-938bb8c2-ac15-4ece-a5f1-001563e4f08b.png#height=282&amp;id=zNnuw&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=583&amp;originWidth=1250&amp;originalType=binary∶=1&amp;size=50598&amp;status=done&amp;style=none&amp;width=605)### 阿里云serverless记录一下Hexo自动化部署过程中阿里云平台的原函数配置的python代码&lt;div style=&quot;background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;&quot;&gt;- python2.7&lt;/div&gt;```python# -*- coding: utf-8 -*-import loggingimport requests# To enable the initializer feature (https://help.aliyun.com/document_detail/158208.html)# please implement the initializer function as below：# def initializer(context):#   logger = logging.getLogger()#   logger.info(&#39;initializing&#39;)def handler(event, context):#   logger = logging.getLogger()#   logger.info(&#39;hello world&#39;)#   return &#39;hello world&#39;    r = requests.post(&quot;https://api.github.com/repos/wztlink1013/blog-source/dispatches&quot;,    json=&#123;&#39;event_type&#39;: &quot;run-it&quot;&#125;,    headers = &#123;&quot;User-Agent&quot;:&#39;curl/7.52.1&#39;,              &#39;Content-Type&#39;: &#39;application/json&#39;,              &#39;Accept&#39;: &#39;application/vnd.github.everest-preview+json&#39;,              &#39;Authorization&#39;: &#39;token f43964836a33dce4385bc303c8c20adc1bd52194&#39;&#125;)    if r.status_code == 204:        return &quot;This&#39;s OK!&quot;    else:        return r.status_code# # -*- coding: utf8 -*-# import requests# def main_handler(event, context):#     r = requests.post(&quot;https://api.github.com/repos/wztlink1013/blog-source/dispatches&quot;,#     json=&#123;&#39;event_type&#39;: &quot;run-it&quot;&#125;,#     headers = &#123;&quot;User-Agent&quot;:&#39;curl/7.52.1&#39;,#               &#39;Content-Type&#39;: &#39;application/json&#39;,#               &#39;Accept&#39;: &#39;application/vnd.github.everest-preview+json&#39;,#               &#39;Authorization&#39;: &#39;token 144a87bde62ff1cf30dc18880787917bc7865417&#39;&#125;)#     if r.status_code == 204:#         return &quot;This&#39;s OK!&quot;#     else:#         return r.status_code</code></pre><div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">- python3</div>```python# -*- coding: utf-8 -*-<p>import logging<br>import requests<br>OK = b’ok\n’</p><p>def handler(environ, start_response):<br>status = ‘200 OK’<br>response_headers = [(‘Content-type’, ‘text/plain’)]<br>sync_yuque()<br>start_response(status, response_headers)<br>return [OK]</p><p>def sync_yuque():<br>requests.post(“<a href="https://api.github.com/repos/wztlink1013/Blog3.0/dispatches&quot;">https://api.github.com/repos/wztlink1013/Blog3.0/dispatches&quot;</a>,<br>json={‘event_type’: “run-it”},<br>headers={“User-Agent”:’curl/7.52.1’,<br>‘Content-Type’: ‘application/json’,<br>‘Accept’: ‘application/vnd.github.everest-preview+json’,<br>‘Authorization’: ‘token f43964836a33dce4385bc303c8c20adc1bd52194’})</p><pre><code>&lt;div style=&quot;background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;&quot;&gt;- 触发器配置&lt;/div&gt;![image.png](https://cdn.nlark.com/yuque/0/2020/png/1484158/1608448464729-f5e542f2-0a6e-4817-bd93-b8cf6f67b8fa.png#height=95&amp;id=V2THU&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=190&amp;originWidth=1547&amp;originalType=binary∶=1&amp;size=28534&amp;status=done&amp;style=stroke&amp;width=773.5)![image.png](https://cdn.nlark.com/yuque/0/2020/png/1484158/1608448488925-30baf354-0b23-490c-8b05-4b054ca1b868.png#height=399&amp;id=vXRT1&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=798&amp;originWidth=1045&amp;originalType=binary∶=1&amp;size=52872&amp;status=done&amp;style=stroke&amp;width=522.5)### Vercel的serverless- [https://github.com/wztlink1013/yuque-github-api](https://github.com/wztlink1013/yuque-github-api)## 四、语雀云端的配置在所需要拉取的仓库中webhook中填入云函数所留下的那串网址，勾选所需要触发的选项即可。![image.png](https://cdn.nlark.com/yuque/0/2021/png/1484158/1610002554569-c1487bca-1b0f-4334-86a9-7ac062cf5a44.png#height=291&amp;id=YSKQg&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=581&amp;originWidth=1084&amp;originalType=binary∶=1&amp;size=52514&amp;status=done&amp;style=stroke&amp;width=542)## 参考- [yuque-hexo开发仓库](https://github.com/x-cold/yuque-hexo)- [Hexo：语雀云端写作，Github Actions持续集成](https://www.zhwei.cn/hexo-github-actions-yuque/)- [Hexo 博客终极玩法：云端写作，自动部署](https://segmentfault.com/a/1190000017797561)- [阿里云云函数使用用户](https://www.xiayinchang.top/post/b2362878.html)- [[原创]自动同步语雀文档到你的hexo博客](https://bbs.pediy.com/thread-260866.htm)- [https://github.com/Zfour/yuque_vercel_webhook_api](https://github.com/Zfour/yuque_vercel_webhook_api)</code></pre>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>“什么都无法舍弃，什么也改变不了”</title>
      <link href="essay/vattip/"/>
      <url>essay/vattip/</url>
      
        <content type="html"><![CDATA[<div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">什么也无法舍弃的人，也无法改变任何事情吧。——爱尔敏·阿诺德</div><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1620265214393-3e90a086-8121-4c96-8f09-6d9bd1406fd2.png#height=216&id=BxjYe&margin=%5Bobject%20Object%5D&name=image.png&originHeight=432&originWidth=767&originalType=binary&size=630773&status=done&style=none&width=383.5" alt="image.png"></p><p><code>2021.04.28</code></p><p>突然对舍弃有了一个新的见解，</p><p>舍弃，很多时候，不仅仅是执行者主观的做法，还有一种就是，被动的舍弃…</p><p>因为你注定要成为什么样的人，所以注定你必须要舍弃某些东西，那么这个时候，对这样的选择该怎么办呢？<br><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1619589532108-e98a4fc8-907a-40c4-9e74-2eb76b34d311.jpeg#height=315&id=DNXMj&margin=%5Bobject%20Object%5D&name=62885377_p0.jpg&originHeight=905&originWidth=1280&originalType=binary&size=880880&status=done&style=none&width=445" alt="62885377_p0.jpg"></p><p><code>2021.04.29</code></p><p>什么是得到呢？</p><p>也许，现在的你没得到，不代表今后的你不会得到，不同的时段，我们所在乎的还会一样吗？</p>]]></content>
      
      
      <categories>
          
          <category> 异世界 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>快节奏下的人们</title>
      <link href="essay/gm1to9/"/>
      <url>essay/gm1to9/</url>
      
        <content type="html"><![CDATA[<p>如今的抒情，早已不知道为何变得如此奢侈</p><p>我们更多的是用心感受远行，而不是，来到一个地方，拍个照，发朋友圈，嗯，我来过，而已……</p><p>什么时候，抒情也变得如此廉价</p><p>写东西更多的是一种抒发内心想法，简单且纯粹，就像是记录下来的，就是我的内心真实写照，</p><p>微商—自媒体—短视频，人们变得不仅是快节奏，更是一种焦虑，为什么会焦虑呢？因为这个社会太快了……</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Python-qrcode和myqr花式二维码</title>
      <link href="blog/ro3p67/"/>
      <url>blog/ro3p67/</url>
      
        <content type="html"><![CDATA[<h2 id="一、官方文档"><a href="#一、官方文档" class="headerlink" title="一、官方文档"></a>一、官方文档</h2><p><a href="https://pypi.org/project/qrcode/">https://pypi.org/project/qrcode/</a></p><p><a href="https://pypi.org/project/MyQR/">https://pypi.org/project/MyQR/</a></p><h2 id="二、下载包"><a href="#二、下载包" class="headerlink" title="二、下载包"></a>二、下载包</h2><p>pip install qrcode  #方法多，体量小</p><p>pip install myqr    #操作简单，功能强大</p><h2 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h2><h3 id="qrcode-一行字二维码"><a href="#qrcode-一行字二维码" class="headerlink" title="qrcode 一行字二维码"></a>qrcode 一行字二维码</h3><pre><code class="python">import qrcodeqrcode.make(&quot;不睡觉干嘛呢&quot;).get_image().show()   #设置URL必须添加http://</code></pre><h3 id="qrcode-一行字二维码-1"><a href="#qrcode-一行字二维码-1" class="headerlink" title="qrcode 一行字二维码"></a>qrcode 一行字二维码</h3><pre><code class="python">import qrcodetext = input(&quot;输入文字或URL：&quot;)img =qrcode.make(text)img.save()                            #保存图片至本地目录，可以设定路径img.show()</code></pre><h3 id="qrcode-生成-logo-二维码"><a href="#qrcode-生成-logo-二维码" class="headerlink" title="qrcode 生成 logo 二维码"></a>qrcode 生成 logo 二维码</h3><pre><code class="python">from PIL import Imageimport qrcode,osdef create_qrcode(url,qrcodename):    qr = qrcode.QRCode(        version=1,  # 设置容错率为最高        error_correction=qrcode.ERROR_CORRECT_H, # 用于控制二维码的错误纠正程度        box_size=8, # 控制二维码中每个格子的像素数，默认为10        border=1, # 二维码四周留白，包含的格子数，默认为4        #image_factory=None,  保存在模块根目录的image文件夹下        #mask_pattern=None    )    qr.add_data(url) # QRCode.add_data(data)函数添加数据    qr.make(fit=True)  # QRCode.make(fit=True)函数生成图片    img = qr.make_image()    img = img.convert(&quot;RGBA&quot;) # 二维码设为彩色    logo = Image.open(&#39;xx.jpg&#39;) # 传gif生成的二维码也是没有动态效果的    w , h = img.size    logo_w , logo_h = logo.size    factor = 4   # 默认logo最大设为图片的四分之一    s_w = int(w / factor)    s_h = int(h / factor)    if logo_w &gt; s_w or logo_h &gt; s_h:        logo_w = s_w        logo_h = s_h    logo = logo.resize((logo_w, logo_h), Image.ANTIALIAS)    l_w = int((w - logo_w) / 2)    l_h = int((h - logo_h) / 2)    logo = logo.convert(&quot;RGBA&quot;)    img.paste(logo, (l_w, l_h), logo)    img.show()    img.save(os.getcwd()+&#39;/&#39; + qrcodename + &#39;.png&#39;, quality=100)</code></pre><h3 id="myqr-动态二维码"><a href="#myqr-动态二维码" class="headerlink" title="myqr 动态二维码"></a>myqr 动态二维码</h3><pre><code>相关参数：    words：二维码内容，链接或者句子    version：二维码大小，范围为[1,40]    level：二维码纠错级别，范围为&#123;L,M,Q,H&#125;，H为最高级，默认。    picture：自定义二维码背景图，支持格式为 .jpg，.png，.bmp，.gif，默认为黑白色    colorized：二维码背景颜色，默认为 False，即黑白色    contrast：对比度，值越高对比度越高，默认为 1.0    brightness：亮度，值越高亮度越高，默认为 1.0，值常和对比度相同    save_name：二维码名称，默认为 qrcode.png    save_dir：二维码路径，默认为程序工作路径</code></pre><pre><code class="python"># 调用库from MyQR import myqr# 函数部分myqr.run(    # 网址    words=&#39;https://wztlink1013.com&#39;,    # 控制边长，范围是1到40，数字越大边长越大，默认边长是取决于你输入的信息的长度和使用的纠错等级    version=5,    # 控制纠错水平，范围是L、M、Q、H，从左到右依次升高    level=&#39;H&#39;,    # 将QR二维码图像与一张同目录下的图片相结合，此处设置该图片，可以是gif    picture=&#39;./input/girl.gif&#39;,    # 默认是黑白(False)，可以选择彩色(True)    colorized=True,    # 调节图片的对比度，1.0 表示原始图片，更小的值表示更低对比度，更大反之。默认为1.0。    contrast=1.0,    # 调节图片的亮度，用法与contrast相同    brightness=1.0,    # 输出文件名，格式可以是jpg，png，bmp，gif    save_name=&#39;girl.gif&#39;,    save_dir=&#39;./output&#39;)</code></pre>]]></content>
      
      
      <categories>
          
          <category> Language </category>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> qrcode </tag>
            
            <tag> myqr </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>时间格式UTC、GMT、GST</title>
      <link href="blog/delag2/"/>
      <url>blog/delag2/</url>
      
        <content type="html"><![CDATA[<h2 id="一、三者区别与关系"><a href="#一、三者区别与关系" class="headerlink" title="一、三者区别与关系"></a>一、三者区别与关系</h2><h3 id="UTC：世界标准时间"><a href="#UTC：世界标准时间" class="headerlink" title="UTC：世界标准时间"></a><strong>UTC：世界标准时间</strong></h3><p>协调世界时（英：Coordinated Universal Time ，法：Temps Universel Coordonné），又称世界统一时间，世界标准时间，国际协调时间。英文（CUT）和法文（TUC）的缩写不同，作为妥协，简称 UTC。</p><h3 id="GMT：格林尼治时间"><a href="#GMT：格林尼治时间" class="headerlink" title="GMT：格林尼治时间"></a><strong>GMT：格林尼治时间</strong></h3><p>世界时 UT   即格林尼治时间，格林尼治所在地的标准时间。以地球自转为基础的时间计量系统。地球自转的角度可用地方子午线相对于地球上的基本参考点的运动来度量。为了测量地球自转，人们在地球上选取了两个基本参考点：春分点（见分至点）和平太阳，由此确定的时间分别称为恒星时和平太阳时。</p><h3 id="GST：北京时间"><a href="#GST：北京时间" class="headerlink" title="GST：北京时间"></a><strong>GST：北京时间</strong></h3><p>在数据库中存放，或者给用户看的时间都是 GST 时间</p><h3 id="UTC-和-GST"><a href="#UTC-和-GST" class="headerlink" title="UTC 和 GST"></a><strong>UTC 和 GST</strong></h3><p>中国北京市的时间比 UTC<strong>早</strong> 8 小时</p><h2 id="二、UTC-与-GST-之间的转换"><a href="#二、UTC-与-GST-之间的转换" class="headerlink" title="二、UTC 与 GST 之间的转换"></a><strong>二、UTC 与 GST 之间的转换</strong></h2><h3 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h3><blockquote><p>2020-05-23T01:12:19.602Z</p></blockquote><ul><li>T：他表示后面跟的时间</li><li>Z：表示 UTC 统一时间</li><li>602：表示毫秒，如果为 6020，最后得到的时间，秒会增加 1 秒。000Z 意思就是 0 毫秒  utc 统一时间</li></ul><h3 id="java-实现"><a href="#java-实现" class="headerlink" title="java 实现"></a>java 实现</h3><pre><code class="java">package website;import java.text.*;import java.util.Date;public class UTC_GST &#123;    public static void main(String[] args) throws ParseException &#123;        String date = &quot;2020-05-23T20:12:19.602Z&quot;;        date = date.replace(&quot;Z&quot;, &quot; UTC&quot;);        System.out.println(&quot;输入的UTC格式数据为：&quot;+date);        SimpleDateFormat format = new SimpleDateFormat(&quot;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSS Z&quot;);        Date d = format.parse(date);        System.out.println(&quot;输出的背景格式数据为：&quot;+d);    &#125;&#125;</code></pre><pre><code class="java">输入的UTC格式数据为：2020-05-23T20:12:19.602 UTC输出的背景格式数据为：Sun May 24 04:12:19 CST 2020</code></pre><pre><code class="java">package website;import java.text.SimpleDateFormat;import java.util.Date;public class Format &#123;    public static void main(String[] args) &#123;        Date ss = new Date();        System.out.println(&quot;一般日期输出：&quot; + ss);        System.out.println(&quot;toString日期输出：&quot; + ss.toString());        System.out.println(&quot;时间戳：&quot; + ss.getTime()+&quot;\n&quot;); // getTime返回的是1970年1月1号至今流逝的时间        //Date aw = Calendar.getInstance().getTime();//获得时间的另一种方式，测试效果一样        SimpleDateFormat format0 = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);        String time = format0.format(ss.getTime());//这个就是把时间戳经过处理得到期望格式的时间        System.out.println(&quot;格式化结果0：&quot; + time + &quot;\n&quot;);        SimpleDateFormat format1 = new SimpleDateFormat(&quot;yyyy年MM月dd日 HH时mm分ss秒&quot;);        time = format1.format(ss.getTime());        System.out.println(&quot;格式化结果1：&quot; + time + &quot;\n&quot;);    &#125;&#125;</code></pre><pre><code class="java">一般日期输出：Sat May 23 15:03:25 CST 2020toString日期输出：Sat May 23 15:03:25 CST 2020时间戳：1590217405777格式化结果0：2020-05-23 15:03:25格式化结果1：2020年05月23日 15时03分25秒</code></pre>]]></content>
      
      
      <categories>
          
          <category> DataAnalysis </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Eclipse配置Tomcat创建Servlet</title>
      <link href="blog/ro0lgm/"/>
      <url>blog/ro0lgm/</url>
      
        <content type="html"><![CDATA[<h2 id="一、Eclipse-的下载与安装与使用"><a href="#一、Eclipse-的下载与安装与使用" class="headerlink" title="一、Eclipse 的下载与安装与使用"></a>一、Eclipse 的下载与安装与使用</h2><p><a href="https://www.eclipse.org/downloads/">下载地址</a><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685043597-84e5ed4c-8ad9-496b-997d-fd84136d0a86.png#align=left&display=inline&height=441&margin=%5Bobject%20Object%5D&originHeight=441&originWidth=1817&size=0&status=done&style=none&width=1817"></p><p><strong>注意不要下错版本，不然开发不了 web 环境</strong><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685043623-2432fa56-57df-4b19-bbcf-d7f803db63d3.png#align=left&display=inline&height=758&margin=%5Bobject%20Object%5D&originHeight=758&originWidth=731&size=0&status=done&style=none&width=731"><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685043608-ed00c908-2eb3-4a07-bcd4-c93a58aed494.png#align=left&display=inline&height=763&margin=%5Bobject%20Object%5D&originHeight=763&originWidth=741&size=0&status=done&style=none&width=741"><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685043479-aac1b3ff-f51d-4dce-8313-4e10d2e78bbb.png#align=left&display=inline&height=373&margin=%5Bobject%20Object%5D&originHeight=373&originWidth=762&size=0&status=done&style=none&width=762"></p><h2 id="二、Tomcat-的下载与配置"><a href="#二、Tomcat-的下载与配置" class="headerlink" title="二、Tomcat 的下载与配置"></a>二、Tomcat 的下载与配置</h2><p><a href="https://tomcat.apache.org/download-90.cgi">下载地址</a><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685043712-245a08a5-48cd-4446-ae4b-2ac442f09a44.png#align=left&display=inline&height=729&margin=%5Bobject%20Object%5D&originHeight=729&originWidth=1829&size=0&status=done&style=none&width=1829"><br><strong>一直下一步即可</strong><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685043478-1e8b6460-5b48-424e-8f2d-db26d6bbce42.png#align=left&display=inline&height=485&margin=%5Bobject%20Object%5D&originHeight=485&originWidth=623&size=0&status=done&style=none&width=623"><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685043417-e391db44-2cd9-4c7c-8e6b-1f131ab95769.png#align=left&display=inline&height=283&margin=%5Bobject%20Object%5D&originHeight=283&originWidth=624&size=0&status=done&style=none&width=624"></p><p>打开浏览器 键入 <a href="http://localhost:8080/">http://localhost:8080</a> 进入页面则表示安装成功</p><p>添加环境变量，以下全在系统环境变量下配置<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685043418-feddef63-fcb3-45ce-ac5a-33dd94d77655.png#align=left&display=inline&height=450&margin=%5Bobject%20Object%5D&originHeight=450&originWidth=1089&size=0&status=done&style=none&width=1089"><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685043499-20fddab9-abfb-4d0d-9c6d-956933ee59be.png#align=left&display=inline&height=24&margin=%5Bobject%20Object%5D&originHeight=24&originWidth=704&size=0&status=done&style=none&width=704"></p><pre><code>TOMCAT_HOME：C:\Program Files\Apache Software Foundation\Tomcat 9.0CATALINA_BASE：C:\Program Files\Apache Software Foundation\Tomcat 9.0;CATALINA_HOME：C:\Program Files\Apache Software Foundation\Tomcat 9.0;在classpath当中加入%CATALINA_HOME%\common\lib\servlet-api.jar;在path中加入%CATALINA_HOME%\bin;</code></pre><p>打开浏览器 键入 <a href="http://localhost:8080/">http://localhost:8080</a> 进入页面则表示配置成功</p><h2 id="三、Eclipse-配置-Tomcat"><a href="#三、Eclipse-配置-Tomcat" class="headerlink" title="三、Eclipse 配置 Tomcat"></a>三、Eclipse 配置 Tomcat</h2><p><strong>让 Tomcat 服务器显示在控制台上，将 Web 应用部署到 Tomcat 中</strong></p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685043589-c8022021-1185-4c41-b114-630856e16984.png#align=left&display=inline&height=350&margin=%5Bobject%20Object%5D&originHeight=350&originWidth=1837&size=0&status=done&style=none&width=1837"><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685043661-236843dd-f3ea-433e-b23a-254cc0a41c9b.png#align=left&display=inline&height=958&margin=%5Bobject%20Object%5D&originHeight=958&originWidth=1217&size=0&status=done&style=none&width=1217"><br>点击<code>Window</code> → <code>Show View</code> → <code>Servers</code> 也可以在控制台点击<code>Servers</code><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685043514-556e9b3f-1003-40ff-9066-70349be51101.png#align=left&display=inline&height=790&margin=%5Bobject%20Object%5D&originHeight=790&originWidth=1600&size=0&status=done&style=none&width=1600"><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685043568-aa8984a7-e9e9-4206-a922-f3386127191d.png#align=left&display=inline&height=597&margin=%5Bobject%20Object%5D&originHeight=597&originWidth=597&size=0&status=done&style=none&width=597"><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685043484-23195297-3636-47d7-bf44-ee0151382f87.png#align=left&display=inline&height=766&margin=%5Bobject%20Object%5D&originHeight=766&originWidth=1478&size=0&status=done&style=none&width=1478"><br><strong>双击点击</strong><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685043403-e34d7544-8144-4516-bb7c-53adbabac167.png#align=left&display=inline&height=290&margin=%5Bobject%20Object%5D&originHeight=290&originWidth=1375&size=0&status=done&style=none&width=1375"></p><h2 id="四、Eclipse-使用-Servlet"><a href="#四、Eclipse-使用-Servlet" class="headerlink" title="四、Eclipse 使用 Servlet"></a>四、Eclipse 使用 Servlet</h2><h3 id="创建-web-工程"><a href="#创建-web-工程" class="headerlink" title="创建 web 工程"></a>创建 web 工程</h3><p><strong>创建过程中，要记得勾选生成 web.xml 文件选项</strong><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685043545-0429f9cf-3910-4401-85da-08dd0118e9b1.png#align=left&display=inline&height=277&margin=%5Bobject%20Object%5D&originHeight=277&originWidth=1838&size=0&status=done&style=none&width=1838"><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685043538-d98f2569-40d6-4c3a-8111-9c3d6702052a.png#align=left&display=inline&height=382&margin=%5Bobject%20Object%5D&originHeight=382&originWidth=820&size=0&status=done&style=none&width=820"></p><h3 id="添加相关文件"><a href="#添加相关文件" class="headerlink" title="添加相关文件"></a>添加相关文件</h3><p><strong>添加下面的四个文件</strong><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685043712-c178c180-3c3a-44a2-9518-671033558337.png#align=left&display=inline&height=1015&margin=%5Bobject%20Object%5D&originHeight=1015&originWidth=1831&size=0&status=done&style=none&width=1831"></p><blockquote><p>HelloWordServlet.java</p></blockquote><pre><code class="java">package cn.itcast.firstmyapp.servlet;import java.io.IOException;import java.io.PrintWriter;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;public class HelloWordServlet extends HttpServlet &#123;     protected void doGet(HttpServletRequest req, HttpServletResponse resp)                throws ServletException, IOException &#123;         System.out.println(&quot;接受了客户端的请求----------------------------------------------------&quot;);         // 设置响应类型:            resp.setContentType(&quot;text/html&quot;);            // 获取输出流:            PrintWriter pw = resp.getWriter();            // 写入响应:            pw.write(&quot;&lt;h1&gt;Hello, world!&lt;/h1&gt;&quot;);            // 最后不要忘记flush强制输出:            pw.flush();        &#125;&#125;</code></pre><blockquote><p>web.xml<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685043517-5459e979-8525-4be9-8dab-d38f0857ef56.png#align=left&display=inline&height=627&margin=%5Bobject%20Object%5D&originHeight=627&originWidth=1178&size=0&status=done&style=none&width=1178"></p></blockquote><h3 id="运行并查看结果"><a href="#运行并查看结果" class="headerlink" title="运行并查看结果"></a>运行并查看结果</h3><p><strong>运行</strong><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685043718-5d90186b-8040-4098-b1d4-bb1f67740382.png#align=left&display=inline&height=761&margin=%5Bobject%20Object%5D&originHeight=761&originWidth=1434&size=0&status=done&style=none&width=1434"><br>然后查看 console 部分<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685043524-efeaf228-713b-43e1-ba15-375060ef20d2.png#align=left&display=inline&height=300&margin=%5Bobject%20Object%5D&originHeight=300&originWidth=1449&size=0&status=done&style=none&width=1449"><br><strong>服务器响应情况</strong></p><blockquote><p>出现下图则说明成功<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685043360-fd5bb570-f56a-429a-ad0e-627646447132.png#align=left&display=inline&height=190&margin=%5Bobject%20Object%5D&originHeight=190&originWidth=1318&size=0&status=done&style=none&width=1318"></p></blockquote><blockquote><p>还可以回到控制台查看请求成功情况<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685043568-b62922c0-c458-4c71-bd9c-800f57b356de.png#align=left&display=inline&height=322&margin=%5Bobject%20Object%5D&originHeight=322&originWidth=1445&size=0&status=done&style=none&width=1445"></p></blockquote><h2 id="五、过程中出现的问题"><a href="#五、过程中出现的问题" class="headerlink" title="五、过程中出现的问题"></a>五、过程中出现的问题</h2><h3 id="IDEA-上的部署"><a href="#IDEA-上的部署" class="headerlink" title="IDEA 上的部署"></a>IDEA 上的部署</h3><p>一开始从 tomcat 部署是完成的，具体参考我的 csdn 一篇小文章<a href="https://blog.csdn.net/ZTlink1013/article/details/104815639">地址</a>。但是在后面使用 Servlet 的时候，不能成功部署，具体原因【图片内容来自<a href="https://blog.csdn.net/HughGilbert/article/details/56424137">链接</a>！！】<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685043902-5708dbdc-79d7-4e16-9e6d-d5571c5de758.png#align=left&display=inline&height=921&margin=%5Bobject%20Object%5D&originHeight=921&originWidth=941&size=0&status=done&style=stroke&width=941"></p><blockquote><p>暂时分析：是和 idea 下的根目录下的某个配置文件的默认配置有关，需要更改相关内容，暂时不折腾了。先记录下，有空再折腾，先学习。还是 eclipse 好配置···</p></blockquote><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="https://blog.csdn.net/weixin_34026276/article/details/93834823?depth_1-utm_source=distribute.pc_relevant.none-task&utm_source=distribute.pc_relevant.none-task">https://blog.csdn.net/weixin_34026276/article/details/93834823?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task</a></li><li><a href="https://blog.csdn.net/qq_38190185/article/details/88198794?depth_1-utm_source=distribute.pc_relevant.none-task&utm_source=distribute.pc_relevant.none-task">https://blog.csdn.net/qq_38190185/article/details/88198794?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task</a></li><li><a href="https://www.yiibai.com/servlet/creating-servlet-in-eclipse-ide.html">直接创建 Servlet</a></li><li>快捷键：<a href="https://www.open-open.com/bbs/view/1320934157953">https://www.open-open.com/bbs/view/1320934157953</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Environment </category>
          
          <category> 环境配置 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>IDEA配置Tomcat</title>
      <link href="blog/fgh5bc/"/>
      <url>blog/fgh5bc/</url>
      
        <content type="html"><![CDATA[<h2 id="一、Tomcat-的下载"><a href="#一、Tomcat-的下载" class="headerlink" title="一、Tomcat 的下载"></a>一、Tomcat 的下载</h2><h3 id="正常下载并安装"><a href="#正常下载并安装" class="headerlink" title="正常下载并安装"></a>正常下载并安装</h3><blockquote><p>！！！在此之前默认读者下载且配置好了 jdk 环境</p></blockquote><ul><li>进入该官网<a href="https://imgconvert.csdnimg.cn/aHR0cDovL3RvbWNhdC5hcGFjaGUub3JnLw?x-oss-process=image/format,png">下载页面</a><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598787914511-a035ba93-0b7a-450b-b391-5d1452435ca7.png#align=left&display=inline&height=238&margin=%5Bobject%20Object%5D&originHeight=952&originWidth=1842&size=0&status=done&style=shadow&width=461"></li><li>下载并解压到自己的相应盘区，再进入下图文件夹检验是否成功<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598787914448-2ef2e1a1-2966-4d35-8bfe-82162aa1588b.png#align=left&display=inline&height=273&margin=%5Bobject%20Object%5D&originHeight=727&originWidth=1147&size=0&status=done&style=shadow&width=431"></li><li>点击第二个框不出现闪退情况则证明成功<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598787914507-87063aec-884a-4180-b124-568478d81bc0.png#align=left&display=inline&height=222&margin=%5Bobject%20Object%5D&originHeight=639&originWidth=1223&size=0&status=done&style=shadow&width=425"></li><li>浏览器进入端口<a href="http://localhost:8080/">http://localhost:8080/</a>上述配置成功则表明成功<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598787914624-248148e3-3f5f-45ca-ad93-c063216a7aff.png#align=left&display=inline&height=240&margin=%5Bobject%20Object%5D&originHeight=1030&originWidth=1838&size=0&status=done&style=shadow&width=429"></li></ul><h3 id="过程中可能会出现的问题"><a href="#过程中可能会出现的问题" class="headerlink" title="过程中可能会出现的问题"></a>过程中可能会出现的问题</h3><ul><li>点击 startup.bat 文件出现闪退<br>电脑中 java jdk 有无（JAVA_HOME）</li><li>端口被占用<br>进入 Tomcat 文件夹下的 conf 文件下的 server.xml 文件，用记事本查找 8080，下面复制一个新的初始端口<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598787914513-8083bc6e-4c6f-436e-b0b0-98d3d70b9dea.png#align=left&display=inline&height=80&margin=%5Bobject%20Object%5D&originHeight=80&originWidth=557&size=0&status=done&style=none&width=557"></li></ul><h2 id="二、IDEA-配置-Tomcat"><a href="#二、IDEA-配置-Tomcat" class="headerlink" title="二、IDEA 配置 Tomcat"></a>二、IDEA 配置 Tomcat</h2><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><ul><li>新建一个项目<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598787914503-6a4bf3f9-0e92-4bd3-bcde-e65af73510b8.png#align=left&display=inline&height=1060&margin=%5Bobject%20Object%5D&originHeight=1060&originWidth=1457&size=0&status=done&style=none&width=1457"></li><li>编写 head/body 待会测试用<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598787914719-36f4cef3-db7c-4bd9-a43a-5c92f0afead2.png#align=left&display=inline&height=1080&margin=%5Bobject%20Object%5D&originHeight=1080&originWidth=1842&size=0&status=done&style=none&width=1842"></li><li>相关配置<br>进入配置页面<img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598787914684-a3f47ea5-50df-450f-935d-f9ec086bc2cb.png#align=left&display=inline&height=1080&margin=%5Bobject%20Object%5D&originHeight=1080&originWidth=1842&size=0&status=done&style=none&width=1842"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598787914511-d1b72498-32cb-4868-8758-34fb3de3e798.png#align=left&display=inline&height=853&margin=%5Bobject%20Object%5D&originHeight=853&originWidth=1343&size=0&status=done&style=none&width=1343"><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598787914585-5e3362d9-db50-4bdb-8640-f3a2f630bbbf.png#align=left&display=inline&height=932&margin=%5Bobject%20Object%5D&originHeight=932&originWidth=1343&size=0&status=done&style=none&width=1343"></li></ul><h3 id="运行测试"><a href="#运行测试" class="headerlink" title="运行测试"></a>运行测试</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598787914608-c71c5263-ae91-472f-b760-cc3fbd78b81c.png#align=left&display=inline&height=1080&margin=%5Bobject%20Object%5D&originHeight=1080&originWidth=1842&size=0&status=done&style=none&width=1842"><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598787914608-14ca2925-9dd2-4cfd-9399-597c08094743.png#align=left&display=inline&height=285&margin=%5Bobject%20Object%5D&originHeight=285&originWidth=1836&size=0&status=done&style=none&width=1836"></p>]]></content>
      
      
      <categories>
          
          <category> Environment </category>
          
          <category> 环境配置 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Eclipse的使用总结</title>
      <link href="blog/at014v/"/>
      <url>blog/at014v/</url>
      
        <content type="html"><![CDATA[<h2 id="一、Eclipse-的下载与安装"><a href="#一、Eclipse-的下载与安装" class="headerlink" title="一、Eclipse 的下载与安装"></a>一、Eclipse 的下载与安装</h2><p><a href="https://www.eclipse.org/downloads/">下载地址</a><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685180944-7ec7ebc3-8c39-44a7-9bec-85fded021a40.png#align=left&display=inline&height=441&margin=%5Bobject%20Object%5D&originHeight=441&originWidth=1817&size=0&status=done&style=none&width=1817"></p><p><strong>注意不要下错版本，不然开发不了 web 环境</strong><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685180923-a106c8c7-aebe-4f0a-bc06-d166bfc8894d.png#align=left&display=inline&height=758&margin=%5Bobject%20Object%5D&originHeight=758&originWidth=731&size=0&status=done&style=none&width=731"><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685180948-16e05303-0d11-454e-8bbd-71a11d7a3ef7.png#align=left&display=inline&height=763&margin=%5Bobject%20Object%5D&originHeight=763&originWidth=741&size=0&status=done&style=none&width=741"><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685180925-0262b0ea-f7af-493b-85a5-d8e7cbd12751.png#align=left&display=inline&height=373&margin=%5Bobject%20Object%5D&originHeight=373&originWidth=762&size=0&status=done&style=none&width=762"></p><h2 id="二、插件"><a href="#二、插件" class="headerlink" title="二、插件"></a>二、插件</h2><blockquote><p>进入：<code>Help Eclipse</code> <code>MarketPlace</code></p></blockquote><ul><li>Plugin1：Waka Time</li></ul><h2 id="三、使用"><a href="#三、使用" class="headerlink" title="三、使用"></a>三、使用</h2><h3 id="样式"><a href="#样式" class="headerlink" title="样式"></a>样式</h3><ul><li>字体设置</li><li>行数显示</li><li>更改工作空间的默认编码</li><li>代码增强显示，在设置中的<code>java</code>中的<code>content Assistant</code>中，将<code>.</code>改为<code>.ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789</code></li></ul><h3 id="导入已存在的项目"><a href="#导入已存在的项目" class="headerlink" title="导入已存在的项目"></a>导入已存在的项目</h3>]]></content>
      
      
      <categories>
          
          <category> Environment </category>
          
          <category> 工具使用 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ANN神经网络</title>
      <link href="blog/apohu8/"/>
      <url>blog/apohu8/</url>
      
        <content type="html"><![CDATA[<h2 id="一、基本结构"><a href="#一、基本结构" class="headerlink" title="一、基本结构"></a>一、基本结构</h2><blockquote><p>神经网络基本结构<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685949882-81dbb96c-eafa-4294-aae3-242fd33fff2b.png#height=324&id=gahgJ&originHeight=324&originWidth=858&originalType=binary%E2%88%B6=1&size=0&status=done&style=none&width=858"> &gt; <img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685950067-4d0671d6-b294-4284-9eff-9409d230e91e.png#height=470&id=agJlv&originHeight=470&originWidth=768&originalType=binary%E2%88%B6=1&size=0&status=done&style=none&width=768"></p></blockquote><blockquote><p>何为深度学习？<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685949953-b8d95ff1-6384-4e59-b3d6-1f8151f08204.png#height=400&id=WSSoJ&originHeight=400&originWidth=842&originalType=binary%E2%88%B6=1&size=0&status=done&style=none&width=842"></p></blockquote><h2 id="二、感知器和激活函数"><a href="#二、感知器和激活函数" class="headerlink" title="二、感知器和激活函数"></a>二、感知器和激活函数</h2><blockquote><p>感知器<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685949922-e9c76c57-f1c5-4ff1-af82-25c35a4005b1.png#height=514&id=eaX9r&originHeight=514&originWidth=802&originalType=binary%E2%88%B6=1&size=0&status=done&style=none&width=802"></p></blockquote><blockquote><p>激活函数（其中 w 和 x 为向量点乘；b 为偏置，w0）<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685949961-18eeecb5-c82e-4f71-a543-9bd0c0f27043.png#height=511&id=LJZ0R&originHeight=511&originWidth=836&originalType=binary%E2%88%B6=1&size=0&status=done&style=none&width=836"></p></blockquote><blockquote><p>激活函数的选择<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685950003-072268a5-122d-4340-85d5-85eeb04236fe.png#height=538&id=DZqH3&originHeight=538&originWidth=861&originalType=binary%E2%88%B6=1&size=0&status=done&style=none&width=861"></p></blockquote><h2 id="三、感知器的训练"><a href="#三、感知器的训练" class="headerlink" title="三、感知器的训练"></a>三、感知器的训练</h2><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685950698-fc03bb22-76e6-4328-9a6b-ee2168250fec.png#height=529&id=jRv0N&originHeight=529&originWidth=872&originalType=binary%E2%88%B6=1&size=0&status=done&style=none&width=872"></p><h2 id="四、简单代码实现"><a href="#四、简单代码实现" class="headerlink" title="四、简单代码实现"></a>四、简单代码实现</h2><pre><code class="python">from functools import reduceclass Perceptron(object):    &#39;&#39;&#39;    构造函数的初始化    &#39;&#39;&#39;    def __init__(self,input_num,activator):        &#39;&#39;&#39;        构造函数的初始化        &#39;&#39;&#39;        self.activator = activator        self.weights = [0.0 for _ in range(input_num)]        self.bias = 0.0    def __str__(self):        &#39;&#39;&#39;        打印学习后的权重值和偏置项        &#39;&#39;&#39;        return &#39;weights\t:%s\nbias\t:%f\n&#39; %(self.weights,self.bias)    def predict(self,input_vec):        &#39;&#39;&#39;        输入向量，输出感知器的计算结果        &#39;&#39;&#39;        return self.activator(            reduce(lambda a,b: a+b,                    list(map(lambda x,w: x*w,                        input_vec,self.weights)                 ),0.0)+self.bias)    def train(self,input_vecs,labels,iteration,rate):        &#39;&#39;&#39;        输入训练数据：一组向量、与每个向量对应的label；以及训练轮数、学习率        &#39;&#39;&#39;        for i in range(iteration):            self._one_iteration(input_vecs,labels,rate)    def _one_iteration(self,input_vecs,labels,rate):        &#39;&#39;&#39;        迭代，把所有的训练数据过一遍        &#39;&#39;&#39;        samples = zip(input_vecs,labels)        for (input_vec,label) in samples:            output = self.predict(input_vec)            self._update_weights(input_vec,output,label,rate)    def _update_weights(self,input_vec,output,label,rate):        &#39;&#39;&#39;        按照感知器规则更新权重        &#39;&#39;&#39;        delta = label - output        self.weights = map(            lambda x, w:w+rate*delta*x,            input_vec,self.weights)        self.weights = list(self.weights)        self.bias += rate*deltadef f(x):    &#39;&#39;&#39;    定义激活函数    &#39;&#39;&#39;    return 1 if x&gt;0 else 0def get_training_dataset():    &#39;&#39;&#39;    训练数据    &#39;&#39;&#39;    input_vecs = [[1,1],[0,0],[1,0],[0,1]]    labels = [1,0,0,0]    return input_vecs,labelsdef train_and_perceptron():    &#39;&#39;&#39;    训练感知器    &#39;&#39;&#39;    p = Perceptron(2,f)    input_vecs,labels = get_training_dataset()    p.train(input_vecs,labels,10,0.1)    return pif __name__ == &#39;__main__&#39;:    and_perception = train_and_perceptron()    print(and_perception)    print(&#39;1 and 1 = %d&#39; % and_perception.predict([1,1]))    print(&#39;0 and 0 = %d&#39; % and_perception.predict([0,0]))    print(&#39;1 and 0 = %d&#39; % and_perception.predict([1,0]))    print(&#39;0 and 1 = %d&#39; % and_perception.predict([0,1]))</code></pre><blockquote><p>运行结果：<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685949806-ba54dca5-89a6-474a-809c-0b0238184755.png#height=261&id=KN2eh&originHeight=261&originWidth=536&originalType=binary%E2%88%B6=1&size=0&status=done&style=none&width=536"></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> MachingLearning </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Python-基本语法</title>
      <link href="blog/ewt4nc/"/>
      <url>blog/ewt4nc/</url>
      
        <content type="html"><![CDATA[<h2 id="一、基本语法"><a href="#一、基本语法" class="headerlink" title="一、基本语法"></a>一、基本语法</h2><ol><li><p>大事谷歌；小事百度【建立良好的编程式思维】</p></li><li><p>PEP8 中的一些良好约定【编程规范】</p></li><li><p>字符串格式化：<br>print(‘%s–%d–%s’%(‘wuzutao’,20,’尼采般地抒情’))<br>a. %i 是什么格式的那啥？‘</p></li><li><p>强制性类型转换：类 C</p></li><li><p>时间和日期：<br>from datetime import datetime<br>dt=datetime(2019,5,12,9,20)<br>print(dt.year,dt.month,dt.day)</p><blockquote><p>2019  5  12<br>dt.strftime(‘%Y/%m/%d %H:%M’)<br>#datetime 格式转化为字符串<br>‘2019/05/12 09:20’<br>datetime.strptime(‘20161203’, ‘%Y%m%d’) #字符串转化为 datetime 格式<br>datetime.datetime(2016, 12, 3, 0, 0)</p></blockquote></li><li><p>pass 函数<br>def f():<br>   #TODO: test pass<br>   pass</p></li><li><p>异常的处理<br>def test(x,y):<br>   try:<br>       print(y/x)<br>   except:<br>       print(‘输入的信息有误！’)</p><blockquote><p>test(2,8)<br>test(‘e’,8)</p></blockquote></li><li><p>range 和 range 的区别！！！</p></li><li><p>对象传递和拷贝【类似 C 语言中的指针】 #变量传递、列表传递和 C 类似 #深拷贝和浅拷贝<br>import copy<br>a = [[1, 2, 3], [4, 5, 6]]<br>b = a<br>c = copy.copy(a)<br>d = copy.deepcopy(a)<br>print (‘a-id:’,id(a))#id 相当于内存里面的地址<br>print (‘b-id:’,id(b))<br>print (‘c-id:’,id(c))<br>print (‘d-id:’,id(d))<br>a.append(15)<br>a[1][2] = 10<br>print (a)<br>print (b)<br>print (c)<br>print (d)</p></li><li><p>a-id: 2171119139144<br>b-id: 2171119139144<br>c-id: 2171119848136<br>d-id: 2171119140744<br>[[1, 2, 3], [4, 5, 10], 15]<br>[[1, 2, 3], [4, 5, 10], 15]<br>[[1, 2, 3], [4, 5, 10]]<br>[[1, 2, 3], [4, 5, 6]]</p></li></ol><h2 id="二、数据结构"><a href="#二、数据结构" class="headerlink" title="二、数据结构"></a>二、数据结构</h2><h3 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h3><pre><code>    ○ #转换为元组（list-&gt;tuple, string-&gt;tuple）    l = [1, 2, 3]    print (tuple(l))    str = (&#39;Hello ChinaHadoop&#39;)    print (tuple(str))    &gt;&gt;&gt;(1, 2, 3) (&#39;H&#39;, &#39;e&#39;, &#39;l&#39;, &#39;l&#39;, &#39;o&#39;, &#39; &#39;, &#39;C&#39;, &#39;h&#39;, &#39;i&#39;, &#39;n&#39;, &#39;a&#39;, &#39;H&#39;, &#39;a&#39;, &#39;d&#39;, &#39;o&#39;, &#39;o&#39;, &#39;p&#39;)    ○ tup1 = (1, 2, 3)    #嵌套元组:    tup2 = ((1, 2, 3), (4, 5))    print (tup2)    #合并元组:    tup1 + tup2    ○ #拆包    def test_1():        r=(2,4,5,32)        return r    a, b, _, f=test_1()    print(f)    &gt;&gt;&gt; 32    ○ # 元组列表迭代    tuple_lst = [(1, 2), (3, 4), (5, 6)]    for x, y in tuple_lst:        print (x+y)    &gt;&gt;&gt;3   7   11    ○ # 计数器    列表/元组.(&#39;需要查找里面的某个对象的个数&#39;)</code></pre><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><pre><code>    ○ list里面可以有不同类型的元素    ○ #合并列表    lst_1=[352,2352,3,556]    lst_2=[&#39;gew&#39;,&#39;f&#39;]    &gt;lst_3 = lst_1 + lst_2    &gt;lst_1.extend(lst_2)    ○ #sort函数和sorted函数    list_1=[23,54,346,222,4,1]    print(list_1.sort())     #查查版本    print(sorted(list_1))  #sorted是新起的一个列表    lst_6 = [&#39;Welcome&#39;, &#39;to&#39;, &#39;Python&#39;, &#39;Data&#39;, &#39;Analysis&#39;, &#39;Course&#39;]    lst_6.sort()    print (lst_6)【!!!!打印出来是none===查查版本】    &gt;&gt;&gt;[&#39;Analysis&#39;, &#39;Course&#39;, &#39;Data&#39;, &#39;Python&#39;, &#39;Welcome&#39;, &#39;to&#39;]    lst_6.sort(key = len, reverse=True)    print (lst_6)    &gt;&gt;&gt;[&#39;Analysis&#39;, &#39;Welcome&#39;, &#39;Course&#39;, &#39;Python&#39;, &#39;Data&#39;, &#39;to&#39;]</code></pre><h3 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h3><pre><code>    ○ #合并字典    dict1 = &#123;1:&#39;huhuhu&#39;&#125;    dict2 = &#123;4: &#39;new1&#39;, 5: &#39;news&#39;&#125;    dict1.update(dict2)    ○ #通过多个列表创建字典    dict_3 = &#123;&#125;    l1 = [32,543,6,2,7,4]    l2 = reversed(l1)    for i1, i2 in zip(l1, l2):        dict_3[i1] = i2    print (dict_3)    &gt;&gt;&gt;&#123;32: 4, 543: 7, 6: 2, 2: 6, 7: 543, 4: 32&#125;    &#39;&#39;&#39;hash函数来判断某个对象是否可以做键&#39;&#39;&#39;    ○ &#39;&#39;&#39;位置赋值；默认赋值；关键字赋值——format&#39;&#39;&#39;    &#39;&#39;&#39;遍历字典的方式变了：keys，values，items&#39;&#39;&#39;    天行九歌=&#123;&#39;韩非&#39;:&#39;逆鳞&#39;,&#39;卫庄&#39;:&#39;鲨齿&#39;,&#39;盖聂&#39;:&#39;渊虹&#39;&#125;    print(天行九歌)    for ren,jian in 天行九歌.items():        print(&#39;&#123;&#125;--&#123;&#125;&#39;.format(ren,jian))    &gt;&gt;&gt;    &#123;&#39;韩非&#39;: &#39;逆鳞&#39;, &#39;卫庄&#39;: &#39;鲨齿&#39;, &#39;盖聂&#39;: &#39;渊虹&#39;&#125;</code></pre><h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><pre><code>    ○ a1=[1,3,4,1,35,2352,75]    b1=[3,2352,24354,4332432,54]    a=set(a1)    b=set(b1)    print(a)    print(b)    a | b#并；a &amp; b#交；a - b#呃。。。；a ^ b#呃。。。；    a.issubset(b)#判断子集    &gt;&gt;&gt;False    a.issuperset(b)#判断父集    &gt;&gt;&gt;False</code></pre><h2 id="三、高级特性"><a href="#三、高级特性" class="headerlink" title="三、高级特性"></a>三、高级特性</h2><h3 id="推导式"><a href="#推导式" class="headerlink" title="推导式"></a>推导式</h3><pre><code>    ○ str_lst = [&#39;Welcome&#39;, &#39;to&#39;, &#39;Python&#39;, &#39;Data&#39;, &#39;Analysis&#39;, &#39;Course&#39;]    result = [x.upper() for x in str_lst if len(x) &gt; 4]    print (result)    &gt;&gt;&gt;[&#39;WELCOME&#39;, &#39;PYTHON&#39;, &#39;ANALYSIS&#39;, &#39;COURSE&#39;]</code></pre><h3 id="多函数模式"><a href="#多函数模式" class="headerlink" title="多函数模式"></a>多函数模式</h3><pre><code>    ○ str_lst = [&#39;$1.123&#39;, &#39; $1123.454&#39;, &#39;$899.12312&#39;]    def remove_space(str):        &quot;&quot;&quot;            remove space        &quot;&quot;&quot;        str_no_space = str.replace(&#39; &#39;, &#39;&#39;)        return str_no_space    def remove_dollar(str):        &quot;&quot;&quot;            remove $        &quot;&quot;&quot;        if &#39;$&#39; in str:            return str.replace(&#39;$&#39;, &#39;&#39;)        else:            return str    def clean_str_lst(str_lst, operations):        &quot;&quot;&quot;            clean string list        &quot;&quot;&quot;        result = []        for item in str_lst:            for op in operations:                item = op(item)            result.append(item)        return result    clean_operations = [remove_space, remove_dollar]    result = clean_str_lst(str_lst, clean_operations)    print (result)    &gt;&gt;&gt;[&#39;1.123&#39;, &#39;1123.454&#39;, &#39;899.12312&#39;]</code></pre><h3 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h3><pre><code>    ○ str_lst = [&#39;Welcome&#39;, &#39;to&#39;, &#39;Python&#39;, &#39;Data&#39;, &#39;Analysis&#39;, &#39;Course&#39;]    str_lst.sort(key=lambda x:len(x)) # sort by length    print (str_lst)    str_lst.sort(key=lambda x:x[-1]) # sort by the last letter    print (str_lst)    &gt;&gt;&gt;    [&#39;to&#39;, &#39;Data&#39;, &#39;Python&#39;, &#39;Course&#39;, &#39;Welcome&#39;, &#39;Analysis&#39;]    [&#39;Data&#39;, &#39;Course&#39;, &#39;Welcome&#39;, &#39;Python&#39;, &#39;to&#39;, &#39;Analysis&#39;]</code></pre><h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><pre><code>    ○ def gen_test():        for i in range(3):            yield i    gen = gen_test() #此时不执行生成器    type(gen)    for i in gen:        print(i)    #用意何在呢？？！！    &gt;&gt;&gt;0  1  2</code></pre><h2 id="四、常用函数"><a href="#四、常用函数" class="headerlink" title="四、常用函数"></a>四、常用函数</h2><h3 id="序列函数-amp-zip-使用"><a href="#序列函数-amp-zip-使用" class="headerlink" title="序列函数&amp;zip 使用"></a>序列函数&amp;zip 使用</h3><pre><code>    a. enumerate函数    list_11 = [&#39;Welcome&#39;, &#39;to&#39;, &#39;Python&#39;, &#39;Data&#39;, &#39;Analysis&#39;, &#39;Course&#39;]    for i, item in enumerate(lst_6):        print (&#39;%i-%s&#39; %(i, item))    &gt;&gt;&gt;    0-Analysis    1-Welcome    2-Course    3-Python    4-Data    5-to    str_dict = dict((i, item) for i, item in enumerate(list_11))    print (str_dict)    &gt;&gt;&gt;&#123;0: &#39;Welcome&#39;, 1: &#39;to&#39;, 2: &#39;Python&#39;, 3: &#39;Data&#39;, 4: &#39;Analysis&#39;, 5: &#39;Course&#39;&#125;    b. zip压缩    lst_6 = [&#39;Welcome&#39;, &#39;to&#39;, &#39;Python&#39;, &#39;Data&#39;, &#39;Analysis&#39;, &#39;Course&#39;]    lst_8 = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]    zip_lst = zip(lst_6, lst_8)    print(list(zip_lst))    #方式一：直接转化为列表    print(dict(list(zip_lst)))    #方式二：转化为字典    for i in zip_lst:        print (i)    #方式三：直接遍历    解压：    print(*zip_lst)    print(lst_6)    c. reversed逆序输出</code></pre><h3 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h3><pre><code>    a. #函数可以作为变量使用;也可以将函数作为参数使用    import math    def func_add(x, y, f):        &quot;&quot;&quot;            functional addition        &quot;&quot;&quot;        return f(x) + f(y)    print (func_add(4, 25, math.sqrt))    print (func_add(-4, 25, abs))    &gt;&gt;&gt;7.0    29</code></pre><h3 id="map-和-reduce"><a href="#map-和-reduce" class="headerlink" title="map 和 reduce"></a>map 和 reduce</h3><pre><code>    a. &#39;&#39;&#39;map函数&#39;&#39;&#39;    list_1=[1,4,9]    aaa = [x**2 for x in list_1]    print (aaa)    bbb = map(math.sqrt, aaa)    print (bbb)    &gt;&gt;&gt;    [1, 16, 81]</code></pre><p>&lt;map object at 0x000002145B2B77F0&gt;</p><h3 id="filter-函数"><a href="#filter-函数" class="headerlink" title="filter 函数"></a>filter 函数</h3><pre><code>    a. 天行=[&#39;韩非&#39;,&#39;卫庄&#39;,&#39;张良&#39;,&#39;盖聂&#39;,&#39;逆鳞&#39;]    def fx(x):        y=[&#39;逆鳞&#39;]        if x in y:            return x    filtered_lst = filter(fx,天行)    print(天行)    print(list(filtered_lst))    #注意python2和3的区别，很多时候要区别出来列表等序列，加上list很有必要    &gt;&gt;&gt;    [&#39;韩非&#39;, &#39;卫庄&#39;, &#39;张良&#39;, &#39;盖聂&#39;, &#39;逆鳞&#39;]     [&#39;逆鳞&#39;]</code></pre>]]></content>
      
      
      <categories>
          
          <category> Language </category>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>GitHub+PicGo构建免费图床及其高效使用</title>
      <link href="blog/bzf30z/"/>
      <url>blog/bzf30z/</url>
      
        <content type="html"><![CDATA[<h2 id="一、搭建缘由"><a href="#一、搭建缘由" class="headerlink" title="一、搭建缘由"></a>一、搭建缘由</h2><p>一开始搭建博客，避免不了要用许多图片，最初使用七牛云来做博客图床，但是后来发现，七牛云只有 30 天的临时域名，hhhhhhh，果然啊，天下就没有免费的好事啊~后来就发现 GitHub 配合 PicGo 可以作图床，而且加上 jsDlivr 速度可观。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1602926956661-8671ebfe-4f99-494d-b759-a9c75cd67b41.png#align=left&display=inline&height=670&margin=%5Bobject%20Object%5D&originHeight=670&originWidth=807&size=0&status=done&style=stroke&width=807"></p><h2 id="二、GitHub-相关配置"><a href="#二、GitHub-相关配置" class="headerlink" title="二、GitHub 相关配置"></a>二、GitHub 相关配置</h2><h3 id="新建-figure-图床仓库"><a href="#新建-figure-图床仓库" class="headerlink" title="新建 figure 图床仓库"></a>新建 figure 图床仓库</h3><p>常规新建仓库方式，命名 figure<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1602926957158-9c7f8749-4d8e-4bc9-9e1c-7d3db5a307b1.png#align=left&display=inline&height=241&margin=%5Bobject%20Object%5D&originHeight=241&originWidth=1812&size=0&status=done&style=stroke&width=1812"></p><h3 id="生成一个-Token-密匙"><a href="#生成一个-Token-密匙" class="headerlink" title="生成一个 Token 密匙"></a>生成一个 Token 密匙</h3><p>点击 setting<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1602926956634-4c139fbc-0469-4749-89b8-f139226aa7d2.png#align=left&display=inline&height=904&margin=%5Bobject%20Object%5D&originHeight=904&originWidth=1823&size=0&status=done&style=stroke&width=1823"><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1605839703428-b18e3c24-48e0-44ed-9715-81fcd822d4e8.png#align=left&display=inline&height=237&margin=%5Bobject%20Object%5D&originHeight=444&originWidth=1120&size=0&status=done&style=stroke&width=599"><br><strong>只需要勾选第一个仓库选项就可以了！</strong></p><h2 id="三、PicGo-相关配置"><a href="#三、PicGo-相关配置" class="headerlink" title="三、PicGo 相关配置"></a>三、PicGo 相关配置</h2><h3 id="下载及注意事项"><a href="#下载及注意事项" class="headerlink" title="下载及注意事项"></a>下载及注意事项</h3><p><a href="https://github.com/Molunerfinn/PicGo/releases">下载地址</a><br>注意：下载 picgo 时候，要科学上网</p><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1602926956815-db5cf455-f628-4c4d-9242-1687e15a7f03.png#align=left&display=inline&height=564&margin=%5Bobject%20Object%5D&originHeight=564&originWidth=1002&size=0&status=done&style=none&width=1002"></p><h2 id="四、高效写博客"><a href="#四、高效写博客" class="headerlink" title="四、高效写博客"></a>四、高效写博客</h2><h3 id="Snipaste-截图软件"><a href="#Snipaste-截图软件" class="headerlink" title="Snipaste 截图软件"></a>Snipaste 截图软件</h3><blockquote><p><strong>常用</strong>快捷键【作者是用的惠普笔记本电脑，不同电脑键盘的使用方式会不一样】</p></blockquote><p>fn+f1：截屏（可编辑）<br>esc：退出<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1602926956785-4e12ba13-c4c6-4e5a-9758-5d3de27f9718.png#align=left&display=inline&height=446&margin=%5Bobject%20Object%5D&originHeight=446&originWidth=553&size=0&status=done&style=stroke&width=553"></p><h3 id="结合-PicGo-使用"><a href="#结合-PicGo-使用" class="headerlink" title="结合 PicGo 使用"></a>结合 PicGo 使用</h3><p>PicGo+Snipaste 快捷键结合<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1602926956619-08d5eae3-3b21-42cc-a2d8-85d6d2f8ed62.png#align=left&display=inline&height=220&margin=%5Bobject%20Object%5D&originHeight=220&originWidth=847&size=0&status=done&style=stroke&width=847"></p><h3 id="综合使用-SOP"><a href="#综合使用-SOP" class="headerlink" title="综合使用 SOP"></a>综合使用 SOP</h3><ol><li>按<code>fn+f1</code>截完图，再按<code>ctrl+c</code>将刚刚截图放到剪贴板</li><li>再按<code>ctrl+shift+p</code>使用 picgo 快捷键将剪贴板上的图片上传同时将此时图片的外链复制到剪贴板</li></ol><h2 id="五、相关补充"><a href="#五、相关补充" class="headerlink" title="五、相关补充"></a>五、相关补充</h2><h3 id="上传失败"><a href="#上传失败" class="headerlink" title="上传失败"></a>上传失败</h3><p><code>问题1：有些时候上传picgo时，会出现配置报错的情况</code></p><blockquote><p>方案 1：在 picgo 的配置中，改一下文件夹名字（相当于在仓库下新建一个文件夹），就比如本来存到 blogarticle3/文件夹下，改成 blogarticle4/就好了<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1602926956579-eafc7cfa-1e0b-41be-ae5b-c6560b8c7638.png#align=left&display=inline&height=186&margin=%5Bobject%20Object%5D&originHeight=186&originWidth=1320&size=0&status=done&style=none&width=1320"><br>方案 2：将下图所示的<code>上传前重命名</code>打开同时<code>设置Server</code>内容开换成关，关换成开，玄学……<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1602926956785-fb091672-3c17-49db-a0e7-965e20c93f5c.png#align=left&display=inline&height=564&margin=%5Bobject%20Object%5D&originHeight=564&originWidth=1002&size=0&status=done&style=none&width=1002"><br>方案 3：将 PicGo 软件叉掉重新运行。玄学····<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1602926957260-3a981036-cd74-4a90-8665-d2510470f2c9.png#align=left&display=inline&height=564&margin=%5Bobject%20Object%5D&originHeight=564&originWidth=1002&size=0&status=done&style=none&width=1002"><br>方案 4（最优方案）：科学上网</p></blockquote><h3 id="关于插件"><a href="#关于插件" class="headerlink" title="关于插件"></a>关于插件</h3><p>在插件列表里面下载这三个拓展插件，其中两个国内的托管 coding 和 gitee，还有一个 github plus 版本，不过觉得国内的外链范围肯定是要小一点的应该，最好是优先使用 github 图床，coding 和 gitee 的作为文章使用，有关博客配置的使用 CDN 等。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1602926956548-b7b5ad1b-2586-42c5-8f7d-9dd17c265fcf.png#align=left&display=inline&height=341&margin=%5Bobject%20Object%5D&originHeight=341&originWidth=771&size=0&status=done&style=none&width=771"></p><h4 id="Coding-配置"><a href="#Coding-配置" class="headerlink" title="Coding 配置"></a>Coding 配置</h4><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1602926956265-035a546d-2ecd-48c3-8eec-c9ef7779653b.png#align=left&display=inline&height=486&margin=%5Bobject%20Object%5D&originHeight=486&originWidth=739&size=0&status=done&style=none&width=739"></p><h4 id="gitee-配置"><a href="#gitee-配置" class="headerlink" title="gitee 配置"></a>gitee 配置</h4><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1602926956286-859465c2-411f-4761-8921-526656b8a191.png#align=left&display=inline&height=568&margin=%5Bobject%20Object%5D&originHeight=568&originWidth=778&size=0&status=done&style=none&width=778"></p><h4 id="GitHub-plus-配置"><a href="#GitHub-plus-配置" class="headerlink" title="GitHub plus 配置"></a>GitHub plus 配置</h4><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1602926956274-6e705ace-8e6f-4226-9fae-ffaaa66a2aa9.png#align=left&display=inline&height=517&margin=%5Bobject%20Object%5D&originHeight=517&originWidth=727&size=0&status=done&style=none&width=727"></p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>jsDelivr和Github构建免费CDN</title>
      <link href="blog/erx9hf/"/>
      <url>blog/erx9hf/</url>
      
        <content type="html"><![CDATA[<h2 id="一、搭建缘由"><a href="#一、搭建缘由" class="headerlink" title="一、搭建缘由"></a>一、搭建缘由</h2><p>CDN 的全称是 Content Delivery Network，即内容分发网络。CDN 是构建在网络之上的内容分发网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。CDN 的关键技术主要有内容存储和分发技术。——百度百科</p><p>通俗来说就是提取外链，同时加速访问的好处。Github 的资源在国内加载速度比较慢，因此需要使用 CDN 加速来优化网站打开速度，jsDelivr + Github 便是免费且好用的 CDN，非常适合博客网站使用。</p><h2 id="二、GitHub-新建-CDN-仓库"><a href="#二、GitHub-新建-CDN-仓库" class="headerlink" title="二、GitHub 新建 CDN 仓库"></a>二、GitHub 新建 CDN 仓库</h2><p>在本地电脑进行一系列 clone/pull 等一系列操作，同时发布版本（最好上传一次就发布依次版本）<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1602926808858-fcdea51e-42b2-4582-b46d-e9c105842039.png#align=left&display=inline&height=950&margin=%5Bobject%20Object%5D&originHeight=950&originWidth=1844&size=0&status=done&style=none&width=1844"><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1602926808290-99384f86-d857-415a-83e6-9be3b5bcf279.png#align=left&display=inline&height=953&margin=%5Bobject%20Object%5D&originHeight=953&originWidth=1832&size=0&status=done&style=none&width=1832"></p><h2 id="三、使用-jsDlivr"><a href="#三、使用-jsDlivr" class="headerlink" title="三、使用 jsDlivr"></a>三、使用 jsDlivr</h2><p><strong><code>[https://cdn.jsdelivr.net/gh/wztlink1013/CDN-Volantis@](https://cdn.jsdelivr.net/gh/wztlink1013/CDN-Volantis@)版本号/文件夹/文件名.文件后缀</code></strong></p><p><strong>举个栗子</strong></p><ul><li><a href="https://cdn.jsdelivr.net/gh/wztlink1013/CDN@2.4/Pictures/blogbackground/fengbaobao_1.jpg">https://cdn.jsdelivr.net/gh/wztlink1013/CDN@2.4/Pictures/blogbackground/fengbaobao_1.jpg</a></li><li><a href="https://cdn.jsdelivr.net/gh/moezx/cdn@3.1.3//The%20Pet%20Girl%20of%20Sakurasou.mp4">https://cdn.jsdelivr.net/gh/moezx/cdn@3.1.3//The Pet Girl of Sakurasou.mp4</a></li></ul><blockquote><p>0、具体使用教程</p></blockquote><ul><li><a href="https://blog.wztlink1013.com/2020/02/25/Hexo/jsDelivr%E5%92%8CGitHub%E6%9E%84%E5%BB%BA%E5%85%8D%E8%B4%B9CDN/">jsDelivr 和 Github 构建免费 CDN</a></li><li><a href="https://www.jsdelivr.com/">jsdelivr 官网网站</a></li></ul><blockquote><p>1、加载任何 Github 发布、提交或分支</p></blockquote><ul><li><a href="https://cdn.jsdelivr.net/gh/user/repo@version/file">https://cdn.jsdelivr.net/gh/user/repo@version/file</a></li></ul><blockquote><p>2、加载 jQuery v3.2.1</p></blockquote><ul><li><a href="https://cdn.jsdelivr.net/gh/jquery/jquery@3.2.1/dist/jquery.min.js">https://cdn.jsdelivr.net/gh/jquery/jquery@3.2.1/dist/jquery.min.js</a></li></ul><blockquote><p>3、使用版本范围而不是特定版本</p></blockquote><ul><li><a href="https://cdn.jsdelivr.net/gh/jquery/jquery@3.2/dist/jquery.min.js">https://cdn.jsdelivr.net/gh/jquery/jquery@3.2/dist/jquery.min.js</a></li><li><a href="https://cdn.jsdelivr.net/gh/jquery/jquery@3/dist/jquery.min.js">https://cdn.jsdelivr.net/gh/jquery/jquery@3/dist/jquery.min.js</a></li></ul><blockquote><p>4、完全省略该版本以获取最新版本</p></blockquote><ul><li><a href="https://cdn.jsdelivr.net/gh/jquery/jquery/dist/jquery.min.js">https://cdn.jsdelivr.net/gh/jquery/jquery/dist/jquery.min.js</a></li></ul><blockquote><p>5、将“.min”添加到任何 JS/CSS 文件中以获取缩小版本，如果不存在，将为会自动生成</p></blockquote><ul><li><a href="https://cdn.jsdelivr.net/gh/jquery/jquery@3.2.1/src/core.min.js">https://cdn.jsdelivr.net/gh/jquery/jquery@3.2.1/src/core.min.js</a></li></ul><blockquote><p>6、在末尾添加 / 以获取资源目录列表</p></blockquote><ul><li><a href="https://cdn.jsdelivr.net/gh/jquery/jquery/">https://cdn.jsdelivr.net/gh/jquery/jquery/</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>DOS/CMD/Windows/提高开发效率</title>
      <link href="blog/nvlr2g/"/>
      <url>blog/nvlr2g/</url>
      
        <content type="html"><![CDATA[<h2 id="一、快捷键"><a href="#一、快捷键" class="headerlink" title="一、快捷键"></a>一、快捷键</h2><blockquote><p>很多软件的快捷键使用相通，在不确定的情况下，先试试其他软件的快捷键的使用方法</p></blockquote><h3 id="Windows-快捷键"><a href="#Windows-快捷键" class="headerlink" title="Windows 快捷键"></a>Windows 快捷键</h3><blockquote><p><strong>HP 惠普笔记本</strong></p></blockquote><pre><code class="powershell">Win+E                  打开文件管器Win+D                  显示桌面Win+L                  锁计算机Win+V：                                打开剪贴板Win+PgUp：                            在桌面选定左上角软件/文件Win+PgDown：                        在桌面选定右下角软件/文件Win+G                                    录频选项Win+alt+G                            直接录频alt+F4                关闭当前程序ctrl+shift+Esc/ctrl+alt+delete：任务管理器ctrl+F                文本或网页中查找（退出一般按ESC）ctrl+A                选中所有文本</code></pre><h3 id="Eclipse-快捷键"><a href="#Eclipse-快捷键" class="headerlink" title="Eclipse 快捷键"></a>Eclipse 快捷键</h3><blockquote><p>ctrl+shift+L：eclipse 所有快捷键<br><code>//</code>注释：<code>ctrl+shift+c</code>（添加和注释都是这样）或者<code>ctrl+/</code> &gt; <code>/**/</code>注释：添加<code>ctrl+shift+/</code>   取消<code>ctrl+shift+\</code></p></blockquote><pre><code>Alt+方向键：                    将当前行向上或者向下移动ctrl+m：                            编辑窗口最大化（反复两次按即取消）ctrl+.及ctrl+1：            下一个错误及快速修改Control+O:                         快速概要,迅速的跳到一个方法或者属性，只需要输入名字的头几个字母。shift+home/end：                选中一行ctrl+pgup/pgdn：                切换页面（浏览器打开的页面/编辑器的多窗口）</code></pre><h3 id="VScode-快捷键"><a href="#VScode-快捷键" class="headerlink" title="VScode 快捷键"></a>VScode 快捷键</h3><pre><code>ctrl+shift+c                直接进入博客根目录下的CMD模式</code></pre><h3 id="Pycharm-JetBrains-快捷键"><a href="#Pycharm-JetBrains-快捷键" class="headerlink" title="Pycharm/JetBrains 快捷键"></a>Pycharm/JetBrains 快捷键</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685666000-0fb595f1-51e4-4e71-8547-96aa0b938148.png#align=left&display=inline&height=397&margin=%5Bobject%20Object%5D&originHeight=397&originWidth=769&size=0&status=done&style=none&width=769"></p><pre><code>Ctrl+F5（左上角）：（return &quot;project&quot;）重新debug该文件F9：（resume program）一个断点接着一个断点走，不按行走（eg：有循环会随着i一步一步走完）F8：（step over） 一行一行走代码F7：（step into） 进入函数内部Alt+shift+F7：（step into mycode）遇到自己函数  进去shift+F8：（step out）跳出，进入函数后，跳出来Alt+F10：（show execution point）指针显示当前断点旁边**Show Python Prompt**按键,交互式调试命令</code></pre><h2 id="二、CMD-之常用命令"><a href="#二、CMD-之常用命令" class="headerlink" title="二、CMD 之常用命令"></a>二、CMD 之常用命令</h2><blockquote><ul><li>使用 help 命令，查看所有的 dos 命令</li><li>找到命令之后，使用 <code>命令+ /?</code>来查看该命令下的其他属性</li><li>DOS 不区分大小写</li></ul></blockquote><h3 id="磁盘-文件夹相关"><a href="#磁盘-文件夹相关" class="headerlink" title="磁盘/文件夹相关"></a>磁盘/文件夹相关</h3><ul><li><p><code>d:</code> <code>e:</code> 进入不同的盘</p></li><li><p><code>cd:</code> 进入指定文件夹。注意：只在<strong>该磁盘</strong>才有效</p></li><li><p><code>dir</code> 查看当前目录下的所有文件，使用 dir /?来查看其它用法</p></li><li><p>创建和删除目录</p><ul><li>md 目录名（文件夹） //创建目录</li><li>rd   目录名（文件夹） //删除目录</li></ul></li><li><p>cd .. 返回上一级文件夹</p></li><li><p>复制文件:把一个文件移动（就是剪切+复制）到另一个地方。甚至可以改后缀</p><blockquote><p>move 路径\文件名 路径\文件名</p></blockquote></li><li><p>删除文件</p><blockquote><p>//这个是专门删除文件的，不能删除文件夹<br>del 文件名</p></blockquote></li><li><p><strong>生成文件树</strong></p><blockquote><p>tree /f &gt;tree.txt</p></blockquote></li></ul><h3 id="网络相关"><a href="#网络相关" class="headerlink" title="网络相关"></a>网络相关</h3><ul><li><code>ipconfig</code> 查看本机 ip</li><li><code>cls</code> 清除屏幕</li><li>ping<blockquote><p>//用来测试网络是否畅通<br>ping ip(主机名)</p></blockquote></li></ul><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><pre><code>复制内容：右键弹出快捷菜单，选择“标记(K)”，然后选中所需复制的内容，然后右键即可粘贴内容：右键弹出快捷菜单，选择“粘贴(P)”</code></pre><ul><li>在文件夹空白处按住 Shift，然后右键弹出快捷菜单，可以看到“在此处打开命令行窗口”</li><li>tab 补齐功能！！！</li><li>文件及目录名中不能包含下列任何字符：\ / : * ? “ &lt; &gt; |</li></ul><h2 id="三、CMD-之默认非-utf-8-编码"><a href="#三、CMD-之默认非-utf-8-编码" class="headerlink" title="三、CMD 之默认非 utf-8 编码"></a>三、CMD 之默认非 utf-8 编码</h2><p>运行 java 程序时候，如果代码中有中文，会出现中文报错乱码情况/</p><h3 id="治标方法"><a href="#治标方法" class="headerlink" title="治标方法"></a>治标方法</h3><p><code>CMD</code> 中输入 <code>chcp 65001</code> 进入 utf-8 模式下的的控制台，再运行程序</p><h3 id="治本方法"><a href="#治本方法" class="headerlink" title="治本方法"></a>治本方法</h3><p><a href="https://blog.csdn.net/gulang03/article/details/81771343">博文 1</a>  <a href="https://blog.csdn.net/runAndRun/article/details/103072938?depth_1-utm_source=distribute.pc_relevant.none-task&utm_source=distribute.pc_relevant.none-task">博文 2</a>注意：自己已经再注册表中增加了一行 tuf-8 编码数据，以后要留意、<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685666566-625a520c-ff9d-4eea-8fba-3a8c4f8f696e.png#align=left&display=inline&height=24&margin=%5Bobject%20Object%5D&originHeight=24&originWidth=660&size=0&status=done&style=none&width=660"></p><h2 id="四、CMD-之运行-JAVA"><a href="#四、CMD-之运行-JAVA" class="headerlink" title="四、CMD 之运行 JAVA"></a>四、CMD 之运行 JAVA</h2><h3 id="CMD-运行-java-程序"><a href="#CMD-运行-java-程序" class="headerlink" title="CMD 运行 java 程序"></a>CMD 运行 java 程序</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685666652-cb97d69b-664c-4506-a24f-1dc5b8220a02.png#align=left&display=inline&height=940&margin=%5Bobject%20Object%5D&originHeight=940&originWidth=902&size=0&status=done&style=none&width=902"></p><h3 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h3><blockquote><p>main 主函数可以看成一个普通的方法，也可以传递实参来调用普通方法<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685666759-75d2a062-c52d-4c49-acce-7310a0280f24.png#align=left&display=inline&height=214&margin=%5Bobject%20Object%5D&originHeight=214&originWidth=1070&size=0&status=done&style=none&width=1070"></p></blockquote><hr><blockquote><p>向 main 方法传递字符串<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685666878-98ce351e-4485-4381-bcfe-4b9121226fc9.png#align=left&display=inline&height=778&margin=%5Bobject%20Object%5D&originHeight=778&originWidth=1098&size=0&status=done&style=none&width=1098"></p></blockquote><h3 id="CMD-下运行-Java-中文乱码"><a href="#CMD-下运行-Java-中文乱码" class="headerlink" title="CMD 下运行 Java 中文乱码"></a>CMD 下运行 Java 中文乱码</h3><p><code>javac -encoding utf-8 test.java</code></p><p>还是上面的问题，DOS 默认使用的编码是 GBK,这里需要再编译的时候制定使用的编码</p><h2 id="五、笔记本触摸板"><a href="#五、笔记本触摸板" class="headerlink" title="五、笔记本触摸板"></a>五、笔记本触摸板</h2><h3 id="笔记本触摸屏使用"><a href="#笔记本触摸屏使用" class="headerlink" title="笔记本触摸屏使用"></a>笔记本触摸屏使用</h3><ul><li><strong>单指</strong>：“确定键”<br>点击===相当于左键确定<br>先点击 不放拖动 ===拖拽</li><li><strong>双指</strong>：“右键、滑动、拉伸旋转键”<br>点击=相当于右键（鼠标）<br>先点击   不放左右拖动上下拖动=滑页功能<br>等比例拉伸或者旋转</li><li><strong>三指</strong>：“页面切换键”<br>点击=查找<br>先点击   不放   上下拖动=多页面模式、纯桌面模式切换<br>先点击   不放   左右拖动===页面切换类似 alt+tab</li><li><strong>四指</strong>：“设置键”<br>点击===设置/操作中心</li></ul><h3 id="实现手写输入功能"><a href="#实现手写输入功能" class="headerlink" title="实现手写输入功能"></a>实现手写输入功能</h3><ul><li>第一步：安装 SoftStylus 手写软件</li></ul><p>本身没有预装 SoftStylus 手写软件的，首先登录 HP 官方网站，查询并下载手写软件，然后安装手写软件。如果已预装手写软件，建议运行 Software Setup 软件，将手写软件升级到最新版本，以提高手写识别成功率。</p><ul><li>第二步：设置手写识别速度</li></ul><p>运行手写软件，点击设置图标进入“参数”界面，然后可根据需要配置识别速度。如果是初次使用手写功能，刚开始建议将识别速度降低，一旦习惯了使用手写功能，应该将识别速度调为最快，这样在 QQ 聊天或编辑文档时，以应对较快的手写输入连写。</p><ul><li>第三步：设置各种热键</li></ul><p>此外，替换选项可设置在主窗口上显示最多可选择字符，这个应该根据笔记本屏幕大小而定，例如 14 英寸屏幕可设置为 7，而 12 英寸屏幕应该设为 4，最后建议开启“汉字预览”功能，切换到“热键”选项页，然后可根据需要自定义各种热键。</p><ul><li>第四步：设置手写窗口外观</li></ul><p>如果经常使用手写功能，建议切换到“一般”选项页，勾寻操作系统起动时运行 SoftStylus”复选框，最后切换到“外观”选项页，并调节窗口透明度、画笔宽度和墨色。如果是 QQ 聊天，建议将画笔宽度调细一点，且墨色应该设为黑色。</p><ul><li>第五步：使用手写进行聊天</li></ul><p>设置完毕后，单击“确认”按钮，当你在 QQ 聊天或编辑文档时，如想使用手写输入，只需按下前面设置的快捷键，即可马上弹出手写输入界面。<br>这个时候，就可以用手指在触摸板上比划，文字就会显示在界面里，最后出现在聊天窗口中，很方便。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>W<a href="https://www.jianshu.com/p/7bd7574d94c8">indows 常用快捷键与快捷指令</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Environment </category>
          
          <category> 工具使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CMD </tag>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>爬虫框架和Scrapy使用</title>
      <link href="blog/zsvfxg/"/>
      <url>blog/zsvfxg/</url>
      
        <content type="html"><![CDATA[<h2 id="一、爬虫基本架构"><a href="#一、爬虫基本架构" class="headerlink" title="一、爬虫基本架构"></a>一、爬虫基本架构</h2><h3 id="url-管理模块"><a href="#url-管理模块" class="headerlink" title="url 管理模块"></a>url 管理模块</h3><ul><li>就是管理自己爬取的的网页不要重复爬取，避免爬取进入死循环</li><li>使用 python 当中的 set 数据结构</li></ul><h3 id="网页下载模块"><a href="#网页下载模块" class="headerlink" title="网页下载模块"></a>网页下载模块</h3><blockquote><p>将对应的 url 模块下载到本地或者读入内存</p></blockquote><blockquote><p>实现方式</p></blockquote><ul><li>通过 url 下载</li></ul><pre><code class="python">from urllib.request import urlopentest_url = &quot;https://wztlink1013.github.io&quot;response = urlopen(test_url)print (response.getcode()) # 200 表示访问成功print (response.read())</code></pre><ul><li>通过 Request 访问</li><li>通过 cookie 访问</li></ul><h3 id="网页解析模块"><a href="#网页解析模块" class="headerlink" title="网页解析模块"></a>网页解析模块</h3><blockquote><p>从已经下载的网页中爬取数据，实现方式有：</p></blockquote><ol><li>正则表达式</li><li>html.parser</li><li><strong>BeautifulSoup：结构化解析网页</strong></li><li>lxml</li><li>结构化解析</li><li>DOM（Document Object Model），树形结构，就是 html 的基本骨架</li></ol><h2 id="二、BeautifulSoup-解析网页"><a href="#二、BeautifulSoup-解析网页" class="headerlink" title="二、BeautifulSoup 解析网页"></a>二、BeautifulSoup 解析网页</h2><h2 id="三、Scrapy"><a href="#三、Scrapy" class="headerlink" title="三、Scrapy"></a>三、Scrapy</h2><h3 id="Scrapy-基础"><a href="#Scrapy-基础" class="headerlink" title="Scrapy 基础"></a>Scrapy 基础</h3><ul><li>是一个爬虫框架，同时易扩展，可以添加新的模块达到自定义扩展</li><li>输出格式多样：json，csv，xml 等</li><li>自动处理编码</li></ul><h3 id="Scrapy-框架架构图"><a href="#Scrapy-框架架构图" class="headerlink" title="Scrapy 框架架构图"></a>Scrapy 框架架构图</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/webp/1484158/1598673193957-7a7456b0-3de1-4c77-b849-cc2572555ed5.webp#align=left&display=inline&height=281&margin=%5Bobject%20Object%5D&originHeight=541&originWidth=801&size=0&status=done&style=shadow&width=416"></p><blockquote><p>下载方法以及问题，在 anaconda 博客中</p></blockquote><h2 id="四、Scrapy-使用"><a href="#四、Scrapy-使用" class="headerlink" title="四、Scrapy 使用"></a>四、Scrapy 使用</h2><h3 id="使用-SOP"><a href="#使用-SOP" class="headerlink" title="使用 SOP"></a>使用 SOP</h3><ul><li>创建工程<ul><li>键入<code>cmd</code> <code>cd</code>到需要下载的目录下</li><li>输入<code>scrapy startproject tutorial</code>（最后是项目名字）</li><li><strong>!此后所有有关命令的操作，均在下一级文件夹下，也有是有 cfg 文件后缀的文件夹下</strong></li></ul></li><li>定义 Item，构造爬取的对象</li><li>编写 spider，爬虫主体<ul><li><code>scrapy genspider amazon_spider https://……</code></li></ul></li><li>pipelines，默认 return item</li><li>编写其他配置，其中 pipeline 用于处理爬取后所得到的结果</li><li>执行爬虫<ul><li><code>scrapy crawl amazon_spider</code></li></ul></li></ul><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>查看其官方文档</li><li><a href="https://www.jianshu.com/p/8023fccd7206">简书</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> DataAnalysis </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数据可视化</title>
      <link href="blog/kt0kvc/"/>
      <url>blog/kt0kvc/</url>
      
        <content type="html"><![CDATA[<h2 id="一、GitHub-Juper-NoteBook-笔记"><a href="#一、GitHub-Juper-NoteBook-笔记" class="headerlink" title="一、GitHub Juper NoteBook 笔记"></a>一、GitHub Juper NoteBook 笔记</h2><ul><li><a href="https://github.com/wztlink1013/data-analysis-mining">https://github.com/wztlink1013/data-analysis-mining</a></li></ul><h2 id="二、零碎总结"><a href="#二、零碎总结" class="headerlink" title="二、零碎总结"></a>二、零碎总结</h2><h3 id="matplotlib-调整子图间距，调整整体空白"><a href="#matplotlib-调整子图间距，调整整体空白" class="headerlink" title="matplotlib 调整子图间距，调整整体空白"></a>matplotlib 调整子图间距，调整整体空白</h3><pre><code class="python">fig.tight_layout() #调整整体空白plt.subplots_adjust(wspace =0, hspace =0) #调整子图间距</code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://mp.weixin.qq.com/s/DaQL6bqr0wu5iYt-cVkz6g">Matplotlib 可视化最有价值的 50 个图表</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> DataAnalysis </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Pandas使用——分组聚合</title>
      <link href="blog/oq4xcx/"/>
      <url>blog/oq4xcx/</url>
      
        <content type="html"><![CDATA[<h2 id="一、分组"><a href="#一、分组" class="headerlink" title="一、分组"></a>一、分组</h2><h3 id="GroupBy-对象"><a href="#GroupBy-对象" class="headerlink" title="GroupBy 对象"></a>GroupBy 对象</h3><blockquote><p>· groupedby 函数中的参数：</p></blockquote><pre><code>as_index的作用：控制聚合输出是否以组标签为索引值，默认为True，就是分层次的索引，若为False多加一列默认索引索引，相当于非其他数据排序好了。但是这两组标签索引值不同有什么作用呢？=== 作用就是，根据的一列是否为索引列。sort_values的作用：对选定的一列数值数据从上往下从小到大进行排序（如果传值没成功===设置本体覆盖，传值覆盖）</code></pre><pre><code class="python">import pandas as pdimport numpy as npimport matplotlib.pyplot as pltimport matplotlib.pyplot%matplotlib inline</code></pre><pre><code class="python">dict_obj = &#123;&#39;key1&#39; : [&#39;a&#39;, &#39;b&#39;, &#39;a&#39;, &#39;b&#39;,                      &#39;a&#39;, &#39;b&#39;, &#39;a&#39;, &#39;a&#39;],            &#39;key2&#39; : [&#39;one&#39;, &#39;one&#39;, &#39;two&#39;, &#39;three&#39;,                      &#39;two&#39;, &#39;two&#39;, &#39;one&#39;, &#39;three&#39;],            &#39;data1&#39;: np.random.randn(8),            &#39;data2&#39;: np.random.randn(8)&#125;df_obj = pd.DataFrame(dict_obj)print (df_obj)</code></pre><pre><code>  key1   key2     data1     data20    a    one -0.147612 -0.3480871    b    one -0.992986  0.9024582    a    two  0.547541 -0.3100403    b  three  0.458871 -1.8953924    a    two  1.224041  0.2201505    b    two -0.200124 -1.5622376    a    one  1.539144 -0.7587167    a  three  0.385845  0.074309</code></pre><pre><code class="python">&#39;&#39;&#39;1. dataframe根据key2进行分组&#39;&#39;&#39;print(df_obj.groupby(&#39;key2&#39;)[&#39;key1&#39;].count())print (type(df_obj.groupby(&#39;key1&#39;)))#没有可视化的输出</code></pre><pre><code>key2one      3three    2two      3Name: key1, dtype: int64&lt;class &#39;pandas.core.groupby.generic.DataFrameGroupBy&#39;&gt;</code></pre><pre><code class="python">&#39;&#39;&#39;2. 指定列根据key1进行分组&#39;&#39;&#39;print (type(df_obj[&#39;data1&#39;].groupby(df_obj[&#39;key1&#39;])))</code></pre><pre><code>&lt;class &#39;pandas.core.groupby.generic.SeriesGroupBy&#39;&gt;</code></pre><pre><code class="python"># 分组运算grouped1 = df_obj.groupby(&#39;key1&#39;,as_index=False)print (grouped1.mean())grouped2 = df_obj[&#39;data1&#39;].groupby(df_obj[&#39;key1&#39;])#指定某一列的数据在该索引下进行分组并且加以聚合print (grouped2.mean())</code></pre><pre><code>  key1     data1     data20    a  0.709792 -0.2244771    b -0.244746 -0.851723key1a    0.709792b   -0.244746Name: data1, dtype: float64</code></pre><pre><code class="python">&#39;&#39;&#39;3. 按自定义key分组，列表&#39;&#39;&#39;self_def_key = [1, 1, 2, 2, 2, 1, 1, 1]df_obj.groupby(self_def_key).mean()</code></pre><table><thead><tr><th></th><th>data1</th><th>data2</th></tr></thead><tbody><tr><td>1</td><td>0.116853</td><td>-0.338455</td></tr><tr><td>2</td><td>0.743484</td><td>-0.661761</td></tr></tbody></table><pre><code class="python">df_obj</code></pre><table><thead><tr><th></th><th>key1</th><th>key2</th><th>data1</th><th>data2</th></tr></thead><tbody><tr><td>0</td><td>a</td><td>one</td><td>-0.147612</td><td>-0.348087</td></tr><tr><td>1</td><td>b</td><td>one</td><td>-0.992986</td><td>0.902458</td></tr><tr><td>2</td><td>a</td><td>two</td><td>0.547541</td><td>-0.310040</td></tr><tr><td>3</td><td>b</td><td>three</td><td>0.458871</td><td>-1.895392</td></tr><tr><td>4</td><td>a</td><td>two</td><td>1.224041</td><td>0.220150</td></tr><tr><td>5</td><td>b</td><td>two</td><td>-0.200124</td><td>-1.562237</td></tr><tr><td>6</td><td>a</td><td>one</td><td>1.539144</td><td>-0.758716</td></tr><tr><td>7</td><td>a</td><td>three</td><td>0.385845</td><td>0.074309</td></tr></tbody></table><pre><code class="python">&#39;&#39;&#39;4. 按多个列多层分组 = = = 通过列表&#39;&#39;&#39;grouped2 = df_obj.groupby([&#39;key1&#39;, &#39;key2&#39;],as_index=False)print (grouped2.mean())print(&#39;--------比较asindex的差异-------&#39;)grouped2 = df_obj.groupby([&#39;key1&#39;, &#39;key2&#39;],as_index=True)print (grouped2.mean())</code></pre><pre><code>  key1   key2     data1     data20    a    one  0.695766 -0.5534011    a  three  0.385845  0.0743092    a    two  0.885791 -0.0449453    b    one -0.992986  0.9024584    b  three  0.458871 -1.8953925    b    two -0.200124 -1.562237--------比较asindex的差异-------               data1     data2key1 key2a    one    0.695766 -0.553401     three  0.385845  0.074309     two    0.885791 -0.044945b    one   -0.992986  0.902458     three  0.458871 -1.895392     two   -0.200124 -1.562237</code></pre><pre><code class="python"># 多层分组按key的顺序进行===和上面的asindex作用一样，把所选取的列数据当成索引，这才是区别之处grouped3 = df_obj.groupby([&#39;key2&#39;, &#39;key1&#39;])print (grouped3.mean())print (&#39;=============================================&#39;)&#39;&#39;&#39;PS：如果想按照列进行分组聚合运算 === unstack===也可以通过转置&#39;&#39;&#39;print (grouped3.mean().unstack())</code></pre><pre><code>               data1     data2key2  key1one   a     0.695766 -0.553401      b    -0.992986  0.902458three a     0.385845  0.074309      b     0.458871 -1.895392two   a     0.885791 -0.044945      b    -0.200124 -1.562237=============================================          data1               data2key1          a         b         a         bkey2one    0.695766 -0.992986 -0.553401  0.902458three  0.385845  0.458871  0.074309 -1.895392two    0.885791 -0.200124 -0.044945 -1.562237</code></pre><h3 id="GroupBy-对象遍历迭代"><a href="#GroupBy-对象遍历迭代" class="headerlink" title="GroupBy 对象遍历迭代"></a>GroupBy 对象遍历迭代</h3><pre><code class="python">grouped1</code></pre><pre><code>&lt;pandas.core.groupby.generic.DataFrameGroupBy object at 0x000001AF5B5F9088&gt;</code></pre><pre><code class="python"># 单层分组print(grouped1.head(5))print(&quot;------------------------------------分割线------------------------------------------&quot;)for group_name, group_data in grouped1:    print (group_name)    print (group_data[&#39;data1&#39;])</code></pre><pre><code>  key1   key2     data1     data20    a    one -0.147612 -0.3480871    b    one -0.992986  0.9024582    a    two  0.547541 -0.3100403    b  three  0.458871 -1.8953924    a    two  1.224041  0.2201505    b    two -0.200124 -1.5622376    a    one  1.539144 -0.7587167    a  three  0.385845  0.074309------------------------------------分割线------------------------------------------a0   -0.1476122    0.5475414    1.2240416    1.5391447    0.385845Name: data1, dtype: float64b1   -0.9929863    0.4588715   -0.200124Name: data1, dtype: float64</code></pre><pre><code class="python"># 多层分组for group_name, group_data in grouped2:    print (group_name)    print (group_data)</code></pre><pre><code>(&#39;a&#39;, &#39;one&#39;)  key1 key2     data1     data20    a  one -0.147612 -0.3480876    a  one  1.539144 -0.758716(&#39;a&#39;, &#39;three&#39;)  key1   key2     data1     data27    a  three  0.385845  0.074309(&#39;a&#39;, &#39;two&#39;)  key1 key2     data1    data22    a  two  0.547541 -0.310044    a  two  1.224041  0.22015(&#39;b&#39;, &#39;one&#39;)  key1 key2     data1     data21    b  one -0.992986  0.902458(&#39;b&#39;, &#39;three&#39;)  key1   key2     data1     data23    b  three  0.458871 -1.895392(&#39;b&#39;, &#39;two&#39;)  key1 key2     data1     data25    b  two -0.200124 -1.562237</code></pre><pre><code class="python"># GroupBy对象转换listprint(grouped1.mean())list(grouped1)</code></pre><pre><code>  key1     data1     data20    a  0.709792 -0.2244771    b -0.244746 -0.851723[(&#39;a&#39;,   key1   key2     data1     data2  0    a    one -0.147612 -0.348087  2    a    two  0.547541 -0.310040  4    a    two  1.224041  0.220150  6    a    one  1.539144 -0.758716  7    a  three  0.385845  0.074309), (&#39;b&#39;,   key1   key2     data1     data2  1    b    one -0.992986  0.902458  3    b  three  0.458871 -1.895392  5    b    two -0.200124 -1.562237)]</code></pre><pre><code class="python"># GroupBy对象转换dictdict(list(grouped1))</code></pre><pre><code>&#123;&#39;a&#39;:   key1   key2     data1     data2 0    a    one -0.147612 -0.348087 2    a    two  0.547541 -0.310040 4    a    two  1.224041  0.220150 6    a    one  1.539144 -0.758716 7    a  three  0.385845  0.074309, &#39;b&#39;:   key1   key2     data1     data2 1    b    one -0.992986  0.902458 3    b  three  0.458871 -1.895392 5    b    two -0.200124 -1.562237&#125;</code></pre><pre><code class="python"># 按列分组print (df_obj.dtypes)# 按数据类型分组df_obj.groupby(df_obj.dtypes, axis=1).size()df_obj.groupby(df_obj.dtypes, axis=1).sum()</code></pre><pre><code>key1      objectkey2      objectdata1    float64data2    float64dtype: object</code></pre><h3 id="其他分组方法"><a href="#其他分组方法" class="headerlink" title="其他分组方法"></a>其他分组方法</h3><ol><li>其实列表也是分组的一种方式<br>===用到列表时候，一般都是多层索引了</li></ol><pre><code class="python">df_obj2 = pd.DataFrame(np.random.randint(1, 10, (5,5)),                       columns=[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;],                       index=[&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;])df_obj2.ix[1, 1:4] = np.NaNdf_obj2</code></pre><pre><code>C:\Users\wztli\Anaconda3\lib\site-packages\ipykernel_launcher.py:4: FutureWarning:.ix is deprecated. Please use.loc for label based indexing or.iloc for positional indexingSee the documentation here:http://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#ix-indexer-is-deprecated  after removing the cwd from sys.path.</code></pre><table><thead><tr><th></th><th>a</th><th>b</th><th>c</th><th>d</th><th>e</th></tr></thead><tbody><tr><td>A</td><td>4</td><td>2.0</td><td>6.0</td><td>5.0</td><td>9</td></tr><tr><td>B</td><td>5</td><td>NaN</td><td>NaN</td><td>NaN</td><td>6</td></tr><tr><td>C</td><td>2</td><td>3.0</td><td>8.0</td><td>6.0</td><td>3</td></tr><tr><td>D</td><td>9</td><td>5.0</td><td>6.0</td><td>5.0</td><td>9</td></tr><tr><td>E</td><td>4</td><td>1.0</td><td>6.0</td><td>2.0</td><td>1</td></tr></tbody></table><ol><li>通过字典分组</li></ol><pre><code class="python"># 通过字典分组mapping_dict = &#123;&#39;A&#39;:&#39;python&#39;, &#39;B&#39;:&#39;python&#39;, &#39;C&#39;:&#39;java&#39;, &#39;D&#39;:&#39;C&#39;, &#39;E&#39;:&#39;java&#39;&#125;#df_obj2.groupby(mapping_dict, axis=1).size()#df_obj2.groupby(mapping_dict, axis=1).count() # 非NaN的个数print(df_obj2.groupby(mapping_dict, axis=0).sum())</code></pre><pre><code>        a    b     c    d   eC       9  5.0   6.0  5.0   9java    6  4.0  14.0  8.0   4python  9  2.0   6.0  5.0  15</code></pre><ol start="2"><li>通过函数分组</li></ol><pre><code class="python"># 通过函数分组df_obj3 = pd.DataFrame(np.random.randint(1, 10, (5,5)),                       columns=[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;],                       index=[&#39;AA&#39;, &#39;BBB&#39;, &#39;CC&#39;, &#39;D&#39;, &#39;EE&#39;])#df_obj3def group_key(idx):    &quot;&quot;&quot;        idx 为列索引或行索引    &quot;&quot;&quot;    #return idx    return len(idx)df_obj3.groupby(group_key).size()# 以上自定义函数等价于#df_obj3.groupby(len).size()</code></pre><pre><code>1    12    33    1dtype: int64</code></pre><ol start="3"><li>通过层级索引级别分组</li></ol><pre><code class="python"># 通过索引级别分组columns = pd.MultiIndex.from_arrays([[&#39;Python&#39;, &#39;Java&#39;, &#39;Python&#39;, &#39;Java&#39;, &#39;Python&#39;],                                     [&#39;A&#39;, &#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;B&#39;]], names=[&#39;language&#39;, &#39;index&#39;])df_obj4 = pd.DataFrame(np.random.randint(1, 10, (5, 5)), columns=columns)df_obj4</code></pre><table><thead><tr><th>language</th><th>Python</th><th>Java</th><th>Python</th><th>Java</th><th>Python</th></tr></thead><tbody><tr><td>index</td><td>A</td><td>A</td><td>B</td><td>C</td><td>B</td></tr><tr><td>0</td><td>4</td><td>6</td><td>8</td><td>8</td><td>4</td></tr><tr><td>1</td><td>1</td><td>3</td><td>2</td><td>3</td><td>5</td></tr><tr><td>2</td><td>3</td><td>1</td><td>1</td><td>5</td><td>6</td></tr><tr><td>3</td><td>2</td><td>9</td><td>3</td><td>1</td><td>9</td></tr><tr><td>4</td><td>4</td><td>1</td><td>5</td><td>6</td><td>6</td></tr></tbody></table><pre><code class="python"># 根据language进行分组df_obj4.groupby(level=&#39;language&#39;, axis=1).sum()df_obj4.groupby(level=&#39;index&#39;, axis=1).sum()</code></pre><table><thead><tr><th>index</th><th>A</th><th>B</th><th>C</th></tr></thead><tbody><tr><td>0</td><td>10</td><td>12</td><td>8</td></tr><tr><td>1</td><td>4</td><td>7</td><td>3</td></tr><tr><td>2</td><td>4</td><td>7</td><td>5</td></tr><tr><td>3</td><td>11</td><td>12</td><td>1</td></tr><tr><td>4</td><td>5</td><td>11</td><td>6</td></tr></tbody></table><h2 id="二、聚合"><a href="#二、聚合" class="headerlink" title="二、聚合"></a>二、聚合</h2><pre><code class="python">dict_obj = &#123;&#39;key1&#39; : [&#39;a&#39;, &#39;b&#39;, &#39;a&#39;, &#39;b&#39;,                      &#39;a&#39;, &#39;b&#39;, &#39;a&#39;, &#39;a&#39;],            &#39;key2&#39; : [&#39;one&#39;, &#39;one&#39;, &#39;two&#39;, &#39;three&#39;,                      &#39;two&#39;, &#39;two&#39;, &#39;one&#39;, &#39;three&#39;],            &#39;data1&#39;: np.random.randint(1,10, 8),            &#39;data2&#39;: np.random.randint(1,10, 8)&#125;df_obj5 = pd.DataFrame(dict_obj)print (df_obj5)</code></pre><pre><code>  key1   key2  data1  data20    a    one      9      41    b    one      6      72    a    two      9      43    b  three      9      64    a    two      6      25    b    two      3      36    a    one      1      17    a  three      2      6</code></pre><h3 id="内置的聚合函数"><a href="#内置的聚合函数" class="headerlink" title="内置的聚合函数"></a>内置的聚合函数</h3><pre><code class="python">df_obj5</code></pre><table><thead><tr><th></th><th>key1</th><th>key2</th><th>data1</th><th>data2</th></tr></thead><tbody><tr><td>0</td><td>a</td><td>one</td><td>9</td><td>4</td></tr><tr><td>1</td><td>b</td><td>one</td><td>6</td><td>7</td></tr><tr><td>2</td><td>a</td><td>two</td><td>9</td><td>4</td></tr><tr><td>3</td><td>b</td><td>three</td><td>9</td><td>6</td></tr><tr><td>4</td><td>a</td><td>two</td><td>6</td><td>2</td></tr><tr><td>5</td><td>b</td><td>two</td><td>3</td><td>3</td></tr><tr><td>6</td><td>a</td><td>one</td><td>1</td><td>1</td></tr><tr><td>7</td><td>a</td><td>three</td><td>2</td><td>6</td></tr></tbody></table><pre><code class="python"># 内置的聚合函数#print (df_obj5.groupby(&#39;key1&#39;).sum())#print (df_obj5.groupby(&#39;key1&#39;).max())#print (df_obj5.groupby(&#39;key1&#39;).min())print (df_obj5.groupby(&#39;key1&#39;).mean())#print (df_obj5.groupby(&#39;key1&#39;).size())#print (df_obj5.groupby(&#39;key1&#39;).count())#print (df_obj5.groupby(&#39;key1&#39;).describe())&#39;&#39;&#39;count：分组中非NA的值std：标准差var：方差median：非NA中的中位数mean：非NA的平均值25%||50%||75%是什么意思==不造？&#39;&#39;&#39;</code></pre><pre><code>      data1     data2key1a       5.4  3.400000b       6.0  5.333333&#39;\ncount：分组中非NA的值\nstd：标准差\nvar：方差\nmedian：非NA中的中位数\nmean：非NA的平均值\n25%||50%||75%是什么意思==不造？\n&#39;</code></pre><h3 id="自定义聚合函数"><a href="#自定义聚合函数" class="headerlink" title="自定义聚合函数"></a>自定义聚合函数</h3><pre><code class="python"># 自定义聚合函数def peak_range(df):    &quot;&quot;&quot;        返回数值范围    &quot;&quot;&quot;    #print type(df) #参数为索引所对应的记录    return df.max() - df.min()print (df_obj5.groupby(&#39;key1&#39;).agg(peak_range))#print df_obj.groupby(&#39;key1&#39;).agg(lambda df : df.max() - df.min())#默认列名就是函数名。</code></pre><pre><code>      data1  data2key1a         8      5b         6      4</code></pre><ol start="3"><li>同时应用多个聚合函数：agg</li></ol><pre><code class="python"># 同时应用多个聚合函数：aggprint (df_obj.groupby(&#39;key1&#39;).agg([&#39;mean&#39;, &#39;std&#39;, &#39;count&#39;]))</code></pre><pre><code>         data1                     data2          mean       std count      mean       std countkey1a     0.709792  0.674293     5 -0.224477  0.385674     5b    -0.244746  0.726957     3 -0.851723  1.528271     3</code></pre><pre><code class="python">print (df_obj.groupby(&#39;key1&#39;).agg([&#39;mean&#39;, &#39;std&#39;, &#39;count&#39;, (&#39;range&#39;, peak_range)])) # 通过元组提供新的列名</code></pre><pre><code>         data1                               data2          mean       std count     range      mean       std count     rangekey1a     0.709792  0.674293     5  1.686756 -0.224477  0.385674     5  0.978865b    -0.244746  0.726957     3  1.451857 -0.851723  1.528271     3  2.797850</code></pre><pre><code class="python"># 每列作用不同的聚合函数dict_mapping = &#123;&#39;data1&#39;:&#39;mean&#39;,                &#39;data2&#39;:&#39;sum&#39;&#125;print (df_obj.groupby(&#39;key1&#39;).agg(dict_mapping))</code></pre><pre><code>         data1     data2key1a     0.709792 -1.122384b    -0.244746 -2.555170</code></pre><pre><code class="python">dict_mapping = &#123;&#39;data1&#39;:[&#39;mean&#39;,&#39;max&#39;],                &#39;data2&#39;:&#39;sum&#39;&#125;print (df_obj.groupby(&#39;key1&#39;).agg(dict_mapping))</code></pre><pre><code>         data1               data2          mean       max       sumkey1a     0.709792  1.539144 -1.122384b    -0.244746  0.458871 -2.555170</code></pre><h2 id="三、分组运算"><a href="#三、分组运算" class="headerlink" title="三、分组运算"></a>三、分组运算</h2><pre><code class="python">import pandas as pdimport numpy as np</code></pre><h3 id="分组和对齐"><a href="#分组和对齐" class="headerlink" title="分组和对齐"></a>分组和对齐</h3><pre><code class="python">s1 = pd.Series(range(10, 20), index = range(10))s2 = pd.Series(range(20, 25), index = range(5))print (&#39;s1: &#39; )print (s1)print(&#39;===========================&#39;)print (&#39;s2: &#39;)print (s2)</code></pre><pre><code>s1:0    101    112    123    134    145    156    167    178    189    19dtype: int64===========================s2:0    201    212    223    234    24dtype: int64</code></pre><pre><code class="python"># Series 对齐运算s1 + s2print(s1+s2)</code></pre><pre><code>0    30.01    32.02    34.03    36.04    38.05     NaN6     NaN7     NaN8     NaN9     NaNdtype: float64</code></pre><pre><code class="python">df1 = pd.DataFrame(np.ones((2,2)), columns = [&#39;a&#39;, &#39;b&#39;])df2 = pd.DataFrame(np.ones((3,3)), columns = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;])print (&#39;df1: &#39;)print (df1)print (&#39;=================&#39;)print (&#39;df2: &#39;)print (df2)</code></pre><pre><code>df1:     a    b0  1.0  1.01  1.0  1.0=================df2:     a    b    c0  1.0  1.0  1.01  1.0  1.0  1.02  1.0  1.0  1.0</code></pre><pre><code class="python"># DataFrame对齐操作print(df1 + df2)</code></pre><pre><code>     a    b   c0  2.0  2.0 NaN1  2.0  2.0 NaN2  NaN  NaN NaN</code></pre><p>① 常用运算函数</p><pre><code class="python"># 填充未对齐的数据进行运算print(s1.add(s2, fill_value = -1))</code></pre><pre><code>0    30.01    32.02    34.03    36.04    38.05    14.06    15.07    16.08    17.09    18.0dtype: float64</code></pre><pre><code class="python">df1.sub(df2, fill_value = 2.)#sub函数</code></pre><table><thead><tr><th></th><th>a</th><th>b</th><th>c</th></tr></thead><tbody><tr><td>0</td><td>0.0</td><td>0.0</td><td>1.0</td></tr><tr><td>1</td><td>0.0</td><td>0.0</td><td>1.0</td></tr><tr><td>2</td><td>1.0</td><td>1.0</td><td>1.0</td></tr></tbody></table><pre><code class="python"># 填充NaNs3 = s1 + s2print (s3)</code></pre><pre><code>0    30.01    32.02    34.03    36.04    38.05     NaN6     NaN7     NaN8     NaN9     NaNdtype: float64</code></pre><pre><code class="python">s3_filled = s3.fillna(-1)print (s3)</code></pre><pre><code>0    30.01    32.02    34.03    36.04    38.05     NaN6     NaN7     NaN8     NaN9     NaNdtype: float64</code></pre><pre><code class="python">df3 = df1 + df2print (df3)</code></pre><pre><code>     a    b   c0  2.0  2.0 NaN1  2.0  2.0 NaN2  NaN  NaN NaN</code></pre><pre><code class="python">df3.fillna(100, inplace = True)print (df3)</code></pre><pre><code>       a      b      c0    2.0    2.0  100.01    2.0    2.0  100.02  100.0  100.0  100.0</code></pre><h3 id="统计计算-VS-聚合运算"><a href="#统计计算-VS-聚合运算" class="headerlink" title="统计计算 VS 聚合运算"></a>统计计算 VS 聚合运算</h3><pre><code class="python">df_obj1 = pd.DataFrame(np.random.randn(5,4), columns = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;])print(df_obj1)</code></pre><pre><code>          a         b         c         d0 -0.542708  0.201376  1.111431  1.7843241  0.583422  0.231096 -2.801967  0.5684972 -0.577329 -1.668581 -0.842126  1.8030803 -0.128431 -1.769619  2.089983  0.2097614  0.493981 -1.571405  0.690019 -0.215292</code></pre><pre><code class="python">print(df_obj1.sum(axis=1))print(&#39;=====================================&#39;)print(df_obj1.max())print(&#39;=====================================&#39;)print(df_obj1.min(axis=1))</code></pre><pre><code>0    2.5544231   -1.4189522   -1.2849563    0.4016944   -0.602698dtype: float64=====================================a    0.583422b    0.231096c    2.089983d    1.803080dtype: float64=====================================0   -0.5427081   -2.8019672   -1.6685813   -1.7696194   -1.571405dtype: float64</code></pre><h3 id="数据分组运算"><a href="#数据分组运算" class="headerlink" title="数据分组运算"></a>数据分组运算</h3><pre><code class="python"># 分组运算后保持shapedict_obj = &#123;&#39;key1&#39; : [&#39;a&#39;, &#39;b&#39;, &#39;a&#39;, &#39;b&#39;,                      &#39;a&#39;, &#39;b&#39;, &#39;a&#39;, &#39;a&#39;],            &#39;key2&#39; : [&#39;one&#39;, &#39;one&#39;, &#39;two&#39;, &#39;three&#39;,                      &#39;two&#39;, &#39;two&#39;, &#39;one&#39;, &#39;three&#39;],            &#39;data1&#39;: np.random.randint(1, 10, 8),            &#39;data2&#39;: np.random.randint(1, 10, 8)&#125;df_obj = pd.DataFrame(dict_obj)df_obj</code></pre><table><thead><tr><th></th><th>key1</th><th>key2</th><th>data1</th><th>data2</th></tr></thead><tbody><tr><td>0</td><td>a</td><td>one</td><td>4</td><td>3</td></tr><tr><td>1</td><td>b</td><td>one</td><td>4</td><td>4</td></tr><tr><td>2</td><td>a</td><td>two</td><td>9</td><td>6</td></tr><tr><td>3</td><td>b</td><td>three</td><td>8</td><td>2</td></tr><tr><td>4</td><td>a</td><td>two</td><td>3</td><td>3</td></tr><tr><td>5</td><td>b</td><td>two</td><td>6</td><td>2</td></tr><tr><td>6</td><td>a</td><td>one</td><td>4</td><td>1</td></tr><tr><td>7</td><td>a</td><td>three</td><td>2</td><td>2</td></tr></tbody></table><pre><code class="python"># 按key1分组后，计算data1，data2的统计信息======并附加到原始表格中k1_sum = df_obj.groupby(&#39;key1&#39;).sum().add_prefix(&#39;sum_&#39;)print(k1_sum)print(&#39;================================&#39;)print(df_obj)</code></pre><pre><code>      sum_data1  sum_data2key1a            22         15b            18          8================================  key1   key2  data1  data20    a    one      4      31    b    one      4      42    a    two      9      63    b  three      8      24    a    two      3      35    b    two      6      26    a    one      4      17    a  three      2      2</code></pre><ol><li>merge 方法</li></ol><pre><code class="python"># 方法1，使用mergepd.merge(df_obj, k1_sum, left_on=&#39;key1&#39;, right_index=True)</code></pre><table><thead><tr><th></th><th>key1</th><th>key2</th><th>data1</th><th>data2</th><th>sum_data1</th><th>sum_data2</th></tr></thead><tbody><tr><td>0</td><td>a</td><td>one</td><td>4</td><td>3</td><td>22</td><td>15</td></tr><tr><td>2</td><td>a</td><td>two</td><td>9</td><td>6</td><td>22</td><td>15</td></tr><tr><td>4</td><td>a</td><td>two</td><td>3</td><td>3</td><td>22</td><td>15</td></tr><tr><td>6</td><td>a</td><td>one</td><td>4</td><td>1</td><td>22</td><td>15</td></tr><tr><td>7</td><td>a</td><td>three</td><td>2</td><td>2</td><td>22</td><td>15</td></tr><tr><td>1</td><td>b</td><td>one</td><td>4</td><td>4</td><td>18</td><td>8</td></tr><tr><td>3</td><td>b</td><td>three</td><td>8</td><td>2</td><td>18</td><td>8</td></tr><tr><td>5</td><td>b</td><td>two</td><td>6</td><td>2</td><td>18</td><td>8</td></tr></tbody></table><ol start="2"><li>transform 方法</li></ol><pre><code class="python"># 方法2，使用transformk1_sum_tf = df_obj.groupby(&#39;key1&#39;).transform(np.sum).add_prefix(&#39;sum_&#39;)df_obj[k1_sum_tf.columns] = k1_sum_tfdf_obj</code></pre><table><thead><tr><th></th><th>key1</th><th>key2</th><th>data1</th><th>data2</th><th>sum_key2</th><th>sum_data1</th><th>sum_data2</th></tr></thead><tbody><tr><td>0</td><td>a</td><td>one</td><td>4</td><td>3</td><td>onetwotwoonethree</td><td>22</td><td>15</td></tr><tr><td>1</td><td>b</td><td>one</td><td>4</td><td>4</td><td>onethreetwo</td><td>18</td><td>8</td></tr><tr><td>2</td><td>a</td><td>two</td><td>9</td><td>6</td><td>onetwotwoonethree</td><td>22</td><td>15</td></tr><tr><td>3</td><td>b</td><td>three</td><td>8</td><td>2</td><td>onethreetwo</td><td>18</td><td>8</td></tr><tr><td>4</td><td>a</td><td>two</td><td>3</td><td>3</td><td>onetwotwoonethree</td><td>22</td><td>15</td></tr><tr><td>5</td><td>b</td><td>two</td><td>6</td><td>2</td><td>onethreetwo</td><td>18</td><td>8</td></tr><tr><td>6</td><td>a</td><td>one</td><td>4</td><td>1</td><td>onetwotwoonethree</td><td>22</td><td>15</td></tr><tr><td>7</td><td>a</td><td>three</td><td>2</td><td>2</td><td>onetwotwoonethree</td><td>22</td><td>15</td></tr></tbody></table><ol start="3"><li>自定义函数</li></ol><pre><code class="python"># 自定义函数传入transformdef diff_mean(s):    &quot;&quot;&quot;        返回数据与均值的差值    &quot;&quot;&quot;    return s - s.mean()df_obj.groupby(&#39;key1&#39;).transform(diff_mean)</code></pre><table><thead><tr><th></th><th>data1</th><th>data2</th><th>sum_data1</th><th>sum_data2</th></tr></thead><tbody><tr><td>0</td><td>-0.4</td><td>0.000000</td><td>0</td><td>0</td></tr><tr><td>1</td><td>-2.0</td><td>1.333333</td><td>0</td><td>0</td></tr><tr><td>2</td><td>4.6</td><td>3.000000</td><td>0</td><td>0</td></tr><tr><td>3</td><td>2.0</td><td>-0.666667</td><td>0</td><td>0</td></tr><tr><td>4</td><td>-1.4</td><td>0.000000</td><td>0</td><td>0</td></tr><tr><td>5</td><td>0.0</td><td>-0.666667</td><td>0</td><td>0</td></tr><tr><td>6</td><td>-0.4</td><td>-2.000000</td><td>0</td><td>0</td></tr><tr><td>7</td><td>-2.4</td><td>-1.000000</td><td>0</td><td>0</td></tr></tbody></table><pre><code class="python">dataset_path = &#39;./data/starcraft.csv&#39;df_data = pd.read_csv(dataset_path, usecols=[&#39;LeagueIndex&#39;, &#39;Age&#39;, &#39;HoursPerWeek&#39;,                                             &#39;TotalHours&#39;, &#39;APM&#39;])</code></pre><ul><li>apply</li></ul><pre><code class="python">def top_n(df, n=3, column=&#39;APM&#39;):    &quot;&quot;&quot;        返回每个分组按 column 的 top n 数据    &quot;&quot;&quot;    return df.sort_values(by=column, ascending=False)[:n]df_data.groupby(&#39;LeagueIndex&#39;).apply(top_n)</code></pre><table><thead><tr><th></th><th></th><th>LeagueIndex</th><th>Age</th><th>HoursPerWeek</th><th>TotalHours</th><th>APM</th></tr></thead><tbody><tr><td>LeagueIndex</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>1</td><td>2214</td><td>1</td><td>20.0</td><td>12.0</td><td>730.0</td><td>172.9530</td></tr><tr><td></td><td>2246</td><td>1</td><td>27.0</td><td>8.0</td><td>250.0</td><td>141.6282</td></tr><tr><td></td><td>1753</td><td>1</td><td>20.0</td><td>28.0</td><td>100.0</td><td>139.6362</td></tr><tr><td>2</td><td>3062</td><td>2</td><td>20.0</td><td>6.0</td><td>100.0</td><td>179.6250</td></tr><tr><td></td><td>3229</td><td>2</td><td>16.0</td><td>24.0</td><td>110.0</td><td>156.7380</td></tr><tr><td></td><td>1520</td><td>2</td><td>29.0</td><td>6.0</td><td>250.0</td><td>151.6470</td></tr><tr><td>3</td><td>1557</td><td>3</td><td>22.0</td><td>6.0</td><td>200.0</td><td>226.6554</td></tr><tr><td></td><td>484</td><td>3</td><td>19.0</td><td>42.0</td><td>450.0</td><td>220.0692</td></tr><tr><td></td><td>2883</td><td>3</td><td>16.0</td><td>8.0</td><td>800.0</td><td>208.9500</td></tr><tr><td>4</td><td>2688</td><td>4</td><td>26.0</td><td>24.0</td><td>990.0</td><td>249.0210</td></tr><tr><td></td><td>1759</td><td>4</td><td>16.0</td><td>6.0</td><td>75.0</td><td>229.9122</td></tr><tr><td></td><td>2637</td><td>4</td><td>23.0</td><td>24.0</td><td>650.0</td><td>227.2272</td></tr><tr><td>5</td><td>3277</td><td>5</td><td>18.0</td><td>16.0</td><td>950.0</td><td>372.6426</td></tr><tr><td></td><td>93</td><td>5</td><td>17.0</td><td>36.0</td><td>720.0</td><td>335.4990</td></tr><tr><td></td><td>202</td><td>5</td><td>37.0</td><td>14.0</td><td>800.0</td><td>327.7218</td></tr><tr><td>6</td><td>734</td><td>6</td><td>16.0</td><td>28.0</td><td>730.0</td><td>389.8314</td></tr><tr><td></td><td>2746</td><td>6</td><td>16.0</td><td>28.0</td><td>4000.0</td><td>350.4114</td></tr><tr><td></td><td>1810</td><td>6</td><td>21.0</td><td>14.0</td><td>730.0</td><td>323.2506</td></tr><tr><td>7</td><td>3127</td><td>7</td><td>23.0</td><td>42.0</td><td>2000.0</td><td>298.7952</td></tr><tr><td></td><td>104</td><td>7</td><td>21.0</td><td>24.0</td><td>1000.0</td><td>286.4538</td></tr><tr><td></td><td>1654</td><td>7</td><td>18.0</td><td>98.0</td><td>700.0</td><td>236.0316</td></tr><tr><td>8</td><td>3393</td><td>8</td><td>NaN</td><td>NaN</td><td>NaN</td><td>375.8664</td></tr><tr><td></td><td>3373</td><td>8</td><td>NaN</td><td>NaN</td><td>NaN</td><td>364.8504</td></tr><tr><td></td><td>3372</td><td>8</td><td>NaN</td><td>NaN</td><td>NaN</td><td>355.3518</td></tr></tbody></table><pre><code class="python"># apply函数接收的参数会传入自定义的函数中df_data.groupby(&#39;LeagueIndex&#39;).apply(top_n, n=2, column=&#39;Age&#39;)</code></pre><table><thead><tr><th></th><th></th><th>LeagueIndex</th><th>Age</th><th>HoursPerWeek</th><th>TotalHours</th><th>APM</th></tr></thead><tbody><tr><td>LeagueIndex</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>1</td><td>3146</td><td>1</td><td>40.0</td><td>12.0</td><td>150.0</td><td>38.5590</td></tr><tr><td></td><td>3040</td><td>1</td><td>39.0</td><td>10.0</td><td>500.0</td><td>29.8764</td></tr><tr><td>2</td><td>920</td><td>2</td><td>43.0</td><td>10.0</td><td>730.0</td><td>86.0586</td></tr><tr><td></td><td>2437</td><td>2</td><td>41.0</td><td>4.0</td><td>200.0</td><td>54.2166</td></tr><tr><td>3</td><td>1258</td><td>3</td><td>41.0</td><td>14.0</td><td>800.0</td><td>77.6472</td></tr><tr><td></td><td>2972</td><td>3</td><td>40.0</td><td>10.0</td><td>500.0</td><td>60.5970</td></tr><tr><td>4</td><td>1696</td><td>4</td><td>44.0</td><td>6.0</td><td>500.0</td><td>89.5266</td></tr><tr><td></td><td>1729</td><td>4</td><td>39.0</td><td>8.0</td><td>500.0</td><td>86.7246</td></tr><tr><td>5</td><td>202</td><td>5</td><td>37.0</td><td>14.0</td><td>800.0</td><td>327.7218</td></tr><tr><td></td><td>2745</td><td>5</td><td>37.0</td><td>18.0</td><td>1000.0</td><td>123.4098</td></tr><tr><td>6</td><td>3069</td><td>6</td><td>31.0</td><td>8.0</td><td>800.0</td><td>133.1790</td></tr><tr><td></td><td>2706</td><td>6</td><td>31.0</td><td>8.0</td><td>700.0</td><td>66.9918</td></tr><tr><td>7</td><td>2813</td><td>7</td><td>26.0</td><td>36.0</td><td>1300.0</td><td>188.5512</td></tr><tr><td></td><td>1992</td><td>7</td><td>26.0</td><td>24.0</td><td>1000.0</td><td>219.6690</td></tr><tr><td>8</td><td>3340</td><td>8</td><td>NaN</td><td>NaN</td><td>NaN</td><td>189.7404</td></tr><tr><td></td><td>3341</td><td>8</td><td>NaN</td><td>NaN</td><td>NaN</td><td>287.8128</td></tr></tbody></table><ul><li>禁止分组 group_keys=False</li></ul><pre><code class="python">df_data.groupby(&#39;LeagueIndex&#39;, group_keys=False).apply(top_n)</code></pre><table><thead><tr><th></th><th>LeagueIndex</th><th>Age</th><th>HoursPerWeek</th><th>TotalHours</th><th>APM</th></tr></thead><tbody><tr><td>2214</td><td>1</td><td>20.0</td><td>12.0</td><td>730.0</td><td>172.9530</td></tr><tr><td>2246</td><td>1</td><td>27.0</td><td>8.0</td><td>250.0</td><td>141.6282</td></tr><tr><td>1753</td><td>1</td><td>20.0</td><td>28.0</td><td>100.0</td><td>139.6362</td></tr><tr><td>3062</td><td>2</td><td>20.0</td><td>6.0</td><td>100.0</td><td>179.6250</td></tr><tr><td>3229</td><td>2</td><td>16.0</td><td>24.0</td><td>110.0</td><td>156.7380</td></tr><tr><td>1520</td><td>2</td><td>29.0</td><td>6.0</td><td>250.0</td><td>151.6470</td></tr><tr><td>1557</td><td>3</td><td>22.0</td><td>6.0</td><td>200.0</td><td>226.6554</td></tr><tr><td>484</td><td>3</td><td>19.0</td><td>42.0</td><td>450.0</td><td>220.0692</td></tr><tr><td>2883</td><td>3</td><td>16.0</td><td>8.0</td><td>800.0</td><td>208.9500</td></tr><tr><td>2688</td><td>4</td><td>26.0</td><td>24.0</td><td>990.0</td><td>249.0210</td></tr><tr><td>1759</td><td>4</td><td>16.0</td><td>6.0</td><td>75.0</td><td>229.9122</td></tr><tr><td>2637</td><td>4</td><td>23.0</td><td>24.0</td><td>650.0</td><td>227.2272</td></tr><tr><td>3277</td><td>5</td><td>18.0</td><td>16.0</td><td>950.0</td><td>372.6426</td></tr><tr><td>93</td><td>5</td><td>17.0</td><td>36.0</td><td>720.0</td><td>335.4990</td></tr><tr><td>202</td><td>5</td><td>37.0</td><td>14.0</td><td>800.0</td><td>327.7218</td></tr><tr><td>734</td><td>6</td><td>16.0</td><td>28.0</td><td>730.0</td><td>389.8314</td></tr><tr><td>2746</td><td>6</td><td>16.0</td><td>28.0</td><td>4000.0</td><td>350.4114</td></tr><tr><td>1810</td><td>6</td><td>21.0</td><td>14.0</td><td>730.0</td><td>323.2506</td></tr><tr><td>3127</td><td>7</td><td>23.0</td><td>42.0</td><td>2000.0</td><td>298.7952</td></tr><tr><td>104</td><td>7</td><td>21.0</td><td>24.0</td><td>1000.0</td><td>286.4538</td></tr><tr><td>1654</td><td>7</td><td>18.0</td><td>98.0</td><td>700.0</td><td>236.0316</td></tr><tr><td>3393</td><td>8</td><td>NaN</td><td>NaN</td><td>NaN</td><td>375.8664</td></tr><tr><td>3373</td><td>8</td><td>NaN</td><td>NaN</td><td>NaN</td><td>364.8504</td></tr><tr><td>3372</td><td>8</td><td>NaN</td><td>NaN</td><td>NaN</td><td>355.3518</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> DataAnalysis </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Pandas使用——各种索引</title>
      <link href="blog/nfqdqf/"/>
      <url>blog/nfqdqf/</url>
      
        <content type="html"><![CDATA[<h2 id="一、基本索引"><a href="#一、基本索引" class="headerlink" title="一、基本索引"></a>一、基本索引</h2><pre><code class="python">import pandas as pdimport numpy as np</code></pre><h3 id="Series-索引"><a href="#Series-索引" class="headerlink" title="Series 索引"></a>Series 索引</h3><pre><code class="python">ser_obj1 = pd.Series(range(5), index = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;])print (ser_obj1.head())</code></pre><pre><code>a    0b    1c    2d    3e    4dtype: int64</code></pre><pre><code class="python">&#39;&#39;&#39;1. 行索引&#39;&#39;&#39;print(&#39;行索引====================================================================&#39;)print (ser_obj1[&#39;b&#39;])print (ser_obj1[0])print(&#39;切片索引====================================================================&#39;)&#39;&#39;&#39;2. 切片索引&#39;&#39;&#39;print (ser_obj1[1:3])print (ser_obj1[&#39;b&#39;:&#39;d&#39;])print(&#39;不连续索引索引====================================================================&#39;)#注意会不会包含尾巴。。&#39;&#39;&#39;3. 不连续索引&#39;&#39;&#39;print (ser_obj1[[0, 2, 4]])print (ser_obj1[[&#39;a&#39;, &#39;e&#39;]])print(&#39;布尔索引====================================================================&#39;)&#39;&#39;&#39;4. 布尔索引&#39;&#39;&#39;#是对里面的值进行判断，不是对索引ser_bool = ser_obj1 &gt; 2print (ser_bool)print (ser_obj1[ser_bool])#运用的方式print (ser_obj1[ser_obj1 &gt; 2])</code></pre><pre><code>行索引====================================================================10切片索引====================================================================b    1c    2dtype: int64b    1c    2d    3dtype: int64不连续索引索引====================================================================a    0c    2e    4dtype: int64a    0e    4dtype: int64布尔索引====================================================================a    Falseb    Falsec    Falsed     Truee     Truedtype: boold    3e    4dtype: int64d    3e    4dtype: int64</code></pre><h3 id="Dataframe-索引"><a href="#Dataframe-索引" class="headerlink" title="Dataframe 索引"></a>Dataframe 索引</h3><pre><code class="python">df_obj1 = pd.DataFrame(np.random.randn(5,4), columns = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;])print (df_obj1.head())</code></pre><pre><code>          a         b         c         d0 -0.720611 -0.002543 -0.084255 -0.5837191  0.174715  0.288090 -0.254462 -1.6696682 -1.872654 -0.466842 -0.481040 -1.7355583  1.147668  1.205686  0.625582 -2.1118634  1.177882  0.049581 -0.404098 -0.497125</code></pre><pre><code class="python">&#39;&#39;&#39;0. 转换成行索引的话===方式一：transpose或者T&#39;&#39;&#39;bb=df_obj1.transpose()print(df_obj1.T)print(bb)&#39;&#39;&#39;0. 转换成行索引的话===方式二：重构&#39;&#39;&#39;</code></pre><pre><code>          0         1         2         3         4a -0.720611  0.174715 -1.872654  1.147668  1.177882b -0.002543  0.288090 -0.466842  1.205686  0.049581c -0.084255 -0.254462 -0.481040  0.625582 -0.404098d -0.583719 -1.669668 -1.735558 -2.111863 -0.497125          0         1         2         3         4a -0.720611  0.174715 -1.872654  1.147668  1.177882b -0.002543  0.288090 -0.466842  1.205686  0.049581c -0.084255 -0.254462 -0.481040  0.625582 -0.404098d -0.583719 -1.669668 -1.735558 -2.111863 -0.497125&#39;0. 转换成行索引的话===方式二：重构/重塑===还没有完全明白&#39;</code></pre><pre><code class="python">&#39;&#39;&#39;1. 列索引=====默认为列索引来操作&#39;&#39;&#39;print (&#39;列索引&#39;)print(df_obj1.b)#当成属性来获取值print(&#39;===================&#39;)print (df_obj1[&#39;a&#39;]) # 返回Series类型print (type(df_obj1[&#39;a&#39;]))print (df_obj1[[&#39;a&#39;]]) # 返回DataFrame类型print (type(df_obj1[[&#39;a&#39;]]))&#39;&#39;&#39;2. 不连续索引&#39;&#39;&#39;print (&#39;不连续索引&#39;)print (df_obj1[[&#39;a&#39;,&#39;c&#39;]])print (df_obj1[[&#39;a&#39;,&#39;c&#39;]])</code></pre><pre><code>列索引0   -0.0025431    0.2880902   -0.4668423    1.2056864    0.049581Name: b, dtype: float64===================0   -0.7206111    0.1747152   -1.8726543    1.1476684    1.177882Name: a, dtype: float64&lt;class &#39;pandas.core.series.Series&#39;&gt;          a0 -0.7206111  0.1747152 -1.8726543  1.1476684  1.177882&lt;class &#39;pandas.core.frame.DataFrame&#39;&gt;不连续索引          a         c0 -0.720611 -0.0842551  0.174715 -0.2544622 -1.872654 -0.4810403  1.147668  0.6255824  1.177882 -0.404098          a         c0 -0.720611 -0.0842551  0.174715 -0.2544622 -1.872654 -0.4810403  1.147668  0.6255824  1.177882 -0.404098</code></pre><h3 id="三种索引方式"><a href="#三种索引方式" class="headerlink" title="三种索引方式"></a>三种索引方式</h3><pre><code class="python">print(ser_obj1)print(&#39;============================&#39;)print(df_obj1)</code></pre><pre><code>a    0b    1c    2d    3e    4dtype: int64============================          a         b         c         d0 -0.720611 -0.002543 -0.084255 -0.5837191  0.174715  0.288090 -0.254462 -1.6696682 -1.872654 -0.466842 -0.481040 -1.7355583  1.147668  1.205686  0.625582 -2.1118634  1.177882  0.049581 -0.404098 -0.497125</code></pre><pre><code class="python">&#39;&#39;&#39;1. 标签索引 loc===用的是index和column的值索引【标签索引】&#39;&#39;&#39;# Seriesprint (ser_obj1[&#39;b&#39;:&#39;d&#39;])print (ser_obj1.loc[&#39;b&#39;:&#39;d&#39;])# DataFrameprint (df_obj1[[&#39;a&#39;]])print (df_obj1.loc[0:2,&#39;a&#39;:&#39;c&#39;])</code></pre><pre><code>b    1c    2d    3dtype: int64b    1c    2d    3dtype: int64          a0 -0.7206111  0.1747152 -1.8726543  1.1476684  1.177882          a         b         c0 -0.720611 -0.002543 -0.0842551  0.174715  0.288090 -0.2544622 -1.872654 -0.466842 -0.481040</code></pre><pre><code class="python">&#39;&#39;&#39;2. 位置索引 iloc====用的是index和column的默认0，1，2，3···的值索引【位置索引】&#39;&#39;&#39;print (ser_obj1[1:3])print (ser_obj1.iloc[1:3])# DataFrameprint (df_obj1.iloc[0:2, 0:2])# 注意和df_obj.loc[0:2, &#39;a&#39;]的区别 = = = 行和列：都不包括尾巴</code></pre><pre><code>b    1c    2dtype: int64b    1c    2dtype: int64          a         b0 -0.720611 -0.0025431  0.174715  0.288090</code></pre><pre><code class="python">&#39;&#39;&#39;3. 混合索引 ix===先按标签索引loc尝试操作，然后再按位置索引iloc尝试操作&#39;&#39;&#39;print (ser_obj1.ix[1:3])print (ser_obj1.ix[&#39;b&#39;:&#39;c&#39;])# DataFrameprint (df_obj1.ix[0:2, 0:3])</code></pre><pre><code>b    1c    2dtype: int64b    1c    2dtype: int64          a         b         c0 -0.720611 -0.002543 -0.0842551  0.174715  0.288090 -0.2544622 -1.872654 -0.466842 -0.481040</code></pre><h2 id="二、Pandas-层级索引"><a href="#二、Pandas-层级索引" class="headerlink" title="二、Pandas 层级索引"></a>二、Pandas 层级索引</h2><h3 id="构造层级索引"><a href="#构造层级索引" class="headerlink" title="构造层级索引"></a>构造层级索引</h3><pre><code class="python">ser_obj = pd.Series(np.random.randn(12),                    index=[[&#39;a&#39;, &#39;a&#39;, &#39;a&#39;, &#39;b&#39;, &#39;b&#39;, &#39;b&#39;, &#39;c&#39;, &#39;c&#39;, &#39;c&#39;, &#39;d&#39;, &#39;d&#39;, &#39;d&#39;],                           [0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2]])#列表里面的列表print (ser_obj)</code></pre><pre><code>a  0   -0.373441   1    0.615976   2    0.959092b  0    1.743670   1   -0.791517   2   -0.774013c  0    1.271094   1   -0.723264   2    0.253038d  0   -0.767791   1    0.419253   2   -0.691644dtype: float64</code></pre><ul><li>MultiIndex 索引对象</li></ul><pre><code class="python">print (type(ser_obj.index))print (ser_obj.index)</code></pre><pre><code>&lt;class &#39;pandas.core.indexes.multi.MultiIndex&#39;&gt;MultiIndex([(&#39;a&#39;, 0),            (&#39;a&#39;, 1),            (&#39;a&#39;, 2),            (&#39;b&#39;, 0),            (&#39;b&#39;, 1),            (&#39;b&#39;, 2),            (&#39;c&#39;, 0),            (&#39;c&#39;, 1),            (&#39;c&#39;, 2),            (&#39;d&#39;, 0),            (&#39;d&#39;, 1),            (&#39;d&#39;, 2)],           )</code></pre><h3 id="选取子集"><a href="#选取子集" class="headerlink" title="选取子集"></a>选取子集</h3><pre><code class="python"># 外层选取print (ser_obj[&#39;c&#39;])</code></pre><pre><code>0    1.2710941   -0.7232642    0.253038dtype: float64</code></pre><pre><code class="python"># 内层选取print (ser_obj[:, 2])</code></pre><pre><code>a    0.959092b   -0.774013c    0.253038d   -0.691644dtype: float64</code></pre><h3 id="交换分层顺序"><a href="#交换分层顺序" class="headerlink" title="交换分层顺序"></a>交换分层顺序</h3><pre><code class="python">df_obj2 = pd.DataFrame(np.random.randn(6,4), columns = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;],index=[[&#39;a&#39;, &#39;a&#39;, &#39;a&#39;, &#39;b&#39;, &#39;b&#39;,&#39;b&#39;],[1, 2, 3, 1, 2,3]])#print (df_obj1.swaplevel())print (df_obj2)</code></pre><pre><code>            a         b         c         da 1  0.273776 -0.018659  1.512727 -0.088091  2 -0.410883 -1.488943  0.917268  1.179941  3 -0.237532 -0.823717  0.189495  1.060476b 1  0.727872  0.323352  0.443786  0.780510  2 -1.407645 -0.059689  1.439843 -1.700740  3 -0.377628 -0.137348 -0.739980  0.122528</code></pre><h3 id="交换并排序分层"><a href="#交换并排序分层" class="headerlink" title="交换并排序分层"></a>交换并排序分层</h3><pre><code class="python">print (df_obj2.swaplevel().sortvalues(by=&#39;a&#39;))#Series没有这个内置函数sortlevel===dataframe有</code></pre><h2 id="三、透视表和交叉表"><a href="#三、透视表和交叉表" class="headerlink" title="三、透视表和交叉表"></a>三、透视表和交叉表</h2><pre><code class="python">dataset_path = &#39;./data/starcraft.csv&#39;df_data = pd.read_csv(dataset_path, usecols=[&#39;LeagueIndex&#39;, &#39;Age&#39;, &#39;HoursPerWeek&#39;,                                             &#39;TotalHours&#39;, &#39;APM&#39;])print(df_data.head())</code></pre><pre><code>   LeagueIndex   Age  HoursPerWeek  TotalHours       APM0            5  27.0          10.0      3000.0  143.71801            5  23.0          10.0      5000.0  129.23222            4  30.0          10.0       200.0   69.96123            3  19.0          20.0       400.0  107.60164            3  32.0          10.0       500.0  122.8908</code></pre><h3 id="透视表"><a href="#透视表" class="headerlink" title="透视表"></a>透视表</h3><pre><code class="python">pd.pivot_table(df_data,               index=[&#39;Age&#39;],               columns=[&#39;LeagueIndex&#39;],               aggfunc=np.sum)</code></pre><p>|             | APM        | HoursPerWeek | TotalHours |<br>| ———– | ———- | ———— | ———- | ———- | ———– | ———- | ——— | —– | —– | —– | — | —— | —— | —– | —— | ——- | ——- | ——- | ——— | ——– | ——- |<br>| LeagueIndex | 1          | 2            | 3          | 4          | 5           | 6          | 7         | 1     | 2     | 3     | … | 5      | 6      | 7     | 1      | 2       | 3       | 4       | 5         | 6        | 7       |<br>| Age         |            |              |            |            |             |            |           |       |       |       |     |        |        |       |        |         |         |         |           |          |         |<br>| 16.0        | 1062.44754 | 2919.70434   | 4851.9222  | 5149.7310  | 7787.37780  | 9042.1722  | 386.7774  | 324.0 | 720.0 | 778.0 | … | 1220.0 | 1280.0 | 56.0  | 4307.0 | 13143.0 | 29211.0 | 23581.0 | 49233.0   | 51320.0  | 3000.0  |<br>| 17.0        | 655.67280  | 1661.01540   | 4181.8920  | 5525.3586  | 10052.72100 | 8310.0858  | 573.8286  | 184.0 | 378.0 | 664.0 | … | 1460.0 | 1116.0 | 104.0 | 2044.0 | 7423.0  | 16602.0 | 24005.0 | 53375.0   | 45421.0  | 12700.0 |<br>| 18.0        | 704.47680  | 3300.41040   | 4847.2152  | 8763.0783  | 10988.66100 | 9134.7240  | 618.5790  | 204.0 | 548.0 | 886.0 | … | 1644.0 | 1194.0 | 164.0 | 3570.0 | 11471.0 | 21037.0 | 46034.0 | 1056486.0 | 50378.0  | 3200.0  |<br>| 19.0        | 734.55600  | 2216.81880   | 5183.7888  | 8030.1960  | 9271.09260  | 11955.6030 | 696.7770  | 126.0 | 458.0 | 950.0 | … | 962.0  | 1642.0 | 168.0 | 2355.0 | 8467.0  | 31861.0 | 39705.0 | 44697.0   | 70331.0  | 4166.0  |<br>| 20.0        | 1624.89660 | 2147.23200   | 4211.5686  | 10596.2070 | 10871.65440 | 14291.8692 | NaN       | 328.0 | 288.0 | 654.0 | … | 1290.0 | 1816.0 | NaN   | 7212.0 | 6325.0  | 20174.0 | 55083.0 | 64170.0   | 105131.0 | NaN     |<br>| 21.0        | 780.67950  | 1578.02880   | 3949.3062  | 8689.8804  | 11954.91660 | 13165.7649 | 867.3474  | 162.0 | 270.0 | 580.0 | … | 1446.0 | 1858.0 | 62.0  | 3377.0 | 7673.0  | 19095.0 | 42296.0 | 68739.0   | 82061.0  | 3180.0  |<br>| 22.0        | 674.59860  | 2147.50980   | 4379.3424  | 7818.7302  | 10473.28380 | 10165.8672 | 493.1586  | 146.0 | 372.0 | 680.0 | … | 1304.0 | 1448.0 | 112.0 | 4225.0 | 10861.0 | 23030.0 | 57996.0 | 84330.0   | 67069.0  | 6950.0  |<br>| 23.0        | 359.65980  | 1575.06120   | 4602.7416  | 7616.9298  | 8292.86160  | 6131.1936  | 1799.6520 | 46.0  | 320.0 | 598.0 | … | 998.0  | 726.0  | 296.0 | 896.0  | 12350.0 | 23081.0 | 40025.0 | 56097.0   | 43176.0  | 14290.0 |<br>| 24.0        | 439.43040  | 1717.55340   | 2876.8572  | 5503.7736  | 7292.32740  | 7240.4076  | 428.6538  | 116.0 | 344.0 | 406.0 | … | 668.0  | 1048.0 | 36.0  | 2070.0 | 9543.0  | 25421.0 | 35384.0 | 36147.0   | 43114.0  | 2250.0  |<br>| 25.0        | 572.61420  | 1178.02440   | 2201.6388  | 4710.9924  | 6168.19260  | 2200.6362  | 361.4550  | 124.0 | 166.0 | 268.0 | … | 682.0  | 256.0  | 52.0  | 2440.0 | 5846.0  | 11270.0 | 26610.0 | 40681.0   | 14890.0  | 3300.0  |<br>| 26.0        | 418.70874  | 1165.96680   | 1794.1890  | 3139.2852  | 4016.67060  | 3301.8498  | 408.2202  | 96.0  | 148.0 | 272.0 | … | 418.0  | 354.0  | 60.0  | 1608.0 | 3417.0  | 10548.0 | 16839.0 | 20100.0   | 17663.0  | 2300.0  |<br>| 27.0        | 359.17320  | 1164.15960   | 1426.4550  | 2850.1320  | 3498.30300  | 2040.8454  | NaN       | 40.0  | 152.0 | 226.0 | … | 340.0  | 164.0  | NaN   | 1100.0 | 3615.0  | 7525.0  | 15935.0 | 19770.0   | 11796.0  | NaN     |<br>| 28.0        | 333.84240  | 479.34000    | 1152.5958  | 2205.8778  | 1992.60540  | 521.7666   | NaN       | 28.0  | 90.0  | 220.0 | … | 186.0  | 44.0   | NaN   | 466.0  | 1860.0  | 7901.0  | 15370.0 | 10872.0   | 2500.0   | NaN     |<br>| 29.0        | 236.74020  | 695.88480    | 568.2594   | 1447.5906  | 1398.78540  | 715.9404   | NaN       | 54.0  | 56.0  | 80.0  | … | 180.0  | 106.0  | NaN   | 2490.0 | 2000.0  | 3816.0  | 8220.0  | 10292.0   | 5950.0   | NaN     |<br>| 30.0        | 125.53740  | 441.14160    | 733.6416   | 743.4468   | 578.32020   | 123.3774   | NaN       | 14.0  | 54.0  | 76.0  | … | 90.0   | 28.0   | NaN   | 210.0  | 2440.0  | 4370.0  | 6310.0  | 3440.0    | 1500.0   | NaN     |<br>| 31.0        | 41.58600   | 314.92980    | 659.2626   | 1166.7606  | 315.53460   | 200.1708   | NaN       | 12.0  | 36.0  | 68.0  | … | 12.0   | 16.0   | NaN   | 200.0  | 1300.0  | 3500.0  | 8710.0  | 1050.0    | 1500.0   | NaN     |<br>| 32.0        | 179.14380  | 315.54180    | 457.5174   | 541.8996   | 66.19740    | NaN        | NaN       | 40.0  | 56.0  | 68.0  | … | 10.0   | NaN    | NaN   | 1600.0 | 860.0   | 2300.0  | 6040.0  | 800.0     | NaN      | NaN     |<br>| 33.0        | 198.77880  | 153.34680    | 284.8218   | 116.7516   | 245.45166   | NaN        | NaN       | 32.0  | 12.0  | 42.0  | … | 60.0   | NaN    | NaN   | 1200.0 | 220.0   | 2065.0  | 1130.0  | 2050.0    | NaN      | NaN     |<br>| 34.0        | 49.11360   | 276.88260    | 268.4100   | 340.7124   | 174.54540   | NaN        | NaN       | 12.0  | 56.0  | 28.0  | … | 14.0   | NaN    | NaN   | 150.0  | 3380.0  | 1150.0  | 2400.0  | 2764.0    | NaN      | NaN     |<br>| 35.0        | 229.31280  | 54.04680     | 170.4930   | 634.7688   | 115.06440   | NaN        | NaN       | 54.0  | 8.0   | 26.0  | … | 12.0   | NaN    | NaN   | 1350.0 | 500.0   | 1950.0  | 3800.0  | 800.0     | NaN      | NaN     |<br>| 36.0        | NaN        | 150.13140    | 333.6474   | 73.6980    | NaN         | NaN        | NaN       | NaN   | 16.0  | 40.0  | … | NaN    | NaN    | NaN   | NaN    | 500.0   | 1950.0  | 400.0   | NaN       | NaN      | NaN     |<br>| 37.0        | 22.05960   | 49.89600     | 44.9682    | NaN        | 451.13160   | NaN        | NaN       | 12.0  | 30.0  | 6.0   | … | 32.0   | NaN    | NaN   | 300.0  | 125.0   | 600.0   | NaN     | 1800.0    | NaN      | NaN     |<br>| 38.0        | 71.59500   | NaN          | 334.6878   | NaN        | NaN         | NaN        | NaN       | 16.0  | NaN   | 46.0  | … | NaN    | NaN    | NaN   | 300.0  | NaN     | 2280.0  | NaN     | NaN       | NaN      | NaN     |<br>| 39.0        | 29.87640   | NaN          | 53.7690    | 86.7246    | NaN         | NaN        | NaN       | 10.0  | NaN   | 12.0  | … | NaN    | NaN    | NaN   | 500.0  | NaN     | 450.0   | 500.0   | NaN       | NaN      | NaN     |<br>| 40.0        | 38.55900   | 51.83580     | 107.4684   | NaN        | NaN         | NaN        | NaN       | 12.0  | 14.0  | 26.0  | … | NaN    | NaN    | NaN   | 150.0  | 500.0   | 1080.0  | NaN     | NaN       | NaN      | NaN     |<br>| 41.0        | NaN        | 108.45720    | 77.6472    | NaN        | NaN         | NaN        | NaN       | NaN   | 12.0  | 14.0  | … | NaN    | NaN    | NaN   | NaN    | 450.0   | 800.0   | NaN     | NaN       | NaN      | NaN     |<br>| 43.0        | NaN        | 86.05860     | NaN        | NaN        | NaN         | NaN        | NaN       | NaN   | 10.0  | NaN   | … | NaN    | NaN    | NaN   | NaN    | 730.0   | NaN     | NaN     | NaN       | NaN      | NaN     |<br>| 44.0        | NaN        | NaN          | NaN        | 89.5266    | NaN         | NaN        | NaN       | NaN   | NaN   | NaN   | … | NaN    | NaN    | NaN   | NaN    | NaN     | NaN     | 500.0   | NaN       | NaN      | NaN     |</p><p>28 rows × 21 columns</p><pre><code class="python">pd.pivot_table(df_data,               index=[&#39;Age&#39;],               columns=[&#39;LeagueIndex&#39;],               aggfunc=np.sum,               fill_value=-100.)</code></pre><p>|             | APM        | HoursPerWeek | TotalHours |<br>| ———– | ———- | ———— | ———- | ———- | ———– | ———- | ——— | —- | —- | —- | — | —- | —- | —- | —- | —– | —– | —– | ——- | —— | —– |<br>| LeagueIndex | 1          | 2            | 3          | 4          | 5           | 6          | 7         | 1    | 2    | 3    | … | 5    | 6    | 7    | 1    | 2     | 3     | 4     | 5       | 6      | 7     |<br>| Age         |            |              |            |            |             |            |           |      |      |      |     |      |      |      |      |       |       |       |         |        |       |<br>| 16.0        | 1062.44754 | 2919.70434   | 4851.9222  | 5149.7310  | 7787.37780  | 9042.1722  | 386.7774  | 324  | 720  | 778  | … | 1220 | 1280 | 56   | 4307 | 13143 | 29211 | 23581 | 49233   | 51320  | 3000  |<br>| 17.0        | 655.67280  | 1661.01540   | 4181.8920  | 5525.3586  | 10052.72100 | 8310.0858  | 573.8286  | 184  | 378  | 664  | … | 1460 | 1116 | 104  | 2044 | 7423  | 16602 | 24005 | 53375   | 45421  | 12700 |<br>| 18.0        | 704.47680  | 3300.41040   | 4847.2152  | 8763.0783  | 10988.66100 | 9134.7240  | 618.5790  | 204  | 548  | 886  | … | 1644 | 1194 | 164  | 3570 | 11471 | 21037 | 46034 | 1056486 | 50378  | 3200  |<br>| 19.0        | 734.55600  | 2216.81880   | 5183.7888  | 8030.1960  | 9271.09260  | 11955.6030 | 696.7770  | 126  | 458  | 950  | … | 962  | 1642 | 168  | 2355 | 8467  | 31861 | 39705 | 44697   | 70331  | 4166  |<br>| 20.0        | 1624.89660 | 2147.23200   | 4211.5686  | 10596.2070 | 10871.65440 | 14291.8692 | -100.0000 | 328  | 288  | 654  | … | 1290 | 1816 | -100 | 7212 | 6325  | 20174 | 55083 | 64170   | 105131 | -100  |<br>| 21.0        | 780.67950  | 1578.02880   | 3949.3062  | 8689.8804  | 11954.91660 | 13165.7649 | 867.3474  | 162  | 270  | 580  | … | 1446 | 1858 | 62   | 3377 | 7673  | 19095 | 42296 | 68739   | 82061  | 3180  |<br>| 22.0        | 674.59860  | 2147.50980   | 4379.3424  | 7818.7302  | 10473.28380 | 10165.8672 | 493.1586  | 146  | 372  | 680  | … | 1304 | 1448 | 112  | 4225 | 10861 | 23030 | 57996 | 84330   | 67069  | 6950  |<br>| 23.0        | 359.65980  | 1575.06120   | 4602.7416  | 7616.9298  | 8292.86160  | 6131.1936  | 1799.6520 | 46   | 320  | 598  | … | 998  | 726  | 296  | 896  | 12350 | 23081 | 40025 | 56097   | 43176  | 14290 |<br>| 24.0        | 439.43040  | 1717.55340   | 2876.8572  | 5503.7736  | 7292.32740  | 7240.4076  | 428.6538  | 116  | 344  | 406  | … | 668  | 1048 | 36   | 2070 | 9543  | 25421 | 35384 | 36147   | 43114  | 2250  |<br>| 25.0        | 572.61420  | 1178.02440   | 2201.6388  | 4710.9924  | 6168.19260  | 2200.6362  | 361.4550  | 124  | 166  | 268  | … | 682  | 256  | 52   | 2440 | 5846  | 11270 | 26610 | 40681   | 14890  | 3300  |<br>| 26.0        | 418.70874  | 1165.96680   | 1794.1890  | 3139.2852  | 4016.67060  | 3301.8498  | 408.2202  | 96   | 148  | 272  | … | 418  | 354  | 60   | 1608 | 3417  | 10548 | 16839 | 20100   | 17663  | 2300  |<br>| 27.0        | 359.17320  | 1164.15960   | 1426.4550  | 2850.1320  | 3498.30300  | 2040.8454  | -100.0000 | 40   | 152  | 226  | … | 340  | 164  | -100 | 1100 | 3615  | 7525  | 15935 | 19770   | 11796  | -100  |<br>| 28.0        | 333.84240  | 479.34000    | 1152.5958  | 2205.8778  | 1992.60540  | 521.7666   | -100.0000 | 28   | 90   | 220  | … | 186  | 44   | -100 | 466  | 1860  | 7901  | 15370 | 10872   | 2500   | -100  |<br>| 29.0        | 236.74020  | 695.88480    | 568.2594   | 1447.5906  | 1398.78540  | 715.9404   | -100.0000 | 54   | 56   | 80   | … | 180  | 106  | -100 | 2490 | 2000  | 3816  | 8220  | 10292   | 5950   | -100  |<br>| 30.0        | 125.53740  | 441.14160    | 733.6416   | 743.4468   | 578.32020   | 123.3774   | -100.0000 | 14   | 54   | 76   | … | 90   | 28   | -100 | 210  | 2440  | 4370  | 6310  | 3440    | 1500   | -100  |<br>| 31.0        | 41.58600   | 314.92980    | 659.2626   | 1166.7606  | 315.53460   | 200.1708   | -100.0000 | 12   | 36   | 68   | … | 12   | 16   | -100 | 200  | 1300  | 3500  | 8710  | 1050    | 1500   | -100  |<br>| 32.0        | 179.14380  | 315.54180    | 457.5174   | 541.8996   | 66.19740    | -100.0000  | -100.0000 | 40   | 56   | 68   | … | 10   | -100 | -100 | 1600 | 860   | 2300  | 6040  | 800     | -100   | -100  |<br>| 33.0        | 198.77880  | 153.34680    | 284.8218   | 116.7516   | 245.45166   | -100.0000  | -100.0000 | 32   | 12   | 42   | … | 60   | -100 | -100 | 1200 | 220   | 2065  | 1130  | 2050    | -100   | -100  |<br>| 34.0        | 49.11360   | 276.88260    | 268.4100   | 340.7124   | 174.54540   | -100.0000  | -100.0000 | 12   | 56   | 28   | … | 14   | -100 | -100 | 150  | 3380  | 1150  | 2400  | 2764    | -100   | -100  |<br>| 35.0        | 229.31280  | 54.04680     | 170.4930   | 634.7688   | 115.06440   | -100.0000  | -100.0000 | 54   | 8    | 26   | … | 12   | -100 | -100 | 1350 | 500   | 1950  | 3800  | 800     | -100   | -100  |<br>| 36.0        | -100.00000 | 150.13140    | 333.6474   | 73.6980    | -100.00000  | -100.0000  | -100.0000 | -100 | 16   | 40   | … | -100 | -100 | -100 | -100 | 500   | 1950  | 400   | -100    | -100   | -100  |<br>| 37.0        | 22.05960   | 49.89600     | 44.9682    | -100.0000  | 451.13160   | -100.0000  | -100.0000 | 12   | 30   | 6    | … | 32   | -100 | -100 | 300  | 125   | 600   | -100  | 1800    | -100   | -100  |<br>| 38.0        | 71.59500   | -100.00000   | 334.6878   | -100.0000  | -100.00000  | -100.0000  | -100.0000 | 16   | -100 | 46   | … | -100 | -100 | -100 | 300  | -100  | 2280  | -100  | -100    | -100   | -100  |<br>| 39.0        | 29.87640   | -100.00000   | 53.7690    | 86.7246    | -100.00000  | -100.0000  | -100.0000 | 10   | -100 | 12   | … | -100 | -100 | -100 | 500  | -100  | 450   | 500   | -100    | -100   | -100  |<br>| 40.0        | 38.55900   | 51.83580     | 107.4684   | -100.0000  | -100.00000  | -100.0000  | -100.0000 | 12   | 14   | 26   | … | -100 | -100 | -100 | 150  | 500   | 1080  | -100  | -100    | -100   | -100  |<br>| 41.0        | -100.00000 | 108.45720    | 77.6472    | -100.0000  | -100.00000  | -100.0000  | -100.0000 | -100 | 12   | 14   | … | -100 | -100 | -100 | -100 | 450   | 800   | -100  | -100    | -100   | -100  |<br>| 43.0        | -100.00000 | 86.05860     | -100.0000  | -100.0000  | -100.00000  | -100.0000  | -100.0000 | -100 | 10   | -100 | … | -100 | -100 | -100 | -100 | 730   | -100  | -100  | -100    | -100   | -100  |<br>| 44.0        | -100.00000 | -100.00000   | -100.0000  | 89.5266    | -100.00000  | -100.0000  | -100.0000 | -100 | -100 | -100 | … | -100 | -100 | -100 | -100 | -100  | -100  | 500   | -100    | -100   | -100  |</p><p>28 rows × 21 columns</p><h3 id="交叉表"><a href="#交叉表" class="headerlink" title="交叉表"></a>交叉表</h3><pre><code class="python">pd.crosstab(df_data[&#39;LeagueIndex&#39;],            df_data[&#39;Age&#39;])</code></pre><table><thead><tr><th>Age</th><th>16.0</th><th>17.0</th><th>18.0</th><th>19.0</th><th>20.0</th><th>21.0</th><th>22.0</th><th>23.0</th><th>24.0</th><th>25.0</th><th>…</th><th>34.0</th><th>35.0</th><th>36.0</th><th>37.0</th><th>38.0</th><th>39.0</th><th>40.0</th><th>41.0</th><th>43.0</th><th>44.0</th></tr></thead><tbody><tr><td>LeagueIndex</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>1</td><td>18</td><td>9</td><td>13</td><td>12</td><td>22</td><td>12</td><td>12</td><td>6</td><td>9</td><td>11</td><td>…</td><td>1</td><td>5</td><td>0</td><td>1</td><td>1</td><td>1</td><td>1</td><td>0</td><td>0</td><td>0</td></tr><tr><td>2</td><td>38</td><td>22</td><td>38</td><td>32</td><td>25</td><td>23</td><td>28</td><td>24</td><td>24</td><td>18</td><td>…</td><td>5</td><td>1</td><td>2</td><td>1</td><td>0</td><td>0</td><td>1</td><td>2</td><td>1</td><td>0</td></tr><tr><td>3</td><td>48</td><td>43</td><td>56</td><td>53</td><td>47</td><td>44</td><td>47</td><td>47</td><td>32</td><td>26</td><td>…</td><td>3</td><td>3</td><td>5</td><td>1</td><td>4</td><td>1</td><td>2</td><td>1</td><td>0</td><td>0</td></tr><tr><td>4</td><td>45</td><td>49</td><td>78</td><td>71</td><td>97</td><td>81</td><td>75</td><td>72</td><td>52</td><td>45</td><td>…</td><td>4</td><td>7</td><td>1</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>1</td></tr><tr><td>5</td><td>55</td><td>71</td><td>81</td><td>68</td><td>80</td><td>96</td><td>81</td><td>59</td><td>58</td><td>51</td><td>…</td><td>2</td><td>1</td><td>0</td><td>2</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>6</td><td>50</td><td>51</td><td>56</td><td>73</td><td>86</td><td>83</td><td>68</td><td>42</td><td>48</td><td>15</td><td>…</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>7</td><td>2</td><td>3</td><td>3</td><td>4</td><td>0</td><td>5</td><td>3</td><td>9</td><td>2</td><td>2</td><td>…</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr></tbody></table><p>7 rows × 28 columns</p><pre><code class="python">pd.crosstab(df_data[&#39;LeagueIndex&#39;],            [df_data[&#39;Age&#39;], df_data[&#39;HoursPerWeek&#39;]])</code></pre><p>| Age          | 16.0 | … | 39.0 | 40.0 | 41.0 | 43.0 | 44.0 |<br>| ———— | —- | — | —- | —- | —- | —- | —- | —- | —- | —- | — | —- | —- | —- | —- | —- | — | — | —- | —- | — |<br>| HoursPerWeek | 0.0  | 2.0 | 4.0  | 6.0  | 8.0  | 10.0 | 12.0 | 14.0 | 16.0 | 20.0 | … | 12.0 | 10.0 | 12.0 | 14.0 | 16.0 | 4.0 | 8.0 | 14.0 | 10.0 | 6.0 |<br>| LeagueIndex  |      |     |      |      |      |      |      |      |      |      |     |      |      |      |      |      |     |     |      |      |     |<br>| 1            | 0    | 0   | 0    | 1    | 3    | 1    | 1    | 2    | 3    | 3    | … | 0    | 0    | 1    | 0    | 0    | 0   | 0   | 0    | 0    | 0   |<br>| 2            | 0    | 0   | 2    | 1    | 0    | 9    | 4    | 4    | 3    | 3    | … | 0    | 0    | 0    | 1    | 0    | 1   | 1   | 0    | 1    | 0   |<br>| 3            | 0    | 0   | 1    | 6    | 7    | 6    | 6    | 7    | 2    | 1    | … | 1    | 1    | 0    | 0    | 1    | 0   | 0   | 1    | 0    | 0   |<br>| 4            | 0    | 2   | 5    | 1    | 6    | 4    | 3    | 6    | 3    | 1    | … | 0    | 0    | 0    | 0    | 0    | 0   | 0   | 0    | 0    | 1   |<br>| 5            | 0    | 1   | 2    | 1    | 3    | 8    | 3    | 6    | 3    | 6    | … | 0    | 0    | 0    | 0    | 0    | 0   | 0   | 0    | 0    | 0   |<br>| 6            | 1    | 1   | 4    | 2    | 1    | 1    | 4    | 3    | 1    | 7    | … | 0    | 0    | 0    | 0    | 0    | 0   | 0   | 0    | 0    | 0   |<br>| 7            | 0    | 0   | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | … | 0    | 0    | 0    | 0    | 0    | 0   | 0   | 0    | 0    | 0   |</p><p>7 rows × 325 columns</p>]]></content>
      
      
      <categories>
          
          <category> DataAnalysis </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>pandas基本知识</title>
      <link href="blog/li8bkt/"/>
      <url>blog/li8bkt/</url>
      
        <content type="html"><![CDATA[<h2 id="一、Pandas-数据结构"><a href="#一、Pandas-数据结构" class="headerlink" title="一、Pandas 数据结构"></a>一、Pandas 数据结构</h2><pre><code class="python">import pandas as pd</code></pre><h3 id="Series"><a href="#Series" class="headerlink" title="Series"></a>Series</h3><blockquote><ol><li>通过 list 构建 Series</li></ol></blockquote><pre><code class="python">ser_obj = pd.Series(range(10, 20,2))print (type(ser_obj))print(ser_obj)</code></pre><pre><code>&lt;class &#39;pandas.core.series.Series&#39;&gt;0    101    122    143    164    18dtype: int64</code></pre><pre><code class="python"># 获取数据print (ser_obj.values)# 获取索引print (ser_obj.index)#范围索引数据类型# 预览数据print (ser_obj.head(3))#默认输出五行</code></pre><pre><code>[10 12 14 16 18]RangeIndex(start=0, stop=5, step=1)0    101    122    14dtype: int64</code></pre><blockquote><ol start="2"><li>通过 dict 构建 Series</li></ol></blockquote><pre><code class="python">year_data = &#123;2001: 17.8, 2002: 20.1, 2003: 16.5,2004:324,2423:243&#125;ser_obj2 = pd.Series(year_data)print (ser_obj2.head(2))print (ser_obj2.index)print(ser_obj2)</code></pre><pre><code>2001    17.82002    20.1dtype: float64Int64Index([2001, 2002, 2003, 2004, 2423], dtype=&#39;int64&#39;)2001     17.82002     20.12003     16.52004    324.02423    243.0dtype: float64</code></pre><pre><code class="python"># name属性【【【【【出问题了！！！】】】】】ser_obj2.name = &#39;钱&#39;ser_obj2.index.name = &#39;year&#39;print (ser_obj2.head())</code></pre><pre><code>year2001     17.82002     20.12003     16.52004    324.02423    243.0Name: 钱, dtype: float64</code></pre><h3 id="DataFrame"><a href="#DataFrame" class="headerlink" title="DataFrame"></a>DataFrame</h3><blockquote><ol><li>通过 ndarray 构建 DataFrame</li></ol></blockquote><pre><code class="python">import numpy as nparray = np.random.rand(5,4)print (array)df_obj = pd.DataFrame(array,columns=[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;])print (df_obj.head())print(df_obj.sort_values(by=&#39;a&#39;, ascending=False))</code></pre><pre><code>[[0.23496522 0.92258429 0.36447462 0.52634697] [0.73743514 0.88175941 0.48944212 0.4173522 ] [0.21214568 0.57148666 0.59496072 0.49490723] [0.7458542  0.74743907 0.70475157 0.28130394] [0.43805937 0.90300134 0.00730653 0.68203725]]          a         b         c         d0  0.234965  0.922584  0.364475  0.5263471  0.737435  0.881759  0.489442  0.4173522  0.212146  0.571487  0.594961  0.4949073  0.745854  0.747439  0.704752  0.2813044  0.438059  0.903001  0.007307  0.682037          a         b         c         d3  0.745854  0.747439  0.704752  0.2813041  0.737435  0.881759  0.489442  0.4173524  0.438059  0.903001  0.007307  0.6820370  0.234965  0.922584  0.364475  0.5263472  0.212146  0.571487  0.594961  0.494907</code></pre><blockquote><ol start="2"><li>通过 dict 构建 DataFrame</li></ol></blockquote><pre><code class="python">#一个键值对就相当于一列！！但是具体到字典里面的值所用到的一些函数还是不能很清楚dict_data = &#123;&#39;A&#39;: 1.,             &#39;B&#39;: pd.Timestamp(&#39;20161217&#39;),             &#39;C&#39;: pd.Series(1, index=list(range(4)),dtype=&#39;float32&#39;),             &#39;D&#39;: np.array([3] * 4,dtype=&#39;int32&#39;),             &#39;E&#39; : pd.Categorical([&quot;Python&quot;,&quot;Java&quot;,&quot;C++&quot;,&quot;C#&quot;]),             &#39;F&#39; : &#39;ChinaHadoop&#39; &#125;df_obj2 = pd.DataFrame(dict_data)print (df_obj2.head())</code></pre><pre><code>     A          B    C  D       E            F0  1.0 2016-12-17  1.0  3  Python  ChinaHadoop1  1.0 2016-12-17  1.0  3    Java  ChinaHadoop2  1.0 2016-12-17  1.0  3     C++  ChinaHadoop3  1.0 2016-12-17  1.0  3      C#  ChinaHadoop</code></pre><pre><code class="python"># 增加列df_obj2[&#39;G&#39;] = df_obj2[&#39;D&#39;] + 4print (df_obj2.head())xxx = pd.DataFrame(df_obj2,columns=[&#39;A&#39;,&#39;B&#39;,&#39;C&#39;,&#39;D&#39;,&#39;E&#39;,&#39;F&#39;,&#39;G&#39;,&#39;H&#39;],index=[0,1,2,3,4])print(xxx)</code></pre><pre><code>     A          B    C  D       E            F  G0  1.0 2016-12-17  1.0  3  Python  ChinaHadoop  71  1.0 2016-12-17  1.0  3    Java  ChinaHadoop  72  1.0 2016-12-17  1.0  3     C++  ChinaHadoop  73  1.0 2016-12-17  1.0  3      C#  ChinaHadoop  7     A          B    C    D       E            F    G   H0  1.0 2016-12-17  1.0  3.0  Python  ChinaHadoop  7.0 NaN1  1.0 2016-12-17  1.0  3.0    Java  ChinaHadoop  7.0 NaN2  1.0 2016-12-17  1.0  3.0     C++  ChinaHadoop  7.0 NaN3  1.0 2016-12-17  1.0  3.0      C#  ChinaHadoop  7.0 NaN4  NaN        NaT  NaN  NaN     NaN          NaN  NaN NaN</code></pre><h3 id="Index"><a href="#Index" class="headerlink" title="Index"></a>Index</h3><pre><code class="python">print (type(ser_obj.index))print (type(df_obj2.index))print (df_obj2.index)</code></pre><pre><code>&lt;class &#39;pandas.core.indexes.range.RangeIndex&#39;&gt;&lt;class &#39;pandas.core.indexes.numeric.Int64Index&#39;&gt;Int64Index([0, 1, 2, 3], dtype=&#39;int64&#39;)</code></pre><pre><code class="python"># 索引对象不可变df_obj2.index[0] = 2</code></pre><pre><code>---------------------------------------------------------------------------TypeError                                 Traceback (most recent call last)&lt;ipython-input-10-6367894e76d8&gt; in &lt;module&gt;      1 # 索引对象不可变----&gt; 2 df_obj2.index[0] = 2~\Anaconda3\lib\site-packages\pandas\core\indexes\base.py in __setitem__(self, key, value)   4258   4259     def __setitem__(self, key, value):-&gt; 4260         raise TypeError(&quot;Index does not support mutable operations&quot;)   4261   4262     def __getitem__(self, key):TypeError: Index does not support mutable operations</code></pre><h2 id="二、Pandas-数据操作"><a href="#二、Pandas-数据操作" class="headerlink" title="二、Pandas 数据操作"></a>二、Pandas 数据操作</h2><h3 id="常用函数总结"><a href="#常用函数总结" class="headerlink" title="常用函数总结"></a>常用函数总结</h3><blockquote><p>·shape   获取数据的尺寸</p></blockquote><pre><code> 获得df的size：df.shape 获得df中的行数：df.shape[0] 获得df中的列数： df.shape[1] 获得行索引信息：df.index 获得列索引信息：df.colomns</code></pre><blockquote><p>·values   获得 df 中的值===中文没用</p></blockquote><pre><code>df.values === 以列表的形式展现出来，去除了索引===dataframe类型数据转换成array类型</code></pre><blockquote><p>·setindex 和 resetindex</p></blockquote><pre><code>reset_index可以还原索引，从新变为默认的整型索引    DataFrame.reset_index(level=None, drop=False, inplace=False, col_level=0, col_fill=”)    level控制了具体要还原的那个等级的索引    drop为False则索引列会被还原为普通列，否则会丢失set_index方法，设置单索引和复合索引抑或是添加索引。    DataFrame.set_index(keys, drop=True, append=False, inplace=False, verify_integrity=False)    append添加新索引，drop为False，inplace为True时，索引将会还原为列</code></pre><blockquote><p>·iterrows（）遍历 DataFrame 中的数据</p></blockquote><pre><code>for index,row in df.iterrows():</code></pre><blockquote><p>·split(sep,n,expand=false)</p></blockquote><pre><code>sep表示用于分割的字符；n表格分割成多少列；expand表示是否展开为数据款，True输出Series，False输出Dataframe。字段拆分：是指按照固定的字符，拆分已有字符串</code></pre><pre><code class="python">import pandas as pdimport numpy as np</code></pre><h3 id="匿名函数应用"><a href="#匿名函数应用" class="headerlink" title="匿名函数应用"></a>匿名函数应用</h3><pre><code class="python"># Numpy ufunc 函数df = pd.DataFrame(np.random.randn(5,4) - 1)print (df)print (np.abs(df))</code></pre><pre><code>          0         1         2         30  0.624016 -2.695175 -1.211426 -0.3861511 -1.335385 -1.315232 -0.305902 -0.3613482 -0.349443 -2.032110  0.075995 -0.9667253 -1.631192 -1.051390 -1.767981 -0.3666634 -0.786178 -0.335846 -0.797992 -0.931216          0         1         2         30  0.624016  2.695175  1.211426  0.3861511  1.335385  1.315232  0.305902  0.3613482  0.349443  2.032110  0.075995  0.9667253  1.631192  1.051390  1.767981  0.3666634  0.786178  0.335846  0.797992  0.931216</code></pre><pre><code class="python"># 使用apply应用行或列数据f = lambda x : x.max()print (df.apply(f))</code></pre><pre><code>0    0.6240161   -0.3358462    0.0759953   -0.361348dtype: float64</code></pre><pre><code class="python"># 指定轴方向print (df.apply(f, axis=1))</code></pre><pre><code>0    0.6240161   -0.3059022    0.0759953   -0.3666634   -0.335846dtype: float64</code></pre><pre><code class="python"># 使用applymap应用到每个数据f2 = lambda x : &#39;%.2f&#39; % xprint (df.applymap(f2))</code></pre><pre><code>       0      1      2      30   0.62  -2.70  -1.21  -0.391  -1.34  -1.32  -0.31  -0.362  -0.35  -2.03   0.08  -0.973  -1.63  -1.05  -1.77  -0.374  -0.79  -0.34  -0.80  -0.93</code></pre><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><pre><code class="python">s4 = pd.Series(range(10, 15), index = np.random.randint(5, size=5))print (s4)</code></pre><pre><code>4    101    114    121    131    14dtype: int64</code></pre><blockquote><ol><li>索引排序</li></ol></blockquote><pre><code class="python">s4.sort_index()</code></pre><pre><code>1    111    131    144    104    12dtype: int64</code></pre><pre><code class="python">df4 = pd.DataFrame(np.random.randn(3, 4),                   index=np.random.randint(3, size=3),                   columns=np.random.randint(4, size=4))</code></pre><pre><code class="python">df4</code></pre><table><thead><tr><th></th><th>2</th><th>1</th><th>3</th><th>1</th></tr></thead><tbody><tr><td>0</td><td>0.007031</td><td>1.261990</td><td>-1.647929</td><td>0.176549</td></tr><tr><td>1</td><td>-2.510698</td><td>-0.207659</td><td>0.628221</td><td>0.441352</td></tr><tr><td>0</td><td>-0.367051</td><td>1.536606</td><td>0.167158</td><td>-0.236129</td></tr></tbody></table><pre><code class="python">#df4.sort_index(ascending=False)df4.sort_index(axis=1)</code></pre><table><thead><tr><th></th><th>1</th><th>1</th><th>2</th><th>3</th></tr></thead><tbody><tr><td>0</td><td>1.261990</td><td>0.176549</td><td>0.007031</td><td>-1.647929</td></tr><tr><td>1</td><td>-0.207659</td><td>0.441352</td><td>-2.510698</td><td>0.628221</td></tr><tr><td>0</td><td>1.536606</td><td>-0.236129</td><td>-0.367051</td><td>0.167158</td></tr></tbody></table><blockquote><ol start="2"><li>按值排序</li></ol></blockquote><pre><code class="python">#df.sortvalues(by=&#39;a&#39;, ascending=False) === 通过a的值#    作用是对选定的一列数值（&#39;a&#39;）数据从上往下从小到大进行排序（如果传值没成功===设置本体覆盖，传值覆盖）df4.sort_values(by=1)</code></pre><pre><code>---------------------------------------------------------------------------ValueError                                Traceback (most recent call last)&lt;ipython-input-22-36ffa8ddd07d&gt; in &lt;module&gt;      2 #df.sortvalues(by=&#39;a&#39;, ascending=False) === 通过a的值      3 #    作用是对选定的一列数值（&#39;a&#39;）数据从上往下从小到大进行排序（如果传值没成功===设置本体覆盖，传值覆盖）----&gt; 4 df4.sort_values(by=1)~\Anaconda3\lib\site-packages\pandas\core\frame.py in sort_values(self, by, axis, ascending, inplace, kind, na_position)   4991   4992             by = by[0]-&gt; 4993             k = self._get_label_or_level_values(by, axis=axis)   4994   4995             if isinstance(ascending, (tuple, list)):~\Anaconda3\lib\site-packages\pandas\core\generic.py in _get_label_or_level_values(self, key, axis)   1795                     key=key,   1796                     label_axis_name=label_axis_name,-&gt; 1797                     multi_message=multi_message,   1798                 )   1799             )ValueError: The column label &#39;1&#39; is not unique.</code></pre>]]></content>
      
      
      <categories>
          
          <category> DataAnalysis </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Numpy库使用总结</title>
      <link href="blog/mk2z96/"/>
      <url>blog/mk2z96/</url>
      
        <content type="html"><![CDATA[<h2 id="一、NumPy"><a href="#一、NumPy" class="headerlink" title="一、NumPy"></a>一、NumPy</h2><h3 id="ndarray-理解多维数组"><a href="#ndarray-理解多维数组" class="headerlink" title="ndarray 理解多维数组"></a>ndarray 理解多维数组</h3><pre><code class="python">import numpy as np# 生成指定维度的随机多维数据#数学建模应该用不到data = np.random.rand(2, 3)print (data)print (type(data))#type是显示数据类型；shape显示维度；ndim维度个数;type另外的作用</code></pre><pre><code>[[0.46686682 0.68844304 0.76663872] [0.70747721 0.47887587 0.25943412]]&lt;class &#39;numpy.ndarray&#39;&gt;</code></pre><blockquote><p>ndim, shape 和 dtype 属性</p></blockquote><pre><code class="python">print (&#39;维度个数&#39;, data.ndim)print (&#39;各维度大小: &#39;, data.shape)print (&#39;数据类型: &#39;, data.dtype)</code></pre><pre><code>维度个数 2各维度大小:  (2, 3)数据类型:  float64</code></pre><h3 id="创建-ndarray"><a href="#创建-ndarray" class="headerlink" title="创建 ndarray"></a>创建 ndarray</h3><pre><code class="python">&#39;&#39;&#39;1. array创建&#39;&#39;&#39;# list转换为 ndarrayl = range(10)data = np.array(l)print (data)print (data.shape)print (data.ndim)</code></pre><pre><code>[0 1 2 3 4 5 6 7 8 9](10,)1</code></pre><pre><code class="python"># 嵌套序列转换为ndarrayl2 = [range(10), range(10)]#就这样形成了一个数组data = np.array(l2)print (data)print (data.shape)</code></pre><pre><code>[[0 1 2 3 4 5 6 7 8 9] [0 1 2 3 4 5 6 7 8 9]](2, 10)</code></pre><pre><code class="python">&#39;&#39;&#39;2. zeros;ones;empty创建&#39;&#39;&#39;# np.zeroszeros_arr = np.zeros((3, 4))#注意元组，这里经常报错# np.onesones_arr = np.ones((2, 3))# np.empty[不全为零，而且是随机的一些数字]empty_arr = np.empty((3, 3))# np.empty 指定数据类型empty_int_arr = np.empty((3, 3), int)print (zeros_arr)print (&#39;-------------&#39;)print (ones_arr)print (&#39;-------------&#39;)print (empty_arr)print (&#39;-------------&#39;)print (empty_int_arr)</code></pre><pre><code>[[0. 0. 0. 0.] [0. 0. 0. 0.] [0. 0. 0. 0.]]-------------[[1. 1. 1.] [1. 1. 1.]]-------------[[0.000e+000 0.000e+000 0.000e+000] [0.000e+000 0.000e+000 2.174e-321] [0.000e+000 0.000e+000 0.000e+000]]-------------[[0 0 0] [0 0 0] [0 0 0]]</code></pre><pre><code class="python"># np.arange()#创建一系列连续的数算是numpy里面类似python里面range的功能print (np.arange(10))</code></pre><pre><code>[0 1 2 3 4 5 6 7 8 9]</code></pre><h2 id="二、操作-nddarray"><a href="#二、操作-nddarray" class="headerlink" title="二、操作 nddarray"></a>二、操作 nddarray</h2><h3 id="矢量化-vectorization"><a href="#矢量化-vectorization" class="headerlink" title="矢量化 (vectorization)"></a>矢量化 (vectorization)</h3><pre><code class="python"># 矢量与矢量运算arr = np.array([[1, 2, 3],                [4, 5, 6]])print (&quot;元素之间相乘：&quot;)#注意区分矩阵之间的运算。这里的矢量原酸相当于是广播式的运算print (arr * arr)print (&quot;矩阵相加：&quot;)print (arr + arr)</code></pre><pre><code>元素之间相乘：[[ 1  4  9] [16 25 36]]矩阵相加：[[ 2  4  6] [ 8 10 12]]</code></pre><pre><code class="python"># 矢量与标量运算print (1. / arr)print (2. * arr)</code></pre><pre><code>[[1.         0.5        0.33333333] [0.25       0.2        0.16666667]][[ 2.  4.  6.] [ 8. 10. 12.]]</code></pre><h3 id="索引与切片"><a href="#索引与切片" class="headerlink" title="索引与切片"></a>索引与切片</h3><pre><code class="python"># 一维数组arr1 = np.arange(10)print (arr1)print (arr1[2:5])</code></pre><pre><code>[0 1 2 3 4 5 6 7 8 9][2 3 4]</code></pre><pre><code class="python"># 多维数组arr2 = np.arange(12).reshape(3,4)#要学会定义多维数组，arange是形成12个随机数，之后的reshape是形成维数#多维数组的空间含义就是比如：3.4.5=长4宽5高3#还有点数就是应用函数print (arr2)</code></pre><pre><code>[[ 0  1  2  3] [ 4  5  6  7] [ 8  9 10 11]]</code></pre><pre><code class="python">print (arr2[1])print (arr2[0:2, 2:])print (arr2[:, 1:3])</code></pre><pre><code>[4 5 6 7][[2 3] [6 7]][[ 1  2] [ 5  6] [ 9 10]]</code></pre><pre><code class="python"># 条件索引# 找出 data_arr 中 2015年后的数据data_arr = np.random.rand(3,3)print (data_arr)year_arr = np.array([[2000, 2001, 2000],                     [2005, 2002, 2009],                     [2001, 2003, 2010]])is_year_after_2005 = year_arr &gt;= 2005#:他会扩展成同类型的数组print (is_year_after_2005, is_year_after_2005.dtype)filtered_arr = data_arr[is_year_after_2005]filtered_arr = data_arr[year_arr &gt;= 2005]print (filtered_arr)#中间的一些语句可以删除#最后生成得是一维数组，进行数据过滤的时候很有用</code></pre><pre><code>[[0.61482194 0.0249229  0.28525661] [0.05121173 0.37672803 0.86259463] [0.22648329 0.4581513  0.18620441]][[False False False] [ True False  True] [False False  True]] bool[0.05121173 0.86259463 0.18620441]</code></pre><pre><code class="python"># 多个条件&amp; |filtered_arr = data_arr[(year_arr &lt;= 2005) &amp; (year_arr % 2 == 0)]print (filtered_arr)</code></pre><pre><code>[0.61482194 0.28525661 0.37672803]</code></pre><h3 id="转置-transpose"><a href="#转置-transpose" class="headerlink" title="转置 === transpose"></a>转置 === transpose</h3><pre><code class="python">arr = np.random.rand(2,3)print (arr)print (arr.transpose())</code></pre><pre><code>[[0.01538974 0.47573964 0.90684253] [0.93683601 0.64306611 0.63846634]][[0.01538974 0.93683601] [0.47573964 0.64306611] [0.90684253 0.63846634]]</code></pre><pre><code class="python">#高维数组的转换(图像里面会用得到转换维度)arr3d = np.random.rand(2,3,4)print (arr3d)print (&#39;----------------------&#39;)print (arr3d.transpose((1,0,2))) # 多维数组的转置和定义不会</code></pre><pre><code>[[[0.18074837 0.64652003 0.80527972 0.67800268]  [0.95766577 0.2498768  0.00304503 0.7058178 ]  [0.12523549 0.18796252 0.72463798 0.15352211]] [[0.38808013 0.31075033 0.53082474 0.32254431]  [0.6861262  0.02999367 0.70980993 0.09099878]  [0.14987301 0.78237398 0.90159408 0.82897071]]]----------------------[[[0.18074837 0.64652003 0.80527972 0.67800268]  [0.38808013 0.31075033 0.53082474 0.32254431]] [[0.95766577 0.2498768  0.00304503 0.7058178 ]  [0.6861262  0.02999367 0.70980993 0.09099878]] [[0.12523549 0.18796252 0.72463798 0.15352211]  [0.14987301 0.78237398 0.90159408 0.82897071]]]</code></pre><h3 id="ndarray-数据类型转化-astype"><a href="#ndarray-数据类型转化-astype" class="headerlink" title="ndarray 数据类型转化 === astype"></a>ndarray 数据类型转化 === astype</h3><pre><code class="python">zeros_float_arr = np.zeros((3, 4), dtype=np.float64)print (zeros_float_arr)print (zeros_float_arr.dtype)# astype转换数据类型zeros_int_arr = zeros_float_arr.astype(np.int32)print (zeros_int_arr)print (zeros_int_arr.dtype)</code></pre><pre><code>[[0. 0. 0. 0.] [0. 0. 0. 0.] [0. 0. 0. 0.]]float64[[0 0 0 0] [0 0 0 0] [0 0 0 0]]int32</code></pre><h3 id="文本文件的读取"><a href="#文本文件的读取" class="headerlink" title="文本文件的读取"></a>文本文件的读取</h3><pre><code class="python"># loadtxtfilename = &#39;./presidential_polls.csv&#39;data_array = np.loadtxt(filename,      # 文件名                        delimiter=&#39;,&#39;, # 指定里面的元素分隔符                        dtype=str,     # 指定数据类型                        usecols=(0,2,3)) # 指定读取的列索引号print (data_array, data_array.shape)</code></pre><pre><code>[[&#39;cycle&#39; &#39;type&#39; &#39;matchup&#39;] [&#39;2016&#39; &#39;&quot;polls-plus&quot;&#39; &#39;&quot;Clinton vs. Trump vs. Johnson&quot;&#39;] [&#39;2016&#39; &#39;&quot;polls-plus&quot;&#39; &#39;&quot;Clinton vs. Trump vs. Johnson&quot;&#39;] ... [&#39;2016&#39; &#39;&quot;polls-only&quot;&#39; &#39;&quot;Clinton vs. Trump vs. Johnson&quot;&#39;] [&#39;2016&#39; &#39;&quot;polls-only&quot;&#39; &#39;&quot;Clinton vs. Trump vs. Johnson&quot;&#39;] [&#39;2016&#39; &#39;&quot;polls-only&quot;&#39; &#39;&quot;Clinton vs. Trump vs. Johnson&quot;&#39;]] (10237, 3)</code></pre><pre><code class="python"># loadtxt, 明确指定每列数据的类型filename = &#39;./presidential_polls.csv&#39;data_array = np.loadtxt(filename,      # 文件名                        delimiter=&#39;,&#39;, # 分隔符                        skiprows=1,                        dtype=&#123;&#39;names&#39;:(&#39;cycle&#39;, &#39;type&#39;, &#39;matchup&#39;),                               &#39;formats&#39;:(&#39;i4&#39;, &#39;S15&#39;, &#39;S50&#39;)&#125;,     # 数据类型                        usecols=(0,2,3)) # 指定读取的列索引号print (data_array, data_array.shape) # 读取的结果是一维的数组，每个元素是一个元组</code></pre><pre><code>[(2016, b&#39;&quot;polls-plus&quot;&#39;, b&#39;&quot;Clinton vs. Trump vs. Johnson&quot;&#39;) (2016, b&#39;&quot;polls-plus&quot;&#39;, b&#39;&quot;Clinton vs. Trump vs. Johnson&quot;&#39;) (2016, b&#39;&quot;polls-plus&quot;&#39;, b&#39;&quot;Clinton vs. Trump vs. Johnson&quot;&#39;) ... (2016, b&#39;&quot;polls-only&quot;&#39;, b&#39;&quot;Clinton vs. Trump vs. Johnson&quot;&#39;) (2016, b&#39;&quot;polls-only&quot;&#39;, b&#39;&quot;Clinton vs. Trump vs. Johnson&quot;&#39;) (2016, b&#39;&quot;polls-only&quot;&#39;, b&#39;&quot;Clinton vs. Trump vs. Johnson&quot;&#39;)] (10236,)</code></pre><h2 id="三、np-的常用函数"><a href="#三、np-的常用函数" class="headerlink" title="三、np 的常用函数"></a>三、np 的常用函数</h2><h3 id="转置-transpose-1"><a href="#转置-transpose-1" class="headerlink" title="转置 transpose"></a>转置 transpose</h3><pre><code class="python">import numpy as np</code></pre><pre><code class="python">arr = np.random.rand(2,3)print (arr)print (arr.transpose())</code></pre><pre><code>[[0.78485041 0.88817969 0.34809014] [0.32744286 0.97539301 0.94401872]][[0.78485041 0.32744286] [0.88817969 0.97539301] [0.34809014 0.94401872]]</code></pre><pre><code class="python">#高维数组的转换(图像里面会用得到转换维度)#不懂这里！！！arr3d = np.random.rand(2,3,4)print (arr3d)print (&#39;----------------------&#39;)print (arr3d.transpose((1,0,2))) # 多维数组的转置和定义不会</code></pre><pre><code>[[[0.28492549 0.60197236 0.45582367 0.21992479]  [0.1747163  0.69201365 0.85460359 0.65311699]  [0.62189644 0.25217555 0.16347156 0.29831219]] [[0.42826733 0.81396165 0.187138   0.560564  ]  [0.10162186 0.66419751 0.03261665 0.06969256]  [0.55461652 0.55020586 0.50693591 0.31741807]]]----------------------[[[0.28492549 0.60197236 0.45582367 0.21992479]  [0.42826733 0.81396165 0.187138   0.560564  ]] [[0.1747163  0.69201365 0.85460359 0.65311699]  [0.10162186 0.66419751 0.03261665 0.06969256]] [[0.62189644 0.25217555 0.16347156 0.29831219]  [0.55461652 0.55020586 0.50693591 0.31741807]]]</code></pre><h3 id="ceil-和-floor-和-rint-和-isnan"><a href="#ceil-和-floor-和-rint-和-isnan" class="headerlink" title="ceil 和 floor 和 rint 和 isnan"></a>ceil 和 floor 和 rint 和 isnan</h3><pre><code class="python">arr = np.random.randn(2,3)print (arr)print (np.ceil(arr))#向上最接近的整数print (np.floor(arr))#向下最接近的整数print (np.rint(arr))#四舍五入print (np.isnan(arr))#判断元素是否为NaN#笔记上还有其他的函数</code></pre><pre><code>[[ 0.262106   -1.33680008 -1.08562543] [ 0.3990978   0.1410074   0.64278274]][[ 1. -1. -1.] [ 1.  1.  1.]][[ 0. -2. -2.] [ 0.  0.  0.]][[ 0. -1. -1.] [ 0.  0.  1.]][[False False False] [False False False]]</code></pre><h3 id="where"><a href="#where" class="headerlink" title="where"></a>where</h3><pre><code class="python">arr = np.random.randn(3,4)print (arr)np.where(arr &gt; 0, 1, -1)#（条件，满足输出，不满足输出）</code></pre><pre><code>[[ 2.04688394  0.48063737  1.20876913 -0.93412937] [-0.43427472 -1.47755481  0.36882256 -0.08943138] [-0.2847686   0.96915893  0.32641235  0.28346922]]array([[ 1,  1,  1, -1],       [-1, -1,  1, -1],       [-1,  1,  1,  1]])</code></pre><h3 id="sum"><a href="#sum" class="headerlink" title="sum"></a>sum</h3><pre><code class="python">arr = np.arange(10).reshape(5,2)print (arr)print (np.sum(arr))print (np.sum(arr, axis=0))print (np.sum(arr, axis=1))</code></pre><pre><code>[[0 1] [2 3] [4 5] [6 7] [8 9]]45[20 25][ 1  5  9 13 17]</code></pre><h3 id="all-和-any"><a href="#all-和-any" class="headerlink" title="all 和 any"></a>all 和 any</h3><pre><code class="python">import numpy as nparr = np.random.randn(2,3)print (arr)print (np.any(arr &gt; 0))#有一个就对print (np.all(arr &gt; 0))#全部对才对&#39;&#39;&#39;·用处就是判断一组数据当中，是否===有点类似布尔类型的·这个也可以应用在pandas中的DataFrame中&#39;&#39;&#39;</code></pre><pre><code>[[-1.020184   -0.48466272 -0.8496271 ] [ 0.88815825 -0.81911857  0.64570539]]TrueFalse&#39;\n·用处就是判断一组数据当中，是否===有点类似布尔类型的\n·这个也可以应用在pandas中的DataFrame中\n&#39;</code></pre><h3 id="unique"><a href="#unique" class="headerlink" title="unique"></a>unique</h3><pre><code class="python">arr = np.array([[1, 2, 1], [2, 3, 4]])print (arr)print (np.unique(arr))</code></pre><pre><code>[[1 2 1] [2 3 4]][1 2 3 4]</code></pre>]]></content>
      
      
      <categories>
          
          <category> DataAnalysis </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数据的清洗和规整（一）</title>
      <link href="blog/gvi1hn/"/>
      <url>blog/gvi1hn/</url>
      
        <content type="html"><![CDATA[<h2 id="一、数据预览：tail（）、head（）"><a href="#一、数据预览：tail（）、head（）" class="headerlink" title="一、数据预览：tail（）、head（）"></a>一、数据预览：tail（）、head（）</h2><pre><code class="python">import numpy as npimport pandas as pddf_obj = pd.DataFrame(np.random.randn(5,4), columns = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;])print(df_obj.tail())# 数据预览尾巴print(df_obj.head())# 数据预览头部</code></pre><pre><code>          a         b         c         d0 -0.507788  0.213237  0.003150 -0.7773121 -0.896653 -2.188016 -0.114848  0.1670572 -1.131242 -0.142287 -1.027330  1.8618143  0.369608  0.823453  1.030830 -0.0417784 -0.647625  0.056791 -0.394078 -1.347718          a         b         c         d0 -0.507788  0.213237  0.003150 -0.7773121 -0.896653 -2.188016 -0.114848  0.1670572 -1.131242 -0.142287 -1.027330  1.8618143  0.369608  0.823453  1.030830 -0.0417784 -0.647625  0.056791 -0.394078 -1.347718</code></pre><h2 id="二、数据描述：shape、info"><a href="#二、数据描述：shape、info" class="headerlink" title="二、数据描述：shape、info()"></a>二、数据描述：shape、info()</h2><pre><code class="python">print (&#39;数据集有%i行，%i列&#39; %(df_obj.shape[0], df_obj.shape[1]))</code></pre><pre><code>数据集有5行，4列</code></pre><pre><code class="python">print(df_obj.info())</code></pre><pre><code>&lt;class &#39;pandas.core.frame.DataFrame&#39;&gt;RangeIndex: 5 entries, 0 to 4Data columns (total 4 columns):a    5 non-null float64b    5 non-null float64c    5 non-null float64d    5 non-null float64dtypes: float64(4)memory usage: 288.0 bytesNone</code></pre><h2 id="三、数据统计：describe"><a href="#三、数据统计：describe" class="headerlink" title="三、数据统计：describe()"></a>三、数据统计：describe()</h2><pre><code class="python">print(df_obj.describe())</code></pre><pre><code>              a         b         c         dcount  5.000000  5.000000  5.000000  5.000000mean  -0.562740 -0.247365 -0.100455 -0.027587std    0.573191  1.143294  0.747673  1.215808min   -1.131242 -2.188016 -1.027330 -1.34771825%   -0.896653 -0.142287 -0.394078 -0.77731250%   -0.647625  0.056791 -0.114848 -0.04177875%   -0.507788  0.213237  0.003150  0.167057max    0.369608  0.823453  1.030830  1.861814</code></pre><h2 id="四、pandas-不完全显示行列"><a href="#四、pandas-不完全显示行列" class="headerlink" title="四、pandas 不完全显示行列"></a>四、pandas 不完全显示行列</h2><pre><code>pd.set_option(&#39;display.max_rows&#39;, 100)        //显示的最大行数（避免只显示部分行数据）pd.set_option(&#39;display.max_columns&#39;, 1000)    //显示的最大列数（避免列显示不全）pd.set_option(&quot;display.max_colwidth&quot;, 1000)   //每一列最大的宽度（避免属性值或列名显示不全）pd.set_option(&#39;display.width&#39;, 1000)          //每一行的宽度（避免换行）</code></pre><h2 id="五、删除指定行列数据"><a href="#五、删除指定行列数据" class="headerlink" title="五、删除指定行列数据"></a>五、删除指定行列数据</h2><pre><code class="python">import pandas as pdimport numpy as np</code></pre><pre><code class="python">dict_data = &#123;&#39;A&#39;: 1.,             &#39;B&#39;: pd.Timestamp(&#39;20161217&#39;),             &#39;C&#39;: pd.Series(1, index=list(range(4)),dtype=&#39;float32&#39;),             &#39;D&#39;: np.array([3] * 4,dtype=&#39;int32&#39;),             &#39;E&#39; : pd.Categorical([&quot;Python&quot;,&quot;Java&quot;,&quot;C++&quot;,&quot;C#&quot;]),             &#39;F&#39; : &#39;ChinaHadoop&#39; &#125;df_obj2 = pd.DataFrame(dict_data)print(df_obj2)</code></pre><pre><code>     A          B    C  D       E            F0  1.0 2016-12-17  1.0  3  Python  ChinaHadoop1  1.0 2016-12-17  1.0  3    Java  ChinaHadoop2  1.0 2016-12-17  1.0  3     C++  ChinaHadoop3  1.0 2016-12-17  1.0  3      C#  ChinaHadoop</code></pre><h3 id="del"><a href="#del" class="headerlink" title="del"></a>del</h3><blockquote><p>删除列</p></blockquote><pre><code class="python">del df_obj2[&#39;A&#39;]print (df_obj2.head())</code></pre><pre><code>           B    C  D       E            F0 2016-12-17  1.0  3  Python  ChinaHadoop1 2016-12-17  1.0  3    Java  ChinaHadoop2 2016-12-17  1.0  3     C++  ChinaHadoop3 2016-12-17  1.0  3      C#  ChinaHadoop</code></pre><h3 id="drop"><a href="#drop" class="headerlink" title="drop"></a>drop</h3><blockquote><p>删除行/列数据</p></blockquote><pre><code class="python">dict_data = &#123;&#39;A&#39;: 1.,             &#39;B&#39;: pd.Timestamp(&#39;20161217&#39;),             &#39;C&#39;: pd.Series(1, index=list(range(4)),dtype=&#39;float32&#39;),             &#39;D&#39;: np.array([3] * 4,dtype=&#39;int32&#39;),             &#39;E&#39; : pd.Categorical([&quot;Python&quot;,&quot;Java&quot;,&quot;C++&quot;,&quot;C#&quot;]),             &#39;F&#39; : &#39;ChinaHadoop&#39; &#125;df_obj3 = pd.DataFrame(dict_data,index = [&#39;sfd&#39;,&#39;sdfd&#39;,&#39;wer&#39;,&#39;rwer&#39;])print (df_obj3.head(7))print(df_obj3.drop(&#39;wer&#39;))#删除行print(df_obj3.drop(&#39;F&#39;,axis=1))#删除列</code></pre><pre><code>        A          B   C  D       E            Fsfd   1.0 2016-12-17 NaN  3  Python  ChinaHadoopsdfd  1.0 2016-12-17 NaN  3    Java  ChinaHadoopwer   1.0 2016-12-17 NaN  3     C++  ChinaHadooprwer  1.0 2016-12-17 NaN  3      C#  ChinaHadoop        A          B   C  D       E            Fsfd   1.0 2016-12-17 NaN  3  Python  ChinaHadoopsdfd  1.0 2016-12-17 NaN  3    Java  ChinaHadooprwer  1.0 2016-12-17 NaN  3      C#  ChinaHadoop        A          B   C  D       Esfd   1.0 2016-12-17 NaN  3  Pythonsdfd  1.0 2016-12-17 NaN  3    Javawer   1.0 2016-12-17 NaN  3     C++rwer  1.0 2016-12-17 NaN  3      C#</code></pre><h2 id="六、处理缺失数据"><a href="#六、处理缺失数据" class="headerlink" title="六、处理缺失数据"></a>六、处理缺失数据</h2><pre><code class="python">df_data = pd.DataFrame([np.random.randn(3), [1., np.nan, np.nan],                       [4., np.nan, np.nan], [1., np.nan, 2.]])df_data.head()</code></pre><table><thead><tr><th></th><th>0</th><th>1</th><th>2</th></tr></thead><tbody><tr><td>0</td><td>-0.702713</td><td>-0.991383</td><td>-1.058464</td></tr><tr><td>1</td><td>1.000000</td><td>NaN</td><td>NaN</td></tr><tr><td>2</td><td>4.000000</td><td>NaN</td><td>NaN</td></tr><tr><td>3</td><td>1.000000</td><td>NaN</td><td>2.000000</td></tr></tbody></table><h3 id="判断是否存在缺失值"><a href="#判断是否存在缺失值" class="headerlink" title="判断是否存在缺失值"></a>判断是否存在缺失值</h3><pre><code class="python">df_data.isnull()</code></pre><table><thead><tr><th></th><th>0</th><th>1</th><th>2</th></tr></thead><tbody><tr><td>0</td><td>False</td><td>False</td><td>False</td></tr><tr><td>1</td><td>False</td><td>True</td><td>True</td></tr><tr><td>2</td><td>False</td><td>True</td><td>True</td></tr><tr><td>3</td><td>False</td><td>True</td><td>False</td></tr></tbody></table><h3 id="丢弃缺失数据"><a href="#丢弃缺失数据" class="headerlink" title="丢弃缺失数据"></a>丢弃缺失数据</h3><pre><code class="python">print(df_data.dropna(axis=0))#0是行；1是列</code></pre><pre><code>          0         1         20 -0.702713 -0.991383 -1.058464</code></pre><h3 id="填充缺失数据"><a href="#填充缺失数据" class="headerlink" title="填充缺失数据"></a>填充缺失数据</h3><pre><code class="python">df_data.fillna(-100.)</code></pre><table><thead><tr><th></th><th>0</th><th>1</th><th>2</th></tr></thead><tbody><tr><td>0</td><td>-0.702713</td><td>-0.991383</td><td>-1.058464</td></tr><tr><td>1</td><td>1.000000</td><td>-100.000000</td><td>-100.000000</td></tr><tr><td>2</td><td>4.000000</td><td>-100.000000</td><td>-100.000000</td></tr><tr><td>3</td><td>1.000000</td><td>-100.000000</td><td>2.000000</td></tr></tbody></table><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
      
      
      <categories>
          
          <category> DataAnalysis </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数据的清洗和规整（二）</title>
      <link href="blog/dggm37/"/>
      <url>blog/dggm37/</url>
      
        <content type="html"><![CDATA[<h2 id="三、数据规整-连接-含索引"><a href="#三、数据规整-连接-含索引" class="headerlink" title="三、数据规整-连接-含索引"></a>三、数据规整-连接-含索引</h2><ul><li>数据连接 merge</li></ul><pre><code class="python">import pandas as pdimport numpy as np</code></pre><pre><code class="python">df_obj1 = pd.DataFrame(&#123;&#39;key&#39;: [&#39;b&#39;, &#39;b&#39;, &#39;a&#39;, &#39;c&#39;, &#39;a&#39;, &#39;a&#39;, &#39;b&#39;],                        &#39;data1&#39; : [&#39;sfd&#39;,&#39;fdsf&#39;,&#39;we&#39;,24,3253,234,23]&#125;)df_obj2 = pd.DataFrame(&#123;&#39;key&#39;: [&#39;a&#39;, &#39;b&#39;, &#39;d&#39;],                        &#39;data2&#39; : np.random.randint(0,10,3)&#125;)print (df_obj1)print (df_obj2)</code></pre><pre><code>  key data10   b   sfd1   b  fdsf2   a    we3   c    244   a  32535   a   2346   b    23  key  data20   a      01   b      62   d      6</code></pre><h3 id="merge-和-on"><a href="#merge-和-on" class="headerlink" title="merge 和 on"></a>merge 和 on</h3><blockquote><p>默认将重叠列的列名作为“外键”进行连接</p></blockquote><pre><code class="python">pd.merge(df_obj1, df_obj2)</code></pre><table><thead><tr><th></th><th>key</th><th>data1</th><th>data2</th></tr></thead><tbody><tr><td>0</td><td>b</td><td>sfd</td><td>6</td></tr><tr><td>1</td><td>b</td><td>fdsf</td><td>6</td></tr><tr><td>2</td><td>b</td><td>23</td><td>6</td></tr><tr><td>3</td><td>a</td><td>we</td><td>0</td></tr><tr><td>4</td><td>a</td><td>3253</td><td>0</td></tr><tr><td>5</td><td>a</td><td>234</td><td>0</td></tr></tbody></table><pre><code class="python"># on显示指定“外键”pd.merge(df_obj1, df_obj2, on=&#39;key&#39;)</code></pre><table><thead><tr><th></th><th>key</th><th>data1</th><th>data2</th></tr></thead><tbody><tr><td>0</td><td>b</td><td>sfd</td><td>6</td></tr><tr><td>1</td><td>b</td><td>fdsf</td><td>6</td></tr><tr><td>2</td><td>b</td><td>23</td><td>6</td></tr><tr><td>3</td><td>a</td><td>we</td><td>0</td></tr><tr><td>4</td><td>a</td><td>3253</td><td>0</td></tr><tr><td>5</td><td>a</td><td>234</td><td>0</td></tr></tbody></table><h3 id="left-on-和-right-on"><a href="#left-on-和-right-on" class="headerlink" title="left-on 和 right-on"></a>left-on 和 right-on</h3><pre><code class="python"># left_on，right_on分别指定左侧数据和右侧数据的“外键”# 更改列名df_obj1 = df_obj1.rename(columns=&#123;&#39;key&#39;:&#39;key1&#39;&#125;)df_obj2 = df_obj2.rename(columns=&#123;&#39;key&#39;:&#39;key2&#39;&#125;)</code></pre><pre><code class="python">print(df_obj1)print(df_obj2)</code></pre><pre><code>  key1 data10    b   sfd1    b  fdsf2    a    we3    c    244    a  32535    a   2346    b    23  key2  data20    a      01    b      62    d      6</code></pre><pre><code class="python">pd.merge(df_obj1, df_obj2, left_on=&#39;key1&#39;, right_on=&#39;key2&#39;)</code></pre><table><thead><tr><th></th><th>key1</th><th>data1</th><th>key2</th><th>data2</th></tr></thead><tbody><tr><td>0</td><td>b</td><td>sfd</td><td>b</td><td>6</td></tr><tr><td>1</td><td>b</td><td>fdsf</td><td>b</td><td>6</td></tr><tr><td>2</td><td>b</td><td>23</td><td>b</td><td>6</td></tr><tr><td>3</td><td>a</td><td>we</td><td>a</td><td>0</td></tr><tr><td>4</td><td>a</td><td>3253</td><td>a</td><td>0</td></tr><tr><td>5</td><td>a</td><td>234</td><td>a</td><td>0</td></tr></tbody></table><h3 id="how"><a href="#how" class="headerlink" title="how"></a>how</h3><pre><code class="python"># “外连接”pd.merge(df_obj1, df_obj2, left_on=&#39;key1&#39;, right_on=&#39;key2&#39;, how=&#39;outer&#39;)</code></pre><table><thead><tr><th></th><th>key1</th><th>data1</th><th>key2</th><th>data2</th></tr></thead><tbody><tr><td>0</td><td>b</td><td>sfd</td><td>b</td><td>6.0</td></tr><tr><td>1</td><td>b</td><td>fdsf</td><td>b</td><td>6.0</td></tr><tr><td>2</td><td>b</td><td>23</td><td>b</td><td>6.0</td></tr><tr><td>3</td><td>a</td><td>we</td><td>a</td><td>0.0</td></tr><tr><td>4</td><td>a</td><td>3253</td><td>a</td><td>0.0</td></tr><tr><td>5</td><td>a</td><td>234</td><td>a</td><td>0.0</td></tr><tr><td>6</td><td>c</td><td>24</td><td>NaN</td><td>NaN</td></tr><tr><td>7</td><td>NaN</td><td>NaN</td><td>d</td><td>6.0</td></tr></tbody></table><pre><code class="python"># 左连接pd.merge(df_obj1, df_obj2, left_on=&#39;key1&#39;, right_on=&#39;key2&#39;, how=&#39;left&#39;)</code></pre><table><thead><tr><th></th><th>key1</th><th>data1</th><th>key2</th><th>data2</th></tr></thead><tbody><tr><td>0</td><td>b</td><td>sfd</td><td>b</td><td>6.0</td></tr><tr><td>1</td><td>b</td><td>fdsf</td><td>b</td><td>6.0</td></tr><tr><td>2</td><td>a</td><td>we</td><td>a</td><td>0.0</td></tr><tr><td>3</td><td>c</td><td>24</td><td>NaN</td><td>NaN</td></tr><tr><td>4</td><td>a</td><td>3253</td><td>a</td><td>0.0</td></tr><tr><td>5</td><td>a</td><td>234</td><td>a</td><td>0.0</td></tr><tr><td>6</td><td>b</td><td>23</td><td>b</td><td>6.0</td></tr></tbody></table><pre><code class="python"># 右连接pd.merge(df_obj1, df_obj2, left_on=&#39;key1&#39;, right_on=&#39;key2&#39;, how=&#39;right&#39;)</code></pre><table><thead><tr><th></th><th>key1</th><th>data1</th><th>key2</th><th>data2</th></tr></thead><tbody><tr><td>0</td><td>b</td><td>sfd</td><td>b</td><td>6</td></tr><tr><td>1</td><td>b</td><td>fdsf</td><td>b</td><td>6</td></tr><tr><td>2</td><td>b</td><td>23</td><td>b</td><td>6</td></tr><tr><td>3</td><td>a</td><td>we</td><td>a</td><td>0</td></tr><tr><td>4</td><td>a</td><td>3253</td><td>a</td><td>0</td></tr><tr><td>5</td><td>a</td><td>234</td><td>a</td><td>0</td></tr><tr><td>6</td><td>NaN</td><td>NaN</td><td>d</td><td>6</td></tr></tbody></table><h3 id="处理重复列名-suffixes"><a href="#处理重复列名-suffixes" class="headerlink" title="处理重复列名 suffixes"></a>处理重复列名 suffixes</h3><pre><code class="python"># 处理重复列名df_obj1 = pd.DataFrame(&#123;&#39;key&#39;: [&#39;b&#39;, &#39;b&#39;, &#39;a&#39;, &#39;c&#39;, &#39;a&#39;, &#39;a&#39;, &#39;b&#39;],                        &#39;data&#39; : np.random.randint(0,10,7)&#125;)df_obj2 = pd.DataFrame(&#123;&#39;key&#39;: [&#39;a&#39;, &#39;b&#39;, &#39;d&#39;],                        &#39;data&#39; : np.random.randint(0,10,3)&#125;)pd.merge(df_obj1, df_obj2, on=&#39;key&#39;, suffixes=(&#39;_left&#39;, &#39;_right&#39;))</code></pre><table><thead><tr><th></th><th>key</th><th>data_left</th><th>data_right</th></tr></thead><tbody><tr><td>0</td><td>b</td><td>9</td><td>1</td></tr><tr><td>1</td><td>b</td><td>1</td><td>1</td></tr><tr><td>2</td><td>b</td><td>6</td><td>1</td></tr><tr><td>3</td><td>a</td><td>7</td><td>1</td></tr><tr><td>4</td><td>a</td><td>3</td><td>1</td></tr><tr><td>5</td><td>a</td><td>4</td><td>1</td></tr></tbody></table><pre><code class="python"># 按索引连接df_obj3 = pd.DataFrame(&#123;&#39;key&#39;: [&#39;b&#39;, &#39;b&#39;, &#39;a&#39;, &#39;c&#39;, &#39;a&#39;, &#39;a&#39;, &#39;b&#39;],                        &#39;data1&#39; : np.random.randint(0,10,7)&#125;)df_obj4 = pd.DataFrame(&#123;&#39;data2&#39; : np.random.randint(0,10,3)&#125;, index=[&#39;a&#39;, &#39;b&#39;, &#39;d&#39;])</code></pre><pre><code class="python">print(df_obj3)print(df_obj4)</code></pre><pre><code>  key  data10   b      71   b      42   a      13   c      94   a      25   a      96   b      7   data2a      9b      4d      0</code></pre><pre><code class="python">pd.merge(df_obj3, df_obj4, left_on=&#39;key&#39;, right_index=True)</code></pre><table><thead><tr><th></th><th>key</th><th>data1</th><th>data2</th></tr></thead><tbody><tr><td>0</td><td>b</td><td>7</td><td>4</td></tr><tr><td>1</td><td>b</td><td>4</td><td>4</td></tr><tr><td>6</td><td>b</td><td>7</td><td>4</td></tr><tr><td>2</td><td>a</td><td>1</td><td>9</td></tr><tr><td>4</td><td>a</td><td>2</td><td>9</td></tr><tr><td>5</td><td>a</td><td>9</td><td>9</td></tr></tbody></table><h3 id="按索引连接-right-index"><a href="#按索引连接-right-index" class="headerlink" title="按索引连接 right_index"></a>按索引连接 right_index</h3><pre><code class="python"># 按索引连接df_obj1 = pd.DataFrame(&#123;&#39;key&#39;: [&#39;b&#39;, &#39;b&#39;, &#39;a&#39;, &#39;c&#39;, &#39;a&#39;, &#39;a&#39;, &#39;b&#39;],                        &#39;data1&#39; : np.random.randint(0,10,7)&#125;)df_obj2 = pd.DataFrame(&#123;&#39;data2&#39; : np.random.randint(0,10,3)&#125;, index=[&#39;a&#39;, &#39;b&#39;, &#39;d&#39;])</code></pre><pre><code class="python">print(df_obj1)print(df_obj2)</code></pre><pre><code>  key  data10   b      01   b      22   a      73   c      34   a      15   a      16   b      6   data2a      2b      1d      1</code></pre><pre><code class="python">pd.merge(df_obj1, df_obj2, left_on=&#39;key&#39;, right_index=True)</code></pre><table><thead><tr><th></th><th>key</th><th>data1</th><th>data2</th></tr></thead><tbody><tr><td>0</td><td>b</td><td>0</td><td>1</td></tr><tr><td>1</td><td>b</td><td>2</td><td>1</td></tr><tr><td>6</td><td>b</td><td>6</td><td>1</td></tr><tr><td>2</td><td>a</td><td>7</td><td>2</td></tr><tr><td>4</td><td>a</td><td>1</td><td>2</td></tr><tr><td>5</td><td>a</td><td>1</td><td>2</td></tr></tbody></table><h2 id="四、数据合并"><a href="#四、数据合并" class="headerlink" title="四、数据合并"></a>四、数据合并</h2><ul><li>数据合并 concat</li><li>按索引连接===right_index</li></ul><pre><code class="python">import numpy as npimport pandas as pd</code></pre><h3 id="numpy-的-concat"><a href="#numpy-的-concat" class="headerlink" title="numpy 的 concat"></a>numpy 的 concat</h3><pre><code class="python">arr1 = np.random.randint(0, 10, (3, 4))arr2 = np.random.randint(0, 10, (3, 4))print (arr1)print (arr2)</code></pre><pre><code>[[6 0 3 2] [5 7 9 8] [5 8 0 3]][[6 5 7 9] [0 1 0 0] [1 1 1 7]]</code></pre><pre><code class="python">np.concatenate([arr1, arr2])</code></pre><pre><code>array([[6, 0, 3, 2],       [5, 7, 9, 8],       [5, 8, 0, 3],       [6, 5, 7, 9],       [0, 1, 0, 0],       [1, 1, 1, 7]])</code></pre><pre><code class="python">np.concatenate([arr1, arr2], axis=1)</code></pre><pre><code>array([[6, 0, 3, 2, 6, 5, 7, 9],       [5, 7, 9, 8, 0, 1, 0, 0],       [5, 8, 0, 3, 1, 1, 1, 7]])</code></pre><h3 id="series-上的-concat"><a href="#series-上的-concat" class="headerlink" title="series 上的 concat"></a>series 上的 concat</h3><pre><code class="python"># index 没有重复的情况ser_obj1 = pd.Series(np.random.randint(0, 10, 5), index=range(0,5))ser_obj2 = pd.Series(np.random.randint(0, 10, 4), index=range(5,9))ser_obj3 = pd.Series(np.random.randint(0, 10, 3), index=range(9,12))</code></pre><pre><code class="python">pd.concat([ser_obj1, ser_obj2, ser_obj3])</code></pre><pre><code>0     01     42     53     14     95     76     87     58     09     510    911    0dtype: int32</code></pre><pre><code class="python">pd.concat([ser_obj1, ser_obj2, ser_obj3], axis=1)</code></pre><table><thead><tr><th></th><th>0</th><th>1</th><th>2</th></tr></thead><tbody><tr><td>0</td><td>0.0</td><td>NaN</td><td>NaN</td></tr><tr><td>1</td><td>4.0</td><td>NaN</td><td>NaN</td></tr><tr><td>2</td><td>5.0</td><td>NaN</td><td>NaN</td></tr><tr><td>3</td><td>1.0</td><td>NaN</td><td>NaN</td></tr><tr><td>4</td><td>9.0</td><td>NaN</td><td>NaN</td></tr><tr><td>5</td><td>NaN</td><td>7.0</td><td>NaN</td></tr><tr><td>6</td><td>NaN</td><td>8.0</td><td>NaN</td></tr><tr><td>7</td><td>NaN</td><td>5.0</td><td>NaN</td></tr><tr><td>8</td><td>NaN</td><td>0.0</td><td>NaN</td></tr><tr><td>9</td><td>NaN</td><td>NaN</td><td>5.0</td></tr><tr><td>10</td><td>NaN</td><td>NaN</td><td>9.0</td></tr><tr><td>11</td><td>NaN</td><td>NaN</td><td>0.0</td></tr></tbody></table><pre><code class="python"># index 有重复的情况ser_obj1 = pd.Series(np.random.randint(0, 10, 5), index=range(5))ser_obj2 = pd.Series(np.random.randint(0, 10, 4), index=range(4))ser_obj3 = pd.Series(np.random.randint(0, 10, 3), index=range(3))print (ser_obj1)print (ser_obj2)print (ser_obj3)</code></pre><pre><code>0    51    32    03    84    3dtype: int320    51    32    23    1dtype: int320    51    82    6dtype: int32</code></pre><pre><code class="python">pd.concat([ser_obj1, ser_obj2, ser_obj3])</code></pre><pre><code>0    51    32    03    84    30    51    32    23    10    51    82    6dtype: int32</code></pre><pre><code class="python">pd.concat([ser_obj1, ser_obj2, ser_obj3], axis=1, join=&#39;inner&#39;)</code></pre><table><thead><tr><th></th><th>0</th><th>1</th><th>2</th></tr></thead><tbody><tr><td>0</td><td>5</td><td>5</td><td>5</td></tr><tr><td>1</td><td>3</td><td>3</td><td>8</td></tr><tr><td>2</td><td>0</td><td>2</td><td>6</td></tr></tbody></table><h3 id="dataframe-上的-concat"><a href="#dataframe-上的-concat" class="headerlink" title="dataframe 上的 concat"></a>dataframe 上的 concat</h3><pre><code class="python">df_obj1 = pd.DataFrame(np.random.randint(0, 10, (3, 2)), index=[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;],                       columns=[&#39;A&#39;, &#39;B&#39;])df_obj2 = pd.DataFrame(np.random.randint(0, 10, (2, 2)), index=[&#39;a&#39;, &#39;b&#39;],                       columns=[&#39;C&#39;, &#39;D&#39;])print (df_obj1)print (df_obj2)</code></pre><pre><code>   A  Ba  4  3b  8  1c  6  3   C  Da  1  3b  8  2</code></pre><pre><code class="python">pd.concat([df_obj1, df_obj2])</code></pre><pre><code>C:\Users\wztli\Anaconda3\lib\site-packages\ipykernel_launcher.py:1: FutureWarning: Sorting because non-concatenation axis is not aligned. A future versionof pandas will change to not sort by default.To accept the future behavior, pass &#39;sort=False&#39;.To retain the current behavior and silence the warning, pass &#39;sort=True&#39;.  &quot;&quot;&quot;Entry point for launching an IPython kernel.</code></pre><table><thead><tr><th></th><th>A</th><th>B</th><th>C</th><th>D</th></tr></thead><tbody><tr><td>a</td><td>4.0</td><td>3.0</td><td>NaN</td><td>NaN</td></tr><tr><td>b</td><td>8.0</td><td>1.0</td><td>NaN</td><td>NaN</td></tr><tr><td>c</td><td>6.0</td><td>3.0</td><td>NaN</td><td>NaN</td></tr><tr><td>a</td><td>NaN</td><td>NaN</td><td>1.0</td><td>3.0</td></tr><tr><td>b</td><td>NaN</td><td>NaN</td><td>8.0</td><td>2.0</td></tr></tbody></table><pre><code class="python">pd.concat([df_obj1, df_obj2], axis=1)</code></pre><pre><code>C:\Users\wztli\Anaconda3\lib\site-packages\ipykernel_launcher.py:1: FutureWarning: Sorting because non-concatenation axis is not aligned. A future versionof pandas will change to not sort by default.To accept the future behavior, pass &#39;sort=False&#39;.To retain the current behavior and silence the warning, pass &#39;sort=True&#39;.  &quot;&quot;&quot;Entry point for launching an IPython kernel.</code></pre><table><thead><tr><th></th><th>A</th><th>B</th><th>C</th><th>D</th></tr></thead><tbody><tr><td>a</td><td>4</td><td>3</td><td>1.0</td><td>3.0</td></tr><tr><td>b</td><td>8</td><td>1</td><td>8.0</td><td>2.0</td></tr><tr><td>c</td><td>6</td><td>3</td><td>NaN</td><td>NaN</td></tr></tbody></table><h2 id="五、数据重构"><a href="#五、数据重构" class="headerlink" title="五、数据重构"></a>五、数据重构</h2><pre><code class="python">import numpy as npimport pandas as pd</code></pre><h3 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h3><pre><code class="python">df_obj = pd.DataFrame(np.random.randint(0,10, (5,2)), columns=[&#39;data1&#39;, &#39;data2&#39;])df_obj</code></pre><table><thead><tr><th></th><th>data1</th><th>data2</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>4</td></tr><tr><td>1</td><td>6</td><td>2</td></tr><tr><td>2</td><td>9</td><td>8</td></tr><tr><td>3</td><td>7</td><td>0</td></tr><tr><td>4</td><td>3</td><td>1</td></tr></tbody></table><pre><code class="python">stacked = df_obj.stack()print (stacked)</code></pre><pre><code>0  data1    0   data2    41  data1    6   data2    22  data1    9   data2    83  data1    7   data2    04  data1    3   data2    1dtype: int32</code></pre><pre><code class="python">print (type(stacked))print (type(stacked.index))</code></pre><pre><code>&lt;class &#39;pandas.core.series.Series&#39;&gt;&lt;class &#39;pandas.core.indexes.multi.MultiIndex&#39;&gt;</code></pre><h3 id="unstack"><a href="#unstack" class="headerlink" title="unstack"></a>unstack</h3><pre><code class="python"># 默认操作内层索引stacked.unstack()</code></pre><table><thead><tr><th></th><th>data1</th><th>data2</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>4</td></tr><tr><td>1</td><td>6</td><td>2</td></tr><tr><td>2</td><td>9</td><td>8</td></tr><tr><td>3</td><td>7</td><td>0</td></tr><tr><td>4</td><td>3</td><td>1</td></tr></tbody></table><pre><code class="python"># 通过level指定操作索引的级别stacked.unstack(level=0)</code></pre><table><thead><tr><th></th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th></tr></thead><tbody><tr><td>data1</td><td>0</td><td>6</td><td>9</td><td>7</td><td>3</td></tr><tr><td>data2</td><td>4</td><td>2</td><td>8</td><td>0</td><td>1</td></tr></tbody></table><h2 id="六、数据转换"><a href="#六、数据转换" class="headerlink" title="六、数据转换"></a>六、数据转换</h2><pre><code class="python">import numpy as npimport pandas as pd</code></pre><h3 id="重复数据-duplicates-函数"><a href="#重复数据-duplicates-函数" class="headerlink" title="重复数据 duplicates 函数"></a>重复数据 duplicates 函数</h3><pre><code class="python">df_obj = pd.DataFrame(&#123;&#39;data1&#39; : [&#39;a&#39;] * 4 + [&#39;b&#39;] * 4,                       &#39;data2&#39; : np.random.randint(0, 4, 8)&#125;)df_obj</code></pre><table><thead><tr><th></th><th>data1</th><th>data2</th></tr></thead><tbody><tr><td>0</td><td>a</td><td>3</td></tr><tr><td>1</td><td>a</td><td>2</td></tr><tr><td>2</td><td>a</td><td>2</td></tr><tr><td>3</td><td>a</td><td>1</td></tr><tr><td>4</td><td>b</td><td>0</td></tr><tr><td>5</td><td>b</td><td>2</td></tr><tr><td>6</td><td>b</td><td>2</td></tr><tr><td>7</td><td>b</td><td>1</td></tr></tbody></table><pre><code class="python">df_obj.duplicated()</code></pre><pre><code>0    False1    False2     True3    False4    False5    False6     True7    Falsedtype: bool</code></pre><pre><code class="python">df_obj.drop_duplicates()</code></pre><table><thead><tr><th></th><th>data1</th><th>data2</th></tr></thead><tbody><tr><td>0</td><td>a</td><td>3</td></tr><tr><td>1</td><td>a</td><td>2</td></tr><tr><td>3</td><td>a</td><td>1</td></tr><tr><td>4</td><td>b</td><td>0</td></tr><tr><td>5</td><td>b</td><td>2</td></tr><tr><td>7</td><td>b</td><td>1</td></tr></tbody></table><pre><code class="python">df_obj.drop_duplicates(&#39;data2&#39;)</code></pre><table><thead><tr><th></th><th>data1</th><th>data2</th></tr></thead><tbody><tr><td>0</td><td>a</td><td>3</td></tr><tr><td>1</td><td>a</td><td>2</td></tr><tr><td>3</td><td>a</td><td>1</td></tr><tr><td>4</td><td>b</td><td>0</td></tr></tbody></table><h3 id="map-函数"><a href="#map-函数" class="headerlink" title="map 函数"></a>map 函数</h3><pre><code class="python">ser_obj = pd.Series(np.random.randint(0,10,10))ser_obj</code></pre><pre><code>0    11    92    13    24    75    26    47    58    49    6dtype: int32</code></pre><pre><code class="python">ser_obj.map(lambda x : x ** 2)</code></pre><pre><code>0     11    812     13     44    495     46    167    258    169    36dtype: int64</code></pre><h3 id="数据替换-repalce"><a href="#数据替换-repalce" class="headerlink" title="数据替换 repalce"></a>数据替换 repalce</h3><pre><code class="python"># 替换单个值ser_obj.replace(0, -100)</code></pre><pre><code>0    11    92    13    24    75    26    47    58    49    6dtype: int32</code></pre><pre><code class="python"># 替换多个值ser_obj.replace([0, 2], -100)</code></pre><pre><code>0      11      92      13   -1004      75   -1006      47      58      49      6dtype: int32</code></pre><pre><code class="python"># 替换多个值ser_obj.replace([0, 2], [-100, -200])</code></pre><pre><code>0      11      92      13   -2004      75   -2006      47      58      49      6dtype: int64</code></pre><pre><code class="python">ser_obj.map(lambda x : x ** 2)#### 3. 数据替换repalce# 替换单个值ser_obj.replace(0, -100)# 替换多个值ser_obj.replace([0, 2], -100)# 替换多个值ser_obj.replace([0, 2], [-100, -200])</code></pre><pre><code>0      11      92      13   -2004      75   -2006      47      58      49      6dtype: int64</code></pre>]]></content>
      
      
      <categories>
          
          <category> DataAnalysis </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数据的本地读取</title>
      <link href="blog/lb8ugs/"/>
      <url>blog/lb8ugs/</url>
      
        <content type="html"><![CDATA[<h2 id="一、TXT-文件操作"><a href="#一、TXT-文件操作" class="headerlink" title="一、TXT 文件操作"></a>一、TXT 文件操作</h2><h3 id="读取全部内容"><a href="#读取全部内容" class="headerlink" title="读取全部内容"></a>读取全部内容</h3><pre><code class="python">import numpy as npimport pandas as pd</code></pre><pre><code class="python">txt_filename = &#39;./files/python_wiki.txt&#39;# 打开文件file_obj = open(txt_filename,&#39;r&#39;)# 读取整个文件内容all_content = file_obj.read()# 关闭文件file_obj.close()print (all_content)</code></pre><pre><code>Python is a widely used high-level, general-purpose, interpreted, dynamic programming language.[24][25] Its design philosophy emphasizes code readability, and its syntax allows programmers to express concepts in fewer lines of code than possible in languages such as C++ or Java.[26][27] The language provides constructs intended to enable writing clear programs on both a small and large scale.[28]Python supports multiple programming paradigms, including object-oriented, imperative and functional programming or procedural styles. It features a dynamic type system and automatic memory management and has a large and comprehensive standard library.[29]Python interpreters are available for many operating systems, allowing Python code to run on a wide variety of systems. CPython, the reference implementation of Python, is open source software[30] and has a community-based development model, as do nearly all of its variant implementations. CPython is managed by the non-profit Python Software Foundation.</code></pre><h3 id="逐行读取"><a href="#逐行读取" class="headerlink" title="逐行读取"></a>逐行读取</h3><pre><code class="python">txt_filename = &#39;./files/python_wiki.txt&#39;# 打开文件file_obj = open(txt_filename, &#39;r&#39;)# 逐行读取line1 = file_obj.readline()print (line1)</code></pre><pre><code>Python is a widely used high-level, general-purpose, interpreted, dynamic programming language.[24][25] Its design philosophy emphasizes code readability, and its syntax allows programmers to express concepts in fewer lines of code than possible in languages such as C++ or Java.[26][27] The language provides constructs intended to enable writing clear programs on both a small and large scale.[28]</code></pre><pre><code class="python"># 继续读下一行【不会全部读完】line2 = file_obj.readline()print (line2)# 关闭文件file_obj.close()</code></pre><pre><code>Python supports multiple programming paradigms, including object-oriented, imperative and functional programming or procedural styles. It features a dynamic type system and automatic memory management and has a large and comprehensive standard library.[29]</code></pre><h3 id="读取全部内容，返回列表"><a href="#读取全部内容，返回列表" class="headerlink" title="读取全部内容，返回列表"></a>读取全部内容，返回列表</h3><pre><code class="python">txt_filename = &#39;./files/python_wiki.txt&#39;# 打开文件file_obj = open(txt_filename, &#39;r&#39;)lines = file_obj.readlines()for i, line in enumerate(lines):    print (&#39;%i: %s&#39; %(i, line))# 关闭文件file_obj.close()</code></pre><pre><code>0: Python is a widely used high-level, general-purpose, interpreted, dynamic programming language.[24][25] Its design philosophy emphasizes code readability, and its syntax allows programmers to express concepts in fewer lines of code than possible in languages such as C++ or Java.[26][27] The language provides constructs intended to enable writing clear programs on both a small and large scale.[28]1: Python supports multiple programming paradigms, including object-oriented, imperative and functional programming or procedural styles. It features a dynamic type system and automatic memory management and has a large and comprehensive standard library.[29]2: Python interpreters are available for many operating systems, allowing Python code to run on a wide variety of systems. CPython, the reference implementation of Python, is open source software[30] and has a community-based development model, as do nearly all of its variant implementations. CPython is managed by the non-profit Python Software Foundation.</code></pre><h3 id="写操作"><a href="#写操作" class="headerlink" title="写操作"></a>写操作</h3><pre><code class="python">txt_filename = &#39;./files/test_write.txt&#39;# 打开文件file_obj = open(txt_filename, &#39;w&#39;)# 写入全部内容file_obj.write(&quot;《Python数据分析》&quot;)file_obj.close()</code></pre><pre><code class="python">txt_filename = &#39;./files/test_write.txt&#39;# 打开文件file_obj = open(txt_filename, &#39;w&#39;)# 写入字符串列表lines = [&#39;这是第%i行\n&#39; %n for n in range(10)]file_obj.writelines(lines)file_obj.close()</code></pre><h3 id="with-语句"><a href="#with-语句" class="headerlink" title="with 语句"></a>with 语句</h3><pre><code class="python">txt_filename = &#39;./files/test_write.txt&#39;with open(txt_filename, &#39;r&#39;) as f_obj:    print (f_obj.read())</code></pre><pre><code>这是第0行这是第1行这是第2行这是第3行这是第4行这是第5行这是第6行这是第7行这是第8行这是第9行</code></pre><h2 id="二、CSV-文件操作"><a href="#二、CSV-文件操作" class="headerlink" title="二、CSV 文件操作"></a>二、CSV 文件操作</h2><h3 id="pandas-读-csv-文件"><a href="#pandas-读-csv-文件" class="headerlink" title="pandas 读 csv 文件"></a>pandas 读 csv 文件</h3><blockquote><p>根据路径导入数据以及指定的列</p></blockquote><pre><code class="python">import pandas as pdfilename = &#39;./files/presidential_polls.csv&#39;df = pd.read_csv(filename, usecols=[&#39;cycle&#39;, &#39;type&#39;, &#39;startdate&#39;])#导入指定列print (type(df))print (df.head())</code></pre><pre><code>&lt;class &#39;pandas.core.frame.DataFrame&#39;&gt;   cycle        type   startdate0   2016  polls-plus  10/25/20161   2016  polls-plus  10/27/20162   2016  polls-plus  10/27/20163   2016  polls-plus  10/20/20164   2016  polls-plus  10/20/2016</code></pre><blockquote><p>引用指定的列</p></blockquote><pre><code class="python">cycle_se = df[&#39;cycle&#39;]print (type(cycle_se))print (cycle_se.head())</code></pre><pre><code>&lt;class &#39;pandas.core.series.Series&#39;&gt;0    20161    20162    20163    20164    2016Name: cycle, dtype: int64</code></pre><blockquote><p>多层索引成 dataframe 类型</p></blockquote><pre><code class="python">filename = &#39;./files/presidential_polls.csv&#39;df1 = pd.read_csv(filename,usecols=[&#39;cycle&#39;, &#39;type&#39;, &#39;startdate&#39;,&#39;state&#39;,&#39;grade&#39;],index_col = [&#39;state&#39;,&#39;grade&#39;])print(df1.head())</code></pre><pre><code>                cycle        type   startdatestate    gradeU.S.     B       2016  polls-plus  10/25/2016         A+      2016  polls-plus  10/27/2016Virginia A+      2016  polls-plus  10/27/2016Florida  A       2016  polls-plus  10/20/2016U.S.     B+      2016  polls-plus  10/20/2016</code></pre><blockquote><p>跳过指定的行</p></blockquote><pre><code class="python">filename = &#39;./files/presidential_polls.csv&#39;df2 = pd.read_csv(filename,usecols=[&#39;cycle&#39;, &#39;type&#39;, &#39;startdate&#39;,&#39;state&#39;,&#39;grade&#39;],skiprows=[1, 2, 3])print(df2.head())</code></pre><pre><code>   cycle        type         state   startdate grade0   2016  polls-plus       Florida  10/20/2016     A1   2016  polls-plus          U.S.  10/20/2016    B+2   2016  polls-plus          U.S.  10/22/2016     A3   2016  polls-plus          U.S.  10/26/2016    A-4   2016  polls-plus  Pennsylvania  10/25/2016    B-</code></pre><h3 id="pandas-写-csv-文件"><a href="#pandas-写-csv-文件" class="headerlink" title="pandas 写 csv 文件"></a>pandas 写 csv 文件</h3><blockquote><p>·to_csv 里面的 index 参数作用？===可能是不要索引的意思。</p></blockquote><pre><code class="python">filename = &#39;./files/pandas_output.csv&#39;df.to_csv(filename, index=None)</code></pre><h2 id="三、JSON-文件操作"><a href="#三、JSON-文件操作" class="headerlink" title="三、JSON 文件操作"></a>三、JSON 文件操作</h2><h3 id="json-读操作"><a href="#json-读操作" class="headerlink" title="json 读操作"></a>json 读操作</h3><pre><code class="python">import jsonfilename = &#39;./files/global_temperature.json&#39;with open(filename, &#39;r&#39;) as f_obj:    json_data = json.load(f_obj)# 返回值是dict类型print (type(json_data))</code></pre><pre><code>&lt;class &#39;dict&#39;&gt;</code></pre><pre><code class="python">print (json_data.keys())</code></pre><pre><code>dict_keys([&#39;description&#39;, &#39;data&#39;])</code></pre><h3 id="json-转-CSV"><a href="#json-转-CSV" class="headerlink" title="json 转 CSV"></a>json 转 CSV</h3><pre><code class="python">#print json_data[&#39;data&#39;].keys()print (json_data[&#39;data&#39;].values())</code></pre><pre><code>dict_values([&#39;-0.1247&#39;, &#39;-0.0707&#39;, &#39;-0.0710&#39;, &#39;-0.1481&#39;, &#39;-0.2099&#39;, &#39;-0.2220&#39;, &#39;-0.2101&#39;, &#39;-0.2559&#39;, &#39;-0.1541&#39;, &#39;-0.1032&#39;, &#39;-0.3233&#39;, &#39;-0.2552&#39;, &#39;-0.3079&#39;, &#39;-0.3221&#39;, &#39;-0.2828&#39;, &#39;-0.2279&#39;, &#39;-0.0971&#39;, &#39;-0.1232&#39;, &#39;-0.2578&#39;, &#39;-0.1172&#39;, &#39;-0.0704&#39;, &#39;-0.1471&#39;, &#39;-0.2535&#39;, &#39;-0.3442&#39;, &#39;-0.4240&#39;, &#39;-0.2967&#39;, &#39;-0.2208&#39;, &#39;-0.3767&#39;, &#39;-0.4441&#39;, &#39;-0.4332&#39;, &#39;-0.3862&#39;, &#39;-0.4367&#39;, &#39;-0.3318&#39;, &#39;-0.3205&#39;, &#39;-0.1444&#39;, &#39;-0.0747&#39;, &#39;-0.2979&#39;, &#39;-0.3193&#39;, &#39;-0.2118&#39;, &#39;-0.2082&#39;, &#39;-0.2152&#39;, &#39;-0.1517&#39;, &#39;-0.2318&#39;, &#39;-0.2161&#39;, &#39;-0.2510&#39;, &#39;-0.1464&#39;, &#39;-0.0618&#39;, &#39;-0.1506&#39;, &#39;-0.1749&#39;, &#39;-0.2982&#39;, &#39;-0.1016&#39;, &#39;-0.0714&#39;, &#39;-0.1214&#39;, &#39;-0.2481&#39;, &#39;-0.1075&#39;, &#39;-0.1445&#39;, &#39;-0.1173&#39;, &#39;-0.0204&#39;, &#39;-0.0318&#39;, &#39;-0.0157&#39;, &#39;0.0927&#39;, &#39;0.1974&#39;, &#39;0.1549&#39;, &#39;0.1598&#39;, &#39;0.2948&#39;, &#39;0.1754&#39;, &#39;-0.0013&#39;, &#39;-0.0455&#39;, &#39;-0.0471&#39;, &#39;-0.0550&#39;, &#39;-0.1579&#39;, &#39;-0.0095&#39;, &#39;0.0288&#39;, &#39;0.0997&#39;, &#39;-0.1118&#39;, &#39;-0.1305&#39;, &#39;-0.1945&#39;, &#39;0.0538&#39;, &#39;0.1145&#39;, &#39;0.0640&#39;, &#39;0.0252&#39;, &#39;0.0818&#39;, &#39;0.0924&#39;, &#39;0.1100&#39;, &#39;-0.1461&#39;, &#39;-0.0752&#39;, &#39;-0.0204&#39;, &#39;-0.0112&#39;, &#39;-0.0282&#39;, &#39;0.0937&#39;, &#39;0.0383&#39;, &#39;-0.0775&#39;, &#39;0.0280&#39;, &#39;0.1654&#39;, &#39;-0.0698&#39;, &#39;0.0060&#39;, &#39;-0.0769&#39;, &#39;0.1996&#39;, &#39;0.1139&#39;, &#39;0.2288&#39;, &#39;0.2651&#39;, &#39;0.3024&#39;, &#39;0.1836&#39;, &#39;0.3429&#39;, &#39;0.1510&#39;, &#39;0.1357&#39;, &#39;0.2308&#39;, &#39;0.3710&#39;, &#39;0.3770&#39;, &#39;0.2982&#39;, &#39;0.4350&#39;, &#39;0.4079&#39;, &#39;0.2583&#39;, &#39;0.2857&#39;, &#39;0.3420&#39;, &#39;0.4593&#39;, &#39;0.3225&#39;, &#39;0.5185&#39;, &#39;0.6335&#39;, &#39;0.4427&#39;, &#39;0.4255&#39;, &#39;0.5455&#39;, &#39;0.6018&#39;, &#39;0.6145&#39;, &#39;0.5806&#39;, &#39;0.6583&#39;, &#39;0.6139&#39;, &#39;0.6113&#39;, &#39;0.5415&#39;, &#39;0.6354&#39;, &#39;0.7008&#39;, &#39;0.5759&#39;, &#39;0.6219&#39;, &#39;0.6687&#39;, &#39;0.7402&#39;, &#39;0.8990&#39;])</code></pre><pre><code class="python"># 转换keyyear_str_lst = json_data[&#39;data&#39;].keys()year_lst = [int(year_str) for year_str in year_str_lst]print (year_lst)</code></pre><pre><code>[1880, 1881, 1882, 1883, 1884, 1885, 1886, 1887, 1888, 1889, 1890, 1891, 1892, 1893, 1894, 1895, 1896, 1897, 1898, 1899, 1900, 1901, 1902, 1903, 1904, 1905, 1906, 1907, 1908, 1909, 1910, 1911, 1912, 1913, 1914, 1915, 1916, 1917, 1918, 1919, 1920, 1921, 1922, 1923, 1924, 1925, 1926, 1927, 1928, 1929, 1930, 1931, 1932, 1933, 1934, 1935, 1936, 1937, 1938, 1939, 1940, 1941, 1942, 1943, 1944, 1945, 1946, 1947, 1948, 1949, 1950, 1951, 1952, 1953, 1954, 1955, 1956, 1957, 1958, 1959, 1960, 1961, 1962, 1963, 1964, 1965, 1966, 1967, 1968, 1969, 1970, 1971, 1972, 1973, 1974, 1975, 1976, 1977, 1978, 1979, 1980, 1981, 1982, 1983, 1984, 1985, 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015]</code></pre><pre><code class="python"># 转换valuetemp_str_lst = json_data[&#39;data&#39;].values()temp_lst = [float(temp_str) for temp_str in temp_str_lst]print (temp_lst)</code></pre><pre><code>[-0.1247, -0.0707, -0.071, -0.1481, -0.2099, -0.222, -0.2101, -0.2559, -0.1541, -0.1032, -0.3233, -0.2552, -0.3079, -0.3221, -0.2828, -0.2279, -0.0971, -0.1232, -0.2578, -0.1172, -0.0704, -0.1471, -0.2535, -0.3442, -0.424, -0.2967, -0.2208, -0.3767, -0.4441, -0.4332, -0.3862, -0.4367, -0.3318, -0.3205, -0.1444, -0.0747, -0.2979, -0.3193, -0.2118, -0.2082, -0.2152, -0.1517, -0.2318, -0.2161, -0.251, -0.1464, -0.0618, -0.1506, -0.1749, -0.2982, -0.1016, -0.0714, -0.1214, -0.2481, -0.1075, -0.1445, -0.1173, -0.0204, -0.0318, -0.0157, 0.0927, 0.1974, 0.1549, 0.1598, 0.2948, 0.1754, -0.0013, -0.0455, -0.0471, -0.055, -0.1579, -0.0095, 0.0288, 0.0997, -0.1118, -0.1305, -0.1945, 0.0538, 0.1145, 0.064, 0.0252, 0.0818, 0.0924, 0.11, -0.1461, -0.0752, -0.0204, -0.0112, -0.0282, 0.0937, 0.0383, -0.0775, 0.028, 0.1654, -0.0698, 0.006, -0.0769, 0.1996, 0.1139, 0.2288, 0.2651, 0.3024, 0.1836, 0.3429, 0.151, 0.1357, 0.2308, 0.371, 0.377, 0.2982, 0.435, 0.4079, 0.2583, 0.2857, 0.342, 0.4593, 0.3225, 0.5185, 0.6335, 0.4427, 0.4255, 0.5455, 0.6018, 0.6145, 0.5806, 0.6583, 0.6139, 0.6113, 0.5415, 0.6354, 0.7008, 0.5759, 0.6219, 0.6687, 0.7402, 0.899]</code></pre><pre><code class="python">import pandas as pd# 构建 dataframeyear_se = pd.Series(year_lst, name = &#39;year&#39;)temp_se = pd.Series(temp_lst, name = &#39;temperature&#39;)result_df = pd.concat([year_se, temp_se], axis = 1)print (result_df.head())# 保存csvresult_df.to_csv(&#39;./files/json_to_csv.csv&#39;, index = None)</code></pre><pre><code>   year  temperature0  1880      -0.12471  1881      -0.07072  1882      -0.07103  1883      -0.14814  1884      -0.2099</code></pre><h3 id="写-json-操作"><a href="#写-json-操作" class="headerlink" title="写 json 操作"></a>写 json 操作</h3><pre><code class="python">book_dict = [&#123;&#39;书名&#39;:&#39;无声告白&#39;, &#39;作者&#39;:&#39;伍绮诗&#39;&#125;, &#123;&#39;书名&#39;:&#39;我不是潘金莲&#39;, &#39;作者&#39;:&#39;刘震云&#39;&#125;, &#123;&#39;书名&#39;:&#39;沉默的大多数 (王小波集)&#39;, &#39;作者&#39;:&#39;王小波&#39;&#125;]filename = &#39;./files/json_output.json&#39;with open(filename, &#39;w&#39;) as f_obj:    f_obj.write(json.dumps(book_dict, ensure_ascii=False))# 不需要加, encoding=&#39;utf-8&#39;参数</code></pre><h2 id="四、SQLite-基本操作"><a href="#四、SQLite-基本操作" class="headerlink" title="四、SQLite 基本操作"></a>四、SQLite 基本操作</h2><h3 id="连接数据库"><a href="#连接数据库" class="headerlink" title="连接数据库"></a>连接数据库</h3><pre><code class="python">import sqlite3db_path = &#39;./files/test.sqlite&#39;conn = sqlite3.connect(db_path)cur = conn.cursor()conn.text_factory = str  # 处理中文</code></pre><h3 id="获取基本信息"><a href="#获取基本信息" class="headerlink" title="获取基本信息"></a>获取基本信息</h3><pre><code class="python">cur.execute(&#39;SELECT SQLITE_VERSION()&#39;)print (&#39;SQLite版本：%s&#39; %str(cur.fetchone()[0]))</code></pre><pre><code>SQLite版本：3.30.0</code></pre><h3 id="逐条插入数据"><a href="#逐条插入数据" class="headerlink" title="逐条插入数据"></a>逐条插入数据</h3><pre><code class="python">cur.execute(&quot;DROP TABLE IF EXISTS book&quot;)cur.execute(&quot;CREATE TABLE book(id INT, name TEXT, price DOUBLE)&quot;)cur.execute(&quot;INSERT INTO book VALUES(1,&#39;肖秀荣考研书系列:肖秀荣(2017)考研政治命题人终极预测4套卷&#39;,14.40)&quot;)cur.execute(&quot;INSERT INTO book VALUES(2,&#39;法医秦明作品集:幸存者+清道夫+尸语者+无声的证词+第十一根手指(套装共5册) (两种封面随机发货)&#39;,100.00)&quot;)cur.execute(&quot;INSERT INTO book VALUES(3,&#39;活着本来单纯:丰子恺散文漫画精品集(收藏本)&#39;,30.90)&quot;)cur.execute(&quot;INSERT INTO book VALUES(4,&#39;自在独行:贾平凹的独行世界&#39;,26.80)&quot;)cur.execute(&quot;INSERT INTO book VALUES(5,&#39;当你的才华还撑不起你的梦想时&#39;,23.00)&quot;)cur.execute(&quot;INSERT INTO book VALUES(6,&#39;巨人的陨落(套装共3册)&#39;,84.90)&quot;)cur.execute(&quot;INSERT INTO book VALUES(7,&#39;孤独深处(收录雨果奖获奖作品《北京折叠》)&#39;,21.90)&quot;)cur.execute(&quot;INSERT INTO book VALUES(8,&#39;世界知名企业员工指定培训教材:所谓情商高,就是会说话&#39;,22.00)&quot;)</code></pre><pre><code>&lt;sqlite3.Cursor at 0x2d2d64e7c00&gt;</code></pre><h3 id="批量插入数据"><a href="#批量插入数据" class="headerlink" title="批量插入数据"></a>批量插入数据</h3><pre><code class="python">books = (    (9, &#39;人间草木&#39;, 30.00),    (10,&#39;你的善良必须有点锋芒&#39;, 20.50),    (11, &#39;这么慢,那么美&#39;, 24.80),    (12, &#39;考拉小巫的英语学习日记:写给为梦想而奋斗的人(全新修订版)&#39;, 23.90))cur.executemany(&quot;INSERT INTO book VALUES(?, ?, ?)&quot;, books)</code></pre><pre><code>&lt;sqlite3.Cursor at 0x2d2d64e7c00&gt;</code></pre><pre><code class="python">conn.commit()</code></pre><h3 id="查找数据"><a href="#查找数据" class="headerlink" title="查找数据"></a>查找数据</h3><pre><code class="python">cur.execute(&#39;SELECT * FROM book&#39;)rows = cur.fetchall()# 通过索引号访问for row in rows:    print (&#39;序号: %i, 书名: %s, 价格: %.2f&#39; %(row[0], row[1], row[2]))</code></pre><pre><code>序号: 1, 书名: 肖秀荣考研书系列:肖秀荣(2017)考研政治命题人终极预测4套卷, 价格: 14.40序号: 2, 书名: 法医秦明作品集:幸存者+清道夫+尸语者+无声的证词+第十一根手指(套装共5册) (两种封面随机发货), 价格: 100.00序号: 3, 书名: 活着本来单纯:丰子恺散文漫画精品集(收藏本), 价格: 30.90序号: 4, 书名: 自在独行:贾平凹的独行世界, 价格: 26.80序号: 5, 书名: 当你的才华还撑不起你的梦想时, 价格: 23.00序号: 6, 书名: 巨人的陨落(套装共3册), 价格: 84.90序号: 7, 书名: 孤独深处(收录雨果奖获奖作品《北京折叠》), 价格: 21.90序号: 8, 书名: 世界知名企业员工指定培训教材:所谓情商高,就是会说话, 价格: 22.00序号: 9, 书名: 人间草木, 价格: 30.00序号: 10, 书名: 你的善良必须有点锋芒, 价格: 20.50序号: 11, 书名: 这么慢,那么美, 价格: 24.80序号: 12, 书名: 考拉小巫的英语学习日记:写给为梦想而奋斗的人(全新修订版), 价格: 23.90</code></pre><pre><code class="python">conn.row_factory = sqlite3.Rowcur = conn.cursor()cur.execute(&#39;SELECT * FROM book&#39;)rows = cur.fetchall()# 通过列名访问for row in rows:    print (&#39;序号: %i, 书名: %s, 价格: %.2f&#39; %(row[&#39;id&#39;], row[&#39;name&#39;], row[&#39;price&#39;]))</code></pre><pre><code>序号: 1, 书名: 肖秀荣考研书系列:肖秀荣(2017)考研政治命题人终极预测4套卷, 价格: 14.40序号: 2, 书名: 法医秦明作品集:幸存者+清道夫+尸语者+无声的证词+第十一根手指(套装共5册) (两种封面随机发货), 价格: 100.00序号: 3, 书名: 活着本来单纯:丰子恺散文漫画精品集(收藏本), 价格: 30.90序号: 4, 书名: 自在独行:贾平凹的独行世界, 价格: 26.80序号: 5, 书名: 当你的才华还撑不起你的梦想时, 价格: 23.00序号: 6, 书名: 巨人的陨落(套装共3册), 价格: 84.90序号: 7, 书名: 孤独深处(收录雨果奖获奖作品《北京折叠》), 价格: 21.90序号: 8, 书名: 世界知名企业员工指定培训教材:所谓情商高,就是会说话, 价格: 22.00序号: 9, 书名: 人间草木, 价格: 30.00序号: 10, 书名: 你的善良必须有点锋芒, 价格: 20.50序号: 11, 书名: 这么慢,那么美, 价格: 24.80序号: 12, 书名: 考拉小巫的英语学习日记:写给为梦想而奋斗的人(全新修订版), 价格: 23.90</code></pre><pre><code class="python">conn.close()</code></pre><h2 id="五、SQLite-json-操作"><a href="#五、SQLite-json-操作" class="headerlink" title="五、SQLite_json 操作"></a>五、SQLite_json 操作</h2><pre><code class="python">import sqlite3db_path = &#39;./files/test_join.sqlite&#39;conn = sqlite3.connect(db_path)cur = conn.cursor()</code></pre><pre><code class="python"># 建 depaetment 表，并插入数据cur.execute(&quot;DROP TABLE IF EXISTS department&quot;)cur.execute(&quot;CREATE TABLE department(\                id INT PRIMARY KEY NOT NULL, \                dept CHAR(50) NOT NULL, \                emp_id INT NOT NULL)&quot;)depts = (        (1, &#39;IT Builing&#39;, 1),        (2, &#39;Engineerin&#39;, 2),        (3, &#39;Finance&#39;, 7))cur.executemany(&quot;INSERT INTO department VALUES(?, ?, ?)&quot;, depts)</code></pre><pre><code>&lt;sqlite3.Cursor at 0x2d2d64f70a0&gt;</code></pre><pre><code class="python">conn.commit()</code></pre><h3 id="CROSS-JOIN-交叉连接"><a href="#CROSS-JOIN-交叉连接" class="headerlink" title="CROSS JOIN 交叉连接"></a>CROSS JOIN 交叉连接</h3><pre><code class="python">cur.execute(&quot;SELECT emp_id, name, dept FROM company CROSS JOIN department;&quot;)rows = cur.fetchall()for row in rows:    print (row)</code></pre><pre><code class="python"># 建 company 表，并插入数据cur.execute(&quot;DROP TABLE IF EXISTS company&quot;)cur.execute(&quot;CREATE TABLE company(\                    id INT PRIMARY KEY NOT NULL, \                    name CHAR(50) NOT NULL, \                    age INT NOT NULL, \                    address CHAR(50) NOT NULL,\                    salary DOUBLE NOT NULL)&quot;)companies = (        (1, &#39;Paul&#39;, 32, &#39;California&#39;, 20000.0),        (2, &#39;Allen&#39;, 25, &#39;Texas&#39;, 15000.0),        (3, &#39;Teddy&#39;, 23, &#39;Norway&#39;, 20000.0),        (4, &#39;Mark&#39;, 25, &#39;Rich-Mond&#39;, 65000.0),        (5, &#39;David&#39;, 27, &#39;Texas&#39;, 85000.0),        (6, &#39;Kim&#39;, 22, &#39;South-Hall&#39;, 45000.0),        (7, &#39;James&#39;, 24, &#39;Houston&#39;, 10000.0))cur.executemany(&quot;INSERT INTO company VALUES (?, ?, ?, ?, ?)&quot;, companies)</code></pre><pre><code>&lt;sqlite3.Cursor at 0x2d2d64f70a0&gt;</code></pre><h3 id="INNER-JOIN-内连接"><a href="#INNER-JOIN-内连接" class="headerlink" title="INNER JOIN 内连接"></a>INNER JOIN 内连接</h3><pre><code class="python">cur.execute(&quot;SELECT emp_id, name, dept FROM company INNER JOIN department \            ON company.id = department.emp_id;&quot;)rows = cur.fetchall()for row in rows:    print (row)</code></pre><pre><code>(1, &#39;Paul&#39;, &#39;IT Builing&#39;)(2, &#39;Allen&#39;, &#39;Engineerin&#39;)(7, &#39;James&#39;, &#39;Finance&#39;)</code></pre><h3 id="OUTER-JOIN-外连接"><a href="#OUTER-JOIN-外连接" class="headerlink" title="OUTER JOIN 外连接"></a>OUTER JOIN 外连接</h3><pre><code class="python"># 左连接cur.execute(&quot;SELECT emp_id, name, dept FROM company LEFT OUTER JOIN department \            ON company.id = department.emp_id;&quot;)rows = cur.fetchall()for row in rows:    print (row)</code></pre><pre><code>(1, &#39;Paul&#39;, &#39;IT Builing&#39;)(2, &#39;Allen&#39;, &#39;Engineerin&#39;)(None, &#39;Teddy&#39;, None)(None, &#39;Mark&#39;, None)(None, &#39;David&#39;, None)(None, &#39;Kim&#39;, None)(7, &#39;James&#39;, &#39;Finance&#39;)</code></pre><pre><code class="python"># 右连接 （目前不支持）cur.execute(&quot;SELECT emp_id, name, dept FROM company RIGHT OUTER JOIN department \            ON company.id = department.emp_id;&quot;)rows = cur.fetchall()for row in rows:    print (row)</code></pre><pre><code>---------------------------------------------------------------------------OperationalError                          Traceback (most recent call last)&lt;ipython-input-41-ce0fc573748b&gt; in &lt;module&gt;      1 # 右连接 （目前不支持）      2 cur.execute(&quot;SELECT emp_id, name, dept FROM company RIGHT OUTER JOIN department \----&gt; 3             ON company.id = department.emp_id;&quot;)      4 rows = cur.fetchall()      5 for row in rows:OperationalError: RIGHT and FULL OUTER JOINs are not currently supported</code></pre><pre><code class="python"># 右连接，交换两张表cur.execute(&quot;SELECT emp_id, name, dept FROM department LEFT OUTER JOIN company \            ON company.id = department.emp_id;&quot;)rows = cur.fetchall()for row in rows:    print (row)</code></pre><pre><code>(1, &#39;Paul&#39;, &#39;IT Builing&#39;)(2, &#39;Allen&#39;, &#39;Engineerin&#39;)(7, &#39;James&#39;, &#39;Finance&#39;)</code></pre><pre><code class="python">sqlite&gt; SELECT EMP_ID, NAME, DEPT FROM COMPANY LEFT OUTER JOIN DEPARTMENT      ON COMPANY.ID = DEPARTMENT.EMP_ID;</code></pre><pre><code>  File &quot;&lt;ipython-input-43-a0833b733075&gt;&quot;, line 1    sqlite&gt; SELECT EMP_ID, NAME, DEPT FROM COMPANY LEFT OUTER JOIN DEPARTMENT                        ^SyntaxError: invalid syntax</code></pre><h2 id="六、Excel-文件操作"><a href="#六、Excel-文件操作" class="headerlink" title="六、Excel 文件操作"></a>六、Excel 文件操作</h2><p>pandas.read_excel(io, sheet_name=0, header=0, names=None, index_col=None, usecols=None, squeeze=False, dtype=None, engine=None, converters=None, true_values=None, false_values=None, skiprows=None, nrows=None, na_values=None, keep_default_na=True, verbose=False, parse_dates=False, date_parser=None, thousands=None, comment=None, skipfooter=0, convert_float=True, mangle_dupe_cols=True, **kwds)</p><p>df_fujian = pd.read_excel(“./datafiles/fujian.xlsx”,sheet_name=’日数据’)</p>]]></content>
      
      
      <categories>
          
          <category> DataAnalysis </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>存储过程</title>
      <link href="blog/adiki8/"/>
      <url>blog/adiki8/</url>
      
        <content type="html"><![CDATA[<p>存储过程（Stored Procedure）是 SQL 语句和控制语句的预编译集合，以一个名称存储并作为一个单元处理。<br>其效率比函数更高。增强 SQL 语句的功能和灵活性。减少网络流量。<br>客户端重启，存储过程不会失效。定界符只对客户端有效，客户端重启，定界符失效。</p><blockquote><p>数据库系统有三层结构：客户端、DBMS、服务端。我们的各种请求都是通过客户端发送给 DBMS，DBMS 将 SQL 语句编译成二进制,然后执行，接着缓存在 DBMS 中（再次执行时效率提高），接着发送给数据库服务端，然后服务端再返回数据给 DBMS，DBMS 再返回给客户端显示。<br>而存储过程，是将某些常用的请求，在 DBMS 中编译好二进制存储在 DBMS 中，以后再发送同样请求，就免去了编译的开销。</p></blockquote><p>模块化编程，可以提高速度。但是可移植性不好。</p><h2 id="创建存储过程"><a href="#创建存储过程" class="headerlink" title="创建存储过程"></a>创建存储过程</h2><p>创建之前必须先选择(USE)数据库。</p><pre><code class="sql">CREATE[DEFINER = &#123;user|CURRENT_USER&#125;]PROCEDURE  sp_name([proc_parameter[,...]])[characteristic ...] routine_bodyproc_parameter:[IN|OUT|INOUT] param_name type</code></pre><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><ul><li>IN，表示该参数的值必须在调用存储过程时指定</li><li>OUT，表示该参数的值可以被存储过程改变，并且可以被返回</li><li>INOUT，表示该参数的调用时指定，并且可以被改变和返回</li></ul><p>可以这样理解，IN 就是要传入的，值必须在调用时指定，不能返回（值传递），OUT 是返回的（指针传递）。INOUT 传入之后被返回的。</p><h3 id="过程体"><a href="#过程体" class="headerlink" title="过程体"></a>过程体</h3><ul><li>过程体由合法的 SQL 语句构成</li><li>过程体是绝大部分 SQL 语句</li><li>复合结构（超过两个 SQL 语句）使用 BEGIN…END</li><li>复合结构可以包含声明，循环，控制结构</li></ul><h2 id="调用存储过程"><a href="#调用存储过程" class="headerlink" title="调用存储过程"></a>调用存储过程</h2><pre><code class="sql">CALL sp_name[()]</code></pre><p>如果存储过程没有参数，则调用的时候可以不加括号。</p><h2 id="删除存储过程"><a href="#删除存储过程" class="headerlink" title="删除存储过程"></a>删除存储过程</h2><p>用 DROP PROCDURE sp_name;</p><hr><p>我们应该已经发现了，所有 CREATE 创建的东西，都需要用 DROP 来删除。包括：<br>数据库、表、视图、触发器、函数、存储过程</p><h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><pre><code class="sql">delimiter //CREATE PROCEDURE  removeuserbyid(IN u_id INT UNSIGNED)begin  DELETE  FROM   users  WHERE  id = u_id;END//  -- 调用  CALL removeuserbyid(1)//</code></pre><p>注意参数的名字不能和字段名相同。</p><pre><code class="sql">CREATE PROCEDURE  remove2(IN p_id      INT signed,          OUT usernums INT UNSIGNED)begin  DELETE  FROM   users  WHERE  id=p_id;  SELECT count(id)  FROM   users  INTO   usernums;end//-- 调用CALL remove2(2,@nums)//-- 查看变量nums的值SELECT @nums//</code></pre><p>返回值存储在变量@nums 中。</p><h2 id="修改存储过程"><a href="#修改存储过程" class="headerlink" title="修改存储过程"></a>修改存储过程</h2><pre><code class="sql">ALTER PROCEDURE sp_name[characteristic ...]COMMENT &#39;string&#39;|&#123;COUNTAINS SQL|NO SQL|READS SQL DATA|MODIFIES SQL DATA&#125;|SQL SECURITY&#123;DEFINER|INVOKER&#125;|</code></pre><h2 id="与函数对比"><a href="#与函数对比" class="headerlink" title="与函数对比"></a>与函数对比</h2><p>存储过程实现的功能更复杂一些；而函数的针对性更强。<br>时间经常用存储过程对表作操作。<br>存储过程可以用多个返回值。<br>存储过程独立出现。<br>函数出现在其他 SQL 语句内部。</p>]]></content>
      
      
      <categories>
          
          <category> DataBase </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Python-apply函数和入口函数</title>
      <link href="blog/hy14ic/"/>
      <url>blog/hy14ic/</url>
      
        <content type="html"><![CDATA[<h2 id="pandas-之-apply-函数"><a href="#pandas-之-apply-函数" class="headerlink" title="pandas 之 apply 函数"></a>pandas 之 apply 函数</h2><pre><code>DataFrame.apply(func, axis=0, broadcast=False, raw=False, reduce=None, args=(), **kwds)</code></pre><p>第一个参数，这个参数是函数，相当于 C/C++的函数指针。</p><p>这个函数需要自己实现，函数的传入参数根据 axis 来定，比如 axis = 1，就会把一行数据作为 Series 的数据<br>结构传入给自己实现的函数中，我们在函数中实现对 Series 不同属性之间的计算，返回一个结果，则 apply 函数<br>会自动遍历每一行 DataFrame 的数据，最后将所有结果组合成一个 Series 数据结构并返回。</p><h2 id="if-name-‘main’"><a href="#if-name-‘main’" class="headerlink" title="if name == ‘main’"></a>if <strong>name</strong> == ‘main’</h2><p><a href="https://zhuanlan.zhihu.com/p/34112508">参考：知乎用户</a></p>]]></content>
      
      
      <categories>
          
          <category> Language </category>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>机器学习scikit-learn库的使用</title>
      <link href="blog/wgv3ak/"/>
      <url>blog/wgv3ak/</url>
      
        <content type="html"><![CDATA[<h2 id="一、机器学习的一些概念"><a href="#一、机器学习的一些概念" class="headerlink" title="一、机器学习的一些概念"></a>一、机器学习的一些概念</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ul><li>特征：一组数据的多个属性</li><li>标签：人为指定特征</li><li>监督学习：就像分类（离散化的标签），回归（连续性的标签）、【“有标准答案”】</li><li>无监督学习：就像聚类【“无标准答案”】</li><li><strong>数据</strong>：是机器学习的命脉</li></ul><h3 id="基本框架图"><a href="#基本框架图" class="headerlink" title="基本框架图"></a>基本框架图</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598686130909-116e16a4-e86a-46e0-93fb-ac0263257056.png#height=271&id=F2NI4&originHeight=692&originWidth=1157&originalType=binary%E2%88%B6=1&size=0&status=done&style=shadow&width=453"><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598686131288-431d8fe6-bf3f-4f3e-9986-9b282e9e2982.png#height=356&id=LzfkG&originHeight=651&originWidth=869&originalType=binary%E2%88%B6=1&size=0&status=done&style=shadow&width=475"></p><h2 id="二、机器学习的一些阶段-步骤"><a href="#二、机器学习的一些阶段-步骤" class="headerlink" title="二、机器学习的一些阶段/步骤"></a>二、机器学习的一些阶段/步骤</h2><h3 id="sklearn-相关提及"><a href="#sklearn-相关提及" class="headerlink" title="sklearn 相关提及"></a>sklearn 相关提及</h3><p><a href="https://scikit-learn.org/stable/testimonials/testimonials.html">官网 scikit-learn</a></p><ol><li>包含聚类、分类、回归等算法<br>eg：随机森林、k-means、SVM 等</li><li>包含模型筛选、降维、预处理等算法</li><li>要特别注意安装该包使用要注意的细节，具体参考上一篇博客</li></ol><h3 id="sklearn-处理机器学习的一般化-sop"><a href="#sklearn-处理机器学习的一般化-sop" class="headerlink" title="sklearn 处理机器学习的一般化 sop"></a>sklearn 处理机器学习的一般化 sop</h3><ol><li><strong>准备数据集</strong><ul><li>数据分析:（利用 np.reshape()成二维(n_samples,n_features)）</li><li>划分数据集：train_test_split()</li><li>特征工程：特征的提取、特征的归一化 nomalization</li></ul></li><li><strong>选择模型</strong><ul><li>根据不同场景选择合适的模型:<a href="https://scikit-learn.org/stable/tutorial/machine_learning_map/index.html">scikit-learn 的模型选择路线图</a></li><li>分类、聚类、回归……</li></ul></li><li>在训练集上<strong>训练模型</strong>，并调整参数<ul><li>经验选定参数</li><li>交叉验证确定最优的参数 cross validation</li></ul></li><li>在测试集上<strong>测试模型</strong><ul><li>predict 预测、score 真实值预测值评分、etc</li></ul></li><li><strong>保存模型</strong><ul><li><code>import pickle</code></li></ul></li></ol><h3 id="主成分分析：将特征降维"><a href="#主成分分析：将特征降维" class="headerlink" title="主成分分析：将特征降维"></a>主成分分析：将特征降维</h3><ul><li>统计学相关知识：方差（衡量在一个维度的偏差）、协方差（衡量一个维度是否对另一个维度有影响 cov（x，y））</li><li>线代相关知识：特征值、特征向量、协方差向量</li><li>PCA</li></ul><p><a href="http://q5e49p23n.bkt.clouddn.com/scikit_pca.html">相关代码 html 页面</a></p><h2 id="三、通过-scikit-learn-认识机器学习"><a href="#三、通过-scikit-learn-认识机器学习" class="headerlink" title="三、通过 scikit-learn 认识机器学习"></a>三、通过 scikit-learn 认识机器学习</h2><h3 id="加载示例数据集"><a href="#加载示例数据集" class="headerlink" title="加载示例数据集"></a>加载示例数据集</h3><pre><code class="python">from sklearn import datasetsiris = datasets.load_iris()#用sklearn自身配带的数据digits = datasets.load_digits()# C:\Users\wztli\Anaconda3\pkgs\scikit-learn-0.21.3-py37h6288b17_0\Lib\site-packages\sklearn\datasets\data# 数据集在电脑中的位置</code></pre><pre><code class="python"># 查看数据集# irisprint(iris.data[:5])print(iris.data.shape)print(iris.target_names)print(iris.target)</code></pre><pre><code class="python">[[5.1 3.5 1.4 0.2] [4.9 3.  1.4 0.2] [4.7 3.2 1.3 0.2] [4.6 3.1 1.5 0.2] [5.  3.6 1.4 0.2]](150, 4)[&#39;setosa&#39; &#39;versicolor&#39; &#39;virginica&#39;][0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2]</code></pre><pre><code class="python"># digitsprint(digits.data)print(digits.data.shape)print(digits.target_names)print(digits.target)</code></pre><pre><code class="python">[[ 0.  0.  5. ...  0.  0.  0.] [ 0.  0.  0. ... 10.  0.  0.] [ 0.  0.  0. ... 16.  9.  0.] ... [ 0.  0.  1. ...  6.  0.  0.] [ 0.  0.  2. ... 12.  0.  0.] [ 0.  0. 10. ... 12.  1.  0.]](1797, 64)[0 1 2 3 4 5 6 7 8 9][0 1 2 ... 8 9 8]</code></pre><h3 id="在训练集上训练模型"><a href="#在训练集上训练模型" class="headerlink" title="在训练集上训练模型"></a>在训练集上训练模型</h3><pre><code class="python"># 手动划分训练集、测试集n_test = 100 # 测试样本个数train_X = digits.data[:-n_test, :]train_y = digits.target[:-n_test]test_X = digits.data[-n_test:, :]y_true = digits.target[-n_test:]</code></pre><pre><code class="python"># 选择SVM模型from sklearn import svmsvm_model = svm.SVC(gamma=0.001, C=100.)# svm_model = svm.SVC(gamma=100., C=1.)# 训练模型svm_model.fit(train_X, train_y)#训练要放入两个参数：样本的特征数据，样本的标签</code></pre><pre><code class="python">SVC(C=100.0, cache_size=200, class_weight=None, coef0=0.0,    decision_function_shape=&#39;ovr&#39;, degree=3, gamma=0.001, kernel=&#39;rbf&#39;,    max_iter=-1, probability=False, random_state=None, shrinking=True,    tol=0.001, verbose=False)</code></pre><pre><code class="python"># 选择LR（逻辑回归）模型from sklearn.linear_model import LogisticRegressionlr_model = LogisticRegression()# 训练模型lr_model.fit(train_X, train_y)</code></pre><pre><code class="python">C:\Users\wztli\Anaconda3\lib\site-packages\sklearn\linear_model\logistic.py:432: FutureWarning: Default solver will be changed to &#39;lbfgs&#39; in 0.22. Specify a solver to silence this warning.  FutureWarning)C:\Users\wztli\Anaconda3\lib\site-packages\sklearn\linear_model\logistic.py:469: FutureWarning: Default multi_class will be changed to &#39;auto&#39; in 0.22. Specify the multi_class option to silence this warning.  &quot;this warning.&quot;, FutureWarning)LogisticRegression(C=1.0, class_weight=None, dual=False, fit_intercept=True,                   intercept_scaling=1, l1_ratio=None, max_iter=100,                   multi_class=&#39;warn&#39;, n_jobs=None, penalty=&#39;l2&#39;,                   random_state=None, solver=&#39;warn&#39;, tol=0.0001, verbose=0,                   warm_start=False)</code></pre><h3 id="在测试集上测试模型"><a href="#在测试集上测试模型" class="headerlink" title="在测试集上测试模型"></a>在测试集上测试模型</h3><pre><code class="python">y_pred_svm = svm_model.predict(test_X)y_pred_lr = lr_model.predict(test_X)</code></pre><pre><code class="python"># 查看结果# 评价指标from sklearn.metrics import accuracy_score#print &#39;预测标签：&#39;, y_pred#print &#39;真实标签：&#39;, y_trueprint(&#39;SVM结果：&#39;, accuracy_score(y_true, y_pred_svm))print(&#39;LR结果：&#39;, accuracy_score(y_true, y_pred_lr))</code></pre><pre><code class="python">SVM结果： 0.98LR结果： 0.94</code></pre><h3 id="保存模型"><a href="#保存模型" class="headerlink" title="保存模型"></a>保存模型</h3><pre><code class="python">import picklewith open(&#39;svm_model.pkl&#39;, &#39;wb&#39;) as f:    pickle.dump(svm_model, f)</code></pre><pre><code class="python">import numpy as np# 重新加载模型进行预测with open(&#39;svm_model.pkl&#39;, &#39;rb&#39;) as f:    model = pickle.load(f)random_samples_index = np.random.randint(0, 1796, 5)random_samples = digits.data[random_samples_index, :]random_targets = digits.target[random_samples_index]random_predict = model.predict(random_samples)print(random_predict)print(random_targets)</code></pre><pre><code class="python">[2 2 1 3 8][2 2 1 3 8]</code></pre><h2 id="四、scikit-learn-入门"><a href="#四、scikit-learn-入门" class="headerlink" title="四、scikit-learn 入门"></a>四、scikit-learn 入门</h2><h3 id="准备数据集"><a href="#准备数据集" class="headerlink" title="准备数据集"></a>准备数据集</h3><pre><code class="python">import numpy as npfrom sklearn.model_selection import train_test_split</code></pre><pre><code class="python">X = np.random.randint(0, 100, (10, 4))y = np.random.randint(0, 4, 10)y.sort()print(&#39;样本：&#39;)print(X)print(&#39;标签：&#39;, y)</code></pre><pre><code class="python">样本：[[43 43 18 78] [74 24 42 37] [36 69 84 47] [70 62 77 30] [87 38  3 96] [68 67 24  7] [66 36 72 72] [12 94 87 72] [66  5 92  6] [41 59 60 91]]标签： [0 0 0 2 2 2 2 3 3 3]</code></pre><pre><code class="python"># 分割训练集、测试集# random_state确保每次随机分割得到相同的结果X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=1/3., random_state=7)print(&#39;训练集：&#39;)print(X_train)print(y_train)print(&#39;测试集：&#39;)print(X_test)print(y_test)</code></pre><pre><code class="python">训练集：[[63 56  7 42] [40 47 17 23] [41 31 26  8] [79 30 22 88] [54 85 48 54] [89 73 77 41]][0 1 1 0 1 1]测试集：[[ 3  0 42 86] [42 96 83 38] [33 45  8 37] [ 1 44 75  7]][1 1 0 0]</code></pre><pre><code class="python"># 特征归一化from sklearn import preprocessingx1 = np.random.randint(0, 1000, 5).reshape(5,1)x2 = np.random.randint(0, 10, 5).reshape(5, 1)x3 = np.random.randint(0, 100000, 5).reshape(5, 1)X = np.concatenate([x1, x2, x3], axis=1)print(X)</code></pre><pre><code class="python">[[  353     4 27241] [  999     4 34684] [  911     4 78606] [  310     6 44593] [  817     9  6356]]</code></pre><pre><code class="python">print(preprocessing.scale(X))</code></pre><pre><code class="python">[[-1.12443958 -0.71443451 -0.46550183] [ 1.11060033 -0.71443451 -0.15209341] [ 0.80613669 -0.71443451  1.69736578] [-1.27321159  0.30618622  0.26515287] [ 0.48091416  1.83711731 -1.34492342]]</code></pre><pre><code class="python"># 生成分类数据进行验证scale的必要性from sklearn.datasets import make_classificationimport matplotlib.pyplot as plt%matplotlib inlineX, y = make_classification(n_samples=300, n_features=2, n_redundant=0, n_informative=2,                           random_state=25, n_clusters_per_class=1, scale=100)plt.scatter(X[:,0], X[:,1], c=y)plt.show()</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598686130636-3a18d8f2-51cb-4b04-8a0f-a40cf1d0b9b6.png#height=248&id=BKtnM&originHeight=248&originWidth=384&originalType=binary%E2%88%B6=1&size=0&status=done&style=none&width=384"></p><pre><code class="python">from sklearn import svm# 注释掉以下这句表示不进行特征归一化X = preprocessing.scale(X)X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=1/3., random_state=7)svm_classifier = svm.SVC()svm_classifier.fit(X_train, y_train)svm_classifier.score(X_test, y_test)</code></pre><pre><code class="python">C:\Users\wztli\Anaconda3\lib\site-packages\sklearn\svm\base.py:193: FutureWarning: The default value of gamma will change from &#39;auto&#39; to &#39;scale&#39; in version 0.22 to account better for unscaled features. Set gamma explicitly to &#39;auto&#39; or &#39;scale&#39; to avoid this warning.  &quot;avoid this warning.&quot;, FutureWarning)0.25</code></pre><h3 id="训练模型"><a href="#训练模型" class="headerlink" title="训练模型"></a>训练模型</h3><pre><code class="python"># 回归模型from sklearn import datasetsboston_data = datasets.load_boston()X = boston_data.datay = boston_data.targetprint(&#39;样本：&#39;)print(X[:5, :])print(&#39;标签：&#39;)print(y[:5])</code></pre><pre><code class="python">样本：[[6.3200e-03 1.8000e+01 2.3100e+00 0.0000e+00 5.3800e-01 6.5750e+00  6.5200e+01 4.0900e+00 1.0000e+00 2.9600e+02 1.5300e+01 3.9690e+02  4.9800e+00] [2.7310e-02 0.0000e+00 7.0700e+00 0.0000e+00 4.6900e-01 6.4210e+00  7.8900e+01 4.9671e+00 2.0000e+00 2.4200e+02 1.7800e+01 3.9690e+02  9.1400e+00] [2.7290e-02 0.0000e+00 7.0700e+00 0.0000e+00 4.6900e-01 7.1850e+00  6.1100e+01 4.9671e+00 2.0000e+00 2.4200e+02 1.7800e+01 3.9283e+02  4.0300e+00] [3.2370e-02 0.0000e+00 2.1800e+00 0.0000e+00 4.5800e-01 6.9980e+00  4.5800e+01 6.0622e+00 3.0000e+00 2.2200e+02 1.8700e+01 3.9463e+02  2.9400e+00] [6.9050e-02 0.0000e+00 2.1800e+00 0.0000e+00 4.5800e-01 7.1470e+00  5.4200e+01 6.0622e+00 3.0000e+00 2.2200e+02 1.8700e+01 3.9690e+02  5.3300e+00]]标签：[24.  21.6 34.7 33.4 36.2]</code></pre><pre><code class="python"># 选择线性回顾模型from sklearn.linear_model import LinearRegressionlr_model = LinearRegression()</code></pre><pre><code class="python">from sklearn.model_selection import train_test_split# 分割训练集、测试集X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=1/3., random_state=7)</code></pre><pre><code class="python"># 训练模型lr_model.fit(X_train, y_train)</code></pre><pre><code class="python">LinearRegression(copy_X=True, fit_intercept=True, n_jobs=None, normalize=False)</code></pre><pre><code class="python"># 返回参数lr_model.get_params()</code></pre><pre><code class="python">&#123;&#39;copy_X&#39;: True, &#39;fit_intercept&#39;: True, &#39;n_jobs&#39;: None, &#39;normalize&#39;: False&#125;</code></pre><pre><code class="python">lr_model.score(X_train, y_train)</code></pre><pre><code class="python">0.7598132492351114</code></pre><pre><code class="python">lr_model.score(X_test, y_test)</code></pre><pre><code class="python">0.6693852753319398</code></pre><h3 id="交叉验证"><a href="#交叉验证" class="headerlink" title="交叉验证"></a>交叉验证</h3><pre><code class="python">from sklearn import datasetsfrom sklearn.model_selection import train_test_split, cross_val_scorefrom sklearn.neighbors import KNeighborsClassifierimport matplotlib.pyplot as plt%matplotlib inlineiris = datasets.load_iris()X = iris.datay = iris.targetX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=1/3., random_state=10)k_range = range(1, 31)cv_scores = []for n in k_range:    knn = KNeighborsClassifier(n)    scores = cross_val_score(knn, X_train, y_train, cv=10, scoring=&#39;accuracy&#39;) # 分类问题使用    #scores = cross_val_score(knn, X_train, y_train, cv=10, scoring=&#39;neg_mean_squared_error&#39;) # 回归问题使用    cv_scores.append(scores.mean())plt.plot(k_range, cv_scores)plt.xlabel(&#39;K&#39;)plt.ylabel(&#39;Accuracy&#39;)plt.show()</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598686130618-179a3dfa-9ffd-4f45-9cc2-d6f63e1ad2b9.png#height=262&id=uSgI0&originHeight=262&originWidth=392&originalType=binary%E2%88%B6=1&size=0&status=done&style=none&width=392"></p><pre><code class="python"># 选择最优的Kbest_knn = KNeighborsClassifier(n_neighbors=5)best_knn.fit(X_train, y_train)print(best_knn.score(X_test, y_test))print(best_knn.predict(X_test))</code></pre><pre><code class="python">0.96[1 2 0 1 0 1 2 1 0 1 1 2 1 0 0 2 1 0 0 0 2 2 2 0 1 0 1 1 1 2 1 1 2 2 2 0 2 2 2 2 0 0 1 0 1 0 1 2 2 2]</code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://github.com/wztlink1013/scikit-learn">scikit-learn 中文文档 github</a>文中链接为英文文档</li><li><a href="https://blog.csdn.net/Little_Fire/article/details/81062447">解释 iris 数据集</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> MachingLearning </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>VScode使用</title>
      <link href="blog/pm7mpk/"/>
      <url>blog/pm7mpk/</url>
      
        <content type="html"><![CDATA[<h2 id="VScode-常用插件"><a href="#VScode-常用插件" class="headerlink" title="VScode 常用插件"></a>VScode 常用插件</h2><ul><li><input checked="" disabled="" type="checkbox"> Markdown Preview Github Styling【Markdown】</li><li><input checked="" disabled="" type="checkbox"> Markdown All in One【Markdown】</li><li><input disabled="" type="checkbox"> <del>GBKtoUTF8</del></li><li><input checked="" disabled="" type="checkbox"> CodeRunner【编写 C/C++】</li><li><input checked="" disabled="" type="checkbox"> C/C++【编写 C/C++】</li><li><input checked="" disabled="" type="checkbox"> Chinese (simplified)Language pack for Visual Code【简体中文】</li><li><input checked="" disabled="" type="checkbox"> [ ] <del>Bracket Pair Colorrizer 2 【优化大括号】</del></li><li><input disabled="" type="checkbox"> <del>background 【添加背景图片】</del></li><li><input disabled="" type="checkbox"> <del>AnsiComment</del></li><li><input checked="" disabled="" type="checkbox"> vscode-icons【美化图标】</li><li><input disabled="" type="checkbox"> <del>Path Intellisense【补全】</del></li><li><input disabled="" type="checkbox"> <del>GitLens 【显示当前行 commit 信息，管理 git】</del></li><li><input disabled="" type="checkbox"> <del>Git History 【查看 commit 信息】</del></li><li><input checked="" disabled="" type="checkbox"> Waka Time【记录软件编写各类语言时间分配】</li><li><input checked="" disabled="" type="checkbox"> Todo Tree【优化 TODO：侧边栏】</li><li><input checked="" disabled="" type="checkbox"> Todo Highlight【优化 TODO：高亮】</li><li><input checked="" disabled="" type="checkbox"> language-stylus【hexo 博客】</li><li><input checked="" disabled="" type="checkbox"> Live Server【运行 HTML】</li></ul><h2 id="VScode-编写-C-和-C-配置"><a href="#VScode-编写-C-和-C-配置" class="headerlink" title="VScode 编写 C 和 C++配置"></a>VScode 编写 C 和 C++配置</h2><blockquote><ul><li>下载插件 ✅CodeRunner【编写 C/C++】✅C/C++【编写 C/C++】</li></ul></blockquote><blockquote><ul><li>建立一个 <code>.vscode</code>  文件夹，然后在里面新建下面三个文件即可。</li></ul></blockquote><h3 id="launch-json"><a href="#launch-json" class="headerlink" title="launch.json"></a>launch.json</h3><pre><code class="json">// https://code.visualstudio.com/docs/cpp/launch-json-reference&#123;  &quot;version&quot;: &quot;0.2.0&quot;,  &quot;configurations&quot;: [    &#123;      &quot;name&quot;: &quot;(gdb) Launch&quot;, // 配置名称，将会在启动配置的下拉菜单中显示      &quot;type&quot;: &quot;cppdbg&quot;, // 配置类型，cppdbg对应cpptools提供的调试功能；可以认为此处只能是cppdbg      &quot;request&quot;: &quot;launch&quot;, // 请求配置类型，可以为launch（启动）或attach（附加）      &quot;program&quot;: &quot;$&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;.exe&quot;, // 将要进行调试的程序的路径      &quot;args&quot;: [], // 程序调试时传递给程序的命令行参数，一般设为空即可      &quot;stopAtEntry&quot;: false, // 设为true时程序将暂停在程序入口处，相当于在main上打断点      &quot;cwd&quot;: &quot;$&#123;workspaceFolder&#125;&quot;, // 调试程序时的工作目录，此为工作区文件夹；改成$&#123;fileDirname&#125;可变为文件所在目录      &quot;environment&quot;: [], // 环境变量      &quot;externalConsole&quot;: true, // 使用单独的cmd窗口，与其它IDE一致；为false时使用内置终端      &quot;internalConsoleOptions&quot;: &quot;neverOpen&quot;, // 如果不设为neverOpen，调试时会跳到“调试控制台”选项卡，你应该不需要对gdb手动输命令吧？      &quot;MIMode&quot;: &quot;gdb&quot;, // 指定连接的调试器，可以为gdb或lldb。但我没试过lldb      &quot;miDebuggerPath&quot;: &quot;gdb.exe&quot;, // 调试器路径，Windows下后缀不能省略，Linux下则不要      &quot;setupCommands&quot;: [        &#123;          // 模板自带，好像可以更好地显示STL容器的内容，具体作用自行Google          &quot;description&quot;: &quot;Enable pretty-printing for gdb&quot;,          &quot;text&quot;: &quot;-enable-pretty-printing&quot;,          &quot;ignoreFailures&quot;: false        &#125;      ],      &quot;preLaunchTask&quot;: &quot;Compile&quot; // 调试会话开始前执行的任务，一般为编译程序。与tasks.json的label相对应    &#125;  ]&#125;</code></pre><h3 id="settings-json"><a href="#settings-json" class="headerlink" title="settings.json"></a>settings.json</h3><pre><code class="json">&#123;  &quot;files.defaultLanguage&quot;: &quot;c&quot;, // ctrl+N新建文件后默认的语言  &quot;editor.formatOnType&quot;: true, // 输入分号(C/C++的语句结束标识)后自动格式化当前这一行的代码  &quot;editor.suggest.snippetsPreventQuickSuggestions&quot;: false, // clangd的snippets有很多的跳转点，不用这个就必须手动触发Intellisense了  &quot;editor.acceptSuggestionOnEnter&quot;: &quot;off&quot;, // 我个人的习惯，按回车时一定是真正的换行，只有tab才会接受Intellisense  // &quot;editor.snippetSuggestions&quot;: &quot;top&quot;, // （可选）snippets显示在补全列表顶端，默认是inline  &quot;code-runner.runInTerminal&quot;: true, // 设置成false会在“输出”中输出，无法输入  &quot;code-runner.executorMap&quot;: &#123;    &quot;c&quot;: &quot;gcc &#39;$fileName&#39; -o &#39;$fileNameWithoutExt.exe&#39; -Wall -O2 -m64 -lm -static-libgcc -std=c11 -fexec-charset=GBK &amp;&amp; &amp;&#39;./$fileNameWithoutExt.exe&#39;&quot;,    &quot;cpp&quot;: &quot;g++ &#39;$fileName&#39; -o &#39;$fileNameWithoutExt.exe&#39; -Wall -O2 -m64 -static-libgcc -std=c++14 -fexec-charset=GBK &amp;&amp; &amp;&#39;./$fileNameWithoutExt.exe&#39;&quot;    // &quot;c&quot;: &quot;gcc $fileName -o $fileNameWithoutExt.exe -Wall -O2 -m64 -lm -static-libgcc -std=c11 -fexec-charset=GBK &amp;&amp; $dir$fileNameWithoutExt.exe&quot;,    // &quot;cpp&quot;: &quot;g++ $fileName -o $fileNameWithoutExt.exe -Wall -O2 -m64 -static-libgcc -std=c++14 -fexec-charset=GBK &amp;&amp; $dir$fileNameWithoutExt.exe&quot;  &#125;, // 右键run code时运行的命令；未注释的仅适用于PowerShell（Win10默认）和pwsh，文件名中有空格也可以编译运行；注释掉的适用于cmd（win7默认）、PS和bash，但文件名中有空格时无法运行  &quot;code-runner.saveFileBeforeRun&quot;: true, // run code前保存  &quot;code-runner.preserveFocus&quot;: true, // 若为false，run code后光标会聚焦到终端上。如果需要频繁输入数据可设为false  &quot;code-runner.clearPreviousOutput&quot;: false, // 每次run code前清空属于code runner的终端消息，默认false  &quot;code-runner.ignoreSelection&quot;: true, // 默认为false，效果是鼠标选中一块代码后可以单独执行，但C是编译型语言，不适合这样用  &quot;code-runner.fileDirectoryAsCwd&quot;: true, // 将code runner终端的工作目录切换到文件目录再运行，对依赖cwd的程序产生影响；如果为false，executorMap要加cd $dir  &quot;C_Cpp.clang_format_sortIncludes&quot;: true // 格式化时调整include的顺序（按字母排序）&#125;</code></pre><h3 id="tasks-json"><a href="#tasks-json" class="headerlink" title="tasks.json"></a>tasks.json</h3><pre><code class="json">// https://code.visualstudio.com/docs/editor/tasks&#123;  &quot;version&quot;: &quot;2.0.0&quot;,  &quot;tasks&quot;: [    &#123;      &quot;label&quot;: &quot;Compile&quot;, // 任务名称，与launch.json的preLaunchTask相对应      &quot;command&quot;: &quot;gcc&quot;, // 要使用的编译器，C++用g++      &quot;args&quot;: [        &quot;$&#123;file&#125;&quot;,        &quot;-o&quot;, // 指定输出文件名，不加该参数则默认输出a.exe，Linux下默认a.out        &quot;$&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;.exe&quot;,        &quot;-g&quot;, // 生成和调试有关的信息        &quot;-m64&quot;, // 不知为何有时会生成16位应用而无法运行，加上此条可强制生成64位的        &quot;-Wall&quot;, // 开启额外警告        &quot;-static-libgcc&quot;, // 静态链接libgcc，一般都会加上        &quot;-fexec-charset=GBK&quot; // 生成的程序使用GBK编码，不加这条会导致Win下输出中文乱码；繁体系统改成BIG5        // &quot;-std=c11&quot;, // 要用的语言标准，根据自己的需要修改。c++可用c++14      ], // 编译的命令，其实相当于VSC帮你在终端中输了这些东西      &quot;type&quot;: &quot;process&quot;, // process是把预定义变量和转义解析后直接全部传给command；shell相当于先打开shell再输入命令，所以args还会经过shell再解析一遍      &quot;group&quot;: &#123;        &quot;kind&quot;: &quot;build&quot;,        &quot;isDefault&quot;: true // 不为true时ctrl shift B就要手动选择了      &#125;,      &quot;presentation&quot;: &#123;        &quot;echo&quot;: true,        &quot;reveal&quot;: &quot;always&quot;, // 执行任务时是否跳转到终端面板，可以为always，silent，never。具体参见VSC的文档        &quot;focus&quot;: false, // 设为true后可以使执行task时焦点聚集在终端，但对编译C/C++来说，设为true没有意义        &quot;panel&quot;: &quot;shared&quot; // 不同的文件的编译信息共享一个终端面板      &#125;,      &quot;problemMatcher&quot;: &quot;$gcc&quot; // 捕捉编译时终端里的报错信息到问题面板中，修改代码后需要重新编译才会再次触发      // 本来有Lint，再开problemMatcher就有双重报错，但MinGW的Lint效果实在太差了；用Clang可以注释掉    &#125;  ]&#125;</code></pre><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><ul><li>vscode 可以自定义 markdown 预览样式，css 文件以外链的方式放上</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.zhihu.com/question/30315894">Visual Studio Code 如何编写运行 C、C++ 程序？</a></li><li><a href="https://segmentfault.com/a/1190000006697219">vscode 插件推荐 - 献给所有前端工程师（2019.10.12 更新）</a></li><li><a href="https://blog.csdn.net/TriDiamond6/article/details/105604427?utm_source=app">VSCode 插件大全｜ VSCode 高级玩家之第二篇</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Environment </category>
          
          <category> 工具使用 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>配置java开发环境</title>
      <link href="blog/cwqx6l/"/>
      <url>blog/cwqx6l/</url>
      
        <content type="html"><![CDATA[<h2 id="一、下载"><a href="#一、下载" class="headerlink" title="一、下载"></a>一、下载</h2><p><a href="https://www.oracle.com/cn/java/technologies/javase-downloads.html">https://www.oracle.com/cn/java/technologies/javase-downloads.html</a></p><h2 id="二、环境变量配置"><a href="#二、环境变量配置" class="headerlink" title="二、环境变量配置"></a>二、环境变量配置</h2><p><strong>在系统变量下</strong></p><h3 id="CLASSPATH"><a href="#CLASSPATH" class="headerlink" title="CLASSPATH"></a>CLASSPATH</h3><blockquote><p>.;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar;%CATALINA_HOME%\common\lib\servlet-api.jar;</p></blockquote><p>其中<code>%CATALINA_HOME%\common\lib\servlet-api.jar;</code>为 tomcat 的加包配置</p><h3 id="JAVA-HOME"><a href="#JAVA-HOME" class="headerlink" title="JAVA_HOME"></a>JAVA_HOME</h3><blockquote><p>C:\Program Files\Java\jdk1.8.0_181</p></blockquote><h3 id="path"><a href="#path" class="headerlink" title="path"></a>path</h3><blockquote><p>%JAVA_HOME%\bin<br>%JAVA_HOME%\jre\bin</p></blockquote><h2 id="三、测试"><a href="#三、测试" class="headerlink" title="三、测试"></a>三、测试</h2><p>CMD 下输入<code>java -version</code></p>]]></content>
      
      
      <categories>
          
          <category> Environment </category>
          
          <category> 环境配置 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Anaconda+JetBrains系列软件使用总结</title>
      <link href="blog/mv7tir/"/>
      <url>blog/mv7tir/</url>
      
        <content type="html"><![CDATA[<h2 id="一、Anaconda-和-Pycharm-下载与配置"><a href="#一、Anaconda-和-Pycharm-下载与配置" class="headerlink" title="一、Anaconda 和 Pycharm 下载与配置"></a>一、Anaconda 和 Pycharm 下载与配置</h2><h3 id="下载-Anaconda-且配置"><a href="#下载-Anaconda-且配置" class="headerlink" title="下载 Anaconda 且配置"></a>下载 Anaconda 且配置</h3><ul><li>（更新）下载了 anaconda 就不要单独下载 python，之前下的也删掉，以此避免路径冲突</li><li>方式一：<strong>迅雷下载</strong>（推荐）；方式二：提取链接<strong>网盘下载</strong>；方式三：清华镜像下载，下载完安装【直接 next 即可】</li><li><strong>测试</strong>：<code>win + R</code> 进入终端输入<code>conda</code>出现 conda 命令使用指南，即证明成功安装</li><li><strong>配置环境变量</strong>：在<strong>系统变量</strong>path 路径中加入下面配置（具体路径具体填写）</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1606634508207-8eb4dda2-6dbe-4162-b7eb-93cc5b35dc0e.png#align=left&display=inline&height=107&margin=%5Bobject%20Object%5D&name=image.png&originHeight=169&originWidth=467&size=7789&status=done&style=shadow&width=296" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1606634439956-bfa830a0-ece9-4caa-9bf7-641b14dafd70.png#align=left&display=inline&height=41&margin=%5Bobject%20Object%5D&name=image.png&originHeight=81&originWidth=645&size=5266&status=done&style=shadow&width=322.5" alt="image.png"></p><h3 id="下载-Pycharm-且配置"><a href="#下载-Pycharm-且配置" class="headerlink" title="下载 Pycharm 且配置"></a>下载 Pycharm 且配置</h3><ul><li><p><strong>下载版本</strong><a href="https://www.jetbrains.com/pycharm/download/">社区/专业</a>：专业版本需要激活码，社区版本功能基本能应付日常使用</p><blockquote><p>（大学学生时期可以用学生邮箱申请使用 JetBrains 系列软件，我的方法是先认证 GitHub 学生认证，然后直接从 GitHub 那边认证 JetBrains 软件的使用权，当然也可以直接用学生邮箱去 JetBrains 官网认证）</p></blockquote></li><li><p><strong>❗ 补充：取消上面用学生邮箱去申请 JetBrains 系列软件使用方法。先去 GitHub 申请学生包，然后通过 GitHub 已认证的 GitHub 账号再去申请 JetBrains 系列软件较为方便 <a href="https://www.jetbrains.com/zh-cn/community/education/?_ga=2.186354217.1063699871.1594345232-1379189663.1590592761#students">JetBrains 申请链接 🔗</a></strong></p></li><li><p>Pycharm 使用 Anaconda 的配置 （ <strong>❗ 补充：下面貌似是社区版本的添加方式，但是专业版本会自动识别</strong> ）：</p></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685306285-e6ca8228-9234-4c7f-97f3-9d7fc26e0728.png#align=left&display=inline&height=266&margin=%5Bobject%20Object%5D&originHeight=1077&originWidth=1843&size=0&status=done&style=shadow&width=456"></p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685306347-9a79eaf2-93cf-4ed4-b008-9e49aa66ad7e.png#align=left&display=inline&height=324&margin=%5Bobject%20Object%5D&originHeight=885&originWidth=1227&size=0&status=done&style=shadow&width=449"></p><h2 id="二、Anaconda-环境管理"><a href="#二、Anaconda-环境管理" class="headerlink" title="二、Anaconda 环境管理"></a>二、Anaconda 环境管理</h2><h3 id="pip-conda-Miniconda-Anaconda"><a href="#pip-conda-Miniconda-Anaconda" class="headerlink" title="pip,conda,Miniconda,Anaconda"></a>pip,conda,Miniconda,Anaconda</h3><ul><li>pip 包管理工具，python 官方认证</li><li>conda 是一种通用包管理系统，旨在构建和管理任何语言和任何类型的软件。包管理与 pip 的使用类似，环境管理则允许用户方便地安装不同版本的 python 并可以快速切换。</li><li>Anaconda 则是一个打包的集合，里面预装好了 conda、某个版本的 python、众多 packages、科学计算工具等等，就是把很多常用的不常用的库都给你装好了。同时利用配置/工具/命令 conda 来进行 package 和<strong>environment</strong>的管理。</li><li>Miniconda，它只包含最基本的内容——python 与 conda，以及相关的必须依赖项，对于空间要求严格的用户，Miniconda 是一种选择。就只包含最基本的东西，其他的库得自己装。</li></ul><blockquote><p>pip 下载/管理经常 bug，用 conda 结合 anaconda/miniconda 方便使用</p></blockquote><h3 id="Python-相关包路径的查看"><a href="#Python-相关包路径的查看" class="headerlink" title="Python 相关包路径的查看"></a>Python 相关包路径的查看</h3><ul><li><code>win+R</code>   输入<code>cmd</code>   输入<code>python</code> 输入<code>import sys</code> 输入<code>sys.path</code></li><li>标准库：anaconda 文件夹下的 lib 文件夹</li><li>第三方库：下述代码中的文件夹 <code>C:\Users\wztli\Anaconda3\Lib\site-packages</code></li></ul><h3 id="Sklearn-包安装失败总结"><a href="#Sklearn-包安装失败总结" class="headerlink" title="Sklearn 包安装失败总结"></a>Sklearn 包安装失败总结</h3><p>安装 scikit-learn 包，导入 sklearn 的 Bug</p><pre><code class="powershell">ImportError: DLL load failed: 找不到指定的模块</code></pre><p><code>scikit-learn</code>的下载会对 numpy、scipy、joblib 三个库相应版本有所要求，总之如果用 anaconda 的话，全部更新为最新即可（<a href="https://www.lfd.uci.edu/~gohlke/pythonlibs/">参考 whl 版本</a>）</p><blockquote><ul><li><code>C:\Users\wztli\Anaconda3\pkgs\scikit-learn-0.21.3-py37h6288b17_0\Lib\site-packages\sklearn\datasets\data</code></li><li>数据集在电脑中的位置</li></ul></blockquote><h3 id="Scrapy-包安装失败总结"><a href="#Scrapy-包安装失败总结" class="headerlink" title="Scrapy 包安装失败总结"></a>Scrapy 包安装失败总结</h3><ul><li>pip 下载可能会失败</li><li>使用 conda（镜像）下载<code>conda install -c scrapinghub scrapy</code></li></ul><h2 id="三、JetBrains-系列软件的高效使用"><a href="#三、JetBrains-系列软件的高效使用" class="headerlink" title="三、JetBrains 系列软件的高效使用"></a>三、JetBrains 系列软件的高效使用</h2><h3 id="JetBrains-之初始配置"><a href="#JetBrains-之初始配置" class="headerlink" title="JetBrains 之初始配置"></a>JetBrains 之初始配置</h3><blockquote><p>界面字体大小、代码字体大小、主题默认（dark）、背景图片（看心情）</p></blockquote><ul><li>字体相关<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685306645-d747b801-f817-475d-93e7-a9357a6f810b.png#align=left&display=inline&height=284&margin=%5Bobject%20Object%5D&originHeight=886&originWidth=1227&size=0&status=done&style=none&width=393"></li><li>主题相关<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685306383-6425ce01-32e1-4216-b62e-def25d1e9dc7.png#align=left&display=inline&height=287&margin=%5Bobject%20Object%5D&originHeight=886&originWidth=1227&size=0&status=done&style=none&width=398"></li></ul><h3 id="JetBrains-之-Debug-断点调试"><a href="#JetBrains-之-Debug-断点调试" class="headerlink" title="JetBrains 之 Debug 断点调试"></a>JetBrains 之 Debug 断点调试</h3><blockquote><p>断点调试是优于打印输出的一种调试程序的一种手段（Pycharm 编辑器，其他系列软件也一样）</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685306462-78e560c3-6150-4b08-b806-34919a36f0a2.png#align=left&display=inline&height=283&margin=%5Bobject%20Object%5D&originHeight=397&originWidth=769&size=0&status=done&style=shadow&width=548"></p><blockquote><ul><li>Ctrl+F5（左上角）：（return “project”）重新 debug 该文件</li><li>F9：（resume program）一个断点接着一个断点走，不按行走（eg：有循环会随着 i 一步一步走完）</li><li>F8：（step over） 一行一行走代码</li><li>F7：（step into） 进入函数内部</li><li>Alt+shift+F7：（step into mycode）遇到自己函数   进去</li><li>shift+F8：（step out）跳出，进入函数后，跳出来</li><li>Alt+F10：（show execution point）指针显示当前断点旁边</li><li><strong>Show Python Prompt</strong>按键<br>交互式调试命令</li></ul></blockquote><h3 id="JetBrains-之-GitHub-使用"><a href="#JetBrains-之-GitHub-使用" class="headerlink" title="JetBrains 之 GitHub 使用"></a>JetBrains 之 GitHub 使用</h3><ol><li>配置 Git 和 GitHub（先连接本地 git，然后登录 GitHub）<br>页面   依次点击<code>File</code> <code>Setting</code> <code>Version Control</code> <code>GitHub</code>然后登录账户进行配置</li><li>将项目新建在 GitHub<br>菜单栏 依次点击 <code>VCS</code> <code>Import into Version Control</code> <code>Share Project on GitHub</code></li><li><strong>将项目克隆在本地</strong> <code>VCS</code> <code>Get from Version Control</code></li></ol><h3 id="JetBrains-之-TODO-使用"><a href="#JetBrains-之-TODO-使用" class="headerlink" title="JetBrains 之 TODO 使用"></a>JetBrains 之 TODO 使用</h3><p>便于编写大型代码，将注释加上前缀以便分类处理，以下图片展示<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685306509-efc968a4-bf76-44f3-8347-52cbb5a7cc73.png#align=left&display=inline&height=689&margin=%5Bobject%20Object%5D&originHeight=689&originWidth=1890&size=0&status=done&style=none&width=1890"></p><p>参考：</p><ul><li><a href="https://www.jetbrains.com/help/pycharm/using-todo.html">TODO 的使用官方文档</a></li><li><a href="https://blog.csdn.net/weixin_34277853/article/details/94205060?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-5&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-5">TODO 的用法</a></li></ul><h3 id="JetBrains-之插件枚举"><a href="#JetBrains-之插件枚举" class="headerlink" title="JetBrains 之插件枚举"></a>JetBrains 之插件枚举</h3><ul><li>Waka Time：持续记录自己的 IDE 以及编程语言的使用时长</li><li>leetcode editor：leetcode 刷题插件</li></ul><h3 id="JetBrains-之初用警告"><a href="#JetBrains-之初用警告" class="headerlink" title="JetBrains 之初用警告"></a>JetBrains 之初用警告</h3><p>一般下载完开始使用，IDE 会报一个 <code>Windows安全中心</code> 的警告</p><pre><code>Windows Defender might be impacting your build performance. PyCharm checked the following directorie</code></pre><p>解决：<img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685306961-bcb04392-e8c2-4f3a-a7f0-d2d1516afe70.png#align=left&display=inline&height=700&margin=%5Bobject%20Object%5D&originHeight=700&originWidth=1184&size=0&status=done&style=none&width=1184"><br>然后再进入排除项添加报错的文件夹即可</p><h3 id="JetBrains-之-IDEA-的-leetcode-插件"><a href="#JetBrains-之-IDEA-的-leetcode-插件" class="headerlink" title="JetBrains 之 IDEA 的 leetcode 插件"></a>JetBrains 之 IDEA 的 leetcode 插件</h3><blockquote><p>记录一些配置</p></blockquote><ul><li>勾选 Custom Template 和 Plugin Update</li><li>TempFilePath</li></ul><pre><code>D:\project-java\datastructure\src\com\wztlink1013\problems</code></pre><ul><li>CodeFileName</li></ul><pre><code>P$&#123;question.frontendQuestionId&#125;$!velocityTool.camelCaseName($&#123;question.titleSlug&#125;)</code></pre><ul><li>CodeTemplate</li></ul><pre><code>package com.wztlink1013.problems.leetcode.editor.cn;$&#123;question.content&#125;public class P$&#123;question.frontendQuestionId&#125;$!velocityTool.camelCaseName($&#123;question.titleSlug&#125;)&#123;    public static void main(String[] args) &#123;        Solution solution = new P$&#123;question.frontendQuestionId&#125;$!velocityTool.camelCaseName($&#123;question.titleSlug&#125;)().new Solution();    &#125;$&#123;question.code&#125;&#125;</code></pre><p>参考：<br><a href="https://blog.csdn.net/yxf19034516/article/details/106087994/">IDEA 的 LeetCode 力扣插件设置与使用</a><br><a href="https://hacpai.com/article/1575547715310">IDEA 的 LeetCode 刷题插件 leetcode editor</a></p>]]></content>
      
      
      <categories>
          
          <category> Environment </category>
          
          <category> 工具使用 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Jupyter使用总结</title>
      <link href="blog/ouipza/"/>
      <url>blog/ouipza/</url>
      
        <content type="html"><![CDATA[<h2 id="一、Jupyter-环境的搭建"><a href="#一、Jupyter-环境的搭建" class="headerlink" title="一、Jupyter 环境的搭建"></a>一、Jupyter 环境的搭建</h2><ol><li>pip 下载</li><li>跟随 anaconda 下载</li></ol><h2 id="二、高效使用，安装扩展插件"><a href="#二、高效使用，安装扩展插件" class="headerlink" title="二、高效使用，安装扩展插件"></a>二、高效使用，安装扩展插件</h2><p>一般只需要下面两条命令，就可以重新打开就可看见新安装的插件环境。</p><p><code>pip install jupyter_contrib_nbextensions</code></p><p>或者</p><p><code>jupyter contrib nbextension install</code></p><p>但是 pip 下载完，会出现 jupyter_contrib_nbextension 扩展功能后不显示 Nbextensions 标签的 bug，在此记录下解决的方式。</p><h2 id="三、扩展插件不显示的解决方法"><a href="#三、扩展插件不显示的解决方法" class="headerlink" title="三、扩展插件不显示的解决方法"></a>三、扩展插件不显示的解决方法</h2><ol><li>如果之前已经用上述两条命令之一安装了上述包，且用 pip list 查看的确成功安装，则依次进行下面删除命令（选 y）:<br><code>pip uninstall jupyter_contrib_nbextensions</code><br><code>pip uninstall jupyter_nbextensions_configurator</code></li><li>打开 Anaconda Prompt 窗口，执行第一个命令，用于安装 nbextensions:<br><code>pip install jupyter_contrib_nbextensions</code></li><li>再执行第下面命令，用于安装 javascript and css files:<br><code>jupyter contrib nbextension install --user</code></li><li>最后执行，用于安装 configurator:<br><code>pip install jupyter_nbextensions_configurator</code></li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.jiqizhixin.com/articles/2018-12-20-12">五个常用插件 - 简书</a></li><li><a href="https://www.zhihu.com/question/59392251/answer/560977151">如何优雅地使用 Jupyter？ - 量子位的回答 - 知乎</a></li><li><a href="https://blog.csdn.net/xiaodongxiexie/article/details/54633183">jupyter 使用技巧</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Environment </category>
          
          <category> 工具使用 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Premiere</title>
      <link href="blog/edproq/"/>
      <url>blog/edproq/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文转载自：<a href="https://zhuanlan.zhihu.com/p/32130541">5 分钟学会 Premiere 视频剪辑全流程</a></p></blockquote><h2 id="第-1-步，打开软件，新建项目"><a href="#第-1-步，打开软件，新建项目" class="headerlink" title="第 1 步，打开软件，新建项目"></a>第 1 步，打开软件，新建项目</h2><p><strong>a.</strong> 填写项目名称；</p><p><strong>b.</strong> 选择项目保存位置，建议建一个用于存放视频项目的文件夹；</p><p><strong>c.</strong> 其他的可以不用改动，点击“确定”。</p><p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1609848527644-14d127eb-6145-4323-8d7e-dc1b813b7d17.jpeg#align=left&display=inline&height=719&margin=%5Bobject%20Object%5D&originHeight=719&originWidth=624&size=0&status=done&style=none&width=624"></p><p><strong>进入“面板”后</strong></p><p><strong>a.</strong> Ctrl+N 新建一个序列；</p><p><strong>b.</strong> 点击“设置”，编辑模式选择“自定义”；</p><p><strong>c.</strong> 帧速率我一般习惯用 23.976，也有的人喜欢用 24、25 或者是 30 帧；</p><p>（至于它们具体有什么区别，我在这里就不详细说了，你们可以自行百度一下）</p><p><strong>d.</strong> 帧大小也就是分辨率，我们通常设置为 1920*1080；</p><p><strong>e.</strong> 像素长宽比选择“方形像素”，场序选择“逐行”；</p><p><strong>f.</strong> 写上序列名称，其他的可以暂时先不研究。</p><p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1609848527668-82cc24b0-26f6-4cad-880e-b71650f5b9f4.jpeg#align=left&display=inline&height=797&margin=%5Bobject%20Object%5D&originHeight=797&originWidth=720&size=0&status=done&style=none&width=720"></p><h2 id="第-2-步，将素材导入-PR"><a href="#第-2-步，将素材导入-PR" class="headerlink" title="第 2 步，将素材导入 PR"></a>第 2 步，将素材导入 PR</h2><p>在“项目面板”内的空白处单击右键导入素材，或者直接将素材选中拖入“项目面板”，如果直接选择一个文件夹的话，直接拖入项目面板，它会生成一个素材箱；</p><p><img src="https://cdn.nlark.com/yuque/0/2021/gif/1484158/1609848527661-1f047b51-da0e-4a8d-af96-6cadf1a8ab75.gif#align=left&display=inline&height=376&margin=%5Bobject%20Object%5D&originHeight=376&originWidth=420&size=0&status=done&style=none&width=420"></p><p>也可以点击右下角的图标，新建一个素材箱，素材箱便于我们进行整理和归类。</p><p><img src="https://cdn.nlark.com/yuque/0/2021/gif/1484158/1609848527781-1f3c610b-49e4-45e0-a13b-96df9b2fb96b.gif#align=left&display=inline&height=355&margin=%5Bobject%20Object%5D&originHeight=355&originWidth=423&size=0&status=done&style=none&width=423"></p><p>除了视频和音频可以导入 PR 之外，图片和 GIF 都可以导入 PR 进行编辑。</p><h2 id="第-3-步，将素材拖入时间轴"><a href="#第-3-步，将素材拖入时间轴" class="headerlink" title="第 3 步，将素材拖入时间轴"></a>第 3 步，将素材拖入时间轴</h2><p><strong>剪辑工作需要在时间轴里面进行：</strong></p><p><strong>a.</strong> 先用鼠标点中素材不放，拖入时间轴的空白处松开就可以了；</p><p>（时间轴上的两个蓝条，上面的轨道是视频，下面的轨道是音频）</p><p><strong>b.</strong> 如果你觉得拖入整条素材太长，也可以先截选片段，鼠标按住视频画面不放，将截选的片段拖到时间轴上；</p><p><strong>c.</strong> 拖入时间轴后如果出现“剪辑不匹配警告”的提示，点击“保持现有设置”，然后右键点击素材，选择“缩放为帧大小”就可以了。</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609848527688-a4109e9f-d436-4e57-9461-8945695f19c8.png#align=left&display=inline&height=228&margin=%5Bobject%20Object%5D&originHeight=228&originWidth=523&size=0&status=done&style=none&width=523"></p><h2 id="第-4-步：剪辑（精剪）"><a href="#第-4-步：剪辑（精剪）" class="headerlink" title="第 4 步：剪辑（精剪）"></a>第 4 步：剪辑（精剪）</h2><p><strong>剪辑工作</strong>包括对素材进行<strong>裁剪</strong>、<strong>拼接</strong>，<strong>调色</strong>，添加<strong>配乐</strong>、<strong>音效</strong>，还可以添加<strong>转场</strong>、<strong>特效</strong>等等，关于这些进阶内容我们后面会有专门的课程进行深入地解析，这里就不多说了。</p><p>完成整个视频的制作以后，我们就可以进行</p><h2 id="第-5-步：渲染输出"><a href="#第-5-步：渲染输出" class="headerlink" title="第 5 步：渲染输出"></a>第 5 步：渲染输出</h2><p><strong>a.</strong> 在“文件”中，点击“导出”，选择“媒体”，弹出渲染设置面板；</p><p><strong>b.</strong> 格式我一般选择 H.264，预设选择“匹配源—高比特率”；</p><p><strong>c.</strong> 设置文件保存位置和文件名。</p><p>其他的参数可以不用改动，对于一般的用户来说这样的设置就够用了，最后点击“导出”就完成了。</p><p>以上内容是我为大家总结整理的 PR 剪辑的基本流程，它不是最全面的，但如果你掌握了前面所说的这些内容，简单地剪辑一个视频几乎没有什么问题了。</p>]]></content>
      
      
      <categories>
          
          <category> PostProduction </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>《龙猫·剪辑》数字媒体后期制作大作业</title>
      <link href="blog/bkthv9/"/>
      <url>blog/bkthv9/</url>
      
        <content type="html"><![CDATA[<h2 id="后期制作大作业-B-站地址"><a href="#后期制作大作业-B-站地址" class="headerlink" title="后期制作大作业 B 站地址"></a>后期制作大作业 B 站地址</h2><blockquote><p><strong>菜的一逼</strong>……<img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1623289703745-08c74433-8721-408d-9970-e9ea9c43f794.jpeg#id=cWhW9&originHeight=50&originWidth=51&originalType=binary%E2%88%B6=1&status=done&style=none"><br>地址：<a href="https://www.bilibili.com/video/BV1UA41187G1">https://www.bilibili.com/video/BV1UA41187G1</a></p></blockquote><iframe src="//player.bilibili.com/player.html?aid=327528419&bvid=BV1UA41187G1&cid=173889112&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>​<h2 id="PS-上课笔记"><a href="#PS-上课笔记" class="headerlink" title="PS 上课笔记"></a>PS 上课笔记</h2><blockquote><p>认识 PS===有许多功能 eg：绘画等等<br>准备工作===了解菜单栏；工具栏；基本功能</p></blockquote><h3 id="图层面板的认识"><a href="#图层面板的认识" class="headerlink" title="图层面板的认识"></a>图层面板的认识</h3><p>图层顺序 上一层遮挡下一层 蒙版也是图层<br>混合模式 就是这层图层与下一层混合叠加的效果<br>@@滤色 就是消去黑色深色只显示白色亮色的部分 案例光晕 用黑背景绘画光晕的图案选择滤色混合样式<br>图层样式<br>不透明<br>创建 删除 解锁</p><h3 id="图片的裁切"><a href="#图片的裁切" class="headerlink" title="图片的裁切"></a>图片的裁切</h3><p>选框工具不行===无法确定像素 不能缩放要显示的区域<br>裁剪工具不行===能确定像素 但不能缩放要显示的区域只是同时裁剪图片和画布<br>图像===大小不行–只是压缩图片和画布而已  <br>画布大小（前提是图层不是背景层没有被锁定）<br>调整画布的大小+自由变换工具缩放+移动工具<br>我们想要的大小 调整图像等比例缩放 移动到我们要显示的区域</p><h3 id="蒙版作用"><a href="#蒙版作用" class="headerlink" title="蒙版作用"></a>蒙版作用</h3><p>蒙版只有白和黑 只是在通道建立一个白色的蒙版图层（默认全部显示；有选区时，选区是白色的非选区是黑色的）<br>黑透明，白不透明<br>画笔涂抹 透明度 流量<br>一般用来合成图片<br>对图像擦除的效果 但不影响原始图像的像素 便于后期修改<br>如果用橡皮擦会破坏原始素材</p><h3 id="正确校色"><a href="#正确校色" class="headerlink" title="正确校色"></a>正确校色</h3><p>图像-调整===对图像校色是不可逆的 不适合后期修改<br>创建新的填充和调整图层的按钮 添加带蒙版的调整图层<br>带蒙版的调整图层 是可逆的<br>如果想只对**一个图层作用 右击图层-创建剪切蒙版</p><h3 id="钢笔工具"><a href="#钢笔工具" class="headerlink" title="钢笔工具"></a>钢笔工具</h3><p>点击-点击===是直线<br>点击-点击不要松开手===拖动 就是曲线勒<br>alt+ 点击瞄点拖拉会产生操纵杆===并且把直线变成曲线<br>点击单个操纵杆会单独操纵一边的  <br>crtl+ 移动瞄点<br>属性栏【自动添加/删除】打勾时 点击线能添加点 点击点不拖动能删除点<br>描绘到一半的没闭合的图层 要闭合的话就要先 ctrl 点击最后一点 在点击初始点<br>抠出的区域转为选区 选中图层 点击路径面板-将路径转为选区<br>这时候的选区可以 建立蒙版把他抠出来单独单独显示 这种抠图是可逆的</p><h3 id="修片时用到的工具"><a href="#修片时用到的工具" class="headerlink" title="修片时用到的工具"></a>修片时用到的工具</h3><p>红眼 ===记得是整个眼睛<br>污点 ===可以吧污点附近的像素自动修改污点 但是对麻子脸没用<br>修复画笔 ===把目标的像素填充涂抹的地方 并且能自动融合边缘<br>修补工具 ===框选一个目标选区 填充涂抹的地方 并且能自动融合边缘</p><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
      
      
      <categories>
          
          <category> PostProduction </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="HelloWorld/"/>
      <url>HelloWorld/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><span id="more"></span><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
