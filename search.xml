<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>辣椒炒莲藕</title>
      <link href="/essay/fi4c0o/"/>
      <url>/essay/fi4c0o/</url>
      
        <content type="html"><![CDATA[<p>辣椒炒莲藕</p><h2 id=""><a href="#" class="headerlink" title=""></a><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/1484158/1656819779743-aa355d3d-1fc6-454d-bebc-9f0178742cc7.jpeg#clientId=ue436d82e-ab28-4&crop=0&crop=0&crop=1&crop=1&from=drop&id=ued5f21b8&margin=%5Bobject%20Object%5D&name=IMG_20220121_120941.jpg&originHeight=2736&originWidth=2736&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=2002855&status=done&style=none&taskId=u7dbe86b4-aa03-4d6d-af64-aeebcee20aa&title=" alt="IMG_20220121_120941.jpg"></h2>]]></content>
      
      
      <categories>
          
          <category> 料理 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>辣椒炒平菇</title>
      <link href="/essay/cgp1qa/"/>
      <url>/essay/cgp1qa/</url>
      
        <content type="html"><![CDATA[<p>辣椒炒平菇<br><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/1484158/1656819580848-fd5bd076-3c27-42ea-a245-7b61b3aaf83c.jpeg#clientId=ub87c8acf-4a22-4&crop=0&crop=0&crop=1&crop=1&from=drop&id=u739306bc&margin=%5Bobject%20Object%5D&name=IMG_20220115_122347.jpg&originHeight=2736&originWidth=2736&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=1490646&status=done&style=none&taskId=ua0d9a841-c548-4d68-a6d6-b17d63bbe08&title=" alt="IMG_20220115_122347.jpg"></p><hr>]]></content>
      
      
      <categories>
          
          <category> 料理 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>鸡蛋水煮面</title>
      <link href="/essay/zky9eg/"/>
      <url>/essay/zky9eg/</url>
      
        <content type="html"><![CDATA[<ol><li>准备好配菜：辣椒，大蒜……切好</li><li>用稍微烧开的水（80℃）泡面条，让其软化</li><li>锅里面放油烧一会，然后把配菜放进去，然后再舀点水进去，这过程中可以放鸡蛋进去，然后机会差不多放盐下去</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/1484158/1656818758889-aaba7431-98fc-4cb0-b052-40ac338b3034.jpeg#crop=0&crop=0&crop=1&crop=1&from=url&id=QLQYX&margin=%5Bobject%20Object%5D&name=IMG_20220616_200659.jpeg&originHeight=1216&originWidth=912&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=83125&status=done&style=none&title=" alt="IMG_20220616_200659.jpeg"></p>]]></content>
      
      
      <categories>
          
          <category> 料理 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>《山茶文具店》小记</title>
      <link href="/essay/tegfte/"/>
      <url>/essay/tegfte/</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/1484158/1653571677209-7e72abde-e202-4913-b4fc-4e89285d0779.jpeg#clientId=u8dbe269d-a9a6-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u836fe5f8&margin=%5Bobject%20Object%5D&originHeight=385&originWidth=270&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&taskId=u14adb637-a7bc-4380-a61d-56159f4dc0a&title="><br>前言：书中的代笔文字还有文具店在四季所渲染的氛围，很能让人安静下来。另外很多场景都像是自己以前读书，独自的对生活感悟的别种形式的外露……</p><h2 id="夏"><a href="#夏" class="headerlink" title="夏"></a>夏</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/1484158/1653570370540-3d102396-6f1f-45ca-a7dd-5951a5c05a4d.jpeg#clientId=u8dbe269d-a9a6-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=366&id=flM7L&margin=%5Bobject%20Object%5D&originHeight=675&originWidth=742&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&taskId=u459aa3f4-acba-4275-b983-3fceaf195e5&title=&width=401.9907531738281"><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/1484158/1653570419276-697b6192-1806-4de2-9667-0743f020a122.jpeg#clientId=u8dbe269d-a9a6-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=358&id=uf11d2c4e&margin=%5Bobject%20Object%5D&originHeight=675&originWidth=753&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&taskId=u2e27e4ac-85a8-4e4b-89af-1dd656571d9&title=&width=398.98614501953125"><br>真诚且坦诚……</p><blockquote><p>夏日的夕阳把门外的巷子染成一片橘色。</p></blockquote><blockquote><p>夏蝉在白天聒噪地叫个不停，入夜后便安静下来，四周一片寂静，简直就像身处深山秘境，只不过仍然闷热不已。</p></blockquote><blockquote><p>“因为我自己写的话，一下子就会看出是小孩子写的。我只要让老师知道我的心意就好。婆婆告诉我，这里的阿嬷可以帮人写很出色的信。”</p></blockquote><blockquote><p>“她为我写了一封打动我老公的情书，所以我们才会结婚哦。”</p></blockquote><p>文字的浪漫……以至于我现在就想去二餐打印店买一纸山师信封，书写起浪漫情话……</p><blockquote><p>我忍不住冷静思考，为什么在这么热的天气里，我还要刻苦练习这些自己根本不喜欢的书法？打从出生起便一直闷在内心的愤怒和疑问，就像岩浆般一口气喷了出来，就连我自己也无法阻止。</p></blockquote><p>桀</p><blockquote><p>敬致关爱我们的各位：夏阳高照的季节来临，镰仓的绿意也更加蓬勃。不知各位是否别来无恙？在鹤冈八幡宫举行婚礼至今，转眼已过十五载，不禁感叹时光流逝如此匆匆。能在各位的见证下，于樱花飘舞的庄严气氛中共结连理，堪称人生之大幸。平日，我们各自努力工作；假日，则常偕同前往海边或山野健行。生活虽然平淡，但夫妻共同享受了日常的平凡幸福，我们都希望能随着岁月的累积，加深彼此的理解和情感。虽然我们无缘得子，但也因此邂逅了爱犬汉娜，我们视她如己出，疼爱有加。回想起来，带着汉娜一起去冲绳旅行的时光，是我们一家人无可取代的美好回忆。此次提笔，是为了向各位报告一件遗憾的事：我们在七月底解除了夫妻关系，正式离婚。虽然我们花费很长时间沟通，摸索是否能找到继续相处的方法；也曾请亲密的友人提供协助，努力寻求最完善的方式，希望走向圆满的结局。但是，前妻希望能与新的伴侣共度未来的人生，无悔活出自我的意志也相当坚定。最后，我们决定分道扬镳，各奔前程。虽然我们无法携手相伴到白头，但仍将默默支持彼此的第二人生。因此，如蒙各位认为我们为了追求幸福的人生，做出富有勇气的决定，我们将深感万幸。各位温暖地守护我们夫妻，如今却辜负了各位的期待，为此着实深感痛苦。衷心感谢各位至今为止的亲切和关爱，有幸和各位结缘，带给我们莫大的鼓励和安慰。虽然我们决定迈向不同的人生，但仍希望能够维持与各位之间的缘分，这也是我们的共同心愿。希望有朝一日，能笑着谈论今天。满怀感恩之心。敬颂崇祺</p></blockquote><h2 id="秋"><a href="#秋" class="headerlink" title="秋"></a>秋</h2><blockquote><p>最近的天空已经有了秋天的味道。山茶文具店也到了差不多该使用火炉的时候，否则太冷了。</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/1484158/1653571236427-fb03c188-941e-4200-a318-c0bb40656720.jpeg#clientId=u8dbe269d-a9a6-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u6ce68298&margin=%5Bobject%20Object%5D&originHeight=986&originWidth=672&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&taskId=uf214bd12-34dc-4202-b95d-f30e9ffeed5&title="><br>作为曾经许诺的对象，我想看到这的反应不是遗憾，反而是喜极而泣……</p><blockquote><p>用几乎快超出信封的大字写得很有气势。</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/1484158/1653571439352-fa11a7d7-e50a-4a87-b775-b5254b726155.jpeg#clientId=u8dbe269d-a9a6-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u95115f11&margin=%5Bobject%20Object%5D&originHeight=1034&originWidth=1102&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&taskId=u677e60e0-f5aa-40bb-b9ae-37d73501522&title="><br>这个手写正楷字真的好看。</p><p>读书期间，写字最好看的往往不是学习最好的，而学习极好的同学，反而写的字，不怎么样。。</p><blockquote><p>我一直以为，字能够反映书写者的人品，但这种认识并不正确。有不少人像花莲小姐一样，即使下了苦功，仍然无法写出漂亮的字。如果认为因为心丑才会字丑，未免太武断了。</p></blockquote><p>代笔这个职业，突然让我想到日本很多影视里面神女这一角色，千恋万花</p><blockquote><p>接着用右手轻轻握住花莲小姐的右手，闭着眼睛，像深呼吸般在卡片上写字。<br>当我缓缓睁开眼睛时，发现卡片上的字很陌生，简直不像出自我的手。决定用圆珠笔写这张卡片是正确的决定，从这些文字中，可以感受到花莲小姐的恭谨有礼和纯洁。我把写好的卡片装进信封。<br>晚上七点多，花莲小姐再度来到山茶文具店。看起来质料很好的深蓝色大衣和白色围巾在她身上很好看。<br>“我呈现了这样的感觉……”<br>我战战兢兢地递上卡片。花莲小姐一看到卡片，立刻欢呼起来。<br>“简直就像我自己写的！谢谢你！”<br>她像少女般兴奋不已。</p></blockquote><p>这就是典型的“少女字体”了，我影响里面，初中我的后桌还有高中一同学写的字就是这类型的</p><blockquote><p>“我一直想写这样的字。”</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1653622953005-24a78b92-4ed4-477d-8d79-8ce1638244e6.png#clientId=u086893de-fca6-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=579&id=u2e939874&margin=%5Bobject%20Object%5D&name=image.png&originHeight=781&originWidth=780&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=140286&status=done&style=none&taskId=ubeda167a-9822-414b-849d-4638a48ae18&title=&width=577.7778185934716" alt="image.png"></p><h2 id="冬"><a href="#冬" class="headerlink" title="冬"></a>冬</h2><p>等到以后，我的小屋门外也要种一棵大树</p><blockquote><p>据说山茶文具店门口的那棵山茶树，是用由比若宫的山茶树树枝扦插而来的。不知道是上代还是上上代，把被台风吹断的树枝带回家，试着种在家门口，没想到它竟牢牢地扎了根、长成了大树。</p></blockquote><p>她深深地爱着她父亲，激动且神秘……</p><blockquote><p>“所以她吵着要回去。看到她那样，我真的很难过，忍不住想象她总是背着年纪还小的我们去查看信箱的样子。我猜那是无法让我们姐弟看到的、秘密的爱。”</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1653626050743-85c10c68-abc6-4c21-9f53-bc5a8943e3a9.png#clientId=u086893de-fca6-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=573&id=VWBdz&margin=%5Bobject%20Object%5D&name=image.png&originHeight=774&originWidth=749&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=233550&status=done&style=none&taskId=u789d683a-cd44-4c78-a8e6-b4f401dbf0c&title=&width=554.8148540083464" alt="image.png"><br>人会成长，所写出的字也会有所成长，虽然不好说这个成长是朝着好的还是邋遢的，但，总归是成长</p><blockquote><p>一个人写的字会随着年岁增长渐渐成熟。即便是同一个人，小学时写的字，和高中时写的字当然不一样；二十多岁时所写的字，和四十多岁时所写的字也不一样。到了七八十岁，差异就更大了。就算是十几岁时写字圆滚滚的少女，变成老太太之后，当然也不会再写那样的字。文字，也会随着年龄变化。</p></blockquote><h2 id="春"><a href="#春" class="headerlink" title="春"></a>春</h2><p>代笔</p><blockquote><p>但我内心很犹豫，觉得是否该拒绝这个委托。代笔工作是为了协助他人得到幸福，这是我身为代笔人的坚持。更何况，有必要写伤害对方的信吗？然而，工作就是工作。从另一个角度思考，代笔人这份工作并不是做义工，眼前这位匿名小姐是客人，只要她高兴，那又何妨呢？两种完全相反的想法在内心天人交战，发出咔嚓咔嚓的声音。</p></blockquote><p>失去的是妻子，后悔所说过的话，可是，庆幸的是女儿还在身旁，妻子已不再人世……</p><blockquote><p>“与其苦苦追寻失去的东西，还不如好好珍惜自己眼前拥有的东西。”</p></blockquote><p>这个场景，和《世界上所有的夜晚》文末那个夜晚是同样的，夜景一样，思绪一样……</p><blockquote><p>小小的亮光穿越黑暗。是萤火虫。没错，每年都有萤火虫在这条河边飞舞。许多人都站在小桥上看萤火虫。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 阅读 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>任务执行机制（事件循环EventLoop）</title>
      <link href="/blog/lz7xgx/"/>
      <url>/blog/lz7xgx/</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1653573417541-44275572-06ee-41fc-ab54-6683e2510450.png#clientId=u6fbf61f2-52d8-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ude4d9e36&margin=%5Bobject%20Object%5D&originHeight=1112&originWidth=1960&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&taskId=u428e19bd-27dd-43cb-be8d-ec40ca5e940&title="></p><h2 id="理解-js-里面的任务执行机制"><a href="#理解-js-里面的任务执行机制" class="headerlink" title="理解 js 里面的任务执行机制"></a>理解 js 里面的任务执行机制</h2><p>相关概念</p><ul><li><input disabled="" type="checkbox"> 异步编程</li><li><input disabled="" type="checkbox"> Javascript 的事件循环</li><li><input disabled="" type="checkbox"> 任务队列</li><li><input disabled="" type="checkbox"> 微任务队列</li><li><input disabled="" type="checkbox"> ……</li></ul><p>以下代码执行的结果是什么？</p><pre><code class="javascript">console.log(1);setTimeout(function () &#123;  console.log(3);&#125;, 3000);console.log(2);</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616040077613-888913ee-a30f-453e-8ebf-c0fd62fde8ea.png#crop=0&crop=0&crop=1&crop=1&height=60&id=neUVv&margin=%5Bobject%20Object%5D&name=image.png&originHeight=119&originWidth=1014&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=5961&status=done&style=stroke&title=&width=507" alt="image.png"><br>以下代码执行的结果是什么？</p><pre><code class="javascript">console.log(1);setTimeout(function () &#123;  console.log(3);&#125;, 0);console.log(2);</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616040090596-2a14e894-a341-48a9-ba3e-71bbf0d66045.png#crop=0&crop=0&crop=1&crop=1&height=63&id=bnEfE&margin=%5Bobject%20Object%5D&name=image.png&originHeight=125&originWidth=1021&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=6181&status=done&style=stroke&title=&width=510.5" alt="image.png"></p><h3 id="啥是单线程"><a href="#啥是单线程" class="headerlink" title="啥是单线程"></a>啥是单线程</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518364671-590b3d5b-f91b-481d-9102-3e8caa4c6075.png#crop=0&crop=0&crop=1&crop=1&height=90&id=ZFI00&originHeight=90&originWidth=726&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&title=&width=726"><br>单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。如果前一个任务耗时很长，后一个任务就不得不一直等着。<br>这样所导致的问题是： 如果 JS 执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞的感觉。</p><h3 id="同步任务和异步任务"><a href="#同步任务和异步任务" class="headerlink" title="同步任务和异步任务"></a>同步任务和异步任务</h3><pre><code>单线程导致的问题就是后面的任务等待前面任务完成，如果前面任务很耗时（比如读取网络数据），后面任务不得不一直等待！！为了解决这个问题，利用多核 CPU 的计算能力，HTML5 提出 Web Worker 标准，允许 JavaScript 脚本创建多个线程，但是子线程完全受主线程控制。于是，JS 中出现了**同步任务**和**异步任务**。</code></pre><blockquote><p><img src="https://cdn.nlark.com/yuque/0/2021/gif/1484158/1622775361143-bbbae322-0d9e-4dff-bb5f-9c727a926563.gif#crop=0&crop=0&crop=1&crop=1&height=43&id=q4R2o&originHeight=43&originWidth=42&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&title=&width=42"><strong>操作系统忘完了</strong></p></blockquote><p>JS 中所有任务可以分成两种，一种是同步任务（synchronous），另一种是异步任务（asynchronous）。<br><strong>【同步任务】</strong>指的是：<br>在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务；<br><strong>【异步任务】</strong>指的是：<br>不进入主线程、而进入<strong>“任务队列”</strong>的任务，当主线程中的任务运行完了，才会从”任务队列”取出异步任务放入主线程执行。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518364776-7168ea9f-39dc-4395-9d07-0a72969f568d.png#crop=0&crop=0&crop=1&crop=1&height=432&id=uGzao&originHeight=432&originWidth=746&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=stroke&title=&width=746"></p><h3 id="JS-执行机制（事件循环）"><a href="#JS-执行机制（事件循环）" class="headerlink" title="JS 执行机制（事件循环）"></a>JS 执行机制（事件循环）</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518364833-4eb43c01-9779-4e8d-99a7-2f651cafb1b3.png#crop=0&crop=0&crop=1&crop=1&height=390&id=MDARJ&originHeight=390&originWidth=768&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=stroke&title=&width=768"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518364890-56fd3e4e-9faa-48d5-a69f-85f0d3bfec1f.png#crop=0&crop=0&crop=1&crop=1&height=379&id=nvj0H&originHeight=379&originWidth=819&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=stroke&title=&width=819"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518364949-71e82dea-e99d-4755-bb73-1c4d68acf4eb.png#crop=0&crop=0&crop=1&crop=1&height=44&id=mZ4Kh&originHeight=44&originWidth=838&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=stroke&title=&width=838"></p><blockquote><p>例子</p></blockquote><pre><code class="javascript">console.log(&quot;主线程：第一个&quot;);document.onclick = function () &#123;  console.log(&quot;点击事件开始&quot;);&#125;;setTimeout(function () &#123;  console.log(&quot;定时器3s&quot;);&#125;, 3000);setTimeout(function () &#123;  console.log(&quot;定时器1s&quot;);&#125;, 1000);console.log(&quot;主线程：最后一个&quot;);</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1622776526386-add5d6e7-7b7f-4e5c-98af-f9189c7282ca.png#crop=0&crop=0&crop=1&crop=1&height=232&id=u6ef71c6b&margin=%5Bobject%20Object%5D&name=image.png&originHeight=464&originWidth=796&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=129597&status=done&style=none&title=&width=398" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1622776561826-eb27e6c9-623e-4bc1-85b4-78ee987e86d5.png#crop=0&crop=0&crop=1&crop=1&height=113&id=u5336dfef&margin=%5Bobject%20Object%5D&name=image.png&originHeight=225&originWidth=922&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=36281&status=done&style=none&title=&width=461" alt="image.png"></p><h3 id="JS-创建异步任务枚举"><a href="#JS-创建异步任务枚举" class="headerlink" title="JS 创建异步任务枚举"></a>JS 创建异步任务枚举</h3><blockquote><p>参考：</p><ul><li><a href="https://juejin.cn/post/6844903832388894727">理解 JavaScript 概念系列–异步任务</a></li><li><a href="https://juejin.cn/post/6844903760280420366">JS 异步编程六种方案</a></li></ul></blockquote><h3 id="期约-Promise"><a href="#期约-Promise" class="headerlink" title="期约 Promise"></a>期约 Promise</h3><ul><li><a href="https://www.cnblogs.com/lvdabao/p/es6-promise-1.html">大白话讲解 Promise（一）</a></li></ul><h3 id="调用栈、消息队列、微任务队列"><a href="#调用栈、消息队列、微任务队列" class="headerlink" title="调用栈、消息队列、微任务队列"></a>调用栈、消息队列、微任务队列</h3><ul><li>调用栈：遇到函数调用就把函数压入栈内</li><li>消息队列（宏任务）：</li><li>微任务队列：</li></ul><p>Promise、Async、await 不是很理解<br>参考：</p><ul><li><a href="https://www.bilibili.com/video/BV1kf4y1U7Ln">https://www.bilibili.com/video/BV1kf4y1U7Ln</a></li><li><a href="https://juejin.cn/post/7050637649123475487">靠做题 📝 来掌握 Promise/async/await</a></li></ul><h3 id="综合测试题"><a href="#综合测试题" class="headerlink" title="综合测试题"></a>综合测试题</h3><pre><code class="javascript">async function a1() &#123;  console.log(&quot;a1 start&quot;);  await a2();  console.log(&quot;a1 end&quot;);&#125;async function a2() &#123;  console.log(&quot;a2&quot;);&#125;console.log(&quot;script start&quot;);setTimeout(() =&gt; &#123;  console.log(&quot;setTimeout&quot;);&#125;, 0);Promise.resolve().then(() =&gt; &#123;  console.log(&quot;promise1&quot;);&#125;);a1();let promise2 = new Promise((resolve) =&gt; &#123;  resolve(&quot;promise2.then&quot;);  console.log(&quot;promise2&quot;);&#125;);promise2.then((res) =&gt; &#123;  console.log(res);  Promise.resolve().then(() =&gt; &#123;    console.log(&quot;promise3&quot;);  &#125;);&#125;);console.log(&quot;script end&quot;);</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1651219112856-f0a4bb85-c46f-454f-93da-73eb1610e5b8.png#clientId=ub96a355b-a0dd-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=223&id=u4d8425df&margin=%5Bobject%20Object%5D&name=image.png&originHeight=268&originWidth=254&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=14026&status=done&style=none&taskId=uad773bd8-2262-4b11-88c0-89d9e2d1dab&title=&width=211.66665825578934" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> 👨‍💻Web开发 </category>
          
          <category> JavaScript+DOM+BOM+TS </category>
          
          <category> ECMAScript </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>客户端检测</title>
      <link href="/blog/gnyhrv/"/>
      <url>/blog/gnyhrv/</url>
      
        <content type="html"><![CDATA[<p>前言：用于客户端检测的工具函数记录</p><h3 id="是否为-IOS-设备"><a href="#是否为-IOS-设备" class="headerlink" title="是否为 IOS 设备"></a>是否为 IOS 设备</h3><pre><code class="javascript">let isIos = () =&gt; &#123;  var u = navigator.userAgent;  if (u.indexOf(&quot;Android&quot;) &gt; -1 || u.indexOf(&quot;Linux&quot;) &gt; -1) &#123;    //安卓手机    // return &quot;Android&quot;;    return false;  &#125; else if (u.indexOf(&quot;iPhone&quot;) &gt; -1) &#123;    //苹果手机    // return &quot;iPhone&quot;;    return true;  &#125; else if (u.indexOf(&quot;iPad&quot;) &gt; -1) &#123;    //iPad    // return &quot;iPad&quot;;    return false;  &#125; else if (u.indexOf(&quot;Windows Phone&quot;) &gt; -1) &#123;    //winphone手机    // return &quot;Windows Phone&quot;;    return false;  &#125; else &#123;    return false;  &#125;&#125;;</code></pre><h3 id="是否为-PC-设备"><a href="#是否为-PC-设备" class="headerlink" title="是否为 PC 设备"></a>是否为 PC 设备</h3><pre><code class="javascript">let isPC = () =&gt; &#123;  //是否为PC端  var userAgentInfo = navigator.userAgent;  var Agents = [    &quot;Android&quot;,    &quot;iPhone&quot;,    &quot;SymbianOS&quot;,    &quot;Windows Phone&quot;,    &quot;iPad&quot;,    &quot;iPod&quot;,  ];  var flag = true;  for (var v = 0; v &lt; Agents.length; v++) &#123;    if (userAgentInfo.indexOf(Agents[v]) &gt; 0) &#123;      flag = false;      break;    &#125;  &#125;  return flag;&#125;;</code></pre><h3 id="浏览器类型"><a href="#浏览器类型" class="headerlink" title="浏览器类型"></a>浏览器类型</h3><pre><code class="javascript">let browserType = () =&gt; &#123;  var userAgent = navigator.userAgent; //取得浏览器的userAgent字符串  var isOpera = userAgent.indexOf(&quot;Opera&quot;) &gt; -1; //判断是否Opera浏览器  var isIE =    userAgent.indexOf(&quot;compatible&quot;) &gt; -1 &amp;&amp;    userAgent.indexOf(&quot;MSIE&quot;) &gt; -1 &amp;&amp;    !isOpera; //判断是否IE浏览器  var isIE11 =    userAgent.indexOf(&quot;Trident&quot;) &gt; -1 &amp;&amp; userAgent.indexOf(&quot;rv:11.0&quot;) &gt; -1;  var isEdge = userAgent.indexOf(&quot;Edge&quot;) &gt; -1 &amp;&amp; !isIE; //判断是否IE的Edge浏览器  var isFF = userAgent.indexOf(&quot;Firefox&quot;) &gt; -1; //判断是否Firefox浏览器  var isSafari =    userAgent.indexOf(&quot;Safari&quot;) &gt; -1 &amp;&amp; userAgent.indexOf(&quot;Chrome&quot;) == -1; //判断是否Safari浏览器  var isChrome =    userAgent.indexOf(&quot;Chrome&quot;) &gt; -1 &amp;&amp; userAgent.indexOf(&quot;Safari&quot;) &gt; -1; //判断Chrome浏览器  if (isIE) &#123;    var reIE = new RegExp(&quot;MSIE (\\d+\\.\\d+);&quot;);    reIE.test(userAgent);    var fIEVersion = parseFloat(RegExp[&quot;$1&quot;]);    if (fIEVersion == 7) return &quot;IE7&quot;;    else if (fIEVersion == 8) return &quot;IE8&quot;;    else if (fIEVersion == 9) return &quot;IE9&quot;;    else if (fIEVersion == 10) return &quot;IE10&quot;;    else return &quot;IE7以下&quot;; //IE版本过低  &#125;  if (isIE11) return &quot;IE11&quot;;  if (isEdge) return &quot;Edge&quot;;  if (isFF) return &quot;FF&quot;;  if (isOpera) return &quot;Opera&quot;;  if (isSafari) return &quot;Safari&quot;;  if (isChrome) return &quot;Chrome&quot;;&#125;;</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1653026051837-a36a45e0-2b92-48d9-8b88-63c35e2babd2.png#clientId=u2fc1e41c-ac9f-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=76&id=ucbd2b3d7&margin=%5Bobject%20Object%5D&name=image.png&originHeight=91&originWidth=444&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=4065&status=done&style=none&taskId=ua4d9a4c9-4212-4b89-af70-8b6e8599f18&title=&width=369.99998529752156" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> 👨‍💻Web开发 </category>
          
          <category> JavaScript+DOM+BOM+TS </category>
          
          <category> BOM </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>小满随笔：故人叹物</title>
      <link href="/essay/avyy9v/"/>
      <url>/essay/avyy9v/</url>
      
        <content type="html"><![CDATA[<p><strong>物质</strong><br>我好像对物质没有太多的追求<br>努力一份好工作，也只是让自己不成为一个无能的人罢了<br>在家人朋友想要的时候，无能会让人变得无比遗憾<br>我不想让所有的不利因素都归咎于无能之下<br>没有太多的物质追求，只求爱我我爱的人过的开心就好</p><p><strong>相处</strong><br>用到理科的取反、就简、取极限原则<br>与人相处也可以定义成如何和你讨厌的人相处<br>懂得了这个<br>很多事情就变得明朗起来了</p><p><strong>成长</strong><br>很多时候，如果不是因为一件大事<br>一个人的成长确实是根据时间、环境来决定的<br>很多时候我就会想成长和成熟的区别<br>我的答案是：没有区别<br>也可以说成两者互为充要条件吧</p><p><strong>没有意义的事情</strong><br>如果你所做的所有事情都是没有意义的。<br>当你做了一些事情，到了一定时候<br>你发现<br>你曾经做过的所有事情<br>都是没有意义的<br>是多么的孤寂</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>原始值+引用值+浅拷贝+深拷贝</title>
      <link href="/blog/lwi9wr/"/>
      <url>/blog/lwi9wr/</url>
      
        <content type="html"><![CDATA[<h2 id="原始值和引用值"><a href="#原始值和引用值" class="headerlink" title="原始值和引用值"></a>原始值和引用值</h2><p>这里面 Java 和 JavaScript 都是只有引用的概念，但是在 C/C++里面，就有指针的概念<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1617868682681-90191ec3-c5b2-415f-9e38-df2706301e0c.png#crop=0&crop=0&crop=1&crop=1&height=173&id=dmTBK&margin=%5Bobject%20Object%5D&name=image.png&originHeight=346&originWidth=931&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=136387&status=done&style=stroke&title=&width=465.5" alt="image.png"></p><ul><li>原始值： <strong>存储在栈中的简单数据段</strong>，即他们的值直接存储在变量访问的位置。</li></ul><p>包括：undefined、null、boolean、number、string。</p><ul><li>引用值：<strong>存储在堆中的对象</strong>，即存储在变量处的值是一个指针，只想存储对象的内存处。</li></ul><p>包括：object、array、function 等</p><ul><li>两者的区别：</li></ul><p>原始变量及他们的值储存在栈中，当把一个原始变量传递给另一个原始变量时，是把一个栈房间的东西复制到另一个栈房间，且这两个原始变量互不影响。<strong>引用值是把引用变量的名称储存在栈中，但是把其实际对象储存在堆中</strong>，且存在一个指针由变量名指向储存在堆中的实际对象，当把引用对象传递给另一个变量时，复制的其实是指向实际对象的指针，此时两者指向的是同一个数据，若通过方法改变其中一个变量的值，则访问另一个变量时，其值也会随之加以改变；但若不是通过方法而是通过重新赋值，此时，相当于重新开了一个房间，该值的原指针改变，则另外一个值不会随他的改变而改变。</p><pre><code class="javascript">let s = &quot;基本类型&quot;;let s_test = s;s_test = &quot;改变之后不影响s&quot;;console.log(s);console.log(s_test);let arr = [&quot;原始数组值&quot;];arr_test = arr;arr_test[0] = &quot;改变值&quot;;console.log(arr);console.log(arr_test);//基本类型//改变之后不影响s//[ &#39;改变值&#39; ]//[ &#39;改变值&#39; ]</code></pre><ul><li>参考：<a href="https://blog.csdn.net/u012443286/article/details/79496742">谈谈 JavaScript 中的变量、指针和引用</a></li></ul><h2 id="深拷贝与浅拷贝"><a href="#深拷贝与浅拷贝" class="headerlink" title="深拷贝与浅拷贝"></a>深拷贝与浅拷贝</h2><h3 id="区分概念"><a href="#区分概念" class="headerlink" title="区分概念"></a>区分概念</h3><ul><li>浅拷贝：直接赋值，还是指向同一个堆</li><li>深拷贝：相当于重新创建一个对象，新开存储空间</li><li>参考：<a href="https://segmentfault.com/a/1190000016440069">js 浅拷贝与深拷贝方法</a></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1651305177480-c971984f-5aa2-48af-9d4b-3eee50afffee.png#clientId=u20944b5d-52c0-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u19a4acf0&margin=%5Bobject%20Object%5D&originHeight=219&originWidth=291&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&taskId=u266d5f95-2ac1-462b-a2dd-60227f98c77&title=">、</p><h3 id="浅拷贝实现"><a href="#浅拷贝实现" class="headerlink" title="浅拷贝实现"></a>浅拷贝实现</h3><ol><li>直接等号赋值</li></ol><pre><code class="javascript">let obj = &#123;  ss: &quot;ss&quot;,  hh: &quot;hh&quot;,&#125;;let obj_qian = obj;obj_qian.ss = &quot;sss&quot;;obj_qian.hh = &quot;hhh&quot;;console.log(obj); //&#123; ss: &#39;sss&#39;, hh: &#39;hhh&#39; &#125;console.log(obj_qian); //&#123; ss: &#39;sss&#39;, hh: &#39;hhh&#39; &#125;</code></pre><h3 id="深拷贝实现"><a href="#深拷贝实现" class="headerlink" title="深拷贝实现"></a>深拷贝实现</h3><ol><li>直接创建一个同类型的数据结构，然后将原值一个个复制过来（数组）</li><li>JSON 方法（对象）</li></ol><pre><code class="javascript">let obj = &#123;  ss: &quot;ss&quot;,  hh: &quot;hh&quot;,&#125;;let obj_shen_JSON = JSON.parse(JSON.stringify(obj));obj_shen_JSON.ss = &quot;sssss&quot;;obj_shen_JSON.hh = &quot;hhhhh&quot;;console.log(obj); //&#123; ss: &#39;ss&#39;, hh: &#39;hh&#39; &#125;console.log(obj_shen_JSON); // &#123; ss: &#39;sssss&#39;, hh: &#39;hhhhh&#39; &#125;</code></pre><h3 id="手写深拷贝"><a href="#手写深拷贝" class="headerlink" title="手写深拷贝"></a>手写深拷贝</h3><pre><code class="javascript">let clone = (target) =&gt; &#123;  if (typeof target === &quot;object&quot;) &#123;    let cloneTarget = Array.isArray(target) ? [] : &#123;&#125;;    for (const key in target) &#123;      cloneTarget[key] = clone(target[key]);    &#125;    return cloneTarget;  &#125; else &#123;    return target;  &#125;&#125;;let obj_1 = &#123;  c: &quot;c&quot;,  d: &#123;    d1: &quot;d1&quot;,    d2: &quot;d2&quot;,  &#125;,&#125;;let obj_my = clone(obj_1);obj_1.c = &quot;ccccccc&quot;;obj_1.d.d1 = &quot;dsdddddddd&quot;;console.log(obj_1);console.log(obj_my);</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1652416167805-60ef8c07-9bba-4d43-a2e2-349b986c3c35.png#clientId=u481d9d93-75a6-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=55&id=u1714696c&margin=%5Bobject%20Object%5D&name=image.png&originHeight=66&originWidth=545&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=12683&status=done&style=none&taskId=u8343e817-307c-4128-8299-a5473b77be4&title=&width=454.1666486197055" alt="image.png"></p><h3 id="Object-assign-obj"><a href="#Object-assign-obj" class="headerlink" title="Object.assign({}, obj)"></a>Object.assign({}, obj)</h3><ul><li><strong>assign 既可以是深拷贝，也可以是浅拷贝</strong></li><li>Object.assign() 方法用于将所有可枚举属性的值从一个或多个源对象分配到目标对象。它将返回目标对象。</li><li>对于 Object.assign()而言，如果对象的属性值为简单类型（string，number），通过 Object.assign({},srcobj);得到的新对象为深拷贝；如果属性值为对象或其他引用类型，那对于这个对象而言其实是浅拷贝的</li></ul><pre><code class="javascript">let obj = &#123;  a: &quot;a&quot;,  b: &quot;b&quot;,&#125;;let obj_deep = Object.assign(&#123;&#125;, obj);obj.a = &quot;aa&quot;;console.log(obj);console.log(obj_deep);console.log(&quot;--------------------------------&quot;);let obj_obj = &#123;  c: &quot;c&quot;,  d: &#123;    d1: &quot;d1&quot;,    d2: &quot;d2&quot;,  &#125;,&#125;;let obj_qian = Object.assign(&#123;&#125;, obj_obj);obj_obj.c = &quot;cc&quot;;obj_obj.d.d1 = &quot;d1111&quot;;console.log(obj_obj);console.log(obj_qian);</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1652415857368-38e9203a-1178-4fc4-b53d-a6059c212ad0.png#clientId=u481d9d93-75a6-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=102&id=u6b2eae5b&margin=%5Bobject%20Object%5D&name=image.png&originHeight=122&originWidth=506&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=18908&status=done&style=none&taskId=ub0c10380-e6fb-4416-902b-2b6d02919d8&title=&width=421.6666499111394" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> 👨‍💻Web开发 </category>
          
          <category> JavaScript+DOM+BOM+TS </category>
          
          <category> ECMAScript </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>442. 数组中重复的数据🔖数组🔖哈希表</title>
      <link href="/blog/cp993p/"/>
      <url>/blog/cp993p/</url>
      
        <content type="html"><![CDATA[<ul><li><a href="https://leetcode-cn.com/problems/find-all-duplicates-in-an-array/">https://leetcode-cn.com/problems/find-all-duplicates-in-an-array/</a></li></ul><h3 id="暴力解法"><a href="#暴力解法" class="headerlink" title="暴力解法"></a>暴力解法</h3><pre><code class="javascript">/** * @param &#123;number[]&#125; nums * @return &#123;number[]&#125; */var findDuplicates = function (nums) &#123;  let arr = [];  let result = [];  nums.forEach((data) =&gt; &#123;    arr.includes(data) ? result.push(data) : arr.push(data);  &#125;);  return result;&#125;;</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1652015297299-44ac1ea9-f775-483d-b762-d57c71ff32c9.png#clientId=u0e5e373a-3004-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=330&id=u730a2960&margin=%5Bobject%20Object%5D&name=image.png&originHeight=396&originWidth=756&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=31972&status=done&style=none&taskId=uc9e91118-2e56-4dd0-8a3b-949623b19cc&title=&width=629.9999749660502" alt="image.png"></p><h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><pre><code class="javascript">/** * @param &#123;number[]&#125; nums * @return &#123;number[]&#125; */var findDuplicates = function (nums) &#123;  const map = new Map();  const arr = [];  for (let i = 0; i &lt; nums.length; i++) &#123;    if (map.has(nums[i])) &#123;      arr.push(nums[i]);      map.delete(nums[i]);    &#125; else &#123;      map.set(nums[i]);    &#125;  &#125;  return arr;&#125;;</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1652015256459-e3d10aa5-79a4-4ea5-b8c2-edb2ffd6abe1.png#clientId=u0e5e373a-3004-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=327&id=ue83dc54e&margin=%5Bobject%20Object%5D&name=image.png&originHeight=392&originWidth=752&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=31583&status=done&style=none&taskId=u210c9c7b-fec6-4817-bf0c-ad9160f7d04&title=&width=626.6666417651716" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 📶线结构：字符串-数组-栈-队列 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>人鬼如梦</title>
      <link href="/essay/otaot9/"/>
      <url>/essay/otaot9/</url>
      
        <content type="html"><![CDATA[<p>不知什么时候，我特别喜欢梦这个意象<br>人鬼殊途，却是美好的意境<br>醒来一无所有<br>我宁愿生活一个小小梦里面，快乐纯真的守护<br>只守护，不求功与名<br>只愿守护所爱<br>人鬼殊途，却也美好梦一场<br><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/1484158/1651989959347-a078aca1-56b2-4421-a8cd-8e10516c166f.jpeg#clientId=u0d70cdf1-31ef-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=uef1688dd&margin=%5Bobject%20Object%5D&name=Sandman_-_The_Dream_Hunters_p000a-000b.jpg&originHeight=1530&originWidth=1950&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=141664&status=done&style=none&taskId=u6266398d-872b-4021-80ab-3dd928c71ff&title=" alt="Sandman_-_The_Dream_Hunters_p000a-000b.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 异世界 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>1823. 找出游戏的获胜者🔖递归</title>
      <link href="/blog/ucz0sz/"/>
      <url>/blog/ucz0sz/</url>
      
        <content type="html"><![CDATA[<ul><li><a href="https://leetcode-cn.com/problems/find-the-winner-of-the-circular-game/">https://leetcode-cn.com/problems/find-the-winner-of-the-circular-game/</a></li></ul><p>其中 12 行代码是根据数学找规律得出来的（滑稽</p><p>感觉这个题目还有用循环链表，队列啥的写，但是力扣我至今还不知道他有没有预设这些 js 不内置的数据结构，一直都是题目有啥用啥……</p><pre><code class="javascript">/** * @param &#123;number&#125; n * @param &#123;number&#125; k * @return &#123;number&#125; */var findTheWinner = function (n, k) &#123;  let arr = [];  for (let i = 0; i &lt; n; i++) arr.push(i + 1);  let searchP = (arr, k, pre) =&gt; &#123;    if (arr.length &gt; 1) &#123;      pre = k + pre - 1;      while (pre &gt; arr.length - 1) pre = pre - arr.length;      arr.splice(pre, 1);      searchP(arr, k, pre);    &#125;  &#125;;  searchP(arr, k, 0);  return arr[0];&#125;;</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1651647527838-774b7fe0-fbba-44d7-8fa2-b7a1af828bdb.png#clientId=u4de436df-9b58-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=378&id=u874494ca&margin=%5Bobject%20Object%5D&name=image.png&originHeight=454&originWidth=805&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=36195&status=done&style=none&taskId=u9f0d56c9-9bbf-4b97-b42d-beb0696c37d&title=&width=670.8333066768128" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 🌌递归算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>905. 按奇偶排序数组🔖数组</title>
      <link href="/blog/sp649k/"/>
      <url>/blog/sp649k/</url>
      
        <content type="html"><![CDATA[<ul><li><a href="https://leetcode-cn.com/problems/sort-array-by-parity/">https://leetcode-cn.com/problems/sort-array-by-parity/</a></li></ul><p>暴力解法</p><pre><code class="javascript">/** * @param &#123;number[]&#125; nums * @return &#123;number[]&#125; */var sortArrayByParity = function (nums) &#123;  let arr = [];  nums.forEach((data) =&gt; &#123;    data % 2 === 0 ? arr.unshift(data) : arr.push(data);  &#125;);  return arr;&#125;;</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1651567846491-0c978678-9a40-4ee4-b77b-22dc5284ef37.png#clientId=u067b7a56-ce9c-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=326&id=ubb08a31d&margin=%5Bobject%20Object%5D&name=image.png&originHeight=391&originWidth=741&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=32895&status=done&style=none&taskId=u190d95fb-a305-4671-9370-bf586378667&title=&width=617.4999754627555" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 📶线结构：字符串-数组-栈-队列 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>908. 最小差值 I🔖数组</title>
      <link href="/blog/vmdef7/"/>
      <url>/blog/vmdef7/</url>
      
        <content type="html"><![CDATA[<ul><li><a href="https://leetcode-cn.com/problems/smallest-range-i/">https://leetcode-cn.com/problems/smallest-range-i/</a></li></ul><p>主要分析出规律就好解了</p><ul><li>对第一个和最后一个元素进行相减比较</li><li>去重</li></ul><pre><code class="javascript">/** * @param &#123;number[]&#125; nums * @param &#123;number&#125; k * @return &#123;number&#125; */var smallestRangeI = function (nums, k) &#123;  let arr = Array.from(    new Set(      nums.sort((a, b) =&gt; &#123;        return a - b;      &#125;)    )  );  if (arr.length === 1) return 0;  return arr[arr.length - 1] - arr[0] - 2 * k &lt;= 0    ? 0    : arr[arr.length - 1] - arr[0] - 2 * k;&#125;;</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1652015419001-5fb4bfd2-befa-43a7-a309-2962b8d2fee1.png#clientId=u91d1e96c-ccff-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=330&id=u9619e698&margin=%5Bobject%20Object%5D&name=image.png&originHeight=396&originWidth=750&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=32140&status=done&style=none&taskId=u58bd3e04-c07d-48f6-86bb-8c5e1945150&title=&width=624.9999751647323" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 📶线结构：字符串-数组-栈-队列 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>1305. 两棵二叉搜索树中的所有元素🔖DFS🔖数组</title>
      <link href="/blog/rxfz11/"/>
      <url>/blog/rxfz11/</url>
      
        <content type="html"><![CDATA[<ul><li><a href="https://leetcode-cn.com/problems/all-elements-in-two-binary-search-trees/">https://leetcode-cn.com/problems/all-elements-in-two-binary-search-trees/</a></li></ul><pre><code class="javascript">/** * Definition for a binary tree node. * function TreeNode(val, left, right) &#123; *     this.val = (val===undefined ? 0 : val) *     this.left = (left===undefined ? null : left) *     this.right = (right===undefined ? null : right) * &#125; *//** * @param &#123;TreeNode&#125; root1 * @param &#123;TreeNode&#125; root2 * @return &#123;number[]&#125; */var getAllElements = function (root1, root2) &#123;  let arr_left = [];  let arr_right = [];  let dfs = (data, arr) =&gt; &#123;    if (data) &#123;      dfs(data.left, arr);      dfs(data.right, arr);      arr.push(data.val);    &#125;  &#125;;  dfs(root1, arr_left);  dfs(root2, arr_right);  return arr_left.concat(arr_right).sort((a, b) =&gt; &#123;    return a - b;  &#125;);&#125;;</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1651564651594-33c9e8d9-889d-4560-858a-8d9f15021e99.png#clientId=u93a79d33-2709-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=332&id=u429a9901&margin=%5Bobject%20Object%5D&name=image.png&originHeight=399&originWidth=763&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=35423&status=done&style=none&taskId=u4a06de28-468e-42be-b859-72939a71fae&title=&width=635.8333080675877" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 🌲树结构：二叉树-哈夫曼树 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>3. 无重复字符的最长子串</title>
      <link href="/blog/sutafh/"/>
      <url>/blog/sutafh/</url>
      
        <content type="html"><![CDATA[<ul><li><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/">https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/</a></li></ul><p>暴力解法</p><pre><code class="javascript">/** * @param &#123;string&#125; s * @return &#123;number&#125; */var lengthOfLongestSubstring = function (s) &#123;  let result = 1;  if (s.length === 0) return 0;  if (s.length === 1) return 1;  for (let i = 0; i &lt; s.length - 1; i++) &#123;    for (let j = i + 1; j &lt; s.length; j++) &#123;      let arr = s.substr(i, j - i + 1).split(&quot;&quot;);      let set = new Set(arr);      if (arr.length !== [...set].length) &#123;        break;      &#125; else &#123;        result = result &gt;= arr.length ? result : arr.length;      &#125;    &#125;  &#125;  return result;&#125;;</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1651544911564-558d66b8-bbf2-4a53-9afe-c3c92e0b8051.png#clientId=u625ddfd4-a9dc-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=333&id=uf5f7c443&margin=%5Bobject%20Object%5D&name=image.png&originHeight=400&originWidth=762&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=32831&status=done&style=none&taskId=ue91987ae-b98b-407b-a9ea-ba3b31c5d0b&title=&width=634.999974767368" alt="image.png"><br>这个结果太拉跨了……<br><strong>todo：滑动窗口</strong></p>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 🥢KMP类算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>n级阶梯1步2步走问题</title>
      <link href="/blog/ik7g6a/"/>
      <url>/blog/ik7g6a/</url>
      
        <content type="html"><![CDATA[<p>题目：一个长阶梯有 n 级，可以一次走 1 级，一次走 2 级，一共有多少种走法？</p><p>经典的动态规划问题，从结果来看：</p><ul><li>到达第 n 层阶梯的方式只有两种，走一步然后结束，或者走两步然后结束。</li><li>到达第 n-1 层阶梯的方式只有两种，走一步然后结束，或者走两步然后结束。</li><li>……</li></ul><p>抽离于动态规划模型，动态规划解题主要是解决两点（一般难题也就从这两个点来设置）</p><ol><li>动态方程</li><li>边界条件</li></ol><pre><code class="javascript">let arr = new Array(n).fill(0);// 边界条件arr[0] = 1;arr[1] = 2;for (let i = 2; i &lt; arr.length; i++) &#123;  // 动态方程  arr[i] = arr[i - 1] + arr[i - 2];&#125;console.log(arr[n - 1]);</code></pre><p>还可以用递归（不建议用，复杂度太高指数级，但是因为和递归看起来有点像，所以写出来作为比较）</p><pre><code class="javascript">let jie = (n) =&gt; &#123;  if (n === 1) return 1;  if (n === 2) return 2;  if (n &gt; 2) return jie(n - 1) + jie(n - 2);&#125;;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 🔢动态规划算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>todo：63. 不同路径 II🔖DP</title>
      <link href="/blog/hny8e9/"/>
      <url>/blog/hny8e9/</url>
      
        <content type="html"><![CDATA[<ul><li><a href="https://leetcode-cn.com/problems/unique-paths-ii/solution/">https://leetcode-cn.com/problems/unique-paths-ii/solution/</a></li></ul><div style="background: #FFF3F3;padding:10px;border: 1px solid #DEB8BE;border-radius:5px;margin-bottom:5px;">代码还没有完成<ul><li><input checked="" disabled="" type="checkbox"> 动态方程</li><li><input disabled="" type="checkbox"> 边界情况：<strong>对于目标位置 arr[m-1][n-1]的周围被围绕这个边界情况遗漏了</strong>。</div></li></ul><pre><code class="javascript">/** * @param &#123;number[][]&#125; obstacleGrid * @return &#123;number&#125; */var uniquePathsWithObstacles = function (obstacleGrid) &#123;  let m = obstacleGrid.length;  let n = obstacleGrid[0].length;  if (m === 1 &amp;&amp; n === 1) return obstacleGrid[0][0] === 0 ? 1 : 0;  if (m === 1) return obstacleGrid[0].includes(1) ? 0 : 1;  if (n === 1) &#123;    for (let i = 0; i &lt; m; i++) &#123;      if (obstacleGrid[i][0] === 1) return 0;    &#125;  &#125;  if (obstacleGrid[0][0] === 1 || obstacleGrid[m - 1][n - 1] === 1) return 0;  for (let i = 0; i &lt; m; i++)    obstacleGrid[i][0] = obstacleGrid[i][0] === 0 ? 1 : 0;  for (let i = 0; i &lt; n; i++)    obstacleGrid[0][i] = obstacleGrid[0][i] === 0 ? 1 : 0;  for (let i = 1; i &lt; m; i++) &#123;    for (let j = 1; j &lt; n; j++) &#123;      obstacleGrid[i][j] === 1        ? (obstacleGrid[i][j] = 0)        : (obstacleGrid[i][j] =            obstacleGrid[i - 1][j] + obstacleGrid[i][j - 1]);    &#125;  &#125;  return obstacleGrid[m - 1][n - 1];&#125;;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 🔢动态规划算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>62. 不同路径🔖DP</title>
      <link href="/blog/lc1dfa/"/>
      <url>/blog/lc1dfa/</url>
      
        <content type="html"><![CDATA[<ul><li><a href="https://leetcode-cn.com/problems/unique-paths/">https://leetcode-cn.com/problems/unique-paths/</a></li></ul><p>动态规划题目需要找到两点：</p><ul><li><strong>动态方程：动态方程抽离问题的共同解决方程</strong></li><li><strong>边界情况：相当于对于上述动态方程的特殊情况的枚举</strong></li></ul><pre><code class="javascript">/** * @param &#123;number&#125; m * @param &#123;number&#125; n * @return &#123;number&#125; */var uniquePaths = function (m, n) &#123;  let arr = new Array(m).fill(0).map(() =&gt; new Array(n).fill(0));  // 边界情况  for (let i = 0; i &lt; m; i++) arr[i][0] = 1;  for (let i = 0; i &lt; n; i++) arr[0][i] = 1;  // 动态方程  for (let i = 1; i &lt; m; i++) &#123;    for (let j = 1; j &lt; n; j++) &#123;      arr[i][j] = arr[i - 1][j] + arr[i][j - 1];    &#125;  &#125;  return arr[m - 1][n - 1];&#125;;</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1652015457078-4895e20f-7f29-463d-aaa7-97715d3dcd54.png#clientId=ue0d6dd3b-e268-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=325&id=u516534aa&margin=%5Bobject%20Object%5D&name=image.png&originHeight=390&originWidth=754&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=31857&status=done&style=none&taskId=ucbe966fc-a7f7-48f4-8ba4-050a4017be1&title=&width=628.333308365611" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 🔢动态规划算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>112. 路径总和🔖DFS</title>
      <link href="/blog/alrzw2/"/>
      <url>/blog/alrzw2/</url>
      
        <content type="html"><![CDATA[<ul><li><a href="https://leetcode-cn.com/problems/path-sum/">https://leetcode-cn.com/problems/path-sum/</a></li></ul><pre><code class="javascript">/** * Definition for a binary tree node. * function TreeNode(val, left, right) &#123; *     this.val = (val===undefined ? 0 : val) *     this.left = (left===undefined ? null : left) *     this.right = (right===undefined ? null : right) * &#125; *//** * @param &#123;TreeNode&#125; root * @param &#123;number&#125; targetSum * @return &#123;boolean&#125; */var hasPathSum = function (root, targetSum) &#123;  let result = false;  let dfs = (data, presum, tar) =&gt; &#123;    if (data) &#123;      presum = data.val + presum;      if (!data.left &amp;&amp; !data.right) &#123;        if (presum == tar) &#123;          result = true;        &#125;      &#125;      dfs(data.left, presum, tar);      dfs(data.right, presum, tar);    &#125;  &#125;;  dfs(root, 0, targetSum);  return result;&#125;;</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1651412804694-76d5dacc-2cbe-4170-a04f-4af28bfa1d6f.png#clientId=u7d8defa7-9a26-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=335&id=ud5bb75fc&margin=%5Bobject%20Object%5D&name=image.png&originHeight=402&originWidth=864&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=36733&status=done&style=none&taskId=u9f19be97-f7cb-4c74-a58b-462a5966a1f&title=&width=719.9999713897716" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 🌲树结构：二叉树-哈夫曼树 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>100. 相同的树🔖BFS🔖DFS</title>
      <link href="/blog/imt8ld/"/>
      <url>/blog/imt8ld/</url>
      
        <content type="html"><![CDATA[<ul><li><a href="https://leetcode-cn.com/problems/same-tree/">https://leetcode-cn.com/problems/same-tree/</a></li></ul><h3 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h3><pre><code class="javascript">/** * Definition for a binary tree node. * function TreeNode(val, left, right) &#123; *     this.val = (val===undefined ? 0 : val) *     this.left = (left===undefined ? null : left) *     this.right = (right===undefined ? null : right) * &#125; *//** * @param &#123;TreeNode&#125; p * @param &#123;TreeNode&#125; q * @return &#123;boolean&#125; */var isSameTree = function (p, q) &#123;  if (p === null &amp;&amp; q === null) return true;  if (p === null || q === null) return false;  let que_1 = [p];  let que_2 = [q];  while (que_1.length !== 0) &#123;    let que_1_size = que_1.length;    let que_2_size = que_2.length;    if (que_1_size !== que_2_size) return false;    for (let i = 0; i &lt; que_1_size; i++) &#123;      let mp1 = que_1.shift();      let mp2 = que_2.shift();      if (mp1.val !== mp2.val) return false;      if (mp1.left &amp;&amp; mp2.left) &#123;        que_1.push(mp1.left);        que_2.push(mp2.left);      &#125; else if (!mp1.left &amp;&amp; !mp2.left) &#123;      &#125; else &#123;        return false;      &#125;      if (mp1.right &amp;&amp; mp2.right) &#123;        que_1.push(mp1.right);        que_2.push(mp2.right);      &#125; else if (!mp1.right &amp;&amp; !mp2.right) &#123;      &#125; else &#123;        return false;      &#125;    &#125;  &#125;  return true;&#125;;</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1652015502900-ce25f41b-27ba-42d1-aba5-574187e8e2b8.png#clientId=ufa0d0cd9-e2f6-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=326&id=u588d5535&margin=%5Bobject%20Object%5D&name=image.png&originHeight=391&originWidth=757&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=32145&status=done&style=none&taskId=u34e6af19-c621-4f1c-bde9-97ad8d24b68&title=&width=630.8333082662698" alt="image.png"></p><h3 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h3><p>肝不动了，直接暴力 run ok 就行</p><pre><code class="javascript">/** * Definition for a binary tree node. * function TreeNode(val, left, right) &#123; *     this.val = (val===undefined ? 0 : val) *     this.left = (left===undefined ? null : left) *     this.right = (right===undefined ? null : right) * &#125; *//** * @param &#123;TreeNode&#125; p * @param &#123;TreeNode&#125; q * @return &#123;boolean&#125; */var isSameTree = function (p, q) &#123;  let result = true;  if (p === null &amp;&amp; q === null) return result;  if (p === null || q === null) return !result;  let arr_1 = [];  let arr_2 = [];  let dfs = (data, arr) =&gt; &#123;    if (data) &#123;      arr.push(data.val);      if (data.left) &#123;        dfs(data.left, arr);      &#125; else &#123;        arr.push(99999);      &#125;      if (data.right) &#123;        dfs(data.right, arr);      &#125; else &#123;        arr.push(99999);      &#125;    &#125;  &#125;;  dfs(p, arr_1);  dfs(q, arr_2);  if (arr_1.length !== arr_2.length) result = false;  arr_1.forEach((data, index) =&gt; &#123;    if (data !== arr_2[index]) &#123;      result = false;    &#125;  &#125;);  return result;&#125;;</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1652015520028-ccb54006-a5de-4448-8501-d6570716c111.png#clientId=ufa0d0cd9-e2f6-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=328&id=u4ffec31d&margin=%5Bobject%20Object%5D&name=image.png&originHeight=394&originWidth=764&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=32195&status=done&style=none&taskId=uc6cafdb2-72e5-4efb-9365-fa6e3f7bd74&title=&width=636.6666413678073" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 🌲树结构：二叉树-哈夫曼树 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>102. 二叉树的层序遍历🔖BFS</title>
      <link href="/blog/by7bg0/"/>
      <url>/blog/by7bg0/</url>
      
        <content type="html"><![CDATA[<ul><li><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/">https://leetcode-cn.com/problems/binary-tree-level-order-traversal/</a></li></ul><p>广度优先搜索</p><pre><code class="javascript">/** * Definition for a binary tree node. * function TreeNode(val, left, right) &#123; *     this.val = (val===undefined ? 0 : val) *     this.left = (left===undefined ? null : left) *     this.right = (right===undefined ? null : right) * &#125; *//** * @param &#123;TreeNode&#125; root * @return &#123;number[][]&#125; */var levelOrder = function (root) &#123;  if (!root) return [];  let result = [];  let que = [];  que.push(root);  while (que.length !== 0) &#123;    let init_size = que.length;    let temp = [];    for (let i = 0; i &lt; init_size; i++) &#123;      let mp = que.shift();      if (mp.left) que.push(mp.left);      if (mp.right) que.push(mp.right);      temp.push(mp.val);    &#125;    result.push(temp);  &#125;  return result;&#125;;</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1652015568860-91161da1-00e3-41d8-9024-9d860fa22e9c.png#clientId=ua24b5efe-8761-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=327&id=ucd610f2e&margin=%5Bobject%20Object%5D&name=image.png&originHeight=393&originWidth=757&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=32792&status=done&style=none&taskId=u1e2015be-c6fb-4d29-b0d1-243c206c7f4&title=&width=630.8333082662698" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 🌲树结构：二叉树-哈夫曼树 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>129. 求根节点到叶节点数字之和🔖DFS</title>
      <link href="/blog/thy7mx/"/>
      <url>/blog/thy7mx/</url>
      
        <content type="html"><![CDATA[<ul><li><a href="https://leetcode-cn.com/problems/sum-root-to-leaf-numbers/">https://leetcode-cn.com/problems/sum-root-to-leaf-numbers/</a></li></ul><h3 id="dfs"><a href="#dfs" class="headerlink" title="dfs"></a>dfs</h3><pre><code class="javascript">/** * Definition for a binary tree node. * function TreeNode(val, left, right) &#123; *     this.val = (val===undefined ? 0 : val) *     this.left = (left===undefined ? null : left) *     this.right = (right===undefined ? null : right) * &#125; *//** * @param &#123;TreeNode&#125; root * @return &#123;number&#125; */var sumNumbers = function (root) &#123;  if (!root) return root;  let arr = [];  let result = 0;  let dfs = (data, presum) =&gt; &#123;    if (data) &#123;      presum = data.val + presum * 10;      if (!data.left &amp;&amp; !data.right) arr.push(presum);      else &#123;        dfs(data.left, presum);        dfs(data.right, presum);      &#125;    &#125;  &#125;;  dfs(root, 0);  result = arr.reduce((a, b) =&gt; &#123;    return a + b;  &#125;);  return result;&#125;;</code></pre><p>优化一下得到：</p><pre><code class="javascript">/** * Definition for a binary tree node. * function TreeNode(val, left, right) &#123; *     this.val = (val===undefined ? 0 : val) *     this.left = (left===undefined ? null : left) *     this.right = (right===undefined ? null : right) * &#125; *//** * @param &#123;TreeNode&#125; root * @return &#123;number&#125; */var sumNumbers = function (root) &#123;  let dfs = (data, presum) =&gt; &#123;    if (data === null) return 0;    presum = data.val + presum * 10;    if (!data.left &amp;&amp; !data.right) &#123;      return presum;    &#125;    return dfs(data.left, presum) + dfs(data.right, presum);  &#125;;  return dfs(root, 0);&#125;;</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1652015642635-9c156952-829a-4fe0-9659-13773d03152d.png#clientId=u1dc26e3d-6ef0-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=322&id=u5238ad6b&margin=%5Bobject%20Object%5D&name=image.png&originHeight=387&originWidth=745&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=31640&status=done&style=none&taskId=ua935f1a8-bce3-4491-8eff-6c283daaa28&title=&width=620.8333086636342" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 🌲树结构：二叉树-哈夫曼树 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>222. 完全二叉树的节点个数🔖DFS</title>
      <link href="/blog/ktp9xg/"/>
      <url>/blog/ktp9xg/</url>
      
        <content type="html"><![CDATA[<ul><li><a href="https://leetcode-cn.com/problems/count-complete-tree-nodes/">https://leetcode-cn.com/problems/count-complete-tree-nodes/</a></li></ul><p>思路：<br>通法就是递归，其他方法暂不考虑</p><pre><code class="javascript">/** * Definition for a binary tree node. * function TreeNode(val, left, right) &#123; *     this.val = (val===undefined ? 0 : val) *     this.left = (left===undefined ? null : left) *     this.right = (right===undefined ? null : right) * &#125; *//** * @param &#123;TreeNode&#125; root * @return &#123;number&#125; */var countNodes = function (root) &#123;  let result = 0;  let nodes = (data) =&gt; &#123;    if (data) &#123;      nodes(data.left);      nodes(data.right);      result++;    &#125;  &#125;;  nodes(root);  return result;&#125;;</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1652015619370-5b367d0f-0a6d-4017-92cd-d370355d74bc.png#clientId=udbadcd50-b0d3-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=325&id=ud7655360&margin=%5Bobject%20Object%5D&name=image.png&originHeight=390&originWidth=754&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=32874&status=done&style=none&taskId=ubb3a6654-a034-47c1-abc1-e19d9326cc4&title=&width=628.333308365611" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 🌲树结构：二叉树-哈夫曼树 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>922. 按奇偶排序数组 II🔖暴力</title>
      <link href="/blog/hfqwr9/"/>
      <url>/blog/hfqwr9/</url>
      
        <content type="html"><![CDATA[<ul><li><a href="https://leetcode-cn.com/problems/sort-array-by-parity-ii/">https://leetcode-cn.com/problems/sort-array-by-parity-ii/</a></li></ul><p>思路：我特喵的直接暴力解法</p><pre><code class="javascript">/** * @param &#123;number[]&#125; nums * @return &#123;number[]&#125; */var sortArrayByParityII = function (nums) &#123;  let arr = [];  let arr_ou = [];  let arr_ji = [];  nums.forEach((data) =&gt; &#123;    data % 2 === 0 ? arr_ou.push(data) : arr_ji.push(data);  &#125;);  for (let i = 0; i &lt; arr_ji.length; i++) &#123;    arr[i * 2] = arr_ou[i];    arr[i * 2 + 1] = arr_ji[i];  &#125;  return arr;&#125;;</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1651392122716-c4681176-5009-40b5-958f-e5221988a605.png#clientId=uec560318-7733-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=285&id=u4d6b42ad&margin=%5Bobject%20Object%5D&name=image.png&originHeight=342&originWidth=797&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=33355&status=done&style=none&taskId=u38dde95d-1d48-4112-b79b-382c2b2e0fd&title=&width=664.1666402750556" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 📊查找排序算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>164. 最大间距🔖排序🔖array.sort🔖冒泡排序</title>
      <link href="/blog/szmcwf/"/>
      <url>/blog/szmcwf/</url>
      
        <content type="html"><![CDATA[<ul><li><a href="https://leetcode-cn.com/problems/maximum-gap/">https://leetcode-cn.com/problems/maximum-gap/</a></li></ul><h3 id="array-sort"><a href="#array-sort" class="headerlink" title="array.sort"></a>array.sort</h3><pre><code class="javascript">/** * @param &#123;number[]&#125; nums * @return &#123;number&#125; */var maximumGap = function (nums) &#123;  let result = 0;  if (nums.length &lt; 2) return result;  nums    .sort((a, b) =&gt; &#123;      return a - b;    &#125;)    .forEach((data, index) =&gt; &#123;      if (index &lt; nums.length - 1) &#123;        result =          result &gt; nums[index + 1] - data ? result : nums[index + 1] - data;      &#125;    &#125;);  return result;&#125;;</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1651388338749-eedd3c62-5fa2-47c1-b44d-76a007fe023f.png#clientId=u28e0d505-a44f-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=195&id=u4ad07262&margin=%5Bobject%20Object%5D&name=image.png&originHeight=234&originWidth=749&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=27522&status=done&style=none&taskId=u11a0efa2-d79a-4cf5-bf82-d60f264327f&title=&width=624.1666418645127" alt="image.png"></p><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>也可以利用冒泡排序，在最后两项排完，比较差值然后与 result 对比</p>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 📊查找排序算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>148. 排序链表🔖链表🔖js初始化单链表</title>
      <link href="/blog/cput4h/"/>
      <url>/blog/cput4h/</url>
      
        <content type="html"><![CDATA[<h3 id="148-排序链表"><a href="#148-排序链表" class="headerlink" title="148. 排序链表"></a>148. 排序链表</h3><ul><li><a href="https://leetcode-cn.com/problems/sort-list/">https://leetcode-cn.com/problems/sort-list/</a></li></ul><pre><code class="javascript">/** * Definition for singly-linked list. * function ListNode(val, next) &#123; *     this.val = (val===undefined ? 0 : val) *     this.next = (next===undefined ? null : next) * &#125; *//** * @param &#123;ListNode&#125; head * @return &#123;ListNode&#125; */var sortList = function (head) &#123;  if (head === null) return head;  let arr = [];  while (head !== null) &#123;    arr.push(head.val);    head = head.next;  &#125;  let result = arr.sort((a, b) =&gt; &#123;    return a - b;  &#125;);  let result_head = new ListNode(result[0], null);  let test = result_head;  result.forEach((data, index) =&gt; &#123;    if (index !== 0) &#123;      let temp = new ListNode(data, null);      test.next = temp;      test = temp;    &#125;  &#125;);  return result_head;&#125;;</code></pre><h3 id="js-初始化单链表"><a href="#js-初始化单链表" class="headerlink" title="js 初始化单链表"></a>js 初始化单链表</h3><pre><code class="javascript">// 节点class Node &#123;  constructor(value) &#123;    this.val = value;    this.next = null;  &#125;&#125;// 利用数组来初始化单链表class NodeList &#123;  constructor(arr) &#123;    let head = new Node(arr.shift());    let next = head;    arr.forEach((data) =&gt; &#123;      next.next = new Node(data);      next = next.next;    &#125;);    return head;  &#125;&#125;let test = new NodeList([1, 2, 3, 4]);while (test !== null) &#123;  console.log(test.val);  test = test.next;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 📎线结构：链表 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>集成ESLint和Prettier代码校验格式化环境（npm包和vscode插件）</title>
      <link href="/blog/mkn98t/"/>
      <url>/blog/mkn98t/</url>
      
        <content type="html"><![CDATA[<p>搞清楚这些逻辑<br>vscode eslint prettier vue eslint-config-prettier<br><a href="https://github.com/wztlink1013/plan/blob/main/package.json">https://github.com/wztlink1013/plan/blob/main/package.json</a></p><h2 id="vscode-插件"><a href="#vscode-插件" class="headerlink" title="vscode 插件"></a>vscode 插件</h2><h3 id="ESLint"><a href="#ESLint" class="headerlink" title="ESLint"></a>ESLint</h3><p>格式化检测工具：会给出警告抑或是报错，但不会修改</p><h3 id="Prettier-Code-formatter"><a href="#Prettier-Code-formatter" class="headerlink" title="Prettier - Code formatter"></a>Prettier - Code formatter</h3><p>代码格式化插件：按照所需配置直接格式化代码</p><h2 id="npm-包"><a href="#npm-包" class="headerlink" title="npm 包"></a>npm 包</h2><h3 id="eslint-plugin-html"><a href="#eslint-plugin-html" class="headerlink" title="eslint-plugin-html"></a>eslint-plugin-html</h3><p>目的是为了检测 html 文件中的 js 代码，全局下载，让设备非 node 项目也能使用</p><pre><code class="bash">npm install -g eslint-plugin-html</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1640400558364-b89c0585-1302-4515-b27a-bdb053cf8701.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_47,text_5bC86YeH6Iis5Zyw5oqS5oOF,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10#clientId=uf4909dba-f5dd-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=257&id=uc4ceedb9&margin=%5Bobject%20Object%5D&name=image.png&originHeight=514&originWidth=1656&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=70743&status=done&style=none&taskId=ue72c1dbf-e39a-418c-b15f-4b99cab5bf2&title=&width=828" alt="image.png"><br>每次打开 html，eslint 就会报错：</p><pre><code>&#39;plugins&#39; doesn&#39;t add plugins to configuration to load. Please use the &#39;overrideConfig.plugins&#39; option instead.</code></pre><p>官网 issues <a href="https://github.com/microsoft/vscode-eslint/issues/1376">https://github.com/microsoft/vscode-eslint/issues/1376</a> 中貌似也并未给出根治方法，暂时禁用：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1640401735422-2e618454-6752-4b2e-9020-8788d0ad114d.png?x-oss-process=image/watermark,type_d3F5LW1pY3JvaGVp,size_21,text_5bC86YeH6Iis5Zyw5oqS5oOF,color_FFFFFF,shadow_50,t_80,g_se,x_10,y_10#clientId=uf4909dba-f5dd-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=167&id=u7b0c7db1&margin=%5Bobject%20Object%5D&name=image.png&originHeight=333&originWidth=730&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=26497&status=done&style=none&taskId=u9c36aabe-d5cf-47bf-b227-a36925ba99f&title=&width=365" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> 🔨环境工具 </category>
          
          <category> 工具使用 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>维</title>
      <link href="/essay/hq3fcy/"/>
      <url>/essay/hq3fcy/</url>
      
        <content type="html"><![CDATA[<p>意念是多维化的体现。</p><p>在宇宙的浩瀚星辰中，难以被人们所定义的是空间，空间的等价转化则是维度，换言之，维度是人类难以捕捉的而又不时出现在我们日常生活中。</p><p>冥想是即达多维空间目的地的不错选择，冥想让我们建立思维上的楼阁，看是虚无，实则通往多维空间。</p><p>任何事物都需要沟通，人类文明创立以来，进制是创先河之例，打开了与计算机沟通的大门。其实此则不然，在永恒事物变相中，有一种沟通方式可以让万物联系——多维化零进制。</p><p>那是谁拾起探索的光辉？又是谁如先驱们般开始质疑身边的科学，一切的一切由维度引起——多维化平行宇宙空间……</p>]]></content>
      
      
      <categories>
          
          <category> 异世界 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>645. 错误的集合🔖数组</title>
      <link href="/blog/vvs5xy/"/>
      <url>/blog/vvs5xy/</url>
      
        <content type="html"><![CDATA[<ul><li><a href="https://leetcode-cn.com/problems/set-mismatch/">https://leetcode-cn.com/problems/set-mismatch/</a></li></ul><p>想着中午写道简单题，喵的，丧失一天学习心情……<br><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1648964102729-2472a01f-8d16-416d-9f17-f8f9ff9acd52.png#clientId=udbbc256e-f36e-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=152&id=ufbf4071b&margin=%5Bobject%20Object%5D&name=image.png&originHeight=677&originWidth=1195&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=281479&status=done&style=none&taskId=uc61f9f23-1e4e-43cf-9ae9-549667c23b4&title=&width=268.015625" alt="image.png"></p><pre><code class="typescript">function findErrorNums(nums: number[]): number[] &#123;  let result: any = [];  nums.sort((a: number, b: number) =&gt; &#123;    return a - b;  &#125;);  nums.forEach((data: number, index: number) =&gt; &#123;    // 重复的值    if (data === nums[index - 1]) &#123;      result.unshift(data);      nums.splice(index, 1);      nums.push(0);      // 丢失的值      for (let i: number = 0; i &lt; nums.length; i++) &#123;        if (i + 1 !== nums[i]) &#123;          result.push(i + 1);          break;        &#125;      &#125;    &#125;  &#125;);  return result;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 📶线结构：字符串-数组-栈-队列 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>TODO: 30. 串联所有单词的子串🔖递归</title>
      <link href="/blog/lgg15d/"/>
      <url>/blog/lgg15d/</url>
      
        <content type="html"><![CDATA[<ul><li><a href="https://leetcode-cn.com/problems/substring-with-concatenation-of-all-words/">https://leetcode-cn.com/problems/substring-with-concatenation-of-all-words/</a></li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 🌌递归算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>93. 复原 IP 地址🔖递归</title>
      <link href="/blog/aucxuf/"/>
      <url>/blog/aucxuf/</url>
      
        <content type="html"><![CDATA[<ul><li><a href="https://leetcode-cn.com/problems/restore-ip-addresses/">https://leetcode-cn.com/problems/restore-ip-addresses/</a></li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li>长度为 12 位：最小单元位 3</li><li>长度为 11 位：最小单元位 2</li><li>其他情况的最小单元位有可能是 1</li></ul><h3 id="ts-代码"><a href="#ts-代码" class="headerlink" title="ts 代码"></a>ts 代码</h3><pre><code class="typescript">function restoreIpAddresses(s: string): string[] &#123;  // 保存所有符合条件的IP地址  let r: any[] = [];  // 分四步递归处理ip分段  let search = (cur: any, sub: any) =&gt; &#123;    if (sub.length &gt; 12) return;    // 边界条件    if (cur.length === 4 &amp;&amp; cur.join(&quot;&quot;) === s) &#123;      r.push(cur.join(&quot;.&quot;));    &#125; else &#123;      // 正常的处理过程      for (let i = 0, len = Math.min(3, sub.length), tmp; i &lt; len; i++) &#123;        tmp = sub.substr(0, i + 1);        if (tmp - 256 &lt; 0) &#123;          // 转换下数据类型，如 01为1（LeetCode测试用例）          search(cur.concat([tmp * 1]), sub.substr(i + 1));        &#125;      &#125;    &#125;  &#125;;  search([], s);  return r;&#125;console.log(restoreIpAddresses(&quot;101023&quot;));</code></pre>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 🌌递归算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>TODO: 10. 正则表达式匹配🔖正则</title>
      <link href="/blog/qg73ng/"/>
      <url>/blog/qg73ng/</url>
      
        <content type="html"><![CDATA[<ul><li><a href="https://leetcode-cn.com/problems/regular-expression-matching/">https://leetcode-cn.com/problems/regular-expression-matching/</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 📶线结构：字符串-数组-栈-队列 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>459. 重复的子字符串🔖正则🔖字符串</title>
      <link href="/blog/rqcfeh/"/>
      <url>/blog/rqcfeh/</url>
      
        <content type="html"><![CDATA[<ul><li><a href="https://leetcode-cn.com/problems/repeated-substring-pattern/">https://leetcode-cn.com/problems/repeated-substring-pattern/</a></li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>基本正则模式匹配</p><h3 id="ts-代码"><a href="#ts-代码" class="headerlink" title="ts 代码"></a>ts 代码</h3><pre><code class="typescript">function repeatedSubstringPattern(s: string): boolean &#123;  let reg: RegExp = /^(\w+)\1+$/;  return reg.test(s);&#125;console.log(repeatedSubstringPattern(&quot;abcabcabcabc&quot;));</code></pre>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 📶线结构：字符串-数组-栈-队列 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>682. 棒球比赛🔖栈</title>
      <link href="/blog/srz8lz/"/>
      <url>/blog/srz8lz/</url>
      
        <content type="html"><![CDATA[<ul><li><a href="https://leetcode-cn.com/problems/baseball-game/">https://leetcode-cn.com/problems/baseball-game/</a></li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>没啥好说的——栈的最基本理解<br>js 的栈实现是利用 Array 的 push 和 pop……</p><pre><code class="typescript">function calPoints(ops: string[]): number &#123;  let sta: Array&lt;number&gt; = [];  ops.forEach((data: string) =&gt; &#123;    switch (data) &#123;      case &quot;+&quot;:        sta.push(sta[sta.length - 1] + sta[sta.length - 2]);        break;      case &quot;D&quot;:        sta.push(sta[sta.length - 1] * 2);        break;      case &quot;C&quot;:        sta.pop();        break;      default:        sta.push(Number(data));    &#125;  &#125;);  return sta.reduce((result: number, index: number) =&gt; &#123;    return result + index;  &#125;);&#125;console.log(calPoints([&quot;5&quot;, &quot;-2&quot;, &quot;4&quot;, &quot;C&quot;, &quot;D&quot;, &quot;9&quot;, &quot;+&quot;, &quot;+&quot;]));</code></pre>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 📶线结构：字符串-数组-栈-队列 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>11. 盛最多水的容器🔖数组🔖双指针</title>
      <link href="/blog/amgx01/"/>
      <url>/blog/amgx01/</url>
      
        <content type="html"><![CDATA[<ul><li><a href="https://leetcode-cn.com/problems/container-with-most-water/">https://leetcode-cn.com/problems/container-with-most-water/</a></li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h4 id="暴力循环解决"><a href="#暴力循环解决" class="headerlink" title="暴力循环解决"></a>暴力循环解决</h4><ul><li>对数组各个元素进行第一遍遍历，在此之中<strong>以该元素为基准</strong>对<strong>该元素后面的所有元素进行遍历</strong>，进行<code>两者最短高度 * （后面元素下标 - 该元素下标）</code>运算，遍历完成即可得到上述值的最大值 result。</li><li>该元素后面的所有元素进行遍历：这个循环是指定开始索引的位置往后进行的遍历，使用传统 for 循环或是 for in 循环</li></ul><p>这种解法会超时，写的时候我就感觉到了数组的双循环八成是超时，即便我是第二个循环不找全部元素，但还是超时 n^2 逃不掉<img src="https://cdn.nlark.com/yuque/0/2022/jpeg/1484158/1648709054571-cb914e0d-2a17-4e20-bdb3-d0f105bec0fe.jpeg#crop=0&crop=0&crop=1&crop=1&id=u4K1n&originHeight=56&originWidth=52&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&title="></p><pre><code class="typescript">function maxArea(height: number[]): number &#123;  let result: number = 0  height.forEach((data: number, index: number) =&gt; &#123;    if (index !== height.length - 1) &#123;      for (let i: number = index + 1; i &lt; height.length; i++) &#123;        let result_temp = Math.min(height[i], data) * (i - index)        result &gt; result_temp ? (result = result) : (result = result_temp)      &#125;    &#125;  &#125;)  return result</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1648707457045-2a083f7a-faab-4354-91bf-7a6b9e45c867.png#clientId=u753f0702-a2dc-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=442&id=uc882220e&margin=%5Bobject%20Object%5D&name=image.png&originHeight=530&originWidth=1561&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=103463&status=done&style=none&taskId=u22067f24-7e23-4771-a53d-ee9f7730591&title=&width=1300.8332816428629" alt="image.png"></p><h4 id="两端双指针移动解决"><a href="#两端双指针移动解决" class="headerlink" title="两端双指针移动解决"></a>两端双指针移动解决</h4><ul><li>探究解决办法的规律来解决问题，利用双指针在首末端往中间靠，每次移动 arr[指针]小的，然后在此次与 result 相比较。</li><li>这样只需要遍历一遍即可，时间复杂度为 n</li></ul><pre><code class="typescript">function maxArea(height: number[]): number &#123;  let head: number = 0;  let back: number = height.length - 1;  const result_fun = (head: number, back: number): number =&gt; &#123;    return Math.min(height[head], height[back]) * (back - head);  &#125;;  let result = result_fun(head, back);  while (head !== back) &#123;    height[head] &lt; height[back] ? head++ : back--;    if (result &lt;= result_fun(head, back)) result = result_fun(head, back);  &#125;  return result;&#125;</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1648710814761-4255d705-1462-47ed-8a96-ad66c4bf25a6.png#clientId=u753f0702-a2dc-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=179&id=u401ae785&name=image.png&originHeight=215&originWidth=720&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=23653&status=done&style=none&taskId=uac477603-59d0-4be6-b3e4-bb0899d2f68&title=&width=599.999976158143" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 📶线结构：字符串-数组-栈-队列 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>疫情下的空城与花海</title>
      <link href="/essay/gvzzcs/"/>
      <url>/essay/gvzzcs/</url>
      
        <content type="html"><![CDATA[<p>我们总喜欢作为旁观者去看待未能触及到自身的悲景，而这个世界上最悲观的身旁之物我想应该就是死亡了。</p><p><strong>空城</strong></p><p>到现在已有两年之久的心冠疫情，或许就是近些年来让我们体会到死亡的传使者，生命变得消亡，聚集场所变得暗淡，像是给我们笼罩一层未能看见的阴霾，我很讨厌这么一个微小生生物为生活所带来的暗色调。</p><p>东方航空 MU5735 的坠毁。在学校和家里的来往，我常坐飞机这一交通形式，我体验过飞机通过强气流带来的机体剧烈晃动，飞机失事的情况，我想，那几分钟是很绝望的，你只能坐在自己座椅上，被飞机下坠的惯性将自己身体硬拽在靠椅上，窗边呼啸的气流声，让你面无神色。我很讨厌大自然偶尔的霸道无理的脾气。</p><p><strong>花海</strong></p><p>学校的三月是一个有花的季节，成片的花香与色彩遍布整个校园。<br>成片的花海是我 22 年觉得最美的一件事物，她将周围的灰色染成五彩斑斓的景色。</p><p><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/1484158/1648700562531-b0b2bf77-4d97-40e1-a7b0-880d8d188c60.jpeg#crop=0&crop=0&crop=1&crop=1&from=url&id=rGCAP&margin=%5Bobject%20Object%5D&originHeight=912&originWidth=1216&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&title="><br><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/1484158/1648700589001-880ca871-1ae5-4ab0-8093-5b09c50f8f63.jpeg#crop=0&crop=0&crop=1&crop=1&from=url&id=yMKAc&margin=%5Bobject%20Object%5D&originHeight=912&originWidth=1216&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&title="><br><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/1484158/1648700686067-283184da-ffb4-4ff7-84b3-465dbcdfa76b.jpeg#crop=0&crop=0&crop=1&crop=1&from=url&id=dblVL&margin=%5Bobject%20Object%5D&originHeight=912&originWidth=1216&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&title="></p><p>花会枯萎，树会凋零，一瞬的美好终会陨落<br>一瞬美好存于此的的意义会是什么呢<br>我不曾知道，也未曾想过<br>可是这些一个月的美丽都不曾保留的美丽，让我些许顿悟<br>美好的意义或许就是美好本身，她不需要太多的形容<br>你会因为她的绽放感到开心、感到愉悦、感到这世上原来还有这么美好的事物</p><p>任何事物的存在都必然伴随着其存在的意义</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>从输入 URL 到页面加载完成，发生了什么？在此流程中做优化！</title>
      <link href="/blog/lvs755/"/>
      <url>/blog/lvs755/</url>
      
        <content type="html"><![CDATA[<p>前言：从输入 URL 到页面加载完成，发生了什么？</p><p>输入 URL，浏览器会先处理输入的信息是搜索信息还是 URL 请求连接，这个过程需要浏览器的 URL 解析操作；然后我们需要通过 DNS（域名解析系统）将 URL 解析为对应的 IP 地址，然后与这个 IP 地址确定的那台服务器建立起 TCP 网络连接，随后我们向服务端抛出我们的 HTTP 请求，服务端处理完我们的请求之后，把目标数据放在 HTTP 响应里返回给客户端，拿到响应数据的浏览器就可以开始走一个渲染的流程。渲染完毕，页面便呈现给了用户，并时刻等待响应用户的操作。</p><p>具体大致过程如下：</p><ol><li>URL 解析</li><li>DNS 解析</li><li>TCP 连接</li><li>客户端发送请求</li><li>服务端处理请求，响应请求</li><li>客户端和服务端断开连接</li><li>浏览器拿到响应数据，解析响应内容，把解析的结果渲染展示给用户</li></ol><p>而前端性能优化，就是把这 5 个过程滴水不漏地考虑到自己的性能优化方案内、反复权衡，从而打磨出用户满意的速度。</p><blockquote><p>文章参考以下两个文章，基于以下文章并做出部分自己的修改：</p><ul><li><a href="https://www.kancloud.cn/sllyli/performance/1242194">前端性能优化原理与实践</a></li><li><a href="https://juejin.cn/post/6844904194801926157">从输入 URL 到渲染全过程</a></li><li><a href="https://segmentfault.com/a/1190000017184701">从 URL 输入到页面展现到底发生什么？</a></li></ul></blockquote><h2 id="一、URL-解析"><a href="#一、URL-解析" class="headerlink" title="一、URL 解析"></a>一、URL 解析</h2><h3 id="地址解析和编码"><a href="#地址解析和编码" class="headerlink" title="地址解析和编码"></a>地址解析和编码</h3><p>我们输入 URL 后，浏览器会解析输入的字符串，判断是 URL 还是搜索关键字，如果是 URL 就开始编码。</p><p>一般来说 URL 只能使用英文字母、阿拉伯数字和某些标点符号，不能使用其他文字和符号，所以，如果 URL 中有文字就必须编码后使用。但是 URL 编码很混乱，不同的操作系统、浏览器、网页字符集，会导致不同的编码结果。所以我们需要使用 JavaScript 先对 URL 编码，然后提交给服务器，不给浏览器插手的机会。我们通常会使用 encodeURI()函数或者 encodeURIComponent()函数来编码 URL</p><h3 id="HSTS"><a href="#HSTS" class="headerlink" title="HSTS"></a>HSTS</h3><p>HSTS(HTTP Strict TransportSecurity)是一种新的 Web 安全协议，HSTS 的作用是强制客户端使用 HTTPS 与服务器创建连接。比如你在地址栏输入 <a href="http://xxx/%EF%BC%8C%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BC%9A%E8%87%AA%E5%8A%A8%E5%B0%86">http://xxx/，浏览器会自动将</a> http 转写成 https，然后直接向 <a href="https://xxx/">https://xxx/</a> 发送请求。</p><h3 id="缓存检查"><a href="#缓存检查" class="headerlink" title="缓存检查"></a>缓存检查</h3><p>浏览器在发送请求之前先检查有没有缓存，过程如下： <img src="https://cdn.nlark.com/yuque/0/2022/webp/1484158/1653193882930-3c261c9c-875f-4ee5-994b-e8fcf22272ee.webp#clientId=u4f3d5f6a-91d0-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ue084b2ed&margin=%5Bobject%20Object%5D&originHeight=531&originWidth=556&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&taskId=u952113a5-23b1-46d7-8793-1452e9565b5&title="><br>浏览器会先去查看强缓存（Expires 和 cache-control）判断是否过期，如果强缓存生效，直接从缓存中读取资源；若不生效则进行协商缓存(Last-Modified / If-Modified-Since 和 Etag/If-None-Match)，协商缓存由服务器决定是否使用缓存，若协商缓存失效，那么代表该请求的缓存失效，返回 200，并重新返回资源和缓存标识，再次存入浏览器缓存中；生效则返回 304，并从缓存中读取资源。（协商缓存之前要经过 DNS 域名解析，之后建立 TCP 链接）</p><p>那么浏览器缓存的位置在哪呢？</p><ul><li>Service Worker：浏览器独立线程进行缓存</li><li>Memory Cache：内存缓存</li><li>Disk Cache：硬盘缓存</li><li>Push Cache：推送缓存（HTTP/2 中的）</li></ul><p><strong>注意</strong>：输入网址之后，会查找内存缓存，没有再找硬盘，都没有就发生网络请求。 普通刷新（F5）：因为 TAB 没有关闭，所以内存缓存可用，如果匹配上会被优先使用，其次是磁盘缓存 强制刷新（Ctrl+F5）：浏览器不使用缓存，因此发送的请求头均带有 Cache-control：no-cache,服务器直接返回 200 和最新内容。</p><h2 id="二、DNS-解析"><a href="#二、DNS-解析" class="headerlink" title="二、DNS 解析"></a>二、DNS 解析</h2><h3 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h3><ul><li>DNS：把域名和 ip 地址相互映射分布式数据库，让用户能更方便的访问互联网，DNS 协议运行在 UDP 协议之上</li><li>DNS 解析：通过域名最终得到对应 ip 地址的过程。</li><li>DNS 缓存：浏览器，操作系统，路由器，本地 DNS，根域名服务器都会对 DNS 结果作出一定的缓存</li></ul><h3 id="DNS-解析过程"><a href="#DNS-解析过程" class="headerlink" title="DNS 解析过程"></a>DNS 解析过程</h3><ol><li>首先搜索浏览器自身的 DNS 缓存，有缓存直接返回;</li><li>浏览器自身 DNS 不存在，浏览器就会调用一个类似 gethostbyname 的库函数,此函数会先去检测本地 hosts 文件，查看是否有对应 ip。</li><li>如果本地 hosts 文件不存在映射关系，就会查询路由缓存，路由缓存不存在就去查找本地 DNS 服务器（一般 TCP/IP 参数里会设首选 DNS 服务器，通常是 8.8.8.8)(客户端到本地 DNS 服务器是递归过程）</li><li>如果本地 DNS 服务器还没找到就会向根服务器发出请求。（DNS 服务器之间是迭代过程）</li></ol><p>具体过程：</p><ul><li><p>本地 DNS 服务器代我们的浏览器发起迭代 DNS 解析请求，首先它会找根域的 DNS 的 IP 地址（全球 13 台哟，可惜中国没有！）。找到根域的 DNS 地址,就会向其发起请求（请问<a href="http://www.baidu.com这个域名的IP地址是多少呀？）；">www.baidu.com这个域名的IP地址是多少呀？）；</a></p></li><li><p>根域发现这是一个顶级域 com 域的一个域名，于是告诉本地 DNS 服务器我不知道这个域名的 IP 地址,但是我知道 com 域的 IP 地址，你去找它去吧；</p></li><li><p>于是本地 DNS 服务器就得到了 com 域的 IP 地址，又向 com 域的 IP 地址发起了请求（请问<a href="http://www.baidu.com这个域名的ip地址是多少呀/?%EF%BC%89,%E4%BA%8E%E6%98%AFcom%E5%9F%9F%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%91%8A%E8%AF%89%E6%9C%AC%E5%9C%B0DNS%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%88%91%E4%B8%8D%E7%9F%A5%E9%81%93www.baidu.com%E8%BF%99%E4%B8%AA%E5%9F%9F%E5%90%8D%E7%9A%84IP%E5%9C%B0%E5%9D%80%EF%BC%8C%E4%BD%86%E6%98%AF%E6%88%91%E7%9F%A5%E9%81%93baidu.com%E8%BF%99%E4%B8%AA%E5%9F%9F%E7%9A%84DNS%E5%9C%B0%E5%9D%80%EF%BC%8C%E4%BD%A0%E5%8E%BB%E6%89%BE%E5%AE%83%E5%8E%BB">www.baidu.com这个域名的IP地址是多少呀?）,于是com域服务器告诉本地DNS服务器我不知道www.baidu.com这个域名的IP地址，但是我知道baidu.com这个域的DNS地址，你去找它去</a>;</p></li><li><p>于是本地 DNS 服务器又向 baidu.com 这个域名的 DNS 地址（这个一般就是由域名注册商提供的，像万网，新网等）发起请求（请问<a href="http://www.baidu.com这个域名的IP地址是多少？），这个时候baidu.com域的DNS服务器一查，呀！果真在我这耶，于是就把找到的结果发送给本地DNS服务器">www.baidu.com这个域名的IP地址是多少？），这个时候baidu.com域的DNS服务器一查，呀！果真在我这耶，于是就把找到的结果发送给本地DNS服务器</a>;</p></li><li><p>这个时候本地 DNS 服务器就拿到了<a href="http://www.baidu.com这个域名对应的ip地址./">www.baidu.com这个域名对应的IP地址。</a></p></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1653195503382-8d0d2c0b-904d-4f6f-ab2a-a41fde109da2.png#clientId=u86c4aa28-20eb-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u07bfc271&margin=%5Bobject%20Object%5D&originHeight=474&originWidth=732&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=stroke&taskId=uf296b58b-1a74-4128-9f89-1237df6806f&title="></p><h3 id="DNS-优化"><a href="#DNS-优化" class="headerlink" title="DNS 优化"></a>DNS 优化</h3><p>DNS 也是开销，通常浏览器查找一个给定域名的 IP 地址要花费 20~120 毫秒，在完成域名解析之前，浏览器不能从服务器加载到任何东西。那么如何减少域名解析时间，加快页面加载速度呢？</p><ul><li>减少 DNS 请求次数</li><li>DNS 预获取,DOM 还没开始，浏览器预解析地址，把解析好的地址放在本地缓存里面，DOM 树生成完，要加载图片类的发现 DNS 已经解析好了，再发送请求。&lt;link rel=’dns-prefetch’href=’//dfns.tanx.com’&gt;<br>（主要对图片资源）</li><li>DNS 查询的过程经历了很多的步骤，如果每次都如此，会耗费太多的时间、资源。所以我们应该尽早的返回真实的 IP 地址:（减少查询过程，也就是 DNS 缓存。浏览器获取到 IP 地址后，一般都会缓存到浏览器的缓存中，本地的 DNS 缓存服务器，也可以去记录。另外，每天几亿网名的访问需求，一秒钟几千万的请求域名服务器如何满足？就是 DNS 负载均衡。通常我们的网站应用各种云服务，或者各种服务商提供类似的服务，由他们去帮我们处理这些问题。 DNS 系统根据每台机器的负载量，地理位置的限制（长距离的传输效率）等等，去提供高效快速的 DNS 解析服务。</li><li>当客户端 DNS 缓存（浏览器和操作系统）缓存为空时，DNS 查找的数量与要加载的 Web 页面中唯一主机名的数量相同，包括页面 URL、脚本、样式表、图片、Flash 对象等的主机名。减少主机名的数量就可以减少 DNS 查找的数量；</li><li>减少唯一主机名的数量会潜在减少页面中并行下载的数量（HTTP1.1 规范建议从每个主机名并行下载两个组件，但实际上可以多个）；但是减少主机名和并行下载的方案会产生矛盾，需要大家自己权衡。建议将组件放到至少两个但不多于 4 个主机名下，减少 DNS 查找的同时也允许高度并行下载。</li></ul><p><strong>DNS 解析后会把域名的解析权交给 cname()指向的内容分发（CDN）专用的 DNS 服务器。CDN 专用的 DNS 服务器把 CDN 的全局负载均衡设备的 ip 地址返回给用户</strong>。</p><h3 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h3><p>举个例子：以前坐火车买票，都要到火车站买，所有人都去火车站买票，火车站售票厅的压力可想而知有多大。<br>后来火车票代售点出现了，分布在各个城市，城镇，我们只需要去距离我们最近的火车票售卖点买票就可以了。 卖火车票的代理售票点（缓存服务器），为买票者提供了方便，帮助他们在最近的地方（最近的 CDN 节点）， 用最短的时间（最短的请求时间）买到票（拿到资源）。减轻了售票大厅的压力（起到分流作用，减轻服务器负载压力）</p><h4 id="CDN-缓存"><a href="#CDN-缓存" class="headerlink" title="CDN 缓存"></a>CDN 缓存</h4><p>在浏览器本地缓存失效后，浏览器会像 CDN 边缘节点发起请求，类似浏览器缓存，CDN 边缘节点也存在一套缓存机制，</p><ul><li>CDN 边缘节点缓存策略因服务商不同而不同，通过 http 响应头中的 cache-control：max-age 字段设置 CDN 边缘节点数据缓存时间。</li><li>当浏览器向 CDN 节点请求数据时，CDN 节点会判断缓存数据是否过期，若缓存数据过期，CDN 会向服务器发出回源请求，从服务器拉取最新数据，更新本地缓存，并将最新数据返回给客户端，CDN 服务商一般会提供基于文件后缀，目录多个维度来指定 CDN 缓存时间，为用户提供更精细化的缓存管理。</li></ul><h4 id="CDN-工作方式"><a href="#CDN-工作方式" class="headerlink" title="CDN 工作方式"></a>CDN 工作方式</h4><p>（1）、当你点击网站页面的 url 时，经过本 DNS 解析，DNS 解析后会把域名的解析权交给 cname()指向的内容分发专用的 DNS 服务器。内容分发专用的 DNS 服务器把内容分发的全局负载均衡（GSLB）设备的 ip 地址返回给用户。<br>（2）、当你向 CDN 的全局负载均衡设备的 ip 地址发起 url 访问请求，CDN 的全局负载均衡设备会为你选择一台合适的缓存服务器提供服务。</p><ul><li><p>选择的依据：用户的 ip 地址，判断哪台服务器距离用户最近，根据用户请求的 url 中携带的内容名称判断哪台服务器上有用户要的数据，查询各个服务器当前负载情况，判断哪台服务器有服务能力。</p></li><li><p>分配：基于这些条件综合分析后，区域负载均衡设备会向全局负载均衡设备请求返回一台缓存服务器的 IP 地址。全局负载均衡设备返回服务器 IP 地址，用户向缓存服务器发起请求，缓存服务器响应用户请求，将用户所需内容传送到用户终端，如果这台缓存服务器没有用户想要的内容，而区域均衡设备依然将它分配给了用户，那么这台服务器就要向它的上一级缓存服务器请求内容，直至追溯到网站的源服务器将内容拉到本地。域名解析服务器根据用户 ip 地址，把域名解析成相应节点的缓存服务器 ip 地址，实现用户就近访问，使用 CDN 服务的网站，只要将其域名解析权交给 CDN 的全局负载均衡设备，将需要分发的内容注入到 CDN 就可以实现内容加速了。</p></li></ul><h4 id="CDN-优势"><a href="#CDN-优势" class="headerlink" title="CDN 优势"></a>CDN 优势</h4><p>（1）、CDN 节点解决了跨运营商和跨地域访问的问题，访问延时大大降低；<br>（2）、大部分请求在 CDN 边缘节点完成，CDN 起到分流作用，减轻了源服务器的负载。</p><h4 id="CDN-劣势"><a href="#CDN-劣势" class="headerlink" title="CDN 劣势"></a>CDN 劣势</h4><p>（1）、当网站更新时，如果 CDN 节点上数据没有及时更新，即便用户在浏览器使用 Ctrl +F5 的方式使浏览器端的缓存失效，也会因为 CDN 边缘节点没有同步最新数据而导致用户访问异常。<br>（2）、CDN 不同的缓存时间会对“回源率”产生直接的影响：</p><ul><li>如果缓存时间短，CDN 边缘节点的内容经常失效，导致频繁回源。不仅增加服务器压力，也增加了用户访问时间。</li><li>如果缓存时间长，数据更新了，边缘节点的内容都还没更新，开发者对特定的任务做特定的数据缓存时间管理。</li></ul><h4 id="CDN-刷新缓存"><a href="#CDN-刷新缓存" class="headerlink" title="CDN 刷新缓存"></a>CDN 刷新缓存</h4><p>CDN 边缘节点对开发者是透明的，相比于浏览器 Ctrl+F5 的强制刷新来使浏览器本地缓存失效，开发者可以通过 CDN 服务商提供的“刷新缓存”接口来达到清理 CDN 边缘节点缓存的目的。这样开发者在更新数据后，可以使用“刷新缓存”功能来强制 CDN 节点上的数据缓存过期，保证客户端在访问时，拉取到最新的数据。 |</p><h4 id="CDN-优化"><a href="#CDN-优化" class="headerlink" title="CDN 优化"></a>CDN 优化</h4><p>（1）、前端需要被加速的文件大致包括：<br>js、css、图片、视频、和页面等文件。页面文件有动态和静态之分。这些文件和页面（比如 html）最大的区别是：这些文件都是静态的，改动比较小，这类静态文件适合做 CDN 加速。我们把这些静态文件通过 CDN 分发到世界各地的节点，用户可以在距离最近的边缘节点拿到需要的内容，从而提升内容下载速度加快网页打开速度。页面分为动态页面和静态页面，动态页面不适合做 CDN 缓存，因为页面是动态的话，内容的有效期就比较活跃。边缘节点的数据经常失效要回源，造成源服务器压力。<br>（2）、减少资源请求的等待时间<br>不同浏览器的并发数量不一样：IE11 、IE10 、chrome、Firefox 的并发连接数是 6 个，IE9 是 10 个。如果页面静态资源（图片等）过多（大于 6 个）会存在资源请求等待的情况。目前现实状况是大多用户带宽越来越大，但是我们的静态资源并非那么大，很多文件都是几 k 或者几十 k，6 个文件加起来都小于带宽。这样就导致了资源的浪费。</p><ul><li>解决方案是：用多个不同 IP 的服务器来存储这些文件，并在页面中通过绝对路径的方式引用（要求同一 IP 的文件不超过 6 个）。这样就可以尽可能的减少资源请求等待的情况。</li></ul><p><strong>至此，你已经获取到缓存服务器的 IP 地址，并且准备向这个 IP 地址发送请求了。</strong></p><h2 id="三、TCP-连接"><a href="#三、TCP-连接" class="headerlink" title="三、TCP 连接"></a>三、TCP 连接</h2><h3 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h3><ul><li>TCP 是一种面向连接的，可靠的，基于字节流的传输层通信协议。</li><li>建立 TCP 连接需要进行三次握手。过程如下：</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/webp/1484158/1653194429604-83b7eccb-7572-4c7b-826e-c9b9fe62c4b4.webp#clientId=u4f3d5f6a-91d0-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=236&id=u757bb214&margin=%5Bobject%20Object%5D&originHeight=660&originWidth=1304&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&taskId=udc0d9860-ec1e-4544-959d-b9b3387194a&title=&width=465.99542236328125"><br><img src="https://cdn.nlark.com/yuque/0/2022/webp/1484158/1653194443274-6c98150b-79e8-4075-adb5-9f05ca79decb.webp#clientId=u4f3d5f6a-91d0-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=147&id=u1fd5e20c&margin=%5Bobject%20Object%5D&originHeight=303&originWidth=897&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&taskId=u65958f1c-2bbd-4cdb-afcb-35cc406c3ba&title=&width=434.99542236328125"></p><h3 id="TCP-握手过程"><a href="#TCP-握手过程" class="headerlink" title="TCP 握手过程"></a>TCP 握手过程</h3><ol><li>客户端发送带有 SYN 标识（SYN=1，seq=x）的请求报文段，然后进入 SYN_SEND 状态，等待服务端确认;</li><li>服务端接收到客户端 SYN 报文段后，需要发送 ACK 信息对这个 SYN 进行确认，同时还要发送自己的 SYN 信息（SYN=1，ACK=1，seq=y，ack=x+1）服务端把这些信息放在一个报文段中（（SYN+ACK 报文段），一并发给客户端，此时客户端进入 SYN_RECV 状态;</li><li>客户端接收到服务端的 SYN+ACK 报文段后会向服务端发送 ACK（ACK=1，seq=x+，ack=y+1）确认报文段，这个报文段发送后，客户端和服务端都进入 ESTABLISHED 状态，完成三次握手。</li></ol><ul><li>第一次握手： 客户端向服务端携带有客户端数据通讯初始序列号的报文，并进入 SYN-SENT 状态，当客户端收到数据时证明服务端知道：客户端的发送能力、服务端的接受能力正常。</li><li>第二次握手： 服务端将响应客户端数据通讯初始序列号和服务端数据通讯初始序列号放入报文中一起发送给客户端。发送结束后服务端进入 SYN-RECEIVED 状态。当客户端接受到数据证明在客户端的角度上知道：客户端和服务端的发送、接收能力是正常的。</li><li>第三次握手： 客户端向服务端发送一个确认应答，并进入 ESTABLISHED 状态，服务端收到应答后也进入 ESTABLISHED 状态完成三次握手。这时候在服务端知道：服务端的发送能力、客户端的接收能力正常。</li></ul><h3 id="为什么-TCP-建立是三次握手？"><a href="#为什么-TCP-建立是三次握手？" class="headerlink" title="为什么 TCP 建立是三次握手？"></a>为什么 TCP 建立是三次握手？</h3><ul><li>双方要明确对方接收能力都是正常的，（客户端发之后，服务端可以确定客户端发送能力正常，服务端发送给客户端，客户端可以确定服务端的接收和发送能力正常，最后客户端发送确认，来确定客户端的接收能力。</li><li><strong>为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误</strong>。</li><li>第三次握手除了让服务端知道，服务端发送能力和客户端的接收能力正常之外，还可以防止数据报延迟带来的不必要的资源消耗：当客户端发起 tcp 第一次握手的请求时，因为网络问题滞留在网络中，这时候客户端因为等待太久没有响应所以自动重发了握手请求并完成了所有数据请求关闭了与服务端的链接，这时候服务端才接收到第一次滞留在网络中的握手请求，服务端会向客户端发送第二次握手并处于等待第 3 次握手状态，客户端接收到第二次握手请求后发现是过期的请求就可以通过停止发送第三次握手，服务端一段时间没接到第三次握手请求会自动关闭请求监听。</li></ul><h3 id="TLS（HTTPS）"><a href="#TLS（HTTPS）" class="headerlink" title="TLS（HTTPS）"></a>TLS（HTTPS）</h3><ul><li><strong>如果是 HTTP 连接，三次握手成功后，便建立起链接，如果是 HTTPS 连接，还需要传输层安全性协议（TLS）</strong></li></ul><p>TLS 工作于传输层之上，应用层之下，默认作用于服务端的 443 端口,在 TLS 中可以分成两种加密技术：</p><ul><li><strong>对称性加密</strong>：客户端和服务端拥有相同的密钥，通过密钥对密文解密。用于密文通讯</li><li><strong>非对称性加密</strong>：在该模式下，密钥分为公钥和私钥，用公钥加密的数据必须用私钥解密，用私钥加密的数据需要用公钥解密，公钥可以通过服务端发送给各个客户端，私钥则只由服务端持有，所有该模式主要用于传递对称性密钥阶段。加密流程如下图：</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/webp/1484158/1653195667430-9725fd8f-69c1-4691-acae-9aea61ff7e4a.webp#clientId=u86c4aa28-20eb-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=283&id=u62e8caf3&margin=%5Bobject%20Object%5D&originHeight=572&originWidth=751&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=stroke&taskId=u21fac48b-ea50-47cc-a1a0-f9c03527647&title=&width=371.99542236328125"><br>其中数字证书是由服务端生成的非对称加密公钥和数字签名组成加密形成，数字签名是服务器在第三方机构注册校验服务器身份的数据，当客户端接收到数字证书是可以通过比对第三方机构注册的信息从而判断该报文是否是从目标服务器中传出来，从而确定公钥是否被调包。如果比对成功，客户端会生成对称性加密的密钥通过服务端派发的公钥进行加密传输给服务端，之后的信息传递就通过这个密钥进行对称性加密传输。</p><h2 id="四、客户端发送请求"><a href="#四、客户端发送请求" class="headerlink" title="四、客户端发送请求"></a>四、客户端发送请求</h2><p>TCP 三次握手建立连接成功后，客户端按照<strong>指定的格式</strong>开始向服务端发送 HTTP 请求。</p><h3 id="请求报文结构"><a href="#请求报文结构" class="headerlink" title="请求报文结构"></a>请求报文结构</h3><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1653196268394-7d03589e-0451-42d8-a460-7165186625a6.png#clientId=u86c4aa28-20eb-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ua22d4039&margin=%5Bobject%20Object%5D&name=image.png&originHeight=243&originWidth=616&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=69787&status=done&style=stroke&taskId=u4cdbcc0b-404e-40f6-9b2d-d1dddcac686&title=" alt="image.png"></p><h4 id="请求报头"><a href="#请求报头" class="headerlink" title="请求报头"></a>请求报头</h4><p>请求报头允许客户端向服务器传递请求的附加信息和客户端自身的信息。<br>PS: 客户端不一定特指浏览器，有时候也可使用 Linux 下的 CURL 命令以及 HTTP 客户端测试工具等。<br>常见的请求报头有: Accept, Accept-Charset, Accept-Encoding, Accept-Language, Content-Type, Authorization, Cookie, User-Agent 等。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1653196015114-144aaadd-3f62-429d-a4ad-ba31e48a49dd.png#clientId=u86c4aa28-20eb-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=116&id=u41a7308a&margin=%5Bobject%20Object%5D&name=image.png&originHeight=583&originWidth=1920&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=123026&status=done&style=stroke&taskId=u3ddce4e4-0502-483b-8154-439d30f1515&title=&width=381.99542236328125" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1653196053367-789ac83b-4ea6-4f5c-ab5b-71064638eaca.png#clientId=u86c4aa28-20eb-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=145&id=u1d78f2c8&margin=%5Bobject%20Object%5D&name=image.png&originHeight=729&originWidth=1920&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=163187&status=done&style=stroke&taskId=udbc636a5-b588-4a00-8e29-4776874dc92&title=&width=380.99542236328125" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1653196074822-50723931-5917-4a05-ab3b-cffa30bcdc1d.png#clientId=u86c4aa28-20eb-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=143&id=udc2cc044&margin=%5Bobject%20Object%5D&name=image.png&originHeight=724&originWidth=1920&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=158629&status=done&style=stroke&taskId=ub7a76542-0afd-4c20-98cb-b27185948ca&title=&width=377.99542236328125" alt="image.png"><br>从图中可以看出，请求报头中使用了 Accept, Accept-Encoding, Accept-Language, Cache-Control, Connection, Cookie 等字段。Accept 用于指定客户端用于接受哪些类型的信息，Accept-Encoding 与 Accept 类似，它用于指定接受的编码方式。Connection 设置为 Keep-alive 用于告诉客户端本次 HTTP 请求结束之后并不需要关闭 TCP 连接，这样可以使下次 HTTP 请求使用相同的 TCP 通道，节省 TCP 连接建立的时间。</p><h4 id="请求正文"><a href="#请求正文" class="headerlink" title="请求正文"></a>请求正文</h4><p>当使用 POST, PUT 等方法时，通常需要客户端向服务器传递数据。这些数据就储存在请求正文中。在请求包头中有一些与请求正文相关的信息，例如: 现在的 Web 应用通常采用 Rest 架构，请求的数据格式一般为 json。这时就需要设置 Content-Type: application/json。</p><h3 id="请求过程优化"><a href="#请求过程优化" class="headerlink" title="请求过程优化"></a>请求过程优化</h3><p>减少 HTTP 请求次数和请求资源大小</p><ul><li>资源合并压缩</li><li>字体图标（精灵图基本不是好的优化方式了，不好维护）</li><li>base64</li><li>Gzip（一般文件能压缩 60%）</li><li>图片懒加载</li><li>数据延迟分批加载</li><li>CDN 资源</li></ul><h2 id="五、服务端响应请求"><a href="#五、服务端响应请求" class="headerlink" title="五、服务端响应请求"></a>五、服务端响应请求</h2><p>服务器端收到请求后由 web 服务器（准确说应该是 http 服务器）处理请求，诸如 Apache、Ngnix、IIS 等。web 服务器解析用户请求，了解了要调度哪些资源文件，再通过响应的资源文件处理用户请求和参数，并调用数据库信息，最后将结果通过 web 服务器返回给浏览器客户端。</p><h4 id="响应报文"><a href="#响应报文" class="headerlink" title="响应报文"></a>响应报文</h4><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1653196402673-6ece40f2-645b-4af5-b395-a715c756cbfc.png#clientId=u86c4aa28-20eb-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u5b68bb44&margin=%5Bobject%20Object%5D&name=image.png&originHeight=288&originWidth=407&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=35564&status=done&style=stroke&taskId=u6f4e3dd1-e779-4e7d-8af2-9d9ab7c27a7&title=" alt="image.png"><br>(1) 响应行包含：协议版本，状态码，状态码描述<br>状态码规则如下：</p><ul><li>1xx：指示信息–表示请求已接收，继续处理。</li><li>2xx：成功–表示请求已被成功接收、理解、接受。</li><li>3xx：重定向–要完成请求必须进行更进一步的操作。</li><li>4xx：客户端错误–请求有语法错误或请求无法实现。</li><li>5xx：服务器端错误–服务器未能实现合法的请求。</li></ul><p>(2) 响应头部包含响应报文的附加信息，由 名/值 对组成<br>(3) 响应主体包含回车符、换行符和响应返回数据，并不是所有响应报文都有响应数据</p><h2 id="六、断开连接"><a href="#六、断开连接" class="headerlink" title="六、断开连接"></a>六、断开连接</h2><p>服务器响应完客户端请求之后，解除 TCP 连接，释放过程（四次挥手过程）如下：<br><img src="https://cdn.nlark.com/yuque/0/2022/webp/1484158/1653194694500-6c0090b0-4c78-407c-83df-3355a71b80f2.webp#clientId=u4f3d5f6a-91d0-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u85962d21&margin=%5Bobject%20Object%5D&originHeight=454&originWidth=553&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&taskId=ud6909642-5c02-4011-b15b-e7dddfd25d3&title="></p><h3 id="四次挥手过程"><a href="#四次挥手过程" class="headerlink" title="四次挥手过程"></a>四次挥手过程</h3><ul><li>客户端发送标记为 FIN=1（finished 的缩写，表示接收完成，请求释放连接），同时生成一个 Seq=u 的序列号，之后进入 FIN-WAIT-1 半关闭阶段（此时客户端到服务端发送数据的通道已经关闭，但是仍然可以接收服务端发过来的数据）；</li><li>服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号 seq=v，此时，服务端就进入了 CLOSE-WAIT（关闭等待）状态。TCP 服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个 CLOSE-WAIT 状态持续的时间。</li><li>客户端收到服务器的确认请求后，此时，客户端就进入 FIN-WAIT-2（终止等待 2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。</li><li>服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为 seq=w，此时，服务器就进入了 LAST-ACK（最后确认）状态，等待客户端的确认。</li><li>客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是 seq=u+1，此时，客户端就进入了 TIME-WAIT（时间等待）状态。</li><li>服务器只要收到了客户端发出的确认，立即进入 CLOSED 状态，就结束了这次的 TCP 连接。</li></ul><h3 id="为什么是四次挥手？"><a href="#为什么是四次挥手？" class="headerlink" title="为什么是四次挥手？"></a>为什么是四次挥手？</h3><p>因为建立一旦连接，双方既是发送方，又是接收方，为了保证在最后断开的时候，客户端发送的最后一个 ACK 报文段能够被服务器接收到。如果客户端在收到服务器给它的断开连接的请求之后，回应完服务器就直接断开连接的话，服务器就会因为一直没得到客户端响应而一直等待，所以客户端要等待两个最长报文段寿命的时间，以便于服务器没有收到请求之后重新发送请求。</p><h2 id="七、浏览器解析并渲染响应内容"><a href="#七、浏览器解析并渲染响应内容" class="headerlink" title="七、浏览器解析并渲染响应内容"></a>七、浏览器解析并渲染响应内容</h2><p>在这之前我们先来补充一点基础知识：</p><h3 id="浏览器的渲染引擎组成（列举的是基本组成）"><a href="#浏览器的渲染引擎组成（列举的是基本组成）" class="headerlink" title="浏览器的渲染引擎组成（列举的是基本组成）"></a>浏览器的渲染引擎组成（列举的是基本组成）</h3><ul><li>HTML 解析器:将 HTML 解析成 DOM 树。</li><li>CSS 解析器: 为 DOM 中各个元素对象计算出样式信息，为布局提供基础设施。</li><li>JavaScript 引擎:解析并执行 javascript 代码。</li><li>布局 layout 模块:在 DOM 树创建后，webkit 需要将其中的元素对象同样式信息结合起来，计算他们的大小位置等布局信息，形成一个能表达这所有信息的模型。</li><li>绘图模块:使用图形库将布局计算后的各个网页的节点绘制成图像的结果。</li></ul><h3 id="渲染过程"><a href="#渲染过程" class="headerlink" title="渲染过程"></a>渲染过程</h3><ol><li>浏览器拿到文件后（拿到的是一些字节码）通过编码方式（一般是 utf-8）转换为对应的字符。</li><li>浏览器至上而下解析文档，遇见 HTML 标记，调用 HTML 解析器解析为对应的 tocken，tocken 就是标签文本的序列号，将 tocken 按词法解析解析成具体的标记结构，这个过程已经构建出一颗有标签，有层级，有结构的 DOM 树（就是一块内存，这块内存实际就是一个个 Tocken 构成的）；</li><li>遇见 style/link 标记，调用 CSS 解析器处理 CSS 标记并构建 CSSOM 样式树；</li><li>遇见 script 标记，调用 javascript 解析器处理，绑定事件、修改 DOM 树/CSS 树等；</li><li>将 DOM 树和 CSSOM 树合并成一颗 render 树（渲染树）。</li><li>根据渲染树来渲染，计算每个节点的几何信息（这一过程要依赖图形库）；</li><li>将各个节点绘制到屏幕上。 如果用户操作页面，会触发第（6）或者第（7）步骤，也就是重排和重绘</li></ol><h3 id="阻塞渲染"><a href="#阻塞渲染" class="headerlink" title="阻塞渲染"></a>阻塞渲染</h3><p>（1）style 标签的样式：</p><ul><li>由 HTML 解析器解析(异步解析）；</li><li>不阻塞浏览器渲染（可能会出现闪屏（解析一点，显示一点现象）；</li><li>不阻塞 DOM 解析。</li></ul><p>（2）link 引入的外部 css 样式（推荐使用）</p><ul><li>由 CSS 解析器解析（同步解析）；</li><li>阻塞浏览器渲染（可以利用这种阻塞避免闪屏);</li><li>阻塞其后 js 语句的执行：</li></ul><p><strong>原因</strong>：如果后面 js 的内容是获取元素的样式，例如宽高等属性,如果不等样式解析完毕，后面的 js 就获得了错误的信息,由于浏览器也不知道后续 js 的具体内容，所以只好等前面所有样式解析完毕，再执行 js。例如：firefox 在样式加载和解析过程，会禁止所有脚本。（webkit 内核的浏览器只会在 js 尝试访问样式属性或者可能受到未加载的样式影响时才会禁止脚本。</p><ul><li>不阻塞 DOM 的解析：</li></ul><p><strong>原因</strong>：DOM 解析和 CSS 解析是两个并行的线程。</p><p>（3）、优化核心概念：尽可能快的提高外部 css 加载速度。</p><ul><li><p>使用 CDN 节点进行外部资源打包；</p></li><li><p>对 css 进行压缩（利用打包工具，比如 webpack，glup 等；</p></li><li><p>减少对 http 请求数量，将多个 css 文件合并；</p></li><li><p>优化样式的代码。</p></li></ul><p>（4）js 阻塞：</p><ul><li>阻塞 DOM 解析：</li></ul><p><strong>原因</strong>：浏览器不知道后续脚本的内容，如果先去解析了下面的 DOM，而随后 js 删除了后面的所有 DOM，做了无用功。浏览器无法预估脚本具体做了什么操作，索性全部暂停，等脚本执行完，浏览器再继续向下解析。</p><ul><li>阻塞页面的渲染：</li></ul><p><strong>原因</strong>：js 中也可以给 DOM 设置样式，浏览器同样等该脚本执行完再继续干活，避免做无用功。</p><ul><li>阻塞后续 js 的执行：</li></ul><p><strong>原因</strong>：维护依赖关系，例如：必须先引入 jQuery 再引入 bootstrap。</p><ul><li>如果 script 脚本加了 defer：浏览器会发送请求加载 js，但是不会阻塞 DOM 解析，等 DOM 解析完，再执行 js。</li><li>如果 script 加了 async：浏览器会发送请求加载 js，不阻塞 DOM 解析，等 js 加载过来了，就先停止 DOM 解析，去执行 js（谁先回来先执行谁），等 js 执行完，继续 DOM 解析。</li></ul><h3 id="渲染过程优化"><a href="#渲染过程优化" class="headerlink" title="渲染过程优化"></a>渲染过程优化</h3><p>（1）标签语义化（使用合适的标签，如果不是 w3c 规定的标签，Tocken 令牌和词法解析语法得识别分析，是不是 wc3 规定的）<br>（2）减少标签嵌套（生成结构树嵌套太多，就得递归（在 DOM 树构建时候快可以一点）<br>（3）样式尽可能少的层级嵌套（使用与编译器的时候，层级嵌套要慎用。CSS 选择器渲染从右到左，.box a{}会 比 a{} 慢<br>（4）尽早把 CSS 下载到客户端（充分利用 HTTP 多请求并发机制）<br>（5）避免阻塞 js 放在底部<br>（6）减少回流</p><ul><li><p>放弃传统操作 DOM 时代，基于 vue/react 开始数据影响试图模式</p></li><li><p>样式集中改变</p></li><li><p>缓存布局信息，</p></li><li><p>动画效果应用到 position 属性为 absolute 或 fixed 的元素上（脱离文档流）</p></li><li><p>CSS3 硬件加速（比起考虑如何减少回流重绘，更期望不要回流重绘：transform、opacity、filters 这些属性会触发硬件加速，不会引发回流重绘（过多使用占用大量内存，性能消耗严重</p></li><li><p>避免使用 table 布局和使用 css 的 js 表达式</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 👨‍💻Web开发 </category>
          
          <category> Web性能优化方案 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[转]浏览器工作原理</title>
      <link href="/blog/vkgoaq/"/>
      <url>/blog/vkgoaq/</url>
      
        <content type="html"><![CDATA[<p>参考：</p><ul><li><a href="https://www.yuque.com/handshell/kygzse">https://www.yuque.com/handshell/kygzse</a></li></ul><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>网络浏览器很可能是使用最广的软件。在这篇入门文章中，我将会介绍它们的幕后工作原理。我们会了解到，从您在地址栏输入 google.com 直到您在浏览器屏幕上看到 Google 首页的整个过程中都发生了些什么。</p><h2 id="浏览器的主要功能"><a href="#浏览器的主要功能" class="headerlink" title="浏览器的主要功能"></a>浏览器的主要功能</h2><p>浏览器的主要功能就是向服务器发出请求，在浏览器窗口中展示您选择的网络资源。这里所说的资源一般是指 HTML 文档，也可以是 PDF、图片或其他的类型。资源的位置由用户使用 URI（统一资源标示符）指定。<br>浏览器解释并显示 HTML 文件的方式是在 HTML 和 CSS 规范中指定的。这些规范由网络标准化组织 W3C（万维网联盟）进行维护。<br>多年以来，各浏览器都没有完全遵从这些规范，同时还在开发自己独有的扩展程序，这给网络开发人员带来了严重的兼容性问题。如今，大多数的浏览器都是或多或少地遵从规范。<br>浏览器的用户界面有很多彼此相同的元素，其中包括：</p><ul><li>用来输入 URI 的地址栏</li><li>前进和后退按钮</li><li>书签设置选项</li><li>用于刷新和停止加载当前文档的刷新和停止按钮</li><li>用于返回主页的主页按钮</li></ul><p>奇怪的是，浏览器的用户界面并没有任何正式的规范，这是多年来的最佳实践自然发展以及彼此之间相互模仿的结果。HTML5 也没有定义浏览器必须具有的用户界面元素，但列出了一些通用的元素，例如地址栏、状态栏和工具栏等。当然，各浏览器也可以有自己独特的功能，比如 Firefox 的下载管理器。</p><h2 id="浏览器的高层结构"><a href="#浏览器的高层结构" class="headerlink" title="浏览器的高层结构"></a>浏览器的高层结构</h2><p>浏览器的主要组件为</p><ol><li>用户界面 - 包括地址栏、前进/后退按钮、书签菜单等。除了浏览器主窗口显示的您请求的页面外，其他显示的各个部分都属于用户界面。</li><li>浏览器引擎 - 在用户界面和呈现引擎之间传送指令。</li><li>呈现引擎 - 负责显示请求的内容。如果请求的内容是 HTML，它就负责解析 HTML 和 CSS 内容，并将解析后的内容显示在屏幕上。</li><li>网络 - 用于网络调用，比如 HTTP 请求。其接口与平台无关，并为所有平台提供底层实现。</li><li>用户界面后端 - 用于绘制基本的窗口小部件，比如组合框和窗口。其公开了与平台无关的通用接口，而在底层使用操作系统的用户界面方法。</li><li>JavaScript 解释器。用于解析和执行 JavaScript 代码。</li><li>数据存储。这是持久层。浏览器需要在硬盘上保存各种数据，例如 Cookie。新的 HTML 规范 (HTML5) 定义了“网络数据库”，这是一个完整（但是轻便）的浏览器内数据库。</li></ol><p><a href="https://blog.towavephone.com/static/2021-07-20-01-39-18-4d2efb6ba6e0c185fa557cbfdc53ca2c-28759.png"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1647955363695-c77ab531-56d2-4703-b760-10b2a357e13e.png#clientId=uc400c82a-3f9e-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u221cabc3&margin=%5Bobject%20Object%5D&name=image.png&originHeight=339&originWidth=500&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=36952&status=done&style=none&taskId=u012e302c-b9b4-484f-ac4b-e7146dfcef8&title=" alt="image.png"></a><br>值得注意的是，和大多数浏览器不同，Chrome 浏览器的每个标签页都分别对应一个呈现引擎实例。每个标签页都是一个独立的进程。</p><h1 id="呈现引擎"><a href="#呈现引擎" class="headerlink" title="呈现引擎"></a>呈现引擎</h1><p>呈现引擎的作用就是在浏览器的屏幕上显示请求的内容。<br>默认情况下，呈现引擎可显示 HTML 和 XML 文档与图片。通过插件（或浏览器扩展程序），还可以显示其他类型的内容；例如，使用 PDF 查看器插件就能显示 PDF 文档。但是在本章中，我们将集中介绍其主要用途：显示使用 CSS 格式化的 HTML 内容和图片。<br>本文所讨论的浏览器（Firefox、Chrome 浏览器和 Safari）是基于两种呈现引擎构建的。Firefox 使用的是 Gecko，这是 Mozilla 公司“自制”的呈现引擎。而 Safari 和 Chrome 浏览器使用的都是 WebKit。<br>WebKit 是一种开放源代码呈现引擎，起初用于 Linux 平台，随后由 Apple 公司进行修改，从而支持苹果机和 Windows。</p><h2 id="主流程"><a href="#主流程" class="headerlink" title="主流程"></a>主流程</h2><p>呈现引擎一开始会从网络层获取请求文档的内容，内容的大小一般限制在 8000 个块以内。<br>然后进行如下所示的基本流程：<br><a href="https://blog.towavephone.com/static/2021-07-20-01-41-38-dba2da5da3c0b45fb5977e4418996051-81a6c.png"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1647955363670-09c68a6a-43bf-4918-bcec-1b15f46e982d.png#clientId=uc400c82a-3f9e-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=uaff40621&margin=%5Bobject%20Object%5D&name=image.png&originHeight=66&originWidth=600&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=10520&status=done&style=none&taskId=ue57464f3-8438-41ec-b7cb-30eb2f80f85&title=" alt="image.png"></a><br>呈现引擎将开始解析 HTML 文档，并将各标记逐个转化成“内容树”上的 DOM 节点。同时也会解析外部 CSS 文件以及样式元素中的样式数据。HTML 中这些带有视觉指令的样式信息将用于创建另一个树结构：呈现树。<br>呈现树包含多个带有视觉属性（如颜色和尺寸）的矩形。这些矩形的排列顺序就是它们将在屏幕上显示的顺序。<br>呈现树构建完毕之后，进入“布局”处理阶段，也就是为每个节点分配一个应出现在屏幕上的确切坐标。下一个阶段是绘制 - 呈现引擎会遍历呈现树，由用户界面后端层将每个节点绘制出来。<br>需要着重指出的是，这是一个渐进的过程。为达到更好的用户体验，呈现引擎会力求尽快将内容显示在屏幕上。它不必等到整个 HTML 文档解析完毕之后，就会开始构建呈现树和设置布局。在不断接收和处理来自网络的其余内容的同时，呈现引擎会将部分内容解析并显示出来。</p><h2 id="主流程示例"><a href="#主流程示例" class="headerlink" title="主流程示例"></a>主流程示例</h2><p><a href="https://blog.towavephone.com/static/2021-07-20-01-43-09-b2b81d9cf1c9a7547a05e02c3d96d537-37d31.png"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1647955363669-1f06ef06-1aff-4c66-9d0c-8a80cc24a0d2.png#clientId=uc400c82a-3f9e-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u8697360d&margin=%5Bobject%20Object%5D&name=image.png&originHeight=289&originWidth=624&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=28085&status=done&style=none&taskId=u9381c05a-237e-4d56-b3af-5f49683f8f1&title=" alt="image.png"></a><br><a href="https://blog.towavephone.com/static/2021-07-20-01-43-20-b62fa3cb50eec54e4215a86e1ce83f85-37d31.png"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1647955363715-948ad36b-e794-4de4-aabd-c2d6ffd71247.png#clientId=uc400c82a-3f9e-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u1c601d5c&margin=%5Bobject%20Object%5D&name=image.png&originHeight=290&originWidth=624&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&size=79469&status=done&style=none&taskId=u2844d0a0-2d9b-43f6-b860-c0797577bcf&title=" alt="image.png"></a><br>可以看出，虽然 WebKit 和 Gecko 使用的术语略有不同，但整体流程是基本相同的。<br>Gecko 将视觉格式化元素组成的树称为“框架树”。每个元素都是一个框架。WebKit 使用的术语是“呈现树”，它由“呈现对象”组成。对于元素的放置，WebKit 使用的术语是“布局”，而 Gecko 称之为“重排”。<br>对于连接 DOM 节点和可视化信息从而创建呈现树的过程，WebKit 使用的术语是“附加”。有一个细微的非语义差别，就是 Gecko 在 HTML 与 DOM 树之间还有一个称为“内容槽”的层，用于生成 DOM 元素。我们会逐一论述流程中的每一部分：</p>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Ant Design Vue</title>
      <link href="/blog/qnrknt/"/>
      <url>/blog/qnrknt/</url>
      
        <content type="html"><![CDATA[<h2 id="ant-design-vue-UI-库的引入与使用"><a href="#ant-design-vue-UI-库的引入与使用" class="headerlink" title="ant-design-vue UI 库的引入与使用"></a><code>ant-design-vue</code> UI 库的引入与使用</h2><ul><li><code>~~element-plus~~</code><del>：</del><a href="https://element-plus.gitee.io/zh-CN/"><del>https://element-plus.gitee.io/zh-CN/</del></a>（该 UI 库用过，换用一个新的 UI 库使用）</li><li><code>ant-design-vue</code> UI 库：<a href="https://antdv.com/docs/vue/introduce-cn/"><del>https://antdv.com/docs/vue/introduce-cn/</del></a><del>（老版本）</del></li></ul><p>最新版本：<a href="https://next.antdv.com/components/overview-cn">https://next.antdv.com/components/overview-cn</a>[</p><p>](<a href="https://element-plus.gitee.io/zh-CN/">https://element-plus.gitee.io/zh-CN/</a>)<br><code>ant-design-vue</code> UI 库的引入和使用</p><h3 id="全局引入的方式"><a href="#全局引入的方式" class="headerlink" title="全局引入的方式"></a>全局引入的方式</h3><p>在 main.ts 文件中如下修改：</p><pre><code class="typescript">/* * @Descripttion: * @Date: 2021-12-07 10:05:32 * @LastEditTime: 2022-01-10 10:18:18 */import &#123; createApp &#125; from &quot;vue&quot;;import App from &quot;./App.vue&quot;;import router from &quot;./router&quot;;// 全局引入全部组件及样式 ant-design-vue UI库(但是官网不推推荐，影响性能)import Antd from &quot;ant-design-vue&quot;;import &quot;ant-design-vue/dist/antd.css&quot;;createApp(App).use(Antd).use(router).mount(&quot;#app&quot;);</code></pre><p><code>**TODO**</code>**: **全局引入会打包所有 UI 组件，所以采用局部引用的方式来使用</p><h3 id="icon-图标的使用"><a href="#icon-图标的使用" class="headerlink" title="icon 图标的使用"></a>icon 图标的使用</h3><p>需要先下载 相应的包</p><pre><code class="bash">cnpm install --save @ant-design/icons-vue</code></pre><p>然后使用到 icon 的时候，按需导入，上面的组件如果按需导入也是用这种方式，但是组件使用情况比 icon 实用得多，所以全局使用 UI 组件但不全局使用 icon。</p><pre><code class="vue">&lt;template&gt;  &lt;div class=&quot;icons-list&quot;&gt;    &lt;span&gt;icon组件&lt;/span&gt;    &lt;up-circle-two-tone /&gt;    &lt;home-outlined /&gt;    &lt;setting-filled /&gt;    &lt;smile-outlined /&gt;    &lt;sync-outlined spin /&gt;    &lt;smile-outlined :rotate=&quot;180&quot; /&gt;    &lt;loading-outlined /&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot;&gt;import &#123;  UpCircleTwoTone,  HomeOutlined,  SettingFilled,  SmileOutlined,  SyncOutlined,  LoadingOutlined,&#125; from &quot;@ant-design/icons-vue&quot;;&lt;/script&gt;&lt;style scoped&gt;.icons-list :deep(.anticon) &#123;  margin-right: 6px;  font-size: 24px;&#125;&lt;/style&gt;</code></pre><h2 id="定制主题"><a href="#定制主题" class="headerlink" title="定制主题"></a>定制主题</h2><p>参考：</p><ul><li><a href="https://www.jianshu.com/p/a42f58fc3f92">https://www.jianshu.com/p/a42f58fc3f92</a></li><li><a href="https://juejin.cn/post/6962078064364748808">https://juejin.cn/post/6962078064364748808</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 👨‍💻Web开发 </category>
          
          <category> Vue </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>水平/垂直居中总结</title>
      <link href="/blog/dubn5y/"/>
      <url>/blog/dubn5y/</url>
      
        <content type="html"><![CDATA[<h2 id="水平居中"><a href="#水平居中" class="headerlink" title="水平居中"></a>水平居中</h2><h2 id="垂直居中"><a href="#垂直居中" class="headerlink" title="垂直居中"></a>垂直居中</h2><ul><li><a href="https://juejin.cn/post/6844903550909153287">https://juejin.cn/post/6844903550909153287</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 👨‍💻Web开发 </category>
          
          <category> HTML+CSS </category>
          
          <category> 布局 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CSS实现上下浮动动画</title>
      <link href="/blog/pu2dxs/"/>
      <url>/blog/pu2dxs/</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1648018096319-db408c92-c6e3-4678-b773-bf084efbdc41.png#clientId=u5311e561-b968-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=242&id=u0cee8aad&margin=%5Bobject%20Object%5D&name=image.png&originHeight=651&originWidth=1469&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=70128&status=done&style=stroke&taskId=u908458db-f99e-42fe-8d18-e3911d7e633&title=&width=546.015625" alt="image.png"><br>lyrics 项目里面自己设计首页需要当前视窗高度有一个箭头上下浮动的效果，按照如下方式实现：</p><pre><code class="css">.home-row-foward &#123;  animation: heart 0.5s ease-in-out 2.7s infinite alternate;  height: 30px;  font-size: 25px;  color: #1890ff;  text-align: center;  position: relative;  bottom: 25px;&#125;@keyframes heart &#123;  from &#123;    transform: translate(0, 0);  &#125;  to &#123;    transform: translate(0, 15px);  &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 👨‍💻Web开发 </category>
          
          <category> HTML+CSS </category>
          
          <category> 动画 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>模块化（es6+nodejs+typescript）</title>
      <link href="/blog/psazge/"/>
      <url>/blog/psazge/</url>
      
        <content type="html"><![CDATA[<h2 id="es6-模块的导入导出"><a href="#es6-模块的导入导出" class="headerlink" title="es6 模块的导入导出"></a>es6 模块的导入导出</h2><ul><li><a href="https://zhuanlan.zhihu.com/p/60374345">ES6 专题—class 与模块化（10）</a></li></ul><h3 id="export"><a href="#export" class="headerlink" title="export"></a>export</h3><pre><code class="javascript">const checkStr = (str, type) =&gt; &#123;  // 等内容&#125;;module.exports = &#123;  checkStr,&#125;;</code></pre><pre><code class="typescript">export const updateInfo: any = (data: any) =&gt; &#123;  return fetch(&#123;    method: &quot;post&quot;,    url: `/*****************`,    data: data,  &#125;);&#125;;</code></pre><h3 id="import"><a href="#import" class="headerlink" title="import"></a>import</h3><pre><code class="typescript">import fetch from &quot;../utils/fetch&quot;;</code></pre><h3 id="与-class-结合"><a href="#与-class-结合" class="headerlink" title="与 class 结合"></a>与 class 结合</h3><pre><code class="typescript">/* * @Author: wztlink1013 * @Date: 2022-03-09 09:56:11 * @LastEditTime: 2022-03-09 10:22:32 * @Description: */class StorageFn &#123;  ls: Storage;  ss: Storage;  constructor() &#123;    this.ls = window.localStorage;    this.ss = window.sessionStorage;  &#125;  /*设置cookie*/  setCookie(name: any, value: any, day: any) &#123;&#125;  // 等内容&#125;export default StorageFn;</code></pre><h2 id="node-模块的导入导出"><a href="#node-模块的导入导出" class="headerlink" title="node 模块的导入导出"></a>node 模块的导入导出</h2><h3 id="nodejs-不能使用-es6-的模块导入导出"><a href="#nodejs-不能使用-es6-的模块导入导出" class="headerlink" title="nodejs 不能使用 es6 的模块导入导出"></a>nodejs 不能使用 es6 的模块导入导出</h3><p>node.js 使用 commonjs 规范，es6 module 的推出和完善，node 从 v13 开始原生支持 es6 module。</p><p>在 node 环境下是不能使用 es6 语法中 import export 导入导出语法的，解决办法有 babel 转义，或者如下面的一种新方法（需要 Node.js 版本 13.x.x 以上），个人推荐最好还是用 babel 配置 babel 配置文件在转义，因为可以自行一些配置。</p><ul><li>解决方案一：Node.js 版本 13.x.x 以上的版本，使用 <a href="https://nodejs.org/api/esm.html#esm_enabling">官方推荐的方法</a> 在 <code>package.json</code> 文件中设置 <code>&quot;type&quot;: &quot;module&quot;</code>。</li></ul><pre><code class="json">&#123;  &quot;type&quot;: &quot;module&quot;&#125;</code></pre><ul><li>解决方案二：使用 <a href="https://babeljs.io/">babeljs</a> ，然后在项目中添加相关配置即可，具体可以查阅相关教程。</li></ul><h3 id="导入导出"><a href="#导入导出" class="headerlink" title="导入导出"></a>导入导出</h3><p><strong>导出</strong></p><blockquote><p>【第一种方式】</p></blockquote><ul><li>就是在模块里面定义好变量/方法，然后利用 <code>exports.let_1= let_1;</code> <code>exports.fun_1 = fun_1;</code>这种形式，一个个导出</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1618149585979-d1ff5498-d0e1-46ce-b115-ceeadf7f0df9.png#crop=0&crop=0&crop=1&crop=1&height=150&id=wPvzv&margin=%5Bobject%20Object%5D&name=image.png&originHeight=300&originWidth=865&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=23380&status=done&style=none&title=&width=432.5" alt="image.png"></p><blockquote><p>【第二种方式】module.exports.version = version;</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1618149597438-9300a103-0fd7-42df-9307-06079ef423c0.png#crop=0&crop=0&crop=1&crop=1&height=98&id=GcxFA&margin=%5Bobject%20Object%5D&name=image.png&originHeight=196&originWidth=844&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=15904&status=done&style=none&title=&width=422" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1618149609536-ea32c674-9e2d-48fb-92bc-d2c7bf0d294c.png#crop=0&crop=0&crop=1&crop=1&height=220&id=uO0Zi&margin=%5Bobject%20Object%5D&name=image.png&originHeight=440&originWidth=931&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=27252&status=done&style=none&title=&width=465.5" alt="image.png"><br><strong>导入</strong><br>const a = require(‘文件路径’);</p><h3 id="模块的查找规则"><a href="#模块的查找规则" class="headerlink" title="模块的查找规则"></a>模块的查找规则</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1618118075531-995293d3-ee92-4f22-a49c-cb5114639b20.png#crop=0&crop=0&crop=1&crop=1&height=204&id=IaKuE&margin=%5Bobject%20Object%5D&name=image.png&originHeight=408&originWidth=864&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=43167&status=done&style=stroke&title=&width=432" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1618118082503-8414faae-297b-4cd7-a304-c80f7a635a35.png#crop=0&crop=0&crop=1&crop=1&height=216&id=SJfTf&margin=%5Bobject%20Object%5D&name=image.png&originHeight=432&originWidth=769&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=35142&status=done&style=stroke&title=&width=384.5" alt="image.png"></p><h2 id="ts-的模块导入导出"><a href="#ts-的模块导入导出" class="headerlink" title="ts 的模块导入导出"></a>ts 的模块导入导出</h2><ul><li><a href="https://blog.csdn.net/qq_43340929/article/details/107034432">TypeScript 模块导入终极解决方案</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 👨‍💻Web开发 </category>
          
          <category> JavaScript+DOM+BOM+TS </category>
          
          <category> ECMAScript </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>696. 计数二进制子串🔖字符串</title>
      <link href="/blog/sueiwv/"/>
      <url>/blog/sueiwv/</url>
      
        <content type="html"><![CDATA[<p>题目链接：</p><ul><li><a href="https://leetcode-cn.com/problems/count-binary-substrings/">https://leetcode-cn.com/problems/count-binary-substrings/</a></li></ul><h3 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h3><ul><li>数学规律就是将字符串按照<strong>一整个 0 或 1</strong>切割开来，将其放入数组 arr，然后 arr 中相邻的元素（字符串）进行字符串长度比较大小，取小的，最后所有相邻的元素比较后的所有相加就是所需结果</li><li>将字符串按照<strong>一整个 0 或 1</strong>切割开来：先对字符串遍历，找到异元素，记录其下标，存为数组 arr；然后利用 splice 方法＋ arr 数组进行切割为目标数组</li></ul><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>将上述解决思路用代码实现如下：</p><pre><code class="typescript">function countBinarySubstrings(s: string): number &#123;  let flag: string = s[0];  let arr: number[] = [];  let arr_target: string[] = [];  for (let i: number = 0; i &lt; s.length; i++) &#123;    if (s[i] !== flag) &#123;      arr.push(i);      flag = s[i];    &#125;  &#125;  arr.forEach((data: number, index: number) =&gt; &#123;    if (index === 0) &#123;      arr_target.push(String(s.slice(0, data)));      // 分割数组只有一个元素情况下      if (arr.length === 1) arr_target.push(String(s.slice(data, s.length)));    &#125; else if (index === arr.length - 1) &#123;      arr_target.push(String(s.slice(arr[index - 1], data)));      arr_target.push(String(s.slice(data, s.length)));    &#125; else &#123;      arr_target.push(String(s.slice(arr[index - 1], data)));    &#125;  &#125;);  let result: number = 0;  arr_target.forEach((data: string, index: number) =&gt; &#123;    if (index &lt; arr_target.length - 1)      result += Math.min(        String(data).length,        String(arr_target[index + 1]).length      );  &#125;);  return result;&#125;console.log(countBinarySubstrings(&quot;1100&quot;));</code></pre><ul><li><strong>对上述逻辑的小优化</strong>：上面是利用 arr 还转换为原只含 0、1 的数组，但是可以利用 arr 直接进行求算结果</li></ul><pre><code class="typescript">function countBinarySubstrings(s: string): number &#123;  let flag: string = s[0];  let arr: number[] = [];  let result: number = 0;  for (let i: number = 0; i &lt; s.length; i++) &#123;    if (s[i] !== flag) &#123;      arr.push(i);      flag = s[i];    &#125;  &#125;  arr.forEach((data: number, index: number) =&gt; &#123;    if (index === 0) &#123;      arr.length === 1        ? (result += Math.min(data, s.length - data))        : (result += Math.min(data, arr[index + 1] - data));    &#125; else if (index === arr.length - 1) &#123;      result += Math.min(data - arr[index - 1], s.length - data);    &#125; else &#123;      result += Math.min(arr[index + 1] - data, data - arr[index - 1]);    &#125;  &#125;);  return result;&#125;</code></pre><p>最后优化效果如下<br><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1647944556161-5866cbd8-f97b-4fdc-9e84-9d3dc2ebc571.png#clientId=u63694f82-525a-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=167&id=u40ceee23&margin=%5Bobject%20Object%5D&name=image.png&originHeight=201&originWidth=840&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=27060&status=done&style=none&taskId=u32cfc997-d854-44bf-a820-a1392b62eb0&title=&width=699.9999721845002" alt="image.png"></p><h3 id="优化方案"><a href="#优化方案" class="headerlink" title="优化方案"></a>优化方案</h3><p>在官网解决方案中，看到其他的解决方案：</p><h4 id="利用正则表达式来切换原字符串"><a href="#利用正则表达式来切换原字符串" class="headerlink" title="利用正则表达式来切换原字符串"></a>利用正则表达式来切换原字符串</h4><pre><code class="typescript">s.match(/([1]+)|([0]+)/g);</code></pre><p>上面的正则表达式就能实现如下效果…………</p><pre><code class="javascript">[&quot;00&quot;, &quot;11&quot;, &quot;00&quot;, &quot;11&quot;];</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/1484158/1647945287324-1f4f1d3f-6731-4794-a023-ba9ebb97397c.jpeg#crop=0&crop=0&crop=1&crop=1&id=BFxC7&originHeight=75&originWidth=75&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&title=">正则表达式太重要了！！<br>得到上述数组再进行数组内相邻元素比较元素字符串长度取小值，然后相加，类似上面方法即可。</p>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 📶线结构：字符串-数组-栈-队列 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>TypeScript笔记</title>
      <link href="/blog/xigb8k/"/>
      <url>/blog/xigb8k/</url>
      
        <content type="html"><![CDATA[<h3 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h3><p>安装：<code>npm install -g typescript</code><br>编译：<code>tsc helloworld.ts</code></p><p>学习网站：</p><ul><li><a href="https://www.tslang.cn/docs/home.html">https://www.tslang.cn/docs/home.html</a></li><li><a href="https://ts.xcatliu.com/introduction/what-is-typescript.html">https://ts.xcatliu.com/introduction/what-is-typescript.html</a></li><li><a href="https://segmentfault.com/a/1190000038959316">https://segmentfault.com/a/1190000038959316</a></li></ul><p>相关教程：</p><ul><li><a href="https://www.cnblogs.com/wisewrong/p/13717287.html">Vue3.x 从零开始（一）—— Vue-cli or Vite 构建 TypeScript 项目</a></li><li><a href="https://segmentfault.com/a/1190000019661168">在 Typescript 项目中，如何优雅的使用 ESLint 和 Prettier</a></li><li><a href="https://segmentfault.com/a/1190000022809326">了不起的 tsconfig.json 指南</a></li><li><a href="https://cn.eslint.org/">官网：ESLint 可组装的 JavaScript 和 JSX 检查工具</a></li><li><a href="https://www.jianshu.com/p/ad1e46faaea2">Eslint 超简单入门教程</a></li><li><a href="https://segmentfault.com/a/1190000020168436">在 Vue 项目中使用 Eslint+Prettier+Stylelint</a></li><li><a href="https://segmentfault.com/a/1190000019905650">使用 Vue-cli3 搭建 Vue+TypeScript 项目</a></li><li><a href="https://www.cnblogs.com/suwanbin/p/13583717.html">prettier - vscode 保存代码自动格式化插件安装与配置项备注</a></li></ul><h3 id="ts-遍历对象"><a href="#ts-遍历对象" class="headerlink" title="ts 遍历对象"></a>ts 遍历对象</h3><p>ts 遍历对象不要使用<code>for···in</code>，使用<code>for···of</code></p><ul><li>理由：<a href="https://stackoverflow.com/questions/65300784/declare-key-type-of-for-in-loop-in-typescript">https://stackoverflow.com/questions/65300784/declare-key-type-of-for-in-loop-in-typescript</a></li><li>遍历的其他方式参考：<a href="https://juejin.cn/post/6844904147146260488">TypeScript 小状况之遍历对象属性</a></li></ul><pre><code class="typescript">const disabled = computed(() =&gt; &#123;  let flag = true;  for (const [key, val] of Object.entries(formState)) &#123;    if (!val) &#123;      flag = true;      break;    &#125; else &#123;      flag = false;    &#125;  &#125;  return flag;&#125;);</code></pre><h3 id="nodemon-运行-ts-文件"><a href="#nodemon-运行-ts-文件" class="headerlink" title="nodemon 运行 ts 文件"></a>nodemon 运行 ts 文件</h3><ul><li>参考：<a href="https://juejin.cn/post/7035637086451400734">https://juejin.cn/post/7035637086451400734</a></li><li>todo：关于 ts 的配置文件，不是很清楚</li></ul><h3 id="vue3-选项式-API"><a href="#vue3-选项式-API" class="headerlink" title="vue3 选项式 API"></a>vue3 选项式 API</h3><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1656489860490-7ceda888-678e-400e-86ce-b8b5eb752b26.png#clientId=ueb506ba7-0e43-4&crop=0&crop=0&crop=1&crop=1&from=drop&id=u38d89f0f&margin=%5Bobject%20Object%5D&name=ac11d2dd93fe10cdd518b85158a67ade.png&originHeight=631&originWidth=1549&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=150769&status=done&style=none&taskId=uf2f826f4-92f2-4505-b45f-1c8e7b7b9d3&title=" alt="ac11d2dd93fe10cdd518b85158a67ade.png"></p><h2 id="报错："><a href="#报错：" class="headerlink" title="报错："></a>报错：</h2><h3 id="类型“string-null”的参数不能赋给类型“string”的参数。-不能将类型“null”分配给类型“string”"><a href="#类型“string-null”的参数不能赋给类型“string”的参数。-不能将类型“null”分配给类型“string”" class="headerlink" title="类型“string | null”的参数不能赋给类型“string”的参数。 不能将类型“null”分配给类型“string”"></a>类型“string | null”的参数不能赋给类型“string”的参数。 不能将类型“null”分配给类型“string”</h3><pre><code>类型“string | null”的参数不能赋给类型“string”的参数。 不能将类型“null”分配给类型“string”</code></pre><p>上面报错是因为 16 行代码之前没有<code>|| &#39;&#39;</code>ts 的赋值较为严格，以此例警戒。</p><ul><li>另外本例子中还需要转换字符串，undefined,null 等转化为””。不然数据回显会显示为 undefined。</li><li>另外还有一个类似问题：<a href="https://segmentfault.com/q/1010000039940940">vue3 中的 reactive 对象赋值问题</a></li></ul><pre><code class="typescript">interface FormState &#123;  input_id: string;  password: string;  remember: boolean;&#125;// undefined,null等转化为&quot;&quot;const praseStrEmpty = (str: any) =&gt; &#123;  if (!str || str == &quot;undefined&quot; || str == &quot;null&quot;) &#123;    return &quot;&quot;;  &#125;  return str;&#125;;let formState = reactive&lt;FormState&gt;(&#123;  input_id: praseStrEmpty(String(route.query.user_id) || &quot;&quot;),  password: praseStrEmpty(String(route.query.password) || &quot;&quot;),  remember: true,&#125;);</code></pre><h3 id="Property-‘replaceAll’-does-not-exist-on-type-‘string’"><a href="#Property-‘replaceAll’-does-not-exist-on-type-‘string’" class="headerlink" title="Property ‘replaceAll’ does not exist on type ‘string’"></a>Property ‘replaceAll’ does not exist on type ‘string’</h3><ul><li>ts 不能使用 js 的 String 的 API：replaceAll 方法</li><li>解决：使用其他字符串 api 来达到该目的，<a href="https://stackoverflow.com/questions/63616486/property-replaceall-does-not-exist-on-type-string">https://stackoverflow.com/questions/63616486/property-replaceall-does-not-exist-on-type-string</a></li><li>todo：可能原因还有可能是自己的配置文件没有配置好</li></ul>]]></content>
      
      
      <categories>
          
          <category> 👨‍💻Web开发 </category>
          
          <category> JavaScript+DOM+BOM+TS </category>
          
          <category> TypeScript </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Express框架</title>
      <link href="/blog/tdgoby/"/>
      <url>/blog/tdgoby/</url>
      
        <content type="html"><![CDATA[<h2 id="express-框架"><a href="#express-框架" class="headerlink" title="express 框架"></a>express 框架</h2><p>express 框架相当于再 http 模块加上一个中间件合集。<strong>中间件</strong>的含义就相当于处理 http 请求的处理函数，而 express 相当于调用多个中间件，这么一个框架。</p><p>参考：</p><ul><li><a href="https://javascript.ruanyifeng.com/nodejs/express.html">Express 框架 来自《JavaScript 标准参考教程（alpha）》，by 阮一峰</a></li><li><a href="https://juejin.cn/post/6844904023380721678">一杯茶的时间，上手 Express 框架开发</a></li></ul><p>相关文档：</p><ul><li><a href="http://expressjs.jser.us/">http://expressjs.jser.us/</a></li></ul><p>项目下载使用：</p><pre><code class="bash">cnpm install express --save</code></pre><h3 id="express-路由结构化"><a href="#express-路由结构化" class="headerlink" title="express 路由结构化"></a>express 路由结构化</h3><p><a href="https://expressjs.com/zh-cn/guide/routing.html">https://expressjs.com/zh-cn/guide/routing.html</a></p><h3 id="express-里-http-createServer"><a href="#express-里-http-createServer" class="headerlink" title="express 里 http.createServer"></a>express 里 http.createServer</h3><pre><code class="javascript">const app = express();app.use(bodyParser.json(&#123; limit: &quot;10mb&quot; &#125;));app.use(  bodyParser.urlencoded(&#123;    extended: false,  &#125;));const server = http.createServer(app);</code></pre><p>第 9 行代码这样写好处有：<br>用 http 封装不但可以使用 express 的属性和方法，而且还可以使用 http 的属性和方法<br>具体可以参考这段讨论：<a href="https://cnodejs.org/topic/5396cd60c3ee0b5820f00e2a">express 里 http.createServer 和 app.listen 有什么区别？</a></p><h3 id="express-常用-API"><a href="#express-常用-API" class="headerlink" title="express 常用 API"></a>express 常用 API</h3><h4 id="use-方法和中间件"><a href="#use-方法和中间件" class="headerlink" title="use 方法和中间件"></a>use 方法和中间件</h4><ul><li>注册中间件，返回的是函数。注意第三个参数 next，如果写<code>next()</code>语句则执行完该中间件，前往下一个中间件执行下一个中间件，如果不写，则执行完该中间件，就停止运行中间件。</li><li>中间件，如果注册了路由，则只显示路由内容，所以使用的时候，中间件的 url 不应该是具体路由，而是一层路由，其他的二层路由则是具体内容路由。</li></ul><pre><code class="javascript">/* * @Author: wztlink1013 * @Date: 2022-01-10 20:15:30 * @LastEditTime: 2022-01-11 10:26:35 * @Description: */let express = require(&quot;express&quot;);let app = express();// 路由app.get(&quot;/&quot;, function (req, res) &#123;  res.send(&quot;Hello world&quot;);&#125;);app.get(&quot;/customer&quot;, function (req, res) &#123;  res.send(&quot;customer page&quot;);&#125;);// app.get(&#39;/admin&#39;, function (req, res) &#123;//   console.log(&#39;----------------------------&#39;)//   res.send(&#39;admin page&#39;)// &#125;)// 中间件// 如果注册了路由，则只显示路由内容app.use(&quot;/admin&quot;, function (request, response, next) &#123;  response.writeHead(200, &#123; &quot;Content-Type&quot;: &quot;text/plain&quot; &#125;);  response.end(&quot;Welcome to the admin page!\n&quot;);&#125;);app.listen(3000);console.log(&quot;to http://localhost:3000/&quot;);</code></pre><h4 id="get-方法"><a href="#get-方法" class="headerlink" title="get 方法"></a>get 方法</h4><ul><li>注册路由，用于指定不同的访问路径所对应的回调函数。由于 get 方法没有 next 回调函数，所以按照执行顺序，当地一个 get 方法执行了（根据匹配成功参数路径），后续的都不会执行了<blockquote><p>put()post()put()del()类似 get()使用（delete 是 JavaScript 保留字，所以改叫 del）</p></blockquote></li></ul><p>对于第一个参数，也就是路径参数，有不同的匹配规则</p><pre><code class="javascript">app.get(&quot;/customer/:who&quot;, function (req, res) &#123;  res.send(&quot;都能访问 /&quot; + req.params.who + &quot; 该路径&quot;);&#125;);</code></pre><p>访问 <a href="http://localhost:3000/customer/fa">http://localhost:3000/customer/fa</a> 返回 <code>都能访问 /fa 该路径</code><br>访问<a href="http://localhost:3000/customer/ad">http://localhost:3000/customer/ad</a> 返回 <code>都能访问 /ad 该路径</code><br>不能访问<a href="http://localhost:3000/customer">http://localhost:3000/customer</a><br>如果是:who? 则成为可选路径</p><h4 id="set-方法"><a href="#set-方法" class="headerlink" title="set 方法"></a>set 方法</h4><ul><li>指定变量的值</li></ul><pre><code class="javascript">// 告诉express框架模板的位置app.set(&quot;views&quot;, path.join(__dirname, &quot;views&quot;));// 告诉express框架模板的默认后缀是什么app.set(&quot;view engine&quot;, &quot;art&quot;);</code></pre><h4 id="response-对象"><a href="#response-对象" class="headerlink" title="response 对象"></a>response 对象</h4><p>response.redirect 方法允许网址的重定向。<br>response.sendFile 方法用于发送文件。<br>response.render 方法用于渲染网页模板。</p><h4 id="request-对象"><a href="#request-对象" class="headerlink" title="request 对象"></a>request 对象</h4><h4 id="搭建-HTTPS-环境"><a href="#搭建-HTTPS-环境" class="headerlink" title="搭建 HTTPS 环境"></a>搭建 HTTPS 环境</h4><p>上传 crt 和 key 文件</p><pre><code class="javascript">var fs = require(&quot;fs&quot;);var options = &#123;  key: fs.readFileSync(&quot;E:/ssl/myserver.key&quot;),  cert: fs.readFileSync(&quot;E:/ssl/myserver.crt&quot;),  passphrase: &quot;1234&quot;,&#125;;var https = require(&quot;https&quot;);var express = require(&quot;express&quot;);var app = express();app.get(&quot;/&quot;, function (req, res) &#123;  res.send(&quot;Hello World Expressjs&quot;);&#125;);var server = https.createServer(options, app);server.listen(8084);console.log(&quot;Server is running on port 8084&quot;);</code></pre><h3 id="express-写-API-接口"><a href="#express-写-API-接口" class="headerlink" title="express 写 API 接口"></a>express 写 API 接口</h3><h4 id="References"><a href="#References" class="headerlink" title="References"></a>References</h4><ul><li><a href="https://blog.csdn.net/m0_48375854/article/details/122447235">Node.js—使用 Express 写接口</a></li></ul><h4 id="response-对象-json-方法写接口"><a href="#response-对象-json-方法写接口" class="headerlink" title="response 对象 json 方法写接口"></a>response 对象 json 方法写接口</h4><p>内置 json 响应的方式：</p><pre><code class="javascript">/* * @Author: wztlink1013 * @Date: 2022-01-11 11:04:38 * @LastEditTime: 2022-01-11 11:21:17 * @Description: */let obj = &#123;  1: &#123;    id: 1234,    name: &quot;张三&quot;,    college: &quot;计算机科学与工程学院&quot;,    grade: 2018,    classes: 2,    age: 21,  &#125;,  2: &#123;    id: 5678,    name: &quot;李四&quot;,    college: &quot;计算机科学与工程学院&quot;,    grade: 2018,    classes: 2,    age: 21,  &#125;,&#125;;exports.index = function (req, res) &#123;  res.status(200).json(obj);&#125;;</code></pre><pre><code class="javascript">// 接口的使用let userinfo = require(&quot;./api/userinfo.js&quot;);app.get(&quot;/api/userinfo&quot;, userinfo.index);</code></pre><h4 id="js-使用接口的一些方法"><a href="#js-使用接口的一些方法" class="headerlink" title="js 使用接口的一些方法"></a>js 使用接口的一些方法</h4><ul><li>用之前总结的使用接口一些方法：<a href="https://github.com/wztlink1013/web-learn-notes/tree/gh-pages/learn-interface">https://github.com/wztlink1013/web-learn-notes/tree/gh-pages/learn-interface</a></li></ul><h4 id="跨域问题的解决"><a href="#跨域问题的解决" class="headerlink" title="跨域问题的解决"></a>跨域问题的解决</h4><p>解法一：手写（但是有看到网上说会有设备（iPhone6）不兼容等问题）</p><pre><code class="javascript">// 跨域设置app.all(&quot;*&quot;, function (req, res, next) &#123;  res.header(&quot;Access-Control-Allow-Credentials&quot;, true);  res.header(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;);  res.header(&quot;Access-Control-Allow-Headers&quot;, &quot;X-Requested-With&quot;);  res.header(&quot;Access-Control-Allow-Methods&quot;, &quot;PUT,POST,GET,DELETE,OPTIONS&quot;);  res.header(&quot;Content-Type&quot;, &quot;application/json;charset=utf-8&quot;);  next();&#125;);</code></pre><p>解法二：直接使用 npm 里面的 cors 包</p><pre><code class="html">&lt;!-- * @Descripttion: learn axios * @Date: 2021-12-21 09:40:36 * @LastEditTime: 2022-01-11 11:25:28--&gt;&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;  &lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot; /&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;    &lt;title&gt;Document&lt;/title&gt;    &lt;script src=&quot;https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js&quot;&gt;&lt;/script&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;script&gt;      // 配置公共的请求头      axios.defaults.baseURL = &quot;http://localhost:3000/&quot;;      // 配置 超时时间      axios.defaults.timeout = 2500;      // 配置公共的请求头      // axios.defaults.headers.common[&quot;Authorization&quot;] =      //   &quot;token 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&quot;      // axios.defaults.headers.common[&quot;Accept&quot;] = &quot;application/vnd.github.v3+json&quot;      // 配置公共的 post 的 Content-Type      axios.defaults.headers.post[&quot;Content-Type&quot;] = &quot;application/json&quot;;      // 请求/响应 拦截器的配置      axios.interceptors.request.use(        (config) =&gt; &#123;          console.log(&quot;请求拦截器: &quot;);          config.headers.Accept = &quot;application/vnd.github.v3+json&quot;;          config.headers.Authorization =            &quot;token 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&quot;;          console.log(config);          return config;        &#125;,        (err) =&gt; &#123;          console.log(err);        &#125;      );      axios.interceptors.response.use(        (data) =&gt; &#123;          console.log(&quot;响应拦截器: &quot;);          console.log(data.data);          return data.data;        &#125;,        (err) =&gt; &#123;          console.log(err);        &#125;      );      // 请求数据      axios.get(&quot;api/userinfo&quot;).then((data) =&gt; &#123;        console.log(data);      &#125;);    &lt;/script&gt;  &lt;/body&gt;&lt;/html&gt;</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1641872349891-229b5dc9-c17f-4a3b-bbef-98611971015f.png#clientId=u035ff002-183d-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=247&id=g5VY5&margin=%5Bobject%20Object%5D&name=image.png&originHeight=493&originWidth=1139&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=82420&status=done&style=none&taskId=u58281aa0-1b1a-418c-a492-1c313d3b7b6&title=&width=569.5" alt="image.png"></p><h4 id="Postman-测试-API-工具"><a href="#Postman-测试-API-工具" class="headerlink" title="Postman 测试 API 工具"></a>Postman 测试 API 工具</h4><p>如果是本地写的接口，也就是 localhost 类的，在 web postman 上是不能测试的，只能下载 Postman PC 应用来测试。</p><h3 id="body-parser-模块"><a href="#body-parser-模块" class="headerlink" title="body-parser 模块"></a>body-parser 模块</h3><p>body-parser 为 express 框架的中间件，其作用就是对 post 请求的请求体进行解析。<br>下载使用：</p><pre><code class="bash">cnpm install body-parser</code></pre><h4 id="bodyParser-json-与-bodyParser-urlencoded"><a href="#bodyParser-json-与-bodyParser-urlencoded" class="headerlink" title="bodyParser.json( )与 bodyParser.urlencoded( )"></a>bodyParser.json( )与 bodyParser.urlencoded( )</h4><ul><li>limit 参数（json）：控制请求体最大尺寸</li><li>extended 参数（urlencoded）：</li></ul><p><code>extended: false</code>：表示使用系统模块 querystring 来处理，也是官方推荐的<br><code>extended: true</code>：表示使用第三方模块 qs 来处理<br>从功能性来讲，qs 比 querystring 要更强大，所以这里可以根据项目的实际需求来考虑<br>详见：<a href="https://github.com/expressjs/body-parser/#extended">https://github.com/expressjs/body-parser/#extended</a></p><h4 id="References-1"><a href="#References-1" class="headerlink" title="References"></a>References</h4><ul><li><a href="https://github.com/expressjs/body-parser/">https://github.com/expressjs/body-parser/</a></li><li><a href="https://www.cnblogs.com/chyingp/p/nodejs-learning-express-body-parser.html">Nodejs 进阶：Express 常用中间件 body-parser 实现解析 </a></li><li><a href="https://segmentfault.com/a/1190000004407008">bodyParser 中间件的研究</a></li></ul><h3 id="express-session-模块"><a href="#express-session-模块" class="headerlink" title="express-session 模块"></a>express-session 模块</h3><p>设置 Cookie，<code>app.use(session(&#123;secret: &#39;secret key&#39;&#125;));</code><br>当参数为 secret 时候，通过设置的 secret 字符串，来计算 hash 值并放在 cookie 中，使产生的 signedCookie 防篡改</p><p>还有其他的参数：</p><ul><li>name: 设置 cookie 中，保存 session 的字段名称，默认为 connect.sid</li><li>store: session 的存储方式，默认为存放在内存中，我们可以自定义 redis 等</li><li>genid: 生成一个新的 session_id 时，默认为使用 uid2 这个 npm 包</li><li>rolling: 每个请求都重新设置一个 cookie，默认为 false</li><li>resave: 即使 session 没有被修改，也保存 session 值，默认为 true</li><li>saveUninitialized：强制未初始化的 session 保存到数据库</li><li>secret: 通过设置的 secret 字符串，来计算 hash 值并放在 cookie 中，使产生的 signedCookie 防篡改</li><li>cookie : 设置存放 sessionid 的 cookie 的相关选项</li></ul>]]></content>
      
      
      <categories>
          
          <category> 👨‍💻Web开发 </category>
          
          <category> Node.js </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>mongoose操作MongoDB数据库</title>
      <link href="/blog/xfn7hy/"/>
      <url>/blog/xfn7hy/</url>
      
        <content type="html"><![CDATA[<ul><li>GitHub：<a href="https://github.com/Automattic/mongoose">https://github.com/Automattic/mongoose</a></li><li>英文文档：<a href="https://mongoosejs.com/docs/guide.html">https://mongoosejs.com/docs/guide.html</a></li><li>中文文档：<a href="http://www.mongoosejs.net/docs/guide.html">http://www.mongoosejs.net/docs/guide.html</a></li><li><a href="https://zhuanlan.zhihu.com/p/56030432">如何使用 nodejs 写一个接口 - MySQL 版</a></li></ul><p>shardb-mongodb 模块操作数据库不好去使用，比如查询，新建等，所以这个模块只用作 ot 服务那边；<br>另外使用 mongoose 去操作数据库方便写接口</p><ul><li><a href="https://github.com/share/sharedb-mongo">https://github.com/share/sharedb-mongo</a></li><li><a href="https://www.jianshu.com/p/46f06896c9cd">Mongoose 查询结果为空</a></li></ul><p>schema 的相关配置为 connection</p><ul><li>之前的增删改查笔记：<a href="https://github.com/wztlink1013/web-learn-notes/blob/gh-pages/learn-nodejs/express/model/connect.js">https://github.com/wztlink1013/web-learn-notes/blob/gh-pages/learn-nodejs/express/model/connect.js</a></li><li><a href="https://segmentfault.com/a/1190000019201081">mongoose 踩坑笔记： Cannot overwrite `` model once compiled.</a></li></ul><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="MongoDB-以及可视化工具-Navicat"><a href="#MongoDB-以及可视化工具-Navicat" class="headerlink" title="MongoDB 以及可视化工具 Navicat"></a>MongoDB 以及可视化工具 Navicat</h3><p>参考之前写的文章：<a href="https://www.yuque.com/wztlink1013/blog/nwt63v">MongoDB 下载及使用+Navicat 使用+服务器上的配置</a></p><h3 id="安装-mongoose"><a href="#安装-mongoose" class="headerlink" title="安装 mongoose"></a>安装 mongoose</h3><pre><code class="bash">cnpm install mongoose -S</code></pre><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="连接数据库语句"><a href="#连接数据库语句" class="headerlink" title="连接数据库语句"></a>连接数据库语句</h3><pre><code class="javascript">// 连接数据库mongoose  .connect(&quot;mongodb://127.0.0.1:27017/test-mongoose&quot;, &#123;    useNewUrlParser: true,    useUnifiedTopology: true,  &#125;)  .then(() =&gt; &#123;    console.log(&quot;数据库连接成功&quot;);  &#125;)  .catch(() =&gt; &#123;    console.log(&quot;数据库连接失败&quot;);  &#125;);</code></pre><p>然后再将这个 js 文件 require 到 app.js 里面使用</p><pre><code class="javascript">// 数据库连接require(&quot;./model/connect&quot;);</code></pre><h3 id="创建集合"><a href="#创建集合" class="headerlink" title="创建集合"></a>创建集合</h3><ul><li>先利用函数 mongoose 的 schema 函数构建一个规则</li><li>然后利用 model 函数创建一个集合并且用上这个规则</li></ul><pre><code class="javascript">// Schema：数据库集合的结构对象。// 创建一个集合(相当于sql里面的设定一个表)规则let TestSchema = new mongoose.Schema(&#123;  name: &#123; type: String &#125;,  age: &#123; type: Number, default: 0 &#125;,  email: &#123; type: String &#125;,  time: &#123; type: Date, default: Date.now &#125;,&#125;);// Model ：由Schema构造而成，可操作数据库。// 创建一个集合(并且应用上面的规则)let TestModel = mongoose.model(&quot;schema&quot;, TestSchema);</code></pre><h3 id="增加文档"><a href="#增加文档" class="headerlink" title="增加文档"></a>增加文档</h3><ul><li>第一个参数：create 函数</li><li>第二个参数：可以打印相关信息（doc 和 err）</li></ul><pre><code class="javascript">// 创建（创建完执行以便之后就注释掉，不然会一直重复创建）TestModel.create(  [    &#123; name: &#39;test-1&#39;, age: 8 &#125;,    &#123; name: &#39;test-2&#39;, age: 18 &#125;,    &#123; name: &#39;test-3&#39;, age: 28 &#125;,    &#123; name: &#39;test-4&#39;, age: 38 &#125;,    &#123; name: &#39;test-5&#39;, age: 48 &#125;,    &#123; name: &#39;test-6&#39;, age: 58, email: &#39;tttt@qq.com&#39; &#125;,    &#123; name: &#39;test-7&#39;, age: 68, email: &#39;ssss@qq.com&#39; &#125;,    &#123; name: &#39;test-8&#39;, age: 18 &#125;,    &#123; name: &#39;test-9&#39;, age: 18, email: &#39;rrrr@qq.com&#39; &#125;,    &#123; name: &#39;test-10&#39;, age: 18 &#125;,  ],  (error, docs)&#123;    if (error) &#123;      console.log(error)    &#125; else &#123;      console.log(&#39;save ok&#39;)      console.log(docs)    &#125;  &#125;)</code></pre><ul><li>也可以创建一个对象赋值给一个变量，然后该变量利用函数 save 即可保存到数据库<div style="background: #FFF3F3;padding:10px;border: 1px solid #DEB8BE;border-radius:5px;margin-bottom:5px;">创建完执行以便之后就注释掉，不然会一直重复创建</div></li></ul><h3 id="查询文档"><a href="#查询文档" class="headerlink" title="查询文档"></a>查询文档</h3><ul><li>查询函数<code>findOne</code>：返回第一条数据</li><li>查询函数<code>find</code>：查询所有包含条件的数据</li></ul><pre><code class="javascript">// 查询TestModel.find(  // 28&lt;= age &lt;48  &#123; age: &#123; $gte: 28, $lt: 48 &#125; &#125;,  // 1为指定字段，0为排除字段  &#123; name: 1, age: 1, _id: 0 &#125;,  function (err, docs) &#123;    if (err) &#123;      console.log(&quot;查询出错: &quot; + err);    &#125; else &#123;      console.log(&quot;$gte,$lte查询结果为: &quot;);      console.log(docs);    &#125;  &#125;);</code></pre><h3 id="mongoose-条件查询"><a href="#mongoose-条件查询" class="headerlink" title="mongoose 条件查询"></a>mongoose 条件查询</h3><p>键为变量时用<br>中括号括起来就行了</p><pre><code class="javascript">checkStr(data.type_id, &#39;email&#39;)    ? (type_str = &#39;email&#39;)    : (type_str = &#39;user_id&#39;)Model_user.find(&#123; [type_str]: data.type_id &#125;, &#123;&#125;, (err, docs) =&gt; &#123;&#125;</code></pre><p>逻辑查询<br>参考：</p><ul><li>文档：<a href="http://mongoosejs.net/docs/queries.html">http://mongoosejs.net/docs/queries.html</a></li><li><a href="https://segmentfault.com/a/1190000021010300">mongoose 系列之一 find 查询</a></li></ul><pre><code class="javascript">Model_user.find(  &#123; $or: [&#123; email: obj.email &#125;, &#123; user_id: obj.user_id &#125;] &#125;,  &#123;&#125;,  (err, docs) =&gt; &#123;&#125;);</code></pre><h3 id="更新文档"><a href="#更新文档" class="headerlink" title="更新文档"></a>更新文档</h3><p><code>User.updateOne(&#123;查询条件&#125;, &#123;要修改的值&#125;).then(result =&gt; console.log(result))</code></p><ul><li>updateOne：更新单个</li><li>updateMany：更新多个</li></ul><pre><code class="javascript">// 更新let conditions_1 = &#123; name: &quot;test-3&quot; &#125;;let update = &#123; $set: &#123; age: 11 &#125; &#125;;TestModel.updateOne(conditions_1, update, function (error) &#123;  if (error) &#123;    console.log(error);  &#125; else &#123;    console.log(&quot;Update success!&quot;);    TestModel.find(      &#123; name: &quot;test-3&quot; &#125;,      &#123; name: 1, age: 1, _id: 0 &#125;,      function (err, docs) &#123;        if (err) &#123;          console.log(&quot;查询出错: &quot; + err);        &#125; else &#123;          console.log(&quot;更新test-3后的查询结果为: &quot;);          console.log(docs);        &#125;      &#125;    );  &#125;&#125;);</code></pre><h3 id="删除文档"><a href="#删除文档" class="headerlink" title="删除文档"></a>删除文档</h3><ul><li>删除单个：<code>User.findOneAndDelete(&#123;&#125;)then(result =&gt; console.log(result))</code></li><li>删除多个：<code>User.deleteMany(&#123;&#125;).then(result =&gt; console.log(result))</code></li><li>deleteOne：删除单个</li></ul><pre><code class="javascript">// 删除let conditions_2 = &#123; name: &quot;test-2&quot; &#125;;TestModel.deleteOne(conditions_2, function (error) &#123;  if (error) &#123;    console.log(error);  &#125; else &#123;    console.log(&quot;Delete success!&quot;);    TestModel.find(      &#123; name: &quot;test-2&quot; &#125;,      &#123; name: 1, age: 1, _id: 0 &#125;,      function (err, docs) &#123;        if (err) &#123;          console.log(&quot;查询出错: &quot; + err);        &#125; else &#123;          console.log(&quot;删除test-2后的查询结果为: &quot;);          console.log(docs);        &#125;      &#125;    );  &#125;&#125;);</code></pre><h3 id="mongoose-验证"><a href="#mongoose-验证" class="headerlink" title="mongoose 验证"></a>mongoose 验证</h3><p>required: true 必传字段<br>minlength：3 字符串最小长度<br>maxlength: 20 字符串最大长度<br>min: 2 数值最小为 2<br>max: 100 数值最大为 100<br>enum: [‘html’, ‘css’, ‘javascript’, ‘node.js’]<br>trim: true 去除字符串两边的空格<br>validate: 自定义验证器<br>default: 默认值</p><p>获取错误信息：error.errors[‘字段名称’].message</p><h3 id="整体代码"><a href="#整体代码" class="headerlink" title="整体代码"></a>整体代码</h3><pre><code class="javascript">/* * @Author: wztlink1013 * @Date: 2022-01-11 12:43:02 * @LastEditTime: 2022-01-11 16:44:13 * @Description: */const mongoose = require(&quot;mongoose&quot;);// 连接数据库mongoose  .connect(&quot;mongodb://127.0.0.1:27017/test-mongoose&quot;, &#123;    useNewUrlParser: true,    useUnifiedTopology: true,  &#125;)  .then(() =&gt; &#123;    console.log(&quot;数据库连接成功&quot;);  &#125;)  .catch(() =&gt; &#123;    console.log(&quot;数据库连接失败&quot;);  &#125;);// Schema：数据库集合的结构对象。let TestSchema = new mongoose.Schema(&#123;  name: &#123; type: String &#125;,  age: &#123; type: Number, default: 0 &#125;,  email: &#123; type: String &#125;,  time: &#123; type: Date, default: Date.now &#125;,&#125;);// Model ：由Schema构造而成，可操作数据库。let TestModel = mongoose.model(&quot;schema&quot;, TestSchema);// Entity：由Model创建的实体，可操作数据库。// let TestEntity = new TestModel(&#123;//   name: &#39;helloworld&#39;,//   age: 28,//   email: &#39;helloworld@qq.com&#39;,// &#125;)// console.log(TestEntity)// 创建（创建完执行以便之后就注释掉，不然会一直重复创建）// TestModel.create(//   [//     &#123; name: &#39;test-1&#39;, age: 8 &#125;,//     &#123; name: &#39;test-2&#39;, age: 18 &#125;,//     &#123; name: &#39;test-3&#39;, age: 28 &#125;,//     &#123; name: &#39;test-4&#39;, age: 38 &#125;,//     &#123; name: &#39;test-5&#39;, age: 48 &#125;,//     &#123; name: &#39;test-6&#39;, age: 58, email: &#39;tttt@qq.com&#39; &#125;,//     &#123; name: &#39;test-7&#39;, age: 68, email: &#39;ssss@qq.com&#39; &#125;,//     &#123; name: &#39;test-8&#39;, age: 18 &#125;,//     &#123; name: &#39;test-9&#39;, age: 18, email: &#39;rrrr@qq.com&#39; &#125;,//     &#123; name: &#39;test-10&#39;, age: 18 &#125;,//   ],//   function (error, docs) &#123;//     if (error) &#123;//       console.log(error)//     &#125; else &#123;//       // console.log(&#39;save ok&#39;)//       // console.log(docs)//     &#125;//   &#125;// )// 查询TestModel.find(  // 28&lt;= age &lt;48  &#123; age: &#123; $gte: 28, $lt: 48 &#125; &#125;,  // 1为指定字段，0为排除字段  &#123; name: 1, age: 1, _id: 0 &#125;,  function (err, docs) &#123;    if (err) &#123;      console.log(&quot;查询出错: &quot; + err);    &#125; else &#123;      console.log(&quot;$gte,$lte查询结果为: &quot;);      console.log(docs);    &#125;  &#125;);// 更新let conditions_1 = &#123; name: &quot;test-3&quot; &#125;;let update = &#123; $set: &#123; age: 11 &#125; &#125;;TestModel.updateOne(conditions_1, update, function (error) &#123;  if (error) &#123;    console.log(error);  &#125; else &#123;    console.log(&quot;Update success!&quot;);    TestModel.find(      &#123; name: &quot;test-3&quot; &#125;,      &#123; name: 1, age: 1, _id: 0 &#125;,      function (err, docs) &#123;        if (err) &#123;          console.log(&quot;查询出错: &quot; + err);        &#125; else &#123;          console.log(&quot;更新test-3后的查询结果为: &quot;);          console.log(docs);        &#125;      &#125;    );  &#125;&#125;);// 删除let conditions_2 = &#123; name: &quot;test-2&quot; &#125;;TestModel.deleteOne(conditions_2, function (error) &#123;  if (error) &#123;    console.log(error);  &#125; else &#123;    console.log(&quot;Delete success!&quot;);    TestModel.find(      &#123; name: &quot;test-2&quot; &#125;,      &#123; name: 1, age: 1, _id: 0 &#125;,      function (err, docs) &#123;        if (err) &#123;          console.log(&quot;查询出错: &quot; + err);        &#125; else &#123;          console.log(&quot;删除test-2后的查询结果为: &quot;);          console.log(docs);        &#125;      &#125;    );  &#125;&#125;);</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1641879796743-f8670ed9-0562-4e6d-ab68-79418d34424f.png#clientId=u035ff002-183d-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=161&id=ddiif&margin=%5Bobject%20Object%5D&name=image.png&originHeight=180&originWidth=417&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=19710&status=done&style=none&taskId=u01a137ea-d112-4f6a-9da7-0839bf010ee&title=&width=373.49537658691406" alt="image.png"></p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul><li><a href="https://blog.csdn.net/youhebuke225/article/details/106872122">mongoose 查询到的对象无法读取问题</a></li></ul><h3 id="mongodb-创建集合"><a href="#mongodb-创建集合" class="headerlink" title="mongodb 创建集合"></a>mongodb 创建集合</h3>]]></content>
      
      
      <categories>
          
          <category> 👨‍💻Web开发 </category>
          
          <category> DataBase </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>校内实习Springboot+Ajax全栈在线考试管理系统</title>
      <link href="/blog/aeavli/"/>
      <url>/blog/aeavli/</url>
      
        <content type="html"><![CDATA[<p>校内实习笔记</p><h2 id="开发环境搭建"><a href="#开发环境搭建" class="headerlink" title="开发环境搭建"></a>开发环境搭建</h2><h3 id="MySQL-下载安装"><a href="#MySQL-下载安装" class="headerlink" title="MySQL 下载安装"></a>MySQL 下载安装</h3><ul><li>下载地址：<a href="https://www.mysql.com/downloads/">https://www.mysql.com/downloads/</a></li><li>安装下载教程：<a href="https://blog.csdn.net/Kindergarten_Sir/article/details/109274396">MySQL 的下载与安装教程–超详细</a></li></ul><p>成功如下：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1645420397245-3062da09-70ef-47cb-94a0-1169ed942a1a.png#clientId=u61daa6fb-d0f7-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=196&id=uf3cb7e10&margin=%5Bobject%20Object%5D&name=image.png&originHeight=235&originWidth=948&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=41454&status=done&style=none&taskId=u2c07a817-8c45-4ee1-a214-f6022e12f92&title=&width=789.9999686082217" alt="image.png"><br>再配置环境变量（和 java 环境变量配置一样）<br><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1645670861710-ec8aa52e-ae51-41d7-a008-03b385f5a189.png#clientId=u02cea811-d019-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=62&id=u53489e49&margin=%5Bobject%20Object%5D&name=image.png&originHeight=74&originWidth=692&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=7708&status=done&style=none&taskId=u08c21228-4db6-4efb-8be4-44575114afb&title=&width=576.666643751993" alt="image.png"></p><h3 id="IDEA-下载安装"><a href="#IDEA-下载安装" class="headerlink" title="IDEA 下载安装"></a>IDEA 下载安装</h3><p>IDEA 下载：<a href="https://www.jetbrains.com.cn/idea/download/#section=windows">https://www.jetbrains.com.cn/idea/download/#section=windows</a></p><h3 id="java-下载安装"><a href="#java-下载安装" class="headerlink" title="java 下载安装"></a>java 下载安装</h3><p>需要下载 1.8 版本的，之前版本删掉<br><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1645497764451-167842e2-5328-446e-bf72-a806cd4ba938.png#clientId=u7736cca5-9ead-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=152&id=u7491a2a7&margin=%5Bobject%20Object%5D&name=image.png&originHeight=182&originWidth=815&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=24417&status=done&style=none&taskId=u66b09438-d2f2-437d-b150-d080616aa26&title=&width=679.1666396790091" alt="image.png"></p><h3 id="Maven-下载安装"><a href="#Maven-下载安装" class="headerlink" title="Maven 下载安装"></a>Maven 下载安装</h3><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1645495772713-46fcc17d-68a0-4c2a-8901-87bc114cfe59.png#clientId=u7736cca5-9ead-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=164&id=ua6d1ef1a&margin=%5Bobject%20Object%5D&name=image.png&originHeight=197&originWidth=968&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=12023&status=done&style=none&taskId=u85fbae1d-3796-4b30-b03e-1c77721bbcd&title=&width=806.6666346126145" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1645495819742-223ad090-3f07-4b04-95b2-e5262d74b394.png#clientId=u7736cca5-9ead-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=391&id=ue1ef2b60&margin=%5Bobject%20Object%5D&name=image.png&originHeight=469&originWidth=987&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=44112&status=done&style=none&taskId=u452196c4-992d-4dbf-b40c-aba4ff1c9a4&title=&width=822.4999673167878" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1645495723226-f5c72ffc-05cb-4b1c-99dc-cce4ec7667bf.png#clientId=u7736cca5-9ead-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=147&id=u3a1d182d&margin=%5Bobject%20Object%5D&name=image.png&originHeight=177&originWidth=976&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=24020&status=done&style=none&taskId=u21d91f4a-3ea4-479a-b9ba-93299e5c348&title=&width=813.3333010143717" alt="image.png"></p><h2 id="创建-springboot-应用程序"><a href="#创建-springboot-应用程序" class="headerlink" title="创建 springboot 应用程序"></a>创建 springboot 应用程序</h2><h3 id="Maven-模板快速创建项目"><a href="#Maven-模板快速创建项目" class="headerlink" title="Maven 模板快速创建项目"></a>Maven 模板快速创建项目</h3><p>找到下面的选项快速创建<br><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1645496306314-3c77ca31-a9e7-4e1e-96de-4e26ff1a98c6.png#clientId=u7736cca5-9ead-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=807&id=uceef7a43&margin=%5Bobject%20Object%5D&name=image.png&originHeight=969&originWidth=1637&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=789015&status=done&style=none&taskId=u7d8d7c07-cd13-4ac8-a52a-a8ca111d75a&title=&width=1364.1666124595558" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1645496453507-1473a2e0-520a-4d7a-a0b6-cb2723f22ec5.png#clientId=u7736cca5-9ead-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=807&id=u6251fbd7&margin=%5Bobject%20Object%5D&name=image.png&originHeight=969&originWidth=1637&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=295038&status=done&style=none&taskId=ubf04bdd4-1105-4d8c-8df0-2d47b925e34&title=&width=1364.1666124595558" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1645496663531-f043939a-6d4a-4c33-90cf-99ad93d71f0d.png#clientId=u7736cca5-9ead-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=807&id=u5fe0c9bc&margin=%5Bobject%20Object%5D&name=image.png&originHeight=969&originWidth=1637&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=387492&status=done&style=none&taskId=u9e3e0509-5eb0-4b4f-9e84-a55c876b535&title=&width=1364.1666124595558" alt="image.png"></p><h3 id="配置-Maven-的-settings-文件"><a href="#配置-Maven-的-settings-文件" class="headerlink" title="配置 Maven 的 settings 文件"></a>配置 Maven 的 settings 文件</h3><p>关于 cong 文件夹中的 settings.xml 文件（<code>D:\maven\conf</code>）：</p><ul><li>maven 用来构建项目</li><li>java 需要外部的 jar 包，外网的中央仓库，下载本地仓库</li><li>setting.xml 文件里面的盘符注意</li></ul><pre><code class="xml">&lt;localRepository&gt;D:/lib_repo/repository&lt;/localRepository&gt;</code></pre><ul><li>用阿里的源站下载</li></ul><pre><code class="xml">  &lt;mirrors&gt;     &lt;!-- 这里使用的是阿里的远程maven镜像，目前国内大多数都使用它 --&gt;     &lt;mirror&gt;         &lt;id&gt;alimaven&lt;/id&gt;        &lt;name&gt;aliyun maven&lt;/name&gt;        &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt;        &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;    &lt;/mirror&gt;  &lt;/mirrors&gt;</code></pre><h3 id="添加-src-main-java-目录"><a href="#添加-src-main-java-目录" class="headerlink" title="添加 src/main/java 目录"></a>添加 src/main/java 目录</h3><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1645498371242-a283bfdb-f00f-4c4a-8cce-548dc8f1245f.png#clientId=u7736cca5-9ead-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=302&id=uUlRT&margin=%5Bobject%20Object%5D&name=image.png&originHeight=362&originWidth=365&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=18415&status=done&style=none&taskId=u4cc26b05-0c69-46e6-a479-d259db2c1a3&title=&width=304.16665458016973" alt="image.png"></p><h3 id="pom-xml-添加项目依赖-jar-包"><a href="#pom-xml-添加项目依赖-jar-包" class="headerlink" title="pom.xml 添加项目依赖 jar 包"></a>pom.xml 添加项目依赖 jar 包</h3><p>打开 pom.xml 文件，改配置文件，添加依赖项，具体修改为如下：</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;parent&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;        &lt;version&gt;2.6.2&lt;/version&gt;        &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;    &lt;/parent&gt;    &lt;groupId&gt;com.cn.shicun&lt;/groupId&gt;    &lt;artifactId&gt;emis&lt;/artifactId&gt;    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;    &lt;name&gt;emis&lt;/name&gt;    &lt;properties&gt;        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;        &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt;        &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt;    &lt;/properties&gt;    &lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;    &lt;build&gt;    &lt;/build&gt;&lt;/project&gt;</code></pre><p>点击右上角蓝色更新按钮<br><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1645757724190-8b4ba45a-8ac4-48c9-a306-b63d8936c87d.png#clientId=u083cc79a-4829-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=266&id=u0495e1bc&margin=%5Bobject%20Object%5D&name=image.png&originHeight=319&originWidth=1460&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=41373&status=done&style=none&taskId=ucd7bceaa-b7ca-426f-a7b5-a4bd9652d9d&title=&width=1216.666618320679" alt="image.png"><br>然后 idea 会自动下载这些 jar 包（Maven 优势之一，就是会自动下载 jar 包）<br><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1645498601439-0aa7238f-2ea2-4158-8bb8-61e355c5bb1e.png#clientId=u7736cca5-9ead-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=255&id=ud93f9cb0&margin=%5Bobject%20Object%5D&name=image.png&originHeight=306&originWidth=1920&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=54500&status=done&style=none&taskId=u349c0c72-970e-44d1-958b-c785c646a54&title=&width=1599.9999364217147" alt="image.png"><br>下载成功如下所示：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1645498687230-217fcf65-9ed3-4888-bc04-b1b08d423a92.png#clientId=u7736cca5-9ead-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=258&id=ub991bc27&margin=%5Bobject%20Object%5D&name=image.png&originHeight=969&originWidth=675&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=126898&status=done&style=none&taskId=u1a16eea9-2b7b-4277-b597-d533513e2c0&title=&width=179.671875" alt="image.png"></p><h2 id="运行-springboot-应用程序"><a href="#运行-springboot-应用程序" class="headerlink" title="运行 springboot 应用程序"></a>运行 springboot 应用程序</h2><h3 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h3><p>如下位置写入如下代码：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1645511526582-4dd0440d-2caf-4137-b544-f487045eb46f.png#clientId=ua382b8e2-dd80-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=233&id=u6e9df4ef&margin=%5Bobject%20Object%5D&name=image.png&originHeight=903&originWidth=1163&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=482003&status=done&style=none&taskId=ua01136b7-08ea-4890-95d3-3f2d19b77ca&title=&width=300.015625" alt="image.png"></p><pre><code class="java">package com.cn.shixun;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplicationpublic class App&#123;    public static void main( String[] args )    &#123;        SpringApplication.run(App.class);    &#125;&#125;</code></pre><h3 id="静态资源"><a href="#静态资源" class="headerlink" title="静态资源"></a>静态资源</h3><p>然后在 resources 新建文件夹 static，在其中写入 index.html 文件，然后运行 App 代码<br><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1645513209905-d82808a5-87e0-4d1d-a44f-7bd84bf14e48.png#clientId=ua382b8e2-dd80-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=431&id=u08e7d5a8&margin=%5Bobject%20Object%5D&name=image.png&originHeight=517&originWidth=828&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=59584&status=done&style=none&taskId=u16b3d731-8c18-41ee-b120-f0cccc86bc7&title=&width=689.9999725818645" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1645513163237-543a369b-f027-4a23-a54b-16d5396317e7.png#clientId=ua382b8e2-dd80-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=294&id=u649359b3&margin=%5Bobject%20Object%5D&name=image.png&originHeight=353&originWidth=889&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=32066&status=done&style=stroke&taskId=u5970fc7a-052a-4d40-a746-4f2f1d7b8c2&title=&width=740.8333038952627" alt="image.png"></p><h3 id="idea-实时刷新前端代码设置"><a href="#idea-实时刷新前端代码设置" class="headerlink" title="idea 实时刷新前端代码设置"></a>idea 实时刷新前端代码设置</h3><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1645513254386-91ff5733-2ee8-4bba-a306-3e0ae0a82189.png#clientId=ua382b8e2-dd80-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=384&id=u857aff52&margin=%5Bobject%20Object%5D&name=image.png&originHeight=461&originWidth=972&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=54248&status=done&style=none&taskId=ua8bcb601-40c3-48e4-9450-cccb6008698&title=&width=809.9999678134931" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1645513246554-dda6481d-a454-497b-a90f-66700b3df752.png#clientId=ua382b8e2-dd80-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=455&id=u8bb3fd04&margin=%5Bobject%20Object%5D&name=image.png&originHeight=546&originWidth=974&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=52171&status=done&style=none&taskId=uac19504c-e5e4-4fc5-befa-e0a9c371b6c&title=&width=811.6666344139323" alt="image.png"></p><h2 id="前后端架构"><a href="#前后端架构" class="headerlink" title="前后端架构"></a>前后端架构</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1645602574923-49da96c6-764f-4141-af8b-b6d8fe8bc584.png#clientId=ud948cc8c-71cb-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=646&id=u65920461&margin=%5Bobject%20Object%5D&name=image.png&originHeight=775&originWidth=1009&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=235932&status=done&style=stroke&taskId=ua122433c-048f-4c3d-a78d-81f66aa200a&title=&width=840.8332999216199" alt="image.png"></p><h2 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h2><h3 id="jQuery-的-Ajax-的使用"><a href="#jQuery-的-Ajax-的使用" class="headerlink" title="jQuery 的 Ajax 的使用"></a>jQuery 的 Ajax 的使用</h3><p>jQuery 其他相关笔记之前已经学过，不做赘述，此文只做 Ajax 相关的笔记<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1629125564200-d6272b27-ffcf-4f6d-b7f8-f1ccc7660b0c.png#crop=0&crop=0&crop=1&crop=1&height=315&id=pBacN&margin=%5Bobject%20Object%5D&name=image.png&originHeight=322&originWidth=623&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=13078&status=done&style=stroke&title=&width=609.4973754882812" alt="image.png"></p><pre><code class="javascript">//    Ajax ===============================================================let ajaxDemo = function () &#123;  $.ajax(&#123;    type: &quot;post&quot;,    url: &quot;https://127.0.0.1:8080/test/demo2&quot;,    data: &#123;      name: &quot;李四&quot;,      age: 14,    &#125;,    //        dataType : &quot;json&quot;,    success: function (data) &#123;      // 后端的返回值      alert(data);    &#125;,  &#125;);&#125;;</code></pre><pre><code class="html">&lt;input type=&quot;button&quot; value=&quot;ajax点击按钮&quot; onclick=&quot;ajaxDemo();&quot; /&gt;</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1645600461044-6f9411a0-aaf9-4f27-bc88-9d590544a9de.png#clientId=ud948cc8c-71cb-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=179&id=KCZBi&margin=%5Bobject%20Object%5D&name=image.png&originHeight=215&originWidth=694&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=11544&status=done&style=stroke&taskId=u79b60ab9-dfb0-4ec3-a7e7-085c3a69d6c&title=&width=578.3333103524324" alt="image.png"></p><h3 id="原生-JavaScript-的-Ajax-使用"><a href="#原生-JavaScript-的-Ajax-使用" class="headerlink" title="原生 JavaScript 的 Ajax 使用"></a>原生 JavaScript 的 Ajax 使用</h3><pre><code class="javascript">function ajax(options) &#123;  // 默认值  var defaults = &#123;    type: &quot;get&quot;,    url: &quot;&quot;,    data: &#123;&#125;,    header: &#123;      &quot;Content-Type&quot;: &quot;application/x-www-form-urlencoded&quot;,    &#125;,    success: function () &#123;&#125;,    error: function () &#123;&#125;,  &#125;;  // 使用用户传递的参数替换默认值参数  Object.assign(defaults, options);  // 创建ajax对象  var xhr = new XMLHttpRequest();  // 参数拼接变量  var params = &quot;&quot;;  // 循环参数  for (var attr in defaults.data) &#123;    // 参数拼接    params += attr + &quot;=&quot; + defaults.data[attr] + &quot;&amp;&quot;;    // 去掉参数中最后一个&amp;    params = params.substr(0, params.length - 1);  &#125;  // 如果请求方式为get  if (defaults.type == &quot;get&quot;) &#123;    // 将参数拼接在url地址的后面    defaults.url += &quot;?&quot; + params;  &#125;  // 配置ajax请求  xhr.open(defaults.type, defaults.url);  // 如果请求方式为post  if (defaults.type == &quot;post&quot;) &#123;    // 设置请求头    xhr.setRequestHeader(&quot;Content-Type&quot;, defaults.header[&quot;Content-Type&quot;]);    // 如果想服务器端传递的参数类型为json    if (defaults.header[&quot;Content-Type&quot;] == &quot;application/json&quot;) &#123;      // 将json对象转换为json字符串      xhr.send(JSON.stringify(defaults.data));    &#125; else &#123;      // 发送请求      xhr.send(params);    &#125;  &#125; else &#123;    xhr.send();  &#125;  // 请求加载完成  xhr.onload = function () &#123;    // 获取服务器端返回数据的类型    var contentType = xhr.getResponseHeader(&quot;content-type&quot;);    // 获取服务器端返回的响应数据    var responseText = xhr.responseText;    // 如果服务器端返回的数据是json数据类型    if (contentType.includes(&quot;application/json&quot;)) &#123;      // 将json字符串转换为json对象      responseText = JSON.parse(responseText);    &#125;    // 如果请求成功    if (xhr.status == 200) &#123;      // 调用成功回调函数, 并且将服务器端返回的结果传递给成功回调函数      defaults.success(responseText, xhr);    &#125; else &#123;      // 调用失败回调函数并且将xhr对象传递给回调函数      defaults.error(responseText, xhr);    &#125;  &#125;;  // 当网络中断时  xhr.onerror = function () &#123;    // 调用失败回调函数并且将xhr对象传递给回调函数    defaults.error(xhr);  &#125;;&#125;</code></pre><h3 id="AdminLTE-框架"><a href="#AdminLTE-框架" class="headerlink" title="AdminLTE 框架"></a>AdminLTE 框架</h3><p>文档：<a href="https://adminlte.io/">https://adminlte.io/</a><br>下载 adminlte 及其依赖放到静态文件夹<br><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1645520275251-6ba0c4e2-026d-4289-8519-2a67d7d0e2af.png#clientId=ua382b8e2-dd80-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=177&id=vP941&margin=%5Bobject%20Object%5D&name=image.png&originHeight=788&originWidth=1132&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=87416&status=done&style=none&taskId=u1740d930-d682-4a37-a958-5edcf626461&title=&width=254.015625" alt="image.png"><br>使用 jsDelivr 外链来构建<br><a href="https://cdn.jsdelivr.net/npm/admin-lte@3.2/dist/css/adminlte.min.css">https://cdn.jsdelivr.net/npm/admin-lte@3.2/dist/css/adminlte.min.css</a><br><a href="https://cdn.jsdelivr.net/npm/admin-lte@3.2/plugins/fontawesome-free/css/all.min.css">https://cdn.jsdelivr.net/npm/admin-lte@3.2/plugins/fontawesome-free/css/all.min.css</a></p><h3 id="构建管理类系统的静态页模板"><a href="#构建管理类系统的静态页模板" class="headerlink" title="构建管理类系统的静态页模板"></a>构建管理类系统的静态页模板</h3><p><strong>利用 AdminLTE UI 模板搭建出项目所需的目的页面（在 static 里面写出想要的各种效果）</strong><br>管理类系统的页面类型大概有以下几类：</p><ol><li>登录页（大多数的管理类系统都没有注册页，需要通过用户管理模块增加用户）。</li></ol><p><a href="http://127.0.0.1:8080/pages/login.html">http://127.0.0.1:8080/pages/login.html</a></p><ol start="2"><li>欢迎页，登录成功后进入的首页。</li></ol><p><a href="http://127.0.0.1:8080/pages/index.html">http://127.0.0.1:8080/pages/index.html</a></p><ol start="3"><li>列表页，展示数据集合的表格，一般带分页和查询功能，展示的每行数据的最后会有可以点击的“修改”和“删除”功能。</li><li>新增/修改页，一个 form 表单，同一个的功能模块的新增/修改页的表单元素是一致的，只是修改页需要回填数据。</li><li>其他特殊页，例如在线答题页、数据统计页、文件上传页等等，这些在管理类系统中的占比很小。</li></ol><h2 id="后端：Springboot-学习"><a href="#后端：Springboot-学习" class="headerlink" title="后端：Springboot 学习"></a>后端：Springboot 学习</h2><p>记录一下框架的 API 使用</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="https://www.springcloud.cc/spring-boot.html">Spring Boot 参考指南</a></li><li><a href="http://c.biancheng.net/spring_boot/">Spring Boot 框架入门教程（快速学习版）</a></li></ul><hr><p>vscode 运行 springboot 项目</p><ul><li><a href="https://juejin.cn/post/7036643751896285220">demo5：如何优雅的在 vscode 里面跑 springboot 工程</a></li></ul><hr><p>SpringBoot 编写接口</p><ul><li><a href="https://blog.csdn.net/qq_28336351/article/details/79327357">用 Spring Boot 开发 API 接口</a></li></ul><hr><h3 id="SpringBootApplication"><a href="#SpringBootApplication" class="headerlink" title="@SpringBootApplication"></a>@SpringBootApplication</h3><p>主要方法是通过调用 run 来委托 Spring Boot 的 SpringApplication 类。<br>SpringApplication 引导我们的应用程序，从 Spring 开始，然后启动自动配置的 Tomcat Web 服务器。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1645749879910-2701fc28-b68f-446f-81e8-4dabe66e43e7.png#clientId=u083cc79a-4829-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=372&id=u835cf579&margin=%5Bobject%20Object%5D&name=image.png&originHeight=447&originWidth=1920&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=131260&status=done&style=none&taskId=u53833995-94b4-4b89-91e6-fbbea447235&title=&width=1599.9999364217147" alt="image.png"><br>我们需要将 Example.class 作为参数传递给 run 方法，以告诉 SpringApplication 哪个是主要的 Spring 组件。<br>还会传递 args 数组以公开任何命令行参数。<br>springboot 的启动类是有作用范围的</p><h3 id="Controller"><a href="#Controller" class="headerlink" title="@Controller"></a>@Controller</h3><p>所创建的类是一个 web <code>@Controller</code>，所以 Spring<strong>在处理传入的 Web 请求时会考虑它</strong>。</p><h3 id="RequestMapping-“test”"><a href="#RequestMapping-“test”" class="headerlink" title="@RequestMapping(“test”)"></a>@RequestMapping(“test”)</h3><p>@RequestMapping 注释提供“路由”信息。它告诉 Spring 任何带有/test 路径的 HTTP 请求都应该映射到所写的 test 方法。</p><h3 id="responseBody"><a href="#responseBody" class="headerlink" title="@responseBody"></a>@responseBody</h3><p>@responseBody 注解的作用是将 controller 的方法返回的对象通过适当的转换器转换为指定的格式之后，写入到 response 对象的 body 区，通常用来返回 JSON 数据回格式是 text/json（或者是 XML）数据，需要注意的呢，在使用此注解之后不会再走试图处理器，而是直接将数据写入到输入流中，他的效果等同于通过 response 对象输出指定格式的数据。</p><h3 id="RestController"><a href="#RestController" class="headerlink" title="@RestController"></a>@RestController</h3><p>类上写上注解 @RestController，那么此 Controller 返回格式就都是 text/json</p><h2 id="后端：数据库学习"><a href="#后端：数据库学习" class="headerlink" title="后端：数据库学习"></a>后端：数据库学习</h2><h3 id="表关系"><a href="#表关系" class="headerlink" title="表关系"></a>表关系</h3><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1645751601318-ffb24061-6e8d-4c67-a6e2-666bf0acd9d1.png#clientId=u083cc79a-4829-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=263&id=u5aec88ce&margin=%5Bobject%20Object%5D&name=image.png&originHeight=316&originWidth=816&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=10093&status=done&style=none&taskId=u3934c768-0a43-482e-a889-c28a29a6d9e&title=&width=679.9999729792288" alt="image.png"></p><p>权限控制：<br>RBAC，role based access control，基于角色的访问控制<br>用户，角色，功能（项目的粒度到二级菜单即可）</p><p>user，user<em>role，role，role_menu，menu<br>用户</em>角色组，角色则，角色组_角色</p><h3 id="数据表的初始化"><a href="#数据表的初始化" class="headerlink" title="数据表的初始化"></a>数据表的初始化</h3><p>连接本地数据库<br><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1645753130016-3d2056bc-ece0-43e8-b97a-f6ccfbc13587.png#clientId=u083cc79a-4829-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=220&id=uffe98a1a&margin=%5Bobject%20Object%5D&name=image.png&originHeight=627&originWidth=874&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=27020&status=done&style=stroke&taskId=u2777c33d-c964-4429-89fa-7fccbac578e&title=&width=306.33331298828125" alt="image.png"><br>按照教程初始化各个数据库</p><hr><p>构建实体类—如果手动构建，需要单独给每个表生成 Getter Setter，所以使用下面讲的 mybits 逆向工程构建。</p><h2 id="MyBatis-逆向工程"><a href="#MyBatis-逆向工程" class="headerlink" title="MyBatis 逆向工程"></a>MyBatis 逆向工程</h2><h3 id="添加数据库账户及授权"><a href="#添加数据库账户及授权" class="headerlink" title="添加数据库账户及授权"></a>添加数据库账户及授权</h3><p>参考：<a href="https://blog.csdn.net/weixin_33400820/article/details/81976424">navicat 创建用户以及设置权限</a><br><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1645757383547-2e71e1ab-c656-4362-af9c-03055d1cdd04.png#clientId=u083cc79a-4829-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=200&id=u067b447b&margin=%5Bobject%20Object%5D&name=image.png&originHeight=461&originWidth=957&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=36538&status=done&style=none&taskId=uc2ac2244-92a4-4c56-8141-b26e1864777&title=&width=415.015625" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1645757505559-1082ac8d-ea6e-4462-bf75-dee340fbec59.png#clientId=u083cc79a-4829-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=244&id=u2db9f02f&margin=%5Bobject%20Object%5D&name=image.png&originHeight=821&originWidth=1162&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=63272&status=done&style=stroke&taskId=u7fc96ed8-287c-48c5-800d-28d16715e45&title=&width=345.015625" alt="image.png"><br>账号密码都是：mybatis<br>创建成功后如下：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1645757562274-1c280235-ee05-4629-863f-aca7b76b5a4a.png#clientId=u083cc79a-4829-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=254&id=u4644ce1e&margin=%5Bobject%20Object%5D&name=image.png&originHeight=450&originWidth=724&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=40396&status=done&style=stroke&taskId=u2b430b46-80ec-453b-9963-71ac9ca5618&title=&width=408.33331298828125" alt="image.png"></p><h3 id="pom-xml-添加依赖"><a href="#pom-xml-添加依赖" class="headerlink" title="pom.xml 添加依赖"></a>pom.xml 添加依赖</h3><pre><code class="xml">    &lt;dependency&gt;      &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;      &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;      &lt;version&gt;2.2.1&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;mysql&lt;/groupId&gt;      &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;      &lt;scope&gt;runtime&lt;/scope&gt;      &lt;!--        1、如果你的数据库是mysql8，这段&lt;version&gt;5.1.32&lt;/version&gt;不用管        2、如果你的数据库是mysql5.x，放开&lt;version&gt;5.1.32&lt;/version&gt;这段注释        --&gt;      &lt;version&gt;5.1.32&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt;      &lt;artifactId&gt;mybatis-generator-core&lt;/artifactId&gt;      &lt;version&gt;1.4.0&lt;/version&gt;    &lt;/dependency&gt;</code></pre><h3 id="编写逆向工程的配置文件-generatorConfig-xml-和-Generator-java"><a href="#编写逆向工程的配置文件-generatorConfig-xml-和-Generator-java" class="headerlink" title="编写逆向工程的配置文件 generatorConfig.xml 和 Generator.java"></a>编写逆向工程的配置文件 generatorConfig.xml 和 Generator.java</h3><p>运行 Generator 类的 main 方法生成实体类、mapper 接口和 mapper 的 xml 文件<br><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1645771323003-02719bd5-ad39-43c6-91f8-c9c3d58f68b5.png#clientId=u12d69e0c-843e-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=279&id=u6276f1f8&margin=%5Bobject%20Object%5D&name=image.png&originHeight=864&originWidth=650&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=88795&status=done&style=none&taskId=u3cae1517-3376-4b4f-a86d-d504317876e&title=&width=209.6666259765625" alt="image.png"><br><strong>每次生成逆向工程之前，要把之前生成的文件全部删除</strong>。</p><pre><code class="html">&lt;dependency&gt;  &lt;groupId&gt;com.alibaba&lt;/groupId&gt;  &lt;artifactId&gt;fastjson&lt;/artifactId&gt;  &lt;version&gt;1.2.73&lt;/version&gt;&lt;/dependency&gt;</code></pre><h2 id="报错"><a href="#报错" class="headerlink" title="报错"></a>报错</h2><h3 id="SpringBoot-启动报错-Failed-to-configure-a-DataSource-‘url’-attribute-is-not-specified-and-no-embedded-datasource-could-be-configured"><a href="#SpringBoot-启动报错-Failed-to-configure-a-DataSource-‘url’-attribute-is-not-specified-and-no-embedded-datasource-could-be-configured" class="headerlink" title="SpringBoot 启动报错 Failed to configure a DataSource: ‘url’ attribute is not specified and no embedded datasource could be configured"></a>SpringBoot 启动报错 Failed to configure a DataSource: ‘url’ attribute is not specified and no embedded datasource could be configured</h3><pre><code class="java">Error starting ApplicationContext. To display the conditions report re-run your application with &#39;debug&#39; enabled.2022-02-27 20:30:12.439 ERROR 12672 --- [           main] o.s.b.d.LoggingFailureAnalysisReporter   :***************************APPLICATION FAILED TO START***************************Description:Failed to configure a DataSource: &#39;url&#39; attribute is not specified and no embedded datasource could be configured.Reason: Failed to determine a suitable driver classAction:Consider the following:    If you want an embedded database (H2, HSQL or Derby), please put it on the classpath.    If you have database settings to be loaded from a particular profile you may need to activate it (no profiles are currently active).Process finished with exit code 1</code></pre><p>启动类添加如下：</p><pre><code class="java">@SpringBootApplication(exclude = &#123;DataSourceAutoConfiguration.class&#125;)</code></pre><p>参考：<a href="https://www.panziye.com/java/1873.html">https://www.panziye.com/java/1873.html</a></p><h3 id="Consider-defining-a-bean-of-type-‘com-cn-shixun-mapper-UserMapper’-in-your-configuration"><a href="#Consider-defining-a-bean-of-type-‘com-cn-shixun-mapper-UserMapper’-in-your-configuration" class="headerlink" title="Consider defining a bean of type ‘com.cn.shixun.mapper.UserMapper’ in your configuration."></a>Consider defining a bean of type ‘com.cn.shixun.mapper.UserMapper’ in your configuration.</h3><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1645965307851-1a6aeb4e-786d-453c-8f19-cf25c41156eb.png#clientId=u60183c30-ad43-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=133&id=u345021ed&margin=%5Bobject%20Object%5D&name=image.png&originHeight=160&originWidth=946&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=23815&status=done&style=none&taskId=u667cd4c8-0a4b-4dbe-9394-1439ebc760c&title=&width=788.3333020077824" alt="image.png"><br>参考：<a href="https://blog.csdn.net/zzldm/article/details/116534419">https://blog.csdn.net/zzldm/article/details/116534419</a></p><h3 id="nio-8080-exec-1"><a href="#nio-8080-exec-1" class="headerlink" title="nio-8080-exec-1"></a>nio-8080-exec-1</h3><p>属于正常情况</p><pre><code class="java">  .   ____          _            __ _ _ /\\ / ___&#39;_ __ _ _(_)_ __  __ _ \ \ \ \( ( )\___ | &#39;_ | &#39;_| | &#39;_ \/ _` | \ \ \ \ \\/  ___)| |_)| | | | | || (_| |  ) ) ) )  &#39;  |____| .__|_| |_|_| |_\__, | / / / / =========|_|==============|___/=/_/_/_/ :: Spring Boot ::                (v2.6.2)2022-02-27 20:46:14.796  INFO 9608 --- [           main] com.App                                  : Starting App using Java 1.8.0_151 on DESKTOP-QTVR7IE with PID 9608 (D:\projects\emis\target\classes started by wztli in D:\projects\emis)2022-02-27 20:46:14.799  INFO 9608 --- [           main] com.App                                  : No active profile set, falling back to default profiles: default2022-02-27 20:46:16.451  INFO 9608 --- [           main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat initialized with port(s): 8080 (http)2022-02-27 20:46:16.464  INFO 9608 --- [           main] o.apache.catalina.core.StandardService   : Starting service [Tomcat]2022-02-27 20:46:16.464  INFO 9608 --- [           main] org.apache.catalina.core.StandardEngine  : Starting Servlet engine: [Apache Tomcat/9.0.56]2022-02-27 20:46:16.582  INFO 9608 --- [           main] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring embedded WebApplicationContext2022-02-27 20:46:16.582  INFO 9608 --- [           main] w.s.c.ServletWebServerApplicationContext : Root WebApplicationContext: initialization completed in 1721 ms2022-02-27 20:46:16.996  INFO 9608 --- [           main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat started on port(s): 8080 (http) with context path &#39;&#39;2022-02-27 20:46:17.010  INFO 9608 --- [           main] com.App                                  : Started App in 2.708 seconds (JVM running for 3.193)2022-02-27 20:46:17.075  INFO 9608 --- [nio-8080-exec-1] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring DispatcherServlet &#39;dispatcherServlet&#39;2022-02-27 20:46:17.075  INFO 9608 --- [nio-8080-exec-1] o.s.web.servlet.DispatcherServlet        : Initializing Servlet &#39;dispatcherServlet&#39;2022-02-27 20:46:17.076  INFO 9608 --- [nio-8080-exec-1] o.s.web.servlet.DispatcherServlet        : Completed initialization in 1 ms</code></pre>]]></content>
      
      
      <categories>
          
          <category> 🔨环境工具 </category>
          
          <category> 环境搭建 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>WebSocket学习笔记</title>
      <link href="/blog/pp1d2p/"/>
      <url>/blog/pp1d2p/</url>
      
        <content type="html"><![CDATA[<h3 id="一些链接"><a href="#一些链接" class="headerlink" title="一些链接"></a>一些链接</h3><ul><li>WebSocket 在线调试：<a href="http://www.easyswoole.com/wstool.html">http://www.easyswoole.com/wstool.html</a></li><li>express 笔记：<a href="https://www.yuque.com/wztlink1013/projects/tdgoby">https://www.yuque.com/wztlink1013/projects/tdgoby</a></li><li>相关文档：<a href="http://expressjs.jser.us/">http://expressjs.jser.us/</a></li></ul><h3 id="mongodb-和-sharedb-mongo"><a href="#mongodb-和-sharedb-mongo" class="headerlink" title="mongodb 和 sharedb-mongo"></a>mongodb 和 sharedb-mongo</h3><ul><li><a href="https://rain120.github.io/sharedb-zh/sharedb/sharedb">ShareDB 中文文档</a></li><li><a href="https://rain120.github.io/sharedb-zh/sharedb-mongo/sharedb-mongo">sharedb-mongo 文档</a></li></ul><h3 id="WebSocket-长连接概念"><a href="#WebSocket-长连接概念" class="headerlink" title="WebSocket 长连接概念"></a>WebSocket 长连接概念</h3><p>什么是 WebSocket？<br>参考：</p><ul><li><a href="https://www.liaoxuefeng.com/wiki/1022910821149312/1103303693824096">WebSocket 廖雪峰的官方网站</a></li><li><a href="https://www.ruanyifeng.com/blog/2017/05/websocket.html">WebSocket 教程 作者： 阮一峰</a></li></ul><p>为什么需要 WebSocket 呢？<br>因为网络请求，有请求响应，浏览器的请求，还需要有服务端的响应，需要时刻进行数据通信，明显上述不行，因为上述强调一个“主动”，也就是客户端如果不发送请求，服务端就不会进行响应，对协同而言明显不行，比如说，a 用户修改了一个部分，这个时候就需要服务端主动将修改后的内容推送到其他客户，这样才能实现实时协同。再比如多人聊天室。<br>所以需要一个在浏览器和服务器之间建立一个不受限的双向通信的通道，比如说，服务器可以在任意时刻发送消息给浏览器。</p><p>使用的时候还需要注意，只有浏览器支持 WebSocket 协议，才能够使用该协议，兼容的浏览器种类及版本如下：</p><pre><code>ChromeFirefoxIE &gt;= 10Sarafi &gt;= 6Android &gt;= 4.4iOS &gt;= 8</code></pre><p>Node.js 中，使用最广泛的 WebSocket 模块是 ws，以下学习笔记：</p><h3 id="Node-js-的-WebSocket-模块-ws-的使用"><a href="#Node-js-的-WebSocket-模块-ws-的使用" class="headerlink" title="Node.js 的 WebSocket 模块 ws 的使用"></a>Node.js 的 WebSocket 模块 ws 的使用</h3><p>地址：<a href="https://github.com/websockets/ws">https://github.com/websockets/ws</a><br>下载</p><pre><code class="bash">cnpm i ws --save</code></pre><ul><li>connection：<a href="https://github.com/websockets/ws/blob/master/doc/ws.md#event-connection">https://github.com/websockets/ws/blob/master/doc/ws.md#event-connection</a></li><li>addEventListener：<a href="https://github.com/websockets/ws/blob/master/doc/ws.md#websocketaddeventlistenertype-listener-options">https://github.com/websockets/ws/blob/master/doc/ws.md#websocketaddeventlistenertype-listener-options</a></li></ul><h3 id="teamwork-websocket-json-stream"><a href="#teamwork-websocket-json-stream" class="headerlink" title="@teamwork/websocket-json-stream"></a>@teamwork/websocket-json-stream</h3><p><a href="https://www.npmjs.com/package/@teamwork/websocket-json-stream">https://www.npmjs.com/package/@teamwork/websocket-json-stream</a></p><p>用于 WebSocket 连接的 nodejs 流包装器。它也适用于浏览器 WebSockets。</p>]]></content>
      
      
      <categories>
          
          <category> 👨‍💻Web开发 </category>
          
          <category> Web其他知识 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Node.js使用</title>
      <link href="/blog/gxh14f/"/>
      <url>/blog/gxh14f/</url>
      
        <content type="html"><![CDATA[<h2 id="Node-js-使用"><a href="#Node-js-使用" class="headerlink" title="Node.js 使用"></a>Node.js 使用</h2><p>Node.js 环境说白了就和浏览器一样，用来运行 js，node 借助终端，浏览器借助展示 HTML 文件来展示 js 功能。具体运行在 js 文件的所在文件目录下运行 <code>node xx.js</code>即可。<br>不过一般全局下载 nodemon 三方模块，其作用是当 js 文件被改动，终端会再次执行该 js 文件，后续模块处再讲。</p><p>模块化开发分为两种：</p><ol><li>前端网页使用 JavaScript 外链</li><li>使用 nodejs 加载模块化开发构建</li></ol><p>Node.js 实际上是模块化开发，由以下两方面组成：</p><ol><li>ECMAScript</li><li>Node 的模块 API（又分为内置模块和三方模块）</li></ol><h3 id="node-环境的一些特性"><a href="#node-环境的一些特性" class="headerlink" title="node 环境的一些特性"></a>node 环境的一些特性</h3><p>异步式 I/O：提高效率，防止阻塞这种情况<br>事件式编程：注意事件循环机制</p><h3 id="node-模块化及其使用"><a href="#node-模块化及其使用" class="headerlink" title="node 模块化及其使用"></a>node 模块化及其使用</h3><p>参考之前写的文章：<a href="https://www.yuque.com/wztlink1013/blog/psazge#FPo3f">https://www.yuque.com/wztlink1013/blog/psazge#FPo3f</a></p><h3 id="process-env-环境变量"><a href="#process-env-环境变量" class="headerlink" title="process.env 环境变量"></a>process.env 环境变量</h3><p>nodejs 的顶层对象 process 下的环境变量设置与使用</p><ul><li>参考：<a href="https://juejin.cn/post/6972466143445385223">https://juejin.cn/post/6972466143445385223</a></li></ul><h3 id="nodejs-中的-try…catch"><a href="#nodejs-中的-try…catch" class="headerlink" title="nodejs 中的 try…catch"></a>nodejs 中的 try…catch</h3><p>写异常的捕获的时候，要时刻注意一些异步执行的代码，比如一种场景是 try 里面的代码是异步操作，那么再执行异步的时候，就已经执行了 catch 里面的报警语句了，学会查看捕获的目标代码是哪段。</p><p>具体参考：<a href="https://www.cnblogs.com/surfer/p/10291609.html">https://www.cnblogs.com/surfer/p/10291609.html</a></p><h2 id="Node-js-内置模块"><a href="#Node-js-内置模块" class="headerlink" title="Node.js 内置模块"></a>Node.js 内置模块</h2><h3 id="全局对象-global"><a href="#全局对象-global" class="headerlink" title="全局对象 global"></a>全局对象 global</h3><p>Node.js 和之前学过的浏览器对象区分之就是，浏览器中全局对象是 window，但是 Node.js 的全局对象是 global（也可以不写、省略）。</p><ul><li>process 对象：关于进程的一个对象，也是 global 的属性之一，是一个和操作系统的简单接口。重点了解 nextTick()函数，这个函数可以将事件循环设置一个任务，提高运行效率</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1622768098753-4f933f75-ea23-41d9-80d3-c8dd46f2e123.png#crop=0&crop=0&crop=1&crop=1&height=41&id=jU6pu&margin=%5Bobject%20Object%5D&name=image.png&originHeight=82&originWidth=914&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=24551&status=done&style=none&title=&width=457" alt="image.png"></p><ul><li>console 对象：log 在控制台中输出；error 输出错误信息；trace 输出错误信息调用栈（就是错在什么地方）</li><li>setTimeout()     设置超时<strong>定时器</strong></li><li>clearTimeout()   清除超时时定时器</li><li>setInterval()       设置间歇<strong>定时器</strong></li><li>clearInterval()   清除间歇定时器</li></ul><h3 id="http-fs-url-querystring-path-模块"><a href="#http-fs-url-querystring-path-模块" class="headerlink" title="http;fs;url;querystring;path 模块"></a>http;fs;url;querystring;path 模块</h3><p>参考：<a href="https://blog.guowenfh.com/2016/10/15/node-http">https://blog.guowenfh.com/2016/10/15/node-http</a></p><ul><li>http，原生创建 web 服务</li><li>url 解析 url，querystring 处理 url 参数，搭配使用</li><li>fs 模块用来读取文件、写入文件等</li><li>path 路径操作，一般都是路径字符串拼接 join，<code>__dirname</code>当前目录名</li></ul><pre><code class="javascript">/* * @Author: wztlink1013 * @Date: 2022-01-10 16:26:41 * @LastEditTime: 2022-01-10 19:49:43 * @Description: */let http = require(&quot;http&quot;);let url = require(&quot;url&quot;);let fs = require(&quot;fs&quot;);let queryString = require(&quot;querystring&quot;);let server = http.createServer();// 读取我们当前文件所在的目录下的 html 文件夹let HtmlDir = __dirname + &quot;/html/&quot;;server.on(&quot;request&quot;, function (req, res) &#123;  let urlObj = url.parse(req.url);  console.log(&quot;【请求url信息】&quot;, urlObj);  let params = queryString.parse(urlObj.query);  console.log(&quot;【url参数】&quot;, JSON.stringify(params));  switch (urlObj.pathname) &#123;    case &quot;/&quot;:      //首页      sendData(HtmlDir + &quot;index.html&quot;, req, res);      break;    case &quot;/user&quot;:      //用户首页      sendData(HtmlDir + &quot;user.html&quot;, req, res);      break;    default:      //处理其他情况      sendData(HtmlDir + &quot;err.html&quot;, req, res);      break;  &#125;&#125;);/** * 读取html文件，响应数据，发送给浏览器 * @param &#123;String&#125; file 文件路径 * @param &#123;Object&#125; req request * @param &#123;Object&#125; res response 对象 */function sendData(file, req, res) &#123;  fs.readFile(file, function (err, data) &#123;    if (err) &#123;      res.writeHead(404, &#123;        &quot;content-type&quot;: &quot;text/html;charset=utf-8&quot;,      &#125;);      res.end(&quot;&lt;h1&gt;你要找的页面不见了～&lt;/h1&gt;&quot;);    &#125; else &#123;      res.writeHead(200, &#123;        &quot;content-type&quot;: &quot;text/html;charset=utf-8&quot;,      &#125;);      res.end(data);    &#125;  &#125;);&#125;server.listen(8888);console.log(&quot;Server is running at http://127.0.0.1:8888/&quot;);</code></pre><h3 id="util-chalk-美化"><a href="#util-chalk-美化" class="headerlink" title="util+chalk 美化"></a>util+chalk 美化</h3><ul><li><input checked="" disabled="" type="checkbox"> util.inherits</li></ul><p>不过感觉这个已经没有多大必要了，这个是实现原型间继承的相关封装，但是现在 ES6 已经有了 class 的概念了（虽然底层还是之前那套），这个工具用的不多</p><ul><li><input checked="" disabled="" type="checkbox"> util.inspect</li></ul><p>目的就是将对象转换为字符串，比如将错误信息更加美观的展示在控制台，就可以自定义，但是可以直接用 chalk 模块在实现这个美化控制台输出的工作。</p><pre><code class="javascript">&quot;use strict&quot;;const chalk = require(&quot;chalk&quot;);module.exports = &#123;  info(...args) &#123;    const prefix = chalk.green(&quot;[INFO]&quot;);    args.unshift(prefix);    console.log.apply(console, args);  &#125;,  warn(...args) &#123;    const prefix = chalk.yellow(&quot;[WARNING]&quot;);    args.unshift(prefix);    console.log.apply(console, args);  &#125;,  error(...args) &#123;    const prefix = chalk.red(&quot;[ERROR]&quot;);    args.unshift(prefix);    console.log.apply(console, args);  &#125;,&#125;;</code></pre><pre><code class="javascript">out.info(  `Current yuque-hexo-lyrics version is $&#123;chalk.yellow(    pkg.version  )&#125;, and the latest version is $&#123;chalk.green(update.latest)&#125;. Please update!`);out.info(  &quot;View more detail: https://github.com/wztlink1013/yuque-hexo-lyrics#changelog&quot;);</code></pre><h2 id="Node-js-三方模块"><a href="#Node-js-三方模块" class="headerlink" title="Node.js 三方模块"></a>Node.js 三方模块</h2><p>第三方模块的两种存在形式：</p><ol><li>以 js 文件的形式存在，提供实现项目具体功能的 API 接口。</li></ol><p>比如使用 jQuery，html 中引入 CDN 超链接即可使用。</p><ol start="2"><li>以命令行工具形式存在，辅助项目开发。</li></ol><p>比如 VUE-CLI 工具。</p><blockquote><p>npm 是用来管理模块的一个 node 工具，它会伴随着 node 的下载而一同下载。</p></blockquote><p>node 生态的繁荣多益于很多优秀的三方模块的存在，具体可以查看 <a href="https://nodersurvey.github.io/reporters/index.html">NoderSurvey 2021 年度报告</a> 的相关统计与调研。在此记录一下在学习以及实际开发过程中自己所学习到的三方模块，特别地，express 三方模块是一个 web 应用框架，需要学习的点较多，单独拿出来详细学习。</p><h3 id="cnpm-淘宝镜像"><a href="#cnpm-淘宝镜像" class="headerlink" title="cnpm+淘宝镜像"></a>cnpm+淘宝镜像</h3><p>因为 npm 是处于国外的服务器，下载模块有时候可能会较慢，特别是文件比较多的模块。以下是临时使用淘宝镜像下载的命令。</p><pre><code class="bash">npm --registry https://registry.npm.taobao.org install</code></pre><p>如果不想改变 npm 源，也可以直接使用 cnpm（推荐）</p><pre><code class="bash">// 安装cnpm命令,不会改变npm的源npm install -g cnpm --registry=https://registry.npm.taobao.org//使用cnpm install//查看源，可以看到设置过的所有的源npm config get registry</code></pre><ul><li>参考：<a href="https://www.cnblogs.com/sese/p/9297028.html">https://www.cnblogs.com/sese/p/9297028.html</a></li></ul><h3 id="nodemon-模块"><a href="#nodemon-模块" class="headerlink" title="nodemon 模块"></a>nodemon 模块</h3><pre><code class="bash">cnpm install nodemon –g</code></pre><p>作用：在开发过程中，修改了文件，控制台命令行就会根据文件的修改自动运行<br>使用方法：将运行命令中的 node 换成 nodemon</p><h3 id="gulp-模块"><a href="#gulp-模块" class="headerlink" title="gulp 模块"></a>gulp 模块</h3><p>基于 node 平台开发的前端构建工具，将机械化操作编写成任务，想要执行机械化操作时执行一个命令行命令任务就能自动执行了，用机器代替手工，提高开发效率。<br>具体的还有 webpack，后续继续学习。</p><p>作用：</p><ul><li>项目上线，HTML、CSS、JS 文件压缩合并</li><li>语法转换（es6、less …）</li><li>公共文件抽离</li><li>修改文件浏览器自动刷新</li></ul><p>glup 本身提供的 api 函数很少，官网到目前更新只有下面几个，具体使用方法，使用的时候去查</p><ul><li><a href="https://github.com/gulpjs/gulp">https://github.com/gulpjs/gulp</a></li><li><a href="https://gulpjs.com/docs/en/getting-started/quick-start">https://gulpjs.com/docs/en/getting-started/quick-start</a></li></ul><p>gulp 生态也有很多插件，根据插件下载相应需要的功能插件</p><ul><li>gulp-htmlmin ：html 文件压缩</li><li>gulp-csso ：压缩 css</li><li>gulp-babel ：JavaScript 语法转化</li><li>gulp-less: less 语法转化</li><li>gulp-uglify ：压缩混淆 JavaScript</li><li>gulp-file-include 公共文件包含</li><li>browsersync 浏览器实时同步</li></ul><h3 id="ws-模块"><a href="#ws-模块" class="headerlink" title="ws 模块"></a>ws 模块</h3><p>ws（<a href="https://github.com/websockets/ws">GitHub 地址</a>）是 Node.js 的 npm 实现，以便在项目中使用。</p><p>什么是 WebSocket？<br>WebSocket 是一个长连接，客户端可以给服务端发送消息，服务端也可以给客户端发送消息，两者频繁的发送消息，全双工通信模式。</p><p>参考：<a href="https://blog.csdn.net/LiMubai_CN/article/details/81844156">https://blog.csdn.net/LiMubai_CN/article/details/81844156</a></p><h3 id="cross-env-模块"><a href="#cross-env-模块" class="headerlink" title="cross-env 模块"></a>cross-env 模块</h3><p>windows 不支持 NODE_ENV=development 的设置方式<br>所以使用该模块来进行跨平台地使用环境变量，兼容各平台使用</p><h3 id="sharedb-模块"><a href="#sharedb-模块" class="headerlink" title="sharedb 模块"></a>sharedb 模块</h3><p>ShareDB 是一个整合了前后端的 OT 框架，可以很方便地自行搭建服务端和客户端。框架基于 Node.JS 实现。</p><blockquote><p>OT（Operational transformation）是一种支持高级协作软件系统中的一系列协作功能的技术。OT 最初是为了在纯文本文档的协作编辑中实现一致性维护和并发控制而发明的。它的功能已得到扩展，其应用程序已扩展至包括组撤消、锁定、冲突解决、操作通知和压缩、组感知、HTML/XML 和树状结构文档编辑、协作办公生产力工具、应用程序共享和协作计算机- 辅助媒体设计工具。[1] 2009 年，OT 被采用为 Apache Wave 协作功能背后的核心技术和谷歌文档。</p></blockquote><h3 id="sharedb-mongo-模块"><a href="#sharedb-mongo-模块" class="headerlink" title="sharedb-mongo 模块"></a>sharedb-mongo 模块</h3><h3 id="uuid-模块"><a href="#uuid-模块" class="headerlink" title="uuid 模块"></a>uuid 模块</h3><p>生成唯一的一个字符串</p><ul><li>v3：基于名字的 用相同的名字，会生成相同的 uuid 出来</li></ul><p><a href="https://juejin.cn/post/6844903708799533064">npm 的 node-uuid 和 uuid</a></p><ul><li>官网配置教程：<a href="https://editor.aomao.com/zh-CN/config/ot#%E5%8D%8F%E5%90%8C%E6%95%B0%E6%8D%AE">https://editor.aomao.com/zh-CN/config/ot</a></li><li>运行方式：将<code>ot-server</code>文件夹复制到项目根目录，将其处于运行状态，然后再运行主项目（localhost 实质上就是指向 127.0.0.1 这个本地 IP 地址。）</li></ul><h3 id="使用-nanoid-模块生成随机路径"><a href="#使用-nanoid-模块生成随机路径" class="headerlink" title="使用 nanoid 模块生成随机路径"></a>使用 nanoid 模块生成随机路径</h3><p>因为 uuid 生成的字符串太长，不便于作为 url 路径使用，所以使用 nanoid 来作为随机 url 路径</p><ul><li><a href="https://www.npmjs.com/package/nanoid">https://www.npmjs.com/package/nanoid</a></li><li><a href="https://github.com/ai/nanoid/blob/HEAD/README.zh-CN.md">https://github.com/ai/nanoid/blob/HEAD/README.zh-CN.md</a></li></ul><h2 id="Node-js-异步的解决策略"><a href="#Node-js-异步的解决策略" class="headerlink" title="Node.js 异步的解决策略"></a>Node.js 异步的解决策略</h2><p>参考：</p><ul><li><p><a href="https://segmentfault.com/a/1190000019418510">Node.js 异步处理的各种写法</a></p></li><li><p>传统的解决方案：async await 等</p></li><li><p>嵌套使用</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 👨‍💻Web开发 </category>
          
          <category> Node.js </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Git Commit 的优化</title>
      <link href="/blog/dvkqhm/"/>
      <url>/blog/dvkqhm/</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1640570522971-b4d4a696-55c0-496b-a81d-deeb3e83a111.png#clientId=ud61507db-7a0e-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u4339158d&margin=%5Bobject%20Object%5D&name=Git%20Commit%20%E4%BC%98%E5%8C%96.png&originHeight=383&originWidth=900&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=142966&status=done&style=none&taskId=ua06ab4ce-5943-4e43-b81d-ef55bc8c96c&title=" alt="Git Commit 优化.png"></p><p>前言：在使用 git 提交代码过程中，git commit 的规范常不被大多数人注意，然而版本管理工具中，代码的提交规范对项目的后续维护有着很重要的作用。故本文从以下几个方面展开述说工程开发中 git commit 优化的几个工具：</p><ul><li>commitizen：简单的 commit 规范</li><li>cz-conventional-changelog：执行会将项目 npm 发布新版本，并自动生成 CHANGELOG.md 文件</li><li>commitlint：格式校验工具</li><li>husky：Git 的钩子，在此作用为代码的提交规范和规范的校验</li><li>standard-version：辅助 cz-conventional-changelog 打 version 等功能</li></ul><h3 id="commitizen-和-cz-conventional-changelog"><a href="#commitizen-和-cz-conventional-changelog" class="headerlink" title="commitizen 和 cz-conventional-changelog"></a>commitizen 和 cz-conventional-changelog</h3><p>下载 cz-conventional-changelog commitizen</p><pre><code class="bash">cnpm i -D commitizen cz-conventional-changelog</code></pre><p>package.json 添加配置信息</p><pre><code class="json">&quot;scripts&quot;: &#123;  ...,    &quot;commit&quot;: &quot;git status &amp;&amp; git add . &amp;&amp; git-cz&quot;,  &#125;,,  &quot;config&quot;: &#123;    &quot;commitizen&quot;: &#123;      &quot;path&quot;: &quot;node_modules/cz-conventional-changelog&quot;    &#125;  &#125;</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1640510064091-ff75df38-e750-452f-8a16-6e6930f8505b.png#clientId=u7eea065d-bb8e-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=241&id=ua1b3c4e2&margin=%5Bobject%20Object%5D&name=image.png&originHeight=481&originWidth=941&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=117446&status=done&style=none&taskId=u715d2e9d-2c6d-4429-8f1b-0067fa8ad54&title=&width=470.5" alt="image.png"><br>成功提交之后<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1640510234956-c68282df-e059-4a8b-b118-0932250a7420.png#clientId=u7eea065d-bb8e-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=71&id=ue703c449&margin=%5Bobject%20Object%5D&name=image.png&originHeight=142&originWidth=1174&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=17629&status=done&style=none&taskId=u864875f4-5aac-4418-9307-4447b466b1f&title=&width=587" alt="image.png"></p><h3 id="Commitlint-及-husky"><a href="#Commitlint-及-husky" class="headerlink" title="Commitlint 及 husky"></a>Commitlint 及 husky</h3><pre><code class="bash">cnpm i -D husky @commitlint/config-conventional @commitlint/cli</code></pre><p>项目根目录新建 commitlint.config.js</p><pre><code class="javascript">module.exports = &#123; extends: [&quot;@commitlint/config-conventional&quot;] &#125;;</code></pre><p>package.json 添加如下</p><pre><code class="json"># package.json...,&quot;husky&quot;: &#123;    &quot;hooks&quot;: &#123;      &quot;commit-msg&quot;: &quot;commitlint -E $HUSKY_GIT_PARAMS&quot;    &#125;&#125;</code></pre><p>执行命令 npm run commit</p><pre><code>1.Select the type of change that you&#39;re committing 选择改动类型 (&lt;type&gt;)2.What is the scope of this change (e.g. component or file name)? 填写改动范围 (&lt;scope&gt;)3.Write a short, imperative tense description of the change: 写一个精简的描述 (&lt;subject&gt;)4.Provide a longer description of the change: (press enter to skip) 对于改动写一段长描述 (&lt;body&gt;)5.Are there any breaking changes? (y/n) 是破坏性修改吗？默认n (&lt;footer&gt;)6.Does this change affect any openreve issues? (y/n) 改动修复了哪个问题？默认n (&lt;footer&gt;)</code></pre><p>生成如下格式</p><pre><code>&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;&lt;BLANK LINE&gt;&lt;body&gt;&lt;BLANK LINE&gt;&lt;footer&gt;</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1640515038577-11c2fbe0-0e7e-4ec4-8836-2c49553151c0.png#clientId=u7eea065d-bb8e-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=52&id=ub44884a1&margin=%5Bobject%20Object%5D&name=image.png&originHeight=104&originWidth=483&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=10950&status=done&style=none&taskId=u51429ff4-97a6-483c-8f12-baea80efa88&title=&width=241.5" alt="image.png"><br>其中各自含义为</p><ul><li>scope 指 commit 的范围（哪些模块进行了修改）</li><li>subject 指 commit 的简短描述</li><li>body 指 commit 主体内容（长描述）</li><li>footer 指 commit footer 信息</li><li>type 指当前 commit 类型，一般有下面几种可选类型：</li></ul><pre><code># 主要typefeat:     增加新功能fix:      修复bug# 特殊typedocs:     只改动了文档相关的内容style:    不影响代码含义的改动，例如去掉空格、改变缩进、增删分号build:    构造工具的或者外部依赖的改动，例如webpack，npmrefactor: 代码重构时使用revert:   执行git revert打印的message# 暂不使用typetest:     添加测试或者修改现有测试perf:     提高性能的改动ci:       与CI（持续集成服务）有关的改动chore:    不修改src或者test的其余修改，例如构建过程或辅助工具的变动</code></pre><h3 id="standard-version-自动生成-CHANGELOG"><a href="#standard-version-自动生成-CHANGELOG" class="headerlink" title="standard-version: 自动生成 CHANGELOG"></a>standard-version: 自动生成 CHANGELOG</h3><p>下载插件</p><pre><code class="bash">cnpm i --save-dev standard-version</code></pre><p>package.json 添加如下</p><pre><code class="json">&#123;  &quot;scripts&quot;: &#123;    &quot;release&quot;: &quot;standard-version&quot;  &#125;&#125;</code></pre><p>执行 npm run release，在根目录会生成 CHANGELOG.md 文件<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1640515612285-57b296de-7def-4ef9-b022-286ac9ef1ac2.png#clientId=u7eea065d-bb8e-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=339&id=u715cd9c7&margin=%5Bobject%20Object%5D&name=image.png&originHeight=677&originWidth=1109&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=61348&status=done&style=none&taskId=u2421e396-549d-4769-a6e2-5a8890fcbb9&title=&width=554.5" alt="image.png"></p><h3 id="总-package-json"><a href="#总-package-json" class="headerlink" title="总 package.json"></a>总 package.json</h3><pre><code class="json">&#123;  &quot;name&quot;: &quot;web-learn-notes&quot;,  &quot;version&quot;: &quot;1.1.0&quot;,  &quot;description&quot;: &quot;web学习笔记仓库&quot;,  &quot;main&quot;: &quot;index.js&quot;,  &quot;scripts&quot;: &#123;    &quot;commit&quot;: &quot;git status &amp;&amp; git add . &amp;&amp; git-cz&quot;,    &quot;release&quot;: &quot;standard-version&quot;,    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;  &#125;,  &quot;repository&quot;: &#123;    &quot;type&quot;: &quot;git&quot;,    &quot;url&quot;: &quot;git+https://github.com/wztlink1013/web-learn-notes.git&quot;  &#125;,  &quot;keywords&quot;: [&quot;web&quot;, &quot;学习&quot;, &quot;笔记&quot;],  &quot;author&quot;: &quot;wztlink1013&quot;,  &quot;license&quot;: &quot;ISC&quot;,  &quot;bugs&quot;: &#123;    &quot;url&quot;: &quot;https://github.com/wztlink1013/web-learn-notes/issues&quot;  &#125;,  &quot;homepage&quot;: &quot;https://github.com/wztlink1013/web-learn-notes#readme&quot;,  &quot;devDependencies&quot;: &#123;    &quot;@commitlint/cli&quot;: &quot;^16.0.0&quot;,    &quot;@commitlint/config-conventional&quot;: &quot;^16.0.0&quot;,    &quot;commitizen&quot;: &quot;^4.2.4&quot;,    &quot;cz-conventional-changelog&quot;: &quot;^3.3.0&quot;,    &quot;husky&quot;: &quot;^7.0.4&quot;,    &quot;standard-version&quot;: &quot;^9.3.2&quot;  &#125;,  &quot;config&quot;: &#123;    &quot;commitizen&quot;: &#123;      &quot;path&quot;: &quot;node_modules/cz-conventional-changelog&quot;    &#125;  &#125;,  &quot;husky&quot;: &#123;    &quot;hooks&quot;: &#123;      &quot;commit-msg&quot;: &quot;commitlint -E $HUSKY_GIT_PARAMS&quot;    &#125;  &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> Git+GitHub </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Vue-CLI搭建Vue3.x+TypeScript项目</title>
      <link href="/blog/blhxct/"/>
      <url>/blog/blhxct/</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1640572147933-73df2b83-c74d-4391-a90c-c8006aba471e.png#clientId=u01e0d066-2cd9-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u1d7f2957&margin=%5Bobject%20Object%5D&name=Vue-CLI%E6%90%AD%E5%BB%BAVue3.x%2BTypeScript%E9%A1%B9%E7%9B%AE.png&originHeight=383&originWidth=900&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=47722&status=done&style=none&taskId=ucee03059-16e7-4258-9442-24bef704273&title=" alt="Vue-CLI搭建Vue3.x+TypeScript项目.png"></p><p>前言：前端工程化开发总结，使用 Vue-CLI 脚手架搭建 Vue3.x + Typescript 项目，整体项目的环境配置。</p><h2 id="下载安装-Vue-CLI"><a href="#下载安装-Vue-CLI" class="headerlink" title="下载安装 Vue-CLI"></a>下载安装 Vue-CLI</h2><ul><li>官方文档：<a href="https://cli.vuejs.org/zh/guide/">Vue CLI 🛠️ Vue.js 开发的标准工具</a></li></ul><pre><code class="bash">npm install -g @vue/cli# oryarn global add @vue/cli# orcnpm install -g @vue/cli</code></pre><p>查看版本：<code>vue --version</code><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1640413980237-9582e32f-7515-40b8-80a7-f678456ac739.png#clientId=u4b22213f-3d48-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=44&id=ua167aa8d&margin=%5Bobject%20Object%5D&name=image.png&originHeight=88&originWidth=377&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=6055&status=done&style=none&taskId=uda0378c6-6748-4bd1-961a-261568ce909&title=&width=188.5" alt="image.png"></p><h2 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h2><p>新建并初始化项目文件夹</p><pre><code class="bash">vue create vue3-cli-demo</code></pre><p>选择最后一项自定义相关配置<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1640414187756-6ebbf844-853d-4a66-b0d6-f401003c1fe8.png#clientId=u4b22213f-3d48-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=64&id=ub11023b3&margin=%5Bobject%20Object%5D&name=image.png&originHeight=127&originWidth=469&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=7161&status=done&style=none&taskId=u016245d6-16ee-4860-86cc-cc4b51da2ec&title=&width=234.5" alt="image.png"><br>全配置搭建测试<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1640414751376-5215b4c4-3e85-4be2-9ce8-6e304bd5b70f.png#clientId=u4b22213f-3d48-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=212&id=ud9b0ef21&margin=%5Bobject%20Object%5D&name=image.png&originHeight=424&originWidth=807&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=58871&status=done&style=none&taskId=ub281502a-cdc2-455e-8f44-5986d29dac5&title=&width=403.5" alt="image.png"></p><h2 id="vue-config-js"><a href="#vue-config-js" class="headerlink" title="vue.config.js"></a>vue.config.js</h2><p>Vue 项目的配置文件（详查：<a href="https://cli.vuejs.org/zh/config/#vue-config-js">https://cli.vuejs.org/zh/config/#vue-config-js</a>）</p><pre><code class="javascript">module.exports = &#123;  // 打包的目录  outputDir: &quot;dist&quot;,  // 在保存时校验格式  lintOnSave: true,  // 生产环境是否生成 SourceMap  productionSourceMap: false,  devServer: &#123;    // 启动服务后是否打开浏览器    open: true,    // 错误信息展示到页面    overlay: &#123;      warnings: true,      errors: true,    &#125;,    host: &quot;0.0.0.0&quot;,    port: 8066, // 服务端口    https: false,    hotOnly: false,    // proxy: &#123; // 设置代理    //   &#39;/api&#39;: &#123;    //     target: host,    //     changeOrigin: true,    //     pathRewrite: &#123;    //       &#39;/api&#39;: &#39;/&#39;,    //     &#125;    //   &#125;,    // &#125;,  &#125;,&#125;;</code></pre><h2 id="单元测试-Jest"><a href="#单元测试-Jest" class="headerlink" title="[单元测试]Jest"></a>[单元测试]Jest</h2><h3 id="Vue3-x-TypeScript-项目下的-jest-单元测试"><a href="#Vue3-x-TypeScript-项目下的-jest-单元测试" class="headerlink" title="Vue3.x+TypeScript 项目下的 jest 单元测试"></a>Vue3.x+TypeScript 项目下的 jest 单元测试</h3><p>官网 API：<a href="https://next.vue-test-utils.vuejs.org/api/">https://next.vue-test-utils.vuejs.org/api/</a></p><h4 id="jest-config-js"><a href="#jest-config-js" class="headerlink" title="jest.config.js"></a>jest.config.js</h4><p>项目搭建成功之后的默认配置如下：</p><pre><code class="javascript">module.exports = &#123;  preset: &quot;@vue/cli-plugin-unit-jest/presets/typescript-and-babel&quot;,  transform: &#123;    &quot;^.+\\.vue$&quot;: &quot;vue-jest&quot;,  &#125;,&#125;;</code></pre><p>更改如下配置</p><pre><code class="javascript">/* * @Author: wztlink1013 * @Date: 2021-12-25 14:49:37 * @LastEditTime: 2021-12-26 14:56:39 * @Description: */module.exports = &#123;  preset: &quot;@vue/cli-plugin-unit-jest/presets/typescript-and-babel&quot;,  // 测试的文件类型  moduleFileExtensions: [&quot;js&quot;, &quot;jsx&quot;, &quot;json&quot;, &quot;vue&quot;, &quot;ts&quot;, &quot;tsx&quot;],  // 转化方式  transform: &#123;    &quot;^.+\\.vue$&quot;: &quot;&lt;rootDir&gt;/node_modules/vue-jest&quot;,    &quot;.+\\.(css|styl|less|sass|scss|svg|png|jpg|ttf|woff|woff2)$&quot;:      &quot;&lt;rootDir&gt;/node_modules/jest-transform-stub&quot;,    &quot;^.+\\.jsx?$&quot;: &quot;&lt;rootDir&gt;/node_modules/babel-jest&quot;,    &quot;^.+\\.tsx?$&quot;: &quot;&lt;rootDir&gt;/node_modules/ts-jest&quot;,  &#125;,  // 不进行匹配的目录  transformIgnorePatterns: [&quot;&lt;rootDir&gt;/node_modules/&quot;],  // 匹配哪些文件进行测试  testMatch: [&quot;**/tests/unit/**/*.spec.[jt]s?(x)&quot;, &quot;**/__tests__/*.[jt]s?(x)&quot;],  // @符号 表示当前项目下的src  moduleNameMapper: &#123;    &quot;^@/(.*)$&quot;: &quot;&lt;rootDir&gt;/src/$1&quot;,  &#125;,  // 将保存的快照测试结果进行序列化，使得其更美观  snapshotSerializers: [&quot;jest-serializer-vue&quot;],&#125;;</code></pre><h4 id="单个文件的单元测试"><a href="#单个文件的单元测试" class="headerlink" title="单个文件的单元测试"></a>单个文件的单元测试</h4><p>项目下运行单元测试命令 <code>test:unit</code> 默认测试所有测试文件，不能指定文件进行单元测试。</p><p>在本地下载全局 jest 然后指定命令去执行项目的单个文件单个测试</p><pre><code class="bash">cnpm install jest --global</code></pre><p>然后执行</p><pre><code class="bash">jest ./tests/unit/jestTest.spec.ts</code></pre><p>或</p><pre><code>npx jest ./tests/unit/jestTest.spec.ts</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1640502745377-c5d57f26-13d6-4701-b7fd-aa1fb0b4312f.png#clientId=u7eea065d-bb8e-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=191&id=u261c3a42&margin=%5Bobject%20Object%5D&name=image.png&originHeight=381&originWidth=595&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=37041&status=done&style=none&taskId=u21e6a05e-867b-4a2c-973f-15bebcd5776&title=&width=297.5" alt="image.png"></p><h3 id="空白项目下的-jest-单元测试"><a href="#空白项目下的-jest-单元测试" class="headerlink" title="空白项目下的 jest 单元测试"></a>空白项目下的 jest 单元测试</h3><h4 id="初始化-npm-插件项目"><a href="#初始化-npm-插件项目" class="headerlink" title="初始化 npm 插件项目"></a>初始化 npm 插件项目</h4><pre><code class="bash">npm init -y</code></pre><h4 id="下载-Jest-和-babel-依赖"><a href="#下载-Jest-和-babel-依赖" class="headerlink" title="下载 Jest 和 babel 依赖"></a>下载 Jest 和 babel 依赖</h4><pre><code class="bash">cnpm i @babel/core @babel/preset-env  jest@24.8.0 -D</code></pre><h4 id="创建测试文件"><a href="#创建测试文件" class="headerlink" title="创建测试文件"></a>创建测试文件</h4><p>创建测试框架用的文件 index.js 和 index.test.js 两个文件<br><code>index.js</code></p><pre><code class="javascript">/* * @Descripttion: * @Date: 2021-12-07 20:08:15 * @LastEditTime: 2021-12-07 20:08:16 */export const add = (a, b) =&gt; &#123;  return a + b;&#125;;export const reduce = (a, b) =&gt; &#123;  return a - b;&#125;;</code></pre><p><code>index.test.js</code></p><pre><code class="javascript">/* * @Descripttion: * @Date: 2021-12-07 20:08:31 * @LastEditTime: 2021-12-07 20:45:17 */import &#123; add, reduce &#125; from &quot;./index&quot;;// toBe 数字test(&quot;测试add函数&quot;, () =&gt; &#123;  expect(add(1, 2)).toBe(3);&#125;);test(&quot;测试add函数（函数功能出错===打印）&quot;, () =&gt; &#123;  expect(add(1, 2)).toBe(4);&#125;);test(&quot;测试reduce函数&quot;, () =&gt; &#123;  expect(reduce(3, 2)).toBe(1);&#125;);</code></pre><p>不能运行是 node 环境不能直接使用 es6 语法，需要只用 babel 来转换<br>新建<code>.babelrc</code>文件</p><pre><code class="bash">// .babelrc&#123;    &quot;presets&quot;: [            [&quot;@babel/preset-env&quot;, &#123;                &quot;targets&quot;: &quot;&gt; 5%&quot;            &#125;]    ]&#125;</code></pre><h4 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h4><p>运行 npm run test 就可以测试了<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1638881167559-731c4af0-07c1-4d1b-b3d2-9273ab358fcb.png#clientId=ucda71d63-20a4-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=356&id=Bt95b&margin=%5Bobject%20Object%5D&name=image.png&originHeight=712&originWidth=1653&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=137248&status=done&style=none&taskId=u8ac28f4c-b511-4b94-9225-de8ea201df3&title=&width=826.5" alt="image.png"></p><h3 id="Jest-API-及相关命令"><a href="#Jest-API-及相关命令" class="headerlink" title="Jest API 及相关命令"></a>Jest API 及相关命令</h3><ul><li>官方文档：<a href="https://jestjs.io/zh-Hans/docs/getting-started">https://jestjs.io/zh-Hans/docs/getting-started</a></li></ul><p>相关教程：</p><ul><li><a href="https://juejin.cn/post/6844904114753634317">Jest 前端自动化测试入门</a></li><li><a href="https://xie.infoq.cn/article/f743bf48dc9ea09e5cbd7285c">搭建基本 Jest 测试框架，解读覆盖率实现原理</a></li><li><a href="https://juejin.cn/post/6844904082516377607">vue 项目搭建 jest 单元测试及采坑</a></li><li><a href="https://cloud.tencent.com/developer/article/1602142">Vue-Test-Utils + Jest 单元测试入门与实践</a></li><li>eslint 就可以使用：<a href="https://www.npmjs.com/package/eslint-plugin-jest">eslint-plugin-jest</a></li></ul><h4 id="Jest-API"><a href="#Jest-API" class="headerlink" title="Jest API"></a>Jest API</h4><ul><li><code>test()</code>类似请求后端接口一样，请求成功或失败的判断</li><li><code>expect()</code>则是判断和预期的值是否一样，然后执行相应的操作</li><li><code>toBe()</code>就是写入预期值来判断是否和自己写的代码值是否一样</li><li><code>describe</code> 描述, decribe 会形成一个作用域</li><li><code>it</code> 断言</li></ul><h4 id="jest-–coverage"><a href="#jest-–coverage" class="headerlink" title="jest –coverage"></a>jest –coverage</h4><p>查看覆盖率命令<br>该命令可以可视化展示，也可以在浏览器打开可视化结果网页<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1640503326529-c0e50682-a7d0-4e47-9be3-df6c5e71b8e3.png#clientId=u7eea065d-bb8e-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=284&id=u1305df8b&margin=%5Bobject%20Object%5D&name=image.png&originHeight=567&originWidth=1163&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=118032&status=done&style=none&taskId=u730983d2-ef03-4431-a420-8bb49c728a8&title=&width=581.5" alt="image.png"></p><h2 id="单元测试-e2e-cypress"><a href="#单元测试-e2e-cypress" class="headerlink" title="[单元测试]e2e-cypress"></a>[单元测试]e2e-cypress</h2><p>插眼：日后再深入了解<br><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1640504518665-55a6bd16-bb69-411d-bc9b-de4b6e2db2cc.jpeg#crop=0&crop=0&crop=1&crop=1&id=nTdFS&originHeight=58&originWidth=79&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&title="><br>Vue 官方插件地址：</p><ul><li><a href="https://www.npmjs.com/package/@vue/cli-plugin-e2e-cypress">https://www.npmjs.com/package/@vue/cli-plugin-e2e-cypress</a></li></ul><p>参考教程：</p><ul><li><a href="https://www.jianshu.com/p/459612488233">Vue 项目采用 Cypress 做 e2e 自动化测试，手把手一撸到底</a></li></ul><h2 id="Vue3-TypeScript-项目搭建过程中报错"><a href="#Vue3-TypeScript-项目搭建过程中报错" class="headerlink" title="Vue3+TypeScript 项目搭建过程中报错"></a>Vue3+TypeScript 项目搭建过程中报错</h2><h3 id="VSCode-插件-ESLint-Prettier-vetur-代码格式化冲突"><a href="#VSCode-插件-ESLint-Prettier-vetur-代码格式化冲突" class="headerlink" title="VSCode 插件 ESLint+Prettier+vetur 代码格式化冲突"></a>VSCode 插件 ESLint+Prettier+vetur 代码格式化冲突</h3><p>这三者是代码校验和格式化的插件，当 vue3.x 项目搭建成功之后<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1640422446727-53aab258-0454-486d-b2e7-f4c181c7b404.png#clientId=u2c3bc674-1572-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=36&id=W9mzl&margin=%5Bobject%20Object%5D&name=image.png&originHeight=72&originWidth=571&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=41601&status=done&style=none&taskId=u548b3ce1-52b7-4c4c-b289-07d4fcf6bb4&title=&width=285.5" alt="image.png"><br>该行配置需要注释，不然代码保存之后，会经过 Prettier 和 vetur 两者之间的来回格式化顺序，导致不能正常格式化。</p><p>具体矛盾原因：</p><ul><li><p><a href="https://zhuanlan.zhihu.com/p/101241781">解决 vscode eslint 与 prettier 冲突</a></p></li><li><p><a href="https://zhuanlan.zhihu.com/p/347339865">VSCode 中 ESLint、Prettier 配置冲突问题原因及解决方案</a></p></li><li><p><a href="https://www.cnblogs.com/wangpenghui522/p/13727990.html">VSCode-Prettier 和 ESLint 如何和睦共处? </a></p></li><li><p><a href="https://cloud.tencent.com/developer/article/1802491">Vue 基于 VSCode 结合 Vetur+ESlint+Prettier 统一 Vue 代码风格</a></p></li><li><p>Prettier 插件：一定要留，能保存所有文件，按照自己规则进行格式化</p></li><li><p>ESLint 插件</p></li><li><p>vetur 插件</p></li><li><p>Vue 项目中的 prettier 插件</p></li><li><p>Vue 项目中的 eslint 插件</p></li><li><p>Vue 项目中的 eslint 的各个子插件</p><ul><li>eslint-plugin-prettier：这个就是 typescript 项目中上述冲突的缘由</li><li>eslint-config-prettier</li><li>……</li></ul></li></ul><h3 id="Error-Cannot-find-module-‘vue-loader-v16-package-json’"><a href="#Error-Cannot-find-module-‘vue-loader-v16-package-json’" class="headerlink" title="Error: Cannot find module ‘vue-loader-v16/package.json’"></a>Error: Cannot find module ‘vue-loader-v16/package.json’</h3><p>在导入 Vue3 + TypeScript 的项目</p><ol><li>升级 npm</li></ol><p>使用 cnpm 的也要升级一下 cnpm</p><pre><code class="bash">cnpm i -g cnpm</code></pre><ol start="2"><li>重新安装 node_modules 依赖包</li></ol><pre><code class="bash">cnpm i // 重新安装</code></pre><ol start="3"><li>重新下载</li></ol><pre><code class="bash">cnpm i -D vue-loader-v16</code></pre><h3 id="vue-no-multiple-template-root-The-template-root-requires-exactly-one-element-eslint-plugin-vue"><a href="#vue-no-multiple-template-root-The-template-root-requires-exactly-one-element-eslint-plugin-vue" class="headerlink" title="[vue/no-multiple-template-root]The template root requires exactly one element.eslint-plugin-vue"></a>[vue/no-multiple-template-root]The template root requires exactly one element.eslint-plugin-vue</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1640357960271-5a2b291c-9a75-45eb-90c7-181a081cd1b3.png#clientId=ua2d91374-f0a2-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=265&id=LDxro&margin=%5Bobject%20Object%5D&name=image.png&originHeight=530&originWidth=1048&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=56340&status=done&style=none&taskId=u1827695c-31a6-43ea-8dec-dda5389886c&title=&width=524" alt="image.png"></p><h3 id="找不到模块“”-aomao-engine””或其相应的类型声明。ts-2307"><a href="#找不到模块“”-aomao-engine””或其相应的类型声明。ts-2307" class="headerlink" title="找不到模块“”@aomao/engine””或其相应的类型声明。ts(2307)"></a>找不到模块“”@aomao/engine””或其相应的类型声明。ts(2307)</h3><div style="background: #FFF3F3;padding:10px;border: 1px solid #DEB8BE;border-radius:5px;margin-bottom:5px;">报错信息</div>```bash找不到模块“"@aomao/engine"”或其相应的类型声明。ts(2307)``````bash模块“"@aomao/engine"”没有导出的成员“PluginEntry”。ts(2305)```<div style="background: #edf9e8;padding:10px;border: 1px solid #c2d2b5;border-radius:5px;margin-bottom:5px;">按照网上找的一些方法，都无法解决这个问题重启可以解决，插件用的太多===太卡顿</div><h3 id="‘vue-comment-directive’-—-error-in-the-end-of-public-index-html-just-after-vue-cli-installation"><a href="#‘vue-comment-directive’-—-error-in-the-end-of-public-index-html-just-after-vue-cli-installation" class="headerlink" title="‘vue/comment-directive’ — error in the end of public/index.html just after vue-cli installation"></a>‘vue/comment-directive’ — error in the end of public/index.html just after vue-cli installation</h3><p>public 文件夹次啊的 index.html 文件末尾会有该报错，解决办法就是配置相关 rule<br><a href="https://github.com/vuejs/eslint-plugin-vue/issues/1355">https://github.com/vuejs/eslint-plugin-vue/issues/1355</a></p><h3 id="Delete-␍eslintprettier-prettier"><a href="#Delete-␍eslintprettier-prettier" class="headerlink" title="Delete ␍eslintprettier/prettier"></a>Delete <code>␍</code>eslintprettier/prettier</h3><p>将代码 push 到 GitHub 仓库，新拉取下来，文件的每行代码会有此报错<br><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1644376958819-fecf2dc0-76f0-4a31-b2a8-269dd345223d.png#clientId=u3756e34d-5956-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=141&id=ua5af1e6f&margin=%5Bobject%20Object%5D&name=image.png&originHeight=141&originWidth=536&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=86221&status=done&style=none&taskId=u2b35c8af-a51e-4081-a134-aa2bfdcb638&title=&width=536" alt="image.png"></p><p>报错原因：文本文件的换行符不一致<br>具体参考：<a href="https://juejin.cn/post/6844904069304156168#heading-6">https://juejin.cn/post/6844904069304156168#heading-6</a><br>解决办法：</p><ol><li>【治标】如果只有少个文件，将 vscode 右下角处改为 LF 即可</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1644377438548-8db15f94-e644-43ac-bad4-2f4ce86eb274.png#clientId=u3756e34d-5956-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=111&id=u08d40637&margin=%5Bobject%20Object%5D&name=image.png&originHeight=111&originWidth=449&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=16273&status=done&style=none&taskId=u6d4468b6-8893-46fe-8a49-fc4606c1b58&title=&width=449" alt="image.png"></p><ol start="2"><li>【治本】在 windows 环境下，全局关掉转换行</li></ol><pre><code class="bash">git config --global core.autocrlf false</code></pre><p>然后再将刚刚拉取到本地的项目删掉，重新从 GitHub 拉取到本地，就不会出现该报错了</p><ol start="3"><li>另外，在 vscode 设置中设置如下，可以达到新建文件就是 LF 转换行的效果了</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1644377676559-12ee984b-e189-4dcf-8a72-59e37198b974.png#clientId=u3756e34d-5956-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=55&id=u84528446&margin=%5Bobject%20Object%5D&name=image.png&originHeight=55&originWidth=362&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=14023&status=done&style=none&taskId=u7045718f-4060-4242-b6cf-b58bd89fd52&title=&width=362" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> 🔨环境工具 </category>
          
          <category> 环境搭建 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>炒青菜</title>
      <link href="/essay/cook_greens/"/>
      <url>/essay/cook_greens/</url>
      
        <content type="html"><![CDATA[<p>这是加密文章！</p>]]></content>
      
      
      <categories>
          
          <category> 料理 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>炒鸡肉</title>
      <link href="/essay/cook_chicken/"/>
      <url>/essay/cook_chicken/</url>
      
        <content type="html"><![CDATA[<ul><li>切块，炒<blockquote><p>目的就是把鸡肉身体里面的水分去掉</p></blockquote></li></ul><p>具体的操作步骤：<br>① 倒入香油，待香油表面的一层油花去掉，再将鸡肉导入<br>② 炒到鸡肉大部分水分已经去掉了，放入生姜，小米椒，放盐……<br>（此时放盐，只是以便待会炖好可以直接吃，也可以放在待会放的）</p><ul><li>锅炖</li></ul><p>锅下面放入适量的水，不能过多，不然溢到鸡肉里面就不能吃了<br>同时还需要用个小盖子将鸡肉盖住，这样一面汽水浸入鸡肉里面，也不能吃</p><p>这个时候理论上是可以直接吃的，但是如果自己觉得荤味太重，也可以再拿出来，再放入一点点香油小炒小烩</p><p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1639711573828-ce9f3075-2dbc-465e-921f-121f56bb00e0.jpeg#crop=0&crop=0&crop=1&crop=1&id=YodIL&originHeight=60&originWidth=60&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&title="></p>]]></content>
      
      
      <categories>
          
          <category> 料理 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>一个梦——害怕</title>
      <link href="/essay/ifuuic/"/>
      <url>/essay/ifuuic/</url>
      
        <content type="html"><![CDATA[<p><strong>被误会</strong><br>两个同事和一个老人，那个老人迷迷糊糊 缓缓 进到我们房子里面，然后不知道一直在干嘛，最后是我的室友 A 不知道哪来的一把特别特别锋利的刀无意间割伤那位老人的大腿，导致大量失血，最终死了<br>然后第二天，有班主任来追究这件事，我不知道怎么的，对质的时候，我正好不在，他们两个被叫去对质，听别人说，他们对质的时候说的答案不一样，反正最后，被误会成是我，我有理说不清，那个老人不是我杀的，但是我的内心又不想说是那个室友做的，于是一直耽搁，我的心里很矛盾，最终，他们统一和班主任说，看到我在那位老人面前用刀…我不知道怎么的，明明不是我，可我在逃避，我不知道在怕什么，可能是全世界都以为我是凶手，可我不是，我争辩不了，那种无力感，那种委屈，那种害怕…</p><p><strong>妈妈失忆</strong><br>一切的落魄，我又回到那个房子里，又有一个老人走到我面前，那是我妈妈，我不知道妈妈怎么就突然瞬间变老了，样子还是一样，但是已经失忆了，我妈妈不记得我了…我哭，一直哭，我一直说，我是你儿子呀，可是我在我妈妈面前就是一个陌生人，我好伤心，一直哭，我妈妈还对房子外面的路过的街坊邻居说，你们看，这个孩子真懂事，而我呆呆地站在那，伤心到形神分离…</p><p>梦醒了，脚在抽搐，抽搐的那块被子特别冰凉，原来是没关窗户，十二月的冷风吹进来了……<br>2021.12.03 07:04</p><p>后记：<br>一个人最失意甚至死亡的时候，脑子里面浮现的，其实是亲人，在小的时候，有次和小伙伴去湖里面游泳，那是我第一次下水游泳，当时差点淹死，我至今都清楚地记得我倒在水里面的时候，一直呛水那会，脑子里面想的其实就是家里厨房，客厅，还有熟悉的我妈叫我吃饭那声音……</p><p>很多人说我很冷，可我其实不是，相处之后，我觉得我还是比较重感情的，我挺感谢这个梦的…</p><p>人其实都有两面，一面是原本流露真情的自我，一面是这个世界这个周围环境甚至自身经历所塑造的自己，可能沉稳，冷静，等等这些都是他人所看到的，然而人的还有一面，就像迟子建笔下的杨二嫂一般，将丈夫的尸体锁在冰柜，深夜独自买醉，因为这可能就是对自我感情的一种救赎，因为到了白天，当周围不再是黑夜，人们不再抒情，用坚强的外壳去跻身于这个不好不坏，不完美却也没有大缺陷的世界中…</p><p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1638506128821-fd0914a3-839b-4cb9-9e0b-a79b4d557a1e.jpeg#clientId=ubce12c44-2c3c-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u8c4a114e&margin=%5Bobject%20Object%5D&name=Screenshot_20211203_123147_com.huawei.notepad.jpg&originHeight=5640&originWidth=1176&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=4857931&status=done&style=none&taskId=u6d95a767-e96b-4d5b-baea-8826935aa9a&title=" alt="Screenshot_20211203_123147_com.huawei.notepad.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 异世界 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>🔏css规范</title>
      <link href="/blog/zfqqd0/"/>
      <url>/blog/zfqqd0/</url>
      
        <content type="html"><![CDATA[<p>这是加密文章！</p>]]></content>
      
      
      <categories>
          
          <category> 👨‍💻Web开发 </category>
          
          <category> HTML+CSS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Nginx常用命令</title>
      <link href="/blog/kz2il6/"/>
      <url>/blog/kz2il6/</url>
      
        <content type="html"><![CDATA[<pre><code class="nginx">cd e:\Nginxcd nginx-1.16.1start nginxtasklist /fi &quot;imagename eq nginx.exe&quot;     //查看进程nginx -t -c ./conf/nginx.conf   //检查配置文件nginx -s reload  //重启服务nginx -s stop   //快速停止nginx -s quit   //完整有序的停止server &#123;        listen       80;        server_name  tf.local.msshuo.cn;        #server_name  kf.local.msshuo.cn;        #charset koi8-r;        #access_log  logs/host.access.log  main;        location / &#123;            root   E:\\mly\\ad_dist;            #root   E:\mly\kf_dist;            index  index.html index.htm;        &#125;        #error_page  404              /404.html;        # redirect server error pages to the static page /50x.html        #        error_page   500 502 503 504  /50x.html;        location = /50x.html &#123;            root   html;        &#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 软件工程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>14种设计模式</title>
      <link href="/blog/figfyg/"/>
      <url>/blog/figfyg/</url>
      
        <content type="html"><![CDATA[<p>这是加密文章！</p>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>axios发送请求报错：Cannot read property &#39;cancelToken&#39; of undefined</title>
      <link href="/blog/d75374fb-d238-4bcb-9146-e8b182b66752/"/>
      <url>/blog/d75374fb-d238-4bcb-9146-e8b182b66752/</url>
      
        <content type="html"><![CDATA[<p><img src="https://img2020.cnblogs.com/blog/1269599/202005/1269599-20200520145553205-2092514210.png#crop=0&crop=0&crop=1&crop=1&id=qbL6v&originHeight=304&originWidth=955&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=stroke&title="></p><p>bug 原因：在使用 axios 的拦截器时，没有添加返回值   return  config<br>解决方法：在请求拦截器中添加 return config，  （！！！注意响应拦截器中也要添加返回值）</p><p><img src="https://img2020.cnblogs.com/blog/1269599/202005/1269599-20200520145902689-569364923.png#crop=0&crop=0&crop=1&crop=1&id=kjLXK&originHeight=526&originWidth=738&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&title="></p>]]></content>
      
      
      <categories>
          
          <category> ✨其他 </category>
          
          <category> Bug </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>《华丽人生》原文摘录</title>
      <link href="/essay/algh82/"/>
      <url>/essay/algh82/</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1639824740044-5fc3d698-c9be-4993-ad8d-688ea9a6947d.png#clientId=udf3bfa5f-b03f-4&from=paste&id=u8defc980&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1637&originWidth=1080&originalType=url%E2%88%B6=1&size=1386545&status=done&style=none&taskId=u4c18ea6c-350b-4cf5-b87e-bb64fa3395f" alt="image.png"></p><p>我放弃抵抗人生。这世上有一股巨大的潮流，就算反抗那股潮流，终究还是会被推着走。如果能理解我们活着的背后有一股巨大的力量，那就没什么好怕的，也不需要逃避。就算我们自以为靠着自我压抑和选择过日子，其实也不过就是”被迫活着”而已，不是吗？” …… “是海洋啊。”黑泽耸耸肩说道，“人生是既没有路线也没有标志的茫茫大海啊。我们只是身在其中，紧紧抓住一条大鱼，委身于巨大的海流罢了</p>]]></content>
      
      
      <categories>
          
          <category> 阅读 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数组去重🔖JavaScript🔖数组</title>
      <link href="/blog/array-deduplication/"/>
      <url>/blog/array-deduplication/</url>
      
        <content type="html"><![CDATA[<p>总结来看，去重分三种思路：</p><ul><li>es6 的 Set 数据结构</li><li>Array 的各类 api</li><li>利用对象的属性</li></ul><p>文章参考：<a href="https://segmentfault.com/a/1190000016418021">https://segmentfault.com/a/1190000016418021</a></p><h2 id="一、利用-ES6-Set-去重（ES6-中最常用）"><a href="#一、利用-ES6-Set-去重（ES6-中最常用）" class="headerlink" title="一、利用 ES6 Set 去重（ES6 中最常用）"></a>一、利用 ES6 Set 去重（ES6 中最常用）</h2><pre><code class="javascript">arr_test = [  0,  0,  999,  999,  &quot;字符串&quot;,  &quot;字符串&quot;,  true,  true,  false,  false,  undefined,  undefined,  null,  null,  NaN,  NaN,  &#123;&#125;,  &#123;&#125;,  [],  [],];let unique_set = (arr) =&gt; &#123;  return Array.from(new Set(arr));&#125;;console.log(unique_set(arr_test));</code></pre><p>或者……</p><pre><code class="javascript">console.log([...new Set(arr_test)]);</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1651548685623-2a8e3fb9-2f10-4f98-bb4d-bede8276712f.png#clientId=uec5099ef-906b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=144&id=u5b9461cf&margin=%5Bobject%20Object%5D&name=image.png&originHeight=173&originWidth=279&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=6929&status=done&style=none&taskId=u9cd14827-6b02-4c05-b9f0-242afc49431&title=&width=232.49999076128043" alt="image.png"></p><div style="background: #FFF3F3;padding:10px;border: 1px solid #DEB8BE;border-radius:5px;margin-bottom:5px;">去不掉<ul><li>{}</li><li>[]</div></li></ul><h2 id="二、利用-for-嵌套-for，然后-splice-去重（ES5-中最常用）"><a href="#二、利用-for-嵌套-for，然后-splice-去重（ES5-中最常用）" class="headerlink" title="二、利用 for 嵌套 for，然后 splice 去重（ES5 中最常用）"></a>二、利用 for 嵌套 for，然后 splice 去重（ES5 中最常用）</h2><pre><code class="javascript">arr_test = [  0,  0,  999,  999,  &quot;字符串&quot;,  &quot;字符串&quot;,  true,  true,  false,  false,  undefined,  undefined,  null,  null,  NaN,  NaN,  &#123;&#125;,  &#123;&#125;,  [],  [],];let unique_for_for_splice = (arr) =&gt; &#123;  for (let i = 0; i &lt; arr.length; i++) &#123;    for (let j = i + 1; j &lt; arr.length; j++) &#123;      if (arr[i] === arr[j]) &#123;        arr.splice(j, 1);      &#125;    &#125;  &#125;  return arr;&#125;;console.log(unique_for_for_splice(arr_test));</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1651548810144-b36aa36d-87c9-4879-bd0a-12f3c4f55295.png#clientId=uec5099ef-906b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=157&id=u8b1b4557&margin=%5Bobject%20Object%5D&name=image.png&originHeight=189&originWidth=274&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=6651&status=done&style=none&taskId=u4fdb60ce-312b-4611-ae74-12552368393&title=&width=228.33332426018222" alt="image.png"></p><div style="background: #FFF3F3;padding:10px;border: 1px solid #DEB8BE;border-radius:5px;margin-bottom:5px;">去不掉<ul><li>NaN</li><li>{}</li><li>[]</div></li></ul><h2 id="三、利用-includes-indexOf-去重"><a href="#三、利用-includes-indexOf-去重" class="headerlink" title="三、利用 includes/indexOf 去重"></a>三、利用 includes/indexOf 去重</h2><pre><code class="javascript">let unique_includes = (arr) =&gt; &#123;  let result = [];  arr.forEach((data) =&gt; &#123;    if (!result.includes(data)) result.push(data);  &#125;);  return result;&#125;;console.log(unique_includes(arr_test));</code></pre><pre><code class="javascript">let unique_indexof = (arr) =&gt; &#123;  let result = [];  arr.forEach((data) =&gt; &#123;    if (result.indexOf(data) === -1) result.push(data);  &#125;);  return result;&#125;;console.log(unique_indexof(arr_test));</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1651549129756-b5675fd2-1851-4b74-923a-6bd90675fcd4.png#clientId=uec5099ef-906b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=157&id=uda11904a&margin=%5Bobject%20Object%5D&name=image.png&originHeight=188&originWidth=284&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=12315&status=done&style=none&taskId=u2e4e24ba-fb88-4cfc-ae9b-f2965f03d7a&title=&width=236.66665726237864" alt="image.png"></p><h2 id="四、利用-sort"><a href="#四、利用-sort" class="headerlink" title="四、利用 sort()"></a>四、利用 sort()</h2><pre><code class="javascript">let unique_sort = (arr) =&gt; &#123;  arr.sort().forEach((data, index) =&gt; &#123;    if (data === arr[index + 1] &amp;&amp; index &lt; arr.length - 1)      arr.splice(index + 1, 1);  &#125;);  return arr;&#125;;console.log(unique_indexof(arr_test));</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1651549585258-df18b8b6-1a2f-4345-a7a2-db2635e84b13.png#clientId=uec5099ef-906b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=141&id=u150d350e&margin=%5Bobject%20Object%5D&name=image.png&originHeight=169&originWidth=341&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=10579&status=done&style=none&taskId=u7aa2124d-13b3-48d6-8b30-f334ff8ce12&title=&width=284.1666553748983" alt="image.png"></p><h2 id="五、利用-filter"><a href="#五、利用-filter" class="headerlink" title="五、利用 filter"></a>五、利用 filter</h2><pre><code class="javascript">let unique_filter = (arr) =&gt; &#123;  return arr.filter((data, index, arr) =&gt; &#123;    return arr.indexOf(data, 0) === index;  &#125;);&#125;;console.log(unique_filter(arr_test));</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1651550392520-a342d7c0-9102-49db-b672-3c70b887d258.png#clientId=uec5099ef-906b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=143&id=nMX9A&margin=%5Bobject%20Object%5D&name=image.png&originHeight=172&originWidth=356&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=9050&status=done&style=none&taskId=u91cd53c7-ec93-435b-acb9-0a641c45645&title=&width=296.66665487819296" alt="image.png"></p><h2 id="六、利用-reduce"><a href="#六、利用-reduce" class="headerlink" title="六、利用 reduce"></a>六、利用 reduce</h2><pre><code class="javascript">let unique_reduce = (arr) =&gt; &#123;  return arr.reduce((a, b) =&gt; (a.includes(b) ? a : [...a, b]), []);&#125;;console.log(unique_reduce(arr_test));</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1651550878738-7acdd3ef-54cd-4572-97e6-0e8c43b5719e.png#clientId=uec5099ef-906b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=146&id=jhDy7&margin=%5Bobject%20Object%5D&name=image.png&originHeight=175&originWidth=365&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=9360&status=done&style=none&taskId=u13083926-1278-4420-a5b8-7d00e13774f&title=&width=304.16665458016973" alt="image.png"></p><h2 id="利用对象的属性不能相同的特点进行去重（这种数组去重的方法有问题，不建议用，有待改进）"><a href="#利用对象的属性不能相同的特点进行去重（这种数组去重的方法有问题，不建议用，有待改进）" class="headerlink" title="利用对象的属性不能相同的特点进行去重（这种数组去重的方法有问题，不建议用，有待改进）"></a>利用对象的属性不能相同的特点进行去重（这种数组去重的方法有问题，不建议用，有待改进）</h2><pre><code>function unique(arr) &#123;    if (!Array.isArray(arr)) &#123;        console.log(&#39;type error!&#39;)        return    &#125;    var arrry= \[\];     var  obj = &#123;&#125;;    for (var i = 0; i &lt; arr.length; i++) &#123;        if (!obj\[arr\[i\]\]) &#123;            arrry.push(arr\[i\])            obj\[arr\[i\]\] = 1        &#125; else &#123;            obj\[arr\[i\]\]++        &#125;    &#125;    return arrry;&#125;    var arr = \[1,1,&#39;true&#39;,&#39;true&#39;,true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,&#39;NaN&#39;, 0, 0, &#39;a&#39;, &#39;a&#39;,&#123;&#125;,&#123;&#125;\];        console.log(unique(arr))//\[1, &quot;true&quot;, 15, false, undefined, null, NaN, 0, &quot;a&quot;, &#123;…&#125;\]    //两个true直接去掉了，NaN和&#123;&#125;去重</code></pre><h2 id="利用-hasOwnProperty"><a href="#利用-hasOwnProperty" class="headerlink" title="利用 hasOwnProperty"></a>利用 hasOwnProperty</h2><pre><code>function unique(arr) &#123;    var obj = &#123;&#125;;    return arr.filter(function(item, index, arr)&#123;        return obj.hasOwnProperty(typeof item + item) ? false : (obj\[typeof item + item\] = true)    &#125;)&#125;    var arr = \[1,1,&#39;true&#39;,&#39;true&#39;,true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,&#39;NaN&#39;, 0, 0, &#39;a&#39;, &#39;a&#39;,&#123;&#125;,&#123;&#125;\];        console.log(unique(arr))//\[1, &quot;true&quot;, true, 15, false, undefined, null, NaN, &quot;NaN&quot;, 0, &quot;a&quot;, &#123;…&#125;\]   //所有的都去重了</code></pre><p>利用 hasOwnProperty 判断是否存在对象属性</p><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="利用递归去重"><a href="#利用递归去重" class="headerlink" title="利用递归去重"></a>利用递归去重</h2><pre><code>function unique(arr) &#123;        var array\= arr;        var len = array.length;    array.sort(function(a,b)&#123;   //排序后更加方便去重        return a - b;    &#125;)    function loop(index)&#123;        if(index &gt;= 1)&#123;            if(array\[index\] === array\[index\-1\])&#123;                array.splice(index,1);            &#125;            loop(index - 1);    //递归loop，然后数组去重        &#125;    &#125;    loop(len\-1);    return array;&#125; var arr = \[1,1,&#39;true&#39;,&#39;true&#39;,true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,&#39;NaN&#39;, 0, 0, &#39;a&#39;, &#39;a&#39;,&#123;&#125;,&#123;&#125;\];console.log(unique(arr))//\[1, &quot;a&quot;, &quot;true&quot;, true, 15, false, 1, &#123;…&#125;, null, NaN, NaN, &quot;NaN&quot;, 0, &quot;a&quot;, &#123;…&#125;, undefined\]</code></pre><h2 id="利用-Map-数据结构去重"><a href="#利用-Map-数据结构去重" class="headerlink" title="利用 Map 数据结构去重"></a>利用 Map 数据结构去重</h2><pre><code>function arrayNonRepeatfy(arr) &#123;  let map = new Map();  let array = new Array();  // 数组用于返回结果  for (let i = 0; i &lt; arr.length; i++) &#123;    if(map .has(arr\[i\])) &#123;  // 如果有该key值      map .set(arr\[i\], true);    &#125; else &#123;      map .set(arr\[i\], false);   // 如果没有该key值      array .push(arr\[i\]);    &#125;  &#125;  return array ;&#125; var arr = \[1,1,&#39;true&#39;,&#39;true&#39;,true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,&#39;NaN&#39;, 0, 0, &#39;a&#39;, &#39;a&#39;,&#123;&#125;,&#123;&#125;\];    console.log(unique(arr))//\[1, &quot;a&quot;, &quot;true&quot;, true, 15, false, 1, &#123;…&#125;, null, NaN, NaN, &quot;NaN&quot;, 0, &quot;a&quot;, &#123;…&#125;, undefined\]</code></pre><p>创建一个空 Map 数据结构，遍历需要去重的数组，把数组的每一个元素作为 key 存到 Map 中。由于 Map 中不会出现相同的 key 值，所以最终得到的就是去重后的结果。</p><h2 id="-1"><a href="#-1" class="headerlink" title=""></a></h2><p>PS：有些文章提到了 foreach+indexOf 数组去重的方法，个人觉得都是大同小异，所以没有写上去。</p>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 📶线结构：字符串-数组-栈-队列 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Vue下载指定url图片</title>
      <link href="/blog/na8588/"/>
      <url>/blog/na8588/</url>
      
        <content type="html"><![CDATA[<h2 id="一、转换-base64-编码"><a href="#一、转换-base64-编码" class="headerlink" title="一、转换 base64 编码"></a>一、转换 base64 编码</h2><pre><code class="javascript">// 下载图标点击事件downloadIcon() &#123;  let downloadUrl =  &#39;https://xxx.com&#39; +  this.gameInfoData.gameIcon.replace(&#39;_thumb&#39;, &#39;&#39;)  this.downloadImg(downloadUrl, this.gameInfoData.gameName + &#39;-icon&#39;)&#125;,// 功能代码downloadImg(imgsrc, name) &#123;  var image = new Image()  // 解决跨域 Canvas 污染问题  image.setAttribute(&#39;crossOrigin&#39;, &#39;anonymous&#39;)  image.onload = function() &#123;    var canvas = document.createElement(&#39;canvas&#39;)    canvas.width = image.width    canvas.height = image.height    var context = canvas.getContext(&#39;2d&#39;)    context.drawImage(image, 0, 0, image.width, image.height)    var url = canvas.toDataURL() //得到图片的base64编码数据    var a = document.createElement(&#39;a&#39;) // 生成一个a元素    var event = new MouseEvent(&#39;click&#39;) // 创建一个单击事件    a.download = name || &#39;photo&#39; // 设置图片名称    a.href = url // 将生成的URL设置为a.href属性    a.dispatchEvent(event) // 触发a的单击事件  &#125;  image.src = imgsrc&#125;</code></pre><p>参考：<a href="https://blog.csdn.net/z9061/article/details/84882353">https://blog.csdn.net/z9061/article/details/84882353</a></p><h2 id="二、下载文件"><a href="#二、下载文件" class="headerlink" title="二、下载文件"></a>二、下载文件</h2><p>参考：<a href="https://segmentfault.com/a/1190000020540788">https://segmentfault.com/a/1190000020540788</a></p><p><img src="https://cdn.nlark.com/yuque/0/2021/gif/1484158/1636381118828-028d764d-cc8c-4910-a280-9c1037ae0ae4.gif#id=Oaany&originHeight=151&originWidth=218&originalType=binary%E2%88%B6=1&status=done&style=none"> 插个眼，日后再去摸索摸索这方面的功能</p>]]></content>
      
      
      <categories>
          
          <category> 👨‍💻Web开发 </category>
          
          <category> Vue </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Vue中几种组件通信方式</title>
      <link href="/blog/qwv5oz/"/>
      <url>/blog/qwv5oz/</url>
      
        <content type="html"><![CDATA[<div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">本文转载自：[https://juejin.cn/post/6844903887162310669](https://juejin.cn/post/6844903887162310669)（部分内容自行添加/修改）</div><blockquote><p>之前写了一篇关于 vue 面试总结的文章, 有不少网友提出组件之间通信方式还有很多, 这篇文章便是专门总结组件之间通信的</p></blockquote><p>作者简介：koala，专注完整的 Node.js 技术栈分享，从 JavaScript 到 Node.js, 再到后端数据库，祝您成为优秀的高级 Node.js 工程师。【程序员成长指北】作者，Github 博客开源项目 <a href="https://link.juejin.cn/?target=https://github.com/koala-coding/goodBlog">https://github.com/koala-coding/goodBlog</a></p><p>vue 是数据驱动视图更新的框架, 所以对于 vue 来说组件间的数据通信非常重要，那么组件之间如何进行数据通信的呢？ 首先我们需要知道在 vue 中组件之间存在什么样的关系, 才更容易理解他们的通信方式, 就好像过年回家，坐着一屋子的陌生人，相互之间怎么称呼，这时就需要先知道自己和他们之间是什么样的关系。 vue 组件中关系说明:</p><p><img src="https://cdn.nlark.com/yuque/0/2021/webp/1484158/1635399234264-ec4a46fa-6e27-4efb-922f-871b5ef8719c.webp#clientId=u9a7d0d71-d690-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=ubbf5437a&margin=%5Bobject%20Object%5D&originHeight=402&originWidth=462&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&taskId=u15ab5dd7-77df-4cb2-8501-06300dcc47d&title="></p><p>如上图所示, A 与 B、A 与 C、B 与 D、C 与 E 组件之间是父子关系； B 与 C 之间是兄弟关系；A 与 D、A 与 E 之间是隔代关系； D 与 E 是堂兄关系（非直系亲属） 针对以上关系我们归类为：</p><ul><li>父子组件之间通信</li><li>非父子组件之间通信 (兄弟组件、隔代关系组件等)</li></ul><p>本文会介绍组件间通信的 8 种方式如下图目录所示: 并介绍在不同的场景下如何选择有效方式实现的组件间通信方式，希望可以帮助小伙伴们更好理解组件间的通信。</p><p><img src="https://cdn.nlark.com/yuque/0/2021/webp/1484158/1635399242725-f019c2ac-ea0b-48d2-81c1-fa4f80211155.webp#clientId=u9a7d0d71-d690-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u2d5076b9&margin=%5Bobject%20Object%5D&originHeight=566&originWidth=499&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&taskId=u2d84fde4-fda3-41f3-8456-117f7d45e3e&title="></p><h3 id="一、props-emit"><a href="#一、props-emit" class="headerlink" title="一、props / $emit"></a>一、<code>props</code> / <code>$emit</code></h3><p>父组件通过<code>props</code>的方式向子组件传递数据，而通过<code>$emit</code> 子组件可以向父组件通信。</p><h4 id="1-父组件向子组件传值"><a href="#1-父组件向子组件传值" class="headerlink" title="1. 父组件向子组件传值"></a>1. 父组件向子组件传值</h4><p>下面通过一个例子说明父组件如何向子组件传递数据：在子组件<code>article.vue</code>中如何获取父组件<code>section.vue</code>中的数据<code>articles:[&#39;红楼梦&#39;, &#39;西游记&#39;,&#39;三国演义&#39;]</code></p><pre><code class="vue">// section父组件&lt;template&gt;  &lt;div class=&quot;section&quot;&gt;    &lt;com-article :articles=&quot;articleList&quot;&gt;&lt;/com-article&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import comArticle from &quot;./test/article.vue&quot;;export default &#123;  name: &quot;HelloWorld&quot;,  components: &#123; comArticle &#125;,  data() &#123;    return &#123;      articleList: [&quot;红楼梦&quot;, &quot;西游记&quot;, &quot;三国演义&quot;],    &#125;;  &#125;,&#125;;&lt;/script&gt;</code></pre><pre><code class="vue">// 子组件 article.vue&lt;template&gt;  &lt;div&gt;    &lt;span v-for=&quot;(item, index) in articles&quot; :key=&quot;index&quot;&gt;&#123;&#123; item &#125;&#125;&lt;/span&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  props: [&quot;articles&quot;],&#125;;&lt;/script&gt;</code></pre><blockquote><p>总结: prop 只可以从上一级组件传递到下一级组件（父子组件），即所谓的单向数据流。而且 prop 只读，不可被修改，所有修改都会失效并警告。</p></blockquote><h4 id="2-子组件向父组件传值"><a href="#2-子组件向父组件传值" class="headerlink" title="2. 子组件向父组件传值"></a>2. 子组件向父组件传值</h4><p>对于<code>$emit</code> 我自己的理解是这样的: <code>$emit</code>绑定一个自定义事件, 当这个语句被执行时, 就会将参数 arg 传递给父组件, 父组件通过 v-on 监听并接收参数。 通过一个例子，说明子组件如何向父组件传递数据。 在上个例子的基础上, 点击页面渲染出来的<code>ariticle</code>的<code>item</code>, 父组件中显示在数组中的下标</p><pre><code class="vue">// 父组件&lt;template&gt;  &lt;div class=&quot;section&quot;&gt;    &lt;com-article      :articles=&quot;articleList&quot;      @onEmitIndex=&quot;onEmitIndex&quot;    &gt;&lt;/com-article&gt;    &lt;p&gt;&#123;&#123; currentIndex &#125;&#125;&lt;/p&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import comArticle from &quot;./test/article.vue&quot;;export default &#123;  name: &quot;HelloWorld&quot;,  components: &#123; comArticle &#125;,  data() &#123;    return &#123;      currentIndex: -1,      articleList: [&quot;红楼梦&quot;, &quot;西游记&quot;, &quot;三国演义&quot;],    &#125;;  &#125;,  methods: &#123;    onEmitIndex(idx) &#123;      this.currentIndex = idx;    &#125;,  &#125;,&#125;;&lt;/script&gt;</code></pre><pre><code class="vue">// 子组件&lt;template&gt;  &lt;div&gt;    &lt;div      v-for=&quot;(item, index) in articles&quot;      :key=&quot;index&quot;      @click=&quot;emitIndex(index)&quot;    &gt;      &#123;&#123; item &#125;&#125;    &lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  props: [&quot;articles&quot;],  methods: &#123;    emitIndex(index) &#123;      this.$emit(&quot;onEmitIndex&quot;, index);    &#125;,  &#125;,&#125;;&lt;/script&gt;</code></pre><h3 id="二、-children-parent"><a href="#二、-children-parent" class="headerlink" title="二、 $children / $parent"></a>二、 <code>$children</code> / <code>$parent</code></h3><p><img src="https://cdn.nlark.com/yuque/0/2021/webp/1484158/1635399257895-523f1b19-b58a-42bf-9649-abebf7694ef2.webp#clientId=u9a7d0d71-d690-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u4267112c&margin=%5Bobject%20Object%5D&originHeight=330&originWidth=642&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=stroke&taskId=ufebdbf3a-e305-4d98-a0d5-ff4444f1df1&title="></p><p>上面这张图片是<code>vue</code>官方的解释，通过<code>$parent</code>和<code>$children</code>就可以访问组件的实例，拿到实例代表什么？代表可以访问此组件的所有方法和<code>data</code>。接下来就是怎么实现拿到指定组件的实例。</p><h4 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h4><pre><code class="vue">// 父组件中&lt;template&gt;  &lt;div class=&quot;hello_world&quot;&gt;    &lt;div&gt;&#123;&#123; msg &#125;&#125;&lt;/div&gt;    &lt;com-a&gt;&lt;/com-a&gt;    &lt;button @click=&quot;changeA&quot;&gt;点击改变子组件值&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import ComA from &quot;./test/comA.vue&quot;;export default &#123;  name: &quot;HelloWorld&quot;,  components: &#123; ComA &#125;,  data() &#123;    return &#123;      msg: &quot;Welcome&quot;,    &#125;;  &#125;,  methods: &#123;    changeA() &#123;      // 获取到子组件A      this.$children[0].messageA = &quot;this is new value&quot;;    &#125;,  &#125;,&#125;;&lt;/script&gt;</code></pre><pre><code class="vue">// 子组件中&lt;template&gt;  &lt;div class=&quot;com_a&quot;&gt;    &lt;span&gt;&#123;&#123; messageA &#125;&#125;&lt;/span&gt;    &lt;p&gt;获取父组件的值为: &#123;&#123; parentVal &#125;&#125;&lt;/p&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  data() &#123;    return &#123;      messageA: &quot;this is old&quot;,    &#125;;  &#125;,  computed: &#123;    parentVal() &#123;      return this.$parent.msg;    &#125;,  &#125;,&#125;;&lt;/script&gt;</code></pre><blockquote><p>要注意边界情况，如在<code>#app</code>上拿<code>$parent</code>得到的是<code>new Vue()</code>的实例，在这实例上再拿<code>$parent</code>得到的是<code>undefined</code>，而在最底层的子组件拿<code>$children</code>是个空数组。也要注意得到<code>$parent</code>和<code>$children</code>的值不一样，<code>$children</code> 的值是数组，而<code>$parent</code>是个对象</p></blockquote><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>上面两种方式用于父子组件之间的通信， 而使用 props 进行父子组件通信更加普遍; 二者皆不能用于非父子组件之间的通信。</p><h3 id="三、provide-inject"><a href="#三、provide-inject" class="headerlink" title="三、provide/ inject"></a>三、<code>provide</code>/ <code>inject</code></h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念:"></a>概念:</h4><p><code>provide</code>/ <code>inject</code> 是<code>vue2.2.0</code>新增的 api, 简单来说就是父组件中通过<code>provide</code>来提供变量, 然后再子组件中通过<code>inject</code>来注入变量。</p><blockquote><p>注意: 这里不论子组件嵌套有多深, 只要调用了<code>inject</code> 那么就可以注入<code>provide</code>中的数据，而不局限于只能从当前父组件的 props 属性中回去数据</p></blockquote><h4 id="举例验证"><a href="#举例验证" class="headerlink" title="举例验证"></a>举例验证</h4><p>接下来就用一个例子来验证上面的描述: 假设有三个组件: A.vue、B.vue、C.vue 其中 C 是 B 的子组件，B 是 A 的子组件</p><pre><code class="vue">// A.vue&lt;template&gt;  &lt;div&gt;    &lt;comB&gt;&lt;/comB&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import comB from &quot;../components/test/comB.vue&quot;;export default &#123;  name: &quot;A&quot;,  provide: &#123;    for: &quot;demo&quot;,  &#125;,  components: &#123;    comB,  &#125;,&#125;;&lt;/script&gt;</code></pre><pre><code class="vue">// B.vue&lt;template&gt;  &lt;div&gt;    &#123;&#123; demo &#125;&#125;    &lt;comC&gt;&lt;/comC&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import comC from &quot;../components/test/comC.vue&quot;;export default &#123;  name: &quot;B&quot;,  inject: [&quot;for&quot;],  data() &#123;    return &#123;      demo: this.for,    &#125;;  &#125;,  components: &#123;    comC,  &#125;,&#125;;&lt;/script&gt;</code></pre><pre><code class="vue">// C.vue&lt;template&gt;  &lt;div&gt;    &#123;&#123; demo &#125;&#125;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  name: &quot;C&quot;,  inject: [&quot;for&quot;],  data() &#123;    return &#123;      demo: this.for,    &#125;;  &#125;,&#125;;&lt;/script&gt;</code></pre><h3 id="四、ref-refs"><a href="#四、ref-refs" class="headerlink" title="四、ref / refs"></a>四、<code>ref</code> / <code>refs</code></h3><h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><p><code>ref</code>：如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素；如果用在子组件上，引用就指向组件实例，可以通过实例直接调用组件的方法或访问数据， 我们看一个<code>ref</code> 来访问组件的例子:</p><pre><code class="vue">// 父组件 app.vue&lt;template&gt;  &lt;component-a ref=&quot;comA&quot;&gt;&lt;/component-a&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  mounted() &#123;    const comA = this.$refs.comA;    console.log(comA.name); // Vue.js    comA.sayHello(); // hello  &#125;,&#125;;&lt;/script&gt;</code></pre><pre><code class="vue">// 子组件 A.vue export default &#123; data () &#123; return &#123; name: &#39;Vue.js&#39; &#125; &#125;, methods:&#123; sayHello () &#123; console.log(&#39;hello&#39;) &#125; &#125; &#125;</code></pre><h4 id="和-v-for-共使用"><a href="#和-v-for-共使用" class="headerlink" title="和 v-for 共使用"></a>和 v-for 共使用</h4><p>遇到过这个场景，在主组件里面需要多次渲染子组件</p><pre><code class="vue">&lt;!-- 直播绑定 --&gt;&lt;div slot=&quot;liveBind&quot;&gt;        &lt;AddLiveBindItem          v-for=&quot;(data, index) in datas&quot;          :key=&quot;data.id&quot;          :dataConfig=&quot;data.dataConfig&quot;          :isFirst=&quot;index === 0 ? true : false&quot;          :liveBindId=&quot;            index === 0              ? 1              : index === 1              ? 2              : index === 2              ? 3              : index === 3              ? 4              : index === 4              ? 5              : 6          &quot;          @toDeleteLiveBind=&quot;toDeleteLiveBind(index)&quot;          ref=&quot;addLiveBindRef&quot;        /&gt;      &lt;/div&gt;</code></pre><p>具体使用：下面第四行代码</p><pre><code class="javascript">this.datas.forEach((_it, index) =&gt; &#123;  // 当前表单的配置项遍历上传  liveRelationList.push(this.$refs.addLiveBindRef[index].liveBindApiParams);  // 上传sort参数  liveRelationList[liveRelationList.length - 1].sort = _it.id;&#125;);</code></pre><h4 id="其他理解"><a href="#其他理解" class="headerlink" title="其他理解"></a>其他理解</h4><ul><li>v-for 用于元素或组件时,引用信息将是<strong>包含 DOM 节点或组件实例的数组，</strong>按照这个理解，可以直接利用$refs 来获取 dom 元素</li></ul><pre><code class="javascript">this.$refs.addAlert.style.display = &quot;block&quot;;</code></pre><p><strong>$refs只会在组件渲染完成之后生效，并且它们不是响应式的。这仅作为一个用于直接操作子组件的“逃生舱”——你应该避免在模板或计算属性中访问$refs。这是官方说法，提倡 props 来操作，缺点就是非响应式的</strong></p><p><strong>ref 本身是作为渲染结果被创建的，在初始渲染的时候你不能访问它们 - 它们还不存在！$refs 也不是响应式的，因此你不应该试图用它在模板中做数据绑定。</strong></p><h3 id="五、eventBus"><a href="#五、eventBus" class="headerlink" title="五、eventBus"></a>五、eventBus</h3><p><code>eventBus</code> 又称为事件总线，在 vue 中可以使用它来作为沟通桥梁的概念, 就像是所有组件共用相同的事件中心，可以向该中心<strong>注册发送事件</strong>或<strong>接收事件</strong>， 所以<strong>组件都可以通知其他组件</strong>。</p><blockquote><p>eventBus 也有不方便之处, 当项目较大, 就容易造成难以维护的灾难</p></blockquote><p>在 Vue 的项目中怎么使用<code>eventBus</code>来实现组件之间的数据通信呢? 具体通过下面几个步骤</p><h4 id="1-初始化"><a href="#1-初始化" class="headerlink" title="1. 初始化"></a>1. 初始化</h4><p>首先需要创建一个事件总线并将其导出, 以便其他模块可以使用或者监听它.</p><pre><code class="javascript">// event-bus.jsimport Vue from &quot;vue&quot;;export const EventBus = new Vue();</code></pre><p>假设你有两个组件: <code>additionNum</code> 和 <code>showNum</code>, 这两个组件可以是兄弟组件也可以是父子组件；这里我们以兄弟组件为例:</p><pre><code class="vue">&lt;template&gt;  &lt;div&gt;    &lt;show-num-com&gt;&lt;/show-num-com&gt;    &lt;addition-num-com&gt;&lt;/addition-num-com&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import showNumCom from &quot;./showNum.vue&quot;;import additionNumCom from &quot;./additionNum.vue&quot;;export default &#123;  components: &#123; showNumCom, additionNumCom &#125;,&#125;;&lt;/script&gt;</code></pre><h4 id="2-发送事件"><a href="#2-发送事件" class="headerlink" title="2. 发送事件"></a>2. 发送事件</h4><pre><code class="vue">// addtionNum.vue 中发送事件&lt;template&gt;  &lt;div&gt;    &lt;button @click=&quot;additionHandle&quot;&gt;+加法器&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123; EventBus &#125; from &quot;./event-bus.js&quot;;console.log(EventBus);export default &#123;  data() &#123;    return &#123;      num: 1,    &#125;;  &#125;,  methods: &#123;    additionHandle() &#123;      EventBus.$emit(&quot;addition&quot;, &#123;        num: this.num++,      &#125;);    &#125;,  &#125;,&#125;;&lt;/script&gt;</code></pre><h4 id="3-接收事件"><a href="#3-接收事件" class="headerlink" title="3. 接收事件"></a>3. 接收事件</h4><pre><code class="vue">// showNum.vue 中接收事件&lt;template&gt;  &lt;div&gt;计算和: &#123;&#123; count &#125;&#125;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123; EventBus &#125; from &quot;./event-bus.js&quot;;export default &#123;  data() &#123;    return &#123;      count: 0,    &#125;;  &#125;,  mounted() &#123;    EventBus.$on(&quot;addition&quot;, (param) =&gt; &#123;      this.count = this.count + param.num;    &#125;);  &#125;,&#125;;&lt;/script&gt;</code></pre><p>这样就实现了在组件<code>addtionNum.vue</code>中点击相加按钮, 在<code>showNum.vue</code>中利用传递来的 <code>num</code> 展示求和的结果.</p><h4 id="4-移除事件监听者"><a href="#4-移除事件监听者" class="headerlink" title="4. 移除事件监听者"></a>4. 移除事件监听者</h4><p>如果想移除事件的监听, 可以像下面这样操作:</p><pre><code class="vue">import &#123; eventBus &#125; from &#39;event-bus.js&#39; EventBus.$off(&#39;addition&#39;, &#123;&#125;)</code></pre><h3 id="六、Vuex"><a href="#六、Vuex" class="headerlink" title="六、Vuex"></a>六、Vuex</h3><h4 id="1-Vuex-介绍"><a href="#1-Vuex-介绍" class="headerlink" title="1. Vuex 介绍"></a>1. Vuex 介绍</h4><p>Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化. Vuex 解决了<code>多个视图依赖于同一状态</code>和<code>来自不同视图的行为需要变更同一状态</code>的问题，将开发者的精力聚焦于数据的更新而不是数据在组件之间的传递上</p><h4 id="2-Vuex-各个模块"><a href="#2-Vuex-各个模块" class="headerlink" title="2. Vuex 各个模块"></a>2. Vuex 各个模块</h4><ol><li><code>state</code>：用于数据的存储，是 store 中的唯一数据源</li><li><code>getters</code>：如 vue 中的计算属性一样，基于 state 数据的二次包装，常用于数据的筛选和多个数据的相关性计算</li><li><code>mutations</code>：类似函数，改变 state 数据的唯一途径，且不能用于处理异步事件</li><li><code>actions</code>：类似于<code>mutation</code>，用于提交<code>mutation</code>来改变状态，而不直接变更状态，可以包含任意异步操作</li><li><code>modules</code>：类似于命名空间，用于项目中将各个模块的状态分开定义和操作，便于维护</li></ol><h4 id="3-Vuex-实例应用"><a href="#3-Vuex-实例应用" class="headerlink" title="3. Vuex 实例应用"></a>3. Vuex 实例应用</h4><pre><code class="vue">// 父组件&lt;template&gt;  &lt;div id=&quot;app&quot;&gt;    &lt;ChildA /&gt;    &lt;ChildB /&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import ChildA from &quot;./components/ChildA&quot;; // 导入A组件import ChildB from &quot;./components/ChildB&quot;; // 导入B组件export default &#123;  name: &quot;App&quot;,  components: &#123; ChildA, ChildB &#125;, // 注册A、B组件&#125;;&lt;/script&gt;</code></pre><pre><code class="vue">// 子组件childA&lt;template&gt;  &lt;div id=&quot;childA&quot;&gt;    &lt;h1&gt;我是A组件&lt;/h1&gt;    &lt;button @click=&quot;transform&quot;&gt;点我让B组件接收到数据&lt;/button&gt;    &lt;p&gt;因为你点了B，所以我的信息发生了变化：&#123;&#123; BMessage &#125;&#125;&lt;/p&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  data() &#123;    return &#123;      AMessage: &quot;Hello，B组件，我是A组件&quot;,    &#125;;  &#125;,  computed: &#123;    BMessage() &#123;      // 这里存储从store里获取的B组件的数据      return this.$store.state.BMsg;    &#125;,  &#125;,  methods: &#123;    transform() &#123;      // 触发receiveAMsg，将A组件的数据存放到store里去      this.$store.commit(&quot;receiveAMsg&quot;, &#123;        AMsg: this.AMessage,      &#125;);    &#125;,  &#125;,&#125;;&lt;/script&gt;</code></pre><pre><code class="vue">// 子组件 childB&lt;template&gt;  &lt;div id=&quot;childB&quot;&gt;    &lt;h1&gt;我是B组件&lt;/h1&gt;    &lt;button @click=&quot;transform&quot;&gt;点我让A组件接收到数据&lt;/button&gt;    &lt;p&gt;因为你点了A，所以我的信息发生了变化：&#123;&#123; AMessage &#125;&#125;&lt;/p&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  data() &#123;    return &#123;      BMessage: &quot;Hello，A组件，我是B组件&quot;,    &#125;;  &#125;,  computed: &#123;    AMessage() &#123;      // 这里存储从store里获取的A组件的数据      return this.$store.state.AMsg;    &#125;,  &#125;,  methods: &#123;    transform() &#123;      // 触发receiveBMsg，将B组件的数据存放到store里去      this.$store.commit(&quot;receiveBMsg&quot;, &#123;        BMsg: this.BMessage,      &#125;);    &#125;,  &#125;,&#125;;&lt;/script&gt;</code></pre><p>vuex 的<code>store,js</code></p><pre><code class="javascript">import Vue from &quot;vue&quot;;import Vuex from &quot;vuex&quot;;Vue.use(Vuex);const state = &#123;  // 初始化A和B组件的数据，等待获取  AMsg: &quot;&quot;,  BMsg: &quot;&quot;,&#125;;const mutations = &#123;  receiveAMsg(state, payload) &#123;    // 将A组件的数据存放于state    state.AMsg = payload.AMsg;  &#125;,  receiveBMsg(state, payload) &#123;    // 将B组件的数据存放于state    state.BMsg = payload.BMsg;  &#125;,&#125;;export default new Vuex.Store(&#123;  state,  mutations,&#125;);</code></pre><h3 id="七、localStorage-sessionStorage"><a href="#七、localStorage-sessionStorage" class="headerlink" title="七、localStorage / sessionStorage"></a>七、<code>localStorage</code> / <code>sessionStorage</code></h3><p>这种通信比较简单, 缺点是数据和状态比较混乱, 不太容易维护。 通过<code>window.localStorage.getItem(key)</code>获取数据 通过<code>window.localStorage.setItem(key,value)</code>存储数据</p><blockquote><p>注意用<code>JSON.parse()</code> / <code>JSON.stringify()</code> 做数据格式转换（localStorage 和 sessionStorage 只能存字符串，会自动调用对象的 toString 方法）<br><code>localStorage</code> / <code>sessionStorage</code>可以结合<code>vuex</code>, 实现数据的持久保存, 同时使用 <code>vuex</code>解决数据和状态混乱问题.</p></blockquote><pre><code class="javascript">// 存取sessionStorage.setItem(  &quot;sortColumn&quot;,  JSON.stringify(&#123; prop: column.prop, order: column.order &#125;));// 使用this.sortColumnSession = JSON.parse(sessionStorage.getItem(&quot;sortColumn&quot;));</code></pre><h3 id="八-attrs与-listeners"><a href="#八-attrs与-listeners" class="headerlink" title="八 $attrs与 $listeners"></a>八 <code>$attrs</code>与 <code>$listeners</code></h3><p>现在我们来讨论一种情况， 我们一开始给出的组件关系图中 A 组件与 D 组件是隔代关系， 那它们之前进行通信有哪些方式呢？</p><ol><li>使用<code>props</code>绑定来进行一级一级的信息传递, 如果 D 组件中状态改变需要传递数据给 A, 使用事件系统一级级往上传递</li><li>使用<code>eventBus</code>, 这种情况下还是比较适合使用, 但是碰到多人合作开发时, 代码维护性较低, 可读性也低</li><li>使用 Vuex 来进行数据管理, 但是如果仅仅是传递数据, 而不做中间处理, 使用 Vuex 处理感觉有点大材小用了.</li></ol><p>在<code>vue2.4</code>中，为了解决该需求，引入了<code>$attrs</code> 和<code>$listeners</code> ， 新增了<code>inheritAttrs</code> 选项。 在版本 2.4 以前，默认情况下, 父作用域中不作为 prop 被识别 (且获取) 的特性绑定 (class 和 style 除外)，将会 “回退” 且作为普通的 HTML 特性应用在子组件的根元素上。接下来看一个跨级通信的例子:</p><pre><code class="vue">// app.vue // index.vue&lt;template&gt;  &lt;div&gt;    &lt;child-com1      :name=&quot;name&quot;      :age=&quot;age&quot;      :gender=&quot;gender&quot;      :height=&quot;height&quot;      title=&quot;程序员成长指北&quot;    &gt;&lt;/child-com1&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;const childCom1 = () =&gt; import(&quot;./childCom1.vue&quot;);export default &#123;  components: &#123; childCom1 &#125;,  data() &#123;    return &#123;      name: &quot;zhang&quot;,      age: &quot;18&quot;,      gender: &quot;女&quot;,      height: &quot;158&quot;,    &#125;;  &#125;,&#125;;&lt;/script&gt;</code></pre><pre><code class="vue">// childCom1.vue&lt;template class=&quot;border&quot;&gt;  &lt;div&gt;    &lt;p&gt;name: &#123;&#123; name &#125;&#125;&lt;/p&gt;    &lt;p&gt;childCom1的$attrs: &#123;&#123; $attrs &#125;&#125;&lt;/p&gt;    &lt;child-com2 v-bind=&quot;$attrs&quot;&gt;&lt;/child-com2&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;const childCom2 = () =&gt; import(&quot;./childCom2.vue&quot;);export default &#123;  components: &#123;    childCom2,  &#125;,  inheritAttrs: false, // 可以关闭自动挂载到组件根元素上的没有在props声明的属性  props: &#123;    name: String, // name作为props属性绑定  &#125;,  created() &#123;    console.log(this.$attrs);    // &#123; &quot;age&quot;: &quot;18&quot;, &quot;gender&quot;: &quot;女&quot;, &quot;height&quot;: &quot;158&quot;, &quot;title&quot;: &quot;程序员成长指北&quot; &#125;  &#125;,&#125;;&lt;/script&gt;</code></pre><pre><code class="vue">// childCom2.vue&lt;template&gt;  &lt;div class=&quot;border&quot;&gt;    &lt;p&gt;age: &#123;&#123; age &#125;&#125;&lt;/p&gt;    &lt;p&gt;childCom2: &#123;&#123; $attrs &#125;&#125;&lt;/p&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  inheritAttrs: false,  props: &#123;    age: String,  &#125;,  created() &#123;    console.log(this.$attrs);    // &#123; &quot;gender&quot;: &quot;女&quot;, &quot;height&quot;: &quot;158&quot;, &quot;title&quot;: &quot;程序员成长指北&quot; &#125;  &#125;,&#125;;&lt;/script&gt;</code></pre><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>常见使用场景可以分为三类:</p><ul><li>父子组件通信: <code>props</code>; <code>$parent</code> / <code>$children</code>; <code>provide</code> / <code>inject</code> ; <code>ref</code> ; <code>$attrs</code> / <code>$listeners</code></li><li>兄弟组件通信: <code>eventBus</code> ; vuex</li><li>跨级通信: <code>eventBus</code>；Vuex；<code>provide</code> / <code>inject</code> 、<code>$attrs</code> / <code>$listeners</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> 👨‍💻Web开发 </category>
          
          <category> Vue </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Vue3学习笔记</title>
      <link href="/blog/vue_watch_summary/"/>
      <url>/blog/vue_watch_summary/</url>
      
        <content type="html"><![CDATA[<p>前言：以官方文档为蓝本的 Vue 学习过程中，需要的一些细节以及实际开发中遇到的总结点。</p><p>Vue 的学习过程中，主要分几个大块：</p><ul><li>基础知识：框架自行的一些语法（官网里面的<strong>基础</strong>）</li><li>组件相关：尤其是组件之间的各类通信方式，在写/抽离组件里面经常用到，单独一篇文章总结。</li></ul><p>官方文档：</p><ul><li>Vue 2.x：<a href="https://cn.vuejs.org/v2/guide/">https://cn.vuejs.org/v2/guide/</a></li><li>Vue 3：<a href="https://v3.cn.vuejs.org/guide/introduction.html">https://v3.cn.vuejs.org/guide/introduction.html</a></li></ul><h2 id="计算属性-方法-侦听器"><a href="#计算属性-方法-侦听器" class="headerlink" title="计算属性+方法+侦听器"></a>计算属性+方法+侦听器</h2><h3 id="计算属性（computed）和方法（methods）的区别"><a href="#计算属性（computed）和方法（methods）的区别" class="headerlink" title="计算属性（computed）和方法（methods）的区别"></a>计算属性（computed）和方法（methods）的区别</h3><ul><li>计算属性是基于他们的依赖来进行缓存的</li></ul><p>“他们的依赖”指的是 data 数据域中的 data 数据，如果其变动，计算属性值才会变</p><ul><li>方法不存在缓存</li></ul><h3 id="计算属性（computed）和侦听器（watch）的使用"><a href="#计算属性（computed）和侦听器（watch）的使用" class="headerlink" title="计算属性（computed）和侦听器（watch）的使用"></a>计算属性（computed）和侦听器（watch）的使用</h3><ul><li>侦听器更用于异步或是开销较大的操作</li></ul><p>文档：<a href="https://cn.vuejs.org/v2/api/#watch">https://cn.vuejs.org/v2/api/#watch</a></p><h3 id="侦听器（watch）的一些注意事项"><a href="#侦听器（watch）的一些注意事项" class="headerlink" title="侦听器（watch）的一些注意事项"></a>侦听器（watch）的一些注意事项</h3><p>实际开发过程中：</p><ul><li><strong>非的确必要，尽量不要使用 watch 监听，实际过程中，会造成许多问题，比如渲染顺序等，会给后续添加功能带来难以维护的问题</strong></li><li>当监听的数据不是一个简单的基本类型，比如一个对象，一个数组，此时应该使用深度监听：deep:true；当想让监听器一启动就触发一次 watch，应该使用： immediate: true。<blockquote><p>直接<code>watch</code>监听对象内的是检测不到变化的，因为对象的指向并没有发生改变。Vue 中的 watch 监听对象内属性的变动方案</p></blockquote></li></ul><h4 id="使用-deep-属性"><a href="#使用-deep-属性" class="headerlink" title="使用 deep 属性"></a>使用 deep 属性</h4><pre><code class="javascript">new Vue(&#123;  data: &#123;    count: 10，    blog:&#123;        title:&#39;my-blog&#39;,        categories:[]    &#125;  &#125;,  watch: &#123;    blog:&#123;        handler(newVal,oldVal)&#123;            console.log(`new: $&#123;newVal&#125;, old: $&#123;oldVal&#125;`);        &#125;,    deep:true    &#125;  &#125;&#125;)</code></pre><p>里面的<code>deep</code>设为了<code>true</code>，这样的话，如果修改了这个<code>blog</code>中的任何一个属性，都会执行<code>handler</code>这个方法。不过这样会造成更多的性能开销，尤其是对象里面属性过多，结构嵌套过深的时候。而且有时候我们就只想关心这个对象中的某个特定属性，这个时候可以这样</p><h4 id="用字符串来表示对象的属性调用"><a href="#用字符串来表示对象的属性调用" class="headerlink" title="用字符串来表示对象的属性调用"></a>用字符串来表示对象的属性调用</h4><pre><code class="javascript">new Vue(&#123;  data: &#123;    count: 10，    blog:&#123;        title:&#39;my-blog&#39;,        categories:[]    &#125;  &#125;,  watch: &#123;    &#39;blog.categories&#39;(newVal, oldVal) &#123;        console.log(`new:$&#123;newVal&#125;, old:$&#123;oldVal&#125;`);    &#125;,  &#125;&#125;)</code></pre><h4 id="使用计算属性-computed"><a href="#使用计算属性-computed" class="headerlink" title="使用计算属性(computed)"></a>使用计算属性(computed)</h4><pre><code class="javascript">new Vue(&#123;  data: &#123;    count: 10，    blog:&#123;        title:&#39;my-blog&#39;,        categories:[]    &#125;  &#125;,  computed: &#123;    categories() &#123;      return this.blog.categories;    &#125;  &#125;,  watch: &#123;    categories(newVal, oldVal) &#123;      console.log(`new:$&#123;newVal&#125;, old:$&#123;oldVal&#125;`);    &#125;,  &#125;,&#125;)</code></pre><p>参考：<a href="https://segmentfault.com/a/1190000018080301">https://segmentfault.com/a/1190000018080301</a></p><h2 id="生命周期实践理解"><a href="#生命周期实践理解" class="headerlink" title="生命周期实践理解"></a>生命周期实践理解</h2><p>vue2 当中：</p><ol><li>beforeCreate：在实例初始化之后，数据观测和事件配置之前被调用</li><li>created：在实例创建完成后被立即调用</li><li>beforeMount：在挂载开始之前被调用</li><li>mounted：el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子</li><li>beforeUpdate：数据更新时调用，发生在虚拟 DOM 打补丁之前</li><li>updated：由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子</li><li>beforeDestroy：实例销毁之前调用</li><li>destroyed：实例销毁后调用</li></ol><pre><code class="vue">&lt;script&gt;setup() &#123;  console.log(&#39;----setup第一个执行----&#39;)  // vue3.x生命周期写在setup中  onBeforeMount(() =&gt; &#123;    console.log(&#39;------vue3中onBeforeMount-----&#39;)  &#125;)  onMounted(() =&gt; &#123;    console.log(&#39;------vue3中onMounted-----&#39;)  &#125;)  onRenderTriggered((event) =&gt; &#123;    console.log(&#39;------vue3中onRenderTriggered-----&#39;, event)  &#125;)&#125;,// vue2当中的beforeCreate() &#123;  console.log(&#39;----vue2中beforeCreate第二个执行----&#39;)&#125;,// vue2当中的created() &#123;  console.log(&#39;----vue2中created第三个执行----&#39;)&#125;,&lt;/script&gt;</code></pre><p>执行结果如下：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1644646841871-0aaeece1-c5dd-493e-bbfc-41f52925931a.png#clientId=uc6b85a54-d54e-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=184&id=ue1197c21&margin=%5Bobject%20Object%5D&name=image.png&originHeight=184&originWidth=792&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=21679&status=done&style=stroke&taskId=u7cdef1da-82cb-4c2d-a530-94348eaa6e2&title=&width=792" alt="image.png"></p><h2 id="Vue3-x-相交-Vue2-x-的-API-差异"><a href="#Vue3-x-相交-Vue2-x-的-API-差异" class="headerlink" title="Vue3.x 相交 Vue2.x 的 API 差异"></a>Vue3.x 相交 Vue2.x 的 API 差异</h2><ul><li>参考教程：<a href="https://juejin.cn/post/6940454764421316644">Vue3.0 新特性以及使用经验总结</a></li></ul><h3 id="组合式-API"><a href="#组合式-API" class="headerlink" title="组合式 API"></a>组合式 API</h3><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1656489570886-63eb7df3-919e-4746-a848-ef1ddd407c5a.png#clientId=u7503abec-831e-4&crop=0&crop=0&crop=1&crop=1&from=drop&id=uea796c27&margin=%5Bobject%20Object%5D&name=62783021-7ce24400-ba89-11e9-9dd3-36f4f6b1fae2.png&originHeight=1016&originWidth=262&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=118005&status=done&style=stroke&taskId=u1dc3cf48-5c70-4641-8ff9-4e2371024a1&title=" alt="62783021-7ce24400-ba89-11e9-9dd3-36f4f6b1fae2.png"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1656489575312-5aa30517-52d0-4b73-be74-1f4bb4ad6a36.png#clientId=u7503abec-831e-4&crop=0&crop=0&crop=1&crop=1&from=drop&id=u691dd2fb&margin=%5Bobject%20Object%5D&name=62783026-810e6180-ba89-11e9-8774-e7771c8095d6.png&originHeight=1201&originWidth=1200&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=206094&status=done&style=stroke&taskId=uddbf9e8a-c416-4103-b194-34b864dd1df&title=" alt="62783026-810e6180-ba89-11e9-8774-e7771c8095d6.png"></p><h3 id="defineComponent"><a href="#defineComponent" class="headerlink" title="defineComponent({})"></a>defineComponent({})</h3><p>服务于 typescript 项目，defineComponent 本身的功能很简单，但是最主要的功能是为了 ts 下的类型推导。对于一个 ts 文件，如果我们直接写</p><pre><code class="vue">export default &#123;&#125;</code></pre><p>对于编辑器而言，{} 只是一个 Object 的类型，无法有针对性的提示我们对于 vue 组件来说 {} 里应该有哪些属性。但是增加一层 defineComponet 的话，</p><pre><code class="html">export default defineComponent(&#123;&#125;)</code></pre><p>这时，{} 就变成了 defineComponent 的参数，那么对参数类型的提示，就可以实现对 {} 中属性的提示，外还可以进行对参数的一些类型推导等操作。</p><h3 id="setup"><a href="#setup" class="headerlink" title="setup()"></a>setup()</h3><pre><code class="vue">&lt;script&gt;setup() &#123;  console.log(&#39;----setup第一个执行----&#39;)  // vue3.x生命周期写在setup中  onBeforeMount(() =&gt; &#123;    console.log(&#39;------vue3中onBeforeMount-----&#39;)  &#125;)  onMounted(() =&gt; &#123;    console.log(&#39;------vue3中onMounted-----&#39;)  &#125;)  // 调试哪些数据发生了变化  onRenderTriggered((event) =&gt; &#123;    console.log(&#39;------vue3中onRenderTriggered-----&#39;, event)  &#125;)  // ref则处理 js 基础类型的双向绑定，也能处理对象  const year = ref(0)  // reactive用于处理对象的双向绑定  const user = reactive(&#123;nickname: &#39;xiaofan&#39;, age: 26, gender: &#39;女&#39;&#125;)  const timer = setInterval(() =&gt; &#123;    year.value++    user.age++    if (year.value === 2) &#123;      clearInterval(timer)    &#125;  &#125;, 1000)  // 侦听 reactive 定义的数据  watch(    () =&gt; user.age,    (curAge, preAge) =&gt; &#123;      console.log(&#39;reactive新值:&#39;, curAge, &#39;reactive老值:&#39;, preAge)    &#125;  )  // 侦听 ref 定义的数据  watch(year, (newVal, oldVal) =&gt; &#123;    console.log(&#39;ref新值:&#39;, newVal, &#39;ref老值:&#39;, oldVal)  &#125;)  // 也可以使用 toRefs 实现导出时候进行对象结构  return &#123;    year,    user,    blockContent: `AntV 是蚂蚁。`,  &#125;&#125;,&lt;/script&gt;</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1644647050857-a30d7d7c-d2e1-49a4-9695-58d1505df9b2.png#clientId=uc6b85a54-d54e-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=399&id=u5882a31f&margin=%5Bobject%20Object%5D&name=image.png&originHeight=399&originWidth=774&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=50245&status=done&style=stroke&taskId=u776fd526-d630-454c-abc4-6771f3fd831&title=&width=774" alt="image.png"></p><h3 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h3><pre><code class="vue">&lt;script lang=&quot;ts&quot;&gt;import &#123;  defineComponent,  onBeforeMount,  onMounted,  onBeforeUpdate,  onUpdated,  onBeforeUnmount,  onUnmounted,  onErrorCaptured,  onRenderTracked,  onRenderTriggered,  reactive,  ref,  watch,&#125; from &quot;vue&quot;;import &#123;  UpCircleTwoTone,  HomeOutlined,  SettingFilled,  SmileOutlined,  SyncOutlined,  LoadingOutlined,  ClockCircleOutlined,&#125; from &quot;@ant-design/icons-vue&quot;;export default defineComponent(&#123;  components: &#123;    HomeOutlined,    SettingFilled,    SmileOutlined,    SyncOutlined,    LoadingOutlined,    UpCircleTwoTone,    ClockCircleOutlined,  &#125;,  data() &#123;    return &#123;      msg: &quot;msg in data&quot;,    &#125;;  &#125;,  setup() &#123;    console.log(&quot;----setup第一个执行----&quot;);    // vue3.x生命周期写在setup中    onBeforeMount(() =&gt; &#123;      console.log(&quot;------vue3中onBeforeMount-----&quot;);    &#125;);    onMounted(() =&gt; &#123;      console.log(&quot;------vue3中onMounted-----&quot;);    &#125;);    // 调试哪些数据发生了变化    onRenderTriggered((event) =&gt; &#123;      console.log(&quot;------vue3中onRenderTriggered-----&quot;, event);    &#125;);    // ref则处理 js 基础类型的双向绑定，也能处理对象    const year = ref(0);    // reactive用于处理对象的双向绑定    const user = reactive(&#123; nickname: &quot;xiaofan&quot;, age: 26, gender: &quot;女&quot; &#125;);    const timer = setInterval(() =&gt; &#123;      year.value++;      user.age++;      if (year.value === 2) &#123;        clearInterval(timer);      &#125;    &#125;, 1000);    // 侦听 reactive 定义的数据    watch(      () =&gt; user.age,      (curAge, preAge) =&gt; &#123;        console.log(&quot;reactive新值:&quot;, curAge, &quot;reactive老值:&quot;, preAge);      &#125;    );    // 侦听 ref 定义的数据    watch(year, (newVal, oldVal) =&gt; &#123;      console.log(&quot;ref新值:&quot;, newVal, &quot;ref老值:&quot;, oldVal);    &#125;);    // 也可以使用 toRefs 实现导出时候进行对象结构    return &#123;      year,      user,      blockContent: `AntV 是蚂蚁金服全新一代数据可视化解决方案，致力于提供一套简单方便、专业可靠、不限可能的数据可视化最佳实践。得益于丰富的业务场景和用户需求挑战，AntV 经历多年积累与不断打磨，已支撑整个阿里集团内外 20000+ 业务系统，通过了日均千万级 UV 产品的严苛考验。我们正在基础图表，图分析，图编辑，地理空间可视化，智能可视化等各个可视化的领域耕耘，欢迎同路人一起前行。`,    &#125;;  &#125;,  // vue2当中的  beforeCreate() &#123;    console.log(&quot;----vue2中beforeCreate第二个执行----&quot;);  &#125;,  // vue2当中的  created() &#123;    console.log(&quot;----vue2中created第三个执行----&quot;);  &#125;,&#125;);&lt;/script&gt;</code></pre><h2 id="vue3-路由相关"><a href="#vue3-路由相关" class="headerlink" title="vue3 路由相关"></a>vue3 路由相关</h2><ul><li><a href="https://blog.csdn.net/animatecat/article/details/117257037">vue3.0 router 路由跳转传参（router.push）</a></li><li><a href="https://juejin.cn/post/6962528855513006117">【Vue】015. Vue-Router（三）—— 路由传参</a></li><li>官网：<a href="https://router.vuejs.org/zh/">https://router.vuejs.org/zh/</a></li></ul><h3 id="得到动态路由信息"><a href="#得到动态路由信息" class="headerlink" title="得到动态路由信息"></a>得到动态路由信息</h3><ul><li><input checked="" disabled="" type="checkbox"> 在<code>index.ts</code>中得不到该路由页面的相关信息<del>===选一个比较好一点的传值方案，最好在路由 index.ts 设置（props）。</del>在路由使用组件中就可以使用。</li></ul><p>参考：<a href="https://router.vuejs.org/zh/guide/essentials/dynamic-matching.html">https://router.vuejs.org/zh/guide/essentials/dynamic-matching.html</a></p><pre><code class="vue">&lt;script lang=&quot;ts&quot;&gt;import &#123; useRouter &#125; from &quot;vue-router&quot;;export default defineComponent(&#123;  setup() &#123;    // 获取当前路由    const router = useRouter();    // 路由信息    const router_info = router.currentRoute.value;    const lookRouter = () =&gt; &#123;      console.log(router_info);    &#125;;    return &#123;      router_info,      lookRouter,    &#125;;  &#125;,&#125;);&lt;/script&gt;</code></pre><h2 id="定义数据"><a href="#定义数据" class="headerlink" title="定义数据"></a>定义数据</h2><h3 id="Vue3-定义普通数据"><a href="#Vue3-定义普通数据" class="headerlink" title="Vue3 定义普通数据"></a>Vue3 定义普通数据</h3><ul><li>【不建议】：也还可以使用 Vue2 中的 data，但是不能在 setup()中使用 this 访问</li></ul><p><strong>不再用 vue2 当中的 data API 了（因为不能进行操作，功能性大大减少）</strong></p><ul><li>【建议】：使用 ts 的接口类型定义数据</li></ul><pre><code class="vue">&lt;script lang=&quot;ts&quot;&gt;import &#123; defineComponent &#125; from &quot;vue&quot;;// 高效应用场景interface SpecialFunDataItem &#123;  title: string;  description: string;&#125;const apply_data: SpecialFunDataItem[] = [  &#123;    title: &quot;知识库/项目文档/产品手册&quot;,    description:      &quot;适合团队知识库建设、项目文档，开发手册、技术手册、API Document、在线写作。 适用于大型文档，目录检索式布局，多文档，多级分类排版。&quot;,  &#125;,  &#123;    title: &quot;帮助中心/FAQ/在线问答&quot;,    description:      &quot;适合团队知识库建设、项目文档，开发手册、技术手册、API Document、在线写作。 适用于大型文档，目录检索式布局，多文档，多级分类排版。&quot;,  &#125;,  &#123;    title: &quot;企业内部/外部知识管理&quot;,    description:      &quot;适合团队知识库建设、项目文档，开发手册、技术手册、API Document、在线写作。 适用于大型文档，目录检索式布局，多文档，多级分类排版。&quot;,  &#125;,  &#123;    title: &quot;第四个标题&quot;,    description:      &quot;适合团队知识库建设、项目文档，开发手册、技术手册、API Document、在线写作。 适用于大型文档，目录检索式布局，多文档，多级分类排版。&quot;,  &#125;,];export default defineComponent(&#123;  name: &quot;Home&quot;,  components: &#123;&#125;,  setup() &#123;    return &#123;      apply_data,    &#125;;  &#125;,&#125;);&lt;/script&gt;</code></pre><h3 id="Vue3-定义响应数据"><a href="#Vue3-定义响应数据" class="headerlink" title="Vue3 定义响应数据"></a>Vue3 定义响应数据</h3><h4 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h4><pre><code class="typescript">    &lt;a-modal      v-model:visible=&quot;visible&quot;      :title=&quot;updateItem === &#39;delete_user&#39; ? &#39;删除账户&#39; : &#39;修改信息&#39;&quot;      @ok=&quot;handleOkInfo&quot;      @cancel=&quot;handleCancelInfo&quot;      ok-text=&quot;确认&quot;      cancel-text=&quot;取消&quot;    &gt;// -----------------------------------------------------------------------import &#123;ref&#125; from &#39;vue&#39;const visible = ref&lt;boolean&gt;(false)const handleOkInfo = (e: MouseEvent) =&gt; &#123;  visible.value = false&#125;    return &#123;      visible,    &#125;</code></pre><h4 id="reactive"><a href="#reactive" class="headerlink" title="reactive"></a>reactive</h4><p>这个更过使用在对象和数组类型的响应式定义数据，因为在 vue2 中，对于数组和对象是不能够响应式的需要监听，而在 vue3 中，以此作为优化来定义响应式数据。</p><h3 id="Vue2-中的-data"><a href="#Vue2-中的-data" class="headerlink" title="Vue2 中的 data"></a>Vue2 中的 data</h3><h4 id="如何在-setup-中使用-data-中的数据库？"><a href="#如何在-setup-中使用-data-中的数据库？" class="headerlink" title="如何在 setup 中使用 data 中的数据库？"></a>如何在 setup 中使用 data 中的数据库？</h4><p>按照以前 vue2，直接使用 this 可以访问到 data 中定义的数据，但在 vue3 不行，因为 setup()函数的执行要比 created，oncrated 函数都要早。</p><p>具体使用以下小技巧可以访问到：</p><pre><code class="javascript">&lt;div v-on:click=&quot;fun(testdata)&quot;&gt;&lt;/div&gt;setup()&#123;    const  fun=(i)=&gt;&#123;      alert(i)    &#125;&#125;,data()&#123;    return&#123;       testdata:1,    &#125;&#125;</code></pre><p>也可以使用 getCurrentInstance 方法获取 data 内的数据<strong>（未验证）</strong></p><pre><code class="vue">&lt;script lang=&quot;ts&quot;&gt;import &#123; getCurrentInstance &#125; from &quot;vue&quot;;export default &#123;  data() &#123;    return &#123;      b: &quot;data数据&quot;,    &#125;;  &#125;,  setup() &#123;    const datab = getCurrentInstance();    async function getdata() &#123;      let dataa = datab.data.b;      console.log(dataa);    &#125;  &#125;,&#125;;&lt;/script&gt;</code></pre><h2 id="其他知识"><a href="#其他知识" class="headerlink" title="其他知识"></a>其他知识</h2><h3 id="样式只在当前页面有效"><a href="#样式只在当前页面有效" class="headerlink" title="样式只在当前页面有效"></a>样式只在当前页面有效</h3><p>组件中 style 标签后面加上<code>scoped</code>就可以</p><pre><code class="vue">&lt;style lang=&quot;less&quot; scoped&gt;&lt;/style&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 👨‍💻Web开发 </category>
          
          <category> Vue </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>国庆随笔：向死而生</title>
      <link href="/essay/gqoawl/"/>
      <url>/essay/gqoawl/</url>
      
        <content type="html"><![CDATA[<p>国庆小随笔</p><h2 id="十月五号"><a href="#十月五号" class="headerlink" title="十月五号"></a>十月五号</h2><p>姐姐结婚，爱情是什么样的，我们谁都不得而知，我自认为自己最难懂的就是爱情，从爱情走向婚姻，我觉得是最幸福的事情。</p><h2 id="十月六号"><a href="#十月六号" class="headerlink" title="十月六号"></a>十月六号</h2><h3 id="曾视为空城的那个鄱阳"><a href="#曾视为空城的那个鄱阳" class="headerlink" title="曾视为空城的那个鄱阳"></a>曾视为空城的那个鄱阳</h3><p>和两个兄弟去了趟鄱阳，那个我曾经视为空城的一个小城，东湖大道那座小桥现已修建名为文正桥，桥是宽阔了许多，不过我还是些许留恋曾经两旁有参天大树的桥道。</p><p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1633875808473-8c8e729a-95e5-4cc1-9569-75ebeb9ec25e.jpeg#clientId=uaa7522f9-6814-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=ua8c982bd&margin=%5Bobject%20Object%5D&name=IMG_20211006_133245.jpg&originHeight=2736&originWidth=3648&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=4880409&status=done&style=none&taskId=u57af4ca6-2cfe-44e2-a1f7-5d1545c563e&title=" alt="IMG_20211006_133245.jpg"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1633875807952-96f55875-30da-431c-98dd-76ee3ae331e0.jpeg#clientId=uaa7522f9-6814-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u77239b62&margin=%5Bobject%20Object%5D&name=IMG_20211006_133641.jpg&originHeight=2736&originWidth=3648&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=4194628&status=done&style=none&taskId=u3978dc11-808e-433b-91d5-30bd2e4a3d9&title=" alt="IMG_20211006_133641.jpg"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1633875809760-4dffcacf-688d-439e-9f71-a2a3245b26dd.jpeg#clientId=uaa7522f9-6814-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=ufe07eabd&margin=%5Bobject%20Object%5D&name=IMG_20211006_134109.jpg&originHeight=3648&originWidth=2736&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=6523133&status=done&style=none&taskId=ua18b2cfe-5018-4cbf-8956-6d0afab0a4c&title=" alt="IMG_20211006_134109.jpg"></p><h3 id="饶州古镇"><a href="#饶州古镇" class="headerlink" title="饶州古镇"></a>饶州古镇</h3><p>自家有这么一个古镇景点，还是很不错的</p><p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1633875997616-e683f592-bb92-4ca9-93d0-67a3712df0b5.jpeg#clientId=uaa7522f9-6814-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u01295dec&margin=%5Bobject%20Object%5D&name=IMG_20211006_185959.jpg&originHeight=2736&originWidth=3648&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=2432850&status=done&style=none&taskId=u7d46d5aa-31e3-4ec8-a164-ea8f31c8f54&title=" alt="IMG_20211006_185959.jpg"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1633875998381-311af713-f841-4c55-852c-8f92a72749bc.jpeg#clientId=uaa7522f9-6814-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u05d7c963&margin=%5Bobject%20Object%5D&name=IMG_20211006_190306.jpg&originHeight=2736&originWidth=3648&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=3571959&status=done&style=none&taskId=u736c8455-81fd-44bb-93ff-2bb68963e45&title=" alt="IMG_20211006_190306.jpg"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1633875998279-4cdfbe6b-42b1-42bc-81a1-073a7b3830d8.jpeg#clientId=uaa7522f9-6814-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=uddde3c37&margin=%5Bobject%20Object%5D&name=IMG_20211006_190311.jpg&originHeight=2592&originWidth=3840&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=3458685&status=done&style=none&taskId=u9302e69d-6eb2-4ed5-9e1e-934771aa341&title=" alt="IMG_20211006_190311.jpg"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1633875997897-10bf7687-e99e-4f1a-b67d-c6614ece8bca.jpeg#clientId=uaa7522f9-6814-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u7fb6ebc3&margin=%5Bobject%20Object%5D&name=IMG_20211006_190548.jpg&originHeight=2736&originWidth=3648&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=2697639&status=done&style=none&taskId=u62782015-7db3-46e1-86e6-03d1bca84b0&title=" alt="IMG_20211006_190548.jpg"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1633875998399-1534eab0-3711-47d1-886f-4a309f9d9273.jpeg#clientId=uaa7522f9-6814-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=ud64bd0a4&margin=%5Bobject%20Object%5D&name=IMG_20211006_190751.jpg&originHeight=2736&originWidth=3648&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=3456095&status=done&style=none&taskId=u1c0c9637-cbf3-44cd-aa89-4812ad8ad0d&title=" alt="IMG_20211006_190751.jpg"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1633876002155-627bd9d7-39ea-41a4-a82a-4ad9992056c4.jpeg#clientId=uaa7522f9-6814-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=ufa00a8a2&margin=%5Bobject%20Object%5D&name=IMG_20211006_190838.jpg&originHeight=2736&originWidth=3648&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=4177240&status=done&style=none&taskId=ue7c7fc5f-1d6f-40dc-906c-197e383928b&title=" alt="IMG_20211006_190838.jpg"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1633876002241-35379903-c302-4e54-bb58-439786ff4470.jpeg#clientId=uaa7522f9-6814-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u06167c90&margin=%5Bobject%20Object%5D&name=IMG_20211006_190903.jpg&originHeight=2736&originWidth=3648&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=4227079&status=done&style=none&taskId=udaf013ab-21c7-4301-b0ad-e344ea00d98&title=" alt="IMG_20211006_190903.jpg"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1633876002731-e1bb0cc3-48c4-45e0-8895-9d435b1e04fe.jpeg#clientId=uaa7522f9-6814-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u625ac0a3&margin=%5Bobject%20Object%5D&name=IMG_20211006_191013.jpg&originHeight=2736&originWidth=3648&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=4043593&status=done&style=none&taskId=u3c75859f-76e8-4b7a-be49-4de74ef64ef&title=" alt="IMG_20211006_191013.jpg"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1633876002769-34025c83-0fd7-4f24-8ea9-e32f86b94677.jpeg#clientId=uaa7522f9-6814-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u08140798&margin=%5Bobject%20Object%5D&name=IMG_20211006_191018.jpg&originHeight=2736&originWidth=3648&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=3928784&status=done&style=none&taskId=u0f77ba32-6429-4f05-80a8-393044e0c7c&title=" alt="IMG_20211006_191018.jpg"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1633876001841-3bfc9710-8031-4cc4-a930-6a60bcb456f7.jpeg#clientId=uaa7522f9-6814-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u582a5e29&margin=%5Bobject%20Object%5D&name=IMG_20211006_191418.jpg&originHeight=2736&originWidth=3648&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=2361719&status=done&style=none&taskId=u6b1560c9-ec47-429e-8f47-504a7193a60&title=" alt="IMG_20211006_191418.jpg"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1633876005039-78bec731-e419-471b-b1d3-5078abd8f32f.jpeg#clientId=uaa7522f9-6814-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=uc786dce9&margin=%5Bobject%20Object%5D&name=IMG_20211006_191502.jpg&originHeight=2736&originWidth=3648&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=2524312&status=done&style=none&taskId=u92810d64-8ac0-45cc-a0dd-0509feb5d29&title=" alt="IMG_20211006_191502.jpg"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1633876005917-cc7d5d1f-8813-41c8-8392-24b446712922.jpeg#clientId=uaa7522f9-6814-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u00e0504d&margin=%5Bobject%20Object%5D&name=IMG_20211006_191937.jpg&originHeight=2736&originWidth=3648&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=2862008&status=done&style=none&taskId=ub62b0df8-4c3d-493d-8aab-1f34a501c8f&title=" alt="IMG_20211006_191937.jpg"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1633876006650-1cf3f393-472d-4af3-910a-454b98599755.jpeg#clientId=uaa7522f9-6814-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u08504088&margin=%5Bobject%20Object%5D&name=IMG_20211006_192505.jpg&originHeight=2736&originWidth=3648&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=3151108&status=done&style=none&taskId=u5945fa35-9a35-4ed5-9d43-6d193d6e462&title=" alt="IMG_20211006_192505.jpg"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1633876006744-f7a8a89f-a970-4e04-a891-c257f9e67160.jpeg#clientId=uaa7522f9-6814-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u00a090b1&margin=%5Bobject%20Object%5D&name=IMG_20211006_192510.jpg&originHeight=2592&originWidth=3840&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=2492202&status=done&style=none&taskId=u09a65fb7-caeb-4758-b3d2-75275cf7703&title=" alt="IMG_20211006_192510.jpg"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1633876009430-86c16483-95dc-4fea-b6ef-5b6429e0a532.jpeg#clientId=uaa7522f9-6814-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=ue1f27166&margin=%5Bobject%20Object%5D&name=IMG_20211006_192649.jpg&originHeight=2736&originWidth=3648&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=3927639&status=done&style=none&taskId=u2b51170b-bdc2-4638-a050-8b1648f1c66&title=" alt="IMG_20211006_192649.jpg"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1633876009245-da7f7e0a-bfdb-484c-aaac-3b1d666cc25b.jpeg#clientId=uaa7522f9-6814-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u60e30b2c&margin=%5Bobject%20Object%5D&name=IMG_20211006_192958.jpg&originHeight=2736&originWidth=3648&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=2988807&status=done&style=none&taskId=u974dc5c9-f6fb-4c1d-a52c-09a37117edd&title=" alt="IMG_20211006_192958.jpg"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1633876010297-9e5a9f09-53fd-4fe0-8cfd-26fd6a69c87a.jpeg#clientId=uaa7522f9-6814-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u81b81119&margin=%5Bobject%20Object%5D&name=IMG_20211006_193047.jpg&originHeight=2736&originWidth=3648&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=3322541&status=done&style=none&taskId=u67b38cb5-b613-42b3-bbed-f383ffe2cc3&title=" alt="IMG_20211006_193047.jpg"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1633876011269-cf89a74b-13f0-4381-8754-2be7b8cdcf23.jpeg#clientId=uaa7522f9-6814-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u9acd5f62&margin=%5Bobject%20Object%5D&name=IMG_20211006_193354.jpg&originHeight=3648&originWidth=2736&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=4084340&status=done&style=none&taskId=uc1d92180-abc2-4af2-b837-41d92fdf127&title=" alt="IMG_20211006_193354.jpg"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1633876011280-e399e628-809e-4668-a49b-9241c6f3409a.jpeg#clientId=uaa7522f9-6814-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=uf29ce6cc&margin=%5Bobject%20Object%5D&name=IMG_20211006_193356.jpg&originHeight=3648&originWidth=2736&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=4156661&status=done&style=none&taskId=u8283e634-c970-4061-ad3c-00ef657874e&title=" alt="IMG_20211006_193356.jpg"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1633876013616-b2afe4f8-587b-44d7-871f-f508124584f5.jpeg#clientId=uaa7522f9-6814-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=ud0599d64&margin=%5Bobject%20Object%5D&name=IMG_20211006_193444.jpg&originHeight=2736&originWidth=3648&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=3048108&status=done&style=none&taskId=u00a82807-9f76-465c-be9a-2e4f518b589&title=" alt="IMG_20211006_193444.jpg"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1633876014575-2e2702c5-4cf3-461d-a2b0-c4024a95ac8f.jpeg#clientId=uaa7522f9-6814-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=ua104b296&margin=%5Bobject%20Object%5D&name=IMG_20211006_193534.jpg&originHeight=2736&originWidth=3648&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=3783504&status=done&style=none&taskId=u4e4dcf20-2e6a-44b1-86a7-fa5901a5dff&title=" alt="IMG_20211006_193534.jpg"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1633876014664-975619ee-cd95-44c4-bfd5-a6e32201fc89.jpeg#clientId=uaa7522f9-6814-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u750f8321&margin=%5Bobject%20Object%5D&name=IMG_20211006_193636.jpg&originHeight=2736&originWidth=3648&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=3487347&status=done&style=none&taskId=ue451273f-82ae-49b6-9c77-e358c1690e7&title=" alt="IMG_20211006_193636.jpg"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1633876015648-67768ec5-5d69-40c5-b96a-464e6ba3d913.jpeg#clientId=uaa7522f9-6814-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=ud452a52b&margin=%5Bobject%20Object%5D&name=IMG_20211006_193654.jpg&originHeight=3648&originWidth=2736&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=3916209&status=done&style=none&taskId=u6fda9650-290e-417b-98a5-172cee6e685&title=" alt="IMG_20211006_193654.jpg"></p><h2 id="十月七号"><a href="#十月七号" class="headerlink" title="十月七号"></a>十月七号</h2><p>生活节奏太快，想了想，想停下来写写走走看看，于是七号在家中，八号再去公司<br><img src="https://cdn.nlark.com/yuque/0/2022/gif/1484158/1649041952673-600e4ad8-231b-491a-b1ba-ada6a2c0ee31.gif#crop=0&crop=0&crop=1&crop=1&id=nzi5z&originHeight=151&originWidth=218&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&title="></p><h2 id="十月八号"><a href="#十月八号" class="headerlink" title="十月八号"></a>十月八号</h2><h3 id="珠海版“人在囧途”"><a href="#珠海版“人在囧途”" class="headerlink" title="珠海版“人在囧途”"></a>珠海版“人在囧途”</h3><p>返珠海，上演一段真正的人在囧途，没有遇到<br><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1633876494701-40bf091b-6af2-41bc-b108-ce3580a8e3b1.jpeg#clientId=uaa7522f9-6814-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=uf020ab48&margin=%5Bobject%20Object%5D&name=IMG_20211008_180010.jpg&originHeight=2736&originWidth=3648&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=2082722&status=done&style=none&taskId=u9fa51d57-4b8b-4931-a834-23f8a7d8ca6&title=" alt="IMG_20211008_180010.jpg"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1633876495028-16dcd228-d572-4658-9626-6a4a169162a0.jpeg#clientId=uaa7522f9-6814-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=uc21583b3&margin=%5Bobject%20Object%5D&name=IMG_20211008_180015.jpg&originHeight=2736&originWidth=3648&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=2508603&status=done&style=none&taskId=u385a120d-5419-4fe8-86b2-addcd27a8d9&title=" alt="IMG_20211008_180015.jpg"><br><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1633876843288-1bd256a2-fd14-49a3-b8b2-b21ac3f050af.jpeg#clientId=uaa7522f9-6814-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=uf549968e&margin=%5Bobject%20Object%5D&name=Screenshot_20211008_140310_com.huawei.android.launcher.jpg&originHeight=2400&originWidth=1176&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=554001&status=done&style=none&taskId=uc516bcf6-3f6b-495a-81a9-4acb3e3c60a&title=" alt="Screenshot_20211008_140310_com.huawei.android.launcher.jpg"><br><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1633876844529-f7c4bd92-d9b2-495c-9309-6a671a860134.jpeg#clientId=uaa7522f9-6814-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=QEJAx&margin=%5Bobject%20Object%5D&name=IMG_20211008_185907.jpg&originHeight=3648&originWidth=2736&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=2206391&status=done&style=none&taskId=u71395109-ef71-4ff6-968d-f44936523d7&title=" alt="IMG_20211008_185907.jpg"><br><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1633877452207-23cc8796-b4a5-4675-a283-e520384354b8.jpeg#clientId=uaa7522f9-6814-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=u89faf5ba&margin=%5Bobject%20Object%5D&name=IMG_20211009_101626.jpg&originHeight=3648&originWidth=2736&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=1388720&status=done&style=none&taskId=uce9714dc-af3b-4d53-a7ba-2d52f64abff&title=" alt="IMG_20211009_101626.jpg"></p><h2 id="十月九号"><a href="#十月九号" class="headerlink" title="十月九号"></a>十月九号</h2><p>四点钟被叫醒，说是去赶车，我太难了，假期到现在，每天都在早起，每天都在出行的路上，你要说我现在渴望些什么，我只想吃点粥啥的暖暖胃，然后再好好睡上一觉～</p><p>生活或许就是有时该为了活着而活着，而在关键时刻又需要向死而生的一种魄力。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>PC端hevc编码的MOV格式视频无法查看</title>
      <link href="/blog/akf33e/"/>
      <url>/blog/akf33e/</url>
      
        <content type="html"><![CDATA[<p>前言：需求中有这么一个问题，部分 mov 格式的视频在移动端可以播放，但在 pc 客户端无法显示，对比能播放和不能播放的 mov 格式视频，发现是 hevc 编码的 mov 视频不能播放，对此在做需求过程中，寻求并尝试了一些方法来解决这个问题，在本文做个记录。</p><blockquote><ol><li>MOV 合适视频是苹果手机拍摄的视频格式</li><li>苹果拍照的视频和苹果利用 api 调用的拍照的视频，这两者拍的视频编码是有差异的</li></ol></blockquote><h2 id="一、两者视频元信息比较"><a href="#一、两者视频元信息比较" class="headerlink" title="一、两者视频元信息比较"></a>一、两者视频元信息比较</h2><p>所用例子：</p><ul><li><a href="https://image.x7sy.com/oa_medias/65440114717__69E1A426-97B2-4832-95FC-7712D9D7A487-16327083586676.MOV">非 hevc 编码视频例子</a></li><li><a href="https://image.x7sy.com/oa_medias/IMG_0018-16327078428771.MOV">hevc 编码视频例子</a></li></ul><p>利用格式工厂查看两个视频的元信息：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1636168657171-19788f71-f632-44cc-9e62-0e6d9f206379.png#clientId=u44291b10-e611-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=445&id=u318798b8&margin=%5Bobject%20Object%5D&name=image.png&originHeight=890&originWidth=1650&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=671133&status=done&style=stroke&taskId=uf885d7ab-752e-4ef1-96fe-6a421ff5c38&title=&width=825" alt="image.png"><br>利用上面的信息以及实际的可播放效果得：</p><ul><li>mobile：都能看（安卓和苹果）</li><li>pc：不能看上传的，<strong>hevc 编码的不能解码</strong>？移动端相较 pc 能处理 hevc 编码？</li></ul><h2 id="二、HEVC、H-265-兼容性支持情况"><a href="#二、HEVC、H-265-兼容性支持情况" class="headerlink" title="二、HEVC、H.265 兼容性支持情况"></a>二、HEVC、H.265 兼容性支持情况</h2><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1632730222885-c5d08df9-afdf-4b78-85fa-9003cb6b47b2.png#clientId=u38de4263-2f63-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=283&id=u07c0c94a&margin=%5Bobject%20Object%5D&name=image.png&originHeight=292&originWidth=587&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=14470&status=done&style=stroke&taskId=u7ce8c143-f8ec-4f7f-96a5-7ba0728d456&title=&width=568.5" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1632730253372-9f6e0c9d-03c5-4685-ada6-d68306266653.png#clientId=u38de4263-2f63-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=180&id=u940ac543&margin=%5Bobject%20Object%5D&name=image.png&originHeight=337&originWidth=1071&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=100551&status=done&style=stroke&taskId=u994e8a29-5c3d-41d5-8ec1-bae0f682041&title=&width=570.5" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1636168806126-ed5989be-ca1f-455c-a434-b0fbe89bca94.png#clientId=u44291b10-e611-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=339&id=ue461184a&margin=%5Bobject%20Object%5D&name=image.png&originHeight=677&originWidth=1777&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=1107474&status=done&style=none&taskId=uf93f38a9-dd61-421b-9783-db33ab14bd0&title=&width=888.5" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1632885246692-38ce1a86-66eb-4d5e-8e91-ff2c48a65f4e.png#clientId=u90d2ab6b-4700-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=68&id=u48fdcb25&margin=%5Bobject%20Object%5D&name=image.png&originHeight=136&originWidth=1058&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=16583&status=done&style=stroke&taskId=u345d55b9-3d5c-4e20-8210-9ea4a944272&title=&width=529" alt="image.png"><br>参考方案：</p><ul><li><a href="https://blog.csdn.net/yanrx76/article/details/116238315"><strong>如何在浏览器中支持 H265/HEVC</strong></a></li><li><a href="https://www.fdbtech.com/webfrontend/%E5%89%8D%E7%AB%AF%E5%A6%82%E4%BD%95%E6%92%AD%E6%94%BEhevch265%E7%BC%96%E7%A0%81%E7%9A%84mp4%E8%A7%86%E9%A2%91">前端 web 如何播放 HEVC(h265)编码的 MP4 视频</a></li><li><a href="https://segmentfault.com/a/1190000017187346">H.265/HEVC 在 Web 视频播放的实践</a></li><li><a href="https://segmentfault.com/q/1010000020081504">video 播放 mov 文件问题</a></li></ul><h2 id="三、解决方案"><a href="#三、解决方案" class="headerlink" title="三、解决方案"></a>三、解决方案</h2><p>下面几种方法是解决过程中所尝试的几种方法，前四种都测试未能解决该问题，最后一个方法取之。</p><h3 id="【弃】vue-h265-player-插件使用"><a href="#【弃】vue-h265-player-插件使用" class="headerlink" title="【弃】vue-h265-player 插件使用"></a>【弃】vue-h265-player 插件使用</h3><ul><li><a href="https://www.npmjs.com/package/vue-h265-player">https://www.npmjs.com/package/vue-h265-player</a></li><li><a href="https://blog.csdn.net/Nie2014/article/details/114651376">https://blog.csdn.net/Nie2014/article/details/114651376</a></li><li><a href="https://blog.csdn.net/weixin_42274114/article/details/109490633">https://blog.csdn.net/weixin_42274114/article/details/109490633</a></li></ul><p><del>判断是否为 h.265，如果是就将其用新的播放器（插件）播放</del><br><a href="https://github.com/buzz/mediainfo.js"><del>https://github.com/buzz/mediainfo.js</del></a><br><del>项目中添加该 api 的判断代码</del></p><ul><li><a href="https://blog.csdn.net/weixin_42274114/article/details/109490633"><del>https://blog.csdn.net/weixin_42274114/article/details/109490633</del></a></li><li><a href="https://segmentfault.com/a/1190000039753551"><del>https://segmentfault.com/a/1190000039753551</del></a></li><li><a href="https://blog.csdn.net/Nie2014/article/details/114651376"><del>https://blog.csdn.net/Nie2014/article/details/114651376</del></a><div style="background: #FFF3F3;padding:10px;border: 1px solid #DEB8BE;border-radius:5px;margin-bottom:5px;">插件源代码本身有问题</div></li></ul><h3 id="【弃】EasyPlayer-js-插件使用"><a href="#【弃】EasyPlayer-js-插件使用" class="headerlink" title="【弃】EasyPlayer.js 插件使用"></a>【弃】EasyPlayer.js 插件使用</h3><ul><li><a href="https://my.oschina.net/u/4383286/blog/4496965">https://my.oschina.net/u/4383286/blog/4496965</a></li><li><a href="https://github.com/tsingsee/EasyPlayer.js">https://github.com/tsingsee/EasyPlayer.js</a></li><li><a href="https://blog.csdn.net/a843334549/article/details/117323709">https://blog.csdn.net/a843334549/article/details/117323709</a></li><li><a href="https://blog.csdn.net/u012848709/article/details/106291133">https://blog.csdn.net/u012848709/article/details/106291133</a></li><li><a href="https://www.liveqing.com/docs/manuals/LivePlayer.html#%E5%9C%A8-vue-%E4%B8%AD%E4%BD%BF%E7%94%A8">https://www.liveqing.com/docs/manuals/LivePlayer.html#%E5%9C%A8-vue-%E4%B8%AD%E4%BD%BF%E7%94%A8</a></li><li><a href="https://gitee.com/livegbs/liveplayer-vc">https://gitee.com/livegbs/liveplayer-vc</a><div style="background: #FFF3F3;padding:10px;border: 1px solid #DEB8BE;border-radius:5px;margin-bottom:5px;">未能播放那个苹果上传mov文件可能原因是苹果上传的mov文件(hevc)不属于该插件所解码的h.265的范围。</div></li></ul><p><strong>只要是 hevc 的格式，不管是视频还是声音，都无法播放</strong></p><ul><li>EasyPlayer.js 插件：<a href="https://github.com/tsingsee/EasyPlayer.js/issues/45">https://github.com/tsingsee/EasyPlayer.js/issues/45</a></li><li>原项目 issues（vue-video-player 插件）：<a href="https://github.com/surmon-china/vue-video-player/issues/232">https://github.com/surmon-china/vue-video-player/issues/232</a></li></ul><h3 id="【弃】libde265-JS-解决办法"><a href="#【弃】libde265-JS-解决办法" class="headerlink" title="【弃】libde265.JS 解决办法"></a>【弃】libde265.JS 解决办法</h3><ul><li><a href="https://github.com/strukturag/libde265">https://github.com/strukturag/libde265</a></li><li><a href="https://www.fdbtech.com/webfrontend/%E5%89%8D%E7%AB%AF%E5%A6%82%E4%BD%95%E6%92%AD%E6%94%BEhevch265%E7%BC%96%E7%A0%81%E7%9A%84mp4%E8%A7%86%E9%A2%91">前端 web 如何播放 HEVC(h265)编码的 MP4 视频</a></li><li><a href="https://segmentfault.com/a/1190000017187346">H.265/HEVC 在 Web 视频播放的实践</a><div style="background: #FFF3F3;padding:10px;border: 1px solid #DEB8BE;border-radius:5px;margin-bottom:5px;">使用该js文件，能播放他自己提供的那个文件（改不改后缀都可以）新上传的hevc编码的文件还是不能播放</div></li></ul><h3 id="【弃】easywasmplayer"><a href="#【弃】easywasmplayer" class="headerlink" title="【弃】easywasmplayer"></a>【弃】easywasmplayer</h3><p>测试地址：<a href="http://www.easydarwin.org/easywasmplayer/">http://www.easydarwin.org/easywasmplayer/</a></p><div style="background: #FFF3F3;padding:10px;border: 1px solid #DEB8BE;border-radius:5px;margin-bottom:5px;">不支持mov播放，mp4可以</div><h3 id="【取】ffmpeg-方法"><a href="#【取】ffmpeg-方法" class="headerlink" title="【取】ffmpeg 方法"></a>【取】ffmpeg 方法</h3><div style="background: #edf9e8;padding:10px;border: 1px solid #c2d2b5;border-radius:5px;margin-bottom:5px;">能否在后端利用ffmpeg将mov格式视频转换成mp4，转换之后的mp4格式是h.264编码的（目前只有部分mov格式视频是hevc编码的）</div><ul><li><a href="https://learnku.com/articles/50169">Web 端解码 H.265 视频可行性研究</a></li><li><a href="https://blog.csdn.net/qq_29931083/article/details/107758997">ffmpeg 将 mov 格式的视频转换成 mp4 格式</a></li></ul><p>PS：ffmpeg 安装方法：<br><a href="https://ffmpeg.org/download.html">https://ffmpeg.org/download.html</a><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1632896302501-77e97ee6-c0fa-444d-a9c2-a34bec0d7493.png#clientId=u90d2ab6b-4700-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=297&id=u1938d594&margin=%5Bobject%20Object%5D&name=image.png&originHeight=594&originWidth=982&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=56591&status=done&style=none&taskId=u1f4ca2be-aaed-48aa-a233-bf7dfe46cd9&title=&width=491" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1632896323573-b3da95d2-dba7-42d0-b712-b2cfb5dbf82e.png#clientId=u90d2ab6b-4700-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=182&id=ud117ee8e&margin=%5Bobject%20Object%5D&name=image.png&originHeight=364&originWidth=625&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=24353&status=done&style=none&taskId=ufb2cac14-0fe7-42cd-bcfd-37037702049&title=&width=312.5" alt="image.png"><br>添加到环境变量<br><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1641181905373-20996222-6e15-43ee-9e2f-4ca7d62da401.png#clientId=u85c1aac6-a627-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=342&id=ud78e85c0&margin=%5Bobject%20Object%5D&name=image.png&originHeight=796&originWidth=827&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=25169&status=done&style=none&taskId=u55978f1c-6103-44c7-a1a9-44f6df0068a&title=&width=355" alt="image.png"><br>检测是否安装成功<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1632896355552-9604ce17-2ff5-44dc-931e-73ebc2efede8.png#clientId=u90d2ab6b-4700-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=160&id=ubed8d8a3&margin=%5Bobject%20Object%5D&name=image.png&originHeight=320&originWidth=747&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=52326&status=done&style=none&taskId=uff1f30b7-9eb6-4f65-a8cc-4790222e5ba&title=&width=373.5" alt="image.png"><br>安装成功</p><p><strong>【ffmpeg 转 mov 为 mp4-命令】</strong></p><pre><code class="powershell">ffmpeg -i test.mov -vcodec libx264 -preset fast -crf 20 -y -acodec libmp3lame -ab 128k test.mp4</code></pre><p><strong>【前端实现】</strong><br><a href="https://download.csdn.net/download/weixin_42120997/19759493">https://download.csdn.net/download/weixin_42120997/19759493</a>【收费】<br><a href="https://blog.csdn.net/dj513dj/article/details/60961970">https://blog.csdn.net/dj513dj/article/details/60961970</a><br><a href="https://juejin.cn/post/6844903961942556685">https://juejin.cn/post/6844903961942556685</a><br><a href="https://github.com/damianociarla/node-ffmpeg">https://github.com/damianociarla/node-ffmpeg</a><br><a href="https://blog.csdn.net/dj513dj/article/details/60961970">https://blog.csdn.net/dj513dj/article/details/60961970</a><br>还是需要电脑有 ffmpeg 环境</p><p><strong>【后端实现】</strong><br><a href="https://blog.csdn.net/fareise/article/details/53188785">NodeJS 实现视频转码</a><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1632897980832-011bfd61-effc-47f9-a527-17b59644c4ae.png#clientId=u90d2ab6b-4700-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=169&id=lFosa&margin=%5Bobject%20Object%5D&name=image.png&originHeight=242&originWidth=998&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=31345&status=done&style=stroke&taskId=u02d9a503-8540-48eb-aef5-83f136f0e27&title=&width=695" alt="image.png"><br>需要服务端有 ffmpeg 环境</p>]]></content>
      
      
      <categories>
          
          <category> 👨‍💻Web开发 </category>
          
          <category> Web业务解决方案 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>师者对技术的态度</title>
      <link href="/essay/dqzalx/"/>
      <url>/essay/dqzalx/</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/1484158/1649042341317-573ef9f9-3528-4b7c-b838-21e47448200c.jpeg#clientId=u3e07869d-f645-4&crop=0&crop=0&crop=1&crop=1&from=ui&height=250&id=u0d8f20dd&margin=%5Bobject%20Object%5D&name=IMG_20201216_093418.jpg&originHeight=2736&originWidth=3648&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=1791000&status=done&style=none&taskId=u0e697ba8-26d6-4f72-ae4e-a78354c0717&title=&width=333.015625" alt="IMG_20201216_093418.jpg"></p><ul><li>C 语言老师：<code>像你们这个年龄，在古代那会儿，你们才刚刚进入仕途</code></li><li>数据结构老师：<code>将数据结构整本书上的所有算法自己实现一遍，那么代码水平就能够提升到一个不错的高度</code></li><li>JAVA 老师：<code>Ideas are cheap, show me the code</code></li><li>计算机网络老师：<code>要用工程思维去设计一个系统</code></li><li>计算方法老师：<code>计算机没有精确 只有精度</code></li></ul><p>第一个面试的 HR：<br>感受得到，她是一个资深的面试官，她问的各个问题不是很刁钻，但是很细，伴随着问答的交流，我也逐渐意识到我的不足之处（深度和广度），过程中她说了一句话，让我印象深刻：<code>现在技术这条路，不是这么好走的</code></p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>隐忍——能屈能伸</title>
      <link href="/essay/rng8r9/"/>
      <url>/essay/rng8r9/</url>
      
        <content type="html"><![CDATA[<p>这是加密文章！</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>人生独行者</title>
      <link href="/essay/fb0yri/"/>
      <url>/essay/fb0yri/</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1630812970555-a8e776cc-9769-4729-b360-2eaeb8c95afd.jpeg#clientId=ua0bd9c6e-5139-4&from=ui&id=u7c5aea52&margin=%5Bobject%20Object%5D&name=65994caa7f4b5175dec35e466f7b6dbb.jpg&originHeight=1200&originWidth=1920&originalType=binary%E2%88%B6=1&size=261711&status=done&style=none&taskId=u92c17dc9-84a8-4169-b7e6-f7591a276a9" alt="65994caa7f4b5175dec35e466f7b6dbb.jpg"></p><p><strong>无悔的独行者</strong></p><p>人生就是一个行者独自在一条大道上向前行走着，身边有许多美好，有许多遗憾，但是时间是单维度的，时间不会后退，你做过的事情，不会倒退，单一个体要对自己做过的事情无悔</p><p>路上，你遇到很多人，你又和很多人说再见，你的前方无论什么时候都是那条看不到尽头的道路，</p><p>不用去想人生的意义是什么，因为当死了的那一瞬间，了无遗憾，无悔般地笑着</p><p><strong>造物主的内壁</strong></p><p>人生的阶段就像是一个个内壁，就像是造物主让我们这么一个个生命体聚集在一起，他希望我们是规则的，所以在文明下，我们很多人都是规矩的，一样的……</p><p>文明框架下，每个人都是主角，每个人又好像都不是主角。</p><p>循环的单变量<br>读书===娶老婆===事业===生娃===读书</p><p>这个文明带给我们的就像是这样的一段代码，然而，哪有这么容易呢？然而生活还会时不时给你制造 bug，比如你学业上的困难，人总是不习惯于框架之外，但又沉溺于这个制度本身，讽刺的是，解决那些 bug 的人就是我们自己。</p><p>每个人就像是按照既定的规则去做事，不能有程序上的 bug，</p><p>反过来说，要是我们不顺应这个文明制度，这就像是出 bug 了。</p><p>“某人读书期间，不好好读书，不务正业”造物主借由“环境”这么一个事物来影响这一个个体，让其不要破坏这个社会的制度，突然有一天，那个某人终于</p><p>算法当中的贪心算法，其算法思想就是取局部最优</p><p><strong>假如明天我死了</strong></p><p>我的人生准则就是，假如我明天就死了，今天的我不会对我所做的任何事情感到后悔。</p><p>我的行为准则很简单，但是并不代表我不懂，许多所谓的道理，我又何尝不懂，只是，我不害怕这个文明，不害怕这个文明所带来的种种。</p><p>我总是在坚守那些在其他人看来特别幼稚的事情，但是我却将其看得像珍宝一样珍贵</p><p>人如果没有信仰，没有坚守，那活着又有什么意义呢？</p><p><strong>大学……</strong></p><p>大学，只是我所经历的一站，我的前方依旧在那里，看起来很近，但是却也不近，大学快结束了，我想要的是近了还是远了……</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>RSA算法应用——GPG keys</title>
      <link href="/blog/go85d1/"/>
      <url>/blog/go85d1/</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1628854019765-b6022a63-5214-4d70-98b5-aec146cf1e6b.png#crop=0&crop=0&crop=1&crop=1&height=175&id=mqoXX&margin=%5Bobject%20Object%5D&name=image.png&originHeight=350&originWidth=1048&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=48552&status=done&style=none&title=&width=524" alt="image.png"></p><p>前言：GitHub 在提交代码的时候会出现是否验证的情况，如上图所示，出现这个机制的原因就是当利用 name 和 email 提交代码时，两个不同的人都可以提交（多人协同一个项目），为了代码更加的严密与可靠，就出现了 GPG keys 加重验证这一情况。</p><p>同时之前学过 RSA 算法的原理逻辑『<a href="https://www.wztlink1013.com/blog/ccd10c/">RSA 公钥密码算法 | 尼采般地抒情</a>』，本文也算是对该算法的一次应用。</p><hr><h2 id="一、创建-gpg-密钥"><a href="#一、创建-gpg-密钥" class="headerlink" title="一、创建 gpg 密钥"></a>一、创建 gpg 密钥</h2><p>在 git Bash 里面查看 gpg 版本<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1628854562240-df76109f-807c-46ec-93cc-eeb634181583.png#crop=0&crop=0&crop=1&crop=1&height=204&id=FSA2j&margin=%5Bobject%20Object%5D&name=image.png&originHeight=407&originWidth=496&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=49848&status=done&style=none&title=&width=248" alt="image.png"></p><hr><p>生成密钥</p><pre><code class="bash">gpg --full-generate-key</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1628854642828-9298534e-2470-4440-a5d3-a0b4eebf9267.png#crop=0&crop=0&crop=1&crop=1&height=427&id=GLArL&margin=%5Bobject%20Object%5D&name=image.png&originHeight=854&originWidth=580&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=100499&status=done&style=none&title=&width=290" alt="image.png"></p><hr><p>列举已经创建好的密钥 id</p><pre><code class="bash">gpg --list-secret-keys --keyid-format LONG</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1628854721166-1a7cf63a-8053-42aa-a365-9f4accc4cb40.png#crop=0&crop=0&crop=1&crop=1&height=163&id=fBUBe&margin=%5Bobject%20Object%5D&name=image.png&originHeight=325&originWidth=492&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=38145&status=done&style=none&title=&width=246" alt="image.png"></p><div style="background: #FFFBE6;padding:10px;border: 1px solid #C3C3C3;border-radius:5px;margin-bottom:5px;">中途会弹出要设置密码，并且是两次弹出。</div><hr><p>查看密钥内容</p><pre><code class="bash">gpg --armor --export 10A9巴拉巴拉</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1628854842847-28c1fb0a-ac3d-446b-b479-4c34a9d89d0d.png#crop=0&crop=0&crop=1&crop=1&height=196&id=jQgdw&margin=%5Bobject%20Object%5D&name=image.png&originHeight=392&originWidth=470&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=64357&status=done&style=none&title=&width=235" alt="image.png"></p><h2 id="二、添加-gpg-密钥"><a href="#二、添加-gpg-密钥" class="headerlink" title="二、添加 gpg 密钥"></a>二、添加 gpg 密钥</h2><p>将上述控制台的密钥内容复制到 GitHub 的一下区域<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1628854955321-8c0648b4-2ed8-472a-b9a9-58638bf12b61.png#crop=0&crop=0&crop=1&crop=1&height=368&id=al61T&margin=%5Bobject%20Object%5D&name=image.png&originHeight=735&originWidth=1675&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=84347&status=done&style=stroke&title=&width=837.5" alt="image.png"></p><hr><p>以下就是公钥和密钥内容<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1628856682736-35e744c2-8f28-425f-8a4c-fe9236cd8616.png#crop=0&crop=0&crop=1&crop=1&height=197&id=naOHh&margin=%5Bobject%20Object%5D&name=image.png&originHeight=393&originWidth=1173&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=44465&status=done&style=none&title=&width=586.5" alt="image.png"></p><h2 id="三、本地设置-gpg-密钥"><a href="#三、本地设置-gpg-密钥" class="headerlink" title="三、本地设置 gpg 密钥"></a>三、本地设置 gpg 密钥</h2><p>将 gpg 密钥添加到本地设置中</p><pre><code class="bash">git config --global user.signingkey 10A9巴拉巴拉</code></pre><p>在所有项目中设置签名验证</p><pre><code class="bash">git config --global commit.gpgsign true</code></pre><h2 id="四、使用"><a href="#四、使用" class="headerlink" title="四、使用"></a>四、使用</h2><p>在提交代码的时候，会弹出该提示框，这就是在设置密码时候的密码（密钥）。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1628855341009-92cccb8c-0007-4361-8d42-778002d554e8.png#crop=0&crop=0&crop=1&crop=1&height=208&id=dLIY1&margin=%5Bobject%20Object%5D&name=image.png&originHeight=415&originWidth=691&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=37244&status=done&style=none&title=&width=345.5" alt="image.png"></p><p>参考：</p><ul><li><a href="https://www.ruanyifeng.com/blog/2013/07/gpg.html">https://www.ruanyifeng.com/blog/2013/07/gpg.html</a></li><li><a href="https://www.jianshu.com/p/195cac3a2b2c">https://www.jianshu.com/p/195cac3a2b2c</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> RSA算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>『花束般的恋爱』——“我认识了一个和我想法一样的人”</title>
      <link href="/essay/qraopm/"/>
      <url>/essay/qraopm/</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1627879984472-b6f94d18-7055-4be5-9cb6-8a550e5342d3.png#height=1027&id=udf56b2ff&margin=%5Bobject%20Object%5D&name=Snipaste_2021-08-02_12-50-36.png&originHeight=1027&originWidth=1911&originalType=binary%E2%88%B6=1&size=1904737&status=done&style=none&width=1911" alt="Snipaste_2021-08-02_12-50-36.png"></p><p>看完之后的感受：<strong>始于心动，败于现实</strong>。</p><p>恋爱不是婚姻，因为中间有现实，但现实只是一个因素，在这个因素下，有的人忘却了曾经想要守护的，有的人想守住曾经，有的人幡然悔悟，有的人却早已失望并且走远……</p><p>这可能就是爱情和婚姻的不同吧。我也很幼稚，但是我想试试几年之后的我再看这篇文章会是什么感悟……</p><hr><h2 id="“我认识了一个和我想法一样的人”"><a href="#“我认识了一个和我想法一样的人”" class="headerlink" title="“我认识了一个和我想法一样的人”"></a>“我认识了一个和我想法一样的人”</h2><p>这就是相同的灵魂的碰撞，我相信巧合，真的相信。交谈有无数种，但是那种契合灵魂的交谈真的只有那个对的人才会有。</p><p>“我们好像，你就像是另一个世界的我一样”，就是那种你不用多言，也能感受到对方将要表达出来的感受。那绝对是亲身经历才能长存心间的事情。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1627880340235-0ee52649-ef7e-4a7b-94b4-81ca645fd24c.png#height=540&id=uc6f2af4b&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1080&originWidth=1920&originalType=binary%E2%88%B6=1&size=3361014&status=done&style=none&width=960" alt="image.png"></p><h2 id="爱情中的智者？"><a href="#爱情中的智者？" class="headerlink" title="爱情中的智者？"></a>爱情中的智者？</h2><p>生活中总会有人去告诉你一些道理，像是扮演者一个智者的角色。片中爱情博客博主芽衣就是这么一个角色。</p><blockquote><p>相遇总是伴随着离别<br>恋爱就像派对 总有一天会结束<br>所以恋爱的人<br>总是喜欢将迷恋的东西夹在书桌里<br>再分享他们的爱情<br>因为他们只能享受这份悲伤<br>虽然爱情的存存活率极小<br>但我的爱情会活下来</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1627881603601-6bb986d5-c12b-4710-8a56-cbefe8667501.png#height=540&id=u4405a4e6&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1080&originWidth=1920&originalType=binary%E2%88%B6=1&size=2396626&status=done&style=none&width=960" alt="image.png"></p><blockquote><p>芽衣算是看到爱情的死亡吗？<br>她顺应了爱情的结束吗？<br>我只能去想象<br>而且也不打算 把它套用在自己的爱情上面<br>只是 我们的派对<br>现在正在高潮部分</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1627881791016-85d417b3-119a-4c33-8e0f-927071017501.png#height=540&id=u9d16aabc&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1080&originWidth=1920&originalType=binary%E2%88%B6=1&size=2337692&status=done&style=none&width=960" alt="image.png"></p><h2 id="现实会让你忘掉恋爱中最初的自己吗？"><a href="#现实会让你忘掉恋爱中最初的自己吗？" class="headerlink" title="现实会让你忘掉恋爱中最初的自己吗？"></a>现实会让你忘掉恋爱中最初的自己吗？</h2><p>我不知道，我没能看得见未来那个阶段的自己。</p><p>女主工作初期的失意，以及男主工作中的起势和落魄，这可能就是常人说的现实把。现实让两个人褪去了太多色彩，但是一直坚守的是女主，同样是落魄，男主的陪伴和女主的陪伴换来的结果全然不样，没有好好珍惜把。</p><p>人会变，也没有谁能够一直陪着谁。</p><p>人都是个体……</p><h2 id="感性-VS-理性"><a href="#感性-VS-理性" class="headerlink" title="感性 VS 理性"></a>感性 VS 理性</h2><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1627883190252-ec419a89-4711-4126-aa45-5bf708930312.png#height=540&id=uca4b5a69&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1080&originWidth=1920&originalType=binary%E2%88%B6=1&size=3842988&status=done&style=none&width=960" alt="image.png"></p><div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">男主和女主最后的那段话，这段对话算是完完全全交代了两个人的终点。</div><blockquote><p>谢谢你</p></blockquote><blockquote><p>小娟<br>我不想分手<br>我觉得不用分手<br>我们结婚吧<br>结婚后<br>和以前一样<br>一起过日子吧<br>没关系的</p></blockquote><blockquote><p>因为今天很开心所以你才会这么想<br>我们又会回到以前那样</p></blockquote><blockquote><p>我觉得没什么不好<br>这世上结婚的夫妻<br>大家不都是如此吗<br>都会慢慢忘记恋爱的感觉<br>不是也有结婚之后 继续这样过日子的人吗<br>就算感情变了<br>不开心的事 就睁一只眼闭一只眼<br>继续过日子 有这样的人的<br>我和你</p></blockquote><blockquote><p>又要降低标准吗<br>降低标准<br>然后想 就这样过吧<br>这样你就满意吗</p></blockquote><blockquote><p>满意<br>不可能像以前一样喜欢啊<br>如果追求这种事就无法幸福了<br>会不停地吵架<br>不也是因为恋爱的感觉在捣乱吗<br>现在成为一家人的话<br>我觉得能和你过好<br>生个孩子 孩子管我叫爸爸 管你叫妈妈<br>我都能想象到那一幕<br>三个人或者四个人手牵着手一起去多摩川边散步吧<br>推着婴儿车一起去逛高岛屋吧<br>买一辆车<br>去野营 去迪士尼乐园<br>花时间 一起过完这辈子<br>他们俩虽然一起经历了很多事情<br>但现在变成了一堆关系很好的夫妻<br>你中有我 我中有你<br>我们变成这样的关系吧<br>结婚吧 一起变幸福吧</p></blockquote><blockquote><p>你说的可能没错<br>是啊<br>如果我们结婚了<br>成为了家人</p></blockquote><p>没有结局了……</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1627883840887-418d2c4a-2209-4fec-b839-7f85c8bacb17.png#height=540&id=dQsNl&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1080&originWidth=1920&originalType=binary%E2%88%B6=1&size=3111715&status=done&style=none&width=960" alt="image.png"></p><div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">始于心动，败于现实，这是我所能想到的，两人的爱情被磨没了，而这之中，对现实的无能为力才是罪魁祸首……</div>]]></content>
      
      
      <categories>
          
          <category> 影视 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>『士兵突击』</title>
      <link href="/essay/qd0o6r/"/>
      <url>/essay/qd0o6r/</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.nlark.com/yuque/0/2021/webp/1484158/1627457976739-9801a315-02f3-4f5f-b590-6b2a532749a7.webp#align=left&display=inline&height=360&id=udb87ee1e&margin=%5Bobject%20Object%5D&originHeight=360&originWidth=270&status=done&style=none&width=270"></p><p>前言：人生导师级别的一部军旅影视，看完电视剧变买了这本小说一边看完。</p><h2 id="小说"><a href="#小说" class="headerlink" title="小说"></a>小说</h2><p>第二章</p><p>史今班长的温柔和同情，对他而言，像是看到曾经刚入部队的自己，以至于做出绝不可能而又做出的感性的选择……</p><p>以前在初中，是住校的，那时我班上也有一个和许三多一样的同学，我甚至还记得他叫什么，他叫程伊星，他就是看起来傻傻的，也比我们大一两岁，行为举动像是小孩子，也不谙世事，总是成为同学之间玩乐嬉戏的对象。</p><p>记得有一次夏季的体育课，我回宿舍，看见他躺在床上整理被子（他是作息及其规律，内务极其规整的一个学生），那时我们聊了会天，我觉得我以前初中和谁都能说得出心里话的那种，当时好像是问他为什么不和我们一起玩，忘了他是怎么回答的，只记得他说了一番话，具体也记不清，但是说出的话就像是滑稽的哲理一般，就像是背诵了书里面的词句一样的人生态度。他收拾完之后，他就习惯性地坐在床上，跟我聊天，多的记不清了，我只知道他是一个读书人，但就像是尚未入世一样……</p><p>如今在键盘上敲字的我苦笑，敲到<strong>入世</strong>两个字，我也看到了自己的些许狼狈，我不知道什么是成长，但我真的也从家乡那个小城走出来，过往的经历就像是坚毅面庞背后的幸酸，<strong>可这个社会制度下，这个文明框架下，不就是充斥着过多的悲哀么，而我们大多数人都是向着死而生</strong>。</p><hr><h2 id="影视"><a href="#影视" class="headerlink" title="影视"></a>影视</h2><hr><p>10 集</p><p>战友的帮助成就了一个兵，班长的“牺牲”造就了一个兵王。<br>这是部队里面才有的。</p><p>这就像是，重情义的往往是那些曾经成绩不好的后排生，但是会为了彼此扛刀的同学。<br>懂“不抛弃不放弃”远远比成为兵王更重要，真的。</p><p>成才最后被老 A 刷下的那般落魄，真的是曾经没有领悟那六个字所造成的结果。</p><p>人做事真的不要太急了，踏实，稳固，远比结果更重要，并且到最后，你还会发现，人如果走的踏实，结果都不会太差的。</p><hr><p>16 集</p><blockquote><p>早熟的人往往都很晚熟<br>骄傲的人又很急性</p></blockquote><hr><p>17 集</p><p><strong>三多的士官和复员决定与否之路</strong></p><p>高城走了之后，七连只剩下许三多一个兵<br>一个兵守一个连……<br>就是这样，这种历练是何等的孤独，兵王就是兵王，耐得住寂寞。一个人唱战歌，一个人守住仪式，一个人过一整个夜晚，一个人面对整个连的回忆。</p><p>难，真的难。这种人真的厉害</p><p>一个月和别人说话不超过十句话，其他的都是自己和自己说话。</p><p>伍六一在这个时候其实是最担心三多的。</p><hr><p>18 集</p><p>袁朗第一次去找许三多对他的评价：</p><blockquote><p><strong>怎么样 一个人在这守了半年</strong> &gt; <strong>不好不坏 不高不低的一个兵</strong> &gt; <strong>一个很安分的兵</strong> &gt; <strong>不太焦虑 耐得住寂寞</strong> &gt; <strong>有很多人天天都在焦虑</strong> &gt; <strong>怕没得到 怕寂寞</strong> &gt; <strong>我喜欢不焦虑的人</strong></p></blockquote><blockquote><p>我，其实我骨子里 骨子里可笨了<br>每一次换一次新的环境<br>我就跟死过一次似的<br>你一个人呆在这是怕鬼把？<br>这世界上根本就没有鬼<br>那就奇怪了<br><strong>鬼和你怕的事情不都是想出来的自己吓唬自己的吗</strong></p></blockquote><hr><p>19 集</p><p>参加老 A 集训，成才，伍六一，许三多，甘小宁……</p><p>伍六一里面对</p><hr><p>20 集</p><p>人不是靠做出来的，而是靠活出来的<br>就像你，不仅守住了军营，还守住了你自己</p><hr><p>五班</p><p>五班是许三多和成才都经历过的一个地方，这部剧里面有太多的亮点，但我印象最深最深的就是五班，一望无际的草原，有人觉得是束缚，又有人觉得是天堂，环境足以磨灭一个人的信仰，经得起磨练的人才真的是人才。</p><p>成才两次去过五班，第一次是部队整编自己去的五班，第二次是被老 A 打回五班</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1628321067461-42092030-1b62-4a01-9ca6-f36195ef3a22.png#align=left&display=inline&height=381&id=u4771e254&margin=%5Bobject%20Object%5D&name=image.png&originHeight=762&originWidth=1473&size=1207500&status=done&style=none&width=736.5" alt="image.png"><br>最后的五班，是由成才炼好的！</p><hr><p>七连</p><p>在这里面真的学会很多，比技术和荣誉更重要的是——“不抛弃，不放弃”的人生信念。<br>其实你会发现在七连不是所有人都是厉害的，但是他们都是最“靠谱”的，最敢拼的，集体荣誉感极强。还没有成长的成才和许三多在这里面就是两个极端，一个能力极强，但功利心极强，一个能力太低，不谙世事。<br>就是两个这样的人最后都是兵王，能力强和弱的两个极端，在他们两个人成为一个人才的时间，我个人觉得是对那六个字的理解。</p>]]></content>
      
      
      <categories>
          
          <category> 影视 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>菜鸡重学i++和++i</title>
      <link href="/blog/smpdcq/"/>
      <url>/blog/smpdcq/</url>
      
        <content type="html"><![CDATA[<p>前言：for 循环里面的 i++和++i 在平时使用感觉是几乎一样的，但是之前写代码，特别是数据结构课程学链表那会，经常需要做的就是一个节点的 next 指向什么才结束这样一种情况，当时总是不自觉地将 i++调整为++i 就能运行成功，这个点比较模糊，查资料才发现存在<strong>只有++i 可以返回左值</strong>这一情况。</p><hr><p>先来一段常规使用：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1627270650151-857f8953-7e79-4055-a838-2b26b96aaf0a.png#height=161&id=sNaU2&margin=%5Bobject%20Object%5D&name=image.png&originHeight=321&originWidth=1045&originalType=binary%E2%88%B6=1&size=67531&status=done&style=none&width=522.5" alt="image.png"><br>这个没有相关的差别</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1627271346217-4ae80a1d-979b-42cd-b6ff-8fdc271926ab.png#height=108&id=kmxHY&margin=%5Bobject%20Object%5D&name=image.png&originHeight=215&originWidth=1089&originalType=binary%E2%88%B6=1&size=27454&status=done&style=none&width=544.5" alt="image.png"><br>一个返回+之前的值一个返回+之后的值，也是字面理解。</p><blockquote><p>左值：在内存存储空间里面有确定的存储地址的值。<br>判断是否为左值：看是否允许取地址&amp;运算符获得对应的内存地址。</p></blockquote><p><strong>++i 可以返回左值，i++不可以。</strong>（下面的截图对 i++报错，对++i 没有报错）<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1627437597153-a59bb261-e406-46f3-8bbb-34af9278b55d.png#height=201&id=Kc6Sg&margin=%5Bobject%20Object%5D&name=image.png&originHeight=402&originWidth=1522&originalType=binary%E2%88%B6=1&size=103726&status=done&style=none&width=761" alt="image.png"></p><p>i++和++i 的实现：</p><pre><code class="cpp">// 前缀形式：++iint&amp; int::operator++() //这里返回的是一个引用形式，就是说函数返回值也可以作为一个左值使用&#123;//函数本身无参，意味着是在自身空间内增加1的  *this += 1;  // 增加  return *this;  // 取回值&#125;//后缀形式：i++const int int::operator++(int) //函数返回值是一个非左值型的，与前缀形式的差别所在。&#123;//函数带参，说明有另外的空间开辟  int oldValue = *this;  // 取回值  ++(*this);  // 增加  return oldValue;  // 返回被取回的值&#125;</code></pre><p>从这个代码也可以看出++i 的效率是优于 i++的，尽管很微弱。</p><div style="background: #FFF3F3;padding:10px;border: 1px solid #DEB8BE;border-radius:5px;margin-bottom:5px;">大多数编译器已经对这两种使用方式封装，使其普通使用的效果几乎一致。</div><div style="background: #edf9e8;padding:10px;border: 1px solid #c2d2b5;border-radius:5px;margin-bottom:5px;">今后尽量使用++i，特别是C++写题的时候。</div><p>参考链接：</p><ul><li><a href="https://www.zhihu.com/question/19811087">在程序开发中，++i 与 i++的区别在哪里？</a></li><li><a href="https://blog.csdn.net/zlhy_/article/details/8349300">为什么(i++)不能做左值，而(++i)可以</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 非前端编程语言 </category>
          
          <category> CPlusPlus </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>终端环境配置</title>
      <link href="/blog/pa6aqc/"/>
      <url>/blog/pa6aqc/</url>
      
        <content type="html"><![CDATA[<p>教程：<a href="https://github.com/jlevy/the-art-of-command-line/blob/master/README-zh.md">命令行的艺术</a>（the-art-of-command-line）</p><h2 id="scoop-下载"><a href="#scoop-下载" class="headerlink" title="scoop 下载"></a>scoop 下载</h2><p><a href="https://scoop.sh/">https://scoop.sh/</a></p><pre><code class="powershell"># 在 PowerShell 中输入下面内容，保证允许本地脚本的执行：set-executionpolicy remotesigned -scope currentuser</code></pre><pre><code class="powershell"># 然后执行下面的命令安装 Scoop：iex (new-object net.webclient).downloadstring(&#39;https://get.scoop.sh&#39;)</code></pre><pre><code class="powershell"># 静待脚本执行完成就可以了，安装成功后，让我们尝试一下：scoop help</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1639189556041-8c5d7b31-190e-463a-8ded-64ae19bc60d7.png#clientId=ucaad0713-bcb5-4&from=paste&height=422&id=u42c137bf&margin=%5Bobject%20Object%5D&name=image.png&originHeight=844&originWidth=1894&originalType=binary%E2%88%B6=1&size=114880&status=done&style=none&taskId=uf29f6943-5eb1-4a7a-80ce-4254b682189&width=947" alt="image.png"></p><h2 id="lazygit"><a href="#lazygit" class="headerlink" title="lazygit"></a>lazygit</h2><p><a href="https://github.com/jesseduffield/lazygit">https://github.com/jesseduffield/lazygit</a></p><p>Add the extras bucket</p><pre><code class="powershell">scoop bucket add extras</code></pre><p>Install lazygit</p><pre><code class="powershell">scoop install lazygit</code></pre><p>然后进入一个 git 文件夹用终端打开输入 <code>lazygit</code> 即可</p><h2 id="Windows-Terminal"><a href="#Windows-Terminal" class="headerlink" title="Windows Terminal"></a>Windows Terminal</h2><ul><li>官方教程：<a href="https://docs.microsoft.com/zh-cn/windows/terminal/">https://docs.microsoft.com/zh-cn/windows/terminal/</a></li></ul><p>按照此教程可以 DIY 如下：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1639822798943-6d29922d-cfe5-4101-bac7-3f94650392f3.png#clientId=u9ca9c86f-1dbe-4&from=paste&height=311&id=u86db2961&margin=%5Bobject%20Object%5D&name=image.png&originHeight=881&originWidth=706&originalType=binary%E2%88%B6=1&size=63201&status=done&style=none&taskId=u354b1bee-8c35-4e18-ba58-c72b3e24650&width=249" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1639822897499-1230f2d1-791d-4e59-ac32-06c718f71ac6.png#clientId=u9ca9c86f-1dbe-4&from=paste&height=263&id=u35f1ca4e&margin=%5Bobject%20Object%5D&name=image.png&originHeight=525&originWidth=704&originalType=binary%E2%88%B6=1&size=36173&status=done&style=none&taskId=ubaca36c9-312c-45ca-89ad-d55dacebd84&width=352" alt="image.png"></p><h2 id="oh-my-posh"><a href="#oh-my-posh" class="headerlink" title="oh-my-posh"></a>oh-my-posh</h2><p><a href="https://ohmyposh.dev/docs/windows">https://ohmyposh.dev/docs/windows</a></p><pre><code class="powershell">Install-Module posh-git -Scope CurrentUserInstall-Module oh-my-posh -Scope CurrentUser</code></pre><p><a href="https://blog.csdn.net/weixin_44490152/article/details/113854767">https://blog.csdn.net/weixin_44490152/article/details/113854767</a><br>安装字体<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1639190934169-c1b6e5bc-e0f9-4b34-bdf6-113ba4c3c8f6.png#clientId=ucaad0713-bcb5-4&from=paste&height=440&id=u81c84ea1&margin=%5Bobject%20Object%5D&name=image.png&originHeight=880&originWidth=1806&originalType=binary%E2%88%B6=1&size=377775&status=done&style=none&taskId=ud387ed12-5ac5-4ca7-af05-b74906d409a&width=903" alt="image.png"></p><p>参考：<a href="https://zhuanlan.zhihu.com/p/163007658">https://zhuanlan.zhihu.com/p/163007658</a></p>]]></content>
      
      
      <categories>
          
          <category> 🔨环境工具 </category>
          
          <category> 环境搭建 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>『大老师+路哥+师傅+折棒』</title>
      <link href="/essay/mll6d7/"/>
      <url>/essay/mll6d7/</url>
      
        <content type="html"><![CDATA[<p>这是加密文章！</p>]]></content>
      
      
      <categories>
          
          <category> 影视 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>《狼图腾》</title>
      <link href="/essay/gla4ug/"/>
      <url>/essay/gla4ug/</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1626253972954-cf013c98-7c95-4e4c-92d0-e58722469a3b.png#align=left&display=inline&height=381&id=uc7dc0cca&margin=%5Bobject%20Object%5D&name=image.png&originHeight=381&originWidth=260&size=90043&status=done&style=none&width=260" alt="image.png"></p><p>前言：在那蒙古草原上，有一种被崇敬的事物，那就是狼图腾。</p><hr><p>1</p><p>狼群是一个有组织的群体，进攻、放哨兵、撤退，都会按照既定的队形实施。</p><hr><p>2</p><p>黄羊和狼的互相存在就是草原上的生存法则</p><blockquote><p>“老人说：我也打狼，可不能多打。要是把狼打绝了，草原就活不成。草原死了，人畜还能活吗？”</p></blockquote><p>“红卫兵”“知青”“学生”……<br>在那种蛮荒时代里，步入殷实温暖的蒙古包，其实倒也是不错的经历，简单纯粹。</p><blockquote><p>“你们汉人胆子太小，像吃草的羊，我们蒙古人是吃肉的狼，你是该有点狼胆了。”</p></blockquote><p>狼是草原的守护神，腾格里（信奉的神）护着狼。<br>人的内心深处亦或者说人类最原始角色就有一种猎性，只是从一开始作为农耕民族，早已被“便捷”所“进化”地向绵羊一般，不再有猎性，不再是猎人……可能这就是一种我们常说的血性。</p><blockquote><p>老人说：“光靠狼的狠劲还不行，还得靠狼的耐性”（智慧、耐性、组织性、纪律性）</p></blockquote><p>草原上的蒙古人更为精明，作为狼的徒弟，青出于蓝而胜于蓝。</p><hr><p>3</p><p>古老的草原逻辑解释了食肉名族和食草民族几千年来的争斗的根本</p><blockquote><p>草原名族捍卫的是“大命”——草原和自然的命比人命更宝贵；<br>而农耕名族捍卫的是“小命”——天下最宝贵的是人命和活命。<br>可是大命没了小命全都没命。</p></blockquote><hr><p>4</p><p>对狼的敬畏</p><blockquote><p>在草原不吃食物，就不能算是真正的草原蒙古人。</p></blockquote><p>狼死了，狼的灵魂也会飞回腾格里那儿去的。<br>什么才叫真正的崇敬，对于蒙古民族，崇敬狼图腾，在一个人生命的终点，将躯体当成裸露坦荡的祭祀供品，从而把自己解脱的如此彻底。</p><hr><p>5</p><p>巴图带领上等军马出去被狼群袭击。<br>丧崽哭嚎的母狼加入狼群，会格外地疯狂残忍<br>疯狼不能打，越打越凶，越杀越疯，疯狼的报复心草原上无人不怕<br>对狼来说，狼牙就是狼命。狼没了牙，狼就没了天</p><blockquote><p>狼的最凶狠锐利的武器就是它的上下四根狼牙，如果没有狼牙，狼所有的勇敢、强悍、狡猾、凶残、贪婪、狂妄、野心、雄心、耐性、机敏、警觉、体力、耐力、等等一切的品性、个性和物性，统统等于零。</p></blockquote><hr><p>6</p>]]></content>
      
      
      <categories>
          
          <category> 阅读 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>各类查找算法汇总</title>
      <link href="/blog/umxpln/"/>
      <url>/blog/umxpln/</url>
      
        <content type="html"><![CDATA[<p>这是加密文章！</p>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 📊查找排序算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数字电路总结</title>
      <link href="/blog/tn3fhp/"/>
      <url>/blog/tn3fhp/</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1627439456204-1f0fe7c2-b603-476f-93ee-d3705839148c.png#clientId=u4dcd2c14-8dea-4&from=paste&id=u0286b041&margin=%5Bobject%20Object%5D&name=image.png&originHeight=499&originWidth=354&originalType=url%E2%88%B6=1&size=241164&status=done&style=none&taskId=u2e18af5b-291c-42dd-b9b2-db10c36ce6e" alt="image.png"></p><div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">前言：利用猴博士视频总结的题型对整个数字电路做出复习。</div><h2 id="一、进制及其转换"><a href="#一、进制及其转换" class="headerlink" title="一、进制及其转换"></a>一、进制及其转换</h2><ul><li>二进制：B</li><li>十进制：D</li><li>八进制：O</li><li>十六进制：H</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1624499655205-1611e06a-b4bf-49c1-9890-5fe12bbfc2bc.png#clientId=u5a7b053a-bdc9-4&from=paste&height=101&id=u30777ccf&margin=%5Bobject%20Object%5D&name=image.png&originHeight=202&originWidth=1001&originalType=binary%E2%88%B6=2&size=397258&status=done&style=none&taskId=uc0ddb5aa-22ed-4055-89d8-0a374154a3f&width=500.5" alt="image.png"></p><h2 id="二、逻辑门电路"><a href="#二、逻辑门电路" class="headerlink" title="二、逻辑门电路"></a>二、逻辑门电路</h2><h3 id="给出逻辑图、输入，求输出"><a href="#给出逻辑图、输入，求输出" class="headerlink" title="给出逻辑图、输入，求输出"></a>给出逻辑图、输入，求输出</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1624458112503-bd20e917-0fbd-4ab0-9ff4-b4ccd9865fc4.png#clientId=ubf956e02-31c4-4&from=paste&height=159&id=u108d5323&margin=%5Bobject%20Object%5D&name=image.png&originHeight=318&originWidth=1109&originalType=binary%E2%88%B6=2&size=711453&status=done&style=none&taskId=u845e2cab-302f-4d96-bdb0-a6e70e71ad3&width=554.5" alt="image.png"></p><h3 id="给出逻辑图，写表达式"><a href="#给出逻辑图，写表达式" class="headerlink" title="给出逻辑图，写表达式"></a>给出逻辑图，写表达式</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1624458199919-649be4e4-ce94-4902-9c69-5595aff00f9e.png#clientId=ubf956e02-31c4-4&from=paste&height=209&id=ude5115ed&margin=%5Bobject%20Object%5D&name=image.png&originHeight=418&originWidth=1114&originalType=binary%E2%88%B6=2&size=570857&status=done&style=none&taskId=u73d32d6d-6d5d-407b-b9da-11feafc1a56&width=557" alt="image.png"></p><h3 id="给出表达式，画逻辑图"><a href="#给出表达式，画逻辑图" class="headerlink" title="给出表达式，画逻辑图"></a>给出表达式，画逻辑图</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1624458182439-0e80d369-7d17-453d-b7e6-d30e6e046598.png#clientId=ubf956e02-31c4-4&from=paste&height=306&id=u34ba51a5&margin=%5Bobject%20Object%5D&name=image.png&originHeight=611&originWidth=975&originalType=binary%E2%88%B6=2&size=831646&status=done&style=none&taskId=ue2df85d2-aaba-4ea7-b137-274ef9fa9f9&width=487.5" alt="image.png"></p><h2 id="三、化简逻辑函数表达式"><a href="#三、化简逻辑函数表达式" class="headerlink" title="三、化简逻辑函数表达式"></a>三、化简逻辑函数表达式</h2><h3 id="公式法化简"><a href="#公式法化简" class="headerlink" title="公式法化简"></a>公式法化简</h3><p>拍照那个笔记</p><h3 id="卡诺图法化简"><a href="#卡诺图法化简" class="headerlink" title="卡诺图法化简"></a>卡诺图法化简</h3><p>要求：</p><ol><li>卡诺图表示成逻辑函数表达式</li><li>逻辑函数表达式表示成卡诺图</li><li>化简逻辑函数表达式<ol><li>没有约束</li><li>有约束</li></ol></li></ol><p>注意以下几点：</p><ul><li>能圈多的就圈多的</li><li>约束项<em>能用就用，用的时候就为 1，不用的时候就为 0，不需要一定将其应用，</em>只是服务于 1 的</li></ul><h3 id="求反函数"><a href="#求反函数" class="headerlink" title="求反函数"></a>求反函数</h3><p>根据逻辑函数表达式求反函数</p><blockquote><ul><li>把所有的“与”“或”互换</li><li>把所有的 0、1 互换</li><li>原变量和反变量互换</li><li>多个变量的公共非不变</li><li>原始运算的优先顺序不变</li></ul></blockquote><p>根据卡诺图求反函数</p><blockquote><ul><li>把图中的 0、1 互换</li><li>信徒写出来即可</li></ul></blockquote><h2 id="四、组合逻辑电路的分析与设计"><a href="#四、组合逻辑电路的分析与设计" class="headerlink" title="四、组合逻辑电路的分析与设计"></a>四、组合逻辑电路的分析与设计</h2><h3 id="给出逻辑电路图，分析逻辑功能"><a href="#给出逻辑电路图，分析逻辑功能" class="headerlink" title="给出逻辑电路图，分析逻辑功能"></a>给出逻辑电路图，分析逻辑功能</h3><ul><li>逻辑电路图写出函数表达式</li><li>化简函数表达式（符合要求的）</li><li>列出所有情况</li><li>分析出功能<blockquote><p>常见的功能有：不一致电路、一致电路、少数服从多数电路</p></blockquote></li></ul><h3 id="给出逻辑功能，画出逻辑电路图"><a href="#给出逻辑功能，画出逻辑电路图" class="headerlink" title="给出逻辑功能，画出逻辑电路图"></a>给出逻辑功能，画出逻辑电路图</h3><p>和上面的步骤差不多，</p><ul><li>确定输入个数，定义 0、1</li><li>列真值表</li><li>写出逻辑函数表达式</li><li>化简</li><li>画出电路图</li></ul><h2 id="五、最小项"><a href="#五、最小项" class="headerlink" title="五、最小项"></a>五、最小项</h2><h3 id="卡诺图求最小项"><a href="#卡诺图求最小项" class="headerlink" title="卡诺图求最小项"></a>卡诺图求最小项</h3><ul><li>把逻辑函数表达式转换为卡诺图</li><li>卡诺图里面为 1 的就是该位置二进制存在的最小项</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1624457764328-fc869be5-3d63-4499-9a9a-6e82ca2601fe.png#clientId=ubf956e02-31c4-4&from=paste&height=298&id=u2aba1ab9&margin=%5Bobject%20Object%5D&name=image.png&originHeight=595&originWidth=1234&originalType=binary%E2%88%B6=2&size=1302276&status=done&style=none&taskId=u92abcf46-4e5f-4999-9826-67877a63265&width=617" alt="image.png"></p><h3 id="公式法求最小项"><a href="#公式法求最小项" class="headerlink" title="公式法求最小项"></a>公式法求最小项</h3><p>就是通俗的化简，不过结果的每一项都必须包含每个字母，最后用二进制表示<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1624457888889-57837834-3e20-4a68-93f2-94a5d9cf0482.png#clientId=ubf956e02-31c4-4&from=paste&height=183&id=u17d70b37&margin=%5Bobject%20Object%5D&name=image.png&originHeight=366&originWidth=749&originalType=binary%E2%88%B6=2&size=520278&status=done&style=none&taskId=ua7c7dbfb-1689-4d0e-8956-ff17883db0c&width=374.5" alt="image.png"></p><h3 id="最小项化成变量形式"><a href="#最小项化成变量形式" class="headerlink" title="最小项化成变量形式"></a>最小项化成变量形式</h3><p>将其下标化成二进制，然后转换<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1624457989908-8eeaae47-38c1-440b-a1b6-aacda1358653.png#clientId=ubf956e02-31c4-4&from=paste&height=266&id=u744474eb&margin=%5Bobject%20Object%5D&name=image.png&originHeight=531&originWidth=966&originalType=binary%E2%88%B6=2&size=892119&status=done&style=none&taskId=u447b0240-b213-43f4-9969-46a84d86d6d&width=483" alt="image.png"></p><h3 id="卡诺图化简有约束条件的"><a href="#卡诺图化简有约束条件的" class="headerlink" title="卡诺图化简有约束条件的"></a>卡诺图化简有约束条件的</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1624458044603-7393051c-fa08-444d-8890-d510b20f259a.png#clientId=ubf956e02-31c4-4&from=paste&height=249&id=ud5764522&margin=%5Bobject%20Object%5D&name=image.png&originHeight=497&originWidth=999&originalType=binary%E2%88%B6=2&size=859380&status=done&style=none&taskId=u63b1e123-0de6-4882-bde2-ba6786e58db&width=499.5" alt="image.png"></p><h2 id="六、常用的集成器件"><a href="#六、常用的集成器件" class="headerlink" title="六、常用的集成器件"></a>六、常用的集成器件</h2><h3 id="译码器和门电路实现逻辑函数"><a href="#译码器和门电路实现逻辑函数" class="headerlink" title="译码器和门电路实现逻辑函数"></a>译码器和门电路实现逻辑函数</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1624495725174-7d84b3db-0535-4e9c-8445-eca05056e43e.png#clientId=u5a7b053a-bdc9-4&from=paste&height=268&id=u6d89f5d1&margin=%5Bobject%20Object%5D&name=image.png&originHeight=535&originWidth=1007&originalType=binary%E2%88%B6=2&size=946172&status=done&style=none&taskId=u2ffffd90-2f66-43c8-a2a8-62a5e8e4476&width=503.5" alt="image.png"></p><h3 id="译码器接线图写出逻辑函数"><a href="#译码器接线图写出逻辑函数" class="headerlink" title="译码器接线图写出逻辑函数"></a>译码器接线图写出逻辑函数</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1624495940765-119658e7-e960-4fc3-83a7-634fdc6dc8dd.png#clientId=u5a7b053a-bdc9-4&from=paste&height=254&id=u076f4229&margin=%5Bobject%20Object%5D&name=image.png&originHeight=508&originWidth=982&originalType=binary%E2%88%B6=2&size=886777&status=done&style=none&taskId=u54645bde-fb16-4769-9ba3-c2a70ce059a&width=491" alt="image.png"></p><h3 id="8-选-1-数据选择器实现-3-输入逻辑函数"><a href="#8-选-1-数据选择器实现-3-输入逻辑函数" class="headerlink" title="8 选 1 数据选择器实现 3 输入逻辑函数"></a>8 选 1 数据选择器实现 3 输入逻辑函数</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1624496141542-776d204b-0332-4dad-acc1-c75ac793c2b7.png#clientId=u5a7b053a-bdc9-4&from=paste&height=236&id=u3f7c15b1&margin=%5Bobject%20Object%5D&name=image.png&originHeight=471&originWidth=1009&originalType=binary%E2%88%B6=2&size=929879&status=done&style=none&taskId=uae4e98db-29e5-4945-9880-f784c6adce1&width=504.5" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1624496797353-52c90305-9a96-4b48-9e94-d4ef979229e1.png#clientId=u5a7b053a-bdc9-4&from=paste&height=243&id=u693c19a9&margin=%5Bobject%20Object%5D&name=image.png&originHeight=485&originWidth=1000&originalType=binary%E2%88%B6=2&size=928152&status=done&style=none&taskId=udf45b8f0-3ce7-4b2c-9c32-c99636c4b89&width=500" alt="image.png"></p><h3 id="8-选-1-数据选择器实现多输入逻辑函数"><a href="#8-选-1-数据选择器实现多输入逻辑函数" class="headerlink" title="8 选 1 数据选择器实现多输入逻辑函数"></a>8 选 1 数据选择器实现多输入逻辑函数</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1624496656766-4a7aa12f-e321-4db0-a4ad-08b6fa88599e.png#clientId=u5a7b053a-bdc9-4&from=paste&height=276&id=u6828df9f&margin=%5Bobject%20Object%5D&name=image.png&originHeight=551&originWidth=1014&originalType=binary%E2%88%B6=2&size=1033780&status=done&style=none&taskId=u64c518e0-798a-41bc-b94d-c6872b5c14a&width=507" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1624496990732-16fbfeea-0384-4da7-9a20-af26f3a367c3.png#clientId=u5a7b053a-bdc9-4&from=paste&height=278&id=ucd4d8900&margin=%5Bobject%20Object%5D&name=image.png&originHeight=556&originWidth=1014&originalType=binary%E2%88%B6=2&size=1033528&status=done&style=none&taskId=u6d0dff38-e184-482b-a71b-b36ee018935&width=507" alt="image.png"></p><h2 id="七、触发器"><a href="#七、触发器" class="headerlink" title="七、触发器"></a>七、触发器</h2><h3 id="同步-RS-触发器"><a href="#同步-RS-触发器" class="headerlink" title="同步 RS 触发器"></a>同步 RS 触发器</h3><h3 id="给出-D-触发器及输入，画出波形图"><a href="#给出-D-触发器及输入，画出波形图" class="headerlink" title="给出 D 触发器及输入，画出波形图"></a>给出 D 触发器及输入，画出波形图</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1624537249474-e313d1d4-e54a-4f11-801a-7cb35477b1ab.png#clientId=u5b32576c-6901-4&from=paste&height=277&id=ua213f1e1&margin=%5Bobject%20Object%5D&name=image.png&originHeight=553&originWidth=1008&originalType=binary%E2%88%B6=2&size=1022205&status=done&style=none&taskId=ub4c568c8-9c1d-4753-ae17-829ec02efdc&width=504" alt="image.png"></p><h3 id="给出-JK-触发器及输入，画出波形图"><a href="#给出-JK-触发器及输入，画出波形图" class="headerlink" title="给出 JK 触发器及输入，画出波形图"></a>给出 JK 触发器及输入，画出波形图</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1624537215870-9c84a3f2-bc32-45fc-ad01-711ccedb1f2f.png#clientId=u5b32576c-6901-4&from=paste&height=285&id=u906a2e93&margin=%5Bobject%20Object%5D&name=image.png&originHeight=569&originWidth=1000&originalType=binary%E2%88%B6=2&size=1192030&status=done&style=none&taskId=uf1cb6f6a-8d91-4df8-a6e1-45962884a2f&width=500" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1624537294036-58b09d4c-ff3f-463b-a638-40a8d9aceb27.png#clientId=u5b32576c-6901-4&from=paste&height=283&id=u4547f333&margin=%5Bobject%20Object%5D&name=image.png&originHeight=565&originWidth=994&originalType=binary%E2%88%B6=2&size=1119757&status=done&style=none&taskId=ub3790dac-46cd-4916-b6c7-0e502115b05&width=497" alt="image.png"></p><h3 id="多个触发器相连"><a href="#多个触发器相连" class="headerlink" title="多个触发器相连"></a>多个触发器相连</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1624537373073-41ebf1b0-eefa-4780-bf91-d48419f01d2d.png#clientId=u5b32576c-6901-4&from=paste&height=244&id=ub2a45094&margin=%5Bobject%20Object%5D&name=image.png&originHeight=488&originWidth=978&originalType=binary%E2%88%B6=2&size=847034&status=done&style=none&taskId=uae843972-b97f-48db-8c5c-93631575637&width=489" alt="image.png"></p><h2 id="问答题"><a href="#问答题" class="headerlink" title="问答题"></a>问答题</h2><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1624539793127-eb24945d-a5b8-4b60-ad1b-52764290c914.png#clientId=u122e29b6-0627-4&from=paste&height=37&id=u9205094c&margin=%5Bobject%20Object%5D&name=image.png&originHeight=73&originWidth=854&originalType=binary%E2%88%B6=2&size=7876&status=done&style=none&taskId=u06741aa3-a0ba-4975-84c3-cdd7b7f7809&width=427" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1624539824281-1a7c5e6a-774d-41de-96c0-68525d81eb6c.png#clientId=u122e29b6-0627-4&from=paste&height=32&id=u71ba7cb4&margin=%5Bobject%20Object%5D&name=image.png&originHeight=63&originWidth=513&originalType=binary%E2%88%B6=2&size=5969&status=done&style=none&taskId=uffb4ae4d-1b67-4d4a-b5aa-15349f09ceb&width=256.5" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1624539813127-8f316639-a479-4cf2-89b6-7e8d2d6ac7e9.png#clientId=u122e29b6-0627-4&from=paste&height=32&id=u41542c50&margin=%5Bobject%20Object%5D&name=image.png&originHeight=63&originWidth=358&originalType=binary%E2%88%B6=2&size=4347&status=done&style=none&taskId=udb329ebb-d53f-4dce-82fb-46cbed89a52&width=179" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1624539898752-fe3a106e-2e6d-4296-8ea7-bd2e434481a9.png#clientId=u122e29b6-0627-4&from=paste&height=58&id=uc035f11a&margin=%5Bobject%20Object%5D&name=image.png&originHeight=115&originWidth=1062&originalType=binary%E2%88%B6=2&size=15648&status=done&style=none&taskId=ud580aa19-df79-45aa-95f3-596130d36ff&width=531" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>《洒脱的人才“玩”得起人生》</title>
      <link href="/essay/mzd92z/"/>
      <url>/essay/mzd92z/</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1624193059628-8f003b19-46ac-47e4-b4af-23593b54b32a.jpeg#align=left&display=inline&height=371&id=u43723471&margin=%5Bobject%20Object%5D&originHeight=1536&originWidth=1080&status=done&style=none&width=261.0115966796875"></p><p>前言：<strong>我喜欢洒脱的人生态度，洒脱的人，活得简单、快乐</strong>。</p><p>对蔡澜的认识是源于『舌尖上的中国』，只知道他是一位美食家，最近才知道，蔡先生是一位见识丰富，极具艺术气质的一个人，他不仅是一位美食家，还是作家，电影制片人。</p><p>看完蔡澜先生写的这本随笔，会有一种豁达随性之感，有一种“生活本该如此”的感觉。整本书就是作者的随笔合集，作者有记录生活的那些看似不起眼，却也能吐槽，放开心境的一系列事情。书中还记录作者所吃过的许许多多的美食随笔，看这本书有一种吃甜点的那种愉悦感。</p><hr><p>最喜欢书里面的一段话：</p><blockquote><p><strong>人生的意义太过广泛，这个问题天下多少宗教家、哲学家都解答不了。吃得好一点，睡得好一点，多玩玩，不羡慕别人，不听管束，多储蓄人生经验，死而无憾。这就是最大的意义吧，一点儿也不复杂</strong>。</p></blockquote><h2 id="一、我承认我快乐"><a href="#一、我承认我快乐" class="headerlink" title="一、我承认我快乐"></a>一、我承认我快乐</h2><p>快乐</p><p>一天过得比一天快乐，是人生欢乐可行之道。可以从不刻薄自己开始。努力之余，想要什么就放手去买、去做。旅行最好，多学一样东西也不错。（蔡澜语录）</p><hr><p>想做的事</p><p>等到我所有的欲望都消失了，像看到好吃的东西也不想吃，好看的女人也不想和她们睡觉时，我就会去雕刻佛像，我好像说过这件事，我在清迈有一块地，可以建筑一间工作室，到时天天刻佛像，刻后涂上五颜六色，佛像的脸，像你、像我，不一定是菩萨观音。（蔡澜语录）</p><p>问：“那么多的兴趣，要等到什么时候才去做？是不是要等到退休？”<br>答：“我早已退休了，从很年轻开始已经学会退休。我一直觉得时间不够用，只能在某一段时期，做某件事，什么时候开始，什么时候终结，随缘吧。”</p><hr><p>好玩之都</p><p>在这个充满丑闻的都市中，我们得到了无限的欢乐，只要一天不死，就有笑话看。是的，还是香港好。（蔡澜语录）</p><hr><p>玩物丧志</p><p>谁说玩物丧志？玩物养志才对！（蔡澜语录）</p><div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">玩物丧志吗？谁都知道，如果玩的是自己极其感兴趣的，会走出不一样的路，讽刺的是，世上绝大多数人都不敢这么做……</div><hr><p>偷笑</p><p>庆幸的是我没有生儿育女的经验。看到别人的失落，我躲起来偷笑。想到自己结交的一些年轻女友都是人家的女儿，笑得更厉害了。（蔡澜语录）</p><p>（看这段的时候，笑死）<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1624348364148-8176d785-505c-4979-873b-8dbdb4341941.png#align=left&display=inline&height=96&id=gGEfk&margin=%5Bobject%20Object%5D&originHeight=96&originWidth=96&status=done&style=none&width=96"></p><hr><p>后悔</p><p>后悔，我们一定有过。烦恼出自我们的贪婪。两者兼得，就产生后悔和痛苦。a 君或 b 君，要哪一个？烦恼即来。选其中一个，不后悔就是。一切灾殃化为尘，阿弥陀佛！（蔡澜语录）</p><hr><p>惊讶状</p><p>换一个新环境，就像交了个新情妇，晚上睡不着觉，一大早起床便往外跑，想发现每一个角落有什么不同的。这种心情是兴奋的、年轻的。这就是我爱旅行、爱住酒店的主要原因。（蔡澜语录）</p><div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">这段作者讲述的是在帮一个朋友宣传的时候，某社报的记者来访问的情形，这个记者每句话离不开一个“哟”……</div><hr><p>水准</p><p>日本有一个很出名的料理人，他教了很多徒弟，其中有一个他最喜欢，但是他不教很多花样，每天一早，就叫这个徒弟煮一碗面豉汤给他喝。徒弟做了三年，师父也喝了三年。每天喝完不称赞，也不批评。后来徒弟才知道，师父教他的是保持一贯的水准，这是最重要的，客人吃了吃了，就吃出瘾来，不光顾不可。</p><div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">很多时候，最本真的或许才是最好的。想起了在天津吃的那家网红烤肉店，虽然整个餐厅运营机制不方便，但是吃到原生的服务员做的烤肉那味道，那种感觉还是很美妙的。</div><hr><p>蓝莓园</p><p>从吃一顿饭，便能观察对方是怎样的一种人。拿筷子搬弄一番又不选一块来吃，好不了哪里。大刺刺地先吃最好的部分，而不留给朋友，非常自私。夹了一大堆食物而不去动，是个贪心损人不利己的。畅怀大嚼，属于豁达型，豪放又来得性感，无妨深交。（蔡澜语录）</p><blockquote><p>哈哈哈，好像还真有道理……</p></blockquote><p>对着一望无际的蓝莓，他说：“一粒粒采摘，吃不完做果酱，春天也会开漂亮的花。到了秋天，蓝莓树像枫叶一样满山变红。那边有几棵高大的栗子树，果实熟了掉下，一面看红叶一面烤来吃，我已经不能回到城市去了。”</p><div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">“明知是一场意外，你要不要来”此般愿景，去又何妨</div><hr><p>不胖</p><p>一切浅尝，当然肥不了，但还是装腔作势，回答说：“真正会吃的人，是不胖的。”（蔡澜语录）</p><hr><p>演讲与拐杖</p><p>能进步的人，都有自己独立的思想，听他们的谈吐，就知与众不同，感想和观点皆独特的，都是努力奋斗的人物。（蔡澜语录）</p><hr><p>世界上的厕所</p><p>如果你很想在一生中出一本书的话，也不必有太多的才华，将所闻所见以相机拍下，再加上几行说明文字即行。举个例子，世界上的街灯都不同，乘现在年轻看到了就记录拍下，也是一本好书。（蔡澜语录）</p><div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">生活是一切美好事物的源泉</div><hr><p>整容</p><p>韩国女人愈来愈会打扮，愈来愈会穿衣服，不过这一点儿用处也没有，给外国人的印象，她们的美还是整容的结果。这对她们一点儿也不公平，数十年前经济未起飞时，哪有钱做手术，美女还不是多过其他国家？（蔡澜语录）</p><hr><p>商机</p><p>如果只为升值及价值而去收藏某物件，这是一种肤浅的行为，我不会刻意去收藏某种物件。买一件你喜欢的，因为可以用上一生一世。（蔡澜语录）</p><hr><p>惊喜</p><p>轮到了乐观派：“蔡先生的团总有惊喜，加了一个采苹果的节目，这次送给我们一次地震的经验。”（蔡澜语录）</p><p>另一位说：“最大惊喜还是我老婆给我的。结婚十多年，这一次因为地震，她才紧紧抱住我。”</p><div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">悲观者，和乐观者之间的差别，就在此了</div><p><img src="https://cdn.nlark.com/yuque/0/2021/gif/1484158/1624195248841-6bc739e9-a3ac-449f-8bd9-6afd3edc9fe5.gif#align=left&display=inline&height=45&id=d9ReS&margin=%5Bobject%20Object%5D&originHeight=45&originWidth=45&status=done&style=none&width=45"></p><hr><p>白痴</p><p>一个人一生中最需要储的，是说实话的本钱。年轻人还没有大本事，你面对同事上司，怎可能随便给人脸色看？明明碰上看不顺眼的人和事，你只有逆来顺受。要一点虚伪也要圆滑，等你建立了相当的自信和说服力后，便储了说实话的本钱。（蔡澜语录）</p><hr><p>尊重</p><p>不觉得，我心中说，太操劳的事我已不会做。况且，第一团去过的地方第二团重访，店主即当我老爷拜。怪不得那位第一次参加的团友说：“最过瘾的是跟你去到那里，都得到人家的尊重。”（蔡澜语录）</p><div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">感受得到，做生意就是这样，诚恳，尊重他人，待人友善的这种做事风格</div><div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">所有的快乐都是在自己生活中的点滴累计而成，生活啊，不要太难为自己~身边处处是一些美好的事物啊，难道不是吗？</div><h2 id="二、今日的烦恼将成为明日的笑话"><a href="#二、今日的烦恼将成为明日的笑话" class="headerlink" title="二、今日的烦恼将成为明日的笑话"></a>二、今日的烦恼将成为明日的笑话</h2><p>专栏作家</p><p>既然要写专栏，记得多看专栏，仔细研究其他作者的可读性因素何在。我开始时，先拜十三妹为师，她是专栏作家的老祖宗。本人未见，读遍她的文字，知道她除了谈论国际关系、文学音乐戏剧之外，也多涉及生活点滴，连看医生，向人借钱，也可以娓娓道来，这才能与读者融合在一起。（蔡澜语录）</p><p>作者需要不断地吸收，才能付出。需要不耻下问。旅行、交友、阅读、爱戏剧电影、绘画、音乐等等，是基本的条件。专栏作者和小说家完全是两码子事，后者可以把自己藏起来，编写出动人的故事，但是前者每天赤裸裸地把生活点滴奉献给读者。想过什么、做过什么，都在每天的专栏看得清清楚楚，是假装不出来的。</p><p>我们这些写作人，多多少少都有发表欲，既然有了，不必要扮清高，迎合读者，不是大罪。</p><p><strong>真，是专栏作者的本钱，一假便被看穿，如果我们把真诚的感情放在文字上，读者也许不喜欢，可是一旦爱上，就是终生的了</strong>。</p><p>既然要写专栏，记得多看专栏，仔细研究其他作者的可读性因素何在。我开始时，先拜十三妹为师，她是专栏作家的老祖宗。本人未见，读遍她的文字，知道她除了谈论国际关系、文学音乐戏剧之外，也多涉及生活点滴，连看医生，向人借钱，也可以娓娓道来，这才能与读者融合在一起。</p><div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">“真，是专栏作者得本钱！”受益这句话。</div><hr><p>飞行等级</p><p>生活质量的提高，商务舱已是抢手货，不管是否公费，大家一坐过之后，已不能退步去坐经济舱了，自掏腰包，也非商务不可，有些航线，已是一半商务一半经济了，更夸张的，是整架飞机，只有商务的趋势。</p><p>人往高处，乘商务的，心中也一直想要坐头等，头等那么好吗？值得吗？<br>可以把座椅当床平卧，是最大的特点，但这种服务，多数的商务舱已能做到。<br>吃得好，喝得佳吗？也不是，所谓的香槟，皆非第一流的，鱼子酱更是咸得要死。坐欧洲的航空公司，头等还有一点头等味道，亚洲的，有钱人通街都是，不当你是贵客。头等，只能遇到一些不肯退休的空中服务员，反正不会被炒鱿鱼，也带狗眼看人低的眼光了。<br>说什么，也是商务物有所值，但物有所值这句话，是昂贵的，当今的旅行费，绝不便宜。</p><div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">或许是不是所有事物都是物有所值把……</div><h2 id="三、只有自爱才心安理得"><a href="#三、只有自爱才心安理得" class="headerlink" title="三、只有自爱才心安理得"></a>三、只有自爱才心安理得</h2><p>旅行伴侣</p><p>看了电视剧而找原著来读的不乏其人，相反就寥寥无几。到底，电视剧给我们的是固定的形象，失去了看书的幻想力。（蔡澜语录）</p><div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">还好吧，我觉得『士兵突击』这部电视剧和小说就不错。</div><hr><p>交友</p><p>最重要的，是把自己最真实的一面表露出来。真面目示众又如何？相貌是父母赐予，不应为讨好别人而改变。如果不够自信，就努力看书，增加自己的内涵，多写精彩的文章，日子久了，就会有人欣赏。</p><hr><p>乐得拍掌</p><p>做人最好的就是醉生梦死。醉生，每天喝醉；梦死，在做梦的时候死去，多幸福！（蔡澜语录）</p><h2 id="四、豁得出去，又是另一片天空"><a href="#四、豁得出去，又是另一片天空" class="headerlink" title="四、豁得出去，又是另一片天空"></a>四、豁得出去，又是另一片天空</h2><p>痴人说梦</p><p>我一直做梦，梦见给人追杀。醒来，原来是一场梦，怎会不高兴？哈哈哈哈。（蔡澜语录）</p><hr><p>做人</p><p>从小，父母亲就要我好好地“做人”。做人就是努力别看他人脸色，做人，也不必要给别人脸色看。生了下来，大家都是平等的。人与人之间要有一份互相的尊敬。所以我不管对方是什么职业，是老是少，我都尊重。（蔡澜语录）</p><p>“你到底是什么身份？电影人？食家？茶商？开餐厅的？开杂货店的？做零食的？卖财柴米油盐酱的？你最想别人怎么看你？”朋友问。“我只想做一个人。”我回答。　　从小，父母亲就要我好好地“做人”。做人还不容易吗？不。不容易。“什么叫会做人？”朋友说，“看人脸色不就是？”不，做人就是努力别看他人脸色，做人，也不必要给别人脸色看。</p><p>生了下来，大家都是平等的。人与人之间要有一份互相的尊敬。所以我不管对方是什么职业，是老是少，我都尊重。</p><p>除了尊敬人，也要尊敬我们住的环境，这是一个基本条件。</p><hr><h2 id="五、你是为谁生存"><a href="#五、你是为谁生存" class="headerlink" title="五、你是为谁生存"></a>五、你是为谁生存</h2><p>最喜欢的</p><p>写文章不求留世，工作当消遣，有什么说什么，东西不好吃就说不好吃，这种讲真话的本钱，是我花了数十年储蓄回来的。从前有点违背良心的话，是看到女人，都叫她们为“靓女”。当今也花不了本钱，说：“聪明。”（蔡澜语录）</p><hr><p>教坏</p><p>“现在的孩子，都太乖了。出到社会，不知怎么面对。由我来教坏，遇到什么骗子都不必怕。我有个电影界的泰国朋友秦子彬先生，他把好赌的儿子带到拉斯维加斯去，给他一百万美金去赌，一下子输光，输得那儿子脸都青掉，从此不赌了。这不是以坏易好吗？”</p>]]></content>
      
      
      <categories>
          
          <category> 阅读 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>对平侠谈个人成长的一些感悟</title>
      <link href="/essay/coeh8m/"/>
      <url>/essay/coeh8m/</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1624096824333-d7a7a173-78ce-487b-8924-11e04875f913.png#crop=0&crop=0&crop=1&crop=1&height=1080&id=SJV2T&margin=%5Bobject%20Object%5D&name=Snipaste_2021-06-19_17-46-32.png&originHeight=1080&originWidth=1920&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=1582632&status=done&style=none&title=&width=1920" alt="Snipaste_2021-06-19_17-46-32.png"></p><p>前言：近期看到平侠作者发布的一篇文章『<a href="https://www.yuque.com/zenany/up/be_independent">从高效能人士的七个习惯谈成长</a>』，作者对个人成长精炼出来三个要素：心态、格局、魄力，对应《高效能人士的七个习惯》就是积极主动、以终为始、要事第一这三点。这三点算是对个人成长的比较好的概括了，总的来说，这篇文章对近期有些烦躁的自己算是重新点亮了一盏明灯。</p><hr><h2 id="积极主动的心态"><a href="#积极主动的心态" class="headerlink" title="积极主动的心态"></a>积极主动的心态</h2><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1624097233676-35f38d3c-7383-430a-9ca3-19551b956320.png#crop=0&crop=0&crop=1&crop=1&height=348&id=u5b8ae4a2&margin=%5Bobject%20Object%5D&name=Snipaste_2020-12-21_11-03-35.png&originHeight=1080&originWidth=1920&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=1220501&status=done&style=none&title=&width=618.0208740234375" alt="Snipaste_2020-12-21_11-03-35.png"></p><p>作者说的这句话“<strong>接受无法改变的，改变有可能改变的</strong>”，我想应该是和李开复前辈的理念一样——“<strong>有勇气改变可以改变的，有胸怀接受不可改变的事情</strong>”，李开复其实后面还说道，“<strong>用智慧区分两者的不同</strong>”。其实说白了，就是对所处之境，所遇之事永远抱有一个乐观豁达的心态。</p><p>近期或然有些许同感，很多所有人都懂的道理，对一些人而言，由于性格的缘故，总要比别人接受的晚，再深点讲其实是内心不想接受罢了，抵触，就像是一个孩子被家长训话，就有些桀骜不驯的孩子，知道是这样的，知道这样是不对的，但就是愿意被性格被情绪所控制，但一旦懂得了并接受了这个所有人都懂的道理，成长加速度就会提升甚至赶超同龄人了，这或许就是成长吧。</p><blockquote><p>天下事，难易相成。在做事的过程中，有顺境，有逆境，难在始终保持积极主动的心态。<br>顺境：比较容易做到积极主动，但也容易产生懈怠，需要顺势而为，不可懈怠，快速扩大成果。<br>逆境：往往正是考验积极主动的时候，需要摆正心态，重塑信心，主动寻找改变的契机。</p></blockquote><p>作者这段话我觉得很不错，特别是对逆境的态度——始终坚持积极主动的心态。</p><p>积极主动的心态其实每个人或多或少都会，但是一直坚持的人，很少，也很难，但也正因是难，才要坚持不是么？（算是把自己好好教育了一番的感觉</p><p>三分钟不开刀无痛苦的历练，在这个文明制度下，不存在。</p><h2 id="以终为始的格局"><a href="#以终为始的格局" class="headerlink" title="以终为始的格局"></a>以终为始的格局</h2><p>换一个本人一直贯彻的学习方法中的一句话就是“以结果为导向”，以结果为导向的这种思维，在计算机专业里面特别好使，简单说明就是对于同一个技术，一个大作业比课堂上课一学期好使（我可没说我不好好听课<img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1624095112125-51056426-2c52-4bbf-9d7f-128cd1fac489.png#crop=0&crop=0&crop=1&crop=1&height=68&id=aZJCK&margin=%5Bobject%20Object%5D&name=1F18FB8EB4B76CFAC0B29A0A81E144E1.png&originHeight=68&originWidth=74&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=6617&status=done&style=none&title=&width=74" alt="1F18FB8EB4B76CFAC0B29A0A81E144E1.png">）</p><p>对于把这种思维转到职业规划与发展里面，亦是如此，划分阶段的话，就如作者的三步，确定终点——推演路径——制定计划。虽然我不太习惯制定这种人生抑或是职业计划，但不得不承认，这种方式是有效果的。</p><p>作者所推荐的他的师傅 <a href="https://www.zhihu.com/people/wuduoyi">nwind</a> 传授的 <a href="https://baike.baidu.com/item/%E9%A9%AC%E9%B9%A4%E5%87%8C/5566647">马鹤凌老先生</a> 的总结：<a href="https://github.com/zenany/zenany.github.io/blob/master/_posts/about_time_and_knowledge_management.md">此生理想、近期计划、今日功课</a>。仔细看了看，感觉也在强调计划的操作必要性。此刻，突然想到了兵长内心打算跟随团长的心理独白</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1624096040600-e72f1c6f-cd5e-4421-a75c-9e5e8ac3edb7.png#crop=0&crop=0&crop=1&crop=1&height=366&id=bwQJL&margin=%5Bobject%20Object%5D&name=Snipaste_2021-06-19_17-46-54.png&originHeight=1080&originWidth=1920&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=1705432&status=done&style=none&title=&width=650.9954223632812" alt="Snipaste_2021-06-19_17-46-54.png"><br>“<strong>好吧，我就跟着你好了，埃尔文·史密斯</strong>”</p><h2 id="要事第一的魄力"><a href="#要事第一的魄力" class="headerlink" title="要事第一的魄力"></a>要事第一的魄力</h2><p>作者想要表达的是“专注当下，取舍果断”。</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1624096754794-70a837ba-bd73-4a01-a20d-712bfe4266fe.png#crop=0&crop=0&crop=1&crop=1&height=355&id=Di3jA&margin=%5Bobject%20Object%5D&name=image.png&originHeight=430&originWidth=765&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=661296&status=done&style=none&title=&width=632" alt="image.png"></p><p>舍弃的精神，我觉得我有，作者所描述的今后我可能会遇到的工作方面，也有对职业的持续发展道路方面的，作者的三个问题值得记录：</p><blockquote><p>1、我能为团队和公司带来什么？<br>2、我从身边的人身上可以学到什么？<br>3、我真正想做的事是什么？</p></blockquote><p>时时刻刻想着这三个问题，其实结果还是比较显而易见的……</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>所有的职业终点都是NPC</title>
      <link href="/essay/dpauku/"/>
      <url>/essay/dpauku/</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1623929248579-c01331e1-d895-4f58-bf92-026465a16a65.png#clientId=u43e23ad8-c9db-4&from=paste&height=540&id=u7e92ea60&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1080&originWidth=1920&originalType=binary%E2%88%B6=2&size=3331025&status=done&style=none&taskId=ud8484b86-49fd-4d9c-b9b3-5f6812ef7c0&width=960" alt="image.png"></p><blockquote><p>非玩家角色或称非操控角色（英语：Non-Player Character，NPC），是指角色扮演游戏中非玩家控制的角色。</p><p>NPC 是游戏背景中，非主角（狭义上来说还要求非敌人）的陪衬人物。玩家借由他们与游戏互动。在桌上角色扮演游戏里，NPC 是由游戏主持者操纵，而在电脑角色扮演游戏里，则是由程序默认的剧本来决定 NPC 的反应，由游戏的人工智能做出控制。部分 NPC 有时可变成可操控角色</p><p>——维基百科</p></blockquote><p>如果将一个人人生的职业经历划分为两段，第一段就像是打怪升级的攻略者，而后一段我想就是 NPC 吧</p><p>现在的我就像是一个攻略者，利用对这个文明框架的种种，去攻略眼前的所有困难，但是，我似乎也看到了今后处在 NPC 角色的我……</p><p>如果把人生喻成一场游戏，那么我觉得人生的意义则是，<strong>用一颗勇敢的心，去攻略眼前的一个个困难</strong>。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>文明框架下美好的事物是什么样的？</title>
      <link href="/essay/logfxx/"/>
      <url>/essay/logfxx/</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1623724816738-638c68c5-a58d-4855-a83f-8040d78aba26.jpeg#height=1080&id=AqhVV&originHeight=1080&originWidth=1440&originalType=binary%E2%88%B6=1&status=done&style=none&width=1440"><br>图：梁同学</p><hr><p>文明，历史的长久以往，让我们这个文明慢慢趋于一种某一方面而言的制度体系，或许对大多数人而言，这是一种常态，但对我而言，文明是框架。我并没有用束缚这个较为偏激的字眼去形容，而是用的框架。</p><p>我们所喜欢的事物，至少我喜欢的事物，拆开了讲，许许多多都是都是被框架所限定，生活、思维、情感、甚至是内心，那为什么框架要限定出我们所定义出来的幸福呢？我脑海中浮现的答案是文明，是制度……</p><p>地球最初的生命，或许只是造物主偷偷在一个水球中放下了能进行光合作用的一些小生物，进而演化成了我们此般文明景象罢了，我们都是进化而来的生物，而生物遵循了生物法则，长久以往的人们制定了无数有益于生存下去的制度、规则，而在这样的大环境下生活着，有一种奇妙的事物叫做快乐抑或是幸福。</p><p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1623724819065-43292e39-1cfe-4dd4-b4a9-9cbf05167e4a.jpeg#height=1080&id=jClko&originHeight=1080&originWidth=1440&originalType=binary%E2%88%B6=1&status=done&style=none&width=1440"></p><p>人生的终极目标是什么？我又在一直追寻着什么啊？</p><p>我对自己问了一个特别大的问题，甚至有些幼稚的问题，或许我的潜意识里面想过这问题，但是又像是模模糊糊，如果用此刻大脑中的思绪来回答，我应该会回答：文明框架下的快乐和幸福。这个回答看起来是那么的简单易懂，却又有一些伤感与妥协，我站的太低了，我将自己死死地按在一个没有实体的框架下面，多么的悲怆，似乎就像是一台机器去做那些连幸福都定义好了的事情，</p><p>突然想到了一些人，无间道里面的刘建明和人间失格里面的叶藏，描述这两个人最好的状态就是无间，无间地狱，真的是艺术，描述的彻彻底底，佛教的思想：轮回、开悟、涅槃，而那两个人，无止境的在无间地狱轮回……想想这个文明制度下的种种，细思极恐</p><p>人活着就是为了生活更快乐，更幸福，而幸福的生活要自己努力争取来的。</p><p>我总是又在想，温柔的人为什么也会被</p><hr><p>2021.06.16</p><p>“<strong>我不喜欢那些正确的人，那些从没堕落过、从没犯过错的人。生活的美未曾在他们面前展开过。</strong>”一个文学家在所沉浸的文学世界中的独白。</p><p>真正的文学家总让人感觉是一个怪人，而我却独爱这般不被束缚的精神因子。</p><p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1626942905634-3fe3cc98-bedf-46bf-ac8e-20162a512b91.jpeg#clientId=u065e478d-f803-4&from=drop&id=u233ed369&margin=%5Bobject%20Object%5D&name=Screenshot_20210616_222939_com.douban.frodo.jpg&originHeight=1438&originWidth=1176&originalType=binary%E2%88%B6=1&size=215039&status=done&style=none&taskId=u40b1c59c-ec9a-42ed-b435-1d49ad1646a" alt="Screenshot_20210616_222939_com.douban.frodo.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>各类排序算法汇总</title>
      <link href="/blog/garbxb/"/>
      <url>/blog/garbxb/</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1625064781047-2f12af3a-ce5c-4280-b387-38a40f307b45.jpeg#crop=0&crop=0&crop=1&crop=1&height=3508&id=yeGww&margin=%5Bobject%20Object%5D&name=hezhao.jpg&originHeight=3508&originWidth=4961&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=599481&status=done&style=none&title=&width=4961" alt="hezhao.jpg"></p><p>前言：排序按照所占用的计算机内部存储设备，可以分为：<strong>内部排序</strong>和<strong>外部排序</strong></p><ul><li><strong>内部排序：</strong>占用的是内存，待排序序列全部放在内存加以排序处理</li><li><strong>外部排序：</strong>占用的是外存，数据量比较大，内存空间不足以一次性全部容纳数据的情况</li></ul><p>本文章 通过<a href="https://leetcode.cn/problems/sort-an-array/">912. 排序数组</a> 题目，以此来总结内部排序的各种排序算法。</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1623667337022-44c54af8-5961-43d6-8fa4-46ef3f6ec71f.png#crop=0&crop=0&crop=1&crop=1&height=329&id=zJx4v&margin=%5Bobject%20Object%5D&name=image.png&originHeight=499&originWidth=1130&originalType=binary%E2%88%B6=1&rotation=0&showTitle=true&size=412707&status=done&style=stroke&title=%E5%90%84%E7%A7%8D%E5%86%85%E9%83%A8%E6%8E%92%E5%BA%8F%E6%96%B9%E6%B3%95%E7%9A%84%E6%AF%94%E8%BE%83&width=746" alt="image.png" title="各种内部排序方法的比较"></p><h2 id="一、插入类排序"><a href="#一、插入类排序" class="headerlink" title="一、插入类排序"></a>一、插入类排序</h2><p>将无序的子序列插入到有序序列中</p><h3 id="✅-直接插入"><a href="#✅-直接插入" class="headerlink" title="✅ 直接插入"></a>✅ 直接插入</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/gif/1484158/1625014050650-261f0307-6356-440f-b06a-12e264344572.gif#crop=0&crop=0&crop=1&crop=1&height=523&id=pZjWF&originHeight=523&originWidth=813&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=0&status=done&style=none&title=&width=813"><br>将元素序列走一遍，走到某个元素时，将其插入到已走过的已排序序列中，这样可以保证走完所有元素，然后所有的元素都是排序好的。<br>数据结构选用的时顺序表</p><pre><code class="javascript">/** * @param &#123;number[]&#125; nums * @return &#123;number[]&#125; */var sortArray = function (nums) &#123;  for (let i = 0; i &lt; nums.length; i++) &#123;    let flag = i;    for (let j = flag - 1; j &gt;= 0; j--) &#123;      if (nums[flag] &lt; nums[j]) &#123;        let temp = nums[j];        nums[j] = nums[flag];        nums[flag] = temp;        flag--;      &#125;    &#125;  &#125;  return nums;&#125;;</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1653228341393-1bd78b67-0797-4bec-add7-be5d8295ac35.png#clientId=u863f3fca-1616-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=295&id=uecb8136f&name=image.png&originHeight=398&originWidth=766&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=35479&status=done&style=none&taskId=uf5cc12a8-e880-46fe-a8fd-24cc4688335&title=&width=567.4074474905118" alt="image.png"></p><h3 id="优化：折半插入"><a href="#优化：折半插入" class="headerlink" title="优化：折半插入"></a>优化：折半插入</h3><p>在直接插入的过程中，找到一个元素，然后再需要从后往前依次查找“该在”的位置，对其查找进行了折半优化</p><pre><code class="cpp">/* 折半插入排序 */void BinsertSort(SqList &amp;S) &#123;    for (int i = 2; i &lt;= S.length;i++) &#123;        S.data[0] = S.data[i];        int low = 1;        int high = i - 1;        while (low &lt;= high) &#123;            int m = (low + high) / 2;            if (S.data[0]&lt;S.data[m]) high = m - 1;            else low = m + 1;        &#125;        int j;        for (j = i - 1; j &gt;= high + 1;--j)            S.data[j + 1] = S.data[j];        S.data[high + 1] = S.data[0];    &#125;&#125;</code></pre><h3 id="优化：希尔排序"><a href="#优化：希尔排序" class="headerlink" title="优化：希尔排序"></a>优化：希尔排序</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/gif/1484158/1625015190376-d54ed111-aa4a-41cf-9dde-6593a6aaf4e0.gif#crop=0&crop=0&crop=1&crop=1&height=290&id=KmYb4&originHeight=290&originWidth=665&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=0&status=done&style=none&title=&width=665"></p><pre><code class="cpp">/* 希尔排序 */void ShellInsert (SqList &amp;L, int dk) &#123;    for (int i = dk + 1; i &lt;= L.length;++i) &#123;        if (L.data[i]&lt;L.data[i-dk]) &#123;            L.data[0] = L.data[i];            int j;            for (j = i - dk; j &gt; 0 &amp;&amp; L.data[0] &lt; L.data[j]; j -= dk)                L.data[j + dk] = L.data[j];            L.data[j + dk] = L.data[0];        &#125;    &#125;&#125;void ShellSort (SqList &amp;L, int dt[],int t) &#123;    for (int k = 0; k &lt; t;++k) &#123;        ShellInsert(L, dt[k]);    &#125;&#125;</code></pre><h2 id="二、交换类排序"><a href="#二、交换类排序" class="headerlink" title="二、交换类排序"></a>二、交换类排序</h2><h3 id="✅-冒泡排序"><a href="#✅-冒泡排序" class="headerlink" title="✅ 冒泡排序"></a>✅ 冒泡排序</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/gif/1484158/1625013969954-b7310256-1c0a-4b3c-b45b-a7b33eca8e5c.gif#crop=0&crop=0&crop=1&crop=1&height=262&id=bVJVg&originHeight=262&originWidth=813&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=0&status=done&style=none&title=&width=813"></p><pre><code class="javascript">/** * @param &#123;number[]&#125; nums * @return &#123;number[]&#125; */var sortArray = function (nums) &#123;  for (let i = nums.length - 1; i &gt; 0; i--) &#123;    for (let j = 0; j &lt; i; j++) &#123;      if (nums[j] &gt; nums[j + 1]) &#123;        let temp = nums[j];        nums[j] = nums[j + 1];        nums[j + 1] = temp;      &#125;    &#125;  &#125;  return nums;&#125;;</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1653213078608-86011f32-d058-4393-902d-33f97f21578b.png#clientId=u863f3fca-1616-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=293&id=u8a10d142&name=image.png&originHeight=395&originWidth=781&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=34658&status=done&style=none&taskId=ub6150d09-6f32-4641-a7c7-5bc9726769f&title=&width=578.5185593865401" alt="image.png"></p><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/gif/1484158/1625017709918-661c5cd4-fd2a-49a0-be80-bb59b791ed8f.gif#crop=0&crop=0&crop=1&crop=1&height=252&id=jCV3S&originHeight=252&originWidth=811&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=0&status=done&style=none&title=&width=811"></p><pre><code class="cpp">/* 快速排序 */int Partition (SqList &amp;L, int low, int high) &#123;    L.data[0] = L.data[low];    int pivotkey = L.data[low];    while (low &lt; high) &#123;        while (low&lt;high &amp;&amp; L.data[high]&gt;=pivotkey)            --high;        L.data[low] = L.data[high];        while (low&lt;high &amp;&amp; L.data[low]&lt;=pivotkey)            ++low;        L.data[high] = L.data[low];    &#125;    L.data[low] = L.data[0];    return low;&#125;void Qsort(SqList &amp;L, int low, int high) &#123;    if (low&lt;high)&#123;        int pivoloc = Partition(L, low, high);        Qsort(L, low, pivoloc - 1);        Qsort(L, pivoloc + 1, high);    &#125;&#125;void QuickSort(SqList &amp;L) &#123;    Qsort(L, 1, L.length);&#125;</code></pre><h2 id="三、选择类排序"><a href="#三、选择类排序" class="headerlink" title="三、选择类排序"></a>三、选择类排序</h2><p><a href="http://data.biancheng.net/view/72.html">参考：ata.biancheng.net/view/72.html</a></p><h3 id="✅-简单选择排序"><a href="#✅-简单选择排序" class="headerlink" title="✅ 简单选择排序"></a>✅ 简单选择排序</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/gif/1484158/1625014017576-1b58bc2d-d46b-48e8-a307-6fc6f4ee8f0a.gif#crop=0&crop=0&crop=1&crop=1&height=262&id=FeuYg&originHeight=262&originWidth=813&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=0&status=done&style=none&title=&width=813"></p><pre><code class="javascript">/** * @param &#123;number[]&#125; nums * @return &#123;number[]&#125; */var sortArray = function (nums) &#123;  for (let i = 0; i &lt; nums.length - 1; i++) &#123;    for (let j = i + 1; j &lt; nums.length; j++) &#123;      if (nums[i] &gt; nums[j]) &#123;        let temp = nums[i];        nums[i] = nums[j];        nums[j] = temp;      &#125;    &#125;  &#125;  return nums;&#125;;</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1653226950636-0e2a6743-01fe-4195-8d7e-a0c59a37891e.png#clientId=u863f3fca-1616-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=306&id=u6b1a3b2d&name=image.png&originHeight=413&originWidth=767&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=35790&status=done&style=none&taskId=uab0382c6-b50f-4554-8871-99f00484b76&title=&width=568.1481882835803" alt="image.png"></p><h3 id="树形选择排序"><a href="#树形选择排序" class="headerlink" title="树形选择排序"></a>树形选择排序</h3><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/gif/1484158/1625021691601-c1572503-c54d-4d12-8d3e-97da2ae0aa38.gif#crop=0&crop=0&crop=1&crop=1&height=364&id=b5jeQ&originHeight=364&originWidth=547&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=0&status=done&style=none&title=&width=547"></p><h2 id="四、归并排序"><a href="#四、归并排序" class="headerlink" title="四、归并排序"></a>四、归并排序</h2><h3 id="2-路归并排序"><a href="#2-路归并排序" class="headerlink" title="2-路归并排序"></a>2-路归并排序</h3><p>给定一个序列，从左往右两两子序列进行归并</p><p>子序列归并的算法：加入有两个靠着的 a、b 序列，由上面可知，a、b 各自都是有序序列，现在就是将这两个合并为一个有序序列 k，将 a 和 b 序列的各个元素进行比较，小的依次放入 k 序列，当 a、b 两个中有一个序列为空了，就将那个不为空的序列直接加入到 k 序列即可，最后 k 序列就是目的序列。</p><h2 id="五、分配类排序"><a href="#五、分配类排序" class="headerlink" title="五、分配类排序"></a>五、分配类排序</h2><h3 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h3><p>TODO: 扑克牌的花色排序</p><h2 id="六、外部排序"><a href="#六、外部排序" class="headerlink" title="六、外部排序"></a>六、外部排序</h2><h3 id="基本方法"><a href="#基本方法" class="headerlink" title="基本方法"></a>基本方法</h3><h3 id="多路平衡归并"><a href="#多路平衡归并" class="headerlink" title="多路平衡归并"></a>多路平衡归并</h3><p>基本思想是内部排序中的 2-路归并排序</p><h3 id="置换-选择排序"><a href="#置换-选择排序" class="headerlink" title="置换-选择排序"></a>置换-选择排序</h3><h3 id="最佳归并树"><a href="#最佳归并树" class="headerlink" title="最佳归并树"></a>最佳归并树</h3><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>文章的动画演示</p><ul><li><a href="https://blog.csdn.net/Hk_john/article/details/79888992">https://blog.csdn.net/Hk_john/article/details/79888992</a>（js）</li><li><a href="https://www.itrhx.com/2020/10/23/A91-sorting-algorithm/">https://www.itrhx.com/2020/10/23/A91-sorting-algorithm/</a>（python）</li></ul>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 📊查找排序算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>一个梦——梦中姑娘</title>
      <link href="/essay/di14o2/"/>
      <url>/essay/di14o2/</url>
      
        <content type="html"><![CDATA[<div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">空调+风扇睡觉->易着凉->易做梦因着凉而做的梦大多不是自然醒，此般崩坏醒……</div><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1623127396847-7144e32c-9f84-4c90-ad75-307f781827a5.png#height=1377&id=IChRS&originHeight=1377&originWidth=1080&originalType=binary%E2%88%B6=1&status=done&style=none&width=1080"></p><hr>]]></content>
      
      
      <categories>
          
          <category> 异世界 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>《人间失格》——“纯真无垢的信任算是罪过吗？”</title>
      <link href="/essay/am0q19/"/>
      <url>/essay/am0q19/</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1622964551715-a700f7e7-b3e8-45c5-9d80-787cbb0c66f3.png#height=400&id=u8cf446b6&margin=%5Bobject%20Object%5D&name=image.png&originHeight=400&originWidth=400&originalType=binary%E2%88%B6=1&size=88088&status=done&style=stroke&width=400" alt="image.png"></p><div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">“纯真无垢的信任算是罪过吗？”</div><p>经历了小时候的“看脸色行事”、中学寄读、与家庭隔绝任何关系……</p><p>回归抑郁惆怅的那会日常状态，常去的那家酒馆，将自己灌得烂醉，突然有一天，遇见的不懂何为污秽的童贞的由子润湿了生来敏感的叶藏……</p><div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">“即便因为这样日后遭逢再大的悲哀也无所谓，我一定要放纵地享受眼前这极度的欢乐，哪怕这一生仅有这一次。”</div><p>还记得『无间道』里面说的「八大地狱之最，称为无间地狱，为无间断遭受大苦大意，故有此名」</p><p>人会变吗？不知道，但我知道敏感的人不易变……</p><div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">四周的气氛蓦地变得异样紧张。两个人从楼顶天台走到二楼,再从二楼往底楼我的屋子走去。在楼梯上堀木停住了脚步,用手指着前面小声说道:“你看!”我家那间屋子上方的小窗户正敞开着,从那儿可以看到里面的光景。<p>只见屋子里亮着电灯,有两只动物正在干着什么。我顿时觉得头晕目眩、呼吸急促,但同时心里却在暗自低语—这也算是一出人间粉戏吧,这也算是人类的本性吧,没什么好大惊小怪的—我甚至忘记了出手去解救由子,只是久久地呆立在楼梯中间。</div></p><p>“解救”这个一词我不是很理解，我看了两遍，不知道由子是被迫的还是自愿的，但是根据后文的由子对叶藏的眼神躲避的情节，我感觉是自愿的……</p><div style="background: #FFF3F3;padding:10px;border: 1px solid #DEB8BE;border-radius:5px;margin-bottom:5px;">每当我唤她时，她总是身体冷不丁一哆嗦，视线也不知道该投向哪里好。无论我再怎么装痴装疯胡言乱语以逗她一笑，她都一副茫然不知所措、坐立不安、战战兢兢的样子，和我说话时还心不在焉地乱用敬语。</div><hr><p>原文里面的天台上的叶藏心理……</p><div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">我则像逃命似的一个人又冲回到天台，躺在地上，仰望含满雨气的夏日夜空。此时，袭遍我全身的情感不是愤怒，也不是厌恶，更不是悲伤，而是极度的恐惧。那不是面对墓地中诸多幽灵时的恐惧，倒更像是在神社的杉树林间，撞见身着白衣的神明时的那种来自太古的、凶暴恶戾的、令人噤默失语般的恐惧。从那晚起，我开始少年白头，我越发对世间所有的一切失去信心，越发对人产生无止境的怀疑，从此诀别了对人世生活所抱有的全部期待、喜悦、共鸣。事实上，这也是我整个人生中起到决定性作用的一个事件，仿佛被人迎面一刀砍中眉间，日后无论我与任何人接触，那伤口便会隐隐作痛。</div><p>丧，十分丧……这一段，以前看的极度压抑，现在看的十分同情，敏感的叶藏遇到这种事情，真的是上天的无间地狱的惩罚吗？那现在这个时代的人呢？</p><hr><div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">“纯真无垢的信任算是罪过吗？”“纯真无垢的信任之心，难道真是罪恶之源吗？！”</div><p>作者说着两次，好像文中还有相似强调的话语，对于一个敏感的人的内心最信任人而言，则算是一种无言的崩溃把，堕入人间地狱……</p><p>作者不解……</p><p>第一次看这本书对此我是感到抑郁，全程压抑，但是现在看来，感受到的是一个敏感的人对周围的无奈与妥协，到最后那纯真无垢的信任之心也已死……</p><p>这样的人生是何等的失望……</p>]]></content>
      
      
      <categories>
          
          <category> 阅读 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>《人生》之高加林的爱情我也曾有过……</title>
      <link href="/essay/mh44ds/"/>
      <url>/essay/mh44ds/</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1622168235721-f78e67ae-65fa-4208-bdf6-1bbad23a55a8.png#height=387&id=u836e58b6&margin=%5Bobject%20Object%5D&name=81676418_p0.png&originHeight=1663&originWidth=1255&originalType=binary%E2%88%B6=1&size=2307612&status=done&style=stroke&width=291.7477111816406" alt="81676418_p0.png"><br>以前看的，今天突然有一些很深的感悟</p><p>高加林把纯情美丽、聪慧贤淑的刘巧珍这块“金子”丢了，突然想到相似的自己、想到了守恒、想到了辗转反侧却也难忘的心思……</p><p>守恒律，总觉得这世界上任何东西<br>这世界上的事情，总是守恒的，人和人之间的情感，爱情、人情味、亲情</p><p>还记得路遥的《人生》最后说，加林失去了自己人生中最重要的金子，我觉得这也是守恒的，从一开始，高加林就获得了自己的“金子”，然而呢，没珍惜……一开始高加林的教师职位被强拉下来，这的确是人生的不公，但是这也迎来了上天送给他的巧珍这颗金子，而后呢，他又放弃了巧珍这颗金子，追寻另外的一个女人，到最后，这个金子也没了</p><p><strong>现实是如此的相似，我曾经也失去过金子，她非常漂亮，些许单纯，些许霸道，还喜欢看言情小说……我们和书里面的主人公一摸一样，真就一模一样，原因无他，在当时看来，在当时周围整个世界看来，读书谈啥恋爱……那时的我，很懵懂···后来我就进高中了，她好像是去一个技术学院还是直接工作，我忘了，有一次我上 QQ 了，那会应该是高一，她真好也在，便和她聊起天，那会她好朋友也在，我们三个是朋友，那会我们一起聊天，突然她朋友来一句“你啥时候和我家 XXX 表白呢”……</strong><br><strong>是的，那会，又是在读书……我不记得我当时是怎么回应的了，我只知道我当时挺想看看她的……</strong></p><p><strong>我大学期间，她生娃了，很漂亮但不帅……</strong></p><p><strong>我苦笑、却又辗转反侧……</strong></p>]]></content>
      
      
      <categories>
          
          <category> 阅读 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>微信屏蔽的不只有网易云的『性格主导色』</title>
      <link href="/essay/qgtwsr/"/>
      <url>/essay/qgtwsr/</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1622096165024-de751f5a-0c8f-4d21-8fe9-da41dbf459bf.jpeg#crop=0&crop=0&crop=1&crop=1&height=393&id=gsk95&margin=%5Bobject%20Object%5D&name=Screenshot_20210527_141510_com.tencent.mm.jpg&originHeight=855&originWidth=1176&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=90586&status=done&style=stroke&title=&width=541" alt="Screenshot_20210527_141510_com.tencent.mm.jpg"></p><p>前言：网易云『性格主导色』活动页面遭微信屏蔽，在微信软件中点击活动页面会出现以下警告内容。我倒是见怪不怪，因为被屏蔽的不只有网易云的『性格主导色』，还有许许多多默不作声的外链，细想之，我个人的看法是与其说这是一种为了维护绿色上网环境，倒不如说是对当下自媒体崛起的一种流量上的恐慌……</p><p>现如今自媒体的崛起，广告的投放不单单是微信，短视频平台，某站平台等这些更加吸引广大用户的娱乐平台的崛起，说白了，自媒体的崛起给腾讯造成了流量上的恐慌，倘若在 B 站动漫里面推广一些产品，不比下面这种每天都看的心烦的广告好得多<img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1622097105798-a36f91ad-5589-4393-8a28-1d152e214c18.jpeg#crop=0&crop=0&crop=1&crop=1&height=52&id=y9K8r&originHeight=52&originWidth=52&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&title=&width=52">……<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1622095673079-588276fc-6d38-4886-8d9c-be90b62f0f63.png#crop=0&crop=0&crop=1&crop=1&height=267&id=C71oi&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1112&originWidth=1176&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=895660&status=done&style=stroke&title=&width=282" alt="image.png"><br>但是作为腾讯的这种机制是说为了维护用户体验，保留用户的权益……就我个人而言，我所知道的不仅仅是这个事件被屏蔽，还有之前的语雀链接在微信也不能打开，另外近期，在 QQ 里面我打开自己的网站，也是无效的，会提示非官方网站，许多博客站点都被屏蔽了<img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1622097255080-95d8e27c-375d-4629-b118-4f74c1273e9c.jpeg#crop=0&crop=0&crop=1&crop=1&height=58&id=XPRrb&originHeight=58&originWidth=62&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&title=&width=62">，总的来说，像上面那种广告是不会被屏蔽的，但是像一些外链现在十有八九是会被屏蔽的，不管这外链是低质量内容还是有不错内容的站点。</p><hr><hr><p>给自己测了下这个主导色，除了蓝色是对的，<strong>其他的都扯淡</strong>……<img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1622098043031-f48fc2c7-e8d9-416f-acd6-925a9528af2e.jpeg#crop=0&crop=0&crop=1&crop=1&height=48&id=ohPur&originHeight=48&originWidth=48&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&title=&width=48"></p><p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1622097912666-9ca03aa8-58f6-4f2e-a5e0-02145b87cb74.jpeg#crop=0&crop=0&crop=1&crop=1&height=3256&id=u0e97d042&margin=%5Bobject%20Object%5D&name=QQ%E5%9B%BE%E7%89%8720210527%E6%94%BE140915.jpg&originHeight=3256&originWidth=1176&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=520401&status=done&style=none&title=&width=1176" alt="QQ图片20210527放140915.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>《活着》</title>
      <link href="/essay/rcexdl/"/>
      <url>/essay/rcexdl/</url>
      
        <content type="html"><![CDATA[<div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">今天突然打开电脑里面的OneNote，发现以前还真写过不少东西……记得当时看这本书的时候，是在一个下午，一个最深的场景主人公他儿子死了，那个清晨黎明两三点，富贵从医院背着儿子往家走的时候，那个场景，针对心酸……有些许微风，夹杂着些许露水……阵阵凉意~</div><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1622032573540-7113b1ee-f2f6-419f-a75b-577f79de0a27.png#align=left&display=inline&height=366&margin=%5Bobject%20Object%5D&name=image.png&originHeight=732&originWidth=1343&size=191674&status=done&style=stroke&width=671.5" alt="image.png"></p><div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">18年写的</div><p>《活着》有感</p><p>每个人的人生都不一样，但是我们都活着。</p><p>——有感</p><p>“我知道黄昏正在准瞬即逝，黑夜从天而降了。我看到广阔的土地袒露着结实的胸膛，那是召唤的姿态，就像女人召唤者她们的儿女，土地召唤着黑夜来临。”活着是一种姿态，一种哲学，主人公福贵的人生是不幸的，在那个时代生活的艰辛，身边的人都离他而去，他几乎失去了一切，但是他活着，活得无奈，活得平庸，活的平凡，但活出了活着的意义。每个人对于活着都会有不同的人生感悟，我们的人生都不一样，因为我们都活着。</p><p>一个人的人生会因为一个人的一次行为而改变，而改变正是一个人活着意义所在。赌博让福贵的家庭从家财万贯到穷困潦倒，我一直觉得一个有故事的人一定会是曾经经历了什么。这次赔债过程中，福贵的爹爹也去世了，再混的子女遇见这等事谁不会心里塌了一片天，可能一切对于当时的他来讲很沉重，但是已经发生了。紧接着的又是妻子家珍被她爹带回家。这里我最感触深的是单纯，天真无邪的凤霞。送给龙二钱的时候，被国民党强制性的拉去充炮兵，就这样又和妻子孩子失去联系，在每天的炮火里，唯一的牵挂也只有老婆孩子了，对啊，人只有在最失意的时候才会想起身边的人，才会珍惜所拥有的，曾经对妻子的漠不关心现在会有牵挂，</p><p>在人民公社之后，百姓的日子日益变得破败不堪，我没有过也没有见过那时代的人，但是我长辈见过。小说有一个片段我觉得挺真实，凤霞用锄头挖到一个地瓜，但是却被村里其他人抢去，可能许多读者看到这不会有太多感触，但我是农村人，我对于此有些许的感触。在决定把凤霞送给别人家的时候，那真的真的是走到尽头了，<br>感触最深的就是，凤霞一天晚上偷偷跑回家，当福贵打开家门，凤霞望着自己的爹娘，说不出话，也听不见别人的话，当福贵决定送凤霞到城里人家时，他说了一句话“就是全家都饿死，也不送凤霞回去”，那一刻，我觉得很温暖，我相信，那是真正的父爱。活着为了什么，我觉得就是为了那些生活中的感动，一个人来到这个世界上，一定都是不容易的，有爱自己的父母，这些一切的一切都是会使得情大于现实。</p><p>原本已经不错的日子最后还是发生了不幸，儿子有庆离开了人世…那天晚上的福贵抱着有庆在回家的路上走走停停，停停走走，不是得停下坐在田埂看看自己的儿子，摸着儿子的脸庞，那时间我的眼眶真的湿了。不知道为什么，看到那时候我想起了我的父母…</p><p>原本凤霞和二喜的婚姻可以让这个不幸的家庭融入点暖和的血液，只是老天还是无情，凤霞的接生让小的来到这个世上，而大的永远离开了。读到这，我的内心真的很难让我往下看了，因为在父母而言，自己的子女都早于自己离开人世，白发人送黑发人，这是怎样的一种伤感，谁能接受这样的现实呢？只是活着终究要活着。之后的生活家珍走了，走的坦然，走之前的家珍说过一句“下辈子还做你的女人，下辈子还和你过”，让我觉得，这是历经苦难之后真正的爱情。爱情是两情相悦，是无言的天长地久，我敬重他们的真爱。福贵晚年也离不开现实的摧残，二喜、苦根也都离开人世了，苦根还那么小，那么的天真，再往后，就是福贵的和老牛的余生了。</p><p>远处的池塘边，有一头老牛在池边喝水，一位老人慢慢的走去。</p><p>尽管《活着》不是一部老师所要求的自传，但我恰恰觉得这是这个世界里许多平凡的人的自传，是那些这个社会中底层人民的生活真实写照，是那些渺小的生命，却能活出活着的意义。</p><p>福贵，福贵的牛，福贵的爹，龙二，家丁长根，老全，春生，家珍，凤霞，有庆，二喜，苦根<br>和龙二赌博输了家底导致生活破败，爹爹去世了，家珍被她爹带回家<br>被国名党拉去充炮兵，结识老全，春生，战败之际，投降回到家里见到老婆孩子<br>人民公社的成立以及之后的潦倒生活，文革<br>把凤霞送给别人家，最后还是情大于现实，留下凤霞一家人生活着<br>有庆献血离去，凤霞接生出血离去，家珍身子体弱离去，二喜工作事故离去，苦根吃豆子死去</p><p>反过来我们也可以说，<strong>因为我们都活着，从而我们的人生可以选择得不一样</strong>。</p><p>作者是以第一人称来塑造富贵这个人物形象，最后的最后只有富贵和他的老牛，不幸的人生，却告诉我们一个人生哲学：活着本身的意义就是活着。</p>]]></content>
      
      
      <categories>
          
          <category> 阅读 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>『境界的彼方』</title>
      <link href="/essay/wvwrcu/"/>
      <url>/essay/wvwrcu/</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.nlark.com/yuque/0/2021/jpg/1484158/1623940888474-c6aa4c62-7d9d-44df-b0ab-bd198c263434.jpg#align=left&display=inline&height=1128&margin=%5Bobject%20Object%5D&originHeight=1128&originWidth=2003&status=done&style=none&width=2003"></p><p>两个特殊身份的角色在一起发生的战斗纯爱番……栗山未来是有着“被诅咒血脉”的异界士少女，神原秋人是有着寄居在体内强大妖梦的半妖（最大的反派竟是主角自己<img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1623926928373-713cb502-b0c8-43a3-ae20-e45a5b4d6828.jpeg#align=left&display=inline&height=58&id=hqw9a&margin=%5Bobject%20Object%5D&originHeight=58&originWidth=79&status=done&style=none&width=79"></p><hr><p>虚幻之影一战<br>这算是秋人解开未来心结的剧情了，男主</p><p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1623927006789-0efec99a-7362-4b1f-8118-0f139cb451a3.jpeg#align=left&display=inline&height=481&id=jD2t5&margin=%5Bobject%20Object%5D&originHeight=481&originWidth=1024&status=done&style=none&width=1024"></p><p>当一个纯爱的人突然有一天闯进缺爱的人世界，这个人就不再孤独，他的余生也注定会因此而改变……</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1623927008770-1000842b-b921-4257-9ffe-3698a435f1ef.png#align=left&display=inline&height=1080&id=EBka9&margin=%5Bobject%20Object%5D&originHeight=1080&originWidth=1920&status=done&style=none&width=1920"></p><p>受过爱的缺爱的人做出的抉择往往不会像常人一样……</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1623927010160-66e09e34-7c86-4ac5-af4d-0097251e4f26.png#align=left&display=inline&height=1080&id=WSDbg&margin=%5Bobject%20Object%5D&originHeight=1080&originWidth=1920&status=done&style=none&width=1920"></p><p>这个是真的呆萌……</p><p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1623927004531-2156628e-e34f-415b-9ff1-a2b53d98f167.jpeg#align=left&display=inline&height=481&id=KMadh&margin=%5Bobject%20Object%5D&originHeight=481&originWidth=1024&status=done&style=none&width=1024"></p>]]></content>
      
      
      <categories>
          
          <category> 影视 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>最短路径算法（Dijkstra+Floyd）</title>
      <link href="/blog/rxx0ab/"/>
      <url>/blog/rxx0ab/</url>
      
        <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p><strong>校园最短路径实验</strong></p><p>1、给出校园中常用的几个点，如教室 550、文宗楼、三个食堂、大操场、宿舍楼（自定）、校门口、体育场；<br>2、画图并给出其邻接矩阵（请合作完成）；<br>3、用 floyd 算法求每对顶点间的最短路。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1622701735560-677cf8e1-e3f6-4c6a-9288-500eefaae6d4.png#align=left&display=inline&height=433&id=VrPJt&margin=%5Bobject%20Object%5D&name=image.png&originHeight=866&originWidth=1091&size=116035&status=done&style=stroke&width=545.5" alt="image.png"></p><hr><div style="background: #FFFBE6;padding:10px;border: 1px solid #C3C3C3;border-radius:5px;margin-bottom:5px;">迪杰斯特拉（Dijkstra）算法</div><p>Dijkstra 算法是经典的单源最短路径算法，用于计算源点到其它所有顶点的最短路径。在图 G=(V,E) 中，假设每条边 E[i] 的权值距离为 w[i]，找到由源点 v0 到其余各点的最短路径。<br>适用：不含负权重的图</p><p>算法当中，对图的遍历方式为 BFS（广度优先遍历）</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1622703321484-ea1fa3e2-34db-4827-8048-cd68231125cb.png#align=left&display=inline&height=113&id=MRDfH&margin=%5Bobject%20Object%5D&name=image.png&originHeight=225&originWidth=561&size=19395&status=done&style=none&width=280.5" alt="image.png"></p><pre><code class="cpp">/** * C++: Floyd算法获取最短路径(邻接矩阵) * */#include &lt;iomanip&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;bits/stdc++.h&gt;using namespace std;// 边的结构体class EData&#123;    public:        char start; // 边的起点        char end;   // 边的终点        int weight; // 边的权重    public:        EData()&#123;&#125;        EData(char s, char e, int w):start(s),end(e),weight(w)&#123;&#125;&#125;;class MatrixUDG &#123;    #define MAX    100    #define INF    (~(0x1&lt;&lt;31))        // 无穷大(即0X7FFFFFFF)    private:        char mVexs[MAX];    // 顶点集合        int mVexNum;             // 顶点数        int mEdgNum;             // 边数        int mMatrix[MAX][MAX];   // 邻接矩阵    public:        // 创建图(自己输入数据)        MatrixUDG();        // 创建图(用已提供的矩阵)        //MatrixUDG(char vexs[], int vlen, char edges[][2], int elen);        MatrixUDG(char vexs[], int vlen, int matrix[][9]);        ~MatrixUDG();        // 深度优先搜索遍历图        void DFS();        // 广度优先搜索（类似于树的层次遍历）        void BFS();        // prim最小生成树(从start开始生成最小生成树)        void prim(int start);        // 克鲁斯卡尔（Kruskal)最小生成树        void kruskal();        // Dijkstra最短路径        void dijkstra(int vs, int vexs[], int dist[]);        // Floyd最短路径        void floyd(int path[][MAX], int dist[][MAX]);        // 打印矩阵队列图        void print();    private:        // 读取一个输入字符        char readChar();        // 返回ch在mMatrix矩阵中的位置        int getPosition(char ch);        // 返回顶点v的第一个邻接顶点的索引，失败则返回-1        int firstVertex(int v);        // 返回顶点v相对于w的下一个邻接顶点的索引，失败则返回-1        int nextVertex(int v, int w);        // 深度优先搜索遍历图的递归实现        void DFS(int i, int *visited);        // 获取图中的边        EData* getEdges();        // 对边按照权值大小进行排序(由小到大)        void sortEdges(EData* edges, int elen);        // 获取i的终点        int getEnd(int vends[], int i);&#125;;/* * 创建图(自己输入数据) */MatrixUDG::MatrixUDG()&#123;    char c1, c2;    int i, j, weight, p1, p2;    // 输入&quot;顶点数&quot;和&quot;边数&quot;    cout &lt;&lt; &quot;input vertex number: &quot;;    cin &gt;&gt; mVexNum;    cout &lt;&lt; &quot;input edge number: &quot;;    cin &gt;&gt; mEdgNum;    if ( mVexNum &lt; 1 || mEdgNum &lt; 1 || (mEdgNum &gt; (mVexNum * (mVexNum-1))))    &#123;        cout &lt;&lt; &quot;input error: invalid parameters!&quot; &lt;&lt; endl;        return ;    &#125;    // 初始化&quot;顶点&quot;    for (i = 0; i &lt; mVexNum; i++)    &#123;        cout &lt;&lt; &quot;vertex(&quot; &lt;&lt; i &lt;&lt; &quot;): &quot;;        mVexs[i] = readChar();    &#125;    // 1. 初始化&quot;边&quot;的权值    for (i = 0; i &lt; mVexNum; i++)    &#123;        for (j = 0; j &lt; mVexNum; j++)        &#123;            if (i==j)                mMatrix[i][j] = 0;            else                mMatrix[i][j] = INF;        &#125;    &#125;    // 2. 初始化&quot;边&quot;的权值: 根据用户的输入进行初始化    for (i = 0; i &lt; mEdgNum; i++)    &#123;        // 读取边的起始顶点，结束顶点，权值        cout &lt;&lt; &quot;edge(&quot; &lt;&lt; i &lt;&lt; &quot;): &quot;;        c1 = readChar();        c2 = readChar();        cin &gt;&gt; weight;        p1 = getPosition(c1);        p2 = getPosition(c2);        if (p1==-1 || p2==-1)        &#123;            cout &lt;&lt; &quot;input error: invalid edge!&quot; &lt;&lt; endl;            return ;        &#125;        mMatrix[p1][p2] = weight;        mMatrix[p2][p1] = weight;    &#125;&#125;/* * 创建图(用已提供的矩阵) * * 参数说明： *     vexs  -- 顶点数组 *     vlen  -- 顶点数组的长度 *     matrix-- 矩阵(数据) */MatrixUDG::MatrixUDG(char vexs[], int vlen, int matrix[][9])&#123;    int i, j;    // 初始化&quot;顶点数&quot;和&quot;边数&quot;    mVexNum = vlen;    // 初始化&quot;顶点&quot;    for (i = 0; i &lt; mVexNum; i++)        mVexs[i] = vexs[i];    // 初始化&quot;边&quot;    for (i = 0; i &lt; mVexNum; i++)        for (j = 0; j &lt; mVexNum; j++)            mMatrix[i][j] = matrix[i][j];    // 统计边的数目    for (i = 0; i &lt; mVexNum; i++)        for (j = 0; j &lt; mVexNum; j++)            if (i!=j &amp;&amp; mMatrix[i][j]!=INF)                mEdgNum++;    mEdgNum /= 2;&#125;/* * 析构函数 */MatrixUDG::~MatrixUDG()&#123;&#125;/* * 返回ch在mMatrix矩阵中的位置 */int MatrixUDG::getPosition(char ch)&#123;    int i;    for(i=0; i&lt;mVexNum; i++)        if(mVexs[i]==ch)            return i;    return -1;&#125;/* * 读取一个输入字符 */char MatrixUDG::readChar()&#123;    char ch;    do &#123;        cin &gt;&gt; ch;    &#125; while(!((ch&gt;=&#39;a&#39;&amp;&amp;ch&lt;=&#39;z&#39;) || (ch&gt;=&#39;A&#39;&amp;&amp;ch&lt;=&#39;Z&#39;)));    return ch;&#125;/* * 返回顶点v的第一个邻接顶点的索引，失败则返回-1 */int MatrixUDG::firstVertex(int v)&#123;    int i;    if (v&lt;0 || v&gt;(mVexNum-1))        return -1;    for (i = 0; i &lt; mVexNum; i++)        if (mMatrix[v][i]!=0 &amp;&amp; mMatrix[v][i]!=INF)            return i;    return -1;&#125;/* * 返回顶点v相对于w的下一个邻接顶点的索引，失败则返回-1 */int MatrixUDG::nextVertex(int v, int w)&#123;    int i;    if (v&lt;0 || v&gt;(mVexNum-1) || w&lt;0 || w&gt;(mVexNum-1))        return -1;    for (i = w + 1; i &lt; mVexNum; i++)        if (mMatrix[v][i]!=0 &amp;&amp; mMatrix[v][i]!=INF)            return i;    return -1;&#125;/* * 深度优先搜索遍历图的递归实现 */void MatrixUDG::DFS(int i, int *visited)&#123;    int w;    visited[i] = 1;    cout &lt;&lt; mVexs[i] &lt;&lt; &quot; &quot;;    // 遍历该顶点的所有邻接顶点。若是没有访问过，那么继续往下走    for (w = firstVertex(i); w &gt;= 0; w = nextVertex(i, w))    &#123;        if (!visited[w])            DFS(w, visited);    &#125;&#125;/* * 深度优先搜索遍历图 */void MatrixUDG::DFS()&#123;    int i;    int visited[MAX];       // 顶点访问标记    // 初始化所有顶点都没有被访问    for (i = 0; i &lt; mVexNum; i++)        visited[i] = 0;    cout &lt;&lt; &quot;DFS: &quot;;    for (i = 0; i &lt; mVexNum; i++)    &#123;        //printf(&quot;\n== LOOP(%d)\n&quot;, i);        if (!visited[i])            DFS(i, visited);    &#125;    cout &lt;&lt; endl;&#125;/* * 广度优先搜索（类似于树的层次遍历） */void MatrixUDG::BFS()&#123;    int head = 0;    int rear = 0;    int queue[MAX];     // 辅组队列    int visited[MAX];   // 顶点访问标记    int i, j, k;    for (i = 0; i &lt; mVexNum; i++)        visited[i] = 0;    cout &lt;&lt; &quot;BFS: &quot;;    for (i = 0; i &lt; mVexNum; i++)    &#123;        if (!visited[i])        &#123;            visited[i] = 1;            cout &lt;&lt; mVexs[i] &lt;&lt; &quot; &quot;;            queue[rear++] = i;  // 入队列        &#125;        while (head != rear)        &#123;            j = queue[head++];  // 出队列            for (k = firstVertex(j); k &gt;= 0; k = nextVertex(j, k)) //k是为访问的邻接顶点            &#123;                if (!visited[k])                &#123;                    visited[k] = 1;                    cout &lt;&lt; mVexs[k] &lt;&lt; &quot; &quot;;                    queue[rear++] = k;                &#125;            &#125;        &#125;    &#125;    cout &lt;&lt; endl;&#125;/* * 打印矩阵队列图 */void MatrixUDG::print()&#123;    int i,j;    cout &lt;&lt; &quot;Martix Graph:&quot; &lt;&lt; endl;    for (i = 0; i &lt; mVexNum; i++)    &#123;        for (j = 0; j &lt; mVexNum; j++)            cout &lt;&lt; setw(10) &lt;&lt; mMatrix[i][j] &lt;&lt; &quot; &quot;;        cout &lt;&lt; endl;    &#125;&#125;/* * prim最小生成树 * * 参数说明： *   start -- 从图中的第start个元素开始，生成最小树 */void MatrixUDG::prim(int start)&#123;    int min,i,j,k,m,n,sum;    int index=0;         // prim最小树的索引，即prims数组的索引    char prims[MAX];     // prim最小树的结果数组    int weights[MAX];    // 顶点间边的权值    // prim最小生成树中第一个数是&quot;图中第start个顶点&quot;，因为是从start开始的。    prims[index++] = mVexs[start];    // 初始化&quot;顶点的权值数组&quot;，    // 将每个顶点的权值初始化为&quot;第start个顶点&quot;到&quot;该顶点&quot;的权值。    for (i = 0; i &lt; mVexNum; i++ )        weights[i] = mMatrix[start][i];    // 将第start个顶点的权值初始化为0。    // 可以理解为&quot;第start个顶点到它自身的距离为0&quot;。    weights[start] = 0;    for (i = 0; i &lt; mVexNum; i++)    &#123;        // 由于从start开始的，因此不需要再对第start个顶点进行处理。        if(start == i)            continue;        j = 0;        k = 0;        min = INF;        // 在未被加入到最小生成树的顶点中，找出权值最小的顶点。        while (j &lt; mVexNum)        &#123;            // 若weights[j]=0，意味着&quot;第j个节点已经被排序过&quot;(或者说已经加入了最小生成树中)。            if (weights[j] != 0 &amp;&amp; weights[j] &lt; min)            &#123;                min = weights[j];                k = j;            &#125;            j++;        &#125;        // 经过上面的处理后，在未被加入到最小生成树的顶点中，权值最小的顶点是第k个顶点。        // 将第k个顶点加入到最小生成树的结果数组中        prims[index++] = mVexs[k];        // 将&quot;第k个顶点的权值&quot;标记为0，意味着第k个顶点已经排序过了(或者说已经加入了最小树结果中)。        weights[k] = 0;        // 当第k个顶点被加入到最小生成树的结果数组中之后，更新其它顶点的权值。        for (j = 0 ; j &lt; mVexNum; j++)        &#123;            // 当第j个节点没有被处理，并且需要更新时才被更新。            if (weights[j] != 0 &amp;&amp; mMatrix[k][j] &lt; weights[j])                weights[j] = mMatrix[k][j];        &#125;    &#125;    // 计算最小生成树的权值    sum = 0;    for (i = 1; i &lt; index; i++)    &#123;        min = INF;        // 获取prims[i]在mMatrix中的位置        n = getPosition(prims[i]);        // 在vexs[0...i]中，找出到j的权值最小的顶点。        for (j = 0; j &lt; i; j++)        &#123;            m = getPosition(prims[j]);            if (mMatrix[m][n]&lt;min)                min = mMatrix[m][n];        &#125;        sum += min;    &#125;    // 打印最小生成树    cout &lt;&lt; &quot;PRIM(&quot; &lt;&lt; mVexs[start] &lt;&lt; &quot;)=&quot; &lt;&lt; sum &lt;&lt; &quot;: &quot;;    for (i = 0; i &lt; index; i++)        cout &lt;&lt; prims[i] &lt;&lt; &quot; &quot;;    cout &lt;&lt; endl;&#125;/* * 获取图中的边 */EData* MatrixUDG::getEdges()&#123;    int i,j;    int index=0;    EData *edges;    edges = new EData[mEdgNum];    for (i=0; i &lt; mVexNum; i++)    &#123;        for (j=i+1; j &lt; mVexNum; j++)        &#123;            if (mMatrix[i][j]!=INF)            &#123;                edges[index].start  = mVexs[i];                edges[index].end    = mVexs[j];                edges[index].weight = mMatrix[i][j];                index++;            &#125;        &#125;    &#125;    return edges;&#125;/* * 对边按照权值大小进行排序(由小到大) */void MatrixUDG::sortEdges(EData* edges, int elen)&#123;    int i,j;    for (i=0; i&lt;elen; i++)    &#123;        for (j=i+1; j&lt;elen; j++)        &#123;            if (edges[i].weight &gt; edges[j].weight)            &#123;                // 交换&quot;边i&quot;和&quot;边j&quot;                swap(edges[i], edges[j]);            &#125;        &#125;    &#125;&#125;/* * 获取i的终点 */int MatrixUDG::getEnd(int vends[], int i)&#123;    while (vends[i] != 0)        i = vends[i];    return i;&#125;/* * 克鲁斯卡尔（Kruskal)最小生成树 */void MatrixUDG::kruskal()&#123;    int i,m,n,p1,p2;    int length;    int index = 0;          // rets数组的索引    int vends[MAX]=&#123;0&#125;;     // 用于保存&quot;已有最小生成树&quot;中每个顶点在该最小树中的终点。    EData rets[MAX];        // 结果数组，保存kruskal最小生成树的边    EData *edges;           // 图对应的所有边    // 获取&quot;图中所有的边&quot;    edges = getEdges();    // 将边按照&quot;权&quot;的大小进行排序(从小到大)    sortEdges(edges, mEdgNum);    for (i=0; i&lt;mEdgNum; i++)    &#123;        p1 = getPosition(edges[i].start);      // 获取第i条边的&quot;起点&quot;的序号        p2 = getPosition(edges[i].end);        // 获取第i条边的&quot;终点&quot;的序号        m = getEnd(vends, p1);                 // 获取p1在&quot;已有的最小生成树&quot;中的终点        n = getEnd(vends, p2);                 // 获取p2在&quot;已有的最小生成树&quot;中的终点        // 如果m!=n，意味着&quot;边i&quot;与&quot;已经添加到最小生成树中的顶点&quot;没有形成环路        if (m != n)        &#123;            vends[m] = n;                       // 设置m在&quot;已有的最小生成树&quot;中的终点为n            rets[index++] = edges[i];           // 保存结果        &#125;    &#125;    delete[] edges;    // 统计并打印&quot;kruskal最小生成树&quot;的信息    length = 0;    for (i = 0; i &lt; index; i++)        length += rets[i].weight;    cout &lt;&lt; &quot;Kruskal=&quot; &lt;&lt; length &lt;&lt; &quot;: &quot;;    for (i = 0; i &lt; index; i++)        cout &lt;&lt; &quot;(&quot; &lt;&lt; rets[i].start &lt;&lt; &quot;,&quot; &lt;&lt; rets[i].end &lt;&lt; &quot;) &quot;;    cout &lt;&lt; endl;&#125;/* * Dijkstra最短路径。 * 即，统计图中&quot;顶点vs&quot;到其它各个顶点的最短路径。 * * 参数说明： *       vs -- 起始顶点(start vertex)。即计算&quot;顶点vs&quot;到其它顶点的最短路径。 *     prev -- 前驱顶点数组。即，prev[i]的值是&quot;顶点vs&quot;到&quot;顶点i&quot;的最短路径所经历的全部顶点中，位于&quot;顶点i&quot;之前的那个顶点。 *     dist -- 长度数组。即，dist[i]是&quot;顶点vs&quot;到&quot;顶点i&quot;的最短路径的长度。 */void MatrixUDG::dijkstra(int vs, int prev[], int dist[])&#123;    int i,j,k;    int min;    int tmp;    int flag[MAX];      // flag[i]=1表示&quot;顶点vs&quot;到&quot;顶点i&quot;的最短路径已成功获取。    // 初始化    for (i = 0; i &lt; mVexNum; i++)    &#123;        flag[i] = 0;              // 顶点i的最短路径还没获取到。        prev[i] = 0;              // 顶点i的前驱顶点为0。        dist[i] = mMatrix[vs][i]; // 顶点i的最短路径为&quot;顶点vs&quot;到&quot;顶点i&quot;的权。    &#125;    // 对&quot;顶点vs&quot;自身进行初始化    flag[vs] = 1;    dist[vs] = 0;    // 遍历mVexNum-1次；每次找出一个顶点的最短路径。    for (i = 1; i &lt; mVexNum; i++)    &#123;        // 寻找当前最小的路径；        // 即，在未获取最短路径的顶点中，找到离vs最近的顶点(k)。        min = INF;        for (j = 0; j &lt; mVexNum; j++)        &#123;            if (flag[j]==0 &amp;&amp; dist[j]&lt;min)            &#123;                min = dist[j];                k = j;            &#125;        &#125;        // 标记&quot;顶点k&quot;为已经获取到最短路径        flag[k] = 1;        // 修正当前最短路径和前驱顶点        // 即，当已经&quot;顶点k的最短路径&quot;之后，更新&quot;未获取最短路径的顶点的最短路径和前驱顶点&quot;。        for (j = 0; j &lt; mVexNum; j++)        &#123;            tmp = (mMatrix[k][j]==INF ? INF : (min + mMatrix[k][j]));            if (flag[j] == 0 &amp;&amp; (tmp  &lt; dist[j]) )            &#123;                dist[j] = tmp;                prev[j] = k;            &#125;        &#125;    &#125;    // 打印dijkstra最短路径的结果    cout &lt;&lt; &quot;dijkstra(&quot; &lt;&lt; mVexs[vs] &lt;&lt; &quot;): &quot; &lt;&lt; endl;    for (i = 0; i &lt; mVexNum; i++)        cout &lt;&lt; &quot;  shortest(&quot; &lt;&lt; mVexs[vs] &lt;&lt; &quot;, &quot; &lt;&lt; mVexs[i] &lt;&lt; &quot;)=&quot; &lt;&lt; dist[i] &lt;&lt; endl;&#125;/* * floyd最短路径。 * 即，统计图中各个顶点间的最短路径。 * * 参数说明： *     path -- 路径。path[i][j]=k表示，&quot;顶点i&quot;到&quot;顶点j&quot;的最短路径会经过顶点k。 *     dist -- 长度数组。即，dist[i][j]=sum表示，&quot;顶点i&quot;到&quot;顶点j&quot;的最短路径的长度是sum。 */void MatrixUDG::floyd(int path[][MAX], int dist[][MAX])&#123;    int i,j,k;    int tmp;    // 初始化    for (i = 0; i &lt; mVexNum; i++)    &#123;        for (j = 0; j &lt; mVexNum; j++)        &#123;            dist[i][j] = mMatrix[i][j];    // &quot;顶点i&quot;到&quot;顶点j&quot;的路径长度为&quot;i到j的权值&quot;。            path[i][j] = j;                // &quot;顶点i&quot;到&quot;顶点j&quot;的最短路径是经过顶点j。        &#125;    &#125;    // 计算最短路径    for (k = 0; k &lt; mVexNum; k++)    &#123;        for (i = 0; i &lt; mVexNum; i++)        &#123;            for (j = 0; j &lt; mVexNum; j++)            &#123;                // 如果经过下标为k顶点路径比原两点间路径更短，则更新dist[i][j]和path[i][j]                tmp = (dist[i][k]==INF || dist[k][j]==INF) ? INF : (dist[i][k] + dist[k][j]);                if (dist[i][j] &gt; tmp)                &#123;                    // &quot;i到j最短路径&quot;对应的值设，为更小的一个(即经过k)                    dist[i][j] = tmp;                    // &quot;i到j最短路径&quot;对应的路径，经过k                    path[i][j] = path[i][k];                &#125;            &#125;        &#125;    &#125;    char dot[] = &#123;&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;, &#39;G&#39;, &#39;H&#39;, &#39;I&#39;&#125;;    // 打印floyd最短路径的结果    cout &lt;&lt; &quot;floyd各个地点的最短路径矩阵如下: &quot; &lt;&lt; endl;    cout &lt;&lt; &quot;    &quot;;    for (int k = 0;k&lt;9;k++)&#123;        cout &lt;&lt; dot[k] &lt;&lt; &quot;    &quot;;    &#125;    cout &lt;&lt; &quot;\n&quot;;    for (i = 0; i &lt; mVexNum; i++)&#123;        cout &lt;&lt; dot[i] &lt;&lt; &quot;: &quot;;        for (j = 0; j &lt; mVexNum; j++)            cout &lt;&lt; setw(2) &lt;&lt; dist[i][j] &lt;&lt; &quot;  &quot;;        cout &lt;&lt; endl;    &#125;&#125;int main()&#123;    int prev[MAX] = &#123;0&#125;;    int dist[MAX] = &#123;0&#125;;    int path[MAX][MAX] = &#123;0&#125;;    // 用于保存floyd路径    int floy[MAX][MAX] = &#123;0&#125;;    // 用于保存floyd长度    char vexs[] = &#123;&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;, &#39;G&#39;, &#39;H&#39;, &#39;I&#39;&#125;;    int matrix[][9] = &#123;                      /*A*//*B*//*C*//*D*//*E*//*F*//*G*//*H*//*I*/      /*A西门*/     &#123;   0,  615, 435, 210, 790,  INF,  INF, INF, INF&#125;,      /*B550教室*/  &#123; 615,   0,  144, 620, 380,   822, INF, INF, INF&#125;,      /*C文宗楼*/   &#123; 435,  144,   0,   INF,   265,   INF, INF, INF, INF&#125;,      /*D二餐*/     &#123; 210, 620,   INF,   0,   480, INF, INF, INF, 170&#125;,      /*E图书馆*/   &#123; 790, 380,   265,   480,   0,   620,   735, 310, 700&#125;,      /*F北门*/     &#123; INF, 822,   INF,   INF,   620,   0,   500, INF, INF&#125;,      /*G体育馆*/   &#123; INF, INF,   INF,   INF,   735,   500,   0, 556, INF&#125;,      /*H一餐*/     &#123;  INF,   INF,   INF, INF,   310,   INF,   556, 0, 420&#125;,      /*I16号楼*/   &#123;  INF, INF, INF, 170,   700,   INF,   INF, 420, 0&#125;&#125;;    int vlen = sizeof(vexs)/sizeof(vexs[0]);    MatrixUDG* pG;    // 自定义&quot;图&quot;(输入矩阵队列)    //pG = new MatrixUDG();    // 采用已有的&quot;图&quot;    pG = new MatrixUDG(vexs, vlen, matrix);    //pG-&gt;print();   // 打印图    //pG-&gt;DFS();     // 深度优先遍历    //pG-&gt;BFS();     // 广度优先遍历    //pG-&gt;prim(0);   // prim算法生成最小生成树    //pG-&gt;kruskal(); // Kruskal算法生成最小生成树    // dijkstra算法获取&quot;第4个顶点&quot;到其它各个顶点的最短距离    //pG-&gt;dijkstra(3, prev, dist);    // floyd算法获取各个顶点之间的最短距离    pG-&gt;floyd(path, floy);    return 0;&#125;</code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://houbb.github.io/2020/01/23/data-struct-learn-03-graph-dijkstra">图最短路径算法之迪杰斯特拉算法（Dijkstra）</a></li><li><a href="https://www.cnblogs.com/skywang12345/p/3711526.html">Floyd 算法(二)之 C++详解</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 贪心算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>图的遍历——DFS（深度优先）、BFS（广度优先）</title>
      <link href="/blog/ztiag3/"/>
      <url>/blog/ztiag3/</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1621307069176-74d6900b-6edd-4e7a-b761-789df7a17cfe.png#crop=0&crop=0&crop=1&crop=1&height=273&id=W9sKH&margin=%5Bobject%20Object%5D&name=image.png&originHeight=545&originWidth=1126&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=159926&status=done&style=stroke&title=&width=563" alt="image.png"></p><div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">前言：用邻接矩阵和邻接表两种图的存储形式实现DFS、BFS算法，并附例子实现。总的来说，邻接矩阵比较好处理，没有邻接表处理那么复杂，但是数组永远不能规避的一个缺点就是内存的占用较邻接表高。</div><h2 id="一、深度优先搜索算法（Depth-First-Search）"><a href="#一、深度优先搜索算法（Depth-First-Search）" class="headerlink" title="一、深度优先搜索算法（Depth-First-Search）"></a>一、深度优先搜索算法（Depth-First-Search）</h2><h3 id="算法说明"><a href="#算法说明" class="headerlink" title="算法说明"></a>算法说明</h3><p><strong>访问步骤：</strong></p><blockquote><ul><li>访问顶点 v；</li><li>依次从 v 的未被访问的邻接点出发，对图进行深度优先遍历；直至图中和 v 有路径相通的顶点都被访问；</li><li>若此时图中尚有顶点未被访问，则从一个未被访问的顶点出发，重新进行深度优先遍历，直到图中所有顶点均被访问过为止。</li></ul></blockquote><p><strong>核心代码就是利用递归，以及标志数组的设定，每次访问数组元素的那一行，对那行链表进行遍历，每遍历一个链表结点，就将“其”所在的那个数组元素“点亮”。如果标志数组里面的所有元素都被访问了，说明遍历完了</strong></p><p><strong>深度优先搜索类似于树里面遍历算法当中的先序遍历。</strong></p><h3 id="邻接矩阵的-DFS-代码"><a href="#邻接矩阵的-DFS-代码" class="headerlink" title="邻接矩阵的 DFS 代码"></a>邻接矩阵的 DFS 代码</h3><p>以这个无向图为例<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1621329549870-b2fd8a63-a532-4860-8e46-a79cc52a7e0f.png#crop=0&crop=0&crop=1&crop=1&height=156&id=Xvwlk&margin=%5Bobject%20Object%5D&name=image.png&originHeight=311&originWidth=394&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=45059&status=done&style=stroke&title=&width=197" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1621329584016-32d023fe-dc14-4c0d-90e1-7afe6fcc9cd2.png#crop=0&crop=0&crop=1&crop=1&height=106&id=XY5Cd&margin=%5Bobject%20Object%5D&name=image.png&originHeight=212&originWidth=455&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=9480&status=done&style=none&title=&width=227.5" alt="image.png"></p><pre><code class="cpp">#include&lt;bits/stdc++.h&gt;using namespace std;#define MVNum 100#define MaxInt 32767typedef char VerTexType;typedef int ArcType;/** * 邻接矩阵存储形式 */typedef struct &#123;    /* data */    VerTexType vexs[MVNum]; //顶点表    ArcType arcs[MVNum][MVNum]; //邻接矩阵    int vexnum, arcnum; //图的当前顶点和边数&#125;AMGraph;/** * 确定v在G中的位置，即顶点数组的下标 */int LocateVex(AMGraph &amp;G, char v) &#123;    for (int i = 0; i &lt; G.vexnum;i++) &#123;        if (v == G.vexs[i])&#123;            return i;        &#125;    &#125;&#125;/** * 如果创建无向图 */void CreateUDN(AMGraph &amp;G) &#123;    // 采用邻接矩阵表示法，创建无向图G    cout &lt;&lt; &quot;请输入顶点数和边数：&quot; &lt;&lt; endl;    cin &gt;&gt; G.vexnum &gt;&gt; G.arcnum; //输入顶点数和边数    // 初始化顶点    for (int i = 0; i &lt; G.vexnum;i++)&#123;        cout &lt;&lt; &quot;请输入第&quot; &lt;&lt; i &lt;&lt; &quot;个顶点值&quot; &lt;&lt; endl;        cin &gt;&gt; G.vexs[i];    &#125;    // 初始化邻接矩阵的边的权值为最大值    for (int i = 0; i &lt; G.vexnum;i++) &#123;        for (int j = 0; j &lt; G.vexnum;j++) &#123;            G.arcs[i][j] = 0;        &#125;    &#125;    // 构造邻接矩阵    for (int k = 0; k &lt; G.arcnum;k++) &#123;        cout &lt;&lt; &quot;请输入每条边所依附的顶点：&quot; &lt;&lt; endl;        char v1, v2;        int w = 1; //一条边所依附的顶点和权值        cin &gt;&gt; v1 &gt;&gt; v2;        int i = LocateVex(G, v1);        int j = LocateVex(G, v2);        G.arcs[i][j] = w;        G.arcs[j][i] = w;    &#125;&#125;/** * 打印输出图 */void Display(AMGraph &amp;G) &#123;    for (int i = 0; i &lt; G.vexnum;i++) &#123;        for (int j = 0; j &lt; G.vexnum;j++) &#123;            cout &lt;&lt; G.arcs[i][j] &lt;&lt; &quot; &quot;;        &#125;        cout &lt;&lt; endl;    &#125;&#125;//----邻接矩阵的DFS遍历----//访问标志数组，其初值为falsebool visited[MVNum];/** * 图G为邻接矩阵类型，从第v个顶点出发深度优先搜索遍历图G */void DFS_AM(AMGraph &amp;G, int v) &#123;    //访问第v个顶点，并置访问标志数组相应分量值为true    cout&lt;&lt;v;    visited[v] = true;    //依次检查邻接矩阵v所在的行    for(int w = 0; w &lt; G.vexnum; w++)        //G.arcs[v][w] != 0表示w是v的邻接点，!visited[w]表示未访问到        if((G.arcs[v][w] != 0) &amp;&amp; (!visited[w]))            DFS_AM(G, w);    //递归调用DFS_AM&#125;/** * 图G的储存类型任意，对非连通图G做深度优先遍历 */void DFSTraverse(AMGraph &amp;G) &#123;    //访问标志数组初始化    for(int v = 0; v &lt; G.vexnum; v++)        visited[v] = false;    //循环调用DFS    for(int v = 0; v &lt; G.vexnum; v++)        if(!visited[v])            DFS_AM(G, v); //对尚未访问的顶点调用DFS&#125;int main() &#123;    AMGraph test;    CreateUDN(test);    Display(test);    DFSTraverse(test);    return 0;&#125;</code></pre><h3 id="邻接表的-DFS-代码"><a href="#邻接表的-DFS-代码" class="headerlink" title="邻接表的 DFS 代码"></a>邻接表的 DFS 代码</h3><p>举之前上课的一张 PPT 例子（元素插入为后插法）<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1621333199678-46b6841b-415b-46e8-b0f6-0d0407284b15.png#crop=0&crop=0&crop=1&crop=1&height=413&id=HmOsr&margin=%5Bobject%20Object%5D&name=image.png&originHeight=826&originWidth=1108&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=102467&status=done&style=none&title=&width=554" alt="image.png"><br>结果<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1621333246481-117ec0ea-ab95-43be-ac13-75712fdf1e2b.png#crop=0&crop=0&crop=1&crop=1&height=107&id=KjOYY&margin=%5Bobject%20Object%5D&name=image.png&originHeight=214&originWidth=444&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=26415&status=done&style=none&title=&width=222" alt="image.png"></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;#define MVNum 100#define MaxInt 32767typedef char VerTexType;typedef int OtherInfo;/** * 邻接表存储 *//** * 存储结构 */typedef struct ArcNode &#123;  //边结点    int adjvex;  //该边所指向的结点的位置    struct ArcNode *nextarc; //指向下一条边的指针    OtherInfo info;   //和边相关的其他信息&#125;ArcNode;typedef struct VNode &#123;   //顶点信息    VerTexType data;  //数据域，存放顶点vi的名称或其他有关信息    ArcNode *firstarc;  //指向第一条依附该顶点的边的指针&#125;VNode, AdjList[MVNum]; //AdjList表示邻接表的类型typedef struct &#123;    AdjList vertices;    int vexnum, arcnum; //图当前的顶点数和边数&#125;ALGragh; //邻接表（Adjacency List）/** * 找到v顶点在图的顶点数组中的位置 */int LocateVex(ALGragh &amp;G, char v) &#123;    for (int i = 0; i &lt; G.vexnum;i++) &#123;        if (v == G.vertices[i].data) &#123;            return i;        &#125;    &#125;&#125;/** * 邻接表创建无向图 */void CreateUDG(ALGragh &amp;G) &#123;    cout &lt;&lt; &quot;请输入顶点数和边数：&quot; &lt;&lt; endl;    cin &gt;&gt; G.vexnum &gt;&gt; G.arcnum; // 邻接表的顶点数和边数    // 初始化顶点数组    for (int i = 0; i &lt; G.vexnum;i++) &#123;        cin &gt;&gt; G.vertices[i].data; // 初始化顶点数组里面的结点data        G.vertices[i].firstarc = NULL; // 初始化顶点数组里面的结点next域    &#125;    // 初始化所有的边    for (int k = 0; k &lt; G.arcnum;k++) &#123;        char v1, v2;        cout &lt;&lt; &quot;请输入每条边所依附的顶点：&quot; &lt;&lt; endl;        cin &gt;&gt; v1 &gt;&gt; v2;        int i = LocateVex(G, v1); // 找到v1在顶点数组的下标        int j = LocateVex(G, v2); // 找到v2在顶点数组的下标        // 下面建立p1和p2是因为无向图，如果是有向图就没必要了只需要p1        // 前插        ArcNode *p1 = new ArcNode;        p1-&gt;adjvex = j;        p1-&gt;nextarc = G.vertices[i].firstarc;        G.vertices[i].firstarc = p1;        ArcNode *p2 = new ArcNode;        p2-&gt;adjvex = i;        p2-&gt;nextarc = G.vertices[j].firstarc;        G.vertices[j].firstarc = p2;    &#125;&#125;/** * 打印输出图 */void Display(ALGragh &amp;G) &#123;    for (int i = 0; i &lt; G.vexnum;i++) &#123;        cout &lt;&lt; &quot;结点&quot; &lt;&lt; i &lt;&lt; &quot;：&quot;;        // 复制选中的节点数组中的结点        VNode p;        p = G.vertices[i];        if (p.firstarc != NULL)&#123;            ArcNode *temp;            temp = G.vertices[i].firstarc;            while (temp != NULL) &#123;                cout &lt;&lt; temp-&gt;adjvex&lt;&lt;&quot; &quot;;                temp = temp-&gt;nextarc;            &#125;            cout &lt;&lt; &quot;\n&quot;;        &#125;    &#125;&#125;//----邻接表的DFS遍历----bool visited[MVNum];                                                    //访问标志数组，其初值为falsevoid DFS_AL(ALGragh G, int v)&#123;//图G为邻接表类型，从从第v个顶点出发深度优先搜索遍历图G    cout&lt;&lt;v;                                                            //访问第v个顶点，并置访问标志数组相应分量值为true    visited[v] = true;    ArcNode *p;    p = G.vertices[v].firstarc;                                         //p指向v的边链表的第一个边结点    while(p != NULL)    &#123;       int w = p-&gt;adjvex;                                               //w是v的邻接点        if(!visited[w])                                                 //如果w未访问            DFS_AL(G, w);                                               //递归调用DFS_AL        p = p-&gt;nextarc;                                                 //p指向下一个结点    &#125;&#125;void DFSTraverse(ALGragh G)&#123;//图G的储存类型任意，对非连通图G做深度优先遍历    for(int v = 0; v &lt; G.vexnum; v++)                                   //访问标志数组初始化        visited[v] = false;    for(int v = 0; v &lt; G.vexnum; v++)                                   //循环调用DFS        if(!visited[v])            DFS_AL(G, v);                                                  //对尚未访问的顶点调用DFS&#125;int main() &#123;    ALGragh test;    CreateUDG(test);    // Display(test);    DFSTraverse(test);&#125;</code></pre><h2 id="二、广度优先搜索算法（Breadth-First-Search）"><a href="#二、广度优先搜索算法（Breadth-First-Search）" class="headerlink" title="二、广度优先搜索算法（Breadth-First-Search）"></a>二、广度优先搜索算法（Breadth-First-Search）</h2><h3 id="算法说明-1"><a href="#算法说明-1" class="headerlink" title="算法说明"></a>算法说明</h3><p>从某个顶点 V0 出发，并在访问此顶点之后依次访问 V0 的所有未被访问过的邻接点，之后按这些顶点被访问的先后次序依次访问它们的邻接点，直至图中所有和 V0 有路径相通的顶点都被访问到。</p><p>若此时图中尚有顶点未被访问，则另选图中一个未曾被访问的顶点作起始点，重复上述过程，直至图中所有顶点都被访问到为止。</p><p><strong>在树遍历中类似层次遍历。</strong></p><h3 id="邻接矩阵的-BFS-代码"><a href="#邻接矩阵的-BFS-代码" class="headerlink" title="邻接矩阵的 BFS 代码"></a>邻接矩阵的 BFS 代码</h3><p>还是这个例子<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1621329549870-b2fd8a63-a532-4860-8e46-a79cc52a7e0f.png#crop=0&crop=0&crop=1&crop=1&height=156&id=bbWIn&margin=%5Bobject%20Object%5D&name=image.png&originHeight=311&originWidth=394&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=45059&status=done&style=stroke&title=&width=197" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1621338913834-3f2453f3-c56d-4401-9e26-2de805587a04.png#crop=0&crop=0&crop=1&crop=1&height=125&id=hRiOt&margin=%5Bobject%20Object%5D&name=image.png&originHeight=250&originWidth=457&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=12403&status=done&style=none&title=&width=228.5" alt="image.png"></p><pre><code class="cpp">#include&lt;bits/stdc++.h&gt;using namespace std;#define MVNum 100#define MaxInt 32767typedef char VerTexType;typedef int ArcType;/** * 邻接矩阵的bfs代码 */typedef struct &#123;    /* data */    VerTexType vexs[MVNum]; //顶点表    ArcType arcs[MVNum][MVNum]; //邻接矩阵    int vexnum, arcnum; //图的当前顶点和边数&#125;AMGraph;/** * 确定v在G中的位置，即顶点数组的下标 */int LocateVex(AMGraph &amp;G, char v) &#123;    for (int i = 0; i &lt; G.vexnum;i++) &#123;        if (v == G.vexs[i])&#123;            return i;        &#125;    &#125;&#125;/** * 创建无向网 * 如果创建无向图 */void CreateUDN(AMGraph &amp;G) &#123;    // 采用邻接矩阵表示法，创建无向图G    cout &lt;&lt; &quot;请输入顶点数和边数：&quot; &lt;&lt; endl;    cin &gt;&gt; G.vexnum &gt;&gt; G.arcnum; //输入顶点数和边数    // 初始化顶点    for (int i = 0; i &lt; G.vexnum;i++)&#123;        cout &lt;&lt; &quot;请输入第&quot; &lt;&lt; i &lt;&lt; &quot;个顶点值&quot; &lt;&lt; endl;        cin &gt;&gt; G.vexs[i];    &#125;    // 初始化邻接矩阵的边的权值为最大值    for (int i = 0; i &lt; G.vexnum;i++) &#123;        for (int j = 0; j &lt; G.vexnum;j++) &#123;            G.arcs[i][j] = 0;        &#125;    &#125;    // 构造邻接矩阵    for (int k = 0; k &lt; G.arcnum;k++) &#123;        cout &lt;&lt; &quot;请输入每条边所依附的顶点：&quot; &lt;&lt; endl;        char v1, v2;        int w = 1; //一条边所依附的顶点和权值        cin &gt;&gt; v1 &gt;&gt; v2;        int i = LocateVex(G, v1);        int j = LocateVex(G, v2);        G.arcs[i][j] = w;        G.arcs[j][i] = w;    &#125;&#125;/** * 打印输出图 */void Display(AMGraph &amp;G) &#123;    for (int i = 0; i &lt; G.vexnum;i++) &#123;        for (int j = 0; j &lt; G.vexnum;j++) &#123;            cout &lt;&lt; G.arcs[i][j] &lt;&lt; &quot; &quot;;        &#125;        cout &lt;&lt; endl;    &#125;&#125;//----邻接矩阵的BFS遍历----bool visited[MVNum];void BFS_AM(AMGraph G, int v)&#123;//按广度优先非递归遍历连通图G    cout&lt;&lt;v;    visited[v] = true; //访问第v个顶点，并置访问标志数组相应分量值为true    queue&lt;int&gt; Q;    Q.push(v);    while(!Q.empty())    &#123;        int u = Q.front(); //队头元素出队并置为u        Q.pop();        for(int w = 0; w &lt; G.vexnum; w++)            if((G.arcs[u][w] != 0) &amp;&amp; (!visited[w])) //G.arcs[v][w] != 0表示w是v的邻接点，!visited[w]表示未访问到                                            //w为u的尚未访问的邻接顶点            &#123;                cout&lt;&lt;w;                visited[w] = true; //访问w，并置访问标志数组相应分量值为true                Q.push(w); //w进队            &#125;    &#125;&#125;void BFSTraverse(AMGraph &amp;G) &#123;    //访问标志数组初始化    for(int v = 0; v &lt; G.vexnum; v++)        visited[v] = false;    //循环调用BFS    for(int v = 0; v &lt; G.vexnum; v++)        if(!visited[v])            BFS_AM(G, v); //对尚未访问的顶点调用BFS&#125;int main() &#123;    AMGraph test;    CreateUDN(test);    Display(test);    // DFSTraverse(test);    BFSTraverse(test);    return 0;&#125;</code></pre><h3 id="邻接表的-BFS-代码"><a href="#邻接表的-BFS-代码" class="headerlink" title="邻接表的 BFS 代码"></a>邻接表的 BFS 代码</h3><p>还用和 DFS 一样的例子<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1621339344717-55530db9-253b-451d-af57-b591ff17353e.png#crop=0&crop=0&crop=1&crop=1&height=311&id=I73u9&margin=%5Bobject%20Object%5D&name=image.png&originHeight=621&originWidth=834&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=114652&status=done&style=none&title=&width=417" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1621390194148-da12a2e4-1f85-491b-9e53-3848ac4e4a4c.png#crop=0&crop=0&crop=1&crop=1&height=80&id=iul50&margin=%5Bobject%20Object%5D&name=image.png&originHeight=159&originWidth=334&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=6124&status=done&style=none&title=&width=167" alt="image.png"></p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;#define MVNum 100#define MaxInt 32767typedef char VerTexType;typedef int OtherInfo;/** * 邻接表的bfs代码 *//** * 存储结构 */typedef struct ArcNode &#123;  //边结点    int adjvex;  //该边所指向的结点的位置    struct ArcNode *nextarc; //指向下一条边的指针    OtherInfo info;   //和边相关的其他信息&#125;ArcNode;typedef struct VNode &#123;   //顶点信息    VerTexType data;  //数据域，存放顶点vi的名称或其他有关信息    ArcNode *firstarc;  //指向第一条依附该顶点的边的指针&#125;VNode, AdjList[MVNum]; //AdjList表示邻接表的类型typedef struct &#123;    AdjList vertices;    int vexnum, arcnum; //图当前的顶点数和边数&#125;ALGraph; //邻接表（Adjacency List）/** * 找到v顶点在图的顶点数组中的位置 */int LocateVex(ALGraph &amp;G, char v) &#123;    for (int i = 0; i &lt; G.vexnum;i++) &#123;        if (v == G.vertices[i].data) &#123;            return i;        &#125;    &#125;&#125;/** * 邻接表创建无向图 */void CreateUDG(ALGraph &amp;G) &#123;    cout &lt;&lt; &quot;请输入顶点数和边数：&quot; &lt;&lt; endl;    cin &gt;&gt; G.vexnum &gt;&gt; G.arcnum; // 邻接表的顶点数和边数    // 初始化顶点数组    for (int i = 0; i &lt; G.vexnum;i++) &#123;        cin &gt;&gt; G.vertices[i].data; // 初始化顶点数组里面的结点data        G.vertices[i].firstarc = NULL; // 初始化顶点数组里面的结点next域    &#125;    // 初始化所有的边    for (int k = 0; k &lt; G.arcnum;k++) &#123;        char v1, v2;        cout &lt;&lt; &quot;请输入每条边所依附的顶点：&quot; &lt;&lt; endl;        cin &gt;&gt; v1 &gt;&gt; v2;        int i = LocateVex(G, v1); // 找到v1在顶点数组的下标        int j = LocateVex(G, v2); // 找到v2在顶点数组的下标        // 下面建立p1和p2是因为无向图，如果是有向图就没必要了只需要p1        // 前插        ArcNode *p1 = new ArcNode;        p1-&gt;adjvex = j;        p1-&gt;nextarc = G.vertices[i].firstarc;        G.vertices[i].firstarc = p1;        ArcNode *p2 = new ArcNode;        p2-&gt;adjvex = i;        p2-&gt;nextarc = G.vertices[j].firstarc;        G.vertices[j].firstarc = p2;    &#125;&#125;/** * 打印输出图 */void Display(ALGraph &amp;G) &#123;    for (int i = 0; i &lt; G.vexnum;i++) &#123;        cout &lt;&lt; &quot;结点&quot; &lt;&lt; i &lt;&lt; &quot;：&quot;;        // 复制选中的节点数组中的结点        VNode p;        p = G.vertices[i];        if (p.firstarc != NULL)&#123;            ArcNode *temp;            temp = G.vertices[i].firstarc;            while (temp != NULL) &#123;                cout &lt;&lt; temp-&gt;adjvex&lt;&lt;&quot; &quot;;                temp = temp-&gt;nextarc;            &#125;            cout &lt;&lt; &quot;\n&quot;;        &#125;    &#125;&#125;//----邻接表的BFS遍历----bool visited[MVNum];int FirstAdjvex(ALGraph&amp; G, int u)&#123;    int w = G.vertices[u].firstarc-&gt;adjvex;    return w;&#125;int NextAdjVex(ALGraph&amp; G, int u, int w)&#123;    ArcNode *temp = G.vertices[u].firstarc;    while (temp-&gt;adjvex != w)    &#123;        temp = temp-&gt;nextarc;    &#125;    if (temp-&gt;nextarc)        return temp-&gt;nextarc-&gt;adjvex;    else        return -1;    delete temp;&#125;void BFS_AL(ALGraph&amp; G, int v)&#123;    cout &lt;&lt; v;    visited[v] = true;    queue&lt;int&gt; Q;    Q.push(v);    int u = v;    while (!Q.empty())&#123;        u = Q.front();        Q.pop();        for (int w = FirstAdjvex(G, u); w &gt;= 0; w = NextAdjVex(G, u, w))&#123;            if (!visited[w])&#123;                cout &lt;&lt;w;                visited[w] = true;                Q.push(w);            &#125;        &#125;    &#125;&#125;void BFSTraverse(ALGraph &amp;G) &#123;    //访问标志数组初始化    for(int v = 0; v &lt; G.vexnum; v++)        visited[v] = false;    //循环调用BFS    for(int v = 0; v &lt; G.vexnum; v++)        if(!visited[v])            BFS_AL(G, v); //对尚未访问的顶点调用BFS&#125;int main() &#123;    ALGraph test;    CreateUDG(test);    Display(test);    BFSTraverse(test);&#125;</code></pre><div style="background: #FFF3F3;padding:10px;border: 1px solid #DEB8BE;border-radius:5px;margin-bottom:5px;">【插眼】为啥我写的一个函数不需要队列也可以？？？直接将顶点数组的一个元素后面接的链表遍历不就好了，然后再遍历标志数组元素值部位true的不就好了。。。为啥要压队列呀？莫不是哪里有隐藏的bug，插个眼！！！</div><p><img src="https://cdn.nlark.com/yuque/0/2021/gif/1484158/1621340205400-d534997e-4b20-4f0e-8db6-4a91e39c68b6.gif#crop=0&crop=0&crop=1&crop=1&height=134&id=Ivn4n&originHeight=134&originWidth=218&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=stroke&title=&width=218"></p><div style="background: #edf9e8;padding:10px;border: 1px solid #c2d2b5;border-radius:5px;margin-bottom:5px;">【拔眼】这样是一种特殊情况，只适合图的各个结点是按照层次标号的，并且放入标志数组也是按照顺序放入的……</div><p>插眼代码如下：</p><pre><code class="cpp">void BFS_AL(ALGraph &amp;G, int v)&#123;//按广度优先非递归遍历连通图G    cout&lt;&lt;v;    visited[v] = true;    //访问第v个顶点，并置访问标志数组相应分量值为true    ArcNode *p;    p = G.vertices[v].firstarc;    if (p != NULL) &#123;        while(p != NULL) &#123;            if (!visited[p-&gt;adjvex])&#123;                cout &lt;&lt; p-&gt;adjvex;            &#125;            visited[p-&gt;adjvex] = true;            p = p-&gt;nextarc;        &#125;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 📉图结构：无向图-有向图 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>图的术语、存储、应用综述</title>
      <link href="/blog/gqpli5/"/>
      <url>/blog/gqpli5/</url>
      
        <content type="html"><![CDATA[<p>前言：<strong>数据结构一般就四种关系：集合、线性、树、图</strong>。这篇文章打算对图这类数据结构做一个概览。先介绍图的一些术语（复制粘贴：））；然后讲解一下图的各种存储形式；最后把图的应用记录一下，具体应用算法放在算法分类里面。</p><h2 id="一、图的一些术语"><a href="#一、图的一些术语" class="headerlink" title="一、图的一些术语"></a>一、图的一些术语</h2><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1621256644397-9e2a9a9a-c3f9-4bfe-af9d-d3eec44c16b2.png#align=left&display=inline&height=351&id=ue0b15b96&margin=%5Bobject%20Object%5D&name=image.png&originHeight=702&originWidth=998&size=434452&status=done&style=stroke&width=499" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1621256670453-caccc927-2510-4119-9452-a588b6f590e5.png#align=left&display=inline&height=291&id=u1e1a40e2&margin=%5Bobject%20Object%5D&name=image.png&originHeight=581&originWidth=952&size=365443&status=done&style=stroke&width=476" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1621256694543-32b41537-3bc7-4515-b8e9-eb56b026d2a7.png#align=left&display=inline&height=334&id=uee62fe0a&margin=%5Bobject%20Object%5D&name=image.png&originHeight=667&originWidth=940&size=432681&status=done&style=stroke&width=470" alt="image.png"></p><h2 id="二、图存储"><a href="#二、图存储" class="headerlink" title="二、图存储"></a>二、图存储</h2><h3 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h3><div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">创建无向网</div><pre><code class="cpp">#include&lt;bits/stdc++.h&gt;using namespace std;#define MVNum 100#define MaxInt 32767typedef char VerTexType;typedef int ArcType;/** * 邻接矩阵存储形式 */typedef struct &#123;    /* data */    VerTexType vexs[MVNum]; //顶点表    ArcType arcs[MVNum][MVNum]; //邻接矩阵    int vexnum, arcnum; //图的当前顶点和边数&#125;AMGraph;/** * 确定v在G中的位置，即顶点数组的下标 */int LocateVex(AMGraph &amp;G, char v) &#123;    for (int i = 0; i &lt; G.vexnum;i++) &#123;        if (v == G.vexs[i])&#123;            return i;        &#125;    &#125;&#125;/** * 创建无向网 * 如果创建无向图 */void CreateUDN(AMGraph &amp;G) &#123;    // 采用邻接矩阵表示法，创建无向图G    cout &lt;&lt; &quot;请输入顶点数和边数：&quot; &lt;&lt; endl;    cin &gt;&gt; G.vexnum &gt;&gt; G.arcnum; //输入顶点数和边数    // 初始化顶点    for (int i = 0; i &lt; G.vexnum;i++)&#123;        cout &lt;&lt; &quot;请输入第&quot; &lt;&lt; i &lt;&lt; &quot;个顶点值&quot; &lt;&lt; endl;        cin &gt;&gt; G.vexs[i];    &#125;    // 初始化邻接矩阵的边的权值为最大值    for (int i = 0; i &lt; G.vexnum;i++) &#123;        for (int j = 0; j &lt; G.vexnum;j++) &#123;            G.arcs[i][j] = MaxInt;        &#125;    &#125;    // 构造邻接矩阵    for (int k = 0; k &lt; G.arcnum;k++) &#123;        cout &lt;&lt; &quot;请输入每条边所依附的顶点和权值：&quot; &lt;&lt; endl;        char v1, v2;        int w; //一条边所依附的顶点和权值        cin &gt;&gt; v1 &gt;&gt; v2 &gt;&gt; w;        int i = LocateVex(G, v1);        int j = LocateVex(G, v2);        G.arcs[i][j] = w;        G.arcs[j][i] = w;    &#125;&#125;void Display(AMGraph &amp;G) &#123;    for (int i = 0; i &lt; G.vexnum;i++) &#123;        for (int j = 0; j &lt; G.vexnum;j++) &#123;            cout &lt;&lt; G.arcs[i][j] &lt;&lt; &quot; &quot;;        &#125;        cout &lt;&lt; endl;    &#125;&#125;int main() &#123;    AMGraph test;    // CreateUDN(test);    Display(test);&#125;</code></pre><div style="background: #FFFBE6;padding:10px;border: 1px solid #C3C3C3;border-radius:5px;margin-bottom:5px;">创建无向图</div>对`CreateUDN` 进行处理：<ul><li>G.arcs[i][j] = MaxInt;改为 G.arcs[i][j] = 0;</li><li>将 w 改为常量 1 即可</li></ul><div style="background: #FFFBE6;padding:10px;border: 1px solid #C3C3C3;border-radius:5px;margin-bottom:5px;">创建有向网</div>对`CreateUDN` 进行处理：<ul><li>删除 G.arcs[j][i] = w;</li></ul><div style="background: #FFFBE6;padding:10px;border: 1px solid #C3C3C3;border-radius:5px;margin-bottom:5px;">创建有向图</div>对`CreateUDN` 进行处理：<ul><li>删除 G.arcs[j][i] = w;</li></ul><h3 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h3><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;#define MVNum 100#define MaxInt 32767typedef char VerTexType;typedef int OtherInfo;/** * 邻接表存储 *//** * 存储结构 */typedef struct ArcNode &#123;                      //边结点    int adjvex;                             //该边所指向的结点的位置    struct ArcNode *nextarc;                //指向下一条边的指针    OtherInfo info;                         //和边相关的其他信息&#125;ArcNode;typedef struct VNode &#123;                        //顶点信息    VerTexType data;                        //数据域，存放顶点vi的名称或其他有关信息    ArcNode *firstarc;                      //指向第一条依附该顶点的边的指针&#125;VNode, AdjList[MVNum];                     //AdjList表示邻接表的类型typedef struct &#123;    AdjList vertices;    int vexnum, arcnum;                     //图当前的顶点数和边数&#125;ALGragh;                                   //邻接表（Adjacency List）/** * 找到v顶点在图中的位置 */int LocateVex(ALGragh &amp;G, char v) &#123;    for (int i = 0; i &lt; G.vexnum;i++) &#123;        if (v == G.vertices[i].data) &#123;            return i;        &#125;    &#125;&#125;/** * 邻接表创建无向图 */void CreateUDG(ALGragh &amp;G) &#123;    cin &gt;&gt; G.vexnum &gt;&gt; G.arcnum; // 邻接表的顶点数和边数    for (int i = 0; i &lt; G.vexnum;i++) &#123;        cin &gt;&gt; G.vertices[i].data;        G.vertices[i].firstarc = NULL;    &#125;    for (int k = 0; k &lt; G.arcnum;k++) &#123;        char v1, v2;        cin &gt;&gt; v1 &gt;&gt; v2;        int i = LocateVex(G, v1);        int j = LocateVex(G, v2);        ArcNode *p1 = new ArcNode;        p1-&gt;adjvex = j;        p1-&gt;nextarc = G.vertices[i].firstarc;        G.vertices[i].firstarc = p1;        ArcNode *p2 = new ArcNode;        p2-&gt;adjvex = i;        p2-&gt;nextarc = G.vertices[j].firstarc;        G.vertices[j].firstarc = p1;    &#125;&#125;</code></pre><h3 id="有向图：十字链表存储"><a href="#有向图：十字链表存储" class="headerlink" title="有向图：十字链表存储"></a>有向图：十字链表存储</h3><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef int Status;#define OK 1;//----有向图的十字链表储存表示----#define MAX_VERTEX_NUM 20typedef char VerTexType;typedef int InfoType;typedef struct ArcBox&#123;    int tailvex, headvex;                   //该弧的头尾和头顶点的位置    struct ArcBox *hlink, *tlink;            //分别为弧头相同和弧尾相同的链域    InfoType *info;                         //该弧相关信息的指针&#125;ArcBox;typedef struct VexNode&#123;    VerTexType data;    ArcBox *firstin, *firstout;             //分别指向该顶点的第一项入弧和出弧&#125;VexNode;typedef struct&#123;    VexNode xlist[MAX_VERTEX_NUM];          //表头向量    int vexnum, arcnum;                     //有向图的当前顶点数和弧数&#125;OLGraph;                                   //十字链表（Orthogonal List）</code></pre><h3 id="无向图：邻接多重表存储"><a href="#无向图：邻接多重表存储" class="headerlink" title="无向图：邻接多重表存储"></a>无向图：邻接多重表存储</h3><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;typedef int Status;#define OK 1;//----无向图的邻接多重表储存表示----#define MAX_VERTEX_NUM 20typedef char VerTexType;typedef int InfoType;typedef enum&#123;    unvisited, visited                     //枚举unvisited是0，visited是1，注意没有分号&#125;VisitIf;typedef struct EBox&#123;    VisitIf mark;                           //访问标记    int ivex, jvex;                         //该边依附的两个顶点的位置    struct EBox *ilink, *jlink;             //分别指向依附这两个顶点的下一条边    InfoType *info;                         //该边的信息指针&#125;EBox;typedef struct VexBox&#123;    VerTexType data;    EBox *firstedge;                        //指向第一条依附该顶点的边&#125;VexBox;typedef struct&#123;    VexBox adjmulist[MAX_VERTEX_NUM];    int vexnum, arcnum;                     //无向图当前的顶点数和边数&#125;AMLGraph;                                  //邻接多重表(Adjacency Multilist)</code></pre><h3 id="其他：边集数组"><a href="#其他：边集数组" class="headerlink" title="其他：边集数组"></a>其他：边集数组</h3><h3 id="其他：链式前向星"><a href="#其他：链式前向星" class="headerlink" title="其他：链式前向星"></a>其他：链式前向星</h3><h2 id="三、图的应用"><a href="#三、图的应用" class="headerlink" title="三、图的应用"></a>三、图的应用</h2><ul><li>最小生成树</li><li>最短路径</li><li>环路</li><li>关键路径</li></ul><p>具体这几类问题都是算法中的贪心算法所属，故将其放到算法分类里面了。</p>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 📉图结构：无向图-有向图 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>『灵笼』——灵魂的牢笼</title>
      <link href="/essay/pnapfw/"/>
      <url>/essay/pnapfw/</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1621244428291-8f947575-4da5-4938-a3fa-09f21bed0925.png#align=left&display=inline&height=1080&id=ijJPU&margin=%5Bobject%20Object%5D&name=Snipaste_2021-05-17_17-38-3d5.png&originHeight=1080&originWidth=1920&size=17146&status=done&style=none&width=1920" alt="Snipaste_2021-05-17_17-38-3d5.png"></p><p>看了五集，觉得剧情设定方面有浓浓的进击的巨人和 Darling in the franxx 这两部番那味了（去论坛看了看，果然有吐槽的…不过都在说巨人，我更加觉得和国家队的世界观很像）…但不管怎么说，<strong>剧情设定和画质方面在国漫里面也是可圈可点，并且，我个人认为，这部番是这么多年国漫里面最用心最花成本的一部</strong>～</p><p>灵笼，灵魂的牢笼，就像是巨壁<br>重立体，立体机动装置（就不能叫个重装甲啥的，害<img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1621243721740-de5b6182-0bb1-4971-95bf-1309c0fdfb1d.jpeg#align=left&display=inline&height=58&id=rboSG&margin=%5Bobject%20Object%5D&originHeight=58&originWidth=79&status=done&style=stroke&width=79"><br>猎荒者，调查兵团<br>荷光者，宪兵团<br>……</p><p>我之前对 darling 里面的是『心』这个人物，我当时的感受是整部番的点睛之笔，在世界观的角度上，拉伸高度，在灵笼这里被设定为佩妮这个角色……<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1621244183522-a0ab8144-4141-4887-895b-a5b3e6230613.png#align=left&display=inline&height=1080&id=VgAwl&margin=%5Bobject%20Object%5D&name=Snipaste_2021-05-17_17-35-00.png&originHeight=1080&originWidth=1920&size=1267727&status=done&style=none&width=1920" alt="Snipaste_2021-05-17_17-35-00.png"></p><p>这些说实话，感受的挺多了，用这部番里面的一个词就是——躯壳。希望后面的剧情能挖掘出作品的闪光之处～</p><hr><p>EP6<br><img src="https://cdn.nlark.com/yuque/0/2021/jpg/1484158/1621262671765-0831d8b9-f8eb-4a16-acc0-1b8d622ff5b8.jpg#align=left&display=inline&height=146&id=OlIMX&margin=%5Bobject%20Object%5D&originHeight=815&originWidth=1975&status=done&style=none&width=354"><br><img src="https://cdn.nlark.com/yuque/0/2021/jpg/1484158/1621262686893-e61922ea-e1b5-4fa8-82ac-cabc2ef60391.jpg#align=left&display=inline&height=805&id=fQ07I&margin=%5Bobject%20Object%5D&originHeight=805&originWidth=1349&status=done&style=none&width=1349"><br>不管这个世界再怎么变，人性永远在那，就像爱情……</p><p>或许我在想，即便这个世界颠倒了，文明是一个全新的面貌，人性或许是那诸多不变的点之一。</p><hr><p><img src="https://cdn.nlark.com/yuque/0/2021/jpg/1484158/1621472984542-d6010263-d430-4ab7-ac8d-4f911c4d4bf3.jpg#align=left&display=inline&height=834&id=mKa4W&margin=%5Bobject%20Object%5D&originHeight=834&originWidth=2083&status=done&style=none&width=2083"><br>万万没想到系列，冉冰居然凉凉～</p><hr><p>终章+特别篇<br><img src="https://cdn.nlark.com/yuque/0/2021/jpg/1484158/1621473001235-cb79d2e3-6a7e-4556-92b4-33ea9d442010.jpg#align=left&display=inline&height=824&id=gBT7O&margin=%5Bobject%20Object%5D&originHeight=824&originWidth=1996&status=done&style=none&width=1996"></p><p>这波用灯塔来反衬地面幸存者的存在的意义，都知道噬极兽会以人类的情感来孕育，灯塔是颁布三大法令来限制灯塔上的人的情感，以此来让灯塔幸存于这乱世，地面幸存者则是相反，情感不但不能舍弃，反而要坚守</p><p>至于白月魁，直接将这部番提升到修仙境界了<img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1622037065067-007f3642-a1e3-4f60-862b-af2e1013c8ec.jpeg#align=left&display=inline&height=77&id=MR71l&margin=%5Bobject%20Object%5D&originHeight=77&originWidth=77&status=done&style=none&width=77">，就是人类中靠修炼而成的外挂，和阿克曼一族利威尔兵长是一类人，人类最强。</p><p><img src="https://cdn.nlark.com/yuque/0/2021/jpg/1484158/1621473476256-6440f355-2230-47d7-9a2d-cc3a92afa850.jpg#align=left&display=inline&height=1128&id=TxJXz&margin=%5Bobject%20Object%5D&originHeight=1128&originWidth=2400&status=done&style=none&width=2400"></p>]]></content>
      
      
      <categories>
          
          <category> 影视 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[转]竞赛常用STL容器详解</title>
      <link href="/blog/porzdi/"/>
      <url>/blog/porzdi/</url>
      
        <content type="html"><![CDATA[<blockquote><p>大部分文字内容转载自：<a href="https://blog.csdn.net/weixin_43844677/article/details/104902417">竞赛常用 STL 容器详解</a><br>部分内容个人修改补充。</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1626175209711-5b013be3-5942-4a0a-b9ce-529a73668d94.jpeg#align=left&display=inline&height=512&margin=%5Bobject%20Object%5D&name=unnamed.jpg&originHeight=512&originWidth=360&size=48453&status=done&style=none&width=360" alt="unnamed.jpg"></p><h2 id="一、-概述"><a href="#一、-概述" class="headerlink" title="一、 概述"></a>一、 概述</h2><p>在算法竞赛中，使用 C++语言的占很大比例，而几乎没有人使用 C 语言，其中核心的原因就是 C++包含 STL 容器库，能够极大地减少选手在赛场上为了一些基础数据结构而浪费的时间。诚然，花一两分钟实现一个 stack、queue 甚至 priority_queue 都不是什么大问题，但如果需要实现 BBST（Balanced Binary Search Tree）的情况呢？如果可以的话，我们总是希望不要手写红黑树、动态数组的。那么 STL 容器库的出现就像雪中送炭一样了。它们覆盖了竞赛中最基础的需要（张昆玮树、主席树这种东西肯定不会包含的），让你在面对非数据结构题的时候能够不因数据结构部分的代码而分心。</p><p>关于 STL 容器的相关问题非常细，经常成为面试中的考题，这里我们仅讨论一些必须的内容，然后只谈论在竞赛中的具体使用。</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1621221298404-a6bf5daf-fd5b-4504-a4d0-f80b17dc5899.png#align=left&display=inline&height=845&id=Rv9rY&margin=%5Bobject%20Object%5D&originHeight=845&originWidth=1778&size=0&status=done&style=none&width=1778"><br>首先给出一张表格（来自 cppreference）：</p><p>这张表格中给出了各种容器支持的成员函数，在大多数停留在 C++14 和 C++11 版本的测试平台中，只有紫色、绿色部分是可用的。</p><p>在考察具体的容器的时候，出于竞赛中的需要，我们不会涵盖以上的全部，而是着重关注以下几点：</p><ol><li><strong>随机访问</strong></li><li><strong>插入和删除</strong></li><li><strong>端点访问</strong></li><li><strong>迭代器类型（总结以上几点）</strong></li><li><strong>时间复杂度</strong></li></ol><p>**<br>事实上，综合以上几点，就可以得出一个容器的作用。容器的作用是由它支持的操作及其时间复杂度决定的，并不是说，容器的名字叫做 set 我就一定把它当作集合来用。从 ADT 的角度来说，<strong>数据结构=接口+接口的复杂度</strong>。而从另一个角度来看，容器内部支持的逻辑操作决定了它能够使用的迭代器类型，而这决定了外部可能存在哪些接口，因此也可以说**数据结构=内部存储+迭代器**。这样两种观点，能够在使用的层面加强我们对于 STL 容器的理解。</p><p>方便起见，这里先列出一个汇总的表格，包含了竞赛中常用的几种数据结构：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1621221298080-23300f65-22c0-48b6-895a-324e3793fed5.png#align=left&display=inline&height=355&id=PnAJG&margin=%5Bobject%20Object%5D&originHeight=355&originWidth=857&size=0&status=done&style=none&width=857"></p><p>这里的表格只给出了很简单的内容，本文末尾会给出两个总结性的表格，给出具体操作的函数名和时间复杂度。</p><h2 id="二、-迭代器"><a href="#二、-迭代器" class="headerlink" title="二、 迭代器"></a>二、 迭代器</h2><h3 id="迭代器与遍历"><a href="#迭代器与遍历" class="headerlink" title="迭代器与遍历"></a>迭代器与遍历</h3><p>操作一个容器，无法脱离它提供的工具——<strong>迭代器</strong>。即使没有使用过容器，我们也一定使用过最基本的方式遍历一个数组：</p><pre><code class="cpp">for (int i = 0; i &lt;n;i++)    //......</code></pre><p>不严格地说，这里的”i”就可以视作一个最原始的迭代器。事实上，对于藉由它，我们可以访问一个容器内的全部内容——这就是我们所说的“遍历”，这能够让我们对内部数据进行基于元素的操作。</p><p>事实上，一个真正的迭代器需要符合很多要求。STL 容器所配备的迭代器都属于 C++迭代器库规定的六种之一，它们是：</p><ol><li><strong>遗留输入迭代器</strong></li><li><strong>遗留向前迭代器</strong></li><li><strong>遗留双向迭代器</strong></li><li><strong>遗留随机访问迭代器</strong></li><li><strong>遗留输出迭代器</strong></li><li><strong>遗留连续迭代器</strong></li></ol><p>这些名字看起来很唬人，让我们来一点一点解释。<br>首先，它们都是“<strong>遗留迭代器</strong>”，这意味着它们都：（以下假设 i 是迭代器）</p><ul><li>可<strong>解引用</strong>（*i 得到元素）</li><li>可<strong>前自增</strong>（++i 得到下一位置）</li></ul><p>这也就是为何我们能藉由迭代器来完成遍历容器内元素的操作。<br>下面给出上文提到的六种迭代器的实际含义，虽然大多数情况下竞赛中用不到这些原理，但偶尔会有基于手动遍历的技巧性操作，这时候也许需要你对迭代器有一定的认知：<br><strong>遗留输入迭代器：</strong><br>在<strong>遗留迭代器</strong>的基础上，</p><ul><li>可<strong>不等比较</strong>（i!=j 有定义）</li><li>可<strong>后自增</strong>（i++有定义）</li></ul><p>但：<strong>自增后，先前值可能失效。</strong>也就是说，当你访问第 1 个元素时，可能无法通过这个迭代器的拷贝访问第 0 个元素。<br><strong>遗留向前迭代器：</strong><br>在<strong>遗留输入迭代器</strong>的基础上，</p><ul><li><strong>自增后保证先前值不失效。</strong></li></ul><p><strong>遗留双向迭代器：</strong><br>在<strong>遗留向前迭代器</strong>的基础上，</p><ul><li>可<strong>前自减</strong>（–i 有定义）</li><li>可<strong>后自减</strong>（i–有定义）</li></ul><p><strong>遗留随机访问迭代器：</strong><br>在<strong>遗留双向迭代器</strong>的基础上，</p><ul><li>有<strong>下标</strong>运算符（i[n]有定义）</li><li>有<strong>比较</strong>运算符（&gt;、&lt;、&gt;=、&lt;=有定义）</li><li>可按<strong>增量移动</strong>（+、-、+=、-=有定义）</li></ul><p>且：<strong>迭代器移动只耗费常数时间。</strong><br>_若以上迭代器满足<strong>遗留输出迭代器</strong>的标准，那么称它们是“可变迭代器”。_<br><strong>遗留输出迭代器：</strong><br>在<strong>遗留迭代器</strong>的基础上：</p><ul><li>可<strong>赋值</strong>（*i=something 有定义）</li><li>可<strong>后自增</strong></li></ul><p>_若以上迭代器满足<strong>遗留连续迭代器</strong>的标准，那么称它们是“连续迭代器”。_<br><strong>遗留连续迭代器：</strong><br>在<strong>遗留迭代器</strong>的基础上：</p><ul><li>逻辑相邻元素在内存中也相邻，</li><li>即：<code>*(i + n)</code> 等价于 <code>*(std::addressof(*i) + n)</code></li></ul><p>以上涉及的运算，不仅需要定义，并且需要符合功能要求。同时，部分操作有特例存在。例如，即使迭代器可解引用，也无法对尾后迭代器或孤立迭代器解引用。<br>那么，如果知道某个容器的迭代器类型，对比一下它们支持的操作，你就能知道自己的一些奇思妙想能否实现了。例如：两头向中间访问、一次跳过多个元素、多个迭代器同时访问……<br>那么，在复杂的环境下，例如访问的同时涉及插入和删除，这些操作还能按照我的意图运行吗？这就是我们要讨论的下一个问题了。如果说以上内容更偏向于实务开发，那么这个问题在竞赛中就更加常见了，它就是“迭代器失效”问题。</p><h3 id="迭代器失效"><a href="#迭代器失效" class="headerlink" title="迭代器失效"></a>迭代器失效</h3><p>容器的一些操作会使得先前声明的迭代器失去它应有的作用，这种限制来自于容器底层的实现。例如在 vector 中，即使在尾部插入一个新元素也可能因为导致空间达到临界值而使得数据全部被移动到新空间，从而使全部迭代器失效。</p><p>大体来说，删除总会使得迭代器失效，而插入有些情况会使其失效。具体的情形见下表：（同样来自 cppreference）</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1621221298154-92c7bf87-74b3-4fd5-9f62-d7ab6e5aa25b.png#align=left&display=inline&height=525&id=N6O99&margin=%5Bobject%20Object%5D&originHeight=525&originWidth=982&size=0&status=done&style=none&width=982"></p><p>除此之外，尾后迭代器有一些特殊情形需要考虑，例如 vector 的尾后迭代器总是会被非法化、除了删除首元素外的修改操作都会非法化 deque 的尾后迭代器，等等。</p><h3 id="尾后迭代器"><a href="#尾后迭代器" class="headerlink" title="尾后迭代器"></a>尾后迭代器</h3><p>另一个要注意的点是，一般来说一个容器的 begin()返回的是指向容器内首个元素的迭代器，而 end()指向的却不是尾部元素，而是<strong>尾后</strong>——一个不存在的元素，我们也常常把这种位置称为“哨兵”。这一点好像恰好和其他参数为一个区间的函数，如 sort(), substr()等，对应了起来——似乎编程中所有涉及区间的操作，都是使用左开右闭区间来表示的——也就是说，end()表示尾后。这是为什么呢？<br>考虑对一个具有<strong>普通遗留迭代器</strong>的容器进行迭代，应当怎么写呢？似乎很简单：</p><pre><code>for (auto i = x.begin(); i != x.end(); i++)</code></pre><p>看到这里，你应当已经明白了：大多数容器不具有遗留连续迭代器的性质，那就不存在像<code>i &lt; x.end()</code>这种操作，因此无法像迭代一个数组一样以一个偏序比较作为条件，那么就必须有一个哨兵作为实际可以访问到的截止位，这个哨兵就是 end()。</p><h3 id="其他补充"><a href="#其他补充" class="headerlink" title="其他补充"></a>其他补充</h3><p>在自写模板的时候，需要加上关键字<code>typename</code></p><pre><code class="cpp">typename list&lt;T&gt;::iterator p;</code></pre><h2 id="三、容器"><a href="#三、容器" class="headerlink" title="三、容器"></a>三、容器</h2><h3 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h3><h4 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h4><p>那么，我们就开始讲每个具体的容器了。在各节中，我们会依次介绍每个容器的用途、迭代器类型、插查删操作及其复杂度，有必要的时候，我们还会介绍一些其他的小 trick。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1621221298034-6e429607-ece3-4c15-bd6a-e02efaf4d4f6.png#align=left&display=inline&height=263&id=STppH&margin=%5Bobject%20Object%5D&originHeight=263&originWidth=669&size=0&status=done&style=none&width=669"><br>我们看到，Vector 与其他 STL 容器最大的区别就在于，只要元素不为 bool 类型（bool 类型因内存对齐而不连续），它是唯一使用<strong>连续迭代器</strong>的，即使对于全部情况，它也符合遗留随机访问迭代器，从而支持以常数复杂度通过下标运算符随机访问。这使得我们可以直接将其作为升级版的数组使用——数组的功能全部被它继承，而它又自带了其他一些便捷的函数——因此 vector 又被称为 <strong>“动态数组”</strong> 。<br>它底层的数据结构使用的是静态数组，实现动态扩容的奥秘在于，它在每一次容量占用达到阈值时就进行一次翻倍扩容，从而保证了均摊  O ( 1 ) O(1) O(1)的时间复杂度，而又能节省空间。</p><h4 id="常见用法"><a href="#常见用法" class="headerlink" title="常见用法"></a>常见用法</h4><p>在 C++11 中，在具有 begin()和 end()的范围上进行迭代，有一种简便写法，那就是</p><pre><code>for (auto&amp; v : container)</code></pre><p>它等价于</p><pre><code>for (auto&amp; v = container.begin(); v != container.end(); v++)</code></pre><p>这里的 auto 利用了 C++11 的另一个特性——类型推导，这只是一个语法糖，它使我们不必写上 container::iterator 这一串复杂的类型，而在程序运行中与完整键入的并无区别。而 auto 后面加的&amp;代表 v 是一个左值引用，那么我们就可以通过 v 来修改容器中的元素。而如果我们想避免这种修改，可以去掉&amp;，这时 v 就是一个右值拷贝。<br>以一个 int 类型动态数组为例，我们可以这样输出：</p><pre><code>vector&lt;int&gt; arr;for (auto v : arr)    cout&lt;&lt;v;</code></pre><p>而读入可以这样写：</p><pre><code>for (int i = 1; i &lt;= n; i++)&#123;    cin&gt;&gt;temp;    arr.push_back(temp);&#125;</code></pre><p>当然，同程序员们默认的一样，它的下标是从 0 开始的。<br>vector 是否可以写高维数组呢？如果你经常在 Leetcode 上刷题，应当见过二维数组的这种写法：<code>vector&lt;vector&lt;int&gt;&gt;</code>。高维数组以此类推即可。在访问上，这种写法与<code>int arr[][]</code>没有任何区别。</p><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1621221298094-bbd53e64-b82a-4b51-aa3a-f354b3bd7023.png#align=left&display=inline&height=325&id=D1lAx&margin=%5Bobject%20Object%5D&originHeight=325&originWidth=669&size=0&status=done&style=none&width=669"><br>可以看到，list 实际上就是一个<strong>双向链表</strong>，因此对于插入和删除的操作具有优秀的时间表现。当然也很容易想到，list 是无法实现常数时间随机访问的，insert 和 erase 看起来时间复杂度为  O ( 1 ) O(1) O(1)，但在实际应用中，找到插入位置往往就需要  O ( n ) O(n) O(n)的时间。<br>与 list 相似的，STL 中还存在一个单向链表 forward_list。由于不需要反向链，它的空间占用有所减小，不过这一点在竞赛中不怎么需要，所以那种结构了解即可。</p><h3 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h3><h4 id="总览-1"><a href="#总览-1" class="headerlink" title="总览"></a>总览</h4><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1621221298067-e4b7c1aa-ec7e-4535-a505-59440ac713db.png#align=left&display=inline&height=181&id=Sfmf5&margin=%5Bobject%20Object%5D&originHeight=181&originWidth=669&size=0&status=done&style=none&width=669"><br>相比于精心构造的数据结构，stack 似乎更应当被称为一种“包装器”，它在底层实现的基础上屏蔽掉了一些功能，从而使自身表现得更像一个物理栈。对于它和 queue，我们不需要多费口舌，也许这是仅有的两种我们可以自己实现而不会使代码冗长的数据结构了。但无论怎么说，有一个构造好的容器使用总是好的，它可以防止我们在底层的操作上犯一些愚蠢的错误。</p><h4 id="常见用法-1"><a href="#常见用法-1" class="headerlink" title="常见用法"></a>常见用法</h4><p>那么，这里就实际给出使用 stack 完成 DFS 的过程，以下是一段代码片段：</p><pre><code>vector&lt;int&gt; edges[N];    stack&lt;int&gt; dfs;    /*............*/    dfs.push(v0);    vis[v0] = true;    while (!dfs.empty())    &#123;        bool tag = false;        int now = dfs.top();        prt.push_back(now);        for (auto v : edges[now])            if (!vis[v])            &#123;                dfs.push(v);                vis[v] = true;                tag = true;                break;            &#125;        if (!tag)            dfs.pop();    &#125;</code></pre><h3 id="Deque-及其延伸"><a href="#Deque-及其延伸" class="headerlink" title="Deque 及其延伸"></a>Deque 及其延伸</h3><h4 id="Deque"><a href="#Deque" class="headerlink" title="Deque"></a>Deque</h4><p>虽然实际使用时很少见，但 deque 是很多 STL 容器的基础，stack 和 queue 都由它封装而来，它也支持相当多的操作，详见下表：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1621221298045-e627f316-cc63-4992-817c-f8025c1474df.png#align=left&display=inline&height=378&id=yw0ii&margin=%5Bobject%20Object%5D&originHeight=378&originWidth=669&size=0&status=done&style=none&width=669"><br>值得注意的是，该容器的迭代器非法化情形比较有趣，其原理也是面试题常考的内容，建议结合 STL 源码深入分析。<br>结合上表，发现它与 List 的区别主要在于，它能够实现常数时间随机访问，但内部插入、删除却需要线性时间，这也符合他们底层实现：链表和数组的区别，也正是这一点使得它们的迭代器一个是双向而另一个是随机访问。多进行这种思考，由<strong>底层实现——容器——迭代器——操作</strong>转为<strong>底层实现——迭代器——操作</strong>，是一名程序员获得抽象思维的重要方式。</p><h4 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h4><p>总览<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1621221298045-979ccd1c-9d0c-4971-8323-beeb278dfecb.png#align=left&display=inline&height=209&id=LTTqa&margin=%5Bobject%20Object%5D&originHeight=209&originWidth=669&size=0&status=done&style=none&width=669"><br>queue 就是我们常说的<strong>队列</strong>了。同 stack 一样，它是很常见而且简单的数据结构，同样由 deque 封装得来。当然，由于 deque 和 list 都满足它的底层实现的要求，因此你可以指明换用 list 作为你的 queue 的底层实现：</p><pre><code>queue&lt;int, list&lt;int&gt;&gt; myQue;</code></pre><p>由于 STL 容器都使用模板类，因此在实际开发中，你完全可以将所有容器的分配器、底层容器自主实现。<br>6.2.2.常见用法<br>queue 用来实现 BFS 应该是最常见的用法了，以下和 stack 一样给出一个代码片段：</p><pre><code>queue&lt;int&gt; que;    while (!que.empty())    &#123;        int now = que.front();        que.pop();        if (success(pos[now]))            return true;        for (int i = 0; i &lt; n; i++)            if (!vis[i] &amp;&amp; dis[now][i] &lt;= limit)            &#123;                que.push(i);                vis[i] = true;            &#125;    &#125;</code></pre><h4 id="Priority-Queue"><a href="#Priority-Queue" class="headerlink" title="Priority_Queue"></a>Priority_Queue</h4><p>6.3.1.总览<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1621221298072-4aa3333f-4fe3-4f4e-8f10-212345e22947.png#align=left&display=inline&height=205&id=Qei4g&margin=%5Bobject%20Object%5D&originHeight=205&originWidth=669&size=0&status=done&style=none&width=669"><br>priority_queue 实现了优先队列这一 ADT，也就是我们常说的 <strong>“堆”</strong> 。但要明晰的是，优先队列是一种 ADT，而堆是它的一种具体实现。在默认状态下，priority_queue 实现的是大根堆，但你可以通过模板特化从而实现小根堆，甚至是自己定义的规则。</p><p>6.3.2.常见用法<br>实现小根堆的方式很简单:</p><pre><code>priority_queue&lt;int, vector&lt;int&gt;, std::greater&lt;int&gt;&gt; myHeap;</code></pre><p>其中第一个参数为元素类型，第二个类型为底层实现，默认为 vector，但 STL 库中的 deque 也符合要求。第三个参数为你的比较类型。priority_queue 会按照这一比较偏序将<strong>最末序</strong>的元素作为“最大元素”。<br>在 sort 函数中自己构造函数对象以指定排序方式的写法非常基础，但其实在优先队列中指定排序方式的写法也并不困难。在 sort 中，我们传入一个函数指针，sort 函数调用这个函数，获得它的返回值，从而得到元素之间的偏序。而在模板类中，由于<strong>需要在编译期就特化类</strong>，所以我们无法传入一个函数，而必须传入一个<strong>类</strong>。堆在排序时会<strong>调用其构造函数</strong>，获得构造函数的返回值，这整体上与我们给 sort 传参无异。<br>大多数情况下，我们可以使用 STL 提供的编译器函数库中的比较运算，例如小于是 less，大于等于是 greater_equal，等等。上面用于实现小根堆的 greater 源码如下：</p><pre><code>template&lt;typename _Tp&gt;    struct greater : public binary_function&lt;_Tp, _Tp, bool&gt;    &#123;        bool        operator()(const _Tp&amp; __x, const _Tp&amp; __y) const        &#123;     return __x &gt; __y; &#125;    &#125;;</code></pre><p>然而观察这一函数，它最终还是要调用具体类型的比较运算。那么如果我们给容器的类不具有偏序，或者我们需要特别指定偏序怎么办呢？下面给出一个实例。<br>例如，在图的搜索中我们需要存储点和它到源点的距离，那么我们的元素可能是这样的：</p><pre><code>typename int Vertex;typename int Distance;typename pair&lt;Vertex, Distance&gt; Dest;</code></pre><p>在 Dijkstra 算法中，用堆优化时我们需要建立边权的小根堆，那么就可以这样自建比较类型（我们知道自己要使用的类型，就不需要写成模板类了）：</p><pre><code>struct myGreater : public binary_function&lt;Dest, Dest, bool&gt;&#123;    bool operator() (const Dest &amp;lhs, const Dest &amp;rhs) const    &#123;     return lhs.second &gt; rhs.second; &#125;&#125;</code></pre><p>于是就可以这样建立基于边权的小根堆：</p><pre><code>priority_queue&lt;Dest, vector&lt;Dest&gt;, myGreater&gt; myHeap;</code></pre><h3 id="Set-及-Multiset"><a href="#Set-及-Multiset" class="headerlink" title="Set 及 Multiset"></a>Set 及 Multiset</h3><h4 id="总览-2"><a href="#总览-2" class="headerlink" title="总览"></a>总览</h4><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1621221298126-cd7b73e2-055e-4325-8270-dadc26949011.png#align=left&display=inline&height=210&id=fntg7&margin=%5Bobject%20Object%5D&originHeight=210&originWidth=669&size=0&status=done&style=none&width=669"><br>set 对应的 ADT 是<strong>集合</strong>：它支持元素的存储和查找，同时符合抽象意义上的集合要求——<strong>不允许出现重复元素</strong>。</p><h4 id="常见用法-2"><a href="#常见用法-2" class="headerlink" title="常见用法"></a>常见用法</h4><p>set 的一个重要用途就是<strong>排序同时去重</strong>。在 BST 家族中，理论表现最好的是 Fibonacci-heap，但由于常数过大，实际表现最好的数据结构其实是 set 所采用的底层结构红黑树。如果说排序去重可以通过使用一个 sort 函数加手工来完成，那么需要<strong>支持插入和查找</strong>的题目呢？莫非我们要手写 RBT 吗？这时候，一个深受考验的 set 无疑是广大竞赛选手的福音。<br>当然，在更多的情况下，我们需要<strong>允许数据中出现重复</strong>的元素，那么<strong>可以使用 multiset</strong>这种数据结构，它在其他地方与 set 无异，唯一的区别在于它允许重复元素的出现。<br>在容器中，find 函数在找不到对象的时候一般会返回 end，那么查找可以写作：</p><pre><code>if (c.find(x) != c.end())    //do something...</code></pre><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><h4 id="总览-3"><a href="#总览-3" class="headerlink" title="总览"></a>总览</h4><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1621221298068-5d1c0d5a-095f-44a8-92cd-fa4bc119ab01.png#align=left&display=inline&height=209&id=dyk1Y&margin=%5Bobject%20Object%5D&originHeight=209&originWidth=669&size=0&status=done&style=none&width=669"></p><h4 id="常见用法-3"><a href="#常见用法-3" class="headerlink" title="常见用法"></a>常见用法</h4><p>map 和 set 非常类似，只不过它的数据是<strong>键值对</strong>而非一个单独的键，而<strong>键是唯一的</strong>。如果给它的用途举个例子，可以是存储源点到所有可达点的访问记录。<br>当然，同 map 一样，它也有允许键不唯一的版本，那就是<strong>multimap</strong>。本质上，<code>multimap&lt;Key, T&gt;</code>等价于<code>multiset&lt;pair&lt;Key, T&gt;, Comp&lt;pair&lt;Key, T&gt;&gt;, std::allocator&lt;std::pair&lt;Key, T&gt;&gt;&gt;</code>，其中 Comp 是自主实现的依据 Key 的比较类型。<br>也就是说，map 和 set 和 priority_queue 一样，支持特化比较类型，特化的方式也是一样的。只不过实际使用的时候，不要忘记最后一个模板参数，那是用于生成元素空间的分配器。</p><h2 id="四、算法"><a href="#四、算法" class="headerlink" title="四、算法"></a>四、算法</h2><p>STL 里面有一些常用的函数模板，可以在平常使用。</p><blockquote><p>参考这个链接：<a href="https://segmentfault.com/a/1190000021581714">https://segmentfault.com/a/1190000021581714</a></p></blockquote><h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><p>本文最后，给出一个表格以供检索，相比于 cppreference 的总结，这里只列出了竞赛中常用的一些操作及其复杂度。begin()和 end()虽然较为常用，不过由于是全体容器必备的，所以不再列出。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1621221298131-b854f40d-40b6-42fb-a901-467032ef3583.png#align=left&display=inline&height=164&id=Pt0mu&margin=%5Bobject%20Object%5D&originHeight=164&originWidth=1321&size=0&status=done&style=none&width=1321"><br>这样，这篇文章也就基本结束了。可以看到，为了照顾特定的使用需求，本文对容器具体的实现未做过多探讨，反而对通常不太重视的迭代器部分做了一定的讲解。在竞赛中掌握这些内容，已经能够满足几乎全部的需求了。但在实际应用中，掌握这些内容甚至不足以通过一个大厂的面试。例如，deque 的若是对容器原理有兴趣，可以找市面上评价较好的 STL 源码解读类书籍学习。</p><div style="background: #FFFBE6;padding:10px;border: 1px solid #C3C3C3;border-radius:5px;margin-bottom:5px;">补充：头文件#include<bits/stdc.h>（最常用，特别是OJ刷题）的内容如下</div><pre><code class="cpp">// C++ includes used for precompiling -*- C++ -*-// Copyright (C) 2003-2013 Free Software Foundation, Inc.//// This file is part of the GNU ISO C++ Library.  This library is free// software; you can redistribute it and/or modify it under the// terms of the GNU General Public License as published by the// Free Software Foundation; either version 3, or (at your option)// any later version.// This library is distributed in the hope that it will be useful,// but WITHOUT ANY WARRANTY; without even the implied warranty of// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the// GNU General Public License for more details.// Under Section 7 of GPL version 3, you are granted additional// permissions described in the GCC Runtime Library Exception, version// 3.1, as published by the Free Software Foundation.// You should have received a copy of the GNU General Public License and// a copy of the GCC Runtime Library Exception along with this program;// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see// &lt;Licenses - GNU Project - Free Software Foundation&gt;./** @file stdc++.h *  This is an implementation file for a precompiled header. */// 17.4.1.2 Headers// C#ifndef _GLIBCXX_NO_ASSERT#include &lt;cassert&gt;#endif#include &lt;cctype&gt;#include &lt;cerrno&gt;#include &lt;cfloat&gt;#include &lt;ciso646&gt;#include &lt;climits&gt;#include &lt;clocale&gt;#include &lt;cmath&gt;#include &lt;csetjmp&gt;#include &lt;csignal&gt;#include &lt;cstdarg&gt;#include &lt;cstddef&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;ctime&gt;#if __cplusplus &gt;= 201103L#include &lt;ccomplex&gt;#include &lt;cfenv&gt;#include &lt;cinttypes&gt;#include &lt;cstdalign&gt;#include &lt;cstdbool&gt;#include &lt;cstdint&gt;#include &lt;ctgmath&gt;#include &lt;cwchar&gt;#include &lt;cwctype&gt;#endif// C++#include &lt;algorithm&gt;#include &lt;bitset&gt;#include &lt;complex&gt;#include &lt;deque&gt;#include &lt;exception&gt;#include &lt;fstream&gt;#include &lt;functional&gt;#include &lt;iomanip&gt;#include &lt;ios&gt;#include &lt;iosfwd&gt;#include &lt;iostream&gt;#include &lt;istream&gt;#include &lt;iterator&gt;#include &lt;limits&gt;#include &lt;list&gt;#include &lt;locale&gt;#include &lt;map&gt;#include &lt;memory&gt;#include &lt;new&gt;#include &lt;numeric&gt;#include &lt;ostream&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;sstream&gt;#include &lt;stack&gt;#include &lt;stdexcept&gt;#include &lt;streambuf&gt;#include &lt;string&gt;#include &lt;typeinfo&gt;#include &lt;utility&gt;#include &lt;valarray&gt;#include &lt;vector&gt;#if __cplusplus &gt;= 201103L#include &lt;array&gt;#include &lt;atomic&gt;#include &lt;chrono&gt;#include &lt;condition_variable&gt;#include &lt;forward_list&gt;#include &lt;future&gt;#include &lt;initializer_list&gt;#include &lt;mutex&gt;#include &lt;random&gt;#include &lt;ratio&gt;#include &lt;regex&gt;#include &lt;scoped_allocator&gt;#include &lt;system_error&gt;#include &lt;thread&gt;#include &lt;tuple&gt;#include &lt;typeindex&gt;#include &lt;type_traits&gt;#include &lt;unordered_map&gt;#include &lt;unordered_set&gt;#endif</code></pre>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 非前端编程语言 </category>
          
          <category> CPlusPlus </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>视频的无伤切割</title>
      <link href="/blog/wr3hmo/"/>
      <url>/blog/wr3hmo/</url>
      
        <content type="html"><![CDATA[<p>前言：对于一个很大的视频，不方便和其他用户使用软件传输，需要将其切割成数个小容量视频，两种方法，一种是利用其他软件来进行切割，比如 pr；另一种是利用万能的 ffmpeg，这个需求采用后者方法。<br>需求视频为 8G 多，总时长 01：51：00，QQ 在线传输一次最多 4G，所以需要将目标视频切成三段，需要的命令如下：</p><pre><code class="bash">ffmpeg -ss 00:00:00 -i target.mp4 -c copy -t 00:45:00 target-part1.mp4 #Start～00:45:00ffmpeg -ss 00:45:00 -i target.mp4 -c copy -t 00:45:00 target-part2.mp4 #00:45:00~01:30:00ffmpeg -ss 01:30:00 -i target.mp4 -c copy -t 00:21:00 target-part3.mp4 #01:30:00～End</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1643942474386-cacbcb25-dd05-48fa-b575-7cf6e13eb635.png#clientId=uff142774-4372-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=351&id=u9fb04278&margin=%5Bobject%20Object%5D&name=image.png&originHeight=986&originWidth=1894&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=154312&status=done&style=none&taskId=u4ab79a4b-727e-4224-9ba7-be0ec45918d&title=&width=675" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> 👨‍💻Web开发 </category>
          
          <category> Web业务解决方案 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>多一些沉稳，少一点浮躁</title>
      <link href="/essay/wrlggf/"/>
      <url>/essay/wrlggf/</url>
      
        <content type="html"><![CDATA[<div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">在自己、同学、父母身上学到的一些关于沉稳和浮躁的相关感悟。</div><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1621129502175-8304c744-6269-4ca9-a89f-7180dbd6911c.png#clientId=u24aab093-34a5-4&from=ui&id=ue9157375&margin=%5Bobject%20Object%5D&name=81820014_p0.png&originHeight=822&originWidth=1920&originalType=binary&size=2480417&status=done&style=none&taskId=u45c6efd3-08f2-4e70-a006-a5bd0449320" alt="81820014_p0.png"></p><p><strong>多一些沉稳，少一些浮躁</strong></p><p>真正的技术人是不断去学习技术的，抑或是精进自己已有的技术，而不是像一个井底之蛙，不踏踏实实做技术，只想着一步登云，对技术而言，哪来的精进可言</p><p>这个节奏下面，很多人很多时候被生活牵着走，不再是我们过生活，而是生活过着我们，少了一些风情雅致，多了一些功利与欲望，就像是越肤浅的人，越浮躁，一新急于求成，功利心太重。越是有实力，能将生活活出自我的人越是沉稳安静，不急不躁，踏实努力，以梦为马，执笔为声！</p><p>上面说到功利了，于是乎想到了我父母做生意的那路历程，做生意不可能一直起势，有起就有落，可在一些人眼中，他们所看到的，永远只有起势和高光……大学三年之下，A 同学想着年薪百万，B 同学想着开公司，我觉得这都是可以的，我相信年轻的资本在人生历程中是占比很足的，但是现在细想，那些话的字体行间透露着些许的浮躁，我暂且用野心来代替那些话，我相信野心这个词，但这三年在学校的生活与对社会的前驱认知告诉我，野心是基于沉稳之上的，野心是基于踏实之上，野心更是对理想而拆解成一系列目标并予以实施的基础上的，多一些沉稳，少一些浮躁……</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>哈夫曼树</title>
      <link href="/blog/fyhtb2/"/>
      <url>/blog/fyhtb2/</url>
      
        <content type="html"><![CDATA[<h2 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h2><p>已知某系统在通信联络中只可能出现 n 种字符，其概率从键盘输入。试创建哈夫曼树。</p><h2 id="实验要求"><a href="#实验要求" class="headerlink" title="实验要求"></a>实验要求</h2><p>1、从键盘输入 n, 以及 n 个字符的概率。<br>例如：已知某系统在通信联络中只可能出现 n 种字符，其概率分别为   0.05, 0.29, 0.07, 0.08, 0.14, 0.23, 0.03, 0.11，试设计哈夫曼编码创建哈夫曼树。<br>2、用顺序存储。<br>3、输出结果如下<br> <img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1620964210279-ee3848d0-d031-4dc0-a850-3ae179b7a317.png#align=left&display=inline&height=194&id=lteAK&margin=%5Bobject%20Object%5D&name=image.png&originHeight=234&originWidth=377&size=83624&status=done&style=none&width=312" alt="image.png"><br>交作业时间：下次上机前</p><h2 id="实验代码"><a href="#实验代码" class="headerlink" title="实验代码"></a>实验代码</h2><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;using namespace std;int n, m, s1, s2;typedef struct HTNode&#123;    int weight, parent, lchild, rchild, pos;    bool operator&lt;(const HTNode &amp;a)const   &#123;       return a.weight &lt; weight;   &#125;&#125;HTNode, *HuffmanTree;priority_queue&lt;HTNode&gt;P;void Select(HuffmanTree &amp;HT, int ii, int &amp;s1, int &amp;s2)&#123;    HTNode t = P.top();    s1 = t.pos;    P.pop();    t = P.top();    s2 = t.pos;    P.pop();&#125;void CreateHuffmantree(HuffmanTree &amp;HT, int n)&#123;    if(n &lt;= 1)        return;    m = 2 * n - 1;    HT = new HTNode[m + 1];    for(int i = 1; i &lt;= m; i++)    &#123;        HT[i].parent = 0;        HT[i].lchild = 0;        HT[i].rchild = 0;    &#125;    for(int i = 1; i &lt;= n; ++i)    &#123;        cin &gt;&gt; HT[i].weight;        HT[i].pos = i;        P.push(HT[i]);    &#125;    for(int i = n + 1; i &lt;= m; i++)    &#123;        Select(HT, i - 1, s1, s2);        HT[s1].parent = i;        HT[s2].parent = i;        HT[i].lchild = s1;        HT[i].rchild = s2;        HT[i].weight = HT[s1].weight + HT[s2].weight;        HT[i].pos = i ;        P.push(HT[i]);    &#125;&#125;int main()&#123;    HuffmanTree HT;    cout &lt;&lt; &quot;请输入哈夫曼树的叶子结点个数：&quot;;    cin &gt;&gt; n;    cout &lt;&lt; &quot;请输入每个叶子结点的权值：&quot; &lt;&lt; &#39;\n&#39;;    CreateHuffmantree(HT, n);    for(int i = 1; i &lt;= 2 * n - 1; ++i)    &#123;        cout &lt;&lt; &quot;结点序号 &quot; &lt;&lt; i &lt;&lt; &quot; 权重 &quot; &lt;&lt; HT[i].weight        &lt;&lt; &quot; parent &quot; &lt;&lt; HT[i].parent &lt;&lt; &quot; lchild &quot; &lt;&lt; HT[i].lchild        &lt;&lt; &quot; rchild &quot; &lt;&lt; HT[i].rchild &lt;&lt; &#39;\n&#39;;    &#125;&#125;</code></pre><h2 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h2><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1621215937466-2f1ef720-c7ae-4103-bf0b-0f75855059ff.png#align=left&display=inline&height=246&id=mQROC&margin=%5Bobject%20Object%5D&name=image.png&originHeight=491&originWidth=738&size=72930&status=done&style=none&width=369" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 🌲树结构：二叉树-哈夫曼树 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>树的基本知识</title>
      <link href="/blog/tyyaq0/"/>
      <url>/blog/tyyaq0/</url>
      
        <content type="html"><![CDATA[<p>这是加密文章！</p>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 🌲树结构：二叉树-哈夫曼树 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>blob格式视频链接的下载</title>
      <link href="/blog/bhnvxw/"/>
      <url>/blog/bhnvxw/</url>
      
        <content type="html"><![CDATA[<h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><p>有些网页的视频链接（html 中）如下格式会下载不了，也没有视频的 url 可供访问</p><ul><li>具体网页：<code>[https://5kb.co/vodplay/33666-2-1.html](https://5kb.co/vodplay/33666-2-1.html)</code></li><li>网页中的 blob 视频格式</li></ul><pre><code class="html">&lt;img src: &quot;blob:https://5kb.co/a504161c-cf27-4979-a1c3-86a0ce4f6556&quot;&gt;</code></pre><ul><li>控制台查看后缀为 m3u8 的接口访问网络请求</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1641182194610-2c7ff9b7-6445-45b3-b2d9-fcbe164705b4.png#clientId=ud4ecb184-a2b9-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=138&id=u616d033a&margin=%5Bobject%20Object%5D&name=image.png&originHeight=138&originWidth=820&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=18130&status=done&style=none&taskId=u850fd681-0a6e-4b69-934a-7b8783ced99&title=&width=820" alt="image.png"></p><h3 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h3><p>思路：安装 ffmpeg 环境，利用转换命令将其转换为 MP4 资源</p><ul><li>ffmpeg 环境的安装：<a href="https://www.yuque.com/wztlink1013/blog/akf33e#pDCNT">https://www.yuque.com/wztlink1013/blog/akf33e#pDCNT</a></li><li>转换命令：</li></ul><pre><code>ffmpeg -i https://v3.dious.cc/20210520/8sKShH2U/index.m3u8 target.mp4</code></pre><h3 id="关于-blob-视频加密相关知识"><a href="#关于-blob-视频加密相关知识" class="headerlink" title="关于 blob 视频加密相关知识"></a>关于 blob 视频加密相关知识</h3><p>blob 视频加密就相当于将原视频 url 进行隐藏，然后切片访问播放。<br>那么网页如何成功加载该视频呢？服务器会返回一个 m3u8 的响应文件，这个文件的作用就是正确找到所有的切片，然后拼接播放。</p><p>在使用 ffmpeg 将其拼接 ts 文件称 mp4 文件过程中，如下：<br><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1641183335922-952b5616-e47f-44fa-89b6-4f6abaf78157.png#clientId=ud4ecb184-a2b9-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=327&id=u8b056dae&margin=%5Bobject%20Object%5D&name=image.png&originHeight=327&originWidth=1402&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=125630&status=done&style=none&taskId=u656b0749-fbd8-4b75-bebb-48b89c7d550&title=&width=1402" alt="image.png"><br>那么 ts 文件又是什么用的呢？<br>百度百科的定义：</p><blockquote><p>ts 是日本高清摄像机拍摄下进行的封装格式，全称为 MPEG2-TS。ts 即”Transport Stream”的缩写。MPEG2-TS 格式的特点就是要求从视频流的任一片段开始都是可以独立解码的。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 👨‍💻Web开发 </category>
          
          <category> Web业务解决方案 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>二叉树的创建与遍历🔖DFS🔖先序🔖中序🔖后序</title>
      <link href="/blog/ggimdr/"/>
      <url>/blog/ggimdr/</url>
      
        <content type="html"><![CDATA[<h2 id="实验报告"><a href="#实验报告" class="headerlink" title="实验报告"></a>实验报告</h2><blockquote><p>编写一个程序，实现二叉树的各种运算，并在此基础上设计一个程序完成如下功能：</p></blockquote><blockquote><p>（1）创建一棵二叉树（用键盘按照<strong>先序遍历</strong>序列输入一个字符串生成二叉树）；<br>（2）输出前序、中序、后序遍历的遍历序列；  <br>（3）统计并输出二叉树的的结点个数；<br>（4）输出二叉树的叶子结点的个数；(选做)</p></blockquote><blockquote><p>实验要求：</p></blockquote><blockquote><p>用键盘输入一个字符串，按照<strong>满二叉树的特点</strong>生成一棵二叉树。</p></blockquote><blockquote><p>测试用例要求：</p></blockquote><blockquote><p>如下二叉树的输入字符串为：ABD###C#E##<br>书写方法：碰到#说明该二叉树是一棵空树，注意分配（下面缺两个左右补两个#，缺一个左/右子树，补一个#）</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1620295747111-4774a4a6-b617-4f26-a0c3-f9f1bdb386cc.png#crop=0&crop=0&crop=1&crop=1&height=139&id=Fl1gC&margin=%5Bobject%20Object%5D&name=image.png&originHeight=278&originWidth=470&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=10375&status=done&style=stroke&title=&width=235" alt="image.png"></p><blockquote><p>二叉链表的结点类型（C++）：</p></blockquote><pre><code class="cpp">Typedef structure  tnode&#123;    int   data;    structure  tnode   *lchild, *rchild;&#125;bitree,*bitlink ;</code></pre><h2 id="实验代码"><a href="#实验代码" class="headerlink" title="实验代码"></a>实验代码</h2><p>用上面的二叉树作为例子：</p><pre><code class="cpp">#include&lt;bits/stdc++.h&gt;using namespace std;typedef int Status;typedef char TElemType;#define OVERFLOW -1#define ERROR 0#define OK 1char ch;/** * 采用二叉链表的存储形式 */typedef struct BiTNode&#123;    TElemType data;    struct BiTNode *lchild, *rchild;&#125;BiTNode, *BiTree;/** * 创建一棵二叉树 */void CreateBiTree(BiTree &amp;T) &#123;    //按先序次序输入二叉树中结点的值，创建二叉链表表示的二叉树T    TElemType ch;    cin&gt;&gt;ch;    if(ch == &#39;#&#39;)&#123;//递归结束，建空树        T = NULL;    &#125; else &#123;        T = new BiTNode;        T-&gt;data = ch;        CreateBiTree(T-&gt;lchild);        CreateBiTree(T-&gt;rchild);    &#125;&#125;/** * 先序遍历 */void PreOrderTraverse(BiTree &amp;T)&#123;//先序遍历二叉树T的递归算法    if(T)                               //若二叉树非空    &#123;        cout &lt;&lt; T-&gt;data &lt;&lt; &quot; &quot;;                  //访问根结点        PreOrderTraverse(T-&gt;lchild);     //中序遍历左子树        PreOrderTraverse(T-&gt;rchild);     //中序遍历右子树    &#125;&#125;/** * 中序遍历 */void InOrderTraverse(BiTree &amp;T) &#123;    if (T) &#123;        InOrderTraverse(T-&gt;lchild);        cout &lt;&lt; T-&gt;data &lt;&lt; &quot; &quot;;        InOrderTraverse(T-&gt;rchild);    &#125;&#125;/** * 后序遍历 */void PostOrderTraverse(BiTree &amp;T)&#123;//后序遍历二叉树T的递归算法    if(T)                               //若二叉树非空    &#123;        PostOrderTraverse(T-&gt;lchild);   //中序遍历左子树        PostOrderTraverse(T-&gt;rchild);   //中序遍历右子树        cout &lt;&lt; T-&gt;data &lt;&lt; &quot; &quot;;                 //访问根结点    &#125;&#125;/** * 统计二叉树中节点个数 */int NodeCount (BiTree &amp;T) &#123;    if (T == NULL) &#123;        return 0;    &#125; else &#123;        return NodeCount(T-&gt;lchild) + NodeCount(T-&gt;rchild) + 1;    &#125;&#125;/** * 二叉树中叶结点个数 */int LeavesCount (BiTree &amp;T) &#123;    if (T == NULL) &#123;        return 0;    &#125; else if (T-&gt;lchild == NULL &amp;&amp; T-&gt;rchild == NULL) &#123;        return LeavesCount(T-&gt;lchild) + LeavesCount(T-&gt;rchild) + 1;    &#125;    else &#123;        return LeavesCount(T-&gt;lchild) + LeavesCount(T-&gt;rchild);    &#125;&#125;int main() &#123;    BiTree test = new BiTNode;    cout &lt;&lt; &quot;请输入一个字符串以生成二叉树：&quot;;    CreateBiTree(test);    cout &lt;&lt;&quot;\n&quot;&lt;&lt; &quot;先序遍历结果：&quot;;    PreOrderTraverse(test);    cout &lt;&lt;&quot;\n&quot;&lt;&lt; &quot;中序遍历结果：&quot;;    InOrderTraverse(test);    cout &lt;&lt;&quot;\n&quot;&lt;&lt; &quot;后序遍历结果：&quot;;    PostOrderTraverse(test);    cout &lt;&lt;&quot;\n&quot;&lt;&lt; &quot;二叉树结点个数：&quot;&lt;&lt;NodeCount(test);    cout &lt;&lt;&quot;\n&quot;&lt;&lt; &quot;二叉树叶结点个数：&quot;&lt;&lt;LeavesCount(test);&#125;</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1620302765118-f27235d1-7167-40ae-ab80-dc23494d55cc.png#crop=0&crop=0&crop=1&crop=1&height=129&id=fbgNz&margin=%5Bobject%20Object%5D&name=image.png&originHeight=258&originWidth=1025&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=38229&status=done&style=none&title=&width=512.5" alt="image.png"></p><h2 id="DFS-遍历算法"><a href="#DFS-遍历算法" class="headerlink" title="DFS 遍历算法"></a>DFS 遍历算法</h2><p><strong>DFS 遍历分三种情况：先序、中序、后序</strong></p><div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">把一颗树遍历完，有下面三种方法：<ul><li><strong>波兰</strong>表达式 -&gt; ** 先序**遍历二叉树</li><li><strong>中缀</strong>表达式 -&gt; <strong>中序</strong>遍历二叉树</li><li><strong>逆波兰</strong>表达式 -&gt;** 后序**遍历二叉树</div></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1620298049502-63346474-7a61-45cf-88a8-56c66954d894.png#crop=0&crop=0&crop=1&crop=1&height=335&id=WLPKa&margin=%5Bobject%20Object%5D&name=image.png&originHeight=670&originWidth=771&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=277201&status=done&style=stroke&title=&width=385.5" alt="image.png"></p><h3 id="手写例子"><a href="#手写例子" class="headerlink" title="手写例子"></a>手写例子</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1620298098593-6760a592-4907-4662-a4be-404dde35d246.png#crop=0&crop=0&crop=1&crop=1&height=208&id=zsvnG&margin=%5Bobject%20Object%5D&name=image.png&originHeight=416&originWidth=590&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=90670&status=done&style=stroke&title=&width=295" alt="image.png"></p><p>各种遍历结果</p><ul><li>先序：-+a*b-cd/ef</li><li>中序：a+b*c-d-e/f</li><li>后序：abcd-*+ef/-</li></ul><h3 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h3><ul><li><a href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/">144. 二叉树的前序遍历</a></li></ul><pre><code class="javascript">/** * Definition for a binary tree node. * function TreeNode(val, left, right) &#123; *     this.val = (val===undefined ? 0 : val) *     this.left = (left===undefined ? null : left) *     this.right = (right===undefined ? null : right) * &#125; *//** * @param &#123;TreeNode&#125; root * @return &#123;number[]&#125; */var preorderTraversal = function (root) &#123;  let result = [];  let preorder = (data) =&gt; &#123;    if (data) &#123;      result.push(data.val);      preorder(data.left);      preorder(data.right);    &#125;  &#125;;  preorder(root);  return result;&#125;;</code></pre><h3 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h3><ul><li><a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/">94. 二叉树的中序遍历</a></li></ul><pre><code class="javascript">/** * Definition for a binary tree node. * function TreeNode(val, left, right) &#123; *     this.val = (val===undefined ? 0 : val) *     this.left = (left===undefined ? null : left) *     this.right = (right===undefined ? null : right) * &#125; *//** * @param &#123;TreeNode&#125; root * @return &#123;number[]&#125; */var inorderTraversal = function (root) &#123;  let result = [];  let inorder = (data) =&gt; &#123;    if (data) &#123;      inorder(data.left);      result.push(data.val);      inorder(data.right);    &#125;  &#125;;  inorder(root);  return result;&#125;;</code></pre><h3 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h3><ul><li><a href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/">145. 二叉树的后序遍历</a></li></ul><pre><code class="javascript">/** * Definition for a binary tree node. * function TreeNode(val, left, right) &#123; *     this.val = (val===undefined ? 0 : val) *     this.left = (left===undefined ? null : left) *     this.right = (right===undefined ? null : right) * &#125; *//** * @param &#123;TreeNode&#125; root * @return &#123;number[]&#125; */var postorderTraversal = function (root) &#123;  let result = [];  let postorder = (data) =&gt; &#123;    if (data) &#123;      postorder(data.left);      postorder(data.right);      result.push(data.val);    &#125;  &#125;;  postorder(root);  return result;&#125;;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 🌲树结构：二叉树-哈夫曼树 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>实验5——波兰/逆波兰表达式求值🔖栈</title>
      <link href="/blog/iyb7wi/"/>
      <url>/blog/iyb7wi/</url>
      
        <content type="html"><![CDATA[<h2 id="实验报告"><a href="#实验报告" class="headerlink" title="实验报告"></a>实验报告</h2><p>实验五：实现用波兰表达式（先序）和逆波兰表达式（后序）求算术表达式的值<br>要求：仅用一个栈实现（并且用原生单链表实现）<br>测试用例：4+2*3-10/5<br>交作业时间：5 月 14 日</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>两个步骤：</p><ol><li><strong>将给定的表达式转换为波兰表达式/逆波兰表达式</strong></li><li><strong>对转换后的式子进行计算</strong></li></ol><p>学习遍历二叉树，利用前序/中序/后序表达式的时候，经常有一个问题就是：</p><ul><li><input checked="" disabled="" type="checkbox"> 给出中缀表达式，【写出&amp;&amp;编程出】后序（逆波兰）表达式</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1620306330357-a83abeff-56a3-44f1-b837-82051f46e3b5.png#crop=0&crop=0&crop=1&crop=1&height=175&id=ZAX5A&margin=%5Bobject%20Object%5D&name=image.png&originHeight=754&originWidth=1023&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=63695&status=done&style=none&title=&width=237" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1620306352380-f6eef790-b72d-4e1d-9da1-6597ec5ae11d.png#crop=0&crop=0&crop=1&crop=1&height=176&id=zESCQ&margin=%5Bobject%20Object%5D&name=image.png&originHeight=610&originWidth=1021&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=59737&status=done&style=none&title=&width=294" alt="image.png"><br>上面的是课堂上在纸上的书写，那么如何将其用编程语言实现呢？思路应该是这样的：</p><ul><li><p>遍历表达式：对遍历的元素进行判断</p></li><li><p>是运算符？操作数？还是括号呢？对其相应的判断</p><ul><li>操作数</li><li>运算符：+-*/</li><li>括号</li></ul></li><li><p><input checked="" disabled="" type="checkbox">  个位数/双位数……的字符处理</p></li><li><p><input checked="" disabled="" type="checkbox">  给出中缀表达式，【写出&amp;&amp;编程出】前序（波兰）表达式</p></li></ul><p>如果写出了逆波兰表达式，转换为波兰表达式只需要将<code>（</code>变为<code>）</code>，同时遍历从后往前遍历即可</p><p>最后的结果逆置</p><ul><li><input checked="" disabled="" type="checkbox"> 最后的计算，波兰和逆波兰不能写成一个函数，因为减数和被减数，除数和被除数的缘故</li></ul><h2 id="实验代码"><a href="#实验代码" class="headerlink" title="实验代码"></a>实验代码</h2><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1620979662957-690a9050-8a82-4170-816b-ffcff99f38d7.png#crop=0&crop=0&crop=1&crop=1&height=220&id=Kzxk3&margin=%5Bobject%20Object%5D&name=Snipaste_2021-05-14_11-20-30.png&originHeight=220&originWidth=500&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=13118&status=done&style=none&title=&width=500" alt="Snipaste_2021-05-14_11-20-30.png"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1620979669021-d90e4ff6-feb6-4df9-9f6a-d7176b25d258.png#crop=0&crop=0&crop=1&crop=1&height=202&id=XDVSW&margin=%5Bobject%20Object%5D&name=Snipaste_2021-05-14_11-20-43.png&originHeight=202&originWidth=446&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=12040&status=done&style=none&title=&width=446" alt="Snipaste_2021-05-14_11-20-43.png"></p><pre><code class="cpp">#include&lt;bits/stdc++.h&gt;using namespace std;/** * 波兰表达式/逆波兰表达式求解运算表达式 * *//** * 单链表的存储结构 */typedef struct LNode &#123;    string data; //数据域    struct LNode *next; //指针域&#125;Lnode, *LinkList; //LinkList为指向结构体LNode的指针类型/* 初始化链表 */void InitList(LinkList &amp;L) &#123;    L = new LNode;    L-&gt;next = NULL;&#125;/* 打印 */void TraverseList(LinkList &amp; L)&#123;        LNode *p = new LNode;        p = L-&gt;next;        // cout &lt;&lt; &quot;此中缀表达式链表打印的结果为：&quot;;        while (p != NULL)        &#123;            cout &lt;&lt; p-&gt;data;            p = p-&gt;next;        &#125;        cout &lt;&lt; &quot;\n&quot;;&#125;/* 逆置 */void ReverseList(LinkList &amp;L) &#123;    LNode *p = L-&gt;next;    L-&gt;next = NULL;    while(p)    &#123;        LNode *q = p-&gt;next;        p-&gt;next = L-&gt;next;        L-&gt;next = p;        p = q;    &#125;&#125;/** * 初始化用户输入的链表 */void Center(LinkList &amp;L,string s) &#123;    InitList(L);    LinkList p = L;    string temp = &quot;&quot;;    for (int i = 0; i &lt; s.length();i++)&#123;        // 处理双位数字情况        if (isdigit(s[i])) &#123;            // 该字符为数字            temp = temp + s[i];            if (!isdigit(s[i+1])) &#123;                // 下一个不是数字，而是字符，将temp后插                LinkList node = new LNode;                node-&gt;data = temp;                node-&gt;next = NULL;                p-&gt;next = node;                p = node;                // 将temp重置                temp = &quot;&quot;;                continue;            &#125;            continue;        &#125;        // 后插到L尾巴上        LinkList node = new LNode;        node-&gt;data = s[i];        node-&gt;next = NULL;        p-&gt;next = node;        p = node;    &#125;&#125;/** * 将表达式转换为波兰表达式/逆波兰表达式 * 第二个参数对逆波兰而言是左括号，第三个参数对逆波兰而言是右括号 * 对波兰而言反过来 */void Transition(LinkList &amp;L, string l, string r)&#123;    // 定义一个栈用来处理    stack&lt;string&gt; stack;    LinkList p = L-&gt;next;    LinkList result = new LNode;    InitList(result);    LinkList result_a = result;    while(p != NULL) &#123;        if (p-&gt;data == l) &#123;            stack.push(p-&gt;data);        &#125; else if(p-&gt;data == r) &#123;            while(stack.top() != l)&#123;                LinkList temp = new LNode;                temp-&gt;data = stack.top();                temp-&gt;next = NULL;                result_a-&gt;next = temp;                result_a = temp;                stack.pop();            &#125;            if (stack.top() == l)&#123;                stack.pop();            &#125;        &#125; else if(p-&gt;data == &quot;+&quot; || p-&gt;data == &quot;-&quot;) &#123;            if (stack.size() != 0) &#123;                if (stack.top() == &quot;*&quot; || stack.top() == &quot;/&quot;)&#123;                    for (int i = 0; i &lt; stack.size();i++) &#123;                        if (stack.top() == l) &#123;                            break;                        &#125;                        LinkList temp = new LNode;                        temp-&gt;data = stack.top();                        temp-&gt;next = NULL;                        result_a-&gt;next = temp;                        result_a = temp;                        stack.pop();                    &#125;                &#125;            &#125;            stack.push(p-&gt;data);        &#125; else if(p-&gt;data == &quot;*&quot; || p-&gt;data == &quot;/&quot;) &#123;            stack.push(p-&gt;data);        &#125; else &#123;            LinkList temp = new LNode;            temp-&gt;data = p-&gt;data;            temp-&gt;next = NULL;            result_a-&gt;next = temp;            result_a = temp;        &#125;        p = p-&gt;next;    &#125;    // TraverseList(result);    for (int i = 0; i &lt; stack.size();i++) &#123;        LinkList temp = new LNode;        temp-&gt;data = stack.top();        temp-&gt;next = NULL;        result_a-&gt;next = temp;        result_a = temp;        stack.pop();    &#125;    // 上一个操作总是不能清空栈的最后一个元素    LinkList temp = new LNode;    temp-&gt;data = stack.top();    temp-&gt;next = NULL;    result_a-&gt;next = temp;    result_a = temp;    stack.pop();    L = result;&#125;/** * 计算 */void EvaulTree(LinkList &amp;L) &#123;    // 定义一个栈用来处理    stack&lt;string&gt; stack;    LinkList p = L-&gt;next;    while(p != NULL) &#123;        if (p-&gt;data == &quot;+&quot;)&#123;            int x = stoi(stack.top());            stack.pop();            int y = stoi(stack.top());            stack.pop();            stack.push(to_string(y + x));        &#125; else if(p-&gt;data == &quot;-&quot;) &#123;            int x = stoi(stack.top());            stack.pop();            int y = stoi(stack.top());            stack.pop();            stack.push(to_string(y - x));        &#125; else if(p-&gt;data == &quot;*&quot;) &#123;            int x = stoi(stack.top());            stack.pop();            int y = stoi(stack.top());            stack.pop();            stack.push(to_string(y * x));        &#125; else if(p-&gt;data == &quot;/&quot;) &#123;            int x = stoi(stack.top());            stack.pop();            int y = stoi(stack.top());            stack.pop();            stack.push(to_string(y / x));        &#125; else &#123;            stack.push(p-&gt;data);        &#125;        p = p-&gt;next;    &#125;    while (!stack.empty())&#123;        cout &lt;&lt; stoi(stack.top());        stack.pop();    &#125;&#125;void EvaulTree_polish(LinkList &amp;L) &#123;    // 定义一个栈用来处理    stack&lt;string&gt; stack;    LinkList p = L-&gt;next;    while(p != NULL) &#123;        if (p-&gt;data == &quot;+&quot;)&#123;            int x = stoi(stack.top());            stack.pop();            int y = stoi(stack.top());            stack.pop();            stack.push(to_string(x + y));        &#125; else if(p-&gt;data == &quot;-&quot;) &#123;            int x = stoi(stack.top());            stack.pop();            int y = stoi(stack.top());            stack.pop();            stack.push(to_string(x - y));        &#125; else if(p-&gt;data == &quot;*&quot;) &#123;            int x = stoi(stack.top());            stack.pop();            int y = stoi(stack.top());            stack.pop();            stack.push(to_string(x * y));        &#125; else if(p-&gt;data == &quot;/&quot;) &#123;            int x = stoi(stack.top());            stack.pop();            int y = stoi(stack.top());            stack.pop();            stack.push(to_string(x / y));        &#125; else &#123;            stack.push(p-&gt;data);        &#125;        p = p-&gt;next;    &#125;    while (!stack.empty())&#123;        cout &lt;&lt; stoi(stack.top());        stack.pop();    &#125;&#125;int main () &#123;    cout &lt;&lt; &quot;------------------------------------&quot;&lt;&lt;&quot;\n&quot;;    string s;    cout &lt;&lt; &quot;请输入运算表达式：&quot;&lt;&lt;&quot;\n&quot;;    cin &gt;&gt; s;    LinkList test_reversepolish = new LNode;    InitList(test_reversepolish);    LinkList test_polish = new LNode;    InitList(test_polish);    Center(test_reversepolish, s);    Center(test_polish, s);    cout &lt;&lt; &quot;------------------------------------&quot;&lt;&lt;&quot;\n&quot;;    // 波兰表达式    ReverseList(test_polish);    Transition(test_polish, &quot;)&quot;, &quot;(&quot;);    cout &lt;&lt; &quot;波兰表达式为：&quot;;    ReverseList(test_polish);    TraverseList(test_polish);    cout &lt;&lt; &quot;波兰表达式计算结果为：&quot;;    ReverseList(test_polish);    EvaulTree_polish(test_polish);    cout &lt;&lt; &quot;\n&quot;&lt;&lt;&quot;------------------------------------&quot;&lt;&lt;&quot;\n&quot;;    // 逆波兰表达式    Transition(test_reversepolish, &quot;(&quot;, &quot;)&quot;);    cout &lt;&lt; &quot;逆波兰表达式为：&quot;;    TraverseList(test_reversepolish);    cout &lt;&lt; &quot;逆波兰表达式计算结果为：&quot;;    EvaulTree(test_reversepolish);    cout &lt;&lt; &quot;\n&quot;&lt;&lt;&quot;------------------------------------&quot;&lt;&lt;&quot;\n&quot;;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> Problems </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>BF和KMP模式匹配算法</title>
      <link href="/blog/ah7arw/"/>
      <url>/blog/ah7arw/</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1620290726560-b77d1aa1-b7ed-4561-95b4-0e8f7e643ca9.png#align=left&display=inline&height=161&margin=%5Bobject%20Object%5D&name=image.png&originHeight=321&originWidth=723&size=31460&status=done&style=stroke&width=361.5" alt="image.png"></p><div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">在进行字符串匹配的相关程序中，看一个子串是否在一个主串里面，有著名的Brute-Force和基于此改进的KMP算法，具体学习记录如下：</div><h2 id="Brute-Force"><a href="#Brute-Force" class="headerlink" title="Brute-Force"></a>Brute-Force</h2><blockquote><p>给出一个主串和一个子串<br>主串：s = ababc<strong>abcac</strong>bab<br>子串：t = abcac</p></blockquote><p>①BF 算法算是一种暴力算法，首先是查看 t 的第一字母 a 和上面 s 的第一个字母比较相同，所以接着比较比到各自的第三个字符也就是，aba、abc 发现不同，</p><p>② 再递推比较，t 回到第一个字母 a，这时 s 回到第二个字符（因为第一个字符已经比过了）相当于 babcabcacbab 和 abcac 两个字符串进行比较，很明显第一个字符就不一样，</p><p>③ 再递推比较……</p><p>按常理来思考，这样总能得出结果，但是在此基础上，可以有进一步的优化操作，怎么说？<img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1617677082076-945e1a85-4b75-40ad-a413-46f7e514b7f4.jpeg#align=left&display=inline&height=59&margin=%5Bobject%20Object%5D&name=huaji1558a846ddf2e12b.jpeg&originHeight=59&originWidth=55&size=703&status=done&style=stroke&width=55" alt="huaji1558a846ddf2e12b.jpeg"><br>在上面的第 ② 步里面，我们总是一步一步递推，那我们能不能一次性推好几步呢？就根据已经匹配了的那串字母。</p><p>具体表现为：① 已经发现是第三个字符不同，那我们就根据前面两个相同的字符（ab）推出第 ② 步推两步，为什么根据相同的 ab，第 ② 个步骤就可以一次性走两步？</p><h2 id="KMP-算法"><a href="#KMP-算法" class="headerlink" title="KMP 算法"></a>KMP 算法</h2><h3 id="算法详述"><a href="#算法详述" class="headerlink" title="算法详述"></a>算法详述</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1617677082076-945e1a85-4b75-40ad-a413-46f7e514b7f4.jpeg#align=left&display=inline&height=59&margin=%5Bobject%20Object%5D&name=huaji1558a846ddf2e12b.jpeg&originHeight=59&originWidth=55&size=703&status=done&style=stroke&width=55" alt="huaji1558a846ddf2e12b.jpeg">先学会用，理论日后再补…… 🕊</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1620286656388-6b7c4ae0-8c01-4ae5-9451-9d17c63a23bb.png#align=left&display=inline&height=70&margin=%5Bobject%20Object%5D&name=image.png&originHeight=139&originWidth=725&size=10548&status=done&style=stroke&width=362.5" alt="image.png"></p><h3 id="计算-next-函数值"><a href="#计算-next-函数值" class="headerlink" title="计算 next 函数值"></a>计算 next 函数值</h3><blockquote><p>（3）串“ababaaababaa”的 next 数组为（  ）。<br>A．012345678999   B．012121111212   C．011234223456    D．0123012322345<br>答案：C</p></blockquote><table><thead><tr><th>j</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th><th>11</th><th>12</th></tr></thead><tbody><tr><td>t</td><td>a</td><td>b</td><td>a</td><td>b</td><td>a</td><td>a</td><td>a</td><td>b</td><td>a</td><td>b</td><td>a</td><td>a</td></tr><tr><td>next(j)</td><td>0</td><td>1</td><td>1</td><td>2</td><td>3</td><td>4</td><td>2</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td></tr></tbody></table><p>方法：<br>①next 数组第一位永远是 0，1；<br>②next(j) = 前序列相同元素个数 + 1；</p><p>eg：当 t = 6：<br>前面的序列为 ababa，可以看出相同的子序列为 aba，相同元素个数为 3，所以 next(6) = 3 + 1 = 4</p><p>注意：不能“全覆盖”，比如当 j = 2 时候，前面的 a 不能看成 a = a 序列，这样就变成 next(2) = 2 了；</p><h3 id="计算-next-函数修正值"><a href="#计算-next-函数修正值" class="headerlink" title="计算 next 函数修正值"></a>计算 next 函数修正值</h3><blockquote><p>（4）串“ababaabab”的 nextval 为（  ）。<br>A．010104101      B．010102101      C．010100011       D．010101011  <br>答案：A</p></blockquote><table><thead><tr><th>j</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th></tr></thead><tbody><tr><td>t</td><td>a</td><td>b</td><td>a</td><td>b</td><td>a</td><td>a</td><td>b</td><td>a</td><td>b</td></tr><tr><td>next(j)</td><td>0</td><td>1</td><td>1</td><td>2</td><td>3</td><td>4</td><td>2</td><td>3</td><td>4</td></tr><tr><td>nextval(j)</td><td>0</td><td>1</td><td>0</td><td>1</td><td>0</td><td>4</td><td>1</td><td>0</td><td>1</td></tr></tbody></table><p>方法：<br>① 先列举出 next(j)，求 nextval(j)是基于 next(j)的；<br>② 求 nextval(j)，先看求 next(j)的值，记这个值为 x；<br>③ 在表格中找出 j = x 的那一列，如果这一列的 t 值和 ② 步骤中的 t 值相同，则结果为 j = x 这一列的 nextval(j)值，如果不相同，则结果为所要求的那一列的 next(j)值；</p><p>eg：当 j = 5 时：<br>此时 next(j) = 3，就去 j = 3 那一列看到 t = a，和 j = 5 一列的 t 值 a 相同，所以结果为 j = 3 一列的 nextval 值 0</p><p>eg：当 j = 6 时：<br>此时 next(j) = 4，就去 j = 4 那一列看到 t = b，和 j = 6 一列的 t 值不相同，所以结果为 j = 6 一列的 next 值 4</p><h3 id="具体匹配情况"><a href="#具体匹配情况" class="headerlink" title="具体匹配情况"></a>具体匹配情况</h3><blockquote><p>（2）设目标为 t=“abcaabbabcabaacbacba”,模式为 p=“abcabaa”<br>① 计算模式 p 的 naxtval 函数值；<br>② 不写出算法,只画出利用 KMP 算法进行模式匹配时每一趟的匹配过程。</p></blockquote><p>答案：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1620290726560-b77d1aa1-b7ed-4561-95b4-0e8f7e643ca9.png#align=left&display=inline&height=161&margin=%5Bobject%20Object%5D&name=image.png&originHeight=321&originWidth=723&size=31460&status=done&style=stroke&width=361.5" alt="image.png"></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre><code class="cpp">#include&lt;bits/stdc++.h&gt;using namespace std;typedef int Status;typedef int ElemType;#define OVERFLOW -1#define ERROR 0#define OK 1//------串的顺序存储结构-----#define MAXLEN 225typedef struct&#123;    char ch[MAXLEN + 1];    //存储串的一维数组，从下标为1的数组分量开始存储的，下标为0的分量闲置不用    int length;             //串的当前长度&#125;SString;//------串的堆式顺序存储结构-----typedef struct&#123;    char *ch;       //若是非空串，则按串长分配存储区，否则ch为NULL    int length;     //串的当前长度&#125;HString;HString S, T;//-----串的链式存储结构-----#define CHUNKSIZE 80typedef struct Chunk&#123;    char ch[CHUNKSIZE];    struct Chunk *next;&#125;Chunk;typedef struct&#123;    Chunk *head, *tail;     //串的头指针和尾指针    int length;             //串的当前长度&#125;LString;// //1、生成串// StrAssign(&amp;T, chars)// //2、复制// StrCopy(&amp;T, S)// //3、判空// StrEmpty(S)// //4、比较// StrCompare(S, T)// //5、长度// StrLength(S)// //6、清空// ClearString(&amp;S)// //7、联接// Concat(&amp;T, S1, S2)// //8、子串// SubString(⋐, S, pos, len)//9、串的模式匹配_BF算法 O(n * m)int Index_BF(HString S, HString T, int pos)&#123;//返回模式T在主串s中第pos个字符开始第一次出现的位置。若不存在，则返回值为0 //其中，T非空，1&lt;=pos&lt;=S.length    int i = pos, j = 1;                     //初始化    while(i &lt;= S.length &amp;&amp; j &lt;= T.length)   //两串均未比较到串尾    &#123;        if(S.ch[i] == T.ch[j])              //继续比较后继字符        &#123;            i++;            j++;        &#125;        else                                //指针后退重新开始匹配        &#123;            i = i - j + 2;                  //i=i-j+1回到i的起点，+2到下一个字符            j = 1;        &#125;    &#125;    if(j &gt; T.length)            return i - T.length;            //匹配成功，返回T在S中第一次出现的位置        else            return 0;&#125;//9、串的模式匹配_KMP算法求next数组void get_next(HString, int next[])&#123;//求模式串T的next函数值并存入数组next    int j = 1, t = 0;    next[1] = 0;    while(j &lt; T.length)    &#123;        if(t == 0 || T.ch[j] == T.ch[t])        &#123;            t++;            j++;            next[j] = t;        &#125;        else            t = next[t];    &#125;&#125;//9、串的模式匹配_KMP算法求nextval数组void get_nextval(HString T, int nextval[])&#123;//求模式串T的next函数修正值并存入数组nextval    int j = 1, t = 0;    nextval[1] = 0;    while(j &lt; T.length)    &#123;        if(t == 0 || T.ch[j] == T.ch[t])        &#123;            t++;            j++;            if(T.ch[j] != T.ch[t])                nextval[j] = t;            else                nextval[j] = nextval[t];        &#125;        else            t = nextval[t];    &#125;&#125;//9、串的模式匹配_KMP算法 O(n + m)int Index_KMP(HString S, HString T, int pos, int next[])&#123;//利用模式串T的next函数求T在主串S中第pos个字符之后的位置 //其中，T非空，1&lt;=pos&lt;=S.length    int i = pos, j = 1;    while(i &lt;= S.length &amp;&amp; j &lt;= S.length)   //两个串均未比较到串尾    &#123;        if(j == 0 || S.ch[i] == T.ch[i])    //继续比较后继字符        &#123;            i++;            j++;        &#125;        else            j = next[j];                    //模式串向右移动        if(j &gt; T.length)                    //匹配成功            return i - T.length;        else            return 0;    &#125;&#125;// //10、插入// Strlnsert(&amp;S, pos, T)// //11、删除// StrDelete(&amp;S, pos, len)// //12、销毁// DestroyString(&amp;S)</code></pre>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 🥢KMP类算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>《文城》——我也曾是林详福</title>
      <link href="/essay/ll4lrz/"/>
      <url>/essay/ll4lrz/</url>
      
        <content type="html"><![CDATA[<blockquote><p>文城（《活着》作者余华时隔 8 年，全新长篇重磅归来。关于一个人和他一生的寻找，以及一群人和一个汹涌的年代。他原本不属于这里，但许多人的牵挂和眼泪都留在了他身上） (余华)</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2021/webp/1484158/1620263368423-1137b0d5-338f-4b67-8710-05113a05e2cf.webp#height=352&id=q1Cav&originHeight=2468&originWidth=1716&originalType=binary%E2%88%B6=1&size=0&status=done&style=stroke&width=245"></p><blockquote><p>七月三号阅读小记</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1625267396039-fd9ba6e0-3e18-4d2d-abf1-ac129db4ec64.png#height=3329&id=wN6zS&margin=%5Bobject%20Object%5D&name=Notepad_202107030704_20075.png&originHeight=3329&originWidth=1128&originalType=binary%E2%88%B6=1&size=2787030&status=done&style=none&width=1128" alt="Notepad_202107030704_20075.png"></p><ul><li>您在位置 #275-277 的标注 | 添加于 2021 年 4 月 28 日星期三 下午 2:27:12</li></ul><div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">她一边说一边笑，她的眼睛闪闪发亮，这是林祥福第一次见到小美这样的神态。一个在屋子里走动时只有木屐声响的女子，一个不会笑出声音而是将笑意含在嘴角的女子，此刻容光焕发了。</div><ul><li>您在位置 #289-289 的标注 | 添加于 2021 年 4 月 28 日星期三 下午 2:29:19</li></ul><div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">刚才屋顶被砸出的洞口纷纷落下来碗大的雨雹，砸到地上后犹如花开花谢。</div><ul><li>您在位置 #330-330 的标注 | 添加于 2021 年 4 月 28 日星期三 下午 2:33:05</li></ul><div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">“天下棺材七尺三。”</div><ul><li>您在位置 #474-476 的标注 | 添加于 2021 年 4 月 28 日星期三 下午 2:46:24</li></ul><div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">人生在世祸福难测，有一门技艺在身能够逢凶化吉，技艺是怎么也不会败落的。林祥福觉得自己的木工技艺应该更上一层楼，应该继续去拜师学艺。</div><ul><li>您在位置 #818-819 的标注 | 添加于 2021 年 4 月 28 日星期三 下午 3:09:19</li></ul><div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">晚霞在明净的天空里燃烧般通红，岸上的田地里传来耕牛回家的哞哞叫声，炊烟正在袅袅升起。</div>]]></content>
      
      
      <categories>
          
          <category> 阅读 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>『无间道』有感</title>
      <link href="/essay/ebd5c2/"/>
      <url>/essay/ebd5c2/</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1620262818767-a8f3dd82-2eb8-49c4-a240-42f1618ae335.png#align=left&display=inline&height=540&id=p3dbG&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1080&originWidth=1920&size=2070221&status=done&style=none&width=960" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1620262714711-9a4e8bf0-56f2-4db0-9c48-9f05243e19e7.png#align=left&display=inline&height=540&id=zT0rR&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1080&originWidth=1920&size=1926079&status=done&style=none&width=960" alt="image.png"></p><p>上个礼拜看的，我觉得这无间道三部曲算是港片的鼻祖地位的，因为传神……</p><p>对刘建明和阿仁，我只想说，<strong>有的人死去，人已经解脱了，有的人，看似风生水起，实则，已堕入无间地狱</strong>。</p><p>还有一句“我只想做个好人”，初听之下就像是步入正途之下的光明大道，实则细想实在是<strong>鬼魅</strong>。</p><p>这里面还有很多关于佛教的一些摘录，感觉很值得揣摩，在此摘录一番</p><div style="background: #FFFBE6;padding:10px;border: 1px solid #C3C3C3;border-radius:5px;margin-bottom:5px;">《涅槃经》第十九卷「八大地狱之最，称为无间地狱，为无间断遭受大苦大意，故有此名。」</div><div style="background: #FFFBE6;padding:10px;border: 1px solid #C3C3C3;border-radius:5px;margin-bottom:5px;">「无间有三，时无间，空无间，受业无间。犯忤逆罪这永堕此界，尽受终极之无间。」</div><div style="background: #FFFBE6;padding:10px;border: 1px solid #C3C3C3;border-radius:5px;margin-bottom:5px;">地藏菩萨本愿经卷上：「如是本辈，当堕无间地狱，千万亿劫，以此连绵，求出无期。」</div><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1620262755423-85be1e40-abd1-4879-abc5-94e82b6a913a.png#align=left&display=inline&height=540&id=jfQ8C&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1080&originWidth=1920&size=2866623&status=done&style=none&width=960" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> 影视 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>『DARLING in the FRANXX』</title>
      <link href="/essay/lwgmc6/"/>
      <url>/essay/lwgmc6/</url>
      
        <content type="html"><![CDATA[<div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">Darling in the FranXX （比翼之吻）</div><p>这部番我觉得从世界观的角度来说构思很新奇，贯穿全篇则为——人性。</p><p>世界观颠覆了以往的人类美的一面，将人类的人格寄存于“爸爸”的手掌之下，欲望促使人类的人形暴露，但同时人性的一些闪光点，也在悄然萌发。</p><p>zero two 和广的爱情，就像是我之前写的『缺爱』一篇，zero two 的缺爱的极端时刻，被广的光辉所拯救了，成年之际，广的失意落魄被 zero two 口中的 darling 所拯救；</p><p>还有心的圣母形象，忘了对满的感情和生育的知识，这是我觉得这部番里面特别重要的一个点睛之笔。</p><p>我们很难去理性的分析这些人物角色，但是贯穿这些的我想就是人性最为光辉的各个闪光点吧……</p><p>转载一篇文章，片中几个机体的命名——对应的都是植物</p><blockquote><p><a href="https://movie.douban.com/review/9225938/">片中几个机体的命名——对应的都是植物</a></p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1619577542480-78f1ab01-405e-411c-ae14-537958ecf49e.jpeg#align=left&display=inline&height=540&id=u4f75054a&margin=%5Bobject%20Object%5D&originHeight=1080&originWidth=1920&status=done&style=none&width=960"></p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1619485267464-dd9642d5-df67-4a97-8419-8e5fc3a709a9.png#align=left&display=inline&height=1200&id=QP1th&margin=%5Bobject%20Object%5D&name=85308871_p0.png&originHeight=1200&originWidth=1600&size=309762&status=done&style=none&width=1600" alt="85308871_p0.png"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1619485230506-60d08215-4e79-42cb-9ba0-d3b5681edec4.png#align=left&display=inline&height=1261&id=U6MD4&margin=%5Bobject%20Object%5D&name=87980648_p0.png&originHeight=1261&originWidth=2000&size=2542419&status=done&style=none&width=2000" alt="87980648_p0.png"><br><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1619485170602-d19ab096-b1e2-4001-a419-4e1cc1c5a8ba.jpeg#align=left&display=inline&height=1040&id=LdgD5&margin=%5Bobject%20Object%5D&name=87883532_p0.jpg&originHeight=1040&originWidth=700&size=166056&status=done&style=none&width=700" alt="87883532_p0.jpg"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1619485191278-d20ca434-1141-41f5-a73e-db7b54f34d4e.png#align=left&display=inline&height=5000&id=Y2Du1&margin=%5Bobject%20Object%5D&name=87324495_p0.png&originHeight=5000&originWidth=3000&size=5878321&status=done&style=none&width=3000" alt="87324495_p0.png"></p>]]></content>
      
      
      <categories>
          
          <category> 影视 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>《平凡的世界》有感</title>
      <link href="/essay/hhd57l/"/>
      <url>/essay/hhd57l/</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1622032253532-9007acd3-e5c9-4e15-9839-7412bf52d680.jpeg#height=350&id=gdmS8&originHeight=350&originWidth=350&originalType=binary%E2%88%B6=1&size=0&status=done&style=stroke&width=350"><br>平凡的世界（路遥著长篇小说）</p><hr><p>21.06.12</p><p>经历了一件事，心碎。<br>今天的我懂得到什么叫成长，就像最后的少平那样，笔直地走向那条铁路，坚毅，成长……</p><p>“少平，你要记得，你与其他人不一样，你是一个有另外世界的人，你的心不应该只在这，而是在远方，那个充满光的地方”</p><p>这话湿了眼眶……</p><hr><p>21.02.21 号整理家里书架时候写的</p><p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1619483066100-b7e6b34c-9232-4dda-859f-02f28ceec07c.jpeg#height=4095&id=fX4yb&originHeight=4095&originWidth=1125&originalType=binary%E2%88%B6=1&status=done&style=none&width=1125"></p>]]></content>
      
      
      <categories>
          
          <category> 阅读 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>我变了吗？</title>
      <link href="/essay/ogyb5h/"/>
      <url>/essay/ogyb5h/</url>
      
        <content type="html"><![CDATA[<p>这是加密文章！</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>应用层及网络应用万维网的HTTP协议</title>
      <link href="/blog/re05fo/"/>
      <url>/blog/re05fo/</url>
      
        <content type="html"><![CDATA[<h2 id="为什么需要应用层呢？"><a href="#为什么需要应用层呢？" class="headerlink" title="为什么需要应用层呢？"></a>为什么需要应用层呢？</h2><div style="background: #FFFBE6;padding:10px;border: 1px solid #C3C3C3;border-radius:5px;margin-bottom:5px;">为什么需要应用层呢？</div><p>应用层的上一层，也就是传输层其实就已经搭建好了传输信息的框架，但是为什么还需要应用层这一层，因为<strong>传输层传的太简单，只实现我给你传过去，不全面有不足之处，用课上老师的话说，各层的宗旨就是尽力而为，举一些传输层心有余而力不足的地方：</strong></p><ul><li>客户端发送的是什么数据类型的文件</li><li>数据的长度，传输一次的数据长度为多长，一次是否传得完？什么时候传完？（TCP 的流量控制）</li><li>数据的压缩方式，服务端如何知道客户端对数据是否压缩抑或是压缩算法是什么？</li></ul><p>而对于上述三个问题，在应用层给出相应的解决方案：</p><ul><li>数据的类型，HTTP Header： Content-Type</li><li>数据的长度，HTTP Header： Content-Length</li><li>数据的压缩方式，HTTP Header： Accept-Encoding</li></ul><h2 id="搞清互联网和万维网主次"><a href="#搞清互联网和万维网主次" class="headerlink" title="搞清互联网和万维网主次"></a>搞清互联网和万维网主次</h2><p>之前上课的时候，这里一直被忽视了，有一个主次概念需要搞清楚，<strong>万维网（WWW）是一个网络应用，万维网应用是一种基于客户/服务器体系结构的网络应用</strong>『应用层的协议都是基于客户服务器方式的，即便是 P2P 对等通信方式，实质上也是一种特殊的客户服务器方式』<strong>，它是一个网络应用</strong>，相应地，在互联网里面，还有文件传输（FTP)、电子邮件 E-mail、远程登录（Telnet）等这些应用。所以引用对互联网还可以说成：<strong>是线路、协议以及通过 TCP/IP 协议实现数据电子传输的硬件和软件的集合体</strong>。</p><p>万维网这个应用还包括一些部件：万维网浏览器，万维网服务器，玩万维网文档的格式标准，以及一个应用层协议等等，这样就将 HTTP 的来源就串起来了。</p><p>理解了主次，再从“主”依次理解“次”</p><ul><li>先理解许多应用协议都要使用的<strong>域名系统（DNS）</strong>，这是基础中的基础</li><li>文件传送协议：具体应用就是云主机的使用吧</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1618625750527-7aa85753-4d61-4400-8e86-f8f2c6ae0c41.png#align=left&display=inline&height=104&margin=%5Bobject%20Object%5D&name=image.png&originHeight=207&originWidth=219&size=11364&status=done&style=none&width=109.5" alt="image.png"></p><ul><li>远程登录协议：书上只讲了 TELNET，具体应用 XSHELL 的 SSH 也是</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1618625847438-b61068f8-a3d5-43b0-8cd3-eefb3aeac42d.png#align=left&display=inline&height=100&margin=%5Bobject%20Object%5D&name=image.png&originHeight=199&originWidth=200&size=9164&status=done&style=none&width=100" alt="image.png"></p><ul><li><strong>万维网及其主要协议</strong></li><li>电子邮件</li></ul><h2 id="万维网是什么？有什么用？"><a href="#万维网是什么？有什么用？" class="headerlink" title="万维网是什么？有什么用？"></a>万维网是什么？有什么用？</h2><blockquote><p>用课本的概念：万维网用链接的方式能非常方便地从互联网上的一个站点访问另一个站点（也就是所谓的“链接到另一个站点”），从而主动地按需获取丰富的信息。</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1618626263044-e610396b-b7b5-4f11-a8f5-1499f0f7f5d8.png#align=left&display=inline&height=226&margin=%5Bobject%20Object%5D&name=image.png&originHeight=451&originWidth=955&size=63032&status=done&style=stroke&width=477.5" alt="image.png"><br>要达到这样的构想，架构这样的系统需要解决哪些问题呢？<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1618626404243-cf649c67-a499-46a3-a163-aad61a17c9b7.png#align=left&display=inline&height=104&margin=%5Bobject%20Object%5D&name=image.png&originHeight=208&originWidth=1132&size=50697&status=done&style=stroke&width=566" alt="image.png"></p><ol><li>利用 URL</li><li>HTTP 协议（基于 TCP）</li><li>HTML：就是超文本标记语言，这里不再赘述</li><li>搜索工具：搜索引擎工具，谷歌、百度……</li></ol><h2 id="HTTP-协议"><a href="#HTTP-协议" class="headerlink" title="HTTP 协议"></a>HTTP 协议</h2><h3 id="HTTP-的报文结构"><a href="#HTTP-的报文结构" class="headerlink" title="HTTP 的报文结构"></a>HTTP 的报文结构</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1618626839900-2a58c82a-1c27-427e-a902-6b21e3458b12.png#align=left&display=inline&height=397&margin=%5Bobject%20Object%5D&name=image.png&originHeight=793&originWidth=858&size=171966&status=done&style=stroke&width=429" alt="image.png"></p><h3 id="请求报文实例"><a href="#请求报文实例" class="headerlink" title="请求报文实例"></a>请求报文实例</h3><p>请求行中的方法，就是对所请求对象进行的操作，具体有以下一些方法：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1618627091156-cd978f06-4e39-41ea-9652-0ceddab98bb7.png#align=left&display=inline&height=175&margin=%5Bobject%20Object%5D&name=image.png&originHeight=349&originWidth=682&size=46050&status=done&style=stroke&width=341" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1618627123440-4ed5d351-96a7-4228-a9fe-aaff7e5bb9e2.png#align=left&display=inline&height=186&margin=%5Bobject%20Object%5D&name=image.png&originHeight=371&originWidth=949&size=77130&status=done&style=stroke&width=474.5" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1618627710005-1577f282-ff85-4fd2-a6ae-51187928044e.png#align=left&display=inline&height=298&margin=%5Bobject%20Object%5D&name=image.png&originHeight=596&originWidth=885&size=140277&status=done&style=stroke&width=442.5" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1618627722921-07c819d7-b873-4644-8cb0-844ff27450d0.png#align=left&display=inline&height=68&margin=%5Bobject%20Object%5D&name=image.png&originHeight=136&originWidth=828&size=19552&status=done&style=stroke&width=414" alt="image.png"><br>具体在浏览器的显示为：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1618627622010-49ba1876-a555-41a6-85b6-f23bc458ac82.png#align=left&display=inline&height=331&margin=%5Bobject%20Object%5D&name=image.png&originHeight=662&originWidth=1248&size=73626&status=done&style=stroke&width=624" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1618627640727-1204203a-4f3e-4fff-a388-fa47224fd7a0.png#align=left&display=inline&height=163&margin=%5Bobject%20Object%5D&name=image.png&originHeight=325&originWidth=1237&size=35473&status=done&style=stroke&width=618.5" alt="image.png"></p><h3 id="本地存储和-Cookie"><a href="#本地存储和-Cookie" class="headerlink" title="本地存储和 Cookie"></a>本地存储和 Cookie</h3><p>自己搭建个人网站的时候，有这么一个功能，<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1618627885598-f7d86695-ab4b-47b1-84de-1f7131daf095.png#align=left&display=inline&height=72&margin=%5Bobject%20Object%5D&name=image.png&originHeight=143&originWidth=1920&size=24745&status=done&style=none&width=960" alt="image.png"><br>对用户在本地浏览器里面点击这个伸缩布局按钮，下一次再打开网站，浏览器会记住这个布局，我是使用的 localSession 这个对象方法，因为是静态网站，这样实现还是比较友好的<img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1618628002219-e1725906-d456-4930-bba7-cc800938c02f.png#align=left&display=inline&height=268&margin=%5Bobject%20Object%5D&name=image.png&originHeight=536&originWidth=1920&size=183363&status=done&style=none&width=960" alt="image.png"><br>这是静态站点使用的友好方式，比较灵活的还有 Cookie 方式，特别是在动态网站的搭建过程中。<br>在 Node.js 框架 Express 里面利用“express-session”插件来使用 Cookie。</p><ul><li>Cookie 会记录客户端和服务端之间的信息</li><li>每次请求都会默认携带 Cookie</li><li>会被加密，安全</li></ul><p>关于安全问题，课本上的表述是这样的：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1618628510004-3df5120d-f238-4a6c-9dc8-e9c803283163.png#align=left&display=inline&height=245&margin=%5Bobject%20Object%5D&name=image.png&originHeight=490&originWidth=931&size=87665&status=done&style=stroke&width=465.5" alt="image.png"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>《计算机网络》第 7 版——谢希仁</li><li><a href="https://www.html.cn/qa/other/21226.html">万维网和互联网的区别是什么？</a></li><li><a href="https://www.zhihu.com/question/368324676/answer/988997873">为什么需要，以及如何设计应用层协议？</a></li><li><a href="https://blog.csdn.net/u010076558/article/details/17620719">几种远程控制协议</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>实验4——超市排队机🔖队列</title>
      <link href="/blog/zgiaxv/"/>
      <url>/blog/zgiaxv/</url>
      
        <content type="html"><![CDATA[<h2 id="实验任务"><a href="#实验任务" class="headerlink" title="实验任务"></a>实验任务</h2><p>实验 4：队列的链式表示和实现<br>    要求：某小超市有两个排队机，构建 2 个用带头结点的单链表队列 QA 和 QB, 实现下列操作<br>       1、初始化队列(清空)；<br>       2、入队；<br>       3、出队;<br>       4、求队列长度；<br>       5、判断队列是否为空；<br>       6、判断队列是否为满；<br>       7、对于队列 QA 和 QB，如果其中一个队列的售货员下班，则自动甩到另一个队列后面。<br>截止日期：4 月 22 日</p><h2 id="实验讨论"><a href="#实验讨论" class="headerlink" title="实验讨论"></a>实验讨论</h2><div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">觉得问题里面有bug</div><p>对问题判满的疑惑与解决，第六个问题对链对判满是否有意义，如果是链式存储，数据结构本身判断满没有意义，但是考虑到是小型超市，超市空间不大，所以对其进行一开始的用户自己输入两个队列的最大长度。</p><p>但是这样又有一个问题，在问题 7 中，如果一个队列的售货员下班了，这个队列的所有人排到另一个队列中，那如果新队列的长度超出用户输入的队列最大长度呢？考虑到实际问题，这个问题不打算解决了，让他们挤挤……</p><h2 id="代码代码"><a href="#代码代码" class="headerlink" title="代码代码"></a>代码代码</h2><pre><code class="cpp">#include&lt;bits/stdc++.h&gt;using namespace std;typedef int Status;typedef int QElemType;#define OVERFLOW -1#define ERROR 0#define OK 1/**    实验4：队列的链式表示和实现    要求：某小超市有两个排队机，构建2个用带头结点的单链表队列QA和QB, 实现下列操作        1、初始化队列(清空)；        2、入队；        3、出队;        4、求队列长度；        5、判断队列是否为空；        6、判断队列是否为满；        7、对于队列QA和QB，如果其中一个队列的售货员下班，则自动甩到另一个队列后面。 *//* 存储形式 */typedef struct QNode&#123; //链队用的结点    QElemType data;    struct QNode *next;&#125;QNode,*QueuePtr;typedef struct &#123;    QueuePtr front;    QueuePtr rear;&#125;LinkQueue;/* 初始化 */Status InitQueue(LinkQueue &amp;queue) &#123;    queue.front = queue.rear = new QNode;    queue.front-&gt;next = NULL;    return OK;&#125;/* 求队列长度 */Status QueueLength(LinkQueue &amp;queue) &#123;    int count = 0;    if (queue.rear == queue.front) &#123;        return count;    &#125;    QueuePtr temp = queue.front;    while (temp != queue.rear) &#123;        count++;        temp = temp-&gt;next;    &#125;    return count;&#125;/* 入队 */Status EnQueue(LinkQueue &amp;queue, QElemType e, int length) &#123;    if (QueueLength(queue) &lt;length) &#123;        QueuePtr temp = new QNode;        temp-&gt;data = e;        temp-&gt;next = NULL;        queue.rear-&gt;next = temp;        queue.rear = temp;        return OK;    &#125; else &#123;        cout &lt;&lt; &quot;队已经满了，不能再入元素了&quot;&lt;&lt; &quot;\n&quot;;        return ERROR;    &#125;&#125;/* 出队 */Status DeQueue(LinkQueue &amp;queue) &#123;    if (queue.front == queue.rear) &#123;        return OVERFLOW;    &#125;    // 有必要定义一个p，不然头结点会掉    QueuePtr p = queue.front-&gt;next;    QElemType e = p-&gt;data;    queue.front-&gt;next = p-&gt;next;    // 考虑最后一个元素被删，队尾指针指向头结点    if (queue.rear == p) &#123;        queue.rear = queue.front;    &#125;    return e;&#125;/* 取队头元素 */// Status GetHead(LinkQueue &amp;queue) &#123;//     if (queue.front != queue.rear)&#123;//         return queue.front-&gt;next-&gt;data;//     &#125;// &#125;/* 判断队列是否为空 */bool QueueIsEmpty(LinkQueue &amp;queue) &#123;    if (queue.rear == queue.front) &#123;        return true;    &#125; else &#123;        return false;    &#125;&#125;/** * 判断队列是否为满 * 不是很理解为什么链队需要判断是否为满呢？ * 采用输入链队长度，利用链队函数来判断 * 那么入队的代码需要输入length参数来判断是否还能让元素入队 */bool QueueIsFull(LinkQueue &amp;queue, int length) &#123;    if (QueueLength(queue) == length) &#123;        return true;    &#125; else &#123;        return false;    &#125;&#125;/* 一个队列甩到另一个队列 */Status QueueMove(LinkQueue &amp;queue_delete,LinkQueue &amp;queue_add) &#123;    queue_add.rear-&gt;next = queue_delete.front-&gt;next;    queue_add.rear = queue_delete.rear;    return OK;&#125;/* 遍历查看队列元素 */Status DisplayQueue(LinkQueue &amp;queue) &#123;    LinkQueue L = queue;    while (L.front-&gt;next != NULL) &#123;        cout &lt;&lt; L.front-&gt;next-&gt;data &lt;&lt; &quot; &quot;;        L.front = L.front-&gt;next;    &#125;    cout &lt;&lt; &quot;\n&quot;;    return OK;&#125;int main() &#123;    cout&lt;&lt;&quot;------------------------链队菜单----------------------&quot;&lt;&lt;&#39;\n&#39;;    cout&lt;&lt;&quot;操作0：退出程序&quot;&lt;&lt;&#39;\n&#39;;    cout&lt;&lt;&quot;操作1：初始化两队列&quot;&lt;&lt;&#39;\n&#39;;    cout&lt;&lt;&quot;操作2：入队操作&quot;&lt;&lt;&#39;\n&#39;;    cout&lt;&lt;&quot;操作3：出队操作&quot;&lt;&lt;&#39;\n&#39;;    cout&lt;&lt;&quot;操作4：判断判断链队是否为空&quot;&lt;&lt;&#39;\n&#39;;    cout&lt;&lt;&quot;操作5：判断判断链队是否为满&quot;&lt;&lt;&#39;\n&#39;;    cout&lt;&lt;&quot;操作6：售货员偷懒选项&quot;&lt;&lt;&#39;\n&#39;;    cout&lt;&lt;&quot;操作7：查看队列&quot;&lt;&lt;&#39;\n&#39;;    cout&lt;&lt;&quot;操作8：求队列长度&quot;&lt;&lt;&#39;\n&#39;;    cout&lt;&lt;&quot;--------------------------------------------------------&quot;&lt;&lt;&#39;\n&#39;;    int a, length,flag = 1;    cout &lt;&lt; &quot;请输入你希望排队机最多能排的人数：&quot;&lt;&lt;&quot;\n&quot;&lt;&lt;&quot;\n&quot;;    cin &gt;&gt; length;    LinkQueue QA,QB;    while(flag)    &#123;        cout&lt;&lt;&#39;\n&#39;&lt;&lt;&quot;请选择要执行的操作：&quot;;        while(cin&gt;&gt;a)        &#123;            if(a &lt; 0 || a &gt; 8)                cout&lt;&lt;&quot;请选择正确操作编号：&quot;;            else                break;        &#125;        switch(a)        &#123;            case 0:            &#123;                cout&lt;&lt;&quot;正在退出程序中……&quot;&lt;&lt;&#39;\n&#39;;                flag = 0;                break;            &#125;            case 1:            &#123;                cout&lt;&lt;&quot;初始化QA、QB队列中……&quot;&lt;&lt;&#39;\n&#39;;                InitQueue(QA);                InitQueue(QB);                break;            &#125;            case 2:            &#123;                cout&lt;&lt;&quot;请输入入队的队列（QA输入1，QB输入2）&quot;&lt;&lt;&#39;\n&#39;;                int select_queue;                cin &gt;&gt; select_queue;                if (select_queue == 1) &#123;                    cout&lt;&lt;&quot;请输入入QA队的队列的元素&quot;&lt;&lt;&#39;\n&#39;;                    int select_queue_A;                    cin &gt;&gt; select_queue_A;                    EnQueue(QA, select_queue_A, length);                &#125; else if (select_queue == 2) &#123;                    cout&lt;&lt;&quot;请输入入QB队的队列的元素&quot;&lt;&lt;&#39;\n&#39;;                    int select_queue_B;                    cin &gt;&gt; select_queue_B;                    EnQueue(QB, select_queue_B, length);                &#125; else &#123;                    cout &lt;&lt; &quot;输入有误！&quot;&lt;&lt; &quot;\n&quot;;                &#125;                break;            &#125;            case 3:            &#123;                cout&lt;&lt;&quot;请输入需要出队的队列（QA输入1，QB输入2）&quot;&lt;&lt;&#39;\n&#39;;                int select_queue;                cin &gt;&gt; select_queue;                if (select_queue == 1) &#123;                    DeQueue(QA);                &#125; else if (select_queue == 2) &#123;                    DeQueue(QB);                &#125; else &#123;                    cout &lt;&lt; &quot;输入有误！&quot;&lt;&lt; &quot;\n&quot;;                &#125;                break;            &#125;            case 4:            &#123;                cout&lt;&lt;&quot;请输入需要判空的队列（QA输入1，QB输入2）&quot;&lt;&lt;&#39;\n&#39;;                int select_queue;                cin &gt;&gt; select_queue;                if (select_queue == 1) &#123;                    cout &lt;&lt; &quot;QA队列为空吗？&quot;&lt;&lt; boolalpha &lt;&lt; QueueIsEmpty(QA) &lt;&lt; &quot;\n&quot;;                &#125; else if (select_queue == 2) &#123;                    cout &lt;&lt; &quot;QB队列为空吗？&quot;&lt;&lt; boolalpha &lt;&lt; QueueIsEmpty(QB) &lt;&lt; &quot;\n&quot;;                &#125; else &#123;                    cout &lt;&lt; &quot;输入有误！&quot;&lt;&lt; &quot;\n&quot;;                &#125;                break;            &#125;            case 5:            &#123;                cout&lt;&lt;&quot;请输入需要判满的队列（QA输入1，QB输入2）&quot;&lt;&lt;&#39;\n&#39;;                int select_queue;                cin &gt;&gt; select_queue;                if (select_queue == 1) &#123;                    cout &lt;&lt; &quot;QA队列为满吗？&quot;&lt;&lt; boolalpha &lt;&lt; QueueIsFull(QA,length) &lt;&lt; &quot;\n&quot;;                &#125; else if (select_queue == 2) &#123;                    cout &lt;&lt; &quot;QB队列为满吗？&quot;&lt;&lt; boolalpha &lt;&lt; QueueIsFull(QB,length) &lt;&lt; &quot;\n&quot;;                &#125; else &#123;                    cout &lt;&lt; &quot;输入有误！&quot;&lt;&lt; &quot;\n&quot;;                &#125;                break;            &#125;            case 6:            &#123;                cout&lt;&lt;&quot;请输入下班的售货员（QA输入1，QB输入2）&quot;&lt;&lt;&#39;\n&#39;;                int select_queue;                cin &gt;&gt; select_queue;                if (select_queue == 1) &#123;                    QueueMove(QA, QB);                &#125; else if (select_queue == 2) &#123;                    QueueMove(QB, QA);                &#125; else &#123;                    cout &lt;&lt; &quot;输入有误！&quot;&lt;&lt; &quot;\n&quot;;                &#125;                break;            &#125;            case 7:            &#123;                cout&lt;&lt;&quot;请输入要查看的队列（QA输入1，QB输入2）&quot;&lt;&lt;&#39;\n&#39;;                int select_queue;                cin &gt;&gt; select_queue;                if (select_queue == 1) &#123;                    DisplayQueue(QA);                &#125; else if (select_queue == 2) &#123;                    DisplayQueue(QB);                &#125; else &#123;                    cout &lt;&lt; &quot;输入有误！&quot;&lt;&lt; &quot;\n&quot;;                &#125;                break;            &#125;            case 8:            &#123;                cout&lt;&lt;&quot;请输入要查看的队列的长度（QA输入1，QB输入2）&quot;&lt;&lt;&#39;\n&#39;;                int select_queue;                cin &gt;&gt; select_queue;                if (select_queue == 1) &#123;                    cout&lt;&lt;QueueLength(QA)&lt;&lt; &quot;\n&quot;;                &#125; else if (select_queue == 2) &#123;                    cout&lt;&lt;QueueLength(QB)&lt;&lt; &quot;\n&quot;;                &#125; else &#123;                    cout &lt;&lt; &quot;输入有误！&quot;&lt;&lt; &quot;\n&quot;;                &#125;                break;            &#125;        &#125;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> Problems </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++队列顺序和链式实现及操作</title>
      <link href="/blog/fbfgft/"/>
      <url>/blog/fbfgft/</url>
      
        <content type="html"><![CDATA[<h2 id="顺序循环队列"><a href="#顺序循环队列" class="headerlink" title="顺序循环队列"></a>顺序循环队列</h2><pre><code class="cpp">#include&lt;bits/stdc++.h&gt;using namespace std;typedef int Status;typedef int QElemType;#define OVERFLOW -1#define ERROR 0#define OK 1#define MAXSIZE 100/** * 循环队列——队列的顺序表示和实现 * * 操作：初始化、队列长度、入队、出队、取队头元素 *//* 存储形式 */typedef struct &#123;    QElemType *base;    int front;    int rear;&#125; SqQueue;/* 初始化 */Status InitQueue(SqQueue &amp;queue) &#123;    // 初始化这个base地址为一个有最大容量的数组初地址    queue.base = new int[MAXSIZE];    if (!queue.base) &#123;        return OVERFLOW;    &#125;    queue.front = queue.rear = 0;    return OK;&#125;/* 求队列长度 */Status QueueLength(SqQueue &amp;queue) &#123;    return (queue.rear - queue.front + MAXSIZE) % MAXSIZE;&#125;/* 入队 */Status EnQueue(SqQueue &amp;queue, QElemType e) &#123;    if ((queue.rear+1)%MAXSIZE == queue.front) &#123;        return OVERFLOW;    &#125;    queue.base[queue.rear] = e;    queue.rear = (queue.rear + 1) % MAXSIZE;    return OK;&#125;/* 出队 */Status DeQueue(SqQueue &amp;queue) &#123;    if ((queue.rear+1)%MAXSIZE == queue.front) &#123;        return OVERFLOW;    &#125;    QElemType e = queue.base[queue.front];    queue.front = (queue.front + 1) % MAXSIZE; //队头指针+1    return e;&#125;/* 取队头元素 */Status GetHead(SqQueue &amp;queue) &#123;    if (queue.front != queue.rear) &#123;        return queue.base[queue.front];    &#125;&#125;int main() &#123;    SqQueue test;    InitQueue(test);    EnQueue(test, 10);    EnQueue(test, 15);    EnQueue(test, 20);    cout &lt;&lt; &quot;队列长度为：&quot; &lt;&lt; QueueLength(test) &lt;&lt; &quot;\n&quot;;    cout &lt;&lt; GetHead(test)&lt;&lt;&quot; &quot;&lt;&lt; GetHead(test)&lt;&lt;&quot; &quot;&lt;&lt; GetHead(test)&lt;&lt;&quot; &quot;&lt;&lt;&quot;\n&quot;;    cout &lt;&lt; DeQueue(test)&lt;&lt;&quot; &quot;&lt;&lt; DeQueue(test)&lt;&lt;&quot; &quot;&lt;&lt; DeQueue(test)&lt;&lt;&quot; &quot;&lt;&lt;&quot;\n&quot;;&#125;</code></pre><h2 id="链队"><a href="#链队" class="headerlink" title="链队"></a>链队</h2><pre><code class="cpp">#include&lt;bits/stdc++.h&gt;using namespace std;typedef int Status;typedef int QElemType;#define OVERFLOW -1#define ERROR 0#define OK 1#define MAXSIZE 100/** * 链队——队列的链式表示和实现 * * 操作：初始化、入队、出队、取队头元素 *//* 存储形式 */typedef struct QNode&#123; //链队用的结点    QElemType data;    struct QNode *next;&#125;QNode,*QueuePtr;typedef struct &#123;    QueuePtr front;    QueuePtr rear;&#125;LinkQueue;/* 初始化 */Status InitQueue(LinkQueue &amp;queue) &#123;    queue.front = queue.rear = new QNode;    queue.front-&gt;next = NULL;    return OK;&#125;/* 入队 */Status EnQueue(LinkQueue &amp;queue, QElemType e) &#123;    QueuePtr temp = new QNode;    temp-&gt;data = e;    temp-&gt;next = NULL;    queue.rear-&gt;next = temp;    queue.rear = temp;    return OK;&#125;/* 出队 */Status DeQueue(LinkQueue &amp;queue) &#123;    if (queue.front == queue.rear) &#123;        return OVERFLOW;    &#125;    QElemType e = queue.front-&gt;next-&gt;data;    queue.front-&gt;next = queue.front-&gt;next-&gt;next;    // 考虑最后一个元素被删，队尾指针指向头结点    if (queue.rear == queue.front) &#123;        queue.front = queue.rear;    &#125;    return e;&#125;/* 取队头元素 */Status GetHead(LinkQueue &amp;queue) &#123;    if (queue.front != queue.rear)&#123;        return queue.front-&gt;next-&gt;data;    &#125;&#125;int main() &#123;    LinkQueue test;    InitQueue(test);    EnQueue(test, 10);    EnQueue(test, 15);    EnQueue(test, 20);    // cout &lt;&lt; &quot;队列长度为：&quot; &lt;&lt; QueueLength(test) &lt;&lt; &quot;\n&quot;;    cout &lt;&lt; GetHead(test)&lt;&lt;&quot; &quot;&lt;&lt; GetHead(test)&lt;&lt;&quot; &quot;&lt;&lt; GetHead(test)&lt;&lt;&quot; &quot;&lt;&lt;&quot;\n&quot;;    cout &lt;&lt; DeQueue(test)&lt;&lt;&quot; &quot;&lt;&lt; DeQueue(test)&lt;&lt;&quot; &quot;&lt;&lt; DeQueue(test)&lt;&lt;&quot; &quot;&lt;&lt;&quot;\n&quot;;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 📶线结构：字符串-数组-栈-队列 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++栈顺序和链式实现及操作</title>
      <link href="/blog/tlzqah/"/>
      <url>/blog/tlzqah/</url>
      
        <content type="html"><![CDATA[<div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">存储形式以及操作和顺序表和链表差不多，需要的操作也少，学栈和队列，感觉只是抽离出来这两种便于在应用层面使用</div><h2 id="顺序栈"><a href="#顺序栈" class="headerlink" title="顺序栈"></a>顺序栈</h2><pre><code class="cpp">#include&lt;bits/stdc++.h&gt;typedef int Status;typedef int SElemType;#define OVERFLOW -1#define ERROR 0#define OK 1#define MAXSIZE 100using namespace std;/** * 顺序栈 * * 顺序栈的基本操作：初始化、入栈、出栈、取栈顶元素 *//* 顺序栈的存储形式 */typedef struct &#123;    SElemType *base;    SElemType *top;    int stacksize;&#125; SqStack;/* 初始化 */Status InitSqStack(SqStack &amp;stack) &#123;    // 为栈分配容量    stack.base = new int[MAXSIZE];    // 分配失败返回失败值    if (!stack.base) &#123;        return OVERFLOW;    &#125;    // 让栈顶地址初始为栈底地址    stack.top = stack.base;    // 初始化容量    stack.stacksize = MAXSIZE;    return OK;&#125;/* 入栈 */Status Push(SqStack &amp;stack, SElemType e) &#123;    if (stack.top - stack.base == stack.stacksize) &#123;        return OVERFLOW;    &#125;    *stack.top = e; // 先在top位置赋值    stack.top++; // 将top地址++    return OK;&#125;/* 出栈 */Status Pop(SqStack &amp;stack) &#123;    // 空栈返回异常    if (stack.top == stack.base) &#123;        return OVERFLOW;    &#125;    stack.top--; // 栈顶地址减1    return *stack.top; // 返回此时“栈顶”元素&#125;/* 取栈顶元素 */Status GetTop (SqStack &amp;stack) &#123;    // 空栈返回异常    if (stack.top == stack.base) &#123;        return OVERFLOW;    &#125;    // stack.top--; // 栈顶地址减1，这是和出栈的区别    return *(stack.top-1); // 返回此时“栈顶”元素&#125;int main() &#123;    SqStack test;    InitSqStack(test);    Push(test, 10);    Push(test, 15);    Push(test, 20);    cout &lt;&lt; GetTop(test)&lt;&lt;&quot; &quot;&lt;&lt; GetTop(test)&lt;&lt;&quot; &quot;&lt;&lt; GetTop(test)&lt;&lt;&quot; &quot;&lt;&lt;&quot;\n&quot;;    cout &lt;&lt; Pop(test)&lt;&lt;&quot; &quot;&lt;&lt; Pop(test)&lt;&lt;&quot; &quot;&lt;&lt; Pop(test)&lt;&lt;&quot; &quot;&lt;&lt;&quot;\n&quot;;&#125;</code></pre><h2 id="链栈"><a href="#链栈" class="headerlink" title="链栈"></a>链栈</h2><pre><code class="cpp">#include&lt;bits/stdc++.h&gt;typedef int Status;typedef int SElemType;#define OVERFLOW -1#define ERROR 0#define OK 1#define MAXSIZE 100using namespace std;/** * 链栈 * * 链栈的基本操作：初始化、入栈、出栈、取栈顶元素 *//* 链栈的存储形式 */typedef struct StackNode&#123;    SElemType data;    struct StackNode *next;&#125; StackNode, *LinkStack;/** * 初始化 * 不设头结点 */Status InitLinkStack(LinkStack &amp;stack) &#123;    stack = NULL; // 栈顶元素置空    return OK;&#125;/* 入栈 */Status Push(LinkStack &amp;stack, SElemType e) &#123;    // 不能用LinkStack这样声明结点变量，需要new一个内存空间    LinkStack temp = new StackNode;    temp-&gt;data = e;    temp-&gt;next = stack;    stack = temp;    return OK;&#125;/* 出栈 */Status Pop (LinkStack &amp;stack) &#123;    SElemType i = stack-&gt;data;    stack = stack-&gt;next;    return i;&#125;/* 取栈顶元素 */Status GetTop (LinkStack &amp;stack) &#123;    return stack-&gt;data;&#125;int main() &#123;    LinkStack test;    InitLinkStack(test);    Push(test, 10);    Push(test, 15);    Push(test, 20);    cout &lt;&lt; GetTop(test)&lt;&lt;&quot; &quot;&lt;&lt; GetTop(test)&lt;&lt;&quot; &quot;&lt;&lt; GetTop(test)&lt;&lt;&quot; &quot;&lt;&lt;&quot;\n&quot;;    cout &lt;&lt; Pop(test)&lt;&lt;&quot; &quot;&lt;&lt; Pop(test)&lt;&lt;&quot; &quot;&lt;&lt; Pop(test)&lt;&lt;&quot; &quot;&lt;&lt;&quot;\n&quot;;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 📶线结构：字符串-数组-栈-队列 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>缺爱</title>
      <link href="/essay/xikynq/"/>
      <url>/essay/xikynq/</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1620269016472-0205bffa-da28-4411-9950-1b94025de0f7.jpeg#crop=0&crop=0&crop=1&crop=1&height=310&id=THQSB&margin=%5Bobject%20Object%5D&originHeight=619&originWidth=1100&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&title=&width=550"></p><p>前言：观《刀剑神域》《东京食尸鬼》《进击的巨人》等一些番，对“缺爱”这个词的一些感悟……</p><hr><p>缺爱的人，内心总有一些渴望，渴望被关爱，渴望被呵护，渴望对方是自己心里想要的模样……这种渴望是一种游走在刀尖上的隐式力量，甚至，会让一个人人格变化，变成一个我们都不在认识的人……</p><p>尤吉欧缺的是从小的青梅竹马爱丽丝的爱，在面对最高祭司的亲昵……当然，尤吉欧的强大就强大在，他无条件相信挚友桐人，即便是那般情形，他也从刀尖上走向了正确的道路。金木研缺少的是母爱，的佣人，缺少的是家主的关爱</p><p>兵长利威尔，就更不用说了，人类中外挂，绝对的强者，他缺少的不仅是亲人的爱，更是这个世界的压抑与社会的动荡，地下生活，从小就仰头看不见天空，低头被人唾弃，这缺的简直是一个世界啊，他心里也是多么珍视自己的爱和他人的爱，最初的两个小伙伴，再到利威尔整个班，还有……佩特拉……</p><p>如果说这个世界真有一种至暗力量，缺爱或许也是其一呢~这个世界谁都没错，错的是这个世界，那么 我又为何一直低头呢？这就是缺爱的至暗力量……</p><p>生活中，也有很多啊，跟班，小时候的孩子，经常有跟班一说，如果你是和别人相爱的人，那么你可以给对方更多一点的爱，如果你是为人父母，你可以更加爱自己的子女，爱，从来都不嫌多，两个人之间的爱情也是一样</p><p>人与人之间，不要让对方、让彼此缺爱……</p><p>你仔细看看，缺爱的人好多，小什造，又何尝不是，</p><p>这部剧好就好在，没有没有对错，没有哪一方是绝对的正确，贯穿全剧的就是一句话——“错的不是我，而是这个世界”</p><p>写着写着，简直我就要黑化一般<img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1618565453724-89af8f91-a000-4be3-bddd-cb1708cc5065.jpeg#crop=0&crop=0&crop=1&crop=1&height=52&id=fQUdE&originHeight=52&originWidth=52&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=stroke&title=&width=52"></p><p><code>2021.05.06</code></p><p>上网搜了一下，缺爱还是有相应的词条的：<a href="https://baike.baidu.com/item/%E7%BC%BA%E7%88%B1/4544029">缺爱·百度百科</a></p><blockquote><p>缺爱：一般指缺少关爱的孩子的一种心情表现形式，着调于凄凉寂寞的非乐观主义。缺爱的孩子性格往往和普通孩子不一样，思想也成熟的早一点，但是较容易走极端。<br>——百度百科</p></blockquote><blockquote><p>表现：缺爱的孩子性格往往和普通孩子不一样，思想也成熟的早一点，但是容易走极端，比较叛逆，一般能力较强，事业心强，但在内心里缺乏安全感，不论拥有再多，始终担忧如果有一天失去了怎么办。<br>缺爱的孩子比较喜欢自己一个人不声不响的做事，性格比较孤僻，一般让人看上去会形容他“感觉这个人有很多心事”。</p></blockquote><blockquote><p>对于爱情，缺爱的孩子比较“慢热”，心里有恐惧感，害怕如果我投入了结果会怎样…… 但是一旦投入了，就会比较偏激的把自己认为好的全部给对方。不管这爱是亲情，友情，爱情，他都是全方位的去考虑去付出。因为他缺少爱，他全身心的付出内心里也是希望对方能像他一样全身心付出的对他好。如果没有得到期望中的回报或者被人所不屑，心中必然是由爱生恨，他们的爱恨往往比较极端。</p></blockquote><blockquote><p>单亲家庭的孩子、孤儿、重男轻女家庭的女儿、重小轻大家庭的大孩一般都会存在缺爱的现象，这是一个比较普遍的现象。</p></blockquote><blockquote><p>缺爱的孩子需要社会的关心，不然容易变坏，社会上这样的例子很多。<br>——百度百科</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>实验3——求LA和LB(用单链表表示)的并和交集🔖链表</title>
      <link href="/blog/tw2cvt/"/>
      <url>/blog/tw2cvt/</url>
      
        <content type="html"><![CDATA[<h2 id="实验要求"><a href="#实验要求" class="headerlink" title="实验要求"></a>实验要求</h2><p>求两个集合 LA 和 LB(用单链表表示)的并和交集<br>要求：在实验二的基础上，使用单链表表示集合。编写两个算法（求交算法和求并算法），并输出最终的结果。<br>测试用例：集合 A 为{3，4，1，6}，集合 A 为{2，3，6，7}，<br>           交集为{3，6}<br>           并集为{1，2，3，4，6，7}<br>交作业时间：4 月 16 日</p><h2 id="实验代码"><a href="#实验代码" class="headerlink" title="实验代码"></a>实验代码</h2><pre><code class="cpp">#include&lt;bits/stdc++.h&gt;using namespace std;/** * 求两个集合LA和LB(用单链表表示)的并和交集 *//* 单链表的存储结构 */typedef struct LNode &#123;    int data; //数据域    struct LNode *next; //指针域&#125;Lnode, *LinkList; //LinkList为指向结构体LNode的指针类型/* 初始化链表 */void InitList(LinkList &amp;L) &#123;    L = new LNode;    L-&gt;next = NULL;&#125;/* 创建：后插 */void CreateList_R(LinkList &amp;L, int n) &#123;    cout &lt;&lt; &quot;请输入&quot; &lt;&lt; n &lt;&lt; &quot;个数字&quot;&lt;&lt; &quot;\n&quot;;    InitList(L);    // 定义一个在下面循环用来一直操作所加元素的结点p来指向头结点L    LinkList p = L;    for (int i = 0; i &lt; n;i++) &#123;        LinkList q = new Lnode;        q-&gt;next = NULL;        cin &gt;&gt; q-&gt;data;        p-&gt;next = q;        p = q; //为了下一次    &#125;&#125;/* 打印 */void TraverseList(LinkList &amp; L)&#123;        LinkList p = new LNode;        p = L-&gt;next;        cout &lt;&lt; &quot;此链表打印的结果为：&quot;&lt;&lt; &quot;\n&quot;;        while (p != NULL)        &#123;            cout &lt;&lt; p-&gt;data &lt;&lt; &quot; &quot;;            p = p-&gt;next;        &#125;        cout &lt;&lt; &quot;\n&quot;;&#125;/* 排序单链表 */void sort(LinkList &amp;L) &#123;&#125;/* jiao算法 */void jiao(LinkList &amp;A,LinkList &amp;B) &#123;    // 用双循环得出共有的元素并输出    LinkList p;    InitList(p);    A = A-&gt;next;    B = B-&gt;next;    while (A != NULL ) &#123;        LinkList copy_b = B;        while(copy_b != NULL) &#123;            if (A-&gt;data == copy_b-&gt;data) &#123;                LinkList temp = new Lnode;                temp-&gt;data = copy_b-&gt;data;                temp-&gt;next = p-&gt;next;                p-&gt;next = temp;                break;            &#125; else &#123;                copy_b = copy_b-&gt;next;            &#125;        &#125;        A = A-&gt;next;    &#125;    while(p-&gt;next != NULL) &#123;        cout &lt;&lt; p-&gt;next-&gt;data &lt;&lt; &quot; &quot;;        p = p-&gt;next;    &#125;&#125;/* bing算法 */void bing(LinkList &amp;A,LinkList &amp;B) &#123;    LinkList p = A;    LinkList s = B;    A = A-&gt;next;    B = B-&gt;next;    while (A != NULL ) &#123;        LinkList copy_b = B;        while(copy_b != NULL) &#123;            if (A-&gt;data == copy_b-&gt;data) &#123;                // cout &lt;&lt; A-&gt;data &lt;&lt; &quot;\n&quot;;                // 在p链里面删除A-&gt;data值                LinkList q = p;                while(q-&gt;next != NULL) &#123;                    if (q-&gt;next-&gt;data == A-&gt;data) &#123;                        q-&gt;next = q-&gt;next-&gt;next;                        break;                    &#125; else &#123;                        q = q-&gt;next;                    &#125;                &#125;                break;            &#125; else &#123;                copy_b = copy_b-&gt;next;            &#125;        &#125;        A = A-&gt;next;    &#125;    // 将p链表连接到s链表上    LinkList result = p;    while (p != NULL) &#123;        if (p-&gt;next == NULL) &#123;            p-&gt;next = s-&gt;next;            break;        &#125;        p = p-&gt;next;    &#125;    while(result-&gt;next != NULL) &#123;        cout &lt;&lt; result-&gt;next-&gt;data &lt;&lt; &quot; &quot;;        result = result-&gt;next;    &#125;&#125;int main() &#123;    LinkList list_A;    LinkList list_B;    InitList(list_A);    InitList(list_B);    CreateList_R(list_A, 6);    CreateList_R(list_B, 6);    LinkList list_C = list_A;    LinkList list_D = list_B;    cout &lt;&lt;&quot;A、B交集的值为：&quot;;    jiao(list_A, list_B);    cout &lt;&lt;&quot;\n&quot;&lt;&lt;&quot;A、B并集的值为：&quot;;    bing(list_C, list_D);&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> Problems </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>“错的不是我，是这个世界”</title>
      <link href="/essay/lu9dks/"/>
      <url>/essay/lu9dks/</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1619799998545-a5718c40-08b7-4571-84a2-c79b4396d498.jpeg#crop=0&crop=0&crop=1&crop=1&height=1112&id=WX9p5&margin=%5Bobject%20Object%5D&name=Screenshot_20210429_234712_edit_1449910826681363.jpg&originHeight=1112&originWidth=2154&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=349927&status=done&style=none&title=&width=2154" alt="Screenshot_20210429_234712_edit_1449910826681363.jpg"></p><p>既不是喰种也不是人类，与既是喰种又是人类，怎么选呢？<br>不谙世事所带来的就是单纯与洁白</p><p>英对好友金木敏锐的反应真的是关心与从小而来的感情之深。</p><blockquote><p>咖啡的味道会随着人们花费于其中的精力而变<br>人做事也是如此，你不用太着急</p></blockquote><p>所有人都认为是对的事情，不一定是对的，而有些错误的事情，的确掌握在少数人手上</p><p>呗先生说的一句话：“金木没有恋人吗 比起同龄的女性 更喜欢被年长的姐姐疼爱把”，这也的确点明金木从小缺爱的身世。</p><p>稚实和董香应该都是内心非常可爱的女孩子把，从小经历生死颠簸坎坷的生活与环境，能保持这么一点可爱的童心真的很不容易。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1642409420043-064162ee-0226-4957-bb9e-2d0b8050ec57.png#clientId=uc1afb5a9-6a8f-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=1080&id=ub936c96a&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1080&originWidth=1920&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=1520763&status=done&style=none&taskId=ua4c5efe6-a48d-4936-b8af-d59463004a9&title=&width=1920" alt="image.png"></p><h3 id="致终章"><a href="#致终章" class="headerlink" title="致终章"></a>致终章</h3><blockquote><p>不……不是我的错<br>不对 都是我 都是我的错</p></blockquote><blockquote><p>事到如今 你还在说这么显而易见的事实<br>你就像这样责备自己 不断地责备自己</p></blockquote><blockquote><p>只是一味地责备自己 结果一点也没有改变<br>变成这样到底是谁的错<br>偶然 事故 运气<br><strong>运气是不存在的 那只是情况和情况的不同组合</strong><br>那又是谁制造了这种情况 是谁呢？<br>就是你啊<br><strong>世界上所有的不利因素都是因为当事人的能力不足</strong></p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1618470547319-c45591d3-8c94-4a78-8e1d-83174784522b.png#crop=0&crop=0&crop=1&crop=1&height=540&id=u3e621b1a&margin=%5Bobject%20Object%5D&originHeight=1080&originWidth=1920&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=607833&status=done&style=stroke&title=&width=960"></p><blockquote><p>事实如此<br>话说回来 一切的开端<br><strong>也就是因为你是一个不谙世事的笨蛋啊</strong><br>因为你是笨蛋 然后被我欺骗<br>还被医生动了手脚<br>所以变成了怪物</p></blockquote><blockquote><p>全部都是你的错<br>于其伤害他人 不如成为被伤害的那一方<br>所以你遇到这种事<br>如果你足够强到能够杀死壁虎的话<br>那两人就能得救了哦<br>或者如果你选择了男人的话 那个女人就可能得救了<br>那个时候也是如此<br><strong>如果你有足够实力的话</strong></p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1618470834142-4bea4e83-48a2-41fd-9246-e1f0b27c04e5.png#crop=0&crop=0&crop=1&crop=1&height=540&id=u8e685db7&margin=%5Bobject%20Object%5D&originHeight=1080&originWidth=1920&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=1038551&status=done&style=stroke&title=&width=960"></p><blockquote><p>从今往后也一样<br>董香 雏实 英<br>你所珍视的人</p></blockquote><blockquote><p>明白了吗<br>这就是你所选择的生活方式<br>你所选择的未来啊<br>为什么要哭泣呢 为什么要呐喊呢<br>与其伤害他人 你选择成为被伤害的那一方不是吗<br>既温柔又美好<br>看似你两者都选择了<br>但实际上你两者都失去了<br>你的母亲也是如此</p></blockquote><blockquote><p>你其实也希望她这么做吧<br>请你……不要再说了</p></blockquote><blockquote><p>为什么<br>为什么留下我一个人<br>我不要孤单一人<br>我好希望你能够选择我啊</p></blockquote><blockquote><p>没错 金木<br><strong>『每个人都有必须舍弃某一边才能保护重要事物的时刻』</strong></p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1618471315132-4f0b9cc2-ba10-4c59-8c6f-73475002e472.png#crop=0&crop=0&crop=1&crop=1&height=540&id=u5f1533bb&margin=%5Bobject%20Object%5D&originHeight=1080&originWidth=1920&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=2481642&status=done&style=stroke&title=&width=960"></p><blockquote><p><strong>没做到这一点 只是软弱罢了</strong> &gt; <strong>没有舍弃的坚强 缺乏深刻的觉悟</strong><br>你还能继续做被伤害的那一方吗<br>你还能原谅壁虎这种人吗</p></blockquote><blockquote><p>无法……无法原谅</p></blockquote><blockquote><p>你最重要的英 还有安定区的同伴们<br>都有可能遇到那种事</p></blockquote><blockquote><p><strong>你拥有做到这些的力量吗</strong> &gt; <strong>我有…</strong> &gt; <strong>那也就是你要接受我的意思吗</strong> &gt; <strong>不对</strong> &gt; <strong>并不是这样</strong> &gt; <strong>我只要超越你就好了</strong> &gt; <strong>即使这是错误的选择也没关系吗</strong> &gt; <strong>『错的人不是我 错误的是…这个世界』</strong></p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1618471631139-459ab7b1-8de4-439a-ba90-47ec64a973db.png#crop=0&crop=0&crop=1&crop=1&height=540&id=u359998a2&margin=%5Bobject%20Object%5D&originHeight=1080&originWidth=1920&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=3208423&status=done&style=stroke&title=&width=960"></p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1618471714779-46f493f2-f76d-4ae8-8016-82a8acc51e66.png#crop=0&crop=0&crop=1&crop=1&height=540&id=u0b809119&margin=%5Bobject%20Object%5D&originHeight=1080&originWidth=1920&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=1977959&status=done&style=stroke&title=&width=960"></p><p><a href="https://music.163.com/outchain/player?type=2&id=29017078&auto=0&height=66">点击查看【music163】</a></p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1618472037932-fcffb7e6-0ca2-4f68-9c3d-52d865fd05ca.png#crop=0&crop=0&crop=1&crop=1&height=540&id=u82016ac2&margin=%5Bobject%20Object%5D&originHeight=1080&originWidth=1920&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=2748009&status=done&style=stroke&title=&width=960"></p><pre><code>教えて 教えてよその仕組みを僕の中に誰がいるの？壊れた 壊れたよこの世界で君が笑う何も見えずに壊れた僕なんてさ息を止めてほどけない もう ほどけないよ真実さえ freeze壊せる 壊せない狂える 狂えないあなたを見つけて 揺れた歪んだ世界にだんだん僕は透き通って見えなくなって見つけないで 僕のことを見つめないで誰かが描いた世界の中であなたを傷つけたくはないよ覚えていて 僕のことを鮮やかなまま無限に広がる孤独が絡まる無邪気に笑った記憶が刺さって動けない 動けない動けない 動けない動けない 動けないよUnravelling the world変わってしまった 変えられなかった2つが絡まる 2人が滅びる壊せる 壊せない狂える 狂えないあなたを汚せないよ 揺れた歪んだ世界にだんだん僕は透き通って見えなくなって見つけないで 僕のことを見つめないで誰かが仕組んだ孤独な罠に未来がほどけてしまう前に思い出して 僕のことを鮮やかなまま忘れないで 忘れないで忘れないで 忘れないで変わってしまったことに paralyze変えられないことだらけの paradise覚えていて 僕のことを教えて教えて僕の中に誰がいるの？</code></pre>]]></content>
      
      
      <categories>
          
          <category> 影视 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>art-template模板</title>
      <link href="/blog/qhgult/"/>
      <url>/blog/qhgult/</url>
      
        <content type="html"><![CDATA[<h2 id="art-template-和-express-art-template"><a href="#art-template-和-express-art-template" class="headerlink" title="art-template 和 express-art-template"></a>art-template 和 express-art-template</h2><div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">为了是art-template模板引擎能够更好地和Express框架配合，模板引擎官方在源art-template模板引擎的基础上封装了express-art-template，所以在使用Espress框架时候，这两个模块都要下载。</div><ul><li>art-template 官网：<a href="https://aui.github.io/art-template/zh-cn/docs/">https://aui.github.io/art-template/zh-cn/docs/</a></li><li>关于模板引擎：<a href="https://segmentfault.com/a/1190000020478061">6 个常见 JS 模板引擎</a></li></ul><h3 id="使用模板渲染情况下声明"><a href="#使用模板渲染情况下声明" class="headerlink" title="使用模板渲染情况下声明"></a>使用模板渲染情况下声明</h3><pre><code class="javascript">// 渲染后缀为art的模板时，所使用的模板引擎是什么app.engine(&quot;art&quot;, require(&quot;express-art-template&quot;));// 告诉express框架模板的位置app.set(&quot;views&quot;, path.join(__dirname, &quot;views&quot;));// 告诉express框架模板的默认后缀是什么app.set(&quot;view engine&quot;, &quot;art&quot;);</code></pre><h3 id="关于绝对-相对路径的引用"><a href="#关于绝对-相对路径的引用" class="headerlink" title="关于绝对/相对路径的引用"></a>关于绝对/相对路径的引用</h3><p><strong>模板资源里面引用静态资源的路径要用绝对路径</strong>。怎么使用绝对路径呢，类似 hexo 静态博客一样，前面加一个“/”即可是根目录路径下，再进行根目录路径下路径写法</p>]]></content>
      
      
      <categories>
          
          <category> 👨‍💻Web开发 </category>
          
          <category> Node.js </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>应用层下的域名系统DNS</title>
      <link href="/blog/lz0ywx/"/>
      <url>/blog/lz0ywx/</url>
      
        <content type="html"><![CDATA[<p>域名系统 DNS 的作用就是域名解析为 IP 地址，因为在网络中传输的是字节，从之前学过的报文结构就可以得知，但是为何不直接在报文中直接传输域名呢？因为 IP 地址长度是固定的 32 位（如果是 IPV6 就是固定的 128 位），而域名长度不是固定长度的，及其处理比较困难。所以将域名解析成 IP 地址这个任务就交给了域名服务器了。</p><h2 id="理解什么是域名服务器？"><a href="#理解什么是域名服务器？" class="headerlink" title="理解什么是域名服务器？"></a>理解什么是域名服务器？</h2><p>域名服务器构成了 DNS 中的分布式网络系统，其功能主要是为内外主机提供域名与 IP 地址的互相解析映射服务。域名服务器分布在互联网的各子网中，每个域名服务器负责管理连接到本子网的所有主机，并为其提供服务。</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1618645215420-4ee27962-12d4-467b-81e6-f932e4c82a2a.png#align=left&display=inline&height=226&margin=%5Bobject%20Object%5D&name=image.png&originHeight=452&originWidth=1090&size=77271&status=done&style=stroke&width=545" alt="image.png"><br>域名服务器分为上面所表示的根域名服务器、顶级域名服务器、权限域名服务器、还有本地域名服务器（在本地电脑里面）</p><h3 id="关于本地域名服务器"><a href="#关于本地域名服务器" class="headerlink" title="关于本地域名服务器"></a>关于本地域名服务器</h3><p>本地电脑就有<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1618647707183-7e8f7af0-a3ab-455b-b702-18f82644471b.png#align=left&display=inline&height=398&margin=%5Bobject%20Object%5D&name=image.png&originHeight=796&originWidth=662&size=58470&status=done&style=none&width=331" alt="image.png"></p><h3 id="关于根域名服务器"><a href="#关于根域名服务器" class="headerlink" title="关于根域名服务器"></a>关于根域名服务器</h3><blockquote><p>关于根域名服务器，这里面有个有趣的话题，参考这篇文章：<br><a href="https://segmentfault.com/a/1190000023696737">美国如果把根域名服务器封了，中国会从网络上消失？</a></p></blockquote><h2 id="理解什么是域名注册商？"><a href="#理解什么是域名注册商？" class="headerlink" title="理解什么是域名注册商？"></a>理解什么是域名注册商？</h2><blockquote><p>域名服务器之所以能知道域名与 IP 地址的映射信息，是因为我们在域名服务商那里提交了域名记录。购买了一个域名之后，我们需要在域名服务商那里设置域名解析的记录，域名服务商把这些记录推送到权威域名服务器，这样我们的域名才能正式生效。<br>常见的域名服务商有阿里云、腾讯云等等……</p></blockquote><h3 id="注册域名注册商"><a href="#注册域名注册商" class="headerlink" title="注册域名注册商"></a>注册域名注册商</h3><p>要成为域名注册商需要提权，具体参考：<a href="https://baike.baidu.com/item/%E5%9F%9F%E5%90%8D%E6%B3%A8%E5%86%8C%E5%95%86">https://baike.baidu.com/item/%E5%9F%9F%E5%90%8D%E6%B3%A8%E5%86%8C%E5%95%86</a><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1618646601711-fca612d8-b2cd-4c22-8417-5938c415c7ce.png#align=left&display=inline&height=85&margin=%5Bobject%20Object%5D&name=image.png&originHeight=169&originWidth=1064&size=19679&status=done&style=stroke&width=532" alt="image.png"></p><h3 id="ICANN"><a href="#ICANN" class="headerlink" title="ICANN"></a>ICANN</h3><p>『互联网名称与数字地址分配机构』<br>可以看看发展历程<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1618646847974-89e834aa-7e05-4788-aebb-ac3a084362e4.png#align=left&display=inline&height=382&margin=%5Bobject%20Object%5D&name=image.png&originHeight=763&originWidth=1107&size=424236&status=done&style=none&width=553.5" alt="image.png"><br>不仅如此，包含全球的域名相关信息的 ICANN 的数据库管控方式也是极为严格，<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1618646929122-b3d35ad5-9a28-4fd2-a56f-1b7164cd51ff.png#align=left&display=inline&height=242&margin=%5Bobject%20Object%5D&name=image.png&originHeight=485&originWidth=1111&size=135338&status=done&style=stroke&width=555.5" alt="image.png"><br>像极了电影里面的情节<img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1618646983840-652fc715-3b53-427d-9722-86890ccbe07a.jpeg#align=left&display=inline&height=59&margin=%5Bobject%20Object%5D&name=huaji1558a846ddf2e12b.jpeg&originHeight=59&originWidth=55&size=703&status=done&style=stroke&width=55" alt="huaji1558a846ddf2e12b.jpeg"><br>具体参考：<a href="https://baike.baidu.com/item/%E4%BA%92%E8%81%94%E7%BD%91%E5%90%8D%E7%A7%B0%E4%B8%8E%E6%95%B0%E5%AD%97%E5%9C%B0%E5%9D%80%E5%88%86%E9%85%8D%E6%9C%BA%E6%9E%84/2775450?fromtitle=ICANN&fromid=6807198">https://baike.baidu.com/item/%E4%BA%92%E8%81%94%E7%BD%91%E5%90%8D%E7%A7%B0%E4%B8%8E%E6%95%B0%E5%AD%97%E5%9C%B0%E5%9D%80%E5%88%86%E9%85%8D%E6%9C%BA%E6%9E%84/2775450?fromtitle=ICANN&amp;fromid=6807198</a></p><h2 id="域名解析过程"><a href="#域名解析过程" class="headerlink" title="域名解析过程"></a>域名解析过程</h2><div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">了解了上面一些DNS宏观的设计方式，再来到域名解析就比较好理解了，域名解析就是将域名解析为IP地址，它怎么解析呢？利用在域名服务器里面查找有没有相关的解析记录。</div><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1618647354829-7da7d070-ba2e-404d-937d-45dcfb2faf25.png#align=left&display=inline&height=329&margin=%5Bobject%20Object%5D&name=image.png&originHeight=657&originWidth=1293&size=150691&status=done&style=stroke&width=646.5" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1618647396384-6ec5030a-0fdf-46c5-9ebb-1d257d92f2c9.png#align=left&display=inline&height=333&margin=%5Bobject%20Object%5D&name=image.png&originHeight=665&originWidth=943&size=175373&status=done&style=stroke&width=471.5" alt="image.png"></p><h2 id="使用工具查看-DNS-查询过程"><a href="#使用工具查看-DNS-查询过程" class="headerlink" title="使用工具查看 DNS 查询过程"></a>使用工具查看 DNS 查询过程</h2><h3 id="Linux-下的-dig-命令"><a href="#Linux-下的-dig-命令" class="headerlink" title="Linux 下的 dig 命令"></a>Linux 下的 dig 命令</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1618649698238-46345e66-fccd-4ad5-b99c-76db7072c62f.png#align=left&display=inline&height=360&margin=%5Bobject%20Object%5D&name=image.png&originHeight=720&originWidth=1440&size=88912&status=done&style=none&width=720" alt="image.png"></p><h3 id="Windows-下的-trance-命令"><a href="#Windows-下的-trance-命令" class="headerlink" title="Windows 下的 trance 命令"></a>Windows 下的 trance 命令</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1618649719833-b58925d7-4a25-4bdc-897b-e7bb281efed5.png#align=left&display=inline&height=360&margin=%5Bobject%20Object%5D&name=image.png&originHeight=720&originWidth=1440&size=100070&status=done&style=none&width=720" alt="image.png"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://github.com/ruanyf/articles/blob/master/2016/2016-06-15-dns.md">DNS 原理入门 - 阮一峰的网络日志</a></li><li><a href="https://segmentfault.com/a/1190000023696737">https://segmentfault.com/a/1190000023696737</a></li><li><a href="https://baike.baidu.com/item/%E5%9F%9F%E5%90%8D%E6%B3%A8%E5%86%8C%E5%95%86">https://baike.baidu.com/item/%E5%9F%9F%E5%90%8D%E6%B3%A8%E5%86%8C%E5%95%86</a></li><li><a href="https://baike.baidu.com/item/%E4%BA%92%E8%81%94%E7%BD%91%E5%90%8D%E7%A7%B0%E4%B8%8E%E6%95%B0%E5%AD%97%E5%9C%B0%E5%9D%80%E5%88%86%E9%85%8D%E6%9C%BA%E6%9E%84/2775450?fromtitle=ICANN&fromid=6807198">https://baike.baidu.com/item/%E4%BA%92%E8%81%94%E7%BD%91%E5%90%8D%E7%A7%B0%E4%B8%8E%E6%95%B0%E5%AD%97%E5%9C%B0%E5%9D%80%E5%88%86%E9%85%8D%E6%9C%BA%E6%9E%84/2775450?fromtitle=ICANN&amp;fromid=6807198</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>客户端存储</title>
      <link href="/blog/bzdwkx/"/>
      <url>/blog/bzdwkx/</url>
      
        <content type="html"><![CDATA[<h3 id="本地存储特性"><a href="#本地存储特性" class="headerlink" title="本地存储特性"></a>本地存储特性</h3><ul><li>数据存储在用户浏览器中</li><li>设置、读取方便、甚至页面刷新不丢失数据</li><li>容量较大，<code>sessionStorage</code>约<code>5M</code>、<code>localStorage</code>约<code>20M</code></li><li>只能存储字符串，可以将对象<code>JSON.stringify()</code>编码后存储，然后使用的使用<code>JSON.parse()</code>转换回对象</li></ul><h3 id="window-sessionStorage"><a href="#window-sessionStorage" class="headerlink" title="window.sessionStorage"></a>window.sessionStorage</h3><p>1、生命周期为关闭浏览器窗口<br>2、在同一个窗口(页面)下数据可以共享<br>3、以键值对的形式存储使用<br>存储数据：</p><pre><code class="javascript">sessionStorage.setItem(key, value);</code></pre><p>获取数据：</p><pre><code class="javascript">sessionStorage.getItem(key);</code></pre><p>删除数据：</p><pre><code class="javascript">sessionStorage.removeItem(key);</code></pre><p>清空数据：(所有都清除掉)</p><pre><code class="javascript">sessionStorage.clear();</code></pre><h3 id="window-localStorage"><a href="#window-localStorage" class="headerlink" title="window.localStorage"></a>window.localStorage</h3><p>1、声明周期永久生效，除非手动删除 否则关闭页面也会存在<br>2、可以多窗口（页面）共享（同一浏览器可以共享）<br>3.   以键值对的形式存储使用<br>存储数据：</p><pre><code class="javascript">localStorage.setItem(key, value);</code></pre><p>获取数据：</p><pre><code class="javascript">localStorage.getItem(key);</code></pre><p>删除数据：</p><pre><code class="javascript">localStorage.removeItem(key);</code></pre><p>清空数据：(所有都清除掉)</p><pre><code class="javascript">localStorage.clear();</code></pre><h3 id="工具函数的封装"><a href="#工具函数的封装" class="headerlink" title="工具函数的封装"></a>工具函数的封装</h3><pre><code class="javascript">class StorageFn &#123;  constructor() &#123;    this.ls = window.localStorage;    this.ss = window.sessionStorage;  &#125;  /*-----------------cookie---------------------*/  /*设置cookie*/  setCookie(name, value, day) &#123;    var setting = arguments[0];    if (Object.prototype.toString.call(setting).slice(8, -1) === &quot;Object&quot;) &#123;      for (var i in setting) &#123;        var oDate = new Date();        oDate.setDate(oDate.getDate() + day);        document.cookie = i + &quot;=&quot; + setting[i] + &quot;;expires=&quot; + oDate;      &#125;    &#125; else &#123;      var oDate = new Date();      oDate.setDate(oDate.getDate() + day);      document.cookie = name + &quot;=&quot; + value + &quot;;expires=&quot; + oDate;    &#125;  &#125;  /*获取cookie*/  getCookie(name) &#123;    var arr = document.cookie.split(&quot;; &quot;);    for (var i = 0; i &lt; arr.length; i++) &#123;      var arr2 = arr[i].split(&quot;=&quot;);      if (arr2[0] == name) &#123;        return arr2[1];      &#125;    &#125;    return &quot;&quot;;  &#125;  /*删除cookie*/  removeCookie(name) &#123;    this.setCookie(name, 1, -1);  &#125;  /*-----------------localStorage---------------------*/  /*设置localStorage*/  setLocal(key, val) &#123;    var setting = arguments[0];    if (Object.prototype.toString.call(setting).slice(8, -1) === &quot;Object&quot;) &#123;      for (var i in setting) &#123;        this.ls.setItem(i, JSON.stringify(setting[i]));      &#125;    &#125; else &#123;      this.ls.setItem(key, JSON.stringify(val));    &#125;  &#125;  /*获取localStorage*/  getLocal(key) &#123;    if (key) return JSON.parse(this.ls.getItem(key));    return null;  &#125;  /*移除localStorage*/  removeLocal(key) &#123;    this.ls.removeItem(key);  &#125;  /*移除所有localStorage*/  clearLocal() &#123;    this.ls.clear();  &#125;  /*-----------------sessionStorage---------------------*/  /*设置sessionStorage*/  setSession(key, val) &#123;    var setting = arguments[0];    if (Object.prototype.toString.call(setting).slice(8, -1) === &quot;Object&quot;) &#123;      for (var i in setting) &#123;        this.ss.setItem(i, JSON.stringify(setting[i]));      &#125;    &#125; else &#123;      this.ss.setItem(key, JSON.stringify(val));    &#125;  &#125;  /*获取sessionStorage*/  getSession(key) &#123;    if (key) return JSON.parse(this.ss.getItem(key));    return null;  &#125;  /*移除sessionStorage*/  removeSession(key) &#123;    this.ss.removeItem(key);  &#125;  /*移除所有sessionStorage*/  clearSession() &#123;    this.ss.clear();  &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 👨‍💻Web开发 </category>
          
          <category> JavaScript+DOM+BOM+TS </category>
          
          <category> BOM </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>综合实验2——约瑟夫环🔖链表</title>
      <link href="/blog/itu2g5/"/>
      <url>/blog/itu2g5/</url>
      
        <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>设有 n 个人围坐在圆桌周围，现从某个位置 m(1≤m≤n)上的人开始报数，报数到 k 的人就站出来。下一个人，即原来的第 k+1 个位置上的人，又从 1 开始报数，再报数到 k 的人站出来。依次重复下去，直到全部的人都站出来为止。试设计一个程序求出这 n 个人的<strong>出列顺序</strong>。</p><h2 id="问题要求"><a href="#问题要求" class="headerlink" title="问题要求"></a>问题要求</h2><ol><li>构造一个具有 n 个结点的循环单链表，用于存储圆桌周围的人的编号，链表结点的 data 域存放桌子周围的人的编号。</li><li>为保持程序的通用性,问题中的 n、m、k 可由用户从键盘输入.</li><li>要求编写函数模拟约瑟夫问题的实现过程,并输出 n 个人的出列顺序。</li></ol><h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>这个问题和综合实验一的思路一样，都是利用循环单链表（所以理论上之前的狐狸逮兔子应该用顺序表，而我用了链表<img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1617761762269-2745323d-e497-4442-984b-fe31e817f25a.jpeg#align=left&display=inline&height=90&margin=%5Bobject%20Object%5D&name=huajif07e7f9f783b2e6.jpeg&originHeight=90&originWidth=62&size=1957&status=done&style=stroke&width=62" alt="huajif07e7f9f783b2e6.jpeg">）。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>写代码过程中，题目没看清楚，一开始以为是被选中的人还呆在环里面，就导致我的指针指了一下午的寂寞……<img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1617799608465-1b5ed521-81ea-4434-a2bb-3d104e6ea038.jpeg#align=left&display=inline&height=56&margin=%5Bobject%20Object%5D&name=huaji-336495ce81a39782.jpeg&originHeight=56&originWidth=52&size=3550&status=done&style=stroke&width=52" alt="huaji-336495ce81a39782.jpeg">，不说了，交实验报告去了……</p><pre><code class="cpp">#include&lt;bits/stdc++.h&gt;using namespace std;/** * 定义一个单链表 */typedef struct LNode &#123;    int data;    struct LNode *next;&#125;Lnode, *LinkList;/** * 初始化单链表 */void InitList(LinkList &amp;L) &#123;    L = new LNode;    L-&gt;next = NULL;    L-&gt;data = 1;&#125;/* 初始化循环链表的初始值 */void init_add(LinkList &amp;L, int n) &#123;    InitList(L);    LinkList p = L;    for (int i = 2; i &lt;= n;i++) &#123;        LinkList p_temp = new Lnode;        p_temp-&gt;data = i;        if (i == n) &#123;            p_temp-&gt;next = L;            p-&gt;next = p_temp;        &#125; else &#123;            p_temp-&gt;next = p-&gt;next;            p-&gt;next = p_temp;            p = p-&gt;next;        &#125;    &#125;&#125;void joseph_ring(LinkList &amp;L, int n, int m, int k) &#123;    init_add(L, n);    LinkList p = L;    for (int i = 0; i&lt; m; i++) &#123;        p = p-&gt;next;    &#125;    while(p-&gt;next != p) &#123;        for (int j = 1; j&lt; k; j++) &#123;            if (j == k-1) &#123;                cout&lt;&lt;p-&gt;next-&gt;data&lt;&lt;&quot;号出来&quot;&lt;&lt;&quot;\n&quot;;                p-&gt;next = p-&gt;next-&gt;next;                p = p-&gt;next;            &#125; else &#123;                p = p-&gt;next;            &#125;        &#125;    &#125;    cout&lt;&lt; p-&gt;data&lt;&lt;&quot;号出来&quot;&lt;&lt;&quot;\n&quot;;&#125;int main()&#123;    cout &lt;&lt; &quot;请依次输入人数n、报数位置m、报到指定值就站起来的k值&quot; &lt;&lt; &quot;\n&quot;;    int n, m, k;    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;    LinkList p;    joseph_ring(p, n, m, k);&#125;</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1618305848004-50b702f4-e85f-410e-8310-bbd0c16ecac2.png#align=left&display=inline&height=136&margin=%5Bobject%20Object%5D&name=image.png&originHeight=272&originWidth=933&size=35832&status=done&style=none&width=466.5" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> Problems </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>综合实验1——狐狸逮兔子🔖链表</title>
      <link href="/blog/bexxoi/"/>
      <url>/blog/bexxoi/</url>
      
        <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>围绕着山顶有 10 个圆形排列的洞,狐狸要吃兔子,兔子说:”可以,但必须找到我,我就藏于这 10 个洞中,你先到 1 号洞找,第二次隔 1 个洞(即 3 号洞)找,第二次隔 2 个洞(即 6 号洞)找,以后如此类推,次数不限.”但狐狸从早到晚进进出出了 1000 次,仍没有找到兔子.问:兔子究竟藏在那个洞里?</p><h2 id="问题要求"><a href="#问题要求" class="headerlink" title="问题要求"></a>问题要求</h2><ol><li>设计一种存储方式用于存储山洞,元素的下标表示山洞的编号,元素的值为 1 表示狐狸没有进过山洞,为 0 表示狐狸进过该山洞.</li><li>为保持程序的通用性,山洞的数目和狐狸进出山洞的次数不一定为题设的 10 和 1000,可由用户从键盘输入.</li><li>要求编写函数模拟狐狸逮兔子的过程,并输出兔子可能的藏身之处.</li></ol><p>注：实验报告中要求说明采用了什么存储结构。</p><h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>这实际上是一个反复查找线性表的过程.<br><del>定义一个顺序表,用具有 10 个元素的顺序表来表示这 10 个洞.每个元素表示围绕山顶的一个洞,下标为洞的编号.对所有洞设置初始标志为 1,然后通过 1000 次循环,对每次所进之洞修改标志为 0,最后输出标志为 1 的洞,即兔子藏身的洞</del>.<br>定义了一个单链表，将其转换为循环链表，利用循环链表来解决了这个问题。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="cpp">#include&lt;bits/stdc++.h&gt;using namespace std;typedef struct LNode &#123;    int data;    int flag;    struct LNode *next;&#125;Lnode, *LinkList;int main() &#123;    LinkList L;    L = new LNode;    L-&gt;data = 1;    L-&gt;flag = 1;    L-&gt;next = NULL;    for (int i = 1; i &lt; 10;i++) &#123;        LinkList p;        p = new LNode;        p-&gt;data = 11-i;        p-&gt;flag = 1;        p-&gt;next = L-&gt;next;        L-&gt;next = p;        if (i == 1)&#123;            p-&gt;next = L;        &#125;    &#125;    LinkList s;    s = new LNode;    s = L;    for (int i = 0; i &lt; 1000;i++) &#123;        s-&gt;flag = 0;        for (int j = 0; j &lt; i+2;j++) &#123;            s = s-&gt;next;        &#125;    &#125;    cout &lt;&lt; &quot;最终结果：&quot;&lt;&lt; &quot;\n&quot;;    for (int i = 0; i &lt; 10;i++)&#123;        cout &lt;&lt; L-&gt;data &lt;&lt;&quot;洞&quot;&lt;&lt; &quot; &quot; &lt;&lt; L-&gt;flag &lt;&lt; &quot;\n&quot;;        L = L-&gt;next;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> Problems </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[加密文章]Write Code Summary</title>
      <link href="/blog/fit037/"/>
      <url>/blog/fit037/</url>
      
        <content type="html"><![CDATA[<p>这是加密文章！</p>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++串</title>
      <link href="/blog/hcwio0/"/>
      <url>/blog/hcwio0/</url>
      
        <content type="html"><![CDATA[<h2 id="课后一些问题"><a href="#课后一些问题" class="headerlink" title="课后一些问题"></a>课后一些问题</h2><p>（1）串是一种特殊的线性表，其特殊性体现在（  ）。<br> A．可以顺序存储             **  B．数据元素是一个字符   **   <br>C．可以链式存储               D．数据元素可以是多个字符若  <br>答案：B</p><p>（2）串下面关于串的的叙述中，（  ）是不正确的？  <br>A．串是字符的有限序列          <strong>B．空串是由空格构成的串</strong><br>C．模式匹配是串的一种重要运算  D．串既可以采用顺序存储，也可以采用链式存储<br>答案：B<br>解释：空格常常是串的字符集合中的一个元素，有一个或多个空格组成的串成为空格串，零个字符的串成为空串，其长度为零。</p><p>（5）串的长度是指（  ）。<br>A．串中所含不同字母的个数    **   B．串中所含字符的个数**<br>C．串中所含不同字符的个数       D．串中所含非空格字符的个数<br>答案：B<br>解释：串中字符的数目称为串的长度。</p>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 📶线结构：字符串-数组-栈-队列 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>今年的清明有点不一样</title>
      <link href="/essay/nyh946/"/>
      <url>/essay/nyh946/</url>
      
        <content type="html"><![CDATA[<p>还是在昨天，济南这边下了一场不小的雨，图书馆外的风甚是喧嚣，今天却又是格外晴朗…</p><p>和三月份回学校那天一样，南昌下着大雨，在去昌北机场大巴的车上，鹏鹏打电话和我说华哥死了的时候，那会儿我是很突然的，还没反应过来，人就懵了…车窗外的雨下的愈来愈大</p><p>以前，亲戚长辈们总和我们后辈说，不要学华哥，说是没出息，那会我不懂，我不懂的是什么叫出息，更不懂人们眼中的出息叫什么，我只知道他是我哥，我很喜欢和他玩。</p><p>小时候某年过节那会，亲戚朋友们都聚在一起，大人们都在那谈论电动摩特车，我在一旁听着，想跃跃欲试，我和身旁的华哥说，借他车去路上试试，华哥二话不说把我带到路上把车子开动，我凭着刚才他们大人们的三言两句，三下五除二车子就被我骑的老远，然后手不由自主地加速，车子越来越快，那一瞬间我突然想起来我忘了问刹车在哪…那一瞬间我实实在在感受到了相对速度的感念，车子走了，我屁股着地了～事后华哥笑着和我爸妈说，没多大事…</p><p>这个世界上，我一直相信人不止一面，在人们面前展示的一面，或许是普通的一面，可能一个人的表面是不被人所喜爱的，有几分不羁放纵，也可以是洒脱，当然也有那种特别讨别人喜的那种性格，但我也说了，人是复杂的，有的人在别人看来很没出息，没有大作为，可是，人心很好，当亲朋好友有困难，他会第一时间帮忙，和长辈说话，他会很认真倾听…当人类文明被创建那会，就注定会有框架来定义某些事情的标准。</p><p>我一直对自己说，平生这辈不做一个庸俗之人，尽管身处这个文明有很多的框架…</p><p>已故之人，定当缅怀之，下飞机已经是傍晚六点那会，夕阳洒在那诺大的跑道上，那般场景太容易调动情感，</p><p>在飞机上的一个半小时，我应该是离华哥最近的吧…<br><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1617606456340-0908688d-ae97-4581-9cdd-53c767da919d.jpeg#height=472&id=RgO7L&margin=%5Bobject%20Object%5D&name=IMG_20210109_164434.jpg&originHeight=3648&originWidth=2736&originalType=binary&size=1434606&status=done&style=none&width=354" alt="IMG_20210109_164434.jpg"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1617606104878-d295f451-12db-4207-b53a-9bfa1b250017.jpeg#height=472&id=jTfMO&margin=%5Bobject%20Object%5D&name=IMG_20210109_180755.jpg&originHeight=3648&originWidth=2736&originalType=binary&size=1847977&status=done&style=none&width=354" alt="IMG_20210109_180755.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>轮子哥……</title>
      <link href="/essay/las4ft/"/>
      <url>/essay/las4ft/</url>
      
        <content type="html"><![CDATA[<p>一时造轮子一时爽，一直造轮子，一直爽……</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>jQuery使用笔记</title>
      <link href="/blog/aa9fsh/"/>
      <url>/blog/aa9fsh/</url>
      
        <content type="html"><![CDATA[<p><code>jQuery</code>只是对原生的<code>JavaScript</code>进行封装，说白了就是封装成伪数组，所以记住它的一些调用方法就可以了</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://jquery.cuishifeng.cn/">jQuery API 速查表 –作者：Shifone</a></li><li><a href="https://www.processon.com/view/link/5b7d6458e4b0534c9bb76ad9#map">jQuery 思维导图</a></li></ul><h2 id="一些特性"><a href="#一些特性" class="headerlink" title="一些特性"></a>一些特性</h2><ul><li><code>$</code>符号：jq 里面的顶级对象</li><li>入口函数：在 DOM 里面的 DOMContentLoaded，在$里面直接赋予入口函数即可</li><li>jq 对象和 DOM 对象：</li></ul><p>两者之间的函数调用不能互换（因为是被封装成了伪数组）<br>jq 转换为 DOM：加数组下标即可（因为是被封装成了伪数组，利用索引即可）<br>DOM 转换为 jq：使用$符号即可（括号不加引号），或者是 get(索引值)</p><h2 id="常用-API"><a href="#常用-API" class="headerlink" title="常用 API"></a>常用 API</h2><h3 id="选择器操作"><a href="#选择器操作" class="headerlink" title="选择器操作"></a>选择器操作</h3><ul><li>元素获取：之前的 CSS 选择器（基础选择器、复合选择器）怎么写，这里直接就放到$里面即可</li></ul><p>筛选选择器<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1617359781992-e02802ae-f357-4987-a8a0-46cc0c5be69a.png#height=165&id=yL3dG&margin=%5Bobject%20Object%5D&name=image.png&originHeight=249&originWidth=793&originalType=binary%E2%88%B6=1&size=49996&status=done&style=none&width=524" alt="image.png"></p><ul><li>隐式迭代：如果获取的元素是一个数组，那么对其赋予的新操作，会隐式遍历</li><li>元素属性操作：css(“属性”,”值”)函数</li><li>元素节点操作</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1617359820567-38b9fad2-deb7-429f-9d21-8f9676563426.png#height=262&id=G7Yck&margin=%5Bobject%20Object%5D&name=image.png&originHeight=344&originWidth=709&originalType=binary%E2%88%B6=1&size=63602&status=done&style=none&width=541" alt="image.png"></p><ul><li>事件：.mouseover()、.click()</li><li>.show()、.hide()：元素显示和隐藏</li><li>$(this)当前这个对象</li></ul><h3 id="样式操作"><a href="#样式操作" class="headerlink" title="样式操作"></a>样式操作</h3><p>样式的操作还是和之前的 DOM 一样，有两种，一种是逐个设置该元素的属性和值，另一种就是改变其类，jq 里面也是这个大题思路，不过有不同</p><ul><li>单一设置：.css()函数，一个参数的时候，返回该参数的值，两个参数的时候，即赋予该属性及值</li><li>clsss 设置</li></ul><p>.addClass(“类名”)：如果该元素没有该类，则加上<br>.removeClass()：移除指定类名<br>.toggle()：如果该元素有该类则删除，如果没有该类则加上</p><ul><li>class 设置和 DOM 里面 className 区别是前者不会删除原本的类，后者会</li></ul><h3 id="效果操作"><a href="#效果操作" class="headerlink" title="效果操作"></a>效果操作</h3><p>jq 封装了很多的效果，具体可以详查相关文档     <br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1617361907950-d1d89194-401d-46aa-9471-34139e3e00df.png#height=149&id=SD9oO&margin=%5Bobject%20Object%5D&name=image.png&originHeight=298&originWidth=703&originalType=binary%E2%88%B6=1&size=42060&status=done&style=stroke&width=351.5" alt="image.png"></p><h3 id="属性操作"><a href="#属性操作" class="headerlink" title="属性操作"></a>属性操作</h3><ul><li>prop()：得到/设置元素固有的属性及值</li><li>attr()：得到/设置元素自定义的属性及值</li><li>data()：数据缓存</li></ul><h3 id="内容文本值操作"><a href="#内容文本值操作" class="headerlink" title="内容文本值操作"></a>内容文本值操作</h3><ul><li>html()：相当于 innerHTML</li><li>text()：相当于 innerText</li><li>val()：操作表单的值（没有参数是获取值，有一个参数是设置）</li></ul><h3 id="元素操作"><a href="#元素操作" class="headerlink" title="元素操作"></a>元素操作</h3><div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">遍历</div><blockquote><p>第一种表达：</p></blockquote><ul><li><p>$(“div”).each(function(index,ele){XXXX})</p></li><li><p>其中 index 是索引号，ele 得到的是 DOM 对象</p><blockquote><p>第二种表达</p></blockquote></li><li><p>$.each(Object,function(index,ele){XXXXX})</p></li><li><p>主要用于数据处理</p></li></ul><div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">创建</div><p>直接在$里面双引号加上需要创建的标签</p><div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">添加</div><blockquote><p>第一种关系：添加生成父子关系</p></blockquote><ul><li><p>append(“”)</p></li><li><p>prepend(“”)</p><blockquote><p>第二种关系：添加生成兄弟关系</p></blockquote></li><li><p>after(“”)</p></li><li><p>before(“”)</p></li></ul><div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">删除</div><ul><li>remove()：移除选定节点</li><li>empty()：清空所选节点的左右子节点</li><li>html(“”)：将所选节点的 html 内容制空（相当于删除节点了）</li></ul><h3 id="尺寸、位置操作"><a href="#尺寸、位置操作" class="headerlink" title="尺寸、位置操作"></a>尺寸、位置操作</h3><div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">尺寸操作</div>![image.png](https://cdn.nlark.com/yuque/0/2021/png/1484158/1617364626783-b5a50ec5-eeb2-4447-bc15-c7c209ae1d08.png#height=152&id=AIKMv&margin=%5Bobject%20Object%5D&name=image.png&originHeight=303&originWidth=1166&originalType=binary∶=1&size=133998&status=done&style=none&width=583)参数为空：返回值参数为一个值：设置<div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">位置操作</div><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1617364679986-4ff0b4c0-8622-4111-9c4b-c6571bd278db.png#height=127&id=SdHbS&margin=%5Bobject%20Object%5D&name=image.png&originHeight=253&originWidth=1246&originalType=binary%E2%88%B6=1&size=75964&status=done&style=stroke&width=623" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1617364688980-2d85f32d-a51c-48ae-85a9-fc9f613536e5.png#height=144&id=AO6QL&margin=%5Bobject%20Object%5D&name=image.png&originHeight=288&originWidth=1179&originalType=binary%E2%88%B6=1&size=78029&status=done&style=stroke&width=589.5" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1617364699038-74aa84bc-20ec-4427-9485-311ebaf9d066.png#height=120&id=jllHI&margin=%5Bobject%20Object%5D&name=image.png&originHeight=240&originWidth=1047&originalType=binary%E2%88%B6=1&size=62052&status=done&style=stroke&width=523.5" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> 👨‍💻Web开发 </category>
          
          <category> jQuery </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CSS预处理器</title>
      <link href="/blog/zsiw5e/"/>
      <url>/blog/zsiw5e/</url>
      
        <content type="html"><![CDATA[<h2 id="stylus"><a href="#stylus" class="headerlink" title="stylus"></a>stylus</h2><p>CSS 预处理器优化 CSS 的开发</p><div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">CSS 的预处理器，给 CSS 添加了可编程的特性，也就是说，在 stylus 中可以使用变量、函数、判断、循环一系列 CSS 没有的东西来编写样式文件，这个文件可编译成 CSS 文件</div><h3 id="note"><a href="#note" class="headerlink" title="note"></a>note</h3><ul><li>“[]”：中括号内容，是定义属性的方式</li></ul><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://www.zhangxinxu.com/jq/stylus/">stylus 中文版参考文档之综述——张鑫旭</a></li><li><a href="https://stylus.bootcss.com/">富于表现力、动态的、健壮的 CSS</a></li></ul><h2 id="less"><a href="#less" class="headerlink" title="less"></a>less</h2><p>参考：<a href="https://less.bootcss.com/">https://less.bootcss.com/</a></p>]]></content>
      
      
      <categories>
          
          <category> 👨‍💻Web开发 </category>
          
          <category> HTML+CSS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CSS的媒体查询</title>
      <link href="/blog/mio9h2/"/>
      <url>/blog/mio9h2/</url>
      
        <content type="html"><![CDATA[<h3 id="媒体查询（CSS3）"><a href="#媒体查询（CSS3）" class="headerlink" title="媒体查询（CSS3）"></a>媒体查询（CSS3）</h3><div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">@media：注意@符号</div><pre><code class="css">@media mediatype and|not|only (media feature) &#123;    CSS-Code;&#125;</code></pre><h3 id="mediatype-查询类型"><a href="#mediatype-查询类型" class="headerlink" title="mediatype 查询类型"></a>mediatype 查询类型</h3><div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">将不同的终端设备划分成不同的类型，称为媒体类型</div><p><img src="https://cdn.nlark.com/yuque/0/2021/jpg/1484158/1615360325196-c449a080-4612-4814-b5da-5a61b1da1c0b.jpg#align=left&display=inline&height=193&margin=%5Bobject%20Object%5D&originHeight=193&originWidth=915&status=done&style=stroke&width=915"></p><h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">关键字将媒体类型或多个媒体特性连接到一起做为媒体查询的条件。</div><ul><li>and：可以将多个媒体特性连接到一起，相当于“且”的意思。</li><li>not：排除某个媒体类型，相当于“非”的意思，可以省略。</li><li>only：指定某个特定的媒体类型，可以省略。</li></ul><h3 id="媒体特性"><a href="#媒体特性" class="headerlink" title="媒体特性"></a>媒体特性</h3><div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">每种媒体类型都具体各自不同的特性，根据不同媒体类型的媒体特性设置不同的展示风格。我们暂且了解三个。</div><p><img src="https://cdn.nlark.com/yuque/0/2021/jpg/1484158/1615360325364-d6cd0d1a-1ec7-4bd1-a67e-3fadde7c4381.jpg#align=left&display=inline&height=195&margin=%5Bobject%20Object%5D&originHeight=195&originWidth=918&status=done&style=stroke&width=918"></p><h3 id="媒体查询书写规则"><a href="#媒体查询书写规则" class="headerlink" title="媒体查询书写规则"></a>媒体查询书写规则</h3><div style="background: #FFF3F3;padding:10px;border: 1px solid #DEB8BE;border-radius:5px;margin-bottom:5px;">为了防止混乱，媒体查询我们要按照从小到大或者从大到小的顺序来写,但是我们最喜欢的还是从小到大来写，这样代码更简洁</div>]]></content>
      
      
      <categories>
          
          <category> 👨‍💻Web开发 </category>
          
          <category> HTML+CSS </category>
          
          <category> 布局 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>GitHub基于Issue的软件项目管理</title>
      <link href="/blog/hgbehz/"/>
      <url>/blog/hgbehz/</url>
      
        <content type="html"><![CDATA[<div style="background: #FFFBE6;padding:10px;border: 1px solid #C3C3C3;border-radius:5px;margin-bottom:5px;">在进行GitHub项目开发过程中，途中会有一些新想法，遇见的新bug等问题，提出的一些新灵感等等都可以利用GitHub每个项目自带的issues（议题）来进行管理、跟踪并且加以解决。传统的软件项目管理还有Milestones（里程碑）、Projects（画板）来一并进行项目的开发，GitHub在2020年还新增加了Discussion（讨论区）模块，进一步提高软件项目的管理工作。</div><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616655875686-d8387a58-3c42-4442-b6b5-1cd2b0c68a5f.png#align=left&display=inline&height=129&id=vUGI2&margin=%5Bobject%20Object%5D&name=image.png&originHeight=258&originWidth=1893&size=52796&status=done&style=stroke&width=946.5" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616656006240-dd9c58bd-6675-487e-aab0-58878e9fcb29.png#align=left&display=inline&height=128&id=PmAcn&margin=%5Bobject%20Object%5D&name=image.png&originHeight=255&originWidth=1895&size=48535&status=done&style=stroke&width=947.5" alt="image.png"></p><h2 id="Issue-标签类型总结"><a href="#Issue-标签类型总结" class="headerlink" title="Issue 标签类型总结"></a>Issue 标签类型总结</h2><h3 id="GitHub-默认标签"><a href="#GitHub-默认标签" class="headerlink" title="GitHub 默认标签"></a>GitHub 默认标签</h3><table><thead><tr><th>bug</th><th>提出一个 bug</th><th>颜色默认</th></tr></thead><tbody><tr><td>documentation</td><td>详查文档</td><td>颜色默认</td></tr><tr><td>duplicate</td><td>这是个重复的问题</td><td>颜色默认</td></tr><tr><td>enhancement</td><td>增强和改进</td><td>颜色默认</td></tr><tr><td>good first issue</td><td>好的想法/灵感</td><td>颜色默认</td></tr><tr><td>help wanted</td><td>使用过程中不明白的地方</td><td>颜色默认</td></tr><tr><td>invalid</td><td>该问题看起来没有意义</td><td>颜色默认</td></tr><tr><td>question</td><td>请提供进一步资料</td><td>颜色默认</td></tr><tr><td>wontfix</td><td>项目设计初衷如此</td><td>颜色默认</td></tr></tbody></table><h3 id="自需添加"><a href="#自需添加" class="headerlink" title="自需添加"></a>自需添加</h3><table><thead><tr><th>debugging</th><th>正在调试</th></tr></thead><tbody><tr><td>fixed</td><td>已被修复</td></tr></tbody></table><blockquote><p>持续更新……</p></blockquote><h2 id="Discussion-的新革新"><a href="#Discussion-的新革新" class="headerlink" title="Discussion 的新革新"></a>Discussion 的新革新</h2><p>传统的流程是提出 issues 之后，根据不同的 issue 来跟进画板（Project）的内容。</p><p>上面的做法其实有一个思维上的 bug，一些灵感之类的不好放上去，使用 Discussion 之后，可以在 Discussion 里面放上想法、灵感等，实际开发从这里面的一个的一个具体的评论转换到实际的 issue 里面</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="http://www.ruanyifeng.com/blog/2017/08/issue.html">http://www.ruanyifeng.com/blog/2017/08/issue.html</a></li><li><a href="https://github.com/volantis-x/hexo-theme-volantis/">https://github.com/volantis-x/hexo-theme-volantis/</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> Git+GitHub </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Git push出(10054)/(port 443：time out)错</title>
      <link href="/blog/tttk33/"/>
      <url>/blog/tttk33/</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1624951739057-ebfc3755-1e5a-426b-a7b3-a7841ead1b1f.png#clientId=u3f2416ef-009b-4&from=paste&height=241&id=yDPwn&margin=%5Bobject%20Object%5D&name=image.png&originHeight=482&originWidth=882&originalType=binary%E2%88%B6=2&size=54005&status=done&style=none&taskId=u314208e8-25e1-4b29-9147-2b0ebc4645c&width=441" alt="image.png"></p><p><strong>前言：今年 GitHub 的各种操作被屏蔽的挺迷的，一开始我只是以为偶尔报个连接失败的 port443 的错误，但是后来经常性的出现本地 push 不上 GitHub 的情况，在此情况记录一下各种情况（clone、pull、push……）连接不上的解决办法。</strong></p><h2 id="一、报错信息与原因分析"><a href="#一、报错信息与原因分析" class="headerlink" title="一、报错信息与原因分析"></a>一、报错信息与原因分析</h2><h3 id="报错信息"><a href="#报错信息" class="headerlink" title="报错信息"></a>报错信息</h3><pre><code class="bash">Git push出(10054)/(port 443：time out)错git push error: RPC failed; curl 56 OpenSSL SSL_read: SSL_ERROR_SYSCALL, errno 10054</code></pre><h3 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h3><ol><li>由于 Http 协议错误，当 pull 或者 clone 的时候，或者是 github 某个 CDN 被 qiang 屏蔽所致。</li><li>用了 kexueshangwang 工具之后，由于更改代理服务器连接端口，导致本地 push 偶尔失败（但是以前有用）。</li></ol><h2 id="二、常规解决方案"><a href="#二、常规解决方案" class="headerlink" title="二、常规解决方案"></a>二、常规解决方案</h2><div style="background: #edf9e8;padding:10px;border: 1px solid #c2d2b5;border-radius:5px;margin-bottom:5px;">2021.06.29更新解决方法：【针对clone失败】https的连接不行，那就用ssh的连接。2021.07.13更新解决方案：【针对pull、push失败】ssh连接push连接不行，那就用token来push。</div><div style="background: #edf9e8;padding:10px;border: 1px solid #c2d2b5;border-radius:5px;margin-bottom:5px;">常规解决方法：第一种方法是下面的三条命令，另外如果用了该三条命令还不行，那就ctrl + c ，再进行输入命令，以此往复，总会出现GitHub的登录框的……；第二种方法就是在本地对host进行更改，让其可以访问github网站的相关ip；</div><h3 id="常规解决方案-1：改代理"><a href="#常规解决方案-1：改代理" class="headerlink" title="常规解决方案 1：改代理"></a>常规解决方案 1：改代理</h3><blockquote><p>10054 的 bug 复制下面的</p></blockquote><pre><code class="bash">git config http.postBuffer 524288000</code></pre><blockquote><p>443 的 bug 复制下面的</p></blockquote><pre><code class="bash"># 设置ssgit config --global http.proxy &#39;socks5://127.0.0.1:10080&#39;git config --global https.proxy &#39;socks5://127.0.0.1:10080&#39;# 设置代理git config --global https.proxy http://127.0.0.1:10080git config --global https.proxy https://127.0.0.1:10080# 取消代理git config --global --unset http.proxygit config --global --unset https.proxy</code></pre><h3 id="常规解决方案-2：改变本地-hosts-文件"><a href="#常规解决方案-2：改变本地-hosts-文件" class="headerlink" title="常规解决方案 2：改变本地 hosts 文件"></a>常规解决方案 2：改变本地 hosts 文件</h3><p>在<a href="https://www.ipaddress.com/">https://www.ipaddress.com/</a>里面查找下面三个域名的 ip 地址</p><ul><li>github.com</li><li>github.global.ssl.fastly.net</li><li>codeload.github.com</li></ul><p>将其添加到本电脑 hosts 文件当中<br><code>C:\Windows\System32\drivers\etc\hosts</code> <br>类似下面：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1615339105733-afb66a55-d96e-4dba-9650-a9d3cb8324fa.png#height=56&id=EhSLV&margin=%5Bobject%20Object%5D&name=image.png&originHeight=112&originWidth=490&originalType=binary%E2%88%B6=1&size=10992&status=done&style=stroke&width=245" alt="image.png"><br>CMD 窗口刷新 DNS 缓存</p><pre><code class="powershell">ipconfig /flushdns</code></pre><h2 id="三、针对性解决方案"><a href="#三、针对性解决方案" class="headerlink" title="三、针对性解决方案"></a>三、针对性解决方案</h2><p>上面两种方案理论上解决了问题，但是奇葩的问题年年有，上述两种方案都不能解决，就用如下方案：</p><h3 id="针对-clone-失败"><a href="#针对-clone-失败" class="headerlink" title="针对 clone 失败"></a>针对 clone 失败</h3><p>如果 https 连接失败，使用 ssh 链连接（前提是电脑端配置了 ssh），如果 ssh 连接也不行，那就下面的针对 pull、push 失败的方案。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1624953268520-f8c7c56d-6588-4991-b63c-11adc5cdd0ae.png#clientId=u1ae40c10-ed35-4&from=paste&height=98&id=KCLWc&margin=%5Bobject%20Object%5D&name=image.png&originHeight=195&originWidth=882&originalType=binary%E2%88%B6=2&size=31370&status=done&style=none&taskId=u14d1ed3c-4738-4a91-b0e7-53ebf113528&width=441" alt="image.png"></p><h3 id="针对-pull、push-失败"><a href="#针对-pull、push-失败" class="headerlink" title="针对 pull、push 失败"></a>针对 pull、push 失败</h3><p>ssh 连接不行，那就使用 token 来连接</p><pre><code class="bash">git push https://一串token@github.com/wztlink1013/datastructure-algorithm</code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.cnblogs.com/mmzs/p/12039888.html">https://www.cnblogs.com/mmzs/p/12039888.html</a></li><li><a href="https://www.jianshu.com/p/f98ed938f91a">使用 Personal access tokens 以避免 Windows 下每次 git push 都需要输入账号密码</a></li><li><a href="https://segmentfault.com/q/1010000039738438">2021 年为什么最近 github 能访问不能 push 代码了</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> ✨其他 </category>
          
          <category> Bug </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++链表(单、循环、双向)设计及操作</title>
      <link href="/blog/gu92gu/"/>
      <url>/blog/gu92gu/</url>
      
        <content type="html"><![CDATA[<div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">前言：这篇文章，打算详细记录下链表的相关知识，毕竟是基础中的基础。首先是先记录下在一开始学习过程中的些许疑惑/C的遗忘，然后记录各种代码（实验报告代码，单链表各种操作代码总结，循环链表代码，双向链表代码）</div><h2 id="实验要求"><a href="#实验要求" class="headerlink" title="实验要求"></a>实验要求</h2><blockquote><p>1、创建一个带头结点的单链表（头指针为 head），且遍历此链表（输出链表中各结点的值）；<br>2、查找单链表中的第 i 个结点，并输出结点元素的值；</p></blockquote><blockquote><p>3、在单链表中的第 i 个结点前插入一个结点值为 e 的正整数(从外部输入);</p></blockquote><blockquote><p>4、删除单链表中的第 j 个结点；</p></blockquote><blockquote><p>*5、将单链表中的各结点就地逆序（不允许另建一个链表）；</p></blockquote><h2 id="概念理解"><a href="#概念理解" class="headerlink" title="概念理解"></a>概念理解</h2><h3 id="链表数据结构"><a href="#链表数据结构" class="headerlink" title="链表数据结构"></a>链表数据结构</h3><p>链表是一种数据结构，和<strong>数组同级</strong>。之前 JAVA 里面的 ArrayList 数据结构，其实现原理是数组，而 JAVA 的 LinkedList 的实现原理就是链表了。链表在进行循环遍历时效率不高，但是插入和删除时优势明显，其实 C/C++抑或是 JAVA 这些数据结构都一样——地址……引用……</p><p>单向链表是一种线性表，实际上是由<strong>节点（Node）</strong>组成的，一个链表拥有不定数量的节点。其数据在<strong>内存中存储是不连续的</strong>，它存储的数据分散在内存中，每个结点只能也只有它能知道下一个结点的存储位置。由 N 各节点（Node）组成单向链表，每一个 Node 记录本 Node 的数据及下一个 Node。向外暴露的只有一个头节点（Head），<strong>我们对链表的所有操作，都是直接或者间接地通过其头节点来进行的。</strong><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1603194076184-195f3044-1083-4244-9eeb-d86c96a37e6f.png#align=left&display=inline&height=98&margin=%5Bobject%20Object%5D&originHeight=98&originWidth=491&size=0&status=done&style=shadow&width=491"><br>上图中最左边的节点即为头结点（Head），但是添加节点的顺序是从右向左的，添加的新节点会被作为新节点。最先添加的节点对下一节点的引用可以为空。引用是引用下一个节点而非下一个节点的对象。因为有着不断的引用，所以<strong>头节点就可以操作所有节点</strong>了。</p><p>下图描述了单向链表存储情况。存储是分散的，每一个节点只要记录下一节点，就把所有数据串了起来，形成了一个单向链表。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1603194105521-d31f8e78-7f2a-4c60-8838-57e15707e27b.png#align=left&display=inline&height=219&margin=%5Bobject%20Object%5D&originHeight=219&originWidth=195&size=0&status=done&style=stroke&width=195"><br>节点（Node）是由一个需要储存的对象及对下一个节点的引用组成的。也就是说，节点拥有两个成员：储存的对象、对下一个节点的引用。下面图是具体的说明：<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1603194124335-fc6fc00c-35fb-44e1-a01c-de4b8b5531af.png#align=left&display=inline&height=207&margin=%5Bobject%20Object%5D&originHeight=207&originWidth=370&size=0&status=done&style=stroke&width=370"></p><h3 id="关于链表的指向"><a href="#关于链表的指向" class="headerlink" title="关于链表的指向"></a>关于链表的指向</h3><blockquote><p>【1】何为指向？</p></blockquote><p>个人觉得链表的相关问题及操作就是理解链表的<strong>“指向”</strong>这么个概念，先明确以下几点</p><ul><li>每个节点的<strong>next</strong>用来存放<strong>下一个节点的“地址”</strong></li><li><strong>每个节点的自身就是地址</strong>，相当于 C 语言中数组的数组名就是本数组的地址</li></ul><blockquote><p>【2】谁指向谁？</p></blockquote><p><strong>总结：做题用下面总结的方法，绝对好使</strong><br><strong><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1616501415627-ee5d1008-a07d-4acb-821b-e227b5cb7ad8.jpeg#align=left&display=inline&height=59&margin=%5Bobject%20Object%5D&name=huaji1558a846ddf2e12b.jpeg&originHeight=59&originWidth=55&size=703&status=done&style=stroke&width=55" alt="huaji1558a846ddf2e12b.jpeg"></strong></p><ul><li><strong>读的时候：从左往右读，一般左边是某某的 next 域，右边是具体的结点</strong></li><li><strong>画的时候：在图中表示为等号左边指向等号右边</strong></li></ul><p>**<br>例子：<br>① <code>node.next = prev.next;</code><br>② <code>prev.next = node</code><br>读法：<br>①“node 的 next 指向 prev 的下一个结点”<br>（用指针的概念通俗地说，其实就是 prev 的下一个结点的地址由 prev 的指针域里面赋值给了 node 的 next 指针域里面）<br>②“prev 的 next 指向 node 这个结点”<br>（还可以这么说：将 node 赋值给 prev 的 next，也就是说 prev 的下一个结点是 node）<br>**</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1599309003706-ad779a14-1678-4d0c-86f2-b147752bd252.png#align=left&display=inline&height=204&margin=%5Bobject%20Object%5D&originHeight=594&originWidth=955&size=0&status=done&style=stroke&width=328"><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1599309003751-ffeee4d8-9662-416e-8f46-5cf5edf03114.png#align=left&display=inline&height=250&margin=%5Bobject%20Object%5D&originHeight=725&originWidth=938&size=0&status=done&style=stroke&width=324"><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1599309003658-46b3e7db-e6dc-4d13-baea-e7e44075e8bc.png#align=left&display=inline&height=221&margin=%5Bobject%20Object%5D&originHeight=626&originWidth=975&size=0&status=done&style=stroke&width=344"></p><blockquote><p>【3】指向错位？</p></blockquote><p><strong>关注第一个元素节点是不是 head，因为有的链表不声明头节点（head），直接就是第一个结点就是元素结点</strong></p><h3 id="关于-p-L-的理解"><a href="#关于-p-L-的理解" class="headerlink" title="关于 p=L 的理解"></a>关于 p=L 的理解</h3><p>写代码的时候，还经常遇到下面的情况<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616501697301-b63e6312-d8f9-4130-8d25-2d3becd75038.png#align=left&display=inline&height=53&margin=%5Bobject%20Object%5D&name=image.png&originHeight=106&originWidth=466&size=9439&status=done&style=none&width=233" alt="image.png"><br>p、L 就是指向结点的指针类型，将 L 的值赋给 p，也就是 p、L 指向同一个结点。具体理解可以用下面一个例子来说明：<br>下面图片这个函数就是在一个单链表中，功能就是指定 i 位置插入 e 值。下图箭头处如果 TraverseList 返回的是 p 那么得出的链表结果就是从插入的那个元素往后这样一个部分链表，返回的是 L 就是想要的结果，p 的功能有点类似在 L 的中间做了手脚……<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616501856348-955542eb-258d-473f-b003-c53881275937.png#align=left&display=inline&height=331&margin=%5Bobject%20Object%5D&name=image.png&originHeight=662&originWidth=740&size=62693&status=done&style=none&width=370" alt="image.png"></p><h2 id="各种代码"><a href="#各种代码" class="headerlink" title="各种代码"></a>各种代码</h2><h3 id="实验报告代码"><a href="#实验报告代码" class="headerlink" title="实验报告代码"></a>实验报告代码</h3><pre><code class="cpp">#include&lt;bits/stdc++.h&gt;using namespace std;typedef struct LNode &#123;    int data;    struct LNode *next;&#125;Lnode, *LinkList;LinkList L;void InitList(LinkList &amp;L) &#123;    L = new LNode;    L-&gt;next = NULL;&#125;void CreateList_H(LinkList &amp;L) &#123;    InitList(L);    int n;    cout &lt;&lt; &quot;请输入要使用前插法插入的元素个数：&quot;;    cin &gt;&gt; n;    for (int i = 0; i &lt; n; i++)&#123;        LNode *p = new LNode;        cin &gt;&gt; p-&gt;data;        p-&gt;next = L-&gt;next;        L-&gt;next = p;    &#125;&#125;void TraverseList(LinkList &amp;L)&#123;    LNode *p = new LNode;    p = L-&gt;next;    cout &lt;&lt; &quot;此链表打印的结果为：&quot;&lt;&lt;&quot;\n&quot;;    while (p != NULL)&#123;        cout &lt;&lt; p-&gt;data &lt;&lt; &quot; &quot;;        p = p-&gt;next;    &#125;    cout &lt;&lt; &quot;\n&quot;;&#125;void GetElem(LinkList &amp;L) &#123;    int n;    cout &lt;&lt; &quot;请输入要查询的链表中第i个数：&quot;;    cin &gt;&gt; n;    LNode *p = new LNode;    p = L;    for (int i = 0; i &lt; n;i++)&#123;        p = p-&gt;next;    &#125;    cout &lt;&lt; &quot;查询的结果为：&quot; &lt;&lt; p-&gt;data&lt;&lt;&quot;\n&quot;;&#125;void ListInsert(LinkList &amp;L)&#123;    LNode *p = new LNode;    p = L;    int n;    int e;    cout &lt;&lt; &quot;请分别输入要在第n个位置插入的e值：&quot;;    cin &gt;&gt; n&gt;&gt; e ;    for (int i = 0; i &lt; n;i++) &#123;        if (n == i+1)&#123;            LNode *temp = new LNode;            temp-&gt;data = e;            temp-&gt;next = p-&gt;next;            p-&gt;next = temp;            break;        &#125;        p = p-&gt;next;    &#125;    TraverseList(L); // 直接返回L就可以了，之前返回p是不可以的！！！唉，大意了~&#125;void ListDelete(LinkList &amp;L)&#123;    cout &lt;&lt; &quot;请输入要删除的第j个位置的j值：&quot;;    LNode *p = new LNode;    p = L;    int j;    cin &gt;&gt; j;    for (int i = 0; i &lt; j;i++) &#123;        if (j == i+1) &#123;            p-&gt;next = p-&gt;next-&gt;next;            break;        &#125;        p = p-&gt;next;    &#125;    TraverseList(L);&#125;void ReverseList(LinkList &amp;L) &#123;    LNode *p = L-&gt;next;    L-&gt;next = NULL;    while(p)    &#123;        LNode *q = p-&gt;next;        p-&gt;next = L-&gt;next;        L-&gt;next = p;        p = q;    &#125;    cout &lt;&lt; &quot;通过逆置之后……&quot;;    TraverseList(L);&#125;int main() &#123;    LNode *test = new LNode;    CreateList_H(test);//1    TraverseList(test);//1    GetElem(test);//2    ListInsert(test);//3    ListDelete(test);//4    ReverseList(test);//5&#125;</code></pre><h3 id="单链表各种操作代码总结"><a href="#单链表各种操作代码总结" class="headerlink" title="单链表各种操作代码总结"></a>单链表各种操作代码总结</h3><ul><li><input checked="" disabled="" type="checkbox"> 单链表存储形式</li></ul><pre><code class="cpp">typedef struct LNode &#123;    int data; //数据域    struct LNode *next; //指针域&#125;Lnode, *LinkList; //LinkList为指向结构体LNode的指针类型</code></pre><ul><li><input checked="" disabled="" type="checkbox"> 初始化</li><li><input checked="" disabled="" type="checkbox"> 创建：前插法</li><li><input checked="" disabled="" type="checkbox"> 创建：后插法</li><li><input checked="" disabled="" type="checkbox"> 取值</li><li><input checked="" disabled="" type="checkbox"> 插值</li><li><input checked="" disabled="" type="checkbox"> 删除</li><li><input checked="" disabled="" type="checkbox"> 打印</li><li><input checked="" disabled="" type="checkbox"> <strong>逆置</strong></li></ul><p>逆置多用前插的思想</p><pre><code class="cpp">void ReverseList(LinkList &amp;L) &#123;    LNode *p = L-&gt;next;    L-&gt;next = NULL;    while(p) &#123;        LinkList q = p-&gt;next;        p-&gt;next = L-&gt;next;        L-&gt;next = p;        p = q;    &#125;&#125;</code></pre><p>所有操作如下</p><pre><code class="cpp">#include&lt;bits/stdc++.h&gt;using namespace std;/** * 单链表 * * 链表的基本操作：初始化、创建（前插、后插）、取值、查找、插值、删除、打印、逆置 *//* 单链表的存储结构 */typedef struct LNode &#123;    int data; //数据域    struct LNode *next; //指针域&#125;Lnode, *LinkList; //LinkList为指向结构体LNode的指针类型/* 初始化链表 */void InitList(LinkList &amp;L) &#123;    L = new LNode;    L-&gt;next = NULL;&#125;/* 创建：前插 */void CreateList_H(LinkList &amp;L, int n) &#123;    InitList(L);    for (int i = 0; i &lt; n; i++)&#123;        LNode *p = new LNode;        cin &gt;&gt; p-&gt;data;        p-&gt;next = L-&gt;next;        L-&gt;next = p;    &#125;&#125;/* 创建：后插 */void CreateList_R(LinkList &amp;L, int n) &#123;    cout &lt;&lt; &quot;请输入&quot; &lt;&lt; n &lt;&lt; &quot;个数字&quot;&lt;&lt; &quot;\n&quot;;    InitList(L);    // 定义一个在下面循环用来一直操作所加元素的结点p来指向头结点L    LinkList p = L;    for (int i = 0; i &lt; n;i++) &#123;        LinkList q = new Lnode;        q-&gt;next = NULL;        cin &gt;&gt; q-&gt;data;        p-&gt;next = q;        p = q; //为了下一次    &#125;&#125;/* 取值 */void GetElem(LinkList &amp;L, int n) &#123;    LinkList p = L;    for (int i = 0; i &lt; n;i++)&#123;        p = p-&gt;next;    &#125;    cout &lt;&lt;n&lt;&lt;&quot;的值为：&quot; &lt;&lt; p-&gt;data&lt;&lt;&quot;\n&quot;&lt;&lt;&quot;\n&quot;;&#125;/* 查找 */void SearchElem(LinkList &amp;L, int ele) &#123;    LinkList p = L;    int count = 0;    while (p-&gt;data != ele) &#123;        p = p-&gt;next;        count++;    &#125;    cout &lt;&lt;ele&lt;&lt;&quot;这个值的索引位置是：&quot;&lt;&lt; count&lt;&lt;&quot;\n&quot;;&#125;/* 插值：在第n个位置插入ele值*/void ListInsert(LinkList &amp;L, int n, int ele)&#123;    LinkList p = L;    for (int i = 0; i &lt; n;i++) &#123;        if (n == i+1)&#123;            LinkList temp = new LNode;            temp-&gt;data = ele;            temp-&gt;next = p-&gt;next;            p-&gt;next = temp;            break;        &#125;        p = p-&gt;next;    &#125;    TraverseList(L);&#125;/* 删除：删除第j个位置的值 */void ListDelete(LinkList &amp;L, int j)&#123;    LinkList p = L;    for (int i = 0; i &lt; j;i++) &#123;        if (j == i+1) &#123;            p-&gt;next = p-&gt;next-&gt;next;            break;        &#125;        p = p-&gt;next;    &#125;    TraverseList(L);&#125;/* 打印 */void TraverseList(LinkList &amp; L)&#123;        LNode *p = new LNode;        p = L-&gt;next;        cout &lt;&lt; &quot;此链表打印的结果为：&quot;             &lt;&lt; &quot;\n&quot;;        while (p != NULL)        &#123;            cout &lt;&lt; p-&gt;data &lt;&lt; &quot; &quot;;            p = p-&gt;next;        &#125;        cout &lt;&lt; &quot;\n&quot;;&#125;/* 逆置 */void ReverseList(LinkList &amp;L) &#123;    LNode *p = L-&gt;next;    L-&gt;next = NULL;    while(p)    &#123;        LNode *q = p-&gt;next;        p-&gt;next = L-&gt;next;        L-&gt;next = p;        p = q;    &#125;    cout &lt;&lt; &quot;通过逆置之后……&quot;;    TraverseList(L);&#125;int main() &#123;    // LNode *test = new LNode;    LinkList test;    // struct LNode *test;    CreateList_R(test,4);    SearchElem(test, 3);    // cout &lt;&lt; GetEle(test, 2);    // TraverseList(test);    // GetElem(test,2);    // ListInsert(test);    // ListDelete(test);    // ReverseList(test);&#125;</code></pre><h3 id="循环链表代码"><a href="#循环链表代码" class="headerlink" title="循环链表代码"></a>循环链表代码</h3><p>* 循环链表其实只需要注意最后一个结点所指向的下一个结点为头结点 L 就好了</p><ul><li>还要注意头结点存不存元素</li><li>还有判断的时候条件不是单链表那样判断是否为空了，而是是否为头结点的值了</li></ul><pre><code class="cpp">#include&lt;bits/stdc++.h&gt;using namespace std;/** * 循环链表 * * 循环链表其实只需要注意最后一个结点所指向的下一个结点为头结点L就好了 * 还要注意头结点存不存元素 * 还有判断的时候条件不是单链表那样判断是否为空了，而是是否为头结点的值了 *//* 定义一个单链表 */typedef struct LNode &#123;    int data;    struct LNode *next;&#125;Lnode, *LinkList;/** * 初始化单链表 */void InitList(LinkList &amp;L) &#123;    L = new LNode;    L-&gt;next = NULL;&#125;/** * 初始化单链表并将其变成循环链表 */void CircleList(LinkList &amp;L, int n) &#123;    InitList(L);    // 初始化第一个结点的值    L-&gt;data = 1;    LinkList p = L;    for (int i = 2; i &lt;= n; i++) &#123;        LinkList temp = new Lnode;        temp-&gt;data = i;        if (i == n) &#123;            temp-&gt;next = L;            p-&gt;next = temp;            break;        &#125;        temp-&gt;next = NULL;        p-&gt;next = temp;        p = p-&gt;next;    &#125;&#125;/** * 打印输出用来测试是否为循环链表 */void PrintList(LinkList &amp;L, int n) &#123;    LinkList p = L;    for (int i = 0; i &lt; n;i++) &#123;        cout &lt;&lt; p-&gt;data &lt;&lt; &quot; &quot;;        p = p-&gt;next;    &#125;&#125;int main() &#123;    LinkList test;    CircleList(test,5);    PrintList(test, 12);&#125;</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1618307254729-8f60bc5d-be41-47fe-a2ad-466715cc740e.png#align=left&display=inline&height=45&margin=%5Bobject%20Object%5D&name=image.png&originHeight=90&originWidth=596&size=22406&status=done&style=none&width=298" alt="image.png"></p><h3 id="双向链表代码"><a href="#双向链表代码" class="headerlink" title="双向链表代码"></a>双向链表代码</h3><ul><li>双向链表从某种意义上来说，更加简单了，因为可操作的“指向更多了”，但正因为这样，所以每次指向操作之后，检查一下有没有“落单的指向”</li><li>删除某个结点的时候，一定要记得删除哪个结点，就操作哪个结点</li></ul><pre><code class="cpp">#include&lt;bits/stdc++.h&gt;using namespace std;/** * 双向链表 *//* 双向链表的存储结构 */typedef struct DuLNode &#123;    int data;    struct DuLNode *prior;    struct DuLNode *next;&#125;DuLnode, *DuLinkList;/* 双向链表的初始化 */void InitDuLinkList(DuLinkList &amp;L) &#123;    L = new DuLNode;    L-&gt;prior = NULL;    L-&gt;next = NULL;&#125;int main() &#123;    DuLinkList L;    InitDuLinkList(L);    // 初始化初始节点值为100    L-&gt;data = 100;    // 在L结点前面插值50    DuLinkList L_prior;    L_prior-&gt;data = 50;    L_prior-&gt;next = L;    L-&gt;prior = NULL;    L-&gt;prior = L_prior;    // 在L结点后面插值150    DuLinkList L_next;    L_next-&gt;data = 150;    L_next-&gt;prior = L;    L_next-&gt;next = NULL;    L-&gt;next = L_next;    cout &lt;&lt; L_prior-&gt;data &lt;&lt; &quot; &quot; &lt;&lt; L_prior-&gt;next-&gt;data &lt;&lt; &quot; &quot; &lt;&lt; L_prior-&gt;next-&gt;next-&gt;data&lt;&lt;&quot;\n&quot;;    // 在50和100之间插值75（只操作L结点）    DuLinkList L_prior_L;    L_prior_L-&gt;data = 75;    L_prior_L-&gt;prior = L-&gt;prior;    L-&gt;prior-&gt;next = L_prior_L;    L_prior_L-&gt;next = L;    L-&gt;prior = L_prior_L;    cout &lt;&lt; L-&gt;prior-&gt;prior-&gt;data &lt;&lt; &quot; &quot; &lt;&lt; L-&gt;prior-&gt;data &lt;&lt; &quot; &quot; &lt;&lt; L-&gt;data &lt;&lt;&quot; &quot;&lt;&lt; L-&gt;next-&gt;data&lt;&lt;&quot;\n&quot;;    // 删除75这个值的结点(记住一点，删除哪个结点就操作哪个结点)    L_prior_L-&gt;next-&gt;prior = L_prior_L-&gt;prior;    L_prior_L-&gt;prior-&gt;next = L_prior_L-&gt;next;    cout &lt;&lt; L-&gt;prior-&gt;data &lt;&lt; &quot; &quot; &lt;&lt; L-&gt;data &lt;&lt; &quot; &quot; &lt;&lt; L-&gt;next-&gt;data &lt;&lt; &quot;\n&quot;;&#125;</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1618309282126-1ad3d5c4-1d3e-425f-b474-27f33261ead6.png#align=left&display=inline&height=92&margin=%5Bobject%20Object%5D&name=image.png&originHeight=183&originWidth=526&size=39489&status=done&style=none&width=263" alt="image.png"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="http://shangdixinxi.com/detail-1507915.html">链表 p-&gt;next=q-&gt;next,q-&gt;next=p,q=p;的一些解释</a></li><li><a href="https://blog.csdn.net/weixin_44135282/article/details/90348885">p-&gt;next=q 与 q=p-&gt;next 区分</a></li><li><a href="https://www.jianshu.com/p/73d56c3d228c">数据结构：链表</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 📶线结构：字符串-数组-栈-队列 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>DOM事件</title>
      <link href="/blog/wgzidzz85o76/"/>
      <url>/blog/wgzidzz85o76/</url>
      
        <content type="html"><![CDATA[<h2 id="事件（低阶）"><a href="#事件（低阶）" class="headerlink" title="事件（低阶）"></a>事件（低阶）</h2><blockquote><p>事件三要素</p></blockquote><ul><li>Who(事件源)：触发事件的元素</li><li>What(事件类型)： eg 绑定 click 点击事件</li><li>How(事件处理程序)：事件触发后要执行的代码(函数赋值形式)，事件处理函数**</li></ul><h3 id="常见鼠标事件"><a href="#常见鼠标事件" class="headerlink" title="常见鼠标事件"></a>常见鼠标事件</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518355975-babb3ede-4626-4ccd-9507-eb4c35c58439.png#align=left&display=inline&height=318&margin=%5Bobject%20Object%5D&originHeight=318&originWidth=714&status=done&style=stroke&width=714"></p><h3 id="addEventListener"><a href="#addEventListener" class="headerlink" title="addEventListener()"></a>addEventListener()</h3><blockquote><p>事件监听（IE9 以后支持）</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518360715-05c708e0-db51-4791-b3cc-14ca89b6d9bc.png#align=left&display=inline&height=61&margin=%5Bobject%20Object%5D&originHeight=61&originWidth=707&status=done&style=none&width=707"><br>eventTarget.addEventListener()方法将指定的监听器注册到 eventTarget（目标对象）上，当该对象触发指定的事件时，就会执行事件处理函数。</p><ul><li>type：监听事件类型 click……（不要加 on，要记得加引号）</li><li>listener：监听函数（触发之后进行什么样的行为（函数））</li><li>useCapture：默认 false</li></ul><pre><code class="javascript">var class_down = document.getElementsByClassName(&quot;entry-thumb&quot;);var over_img_back_index = class_down[0].getElementsByTagName(&quot;img&quot;);over_img_back_index[0].addEventListener(&quot;mouseover&quot;, function () &#123;  alert(&quot;鼠标经过左侧图片，触发至即将跳转到首页&quot;);  location.href = &quot;https://www.wztlink1013.com&quot;;&#125;);</code></pre><h3 id="attachEvent"><a href="#attachEvent" class="headerlink" title="attachEvent()"></a>attachEvent()</h3><blockquote><p>事件监听（IE678 支持）</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518360822-32bdd41a-9d13-4b76-93db-3f503b39bba7.png#align=left&display=inline&height=52&margin=%5Bobject%20Object%5D&originHeight=52&originWidth=696&status=done&style=none&width=696"></p><ul><li>和 addEventListener()功能一样，不过这是老版本只带两个参数，而且第一个参数要加 on</li></ul><h3 id="兼容性解决注册事件"><a href="#兼容性解决注册事件" class="headerlink" title="兼容性解决注册事件"></a>兼容性解决注册事件</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518360652-874303ea-a903-4f8c-93a0-a90c193c661b.png#align=left&display=inline&height=361&margin=%5Bobject%20Object%5D&originHeight=361&originWidth=867&status=done&style=stroke&width=867"><br>封装一个函数，函数中判断浏览器的类型：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518360935-9054e419-704a-402e-969c-a572f0f322e0.png#align=left&display=inline&height=266&margin=%5Bobject%20Object%5D&originHeight=266&originWidth=643&status=done&style=none&width=643"></p><h3 id="解绑事件"><a href="#解绑事件" class="headerlink" title="解绑事件"></a>解绑事件</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518360992-53947cad-916b-4b2a-baf9-0587c30a33d9.png#align=left&display=inline&height=241&margin=%5Bobject%20Object%5D&originHeight=241&originWidth=737&status=done&style=stroke&width=737"></p><pre><code class="html">&lt;div&gt;1&lt;/div&gt;&lt;div&gt;2&lt;/div&gt;&lt;div&gt;3&lt;/div&gt;&lt;script&gt;  var divs = document.querySelectorAll(&quot;div&quot;);  divs[0].onclick = function () &#123;    alert(11);    // 1. 传统方式删除事件    divs[0].onclick = null;  &#125;;  // 2. removeEventListener 删除事件  divs[1].addEventListener(&quot;click&quot;, fn); // 里面的fn 不需要调用加小括号  function fn() &#123;    alert(22);    divs[1].removeEventListener(&quot;click&quot;, fn);  &#125;  // 3. detachEvent  divs[2].attachEvent(&quot;onclick&quot;, fn1);  function fn1() &#123;    alert(33);    divs[2].detachEvent(&quot;onclick&quot;, fn1);  &#125;&lt;/script&gt;</code></pre><blockquote><p>**删除事件兼容性解决方案 **</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518361056-6ce22708-00af-43e8-943d-466fe8fcb053.png#align=left&display=inline&height=269&margin=%5Bobject%20Object%5D&originHeight=269&originWidth=713&status=done&style=none&width=713"></p><h2 id="常用鼠标事件"><a href="#常用鼠标事件" class="headerlink" title="常用鼠标事件"></a>常用鼠标事件</h2><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518361860-3dea106f-9140-4836-8e7d-2f160b94435b.png#align=left&display=inline&height=305&margin=%5Bobject%20Object%5D&originHeight=305&originWidth=683&status=done&style=stroke&width=683"></p><h3 id="Demo：禁止选中文字和禁止右键菜单"><a href="#Demo：禁止选中文字和禁止右键菜单" class="headerlink" title="Demo：禁止选中文字和禁止右键菜单"></a>Demo：禁止选中文字和禁止右键菜单</h3><blockquote><p>【1】禁止鼠标选中</p></blockquote><ul><li>selectstart 开始选中</li></ul><pre><code class="javascript">document.addEventListener(&quot;selectstart&quot;, function (e) &#123;  e.preventDefault();&#125;);</code></pre><blockquote><p>【2】禁止鼠标右键菜单</p></blockquote><ul><li>contextmenu 主要控制应该合适显示上下文菜单，主要用于程序员取消默认的上下文菜单</li></ul><pre><code class="javascript">document.addEventListener(&quot;contextmenu&quot;, function (e) &#123;  e.preventDefault();&#125;);</code></pre><h3 id="鼠标事件对象"><a href="#鼠标事件对象" class="headerlink" title="鼠标事件对象"></a>鼠标事件对象</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518361978-034f2af6-14fa-4ddb-bd8b-2eabe289eb59.png#align=left&display=inline&height=308&margin=%5Bobject%20Object%5D&originHeight=308&originWidth=703&status=done&style=stroke&width=703"></p><h3 id="Demo：获取鼠标在页面的坐标"><a href="#Demo：获取鼠标在页面的坐标" class="headerlink" title="Demo：获取鼠标在页面的坐标"></a>Demo：获取鼠标在页面的坐标</h3><pre><code class="html">&lt;script&gt;  // 鼠标事件对象 MouseEvent  document.addEventListener(&quot;click&quot;, function (e) &#123;    console.log(&quot;client 鼠标在可视区的x和y坐标&quot;);    console.log(e.clientX);    console.log(e.clientY);    console.log(&quot;---------------------&quot;);    console.log(&quot;page 鼠标在页面文档的x和y坐标&quot;);    console.log(e.pageX);    console.log(e.pageY);    console.log(&quot;---------------------&quot;);    console.log(&quot;screen 鼠标在电脑屏幕的x和y坐标&quot;);    console.log(e.screenX);    console.log(e.screenY);  &#125;);&lt;/script&gt;</code></pre><h3 id="Demo：跟随鼠标的天使"><a href="#Demo：跟随鼠标的天使" class="headerlink" title="Demo：跟随鼠标的天使"></a>Demo：跟随鼠标的天使</h3><pre><code class="html">&lt;img src=&quot;images/angel.gif&quot; alt=&quot;&quot; /&gt;&lt;script&gt;  var pic = document.querySelector(&quot;img&quot;);  document.addEventListener(&quot;mousemove&quot;, function (e) &#123;    // 1. mousemove只要我们鼠标移动1px 就会触发这个事件    // 2.核心原理： 每次鼠标移动，我们都会获得最新的鼠标坐标，    // 把这个x和y坐标做为图片的top和left 值就可以移动图片    var x = e.pageX;    var y = e.pageY;    console.log(&quot;x坐标是&quot; + x, &quot;y坐标是&quot; + y);    //3 . 千万不要忘记给left 和top 添加px 单位    pic.style.left = x - 50 + &quot;px&quot;;    pic.style.top = y - 40 + &quot;px&quot;;  &#125;);&lt;/script&gt;</code></pre><h3 id="mouseenter-和-mouseover-的区别"><a href="#mouseenter-和-mouseover-的区别" class="headerlink" title="mouseenter 和 mouseover 的区别"></a>mouseenter 和 mouseover 的区别</h3><ul><li>当鼠标移动到元素上时就会触发 mouseenter 事件</li><li>类似 mouseover，它们两者之间的差别是</li><li>mouseover 鼠标经过自身盒子会触发，经过子盒子还会触发。mouseenter  只会经过自身盒子触发</li><li>之所以这样，就是因为 mouseenter 不会冒泡</li><li>跟 mouseenter 搭配鼠标离开 mouseleave  同样不会冒泡</li></ul><h2 id="常用键盘事件"><a href="#常用键盘事件" class="headerlink" title="常用键盘事件"></a>常用键盘事件</h2><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518362322-f21797ca-1e8e-4702-a243-4e76a8458b7e.png#align=left&display=inline&height=143&margin=%5Bobject%20Object%5D&originHeight=143&originWidth=701&status=done&style=stroke&width=701"></p><ul><li>三个事件执行的顺序是：keydown-&gt;keypress-&gt;keyup</li></ul><pre><code class="html">&lt;script&gt;  // 常用的键盘事件  //1. keyup 按键弹起的时候触发  document.addEventListener(&quot;keyup&quot;, function () &#123;    console.log(&quot;我弹起了&quot;);  &#125;);  //3. keypress 按键按下的时候触发  不能识别功能键 比如 ctrl shift 左右箭头啊  document.addEventListener(&quot;keypress&quot;, function () &#123;    console.log(&quot;我按下了press&quot;);  &#125;);  //2. keydown 按键按下的时候触发  能识别功能键 比如 ctrl shift 左右箭头啊  document.addEventListener(&quot;keydown&quot;, function () &#123;    console.log(&quot;我按下了down&quot;);  &#125;);  // 4. 三个事件的执行顺序  keydown -- keypress -- keyup&lt;/script&gt;</code></pre><h3 id="键盘事件对象"><a href="#键盘事件对象" class="headerlink" title="键盘事件对象"></a>键盘事件对象</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518362443-95c05d9c-6850-4cc3-a35e-c972b1723658.png#align=left&display=inline&height=78&margin=%5Bobject%20Object%5D&originHeight=78&originWidth=700&status=done&style=stroke&width=700"></p><ul><li>onkeydown 和 onkeyup 不区分字母大小写，onkeypress 区分字母大小写（使用更多的前面两个，能够识别所有键，包括功能键）</li><li>keypress 不识别功能键，但是 keyCode 属性能够区分大小写，返回不同的 ASCII 值<blockquote><p><strong>使用 keyCode 属性判断用户按下哪个键</strong></p></blockquote></li></ul><pre><code class="html">&lt;script&gt;  // 键盘事件对象中的keyCode属性可以得到相应键的ASCII码值  document.addEventListener(&quot;keyup&quot;, function (e) &#123;    console.log(&quot;up:&quot; + e.keyCode);    // 我们可以利用keycode返回的ASCII码值来判断用户按下了那个键    if (e.keyCode === 65) &#123;      alert(&quot;您按下的a键&quot;);    &#125; else &#123;      alert(&quot;您没有按下a键&quot;);    &#125;  &#125;);  document.addEventListener(&quot;keypress&quot;, function (e) &#123;    // console.log(e);    console.log(&quot;press:&quot; + e.keyCode);  &#125;);&lt;/script&gt;</code></pre><h3 id="Demo：模拟京东按键输入内容"><a href="#Demo：模拟京东按键输入内容" class="headerlink" title="Demo：模拟京东按键输入内容"></a>Demo：模拟京东按键输入内容</h3><ul><li>当我们按下 s 键， 光标就定位到搜索框（文本框获得焦点）。</li><li>注意：触发获得焦点事件，可以使用 元素对象.focus()</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616211826182-452dfe9b-0c03-4fe3-845c-afc16697e3ee.png#align=left&display=inline&height=442&margin=%5Bobject%20Object%5D&name=image.png&originHeight=883&originWidth=1920&size=1657927&status=done&style=stroke&width=960" alt="image.png"></p><h3 id="Demo：模拟京东快递单号查询"><a href="#Demo：模拟京东快递单号查询" class="headerlink" title="Demo：模拟京东快递单号查询"></a>Demo：模拟京东快递单号查询</h3><p>要求：当我们在文本框中输入内容时，文本框上面自动显示大字号的内容。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518362646-5b0c1da3-32dd-40b4-8b42-1bbb3065c01c.png#align=left&display=inline&height=259&margin=%5Bobject%20Object%5D&originHeight=259&originWidth=551&status=done&style=stroke&width=551"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518362734-9740cabb-bd4d-48ce-824d-001b5913b804.png#align=left&display=inline&height=288&margin=%5Bobject%20Object%5D&originHeight=288&originWidth=751&status=done&style=none&width=751"></p><pre><code class="js">&lt;div class=&quot;search&quot;&gt;        &lt;div class=&quot;con&quot;&gt;123&lt;/div&gt;        &lt;input type=&quot;text&quot; placeholder=&quot;请输入您的快递单号&quot; class=&quot;jd&quot;&gt;    &lt;/div&gt;    &lt;script&gt;        // 获取要操作的元素        var con = document.querySelector(&#39;.con&#39;);        var jd_input = document.querySelector(&#39;.jd&#39;);        // 给输入框注册keyup事件        jd_input.addEventListener(&#39;keyup&#39;, function() &#123;                // 判断输入框内容是否为空                if (this.value == &#39;&#39;) &#123;                    // 为空，隐藏放大提示盒子                    con.style.display = &#39;none&#39;;                &#125; else &#123;                    // 不为空，显示放大提示盒子，设置盒子的内容                    con.style.display = &#39;block&#39;;                    con.innerText = this.value;                &#125;            &#125;)        // 给输入框注册失去焦点事件，隐藏放大提示盒子        jd_input.addEventListener(&#39;blur&#39;, function() &#123;                con.style.display = &#39;none&#39;;            &#125;)        // 给输入框注册获得焦点事件        jd_input.addEventListener(&#39;focus&#39;, function() &#123;            // 判断输入框内容是否为空            if (this.value !== &#39;&#39;) &#123;                // 不为空则显示提示盒子                con.style.display = &#39;block&#39;;            &#125;        &#125;)    &lt;/script&gt;</code></pre><h2 id="事件（高阶）"><a href="#事件（高阶）" class="headerlink" title="事件（高阶）"></a>事件（高阶）</h2><h3 id="DOM-事件流"><a href="#DOM-事件流" class="headerlink" title="DOM 事件流"></a>DOM 事件流</h3><pre><code>html中的标签都是相互嵌套的，我们可以将元素想象成一个盒子装一个盒子，document是最外面的大盒子。当你单击一个div时，同时你也单击了div的父元素，甚至整个页面。那么是先执行父元素的单击事件，还是先执行div的单击事件 ？？？</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518361114-2ab6ad14-e27a-4626-88bd-abbc2badfc0b.png#align=left&display=inline&height=70&margin=%5Bobject%20Object%5D&originHeight=70&originWidth=696&status=done&style=stroke&width=696"></p><blockquote><p>比如：我们给页面中的一个 div 注册了单击事件，当你单击了 div 时，也就单击了 body，单击了 html，单击了 document。</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518361173-9a6bf5d3-a273-4294-b849-0ebaf79da603.png#align=left&display=inline&height=196&margin=%5Bobject%20Object%5D&originHeight=196&originWidth=268&status=done&style=none&width=268"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518361248-0ea0959b-c350-4780-9437-8561fe69f36d.png#align=left&display=inline&height=72&margin=%5Bobject%20Object%5D&originHeight=72&originWidth=751&status=done&style=none&width=751"></p><pre><code>当时的2大浏览器霸主谁也不服谁！IE 提出从目标元素开始，然后一层一层向外接收事件并响应，也就是冒泡型事件流。Netscape（网景公司）提出从最外层开始，然后一层一层向内接收事件并响应，也就是捕获型事件流。江湖纷争，武林盟主也脑壳疼！！！最终，w3c 采用折中的方式，平息了战火，制定了统一的标准 —--— 先捕获再冒泡。现代浏览器都遵循了此标准，所以当事件发生时，会经历3个阶段。</code></pre><p>DOM 事件流会经历 3 个阶段：</p><ol><li><p> 捕获阶段</p></li><li><p> 当前目标阶段</p></li><li><p>冒泡阶段</p><pre><code> 我们向水里面扔一块石头，首先它会有一个下降的过程，这个过程就可以理解为从最顶层向事件发生的最具体元素（目标点）的捕获过程；之后会产生泡泡，会在最低点（ 最具体元素）之后漂浮到水面上，这个过程相当于事件冒泡。</code></pre><p> <img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518361302-fa0b37f5-a8ec-4898-82b6-e136cd291951.png#align=left&display=inline&height=271&margin=%5Bobject%20Object%5D&originHeight=271&originWidth=498&status=done&style=none&width=498"><br> <img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518361362-b8b1f065-da6a-40c5-8782-b265699cdd49.png#align=left&display=inline&height=370&margin=%5Bobject%20Object%5D&originHeight=370&originWidth=757&status=done&style=none&width=757"><br> <strong>事件冒泡</strong></p></li></ol><pre><code class="js">&lt;div class=&quot;father&quot;&gt;        &lt;div class=&quot;son&quot;&gt;son盒子&lt;/div&gt;    &lt;/div&gt;    &lt;script&gt;        // onclick 和 attachEvent（ie） 在冒泡阶段触发        // 冒泡阶段 如果addEventListener 第三个参数是 false 或者 省略        // son -&gt; father -&gt;body -&gt; html -&gt; document        var son = document.querySelector(&#39;.son&#39;);        // 给son注册单击事件        son.addEventListener(&#39;click&#39;, function() &#123;            alert(&#39;son&#39;);        &#125;, false);        // 给father注册单击事件        var father = document.querySelector(&#39;.father&#39;);        father.addEventListener(&#39;click&#39;, function() &#123;            alert(&#39;father&#39;);        &#125;, false);        // 给document注册单击事件，省略第3个参数        document.addEventListener(&#39;click&#39;, function() &#123;            alert(&#39;document&#39;);        &#125;)    &lt;/script&gt;</code></pre><p><strong>事件捕获</strong></p><pre><code class="js">&lt;div class=&quot;father&quot;&gt;        &lt;div class=&quot;son&quot;&gt;son盒子&lt;/div&gt;    &lt;/div&gt;    &lt;script&gt;        // 如果addEventListener() 第三个参数是 true 那么在捕获阶段触发        // document -&gt; html -&gt; body -&gt; father -&gt; son         var son = document.querySelector(&#39;.son&#39;);        // 给son注册单击事件，第3个参数为true         son.addEventListener(&#39;click&#39;, function() &#123;             alert(&#39;son&#39;);         &#125;, true);         var father = document.querySelector(&#39;.father&#39;);        // 给father注册单击事件，第3个参数为true         father.addEventListener(&#39;click&#39;, function() &#123;             alert(&#39;father&#39;);         &#125;, true);        // 给document注册单击事件，第3个参数为true        document.addEventListener(&#39;click&#39;, function() &#123;            alert(&#39;document&#39;);        &#125;, true)    &lt;/script&gt;</code></pre><h3 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h3><h4 id="什么是事件对象"><a href="#什么是事件对象" class="headerlink" title="什么是事件对象"></a>什么是事件对象</h4><p>事件发生后，跟事件相关的一系列信息数据的集合都放到这个对象里面，这个对象就是事件对象。<br>比如：</p><ol><li>谁绑定了这个事件。</li><li>鼠标触发事件的话，会得到鼠标的相关信息，如鼠标位置。</li><li>键盘触发事件的话，会得到键盘的相关信息，如按了哪个键。</li></ol><h4 id="事件对象的使用"><a href="#事件对象的使用" class="headerlink" title="事件对象的使用"></a>事件对象的使用</h4><p>事件触发发生时就会产生事件对象，并且系统会以实参的形式传给事件处理函数。<br>所以，在事件处理函数中声明 1 个形参用来接收事件对象。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518361420-28ca3202-57b2-48ab-83cb-620191320123.png#align=left&display=inline&height=259&margin=%5Bobject%20Object%5D&originHeight=259&originWidth=681&status=done&style=none&width=681"></p><h4 id="事件对象的兼容性处理"><a href="#事件对象的兼容性处理" class="headerlink" title="事件对象的兼容性处理"></a>事件对象的兼容性处理</h4><p>事件对象本身的获取存在兼容问题：</p><ol><li>标准浏览器中是浏览器给方法传递的参数，只需要定义形参 e 就可以获取到。</li><li>在 IE6~8 中，浏览器不会给方法传递参数，如果需要的话，需要到 window.event 中获取查找。</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518361484-fb99b58d-4733-4716-b625-a14e1cd02938.png#align=left&display=inline&height=71&margin=%5Bobject%20Object%5D&originHeight=71&originWidth=660&status=done&style=none&width=660"></p><pre><code>只要“||”前面为false, 不管“||”后面是true 还是 false，都返回 “||” 后面的值。只要“||”前面为true, 不管“||”后面是true 还是 false，都返回 “||” 前面的值。</code></pre><pre><code class="js">&lt;div&gt;123&lt;/div&gt;    &lt;script&gt;        var div = document.querySelector(&#39;div&#39;);        div.onclick = function(e) &#123;                // 事件对象                e = e || window.event;                console.log(e);        &#125;    &lt;/script&gt;</code></pre><h4 id="事件对象的属性和方法"><a href="#事件对象的属性和方法" class="headerlink" title="事件对象的属性和方法"></a>事件对象的属性和方法</h4><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518361541-14665361-d721-4083-8cb2-d2088c6dc0cc.png#align=left&display=inline&height=273&margin=%5Bobject%20Object%5D&originHeight=273&originWidth=698&status=done&style=none&width=698"></p><h4 id="e-target-和-this-的区别"><a href="#e-target-和-this-的区别" class="headerlink" title="e.target 和 this 的区别"></a>e.target 和 this 的区别</h4><ul><li>this 是事件绑定的元素（绑定这个事件处理函数的元素） 。</li><li>e.target 是事件触发的元素。</li></ul><pre><code>常情况下terget 和 this是一致的，但有一种情况不同，那就是在事件冒泡时（父子元素有相同事件，单击子元素，父元素的事件处理函数也会被触发执行），    这时候this指向的是父元素，因为它是绑定事件的元素对象，    而target指向的是子元素，因为他是触发事件的那个具体元素对象。</code></pre><pre><code class="js">&lt;div&gt;123&lt;/div&gt;    &lt;script&gt;        var div = document.querySelector(&#39;div&#39;);        div.addEventListener(&#39;click&#39;, function(e) &#123;            // e.target 和 this指向的都是div            console.log(e.target);            console.log(this);        &#125;);    &lt;/script&gt;</code></pre><p>事件冒泡下的 e.target 和 this</p><pre><code class="js">&lt;ul&gt;        &lt;li&gt;abc&lt;/li&gt;        &lt;li&gt;abc&lt;/li&gt;        &lt;li&gt;abc&lt;/li&gt;    &lt;/ul&gt;    &lt;script&gt;        var ul = document.querySelector(&#39;ul&#39;);        ul.addEventListener(&#39;click&#39;, function(e) &#123;              // 我们给ul 绑定了事件  那么this 就指向ul              console.log(this); // ul              // e.target 触发了事件的对象 我们点击的是li e.target 指向的就是li              console.log(e.target); // li        &#125;);    &lt;/script&gt;</code></pre><h3 id="阻止默认行为"><a href="#阻止默认行为" class="headerlink" title="阻止默认行为"></a>阻止默认行为</h3><blockquote><p>html 中一些标签有默认行为，例如 a 标签被单击后，默认会进行页面跳转。</p></blockquote><pre><code class="js">&lt;a href=&quot;http://www.baidu.com&quot;&gt;百度&lt;/a&gt;    &lt;script&gt;        // 2. 阻止默认行为 让链接不跳转        var a = document.querySelector(&#39;a&#39;);        a.addEventListener(&#39;click&#39;, function(e) &#123;             e.preventDefault(); //  dom 标准写法        &#125;);        // 3. 传统的注册方式        a.onclick = function(e) &#123;            // 普通浏览器 e.preventDefault();  方法            e.preventDefault();            // 低版本浏览器 ie678  returnValue  属性            e.returnValue = false;            // 我们可以利用return false 也能阻止默认行为 没有兼容性问题            return false;        &#125;    &lt;/script&gt;</code></pre><h3 id="阻止事件冒泡"><a href="#阻止事件冒泡" class="headerlink" title="阻止事件冒泡"></a>阻止事件冒泡</h3><p>事件冒泡本身的特性，会带来的坏处，也会带来的好处。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518361625-d482ad01-1332-4d91-b951-664b337c86f3.png#align=left&display=inline&height=182&margin=%5Bobject%20Object%5D&originHeight=182&originWidth=667&status=done&style=none&width=667"></p><pre><code class="js">&lt;div class=&quot;father&quot;&gt;        &lt;div class=&quot;son&quot;&gt;son儿子&lt;/div&gt;    &lt;/div&gt;    &lt;script&gt;        var son = document.querySelector(&#39;.son&#39;);        // 给son注册单击事件        son.addEventListener(&#39;click&#39;, function(e) &#123;            alert(&#39;son&#39;);            e.stopPropagation(); // stop 停止  Propagation 传播            window.event.cancelBubble = true; // 非标准 cancel 取消 bubble 泡泡        &#125;, false);        var father = document.querySelector(&#39;.father&#39;);        // 给father注册单击事件        father.addEventListener(&#39;click&#39;, function() &#123;            alert(&#39;father&#39;);        &#125;, false);        // 给document注册单击事件        document.addEventListener(&#39;click&#39;, function() &#123;            alert(&#39;document&#39;);        &#125;)    &lt;/script&gt;</code></pre><p><strong>阻止事件冒泡的兼容性处理</strong><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518361680-f20195f2-69b6-4d72-a6d5-6a5d08646b73.png#align=left&display=inline&height=167&margin=%5Bobject%20Object%5D&originHeight=167&originWidth=685&status=done&style=none&width=685"></p><h3 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h3><p>事件冒泡本身的特性，会带来的坏处，也会带来的好处。</p><h4 id="什么是事件委托"><a href="#什么是事件委托" class="headerlink" title="什么是事件委托"></a>什么是事件委托</h4><pre><code>把事情委托给别人，代为处理。</code></pre><p>事件委托也称为事件代理，在 jQuery 里面称为事件委派。</p><blockquote><p>说白了就是，不给子元素注册事件，给父元素注册事件，把处理代码在父元素的事件中执行。</p></blockquote><p><strong>生活中的代理：</strong><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518361736-9861e13e-f31a-4425-b062-883b21374fce.png#align=left&display=inline&height=159&margin=%5Bobject%20Object%5D&originHeight=159&originWidth=689&status=done&style=none&width=689"><br><strong>js 事件中的代理：</strong><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518361805-81024b8b-f5e4-488a-91fa-d8ffa16d04fa.png#align=left&display=inline&height=278&margin=%5Bobject%20Object%5D&originHeight=278&originWidth=698&status=done&style=none&width=698"></p><h4 id="事件委托的原理"><a href="#事件委托的原理" class="headerlink" title="事件委托的原理"></a>事件委托的原理</h4><pre><code>给父元素注册事件，利用事件冒泡，当子元素的事件触发，会冒泡到父元素，然后去控制相应的子元素。</code></pre><h4 id="事件委托的作用"><a href="#事件委托的作用" class="headerlink" title="事件委托的作用"></a>事件委托的作用</h4><ul><li>我们只操作了一次 DOM ，提高了程序的性能。</li><li>动态新创建的子元素，也拥有事件。</li></ul><pre><code class="js">&lt;ul&gt;        &lt;li&gt;知否知否，点我应有弹框在手！&lt;/li&gt;        &lt;li&gt;知否知否，点我应有弹框在手！&lt;/li&gt;        &lt;li&gt;知否知否，点我应有弹框在手！&lt;/li&gt;        &lt;li&gt;知否知否，点我应有弹框在手！&lt;/li&gt;        &lt;li&gt;知否知否，点我应有弹框在手！&lt;/li&gt;    &lt;/ul&gt;    &lt;script&gt;        // 事件委托的核心原理：给父节点添加侦听器， 利用事件冒泡影响每一个子节点        var ul = document.querySelector(&#39;ul&#39;);        ul.addEventListener(&#39;click&#39;, function(e) &#123;            // e.target 这个可以得到我们点击的对象            e.target.style.backgroundColor = &#39;pink&#39;;        &#125;)    &lt;/script&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 👨‍💻Web开发 </category>
          
          <category> JavaScript+DOM+BOM+TS </category>
          
          <category> DOM </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>函数-闭包-this指向</title>
      <link href="/blog/egols2d1kxs2/"/>
      <url>/blog/egols2d1kxs2/</url>
      
        <content type="html"><![CDATA[<div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">前言：基本上和之前学过的语言一样，return语句、continue语句、break语句、函数的传参用法基本都一样，记录一下js的特征用法</div><h2 id="函数定义使用"><a href="#函数定义使用" class="headerlink" title="函数定义使用"></a>函数定义使用</h2><p>不像之前的 C++、JAVA 那样需要一个返回值来声明，JavaScript 里面直接一个关键字就搞定了，如果里面有 return 就返回 return 的值，没有则返回 undefined。下面记录一下 js 里面的三种函数声明方式和不同情况下的使用场景。</p><h3 id="function-关键字"><a href="#function-关键字" class="headerlink" title="function 关键字"></a>function 关键字</h3><blockquote><p>自定义函数方式(命名函数)利用函数关键字 function 自定义函数方式</p></blockquote><pre><code class="javascript">// 声明定义方式function fn() &#123;...&#125;// 调用fn();</code></pre><ul><li>调用函数的代码既可以放到声明函数的前面，也可以放在声明函数的后面</li></ul><h3 id="匿名函数表达式"><a href="#匿名函数表达式" class="headerlink" title="匿名函数表达式"></a>匿名函数表达式</h3><p>函数表达式方式(匿名函数）</p><blockquote><p>【C++11 里面也有匿名函数的用法，基本上就是<strong>匿名函数表达式</strong>】</p></blockquote><pre><code class="javascript">// 这是函数表达式写法，匿名函数后面跟分号结束var fn = function()&#123;...&#125;;// 调用的方式，函数调用必须写到函数体下面fn();</code></pre><ul><li>这个 fn 里面存储的是一个函数</li><li>函数表达式方式原理跟声明变量方式是一致的</li><li>函数调用的代码必须写到函数体后面</li></ul><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><ul><li>所有函数都是 Function 的对象，函数也是对象</li></ul><pre><code class="javascript">var f = new Function(&#39;a&#39;, &#39;b&#39;, &#39;console.log(a + b)&#39;);f(1, 2);var fn = new Function(&#39;参数1&#39;,&#39;参数2&#39;..., &#39;函数体&#39;)</code></pre><h3 id="立即调用函数"><a href="#立即调用函数" class="headerlink" title="立即调用函数"></a>立即调用函数</h3><p>两种表达方式</p><ul><li>(function(){})()</li><li>(function(){}())</li></ul><p>与立即执行函数相关的知识还有在函数前面加上一些符号（！、<del>、+……）会对函数的返回值进行相应的操作，其中加上</del>的意思是对返回值进行按位取反的操作，具体参考下面的参考资料<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1617956106484-c021320c-100a-49b5-a668-99928bf3a720.png#crop=0&crop=0&crop=1&crop=1&height=273&id=ll11Y&margin=%5Bobject%20Object%5D&name=image.png&originHeight=709&originWidth=1230&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=75306&status=done&style=none&title=&width=472.98846435546875" alt="image.png"><br>参考：<a href="https://blog.csdn.net/hot_cool/article/details/77567166">https://blog.csdn.net/hot_cool/article/details/77567166</a></p><h2 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h2><h3 id="arguments"><a href="#arguments" class="headerlink" title="arguments"></a>arguments</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1617851666624-a963acb7-8a97-43bc-9998-35738a1a1a7f.png#crop=0&crop=0&crop=1&crop=1&height=306&id=OVrKI&margin=%5Bobject%20Object%5D&name=image.png&originHeight=612&originWidth=935&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=236202&status=done&style=stroke&title=&width=467.5" alt="image.png"><br>当不确定有多少个参数传递的时候，可以用 arguments 来获取。JavaScript 中，arguments 实际上它是当前函数的一个内置对象。所有函数都内置了一个 arguments 对象，arguments 对象中存储了传递的所有实参。arguments 展示形式是一个伪数组，因此可以进行遍历。伪数组具有以下特点：</p><ul><li>具有 length 属性</li><li>按索引方式储存数据</li><li>不具有数组的 push , pop 等方法<br>注意：在函数内部使用该对象，用此对象获取函数调用时传的实参。</li></ul><h3 id="箭头函数（ES6）里面的不同"><a href="#箭头函数（ES6）里面的不同" class="headerlink" title="箭头函数（ES6）里面的不同"></a>箭头函数（ES6）里面的不同</h3><p>es6 的箭头函数用起来很方便，但是一个不方便的就是在这里面 arguments 不能用了<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1617852137156-ea361bcf-a64d-40e7-9ad4-de9ad5a2789d.png#crop=0&crop=0&crop=1&crop=1&height=151&id=FOFeI&margin=%5Bobject%20Object%5D&name=image.png&originHeight=301&originWidth=928&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=43847&status=done&style=none&title=&width=464" alt="image.png"><br>如果非要用的化，将这个箭头函数放在一个普通函数里面，让箭头函数接受这个普通函数的参数<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1617852218090-65cab2f5-0088-41e5-95fa-0845a253fcbd.png#crop=0&crop=0&crop=1&crop=1&height=102&id=kFJpX&margin=%5Bobject%20Object%5D&name=image.png&originHeight=203&originWidth=754&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=27598&status=done&style=stroke&title=&width=377" alt="image.png"></p><h3 id="关于值传递"><a href="#关于值传递" class="headerlink" title="关于值传递"></a>关于值传递</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1617852230127-5b2394d1-82c0-48a4-8bbb-385f5d27760b.png#crop=0&crop=0&crop=1&crop=1&height=54&id=Iq2ke&margin=%5Bobject%20Object%5D&name=image.png&originHeight=108&originWidth=813&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=28188&status=done&style=stroke&title=&width=406.5" alt="image.png"></p><h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><h3 id="几个常用-this-指向"><a href="#几个常用-this-指向" class="headerlink" title="几个常用 this 指向"></a>几个常用 this 指向</h3><ul><li>全局作用域或者普通函数中 this 指向全局对象 window（定时器里面的 this 指向 window）</li><li>方法调用中谁调用 this 指向谁</li><li>构造函数中 this 指向构造函数的实例</li></ul><pre><code class="javascript">&lt;button&gt;点击&lt;/button&gt;    &lt;script&gt;        // this 指向问题 一般情况下this的最终指向的是那个调用它的对象        // 1. 全局作用域或者普通函数中this指向全局对象window（ 注意定时器里面的this指向window）        console.log(this);        function fn() &#123;            console.log(this);        &#125;        window.fn();        window.setTimeout(function() &#123;            console.log(this);        &#125;, 1000);        // 2. 方法调用中谁调用this指向谁        var o = &#123;            sayHi: function() &#123;                console.log(this); // this指向的是 o 这个对象            &#125;        &#125;        o.sayHi();        var btn = document.querySelector(&#39;button&#39;);        btn.addEventListener(&#39;click&#39;, function() &#123;                console.log(this); // 事件处理函数中的this指向的是btn这个按钮对象            &#125;)        // 3. 构造函数中this指向构造函数的实例        function Fun() &#123;            console.log(this); // this 指向的是fun 实例对象        &#125;        var fun = new Fun();    &lt;/script&gt;</code></pre><h3 id="函数内部的-this-指向"><a href="#函数内部的-this-指向" class="headerlink" title="函数内部的 this 指向"></a>函数内部的 this 指向</h3><p>这些 this 的指向，是当我们调用函数的时候确定的。调用方式的不同决定了 this 的指向不同<br>一般指向我们的调用者.</p><h3 id="改变函数内部-this-指向"><a href="#改变函数内部-this-指向" class="headerlink" title="改变函数内部 this 指向"></a>改变函数内部 this 指向</h3><div style="background: #FFFBE6;padding:10px;border: 1px solid #C3C3C3;border-radius:5px;margin-bottom:5px;">call方法</div>call()方法调用一个对象。简单理解为调用函数的方式，但是它可以改变函数的 this 指向应用场景:  经常做继承.```javascriptvar o = {    name: 'andy'} function fn(a, b) {      console.log(this);      console.log(a+b)};fn(1,2)// 此时的this指向的是window 运行结果为3fn.call(o,1,2)//此时的this指向的是对象o,参数使用逗号隔开,运行结果为3```<div style="background: #FFFBE6;padding:10px;border: 1px solid #C3C3C3;border-radius:5px;margin-bottom:5px;">apply方法</div>apply() 方法调用一个函数。简单理解为调用函数的方式，但是它可以改变函数的 this 指向。应用场景:  经常跟数组有关系```javascriptvar o = {    name: 'andy'} function fn(a, b) {      console.log(this);      console.log(a+b)};fn()// 此时的this指向的是window 运行结果为3fn.apply(o,[1,2])//此时的this指向的是对象o,参数使用数组传递 运行结果为3```<div style="background: #FFFBE6;padding:10px;border: 1px solid #C3C3C3;border-radius:5px;margin-bottom:5px;">bind方法</div>bind() 方法不会调用函数,但是能改变函数内部this 指向,返回的是原函数改变this之后产生的新函数如果只是想改变 this 指向，并且不想调用这个函数的时候，可以使用bind应用场景:不调用函数,但是还想改变this指向```javascriptvar o = { name: 'andy' };function fn(a, b) {    console.log(this);    console.log(a + b);};var f = fn.bind(o, 1, 2); //此处的f是bind返回的新函数f();//调用新函数  this指向的是对象o 参数使用逗号隔开```<div style="background: #FFFBE6;padding:10px;border: 1px solid #C3C3C3;border-radius:5px;margin-bottom:5px;">call、apply、bind三者的异同</div><ul><li>共同点 : 都可以改变 this 指向</li><li>不同点:<ul><li>call 和 apply 会调用函数, 并且改变函数内部 this 指向.</li><li>call 和 apply 传递的参数不一样,call 传递参数使用逗号隔开,apply 使用数组传递</li><li>bind 不会调用函数, 可以改变函数内部 this 指向.</li></ul></li><li>应用场景<ol><li> call 经常做继承.</li><li> apply 经常跟数组有关系. 比如借助于数学对象实现数组最大值最小值</li><li> bind 不调用函数,但是还想改变 this 指向. 比如改变定时器内部的 this 指向.</li></ol></li></ul><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>闭包（closure）指有权访问另一个函数作用域中变量的函数。简单理解就是 ，一个作用域可以访问另外一个函数内部的局部变量。</p><h3 id="闭包的作用"><a href="#闭包的作用" class="headerlink" title="闭包的作用"></a>闭包的作用</h3><p>作用：延伸变量的作用范围。</p><pre><code class="javascript">function fn() &#123;  var num = 10;  function fun() &#123;    console.log(num);  &#125;  return fun;&#125;var f = fn();f();</code></pre><h3 id="闭包的案例"><a href="#闭包的案例" class="headerlink" title="闭包的案例"></a>闭包的案例</h3><ol><li>利用闭包的方式得到当前 li 的索引号</li></ol><pre><code class="javascript">for (var i = 0; i &lt; lis.length; i++) &#123;  // 利用for循环创建了4个立即执行函数  // 立即执行函数也成为小闭包因为立即执行函数里面的任何一个函数都可以使用它的i这变量  (function (i) &#123;    lis[i].onclick = function () &#123;      console.log(i);    &#125;;  &#125;)(i);&#125;</code></pre><ol start="2"><li>闭包应用-3 秒钟之后,打印所有 li 元素的内容</li></ol><pre><code class="javascript">for (var i = 0; i &lt; lis.length; i++) &#123;  (function (i) &#123;    setTimeout(function () &#123;      console.log(lis[i].innerHTML);    &#125;, 3000);  &#125;)(i);&#125;</code></pre><ol start="3"><li>闭包应用-计算打车价格</li></ol><pre><code class="javascript">/*需求分析打车起步价13(3公里内),  之后每多一公里增加 5块钱.  用户输入公里数就可以计算打车价格如果有拥堵情况,总价格多收取10块钱拥堵费*/var car = (function () &#123;  var start = 13; // 起步价  局部变量  var total = 0; // 总价  局部变量  return &#123;    // 正常的总价    price: function (n) &#123;      if (n &lt;= 3) &#123;        total = start;      &#125; else &#123;        total = start + (n - 3) * 5;      &#125;      return total;    &#125;,    // 拥堵之后的费用    yd: function (flag) &#123;      return flag ? total + 10 : total;    &#125;,  &#125;;&#125;)();console.log(car.price(5)); // 23console.log(car.yd(true)); // 33</code></pre><pre><code class="javascript">var name = &quot;The Window&quot;;   var object = &#123;     name: &quot;My Object&quot;,     getNameFunc: function() &#123;     return function() &#123;     return this.name;     &#125;;   &#125; &#125;;console.log(object.getNameFunc()())-----------------------------------------------------------------------------------var name = &quot;The Window&quot;;　　  var object = &#123;　　　　    name: &quot;My Object&quot;,    getNameFunc: function() &#123;    var that = this;    return function() &#123;    return that.name;    &#125;;  &#125;&#125;;console.log(object.getNameFunc()())</code></pre><h2 id="简单-复杂数据类型传参"><a href="#简单-复杂数据类型传参" class="headerlink" title="简单/复杂数据类型传参"></a>简单/复杂数据类型传参</h2><ul><li><strong>简单类型</strong>（<strong>基本数据类型</strong>、<strong>值类型</strong>）：在存储时变量中存储的是值本身，包括 string ，number，boolean，undefined，null</li><li><strong>复杂数据类型（引用类型）</strong>：在存储时变量中存储的仅仅是地址（引用），通过 new 关键字创建的对象（系统对象、自定义对象），如 Object、Array、Date 等；</li></ul><h3 id="堆栈存储区别"><a href="#堆栈存储区别" class="headerlink" title="堆栈存储区别"></a>堆栈存储区别</h3><p>堆栈空间分配区别：<br>1、栈（操作系统）：由操作系统自动分配释放存放函数的参数值、局部变量的值等。其操作方式类似于数据结构中的栈；<br>简单数据类型存放到栈里面<br>2、堆（操作系统）：存储复杂类型(对象)，一般由程序员分配释放，若程序员不释放，由垃圾回收机制回收。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611885075555-12234777-10f8-4df1-8a9f-e61078298520.png#crop=0&crop=0&crop=1&crop=1&height=138&id=N6D51&margin=%5Bobject%20Object%5D&name=image.png&originHeight=275&originWidth=476&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=16662&status=done&style=none&title=&width=238" alt="image.png"><br>简单数据类型的存储方式：值类型变量的数据直接存放在变量（栈空间）中<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611885085102-7ebb3c36-ffc2-4a5b-af50-c8e377f92cef.png#crop=0&crop=0&crop=1&crop=1&height=121&id=hEv5b&margin=%5Bobject%20Object%5D&name=image.png&originHeight=241&originWidth=789&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=33962&status=done&style=stroke&title=&width=394.5" alt="image.png"><br>复杂数据类型的存储方式：引用类型变量（栈空间）里存放的是地址，真正的对象实例存放在堆空间中<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611885116525-3f8ac293-e955-40f9-bbff-1aa589b53efa.png#crop=0&crop=0&crop=1&crop=1&height=130&id=ZXK4X&margin=%5Bobject%20Object%5D&name=image.png&originHeight=259&originWidth=558&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=26906&status=done&style=stroke&title=&width=279" alt="image.png"></p><h3 id="简单类型传参"><a href="#简单类型传参" class="headerlink" title="简单类型传参"></a>简单类型传参</h3><p>函数的形参也可以看做是一个变量，当我们把一个值类型变量作为参数传给函数的形参时，其实是把变量在栈空间里的值复制了一份给形参，那么在方法内部对形参做任何修改，都不会影响到的外部变量。</p><pre><code class="javascript">function fn(a) &#123;    a++;    console.log(a);&#125;var x = 10;fn(x);console.log(x)；</code></pre><p>运行结果如下：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611885126655-4b3507e8-a666-4dae-b1c5-ecd0ad9f8bdb.png#crop=0&crop=0&crop=1&crop=1&height=98&id=E6Jxe&margin=%5Bobject%20Object%5D&name=image.png&originHeight=195&originWidth=364&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=6181&status=done&style=stroke&title=&width=182" alt="image.png"></p><h3 id="复杂数据类型传参"><a href="#复杂数据类型传参" class="headerlink" title="复杂数据类型传参"></a>复杂数据类型传参</h3><p>函数的形参也可以看做是一个变量，当我们把引用类型变量传给形参时，其实是把变量在栈空间里保存的堆地址复制给了形参，形参和实参其实保存的是同一个堆地址，所以操作的是同一个对象。</p><pre><code class="javascript">function Person(name) &#123;  this.name = name;&#125;function f1(x) &#123;  // x = p  console.log(x.name); // 2. 这个输出什么 ?  x.name = &quot;张学友&quot;;  console.log(x.name); // 3. 这个输出什么 ?&#125;var p = new Person(&quot;刘德华&quot;);console.log(p.name); // 1. 这个输出什么 ?f1(p);console.log(p.name); // 4. 这个输出什么 ?</code></pre><pre><code>    运行结果如下：</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611885137269-b37442f2-ea5b-45ce-a974-ff4676772c47.png#crop=0&crop=0&crop=1&crop=1&height=163&id=qL1s3&margin=%5Bobject%20Object%5D&name=image.png&originHeight=325&originWidth=345&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=22422&status=done&style=stroke&title=&width=172.5" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> 👨‍💻Web开发 </category>
          
          <category> JavaScript+DOM+BOM+TS </category>
          
          <category> ECMAScript </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>面向对象体系</title>
      <link href="/blog/zfpg9dfgehog/"/>
      <url>/blog/zfpg9dfgehog/</url>
      
        <content type="html"><![CDATA[<p>前言：JavaScript 首先在 ES6 没有出来之前，利用一个叫原型的一系列机制来用一段很长的代码来实现类的继承，说白了就是在函数里面默认给你加个一个叫原型的对象属性，再利用一系列指向来完成继承。在 ES6 之后，才有了形式上的类 class 及其对象，以及一个单词 extends 就搞定的继承，虽说搞定，但这里面的机制还是原型相关知识，记录学习一下。<br>不管是原型也好，新加的 class 也罢，就一个目的——为了实现面向对象。从两个体系来展开详述。</p><h2 id="体系一：原型-原型链"><a href="#体系一：原型-原型链" class="headerlink" title="体系一：原型+原型链"></a>体系一：原型+原型链</h2><ul><li>讲解的很透彻：<a href="https://www.bilibili.com/video/BV1Q64y1v7fW">https://www.bilibili.com/video/BV1Q64y1v7fW</a></li></ul><h3 id="隐式原型proto"><a href="#隐式原型proto" class="headerlink" title="隐式原型proto"></a>隐式原型<strong>proto</strong></h3><p>每个对象里面都有<strong>proto</strong>属性，这个叫对象原型，这个玩意指向<strong>构造函数的 prototype 对象</strong></p><blockquote><p><strong>proto</strong>对象原型的意义就在于为对象的查找机制提供一个方向，或者说一条路线，但是它是一个非标准属性，因此实际开发中，不可以使用这个属性，它只是内部指向原型对象 prototype</p></blockquote><p>比如说，有一个 Person 类，有一个 Student 类，Student 类继承自 Person 类，Student 有一个实例 student_1，那么 student_1 会有<strong>proto</strong>对象属性，并且展开该<strong>proto</strong>，会发现里面是 Person 类的方法和属性</p><h3 id="显式原型-prototype"><a href="#显式原型-prototype" class="headerlink" title="显式原型 prototype"></a>显式原型 prototype</h3><p>每个构造函数里面都有一个属性，这个属性叫 prototype，<strong>指向另一个对象</strong>（有什么用？在后面原型链就会发现有用了），并且这个属性是一个对象，叫做构造函数原型</p><blockquote><p>这样可以解决一个问题，就是创建不同实例，这些事例所用的方法都是同一个内存下的方法，实现共享</p></blockquote><h3 id="constructor-构造函数"><a href="#constructor-构造函数" class="headerlink" title="constructor 构造函数"></a>constructor 构造函数</h3><ol><li>对象原型（ <strong>proto</strong>）和构造函数（prototype）原型对象里面都有一个属性 constructor 属性 ，constructor 我们称为构造函数，因为它<strong>指回构造函数本身</strong>。</li><li>constructor 主要用于记录该对象引用于哪个构造函数，它可以让原型对象重新指向原来的构造函数。</li><li>一般情况下，对象的方法都在构造函数的原型对象中设置。如果有多个对象的方法，我们可以给原型对象采取对象形式赋值，但是这样就会覆盖构造函数原型对象原来的内容，这样修改后的原型对象 constructor   就不再指向当前构造函数了。此时，我们可以在修改后的原型对象中，添加一个 constructor 指向原来的构造函数。</li></ol><h3 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h3><p>a instanceof b<br>判断是 true 还是 false<br>看 a 的 constructor 是什么<br>当 b 为 a 的 constructor 或 a 的<strong>proto</strong>的 constructor……<br>结果都是 true</p><h3 id="原型链和成员查找机制"><a href="#原型链和成员查找机制" class="headerlink" title="原型链和成员查找机制"></a>原型链和成员查找机制</h3><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1651672328368-25e71aa6-4015-4469-9a67-5d841645aebe.png#clientId=u46a56e21-c760-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=735&id=ue6601372&margin=%5Bobject%20Object%5D&name=image.png&originHeight=882&originWidth=1522&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=460026&status=done&style=shadow&taskId=uac1dd157-c262-4f1d-846e-dc63ec1c20f&title=&width=1268.333282934297" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1622632967349-b2adf38c-b51f-445b-b4c8-7d0408e96390.png#crop=0&crop=0&crop=1&crop=1&height=251&id=B3Eo8&margin=%5Bobject%20Object%5D&name=image.png&originHeight=501&originWidth=1002&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=152264&status=done&style=none&title=&width=501" alt="image.png"></p><h3 id="原型体系中的继承"><a href="#原型体系中的继承" class="headerlink" title="原型体系中的继承"></a>原型体系中的继承</h3><p>call 方法可以改变一个函数的指向</p><ol><li>继承父构造函数里面的属性</li></ol><pre><code class="javascript">// 1. 父构造函数function Father(uname, age) &#123;  // this 指向父构造函数的对象实例  this.uname = uname;  this.age = age;&#125;// 2 .子构造函数function Son(uname, age, score) &#123;  // this 指向子构造函数的对象实例  // 3.使用call方式实现子继承父的属性  Father.call(this, uname, age);  this.score = score;&#125;var son = new Son(&quot;刘德华&quot;, 18, 100);console.log(son);</code></pre><ol start="2"><li>继承方法</li></ol><pre><code class="javascript">// 1. 父构造函数function Father(uname, age) &#123;  // this 指向父构造函数的对象实例  this.uname = uname;  this.age = age;&#125;Father.prototype.money = function () &#123;  console.log(100000);&#125;;// 2 .子构造函数function Son(uname, age, score) &#123;  // this 指向子构造函数的对象实例  Father.call(this, uname, age);  this.score = score;&#125;// Son.prototype = Father.prototype;  这样直接赋值会有问题,如果修改了子原型对象,父原型对象也会跟着一起变化Son.prototype = new Father();// 如果利用对象的形式修改了原型对象,别忘了利用constructor 指回原来的构造函数Son.prototype.constructor = Son;// 这个是子构造函数专门的方法Son.prototype.exam = function () &#123;  console.log(&quot;孩子要考试&quot;);&#125;;var son = new Son(&quot;刘德华&quot;, 18, 100);console.log(son);</code></pre><h2 id="体系二：类-class-【ES6】"><a href="#体系二：类-class-【ES6】" class="headerlink" title="体系二：类(class)【ES6】"></a>体系二：类(class)【ES6】</h2><p>在 ES6 中新增加了类的概念，可以使用 class 关键字声明一个类，之后以这个类来实例化对象。类抽象了对象的公共部分，它泛指某一大类（class）对象特指某一个，通过类实例化一个具体的对象。其创建的方式和之前学过的语言很类似。<br>在 ES6 中类没有变量提升，所以必须先定义类，才能通过类实例化对象</p><h3 id="创建-继承-使用"><a href="#创建-继承-使用" class="headerlink" title="创建+继承+使用"></a>创建+继承+使用</h3><pre><code class="javascript">// 奥特曼类class Aoteman &#123;  // 构造函数里面放共有属性、方法  constructor(name, age) &#123;    this.name = name;    this.age = age;  &#125;  Ability(abi) &#123;    console.log(this.name + &quot; can &quot; + abi);  &#125;&#125;// 假奥特曼类 继承 奥特曼class Jia extends Aoteman &#123;  constructor(x, y) &#123;    // 继承父类的构造函数    super(x, y);    // 方便写自己的函数    this.x = x;    this.y = y;  &#125;  // 自己内部的函数  Chuiniu() &#123;    console.log(this.x + &quot; chuiniu&quot;);  &#125;&#125;// 创建迪迦对象let dijia = new Aoteman(&quot;dijia&quot;, 100);console.log(dijia);dijia.Ability(&quot;X-ray&quot;);let dijia_jia = new Jia(&quot;dijia_jia&quot;, 50);dijia_jia.Ability(&quot;xxx&quot;);dijia_jia.Chuiniu();</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1622622728600-59f47873-c895-4686-b771-f1f538198f26.png#crop=0&crop=0&crop=1&crop=1&height=77&id=JN882&margin=%5Bobject%20Object%5D&name=image.png&originHeight=153&originWidth=882&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=14744&status=done&style=none&title=&width=441" alt="image.png"></p><h2 id="对象的各种创建方式"><a href="#对象的各种创建方式" class="headerlink" title="对象的各种创建方式"></a>对象的各种创建方式</h2><h3 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h3><p>属性和方法的调用：<br>属性可以用”.”和[“属性名”]来调用<br>方法用”.”来调用</p><h3 id="模式工厂"><a href="#模式工厂" class="headerlink" title="模式工厂"></a>模式工厂</h3><p>new 一个空对象，<code>let obj = new Object();</code><br>然后利用”.”的方式给其添加属性和方法<br>内置的 Object()构造函数<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1622623002064-1297005b-76a6-4d94-9b12-a83cf709e3a1.png#crop=0&crop=0&crop=1&crop=1&height=215&id=hDM2I&margin=%5Bobject%20Object%5D&name=image.png&originHeight=429&originWidth=1059&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=99843&status=done&style=shadow&title=&width=529.5" alt="image.png"></p><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><blockquote><p>构造函数：是一种特殊的函数，主要用来初始化对象，即为对象成员变量赋初始值，它总与 new 运算符一起使用。我们可以把对象中一些公共的属性和方法抽取出来，然后封装到这个函数里面。</p></blockquote><pre><code class="javascript">function 构造函数名(形参1,形参2,形参3) &#123;     this.属性名1 = 参数1;     this.属性名2 = 参数2;     this.属性名3 = 参数3;     this.方法名 = 函数体;&#125;let obj = new 构造函数名(实参1，实参2，实参3)</code></pre><ul><li>构造函数约定<strong>首字母大写</strong>。</li><li>函数内的属性和方法前面需要添加 <strong>this</strong> ，表示当前对象的属性和方法。</li><li>构造函数中<strong>不需要 return 返回结果</strong>。</li><li>当我们创建对象的时候，<strong>必须用 new 来调用构造函数</strong>。</li></ul><h3 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1622623181327-bd4b5d09-8525-4c59-b550-9af381526f23.png#crop=0&crop=0&crop=1&crop=1&height=264&id=qBvgN&margin=%5Bobject%20Object%5D&name=image.png&originHeight=527&originWidth=1059&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=125271&status=done&style=shadow&title=&width=529.5" alt="image.png"><br>下面详述什么是原型</p><h2 id="对象的内置方法"><a href="#对象的内置方法" class="headerlink" title="对象的内置方法"></a>对象的内置方法</h2><p>参考教程：</p><ul><li><a href="https://zh.javascript.info/object-basics">https://zh.javascript.info/object-basics</a></li></ul><h3 id="Object-defineProperty"><a href="#Object-defineProperty" class="headerlink" title="Object.defineProperty"></a>Object.defineProperty</h3><p>Object.defineProperty 设置或修改对象中的属性</p><pre><code class="javascript">Object.defineProperty(对象，修改或新增的属性名，&#123;        value:修改或新增的属性的值,        writable:true/false,//如果值为false 不允许修改这个属性值        enumerable: false,//enumerable 如果值为false 则不允许遍历    configurable: false  //configurable 如果为false 则不允许删除这个属性 属性是否可以被删除或是否可以再次修改特性&#125;)</code></pre><h3 id="删除对象属性"><a href="#删除对象属性" class="headerlink" title="删除对象属性"></a>删除对象属性</h3><ul><li>直接用 delete，暴力简单</li><li>也可以参考：<a href="https://segmentfault.com/q/1010000013891861">如何优雅的删除对象中的指定属性？</a></li></ul><h3 id="assign"><a href="#assign" class="headerlink" title="assign()"></a>assign()</h3><ul><li>Object.assign 后者覆盖前者，再返回前者</li><li>常用于深拷贝浅拷贝数据</li></ul><h2 id="对象的遍历"><a href="#对象的遍历" class="headerlink" title="对象的遍历"></a>对象的遍历</h2><h3 id="for…in"><a href="#for…in" class="headerlink" title="for…in"></a>for…in</h3><div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">语句用于对数组或者对象的属性进行循环操作。</div>其语法如下：```javascriptfor (变量 in 对象名字) {    // 在此执行代码}```<ul><li>语法中的变量是自定义的，它需要符合命名规范，通常我们会将这个变量写为 k 或者 key。书里面建议用 const 来加持。</li></ul><pre><code class="javascript">for (let k in obj) &#123;  console.log(k); // 这里的 k 是属性名  console.log(obj[k]); // 这里的 obj[k] 是属性值&#125;</code></pre><h3 id="Object-keys-obj"><a href="#Object-keys-obj" class="headerlink" title="Object.keys(obj)"></a>Object.keys(obj)</h3><div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">获取属性名</div>```javascriptvar obj = {     id: 1,     pname: '小米',     price: 1999,     num: 2000};var result = Object.keys(obj)console.log(result)//[id，pname,price,num]```]]></content>
      
      
      <categories>
          
          <category> 👨‍💻Web开发 </category>
          
          <category> JavaScript+DOM+BOM+TS </category>
          
          <category> ECMAScript </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>jQuery事件+插件</title>
      <link href="/blog/3_day03_jquery/"/>
      <url>/blog/3_day03_jquery/</url>
      
        <content type="html"><![CDATA[<h2 id="jQuery-事件注册"><a href="#jQuery-事件注册" class="headerlink" title="jQuery 事件注册"></a>jQuery 事件注册</h2><p>jQuery 为我们提供了方便的事件注册机制，是开发人员抑郁操作优缺点如下：</p><ul><li>优点: 操作简单，且不用担心事件覆盖等问题。</li><li>缺点: 普通的事件注册不能做事件委托，且无法实现事件解绑，需要借助其他方法。</li></ul><p><strong>语法</strong><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616073493434-c3ba216b-4d64-4229-b788-30947c24ab77.png#crop=0&crop=0&crop=1&crop=1&height=220&id=fMqr8&originHeight=220&originWidth=620&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=stroke&title=&width=620"><br><strong>演示代码</strong></p><pre><code class="javascript">&lt;body&gt;    &lt;div&gt;&lt;/div&gt;    &lt;script&gt;        $(function() &#123;            // 1. 单个事件注册            $(&quot;div&quot;).click(function() &#123;                $(this).css(&quot;background&quot;, &quot;purple&quot;);            &#125;);            $(&quot;div&quot;).mouseenter(function() &#123;                $(this).css(&quot;background&quot;, &quot;skyblue&quot;);            &#125;);        &#125;)    &lt;/script&gt;&lt;/body&gt;</code></pre><h2 id="jQuery-事件处理"><a href="#jQuery-事件处理" class="headerlink" title="jQuery 事件处理"></a>jQuery 事件处理</h2><p>因为普通注册事件方法的不足，jQuery 又开发了多个处理方法，重点讲解如下：</p><ul><li>on(): 用于事件绑定，目前最好用的事件绑定方法</li><li>off(): 事件解绑</li><li>trigger() / triggerHandler(): 事件触发</li></ul><h3 id="1-2-1-事件处理-on-绑定事件"><a href="#1-2-1-事件处理-on-绑定事件" class="headerlink" title="1.2.1 事件处理 on() 绑定事件"></a>1.2.1 事件处理 on() 绑定事件</h3><pre><code>因为普通注册事件方法的不足，jQuery又创建了多个新的事件绑定方法bind() / live() / delegate() / on()等，其中最好用的是: on()</code></pre><p><strong>语法</strong><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616073493540-3a234b93-0493-427d-9113-4a801e391e60.png#crop=0&crop=0&crop=1&crop=1&height=276&id=RIdT9&originHeight=276&originWidth=620&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&title=&width=620"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616073493614-d618db76-bdb5-4284-a6c3-433bf44340b2.png#crop=0&crop=0&crop=1&crop=1&height=200&id=hBFH2&originHeight=200&originWidth=620&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&title=&width=620"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616073493684-be1891f4-c228-49eb-ac9d-47e233dafaad.png#crop=0&crop=0&crop=1&crop=1&height=235&id=Cd9At&originHeight=235&originWidth=620&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&title=&width=620"><br><strong>演示代码</strong></p><pre><code class="javascript">&lt;body&gt;    &lt;div&gt;&lt;/div&gt;    &lt;ul&gt;        &lt;li&gt;我们都是好孩子&lt;/li&gt;        &lt;li&gt;我们都是好孩子&lt;/li&gt;        &lt;li&gt;我们都是好孩子&lt;/li&gt;    &lt;/ul&gt;    &lt;ol&gt;&lt;/ol&gt;    &lt;script&gt;        $(function() &#123;            // (1) on可以绑定1个或者多个事件处理程序            // $(&quot;div&quot;).on(&#123;            //     mouseenter: function() &#123;            //         $(this).css(&quot;background&quot;, &quot;skyblue&quot;);            //     &#125;,            //     click: function() &#123;            //         $(this).css(&quot;background&quot;, &quot;purple&quot;);            //     &#125;            // &#125;);            $(&quot;div&quot;).on(&quot;mouseenter mouseleave&quot;, function() &#123;                $(this).toggleClass(&quot;current&quot;);            &#125;);            // (2) on可以实现事件委托（委派）            // click 是绑定在ul 身上的，但是 触发的对象是 ul 里面的小li            // $(&quot;ul li&quot;).click();            $(&quot;ul&quot;).on(&quot;click&quot;, &quot;li&quot;, function() &#123;                alert(11);            &#125;);            // (3) on可以给未来动态创建的元素绑定事件            $(&quot;ol&quot;).on(&quot;click&quot;, &quot;li&quot;, function() &#123;                alert(11);            &#125;)            var li = $(&quot;&lt;li&gt;我是后来创建的&lt;/li&gt;&quot;);            $(&quot;ol&quot;).append(li);        &#125;)    &lt;/script&gt;&lt;/body&gt;</code></pre><h3 id="1-2-3-事件处理-off-解绑事件"><a href="#1-2-3-事件处理-off-解绑事件" class="headerlink" title="1.2.3. 事件处理 off() 解绑事件"></a>1.2.3. 事件处理 off() 解绑事件</h3><pre><code>当某个事件上面的逻辑，在特定需求下不需要的时候，可以把该事件上的逻辑移除，这个过程我们称为事件解绑。jQuery 为我们提供 了多种事件解绑方法：die() / undelegate() / off() 等，甚至还有只触发一次的事件绑定方法 one()，在这里我们重点讲解一下 off() ;</code></pre><p><strong>语法</strong><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616073493756-82ebfacb-9794-47bf-8776-6b7d80437782.png#crop=0&crop=0&crop=1&crop=1&height=226&id=IIuR6&originHeight=226&originWidth=620&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&title=&width=620"><br><strong>演示代码</strong></p><pre><code class="javascript">&lt;body&gt;    &lt;div&gt;&lt;/div&gt;    &lt;ul&gt;        &lt;li&gt;我们都是好孩子&lt;/li&gt;        &lt;li&gt;我们都是好孩子&lt;/li&gt;        &lt;li&gt;我们都是好孩子&lt;/li&gt;    &lt;/ul&gt;    &lt;p&gt;我是一个P标签&lt;/p&gt;    &lt;script&gt;        $(function() &#123;              // 事件绑定            $(&quot;div&quot;).on(&#123;                click: function() &#123;                    console.log(&quot;我点击了&quot;);                &#125;,                mouseover: function() &#123;                    console.log(&#39;我鼠标经过了&#39;);                &#125;            &#125;);            $(&quot;ul&quot;).on(&quot;click&quot;, &quot;li&quot;, function() &#123;                alert(11);            &#125;);            // 1. 事件解绑 off            // $(&quot;div&quot;).off();  // 这个是解除了div身上的所有事件            $(&quot;div&quot;).off(&quot;click&quot;); // 这个是解除了div身上的点击事件            $(&quot;ul&quot;).off(&quot;click&quot;, &quot;li&quot;);            // 2. one() 但是它只能触发事件一次            $(&quot;p&quot;).one(&quot;click&quot;, function() &#123;                alert(11);            &#125;)        &#125;)    &lt;/script&gt;&lt;/body&gt;</code></pre><h3 id="1-2-4-事件处理-trigger-自动触发事件"><a href="#1-2-4-事件处理-trigger-自动触发事件" class="headerlink" title="1.2.4. 事件处理 trigger() 自动触发事件"></a>1.2.4. 事件处理 trigger() 自动触发事件</h3><pre><code>有些时候，在某些特定的条件下，我们希望某些事件能够自动触发, 比如轮播图自动播放功能跟点击右侧按钮一致。可以利用定时器自动触发右侧按钮点击事件，不必鼠标点击触发。由此 jQuery 为我们提供了两个自动触发事件 trigger() 和 triggerHandler() ;</code></pre><p><strong>语法</strong><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616073493822-a72c8dfb-7860-407e-b410-60c073ed48d7.png#crop=0&crop=0&crop=1&crop=1&height=146&id=wy7Zt&originHeight=146&originWidth=620&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&title=&width=620"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616073493901-f1048b8f-64aa-4cf6-98df-0ea9245e813e.png#crop=0&crop=0&crop=1&crop=1&height=134&id=EXulM&originHeight=134&originWidth=620&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&title=&width=620"><br><strong>演示代码</strong></p><pre><code class="javascript">&lt;body&gt;    &lt;div&gt;&lt;/div&gt;    &lt;input type=&quot;text&quot;&gt;    &lt;script&gt;    $(function() &#123;      // 绑定事件      $(&quot;div&quot;).on(&quot;click&quot;, function() &#123;        alert(11);      &#125;);      // 自动触发事件      // 1. 元素.事件()      // $(&quot;div&quot;).click();会触发元素的默认行为      // 2. 元素.trigger(&quot;事件&quot;)      // $(&quot;div&quot;).trigger(&quot;click&quot;);会触发元素的默认行为      $(&quot;input&quot;).trigger(&quot;focus&quot;);      // 3. 元素.triggerHandler(&quot;事件&quot;) 就是不会触发元素的默认行为      $(&quot;input&quot;).on(&quot;focus&quot;, function() &#123;        $(this).val(&quot;你好吗&quot;);      &#125;);      // 一个会获取焦点，一个不会      $(&quot;div&quot;).triggerHandler(&quot;click&quot;);      // $(&quot;input&quot;).triggerHandler(&quot;focus&quot;);    &#125;);    &lt;/script&gt;&lt;/body&gt;</code></pre><h2 id="1-3-jQuery-事件对象"><a href="#1-3-jQuery-事件对象" class="headerlink" title="1.3. jQuery 事件对象"></a>1.3. jQuery 事件对象</h2><pre><code>jQuery 对DOM中的事件对象 event 进行了封装，兼容性更好，获取更方便，使用变化不大。事件被触发，就会有事件对象的产生。</code></pre><p><strong>语法</strong><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616073493975-78588b8f-4bb7-4720-b637-d256b2831b0b.png#crop=0&crop=0&crop=1&crop=1&height=121&id=rOjnn&originHeight=121&originWidth=635&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&title=&width=635"><br><strong>演示代码</strong></p><pre><code class="javascript">&lt;body&gt;    &lt;div&gt;&lt;/div&gt;    &lt;script&gt;        $(function() &#123;            $(document).on(&quot;click&quot;, function() &#123;                console.log(&quot;点击了document&quot;);            &#125;)            $(&quot;div&quot;).on(&quot;click&quot;, function(event) &#123;                // console.log(event);                console.log(&quot;点击了div&quot;);                event.stopPropagation();            &#125;)        &#125;)    &lt;/script&gt;&lt;/body&gt;</code></pre><p>注意：jQuery 中的 event 对象使用，可以借鉴 API 和 DOM 中的 event 。</p><h2 id="1-4-jQuery-拷贝对象"><a href="#1-4-jQuery-拷贝对象" class="headerlink" title="1.4. jQuery 拷贝对象"></a>1.4. jQuery 拷贝对象</h2><pre><code>jQuery中分别为我们提供了两套快速获取和设置元素尺寸和位置的API，方便易用，内容如下。</code></pre><p><strong>语法</strong><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616073494039-54be8373-5ba6-4c40-af84-3c6e7cd37d79.png#crop=0&crop=0&crop=1&crop=1&height=274&id=n5zBz&originHeight=274&originWidth=620&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&title=&width=620"><br><strong>演示代码</strong></p><pre><code class="javascript">&lt;script&gt;        $(function() &#123;               // 1.合并数据            var targetObj = &#123;&#125;;            var obj = &#123;                id: 1,                name: &quot;andy&quot;            &#125;;            // $.extend(target, obj);            $.extend(targetObj, obj);            console.log(targetObj);               // 2. 会覆盖 targetObj 里面原来的数据            var targetObj = &#123;                id: 0            &#125;;            var obj = &#123;                id: 1,                name: &quot;andy&quot;            &#125;;            // $.extend(target, obj);            $.extend(targetObj, obj);            console.log(targetObj);        &#125;)    &lt;/script&gt;</code></pre><h2 id="1-5-jQuery-多库共存"><a href="#1-5-jQuery-多库共存" class="headerlink" title="1.5. jQuery 多库共存"></a>1.5. jQuery 多库共存</h2><pre><code>实际开发中，很多项目连续开发十多年，jQuery版本不断更新，最初的 jQuery 版本无法满足需求，这时就需要保证在旧有版本正常运行的情况下，新的功能使用新的jQuery版本实现，这种情况被称为，jQuery 多库共存。</code></pre><p><strong>语法</strong><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616073494111-229f7c73-4d09-4074-bd62-0da6a2f0db40.png#crop=0&crop=0&crop=1&crop=1&height=112&id=iTQQD&originHeight=112&originWidth=620&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&title=&width=620"><br><strong>演示代码</strong></p><pre><code class="javascript">&lt;script&gt;    $(function() &#123;          // 让jquery 释放对$ 控制权 让用自己决定          var suibian = jQuery.noConflict();          console.log(suibian(&quot;span&quot;));    &#125;)&lt;/script&gt;</code></pre><h2 id="1-6-jQuery-插件"><a href="#1-6-jQuery-插件" class="headerlink" title="1.6. jQuery 插件"></a>1.6. jQuery 插件</h2><pre><code>jQuery 功能比较有限，想要更复杂的特效效果，可以借助于 jQuery 插件完成。 这些插件也是依赖于jQuery来完成的，所以必须要先引入</code></pre><p>jQuery 文件，因此也称为 jQuery 插件。<br>jQuery 插件常用的网站：</p><ol><li>jQuery 插件库 <a href="http://www.jq22.com/">http://www.jq22.com/</a></li><li>jQuery 之家 <a href="http://www.htmleaf.com/">http://www.htmleaf.com/</a></li></ol><p>jQuery 插件使用步骤：</p><ol start="3"><li>引入相关文件。（jQuery 文件 和 插件文件）</li><li>复制相关 html、css、js (调用插件)。</li></ol><h3 id="1-4-1-瀑布流插件（重点讲解）"><a href="#1-4-1-瀑布流插件（重点讲解）" class="headerlink" title="1.4.1. 瀑布流插件（重点讲解）"></a>1.4.1. 瀑布流插件（重点讲解）</h3><pre><code>我们学习的第一个插件是jQuery之家的开源插件，瀑布流。我们将重点详细讲解，从找到插件所在网页，然后点击下载代码，到插件的使用等，后面的插件使用可参考瀑布流插件的使用。</code></pre><p><strong>下载位置</strong><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616073494174-fb4a286c-0558-4af1-98d7-08102ae5bb99.png#crop=0&crop=0&crop=1&crop=1&height=500&id=noBRx&originHeight=500&originWidth=1200&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&title=&width=1200"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616073494257-d73dc383-f99b-465d-908e-703a4c023f36.png#crop=0&crop=0&crop=1&crop=1&height=77&id=MxV60&originHeight=77&originWidth=318&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&title=&width=318"><br><strong>代码演示</strong><br>插件的使用三点： 1. 引入 css. 2.引入 JS 3.引入 html。 （有的简单插件只需引入 html 和 js，甚至有的只需引入 js）</p><ul><li>1.引入 css.</li></ul><pre><code class="javascript">&lt;link rel=&quot;stylesheet&quot; href=&quot;css/normalize.css&quot;&gt;&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;css/default.css&quot;&gt;&lt;!-- 下面的样式代码为页面布局，可以引入，也可以自己写，自己设计页面样式，一般为直接引入，方便 --&gt;&lt;style type=&quot;text/css&quot;&gt;  #gallery-wrapper &#123;    position: relative;    max-width: 75%;    width: 75%;    margin: 50px auto;  &#125;  img.thumb &#123;    width: 100%;    max-width: 100%;    height: auto;  &#125;  .white-panel &#123;    position: absolute;    background: white;    border-radius: 5px;    box-shadow: 0px 1px 2px rgba(0, 0, 0, 0.3);    padding: 10px;  &#125;  .white-panel h1 &#123;    font-size: 1em;  &#125;  .white-panel h1 a &#123;    color: #A92733;  &#125;  .white-panel:hover &#123;    box-shadow: 1px 1px 10px rgba(0, 0, 0, 0.5);    margin-top: -5px;    -webkit-transition: all 0.3s ease-in-out;    -moz-transition: all 0.3s ease-in-out;    -o-transition: all 0.3s ease-in-out;    transition: all 0.3s ease-in-out;  &#125;&lt;/style&gt;</code></pre><ul><li>2.引入 js.</li></ul><pre><code class="javascript">&lt;!-- 前两个必须引入 --&gt;&lt;script src=&quot;js/jquery-1.11.0.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;js/pinterest_grid.js&quot;&gt;&lt;/script&gt;&lt;!-- 下面的为启动瀑布流代码，参数可调节属性，具体功能可参考readme.html --&gt;&lt;script type=&quot;text/javascript&quot;&gt;    $(function() &#123;      $(&quot;#gallery-wrapper&quot;).pinterest_grid(&#123;          no_columns: 5,          padding_x: 15,          padding_y: 10,          margin_bottom: 50,          single_column_breakpoint: 700      &#125;);    &#125;);&lt;/script&gt;</code></pre><ul><li>3.引入 html.</li></ul><pre><code class="javascript">&lt;!-- html结构一般为事先写好，很难修改结构，但可以修改内容及图片的多少（article标签） --&gt;    &lt;section id=&quot;gallery-wrapper&quot;&gt;        &lt;article class=&quot;white-panel&quot;&gt;            &lt;img src=&quot;images/P_000.jpg&quot; class=&quot;thumb&quot;&gt;            &lt;h1&gt;&lt;a href=&quot;#&quot;&gt;我是轮播图片1&lt;/a&gt;&lt;/h1&gt;            &lt;p&gt;里面很精彩哦&lt;/p&gt;        &lt;/article&gt;        &lt;article class=&quot;white-panel&quot;&gt;            &lt;img src=&quot;images/P_005.jpg&quot; class=&quot;thumb&quot;&gt;            &lt;h1&gt;&lt;a href=&quot;#&quot;&gt;我是轮播图片1&lt;/a&gt;&lt;/h1&gt;            &lt;p&gt;里面很精彩哦&lt;/p&gt;        &lt;/article&gt;        &lt;article class=&quot;white-panel&quot;&gt;            &lt;img src=&quot;images/P_006.jpg&quot; class=&quot;thumb&quot;&gt;            &lt;h1&gt;&lt;a href=&quot;#&quot;&gt;我是轮播图片1&lt;/a&gt;&lt;/h1&gt;            &lt;p&gt;里面很精彩哦&lt;/p&gt;        &lt;/article&gt;        &lt;article class=&quot;white-panel&quot;&gt;            &lt;img src=&quot;images/P_007.jpg&quot; class=&quot;thumb&quot;&gt;            &lt;h1&gt;&lt;a href=&quot;#&quot;&gt;我是轮播图片1&lt;/a&gt;&lt;/h1&gt;            &lt;p&gt;里面很精彩哦&lt;/p&gt;        &lt;/article&gt;    &lt;/section&gt;</code></pre><p>总结：jQuery 插件就是引入别人写好的：html 、css、js （有时也可以只引入一部分，读懂后也可以修改部分内容）</p><h3 id="1-4-2-图片懒加载插件"><a href="#1-4-2-图片懒加载插件" class="headerlink" title="1.4.2. 图片懒加载插件"></a>1.4.2. 图片懒加载插件</h3><pre><code>图片的懒加载就是：当页面滑动到有图片的位置，图片才进行加载，用以提升页面打开的速度及用户体验。（下载略）</code></pre><p><strong>代码演示</strong><br>懒加载只需引入 html 和 js 操作 即可，此插件不涉及 css。</p><ul><li>1.引入 js</li></ul><pre><code class="javascript">&lt;script src=&quot;js/EasyLazyload.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt;       lazyLoadInit(&#123;           showTime: 1100,           onLoadBackEnd: function(i, e) &#123;             console.log(&quot;onLoadBackEnd:&quot; + i);           &#125;,           onLoadBackStart: function(i, e) &#123;             console.log(&quot;onLoadBackStart:&quot; + i);           &#125;     &#125;);&lt;/script&gt;</code></pre><ul><li>2.引入 html</li></ul><pre><code class="javascript">&lt;img data-lazy-src=&quot;upload/floor-1-3.png&quot; alt=&quot;&quot;&gt;</code></pre><h3 id="1-4-3-全屏滚动插件"><a href="#1-4-3-全屏滚动插件" class="headerlink" title="1.4.3. 全屏滚动插件"></a>1.4.3. 全屏滚动插件</h3><pre><code>全屏滚动插件比较大，所以，一般大型插件都会有帮助文档，或者网站。全屏滚动插件介绍比较详细的网站为：</code></pre><p><a href="http://www.dowebok.com/demo/2014/77/">http://www.dowebok.com/demo/2014/77/</a><br><strong>代码演示</strong><br>全屏滚动因为有多重形式，所以不一样的风格 html 和 css 也不一样，但是 js 变化不大。所以下面只演示 js 的引入，html 和 css 引入根据自己实际<br>项目需要使用哪种风格引入对应的 HTML 和 CSS。</p><pre><code class="javascript">&lt;script src=&quot;js/jquery.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;js/fullpage.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt;      $(function() &#123;          $(&#39;#dowebok&#39;).fullpage(&#123;            sectionsColor: [&#39;pink&#39;, &#39;#4BBFC3&#39;, &#39;#7BAABE&#39;, &#39;#f90&#39;],            navigation: true          &#125;);    &#125;);&lt;/script&gt;</code></pre><p>注意：实际开发，一般复制文件，然后在文件中进行修改和添加功能。</p><h3 id="1-4-4-bootstrap-组件"><a href="#1-4-4-bootstrap-组件" class="headerlink" title="1.4.4. bootstrap 组件"></a>1.4.4. bootstrap 组件</h3><pre><code>Bootstrap是 Twitter 公司设计的基于HTML、CSS、JavaScript开发的简洁、直观、强悍的前端开发框架，他依靠jQuery实现，且支持响应式</code></pre><p>布局，使得 Web 开发更加方便快捷。<br><strong>凡是在软件开发中用到了软件的复用，被复用的部分都可以称为组件，凡是在应用程序中已经预留接口的组件就是插件</strong>。Bootstrap 组件使<br>用非常方便: 1.引入 bootstrap 相关 css 和 js 2.去官网复制 html<br><strong>代码演示</strong></p><ol><li>引入 bootstrap 相关 css 和 js</li></ol><pre><code class="javascript">&lt;link rel=&quot;stylesheet&quot; href=&quot;bootstrap/css/bootstrap.min.css&quot;&gt;&lt;script src=&quot;bootstrap/js/jquery.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;bootstrap/js/bootstrap.min.js&quot;&gt;&lt;/script&gt;</code></pre><ol start="2"><li>去官网复制 html 的功能模块</li></ol><pre><code class="javascript">&lt;div class=&quot;container&quot;&gt;        &lt;!-- Single button --&gt;        &lt;div class=&quot;btn-group&quot;&gt;            &lt;button type=&quot;button&quot; class=&quot;btn btn-default dropdown-toggle&quot; data-toggle=&quot;dropdown&quot; aria-haspopup=&quot;true&quot; aria-expanded=&quot;false&quot;&gt;              Action &lt;span class=&quot;caret&quot;&gt;&lt;/span&gt;            &lt;/button&gt;            &lt;ul class=&quot;dropdown-menu&quot;&gt;                &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Action&lt;/a&gt;&lt;/li&gt;                &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Another action&lt;/a&gt;&lt;/li&gt;                &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Something else here&lt;/a&gt;&lt;/li&gt;                &lt;li role=&quot;separator&quot; class=&quot;divider&quot;&gt;&lt;/li&gt;                &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Separated link&lt;/a&gt;&lt;/li&gt;            &lt;/ul&gt;         &lt;/div&gt;    &lt;/div&gt;</code></pre><h3 id="1-4-5-bootstrap-插件（JS）"><a href="#1-4-5-bootstrap-插件（JS）" class="headerlink" title="1.4.5. bootstrap 插件（JS）"></a>1.4.5. bootstrap 插件（JS）</h3><pre><code>bootstrap中的js插件其实也是组件的一部分，只不过是需要js调用功能的组件，所以一般bootstrap的js插件一般会伴随着js代码（有的也可以</code></pre><p>省略 js，用属性实现）。<br>步骤： 1.引入 bootstrap 相关 css 和 js 2.去官网复制 html 3.复制 js 代码，启动 js 插件。<br><strong>代码演示</strong></p><ol><li>引入 bootstrap 相关 css 和 js</li></ol><pre><code class="javascript">&lt;link rel=&quot;stylesheet&quot; href=&quot;bootstrap/css/bootstrap.min.css&quot;&gt;&lt;script src=&quot;bootstrap/js/jquery.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;bootstrap/js/bootstrap.min.js&quot;&gt;&lt;/script&gt;</code></pre><ol start="2"><li>去官网复制 html 的功能模块</li></ol><pre><code class="javascript">&lt;!-- 模态框 --&gt;&lt;!-- Large modal --&gt;&lt;button type=&quot;button&quot; class=&quot;btn btn-primary&quot; data-toggle=&quot;modal&quot; data-target=&quot;.bs-example-modal-lg&quot;&gt;Large modal&lt;/button&gt;&lt;div class=&quot;modal fade bs-example-modal-lg&quot; tabindex=&quot;-1&quot; role=&quot;dialog&quot; aria-labelledby=&quot;myLargeModalLabel&quot;&gt;    &lt;div class=&quot;modal-dialog modal-lg&quot; role=&quot;document&quot;&gt;        &lt;div class=&quot;modal-content&quot;&gt;            里面就是模态框        &lt;/div&gt;    &lt;/div&gt;&lt;/div&gt;</code></pre><ol start="3"><li>复制 js 代码，启动 js 插件。</li></ol><pre><code class="javascript">&lt;script&gt;  // 当我们点击了自己定义的按钮，就弹出模态框 $(&quot;.myBtn&quot;).on(&quot;click&quot;, function()&#123;&quot; &quot;&#125;  &#123;    // alert(11);    $(&quot;#btn&quot;).modal()  &#125;  )&lt;/script&gt;</code></pre><h3 id="1-4-6-bootstrap-案例-阿里百秀"><a href="#1-4-6-bootstrap-案例-阿里百秀" class="headerlink" title="1.4.6. bootstrap 案例-阿里百秀"></a>1.4.6. bootstrap 案例-阿里百秀</h3><blockquote><p>1.通过调用组件实现导航栏 2.通过调用插件实现登录 3.通过调用插件标签页实现 tab 栏</p></blockquote><pre><code>代码实现略。(详情参考源代码)</code></pre><h2 id="1-7-综合案例-toDoList-案例分析（代码略）"><a href="#1-7-综合案例-toDoList-案例分析（代码略）" class="headerlink" title="1.7. 综合案例: toDoList 案例分析（代码略）"></a>1.7. 综合案例: toDoList 案例分析（代码略）</h2><h3 id="1-7-1-案例：案例介绍"><a href="#1-7-1-案例：案例介绍" class="headerlink" title="1.7.1 案例：案例介绍"></a>1.7.1 案例：案例介绍</h3><pre><code class="javascript">// 1. 文本框里面输入内容，按下回车，就可以生成待办事项。// 2. 点击待办事项复选框，就可以把当前数据添加到已完成事项里面。// 3. 点击已完成事项复选框，就可以把当前数据添加到待办事项里面。// 4. 但是本页面内容刷新页面不会丢失。</code></pre><h3 id="1-7-2-案例：toDoList-分析"><a href="#1-7-2-案例：toDoList-分析" class="headerlink" title="1.7.2 案例：toDoList 分析"></a>1.7.2 案例：toDoList 分析</h3><pre><code class="javascript">// 1. 刷新页面不会丢失数据，因此需要用到本地存储 localStorage// 2. 核心思路： 不管按下回车，还是点击复选框，都是把本地存储的数据加载到页面中，这样保证刷新关闭页面不会丢失数据// 3. 存储的数据格式：var todolist =  [&#123; title : ‘xxx’, done: false&#125;]// 4. 注意点1： 本地存储 localStorage 里面只能存储字符串格式 ，因此需要把对象转换为字符串 JSON.stringify(data)。// 5. 注意点2： 获取本地存储数据，需要把里面的字符串转换为对象格式JSON.parse() 我们才能使用里面的数据。</code></pre><h3 id="1-7-3-案例：toDoList-按下回车把新数据添加到本地存储里面"><a href="#1-7-3-案例：toDoList-按下回车把新数据添加到本地存储里面" class="headerlink" title="1.7.3 案例：toDoList 按下回车把新数据添加到本地存储里面"></a>1.7.3 案例：toDoList 按下回车把新数据添加到本地存储里面</h3><pre><code class="javascript">// 1.切记： 页面中的数据，都要从本地存储里面获取，这样刷新页面不会丢失数据，所以先要把数据保存到本地存储里面。// 2.利用事件对象.keyCode判断用户按下回车键（13）。// 3.声明一个数组，保存数据。// 4.先要读取本地存储原来的数据（声明函数 getData()），放到这个数组里面。// 5.之后把最新从表单获取过来的数据，追加到数组里面。// 6.最后把数组存储给本地存储 (声明函数 savaDate())</code></pre><h3 id="1-7-4-案例：toDoList-本地存储数据渲染加载到页面"><a href="#1-7-4-案例：toDoList-本地存储数据渲染加载到页面" class="headerlink" title="1.7.4 案例：toDoList 本地存储数据渲染加载到页面"></a>1.7.4 案例：toDoList 本地存储数据渲染加载到页面</h3><pre><code class="javascript">// 1.因为后面也会经常渲染加载操作，所以声明一个函数 load，方便后面调用// 2.先要读取本地存储数据。（数据不要忘记转换为对象格式）// 3.之后遍历这个数据（$.each()），有几条数据，就生成几个小li 添加到 ol 里面。// 4.每次渲染之前，先把原先里面 ol 的内容清空，然后渲染加载最新的数据。</code></pre><h3 id="1-7-5-案例：toDoList-删除操作"><a href="#1-7-5-案例：toDoList-删除操作" class="headerlink" title="1.7.5 案例：toDoList 删除操作"></a>1.7.5 案例：toDoList 删除操作</h3><pre><code class="javascript">// 1.点击里面的a链接，不是删除的li，而是删除本地存储对应的数据。// 2.核心原理：先获取本地存储数据，删除对应的数据，保存给本地存储，重新渲染列表li// 3.我们可以给链接自定义属性记录当前的索引号// 4.根据这个索引号删除相关的数据----数组的splice(i, 1)方法// 5.存储修改后的数据，然后存储给本地存储// 6.重新渲染加载数据列表// 7.因为a是动态创建的，我们使用on方法绑定事件</code></pre><h3 id="1-7-6-案例：toDoList-正在进行和已完成选项操作"><a href="#1-7-6-案例：toDoList-正在进行和已完成选项操作" class="headerlink" title="1.7.6 案例：toDoList 正在进行和已完成选项操作"></a>1.7.6 案例：toDoList 正在进行和已完成选项操作</h3><pre><code class="javascript">// 1.当我们点击了小的复选框，修改本地存储数据，再重新渲染数据列表。// 2.点击之后，获取本地存储数据。// 3.修改对应数据属性 done 为当前复选框的checked状态。// 4.之后保存数据到本地存储// 5.重新渲染加载数据列表// 6.load 加载函数里面，新增一个条件,如果当前数据的done为true 就是已经完成的，就把列表渲染加载到 ul 里面// 7.如果当前数据的done 为false， 则是待办事项，就把列表渲染加载到 ol 里面</code></pre><h3 id="1-7-7-案例：toDoList-统计正在进行个数和已经完成个数"><a href="#1-7-7-案例：toDoList-统计正在进行个数和已经完成个数" class="headerlink" title="1.7.7 案例：toDoList 统计正在进行个数和已经完成个数"></a>1.7.7 案例：toDoList 统计正在进行个数和已经完成个数</h3><pre><code class="javascript">// 1.在我们load 函数里面操作// 2.声明2个变量 ：todoCount 待办个数  doneCount 已完成个数// 3.当进行遍历本地存储数据的时候， 如果 数据done为 false， 则 todoCount++, 否则 doneCount++// 4.最后修改相应的元素 text()</code></pre><h2 id="1-8-今日总结"><a href="#1-8-今日总结" class="headerlink" title="1.8. 今日总结"></a>1.8. 今日总结</h2><p><img src="images/%E6%80%BB%E7%BB%93.png#crop=0&crop=0&crop=1&crop=1&id=M74oU&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&title="></p>]]></content>
      
      
      <categories>
          
          <category> 👨‍💻Web开发 </category>
          
          <category> jQuery </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>jQuery元素+属性操作</title>
      <link href="/blog/2_day02_jquery/"/>
      <url>/blog/2_day02_jquery/</url>
      
        <content type="html"><![CDATA[<h2 id="jQuery-属性操作"><a href="#jQuery-属性操作" class="headerlink" title="jQuery 属性操作"></a>jQuery 属性操作</h2><p>jQuery 常用属性操作有三种：prop() / attr() / data() ;</p><h3 id="元素固有属性值-prop"><a href="#元素固有属性值-prop" class="headerlink" title="元素固有属性值 prop()"></a>元素固有属性值 prop()</h3><p>所谓元素固有属性就是元素本身自带的属性，比如 元素里面的 href ，比如 元素里面的 type。<br><strong>语法</strong><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616073492194-d6d9ff5b-5c98-495b-bebb-c3be7790bbf4.png#crop=0&crop=0&crop=1&crop=1&height=185&id=F3BQ7&originHeight=185&originWidth=619&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&title=&width=619"><br>注意：prop() 除了普通属性操作，更适合操作表单属性：disabled / checked / selected 等。</p><h3 id="元素自定义属性值-attr"><a href="#元素自定义属性值-attr" class="headerlink" title="元素自定义属性值 attr()"></a>元素自定义属性值 attr()</h3><p>用户自己给元素添加的属性，我们称为自定义属性。 比如给 div 添加 index =“1”。<br><strong>语法</strong><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616073492261-f36c35ad-cba6-4c24-ac2d-18781c30b41a.png#crop=0&crop=0&crop=1&crop=1&height=231&id=ULnKR&originHeight=231&originWidth=616&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&title=&width=616"><br>注意：attr() 除了普通属性操作，更适合操作自定义属性。（该方法也可以获取 H5 自定义属性）</p><h3 id="数据缓存-data"><a href="#数据缓存-data" class="headerlink" title="数据缓存 data()"></a>数据缓存 data()</h3><pre><code>data() 方法可以在指定的元素上存取数据，并不会修改 DOM 元素结构。一旦页面刷新，之前存放的数据都将被移除。</code></pre><p><strong>语法</strong><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616073492334-8d7a046e-854f-4449-a169-2820244ff75f.png#crop=0&crop=0&crop=1&crop=1&height=169&id=teEJx&originHeight=169&originWidth=616&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&title=&width=616"><br>注意：同时，还可以读取 HTML5 自定义属性 data-index ，得到的是数字型。<br><strong>演示代码</strong></p><pre><code class="javascript">&lt;body&gt;    &lt;a href=&quot;http://www.itcast.cn&quot; title=&quot;都挺好&quot;&gt;都挺好&lt;/a&gt;    &lt;input type=&quot;checkbox&quot; name=&quot;&quot; id=&quot;&quot; checked&gt;    &lt;div index=&quot;1&quot; data-index=&quot;2&quot;&gt;我是div&lt;/div&gt;    &lt;span&gt;123&lt;/span&gt;    &lt;script&gt;        $(function() &#123;            //1. element.prop(&quot;属性名&quot;) 获取元素固有的属性值            console.log($(&quot;a&quot;).prop(&quot;href&quot;));            $(&quot;a&quot;).prop(&quot;title&quot;, &quot;我们都挺好&quot;);            $(&quot;input&quot;).change(function() &#123;                console.log($(this).prop(&quot;checked&quot;));            &#125;);            // console.log($(&quot;div&quot;).prop(&quot;index&quot;));            // 2. 元素的自定义属性 我们通过 attr()            console.log($(&quot;div&quot;).attr(&quot;index&quot;));            $(&quot;div&quot;).attr(&quot;index&quot;, 4);            console.log($(&quot;div&quot;).attr(&quot;data-index&quot;));            // 3. 数据缓存 data() 这个里面的数据是存放在元素的内存里面            $(&quot;span&quot;).data(&quot;uname&quot;, &quot;andy&quot;);            console.log($(&quot;span&quot;).data(&quot;uname&quot;));            // 这个方法获取data-index h5自定义属性 第一个 不用写data-  而且返回的是数字型            console.log($(&quot;div&quot;).data(&quot;index&quot;));        &#125;)    &lt;/script&gt;&lt;/body&gt;</code></pre><h2 id="jQuery-文本属性值"><a href="#jQuery-文本属性值" class="headerlink" title="jQuery 文本属性值"></a>jQuery 文本属性值</h2><p>jQuery 的文本属性值常见操作有三种：html() / text() / val() ; 分别对应 JS 中的 innerHTML 、innerText 和 value 属性。</p><h3 id="jQuery-内容文本值"><a href="#jQuery-内容文本值" class="headerlink" title="jQuery 内容文本值"></a>jQuery 内容文本值</h3><p>常见操作有三种：html() / text() / val() ; 分别对应 JS 中的 innerHTML 、innerText 和 value 属性，主要针对元素的内容还有表单的值操作。<br><strong>语法</strong><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616073492400-d8ee58ad-1d5e-42a0-a07f-52d7558fb341.png#crop=0&crop=0&crop=1&crop=1&height=425&id=WFDE9&originHeight=425&originWidth=663&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&title=&width=663"><br>注意：html() 可识别标签，text() 不识别标签。<br><strong>演示代码</strong></p><pre><code class="javascript">&lt;body&gt;    &lt;div&gt;        &lt;span&gt;我是内容&lt;/span&gt;    &lt;/div&gt;    &lt;input type=&quot;text&quot; value=&quot;请输入内容&quot;&gt;    &lt;script&gt;        // 1. 获取设置元素内容 html()        console.log($(&quot;div&quot;).html());        // $(&quot;div&quot;).html(&quot;123&quot;);        // 2. 获取设置元素文本内容 text()        console.log($(&quot;div&quot;).text());        $(&quot;div&quot;).text(&quot;123&quot;);        // 3. 获取设置表单值 val()        console.log($(&quot;input&quot;).val());        $(&quot;input&quot;).val(&quot;123&quot;);    &lt;/script&gt;&lt;/body&gt;</code></pre><h2 id="jQuery-元素操作"><a href="#jQuery-元素操作" class="headerlink" title="jQuery 元素操作"></a>jQuery 元素操作</h2><p>jQuery 元素操作主要讲的是用 jQuery 方法，操作标签的遍历、创建、添加、删除等操作。</p><h3 id="遍历元素"><a href="#遍历元素" class="headerlink" title="遍历元素"></a>遍历元素</h3><p>jQuery 隐式迭代是对同一类元素做了同样的操作。 如果想要给同一类元素做不同操作，就需要用到遍历。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616073492472-0f31ef63-133b-40cf-b438-391dde571eb4.png#crop=0&crop=0&crop=1&crop=1&height=177&id=kRNyG&originHeight=177&originWidth=622&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&title=&width=622"><br>注意：此方法用于遍历 jQuery 对象中的每一项，回调函数中元素为 DOM 对象，想要使用 jQuery 方法需要转换。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616073492553-9c2ac31d-49a0-4e91-bf4e-d2279e74ff32.png#crop=0&crop=0&crop=1&crop=1&height=146&id=W8TwJ&originHeight=146&originWidth=617&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&title=&width=617"><br>注意：此方法用于遍历 jQuery 对象中的每一项，回调函数中元素为 DOM 对象，想要使用 jQuery 方法需要转换。<br><strong>演示代码</strong></p><pre><code class="javascript">&lt;body&gt;    &lt;div&gt;1&lt;/div&gt;    &lt;div&gt;2&lt;/div&gt;    &lt;div&gt;3&lt;/div&gt;    &lt;script&gt;        $(function() &#123;            // 如果针对于同一类元素做不同操作，需要用到遍历元素（类似for，但是比for强大）            var sum = 0;            var arr = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;];            // 1. each() 方法遍历元素            $(&quot;div&quot;).each(function(i, domEle) &#123;                // 回调函数第一个参数一定是索引号  可以自己指定索引号号名称                // console.log(i);                // 回调函数第二个参数一定是 dom 元素对象，也是自己命名                // console.log(domEle);  // 使用jQuery方法需要转换 $(domEle)                $(domEle).css(&quot;color&quot;, arr[i]);                sum += parseInt($(domEle).text());            &#125;)            console.log(sum);            // 2. $.each() 方法遍历元素 主要用于遍历数据，处理数据            // $.each($(&quot;div&quot;), function(i, ele) &#123;            //     console.log(i);            //     console.log(ele);            // &#125;);            // $.each(arr, function(i, ele) &#123;            //     console.log(i);            //     console.log(ele);            // &#125;)            $.each(&#123;                name: &quot;andy&quot;,                age: 18            &#125;, function(i, ele) &#123;                console.log(i); // 输出的是 name age 属性名                console.log(ele); // 输出的是 andy  18 属性值            &#125;)        &#125;)    &lt;/script&gt;&lt;/body&gt;</code></pre><h3 id="创建、添加、删除"><a href="#创建、添加、删除" class="headerlink" title="创建、添加、删除"></a>创建、添加、删除</h3><p>jQuery 方法操作元素的创建、添加、删除方法很多，则重点使用部分，如下：<br><strong>语法总和</strong><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616073492632-06694ce7-f376-454f-9c85-c4f7a0ba0338.png#crop=0&crop=0&crop=1&crop=1&height=115&id=yRDsg&originHeight=115&originWidth=624&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&title=&width=624"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616073492709-dbf5e1ae-fcee-4283-8cc2-5ecb0bcc1b83.png#crop=0&crop=0&crop=1&crop=1&height=206&id=jQMTc&originHeight=206&originWidth=623&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&title=&width=623"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616073492783-28f74b87-b629-477d-9ca2-47e4588c4b96.png#crop=0&crop=0&crop=1&crop=1&height=208&id=YQmbb&originHeight=208&originWidth=621&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&title=&width=621"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616073492861-e9f292d0-aaf9-4b05-b013-77a589f3bf2a.png#crop=0&crop=0&crop=1&crop=1&height=230&id=YVMfw&originHeight=230&originWidth=625&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&title=&width=625"><br>注意：以上只是元素的创建、添加、删除方法的常用方法，其他方法请参详 API。<br><strong>案例代码</strong></p><pre><code class="html">&lt;body&gt;  &lt;ul&gt;    &lt;li&gt;原先的li&lt;/li&gt;  &lt;/ul&gt;  &lt;div class=&quot;test&quot;&gt;我是原先的div&lt;/div&gt;  &lt;script&gt;    $(function () &#123;      // 1. 创建元素      var li = $(&quot;&lt;li&gt;我是后来创建的li&lt;/li&gt;&quot;);      // 2. 添加元素      //     2.1 内部添加      // $(&quot;ul&quot;).append(li);  内部添加并且放到内容的最后面      $(&quot;ul&quot;).prepend(li); // 内部添加并且放到内容的最前面      //  2.2 外部添加      var div = $(&quot;&lt;div&gt;我是后妈生的&lt;/div&gt;&quot;);      // $(&quot;.test&quot;).after(div);      $(&quot;.test&quot;).before(div);      // 3. 删除元素      // $(&quot;ul&quot;).remove(); 可以删除匹配的元素 自杀      // $(&quot;ul&quot;).empty(); // 可以删除匹配的元素里面的子节点 孩子      $(&quot;ul&quot;).html(&quot;&quot;); // 可以删除匹配的元素里面的子节点 孩子    &#125;);  &lt;/script&gt;&lt;/body&gt;</code></pre><h2 id="jQuery-尺寸、位置操作"><a href="#jQuery-尺寸、位置操作" class="headerlink" title="jQuery 尺寸、位置操作"></a>jQuery 尺寸、位置操作</h2><p>jQuery 中分别为我们提供了两套快速获取和设置元素尺寸和位置的 API，方便易用，内容如下。</p><h3 id="jQuery-尺寸操作"><a href="#jQuery-尺寸操作" class="headerlink" title="jQuery 尺寸操作"></a>jQuery 尺寸操作</h3><p>jQuery 尺寸操作包括元素宽高的获取和设置，且不一样的 API 对应不一样的盒子模型。<br><strong>语法</strong><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616073492939-79b5b959-2700-496c-adb0-d049e25f6490.png#crop=0&crop=0&crop=1&crop=1&height=260&id=sD1iA&originHeight=260&originWidth=629&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&title=&width=629"><br><strong>代码演示</strong></p><pre><code class="javascript">&lt;body&gt;    &lt;div&gt;&lt;/div&gt;    &lt;script&gt;        $(function() &#123;            // 1. width() / height() 获取设置元素 width和height大小            console.log($(&quot;div&quot;).width());            // $(&quot;div&quot;).width(300);            // 2. innerWidth() / innerHeight()  获取设置元素 width和height + padding 大小            console.log($(&quot;div&quot;).innerWidth());            // 3. outerWidth()  / outerHeight()  获取设置元素 width和height + padding + border 大小            console.log($(&quot;div&quot;).outerWidth());            // 4. outerWidth(true) / outerHeight(true) 获取设置 width和height + padding + border + margin            console.log($(&quot;div&quot;).outerWidth(true));        &#125;)    &lt;/script&gt;&lt;/body&gt;</code></pre><p>注意：有了这套 API 我们将可以快速获取和子的宽高，至于其他属性想要获取和设置，还要使用 css() 等方法配合。</p><h3 id="jQuery-位置操作"><a href="#jQuery-位置操作" class="headerlink" title="jQuery 位置操作"></a>jQuery 位置操作</h3><p>jQuery 的位置操作主要有三个： offset()、position()、scrollTop()/scrollLeft() , 具体介绍如下:<br><strong>语法</strong><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616073493024-1b363784-6614-4dd9-8ddc-dd97531a3cb6.png#crop=0&crop=0&crop=1&crop=1&height=129&id=No6MP&originHeight=129&originWidth=663&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&title=&width=663"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616073493095-d18b82ae-83d0-465b-bf27-4fb9449ee6c6.png#crop=0&crop=0&crop=1&crop=1&height=151&id=uRPbe&originHeight=151&originWidth=663&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&title=&width=663"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616073493171-f3d23a41-7256-4fe7-9818-1624a3ab45ce.png#crop=0&crop=0&crop=1&crop=1&height=100&id=q9MPG&originHeight=100&originWidth=663&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&title=&width=663"><br><strong>代码演示</strong></p><pre><code class="javascript">&lt;body&gt;    &lt;div class=&quot;father&quot;&gt;        &lt;div class=&quot;son&quot;&gt;&lt;/div&gt;    &lt;/div&gt;    &lt;div class=&quot;back&quot;&gt;返回顶部&lt;/div&gt;    &lt;div class=&quot;container&quot;&gt;&lt;/div&gt;    &lt;script&gt;        $(function() &#123;            // 1. 获取设置距离文档的位置（偏移） offset            console.log($(&quot;.son&quot;).offset());            console.log($(&quot;.son&quot;).offset().top);            // $(&quot;.son&quot;).offset(&#123;            //     top: 200,            //     left: 200            // &#125;);            // 2. 获取距离带有定位父级位置（偏移） position   如果没有带有定位的父级，则以文档为准            // 这个方法只能获取不能设置偏移            console.log($(&quot;.son&quot;).position());            // $(&quot;.son&quot;).position(&#123;            //     top: 200,            //     left: 200            // &#125;);              // 3. 被卷去的头部              $(document).scrollTop(100);            // 被卷去的头部 scrollTop()  / 被卷去的左侧 scrollLeft()            // 页面滚动事件            var boxTop = $(&quot;.container&quot;).offset().top;            $(window).scroll(function() &#123;                // console.log(11);                console.log($(document).scrollTop());                if ($(document).scrollTop() &gt;= boxTop) &#123;                    $(&quot;.back&quot;).fadeIn();                &#125; else &#123;                    $(&quot;.back&quot;).fadeOut();                &#125;            &#125;);            // 返回顶部            $(&quot;.back&quot;).click(function() &#123;                // $(document).scrollTop(0);                $(&quot;body, html&quot;).stop().animate(&#123;                    scrollTop: 0                &#125;);                // $(document).stop().animate(&#123;                //     scrollTop: 0                // &#125;); 不能是文档而是 html和body元素做动画            &#125;)        &#125;)    &lt;/script&gt;&lt;/body&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 👨‍💻Web开发 </category>
          
          <category> jQuery </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>jQuery选择器+样式操作+动画效果</title>
      <link href="/blog/1_day01_jquery/"/>
      <url>/blog/1_day01_jquery/</url>
      
        <content type="html"><![CDATA[<h2 id="jQuery-介绍"><a href="#jQuery-介绍" class="headerlink" title="jQuery 介绍"></a>jQuery 介绍</h2><h3 id="JavaScript-库"><a href="#JavaScript-库" class="headerlink" title="JavaScript 库"></a>JavaScript 库</h3><p>JavaScript 库：即 library，是一个封装好的特定的集合（方法和函数）。从封装一大堆函数的角度理解库，就是在这个库中，封装了很多预先定义好的函数在里面，比如动画 animate、hide、show，比如获取元素等。</p><blockquote><p>简单理解： 就是一个 JS 文件，里面对我们原生 js 代码进行了封装，存放到里面。这样我们可以快速高效的使用这些封装好的功能了。<br>比如 jQuery，就是为了快速方便的操作 DOM，里面基本都是函数（方法）。</p></blockquote><p>常见的 JavaScript 库：jQuery、Prototype、YUI、Dojo、Ext JS、移动端的 zepto 等，这些库都是对原生 JavaScript 的封装，内部都是用 JavaScript 实现的，我们主要学习的是 jQuery。</p><h3 id="jQuery-的概念"><a href="#jQuery-的概念" class="headerlink" title="jQuery 的概念"></a>jQuery 的概念</h3><p>jQuery 总体概况如下 :</p><ul><li>jQuery 是一个快速、简洁的 JavaScript 库，其设计的宗旨是“write Less，Do More”，即倡导写更少的代码，做更多的事情。</li><li>j 就是 JavaScript； Query 查询； 意思就是查询 js，把 js 中的 DOM 操作做了封装，我们可以快速的查询使用里面的功能。</li><li>jQuery 封装了 JavaScript 常用的功能代码，优化了 DOM 操作、事件处理、动画设计和 Ajax 交互。</li><li>学习 jQuery 本质： 就是学习调用这些函数（方法）。</li><li>jQuery 出现的目的是加快前端人员的开发速度，我们可以非常方便的调用和使用它，从而提高开发效率。</li></ul><h3 id="jQuery-的优点"><a href="#jQuery-的优点" class="headerlink" title="jQuery 的优点"></a>jQuery 的优点</h3><ol><li>轻量级。核心文件才几十 kb，不会影响页面加载速度。</li><li>跨浏览器兼容，基本兼容了现在主流的浏览器。</li><li>链式编程、隐式迭代。</li><li>对事件、样式、动画支持，大大简化了 DOM 操作。</li><li>支持插件扩展开发。有着丰富的第三方的插件，例如：树形菜单、日期控件、轮播图等。</li><li>免费、开源。</li></ol><h2 id="jQuery-的基本使用"><a href="#jQuery-的基本使用" class="headerlink" title="jQuery 的基本使用"></a>jQuery 的基本使用</h2><h3 id="jQuery-的下载"><a href="#jQuery-的下载" class="headerlink" title="jQuery 的下载"></a>jQuery 的下载</h3><p>jQuery 的官网地址： <a href="https://jquery.com/">https://jquery.com/</a>，官网即可下载最新版本。</p><blockquote><p>各个版本的下载：<a href="https://code.jquery.com/">https://code.jquery.com/</a></p></blockquote><p>版本介绍：</p><blockquote><p>1x ：兼容 IE 678 等低版本浏览器， 官网不再更新<br>2x ：不兼容 IE 678 等低版本浏览器， 官网不再更新<br>3x ：不兼容 IE 678 等低版本浏览器， 是官方主要更新维护的版本</p></blockquote><h3 id="jQuery-的入口函数"><a href="#jQuery-的入口函数" class="headerlink" title="jQuery 的入口函数"></a>jQuery 的入口函数</h3><p>jQuery 中常见的两种入口函数：</p><pre><code class="javascript">// 第一种: 简单易用。$(function () &#123;    ...  // 此处是页面 DOM 加载完成的入口&#125;) ;// 第二种: 繁琐，但是也可以实现$(document).ready(function()&#123;   ...  //  此处是页面DOM加载完成的入口&#125;);</code></pre><p>总结：</p><ol><li>等着 DOM 结构渲染完毕即可执行内部代码，不必等到所有外部资源加载完成，jQuery 帮我们完成了封装。</li><li>相当于原生 js 中的 DOMContentLoaded。</li><li>不同于原生 js 中的 load 事件是等页面文档、外部的 js 文件、css 文件、图片加载完毕才执行内部代码。</li><li>更推荐使用第一种方式。</li></ol><h3 id="jQuery-中的顶级对象"><a href="#jQuery-中的顶级对象" class="headerlink" title="jQuery 中的顶级对象$"></a>jQuery 中的顶级对象$</h3><ol><li>$是 jQuery 的别称，在代码中可以使用 jQuery 代替，但一般为了方便，通常都直接使用 $ 。</li><li>$是jQuery的顶级对象，相当于原生JavaScript中的 window。把元素利用$包装成 jQuery 对象，就可以调用 jQuery 的方法。</li></ol><h3 id="jQuery-对象和-DOM-对象"><a href="#jQuery-对象和-DOM-对象" class="headerlink" title="jQuery 对象和 DOM 对象"></a>jQuery 对象和 DOM 对象</h3><p>使用 jQuery 方法和原生 JS 获取的元素是不一样的，总结如下 :</p><ol><li>用原生 JS 获取来的对象就是 DOM 对象</li><li>jQuery 方法获取的元素就是 jQuery 对象。</li><li>jQuery 对象本质是： 利用$对 DOM 对象包装后产生的对象（伪数组形式存储）。<blockquote><p>注意：<br>只有 jQuery 对象才能使用 jQuery 方法，DOM 对象则使用原生的 JavaScirpt 方法。</p></blockquote></li></ol><h3 id="jQuery-对象和-DOM-对象转换"><a href="#jQuery-对象和-DOM-对象转换" class="headerlink" title="jQuery 对象和 DOM 对象转换"></a>jQuery 对象和 DOM 对象转换</h3><p>DOM 对象与 jQuery 对象之间是可以相互转换的。因为原生 js 比 jQuery 更大，原生的一些属性和方法 jQuery 没有给我们封装. 要想使用这些属性和方法需要把 jQuery 对象转换为 DOM 对象才能使用。</p><pre><code class="javascript">// 1.DOM对象转换成jQuery对象，方法只有一种var box = document.getElementById(&quot;box&quot;); // 获取DOM对象var jQueryObject = $(box); // 把DOM对象转换为 jQuery 对象// 2.jQuery 对象转换为 DOM 对象有两种方法：//   2.1 jQuery对象[索引值]var domObject1 = $(&quot;div&quot;)[0];//   2.2 jQuery对象.get(索引值)var domObject2 = $(&quot;div&quot;).get(0);</code></pre><p>总结：实际开发比较常用的是把 DOM 对象转换为 jQuery 对象，这样能够调用功能更加强大的 jQuery 中的方法。</p><h2 id="jQuery-选择器"><a href="#jQuery-选择器" class="headerlink" title="jQuery 选择器"></a>jQuery 选择器</h2><p>原生 JS 获取元素方式很多，很杂，而且兼容性情况不一致，因此 jQuery 给我们做了封装，使获取元素统一标准。<br>参考：<a href="https://www.runoob.com/jquery/jquery-selectors.html">https://www.runoob.com/jquery/jquery-selectors.html</a></p><h3 id="基础选择器"><a href="#基础选择器" class="headerlink" title="基础选择器"></a>基础选择器</h3><pre><code class="js">$(&quot;选择器&quot;); //  里面选择器直接写 CSS 选择器即可，但是要加引号</code></pre><h3 id="层级选择器"><a href="#层级选择器" class="headerlink" title="层级选择器"></a>层级选择器</h3><p>层级选择器最常用的两个分别为：后代选择器和子代选择器。<br><strong>基础选择器和层级选择器案例代码</strong></p><pre><code class="javascript">&lt;body&gt;    &lt;div&gt;我是div&lt;/div&gt;    &lt;div class=&quot;nav&quot;&gt;我是nav div&lt;/div&gt;    &lt;p&gt;我是p&lt;/p&gt;    &lt;ul&gt;        &lt;li&gt;我是ul 的&lt;/li&gt;        &lt;li&gt;我是ul 的&lt;/li&gt;        &lt;li&gt;我是ul 的&lt;/li&gt;    &lt;/ul&gt;    &lt;script&gt;        $(function() &#123;            console.log($(&quot;.nav&quot;));            console.log($(&quot;ul li&quot;));        &#125;)    &lt;/script&gt;&lt;/body&gt;</code></pre><h3 id="筛选选择器"><a href="#筛选选择器" class="headerlink" title="筛选选择器"></a>筛选选择器</h3><p>筛选选择器，顾名思义就是在所有的选项中选择满足条件的进行筛选选择。常见如下 :</p><pre><code class="html">&lt;body&gt;  &lt;ul&gt;    &lt;li&gt;多个里面筛选几个&lt;/li&gt;    &lt;li&gt;多个里面筛选几个&lt;/li&gt;    &lt;li&gt;多个里面筛选几个&lt;/li&gt;    &lt;li&gt;多个里面筛选几个&lt;/li&gt;    &lt;li&gt;多个里面筛选几个&lt;/li&gt;    &lt;li&gt;多个里面筛选几个&lt;/li&gt;  &lt;/ul&gt;  &lt;ol&gt;    &lt;li&gt;多个里面筛选几个&lt;/li&gt;    &lt;li&gt;多个里面筛选几个&lt;/li&gt;    &lt;li&gt;多个里面筛选几个&lt;/li&gt;    &lt;li&gt;多个里面筛选几个&lt;/li&gt;    &lt;li&gt;多个里面筛选几个&lt;/li&gt;    &lt;li&gt;多个里面筛选几个&lt;/li&gt;  &lt;/ol&gt;  &lt;script&gt;    $(function () &#123;      $(&quot;ul li:first&quot;).css(&quot;color&quot;, &quot;red&quot;);      $(&quot;ul li:eq(2)&quot;).css(&quot;color&quot;, &quot;blue&quot;);      $(&quot;ol li:odd&quot;).css(&quot;color&quot;, &quot;skyblue&quot;);      $(&quot;ol li:even&quot;).css(&quot;color&quot;, &quot;pink&quot;);    &#125;);  &lt;/script&gt;&lt;/body&gt;</code></pre><p>另: jQuery 中还有一些筛选方法，类似 DOM 中的通过一个节点找另外一个节点，父、子、兄以外有所加强。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616073490928-8c91de0f-b9b1-41c3-8a06-ab51b23cfb98.png#crop=0&crop=0&crop=1&crop=1&height=471&id=oIGOe&originHeight=471&originWidth=1002&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&title=&width=1002"></p><h2 id="jQuery-样式操作"><a href="#jQuery-样式操作" class="headerlink" title="jQuery 样式操作"></a>jQuery 样式操作</h2><p>jQuery 中常用的样式操作有两种：css() 和 设置类样式方法</p><h3 id="方法-1-操作-css-方法"><a href="#方法-1-操作-css-方法" class="headerlink" title="方法 1: 操作 css 方法"></a>方法 1: 操作 css 方法</h3><p>jQuery 可以使用 css 方法来修改简单元素样式； 也可以操作类，修改多个样式。常用以下三种形式 :</p><pre><code class="javascript">// 1.参数只写属性名，则是返回属性值var strColor = $(this).css(&#39;color&#39;);// 2.参数是属性名，属性值，逗号分隔，是设置一组样式，属性必须加引号，值如果是数字可以不用跟单位和引号$(this).css(&#39;&#39;color&#39;&#39;, &#39;&#39;red&#39;&#39;);// 3.  参数可以是对象形式，方便设置多组样式。属性名和属性值用冒号隔开， 属性可以不用加引号$(this).css(&#123; &quot;color&quot;:&quot;white&quot;,&quot;font-size&quot;:&quot;20px&quot;&#125;);</code></pre><p>注意：css() 多用于样式少时操作，多了则不太方便。</p><h3 id="方法-2-设置类样式方法"><a href="#方法-2-设置类样式方法" class="headerlink" title="方法 2: 设置类样式方法"></a>方法 2: 设置类样式方法</h3><p>作用等同于以前的 classList，可以操作类样式， 注意操作类里面的参数不要加点。常用的三种设置类样式方法：</p><pre><code class="javascript">// 1.添加类$(&quot;div&quot;).addClass(&quot;current&quot;);// 2.删除类$(&quot;div&quot;).removeClass(&quot;current&quot;);// 3.切换类$(&quot;div&quot;).toggleClass(&quot;current&quot;);</code></pre><p>注意：</p><ol><li>设置类样式方法比较适合样式多时操作，可以弥补 css()的不足。</li><li>原生 JS 中 className 会覆盖元素原先里面的类名，jQuery 里面类操作只是对指定类进行操作，不影响原先的类名。</li></ol><h2 id="jQuery-效果"><a href="#jQuery-效果" class="headerlink" title="jQuery 效果"></a>jQuery 效果</h2><p>jQuery 给我们封装了很多动画效果，最为常见的如下：</p><ul><li>显示隐藏：show() / hide() / toggle() ;</li><li>划入画出：slideDown() / slideUp() / slideToggle() ;</li><li>淡入淡出：fadeIn() / fadeOut() / fadeToggle() / fadeTo() ;</li><li>自定义动画：animate() ;<blockquote><p>注意：<br>动画或者效果一旦触发就会执行，如果多次触发，就造成多个动画或者效果排队执行。<br>jQuery 为我们提供另一个方法，可以停止动画排队：stop() ;</p></blockquote></li></ul><h3 id="显示隐藏切换"><a href="#显示隐藏切换" class="headerlink" title="显示隐藏切换"></a>显示隐藏切换</h3><p>显示隐藏动画，常见有三个方法：show() / hide() / toggle() ;<br>语法规范如下:<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616073491028-773a9d46-839b-4afc-bee1-17d55ed0a4ad.png#crop=0&crop=0&crop=1&crop=1&height=260&id=q0jwB&originHeight=260&originWidth=624&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&title=&width=624"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616073491164-e18ddc74-6cd9-4758-98be-8a4ba4a5659b.png#crop=0&crop=0&crop=1&crop=1&height=260&id=Jbw7X&originHeight=260&originWidth=624&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&title=&width=624"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616073491265-475bb990-b1e3-4aa8-b58a-089a14539935.png#crop=0&crop=0&crop=1&crop=1&height=284&id=j1sLx&originHeight=284&originWidth=625&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&title=&width=625"><br><strong>代码演示</strong></p><pre><code class="javascript">&lt;body&gt;    &lt;button&gt;显示&lt;/button&gt;    &lt;button&gt;隐藏&lt;/button&gt;    &lt;button&gt;切换&lt;/button&gt;    &lt;div&gt;&lt;/div&gt;    &lt;script&gt;        $(function() &#123;            $(&quot;button&quot;).eq(0).click(function() &#123;                $(&quot;div&quot;).show(1000, function() &#123;                    alert(1);                &#125;);            &#125;)            $(&quot;button&quot;).eq(1).click(function() &#123;                $(&quot;div&quot;).hide(1000, function() &#123;                    alert(1);                &#125;);            &#125;)            $(&quot;button&quot;).eq(2).click(function() &#123;              $(&quot;div&quot;).toggle(1000);            &#125;)            // 一般情况下，我们都不加参数直接显示隐藏就可以了        &#125;);    &lt;/script&gt;&lt;/body&gt;</code></pre><h3 id="滑入滑出"><a href="#滑入滑出" class="headerlink" title="滑入滑出"></a>滑入滑出</h3><pre><code>滑入滑出动画，常见有三个方法：slideDown() / slideUp() / slideToggle() ;语法规范如下:</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616073491339-dc77fd79-125f-48b7-a6e8-3d44db54fba8.png#crop=0&crop=0&crop=1&crop=1&height=260&id=WXVZd&originHeight=260&originWidth=624&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&title=&width=624"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616073491433-2cf9c8e4-43ce-4c72-849f-2d23bf822215.png#crop=0&crop=0&crop=1&crop=1&height=260&id=DlH5f&originHeight=260&originWidth=624&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&title=&width=624"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616073491518-8e00011c-f004-4d1b-81f4-e0ade442f00f.png#crop=0&crop=0&crop=1&crop=1&height=250&id=L8ZSu&originHeight=250&originWidth=624&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&title=&width=624"><br><strong>代码演示</strong></p><pre><code class="javascript">&lt;body&gt;    &lt;button&gt;下拉滑动&lt;/button&gt;    &lt;button&gt;上拉滑动&lt;/button&gt;    &lt;button&gt;切换滑动&lt;/button&gt;    &lt;div&gt;&lt;/div&gt;    &lt;script&gt;        $(function() &#123;            $(&quot;button&quot;).eq(0).click(function() &#123;                // 下滑动 slideDown()                $(&quot;div&quot;).slideDown();            &#125;)            $(&quot;button&quot;).eq(1).click(function() &#123;                // 上滑动 slideUp()                $(&quot;div&quot;).slideUp(500);            &#125;)            $(&quot;button&quot;).eq(2).click(function() &#123;                // 滑动切换 slideToggle()                $(&quot;div&quot;).slideToggle(500);            &#125;);        &#125;);    &lt;/script&gt;&lt;/body&gt;</code></pre><h3 id="淡入淡出"><a href="#淡入淡出" class="headerlink" title="淡入淡出"></a>淡入淡出</h3><pre><code>淡入淡出动画，常见有四个方法：fadeIn() / fadeOut() / fadeToggle() / fadeTo() ;语法规范如下:</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616073491592-b675c8b8-6d7a-40b5-a4be-d51dc9bd1c86.png#crop=0&crop=0&crop=1&crop=1&height=260&id=bTN9b&originHeight=260&originWidth=624&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&title=&width=624"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616073491668-703fa0c6-d2f4-48e6-a78c-5db0cb33df17.png#crop=0&crop=0&crop=1&crop=1&height=250&id=B9SjO&originHeight=250&originWidth=624&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&title=&width=624"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616073491743-2587d517-38fd-4633-9273-d99234bb35e4.png#crop=0&crop=0&crop=1&crop=1&height=260&id=lDuyr&originHeight=260&originWidth=624&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&title=&width=624"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616073491838-9409127c-665d-4c7e-b4b0-180ef10ffa61.png#crop=0&crop=0&crop=1&crop=1&height=255&id=VB0bu&originHeight=255&originWidth=664&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&title=&width=664"><br><strong>代码演示</strong></p><pre><code class="javascript">&lt;body&gt;    &lt;button&gt;淡入效果&lt;/button&gt;    &lt;button&gt;淡出效果&lt;/button&gt;    &lt;button&gt;淡入淡出切换&lt;/button&gt;    &lt;button&gt;修改透明度&lt;/button&gt;    &lt;div&gt;&lt;/div&gt;    &lt;script&gt;        $(function() &#123;            $(&quot;button&quot;).eq(0).click(function() &#123;                // 淡入 fadeIn()                $(&quot;div&quot;).fadeIn(1000);            &#125;)            $(&quot;button&quot;).eq(1).click(function() &#123;                // 淡出 fadeOut()                $(&quot;div&quot;).fadeOut(1000);            &#125;)            $(&quot;button&quot;).eq(2).click(function() &#123;                // 淡入淡出切换 fadeToggle()                $(&quot;div&quot;).fadeToggle(1000);            &#125;);            $(&quot;button&quot;).eq(3).click(function() &#123;                //  修改透明度 fadeTo() 这个速度和透明度要必须写                $(&quot;div&quot;).fadeTo(1000, 0.5);            &#125;);        &#125;);    &lt;/script&gt;&lt;/body&gt;</code></pre><h3 id="自定义动画"><a href="#自定义动画" class="headerlink" title="自定义动画"></a>自定义动画</h3><p>自定义动画非常强大，通过参数的传递可以模拟以上所有动画，方法为：animate() ;<br>语法规范如下:<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616073491922-87ac5de5-e3b5-410a-afee-89e862531e62.png#crop=0&crop=0&crop=1&crop=1&height=280&id=qdJ6i&originHeight=280&originWidth=624&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&title=&width=624"><br><strong>代码演示</strong></p><pre><code class="javascript">&lt;body&gt;  &lt;button&gt;动起来&lt;/button&gt;  &lt;div&gt;&lt;/div&gt;  &lt;script&gt;    $(function()&#123;&quot; &quot;&#125;    &#123;$(&quot;button&quot;).click(function () &#123;      $(&quot;div&quot;).animate(        &#123;          left: 500,          top: 300,          opacity: 0.4,          width: 500,        &#125;,        500      );    &#125;)&#125;    )  &lt;/script&gt;&lt;/body&gt;</code></pre><h3 id="停止动画排队"><a href="#停止动画排队" class="headerlink" title="停止动画排队"></a>停止动画排队</h3><p>动画或者效果一旦触发就会执行，如果多次触发，就造成多个动画或者效果排队执行。<br>停止动画排队的方法为：stop() ;</p><ul><li>stop() 方法用于停止动画或效果。</li><li>stop() 写到动画或者效果的前面， 相当于停止结束上一次的动画。</li></ul><p>总结: 每次使用动画之前，先调用 stop() ,在调用动画。</p><h3 id="事件切换-hover"><a href="#事件切换-hover" class="headerlink" title="事件切换 hover()"></a>事件切换 hover()</h3><p>jQuery 中为我们添加了一个新事件 hover() ; 功能类似 css 中的伪类 :hover 。介绍如下<br><strong>语法</strong></p><pre><code class="javascript">hover([over,]out)     // 其中over和out为两个函数</code></pre><ul><li>over:鼠标移到元素上要触发的函数（相当于 mouseenter）</li><li>out:鼠标移出元素要触发的函数（相当于 mouseleave）</li><li>如果只写一个函数，则鼠标经过和离开都会触发它</li></ul><p><strong>hover 事件和停止动画排列案例</strong></p><pre><code class="javascript">&lt;body&gt;    &lt;ul class=&quot;nav&quot;&gt;        &lt;li&gt;            &lt;a href=&quot;#&quot;&gt;微博&lt;/a&gt;            &lt;ul&gt;&lt;li&gt;&lt;a href=&quot;&quot;&gt;私信&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;&quot;&gt;评论&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;&quot;&gt;@我&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;        &lt;/li&gt;        &lt;li&gt;            &lt;a href=&quot;#&quot;&gt;微博&lt;/a&gt;            &lt;ul&gt;&lt;li&gt;&lt;a href=&quot;&quot;&gt;私信&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;&quot;&gt;评论&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;&quot;&gt;@我&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;        &lt;/li&gt;    &lt;/ul&gt;    &lt;script&gt;        $(function() &#123;            // 鼠标经过            // $(&quot;.nav&gt;li&quot;).mouseover(function() &#123;            //     // $(this) jQuery 当前元素  this不要加引号            //     // show() 显示元素  hide() 隐藏元素            //     $(this).children(&quot;ul&quot;).slideDown(200);            // &#125;);            // // 鼠标离开            // $(&quot;.nav&gt;li&quot;).mouseout(function() &#123;            //     $(this).children(&quot;ul&quot;).slideUp(200);            // &#125;);            // 1. 事件切换 hover 就是鼠标经过和离开的复合写法            // $(&quot;.nav&gt;li&quot;).hover(function() &#123;            //     $(this).children(&quot;ul&quot;).slideDown(200);            // &#125;, function() &#123;            //     $(this).children(&quot;ul&quot;).slideUp(200);            // &#125;);            // 2. 事件切换 hover  如果只写一个函数，那么鼠标经过和鼠标离开都会触发这个函数            $(&quot;.nav&gt;li&quot;).hover(function() &#123;                // stop 方法必须写到动画的前面                $(this).children(&quot;ul&quot;).stop().slideToggle();            &#125;);        &#125;)    &lt;/script&gt;&lt;/body&gt;</code></pre><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
      
      
      <categories>
          
          <category> 👨‍💻Web开发 </category>
          
          <category> jQuery </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>计算方法各实验流程图汇总</title>
      <link href="/blog/hizlew/"/>
      <url>/blog/hizlew/</url>
      
        <content type="html"><![CDATA[<p>前言：大三<strong>计算方法</strong>课程所有实验报告的流程图，做个存档，以备不时之需~~<img src="https://cdn.nlark.com/yuque/0/2021/gif/1484158/1616633908079-3d59dbee-c4dc-4c51-899f-0708e3570b0d.gif#crop=0&crop=0&crop=1&crop=1&height=100&id=q5k8l&margin=%5Bobject%20Object%5D&name=A13E7D78C08B2131588EDD8D9F6FE5EB.gif&originHeight=100&originWidth=100&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=10263&status=done&style=stroke&title=&width=100" alt="A13E7D78C08B2131588EDD8D9F6FE5EB.gif">具体代码改天再找找再放上来。</p><p>目录</p><ul><li>非线性方程的解法</li><li>线性方程组的解法</li><li>Hermite 插值</li><li>最小二乘算法</li><li>正态分布表复现</li></ul><h2 id="非线性方程的解法"><a href="#非线性方程的解法" class="headerlink" title="非线性方程的解法"></a>非线性方程的解法</h2><p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1616633632638-fc4a4508-6a92-4c8e-ae80-6d7326f9e13a.jpeg#crop=0&crop=0&crop=1&crop=1&height=555&id=Px9X1&margin=%5Bobject%20Object%5D&name=yuque_diagram.jpg&originHeight=1728&originWidth=1258&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=109866&status=done&style=stroke&title=&width=404" alt="yuque_diagram.jpg"><br><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1616633610151-eed94d68-d147-4478-9c56-730fbe696d47.jpeg"></p><h2 id="线性方程组的解法"><a href="#线性方程组的解法" class="headerlink" title="线性方程组的解法"></a>线性方程组的解法</h2><p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1616633672598-12d949b6-91f6-4b78-9825-21bd836c6dee.jpeg#crop=0&crop=0&crop=1&crop=1&height=538&id=ysuDu&margin=%5Bobject%20Object%5D&name=yuque_diagram.jpg&originHeight=2050&originWidth=1697&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=226328&status=done&style=stroke&title=&width=445" alt="yuque_diagram.jpg"><br><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1616633610254-fa45fc83-037a-4ef6-8335-15363df8051a.jpeg"></p><h2 id="Hermite-插值"><a href="#Hermite-插值" class="headerlink" title="Hermite 插值"></a>Hermite 插值</h2><p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1616633702383-7da5e39f-e899-4034-acdd-7e0c417a1487.jpeg#crop=0&crop=0&crop=1&crop=1&height=667&id=dDpcv&margin=%5Bobject%20Object%5D&name=yuque_diagram.jpg&originHeight=2610&originWidth=1796&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=225117&status=done&style=stroke&title=&width=459" alt="yuque_diagram.jpg"><br><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1616633692587-90b66863-8a3c-4b63-8046-674f80dc04d9.jpeg"></p><h2 id="最小二乘算法"><a href="#最小二乘算法" class="headerlink" title="最小二乘算法"></a>最小二乘算法</h2><p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1616633760214-e8df0fdd-19f5-44a7-97dc-7d3e5b05e0d3.jpeg#crop=0&crop=0&crop=1&crop=1&height=819&id=V41YV&margin=%5Bobject%20Object%5D&name=yuque_diagram.jpg&originHeight=2177&originWidth=1380&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=162211&status=done&style=stroke&title=&width=519" alt="yuque_diagram.jpg"><br><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1616633747782-b4fd3da7-09fe-4bed-bd37-e9bec306e6a6.jpeg"></p><h2 id="正态分布表复现"><a href="#正态分布表复现" class="headerlink" title="正态分布表复现"></a>正态分布表复现</h2><p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1616633788535-61ef6425-b386-4a92-b3d8-44a136c3ee88.jpeg#crop=0&crop=0&crop=1&crop=1&height=1027&id=NeiyB&margin=%5Bobject%20Object%5D&name=yuque_diagram.jpg&originHeight=1748&originWidth=708&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=98744&status=done&style=stroke&title=&width=416" alt="yuque_diagram.jpg"><br><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1616633747770-5c3e05b2-2b4a-4187-9aa8-e4063434dfc0.jpeg"></p>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 其他算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[转]前端PS操作-蓝湖</title>
      <link href="/blog/gqw2qf/"/>
      <url>/blog/gqw2qf/</url>
      
        <content type="html"><![CDATA[<p>前言：现在蓝湖做设计貌似非常多……<br>插眼……</p><p><img src="https://cdn.nlark.com/yuque/0/2021/gif/1484158/1638108278654-c145b08a-a44d-4b0f-a532-0da59d850756.gif#crop=0&crop=0&crop=1&crop=1&id=T3DQk&originHeight=151&originWidth=218&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&title="></p><h2 id="ps-基本操作以及常用快捷键："><a href="#ps-基本操作以及常用快捷键：" class="headerlink" title="ps 基本操作以及常用快捷键："></a>ps 基本操作以及常用快捷键：</h2><p>因为网页美工大部分效果图都是利用 ps 来做的，所以，以后我们大部分切图工作都是在 ps 里面完成。</p><ul><li>文件–打开 – 可以打开 我们要测量的图片</li><li>ctrl+r 可以打开标尺 或者 视图 – 标尺</li><li>右击标尺， 把里面的单位改为 像素</li><li>ctrl+ 加号 键 可以 放大 视图 ctrl+ 减号 缩小视图</li><li>按住空格键， 鼠标可以 变成小手 ，拖动 ps 视图</li><li>用选区 拖动 可以 测量 大小</li><li>ctrl+ d 可以取消选区 或者旁边空白处点击一下也可以取消选区</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611549556960-d43dc95b-ceed-4eb5-bc70-d527bfd6790f.png#crop=0&crop=0&crop=1&crop=1&height=440&id=BrF58&originHeight=440&originWidth=849&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=stroke&title=&width=849"></p><h2 id="Photoshop-切图"><a href="#Photoshop-切图" class="headerlink" title="Photoshop 切图"></a>Photoshop 切图</h2><p><strong>常见的图片格式</strong></p><pre><code>1. jpg图像格式：JPEG（.JPG）对色彩的信息保留较好，高清，颜色较多，我们产品类的图片经常用jpg格式的2. gif图像格式：GIF格式最多只能储存256色，所以通常用来显示简单图形及字体，但是可以保存透明背景和动画效果3. png图像格式是一种新兴的网络图形格式，结合了GIF和JPEG的优点，具有存储形式丰富的特点，能够保持透明背景4. PSD图像格式PSD格式是Photoshop的专用格式，里面可以存放图层、通道、遮罩等多种设计草稿。</code></pre><p>PS 切图 可以 分为 利用切片工具切图 以及 利用 PS 的插件快速切图。</p><h3 id="1-PS-切片工具"><a href="#1-PS-切片工具" class="headerlink" title="1). PS 切片工具"></a>1). PS 切片工具</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611549558330-2bb506e1-9230-4d4c-a031-7de0b5d2077a.png#crop=0&crop=0&crop=1&crop=1&height=246&id=Vf7om&originHeight=246&originWidth=306&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&title=&width=306"><br>ps 切图片，分两大步：<br><strong>1). 用切片选中图片</strong></p><ul><li>利用切片工具手动划出</li><li>图层菜单—新建基于图层的切片</li><li>利用辅助线 来切图 – 基于参考线的切片<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611549558387-e6ea82e1-e85f-4b2e-a724-7eb095932273.png#crop=0&crop=0&crop=1&crop=1&height=106&id=hu6mY&originHeight=106&originWidth=640&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&title=&width=640"></li></ul><p><strong>2). 导出切片</strong><br>文件菜单 – 存储为 web 设备所用格式 —- 选择 我们要的图片格式 —- 点存储 — 别忘了选中的切片</p><blockquote><p>辅助线和切片使用及清除</p></blockquote><p>视图菜单– 清除 辅助线/ 清除切片</p><h3 id="2-切图插件"><a href="#2-切图插件" class="headerlink" title="2). 切图插件"></a>2). 切图插件</h3><p>Cutterman 是一款运行在 photoshop 中的插件，能够自动将你需要的图层进行输出， 以替代传统的手工 “导出 web 所用格式” 以及使用切片工具进行挨个切图的繁琐流程。 它支持各种各样的图片尺寸、格式、形态输出，方便你在 pc、ios、Android 等端上使用。 它不需要你记住一堆的语法、规则，纯点击操作，方便、快捷，易于上手。<br>官网: <a href="http://www.cutterman.cn/zh/cutterman">http://www.cutterman.cn/zh/cutterman</a><br>注意： cutterman 插件要求你的 ps 必须是完整版，不能是绿色版，所以大家需要从新安装完整版本。<br><img src="https://cdn.nlark.com/yuque/0/2021/gif/1484158/1611549558445-f9023a37-7339-4590-907e-a71d004899ff.gif#crop=0&crop=0&crop=1&crop=1&height=569&id=LnDfZ&originHeight=569&originWidth=644&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=stroke&title=&width=644"></p>]]></content>
      
      
      <categories>
          
          <category> ✨其他 </category>
          
          <category> 后期制作 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>响应式布局rem</title>
      <link href="/blog/rm1i2lgosgh2/"/>
      <url>/blog/rm1i2lgosgh2/</url>
      
        <content type="html"><![CDATA[<h2 id="rem"><a href="#rem" class="headerlink" title="rem"></a>rem</h2><h3 id="em"><a href="#em" class="headerlink" title="em"></a>em</h3><div style="background: #FFF3F3;padding:10px;border: 1px solid #DEB8BE;border-radius:5px;margin-bottom:5px;">- 相对单位- em是父元素字体大小</div><h3 id="rem-1"><a href="#rem-1" class="headerlink" title="rem"></a>rem</h3><div style="background: #FFF3F3;padding:10px;border: 1px solid #DEB8BE;border-radius:5px;margin-bottom:5px;">- 相对单位- rem的基准是相对于html元素的字体大小。</div>比如，根元素（html）设置font-size=12px; 非根元素设置width:2rem; 则换成px表示就是24px。```css/* 根html 为 12px */html {   font-size: 12px;}/* 此时 div 的字体大小就是 24px */       div {    font-size: 2rem;}```rem的优势：父元素文字大小可能不一致， 但是整个页面只有一个html，可以很好来控制整个页面的元素大小。<h3 id="vm-和-vh"><a href="#vm-和-vh" class="headerlink" title="vm 和 vh"></a>vm 和 vh</h3><ul><li>视口的宽高</li><li>按照 100 来划分</li></ul><p>用过的例子：</p><pre><code class="css">.test &#123;  height: calc(100vh);  padding: calc((100vh - 60px - 10px) / 4) 10px;&#125;</code></pre><h2 id="rem-适配方案"><a href="#rem-适配方案" class="headerlink" title="rem 适配方案"></a>rem 适配方案</h2><p>1.让一些不能等比自适应的元素，达到当设备尺寸发生改变的时候，等比例适配当前设备。 2.使用媒体查询根据不同设备按比例设置 html 的字体大小，然后页面元素使用 rem 做尺寸单位，当 html 字体大小变化元素尺寸也会发生变化，从而达到等比缩放的适配。<br>技术方案：<br>1.less+rem+媒体查询<br>2.lflexible.js+rem<br>总结：<br>两种方案现在都存在。<br>方案 2 更简单，现阶段大家无需了解里面的 js 代码。</p><h3 id="rem-适配方案-1"><a href="#rem-适配方案-1" class="headerlink" title="rem 适配方案 1"></a>rem 适配方案 1</h3><p>① 假设设计稿是 750px<br>② 假设我们把整个屏幕划分为 15 等份（划分标准不一可以是 20 份也可以是 10 等份）<br>③ 每一份作为 html 字体大小，这里就是 50px<br>④ 那么在 320px 设备的时候，字体大小为 320/15 就是 21.33px<br>⑤ 用我们页面元素的大小除以不同的 html 字体大小会发现他们比例还是相同的<br>⑥ 比如我们以 750 为标准设计稿<br>⑦ 一个 100_100 像素的页面元素在 750 屏幕下， 就是 100/ 50 转换为 rem 是 2rem_2rem 比例是 1 比 1<br>⑧320 屏幕下， html 字体大小为 21.33 则 2rem= 42.66px 此时宽和高都是 42.66 但是宽和高的比例还是 1 比 1<br>⑨ 但是已经能实现不同屏幕下 页面元素盒子等比例缩放的效果<br>总结：<br>① 最后的公式：页面元素的 rem 值 = 页面元素值（px） / （屏幕宽度 / 划分的份数）<br>② 屏幕宽度/划分的份数就是 htmlfont-size 的大小<br>③ 或者：页面元素的 rem 值 = 页面元素值（px） / html font-size 字体大小</p><h3 id="苏宁首页"><a href="#苏宁首页" class="headerlink" title="苏宁首页"></a>苏宁首页</h3><p>苏宁首页地址 ：<a href="m.suning.com">苏宁首页</a><br>1、 技术选型<br>方案：我们采取单独制作移动页面方案<br>技术：布局采取 rem 适配布局（less + rem + 媒体查询）<br>设计图： 本设计图采用 750px 设计尺寸<br>2、搭建文件结构<br><img src="https://cdn.nlark.com/yuque/0/2021/jpg/1484158/1615360325682-7e3f3397-a6e1-47eb-9774-d632ea98c710.jpg#crop=0&crop=0&crop=1&crop=1&height=263&id=JeBWG&originHeight=263&originWidth=466&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=stroke&title=&width=466"><br>3、设置视口标签以及引入初始化样式</p><pre><code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no,         initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;css/normalize.css&quot;&gt;</code></pre><p>4、设置公共 common.less 文件</p><ul><li>新建 common.less 设置好最常见的屏幕尺寸，利用媒体查询设置不同的 html 字体大小，因为除了首页其他页面也需要</li><li>我们关心的尺寸有 320px、360px、375px、384px、400px、414px、424px、480px、540px、720px、750px</li><li>划分的份数我们定为 15 等份</li><li>因为我们 pc 端也可以打开我们苏宁移动端首页，我们默认 html 字体大小为 50px，注意这句话写到最上面</li></ul><h3 id="rem-适配方案-2"><a href="#rem-适配方案-2" class="headerlink" title="rem 适配方案 2"></a>rem 适配方案 2</h3><p>手机淘宝团队出的简洁高效 移动端适配库<br>我们再也不需要在写不同屏幕的媒体查询，因为里面 js 做了处理<br>它的原理是把当前设备划分为 10 等份，但是不同设备下，比例还是一致的。<br>我们要做的，就是确定好我们当前设备的 html 文字大小就可以了<br>比如当前设计稿是 750px， 那么我们只需要把 html 文字大小设置为 75px(750px / 10) 就可以<br>里面页面元素 rem 值： 页面元素的 px 值 / 75<br>剩余的，让 flexible.js 来去算<br>github 地址：<a href="https://link.jianshu.com/?t=https://github.com/amfe/lib-flexible">https://github.com/amfe/lib-flexible</a><br>总结：<br>因为 flexible 是默认将屏幕分为 10 等分<br>但是当屏幕大于 750 的时候希望不要再去重置 html 字体了<br>所以要自己通过媒体查询设置一下<br>并且要把权重提到最高<br>VSCode px 转换 rem 插件 cssrem<br>因为 cssrem 中 css 自动转化为 rem 是参照默认插件的 16 转换的所以需要自己配置<br><img src="https://cdn.nlark.com/yuque/0/2021/jpg/1484158/1615360325777-63efe343-7fb5-46ff-a976-757d50df3556.jpg#crop=0&crop=0&crop=1&crop=1&height=536&id=UABvV&originHeight=536&originWidth=713&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=stroke&title=&width=713"><img src="https://cdn.nlark.com/yuque/0/2021/jpg/1484158/1615360325891-a1820b7f-bdbf-47e8-b04b-723db8329cf8.jpg#crop=0&crop=0&crop=1&crop=1&height=544&id=alFe1&originHeight=544&originWidth=566&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=stroke&title=&width=566"></p><h2 id="响应式开发原理"><a href="#响应式开发原理" class="headerlink" title="响应式开发原理"></a>响应式开发原理</h2><h3 id="响应式开发原理-1"><a href="#响应式开发原理-1" class="headerlink" title="响应式开发原理"></a>响应式开发原理</h3><div style="background: #edf9e8;padding:10px;border: 1px solid #c2d2b5;border-radius:5px;margin-bottom:5px;">就是使用媒体查询针对不同宽度的设备进行布局和样式的设置，从而适配不同设备的目的</div>设备的划分情况<ul><li>小于 768 的为超小屏幕（手机）</li><li>768~992 之间的为小屏设备（平板）</li><li>992~1200 的中等屏幕（桌面显示器）</li><li>大于 1200 的宽屏设备（大桌面显示器）</li></ul><h3 id="响应式布局容器"><a href="#响应式布局容器" class="headerlink" title="响应式布局容器"></a>响应式布局容器</h3><div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">响应式需要一个父级做为布局容器，来配合子级元素来实现变化效果。原理就是在不同屏幕下，通过媒体查询来改变这个布局容器的大小，再改变里面子元素的排列方式和大小，从而实现不同屏幕下，看到不同的页面布局和样式变化。</div>父容器版心的尺寸划分<ul><li>超小屏幕（手机，小于 768px）：设置宽度为 100%</li><li>小屏幕（平板，大于等于 768px）：设置宽度为 750px</li><li>中等屏幕（桌面显示器，大于等于 992px）：宽度设置为 970px</li><li>大屏幕（大桌面显示器，大于等于 1200px）：宽度设置为 1170px</li></ul><p>但是我们也可以根据实际情况自己定义划分</p>]]></content>
      
      
      <categories>
          
          <category> 👨‍💻Web开发 </category>
          
          <category> HTML+CSS </category>
          
          <category> 布局 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>百分比布局</title>
      <link href="/blog/oxqtosvrfeg8/"/>
      <url>/blog/oxqtosvrfeg8/</url>
      
        <content type="html"><![CDATA[<h2 id="meta-标签-viewport"><a href="#meta-标签-viewport" class="headerlink" title="meta 标签 viewport"></a>meta 标签 viewport</h2><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1615360134988-de179521-dfc1-419f-a1b6-5e45b5b40096.png#align=left&display=inline&height=451&margin=%5Bobject%20Object%5D&originHeight=451&originWidth=1043&status=done&style=none&width=1043"></p><h2 id="normalize-css"><a href="#normalize-css" class="headerlink" title="normalize.css"></a>normalize.css</h2><p>移动端 CSS 初始化推荐使用 normalize.css/<br>Normalize.css：保护了有价值的默认值<br>Normalize.css：修复了浏览器的 bug<br>Normalize.css：是模块化的<br>Normalize.css：拥有详细的文档<br>官网地址： <a href="http://necolas.github.io/normalize.css/">http://necolas.github.io/normalize.css/</a></p><h2 id="box-sizing"><a href="#box-sizing" class="headerlink" title="box-sizing"></a>box-sizing</h2><div style="background: #FFF3F3;padding:10px;border: 1px solid #DEB8BE;border-radius:5px;margin-bottom:5px;">传统模式宽度计算：盒子的宽度 = CSS中设置的width + border + padding</div><div style="background: #edf9e8;padding:10px;border: 1px solid #c2d2b5;border-radius:5px;margin-bottom:5px;">CSS3盒子模型：盒子的宽度=  CSS中设置的宽度width 里面包含了 border 和 padding</div>也就是说，我们的CSS3中的盒子模型， padding 和 border 不会撑大盒子了```css/*CSS3盒子模型*/box-sizing: border-box;/*传统盒子模型*/box-sizing: content-box;```移动端可以全部CSS3 盒子模型<div style="background: #FFF3F3;padding:10px;border: 1px solid #DEB8BE;border-radius:5px;margin-bottom:5px;">PC端如果完全需要兼容，我们就用传统模式，如果不考虑兼容性，我们就选择 CSS3 盒子模型</div><pre><code class="css">-webkit-box-sizing: border-box              /* CSS3盒模型 */-moz-box-sizing: border-box                 /* CSS3盒模型 */box-sizing: border-box                      /* CSS3盒模型 */</code></pre><h3 id="移动端特殊样式"><a href="#移动端特殊样式" class="headerlink" title="移动端特殊样式"></a>移动端特殊样式</h3><pre><code class="css">/*CSS3盒子模型*/box-sizing: border-box;-webkit-box-sizing: border-box;/*点击高亮我们需要清除清除  设置为transparent 完成透明*/-webkit-tap-highlight-color: transparent;/*在移动端浏览器默认的外观在iOS上加上这个属性才能给按钮和输入框自定义样式*/-webkit-appearance: none;/*禁用长按页面时的弹出菜单*/img,a &#123;  -webkit-touch-callout: none;&#125;</code></pre><h2 id="移动端常见布局"><a href="#移动端常见布局" class="headerlink" title="移动端常见布局"></a>移动端常见布局</h2><h3 id="移动端单独制作"><a href="#移动端单独制作" class="headerlink" title="移动端单独制作"></a>移动端单独制作</h3><div style="background: #edf9e8;padding:10px;border: 1px solid #c2d2b5;border-radius:5px;margin-bottom:5px;">流式布局（百分比布局）</div>流式布局，就是百分比布局，也称非固定像素布局。通过盒子的宽度设置成百分比来根据屏幕的宽度来进行伸缩，不受固定像素的限制，内容向两侧填充。流式布局方式是移动web开发使用的比较常见的布局方式。]]></content>
      
      
      <categories>
          
          <category> 👨‍💻Web开发 </category>
          
          <category> HTML+CSS </category>
          
          <category> 布局 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Flex布局</title>
      <link href="/blog/ogynfghwtsa7/"/>
      <url>/blog/ogynfghwtsa7/</url>
      
        <content type="html"><![CDATA[<h2 id="flex-布局原理"><a href="#flex-布局原理" class="headerlink" title="flex 布局原理"></a>flex 布局原理</h2><ul><li>flex 是 flexible Box 的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性，任何一个容器都可以指定为 flex 布局。</li><li>当我们为父盒子设为 flex 布局以后，子元素的 float、clear 和 vertical-align 属性将失效。</li><li>flex 布局又叫伸缩布局 、弹性布局 、伸缩盒布局 、弹性盒布局</li><li>采用 Flex 布局的元素，称为 Flex 容器（flex</li></ul><p>container），简称”容器”。它的所有子元素自动成为容器成员，称为 Flex 项目（flex<br>item），简称”项目”。<br><strong>总结</strong>：就是通过给父盒子添加 flex 属性，来控制子盒子的位置和排列方式</p><h2 id="父项常见属性"><a href="#父项常见属性" class="headerlink" title="父项常见属性"></a>父项常见属性</h2><ul><li>flex-direction：设置主轴的方向</li><li>justify-content：设置主轴上的子元素排列方式</li><li>flex-wrap：设置子元素是否换行</li><li>align-content：设置侧轴上的子元素的排列方式（多行）</li><li>align-items：设置侧轴上的子元素排列方式（单行）</li><li>flex-flow：复合属性，相当于同时设置了 flex-direction 和 flex-wrap</li></ul><h3 id="flex-direction-设置主轴的方向"><a href="#flex-direction-设置主轴的方向" class="headerlink" title="flex-direction 设置主轴的方向"></a>flex-direction 设置主轴的方向</h3><ul><li>在 flex 布局中，是分为主轴和侧轴两个方向，同样的叫法有 ： 行和列、x 轴和 y 轴</li><li>默认主轴方向就是 x 轴方向，水平向右</li><li>默认侧轴方向就是 y 轴方向，水平向下</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1615561167817-709457f2-58f3-47b2-82f2-36a27c5ffbac.png#align=left&display=inline&height=227&margin=%5Bobject%20Object%5D&name=image.png&originHeight=453&originWidth=970&size=44867&status=done&style=none&width=485" alt="image.png"></p><ul><li>注意： 主轴和侧轴是会变化的，就看 flex-direction 设置谁为主轴，剩下的就是侧轴。而我们的子元素是跟着主轴来排列的</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1615561179498-b513941e-0741-403e-a156-bf3794692e74.png#align=left&display=inline&height=182&margin=%5Bobject%20Object%5D&name=image.png&originHeight=363&originWidth=927&size=149158&status=done&style=none&width=463.5" alt="image.png"></p><h3 id="justify-content-设置主轴上的子元素排列方式"><a href="#justify-content-设置主轴上的子元素排列方式" class="headerlink" title="justify-content 设置主轴上的子元素排列方式"></a>justify-content 设置主轴上的子元素排列方式</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1615561189187-37fb2250-6a7a-4b7e-8da7-8bfbed134942.png#align=left&display=inline&height=216&margin=%5Bobject%20Object%5D&name=image.png&originHeight=432&originWidth=1228&size=383001&status=done&style=none&width=614" alt="image.png"></p><h3 id="flex-wrap-设置是否换行"><a href="#flex-wrap-设置是否换行" class="headerlink" title="flex-wrap 设置是否换行"></a>flex-wrap 设置是否换行</h3><ul><li>默认情况下，项目都排在一条线（又称”轴线”）上。flex-wrap 属性定义，flex 布局中默认是不换行的。</li><li>nowrap 不换行</li><li>wrap 换行</li></ul><h3 id="align-items-设置侧轴上的子元素排列方式（单行-）"><a href="#align-items-设置侧轴上的子元素排列方式（单行-）" class="headerlink" title="align-items 设置侧轴上的子元素排列方式（单行 ）"></a>align-items 设置侧轴上的子元素排列方式（单行 ）</h3><ul><li>该属性是控制子项在侧轴（默认是 y 轴）上的排列方式 在子项为单项（单行）的时候使用</li><li>flex-start 从头部开始</li><li>flex-end 从尾部开始</li><li>center 居中显示</li><li>stretch 拉伸</li></ul><h3 id="align-content-设置侧轴上的子元素的排列方式（多行）"><a href="#align-content-设置侧轴上的子元素的排列方式（多行）" class="headerlink" title="align-content 设置侧轴上的子元素的排列方式（多行）"></a>align-content 设置侧轴上的子元素的排列方式（多行）</h3><p>设置子项在侧轴上的排列方式 并且只能用于子项出现 换行 的情况（多行），在单行下是没有效果的。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1615561203043-769de419-37f6-47ac-8a01-7353fb2fbcd4.png#align=left&display=inline&height=271&margin=%5Bobject%20Object%5D&name=image.png&originHeight=541&originWidth=1084&size=429763&status=done&style=none&width=542" alt="image.png"></p><h3 id="align-content-和-align-items-区别"><a href="#align-content-和-align-items-区别" class="headerlink" title="align-content 和 align-items 区别"></a>align-content 和 align-items 区别</h3><ul><li>align-items 适用于单行情况下， 只有上对齐、下对齐、居中和 拉伸</li><li>align-content 适应于换行（多行）的情况下（单行情况下无效）， 可以设置 上对齐、下对齐、居中、拉伸以及平均分配剩余空间等属性值。</li><li>总结就是单行找 align-items 多行找 align-content</li></ul><h3 id="flex-flow-属性是-flex-direction-和-flex-wrap-属性的复合属性"><a href="#flex-flow-属性是-flex-direction-和-flex-wrap-属性的复合属性" class="headerlink" title="flex-flow 属性是 flex-direction 和 flex-wrap 属性的复合属性"></a>flex-flow 属性是 flex-direction 和 flex-wrap 属性的复合属性</h3><pre><code>flex-flow:row wrap;</code></pre><h2 id="flex-布局子项常见属性"><a href="#flex-布局子项常见属性" class="headerlink" title="flex 布局子项常见属性"></a>flex 布局子项常见属性</h2><ul><li>flex 子项目占的份数</li><li>align-self 控制子项自己在侧轴的排列方式</li><li>order 属性定义子项的排列顺序（前后顺序）</li></ul><h3 id="flex-属性"><a href="#flex-属性" class="headerlink" title="flex 属性"></a>flex 属性</h3><p>flex 属性定义子项目分配剩余空间，用 flex 来表示占多少份数。</p><pre><code>.item &#123;    flex: &lt;number&gt;; /* 默认值 0 */&#125;</code></pre><h3 id="align-self-控制子项自己在侧轴上的排列方式"><a href="#align-self-控制子项自己在侧轴上的排列方式" class="headerlink" title="align-self 控制子项自己在侧轴上的排列方式"></a>align-self 控制子项自己在侧轴上的排列方式</h3><p>align-self 属性允许单个项目有与其他项目不一样的对齐方式，可覆盖 align-items 属性。<br>默认值为 auto，表示继承父元素的 align-items 属性，如果没有父元素，则等同于 stretch。</p><pre><code>span:nth-child(2) &#123;      /* 设置自己在侧轴上的排列方式 */      align-self: flex-end;&#125;</code></pre><h3 id="order-属性定义项目的排列顺序"><a href="#order-属性定义项目的排列顺序" class="headerlink" title="order 属性定义项目的排列顺序"></a>order 属性定义项目的排列顺序</h3><p>数值越小，排列越靠前，默认为 0。<br>注意：和 z-index 不一样。</p><pre><code>.item &#123;    order: &lt;number&gt;;&#125;</code></pre><h2 id="携程网首页案例制作"><a href="#携程网首页案例制作" class="headerlink" title="携程网首页案例制作"></a>携程网首页案例制作</h2><p>携程网链接：<a href="http://m.ctrip.com/">http://m.ctrip.com</a> 1.技术选型<br>方案：我们采取单独制作移动页面方案<br>技术：布局采取 flex 布局 2.搭建相关文件夹<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1615561216425-7cb96807-082c-4f58-a8e6-7fd089ad6c35.png#align=left&display=inline&height=140&margin=%5Bobject%20Object%5D&name=image.png&originHeight=279&originWidth=388&size=95052&status=done&style=none&width=194" alt="image.png"> 3.设置视口标签以及引入初始化样式</p><pre><code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no,initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;css/normalize.css&quot;&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;css/index.css&quot;&gt;</code></pre><p>4.常用初始化样式</p><pre><code>body &#123;  max-width: 540px;  min-width: 320px;  margin: 0 auto;  font: normal 14px/1.5 Tahoma,&quot;Lucida Grande&quot;,Verdana,&quot;Microsoft Yahei&quot;,STXihei,hei;  color: #000;  background: #f2f2f2;  overflow-x: hidden;  -webkit-tap-highlight-color: transparent;&#125;</code></pre><p>5.模块名字划分<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1615561231614-a9ccc256-3219-41a4-a610-588d72137519.png#align=left&display=inline&height=404&margin=%5Bobject%20Object%5D&name=image.png&originHeight=808&originWidth=1035&size=777724&status=done&style=none&width=517.5" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> 👨‍💻Web开发 </category>
          
          <category> HTML+CSS </category>
          
          <category> 布局 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CSS3的2D效果</title>
      <link href="/blog/02_html5css3_day02/"/>
      <url>/blog/02_html5css3_day02/</url>
      
        <content type="html"><![CDATA[<p>这是加密文章！</p>]]></content>
      
      
      <categories>
          
          <category> 👨‍💻Web开发 </category>
          
          <category> HTML+CSS </category>
          
          <category> 动画 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CSS3的3D效果</title>
      <link href="/blog/03_html5css3_day03/"/>
      <url>/blog/03_html5css3_day03/</url>
      
        <content type="html"><![CDATA[<p>这是加密文章！</p>]]></content>
      
      
      <categories>
          
          <category> 👨‍💻Web开发 </category>
          
          <category> HTML+CSS </category>
          
          <category> 动画 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CSS/CSS3选择器总结</title>
      <link href="/blog/01_html5css3_day01/"/>
      <url>/blog/01_html5css3_day01/</url>
      
        <content type="html"><![CDATA[<p>这是加密文章！</p>]]></content>
      
      
      <categories>
          
          <category> 👨‍💻Web开发 </category>
          
          <category> HTML+CSS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JAVA当中栈和队列常用方法</title>
      <link href="/blog/oylyeh/"/>
      <url>/blog/oylyeh/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Java 里有一个叫做 Stack 的类，却没有叫做 Queue 的类（它是个接口名字）。当需要使用栈时，Java 已不推荐使用 Stack，而是推荐使用更高效的 ArrayDeque；</p></blockquote><blockquote><p>既然 Queue 只是一个接口，当需要使用队列时也就首选 ArrayDeque 了（次选是 LinkedList）。</p></blockquote><h2 id="队列常用方法"><a href="#队列常用方法" class="headerlink" title="队列常用方法"></a>队列常用方法</h2><blockquote><p>初始化</p></blockquote><pre><code class="java">import java.util.LinkedList;import java.util.Queue;Queue&lt;Integer&gt; queue_input = new LinkedList&lt;&gt;();</code></pre><table><thead><tr><th>Queue Method</th><th>Equivalent Deque Method</th><th>说明</th></tr></thead><tbody><tr><td>add(e)</td><td>addLast(e)</td><td>向队尾插入元素，失败则抛出异常</td></tr><tr><td>offer(e)</td><td>offerLast(e)</td><td>向队尾插入元素，失败则返回 false，offer(E e)操作是专为容量受限的队列实现而设计的，在大多数实现中，插入操作不会失败</td></tr><tr><td>remove()</td><td>removeFirst()</td><td>获取并删除队首元素，失败则抛出异常</td></tr><tr><td>poll()</td><td>pollFirst()</td><td>获取并删除队首元素，失败则返回 null</td></tr><tr><td>element()</td><td>getFirst()</td><td>获取但不删除队首元素，失败则抛出异常</td></tr><tr><td>peek()</td><td>peekFirst()</td><td>获取但不删除队首元素，失败则返回 null</td></tr></tbody></table><h2 id="栈常用方法"><a href="#栈常用方法" class="headerlink" title="栈常用方法"></a>栈常用方法</h2><table><thead><tr><th>Stack Method</th><th>Equivalent Deque Method</th><th>说明</th></tr></thead><tbody><tr><td>push(e)</td><td>addFirst(e)</td><td>向栈顶插入元素，失败则抛出异常</td></tr><tr><td>无</td><td>offerFirst(e)</td><td>向栈顶插入元素，失败则返回 false</td></tr><tr><td>pop()</td><td>removeFirst()</td><td>获取并删除栈顶元素，失败则抛出异常</td></tr><tr><td>无</td><td>pollFirst()</td><td>获取并删除栈顶元素，失败则返回 null</td></tr><tr><td>peek()</td><td>peekFirst()</td><td>获取但不删除栈顶元素，失败则抛出异常</td></tr><tr><td>无</td><td>peekFirst()</td><td>获取但不删除栈顶元素，失败则返回 null</td></tr></tbody></table><h2 id="关于-ArrayDeque"><a href="#关于-ArrayDeque" class="headerlink" title="关于 ArrayDeque"></a>关于 ArrayDeque</h2><blockquote><p>ArrayDeque 和 LinkedList 是 Deque 的两个通用实现，由于官方更推荐使用 AarryDeque 用作栈和队列，<br>从名字可以看出 ArrayDeque 底层通过数组实现，为了满足可以同时在数组两端插入或删除元素的需求，该数组还必须是循环的，即循环数组（circular array），也就是说数组的任何一点都可能被看作起点或者终点。ArrayDeque 是非线程安全的（not thread-safe），当多个线程同时使用的时候，需要程序员手动同步；另外，该容器不允许放入 null 元素。</p></blockquote><pre><code class="java">import java.util.*;public class ArrayDequeStack &#123;    public static void main(String[] args) &#123;        ArrayDeque stack = new ArrayDeque();        // 依次将三个元素push入“栈”，先进后出        stack.push(&quot;疯狂Java讲义&quot;);        stack.push(&quot;轻量级Java EE企业应用实战&quot;);        stack.push(&quot;疯狂Android讲义&quot;);        System.out.println(stack); // [疯狂Android讲义, 轻量级Java EE企业应用实战, 疯狂Java讲义]        System.out.println(stack.peek()); // 疯狂Android讲义        System.out.println(stack); // [疯狂Android讲义, 轻量级Java EE企业应用实战, 疯狂Java讲义]        System.out.println(stack.pop()); // 疯狂Android讲义        System.out.println(stack);//[轻量级Java EE企业应用实战, 疯狂Java讲义]        // 当做队列来使用,先进先出        ArrayDeque queue = new ArrayDeque();        queue.offer(&quot;疯狂Java讲义&quot;);        queue.offer(&quot;轻量级JavaEE企业应用实践&quot;);        queue.offer(&quot;疯狂Android讲义&quot;);        System.out.println(queue); //[疯狂Java讲义, 轻量级JavaEE企业应用实践, 疯狂Android讲义]        // 访问队列头部元素，但不将其poll出队列        System.out.println(queue.peek());        System.out.println(queue);        // poll出第一个元素        System.out.println(queue.poll());        System.out.println(queue);// [轻量级JavaEE企业应用实践, 疯狂Android讲义]    &#125;&#125;</code></pre><pre><code>[疯狂Android讲义, 轻量级Java EE企业应用实战, 疯狂Java讲义]疯狂Android讲义[疯狂Android讲义, 轻量级Java EE企业应用实战, 疯狂Java讲义]疯狂Android讲义[轻量级Java EE企业应用实战, 疯狂Java讲义][疯狂Java讲义, 轻量级JavaEE企业应用实践, 疯狂Android讲义]疯狂Java讲义[疯狂Java讲义, 轻量级JavaEE企业应用实践, 疯狂Android讲义]疯狂Java讲义[轻量级JavaEE企业应用实践, 疯狂Android讲义]</code></pre><p>例子参考：<a href="https://www.cnblogs.com/jiqing9006/p/6107491.html">https://www.cnblogs.com/jiqing9006/p/6107491.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 📶线结构：字符串-数组-栈-队列 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>225/232. 队列和栈的相互实现🔖队列🔖栈</title>
      <link href="/blog/le21wf/"/>
      <url>/blog/le21wf/</url>
      
        <content type="html"><![CDATA[<p>简单实现一下，熟悉一下写题目，这几天找找状态……<img src="https://cdn.nlark.com/yuque/0/2021/gif/1484158/1615278756585-fb0d9f38-8031-472f-9a19-8545be93a548.gif#align=left&display=inline&height=100&margin=%5Bobject%20Object%5D&name=huaji-6f8ff8999ff5ed9a.gif&originHeight=100&originWidth=100&size=12637&status=done&style=none&width=100" alt="huaji-6f8ff8999ff5ed9a.gif"></p><h2 id="P232-栈实现队列"><a href="#P232-栈实现队列" class="headerlink" title="P232. 栈实现队列"></a>P232. 栈实现队列</h2><pre><code class="java">package com.wztlink1013.problems.leetcode.editor.cn;// P232.用栈实现队列// P232.implement-queue-using-stacks//请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（push、pop、peek、empty）：//// 实现 MyQueue 类：////// void push(int x) 将元素 x 推到队列的末尾// int pop() 从队列的开头移除并返回元素// int peek() 返回队列开头的元素// boolean empty() 如果队列为空，返回 true ；否则，返回 false////////// 说明：////// 你只能使用标准的栈操作 —— 也就是只有 push to top, peek/pop from top, size, 和 is empty 操作是合法的。//// 你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。////////// 进阶：////// 你能否实现每个操作均摊时间复杂度为 O(1) 的队列？换句话说，执行 n 个操作的总时间复杂度为 O(n) ，即使其中一个操作可能花费较长时间。////////// 示例：//////输入：//[&quot;MyQueue&quot;, &quot;push&quot;, &quot;push&quot;, &quot;peek&quot;, &quot;pop&quot;, &quot;empty&quot;]//[[], [1], [2], [], [], []]//输出：//[null, null, null, 1, 1, false]////解释：//MyQueue myQueue = new MyQueue();//myQueue.push(1); // queue is: [1]//myQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue)//myQueue.peek(); // return 1//myQueue.pop(); // return 1, queue is [2]//myQueue.empty(); // return false//////////////// 提示：////// 1 &lt;= x &lt;= 9// 最多调用 100 次 push、pop、peek 和 empty// 假设所有操作都是有效的 （例如，一个空的队列不会调用 pop 或者 peek 操作）//// Related Topics 栈 设计// 👍 361 👎 0import java.util.Stack;public class P232ImplementQueueUsingStacks&#123;    public void main(String[] args) &#123;        MyQueue myQueue = new MyQueue();        //本地调试需要将MyQueue类和主函数加上静态static修饰字        //具体解释：https://www.cnblogs.com/dolphin0520/p/3799052.html        myQueue.push(1); // queue is: [1]        myQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue)        myQueue.pop();        myQueue.peek();//        myQueue.peek(); // return 1//        myQueue.pop(); // return 1, queue is [2]//        myQueue.empty(); // return false//        System.out.println(myQueue);    &#125;//leetcode submit region begin(Prohibit modification and deletion)class MyQueue &#123;    Stack&lt;Integer&gt; stack_input = new Stack&lt;&gt;();    Stack&lt;Integer&gt; stack_output = new Stack&lt;&gt;();    /** Initialize your data structure here. */    public MyQueue() &#123;//        Stack&lt;Integer&gt; stack_input = new Stack&lt;&gt;();//        Stack&lt;Integer&gt; stack_output = new Stack&lt;&gt;();    &#125;    /** Push element x to the back of queue. */    public void push(int x) &#123;        stack_input.push(x);        int temp = stack_input.size();        if (stack_output.size() == 0) &#123;            for (int i=0; i&lt;temp; i++)&#123;                stack_output.push(stack_input.pop());            &#125;        &#125;    &#125;    /** Removes the element from in front of queue and returns that element. */    public int pop() &#123;        int temp = stack_input.size();        if (stack_output.size() == 0) &#123;            for (int i=0; i&lt;temp; i++)&#123;                stack_output.push(stack_input.pop());            &#125;        &#125;        return stack_output.pop();    &#125;    /** Get the front element. */    public int peek() &#123;        int temp = stack_input.size();        if (stack_output.size() == 0) &#123;            for (int i=0; i&lt;temp; i++)&#123;                stack_output.push(stack_input.pop());            &#125;        &#125;        return stack_output.peek();    &#125;    /** Returns whether the queue is empty. */    public boolean empty() &#123;        if (stack_input.size() == 0 &amp;&amp; stack_output.size() == 0) &#123;            return true;        &#125;        return false;    &#125;&#125;/** * Your MyQueue object will be instantiated and called as such: * MyQueue obj = new MyQueue(); * obj.push(x); * int param_2 = obj.pop(); * int param_3 = obj.peek(); * boolean param_4 = obj.empty(); *///leetcode submit region end(Prohibit modification and deletion)&#125;</code></pre><h2 id="P225-队列实现栈"><a href="#P225-队列实现栈" class="headerlink" title="P225. 队列实现栈"></a>P225. 队列实现栈</h2><pre><code class="java">package com.wztlink1013.problems.leetcode.editor.cn;// P225.用队列实现栈// P225.implement-stack-using-queues//请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通队列的全部四种操作（push、top、pop 和 empty）。//// 实现 MyStack 类：////// void push(int x) 将元素 x 压入栈顶。// int pop() 移除并返回栈顶元素。// int top() 返回栈顶元素。// boolean empty() 如果栈是空的，返回 true ；否则，返回 false 。////////// 注意：////// 你只能使用队列的基本操作 —— 也就是 push to back、peek/pop from front、size 和 is empty 这些操作。// 你所使用的语言也许不支持队列。 你可以使用 list （列表）或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。////////// 示例：//////输入：//[&quot;MyStack&quot;, &quot;push&quot;, &quot;push&quot;, &quot;top&quot;, &quot;pop&quot;, &quot;empty&quot;]//[[], [1], [2], [], [], []]//输出：//[null, null, null, 2, 2, false]////解释：//MyStack myStack = new MyStack();//myStack.push(1);//myStack.push(2);//myStack.top(); // 返回 2//myStack.pop(); // 返回 2//myStack.empty(); // 返回 False////////// 提示：////// 1 &lt;= x &lt;= 9// 最多调用100 次 push、pop、top 和 empty// 每次调用 pop 和 top 都保证栈不为空////////// 进阶：你能否实现每种操作的均摊时间复杂度为 O(1) 的栈？换句话说，执行 n 个操作的总时间复杂度 O(n) ，尽管其中某个操作可能需要比其他操作更长的//时间。你可以使用两个以上的队列。// Related Topics 栈 设计// 👍 291 👎 0import java.util.LinkedList;import java.util.Queue;public class P225ImplementStackUsingQueues&#123;    public void main(String[] args) &#123;//        Solution solution = new P225ImplementStackUsingQueues().new Solution();    &#125;//leetcode submit region begin(Prohibit modification and deletion)class MyStack &#123;    Queue&lt;Integer&gt; queue_input = new LinkedList&lt;&gt;();    Queue&lt;Integer&gt; queue_output = new LinkedList&lt;&gt;();    /** Initialize your data structure here. */    public MyStack() &#123;    &#125;    /** Push element x onto stack. */    public void push(int x) &#123;        queue_input.add(x);    &#125;    /** Removes the element on top of the stack and returns that element. */    public int pop() &#123;        int temp_2 = queue_input.size();        for (int i=0; i&lt;temp_2; i++) &#123;            queue_output.add(queue_input.remove());        &#125;        int temp_3 = queue_output.size();        for (int i=0; i&lt;temp_3-1; i++) &#123;            queue_input.add(queue_output.remove());        &#125;        return queue_output.remove();    &#125;    /** Get the top element. */    public int top() &#123;        int top = 0;        int temp_4 = queue_input.size();        for (int i=0; i&lt;temp_4; i++) &#123;            queue_output.add(queue_input.remove());        &#125;        int temp_5 = queue_output.size();        for (int i=0; i&lt;temp_5; i++) &#123;            if (i == temp_5-1) &#123;                top = queue_output.element();            &#125;            queue_input.add(queue_output.remove());        &#125;        return top;    &#125;    /** Returns whether the stack is empty. */    public boolean empty() &#123;        if (queue_input.size() == 0 &amp;&amp; queue_output.size() == 0) &#123;            return true;        &#125;        return false;    &#125;&#125;/** * Your MyStack object will be instantiated and called as such: * MyStack obj = new MyStack(); * obj.push(x); * int param_2 = obj.pop(); * int param_3 = obj.top(); * boolean param_4 = obj.empty(); *///leetcode submit region end(Prohibit modification and deletion)&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> Problems </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>站点文章导航</title>
      <link href="/blog/guide_post/"/>
      <url>/blog/guide_post/</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1622192869413-b170ca0a-ff41-434d-bafb-5499b6b3636e.jpeg#crop=0&crop=0&crop=1&crop=1&height=308&id=ucc1528f2&margin=%5Bobject%20Object%5D&name=52853677_p0.jpg&originHeight=900&originWidth=1600&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=903023&status=done&style=none&title=&width=548.0208740234375" alt="52853677_p0.jpg"></p><div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">建站初衷就是从大学伊始做一些文字记录，站点所有文章大类分两类：『技术』和『随笔』，具体的文章整理我是依据文章分类来划分的，下面内容会详述之。所有文章都可能二次修改，比如更新，增加，删除内容等。</div><div style="background: #edf9e8;padding:10px;border: 1px solid #c2d2b5;border-radius:5px;margin-bottom:5px;">✨欢迎交流！</div><h2 id="一、技术博客"><a href="#一、技术博客" class="headerlink" title="一、技术博客"></a>一、技术博客</h2><ul><li><a href="https://www.wztlink1013.com/blog/">https://www.wztlink1013.com/blog/</a><div style="background: #fffbe6;padding:10px;border: 1px solid #e0d1b1;border-radius:5px;margin-bottom:5px;">对技术的分类比较细，是因为想让自己的CS知识体系在不断的学习过程中不断完善精进。</div><div style="background: #FFF3F3;padding:10px;border: 1px solid #DEB8BE;border-radius:5px;margin-bottom:5px;">注意：部分文章为个人知识学习笔记，其排版抑或是内容可能不会完整，个人笔记方式为搭建知识框架，其内容不一定全部书写记录。</div></li></ul><h2 id="二、生活随笔"><a href="#二、生活随笔" class="headerlink" title="二、生活随笔"></a>二、生活随笔</h2><ul><li><a href="https://www.wztlink1013.com/essay/">https://www.wztlink1013.com/essay/</a><div style="background: #fffbe6;padding:10px;border: 1px solid #e0d1b1;border-radius:5px;margin-bottom:5px;">生活随笔的分类并没有上面技术博客那么细致，是因为我大多数是随心随性写随笔，不想太拘束于文本的框架。</div></li></ul><blockquote><p>另外，如果你想了解博主，可以前往以下页面查看~<br>『<a href="https://www.wztlink1013.com/about/">https://www.wztlink1013.com/about/</a>』</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> ✨其他 </category>
          
          <category> 玩转博客 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>RSA公钥密码算法</title>
      <link href="/blog/ccd10c/"/>
      <url>/blog/ccd10c/</url>
      
        <content type="html"><![CDATA[<blockquote><p>最近利用自己曾经写过的一篇文章『<a href="https://www.wztlink1013.com/blog/bw80k6/">https://www.wztlink1013.com/blog/bw80k6/</a>』（利用一次抓包来复习学习过的计网知识）</p></blockquote><p>前言：在分析 HTTPS 和 HTTP 这两个协议之间的区别的时候，我感觉 HTTPS 的 SSL(Secure Sockets Layer 安全套接字协议)证书很类似之前老师讲过的 RSA 算法，做此篇文章复习下 RSA 算法和加深 HTTPS 的理解。</p><p>在密码学当中，由对称密钥和非对称密钥之分。</p><h2 id="对称密钥"><a href="#对称密钥" class="headerlink" title="对称密钥"></a>对称密钥</h2><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612943343546-b8330998-9019-40a1-9759-12b459d5379b.png#align=left&display=inline&height=345&margin=%5Bobject%20Object%5D&name=image.png&originHeight=690&originWidth=982&size=266245&status=done&style=stroke&width=491" alt="image.png"><br>用一个简单的凯撒密码例子来讲解一下对称密钥：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612943823633-5283daed-a125-46fd-a785-93851daf5269.png#align=left&display=inline&height=325&margin=%5Bobject%20Object%5D&name=image.png&originHeight=650&originWidth=957&size=205858&status=done&style=stroke&width=478.5" alt="image.png"><br>上图是凯撒密码的定义，先说一下怎么用：</p><p>假如张三和李四两个人之间需要传输一段密码 apple，他们之间共同约定使用密钥-3（再上图表示就为 e 字母编程 b 字母了，以此类推），而这个算法是基于<a href="https://zh.wikipedia.org/wiki/%E6%A8%A1%E9%99%A4">mod 运算</a>（在这里看成是一种加密/解密机制）的。</p><p>张三利用 mod 运算加密机制（mod 运算）将 apple 转换位 xmmfb<br>李四利用 mod 运算解密机制（mod 运算）将 xmmfb 转换位 apple</p><blockquote><p>a 为什么到 x：（0-3）mod26 可以看成（23-26）mod26=23，所以 a 往后退三位还是 x</p></blockquote><p>上述例子的加密机制和解密机制算法一样（mod 运算），实际上也可以不一样，不做详述。但是可以说名对称加密的密钥都一样，该例子中表现为-3</p><h2 id="RSA-公钥密码算法"><a href="#RSA-公钥密码算法" class="headerlink" title="RSA 公钥密码算法"></a>RSA 公钥密码算法</h2><p>RSA 公钥密码算法是非对称加密。</p><p>先说一下和上面的对称密钥的不同，很简单，不同之处就是对称密钥只有一个密钥，而非对称密钥有两个（我觉得严谨来说可以有多个，但在这里先局限地说有两个），而且一个叫公钥，一个叫密钥。</p><p>还是上面的张三李四例子，就相当于张三这次用公钥来加密 apple 这个单词，加密成一段密文，这段密文<strong>只能由密钥来解密</strong>，即便是你有了公钥，也不能将其解密。</p><p>然后来抛出几个问题来分析之：</p><blockquote><p>【Q1】公钥和密钥怎么来规定呢？我要是一个网络攻击者，我利用公钥来推理出密钥，那我岂不是直接解密了？！</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612945567958-1cd39a87-ba61-4dd8-955e-1a4fc130378d.png#align=left&display=inline&height=290&margin=%5Bobject%20Object%5D&name=image.png&originHeight=579&originWidth=474&size=117414&status=done&style=stroke&width=237" alt="image.png"><br>具体的相关 mod 运算在此不做详述</p><blockquote><p>【Q2】算法可靠与否</p></blockquote><p>为了保证严谨，同时也证明了这种算法的</p><ul><li>可行性，所计算出来的算法复杂度最高是 4 次方，对计算机而言，可计算</li><li>不可攻破，在学界，大数因子分解不可行，或者说，如今的科技还不能轻易的破解</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612945767363-ee62dad7-357d-42d3-a932-78cc10d29866.png#align=left&display=inline&height=337&margin=%5Bobject%20Object%5D&name=image.png&originHeight=674&originWidth=985&size=269673&status=done&style=stroke&width=492.5" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612945781929-bea0946c-3f24-472d-a4d4-3c40abd83ee3.png#align=left&display=inline&height=244&margin=%5Bobject%20Object%5D&name=image.png&originHeight=487&originWidth=987&size=177512&status=done&style=stroke&width=493.5" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> RSA算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>HTTPS较HTTP安全在哪？</title>
      <link href="/blog/pl8gro/"/>
      <url>/blog/pl8gro/</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612949716697-1ceb6a5c-fa5e-4129-9c0a-63e01ce75057.png#crop=0&crop=0&crop=1&crop=1&height=51&id=VgkSz&margin=%5Bobject%20Object%5D&name=image.png&originHeight=56&originWidth=615&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=6666&status=done&style=shadow&title=&width=564" alt="image.png"></p><h2 id="HTTPS-的精妙之处"><a href="#HTTPS-的精妙之处" class="headerlink" title="HTTPS 的精妙之处"></a>HTTPS 的精妙之处</h2><p>在我写的算法相关文章里面，有一篇 RSA 相关的文章<a href="https://www.yuque.com/wztlink1013/blog/ccd10c">https://www.yuque.com/wztlink1013/blog/ccd10c</a>，里面解释了对称加密和的非对称加密</p><p>我觉得 HTTPS 的精妙之处就是在于它同时运用了<strong>对称加密（AES）</strong>和<strong>非对称加密（RSA）</strong>两种加密，下面我解释一下：</p><h2 id="HTTP-为何不安全？"><a href="#HTTP-为何不安全？" class="headerlink" title="HTTP 为何不安全？"></a>HTTP 为何不安全？</h2><p>客户端对服务端做出请求，然后服务端做出响应，这个大家都知道，但是 HTTP 是明文传输，我在<a href="https://www.yuque.com/wztlink1013/blog/bw80k6/">https://www.yuque.com/wztlink1013/blog/bw80k6/</a>这篇文章里面也详细抓包展示了 HTTP 的明文传输<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612946821326-d568e02e-1173-4af4-93c5-539275023ba3.png#crop=0&crop=0&crop=1&crop=1&height=282&id=rZuDh&margin=%5Bobject%20Object%5D&name=image.png&originHeight=563&originWidth=1544&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=287151&status=done&style=stroke&title=&width=772" alt="image.png"><br>这样传输的信息就不安全，攻击者就能轻易得到，进一步讲，得到了就不安全吗？</p><ul><li>因为假如此时服务端响应给客户端的是很重要的诸如密码或者个人信息之类的敏感信息，就会被窃听</li><li>中途截取，将所传输的信息不完整等等</li></ul><h2 id="HTTPS-安全在哪？精妙之处！"><a href="#HTTPS-安全在哪？精妙之处！" class="headerlink" title="HTTPS 安全在哪？精妙之处！"></a>HTTPS 安全在哪？精妙之处！</h2><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612947167321-69c11c8d-9f8d-4f78-80a9-b2ee1c02e6b8.png#crop=0&crop=0&crop=1&crop=1&height=259&id=m1HhZ&margin=%5Bobject%20Object%5D&name=image.png&originHeight=517&originWidth=992&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=373859&status=done&style=stroke&title=&width=496" alt="image.png"><br>由上图所示，HTTPS 的协议栈相较 HTTP 协议栈多了安全层，也就是 SSL(安全套接层)或者 TSL(安全传输层)协议<br><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1651901470392-70830d5a-2402-4dd5-90d2-f1f52004da65.png#clientId=u27476d36-bcfa-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=386&id=u6c39ea43&margin=%5Bobject%20Object%5D&originHeight=697&originWidth=788&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=stroke&taskId=u52ca671a-b326-4dd6-9978-90f0abfc017&title=&width=436.015625"></p><ol><li><p>客户端向服务端发出一个 https 请求，其中端口位 443</p><blockquote><p>说明：采用 https 的网站都会有相应的 ssl 证书，在服务器那里，这个证书内容就是颁发的机构、到期时间……，而这个证书的形式就是以公钥的形式存在于服务器的。</p></blockquote></li><li><p>服务端响应给客户端这个证书（公钥的形式）</p></li><li><p>客户端解析响应来的公钥，因为需要验证这个 ssl 是不是伪造的还是过期了等等，假如验证不成功，就会如下：</p></li></ol><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612948950125-219e56dd-b6cd-4245-8aa5-44ad8e6e381c.png#crop=0&crop=0&crop=1&crop=1&height=38&id=orB4W&margin=%5Bobject%20Object%5D&name=image.png&originHeight=75&originWidth=605&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=7708&status=done&style=stroke&title=&width=302.5" alt="image.png"></p><ol start="4"><li>然后客户端（浏览器）利用这个公钥随机得出的私钥，然后将这个私钥发给服务端，以后客户端和服务端就可以利用这个密钥来解密双方传来传去的加密信息了<blockquote><p>说明：随机的出的私钥并不是那么“随机”，因为要保证不可攻破性，具体可以看我的 RSA 算法相关文章</p></blockquote></li></ol><hr><ol start="5"><li>服务端将要展示给客户端的具体信息利用上述私钥来加密</li><li>客户端接收到服务端发过来的加密信息，用共同都有的私钥解密查看之<blockquote><p>整个过程对外人而言看到的都是加密后的信息，而不是明文</p></blockquote></li></ol><p>综上，56 条是采用了 AES 对称加密，而前面是利用 RSA 算法得到私钥</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>这位博主（数据中心网络工程师）将 SSL 讲解的更加细致，可以常看：<a href="https://cshihong.github.io/2019/05/09/SSL%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/">SSL/TLS 协议详解</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>关于CDN的一些概念</title>
      <link href="/blog/fxzcy3/"/>
      <url>/blog/fxzcy3/</url>
      
        <content type="html"><![CDATA[<h2 id="CDN-回源"><a href="#CDN-回源" class="headerlink" title="CDN 回源"></a>CDN 回源</h2><p>cdn 回源是什么意思？CDN 回源包括回源地址和加速<a href="https://www.west.cn/services/domain/">域名</a>。常规的 CDN 都是回源的。即：当有用户访问某一个 URL 的时候，如果被解析到的那个 CDN 节点没有缓存响应的内容，或者是缓存已经到期，就会回源站去获取。如果没有人访问，那么 CDN 节点不会主动去源站拿的。<br>回源地址：可以使回源域名，也可以是回源 IP，主要作用是 CDN 加速节点同步更新的一个地址；<br>加速域名：使用 CDN<a href="https://www.west.cn/cloudhost/">服务器</a>需要加速的一个域名，一般会将加速域名做别名解析为 CDN 运营商提供的域名，来做 CDN 加速访问。<br><a href="https://www.west.cn/docs/wp-content/uploads/2018/05/n-40.jpg"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1612941062375-753094ca-dc39-494d-abaf-022708a631a3.jpeg#align=left&display=inline&height=300&margin=%5Bobject%20Object%5D&originHeight=300&originWidth=581&size=0&status=done&style=stroke&width=581"></a><br>回源域名一般是 cdn 领域的专业术语，通常情况下，是直接用 ip 进行回源的，但是如果客户源站有多个 ip，并且 ip 地址会经常变化，对于 cdn 厂商来说，为了避免经常更改配置（回源 ip），会采用回源域名方式进行回源，这样即使源站的 ip 变化了，也不影响原有的配置。<br>CDN 本来是给网站加速的，但是有时会因为不合适的回源策略给服务器带来负担，只有选择正确的策略才能给自己的网站带来更高的访问效率。</p><h2 id="网站优化"><a href="#网站优化" class="headerlink" title="网站优化"></a>网站优化</h2><h3 id="Gzip-智能压缩"><a href="#Gzip-智能压缩" class="headerlink" title="Gzip 智能压缩"></a>Gzip 智能压缩</h3><p>gzip 是 GNUzip 的缩写，最早用于 UNIX 系统的文件压缩</p><p>HTTP 协议上的 gzip 编码是一种用来改进 web 应用程序性能的技术，web 服务器和客户端（浏览器）必须共同支持 gzip<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612939525023-772b71d1-11ea-4f13-8629-500d71865e16.png#align=left&display=inline&height=352&margin=%5Bobject%20Object%5D&name=image.png&originHeight=703&originWidth=1091&size=127314&status=done&style=stroke&width=545.5" alt="image.png"></p><h3 id="Brotli-智能压缩"><a href="#Brotli-智能压缩" class="headerlink" title="Brotli 智能压缩"></a>Brotli 智能压缩</h3><p>也是一种静态资源压缩算法，并且也支持 HTTPS</p><h3 id="页面压缩"><a href="#页面压缩" class="headerlink" title="页面压缩"></a>页面压缩</h3><p>去除掉页面的注释或空格提高传输效率</p><h3 id="302-调度"><a href="#302-调度" class="headerlink" title="302 调度"></a>302 调度</h3><p><a href="https://cloud.tencent.com/developer/article/1445728">CDN 系列学习文章（三）——302 调度</a></p><p>作者：深蓝加菲<br>链接：<a href="https://www.zhihu.com/question/32148047/answer/70920110">https://www.zhihu.com/question/32148047/answer/70920110</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><p>一般是两者结合，DNS 做省市级别和跨运营商的调度， 302 做基于内容和精确 IP 的精确调度<br>DNS 的优点：<br>DNS 系统是天然的分布式结构<br>客户端本机，LDNS 都可以实现 cache，<strong>架构本身就能实现高的伸缩性和性能</strong></p><hr><p>DNS 的缺点：<br>DNS 并不是为 GSLB 设计的<br>GSLB 基于 local DNS 的地址判断，<strong>粒度较粗</strong>。而且 LDNS 可能和 end user 网络距离很远。<br>用户可能会设置错误的 Local DNS，该服务器和用户实际距离较远，比如 8.8.8.8 等(edns-client-subnet 可以部分解决该问题)<br>DNS 请求里面<strong>不会带有内容信息</strong>，GSLB 只能拥有 LDNS ip 信息，无法针对内容作出更加灵活的判断<br>因为 DNS reply TTL，所以某个用户一段时间内的请求都会导向同一个 site (解决：趋向于较短的 TTL)<br>因为 local dns 缓存和 TTL 的存在，你很难判断某次的返回会对负载有多大影响<br>某些 Local DNS 会忽略 DNS TTL 信息，而采用固定的 TTL 时间，对此我们无能为力<br>电信系统倾向于直接使用 ip 地址访问，不使用域名</p><hr><p>302 的优点：<br>可以直接得到 end user ip 和内容的地址，可以<strong>做出精确的 redirect</strong><br>每个请求都需要访问 GSLB,可以做出单独的处理<br>可以在一个点方便的作出统计和认证</p><hr><p>302 的缺点：<br>需要应用层协议支持(http / rtsp)<br>一般有重定向次数限制<br>GSLB 需要处理较多的请求，却没有 LDNS 作为 cache<br>GSLB 暴露给 end user ， 容易遭受攻击<br>用户访问 GSLB 本身就会带来时延，可能深圳的用户需要访问北京的 GSLB<br>单点故障(可以通过 GSLB 服务群集解决)<br>某些应用对 URL 变化敏感，比如 WEB<br>某些客户端支持不好(中文字符集等问题)</p><h3 id="TLS1-3"><a href="#TLS1-3" class="headerlink" title="TLS1.3"></a>TLS1.3</h3><p>TLS 1.3 是一种全新的加密协议，它既能提高终端用户的访问速度，又能增强安全性</p><h3 id="HTTP-2-Server-Push"><a href="#HTTP-2-Server-Push" class="headerlink" title="HTTP/2 + Server Push"></a>HTTP/2 + Server Push</h3><h3 id="WebP-自适应"><a href="#WebP-自适应" class="headerlink" title="WebP 自适应"></a>WebP 自适应</h3><p>WebP 自适应功能是 CDN 平台智能判断客户端浏览器是否支持 WebP 解码，如支持则返回 WebP 格式图片，否则返回原图，客户端以及源站无需任何改动。开启该特性，可以有效节省 CDN 传输带宽，加速图片渲染速度。</p><h2 id="网站防攻击"><a href="#网站防攻击" class="headerlink" title="网站防攻击"></a>网站防攻击</h2><h3 id="IP-限制访问"><a href="#IP-限制访问" class="headerlink" title="IP 限制访问"></a>IP 限制访问</h3><h3 id="CC-防护"><a href="#CC-防护" class="headerlink" title="CC 防护"></a>CC 防护</h3>]]></content>
      
      
      <categories>
          
          <category> 👨‍💻Web开发 </category>
          
          <category> Web其他知识 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>『Re：从零开始的异世界生活』</title>
      <link href="/essay/ghnpqy/"/>
      <url>/essay/ghnpqy/</url>
      
        <content type="html"><![CDATA[<div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">“我可是经历过死亡的人！”</div>第一次听到486说这句话的时候，我是有很大的感触的，甚至是共鸣，因为，见过地狱的人啊……被历史所记载下来的人，总有异于常人的行为准则。<p>希特勒，大三寒假在家那会在家看了郭伟强作者译作的《希特勒》一书，以前，我觉得我或多或少了解那个恶魔，因为二战，我觉得这人应该是人们脑海中残酷战争的人形代表吧。或在少年时期，一个人的精神和心智都是极其可变的……</p><p>如果把思维换一下来思考，如果，我明天就死了，那么现在的我会做出什么样的行为呢？因为懂得地狱的可怕，那可怕来自心里面的恐惧、来自亲人爱人的离去、来自一切想要去守护的人的离去……</p><p>见过地狱的人啊。</p><div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">如果真爱有颜色，那么一定是蓝色</div>]]></content>
      
      
      <categories>
          
          <category> 影视 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>『进击的巨人』是信仰</title>
      <link href="/essay/ebg1s8/"/>
      <url>/essay/ebg1s8/</url>
      
        <content type="html"><![CDATA[<hr><p>21.05更</p><p><del>海的那边，是自由。</del></p><p>海的那边，是杀千刀的jsc<img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1623928492929-ffc048a0-5a85-4f9c-81d6-c71ceda450b5.jpeg#align=left&display=inline&height=75&id=uLVJZ&margin=%5Bobject%20Object%5D&originHeight=75&originWidth=75&status=done&style=none&width=75"></p><h2 id=""><a href="#" class="headerlink" title=""></a><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1623928497065-1e541eba-d224-4125-acee-eb249a83bb3b.jpeg#align=left&display=inline&height=50&id=oqhQI&margin=%5Bobject%20Object%5D&originHeight=50&originWidth=50&status=done&style=none&width=50"></h2><p>兵长永远是最强的……</p><div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">你刚才玩的挺开心啊~</div><p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1619319047360-440f4560-ea7d-4751-822c-0451f0fa40f0.jpeg#align=left&display=inline&height=814&id=u0d61af7a&margin=%5Bobject%20Object%5D&name=011.jpg&originHeight=814&originWidth=1100&size=466024&status=done&style=none&width=1100" alt="011.jpg"></p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1619482927278-c7d820d9-9797-45ff-89a6-3fc5b4a10304.png#align=left&display=inline&height=1080&id=GvVBt&margin=%5Bobject%20Object%5D&name=04.png&originHeight=1080&originWidth=1920&size=1897071&status=done&style=none&width=1920" alt="04.png"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1619482904818-7bc6ef93-00d8-4fc1-ac3b-75338fb25a41.png#align=left&display=inline&height=1080&id=LStyO&margin=%5Bobject%20Object%5D&name=Snipaste_2020-12-21_11-03-35.png&originHeight=1080&originWidth=1920&size=1220501&status=done&style=none&width=1920" alt="Snipaste_2020-12-21_11-03-35.png"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1619482905865-3e7b798f-1888-4ecc-86fd-8200bc78b73b.png#align=left&display=inline&height=1080&id=ExxI6&margin=%5Bobject%20Object%5D&name=Snipaste_2021-01-18_12-39-58.png&originHeight=1080&originWidth=1920&size=926577&status=done&style=none&width=1920" alt="Snipaste_2021-01-18_12-39-58.png"></p><p>![ZE5}I@{<del>]L4$KBF{[@DYK3Q(1).png](<a href="https://cdn.nlark.com/yuque/0/2021/png/1484158/1619482909799-aec5bedb-ce37-4f2c-959a-b15c3bd34e8f.png#align=left&amp;display=inline&amp;height=1080&amp;id=W3TmY&amp;margin=%5Bobject%20Object%5D&amp;name=ZE5%7DI%40%7B">https://cdn.nlark.com/yuque/0/2021/png/1484158/1619482909799-aec5bedb-ce37-4f2c-959a-b15c3bd34e8f.png#align=left&amp;display=inline&amp;height=1080&amp;id=W3TmY&amp;margin=%5Bobject%20Object%5D&amp;name=ZE5%7DI%40%7B</a></del>%5DL4%24KBF%7B%5B%40DYK3Q%281%29.png&amp;originHeight=1080&amp;originWidth=1920&amp;size=1435340&amp;status=done&amp;style=none&amp;width=1920)</p>]]></content>
      
      
      <categories>
          
          <category> 影视 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>NPM包的发布、调试、使用</title>
      <link href="/blog/auczes/"/>
      <url>/blog/auczes/</url>
      
        <content type="html"><![CDATA[<p>介绍 Node.js 的包管理工具 NPM 的使用，同时介绍两种调试包的方式。</p><h2 id="注册一个包"><a href="#注册一个包" class="headerlink" title="注册一个包"></a>注册一个包</h2><ul><li><a href="https://www.npmjs.com/">https://www.npmjs.com/</a>注册的用户账号</li></ul><p>新建一个文件夹<code>npm-wzutao</code>再此文件夹下进入 bash</p><h3 id="npm-login"><a href="#npm-login" class="headerlink" title="npm login"></a>npm login</h3><p>登录自己的 npm 账号，所发布的包在该账号下。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612782412366-aeecc92e-a5e0-4f3d-9172-c607a5c06199.png#crop=0&crop=0&crop=1&crop=1&height=112&id=eG8zD&margin=%5Bobject%20Object%5D&name=image.png&originHeight=223&originWidth=882&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=27239&status=done&style=none&title=&width=441" alt="image.png"></p><h3 id="npm-init"><a href="#npm-init" class="headerlink" title="npm init"></a>npm init</h3><p>初始化该包</p><blockquote><p>也可以快速创建 <code>npm init -y</code></p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612782805229-e691af8b-0440-4fdb-baa6-63f5089017bb.png#crop=0&crop=0&crop=1&crop=1&height=441&id=QpvJz&margin=%5Bobject%20Object%5D&name=image.png&originHeight=881&originWidth=843&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=81289&status=done&style=none&title=&width=421.5" alt="image.png"><br>然后在该文件夹下新建 index.js 文件，写入如下测试代码</p><pre><code class="javascript">exports.sum = function () &#123;  var res = 0;  for (var i = 0; i &lt; arguments.length; i++) &#123;    res += arguments[i];  &#125;  return res;&#125;;</code></pre><h2 id="发布包"><a href="#发布包" class="headerlink" title="发布包"></a>发布包</h2><h3 id="npm-publish"><a href="#npm-publish" class="headerlink" title="npm publish"></a>npm publish</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612782959102-a6d78720-76a0-472a-b0d9-430c83ce7c8b.png#crop=0&crop=0&crop=1&crop=1&height=196&id=JUrwH&margin=%5Bobject%20Object%5D&name=image.png&originHeight=392&originWidth=761&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=45114&status=done&style=none&title=&width=380.5" alt="image.png"><br>去官网可以搜索到<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612783041850-acf55586-80aa-4cf5-b19a-7f538396fadd.png#crop=0&crop=0&crop=1&crop=1&height=211&id=nvASC&margin=%5Bobject%20Object%5D&name=image.png&originHeight=759&originWidth=1663&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=82826&status=done&style=stroke&title=&width=463" alt="image.png"></p><h3 id="npm-version"><a href="#npm-version" class="headerlink" title="npm version"></a>npm version</h3><p>更新版本号<br>1.0.1 版本，注意，是最后一位修改了增 1</p><pre><code class="bash">npm version patch</code></pre><p>1.1.0 版本，注意，是第二位修改了增 1</p><pre><code class="bash">npm version minor</code></pre><p>2.0.0 版本，注意，是第一位修改了增 1</p><pre><code class="bash">npm version major</code></pre><p>最后再提交到远端 npm 中</p><pre><code class="bash">npm publish</code></pre><h2 id="package-json-文件"><a href="#package-json-文件" class="headerlink" title="package.json 文件"></a>package.json 文件</h2><p>项目依赖和开发依赖</p><ul><li>项目依赖就是这个产品线上运营所依赖的模块，在文件的 dependencies 字段</li></ul><p>npm install 包名</p><ul><li>开发依赖就是项目的开发阶段需要依赖，线上运营阶段不需要依赖的第三方包，称为开发依赖，devDependencies 字段</li></ul><p>npm install 包名 –save-dev</p><ul><li>npm install –production，在本地下载依赖的包</li><li>里面的 script 使用：npm run XXX</li></ul><h3 id="scripts"><a href="#scripts" class="headerlink" title="scripts"></a>scripts</h3><p>参考：<a href="https://www.ruanyifeng.com/blog/2016/10/npm_scripts.html">npm scripts 使用指南-阮一峰的网络日志</a></p><p>package.josn</p><pre><code class="json">&#123;  &quot;name&quot;: &quot;learn-scripts&quot;,  &quot;version&quot;: &quot;1.0.0&quot;,  &quot;description&quot;: &quot;&quot;,  &quot;main&quot;: &quot;index.js&quot;,  &quot;scripts&quot;: &#123;    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;,    &quot;runFile&quot;: &quot;node index.js&quot;,    &quot;commit&quot;: &quot;git status &amp;&amp; git add . &amp;&amp; git-cz&quot;,    &quot;runBashCommand&quot;: &quot;git --version &amp;&amp; git help -a&quot;  &#125;,  &quot;keywords&quot;: [],  &quot;author&quot;: &quot;&quot;,  &quot;license&quot;: &quot;ISC&quot;&#125;</code></pre><h2 id="package-lock-json-文件"><a href="#package-lock-json-文件" class="headerlink" title="package-lock.json 文件"></a>package-lock.json 文件</h2><ul><li>锁定包的版本，确保再次下载时不会因为包版本不同而产生问题</li><li>加快下载速度，因为该文件中已经记录了项目所依赖第三方包的树状结构和包的下载地址，重新安装时只需下载即可，不需要做额外的工作</li></ul><h2 id="本地调试-npm-包的问题"><a href="#本地调试-npm-包的问题" class="headerlink" title="本地调试 npm 包的问题"></a>本地调试 npm 包的问题</h2><h3 id="相对路径测试所开发的-npm-包"><a href="#相对路径测试所开发的-npm-包" class="headerlink" title="相对路径测试所开发的 npm 包"></a>相对路径测试所开发的 npm 包</h3><blockquote><p>适合项目所需的某一个 npm 包</p></blockquote><p>比如 a 文件夹下有 npm 包 b 文件夹和测试插件的 c 文件夹，那么在 c 文件夹下使用<code>npm i ../b</code>命令来下载本地开发的 npm 包。</p><h3 id="npm-link-链接全局测试"><a href="#npm-link-链接全局测试" class="headerlink" title="npm link 链接全局测试"></a>npm link 链接全局测试</h3><blockquote><p>适合脚手架类型的 npm 包</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1644571675015-971bcbde-3119-43dd-90ed-8ef33c5bb478.png#clientId=u4e849149-788a-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=288&id=ue70d5364&margin=%5Bobject%20Object%5D&name=image.png&originHeight=582&originWidth=882&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=50555&status=done&style=none&taskId=u7887dcf8-1354-4d92-9958-c069ba60ba4&title=&width=436" alt="image.png"><br>node 全局包目录如下：其实就是链接使用一下而已<br><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1644571733855-7615cfb8-8648-4468-ad35-199c95161160.png#clientId=u4e849149-788a-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=263&id=u1fb22cf2&margin=%5Bobject%20Object%5D&name=image.png&originHeight=511&originWidth=832&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=44652&status=done&style=stroke&taskId=u41a7f038-9176-4dfd-be3b-ef4ba61c937&title=&width=428" alt="image.png"></p><h3 id="jest-测试框架"><a href="#jest-测试框架" class="headerlink" title="jest 测试框架"></a>jest 测试框架</h3><blockquote><p>适合各种项目，不仅是 npm 包，vue 项目等也需要这种测试工具</p></blockquote><ul><li>详细查看：<a href="https://www.wztlink1013.com/blog/blhxct/#%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95-Jest">https://www.wztlink1013.com/blog/blhxct</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 👨‍💻Web开发 </category>
          
          <category> Node.js </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>IDEA环境下的Javaweb开发bug汇总</title>
      <link href="/blog/aiuif3/"/>
      <url>/blog/aiuif3/</url>
      
        <content type="html"><![CDATA[<h2 id="Unsupported-major-minor-version-52-0"><a href="#Unsupported-major-minor-version-52-0" class="headerlink" title="Unsupported major.minor version 52.0"></a>Unsupported major.minor version 52.0</h2><blockquote><p>版本过低</p></blockquote><pre><code class="java">[2021-02-07 08:25:52,537] Artifact javaweb-blog:war exploded: Error during artifact deployment. See server log for details.</code></pre><pre><code class="java"> java.lang.UnsupportedClassVersionError: com/nic/filter/AdminFilter : Unsupported major.minor version 52.0 (unable to load class com.nic.filter.AdminFilter)</code></pre><p>一直报错，网上找一直是说和 jdk 的版本有关，但是 jdk 的版本尝试更换几个都无效。事实上是 Tomcat 的版本问题，项目开始用的是 Tomcat8.1 升级至 8.5.34 即可（升级 Tomcat9 可以否？会对下兼容吗？trytry）</p><h2 id="org-apache-tomcat-util-descriptor-web-WebXml-setVersion-Unknown-version-string-4-0"><a href="#org-apache-tomcat-util-descriptor-web-WebXml-setVersion-Unknown-version-string-4-0" class="headerlink" title="org.apache.tomcat.util.descriptor.web.WebXml.setVersion Unknown version string [4.0]"></a>org.apache.tomcat.util.descriptor.web.WebXml.setVersion Unknown version string [4.0]</h2><blockquote><p>warning：4.0 太高</p></blockquote><pre><code class="java">org.apache.tomcat.util.descriptor.web.WebXml.setVersion Unknown version string [4.0]</code></pre><ul><li>解决：<a href="https://blog.csdn.net/qq_32483145/article/details/80292463">https://blog.csdn.net/qq_32483145/article/details/80292463</a></li></ul><h2 id="用到-servlet-的页面跳转-404"><a href="#用到-servlet-的页面跳转-404" class="headerlink" title="用到 servlet 的页面跳转 404"></a>用到 servlet 的页面跳转 404</h2><h3 id="web-xml-配置有误"><a href="#web-xml-配置有误" class="headerlink" title="web.xml 配置有误"></a>web.xml 配置有误</h3><p>页面能访问，也成功部署到 tomcat 下面的 weapps 文件夹下面，但是在进行页面跳转的过程中，会出现下面的 404 情况。分析之后是我这个项目是新建的一个空项目，然后代码是之前在 eclipse 下运行过的，而后直接将内容代码复制过来，却没复制 web.xml，导致现项目的 web.xml 是“空的”，无配置。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612753264339-b79c791c-6814-4c38-b42d-6b85bb9c1d5f.png#crop=0&crop=0&crop=1&crop=1&height=144&id=VxL8Y&margin=%5Bobject%20Object%5D&name=image.png&originHeight=288&originWidth=1920&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=37994&status=done&style=none&title=&width=960" alt="image.png"></p><h3 id="Tomcat-路径配置有误"><a href="#Tomcat-路径配置有误" class="headerlink" title="Tomcat 路径配置有误"></a>Tomcat 路径配置有误</h3><p>还有一种情况，就是 tomcat 配置过程中的那两个路径也要注意下<br>调整为如下配置，不然会出现访问/jsp-peojectname/jsp-peojectname/index.jsp 页面为 404 的情况<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612756924057-55c60ad3-85b8-4cf0-aa9d-6184bfbd296e.png#crop=0&crop=0&crop=1&crop=1&height=78&id=rdvlv&margin=%5Bobject%20Object%5D&name=image.png&originHeight=156&originWidth=1611&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=17507&status=done&style=none&title=&width=805.5" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612756936656-72d837f5-46ef-4d35-8e39-e49d2c6f077d.png#crop=0&crop=0&crop=1&crop=1&height=97&id=qzUm9&margin=%5Bobject%20Object%5D&name=image.png&originHeight=194&originWidth=1611&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=12795&status=done&style=none&title=&width=805.5" alt="image.png"></p><h3 id="其他类型错误"><a href="#其他类型错误" class="headerlink" title="其他类型错误"></a>其他类型错误</h3><p>可能还有其他类型错误，参考以下的总结</p><ul><li><a href="https://blog.csdn.net/DBC_121/article/details/79204340">Web 开发：关于 Tomcat 出现 The origin server did not find a current representation for the target resourc…的问题</a></li></ul><h2 id="数据库报错"><a href="#数据库报错" class="headerlink" title="数据库报错"></a>数据库报错</h2><p>navicat 也不能查看该数据库</p><pre><code class="java">HTTP Status 500 – Internal Server ErrorType Exception ReportMessage get connection error!Description The server encountered an unexpected condition that prevented it from fulfilling the request.Exceptionjava.lang.RuntimeException: get connection error!    com.nic.util.JdbcUtil.getConnection(JdbcUtil.java:55)    com.nic.dao.ArticleDao.findArticle(ArticleDao.java:56)    com.nic.service.ArticleService.findArticle(ArticleService.java:20)    com.nic.servlet.PostlistServlet.doGet(PostlistServlet.java:50)    javax.servlet.http.HttpServlet.service(HttpServlet.java:635)    javax.servlet.http.HttpServlet.service(HttpServlet.java:742)    org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:52)Root Causejava.lang.ClassNotFoundException: com.mysql.jdbc.Driver    org.apache.catalina.loader.WebappClassLoaderBase.loadClass(WebappClassLoaderBase.java:1309)    org.apache.catalina.loader.WebappClassLoaderBase.loadClass(WebappClassLoaderBase.java:1137)    java.lang.Class.forName0(Native Method)    java.lang.Class.forName(Class.java:264)    com.nic.util.JdbcUtil.getConnection(JdbcUtil.java:52)    com.nic.dao.ArticleDao.findArticle(ArticleDao.java:56)    com.nic.service.ArticleService.findArticle(ArticleService.java:20)    com.nic.servlet.PostlistServlet.doGet(PostlistServlet.java:50)    javax.servlet.http.HttpServlet.service(HttpServlet.java:635)    javax.servlet.http.HttpServlet.service(HttpServlet.java:742)    org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:52)Note The full stack trace of the root cause is available in the server logs.Apache Tomcat/8.5.34</code></pre><p>初步分析是用的 phpstudy 里面的 mysql 数据库不能生效，删除电脑之前的 mysql，用 phpstudy 数据库恢复</p><hr><p>但是还会报错，判断应该是代码文件出错【不过不用将这个 jar 包导入到 lib 文件夹下（反而会报错），只需要将其导入到 tomcat 文件夹下的 lib 文件夹，即可】<br><a href="https://www.yuque.com/attachments/yuque/0/2021/jar/1484158/1612768356808-4c69cbaa-cbc7-4ebe-9232-423cad8ef54f.jar?_lake_card=%7B%22src%22:%22https://www.yuque.com/attachments/yuque/0/2021/jar/1484158/1612768356808-4c69cbaa-cbc7-4ebe-9232-423cad8ef54f.jar%22,%22name%22:%22mysql-connector-java-5.1.49.jar%22,%22size%22:1006904,%22type%22:%22%22,%22ext%22:%22jar%22,%22status%22:%22done%22,%22uid%22:%221612761483730-0%22,%22progress%22:%7B%22percent%22:99%7D,%22percent%22:0,%22refSrc%22:%22https://www.yuque.com/attachments/yuque/0/2021/jar/1484158/1612761486309-2d90c3e5-5a0c-4b57-95f5-5551ed944a23.jar%22,%22id%22:%22xrOhc%22,%22card%22:%22file%22%7D">mysql-connector-java-5.1.49.jar</a>（或者直接上网搜再下载）<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612756117413-4649efa1-9274-4ae5-aa1a-463750acd571.png#crop=0&crop=0&crop=1&crop=1&height=332&id=ISElc&margin=%5Bobject%20Object%5D&name=image.png&originHeight=663&originWidth=1291&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=105075&status=done&style=shadow&title=&width=645.5" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> ✨其他 </category>
          
          <category> Bug </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>IDEA创建JavaWeb项目</title>
      <link href="/blog/qi1ddv/"/>
      <url>/blog/qi1ddv/</url>
      
        <content type="html"><![CDATA[<h2 id="一、Tomcat-下载"><a href="#一、Tomcat-下载" class="headerlink" title="一、Tomcat 下载"></a>一、Tomcat 下载</h2><h3 id="1-下载并安装"><a href="#1-下载并安装" class="headerlink" title="1. 下载并安装"></a>1. 下载并安装</h3><blockquote><p>假如不是集成开发环境（比如 phpstudy），电脑要有 jdk 环境</p></blockquote><p>【1】官网下载：<a href="http://tomcat.apache.org/">http://tomcat.apache.org/</a></p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598787914511-a035ba93-0b7a-450b-b391-5d1452435ca7.png#align=left&display=inline&height=220&margin=%5Bobject%20Object%5D&originHeight=952&originWidth=1842&size=0&status=done&style=shadow&width=425"><br>【2】下载并解压到自己的相应盘区，再检验是否成功<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598787914448-2ef2e1a1-2966-4d35-8bfe-82162aa1588b.png#align=left&display=inline&height=273&margin=%5Bobject%20Object%5D&originHeight=727&originWidth=1147&size=0&status=done&style=shadow&width=431"><br>点击第二个框不出现闪退情况则证明成功<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598787914507-87063aec-884a-4180-b124-568478d81bc0.png#align=left&display=inline&height=222&margin=%5Bobject%20Object%5D&originHeight=639&originWidth=1223&size=0&status=done&style=shadow&width=425"><br>【3】浏览器进入端口<a href="http://localhost:8080/">http://localhost:8080/</a>上述配置成功则表明成功<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598787914624-248148e3-3f5f-45ca-ad93-c063216a7aff.png#align=left&display=inline&height=270&margin=%5Bobject%20Object%5D&originHeight=1030&originWidth=1838&size=0&status=done&style=shadow&width=482"></p><h3 id="2-过程中可能会出现的问题"><a href="#2-过程中可能会出现的问题" class="headerlink" title="2. 过程中可能会出现的问题"></a>2. 过程中可能会出现的问题</h3><p>【1】点击 startup.bat 文件出现闪退</p><blockquote><p>电脑中 java jdk 有无（JAVA_HOME）</p></blockquote><p>【2】端口被占用</p><blockquote><p>进入 Tomcat 文件夹下的 conf 文件下的 server.xml 文件，用记事本查找 8080，下面复制一个新的初始端口<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598787914513-8083bc6e-4c6f-436e-b0b0-98d3d70b9dea.png#align=left&display=inline&height=80&margin=%5Bobject%20Object%5D&originHeight=80&originWidth=557&size=0&status=done&style=shadow&width=557"></p></blockquote><h2 id="二、利用-IDEA-创建一个-JavaWeb-项目"><a href="#二、利用-IDEA-创建一个-JavaWeb-项目" class="headerlink" title="二、利用 IDEA 创建一个 JavaWeb 项目"></a>二、利用 IDEA 创建一个 JavaWeb 项目</h2><h3 id="1-创建新项目"><a href="#1-创建新项目" class="headerlink" title="1. 创建新项目"></a>1. 创建新项目</h3><p>依次点击：<code>File </code>-&gt; <code>New </code>-&gt; <code>Project</code><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612697874347-fef7ad38-7ff2-4567-89a9-f5d47a1f4824.png#align=left&display=inline&height=316&margin=%5Bobject%20Object%5D&name=image.png&originHeight=812&originWidth=1202&size=104672&status=done&style=none&width=468" alt="image.png"></p><h3 id="2-项目工程配置"><a href="#2-项目工程配置" class="headerlink" title="2. 项目工程配置"></a>2. 项目工程配置</h3><p>【1】在<code>WEB-INF</code>下创建两个空文件夹 <code>classes</code> <code>lib</code></p><blockquote><p>目的：</p><ul><li>classes 文件夹用于存放编译后的 class 文件</li><li>lib 文件夹用于存放依赖的 jar 包</li></ul></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612697966439-ab639870-61ab-429e-919a-4109c8cefdc5.png#align=left&display=inline&height=237&margin=%5Bobject%20Object%5D&name=image.png&originHeight=473&originWidth=469&size=29009&status=done&style=none&width=234.5" alt="image.png"><br>【2】依次点击<code>file</code> -&gt; <code>Project Structure</code></p><blockquote><p>目的：将后面编译的 class 文件默认生成到刚刚新建的 classes 目录下</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612698144393-24e78472-430b-47a4-b423-e091597bb4f3.png#align=left&display=inline&height=364&margin=%5Bobject%20Object%5D&name=image.png&originHeight=727&originWidth=1535&size=95789&status=done&style=none&width=767.5" alt="image.png"><br>【3】依次点击<code>file</code> -&gt; <code>Project Structure</code></p><blockquote><p>目的：添加 jar 包依赖<br>（项目所需要的 jar 包都放到刚刚新建的 lib 文件夹）<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612698241583-99ff6441-6e2a-4776-addb-9f8f1eda6636.png#align=left&display=inline&height=268&margin=%5Bobject%20Object%5D&name=image.png&originHeight=535&originWidth=1274&size=68026&status=done&style=none&width=637" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612698274993-98e1b314-c726-41e6-973e-1dbb07ef7312.png#align=left&display=inline&height=169&margin=%5Bobject%20Object%5D&name=image.png&originHeight=337&originWidth=546&size=22322&status=done&style=none&width=273" alt="image.png"><br>【4】配置打包方式 Artifacts<br><del>点击 Artifacts 选项卡，IDEA 会为该项目自动创建一个名为“JavaWeb:war exploded”的打包方式，表示 打包成 war 包，并且是文件展开性的，输出路径为当前项目下的 out 文件夹，保持默认即可。另外勾选下“Build on make”，表示编译的时候就打包部署，勾选“Show content of elements”，表示显示详细的内容列表。</del></p></blockquote><p><em>如果按照上面说的，那么会发现发布的项目并没有在 tomcat 目录下的 webapps 目录下，如果项目以前在其他电脑抑或是其他环境下运行过，可能会导致项目的很多子页面默认 URL404。</em><br><del><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612711385355-7645f327-ad5c-40aa-a165-b975f957ebe3.png#align=left&display=inline&height=239&margin=%5Bobject%20Object%5D&name=image.png&originHeight=479&originWidth=884&size=112691&status=done&style=shadow&width=442" alt="image.png"></del><br>正确解决办法：项目一开始依次点击<code>file</code> -&gt; <code>Project Structure</code></p><blockquote><p>1 区域：将 output 路径指定到<code>tomcat</code>的<code>webapps</code>下面（新建一个本项目的同名文件夹）<br>2 区域：Output Layout 就是配置这个路径里面生成的所有文件<br>3 区域：将右边的文件内容脱拉到左边的 3 区域即可</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612763067214-29b72122-e8c6-4df1-a112-50ffb6c43084.png#align=left&display=inline&height=327&margin=%5Bobject%20Object%5D&name=image.png&originHeight=653&originWidth=1535&size=81034&status=done&style=none&width=767.5" alt="image.png"></p><h3 id="3-Tomcat-配置"><a href="#3-Tomcat-配置" class="headerlink" title="3. Tomcat 配置"></a>3. Tomcat 配置</h3><p>【1】点击如下位置进入 tomcat 容器编辑板块<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612698536983-4544013a-5e2a-43d7-ae31-7aa5c871fb3a.png#align=left&display=inline&height=151&margin=%5Bobject%20Object%5D&name=image.png&originHeight=301&originWidth=1920&size=55468&status=done&style=none&width=960" alt="image.png"><br>【2】默认会自动给我们生成一个 Tomcat 容器，基本上只需要配置<code>Deployment</code>即可，如果没有默认生成就新建一个。其中<code>Application server</code>填写本地 tomcat 的安装目录文件夹即可（因为一台电脑开发可能会有多个 tomcat 版本）<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612711521404-673143aa-f3fd-4b37-aed1-919d0ea1de1f.png#align=left&display=inline&height=370&margin=%5Bobject%20Object%5D&name=image.png&originHeight=740&originWidth=1163&size=152940&status=done&style=none&width=581.5" alt="image.png"></p><blockquote><p>❗ ❗ ❗ 如果要换不同版本的 tomcat 来运行项目，改如下地方：</p><ol><li>先将上面图片<code>Application server</code>tomcat 版本更换至新的 tomcat 版本</li><li>去<code>2. 项目工程配置</code>步骤中，减去原先的 tomcat，加上新的 tomcat</li></ol></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612698612335-158bfcb3-3016-478c-b86a-770ad57ad2a9.png#align=left&display=inline&height=511&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1022&originWidth=1611&size=111169&status=done&style=none&width=805.5" alt="image.png"></p><blockquote><p>此处的 Application context 是指定本工程的根目录</p></blockquote><h3 id="4-结果测试"><a href="#4-结果测试" class="headerlink" title="4. 结果测试"></a>4. 结果测试</h3><p>在<code>index.jsp</code>文件下添加显示代码<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612698732177-5bedf912-6a16-47d4-ab96-d5527b9567d1.png#align=left&display=inline&height=271&margin=%5Bobject%20Object%5D&name=image.png&originHeight=542&originWidth=1879&size=244164&status=done&style=none&width=939.5" alt="image.png"><br>直接运行<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612698844575-2952fffc-3616-43f1-be90-138dbe0df86d.png#align=left&display=inline&height=128&margin=%5Bobject%20Object%5D&name=image.png&originHeight=256&originWidth=1107&size=40673&status=done&style=shadow&width=553.5" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612698866551-55b0f5c6-fc7e-423a-8c59-2af2cbe08953.png#align=left&display=inline&height=152&margin=%5Bobject%20Object%5D&name=image.png&originHeight=303&originWidth=827&size=28375&status=done&style=shadow&width=413.5" alt="image.png"></p><blockquote><p>如果在 Tomcat 配置过程中的部署路径为 <code>/</code> ，会出现下面第二张图的结果，都能访问，但是最好还是上面的方式，符合服务器“一个文件夹一个站点”的思想，路径访问的相关问题不会挖坑。</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612698976241-4d798089-9581-4cdf-893b-dbbc11b18057.png#align=left&display=inline&height=511&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1022&originWidth=1611&size=101904&status=done&style=none&width=805.5" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612698989649-0fdabed2-a690-450a-b11f-3900a477a68a.png#align=left&display=inline&height=170&margin=%5Bobject%20Object%5D&name=image.png&originHeight=340&originWidth=862&size=27789&status=done&style=shadow&width=431" alt="image.png"></p><h3 id="❗-JavaWeb-项目结构分析"><a href="#❗-JavaWeb-项目结构分析" class="headerlink" title="❗ JavaWeb 项目结构分析"></a>❗ JavaWeb 项目结构分析</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612752142869-4f7db98f-6d15-4ce5-be4b-1e0e13dcab08.png#align=left&display=inline&height=444&margin=%5Bobject%20Object%5D&name=image.png&originHeight=888&originWidth=321&size=43193&status=done&style=none&width=160.5" alt="image.png"></p><ul><li>src 文件夹：编写的 java 代码，编译后会放到 WEB-INF 文件夹下的 classes 文件夹</li><li>web 文件夹：web 应用程序的根目录，web 应用程序所有的文件都在该目录下</li><li>WEB-INF：客户不能直接通过浏览器进行访问<ul><li>classes：存放 servlet 和其他有用的 class 文件（编译后的）</li><li>lib：存放 web 应用程序所需要的 jar 包</li><li>web.xml：存放部署和配置信息的文件（当前 WEB 项目的核心配置，Servlet2.5 必须有，3.0 以后可省略）</li></ul></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://blog.csdn.net/m0_37499059/article/details/78806617">Intellij idea 创建 javaWeb 项目</a></li><li><a href="https://blog.csdn.net/c_little_white/article/details/89435646?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.control">IDEA 启动 tomcat 不报错，tomcat 的 webapps 文件夹没有项目文件，项目的默认 URL404</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 🔨环境工具 </category>
          
          <category> 环境搭建 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>BOM各种长宽的总结</title>
      <link href="/blog/5_day05_webapis/"/>
      <url>/blog/5_day05_webapis/</url>
      
        <content type="html"><![CDATA[<h2 id="其他关于长宽"><a href="#其他关于长宽" class="headerlink" title="其他关于长宽"></a><strong>其他关于长宽</strong></h2><h3 id="window-innerWidth-和-innerHeight"><a href="#window-innerWidth-和-innerHeight" class="headerlink" title="window.innerWidth 和 innerHeight"></a>window.innerWidth 和 innerHeight</h3><ul><li>表示文档显示区域的宽高，不包括工具栏和地址栏等区域；</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1617937380778-c1f24a67-c63e-49d1-9907-f7fe91880e9f.png#align=left&display=inline&height=238&margin=%5Bobject%20Object%5D&name=image.png&originHeight=476&originWidth=1236&size=64616&status=done&style=stroke&width=618" alt="image.png"></p><h3 id="window-pageYOffset-和-pageXOffset"><a href="#window-pageYOffset-和-pageXOffset" class="headerlink" title="window.pageYOffset 和 pageXOffset"></a>window.pageYOffset 和 pageXOffset</h3><p>ie9 往后才支持的“被卷去”的长度<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1617938014655-932453ea-63bc-4bc1-8388-63b41417892d.png#align=left&display=inline&height=210&margin=%5Bobject%20Object%5D&name=image.png&originHeight=420&originWidth=1234&size=62349&status=done&style=none&width=617" alt="image.png"></p><h3 id="鼠标事件对象-event"><a href="#鼠标事件对象-event" class="headerlink" title="鼠标事件对象 event"></a>鼠标事件对象 event</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518361978-034f2af6-14fa-4ddb-bd8b-2eabe289eb59.png#align=left&display=inline&height=308&margin=%5Bobject%20Object%5D&originHeight=308&originWidth=703&status=done&style=stroke&width=703"></p><h2 id="元素偏移量-offset"><a href="#元素偏移量-offset" class="headerlink" title="元素偏移量 offset"></a>元素偏移量 offset</h2><h3 id="offset-概述"><a href="#offset-概述" class="headerlink" title="offset 概述"></a>offset 概述</h3><blockquote><p>offset 翻译过来就是偏移量， 我们使用 offset 系列相关属性可以动态的得到该元素的位置（偏移）、大小等。</p></blockquote><ul><li><p>获得元素距离带有定位父元素的位置</p></li><li><p>获得元素自身的大小（宽度高度）</p></li><li><p>注意：返回的数值都不带单位</p></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616067042341-17b54a01-de40-4ad5-8a54-ad61317d27ae.png#align=left&display=inline&height=157&margin=%5Bobject%20Object%5D&name=image.png&originHeight=313&originWidth=1044&size=201699&status=done&style=stroke&width=522" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616068060630-5d0eeb72-5a55-48c4-8e60-1e0f2cd4afed.png#align=left&display=inline&height=440&margin=%5Bobject%20Object%5D&name=image.png&originHeight=880&originWidth=1920&size=2504958&status=done&style=stroke&width=960" alt="image.png"></p><h3 id="offset-与-style-区别"><a href="#offset-与-style-区别" class="headerlink" title="offset 与 style 区别"></a>offset 与 style 区别</h3><p>【1】offset</p><ul><li><p>offset 可以得到任意样式表中的样式值</p></li><li><p>offset 系列获得的数值是没有单位的</p></li><li><p><strong>offsetWidth 包含 padding+border+width</strong></p></li><li><p>offsetWidth 等属性是只读属性，只能获取不能赋值</p></li></ul><blockquote><p>所以，我们想要获取元素大小位置，用 offset 更合适</p></blockquote><p>【2】style</p><ul><li><p>style 只能得到<strong>行内样式表中的样式值</strong></p></li><li><p>style.width 获得的是带有单位的字符串</p></li><li><p>style.width 获得不包含 padding 和 border 的值</p></li><li><p>style.width 是可读写属性，可以获取也可以赋值</p></li></ul><blockquote><p>所以，我们想要给元素更改值，则需要用 style 改变<br><strong>因为平时我们都是给元素注册触摸事件，所以重点记住 targetTocuhes</strong></p></blockquote><h3 id="Demo：获取鼠标在盒子内的坐标"><a href="#Demo：获取鼠标在盒子内的坐标" class="headerlink" title="Demo：获取鼠标在盒子内的坐标"></a>Demo：获取鼠标在盒子内的坐标</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616069445575-c9a9b51d-665d-4f26-96bb-768a9415a230.png#align=left&display=inline&height=429&margin=%5Bobject%20Object%5D&name=image.png&originHeight=857&originWidth=1920&size=2461932&status=done&style=stroke&width=960" alt="image.png"></p><pre><code class="javascript">box.addEventListener(&quot;mousemove&quot;, function (e) &#123;  if (e.pageX &gt; box_left + box.width) &#123;    var ture_width = e.pageX - box_left + box_width;  &#125; else &#123;    var ture_width = e.pageX - box_left;  &#125;  if (e.pageY &gt; box_top + box_height) &#123;    var ture_height = e.pageY - box_top + box_height;  &#125; else &#123;    var ture_height = e.pageY - box_top;  &#125;  this.innerHTML = &quot;x坐标是&quot; + ture_width + &quot; y坐标是&quot; + ture_height;&#125;);</code></pre><h3 id="Demo：模态框拖拽"><a href="#Demo：模态框拖拽" class="headerlink" title="Demo：模态框拖拽"></a>Demo：模态框拖拽</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616210051320-8b04d6a8-efc0-4a78-a985-80fdc0a0c238.png#align=left&display=inline&height=440&margin=%5Bobject%20Object%5D&name=image.png&originHeight=879&originWidth=1920&size=63982&status=done&style=stroke&width=960" alt="image.png"></p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;  &lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot; /&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;    &lt;title&gt;Document&lt;/title&gt;    &lt;style&gt;      * &#123;        padding: 0px;        margin: 0px;      &#125;      a &#123;        text-decoration: none;        color: #000000;      &#125;      .login-header &#123;        width: 100%;        text-align: center;        height: 30px;        line-height: 30px;        font-size: 24px;      &#125;      .login-bg &#123;        display: none;        width: 100%;        height: 100%;        position: fixed;        top: 0px;        left: 0px;        background: rgba(0, 0, 0, 0.3);      &#125;      .login &#123;        display: none;        width: 512px;        height: 280px;        position: fixed;        left: 50%;        top: 50%;        z-index: 9999;        border: #ebebeb solid 1px;        background-color: #ffffff;        box-shadow: 0px 0px 20px #ddd;        transform: translate(-50%, -50%);      &#125;      .login-title &#123;        width: 100%;        margin: 10px 0 0 0;        text-align: center;        line-height: 40px;        height: 40px;        font-size: 18px;        position: relative;        cursor: move;      &#125;      .login-title span &#123;        position: absolute;        width: 40px;        height: 40px;        font-size: 12px;        background: #ffffff;        border: #ebebeb solid 1px;        right: -20px;        top: -30px;        border-radius: 50%;      &#125;      .login-input-content &#123;        margin: 20px 0 0 0;      &#125;      .login-input &#123;        overflow: hidden;        margin: 0px 0px 20px 0px;      &#125;      .login-input label &#123;        float: left;        width: 90px;        padding-right: 10px;        text-align: right;        line-height: 35px;        height: 35px;        font-size: 14px;      &#125;      .login-input input.list-input &#123;        float: left;        line-height: 35px;        height: 35px;        width: 350px;        border: #ebebeb 1px solid;        text-indent: 5px;      &#125;      .login-input input.button-login &#123;        display: block;        border: 1px #ebebeb solid;        height: 35px;        width: 50%;        margin: 20px auto;      &#125;    &lt;/style&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;div class=&quot;login-header&quot;&gt;      &lt;a id=&quot;link&quot; href=&quot;javascript:;&quot;&gt;点击，弹出登录框&lt;/a&gt;    &lt;/div&gt;    &lt;div id=&quot;loginBg&quot; class=&quot;login-bg&quot;&gt;&lt;/div&gt;    &lt;div id=&quot;login&quot; class=&quot;login&quot;&gt;      &lt;div class=&quot;login-title&quot;&gt;        登录会员        &lt;span          &gt;&lt;a id=&quot;closeBtn&quot; href=&quot;javascript:; &quot; class=&quot;close-login&quot;            &gt;关闭&lt;/a          &gt;&lt;/span        &gt;      &lt;/div&gt;      &lt;div class=&quot;login-input-content&quot;&gt;        &lt;div class=&quot;login-input&quot;&gt;          &lt;label&gt;用户名：&lt;/label&gt;          &lt;input            type=&quot;text&quot;            placeholder=&quot;请输入用户名&quot;            name=&quot;info[username]&quot;            id=&quot;username&quot;            class=&quot;list-input&quot;          /&gt;        &lt;/div&gt;        &lt;div class=&quot;login-input&quot;&gt;          &lt;label&gt;登录密码：&lt;/label&gt;          &lt;input            type=&quot;password&quot;            placeholder=&quot;请输入登录密码&quot;            name=&quot;info[password]&quot;            id=&quot;password&quot;            class=&quot;list-input&quot;          /&gt;        &lt;/div&gt;        &lt;div class=&quot;login-input&quot;&gt;          &lt;input type=&quot;button&quot; class=&quot;button-login&quot; value=&quot;登录会员&quot; /&gt;        &lt;/div&gt;      &lt;/div&gt;    &lt;/div&gt;    &lt;script&gt;      var link = document.getElementById(&quot;link&quot;);      var loginBg = document.getElementById(&quot;loginBg&quot;);      var login = document.getElementById(&quot;login&quot;);      var closeBtn = document.getElementById(&quot;closeBtn&quot;);      link.addEventListener(&quot;click&quot;, function () &#123;        loginBg.style.display = &quot;block&quot;;        login.style.display = &quot;block&quot;;      &#125;);      closeBtn.addEventListener(&quot;click&quot;, function () &#123;        loginBg.style.display = &quot;none&quot;;        login.style.display = &quot;none&quot;;      &#125;);      login.addEventListener(&quot;mousedown&quot;, function (e) &#123;        var x = e.pageX - login.offsetLeft;        var y = e.pageY - login.offsetTop;        document.addEventListener(&quot;mousemove&quot;, move);        function move(e) &#123;          login.style.left = e.pageX - x + &quot;px&quot;;          login.style.top = e.pageY - y + &quot;px&quot;;        &#125;        document.addEventListener(&quot;mouseup&quot;, function () &#123;          document.removeEventListener(&quot;mousemove&quot;, move);        &#125;);      &#125;);    &lt;/script&gt;  &lt;/body&gt;&lt;/html&gt;</code></pre><h2 id="元素可视区-client-系列"><a href="#元素可视区-client-系列" class="headerlink" title="元素可视区 client 系列"></a>元素可视区 client 系列</h2><h3 id="client-概述"><a href="#client-概述" class="headerlink" title="client 概述"></a>client 概述</h3><p>client 翻译过来就是客户端，我们使用 client 系列的相关属性来获取元素可视区的相关信息。通过 client<br>系列的相关属性可以动态的得到该元素的边框大小、元素大小等。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616070278053-25f4dbb3-2991-4ce4-b1ec-cb3a94f80c0c.png#align=left&display=inline&height=129&margin=%5Bobject%20Object%5D&name=image.png&originHeight=257&originWidth=1030&size=138269&status=done&style=stroke&width=515" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616070286487-4d2a07f6-46b7-4af4-be5c-134ac01d6b48.png#align=left&display=inline&height=150&margin=%5Bobject%20Object%5D&name=image.png&originHeight=299&originWidth=572&size=37702&status=done&style=stroke&width=286" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616070508648-c56b354b-77e7-4afb-9072-0385ac38782f.png#align=left&display=inline&height=441&margin=%5Bobject%20Object%5D&name=image.png&originHeight=881&originWidth=1920&size=1850210&status=done&style=stroke&width=960" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616070554658-21dea2fb-5942-4f60-9205-71bc2a022a79.png#align=left&display=inline&height=440&margin=%5Bobject%20Object%5D&name=image.png&originHeight=879&originWidth=1920&size=1704838&status=done&style=stroke&width=960" alt="image.png"></p><h3 id="淘宝-flexible-js-源码分析"><a href="#淘宝-flexible-js-源码分析" class="headerlink" title="淘宝 flexible.js 源码分析"></a>淘宝 flexible.js 源码分析</h3><ul><li>立即执行函数  (function(){})()  或者 (function(){}())</li><li>主要作用： 创建一个独立的作用域。 避免了命名冲突问题</li><li>下面三种情况都会刷新页面都会触发 load 事件。<ul><li>a 标签的超链接</li><li>F5 或者刷新按钮（强制刷新）</li><li>前进后退按钮<blockquote><p>但是 火狐中，有个特点，有个“往返缓存”，这个缓存中不仅保存着页面数据，还保存了 DOM 和 JavaScript 的状态；实际上是将整个页面都保存在了内存里。</p></blockquote></li></ul></li></ul><p>所以此时后退按钮不能刷新页面。</p><p>此时可以使用 pageshow 事件来触发。，这个事件在页面显示时触发，无论页面是否来自缓存。在重新加载页面中，pageshow 会在 load 事件触发后触发；根据事件对象中的 persisted 来判断是否是缓存中的页面触发的 pageshow 事件</p><p><code>注意这个事件给window添加。</code></p><pre><code class="javascript">(function flexible(window, document) &#123;  // 获取的html 的根元素  var docEl = document.documentElement;  // dpr 物理像素比  var dpr = window.devicePixelRatio || 1;  // adjust body font size  设置我们body 的字体大小  function setBodyFontSize() &#123;    // 如果页面中有body 这个元素 就设置body的字体大小    if (document.body) &#123;      document.body.style.fontSize = 12 * dpr + &quot;px&quot;;    &#125; else &#123;      // 如果页面中没有body 这个元素，则等着 我们页面主要的DOM元素加载完毕再去设置body      // 的字体大小      document.addEventListener(&quot;DOMContentLoaded&quot;, setBodyFontSize);    &#125;  &#125;  setBodyFontSize();  // set 1rem = viewWidth / 10    设置我们html 元素的文字大小  function setRemUnit() &#123;    var rem = docEl.clientWidth / 10;    docEl.style.fontSize = rem + &quot;px&quot;;  &#125;  setRemUnit();  // reset rem unit on page resize  当我们页面尺寸大小发生变化的时候，要重新设置下rem 的大小  window.addEventListener(&quot;resize&quot;, setRemUnit);  // pageshow 是我们重新加载页面触发的事件  window.addEventListener(&quot;pageshow&quot;, function (e) &#123;    // e.persisted 返回的是true 就是说如果这个页面是从缓存取过来的页面，也需要从新计算一下rem 的大小    if (e.persisted) &#123;      setRemUnit();    &#125;  &#125;);  // detect 0.5px supports  有些移动端的浏览器不支持0.5像素的写法  if (dpr &gt;= 2) &#123;    var fakeBody = document.createElement(&quot;body&quot;);    var testElement = document.createElement(&quot;div&quot;);    testElement.style.border = &quot;.5px solid transparent&quot;;    fakeBody.appendChild(testElement);    docEl.appendChild(fakeBody);    if (testElement.offsetHeight === 1) &#123;      docEl.classList.add(&quot;hairlines&quot;);    &#125;    docEl.removeChild(fakeBody);  &#125;&#125;)(window, document);</code></pre><h2 id="元素滚动-scroll-系列"><a href="#元素滚动-scroll-系列" class="headerlink" title="元素滚动 scroll 系列"></a>元素滚动 scroll 系列</h2><h3 id="scroll-概述"><a href="#scroll-概述" class="headerlink" title="scroll 概述"></a>scroll 概述</h3><p>scroll 翻译过来就是滚动的，我们使用 scroll 系列的相关属性可以动态的得到该元素的大小、滚动距离等。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616070606903-ad20b10d-b146-4d60-bcc8-b202127dbac2.png#align=left&display=inline&height=131&margin=%5Bobject%20Object%5D&name=image.png&originHeight=261&originWidth=1056&size=145855&status=done&style=stroke&width=528" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616070615035-e5456585-8b3a-4c5a-8e1d-e4affd0e7fd2.png#align=left&display=inline&height=223&margin=%5Bobject%20Object%5D&name=image.png&originHeight=445&originWidth=421&size=102675&status=done&style=stroke&width=210.5" alt="image.png"></p><h3 id="页面被卷去的头部"><a href="#页面被卷去的头部" class="headerlink" title="页面被卷去的头部"></a>页面被卷去的头部</h3><p>如果浏览器的高（或宽）度不足以显示整个页面时，会自动出现滚动条。当滚动条向下滚动时，页面上面被隐藏掉的高度，我们就称为页面被卷去的头部。滚动条在滚动时会触发 onscroll 事件。</p><h3 id="页面被卷去的头部兼容性解决方案"><a href="#页面被卷去的头部兼容性解决方案" class="headerlink" title="页面被卷去的头部兼容性解决方案"></a>页面被卷去的头部兼容性解决方案</h3><p>需要注意的是，页面被卷去的头部，有兼容性问题，因此被卷去的头部通常有如下几种写法：</p><ol><li>声明了 DTD，使用 document.documentElement.scrollTop</li><li>未声明 DTD，使用   document.body.scrollTop</li><li>新方法 window.pageYOffset 和 window.pageXOffset，IE9 开始支持</li><li>微信里面浏览也会有相关兼容性的问题，所以需要兼容行解决</li></ol><pre><code class="javascript">function getScroll() &#123;    return &#123;      left: window.pageXOffset || document.documentElement.scrollLeft || document.body.scrollLeft||0,      top: window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0    &#125;; &#125;使用的时候  getScroll().left</code></pre><h2 id="三大系列总结"><a href="#三大系列总结" class="headerlink" title="三大系列总结"></a>三大系列总结</h2><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616070740695-1045516b-2b85-4697-874b-32fe2b1cbe5b.png#align=left&display=inline&height=113&margin=%5Bobject%20Object%5D&name=image.png&originHeight=226&originWidth=1105&size=140561&status=done&style=stroke&width=552.5" alt="image.png"><br>他们主要用法：</p><ol><li>offset 系列 经常用于获得元素位置     offsetLeft  offsetTop</li><li>client 经常用于获取元素大小   clientWidth clientHeight</li><li>scroll 经常用于获取滚动距离  scrollTop  scrollLeft</li><li>注意页面滚动的距离通过 window.pageXOffset   获得</li></ol><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="-1"><a href="#-1" class="headerlink" title=""></a></h2>]]></content>
      
      
      <categories>
          
          <category> 👨‍💻Web开发 </category>
          
          <category> JavaScript+DOM+BOM+TS </category>
          
          <category> BOM </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>window五大对象</title>
      <link href="/blog/window_five_obj_webapis/"/>
      <url>/blog/window_five_obj_webapis/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是-BOM"><a href="#什么是-BOM" class="headerlink" title="什么是 BOM"></a>什么是 BOM</h2><p>BOM（Browser Object Model）即浏览器对象模型，它提供了独立于内容而与浏览器窗口进行交互的对象，其核心对象是 window。<br>BOM 由一系列相关的对象构成，并且每个对象都提供了很多方法与属性。<br>BOM 缺乏标准，JavaScript 语法的标准化组织是 ECMA，DOM 的标准化组织是 W3C，BOM 最初是 Netscape 浏览器标准的一部分。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518362800-e37d0116-7afb-4099-9d0e-d06e4a1e5127.png#crop=0&crop=0&crop=1&crop=1&height=207&id=AK9gT&originHeight=207&originWidth=866&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=stroke&title=&width=866"><br>BOM 比 DOM 更大，它包含 DOM。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518362856-04ac0f7c-e251-4985-ba14-9d8839bd2fcf.png#crop=0&crop=0&crop=1&crop=1&height=214&id=AS3Ek&originHeight=214&originWidth=629&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=stroke&title=&width=629"></p><h2 id="window-对象"><a href="#window-对象" class="headerlink" title="window 对象"></a>window 对象</h2><h3 id="window-alert、window-prompt"><a href="#window-alert、window-prompt" class="headerlink" title="window.alert、window.prompt"></a>window.alert、window.prompt</h3><ul><li>是 js 访问浏览器窗口的一个接口</li><li>之前学的这两种输入输出都是 window 的对象方法，window.alert 的 window 可以省略</li></ul><h3 id="window-name"><a href="#window-name" class="headerlink" title="window.name"></a>window.name</h3><p>window.name 的使用</p><ul><li>参考：<a href="https://www.zhangxinxu.com/wordpress/2019/09/window-name/">https://www.zhangxinxu.com/wordpress/2019/09/window-name/</a>（基本没啥用了）</li></ul><h3 id="window-onload-和-DOMContentLoaded"><a href="#window-onload-和-DOMContentLoaded" class="headerlink" title="window.onload 和 DOMContentLoaded"></a>window.onload 和 DOMContentLoaded</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518362978-a9a37865-ed21-4388-9d6b-9c95cf4e2c03.png#crop=0&crop=0&crop=1&crop=1&height=134&id=GEaKk&originHeight=134&originWidth=697&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&title=&width=697"></p><ul><li>窗口 (页面）加载事件</li><li><strong>当文档内容完全加载完成</strong>会触发该事件(包括图像、脚本文件、CSS 文件等), 就调用的处理函数。</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518363060-d1b0c898-d05e-45d2-b969-d625f094716e.png#crop=0&crop=0&crop=1&crop=1&height=175&id=iqFg7&originHeight=175&originWidth=717&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=stroke&title=&width=717"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518363117-b08edff8-a5e7-4d72-af87-30d266da9644.png#crop=0&crop=0&crop=1&crop=1&height=84&id=FuxJM&originHeight=84&originWidth=692&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&title=&width=692"><br>事件触发时，仅当 DOM 加载完成，不包括样式表，图片，flash 等等。<br>IE9 以上才支持<br>适用场景：如果页面的图片很多的话, 从用户访问到 onload 触发可能需要较长的时间, 交互效果就不能实现，必然影响用户的体验，此时用 DOMContentLoaded 事件比较合适。</p><pre><code class="javascript">&lt;script&gt;        window.addEventListener(&#39;load&#39;, function() &#123;            var btn = document.querySelector(&#39;button&#39;);            btn.addEventListener(&#39;click&#39;, function() &#123;                alert(&#39;点击我&#39;);            &#125;)        &#125;)        window.addEventListener(&#39;load&#39;, function() &#123;            alert(22);        &#125;)        document.addEventListener(&#39;DOMContentLoaded&#39;, function() &#123;            alert(33);        &#125;)    &lt;/script&gt;</code></pre><h3 id="window-onresize"><a href="#window-onresize" class="headerlink" title="window.onresize"></a>window.onresize</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518363174-36e0247a-e870-47b7-ad70-a39e8204f778.png#crop=0&crop=0&crop=1&crop=1&height=117&id=Yml18&originHeight=117&originWidth=698&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&title=&width=698"></p><ul><li>window.onresize 是调整窗口大小加载事件, 当触发时就调用的处理函数。</li><li>只要窗口大小发生像素变化，就会触发这个事件。</li><li>利用这个事件完成响应式布局</li><li>window.innerWidth 当前屏幕的宽度</li></ul><pre><code class="javascript">&lt;script&gt;        // 注册页面加载事件        window.addEventListener(&#39;load&#39;, function() &#123;            var div = document.querySelector(&#39;div&#39;);            // 注册调整窗口大小事件            window.addEventListener(&#39;resize&#39;, function() &#123;                // window.innerWidth 获取窗口大小                console.log(&#39;变化了&#39;);                if (window.innerWidth &lt;= 800) &#123;                    div.style.display = &#39;none&#39;;                &#125; else &#123;                    div.style.display = &#39;block&#39;;                &#125;            &#125;)        &#125;)    &lt;/script&gt;    &lt;div&gt;&lt;/div&gt;</code></pre><h3 id="setTimeout-和-clearTimeout"><a href="#setTimeout-和-clearTimeout" class="headerlink" title="setTimeout()和 clearTimeout()"></a>setTimeout()和 clearTimeout()</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518363237-7fb4b99d-18cc-4621-9153-99ee3b219faa.png#crop=0&crop=0&crop=1&crop=1&height=50&id=zmYE6&originHeight=50&originWidth=695&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=stroke&title=&width=695"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518363294-245f3e69-65be-425b-8390-cedcea50e6b9.png#crop=0&crop=0&crop=1&crop=1&height=31&id=YGNul&originHeight=31&originWidth=687&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=stroke&title=&width=687"></p><ul><li>默认的延迟毫秒数默认是 0，单位必须是毫秒</li><li>通常定义了一个这种函数就给其“名”，赋予其一个标识符，因为一个项目里面可能有很多的定时器。<blockquote><p>什么是回调函数呢？</p></blockquote></li></ul><p>普通函数是按照代码顺序直接调用。回调，就是回头调用的意思。上一件事干完，再回头再调用这个函数。例如：定时器中的调用函数，事件处理函数，也是回调函数。element.onclick = function(){}   或者  element.addEventListener(“click”, fn);   里面的 函数也是回调函数。</p><pre><code class="cpp">&lt;script&gt;        // 回调函数是一个匿名函数         setTimeout(function() &#123;             console.log(&#39;时间到了&#39;);         &#125;, 2000);        function callback() &#123;            console.log(&#39;爆炸了&#39;);        &#125;        // 回调函数是一个有名函数        var timer1 = setTimeout(callback, 3000);        var timer2 = setTimeout(callback, 5000);    &lt;/script&gt;</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518363519-c36076ed-0e62-471c-a193-001186cebc77.png#crop=0&crop=0&crop=1&crop=1&height=51&id=k1kyd&originHeight=51&originWidth=703&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&title=&width=703"></p><ul><li>类似在炸弹爆炸前拆除的意思</li></ul><pre><code class="javascript">&lt;button&gt;点击停止定时器&lt;/button&gt;    &lt;script&gt;        var btn = document.querySelector(&#39;button&#39;);        // 开启定时器        var timer = setTimeout(function() &#123;            console.log(&#39;爆炸了&#39;);        &#125;, 5000);        // 给按钮注册单击事件        btn.addEventListener(&#39;click&#39;, function() &#123;            // 停止定时器            clearTimeout(timer);        &#125;)    &lt;/script&gt;</code></pre><h3 id="setInterval-和-clearInterval"><a href="#setInterval-和-clearInterval" class="headerlink" title="setInterval()和 clearInterval()"></a>setInterval()和 clearInterval()</h3><ul><li>会多次进行调用，直到清除</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616033160668-637ca99a-723f-4f14-9576-6de4f4fdd383.png#crop=0&crop=0&crop=1&crop=1&height=50&id=lb5Xh&margin=%5Bobject%20Object%5D&name=image.png&originHeight=99&originWidth=1438&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=41629&status=done&style=none&title=&width=719" alt="image.png"></p><h3 id="Demo：倒计时"><a href="#Demo：倒计时" class="headerlink" title="Demo：倒计时"></a>Demo：倒计时</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616035667401-0c467c6a-2509-4b0c-a1b3-ea2a9b3d4f85.png#crop=0&crop=0&crop=1&crop=1&height=82&id=Vxs7R&margin=%5Bobject%20Object%5D&name=image.png&originHeight=163&originWidth=316&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=3932&status=done&style=stroke&title=&width=158" alt="image.png"></p><pre><code class="javascript">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;    &lt;style&gt;        div &#123;            margin: 200px;        &#125;        span &#123;            display: inline-block;            width: 40px;            height: 40px;            background-color: #333;            font-size: 20px;            color: #fff;            text-align: center;            line-height: 40px;        &#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;div&gt;        &lt;span class=&quot;hour&quot;&gt;1&lt;/span&gt;        &lt;span class=&quot;minute&quot;&gt;2&lt;/span&gt;        &lt;span class=&quot;second&quot;&gt;3&lt;/span&gt;    &lt;/div&gt;    &lt;script&gt;        // 1. 获取元素        var hour = document.querySelector(&#39;.hour&#39;); // 小时的黑色盒子        var minute = document.querySelector(&#39;.minute&#39;); // 分钟的黑色盒子        var second = document.querySelector(&#39;.second&#39;); // 秒数的黑色盒子        var inputTime = +new Date(&#39;2021-3-18 19:00:00&#39;); // 返回的是用户输入时间总的毫秒数        countDown(); // 我们先调用一次这个函数，防止第一次刷新页面有空白        // 2. 开启定时器        setInterval(countDown, 1000);        function countDown() &#123;            var nowTime = +new Date(); // 返回的是当前时间总的毫秒数            var times = (inputTime - nowTime) / 1000; // times是剩余时间总的秒数            var h = parseInt(times / 60 / 60 % 24); //时            h = h &lt; 10 ? &#39;0&#39; + h : h;            hour.innerHTML = h; // 把剩余的小时给 小时黑色盒子            var m = parseInt(times / 60 % 60); // 分            m = m &lt; 10 ? &#39;0&#39; + m : m;            minute.innerHTML = m;            var s = parseInt(times % 60); // 当前的秒            s = s &lt; 10 ? &#39;0&#39; + s : s;            second.innerHTML = s;        &#125;    &lt;/script&gt;&lt;/body&gt;&lt;/html</code></pre><h3 id="Demo：短信倒计时"><a href="#Demo：短信倒计时" class="headerlink" title="Demo：短信倒计时"></a>Demo：短信倒计时</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616036201989-deced5f6-9ec3-4392-8e1d-cf10d7c1c55b.png#crop=0&crop=0&crop=1&crop=1&height=42&id=KNBAm&margin=%5Bobject%20Object%5D&name=image.png&originHeight=63&originWidth=959&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=11368&status=done&style=none&title=&width=641" alt="image.png"></p><blockquote><p>案例：发送短信倒计时<br>同时这个例子还用到了闭包的相关知识</p></blockquote><p>点击按钮后，该按钮 60 秒之内不能再次点击，防止重复发送短信。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518363854-8efb51de-f962-4ce9-b686-4166d4ef3bfe.png#crop=0&crop=0&crop=1&crop=1&height=40&id=KGTIA&originHeight=40&originWidth=364&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=stroke&title=&width=364"></p><pre><code class="javascript">手机号码： &lt;input type=&quot;number&quot;&gt; &lt;button&gt;发送&lt;/button&gt;    &lt;script&gt;        var btn = document.querySelector(&#39;button&#39;);        // 全局变量，定义剩下的秒数        var time = 3;        // 注册单击事件        btn.addEventListener(&#39;click&#39;, function() &#123;            // 禁用按钮            btn.disabled = true;            // 开启定时器            var timer = setInterval(function() &#123;                // 判断剩余秒数                if (time == 0) &#123;                    // 清除定时器和复原按钮                    clearInterval(timer);                    btn.disabled = false;                    btn.innerHTML = &#39;发送&#39;;                &#125; else &#123;                    btn.innerHTML = &#39;还剩下&#39; + time + &#39;秒&#39;;                    time--;                &#125;            &#125;, 1000);        &#125;);    &lt;/script&gt;</code></pre><h2 id="location-对象"><a href="#location-对象" class="headerlink" title="location 对象"></a>location 对象</h2><p>参考：</p><ul><li><a href="https://www.cnblogs.com/cang12138/p/7677239.html">https://www.cnblogs.com/cang12138/p/7677239.html</a></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518363970-e7ae6f17-8fa0-4cda-bd5c-a486dbad0410.png#crop=0&crop=0&crop=1&crop=1&height=56&id=MQwpb&originHeight=56&originWidth=722&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&title=&width=722"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518364029-47b8981f-8ef1-4978-8760-2be8bc0c5e96.png#crop=0&crop=0&crop=1&crop=1&height=177&id=UFOqO&originHeight=177&originWidth=723&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&title=&width=723"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518364086-8b3e0045-e245-4c0a-b484-4e038b829a6b.png#crop=0&crop=0&crop=1&crop=1&height=240&id=MJ42d&originHeight=240&originWidth=684&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&title=&width=684"></p><h3 id="location-对象常用属性"><a href="#location-对象常用属性" class="headerlink" title="location 对象常用属性"></a>location 对象常用属性</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518364152-c5c0aa45-eb47-49d3-81ce-2318a6bc8497.png#crop=0&crop=0&crop=1&crop=1&height=240&id=UD8ZA&originHeight=240&originWidth=705&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&title=&width=705"></p><h3 id="location-对象常见方法"><a href="#location-对象常见方法" class="headerlink" title="location 对象常见方法"></a>location 对象常见方法</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518364490-f3c87eef-a34f-4378-9b69-03ea18f2fb26.png#crop=0&crop=0&crop=1&crop=1&height=153&id=hTDRo&originHeight=153&originWidth=728&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&title=&width=728"></p><pre><code class="javascript">&lt;button&gt;点击&lt;/button&gt;    &lt;script&gt;        var btn = document.querySelector(&#39;button&#39;);        btn.addEventListener(&#39;click&#39;, function() &#123;            // 记录浏览历史，所以可以实现后退功能            // location.assign(&#39;http://www.itcast.cn&#39;);            // 不记录浏览历史，所以不可以实现后退功能            // location.replace(&#39;http://www.itcast.cn&#39;);            location.reload(true);        &#125;)    &lt;/script&gt;</code></pre><h3 id="Demo：5-秒钟自动跳转页面"><a href="#Demo：5-秒钟自动跳转页面" class="headerlink" title="Demo：5 秒钟自动跳转页面"></a>Demo：5 秒钟自动跳转页面</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616038766425-7b736d4a-8329-4912-879c-7eb5924745f5.png#crop=0&crop=0&crop=1&crop=1&height=260&id=ZGNKi&margin=%5Bobject%20Object%5D&name=image.png&originHeight=519&originWidth=798&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=756606&status=done&style=stroke&title=&width=399" alt="image.png"></p><pre><code class="javascript">var img = document.getElementsByTagName(&quot;img&quot;);img[0].addEventListener(&quot;click&quot;, function () &#123;  console.log(&quot;运行到了这里1&quot;);  setTimeout(function () &#123;    location.href = &quot;https://www.wztlink1013.com&quot;;    console.log(&quot;运行到了这里&quot;);  &#125;, 5000);&#125;);</code></pre><h3 id="Demo：获取-URL-参数"><a href="#Demo：获取-URL-参数" class="headerlink" title="Demo：获取 URL 参数"></a>Demo：获取 URL 参数</h3><blockquote><p>login.html</p></blockquote><pre><code class="html">&lt;body&gt;  &lt;form action=&quot;index.html&quot;&gt;    用户名： &lt;input type=&quot;text&quot; name=&quot;uname&quot; /&gt;    &lt;input type=&quot;submit&quot; value=&quot;登录&quot; /&gt;  &lt;/form&gt;&lt;/body&gt;</code></pre><blockquote><p>index.html</p></blockquote><p>收到 login 页面传来的参数后<img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616039288488-d1884566-894d-4a15-a677-9227934a5eb9.png#crop=0&crop=0&crop=1&crop=1&height=28&id=ftUqi&margin=%5Bobject%20Object%5D&name=image.png&originHeight=55&originWidth=341&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=3107&status=done&style=stroke&title=&width=170.5" alt="image.png"></p><pre><code class="html">&lt;div&gt;&lt;/div&gt;&lt;script&gt;  console.log(location.search); // ?uname=wztlink1013  // 1.先去掉？  substr(&#39;起始的位置&#39;，截取几个字符);  var params = location.search.substr(1); // uname=wztlink1013  console.log(params);  // 2. 利用=把字符串分割为数组 split(&#39;=&#39;);  var arr = params.split(&quot;=&quot;);  console.log(arr); // [&quot;uname&quot;, &quot;wztlink1013&quot;]  var div = document.querySelector(&quot;div&quot;);  // 3.把数据写入div中  div.innerHTML = arr[1] + &quot;欢迎您&quot;;&lt;/script&gt;</code></pre><h2 id="navigator-对象"><a href="#navigator-对象" class="headerlink" title="navigator 对象"></a>navigator 对象</h2><p>navigator 对象包含有关浏览器的信息，它有很多属性，我们最常用的是 userAgent，该属性可以返回由客户机发送服务器的 user-agent 头部的值。<br>下面前端代码可以判断用户那个终端打开页面，实现跳转，比如：</p><pre><code class="javascript">if (  navigator.userAgent.match(    /(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i  )) &#123;  window.location.href = &quot;https://www.wztlink1013.com/m/index.html&quot;; //手机页面&#125; else &#123;  window.location.href = &quot;https://www.wztlink1013.com/p/index.html&quot;; //电脑页面&#125;</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616072483887-50d05057-73f8-49b7-8761-8f68defe6194.png#crop=0&crop=0&crop=1&crop=1&height=441&id=lZii4&margin=%5Bobject%20Object%5D&name=image.png&originHeight=881&originWidth=1920&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=1468471&status=done&style=stroke&title=&width=960" alt="image.png"></p><h2 id="history-对象"><a href="#history-对象" class="headerlink" title="history 对象"></a>history 对象</h2><pre><code>window对象给我们提供了一个 history对象，与浏览器历史记录进行交互。该对象包含用户（在浏览器窗口中）访问过的URL。</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518364555-790a838f-2446-45bd-886e-686c75286b2c.png#crop=0&crop=0&crop=1&crop=1&height=148&id=moiW0&originHeight=148&originWidth=731&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&title=&width=731"></p><h2 id="screen-对象"><a href="#screen-对象" class="headerlink" title="screen 对象"></a>screen 对象</h2><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td><a href="https://www.runoob.com/jsref/prop-screen-availheight.html">availHeight</a></td><td>返回屏幕的高度（不包括 Windows 任务栏）</td></tr><tr><td><a href="https://www.runoob.com/jsref/prop-screen-availwidth.html">availWidth</a></td><td>返回屏幕的宽度（不包括 Windows 任务栏）</td></tr><tr><td><a href="https://www.runoob.com/jsref/prop-screen-colordepth.html">colorDepth</a></td><td>返回目标设备或缓冲器上的调色板的比特深度</td></tr><tr><td><a href="https://www.runoob.com/jsref/prop-screen-height.html">height</a></td><td>返回屏幕的总高度</td></tr><tr><td><a href="https://www.runoob.com/jsref/prop-screen-pixeldepth.html">pixelDepth</a></td><td>返回屏幕的颜色分辨率（每象素的位数）</td></tr><tr><td><a href="https://www.runoob.com/jsref/prop-screen-width.html">width</a></td><td>返回屏幕的总宽度</td></tr></tbody></table><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616073065915-eee3a4aa-52a8-4200-9d15-9e66f5c4fba5.png#crop=0&crop=0&crop=1&crop=1&height=881&id=ugF7E&margin=%5Bobject%20Object%5D&name=Snipaste_2021-03-18_21-09-08.png&originHeight=881&originWidth=1920&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=697028&status=done&style=stroke&title=&width=1920" alt="Snipaste_2021-03-18_21-09-08.png"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616073033094-e0640f15-e1a2-4f9d-9937-aad687e2bfbe.png#crop=0&crop=0&crop=1&crop=1&height=540&id=PyKN9&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1080&originWidth=620&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=196090&status=done&style=stroke&title=&width=310" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> 👨‍💻Web开发 </category>
          
          <category> JavaScript+DOM+BOM+TS </category>
          
          <category> BOM </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>DOM节点操作</title>
      <link href="/blog/2_day02_webapis/"/>
      <url>/blog/2_day02_webapis/</url>
      
        <content type="html"><![CDATA[<h3 id="节点概述"><a href="#节点概述" class="headerlink" title="节点概述"></a>节点概述</h3><p>网页中的所有内容都是节点（标签、属性、文本、注释等），在 DOM 中，节点使用 node 来表示。HTML DOM 树中的所有节点均可通过 JavaScript 进行访问，所有 HTML 元素（节点）均可被修改，也可以创建或删除。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518358489-a0521202-b32d-46a9-9b8d-f0cfe9afc455.png#align=left&display=inline&height=236&margin=%5Bobject%20Object%5D&originHeight=236&originWidth=432&status=done&style=stroke&width=432"><br>一般地，节点至少拥有 nodeType（节点类型）、nodeName（节点名称）和 nodeValue（节点值）这三个基本属性。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518358548-9283575f-7aef-450d-bc6e-b9d3a4384cc2.png#align=left&display=inline&height=148&margin=%5Bobject%20Object%5D&originHeight=148&originWidth=666&status=done&style=stroke&width=666"></p><blockquote><p>节点层级：利用 DOM 树可以把节点划分为不同的层级关系，常见的是<strong>父子兄层级关系</strong>。</p></blockquote><h2 id="父节点"><a href="#父节点" class="headerlink" title="父节点"></a>父节点</h2><h3 id="node-parentNode"><a href="#node-parentNode" class="headerlink" title="node.parentNode"></a>node.parentNode</h3><ul><li>返回某节点的父节点，最近的一个父节点</li><li>如果没有父节点，则返回 null</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616056309357-b2a256d0-2a4d-4983-80f9-1eed069c3890.png#align=left&display=inline&height=354&margin=%5Bobject%20Object%5D&name=image.png&originHeight=708&originWidth=1920&size=1164429&status=done&style=stroke&width=960" alt="image.png"></p><h2 id="子节点"><a href="#子节点" class="headerlink" title="子节点"></a>子节点</h2><h3 id="parentNode-childNodes"><a href="#parentNode-childNodes" class="headerlink" title="parentNode.childNodes"></a>parentNode.childNodes</h3><ul><li>返回指定节点的子节点的集合，会即时更新</li><li>会返回所有的节点（包含元素节点、文本节点等）</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616056553404-55b8fe19-9bea-413d-9cb1-6554380831af.png#align=left&display=inline&height=281&margin=%5Bobject%20Object%5D&name=image.png&originHeight=561&originWidth=1920&size=936204&status=done&style=stroke&width=960" alt="image.png"></p><h3 id="parentNode-children"><a href="#parentNode-children" class="headerlink" title="parentNode.children"></a>parentNode.children</h3><ul><li>只读属性</li><li>只返回元素节点</li><li>非标准，但是各个浏览器都支持</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616056710609-4bb68282-b6ae-4240-b9be-a9faea530ab2.png#align=left&display=inline&height=435&margin=%5Bobject%20Object%5D&name=image.png&originHeight=870&originWidth=1920&size=1444600&status=done&style=stroke&width=960" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616057002507-4244db60-7bf0-4e95-b68b-acb4d4d62d8d.png#align=left&display=inline&height=318&margin=%5Bobject%20Object%5D&name=image.png&originHeight=635&originWidth=1920&size=1036129&status=done&style=stroke&width=960" alt="image.png"></p><h3 id="parent-firstChild"><a href="#parent-firstChild" class="headerlink" title="parent.firstChild"></a>parent.firstChild</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616057242192-2bb01e66-de7d-4220-afc2-499adbdcc3de.png#align=left&display=inline&height=225&margin=%5Bobject%20Object%5D&name=image.png&originHeight=449&originWidth=1920&size=719099&status=done&style=stroke&width=960" alt="image.png"></p><ul><li>返回第一个子节点，找不到返回 null，包含所有节点</li></ul><h3 id="parent-lastChild"><a href="#parent-lastChild" class="headerlink" title="parent.lastChild"></a>parent.lastChild</h3><ul><li>返回最后一个子节点，找不到返回 null，包含所有节点</li></ul><h3 id="parent-firstElementChild"><a href="#parent-firstElementChild" class="headerlink" title="parent.firstElementChild"></a>parent.firstElementChild</h3><ul><li>返回第一个子元素节点，找不到返回 null</li><li>IE9 以上支持</li></ul><h3 id="parent-lastElementChild"><a href="#parent-lastElementChild" class="headerlink" title="parent.lastElementChild"></a>parent.lastElementChild</h3><ul><li>返回最后一个子元素节点，找不到返回 null</li><li>IE9 以上支持</li></ul><h3 id="首末节点兼容方案"><a href="#首末节点兼容方案" class="headerlink" title="首末节点兼容方案"></a>首末节点兼容方案</h3><blockquote><p>实际开发中，firstChild 和 lastChild 包含其他节点，操作不方便，而 firstElementChild 和 lastElementChild 又有兼容性问题，那么我们如何获取第一个子元素节点或最后一个子元素节点呢？</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616057537841-77a6605b-5d29-4cf2-b750-0cd916841cdd.png#align=left&display=inline&height=303&margin=%5Bobject%20Object%5D&name=image.png&originHeight=606&originWidth=1920&size=992223&status=done&style=stroke&width=960" alt="image.png"></p><h2 id="兄弟节点"><a href="#兄弟节点" class="headerlink" title="兄弟节点"></a>兄弟节点</h2><p><strong>下一个兄弟节点</strong><br><img src="../../../../../%E5%A4%87%E8%AF%BE%E8%B5%84%E6%96%99/20190220-%E8%AF%BE%E4%BB%B6%E5%88%B6%E4%BD%9C/Web%20APIs/Web%20APIs-day02/4-%E7%AC%94%E8%AE%B0/images/1550973538696.png#"><br><strong>上一个兄弟节点</strong><br><img src="../../../../../%E5%A4%87%E8%AF%BE%E8%B5%84%E6%96%99/20190220-%E8%AF%BE%E4%BB%B6%E5%88%B6%E4%BD%9C/Web%20APIs/Web%20APIs-day02/4-%E7%AC%94%E8%AE%B0/images/1550973558511.png#"></p><pre><code class="js">&lt;div&gt;我是div&lt;/div&gt;    &lt;span&gt;我是span&lt;/span&gt;    &lt;script&gt;        var div = document.querySelector(&#39;div&#39;);        // 1.nextSibling 下一个兄弟节点 包含元素节点或者 文本节点等等        console.log(div.nextSibling);        console.log(div.previousSibling);        // 2. nextElementSibling 得到下一个兄弟元素节点        console.log(div.nextElementSibling);        console.log(div.previousElementSibling);    &lt;/script&gt;</code></pre><p><strong>下一个兄弟元素节点（有兼容性问题）</strong><br><img src="../../../../../%E5%A4%87%E8%AF%BE%E8%B5%84%E6%96%99/20190220-%E8%AF%BE%E4%BB%B6%E5%88%B6%E4%BD%9C/Web%20APIs/Web%20APIs-day02/4-%E7%AC%94%E8%AE%B0/images/1550973610223.png#"><br><strong>上一个兄弟元素节点（有兼容性问题）</strong><br><img src="../../../../../%E5%A4%87%E8%AF%BE%E8%B5%84%E6%96%99/20190220-%E8%AF%BE%E4%BB%B6%E5%88%B6%E4%BD%9C/Web%20APIs/Web%20APIs-day02/4-%E7%AC%94%E8%AE%B0/images/1550973630150.png#"><br><img src="../../../../../%E5%A4%87%E8%AF%BE%E8%B5%84%E6%96%99/20190220-%E8%AF%BE%E4%BB%B6%E5%88%B6%E4%BD%9C/Web%20APIs/Web%20APIs-day02/4-%E7%AC%94%E8%AE%B0/images/1550973722805.png#"><br><img src="../../../../../%E5%A4%87%E8%AF%BE%E8%B5%84%E6%96%99/20190220-%E8%AF%BE%E4%BB%B6%E5%88%B6%E4%BD%9C/Web%20APIs/Web%20APIs-day02/4-%E7%AC%94%E8%AE%B0/images/1550973799759.png#"></p><pre><code class="js">function getNextElementSibling(element) &#123;  var el = element;  while ((el = el.nextSibling)) &#123;    if (el.nodeType === 1) &#123;      return el;    &#125;  &#125;  return null;&#125;</code></pre><h2 id="创建结点"><a href="#创建结点" class="headerlink" title="创建结点"></a>创建结点</h2><h3 id="document-createElement"><a href="#document-createElement" class="headerlink" title="document.createElement()"></a>document.createElement()</h3><ul><li>document.createElement(‘tagName’)</li><li>动态创建元素节点</li></ul><h3 id="node-cloneNode"><a href="#node-cloneNode" class="headerlink" title="node.cloneNode()"></a>node.cloneNode()</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518359854-90c1339a-ca41-47e5-86b1-189336c186d3.png#align=left&display=inline&height=248&margin=%5Bobject%20Object%5D&originHeight=248&originWidth=726&status=done&style=stroke&width=726"></p><pre><code class="html">&lt;ul&gt;  &lt;li&gt;1111&lt;/li&gt;  &lt;li&gt;2&lt;/li&gt;  &lt;li&gt;3&lt;/li&gt;&lt;/ul&gt;&lt;script&gt;  var ul = document.querySelector(&quot;ul&quot;);  // 1. node.cloneNode(); 括号为空或者里面是false 浅拷贝 只复制标签不复制里面的内容  // 2. node.cloneNode(true); 括号为true 深拷贝 复制标签复制里面的内容  var lili = ul.children[0].cloneNode(true);  ul.appendChild(lili);&lt;/script&gt;</code></pre><h3 id="Demo：动态生成表格"><a href="#Demo：动态生成表格" class="headerlink" title="Demo：动态生成表格"></a>Demo：动态生成表格</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518359913-8e1af74d-0a30-4370-83ea-4974ad83d2b8.png#align=left&display=inline&height=268&margin=%5Bobject%20Object%5D&originHeight=268&originWidth=718&status=done&style=stroke&width=718"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518359980-7b2a19b1-47dd-41cb-8f9b-93d64873fb6f.png#align=left&display=inline&height=288&margin=%5Bobject%20Object%5D&originHeight=288&originWidth=751&status=done&style=stroke&width=751"></p><pre><code class="html">&lt;script&gt;  // 1.先去准备好学生的数据  var datas = [    &#123;      name: &quot;魏璎珞&quot;,      subject: &quot;JavaScript&quot;,      score: 100,    &#125;,    &#123;      name: &quot;弘历&quot;,      subject: &quot;JavaScript&quot;,      score: 98,    &#125;,    &#123;      name: &quot;傅恒&quot;,      subject: &quot;JavaScript&quot;,      score: 99,    &#125;,    &#123;      name: &quot;明玉&quot;,      subject: &quot;JavaScript&quot;,      score: 88,    &#125;,    &#123;      name: &quot;大猪蹄子&quot;,      subject: &quot;JavaScript&quot;,      score: 0,    &#125;,  ];  // 2. 往tbody 里面创建行： 有几个人（通过数组的长度）我们就创建几行  var tbody = document.querySelector(&quot;tbody&quot;);  // 遍历数组  for (var i = 0; i &lt; datas.length; i++) &#123;    // 1. 创建 tr行    var tr = document.createElement(&quot;tr&quot;);    tbody.appendChild(tr);    // 2. 行里面创建单元格td 单元格的数量取决于每个对象里面的属性个数    // 使用for in遍历学生对象    for (var k in datas[i]) &#123;      // 创建单元格      var td = document.createElement(&quot;td&quot;);      // 把对象里面的属性值 datas[i][k] 给 td      td.innerHTML = datas[i][k];      tr.appendChild(td);    &#125;    // 3. 创建有删除2个字的单元格    var td = document.createElement(&quot;td&quot;);    td.innerHTML = &#39;&lt;a href=&quot;javascript:;&quot;&gt;删除 &lt;/a&gt;&#39;;    tr.appendChild(td);  &#125;  // 4. 删除操作 开始  var as = document.querySelectorAll(&quot;a&quot;);  for (var i = 0; i &lt; as.length; i++) &#123;    as[i].onclick = function () &#123;      // 点击a 删除 当前a 所在的行(链接的爸爸的爸爸)  node.removeChild(child)      tbody.removeChild(this.parentNode.parentNode);    &#125;;  &#125;&lt;/script&gt;</code></pre><h3 id="创建元素的三种方式对比"><a href="#创建元素的三种方式对比" class="headerlink" title="创建元素的三种方式对比"></a>创建元素的三种方式对比</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518360041-a233aa10-7238-46f4-bb78-2438898c8950.png#align=left&display=inline&height=346&margin=%5Bobject%20Object%5D&originHeight=346&originWidth=759&status=done&style=stroke&width=759"></p><pre><code class="html">&lt;script&gt;  // 三种创建元素方式区别  // 1. document.write() 创建元素  如果页面文档流加载完毕，再调用这句话会导致页面重绘  var btn = document.querySelector(&quot;button&quot;);  btn.onclick = function () &#123;    document.write(&quot;&lt;div&gt;123&lt;/div&gt;&quot;);  &#125;;  // 2. innerHTML 创建元素  var inner = document.querySelector(&quot;.inner&quot;);  for (var i = 0; i &lt;= 100; i++) &#123;    inner.innerHTML += &#39;&lt;a href=&quot;#&quot;&gt;百度&lt;/a&gt;&#39;;  &#125;  var arr = [];  for (var i = 0; i &lt;= 100; i++) &#123;    arr.push(&#39;&lt;a href=&quot;#&quot;&gt;百度&lt;/a&gt;&#39;);  &#125;  inner.innerHTML = arr.join(&quot;&quot;);  // 3. document.createElement() 创建元素  var create = document.querySelector(&quot;.create&quot;);  for (var i = 0; i &lt;= 100; i++) &#123;    var a = document.createElement(&quot;a&quot;);    create.appendChild(a);  &#125;&lt;/script&gt;</code></pre><blockquote><p>innerTHML 和 createElement 效率对比</p></blockquote><p><strong>innerHTML 字符串拼接方式（效率低）</strong></p><pre><code class="html">&lt;script&gt;  function fn() &#123;    var d1 = +new Date();    var str = &quot;&quot;;    for (var i = 0; i &lt; 1000; i++) &#123;      document.body.innerHTML +=        &#39;&lt;div style=&quot;width:100px; height:2px; border:1px solid blue;&quot;&gt;&lt;/div&gt;&#39;;    &#125;    var d2 = +new Date();    console.log(d2 - d1);  &#125;  fn();&lt;/script&gt;</code></pre><p><strong>createElement 方式（效率一般）</strong></p><pre><code class="html">&lt;script&gt;  function fn() &#123;    var d1 = +new Date();    for (var i = 0; i &lt; 1000; i++) &#123;      var div = document.createElement(&quot;div&quot;);      div.style.width = &quot;100px&quot;;      div.style.height = &quot;2px&quot;;      div.style.border = &quot;1px solid red&quot;;      document.body.appendChild(div);    &#125;    var d2 = +new Date();    console.log(d2 - d1);  &#125;  fn();&lt;/script&gt;</code></pre><p><strong>innerHTML 数组方式（效率高）</strong></p><pre><code class="html">&lt;script&gt;  function fn() &#123;    var d1 = +new Date();    var array = [];    for (var i = 0; i &lt; 1000; i++) &#123;      array.push(        &#39;&lt;div style=&quot;width:100px; height:2px; border:1px solid blue;&quot;&gt;&lt;/div&gt;&#39;      );    &#125;    document.body.innerHTML = array.join(&quot;&quot;);    var d2 = +new Date();    console.log(d2 - d1);  &#125;  fn();&lt;/script&gt;</code></pre><h2 id="插入结点"><a href="#插入结点" class="headerlink" title="插入结点"></a>插入结点</h2><h3 id="node-appendChild"><a href="#node-appendChild" class="headerlink" title="node.appendChild()"></a>node.appendChild()</h3><ul><li>node.appendChild(child)</li><li>添加到父节点的子节点列表末尾</li></ul><h3 id="node-insertBefore"><a href="#node-insertBefore" class="headerlink" title="node.insertBefore()"></a>node.insertBefore()</h3><ul><li>node.insertBefore(child,指定元素)</li><li>将一个节点添加到父节点的指定子节点前面</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616058396292-0ab90d78-37b9-4851-96bf-2e2bf5fb13cd.png#align=left&display=inline&height=422&margin=%5Bobject%20Object%5D&name=image.png&originHeight=844&originWidth=1920&size=1419443&status=done&style=stroke&width=960" alt="image.png"></p><h3 id="Demo：简单版发布留言"><a href="#Demo：简单版发布留言" class="headerlink" title="Demo：简单版发布留言"></a>Demo：简单版发布留言</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518359458-b8cd80e8-0c64-4c8f-8d76-2cfcdbce3f48.png#align=left&display=inline&height=152&margin=%5Bobject%20Object%5D&originHeight=152&originWidth=337&status=done&style=stroke&width=337"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518359516-1b352ba3-c851-49d8-aeff-5af5668b1d71.png#align=left&display=inline&height=161&margin=%5Bobject%20Object%5D&originHeight=161&originWidth=727&status=done&style=stroke&width=727"></p><pre><code class="html">&lt;body&gt;  &lt;textarea name=&quot;&quot; id=&quot;&quot;&gt;&lt;/textarea&gt;  &lt;button&gt;发布&lt;/button&gt;  &lt;ul&gt;&lt;/ul&gt;  &lt;script&gt;    // 1. 获取元素    var btn = document.querySelector(&quot;button&quot;);    var text = document.querySelector(&quot;textarea&quot;);    var ul = document.querySelector(&quot;ul&quot;);    // 2. 注册事件    btn.onclick = function () &#123;      if (text.value == &quot;&quot;) &#123;        alert(&quot;您没有输入内容&quot;);        return false;      &#125; else &#123;        // console.log(text.value);        // (1) 创建元素        var li = document.createElement(&quot;li&quot;);        // 先有li 才能赋值        li.innerHTML = text.value;        // (2) 添加元素        // ul.appendChild(li);        ul.insertBefore(li, ul.children[0]);      &#125;    &#125;;  &lt;/script&gt;&lt;/body&gt;</code></pre><h2 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h2><h3 id="node-removeChild"><a href="#node-removeChild" class="headerlink" title="node.removeChild()"></a>node.removeChild()</h3><ul><li>node.removeChild() 方法从 node 节点中删除一个子节点，返回删除的节点。</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616060281051-79e7f85a-572a-4e31-b204-b5dbdaff1e60.png#align=left&display=inline&height=435&margin=%5Bobject%20Object%5D&name=image.png&originHeight=870&originWidth=1920&size=1459532&status=done&style=stroke&width=960" alt="image.png"></p><h3 id="Demo：删除留言"><a href="#Demo：删除留言" class="headerlink" title="Demo：删除留言"></a>Demo：删除留言</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518359732-302df5c2-5149-4e89-89dd-e99586f91651.png#align=left&display=inline&height=210&margin=%5Bobject%20Object%5D&originHeight=210&originWidth=361&status=done&style=stroke&width=361"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518359795-1a54681c-6264-48c2-a670-28b1f41c4388.png#align=left&display=inline&height=155&margin=%5Bobject%20Object%5D&originHeight=155&originWidth=718&status=done&style=none&width=718"></p><pre><code class="html">&lt;textarea name=&quot;&quot; id=&quot;&quot;&gt;&lt;/textarea&gt;&lt;button&gt;发布&lt;/button&gt;&lt;ul&gt;&lt;/ul&gt;&lt;script&gt;  // 1. 获取元素  var btn = document.querySelector(&quot;button&quot;);  var text = document.querySelector(&quot;textarea&quot;);  var ul = document.querySelector(&quot;ul&quot;);  // 2. 注册事件  btn.onclick = function () &#123;    if (text.value == &quot;&quot;) &#123;      alert(&quot;您没有输入内容&quot;);      return false;    &#125; else &#123;      // console.log(text.value);      // (1) 创建元素      var li = document.createElement(&quot;li&quot;);      // 先有li 才能赋值      li.innerHTML = text.value + &quot;&lt;a href=&#39;javascript:;&#39;&gt;删除&lt;/a&gt;&quot;;      // (2) 添加元素      // ul.appendChild(li);      ul.insertBefore(li, ul.children[0]);      // (3) 删除元素 删除的是当前链接的li  它的父亲      var as = document.querySelectorAll(&quot;a&quot;);      for (var i = 0; i &lt; as.length; i++) &#123;        as[i].onclick = function () &#123;          // 删除的是 li 当前a所在的li  this.parentNode;          ul.removeChild(this.parentNode);        &#125;;      &#125;    &#125;  &#125;;&lt;/script&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 👨‍💻Web开发 </category>
          
          <category> JavaScript+DOM+BOM+TS </category>
          
          <category> DOM </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>DOM元素操作</title>
      <link href="/blog/1_day01_webapis/"/>
      <url>/blog/1_day01_webapis/</url>
      
        <content type="html"><![CDATA[<h2 id="API-和-Web-API-和-SDK"><a href="#API-和-Web-API-和-SDK" class="headerlink" title="API 和 Web API 和 SDK"></a>API 和 Web API 和 SDK</h2><blockquote><p>文档：<a href="https://developer.mozilla.org/zh-CN/docs/Web/API">https://developer.mozilla.org/zh-CN/docs/Web/API</a></p></blockquote><div style="background: #FFFBE6;padding:10px;border: 1px solid #C3C3C3;border-radius:5px;margin-bottom:5px;">API（Application Programming Interface，应用程序编程接口）是一些预先定义的函数，目的是提供应用程序与开发人员基于某软件或硬件得以访问一组例程的能力，而又无需访问源码，无需理解其内部工作机制细节，只需直接调用使用即可。</div><div style="background: #FFFBE6;padding:10px;border: 1px solid #C3C3C3;border-radius:5px;margin-bottom:5px;">Web API 是浏览器提供的一套操作浏览器功能和页面元素的 API ( BOM 和 DOM )。</div><div style="background: #FFFBE6;padding:10px;border: 1px solid #C3C3C3;border-radius:5px;margin-bottom:5px;">[https://www.zhihu.com/question/21691705](https://www.zhihu.com/question/21691705)</div><h2 id="DOM-总结"><a href="#DOM-总结" class="headerlink" title="DOM 总结"></a>DOM 总结</h2><p>关于 dom 操作，我们主要针对于元素的操作。主要有创建、增、删、改、查、属性操作、事件操作。<br>【1】创建<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518360222-db94e8d0-f9a7-459d-8a24-88b745237bd5.png#align=left&display=inline&height=115&margin=%5Bobject%20Object%5D&originHeight=115&originWidth=691&status=done&style=stroke&width=691"><br>【2】增<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518360287-480d224a-a047-4ef5-8bba-92845d85b573.png#align=left&display=inline&height=85&margin=%5Bobject%20Object%5D&originHeight=85&originWidth=720&status=done&style=stroke&width=720"><br>【3】删<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518360367-4e96254b-5fd8-4f7e-8fb3-29143718f08d.png#align=left&display=inline&height=49&margin=%5Bobject%20Object%5D&originHeight=49&originWidth=695&status=done&style=stroke&width=695"><br>【4】改<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518360436-7e94f916-24d1-4e97-84fe-6fc6ba6d68fb.png#align=left&display=inline&height=191&margin=%5Bobject%20Object%5D&originHeight=191&originWidth=731&status=done&style=stroke&width=731"><br>【5】查<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518360497-cfec4566-ac5b-46c6-995d-8db307167137.png#align=left&display=inline&height=181&margin=%5Bobject%20Object%5D&originHeight=181&originWidth=703&status=done&style=stroke&width=703"><br>【6】属性操作<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518360564-6e2cf7dd-fa5e-48fe-bcdb-be69ea87065c.png#align=left&display=inline&height=157&margin=%5Bobject%20Object%5D&originHeight=157&originWidth=722&status=done&style=stroke&width=722"><br>【7】事件操作（重点）</p><h2 id="获取元素"><a href="#获取元素" class="headerlink" title="获取元素"></a>获取元素</h2><h3 id="getElementById"><a href="#getElementById" class="headerlink" title="getElementById"></a>getElementById</h3><ul><li>语法：document.getElementById(id)</li><li>作用：根据 ID 获取元素对象</li><li>参数：id 值，区分大小写的字符串</li><li>返回值：元素对象 或 null</li></ul><p>**</p><pre><code class="javascript">var test_id = document.getElementById(&quot;indexLogo&quot;);</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616048539813-60fc22f6-0d07-482c-aaae-0227b1f55206.png#align=left&display=inline&height=280&margin=%5Bobject%20Object%5D&name=image.png&originHeight=560&originWidth=916&size=53785&status=done&style=stroke&width=458" alt="image.png"></p><h3 id="getElementsByTagName"><a href="#getElementsByTagName" class="headerlink" title="getElementsByTagName"></a>getElementsByTagName</h3><ul><li>语法：document.getElementsByTagName(‘标签名’) 或者 element.getElementsByTagName(‘标签名’)</li><li>作用：根据标签名获取元素对象</li><li>参数：标签名</li><li>返回值：元素对象集合（伪数组，数组元素是元素对象）**</li></ul><pre><code class="javascript">var test_tag = document.getElementsByTagName(&quot;p&quot;);</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616048909454-bdfb7dbc-18e4-4449-abc6-800e87b42380.png#align=left&display=inline&height=442&margin=%5Bobject%20Object%5D&name=image.png&originHeight=884&originWidth=1920&size=1760479&status=done&style=stroke&width=960" alt="image.png"></p><ul><li>getElementsByTagName()获取到是动态集合，即：当页面增加了标签，这个集合中也就增加了元素。</li><li>由上面的图可以知道，得到的不是一个对象，而是一个对象集合，所以要操作具体的一个 p 就要遍历，然后再进行操作（抑或是对其当作节点再进行操作）</li></ul><h3 id="getElementsByClassName"><a href="#getElementsByClassName" class="headerlink" title="getElementsByClassName"></a>getElementsByClassName</h3><h3 id=""><a href="#" class="headerlink" title=""></a><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616049522946-8c892471-1b04-4b04-b56f-630420bdb654.png#align=left&display=inline&height=440&margin=%5Bobject%20Object%5D&name=image.png&originHeight=880&originWidth=1920&size=312821&status=done&style=stroke&width=960" alt="image.png"></h3><h3 id="querySelector"><a href="#querySelector" class="headerlink" title="querySelector"></a>querySelector</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616049685312-55929307-c68b-4e1d-b6b5-1845c0d5a878.png#align=left&display=inline&height=226&margin=%5Bobject%20Object%5D&name=image.png&originHeight=451&originWidth=1920&size=239671&status=done&style=stroke&width=960" alt="image.png"></p><h3 id="querySelectorAll"><a href="#querySelectorAll" class="headerlink" title="querySelectorAll"></a>querySelectorAll</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616049810063-ee5595dc-89bb-47cc-aa9a-c9446ed97d6f.png#align=left&display=inline&height=306&margin=%5Bobject%20Object%5D&name=image.png&originHeight=612&originWidth=1920&size=288375&status=done&style=stroke&width=960" alt="image.png"></p><ul><li>如果是选择器，需要加符号 <code>querySelectorAll(&#39;#box1&#39;)</code> **</li></ul><h3 id="获取-body-html-对象"><a href="#获取-body-html-对象" class="headerlink" title="获取 body/html 对象"></a>获取 body/html 对象</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616050005999-ac944be2-9612-41ac-89f7-9fa04c4d3912.png#align=left&display=inline&height=442&margin=%5Bobject%20Object%5D&name=image.png&originHeight=884&originWidth=1920&size=301673&status=done&style=stroke&width=960" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518355850-2e015c88-50b7-400e-9593-c7e21a9068b5.png#align=left&display=inline&height=272&margin=%5Bobject%20Object%5D&originHeight=272&originWidth=748&status=done&style=none&width=748"></p><h2 id="操作元素内容-属性"><a href="#操作元素内容-属性" class="headerlink" title="操作元素内容/属性"></a>操作元素内容/属性</h2><p>JavaScript 的 DOM 操作可以改变网页内容、结构和样式，我们可以利用 DOM 操作元素来改变元素里面的内容、属性等。（注意：这些操作都是通过元素对象的属性实现的）</p><h4 id="-1"><a href="#-1" class="headerlink" title=""></a><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518357274-e26496b9-3fdb-47de-85be-fd6aea949767.png#align=left&display=inline&height=253&margin=%5Bobject%20Object%5D&originHeight=424&originWidth=741&status=done&style=stroke&width=442"></h4><h3 id="innerText-和-innerHTML"><a href="#innerText-和-innerHTML" class="headerlink" title="innerText 和 innerHTML"></a>innerText 和 innerHTML</h3><ul><li>获取内容时的区别：innerText 会去除空格和换行，而 innerHTML 会保留空格和换行</li><li>设置内容时的区别：innerText 不会识别 html，而 innerHTML 会识别</li><li>小记：是属性，不是方法！要用赋值的形式，而不是带参数的形式</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616053295394-7fe7d51d-3ce6-4f51-9898-9e0e62b207c4.png#align=left&display=inline&height=441&margin=%5Bobject%20Object%5D&name=image.png&originHeight=881&originWidth=1920&size=1394439&status=done&style=stroke&width=960" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616053546675-78ea1659-1dee-4b43-aa1a-82aad00e1795.png#align=left&display=inline&height=440&margin=%5Bobject%20Object%5D&name=image.png&originHeight=879&originWidth=1920&size=1397046&status=done&style=stroke&width=960" alt="image.png"></p><h3 id="改变元素属性操作"><a href="#改变元素属性操作" class="headerlink" title="改变元素属性操作"></a>改变元素属性操作</h3><h3 id="-2"><a href="#-2" class="headerlink" title=""></a><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616053829361-6faff7b2-0d8f-41c6-b909-6b72ff3b5401.png#align=left&display=inline&height=352&margin=%5Bobject%20Object%5D&name=image.png&originHeight=703&originWidth=1920&size=639610&status=done&style=stroke&width=960" alt="image.png"></h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616054507713-8b717792-1d98-4477-a9e8-db7417b87f34.png#align=left&display=inline&height=440&margin=%5Bobject%20Object%5D&name=image.png&originHeight=880&originWidth=1920&size=169274&status=done&style=stroke&width=960" alt="image.png"></p><h3 id="element-style"><a href="#element-style" class="headerlink" title="element.style"></a>element.style</h3><h3 id="-3"><a href="#-3" class="headerlink" title=""></a><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616053829361-6faff7b2-0d8f-41c6-b909-6b72ff3b5401.png#align=left&display=inline&height=352&margin=%5Bobject%20Object%5D&name=image.png&originHeight=703&originWidth=1920&size=639610&status=done&style=stroke&width=960" alt="image.png"></h3><ul><li>元素对象的 style 属性也是一个对象！</li><li>元素对象.style.样式属性 = 值;</li><li>其中样式属性的命名不再是中间有-的，而是驼峰命名，eg：backgroundColor</li><li>js 修改的 style 样式操作，产生的是行内样式，css 权重较高</li></ul><h3 id="element-className"><a href="#element-className" class="headerlink" title="element.className"></a>element.className</h3><ul><li>元素对象.className = 值;</li><li>因为 class 是关键字，所有使用 className，覆盖原先的类名</li></ul><pre><code class="html">&lt;body&gt;  &lt;div class=&quot;first&quot;&gt;文本&lt;/div&gt;  &lt;script&gt;    // 1. 使用 element.style 获得修改元素样式  如果样式比较少 或者 功能简单的情况下使用    var test = document.querySelector(&quot;div&quot;);    test.onclick = function () &#123;      // 2. 我们可以通过 修改元素的className更改元素的样式 适合于样式较多或者功能复杂的情况      // 3. 如果想要保留原先的类名，我们可以这么做 多类名选择器      // this.className = &#39;change&#39;;      this.className = &quot;first change&quot;;    &#125;;  &lt;/script&gt;&lt;/body&gt;</code></pre><h2 id="自定义元素属性"><a href="#自定义元素属性" class="headerlink" title="自定义元素属性"></a>自定义元素属性</h2><h3 id="element-getAttribute"><a href="#element-getAttribute" class="headerlink" title="element.getAttribute"></a>element.getAttribute</h3><ul><li>和 element.属性不同的是，获取的是自定义属性的值，而 element.属性获取的是内置的属性</li></ul><pre><code class="html">&lt;div id=&quot;demo&quot; index=&quot;1&quot; class=&quot;nav&quot;&gt;&lt;/div&gt;&lt;script&gt;  var div = document.querySelector(&quot;div&quot;);  // 1. 获取元素的属性值  // (1) element.属性  console.log(div.id);  //(2) element.getAttribute(&#39;属性&#39;)  get得到获取 attribute 属性的意思 我们程序员自己添加的属性我们称为自定义属性 index  console.log(div.getAttribute(&quot;id&quot;));  console.log(div.getAttribute(&quot;index&quot;));&lt;/script&gt;</code></pre><h3 id="element-setAttribute"><a href="#element-setAttribute" class="headerlink" title="element.setAttribute"></a>element.setAttribute</h3><ul><li>element.setAttribute(‘属性’,’值’)；</li></ul><pre><code class="javascript">// 2. 设置元素属性值// (1) element.属性= &#39;值&#39;div.id = &quot;test&quot;;div.className = &quot;navs&quot;;// (2) element.setAttribute(&#39;属性&#39;, &#39;值&#39;);  主要针对于自定义属性div.setAttribute(&quot;index&quot;, 2);div.setAttribute(&quot;class&quot;, &quot;footer&quot;); // class 特殊  这里面写的就是</code></pre><h3 id="element-removeAttribute"><a href="#element-removeAttribute" class="headerlink" title="element.removeAttribute"></a>element.removeAttribute</h3><pre><code class="javascript">// class 不是className// 3 移除属性 removeAttribute(属性)div.removeAttribute(&quot;index&quot;);</code></pre><h3 id="Demo：tab-栏"><a href="#Demo：tab-栏" class="headerlink" title="Demo：tab 栏"></a>Demo：tab 栏</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518358239-8396b94f-cc87-4ff3-bc86-20c652a2fe8f.png#align=left&display=inline&height=272&margin=%5Bobject%20Object%5D&originHeight=272&originWidth=786&status=done&style=stroke&width=786"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518358314-a1d9f6be-a9c3-4693-8b11-eec0665df297.png#align=left&display=inline&height=290&margin=%5Bobject%20Object%5D&originHeight=290&originWidth=744&status=done&style=stroke&width=744"></p><pre><code class="html">&lt;script&gt;  // 获取元素  var tab_list = document.querySelector(&quot;.tab_list&quot;);  var lis = tab_list.querySelectorAll(&quot;li&quot;);  var items = document.querySelectorAll(&quot;.item&quot;);  // for循环，给选项卡绑定点击事件  for (var i = 0; i &lt; lis.length; i++) &#123;    // 开始给5个小li 设置索引号    lis[i].setAttribute(&quot;index&quot;, i);    lis[i].onclick = function () &#123;      // 1. 上的模块选项卡，当前这一个底色会是红色，其余不变（排他思想）      // 干掉所有人 其余的li清除 class 这个类      for (var i = 0; i &lt; lis.length; i++) &#123;        lis[i].className = &quot;&quot;;      &#125;      // 留下我自己      this.className = &quot;current&quot;;      // 2. 下面的显示内容模块      var index = this.getAttribute(&quot;index&quot;);      console.log(index);      // 干掉所有人 让其余的item 这些div 隐藏      for (var i = 0; i &lt; items.length; i++) &#123;        items[i].style.display = &quot;none&quot;;      &#125;      // 留下我自己 让对应的item 显示出来      items[index].style.display = &quot;block&quot;;    &#125;;  &#125;&lt;/script&gt;</code></pre><h3 id="element-dataset"><a href="#element-dataset" class="headerlink" title="element.dataset"></a>element.dataset</h3><p>自定义属性目的：是为了保存并使用数据。有些数据可以保存到页面中而不用保存到数据库中。<br>自定义属性获取是通过 getAttribute(‘属性’) 获取。<br>但是有些自定义属性很容易引起歧义，不容易判断是元素的内置属性还是自定义属性。<br>H5 给我们新增了自定义属性：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518358371-b2d8cb33-5750-4e13-be06-27c86768b244.png#align=left&display=inline&height=196&margin=%5Bobject%20Object%5D&originHeight=196&originWidth=705&status=done&style=stroke&width=705"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518358431-0a046321-c303-4333-9e0d-57875144f3e5.png#align=left&display=inline&height=125&margin=%5Bobject%20Object%5D&originHeight=125&originWidth=691&status=done&style=stroke&width=691"></p><pre><code class="html">&lt;div getTime=&quot;20&quot; data-index=&quot;2&quot; data-list-name=&quot;andy&quot;&gt;&lt;/div&gt;&lt;script&gt;  var div = document.querySelector(&quot;div&quot;);  // console.log(div.getTime);  console.log(div.getAttribute(&quot;getTime&quot;));  div.setAttribute(&quot;data-time&quot;, 20);  console.log(div.getAttribute(&quot;data-index&quot;));  console.log(div.getAttribute(&quot;data-list-name&quot;));  // h5新增的获取自定义属性的方法 它只能获取data-开头的  // dataset 是一个集合里面存放了所有以data开头的自定义属性  console.log(div.dataset);  console.log(div.dataset.index);  console.log(div.dataset[&quot;index&quot;]);  // 如果自定义属性里面有多个-链接的单词，我们获取的时候采取 驼峰命名法  console.log(div.dataset.listName);  console.log(div.dataset[&quot;listName&quot;]);&lt;/script&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 👨‍💻Web开发 </category>
          
          <category> JavaScript+DOM+BOM+TS </category>
          
          <category> DOM </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>内置对象-全局属性-函数</title>
      <link href="/blog/fc3rdkwoum2b/"/>
      <url>/blog/fc3rdkwoum2b/</url>
      
        <content type="html"><![CDATA[<p><strong>前言：</strong><br>【全文内容是基于以下文档内容所作的补充】</p><ul><li>MDN：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects">JavaScript 标准内置对象</a></li><li>W3school：<a href="https://www.w3school.com.cn/jsref/index.asp">JavaScript 和 HTML DOM 参考手册</a></li><li>菜鸟教程：<a href="https://www.runoob.com/jsref/jsref-tutorial.html">JavaScript 和 HTML DOM 参考手册</a></li></ul><p>补充：数组、字符串两中对象，都是打印原始值：</p><ul><li>toString</li><li>valueOf</li></ul><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><table><thead><tr><th>类型</th><th>API</th></tr></thead><tbody><tr><td>增、删、改</td><td></td></tr></tbody></table><ul><li>replace()：修改指定字符串为新字符串</li><li>replaceAll()：所有的</li><li>slice()：和数组 api 一样</li><li>substr()：给起始索引截取指定个数</li><li>substring()：[起始索引，结束索引)</li><li>trim()：清楚两边空白</li><li>toLowerCase()：字符串转换为小写</li><li>toUpperCase()：字符串转换为大写</li><li>toLocaleLowerCase()：根据本地主机的语言环境把字符串转换为小写</li><li>toLocaleUpperCase()：根据本地主机的语言环境把字符串转换为大写<br>|<br>| 查 |</li><li>charAt：根据索引得到指定位置值</li><li>charCodeAt：根据索引得到指定位置值 Unicode 码</li><li>indexOf()：查找子字符串的初次索引</li><li>lastIndexOf()：从右往左</li><li>includes()：是否包含子字符串</li><li>match()：查找正则规则子字符串</li><li>search()：查找指定字符串/正则的索引<br>|<br>| 和数组联系 |</li><li>split：根据指定字符切割数组<br>|<br>| 拷贝和拼接 |</li><li>concat：和数组一样<br>|<br>| 其他 |</li><li>startsWith()：是否已子字符串开头</li><li>endsWith：是否以子字符串结尾</li><li>fromCharCode()：Unicode 码转换为字符</li><li>repeat：将字符串复制指定次数并返回，参数是次数<blockquote><p>‘hello’.repeat(2) // “hellohello”</p></blockquote></li></ul><p>|</p><h3 id="反引号"><a href="#反引号" class="headerlink" title="反引号"></a>反引号</h3><p>ES6 新增的创建字符串的方式，使用反引号定义</p><pre><code class="javascript">let name = `zhangsan`;</code></pre><ul><li>模板字符串中可以解析变量</li></ul><pre><code class="javascript">let name = &quot;张三&quot;;let sayHello = `hello,my name is $&#123;name&#125;`; // hello,my name is 张三</code></pre><ul><li>模板字符串中可以换行</li></ul><pre><code class="javascript">let result = &#123;  name: &quot;zhangsan&quot;,  age: 20,  sex: &quot;男&quot;,&#125;;let html = ` &lt;div&gt;     &lt;span&gt;$&#123;result.name&#125;&lt;/span&gt;     &lt;span&gt;$&#123;result.age&#125;&lt;/span&gt;     &lt;span&gt;$&#123;result.sex&#125;&lt;/span&gt; &lt;/div&gt; `;</code></pre><ul><li>在模板字符串中可以调用函数</li></ul><pre><code class="javascript">const sayHello = function () &#123;  return &quot;哈哈哈哈 追不到我吧 我就是这么强大&quot;;&#125;;let greet = `$&#123;sayHello()&#125; 哈哈哈哈`;console.log(greet); // 哈哈哈哈 追不到我吧 我就是这么强大 哈哈哈哈</code></pre><h2 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h2><ul><li><a href="https://www.runoob.com/jsref/jsref-obj-array.html">https://www.runoob.com/jsref/jsref-obj-array.html</a><table><thead><tr><th>类型</th><th>API</th></tr></thead><tbody><tr><td>增、删、改</td><td></td></tr></tbody></table></li><li>slice：操作完然后复制结果为一个新数组</li><li>splice：会改变原始数组，返回的删除元素数组<br>|<br>| 查 |</li><li>includes：根据数组元素值查</li><li>indexOf：根据索引查</li><li>lastIndexOf：根据索引查<br>|<br>| 充当栈、队列 |</li><li>push：末尾添加元素，返回新长度</li><li>pop：删除最后一个元素并且返回该值</li><li>shift：删除第一个元素并且返回该值</li><li>unshift：开头添加元素，返回新长度<br>|<br>| 和字符串联系 |</li><li>join：通过指定字符串拼接，空参数则为逗号（类似 valueOf 和 toString）<br>|<br>| 迭代遍历有关 | every、some、entries、filter、find、findIndex、forEach、keys</li><li>find：可以传入参数来查找</li><li>map：相当于将 y = x 变成 y = x2，不改变原数组</li><li>reduce：把结果继续和序列的下一个元素做累积计算</li></ul><pre><code class="javascript">var arr = [1, 3, 5, 7, 9];arr.reduce(function (x, y) &#123;  return x * 10 + y;&#125;); // 13579</code></pre><ul><li>reduceRight<br>|<br>| 拷贝和拼接 |</li><li>concat：不改变原数组，arr1.concat(arr2, arr3)</li><li>扩展运算符</li></ul><pre><code class="javascript">// 方法一let ary1 = [1, 2, 3];let ary2 = [3, 4, 5];let ary3 = [...ary1, ...ary2];// 方法二ary1.push(...ary2);</code></pre><ul><li><p>copyWithin：从数组的指定位置拷贝元素到数组的另一个指定位置中<br>|<br>| 排序 |</p></li><li><p>sort：数字升序（sort((a,b)=&gt;{return a-b})）</p></li><li><p>reserve：逆置<br>|<br>| 其他 |</p></li><li><p>fill：使用一个值来填充/替换数组元素，可以指定索引，通常用在 DP 问题的填充 0</p></li><li><p>from：构造函数方法，将伪数组或可遍历对象转换为真正的数组（类数组转换为数组）</p><blockquote><p>伪数组、可遍历对象、Set</p></blockquote></li><li><p>isArray<br>|</p></li></ul><h3 id="类数组与数组的区别与转换"><a href="#类数组与数组的区别与转换" class="headerlink" title="类数组与数组的区别与转换"></a>类数组与数组的区别与转换</h3><p><a href="https://blog.csdn.net/qq_37635012/article/details/106195211">https://blog.csdn.net/qq_37635012/article/details/106195211</a></p><h3 id="扩展运算符（展开语法）"><a href="#扩展运算符（展开语法）" class="headerlink" title="扩展运算符（展开语法）"></a>扩展运算符（展开语法）</h3><p>扩展运算符可以将数组或者对象转为用逗号分隔的参数序列</p><pre><code class="javascript">let ary = [1, 2, 3]; ...ary  // 1, 2, 3 console.log(...ary);    // 1 2 3,相当于下面的代码 console.log(1,2,3);</code></pre><p><strong>扩展运算符可以应用于合并数组</strong></p><pre><code class="javascript">// 方法一let ary1 = [1, 2, 3];let ary2 = [3, 4, 5];let ary3 = [...ary1, ...ary2];// 方法二ary1.push(...ary2);</code></pre><p><strong>将类数组或可遍历对象转换为真正的数组</strong></p><pre><code class="javascript">let oDivs = document.getElementsByTagName(&quot;div&quot;);oDivs = [...oDivs];</code></pre><h3 id="Array-构造函数"><a href="#Array-构造函数" class="headerlink" title="Array 构造函数"></a>Array 构造函数</h3><ul><li>Array 构造函数：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/Array">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/Array</a></li></ul><h3 id="from"><a href="#from" class="headerlink" title="from"></a>from</h3><p>构造函数方法：Array.from()<br>将伪数组或可遍历对象转换为真正的数组</p><pre><code class="javascript">//定义一个集合let arrayLike = &#123;  0: &quot;a&quot;,  1: &quot;b&quot;,  2: &quot;c&quot;,  length: 3,&#125;;//转成数组let arr2 = Array.from(arrayLike); // [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]</code></pre><p>方法还可以接受第二个参数，作用类似于数组的 map 方法，用来对每个元素进行处理，将处理后的值放入返回的数组</p><pre><code class="javascript">let arrayLike = &#123;  0: 1,  1: 2,  length: 2,&#125;;let newAry = Array.from(arrayLike, (item) =&gt; item * 2); //[2,4]</code></pre><p>注意：如果是对象，那么属性需要写对应的索引</p><h3 id="find"><a href="#find" class="headerlink" title="find"></a>find</h3><p>用于找出第一个符合条件的数组成员，如果没有找到返回 undefined</p><pre><code class="javascript">let ary = [  &#123;    id: 1,    name: &quot;张三&quot;,  &#125;,  &#123;    id: 2,    name: &quot;李四&quot;,  &#125;,];//找数组里面符合条件的值，当数组中元素id等于2的查找出来，注意，只会匹配第一个let target = ary.find((item, index) =&gt; item.id == 2);</code></pre><h3 id="findIndex"><a href="#findIndex" class="headerlink" title="findIndex"></a>findIndex</h3><p>用于找出第一个符合条件的数组成员的位置，如果没有找到返回-1</p><pre><code class="javascript">let ary = [1, 5, 10, 15];let index = ary.findIndex((value, index) =&gt; value &gt; 9);console.log(index); // 2</code></pre><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><p><a href="https://www.runoob.com/w3cnote/es6-map-set.html">https://www.runoob.com/w3cnote/es6-map-set.html</a></p><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。<br>Set 本身是一个构造函数，用来生成 Set 数据结构</p><pre><code class="javascript">const s = new Set();</code></pre><p>Set 函数可以接受一个数组作为参数，用来初始化。</p><pre><code class="javascript">const set = new Set([1, 2, 3, 4, 4]); //&#123;1, 2, 3, 4&#125;</code></pre><h3 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h3><ul><li>add(value)：添加某个值，返回 Set 结构本身</li><li>delete(value)：删除某个值，返回一个布尔值，表示删除是否成功</li><li>has(value)：返回一个布尔值，表示该值是否为 Set 的成员</li><li>clear()：清除所有成员，没有返回值</li></ul><pre><code class="javascript">const s = new Set();s.add(1).add(2).add(3); // 向 set 结构中添加值s.delete(2); // 删除 set 结构中的2值s.has(1); // 表示 set 结构中是否有1这个值 返回布尔值s.clear(); // 清除 set 结构中的所有值//注意：删除的是元素的值，不是代表的索引</code></pre><h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><p>Set 结构的实例与数组一样，也拥有 forEach 方法，用于对每个成员执行某种操作，没有返回值。</p><pre><code class="javascript">s.forEach((value) =&gt; console.log(value));</code></pre><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p><a href="https://www.runoob.com/w3cnote/es6-map-set.html">https://www.runoob.com/w3cnote/es6-map-set.html</a></p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h3><ul><li>数组和对象可以赋值解构</li><li>参考：<a href="https://zh.javascript.info/destructuring-assignment">https://zh.javascript.info/destructuring-assignment</a></li></ul><h3 id="剩余参数"><a href="#剩余参数" class="headerlink" title="剩余参数"></a>剩余参数</h3><ul><li>剩余参数是以<strong>数组</strong>的形式存在的</li></ul><pre><code class="javascript">function sum(...theArgs) &#123;  return theArgs.reduce((previous, current) =&gt; &#123;    return previous + current;  &#125;);&#125;console.log(sum(1, 2, 3));// expected output: 6console.log(sum(1, 2, 3, 4));// expected output: 10</code></pre>]]></content>
      
      
      <categories>
          
          <category> 👨‍💻Web开发 </category>
          
          <category> JavaScript+DOM+BOM+TS </category>
          
          <category> ECMAScript </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Shadowsocks/ByWave使用总结</title>
      <link href="/blog/qt0mw3de2tcn/"/>
      <url>/blog/qt0mw3de2tcn/</url>
      
        <content type="html"><![CDATA[<p>这是加密文章！</p>]]></content>
      
      
      <categories>
          
          <category> 🔨环境工具 </category>
          
          <category> 工具使用 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>变量-数据类型-表达式-程序结构</title>
      <link href="/blog/uz1d072engtt/"/>
      <url>/blog/uz1d072engtt/</url>
      
        <content type="html"><![CDATA[<h2 id="知识架构"><a href="#知识架构" class="headerlink" title="知识架构"></a>知识架构</h2><h3 id="第一大类：ECMAScript"><a href="#第一大类：ECMAScript" class="headerlink" title="第一大类：ECMAScript"></a>第一大类：ECMAScript</h3><ul><li><p><input checked="" disabled="" type="checkbox">  基本语法</p><ul><li>【补充】JavaScript 语言介绍</li><li>变量</li><li>基本数据类型</li><li>运算符和表达式</li><li>流程控制语句</li></ul></li><li><p><input checked="" disabled="" type="checkbox">  函数</p><ul><li>常规基础知识</li><li>闭包</li><li>JavaScript 运行机制（单线程，异步任务机制……）</li></ul></li><li><p><input checked="" disabled="" type="checkbox">  引用</p><blockquote><p>文档学习：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript</a></p></blockquote><ul><li>基本引用类型：Date、RegExp、原始包装、Global、Math 等</li><li>集合引用类型：Object、Array、Map、WeakMap、Set、WeakSet</li></ul></li><li><p><input checked="" disabled="" type="checkbox">  面向对象</p><ul><li>体系一：原型</li><li>体系二：类【ES6 后出来的】</li><li>关于对象的创建和内置方法</li></ul></li></ul><hr><ul><li><input disabled="" type="checkbox"> 迭代器和生成器</li><li><input disabled="" type="checkbox"> 代理和反射</li><li><input disabled="" type="checkbox"> canvas 技术</li><li><input disabled="" type="checkbox"> 表单脚本</li><li><input disabled="" type="checkbox"> JavaScript API</li><li><input disabled="" type="checkbox"> 错误处理和调试</li><li><input disabled="" type="checkbox"> 处理 XML</li><li><input disabled="" type="checkbox"> JSON 技术</li><li><input disabled="" type="checkbox"> 网络请求和远程资源</li><li><input disabled="" type="checkbox"> 模块化</li><li><input disabled="" type="checkbox"> 工作者线程</li><li><input disabled="" type="checkbox"> 最佳实践</li><li><input checked="" disabled="" type="checkbox"> 严格模式</li></ul><h2 id="JavaScript-编程语言"><a href="#JavaScript-编程语言" class="headerlink" title="JavaScript 编程语言"></a>JavaScript 编程语言</h2><h3 id="解释型语言和编译型语言"><a href="#解释型语言和编译型语言" class="headerlink" title="解释型语言和编译型语言"></a>解释型语言和编译型语言</h3><p>计算机不能直接理解任何除机器语言以外的语言，所以必须要把程序员所写的程序语言翻译成机器语言才能执行程序。程序语言翻译成机器语言的工具，被称为翻译器。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611883945965-edfd63f6-b312-4daa-990e-aa7fb8d29640.png#crop=0&crop=0&crop=1&crop=1&height=82&id=lzaQj&margin=%5Bobject%20Object%5D&name=image.png&originHeight=163&originWidth=614&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=25533&status=done&style=none&title=&width=307" alt="image.png"></p><ul><li>翻译器翻译的方式有两种：一个是编译，另外一个是解释。两种方式之间的区别在于翻译的时间点不同</li><li>编译器是在代码执行之前进行编译，生成中间代码文件</li><li>解释器是在运行时进行及时解释，并立即执行(当编译器以解释方式运行的时候，也称之为解释器)<blockquote><p>执行过程</p></blockquote></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611883933551-3185c915-4a31-4151-a6c6-9212e11d336c.png#crop=0&crop=0&crop=1&crop=1&height=246&id=Fnw0A&margin=%5Bobject%20Object%5D&name=image.png&originHeight=492&originWidth=825&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=122185&status=done&style=none&title=&width=412.5" alt="image.png"></p><h3 id="JavaScript-是什么"><a href="#JavaScript-是什么" class="headerlink" title="JavaScript 是什么"></a>JavaScript 是什么</h3><ul><li>JavaScript 是世界上最流行的语言之一，是一种运行在客户端的脚本语言 （Script == 脚本）</li><li>脚本语言：不需要编译，运行过程中由 js 解释器( js 引擎）逐行来进行解释并执行</li><li>现在也可以基于 Node.js 技术进行服务器端编程</li></ul><h3 id="JavaScript-的作用"><a href="#JavaScript-的作用" class="headerlink" title="JavaScript 的作用"></a>JavaScript 的作用</h3><ul><li>表单动态校验（密码强度检测） （ JS 产生最初的目的 ）</li><li>网页特效</li><li>服务端开发(Node.js)</li><li>桌面程序(Electron)</li><li>App(Cordova)</li><li>控制硬件-物联网(Ruff)</li><li>游戏开发(cocos2d-js)</li></ul><h3 id="浏览器执行-JS-简介"><a href="#浏览器执行-JS-简介" class="headerlink" title="浏览器执行 JS 简介"></a>浏览器执行 JS 简介</h3><p><strong>浏览器分成两部分：渲染引擎和 JS 引擎</strong><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611883433929-789dc835-fd39-43fb-8212-9580ee9e69a6.png#crop=0&crop=0&crop=1&crop=1&height=132&id=sXxXn&margin=%5Bobject%20Object%5D&name=image.png&originHeight=263&originWidth=839&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=73081&status=done&style=stroke&title=&width=419.5" alt="image.png"></p><pre><code>浏览器本身并不会执行JS代码，而是通过内置 JavaScript 引擎(解释器) 来执行 JS 代码 。JS 引擎执行代码时逐行解释每一句源码（转换为机器语言），然后由计算机去执行，所以 JavaScript 语言归为脚本语言，会逐行解释执行。</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611883443893-9e920247-6cbf-4713-85cb-c76eeb34013c.png#crop=0&crop=0&crop=1&crop=1&height=149&id=KjTqV&margin=%5Bobject%20Object%5D&name=image.png&originHeight=297&originWidth=816&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=53400&status=done&style=stroke&title=&width=408" alt="image.png"></p><h3 id="JavaScript-的组成"><a href="#JavaScript-的组成" class="headerlink" title="JavaScript 的组成"></a>JavaScript 的组成</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611883453712-2dfb6f14-cf77-4475-ad87-5826124bc43f.png#crop=0&crop=0&crop=1&crop=1&height=189&id=nDXwH&margin=%5Bobject%20Object%5D&name=image.png&originHeight=378&originWidth=825&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=47608&status=done&style=stroke&title=&width=412.5" alt="image.png"></p><ol><li><strong>ECMAScript</strong><br>        ECMAScript 是由 ECMA 国际（ 原欧洲计算机制造商协会）进行标准化的一门编程语言，这种语言在万维网上应用广泛，它往往被称为 JavaScript 或 JScript，但实际上后两者是 ECMAScript 语言的实现和扩展。<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611883470657-6e9bb00b-781e-46d3-99e7-64afd35e3758.png#crop=0&crop=0&crop=1&crop=1&height=138&id=HPj6o&margin=%5Bobject%20Object%5D&name=image.png&originHeight=276&originWidth=841&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=27667&status=done&style=stroke&title=&width=420.5" alt="image.png"><br>ECMAScript：规定了 JS 的编程语法和基础核心知识，是所有浏览器厂商共同遵守的一套 JS 语法工业标准。<br>更多参看 MDN: <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/JavaScript_technologies_overview">MDN 手册</a></li><li><strong>DOM——文档对象模型</strong><br><strong>文档对象模型</strong>（DocumentObject Model，简称 DOM），是 W3C 组织推荐的处理可扩展标记语言的标准编程接口。通过 DOM 提供的接口可以对页面上的各种元素进行操作（大小、位置、颜色等）</li><li><strong>BOM——浏览器对象模型</strong><br><strong>浏览器对象模型</strong>(Browser Object Model，简称 BOM) 是指浏览器对象模型，它提供了独立于内容的、可以与浏览器窗口进行互动的对象结构。通过 BOM 可以操作浏览器窗口，比如弹出框、控制浏览器跳转、获取分辨率等。</li></ol><h3 id="JavaScript-初体验"><a href="#JavaScript-初体验" class="headerlink" title="JavaScript 初体验"></a>JavaScript 初体验</h3><pre><code>JS 有3种书写位置，分别为行内、内嵌和外部。</code></pre><ol><li>行内式</li></ol><pre><code class="html">&lt;input type=&quot;button&quot; value=&quot;点我试试&quot; onclick=&quot;alert(&#39;Hello World&#39;)&quot; /&gt;</code></pre><ul><li>可以将单行或少量 JS 代码写在 HTML 标签的事件属性中（以 on 开头的属性），如：onclick</li><li>注意单双引号的使用：在 HTML 中我们推荐使用双引号, JS 中我们推荐使用单引号</li><li>可读性差， 在 html 中编写 JS 大量代码时，不方便阅读；</li><li>引号易错，引号多层嵌套匹配时，非常容易弄混；</li><li>特殊情况下使用</li></ul><ol start="2"><li>内嵌式</li></ol><pre><code class="html">&lt;script&gt;  alert(&quot;Hello  World~!&quot;);&lt;/script&gt;</code></pre><ul><li>可以将多行 JS 代码写到 script 标签中</li><li>内嵌 JS 是学习时常用的方式</li></ul><ol start="2"><li>外部 JS 文件</li></ol><pre><code class="html">&lt;script src=&quot;my.js&quot;&gt;&lt;/script&gt;</code></pre><ul><li>利于 HTML 页面代码结构化，把大段 JS 代码独立到 HTML 页面之外，既美观，也方便文件级别的复用</li><li>引用外部 JS 文件的 script 标签中间不可以写代码</li><li>适合于 JS 代码量比较大的情况</li></ul><h3 id="JavaScript-输入输出"><a href="#JavaScript-输入输出" class="headerlink" title="JavaScript 输入输出"></a>JavaScript 输入输出</h3><blockquote><p>调试有两种，一种是 debug，一种是 print 大法，js 输入输出依靠浏览器来“可视化”输入输出</p></blockquote><ul><li>prompt：可以输入</li><li>alert：输出</li><li>console.log()：输出</li></ul><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>JavaScript 里面的变量使用可谓是一言难尽，用<em>《JavaScript 高级程序设计》</em>书里面说的就是：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1617866042752-0faeefea-8db4-4432-b4ce-afe96f10375a.png#crop=0&crop=0&crop=1&crop=1&height=19&id=JljGP&margin=%5Bobject%20Object%5D&name=image.png&originHeight=38&originWidth=332&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=8076&status=done&style=none&title=&width=166" alt="image.png">，总结一下变量一些重点知识。</p><h3 id="var-和-let-和-const"><a href="#var-和-let-和-const" class="headerlink" title="var 和 let 和 const"></a>var 和 let 和 const</h3><p><strong>【1】var</strong></p><ul><li>在全局区域声明是全局变量</li><li>在<strong>函数里面</strong>用 var 声明变量的时候是局部变量，但是省略 var 的时候，就变成全局变量了（坑……），好在严格模式下如果在函数里面这样定义会报错</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1617867733497-db043164-d28e-48e8-8bd7-2a9b1d30203a.png#crop=0&crop=0&crop=1&crop=1&height=63&id=HzdsA&margin=%5Bobject%20Object%5D&name=image.png&originHeight=126&originWidth=789&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=36005&status=done&style=none&title=&width=394.5" alt="image.png"></p><ul><li>会变量提升，把所有变量声明都拉到函数作用域的顶部，所以在同一个域里面，var 定义的变量，先使用在定义也是可以的。</li><li>可以多次定义赋值<blockquote><p>var i = 0;<br>var i = 0;</p></blockquote></li></ul><p><strong>【2】let</strong></p><ul><li>作用范围：块作用域</li><li>会有冗余声明（不可以多次定义赋值）</li><li>不会变量提升，俗称“暂时性死区”</li></ul><p><strong>【3】const</strong></p><ul><li>作用范围：块作用域</li><li><strong>声明变量必须同时初始化变量</strong></li><li>尝试修改变量的值报错</li><li>不允许重复声明</li><li>但对对象操作就不一样了</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1617866749694-8c13df91-894d-41ba-a6bf-4545875594be.png#crop=0&crop=0&crop=1&crop=1&height=39&id=Tyu1F&margin=%5Bobject%20Object%5D&name=image.png&originHeight=78&originWidth=900&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=29349&status=done&style=none&title=&width=450" alt="image.png"></p><h3 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h3><p>因为 var 可以多次声明这一个特点，就产生出了一个问题，在函数里面声明一个变量，在函数外也声明一个同名的变量，就会导致接下来的代码使用哪一个变量的情况。分析是哪个其实也好办，就是看调用的这个函数离哪个声明的变量最近，哪个最近取哪个。</p><p><strong>作用域链有其解决的办法，那就是利用作用域链，但是使用 let 和 const 更为方便</strong>。</p><p>比如：循环迭代过程中<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1617867856859-e30d58a7-ff23-4c94-9690-fa18931b1274.png#crop=0&crop=0&crop=1&crop=1&height=133&id=R0mLn&margin=%5Bobject%20Object%5D&name=image.png&originHeight=265&originWidth=930&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=74043&status=done&style=none&title=&width=465" alt="image.png"></p><h3 id="预解析和代码执行"><a href="#预解析和代码执行" class="headerlink" title="预解析和代码执行"></a>预解析和代码执行</h3><p>浏览器的 js 解析器当中，会将 js 代码分两步执行，分别为，预解析和执行代码</p><ul><li>预解析：在当前作用域下, JS 代码执行之前，浏览器会默认把带有 var 和 function 声明的变量在内存中进行提前声明或者定义</li><li>代码执行： 从上到下执行 JS 语句</li></ul><h3 id="使用风格"><a href="#使用风格" class="headerlink" title="使用风格"></a>使用风格</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1617866793247-8f59e0d0-c674-4bbb-927d-c0def061ef4b.png#crop=0&crop=0&crop=1&crop=1&height=143&id=j8Cg3&margin=%5Bobject%20Object%5D&name=image.png&originHeight=285&originWidth=906&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=116098&status=done&style=none&title=&width=453" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1617866805218-d141595e-4964-4c77-8b8a-e0396af6ecc9.png#crop=0&crop=0&crop=1&crop=1&height=40&id=tYDkb&margin=%5Bobject%20Object%5D&name=image.png&originHeight=79&originWidth=896&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=25485&status=done&style=none&title=&width=448" alt="image.png"></p><h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><h3 id="JavaScript-和-java-比较"><a href="#JavaScript-和-java-比较" class="headerlink" title="JavaScript 和 java 比较"></a>JavaScript 和 java 比较</h3><ul><li>JAVA 有八种基本数据类型（byte、short、int、long、float、double、string、boolean）</li><li>JavaScript 有六种基本类型（值类型）（Number、String、Boolean、Undefined、Null、Symbol（es6））<blockquote><p>注：Symbol 是 ES6 引入了一种新的原始数据类型，表示独一无二的值。</p></blockquote></li></ul><p><strong>在 java 中除了以上八种，其他都是以对象 Object（或者说类的实例）存在的，JavaScript 也一样！</strong></p><p>【在 Java.lang 里面有上述八种包装类，在 JavaScript 里面也有相应的概念称之为——包装对象】</p><h3 id="自动确定类型机制"><a href="#自动确定类型机制" class="headerlink" title="自动确定类型机制"></a>自动确定类型机制</h3><p>JavaScript 是一种弱类型或者说动态语言。这意味着不用提前声明变量的类型，在程序运行过程中，类型会被自动确定，这是和 Java 基本类型不同的一点。</p><pre><code class="javascript">var age = 10; // 这是一个数字型var forsome = &quot;是的&quot;; // 这是一个字符串</code></pre><p>在代码运行时，变量的数据类型是由 <strong>JS 引擎</strong> 根据 = 右边变量值的数据类型来判断 的，运行完毕之后， 变量就确定了数据类型。<strong>JavaScript 拥有动态类型，同时也意味着相同的变量可用作不同的类型</strong></p><h3 id="number"><a href="#number" class="headerlink" title="number"></a>number</h3><p>JavaScript 数字类型既可以保存整数，也可以保存小数(浮点数）。</p><table><thead><tr><th>Number.MAX_VALUE</th><th>最大值</th></tr></thead><tbody><tr><td>Number.MIN_VALUE</td><td>最小值</td></tr><tr><td>Infinity</td><td>正无穷大</td></tr><tr><td>-Infinity</td><td>负无穷大</td></tr><tr><td>NaN</td><td>非数值</td></tr></tbody></table><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1617862223224-4f56c586-004a-476a-b000-b6ab21d9d76f.png#crop=0&crop=0&crop=1&crop=1&height=33&id=QgHNv&margin=%5Bobject%20Object%5D&name=image.png&originHeight=66&originWidth=535&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=5962&status=done&style=none&title=&width=267.5" alt="image.png"><br>isNaN()：用来判断一个变量是否为非数字的类型，返回 true 或者 false<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1617862345109-761be59e-466e-4e76-ae90-de038b1eb668.png#crop=0&crop=0&crop=1&crop=1&height=76&id=FD7YB&margin=%5Bobject%20Object%5D&name=image.png&originHeight=151&originWidth=329&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=16886&status=done&style=none&title=&width=164.5" alt="image.png"></p><h3 id="string"><a href="#string" class="headerlink" title="string"></a>string</h3><ul><li><p>转义符：和 java 一样</p><table><thead><tr><th>转义符</th><th>解释说明</th></tr></thead><tbody><tr><td>\n</td><td>换行符，n 是 newline 的意思</td></tr><tr><td>\ \</td><td>斜杠 \</td></tr><tr><td>‘</td><td>‘ 单引号</td></tr><tr><td>“</td><td>”双引号</td></tr><tr><td>\t</td><td>tab 缩进</td></tr><tr><td>\b</td><td>空格 ，b 是 blank 的意思</td></tr></tbody></table></li><li><p>字符串长度：通过字符串的 length 属性可以获取整个字符串的长度。</p></li></ul><pre><code>var strMsg = &quot;一串文字&quot;;alert(strMsg.length); // 显示 4</code></pre><div style="background: #FFF3F3;padding:10px;border: 1px solid #DEB8BE;border-radius:5px;margin-bottom:5px;">Java里面基本数据类型比如定义了一串字符，是没有相应长度length属性一说的，除非new一个字符的对象。JavaScript里面也有相应的机制，称之为——**“包装对象”**，可以直接使用length属性，指的是与数值、字符串、布尔值分别相对应的Number、String、Boolean三个原生对象。这三个原生对象可以把原始类型的值变成（包装成）对象，和Java里面一样。</div><ul><li>字符串拼接：和 java 一样，用一个+号就好了</li></ul><h3 id="boolean"><a href="#boolean" class="headerlink" title="boolean"></a>boolean</h3><p>布尔类型有两个值：true 和 false ，其中 true 表示真（对），而 false 表示假（错）。<br>布尔型和数字型相加的时候， true 的值为 1 ，false 的值为 0。</p><pre><code class="javascript">console.log(true + 1); // 2console.log(false + 1); // 1</code></pre><h3 id="undefined"><a href="#undefined" class="headerlink" title="undefined"></a>undefined</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1617863116062-5457a96b-062e-4262-a093-ea6e30c005cb.png#crop=0&crop=0&crop=1&crop=1&height=227&id=lgGc7&margin=%5Bobject%20Object%5D&name=image.png&originHeight=454&originWidth=1012&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=39117&status=done&style=stroke&title=&width=506" alt="image.png"></p><h3 id="null"><a href="#null" class="headerlink" title="null"></a>null</h3><ul><li>参考教程：<a href="https://javascript.ruanyifeng.com/grammar/types.html#toc2">https://javascript.ruanyifeng.com/grammar/types.html#toc2</a></li></ul><h3 id="symbol"><a href="#symbol" class="headerlink" title="symbol"></a>symbol</h3><p><a href="https://juejin.cn/post/7091170378243899429">https://juejin.cn/post/7091170378243899429</a></p><h3 id="数据类型判断及转换"><a href="#数据类型判断及转换" class="headerlink" title="数据类型判断及转换"></a>数据类型判断及转换</h3><h4 id="typeof、instanceof、constructor、Object-prototype-toString-call"><a href="#typeof、instanceof、constructor、Object-prototype-toString-call" class="headerlink" title="typeof、instanceof、constructor、Object.prototype.toString.call()"></a>typeof、instanceof、constructor、Object.prototype.toString.call()</h4><p><img src="https://cdn.nlark.com/yuque/0/2022/webp/1484158/1648801814160-1ac450e7-aee2-49e7-bae9-3dbd1b18fff0.webp#clientId=u88e2544f-fa6b-4&crop=0&crop=0&crop=1&crop=1&from=paste&id=u5794e0ee&margin=%5Bobject%20Object%5D&originHeight=301&originWidth=737&originalType=url%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=stroke&taskId=ub661e7eb-82eb-4d57-ab9e-743523e3c1a&title="></p><ul><li><a href="https://www.jianshu.com/p/6f3087a44d83">JS 类型判断 typeof、instanceof、constructor、Object.prototype.toString.call()</a></li></ul><h4 id="转换"><a href="#转换" class="headerlink" title="转换"></a>转换</h4><p>使用表单、prompt 获取过来的数据默认是字符串类型的，此时就不能直接简单的进行加法运算，而需要转换变量的数据类型</p><blockquote><p>当参数为： ‘’、0、NaN、null、undefined，转换为 false，其他都转换称 true</p></blockquote><h2 id="运算符和表达式"><a href="#运算符和表达式" class="headerlink" title="运算符和表达式"></a>运算符和表达式</h2><blockquote><p>几乎和 java 里面一样，但是有一些不同</p></blockquote><h3 id="基本"><a href="#基本" class="headerlink" title="基本"></a>基本</h3><ul><li>+-*/%</li><li>i++和++i 区别</li><li>==和===区别就是后者要求值和数据类型都相等，前者只要求值</li><li>&amp;&amp;与||或!非</li></ul><h3 id="逻辑与和逻辑或"><a href="#逻辑与和逻辑或" class="headerlink" title="逻辑与和逻辑或"></a>逻辑与和逻辑或</h3><ul><li>逻辑与</li></ul><pre><code class="javascript">console.log(123 &amp;&amp; 456); // 456console.log(0 &amp;&amp; 456); // 0console.log(123 &amp;&amp; 456 &amp;&amp; 789); // 789</code></pre><ul><li>逻辑或</li></ul><pre><code class="javascript">console.log(123 || 456); //  123console.log(0 || 456); //  456console.log(123 || 456 || 789); //  123</code></pre><h2 id="程序三大基本结构"><a href="#程序三大基本结构" class="headerlink" title="程序三大基本结构"></a>程序三大基本结构</h2><h3 id="顺序结构"><a href="#顺序结构" class="headerlink" title="顺序结构"></a>顺序结构</h3><p>浏览器引擎对 js 代码是从上往下依次执行的！所以 js 代码的位置，以及代码与代码相互依赖的关系顺序都要注意。</p><h3 id="选择结构"><a href="#选择结构" class="headerlink" title="选择结构"></a>选择结构</h3><p>和 Java 一样，都有 if 语句</p><hr><ul><li>switch 语句</li></ul><pre><code class="javascript">switch (表达式) &#123;  case value1:    // 表达式 等于 value1 时要执行的代码    break;  case value2:    // 表达式 等于 value2 时要执行的代码    break;  default:  // 表达式 不等于任何一个 value 时要执行的代码&#125;</code></pre><hr><ul><li>条件赋值语句 = 赋值语句 + <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Conditional_Operator">条件（三元）运算符</a></li></ul><pre><code class="javascript">// 如果row为true则this.actFormOptions.modelObject.assign(&#123;&#125;, toShowActFromData(row))this.actFormOptions.model = row  ? Object.assign(&#123;&#125;, toShowActFromData(row))  : getColumnFormModel(actColumns, defaultActProp);</code></pre><h3 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h3><p>和 Java 一样都有，都有 for(){}、while(){}、do{}while()三种结构，以及 continue、break 两个关键字，用法完全一样，在 java 里面有增强的 for 循环一说，js 也有相应的增强的 for 循环。</p><p>for-in 语句<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1622620171596-8dc93211-66d7-4bff-aa7a-f0a1f25fef6b.png#crop=0&crop=0&crop=1&crop=1&height=169&id=hh3nm&margin=%5Bobject%20Object%5D&name=image.png&originHeight=337&originWidth=1072&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=122831&status=done&style=stroke&title=&width=536" alt="image.png"><br>for-of 语句<br>遍历可迭代对象的元素</p>]]></content>
      
      
      <categories>
          
          <category> 👨‍💻Web开发 </category>
          
          <category> JavaScript+DOM+BOM+TS </category>
          
          <category> ECMAScript </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CSS定位</title>
      <link href="/blog/qfka5bkr6swg/"/>
      <url>/blog/qfka5bkr6swg/</url>
      
        <content type="html"><![CDATA[<h2 id="CSS-布局的三种机制"><a href="#CSS-布局的三种机制" class="headerlink" title="CSS 布局的三种机制"></a>CSS 布局的三种机制</h2><blockquote><p>网页布局的核心 —— 就是<strong>用 CSS 来摆放盒子位置</strong>。<br>CSS 提供了 <strong>3 种机制</strong>来设置盒子的摆放位置，分别是<strong>普通流</strong>、<strong>浮动</strong>和<strong>定位</strong></p></blockquote><blockquote><p><strong>【1】普通流</strong>（<strong>标准流</strong>）</p></blockquote><p>可以让盒子上下排列或者左右排列的</p><ul><li><p><strong>块级元素</strong>会独占一行，<strong>从上向下</strong>顺序排列；</p><ul><li>常用元素：div、hr、p、h1~h6、ul、ol、dl、form、table</li></ul></li><li><p><strong>行内元素</strong>会按照顺序，<strong>从左到右</strong>顺序排列，碰到父元素边缘则自动换行；</p><ul><li>常用元素：span、a、i、em 等<blockquote><p><strong>【2】浮动</strong></p></blockquote></li></ul></li><li><p>让盒子从普通流中<strong>浮</strong>起来 —— <strong>让多个盒子(div)水平排列成一行</strong>。</p></li><li><p>可以让多个块级元素一行显示 或者 左右对齐盒子 浮动的盒子就是按照顺序左右排列</p><blockquote><p><strong>【3】定位</strong></p></blockquote></li><li><p>将盒子<strong>定</strong>在某一个<strong>位</strong>置 自由的漂浮在其他盒子的上面 —— CSS 离不开定位，特别是后面的 js 特效。</p></li><li><p>定位最大的特点是有层叠的概念，就是可以让多个盒子 前后 叠压来显示。 但是每个盒子需要测量数值。</p><blockquote><p><strong>【结论】</strong></p><ul><li>标准流在最底层</li><li>浮动的盒子在中间层</li><li>定位的盒子在最上层</li></ul></blockquote></li></ul><h2 id="定位详解"><a href="#定位详解" class="headerlink" title="定位详解"></a>定位详解</h2><p>定位也是用来布局的，它有两部分组成：</p><blockquote><p><code>定位 = 定位模式 + 边偏移</code></p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611552456483-b258a0b4-d5e2-43ab-af99-f6eef921bacb.png#crop=0&crop=0&crop=1&crop=1&height=182&id=tPuDD&margin=%5Bobject%20Object%5D&name=image.png&originHeight=364&originWidth=602&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=24287&status=done&style=stroke&title=&width=301" alt="image.png"></p><h3 id="边偏移"><a href="#边偏移" class="headerlink" title="边偏移"></a>边偏移</h3><p>简单说， 我们定位的盒子，是通过边偏移来移动位置的。<br>在 CSS 中，通过 <code>top</code>、<code>bottom</code>、<code>left</code> 和 <code>right</code> 属性定义元素的<strong>边偏移</strong>：（方位名词）</p><table><thead><tr><th>边偏移属性</th><th>示例</th><th>描述</th></tr></thead><tbody><tr><td><code>top</code></td><td><code>top: 80px</code></td><td><strong>顶端</strong>偏移量，定义元素相对于其父元素<strong>上边线的距离</strong>。</td></tr><tr><td><code>bottom</code></td><td><code>bottom: 80px</code></td><td><strong>底部</strong>偏移量，定义元素相对于其父元素<strong>下边线的距离</strong>。</td></tr><tr><td><code>left</code></td><td><code>left: 80px</code></td><td><strong>左侧</strong>偏移量，定义元素相对于其父元素<strong>左边线的距离</strong>。</td></tr><tr><td><code>right</code></td><td><code>right: 80px</code></td><td><strong>右侧</strong>偏移量，定义元素相对于其父元素<strong>右边线的距离</strong></td></tr></tbody></table><p>定位的盒子有了边偏移才有价值。 一般情况下，凡是有定位地方必定有边偏移。</p><h3 id="static"><a href="#static" class="headerlink" title="static"></a>static</h3><ul><li><strong>静态定位</strong>是元素的默认定位方式，无定位的意思。它相当于 border 里面的 none， 不要定位的时候用。</li><li>静态定位 按照标准流特性摆放位置，它没有边偏移。</li><li>静态定位在布局时我们几乎不用的</li></ul><h3 id="relative"><a href="#relative" class="headerlink" title="relative"></a>relative</h3><ul><li><strong>相对定位</strong>是元素<strong>相对</strong>于它原来在标准流中的位置 来说的。（自恋型）</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611552470167-bd2f5289-4670-4b1f-9b22-1361f8cd58d0.png#crop=0&crop=0&crop=1&crop=1&height=190&id=hJGMp&margin=%5Bobject%20Object%5D&name=image.png&originHeight=634&originWidth=1216&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=93835&status=done&style=stroke&title=&width=365" alt="image.png"><br>相对定位的特点：（务必记住）</p><ul><li>相对于 自己原来在标准流中位置来移动的</li><li>原来<strong>在标准流的区域继续占有</strong>，后面的盒子仍然以标准流的方式对待它。</li></ul><h3 id="absolute"><a href="#absolute" class="headerlink" title="absolute"></a>absolute</h3><blockquote><p><strong>【1】绝对定位</strong>是元素以带有定位的父级元素来移动位置 （拼爹型）</p></blockquote><ul><li><strong>完全脱标</strong>：完全不占位置，完全镂空</li><li><strong>父元素没有定位：</strong>则以<strong>浏览器</strong>为准定位（Document 文档）。</li><li><strong>父元素要有定位：</strong>将元素依据最近的已经定位（绝对、固定或相对定位）的父元素（祖先）进行定位。</li><li>绝对是以带有定位的父级元素来移动位置， 如果父级都没有定位，则以浏览器文档为准移动位置</li><li>不保留原来的位置，完全是脱标的。</li></ul><blockquote><p>【2】子级元素使用绝对定位时，父级元素就要用相对定位</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611552541033-59cb288a-ccb1-4ccb-aa4c-e4550e99edf0.png#crop=0&crop=0&crop=1&crop=1&height=459&id=Nzb9x&margin=%5Bobject%20Object%5D&name=image.png&originHeight=918&originWidth=1234&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=93786&status=done&style=stroke&title=&width=617" alt="image.png"></p><blockquote><p><strong>分析</strong></p></blockquote><ul><li><strong>方向箭头</strong>叠加在其他图片上方，应该使用<strong>绝对定位</strong>，因为<strong>绝对定位完全脱标</strong>，完全不占位置。</li><li><strong>父级盒子</strong>应该使用<strong>相对定位</strong>，因为<strong>相对定位不脱标</strong>，后续盒子仍然以标准流的方式对待它。</li><li>如果父级盒子也使用<strong>绝对定位</strong>，会完全脱标，那么下方的<strong>广告盒子</strong>会上移，这显然不是我们想要的。</li></ul><h3 id="fixed"><a href="#fixed" class="headerlink" title="fixed"></a>fixed</h3><ul><li><strong>固定定位</strong>是<strong>绝对定位</strong>的一种特殊形式： （认死理型）</li><li><strong>完全脱标</strong> —— 完全不占位置；</li><li>只认<strong>浏览器的可视窗口</strong> —— <code>浏览器可视窗口 + 边偏移属性</code> 来设置元素的位置；<ul><li>跟父元素没有任何关系；单独使用的</li><li>不随滚动条滚动。<blockquote><p>案例演练：固定定位案例。</p></blockquote></li></ul></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611552558881-329f4f76-7ace-4fdd-840d-40a651c628ad.png#crop=0&crop=0&crop=1&crop=1&height=256&id=dVYeK&margin=%5Bobject%20Object%5D&name=image.png&originHeight=512&originWidth=1221&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=93480&status=done&style=stroke&title=&width=610.5" alt="image.png"><br><strong>提示</strong>：IE 6 等低版本浏览器不支持固定定位。</p><h3 id="Demo：轮播图"><a href="#Demo：轮播图" class="headerlink" title="Demo：轮播图"></a>Demo：轮播图</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616243009664-321f94d9-d92b-4503-9ff3-beaf87f2413e.png#crop=0&crop=0&crop=1&crop=1&height=272&id=RvrWd&margin=%5Bobject%20Object%5D&name=image.png&originHeight=544&originWidth=1920&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=28507&status=done&style=stroke&title=&width=960" alt="image.png"></p><blockquote><p>圆角矩形设置 4 个角</p></blockquote><ul><li>圆角矩形可以为 4 个角分别设置圆度， 但是是有顺序的</li></ul><pre><code class="css">border-top-left-radius: 20px;border-top-right-radius: 20px;border-bottom-right-radius: 20px;border-bottom-left-radius: 20px;</code></pre><ul><li>如果 4 个角，数值相同</li></ul><pre><code class="css">border-radius: 15px;</code></pre><ul><li>里面数值不同，我们也可以按照简写的形式，还是遵循的顺时针。</li></ul><pre><code class="css">border-radius: 左上角 右上角 右下角 左下角;</code></pre><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;  &lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot; /&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;    &lt;title&gt;Document&lt;/title&gt;    &lt;style&gt;      * &#123;        padding: 0;        margin: 0;      &#125;      li &#123;        list-style: none;      &#125;      .box &#123;        width: 400px;        height: 300px;        background-color: tan;        position: relative;        margin: 0 auto;      &#125;      .row_left &#123;        position: absolute;        width: 20px;        height: 30px;        top: 50%;        left: 0;        margin-top: -15px;        border: 1px darkgoldenrod solid;        line-height: 30px;        border-top-right-radius: 30px;        border-bottom-right-radius: 30px;        text-align: left;      &#125;      .row_right &#123;        position: absolute;        width: 20px;        height: 30px;        top: 50%;        right: 0;        margin-top: -15px;        border: 1px darkgoldenrod solid;        line-height: 30px;        border-top-left-radius: 30px;        border-bottom-left-radius: 30px;        text-align: right;      &#125;      .bottom_dots &#123;        position: absolute;        width: 110px;        height: 22px;        bottom: 10px;        left: 50%;        margin-left: -50px;        border: springgreen 1px solid;        border-radius: 10px;      &#125;      .row_left:hover,      .row_right:hover &#123;        background-color: yellowgreen;      &#125;      .bottom_dots li &#123;        float: left;        width: 20px;        height: 20px;        border-radius: 50%;        border: steelblue solid 1px;      &#125;      .bottom_dots .current &#123;        background-color: tomato;      &#125;    &lt;/style&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;div class=&quot;box&quot;&gt;      &lt;div class=&quot;row_left&quot;&gt;&lt;&lt;/div&gt;      &lt;div class=&quot;row_right&quot;&gt;&gt;&lt;/div&gt;      &lt;ul class=&quot;bottom_dots&quot;&gt;        &lt;li&gt;&lt;/li&gt;        &lt;li class=&quot;current&quot;&gt;&lt;/li&gt;        &lt;li&gt;&lt;/li&gt;        &lt;li&gt;&lt;/li&gt;        &lt;li&gt;&lt;/li&gt;      &lt;/ul&gt;    &lt;/div&gt;  &lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="Demo：网站右下角快捷功能"><a href="#Demo：网站右下角快捷功能" class="headerlink" title="Demo：网站右下角快捷功能"></a>Demo：网站右下角快捷功能</h3><ul><li><strong>注意</strong>：不要同时使用 <code>left</code> 和 <code>right</code> 和边偏移属性。</li><li><strong>固定定位</strong>的应用场景：<strong>固定在浏览器可视窗口某个位置的布局</strong>；</li><li>在使用固定和绝对定位时，如果盒子中没有内容，需要指定宽度，下面的例子又宽度</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616239742720-28510068-3322-4b73-ad28-8a345ba5f8c6.png#crop=0&crop=0&crop=1&crop=1&height=297&id=pTRHC&margin=%5Bobject%20Object%5D&name=image.png&originHeight=593&originWidth=1920&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=187411&status=done&style=stroke&title=&width=960" alt="image.png"></p><h2 id="定位的相关问题"><a href="#定位的相关问题" class="headerlink" title="定位的相关问题"></a>定位的相关问题</h2><h3 id="绝对定位的盒子居中"><a href="#绝对定位的盒子居中" class="headerlink" title="绝对定位的盒子居中"></a>绝对定位的盒子居中</h3><blockquote><p><strong>注意</strong>：<strong>绝对定位/固定定位的盒子</strong>不能通过设置 <code>margin: auto</code> 设置<strong>水平居中</strong>。</p></blockquote><p>在使用<strong>绝对定位</strong>时要想实现水平居中，可以按照下面的方法：</p><ol><li><code>left: 50%;</code>：让<strong>盒子的左侧</strong>移动到<strong>父级元素的水平中心位置</strong>；</li><li><code>margin-left: -100px;</code>：让盒子<strong>向左</strong>移动<strong>自身宽度的一半</strong>。</li></ol><p>整体居中如下设置<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616240730926-4415dd36-b842-4cc8-b0a2-49345b503a43.png#crop=0&crop=0&crop=1&crop=1&height=892&id=U8COT&margin=%5Bobject%20Object%5D&name=Snipaste_2021-03-20_19-44-47.png&originHeight=892&originWidth=1920&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=76602&status=done&style=stroke&title=&width=1920" alt="Snipaste_2021-03-20_19-44-47.png"></p><h3 id="z-index"><a href="#z-index" class="headerlink" title="z-index"></a>z-index</h3><ul><li>在使用<strong>定位</strong>布局时，可能会<strong>出现盒子重叠的情况</strong>。</li><li>加了定位的盒子，默认<strong>后来者居上</strong>， 后面的盒子会压住前面的盒子。</li><li>应用 <code>z-index</code> 层叠等级属性可以<strong>调整盒子的堆叠顺序</strong>。如下图所示：</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611552609219-135cc13d-9a4e-411e-bac1-3b3fcad55d5e.png#crop=0&crop=0&crop=1&crop=1&height=186&id=FpYQs&margin=%5Bobject%20Object%5D&name=image.png&originHeight=371&originWidth=1245&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=36112&status=done&style=stroke&title=&width=622.5" alt="image.png"></p><blockquote><p><code>z-index</code> 的特性如下：</p></blockquote><ul><li><strong>属性值</strong>：<strong>正整数</strong>、<strong>负整数</strong>或 <strong>0</strong>，默认值是 0，数值越大，盒子越靠上；</li><li>如果<strong>属性值相同</strong>，则按照书写顺序，<strong>后来居上</strong>；</li><li><strong>数字后面不能加单位</strong>。</li><li><strong>注意</strong>：<code>z-index</code> 只能应用于<strong>相对定位</strong>、<strong>绝对定位</strong>和<strong>固定定位</strong>的元素，其他<strong>标准流</strong>、<strong>浮动</strong>和<strong>静态定位</strong>无效。</li></ul><h3 id="定位改变-display-属性"><a href="#定位改变-display-属性" class="headerlink" title="定位改变 display 属性"></a>定位改变 display 属性</h3><p>前面我们讲过，display 是显示模式，可以改变显示模式有以下方式:</p><ul><li>可以用 inline-block 转换为行内块</li><li>可以用浮动 float 默认转换为行内块（类似，并不完全一样，因为浮动是脱标的）</li><li>绝对定位和固定定位也和浮动类似， 默认转换的特性转换为行内块。</li></ul><p>所以说， 一个行内的盒子，如果加了<strong>浮动</strong>、<strong>固定定位</strong>和<strong>绝对定位</strong>，不用转换，就可以给这个盒子直接设置宽度和高度等。</p><blockquote><p><strong>同时注意：</strong></p></blockquote><p>浮动元素、绝对定位(固定定位）元素的都不会触发外边距合并的问题。 （我们以前是用 padding border overflow 解决的）<br>也就是说，我们给盒子改为了浮动或者定位，就不会有垂直外边距合并的问题了。</p>]]></content>
      
      
      <categories>
          
          <category> 👨‍💻Web开发 </category>
          
          <category> HTML+CSS </category>
          
          <category> 布局 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CSS浮动</title>
      <link href="/blog/vgixv5vex3i8/"/>
      <url>/blog/vgixv5vex3i8/</url>
      
        <content type="html"><![CDATA[<h2 id="浮动详解"><a href="#浮动详解" class="headerlink" title="浮动详解"></a>浮动详解</h2><h3 id="为什么需要浮动"><a href="#为什么需要浮动" class="headerlink" title="为什么需要浮动"></a>为什么需要浮动</h3><ul><li><p>多个盒子(div)水平排列成一行</p></li><li><p>实现盒子的左右对齐</p></li><li><p>行内块（inline-block）它可以实现多个元素一行显示，但是中间会有空白缝隙，不能满足以上第一个问题。</p></li><li><p>行内块（inline-block）不能实现以上第二个问题，盒子左右对齐</p></li></ul><h3 id="浮动特点"><a href="#浮动特点" class="headerlink" title="浮动特点"></a>浮动特点</h3><blockquote><p><strong>概念</strong>：元素的浮动是指<strong>设置了浮动属性的元素</strong>会</p></blockquote><ul><li><p>脱离标准普通流的控制</p></li><li><p>移动到指定位置</p><blockquote><p>作用</p></blockquote></li><li><p><strong>让多个盒子(div)水平排列成一行</strong>，使得浮动成为布局的重要手段。</p></li><li><p>可以实现盒子的左右对齐等等..</p></li><li><p>浮动最早是用来<strong>控制图片</strong>，实现<strong>文字环绕图片的效果</strong>。</p><blockquote><p>语法</p></blockquote></li></ul><pre><code class="css">选择器 &#123;  float: 属性值;&#125;</code></pre><table><thead><tr><th>属性值</th><th>描述</th></tr></thead><tbody><tr><td><strong>none</strong></td><td>元素不浮动（<strong>默认值</strong>）</td></tr><tr><td><strong>left</strong></td><td>元素向<strong>左</strong>浮动</td></tr><tr><td><strong>right</strong></td><td>元素向<strong>右</strong>浮动</td></tr></tbody></table><blockquote><p>特点 1：浮</p></blockquote><ul><li>浮动——浮浮~~~漂浮在普通流的上面。 脱离标准流。 俗称 “脱标”</li><li><code>float</code> 属性会让盒子漂浮在标准流的上面，所以第二个标准流的盒子跑到浮动盒子的底下了。</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616233538999-0a7d098b-a897-491c-b25c-36f34eb7b193.png#align=left&display=inline&height=440&margin=%5Bobject%20Object%5D&name=image.png&originHeight=880&originWidth=1920&size=139927&status=done&style=stroke&width=960" alt="image.png"></p><ul><li><p>上图问题 1 处出现文字被撑开的情况，似乎和预想的有一丢丢的不尽如意，原因是对于文本和行内元素来说依然是占用空间的</p><blockquote><p>特点 2：漏</p></blockquote></li><li><p>浮动——漏漏~ 浮动的盒子，把自己原来的位置漏给下面标准流的盒子，就是不占有原来位置，是脱离标准流的，我们俗称 “脱标”。</p><blockquote><p>特点 3：特</p></blockquote></li><li><p>浮动——特性 float 属性会改变元素 display 属性。</p></li><li><p>任何元素都可以浮动。浮动元素会生成一个块级框，而不论它本身是何种元素。 生成的块级框和我们前面的行内块极其相似，所以出现了上面浮里面的例子当中父元素里面的文字被撑开的情况</p></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616234017630-4391a0b4-6214-42ba-a1f2-cd44c1a99f94.png#align=left&display=inline&height=330&margin=%5Bobject%20Object%5D&name=image.png&originHeight=660&originWidth=1920&size=116474&status=done&style=stroke&width=960" alt="image.png"></p><ul><li>**浮动的元素互相贴靠一起的，但是如果父级宽度装不下这些浮动的盒子， ****多出的盒子会另起一行对齐**</li></ul><h3 id="Demo：浮动-标准流的布局"><a href="#Demo：浮动-标准流的布局" class="headerlink" title="Demo：浮动+标准流的布局"></a>Demo：浮动+标准流的布局</h3><blockquote><p>浮动和标准流的父盒子搭配</p></blockquote><p>我们知道，浮动是脱标的，会影响下面的标准流元素，此时，我们需要给浮动的元素添加一个标准流的父亲，这样，最大化的减小了对其他标准流的影响。**<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616236830103-21860906-bc1f-48a8-8fb1-a5011f02a551.png#align=left&display=inline&height=334&margin=%5Bobject%20Object%5D&name=image.png&originHeight=667&originWidth=1920&size=71026&status=done&style=stroke&width=960" alt="image.png"></p><h2 id="浮动的相关问题"><a href="#浮动的相关问题" class="headerlink" title="浮动的相关问题"></a>浮动的相关问题</h2><h3 id="浮动元素与父盒子的关系"><a href="#浮动元素与父盒子的关系" class="headerlink" title="浮动元素与父盒子的关系"></a>浮动元素与父盒子的关系</h3><ul><li>子盒子的浮动参照父盒子对齐</li><li>不会与父盒子的边框重叠，也不会超过父盒子的内边距</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616237499108-fe82abe6-42c1-4f37-ad68-d45c3f78cd11.png#align=left&display=inline&height=152&margin=%5Bobject%20Object%5D&name=image.png&originHeight=303&originWidth=1920&size=33264&status=done&style=stroke&width=960" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616237548311-79fb762c-6f7d-45c0-b316-14a12ba92098.png#align=left&display=inline&height=90&margin=%5Bobject%20Object%5D&name=image.png&originHeight=179&originWidth=1920&size=8431&status=done&style=stroke&width=960" alt="image.png"></p><h3 id="浮动元素与兄弟盒子的关系"><a href="#浮动元素与兄弟盒子的关系" class="headerlink" title="浮动元素与兄弟盒子的关系"></a>浮动元素与兄弟盒子的关系</h3><p>在一个父级盒子中，如果<strong>前一个兄弟盒子</strong>是：</p><ul><li><strong>浮动</strong>的，那么<strong>当前盒子</strong>会与前一个盒子的顶部对齐；</li><li><strong>普通流</strong>的，那么<strong>当前盒子</strong>会显示在前一个兄弟盒子的下方。</li><li>浮动只会影响当前的或者是后面的标准流盒子，不会影响前面的标准流。</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2021/jpg/1484158/1611549557830-9fdd5350-af70-4793-8dba-cc3c06214b72.jpg#align=left&display=inline&height=553&margin=%5Bobject%20Object%5D&originHeight=553&originWidth=486&status=done&style=stroke&width=486"></p><ul><li><strong>如果一个盒子里面有多个子盒子，如果其中一个盒子浮动了，其他兄弟也应该浮动。防止引起问题</strong></li></ul><h3 id="为什么要清除浮动"><a href="#为什么要清除浮动" class="headerlink" title="为什么要清除浮动"></a>为什么要清除浮动</h3><ul><li>因为父级盒子很多情况下，不方便给高度，但是子盒子浮动就不占有位置，最后父级盒子高度为 0，就影响了下面的标准流盒子</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616238120449-097b5efe-31ea-43f9-b393-4e64e9836530.png#align=left&display=inline&height=135&margin=%5Bobject%20Object%5D&name=image.png&originHeight=270&originWidth=1920&size=32856&status=done&style=stroke&width=960" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616238209810-a8b31f63-37b3-4289-a691-e52ab55f8203.png#align=left&display=inline&height=101&margin=%5Bobject%20Object%5D&name=image.png&originHeight=201&originWidth=1920&size=20171&status=done&style=stroke&width=960" alt="image.png"></p><ul><li>总结：由于浮动元素不再占用原文档流的位置，所以它会对后面的元素排版产生影响，准确地说，并不是清除浮动，而是<strong>清除浮动后造成的影响</strong></li><li><strong>所以还是最好利用一个标准流为父盒子，里面套数个浮动盒子最为好用</strong><blockquote><p><strong>清除浮动本质：</strong> &gt; <strong>清除浮动主要为了解决父级元素因为子级浮动引起内部高度为 0 的问题</strong>&gt; <strong>。清除浮动之后， 父级就会根据浮动的子盒子自动检测高度。父级有了高度，就不会影响下面的标准流了</strong></p></blockquote></li></ul><h3 id="清除浮动的方法"><a href="#清除浮动的方法" class="headerlink" title="清除浮动的方法"></a>清除浮动的方法</h3><ul><li>clear 属性用于清除浮动<table><thead><tr><th>属性值</th><th>描述</th></tr></thead><tbody><tr><td>left</td><td>不允许左侧有浮动元素（清除左侧浮动的影响）</td></tr><tr><td>right</td><td>不允许右侧有浮动元素（清除右侧浮动的影响）</td></tr><tr><td>both</td><td>同时清除左右两侧浮动的影响</td></tr></tbody></table></li></ul><h4 id="clear-both"><a href="#clear-both" class="headerlink" title="clear:both"></a>clear:both</h4><p>是 W3C 推荐的做法是通过在浮动元素末尾添加一个空的标签例如 <code>&lt;div style=”clear:both”&gt;&lt;/div&gt;</code>，或则其他标签 br 等亦可。</p><ul><li>优点： 通俗易懂，书写方便</li><li>缺点： 添加许多无意义的标签，结构化较差。</li></ul><h4 id="overflow-hidden"><a href="#overflow-hidden" class="headerlink" title="overflow: hidden;"></a>overflow: hidden;</h4><p>可以给父级添加： overflow 为 hidden| auto| scroll   都可以实现。</p><ul><li>优点： 代码简洁</li><li>缺点： 内容增多时候容易造成不会自动换行导致内容被隐藏掉，无法显示需要溢出的元素。</li></ul><h4 id="使用-after-伪元素清除浮动"><a href="#使用-after-伪元素清除浮动" class="headerlink" title="使用 after 伪元素清除浮动"></a>使用 after 伪元素清除浮动</h4><blockquote><p><strong>:after 方式为空元素额外标签法的升级版，好处是不用单独加标签了</strong></p></blockquote><pre><code class="css">.clearfix:after &#123;  content: &quot;&quot;;  display: block;  height: 0;  clear: both;  visibility: hidden;&#125;.clearfix &#123;  *zoom: 1;&#125; /* IE6、7 专有 */</code></pre><ul><li>优点： 符合闭合浮动思想 结构语义化正确</li><li>缺点： 由于 IE6-7 不支持:after，使用 zoom:1 触发 hasLayout。</li><li>代表网站： 百度、淘宝网、网易等</li></ul><h4 id="使用双伪元素清除浮动"><a href="#使用双伪元素清除浮动" class="headerlink" title="使用双伪元素清除浮动"></a>使用双伪元素清除浮动</h4><pre><code class="css">.clearfix:before,.clearfix:after &#123;  content: &quot;&quot;;  display: table;&#125;.clearfix:after &#123;  clear: both;&#125;.clearfix &#123;  *zoom: 1;&#125;</code></pre><ul><li><p>优点： 代码更简洁</p></li><li><p>缺点： 由于 IE6-7 不支持:after，使用 zoom:1 触发 hasLayout。</p></li><li><p>代表网站： 小米、腾讯等</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 👨‍💻Web开发 </category>
          
          <category> HTML+CSS </category>
          
          <category> 布局 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CSS盒模型</title>
      <link href="/blog/dnp4byvzqz87/"/>
      <url>/blog/dnp4byvzqz87/</url>
      
        <content type="html"><![CDATA[<h2 id="border"><a href="#border" class="headerlink" title="border"></a>border</h2><h3 id="border-综合"><a href="#border-综合" class="headerlink" title="border 综合"></a>border 综合</h3><table><thead><tr><th>属性</th><th align="center">作用</th></tr></thead><tbody><tr><td>border-width</td><td align="center">定义边框粗细，单位是 px</td></tr><tr><td>border-style</td><td align="center">边框的样式</td></tr><tr><td>border-color</td><td align="center">边框颜色</td></tr></tbody></table><blockquote><p>【1】border-style</p></blockquote><ul><li>none：没有边框即忽略所有边框的宽度（默认值）</li><li>solid：边框为单实线(最为常用的)</li><li>dashed：边框为虚线</li><li>dotted：边框为点线<blockquote><p>【2】综合设置：盒子边框写法总结表</p></blockquote></li></ul><pre><code class="css">border: 1px solid red;</code></pre><blockquote><p>【3】很多情况下，我们不需要指定 4 个边框，我们是可以单独给 4 个边框分别指定的。</p></blockquote><table><thead><tr><th align="left">上边框</th><th align="left">下边框</th><th align="left">左边框</th><th align="left">右边框</th></tr></thead><tbody><tr><td align="left">border-top-style:样式;</td><td align="left">border-bottom-style:样式;</td><td align="left">border-left-style:样式;</td><td align="left">border-right-style:样式;</td></tr><tr><td align="left">border-top-width:宽度;</td><td align="left">border- bottom-width:宽度;</td><td align="left">border-left-width:宽度;</td><td align="left">border-right-width:宽度;</td></tr><tr><td align="left">border-top-color:颜色;</td><td align="left">border- bottom-color:颜色;</td><td align="left">border-left-color:颜色;</td><td align="left">border-right-color:颜色;</td></tr><tr><td align="left">border-top:宽度 样式 颜色;</td><td align="left">border-bottom:宽度 样式 颜色;</td><td align="left">border-left:宽度 样式 颜色;</td><td align="left">border-right:宽度 样式 颜色;</td></tr></tbody></table><blockquote><p>表格的细线边框</p></blockquote><ul><li><p>通过表格的<code>cellspacing=&quot;0&quot;</code>,将单元格与单元格之间的距离设置为 0，</p></li><li><p>但是两个单元格之间的边框会出现重叠，从而使边框变粗</p></li><li><p>通过 css 属性：</p></li></ul><pre><code>table&#123; border-collapse:collapse; &#125;</code></pre><ul><li>collapse 单词是合并的意思</li><li>border-collapse:collapse; 表示相邻边框合并在一起。</li></ul><pre><code class="css">&lt;style&gt;    table &#123;        width: 500px;        height: 300px;        border: 1px solid red;    &#125;    td &#123;        border: 1px solid red;        text-align: center;    &#125;    table, td &#123;        border-collapse: collapse;  /*合并相邻边框*/    &#125;&lt;/style&gt;</code></pre><h3 id="border-radius"><a href="#border-radius" class="headerlink" title="border-radius"></a>border-radius</h3><ul><li>语法：</li></ul><pre><code class="css">border-radius: length;</code></pre><ul><li><p>其中每一个值可以为 数值或百分比的形式。</p></li><li><p>让一个正方形（让这个盒子 width 和 height 相等）变成圆圈</p></li></ul><pre><code class="css">border-radius: 50%;</code></pre><ul><li>百分比会是表示高度和宽度的一半的情况</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616160100879-1ec56967-ea20-4bd2-8327-519c75d1367f.png#align=left&display=inline&height=345&margin=%5Bobject%20Object%5D&name=image.png&originHeight=689&originWidth=1920&size=1162765&status=done&style=stroke&width=960" alt="image.png"></p><h3 id="box-shadow"><a href="#box-shadow" class="headerlink" title="box-shadow"></a>box-shadow</h3><ul><li>语法:</li></ul><pre><code class="css">box-shadow: 水平阴影 垂直阴影 模糊距离（虚实） 阴影尺寸（影子大小） 阴影颜色  内/外阴影；;</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611549557136-9945210f-61eb-44df-af61-5eb070818e6f.png#align=left&display=inline&height=306&margin=%5Bobject%20Object%5D&originHeight=306&originWidth=862&status=done&style=stroke&width=862"></p><ul><li>前两个属性是必须写的。其余的可以省略。</li><li>外阴影 (outset) 是默认的 但是不能写 想要内阴影可以写 inset</li></ul><h2 id="padding"><a href="#padding" class="headerlink" title="padding"></a>padding</h2><blockquote><p>内边距：padding 属性用于设置内边距。 <strong>是指 边框与内容之间的距离。</strong></p></blockquote><h3 id="padding-综合"><a href="#padding-综合" class="headerlink" title="padding 综合"></a>padding 综合</h3><table><thead><tr><th>属性</th><th align="left">作用</th></tr></thead><tbody><tr><td>padding-left</td><td align="left">左内边距</td></tr><tr><td>padding-right</td><td align="left">右内边距</td></tr><tr><td>padding-top</td><td align="left">上内边距</td></tr><tr><td>padding-bottom</td><td align="left">下内边距</td></tr></tbody></table><p>当我们给盒子指定 padding 值之后， 发生了 2 件事情：</p><ol><li>内容和边框 有了距离，添加了内边距。</li><li>盒子会变大了。</li></ol><p><strong>注意： 后面跟几个数值表示的意思是不一样的。</strong><br>我们分开写有点麻烦，我们可以不可以简写呢？</p><table><thead><tr><th>值的个数</th><th>表达意思</th></tr></thead><tbody><tr><td>1 个值</td><td>padding：上下左右内边距;</td></tr><tr><td>2 个值</td><td>padding: 上下内边距 左右内边距 ；</td></tr><tr><td>3 个值</td><td>padding：上内边距 左右内边距 下内边距；</td></tr><tr><td>4 个值</td><td>padding: 上内边距 右内边距 下内边距 左内边距 ；</td></tr></tbody></table><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611552112041-a7ed9154-18bb-478e-867f-92e7837719ea.png#align=left&display=inline&height=152&margin=%5Bobject%20Object%5D&name=image.png&originHeight=303&originWidth=409&size=41892&status=done&style=stroke&width=204.5" alt="image.png">**</p><h3 id="内盒尺寸计算（元素实际大小）"><a href="#内盒尺寸计算（元素实际大小）" class="headerlink" title="内盒尺寸计算（元素实际大小）"></a>内盒尺寸计算（元素实际大小）</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611552122666-74470517-33eb-4212-b483-430e2bbd0ee5.png#align=left&display=inline&height=154&margin=%5Bobject%20Object%5D&name=image.png&originHeight=308&originWidth=347&size=26383&status=done&style=stroke&width=173.5" alt="image.png"></p><ul><li><p>宽度：Element Height = content height + padding + border （Height 为内容高度）</p></li><li><p>高度：Element Width = content width + padding + border （Width 为内容宽度）</p></li><li><p>盒子的实际的大小 = 内容的宽度和高度 + 内边距 + 边框</p></li></ul><h3 id="内边距撑大盒子的解决方案"><a href="#内边距撑大盒子的解决方案" class="headerlink" title="内边距撑大盒子的解决方案"></a>内边距撑大盒子的解决方案</h3><blockquote><p>问题：会撑大原来的盒子</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611552148703-03f4e9a2-62c0-4ef6-bcc9-daca7a48972f.png#align=left&display=inline&height=187&margin=%5Bobject%20Object%5D&name=image.png&originHeight=602&originWidth=1127&size=112122&status=done&style=stroke&width=350" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611552164629-96bb4847-362e-4c50-ad11-9bf86c3cd22e.png#align=left&display=inline&height=213&margin=%5Bobject%20Object%5D&name=image.png&originHeight=715&originWidth=1186&size=132784&status=done&style=stroke&width=353" alt="image.png"></p><blockquote><p>解决方案【1】：通过给设置了宽高的盒子，减去相应的内边距的值，维持盒子原有的大小</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611552179527-c1060669-e26e-4c16-b0eb-0fa78c03b45b.png#align=left&display=inline&height=215&margin=%5Bobject%20Object%5D&name=image.png&originHeight=610&originWidth=1113&size=111733&status=done&style=stroke&width=393" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611552188919-c9493a98-9f8f-4ba4-942c-83d9fd2a033f.png#align=left&display=inline&height=238&margin=%5Bobject%20Object%5D&name=image.png&originHeight=687&originWidth=1145&size=127523&status=done&style=stroke&width=397" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611552197848-242d4e3f-1cdd-4f31-b86b-e42b549e2094.png#align=left&display=inline&height=223&margin=%5Bobject%20Object%5D&name=image.png&originHeight=667&originWidth=1189&size=128129&status=done&style=stroke&width=397" alt="image.png"><br>关于根据下列代码计算 盒子宽高下列说法正确的是（）</p><pre><code class="css">div &#123;  width: 200px;  height: 200px;  border: 1px solid #000000;  border-top: 5px solid blue;  padding: 50px;  padding-left: 100px;&#125;</code></pre><ul><li>(A) 宽度为 200px 高度为 200px</li><li>(B) 宽度为 352px 高度为 306px</li><li>(C) 宽度为 302px 高度为 307px</li><li>(D) 宽度为 302px 高度为 252px</li></ul><p>w 200 + 150 + 2 = 352<br>h 200 + 100 + 6 = 306</p><blockquote><p>解决方案【2】：设置 box-sizing 属性</p></blockquote><pre><code class="css">-moz-box-sizing: border-box; /*Firefox3.5+*/-webkit-box-sizing: border-box; /*Safari3.2+*/-o-box-sizing: border-box; /*Opera9.6*/-ms-box-sizing: border-box; /*IE8*/box-sizing: border-box; /*W3C标准(IE9+，Safari5.1+,Chrome10.0+,Opera10.6+都符合box-sizing的w3c标准语法)*/</code></pre><p>注意：box-sizing 属性是 CSS3 的属性，IE 低版本不支持，注意兼容性<br>参考：</p><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/box-sizing">https://developer.mozilla.org/zh-CN/docs/Web/CSS/box-sizing</a></li><li><a href="https://www.zhihu.com/question/31031251">https://www.zhihu.com/question/31031251</a></li></ul><h3 id="内边距不影响盒子大小情况"><a href="#内边距不影响盒子大小情况" class="headerlink" title="内边距不影响盒子大小情况"></a>内边距不影响盒子大小情况</h3><blockquote><p>如果没有给一个盒子指定宽度， 此时，如果给这个盒子指定 padding， 则不会撑开盒子。</p></blockquote><h2 id="margin"><a href="#margin" class="headerlink" title="margin"></a>margin</h2><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611552211186-1bc52b3c-f2d9-418b-99d8-582718465af1.png#align=left&display=inline&height=250&margin=%5Bobject%20Object%5D&name=image.png&originHeight=500&originWidth=950&size=49287&status=done&style=stroke&width=475" alt="image.png"><br>margin 属性用于设置外边距。 margin 就是控制<strong>盒子和盒子之间的距离</strong></p><h3 id="padding-综合-1"><a href="#padding-综合-1" class="headerlink" title="padding 综合"></a>padding 综合</h3><table><thead><tr><th>属性</th><th align="left">作用</th></tr></thead><tbody><tr><td>margin-left</td><td align="left">左外边距</td></tr><tr><td>margin-right</td><td align="left">右外边距</td></tr><tr><td>margin-top</td><td align="left">上外边距</td></tr><tr><td>margin-bottom</td><td align="left">下外边距</td></tr></tbody></table><p>margin 值的简写 （复合写法）代表意思 跟 padding 完全相同。</p><h2 id="display"><a href="#display" class="headerlink" title="display"></a>display</h2><h3 id="什么是标签显示模式"><a href="#什么是标签显示模式" class="headerlink" title="什么是标签显示模式"></a>什么是标签显示模式</h3><ul><li><p>什么是标签的显示模式？<br>标签以什么方式进行显示，比如 div 自己占一行， 比如 span 一行可以放很多个</p></li><li><p>作用：<br>我们网页的标签非常多，再不同地方会用到不同类型的标签，以便更好的完成我们的网页。</p></li><li><p>标签的类型(分类)<br>HTML 标签一般分为块标签和行内标签两种类型，它们也称块元素和行内元素。</p></li></ul><h3 id="块级元素-block-level"><a href="#块级元素-block-level" class="headerlink" title="块级元素(block-level)"></a>块级元素(block-level)</h3><ul><li>例：</li></ul><pre><code>常见的块元素有&lt;h1&gt;~&lt;h6&gt;、&lt;p&gt;、&lt;div&gt;、&lt;ul&gt;、&lt;ol&gt;、&lt;li&gt;等，其中&lt;div&gt;标签是最典型的块元素。</code></pre><ul><li>块级元素的特点</li></ul><p>（1）比较霸道，自己独占一行<br>（2）高度，宽度、外边距以及内边距都可以控制。<br>（3）宽度默认是容器（父级宽度）的 100%<br>（4）是一个容器及盒子，里面可以放行内或者块级元素。</p><ul><li>只有 文字才 能组成段落 因此 p 里面不能放块级元素，特别是 p 不能放 div</li><li>同理还有这些标签 h1,h2,h3,h4,h5,h6,dt，他们都是文字类块级标签，里面不能放其他块级元素。</li></ul><h3 id="行内元素-inline-level"><a href="#行内元素-inline-level" class="headerlink" title="行内元素(inline-level)"></a>行内元素(inline-level)</h3><ul><li>例：</li></ul><pre><code>常见的行内元素有&lt;a&gt;、&lt;strong&gt;、&lt;b&gt;、&lt;em&gt;、&lt;i&gt;、&lt;del&gt;、&lt;s&gt;、&lt;ins&gt;、&lt;u&gt;、&lt;span&gt;等，其中&lt;span&gt;标签最典型的行内元素。有的地方也成内联元素</code></pre><ul><li>行内元素的特点：</li></ul><p>（1）相邻行内元素在一行上，一行可以显示多个。<br>（2）高、宽直接设置是无效的。<br>（3）默认宽度就是它本身内容的宽度。<br>（4）<strong>行内元素只能容纳文本或则其他行内元素。</strong></p><ul><li>链接里面不能再放链接。</li><li>特殊情况 a 里面可以放块级元素，但是给 a 转换一下块级模式最安全。</li></ul><h3 id="行内块元素（inline-block）"><a href="#行内块元素（inline-block）" class="headerlink" title="行内块元素（inline-block）"></a>行内块元素（inline-block）</h3><ul><li>例：</li></ul><pre><code>在行内元素中有几个特殊的标签——&lt;img /&gt;、&lt;input /&gt;、&lt;td&gt;，可以对它们设置宽高和对齐属性，有些资料可能会称它们为行内块元素。</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611551937533-f958d872-1942-4aee-8533-8671afa1dc82.png#align=left&display=inline&height=258&margin=%5Bobject%20Object%5D&name=image.png&originHeight=515&originWidth=1217&size=75676&status=done&style=stroke&width=608.5" alt="image.png"></p><ul><li>行内块元素的特点：<br>（1）和相邻行内元素（行内块）在一行上,但是之间会有空白缝隙。一行可以显示多个<br>（2）默认宽度就是它本身内容的宽度。<br>（3）高度，行高、外边距以及内边距都可以控制。</li></ul><h3 id="display-1"><a href="#display-1" class="headerlink" title="display"></a>display</h3><ul><li>块转行内：display:inline;</li><li>行内转块：display:block;</li><li>块、行内元素转换为行内块： display: inline-block;</li></ul><p>此阶段，我们只需关心这三个，其他的是我们后面的工作。</p><h2 id="盒模型的相关问题"><a href="#盒模型的相关问题" class="headerlink" title="盒模型的相关问题"></a>盒模型的相关问题</h2><h3 id="块级盒子水平居中"><a href="#块级盒子水平居中" class="headerlink" title="块级盒子水平居中"></a>块级盒子水平居中</h3><ul><li>一个块级盒子实现水平居中必须：<ul><li>盒子必须指定了宽度（width）</li><li>然后就给<strong>左右的外边距都设置为 auto</strong>，</li></ul></li></ul><p>实际工作中常用这种方式进行网页布局，示例代码如下：</p><pre><code class="css">.header &#123;  width: 960px;  margin: 0 auto;&#125;</code></pre><p>常见的写法，以下下三种都可以。</p><ul><li>margin-left: auto; margin-right: auto;</li><li>margin: auto;</li><li>margin: 0 auto;</li></ul><h3 id="文字居中和盒子居中区别"><a href="#文字居中和盒子居中区别" class="headerlink" title="文字居中和盒子居中区别"></a>文字居中和盒子居中区别</h3><ol><li>盒子内的文字水平居中是 text-align: center, 而且还可以让行内元素和行内块居中对齐</li><li>块级盒子水平居中左右 margin 改为 auto</li></ol><pre><code class="css">text-align: center; /*  文字 行内元素 行内块元素水平居中 */margin: 10px auto; /* 块级盒子水平居中  左右margin 改为 auto 就阔以了 上下margin都可以 */</code></pre><h3 id="插入图片和背景图片区别"><a href="#插入图片和背景图片区别" class="headerlink" title="插入图片和背景图片区别"></a>插入图片和背景图片区别</h3><ol><li>插入图片 我们用的最多 比如产品展示类 移动位置只能靠盒模型 padding margin</li><li>背景图片我们一般用于小图标背景 或者 超大背景图片 背景图片 只能通过 background-position</li></ol><pre><code class="css">img &#123;  width: 200px; /* 插入图片更改大小 width 和 height */  height: 210px;  margin-top: 30px; /* 插入图片更改位置 可以用margin 或padding  盒模型 */  margin-left: 50px; /* 插入当图片也是一个盒子 */&#125;div &#123;  width: 400px;  height: 400px;  border: 1px solid purple;  background: #fff url(images/sun.jpg) no-repeat;  background-position: 30px 50px; /* 背景图片更改位置 我用 background-position */&#125;</code></pre><h3 id="清除元素的默认内外边距"><a href="#清除元素的默认内外边距" class="headerlink" title="清除元素的默认内外边距"></a>清除元素的默认内外边距</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611552224242-7158d827-f872-4872-9c9d-598c846d74b9.png#align=left&display=inline&height=178&margin=%5Bobject%20Object%5D&name=image.png&originHeight=355&originWidth=1075&size=48809&status=done&style=stroke&width=537.5" alt="image.png"><br>为了更灵活方便地控制网页中的元素，制作网页时，我们需要将元素的默认内外边距清除<br>代码：</p><pre><code class="css">* &#123;  padding: 0; /* 清除内边距 */  margin: 0; /* 清除外边距 */&#125;</code></pre><ul><li>行内元素为了照顾兼容性， 尽量只设置左右内外边距， 不要设置上下内外边距。</li></ul><h3 id="margin-塌陷问题"><a href="#margin-塌陷问题" class="headerlink" title="margin 塌陷问题"></a>margin 塌陷问题</h3><p>使用 margin 定义块元素的<strong>垂直外边距</strong>时，可能会出现外边距的合并。</p><blockquote><p>相邻块元素垂直外边距的合并</p></blockquote><ul><li>当上下相邻的两个块元素相遇时，如果上面的元素有下外边距 margin-bottom</li><li>下面的元素有上外边距 margin-top，则他们之间的垂直间距不是 margin-bottom 与 margin-top 之和</li><li><strong>取两个值中的较大者</strong>这种现象被称为相邻块元素垂直外边距的合并（也称外边距塌陷）。</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611549556832-735ecd9b-2e20-4413-a635-cedc3692442f.png#align=left&display=inline&height=309&margin=%5Bobject%20Object%5D&originHeight=309&originWidth=504&status=done&style=stroke&width=504"><br>**解决方案：****尽量给只给一个盒子添加 margin 值**。</p><blockquote><p>嵌套块元素垂直外边距的合并（塌陷）</p></blockquote><ul><li>对于两个嵌套关系的块元素，如果父元素没有上内边距及边框</li><li>父元素的上外边距会与子元素的上外边距发生合并</li><li>合并后的外边距为两者中的较大者</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611549556894-4dc0bcd3-d5ed-467c-b725-bf4477a4e93c.png#align=left&display=inline&height=195&margin=%5Bobject%20Object%5D&originHeight=195&originWidth=504&status=done&style=stroke&width=504"><br><strong>解决方案：</strong></p><ol><li>可以为父元素定义上边框。</li><li>可以为父元素定义上内边距</li><li>可以为父元素添加 overflow:hidden。</li></ol><p>还有其他方法，比如浮动、固定、绝对定位的盒子不会有问题，后面咱们再总结。。。</p><h3 id="盒子模型布局稳定性"><a href="#盒子模型布局稳定性" class="headerlink" title="盒子模型布局稳定性"></a>盒子模型布局稳定性</h3><ul><li>根据稳定性来分：按照 优先使用 宽度 （width） 其次 使用内边距（padding） 再次 外边距（margin）。</li><li>margin 会有外边距合并 还有 ie6 下面 margin 加倍的 bug（讨厌）所以最后使用。</li><li>padding 会影响盒子大小， 需要进行加减计算（麻烦） 其次使用。</li><li>width 没有问题，经常使用宽度剩余法 高度剩余法来做。</li></ul><h3 id="line-height-的问题"><a href="#line-height-的问题" class="headerlink" title="line-height 的问题"></a>line-height 的问题</h3><blockquote><p>【1】行高测量</p></blockquote><p>行高的测量方法：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611549555568-b660d3a6-0153-453f-ae22-fc831f79d659.png#align=left&display=inline&height=183&margin=%5Bobject%20Object%5D&originHeight=291&originWidth=648&status=done&style=stroke&width=407"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611549555629-ba0bce7a-f7b1-49ff-89aa-c14496ccbcb6.png#align=left&display=inline&height=148&margin=%5Bobject%20Object%5D&originHeight=291&originWidth=800&status=done&style=stroke&width=408"></p><blockquote><p>【2】单行文本垂直居中</p></blockquote><p>行高我们利用最多的一个地方是： 可以让单行文本在盒子中垂直居中对齐。</p><blockquote><p><strong>文字的行高等于盒子的高度。</strong></p></blockquote><p>这里情况些许复杂，开始学习，我们可以先从简单地方入手学会。<br>行高 = 上距离 + 内容高度 + 下距离<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611549555695-02bf584b-9ece-45fe-a081-52aaf565d20d.png#align=left&display=inline&height=312&margin=%5Bobject%20Object%5D&originHeight=174&originWidth=391&status=done&style=stroke&width=700"><br>上距离和下距离总是相等的，因此文字看上去是垂直居中的。<br><strong>行高和高度的三种关系</strong></p><ul><li>如果 行高 等 高度 文字会 垂直居中</li><li>如果行高 大于 高度 文字会 偏下</li><li>如果行高小于高度 文字会 偏上</li></ul><h3 id=""><a href="#" class="headerlink" title=""></a></h3>]]></content>
      
      
      <categories>
          
          <category> 👨‍💻Web开发 </category>
          
          <category> HTML+CSS </category>
          
          <category> 布局 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CSS字体和背景</title>
      <link href="/blog/sideak09lpko/"/>
      <url>/blog/sideak09lpko/</url>
      
        <content type="html"><![CDATA[<h2 id="字体相关"><a href="#字体相关" class="headerlink" title="字体相关"></a>字体相关</h2><h3 id="font-size"><a href="#font-size" class="headerlink" title="font-size"></a>font-size</h3><ul><li>作用：<br>font-size 属性用于设置字号</li></ul><pre><code class="css">p &#123;  font-size: 20px;&#125;</code></pre><ul><li>单位：<ul><li>可以使用相对长度单位，也可以使用绝对长度单位。</li><li>相对长度单位比较常用，推荐使用像素单位 px，绝对长度单位使用较少。</li></ul></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611549554219-97b92fc6-0b55-4946-a903-080b2dfa44fa.png#align=left&display=inline&height=308&margin=%5Bobject%20Object%5D&originHeight=308&originWidth=637&status=done&style=stroke&width=637"><br><strong>注意：</strong></p><ul><li>我们文字大小以后，基本就用 px 了，其他单位很少使用</li><li>谷歌浏览器默认的文字大小为 16px</li><li>但是不同浏览器可能默认显示的字号大小不一致，我们尽量给一个明确值大小，不要默认大小。一般给 body 指定整个页面文字的大小</li></ul><h3 id="font-family"><a href="#font-family" class="headerlink" title="font-family"></a>font-family</h3><pre><code>p&#123; font-family:&quot;微软雅黑&quot;;&#125;</code></pre><ul><li>网页中常用的字体有宋体、微软雅黑、黑体等，例如将网页中所有段落文本的字体设置为微软雅黑</li><li>可以同时指定多个字体，中间以逗号隔开，表示如果浏览器不支持第一个字体，则会尝试下一个，直到找到合适的字体， 如果都没有，则以我们电脑默认的字体为准。</li></ul><pre><code>p&#123;font-family: Arial,&quot;Microsoft Yahei&quot;, &quot;微软雅黑&quot;;&#125;</code></pre><blockquote><p>常用技巧：</p><ol><li>各种字体之间必须使用英文状态下的逗号隔开。</li><li>中文字体需要加英文状态下的引号，英文字体一般不需要加引号。当需要设置英文字体时，英文字体名必须位于中文字体名之前。</li><li>如果字体名中包含空格、#、$等符号，则该字体必须加英文状态下的单引号或双引号，例如 font-family: “Times New Roman”;。</li><li>尽量使用系统默认字体，保证在任何用户的浏览器中都能正确显示。</li></ol></blockquote><h3 id=""><a href="#" class="headerlink" title=""></a></h3><blockquote><p>CSS Unicode 字体</p></blockquote><ul><li><p>为什么使用 Unicode 字体</p><ul><li>在 CSS 中设置字体名称，直接写中文是可以的。但是在文件编码（GB2312、UTF-8 等）不匹配时会产生乱码的错误。</li><li>xp 系统不支持 类似微软雅黑的中文。</li></ul></li><li><p>解决方案一： 你可以使用英文来替代。 比如<code>font-family:&quot;Microsoft Yahei&quot;</code>。</p></li><li><p>解决方案二： 在 CSS 直接使用 Unicode 编码来写字体名称可以避免这些错误。使用 Unicode 写中文字体名称，浏览器是可以正确的解析的，记住！是在 CSS 里面</p></li></ul><pre><code class="css">font-family: &quot;\5FAE\8F6F\96C5\9ED1&quot;;   表示设置字体为“微软雅黑”。</code></pre><table><thead><tr><th>字体名称</th><th>英文名称</th><th>Unicode 编码</th></tr></thead><tbody><tr><td>宋体</td><td>SimSun</td><td>\5B8B\4F53</td></tr><tr><td>新宋体</td><td>NSimSun</td><td>\65B0\5B8B\4F53</td></tr><tr><td>黑体</td><td>SimHei</td><td>\9ED1\4F53</td></tr><tr><td>微软雅黑</td><td>Microsoft YaHei</td><td>\5FAE\8F6F\96C5\9ED1</td></tr><tr><td>楷体_GB2312</td><td>KaiTi_GB2312</td><td>\6977\4F53_GB2312</td></tr><tr><td>隶书</td><td>LiSu</td><td>\96B6\4E66</td></tr><tr><td>幼园</td><td>YouYuan</td><td>\5E7C\5706</td></tr><tr><td>华文细黑</td><td>STXihei</td><td>\534E\6587\7EC6\9ED1</td></tr><tr><td>细明体</td><td>MingLiU</td><td>\7EC6\660E\4F53</td></tr><tr><td>新细明体</td><td>PMingLiU</td><td>\65B0\7EC6\660E\4F53</td></tr></tbody></table><p>为了照顾不同电脑的字体安装问题，我们尽量只使用宋体和微软雅黑中文字体</p><h3 id="font-weight"><a href="#font-weight" class="headerlink" title="font-weight"></a>font-weight</h3><ul><li>在 html 中使用 b 和 strong 标签是文本加粗。</li><li>可以使用 CSS 来实现，但是 CSS 是没有语义的。<table><thead><tr><th>属性值</th><th align="left">描述</th></tr></thead><tbody><tr><td>normal</td><td align="left">默认值（不加粗的）</td></tr><tr><td>bold</td><td align="left">定义粗体（加粗的）</td></tr><tr><td>100~900</td><td align="left">400 等同于 normal，而 700 等同于 bold</td></tr></tbody></table></li></ul><h3 id="font-style"><a href="#font-style" class="headerlink" title="font-style"></a>font-style</h3><ul><li>在 html 中字体倾斜用 i 和 em 标签，</li><li>可以使用 CSS 来实现，但是 CSS 是没有语义的</li></ul><p>font-style 属性用于定义字体风格，如设置斜体、倾斜或正常字体，其可用属性值如下：</p><table><thead><tr><th>属性</th><th align="left">作用</th></tr></thead><tbody><tr><td>normal</td><td align="left">默认值，浏览器会显示标准的字体样式 font-style: normal;</td></tr><tr><td>italic</td><td align="left">浏览器会显示斜体的字体样式。</td></tr></tbody></table><h3 id="font-综合设置"><a href="#font-综合设置" class="headerlink" title="font 综合设置"></a>font 综合设置</h3><ul><li>基本语法格式如下：</li></ul><pre><code class="css">选择器 &#123;  font: font-style font-weight font-size/line-height font-family;&#125;</code></pre><ul><li>使用 font 属性时，必须按上面语法格式中的顺序书写，不能更换顺序，各个属性以<strong>空格</strong>隔开。</li><li>其中不需要设置的属性可以省略（取默认值），但必须保留 font-size 和 font-family 属性，否则 font 属性将不起作用。</li></ul><h3 id="color"><a href="#color" class="headerlink" title="color"></a>color</h3><ul><li>作用：color 属性用于定义文本的颜色，</li><li>一般选用十六进制的</li><li>其取值方式有如下 3 种：</li></ul><table><thead><tr><th align="left">表示表示</th><th align="left">属性值</th></tr></thead><tbody><tr><td align="left">预定义的颜色值</td><td align="left">red，green，blue，还有我们的御用色 pink</td></tr><tr><td align="left">十六进制</td><td align="left">#FF0000，#FF6600，#29D794</td></tr><tr><td align="left">RGB 代码</td><td align="left">rgb(255,0,0)或 rgb(100%,0%,0%)</td></tr></tbody></table><h3 id="text-align"><a href="#text-align" class="headerlink" title="text-align"></a>text-align</h3><ul><li><p>文本水平对齐方式：text-align 属性用于设置文本内容的水平对齐，相当于 html 中的 align 对齐属性</p></li><li><p>其可用属性值如下：</p></li></ul><table><thead><tr><th>属性</th><th align="center">解释</th></tr></thead><tbody><tr><td>left</td><td align="center">左对齐（默认值）</td></tr><tr><td>right</td><td align="center">右对齐</td></tr><tr><td>center</td><td align="center">居中对齐</td></tr></tbody></table><ul><li>注意：<br>是让盒子里面的内容水平居中， 而不是让盒子居中对齐</li></ul><h3 id="TODO-line-height"><a href="#TODO-line-height" class="headerlink" title="TODO: line-height"></a>TODO: line-height</h3><ul><li><p>行间距：line-height 属性用于设置行间距，就是行与行之间的距离，即字符的垂直间距，一般称为行高。</p></li><li><p>单位：line-height 常用的属性值单位有三种，分别为像素 px，相对值 em 和百分比%，实际工作中使用最多的是像素 px</p></li></ul><pre><code>一般情况下，行距比字号大7.8像素左右就可以了。line-height: 24px;</code></pre><h3 id="text-indent"><a href="#text-indent" class="headerlink" title="text-indent"></a>text-indent</h3><ul><li><p>作用：text-indent 属性用于设置首行文本的缩进，</p></li><li><p>其属性值可为不同单位的数值、em 字符宽度的倍数、或相对于浏览器窗口宽度的百分比%，允许使用负值,</p></li><li><p>建议使用 em 作为设置单位，<strong>1em 就是一个字的宽度 如果是汉字的段落， 1em 就是一个汉字的宽度</strong></p></li></ul><pre><code class="css">p &#123;  /*行间距*/  line-height: 25px;  /*首行缩进2个字  em  1个em 就是1个字的大小*/  text-indent: 2em;&#125;</code></pre><h3 id="text-decoration"><a href="#text-decoration" class="headerlink" title="text-decoration"></a>text-decoration</h3><ul><li>text-decoration 通常我们用于给链接修改装饰效果<table><thead><tr><th>值</th><th>描述</th></tr></thead><tbody><tr><td>none</td><td>默认。定义标准的文本。 取消下划线（最常用）</td></tr><tr><td>underline</td><td>定义文本下的一条线。下划线 也是我们链接自带的（常用）</td></tr><tr><td>overline</td><td>定义文本上的一条线。（不用）</td></tr><tr><td>line-through</td><td>定义穿过文本下的一条线。（不常用）</td></tr></tbody></table></li></ul><h2 id="背景相关"><a href="#背景相关" class="headerlink" title="背景相关"></a>背景相关</h2><h3 id="background-color"><a href="#background-color" class="headerlink" title="background-color"></a>background-color</h3><ul><li>background-color: 颜色值;</li><li>默认的值是 transparent   透明的</li></ul><h3 id="background-image"><a href="#background-image" class="headerlink" title="background-image"></a>background-image</h3><ul><li>background-image : url(images/demo.png);</li><li>背景图片后面的地址，url 不要加引号。</li></ul><pre><code class="css">background-image: none | url (url);</code></pre><table><thead><tr><th>参数</th><th align="center">作用</th></tr></thead><tbody><tr><td>none</td><td align="center">无背景图（默认的）</td></tr><tr><td>url</td><td align="center">使用绝对或相对地址指定背景图像</td></tr></tbody></table><h3 id="background-repeat"><a href="#background-repeat" class="headerlink" title="background-repeat"></a>background-repeat</h3><ul><li>语法：</li></ul><pre><code class="css">background-repeat: repeat | no-repeat | repeat-x | repeat-y;</code></pre><table><thead><tr><th>参数</th><th align="center">作用</th></tr></thead><tbody><tr><td>repeat</td><td align="center">背景图像在纵向和横向上平铺（默认的）</td></tr><tr><td>no-repeat</td><td align="center">背景图像不平铺</td></tr><tr><td>repeat-x</td><td align="center">背景图像在横向上平铺</td></tr><tr><td>repeat-y</td><td align="center">背景图像在纵向平铺</td></tr></tbody></table><h3 id="background-position"><a href="#background-position" class="headerlink" title="background-position"></a>background-position</h3><ul><li>语法：</li></ul><pre><code class="css">background-position : length || lengthbackground-position : position || position</code></pre><ul><li><p>参数解释</p><table><thead><tr><th>参数</th><th align="center">值</th></tr></thead><tbody><tr><td>length</td><td align="center">百分数</td></tr><tr><td>position</td><td align="center">top</td></tr></tbody></table></li><li><p>必须先指定 background-image 属性</p></li><li><p>position 后面是 x 坐标和 y 坐标。 可以使用方位名词或者 精确单位。</p></li><li><p>如果指定两个值，两个值都是方位名字，则两个值前后顺序无关，比如 left top 和 top left 效果一致</p></li><li><p>如果只指定了一个方位名词，另一个值默认居中对齐。</p></li><li><p>如果 position 后面是精确坐标， 那么第一个，肯定是 x 第二的一定是 y</p></li><li><p>如果只指定一个数值,那该数值一定是 x 坐标，另一个默认垂直居中</p></li><li><p>如果指定的两个值是 精确单位和方位名字混合使用，则第一个值是 x 坐标，第二个值是 y 坐标</p></li><li><p><strong>实际工作用的最多的，就是背景图片居中对齐了。</strong></p></li></ul><h3 id="background-attachment"><a href="#background-attachment" class="headerlink" title="background-attachment"></a>background-attachment</h3><ul><li><p>背景附着就是解释背景是滚动的还是固定的</p></li><li><p>语法：</p></li></ul><pre><code class="css">background-attachment: scroll | fixed;</code></pre><table><thead><tr><th>参数</th><th align="center">作用</th></tr></thead><tbody><tr><td>scroll</td><td align="center">背景图像是随对象内容滚动</td></tr><tr><td>fixed</td><td align="center">背景图像固定</td></tr></tbody></table><h3 id="background-size"><a href="#background-size" class="headerlink" title="background-size"></a>background-size</h3><blockquote><p>background-size 属性规定背景图像的尺寸</p></blockquote><ul><li>两个参数：分别是长度和宽度</li><li>一个参数：就是宽度，高度跟着宽度等比拉伸</li><li><strong>也可以是百分比，相对父盒子</strong></li><li>cover：类似按着右下角光标，把背景图像扩展至足够大，以使背景图像完全覆盖背景区域。</li><li>contain：把图像扩展至最大尺寸，以使其宽度和高度完全适应内容区域</li></ul><h3 id="背景简写"><a href="#背景简写" class="headerlink" title="背景简写"></a>背景简写</h3><ul><li>background：属性的值的书写顺序官方并没有强制标准的。</li><li>background: 背景颜色 背景图片地址 背景平铺 背景滚动 背景位置;</li><li>语法：</li></ul><pre><code class="css">background: blue url(image.jpg) repeat-y scroll center top;</code></pre><h3 id="背景透明-CSS3"><a href="#背景透明-CSS3" class="headerlink" title="背景透明(CSS3)"></a>背景透明(CSS3)</h3><ul><li>语法：</li></ul><pre><code class="css">background: rgba(0, 0, 0, 0);</code></pre><ul><li>最后一个参数是 alpha 透明度 取值范围 0~1 之间</li><li>我们习惯把 0.3 的 0 省略掉 这样写 background: rgba(0, 0, 0, .3);</li><li>注意： 背景半透明是指盒子背景半透明， 盒子里面的内容不受影响</li><li>因为是 CSS3 ，所以 低于 ie9 的版本是不支持的。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 👨‍💻Web开发 </category>
          
          <category> HTML+CSS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>HTML5总结</title>
      <link href="/blog/vxz6aq7m0szt/"/>
      <url>/blog/vxz6aq7m0szt/</url>
      
        <content type="html"><![CDATA[<h2 id="HTML5"><a href="#HTML5" class="headerlink" title="HTML5"></a>HTML5</h2><div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">新版本的 HTML 语言，定义了新的标签、特性和属性</div><h3 id="常用文档"><a href="#常用文档" class="headerlink" title="常用文档"></a>常用文档</h3><blockquote><p>W3C : <a href="http://www.w3school.com.cn/">http://www.w3school.com.cn/</a><br>MDN: <a href="https://developer.mozilla.org/zh-CN/">https://developer.mozilla.org/zh-CN/</a><br>菜鸟：<a href="https://www.runoob.com/">https://www.runoob.com/</a></p></blockquote><h3 id="扩展的内容"><a href="#扩展的内容" class="headerlink" title="扩展的内容"></a>扩展的内容</h3><ul><li>语义化标签</li><li>本地存储</li><li>兼容特性</li><li>2D、3D</li><li>动画、过渡</li><li>CSS3 特性</li><li>性能与集成</li></ul><h2 id="HTML5-文档结构-语义化标签"><a href="#HTML5-文档结构-语义化标签" class="headerlink" title="HTML5 文档结构/语义化标签"></a>HTML5 文档结构/语义化标签</h2><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616663386514-c6d53c70-d47f-4e40-b6f8-4a0f0596489b.png#align=left&display=inline&height=215&margin=%5Bobject%20Object%5D&name=image.png&originHeight=429&originWidth=669&size=51321&status=done&style=stroke&width=334.5" alt="image.png"></p><ul><li><a href="https://www.jianshu.com/p/c41b88217834">https://www.jianshu.com/p/c41b88217834</a></li><li><a href="https://juejin.cn/post/6844903544995184653">https://juejin.cn/post/6844903544995184653</a></li></ul><h2 id="lt-DOCTYPE-gt"><a href="#lt-DOCTYPE-gt" class="headerlink" title="&lt;!DOCTYPE&gt;"></a>&lt;!DOCTYPE&gt;</h2><ul><li>html5 的文档类型声明：声明位于文档中的最前面的位置，处于 标签之前。此标签可告知浏览器文档使用哪种 HTML 或 XHTML 规范。</li><li>一些老网站可能用的还是老版本的文档类型比如 XHTML 之类的，但是我们学的是 HTML5,而且 HTML5 的文档类型兼容很好(向下兼容的原则)</li></ul><h2 id="charset"><a href="#charset" class="headerlink" title="charset"></a>charset</h2><ul><li>html5 文档编码格式的指定</li></ul><pre><code class="html">&lt;meta charset=&quot;UTF-8&quot; /&gt;</code></pre><blockquote><p>字符集(Character set)是多个字符的集合。<br>计算机要准确的处理各种字符集文字，需要进行字符编码，以便计算机能够识别和存储各种文字。</p></blockquote><p>utf-8 是目前最常用的字符集编码方式，常用的字符集编码方式还有 gbk 和 gb2312。</p><ul><li>gb2312 简单中文 包括 6763 个汉字</li><li>BIG5 繁体中文 港澳台等用</li><li>GBK 包含全部中文字符 是 GB2312 的扩展，加入对繁体字的支持，兼容 GB2312</li><li>UTF-8 则基本包含全世界所有国家需要用到的字符</li></ul><h2 id="多媒体音频标签"><a href="#多媒体音频标签" class="headerlink" title="多媒体音频标签"></a>多媒体音频标签</h2><ol><li>多媒体标签有两个，分别是</li></ol><ul><li>音频  – <code>audio</code></li><li>视频  – <code>video</code></li></ul><ol start="2"><li><code>audio</code> 标签说明</li></ol><ul><li>可以在不使用标签的情况下，也能够原生的支持音频格式文件的播放，</li><li>但是：播放格式是有限的</li></ul><ol start="3"><li><p>audio 支持的音频格式</p><ul><li>audio 目前支持三种格式</li></ul></li><li><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1615560874331-7786480d-ad33-403e-976d-73e235a0f3ec.png#align=left&display=inline&height=130&margin=%5Bobject%20Object%5D&name=image.png&originHeight=260&originWidth=1179&size=48950&status=done&style=none&width=589.5" alt="image.png"></p></li><li><p>audio 的参数<img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1615560883989-c202ee16-7e45-4c86-ac47-3e3ba07fc2a7.png#align=left&display=inline&height=210&margin=%5Bobject%20Object%5D&name=image.png&originHeight=420&originWidth=1203&size=105644&status=done&style=none&width=601.5" alt="image.png"></p></li></ol><p>5、audio 代码演示</p><pre><code class="css">&lt;body&gt;  &lt;!-- 注意：在 chrome 浏览器中已经禁用了 autoplay 属性 --&gt;  &lt;!-- &lt;audio src=&quot;./media/snow.mp3&quot; controls autoplay&gt;&lt;/audio&gt; --&gt;  &lt;!--    因为不同浏览器支持不同的格式，所以我们采取的方案是这个音频准备多个文件   --&gt;  &lt;audio controls&gt;    &lt;source src=&quot;./media/snow.mp3&quot; type=&quot;audio/mpeg&quot; /&gt;  &lt;/audio&gt;&lt;/body&gt;</code></pre><h2 id="多媒体视频标签"><a href="#多媒体视频标签" class="headerlink" title="多媒体视频标签"></a>多媒体视频标签</h2><ol><li>video 视频标签<ul><li>目前支持三种格式</li></ul></li><li><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1615560894436-db88d851-871b-4758-9b78-9b9892711139.png#align=left&display=inline&height=141&margin=%5Bobject%20Object%5D&name=image.png&originHeight=281&originWidth=1211&size=137376&status=done&style=none&width=605.5" alt="image.png"></li><li>语法格式</li></ol><pre><code class="html">&lt;video src=&quot;./media/video.mp4&quot; controls=&quot;controls&quot;&gt;&lt;/video&gt;</code></pre><ol><li>video 参数<img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1615560905874-4a6cc88d-8941-4f8c-9c89-05ce01e229fb.png#align=left&display=inline&height=301&margin=%5Bobject%20Object%5D&name=image.png&originHeight=602&originWidth=1193&size=396225&status=done&style=none&width=596.5" alt="image.png"></li><li>video 代码演示</li></ol><pre><code class="html">&lt;body&gt;  &lt;!-- &lt;video src=&quot;./media/video.mp4&quot; controls=&quot;controls&quot;&gt;&lt;/video&gt; --&gt;  &lt;!-- 谷歌浏览器禁用了自动播放功能，如果想自动播放，需要添加 muted 属性 --&gt;  &lt;video controls=&quot;controls&quot; autoplay muted loop poster=&quot;./media/pig.jpg&quot;&gt;    &lt;source src=&quot;./media/video.mp4&quot; type=&quot;video/mp4&quot; /&gt;    &lt;source src=&quot;./media/video.ogg&quot; type=&quot;video/ogg&quot; /&gt;  &lt;/video&gt;&lt;/body&gt;</code></pre><ol><li>多媒体标签总结</li></ol><ul><li>音频标签与视频标签使用基本一致</li><li>多媒体标签在不同浏览器下情况不同，存在兼容性问题</li><li>谷歌浏览器把音频和视频标签的自动播放都禁止了</li><li>谷歌浏览器中视频添加 muted 标签可以自己播放</li><li>注意：重点记住使用方法以及自动播放即可，其他属性可以在使用时查找对应的手册</li></ul><h2 id="新增-input-标签"><a href="#新增-input-标签" class="headerlink" title="新增 input 标签"></a>新增 input 标签</h2><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1615560920848-b6218b7e-57ed-4da9-889e-ff00dd8df1c2.png#align=left&display=inline&height=376&margin=%5Bobject%20Object%5D&name=image.png&originHeight=752&originWidth=1259&size=176698&status=done&style=none&width=629.5" alt="image.png"></p><h2 id="新增表单属性"><a href="#新增表单属性" class="headerlink" title="新增表单属性"></a>新增表单属性</h2><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1615560931257-0c5b2693-9baf-4129-a502-e22ebc14c89e.png#align=left&display=inline&height=251&margin=%5Bobject%20Object%5D&name=image.png&originHeight=502&originWidth=1217&size=155890&status=done&style=none&width=608.5" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> 👨‍💻Web开发 </category>
          
          <category> HTML+CSS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>HTML总结</title>
      <link href="/blog/vtwy70ohpnm5/"/>
      <url>/blog/vtwy70ohpnm5/</url>
      
        <content type="html"><![CDATA[<h2 id="常用文档"><a href="#常用文档" class="headerlink" title="常用文档"></a>常用文档</h2><blockquote><p>W3C : <a href="http://www.w3school.com.cn/">http://www.w3school.com.cn/</a><br>MDN: <a href="https://developer.mozilla.org/zh-CN/">https://developer.mozilla.org/zh-CN/</a><br>菜鸟：<a href="https://www.runoob.com/">https://www.runoob.com/</a></p></blockquote><h2 id="排版标签"><a href="#排版标签" class="headerlink" title="排版标签"></a>排版标签</h2><ul><li>h：标题</li><li>p：段落</li><li>hr（单）：横线</li><li>br（单）：换行</li><li>blockquote：引用</li><li>pre：预定义格式<blockquote><p>标签可定义预格式化的文本。 被包围在   标签 元素中的文本通常会保留空格和换行符。而文本也会呈现为等宽字体。</p></blockquote></li></ul><h2 id="文本格式化标签"><a href="#文本格式化标签" class="headerlink" title="文本格式化标签"></a>文本格式化标签</h2><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611547659083-2c64e035-b906-47c8-84e1-67b8e747e361.png#align=left&display=inline&height=434&margin=%5Bobject%20Object%5D&originHeight=434&originWidth=1054&status=done&style=none&width=1054"></p><ul><li>b 只是加粗 strong 除了可以加粗还有 强调的意思，语义更强烈。</li></ul><h2 id="img（单）"><a href="#img（单）" class="headerlink" title="img（单）"></a>img（单）</h2><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611547659339-b5fd80fe-ed24-42d9-8d70-ab9fe086449d.png#align=left&display=inline&height=439&margin=%5Bobject%20Object%5D&originHeight=439&originWidth=997&status=done&style=none&width=997"><br>border 后面我们会用 css 来做，这里童鞋们就记住这个 border 单词就好了<br>**注意: **</p><ol><li>标签可以拥有多个属性，必须写在开始标签中，位于标签名后面。</li><li>属性之间不分先后顺序，标签名与属性、属性与属性之间均以空格分开。</li><li>任何标签的属性都有默认值，省略该属性则取默认值。</li><li>采取 键值对 的格式 key=”value” 的格式</li></ol><p>比如:<br>此处有练习题<br><strong>重点掌握点：</strong></p><ul><li>请说出 图像标签那个属性是必须要写的？ img src 图片的路径</li><li>请说出 图像标签中 alt 和 title 属性区别？ alt 图片显示不出，文字就显示 title 鼠标经过图片的时候显示文字</li></ul><h2 id="a"><a href="#a" class="headerlink" title="a**"></a>a**</h2><ul><li>href：必须要的属性</li><li>target=“_blank”：新窗口打开</li></ul><h2 id="div-和-span"><a href="#div-和-span" class="headerlink" title="div 和 span"></a>div 和 span</h2><blockquote><p>标准流布局</p></blockquote><ul><li>div 标签 用来布局的，但是现在一行只能放一个 div</li><li>span 标签 用来布局的，一行上可以放好多个 span</li></ul><h2 id="base"><a href="#base" class="headerlink" title="base"></a>base</h2><ul><li>base 可以设置整体链接的打开状态<blockquote><p>最常用的就是<base target="_blank" /></p></blockquote></li></ul><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="lang"><a href="#lang" class="headerlink" title="lang"></a>lang</h2><pre><code class="html">&lt;html lang=&quot;en&quot;&gt;  指定html 语言种类&lt;/html&gt;</code></pre><p>最常见的 2 个：</p><ol><li><code>en</code>定义语言为英语</li><li><code>zh-CN</code>定义语言为中文</li></ol><ul><li>指定该 html 标签 内容 所用的语言为中文**</li><li>简单来说，可能对于程序来说没有太大的作用，但是它可以告诉浏览器，搜索引擎，一些处理 Html 的程序对页面语言内容来做一些对应的处理或者事情。</li></ul><h2 id="table"><a href="#table" class="headerlink" title="table"></a>table</h2><h3 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h3><ul><li>展示数据</li><li>让数据显示整齐规范</li><li>表格属性需要注意的</li></ul><p>平时开发的我们这三个参数 border、cellpadding、cellspacing 为 0，但在 HTML5 里面，后两者属性设置无效，利用 <code>border-collapse: collapse;</code> 来设置，将 th 和 td 设置为 0</p><ul><li>浏览器会默认包裹 tbody 标签</li><li>HTML5 里面用 thead,tbody,tfoot 来标注内容，更加清晰**</li></ul><h3 id="合并单元格"><a href="#合并单元格" class="headerlink" title="合并单元格"></a>合并单元格</h3><p>合并单元格是我们比较常用的一个操作，但是不会合并的很复杂。</p><blockquote><p>【1】合并单元格 2 种方式</p></blockquote><ul><li>跨行合并：rowspan=”合并单元格的个数”</li><li>跨列合并：colspan=”合并单元格的个数”<blockquote><p>【2】合并单元格顺序<br>**合并的顺序我们按照 先上 后下 先左 后右 的顺序 **</p></blockquote></li></ul><p>跟我们以前学习汉字的书写顺序完全一致。</p><blockquote><p>【3】合并单元格三步曲</p></blockquote><ol><li>先确定是跨行还是跨列合并</li><li>根据 先上 后下 先左 后右的原则找到目标单元格 然后写上 合并方式 还有 要合并的单元格数量 比如 ：</li><li>删除多余的单元格 单元格</li></ol><h2 id="ul、ol、dl"><a href="#ul、ol、dl" class="headerlink" title="ul、ol、dl"></a>ul、ol、dl</h2><h3 id="去掉列表默认的样式"><a href="#去掉列表默认的样式" class="headerlink" title="去掉列表默认的样式"></a>去掉列表默认的样式</h3><p>无序和有序列表前面默认的列表样式，在不同浏览器显示效果不一样，而且也比较难看，所以，我们一般上来就直接去掉这些列表样式就行了。 代码如下</p><pre><code class="css">li &#123;  list-style: none;&#125;</code></pre><h2 id="form"><a href="#form" class="headerlink" title="form"></a>form</h2><ul><li>表单目的是为了收集用户信息。</li></ul><p>在我们网页中， 我们也需要跟用户进行交互，收集用户资料，此时也需要表单。</p><blockquote><p>在 HTML 中，一个完整的表单通常由表单控件（也称为表单元素）、提示信息和表单域 3 个部分构成。</p></blockquote><ul><li>**表单控件： **包含了具体的表单功能项，如单行文本输入框、密码输入框、复选框、提交按钮、重置按钮等。</li><li><strong>提示信息：</strong>一个表单中通常还需要包含一些说明性的文字，提示用户进行填写和操作。</li><li><strong>表单域：</strong>他相当于一个容器，用来容纳所有的表单控件和提示信息，可以通过他定义处理表单数据所用程序的 url 地址，以及数据提交到服务器的方法。如果不定义表单域，表单中的数据就无法传送到后台服务器。</li></ul><h3 id="input"><a href="#input" class="headerlink" title="input"></a>input</h3><ul><li>常用属性：</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611547661035-9721cb68-5232-4cbf-8bf5-01b447ed3f3f.png#align=left&display=inline&height=456&margin=%5Bobject%20Object%5D&originHeight=456&originWidth=950&status=done&style=none&width=950"></p><ul><li><p>value 默认的文本值。 有些表单想刚打开页面就默认显示几个文字，就可以通过这个 value 来设置。</p><blockquote><p>name 属性后面的值，是我们自己定义的。</p></blockquote></li><li><p>name 表单的名字， 这样，后台可以通过这个 name 属性找到这个表单。 页面中的表单很多，name 主要作用就是用于区别不同的表单。</p></li><li><p>radio 如果是一组，我们必须给他们命名相同的名字 name 这样就可以在同一个组里面多个选其中的一个</p></li><li><p>name 属性，我们现在用的较少， 但是，当我们学 ajax 和后台的时候，是必须的。</p><blockquote><p>checked 属性</p></blockquote></li><li><p>默认选中状态。 较常见于 单选按钮和复选按钮。</p></li></ul><h3 id="label"><a href="#label" class="headerlink" title="label"></a>label</h3><ul><li>用于绑定一个表单元素, 当点击 label 标签的时候, 被绑定的表单元素就会获得输入焦点。<blockquote><p>两种绑定方式</p></blockquote></li></ul><ol><li>第一种用法就是用 label 直接包括 input 表单。</li></ol><pre><code class="html">&lt;label&gt;  用户名： &lt;input type=&quot;radio&quot; name=&quot;usename&quot; value=&quot;请输入用户名&quot; /&gt;&lt;/label&gt;</code></pre><p>适合单个表单选择</p><ol start="2"><li>第二种用法 for 属性规定 label 与哪个表单元素绑定。</li></ol><pre><code class="html">&lt;label for=&quot;sex&quot;&gt;男&lt;/label&gt; &lt;input type=&quot;radio&quot; name=&quot;sex&quot; id=&quot;sex&quot; /&gt;</code></pre><h3 id="textarea"><a href="#textarea" class="headerlink" title="textarea"></a>textarea</h3><h3 id="select"><a href="#select" class="headerlink" title="select**"></a>select**</h3><ul><li><select> 中至少包含一对 option</li><li>在 option 中定义 selected =” selected “时，当前项即为默认选中项。</li><li>但是我们实际开发会用的比较少</li></ul><h3 id="form-表单域"><a href="#form-表单域" class="headerlink" title="form 表单域"></a>form 表单域</h3><ul><li><p>收集的用户信息怎么传递给服务器：通过 form 表单域</p></li><li><p>目的：在 HTML 中，form 标签被用于定义表单域，以实现用户信息的收集和传递，form 中的所有内容都会被提交给服务器。</p></li></ul><pre><code class="html">&lt;form action=&quot;url地址&quot; method=&quot;提交方式&quot; name=&quot;表单名称&quot;&gt;各种表单控件&lt;/form&gt;</code></pre><ul><li>每一个 form 至少含有一个 submit 类型的 input 标签（点击 submit 提交到 form 中的 action 地址当中），然后接收的 html 页面（服务端）利用类似以下的代码进行处理 url 得到前者页面所传过来的参数，以便在服务端进行利用</li></ul><pre><code class="javascript">&lt;script&gt;  console.log(location.search); // ?uname=andy // 1.先去掉？  substr(&#39;起始的位置&#39;，截取几个字符); var params = location.search.substr(1); //  uname=andy console.log(params); // 2. 利用=把字符串分割为数组 split(&#39;=&#39;); var  arr = params.split(&#39;=&#39;); console.log(arr); // [&quot;uname&quot;, &quot;ANDY&quot;] var div =  document.querySelector(&#39;div&#39;); // 3.把数据写入div中 div.innerHTML = arr[1] +  &#39;欢迎您&#39;;&lt;/script&gt;</code></pre><ul><li><p><strong>常用属性</strong></p><table><thead><tr><th>属性</th><th align="left">属性值</th><th>作用</th></tr></thead><tbody><tr><td>action</td><td align="left">url 地址</td><td>用于指定接收并处理表单数据的服务器程序的 url 地址。</td></tr><tr><td>method</td><td align="left">get/post</td><td>用于设置表单数据的提交方式，其取值为 get 或 post。</td></tr><tr><td>name</td><td align="left">名称</td><td>用于指定表单的名称，以区分同一个页面中的多个表单。</td></tr></tbody></table></li><li><p>每个表单都应该有自己表单域。我们现在做页面，不写看不到效果，但是 如果后面学 ajax 后台交互的时候，必须需要 form 表单域。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 👨‍💻Web开发 </category>
          
          <category> HTML+CSS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>674. 最长连续递增序列🔖数组🔖双指针</title>
      <link href="/blog/guaorh/"/>
      <url>/blog/guaorh/</url>
      
        <content type="html"><![CDATA[<ul><li><a href="https://leetcode-cn.com/problems/longest-continuous-increasing-subsequence/">https://leetcode-cn.com/problems/longest-continuous-increasing-subsequence/</a></li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>双指针顺移思想</p><h3 id="ts-实现"><a href="#ts-实现" class="headerlink" title="ts 实现"></a>ts 实现</h3><pre><code class="typescript">function findLengthOfLCIS(nums: number[]): number &#123;  if (nums.length === 1) return 1;  let head: number = 0;  let next: number = 1;  let result: number = 1;  while (next !== nums.length) &#123;    nums[next - 1] &lt; nums[next]      ? (result = result &lt;= next - head + 1 ? next - head + 1 : result)      : (head = next);    next++;  &#125;  return result;&#125;</code></pre><h3 id="之前-java-代码实现"><a href="#之前-java-代码实现" class="headerlink" title="之前 java 代码实现"></a>之前 java 代码实现</h3><pre><code class="java">package com.wztlink1013.problems.leetcode.editor.cn;// P674.最长连续递增序列// P674.longest-continuous-increasing-subsequence//给定一个未经排序的整数数组，找到最长且 连续递增的子序列，并返回该序列的长度。//// 连续递增的子序列 可以由两个下标 l 和 r（l &lt; r）确定，如果对于每个 l &lt;= i &lt; r，都有 nums[i] &lt; nums[i + 1] ，那//么子序列 [nums[l], nums[l + 1], ..., nums[r - 1], nums[r]] 就是连续递增子序列。//////// 示例 1：//////输入：nums = [1,3,5,4,7]//输出：3//解释：最长连续递增序列是 [1,3,5], 长度为3。//尽管 [1,3,5,7] 也是升序的子序列, 但它不是连续的，因为 5 和 7 在原数组里被 4 隔开。////// 示例 2：//////输入：nums = [2,2,2,2,2]//输出：1//解释：最长连续递增序列是 [2], 长度为1。////////// 提示：////// 0 &lt;= nums.length &lt;= 104// -109 &lt;= nums[i] &lt;= 109//// Related Topics 数组// 👍 147 👎 0public class P674LongestContinuousIncreasingSubsequence&#123;    public static void main(String[] args) &#123;        Solution solution = new P674LongestContinuousIncreasingSubsequence().new Solution();        int [] nums = &#123;1,3,5,7&#125;;        int result = solution.findLengthOfLCIS(nums);        System.out.println(result);    &#125;//leetcode submit region begin(Prohibit modification and deletion)class Solution &#123;    public int findLengthOfLCIS(int[] nums) &#123;        if (nums.length == 0) &#123; return 0; &#125;        int result = 1;        int count = 1;        for (int i=0; i&lt;nums.length-1; i++) &#123;            if (nums[i] &lt; nums[i+1] ) &#123;                count++;                if (result &lt; count) &#123;result = count;&#125;            &#125; else &#123;                if (result &lt; count) &#123;result = count;&#125;                count = 1;            &#125;        &#125;        return result;    &#125;&#125;//leetcode submit region end(Prohibit modification and deletion)&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 📶线结构：字符串-数组-栈-队列 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>《软件工程导论》知识总结</title>
      <link href="/blog/sc6tzq/"/>
      <url>/blog/sc6tzq/</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1623288164521-ad52e1f8-1a29-4976-ac2b-c45d7d5aa773.png#crop=0&crop=0&crop=1&crop=1&height=330&id=uca9222ff&margin=%5Bobject%20Object%5D&name=image.png&originHeight=500&originWidth=356&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=280972&status=done&style=none&title=&width=234.98956298828125" alt="image.png"></p><p>前言：大三课程所学总结，同时日后以此为蓝本在实际开发中规范化开发。</p><h2 id="一、传统方法学"><a href="#一、传统方法学" class="headerlink" title="一、传统方法学"></a>一、传统方法学</h2><ul><li><p><strong>问题定义</strong></p></li><li><p><strong>可行性研究</strong></p></li><li><p><strong>需求分析</strong></p></li><li><p><strong>总体设计</strong></p></li><li><p><strong>详细设计</strong></p></li><li><p><strong>编码和单元测试</strong></p></li><li><p><strong>综合测试</strong></p></li><li><p><strong>软件维护</strong></p></li></ul><h3 id="可行性研究"><a href="#可行性研究" class="headerlink" title="可行性研究"></a>可行性研究</h3><blockquote><p>在了解问题定义之后，将其模型抽离出来，然后对其进行可行性分析，探索若干种解法，对每种解法仔细研究其可行性，从下面几种方面来考虑</p></blockquote><ol><li>技术可行性：能否用现又技术实现？</li><li>经济可行性：软件带来的经济效益能否大于软件的开发成本？</li><li>操作可行性：在用户组织之间是否具有操作可行性？</li></ol><p>必要时还有从法律和社会效益来研究其可行性。</p><blockquote><p>系统流程图<br>数据流图</p></blockquote><blockquote><p>成本/效益分析</p></blockquote><p>成本估计的几种方法</p><ul><li>代码行技术：根据每行代码的平均成本乘以行数就是大概的成本</li><li>任务分解技术：将整个声明周期划分不同阶段，估计每个不同阶段所花费的成本，一般都是各阶段的人数诚意平均工资再加这般</li><li>自动估计成本：根据程序来估计，一般要用到大量数据，才能保证这个估计有效（大数据时代应该很吃香，可以利用所搜集的大量数据来进行建模）</li></ul><p>成本/效益分析的方法</p><ul><li>货币的时间价值：这里面有年利率的概念，就是过 n 年之后，你手中的钱在 n 年之后会提升</li></ul><p>F=P（1+n）^n （P 元钱在 n 年后的价值）</p><ul><li>投资回收期：你所赚的钱等于你所投资的资金所花费的时间越短越好</li><li>纯收入：整个生命周期内，赚的钱减去你投资的钱</li></ul><h3 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h3><blockquote><p>与用户沟通获取需求的方法</p></blockquote><ul><li>访谈</li><li>面向数据流自顶向下求精</li><li>简易的应用规格说明技术</li><li>快速建立软件模型</li></ul><blockquote><p>根据结构化分析准则，需求分析过程应该建立三种模型，它们分别是？以及他们所用到的工具？</p></blockquote><ul><li>数据模型——E-R 图：就是数据库里面学到的实体-联系图</li><li>功能模型——数据流图：描述数据在系统中的转换的逻辑过程</li><li>行为模型——状态转换图：作为外部事件结果的系统行为</li></ul><blockquote><p>其他的工具还有</p></blockquote><ul><li>层次方框图（树形结构）</li><li>Warnier 图{大括号包裹）</li><li>IPO 图（方框-箭头；表格形式）</li></ul><h3 id="形式化说明技术"><a href="#形式化说明技术" class="headerlink" title="形式化说明技术"></a>形式化说明技术</h3><blockquote><p>软件工程所使用的方法可划分为下面三种</p></blockquote><ul><li>非形式化方法：用自然语言描述就是典型的非形式化方法</li><li>半形式化方法：利用 E-R 图描述就是半形式化方法</li><li>形式化方法：用到数学的技术，也就是说，如果一种方法用到坚实的数学基础，那么他就是形式化方法</li></ul><h3 id="总体设计"><a href="#总体设计" class="headerlink" title="总体设计"></a>总体设计</h3><blockquote><p>总体设计又称之为概要设计、初步设计</p></blockquote><blockquote><p>由哪两阶段组成呢？</p></blockquote><ul><li>系统设计阶段：确定系统的具体实现方案</li><li>结构设计阶段：确定软件结构</li></ul><blockquote><p>设计原理</p></blockquote><p><strong>模块</strong>是由边界元素限定的相邻程序元素（数据说明，可执行的语句）的序列，而且有一个总体标识符代表它</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1608815946283-167d2edb-f25b-45de-ade4-6041bddf45c2.png#crop=0&crop=0&crop=1&crop=1&height=258&id=LdPtL&margin=%5Bobject%20Object%5D&name=image.png&originHeight=516&originWidth=694&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=141087&status=done&style=shadow&title=&width=347" alt="image.png"></p><p>模块之间的<strong>独立程度</strong>有两个标准来度量，分别是：</p><p>耦合：度量<strong>模块间</strong>的互相依赖程度</p><p>内聚：度量<strong>模块内部元素间</strong>的结合程度</p><p><strong>尽量使用数据耦合，少用控制耦合和特征耦合，限制公共环境耦合的范围，完全不用内容耦合</strong></p><p>7 种内聚优劣评分：功能内聚（10 分）偶然内聚（0 分）</p><blockquote><p>描绘软件结构的图形工具</p></blockquote><ul><li>层次图（树状）和 HIPO 图（带编号的层次图）</li><li>结构图</li></ul><blockquote><p>面向数据流的设计方法</p></blockquote><p>概念：面向数据流的设计方法就是把信息流映射成软件结构，同时信息流的结构决定了映射的方法</p><ul><li>变换流</li><li>事务流</li><li>设计过程</li></ul><h3 id="详细设计"><a href="#详细设计" class="headerlink" title="详细设计"></a>详细设计</h3><blockquote><p>结构程序设计</p></blockquote><p>只用 3 种控制结构就能实现任何单入口单出口的程序，这三种结构分别是顺序结构、选择结构、循环结构</p><blockquote><p>人机界面设计的设计问题有：</p></blockquote><ul><li>系统响应时间</li><li>用户帮助实施</li><li>出错信息处理</li><li>命令交互</li></ul><blockquote><p>人机界面设计的设计指南：</p></blockquote><ul><li>一般交互指南</li><li>信息显示指南</li><li>数据输入指南</li></ul><blockquote><p>过程设计的工具【重要】</p></blockquote><ol><li>程序流程图</li><li>盒图（N-S 图）</li><li>PAD 图</li><li>判定表</li><li>判定树</li><li>过程设计语言</li></ol><blockquote><p>面向数据结构的设计方法</p></blockquote><p><strong>两个最著名的方法为：Jackson 方法和 Warnier 方法</strong></p><blockquote><p>Jackson 方法</p></blockquote><p>只有顺序、选择、重复三种结构</p><p>要会用伪代码表示</p><blockquote><p>程序复杂程度的定量度量有 McCabe 方法和 Halstead 方法，只介绍前者</p></blockquote><ol><li>流图（给出伪代码画流图）</li><li>计算环形复杂度的方法</li></ol><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>实现 = 编码 + 调试</p><p>实际过程中，调试所花费的时间远大于编码的时间</p><h3 id="维护"><a href="#维护" class="headerlink" title="维护"></a>维护</h3><hr><h2 id="二、面向对象方法学"><a href="#二、面向对象方法学" class="headerlink" title="二、面向对象方法学"></a>二、面向对象方法学</h2><p>由三部分组成：分析，设计，实现</p><h2 id="三、软件项目管理"><a href="#三、软件项目管理" class="headerlink" title="三、软件项目管理"></a>三、软件项目管理</h2><p>本章节探讨的是实际<strong>软件项目管理</strong>的相关工作，软件项目管理是软件项目一经启动就开始实施的一系列工作，其首先需要探讨的就是软件项目的相关估算，具体的有<strong>软件规模的估算、工作量的估算</strong>和<strong>完成项目估算</strong>，由上述的估算再对其进行制定一套完整的<strong>进度计划方案</strong>和<strong>人员组织方案</strong>，在整个项目过程中，还需要动态的<strong>软件配置管理</strong>，最后还介绍了<strong>软件质量的保证</strong>和<strong>软件能力成熟度模型</strong>这两个软件完成收尾的相关概念。</p><p>作者想要解决软件危机相关问题，具体而言就印证“后人哀之而不鉴之，亦是后人而复哀后人也”这句古话，所以一套系统的软件项目管理出来了。</p><h3 id="估算工作"><a href="#估算工作" class="headerlink" title="估算工作"></a>估算工作</h3><p><strong>估算软件规模</strong>有两种方法：代码行估算和功能点估算<br>代码行技术就是利用代码的行数来进行估算的，会根据几个有经验的工作者利用一个公式来进行估算（最小可能的规模+最大可能的规模+最可能的规模）/6，得到的结果有两种，第一种是规模小的时候，单位行，第二种是规模大的时候，单位是千行。<br>功能点技术就比较复杂了，它涉及到五个相关信息域特征的概念，分别是输入项数，输出项数，查询项数，主文件数，外部接口项数，再利用一系列步骤公式得到这个软件的功能点估算，最后得到的是功能点数 FP。<br>具体可以参考：<a href="https://wiki.mbalib.com/wiki/%E5%8A%9F%E8%83%BD%E7%82%B9%E4%BC%B0%E7%AE%97%E6%B3%95">功能点估算法 | MBA 智库</a><br><strong>估算工作量</strong>有三种方法<br>构造的函数模型的有静态单变量模型、动态多变量模型、COCOMO2 模型这三种模型，得到的结果单位是人月（pm）。    <br>静态单变量是基于上一个估算软件规模得出的代码行/功能点结果这一个变量函数，有一些相应的前人总结的公式<br>多变量模型，顾名思义，多个变量不止一个变量，有项目持续时间，特殊技术因子，生产率参数，也有相应的函数，可以去查查。<br>COCOMO2 模型 略、<br><strong>估算开发时间</strong><br>利用上一步骤得到的所估算的工作量，有一系列模型将工作量的值带进去就会得到相应的开发时间值。书中介绍了 Walston_Felix、原始的 COCOMO 模型、COCOMO2 模型、Putnam 模型。</p><hr><h3 id="制定进度计划表-图"><a href="#制定进度计划表-图" class="headerlink" title="制定进度计划表/图"></a>制定进度计划表/图</h3><p>得到开发时间，然后就是根据人员人员数量的资源来自定计划，有两种可视化方法：<br>第一种就是<strong>Gantt 图</strong>：典型的异于流水作业的一种方法，动态调配人员来完成工作<br>第二种就是<strong>工程网络</strong>：用箭头和圆圈来表示整个项目流程，优于 Gantt 图的就是能够实际根据实际项目中的潜力任务来跟踪观察，具体说就是有些任务可能在实际过程中，用原先指定的时间或人员不一定能高效完成，逾期或是提前很久完成等等这种情况。<br>工程网络功能可以估算工程的进度，在工程网络里面加上一些时间数字，可以灵活地查看并计算工程的计划时间。<br>工程网络还可以计算出机动时间。<br>其实在实际过程中，这两种方法都是并用的。</p><hr><h3 id="人员组织"><a href="#人员组织" class="headerlink" title="人员组织"></a>人员组织</h3><p>人员组织在所经历的阶段中，经过多次变革，书中介绍有，最初的民主制程序员组 👉 主程序员<br>组 👉 现代程序员组<br>只介绍现代程序员组，其实这个在历史中也分两种，第一种是根据职能不同分成两个组长，这种方式不能根治这过程中的软件危机，不详细讲述，第二种就是现在常说的项目经理管理下调配的，项目经理管多个组长，各个组长管理下面的多个程序员，并且，在组长与组长之间可以进行该层的交流，程序员层也一样，但是项目经理就是在该项目中的天花板了，没人管得了……</p><hr><h3 id="软件配置管理、质量保证、能力成熟度模型"><a href="#软件配置管理、质量保证、能力成熟度模型" class="headerlink" title="软件配置管理、质量保证、能力成熟度模型"></a>软件配置管理、质量保证、能力成熟度模型</h3><p>这三个就是项目管理过程中一些概念之类的，其中软件配置管理讲究动态二字，因为随着时间抑或是用户需求的推移，软件配置势必会改变，这时候就需要即时更新相应配置<br>后两者是对软件完成的收尾相关工作了。</p>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 软件工程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成原理知识点回顾</title>
      <link href="/blog/pnf49g/"/>
      <url>/blog/pnf49g/</url>
      
        <content type="html"><![CDATA[<blockquote><p>利用一些基本的问题简单回顾一下这学期学的计组的基本知识点。</p></blockquote><h2 id="概论"><a href="#概论" class="headerlink" title="概论"></a>概论</h2><blockquote><p>电子数字计算机和电子模拟计算机的区别是什么？</p></blockquote><p>电子数字计算机处理的信息是<strong>离散</strong>的，运算过程是离散的<br>电子模拟计算机处理的信号时<strong>连续</strong>的，运算过程是连续的</p><blockquote><p>冯诺依曼计算机的特点是什么？其中最主要的一点是什么？</p></blockquote><ol><li>计算机由运算器、控制器、存储器、输入系统、输出系统<strong>五大部件</strong>组成（注意中央处理器是运算器和控制器的合称）</li><li>计算机内部由<strong>二进制编码</strong>指令和数据</li><li>将编好的数据和程序<strong>先放</strong>入存储器中，然后<strong>再启动</strong>计算机工作</li></ol><p>其中最主要的一点是第三点最主要！</p><h2 id="数据的机器层次表示"><a href="#数据的机器层次表示" class="headerlink" title="数据的机器层次表示"></a>数据的机器层次表示</h2><blockquote><p>机器数的原码+反码+补码表示</p></blockquote><p>定点小数表示：阶码：小数点位数；尾数：在小数那里编码即可</p><p>真值就是加正负所表现出来的</p><blockquote><p>给定计算机字长位数，知道各种情况下表示数值的范围</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1608863188017-8f6c8d66-710e-4880-8559-af59c6e37609.png#align=left&display=inline&height=356&margin=%5Bobject%20Object%5D&name=image.png&originHeight=712&originWidth=1315&size=336629&status=done&style=shadow&width=657.5" alt="image.png"></p><h2 id="数值的机器运算"><a href="#数值的机器运算" class="headerlink" title="数值的机器运算"></a>数值的机器运算</h2><blockquote><p>定点加减运算+判断结果是否溢出</p></blockquote><ol><li>先写出两个数的补码（减法运算转换为加法运算即可）</li><li>然后进行二进制加法运算（遵循 0+0=0，1+0=1，0+1=1，1+1=10 向高位进位）</li><li>判断是否溢出【00：结果为正无溢出；01：正溢；10：负溢；11 结果为负无溢出】</li><li>将[X+Y]补转换为[X+Y]真值<blockquote><p>定点乘法运算：原码一位乘法运算+补码一位乘法运算</p></blockquote></li></ol><p>原码一位乘法运算：</p><ol><li>先写出 X 和 Y 的绝对值|X|和|Y|</li><li>让 00.0……和|X|相加同时判断|Y|的最后一位（如果为 1 加|X|如果是 0 加 0）</li><li>加完之后右移一位，再判断，加了再判断，啥时候那个分隔符分没了，就好了……………</li><li>最后判断真值符号</li></ol><p>我写的个啥………………逃</p><p>补码一位乘法运算：</p><ol><li>写出[X]补[-X]补[Y]补</li><li>在[Y]补码尾巴后面加一个 0，判断最后两位，（00 加 0；10 加[-X]补；01 加[X]补；11 加 0）</li><li>让 00.000……加上上面判断的加上某某</li><li>又一直这样下去下去……</li><li>把补码换成原码即可……</li></ol><p>…………逃 🤣</p><h2 id="指令系统"><a href="#指令系统" class="headerlink" title="指令系统"></a>指令系统</h2><blockquote><p>什么叫主程序和子程序？调用子程序还可以采用哪几种方法保存返回地址？画出图说明调用子程序的过程。</p></blockquote><p>主程序：<strong>通常</strong>的程序<br>**<br>子程序：可以被反复调用、<strong>公用</strong>的程序，只要知道其**入口地址**，就可以调用之，其就是我们编程常写的函数</p><p>保存返回地址的方法：</p><ul><li>子程序的第一个<strong>子单元</strong>存放返回地址，然后从第二个字单元开始执行子程序</li><li><strong>寄存器</strong>存放</li><li><strong>堆栈</strong>保存</li></ul><p>以堆栈保存返回地址的方法来说明调用子程序的过程：<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1608774330112-3e8bf3df-1091-4476-aa72-e9757e36a3e6.png#align=left&display=inline&height=77&margin=%5Bobject%20Object%5D&name=image.png&originHeight=154&originWidth=242&size=22896&status=done&style=shadow&width=121" alt="image.png"></p><blockquote><p>如果某计算机调用子程序保存返回地址是上个问题的第一种方式，有这么几个问题：</p><ol><li>为这种方法设计一条从子程序转到主程序的返回指令</li><li>怎么在主程序和子程序之间进行传参</li><li>可否用于子程序嵌套</li><li>可否用于子程序的递归</li><li>如果将该种方式改为第三种方式（堆栈方式），可否完成 4</li></ol></blockquote><ol><li>使用间接寻址方式</li></ol><table><thead><tr><th>JMP</th><th>@</th><th>子程序首地址</th></tr></thead></table><ol start="2"><li>可以利用寄存器或主存单元进行主、子程序间的参数传递</li><li>可以。返回的地址都放在子程序的第一个单元</li><li>不可以。会破坏其内部结构</li><li>可以。因为堆栈具有后进先出功能</li></ol><h2 id="存储系统和结构"><a href="#存储系统和结构" class="headerlink" title="存储系统和结构"></a>存储系统和结构</h2><blockquote><p>如何区别存储器和寄存器？两者是一回事说法对吗？</p></blockquote><p>两者不是一回事。</p><p>存储器是在<strong>CPU</strong>外边，用来存放数据和程序的，访问存储器的<strong>速度</strong>较慢；</p><p>寄存器数据 CPU 的一部分，访问寄存器的速度很快。<br>**</p><blockquote><p>存储器的主要功能是什么？为什么把存储系统分成若干个不同层次？主要有那些层次？</p></blockquote><p>存储器的主要功能：存储数据和程序</p><p>存储系统是有几个<strong>容量、速度、价格</strong>不同的存储器用硬件、软件、软硬件相结合起来的系统。分成若干个不同层次是因为考虑到不同存储器的价格因素、存储速度、存储容量三个因素。</p><ol><li>高速缓存</li><li>主存</li><li>辅存</li></ol><p>其中 12 又称之为 Cache-主存存储层次，23 又称之为主存-辅存存储层次。</p><blockquote><p>动态 RAM 为什么要刷新？一般有几种刷新方式？各有什么优缺点？</p></blockquote><p><strong>为了维持 DRAM 的记忆单元的存储信息</strong></p><ul><li><strong>集中式</strong>刷新</li></ul><p>优点：<strong>读写操作</strong>不受刷新工作的影响，<strong>存取速度</strong>高</p><p>缺点：存储容量越大，死区越长</p><ul><li><strong>分散式</strong>刷新</li></ul><p>优点：没有死区</p><p>缺点：加长了系统的<strong>存取周期</strong>，降低了整机的速度，并且刷新过于频繁，没有充分利用允许的最大刷新间隔</p><ul><li><strong>异步式</strong>刷新</li></ul><p>异步式虽然有死区，但是比几种方式的<strong>死区小</strong>得多，而且<strong>减少了刷新次数</strong>，是比较实用的一种刷新方式。</p><h2 id="中央处理器"><a href="#中央处理器" class="headerlink" title="中央处理器"></a>中央处理器</h2><hr><blockquote><p>控制器有哪几种控制方式？各有何特点？</p></blockquote><ul><li><strong>同步</strong>控制方式</li></ul><p>该控制方式各项操作都由统一的<strong>时序信号</strong>完成，并且在每个及其周期中产生统一的<strong>节拍电位和工作脉冲</strong>。这种方式设计简单，但是对于许多<strong>单指令</strong>来说，有太多的<strong>空闲时间</strong>，造成时间浪费，影响指令执行速度。</p><ul><li><strong>异步</strong>控制方式</li></ul><p>该控制方式的各项操作都<strong>不由统一的时序信号</strong>完成，而是由指令本身或部件的具体情况决定，因此这种控制方式的效率高，时间能够合理利用，但是该控制方式也比较复杂。</p><ul><li><strong>联合</strong>控制方式</li></ul><p>是由上面的同步控制方式和异步控制方式相结合的方式。</p><hr><blockquote><p>什么是三级时序系统？</p></blockquote><p>三级时序系统是指<strong>机器周期</strong>、<strong>节拍</strong>、<strong>工作脉冲</strong></p><p>具体所属关系是：每个指令周期划分若干个机器周期，每个机器周期划分若干个节拍，每个节拍划分 1 个或几个工作脉冲。</p><hr><blockquote><p>控制器有哪些基本功能？可分为哪几类？分类的依据是什么？</p></blockquote><p>基本功能：</p><ul><li>从主存中<strong>取出一条指令</strong>，并指出下一跳指令在主存中的位置</li><li>对指令进行<strong>译码或是测试</strong>，产生相应的操作控制信号，以便启动规定的工作</li><li>指挥并控制<strong>CPU</strong>，主存和输入输出设备之间的<strong>数据流动</strong></li></ul><p>分类：</p><ul><li><strong>组合逻辑</strong>型</li><li><strong>存储逻辑</strong>型</li><li>组合逻辑和存储逻辑<strong>结合</strong>型</li></ul><p>分类的依据：<br>在于控制器的核心——<strong>微操作信号发生器的实现方法不同</strong>。</p><hr><blockquote><p>中央处理器有哪些功能？它是由那些基本部件构成的？</p></blockquote><p>构成：</p><ul><li>控制器</li><li>运算器</li></ul><p>功能：<br>对数据流和指令流在时间上和空间上进行正确的控制。当然，对于冯诺依曼结构的计算机而言，数据流是基于指令流的操作而驱动的。</p><hr><blockquote><p>中央处理器有哪几个主要寄存器？说说他们的结构和功能？</p></blockquote><p>寄存器的功能就是用来存放程序运行过程中的中间结果、最终结果以及控制、状态信息的。</p><ul><li>通用寄存器</li></ul><p>用来存放原始数据和运算结果，有的还可以作为变址寄存器、计数器、地址指针等</p><ul><li>专用寄存器</li></ul><p>是用来完成某些特定功能的寄存器：程序计数器（PC）、指令寄存器（IR）、存储器地址寄存器（MAR）、存储器数据寄存器（MDR）、程序状态字寄存器（PSWR）等</p><blockquote><p>以单指令为例，简要说明下列部件在计算机的取值周期和执行周期的作用。</p></blockquote><ul><li>程序计数器（PC）：存放指令地址</li><li>指令寄存器（IR）：存放当前指令</li><li>存储器地址寄存器（MAR）：进行算术逻辑运算</li><li>存储器数据寄存器（MDR）：存放写入或读出的数据/指令</li><li>程序状态字寄存器（PSWR）：存放写入或读出的数据/指令的地址</li></ul><hr><blockquote><p>什么是指令周期？什么是 CPU 周期？他们之间有什么关系？</p></blockquote><p>指令周期：指<strong>取指令</strong>、<strong>分析指令</strong>到<strong>执行指令</strong>所花费的所有时间</p><p>CPU 周期：也叫<strong>机器周期</strong>，是指完成一个基本操作所花费的时间<br>一个指令周期划分为多个 CPU 周期</p><hr><h2 id="【总线-外部设备】nothing"><a href="#【总线-外部设备】nothing" class="headerlink" title="【总线+外部设备】nothing"></a>【总线+外部设备】nothing</h2><h2 id="输入输出系统"><a href="#输入输出系统" class="headerlink" title="输入输出系统"></a>输入输出系统</h2><hr><blockquote><p>什么是计机的输入输出系统？输入输出设备有哪些编址方式？有什么特点？</p></blockquote><p>输入输出系统：包括输入输出<strong>接口</strong>和输入输出信息<strong>传送</strong>控制方式，是计算机系统中最具有<strong>多样性</strong>和<strong>复杂性</strong>的部分。</p><p>编址方式：</p><ul><li><strong>独立编址</strong></li></ul><p>优点：指令易于区分，译码简单，主存空间不会减少</p><p>缺点：增加了控制线 I/ORead 和 I/OWrite 信号</p><ul><li><strong>统一编址</strong></li></ul><p>优点：总线结构简单，全部访存类指令都可用于控制外设，可直接对外设寄存器进行各种运算</p><p>缺点：占用主存一部分地址，缩小了可用的主存空间</p><hr><blockquote><p>什么是 I/O 接口？I/O 接口有哪些特点和功能？接口有哪些类型？</p></blockquote><p>主机和外设之间的交接界面</p><p>特点：<br>实现信息交换</p><p>功能：</p><ul><li>实现主机和外设的通信联络控制</li><li>进行地址译码和设备选择</li><li>实现数据缓冲</li><li>完成数据格式的变换</li><li>传递控制命令和状态信息</li></ul><p>类型：</p><ul><li>串行接口</li><li>并行接口</li></ul><hr><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1608728980150-18e3d2ee-cc80-4187-b38c-14c78554e979.png#align=left&display=inline&height=152&margin=%5Bobject%20Object%5D&name=image.png&originHeight=198&originWidth=766&size=190453&status=done&style=none&width=589" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1608729028676-c983dd94-3689-431d-bf54-76bbb5b01f75.png#align=left&display=inline&height=80&margin=%5Bobject%20Object%5D&name=image.png&originHeight=160&originWidth=788&size=111323&status=done&style=none&width=394" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1608729049887-aee5cd74-e49d-44d1-88b2-bcdc511ff3c3.png#align=left&display=inline&height=107&margin=%5Bobject%20Object%5D&name=image.png&originHeight=214&originWidth=968&size=213320&status=done&style=none&width=484" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1608729065956-47dc5b50-caaa-44a1-a54e-8e3f5ae2192a.png#align=left&display=inline&height=172&margin=%5Bobject%20Object%5D&name=image.png&originHeight=343&originWidth=687&size=119088&status=done&style=none&width=343.5" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1608729081886-f27d6175-e541-4379-b158-0093a23b693d.png#align=left&display=inline&height=139&margin=%5Bobject%20Object%5D&name=image.png&originHeight=277&originWidth=922&size=156708&status=done&style=none&width=461" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1608729097801-61fd270b-1608-48ab-b1fa-a951febba5d6.png#align=left&display=inline&height=87&margin=%5Bobject%20Object%5D&name=image.png&originHeight=173&originWidth=907&size=129678&status=done&style=none&width=453.5" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1608729108461-95f5d6e5-efd6-4acf-a2c7-fb72f6052d25.png#align=left&display=inline&height=71&margin=%5Bobject%20Object%5D&name=image.png&originHeight=141&originWidth=897&size=100962&status=done&style=none&width=448.5" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1608729131667-e6955db4-4b2c-4efb-ad1f-3acf8ccc5e48.png#align=left&display=inline&height=315&margin=%5Bobject%20Object%5D&name=image.png&originHeight=630&originWidth=974&size=493234&status=done&style=none&width=487" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1608729144873-1a207e20-98d9-4e44-b40e-c1a81a54b667.png#align=left&display=inline&height=195&margin=%5Bobject%20Object%5D&name=image.png&originHeight=390&originWidth=968&size=379559&status=done&style=none&width=484" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1608729157489-b3899992-00d9-405b-8f02-9619f08d9960.png#align=left&display=inline&height=193&margin=%5Bobject%20Object%5D&name=image.png&originHeight=386&originWidth=938&size=349548&status=done&style=none&width=469" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1608729176250-7499ab5f-2a40-4514-92f3-afc46c739936.png#align=left&display=inline&height=275&margin=%5Bobject%20Object%5D&name=image.png&originHeight=549&originWidth=1005&size=475058&status=done&style=none&width=502.5" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>VuePress初体验</title>
      <link href="/blog/czl3oc/"/>
      <url>/blog/czl3oc/</url>
      
        <content type="html"><![CDATA[<h2 id="安装-Yarn"><a href="#安装-Yarn" class="headerlink" title="安装 Yarn"></a>安装 Yarn</h2><blockquote><p>Yarn 是为了弥补 npm 的一些缺陷而生的</p></blockquote><p>具体参考：<a href="https://zhuanlan.zhihu.com/p/27449990">https://zhuanlan.zhihu.com/p/27449990</a></p><h3 id="引导式安装"><a href="#引导式安装" class="headerlink" title="引导式安装"></a>引导式安装</h3><p><a href="https://classic.yarnpkg.com/zh-Hans/docs/install#windows-stable">下载地址</a><br>使用 Windows 版的下载安装即可<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1608540352757-ed3ef592-f042-4262-9378-42aa9d053fcd.png#align=left&display=inline&height=35&id=cUHeI&margin=%5Bobject%20Object%5D&name=image.png&originHeight=69&originWidth=433&size=3803&status=done&style=none&width=216.5" alt="image.png"></p><h3 id="bash-安装"><a href="#bash-安装" class="headerlink" title="bash 安装"></a>bash 安装</h3><p>在 bash 里面不能显示，在 bash 里面下载<br><code>npm install -g yarn</code> 即可</p><h2 id="将-VuePress-安装为本地依赖"><a href="#将-VuePress-安装为本地依赖" class="headerlink" title="将 VuePress 安装为本地依赖"></a>将 VuePress 安装为本地依赖</h2><h3 id="yarn-init"><a href="#yarn-init" class="headerlink" title="yarn init"></a>yarn init</h3><p>yarn init 出错</p><pre><code class="bash">error An unexpected error occurred: &quot;Can&#39;t answer a question unless a user TTY&quot;. info If you think t</code></pre><p><strong>使用 cmd 或者 power shell 不要使用 bash</strong></p><h3 id="yarn-add-D-vuepress"><a href="#yarn-add-D-vuepress" class="headerlink" title="yarn add -D vuepress"></a>yarn add -D vuepress</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1608541125538-3124ff43-0574-4bfd-a290-908621b54644.png#align=left&display=inline&height=272&id=wwNV3&margin=%5Bobject%20Object%5D&name=image.png&originHeight=543&originWidth=1920&size=147908&status=done&style=none&width=960" alt="image.png"></p><h3 id="创建一篇文章"><a href="#创建一篇文章" class="headerlink" title="创建一篇文章"></a>创建一篇文章</h3><p>在 bash 创建，在 powershell 里面创建会报错</p><pre><code class="bash">mkdir docs &amp;&amp; echo &#39;# Hello VuePress&#39; &gt; docs/README.md</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1608541380531-3ad1565f-0eef-4dac-bebf-64d1a131d7f3.png#align=left&display=inline&height=105&id=RwhmG&margin=%5Bobject%20Object%5D&name=image.png&originHeight=210&originWidth=1160&size=36343&status=done&style=none&width=580" alt="image.png"></p><h3 id="添加脚本"><a href="#添加脚本" class="headerlink" title="添加脚本"></a>添加脚本</h3><pre><code class="json">&#123;  &quot;name&quot;: &quot;my-site&quot;,  &quot;version&quot;: &quot;1.0.0&quot;,  &quot;main&quot;: &quot;index.js&quot;,  &quot;license&quot;: &quot;MIT&quot;,  &quot;devDependencies&quot;: &#123;    &quot;vuepress&quot;: &quot;^1.7.1&quot;  &#125;,  &quot;scripts&quot;: &#123;    &quot;docs:dev&quot;: &quot;vuepress dev docs&quot;,    &quot;docs:build&quot;: &quot;vuepress build docs&quot;  &#125;&#125;</code></pre><h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1608541418296-b53b29dc-f6a9-480f-b65d-009a21c0d013.png#align=left&display=inline&height=237&id=YrVlg&margin=%5Bobject%20Object%5D&name=image.png&originHeight=474&originWidth=951&size=59046&status=done&style=none&width=475.5" alt="image.png"><br>端口访问：<a href="http://localhost:8080/">http://localhost:8080/</a></p>]]></content>
      
      
      <categories>
          
          <category> ✨其他 </category>
          
          <category> 玩转博客 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[转]低谷</title>
      <link href="/essay/vpzzbr/"/>
      <url>/essay/vpzzbr/</url>
      
        <content type="html"><![CDATA[<blockquote><p>不要害怕低谷，这是上天给你的升级时间<br>有个好玩的现象，我这里的畅销书，绝大多数是在作者低谷的时候写出来的。比如创业失败、被公司裁员、或者身体不好在家休息等等。</p><p>为什么呢？因为事业上升时，人被事情推着走，每天忙忙碌碌，没有一块时间思考和复盘。<br>进入低谷后，时间充足，可以好好整理思想了，把以前的经验体系化，于是一本畅销书横空出世。更重要的是，这本书已成为他的视野催化剂，走向人生的第二巅峰。</p><p>低谷不可怕，可怕的是一蹶不振啊。</p><p><strong>转载自：写书哥（同微博）</strong></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CSS的高级使用技巧</title>
      <link href="/blog/rpd10b/"/>
      <url>/blog/rpd10b/</url>
      
        <content type="html"><![CDATA[<p>这是加密文章！</p>]]></content>
      
      
      <categories>
          
          <category> 👨‍💻Web开发 </category>
          
          <category> HTML+CSS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>搭建“文本三巨头”环境</title>
      <link href="/blog/yhxiep/"/>
      <url>/blog/yhxiep/</url>
      
        <content type="html"><![CDATA[<h2 id="Vim"><a href="#Vim" class="headerlink" title="Vim"></a>Vim</h2><h3 id="Vim-下载安装"><a href="#Vim-下载安装" class="headerlink" title="Vim 下载安装"></a>Vim 下载安装</h3><p><a href="https://www.vim.org/download.php">下载地址</a><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1608357192619-ac3d093e-c4e4-49fa-9a3b-8ead607b2160.png#align=left&display=inline&height=299&margin=%5Bobject%20Object%5D&name=image.png&originHeight=598&originWidth=1919&size=248340&status=done&style=none&width=959.5" alt="image.png"><br>下载完之后 next 安装即可</p><h3 id="Vim-环境变量配置"><a href="#Vim-环境变量配置" class="headerlink" title="Vim 环境变量配置"></a>Vim 环境变量配置</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1608357482468-e6a53bc3-991d-4eda-aa2e-c5643b9617b0.png#align=left&display=inline&height=89&margin=%5Bobject%20Object%5D&name=image.png&originHeight=177&originWidth=602&size=11434&status=done&style=none&width=301" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1608357463679-c00baef1-4e21-4405-8e79-f65afabe0370.png#align=left&display=inline&height=469&margin=%5Bobject%20Object%5D&name=image.png&originHeight=938&originWidth=976&size=105454&status=done&style=none&width=488" alt="image.png"></p><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1608357601712-bc8f6f5b-6038-4358-8699-a7201ce8223e.png#align=left&display=inline&height=112&margin=%5Bobject%20Object%5D&name=image.png&originHeight=225&originWidth=1468&size=22708&status=done&style=none&width=734" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1608357572830-fd4043b2-f02a-4c32-b9e7-677c4918ec19.png#align=left&display=inline&height=383&margin=%5Bobject%20Object%5D&name=image.png&originHeight=766&originWidth=1442&size=64262&status=done&style=none&width=721" alt="image.png"></p><h2 id="zsh"><a href="#zsh" class="headerlink" title="zsh"></a>zsh</h2><h3 id="安装-Linux-子系统"><a href="#安装-Linux-子系统" class="headerlink" title="安装 Linux 子系统"></a>安装 Linux 子系统</h3><p>查看之前写的文章：<a href="https://www.wztlink1013.com/blog/xnh83z/">搭建 Windows 子系统 Linux - 尼采般地抒情</a></p><h3 id="安装-ConEmu"><a href="#安装-ConEmu" class="headerlink" title="安装 ConEmu"></a>安装 ConEmu</h3><p><a href="https://www.fosshub.com/ConEmu.html">https://www.fosshub.com/ConEmu.html</a><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1608358847174-3a3b7ba1-45e8-4951-a943-debd2a09de43.png#align=left&display=inline&height=217&margin=%5Bobject%20Object%5D&name=image.png&originHeight=434&originWidth=1904&size=80285&status=done&style=none&width=952" alt="image.png"><br>设置如下：<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1608358926353-c172728f-978e-47f7-9ec5-34472219ccdb.png#align=left&display=inline&height=376&margin=%5Bobject%20Object%5D&name=image.png&originHeight=751&originWidth=1143&size=84693&status=done&style=none&width=571.5" alt="image.png"><br>确定后会进入以下界面<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1608358964494-c12c30a4-4b04-4463-b3d6-3c5fc21b607f.png#align=left&display=inline&height=359&margin=%5Bobject%20Object%5D&name=image.png&originHeight=717&originWidth=970&size=40132&status=done&style=none&width=485" alt="image.png"></p><h3 id="安装并配置-zsh"><a href="#安装并配置-zsh" class="headerlink" title="安装并配置 zsh"></a>安装并配置 zsh</h3><p>进入页面 <code>sudo apt-get install -y zsh</code> ，输入密码：<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1608359167583-80d5f5fd-77e6-417d-ac0c-279dbfb55776.png#align=left&display=inline&height=300&margin=%5Bobject%20Object%5D&name=image.png&originHeight=600&originWidth=960&size=64893&status=done&style=none&width=480" alt="image.png"><br>安装成功界面如下：<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1608360612991-863a5a2e-77a2-4bd7-b1b9-4ef6a79dcb86.png#align=left&display=inline&height=456&margin=%5Bobject%20Object%5D&name=image.png&originHeight=912&originWidth=1908&size=196509&status=done&style=none&width=954" alt="image.png"></p><h3 id="安装-oh-my-zsh"><a href="#安装-oh-my-zsh" class="headerlink" title="安装 oh-my-zsh"></a>安装 oh-my-zsh</h3><p>sh -c “$(curl -fsSL <a href="https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh">https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)”</a>%22)<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1608360763102-d6886d61-c954-4c15-adfc-ca42c0daf337.png#align=left&display=inline&height=411&margin=%5Bobject%20Object%5D&name=image.png&originHeight=821&originWidth=1908&size=125769&status=done&style=none&width=954" alt="image.png"><br>上述文件夹在这里： <code>C:\Users\wztli\AppData\Local\Packages\CanonicalGroupLimited.UbuntuonWindows_79rhkp1fndgsc\LocalState\rootfs\home\wztlink1013</code></p><h2 id="tmux"><a href="#tmux" class="headerlink" title="tmux"></a>tmux</h2><h3 id="安装运行"><a href="#安装运行" class="headerlink" title="安装运行"></a>安装运行</h3><p>Ubuntu 系统命令行界面输入： <code>sudo apt install tmux</code></p><p>在 Ubuntu 系统输入并执行”tmux”命令，会进入 tmux 窗口</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.jianshu.com/p/5f7b83ca3952">https://www.jianshu.com/p/5f7b83ca3952</a></li><li><a href="https://post.smzdm.com/p/a5k6e033/">https://post.smzdm.com/p/a5k6e033/</a></li><li><a href="https://blog.csdn.net/qq_2300688967/article/details/81774297">https://blog.csdn.net/qq_2300688967/article/details/81774297</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 🔨环境工具 </category>
          
          <category> 环境搭建 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>150.逆波兰表达式求值🔖栈</title>
      <link href="/blog/ewoap5/"/>
      <url>/blog/ewoap5/</url>
      
        <content type="html"><![CDATA[<h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>对所给字符串进行遍历，遇到数字字符就压入栈 stack 内，遇到+-*/符号就 pop 处栈的两个元素，进行该字符运算处理</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><pre><code class="java">package com.wztlink1013.problems.leetcode.editor.cn;// P150.逆波兰表达式求值// P150.evaluate-reverse-polish-notation//根据 逆波兰表示法，求表达式的值。//// 有效的运算符包括 +, -, *, / 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。//////// 说明：////// 整数除法只保留整数部分。// 给定逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。////////// 示例 1：//// 输入: [&quot;2&quot;, &quot;1&quot;, &quot;+&quot;, &quot;3&quot;, &quot;*&quot;]//输出: 9//解释: 该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) = 9////// 示例 2：//// 输入: [&quot;4&quot;, &quot;13&quot;, &quot;5&quot;, &quot;/&quot;, &quot;+&quot;]//输出: 6//解释: 该算式转化为常见的中缀算术表达式为：(4 + (13 / 5)) = 6////// 示例 3：//// 输入: [&quot;10&quot;, &quot;6&quot;, &quot;9&quot;, &quot;3&quot;, &quot;+&quot;, &quot;-11&quot;, &quot;*&quot;, &quot;/&quot;, &quot;*&quot;, &quot;17&quot;, &quot;+&quot;, &quot;5&quot;, &quot;+&quot;]//输出: 22//解释://该算式转化为常见的中缀算术表达式为：//  ((10 * (6 / ((9 + 3) * -11))) + 17) + 5//= ((10 * (6 / (12 * -11))) + 17) + 5//= ((10 * (6 / -132)) + 17) + 5//= ((10 * 0) + 17) + 5//= (0 + 17) + 5//= 17 + 5//= 22//////// 逆波兰表达式：//// 逆波兰表达式是一种后缀表达式，所谓后缀就是指算符写在后面。////// 平常使用的算式则是一种中缀表达式，如 ( 1 + 2 ) * ( 3 + 4 ) 。// 该算式的逆波兰表达式写法为 ( ( 1 2 + ) ( 3 4 + ) * ) 。////// 逆波兰表达式主要有以下两个优点：////// 去掉括号后表达式无歧义，上式即便写成 1 2 + 3 4 + * 也可以依据次序计算出正确结果。// 适合用栈操作运算：遇到数字则入栈；遇到算符则取出栈顶两个数字进行计算，并将结果压入栈中。//// Related Topics 栈// 👍 213 👎 0import java.util.Stack;public class P150EvaluateReversePolishNotation&#123;    public static void main(String[] args) &#123;        Solution solution = new P150EvaluateReversePolishNotation().new Solution();        String[] tokens_1 = &#123;&quot;10&quot;, &quot;6&quot;, &quot;9&quot;, &quot;3&quot;, &quot;+&quot;, &quot;-11&quot;, &quot;*&quot;, &quot;/&quot;, &quot;*&quot;, &quot;17&quot;, &quot;+&quot;, &quot;5&quot;, &quot;+&quot;&#125;;        int temp = solution.evalRPN(tokens_1);        System.out.println(temp);    &#125;//leetcode submit region begin(Prohibit modification and deletion)class Solution &#123;    public int evalRPN(String[] tokens) &#123;        Stack&lt;String&gt; stack = new Stack&lt;&gt;();        String temp = &quot;0&quot;;        stack.push(temp);        for (String token : tokens) &#123;            int sum = 0;            if (token.equals(&quot;+&quot;)) &#123;                sum += Integer.parseInt(stack.pop()) + Integer.parseInt(stack.pop());                String str = String.valueOf(sum);                stack.push(str);            &#125; else if (token.equals(&quot;-&quot;)) &#123;                int i = Integer.parseInt(stack.pop());                int j = Integer.parseInt(stack.pop());                sum += j-i;                String str = String.valueOf(sum);                stack.push(str);            &#125; else if (token.equals(&quot;*&quot;)) &#123;                sum += Integer.parseInt(stack.pop()) * Integer.parseInt(stack.pop());                String str = String.valueOf(sum);                stack.push(str);            &#125; else if (token.equals(&quot;/&quot;)) &#123;                int i = Integer.parseInt(stack.pop());                int j = Integer.parseInt(stack.pop());                sum += j / i;                String str = String.valueOf(sum);                stack.push(str);            &#125; else &#123;                stack.push(token);            &#125;        &#125;        int result = Integer.parseInt(stack.pop());        return result;    &#125;&#125;//leetcode submit region end(Prohibit modification and deletion)&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> Problems </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>hexo-部署出错at formatNunjucksError</title>
      <link href="/blog/gw1d4z/"/>
      <url>/blog/gw1d4z/</url>
      
        <content type="html"><![CDATA[<h2 id="报错信息"><a href="#报错信息" class="headerlink" title="报错信息"></a>报错信息</h2><p>GitHub Actions 流程中 hexo g 出现错误，具体错误在“Vue 笔记”中那篇文章中，有个地方用到了大括号嵌套的情况。</p><pre><code class="bash">    =====             Context Dump Ends            =====    at formatNunjucksError (/home/runner/work/website/website/node_modules/hexo/lib/extend/tag.js:102:13)    at Promise.fromCallback.catch.err (/home/runner/work/website/website/node_modules/hexo/lib/extend/tag.js:124:34)    at tryCatcher (/home/runner/work/website/website/node_modules/bluebird/js/release/util.js:16:23)    at Promise._settlePromiseFromHandler (/home/runner/work/website/website/node_modules/bluebird/js/release/promise.js:547:31)    at Promise._settlePromise (/home/runner/work/website/website/node_modules/bluebird/js/release/promise.js:604:18)    at Promise._settlePromise0 (/home/runner/work/website/website/node_modules/bluebird/js/release/promise.js:649:10)    at Promise._settlePromises (/home/runner/work/website/website/node_modules/bluebird/js/release/promise.js:725:18)    at _drainQueueStep (/home/runner/work/website/website/node_modules/bluebird/js/release/async.js:93:12)    at _drainQueue (/home/runner/work/website/website/node_modules/bluebird/js/release/async.js:86:9)    at Async._drainQueues (/home/runner/work/website/website/node_modules/bluebird/js/release/async.js:102:5)    at Immediate.Async.drainQueues [as _onImmediate] (/home/runner/work/website/website/node_modules/bluebird/js/release/async.js:15:14)    at runCallback (timers.js:705:18)    at tryOnImmediate (timers.js:676:5)    at processImmediate (timers.js:658:5)Error: Process completed with exit code 2.</code></pre><h2 id="问题分析与解决"><a href="#问题分析与解决" class="headerlink" title="问题分析与解决"></a>问题分析与解决</h2><p>上述代码中第二行其实已经说的很明确 <code> at formatNunjucksError</code><br>但是 hexo 中，渲染过程中用到的是 Nunjucks，在 Nunjucks 中双大括号被视为语法，所以报错。</p><h2 id="小记"><a href="#小记" class="headerlink" title="小记"></a>小记</h2><p><a href="https://www.wztlink1013.com/blog/pxpix4/">https://www.wztlink1013.com/blog/pxpix4/</a></p><p>其实之前遇到过类似的问题……写的博客还是要经常回顾……</p>]]></content>
      
      
      <categories>
          
          <category> ✨其他 </category>
          
          <category> Bug </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>GitHub多人协作功能Pull requests</title>
      <link href="/blog/iwvugw/"/>
      <url>/blog/iwvugw/</url>
      
        <content type="html"><![CDATA[<h2 id="给出一个初始场景"><a href="#给出一个初始场景" class="headerlink" title="给出一个初始场景"></a>给出一个初始场景</h2><p>小吴和小王同时开发一个项目 project，该项目托管到 GitHub 上，假定该项目托管到小吴的 GitHub 上，小王要想同时开发这个 project，就必须要 fork 小吴的这个 project，最后两个人 GitHub 仓库是这个样子的：</p><p>小吴：xiaowu/project<br>小王：xiaowang/project</p><p>（需要明确一点，小吴小王各自的 project 仓库现在就相当各做各的事情了）</p><h2 id="具体工作场景"><a href="#具体工作场景" class="headerlink" title="具体工作场景"></a>具体工作场景</h2><p>小王的仓库 xiaowang/project 改了代码，想要 push 合并到小吴的仓库 xiaowu/project 中，这里分两种情况。</p><h3 id="第一种情况"><a href="#第一种情况" class="headerlink" title="第一种情况"></a>第一种情况</h3><p><strong>小王在从 fork 小吴仓库到现在这段期间，小吴没有对 xiaowu/project 做任何改动</strong></p><blockquote><p>处理方法：直接 Pull request<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1606915274704-123b219d-d7fe-4816-88c4-91ba11b5c466.png#height=143&id=e0K97&margin=%5Bobject%20Object%5D&name=image.png&originHeight=285&originWidth=1917&originalType=binary%E2%88%B6=1&size=47997&status=done&style=shadow&width=958.5" alt="image.png"> &gt; <img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1606915405152-c1e60a93-99fb-42d5-a7a5-87c564fe53d4.png#height=270&id=Of4D4&margin=%5Bobject%20Object%5D&name=image.png&originHeight=540&originWidth=1920&originalType=binary%E2%88%B6=1&size=80075&status=done&style=shadow&width=960" alt="image.png"><br>可以看到 1 区域显示 Able to merge，表明这个 Pull request 对于双方是没有矛盾的</p></blockquote><h3 id="第二种情况"><a href="#第二种情况" class="headerlink" title="第二种情况"></a>第二种情况</h3><p><strong>小王在从 fork 小吴仓库到现在这段期间，小吴又在 xiaowu/project 里面做了改动，就相当于小王 fork 过后，两个人都对各自的仓库更新了，然后小王想将自己的改动推送到小吴那里</strong></p><blockquote><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1606916524143-c5076532-2497-4923-986f-d442122e6de7.png#height=287&id=YBom8&margin=%5Bobject%20Object%5D&name=image.png&originHeight=574&originWidth=1920&originalType=binary%E2%88%B6=1&size=91126&status=done&style=shadow&width=960" alt="image.png"> &gt; <strong>可以发现 1 处并没有那么顺利，因为产生了冲突，但是 2 处仍然可以新建一个 request 请求，先点击 2</strong> &gt; <img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1606916762342-e5215ae5-cf61-43ac-9051-f73c40de1fb1.png#height=307&id=F7o57&margin=%5Bobject%20Object%5D&name=image.png&originHeight=613&originWidth=1191&originalType=binary%E2%88%B6=1&size=52688&status=done&style=shadow&width=595.5" alt="image.png"> &gt; <strong>点击之后会这样 👇</strong> &gt; <img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1606916826669-b406d584-50a7-49d5-9044-166bba4bc75f.png#height=133&id=D3ARz&margin=%5Bobject%20Object%5D&name=image.png&originHeight=266&originWidth=1284&originalType=binary%E2%88%B6=1&size=32978&status=done&style=shadow&width=642" alt="image.png"><br>1 处显示矛盾的文件（就是小吴和小王在各自的仓库都进行了更改）<br>我们点击 2 处<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1606916998671-6b369cf8-f6dc-4ad3-ba0b-d2f7006b7804.png#height=198&id=nRTI1&margin=%5Bobject%20Object%5D&name=image.png&originHeight=396&originWidth=1920&originalType=binary%E2%88%B6=1&size=65448&status=done&style=shadow&width=960" alt="image.png"><br>接下来解决这个问题并且点击 Mark as resolved 按钮就可以了<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1606917076365-e79652f9-3c56-4259-87d4-b6e979af277d.png#height=181&id=UNqSw&margin=%5Bobject%20Object%5D&name=image.png&originHeight=361&originWidth=1920&originalType=binary%E2%88%B6=1&size=44612&status=done&style=shadow&width=960" alt="image.png"> &gt; <img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1606917146702-bc316303-78f2-4746-94fa-72e4cda90dd0.png#height=196&id=jhbAg&margin=%5Bobject%20Object%5D&name=image.png&originHeight=391&originWidth=1920&originalType=binary%E2%88%B6=1&size=87061&status=done&style=shadow&width=960" alt="image.png"><br>最后就会出现下面的图，接下来，小吴在他的 GitHub 上同意接受这个请求就可以了。（或者小王有权限小王自己接受也可以）<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1606917264180-37c25758-4db9-44f8-a3f6-0ca725d6c0fd.png#height=435&id=Z5Awy&margin=%5Bobject%20Object%5D&name=image.png&originHeight=869&originWidth=1435&originalType=binary%E2%88%B6=1&size=132722&status=done&style=shadow&width=717.5" alt="image.png"></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> Git+GitHub </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>224.基本计算器🔖栈</title>
      <link href="/blog/ckr31m/"/>
      <url>/blog/ckr31m/</url>
      
        <content type="html"><![CDATA[<h2 id="问题思路"><a href="#问题思路" class="headerlink" title="问题思路"></a>问题思路</h2><p>用栈来作为临时存取非括号的求和数。对字符串进行逐个遍历，然后对遇到的每个字符串进行判断</p><ul><li>数字：将其求和到 sum 当中</li><li>（：将上述 sum 和符号压入栈内</li><li>）：将栈内的元素取出与现有 sum 求和</li><li>+：直接走</li><li>-：直接走不过给下一个计算数提前加负号</li></ul><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><pre><code class="java">package com.wztlink1013.problems.leetcode.editor.cn;// P224.基本计算器//实现一个基本的计算器来计算一个简单的字符串表达式的值。//// 字符串表达式可以包含左括号 ( ，右括号 )，加号 + ，减号 -，非负整数和空格 。//// 示例 1://// 输入: &quot;1 + 1&quot;//输出: 2////// 示例 2://// 输入: &quot; 2-1 + 2 &quot;//输出: 3//// 示例 3://// 输入: &quot;(1+(4+5+2)-3)+(6+8)&quot;//输出: 23//// 说明：////// 你可以假设所给定的表达式都是有效的。// 请不要使用内置的库函数 eval。//// Related Topics 栈 数学// 👍 309 👎 0import java.util.Stack;public class P224BasicCalculator&#123;    public static void main(String[] args) &#123;        Solution solution = new P224BasicCalculator().new Solution();        int key_1 = solution.calculate(&quot;7896979&quot;);        int key_2 = solution.calculate(&quot;(23-2)-33+1111&quot;);        System.out.println(key_1);        System.out.println(key_2);    &#125;//leetcode submit region begin(Prohibit modification and deletion)class Solution &#123;    public int calculate(String s) &#123;        Stack&lt;Integer&gt; stack_1 = new Stack&lt;Integer&gt;();        int sum = 0;        int sign = 1;        int num = 0;        for (int i=0;i&lt;s.length();i++) &#123;            char ch = s.charAt(i);            if (Character.isDigit(ch)) &#123;                num = 10 * num + (int) (ch - &#39;0&#39;);            &#125; else if (ch == &#39;+&#39;) &#123;                num = num * sign;                sum = sum + num;                sign = 1;                num = 0;            &#125; else if (ch == &#39;-&#39;) &#123;                num = num * sign;                sum = sum + num;                sign = -1;                num = 0;            &#125; else if (ch == &#39;(&#39;) &#123;                stack_1.push(sum);                stack_1.push(sign);                sum = 0;                num = 0;                sign = 1;            &#125; else if (ch == &#39;)&#39;) &#123;                num = num * sign;                sum = sum + num;                sum = stack_1.pop() * sum;                sum = sum + stack_1.pop();                num = 0;                sign = 1;            &#125;        &#125;        sum = sum + sign * num;        return sum;    &#125;&#125;//leetcode submit region end(Prohibit modification and deletion)&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> Problems </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>sdnu-dboj-Student-Movie</title>
      <link href="/blog/zhdy1x/"/>
      <url>/blog/zhdy1x/</url>
      
        <content type="html"><![CDATA[<blockquote><p>题目入口：<a href="http://db.itoi.sd.cn/problem/set">http://db.itoi.sd.cn/problem/set</a></p></blockquote><h2 id="成绩管理相关题目"><a href="#成绩管理相关题目" class="headerlink" title="成绩管理相关题目"></a>成绩管理相关题目</h2><h3 id="Student-表"><a href="#Student-表" class="headerlink" title="Student 表"></a>Student 表</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1600849205116-d4263820-8bbb-4d01-b97b-a0363f4498e7.png#align=left&display=inline&height=216&margin=%5Bobject%20Object%5D&name=image.png&originHeight=432&originWidth=722&size=41200&status=done&style=shadow&width=361" alt="image.png"></p><h3 id="Course-表"><a href="#Course-表" class="headerlink" title="Course 表"></a>Course 表</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1600849217512-41be815b-8bc4-4b6a-82c2-cbb4d335c9b9.png#align=left&display=inline&height=256&margin=%5Bobject%20Object%5D&name=image.png&originHeight=511&originWidth=632&size=38392&status=done&style=shadow&width=316" alt="image.png"></p><h3 id="SC-表"><a href="#SC-表" class="headerlink" title="SC 表"></a>SC 表</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1600849229639-8d5cd91f-d87e-49e9-a1cd-9c563b64723f.png#align=left&display=inline&height=262&margin=%5Bobject%20Object%5D&name=image.png&originHeight=523&originWidth=492&size=32976&status=done&style=shadow&width=246" alt="image.png"></p><h3 id="初始化-SQL-语句"><a href="#初始化-SQL-语句" class="headerlink" title="初始化 SQL 语句"></a>初始化 SQL 语句</h3><pre><code class="sql">SET NAMES utf8mb4;SET FOREIGN_KEY_CHECKS = 0;/*学生表*/CREATE TABLE Student(    Sno  INT(9) PRIMARY KEY,    Sname VARCHAR(10),    Ssex  CHAR(2),    Sage  TINYINT(3),    Sdept VARCHAR(20));INSERT INTO StudentVALUES (201215121, &#39;李勇&#39;, &#39;男&#39;, 20, &#39;CS&#39;),     (201215122, &#39;刘晨&#39;, &#39;女&#39;, 19, &#39;CS&#39;),    (201215123, &#39;王敏&#39;, &#39;女&#39;, 18, &#39;MA&#39;),    (201215125, &#39;张立&#39;, &#39;男&#39;, 19, &#39;IS&#39;),    (201215133, &#39;张三&#39;, &#39;男&#39;, 21, &#39;TE&#39;),     (201215137, &#39;赵四&#39;, &#39;男&#39;, 23, &#39;TE&#39;),     (201215139, &#39;田二&#39;, &#39;女&#39;, 24, &#39;CS&#39;),     (201215140, &#39;李四&#39;, &#39;男&#39;, 21, &#39;CS&#39;),     (201215141, &#39;郑五&#39;, &#39;女&#39;, 22, &#39;IS&#39;);/*课程表*/CREATE TABLE Course(    Cno      INT(4) PRIMARY KEY,    Cname     VARCHAR(40),    Cpno      INT(4),    Ccredit     TINYINT(3),    FOREIGN     KEY (Cpno) REFERENCES Course (Cno));INSERT INTO CourseVALUES    (1, &#39;数据库&#39;, 5, 4),        (2, &#39;数学&#39;, NULL, 2),    (3, &#39;信息系统&#39;, 1, 4),     (4, &#39;操作系统&#39;, 6, 3),     (5, &#39;数据结构&#39;, 7, 4),     (6, &#39;数据处理&#39;, NULL, 2),     (7, &#39;PASCAL语言&#39;, 6, 4);/*选课表*/CREATE TABLE SC(    Sno  INT(9),    Cno  INT(4),    Grade SMALLINT(3),    PRIMARY KEY (Sno, Cno),/* 主码由两个属性构成，必须作为表级完整性进行定义*/    FOREIGN KEY (Sno) REFERENCES Student (Sno),/* 表级完整性约束条件，Sno是外码，被参照表是Student */    FOREIGN KEY (Cno) REFERENCES Course (Cno)/* 表级完整性约束条件， Cno是外码，被参照表是Course*/);INSERT INTO SCVALUES (201215121, 1, 92),            (201215121, 2, 85),            (201215121, 3, 88),            (201215122, 2, 90),      (201215122, 3, 80),            (201215122, 6, 59),         (201215123, 1, 84),         (201215125, 1, 60),         (201215125, 3, 90),         (201215133, 4, 87),         (201215137, 2, 79),         (201215139, 2, 80),         (201215140, 2, 81);SET FOREIGN_KEY_CHECKS = 1;</code></pre><h3 id="问题代码"><a href="#问题代码" class="headerlink" title="问题代码"></a>问题代码</h3><pre><code class="sql">0select Sno, Sname        from Student1select Sname, Sno, Sdept        from Student2select Sname, Sno, Sdept        from Student3select distinct Sno        from SC4select distinct Sname        from Student        where Sdept=&#39;CS&#39;5select Sname, Sage    from Student    where Sage&lt;206select Sno    from SC    where Grade&lt;607select Sname, Sdept, Sage    from Student    where Sage&gt;=20 and Sage&lt;=238select Sname, Sdept, Sage    from Student    where Sage&lt;20 or Sage&gt;239select Sname, Ssex    from Student    where Sdept=&#39;CS&#39; or Sdept=&#39;MA&#39; or Sdept=&#39;IS&#39;10select Sname, Ssex    from Student    where Sdept not in (&#39;CS&#39;, &#39;MA&#39;, &#39;IS&#39;)11select Sname, Sno, Ssex    from Student    where Sname like &#39;刘_&#39;12select Sname, Sno    from Student    where Sname like &#39;_立&#39;13select Sname, Sno, Ssex    from Student    where Sname not like &#39;刘_&#39;14select Sno, Cno    from SC    where Grade is not null15select Sname    from Student    where Sdept=&#39;CS&#39; and Sage&lt;2016select Sno, Grade    from SC    where Cno=&#39;3&#39;    order by Grade desc17select *    from Student    order by Sdept asc, Sage desc18select count(Sno) as &#39;COUNT&#39;    from Student19select count(Sno) as COUNT        from (        select Sno                from SC                group by sno) as test20select avg(Grade) as AVG    from SC    where Cno=&#39;1&#39;21select max(Grade) as MAX    from SC    where Cno=&#39;1&#39;22select SUM(Ccredit) as SUM        from Course, SC        where Course.Cno=SC.Cno        and Sno=&#39;201215121&#39;23select Cno, count(Grade) as COUNT        from SC        group by Cno24select Sno        from(        select Sno, count(Grade) as COUNT                from SC                group by Sno            )as test        where COUNT&gt;225select Sno, AVG(Grade) as AVG        from SC        group by Sno        having AVG(Grade)&gt;=8826select Student.Sno, Sname, Ssex, Sage, Sdept, Cno, Grade    from Student inner join SC    on Student.Sno=SC.Sno27SELECT x.Cno, y.Cpno        FROM Course x, Course y        WHERE x.Cpno = y.Cno28select Student.Sno, Student.Sname        from Student, SC        where Student.Sno=SC.Sno                and SC.Cno=&#39;2&#39;                and SC.Grade&gt;8029select test.Sno, test.Sname, Course.Cname, test.Grade    from Course join        (select SC.Sno, SC.Cno, Student.Sname, SC.Grade            from Student join SC                on Student.Sno=SC.Sno)as test        on Course.Cno=test.Cno</code></pre><h2 id="Movie-相关题目"><a href="#Movie-相关题目" class="headerlink" title="Movie 相关题目"></a>Movie 相关题目</h2><pre><code class="sql">30select title        from movie        where director=&#39;Steven Spielberg&#39;31select year        from movie        where mID in (                select mID                from rating                where stars=&#39;4&#39; or stars=&#39;5&#39;                )        order by year asc32select title        from movie        where mID not in (                select mID                    from rating)33select name        from reviewer        where rID in (                select rID                        from rating                        where ratingDate is null)34select reviewer.name, test.title, test.stars, test.ratingDatefrom reviewer join (    select movie.title, rating.rID, rating.stars, rating.ratingDate    from movie join rating    on movie.mID=rating.mID    ) as teston reviewer.rID=test.rIDorder by reviewer.name, test.title, test.stars3537select movie.title, rating_2.stars_avg as starsfrom movie join (    select mID, AVG(stars) as stars_avg    from rating    group by mID) as rating_2on movie.mID=rating_2.mIDorder by stars desc, title38select namefrom reviewerwhere rID in(    select rID    from rating    group by rID    having COUNT(rID)&gt;=3)39select namefrom reviewerwhere rID in (select distinct rIDfrom ratingwhere mID in (    select mID    from movie    where title=&#39;Gone with the Wind&#39;)) 40 select temp.name as name, movie.title as title, temp.stars as stars    from movie join (        select rating.stars, reviewer.name, rating.mID        from rating join reviewer        on rating.rID=reviewer.rID) as temp    on movie.mID=temp.mID    where movie.director=temp.name</code></pre>]]></content>
      
      
      <categories>
          
          <category> 👨‍💻Web开发 </category>
          
          <category> DataBase </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>509. 斐波那契数🔖递归</title>
      <link href="/blog/pmd7dz/"/>
      <url>/blog/pmd7dz/</url>
      
        <content type="html"><![CDATA[<ul><li><a href="https://leetcode-cn.com/problems/fibonacci-number/">https://leetcode-cn.com/problems/fibonacci-number/</a></li></ul><h3 id="ts-实现"><a href="#ts-实现" class="headerlink" title="ts 实现"></a>ts 实现</h3><pre><code class="typescript">function fib(n: number): number &#123;  if (n &lt;= 1) return n;  return fib(n - 1) + fib(n - 2);&#125;</code></pre><h3 id="java-实现"><a href="#java-实现" class="headerlink" title="java 实现"></a>java 实现</h3><pre><code class="java">class Solution &#123;    // TODO: for循环实现    public int fib(int N) &#123;        if (N &lt;= 1) return N;        int first = 0;        int second = 1;        for (int i = 0; i &lt; N - 1; i++) &#123;            int sum = first + second;            first = second;            second = sum;        &#125;        return second;    &#125;//    // TODO: 递归实现O(2^n)//    public int fib1(int n) &#123;//        if (n &lt;= 1) return n;//        return fib1(n - 1) + fib1(n - 2);//    &#125;//    // TODO: 首尾实现//    public int fib3(int n) &#123;//        if (n &lt;= 1) return n;//        int first = 0;//        int second = 1;//        while (n-- &gt; 1) &#123;//            second += first;//            first = second - first;//        &#125;//        return second;//    &#125;&#125;</code></pre><h3 id="C-实现"><a href="#C-实现" class="headerlink" title="C++实现"></a>C++实现</h3><pre><code class="java">// 递归：O(2^n)public static int fib1(int n) &#123;    if (n &lt;= 1) return n;    return fib1(n - 1) + fib1(n - 2);&#125;// for循环：O(n)public static int fib2(int n) &#123;    if (n &lt;= 1) return n;    int first = 0;    int second = 1;    for (int i = 0; i &lt; n - 1; i++) &#123;        int sum = first + second;        first = second;        second = sum;    &#125;    return second;&#125;// 首尾法public static int fib3(int n) &#123;    if (n &lt;= 1) return n;    int first = 0;    int second = 1;    while (n-- &gt; 1) &#123;        second += first;        first = second - first;    &#125;    return second;&#125;// 特征方程解法：O（1）public static int fib4(int n) &#123;    double c = Math.sqrt(5);    return (int) (Math.pow((1+c) / 2, n) - Math.pow((1-c) / 2, c));&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 🌌递归算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>486. 预测赢家🔖数组</title>
      <link href="/blog/srvbwz/"/>
      <url>/blog/srvbwz/</url>
      
        <content type="html"><![CDATA[<ul><li><a href="https://leetcode-cn.com/problems/predict-the-winner/">https://leetcode-cn.com/problems/predict-the-winner/</a></li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>贪心策略不行，如果玩家每次都选相对自己当下可选择的最大值，这样的贪心策略有错误，比如这个例子：</p><blockquote><p>输入：nums = [1,5,233,7]<br>输出：true<br>解释：玩家 1 一开始选择 1 。然后玩家 2 必须从 5 和 7 中进行选择。无论玩家 2 选择了哪个，玩家 1 都可以选择 233 。<br>最终，玩家 1（234 分）比玩家 2（12 分）获得更多的分数，所以返回 true，表示玩家 1 可以成为赢家。</p></blockquote><h3 id="java-实现"><a href="#java-实现" class="headerlink" title="java 实现"></a>java 实现</h3><pre><code class="java">class Solution &#123;    public boolean PredictTheWinner(int[] nums) &#123;        return total(nums, 0, nums.length - 1, 1) &gt;= 0;    &#125;    public int total(int[] nums, int start, int end, int turn) &#123;        if (start == end) &#123;            return nums[start] * turn;        &#125;        int scoreStart = nums[start] * turn + total(nums, start + 1, end, -turn);        int scoreEnd = nums[end] * turn + total(nums, start, end - 1, -turn);        return Math.max(scoreStart * turn, scoreEnd * turn) * turn;//        if(turn == 1)&#123;//            return Math.max(scoreStart ,scoreEnd );//        &#125;else&#123;//            return Math.min(scoreStart ,scoreEnd );//        &#125;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> Problems </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>876. 链表的中间结点🔖链表</title>
      <link href="/blog/serpsb/"/>
      <url>/blog/serpsb/</url>
      
        <content type="html"><![CDATA[<h2 id="876-链表的中间结点"><a href="#876-链表的中间结点" class="headerlink" title="876. 链表的中间结点"></a>876. 链表的中间结点</h2><ul><li><a href="https://leetcode-cn.com/problems/middle-of-the-linked-list/">https://leetcode-cn.com/problems/middle-of-the-linked-list/</a></li></ul><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1603195941092-8cd11b96-c174-425e-ab68-a7015110092e.png#crop=0&crop=0&crop=1&crop=1&height=208&id=QJds4&margin=%5Bobject%20Object%5D&name=image.png&originHeight=415&originWidth=717&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=49665&status=done&style=shadow&title=&width=358.5" alt="image.png"></p><h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h3><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><h4 id="js"><a href="#js" class="headerlink" title="js"></a>js</h4><pre><code class="javascript">/** * Definition for singly-linked list. * function ListNode(val, next) &#123; *     this.val = (val===undefined ? 0 : val) *     this.next = (next===undefined ? null : next) * &#125; *//** * @param &#123;ListNode&#125; head * @return &#123;ListNode&#125; */var middleNode = function (head) &#123;  let count = 0;  let temp = head;  while (temp) &#123;    count++;    temp = temp.next;  &#125;  for (let i = 0; i &lt; (count - 1) / 2; i++) &#123;    head = head.next;  &#125;  return head;&#125;;</code></pre><h4 id="java"><a href="#java" class="headerlink" title="java"></a>java</h4><pre><code class="java">class Solution &#123;    public ListNode middleNode(ListNode head) &#123;        if (head.next == null) return head;        if (head.next.next == null) return head.next;        ListNode slow = head.next;        ListNode fast = head.next.next;        while (fast != null &amp;&amp; fast.next != null) &#123;            slow = slow.next;            fast = fast.next.next;            if (fast == null) return slow;        &#125;        return slow;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 📎线结构：链表 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>83. 删除排序链表中的重复元素🔖链表</title>
      <link href="/blog/lg67md/"/>
      <url>/blog/lg67md/</url>
      
        <content type="html"><![CDATA[<pre><code class="java">/** * public class ListNode &#123; *     int val; *     ListNode next; *     ListNode(int x) &#123; val = x; &#125; * &#125; */</code></pre><h2 id="83-删除排序链表中的重复元素"><a href="#83-删除排序链表中的重复元素" class="headerlink" title="83. 删除排序链表中的重复元素"></a>83. 删除排序链表中的重复元素</h2><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1603195897467-fdb33dfe-a1c0-4963-b76a-2c978f565801.png#align=left&display=inline&height=177&margin=%5Bobject%20Object%5D&name=image.png&originHeight=354&originWidth=727&size=22776&status=done&style=stroke&width=363.5" alt="image.png"></p><h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h3><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><pre><code class="java">class Solution &#123;    public ListNode deleteDuplicates(ListNode head) &#123;        // TODO: 快慢指针        if (head == null) return head;        ListNode slow = head;        ListNode fast = head.next;        while (fast != null)&#123;            if (slow.val != fast.val) &#123;                slow.next = fast;                slow = fast;            &#125;            fast = fast.next;        &#125;        slow.next = null;        return head;    &#125;&#125;// TODO: 单指针下一步//class Solution &#123;//    public ListNode deleteDuplicates(ListNode head) &#123;//        ListNode cur = head;//        while(cur != null &amp;&amp; cur.next != null) &#123;//            if(cur.val == cur.next.val) &#123;//                cur.next = cur.next.next;//            &#125; else &#123;//                cur = cur.next;//            &#125;//        &#125;//        return head;//    &#125;//&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> Problems </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>203. 移除链表元素🔖链表</title>
      <link href="/blog/kgpm3x/"/>
      <url>/blog/kgpm3x/</url>
      
        <content type="html"><![CDATA[<pre><code class="java">/** * public class ListNode &#123; *     int val; *     ListNode next; *     ListNode(int x) &#123; val = x; &#125; * &#125; */</code></pre><h2 id="203-移除链表元素"><a href="#203-移除链表元素" class="headerlink" title="203. 移除链表元素"></a>203. 移除链表元素</h2><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1603195857807-2e8c8296-2d79-4e36-b304-f02c4dee52b3.png#align=left&display=inline&height=100&margin=%5Bobject%20Object%5D&name=image.png&originHeight=200&originWidth=729&size=15034&status=done&style=shadow&width=364.5" alt="image.png"></p><h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h3><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><pre><code class="java">class Solution &#123;    public ListNode removeElements(ListNode head, int val) &#123;        // 将整个链表想象成head+子链表        if (head == null)            return null;        // 先处理子链表        head.next = removeElements(head.next, val);        // 再处理头结点        return head.val == val ? head.next : head;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> Problems </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>141. 环形链表🔖链表</title>
      <link href="/blog/fgkbg2/"/>
      <url>/blog/fgkbg2/</url>
      
        <content type="html"><![CDATA[<pre><code class="java">/** * public class ListNode &#123; *     int val; *     ListNode next; *     ListNode(int x) &#123; val = x; &#125; * &#125; */</code></pre><h2 id="141-环形链表"><a href="#141-环形链表" class="headerlink" title="141. 环形链表"></a>141. 环形链表</h2><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>给定一个链表，判断链表中是否有环。</p><p>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。</p><p>如果链表中存在环，则返回 true 。 否则，返回 false 。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1603195777983-5574f7c4-135c-45c2-aef2-6118e954bf68.png#align=left&display=inline&height=172&margin=%5Bobject%20Object%5D&name=image.png&originHeight=343&originWidth=726&size=36403&status=done&style=shadow&width=363" alt="image.png"></p><h3 id="问题思路"><a href="#问题思路" class="headerlink" title="问题思路"></a>问题思路</h3><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><pre><code class="java">public class Solution &#123;    public boolean hasCycle(ListNode head) &#123;        if (head == null || head.next == null) return false;        // TODO: 快慢指针        ListNode slow = head;        ListNode fast = head.next;        while (fast != null &amp;&amp; fast.next != null) &#123;            slow = slow.next;            fast = fast.next.next;            if (slow == fast) return true; //如果能相遇则表示有环        &#125;        return false; //不能相遇则没有环    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> Problems </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>.gitignore文件使用总结</title>
      <link href="/blog/hgxgvd/"/>
      <url>/blog/hgxgvd/</url>
      
        <content type="html"><![CDATA[<div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">在Git项目将要提交到github仓库的时候，有些时候我们想要将指定文件不push，例如含有敏感信息类似token的文件，或者.class、.xml、等文件</div><h2 id="忽略指定文件的-push-的三种方式"><a href="#忽略指定文件的-push-的三种方式" class="headerlink" title="忽略指定文件的 push 的三种方式"></a>忽略指定文件的 push 的三种方式</h2><ul><li>方式一：在 Git 项目中定义.gitignore 文件</li><li>方式二：在 Git 项目的设置中指定排除文件</li><li>方式三：定义 Git 全局的 .gitignore 文件</li></ul><h2 id="语法规则"><a href="#语法规则" class="headerlink" title="语法规则"></a>语法规则</h2><pre><code>#               表示此为注释,将被Git忽略*.a             表示忽略所有 .a 结尾的文件!lib.a          表示但lib.a除外/TODO           表示仅仅忽略项目根目录下的 TODO 文件，不包括 subdir/TODObuild/          表示忽略 build/目录下的所有文件，过滤整个build文件夹；doc/*.txt       表示会忽略doc/notes.txt但不包括 doc/server/arch.txtbin/:           表示忽略当前路径下的bin文件夹，该文件夹下的所有内容都会被忽略，不忽略 bin 文件/bin:           表示忽略根目录下的bin文件/*.c:           表示忽略cat.c，不忽略 build/cat.cdebug/*.obj:    表示忽略debug/io.obj，不忽略 debug/common/io.obj和tools/debug/io.obj**/foo:         表示忽略/foo,a/foo,a/b/foo等a/**/b:         表示忽略a/b, a/x/b,a/x/y/b等!/bin/run.sh    表示不忽略bin目录下的run.sh文件*.log:          表示忽略所有 .log 文件config.php:     表示忽略当前路径的 config.php 文件/mtk/           表示过滤整个文件夹*.zip           表示过滤所有.zip文件/mtk/do.c       表示过滤某个具体文件被过滤掉的文件就不会出现在git仓库中（gitlab或github）了，当然本地库中还有，只是push的时候不会上传。需要注意的是，gitignore还可以指定要将哪些文件添加到版本管理中，如下：!*.zip!/mtk/one.txt唯一的区别就是规则开头多了一个感叹号，Git会将满足这类规则的文件添加到版本管理中。为什么要有两种规则呢？想象一个场景：假如我们只需要管理/mtk/目录中的one.txt文件，这个目录中的其他文件都不需要管理，那么.gitignore规则应写为：：/mtk/*!/mtk/one.txt假设我们只有过滤规则，而没有添加规则，那么我们就需要把/mtk/目录下除了one.txt以外的所有文件都写出来！注意上面的/mtk/*不能写为/mtk/，否则父目录被前面的规则排除掉了，one.txt文件虽然加了!过滤规则，也不会生效！----------------------------------------------------------------------------------还有一些规则如下：fd1/*说明：忽略目录 fd1 下的全部内容；注意，不管是根目录下的 /fd1/ 目录，还是某个子目录 /child/fd1/ 目录，都会被忽略；/fd1/*说明：忽略根目录下的 /fd1/ 目录的全部内容；/*!.gitignore!/fw//fw/*!/fw/bin/!/fw/sf/说明：忽略全部内容，但是不忽略 .gitignore 文件、根目录下的 /fw/bin/ 和 /fw/sf/ 目录；注意要先对bin/的父目录使用!规则，使其不被排除。</code></pre><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li>文章主要参考：<a href="https://www.cnblogs.com/kevingrace/p/5690241.html">https://www.cnblogs.com/kevingrace/p/5690241.html</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> Git+GitHub </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>《围城》有感</title>
      <link href="/essay/obs0vr/"/>
      <url>/essay/obs0vr/</url>
      
        <content type="html"><![CDATA[<p>持续记录读这本书的所思所感所悟</p><div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">“城外的人想进来，城内的人想出去”</div><div style="background: #edf9e8;padding:10px;border: 1px solid #c2d2b5;border-radius:5px;margin-bottom:5px;">这真的是一种人生态度，每次用这句话对一系列问题进行思考的时候，我总喜欢在后面加上一句“活在当下，知足常乐”。</div><p>还是坐在教室里面的一些遐想…</p><p>我很难去想象一个没有选择权利的人会怎么样度过这么一生。这是一个极端，也是一个愿以安于现状的人的一种解脱，</p><p>还没看完，下次再写吧</p><hr><p>最大的围城，或许就是知识分子之间的吧，就像是一个圈子，这个圈子吧所谓的知识分子划分出来，而这个圈子里面的人或许又如井底的青蛙一样，甚至也不想出去呢~</p><p>滑稽的人呀，一切都貌似在追求一些虚无缥缈般地事物一样，易碎<code>fragile</code> ……</p>]]></content>
      
      
      <categories>
          
          <category> 阅读 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>计算方法课小记</title>
      <link href="/essay/sdzqr3/"/>
      <url>/essay/sdzqr3/</url>
      
        <content type="html"><![CDATA[<p>上计算方法课的那个老师，我严重怀疑他有山东口音，他讲话，一开始简直听不清，可能是我还不习惯山东话的缘故吧~可就是在那样的课堂里面，在那些个周里面，我真的是潜移默化般地学到了许多到许多……</p><p>大三上学期选了一门计算方法这门课，当时选的人不太多，四十几个吧，当时都是说这门课太难了，需要用到许多之前学习的高数、线代、概率统计等知识，我选这门课，一是自己比较喜欢数学，想着今后应该不做科研了，与数学不出意外应该是不会再相见了，还想再最后学习一下自己最喜欢的科目，也算是一种情怀吧~哈哈，在一个原因就是，这门课四个学分，四个学分！！</p><p>老师经常和我们说，算法就是解决实际问题，以前我们学的立刻当中，结果就是是与不是，但是这门课里面，没有对错，他经常让我们看到一个问题，不要立马去看树上的解答，他说书很局限思维，起初我不以为意，渐渐地，我发现了这位老师说的的确对，我记得有一次课是讲求积分，我一直觉得我高数学的还行，老师让我们尽自己所想，想出所有的解决方案，来解决求一个正态分布表这么个简单的问题，老师一再强调让我们不要有正确答案的想法，有解决方案即可，那次我记得那个问题同学们给出的解决方案有许许多多，插值、拟合、泰勒多项式展开、幂级数展开、求面积，多点函数值……</p><p>其实从那个时候，我对算法这个事物有了进一步的认识，就像这位常年带学校 ACM 队的老师所说，算法就是解决实际问题，没有什么对错，只有精度，优化，算法亦是如此，其实那个时候，我对算法设计与分析那门课程里面谈及的各种算法问题，各种算法思想，也有了更加一步的上帝视角来观望。</p><p>算法就是解决实际问题，手上敲的代码亦是如此。</p><p>他和我们说，我们现在在学校里面学的这些知识出去是用不到的，那为什么还学呢？</p><p>能力。他的这个回答，和我的回答一样，身处在这个技术迭代极快的情况下，更何况是计算机行业，我们要学的实在太多了，但是又如老师所言，但那些底层次的知识，那些思想，是我们这些学习者要学习的，我想老师想表达的更是一种万变不离其中的意味吧。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>博客与前端历程</title>
      <link href="/essay/sgyoz3/"/>
      <url>/essay/sgyoz3/</url>
      
        <content type="html"><![CDATA[<div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">大三上学期，学习计算机网络的应用层那里，我才知道我常写的原来叫博客……</div><h2 id="学习就要做笔记"><a href="#学习就要做笔记" class="headerlink" title="学习就要做笔记"></a>学习就要做笔记</h2><p>大二上学期期末那会，当时复习操作系统那会在想，为什么我现在想不起来我大一的 C 语言的一些知识呢？学过的知识过了许久没有记录，没有可以供自己想起的那般线索，还有什么意义呢？于是，那时我就想着在网上弄一个电子笔记吧。</p><p>于是，我认识了 Onenote，Onenote 很灵活，以至于太过灵活，不太适合发布文章，用了一段时间，想了想我还是想以发布文章的角色来做笔记</p><p>于是期末那段时间我就平时在网上搜适合我做电子笔记的平台，当时改不知道什么是博客，但是看~~很多人 ~~程序员都有自己的网站写点东西，于是就对其感兴趣了<br>再后来就发现很多人都拥有自己的个人网站，而且建立也很简单，一个 GitHub 就可以了，那会就一直玩 GitHub，利用 GitHub Pages 搭建了一个静态网站</p><p>疫情期间正好有一门选修课是 JavaWeb，那会我就接触了 CS 架构模型</p><p>疫情期间，在家发现网上有好多的博客大神。突然有那么一刹那，我突然意识到，我想写的不是笔记，也不是零零碎碎的小想法，我要写的是一篇篇博客，一篇篇文章呀！</p><p>从那之后，对前端就慢慢了解，前端很难，水很深，需要的自学能力甚至赶超其他行业。</p><h2 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h2><p>其实一直喜欢数据，大一那会，人工智能，机器学习啥的，都特别火，那会我也就学了 python，然后数据分析，那会我就挺喜欢数据分析挖掘的，将一堆杂乱的数据经过处理之后，就可以变成各种自己需要的各种数据，还能出图，matplotlib 包，我就特别喜欢用这个画各种图</p><p>2021.04.26 更<br>好的，已入前端坑 🙃，两个字——鬼魅～</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>万物守恒</title>
      <link href="/essay/ipgq2m/"/>
      <url>/essay/ipgq2m/</url>
      
        <content type="html"><![CDATA[<p>什么都是守恒的，我一直觉得这世界上很多事物都是守恒的</p><ul><li>有过很顺的时候，也有过身处逆境</li><li>有过巅峰，也有过没落</li><li>有些时候，你帮助陌生人，到某个时候，你也会被他人帮助</li><li>盛极一时的罗马，最后也败于自己</li><li>秦的大一统，也终将没落</li></ul>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++匿名函数</title>
      <link href="/blog/uq89oe/"/>
      <url>/blog/uq89oe/</url>
      
        <content type="html"><![CDATA[<h3 id="常用形式"><a href="#常用形式" class="headerlink" title="常用形式"></a>常用形式</h3><pre><code class="cpp">[](int x, int y) -&gt; int &#123; int z = x + y; return z; &#125; //这样显示指定返回类型:[](int x, int y) &#123; return x + y; &#125; // 隐式返回类型[](int&amp; x) &#123; ++x; &#125;   // 没有return语句 -&gt; lambda 函数的返回类型是&#39;void&#39;[]() &#123; ++global_x; &#125;  // 没有参数,仅访问某个全局变量[]&#123; ++global_x; &#125;     // 与上一个相同,省略了()</code></pre><h3 id="小例子"><a href="#小例子" class="headerlink" title="小例子"></a>小例子</h3><pre><code class="cpp">#include &lt;iostream&gt;int main() &#123;    // lambda表达式    auto multiply = [](int a, int b) -&gt; int &#123; return a * b; &#125;;    // 匿名函数调用    auto result = multiply(2, 4);    std::cout &lt;&lt; result &lt;&lt; std::endl;    return 0;&#125;</code></pre><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><blockquote><p>一些进一步用法<a href="https://www.cnblogs.com/pzhfei/archive/2013/01/14/lambda_expression.html">https://www.cnblogs.com/pzhfei/archive/2013/01/14/lambda_expression.html</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 非前端编程语言 </category>
          
          <category> CPlusPlus </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Huffman编码算法</title>
      <link href="/blog/ggu8v9/"/>
      <url>/blog/ggu8v9/</url>
      
        <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>压缩算法，目的就是根据字母的出现频率来“按需分配”编码来优化编码方式。</p><p>比如：给出一串字母 <code>Huffman Coding</code>   ，按照计算机处理形式，会根据 ascll 码将这串字符编码，具体形式（十进制）就是 104 117 102 102 109 97 110 32 67 111 100 105 110 103，然后转换成二进制，最后会得到需要 97 个比特来存储。</p><h2 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h2><p>算法角度来讲对上述问题 ascll 编码方式是浪费空间的，优化方向是改变编码方式，根据字母出现的频率来“按需分配”进制位。</p><p>给出下面所给出的字母，以及出现的频率，来得到哈夫曼编码<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1605340774734-5ec5e8f1-0fae-47ff-8ded-dccf9611a3ad.png#align=left&display=inline&height=45&id=pbDsY&margin=%5Bobject%20Object%5D&name=image.png&originHeight=89&originWidth=411&size=4276&status=done&style=shadow&width=205.5" alt="image.png"><br>先提出将频率小的依次加入。d 和 h 组合权值为 9(或者说 A 只是称呼方便)，然后将这个 9“替换 d 和 h”代入整个序列，在进行插入树操作，</p><blockquote><p>过程中，遵循数字大的在左数字小的在右原则（互换也没关系，只不过换的是二进制的 0 和 1）</p></blockquote><p>在进行到 E 的时候，此时的队列应该为 120 107 42 37，所以此时需要重新调整队列，然后进行到结束。</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1605340899720-d8867a90-d01c-4bf6-8ec7-ca0e812a99dd.png#align=left&display=inline&height=221&id=vJM66&margin=%5Bobject%20Object%5D&name=image.png&originHeight=443&originWidth=376&size=24239&status=done&style=shadow&width=188" alt="image.png"><br>最后的编码结果为：<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1605341313840-61587c86-135d-4ba0-96aa-844868de1d56.png#align=left&display=inline&height=101&id=ENEj4&margin=%5Bobject%20Object%5D&name=image.png&originHeight=201&originWidth=165&size=4405&status=done&style=shadow&width=82.5" alt="image.png"></p><h2 id="编码实现"><a href="#编码实现" class="headerlink" title="编码实现"></a>编码实现</h2><pre><code class="cpp">#include &lt;stdio.h&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;namespace NS_HuffmanCoding &#123;using namespace std;void BuildHuffmanTree();void Initialization(vector&lt;pair&lt;char, int&gt;&gt; chars);void Finalization();struct HFMNode &#123;  char Ch; int Freq;  HFMNode* Left, * Right;  HFMNode(char pCh, int pFreq, HFMNode* pLeft, HFMNode* pRight)    : Ch(pCh), Freq(pFreq), Left(pLeft), Right(pRight) &#123;&#125;  HFMNode(char pCh, int pFreq)    : HFMNode(pCh, pFreq, NULL, NULL) &#123;&#125;&#125;;void MinHeapify(vector&lt;HFMNode*&gt;&amp; H);void InsertH(vector&lt;HFMNode*&gt;&amp; H, HFMNode* node);void SiftDown(vector&lt;HFMNode*&gt;&amp; H, int i);void SiftUp(vector&lt;HFMNode*&gt;&amp; H, int i);HFMNode* ExtractMin(vector&lt;HFMNode*&gt;&amp; H);void DeleteANode(HFMNode* node);void ShowInput(vector&lt;pair&lt;char, int&gt;&gt; chars);void Output();static vector&lt;HFMNode*&gt; Q;void HuffmanCodingCaller(vector&lt;pair&lt;char, int&gt;&gt; chars)&#123;  ShowInput(chars);  Initialization(chars);  BuildHuffmanTree();  Output();  Finalization();&#125;void BuildHuffmanTree()&#123;  char C = &#39;A&#39;;  while (Q.size() &gt; 1)  &#123;    HFMNode* x = ExtractMin(Q);    HFMNode* y = ExtractMin(Q);    HFMNode* z = new HFMNode(C++, x-&gt;Freq + y-&gt;Freq, x, y);    InsertH(Q, z);  &#125;&#125;HFMNode* ExtractMin(vector&lt;HFMNode*&gt;&amp; H)&#123;  swap(H.front(), H.back());  HFMNode* p = H.back();  H.pop_back();  if (!H.empty())    SiftDown(H, 0);  return p;&#125;void SiftDown(vector&lt;HFMNode*&gt;&amp; H, int i)&#123;    while ((i = (i &lt;&lt; 1) + 1) &lt; H.size()) &#123;        if ((i + 1 &lt; H.size()) &amp;&amp; (H[i + 1]-&gt;Freq &lt; H[i]-&gt;Freq))            i = i + 1;        if (H[(i - 1) &gt;&gt; 1]-&gt;Freq &gt; H[i]-&gt;Freq)            swap(H[(i - 1) &gt;&gt; 1], H[i]);        else break;    &#125;&#125;void InsertH(vector&lt;HFMNode*&gt;&amp; H, HFMNode* node)&#123;  H.push_back(node);  SiftUp(H, H.size() - 1);&#125;void SiftUp(vector&lt;HFMNode*&gt;&amp; H, int i)&#123;  while (i &gt; 0 &amp;&amp; H[i]-&gt;Freq &lt; H[(i - 1) &gt;&gt; 1]-&gt;Freq) &#123;    swap(H[i], H[(i - 1) &gt;&gt; 1]);    i = (i - 1) &gt;&gt; 1;  &#125;&#125;void MinHeapify(vector&lt;HFMNode*&gt;&amp; H)&#123;  for (int i = (H.size() &gt;&gt; 1) - 1; i &gt;= 0; i--) &#123;    SiftDown(H, i);  &#125;&#125;void Initialization(vector&lt;pair&lt;char, int&gt;&gt; chars)&#123;  Q.clear();  for (auto ch : chars)    Q.push_back(new HFMNode(ch.first, ch.second));  MinHeapify(Q);&#125;void Finalization()&#123;  DeleteANode(Q[0]);&#125;void DeleteANode(HFMNode* node)&#123;  if (node-&gt;Left)  &#123;    DeleteANode(node-&gt;Left);    DeleteANode(node-&gt;Right);  &#125;  delete node;&#125;void ShowInput(vector&lt;pair&lt;char, int&gt;&gt; chars)&#123;  printf(&quot;Huffman coding input: \n&quot;);  for (auto c : chars)    printf(&quot;%c,%d; &quot;, c.first, c.second);  printf(&quot;\n&quot;);&#125;static vector&lt;char&gt; coding;static vector&lt;pair&lt;char, vector&lt;char&gt;&gt;&gt; codingList;void GetHuffmanCoding(HFMNode* node)&#123;  if (node-&gt;Left)  &#123;    coding.push_back(&#39;0&#39;);    GetHuffmanCoding(node-&gt;Left);    coding.pop_back();    coding.push_back(&#39;1&#39;);    GetHuffmanCoding(node-&gt;Right);    coding.pop_back();  &#125;  else  &#123;    codingList.push_back(pair&lt;char,      vector&lt;char&gt;&gt;(node-&gt;Ch, coding));  &#125;&#125;void Output()&#123;  printf(&quot;Huffman coding:\n&quot;);  coding.clear();  codingList.clear();  GetHuffmanCoding(Q[0]);  sort(codingList.begin(), codingList.end());  for (auto c1 : codingList)  &#123;    printf(&quot;  %c: &quot;, c1.first);    for (auto c2 : c1.second)      printf(&quot;%c&quot;, c2);    printf(&quot;\n&quot;);  &#125;  printf(&quot;\n&quot;);&#125;&#125; //namespace NS_HuffmanCodingusing namespace NS_HuffmanCoding;void TestHuffmanCoding()&#123;  vector&lt;vector&lt;pair&lt;char, int&gt;&gt;&gt; charLists = &#123;      //Introduction to Algorithms     &#123;        &#123; &#123;&#39;a&#39;,40&#125;, &#123;&#39;b&#39;,13&#125;, &#123;&#39;c&#39;,12&#125;,          &#123;&#39;d&#39;,16&#125;, &#123;&#39;e&#39;,9&#125;, &#123;&#39;f&#39;,5&#125; &#125;,     &#125;,     //ÑÏÎµÃô     &#123;        &#123; &#123;&#39;a&#39;,5&#125;, &#123;&#39;b&#39;,29&#125;, &#123;&#39;c&#39;,7&#125;, &#123;&#39;d&#39;,8&#125;,          &#123;&#39;e&#39;,14&#125;, &#123;&#39;f&#39;,23&#125;, &#123;&#39;g&#39;,3&#125;, &#123;&#39;h&#39;,11&#125; &#125;,     &#125;,  &#125;;  int n = charLists.size();  for (int i = 0; i &lt; n; i++)  &#123;    HuffmanCodingCaller(charLists[i]);  &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 贪心算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>最小生成树算法（Prim+Kruskal）</title>
      <link href="/blog/ghf568/"/>
      <url>/blog/ghf568/</url>
      
        <content type="html"><![CDATA[<div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">贪心算法四个字总结：目前最优</div><h2 id="图的一些概念"><a href="#图的一些概念" class="headerlink" title="图的一些概念"></a>图的一些概念</h2><p>具体看先前的一篇文章<a href="https://www.wztlink1013.com/blog/gqpli5/">https://www.wztlink1013.com/blog/gqpli5/</a></p><p><strong>连通图</strong></p><blockquote><p>在<a href="https://baike.baidu.com/item/%E5%9B%BE%E8%AE%BA/1433806">图论</a>中，连通图基于连通的概念。在一个<a href="https://baike.baidu.com/item/%E6%97%A0%E5%90%91%E5%9B%BE/1680427">无向图</a> G 中，若从<a href="https://baike.baidu.com/item/%E9%A1%B6%E7%82%B9/11030118">顶点</a>i 到顶点 j 有路径相连（当然从 j 到 i 也一定有路径），则称 i 和 j 是连通的。如果 G 是<a href="https://baike.baidu.com/item/%E6%9C%89%E5%90%91%E5%9B%BE">有向图</a>，那么连接 i 和 j 的路径中所有的边都必须同向。如果图中任意两点都是连通的，那么图被称作连通图。如果此图是有向图，则称为强连通图（注意：需要双向都有路径）。图的<a href="https://baike.baidu.com/item/%E8%BF%9E%E9%80%9A%E6%80%A7/6688865">连通性</a>是图的基本性质。</p></blockquote><p><strong>生成树</strong></p><blockquote><p>包含图的全部顶点，边数最少的连通子图</p></blockquote><p><strong>最小生成树</strong></p><blockquote><p>总权值最小的生成树</p></blockquote><p>常见问题（该算法）就是求最小生成树。<br><strong>并查集</strong></p><blockquote><p>是一个数据结构，功能有查找 a 和 b 是否为同一组；将 a 和 b 合并为同一组。</p></blockquote><h2 id="Prim-算法思路"><a href="#Prim-算法思路" class="headerlink" title="Prim 算法思路"></a>Prim 算法思路</h2><p><code>Prim——普里姆算法</code></p><p>类似于图的深度优先遍历一样，在遍历到一个结点的时候，在此根据该节点所连通的各边权值，取最小的，以此往复<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1625102662437-05ab5a6e-fcc3-46d5-8c2d-666c9c23fa9a.png#align=left&display=inline&height=194&margin=%5Bobject%20Object%5D&name=image.png&originHeight=387&originWidth=776&size=153006&status=done&style=none&width=388" alt="image.png"></p><h2 id="Kruskal-算法思路"><a href="#Kruskal-算法思路" class="headerlink" title="Kruskal 算法思路"></a>Kruskal 算法思路</h2><p><code>Kruskal——克鲁斯卡尔算法</code></p><p>把所有边按照权值全部按数值大小拿出来，然后按顺序选取每条边，利用并查集的思想，如果这条边的两个端点不属于同一集合，那么就将它们合并，直到所有的点都属于同一个集合为止。</p><p>比如有如下这么一个图：<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1605320252853-c5d445e4-aa0e-4279-b9fd-7477f23b1bc1.png#align=left&display=inline&height=95&id=Hx7aL&margin=%5Bobject%20Object%5D&name=image.png&originHeight=189&originWidth=438&size=10882&status=done&style=shadow&width=219" alt="image.png"><br>单独分析 ①② 边和 ③④ 边情况下，两个不在一个集合里面，<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1605320331669-51ec03dc-caf6-449d-9e8b-e4e62b9f35a6.png#align=left&display=inline&height=96&id=PuNRa&margin=%5Bobject%20Object%5D&name=image.png&originHeight=192&originWidth=769&size=21600&status=done&style=shadow&width=384.5" alt="image.png"><br>不断重复，不断判断是否为同一个集合，不在同一个集合的话，就合并，持续如此。比方说当一直操作到权值为 3 的时候，此时就需要将左右两个集合合并了<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1605320497092-00097419-4852-44c4-884e-febd4d37eb65.png#align=left&display=inline&height=101&id=wsUam&margin=%5Bobject%20Object%5D&name=image.png&originHeight=202&originWidth=748&size=22229&status=done&style=shadow&width=374" alt="image.png"><br>最后的结果样式就为如下<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1605320612085-d893c759-4ef1-410c-976e-8f32ddfe6321.png#align=left&display=inline&height=146&id=adOCr&margin=%5Bobject%20Object%5D&name=image.png&originHeight=292&originWidth=780&size=31319&status=done&style=shadow&width=390" alt="image.png"></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="Kruskal-算法代码"><a href="#Kruskal-算法代码" class="headerlink" title="Kruskal 算法代码"></a>Kruskal 算法代码</h3><pre><code class="cpp">#include &lt;stdio.h&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;namespace NS_KruskalMST &#123;using namespace std;void KruskalMST();int FindSet(int u);void UnionSets(int u, int v);void Initialization();void GenEdges();void MakeSets();void Output(int v0);#define INF INT_MAXstatic int n;static vector&lt;vector&lt;int&gt;&gt; WMatrix;static vector&lt;pair&lt;pair&lt;int, int&gt;, int&gt;&gt; Edges;//Node struct for the disjoint setstruct DJSNode &#123;    int Parent; int Rank;    DJSNode(int p) : Parent(p), Rank(0) &#123;&#125;&#125;;static vector&lt;DJSNode&gt; DisjointSet;static vector&lt;pair&lt;int, int&gt;&gt; MST;//The adjacency list for MSTstatic vector&lt;vector&lt;int&gt;&gt; MSTList;static vector&lt;int&gt; Prev;void KruskalMSTCaller(int an,    vector&lt;vector&lt;int&gt;&gt; &amp;wMatrix, int v0)&#123;    n = an;    WMatrix = wMatrix;    Initialization();    KruskalMST();    Output(v0);&#125;void KruskalMST()&#123;    for (auto &amp;e: Edges)    &#123;        int u = e.first.first;        int v = e.first.second;        int setU = FindSet(u);        int setV = FindSet(v);        if (setU != setV)        &#123;            MST.push_back(e.first);            if (MST.size() == n - 1)                break;            UnionSets(setU, setV);        &#125;    &#125;&#125;int FindSet(int u)&#123;    while (u != DisjointSet[u].Parent)        u = DisjointSet[u].Parent;        //For path compression:        //DisjointSet[u].Parent =        //    FindSet(DisjointSet[u].Parent);    return u;&#125;void UnionSets(int u, int v)&#123;    if (DisjointSet[u].Rank &gt;= DisjointSet[v].Rank)        DisjointSet[v].Parent = u;    else        DisjointSet[u].Parent = v;    if (DisjointSet[u].Rank == DisjointSet[v].Rank)        DisjointSet[u].Rank++;&#125;void Initialization()&#123;    GenEdges();    sort(Edges.begin(), Edges.end(),        [](pair&lt;pair&lt;int, int&gt;, int&gt;a,            pair&lt;pair&lt;int, int&gt;, int&gt;b)        &#123;return a.second &lt; b.second; &#125;);    MakeSets();    MST.clear();&#125;void GenEdges()&#123;    Edges.clear();    //Traverse the upper triangle of WMatrix    for (int i = 0; i &lt; n - 1; i++)    &#123;        for (int j = i + 1; j &lt; n; j++)            if (WMatrix[i][j] != INF)                Edges.push_back(&#123; &#123;i, j&#125;,                    WMatrix[i][j] &#125;);    &#125;&#125;void MakeSets()&#123;    DisjointSet.clear();    for (int i = 0; i &lt; n; i++)        DisjointSet.push_back(DJSNode(i));&#125;void OutputWMatrix()&#123;    printf(&quot;n = %d\n&quot;, n);    printf(&quot;The weight matrix:\n&quot;);    printf(&quot;%3c&quot;, &#39; &#39;);    for (int j = 0; j &lt; n; j++)        printf(&quot;%3d&quot;, j + 1);    printf(&quot;\n&quot;);    for (int i = 0; i &lt; n; i++)    &#123;        printf(&quot;%3d&quot;, i + 1);        for (auto j : WMatrix[i])            if (j &lt; INF)                printf(&quot;%3d&quot;, j);            else                printf(&quot;%3c&quot;, &#39;*&#39;);        printf(&quot;\n&quot;);    &#125;&#125;void OutputPath(int u)&#123;    if (Prev[u] == -1)        printf(&quot;%d&quot;, u + 1);    else    &#123;        OutputPath(Prev[u]);        printf(&quot;-%d&quot;, u + 1);    &#125;&#125;void GenMSTList()&#123;    MSTList.clear();    MSTList.resize(n);    for (auto &amp;e: MST)    &#123;        MSTList[e.first].push_back(e.second);        MSTList[e.second].push_back(e.first);    &#125;&#125;void GenPrev(int v)&#123;    for (auto &amp;u : MSTList[v])        if (u != -1)        &#123;            Prev[u] = v;            auto w = find(MSTList[u].begin(),                MSTList[u].end(), v);            MSTList[u][w - MSTList[u].begin()] = -1;            GenPrev(u);        &#125;&#125;void Output(int v0)&#123;    printf(&quot;Kruskal&#39;s MST algorithm\n&quot;);    OutputWMatrix();    int wSum = 0;    for (int i = 0; i &lt; n - 1; i++)        wSum += WMatrix[MST[i].first][MST[i].second];    GenMSTList();    Prev.clear();    Prev.resize(n);    Prev[v0] = -1;    GenPrev(v0);    printf(&quot;The MST edges:\n&quot;);    printf(&quot;Edge Weight\n&quot;);    for (auto &amp;e : MST)        printf(&quot; %d-%d  %d\n&quot;, e.first + 1, e.second + 1,            WMatrix[e.first][e.second]);    printf(&quot;Total MST weight: %d\n&quot;, wSum);    printf(&quot;The MST paths from vertex %d:\n&quot;, v0 + 1);    for (int u = 0; u &lt; n; u++)        if (u != v0)        &#123;            printf(&quot;%3d: &quot;, u + 1);            OutputPath(u);            printf(&quot;\n&quot;);        &#125;    printf(&quot;\n&quot;);&#125;&#125; //namespace NS_KruskalMSTusing namespace NS_KruskalMST;void TestKruskalMST(int v0 = 0)&#123;    vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt; w = &#123;        //https://www.geeksforgeeks.org/        //prims-minimum-spanning-tree-mst-greedy-algo-5/        &#123;            &#123;   0,  2,INF,  6,INF &#125;,            &#123;   2,  0,  3,  8,  5 &#125;,            &#123; INF,  3,  0,INF,  7 &#125;,            &#123;   6,  8,INF,  0,  9 &#125;,            &#123; INF,  5,  7,  9,  0 &#125;        &#125;,        // Dijkstra&#39;s algorithm on Wikipedia        &#123;            &#123;   0,  7,  9,INF,INF, 14 &#125;,            &#123;   7,  0, 10, 15,INF,INF &#125;,            &#123;   9, 10,  0, 11,INF,  2 &#125;,            &#123; INF, 15, 11,  0,  6,INF &#125;,            &#123; INF,INF,INF,  6,  0,  9 &#125;,            &#123;  14,INF,  2,INF,  9,  0 &#125;,        &#125;,        //https://www.geeksforgeeks.org/        //kruskals-minimum-spanning-tree-using-stl-in-c/        &#123;            &#123;   0,  4,INF,INF,INF,INF,INF,  8,INF &#125;,            &#123;   4,  0,  8,INF,INF,INF,INF, 11,INF &#125;,            &#123; INF,  8,  0,  7,INF,  4,INF,INF,  2 &#125;,            &#123; INF,INF,  7,  0,  9, 14,INF,INF,INF &#125;,            &#123; INF,INF,INF,  9,  0, 10,INF,INF,INF &#125;,            &#123; INF,INF,  4, 14, 10,  0,  2,INF,INF &#125;,            &#123; INF,INF,INF,INF,INF,  2,  0,  1,  6 &#125;,            &#123;   8, 11,INF,INF,INF,INF,  1,  0,  7 &#125;,            &#123; INF,INF,  2,INF,INF,INF,  6,  7,  0 &#125;,        &#125;,    &#125;;    int k = w.size();    for (int i = 0; i &lt; k; i++)    &#123;      if (v0 &gt; w[i].size() - 1)        v0 = w[i].size() - 1;      KruskalMSTCaller(w[i].size(), w[i], v0);    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 贪心算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Vue接口调用学习笔记</title>
      <link href="/blog/frhg9i/"/>
      <url>/blog/frhg9i/</url>
      
        <content type="html"><![CDATA[<ul><li><input disabled="" type="checkbox"> 计时器和定时器这方面的知识不太熟悉</li></ul><h3 id="接口调用方式"><a href="#接口调用方式" class="headerlink" title="接口调用方式"></a>接口调用方式</h3><ul><li>原生 ajax</li><li>基于 jQuery 的 ajax</li><li>fetch</li><li>axios</li></ul><h3 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h3><ul><li>JavaScript 的执行环境是「单线程」</li><li>所谓单线程，是指 JS 引擎中负责解释和执行 JavaScript 代码的线程只有一个，也就是一次只能完成一项任务，这个任务执行完后才能执行下一个，它会「阻塞」其他任务。这个任务可称为主线程</li><li>异步模式可以一起执行<strong>多个任务</strong></li><li>JS 中常见的异步调用<ul><li>定时任何</li><li>ajax</li><li>事件函数</li></ul></li></ul><h3 id="promise"><a href="#promise" class="headerlink" title="promise"></a>promise</h3><ul><li>主要解决异步深层嵌套的问题</li><li>promise 提供了简洁的 API   使得异步操作更加容易</li></ul><pre><code class="html">&lt;script type=&quot;text/javascript&quot;&gt;  /*     1. Promise基本使用     我们使用new来构建一个Promise  Promise的构造函数接收一个参数，是函数，并且传入两个参数：           resolve，reject， 分别表示异步操作执行成功后的回调函数和异步操作执行失败后的回调函数    */  var p = new Promise(function (resolve, reject) &#123;    //2. 这里用于实现异步任务  setTimeout    setTimeout(function () &#123;      var flag = false;      if (flag) &#123;        //3. 正常情况        resolve(&quot;hello&quot;);      &#125; else &#123;        //4. 异常情况        reject(&quot;出错了&quot;);      &#125;    &#125;, 100);  &#125;);  //  5 Promise实例生成以后，可以用then方法指定resolved状态和reject状态的回调函数  //  在then方法中，你也可以直接return数据而不是Promise对象，在后面的then中就可以接收到数据了  p.then(    function (data) &#123;      console.log(data);    &#125;,    function (info) &#123;      console.log(info);    &#125;  );&lt;/script&gt;</code></pre><h3 id="基于-Promise-发送-Ajax-请求"><a href="#基于-Promise-发送-Ajax-请求" class="headerlink" title="基于 Promise 发送 Ajax 请求"></a>基于 Promise 发送 Ajax 请求</h3><pre><code class="html">&lt;script type=&quot;text/javascript&quot;&gt;     /*       基于Promise发送Ajax请求     */     function queryData(url) &#123;      #   1.1 创建一个Promise实例       var p = new Promise(function(resolve, reject)&#123;         var xhr = new XMLHttpRequest();         xhr.onreadystatechange = function()&#123;           if(xhr.readyState != 4) return;           if(xhr.readyState == 4 &amp;&amp; xhr.status == 200) &#123;             # 1.2 处理正常的情况             resolve(xhr.responseText);           &#125;else&#123;             # 1.3 处理异常情况             reject(&#39;服务器错误&#39;);           &#125;         &#125;;         xhr.open(&#39;get&#39;, url);         xhr.send(null);       &#125;);       return p;     &#125;  # 注意：  这里需要开启一个服务     # 在then方法中，你也可以直接return数据而不是Promise对象，在后面的then中就可以接收到数据了     queryData(&#39;http://localhost:3000/data&#39;)       .then(function(data)&#123;         console.log(data)         #  1.4 想要继续链式编程下去 需要 return         return queryData(&#39;http://localhost:3000/data1&#39;);       &#125;)       .then(function(data)&#123;         console.log(data);         return queryData(&#39;http://localhost:3000/data2&#39;);       &#125;)       .then(function(data)&#123;         console.log(data)       &#125;);&lt;/script&gt;</code></pre><h3 id="Promise-基本-API"><a href="#Promise-基本-API" class="headerlink" title="Promise   基本 API"></a>Promise   基本 API</h3><h4 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h4><h5 id="then"><a href="#then" class="headerlink" title=".then()"></a>.then()</h5><ul><li>得到异步任务正确的结果</li></ul><h5 id="catch"><a href="#catch" class="headerlink" title=".catch()"></a>.catch()</h5><ul><li>获取异常信息</li></ul><h5 id="finally"><a href="#finally" class="headerlink" title=".finally()"></a>.finally()</h5><ul><li>成功与否都会执行（不是正式标准）</li></ul><pre><code class="html">&lt;script type=&quot;text/javascript&quot;&gt;  /*    Promise常用API-实例方法  */  // console.dir(Promise);  function foo() &#123;    return new Promise(function(resolve, reject)&#123;      setTimeout(function()&#123;        // resolve(123);        reject(&#39;error&#39;);      &#125;, 100);    &#125;)  &#125;  // foo()  //   .then(function(data)&#123;  //     console.log(data)  //   &#125;)  //   .catch(function(data)&#123;  //     console.log(data)  //   &#125;)  //   .finally(function()&#123;  //     console.log(&#39;finished&#39;)  //   &#125;);  // --------------------------  // 两种写法是等效的  foo()    .then(function(data)&#123;      # 得到异步任务正确的结果      console.log(data)    &#125;,function(data)&#123;      # 获取异常信息      console.log(data)    &#125;)    # 成功与否都会执行（不是正式标准）    .finally(function()&#123;      console.log(&#39;finished&#39;)    &#125;);&lt;/script&gt;</code></pre><h4 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h4><h5 id="all"><a href="#all" class="headerlink" title=".all()"></a>.all()</h5><ul><li><code>Promise.all</code>方法接受一个数组作参数，数组中的对象（p1、p2、p3）均为 promise 实例（如果不是一个 promise，该项会被用<code>Promise.resolve</code>转换为一个 promise)。它的状态由这三个 promise 实例决定</li></ul><h5 id="race"><a href="#race" class="headerlink" title=".race()"></a>.race()</h5><ul><li><code>Promise.race</code>方法同样接受一个数组作参数。当 p1, p2, p3 中有一个实例的状态发生改变（变为<code>fulfilled</code>或<code>rejected</code>），p 的状态就跟着改变。并把第一个改变状态的 promise 的返回值，传给 p 的回调函数</li></ul><pre><code class="html">&lt;script type=&quot;text/javascript&quot;&gt;  /*      Promise常用API-对象方法    */  // console.dir(Promise)  function queryData(url) &#123;    return new Promise(function (resolve, reject) &#123;      var xhr = new XMLHttpRequest();      xhr.onreadystatechange = function () &#123;        if (xhr.readyState != 4) return;        if (xhr.readyState == 4 &amp;&amp; xhr.status == 200) &#123;          // 处理正常的情况          resolve(xhr.responseText);        &#125; else &#123;          // 处理异常情况          reject(&quot;服务器错误&quot;);        &#125;      &#125;;      xhr.open(&quot;get&quot;, url);      xhr.send(null);    &#125;);  &#125;  var p1 = queryData(&quot;http://localhost:3000/a1&quot;);  var p2 = queryData(&quot;http://localhost:3000/a2&quot;);  var p3 = queryData(&quot;http://localhost:3000/a3&quot;);  Promise.all([p1, p2, p3]).then(function (result) &#123;    //   all 中的参数  [p1,p2,p3]   和 返回的结果一 一对应[&quot;HELLO TOM&quot;, &quot;HELLO JERRY&quot;, &quot;HELLO SPIKE&quot;]    console.log(result); //[&quot;HELLO TOM&quot;, &quot;HELLO JERRY&quot;, &quot;HELLO SPIKE&quot;]  &#125;);  Promise.race([p1, p2, p3]).then(function (result) &#123;    // 由于p1执行较快，Promise的then()将获得结果&#39;P1&#39;。p2,p3仍在继续执行，但执行结果将被丢弃。    console.log(result); // &quot;HELLO TOM&quot;  &#125;);&lt;/script&gt;</code></pre><h3 id="fetch"><a href="#fetch" class="headerlink" title="fetch"></a>fetch</h3><ul><li>Fetch API 是新的 ajax 解决方案 Fetch 会返回 Promise</li><li><strong>fetch 不是 ajax 的进一步封装，而是原生 js，没有使用 XMLHttpRequest 对象</strong>。</li><li>fetch(url, options).then(）</li></ul><pre><code class="html">&lt;script type=&quot;text/javascript&quot;&gt;  /*      Fetch API 基本用法          fetch(url).then()         第一个参数请求的路径   Fetch会返回Promise   所以我们可以使用then 拿到请求成功的结果     */  fetch(&quot;http://localhost:3000/fdata&quot;)    .then(function (data) &#123;      // text()方法属于fetchAPI的一部分，它返回一个Promise实例对象，用于获取后台返回的数据      return data.text();    &#125;)    .then(function (data) &#123;      //   在这个then里面我们能拿到最终的数据      console.log(data);    &#125;);&lt;/script&gt;</code></pre><h4 id="fetch-API-中的-HTTP-请求"><a href="#fetch-API-中的-HTTP-请求" class="headerlink" title="fetch API   中的 HTTP   请求"></a>fetch API   中的 HTTP   请求</h4><ul><li>fetch(url, options).then(）</li><li>HTTP 协议，它给我们提供了很多的方法，如 POST，GET，DELETE，UPDATE，PATCH 和 PUT<ul><li>默认的是 GET 请求</li><li>需要在 options 对象中 指定对应的 method       method:请求使用的方法</li><li>post 和 普通 请求的时候 需要在 options 中 设置   请求头 headers   和  body</li></ul></li></ul><pre><code class="html">&lt;script type=&quot;text/javascript&quot;&gt;    /*          Fetch API 调用接口传递参数    */   #1.1 GET参数传递 - 传统URL  通过url  ？ 的形式传参    fetch(&#39;http://localhost:3000/books?id=123&#39;, &#123;            # get 请求可以省略不写 默认的是GET            method: &#39;get&#39;        &#125;)        .then(function(data) &#123;            # 它返回一个Promise实例对象，用于获取后台返回的数据            return data.text();        &#125;).then(function(data) &#123;            # 在这个then里面我们能拿到最终的数据            console.log(data)        &#125;);  #1.2  GET参数传递  restful形式的URL  通过/ 的形式传递参数  即  id = 456 和id后台的配置有关    fetch(&#39;http://localhost:3000/books/456&#39;, &#123;            # get 请求可以省略不写 默认的是GET            method: &#39;get&#39;        &#125;)        .then(function(data) &#123;            return data.text();        &#125;).then(function(data) &#123;            console.log(data)        &#125;);   #2.1  DELETE请求方式参数传递      删除id  是  id=789    fetch(&#39;http://localhost:3000/books/789&#39;, &#123;            method: &#39;delete&#39;        &#125;)        .then(function(data) &#123;            return data.text();        &#125;).then(function(data) &#123;            console.log(data)        &#125;);   #3 POST请求传参    fetch(&#39;http://localhost:3000/books&#39;, &#123;            method: &#39;post&#39;,            # 3.1  传递数据            body: &#39;uname=lisi&amp;pwd=123&#39;,            #  3.2  设置请求头            headers: &#123;                &#39;Content-Type&#39;: &#39;application/x-www-form-urlencoded&#39;            &#125;        &#125;)        .then(function(data) &#123;            return data.text();        &#125;).then(function(data) &#123;            console.log(data)        &#125;);   # POST请求传参    fetch(&#39;http://localhost:3000/books&#39;, &#123;            method: &#39;post&#39;,            body: JSON.stringify(&#123;                uname: &#39;张三&#39;,                pwd: &#39;456&#39;            &#125;),            headers: &#123;                &#39;Content-Type&#39;: &#39;application/json&#39;            &#125;        &#125;)        .then(function(data) &#123;            return data.text();        &#125;).then(function(data) &#123;            console.log(data)        &#125;);    # PUT请求传参     修改id 是 123 的    fetch(&#39;http://localhost:3000/books/123&#39;, &#123;            method: &#39;put&#39;,            body: JSON.stringify(&#123;                uname: &#39;张三&#39;,                pwd: &#39;789&#39;            &#125;),            headers: &#123;                &#39;Content-Type&#39;: &#39;application/json&#39;            &#125;        &#125;)        .then(function(data) &#123;            return data.text();        &#125;).then(function(data) &#123;            console.log(data)        &#125;);&lt;/script&gt;</code></pre><h4 id="fetchAPI-中-响应格式"><a href="#fetchAPI-中-响应格式" class="headerlink" title="fetchAPI 中 响应格式"></a>fetchAPI 中 响应格式</h4><ul><li>用 fetch 来获取数据，如果响应正常返回，我们首先看到的是一个 response 对象，其中包括返回的一堆原始字节，这些字节需要在收到后，需要我们通过调用方法将其转换为相应格式的数据，比如<code>JSON</code>，<code>BLOB</code>或者<code>TEXT</code>等等</li></ul><pre><code class="javascript">/*      Fetch响应结果的数据格式    */fetch(&quot;http://localhost:3000/json&quot;)  .then(function (data) &#123;    // return data.json();   //  将获取到的数据使用 json 转换对象    return data.text(); //  //  将获取到的数据 转换成字符串  &#125;)  .then(function (data) &#123;    // console.log(data.uname)    // console.log(typeof data)    var obj = JSON.parse(data);    console.log(obj.uname, obj.age, obj.gender);  &#125;);</code></pre><h3 id="axios"><a href="#axios" class="headerlink" title="axios"></a>axios</h3><ul><li>基于 promise 用于浏览器和 node.js 的 http 客户端</li><li>支持浏览器和 node.js</li><li>支持 promise</li><li>能拦截请求和响应</li><li>自动转换 JSON 数据</li><li>能转换请求和响应数据</li></ul><h4 id="axios-基础用法"><a href="#axios-基础用法" class="headerlink" title="axios 基础用法"></a>axios 基础用法</h4><ul><li>get 和 delete 请求传递参数<ul><li>通过传统的 url   以<code>?</code>的形式传递参数</li><li>restful 形式传递参数</li><li>通过 params   形式传递参数</li></ul></li><li>post   和 put   请求传递参数<ul><li>通过选项传递参数</li><li>通过 URLSearchParams   传递参数</li></ul></li></ul><pre><code class="javascript">    # 1. 发送get 请求    axios.get(&#39;http://localhost:3000/adata&#39;).then(function(ret)&#123;      #  拿到 ret 是一个对象      所有的对象都存在 ret 的data 属性里面      // 注意data属性是固定的用法，用于获取后台的实际数据      // console.log(ret.data)      console.log(ret)    &#125;)    # 2.  get 请求传递参数    # 2.1  通过传统的url  以 ? 的形式传递参数    axios.get(&#39;http://localhost:3000/axios?id=123&#39;).then(function(ret)&#123;      console.log(ret.data)    &#125;)    # 2.2  restful 形式传递参数    axios.get(&#39;http://localhost:3000/axios/123&#39;).then(function(ret)&#123;      console.log(ret.data)    &#125;)    # 2.3  通过params  形式传递参数    axios.get(&#39;http://localhost:3000/axios&#39;, &#123;      params: &#123;        id: 789      &#125;    &#125;).then(function(ret)&#123;      console.log(ret.data)    &#125;)    #3 axios delete 请求传参     传参的形式和 get 请求一样    axios.delete(&#39;http://localhost:3000/axios&#39;, &#123;      params: &#123;        id: 111      &#125;    &#125;).then(function(ret)&#123;      console.log(ret.data)    &#125;)    # 4  axios 的 post 请求    # 4.1  通过选项传递参数    axios.post(&#39;http://localhost:3000/axios&#39;, &#123;      uname: &#39;lisi&#39;,      pwd: 123    &#125;).then(function(ret)&#123;      console.log(ret.data)    &#125;)    # 4.2  通过 URLSearchParams  传递参数    var params = new URLSearchParams();    params.append(&#39;uname&#39;, &#39;zhangsan&#39;);    params.append(&#39;pwd&#39;, &#39;111&#39;);    axios.post(&#39;http://localhost:3000/axios&#39;, params).then(function(ret)&#123;      console.log(ret.data)    &#125;)     #5  axios put 请求传参   和 post 请求一样    axios.put(&#39;http://localhost:3000/axios/123&#39;, &#123;      uname: &#39;lisi&#39;,      pwd: 123    &#125;).then(function(ret)&#123;      console.log(ret.data)    &#125;)</code></pre><h4 id="axios-全局配置"><a href="#axios-全局配置" class="headerlink" title="axios 全局配置"></a>axios 全局配置</h4><pre><code class="javascript">#  配置公共的请求头axios.defaults.baseURL = &#39;https://api.example.com&#39;;#  配置 超时时间axios.defaults.timeout = 2500;#  配置公共的请求头axios.defaults.headers.common[&#39;Authorization&#39;] = AUTH_TOKEN;# 配置公共的 post 的 Content-Typeaxios.defaults.headers.post[&#39;Content-Type&#39;] = &#39;application/x-www-form-urlencoded&#39;;</code></pre><h4 id="axios-拦截器"><a href="#axios-拦截器" class="headerlink" title="axios 拦截器"></a>axios 拦截器</h4><ul><li>请求拦截器<ul><li>请求拦截器的作用是在请求发送前进行一些操作<ul><li>例如在每个请求体里加上 token，统一做了处理如果以后要改也非常容易</li></ul></li></ul></li><li>响应拦截器<ul><li>响应拦截器的作用是在接收到响应后进行一些操作<ul><li>例如在服务器返回登录状态失效，需要重新登录的时候，跳转到登录页</li></ul></li></ul></li></ul><pre><code class="javascript">    # 1. 请求拦截器    axios.interceptors.request.use(function(config) &#123;      console.log(config.url)      # 1.1  任何请求都会经过这一步   在发送请求之前做些什么      config.headers.mytoken = &#39;nihao&#39;;      # 1.2  这里一定要return   否则配置不成功      return config;    &#125;, function(err)&#123;       #1.3 对请求错误做点什么      console.log(err)    &#125;)    #2. 响应拦截器    axios.interceptors.response.use(function(res) &#123;      #2.1  在接收响应做些什么      var data = res.data;      return data;    &#125;, function(err)&#123;      #2.2 对响应错误做点什么      console.log(err)    &#125;)</code></pre><h3 id="async-和-await"><a href="#async-和-await" class="headerlink" title="async   和 await"></a>async   和 await</h3><ul><li>async 作为一个关键字放到函数前面<ul><li>任何一个<code>async</code>函数都会隐式返回一个<code>promise</code></li></ul></li><li><code>await</code>关键字只能在使用<code>async</code>定义的函数中使用<ul><li>await 后面可以直接跟一个 Promise 实例对象</li><li>await 函数不能单独使用</li></ul></li><li><strong>async/await 让异步代码看起来、表现起来更像同步代码</strong></li></ul><pre><code class="javascript">     # 1.  async 基础用法    # 1.1 async作为一个关键字放到函数前面    async function queryData() &#123;      # 1.2 await关键字只能在使用async定义的函数中使用      await后面可以直接跟一个 Promise实例对象      var ret = await new Promise(function(resolve, reject)&#123;        setTimeout(function()&#123;          resolve(&#39;nihao&#39;)        &#125;,1000);      &#125;)      // console.log(ret.data)      return ret;    &#125;    # 1.3 任何一个async函数都会隐式返回一个promise   我们可以使用then 进行链式编程    queryData().then(function(data)&#123;      console.log(data)    &#125;)    #2.  async    函数处理多个异步函数    axios.defaults.baseURL = &#39;http://localhost:3000&#39;;    async function queryData() &#123;      # 2.1  添加await之后 当前的await 返回结果之后才会执行后面的代码      var info = await axios.get(&#39;async1&#39;);      #2.2  让异步代码看起来、表现起来更像同步代码      var ret = await axios.get(&#39;async2?info=&#39; + info.data);      return ret.data;    &#125;    queryData().then(function(data)&#123;      console.log(data)    &#125;)</code></pre><h3 id="图书列表案例"><a href="#图书列表案例" class="headerlink" title="图书列表案例"></a>图书列表案例</h3><h4 id="1-基于接口案例-获取图书列表"><a href="#1-基于接口案例-获取图书列表" class="headerlink" title="1. 基于接口案例-获取图书列表"></a>1. 基于接口案例-获取图书列表</h4><ul><li>导入 axios   用来发送 ajax</li><li>把获取到的数据渲染到页面上</li></ul><pre><code class="html">&lt;div id=&quot;app&quot;&gt;  &lt;div class=&quot;grid&quot;&gt;    &lt;table&gt;      &lt;thead&gt;        &lt;tr&gt;          &lt;th&gt;编号&lt;/th&gt;          &lt;th&gt;名称&lt;/th&gt;          &lt;th&gt;时间&lt;/th&gt;          &lt;th&gt;操作&lt;/th&gt;        &lt;/tr&gt;      &lt;/thead&gt;      &lt;tbody&gt;        &lt;!-- 5.  把books  中的数据渲染到页面上   --&gt;        &lt;tr :key=&quot;item.id&quot; v-for=&quot;item in books&quot;&gt;          &lt;td&gt;&#123;&#123;item.id&#125;&#125;&lt;/td&gt;          &lt;td&gt;&#123;&#123;item.name&#125;&#125;&lt;/td&gt;          &lt;td&gt;&#123;&#123;item.date &#125;&#125;&lt;/td&gt;          &lt;td&gt;            &lt;a href=&quot;&quot;&gt;修改&lt;/a&gt;            &lt;span&gt;|&lt;/span&gt;            &lt;a href=&quot;&quot;&gt;删除&lt;/a&gt;          &lt;/td&gt;        &lt;/tr&gt;      &lt;/tbody&gt;    &lt;/table&gt;  &lt;/div&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;js/vue.js&quot;&gt;&lt;/script&gt;1. 导入axios&lt;script type=&quot;text/javascript&quot; src=&quot;js/axios.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt;      /*           图书管理-添加图书       */      # 2   配置公共的url地址  简化后面的调用方式      axios.defaults.baseURL = &#39;http://localhost:3000/&#39;;      axios.interceptors.response.use(function(res) &#123;          return res.data;      &#125;, function(error) &#123;          console.log(error)      &#125;);      var vm = new Vue(&#123;          el: &#39;#app&#39;,          data: &#123;              flag: false,              submitFlag: false,              id: &#39;&#39;,              name: &#39;&#39;,              books: []          &#125;,          methods: &#123;              # 3 定义一个方法 用来发送 ajax              # 3.1  使用 async  来 让异步的代码  以同步的形式书写              queryData: async function() &#123;                  // 调用后台接口获取图书列表数据                  // var ret = await axios.get(&#39;books&#39;);                  // this.books = ret.data;      # 3.2  发送ajax请求  把拿到的数据放在books 里面                  this.books = await axios.get(&#39;books&#39;);              &#125;          &#125;,          mounted: function() &#123;  #  4 mounted  里面 DOM已经加载完毕  在这里调用函数              this.queryData();          &#125;      &#125;);&lt;/script&gt;</code></pre><h4 id="2-添加图书"><a href="#2-添加图书" class="headerlink" title="2   添加图书"></a>2   添加图书</h4><ul><li>获取用户输入的数据   发送到后台</li><li>渲染最新的数据到页面上</li></ul><pre><code class="javascript"> methods: &#123;    handle: async function()&#123;          if(this.flag) &#123;            // 编辑图书            // 就是根据当前的ID去更新数组中对应的数据            this.books.some((item) =&gt; &#123;              if(item.id == this.id) &#123;                item.name = this.name;                // 完成更新操作之后，需要终止循环                return true;              &#125;            &#125;);            this.flag = false;          &#125;else&#123;            # 1.1  在前面封装好的 handle 方法中  发送ajax请求            # 1.2  使用async  和 await 简化操作 需要在 function 前面添加 async            var ret = await axios.post(&#39;books&#39;, &#123;              name: this.name            &#125;)            # 1.3  根据后台返回的状态码判断是否加载数据            if(ret.status == 200) &#123;             # 1.4  调用 queryData 这个方法  渲染最新的数据              this.queryData();            &#125;          &#125;          // 清空表单          this.id = &#39;&#39;;          this.name = &#39;&#39;;        &#125;, &#125;</code></pre><h4 id="3-验证图书名称是否存在"><a href="#3-验证图书名称是否存在" class="headerlink" title="3   验证图书名称是否存在"></a>3   验证图书名称是否存在</h4><ul><li>添加图书之前发送请求验证图示是否已经存在</li><li>如果不存在 往后台里面添加图书名称<ul><li>图书存在与否只需要修改 submitFlag 的值即可</li></ul></li></ul><pre><code class="javascript"> watch: &#123;        name: async function(val) &#123;          // 验证图书名称是否已经存在          // var flag = this.books.some(function(item)&#123;          //   return item.name == val;          // &#125;);          var ret = await axios.get(&#39;/books/book/&#39; + this.name);          if(ret.status == 1) &#123;            // 图书名称存在            this.submitFlag = true;          &#125;else&#123;            // 图书名称不存在            this.submitFlag = false;          &#125;        &#125;&#125;,</code></pre><h4 id="4-编辑图书"><a href="#4-编辑图书" class="headerlink" title="4.   编辑图书"></a>4.   编辑图书</h4><ul><li>根据当前书的 id 查询需要编辑的书籍</li><li>需要根据状态位判断是添加还是编辑</li></ul><pre><code class="javascript"> methods: &#123;        handle: async function()&#123;          if(this.flag) &#123;            #4.3 编辑图书   把用户输入的信息提交到后台            var ret = await axios.put(&#39;books/&#39; + this.id, &#123;              name: this.name            &#125;);            if(ret.status == 200)&#123;              #4.4  完成添加后 重新加载列表数据              this.queryData();            &#125;            this.flag = false;          &#125;else&#123;            // 添加图书            var ret = await axios.post(&#39;books&#39;, &#123;              name: this.name            &#125;)            if(ret.status == 200) &#123;              // 重新加载列表数据              this.queryData();            &#125;          &#125;          // 清空表单          this.id = &#39;&#39;;          this.name = &#39;&#39;;        &#125;,        toEdit: async function(id)&#123;          #4.1  flag状态位用于区分编辑和添加操作          this.flag = true;          #4.2  根据id查询出对应的图书信息  页面中可以加载出来最新的信息          # 调用接口发送ajax 请求          var ret = await axios.get(&#39;books/&#39; + id);          this.id = ret.id;          this.name = ret.name;        &#125;,</code></pre><h4 id="5-删除图书"><a href="#5-删除图书" class="headerlink" title="5 删除图书"></a>5 删除图书</h4><ul><li>把需要删除的 id 书籍 通过参数的形式传递到后台</li></ul><pre><code class="javascript">   deleteBook: async function(id)&#123;          // 删除图书          var ret = await axios.delete(&#39;books/&#39; + id);          if(ret.status == 200) &#123;            // 重新加载列表数据            this.queryData();          &#125;   &#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 👨‍💻Web开发 </category>
          
          <category> Vue </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>GitHub Actions仓库分离代码分析</title>
      <link href="/blog/xvletn/"/>
      <url>/blog/xvletn/</url>
      
        <content type="html"><![CDATA[<p>这是加密文章！</p>]]></content>
      
      
      <categories>
          
          <category> ✨其他 </category>
          
          <category> 玩转博客 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Git提交规范</title>
      <link href="/blog/lezklv/"/>
      <url>/blog/lezklv/</url>
      
        <content type="html"><![CDATA[<h2 id="一、提交格式"><a href="#一、提交格式" class="headerlink" title="一、提交格式"></a>一、提交格式</h2><h3 id="commit-message-格式"><a href="#commit-message-格式" class="headerlink" title="commit message 格式"></a>commit message 格式</h3><pre><code class="bash">&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;</code></pre><h3 id="type-必须）"><a href="#type-必须）" class="headerlink" title="type(必须）"></a>type(必须）</h3><blockquote><p>用于说明 git commit 的类别，只允许使用下面的标识。</p></blockquote><p>feat：新功能（feature）。<br>fix/to：修复 bug，可以是 QA 发现的 BUG，也可以是研发自己发现的 BUG。</p><ul><li>fix：产生 diff 并自动修复此问题。适合于一次提交直接修复问题</li><li>to：只产生 diff 不自动修复此问题。适合于多次提交。最终修复问题提交时使用 fix</li></ul><p>docs：文档（documentation）。<br>style：格式（不影响代码运行的变动）。<br>refactor：重构（即不是新增功能，也不是修改 bug 的代码变动）<br>perf：优化相关，比如提升性能、体验。<br>test：增加测试。<br>chore：构建过程或辅助工具的变动。<br>revert：回滚到上一个版本。<br>merge：代码合并。<br>sync：同步主线或分支的 Bug。</p><h2 id="二、开发流程"><a href="#二、开发流程" class="headerlink" title="二、开发流程"></a>二、开发流程</h2><h3 id="线上库命名"><a href="#线上库命名" class="headerlink" title="线上库命名"></a>线上库命名</h3><p>master：测试站的分支<br>develop：开发站的分支<br>release：部署到正式站的分支</p><h3 id="SOP（开发流程）"><a href="#SOP（开发流程）" class="headerlink" title="SOP（开发流程）"></a>SOP（开发流程）</h3><ul><li>在本地 main 主分支下创建新分支</li></ul><pre><code class="bash">git checkout -b &quot;dev/wzt-feat-newFeature&quot;</code></pre><ul><li>push 即可</li></ul>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> Git+GitHub </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>GitHub Pages相关使用</title>
      <link href="/blog/di1z9u/"/>
      <url>/blog/di1z9u/</url>
      
        <content type="html"><![CDATA[<div style="background: #FFFBE6;padding:10px;border: 1px solid #C3C3C3;border-radius:5px;margin-bottom:5px;">GitHub Pages是GitHub软件的一个页面展示功能，它可以让展示用户的个人信息，也可以为你在GitHub上存放的一个项目定制一个介绍页面（纯静态网站）</div><blockquote><p>官网地址：<a href="https://pages.github.com/">https://pages.github.com/</a></p></blockquote><h2 id="xxxx-github-io-仓库的创建"><a href="#xxxx-github-io-仓库的创建" class="headerlink" title="xxxx.github.io 仓库的创建"></a>xxxx.github.io 仓库的创建</h2><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616657760639-b6e36a91-6822-4ea2-9dc4-649ec5ef9768.png#crop=0&crop=0&crop=1&crop=1&height=126&id=uq7fd&margin=%5Bobject%20Object%5D&name=image.png&originHeight=251&originWidth=1893&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=44413&status=done&style=stroke&title=&width=946.5" alt="image.png"><br>创建一个用户名.github.io 的仓库，这个仓库的主分支下的静态网页就可以被访问到了，比如我创建的 wztlink1013.github.io 仓库，访问<a href="https://wztlink1013.github.io就可以访问了./">https://wztlink1013.github.io就可以访问了。</a></p><div style="background: #FFFBE6;padding:10px;border: 1px solid #C3C3C3;border-radius:5px;margin-bottom:5px;">需要注意的有：<ul><li>仓库必须有 index.html 文件</div></li></ul><h2 id="gh-pages-分支的使用"><a href="#gh-pages-分支的使用" class="headerlink" title="gh-pages 分支的使用"></a>gh-pages 分支的使用</h2><p>其他仓库（非 wztlink1013.github.io 仓库）下新建 gh-pages 分支，则 gh-pages 分支下的静态网页会被访问到，比如<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616658110985-fab12af6-362b-4fca-838c-78441e834197.png#crop=0&crop=0&crop=1&crop=1&height=340&id=GVSVP&margin=%5Bobject%20Object%5D&name=image.png&originHeight=679&originWidth=1891&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=159234&status=done&style=stroke&title=&width=945.5" alt="image.png"></p><h2 id="私有仓库下的共有-Pages"><a href="#私有仓库下的共有-Pages" class="headerlink" title="私有仓库下的共有 Pages"></a>私有仓库下的共有 Pages</h2><blockquote><p>Caution: This repository is private but the published site will be public.</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1605229290479-7c20a062-56f7-4f20-af37-b3354ca69daf.png#crop=0&crop=0&crop=1&crop=1&height=304&id=kY2We&margin=%5Bobject%20Object%5D&name=image.png&originHeight=857&originWidth=1252&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=87132&status=done&style=stroke&title=&width=444" alt="image.png"></p><div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">简单解释一下就是，仓库虽然是私有的，但是gh-pages下的静态页面将会被公开。</div><h2 id="gh-pages-分支下的静态-css-js-资源加载失败"><a href="#gh-pages-分支下的静态-css-js-资源加载失败" class="headerlink" title="gh-pages 分支下的静态 css/js 资源加载失败"></a>gh-pages 分支下的静态 css/js 资源加载失败</h2><div style="background: #FFF3F3;padding:10px;border: 1px solid #DEB8BE;border-radius:5px;margin-bottom:5px;">单个仓库下的gh-pages分支，可能导致静态网页css/js等文件加载不了，问题出在网站的css/js的引用方面上</div><div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">更改_yaml文件下的root的路径即可</div><p><strong>参考：</strong></p><ul><li><a href="https://blog.csdn.net/simple_the_best/article/details/53403787">https://blog.csdn.net/simple_the_best/article/details/53403787</a></li></ul><h2 id="使用-issues-搭建博客"><a href="#使用-issues-搭建博客" class="headerlink" title="使用 issues 搭建博客"></a>使用 issues 搭建博客</h2><p>这个就比较会玩了，将 GitHub 的 API 接口玩的溜溜的……<img src="https://cdn.nlark.com/yuque/0/2021/gif/1484158/1616657583331-5d034146-804a-44e8-a90e-994f86de946a.gif#crop=0&crop=0&crop=1&crop=1&height=90&id=NXawR&margin=%5Bobject%20Object%5D&name=huaji53f28867be2378c3.gif&originHeight=90&originWidth=90&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=8805&status=done&style=none&title=&width=90" alt="huaji53f28867be2378c3.gif"><br>先插个眼，日后技术学到家再来玩玩这个<img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1616657633200-0f3a1324-21c2-4165-a23f-9a86ac69f399.jpeg#crop=0&crop=0&crop=1&crop=1&height=50&id=K09k5&margin=%5Bobject%20Object%5D&name=huaji-19bbf9b05f8aad09.jpeg&originHeight=50&originWidth=51&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=969&status=done&style=none&title=&width=51" alt="huaji-19bbf9b05f8aad09.jpeg"><br><a href="https://github.com/Pines-Cheng/blog"></a></p>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> Git+GitHub </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>搭建Windows子系统Linux及其相关命令</title>
      <link href="/blog/xnh83z/"/>
      <url>/blog/xnh83z/</url>
      
        <content type="html"><![CDATA[<h2 id="Windows-子系统-Linux"><a href="#Windows-子系统-Linux" class="headerlink" title="Windows 子系统 Linux"></a>Windows 子系统 Linux</h2><h3 id="子系统-Linux-下载安装"><a href="#子系统-Linux-下载安装" class="headerlink" title="子系统 Linux 下载安装"></a>子系统 Linux 下载安装</h3><p>在 windows 里面搜索 <code>windows功能</code> <br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1604913834448-30d164c9-e0a6-47f8-baac-03c5d6648186.png#height=517&id=CJVjC&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1033&originWidth=1176&originalType=binary%E2%88%B6=1&size=659449&status=done&style=shadow&width=588" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1604913865729-b20b3a35-ab49-48c9-be97-9f3c56d6d7a6.png#height=295&id=HcgSp&margin=%5Bobject%20Object%5D&name=image.png&originHeight=590&originWidth=623&originalType=binary%E2%88%B6=1&size=61833&status=done&style=shadow&width=311.5" alt="image.png"><br>然后已知下一步操作即可，该过程中会有重启的过程。<br>之后重启之后在应用商店下载 Ubuntu 系统，如下。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1604913776014-38c5ce17-996d-4827-8c49-bb047b2f7d3c.png#height=339&id=JGNy1&margin=%5Bobject%20Object%5D&name=image.png&originHeight=948&originWidth=1200&originalType=binary%E2%88%B6=1&size=183352&status=done&style=shadow&width=429" alt="image.png"><br>然后启动的时候，会有让自己输入用户名和密码的情况。输入确认就好了（<strong>输入密码的时候，终端内不会显示光标以及输入的字符！但是会有密码验证</strong>）<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1630977376308-3239ad06-8a3a-406a-8c0f-6ed478ce0c3b.png#clientId=u9be8cb3d-4e4d-4&from=paste&height=487&id=u250e6022&margin=%5Bobject%20Object%5D&name=image.png&originHeight=974&originWidth=1440&originalType=binary%E2%88%B6=1&size=121690&status=done&style=none&taskId=u847cda3f-3378-4c28-9994-03fef315c24&width=720" alt="image.png"></p><h3 id="子系统-Linux-文件目录"><a href="#子系统-Linux-文件目录" class="headerlink" title="子系统 Linux 文件目录"></a>子系统 Linux 文件目录</h3><pre><code class="powershell">C:\Users\wztli\AppData\Local\Packages\CanonicalGroupLimited.UbuntuonWindows_79rhkp1fndgsc\LocalState\rootfs\home\wztlink1013</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1604914117863-4fc253c2-1978-44b1-94c6-48e82a3ddf3a.png#height=111&id=t36kI&margin=%5Bobject%20Object%5D&name=image.png&originHeight=221&originWidth=1468&originalType=binary%E2%88%B6=1&size=28524&status=done&style=shadow&width=734" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1604914176405-056c5008-8168-40f8-a599-0e7951cad309.png#height=293&id=VZms0&margin=%5Bobject%20Object%5D&name=image.png&originHeight=585&originWidth=1406&originalType=binary%E2%88%B6=1&size=115194&status=done&style=shadow&width=703" alt="image.png"></p><h3 id="Linux-访问-Windows-文件"><a href="#Linux-访问-Windows-文件" class="headerlink" title="Linux 访问 Windows 文件"></a>Linux 访问 Windows 文件</h3><p>如下图中 1 所示，访问时，需要先将 Windows 磁盘挂载到/mnt 下面，然后就可以访问了。</p><ul><li>ls 命令：列举指定文件夹下的目录</li><li>cd 命令：在指定文件夹下运行该 linux 环境</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1604914600884-f758bc8f-668d-4354-be9f-f9be774cfff1.png#height=189&id=HLsJa&margin=%5Bobject%20Object%5D&name=image.png&originHeight=378&originWidth=1122&originalType=binary%E2%88%B6=1&size=63616&status=done&style=shadow&width=561" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> 🔨环境工具 </category>
          
          <category> 环境搭建 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>一个梦——一切都太迟了</title>
      <link href="/essay/gx3g8t/"/>
      <url>/essay/gx3g8t/</url>
      
        <content type="html"><![CDATA[<p>那天早上，老康起得很早，五点就起床了，说是要坐车去考教资，然后我突然迷迷糊糊被他起床的动静吵醒了，那天早上，我终于想起了什么…原来，黑魔法是存在的！！！</p><p><strong>和一批人上山</strong><br>有好几伙人，同时登上山顶，像是被什么所指引那般，都像是阻止什么，又好像是为了得到什么……</p><p><strong>我的境遇</strong><br>山顶那个小栈好像是取某个物品，</p><p>夜晚某个时辰，周围突然陷入黑暗，所有人都匆匆忙忙跑下山，那个客栈里面，大量的黑烟逐渐弥漫开来，我们都内心里面清楚，太迟了，我们都太迟了！</p><p>我赶紧跑下山，摔到了一个村庄，然后一直跑，跑到我那个伙伴的家里，我看到了我那副眼镜，然后一直跑，跑回我自己的地方了</p>]]></content>
      
      
      <categories>
          
          <category> 异世界 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[转]uni-app和传统三剑客的不同</title>
      <link href="/blog/ytoag7/"/>
      <url>/blog/ytoag7/</url>
      
        <content type="html"><![CDATA[<blockquote><blockquote><ul><li>本文转载自：<a href="https://ask.dcloud.net.cn/article/35657">白话 uni-app </a></li></ul></blockquote><ul><li>添加部分细节自己写的内容</li></ul></blockquote><h2 id="uni-app-相对传统的变化"><a href="#uni-app-相对传统的变化" class="headerlink" title="uni-app 相对传统的变化"></a>uni-app 相对传统的变化</h2><h3 id="网络模型的变化"><a href="#网络模型的变化" class="headerlink" title="网络模型的变化"></a>网络模型的变化</h3><p>之前学习的<code>javaweb</code>形式的是“相互嵌套”类型的，<code>jsp</code>代码里面可以有<code>html</code>代码。</p><p>以前网页大多是 b/s，服务端代码混合在页面里；<br>现在是 c/s，前后端分离，通过 js api(类似 ajax 的<code>uni.request</code>)获取 json 数据，把数据绑定在界面上渲染。</p><h3 id="文件类型变化"><a href="#文件类型变化" class="headerlink" title="文件类型变化"></a>文件类型变化</h3><p>.vue 文件通过编译，编译 js 文件</p><h3 id="代码架构大变动"><a href="#代码架构大变动" class="headerlink" title="代码架构大变动"></a>代码架构大变动</h3><p>以前的 HTML 代码节点，有 html 大节点，还有 script 和 style 两个小结点</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html&gt;  &lt;head&gt;    &lt;meta charset=&quot;utf-8&quot; /&gt;    &lt;title&gt;&lt;/title&gt;    &lt;script type=&quot;text/javascript&quot;&gt;&lt;/script&gt;    &lt;style type=&quot;text/css&quot;&gt;&lt;/style&gt;  &lt;/head&gt;  &lt;body&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>现在 template 是一级节点，用于写<strong>tag 组件</strong>，script 和 style 是并列的一级节点，也就是有 3 个一级节点</p><pre><code class="vue">&lt;template&gt;  &lt;view&gt;    注意必须有一个view，且只能有一个根view。所有内容写在这个view下面。  &lt;/view&gt;&lt;/template&gt;&lt;script&gt;export default &#123;&#125;;&lt;/script&gt;&lt;style&gt;&lt;/style&gt;</code></pre><ul><li><a href="https://cn.vuejs.org/v2/guide/single-file-components.html">Vue 单文件组件</a></li></ul><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="组件-标签的变化"><a href="#组件-标签的变化" class="headerlink" title="组件/标签的变化"></a>组件/标签的变化</h3><p>下为 html 标签和 uni-app 内置组件的映射表：<br>（其实老的 HTML 标签也可以在 uni-app 里使用，uni-app 编译器会在编译时把老标签转为新标签，比如把 div 编译成 view。但不推荐这种用法，调试 H5 端时容易混乱。）</p><ul><li>div 改成 <a href="https://uniapp.dcloud.io/component/view">view</a></li><li>span、font 改成 <a href="https://uniapp.dcloud.io/component/text">text</a></li><li>a 改成 <a href="https://uniapp.dcloud.io/component/navigator">navigator</a></li><li>img 改成 <a href="https://uniapp.dcloud.io/component/image">image</a></li><li><a href="https://uniapp.dcloud.io/component/input">input</a> 还在，但 type 属性改成了 confirmtype</li><li><a href="https://uniapp.dcloud.io/component/form">form</a>、<a href="https://uniapp.dcloud.io/component/button">button</a>、<a href="https://uniapp.dcloud.io/component/checkbox">checkbox</a>、<a href="https://uniapp.dcloud.io/component/radio">radio</a>、<a href="https://uniapp.dcloud.io/component/label">label</a>、<a href="https://uniapp.dcloud.io/component/textarea">textarea</a>、<a href="https://uniapp.dcloud.io/component/canvas">canvas</a>、<a href="https://uniapp.dcloud.io/component/video">video</a> 这些还在。</li><li>select 改成 <a href="https://uniapp.dcloud.io/component/picker">picker</a></li><li>iframe 改成 <a href="https://uniapp.dcloud.io/component/web-view">web-view</a></li><li>ul、li 没有了，都用 view 替代</li><li>audio 不再推荐使用，改成 api 方式，<a href="https://uniapp.dcloud.io/api/media/background-audio-manager?id=getbackgroundaudiomanager">背景音频 api 文档</a></li></ul><p><strong>除了改动外，新增了一批手机端常用的新组件</strong></p><ul><li>scroll-view <a href="https://uniapp.dcloud.io/component/scroll-view">可区域滚动视图容器</a></li><li>swiper <a href="https://uniapp.dcloud.io/component/swiper">可滑动区域视图容器</a></li><li>icon <a href="https://uniapp.dcloud.io/component/icon">图标</a></li><li>rich-text <a href="https://uniapp.dcloud.io/component/rich-text">富文本（不可执行 js，但可渲染各种文字格式和图片）</a></li><li>progress <a href="https://uniapp.dcloud.io/component/progress">进度条</a></li><li>slider <a href="https://uniapp.dcloud.io/component/slider">滑块指示器</a></li><li>switch <a href="https://uniapp.dcloud.io/component/switch">开关选择器</a></li><li>camera <a href="https://uniapp.dcloud.io/component/camera">相机</a></li><li>live-player <a href="https://uniapp.dcloud.io/component/live-player">直播</a></li><li>map <a href="https://uniapp.dcloud.io/component/map">地图</a></li><li>cover-view <a href="https://uniapp.dcloud.io/component/cover-view?id=cover-view">可覆盖原生组件的视图容器</a><br>cover-view 需要多强调几句，uni-app 的非 h5 端的 video、map、canvas、textarea 是原生组件，层级高于其他组件。如需覆盖原生组件，则需要使用 cover-view 组件。详见<a href="https://uniapp.dcloud.net.cn/component/native-component">层级介绍</a></li></ul><p>除了内置组件，还有很多开源的扩展组件，把常用操作都进行封装，DCloud 建立了插件市场收录这些扩展组件，详见<a href="https://ext.dcloud.net.cn/">插件市场</a></p><h3 id="工程结构和页面管理"><a href="#工程结构和页面管理" class="headerlink" title="工程结构和页面管理"></a>工程结构和页面管理</h3><p>uni-app 的工程结构有单独的要求，<a href="https://uniapp.dcloud.io/frame?id=%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84">详见</a></p><p>每个可显示的页面，都必须在 <a href="https://uniapp.dcloud.io/collocation/pages">pages.json</a> 中注册。如果你开发过小程序，那么 pages.json 类似 app.json。如果你熟悉 vue，这里没有 vue 的路由，都是在 pages.json 里管理。</p><p>原来工程的首页一般是 index.html 或 default.html，是在 web server 里配的。而 uni-app 的首页，是在 pages.json 里配的，page 节点下第一个页面就是首页。一般在/pages/xx 的目录下。</p><p>app 和小程序中，为了提升体验，页面提供了原生的导航栏和底部 tabbar，注意这些配置是在 pages.json 中做，而不是在 vue 页面里创建，但点击事件的监听在显示的 vue 页面中做。</p><p>如果你熟悉小程序开发的话，对比变化如下：</p><ul><li>原来 app.json 被一拆为二。页面管理，被挪入了 uni-app 的 pages.json；非页面管理，挪入了 manifest.json</li><li>原来的 app.js 和 app.wxss 被合并到了 app.vue 中</li></ul><h2 id="文件导入方式变化"><a href="#文件导入方式变化" class="headerlink" title="文件导入方式变化"></a>文件导入方式变化</h2><h3 id="js-引入方式"><a href="#js-引入方式" class="headerlink" title="js 引入方式"></a>js 引入方式</h3><p>以前通过<code>script ``src</code>、<code>link ``href</code>引入外部的 js 和 css；<br>现在是<strong>es6</strong>的写法，<code>import</code>引入外部的 js 模块(注意不是文件)或 css<br>以前</p><pre><code class="javascript">&lt;script src=&quot;js/jquery-1.10.2.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;&lt;link href=&quot;css/bootstrap.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot;/&gt;</code></pre><p>现在</p><blockquote><p>js 要 require 进来，变成了对象。</p></blockquote><p>在 hello uni-app 项目的 common 目录有一个工具类<code>util.js</code>，可以在 hello uni-app 中搜索这个例子查看。</p><pre><code class="javascript">&lt;script&gt;  var util = require(&#39;../../../common/util.js&#39;); //require这个js模块 var  formatedPlayTime = util.formatTime(playTime); //调用js模块的方法&lt;/script&gt;</code></pre><p>而在这个<code>util.js</code>里，要把之前的 function 封装为对象的方法<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1604048264989-b4591bb0-e4bc-4581-aae5-bf7615f268b4.png#height=231&id=wkQ3w&margin=%5Bobject%20Object%5D&name=image.png&originHeight=606&originWidth=1331&originalType=binary%E2%88%B6=1&size=70716&status=done&style=shadow&width=508" alt="image.png"><br>当然还有一些高级的用法</p><pre><code class="javascript">var dateUtils = require(&quot;../../../common/util.js&quot;).dateUtils; //直接使用js模块的属性。在hello uni-app有示例import * as echarts from &quot;/components/echarts/echarts.simple.min.js&quot;; //将js导入并重命名为echarts，然后使用echarts.来继续执行方法。</code></pre><h3 id="CSS-引入方式"><a href="#CSS-引入方式" class="headerlink" title="CSS 引入方式"></a>CSS 引入方式</h3><pre><code class="css">&lt;style&gt;    @import &quot;./common/uni.css&quot;;    .uni-hello-text&#123;        color:#7A7E83;    &#125;&lt;/style&gt;</code></pre><p><strong>改全局样式：</strong>在根目录下的 app.vue 里写入，每个页面都会加载 app.vue 里的样式。</p><h3 id="组件导入"><a href="#组件导入" class="headerlink" title="组件导入"></a>组件导入</h3><p>类似 hexo 博客主题设计一样，能以组件的形式模块化导入。<br>如下是导入一个角标的组件库，在页面上显示一个 abc 并且右上角有个数字角标 1，<a href="http://ext.dcloud.net.cn/plugin?id=21">详见</a></p><pre><code class="vue">&lt;template&gt;  &lt;view&gt;    &lt;uni-badge text=&quot;abc&quot; :inverted=&quot;true&quot;&gt;&lt;/uni-badge    &gt;&lt;!--3.使用组件--&gt;  &lt;/view&gt;&lt;/template&gt;&lt;script&gt;import uniBadge from &quot;../../../components/uni-badge.vue&quot;; //1.导入组件（这步属于传统vue规范，但在uni-app的easycom下可以省略这步）export default &#123;  data() &#123;    return &#123;&#125;;  &#125;,  components: &#123;    uniBadge, //2.注册组件（这步属于传统vue规范，但在uni-app的easycom下可以省略这步）  &#125;,&#125;;&lt;/script&gt;</code></pre><p>如需要全局导入 vue 组件，即每个页面都可以直接使用而不用引用和注册的话，在项目根目录下的 main.js 里处理。如下是 hello uni-app 里的例子。</p><pre><code class="javascript">//main.jsimport pageHead from &quot;./components/page-head.vue&quot;; //导入Vue.component(&quot;page-head&quot;, pageHead); //注册。注册后在每个vue的page页面里可以直接使用&lt;page-head&gt;&lt;/page-head&gt;组件。</code></pre><p>上述的组件使用方式属于传统 vue 的概念。uni-app 2.7 以后推出了更简单的组件使用技术<a href="https://uniapp.dcloud.net.cn/collocation/pages?id=easycom">easycom</a>，无需引用和注册组件，直接在 template 区域使用组件即可。</p><h2 id="js-的变化"><a href="#js-的变化" class="headerlink" title="js 的变化"></a>js 的变化</h2><p>js 的变化，分为<strong>运行环境变化</strong>、<strong>数据绑定模式变化</strong>、<strong>api 变化</strong>3 部分。</p><h3 id="运行环境从浏览器变成-v8-引擎"><a href="#运行环境从浏览器变成-v8-引擎" class="headerlink" title="运行环境从浏览器变成 v8 引擎"></a>运行环境从浏览器变成 v8 引擎</h3><p>标准 js 语法和 api 都支持，比如 if、for、settimeout、indexOf 等。</p><p>但<strong>浏览器专用的</strong>window、document、navigator、location 对象，包括 cookie 等存储，<strong>只有在浏览器中才有</strong>，app 和小程序都不支持。</p><blockquote><p>可能有些人以为 js 等于浏览器里的 js。其实 js 是 ECMAScript 组织管理的，浏览器中的 js 是 w3c 组织基于 js 规范补充了 window、document、navigator、location 等专用对象。</p></blockquote><p>在 uni-app 的各个端中，除了 h5 端，其他端的 js 都运行在一个独立的 v8 引擎下，不是在浏览器中，所以浏览器的对象无法使用。如果你做过小程序开发，对此应当很了解。<br><strong>这意味着依赖 document 的很多 HTML 的库，比如 jqurey 无法使用。</strong><br>当然 app 和小程序支持 web-view 组件，里面可以加载标准 HTML，这种页面仍然支持浏览器专用对象 window、document、navigator、location。</p><h3 id="以前的-dom-操作，改成-vue-的-MVVM-模式"><a href="#以前的-dom-操作，改成-vue-的-MVVM-模式" class="headerlink" title="以前的 dom 操作，改成 vue 的 MVVM 模式"></a>以前的 dom 操作，改成 vue 的 MVVM 模式</h3><p>现在前端趋势是去 dom 化，改用<strong>mvvm 模式，</strong>更简洁的写法，大幅减少代码行数，同时差量渲染性能更好。<br>uni-app 使用 vue 的数据绑定方式解决 js 和 dom 界面交互的问题。<br>如果你想改变某个 dom 元素的显示内容，比如一个 view 的显示文字：<br><strong>以前</strong>是给 view 设 id，然后 js 里通过选择器获取 dom 元素，进一步通过 js 进行赋值操作，修改 dom 元素的属性或值。<br>如下演示了一段代码，页面中有个显示的文字区和一个按钮，点击按钮后会修改文字区的值</p><pre><code class="html">&lt;html&gt;  &lt;head&gt;    &lt;script type=&quot;text/javascript&quot;&gt;      document.addEventListener(&quot;DOMContentLoaded&quot;, function () &#123;        document.getElementById(&quot;spana&quot;).innerText = &quot;456&quot;;      &#125;);      function changetextvalue() &#123;        document.getElementById(&quot;spana&quot;).innerText = &quot;789&quot;;      &#125;    &lt;/script&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;span id=&quot;spana&quot;&gt;123&lt;/span&gt;    &lt;button type=&quot;button&quot; onclick=&quot;changetextvalue()&quot;&gt;修改为789&lt;/button&gt;  &lt;/body&gt;&lt;/html&gt;</code></pre><p>现在的做法，是<strong>vue 的绑定模式</strong>，给这个<strong>dom 元素绑定一个 js 变量</strong>，在 script 中修改 js 变量的值，dom 会自动变化，页面会自动更新渲染</p><pre><code class="vue">&lt;template&gt;  &lt;view&gt;    &lt;text&gt;&#123;&#123; textvalue &#125;&#125;&lt;/text    &gt;&lt;!-- 这里演示了组件值的绑定 --&gt;    &lt;button :type=&quot;buttontype&quot; @click=&quot;changetextvalue()&quot;&gt;修改为789&lt;/button    &gt;&lt;!-- 这里演示了属性和事件的绑定 --&gt;  &lt;/view&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  data() &#123;    return &#123;      textvalue: &quot;123&quot;,      buttontype: &quot;primary&quot;,    &#125;;  &#125;,  onLoad() &#123;    this.textvalue = &quot;456&quot;; //这里修改textvalue的值，其实123都来不及显示就变成了456  &#125;,  methods: &#123;    changetextvalue() &#123;      this.textvalue = &quot;789&quot;; //这里修改textvalue的值，页面自动刷新为789    &#125;,  &#125;,&#125;;&lt;/script&gt;</code></pre><p>注意上述代码中的 <code>export default &#123;&#125;</code> 里的 <code>data(): &#123;return &#123; &#125;&#125;</code>。<br>在 vue 的设计中，这里存放着页面中需要绑定的数据，写在 data 里，才能被界面正确的绑定和渲染。<br>注意：uni-app 的 vue 页面是 vue 的单文件组件规范，按照 vue 的定义只接受 function，必须用 return 包起来。<br>如果你学过小程序的数据绑定，但不了解 vue，要注意：</p><ul><li>小程序的数据绑定参考了 vue，但自己修改了一些。在 uni-app 中只支持标准的 vue，不支持小程序的数据绑定语法</li><li>小程序里的 setData 在 uni-app 里并不存在，因为 vue 是自动双向数据绑定的。直接通过赋值方式修改数据，如果数据绑定到界面上，界面会自动更新渲染</li></ul><p>从上述示例，还可看出事件的写法变化。</p><ul><li>以前，元素的事件是用 onxxx=””，里面写一段 js 或引用 function 的 name，比如上述代码中的<code>onclick=&quot;changetextvalue()&quot;</code></li><li>现在，需要在 js 的<code>export default &#123;&#125;</code> 里的 <code>methods: &#123;&#125;</code> 里写一个方法，然后在组件中使用<code>@click=&quot;changetextvalue()&quot;</code></li></ul><p>在 js 中，与 data 和 methods 平级的，如上述示例代码中的<code>onload()</code>，称为生命周期。在普通 vue 页面里的生命周期叫页面生命周期。在项目根目录的 app.vue 文件中的生命周期叫应用生命周期。<br>除了<code>onload</code>，还有<code>onready</code>等很多生命周期，具体见<a href="https://uniapp.dcloud.io/collocation/frame/lifecycle">uni-app 的生命周期</a><br>在高级用法里，<strong>vue 支持给组件设 ref（引用标记）</strong>，这类似于之前 html 中给一个 dom 元素设 id，然后在 js 中也可以用<code>this.$refs.xxx</code>来获取。如下：</p><pre><code class="vue">&lt;template&gt;  &lt;view&gt;    &lt;view ref=&quot;testview&quot;&gt;11111&lt;/view&gt;    &lt;button @click=&quot;getTest&quot;&gt;获取test节点&lt;/button&gt;  &lt;/view&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  methods: &#123;    getTest() &#123;      console.log(this.$refs.testview);    &#125;,  &#125;,&#125;;&lt;/script&gt;</code></pre><h3 id="js-api-的变化"><a href="#js-api-的变化" class="headerlink" title="js api 的变化"></a>js api 的变化</h3><p>因为 uni-app 的 api 是<strong>参考小程序</strong>的，所以<strong>和浏览器的 js api</strong>有很多不同，如</p><ol><li>alert,confirm 改成 <a href="https://uniapp.dcloud.io/api/ui/prompt?id=showmodal">uni.showmodel</a></li><li>ajax 改成 <a href="https://uniapp.dcloud.io/api/request/request">uni.request</a></li><li>cookie、session 没有了，local.storage 改成 <a href="https://uniapp.dcloud.io/api/storage/storage?id=setstorage">uni.storage</a></li></ol><p>uni-app 的 js api 还有很多，但基本就是小程序的 api，把 wx.xxx 改为 uni.xxx 即可。<a href="https://uniapp.dcloud.io/api/README">详见</a><br>uni-app 在不同的端，支持条件编译，无限制的使用各端独有的 api，<a href="https://uniapp.dcloud.io/platform">详见条件编译</a></p><h2 id="css-的变化"><a href="#css-的变化" class="headerlink" title="css 的变化"></a>css 的变化</h2><p><strong>标准的 css 基本都是支持的。</strong></p><h3 id="选择器方面"><a href="#选择器方面" class="headerlink" title="选择器方面"></a>选择器方面</h3><blockquote><p>有 2 个变化：</p></blockquote><ol><li>*选择器不支持；</li><li>元素选择器里没有 body，改为了 page。微信小程序即是如此。</li></ol><pre><code class="css">page &#123;&#125;</code></pre><ul><li><strong>单位方面：</strong>px 无法动态适应不同宽度的屏幕，rem 无法用于 nvue/weex。如果想使用根据屏幕宽度自适应的单位，推荐使用 rpx，全端支持。 <a href="https://uniapp.dcloud.io/frame?id=%E5%B0%BA%E5%AF%B8%E5%8D%95%E4%BD%8D">尺寸单位文档</a></li><li><strong>布局方面：</strong>uni-app 推荐使用 flex 布局，这个布局思路和传统流式布局有点区别。但 flex 的特色在于，不管是什么技术都支持这种排版，web、小程序/快应用、weex/rn、原生的 iOS、Android 开发，全都支持 flex。它是通吃所有端的新一代布局方案。相关教程请自行百度学习。</li></ul><h3 id="flex"><a href="#flex" class="headerlink" title="flex"></a>flex</h3><p>uni-app 的 vue 文件里支持所有 web 排版方式，不管是流式还是 flex。但 nvue 里，只支持 flex，因为它在 app 端是使用原生排版引擎渲染的。<br><strong>注意 css 里背景图和字体文件，尽量不要大于 40k，因为会影响性能。在小程序端，如果要大于 40k，需放到服务器侧远程引用或 base64 后引入，不能放到本地作为独立文件引用。</strong></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://uniapp.dcloud.net.cn/">https://uniapp.dcloud.net.cn/</a></li><li><a href="https://cn.vuejs.org/index.html">https://cn.vuejs.org/index.html</a></li><li>官方教程：<a href="https://ke.qq.com/course/343370">uni-app 跨平台框架官方教程</a></li><li><a href="https://ask.dcloud.net.cn/article/35657">白话 uni-app </a></li><li>微信官方文档：<a href="https://developers.weixin.qq.com/doc/">https://developers.weixin.qq.com/doc/</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 👨‍💻Web开发 </category>
          
          <category> Web其他知识 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Android平台与开发技术</title>
      <link href="/blog/im0an1/"/>
      <url>/blog/im0an1/</url>
      
        <content type="html"><![CDATA[<h2 id="一、目的"><a href="#一、目的" class="headerlink" title="一、目的"></a>一、目的</h2><p>大学期间，有没有能够<strong>有专业能力的项目实战</strong>。希望在你的将来的简历中加入技术方面的项目介绍。</p><h2 id="二、考核方式"><a href="#二、考核方式" class="headerlink" title="二、考核方式"></a>二、考核方式</h2><p>PBL 的方式组队，开发一个创意项目。</p><h2 id="三、课程背景"><a href="#三、课程背景" class="headerlink" title="三、课程背景"></a>三、课程背景</h2><ol><li>Android 平台简介</li><li>Google  提供了官方的 Android Studio<ol><li>Java  或者  Kotlin</li></ol></li><li>Apple 提供了官方的开发环境<ol><li>Swift 或者 OC</li></ol></li><li>Wechat 提供了官方的开发环境<ol><li>SNS  排第一的产品；Facebook</li><li>小程序，JD</li></ol></li><li>其他平台<ol><li>百度小程序等</li></ol></li></ol><h2 id="四、技术路线"><a href="#四、技术路线" class="headerlink" title="四、技术路线"></a>四、技术路线</h2><ol><li>uni-app  是一个使用 <a href="https://vuejs.org/">Vue.js</a> 开发所有前端应用的框架，开发者编写一套代码，可发布到 iOS、Android、H5、以及各种小程序（微信/支付宝/百度/头条/QQ/钉钉/淘宝）、快应用等多个平台。</li><li>DCloud 公司拥有 500 万开发者用户，几十万应用案例、10 亿手机端月活用户，数千款 uni-app 插件、70+微信/qq 群。阿里小程序工具官方内置 uni-app（<a href="https://docs.alipay.com/mini/ide/0.70-stable">详见</a>），腾讯课堂官方为 uni-app 录制培训课程（<a href="https://ask.dcloud.net.cn/article/35640">详见</a>），开发者可以放心选择。</li><li>uni-app 在手，做啥都不愁。即使不跨端，uni-app 也是更好的小程序开发框架（<a href="https://ask.dcloud.net.cn/article/35947">详见</a>）、更好的 App 跨平台框架、更方便的 H5 开发框架。不管领导安排什么样的项目，你都可以快速交付，不需要转换开发思维、不需要更改开发习惯。</li></ol><h2 id="五、快速上手-安装环境"><a href="#五、快速上手-安装环境" class="headerlink" title="五、快速上手+安装环境"></a>五、快速上手+安装环境</h2><p>uni-app 支持通过可视化界面、<a href="https://uniapp.dcloud.io/quickstart?id=%E9%80%9A%E8%BF%87vue-cli%E5%91%BD%E4%BB%A4%E8%A1%8C">vue-cli 命令行</a> 两种方式快速创建项目。</p><h3 id="通过-HBuilderX-可视化界面"><a href="#通过-HBuilderX-可视化界面" class="headerlink" title="通过  HBuilderX  可视化界面"></a><a href="https://uniapp.dcloud.io/quickstart?id=_1-%E9%80%9A%E8%BF%87-hbuilderx-%E5%8F%AF%E8%A7%86%E5%8C%96%E7%95%8C%E9%9D%A2">通过  HBuilderX  可视化界面</a></h3><ol><li>可视化的方式比较简单，HBuilderX 内置相关环境，开箱即用，无需配置 nodejs。</li><li>开始之前，开发者需先下载安装如下工具：</li><li>HBuilderX：<a href="https://www.dcloud.io/hbuilderx.html">官方 IDE 下载地址</a></li><li><a href="https://www.dcloud.io/hbuilderx.html">HBuilderX</a>是通用的前端开发工具，但为 uni-app 做了特别强化。</li><li>下载 App 开发版，可开箱即用；如下载标准版，在运行或发行 uni-app 时，会提示安装 uni-app 插件，插件下载完成后方可使用。</li></ol><h3 id="Chrome-最新版-Edge"><a href="#Chrome-最新版-Edge" class="headerlink" title="Chrome/最新版 Edge"></a>Chrome/最新版 Edge</h3><ul><li><a href="https://www.google.com/intl/zh-CN/chrome/">https://www.google.com/intl/zh-CN/chrome/</a></li><li>Edge(最新)浏览器：<a href="https://www.microsoftedgeinsider.com/en-us/download">下载地址（DEV 版本会消去插件开发者禁用状态）</a></li></ul><h3 id="Android-Studio"><a href="#Android-Studio" class="headerlink" title="Android Studio"></a>Android Studio</h3><ul><li>下载地址：<a href="https://developer.android.com/studio">https://developer.android.com/studio</a></li></ul><p>下载及配置参考：</p><ul><li><a href="https://blog.csdn.net/wangmx1993328/article/details/81905195">https://blog.csdn.net/wangmx1993328/article/details/81905195</a></li><li><a href="https://blog.csdn.net/qq_41976613/article/details/91432304">https://blog.csdn.net/qq_41976613/article/details/91432304</a></li><li><a href="https://blog.csdn.net/qq_41976613/article/details/104394870">https://blog.csdn.net/qq_41976613/article/details/104394870</a></li><li><a href="https://blog.csdn.net/liqz666/article/details/80243836">https://blog.csdn.net/liqz666/article/details/80243836</a></li><li><a href="https://blog.csdn.net/weixin_43717445/article/details/108719984">https://blog.csdn.net/weixin_43717445/article/details/108719984</a></li></ul><h3 id="gradle-国内源配置方法"><a href="#gradle-国内源配置方法" class="headerlink" title="gradle 国内源配置方法"></a>gradle 国内源配置方法</h3><p>Android Studio 在构建项目时会拉取 gradle 资源，而 goole 和 jcenter 在国内的网络环境并不好用，容易产生 connect timeout 等错误。因此将地址修改成阿里云的国内镜像。<br>一、允许使用 maven 仓库<br>　　点击 File-&gt;Settings 进入设置界面，勾选“Enable embedded Maven repository”，</p><p>二、修改 build.gradle<br>　　在项目文件中找到 build.gradle 文件，修改其中的 buildscript 和 allprojects 地址：</p><pre><code>buildscript &#123;    repositories &#123;        maven&#123; url &#39;http://maven.aliyun.com/nexus/content/groups/public/&#39; &#125;        maven&#123; url &#39;http://maven.aliyun.com/nexus/content/repositories/jcenter&#39;&#125;    &#125;    dependencies &#123;        classpath &#39;com.android.tools.build:gradle:3.3.0-alpha13&#39;    &#125;&#125;allprojects &#123;    repositories &#123;        maven&#123; url &#39;http://maven.aliyun.com/nexus/content/groups/public/&#39;&#125;        maven&#123; url &#39;http://maven.aliyun.com/nexus/content/repositories/jcenter&#39;&#125;    &#125;&#125;task clean(type: Delete) &#123;    delete rootProject.buildDir&#125;</code></pre><p>gradle 的文件下载下来以后会保存在本地，也有缓存。这意味着不同的项目如果有相同的 gradle 依赖，则不需要重复下载。因此也不是每次打开新项目都需要修改 build.gradle 文件。</p><p>如果修改 build.gradle 后重新 build 还是有错，可以尝试新建一个相同 API 版本的项目。</p><p>参考：</p><ul><li><a href="https://maven.aliyun.com/mvn/guide">阿里云 gradle 配置指南</a></li></ul><h2 id="六、考核方式"><a href="#六、考核方式" class="headerlink" title="六、考核方式"></a>六、考核方式</h2><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1605441751743-cb395908-39ce-4303-ab00-0c885d05abe9.png#height=294&id=f7AlH&margin=%5Bobject%20Object%5D&name=image.png&originHeight=588&originWidth=1192&originalType=binary%E2%88%B6=1&size=83972&status=done&style=none&width=596" alt="image.png"></p><h3 id="后台技术栈"><a href="#后台技术栈" class="headerlink" title="后台技术栈"></a>后台技术栈</h3><ul><li><p>PHP</p></li><li><p>Node.js</p><blockquote><p>JavaScript<br>node.js+express+ejs</p></blockquote></li><li><p>Spring Boot</p><blockquote><p>Java 框架，难</p></blockquote></li><li><p>数据库</p><blockquote><ul><li>MyBatis-Plus</li><li>DCloud</li></ul></blockquote></li></ul>]]></content>
      
      
      <categories>
          
          <category> 👨‍💻Web开发 </category>
          
          <category> Web其他知识 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++广义表</title>
      <link href="/blog/gosz5u/"/>
      <url>/blog/gosz5u/</url>
      
        <content type="html"><![CDATA[<h2 id="广义表举例"><a href="#广义表举例" class="headerlink" title="广义表举例"></a>广义表举例</h2><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1620291002536-6b098e81-6400-4139-876b-9ef890f1dc71.png#align=left&display=inline&height=183&margin=%5Bobject%20Object%5D&name=image.png&originHeight=366&originWidth=1337&size=242885&status=done&style=stroke&width=668.5" alt="image.png"></p><h2 id="广义表的-3-个重要结论"><a href="#广义表的-3-个重要结论" class="headerlink" title="广义表的 3 个重要结论"></a>广义表的 3 个重要结论</h2><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1620291048426-17db6fbb-8972-4d82-980e-6ff303f55752.png#align=left&display=inline&height=359&margin=%5Bobject%20Object%5D&name=image.png&originHeight=718&originWidth=1409&size=353253&status=done&style=stroke&width=704.5" alt="image.png"></p><h2 id="广义表的运算"><a href="#广义表的运算" class="headerlink" title="广义表的运算"></a>广义表的运算</h2><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1620291080210-d88e7855-41ed-45be-a433-1a60a64d3220.png#align=left&display=inline&height=291&margin=%5Bobject%20Object%5D&name=image.png&originHeight=581&originWidth=1390&size=377721&status=done&style=stroke&width=695" alt="image.png"></p><h2 id="一些题目"><a href="#一些题目" class="headerlink" title="一些题目"></a>一些题目</h2><blockquote><p>（13）广义表 A=(a,b,(c,d),(e,(f,g)))，则 Head(Tail(Head(Tail(Tail(A)))))的值为（  ）。<br>A．(g)            B．(d)             C．c            D．d</p></blockquote><p>答案：D<br>解释：Tail(A)=(b,(c,d),(e,(f,g)))；Tail(Tail(A))=( (c,d),(e,(f,g)))； Head(Tail(Tail(A)))= (c,d)；Tail(Head(Tail(Tail(A))))=(d)；Head(Tail(Head(Tail(Tail(A)))))=d。</p><blockquote><p>（14）广义表((a,b,c,d))的表头是（  ），表尾是（  ）。<br>A．a              B．( )             C．(a,b,c,d)      D．(b,c,d)</p></blockquote><p>答案：C、B<br>解释：表头为非空广义表的第一个元素，可以是一个单原子，也可以是一个子表，((a,b,c,d))的表头为一个子表(a,b,c,d)；表尾为除去表头之外，由其余元素构成的表，表为一定是个广义表，((a,b,c,d))的表尾为空表( )。</p><blockquote><p>（15）设广义表 L=((a,b,c))，则 L 的长度和深度分别为（  ）。<br>A．1 和 1          B．1 和 3          C．1 和 2          D．2 和 3</p></blockquote><p>答案：C<br>解释：广义表的深度是指广义表中展开后所含括号的层数，广义表的长度是指广义表中所含元素的个数。根据定义易知 L 的长度为 1，深度为 2。</p>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 📶线结构：字符串-数组-栈-队列 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>周围的喧嚣</title>
      <link href="/essay/nqm77s/"/>
      <url>/essay/nqm77s/</url>
      
        <content type="html"><![CDATA[<p>现在的文章，喧嚣</p><p>动不动一篇文章出来个广告</p><p>目的性太强</p><p>为了写而写，就像是，文字什么时候变得这么苍白</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>npm- ERR! Unexpected end of JSON input while parsing</title>
      <link href="/blog/gcwu9h/"/>
      <url>/blog/gcwu9h/</url>
      
        <content type="html"><![CDATA[<h2 id="报错信息"><a href="#报错信息" class="headerlink" title="报错信息"></a>报错信息</h2><pre><code class="bash">npm WARN deprecated circular-json@0.5.9: CircularJSON is in maintenance only, flatted is its successor.npm ERR! Unexpected end of JSON input while parsing near &#39;...:&quot;~0.0.0&quot;,&quot;webpack-de&#39;npm ERR! A complete log of this run can be found in:npm ERR! C:\文件路径\npm-cache_logs\2018-12-13T10_24_02_151Z-debug.logPackage install failed, see above.</code></pre><p>（具体的报错信息和这个类似）<br>升级 hexo5.0 过程中，npm i –save 出错，各种插件都不能很好的下载。</p><h2 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h2><p>在 node 安装目录下配置的 node_cache 目录里面 <code>D:\Develop\nodejs</code> <br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1603808754530-64316710-95b9-4e13-98dd-efda5197f782.png#align=left&display=inline&height=167&margin=%5Bobject%20Object%5D&name=image.png&originHeight=487&originWidth=1128&size=62358&status=done&style=shadow&width=387" alt="image.png"><br>系统盘的 AppData/roaming 的文件夹并没有一个 npm 的缓存目录，安装 node 的时候将<code>D:\Develop\nodejs</code> 放到系统环境变量的 Path 路径了。</p><p>所以只需要一下两条命令即可</p><pre><code class="bash">npm cache clean --forcenpm install</code></pre><p>**</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://stackoverflow.com/questions/53759929/npm-err-unexpected-end-of-json-input-while-parsing">stackoverflow-npm ERR! Unexpected end of JSON input while parsing</a></li><li><a href="https://www.ruanyifeng.com/blog/2016/01/npm-install.html">阮一峰-npm 模块安装机制简介</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> ✨其他 </category>
          
          <category> Bug </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>《许三观卖血记》</title>
      <link href="/essay/ghwn6o/"/>
      <url>/essay/ghwn6o/</url>
      
        <content type="html"><![CDATA[<p>===有一个场景我记得很清楚，当许玉兰被批斗的时候，许三观送饭，在饭下面藏着几块肉，那样的场景，温情脉脉<br>还有在家里的时候，玉兰说出自己曾经的种种不堪的事情的时候，许三观为了在几个儿子面前维护玉兰，也同等说出自己的许多不堪的事<br>我觉得，这种关系，才像是一起经历过苦难的夫妻作为，那个家庭场景，老实说，我感到很有温度</p><p>===小说最后，让我有点痛心的就是三个儿子对许三观说出的一番话。<br>子女永远不知道自己父母付出的有多少<br>好在身边一直有的是玉兰。</p><p>===突然又想到《活着》，突然又想到富贵的人生似乎更为惨淡，一生下来，经历种种苦楚，最后的人生和一头老牛在田野远远望去<br>家珍，还有一个女儿，一个儿子…说实话，他们的结局，也是挺悲惨的……</p>]]></content>
      
      
      <categories>
          
          <category> 阅读 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CPP-LINK : fatal error LNK1561: 必须定义入口点</title>
      <link href="/blog/oyvpk4/"/>
      <url>/blog/oyvpk4/</url>
      
        <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><pre><code class="cpp">LINK : fatal error LNK1561: 必须定义入口点</code></pre><h2 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h2><p>每个应用程序(文件格式为 exe)都应该有个启动点，这个点就是 main 函数。缺少就会出现 link error 。</p><p>解决方法</p><ol><li>添加含有 main 函数的 CPP 文件</li><li>右击属性，在常规项中修改配置类型，将应用程序修改为库，动静态库</li></ol>]]></content>
      
      
      <categories>
          
          <category> ✨其他 </category>
          
          <category> Bug </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++随机字符串生成函数</title>
      <link href="/blog/zeszpb/"/>
      <url>/blog/zeszpb/</url>
      
        <content type="html"><![CDATA[<pre><code class="cpp">//C++ 随机字符串生成函数#include&lt;iostream&gt;#include&lt;ctime&gt;using namespace std;const int LEN_NAME=4;char *rand_str(char *str,const int len)&#123;    int i;    for(i=0;i&lt;len;++i)        str[i]=&#39;A&#39;+rand()%26;    str[++i]=&#39;\0&#39;;    return str;&#125;void main()&#123;    srand(time(NULL));    int i;    char name[LEN_NAME+1];    for(i=0;i&lt;20;++i)    &#123;        cout&lt;&lt;rand_str(name,LEN_NAME)&lt;&lt;endl;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 非前端编程语言 </category>
          
          <category> CPlusPlus </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>分治算法+归并排序</title>
      <link href="/blog/ab9fkt/"/>
      <url>/blog/ab9fkt/</url>
      
        <content type="html"><![CDATA[<h2 id="分治算法"><a href="#分治算法" class="headerlink" title="分治算法"></a>分治算法</h2><p>此前学习的<strong>递归设计方法</strong>，是针对规模大的问题拆成规模小的问题，并且规模大的问题和规模小的问题的解决办法相同。</p><p>分治算法与递归设计方法的不同之处就是，该规模较大的问题分解为多个不重叠的子问题，并将其称为<strong>“分而治之”</strong><br>**<br>分治的三个步骤：</p><ol><li>分解：将原问题分解为若干个规模较小、相互不重叠与原问题形式相同的子问题</li><li>解决：<ol><li>若子问题规模较小且易于解决时候直接解出</li><li>否则递归地解决各个子问题</li></ol></li><li>合并：将各个子问题的解个并未原问题的解</li></ol><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h3><ul><li>分解：将排序数组分解为左右两个相等的不重叠的数组</li><li>解决：递归</li><li>合并：将两个已经有序的数组合并为一个有序的数组</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1603617542157-07613fda-ebed-4924-bf6a-091c19b12fc7.png#align=left&display=inline&height=431&margin=%5Bobject%20Object%5D&name=image.png&originHeight=861&originWidth=895&size=74826&status=done&style=shadow&width=447.5" alt="image.png"></p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 分治算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>IDEA-控制台输出中文乱码问题</title>
      <link href="/blog/lkgrkx/"/>
      <url>/blog/lkgrkx/</url>
      
        <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>在 java 实现 ping/tracert 两个命令时候，输出到控制台里面中文乱码。</p><h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>应该是调用了终端，而 windows 的终端默认是 GBK 的编码，所以要对其更改管用的 utf-8 编码，改为 GBK 编码。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1603613519544-dc851d0f-e0c0-4a0a-9a2d-0043285b3db0.png#align=left&display=inline&height=441&margin=%5Bobject%20Object%5D&name=image.png&originHeight=881&originWidth=706&size=74813&status=done&style=shadow&width=353" alt="image.png"></p><h2 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h2><h3 id="编码更改"><a href="#编码更改" class="headerlink" title="编码更改"></a>编码更改</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1603613302488-7bd6d045-81c3-470c-a57c-05a020588fcd.png#align=left&display=inline&height=511&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1022&originWidth=1449&size=141645&status=done&style=shadow&width=724.5" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1603613687953-21f1bbc9-b0bc-4db4-a935-3fcf6275909f.png#align=left&display=inline&height=185&margin=%5Bobject%20Object%5D&name=image.png&originHeight=369&originWidth=1920&size=135691&status=done&style=shadow&width=960" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1603613719305-ac9dc39b-2c6a-4350-9f31-49d48dbedfe5.png#align=left&display=inline&height=110&margin=%5Bobject%20Object%5D&name=image.png&originHeight=220&originWidth=764&size=24151&status=done&style=none&width=382" alt="image.png"></p><ul><li><code>Reload</code> 表示使用新编码重新加载，新编码不会保存到文件中</li><li><code>Convert</code> 表示使用新编码进行转换，新编码会保存到文件中</li><li>含有中文的代码文件，<code>Convert</code> 之后可能会使中文变成乱码，所以在转换成请做好备份，不然可能出现转换过程变成乱码，无法还原</li></ul><h3 id="BOM-问题"><a href="#BOM-问题" class="headerlink" title="BOM 问题"></a>BOM 问题</h3><blockquote><p>BOM：byte-order mark 字节顺序标记<br><a href="https://zh.wikipedia.org/wiki/%E4%BD%8D%E5%85%83%E7%B5%84%E9%A0%86%E5%BA%8F%E8%A8%98%E8%99%9F">https://zh.wikipedia.org/wiki/%E4%BD%8D%E5%85%83%E7%B5%84%E9%A0%86%E5%BA%8F%E8%A8%98%E8%99%9F</a></p></blockquote><p>可能会出现的问题有：</p><blockquote><p>编译报错：<code>找不到符号</code>、<code>未结束的字符串文字</code> 或者是 提示 <code>非法字符</code></p></blockquote><p>解决办法：有上述百科可知，UTF-8 编码分有 BOM 和无 BOM 两种分类。IDEA 打开 Eclipse 项目，会提示出现上述编译问题，因为<strong>Eclipse 默认是有 BOM 的文件编译</strong>，而<strong>IDEA 只能编译无 BOM 的文件编译</strong>，所以解决办法就是对项目进行<strong>BOM 去除</strong>操作。</p>]]></content>
      
      
      <categories>
          
          <category> ✨其他 </category>
          
          <category> Bug </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>莱文斯坦距离(LD)问题</title>
      <link href="/blog/bvk4ok/"/>
      <url>/blog/bvk4ok/</url>
      
        <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p><strong>Levenshtein Distance</strong>也称<strong>莱文斯坦距离</strong></p><p>具体形式就是求一个字符串到另一个字符串所需要的<strong>最少操作步数</strong>，操作形式有：</p><ul><li>替换字母</li><li>删除字母</li><li>插入字母</li></ul><h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>利用动态规划思想，将其剖析为一个个子问题，用其子问题的解决方式来解决该问题。问题分解出来的子问题存在重叠的情况，这是区分分治算法的不同。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1603615056984-36cbce7c-c55e-456a-bb90-eb18471167e0.png#crop=0&crop=0&crop=1&crop=1&height=335&id=qpRoD&margin=%5Bobject%20Object%5D&name=image.png&originHeight=670&originWidth=1026&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=202356&status=done&style=shadow&title=&width=513" alt="image.png"></p><p><strong>莱文斯坦的公式化</strong>表述为：<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1603614727015-dad259b0-7904-4e5d-9ec8-f4ac284af2e5.png#crop=0&crop=0&crop=1&crop=1&height=94&id=OLKIR&margin=%5Bobject%20Object%5D&name=image.png&originHeight=188&originWidth=874&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=23400&status=done&style=shadow&title=&width=437" alt="image.png"></p><p>下面利用表格的形式来步步推出该字母所需要达到相应的目标字母序列的步数。</p><p>| |<br>| s | o | n |<br>| — | — | — | — | — |<br>|<br>| 0 | 1 | 2 | 3 |<br>| s | 1 | 0 | 1 | 2 |<br>| u | 2 | 1 | 1 | 2 |<br>| n | 3 | 2 | 2 | 1 |</p><p>记横（son）为 i 字符串序列，纵（sun）为 j 字符串序列。需要完成的字符串变换为 i-&gt;j。现举例格子数值该怎么填：</p><p>当到了第三行第三列的那一格，需要完成 s-&gt;s，有三种情况可以选择</p><ol><li>左操作(i-1,j)：删除 s 字符然后插入 s 字符===操作步数两步</li><li>上操作(i,j-1)：插入 s 字符然后删除 s 字符===操作步数两步</li><li>左上操作(i-1,j-1)：替换步骤，因为这个元素相同，故===操作步数零部</li></ol><p>然后选取上述三种情况最短步数的数值 0</p><p>然后再看第三行第四列，需要完成 so-&gt;s，</p><ol><li>左操作：删除 o===一步</li><li>上操作：插入 s 删除 so===三步</li><li>做上操作：替换 s 删除 o===两步</li></ol><p>综上应该填 1</p><p>其他格子也一样以上述方法填写。</p><p>有个作业遗留问题，在 CAAIS 里面每个得出的值右上标的 <code>U</code>  <code>L</code>  <code>0</code>  <code>1</code>  这些的依次顺序是怎么个顺序？<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1603615446981-23bea432-08ee-490a-9037-018ba6280c3b.png#crop=0&crop=0&crop=1&crop=1&height=201&id=C4QpM&margin=%5Bobject%20Object%5D&name=image.png&originHeight=401&originWidth=651&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=49834&status=done&style=shadow&title=&width=325.5" alt="image.png"></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><pre><code class="cpp">#include &lt;string&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;ctime&gt;const int LEN_NAME=100;namespace NS_LSEditDist &#123;    using namespace std;    void Initialization(const string &amp;x, const string &amp;y);    int GetLSEditDist(const string &amp;x, const string &amp;y);    void GetLSEdits(const string &amp;x, const string &amp;y);    void Output(const string &amp;x, const string &amp;y, int OptD);    void OutputE(const string &amp;x, const string &amp;y);    void OutputP(const string &amp;x, const string &amp;y);    static int m, n;    static vector&lt;vector&lt;int&gt;&gt; E;    static vector&lt;vector&lt;char&gt;&gt; P;    static string xe, ye;    void LSEditDistCaller(const string &amp;x, const string &amp;y)    &#123;        Initialization(x, y);        int OptD = GetLSEditDist(x, y);        GetLSEdits(x, y);        Output(x, y, OptD);    &#125;    int GetLSEditDist(const string &amp;x, const string &amp;y)    &#123;        for (int i = 1; i &lt;= m; i++)            for (int j = 1; j &lt;= n; j++)            &#123;                E[i][j] = min(E[i - 1][j] + 1,                              min(E[i][j - 1] + 1,                                  E[i - 1][j - 1] + (x[i - 1] != y[j - 1])));                if (E[i][j] == E[i - 1][j] + 1)                    P[i][j] = &#39;U&#39;;                else if (E[i][j] == E[i][j - 1] + 1)                    P[i][j] = &#39;L&#39;;                else if (x[i - 1] != y[j - 1])                    P[i][j] = &#39;1&#39;;            &#125;        return E[m][n];    &#125;    void GetLSEdits(const string &amp;x, const string &amp;y)    &#123;        int i = m, j = n;        while (i &gt; 0 || j &gt; 0)        &#123;            if (P[i][j] == &#39;0&#39; || P[i][j] == &#39;1&#39;)            &#123;                xe.insert(0, 1, x[i - 1]);                ye.insert(0, 1, y[j - 1]);                i--; j--;            &#125;            else if (P[i][j] == &#39;U&#39;)            &#123;                xe.insert(xe.begin(), x[i - 1]);                ye.insert(ye.begin(), &#39;-&#39;);                i--;            &#125;            else            &#123;                xe.insert(xe.begin(), &#39;-&#39;);                ye.insert(ye.begin(), y[j - 1]);                j--;            &#125;        &#125;    &#125;    void Initialization(const string &amp;x, const string &amp;y)    &#123;        m = x.length();        n = y.length();        E.clear();        E.resize(m + 1, vector&lt;int&gt;(n + 1, 0));        P.clear();        P.resize(m + 1, vector&lt;char&gt;(n + 1, &#39;0&#39;));        for (int j = 1; j &lt;= n; j++)        &#123;            E[0][j] = j;            P[0][j] = &#39;L&#39;;        &#125;        for (int i = 1; i &lt;= m; i++)        &#123;            E[i][0] = i;            P[i][0] = &#39;U&#39;;        &#125;        xe.clear();        ye.clear();    &#125;    void Output(const string &amp;x, const string &amp;y, int OptD)    &#123;        printf(&quot;Levenshtein distance: \n&quot;);        printf(&quot;Strings: %s, %s\n\n&quot;, x.c_str(), y.c_str());        OutputE(x, y);        OutputP(x, y);        printf(&quot;Distance: %d\n&quot;, OptD);        printf(&quot;Edited strings:\n&quot;);        for (auto c : xe)            printf(&quot;%2c&quot;, c);        printf(&quot;\n&quot;);        for (auto c : ye)            printf(&quot;%2c&quot;, c);        printf(&quot;\n\n&quot;);    &#125;    void OutputE(const string &amp;x, const string &amp;y)    &#123;        printf(&quot; E  &quot;);        for (int j = 0; j &lt; n; j++)            printf(&quot;%2c&quot;, y[j]);        printf(&quot;\n&quot;);        for (int i = 0; i &lt;= m; i++)        &#123;            if (i == 0)                printf(&quot;  &quot;);            else                printf(&quot;%2c&quot;, x[i - 1]);            for (int j = 0; j &lt;= n; j++)            &#123;                printf(&quot;%2d&quot;, E[i][j]);            &#125;            printf(&quot;\n&quot;);        &#125;        printf(&quot;\n&quot;);    &#125;    void OutputP(const string &amp;x, const string &amp;y)    &#123;        printf(&quot; P  &quot;);        for (int j = 0; j &lt; n; j++)            printf(&quot;%2c&quot;, y[j]);        printf(&quot;\n&quot;);        for (int i = 0; i &lt;= m; i++)        &#123;            if (i == 0)                printf(&quot;  &quot;);            else                printf(&quot;%2c&quot;, x[i - 1]);            for (int j = 0; j &lt;= n; j++)            &#123;                printf(&quot;%2c&quot;, P[i][j]);            &#125;            printf(&quot;\n&quot;);        &#125;        printf(&quot;\n&quot;);    &#125;&#125; //namespace NS_LSEditDistchar *rand_str(char *str,const int len)&#123;    int i;    for(i=0;i&lt;len;++i)        str[i]=&#39;a&#39;+rand()%26;    str[++i]=&#39;\0&#39;;    return str;&#125;using namespace NS_LSEditDist;int main()&#123;    vector&lt;vector&lt;string&gt;&gt; abs = &#123;            &#123; &quot;water&quot;, &quot;wheat&quot; &#125;,            &#123; &quot;servant&quot;, &quot;reveal&quot; &#125;    &#125;;    for (auto ab : abs)    &#123;        string a = ab[0];        string b = ab[1];        LSEditDistCaller(a, b);    &#125;    cout&lt;&lt;&quot;两个100位字符串的LevenShtein距离：&quot;&lt;&lt;endl;    srand(time(NULL));    int i;    char name[LEN_NAME+1];    string x = rand_str(name,LEN_NAME);    string y = rand_str(name,LEN_NAME);    cout&lt;&lt;&quot;字符串1：&quot;&lt;&lt;x&lt;&lt;endl;    cout&lt;&lt;&quot;字符串2：&quot;&lt;&lt;y&lt;&lt;endl;    LSEditDistCaller(x, y);&#125;</code></pre><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://zh.wikipedia.org/wiki/%E8%90%8A%E6%96%87%E6%96%AF%E5%9D%A6%E8%B7%9D%E9%9B%A2">莱文斯坦距离</a></li><li><a href="https://www.dazhuanlan.com/2019/12/06/5dea0cb03281f/">理解 Levenshtein Distancee</a></li><li><a href="https://www.throwable.club/2020/03/08/learn-about-levenshtein-distance-algorithm/">Levenshtein Distance（编辑距离）算法与使用场景</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 🔢动态规划算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>利用WireShark捕获并分析以太网报文结构</title>
      <link href="/blog/bw80k6/"/>
      <url>/blog/bw80k6/</url>
      
        <content type="html"><![CDATA[<blockquote><p>学习网络协议分析工具 WireShark，利用 WireShark 捕获并分析以太网报文结构，最重要的是后面超星网登录案例分析，用实际例子将计网的所学知识串起来。</p></blockquote><blockquote><p>文章更新内容说明：无线上网和有线上网的 MAC 地址是不一样的<br>【查看本地地址的截图是在家里的查看，wireshark 的使用是在学校】</p></blockquote><h2 id="查看信息"><a href="#查看信息" class="headerlink" title="查看信息"></a>查看信息</h2><h3 id="查看本地的-mac-地址"><a href="#查看本地的-mac-地址" class="headerlink" title="查看本地的 mac 地址"></a>查看本地的 mac 地址</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612839562082-cbc1fcf8-a520-4820-bafc-e26f07ba1177.png#align=left&display=inline&height=248&margin=%5Bobject%20Object%5D&name=image.png&originHeight=496&originWidth=1920&size=78833&status=done&style=shadow&width=960" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612839610832-5568023d-da16-41af-b95e-1787acadf747.png#align=left&display=inline&height=402&margin=%5Bobject%20Object%5D&name=image.png&originHeight=804&originWidth=1335&size=109239&status=done&style=shadow&width=667.5" alt="image.png"></p><h3 id="ping-命令"><a href="#ping-命令" class="headerlink" title="ping 命令"></a>ping 命令</h3><blockquote><p>先使用 ping 命令找到需要抓包的网站的 ip 地址</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612845955475-12f08386-5ec4-4b3f-8cbf-56059d79677c.png#align=left&display=inline&height=162&margin=%5Bobject%20Object%5D&name=image.png&originHeight=323&originWidth=828&size=51064&status=done&style=shadow&width=414" alt="image.png"></p><h2 id="WireShark-使用"><a href="#WireShark-使用" class="headerlink" title="WireShark 使用"></a>WireShark 使用</h2><h3 id="WireShark-使用及面板功能区域"><a href="#WireShark-使用及面板功能区域" class="headerlink" title="WireShark 使用及面板功能区域"></a>WireShark 使用及面板功能区域</h3><p>进入软件，若成功适配电脑网卡，则出现如下类似接口列表<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1603434019601-cc879af3-8784-4ada-83dc-642d64e02981.png#align=left&display=inline&height=329&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1038&originWidth=1920&size=115692&status=done&style=shadow&width=608" alt="image.png"><br>直接双击上图中 WLAN 行即可抓包，也可以如下设置网卡启动抓包<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1603434096441-73c67d75-4e36-4e76-ae3c-0a8b8976da28.png#align=left&display=inline&height=301&margin=%5Bobject%20Object%5D&name=image.png&originHeight=911&originWidth=1920&size=114148&status=done&style=shadow&width=634" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1603431676018-f4988b52-5aef-4d92-8b9b-15109a08adab.png#align=left&display=inline&height=345&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1033&originWidth=1920&size=207427&status=done&style=shadow&width=641" alt="image.png"></p><h3 id="1-区域-显示过滤器"><a href="#1-区域-显示过滤器" class="headerlink" title="1 区域-显示过滤器"></a>1 区域-显示过滤器</h3><blockquote><p>为过滤 ip 地址区域。相关表达式语法有</p></blockquote><ol><li>协议过滤。比如 TCP，只显示 TCP 协议。</li><li>IP 过滤。比如 ip.src == 192.168.1.102,显示源地址为 192.168.1.102，</li></ol><p>ip.dst == 192.168.1.102, 目标地址为 192.168.1.102。</p><ol start="3"><li>端口过滤。   tcp.port ==80,   端口为 80 的</li></ol><p>tcp.srcport == 80,只显示 TCP 协议的愿端口为 80 的。</p><ol start="4"><li>Http 模式过滤。http.request.method==”GET”,   只显示 HTTP GET 方法的。</li><li>逻辑运算符为 AND/ OR</li></ol><h3 id="2-区域-获取的数据包"><a href="#2-区域-获取的数据包" class="headerlink" title="2 区域-获取的数据包"></a>2 区域-获取的数据包</h3><blockquote><p>封包列表(Packet List Pane)</p></blockquote><h3 id="3-区域-单个数据包各层详细内容"><a href="#3-区域-单个数据包各层详细内容" class="headerlink" title="3 区域-单个数据包各层详细内容"></a>3 区域-单个数据包各层详细内容</h3><blockquote><p>选定的封包详细信息 (Packet Details Pane)</p></blockquote><ol><li>Frame:物理层的数据帧概况。</li></ol><pre><code class="http">Frame 165: 74 bytes on wire (592 bits), 74 bytes captured (592 bits) on interface \Device\NPF_&#123;B016AB5D-3088-41BD-8997-48F19D9DEBFA&#125;, id 0 //165号帧，对方发送74字节，实际收到74字节    Interface id: 0 (\Device\NPF_&#123;B016AB5D-3088-41BD-8997-48F19D9DEBFA&#125;) //接口id为0        Interface name: \Device\NPF_&#123;B016AB5D-3088-41BD-8997-48F19D9DEBFA&#125;        Interface description: WLAN    Encapsulation type: Ethernet (1) //封装类型    Arrival Time: Oct 23, 2020 13:37:43.372763000 中国标准时间//捕获日期和时间（中国标准时间）    [Time shift for this packet: 0.000000000 seconds]    Epoch Time: 1603431463.372763000 seconds    [Time delta from previous captured frame: 0.008472000 seconds]//与前一包时间间隔    [Time delta from previous displayed frame: 0.000000000 seconds]    [Time since reference or first frame: 36.349570000 seconds]//此包与第一帧的时间间隔    Frame Number: 165//帧序号    Frame Length: 74 bytes (592 bits)//帧长度    Capture Length: 74 bytes (592 bits)//捕获字节长度    [Frame is marked: False]//是否做了标记    [Frame is ignored: False]//是否被忽略    [Protocols in frame: eth:ethertype:ip:icmp:data]//帧内封装的协议层次结构    [Coloring Rule Name: ICMP]//着色标记的协议名称    [Coloring Rule String: icmp || icmpv6]//着色规则显示的字符串</code></pre><ol start="2"><li>Ethernet II:数据链路层以太网帧头部信息。</li></ol><pre><code class="http">Ethernet II, Src: IntelCor_fb:33:94 (0c:54:15:fb:33:94), Dst: HuaweiTe_da:ff:f3 (7c:a1:77:da:ff:f3)    Destination: HuaweiTe_da:ff:f3 (7c:a1:77:da:ff:f3)//目的MAC地址    Source: IntelCor_fb:33:94 (0c:54:15:fb:33:94)//源MAC地址（就是我电脑的MAC地址）    Type: IPv4 (0x0800)//0x0800表示使用IP协议</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1603432754493-20843464-3bbb-4c01-9ceb-e781759a583d.png#align=left&display=inline&height=280&margin=%5Bobject%20Object%5D&name=image.png&originHeight=559&originWidth=1920&size=110051&status=done&style=shadow&width=960" alt="image.png"></p><ol start="3"><li>Internet Protocol Version 4:互联网层 IP 包头部信息。</li></ol><pre><code class="http">Internet Protocol Version 4, Src: 192.168.43.36, Dst: 39.156.66.18    0100 .... = Version: 4//互联网协议IPv4    .... 0101 = Header Length: 20 bytes (5)//IP包头部长度    Differentiated Services Field: 0x00 (DSCP: CS0, ECN: Not-ECT)//差分服务字段    Total Length: 60//IP包的总长度    Identification: 0xdf8c (57228)//标志字段    Flags: 0x0000//标记字段    Fragment offset: 0//分的偏移量    Time to live: 128//生存期TTL    Protocol: ICMP (1)//此包内封装的上层协议为TCP    Header checksum: 0x05ba [validation disabled]//头部数据的校验和    [Header checksum status: Unverified]    Source: 192.168.43.36//来源IP地址    Destination: 39.156.66.18//目标IP地址</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1603433033837-c88714a1-eaa1-45cb-b836-5672e4515eee.png#align=left&display=inline&height=189&margin=%5Bobject%20Object%5D&name=image.png&originHeight=378&originWidth=640&size=84901&status=done&style=shadow&width=320" alt="image.png"></p><ol start="4"><li>Transmission Control Protocol:传输层 T 的数据段头部信息，此处是 TCP。</li></ol><pre><code class="http">Transmission Control Protocol, Src Port: 80 (80), Dst Port: 50362 (50362), Seq: 1025, Ack: 447, Len: 714Source Port: 80 (80) //源端口号Destination Port: 50362 (50362) //目标端口号Sequence number: 1025 (relative sequence number) //序列号（相对序列号）[Next sequence number: 1739 (relative sequence number)] //下一个序列号Acknowledgment number: 447    (relative ack number) //确认序列号Header Length: 20 bytes  //头部长度.... 0000 0001 1000 = Flags: 0x018 (PSH, ACK) //TCP标记长度Window size value: 5896  //流量控制的窗口大小Checksum: 0x915b [validation disabled] //TCP数据段的校验和</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1603433149527-0125377e-b64b-4e32-9eb0-e122d0c111cb.png#align=left&display=inline&height=190&margin=%5Bobject%20Object%5D&name=image.png&originHeight=379&originWidth=579&size=89043&status=done&style=shadow&width=289.5" alt="image.png"></p><ol start="5"><li><p>Hypertext Transfer Protocol:应用层的信息，此处是 HTTP 协议。</p></li><li><p>Data（312 bytes）：数据。</p></li></ol><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1603434354567-45e84cc7-63a9-4136-adde-85c377345e92.png#align=left&display=inline&height=147&margin=%5Bobject%20Object%5D&name=image.png&originHeight=347&originWidth=1920&size=49744&status=done&style=shadow&width=813" alt="image.png"></p><h2 id="超星网登录案例分析"><a href="#超星网登录案例分析" class="headerlink" title="超星网登录案例分析"></a>超星网登录案例分析</h2><h3 id="网站请求和响应"><a href="#网站请求和响应" class="headerlink" title="网站请求和响应"></a>网站请求和响应</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612849248230-2f38b355-ee1f-4ee1-8b8a-291e64f4e1bd.png#align=left&display=inline&height=356&margin=%5Bobject%20Object%5D&name=image.png&originHeight=711&originWidth=1920&size=230540&status=done&style=none&width=960" alt="image.png"></p><h3 id="发送请求相应协议"><a href="#发送请求相应协议" class="headerlink" title="发送请求相应协议"></a>发送请求相应协议</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612849740094-cbdefdda-f504-43f3-9e41-ac8dc8029fd3.png#align=left&display=inline&height=440&margin=%5Bobject%20Object%5D&name=image.png&originHeight=880&originWidth=1920&size=208371&status=done&style=none&width=960" alt="image.png"></p><h3 id="收到响应相应协议"><a href="#收到响应相应协议" class="headerlink" title="收到响应相应协议"></a>收到响应相应协议</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612849811431-437bd72d-ac54-4c28-b731-9e128b6b998f.png#align=left&display=inline&height=441&margin=%5Bobject%20Object%5D&name=image.png&originHeight=881&originWidth=1918&size=151717&status=done&style=stroke&width=959" alt="image.png"></p><blockquote><p>接下来的 7 个小节内容来具体对数据报头做出分析 ❗</p></blockquote><h3 id="Hypertext-Transfer-Protocol"><a href="#Hypertext-Transfer-Protocol" class="headerlink" title="Hypertext Transfer Protocol"></a>Hypertext Transfer Protocol</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612849851243-b18b3e15-f21e-4998-bcfe-45c0b92aabde.png#align=left&display=inline&height=339&margin=%5Bobject%20Object%5D&name=image.png&originHeight=678&originWidth=1920&size=99636&status=done&style=shadow&width=960" alt="image.png"></p><blockquote><p>HTTP 协议定义了客户端和服务器之间交互的消息内容和步骤，大家按照固定的步骤和格式进行通信<br>根据 URL 可以定位请求资源的位置，但是对于这个资源可能还有多种处理方法，比如是请求资源还是要删除指定资源？</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612851558692-ed870a9e-f619-4235-bb98-85d22557340f.png#align=left&display=inline&height=493&margin=%5Bobject%20Object%5D&name=image.png&originHeight=985&originWidth=1920&size=489577&status=done&style=none&width=960" alt="image.png"><br>这个时候<strong>浏览器</strong>将需要请求的信息，按照 HTTP 协议约定的格式，封装成为 HTTP 请求报文<br>HTTP 主要请求方法为 GET 和 POST<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612851687862-c1a44f57-065b-4547-93bb-4ae9b1f9cb95.png#align=left&display=inline&height=190&margin=%5Bobject%20Object%5D&name=image.png&originHeight=379&originWidth=693&size=117900&status=done&style=shadow&width=346.5" alt="image.png"></p><blockquote><p>请求报文和响应报文的具体形式参考课本</p></blockquote><h3 id="Line-based-text-data"><a href="#Line-based-text-data" class="headerlink" title="Line-based text data"></a>Line-based text data</h3><p>这里面内容就是请求成功所返回的 Html 代码<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612851995920-233bc149-948d-43e1-a549-fc2887c23163.png#align=left&display=inline&height=353&margin=%5Bobject%20Object%5D&name=image.png&originHeight=706&originWidth=1920&size=159705&status=done&style=none&width=960" alt="image.png"></p><h3 id="Transmission-Control-Protocol"><a href="#Transmission-Control-Protocol" class="headerlink" title="Transmission Control Protocol"></a>Transmission Control Protocol</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612852359910-50409417-8113-4600-bbb6-6d0e02db4894.png#align=left&display=inline&height=356&margin=%5Bobject%20Object%5D&name=image.png&originHeight=712&originWidth=1920&size=104306&status=done&style=none&width=960" alt="image.png"><br>这个数据报传输使用的可靠的 TCP 协议，而不是 UDP，所以会有相应的滑动窗口、流量控制等等相关机制，还有三次握手，四次挥手……<br>（插个眼，日后再复习一下……）<br><img src="https://cdn.nlark.com/yuque/0/2021/gif/1484158/1612852762215-ba49fa51-55e0-440d-afa7-b567540e39a2.gif#align=left&display=inline&height=151&margin=%5Bobject%20Object%5D&name=huaji-779c5947261d2633.gif&originHeight=151&originWidth=218&size=163714&status=done&style=none&width=218" alt="huaji-779c5947261d2633.gif"><br>（插眼专用图/滑稽）</p><h3 id="Internet-Protocol-Version-4"><a href="#Internet-Protocol-Version-4" class="headerlink" title="Internet Protocol Version 4"></a>Internet Protocol Version 4</h3><p>好了，接下来到了 IP 层，需要给上面来的数据报加上 IP 头部，IP 数据报结构如下：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612853140617-ff243167-abb7-4c65-b5c3-b0bbaa77b5aa.png#align=left&display=inline&height=237&margin=%5Bobject%20Object%5D&name=image.png&originHeight=474&originWidth=892&size=244750&status=done&style=stroke&width=446" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612853444183-7fa048ef-3e75-4586-82a7-ac9cc58c3630.png#align=left&display=inline&height=203&margin=%5Bobject%20Object%5D&name=image.png&originHeight=405&originWidth=1920&size=105587&status=done&style=stroke&width=960" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612852425531-82ec984f-ac3b-4f8a-a06e-0c48080815f6.png#align=left&display=inline&height=353&margin=%5Bobject%20Object%5D&name=image.png&originHeight=706&originWidth=1920&size=107520&status=done&style=none&width=960" alt="image.png"><br>比如说<code>45 </code>这个字节这具体表现是 ip 数据报的第一行和第二行的具体信息，IP 版本为 IPv4，报头长度为二十个字节，往后的各个字段都是这样一一对应的关系，具体还要加强对那张 ip 数据报结构图的理解，要了然于胸。</p><h3 id="Ethernet-II-Src"><a href="#Ethernet-II-Src" class="headerlink" title="Ethernet II, Src"></a>Ethernet II, Src</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612853924295-ea6fe64c-bc90-4e49-ad4e-5ff212448fdc.png#align=left&display=inline&height=214&margin=%5Bobject%20Object%5D&name=image.png&originHeight=428&originWidth=904&size=226429&status=done&style=stroke&width=452" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612850191706-18807d7d-16b5-44fa-a436-5c2b7c4ed5ed.png#align=left&display=inline&height=321&margin=%5Bobject%20Object%5D&name=image.png&originHeight=641&originWidth=1920&size=151109&status=done&style=none&width=960" alt="image.png"></p><blockquote><p>图中三个方框的 14 个字节对应以太网 MAC 帧的前 14 个字节：前 6 个字节是目的地址，接下来的 6 个字节是源地址，最后两个字节是类型字段(用来标志上一层使用的是什么协议，以便把收到的 MAC 帧的数据交给上一层的这个协议。0x8000 代表上层使用的是 IP 数据报)，后面是数据部分。<br>另外：wireshark 把 8 字节的前序（前同步码）和 4 字节的 FCS（帧开始界定符）都给过滤掉了，所以捕获到的帧里看不到这两部分。</p></blockquote><h3 id="Frame-75"><a href="#Frame-75" class="headerlink" title="Frame 75"></a>Frame 75</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612852486656-87756b19-ff3d-4833-9af9-d2006a401068.png#align=left&display=inline&height=353&margin=%5Bobject%20Object%5D&name=image.png&originHeight=706&originWidth=1920&size=135359&status=done&style=none&width=960" alt="image.png"></p><ul><li>对方发送 5520 字节，实际收到 5520 字节</li><li>第一行表示接口位 0 号</li></ul><h3 id="总体数据表示"><a href="#总体数据表示" class="headerlink" title="总体数据表示"></a>总体数据表示</h3><p>其实在计算机看来，网络中的数据传输就是传输下面的这些字节</p><blockquote><p>一个字节由八个位组成，而位就是我们通常所说的二进制中的 0 或 1</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612852578885-9519d1d0-a72d-409b-a480-f8554b87fd0d.png#align=left&display=inline&height=299&margin=%5Bobject%20Object%5D&name=image.png&originHeight=598&originWidth=1918&size=138039&status=done&style=stroke&width=959" alt="image.png"></p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><h3 id="Wireshark-抓不到-HTTPS-数据包"><a href="#Wireshark-抓不到-HTTPS-数据包" class="headerlink" title="Wireshark 抓不到 HTTPS 数据包"></a>Wireshark 抓不到 HTTPS 数据包</h3><blockquote><p>有些时候 HTTP 包也抓不到抑或是抓的不全，用如下方式解决即可。</p></blockquote><p>在 C 盘根目录下创建如下目录和文件，.log 就是后缀不要 txt<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612847971131-6c3c2084-c6d8-41ae-8a82-8a4df65748b8.png#align=left&display=inline&height=112&margin=%5Bobject%20Object%5D&name=image.png&originHeight=224&originWidth=811&size=14570&status=done&style=shadow&width=405.5" alt="image.png"><br>添加环境变量<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612848066208-6f22250b-e74d-4156-aa31-c5de17d2e812.png#align=left&display=inline&height=236&margin=%5Bobject%20Object%5D&name=image.png&originHeight=471&originWidth=968&size=35366&status=done&style=none&width=484" alt="image.png"><br>进入 wireshark 软件<br><code>编辑 ``首选项</code> <code>Protocols</code><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612848155164-ace1e002-1971-4910-8d04-cf9c388eb5cd.png#align=left&display=inline&height=496&margin=%5Bobject%20Object%5D&name=image.png&originHeight=992&originWidth=1362&size=89975&status=done&style=none&width=681" alt="image.png"></p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="https://www.cnblogs.com/linyfeng/p/9496126.html">wireshark 抓包新手使用教程</a></li><li><a href="https://zhuanlan.zhihu.com/p/82498482">https://zhuanlan.zhihu.com/p/82498482</a></li><li><a href="https://zhuanlan.zhihu.com/p/264942536">https://zhuanlan.zhihu.com/p/264942536</a></li><li><a href="https://blog.csdn.net/zam183/article/details/103783785">https://blog.csdn.net/zam183/article/details/103783785</a></li><li>TODO: <a href="https://www.cnblogs.com/zhaopei/p/12152139.html#autoid-2-6">Wireshark 抓包，带你快速入门</a></li><li>TODO: <a href="https://www.cnblogs.com/noteless/p/10256470.html#21">网络是如何连接的？网络发展简介（四）</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ping、traceroute命令编程实现</title>
      <link href="/blog/qlrcf6/"/>
      <url>/blog/qlrcf6/</url>
      
        <content type="html"><![CDATA[<h3 id="ping-和-tracert-命令"><a href="#ping-和-tracert-命令" class="headerlink" title="ping 和 tracert 命令"></a>ping 和 tracert 命令</h3><p><strong>ping</strong>命令一般用来测试两台机器或者机器和服务器之间网络是否连通。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1603437323252-a3bf1470-c4ae-450a-b0fd-4d83281aab46.png#align=left&display=inline&height=156&margin=%5Bobject%20Object%5D&name=image.png&originHeight=311&originWidth=1439&size=57273&status=done&style=shadow&width=719.5" alt="image.png"><br><strong>tracert</strong>命令显示数据报到达目标主机途中所经过的路径（路由器），并且显示到达每个节点（路由器）的花费时间，显示的信息比 ping 出来的信息要多，要详细。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1603437358485-aef50645-6ff9-4395-bbae-0bfe22ce3dc1.png#align=left&display=inline&height=269&margin=%5Bobject%20Object%5D&name=image.png&originHeight=538&originWidth=1436&size=63435&status=done&style=shadow&width=718" alt="image.png"></p><h3 id="编程实现"><a href="#编程实现" class="headerlink" title="编程实现"></a>编程实现</h3><h4 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h4><pre><code class="java">import java.net.InetAddress;import java.net.MalformedURLException;import java.net.URL;import java.net.UnknownHostException;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStream;import java.io.InputStreamReader;import java.util.Scanner;public class CommandUtil &#123;    String tracert = &quot;tracert -h 10 &quot;; //模拟tracert命令    String ping = &quot;ping&quot;;//模拟 ping 命令    String routePrint = &quot;route print -4&quot;;//模拟route print命令    public static void main(String args[])&#123;        String input = null;        @SuppressWarnings(&quot;resource&quot;)        Scanner scanner = new Scanner(System.in);        //利用while循环接收输入的命令行参数        while(true)&#123;            System.out.println(&quot;Please input destination server IP address ：\n&quot;);            input = scanner.next();            CommandUtil host = new CommandUtil();            host.tracert = host.tracert + &quot; &quot; + input;            host.ping = host.ping + &quot; &quot; + input;            try &#123;                host.command(host.routePrint);            &#125; catch (IOException exception) &#123;                exception.printStackTrace();            &#125;            try &#123;                host.command(host.tracert) ;            &#125; catch (IOException exception) &#123;                exception.printStackTrace();            &#125;            try &#123;                host.command(host.ping);            &#125; catch (IOException exception) &#123;                exception.printStackTrace();            &#125;            InetAddress ipAddress;            try &#123;                ipAddress = InetAddress.getByName(input);                System.out.println(&quot;IP address : &quot;+ipAddress);            &#125; catch (UnknownHostException exception) &#123;                exception.printStackTrace();            &#125;            URL url;            try &#123;                url = new URL(&quot;http&quot;,input,80,&quot;index.html&quot;);                System.out.println();//输出服务器地址                System.out.println(&quot;Get the Server-Name# : &quot;+url.getHost());                System.out.println();//输出首页文件                System.out.println(&quot;Get the default file# : &quot;+url.getFile());                System.out.println();//输出首页协议和端口                System.out.println(&quot;Get the protocol# : &quot;+url.getProtocol()+&quot; &quot;+url.getPort());                System.out.println();            &#125; catch (MalformedURLException e) &#123;                e.printStackTrace();            &#125;            System.out.println();            try &#123;                System.out.println(&quot;Get serverName &amp; IPAddress：&quot;+InetAddress.getByName(input));            &#125; catch (UnknownHostException e) &#123;                e.printStackTrace();            &#125;            long freeMemory = Runtime.getRuntime().freeMemory();            System.out.println(&quot;Surplus memory of JVM: &quot;+freeMemory+&quot;B&quot;);        &#125;    &#125;    //模拟 tracert 命令    StringBuffer commandResult = null;    private void command(String tracerCommand) throws IOException&#123;        //第一步：创建进程(是接口不必初始化)        //1.通过Runtime类的getRuntime().exec()传入需要运行的命令参数        System.out.println();        System.out.println(InetAddress.getByName(&quot;localhost&quot;)+&quot; is tracking the destination server...&quot;);        Process process = Runtime.getRuntime().exec(tracerCommand);        readResult(process.getInputStream());        process.destroy();    &#125;    //第二步：通过输入流来将命令执行结果输出到控制台    private void readResult(InputStream inputStream) throws IOException&#123;        commandResult = new StringBuffer();  //初始化命令行        String commandInfo = null; //定义用于接收命令行执行结果的字符串        BufferedReader bufferedReader =                new BufferedReader(new InputStreamReader(inputStream));        while ( (commandInfo = bufferedReader.readLine()) != null)  &#123;            System.out.println(commandInfo);        &#125;        bufferedReader.close();    &#125;&#125;</code></pre><h4 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h4><pre><code>D:\Java\jdk1.8.0_181\bin\java.exe &quot;-javaagent:D:\JetBrains\IntelliJ IDEA 2020.1.3\lib\idea_rt.jar=39614:D:\JetBrains\IntelliJ IDEA 2020.1.3\bin&quot; -Dfile.encoding=GBK -classpath D:\Java\jdk1.8.0_181\jre\lib\charsets.jar;D:\Java\jdk1.8.0_181\jre\lib\deploy.jar;D:\Java\jdk1.8.0_181\jre\lib\ext\access-bridge-64.jar;D:\Java\jdk1.8.0_181\jre\lib\ext\cldrdata.jar;D:\Java\jdk1.8.0_181\jre\lib\ext\dnsns.jar;D:\Java\jdk1.8.0_181\jre\lib\ext\jaccess.jar;D:\Java\jdk1.8.0_181\jre\lib\ext\jfxrt.jar;D:\Java\jdk1.8.0_181\jre\lib\ext\localedata.jar;D:\Java\jdk1.8.0_181\jre\lib\ext\nashorn.jar;D:\Java\jdk1.8.0_181\jre\lib\ext\sunec.jar;D:\Java\jdk1.8.0_181\jre\lib\ext\sunjce_provider.jar;D:\Java\jdk1.8.0_181\jre\lib\ext\sunmscapi.jar;D:\Java\jdk1.8.0_181\jre\lib\ext\sunpkcs11.jar;D:\Java\jdk1.8.0_181\jre\lib\ext\zipfs.jar;D:\Java\jdk1.8.0_181\jre\lib\javaws.jar;D:\Java\jdk1.8.0_181\jre\lib\jce.jar;D:\Java\jdk1.8.0_181\jre\lib\jfr.jar;D:\Java\jdk1.8.0_181\jre\lib\jfxswt.jar;D:\Java\jdk1.8.0_181\jre\lib\jsse.jar;D:\Java\jdk1.8.0_181\jre\lib\management-agent.jar;D:\Java\jdk1.8.0_181\jre\lib\plugin.jar;D:\Java\jdk1.8.0_181\jre\lib\resources.jar;D:\Java\jdk1.8.0_181\jre\lib\rt.jar;D:\project-java\jiwang\out\production\jiwang CommandUtilPlease input destination server IP address ：baidu.comlocalhost/127.0.0.1 is tracking the destination server...===========================================================================接口列表  6...b4 b6 86 df cc 9d ......Realtek PCIe GbE Family Controller 11...0c 54 15 fb 33 95 ......Microsoft Wi-Fi Direct Virtual Adapter 14...0e 54 15 fb 33 94 ......Microsoft Wi-Fi Direct Virtual Adapter #2 16...0c 54 15 fb 33 94 ......Intel(R) Dual Band Wireless-AC 3168 17...0c 54 15 fb 33 98 ......Bluetooth Device (Personal Area Network)  1...........................Software Loopback Interface 1===========================================================================IPv4 路由表===========================================================================活动路由:网络目标        网络掩码          网关       接口   跃点数          0.0.0.0          0.0.0.0      192.168.2.1    192.168.2.132     35        127.0.0.0        255.0.0.0            在链路上         127.0.0.1    331        127.0.0.1  255.255.255.255            在链路上         127.0.0.1    331  127.255.255.255  255.255.255.255            在链路上         127.0.0.1    331      192.168.2.0    255.255.255.0            在链路上     192.168.2.132    291    192.168.2.132  255.255.255.255            在链路上     192.168.2.132    291    192.168.2.255  255.255.255.255            在链路上     192.168.2.132    291        224.0.0.0        240.0.0.0            在链路上         127.0.0.1    331        224.0.0.0        240.0.0.0            在链路上     192.168.2.132    291  255.255.255.255  255.255.255.255            在链路上         127.0.0.1    331  255.255.255.255  255.255.255.255            在链路上     192.168.2.132    291===========================================================================永久路由:  无localhost/127.0.0.1 is tracking the destination server...通过最多 10 个跃点跟踪到 baidu.com [39.156.69.79] 的路由:  1     1 ms     1 ms     1 ms  RM2100.lan [192.168.2.1]  2     *        *        *     请求超时。  3     *        *        *     请求超时。  4     4 ms     3 ms     3 ms  192.168.100.253  5     4 ms     5 ms    10 ms  192.168.100.114  6     3 ms     3 ms     3 ms  192.168.100.118  7     *        *        *     请求超时。  8     *        *        *     请求超时。  9     *        *        *     请求超时。 10     *        *        *     请求超时。跟踪完成。localhost/127.0.0.1 is tracking the destination server...正在 Ping baidu.com [39.156.69.79] 具有 32 字节的数据:来自 39.156.69.79 的回复: 字节=32 时间=20ms TTL=48来自 39.156.69.79 的回复: 字节=32 时间=20ms TTL=48来自 39.156.69.79 的回复: 字节=32 时间=20ms TTL=48来自 39.156.69.79 的回复: 字节=32 时间=20ms TTL=4839.156.69.79 的 Ping 统计信息:    数据包: 已发送 = 4，已接收 = 4，丢失 = 0 (0% 丢失)，往返行程的估计时间(以毫秒为单位):    最短 = 20ms，最长 = 20ms，平均 = 20msIP address : baidu.com/39.156.69.79Get the Server-Name# : baidu.comGet the default file# : index.htmlGet the protocol# : http 80Get serverName &amp; IPAddress：baidu.com/39.156.69.79Surplus memory of JVM: 124194640B</code></pre>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>正则表达式</title>
      <link href="/blog/xm1a2g/"/>
      <url>/blog/xm1a2g/</url>
      
        <content type="html"><![CDATA[<h2 id="常见匹配符号"><a href="#常见匹配符号" class="headerlink" title="常见匹配符号"></a>常见匹配符号</h2><p>| 正则表达式  |                                               描述                                                |<br>| :———: | :———————————————————————————————–: | ———– |<br>|     <code>.</code>     |           匹配所有单个字符，除了换行符（Linux 中换行是 <code>\n</code>，Windows 中换行是 <code>\r\n</code>）            |<br>|  <code>^regex</code>   |                                      正则必须匹配字符串开头                                       |<br>|  <code>regex$</code>   |                                      正则必须匹配字符串结尾                                       |<br>|   <code>[abc]</code>   |                                 复选集定义，匹配字母 a 或 b 或 c                                  |<br>| <code>[abc][vz]</code> |                         复选集定义，匹配字母 a 或 b 或 c，后面跟着 v 或 z                         |<br>|  <code>[^abc]</code>   | 当插入符 <code>^</code> 在中括号中以第一个字符开始显示，则表示否定模式。此模式匹配所有字符，除了 a 或 b 或 c |<br>| <code>[a-d1-7]</code>  |                    范围匹配，匹配字母 a 到 d 和数字从 1 到 7 之间，但不匹配 d1                    |<br>|    <code>XZ</code>     |                                        匹配 X 后直接跟着 Z                                        |<br>|      X      |                                                 Z                                                 | 匹配 X 或 Z |</p><h2 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h2><table><thead><tr><th align="center">正则表达式</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center"><code>\d</code></td><td align="center">匹配一个数字，是 <code>[0-9]</code> 的简写</td></tr><tr><td align="center"><code>\D</code></td><td align="center">匹配一个非数字，是 <code>[^0-9]</code> 的简写</td></tr><tr><td align="center"><code>\s</code></td><td align="center">匹配一个空格，是 <code>[ \t\n\x0b\r\f]</code> 的简写</td></tr><tr><td align="center"><code>\S</code></td><td align="center">匹配一个非空格</td></tr><tr><td align="center"><code>\w</code></td><td align="center">匹配一个单词字符（大小写字母、数字、下划线），是 <code>[a-zA-Z_0-9]</code> 的简写</td></tr><tr><td align="center"><code>\W</code></td><td align="center">匹配一个非单词字符（除了大小写字母、数字、下划线之外的字符），等同于 <code>[^\w]</code></td></tr></tbody></table><h2 id="限定符"><a href="#限定符" class="headerlink" title="限定符"></a>限定符</h2><p>| 正则表达式 | 描述 | 举例 |<br>| <code>*</code> | 匹配 &gt;=0 个，是 <code>&#123;0,&#125;</code> 的简写 | <code>X*</code> 表示匹配零个或多个字母 X，<code>.*</code> 表示匹配任何字符串 |<br>| :—: | :—: | :—: |<br>| <code>+</code> | 匹配 &gt;=1 个，是 <code>&#123;1,&#125;</code> 的简写 | <code>X+</code> 表示匹配一个或多个字母 X |<br>| <code>?</code> | 匹配 1 个或 0 个，是 <code>&#123;0,1&#125;</code> 的简写 | <code>X?</code> 表示匹配 0 个或 1 个字母 X |<br>| <code>&#123;X&#125;</code> | 只匹配 X 个字符 | <code>\d&#123;3&#125;</code> 表示匹配 3 个数字，<code>.&#123;10&#125;</code> 表示匹配任何长度是 10 的字符串 |<br>| <code>&#123;X,Y&#125;</code> | 匹配 &gt;=X 且 &lt;=Y 个 | <code>\d&#123;1,4&#125;</code> 表示匹配至少 1 个最多 4 个数字 |<br>| <code>*?</code> | 如果 <code>?</code> 是限定符 <code>*</code> 或 <code>+</code> 或 <code>?</code> 或 <code>&#123;&#125;</code> 后面的第一个字符，那么表示<strong>非贪婪模式</strong>（尽可能少的匹配字符），而不是默认的<strong>贪婪模式</strong> | |</p>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 非前端编程语言 </category>
          
          <category> JAVA </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>继承和多态</title>
      <link href="/blog/bn6afv/"/>
      <url>/blog/bn6afv/</url>
      
        <content type="html"><![CDATA[<h2 id="extends-和-super"><a href="#extends-和-super" class="headerlink" title="extends 和 super"></a>extends 和 super</h2><ul><li>**子类继承父类用关键字 <code>extends</code> **</li><li>super 关键字作用有<ul><li>继承父类的构造函数</li><li>构造方法链</li><li>调用父类的方法（一般不怎么用）</li></ul></li></ul><h2 id="方法重写和方法重载"><a href="#方法重写和方法重载" class="headerlink" title="方法重写和方法重载"></a>方法重写和方法重载</h2><blockquote><p>方法重写注意要子类和父类的方法都得是一样的签名和返回类型</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1600089343780-c8d0a28c-dc06-4aab-a331-9ac926a65498.png#align=left&display=inline&height=289&margin=%5Bobject%20Object%5D&name=image.png&originHeight=577&originWidth=764&size=325094&status=done&style=shadow&width=382" alt="image.png"></p><p>为了避免编写程序过程中方法重载和方法重写的误用，使用<strong>重写标注 <code>@Override</code></strong> 来区分，系统可以检查方法的正确性。</p><h2 id="Object-类"><a href="#Object-类" class="headerlink" title="Object 类"></a>Object 类</h2><blockquote><p>java 中所有类都继承子 java.lang.Object 类，其中 toString 就是该类里面的方法之一，所有许多接口/类都会重写这个方法，手写的链表里面的该方法就是重写之后的方法</p></blockquote><h2 id="多态与动态绑定"><a href="#多态与动态绑定" class="headerlink" title="多态与动态绑定"></a>多态与动态绑定</h2><blockquote><p>多态</p></blockquote><p>使用夫类对象的地方都可以使用子类对象。也就意味着父类的变量可以引用子类型的对象</p><blockquote><p>动态绑定</p></blockquote><p>如果定义了一个父类的对象，该对象调用了一个方法，该方法不存在父类当中，但是存在其父类下面的多个子类当中，那么这个方法调用的是哪个子类当中的该方法呢？JVM 有这么一个机制，从“辈分最小的类”依次往上找，第一个找到含有该方法的类，则调用该类当中的那个方法<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1600138148812-5cc991ce-0577-4f01-b57c-bec631518a99.png#align=left&display=inline&height=109&margin=%5Bobject%20Object%5D&name=image.png&originHeight=217&originWidth=960&size=14420&status=done&style=shadow&width=483" alt="image.png"><br>注：Cn 为父类，往后都是以此继承的子类</p><h2 id="对象转换"><a href="#对象转换" class="headerlink" title="对象转换"></a>对象转换</h2><blockquote><p>向下转换与向上转换</p></blockquote><pre><code class="java">Object o = new Student(); // 可以：因为Student的实例也是Object的实例Student a = o; // (o是Object对象)不可以：因为“级别”的不可逆Student s = Student(o); //向上转换</code></pre><blockquote><p>instanceof</p></blockquote><p>如果一个对象不是 Student 实例，他就不能转换成 Student 类型的变量，会报错 <code>ClassCastException</code> 。因此，在此之前最好先确保该对象是另一个对象的实例，于是用到关键字 <code>instanceof</code></p><pre><code class="java">Object myObject = new Circle();... // Some lines of code/** Perform casting if myObject is an instance of Circle */if (myObject instanceof Circle) &#123;  System.out.println(&quot;The circle diameter is &quot; +    ((Circle)myObject).getDiameter());  ...&#125;</code></pre><h2 id="override"><a href="#override" class="headerlink" title="@override"></a>@override</h2><p>在重写父类的函数时，在方法前面加上<a href="https://www.yuque.com/Override">@Override </a> 系统可以帮你检查方法的正确性。</p>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 非前端编程语言 </category>
          
          <category> JAVA </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>抽象类和接口</title>
      <link href="/blog/akog9h/"/>
      <url>/blog/akog9h/</url>
      
        <content type="html"><![CDATA[<h2 id="概念名词"><a href="#概念名词" class="headerlink" title="概念名词"></a>概念名词</h2><ul><li><strong>接口</strong>：许多类的<strong>共同行为</strong>（包含非相关类），就当与给客户看的。</li><li><strong>抽象类</strong>：就相当于一个父类，该父类包含其子类的<strong>共性</strong>特征，就像是子类园和子类长方形，两个类可以有一个共同的父类，该父类定义为抽象类，其包含一个<strong>抽象方法</strong>，比如求面积或是求周长</li></ul><h2 id="接口的一些要点"><a href="#接口的一些要点" class="headerlink" title="接口的一些要点"></a>接口的一些要点</h2><blockquote><p><code>public interface List&lt;E&gt; &#123; &#125;</code></p></blockquote><ul><li>接口是一个<strong>写注释</strong>的好地方</li></ul><h2 id="抽象类的一些要点"><a href="#抽象类的一些要点" class="headerlink" title="抽象类的一些要点"></a>抽象类的一些要点</h2><blockquote><p><code>public abstract class AbstractList&lt;E&gt; implements List&lt;E&gt; &#123; &#125;</code> &gt; <code>public abstract class Test()&#123;&#125;</code> &gt; <code>public abstract double getTest()&#123;&#125;</code></p></blockquote><ul><li>抽象类当中的<strong>抽象方法</strong>要在其子类当中实现，因为抽象类“抽象”的以至于没有实例</li><li>包含抽象方法的类必定是抽象类</li><li><strong>抽象类的构造函数实现要加上 protected，因为其构造函数只被其子类所使用，在创建子类实例的时候，其父类构造函数被调用来初始化该父类的数据域</strong></li><li><strong>抽象类不可以 new 对象，不对外公开，只抽取公共代码，eg：ArrayList 和 LinkedList</strong></li><li><strong>抽象类可以不是先接口里面的部分函数</strong></li><li><strong>抽象类作用：放“公共代码”</strong></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598686636557-2700f743-9f28-435a-b771-86bdf7b2b25c.png#align=left&display=inline&height=326&margin=%5Bobject%20Object%5D&originHeight=574&originWidth=732&size=0&status=done&style=shadow&width=416"></p>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 非前端编程语言 </category>
          
          <category> JAVA </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JAVA队列设计</title>
      <link href="/blog/zqmygi/"/>
      <url>/blog/zqmygi/</url>
      
        <content type="html"><![CDATA[<h2 id="Queue-队列设计"><a href="#Queue-队列设计" class="headerlink" title="Queue 队列设计"></a>Queue 队列设计</h2><blockquote><p>在头尾两端进行操作，先进先出 FIFO</p></blockquote><p>队列的接口设计</p><pre><code class="java">int size(); //队列元素个数boolean isEmpty(); //队列是否为空void clear(); //清空队列元素void enQueue(E element); //入队E deQueue(); // 出队E front(); //获取队列的头元素</code></pre><pre><code class="java">package com.wztlink1013.ds.queue;import com.wztlink1013.ds.queue.list.LinkedList;import com.wztlink1013.ds.queue.list.List;public class Queue&lt;E&gt; &#123;    private List&lt;E&gt; list = new LinkedList&lt;&gt;();    public int size() &#123;        return list.size();    &#125;    public boolean isEmpty() &#123;        return list.isEmpty();    &#125;    public void clear() &#123;        list.clear();    &#125;    public void enQueue(E element) &#123;        list.add(element);    &#125;    public E deQueue() &#123;        return list.remove(0);    &#125;    public E front() &#123;        return list.get(0);    &#125;&#125;</code></pre><h2 id="Deque-双端队列设计"><a href="#Deque-双端队列设计" class="headerlink" title="Deque 双端队列设计"></a>Deque 双端队列设计</h2><blockquote><p>双端队列是能在头尾两端添加、删除的队列</p></blockquote><pre><code class="java">package com.wztlink1013.ds.queue;import com.wztlink1013.ds.queue.list.LinkedList;import com.wztlink1013.ds.queue.list.List;public class Deque&lt;E&gt; &#123;    private List&lt;E&gt; list = new LinkedList&lt;&gt;();    public int size() &#123;        return list.size();    &#125;    public boolean isEmpty() &#123;        return list.isEmpty();    &#125;    public void clear() &#123;        list.clear();    &#125;    public void enQueueRear(E element) &#123;        list.add(element);    &#125;    public E deQueueFront() &#123;        return list.remove(0);    &#125;    public void enQueueFront(E element) &#123;        list.add(0, element);    &#125;    public E deQueueRear() &#123;        return list.remove(list.size() - 1);    &#125;    public E front() &#123;        return list.get(0);    &#125;    public E rear() &#123;        return list.get(list.size() - 1);    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 📶线结构：字符串-数组-栈-队列 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++顺序表设计</title>
      <link href="/blog/nlhg88/"/>
      <url>/blog/nlhg88/</url>
      
        <content type="html"><![CDATA[<div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">类似一个简易版本的数组</div><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><ul><li><input checked="" disabled="" type="checkbox"> 顺序表存储形式</li></ul><pre><code class="cpp">/* 顺序表的存储形式就是连续存储空间，地址连续的，其实就是数组 */typedef struct &#123;    int *arr;    int length;&#125;SqList;</code></pre><ul><li><input checked="" disabled="" type="checkbox"> 打印</li><li><input checked="" disabled="" type="checkbox"> 取值</li><li><input checked="" disabled="" type="checkbox"> 查找</li><li><input checked="" disabled="" type="checkbox"> 插入</li><li><input checked="" disabled="" type="checkbox"> 删除</li><li><input checked="" disabled="" type="checkbox"> 升序</li><li><input checked="" disabled="" type="checkbox"> 逆置</li></ul><pre><code class="cpp">#include&lt;bits/stdc++.h&gt;using namespace std;#define MAXSIZE 100/** * 顺序表 * * 顺序表的基本操作： 初始化、打印、取值、查找、插入、删除、升序、逆置 *//* 顺序表的存储形式就是连续存储空间，地址连续的，其实就是数组 */typedef struct &#123;    int *arr;    int length;&#125;SqList;/* 初始化 */void InitList(SqList &amp;L)&#123;    L.arr = new int[MAXSIZE];    if (!L.arr) exit(-1);    L.length = 0;&#125;/* 初始化添加元素 */void ListInsert(SqList &amp;L) &#123;    cout &lt;&lt; &quot;请输入元素个数n：&quot;;    int n;    cin &gt;&gt; n;    for (int i = 0; i &lt; n;i++)&#123;        cin &gt;&gt; L.arr[i];        L.length++;    &#125;&#125;/* 打印 */void TraverseList(SqList &amp;L) &#123;    cout &lt;&lt; &quot;该顺序表元素遍历结果为：&quot;;    for (int i = 0; i &lt; L.length;i++) &#123;        cout &lt;&lt; L.arr[i] &lt;&lt; &#39; &#39;;    &#125;    cout &lt;&lt; &quot;\n&quot;;&#125;/* 最大值 */void NumberMax (SqList &amp;L)&#123;    cout &lt;&lt; &quot;该顺序表最大值为：&quot;;    int max = L.arr[0];    for (int i = 0; i &lt; L.length;i++) &#123;        if(L.arr[i]&gt;max)            max = L.arr[i];    &#125;    cout &lt;&lt; max&lt;&lt;&quot;\n&quot;;&#125;/* 插值 */void InsertOneElement (SqList &amp;L) &#123;    cout &lt;&lt; &quot;请分别输入在n位置插入的e值：&quot;;    int n;    int e;    cin &gt;&gt; n &gt;&gt; e;    for (int i = L.length - 1; i &gt;= n-1;i--)&#123;        L.arr[i + 1] = L.arr[i];    &#125;    L.arr[n-1] = e;    L.length++;    cout &lt;&lt; &quot;\n&quot;&lt;&lt;&quot;插入值之后的顺序表为：&quot;;    TraverseList(L);&#125;/* 删除 */void DeleteOneElement (SqList &amp;L) &#123;    cout &lt;&lt; &quot;请输入要删除n位置的n值：&quot;;    int n;    cin &gt;&gt; n;    for (int i = 0; i &lt; L.length;i++)&#123;        if (i&gt;=n-1)&#123;            L.arr[i] = L.arr[i + 1];        &#125;    &#125;    L.length--;    cout &lt;&lt; &quot;\n&quot;&lt;&lt;&quot;删除值之后的顺序表为：&quot;;    TraverseList(L);&#125;/* 升序 */void IncrList (SqList &amp;L) &#123;    cout &lt;&lt; &quot;升序之后的顺序表为：&quot;;    for (int i = 0; i &lt; L.length;i++)&#123;        for (int j = 0; j &lt; L.length;j++)&#123;            if (L.arr[j]&gt;L.arr[i]) &#123;                int temp;                temp = L.arr[j];                L.arr[j] = L.arr[i];                L.arr[i] = temp;            &#125;        &#125;    &#125;    TraverseList(L);&#125;/* 逆置 */void ReverseList (SqList &amp;L) &#123;    cout &lt;&lt; &quot;逆序之后……&quot;;    for (int i = 0; i &lt; L.length / 2;i++)&#123;        int temp;        temp = L.arr[i];        L.arr[i] = L.arr[L.length-i-1];        L.arr[L.length-i-1] = temp;    &#125;    TraverseList(L);&#125;int main () &#123;    SqList test;    InitList(test);//1    ListInsert(test);//1    TraverseList(test);//1    NumberMax(test);//2    InsertOneElement(test);//3    DeleteOneElement(test);//4    IncrList(test);//5    ReverseList(test);//6&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 📶线结构：字符串-数组-栈-队列 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>20. 有效的括号🔖栈</title>
      <link href="/blog/aritwv/"/>
      <url>/blog/aritwv/</url>
      
        <content type="html"><![CDATA[<ul><li><a href="https://leetcode-cn.com/problems/valid-parentheses/">https://leetcode-cn.com/problems/valid-parentheses/</a></li></ul><h2 id="问题思路"><a href="#问题思路" class="headerlink" title="问题思路"></a>问题思路</h2><p>将所有的左半边括号 push 到栈内，然后遇到右半边括号，就将其与栈顶元素匹配测试，若能匹配成功则继续匹配，反之输出 false。</p><p>在这之间注意比较当栈内没有元素了，而字符串还有待匹配的字符，输出 false，当栈内还有元素，外面与之匹配测试的右半边括号，也输出 false。</p><h3 id="ts-实现"><a href="#ts-实现" class="headerlink" title="ts 实现"></a>ts 实现</h3><pre><code class="typescript">function isValid(s: string): boolean &#123;  let stack: Array&lt;string&gt; = [];  for (let i of s) &#123;    if ([&quot;(&quot;, &quot;[&quot;, &quot;&#123;&quot;].includes(i)) &#123;      stack.push(i);    &#125; else &#123;      switch (i) &#123;        case &quot;)&quot;:          if (stack[stack.length - 1] === &quot;(&quot;) &#123;            stack.pop();          &#125; else &#123;            return false;          &#125;          break;        case &quot;]&quot;:          if (stack[stack.length - 1] === &quot;[&quot;) &#123;            stack.pop();          &#125; else &#123;            return false;          &#125;          break;        case &quot;&#125;&quot;:          if (stack[stack.length - 1] === &quot;&#123;&quot;) &#123;            stack.pop();          &#125; else &#123;            return false;          &#125;          break;      &#125;    &#125;  &#125;  return stack.length ? false : true;&#125;</code></pre><h3 id="之前的-java-代码实现"><a href="#之前的-java-代码实现" class="headerlink" title="之前的 java 代码实现"></a>之前的 java 代码实现</h3><h4 id="栈实现"><a href="#栈实现" class="headerlink" title="栈实现"></a>栈实现</h4><pre><code class="java">class Solution &#123;    public boolean isValid(String s) &#123;        Stack&lt;Character&gt; stack = new Stack&lt;&gt;();        int len = s.length();        for (int i=0;i&lt;len;i++) &#123;            char c = s.charAt(i);            if (c == &#39;(&#39; || c == &#39;[&#39; || c == &#39;&#123;&#39;) &#123;                stack.push(c);            &#125; else &#123;                if (stack.isEmpty()) return false;                char left = stack.pop();                if (left == &#39;(&#39; &amp;&amp; c !=&#39;)&#39;) return false;                if (left == &#39;[&#39; &amp;&amp; c !=&#39;]&#39;) return false;                if (left == &#39;&#123;&#39; &amp;&amp; c !=&#39;&#125;&#39;) return false;            &#125;        &#125;        return stack.isEmpty();    &#125;&#125;</code></pre><pre><code class="java">class Solution &#123;    public boolean isValid(String s) &#123;        Stack&lt;Character&gt; stack = new Stack&lt;&gt;();        for (int i = 0; i&lt; s.length();i++)&#123;            if (s.charAt(0) == &#39;)&#39; || s.charAt(0) == &#39;]&#39; || s.charAt(0) == &#39;&#125;&#39;)&#123;                return false;            &#125;            if (s.charAt(i) == &#39;(&#39; || s.charAt(i) == &#39;[&#39; || s.charAt(i) == &#39;&#123;&#39;)&#123;                stack.push(s.charAt(i));            &#125;            if (s.charAt(i) == &#39;)&#39; || s.charAt(i) == &#39;]&#39; || s.charAt(i) == &#39;&#125;&#39;)&#123;                if (s.charAt(i) == &#39;)&#39;)&#123;                    if (stack.isEmpty() == true) &#123;                        return false;                    &#125;                    if (stack.pop() != &#39;(&#39;)                        return false;                &#125;                if (s.charAt(i) == &#39;]&#39;)&#123;                    if (stack.isEmpty() == true) &#123;                        return false;                    &#125;                    if (stack.pop() != &#39;[&#39;)                        return false;                &#125;                if (s.charAt(i) == &#39;&#125;&#39;)&#123;                    if (stack.isEmpty() == true) &#123;                        return false;                    &#125;                    if (stack.pop() != &#39;&#123;&#39;)                        return false;                &#125;            &#125;        &#125;        if (stack.isEmpty() == true)&#123;            return true;        &#125; else &#123;            return false;        &#125;    &#125;&#125;</code></pre><h4 id="HashMap-实现"><a href="#HashMap-实现" class="headerlink" title="HashMap 实现"></a>HashMap 实现</h4><pre><code class="java">class Solution &#123;    private static HashMap&lt;Character, Character&gt; map = new HashMap&lt;&gt;();    static &#123;        // key - value        map.put(&#39;(&#39;, &#39;)&#39;);        map.put(&#39;&#123;&#39;, &#39;&#125;&#39;);        map.put(&#39;[&#39;, &#39;]&#39;);    &#125;    public boolean isValid(String s) &#123;        Stack&lt;Character&gt; stack = new Stack&lt;&gt;();        int len = s.length();        for (int i = 0; i &lt; len; i++) &#123;            char c = s.charAt(i);            if (map.containsKey(c)) &#123; // 左括号                stack.push(c);            &#125; else &#123; // 右括号                if (stack.isEmpty()) return false;                if (c != map.get(stack.pop())) return false;            &#125;        &#125;        return stack.isEmpty();    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 📶线结构：字符串-数组-栈-队列 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JAVA栈设计</title>
      <link href="/blog/yxy6mv/"/>
      <url>/blog/yxy6mv/</url>
      
        <content type="html"><![CDATA[<h2 id="栈的设计"><a href="#栈的设计" class="headerlink" title="栈的设计"></a>栈的设计</h2><h3 id="栈的特点"><a href="#栈的特点" class="headerlink" title="栈的特点"></a>栈的特点</h3><p>栈的最重要特点就是其元素的<strong>后进先出，先进后出</strong>。</p><h3 id="栈的接口设计"><a href="#栈的接口设计" class="headerlink" title="栈的接口设计"></a>栈的接口设计</h3><p>栈可以<strong>直接继承</strong>之前所学的 ArrayList 亦或是 List 接口。<br>这过程中需要注意，最好不要直接继承，因为如果直接继承，会将接口里面的其他方法也继承下来，会导致栈的对外接口不合理，解决办法就是在<strong>类设计内部 new 一个 private List 对象</strong>来设计栈。</p><pre><code class="java">int size(); // 元素的数量boolean isEmpty(); // 栈是否为空void push(E element); // 入栈E pop(); // 出栈E top(); // 获取栈顶元素void clear(); // 清空栈</code></pre><pre><code class="java">package com.wztlink1013.ds.stack;import com.wztlink1013.ds.stack.list.ArrayList;import com.wztlink1013.ds.stack.list.List;public class Stack&lt;E&gt; &#123;    private List&lt;E&gt; list = new ArrayList&lt;&gt;();    public void clear() &#123;        list.clear();    &#125;    public int size() &#123;        return list.size();    &#125;    public boolean isEmpty() &#123;        return list.isEmpty();    &#125;    public void push(E element) &#123;        list.add(element);    &#125;    public E pop() &#123;        return list.remove(list.size() - 1);    &#125;    public E top() &#123;        return list.get(list.size() - 1);    &#125;&#125;</code></pre><h2 id="栈的应用"><a href="#栈的应用" class="headerlink" title="栈的应用"></a>栈的应用</h2><p><strong>浏览器的前进和后退</strong>的功能。<br>假如有网页 a、b、c、d，依次点击 abc 三个网页，然后回退至 b 网页，这个时候，就相当于在 1 栈中有 ab 两个网页（且 b 为栈顶元素），c 暂时放到 2 栈中，此时依然可以使用回退前进功能，但是现在在 b 页面上在新输入 d 网页并进入，此时 2 栈被清空，d 为 1 栈的栈顶元素，在此时的 d 页面内，不能使用浏览器的前进功能，只能使用后退功能。</p><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 📶线结构：字符串-数组-栈-队列 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>GitHub+PicGo构建免费图床及其高效使用</title>
      <link href="/blog/bzf30z/"/>
      <url>/blog/bzf30z/</url>
      
        <content type="html"><![CDATA[<h2 id="一、搭建缘由"><a href="#一、搭建缘由" class="headerlink" title="一、搭建缘由"></a>一、搭建缘由</h2><p>一开始搭建博客，避免不了要用许多图片，最初使用七牛云来做博客图床，但是后来发现，七牛云只有 30 天的临时域名，hhhhhhh，果然啊，天下就没有免费的好事啊~后来就发现 GitHub 配合 PicGo 可以作图床，而且加上 jsDlivr 速度可观。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1602926956661-8671ebfe-4f99-494d-b759-a9c75cd67b41.png#align=left&display=inline&height=670&margin=%5Bobject%20Object%5D&originHeight=670&originWidth=807&size=0&status=done&style=stroke&width=807"></p><h2 id="二、GitHub-相关配置"><a href="#二、GitHub-相关配置" class="headerlink" title="二、GitHub 相关配置"></a>二、GitHub 相关配置</h2><h3 id="新建-figure-图床仓库"><a href="#新建-figure-图床仓库" class="headerlink" title="新建 figure 图床仓库"></a>新建 figure 图床仓库</h3><p>常规新建仓库方式，命名 figure<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1602926957158-9c7f8749-4d8e-4bc9-9e1c-7d3db5a307b1.png#align=left&display=inline&height=241&margin=%5Bobject%20Object%5D&originHeight=241&originWidth=1812&size=0&status=done&style=stroke&width=1812"></p><h3 id="生成一个-Token-密匙"><a href="#生成一个-Token-密匙" class="headerlink" title="生成一个 Token 密匙"></a>生成一个 Token 密匙</h3><p>点击 setting<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1602926956634-4c139fbc-0469-4749-89b8-f139226aa7d2.png#align=left&display=inline&height=904&margin=%5Bobject%20Object%5D&originHeight=904&originWidth=1823&size=0&status=done&style=stroke&width=1823"><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1605839703428-b18e3c24-48e0-44ed-9715-81fcd822d4e8.png#align=left&display=inline&height=237&margin=%5Bobject%20Object%5D&originHeight=444&originWidth=1120&size=0&status=done&style=stroke&width=599"><br><strong>只需要勾选第一个仓库选项就可以了！</strong></p><h2 id="三、PicGo-相关配置"><a href="#三、PicGo-相关配置" class="headerlink" title="三、PicGo 相关配置"></a>三、PicGo 相关配置</h2><h3 id="下载及注意事项"><a href="#下载及注意事项" class="headerlink" title="下载及注意事项"></a>下载及注意事项</h3><p><a href="https://github.com/Molunerfinn/PicGo/releases">下载地址</a><br>注意：下载 picgo 时候，要科学上网</p><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1602926956815-db5cf455-f628-4c4d-9242-1687e15a7f03.png#align=left&display=inline&height=564&margin=%5Bobject%20Object%5D&originHeight=564&originWidth=1002&size=0&status=done&style=none&width=1002"></p><h2 id="四、高效写博客"><a href="#四、高效写博客" class="headerlink" title="四、高效写博客"></a>四、高效写博客</h2><h3 id="Snipaste-截图软件"><a href="#Snipaste-截图软件" class="headerlink" title="Snipaste 截图软件"></a>Snipaste 截图软件</h3><blockquote><p><strong>常用</strong>快捷键【作者是用的惠普笔记本电脑，不同电脑键盘的使用方式会不一样】</p></blockquote><p>fn+f1：截屏（可编辑）<br>esc：退出<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1602926956785-4e12ba13-c4c6-4e5a-9758-5d3de27f9718.png#align=left&display=inline&height=446&margin=%5Bobject%20Object%5D&originHeight=446&originWidth=553&size=0&status=done&style=stroke&width=553"></p><h3 id="结合-PicGo-使用"><a href="#结合-PicGo-使用" class="headerlink" title="结合 PicGo 使用"></a>结合 PicGo 使用</h3><p>PicGo+Snipaste 快捷键结合<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1602926956619-08d5eae3-3b21-42cc-a2d8-85d6d2f8ed62.png#align=left&display=inline&height=220&margin=%5Bobject%20Object%5D&originHeight=220&originWidth=847&size=0&status=done&style=stroke&width=847"></p><h3 id="综合使用-SOP"><a href="#综合使用-SOP" class="headerlink" title="综合使用 SOP"></a>综合使用 SOP</h3><ol><li>按<code>fn+f1</code>截完图，再按<code>ctrl+c</code>将刚刚截图放到剪贴板</li><li>再按<code>ctrl+shift+p</code>使用 picgo 快捷键将剪贴板上的图片上传同时将此时图片的外链复制到剪贴板</li></ol><h2 id="五、相关补充"><a href="#五、相关补充" class="headerlink" title="五、相关补充"></a>五、相关补充</h2><h3 id="上传失败"><a href="#上传失败" class="headerlink" title="上传失败"></a>上传失败</h3><p><code>问题1：有些时候上传picgo时，会出现配置报错的情况</code></p><blockquote><p>方案 1：在 picgo 的配置中，改一下文件夹名字（相当于在仓库下新建一个文件夹），就比如本来存到 blogarticle3/文件夹下，改成 blogarticle4/就好了<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1602926956579-eafc7cfa-1e0b-41be-ae5b-c6560b8c7638.png#align=left&display=inline&height=186&margin=%5Bobject%20Object%5D&originHeight=186&originWidth=1320&size=0&status=done&style=none&width=1320"><br>方案 2：将下图所示的<code>上传前重命名</code>打开同时<code>设置Server</code>内容开换成关，关换成开，玄学……<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1602926956785-fb091672-3c17-49db-a0e7-965e20c93f5c.png#align=left&display=inline&height=564&margin=%5Bobject%20Object%5D&originHeight=564&originWidth=1002&size=0&status=done&style=none&width=1002"><br>方案 3：将 PicGo 软件叉掉重新运行。玄学····<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1602926957260-3a981036-cd74-4a90-8665-d2510470f2c9.png#align=left&display=inline&height=564&margin=%5Bobject%20Object%5D&originHeight=564&originWidth=1002&size=0&status=done&style=none&width=1002"><br>方案 4（最优方案）：科学上网</p></blockquote><h3 id="关于插件"><a href="#关于插件" class="headerlink" title="关于插件"></a>关于插件</h3><p>在插件列表里面下载这三个拓展插件，其中两个国内的托管 coding 和 gitee，还有一个 github plus 版本，不过觉得国内的外链范围肯定是要小一点的应该，最好是优先使用 github 图床，coding 和 gitee 的作为文章使用，有关博客配置的使用 CDN 等。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1602926956548-b7b5ad1b-2586-42c5-8f7d-9dd17c265fcf.png#align=left&display=inline&height=341&margin=%5Bobject%20Object%5D&originHeight=341&originWidth=771&size=0&status=done&style=none&width=771"></p><h4 id="Coding-配置"><a href="#Coding-配置" class="headerlink" title="Coding 配置"></a>Coding 配置</h4><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1602926956265-035a546d-2ecd-48c3-8eec-c9ef7779653b.png#align=left&display=inline&height=486&margin=%5Bobject%20Object%5D&originHeight=486&originWidth=739&size=0&status=done&style=none&width=739"></p><h4 id="gitee-配置"><a href="#gitee-配置" class="headerlink" title="gitee 配置"></a>gitee 配置</h4><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1602926956286-859465c2-411f-4761-8921-526656b8a191.png#align=left&display=inline&height=568&margin=%5Bobject%20Object%5D&originHeight=568&originWidth=778&size=0&status=done&style=none&width=778"></p><h4 id="GitHub-plus-配置"><a href="#GitHub-plus-配置" class="headerlink" title="GitHub plus 配置"></a>GitHub plus 配置</h4><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1602926956274-6e705ace-8e6f-4226-9fae-ffaaa66a2aa9.png#align=left&display=inline&height=517&margin=%5Bobject%20Object%5D&originHeight=517&originWidth=727&size=0&status=done&style=none&width=727"></p>]]></content>
      
      
      <categories>
          
          <category> ✨其他 </category>
          
          <category> 玩转博客 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>jsDelivr+Github或NPM+国内镜像源两种方法构建免费CDN库</title>
      <link href="/blog/erx9hf/"/>
      <url>/blog/erx9hf/</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1641718461641-3811ef80-de8d-4fe8-adf5-1e80d9bc3a4f.png#clientId=u667291ab-6b14-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=ue9c0ff30&margin=%5Bobject%20Object%5D&name=%E6%9E%84%E5%BB%BACDN%E5%BA%93.png&originHeight=383&originWidth=900&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=46755&status=done&style=none&taskId=u6626586e-8dfd-486a-bc28-1346ab73b96&title=" alt="构建CDN库.png"><br>前言：此前一直使用 jsDelivr+GitHub 来构建免费的 CDN 服务，但是在 2121.12.20 左右，jsDelivr 貌似崩了，究其原因是其在国内的备案失效了，导致网宿停止对该域名的服务，之后恢复之后，国内节点也不会像之前一样的解析得快了，具体体现就是网站中涉及 jsDelivr 静态资源 CDN 处打开会有卡顿的访问情况。</p><p>所以本文介绍新一种搭建免费 CDN 的方案：将静态资源发布 NPM 包+国内镜像引用的方式，另一种是之前一直用的 jsDelivr+GitHub 仓库引用的方案。</p><h3 id="何为内容分发网络-CDN"><a href="#何为内容分发网络-CDN" class="headerlink" title="何为内容分发网络 CDN"></a>何为内容分发网络 CDN</h3><blockquote><p>CDN 的全称是 Content Delivery Network，即内容分发网络。CDN 是构建在网络之上的内容分发网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。CDN 的关键技术主要有内容存储和分发技术。——百度百科</p></blockquote><p>通俗来说就是提取外链，同时加速访问的好处。Github 的资源在国内加载速度比较慢，因此需要使用 CDN 加速来优化网站打开速度，<del>jsDelivr + Github 便是免费且好用的 CDN</del>（jsDelivr cdn 半挂状态），非常适合博客网站使用。</p><h2 id="方法一：NPM-包-国内镜像"><a href="#方法一：NPM-包-国内镜像" class="headerlink" title="方法一：NPM 包+国内镜像"></a>方法一：NPM 包+国内镜像</h2><p>原因：</p><ul><li>网站引入的静态资源，如 js、css、图片等资源，使用公共的 CDN 库来引入会更好地优化网站速度。</li><li>不用 jsDelivr+GitHub 做 CDN 的缘由是，镜像没有 npm 的镜像多</li><li>jsDelivr cdn 挂了（盲猜薅羊毛导致），备案证书过期，国内速度不再是从前的那般快了</li></ul><h3 id="CDN-镜像源"><a href="#CDN-镜像源" class="headerlink" title="CDN 镜像源"></a>CDN 镜像源</h3><ul><li>饿了么做的：<a href="https://npm.elemecdn.com/">https://npm.elemecdn.com/</a></li></ul><p><a href="https://unpkg.zhimg.com/yuque-hexo-lyrics@1.0.0/config.js">https://unpkg.zhimg.com/yuque-hexo-lyrics@1.0.0/config.js</a></p><ul><li>知乎做的：<a href="https://unpkg.zhimg.com/">https://unpkg.zhimg.com/</a></li></ul><p><a href="https://npm.elemecdn.com/yuque-hexo-lyrics@1.0.0/config.js">https://npm.elemecdn.com/yuque-hexo-lyrics@1.0.0/config.js</a></p><ul><li>UNPKG（unpkg 镜像用的是 CloudFlare，国内加速效果不好）：<a href="https://unpkg.com/">https://unpkg.com/</a></li></ul><p><a href="https://unpkg.com/yuque-hexo-lyrics@1.0.0/config.js">https://unpkg.com/yuque-hexo-lyrics@1.0.0/config.js</a></p><ul><li>……</li></ul><h3 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h3><p>将 GitHub 仓库私有化，同时配置 GitHub Actions，如果发布版本/fork/star 等操作，就将其 pulish 到 npm 包</p><p>每次更新 GitHub 仓库之后，需要将 package.json 文件中的 version 字段的值指定，然后才能使用 GitHub Actions 进行自动化部署</p><p>具体使用形式：</p><ul><li><a href="https://unpkg.zhimg.com/cdn-website@0.0.0/ico/heroes_villains/Totoro.ico">https://unpkg.zhimg.com/cdn-website@0.0.0/ico/heroes_villains/Totoro.ico</a></li><li><a href="https://unpkg.zhimg.com/cdn-pictures@0.0.0/about/teacher.png">https://unpkg.zhimg.com/cdn-pictures@0.0.0/about/teacher.png</a></li><li><a href="https://unpkg.zhimg.com/cdn-articles@0.0.0/article1/20200725094728.jpg">https://unpkg.zhimg.com/cdn-articles@0.0.0/article1/20200725094728.jpg</a></li></ul><p>其中，上述链接中的 CDN 链接<a href="https://unpkg.zhimg.com/">https://unpkg.zhimg.com/</a>都可以用其他镜像源（unpkg、elemecdn、jsdelivr 等）替换</p><h2 id="方法二：jsDelivr-GitHub-仓库"><a href="#方法二：jsDelivr-GitHub-仓库" class="headerlink" title="方法二：jsDelivr+GitHub 仓库"></a>方法二：jsDelivr+GitHub 仓库</h2><h3 id="GitHub-新建-CDN-仓库"><a href="#GitHub-新建-CDN-仓库" class="headerlink" title="GitHub 新建 CDN 仓库"></a>GitHub 新建 CDN 仓库</h3><p>在本地电脑进行一系列 clone/pull 等一系列操作，同时发布版本（最好上传一次就发布依次版本）<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1602926808858-fcdea51e-42b2-4582-b46d-e9c105842039.png#crop=0&crop=0&crop=1&crop=1&height=950&id=H2FW1&originHeight=950&originWidth=1844&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=0&status=done&style=none&title=&width=1844"><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1602926808290-99384f86-d857-415a-83e6-9be3b5bcf279.png#crop=0&crop=0&crop=1&crop=1&height=953&id=nIJCg&originHeight=953&originWidth=1832&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=0&status=done&style=none&title=&width=1832"></p><h3 id="使用-jsDelivr"><a href="#使用-jsDelivr" class="headerlink" title="使用 jsDelivr"></a>使用 jsDelivr</h3><p><code>[**https://cdn.jsdelivr.net/gh/wztlink1013/CDN-Volantis@**](https://cdn.jsdelivr.net/gh/wztlink1013/CDN-Volantis@)**版本号/文件夹/文件名.文件后缀**</code><br><strong>举个栗子</strong></p><ul><li><a href="https://cdn.jsdelivr.net/gh/wztlink1013/CDN@2.4/Pictures/blogbackground/fengbaobao_1.jpg">https://cdn.jsdelivr.net/gh/wztlink1013/CDN@2.4/Pictures/blogbackground/fengbaobao_1.jpg</a></li><li><a href="https://cdn.jsdelivr.net/gh/moezx/cdn@3.1.3//The%20Pet%20Girl%20of%20Sakurasou.mp4">https://cdn.jsdelivr.net/gh/moezx/cdn@3.1.3//The Pet Girl of Sakurasou.mp4</a></li></ul><blockquote><p>0、具体使用教程</p></blockquote><ul><li><a href="https://blog.wztlink1013.com/2020/02/25/Hexo/jsDelivr%E5%92%8CGitHub%E6%9E%84%E5%BB%BA%E5%85%8D%E8%B4%B9CDN/">jsDelivr 和 Github 构建免费 CDN</a></li><li><a href="https://www.jsdelivr.com/">jsdelivr 官网网站</a></li></ul><blockquote><p>1、加载任何 Github 发布、提交或分支</p></blockquote><ul><li><p><a href="https://cdn.jsdelivr.net/gh/user/repo@version/file">https://cdn.jsdelivr.net/gh/user/repo@version/file</a></p><blockquote><p>2、加载 jQuery v3.2.1</p></blockquote></li><li><p><a href="https://cdn.jsdelivr.net/gh/jquery/jquery@3.2.1/dist/jquery.min.js">https://cdn.jsdelivr.net/gh/jquery/jquery@3.2.1/dist/jquery.min.js</a></p></li></ul><blockquote><p>3、使用版本范围而不是特定版本</p></blockquote><ul><li><a href="https://cdn.jsdelivr.net/gh/jquery/jquery@3.2/dist/jquery.min.js">https://cdn.jsdelivr.net/gh/jquery/jquery@3.2/dist/jquery.min.js</a></li><li><a href="https://cdn.jsdelivr.net/gh/jquery/jquery@3/dist/jquery.min.js">https://cdn.jsdelivr.net/gh/jquery/jquery@3/dist/jquery.min.js</a></li></ul><blockquote><p>4、完全省略该版本以获取最新版本</p></blockquote><ul><li><a href="https://cdn.jsdelivr.net/gh/jquery/jquery/dist/jquery.min.js">https://cdn.jsdelivr.net/gh/jquery/jquery/dist/jquery.min.js</a></li></ul><blockquote><p>5、将“.min”添加到任何 JS/CSS 文件中以获取缩小版本，如果不存在，将为会自动生成</p></blockquote><ul><li><a href="https://cdn.jsdelivr.net/gh/jquery/jquery@3.2.1/src/core.min.js">https://cdn.jsdelivr.net/gh/jquery/jquery@3.2.1/src/core.min.js</a></li></ul><blockquote><p>6、在末尾添加 / 以获取资源目录列表</p></blockquote><ul><li><a href="https://cdn.jsdelivr.net/gh/jquery/jquery/">https://cdn.jsdelivr.net/gh/jquery/jquery/</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> ✨其他 </category>
          
          <category> 玩转博客 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>yuque-未拉取成功</title>
      <link href="/blog/wsmygb/"/>
      <url>/blog/wsmygb/</url>
      
        <content type="html"><![CDATA[<h2 id="一、报错信息"><a href="#一、报错信息" class="headerlink" title="一、报错信息"></a>一、报错信息</h2><pre><code class="bash">$ yuque-hexo sync[INFO] clear previous directory.[INFO] remove yuque posts: D:\Blog\blog-wztlink1013-3.0\source\yuqueMon, 01 Jun 2020 04:02:22 GMT yuque-hexo deprecated TOKEN of yuque will be required while verion &gt;v1.6.0. at ..\..\Develop\nodejs\node_global\node_modules\yuque-hexo\lib\Downloader.js:39:19[INFO] reading from local file: D:\Blog\blog-wztlink1013-3.0\yuque.json[WARNING] Cannot find module &#39;D:\Blog\blog-wztlink1013-3.0\yuque.json&#39;Require stack:- D:\Develop\nodejs\node_global\node_modules\yuque-hexo\lib\Downloader.js- D:\Develop\nodejs\node_global\node_modules\yuque-hexo\command\sync.js- D:\Develop\nodejs\node_global\node_modules\yuque-hexo\node_modules\common-bin\lib\command.js- D:\Develop\nodejs\node_global\node_modules\yuque-hexo\node_modules\common-bin\index.js- D:\Develop\nodejs\node_global\node_modules\yuque-hexo\index.js- D:\Develop\nodejs\node_global\node_modules\yuque-hexo\bin\yuque-hexo.js⚠️  Error: fail to fetch article list, response: &#123;&quot;status&quot;:401,&quot;message&quot;:&quot;Unauthorized&quot;&#125;⚠️  Command Error, enable `DEBUG=common-bin` for detail</code></pre><h2 id="二、分析并解决问题"><a href="#二、分析并解决问题" class="headerlink" title="二、分析并解决问题"></a>二、分析并解决问题</h2><p>认证出错，应该和下面三个原因有关</p><ul><li>客户端将其身份验证凭据发送到服务器，但是服务器由于某种原因拒绝了凭据。</li><li>客户端无法在请求中提供任何身份验证凭据。</li><li>客户端由于某种原因被禁止。某些应用程序用来限制来自特定 IP 地址的访问请求，因此，如果身份验证不是问题，则可能是服务器端禁止。401 Unauthorized Errors</li></ul><p>也就是身份没有被验证，首先检查用户元信息相关</p><p>的确，配置都是没有问题的，然后去 issue 里面查看相关问题，了解到是语雀官方出于对知识库安全性的调整，需要使用第三方 API 访问知识库，需要传入环境变量 YUQUE_TOKEN。</p><p>然后根据两种指导方式，传入参数即可</p><ul><li>设置全局的环境变量 YUQUE_TOKEN</li><li>命令执行时传入环境变量<ul><li>mac / linux: YUQUE_TOKEN=xxx yuque-hexo sync</li><li>windows: set YUQUE_TOKEN=xxx &amp;&amp; yuque-hexo sync</li></ul></li></ul><p>传入之后会有一封邮件发过来，然后新开 git bash 窗口，重新键入命令即可</p><p>成功之后是这个样子的</p><pre><code class="bash">$ yuque-hexo sync[INFO] clear previous directory.[INFO] remove yuque posts: D:\Blog\blog-wztlink1013-3.0\source\_posts\yuque[INFO] reading from local file: D:\Blog\blog-wztlink1013-3.0\yuque.json[INFO] article amount: 2[INFO] download articles done![INFO] writing to local file: D:\Blog\blog-wztlink1013-3.0\yuque.json[INFO] create posts directory (if it not exists): D:\Blog\blog-wztlink1013-3.0\source\_posts\yuque[INFO] generate post file: D:\Blog\blog-wztlink1013-3.0\source\_posts\yuque\hexo-test.md[INFO] generate post file: D:\Blog\blog-wztlink1013-3.0\source\_posts\yuque\语雀文章测试.md[INFO] yuque-hexo sync done!</code></pre><h2 id="相关参考"><a href="#相关参考" class="headerlink" title="相关参考"></a>相关参考</h2><ul><li><a href="https://airbrake.io/blog/http-errors/401-unauthorized-error">https://airbrake.io/blog/http-errors/401 U-unauthorized E-error:What It Is and How to Fix It</a></li><li><a href="https://www.yuguocong.cn/yuque/eg7hkp.html#Reference">使用语雀编辑器写静态博客 https://www.yuguocong.cn/yuque/eg7hkp.html#Reference</a></li><li><a href="https://blog.csdn.net/Caoyang_He/article/details/82181695?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.nonecase&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.nonecase">windows10 环境变量设置及理解环境变量</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> ✨其他 </category>
          
          <category> Bug </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>python-路径和nltk</title>
      <link href="/blog/uatg7m/"/>
      <url>/blog/uatg7m/</url>
      
        <content type="html"><![CDATA[<h2 id="一、路径相关"><a href="#一、路径相关" class="headerlink" title="一、路径相关"></a>一、路径相关</h2><h3 id="路径相关报错信息"><a href="#路径相关报错信息" class="headerlink" title="路径相关报错信息"></a>路径相关报错信息</h3><pre><code class="python">IOError: [Errno 2] No such file or directory</code></pre><pre><code class="python">pandas.read_csv() 报错 OSError: Initializing from file failed</code></pre><pre><code class="python">(unicode error) &#39;unicodeescape&#39; codec can&#39;t decode bytes in position 2-3: truncated \UXXXXXXXX escape [duplicate]</code></pre><pre><code class="python">File b&#39;train.csv&#39; does not exist even though file exist</code></pre><h3 id="分析与解决问题"><a href="#分析与解决问题" class="headerlink" title="分析与解决问题"></a>分析与解决问题</h3><p>编写 python 代码过程中，出现了类似这种一系列路径相关的错误，原因是，自己更改了<strong>相关文件夹/文件在电脑中的位置</strong>，解决办法就新建一个项目建一个全新路径或者修改现有路径</p><ul><li><code>\</code>绝对路径 会报错（转义字符）处理：① 双引号前面加一个 r②<code>\</code>换成<code>\\</code>（硬盘代号后面的第一个）</li><li><code>./</code>相对路径</li></ul><blockquote><p>三种解决方式<br><code>r&quot;C:\Users\YJG\Desktop\pi_digits.txt&quot;</code> &gt; <code>&quot;C:\\Users\\YJG\\Desktop\\pi_digits.txt&quot;</code> &gt; <code>&quot;C:/Users/YJG/Desktop/pi_digits.txt&quot;</code></p></blockquote><h3 id="PS：路径含中文"><a href="#PS：路径含中文" class="headerlink" title="PS：路径含中文"></a>PS：路径含中文</h3><p>假如路径、文件名都完整，还是报错的原因是这个参数中有中文，即使 Python3 已经支持中文，但是调用 pandas 的 read_csv()方法时，默认使用 C engine 作为 parser engine，而当文件名中含有中文的时候，用 C engine 在部分情况下就会出错。所以在调用 read_csv()方法时指定 engine 为 Python 就可以解决问题。根治：将路径编程全英文，这是必要素养习惯！</p><p><code>da4=pd.read_csv(xxxxxxxxxx,engine=&#39;python&#39;)</code></p><h3 id="PS：utf-8"><a href="#PS：utf-8" class="headerlink" title="PS：utf-8"></a>PS：utf-8</h3><pre><code>UnicodeDecodeError：: &#39;utf-8&#39; codec can&#39;t decode byte 0xc8 in position 0: invalid contin</code></pre><blockquote><p>解决办法：<code>data_1 = pd.read_csv(data1, encoding = &#39;gb2312&#39;)</code>或者 gb2312 换成 gbk<br>参考：<a href="https://blog.csdn.net/qq_18888869/article/details/82625343">https://blog.csdn.net/qq_18888869/article/details/82625343</a></p></blockquote><h2 id="二、nltk-相关"><a href="#二、nltk-相关" class="headerlink" title="二、nltk 相关"></a>二、nltk 相关</h2><h3 id="nltk-下载报错信息"><a href="#nltk-下载报错信息" class="headerlink" title="nltk 下载报错信息"></a>nltk 下载报错信息</h3><pre><code>bug:[WinError 10054] 远程主机强迫关闭了一个现有的连接</code></pre><h3 id="分析与解决问题-1"><a href="#分析与解决问题-1" class="headerlink" title="分析与解决问题"></a>分析与解决问题</h3><p>原因：模型权重参数文件（.h5）较大，下载出现中断，下载失败</p><blockquote><ul><li>解决办法：手动下载模型，放到指定目录</li><li><code>C:\Users\XXX\AppData\Roaming</code></li></ul></blockquote><p><a href="https://pan.baidu.com/s/1oUsf-FgVAZnQAtZWRwiK4w">下载地址</a>  （密码 9sar）</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://blog.csdn.net/zln_whu/article/details/103448420">CSDN-103448420</a></li><li><a href="https://www.jianshu.com/p/0e1d51a7549d">nltk 简书详细讲解</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> ✨其他 </category>
          
          <category> Bug </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>javaweb-8080端口被占用</title>
      <link href="/blog/qi1md8/"/>
      <url>/blog/qi1md8/</url>
      
        <content type="html"><![CDATA[<h2 id="一、报错信息"><a href="#一、报错信息" class="headerlink" title="一、报错信息"></a>一、报错信息</h2><pre><code>localhost:8080 is already in usePort 8080 required by Tomcat v8.0 Server at localhost is already in use. The server may already be running in another process, or a system process may be using the port. To start this server you will need to stop the other process or change the port number(s).Error running Tomcat8: Address localhost:8080 is already in use</code></pre><h2 id="一、分析并解决问题"><a href="#一、分析并解决问题" class="headerlink" title="一、分析并解决问题"></a>一、分析并解决问题</h2><blockquote><p>电脑中 8080 端口被占用，导致 web 项目不能运行</p></blockquote><blockquote><p>任务管理器关闭占用 8080 端口的程序</p></blockquote><h3 id="netstat-ano"><a href="#netstat-ano" class="headerlink" title="netstat -ano"></a>netstat -ano</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1602926284869-236a07ed-16de-4b45-9fb3-08aa10dd3df8.png#align=left&display=inline&height=600&margin=%5Bobject%20Object%5D&originHeight=600&originWidth=1200&size=0&status=done&style=none&width=1200"></p><h3 id="tasklist"><a href="#tasklist" class="headerlink" title="tasklist"></a>tasklist</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1602926285001-7e1779f1-5c00-4f0d-ad38-20b653849c37.png#align=left&display=inline&height=221&margin=%5Bobject%20Object%5D&originHeight=221&originWidth=1200&size=0&status=done&style=none&width=1200"><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1602926284877-544af23f-b422-49de-af28-86f9c7a37ce3.png#align=left&display=inline&height=183&margin=%5Bobject%20Object%5D&originHeight=183&originWidth=1200&size=0&status=done&style=none&width=1200"></p><h3 id="任务管理器"><a href="#任务管理器" class="headerlink" title="任务管理器"></a>任务管理器</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1602926285182-6bfb20a5-33a4-4a6b-8969-eaae9b7c67e4.png#align=left&display=inline&height=550&margin=%5Bobject%20Object%5D&originHeight=550&originWidth=834&size=0&status=done&style=none&width=834"></p>]]></content>
      
      
      <categories>
          
          <category> ✨其他 </category>
          
          <category> Bug </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>java-数组越界和格式输出</title>
      <link href="/blog/ggg01q/"/>
      <url>/blog/ggg01q/</url>
      
        <content type="html"><![CDATA[<h2 id="一、数组越界"><a href="#一、数组越界" class="headerlink" title="一、数组越界"></a>一、数组越界</h2><pre><code>java.lang.ArrayIndexOutOfBoundsException</code></pre><p>在进行判断条件的时候，注意 java 当中的数组“尾巴”不要溢出，数组 arr 的合法错误范围是[0, arr.length-1]</p><blockquote><ul><li>解决办法</li><li>①debug 看数组的尾巴部分输出情况【数组空间小的情况】</li><li>② 打印出遍历数组的索引值【通法】</li></ul></blockquote><p>回顾 java 初始化数组的方式：</p><ul><li>静态初始化：初始化时由程序员显式指定每个数组元素的初始值，有系统决定数组的长度</li></ul><blockquote><p>arrayName = new type[]{element1,element2,element3…}</p></blockquote><pre><code>int[] intArr;intArr = new int[]&#123;1,2,3,4,5,9&#125;;或者String[] strArr = &#123;&quot;one&quot;,&quot;two&quot;,&quot;three&quot;&#125;;</code></pre><ul><li>动态初始化：初始化时由程序员指定数组的长度，由系统初始化每个数组元素的默认值</li></ul><blockquote><p>arrayName = new type[length];</p></blockquote><pre><code>int[] price = new int[4];</code></pre><h2 id="二、printf；println；print"><a href="#二、printf；println；print" class="headerlink" title="二、printf；println；print"></a>二、printf；println；print</h2><ul><li>printf：遇到浮点型数值，继承 C 语言里面的使用，<strong>格式化</strong>输出（注意，参数顺序）</li><li>print：就是一般的标准输出，但是不换行</li><li>println：比 print 多的就是最后会换行</li></ul><pre><code class="java">int i = 4;double j = 5;System.out.print(&quot;用print输出i:&quot;+ i);System.out.println( &quot;用println输出i:&quot;+ i);System.out.printf(&quot;i的值为%d,j的值为%f&quot;, i,j);</code></pre><pre><code class="java">用print输出i:4用println输出i:4i的值为4,j的值为5.000000</code></pre><ul><li>printf 补充</li></ul><blockquote><p><code>%.2f</code>的意思是输出两位小数点<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1602926246151-1730c963-0816-46d1-bd3d-3a5cc7b30403.png#align=left&display=inline&height=589&margin=%5Bobject%20Object%5D&originHeight=589&originWidth=1162&size=0&status=done&style=none&width=1162"></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> ✨其他 </category>
          
          <category> Bug </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[转]java-找不到或无法加载主类</title>
      <link href="/blog/qp81g3/"/>
      <url>/blog/qp81g3/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/wangxiaoha/p/6293340.html">https://www.cnblogs.com/wangxiaoha/p/6293340.html</a></p><p><a href="https://bbs.csdn.net/topics/391862656?page=1">https://bbs.csdn.net/topics/391862656?page=1</a></p><p><a href="https://blog.csdn.net/qinshijangshan/article/details/53048342?depth_1-utm_source=distribute.pc_relevant.none-task-blog-OPENSEARCH-1&utm_source=distribute.pc_relevant.none-task-blog-OPENSEARCH-1">https://blog.csdn.net/qinshijangshan/article/details/53048342?depth_1-utm_source=distribute.pc_relevant.none-task-blog-OPENSEARCH-1&amp;utm_source=distribute.pc_relevant.none-task-blog-OPENSEARCH-1</a></p><p><a href="https://blog.csdn.net/lanchunhui/article/details/76339252">https://blog.csdn.net/lanchunhui/article/details/76339252</a></p><p><a href="https://blog.csdn.net/qq_37717853/article/details/78218606?depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1&utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1">eclipse 下的输入参数方式</a></p>]]></content>
      
      
      <categories>
          
          <category> ✨其他 </category>
          
          <category> Bug </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>hexo-生成文章出错</title>
      <link href="/blog/pxpix4/"/>
      <url>/blog/pxpix4/</url>
      
        <content type="html"><![CDATA[<h2 id="一、报错信息"><a href="#一、报错信息" class="headerlink" title="一、报错信息"></a>一、报错信息</h2><pre><code class="bash">hexo gINFO  Start processingFATAL Somethings wrong. Maybe you can find the solution here: https://hexo.io/docs/troubleshooting.htmlTemplate render error: (unknown path)  unexpected end of file    at Object._prettifyError (D:\Blog\blog-wztlink1013-3.0\node_modules\nunjucks\src\lib.js:36:11)    at Template.render (D:\Blog\blog-wztlink1013-3.0\node_modules\nunjucks\src\environment.js:536:21)    at Environment.renderString (D:\Blog\blog-wztlink1013-3.0\node_modules\nunjucks\src\environment.js:378:17)    at D:\Blog\blog-wztlink1013-3.0\node_modules\hexo\lib\extend\tag.js:120:48    at tryCatcher (D:\Blog\blog-wztlink1013-3.0\node_modules\bluebird\js\release\util.js:16:23)    at Function.Promise.fromNode.Promise.fromCallback (D:\Blog\blog-wztlink1013-3.0\node_modules\bluebird\js\release\promise.js:209:30)    at Tag.render (D:\Blog\blog-wztlink1013-3.0\node_modules\hexo\lib\extend\tag.js:120:18)    at Object.onRenderEnd (D:\Blog\blog-wztlink1013-3.0\node_modules\hexo\lib\hexo\post.js:291:22)    at D:\Blog\blog-wztlink1013-3.0\node_modules\hexo\lib\hexo\render.js:79:21    at tryCatcher (D:\Blog\blog-wztlink1013-3.0\node_modules\bluebird\js\release\util.js:16:23)    at Promise._settlePromiseFromHandler (D:\Blog\blog-wztlink1013-3.0\node_modules\bluebird\js\release\promise.js:547:31)    at Promise._settlePromise (D:\Blog\blog-wztlink1013-3.0\node_modules\bluebird\js\release\promise.js:604:18)    at Promise._settlePromise0 (D:\Blog\blog-wztlink1013-3.0\node_modules\bluebird\js\release\promise.js:649:10)    at Promise._settlePromises (D:\Blog\blog-wztlink1013-3.0\node_modules\bluebird\js\release\promise.js:729:18)    at _drainQueueStep (D:\Blog\blog-wztlink1013-3.0\node_modules\bluebird\js\release\async.js:93:12)    at _drainQueue (D:\Blog\blog-wztlink1013-3.0\node_modules\bluebird\js\release\async.js:86:9)    at Async._drainQueues (D:\Blog\blog-wztlink1013-3.0\node_modules\bluebird\js\release\async.js:102:5)    at Immediate.Async.drainQueues (D:\Blog\blog-wztlink1013-3.0\node_modules\bluebird\js\release\async.js:15:14)    at processImmediate (internal/timers.js:456:21)</code></pre><h2 id="二、分析并解决问题"><a href="#二、分析并解决问题" class="headerlink" title="二、分析并解决问题"></a>二、分析并解决问题</h2><p>根据报错信息，包 nunjucks、bluebird 使用异常</p><p>然后进到 node_modules 文件夹里面分别找到两个包，进入 README.md 进入官网，numjucks 包应该是渲染文章有关，期间出错应该是 markdown 文章里面所使用的标签与 nunjucks 模板引擎的标签冲突，</p><p>根据文档定位英文大括号的使用，定位文章使用带有大括号的 fancybox 标签，标签结束忘记加 end 而导致出错</p><h2 id="三、hexo-g-出错总结"><a href="#三、hexo-g-出错总结" class="headerlink" title="三、hexo g 出错总结"></a>三、hexo g 出错总结</h2><p>hexo g 出错总结多为文件格式出错，主题配置出错，抑或是文章格式出错等</p><h3 id="文章头部"><a href="#文章头部" class="headerlink" title="文章头部"></a>文章头部</h3><ul><li><em>hexo 相关文章报错，大多数为格式出错，文章头部的使用严格遵循 hexo 官方文档的使用，但是目录优化插件，使得文章头部的元信息更为简单化</em></li><li>减号<code>-</code>分隔符，注意头部 front-matter、markdown 行分隔。如果没有加 front-matter，文章还用了 markdown，会报错<br><code>YAMLException: end of the stream or a document separator is expected at line 6, column 1:</code></li><li>目录优化插件的使用</li></ul><h3 id="文章体"><a href="#文章体" class="headerlink" title="文章体"></a>文章体</h3><ul><li>英文大括号的使用要“有始有终”，Volantis 主题的大括号标签使用</li></ul><h3 id="空格问题"><a href="#空格问题" class="headerlink" title="空格问题"></a>空格问题</h3><pre><code class="bash">ERROR Process failed: _posts/yuque/外汇时间序列预测.mdYAMLException: end of the stream or a document separator is expected at line 2, column 11:    categories:              ^    at generateError (D:\Blog\blog-wztlink1013-3.0\node_modules\js-yaml\lib\js-yaml\loader.js:167:10)    at throwError (D:\Blog\blog-wztlink1013-3.0\node_modules\js-yaml\lib\js-yaml\loader.js:173:9)    at readDocument (D:\Blog\blog-wztlink1013-3.0\node_modules\js-yaml\lib\js-yaml\loader.js:1545:5)    at loadDocuments (D:\Blog\blog-wztlink1013-3.0\node_modules\js-yaml\lib\js-yaml\loader.js:1588:5)    at Object.load (D:\Blog\blog-wztlink1013-3.0\node_modules\js-yaml\lib\js-yaml\loader.js:1614:19)    at parseYAML (D:\Blog\blog-wztlink1013-3.0\node_modules\hexo-front-matter\lib\front_matter.js:78:23)    at parse (D:\Blog\blog-wztlink1013-3.0\node_modules\hexo-front-matter\lib\front_matter.js:54:12)    at D:\Blog\blog-wztlink1013-3.0\node_modules\hexo\lib\plugins\processor\post.js:48:20    at tryCatcher (D:\Blog\blog-wztlink1013-3.0\node_modules\bluebird\js\release\util.js:16:23)    at Promise._settlePromiseFromHandler (D:\Blog\blog-wztlink1013-3.0\node_modules\bluebird\js\release\promise.js:544:35)    at Promise._settlePromise (D:\Blog\blog-wztlink1013-3.0\node_modules\bluebird\js\release\promise.js:604:18)    at Promise._settlePromise0 (D:\Blog\blog-wztlink1013-3.0\node_modules\bluebird\js\release\promise.js:649:10)    at Promise._settlePromises (D:\Blog\blog-wztlink1013-3.0\node_modules\bluebird\js\release\promise.js:729:18)    at Promise._fulfill (D:\Blog\blog-wztlink1013-3.0\node_modules\bluebird\js\release\promise.js:673:18)    at PromiseArray._resolve (D:\Blog\blog-wztlink1013-3.0\node_modules\bluebird\js\release\promise_array.js:127:19)    at PromiseArray._promiseFulfilled (D:\Blog\blog-wztlink1013-3.0\node_modules\bluebird\js\release\promise_array.js:145:14)    at PromiseArray._iterate (D:\Blog\blog-wztlink1013-3.0\node_modules\bluebird\js\release\promise_array.js:115:31)    at PromiseArray.init [as _init] (D:\Blog\blog-wztlink1013-3.0\node_modules\bluebird\js\release\promise_array.js:79:10)    at Promise._settlePromise (D:\Blog\blog-wztlink1013-3.0\node_modules\bluebird\js\release\promise.js:601:21)    at Promise._settlePromise0 (D:\Blog\blog-wztlink1013-3.0\node_modules\bluebird\js\release\promise.js:649:10)    at Promise._settlePromises (D:\Blog\blog-wztlink1013-3.0\node_modules\bluebird\js\release\promise.js:729:18)    at Promise._fulfill (D:\Blog\blog-wztlink1013-3.0\node_modules\bluebird\js\release\promise.js:673:18)    at PromiseArray._resolve (D:\Blog\blog-wztlink1013-3.0\node_modules\bluebird\js\release\promise_array.js:127:19)    at PromiseArray._promiseFulfilled (D:\Blog\blog-wztlink1013-3.0\node_modules\bluebird\js\release\promise_array.js:145:14)    at Promise._settlePromise (D:\Blog\blog-wztlink1013-3.0\node_modules\bluebird\js\release\promise.js:609:26)    at Promise._settlePromise0 (D:\Blog\blog-wztlink1013-3.0\node_modules\bluebird\js\release\promise.js:649:10)    at Promise._settlePromises (D:\Blog\blog-wztlink1013-3.0\node_modules\bluebird\js\release\promise.js:729:18)    at Promise._fulfill (D:\Blog\blog-wztlink1013-3.0\node_modules\bluebird\js\release\promise.js:673:18)INFO  Generating Baidu urls for last 1 posts</code></pre><p>奇葩错误，在最上面的三个分隔符后面也要加空格，可能是语雀那边同步过来的文章问题</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://mozilla.github.io/nunjucks/cn/getting-started.html">nunjucks 文档</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> ✨其他 </category>
          
          <category> Bug </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>SSH-登录报错</title>
      <link href="/blog/pix070/"/>
      <url>/blog/pix070/</url>
      
        <content type="html"><![CDATA[<hr><h2 id="一、报错信息"><a href="#一、报错信息" class="headerlink" title="一、报错信息"></a>一、报错信息</h2><pre><code class="bash">remote: Coding 提示: Authentication failed.remote: 认证失败，请确认您输入了正确的账号密码。fatal: Authentication failed for &#39;https://e.coding.net/wztlink1013/wztlink1013.git/&#39;##[error]Process completed with exit code 128.</code></pre><h2 id="二、分析并解决问题"><a href="#二、分析并解决问题" class="headerlink" title="二、分析并解决问题"></a>二、分析并解决问题</h2><p>自动化部署过程中，coding 认证出错，我觉得应该有两个可能性</p><ol><li>字面意思账号密码出错</li><li>SSH 密匙没有匹配到</li><li>在 GitHub Actions 上所配置的 Token 信息之间也修改了一次，会不会是忘了改用户名</li></ol><p>如果是第一种情况，已经进入控制面板中的凭据管理器，更改了 coding 在本机上的默认永久密码，不弹窗理论没事，但是无效，</p><p>根据上次在本机上克隆 coding 仓库也没有其任何反应，所以问题应该出在 ssh 密匙上面，进一步回想，自己重装电脑后，当时是打算不使用全局用户没加上 global 打算使用各个用户，但是最后又换成全局用户，所以生成的.ssh 文件夹下的 config 文件有被删除了，会不会是 config 里面的 coding host 被删除，就默认这个电脑只有初始化 github 用户呢？</p><p>好的，试验了一下，解决了在本地电脑 coding“不算用户”的问题，但是自动化部署的问题未解决</p><p>最后试一下 GitHub Actions 上是不是 coding 用户名之间忘了换一次，的确是……</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.jianshu.com/p/501277e1bada">一台电脑利用秘钥绑定多个 ssh-key 账号（实 n</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> ✨其他 </category>
          
          <category> Bug </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Navicat-1045报错</title>
      <link href="/blog/wp9hok/"/>
      <url>/blog/wp9hok/</url>
      
        <content type="html"><![CDATA[<h2 id="一、报错信息"><a href="#一、报错信息" class="headerlink" title="一、报错信息"></a>一、报错信息</h2><pre><code>1045-Access denied for user root@localhost(using password:YES)</code></pre><h2 id="二、问题分析与解决"><a href="#二、问题分析与解决" class="headerlink" title="二、问题分析与解决"></a>二、问题分析与解决</h2><p>不被接入，改 root 密码</p><p>在 mysql 控制台里面改密码</p><p><code>ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED WITH mysql_native_password BY &#39;你的密码&#39;;</code></p><p>刷新数据库</p><p><code>flush privileges;</code></p><p>退出</p><p><code>quit;</code></p><p>重启 Navicat 再次链接即可。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://blog.csdn.net/acoolgiser/article/details/82967317?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522159185926319725250149590%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=159185926319725250149590&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_ctr_v3-4-82967317.ecpm_v1_rank_ctr_v3&utm_term=1045-Access+denied+for+user+ro">acoolgiser</a></li><li><a href="https://blog.csdn.net/zhang_yu_ling/article/details/103177296?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522159185926319725250149590%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=159185926319725250149590&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_ctr_v3-2-103177296.ecpm_v1_rank_ctr_v3&utm_term=1045-Access+denied+for+user+ro">张张张 i</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> ✨其他 </category>
          
          <category> Bug </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>『斩·赤红之瞳』</title>
      <link href="/essay/vbkkpv/"/>
      <url>/essay/vbkkpv/</url>
      
        <content type="html"><![CDATA[<p>赤瞳的“葬送！”永远无敌，威尔的乡巴佬（贵族）战车甚是让人怀念！<br><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1620268429108-34b6b7b4-9e0e-44f5-aec6-6ea523773328.jpeg#align=left&display=inline&height=60&id=tBuFQ&margin=%5Bobject%20Object%5D&originHeight=60&originWidth=60&status=done&style=stroke&width=60"></p><p>最喜欢威尔这个角色，有自己的信仰，却又不被信仰所蒙蔽双眼！<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1620268376141-97fd7be2-f256-442b-970d-1ab2b6b29214.png#align=left&display=inline&height=540&id=u9c94a2b1&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1080&originWidth=1920&size=3241587&status=done&style=stroke&width=960" alt="image.png"></p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1619317355425-0fe5d175-5fc4-4e3c-b6e0-ecef02d26cf6.png#align=left&display=inline&height=1080&id=uf72f0f30&margin=%5Bobject%20Object%5D&name=592276.png&originHeight=1080&originWidth=1920&size=2185020&status=done&style=none&width=1920" alt="592276.png"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1619403236436-3b1f1084-70d1-470c-8033-8da759333d26.png#align=left&display=inline&height=2039&id=KgBwl&margin=%5Bobject%20Object%5D&name=81852880_p0.png&originHeight=2039&originWidth=1378&size=2849409&status=done&style=none&width=1378" alt="81852880_p0.png"><br><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1619403320717-174bfe62-fc0d-4470-ade4-dfaec764e1a8.jpeg#align=left&display=inline&height=1080&id=OBENY&margin=%5Bobject%20Object%5D&name=605796.jpg&originHeight=1080&originWidth=1920&size=1144117&status=done&style=none&width=1920" alt="605796.jpg"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1619403335035-06379a53-3aa1-4ed1-8194-864aa0423edf.png#align=left&display=inline&height=1359&id=BZQXf&margin=%5Bobject%20Object%5D&name=610221.png&originHeight=1359&originWidth=1920&size=3173404&status=done&style=none&width=1920" alt="610221.png"><br><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1619403340923-d3a0d8f3-2a53-4f2d-ae07-18c5a4d10d3b.jpeg#align=left&display=inline&height=1080&id=poIeY&margin=%5Bobject%20Object%5D&name=554303.jpg&originHeight=1080&originWidth=1920&size=187185&status=done&style=none&width=1920" alt="554303.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 影视 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>榕树下的男孩和女孩</title>
      <link href="/essay/rqlvig/"/>
      <url>/essay/rqlvig/</url>
      
        <content type="html"><![CDATA[<p>趁着伙伴们都还在睡觉那天还未入夜，他朝着桥的那头跑去，那天月亮高高挂起，像是蒙娜丽莎的那般深邃眼眸观望着他，突然，他像是被什么东西拍打了一下，男孩往后望去，是个小女孩，那女孩头发短短的，头发末梢还有些卷卷的，就像是柳树下的枝柳发梢一般，凌乱有致，最重要的是男孩被那饱含星辰大海的眼眸所吸引，还有那唇……小男孩突然一愣，回应道：“你是谁？”女孩说：“我练完了，想去桥的那头玩玩！”男孩惊讶之，连忙回应：“我也是”，榕树那边的风景亦是观之，却不能让我陶醉，说罢，小男孩帮那个小女孩整理一番身边的杂草，他想牵起哪个女孩的手，但是他并没有，他在害怕吗？不知道。我想可能是他没有这般前期过别人的手吧。</p><p>桥的那头好漂亮，哪里有些许的繁华，还有些唱作，同时传来了一阵阵的童谣响起，那个女孩心里一颤，她说，如熟悉的唱作，和我家乡一般，她说她听到了她儿时的童谣，男孩向她的眼眸观去，他像是看到了星辰，他瞬间感受到一种温度，是的！他喜欢上她了。</p><p>榕树下的人们，是有着各自的命运的，男孩和女孩，男孩子要往前走，因为这里的人们是不能停滞的。因为它们本该如此。</p><p>男孩终于忍不住了，他对女孩说：“你喜欢这个童谣吗？”女孩说：“好感动，能在这个地方听到这个童谣”，女孩有一个动作，她用手指收起了她的眼泪，男孩心里想着，桥是禁忌，按照他们的文明，那是他们不能逾越的禁忌。</p><p>旁边的蛐蛐们开始了，仿佛开始为那童谣奏乐了，周围很喧闹，但是他的内心足够安静的，一切都是那般静，那一瞬间，那个男孩就像静静地享受着这般安静与温暖，就像是圆月下的海面，波光涟漪却也有着阵阵波澜。</p><p>桥就像是时间的奴隶，夜深了，桥头的那根锁链开始叮叮叮~的响起，像是提醒着失足的孩子们该回去了，男孩和女孩的时间不读了，往日，男孩会跑着回桥的那头榕树下，来日再来看看这繁华的都市，然后回到榕树下面，因为本该如此，他比谁都清楚榕树下的他背负着怎么样的命运。</p><p>黑夜里，男孩再也看不见女孩的脸，月光很圆，周围的灯也是明亮着的，但男孩却觉得周围一切都是暗淡的，因为他再也看不见那深邃的眼眸。</p><p>女孩对男孩说：“谢谢你帮我越过那座桥，我才有了这般幸运，在这榕树下的文明之外还能听到这般旋律，谢谢你！”</p><p>但是男孩心里想要的不是这句谢谢，是她眼神之下的温暖的星辰大海，因为他一直往前走，修炼。</p><p>他想要在榕树下成为一个真正的男人，特立独行，无惧生死，因为他觉得，他本该如此！可今天，他似乎被他的脸庞融化了。</p><p>一路上，男孩和女孩说着话，他从来没有这般欣喜，来到榕树下面，这个新生的文明之下，可是，女孩的话却在变少。</p><p>回到榕树下，隧道已经慢慢如期开启，男孩和女孩要走了，男孩心里清楚着，他不会再见她了，他心里忧伤，却也无奈，因为，在此之下的文明，亦是如此，就像是之前所述的“内壁”那般文明、国度。或者还可以说，文明之间，男孩和女孩是不合适的，因为她走的和他走的路从一开始就是相反的道路，但在榕树下的男孩确实一直以来有着思想的精灵，他有些忍不住了，在女孩走向隧道那扇门之前那么一瞬，男孩大声说：“喂，你，你的眼睛很好看，虽然夜太黑，但我心里还记得，我喜欢你，喜欢你喜欢的童谣，喜欢你眼睛中的星辰大海！我从没有想过，在榕树下的文明，还能遇见此般的你。还有，我很喜欢你的微笑。”女孩说：“嗯。”</p><p>2020.10.12 文渊楼 C 区 255 划水 ing</p>]]></content>
      
      
      <categories>
          
          <category> 异世界 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>鸟儿飞走了</title>
      <link href="/essay/pyxkf8/"/>
      <url>/essay/pyxkf8/</url>
      
        <content type="html"><![CDATA[<p>学校又要建楼了，地点是图书馆靠西边的那片树林。</p><p>去二餐的靠建筑工地的那条沿路上，总是听到叽叽喳喳的小鸟叫声，定睛一看，原来是因建筑而没有去路的小鸟，它们就在那片矮秃秃的草丛里面，就像是饿了的稚鸟在窝里面叽叽喳喳等它们母亲回来一般。</p><p>“济南一建”的速度真是快，短短一个月不到，那栋楼就建成有二、三层高楼那般模样，可我却不太喜欢它们这么快速度，因为那样，就会挡住我在 E 区各个楼道往学校南边观去的视线，正好挡住学校后面的双龙山，学校的小鸟也会少了，估计它们会生气般地往山上飞去，不再飞回来了。</p><p>为什么我会有些许的伤感……</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>对待问题要静心处理</title>
      <link href="/essay/wgtfly/"/>
      <url>/essay/wgtfly/</url>
      
        <content type="html"><![CDATA[<p>在配置安卓环境的时候，遇到 sdk 漏下载的情况，中间有几次心态爆炸，遇到问题发现自己还是不能很好的解决</p><p>这过程中，S 同学说到他配置环境用到了三天，最后成功了，而且，他的环境远劣于我，突然让我想到一句话，<strong>谁都会遇到问题，甚至遇到的问题都一样</strong>。但是不同的人会有不同的处理方式以及对待问题的态度，我的心真的还不够静，甚至可以说，依旧那么浮躁…</p><p>遇到困难，要静下心来，纸上得来终觉浅，绝知此事要躬行啊～</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>MySQL命令</title>
      <link href="/blog/emv1ek/"/>
      <url>/blog/emv1ek/</url>
      
        <content type="html"><![CDATA[<h2 id="登陆命令"><a href="#登陆命令" class="headerlink" title="登陆命令"></a>登陆命令</h2><pre><code class="sql">mysql -u用户名 -p密码</code></pre><p>用户名和-u 选项之间可以有空格，但是密码和-p 选项之间必须无空格。但是这样密码会是明文。你可以在键入-p 之后，回车再输入密码，就是密文。</p><h3 id="常用选项"><a href="#常用选项" class="headerlink" title="常用选项"></a>常用选项</h3><table><thead><tr><th>缩写</th><th>全写</th><th>描述</th></tr></thead><tbody><tr><td>-h</td><td>–host</td><td>主机</td></tr><tr><td>-p</td><td>–password</td><td>密码</td></tr><tr><td>-P</td><td>–port</td><td>端口</td></tr><tr><td>-V</td><td>–version</td><td>版本信息</td></tr><tr><td>-u</td><td>–user</td><td>用户</td></tr><tr><td></td><td>–prompt</td><td>修改提示符</td></tr></tbody></table><h3 id="–prompt"><a href="#–prompt" class="headerlink" title="–prompt"></a>–prompt</h3><p>–prompt 支持几个转义词组</p><ul><li>\h 主机名</li><li>\D 完整日期</li><li>\d 当前数据库</li><li>\u 当前用户</li></ul><h2 id="登陆之后"><a href="#登陆之后" class="headerlink" title="登陆之后"></a>登陆之后</h2><h3 id="退出"><a href="#退出" class="headerlink" title="退出"></a>退出</h3><ul><li>exit</li><li>quit</li><li>\q</li></ul><p>都能退出 mysql，系统显示 Bye。</p><h3 id="帮助"><a href="#帮助" class="headerlink" title="帮助"></a>帮助</h3><p>键入<code>help</code>或<code>\h</code>。</p><h3 id="显示信息"><a href="#显示信息" class="headerlink" title="显示信息"></a>显示信息</h3><p>select:</p><ul><li>version(); 版本信息</li><li>now(); 当前时间</li><li>user(); 用户@主机名</li></ul><h3 id="使用系统命令"><a href="#使用系统命令" class="headerlink" title="使用系统命令"></a>使用系统命令</h3><p><strong>!</strong> 后加 shell 命令可以在 mysql 中执行 shell 命令。</p><blockquote><p>gdb 使用 shell 加命令来执行 shell 命令。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 👨‍💻Web开发 </category>
          
          <category> DataBase </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>SQL表查询操作</title>
      <link href="/blog/igxqxi/"/>
      <url>/blog/igxqxi/</url>
      
        <content type="html"><![CDATA[<h2 id="基本词汇"><a href="#基本词汇" class="headerlink" title="基本词汇"></a>基本词汇</h2><blockquote><p>查询就是 SELECT 语句</p></blockquote><pre><code class="sql">SELECT  [ ALL | DISTINCT ]        [ TOP expression [ PERCENT ] [ WITH TIES ] ]    &lt;列名&gt;                                             /*指定要选择的列及其限定*/    [ INTO &lt;表名&gt; ]                             /*INTO子句，指定结果存入新表*/    [ FROM &lt;查询对象&gt; ]                        /*FROM子句，指定表或视图*/    [ WHERE &lt;条件&gt; ]                             /*WHERE子句，指定查询条件*/    [ GROUP BY &lt;分组表达式&gt;]                 /*GROUP BY子句，指定分组表达式*/    [ HAVING &lt;分组统计条件&gt;]                 /*HAVING子句，指定分组统计条件*/    [ ORDER BY &lt;排序表达式&gt; [ ASC | DESC ] ] /*ORDER子句，指定排序表达式和顺序*/</code></pre><blockquote><p>说明：所有被使用的子句必须按语法说明中显示的顺序严格地排序。例如，一个 HAVING 子句必须位于 GROUP BY 子句之后，并位于 ORDER BY 子句之前。<br>SELECT 语句返回一个表的结果集，通常该结果集被称为表值表达式。</p></blockquote><h3 id="distinct"><a href="#distinct" class="headerlink" title="distinct"></a>distinct</h3><p>去掉重复的行</p><h3 id="where"><a href="#where" class="headerlink" title="where"></a>where</h3><blockquote><p>条件</p></blockquote><pre><code class="sql">select distinct Sname        from Student        where Sdept=&#39;CS&#39;</code></pre><h3 id="as"><a href="#as" class="headerlink" title="as"></a>as</h3><pre><code class="sql">SELECT id AS userId，username AS uname    FROM users;</code></pre><p>查询出来的列名，就变成了别名。AS 其实可以省略，但可能会出现问题。</p><pre><code class="sql">SELECT id username  FROM users;</code></pre><p>这样会将 username 视作 id 的别名。</p><h3 id="like"><a href="#like" class="headerlink" title="like"></a>like</h3><pre><code class="sql">SELECT 书名 AS BookName, 作译者 AS Author, 出版社 AS PressFROM TBookWHERE 书名 LIKE &#39;%SQL Server%&#39;</code></pre><pre><code class="sql">select Sname, Sno, Ssex    from Student    where Sname not like &#39;刘_&#39;</code></pre><h3 id="is-not"><a href="#is-not" class="headerlink" title="is not"></a>is not</h3><pre><code class="sql">select Sno, Cno    from SC    where Grade is not null</code></pre><h3 id="and、or"><a href="#and、or" class="headerlink" title="and、or"></a>and、or</h3><pre><code class="sql">select Sname, Ssex    from Student    where Sdept=&#39;CS&#39; or Sdept=&#39;MA&#39; or Sdept=&#39;IS&#39;</code></pre><blockquote><p>键可以不用引号，但是值要引号<br>列名又空格也需要加引号</p></blockquote><h3 id="top"><a href="#top" class="headerlink" title="top"></a>top</h3><blockquote><p>前五行数据</p></blockquote><pre><code class="sql">select top 5 *    from rating</code></pre><h3 id="not-in"><a href="#not-in" class="headerlink" title="not in"></a>not in</h3><pre><code class="sql">select Sname, Ssex    from Student    where Sdept not in (&#39;CS&#39;, &#39;MA&#39;, &#39;IS&#39;)</code></pre><h3 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h3><ul><li>有公共的列，在前面表名以示区分</li><li>指明两个表的公共<strong>相等</strong>的列</li></ul><pre><code class="sql">select TLend.ISBN, TLend.借书时间, TLend.借书证号, TLend.图书ID, TLend.应还时间,TReader.姓名from TReader,TLend, TBookwhere TReader.借书证号 = TLend.借书证号    and TBook.ISBN = TLend.ISBN    and TLend.借书证号 = &#39;081101&#39;    and TBook.书名 = &#39;SQL Server实用教程（第3版）&#39;</code></pre><h3 id="join-on"><a href="#join-on" class="headerlink" title="join on"></a>join on</h3><pre><code class="sql">select 姓名    from TReader join HLend    on TReader.借书证号 = HLend.借书证号    where (还书时间 - 借书时间)&gt;5</code></pre><h3 id="count"><a href="#count" class="headerlink" title="count"></a>count</h3><pre><code class="sql">select count(*) 读者总数    from TReader</code></pre><h3 id="order-by"><a href="#order-by" class="headerlink" title="order by"></a>order by</h3><p>排序 ORDER BY</p><pre><code class="sql">select Sno, Grade    from SC    where Cno=&#39;3&#39;    order by Grade desc</code></pre><pre><code class="sql">SELECT *        FROM users    ORDER BY id DESC;</code></pre><p>可以排序多个字段，如果第一个字段能排出结果，就不会用到第 2 个字段。比如：</p><pre><code class="sql">select *    from Student    order by Sdept asc, Sage desc</code></pre><p>因为年龄 age 有相同的，继续排序就要用到 id 的降序。</p><h3 id="limit"><a href="#limit" class="headerlink" title="limit"></a>limit</h3><p>限制返回记录的数量 LIMIT</p><p>LIMIT 有两种语法结构，第一种比较常见。</p><pre><code class="sql">[LIMIT &#123;[offset,] row_count|row_count OFFSET offset&#125;]</code></pre><p>起始位置，偏移量</p><pre><code class="sql">SELECT * FROM users ;SELECT * FROM users LIMIT 3,2;SELECT * FROM users LIMIT 2;</code></pre><p>3，2：表示从第 3 条开始返回，返回两条记录。注意记录从 0 开始编号，即结果集中的从第 0 条开始。<br>如果 LIMIT 后面只有一个参数，认作是偏移量，起始位置缺省为 0。</p><h3 id="union"><a href="#union" class="headerlink" title="union"></a>union</h3><blockquote><p>合并查询结果 UNION</p></blockquote><p>在多条查询语句之间，使用<code>UNION</code>关键字会合并所有查询结果。<br>默认会去掉重复行，如果不想去掉重复行，请使用<code>UNION ALL</code><br>需要注意的是，要联合的查询结果必须有相同的列数（列名可以不同）</p><blockquote><p>去重效率比不去重效率低</p></blockquote><h2 id="group-by"><a href="#group-by" class="headerlink" title="group by"></a>group by</h2><pre><code class="sql">[GROUP BY &#123;col_name|position&#125; [ASC|DESC],...]</code></pre><pre><code class="sql">select 专业, count(*) 不同专业人数    from TReader    group by 专业</code></pre><h3 id="having"><a href="#having" class="headerlink" title="having"></a>having</h3><p>与 GROUP BY 分组联用。只对部分记录做分组操作。有两种用法，比如：</p><pre><code class="sql">SELECT sex,age    FROM users  GROUP BY sex  HAVING age &gt; 35;SELECT sex    FROM users  GROUP BY sex  HAVING count(id) &gt;=2;</code></pre><ul><li>第一种，注意后面的 HAVING 的字段必须在前面 SELECT 部分出现才行。</li><li>第二种，在 HAVING 后面使用<em>聚合函数</em>，前面无需出现相应字段。</li></ul><h3 id="asc、desc"><a href="#asc、desc" class="headerlink" title="asc、desc"></a>asc、desc</h3><p>排序升序 asc、降序 desc</p><pre><code class="sql">SELECT *    FROM TReader    WHERE 专业=&#39;计算机&#39;    ORDER BY 出生时间 desc</code></pre><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h2><p>子查询（Subquery）是指嵌套在查询内部，且必须始终出现在圆括号内。外面的查询并非只是指的查找。可以包含的关键字或条件：</p><pre><code>DISTINCT、GROUP BY、ORDER BY、LIMIT、函数等</code></pre><p>外层的查询可以是：</p><pre><code>SELECT、INSERT、UPDATE、SET、DO</code></pre><h3 id="①-使用比较运算符的子查询"><a href="#①-使用比较运算符的子查询" class="headerlink" title="① 使用比较运算符的子查询"></a>① 使用比较运算符的子查询</h3><ul><li>比较运算符<blockquote><p>=,&gt;,&lt;,&gt;=,&lt;=,&lt;&gt;,!=,&lt;=&gt;</p></blockquote></li></ul><pre><code class="sql">SELECT *    FROM av  WHERE 身高&gt;=(    SELECT AVG(身高)    FROM av);</code></pre><ul><li>修饰比较运算符<blockquote><p>使用 ANY、SOME、ALL，ANY 和 SOME 是等价的。</p></blockquote></li></ul><table><thead><tr><th></th><th>ANY</th><th>ALL</th></tr></thead><tbody><tr><td>&gt;,&gt;=</td><td>最小值</td><td>最大值</td></tr><tr><td>&lt;,&lt;=</td><td>最大值</td><td>最小值</td></tr><tr><td>=,&lt;=&gt;</td><td>任意值</td><td></td></tr><tr><td>&lt;&gt;,!=</td><td></td><td>任意值</td></tr></tbody></table><pre><code class="sql">select emp.empno,emp.ename,emp.job,emp.sal    from scott.emp  where sal &gt;any(    select sal    from scott.emp    where job=&quot;MANAGER&quot;);</code></pre><p>等价于下边两步的执行过程：<br>（1）执行“select sal from scott.emp where job=”MANAGER””<br>（2）查询到 3 个薪水值 2975、2850 和 2450，父查询执行下列语句：<br>select emp.empno,emp.ename,emp.job,emp.sal from scott.emp where** sal &gt;2975 or sal&gt;2850 or sal&gt;2450;**</p><h3 id="②-使用-not-in-的子查询"><a href="#②-使用-not-in-的子查询" class="headerlink" title="② 使用[not]in 的子查询"></a>② 使用[not]in 的子查询</h3><pre><code>operand comparison_operator [NOT] IN (subquery)</code></pre><p>=ANY 和 IN 等效<br>!=ALL 和 NOT IN 等效</p><h3 id="③-使用-not-exists-的子查询"><a href="#③-使用-not-exists-的子查询" class="headerlink" title="③ 使用[not]exists 的子查询"></a>③ 使用[not]exists 的子查询</h3><p>如果子查询返回任何行，EXISTS 将返回 TRUE，否则返回 FALSE。<br>该类子查询使用较少</p>]]></content>
      
      
      <categories>
          
          <category> 👨‍💻Web开发 </category>
          
          <category> DataBase </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>SQL数据库操作</title>
      <link href="/blog/afuf5u/"/>
      <url>/blog/afuf5u/</url>
      
        <content type="html"><![CDATA[<h2 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h2><pre><code class="sql">CREATE &#123;DATABASE|SCHEMA&#125; [IF NOT EXISTS] db_name [DEFAULT] CHARCTER SET [=] charset_name;</code></pre><blockquote><p>注意设置字符集的时候，utf-8 要写作 utf8。</p></blockquote><h2 id="使用数据库"><a href="#使用数据库" class="headerlink" title="使用数据库"></a>使用数据库</h2><blockquote><p>使用指定数据库</p></blockquote><pre><code class="sql">use DATABASEgo</code></pre><h2 id="修改数据库"><a href="#修改数据库" class="headerlink" title="修改数据库"></a>修改数据库</h2><pre><code class="sql">ALTER &#123;DATABASE|SCHEMA&#125; db_name [DEFAUTL] CHARCTER SET [=] charset_name;</code></pre><h3 id="修改数据库编码格式"><a href="#修改数据库编码格式" class="headerlink" title="修改数据库编码格式"></a>修改数据库编码格式</h3><pre><code>SET NAMES GBK;</code></pre><p>GBK 也可以是其他编码格式。但这只是修改你客户端显示的编码格式。服务端并不变化。<br><strong>修改配置文件来改服务端编码</strong><br>打开/etc/my.cnf 文件<br>在[mysqld]条目下：增加</p><pre><code>character_set_server=utf8init_connect=&#39;SET NAMES utf8&#39;</code></pre><p>有时在数据库创建完成后，编码格式是无法修改的。只能删掉重新建。</p><h2 id="删除数据库"><a href="#删除数据库" class="headerlink" title="删除数据库"></a>删除数据库</h2><pre><code class="mysql">    DROP &#123;DATABASE|SCHEMA&#125; [IF EXISTS] db_name;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 👨‍💻Web开发 </category>
          
          <category> DataBase </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>SQL表基本操作</title>
      <link href="/blog/zqbaxc/"/>
      <url>/blog/zqbaxc/</url>
      
        <content type="html"><![CDATA[<h1 id="表基本操作"><a href="#表基本操作" class="headerlink" title="表基本操作"></a>表基本操作</h1><h2 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h2><pre><code class="sql">Create table student(    Sno char(9),    Same char(20),    Ssex char(2),    Sage smallint,    Sdept char(20));Create table course(    Cno char(4),    Cname char(40),    Cpno char(4),    Ccredit smallint);Create table sc(    Sno char(9),    Cno char(4),    Grade smallint);Insert into student values(&#39;200215121&#39;,&#39;李勇&#39;,&#39;男&#39;,20,&#39;cs&#39;);Insert into student values(&#39;200215122&#39;,&#39;刘晨&#39;,&#39;女&#39;,19,&#39;cs&#39;);Insert into student values(&#39;200215123&#39;,&#39;王敏&#39;,&#39;女&#39;,18,&#39;ma&#39;);Insert into student values(&#39;200515124&#39;,&#39;张立&#39;,&#39;男&#39;,19,&#39;is&#39;);Insert into course values (&#39;1&#39;,&#39;数据库&#39;,&#39;5&#39;,4);Insert into course values (&#39;2&#39;,&#39;数学&#39;,NULL,2);Insert into course values(&#39;3&#39;,&#39;信息系统&#39;,&#39;1&#39;,4);Insert into course values(&#39;4&#39;,&#39;操作系统&#39;,&#39;6&#39;,3);Insert into course values(&#39;5&#39;,&#39;数据结构&#39;,&#39;7&#39;,4);Insert into course values(&#39;6&#39;,&#39;数据处理&#39;,NULL,2);Insert into course values(&#39;7&#39;,&#39;pascal语言&#39;,&#39;6&#39;,4);Insert into sc values(&#39;200215121&#39;,&#39;1&#39;,92);Insert into sc values(&#39;200215121&#39;,&#39;2&#39;,85);Insert into sc values(&#39;200215121&#39;,&#39;3&#39;,88);Insert into sc values(&#39;200215122&#39;,&#39;2&#39;,90);Insert into sc values(&#39;200215122&#39;,&#39;3&#39;,80);</code></pre><h2 id="查看表"><a href="#查看表" class="headerlink" title="查看表"></a>查看表</h2><pre><code class="sql">    SHOW TABLES [FROM db_name] [LIKE &#39;pattern&#39;|WHEAR expr];</code></pre><h2 id="查看列（表的组织结构）"><a href="#查看列（表的组织结构）" class="headerlink" title="查看列（表的组织结构）"></a>查看列（表的组织结构）</h2><pre><code class="sql">    SHOW COLUMNS FROM tb_name;    DESC tb_name;</code></pre><p>以上两条语句都可以。</p><h2 id="查看表的内容"><a href="#查看表的内容" class="headerlink" title="查看表的内容"></a>查看表的内容</h2><pre><code class="sql">    SELECT * FROM tb_name;</code></pre><h2 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h2><pre><code class="sql">    INSERT [INTO] tb_name [(col_name,...)] VALUES(val,...);</code></pre><p>如果不指明任何字段名，那么插入的数据必须要包含所有的字段。</p><h1 id="插入记录"><a href="#插入记录" class="headerlink" title="插入记录"></a>插入记录</h1><p>共有三种 Insert 语句。</p><h2 id="INSERT"><a href="#INSERT" class="headerlink" title="INSERT"></a>INSERT</h2><pre><code class="sql">INSERT [INTO] tb_name [(col_name,.....)] &#123;VALUE|VALUES&#125; (&#123;expr|DEFAULT&#125;,...) (...),...</code></pre><ul><li>values 是标准 SQL 关键字，value 是 MySQL 自己的。</li><li>插入语句可以一次性插入多条记录。</li><li>值可以是：<ul><li>函数</li><li>数学表达式</li><li>等</li></ul></li></ul><p>默认值</p><p>在创建数据表的时候可以设置 DEFAUTL。</p><pre><code class="sql">CREATE TABLE users(    id SAMLLINT UNSIGNED PRIMARY KEY AUTO_INCREMENT,    username SAMLLINT VARCHAR(20) NOT NULL,    password SAMLLINT VARCHAR(20) NOT NULL,    age TINYINT UNSIGNED NOT NULL DEFAULT 10,    sex BOOLEAN);</code></pre><p>INSERT 的时候如果为自动编号的字段（比如上表中主键 id）赋值的话，可写作 NULL，或 DEFAULT 就会采用默认值。<br>如果字段设置了 DEFAULT（比如上表中 age），那么值直接写 DEFAULT 就行，注意此时，不能为 NULL。例如：</p><pre><code class="sql">INSERT users VALUES(NULL,&#39;TOM&#39;,&#39;123&#39;,DEFAULT,1);</code></pre><h2 id="INSERT…SET"><a href="#INSERT…SET" class="headerlink" title="INSERT…SET"></a>INSERT…SET</h2><pre><code class="sql">INSERT [INTO] tb_name SET col_name=&#123;expr|DEFAULT&#125;,...</code></pre><p>采用了<a href="%E5%AD%90%E6%9F%A5%E8%AF%A2.md">子查询</a>。例如，上表中插入：</p><pre><code class="sql">INSERT users SET username=&#39;Ben&#39;,password=&#39;456&#39;;</code></pre><p>因为 id，和 age 都有默认值，所以可以不写。而 sex 允许为空，也可以不写。</p><h2 id="INSERT…SELECT"><a href="#INSERT…SELECT" class="headerlink" title="INSERT…SELECT*"></a>INSERT…SELECT*</h2><p>将查找的结果写入记录中。</p><pre><code class="sql">INSERT test(username) SELECT username FROM users WHERE age &gt;=30;</code></pre><h1 id="删除记录"><a href="#删除记录" class="headerlink" title="删除记录"></a>删除记录</h1><p>同样分为：</p><ul><li>单表删除</li><li>多表删除</li></ul><pre><code class="mysql">DELETE FROM tb_name [WHERE where_condition];</code></pre><p>没有 where 部分则会删除全部记录。</p><h1 id="更新记录-单表更新"><a href="#更新记录-单表更新" class="headerlink" title="更新记录-单表更新"></a>更新记录-单表更新</h1><p>更新记录分为：</p><ul><li>单表更新</li><li>多表更新（要涉及连接）</li></ul><blockquote><p>单表更新</p></blockquote><pre><code class="mysql">UPDATE [LOW_PRIORITY] [IGNORE] tb_referenceSET col_name1=&#123;expr|DEFAULT&#125; [,col_name2=&#123;expr|DEFAULT&#125;]...[WHERE where_condition]</code></pre><p>不写 where 会更新全部的记录。</p><h1 id="更新记录-连接（多表更新）"><a href="#更新记录-连接（多表更新）" class="headerlink" title="更新记录-连接（多表更新）"></a>更新记录-连接（多表更新）</h1><h2 id="多表更新"><a href="#多表更新" class="headerlink" title="多表更新"></a>多表更新</h2><pre><code class="mysql">UPDATE table_referencesSET col_name1=&#123;expr1|DEFAULT&#125;[,col_name2=&#123;expr2|DEFAULT&#125;]...[WHERE where_condition]</code></pre><h2 id="CREATE…SELECT"><a href="#CREATE…SELECT" class="headerlink" title="CREATE…SELECT"></a>CREATE…SELECT</h2><p>创建数据表同时将查询结果写入到数据表</p><pre><code class="mysql">CREATE TABLE [IF NOT EXISTS]tb_name[(create_definetion,...)]select_statement</code></pre><p>比如：</p><pre><code class="mysql">CREATE TABLE tall (    tall_id SMALLINT UNSIGNED PRIMARY KEY AUTO_INCREMENT,    num INT) SELECT 身高 AS num FROM    avGROUP BY 身高;</code></pre><p>创建新表 tall，并从 av 表中选取身高字段插入到 tall 表的 num 字段。</p><h2 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h2><h3 id="语法结构"><a href="#语法结构" class="headerlink" title="语法结构"></a>语法结构</h3><pre><code class="mysql">table_reference&#123;[INNER|CROSS] JOIN|&#123;LELT|RIGHT&#125;[OUTER] JOIN&#125;table_referenceON conditional_expr</code></pre><p>ON 为条件。<br>三种连接，即：</p><ul><li>内连接</li><li>左外连接</li><li>右外连接</li></ul><h4 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h4><p>显示左表及右表符合连接条件的记录（交集）</p><h4 id="左外连接"><a href="#左外连接" class="headerlink" title="左外连接"></a>左外连接</h4><p>显示左表的全部记录及右表符合连接条件的记录</p><h4 id="右外连接"><a href="#右外连接" class="headerlink" title="右外连接"></a>右外连接</h4><p>类别左外连接</p><h3 id="UPDATE-JOIN-SET"><a href="#UPDATE-JOIN-SET" class="headerlink" title="UPDATE..JOIN..SET"></a>UPDATE..JOIN..SET</h3><p>比如</p><pre><code class="mysql">UPDATE actor AS a        INNER JOIN    tall AS b ON a.tall = b.numSET    a.tall = b.tall_id;</code></pre><p>依据实际情况，选择是否使用别名。（如果两个表中进行比较的字段名相同，则需要别名）<br>该语句完成了一个替换，将 actor 表中具体的身高数值，替换为 tall 表中身高的对应 id。</p><h1 id="修改数据表"><a href="#修改数据表" class="headerlink" title="修改数据表"></a>修改数据表</h1><p>所有的数据表的修改 SQL 语句的开头都是 ALTER TABLE+表名称。</p><h2 id="给表改名"><a href="#给表改名" class="headerlink" title="给表改名"></a>给表改名</h2><pre><code class="sql">ALTER TABLE tb_name RENAME &#123;TO|AS&#125; tb_new_name;</code></pre><p>另外有个写法是：</p><pre><code class="sql">RENAME TABLE tb_name TO tb_new_name;</code></pre><p>这句可以批量修改多个表的名称。</p><blockquote><p>尽量不要随意修改表的名称。对视图有影响。</p></blockquote><h2 id="添加-删除列"><a href="#添加-删除列" class="headerlink" title="添加/删除列"></a>添加/删除列</h2><h3 id="插入列"><a href="#插入列" class="headerlink" title="插入列"></a>插入列</h3><pre><code class="sql">ALTER TABLE tb_name ADD [COLUMN] col_name column_definition [FIRST|AFTER col_name];</code></pre><p>默认会插入到表的最下面，指定 FIRST，则置于最上面，或者用<code>AFTER col_name</code> 指定为<code>col_name</code>的下面。</p><h3 id="删除列"><a href="#删除列" class="headerlink" title="删除列"></a>删除列</h3><pre><code class="sql">ALTER TABLE tb_name DROP col_name,DROP.....;</code></pre><p>可以一次性删除多个列。</p><h2 id="修改列"><a href="#修改列" class="headerlink" title="修改列"></a>修改列</h2><h3 id="修改列定义"><a href="#修改列定义" class="headerlink" title="修改列定义"></a>修改列定义</h3><p>即修改列的属性。</p><pre><code class="sql">ALTER TABLE tb_name MODIFY col_name column_definition [FIRST|AFTER col_name];</code></pre><p>比如：</p><pre><code class="sql">ALTER TABLE test ADD id SMALLINT unsigned KEY auto_increment first;</code></pre><p>key 可以表示主键，无需 primary。fitrst 表示插入的位置。</p><blockquote><p>如果要修改的列已经是<code>主键</code>了，则修改列定义的时候再加上<code>主键</code>字段会报错。</p></blockquote><h3 id="修改列名"><a href="#修改列名" class="headerlink" title="修改列名"></a>修改列名</h3><pre><code class="sql">ALTER TABLE tb_name CHANGE col_name col_new_name column_definition [FIRST|AFTER col_name];</code></pre><p>修改列名时，新列名后面要指明数据类型。</p><h3 id="修改列顺序"><a href="#修改列顺序" class="headerlink" title="修改列顺序"></a>修改列顺序</h3><p>其实同上，具体比如：</p><pre><code class="sql">ALTER TABLE `user` CHANGE `join_time` `join_time` DATE NULL DEFAULT NULL AFTER `role`;</code></pre><p>把 join_time 列放到 role 列后面。</p><h2 id="修改约束"><a href="#修改约束" class="headerlink" title="修改约束"></a>修改约束</h2><h3 id="PRIMARY-KEY"><a href="#PRIMARY-KEY" class="headerlink" title="PRIMARY KEY"></a>PRIMARY KEY</h3><p>添加主键约束</p><pre><code class="sql">ALTER TABLE tb_name ADD [CONSTRAIN[symbol]] PRIMARY KEY [index.type] (index_col_name,.....);</code></pre><p>删除主键约束</p><pre><code class="sql">ALTER TABLE tb_name DROP [index.type] PRIMARY KEY;</code></pre><p>不需要指定列名，因为每个表只有一个主键。<br>注意！只有一个主键并不意味着主键只有一列。</p><h3 id="UNIQUE"><a href="#UNIQUE" class="headerlink" title="UNIQUE"></a>UNIQUE</h3><p>添加唯一约束</p><pre><code class="sql">ALTER TABLE tb_name ADD [index.type] unique(col_name);</code></pre><p>删除唯一约束</p><pre><code class="sql">ALTER TABLE tb_name DROP [index.type] unique(col_name);</code></pre><h3 id="DEFAULT"><a href="#DEFAULT" class="headerlink" title="DEFAULT"></a>DEFAULT</h3><pre><code class="sql">ALTER TABLE tb_name ALTER [COLUMN] col_name &#123;SET DEFAULT literal|DROP DEFAULT&#125;;for example:ALTER TABLE users ALTER age SET DEFAULT 20;</code></pre><h3 id="FOREIGN-KEY"><a href="#FOREIGN-KEY" class="headerlink" title="FOREIGN KEY"></a>FOREIGN KEY</h3><p>添加外键约束</p><pre><code class="sql">ALTER TABLE tb_name ADD [CONSTRAIN[symbol]] FOREIGN KEY [index_name](index_col_name,...)reference_definition;for example:ALTER TABLE users add FOREIGN KEY (pid) REFERENCE provinces (id);</code></pre><p>删除外键约束</p><pre><code class="sql">ALTER TABLE tb_name DROP FOREIGN KEY fk_symbol;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 👨‍💻Web开发 </category>
          
          <category> DataBase </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>0-1背包问题</title>
      <link href="/blog/kb5sse/"/>
      <url>/blog/kb5sse/</url>
      
        <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><h3 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h3><p>给定一组已知重量和价值的物品和一个容量已知的背包，求解在不超过背包容量情况下，选用那些物品放入背包，使得所选用的所有物品价值最大化。</p><table><thead><tr><th>物品总数 N</th><th>4</th></tr></thead><tbody><tr><td>背包容量 M</td><td>8</td></tr><tr><td>每个物品重量 wi</td><td>{5, 4, 3, 2}</td></tr><tr><td>每个物品价值 vi</td><td>{15, 10, 6, 2}</td></tr></tbody></table><h3 id="问题的判定性说法"><a href="#问题的判定性说法" class="headerlink" title="问题的判定性说法"></a>问题的判定性说法</h3><h3 id=""><a href="#" class="headerlink" title=""></a><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1600597489691-e0d838af-003e-404e-8a40-5145d2fefbad.png#crop=0&crop=0&crop=1&crop=1&height=108&id=jAqDv&margin=%5Bobject%20Object%5D&name=image.png&originHeight=216&originWidth=969&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=73465&status=done&style=shadow&title=&width=484.5" alt="image.png"></h3><h3 id="问题的形式化定义"><a href="#问题的形式化定义" class="headerlink" title="问题的形式化定义"></a>问题的形式化定义</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1600597354257-45eba2b3-641c-433a-8732-9b6c11a16061.png#crop=0&crop=0&crop=1&crop=1&height=281&id=PlZXH&margin=%5Bobject%20Object%5D&name=image.png&originHeight=561&originWidth=1065&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=184609&status=done&style=shadow&title=&width=532.5" alt="image.png"></p><h2 id="问题思路"><a href="#问题思路" class="headerlink" title="问题思路"></a>问题思路</h2><h3 id="动态规划思路"><a href="#动态规划思路" class="headerlink" title="动态规划思路"></a>动态规划思路</h3><p><strong>动态规划</strong>解决该问题，类似于<strong>莱文斯坦距离</strong>的解法类似。利用 CAAIS 数据来说明这个问题的解决思想。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1603943092299-49a0bc97-f2cf-4258-8dde-022b4aae06d1.png#crop=0&crop=0&crop=1&crop=1&height=154&id=bAWry&margin=%5Bobject%20Object%5D&name=image.png&originHeight=307&originWidth=842&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=44700&status=done&style=shadow&title=&width=421" alt="image.png"><br><strong>动态规划 DP 方程构造</strong><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1603943375703-889cea96-f3a0-41df-b806-386dca8bcc82.png#crop=0&crop=0&crop=1&crop=1&height=112&id=FlFHG&margin=%5Bobject%20Object%5D&name=image.png&originHeight=223&originWidth=1020&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=23862&status=done&style=shadow&title=&width=510" alt="image.png"><br><strong>PS：V[i,j]表示在前 i 件物品中选择若干件放在承重为 j 的背包中，可以取得的最大价值</strong></p><p>（整张表格是从上往下，从左往右地填）<br>举例说明表格中的数值填法，<strong>倒数第二行倒数第四列的 16 4</strong>的填法：</p><ul><li>首先不满足 DP 方程的第一种和第二种情况</li><li>所以代入取最大值 max 函数<ul><li>V（i-1，j）：不选本物品（3，6），还是用之前的值，继承上面的第一个物品和第二个物品，DP 值为 15 U</li><li>V（i-1，j）+vi：用该容量（7）-所选物品的重量为 4，然后再查容量为 4 的时候 DP 值为 10，然后求出该情况 DP 是，10 加上该物品的价值，所以该情况下的 DP 值为 16，右上标为 4（CAAIS），值来源于前面容量为 4 的情况。</li></ul></li></ul><hr><p><strong>格子如上方式填就好了！</strong></p><h3 id="递归思路"><a href="#递归思路" class="headerlink" title="递归思路"></a>递归思路</h3><p>第二节课将递归的时候，也讲了这个问题的递归思路。不过复杂度记得是指数级的，暂时不写了~~</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="动态规划-Code"><a href="#动态规划-Code" class="headerlink" title="动态规划 Code"></a>动态规划 Code</h3><pre><code class="cpp">#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;namespace NS_DP0_1Knapsack &#123;int DP0_1Knapsack(int n, int W, int *w, int *v);void Output(int n, int W, int *w, int *v, int OptV);static vector&lt;vector&lt;int&gt;&gt; V;static vector&lt;int&gt; x;void DP0_1KnapsackCaller(int n, int W, int *w, int *v)&#123;    V.clear();    V.resize(n + 1, vector&lt;int&gt;(W + 1, 0));    x.resize(n + 1);    int OptV = DP0_1Knapsack(n, W, w, v);    Output(n, W, w, v, OptV);&#125;int DP0_1Knapsack(int n, int W, int *w, int *v)&#123;    for (int i = 1; i &lt;= n; i++)        for (int j = 1; j &lt;= W; j++)            if (j &lt; w[i - 1])                V[i][j] = V[i - 1][j];            else if (V[i - 1][j] &gt;=                V[i - 1][j - w[i - 1]] + v[i - 1])                V[i][j] = V[i - 1][j];            else                V[i][j] = V[i - 1][j - w[i - 1]] + v[i - 1];    int j = W;    for (int i = n; i &gt; 0; i--)        if (V[i][j] == V[i - 1][j])            x[i] = 0;        else        &#123;   x[i] = 1; j -= w[i - 1];  &#125;    return V[n][W];&#125;void Output(int n, int W, int *w, int *v, int OptV)&#123;    //inputs    printf(&quot;DP to solve 0-1 knapsack:\n&quot;);    printf(&quot;%d items with knapsack capacity %d.\n&quot;, n , W);    printf(&quot;%-6s: &quot;, &quot;Weight&quot;);    for (int i = 0; i &lt; n; i++)        printf(&quot;%3d&quot;, w[i]);    printf(&quot;\n&quot;);    printf(&quot;%-6s: &quot;, &quot;Value&quot;);    for (int i = 0; i &lt; n; i++)        printf(&quot;%3d&quot;, v[i]);    printf(&quot;\n&quot;);    //the value matrix    printf(&quot;\nThe value matrix:\n&quot;);    printf(&quot;  &quot;);    for (int j = 0; j &lt;= W; j++)        printf(&quot;%3d&quot;, j);    printf(&quot;\n&quot;);    for (int i = 0; i &lt;= n; i++)    &#123;        printf(&quot;%2d&quot;, i);        for (int j = 0; j &lt;= W; j++)            printf(&quot;%3d&quot;, V[i][j]);        printf(&quot;\n&quot;);    &#125;    //solution    printf(&quot;\nThe optimal value: %d\n&quot;, OptV);    printf(&quot;The optimal solution:\n&quot;);    for (int i = 1; i &lt;= n; i++)        printf(&quot;%2d&quot;, x[i]);    printf(&quot;\n\n&quot;);&#125;&#125; //namespace NS_DP0_1Knapsackusing namespace NS_DP0_1Knapsack;int main()&#123;    // 物品个数    vector&lt;int&gt; N = &#123; 4,  10&#125;;    // 背包容量    vector&lt;int&gt; W = &#123; 8,  100&#125;;    // 各物品重量    vector&lt;vector&lt;int&gt;&gt; w = &#123;        &#123; 5, 4, 3, 2 &#125;,        &#123; 4, 3, 7, 2, 9, 3, 1, 7, 2, 5 &#125;    &#125;;    // 各物品价值    vector&lt;vector&lt;int&gt;&gt; v = &#123;        &#123; 15, 10, 6, 2 &#125;,        &#123; 15, 10, 6, 2, 23, 12, 33, 7, 22, 10 &#125;    &#125;;    int m = N.size();    for (int i = 0; i &lt; m; i++)    &#123;        DP0_1KnapsackCaller(N[i], W[i], &amp;w[i][0], &amp;v[i][0]);    &#125;    return 0;&#125;</code></pre><h3 id="动态规划-Result"><a href="#动态规划-Result" class="headerlink" title="动态规划 Result"></a>动态规划 Result</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1603943258085-fac4811f-87e7-4eef-8194-ee47d88063a6.png#crop=0&crop=0&crop=1&crop=1&height=379&id=zluPB&margin=%5Bobject%20Object%5D&name=image.png&originHeight=757&originWidth=1920&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=74181&status=done&style=shadow&title=&width=960" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1603943276039-f6f74edf-4871-426d-8af8-e1a62edaf071.png#crop=0&crop=0&crop=1&crop=1&height=276&id=nfyc3&margin=%5Bobject%20Object%5D&name=image.png&originHeight=552&originWidth=1920&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=66929&status=done&style=shadow&title=&width=960" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1603943291836-84a15101-d6e7-4c9f-91b5-1122afd7ac5c.png#crop=0&crop=0&crop=1&crop=1&height=177&id=FpXM4&margin=%5Bobject%20Object%5D&name=image.png&originHeight=353&originWidth=1920&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=29292&status=done&style=shadow&title=&width=960" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 🔢动态规划算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>TSP问题</title>
      <link href="/blog/bkbll1/"/>
      <url>/blog/bkbll1/</url>
      
        <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>假设有 n 个城市，各个城市与城市间的距离也已知，有一位旅行商需要途径所有的这 n 个城市，且每个城市只能且必须经过以此，求出一条路线，使得旅行商所走过的路程最短</p><h2 id="问题思路"><a href="#问题思路" class="headerlink" title="问题思路"></a>问题思路</h2><h2 id="代码思路"><a href="#代码思路" class="headerlink" title="代码思路"></a>代码思路</h2><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://jerkwin.github.io/2016/03/17/%E6%97%85%E8%A1%8C%E6%8E%A8%E9%94%80%E5%95%86%E9%97%AE%E9%A2%98TSP%E7%9A%84%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E8%A7%A3%E6%B3%95/">旅行推销商问题 TSP 的动态规划解法</a></li><li><a href="https://blog.csdn.net/joekwok/article/details/4749713">TSP(旅行者问题)——动态规划详解</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 🔢动态规划算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>TODO: 46. 全排列🔖递归</title>
      <link href="/blog/kgaymi/"/>
      <url>/blog/kgaymi/</url>
      
        <content type="html"><![CDATA[<ul><li><a href="https://leetcode-cn.com/problems/permutations/">https://leetcode-cn.com/problems/permutations/</a></li><li><a href="https://leetcode-cn.com/problems/permutations-ii/">https://leetcode-cn.com/problems/permutations-ii/</a></li></ul><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>给定 n 个有序元素的集合，列出其可能出现的排列。</p><h2 id="问题思路"><a href="#问题思路" class="headerlink" title="问题思路"></a>问题思路</h2><h2 id="代码思路"><a href="#代码思路" class="headerlink" title="代码思路"></a>代码思路</h2><ul><li>利用动态数组数据结构</li></ul><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><pre><code class="java">package com.wztlink1013.al._递归法_;import java.util.ArrayList;/** * 全排列问题 * */public class Permuting &#123;    static ArrayList&lt;Integer&gt; x  = new ArrayList&lt;Integer&gt;();    static int N;    static int cnt = 0;    static int t;    public static void main(String args[]) &#123;        int n = 10;        Times.test(&quot;当n = &quot; + n + &quot;时候的耗费时间&quot;, new Times.Task() &#123;            public void execute() &#123;                PermutingCaller(n);            &#125;        &#125;);    &#125;    private static void PermutingCaller(int n) &#123;        N = n;        for (int i = 0; i &lt; n; ++i)            x.add(i + 1);        Permuting(0);    &#125;    private static void Permuting(int i) &#123;        if (i &lt; N - 1) &#123;            for (int j = i; j &lt; N; j++) &#123;                t = x.get(i);                x.set(i, x.get(j));                x.set(j, t);                Permuting(i + 1);                t = x.get(i);                x.set(i, x.get(j));                x.set(j, t);            &#125;        &#125;        else            OutputOnePermutation();    &#125;    private static void OutputOnePermutation()    &#123;        System.out.print(++cnt + &quot; : &quot;);        for (int x : x)            System.out.print(x + &quot; &quot;);        System.out.println();    &#125;&#125;</code></pre><blockquote><p>n:10</p></blockquote><blockquote><p>n</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 🌌递归算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>线性搜索</title>
      <link href="/blog/ete0k7/"/>
      <url>/blog/ete0k7/</url>
      
        <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1599481660030-a834223b-30e4-4a9e-a290-243f028112f2.png#align=left&display=inline&height=325&margin=%5Bobject%20Object%5D&name=image.png&originHeight=650&originWidth=1040&size=166464&status=done&style=shadow&width=520" alt="image.png"></p><h2 id="问题思路"><a href="#问题思路" class="headerlink" title="问题思路"></a>问题思路</h2><h2 id="代码思路"><a href="#代码思路" class="headerlink" title="代码思路"></a>代码思路</h2><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 穷举算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>穷举算法+百元买百兔、素性测试、洗牌问题</title>
      <link href="/blog/czgm7d/"/>
      <url>/blog/czgm7d/</url>
      
        <content type="html"><![CDATA[<h2 id="穷举思想"><a href="#穷举思想" class="headerlink" title="穷举思想"></a>穷举思想</h2><p>穷举法就是针对问题可能出现的结果，对其逐个进行测验并得出是否为符合要求的结果，穷举法也是许多高级算法中的某个部分。<strong>有点像高中数学里面的对问题进行分类讨论</strong>的过程中，寻找所有的情况的异曲同工之处。</p><h3 id="两部分组成"><a href="#两部分组成" class="headerlink" title="两部分组成"></a>两部分组成</h3><ol><li>系统化地枚举问题各种可能的候选解</li><li>检查验证每一个候选解是否满足问题的求解要求</li></ol><h3 id="穷举的抽象算法伪代码"><a href="#穷举的抽象算法伪代码" class="headerlink" title="穷举的抽象算法伪代码"></a>穷举的抽象算法伪代码</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1599469820927-b990d8a2-9025-4f33-becb-46a03890bf07.png#align=left&display=inline&height=323&margin=%5Bobject%20Object%5D&name=image.png&originHeight=645&originWidth=1097&size=223732&status=done&style=stroke&width=548.5" alt="image.png"></p><h2 id="百元买百兔问题"><a href="#百元买百兔问题" class="headerlink" title="百元买百兔问题"></a>百元买百兔问题</h2><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1621393290050-0aa37db7-c08b-407b-8088-c4ede29b80b5.png#align=left&display=inline&height=392&margin=%5Bobject%20Object%5D&name=image.png&originHeight=784&originWidth=1119&size=232684&status=done&style=stroke&width=559.5" alt="image.png"></p><h2 id="洗牌问题"><a href="#洗牌问题" class="headerlink" title="洗牌问题"></a>洗牌问题</h2><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1599475674143-ee86ef49-1b68-4940-baef-e556f225e43d.png#align=left&display=inline&height=297&margin=%5Bobject%20Object%5D&name=image.png&originHeight=594&originWidth=1056&size=159618&status=done&style=stroke&width=528" alt="image.png"></p><h3 id="问题思路"><a href="#问题思路" class="headerlink" title="问题思路"></a>问题思路</h3><ul><li>在 1~n-1 当中随机选择一个数 k1，将其与第 n 个数互换；</li><li>在 1~n-2 当中随机选择一个属 k2，将其与第 n-1 个数互换；</li><li>在第 i 轮之后，1~n-**(i-1)<strong>当中选择一个数 ki，将其与第 n-</strong>(i-1)**个数互换；</li></ul><h3 id="代码思路"><a href="#代码思路" class="headerlink" title="代码思路"></a>代码思路</h3><ul><li>在区间之间随机数的生成</li><li>交换函数</li><li>泛型：支持各种类型数据的“洗牌”</li></ul>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 穷举算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>TODO: 78. 子集🔖递归</title>
      <link href="/blog/mz8hpp/"/>
      <url>/blog/mz8hpp/</url>
      
        <content type="html"><![CDATA[<ul><li><a href="https://leetcode-cn.com/problems/subsets/">https://leetcode-cn.com/problems/subsets/</a></li></ul><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>给定一个正整数 n，生成集合 {1,2,3,…n} 的所有子集</p><h2 id="问题思路"><a href="#问题思路" class="headerlink" title="问题思路"></a>问题思路</h2><blockquote><p>思路一：二进制法</p></blockquote><p>利用<strong>二进制</strong>“<strong>是否显现”</strong>的转换思路来解决这个问题，一个数字在子集当中就标记为 1 反之标记为 0，就比如 <code>n=3</code> ，输出： <code>&#123;&#125;&#123;1,0,0&#125;&#123;0,1,0&#125;&#123;0,0,1&#125;&#123;1,1,0&#125;&#123;1,0,1&#125;&#123;0,1,1&#125;&#123;1,1,1&#125;</code></p><h2 id="代码思路"><a href="#代码思路" class="headerlink" title="代码思路"></a>代码思路</h2><blockquote><p>思路一：利用动态数组数据结构</p></blockquote><p>输入的 n 就是动态数组的初始大小<br>然后依次利用“吞进来”和“吐出去”尾元素来实现</p><h2 id="java-代码实现"><a href="#java-代码实现" class="headerlink" title="java 代码实现"></a>java 代码实现</h2><pre><code class="java">package com.wztlink1013.al._递归法_;/* * 作用：测量代码运行时间 */import java.text.SimpleDateFormat;import java.util.Date;public class Times &#123;    private static final SimpleDateFormat fmt = new SimpleDateFormat(&quot;HH:mm:ss.SSS&quot;);    public interface Task &#123;        void execute();    &#125;    public static void test(String title, Task task) &#123;        if (task == null) return;        title = (title == null) ? &quot;&quot; : (&quot;【&quot; + title + &quot;】&quot;);        System.out.println(title);        System.out.println(&quot;开始：&quot; + fmt.format(new Date()));        long begin = System.currentTimeMillis();        task.execute();        long end = System.currentTimeMillis();        System.out.println(&quot;结束：&quot; + fmt.format(new Date()));        double delta = (end - begin) / 1000.0;        System.out.println(&quot;耗时：&quot; + delta + &quot;秒&quot;);        System.out.println(&quot;-------------------------------------&quot;);    &#125;&#125;</code></pre><pre><code class="java">package com.wztlink1013.al._递归法_;import java.util.ArrayList;/** * 子集问题 */public class SubSetting &#123;    static ArrayList&lt;Integer&gt; x  = new ArrayList&lt;Integer&gt;();    static int cnt = 0;    public static void main(String args[]) &#123;        int n = 4;        Times.test(&quot;当n = &quot; + n + &quot;时候的耗费时间&quot;, new Times.Task() &#123;            public void execute() &#123;                Subsetting(n);            &#125;        &#125;);    &#125;    private static void Subsetting(int n) &#123;        if (n &gt; 0) &#123;            x.add(0);            Subsetting(n - 1);            x.remove(x.size() - 1);            x.add(1);            Subsetting(n - 1);            x.remove(x.size() - 1);        &#125;else &#123;            OutputOneSubsetBinary();            OutputOneSubset();            System.out.print(&quot;\n&quot;);        &#125;    &#125;    private static void OutputOneSubset() &#123;        System.out.printf(&quot;; &#123;&quot;);        int k = 0;        for (int i = x.size() - 1; i &gt;=0; i--) &#123;            if (x.get(i) == 1) &#123;                if (k &gt; 0)                    System.out.printf(&quot;,&quot;);                System.out.printf(&quot;%d&quot;, x.size() - i);                k++;            &#125;        &#125;        System.out.printf(&quot;&#125;&quot;);    &#125;    private static void OutputOneSubsetBinary() &#123;        System.out.printf(&quot;%010d: &quot;, ++cnt);        for (int i = x.size() - 1; i &gt;= 0; i--)            System.out.printf(&quot;%d&quot;, x.get(i));    &#125;&#125;</code></pre><p>运行结果：</p><blockquote><p>n：18（分钟）</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1600319992252-d49865a4-9a9d-4c65-88c8-ea72f140bf85.png#crop=0&crop=0&crop=1&crop=1&height=219&id=fUSjb&margin=%5Bobject%20Object%5D&name=image.png&originHeight=438&originWidth=1920&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=146634&status=done&style=none&title=&width=960" alt="image.png"></p><blockquote><p>n：19（分钟）</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1600320121635-ea76638e-a4c2-4686-a017-0d97088dc417.png#crop=0&crop=0&crop=1&crop=1&height=190&id=vPsbY&margin=%5Bobject%20Object%5D&name=image.png&originHeight=380&originWidth=1920&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=140804&status=done&style=none&title=&width=960" alt="image.png"></p><blockquote><p>n：20（分钟）</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1600320284010-b885d1eb-01da-40d9-a098-f5d84744d847.png#crop=0&crop=0&crop=1&crop=1&height=196&id=ulpx3&margin=%5Bobject%20Object%5D&name=image.png&originHeight=392&originWidth=1920&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=144176&status=done&style=none&title=&width=960" alt="image.png"></p><blockquote><p>n：21（分钟）</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1600320620721-cf61057d-1eac-48d3-b724-36d0d21c4d1e.png#crop=0&crop=0&crop=1&crop=1&height=160&id=oFf1t&margin=%5Bobject%20Object%5D&name=image.png&originHeight=319&originWidth=1920&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=129722&status=done&style=none&title=&width=960" alt="image.png"></p><blockquote><p>n：22（分钟）</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1600321218265-60888e51-2006-4dd7-bbe0-60b336895b8c.png#crop=0&crop=0&crop=1&crop=1&height=173&id=Gkj9x&margin=%5Bobject%20Object%5D&name=image.png&originHeight=345&originWidth=1920&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=131717&status=done&style=none&title=&width=960" alt="image.png"></p><blockquote><p>n：23（分钟）</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1600329834700-9cb11fdc-fec8-463d-934a-b140b45cc0ae.png#crop=0&crop=0&crop=1&crop=1&height=193&id=FPV45&margin=%5Bobject%20Object%5D&name=image.png&originHeight=386&originWidth=1920&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=146130&status=done&style=none&title=&width=960" alt="image.png"></p><blockquote><p>网上查的代码！</p></blockquote><pre><code class="java">class Main&#123;    static void printSubsets(String[] set)    &#123;        int n = set.length;        for (int i = 0; i &lt; (1&lt;&lt;n); i++)        &#123;            System.out.print(&quot;&#123; &quot;);            for (int j = 0; j &lt; n; j++)                if ((i &amp; (1 &lt;&lt; j)) &gt; 0)                    System.out.print(set[j] + &quot; &quot;);            System.out.println(&quot;&#125;&quot;);        &#125;    &#125;    public static void main(String[] args)    &#123;        String[] set = &#123;&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;,                        &quot;5&quot;, &quot;6&quot;, &quot;7&quot;, &quot;8&quot;&#125;;        printSubsets(set);    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 🌌递归算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>常用类</title>
      <link href="/blog/rnsz9o/"/>
      <url>/blog/rnsz9o/</url>
      
        <content type="html"><![CDATA[<h2 id="java-util-Date"><a href="#java-util-Date" class="headerlink" title="java.util.Date"></a>java.util.Date</h2><pre><code class="java">java.util.Date date = new java.util.Date();System.out.println(date.toString());</code></pre><pre><code>Sun Mar 09 13:50:19 EST 2020</code></pre><h2 id="java-util-Random"><a href="#java-util-Random" class="headerlink" title="java.util.Random"></a>java.util.Random</h2><blockquote><p>Math.Random()：Math 类里面的随机数函数，范围是 0.0 到 0.1</p></blockquote><blockquote><p>java.util.Random</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1600085762621-35c72adc-6c6e-4ab2-ac8b-d76d50e570e5.png#align=left&display=inline&height=176&margin=%5Bobject%20Object%5D&name=image.png&originHeight=352&originWidth=899&size=45653&status=done&style=shadow&width=449.5" alt="image.png"></p><h2 id="javafx-geometry-Point2D"><a href="#javafx-geometry-Point2D" class="headerlink" title="javafx.geometry.Point2D"></a>javafx.geometry.Point2D</h2><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1600086091697-6fa8f4e4-137d-490a-8fe0-3546693a1f86.png#align=left&display=inline&height=103&margin=%5Bobject%20Object%5D&name=image.png&originHeight=206&originWidth=960&size=115357&status=done&style=shadow&width=480" alt="image.png"></p><pre><code class="java">import java.util.Scanner;import javafx.geometry.Point2D;public class TestPoint2D &#123;public static void main(String[] args)&#123;    Scanner input= new Scanner(System.in);    System.out.println(&quot;Enter point1&#39;s x-,y-coordinates:&quot;);    double x1=input.nextDouble();    double y1=input.nextDouble();    System.out.println(&quot;Enter point2&#39;s x-,y-coordinates:&quot;);    double x2=input.nextDouble();    double y2=input.nextDouble();    Point2D p1 =new Point2D(x1,y1);    Point2D p2 =new Point2D(x2,y2);    System.out.println(&quot;p1 is&quot;+p1.toString());    System.out.println(&quot;p2 is&quot;+p2.toString());    System.out.println(&quot;distance is&quot;+p1.distance(p2));    &#125;&#125;</code></pre><pre><code>Enter point1&#39;s x-,y-coordinates:1 2Enter point2&#39;s x-,y-coordinates:3 4p1 isPoint2D [x = 1.0, y = 2.0]p2 isPoint2D [x = 3.0, y = 4.0]distance is2.8284271247461903</code></pre><h2 id="String-和-StringBuilder-和-StringBuffer"><a href="#String-和-StringBuilder-和-StringBuffer" class="headerlink" title="String 和 StringBuilder 和 StringBuffer"></a>String 和 StringBuilder 和 StringBuffer</h2><h2 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h2><h3 id="toString-方法"><a href="#toString-方法" class="headerlink" title="toString()方法"></a>toString()方法</h3><h3 id="equals-方法"><a href="#equals-方法" class="headerlink" title="equals()方法"></a>equals()方法</h3><blockquote><p>默认实现的方法</p></blockquote><pre><code class="java">public boolean equals(Object obj) &#123;    return (this == obj);&#125;</code></pre><blockquote><p>重写例子</p></blockquote><pre><code class="java">public boolean equals(Object obj) &#123;    if (o instanceof Circe)        return radius == ((Circle)o).radius;    else        return this == o;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 非前端编程语言 </category>
          
          <category> JAVA </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>206.反转链表🔖链表</title>
      <link href="/blog/ipiwza/"/>
      <url>/blog/ipiwza/</url>
      
        <content type="html"><![CDATA[<h2 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206. 反转链表"></a>206. 反转链表</h2><ul><li><a href="https://leetcode-cn.com/problems/reverse-linked-list/">https://leetcode-cn.com/problems/reverse-linked-list/</a></li></ul><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1603193588776-6539785f-f52d-494b-b7a1-2bc6cebf1e60.png#crop=0&crop=0&crop=1&crop=1&height=136&id=YFQAP&margin=%5Bobject%20Object%5D&name=image.png&originHeight=271&originWidth=725&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=20430&status=done&style=shadow&title=&width=362.5" alt="image.png"></p><h3 id="问题思路"><a href="#问题思路" class="headerlink" title="问题思路"></a>问题思路</h3><ol><li><strong>利用外部空间：</strong>将所给链表存到 ArryList 里面或者是新的链表里面，然后再反转动态数组就可以了。</li><li><strong>快慢指针</strong></li><li><strong>递归解法</strong></li></ol><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><h4 id="js"><a href="#js" class="headerlink" title="js"></a>js</h4><pre><code class="javascript">/** * Definition for singly-linked list. * function ListNode(val, next) &#123; *     this.val = (val===undefined ? 0 : val) *     this.next = (next===undefined ? null : next) * &#125; *//** * @param &#123;ListNode&#125; head * @return &#123;ListNode&#125; */var reverseList = function (head) &#123;  let prev = null;  let curr = head;  while (curr) &#123;    const next = curr.next;    curr.next = prev;    prev = curr;    curr = next;  &#125;  return prev;&#125;;</code></pre><h4 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a>递归实现</h4><pre><code class="java">/** * public class ListNode &#123; *     int val; *     ListNode next; *     ListNode(int x) &#123; val = x; &#125; * &#125; */</code></pre><pre><code class="java">// 避免陷入死循环if (head == null || head.next == null) return head;ListNode newHead = reverseList(head.next); //此处递归，找到最后一个节点了head.next.next = head; //重新指定节点指向（有两个next，注意少写）head.next = null; //将最初的节点指向空return newHead; //返回新的“倒置”头节点</code></pre><h4 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h4><pre><code class="java">class Solution &#123;    public ListNode reverseList(ListNode head) &#123;        // 避免陷入死循环        if (head == null || head.next == null) return head;        ListNode newHead = null;        while (head != null)&#123;            ListNode tmp = head.next;            head.next = newHead;            newHead = head;            head = tmp;        &#125;        return newHead;    &#125;&#125;</code></pre><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 📎线结构：链表 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>算法复杂度</title>
      <link href="/blog/veggl2/"/>
      <url>/blog/veggl2/</url>
      
        <content type="html"><![CDATA[<p>这是加密文章！</p>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 算法综述 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>算法分析与设计课程综述</title>
      <link href="/blog/eq2l1v/"/>
      <url>/blog/eq2l1v/</url>
      
        <content type="html"><![CDATA[<div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">算法分析与设计两门课程的学习笔记</div><h2 id="形式化定义"><a href="#形式化定义" class="headerlink" title="形式化定义"></a>形式化定义</h2><p>对于一个问题，将其进行科学的分析研究，就需要对其进行更加严谨的形式化定义，其形式就类似于数学建模过程中的构建出<strong>数学模型</strong>一样，对其进行问题的抽象化提取，以及合理的公式化，就比如“0-1 背包”问题中：<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1600597354257-45eba2b3-641c-433a-8732-9b6c11a16061.png#align=left&display=inline&height=281&id=FfSoK&margin=%5Bobject%20Object%5D&name=image.png&originHeight=561&originWidth=1065&size=184609&status=done&style=shadow&width=532.5" alt="image.png"></p><h2 id="判定性问题"><a href="#判定性问题" class="headerlink" title="判定性问题"></a>判定性问题</h2><p>类似于数学建模当中<strong>模型的求解</strong>，在给定模型以及约束条件的情况下求出符合该约束条件下的模型解：<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1600597489691-e0d838af-003e-404e-8a40-5145d2fefbad.png#align=left&display=inline&height=108&id=ZMrl3&margin=%5Bobject%20Object%5D&name=image.png&originHeight=216&originWidth=969&size=73465&status=done&style=shadow&width=484.5" alt="image.png"></p><h2 id="例子：Euclid-GCD-问题"><a href="#例子：Euclid-GCD-问题" class="headerlink" title="例子：Euclid-GCD 问题"></a>例子：Euclid-GCD 问题</h2><p>问题描述<br>将每个整数分解为素因子的积，找出公共的素因子，它们的积即是 GCD<br>问题思路<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1599360897754-ab7b7684-5565-471b-aece-1725b39196bb.png#align=left&display=inline&height=296&id=zBWoT&margin=%5Bobject%20Object%5D&name=image.png&originHeight=848&originWidth=1131&size=231186&status=done&style=shadow&width=395" alt="image.png"><br>代码实现</p><pre><code class="java">package com.wztlink1013.al.EuclidGCD;import java.util.Scanner;public class Main &#123;    public static void main(String args[])&#123;        Scanner input = new Scanner(System.in);        System.out.println(&quot;请输入两个大于零的自然数：&quot;);        int a = input.nextInt();        int b = input.nextInt();        GCD(a,b);        System.out.println(a + &quot;和&quot; + b + &quot;两个数的GCD值为：&quot; + GCD(a,b));    &#125;    public static int GCD(int i, int j)&#123;        int r;        while (j != 0)&#123;            r = i%j;            i = j;            j = r;            System.out.println(&quot;a=&quot;+i+&quot;；b=&quot;+j+&quot;；r=&quot;+r);        &#125;        return i;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 算法综述 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>1/15/18. 两/三/四数之和🔖数组🔖多指针🔖暴力</title>
      <link href="/blog/dq9vp6/"/>
      <url>/blog/dq9vp6/</url>
      
        <content type="html"><![CDATA[<h3 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a>1. 两数之和</h3><p><a href="https://leetcode.cn/problems/two-sum/">https://leetcode.cn/problems/two-sum/</a></p><pre><code class="javascript">/** * @param &#123;number[]&#125; nums * @param &#123;number&#125; target * @return &#123;number[]&#125; */var twoSum = function (nums, target) &#123;  let result = [];  for (let i = 0; i &lt; nums.length; i++) &#123;    for (let j = i + 1; j &lt; nums.length; j++) &#123;      if (nums[i] + nums[j] === target) &#123;        result = [i, j];        break;      &#125;    &#125;  &#125;  return result;&#125;;</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1652967530657-b60f0c75-a67f-4415-85e9-36c3f6ea89d0.png#clientId=uc31426af-adec-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=318&id=u3349df16&name=image.png&originHeight=382&originWidth=823&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=34517&status=done&style=none&taskId=ue4273151-d509-4228-aef2-d672759f240&title=&width=685.8333060807663" alt="image.png"></p><h3 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15. 三数之和"></a>15. 三数之和</h3><ul><li><a href="https://leetcode-cn.com/problems/3sum/">https://leetcode-cn.com/problems/3sum/</a></li></ul><pre><code class="javascript">/** * @param &#123;number[]&#125; nums * @return &#123;number[][]&#125; */var threeSum = function (nums) &#123;  let result = [];  let arr = nums.sort((a, b) =&gt; &#123;    return a - b;  &#125;);  for (let i = 0; i &lt; arr.length; i++) &#123;    if (i &gt; 0 &amp;&amp; arr[i] === arr[i - 1]) continue;    for (let j = i + 1; j &lt; arr.length; j++) &#123;      if (j &gt; i + 1 &amp;&amp; arr[j] === arr[j - 1]) continue;      for (let k = j + 1; k &lt; arr.length; k++) &#123;        if (arr[i] + arr[j] + arr[k] === 0) &#123;          if (k &gt; j + 1 &amp;&amp; arr[k] === arr[k - 1]) &#123;            k++;            continue;          &#125;          result.push([arr[i], arr[j], arr[k]]);        &#125;      &#125;    &#125;  &#125;  return result;&#125;;</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1652966701635-7130309a-dd69-4cb7-93fc-3a2f0ddffa65.png#clientId=uc31426af-adec-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=337&id=ub4f4d5d1&name=image.png&originHeight=405&originWidth=883&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=34614&status=done&style=none&taskId=u8fbc5a00-f533-486f-8b84-6fd8a4ff8c3&title=&width=735.8333040939449" alt="image.png"><br>5%……我裂开……思路还是 for 暴力循环，但是和上面的耗时过长做了一个先把数组排序的操作。</p><p>感觉肯定是有简单的方法的…<br>但肯定都是定一移二的操作</p><h3 id="18-四数之和"><a href="#18-四数之和" class="headerlink" title="18. 四数之和"></a>18. 四数之和</h3><ul><li><a href="https://leetcode.cn/problems/4sum/">https://leetcode.cn/problems/4sum/</a></li></ul><pre><code class="javascript">/** * @param &#123;number[]&#125; nums * @param &#123;number&#125; target * @return &#123;number[][]&#125; */var fourSum = function (nums, target) &#123;  let result = [];  let arr = nums.sort((a, b) =&gt; &#123;    return a - b;  &#125;);  for (let i = 0; i &lt; arr.length; i++) &#123;    if (i &gt; 0 &amp;&amp; arr[i] == arr[i - 1]) continue;    for (let j = i + 1; j &lt; arr.length; j++) &#123;      if (j &gt; i + 1 &amp;&amp; arr[j] == arr[j - 1]) continue;      for (let k = j + 1; k &lt; arr.length; k++) &#123;        if (k &gt; j + 1 &amp;&amp; arr[k] == arr[k - 1]) continue;        for (let l = k + 1; l &lt; arr.length; l++) &#123;          if (arr[i] + arr[j] + arr[k] + arr[l] === target) &#123;            if (l &gt; k + 1 &amp;&amp; arr[l] === arr[l - 1]) &#123;              l++;              continue;            &#125;            result.push([arr[i], arr[j], arr[k], arr[l]]);          &#125;        &#125;      &#125;    &#125;  &#125;  return result;&#125;;</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1653017507005-019cf789-c92c-4510-a8fa-a7ccbd00fc1c.png#clientId=u0f5497cc-bef1-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=344&id=u56d5290b&name=image.png&originHeight=413&originWidth=777&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=36684&status=done&style=none&taskId=u09bee045-0c4b-4e20-a23b-9d9b4dd7289&title=&width=647.4999742706627" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 📶线结构：字符串-数组-栈-队列 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>泛型</title>
      <link href="/blog/ef1q5c/"/>
      <url>/blog/ef1q5c/</url>
      
        <content type="html"><![CDATA[<p>类似 C++里面的模板</p><ul><li>定义的时候就是直接在后面加上<E>，比如： <code>public class ArrayList&lt;E&gt;</code></li><li>使用就是 <code>private E[] array</code> ;</li></ul><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="-1"><a href="#-1" class="headerlink" title=""></a></h2>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 非前端编程语言 </category>
          
          <category> JAVA </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JAVA动态数组设计</title>
      <link href="/blog/bx5ouf/"/>
      <url>/blog/bx5ouf/</url>
      
        <content type="html"><![CDATA[<h3 id="接口设计"><a href="#接口设计" class="headerlink" title="接口设计"></a>接口设计</h3><pre><code class="java">public int size(); // 返回动态数组元素个数public boolean isEmpty(); // 是否为空public boolean contains(E element); // 是否包含某个元素public void add(E element); // 在数组尾部添加元素public E get(int index); // 返回index位置对应的元素public E set(int index, E element); // 设置/更换index位置上的值public void add (int index, E element); // 在index位置上添加元素public E remove(int index); // 移除index位置上的值public int indexOf(E element); // 查看元素的位置public void clear(); // 清空动态数组所有元素</code></pre><h3 id="private-设计"><a href="#private-设计" class="headerlink" title="private 设计"></a>private 设计</h3><pre><code class="java">// 元素的数量private int size;// 所有的元素private E[] elements;private static final int DEFAULT_CAPACITY = 10;private static final int ELEMENT_NOT_FOUND = -1;/**     * 保证要有capacity的容量     * @param capacity     */private void ensureCapacity(int capacity) &#123;    int oldCapacity = elements.length;    if (oldCapacity &gt;= capacity) return;    // 新容量为旧容量的1.5倍    int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);    E[] newElements = (E[]) new Object[newCapacity];    for (int i = 0; i &lt; size; i++) &#123;        newElements[i] = elements[i];    &#125;    elements = newElements;    System.out.println(oldCapacity + &quot;扩容为&quot; + newCapacity);&#125;private void outOfBounds(int index) &#123;    throw new IndexOutOfBoundsException(&quot;Index:&quot; + index + &quot;, Size:&quot; + size);&#125;private void rangeCheck(int index) &#123;    if (index &lt; 0 || index &gt;= size) &#123;        outOfBounds(index);    &#125;&#125;private void rangeCheckForAdd(int index) &#123;    if (index &lt; 0 || index &gt; size) &#123;        outOfBounds(index);    &#125;&#125;</code></pre><h3 id="构造函数设计"><a href="#构造函数设计" class="headerlink" title="构造函数设计"></a>构造函数设计</h3><pre><code class="java">public ArrayList(int capaticy) &#123;    capaticy = (capaticy &lt; DEFAULT_CAPACITY) ? DEFAULT_CAPACITY : capaticy;    elements = (E[]) new Object[capaticy];&#125;public ArrayList() &#123;    this(DEFAULT_CAPACITY);&#125;</code></pre><h3 id="重写输出"><a href="#重写输出" class="headerlink" title="重写输出"></a>重写输出</h3><pre><code class="java">@Overridepublic String toString() &#123;    // size=3, [99, 88, 77]    StringBuilder string = new StringBuilder();    string.append(&quot;size=&quot;).append(size).append(&quot;, [&quot;);    for (int i = 0; i &lt; size; i++) &#123;        if (i != 0) &#123;            string.append(&quot;, &quot;);        &#125;        string.append(elements[i]);        //            if (i != size - 1) &#123;        //                string.append(&quot;, &quot;);        //            &#125;    &#125;    string.append(&quot;]&quot;);    return string.toString();&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 📶线结构：字符串-数组-栈-队列 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JAVA链表设计</title>
      <link href="/blog/nkn2os/"/>
      <url>/blog/nkn2os/</url>
      
        <content type="html"><![CDATA[<h2 id="LinkedList-和-ArrayList-的设计"><a href="#LinkedList-和-ArrayList-的设计" class="headerlink" title="LinkedList 和 ArrayList 的设计"></a>LinkedList 和 ArrayList 的设计</h2><blockquote><p>同时设计 LinkedList 和 ArrayList</p></blockquote><ul><li><strong>LinkedList</strong>不需要构造函数</li><li><strong>ArrayList</strong>需要，后者需要一个容量的初始化。</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1603191040309-0ed4b536-89c0-449d-85cc-e763afcb73ea.png#align=left&display=inline&height=300&margin=%5Bobject%20Object%5D&name=image.png&originHeight=600&originWidth=557&size=89515&status=done&style=stroke&width=278.5" alt="image.png"></p><h3 id="接口-List-设计"><a href="#接口-List-设计" class="headerlink" title="接口 List 设计"></a>接口 List 设计</h3><blockquote><p>只用来<strong>声明对外接口</strong>，不能声明</p></blockquote><pre><code class="java">package com.wztlink1013.ds.linkedlist;/** * fun：实现ArrayList和LinkedList的接口 * */public interface List&lt;E&gt; &#123;    static final int ELEMENT_NOT_FOUND = -1;    /**     * 元素的数量[抽象类中实现]     * @return     */    int size();    /**     * 是否为空[抽象类中实现]     * @return     */    boolean isEmpty();    /**     * 是否包含某个元素[抽象类中实现]     * @param element     * @return     */    boolean contains(E element);    /**     * 添加元素到尾部[抽象类中实现]     * @param element     */    void add(E element);    /**     * 清除所有元素[实现类中实现]     */    void clear();    /**     * 获取index位置的元素[实现类中实现]     * @param index     * @return     */    E get(int index);    /**     * 设置index位置的元素[实现类中实现]     * @param index     * @param element     * @return 原来的元素ֵ     */    E set(int index, E element);    /**     * 在index位置插入一个元素[实现类中实现]     * @param index     * @param element     */    void add(int index, E element);    /**     * 删除index位置的元素[实现类中实现]     * @param index     * @return     */    E remove(int index);    /**     * 查看元素的索引[实现类中实现]     * @param element     * @return     */    int indexOf(E element);&#125;</code></pre><h3 id="抽象类-AbstractList-设计"><a href="#抽象类-AbstractList-设计" class="headerlink" title="抽象类 AbstractList 设计"></a>抽象类 AbstractList 设计</h3><blockquote><p>放 ArrayList 和 LinkedList 的公共代码</p><ul><li><strong>实现 List 接口类</strong>的共同代码</li><li>ArrayList 和 LinkedList 都用得到但是不对外公开的代码</li></ul><p>声明抽象类 abstract，就意味着可以不用全部实现接口 List 里面的所有方法</p></blockquote><pre><code class="java">package com.wztlink1013.ds.linkedlist;/** * fun：放ArrayList和LinkedList公共代码的抽象类（父类） * */public abstract class AbstractList&lt;E&gt; implements List&lt;E&gt; &#123;    protected int size;    /**     * 元素的数量     * @return     */    public int size() &#123;        return size;    &#125;    /**     * 是否为空     * @return     */    public boolean isEmpty() &#123;        return size == 0;    &#125;    /**     * 是否包含某个元素     * @param element     * @return     */    public boolean contains(E element) &#123;        return indexOf(element) != ELEMENT_NOT_FOUND;    &#125;    /**     * 添加元素到尾部     * @param element     */    public void add(E element) &#123;        add(size, element);    &#125;    /**     * 下面三个是ArrayList和LinkedList两个实现类中的公共代码     * */    protected void outOfBounds(int index) &#123;        throw new IndexOutOfBoundsException(&quot;Index:&quot; + index + &quot;, Size:&quot; + size);    &#125;    protected void rangeCheck(int index) &#123;        if (index &lt; 0 || index &gt;= size) &#123;            outOfBounds(index);        &#125;    &#125;    protected void rangeCheckForAdd(int index) &#123;        if (index &lt; 0 || index &gt; size) &#123;            outOfBounds(index);        &#125;    &#125;&#125;</code></pre><h3 id="ArrayList-设计"><a href="#ArrayList-设计" class="headerlink" title="ArrayList 设计"></a>ArrayList 设计</h3><pre><code class="java">package com.wztlink1013.ds.linkedlist;/** *fun：实现动态数组 */@SuppressWarnings(&quot;unchecked&quot;)public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; &#123;    private E[] elements;    private static final int DEFAULT_CAPACITY = 10;    public ArrayList(int capaticy) &#123;        capaticy = (capaticy &lt; DEFAULT_CAPACITY) ? DEFAULT_CAPACITY : capaticy;        elements = (E[]) new Object[capaticy];    &#125;    public ArrayList() &#123;        this(DEFAULT_CAPACITY);    &#125;    @Override    public void clear() &#123;        for (int i = 0; i &lt; size; i++) &#123;            elements[i] = null;        &#125;        size = 0;    &#125;    @Override    public E get(int index) &#123;        rangeCheck(index);        return elements[index];    &#125;    @Override    public E set(int index, E element) &#123;        rangeCheck(index);        E old = elements[index];        elements[index] = element;        return old;    &#125;    @Override    public void add(int index, E element) &#123;        rangeCheckForAdd(index);        ensureCapacity(size + 1);        for (int i = size; i &gt; index; i--) &#123;            elements[i] = elements[i - 1];        &#125;        elements[index] = element;        size++;    &#125;    @Override    public E remove(int index) &#123;        rangeCheck(index);        E old = elements[index];        for (int i = index + 1; i &lt; size; i++) &#123;            elements[i - 1] = elements[i];        &#125;        elements[--size] = null;        return old;    &#125;    @Override    public int indexOf(E element) &#123;        if (element == null) &#123;  // 1            for (int i = 0; i &lt; size; i++) &#123;                if (elements[i] == null) return i;            &#125;        &#125; else &#123;            for (int i = 0; i &lt; size; i++) &#123;                if (element.equals(elements[i])) return i; // n            &#125;        &#125;        return ELEMENT_NOT_FOUND;    &#125;    /**     * 保证要有capacity的容量     * @param capacity     */    private void ensureCapacity(int capacity) &#123;        int oldCapacity = elements.length;        if (oldCapacity &gt;= capacity) return;        // 新容量为旧容量的1.5倍        int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);        E[] newElements = (E[]) new Object[newCapacity];        for (int i = 0; i &lt; size; i++) &#123;            newElements[i] = elements[i];        &#125;        elements = newElements;        System.out.println(oldCapacity + &quot;扩容为&quot; + newCapacity);    &#125;    @Override    public String toString() &#123;        // size=3, [99, 88, 77]        StringBuilder string = new StringBuilder();        string.append(&quot;size=&quot;).append(size).append(&quot;, [&quot;);        for (int i = 0; i &lt; size; i++) &#123;            if (i != 0) &#123;                string.append(&quot;, &quot;);            &#125;            string.append(elements[i]);        &#125;        string.append(&quot;]&quot;);        return string.toString();    &#125;    /**     * 新添加功能     */    public int search(E element)&#123;        for (int i = 0;i&lt;size;i++)&#123;            if (element == elements[i])&#123;                return i;            &#125;        &#125;        return ELEMENT_NOT_FOUND;    &#125;&#125;</code></pre><h3 id="LinkedList-设计"><a href="#LinkedList-设计" class="headerlink" title="LinkedList 设计"></a>LinkedList 设计</h3><pre><code class="java">package com.wztlink1013.ds.linkedlist;/** *fun：链表的实现 */@SuppressWarnings(&quot;unchecked&quot;)public class LinkedList&lt;E&gt; extends AbstractList&lt;E&gt; &#123;    private Node&lt;E&gt; first;    private Node&lt;E&gt; last;    private static class Node&lt;E&gt; &#123;        E element;        Node&lt;E&gt; prev;        Node&lt;E&gt; next;        public Node(E element, Node&lt;E&gt; next) &#123;            this.element = element;            this.next = next;        &#125;    &#125;    @Override    public void clear() &#123;        size = 0;        first = null;        last = null;    &#125;    @Override    public E get(int index) &#123;        return node(index).element;    &#125;    @Override    public E set(int index, E element) &#123;        Node&lt;E&gt; node = node(index);        E old = node.element;        node.element = element;        return old;    &#125;    @Override    public void add(int index, E element) &#123;        if (index == 0)&#123;            first = new Node&lt;&gt;(element, first);        &#125; else &#123;            Node&lt;E&gt; prev = node(index - 1);            prev.next = new Node&lt;&gt;(element, prev.next);        &#125;        size++;    &#125;    @Override    public E remove(int index) &#123;//        Node&lt;E&gt; node = first;//        if (index == 0) &#123;//            first = first.next;//        &#125; else &#123;//            Node&lt;E&gt; prev = node(index -1);//            node = prev.next;//            prev.next = node.next;//        &#125;        rangeCheck(index);        Node&lt;E&gt; node = node(index);        Node&lt;E&gt; prev = node.prev;        Node&lt;E&gt; next = node.next;        if (prev == null) &#123; // index == 0            first = next;        &#125; else &#123;            prev.next = next;        &#125;        if (next == null) &#123; // index == size - 1            last = prev;        &#125; else &#123;            next.prev = prev;        &#125;        size--;        return node.element;    &#125;    @Override    public int indexOf(E element) &#123;        if (element == null) &#123;            Node&lt;E&gt; node = first;            for (int i = 0; i &lt; size; i++) &#123;                if (node.element == null) return i;                node = node.next;            &#125;        &#125; else &#123;            Node&lt;E&gt; node = first;            for (int i = 0; i &lt; size; i++) &#123;                if (element.equals(node.element)) return i;                node = node.next;            &#125;        &#125;        return ELEMENT_NOT_FOUND;    &#125;    /**     * 获取index位置对应的节点对象     * @param index     * @return     */    private Node&lt;E&gt; node(int index) &#123;        rangeCheck(index);        if (index &lt; (size &gt;&gt; 1)) &#123;            Node&lt;E&gt; node = first;            for (int i = 0; i &lt; index; i++) &#123;                node = node.next;            &#125;            return node;        &#125; else &#123;            Node&lt;E&gt; node = last;            for (int i = size - 1; i &gt; index; i--) &#123;                node = node.prev;            &#125;            return node;        &#125;    &#125;    @Override    public String toString() &#123;        StringBuilder string = new StringBuilder();        string.append(&quot;size=&quot;).append(size).append(&quot;, [&quot;);        Node&lt;E&gt; node = first;        for (int i = 0; i &lt; size; i++) &#123;            if (i != 0) &#123;                string.append(&quot;, &quot;);            &#125;            string.append(node);            node = node.next;        &#125;        string.append(&quot;]&quot;);        return string.toString();    &#125;&#125;</code></pre><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 📶线结构：字符串-数组-栈-队列 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>IDEA配置Tomcat</title>
      <link href="/blog/fgh5bc/"/>
      <url>/blog/fgh5bc/</url>
      
        <content type="html"><![CDATA[<h2 id="一、Tomcat-的下载"><a href="#一、Tomcat-的下载" class="headerlink" title="一、Tomcat 的下载"></a>一、Tomcat 的下载</h2><h3 id="正常下载并安装"><a href="#正常下载并安装" class="headerlink" title="正常下载并安装"></a>正常下载并安装</h3><blockquote><p>！！！在此之前默认读者下载且配置好了 jdk 环境</p></blockquote><ul><li>进入该官网<a href="https://imgconvert.csdnimg.cn/aHR0cDovL3RvbWNhdC5hcGFjaGUub3JnLw?x-oss-process=image/format,png">下载页面</a><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598787914511-a035ba93-0b7a-450b-b391-5d1452435ca7.png#align=left&display=inline&height=238&margin=%5Bobject%20Object%5D&originHeight=952&originWidth=1842&size=0&status=done&style=shadow&width=461"></li><li>下载并解压到自己的相应盘区，再进入下图文件夹检验是否成功<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598787914448-2ef2e1a1-2966-4d35-8bfe-82162aa1588b.png#align=left&display=inline&height=273&margin=%5Bobject%20Object%5D&originHeight=727&originWidth=1147&size=0&status=done&style=shadow&width=431"></li><li>点击第二个框不出现闪退情况则证明成功<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598787914507-87063aec-884a-4180-b124-568478d81bc0.png#align=left&display=inline&height=222&margin=%5Bobject%20Object%5D&originHeight=639&originWidth=1223&size=0&status=done&style=shadow&width=425"></li><li>浏览器进入端口<a href="http://localhost:8080/">http://localhost:8080/</a>上述配置成功则表明成功<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598787914624-248148e3-3f5f-45ca-ad93-c063216a7aff.png#align=left&display=inline&height=240&margin=%5Bobject%20Object%5D&originHeight=1030&originWidth=1838&size=0&status=done&style=shadow&width=429"></li></ul><h3 id="过程中可能会出现的问题"><a href="#过程中可能会出现的问题" class="headerlink" title="过程中可能会出现的问题"></a>过程中可能会出现的问题</h3><ul><li>点击 startup.bat 文件出现闪退<br>电脑中 java jdk 有无（JAVA_HOME）</li><li>端口被占用<br>进入 Tomcat 文件夹下的 conf 文件下的 server.xml 文件，用记事本查找 8080，下面复制一个新的初始端口<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598787914513-8083bc6e-4c6f-436e-b0b0-98d3d70b9dea.png#align=left&display=inline&height=80&margin=%5Bobject%20Object%5D&originHeight=80&originWidth=557&size=0&status=done&style=none&width=557"></li></ul><h2 id="二、IDEA-配置-Tomcat"><a href="#二、IDEA-配置-Tomcat" class="headerlink" title="二、IDEA 配置 Tomcat"></a>二、IDEA 配置 Tomcat</h2><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><ul><li>新建一个项目<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598787914503-6a4bf3f9-0e92-4bd3-bcde-e65af73510b8.png#align=left&display=inline&height=1060&margin=%5Bobject%20Object%5D&originHeight=1060&originWidth=1457&size=0&status=done&style=none&width=1457"></li><li>编写 head/body 待会测试用<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598787914719-36f4cef3-db7c-4bd9-a43a-5c92f0afead2.png#align=left&display=inline&height=1080&margin=%5Bobject%20Object%5D&originHeight=1080&originWidth=1842&size=0&status=done&style=none&width=1842"></li><li>相关配置<br>进入配置页面<img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598787914684-a3f47ea5-50df-450f-935d-f9ec086bc2cb.png#align=left&display=inline&height=1080&margin=%5Bobject%20Object%5D&originHeight=1080&originWidth=1842&size=0&status=done&style=none&width=1842"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598787914511-d1b72498-32cb-4868-8758-34fb3de3e798.png#align=left&display=inline&height=853&margin=%5Bobject%20Object%5D&originHeight=853&originWidth=1343&size=0&status=done&style=none&width=1343"><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598787914585-5e3362d9-db50-4bdb-8640-f3a2f630bbbf.png#align=left&display=inline&height=932&margin=%5Bobject%20Object%5D&originHeight=932&originWidth=1343&size=0&status=done&style=none&width=1343"></li></ul><h3 id="运行测试"><a href="#运行测试" class="headerlink" title="运行测试"></a>运行测试</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598787914608-c71c5263-ae91-472f-b760-cc3fbd78b81c.png#align=left&display=inline&height=1080&margin=%5Bobject%20Object%5D&originHeight=1080&originWidth=1842&size=0&status=done&style=none&width=1842"><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598787914608-14ca2925-9dd2-4cfd-9399-597c08094743.png#align=left&display=inline&height=285&margin=%5Bobject%20Object%5D&originHeight=285&originWidth=1836&size=0&status=done&style=none&width=1836"></p>]]></content>
      
      
      <categories>
          
          <category> 🔨环境工具 </category>
          
          <category> 环境搭建 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>对谷歌BERT模型的思考</title>
      <link href="/blog/mssoff/"/>
      <url>/blog/mssoff/</url>
      
        <content type="html"><![CDATA[<h2 id="why？"><a href="#why？" class="headerlink" title="why？"></a>why？</h2><blockquote><p>BERT 可以用来干什么？</p></blockquote><p>处理这种非结构化的数据以及之前学习到的情感分析</p><p>BERT 可以用于问答系统，情感分析，垃圾邮件过滤，命名实体识别，文档聚类等任务中，作为这些任务的基础设施即语言模型，</p><h2 id="what？"><a href="#what？" class="headerlink" title="what？"></a>what？</h2><p>是一个自然语言处理模型<br>提出了“训练词向量”概念，这是独特之处</p><p><strong>BERT 利用了 Transformer 的 encoder 部分。</strong><br><strong>BERT 的创新点在于它将双向 Transformer 用于语言模型，</strong><br>之前的模型是从左向右输入一个文本序列，或者将 left-to-right 和 right-to-left 的训练结合起来。实验的结果表明，双向训练的语言模型对语境的理解会比单向的语言模型更深刻，Transformer 是一种注意力机制，可以学习文本中单词之间的上下文关系的。Transformer 的原型包括两个独立的机制，一个 encoder 负责接收文本作为输入，一个 decoder 负责预测任务的结果。BERT 的目标是生成语言模型，所以只需要 encoder 机制。Transformer 的 encoder 是一次性读取整个文本序列，而不是从左到右或从右到左地按顺序读取，这个特征使得模型能够基于单词的两侧学习，相当于是一个双向的功能。 Transformer 的 encoder 部分，输入是一个 token 序列，先对其进行 embedding 称为向量，然后输入给神经网络，输出是大小为 H 的向量序列，每个向量对应着具有相同索引的 token。当我们在训练语言模型时，有一个挑战就是要定义一个预测目标，很多模型在一个序列中预测下一个单词，“The child came home from ___”双向的方法在这样的任务中是有限制的，为了克服这个问题，BERT 使用两个策略:</p><h3 id="Masked-LM-MLM"><a href="#Masked-LM-MLM" class="headerlink" title="Masked LM (MLM)"></a>Masked LM (MLM)</h3><p>论文中介绍了一种新技术叫做 Masked LM（MLM），在这个技术出现之前是无法进行双向语言模型训练的。在将单词序列输入给 BERT 之前，每个序列中有 15％ 的单词被 [MASK] token 替换。 然后模型尝试基于序列中其他未被 mask 的单词的上下文来预测被掩盖的原单词。</p><p>这样就需要：</p><ul><li><input checked="" disabled="" type="checkbox"> 在 encoder 的输出上添加一个分类层</li><li><input checked="" disabled="" type="checkbox"> 用嵌入矩阵乘以输出向量，将其转换为词汇的维度</li><li><input checked="" disabled="" type="checkbox"> 用 softmax 计算词汇表中每个单词的概率</li></ul><p>BERT 的损失函数只考虑了 mask 的预测值，忽略了没有掩蔽的字的预测。这样的话，模型要比单向模型收敛得慢，不过结果的情境意识增加了。</p><p><strong>eg：my dog is hairy</strong></p><ul><li>有 80%的概率用“[mask]”标记来替换——my dog is [MASK]</li><li>有 10%的概率用随机采样的一个单词来替换——my dog is apple</li><li>有 10%的概率不做替换——my dog is hairy</li></ul><h3 id="Next-Sentence-Prediction-NSP"><a href="#Next-Sentence-Prediction-NSP" class="headerlink" title="Next Sentence Prediction (NSP)"></a>Next Sentence Prediction (NSP)</h3><p>在 BERT 的训练过程中，模型接收成对的句子作为输入，并且预测其中第二个句子是否在原始文档中也是后续句子。在训练期间，50％ 的输入对在原始文档中是前后关系，另外 50％ 中是从语料库中随机组成的，并且是与第一句断开的。为了帮助模型区分开训练中的两个句子，输入在进入模型之前要按以下方式进行处理：</p><ul><li><input checked="" disabled="" type="checkbox"> 在第一个句子的开头插入 [CLS] 标记，在每个句子的末尾插入 [SEP] 标记。</li><li><input checked="" disabled="" type="checkbox"> 将表示句子 A 或句子 B 的一个句子 embedding 添加到每个 token 上。</li><li><input checked="" disabled="" type="checkbox"> 给每个 token 添加一个位置 embedding，来表示它在序列中的位置。</li><li><input checked="" disabled="" type="checkbox"> 为了预测第二个句子是否是第一个句子的后续句子，用下面几个步骤来预测：</li><li><input checked="" disabled="" type="checkbox"> 整个输入序列输入给 Transformer 模型</li><li><input checked="" disabled="" type="checkbox"> 用一个简单的分类层将 [CLS] 标记的输出变换为 2×1 形状的向量</li><li><input checked="" disabled="" type="checkbox"> 用 softmax 计算 IsNextSequence 的概率</li></ul><p>在训练 BERT 模型时，Masked LM 和 Next Sentence Prediction 是一起训练的，目标就是要最小化两种策略的组合损失函数。</p><h2 id="how？"><a href="#how？" class="headerlink" title="how？"></a>how？</h2><p>BERT 可以用于各种 NLP 任务，只需在核心模型中添加一个层.<br>例如：</p><ul><li><input checked="" disabled="" type="checkbox"> 在分类任务中，例如情感分析等，只需要在 Transformer 的输出之上加一个分类层</li><li><input checked="" disabled="" type="checkbox"> 在问答任务（例如 SQUAD v1.1）中，问答系统需要接收有关文本序列的 question，并且需要在序列中标记 answer。 可以使用 BERT 学习两个标记 answer 开始和结尾的向量来训练 Q＆A 模型。</li><li><input checked="" disabled="" type="checkbox"> 在命名实体识别（NER）中，系统需要接收文本序列，标记文本中的各种类型的实体（人员，组织，日期等）。 可以用 BERT 将每个 token 的输出向量送到预测 NER 标签的分类层。</li></ul>]]></content>
      
      
      <categories>
          
          <category> ✨其他 </category>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[转]银行家算法</title>
      <link href="/blog/kc645t/"/>
      <url>/blog/kc645t/</url>
      
        <content type="html"><![CDATA[<h2 id="一、银行家算法"><a href="#一、银行家算法" class="headerlink" title="一、银行家算法"></a>一、银行家算法</h2><p><strong>功能：避免死锁</strong></p><blockquote><p>在银行中，客户申请贷款的数量是有限的，每个客户在第一次申请贷款时要声明完成该项目所需的最大资金量，在满足所有贷款要求时，客户应及时归还。银行家在客户申请的贷款数量不超过自己拥有的最大值时，都应尽量满足客户的需要。在这样的描述中，银行家就好比操作系统，资金就是资源，客户就相当于要申请资源的进程。</p></blockquote><h2 id="二、代码实现"><a href="#二、代码实现" class="headerlink" title="二、代码实现"></a>二、代码实现</h2><pre><code class="cpp">#include &lt;iostream&gt;using namespace std;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;/* 定义全局变量 */const int    x = 50, y = 50;                                 /* x为进程个数 y为资源种类数 */int        Available[y];                                   /* 各资源可利用的数量 */int        Allocation[x][y];                               /* 各进程当前已分配的资源数量 */int        Max[x][y];                                      /* 各进程对各类资源的最大需求数 */int        Need[x][y];                                     /* 尚需多少资源 */int        Request[y];                                     /* 申请多少资源 */int        Work[y];                                        /* 工作向量，表示系统可提供给进程继续运行所需的各类资源数量 */int        Finish[x];                                      /* 表示系统是否有足够的资源分配给进程，1为是 */int        p[x];                                           /* 存储安全序列 */int        i, j;                                           /* i表示进程，j表示资源 */int        n, m;                                           /* n为进程i的数量,m为资源j种类数 */int        l    = 0;                                    /* l用来记录有几个进程是Finish[i]=1的，当l=n是说明系统状态是安全的 */int        counter = 0;                                    /* 记数器,记录可执行的进程数 *//* 函数声明 */void chushihua();                                               /* 初始化函数 */void safe();                                                    /* 安全性算法 */void show();                                                    /* 函数show,输出当前状态 */void bank();                                                    /* 银行家算法 */void jieshu();                                                  /* 结束函数 */void chushihua()&#123;    cout &lt;&lt; &quot;输入进程的数量: &quot;;                                    /* 从此开始输入有关数据 */    cin &gt;&gt; n;    cout &lt;&lt; &quot;输入资源种类数: &quot;;    cin &gt;&gt; m;    cout &lt;&lt; endl &lt;&lt; &quot;输入各种资源当前可用的数量( &quot; &lt;&lt; m &lt;&lt; &quot; 种): &quot; &lt;&lt; endl;    for ( j = 0; j &lt; m; j++ )                               /* m为资源数 */    &#123;        cout &lt;&lt; &quot;输入资源 &quot; &lt;&lt; j &lt;&lt; &quot; 可利用的数量Available[&quot; &lt;&lt; j &lt;&lt; &quot;]: &quot;;        cin &gt;&gt; Available[j];                            /* 输入数字的过程 */        Work[j] = Available[j];                         /* 初始化Work[j]，它的初始值就是当前可用的资源数 */    &#125;    cout &lt;&lt; endl &lt;&lt; &quot;输入各进程当前已分配的资源数量Allocation[&quot; &lt;&lt; n &lt;&lt; &quot;][&quot; &lt;&lt; m &lt;&lt; &quot;]: &quot; &lt;&lt; endl;    for ( i = 0; i &lt; n; i++ )                               /* n为进程数 */    &#123;        for ( j = 0; j &lt; m; j++ )                       /* m为资源数 */        &#123;            cout &lt;&lt; &quot; 输入进程 &quot; &lt;&lt; i &lt;&lt; &quot; 当前已分配的资源 &quot; &lt;&lt; j &lt;&lt; &quot; 数量: &quot;;            cin &gt;&gt; Allocation[i][j];        &#125;        cout &lt;&lt; endl;        Finish[i] = 0;                                  /* 初始化Finish[i] */    &#125;    cout &lt;&lt; endl &lt;&lt; &quot;输入各进程对各类资源的最大需求Max[&quot; &lt;&lt; n &lt;&lt; &quot;][&quot; &lt;&lt; m &lt;&lt; &quot;]: &quot; &lt;&lt; endl;    for ( i = 0; i &lt; n; i++ )                               /* n为进程数 */    &#123;        for ( j = 0; j &lt; m; j++ )                       /* m为资源数 */        &#123;            cout &lt;&lt; &quot; 输入进程 &quot; &lt;&lt; i &lt;&lt; &quot; 对资源 &quot; &lt;&lt; j &lt;&lt; &quot; 的最大需求数: &quot;;            cin &gt;&gt; Max[i][j];            if ( Max[i][j] &gt;= Allocation[i][j] )    /* 若最大需求大于已分配，则计算需求量 */                Need[i][j] = Max[i][j] - Allocation[i][j];            else                Need[i][j] = 0;                 /* Max小于已分配的时候，此类资源已足够不需再申请 */        &#125;        cout &lt;&lt; endl;    &#125;    cout &lt;&lt; endl &lt;&lt; &quot;初始化完成&quot; &lt;&lt; endl;&#125;/* 安全性算法函数 */void safe()&#123;    l = 0;                                                                  /* l用来记录有几个进程是Finish[i]=1的，当l=n是说明系统状态是安全的 */    for ( i = 0; i &lt; n; i++ )                                               /* n为进程数 */    &#123;        if ( Finish[i] == 0 )        &#123;                                                               /* 逐个查找Finish[i]==0的进程 条件一 */            counter = 0;                                            /* 记数器,记录有多少个进程已经执行 */            for ( j = 0; j &lt; m; j++ )                               /* m为资源数 */            &#123;                if ( Work[j] &gt;= Need[i][j] )                    counter = counter + 1;                  /* 可用大于需求，记数，该进程可以执行 */            &#125;            if ( counter == m )                                     /* i进程的每类资源都符合Work[j]&gt;=Need[i][j] 条件二 */            &#123;                p[l]        = i;                            /* 存储安全序列 */                Finish[i]    = 1;                            /* i进程标志为可分配 */                for ( j = 0; j &lt; m; j++ )                    Work[j] = Work[j] + Allocation[i][j];   /* 释放资源 */                l    = l + 1;                                /* 记数,现在有l个进程是安全的，当l=n时说明满足安全序列 */                i    = -1;                                   /* 从第一个进程开始继续寻找满足条件一二的进程 */            &#125;        &#125;    &#125;&#125;/* 显示当前状态函数 */void show()                                     /* 函数show,输出当前资源分配情况 */&#123;    int    i, j;                           /* 局部变量，i表示进程，j表示资源 */    int    All[y];                         /* 各种资源的总数量 */    int    L1;                             /* 局部变量L1 */    cout &lt;&lt; &quot;当前的状态为：&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;各种资源的总数量:&quot; &lt;&lt; endl;    for ( j = 0; j &lt; m; j++ )               /* m为资源数 */    &#123;        cout &lt;&lt; &quot; 资源&quot; &lt;&lt; j &lt;&lt; &quot;: &quot;;        All[j] = Available[j];          /* 总数量=可用的+已分配的 */        for ( i = 0; i &lt; n; i++ )       /* n为进程数 */            All[j] += Allocation[i][j];        cout &lt;&lt; All[j] &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl &lt;&lt; &quot;当前各种资源可用的量为(available):&quot; &lt;&lt; endl;    for ( j = 0; j &lt; m; j++ )               /* m为资源数 */        cout &lt;&lt; &quot; 资源&quot; &lt;&lt; j &lt;&lt; &quot;: &quot; &lt;&lt; Available[j] &lt;&lt; &quot; &quot;;    cout &lt;&lt; endl &lt;&lt; &quot;各进程所需的最大资源量(Max): &quot; &lt;&lt; endl;    for ( i = 0; i &lt; m; i++ )               /* m为资源数 */    &#123;        cout &lt;&lt; &quot; 资源&quot; &lt;&lt; i &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;    for ( L1 = 0; L1 &lt; n; L1++ )            /* n为进程数 */    &#123;        cout &lt;&lt; &quot;进程&quot; &lt;&lt; L1 &lt;&lt; &quot;: &quot;;        for ( j = 0; j &lt; m; j++ )            cout &lt;&lt; Max[L1][j] &lt;&lt; &quot; &quot;;        cout &lt;&lt; endl;    &#125;    cout &lt;&lt; endl &lt;&lt; &quot;各进程已经得到的资源量(allocation): &quot; &lt;&lt; endl;    for ( i = 0; i &lt; m; i++ )       /* m为资源数 */    &#123;        cout &lt;&lt; &quot; 资源&quot; &lt;&lt; i &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;    for ( L1 = 0; L1 &lt; n; L1++ )    /* n为进程数 */    &#123;        cout &lt;&lt; &quot;进程&quot; &lt;&lt; L1 &lt;&lt; &quot;: &quot;;        for ( j = 0; j &lt; m; j++ )            cout &lt;&lt; Allocation[L1][j] &lt;&lt; &quot; &quot;;        cout &lt;&lt; endl;    &#125;    cout &lt;&lt; endl &lt;&lt; &quot;各进程还需要的资源量(need):&quot; &lt;&lt; endl;    for ( i = 0; i &lt; m; i++ ) /* m为资源数 */    &#123;        cout &lt;&lt; &quot; 资源&quot; &lt;&lt; i &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;    for ( L1 = 0; L1 &lt; n; L1++ )    &#123;        cout &lt;&lt; &quot;进程&quot; &lt;&lt; L1 &lt;&lt; &quot;: &quot;;        for ( j = 0; j &lt; m; j++ )            cout &lt;&lt; Need[L1][j] &lt;&lt; &quot; &quot;;        cout &lt;&lt; endl;    &#125;&#125;/* 银行家算法函数 */void bank()&#123;    cout &lt;&lt; endl &lt;&lt; &quot;进程申请分配资源：&quot; &lt;&lt; endl;    int    k    = 0;                                                            /* 用于输入进程编号 */    bool    r    = false;                                                        /* 初值为假，输入Y继续申请则置为真 */    do                                                                              /* 输入请求 */    &#123;        cout &lt;&lt; &quot;输入申请资源的进程(0-&quot; &lt;&lt; n - 1 &lt;&lt; &quot;): &quot;;        cin &gt;&gt; k;                                                               /* 进程编号 */        cout &lt;&lt; endl;        while ( k &gt; n - 1 )                                                     /* 输入错误处理 */        &#123;            cout &lt;&lt; endl &lt;&lt; &quot;无该进程号，重新输入：&quot; &lt;&lt; endl;            cout &lt;&lt; endl &lt;&lt; &quot;输入申请资源的进程(0--&quot; &lt;&lt; n - 1 &lt;&lt; &quot;): &quot;;            cin &gt;&gt; k;                                                       /* 进程编号 */            cout &lt;&lt; endl;        &#125;        cout &lt;&lt; endl &lt;&lt; &quot;输入该进程申请各类资源的数量: &quot; &lt;&lt; endl;        for ( j = 0; j &lt; m; j++ )                                               /* m为资源数 */        &#123;            do                                                              /* do……while 循环判断申请输入的情况 */            &#123;                cout &lt;&lt; &quot;进程 &quot; &lt;&lt; k &lt;&lt; &quot; 申请资源[&quot; &lt;&lt; j &lt;&lt; &quot;]的数量:&quot;;                cin &gt;&gt; Request[j];                                      /* 输入请求进程数 */                cout &lt;&lt; endl;                if ( Request[j] &gt; Need[k][j] )                          /* 申请大于需求量时出错，提示重新输入 cout&lt;&lt;&quot;申请量大于需要量!&quot;&lt;&lt;endl; */                &#123;                    cout &lt;&lt; &quot;申请的资源&quot; &lt;&lt; j &lt;&lt; &quot;的数量为&quot; &lt;&lt; Request[j] &lt;&lt; &quot;,大于进程&quot; &lt;&lt; k &lt;&lt; &quot;对该资源需求量&quot; &lt;&lt; Need[k][j] &lt;&lt; &quot;。&quot; &lt;&lt; endl;                    cout &lt;&lt; &quot;重新输入!&quot; &lt;&lt; endl;                &#125;/* 先判断是否申请大于需求量，再判断是否申请大于可利用量 */                else if ( Request[j] &gt; Available[j] )                   /* 申请大于可利用量， 应该阻塞等待 */                &#123;                    cout &lt;&lt; &quot;\n没有那么多资源，目前可利用资源&quot; &lt;&lt; j &lt;&lt; &quot;数量为&quot; &lt;&lt; Available[j] &lt;&lt; &quot;,本次申请不成功，进程等待!&quot; &lt;&lt; endl;                    Finish[k] = 0;                                  /* 该进程等待 */                    goto error;                                     /* goto语句跳转，结束本次申请 */                &#125;            &#125;            while ( Request[j] &gt; Need[k][j] );                              /* Request[j]&gt;Available[j] */        &#125;/* 改变Available、Allocation、Need的值 */        for ( j = 0; j &lt; m; j++ )                                               /* m为资源数 */        &#123;            Available[j]        = Available[j] - Request[j];            /* 可用的资源数=可用的资源数-请求分配的资源数 */            Allocation[k][j]    = Allocation[k][j] + Request[j];        /* 已分配的资源数=已分配的资源数+请求的资源数 */            Need[k][j]        = Need[k][j] - Request[j];              /* 还需要的资源数=还需要的资源数-请求的资源数 */            Work[j]            = Available[j];        &#125;        safe();                                                                 /* 调用安全性算法函数，判断当前状态的安全性 */        if ( l &lt; n )                                                            /* l用来记录有几个进程是Finish[i]=1的，当l=n是说明系统状态是安全的 */        &#123;            l = 0;            cout &lt;&lt; &quot;\n试分配后,状态不安全,所以不予分配!恢复原状态&quot; &lt;&lt; endl;/* 恢复数据 */            for ( j = 0; j &lt; m; j++ )                                       /* m为资源数 */            &#123;                Available[j]        = Available[j] + Request[j];                Allocation[k][j]    = Allocation[k][j] - Request[j];                Need[k][j]        = Need[k][j] + Request[j];                Work[j]            = Available[j];            &#125;            for ( i = 0; i &lt; n; i++ )                                       /* n为进程数 */                Finish[i] = 0;                                          /* 进程均置为未分配状态 */        &#125;else  &#123; /* l=n，即所有的Finish[i]=1,每一个进程均能执行 */            l = 0;                                                          /* 判断标志 */            cout &lt;&lt; &quot;\n申请资源成功!!!&quot; &lt;&lt; endl;            for ( j = 0; j &lt; m; j++ )                                       /* m为资源数 */            &#123;                if ( Need[k][j] == 0 )                    ;                else &#123;                                                  /*有一种资源还没全部申请到，则该进程不可执行，不能释放拥有的资源 */                    l = 1;                                          /* 置l为1，作为判断标志 */                    break;                &#125;            &#125;            if ( l != 1 )                                                   /* 进程可以执行，则释放该进程的所有资源 */            &#123;                for ( j = 0; j &lt; m; j++ )                               /* m为资源数 */                &#123;                    Available[j]        = Available[j] + Allocation[k][j];                    Allocation[k][j]    = 0;                &#125;                cout &lt;&lt; &quot;该进程已得到所有需求资源，执行后将释放其所有拥有资源！&quot; &lt;&lt; endl;            &#125;            l = 0;                                                          /* 归零 */            cout &lt;&lt; &quot;\n安全的状态!&quot; &lt;&lt; endl;            cout &lt;&lt; &quot;安全序列为: &quot;;            cout &lt;&lt; endl &lt;&lt; &quot;进程&quot; &lt;&lt; &quot;(&quot; &lt;&lt; p[0] &lt;&lt; &quot;)&quot;;                     /* 输出安全序列，考虑显示格式，先输出第一个 */            Finish[0] = 0;            for ( i = 1; i &lt; n; i++ )            &#123;                cout &lt;&lt; &quot;==&gt;&gt;&quot; &lt;&lt; &quot;进程&quot; &lt;&lt; &quot;(&quot; &lt;&lt; p[i] &lt;&lt; &quot;)&quot;;                Finish[i] = 0;                                          /* 所有进程置为未分配状态 */            &#125;            cout &lt;&lt; endl &lt;&lt; endl;        &#125;        show();                                                                 /* 显示当前状态 */error:                                                                                  /* 申请大于可利用量， 应该阻塞等待,结束本次资源申请，GOTO 语句跳转至此 */        cout &lt;&lt; endl &lt;&lt; &quot;是否继续申请资源(y/n)或（Y/N）?&quot;;        char* b = new char;                                                     /* 输入y/n，判断是否继续申请 &lt;&lt;endl */        cin &gt;&gt; b;        cout &lt;&lt; endl;        cout &lt;&lt; &quot;-------------------------------------------&quot; &lt;&lt; endl &lt;&lt; endl;        cout &lt;&lt; endl;        if ( *b == &#39;y&#39; || *b == &#39;Y&#39; )            r = true;                                                       /* 继续申请 */        else&#123;            r = false;                                                      /*不继续申请 */            jieshu();                                                       /* 调用结束函数 */        &#125;    &#125;    while ( r == true );&#125;/* 结束函数 */void jieshu()&#123;    cout &lt;&lt; endl &lt;&lt; endl;    cout &lt;&lt; &quot;\t\t 演示计算完毕&quot; &lt;&lt; endl;    cout &lt;&lt; endl &lt;&lt; endl;&#125;/* 主函数 */int main()&#123;    cout &lt;&lt; endl &lt;&lt; endl &lt;&lt; &quot;\t\t\t\t模拟银行家算法&quot; &lt;&lt; endl &lt;&lt; endl;    chushihua();                                    /* 初始化函数调用 */    cout &lt;&lt; endl;    show();                                         /* 输出当前状态 */    safe();                                         /* 判断当前状态的安全性 */    if ( l &lt; n )                                    /* l在safe中是用来记录安全的进程的个数的 */    &#123;        cout &lt;&lt; &quot;\n当前状态不安全，拒绝申请！&quot; &lt;&lt; endl;        cout &lt;&lt; endl;        return(0);    &#125;else  &#123;        int i;                                  /* 局部变量 */        l = 0;        cout &lt;&lt; endl &lt;&lt; &quot;\n当前的状态是安全的!安全序列为:&quot; &lt;&lt; endl;        cout &lt;&lt; &quot;进程&quot; &lt;&lt; &quot;(&quot; &lt;&lt; p[0] &lt;&lt; &quot;)&quot;;     /* 输出安全序列 */        for ( i = 1; i &lt; n; i++ )            cout &lt;&lt; &quot;-&gt;&gt;&quot; &lt;&lt; &quot;进程&quot; &lt;&lt; &quot;(&quot; &lt;&lt; p[i] &lt;&lt; &quot;)&quot;;        for ( i = 0; i &lt; n; i++ )            Finish[i] = 0;                  /* 所有进程置为未分配状态 */        cout &lt;&lt; endl;    &#125;    bank();                                         /* 调用银行家算法函数 */    cout &lt;&lt; &quot;\t\t 演示计算完毕&quot; &lt;&lt; endl;    return(0);&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 其他算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Node环境+Hexo环境的搭建</title>
      <link href="/blog/yo1xhz/"/>
      <url>/blog/yo1xhz/</url>
      
        <content type="html"><![CDATA[<div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">前言：搭建node环境，在此基础上安装hexo模块以搭建个人静态网站。</div><h2 id="一、环境安装与配置"><a href="#一、环境安装与配置" class="headerlink" title="一、环境安装与配置"></a>一、环境安装与配置</h2><h3 id="Node-的下载与安装"><a href="#Node-的下载与安装" class="headerlink" title="Node 的下载与安装"></a>Node 的下载与安装</h3><ul><li>下载<a href="https://nodejs.org/en/">Node.js</a></li><li><strong>设置模块的安装路径，不然会默认在 C 盘，不好管理，也占系统盘存储空间</strong><blockquote><p>nodejs 文件夹中新建两个空文件夹 node_cache、node_global</p></blockquote></li></ul><pre><code class="powershell">npm config set prefix &quot;D:\nodejs\node_global&quot;npm config set cache &quot;D:\nodejs\node_cache&quot;</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1624969463695-0751b555-3284-469d-9a94-d721eb6c2ff7.png#align=left&display=inline&height=125&id=u454edc1a&margin=%5Bobject%20Object%5D&name=image.png&originHeight=250&originWidth=1440&size=23661&status=done&style=none&width=720" alt="image.png"></p><ul><li>环境变量的配置<blockquote><p>需要用到的路径<br>D:\nodejs\node_global\node_modules<br>D:\nodejs\node_global</p></blockquote></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1624969533021-b8d200d6-eb5e-44f1-8e7c-f62914d05bb2.png#align=left&display=inline&height=388&id=u26c06f0e&margin=%5Bobject%20Object%5D&name=image.png&originHeight=776&originWidth=1698&size=119254&status=done&style=none&width=849" alt="image.png"></p><h3 id="安装-Hexo"><a href="#安装-Hexo" class="headerlink" title="安装 Hexo"></a>安装 Hexo</h3><pre><code class="bash">npm install -g hexo-cli</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1624970023639-a627549b-bd0f-4ca6-ad98-448cda506627.png#align=left&display=inline&height=122&id=u95259d87&margin=%5Bobject%20Object%5D&name=image.png&originHeight=244&originWidth=1440&size=45394&status=done&style=none&width=720" alt="image.png"></p><blockquote><p>同时也可以看到全局所安装的模块在刚刚设定的路径下面</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1624970066364-8a42b037-868e-4e72-9644-1ed15b81b482.png#align=left&display=inline&height=88&id=ucbce49f7&margin=%5Bobject%20Object%5D&name=image.png&originHeight=176&originWidth=539&size=7975&status=done&style=none&width=269.5" alt="image.png"></p><h3 id="申请-GitHub-Pages"><a href="#申请-GitHub-Pages" class="headerlink" title="申请 GitHub Pages"></a>申请 GitHub Pages</h3><p>在 github 上申请 github pages，在账户下创建一个仓库名为 <code>wztlink1013.github.io</code>的仓库，则这个仓库下的 main 分支下的前端代码就会被发布成成网页（必须要由 index.html 文件）。</p><blockquote><p>访问：<a href="https://wztlink1013.github.io/">https://wztlink1013.github.io</a></p></blockquote><h2 id="二、搭建博客"><a href="#二、搭建博客" class="headerlink" title="二、搭建博客"></a>二、搭建博客</h2><h3 id="创建并初始化文件夹"><a href="#创建并初始化文件夹" class="headerlink" title="创建并初始化文件夹"></a>创建并初始化文件夹</h3><blockquote><p>这里面所有文件就相当于所搭建博客网页所有源文件</p></blockquote><p>进入文件夹输入</p><pre><code class="bash">hexo init</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616727001925-a02dabbf-4792-492e-bf5d-fed01a85eafc.png#align=left&display=inline&height=120&id=WSl3w&margin=%5Bobject%20Object%5D&name=image.png&originHeight=239&originWidth=1894&size=46813&status=done&style=none&width=947" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616727028761-75106936-43e9-4879-9c25-4596074efc43.png#align=left&display=inline&height=436&id=omNqC&margin=%5Bobject%20Object%5D&name=image.png&originHeight=872&originWidth=1894&size=154103&status=done&style=none&width=947" alt="image.png"></p><ul><li>文件夹下个文件的功能</li></ul><pre><code>node_modules：各种插件的安装文件夹scaffolds：模板文件夹（new的对象的模板）source：资源文件夹themes：主题文件夹（相当于“衣裳”）_config.yml：站点配置文件package.json：应用程序的信息</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616727087774-de9b7013-31f1-4f4b-8018-4dc47b46d075.png#align=left&display=inline&height=517&id=Hho9g&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1034&originWidth=1920&size=866676&status=done&style=none&width=960" alt="image.png"></p><h3 id="相关命令"><a href="#相关命令" class="headerlink" title="相关命令"></a>相关命令</h3><pre><code class="bash">hexo clean   #清除缓存，网页正常情况下可以忽略此条命令hexo n &quot;博客名称&quot;  # hexo new &quot;博客名称&quot;hexo p  # hexo publishhexo g  # hexo generate  # 生成静态网页hexo s  # hexo server  # 启动服务预览；Hexo 会监视文件变动并自动更新，无须重启服务器。        hexo server -s   #静态模式        hexo server -p 5000   #更改端口        hexo server -i 192.168.1.1   #自定义IPhexo d  # hexo deploy  # 部署                hexo deploy --message &quot;哈哈，hexo deploy --message 双引号内容就可以提交commit信息了&quot;</code></pre>]]></content>
      
      
      <categories>
          
          <category> ✨其他 </category>
          
          <category> 玩转博客 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C/C++遗忘知识总结</title>
      <link href="/blog/uakfgc/"/>
      <url>/blog/uakfgc/</url>
      
        <content type="html"><![CDATA[<div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">相当于记个流水帐了~菜鸡永远没有对任何知识都会的时候</div><p><img src="https://cdn.nlark.com/yuque/0/2021/gif/1484158/1618304475795-4149058a-4d7c-49b6-8956-e22568cb4888.gif#align=left&display=inline&height=151&margin=%5Bobject%20Object%5D&name=huaji-779c5947261d2633.gif&originHeight=151&originWidth=218&size=163714&status=done&style=none&width=218" alt="huaji-779c5947261d2633.gif"></p><h2 id="C-指针"><a href="#C-指针" class="headerlink" title="C 指针"></a>C 指针</h2><p>相关概念的理解容易混淆，记住之前学习理解的一个准则！<code>*p 的理解意义就是p 所指向的那个东西</code></p><ul><li>取地址符 <code>&amp;</code></li><li>解引用运算符 <code>*</code><blockquote><p>参考：</p><ul><li><a href="https://blog.csdn.net/soonfly/article/details/51131141">https://blog.csdn.net/soonfly/article/details/51131141</a></li></ul></blockquote></li></ul><ul><li>有 3 个用途<blockquote><ol><li>乘号（Multiply）： 2*3 就是 6</li><li>声明指针（Pointer Statement）： int a =5; int* ptr=&a;就是声明变量 a 是 5，把 a 的地址附到指针 ptr 上</li><li>解引用 （Dereference）： <em>ptr 单独拿出来就是找出 ptr 指针指向的值，按照第二点的说法就是 5.<br>&amp;叫做取地址符号<br>• 一般指针只能接受一个内存地址而不能接受一个值<br>• int a =5; int</em> ptr=a;就是错误的，指针不能接受一个值<br>• int a =5; int* ptr=&a;才对，把 a 的地址给指针 ptr<br>指针理解的话你可以这么想。<br>你问我书在哪。我说在书架第一层。<br>你问我书在哪。我说在那个桌子上的纸条上写着位置。这样的话那个纸条就是指针。<br>纸条上写着，书在书架第一层，这就是地址，他并不是书的实体<br>真正的书在书架第一层，顺着地址去找吧</li></ol></blockquote></li></ul><h2 id="C-结构体"><a href="#C-结构体" class="headerlink" title="C 结构体"></a>C 结构体</h2><h3 id="一些概念"><a href="#一些概念" class="headerlink" title="一些概念"></a>一些概念</h3><blockquote><ul><li>结构体:构造（定义新的数据类型）</li><li>结构体变量:定义（两种）；结构体变量访问结构体里面的成员：<code>.</code>；指针访问成员的时候<code>-&gt;</code></li><li>结构体数组：变量很多</li><li>结构体指针：指向结构体变量的指针，定义：<code>struct Student *p</code>；指向结构体数组的指针</li></ul></blockquote><ul><li>C 里面的<strong>结构体、共用体、枚举体</strong>根据这几类来构造新的数据类型，比如链表的初始实现，就是利用指针和结构体来实现</li><li><strong>typedef</strong>给结构体制定新的类型名  eg：计数专用变量<code>typedef int Count</code></li></ul><h3 id="单链表的存储结构"><a href="#单链表的存储结构" class="headerlink" title="单链表的存储结构"></a>单链表的存储结构</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616502801770-db341786-acc5-4024-966b-8793c339cc89.png#align=left&display=inline&height=116&margin=%5Bobject%20Object%5D&name=image.png&originHeight=231&originWidth=989&size=38948&status=done&style=none&width=494.5" alt="image.png"><br>上面的代码可以分解为：</p><pre><code class="cpp">typedef struct LNode LNode;         //将结构体类型struct LNode重命名为LNodetypedef struct LNode *LinkList;     //将struct LNode *重命名为LinkList</code></pre><blockquote><p>创建的时候，可以有下面三种方法<br>【L 是指向结构体类型（struct LNode 型）指针变量】</p></blockquote><ol><li>LinkList L;</li><li>struct LNode * L</li><li>LNode *L = new LNode;</li></ol><p>只不过是用第 1 种方式创建更加简单，具体的使用，new 的时候一般使用前者，定义一个该类型变量的时候一般用后者</p><p>LinkList L；理解：一个结构体变量的指针就是该结构体变量所占据的内存段的起始地址，而我定义的是 LinkList 而不是 int，只是和计算机说明我需要的内存不一样了这种作用</p><p>参考：<a href="https://blog.csdn.net/GRoads/article/details/104155255">https://blog.csdn.net/GRoads/article/details/104155255</a></p><h2 id="C-的函数参数引用-amp-理解"><a href="#C-的函数参数引用-amp-理解" class="headerlink" title="C++的函数参数引用&amp;理解"></a>C++的函数参数引用&amp;理解</h2><p>在学习单链表的时候，编写前插法的函数，函数参数传递的是&amp;L 而不是*L，这个相关知识的解释，参考这个帖子<a href="https://fishc.com.cn/thread-98021-1-1.html">https://fishc.com.cn/thread-98021-1-1.html</a>，里面的榜首答案下图这么一句话<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616504219420-872367f1-be2c-4afe-89e5-12ecbfe817dc.png#align=left&display=inline&height=165&margin=%5Bobject%20Object%5D&name=image.png&originHeight=330&originWidth=1658&size=55429&status=done&style=stroke&width=829" alt="image.png"></p><ul><li>函数传递&amp;：为引用参数，传递给引用于传递指针的效果是一样的，【只是个别名，不是取值！！】<a href="https://blog.csdn.net/weibo1230123/article/details/78910179">https://blog.csdn.net/weibo1230123/article/details/78910179</a></li><li>代码实操以下</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616504292045-802c3bc2-ebbc-49aa-8764-7852def70548.png#align=left&display=inline&height=219&margin=%5Bobject%20Object%5D&name=image.png&originHeight=438&originWidth=755&size=47238&status=done&style=none&width=377.5" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616504341193-3d82d795-ebab-42c9-bc2c-3b6f0fe04e2e.png#align=left&display=inline&height=214&margin=%5Bobject%20Object%5D&name=image.png&originHeight=428&originWidth=854&size=49466&status=done&style=none&width=427" alt="image.png"><br>图 1 是可以运行的，图 2 不可以（传递错误的格式）<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616504560727-4aacc3bb-139a-46be-aafb-5ba50bbae0b3.png#align=left&display=inline&height=107&margin=%5Bobject%20Object%5D&name=image.png&originHeight=214&originWidth=1062&size=77047&status=done&style=none&width=531" alt="image.png"><br>函数参数的传递，还要好好再复习复习……</p><h2 id="类-C-中-new、delete"><a href="#类-C-中-new、delete" class="headerlink" title="类 C 中 new、delete"></a>类 C 中 new、delete</h2><p>在数据结构课程里面的类 C 语言里面，new、delete 分别为在内存中分配/释放空间</p><h2 id="C-值-STL"><a href="#C-值-STL" class="headerlink" title="C++值 STL"></a>C++值 STL</h2><h3 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h3><ul><li>函数模板</li><li>类模板<br>STL 概述当中，vector 容器，顺序容器：向量 vector、列表 list、双端队列 deque<blockquote><p><a href="https://www.cnblogs.com/mr-wid/archive/2013/01/22/2871105.html">https://www.cnblogs.com/mr-wid/archive/2013/01/22/2871105.html</a></p></blockquote></li></ul><h2 id="C-之-define"><a href="#C-之-define" class="headerlink" title="C 之#define"></a>C 之#define</h2><p>C 语言中，可以用 #define 定义一个标识符来表示一个常量。其特点是：定义的标识符不占内存，只是一个临时的符号，预编译后这个符号就不存在了。</p><p>预编译又叫预处理。预编译不是编译，而是编译前的处理。这个操作是在正式编译之前由系统自动完成的。</p><ul><li><p><a href="http://c.biancheng.net/view/187.html">http://c.biancheng.net/view/187.html</a></p></li><li><p>const 定义常量</p></li><li><p>之前 C 语言里面用的是宏定义#define Π 3.1415927，但是宏定义有时候太“死板”</p></li></ul><h2 id="C-头文件"><a href="#C-头文件" class="headerlink" title="C++头文件"></a>C++头文件</h2><div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">- C语言中的头文件以.h后缀，C++中头文件不加后缀。- C语言中的string.h头文件，C++用cstring，- C语言中的math头文件，C++使用cmath头文件<p>这不只是形式上的改变，其实现也有所不同。</div></p><h3 id="using-namespace-std"><a href="#using-namespace-std" class="headerlink" title="using namespace std;"></a>using namespace std;</h3><p>C++标准库中所有标识符并定义于一个名为 std 的命名空间中，std 称为标准命名空间（standard，标准的）。</p><h3 id="iostream"><a href="#iostream" class="headerlink" title="iostream"></a>iostream</h3><p>C++中的输入、输出头文件 iostream<br>i ——input 输入<br>o ——output 输出<br>stream —— 流</p><h3 id="iomanip"><a href="#iomanip" class="headerlink" title="iomanip"></a>iomanip</h3><table><thead><tr><th>操作符</th><th>功能</th></tr></thead><tbody><tr><td>setfill(char c)</td><td>设置以 c 表示的填充字符</td></tr><tr><td>setprecision(int n)</td><td>设置以 n 表示的数值精度</td></tr><tr><td>setw(int n)</td><td>设置以 n 表示的域宽</td></tr></tbody></table><pre><code class="cpp">#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &lt;cmath&gt;using namespace std;int main()&#123;    double num=sqrt(3.0);    for (int i = 0; i &lt; 6; i++)&#123;        cout &lt;&lt;&quot;当精度为&quot;&lt;&lt;i&lt;&lt;&quot;时：&quot;&lt;&lt;setprecision(i)&lt;&lt;num&lt;&lt;endl;//设置不同的精度    &#125;    cout &lt;&lt; &quot;当前cout精度为：&quot; &lt;&lt;cout.precision() &lt;&lt; endl;    cout &lt;&lt; &quot;当前域宽：&quot; &lt;&lt;cout.width() &lt;&lt; endl;    cout &lt;&lt; &quot;==================================&quot;        &lt;&lt; &quot;\n&quot;;    cout &lt;&lt;setw(7)&lt;&lt;num &lt;&lt; endl; //默认是右对齐    cout &lt;&lt; &quot;当前填充字符：&quot; &lt;&lt; endl;    cout&lt;&lt;setfill(&#39;*&#39;) &lt;&lt;setw(10)&lt;&lt;num &lt;&lt; endl; //setfill()函数可以直接插入流中    return 0;&#125;</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1621218267138-b3d7bcad-1567-4448-9839-e339c6bcb922.png#align=left&display=inline&height=170&margin=%5Bobject%20Object%5D&name=image.png&originHeight=340&originWidth=720&size=32960&status=done&style=none&width=360" alt="image.png"></p><ul><li>参考：<a href="https://blog.csdn.net/akof1314/article/details/4625888">https://blog.csdn.net/akof1314/article/details/4625888</a></li></ul><h3 id="bits-stdc-h"><a href="#bits-stdc-h" class="headerlink" title="bits/stdc++.h"></a>bits/stdc++.h</h3><ul><li>万能头文件：几乎包含所有的可用到的 C++库函数</li><li>缺点<ul><li>编译时间慢，具有不可移植的问题，很多编译器和 oj 不支持，虽然现在 noip 支持了…</li><li>如果你用了 bits/stdc++.h，那么你很大几率就会用 using namespace std;而不是 using std::cin; using std::cout;这样的。这会导致你的某些变量或函数已经被包含了而你不知道（关键字作为函数名）</li><li>还有很重要的一点，就是用 bits 很占内存，某些卡内存的题根本用不了</li></ul></li><li>具体头文件内容</li></ul><pre><code class="cpp">// C++ includes used for precompiling -*- C++ -*-// Copyright (C) 2003-2013 Free Software Foundation, Inc.//// This file is part of the GNU ISO C++ Library.  This library is free// software; you can redistribute it and/or modify it under the// terms of the GNU General Public License as published by the// Free Software Foundation; either version 3, or (at your option)// any later version.// This library is distributed in the hope that it will be useful,// but WITHOUT ANY WARRANTY; without even the implied warranty of// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the// GNU General Public License for more details.// Under Section 7 of GPL version 3, you are granted additional// permissions described in the GCC Runtime Library Exception, version// 3.1, as published by the Free Software Foundation.// You should have received a copy of the GNU General Public License and// a copy of the GCC Runtime Library Exception along with this program;// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see// &lt;Licenses - GNU Project - Free Software Foundation&gt;./** @file stdc++.h *  This is an implementation file for a precompiled header. */// 17.4.1.2 Headers// C#ifndef _GLIBCXX_NO_ASSERT#include &lt;cassert&gt;#endif#include &lt;cctype&gt;#include &lt;cerrno&gt;#include &lt;cfloat&gt;#include &lt;ciso646&gt;#include &lt;climits&gt;#include &lt;clocale&gt;#include &lt;cmath&gt;#include &lt;csetjmp&gt;#include &lt;csignal&gt;#include &lt;cstdarg&gt;#include &lt;cstddef&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;ctime&gt;#if __cplusplus &gt;= 201103L#include &lt;ccomplex&gt;#include &lt;cfenv&gt;#include &lt;cinttypes&gt;#include &lt;cstdalign&gt;#include &lt;cstdbool&gt;#include &lt;cstdint&gt;#include &lt;ctgmath&gt;#include &lt;cwchar&gt;#include &lt;cwctype&gt;#endif// C++#include &lt;algorithm&gt;#include &lt;bitset&gt;#include &lt;complex&gt;#include &lt;deque&gt;#include &lt;exception&gt;#include &lt;fstream&gt;#include &lt;functional&gt;#include &lt;iomanip&gt;#include &lt;ios&gt;#include &lt;iosfwd&gt;#include &lt;iostream&gt;#include &lt;istream&gt;#include &lt;iterator&gt;#include &lt;limits&gt;#include &lt;list&gt;#include &lt;locale&gt;#include &lt;map&gt;#include &lt;memory&gt;#include &lt;new&gt;#include &lt;numeric&gt;#include &lt;ostream&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;sstream&gt;#include &lt;stack&gt;#include &lt;stdexcept&gt;#include &lt;streambuf&gt;#include &lt;string&gt;#include &lt;typeinfo&gt;#include &lt;utility&gt;#include &lt;valarray&gt;#include &lt;vector&gt;#if __cplusplus &gt;= 201103L#include &lt;array&gt;#include &lt;atomic&gt;#include &lt;chrono&gt;#include &lt;condition_variable&gt;#include &lt;forward_list&gt;#include &lt;future&gt;#include &lt;initializer_list&gt;#include &lt;mutex&gt;#include &lt;random&gt;#include &lt;ratio&gt;#include &lt;regex&gt;#include &lt;scoped_allocator&gt;#include &lt;system_error&gt;#include &lt;thread&gt;#include &lt;tuple&gt;#include &lt;typeindex&gt;#include &lt;type_traits&gt;#include &lt;unordered_map&gt;#include &lt;unordered_set&gt;#endif</code></pre><p>C++</p><h2 id="【大一-C-和-C-笔记】"><a href="#【大一-C-和-C-笔记】" class="headerlink" title="【大一 C 和 C++笔记】"></a>【大一 C 和 C++笔记】</h2><div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">当时在OneNote的一些小记</div><h3 id="C-常用字符函数"><a href="#C-常用字符函数" class="headerlink" title="C 常用字符函数"></a>C 常用字符函数</h3><p>Printf()<br>Scanf()<br>Putchar()<br>Getchar()<br>Puts(str)<br>Gets(str)<br>Strcat(str1,str2)：连接字符串<br>复制函数：将 str2 复制给 str1<br>Strcpy(str1,str2)<br>在 C++里面会报错<br>解决 ①：将函数 strcpy 改成 strcpy_s,中间加一个参数——复制的长度</p><p>Strncpy(str1,str2,n)：复制函数，将 str2 的前 n 个字符复制给 str1<br>Strlen(str)：检测 str 的字符串长度<br>Fopen(文件名，使用文件方式）<br>fclose（文件指针）</p><h3 id="I-O-改进"><a href="#I-O-改进" class="headerlink" title="I/O 改进"></a>I/O 改进</h3><ul><li>scanf===cin&gt;&gt; &gt;&gt;endl;</li><li>Print===cout&lt;&lt; &lt;&lt;endl;</li><li>换行符：endl 和 “\n”</li></ul><h3 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h3><p>类的形式？<br>Class wuzutao<br>{<br>private：</p><pre><code>    public：    protect：&#125;；数据成员成员函数：    类内实现=和普通函数的实现一样    类外实现=void Date：：Display（）&#123;&#125;</code></pre><p>类定义对象？<br>① 花括号内定义<br>② 花括号外定义</p><p>访问对象？<br>访问的是类内的成员<br>① 圆点访问形式<br>② 指针访问形式</p><p>this 指针？<br>每个成员函数都会有一个特殊的隐含指针——this 指针。<br>调用形式：cout&lt;&lt;this&lt;year&lt;day&lt;&lt;endl;</p><p><strong>构造函数和析构函数</strong><br>构造函数的作用就是适当地给类进行初始化的作用<br>无参数的构造函数<br>带参数的构造函数</p><p>拷贝构造函数，这里不是太懂！<br>拷贝构造函数声明<br>拷贝构造函数定义和实现</p><p>析构函数<br>一般默认，如果自己写的话就是<br>析构函数的声明：<br><del>类名（）；<br>析构函数的定义和实现：<br>类名：：</del>类名（）{……}</p><h3 id="数据的共享和保护"><a href="#数据的共享和保护" class="headerlink" title="数据的共享和保护"></a>数据的共享和保护</h3><p><strong>数据共享 static</strong></p><ol><li>静态数据成员<br>声明：static 数据类型 静态数据成员名；<br>初始化在类结束和类中函数实现的中间<br>之后访问（通过类名/对象名来访问）：<br>私有的静态成员只能通过间接的方式来访问===静态成员函数<br>对象名.公有静态成员变量名<br>对象名::公有静态成员变量名</li><li>静态成员函数<br>没有 this 指针<br>声明：static 返回值类型 静态成员函数名（形参表）<br>之后访问（通过类名/对象名来访问）：<br>类名::静态成员函数名（实参表）<br>类名.静态成员函数名（实参表）</li></ol><p><strong>数据保护 const</strong></p><ol><li>常数据成员<br>有些时候，希望不用全局变量，因为这样不好移植，所以用到 const 场数据类型，相当于每次用不同场合用到这个类，都是这些用到这些固定的数据<br>一般结合 static 来避免数据赘余<br>eg：类 Circle 中<br>定义：const double PI；<br>初始化只能在构造函数后面的初始化列表中：Circle （double r=0）：PI（3.1415926）<ol><li>常成员函数<br>只访问类中的数据而不修改类中的数据成员，最好用到常成员函数<br>eg：只访问类中的半径<br>声明：Double GetRadius（）const；<br>实现：double Circle：：GetRadius（）const{……}</li><li>常对象<br>所定义的常对象 p1 在之后就不会被改变了<br>形式：const Person p1（17，“wu”）；</li></ol></li></ol><h3 id="类和类之间的关系"><a href="#类和类之间的关系" class="headerlink" title="类和类之间的关系"></a>类和类之间的关系</h3><p><strong>类的组合</strong><br>直观：B 类中有 A 类定义的对象</p><p>构造函数的顺序：<br>对象成员的构造函数<br>自身的构造函数</p><p>构造函数有参数的时候：<br>怎么个表现形式呢？<br><strong>B 类中 B 的构造函数后面带有 A 类在 B 类中所定义的对象，这个对象的参数用做左边 B 类构造函数的参数、</strong></p><p><strong>类的依赖</strong><br>赌徒和骰子，这就是一种依赖关系，如果用组合关系的话，就会影响到生命周期问题</p><p>Class 🎲{}；<br>Class 🕵️‍♂️<br>{<br>public：<br>Void play（🎲1，🎲2，🎲3）<br>{……}<br>}；<br><strong>类的继承和派生</strong><br>一、派生类的定义：<br>父类 class Base{}<br>派生子类：单一继承 class Derived：public Base{}；<br>多重继承 Class Derived：public Base1，pretect Base2{}；<br>继承的类型：<br>单一继承：只有一个基类<br>多重继承：有多个基类</p><p>继承方式：<br>private 继承：所有的数据成员都为子类的的私有成员<br>public 继承：父类的数据类型怎样，在子类类型不变<br>protect 继承：所有的数据成员和成员函数都为字类的保护成员<br>ps：① 父类的 private 数据成员和成员函数不能被子类所继承<br>② 一般很少用 protect 和 private 两种继承，因为两种改变了之前基类的访问属性，限制了这些的进一步派生，所以很少使用</p><p>二、派生类的构造和析构<br>构造和析构的调用顺序：<br>① 所有虚基类的构造函数<br>② 基类的构造函数<br>③ 对象成员的构造函数<br>④ 自身派生类的构造函数<br>ps：析构函数的调用顺序则正好相反、<br>虚基类保证调用一次构造函数。两个子类都有同一个基类的虚基类继承，构造函数只调用一次<br>带参数的构造函数：<br>子类里面，构造函数的初始化要连带着基类的构造函数的初始化<br>eg：classA(int a,int b,int c):classB(a*2),classC(a,b){}</p><p>三、同名冲突和解决方案<br>解决 ① 双冒号法：：<br>基类和子类当中有相同名字的数据成员和成员函数，<br>访问的时候：相同的名字：：数据成员/成员函数<br>解决 ② 定义虚基类 virtual<br>eg：class furniture{}；<br>Class sofa ：virtual public furniture{}；<br>Class bed：virtual public furniture{}；<br>Class sofabed：public sofa，public bed{}；</p><p>四、赋值兼容规则</p><h3 id="主函数"><a href="#主函数" class="headerlink" title="主函数"></a>主函数</h3><p>主函数 main()是程序的入口，每个程序都需要一个主函数。主函数返回值为 int 型。<br>int main()<br>{<br>cout&lt;&lt;”hello,world!”&lt;&lt;endl;<br>return 0;<br>}  <br>注意：程序末尾返回 0</p><h3 id=""><a href="#" class="headerlink" title=""></a></h3>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 非前端编程语言 </category>
          
          <category> CPlusPlus </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Git多账号同设备部署总结</title>
      <link href="/blog/uke79e/"/>
      <url>/blog/uke79e/</url>
      
        <content type="html"><![CDATA[<h2 id="部署多个-github-coding-等账号"><a href="#部署多个-github-coding-等账号" class="headerlink" title="部署多个 github+coding 等账号"></a>部署多个 github+coding 等账号</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>好处：一台设备可以使用多个 github 账号/github+coding 等等多平台托管/搭建两个静态博客</p><p>取消全局用户配置（每建立一个新文件夹，需要输入使用账号），建立多个 ssh 密匙（如果是 github 账号+coding 账号+gitee 账号等）</p><p>SSH 的公钥是 GitHub 连接本地仓库和远程仓库的标识，一个公钥只能对应一个 GitHub 账户，一个相同的公钥不能上传到不同的 GitHub 账户</p><p>一台电脑，可以生成多对公私钥，可以通过配置，将不同的公钥上传到不同的 GitHub 账号，那么就不存在单个公钥绑定多个 GitHub 账号的情况存在了</p><h3 id="多密匙生成"><a href="#多密匙生成" class="headerlink" title="多密匙生成"></a>多密匙生成</h3><ul><li>先进来该文件夹（忽略图片上写的字）<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1597632490897-11718be6-6492-4ead-a739-1c92af25c648.png#crop=0&crop=0&crop=1&crop=1&height=372&id=rIi3X&originHeight=372&originWidth=1215&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=0&status=done&style=none&title=&width=1215"></li><li>创建新密匙方法一（首选）</li></ul><p><code>ssh-keygen -t rsa -f ~/.ssh/这里是新密钥名称 -C &quot;这里是你的邮箱&quot;</code></p><p>注意区别新密钥名称和旧密钥名称，不要相同！！</p><ul><li>创建新密匙方法二</li></ul><p>输入这个：<code>ssh-keygen -t rsa -C &quot;这里是你的邮箱&quot;</code></p><p>出现这两句：<br><code>Generating public/private rsa key pair.</code></p><p><code>Enter file in which to save the key (/c/Users/you/.ssh/id_rsa):</code></p><p>注意此时需要你输入新密钥的名称，同样要注意区别新密钥名称和旧密钥名称，不要相同，之后再两次回车。</p><h3 id="配置-config"><a href="#配置-config" class="headerlink" title="配置 config"></a>配置 config</h3><p>.ssh 根文件夹下没有 config 文件，需要新建</p><ul><li>新建 config 文件方法一</li></ul><p>在.ssh 根路径下键入该命令<code>touch config</code></p><ul><li>新建 config 文件方法二</li></ul><p>记事本新建文件 config 文件！！没有后缀</p><ul><li>输入内容</li></ul><pre><code>#第一个账号，默认使用的账号，不用做任何更改Host github.com    HostName github.com    User git    IdentityFile ~/.ssh/id_rsa#第二个新账号，#&quot;xxxxxx&quot;为前缀名，可以任意设置，要记住，后面需要用到Host xxxxxx.github.com    HostName github.com    User git    IdentityFile ~/.ssh/这里是你创建的新密钥的名称</code></pre><pre><code># one(one@gmail.com)Host one.github.comHostName github.comPreferredAuthentications publickeyIdentityFile ~/.ssh/id_rsa_oneUser one# two(two@gmail.com)Host two.github.comHostName github.comPreferredAuthentications publickeyIdentityFile ~/.ssh/id_rsa_twoUser two</code></pre><pre><code>Host myhost（这里是自定义的host简称，以后连接远程服务器就可以用命令ssh myhost）HostName 主机名可用ip也可以是域名(如:github.com或者bitbucket.org)Port 服务器open-ssh端口（默认：22,默认时一般不写此行）PreferredAuthentications   配置登录时用什么权限认证--可设为publickey,password publickey,keyboard-interactive等IdentityFile 证书文件路径（如~/.ssh/id_rsa_*)User 登录用户名(如：git)</code></pre><p>每个账号单独配置一个 Host，每个 Host 要取一个别名，一般为每个 Host 主要配置 HostName 和 IdentityFile 两个属性，配置完保存即可。</p><p>Host 的名字可以自定义名字，不过这个会影响 git 相关命令，例如：Host mygithub 这样定义的话，使用命令 git clone git@mygithub:PopFisher/AndroidRotateAnim.git，git@后面紧跟的名字改为 mygithub</p><blockquote><p><strong>mine</strong> &gt; <img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1597632490639-fd51b09d-c037-4fdb-bad3-e2e1d56d7aed.png#crop=0&crop=0&crop=1&crop=1&height=637&id=uEqZT&originHeight=637&originWidth=999&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=0&status=done&style=none&title=&width=999"></p></blockquote><h3 id="部署-SSH-key"><a href="#部署-SSH-key" class="headerlink" title="部署 SSH key"></a>部署 SSH key</h3><p>将根文件夹下的<code>wztlink1013.pub</code>文件复制到 github 上，coding/gitee 类似</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1597632490332-674f64ec-d09e-4351-a3cd-dbebc15a3a32.png#crop=0&crop=0&crop=1&crop=1&height=872&id=P7hWK&originHeight=872&originWidth=1839&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=0&status=done&style=none&title=&width=1839"><br>title 可以随便填</p><h3 id="清缓存，添-agent"><a href="#清缓存，添-agent" class="headerlink" title="清缓存，添 agent"></a>清缓存，添 agent</h3><p>在根目录下</p><pre><code>ssh-add -Dssh-add xxxxxx #旧密钥名称，一般是id_rsassh-add xxxxxx #新创建的密钥名称</code></pre><p>如果执行以上命令出现错误：<code>Could not open a connection to your authentication agent.</code>，那么就需要先执行<code>ssh-agent bash</code>，再执行以上命令</p><h3 id="验证是否配置成功"><a href="#验证是否配置成功" class="headerlink" title="验证是否配置成功"></a>验证是否配置成功</h3><p>一下第一个是之前默认的 github 账号，默认即可，第二个是添加的</p><pre><code>ssh -T git@github.comssh -T git@xxxxxxx.github.com</code></pre><p>出现<code>Hi 你的用户名! You&#39;ve successfully authenticated, but GitHub does not provide shell access.</code>则成功。</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ul><li>取消全局用户名和邮箱配置（如果已经设置了全局的话）</li></ul><pre><code>git config --global --unset user.namegit config --global --unset user.email</code></pre><ul><li>clone</li></ul><p>原来：<code>git clone git@github.com: wztlink1013/learngit.git</code></p><p>现在：</p><pre><code>git clone git@wztlink1013.github.com: wztlink1013/learngit.gitgit clone git@twicename.github.com: twicename/learngit.git</code></pre><ul><li>单独为每个 repo 设置 用户名/邮箱【以文件夹为单位】</li></ul><pre><code>git config user.name &quot;wztlink1013&quot;git config user.email &quot;2550374815@qq.com&quot;git config user.name &quot;twicename&quot;git config user.email &quot;123456789@qq.com&quot;</code></pre><p>如果报错：<code>fatal: not in a git directory</code>，说明没有进入.git 目录下，具体路径：其中.git 目录是隐藏的，需要你设置隐藏目录可见<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1597632490310-1580343b-946c-4d67-a063-d5cd11bc6136.png#crop=0&crop=0&crop=1&crop=1&height=105&id=oPGRx&originHeight=105&originWidth=925&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=0&status=done&style=none&title=&width=925"></p><p>执行<code>git config --list</code>查看设置是否成功</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://github.com/guobinhit/cg-blog/blob/master/articles/github/README.md">史上最简单的 GitHub 教程</a></li><li><a href="https://www.itrhx.com/2019/01/18/A16-deploy-two-or-more-hexo-blogs/">一台电脑使用两个/多个 GitHub 账号部署两个/多个 Hexo 博客</a></li><li><a href="https://blog.csdn.net/u013716535/article/details/78621775">一台电脑两个 github 账号</a></li><li><a href="https://blog.csdn.net/IT_xiao_bai/article/details/88563103">一台电脑上的 git 同时使用两个 github 账户</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> Git+GitHub </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>基本语法</title>
      <link href="/blog/ewt4nc/"/>
      <url>/blog/ewt4nc/</url>
      
        <content type="html"><![CDATA[<div style="background: #FFF3F3;padding:10px;border: 1px solid #DEB8BE;border-radius:5px;margin-bottom:5px;">之前从OneNote转过来的笔记，暂未排版整理，日后整理……咕咕咕~</div><h2 id="一、基本语法"><a href="#一、基本语法" class="headerlink" title="一、基本语法"></a>一、基本语法</h2><ol><li><p>大事谷歌；小事百度【建立良好的编程式思维】</p></li><li><p>PEP8 中的一些良好约定【编程规范】</p></li><li><p>字符串格式化：<br>print(‘%s–%d–%s’%(‘wuzutao’,20,’尼采般地抒情’))<br>a. %i 是什么格式的那啥？‘</p></li><li><p>强制性类型转换：类 C</p></li><li><p>时间和日期：<br>from datetime import datetime<br>dt=datetime(2019,5,12,9,20)<br>print(dt.year,dt.month,dt.day)</p><blockquote><p>2019  5  12<br>dt.strftime(‘%Y/%m/%d %H:%M’)<br>#datetime 格式转化为字符串<br>‘2019/05/12 09:20’<br>datetime.strptime(‘20161203’, ‘%Y%m%d’) #字符串转化为 datetime 格式<br>datetime.datetime(2016, 12, 3, 0, 0)</p></blockquote></li><li><p>pass 函数<br>def f():<br>   #TODO: test pass<br>   pass</p></li><li><p>异常的处理<br>def test(x,y):<br>   try:<br>       print(y/x)<br>   except:<br>       print(‘输入的信息有误！’)</p><blockquote><p>test(2,8)<br>test(‘e’,8)</p></blockquote></li><li><p>range 和 range 的区别！！！</p></li><li><p>对象传递和拷贝【类似 C 语言中的指针】 #变量传递、列表传递和 C 类似 #深拷贝和浅拷贝<br>import copy<br>a = [[1, 2, 3], [4, 5, 6]]<br>b = a<br>c = copy.copy(a)<br>d = copy.deepcopy(a)<br>print (‘a-id:’,id(a))#id 相当于内存里面的地址<br>print (‘b-id:’,id(b))<br>print (‘c-id:’,id(c))<br>print (‘d-id:’,id(d))<br>a.append(15)<br>a[1][2] = 10<br>print (a)<br>print (b)<br>print (c)<br>print (d)</p></li><li><p>a-id: 2171119139144<br>b-id: 2171119139144<br>c-id: 2171119848136<br>d-id: 2171119140744<br>[[1, 2, 3], [4, 5, 10], 15]<br>[[1, 2, 3], [4, 5, 10], 15]<br>[[1, 2, 3], [4, 5, 10]]<br>[[1, 2, 3], [4, 5, 6]]</p></li></ol><h2 id="二、数据结构"><a href="#二、数据结构" class="headerlink" title="二、数据结构"></a>二、数据结构</h2><h3 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h3><pre><code>    ○ #转换为元组（list-&gt;tuple, string-&gt;tuple）    l = [1, 2, 3]    print (tuple(l))    str = (&#39;Hello ChinaHadoop&#39;)    print (tuple(str))    &gt;&gt;&gt;(1, 2, 3) (&#39;H&#39;, &#39;e&#39;, &#39;l&#39;, &#39;l&#39;, &#39;o&#39;, &#39; &#39;, &#39;C&#39;, &#39;h&#39;, &#39;i&#39;, &#39;n&#39;, &#39;a&#39;, &#39;H&#39;, &#39;a&#39;, &#39;d&#39;, &#39;o&#39;, &#39;o&#39;, &#39;p&#39;)    ○ tup1 = (1, 2, 3)    #嵌套元组:    tup2 = ((1, 2, 3), (4, 5))    print (tup2)    #合并元组:    tup1 + tup2    ○ #拆包    def test_1():        r=(2,4,5,32)        return r    a, b, _, f=test_1()    print(f)    &gt;&gt;&gt; 32    ○ # 元组列表迭代    tuple_lst = [(1, 2), (3, 4), (5, 6)]    for x, y in tuple_lst:        print (x+y)    &gt;&gt;&gt;3   7   11    ○ # 计数器    列表/元组.(&#39;需要查找里面的某个对象的个数&#39;)</code></pre><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><pre><code>    ○ list里面可以有不同类型的元素    ○ #合并列表    lst_1=[352,2352,3,556]    lst_2=[&#39;gew&#39;,&#39;f&#39;]    &gt;lst_3 = lst_1 + lst_2    &gt;lst_1.extend(lst_2)    ○ #sort函数和sorted函数    list_1=[23,54,346,222,4,1]    print(list_1.sort())     #查查版本    print(sorted(list_1))  #sorted是新起的一个列表    lst_6 = [&#39;Welcome&#39;, &#39;to&#39;, &#39;Python&#39;, &#39;Data&#39;, &#39;Analysis&#39;, &#39;Course&#39;]    lst_6.sort()    print (lst_6)【!!!!打印出来是none===查查版本】    &gt;&gt;&gt;[&#39;Analysis&#39;, &#39;Course&#39;, &#39;Data&#39;, &#39;Python&#39;, &#39;Welcome&#39;, &#39;to&#39;]    lst_6.sort(key = len, reverse=True)    print (lst_6)    &gt;&gt;&gt;[&#39;Analysis&#39;, &#39;Welcome&#39;, &#39;Course&#39;, &#39;Python&#39;, &#39;Data&#39;, &#39;to&#39;]</code></pre><h3 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h3><pre><code>    ○ #合并字典    dict1 = &#123;1:&#39;huhuhu&#39;&#125;    dict2 = &#123;4: &#39;new1&#39;, 5: &#39;news&#39;&#125;    dict1.update(dict2)    ○ #通过多个列表创建字典    dict_3 = &#123;&#125;    l1 = [32,543,6,2,7,4]    l2 = reversed(l1)    for i1, i2 in zip(l1, l2):        dict_3[i1] = i2    print (dict_3)    &gt;&gt;&gt;&#123;32: 4, 543: 7, 6: 2, 2: 6, 7: 543, 4: 32&#125;    &#39;&#39;&#39;hash函数来判断某个对象是否可以做键&#39;&#39;&#39;    ○ &#39;&#39;&#39;位置赋值；默认赋值；关键字赋值——format&#39;&#39;&#39;    &#39;&#39;&#39;遍历字典的方式变了：keys，values，items&#39;&#39;&#39;    天行九歌=&#123;&#39;韩非&#39;:&#39;逆鳞&#39;,&#39;卫庄&#39;:&#39;鲨齿&#39;,&#39;盖聂&#39;:&#39;渊虹&#39;&#125;    print(天行九歌)    for ren,jian in 天行九歌.items():        print(&#39;&#123;&#125;--&#123;&#125;&#39;.format(ren,jian))    &gt;&gt;&gt;    &#123;&#39;韩非&#39;: &#39;逆鳞&#39;, &#39;卫庄&#39;: &#39;鲨齿&#39;, &#39;盖聂&#39;: &#39;渊虹&#39;&#125;</code></pre><h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><pre><code>    ○ a1=[1,3,4,1,35,2352,75]    b1=[3,2352,24354,4332432,54]    a=set(a1)    b=set(b1)    print(a)    print(b)    a | b#并；a &amp; b#交；a - b#呃。。。；a ^ b#呃。。。；    a.issubset(b)#判断子集    &gt;&gt;&gt;False    a.issuperset(b)#判断父集    &gt;&gt;&gt;False</code></pre><h2 id="三、高级特性"><a href="#三、高级特性" class="headerlink" title="三、高级特性"></a>三、高级特性</h2><h3 id="推导式"><a href="#推导式" class="headerlink" title="推导式"></a>推导式</h3><pre><code>    ○ str_lst = [&#39;Welcome&#39;, &#39;to&#39;, &#39;Python&#39;, &#39;Data&#39;, &#39;Analysis&#39;, &#39;Course&#39;]    result = [x.upper() for x in str_lst if len(x) &gt; 4]    print (result)    &gt;&gt;&gt;[&#39;WELCOME&#39;, &#39;PYTHON&#39;, &#39;ANALYSIS&#39;, &#39;COURSE&#39;]</code></pre><h3 id="多函数模式"><a href="#多函数模式" class="headerlink" title="多函数模式"></a>多函数模式</h3><pre><code>    ○ str_lst = [&#39;$1.123&#39;, &#39; $1123.454&#39;, &#39;$899.12312&#39;]    def remove_space(str):        &quot;&quot;&quot;            remove space        &quot;&quot;&quot;        str_no_space = str.replace(&#39; &#39;, &#39;&#39;)        return str_no_space    def remove_dollar(str):        &quot;&quot;&quot;            remove $        &quot;&quot;&quot;        if &#39;$&#39; in str:            return str.replace(&#39;$&#39;, &#39;&#39;)        else:            return str    def clean_str_lst(str_lst, operations):        &quot;&quot;&quot;            clean string list        &quot;&quot;&quot;        result = []        for item in str_lst:            for op in operations:                item = op(item)            result.append(item)        return result    clean_operations = [remove_space, remove_dollar]    result = clean_str_lst(str_lst, clean_operations)    print (result)    &gt;&gt;&gt;[&#39;1.123&#39;, &#39;1123.454&#39;, &#39;899.12312&#39;]</code></pre><h3 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h3><pre><code>    ○ str_lst = [&#39;Welcome&#39;, &#39;to&#39;, &#39;Python&#39;, &#39;Data&#39;, &#39;Analysis&#39;, &#39;Course&#39;]    str_lst.sort(key=lambda x:len(x)) # sort by length    print (str_lst)    str_lst.sort(key=lambda x:x[-1]) # sort by the last letter    print (str_lst)    &gt;&gt;&gt;    [&#39;to&#39;, &#39;Data&#39;, &#39;Python&#39;, &#39;Course&#39;, &#39;Welcome&#39;, &#39;Analysis&#39;]    [&#39;Data&#39;, &#39;Course&#39;, &#39;Welcome&#39;, &#39;Python&#39;, &#39;to&#39;, &#39;Analysis&#39;]</code></pre><h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><pre><code>    ○ def gen_test():        for i in range(3):            yield i    gen = gen_test() #此时不执行生成器    type(gen)    for i in gen:        print(i)    #用意何在呢？？！！    &gt;&gt;&gt;0  1  2</code></pre><h2 id="四、常用函数"><a href="#四、常用函数" class="headerlink" title="四、常用函数"></a>四、常用函数</h2><h3 id="序列函数-amp-zip-使用"><a href="#序列函数-amp-zip-使用" class="headerlink" title="序列函数&amp;zip 使用"></a>序列函数&amp;zip 使用</h3><pre><code>    a. enumerate函数    list_11 = [&#39;Welcome&#39;, &#39;to&#39;, &#39;Python&#39;, &#39;Data&#39;, &#39;Analysis&#39;, &#39;Course&#39;]    for i, item in enumerate(lst_6):        print (&#39;%i-%s&#39; %(i, item))    &gt;&gt;&gt;    0-Analysis    1-Welcome    2-Course    3-Python    4-Data    5-to    str_dict = dict((i, item) for i, item in enumerate(list_11))    print (str_dict)    &gt;&gt;&gt;&#123;0: &#39;Welcome&#39;, 1: &#39;to&#39;, 2: &#39;Python&#39;, 3: &#39;Data&#39;, 4: &#39;Analysis&#39;, 5: &#39;Course&#39;&#125;    b. zip压缩    lst_6 = [&#39;Welcome&#39;, &#39;to&#39;, &#39;Python&#39;, &#39;Data&#39;, &#39;Analysis&#39;, &#39;Course&#39;]    lst_8 = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]    zip_lst = zip(lst_6, lst_8)    print(list(zip_lst))    #方式一：直接转化为列表    print(dict(list(zip_lst)))    #方式二：转化为字典    for i in zip_lst:        print (i)    #方式三：直接遍历    解压：    print(*zip_lst)    print(lst_6)    c. reversed逆序输出</code></pre><h3 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h3><pre><code>    a. #函数可以作为变量使用;也可以将函数作为参数使用    import math    def func_add(x, y, f):        &quot;&quot;&quot;            functional addition        &quot;&quot;&quot;        return f(x) + f(y)    print (func_add(4, 25, math.sqrt))    print (func_add(-4, 25, abs))    &gt;&gt;&gt;7.0    29</code></pre><h3 id="map-和-reduce"><a href="#map-和-reduce" class="headerlink" title="map 和 reduce"></a>map 和 reduce</h3><pre><code>    a. &#39;&#39;&#39;map函数&#39;&#39;&#39;    list_1=[1,4,9]    aaa = [x**2 for x in list_1]    print (aaa)    bbb = map(math.sqrt, aaa)    print (bbb)    &gt;&gt;&gt;    [1, 16, 81]</code></pre><p>&lt;map object at 0x000002145B2B77F0&gt;</p><h3 id="filter-函数"><a href="#filter-函数" class="headerlink" title="filter 函数"></a>filter 函数</h3><pre><code>    a. 天行=[&#39;韩非&#39;,&#39;卫庄&#39;,&#39;张良&#39;,&#39;盖聂&#39;,&#39;逆鳞&#39;]    def fx(x):        y=[&#39;逆鳞&#39;]        if x in y:            return x    filtered_lst = filter(fx,天行)    print(天行)    print(list(filtered_lst))    #注意python2和3的区别，很多时候要区别出来列表等序列，加上list很有必要    &gt;&gt;&gt;    [&#39;韩非&#39;, &#39;卫庄&#39;, &#39;张良&#39;, &#39;盖聂&#39;, &#39;逆鳞&#39;]     [&#39;逆鳞&#39;]</code></pre>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 非前端编程语言 </category>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>apply函数和入口函数</title>
      <link href="/blog/hy14ic/"/>
      <url>/blog/hy14ic/</url>
      
        <content type="html"><![CDATA[<h2 id="pandas-之-apply-函数"><a href="#pandas-之-apply-函数" class="headerlink" title="pandas 之 apply 函数"></a>pandas 之 apply 函数</h2><pre><code>DataFrame.apply(func, axis=0, broadcast=False, raw=False, reduce=None, args=(), **kwds)</code></pre><p>第一个参数，这个参数是函数，相当于 C/C++的函数指针。</p><p>这个函数需要自己实现，函数的传入参数根据 axis 来定，比如 axis = 1，就会把一行数据作为 Series 的数据<br>结构传入给自己实现的函数中，我们在函数中实现对 Series 不同属性之间的计算，返回一个结果，则 apply 函数<br>会自动遍历每一行 DataFrame 的数据，最后将所有结果组合成一个 Series 数据结构并返回。</p><h2 id="if-name-‘main’"><a href="#if-name-‘main’" class="headerlink" title="if name == ‘main’"></a>if <strong>name</strong> == ‘main’</h2><p><a href="https://zhuanlan.zhihu.com/p/34112508">参考：知乎用户</a></p>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 非前端编程语言 </category>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>qrcode和myqr花式二维码</title>
      <link href="/blog/ro3p67/"/>
      <url>/blog/ro3p67/</url>
      
        <content type="html"><![CDATA[<h2 id="一、官方文档"><a href="#一、官方文档" class="headerlink" title="一、官方文档"></a>一、官方文档</h2><p><a href="https://pypi.org/project/qrcode/">https://pypi.org/project/qrcode/</a></p><p><a href="https://pypi.org/project/MyQR/">https://pypi.org/project/MyQR/</a></p><h2 id="二、下载包"><a href="#二、下载包" class="headerlink" title="二、下载包"></a>二、下载包</h2><p>pip install qrcode  #方法多，体量小</p><p>pip install myqr    #操作简单，功能强大</p><h2 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h2><h3 id="qrcode-一行字二维码"><a href="#qrcode-一行字二维码" class="headerlink" title="qrcode 一行字二维码"></a>qrcode 一行字二维码</h3><pre><code class="python">import qrcodeqrcode.make(&quot;不睡觉干嘛呢&quot;).get_image().show()   #设置URL必须添加http://</code></pre><h3 id="qrcode-一行字二维码-1"><a href="#qrcode-一行字二维码-1" class="headerlink" title="qrcode 一行字二维码"></a>qrcode 一行字二维码</h3><pre><code class="python">import qrcodetext = input(&quot;输入文字或URL：&quot;)img =qrcode.make(text)img.save()                            #保存图片至本地目录，可以设定路径img.show()</code></pre><h3 id="qrcode-生成-logo-二维码"><a href="#qrcode-生成-logo-二维码" class="headerlink" title="qrcode 生成 logo 二维码"></a>qrcode 生成 logo 二维码</h3><pre><code class="python">from PIL import Imageimport qrcode,osdef create_qrcode(url,qrcodename):    qr = qrcode.QRCode(        version=1,  # 设置容错率为最高        error_correction=qrcode.ERROR_CORRECT_H, # 用于控制二维码的错误纠正程度        box_size=8, # 控制二维码中每个格子的像素数，默认为10        border=1, # 二维码四周留白，包含的格子数，默认为4        #image_factory=None,  保存在模块根目录的image文件夹下        #mask_pattern=None    )    qr.add_data(url) # QRCode.add_data(data)函数添加数据    qr.make(fit=True)  # QRCode.make(fit=True)函数生成图片    img = qr.make_image()    img = img.convert(&quot;RGBA&quot;) # 二维码设为彩色    logo = Image.open(&#39;xx.jpg&#39;) # 传gif生成的二维码也是没有动态效果的    w , h = img.size    logo_w , logo_h = logo.size    factor = 4   # 默认logo最大设为图片的四分之一    s_w = int(w / factor)    s_h = int(h / factor)    if logo_w &gt; s_w or logo_h &gt; s_h:        logo_w = s_w        logo_h = s_h    logo = logo.resize((logo_w, logo_h), Image.ANTIALIAS)    l_w = int((w - logo_w) / 2)    l_h = int((h - logo_h) / 2)    logo = logo.convert(&quot;RGBA&quot;)    img.paste(logo, (l_w, l_h), logo)    img.show()    img.save(os.getcwd()+&#39;/&#39; + qrcodename + &#39;.png&#39;, quality=100)</code></pre><h3 id="myqr-动态二维码"><a href="#myqr-动态二维码" class="headerlink" title="myqr 动态二维码"></a>myqr 动态二维码</h3><pre><code>相关参数：    words：二维码内容，链接或者句子    version：二维码大小，范围为[1,40]    level：二维码纠错级别，范围为&#123;L,M,Q,H&#125;，H为最高级，默认。    picture：自定义二维码背景图，支持格式为 .jpg，.png，.bmp，.gif，默认为黑白色    colorized：二维码背景颜色，默认为 False，即黑白色    contrast：对比度，值越高对比度越高，默认为 1.0    brightness：亮度，值越高亮度越高，默认为 1.0，值常和对比度相同    save_name：二维码名称，默认为 qrcode.png    save_dir：二维码路径，默认为程序工作路径</code></pre><pre><code class="python"># 调用库from MyQR import myqr# 函数部分myqr.run(    # 网址    words=&#39;https://wztlink1013.com&#39;,    # 控制边长，范围是1到40，数字越大边长越大，默认边长是取决于你输入的信息的长度和使用的纠错等级    version=5,    # 控制纠错水平，范围是L、M、Q、H，从左到右依次升高    level=&#39;H&#39;,    # 将QR二维码图像与一张同目录下的图片相结合，此处设置该图片，可以是gif    picture=&#39;./input/girl.gif&#39;,    # 默认是黑白(False)，可以选择彩色(True)    colorized=True,    # 调节图片的对比度，1.0 表示原始图片，更小的值表示更低对比度，更大反之。默认为1.0。    contrast=1.0,    # 调节图片的亮度，用法与contrast相同    brightness=1.0,    # 输出文件名，格式可以是jpg，png，bmp，gif    save_name=&#39;girl.gif&#39;,    save_dir=&#39;./output&#39;)</code></pre>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 非前端编程语言 </category>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>面向对象</title>
      <link href="/blog/eywygo/"/>
      <url>/blog/eywygo/</url>
      
        <content type="html"><![CDATA[<h2 id="一、面向对象思考"><a href="#一、面向对象思考" class="headerlink" title="一、面向对象思考"></a>一、面向对象思考</h2><h3 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h3><blockquote><p>就像是手工设计动态数组、链表等数据结构一样，要用<strong>设计</strong>这个字眼去面向对象思考。<br>同时还要关注类与类之间的关系有关联、聚集、组合，在设计多个类的过程中要有这些意识</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1600086611076-d83aa284-7977-447d-9b25-0a0a67a12c3f.png#align=left&display=inline&height=189&margin=%5Bobject%20Object%5D&name=image.png&originHeight=377&originWidth=1003&size=316078&status=done&style=stroke&width=501.5" alt="image.png"><br>就像是之前的数据结构课程一样，像那样就是面向过程，全都是写函数来实现操作</p><h3 id="基本数据类型值及其包装类"><a href="#基本数据类型值及其包装类" class="headerlink" title="基本数据类型值及其包装类"></a>基本数据类型值及其包装类</h3><blockquote><p>都存在 java.lang 里面</p></blockquote><p>Integer、Long、Float、Double、Boolean、Character、Short、Byte<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1600087287006-c480d8fd-a6b5-4be9-bc43-3023e9fa4a0c.png#align=left&display=inline&height=264&margin=%5Bobject%20Object%5D&name=image.png&originHeight=527&originWidth=989&size=482466&status=done&style=stroke&width=494.5" alt="image.png"></p><blockquote><p>基本数据类型和其对象化之后的包装类类型之间的自动转换</p></blockquote><p><code>Integer intObject = new Integer (2);</code>  等价于 <code>Integer intObject = 2;</code></p><blockquote><p>BigInteger 类和 BigDeciml 类用于表示任意大小和精度的整数或是二进制数</p></blockquote><h2 id="二、对象和类"><a href="#二、对象和类" class="headerlink" title="二、对象和类"></a>二、对象和类</h2><h3 id="OOP-阶梯图"><a href="#OOP-阶梯图" class="headerlink" title="OOP 阶梯图"></a>OOP 阶梯图</h3><blockquote><p>“OOP 阶梯图”—— 类的多个特性，同时以对象对基础</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598686636493-3aecdbf5-1f94-4076-99dc-0ef0dac07331.png#align=left&display=inline&height=216&margin=%5Bobject%20Object%5D&originHeight=726&originWidth=1328&size=0&status=done&style=stroke&width=396"></p><h3 id="类的组成"><a href="#类的组成" class="headerlink" title="类的组成"></a>类的组成</h3><blockquote><p>数据域、构造函数、方法（C++里面的说法是数据成员和成员函数）<br><strong>类中不能存在可执行语句</strong></p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598686636459-572d60ff-0740-4487-b3fd-9e2fa94b643f.png#align=left&display=inline&height=248&margin=%5Bobject%20Object%5D&originHeight=713&originWidth=1387&size=0&status=done&style=shadow&width=482"></p><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><ul><li>和类同名、重载、没有返回值</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598686636454-ce95b4aa-9966-4024-82ae-b7cc296097db.png#align=left&display=inline&height=218&margin=%5Bobject%20Object%5D&originHeight=481&originWidth=708&size=0&status=done&style=stroke&width=321"></p><ul><li><strong>构造函数初始化优先级</strong><blockquote><ol><li>静态成员变量初始化顺序高于非静态成员变量</li><li>成员变量的初始化顺序优于构造函数</li><li>静态成员变量只初始化一次，就是第一次被访问的时候</li><li>存在多个静态成员变量的时候，按照次序依次执行</li></ol></blockquote></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598686636495-c0c2fdf5-3919-475e-a2f7-a3888d97492d.png#align=left&display=inline&height=220&margin=%5Bobject%20Object%5D&originHeight=700&originWidth=1404&size=0&status=done&style=stroke&width=441"></p><pre><code class="java">Window(2)Window(1)Window(2)Window(3)House()Window(33)f()</code></pre><h3 id="数据域的默认值"><a href="#数据域的默认值" class="headerlink" title="数据域的默认值"></a>数据域的默认值</h3><blockquote><p><strong>对于对象而言，不赋值也会有默认的</strong>。之前的数组就是如此</p></blockquote><p>各个数据域按照之前的基本上的默认初值，如果是其他的类型，则空</p><h3 id="对象的创建和访问"><a href="#对象的创建和访问" class="headerlink" title="对象的创建和访问"></a>对象的创建和访问</h3><blockquote><ol><li>通过引用变量来访问对象，创建的类的对象被内存分配了内存空间，可以用引用变量来访问</li><li><strong>对象类型都需要用 new 来新建</strong></li></ol></blockquote><pre><code class="java">ClassName objectRefVar = new ClassName();Circle myCircle = new Circle();</code></pre><p><strong>使用成员变量和成员函数</strong></p><pre><code class="java">mycircle.radiusmycircle.getArea()</code></pre><p><strong>调用静态函数，动态函数需要在自己类下面调用自己的函数</strong></p><h3 id="“炸宿舍”"><a href="#“炸宿舍”" class="headerlink" title="“炸宿舍”"></a>“炸宿舍”</h3><blockquote><p>关于老师提出来的炸宿舍例子</p></blockquote><p><strong>对象间的赋值和基本类型的赋值，能改变的一定是基本数值类型，所谓的数组名抑或是对象名，都只是地址映射</strong></p><h3 id="垃圾回收机制和-this"><a href="#垃圾回收机制和-this" class="headerlink" title="垃圾回收机制和 this"></a>垃圾回收机制和 this</h3><pre><code class="java">System.gc(); // 提醒垃圾回收</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1600086346479-3cc546b6-dab8-4fc5-a352-8f2fb2ea8065.png#align=left&display=inline&height=281&margin=%5Bobject%20Object%5D&name=image.png&originHeight=562&originWidth=960&size=48667&status=done&style=shadow&width=480" alt="image.png"></p><h3 id="静态变量、常量和方法"><a href="#静态变量、常量和方法" class="headerlink" title="静态变量、常量和方法"></a>静态变量、常量和方法</h3><blockquote><p>静态成员变量：静态成员变量可以被类的所有实例共享（比如计数变量用到）<br>静态方法：不能访问类的实例成员<br>关于静态变量、静态方法、实例变量、实例方法</p></blockquote><h3 id="可见性修饰符"><a href="#可见性修饰符" class="headerlink" title="可见性修饰符"></a>可见性修饰符</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598686637158-0b08a6a1-5cd8-4aac-9133-1ad101cc8a52.png#align=left&display=inline&height=302&margin=%5Bobject%20Object%5D&originHeight=302&originWidth=491&size=0&status=done&style=stroke&width=491"></p><h3 id="“析构函数”"><a href="#“析构函数”" class="headerlink" title="“析构函数”"></a>“析构函数”</h3><pre><code class="java">protected void finalize() throwsable &#123;    super.finalize();    System.out.println(&quot;Person - finalize&quot;);&#125;</code></pre><h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><p>内部类只给该类使用（私有自己用，同时写静态的），就如 LinkedList 类的设计</p><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 非前端编程语言 </category>
          
          <category> JAVA </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>基础知识</title>
      <link href="/blog/esofty/"/>
      <url>/blog/esofty/</url>
      
        <content type="html"><![CDATA[<h2 id="一、关于-JAVA"><a href="#一、关于-JAVA" class="headerlink" title="一、关于 JAVA"></a>一、关于 JAVA</h2><h3 id="Java-和-C-和-C"><a href="#Java-和-C-和-C" class="headerlink" title="Java 和 C 和 C++"></a>Java 和 C 和 C++</h3><ol><li>c 是面向过程的语言。c++和 Java 都是面向对象的。在 c 中没有类或者对象的概念。</li><li>java 运行在虚拟机上，号称与平台无关。也就是你开发的 java 程序无论是 unix，linux 还是 windows 都可以正常运行。但是实际上这是一个良好的愿望，实际跨平台时还会有各种各样的问题。c 和 c++都是直接编译成可执行文件，是否能跨平台主要看你用到的编译器特性是否有多平台支持。</li><li>因为 c 和 c 是直接编译成可执行文件，所以运行效率要比 java 高。至于 c 和 c 哪个更快，两种语言的拥趸已经吵了很多年。</li><li>java 因为是运行在虚拟机上，不需要考虑内存管理和垃圾回收机制。也是就你可以声明一个对象而不用考虑释放他，虚拟机帮你做这事情。而 c 和 c 语言本身没有多少内存管理的概念，写 c 和 c 程序如果用到指针就一定要考虑内存申请和释放。内存泄漏是 c 和 c++最头疼的问题。</li><li>代码重用：java 中有一个根类 object，所有的类都是其子类，通过这种方式将容器和算法分离，实现一种操作作用于多种对象，提高代码重用。c 中没有总根对象，但是 c 提供了另一个更强大的功能“模板”，同样高效地实现了一种操作作用于多种对象，提供了高效的代码重用方法。</li><li>数据结构：java 内建了丰富的数据结构：列表，集合等等（很久没用 java 了，有些记不太清）。而 c++则用“模板”同样提供了各种数据结构（容器）。</li><li>c 语言在一些比较低层，和硬件打交道的地方用得比较多。另外很多开源软件由于 unix/linux 开发习惯也大多采用 c 来开发。Java 是现在最流行的开发语言，c++比起 java 稍稍不那么流行一些，但是功能很强大。如能深入掌握，可以写出兼顾效率和美观的优秀代码。</li></ol><h3 id="多语言简略对比"><a href="#多语言简略对比" class="headerlink" title="多语言简略对比"></a>多语言简略对比</h3><blockquote><p><strong>Ideas are cheap, show me the code</strong>   学到了，学到了~</p></blockquote><pre><code>代码块：python通过缩进来确定代码块复数：java、python有，C、Cplusplus没有python：相对于java，python就是java的压缩版本包、接口、API：我觉得java也好，python也好，正是因为这些模块组件化，才使得这些语言好很好的的健壮性</code></pre><h2 id="二、数据类型；运算符；表达式"><a href="#二、数据类型；运算符；表达式" class="headerlink" title="二、数据类型；运算符；表达式"></a>二、数据类型；运算符；表达式</h2><h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><blockquote><p>常量、标识符和变量、数据类型</p></blockquote><blockquote><p><strong>JAVA 中除了下面 8 种数据类型其他的都是以对象（或者说类的实例）存在的</strong></p></blockquote><ul><li>string：要熟悉常用的函数<ul><li>length()：字符串的长度</li><li>charAt(i)：取字符串的第 i 个元素</li></ul></li><li>boolean（java 中需要全部写出来）<ul><li><code>true</code></li><li><code>false</code></li></ul></li><li>下面 6 中数值型数据类型</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598686524193-b62199d3-9dc6-4caa-a3c1-2484c7d6185c.png#align=left&display=inline&height=204&margin=%5Bobject%20Object%5D&originHeight=583&originWidth=1192&size=0&status=done&style=shadow&width=418"></p><h3 id="运算符和表达式"><a href="#运算符和表达式" class="headerlink" title="运算符和表达式"></a>运算符和表达式</h3><ul><li>赋值语句，赋值表达式</li><li>输入输出：<strong>输入输出，要有记得清除的空间，close 的意识！</strong></li></ul><pre><code class="java">// 方式一import java.util.Scanner;Scanner input = new Scanner(System.in);double radius = input.nextDouble();// 方式二 : 好处就是避免项目工程中类当中重名的情况java.util.Scanner input = new java.util.Scanner(System.in);double radius = input.nextDouble();</code></pre><ul><li><p>数值运算符</p><blockquote><p>+、-、*、/、%</p></blockquote></li><li><p>逻辑运算符<br><code>&amp;&amp;</code> <code>||</code> <code>!</code> <code>^</code>(异或：相同才为假)<br><code>&amp;</code> <code>|</code> <code>^</code> 位运算符：会先化成二进制对二进制码进行分析</p></li><li><p>运算符的优先级</p></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598686523840-d1395ecf-7d3c-416b-8ce8-5d11a0e3f313.png#align=left&display=inline&height=302&margin=%5Bobject%20Object%5D&originHeight=552&originWidth=543&size=0&status=done&style=none&width=297"></p><h2 id="三、程序三大基本结构"><a href="#三、程序三大基本结构" class="headerlink" title="三、程序三大基本结构"></a>三、程序三大基本结构</h2><h3 id="顺序结构"><a href="#顺序结构" class="headerlink" title="顺序结构"></a>顺序结构</h3><h3 id="选择结构"><a href="#选择结构" class="headerlink" title="选择结构"></a>选择结构</h3><ul><li>if(){} else{}</li><li>switch</li></ul><pre><code class="java">public class Test &#123;   public static void main(String args[])&#123;      //char grade = args[0].charAt(0);      char grade = &#39;C&#39;;      switch(grade)      &#123;         case &#39;A&#39; :            System.out.println(&quot;优秀&quot;);            break;         case &#39;B&#39; :         case &#39;C&#39; :            System.out.println(&quot;良好&quot;);            break;         case &#39;D&#39; :            System.out.println(&quot;及格&quot;);            break;         case &#39;F&#39; :            System.out.println(&quot;你需要再努力努力&quot;);            break;         default :            System.out.println(&quot;未知等级&quot;);      &#125;      System.out.println(&quot;你的等级是 &quot; + grade);   &#125;&#125;</code></pre><ul><li><strong>条件表达式</strong></li></ul><pre><code class="java">System.out.println((num % 2 == 0) ? &quot;num is even&quot; : &quot;num is odd&quot;);</code></pre><h3 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h3><ul><li>while () {}</li><li>do {} while ();</li><li>for () {}</li><li>关于 break（跳出该级别的 for 循环）和 continue（后面的语句不读）</li><li>关于 return</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598686523958-c57b6b4d-e802-44e1-adc6-276167476c3d.png#align=left&display=inline&height=236&margin=%5Bobject%20Object%5D&originHeight=328&originWidth=530&size=0&status=done&style=shadow&width=381"></p><ul><li>关于<strong>增强的 for 循环</strong>，在模板章节，配合 vector 使用，并发控制，高效使用</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598686523773-6d1af202-9aa9-4789-b931-b0671aac432f.png#align=left&display=inline&height=255&margin=%5Bobject%20Object%5D&originHeight=781&originWidth=1128&size=0&status=done&style=none&width=369"><br>缺点：看不见索引</p><h2 id="四、方法"><a href="#四、方法" class="headerlink" title="四、方法"></a>四、方法</h2>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 非前端编程语言 </category>
          
          <category> JAVA </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>机器学习scikit-learn库的使用</title>
      <link href="/blog/wgv3ak/"/>
      <url>/blog/wgv3ak/</url>
      
        <content type="html"><![CDATA[<h2 id="一、机器学习的一些概念"><a href="#一、机器学习的一些概念" class="headerlink" title="一、机器学习的一些概念"></a>一、机器学习的一些概念</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ul><li>特征：一组数据的多个属性</li><li>标签：人为指定特征</li><li>监督学习：就像分类（离散化的标签），回归（连续性的标签）、【“有标准答案”】</li><li>无监督学习：就像聚类【“无标准答案”】</li><li><strong>数据</strong>：是机器学习的命脉</li></ul><h3 id="基本框架图"><a href="#基本框架图" class="headerlink" title="基本框架图"></a>基本框架图</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598686130909-116e16a4-e86a-46e0-93fb-ac0263257056.png#align=left&display=inline&height=271&id=F2NI4&margin=%5Bobject%20Object%5D&originHeight=692&originWidth=1157&size=0&status=done&style=shadow&width=453"><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598686131288-431d8fe6-bf3f-4f3e-9986-9b282e9e2982.png#align=left&display=inline&height=356&id=LzfkG&margin=%5Bobject%20Object%5D&originHeight=651&originWidth=869&size=0&status=done&style=shadow&width=475"></p><h2 id="二、机器学习的一些阶段-步骤"><a href="#二、机器学习的一些阶段-步骤" class="headerlink" title="二、机器学习的一些阶段/步骤"></a>二、机器学习的一些阶段/步骤</h2><h3 id="sklearn-相关提及"><a href="#sklearn-相关提及" class="headerlink" title="sklearn 相关提及"></a>sklearn 相关提及</h3><p><a href="https://scikit-learn.org/stable/testimonials/testimonials.html">官网 scikit-learn</a></p><ol><li>包含聚类、分类、回归等算法<br>eg：随机森林、k-means、SVM 等</li><li>包含模型筛选、降维、预处理等算法</li><li>要特别注意安装该包使用要注意的细节，具体参考上一篇博客</li></ol><h3 id="sklearn-处理机器学习的一般化-sop"><a href="#sklearn-处理机器学习的一般化-sop" class="headerlink" title="sklearn 处理机器学习的一般化 sop"></a>sklearn 处理机器学习的一般化 sop</h3><ol><li><strong>准备数据集</strong><ul><li>数据分析:（利用 np.reshape()成二维(n_samples,n_features)）</li><li>划分数据集：train_test_split()</li><li>特征工程：特征的提取、特征的归一化 nomalization</li></ul></li><li><strong>选择模型</strong><ul><li>根据不同场景选择合适的模型:<a href="https://scikit-learn.org/stable/tutorial/machine_learning_map/index.html">scikit-learn 的模型选择路线图</a></li><li>分类、聚类、回归……</li></ul></li><li>在训练集上<strong>训练模型</strong>，并调整参数<ul><li>经验选定参数</li><li>交叉验证确定最优的参数 cross validation</li></ul></li><li>在测试集上<strong>测试模型</strong><ul><li>predict 预测、score 真实值预测值评分、etc</li></ul></li><li><strong>保存模型</strong><ul><li><code>import pickle</code></li></ul></li></ol><h3 id="主成分分析：将特征降维"><a href="#主成分分析：将特征降维" class="headerlink" title="主成分分析：将特征降维"></a>主成分分析：将特征降维</h3><ul><li>统计学相关知识：方差（衡量在一个维度的偏差）、协方差（衡量一个维度是否对另一个维度有影响 cov（x，y））</li><li>线代相关知识：特征值、特征向量、协方差向量</li><li>PCA</li></ul><p><a href="http://q5e49p23n.bkt.clouddn.com/scikit_pca.html">相关代码 html 页面</a></p><h2 id="三、通过-scikit-learn-认识机器学习"><a href="#三、通过-scikit-learn-认识机器学习" class="headerlink" title="三、通过 scikit-learn 认识机器学习"></a>三、通过 scikit-learn 认识机器学习</h2><h3 id="加载示例数据集"><a href="#加载示例数据集" class="headerlink" title="加载示例数据集"></a>加载示例数据集</h3><pre><code class="python">from sklearn import datasetsiris = datasets.load_iris()#用sklearn自身配带的数据digits = datasets.load_digits()# C:\Users\wztli\Anaconda3\pkgs\scikit-learn-0.21.3-py37h6288b17_0\Lib\site-packages\sklearn\datasets\data# 数据集在电脑中的位置</code></pre><pre><code class="python"># 查看数据集# irisprint(iris.data[:5])print(iris.data.shape)print(iris.target_names)print(iris.target)</code></pre><pre><code class="python">[[5.1 3.5 1.4 0.2] [4.9 3.  1.4 0.2] [4.7 3.2 1.3 0.2] [4.6 3.1 1.5 0.2] [5.  3.6 1.4 0.2]](150, 4)[&#39;setosa&#39; &#39;versicolor&#39; &#39;virginica&#39;][0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2]</code></pre><pre><code class="python"># digitsprint(digits.data)print(digits.data.shape)print(digits.target_names)print(digits.target)</code></pre><pre><code class="python">[[ 0.  0.  5. ...  0.  0.  0.] [ 0.  0.  0. ... 10.  0.  0.] [ 0.  0.  0. ... 16.  9.  0.] ... [ 0.  0.  1. ...  6.  0.  0.] [ 0.  0.  2. ... 12.  0.  0.] [ 0.  0. 10. ... 12.  1.  0.]](1797, 64)[0 1 2 3 4 5 6 7 8 9][0 1 2 ... 8 9 8]</code></pre><h3 id="在训练集上训练模型"><a href="#在训练集上训练模型" class="headerlink" title="在训练集上训练模型"></a>在训练集上训练模型</h3><pre><code class="python"># 手动划分训练集、测试集n_test = 100 # 测试样本个数train_X = digits.data[:-n_test, :]train_y = digits.target[:-n_test]test_X = digits.data[-n_test:, :]y_true = digits.target[-n_test:]</code></pre><pre><code class="python"># 选择SVM模型from sklearn import svmsvm_model = svm.SVC(gamma=0.001, C=100.)# svm_model = svm.SVC(gamma=100., C=1.)# 训练模型svm_model.fit(train_X, train_y)#训练要放入两个参数：样本的特征数据，样本的标签</code></pre><pre><code class="python">SVC(C=100.0, cache_size=200, class_weight=None, coef0=0.0,    decision_function_shape=&#39;ovr&#39;, degree=3, gamma=0.001, kernel=&#39;rbf&#39;,    max_iter=-1, probability=False, random_state=None, shrinking=True,    tol=0.001, verbose=False)</code></pre><pre><code class="python"># 选择LR（逻辑回归）模型from sklearn.linear_model import LogisticRegressionlr_model = LogisticRegression()# 训练模型lr_model.fit(train_X, train_y)</code></pre><pre><code class="python">C:\Users\wztli\Anaconda3\lib\site-packages\sklearn\linear_model\logistic.py:432: FutureWarning: Default solver will be changed to &#39;lbfgs&#39; in 0.22. Specify a solver to silence this warning.  FutureWarning)C:\Users\wztli\Anaconda3\lib\site-packages\sklearn\linear_model\logistic.py:469: FutureWarning: Default multi_class will be changed to &#39;auto&#39; in 0.22. Specify the multi_class option to silence this warning.  &quot;this warning.&quot;, FutureWarning)LogisticRegression(C=1.0, class_weight=None, dual=False, fit_intercept=True,                   intercept_scaling=1, l1_ratio=None, max_iter=100,                   multi_class=&#39;warn&#39;, n_jobs=None, penalty=&#39;l2&#39;,                   random_state=None, solver=&#39;warn&#39;, tol=0.0001, verbose=0,                   warm_start=False)</code></pre><h3 id="在测试集上测试模型"><a href="#在测试集上测试模型" class="headerlink" title="在测试集上测试模型"></a>在测试集上测试模型</h3><pre><code class="python">y_pred_svm = svm_model.predict(test_X)y_pred_lr = lr_model.predict(test_X)</code></pre><pre><code class="python"># 查看结果# 评价指标from sklearn.metrics import accuracy_score#print &#39;预测标签：&#39;, y_pred#print &#39;真实标签：&#39;, y_trueprint(&#39;SVM结果：&#39;, accuracy_score(y_true, y_pred_svm))print(&#39;LR结果：&#39;, accuracy_score(y_true, y_pred_lr))</code></pre><pre><code class="python">SVM结果： 0.98LR结果： 0.94</code></pre><h3 id="保存模型"><a href="#保存模型" class="headerlink" title="保存模型"></a>保存模型</h3><pre><code class="python">import picklewith open(&#39;svm_model.pkl&#39;, &#39;wb&#39;) as f:    pickle.dump(svm_model, f)</code></pre><pre><code class="python">import numpy as np# 重新加载模型进行预测with open(&#39;svm_model.pkl&#39;, &#39;rb&#39;) as f:    model = pickle.load(f)random_samples_index = np.random.randint(0, 1796, 5)random_samples = digits.data[random_samples_index, :]random_targets = digits.target[random_samples_index]random_predict = model.predict(random_samples)print(random_predict)print(random_targets)</code></pre><pre><code class="python">[2 2 1 3 8][2 2 1 3 8]</code></pre><h2 id="四、scikit-learn-入门"><a href="#四、scikit-learn-入门" class="headerlink" title="四、scikit-learn 入门"></a>四、scikit-learn 入门</h2><h3 id="准备数据集"><a href="#准备数据集" class="headerlink" title="准备数据集"></a>准备数据集</h3><pre><code class="python">import numpy as npfrom sklearn.model_selection import train_test_split</code></pre><pre><code class="python">X = np.random.randint(0, 100, (10, 4))y = np.random.randint(0, 4, 10)y.sort()print(&#39;样本：&#39;)print(X)print(&#39;标签：&#39;, y)</code></pre><pre><code class="python">样本：[[43 43 18 78] [74 24 42 37] [36 69 84 47] [70 62 77 30] [87 38  3 96] [68 67 24  7] [66 36 72 72] [12 94 87 72] [66  5 92  6] [41 59 60 91]]标签： [0 0 0 2 2 2 2 3 3 3]</code></pre><pre><code class="python"># 分割训练集、测试集# random_state确保每次随机分割得到相同的结果X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=1/3., random_state=7)print(&#39;训练集：&#39;)print(X_train)print(y_train)print(&#39;测试集：&#39;)print(X_test)print(y_test)</code></pre><pre><code class="python">训练集：[[63 56  7 42] [40 47 17 23] [41 31 26  8] [79 30 22 88] [54 85 48 54] [89 73 77 41]][0 1 1 0 1 1]测试集：[[ 3  0 42 86] [42 96 83 38] [33 45  8 37] [ 1 44 75  7]][1 1 0 0]</code></pre><pre><code class="python"># 特征归一化from sklearn import preprocessingx1 = np.random.randint(0, 1000, 5).reshape(5,1)x2 = np.random.randint(0, 10, 5).reshape(5, 1)x3 = np.random.randint(0, 100000, 5).reshape(5, 1)X = np.concatenate([x1, x2, x3], axis=1)print(X)</code></pre><pre><code class="python">[[  353     4 27241] [  999     4 34684] [  911     4 78606] [  310     6 44593] [  817     9  6356]]</code></pre><pre><code class="python">print(preprocessing.scale(X))</code></pre><pre><code class="python">[[-1.12443958 -0.71443451 -0.46550183] [ 1.11060033 -0.71443451 -0.15209341] [ 0.80613669 -0.71443451  1.69736578] [-1.27321159  0.30618622  0.26515287] [ 0.48091416  1.83711731 -1.34492342]]</code></pre><pre><code class="python"># 生成分类数据进行验证scale的必要性from sklearn.datasets import make_classificationimport matplotlib.pyplot as plt%matplotlib inlineX, y = make_classification(n_samples=300, n_features=2, n_redundant=0, n_informative=2,                           random_state=25, n_clusters_per_class=1, scale=100)plt.scatter(X[:,0], X[:,1], c=y)plt.show()</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598686130636-3a18d8f2-51cb-4b04-8a0f-a40cf1d0b9b6.png#align=left&display=inline&height=248&id=BKtnM&margin=%5Bobject%20Object%5D&originHeight=248&originWidth=384&size=0&status=done&style=none&width=384"></p><pre><code class="python">from sklearn import svm# 注释掉以下这句表示不进行特征归一化X = preprocessing.scale(X)X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=1/3., random_state=7)svm_classifier = svm.SVC()svm_classifier.fit(X_train, y_train)svm_classifier.score(X_test, y_test)</code></pre><pre><code class="python">C:\Users\wztli\Anaconda3\lib\site-packages\sklearn\svm\base.py:193: FutureWarning: The default value of gamma will change from &#39;auto&#39; to &#39;scale&#39; in version 0.22 to account better for unscaled features. Set gamma explicitly to &#39;auto&#39; or &#39;scale&#39; to avoid this warning.  &quot;avoid this warning.&quot;, FutureWarning)0.25</code></pre><h3 id="训练模型"><a href="#训练模型" class="headerlink" title="训练模型"></a>训练模型</h3><pre><code class="python"># 回归模型from sklearn import datasetsboston_data = datasets.load_boston()X = boston_data.datay = boston_data.targetprint(&#39;样本：&#39;)print(X[:5, :])print(&#39;标签：&#39;)print(y[:5])</code></pre><pre><code class="python">样本：[[6.3200e-03 1.8000e+01 2.3100e+00 0.0000e+00 5.3800e-01 6.5750e+00  6.5200e+01 4.0900e+00 1.0000e+00 2.9600e+02 1.5300e+01 3.9690e+02  4.9800e+00] [2.7310e-02 0.0000e+00 7.0700e+00 0.0000e+00 4.6900e-01 6.4210e+00  7.8900e+01 4.9671e+00 2.0000e+00 2.4200e+02 1.7800e+01 3.9690e+02  9.1400e+00] [2.7290e-02 0.0000e+00 7.0700e+00 0.0000e+00 4.6900e-01 7.1850e+00  6.1100e+01 4.9671e+00 2.0000e+00 2.4200e+02 1.7800e+01 3.9283e+02  4.0300e+00] [3.2370e-02 0.0000e+00 2.1800e+00 0.0000e+00 4.5800e-01 6.9980e+00  4.5800e+01 6.0622e+00 3.0000e+00 2.2200e+02 1.8700e+01 3.9463e+02  2.9400e+00] [6.9050e-02 0.0000e+00 2.1800e+00 0.0000e+00 4.5800e-01 7.1470e+00  5.4200e+01 6.0622e+00 3.0000e+00 2.2200e+02 1.8700e+01 3.9690e+02  5.3300e+00]]标签：[24.  21.6 34.7 33.4 36.2]</code></pre><pre><code class="python"># 选择线性回顾模型from sklearn.linear_model import LinearRegressionlr_model = LinearRegression()</code></pre><pre><code class="python">from sklearn.model_selection import train_test_split# 分割训练集、测试集X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=1/3., random_state=7)</code></pre><pre><code class="python"># 训练模型lr_model.fit(X_train, y_train)</code></pre><pre><code class="python">LinearRegression(copy_X=True, fit_intercept=True, n_jobs=None, normalize=False)</code></pre><pre><code class="python"># 返回参数lr_model.get_params()</code></pre><pre><code class="python">&#123;&#39;copy_X&#39;: True, &#39;fit_intercept&#39;: True, &#39;n_jobs&#39;: None, &#39;normalize&#39;: False&#125;</code></pre><pre><code class="python">lr_model.score(X_train, y_train)</code></pre><pre><code class="python">0.7598132492351114</code></pre><pre><code class="python">lr_model.score(X_test, y_test)</code></pre><pre><code class="python">0.6693852753319398</code></pre><h3 id="交叉验证"><a href="#交叉验证" class="headerlink" title="交叉验证"></a>交叉验证</h3><pre><code class="python">from sklearn import datasetsfrom sklearn.model_selection import train_test_split, cross_val_scorefrom sklearn.neighbors import KNeighborsClassifierimport matplotlib.pyplot as plt%matplotlib inlineiris = datasets.load_iris()X = iris.datay = iris.targetX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=1/3., random_state=10)k_range = range(1, 31)cv_scores = []for n in k_range:    knn = KNeighborsClassifier(n)    scores = cross_val_score(knn, X_train, y_train, cv=10, scoring=&#39;accuracy&#39;) # 分类问题使用    #scores = cross_val_score(knn, X_train, y_train, cv=10, scoring=&#39;neg_mean_squared_error&#39;) # 回归问题使用    cv_scores.append(scores.mean())plt.plot(k_range, cv_scores)plt.xlabel(&#39;K&#39;)plt.ylabel(&#39;Accuracy&#39;)plt.show()</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598686130618-179a3dfa-9ffd-4f45-9cc2-d6f63e1ad2b9.png#align=left&display=inline&height=262&id=uSgI0&margin=%5Bobject%20Object%5D&originHeight=262&originWidth=392&size=0&status=done&style=none&width=392"></p><pre><code class="python"># 选择最优的Kbest_knn = KNeighborsClassifier(n_neighbors=5)best_knn.fit(X_train, y_train)print(best_knn.score(X_test, y_test))print(best_knn.predict(X_test))</code></pre><pre><code class="python">0.96[1 2 0 1 0 1 2 1 0 1 1 2 1 0 0 2 1 0 0 0 2 2 2 0 1 0 1 1 1 2 1 1 2 2 2 0 2 2 2 2 0 0 1 0 1 0 1 2 2 2]</code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://github.com/wztlink1013/scikit-learn">scikit-learn 中文文档 github</a>文中链接为英文文档</li><li><a href="https://blog.csdn.net/Little_Fire/article/details/81062447">解释 iris 数据集</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> ✨其他 </category>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ANN神经网络</title>
      <link href="/blog/apohu8/"/>
      <url>/blog/apohu8/</url>
      
        <content type="html"><![CDATA[<h2 id="一、基本结构"><a href="#一、基本结构" class="headerlink" title="一、基本结构"></a>一、基本结构</h2><blockquote><p>神经网络基本结构<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685949882-81dbb96c-eafa-4294-aae3-242fd33fff2b.png#align=left&display=inline&height=324&id=gahgJ&margin=%5Bobject%20Object%5D&originHeight=324&originWidth=858&size=0&status=done&style=none&width=858"> &gt; <img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685950067-4d0671d6-b294-4284-9eff-9409d230e91e.png#align=left&display=inline&height=470&id=agJlv&margin=%5Bobject%20Object%5D&originHeight=470&originWidth=768&size=0&status=done&style=none&width=768"></p></blockquote><blockquote><p>何为深度学习？<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685949953-b8d95ff1-6384-4e59-b3d6-1f8151f08204.png#align=left&display=inline&height=400&id=WSSoJ&margin=%5Bobject%20Object%5D&originHeight=400&originWidth=842&size=0&status=done&style=none&width=842"></p></blockquote><h2 id="二、感知器和激活函数"><a href="#二、感知器和激活函数" class="headerlink" title="二、感知器和激活函数"></a>二、感知器和激活函数</h2><blockquote><p>感知器<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685949922-e9c76c57-f1c5-4ff1-af82-25c35a4005b1.png#align=left&display=inline&height=514&id=eaX9r&margin=%5Bobject%20Object%5D&originHeight=514&originWidth=802&size=0&status=done&style=none&width=802"></p></blockquote><blockquote><p>激活函数（其中 w 和 x 为向量点乘；b 为偏置，w0）<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685949961-18eeecb5-c82e-4f71-a543-9bd0c0f27043.png#align=left&display=inline&height=511&id=LJZ0R&margin=%5Bobject%20Object%5D&originHeight=511&originWidth=836&size=0&status=done&style=none&width=836"></p></blockquote><blockquote><p>激活函数的选择<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685950003-072268a5-122d-4340-85d5-85eeb04236fe.png#align=left&display=inline&height=538&id=DZqH3&margin=%5Bobject%20Object%5D&originHeight=538&originWidth=861&size=0&status=done&style=none&width=861"></p></blockquote><h2 id="三、感知器的训练"><a href="#三、感知器的训练" class="headerlink" title="三、感知器的训练"></a>三、感知器的训练</h2><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685950698-fc03bb22-76e6-4328-9a6b-ee2168250fec.png#align=left&display=inline&height=529&id=jRv0N&margin=%5Bobject%20Object%5D&originHeight=529&originWidth=872&size=0&status=done&style=none&width=872"></p><h2 id="四、简单代码实现"><a href="#四、简单代码实现" class="headerlink" title="四、简单代码实现"></a>四、简单代码实现</h2><pre><code class="python">from functools import reduceclass Perceptron(object):    &#39;&#39;&#39;    构造函数的初始化    &#39;&#39;&#39;    def __init__(self,input_num,activator):        &#39;&#39;&#39;        构造函数的初始化        &#39;&#39;&#39;        self.activator = activator        self.weights = [0.0 for _ in range(input_num)]        self.bias = 0.0    def __str__(self):        &#39;&#39;&#39;        打印学习后的权重值和偏置项        &#39;&#39;&#39;        return &#39;weights\t:%s\nbias\t:%f\n&#39; %(self.weights,self.bias)    def predict(self,input_vec):        &#39;&#39;&#39;        输入向量，输出感知器的计算结果        &#39;&#39;&#39;        return self.activator(            reduce(lambda a,b: a+b,                    list(map(lambda x,w: x*w,                        input_vec,self.weights)                 ),0.0)+self.bias)    def train(self,input_vecs,labels,iteration,rate):        &#39;&#39;&#39;        输入训练数据：一组向量、与每个向量对应的label；以及训练轮数、学习率        &#39;&#39;&#39;        for i in range(iteration):            self._one_iteration(input_vecs,labels,rate)    def _one_iteration(self,input_vecs,labels,rate):        &#39;&#39;&#39;        迭代，把所有的训练数据过一遍        &#39;&#39;&#39;        samples = zip(input_vecs,labels)        for (input_vec,label) in samples:            output = self.predict(input_vec)            self._update_weights(input_vec,output,label,rate)    def _update_weights(self,input_vec,output,label,rate):        &#39;&#39;&#39;        按照感知器规则更新权重        &#39;&#39;&#39;        delta = label - output        self.weights = map(            lambda x, w:w+rate*delta*x,            input_vec,self.weights)        self.weights = list(self.weights)        self.bias += rate*deltadef f(x):    &#39;&#39;&#39;    定义激活函数    &#39;&#39;&#39;    return 1 if x&gt;0 else 0def get_training_dataset():    &#39;&#39;&#39;    训练数据    &#39;&#39;&#39;    input_vecs = [[1,1],[0,0],[1,0],[0,1]]    labels = [1,0,0,0]    return input_vecs,labelsdef train_and_perceptron():    &#39;&#39;&#39;    训练感知器    &#39;&#39;&#39;    p = Perceptron(2,f)    input_vecs,labels = get_training_dataset()    p.train(input_vecs,labels,10,0.1)    return pif __name__ == &#39;__main__&#39;:    and_perception = train_and_perceptron()    print(and_perception)    print(&#39;1 and 1 = %d&#39; % and_perception.predict([1,1]))    print(&#39;0 and 0 = %d&#39; % and_perception.predict([0,0]))    print(&#39;1 and 0 = %d&#39; % and_perception.predict([1,0]))    print(&#39;0 and 1 = %d&#39; % and_perception.predict([0,1]))</code></pre><blockquote><p>运行结果：<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685949806-ba54dca5-89a6-474a-809c-0b0238184755.png#align=left&display=inline&height=261&id=KN2eh&margin=%5Bobject%20Object%5D&originHeight=261&originWidth=536&size=0&status=done&style=none&width=536"></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> ✨其他 </category>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[转]操作系统核心知识点</title>
      <link href="/blog/spobqi/"/>
      <url>/blog/spobqi/</url>
      
        <content type="html"><![CDATA[<blockquote><blockquote><ul><li>本文转载自：<a href="https://www.cnblogs.com/cxuanBlog/p/13297199.html">5 万字、97 张图总结操作系统核心知识点 - 程序员 cxuan - 博客园</a></li></ul></blockquote></blockquote><blockquote><ul><li>部分内容自行添加</li></ul></blockquote><p>这不是一篇教你如何创建一个操作系统的文章，相反，这是一篇指导性文章，教你从几个方面来理解操作系统。首先你需要知道你为什么要看这篇文章以及为什么要学习操作系统。</p><h2 id="搞清楚几个问题"><a href="#搞清楚几个问题" class="headerlink" title="搞清楚几个问题"></a>搞清楚几个问题</h2><p>首先你要搞明白你学习操作系统的目的是什么？操作系统的重要性如何？学习操作系统会给我带来什么？下面我会从这几个方面为你回答下。</p><p>操作系统也是一种软件，但是操作系统是一种非常复杂的软件。操作系统提供了几种抽象模型</p><ul><li>文件：对 I/O 设备的抽象</li><li>虚拟内存：对程序存储器的抽象</li><li>进程：对一个正在运行程序的抽象</li><li>虚拟机：对整个操作系统的抽象</li></ul><p>这些抽象和我们的日常开发息息相关。搞清楚了操作系统是如何抽象的，才能培养我们的抽象性思维和开发思路。</p><p>很多问题都和操作系统相关，操作系统是解决这些问题的基础。如果你不学习操作系统，可能会想着从框架层面来解决，那是你了解的还不够深入，当你学习了操作系统后，能够培养你的全局性思维。</p><p>学习操作系统我们能够有效的解决<code>并发</code>问题，并发几乎是互联网的重中之重了，这也从侧面说明了学习操作系统的重要性。</p><p>学习操作系统的重点不是让你从头制造一个操作系统，而是告诉你<strong>操作系统是如何工作的</strong>，能够让你对计算机底层有所了解，打实你的基础。</p><p>相信你一定清楚什么是编程</p><p><strong>Data structures + Algorithms = Programming</strong></p><p>操作系统内部会涉及到众多的数据结构和算法描述，能够让你了解算法的基础上，让你编写更优秀的程序。</p><p>我认为可以把计算机比作一栋楼</p><p>计算机的底层相当于就是楼的根基，计算机应用相当于就是楼的外形，而操作系统就相当于是告诉你大楼的构造原理，编写高质量的软件就相当于是告诉你构建一个稳定的房子。</p><h2 id="认识操作系统"><a href="#认识操作系统" class="headerlink" title="认识操作系统"></a>认识操作系统</h2><p>在了解操作系统前，你需要先知道一下什么是计算机系统：现代计算机系统由<strong>一个或多个处理器、主存、打印机、键盘、鼠标、显示器、网络接口以及各种输入/输出设备构成的系统</strong>。这些都属于<code>硬件</code>的范畴。我们程序员不会直接和这些硬件打交道，并且每位程序员不可能会掌握所有计算机系统的细节。</p><p>所以计算机科学家在硬件的基础之上，安装了一层软件，这层软件能够根据用户输入的指令达到控制硬件的效果，从而满足用户的需求，这样的软件称为 <code>操作系统</code>，它的任务就是为用户程序提供一个更好、更简单、更清晰的计算机模型。也就是说，操作系统相当于是一个中间层，为用户层和硬件提供各自的借口，屏蔽了不同应用和硬件之间的差异，达到统一标准的作用。</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829342-133c5955-ce6b-4c7a-9b0e-74e4a24c0f14.png#height=401&id=ahwEU&originHeight=401&originWidth=698&originalType=binary%E2%88%B6=1&size=0&status=done&style=none&width=698"></p><p>上面一个操作系统的简化图，最底层是硬件，硬件包括<strong>芯片、电路板、磁盘、键盘、显示器</strong>等我们上面提到的设备，在硬件之上是软件。大部分计算机有两种运行模式：<code>内核态</code> 和 <code>用户态</code>，软件中最基础的部分是<code>操作系统</code>，它运行在 <code>内核态</code> 中。操作系统具有硬件的访问权，可以执行机器能够运行的任何指令。软件的其余部分运行在 <code>用户态</code> 下。</p><p>在大概了解到操作系统之后，我们先来认识一下硬件都有哪些</p><h2 id="计算机硬件"><a href="#计算机硬件" class="headerlink" title="计算机硬件"></a>计算机硬件</h2><p>计算机硬件是计算机的重要组成部分，其中包含了 5 个重要的组成部分：<strong>运算器、控制器、存储器、输入设备、输出设备</strong>。</p><ul><li><code>运算器</code>：运算器最主要的功能是对数据和信息进行加工和运算。它是计算机中执行算数和各种逻辑运算的部件。运算器的基本运算包括加、减、乘、除、移位等操作，这些是由 <code>算术逻辑单元(Arithmetic&amp;logical Unit)</code> 实现的。而运算器主要由算数逻辑单元和寄存器构成。</li><li><code>控制器</code>：指按照指定顺序改变主电路或控制电路的部件，它主要起到了控制命令执行的作用，完成协调和指挥整个计算机系统的操作。控制器是由程序计数器、指令寄存器、解码译码器等构成。</li></ul><blockquote><p>运算器和控制器共同组成了 CPU</p></blockquote><ul><li><code>存储器</code>：存储器就是计算机的<code>记忆设备</code>，顾名思义，存储器可以保存信息。存储器分为两种，一种是主存，也就是内存，它是 CPU 主要交互对象，还有一种是外存，比如硬盘软盘等。下面是现代计算机系统的存储架构</li><li><code>输入设备</code>：输入设备是给计算机获取外部信息的设备，它主要包括键盘和鼠标。</li><li><code>输出设备</code>：输出设备是给用户呈现根据输入设备获取的信息经过一系列的计算后得到显示的设备，它主要包括显示器、打印机等。</li></ul><p>这五部分也是冯诺伊曼的体系结构，它认为计算机必须具有如下功能：</p><p>把需要的程序和数据送至计算机中。必须具有长期记忆程序、数据、中间结果及最终运算结果的能力。能够完成各种算术、逻辑运算和数据传送等数据加工处理的能力。能够根据需要控制程序走向，并能根据指令控制机器的各部件协调操作。能够按照要求将处理结果输出给用户。</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829342-9ed0fc8c-06fb-431d-8db6-2caaca0abc0f.png#height=287&id=qMDVd&originHeight=287&originWidth=721&originalType=binary%E2%88%B6=1&size=0&status=done&style=none&width=721"></p><p>下面是一张 intel 家族产品图，是一个详细的计算机硬件分类，我们在根据图中涉及到硬件进行介绍</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829351-810b3b3e-2849-45d3-96c8-62280633f4a6.png#height=534&id=ZSJw7&originHeight=534&originWidth=747&originalType=binary%E2%88%B6=1&size=0&status=done&style=none&width=747"></p><ul><li><code>总线(Buses)</code>：在整个系统中运行的是称为总线的电气管道的集合，这些总线在组件之间来回传输字节信息。通常总线被设计成传送定长的字节块，也就是 <code>字(word)</code>。字中的字节数（字长）是一个基本的系统参数，各个系统中都不尽相同。现在大部分的字都是 4 个字节（32 位）或者 8 个字节（64 位）。</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829372-677cad04-111e-4904-a865-109bf7e95c9c.png#height=280&id=GR4Q2&originHeight=280&originWidth=731&originalType=binary%E2%88%B6=1&size=0&status=done&style=none&width=731"></p><ul><li><code>I/O 设备(I/O Devices)</code>：Input/Output 设备是系统和外部世界的连接。上图中有四类 I/O 设备：用于用户输入的键盘和鼠标，用于用户输出的显示器，一个磁盘驱动用来长时间的保存数据和程序。刚开始的时候，可执行程序就保存在磁盘上。<br>每个 I/O 设备连接 I/O 总线都被称为<code>控制器(controller)</code> 或者是 <code>适配器(Adapter)</code>。控制器和适配器之间的主要区别在于封装方式。控制器是 I/O 设备本身或者系统的主印制板电路（通常称作主板）上的芯片组。而适配器则是一块插在主板插槽上的卡。无论组织形式如何，它们的最终目的都是彼此交换信息。</li><li><code>主存(Main Memory)</code>，主存是一个<code>临时存储设备</code>，而不是永久性存储，磁盘是 <code>永久性存储</code> 的设备。主存既保存程序，又保存处理器执行流程所处理的数据。从物理组成上说，主存是由一系列 <code>DRAM(dynamic random access memory)</code> 动态随机存储构成的集合。逻辑上说，内存就是一个线性的字节数组，有它唯一的地址编号，从 0 开始。一般来说，组成程序的每条机器指令都由不同数量的字节构成，C 程序变量相对应的数据项的大小根据类型进行变化。比如，在 Linux 的 x86-64 机器上，short 类型的数据需要 2 个字节，int 和 float 需要 4 个字节，而 long 和 double 需要 8 个字节。</li><li><code>处理器(Processor)</code>，<code>CPU(central processing unit)</code> 或者简单的处理器，是解释（并执行）存储在主存储器中的指令的引擎。处理器的核心大小为一个字的存储设备（或寄存器），称为<code>程序计数器(PC)</code>。在任何时刻，PC 都指向主存中的某条机器语言指令（即含有该条指令的地址）。<br>从系统通电开始，直到系统断电，处理器一直在不断地执行程序计数器指向的指令，再更新程序计数器，使其指向下一条指令。处理器根据其指令集体系结构定义的指令模型进行操作。在这个模型中，指令按照严格的顺序执行，执行一条指令涉及执行一系列的步骤。处理器从程序计数器指向的内存中读取指令，解释指令中的位，执行该指令指示的一些简单操作，然后更新程序计数器以指向下一条指令。指令与指令之间可能连续，可能不连续（比如 jmp 指令就不会顺序读取）</li></ul><p>下面是 CPU 可能执行简单操作的几个步骤</p><ul><li><code>加载(Load)</code>：从主存中拷贝一个字节或者一个字到内存中，覆盖寄存器先前的内容</li><li><code>存储(Store)</code>：将寄存器中的字节或字复制到主存储器中的某个位置，从而覆盖该位置的先前内容</li><li><code>操作(Operate)</code>：把两个寄存器的内容复制到 <code>ALU(Arithmetic logic unit)</code> 。把两个字进行算术运算，并把结果存储在寄存器中，重写寄存器先前的内容。</li></ul><blockquote><p>算术逻辑单元（ALU）是对数字二进制数执行算术和按位运算的组合数字电子电路。</p></blockquote><ul><li><code>跳转(jump)</code>：从指令中抽取一个字，把这个字复制到<code>程序计数器(PC)</code> 中，覆盖原来的值</li></ul><h2 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h2><p>关于进程和线程，你需要理解下面这张脑图中的重点</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829389-4c3de174-e023-4600-b910-b01112bd2f4c.png#height=736&id=tvXh9&originHeight=736&originWidth=734&originalType=binary%E2%88%B6=1&size=0&status=done&style=none&width=734"></p><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>操作系统中最核心的概念就是 <code>进程</code>，进程是对正在运行中的程序的一个抽象。操作系统的其他所有内容都是围绕着进程展开的。</p><p>在多道程序处理的系统中，CPU 会在<code>进程</code>间快速切换，使每个程序运行几十或者几百毫秒。然而，严格意义来说，在某一个瞬间，CPU 只能运行一个进程，然而我们如果把时间定位为 1 秒内的话，它可能运行多个进程。这样就会让我们产生<code>并行</code>的错觉。因为 CPU 执行速度很快，进程间的换进换出也非常迅速，因此我们很难对多个并行进程进行跟踪。所以，操作系统的设计者开发了用于描述并行的一种概念模型（顺序进程），使得并行更加容易理解和分析。</p><h3 id="进程模型"><a href="#进程模型" class="headerlink" title="进程模型"></a>进程模型</h3><p>一个进程就是一个正在执行的程序的实例，进程也包括程序计数器、寄存器和变量的当前值。从概念上来说，每个进程都有各自的虚拟 CPU，但是实际情况是 CPU 会在各个进程之间进行来回切换。</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829609-9880b940-5163-45d4-8ef6-b559ab53b55d.png#height=351&id=XCIWa&originHeight=351&originWidth=455&originalType=binary%E2%88%B6=1&size=0&status=done&style=none&width=455"></p><p>如上图所示，这是一个具有 4 个程序的多道处理程序，在进程不断切换的过程中，程序计数器也在不同的变化。</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829415-2d4059be-d447-4abf-8e77-2df51d6cc6a1.png#height=338&id=CNsvU&originHeight=338&originWidth=647&originalType=binary%E2%88%B6=1&size=0&status=done&style=none&width=647"></p><p>在上图中，这 4 道程序被抽象为 4 个拥有各自控制流程（即每个自己的程序计数器）的进程，并且每个程序都独立的运行。当然，实际上只有一个物理程序计数器，每个程序要运行时，其逻辑程序计数器会装载到物理程序计数器中。当程序运行结束后，其物理程序计数器就会是真正的程序计数器，然后再把它放回进程的逻辑计数器中。</p><p>从下图我们可以看到，在观察足够长的一段时间后，所有的进程都运行了，<strong>但在任何一个给定的瞬间仅有一个进程真正运行</strong>。</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829611-a49b5e88-0d0e-42c3-a103-485b6e5c984b.png#height=274&id=Zm8OZ&originHeight=274&originWidth=578&originalType=binary%E2%88%B6=1&size=0&status=done&style=none&width=578"></p><p>因此，当我们说一个 CPU 只能真正一次运行一个进程的时候，即使有 2 个核（或 CPU），<strong>每一个核也只能一次运行一个线程</strong>。</p><p>由于 CPU 会在各个进程之间来回快速切换，所以每个进程在 CPU 中的运行时间是无法确定的。并且当同一个进程再次在 CPU 中运行时，其在 CPU 内部的运行时间往往也是不固定的。</p><p>这里的关键思想是<code>认识到一个进程所需的条件</code>，进程是某一类特定活动的总和，它有程序、输入输出以及状态。</p><h3 id="进程的创建"><a href="#进程的创建" class="headerlink" title="进程的创建"></a>进程的创建</h3><p>操作系统需要一些方式来创建进程。下面是一些创建进程的方式</p><ul><li>系统初始化（init）：启动操作系统时，通常会创建若干个进程。</li><li>正在运行的程序执行了创建进程的系统调用（比如 fork）</li><li>用户请求创建一个新进程：在许多交互式系统中，输入一个命令或者双击图标就可以启动程序，以上任意一种操作都可以选择开启一个新的进程，在基本的 UNIX 系统中运行 X，新进程将接管启动它的窗口。</li><li>初始化一个批处理工作</li></ul><p>从技术上讲，在所有这些情况下，让现有流程执行流程是通过创建系统调用来创建新流程的。该进程可能是正在运行的用户进程，是从键盘或鼠标调用的系统进程或批处理程序。这些就是系统调用创建新进程的过程。该系统调用告诉操作系统创建一个新进程，并直接或间接指示在其中运行哪个程序。</p><p>在 UNIX 中，仅有一个系统调用来创建一个新的进程，这个系统调用就是 <code>fork</code>。这个调用会创建一个与调用进程相关的副本。在 fork 后，一个父进程和子进程会有相同的<code>内存映像</code>，相同的环境字符串和相同的打开文件。</p><p>在 Windows 中，情况正相反，一个简单的 Win32 功能调用 <code>CreateProcess</code>，会处理流程创建并将正确的程序加载到新的进程中。这个调用会有 10 个参数，包括了需要执行的程序、输入给程序的命令行参数、各种安全属性、有关打开的文件是否继承控制位、优先级信息、进程所需要创建的窗口规格以及指向一个结构的指针，在该结构中新创建进程的信息被返回给调用者。<strong>在 Windows 中，从一开始父进程的地址空间和子进程的地址空间就是不同的</strong>。</p><h3 id="进程的终止"><a href="#进程的终止" class="headerlink" title="进程的终止"></a>进程的终止</h3><p>进程在创建之后，它就开始运行并做完成任务。然而，没有什么事儿是永不停歇的，包括进程也一样。进程早晚会发生终止，但是通常是由于以下情况触发的</p><ul><li><code>正常退出(自愿的)</code> ： 多数进程是由于完成了工作而终止。当编译器完成了所给定程序的编译之后，编译器会执行一个系统调用告诉操作系统它完成了工作。这个调用在 UNIX 中是 <code>exit</code> ，在 Windows 中是 <code>ExitProcess</code>。</li><li><code>错误退出(自愿的)</code>：比如执行一条不存在的命令，于是编译器就会提醒并退出。</li><li><code>严重错误(非自愿的)</code></li><li><code>被其他进程杀死(非自愿的)</code> ： 某个进程执行系统调用告诉操作系统杀死某个进程。在 UNIX 中，这个系统调用是 kill。在 Win32 中对应的函数是 <code>TerminateProcess</code>（注意不是系统调用）。</li></ul><h3 id="进程的层次结构"><a href="#进程的层次结构" class="headerlink" title="进程的层次结构"></a>进程的层次结构</h3><p>在一些系统中，当一个进程创建了其他进程后，父进程和子进程就会以某种方式进行关联。子进程它自己就会创建更多进程，从而形成一个进程层次结构。</p><h4 id="UNIX-进程体系"><a href="#UNIX-进程体系" class="headerlink" title="UNIX 进程体系"></a>UNIX 进程体系</h4><p>在 UNIX 中，进程和它的所有子进程以及子进程的子进程共同组成一个进程组。当用户从键盘中发出一个信号后，该信号被发送给当前与键盘相关的进程组中的所有成员（它们通常是在当前窗口创建的所有活动进程）。每个进程可以分别捕获该信号、忽略该信号或采取默认的动作，即被信号 kill 掉。整个操作系统中所有的进程都隶属于一个单个以 init 为根的进程树。</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829468-bff503cb-cf97-4853-aca3-35db5bb67312.png#height=192&id=TUggO&originHeight=192&originWidth=615&originalType=binary%E2%88%B6=1&size=0&status=done&style=none&width=615"></p><h4 id="Windows-进程体系"><a href="#Windows-进程体系" class="headerlink" title="Windows 进程体系"></a>Windows 进程体系</h4><p>相反，Windows 中没有进程层次的概念，Windows 中所有进程都是平等的，唯一类似于层次结构的是在创建进程的时候，父进程得到一个特别的令牌（称为句柄），该句柄可以用来控制子进程。然而，这个令牌可能也会移交给别的操作系统，这样就不存在层次结构了。而在 UNIX 中，进程不能剥夺其子进程的 <code>进程权</code>。（这样看来，还是 Windows 比较<code>渣</code>）。</p><h3 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h3><p>尽管每个进程是一个独立的实体，有其自己的程序计数器和内部状态，但是，进程之间仍然需要相互帮助。当一个进程开始运行时，它可能会经历下面这几种状态</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829472-6b2e277f-f4b9-4f38-805d-e9ac73f33129.png#height=495&id=nVHjc&originHeight=495&originWidth=734&originalType=binary%E2%88%B6=1&size=0&status=done&style=none&width=734"></p><p>图中会涉及三种状态</p><ol><li><code>运行态</code>，运行态指的就是进程实际占用 CPU 时间片运行时</li><li><code>就绪态</code>，就绪态指的是可运行，但因为其他进程正在运行而处于就绪状态</li><li><code>阻塞态</code>，除非某种外部事件发生，否则进程不能运行</li></ol><h3 id="进程的实现"><a href="#进程的实现" class="headerlink" title="进程的实现"></a>进程的实现</h3><p>操作系统为了执行进程间的切换，会维护着一张表，这张表就是 <code>进程表(process table)</code>。每个进程占用一个进程表项。该表项包含了进程状态的重要信息，包括程序计数器、堆栈指针、内存分配状况、所打开文件的状态、账号和调度信息，以及其他在进程由运行态转换到就绪态或阻塞态时所必须保存的信息。</p><p>下面展示了一个典型系统中的关键字段</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829487-6d8a6e92-d068-48a8-b5a0-9e5b74f9ab3f.png#height=500&id=Sr874&originHeight=500&originWidth=749&originalType=binary%E2%88%B6=1&size=0&status=done&style=none&width=749"></p><p>第一列内容与<code>进程管理</code>有关，第二列内容与 <code>存储管理</code>有关，第三列内容与<code>文件管理</code>有关。</p><p>现在我们应该对进程表有个大致的了解了，就可以在对单个 CPU 上如何运行多个顺序进程的错觉做更多的解释。与每一 I/O 类相关联的是一个称作 <code>中断向量(interrupt vector)</code> 的位置（靠近内存底部的固定区域）。它包含中断服务程序的入口地址。假设当一个磁盘中断发生时，用户进程 3 正在运行，则中断硬件将程序计数器、程序状态字、有时还有一个或多个寄存器压入堆栈，计算机随即跳转到中断向量所指示的地址。这就是硬件所做的事情。然后软件就随即接管一切剩余的工作。</p><p>当中断结束后，操作系统会调用一个 C 程序来处理中断剩下的工作。在完成剩下的工作后，会使某些进程就绪，接着调用调度程序，决定随后运行哪个进程。然后将控制权转移给一段汇编语言代码，为当前的进程装入寄存器值以及内存映射并启动该进程运行，下面显示了中断处理和调度的过程。</p><ol><li>硬件压入堆栈程序计数器等</li><li>硬件从中断向量装入新的程序计数器</li><li>汇编语言过程保存寄存器的值</li><li>汇编语言过程设置新的堆栈</li><li>C 中断服务器运行（典型的读和缓存写入）</li><li>调度器决定下面哪个程序先运行</li><li>C 过程返回至汇编代码</li><li>汇编语言过程开始运行新的当前进程</li></ol><p>一个进程在执行过程中可能被中断数千次，但关键每次中断后，被中断的进程都返回到与中断发生前完全相同的状态。</p><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>在传统的操作系统中，每个进程都有一个地址空间和一个控制线程。事实上，这是大部分进程的定义。不过，在许多情况下，经常存在同一地址空间中运行多个控制线程的情形，这些线程就像是分离的进程。下面我们就着重探讨一下什么是线程</p><h3 id="线程的使用"><a href="#线程的使用" class="headerlink" title="线程的使用"></a>线程的使用</h3><p>或许这个疑问也是你的疑问，为什么要在进程的基础上再创建一个线程的概念，准确的说，这其实是进程模型和线程模型的讨论，回答这个问题，可能需要分三步来回答</p><ul><li>多线程之间会共享同一块地址空间和所有可用数据的能力，这是进程所不具备的</li><li>线程要比进程<code>更轻量级</code>，由于线程更轻，所以它比进程更容易创建，也更容易撤销。在许多系统中，创建一个线程要比创建一个进程快 10 - 100 倍。</li><li>第三个原因可能是性能方面的探讨，如果多个线程都是 CPU 密集型的，那么并不能获得性能上的增强，但是如果存在着大量的计算和大量的 I/O 处理，拥有多个线程能在这些活动中彼此重叠进行，从而会加快应用程序的执行速度</li></ul><h3 id="经典的线程模型"><a href="#经典的线程模型" class="headerlink" title="经典的线程模型"></a>经典的线程模型</h3><p>进程中拥有一个执行的线程，通常简写为 <code>线程(thread)</code>。线程会有程序计数器，用来记录接着要执行哪一条指令；线程实际上 CPU 上调度执行的实体。</p><p>下图我们可以看到三个传统的进程，每个进程有自己的地址空间和单个控制线程。每个线程都在不同的地址空间中运行</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829491-73cfd311-e3e5-4381-886b-f904f3c8ca5c.png#height=466&id=lfuB1&originHeight=466&originWidth=658&originalType=binary%E2%88%B6=1&size=0&status=done&style=none&width=658"></p><p>下图中，我们可以看到有一个进程三个线程的情况。每个线程都在相同的地址空间中运行。</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829501-7e5370fc-b9ec-4804-a862-9c86e00bf231.png#height=429&id=uVJR7&originHeight=429&originWidth=640&originalType=binary%E2%88%B6=1&size=0&status=done&style=none&width=640"></p><p>线程不像是进程那样具备较强的独立性。同一个进程中的所有线程都会有完全一样的地址空间，这意味着它们也共享同样的全局变量。由于每个线程都可以访问进程地址空间内每个内存地址，<strong>因此一个线程可以读取、写入甚至擦除另一个线程的堆栈</strong>。线程之间除了共享同一内存空间外，还具有如下不同的内容</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829530-1ce4e3bb-f3b4-4fae-bd6b-2a09cb86e2d3.png#height=333&id=GpbmQ&originHeight=333&originWidth=583&originalType=binary%E2%88%B6=1&size=0&status=done&style=none&width=583"></p><p>上图左边的是同一个进程中<code>每个线程共享</code>的内容，上图右边是<code>每个线程</code>中的内容。也就是说左边的列表是进程的属性，右边的列表是线程的属性。</p><p><strong>线程之间的状态转换和进程之间的状态转换是一样的</strong>。</p><p>每个线程都会有自己的堆栈，如下图所示</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829586-41932660-4ab5-42e2-bbb1-bbd660b183f6.png#height=482&id=WnFPn&originHeight=482&originWidth=682&originalType=binary%E2%88%B6=1&size=0&status=done&style=none&width=682"></p><h4 id="线程系统调用"><a href="#线程系统调用" class="headerlink" title="线程系统调用"></a>线程系统调用</h4><p>进程通常会从当前的某个单线程开始，然后这个线程通过调用一个库函数（比如 <code>thread_create</code> ）创建新的线程。线程创建的函数会要求指定新创建线程的名称。创建的线程通常都返回一个线程标识符，该标识符就是新线程的名字。</p><p>当一个线程完成工作后，可以通过调用一个函数（比如 <code>thread_exit</code>）来退出。紧接着线程消失，状态变为终止，不能再进行调度。在某些线程的运行过程中，可以通过调用函数例如 <code>thread_join</code> ，表示一个线程可以等待另一个线程退出。这个过程阻塞调用线程直到等待特定的线程退出。在这种情况下，线程的创建和终止非常类似于进程的创建和终止。</p><p>另一个常见的线程是调用 <code>thread_yield</code>，它允许线程自动放弃 CPU 从而让另一个线程运行。这样一个调用还是很重要的，因为不同于进程，线程是无法利用时钟中断强制让线程让出 CPU 的。</p><h3 id="POSIX-线程"><a href="#POSIX-线程" class="headerlink" title="POSIX 线程"></a>POSIX 线程</h3><p><code>POSIX 线程 通常称为 pthreads</code>是一种独立于语言而存在的执行模型，以及并行执行模型。</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829568-3bded50a-8029-4644-9e42-c2c6ddf60ca1.png#height=645&id=ZELdp&originHeight=645&originWidth=639&originalType=binary%E2%88%B6=1&size=0&status=done&style=none&width=639"></p><p>它允许程序控制时间上重叠的多个不同的工作流程。每个工作流程都称为一个线程，可以通过调用 POSIX Threads API 来实现对这些流程的创建和控制。可以把它理解为线程的标准。</p><blockquote><p>POSIX Threads 的实现在许多类似且符合 POSIX 的操作系统上可用，例如 <strong>FreeBSD、NetBSD、OpenBSD、Linux、macOS、Android、Solaris</strong>，它在现有 Windows API 之上实现了<strong>pthread</strong>。<br>IEEE 是世界上最大的技术专业组织，致力于为人类的利益而发展技术。</p></blockquote><table><thead><tr><th>线程调用</th><th>描述</th></tr></thead><tbody><tr><td>pthread_create</td><td>创建一个新线程</td></tr><tr><td>pthread_exit</td><td>结束调用的线程</td></tr><tr><td>pthread_join</td><td>等待一个特定的线程退出</td></tr><tr><td>pthread_yield</td><td>释放 CPU 来运行另外一个线程</td></tr><tr><td>pthread_attr_init</td><td>创建并初始化一个线程的属性结构</td></tr><tr><td>pthread_attr_destory</td><td>删除一个线程的属性结构</td></tr></tbody></table><p>所有的 Pthreads 都有特定的属性，每一个都含有标识符、一组寄存器（包括程序计数器）和一组存储在结构中的属性。这个属性包括堆栈大小、调度参数以及其他线程需要的项目。</p><h3 id="线程实现"><a href="#线程实现" class="headerlink" title="线程实现"></a>线程实现</h3><p>主要有三种实现方式</p><ul><li>在用户空间中实现线程；</li><li>在内核空间中实现线程；</li><li>在用户和内核空间中混合实现线程。</li></ul><p>下面我们分开讨论一下</p><h4 id="在用户空间中实现线程"><a href="#在用户空间中实现线程" class="headerlink" title="在用户空间中实现线程"></a>在用户空间中实现线程</h4><p>第一种方法是把整个线程包放在用户空间中，内核对线程一无所知，它不知道线程的存在。所有的这类实现都有同样的通用结构</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829565-1733358e-dbe8-4e1e-ab32-50b95d98a6e3.png#height=466&id=uVF3u&originHeight=466&originWidth=599&originalType=binary%E2%88%B6=1&size=0&status=done&style=none&width=599"></p><p>线程在运行时系统之上运行，运行时系统是管理线程过程的集合，包括前面提到的四个过程： pthread_create, pthread_exit, pthread_join 和 pthread_yield。</p><h3 id="在内核中实现线程"><a href="#在内核中实现线程" class="headerlink" title="在内核中实现线程"></a>在内核中实现线程</h3><p>当某个线程希望创建一个新线程或撤销一个已有线程时，它会进行一个系统调用，这个系统调用通过对线程表的更新来完成线程创建或销毁工作。</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829600-91569966-c35c-4db1-858b-f7fcae7729c3.png#height=515&id=hh20v&originHeight=515&originWidth=600&originalType=binary%E2%88%B6=1&size=0&status=done&style=none&width=600"></p><p>内核中的线程表持有每个线程的寄存器、状态和其他信息。这些信息和用户空间中的线程信息相同，但是位置却被放在了内核中而不是用户空间中。另外，内核还维护了一张进程表用来跟踪系统状态。</p><p>所有能够阻塞的调用都会通过系统调用的方式来实现，当一个线程阻塞时，内核可以进行选择，是运行在同一个进程中的另一个线程（如果有就绪线程的话）还是运行一个另一个进程中的线程。但是在用户实现中，运行时系统始终运行自己的线程，直到内核剥夺它的 CPU 时间片（或者没有可运行的线程存在了）为止。</p><h3 id="混合实现"><a href="#混合实现" class="headerlink" title="混合实现"></a>混合实现</h3><p>结合用户空间和内核空间的优点，设计人员采用了一种<code>内核级线程</code>的方式，然后将用户级线程与某些或者全部内核线程多路复用起来</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829624-481cc859-db6d-4516-8dc4-6ea9f958c022.png#height=463&id=z1E6R&originHeight=463&originWidth=647&originalType=binary%E2%88%B6=1&size=0&status=done&style=none&width=647"></p><p>在这种模型中，编程人员可以自由控制用户线程和内核线程的数量，具有很大的灵活度。采用这种方法，内核只识别内核级线程，并对其进行调度。其中一些内核级线程会被多个用户级线程多路复用。</p><h2 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h2><p>进程是需要频繁的和其他进程进行交流的。下面我们会一起讨论有关 <code>进程间通信(Inter Process Communication, IPC)</code> 的问题。大致来说，进程间的通信机制可以分为 6 种</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829616-22b9e251-36fa-4a65-8102-204b899c01ca.png#height=602&id=WxiTX&originHeight=602&originWidth=772&originalType=binary%E2%88%B6=1&size=0&status=done&style=none&width=772"></p><p>下面我们分别对其进行概述</p><h3 id="信号-signal"><a href="#信号-signal" class="headerlink" title="信号 signal"></a>信号 signal</h3><p>信号是 UNIX 系统最先开始使用的进程间通信机制，因为 Linux 是继承于 UNIX 的，所以 Linux 也支持信号机制，通过向一个或多个进程发送<code>异步事件信号</code>来实现，信号可以从键盘或者访问不存在的位置等地方产生；信号通过 shell 将任务发送给子进程。</p><p>你可以在 Linux 系统上输入 <code>kill -l</code> 来列出系统使用的信号，下面是我提供的一些信号</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829652-e25e8aaa-523f-49e7-91a6-13af7872483a.png#height=269&id=iFTA7&originHeight=269&originWidth=736&originalType=binary%E2%88%B6=1&size=0&status=done&style=none&width=736"></p><p>进程可以选择忽略发送过来的信号，但是有两个是不能忽略的：<code>SIGSTOP</code> 和 <code>SIGKILL</code> 信号。SIGSTOP 信号会通知当前正在运行的进程执行关闭操作，SIGKILL 信号会通知当前进程应该被杀死。除此之外，进程可以选择它想要处理的信号，进程也可以选择阻止信号，如果不阻止，可以选择自行处理，也可以选择进行内核处理。如果选择交给内核进行处理，那么就执行默认处理。</p><p>操作系统会中断目标程序的进程来向其发送信号、在任何非原子指令中，执行都可以中断，如果进程已经注册了新号处理程序，那么就执行进程，如果没有注册，将采用默认处理的方式。</p><h3 id="管道-pipe"><a href="#管道-pipe" class="headerlink" title="管道 pipe"></a>管道 pipe</h3><p>Linux 系统中的进程可以通过建立管道 pipe 进行通信</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829658-0cfbf5f9-97b3-4972-8205-7953cdab82b7.png#height=413&id=UyA6r&originHeight=413&originWidth=729&originalType=binary%E2%88%B6=1&size=0&status=done&style=none&width=729"></p><p>在两个进程之间，可以建立一个通道，一个进程向这个通道里写入字节流，另一个进程从这个管道中读取字节流。管道是同步的，当进程尝试从空管道读取数据时，该进程会被阻塞，直到有可用数据为止。shell 中的<code>管线 pipelines</code> 就是用管道实现的，当 shell 发现输出</p><pre><code class="null">sort &lt;f | head</code></pre><p>它会创建两个进程，一个是 sort，一个是 head，sort，会在这两个应用程序之间建立一个管道使得 sort 进程的标准输出作为 head 程序的标准输入。sort 进程产生的输出就不用写到文件中了，如果管道满了系统会停止 sort 以等待 head 读出数据</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829684-0f55014e-302f-4dbe-9ea8-9ee4d6c9fdeb.png#height=396&id=irplH&originHeight=396&originWidth=488&originalType=binary%E2%88%B6=1&size=0&status=done&style=none&width=488"></p><p>管道实际上就是 <code>|</code>，两个应用程序不知道有管道的存在，一切都是由 shell 管理和控制的。</p><h3 id="共享内存-shared-memory"><a href="#共享内存-shared-memory" class="headerlink" title="共享内存 shared memory"></a>共享内存 shared memory</h3><p>两个进程之间还可以通过共享内存进行进程间通信，其中两个或者多个进程可以访问公共内存空间。两个进程的共享工作是通过共享内存完成的，一个进程所作的修改可以对另一个进程可见(很像线程间的通信)。</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829708-7158a6ec-203c-42aa-96bb-7946e3fb959a.png#height=249&id=WYSoT&originHeight=249&originWidth=659&originalType=binary%E2%88%B6=1&size=0&status=done&style=none&width=659"></p><p>在使用共享内存前，需要经过一系列的调用流程，流程如下</p><ul><li>创建共享内存段或者使用已创建的共享内存段<code>(shmget())</code></li><li>将进程附加到已经创建的内存段中<code>(shmat())</code></li><li>从已连接的共享内存段分离进程<code>(shmdt())</code></li><li>对共享内存段执行控制操作<code>(shmctl())</code></li></ul><h3 id="先入先出队列-FIFO"><a href="#先入先出队列-FIFO" class="headerlink" title="先入先出队列 FIFO"></a>先入先出队列 FIFO</h3><p>先入先出队列 FIFO 通常被称为 <code>命名管道(Named Pipes)</code>，命名管道的工作方式与常规管道非常相似，但是确实有一些明显的区别。未命名的管道没有备份文件：操作系统负责维护内存中的缓冲区，用来将字节从写入器传输到读取器。一旦写入或者输出终止的话，缓冲区将被回收，传输的数据会丢失。相比之下，命名管道具有支持文件和独特 API ，命名管道在文件系统中作为设备的专用文件存在。当所有的进程通信完成后，命名管道将保留在文件系统中以备后用。命名管道具有严格的 FIFO 行为</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829713-f872efe8-5031-4f02-89ad-8c8351a854c7.png#height=192&id=gHPi1&originHeight=192&originWidth=584&originalType=binary%E2%88%B6=1&size=0&status=done&style=none&width=584"></p><p>写入的第一个字节是读取的第一个字节，写入的第二个字节是读取的第二个字节，依此类推。</p><h3 id="消息队列-Message-Queue"><a href="#消息队列-Message-Queue" class="headerlink" title="消息队列 Message Queue"></a>消息队列 Message Queue</h3><p>一听到消息队列这个名词你可能不知道是什么意思，消息队列是用来描述内核寻址空间内的内部链接列表。可以按几种不同的方式将消息按顺序发送到队列并从队列中检索消息。每个消息队列由 IPC 标识符唯一标识。消息队列有两种模式，一种是<code>严格模式</code>， 严格模式就像是 FIFO 先入先出队列似的，消息顺序发送，顺序读取。还有一种模式是 <code>非严格模式</code>，消息的顺序性不是非常重要。</p><h3 id="套接字-Socket"><a href="#套接字-Socket" class="headerlink" title="套接字 Socket"></a>套接字 Socket</h3><p>还有一种管理两个进程间通信的是使用 <code>socket</code>，socket 提供端到端的双相通信。一个套接字可以与一个或多个进程关联。就像管道有命令管道和未命名管道一样，套接字也有两种模式，套接字一般用于两个进程之间的网络通信，网络套接字需要来自诸如<code>TCP（传输控制协议）</code>或较低级别<code>UDP（用户数据报协议）</code>等基础协议的支持。</p><p>套接字有以下几种分类</p><ul><li><code>顺序包套接字(Sequential Packet Socket)</code>： 此类套接字为最大长度固定的数据报提供可靠的连接。此连接是双向的并且是顺序的。</li><li><code>数据报套接字(Datagram Socket)</code>：数据包套接字支持双向数据流。数据包套接字接受消息的顺序与发送者可能不同。</li><li><code>流式套接字(Stream Socket)</code>：流套接字的工作方式类似于电话对话，提供双向可靠的数据流。</li><li><code>原始套接字(Raw Socket)</code>： 可以使用原始套接字访问基础通信协议。</li></ul><h2 id="调度"><a href="#调度" class="headerlink" title="调度"></a>调度</h2><p>当一个计算机是多道程序设计系统时，会频繁的有很多进程或者线程来同时竞争 CPU 时间片。当两个或两个以上的进程/线程处于就绪状态时，就会发生这种情况。如果只有一个 CPU 可用，那么必须选择接下来哪个进程/线程可以运行。操作系统中有一个叫做 <code>调度程序(scheduler)</code> 的角色存在，它就是做这件事儿的，该程序使用的算法叫做 <code>调度算法(scheduling algorithm)</code> 。</p><h3 id="调度算法的分类"><a href="#调度算法的分类" class="headerlink" title="调度算法的分类"></a>调度算法的分类</h3><p>毫无疑问，不同的环境下需要不同的调度算法。之所以出现这种情况，是因为不同的应用程序和不同的操作系统有不同的目标。也就是说，在不同的系统中，调度程序的优化也是不同的。这里有必要划分出三种环境</p><ul><li><code>批处理(Batch)</code> : 商业领域</li><li><code>交互式(Interactive)</code> ： 交互式用户环境</li><li><code>实时(Real time)</code></li></ul><h3 id="批处理中的调度"><a href="#批处理中的调度" class="headerlink" title="批处理中的调度"></a>批处理中的调度</h3><p>现在让我们把目光从一般性的调度转换为特定的调度算法。下面我们会探讨在批处理中的调度。</p><h4 id="先来先服务"><a href="#先来先服务" class="headerlink" title="先来先服务"></a>先来先服务</h4><p>最简单的非抢占式调度算法的设计就是 <code>先来先服务(first-come,first-serverd)</code>。当第一个任务从外部进入系统时，将会立即启动并允许运行任意长的时间。它不会因为运行时间太长而中断。当其他作业进入时，它们排到就绪队列尾部。当正在运行的进程阻塞，处于等待队列的第一个进程就开始运行。当一个阻塞的进程重新处于就绪态时，它会像一个新到达的任务，会排在队列的末尾，即排在所有进程最后。</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829697-a9e6978f-5f26-4491-8a57-4691ea81546b.png#height=622&id=fZNys&originHeight=622&originWidth=709&originalType=binary%E2%88%B6=1&size=0&status=done&style=none&width=709"></p><p>这个算法的强大之处在于易于理解和编程，在这个算法中，一个单链表记录了所有就绪进程。要选取一个进程运行，只要从该队列的头部移走一个进程即可；要添加一个新的作业或者阻塞一个进程，只要把这个作业或进程附加在队列的末尾即可。这是很简单的一种实现。</p><h4 id="最短作业优先"><a href="#最短作业优先" class="headerlink" title="最短作业优先"></a>最短作业优先</h4><p>批处理中，第二种调度算法是 <code>最短作业优先(Shortest Job First)</code>，我们假设运行时间已知。例如，一家保险公司，因为每天要做类似的工作，所以人们可以相当精确地预测处理 1000 个索赔的一批作业需要多长时间。当输入队列中有若干个同等重要的作业被启动时，调度程序应使用最短优先作业算法</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829752-b3677366-5828-45be-9c62-d182dce0a26e.png#height=200&id=LgBd9&originHeight=200&originWidth=695&originalType=binary%E2%88%B6=1&size=0&status=done&style=none&width=695"></p><blockquote><p>需要注意的是，在所有的进程都可以运行的情况下，最短作业优先的算法才是最优的。</p></blockquote><h4 id="最短剩余时间优先"><a href="#最短剩余时间优先" class="headerlink" title="最短剩余时间优先"></a>最短剩余时间优先</h4><p>最短作业优先的抢占式版本被称作为 <code>最短剩余时间优先(Shortest Remaining Time Next)</code> 算法。使用这个算法，调度程序总是选择剩余运行时间最短的那个进程运行。</p><h3 id="交互式系统中的调度"><a href="#交互式系统中的调度" class="headerlink" title="交互式系统中的调度"></a>交互式系统中的调度</h3><p>交互式系统中在个人计算机、服务器和其他系统中都是很常用的，所以有必要来探讨一下交互式调度</p><h4 id="轮询调度"><a href="#轮询调度" class="headerlink" title="轮询调度"></a>轮询调度</h4><p>一种最古老、最简单、最公平并且最广泛使用的算法就是 <code>轮询算法(round-robin)</code>。每个进程都会被分配一个时间段，称为<code>时间片(quantum)</code>，在这个时间片内允许进程运行。如果时间片结束时进程还在运行的话，则抢占一个 CPU 并将其分配给另一个进程。如果进程在时间片结束前阻塞或结束，则 CPU 立即进行切换。轮询算法比较容易实现。调度程序所做的就是维护一个可运行进程的列表，就像下图中的 a，当一个进程用完时间片后就被移到队列的末尾，就像下图的 b。</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829772-8a1f4a69-9934-4cf9-b1bd-80a69f410e13.png#height=485&id=Zwr0C&originHeight=485&originWidth=724&originalType=binary%E2%88%B6=1&size=0&status=done&style=none&width=724"></p><h4 id="优先级调度"><a href="#优先级调度" class="headerlink" title="优先级调度"></a>优先级调度</h4><p>轮询调度假设了所有的进程是同等重要的。但事实情况可能不是这样。例如，在一所大学中的等级制度，首先是院长，然后是教授、秘书、后勤人员，最后是学生。这种将外部情况考虑在内就实现了<code>优先级调度(priority scheduling)</code></p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829781-669962be-9966-4de1-be47-f3e9822459eb.png#height=162&id=Lt9Nc&originHeight=162&originWidth=678&originalType=binary%E2%88%B6=1&size=0&status=done&style=none&width=678"></p><p>它的基本思想很明确，每个进程都被赋予一个优先级，优先级高的进程优先运行。</p><h4 id="多级队列"><a href="#多级队列" class="headerlink" title="多级队列"></a>多级队列</h4><p>最早使用优先级调度的系统是 <code>CTSS(Compatible TimeSharing System)</code>。CTSS 在每次切换前都需要将当前进程换出到磁盘，并从磁盘上读入一个新进程。为 CPU 密集型进程设置较长的时间片比频繁地分给他们很短的时间要更有效（减少交换次数）。另一方面，如前所述，长时间片的进程又会影响到响应时间，解决办法是设置优先级类。属于最高优先级的进程运行一个时间片，次高优先级进程运行 2 个时间片，再下面一级运行 4 个时间片，以此类推。当一个进程用完分配的时间片后，它被移到下一类。</p><h4 id="最短进程优先"><a href="#最短进程优先" class="headerlink" title="最短进程优先"></a>最短进程优先</h4><p>最短进程优先是根据进程过去的行为进行推测，并执行估计运行时间最短的那一个。假设每个终端上每条命令的预估运行时间为 <code>T0</code>，现在假设测量到其下一次运行时间为 <code>T1</code>，可以用两个值的加权来改进估计时间，即<code>aT0+ (1- 1)T1</code>。通过选择 a 的值，可以决定是尽快忘掉老的运行时间，还是在一段长时间内始终记住它们。当 a = 1/2 时，可以得到下面这个序列</p><p>![image-20200220120452410](/Users/mr.l/Library/Application Support/typora-user-images/image-20200220120452410.png)</p><p>可以看到，在三轮过后，T0 在新的估计值中所占比重下降至 1/8。</p><h4 id="保证调度"><a href="#保证调度" class="headerlink" title="保证调度"></a>保证调度</h4><p>一种完全不同的调度方法是对用户做出明确的性能保证。一种实际而且容易实现的保证是：若用户工作时有 n 个用户登录，则每个用户将获得 CPU 处理能力的 1/n。类似地，在一个有 n 个进程运行的单用户系统中，若所有的进程都等价，则每个进程将获得 1/n 的 CPU 时间。</p><h4 id="彩票调度"><a href="#彩票调度" class="headerlink" title="彩票调度"></a>彩票调度</h4><p>对用户进行承诺并在随后兑现承诺是一件好事，不过很难实现。但是存在着一种简单的方式，有一种既可以给出预测结果而又有一种比较简单的实现方式的算法，就是 <code>彩票调度(lottery scheduling)</code>算法。</p><p>其基本思想是为进程提供各种系统资源（例如 CPU 时间）的彩票。当做出一个调度决策的时候，就随机抽出一张彩票，拥有彩票的进程将获得该资源。在应用到 CPU 调度时，系统可以每秒持有 50 次抽奖，每个中奖者将获得比如 20 毫秒的 CPU 时间作为奖励。</p><h4 id="公平分享调度"><a href="#公平分享调度" class="headerlink" title="公平分享调度"></a>公平分享调度</h4><p>到目前为止，我们假设被调度的都是各个进程自身，而不用考虑该进程的拥有者是谁。结果是，如果用户 1 启动了 9 个进程，而用户 2 启动了一个进程，使用轮转或相同优先级调度算法，那么用户 1 将得到 90 % 的 CPU 时间，而用户 2 将之得到 10 % 的 CPU 时间。</p><p>为了阻止这种情况的出现，一些系统在调度前会把进程的拥有者考虑在内。在这种模型下，每个用户都会分配一些 CPU 时间，而调度程序会选择进程并强制执行。因此如果两个用户每个都会有 50% 的 CPU 时间片保证，那么无论一个用户有多少个进程，都将获得相同的 CPU 份额。</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829805-f1649640-92c0-4cc0-9d11-d33091868df3.png#height=106&id=s6DG8&originHeight=106&originWidth=681&originalType=binary%E2%88%B6=1&size=0&status=done&style=none&width=681"></p><h3 id="实时系统中的调度"><a href="#实时系统中的调度" class="headerlink" title="实时系统中的调度"></a>实时系统中的调度</h3><p><code>实时系统(real-time)</code> 是一个时间扮演了重要作用的系统。实时系统可以分为两类，<code>硬实时(hard real time)</code> 和 <code>软实时(soft real time)</code> 系统，前者意味着必须要满足绝对的截止时间；后者的含义是虽然不希望偶尔错失截止时间，但是可以容忍。</p><p>实时系统中的事件可以按照响应方式进一步分类为<code>周期性(以规则的时间间隔发生)</code>事件或 <code>非周期性(发生时间不可预知)</code>事件。一个系统可能要响应多个周期性事件流，根据每个事件处理所需的时间，可能甚至无法处理所有事件。例如，如果有 m 个周期事件，事件 i 以周期 Pi 发生，并需要 Ci 秒 CPU 时间处理一个事件，那么可以处理负载的条件是</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829813-d541b483-e6c2-4e61-b29d-faf9719ce83f.png#height=81&id=ufEZW&originHeight=81&originWidth=180&originalType=binary%E2%88%B6=1&size=0&status=done&style=none&width=180"></p><p>只有满足这个条件的实时系统称为<code>可调度的</code>，这意味着它实际上能够被实现。一个不满足此检验标准的进程不能被调度，因为这些进程共同需要的 CPU 时间总和大于 CPU 能提供的时间。</p><p>下面我们来了解一下内存管理，你需要知道的知识点如下</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829871-ad9be6cd-aa53-4acc-b245-5dd76199a6ba.png#height=380&id=qZ8YJ&originHeight=380&originWidth=742&originalType=binary%E2%88%B6=1&size=0&status=done&style=none&width=742"></p><h2 id="地址空间"><a href="#地址空间" class="headerlink" title="地址空间"></a>地址空间</h2><p>如果要使多个应用程序同时运行在内存中，必须要解决两个问题：<code>保护</code>和 <code>重定位</code>。第一种解决方式是用<code>保护密钥标记内存块</code>，并将执行过程的密钥与提取的每个存储字的密钥进行比较。这种方式只能解决第一种问题（破坏操作系统），但是不能解决多进程在内存中同时运行的问题。</p><p>还有一种更好的方式是创造一个存储器抽象：<code>地址空间(the address space)</code>。就像进程的概念创建了一种抽象的 CPU 来运行程序，地址空间也创建了一种抽象内存供程序使用。</p><h4 id="基址寄存器和变址寄存器"><a href="#基址寄存器和变址寄存器" class="headerlink" title="基址寄存器和变址寄存器"></a>基址寄存器和变址寄存器</h4><p>最简单的办法是使用<code>动态重定位(dynamic relocation)</code>技术，它就是通过一种简单的方式将每个进程的地址空间映射到物理内存的不同区域。还有一种方式是使用基址寄存器和变址寄存器。</p><ul><li>基址寄存器：存储数据内存的起始位置</li><li>变址寄存器：存储应用程序的长度。</li></ul><p>每当进程引用内存以获取指令或读取、写入数据时，CPU 都会自动将<code>基址值</code>添加到进程生成的地址中，然后再将其发送到内存总线上。同时，它检查程序提供的地址是否大于或等于<code>变址寄存器</code> 中的值。如果程序提供的地址要超过变址寄存器的范围，那么会产生错误并中止访问。</p><h3 id="交换技术"><a href="#交换技术" class="headerlink" title="交换技术"></a>交换技术</h3><p>在程序运行过程中，经常会出现内存不足的问题。</p><p>针对上面内存不足的问题，提出了两种处理方式：最简单的一种方式就是<code>交换(swapping)</code>技术，即把一个进程完整的调入内存，然后再内存中运行一段时间，再把它放回磁盘。空闲进程会存储在磁盘中，所以这些进程在没有运行时不会占用太多内存。另外一种策略叫做<code>虚拟内存(virtual memory)</code>，虚拟内存技术能够允许应用程序部分的运行在内存中。下面我们首先先探讨一下交换</p><h4 id="交换过程"><a href="#交换过程" class="headerlink" title="交换过程"></a>交换过程</h4><p>下面是一个交换过程</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829844-31f0d41e-db06-4f4a-86d4-15250999e2dd.png#height=349&id=PM0yA&originHeight=349&originWidth=724&originalType=binary%E2%88%B6=1&size=0&status=done&style=none&width=724"></p><p>刚开始的时候，只有进程 A 在内存中，然后从创建进程 B 和进程 C 或者从磁盘中把它们换入内存，然后在图 d 中，A 被换出内存到磁盘中，最后 A 重新进来。因为图 g 中的进程 A 现在到了不同的位置，所以在装载过程中需要被重新定位，或者在交换程序时通过软件来执行；或者在程序执行期间通过硬件来重定位。基址寄存器和变址寄存器就适用于这种情况。</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829879-4fde9a55-0c36-4d7d-948a-49841539d0c8.png#height=469&id=SC4tr&originHeight=469&originWidth=696&originalType=binary%E2%88%B6=1&size=0&status=done&style=none&width=696"></p><p>交换在内存创建了多个 <code>空闲区(hole)</code>，内存会把所有的空闲区尽可能向下移动合并成为一个大的空闲区。这项技术称为<code>内存紧缩(memory compaction)</code>。但是这项技术通常不会使用，因为这项技术会消耗很多 CPU 时间。</p><h3 id="空闲内存管理"><a href="#空闲内存管理" class="headerlink" title="空闲内存管理"></a>空闲内存管理</h3><p>在进行内存动态分配时，操作系统必须对其进行管理。大致上说，有两种监控内存使用的方式</p><ul><li><code>位图(bitmap)</code></li><li><code>空闲列表(free lists)</code></li></ul><h4 id="使用位图的存储管理"><a href="#使用位图的存储管理" class="headerlink" title="使用位图的存储管理"></a>使用位图的存储管理</h4><p>使用位图方法时，内存可能被划分为小到几个字或大到几千字节的分配单元。每个分配单元对应于位图中的一位，0 表示空闲， 1 表示占用（或者相反）。一块内存区域和其对应的位图如下</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829887-83af6188-e02c-4437-8739-40021e8a2957.png#height=303&id=uirOM&originHeight=303&originWidth=734&originalType=binary%E2%88%B6=1&size=0&status=done&style=none&width=734"></p><p><code>位图</code>提供了一种简单的方法在固定大小的内存中跟踪内存的使用情况，因为<strong>位图的大小取决于内存和分配单元的大小</strong>。这种方法有一个问题是，当决定为把具有 k 个分配单元的进程放入内存时，<code>内容管理器(memory manager)</code> 必须搜索位图，在位图中找出能够运行 k 个连续 0 位的串。在位图中找出制定长度的连续 0 串是一个很耗时的操作，这是位图的缺点。（可以简单理解为在杂乱无章的数组中，找出具有一大长串空闲的数组单元）</p><h4 id="使用链表进行管理"><a href="#使用链表进行管理" class="headerlink" title="使用链表进行管理"></a>使用链表进行管理</h4><p>另一种记录内存使用情况的方法是，维护一个记录已分配内存段和空闲内存段的链表，段会包含进程或者是两个进程的空闲区域。可用上面的图 c <strong>来表示内存的使用情况</strong>。链表中的每一项都可以代表一个 <code>空闲区(H)</code> 或者是<code>进程(P)</code>的起始标志，长度和下一个链表项的位置。</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829908-832c7960-d7cc-45fc-a029-b803b86a6bf9.png#height=432&id=ZQMqP&originHeight=432&originWidth=695&originalType=binary%E2%88%B6=1&size=0&status=done&style=none&width=695"></p><p>当按照地址顺序在链表中存放进程和空闲区时，有几种算法可以为创建的进程（或者从磁盘中换入的进程）分配内存。我们先假设内存管理器知道应该分配多少内存，最简单的算法是使用 <code>首次适配(first fit)</code>。内存管理器会沿着段列表进行扫描，直到找个一个足够大的空闲区为止。 除非空闲区大小和要分配的空间大小一样，否则将空闲区分为两部分，一部分供进程使用；一部分生成新的空闲区。首次适配算法是一种速度很快的算法，因为它会尽可能的搜索链表。</p><p>首次适配的一个小的变体是 <code>下次适配(next fit)</code>。它和首次匹配的工作方式相同，只有一个不同之处那就是下次适配在每次找到合适的空闲区时就会记录当时的位置，以便下次寻找空闲区时从上次结束的地方开始搜索，而不是像首次匹配算法那样每次都会从头开始搜索。</p><p>另外一个著名的并且广泛使用的算法是 <code>最佳适配(best fit)</code>。最佳适配会从头到尾寻找整个链表，找出能够容纳进程的最小空闲区。</p><h2 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h2><p>尽管基址寄存器和变址寄存器用来创建地址空间的抽象，但是这有一个其他的问题需要解决：<code>管理软件的不断增大(managing bloatware)</code>。虚拟内存的基本思想是，每个程序都有自己的地址空间，这个地址空间被划分为多个称为<code>页面(page)</code>的块。每一页都是连续的地址范围。这些页被映射到物理内存，但并不是所有的页都必须在内存中才能运行程序。当程序引用到一部分在物理内存中的地址空间时，硬件会立刻执行必要的映射。当程序引用到一部分不在物理内存中的地址空间时，由操作系统负责将缺失的部分装入物理内存并重新执行失败的指令。</p><h3 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h3><p>大部分使用虚拟内存的系统中都会使用一种 <code>分页(paging)</code> 技术。在任何一台计算机上，程序会引用使用一组内存地址。当程序执行</p><pre><code class="assembly">MOV REG,1000</code></pre><p>这条指令时，它会把内存地址为 1000 的内存单元的内容复制到 REG 中（或者相反，这取决于计算机）。地址可以通过索引、基址寄存器、段寄存器或其他方式产生。</p><p>这些程序生成的地址被称为 <code>虚拟地址(virtual addresses)</code> 并形成<code>虚拟地址空间(virtual address space)</code>，在没有虚拟内存的计算机上，系统直接将虚拟地址送到内存中线上，读写操作都使用同样地址的物理内存。<strong>在使用虚拟内存时，虚拟地址不会直接发送到内存总线上</strong>。相反，会使用 <code>MMU(Memory Management Unit)</code> 内存管理单元把<strong>虚拟地址映射为物理内存地址</strong>，像下图这样</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829902-6db577d7-0921-4635-82f1-62f7fe723b48.png#height=326&id=DPfTF&originHeight=326&originWidth=710&originalType=binary%E2%88%B6=1&size=0&status=done&style=none&width=710"></p><p>下面这幅图展示了这种映射是如何工作的</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829922-b5a208d9-6807-4201-b95a-50c300ec3f1e.png#height=728&id=jEXGv&originHeight=728&originWidth=701&originalType=binary%E2%88%B6=1&size=0&status=done&style=none&width=701"></p><p>页表给出虚拟地址与物理内存地址之间的映射关系。每一页起始于 4096 的倍数位置，结束于 4095 的位置，所以 4K 到 8K 实际为 4096 - 8191 ，8K - 12K 就是 8192 - 12287</p><p>在这个例子中，我们可能有一个 16 位地址的计算机，地址从 0 - 64 K - 1，这些是<code>虚拟地址</code>。然而只有 32 KB 的物理地址。所以虽然可以编写 64 KB 的程序，但是程序无法全部调入内存运行，在磁盘上必须有一个最多 64 KB 的程序核心映像的完整副本，以保证程序片段在需要时被调入内存。</p><h3 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h3><p>虚拟页号可作为页表的索引用来找到虚拟页中的内容。由页表项可以找到页框号（如果有的话）。然后把页框号拼接到偏移量的高位端，以替换掉虚拟页号，形成物理地址。</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829940-3af1fa95-4f53-459f-88e6-dc9540fc58fa.png#height=555&id=gDLPK&originHeight=555&originWidth=726&originalType=binary%E2%88%B6=1&size=0&status=done&style=none&width=726"></p><p>因此，页表的目的是把虚拟页映射到页框中。从数学上说，页表是一个函数，它的参数是虚拟页号，结果是物理页框号。</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829970-f9085cee-e3ce-49a6-a175-31095f33b104.png#height=226&id=r6cAl&originHeight=226&originWidth=549&originalType=binary%E2%88%B6=1&size=0&status=done&style=none&width=549"></p><p>通过这个函数可以把虚拟地址中的虚拟页转换为页框，从而形成物理地址。</p><h4 id="页表项的结构"><a href="#页表项的结构" class="headerlink" title="页表项的结构"></a>页表项的结构</h4><p>下面我们探讨一下页表项的具体结构，上面你知道了页表项的大致构成，是由页框号和在/不在位构成的，现在我们来具体探讨一下页表项的构成</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726829994-5ecf9cda-4a6f-418e-b786-bf4a2a05e7c3.png#height=297&id=PVew4&originHeight=297&originWidth=701&originalType=binary%E2%88%B6=1&size=0&status=done&style=none&width=701"></p><p>页表项的结构是与机器相关的，但是不同机器上的页表项大致相同。上面是一个页表项的构成，不同计算机的页表项可能不同，但是一般来说都是 32 位的。页表项中最重要的字段就是<code>页框号(Page frame number)</code>。毕竟，页表到页框最重要的一步操作就是要把此值映射过去。下一个比较重要的就是<code>在/不在</code>位，如果此位上的值是 1，那么页表项是有效的并且能够被<code>使用</code>。如果此值是 0 的话，则表示该页表项对应的虚拟页面<code>不在</code>内存中，访问该页面会引起一个<code>缺页异常(page fault)</code>。</p><p><code>保护位(Protection)</code> 告诉我们哪一种访问是允许的，啥意思呢？最简单的表示形式是这个域只有一位，<strong>0 表示可读可写，1 表示的是只读</strong>。</p><p><code>修改位(Modified)</code> 和 <code>访问位(Referenced)</code> 会跟踪页面的使用情况。当一个页面被写入时，硬件会自动的设置修改位。修改位在页面重新分配页框时很有用。如果一个页面已经被修改过（即它是 <code>脏</code> 的），则必须把它写回磁盘。如果一个页面没有被修改过（即它是 <code>干净</code>的），那么重新分配时这个页框会被直接丢弃，因为磁盘上的副本仍然是有效的。这个位有时也叫做 <code>脏位(dirty bit)</code>，因为它反映了页面的状态。</p><p><code>访问位(Referenced)</code> 在页面被访问时被设置，不管是读还是写。这个值能够帮助操作系统在发生缺页中断时选择要淘汰的页。不再使用的页要比正在使用的页更适合被淘汰。这个位在后面要讨论的<code>页面置换</code>算法中作用很大。</p><p>最后一位用于禁止该页面被高速缓存，这个功能对于映射到设备寄存器还是内存中起到了关键作用。通过这一位可以禁用高速缓存。具有独立的 I/O 空间而不是用内存映射 I/O 的机器来说，并不需要这一位。</p><h2 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h2><p>下面我们就来探讨一下有哪些页面置换算法。</p><h3 id="最优页面置换算法"><a href="#最优页面置换算法" class="headerlink" title="最优页面置换算法"></a>最优页面置换算法</h3><p>最优的页面置换算法的工作流程如下：在缺页中断发生时，这些页面之一将在下一条指令（包含该指令的页面）上被引用。其他页面则可能要到 10、100 或者 1000 条指令后才会被访问。每个页面都可以用在该页首次被访问前所要执行的指令数作为标记。</p><p>最优化的页面算法表明应该标记最大的页面。如果一个页面在 800 万条指令内不会被使用，另外一个页面在 600 万条指令内不会被使用，则置换前一个页面，从而把需要调入这个页面而发生的缺页中断推迟。计算机也像人类一样，会把不愿意做的事情尽可能的往后拖。</p><p>这个算法最大的问题时无法实现。当缺页中断发生时，操作系统无法知道各个页面的下一次将在什么时候被访问。这种算法在实际过程中根本不会使用。</p><h3 id="最近未使用页面置换算法"><a href="#最近未使用页面置换算法" class="headerlink" title="最近未使用页面置换算法"></a>最近未使用页面置换算法</h3><p>为了能够让操作系统收集页面使用信息，大部分使用虚拟地址的计算机都有两个状态位，R 和 M，来和每个页面进行关联。<strong>每当引用页面（读入或写入）时都设置 R，写入（即修改）页面时设置 M</strong>，这些位包含在每个页表项中，就像下面所示</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830000-886bdae7-531d-42ce-86c1-970d3c0fd287.png#height=288&id=GjVza&originHeight=288&originWidth=644&originalType=binary%E2%88%B6=1&size=0&status=done&style=none&width=644"></p><p>因为每次访问时都会更新这些位，因此由<code>硬件</code>来设置它们非常重要。一旦某个位被设置为 1，就会一直保持 1 直到操作系统下次来修改此位。</p><p>如果硬件没有这些位，那么可以使用操作系统的<code>缺页中断</code>和<code>时钟中断</code>机制来进行模拟。当启动一个进程时，将其所有的页面都标记为<code>不在内存</code>；一旦访问任何一个页面就会引发一次缺页中断，此时操作系统就可以设置 <code>R 位(在它的内部表中)</code>，修改页表项使其指向正确的页面，并设置为 <code>READ ONLY</code> 模式，然后重新启动引起缺页中断的指令。如果页面随后被修改，就会发生另一个缺页异常。从而允许操作系统设置 M 位并把页面的模式设置为 <code>READ/WRITE</code>。</p><p>可以用 R 位和 M 位来构造一个简单的页面置换算法：当启动一个进程时，操作系统将其所有页面的两个位都设置为 0。R 位定期的被清零（在每个时钟中断）。用来将最近未引用的页面和已引用的页面分开。</p><p>当出现缺页中断后，操作系统会检查所有的页面，并根据它们的 R 位和 M 位将当前值分为四类：</p><ul><li>第 0 类：没有引用 R，没有修改 M</li><li>第 1 类：没有引用 R，已修改 M</li><li>第 2 类：引用 R ，没有修改 M</li><li>第 3 类：已被访问 R，已被修改 M</li></ul><p>尽管看起来好像无法实现第一类页面，但是当第三类页面的 R 位被时钟中断清除时，它们就会发生。时钟中断不会清除 M 位，因为需要这个信息才能知道是否写回磁盘中。清除 R 但不清除 M 会导致出现一类页面。</p><p><code>NRU(Not Recently Used)</code> 算法从编号最小的非空类中随机删除一个页面。此算法隐含的思想是，在一个时钟内（约 20 ms）淘汰一个已修改但是没有被访问的页面要比一个大量引用的未修改页面好，NRU 的主要优点是<strong>易于理解并且能够有效的实现</strong>。</p><h3 id="先进先出页面置换算法"><a href="#先进先出页面置换算法" class="headerlink" title="先进先出页面置换算法"></a>先进先出页面置换算法</h3><p>另一种开销较小的方式是使用 <code>FIFO(First-In,First-Out)</code> 算法，这种类型的数据结构也适用在页面置换算法中。由操作系统维护一个所有在当前内存中的页面的链表，最早进入的放在表头，最新进入的页面放在表尾。在发生缺页异常时，会把头部的页移除并且把新的页添加到表尾。</p><h3 id="第二次机会页面置换算法"><a href="#第二次机会页面置换算法" class="headerlink" title="第二次机会页面置换算法"></a>第二次机会页面置换算法</h3><p>我们上面学到的 FIFO 链表页面有个<code>缺陷</code>，那就是出链和入链并不会进行 check <code>检查</code>，这样就会容易把经常使用的页面置换出去，为了避免这一问题，我们对该算法做一个简单的修改：我们检查最老页面的 <code>R 位</code>，如果是 0 ，那么这个页面就是最老的而且没有被使用，那么这个页面就会被立刻换出。如果 R 位是 1，那么就清除此位，此页面会被放在链表的尾部，修改它的装入时间就像刚放进来的一样。然后继续搜索。</p><p>这种算法叫做 <code>第二次机会(second chance)</code>算法，就像下面这样，我们看到页面 A 到 H 保留在链表中，并按到达内存的时间排序。</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830001-d17523cc-7d04-4aa5-9b91-7cb47cc26508.png#height=372&id=fCBHb&originHeight=372&originWidth=731&originalType=binary%E2%88%B6=1&size=0&status=done&style=none&width=731"></p><p>a）按照先进先出的方法排列的页面；b）在时刻 20 处发生缺页异常中断并且 A 的 R 位已经设置时的页面链表。</p><p>假设缺页异常发生在时刻 20 处，这时最老的页面是 A ，它是在 0 时刻到达的。如果 A 的 R 位是 0，那么它将被淘汰出内存，或者把它写回磁盘（如果它已经被修改过），或者只是简单的放弃（如果它是未被修改过）。另一方面，如果它的 R 位已经设置了，则将 A 放到链表的尾部并且重新设置<code>装入时间</code>为当前时刻（20 处），然后清除 R 位。然后从 B 页面开始继续搜索合适的页面。</p><p>寻找第二次机会的是在最近的时钟间隔中未被访问过的页面。如果所有的页面都被访问过，该算法就会被简化为单纯的 <code>FIFO 算法</code>。具体来说，假设图 a 中所有页面都设置了 R 位。操作系统将页面依次移到链表末尾，每次都在添加到末尾时清除 R 位。最后，算法又会回到页面 A，此时的 R 位已经被清除，那么页面 A 就会被执行出链处理，因此算法能够正常结束。</p><h3 id="时钟页面置换算法"><a href="#时钟页面置换算法" class="headerlink" title="时钟页面置换算法"></a>时钟页面置换算法</h3><p>一种比较好的方式是把所有的页面都保存在一个类似钟面的环形链表中，一个表针指向最老的页面。如下图所示</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830029-543aeeff-242c-4b6f-a9a4-87fa9b101280.png#height=532&id=Xw06o&originHeight=532&originWidth=669&originalType=binary%E2%88%B6=1&size=0&status=done&style=none&width=669"></p><p>当缺页错误出现时，算法首先检查表针指向的页面，如果它的 R 位是 0 就淘汰该页面，并把新的页面插入到这个位置，然后把表针向前移动一位；如果 R 位是 1 就清除 R 位并把表针前移一个位置。重复这个过程直到找到了一个 R 位为 0 的页面位置。了解这个算法的工作方式，就明白为什么它被称为 <code>时钟(clokc)</code>算法了。</p><h3 id="最近最少使用页面置换算法"><a href="#最近最少使用页面置换算法" class="headerlink" title="最近最少使用页面置换算法"></a>最近最少使用页面置换算法</h3><p>在前面几条指令中频繁使用的页面和可能在后面的几条指令中被使用。反过来说，已经很久没有使用的页面有可能在未来一段时间内仍不会被使用。这个思想揭示了一个可以实现的算法：在缺页中断时，置换未使用时间最长的页面。这个策略称为 <code>LRU(Least Recently Used)</code> ，最近最少使用页面置换算法。</p><p>虽然 LRU 在理论上是可以实现的，但是从长远看来代价比较高。为了完全实现 LRU，会在内存中维护一个所有页面的链表，最频繁使用的页位于表头，最近最少使用的页位于表尾。困难的是在每次内存引用时更新整个链表。在链表中找到一个页面，删除它，然后把它移动到表头是一个非常耗时的操作，即使使用<code>硬件</code>来实现也是一样的费时。</p><h3 id="用软件模拟-LRU"><a href="#用软件模拟-LRU" class="headerlink" title="用软件模拟 LRU"></a>用软件模拟 LRU</h3><p>尽管上面的 LRU 算法在原则上是可以实现的，<strong>但是很少有机器能够拥有那些特殊的硬件</strong>。上面是硬件的实现方式，那么现在考虑要用<code>软件</code>来实现 LRU 。一种可以实现的方案是 <code>NFU(Not Frequently Used，最不常用)</code>算法。它需要一个软件计数器来和每个页面关联，初始化的时候是 0 。在每个时钟中断时，操作系统会浏览内存中的所有页，会将每个页面的 R 位（0 或 1）加到它的计数器上。这个计数器大体上跟踪了各个页面访问的频繁程度。当缺页异常出现时，则置换计数器值最小的页面。</p><p>只需要对 NFU 做一个简单的修改就可以让它模拟 LRU，这个修改有两个步骤</p><ul><li>首先，在 R 位被添加进来之前先把计数器右移一位；</li><li>第二步，R 位被添加到最左边的位而不是最右边的位。</li></ul><p>修改以后的算法称为 <code>老化(aging)</code> 算法，下图解释了老化算法是如何工作的。</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830078-9cab6ac9-f2fa-4395-b8d5-57b61a80e6d3.png#height=415&id=kzyJK&originHeight=415&originWidth=747&originalType=binary%E2%88%B6=1&size=0&status=done&style=none&width=747"></p><p>我们假设在第一个时钟周期内页面 0 - 5 的 R 位依次是 1，0，1，0，1，1，（也就是页面 0 是 1，页面 1 是 0，页面 2 是 1 这样类推）。也就是说，<strong>在 0 个时钟周期到 1 个时钟周期之间，0，2，4，5 都被引用了</strong>，从而把它们的 R 位设置为 1，剩下的设置为 0 。在相关的六个计数器被右移之后 R 位被添加到 <code>左侧</code> ，就像上图中的 a。剩下的四列显示了接下来的四个时钟周期内的六个计数器变化。</p><blockquote><p>CPU 正在以某个频率前进，该频率的周期称为<code>时钟滴答</code>或<code>时钟周期</code>。一个 100Mhz 的处理器每秒将接收 100,000,000 个时钟滴答。</p></blockquote><p>当缺页异常出现时，将<code>置换（就是移除）</code>计数器值最小的页面。如果一个页面在前面 4 个时钟周期内都没有被访问过，那么它的计数器应该会有四个连续的 0 ，因此它的值肯定要比前面 3 个时钟周期内都没有被访问过的页面的计数器小。</p><p>这个算法与 LRU 算法有两个重要的区别：看一下上图中的 <code>e</code>，第三列和第五列</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830053-3463258f-69af-41f6-94ed-94a15761844e.png#height=429&id=BE7AZ&originHeight=429&originWidth=763&originalType=binary%E2%88%B6=1&size=0&status=done&style=none&width=763"></p><h3 id="工作集时钟页面置换算法"><a href="#工作集时钟页面置换算法" class="headerlink" title="工作集时钟页面置换算法"></a>工作集时钟页面置换算法</h3><p>当缺页异常发生后，需要扫描整个页表才能确定被淘汰的页面，因此基本工作集算法还是比较浪费时间的。一个对基本工作集算法的提升是基于时钟算法但是却使用工作集的信息，这种算法称为<code>WSClock(工作集时钟)</code>。由于它的实现简单并且具有高性能，因此在实践中被广泛应用。</p><p>与时钟算法一样，所需的数据结构是一个以页框为元素的循环列表，就像下面这样</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830081-e96444ca-dda9-4c3f-9af5-e0db74d03a6f.png#height=588&id=tl5hI&originHeight=588&originWidth=705&originalType=binary%E2%88%B6=1&size=0&status=done&style=none&width=705"></p><p>工作集时钟页面置换算法的操作：a) 和 b) 给出 R = 1 时所发生的情形；c) 和 d) 给出 R = 0 的例子</p><p>最初的时候，该表是空的。当装入第一个页面后，把它加载到该表中。随着更多的页面的加入，它们形成一个环形结构。每个表项包含来自基本工作集算法的上次使用时间，以及 R 位（已标明）和 M 位（未标明）。</p><p>与时钟算法一样，在每个缺页异常时，首先检查指针指向的页面。如果 R 位被是设置为 1，该页面在当前时钟周期内就被使用过，那么该页面就不适合被淘汰。然后把该页面的 R 位置为 0，指针指向下一个页面，并重复该算法。该事件序列化后的状态参见图 b。</p><p>现在考虑指针指向的页面 R = 0 时会发生什么，参见图 c，如果页面的使用期限大于 t 并且页面为被访问过，那么这个页面就不会在工作集中，并且在磁盘上会有一个此页面的副本。申请重新调入一个新的页面，并把新的页面放在其中，如图 d 所示。另一方面，如果页面被修改过，就不能重新申请页面，因为这个页面在磁盘上没有有效的副本。为了避免由于调度写磁盘操作引起的进程切换，指针继续向前走，算法继续对下一个页面进行操作。毕竟，有可能存在一个老的，没有被修改过的页面可以立即使用。</p><p>原则上来说，所有的页面都有可能因为<code>磁盘I/O</code> 在某个时钟周期内被调度。为了降低磁盘阻塞，需要设置一个限制，即最大只允许写回 n 个页面。一旦达到该限制，就不允许调度新的写操作。</p><p>那么就有个问题，指针会绕一圈回到原点的，如果回到原点，它的起始点会发生什么？这里有两种情况：</p><ul><li>至少调度了一次写操作</li><li>没有调度过写操作</li></ul><p>在第一种情况中，指针仅仅是不停的移动，寻找一个未被修改过的页面。由于已经调度了一个或者多个写操作，最终会有某个写操作完成，它的页面会被标记为未修改。置换遇到的第一个未被修改过的页面，这个页面不一定是第一个被调度写操作的页面，因为硬盘驱动程序为了优化性能可能会把写操作重排序。</p><p>对于第二种情况，所有的页面都在工作集中，否则将至少调度了一个写操作。由于缺乏额外的信息，最简单的方法就是置换一个未被修改的页面来使用，扫描中需要记录未被修改的页面的位置，如果不存在未被修改的页面，就选定当前页面并把它写回磁盘。</p><h3 id="页面置换算法小结"><a href="#页面置换算法小结" class="headerlink" title="页面置换算法小结"></a>页面置换算法小结</h3><p>我们到现在已经研究了各种页面置换算法，现在我们来一个简单的总结，算法的总结归纳如下</p><table><thead><tr><th>算法</th><th>注释</th></tr></thead><tbody><tr><td>最优算法</td><td>不可实现，但可以用作基准</td></tr><tr><td>NRU(最近未使用) 算法</td><td>和 LRU 算法很相似</td></tr><tr><td>FIFO(先进先出) 算法</td><td>有可能会抛弃重要的页面</td></tr><tr><td>第二次机会算法</td><td>比 FIFO 有较大的改善</td></tr><tr><td>时钟算法</td><td>实际使用</td></tr><tr><td>LRU(最近最少)算法</td><td>比较优秀，但是很难实现</td></tr><tr><td>NFU(最不经常食用)算法</td><td>和 LRU 很类似</td></tr><tr><td>老化算法</td><td>近似 LRU 的高效算法</td></tr><tr><td>工作集算法</td><td>实施起来开销很大</td></tr><tr><td>工作集时钟算法</td><td>比较有效的算法</td></tr></tbody></table><ul><li><code>最优算法</code>在当前页面中置换最后要访问的页面。不幸的是，没有办法来判定哪个页面是最后一个要访问的，<code>因此实际上该算法不能使用</code>。然而，它可以作为衡量其他算法的标准。</li><li><code>NRU</code> 算法根据 R 位和 M 位的状态将页面氛围四类。从编号最小的类别中随机选择一个页面。NRU 算法易于实现，但是性能不是很好。存在更好的算法。</li><li><code>FIFO</code> 会跟踪页面加载进入内存中的顺序，并把页面放入一个链表中。有可能删除存在时间最长但是还在使用的页面，因此这个算法也不是一个很好的选择。</li><li><code>第二次机会</code>算法是对 FIFO 的一个修改，它会在删除页面之前检查这个页面是否仍在使用。如果页面正在使用，就会进行保留。这个改进大大提高了性能。</li><li><code>时钟</code> 算法是第二次机会算法的另外一种实现形式，时钟算法和第二次算法的性能差不多，但是会花费更少的时间来执行算法。</li><li><code>LRU</code> 算法是一个非常优秀的算法，但是没有<code>特殊的硬件(TLB)</code>很难实现。如果没有硬件，就不能使用 LRU 算法。</li><li><code>NFU</code> 算法是一种近似于 LRU 的算法，它的性能不是非常好。</li><li><code>老化</code> 算法是一种更接近 LRU 算法的实现，并且可以更好的实现，因此是一个很好的选择</li><li>最后两种算法都使用了工作集算法。工作集算法提供了合理的性能开销，但是它的实现比较复杂。<code>WSClock</code> 是另外一种变体，它不仅能够提供良好的性能，而且可以高效地实现。</li></ul><p>总之，<strong>最好的算法是老化算法和 WSClock 算法</strong>。他们分别是基于 LRU 和工作集算法。他们都具有良好的性能并且能够被有效的实现。还存在其他一些好的算法，但实际上这两个可能是最重要的。</p><p>下面来聊一聊文件系统，你需要知道下面这些知识点</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830114-09f30aaf-25b8-44c3-992a-577e4c3a833c.png#height=657&id=MOs6Q&originHeight=657&originWidth=721&originalType=binary%E2%88%B6=1&size=0&status=done&style=none&width=721"></p><h2 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h2><h3 id="文件命名"><a href="#文件命名" class="headerlink" title="文件命名"></a>文件命名</h3><p>文件是一种抽象机制，它提供了一种方式用来存储信息以及在后面进行读取。可能任何一种机制最重要的特性就是管理对象的命名方式。在创建一个文件后，它会给文件一个命名。当进程终止时，文件会继续存在，并且其他进程可以使用<code>名称访问该文件</code>。</p><p>文件命名规则对于不同的操作系统来说是不一样的，但是所有现代操作系统都允许使用 1 - 8 个字母的字符串作为合法文件名。</p><p>某些文件区分大小写字母，而大多数则不区分。<code>UNIX</code> 属于第一类；历史悠久的 <code>MS-DOS</code> 属于第二类（顺便说一句，尽管 MS-DOS 历史悠久，但 MS-DOS 仍在嵌入式系统中非常广泛地使用，因此它绝不是过时的）；因此，UNIX 系统会有三种不同的命名文件：<code>maria</code>、<code>Maria</code>、<code>MARIA</code> 。在 MS-DOS ，所有这些命名都属于相同的文件。</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830120-5ba4f13c-ee71-46f2-a110-e2eaf1dbf324.png#height=302&id=JHfwL&originHeight=302&originWidth=691&originalType=binary%E2%88%B6=1&size=0&status=done&style=none&width=691"></p><p>许多操作系统支持两部分的文件名，它们之间用 <code>.</code> 分隔开，比如文件名 <code>prog.c</code>。原点后面的文件称为 <code>文件扩展名(file extension)</code> ，文件扩展名通常表示文件的一些信息。一些常用的文件扩展名以及含义如下图所示</p><table><thead><tr><th>扩展名</th><th>含义</th></tr></thead><tbody><tr><td>bak</td><td>备份文件</td></tr><tr><td>c</td><td>c 源程序文件</td></tr><tr><td>gif</td><td>符合图形交换格式的图像文件</td></tr><tr><td>hlp</td><td>帮助文件</td></tr><tr><td>html</td><td>WWW 超文本标记语言文档</td></tr><tr><td>jpg</td><td>符合 JPEG 编码标准的静态图片</td></tr><tr><td>mp3</td><td>符合 MP3 音频编码格式的音乐文件</td></tr><tr><td>mpg</td><td>符合 MPEG 编码标准的电影</td></tr><tr><td>o</td><td>目标文件（编译器输出格式，尚未链接）</td></tr><tr><td>pdf</td><td>pdf 格式的文件</td></tr><tr><td>ps</td><td>PostScript 文件</td></tr><tr><td>tex</td><td>为 TEX 格式化程序准备的输入文件</td></tr><tr><td>txt</td><td>文本文件</td></tr><tr><td>zip</td><td>压缩文件</td></tr></tbody></table><p>在 UNIX 系统中，文件扩展名只是一种约定，操作系统并不强制采用。</p><h3 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h3><p>文件的构造有多种方式。下图列出了常用的三种构造方式</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830179-1cd3ea7b-cf21-432f-a8e4-c2d8f317e0ff.png#height=426&id=HSm1k&originHeight=426&originWidth=728&originalType=binary%E2%88%B6=1&size=0&status=done&style=none&width=728"></p><p>三种不同的文件。 a) 字节序列 。b) 记录序列。c) 树</p><p>上图中的 a 是一种无结构的字节序列，操作系统不关心序列的内容是什么，操作系统能看到的就是<code>字节(bytes)</code>。其文件内容的任何含义只在用户程序中进行解释。UNIX 和 Windows 都采用这种办法。</p><p>图 b 表示在文件结构上的第一部改进。在这个模型中，文件是具有固定长度记录的序列，每个记录都有其内部结构。 把文件作为记录序列的核心思想是：<strong>读操作返回一个记录，而写操作重写或者追加一个记录</strong>。第三种文件结构如上图 c 所示。在这种组织结构中，文件由一颗<code>记录树</code>构成，记录树的长度不一定相同，每个记录树都在记录中的固定位置包含一个<code>key</code> 字段。这棵树按 key 进行排序，从而可以对特定的 key 进行快速查找。</p><h3 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h3><p>很多操作系统支持多种文件类型。例如，UNIX（同样包括 OS X）和 Windows 都具有常规的文件和目录。除此之外，UNIX 还具有<code>字符特殊文件(character special file)</code> 和 <code>块特殊文件(block special file)</code>。<code>常规文件(Regular files)</code> 是包含有用户信息的文件。用户一般使用的文件大都是常规文件，常规文件一般包括 <strong>可执行文件、文本文件、图像文件</strong>，从常规文件读取数据或将数据写入时，内核会根据文件系统的规则执行操作，是写入可能被延迟，记录日志或者接受其他操作。</p><h3 id="文件访问"><a href="#文件访问" class="headerlink" title="文件访问"></a>文件访问</h3><p>早期的操作系统只有一种访问方式：<code>序列访问(sequential access)</code>。在这些系统中，进程可以按照顺序读取所有的字节或文件中的记录，但是不能跳过并乱序执行它们。顺序访问文件是可以返回到起点的，需要时可以多次读取该文件。当存储介质是磁带而不是磁盘时，顺序访问文件很方便。</p><p>在使用磁盘来存储文件时，可以不按照顺序读取文件中的字节或者记录，或者按照关键字而不是位置来访问记录。这种能够以任意次序进行读取的称为<code>随机访问文件(random access file)</code>。许多应用程序都需要这种方式。</p><p>随机访问文件对许多应用程序来说都必不可少，例如，数据库系统。如果乘客打电话预定某航班机票，订票程序必须能够直接访问航班记录，而不必先读取其他航班的成千上万条记录。</p><p>有两种方法可以指示从何处开始读取文件。第一种方法是直接使用 <code>read</code> 从头开始读取。另一种是用一个特殊的 <code>seek</code> 操作设置当前位置，在 seek 操作后，从这个当前位置顺序地开始读文件。UNIX 和 Windows 使用的是后面一种方式。</p><h3 id="文件属性"><a href="#文件属性" class="headerlink" title="文件属性"></a>文件属性</h3><p>文件包括文件名和数据。除此之外，所有的操作系统还会保存其他与文件相关的信息，如文件创建的日期和时间、文件大小。我们可以称这些为文件的<code>属性(attributes)</code>。有些人也喜欢把它们称作 <code>元数据(metadata)</code>。文件的属性在不同的系统中差别很大。文件的属性只有两种状态：<code>设置(set)</code> 和 <code>清除(clear)</code>。</p><h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h3><p>使用文件的目的是用来存储信息并方便以后的检索。对于存储和检索，不同的系统提供了不同的操作。以下是与文件有关的最常用的一些系统调用：</p><ol><li><code>Create</code>，创建不包含任何数据的文件。调用的目的是表示文件即将建立，并对文件设置一些属性。</li><li><code>Delete</code>，当文件不再需要，必须删除它以释放内存空间。为此总会有一个系统调用来删除文件。</li><li><code>Open</code>，在使用文件之前，必须先打开文件。这个调用的目的是允许系统将属性和磁盘地址列表保存到主存中，用来以后的快速访问。</li><li><code>Close</code>，当所有进程完成时，属性和磁盘地址不再需要，因此应关闭文件以释放表空间。很多系统限制进程打开文件的个数，以此达到鼓励用户关闭不再使用的文件。磁盘以块为单位写入，关闭文件时会强制写入最后一<code>块</code>，即使这个块空间内部还不满。</li><li><code>Read</code>，数据从文件中读取。通常情况下，读取的数据来自文件的当前位置。调用者必须指定需要读取多少数据，并且提供存放这些数据的缓冲区。</li><li><code>Write</code>，向文件写数据，写操作一般也是从文件的当前位置开始进行。如果当前位置是文件的末尾，则会直接追加进行写入。如果当前位置在文件中，则现有数据被覆盖，并且永远消失。</li><li><code>append</code>，使用 append 只能向文件末尾添加数据。</li><li><code>seek</code>，对于随机访问的文件，要指定从何处开始获取数据。通常的方法是用 seek 系统调用把当前位置指针指向文件中的特定位置。seek 调用结束后，就可以从指定位置开始读写数据了。</li><li><code>get attributes</code>，进程运行时通常需要读取文件属性。</li><li><code>set attributes</code>，用户可以自己设置一些文件属性，甚至是在文件创建之后，实现该功能的是 set attributes 系统调用。</li><li><code>rename</code>，用户可以自己更改已有文件的名字，rename 系统调用用于这一目的。</li></ol><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><p>文件系统通常提供<code>目录(directories)</code> 或者 <code>文件夹(folders)</code> 用于记录文件的位置，在很多系统中目录本身也是文件，下面我们会讨论关于文件，他们的组织形式、属性和可以对文件进行的操作。</p><h3 id="一级目录系统"><a href="#一级目录系统" class="headerlink" title="一级目录系统"></a>一级目录系统</h3><p>目录系统最简单的形式是有一个能够包含所有文件的目录。这种目录被称为<code>根目录(root directory)</code>，由于根目录的唯一性，所以其名称并不重要。在最早期的个人计算机中，这种系统很常见，部分原因是因为只有一个用户。下面是一个单层目录系统的例子</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830155-ca95d416-207a-46d6-89dd-77c398a175d3.png#height=306&id=LyUcX&originHeight=306&originWidth=500&originalType=binary%E2%88%B6=1&size=0&status=done&style=none&width=500"></p><p>含有四个文件的单层目录系统</p><p>该目录中有四个文件。这种设计的优点在于简单，并且能够快速定位文件，毕竟只有一个地方可以检索。这种目录组织形式现在一般用于简单的嵌入式设备（如数码相机和某些便携式音乐播放器）上使用。</p><h3 id="层次目录系统"><a href="#层次目录系统" class="headerlink" title="层次目录系统"></a>层次目录系统</h3><p>对于简单的应用而言，一般都用单层目录方式，但是这种组织形式并不适合于现代计算机，因为现代计算机含有成千上万个文件和文件夹。如果都放在根目录下，查找起来会非常困难。为了解决这一问题，出现了<code>层次目录系统(Hierarchical Directory Systems)</code>，也称为<code>目录树</code>。通过这种方式，可以用很多目录把文件进行分组。进而，如果多个用户共享同一个文件服务器，比如公司的网络系统，每个用户可以为自己的目录树拥有自己的私人根目录。这种方式的组织结构如下</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830190-cdcd48b8-b7ca-4597-b41d-d61089e0250d.png#height=447&id=eyi1a&originHeight=447&originWidth=699&originalType=binary%E2%88%B6=1&size=0&status=done&style=none&width=699"></p><p>根目录含有目录 A、B 和 C ，分别属于不同的用户，其中两个用户个字创建了<code>子目录</code>。用户可以创建任意数量的子目录，现代文件系统都是按照这种方式组织的。</p><h3 id="路径名"><a href="#路径名" class="headerlink" title="路径名"></a>路径名</h3><p>当目录树组织文件系统时，需要有某种方法指明文件名。常用的方法有两种，第一种方式是每个文件都会用一个<code>绝对路径名(absolute path name)</code>，它由根目录到文件的路径组成。</p><p>另外一种指定文件名的方法是 <code>相对路径名(relative path name)</code>。它常常和 <code>工作目录(working directory)</code> （也称作 <code>当前目录(current directory)</code>）一起使用。用户可以指定一个目录作为当前工作目录。例如，如果当前目录是 <code>/usr/ast</code>，那么绝对路径 <code>/usr/ast/mailbox</code>可以直接使用 <code>mailbox</code> 来引用。</p><h3 id="目录操作"><a href="#目录操作" class="headerlink" title="目录操作"></a>目录操作</h3><p>不同文件中管理目录的系统调用的差别比管理文件的系统调用差别大。为了了解这些系统调用有哪些以及它们怎样工作，下面给出一个例子（取自 UNIX）。</p><ol><li><code>Create</code>，创建目录，除了目录项 <code>.</code> 和 <code>..</code> 外，目录内容为空。</li><li><code>Delete</code>，删除目录，只有空目录可以删除。只包含 <code>.</code> 和 <code>..</code> 的目录被认为是空目录，这两个目录项通常不能删除</li><li><code>opendir</code>，目录内容可被读取。例如，未列出目录中的全部文件，程序必须先打开该目录，然后读其中全部文件的文件名。与打开和读文件相同，在读目录前，必须先打开文件。</li><li><code>closedir</code>，读目录结束后，应该关闭目录用于释放内部表空间。</li><li><code>readdir</code>，系统调用 readdir 返回打开目录的下一个目录项。以前也采用 read 系统调用来读取目录，但是这种方法有一个缺点：程序员必须了解和处理目录的内部结构。相反，不论采用哪一种目录结构，readdir 总是以标准格式返回一个目录项。</li><li><code>rename</code>，在很多方面目录和文件都相似。文件可以更换名称，目录也可以。</li><li><code>link</code>，链接技术允许在多个目录中出现同一个文件。这个系统调用指定一个存在的文件和一个路径名，并建立从该文件到路径所指名字的链接。这样，可以在多个目录中出现同一个文件。有时也被称为<code>硬链接(hard link)</code>。</li><li><code>unlink</code>，删除目录项。如果被解除链接的文件只出现在一个目录中，则将它从文件中删除。如果它出现在多个目录中，则只删除指定路径名的链接，依然保留其他路径名的链接。在 UNIX 中，用于删除文件的系统调用就是 unlink。</li></ol><h2 id="文件系统的实现"><a href="#文件系统的实现" class="headerlink" title="文件系统的实现"></a>文件系统的实现</h2><h3 id="文件系统布局"><a href="#文件系统布局" class="headerlink" title="文件系统布局"></a>文件系统布局</h3><p>文件系统存储在<code>磁盘</code>中。大部分的磁盘能够划分出一到多个分区，叫做<code>磁盘分区(disk partitioning)</code> 或者是<code>磁盘分片(disk slicing)</code>。每个分区都有独立的文件系统，每块分区的文件系统可以不同。磁盘的 0 号分区称为 <code>主引导记录(Master Boot Record, MBR)</code>，用来<code>引导(boot)</code> 计算机。在 MBR 的结尾是<code>分区表(partition table)</code>。每个分区表给出每个分区由开始到结束的地址。</p><p>当计算机开始引 boot 时，BIOS 读入并执行 MBR。</p><h4 id="引导块"><a href="#引导块" class="headerlink" title="引导块"></a>引导块</h4><p>MBR 做的第一件事就是<code>确定活动分区</code>，读入它的第一个块，称为<code>引导块(boot block)</code> 并执行。引导块中的程序将加载分区中的操作系统。为了一致性，每个分区都会从引导块开始，即使引导块不包含操作系统。引导块占据文件系统的前 4096 个字节，从磁盘上的字节偏移量 0 开始。引导块可用于启动操作系统。</p><p>除了从引导块开始之外，磁盘分区的布局是随着文件系统的不同而变化的。通常文件系统会包含一些属性，如下</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830178-416c1399-355d-4e11-aaad-360c3071d651.png#height=419&id=WO5Ij&originHeight=419&originWidth=725&originalType=binary%E2%88%B6=1&size=0&status=done&style=none&width=725"></p><p>文件系统布局</p><h4 id="超级块"><a href="#超级块" class="headerlink" title="超级块"></a>超级块</h4><p>紧跟在引导块后面的是 <code>超级块(Superblock)</code>，超级块 的大小为 4096 字节，从磁盘上的字节偏移 4096 开始。超级块包含文件系统的所有关键参数</p><ul><li>文件系统的大小</li><li>文件系统中的数据块数</li><li>指示文件系统状态的标志</li><li>分配组大小</li></ul><p>在计算机启动或者文件系统首次使用时，超级块会被读入内存。</p><h4 id="空闲空间块"><a href="#空闲空间块" class="headerlink" title="空闲空间块"></a>空闲空间块</h4><p>接着是文件系统中<code>空闲块</code>的信息，例如，可以用位图或者指针列表的形式给出。</p><p><strong>BitMap 位图或者 Bit vector 位向量</strong></p><p>位图或位向量是一系列位或位的集合，其中每个位对应一个磁盘块，该位可以采用两个值：0 和 1，0 表示已分配该块，而 1 表示一个空闲块。下图中的磁盘上给定的磁盘块实例（分配了绿色块）可以用 16 位的位图表示为：0000111000000110。</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830202-8aab8dd3-4293-45ca-ab73-fdf893584edc.png#height=428&id=NJVi8&originHeight=428&originWidth=395&originalType=binary%E2%88%B6=1&size=0&status=done&style=none&width=395"></p><p><strong>使用链表进行管理</strong></p><p>在这种方法中，空闲磁盘块链接在一起，即一个空闲块包含指向下一个空闲块的指针。第一个磁盘块的块号存储在磁盘上的单独位置，也缓存在内存中。</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830218-bc0ef6e9-c0df-4495-9a7f-4bd5161d4bef.png#height=422&id=dvjrg&originHeight=422&originWidth=432&originalType=binary%E2%88%B6=1&size=0&status=done&style=none&width=432"></p><h4 id="碎片"><a href="#碎片" class="headerlink" title="碎片"></a>碎片</h4><p>这里不得不提一个叫做<code>碎片(fragment)</code>的概念，也称为片段。一般零散的单个数据通常称为片段。 磁盘块可以进一步分为固定大小的分配单元，片段只是在驱动器上彼此不相邻的文件片段。</p><h4 id="inode"><a href="#inode" class="headerlink" title="inode"></a>inode</h4><p>然后在后面是一个 <code>inode(index node)</code>，也称作索引节点。它是一个数组的结构，每个文件有一个 inode，inode 非常重要，它说明了文件的方方面面。每个索引节点都存储对象数据的属性和磁盘块位置</p><p>有一种简单的方法可以找到它们 <code>ls -lai</code> 命令。让我们看一下根文件系统：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830231-757b0e6a-7a82-4ec8-9a1c-15b9999e0185.png#height=228&id=dyXmP&originHeight=228&originWidth=725&originalType=binary%E2%88%B6=1&size=0&status=done&style=none&width=725"></p><p>inode 节点主要包括了以下信息</p><ul><li>模式/权限（保护）</li><li>所有者 ID</li><li>组 ID</li><li>文件大小</li><li>文件的硬链接数</li><li>上次访问时间</li><li>最后修改时间</li><li>inode 上次修改时间</li></ul><p>文件分为两部分，索引节点和块。一旦创建后，每种类型的块数是固定的。你不能增加分区上 inode 的数量，也不能增加磁盘块的数量。</p><p>紧跟在 inode 后面的是根目录，它存放的是文件系统目录树的根部。最后，磁盘的其他部分存放了其他所有的目录和文件。</p><h3 id="文件的实现"><a href="#文件的实现" class="headerlink" title="文件的实现"></a>文件的实现</h3><p>最重要的问题是记录各个文件分别用到了哪些磁盘块。不同的系统采用了不同的方法。下面我们会探讨一下这些方式。分配背后的主要思想是<code>有效利用文件空间</code>和<code>快速访问文件</code> ，主要有三种分配方案</p><ul><li>连续分配</li><li>链表分配</li><li>索引分配</li></ul><h4 id="连续分配"><a href="#连续分配" class="headerlink" title="连续分配"></a>连续分配</h4><p>最简单的分配方案是把每个文件作为一连串连续数据块存储在磁盘上。因此，在具有 1KB 块的磁盘上，将为 50 KB 文件分配 50 个连续块。</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830290-96589d90-fa12-43fb-a38a-8ece59db8fcd.png#height=267&id=DEFjo&originHeight=267&originWidth=708&originalType=binary%E2%88%B6=1&size=0&status=done&style=none&width=708"></p><p>使用连续空间存储文件</p><p>上面展示了 40 个连续的内存块。从最左侧的 0 块开始。初始状态下，还没有装载文件，因此磁盘是空的。接着，从磁盘开始处（块 0 ）处开始写入占用 4 块长度的内存 A 。然后是一个占用 6 块长度的内存 B，会直接在 A 的末尾开始写。</p><p>注意每个文件都会在新的文件块开始写，所以如果文件 A 只占用了 <code>3 又 1/2</code> 个块，那么最后一个块的部分内存会被浪费。在上面这幅图中，总共展示了 7 个文件，每个文件都会从上个文件的末尾块开始写新的文件块。</p><p>连续的磁盘空间分配有两个优点。</p><ul><li>第一，连续文件存储实现起来比较简单，只需要记住两个数字就可以：一个是第一个块的文件地址和文件的块数量。给定第一个块的编号，可以通过简单的加法找到任何其他块的编号。</li><li>第二点是读取性能比较强，可以通过一次操作从文件中读取整个文件。只需要一次寻找第一个块。后面就不再需要寻道时间和旋转延迟，所以数据会以全带宽进入磁盘。</li></ul><p>因此，连续的空间分配具有<code>实现简单</code>、<code>高性能</code>的特点。</p><p>不幸的是，连续空间分配也有很明显的不足。随着时间的推移，磁盘会变得很零碎。下图解释了这种现象</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830262-ef7ce9d8-c4b9-488c-a2d3-48d7888ffe1f.png#height=250&id=AWBOd&originHeight=250&originWidth=700&originalType=binary%E2%88%B6=1&size=0&status=done&style=none&width=700"></p><p>这里有两个文件 D 和 F 被删除了。当删除一个文件时，此文件所占用的块也随之释放，就会在磁盘空间中留下一些空闲块。磁盘并不会在这个位置挤压掉空闲块，因为这会复制空闲块之后的所有文件，可能会有上百万的块，这个量级就太大了。</p><h4 id="链表分配"><a href="#链表分配" class="headerlink" title="链表分配"></a>链表分配</h4><p>第二种存储文件的方式是为每个文件构造磁盘块链表，每个文件都是磁盘块的链接列表，就像下面所示</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830296-9199d50b-5e5b-43f4-a62b-dc0b1ef02d6d.png#height=472&id=UEy0O&originHeight=472&originWidth=739&originalType=binary%E2%88%B6=1&size=0&status=done&style=none&width=739"></p><p>以磁盘块的链表形式存储文件</p><p>每个块的第一个字作为指向下一块的指针，块的其他部分存放数据。如果上面这张图你看的不是很清楚的话，可以看看整个的链表分配方案</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830272-99171e3f-0aae-4fa7-b127-e43f64daed7d.png#height=548&id=MV6v4&originHeight=548&originWidth=717&originalType=binary%E2%88%B6=1&size=0&status=done&style=none&width=717"></p><p>与连续分配方案不同，这一方法可以充分利用每个磁盘块。除了最后一个磁盘块外，不会因为磁盘碎片而浪费存储空间。同样，在目录项中，只要存储了第一个文件块，那么其他文件块也能够被找到。</p><p>另一方面，在链表的分配方案中，尽管顺序读取非常方便，但是随机访问却很困难（这也是数组和链表数据结构的一大区别）。</p><p>还有一个问题是，由于指针会占用一些字节，每个磁盘块实际存储数据的字节数并不再是 2 的整数次幂。虽然这个问题并不会很严重，但是这种方式降低了程序运行效率。许多程序都是以长度为 2 的整数次幂来读写磁盘，由于每个块的前几个字节被指针所使用，所以要读出一个完成的块大小信息，就需要当前块的信息和下一块的信息拼凑而成，因此就引发了查找和拼接的开销。</p><h4 id="使用内存表进行链表分配"><a href="#使用内存表进行链表分配" class="headerlink" title="使用内存表进行链表分配"></a>使用内存表进行链表分配</h4><p>由于连续分配和链表分配都有其不可忽视的缺点。所以提出了使用内存中的表来解决分配问题。取出每个磁盘块的指针字，把它们放在内存的一个表中，就可以解决上述链表的两个不足之处。下面是一个例子</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830309-8180ae56-d298-4224-a60b-d472bd7dff53.png#height=448&id=qB40I&originHeight=448&originWidth=499&originalType=binary%E2%88%B6=1&size=0&status=done&style=none&width=499"></p><p>上图表示了链表形成的磁盘块的内容。这两个图中都有两个文件，文件 A 依次使用了磁盘块地址 <strong>4、7、 2、 10、 12</strong>，文件 B 使用了<strong>6、3、11 和 14</strong>。也就是说，文件 A 从地址 4 处开始，顺着链表走就能找到文件 A 的全部磁盘块。同样，从第 6 块开始，顺着链走到最后，也能够找到文件 B 的全部磁盘块。你会发现，这两个链表都以不属于有效磁盘编号的特殊标记（-1）结束。内存中的这种表格称为 <code>文件分配表(File Application Table,FAT)</code>。</p><h3 id="目录的实现"><a href="#目录的实现" class="headerlink" title="目录的实现"></a>目录的实现</h3><p>文件只有打开后才能够被读取。在文件打开后，操作系统会使用用户提供的路径名来定位磁盘中的目录。目录项提供了查找文件磁盘块所需要的信息。根据系统的不同，提供的信息也不同，可能提供的信息是整个文件的磁盘地址，或者是第一个块的数量（两个链表方案）或 inode 的数量。不过不管用那种情况，目录系统的主要功能就是 <strong>将文件的 ASCII 码的名称映射到定位数据所需的信息上</strong>。</p><h3 id="共享文件"><a href="#共享文件" class="headerlink" title="共享文件"></a>共享文件</h3><p>当多个用户在同一个项目中工作时，他们通常需要共享文件。如果这个共享文件同时出现在多个用户目录下，那么他们协同工作起来就很方便。下面的这张图我们在上面提到过，但是有一个更改的地方，就是 <strong>C 的一个文件也出现在了 B 的目录下</strong>。</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830321-b6391c5b-3b64-4089-9c4e-9a9afd09875c.png#height=559&id=wJKZ9&originHeight=559&originWidth=743&originalType=binary%E2%88%B6=1&size=0&status=done&style=none&width=743"></p><p>如果按照如上图的这种组织方式而言，那么 B 的目录与该共享文件的联系称为 <code>链接(link)</code>。那么文件系统现在就是一个 <code>有向无环图(Directed Acyclic Graph, 简称 DAG)</code>，而不是一棵树了。</p><h3 id="日志结构文件系统"><a href="#日志结构文件系统" class="headerlink" title="日志结构文件系统"></a>日志结构文件系统</h3><p>技术的改变会给当前的文件系统带来压力。这种情况下，CPU 会变得越来越快，磁盘会变得越来越大并且越来越便宜（但不会越来越快）。内存容量也是以指数级增长。但是磁盘的寻道时间（除了固态盘，因为固态盘没有寻道时间）并没有获得提高。</p><p>为此，<code>Berkeley</code> 设计了一种全新的文件系统，试图缓解这个问题，这个文件系统就是 <code>日志结构文件系统(Log-structured File System, LFS)</code>。旨在解决以下问题。</p><ul><li>不断增长的系统内存</li><li>顺序 I/O 性能胜过随机 I/O 性能</li><li>现有低效率的文件系统</li><li>文件系统不支持 RAID（虚拟化）</li></ul><p>另一方面，当时的文件系统不论是 UNIX 还是 FFS，都有大量的随机读写（在 FFS 中创建一个新文件至少需要 5 次随机写），因此成为整个系统的性能瓶颈。同时因为 <code>Page cache</code> 的存在，作者认为随机读不是主要问题：随着越来越大的内存，大部分的读操作都能被 cache，因此 LFS 主要要解决的是减少对硬盘的随机写操作。</p><p>在这种设计中，inode 甚至具有与 UNIX 中相同的结构，但是现在它们分散在整个日志中，而不是位于磁盘上的固定位置。所以，inode 很定位。为了能够找到 inode ，维护了一个由 inode 索引的 <code>inode map(inode 映射)</code>。表项 i 指向磁盘中的第 i 个 inode 。这个映射保存在磁盘中，但是也保存在缓存中，因此，使用最频繁的部分大部分时间都在内存中。</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830360-ead8d1cc-da6e-40bc-896b-4350498bf5c8.png#height=348&id=qxML0&originHeight=348&originWidth=732&originalType=binary%E2%88%B6=1&size=0&status=done&style=none&width=732"></p><p>到目前为止，所有写入最初都缓存在<code>内存</code>中，并且追加在<code>日志末尾</code>，所有缓存的写入都定期在单个段中写入磁盘。所以，现在打开文件也就意味着用映射定位文件的索引节点。一旦 inode 被定位后，磁盘块的地址就能够被找到。所有这些块本身都将位于日志中某处的分段中。</p><p>真实情况下的磁盘容量是有限的，所以最终日志会占满整个磁盘空间，这种情况下就会出现没有新的磁盘块被写入到日志中。幸运的是，许多现有段可能具有不再需要的块。例如，如果一个文件被覆盖了，那么它的 inode 将被指向新的块，但是旧的磁盘块仍在先前写入的段中占据着空间。</p><p>为了处理这个问题，LFS 有一个<code>清理(clean)</code>线程，它会循环扫描日志并对日志进行压缩。首先，通过查看日志中第一部分的信息来查看其中存在哪些索引节点和文件。它会检查当前 inode 的映射来查看 inode 否在在当前块中，是否仍在被使用。如果不是，该信息将被丢弃。如果仍然在使用，那么 inode 和块就会进入内存等待写回到下一个段中。然后原来的段被标记为空闲，以便日志可以用来存放新的数据。用这种方法，清理线程遍历日志，从后面移走旧的段，然后将有效的数据放入内存等待写到下一个段中。由此一来整个磁盘会形成一个大的<code>环形缓冲区</code>，写线程将新的段写在前面，而清理线程则清理后面的段。</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830348-81e32c04-1184-4cdb-8403-2efeeb68787c.png#height=236&id=A4Ev0&originHeight=236&originWidth=631&originalType=binary%E2%88%B6=1&size=0&status=done&style=none&width=631"></p><h3 id="日志文件系统"><a href="#日志文件系统" class="headerlink" title="日志文件系统"></a>日志文件系统</h3><p>虽然日志结构系统的设计很优雅，但是由于它们和现有的文件系统不相匹配，因此还没有广泛使用。不过，从日志文件结构系统衍生出来一种新的日志系统，叫做<code>日志文件系统</code>，它会记录系统下一步将要做什么的日志。微软的 <code>NTFS</code> 文件系统、Linux 的 <code>ext3</code> 就使用了此日志。 <code>OS X</code> 将日志系统作为可供选项。为了看清它是如何工作的，我们下面讨论一个例子，比如 <code>移除文件</code> ，这个操作在 UNIX 中需要三个步骤完成：</p><ul><li>在目录中删除文件</li><li>释放 inode 到空闲 inode 池</li><li>将所有磁盘块归还给空闲磁盘池。</li></ul><h3 id="虚拟文件系统"><a href="#虚拟文件系统" class="headerlink" title="虚拟文件系统"></a>虚拟文件系统</h3><p>UNIX 操作系统使用一种 <code>虚拟文件系统(Virtual File System, VFS)</code> 来尝试将多种文件系统构成一个有序的结构。关键的思想是抽象出所有文件系统都共有的部分，并将这部分代码放在一层，这一层再调用具体文件系统来管理数据。下面是一个 VFS 的系统结构</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830356-635b72b4-bcf2-434f-9719-c83b191da6cf.png#height=345&id=zWieH&originHeight=345&originWidth=675&originalType=binary%E2%88%B6=1&size=0&status=done&style=none&width=675"></p><p>还是那句经典的话，在计算机世界中，任何解决不了的问题都可以加个<code>代理</code>来解决。所有和文件相关的系统调用在最初的处理上都指向虚拟文件系统。这些来自用户进程的调用，都是标准的 <code>POSIX 系统调用</code>，比如 open、read、write 和 seek 等。VFS 对用户进程有一个 <code>上层</code> 接口，这个接口就是著名的 POSIX 接口。</p><h2 id="文件系统的管理和优化"><a href="#文件系统的管理和优化" class="headerlink" title="文件系统的管理和优化"></a>文件系统的管理和优化</h2><p>能够使文件系统工作是一回事，能够使文件系统高效、稳定的工作是另一回事，下面我们就来探讨一下文件系统的管理和优化。</p><h3 id="磁盘空间管理"><a href="#磁盘空间管理" class="headerlink" title="磁盘空间管理"></a>磁盘空间管理</h3><p>文件通常存在磁盘中，所以如何管理磁盘空间是一个操作系统的设计者需要考虑的问题。在文件上进行存有两种策略：<strong>分配 n 个字节的连续磁盘空间；或者把文件拆分成多个并不一定连续的块</strong>。在存储管理系统中，主要有<code>分段管理</code>和 <code>分页管理</code> 两种方式。</p><p>正如我们所看到的，按<code>连续字节序列</code>存储文件有一个明显的问题，当文件扩大时，有可能需要在磁盘上移动文件。内存中分段也有同样的问题。不同的是，相对于把文件从磁盘的一个位置移动到另一个位置，内存中段的移动操作要快很多。因此，几乎所有的文件系统都把文件分割成固定大小的块来存储。</p><h4 id="块大小"><a href="#块大小" class="headerlink" title="块大小"></a>块大小</h4><p>一旦把文件分为固定大小的块来存储，就会出现问题，块的大小是多少？按照<strong>磁盘组织方式，扇区、磁道和柱面显然都可以作为分配单位</strong>。在分页系统中，分页大小也是主要因素。</p><p>拥有大的块尺寸意味着每个文件，甚至 1 字节文件，都要占用一个柱面空间，也就是说小文件浪费了大量的磁盘空间。另一方面，小块意味着大部分文件将会跨越多个块，因此需要多次搜索和旋转延迟才能读取它们，从而降低了性能。因此，如果分配的块<code>太大</code>会浪费<code>空间</code>；分配的块<code>太小</code>会浪费<code>时间</code>。</p><h4 id="记录空闲块"><a href="#记录空闲块" class="headerlink" title="记录空闲块"></a>记录空闲块</h4><p>一旦指定了块大小，下一个问题就是怎样跟踪空闲块。有两种方法被广泛采用，如下图所示</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830365-86ca166a-5dd1-4e96-b9b4-2966e2d87565.png#height=476&id=CTgLy&originHeight=476&originWidth=753&originalType=binary%E2%88%B6=1&size=0&status=done&style=none&width=753"></p><p>第一种方法是采用<code>磁盘块链表</code>，链表的每个块中包含极可能多的空闲磁盘块号。对于 1 KB 的块和 32 位的磁盘块号，空闲表中每个块包含有 255 个空闲的块号。考虑 1 TB 的硬盘，拥有大概十亿个磁盘块。为了存储全部地址块号，如果每块可以保存 255 个块号，则需要将近 400 万个块。通常，空闲块用于保存空闲列表，因此存储基本上是空闲的。</p><p>另一种空闲空间管理的技术是<code>位图(bitmap)</code>，n 个块的磁盘需要 n 位位图。在位图中，空闲块用 1 表示，已分配的块用 0 表示。对于 1 TB 硬盘的例子，需要 10 亿位表示，即需要大约 130 000 个 1 KB 块存储。很明显，和 32 位链表模型相比，位图需要的空间更少，因为每个块使用 1 位。只有当磁盘快满的时候，链表需要的块才会比位图少。</p><h3 id="磁盘配额"><a href="#磁盘配额" class="headerlink" title="磁盘配额"></a>磁盘配额</h3><p>为了防止一些用户占用太多的磁盘空间，多用户操作通常提供一种<code>磁盘配额(enforcing disk quotas)</code>的机制。系统管理员为每个用户分配<strong>最大的文件和块分配</strong>，并且操作系统确保用户不会超过其配额。我们下面会谈到这一机制。</p><p>在用户打开一个文件时，操作系统会找到<code>文件属性</code>和<code>磁盘地址</code>，并把它们送入内存中的打开文件表。其中一个属性告诉<code>文件所有者</code>是谁。任何有关文件的增加都会记到所有者的配额中。</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830397-dc14e657-f7ce-4c0e-a2fc-dae37cdce37e.png#height=532&id=Oo3ow&originHeight=532&originWidth=681&originalType=binary%E2%88%B6=1&size=0&status=done&style=none&width=681"></p><p>配额表中记录了每个用户的配额</p><p>第二张表包含了每个用户当前打开文件的配额记录，即使是其他人打开该文件也一样。如上图所示，该表的内容是从被打开文件的所有者的磁盘配额文件中提取出来的。当所有文件关闭时，该记录被写回配额文件。</p><p>当在打开文件表中建立一新表项时，会产生一个指向所有者配额记录的指针。每次向文件中添加一个块时，文件所有者所用数据块的总数也随之增加，并会同时增加<code>硬限制</code>和<code>软限制</code>的检查。可以超出软限制，但硬限制不可以超出。当已达到硬限制时，再往文件中添加内容将引发错误。同样，对文件数目也存在类似的检查。</p><h3 id="文件系统备份"><a href="#文件系统备份" class="headerlink" title="文件系统备份"></a>文件系统备份</h3><p>做文件备份很耗费时间而且也很浪费空间，这会引起下面几个问题。首先，是要<strong>备份整个文件还是仅备份一部分呢</strong>？一般来说，只是备份特定目录及其下的全部文件，而不是备份整个文件系统。</p><p>其次，对上次未修改过的文件再进行备份是一种浪费，因而产生了一种<code>增量转储(incremental dumps)</code> 的思想。最简单的增量转储的形式就是<code>周期性</code>的做全面的备份，而每天只对增量转储完成后发生变化的文件做单个备份。</p><p>稍微好一点的方式是只备份最近一次转储以来更改过的文件。当然，这种做法极大的缩减了转储时间，但恢复起来却更复杂，因为<strong>最近的全面转储先要全部恢复，随后按逆序进行增量转储</strong>。为了方便恢复，人们往往使用更复杂的转储模式。</p><p>第三，既然待转储的往往是海量数据，那么在将其写入磁带之前对文件进行压缩就很有必要。但是，如果在备份过程中出现了文件损坏的情况，就会导致破坏压缩算法，从而使整个磁带无法读取。所以在备份前是否进行文件压缩需慎重考虑。</p><p>第四，对正在使用的文件系统做备份是很难的。如果在转储过程中要添加，删除和修改文件和目录，则转储结果可能不一致。因此，因为转储过程中需要花费数个小时的时间，所以有必要在晚上将系统脱机进行备份，然而这种方式的接受程度并不高。所以，人们修改了转储算法，记下文件系统的<code>瞬时快照</code>，即复制关键的数据结构，然后需要把将来对文件和目录所做的修改复制到块中，而不是到处更新他们。</p><p>磁盘转储到备份磁盘上有两种方案：<strong>物理转储和逻辑转储</strong>。<code>物理转储(physical dump)</code> 是从磁盘的 0 块开始，依次将所有磁盘块按照顺序写入到输出磁盘，并在复制最后一个磁盘时停止。这种程序的万无一失性是其他程序所不具备的。</p><p>第二个需要考虑的是<strong>坏块的转储</strong>。制造大型磁盘而没有瑕疵是不可能的，所以也会存在一些<code>坏块(bad blocks)</code>。有时进行低级格式化后，坏块会被检测出来并进行标记，这种情况的解决办法是用磁盘末尾的一些空闲块所替换。</p><p>然而，一些块在格式化后会变坏，在这种情况下操作系统可以检测到它们。通常情况下，它可以通过创建一个由所有坏块组成的<code>文件</code>来解决问题，确保它们不会出现在空闲池中并且永远不会被分配。<strong>那么此文件是完全不可读的</strong>。如果磁盘控制器将所有的坏块重新映射，物理转储还是能够正常工作的。</p><p>Windows 系统有<code>分页文件(paging files)</code> 和 <code>休眠文件(hibernation files)</code> 。它们在文件还原时不发挥作用，同时也不应该在第一时间进行备份。</p><h3 id="文件系统的一致性"><a href="#文件系统的一致性" class="headerlink" title="文件系统的一致性"></a>文件系统的一致性</h3><p>影响可靠性的一个因素是文件系统的一致性。许多文件系统读取磁盘块、修改磁盘块、再把它们写回磁盘。如果系统在所有块写入之前崩溃，文件系统就会处于一种<code>不一致(inconsistent)</code>的状态。如果某些尚未写回的块是索引节点块，目录块或包含空闲列表的块，则此问题是很严重的。</p><p>为了处理文件系统一致性问题，大部分计算机都会有应用程序来检查文件系统的一致性。例如，UNIX 有 <code>fsck</code>；Windows 有 <code>sfc</code>，每当引导系统时（尤其是在崩溃后），都可以运行该程序。</p><p>可以进行两种一致性检查：<strong>块的一致性检查和文件的一致性检查</strong>。为了检查块的一致性，应用程序会建立两张表，每个包含一个计数器的块，最初设置为 0 。第一个表中的计数器跟踪该块在文件中出现的次数，第二张表中的计数器记录每个块在空闲列表、空闲位图中出现的频率。</p><h3 id="文件系统性能"><a href="#文件系统性能" class="headerlink" title="文件系统性能"></a>文件系统性能</h3><p>访问磁盘的效率要比内存满的多，是时候又祭出这张图了</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830422-af95403a-f195-4d9e-8125-0d05ec7651ff.png#height=312&id=oMNVY&originHeight=312&originWidth=711&originalType=binary%E2%88%B6=1&size=0&status=done&style=none&width=711"></p><p>从内存读一个 32 位字大概是 10ns，从硬盘上读的速率大概是 100MB/S，对每个 32 位字来说，效率会慢了四倍，另外，还要加上 5 - 10 ms 的寻道时间等其他损耗，如果只访问一个字，内存要比磁盘快百万数量级。所以磁盘优化是很有必要的，下面我们会讨论几种优化方式</p><h4 id="高速缓存"><a href="#高速缓存" class="headerlink" title="高速缓存"></a>高速缓存</h4><p>最常用的减少磁盘访问次数的技术是使用 <code>块高速缓存(block cache)</code> 或者 <code>缓冲区高速缓存(buffer cache)</code>。高速缓存指的是一系列的块，它们在逻辑上属于磁盘，但实际上基于性能的考虑被保存在内存中。</p><p>管理高速缓存有不同的算法，常用的算法是：检查全部的读请求，查看在高速缓存中是否有所需要的块。如果存在，可执行读操作而无须访问磁盘。如果检查块不再高速缓存中，那么首先把它读入高速缓存，再复制到所需的地方。之后，对同一个块的请求都通过<code>高速缓存</code>来完成。</p><p>高速缓存的操作如下图所示</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830486-9b7cd7d5-cd58-485e-8fb9-7c5f918fb69a.png#height=262&id=w4gdw&originHeight=262&originWidth=733&originalType=binary%E2%88%B6=1&size=0&status=done&style=none&width=733"></p><p>由于在高速缓存中有许多块，所以需要某种方法快速确定所需的块是否存在。常用方法是将设备和磁盘地址进行散列操作，然后，在散列表中查找结果。具有相同散列值的块在一个链表中连接在一起（这个数据结构是不是很像 HashMap?），这样就可以沿着冲突链查找其他块。</p><p>如果高速缓存<code>已满</code>，此时需要调入新的块，则要把原来的某一块调出高速缓存，如果要调出的块在上次调入后已经被修改过，则需要把它写回磁盘。</p><h4 id="块提前读"><a href="#块提前读" class="headerlink" title="块提前读"></a>块提前读</h4><p>第二个明显提高文件系统的性能是，在需要用到块之前，试图<code>提前</code>将其写入高速缓存，从而<code>提高命中率</code>。许多文件都是顺序读取。如果请求文件系统在某个文件中生成块 k，文件系统执行相关操作并且在完成之后，会检查高速缓存，以便确定块 k + 1 是否已经在高速缓存。如果不在，文件系统会为 k + 1 安排一个预读取，因为文件希望在用到该块的时候能够直接从高速缓存中读取。</p><p>当然，块提前读取策略只适用于实际顺序读取的文件。对随机访问的文件，提前读丝毫不起作用。甚至还会造成阻碍。</p><h4 id="减少磁盘臂运动"><a href="#减少磁盘臂运动" class="headerlink" title="减少磁盘臂运动"></a>减少磁盘臂运动</h4><p>高速缓存和块提前读并不是提高文件系统性能的唯一方法。另一种重要的技术是<strong>把有可能顺序访问的块放在一起，当然最好是在同一个柱面上，从而减少磁盘臂的移动次数</strong>。当写一个输出文件时，文件系统就必须按照要求一次一次地分配磁盘块。如果用位图来记录空闲块，并且整个位图在内存中，那么选择与前一块最近的空闲块是很容易的。如果用空闲表，并且链表的一部分存在磁盘上，要分配紧邻的空闲块就会困难很多。</p><h4 id="磁盘碎片整理"><a href="#磁盘碎片整理" class="headerlink" title="磁盘碎片整理"></a>磁盘碎片整理</h4><p>在初始安装操作系统后，文件就会被不断的创建和清除，于是磁盘会产生很多的碎片，在创建一个文件时，它使用的块会散布在整个磁盘上，降低性能。删除文件后，回收磁盘块，可能会造成空穴。</p><p>磁盘性能可以通过如下方式恢复：移动文件使它们相互挨着，并把所有的至少是大部分的空闲空间放在一个或多个大的连续区域内。Windows 有一个程序 <code>defrag</code> 就是做这个事儿的。Windows 用户会经常使用它，SSD 除外。</p><p>磁盘碎片整理程序会在让文件系统上很好地运行。Linux 文件系统（特别是 ext2 和 ext3）由于其选择磁盘块的方式，在磁盘碎片整理上一般不会像 Windows 一样困难，因此很少需要手动的磁盘碎片整理。而且，固态硬盘并不受磁盘碎片的影响，事实上，在固态硬盘上做磁盘碎片整理反倒是多此一举，不仅没有提高性能，反而磨损了固态硬盘。所以碎片整理只会缩短固态硬盘的寿命。</p><p>下面我们来探讨一下 I/O 流程问题。</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830481-2693434c-6334-4f5a-a152-75454e91d275.png#height=474&id=Nh8lv&originHeight=474&originWidth=752&originalType=binary%E2%88%B6=1&size=0&status=done&style=none&width=752"></p><h2 id="I-O-设备"><a href="#I-O-设备" class="headerlink" title="I/O 设备"></a>I/O 设备</h2><p>什么是 I/O 设备？I/O 设备又叫做输入/输出设备，它是人类用来和计算机进行通信的外部硬件。输入/输出设备能够向计算机<code>发送数据（输出）</code>并从计算机<code>接收数据（输入）</code>。</p><p><code>I/O 设备(I/O devices)</code>可以分成两种：<code>块设备(block devices)</code> 和 <code>字符设备(character devices)</code>。</p><h4 id="块设备"><a href="#块设备" class="headerlink" title="块设备"></a>块设备</h4><p>块设备是一个能存储<code>固定大小块</code>信息的设备，它支持<strong>以固定大小的块，扇区或群集读取和（可选）写入数据</strong>。每个块都有自己的<code>物理地址</code>。通常块的大小在 512 - 65536 之间。所有传输的信息都会以<code>连续</code>的块为单位。块设备的基本特征是每个块都较为对立，能够独立的进行读写。常见的块设备有 <strong>硬盘、蓝光光盘、USB 盘</strong></p><p>与字符设备相比，块设备通常需要较少的引脚。</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830476-de4c28f8-7881-487b-9bc3-11bf81770f23.png#height=257&id=pm6J2&originHeight=257&originWidth=700&originalType=binary%E2%88%B6=1&size=0&status=done&style=none&width=700"></p><h4 id="块设备的缺点"><a href="#块设备的缺点" class="headerlink" title="块设备的缺点"></a>块设备的缺点</h4><p>基于给定固态存储器的块设备比基于相同类型的存储器的字节寻址要慢一些，因为必须在块的开头开始读取或写入。所以，要读取该块的任何部分，必须寻找到该块的开始，读取整个块，如果不使用该块，则将其丢弃。要写入块的一部分，必须寻找到块的开始，将整个块读入内存，修改数据，再次寻找到块的开头处，然后将整个块写回设备。</p><h4 id="字符设备"><a href="#字符设备" class="headerlink" title="字符设备"></a>字符设备</h4><p>另一类 I/O 设备是<code>字符设备</code>。字符设备以<code>字符</code>为单位发送或接收一个字符流，而不考虑任何块结构。字符设备是不可寻址的，也没有任何寻道操作。常见的字符设备有 <strong>打印机、网络设备、鼠标、以及大多数与磁盘不同的设备</strong>。</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830510-e704b09f-ae66-45ce-bde4-66fd175dc769.png#height=322&id=ZC93B&originHeight=322&originWidth=703&originalType=binary%E2%88%B6=1&size=0&status=done&style=none&width=703"></p><h3 id="设备控制器"><a href="#设备控制器" class="headerlink" title="设备控制器"></a>设备控制器</h3><p>设备控制器是处理 CPU 传入和传出信号的系统。设备通过插头和插座连接到计算机，并且插座连接到设备控制器。设备控制器从连接的设备处接收数据，并将其存储在控制器内部的一些<code>特殊目的寄存器(special purpose registers)</code> 也就是本地缓冲区中。</p><p>每个设备控制器都会有一个应用程序与之对应，设备控制器通过应用程序的接口通过中断与操作系统进行通信。设备控制器是硬件，而设备驱动程序是软件。</p><h3 id="内存映射-I-O"><a href="#内存映射-I-O" class="headerlink" title="内存映射 I/O"></a>内存映射 I/O</h3><p>每个控制器都会有几个寄存器用来和 CPU 进行通信。通过写入这些寄存器，操作系统可以命令设备发送数据，接收数据、开启或者关闭设备等。通过从这些寄存器中读取信息，操作系统能够知道设备的状态，是否准备接受一个新命令等。</p><p>为了控制<code>寄存器</code>，许多设备都会有<code>数据缓冲区(data buffer)</code>，来供系统进行读写。</p><p>那么问题来了，CPU 如何与设备寄存器和设备数据缓冲区进行通信呢？存在两个可选的方式。第一种方法是，每个控制寄存器都被分配一个 <code>I/O 端口(I/O port)</code>号，这是一个 8 位或 16 位的整数。所有 I/O 端口的集合形成了受保护的 I/O 端口空间，以便普通用户程序无法访问它（只有操作系统可以访问）。使用特殊的 I/O 指令像是</p><pre><code class="assembly">IN REG,PORT</code></pre><p>CPU 可以读取控制寄存器 PORT 的内容并将结果放在 CPU 寄存器 REG 中。类似的，使用</p><pre><code class="assembly">OUT PORT,REG</code></pre><p>CPU 可以将 REG 的内容写到控制寄存器中。大多数早期计算机，包括几乎所有大型主机，如 IBM 360 及其所有后续机型，都是以这种方式工作的。</p><p>第二个方法是 PDP-11 引入的，它将<strong>所有控制寄存器映射到内存空间</strong>中。</p><h3 id="直接内存访问"><a href="#直接内存访问" class="headerlink" title="直接内存访问"></a>直接内存访问</h3><p>无论一个 CPU 是否具有内存映射 I/O，它都需要寻址设备控制器以便与它们交换数据。CPU 可以从 I/O 控制器每次请求一个字节的数据，但是这么做会浪费 CPU 时间，所以经常会用到一种称为<code>直接内存访问(Direct Memory Access)</code> 的方案。为了简化，我们假设 CPU 通过单一的系统总线访问所有的设备和内存，该总线连接 CPU 、内存和 I/O 设备，如下图所示</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830508-9d21c036-35f6-4f66-a119-b33cd2ebffa9.png#height=351&id=s3oNe&originHeight=351&originWidth=720&originalType=binary%E2%88%B6=1&size=0&status=done&style=none&width=720"></p><p>DMA 传送操作</p><p>现代操作系统实际更为复杂，但是原理是相同的。如果硬件有 <code>DMA 控制器</code>，那么操作系统只能使用 DMA。有时这个控制器会集成到磁盘控制器和其他控制器中，但这种设计需要在每个设备上都装有一个分离的 DMA 控制器。单个的 DMA 控制器可用于向多个设备传输，这种传输往往同时进行。</p><h4 id="DMA-工作原理"><a href="#DMA-工作原理" class="headerlink" title="DMA 工作原理"></a>DMA 工作原理</h4><p>首先 CPU 通过设置 DMA 控制器的寄存器对它进行编程，所以 DMA 控制器知道将什么数据传送到什么地方。DMA 控制器还要向磁盘控制器发出一个命令，通知它从磁盘读数据到其内部的缓冲区并检验校验和。当有效数据位于磁盘控制器的缓冲区中时，DMA 就可以开始了。</p><p>DMA 控制器通过在总线上发出一个<code>读请求</code>到磁盘控制器而发起 DMA 传送，这是第二步。这个读请求就像其他读请求一样，磁盘控制器并不知道或者并不关心它是来自 CPU 还是来自 DMA 控制器。通常情况下，要写的内存地址在总线的地址线上，所以当磁盘控制器去匹配下一个字时，它知道将该字写到什么地方。写到内存就是另外一个总线循环了，这是第三步。当写操作完成时，磁盘控制器在总线上发出一个应答信号到 DMA 控制器，这是第四步。</p><p>然后，DMA 控制器会增加内存地址并减少字节数量。如果字节数量仍然大于 0 ，就会循环步骤 2 - 步骤 4 ，直到字节计数变为 0 。此时，DMA 控制器会打断 CPU 并告诉它传输已经完成了。</p><h3 id="重温中断"><a href="#重温中断" class="headerlink" title="重温中断"></a>重温中断</h3><p>在一台个人计算机体系结构中，中断结构会如下所示</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830529-8f149c71-9817-4096-a8df-b613c0308a0c.png#height=320&id=iOWO2&originHeight=320&originWidth=719&originalType=binary%E2%88%B6=1&size=0&status=done&style=none&width=719"></p><p>中断是怎样发生的</p><p>当一个 I/O 设备完成它的工作后，它就会产生一个中断（默认操作系统已经开启中断），它通过在总线上声明已分配的信号来实现此目的。主板上的中断控制器芯片会检测到这个信号，然后执行中断操作。</p><h4 id="精确中断和不精确中断"><a href="#精确中断和不精确中断" class="headerlink" title="精确中断和不精确中断"></a>精确中断和不精确中断</h4><p>使机器处于良好状态的中断称为<code>精确中断(precise interrupt)</code>。这样的中断具有四个属性：</p><ul><li>PC （程序计数器）保存在一个已知的地方</li><li>PC 所指向的指令之前所有的指令已经完全执行</li><li>PC 所指向的指令之后所有的指令都没有执行</li><li>PC 所指向的指令的执行状态是已知的</li></ul><p>不满足以上要求的中断称为 <code>不精确中断(imprecise interrupt)</code>，不精确中断让人很头疼。上图描述了不精确中断的现象。指令的执行时序和完成度具有不确定性，而且恢复起来也非常麻烦。</p><h2 id="IO-软件原理"><a href="#IO-软件原理" class="headerlink" title="IO 软件原理"></a>IO 软件原理</h2><h3 id="I-O-软件目标"><a href="#I-O-软件目标" class="headerlink" title="I/O 软件目标"></a>I/O 软件目标</h3><h4 id="设备独立性"><a href="#设备独立性" class="headerlink" title="设备独立性"></a>设备独立性</h4><p>I/O 软件设计一个很重要的目标就是<code>设备独立性(device independence)</code>。这意味着<strong>我们能够编写访问任何设备的应用程序，而不用事先指定特定的设备</strong>。</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830529-e4825574-4e1c-43fa-adf0-519f0ea1c7f7.png#height=403&id=GdxNy&originHeight=403&originWidth=500&originalType=binary%E2%88%B6=1&size=0&status=done&style=none&width=500"></p><h4 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h4><p>除了<code>设备独立性</code>外，I/O 软件实现的第二个重要的目标就是<code>错误处理(error handling)</code>。通常情况下来说，错误应该交给<code>硬件</code>层面去处理。如果设备控制器发现了读错误的话，它会尽可能的去修复这个错误。如果设备控制器处理不了这个问题，那么设备驱动程序应该进行处理，设备驱动程序会再次尝试读取操作，很多错误都是偶然性的，如果设备驱动程序无法处理这个错误，才会把错误向上抛到硬件层面（上层）进行处理，很多时候，上层并不需要知道下层是如何解决错误的。</p><h4 id="同步和异步传输"><a href="#同步和异步传输" class="headerlink" title="同步和异步传输"></a>同步和异步传输</h4><p>I/O 软件实现的第三个目标就是 <code>同步(synchronous)</code> 和 <code>异步(asynchronous，即中断驱动)</code>传输。这里先说一下同步和异步是怎么回事吧。</p><p>同步传输中数据通常以块或帧的形式发送。发送方和接收方在数据传输之前应该具有<code>同步时钟</code>。而在异步传输中，数据通常以字节或者字符的形式发送，异步传输则不需要同步时钟，但是会在传输之前向数据添加<code>奇偶校验位</code>。大部分<code>物理IO(physical I/O)</code> 是异步的。物理 I/O 中的 CPU 是很聪明的，CPU 传输完成后会转而做其他事情，它和中断心灵相通，等到中断发生后，CPU 才会回到传输这件事情上来。</p><h4 id="缓冲"><a href="#缓冲" class="headerlink" title="缓冲"></a>缓冲</h4><p>I/O 软件的最后一个问题是<code>缓冲(buffering)</code>。通常情况下，从一个设备发出的数据不会直接到达最后的设备。其间会经过一系列的校验、检查、缓冲等操作才能到达。</p><h4 id="共享和独占"><a href="#共享和独占" class="headerlink" title="共享和独占"></a>共享和独占</h4><p>I/O 软件引起的最后一个问题就是共享设备和独占设备的问题。有些 I/O 设备能够被许多用户共同使用。一些设备比如磁盘，让多个用户使用一般不会产生什么问题，但是某些设备必须具有独占性，即只允许单个用户使用完成后才能让其他用户使用。</p><p>一共有三种控制 I/O 设备的方法</p><ul><li>使用程序控制 I/O</li><li>使用中断驱动 I/O</li><li>使用 DMA 驱动 I/O</li></ul><h2 id="I-O-层次结构"><a href="#I-O-层次结构" class="headerlink" title="I/O 层次结构"></a>I/O 层次结构</h2><p>I/O 软件通常组织成四个层次，它们的大致结构如下图所示</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830546-fa05a772-fc02-4957-ba1d-1e5a82d78de2.png#height=372&id=la9lz&originHeight=372&originWidth=733&originalType=binary%E2%88%B6=1&size=0&status=done&style=none&width=733"></p><p>下面我们具体的来探讨一下上面的层次结构</p><h3 id="中断处理程序"><a href="#中断处理程序" class="headerlink" title="中断处理程序"></a>中断处理程序</h3><p>在计算机系统中，中断就像女人的脾气一样无时无刻都在产生，中断的出现往往是让人很不爽的。中断处理程序又被称为<code>中断服务程序</code> 或者是 <code>ISR(Interrupt Service Routines)</code>，它是最靠近硬件的一层。中断处理程序由硬件中断、软件中断或者是软件异常启动产生的中断，用于实现设备驱动程序或受保护的操作模式（例如系统调用）之间的转换。</p><p>中断处理程序负责处理中断发生时的所有操作，操作完成后阻塞，然后启动中断驱动程序来解决阻塞。通常会有三种通知方式，依赖于不同的具体实现</p><ul><li>信号量实现中：在信号量上使用 <code>up</code> 进行通知；</li><li>管程实现：对管程中的条件变量执行 <code>signal</code> 操作</li><li>还有一些情况是发送一些消息</li></ul><h3 id="设备驱动程序"><a href="#设备驱动程序" class="headerlink" title="设备驱动程序"></a>设备驱动程序</h3><p>每个连接到计算机的 I/O 设备都需要有某些特定设备的代码对其进行控制。这些提供 I/O 设备到设备控制器转换的过程的代码称为 <code>设备驱动程序(Device driver)</code>。</p><p>设备控制器的主要功能有下面这些</p><ul><li>接收和识别命令：设备控制器可以接受来自 CPU 的指令，并进行识别。设备控制器内部也会有寄存器，用来存放指令和参数</li><li>进行数据交换：CPU、控制器和设备之间会进行数据的交换，CPU 通过总线把指令发送给控制器，或从控制器中并行地读出数据；控制器将数据写入指定设备。</li><li>地址识别：每个硬件设备都有自己的地址，设备控制器能够识别这些不同的地址，来达到控制硬件的目的，此外，为使 CPU 能向寄存器中写入或者读取数据，这些寄存器都应具有唯一的地址。</li><li>差错检测：设备控制器还具有对设备传递过来的数据进行检测的功能。</li></ul><p>在这种情况下，设备控制器会阻塞，直到中断来解除阻塞状态。还有一种情况是操作是可以无延迟的完成，所以驱动程序不需要阻塞。在第一种情况下，操作系统可能被中断唤醒；第二种情况下操作系统不会被休眠。</p><p>设备驱动程序必须是<code>可重入</code>的，因为设备驱动程序会阻塞和唤醒然后再次阻塞。驱动程序不允许进行系统调用，但是它们通常需要与内核的其余部分进行交互。</p><h3 id="与设备无关的-I-O-软件"><a href="#与设备无关的-I-O-软件" class="headerlink" title="与设备无关的 I/O 软件"></a>与设备无关的 I/O 软件</h3><p>I/O 软件有两种，一种是我们上面介绍过的基于特定设备的，还有一种是<code>设备无关性</code>的，设备无关性也就是不需要特定的设备。设备驱动程序与设备无关的软件之间的界限取决于具体的系统。下面显示的功能由设备无关的软件实现</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830586-059b4da8-ea81-4a5a-b884-3377ca39d976.png#height=331&id=qRr1F&originHeight=331&originWidth=428&originalType=binary%E2%88%B6=1&size=0&status=done&style=none&width=428"></p><p>与设备无关的软件的基本功能是对所有设备执行公共的 I/O 功能，并且向用户层软件提供一个统一的接口。</p><h4 id="缓冲-1"><a href="#缓冲-1" class="headerlink" title="缓冲"></a>缓冲</h4><p>无论是对于块设备还是字符设备来说，缓冲都是一个非常重要的考量标准。缓冲技术应用广泛，但它也有缺点。如果数据被缓冲次数太多，会影响性能。</p><h4 id="错误处理-1"><a href="#错误处理-1" class="headerlink" title="错误处理"></a>错误处理</h4><p>在 I/O 中，出错是一种再正常不过的情况了。当出错发生时，操作系统必须尽可能处理这些错误。有一些错误是只有特定的设备才能处理，有一些是由框架进行处理，这些错误和特定的设备无关。</p><p>I/O 错误的一类是程序员<code>编程</code>错误，比如还没有打开文件前就读流，或者不关闭流导致内存溢出等等。这类问题由程序员处理；另外一类是实际的 I/O 错误，例如向一个磁盘坏块写入数据，无论怎么写都写入不了。这类问题由驱动程序处理，驱动程序处理不了交给硬件处理，这个我们上面也说过。</p><h4 id="设备驱动程序统一接口"><a href="#设备驱动程序统一接口" class="headerlink" title="设备驱动程序统一接口"></a>设备驱动程序统一接口</h4><p>我们在操作系统概述中说到，操作系统一个非常重要的功能就是屏蔽了硬件和软件的差异性，为硬件和软件提供了统一的标准，这个标准还体现在为设备驱动程序提供统一的接口，因为不同的硬件和厂商编写的设备驱动程序不同，所以如果为每个驱动程序都单独提供接口的话，这样没法搞，所以必须统一。</p><h4 id="分配和释放"><a href="#分配和释放" class="headerlink" title="分配和释放"></a>分配和释放</h4><p>一些设备例如打印机，它只能由一个进程来使用，这就需要操作系统根据实际情况判断是否能够对设备的请求进行检查，判断是否能够接受其他请求，一种比较简单直接的方式是在特殊文件上执行 <code>open</code>操作。如果设备不可用，那么直接 open 会导致失败。还有一种方式是不直接导致失败，而是让其阻塞，等到另外一个进程释放资源后，在进行 open 打开操作。这种方式就把选择权交给了用户，由用户判断是否应该等待。</p><h4 id="设备无关的块"><a href="#设备无关的块" class="headerlink" title="设备无关的块"></a>设备无关的块</h4><p>不同的磁盘会具有不同的扇区大小，但是软件不会关心扇区大小，只管存储就是了。一些字符设备可以一次一个字节的交付数据，而其他的设备则以较大的单位交付数据，这些差异也可以隐藏起来。</p><h3 id="用户空间的-I-O-软件"><a href="#用户空间的-I-O-软件" class="headerlink" title="用户空间的 I/O 软件"></a>用户空间的 I/O 软件</h3><p>虽然大部分 I/O 软件都在内核结构中，但是还有一些在用户空间实现的 I/O 软件，凡事没有绝对。一些 I/O 软件和库过程在用户空间存在，然后以提供系统调用的方式实现。</p><h2 id="盘"><a href="#盘" class="headerlink" title="盘"></a>盘</h2><p>盘可以说是硬件里面比较简单的构造了，同时也是最重要的。下面我们从盘谈起，聊聊它的物理构造</p><h3 id="盘硬件"><a href="#盘硬件" class="headerlink" title="盘硬件"></a>盘硬件</h3><p>盘会有很多种类型。其中最简单的构造就是<code>磁盘(magnetic hard disks)</code>， 也被称为 <code>hard disk,HDD</code>等。磁盘通常与安装在磁臂上的磁头配对，磁头可将数据读取或者将数据写入磁盘，因此磁盘的读写速度都同样快。在磁盘中，数据是随机访问的，这也就说明可以通过任意的顺序来<code>存储</code>和<code>检索</code>单个数据块，所以你可以在任意位置放置磁盘来让磁头读取，磁盘是一种<code>非易失性</code>的设备，即使断电也能永久保留。</p><h4 id="磁盘"><a href="#磁盘" class="headerlink" title="磁盘"></a>磁盘</h4><p>为了组织和检索数据，会将磁盘组织成特定的结构，这些特定的结构就是<strong>磁道、扇区和柱面</strong></p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830596-8b2a7f11-b5c9-4a00-b0c9-436889b099a8.png#height=448&id=XlRJ3&originHeight=448&originWidth=498&originalType=binary%E2%88%B6=1&size=0&status=done&style=none&width=498"></p><p>磁盘被组织成柱面形式，每个盘用轴相连，每一个柱面包含若干磁道，每个磁道由若干扇区组成。软盘上大约每个磁道有 8 - 32 个扇区，硬盘上每条磁道上扇区的数量可达几百个，磁头大约是 1 - 16 个。</p><p>对于磁盘驱动程序来说，一个非常重要的特性就是控制器是否能够同时控制两个或者多个驱动器进行磁道寻址，这就是<code>重叠寻道(overlapped seek)</code>。对于控制器来说，它能够控制一个磁盘驱动程序完成寻道操作，同时让其他驱动程序等待寻道结束。控制器也可以在一个驱动程序上进行读写草哦做，与此同时让另外的驱动器进行寻道操作，但是软盘控制器不能在两个驱动器上进行读写操作。</p><h4 id="RAID"><a href="#RAID" class="headerlink" title="RAID"></a>RAID</h4><p>RAID 称为 <code>磁盘冗余阵列</code>，简称 <code>磁盘阵列</code>。利用虚拟化技术把多个硬盘结合在一起，成为一个或多个磁盘阵列组，目的是提升性能或数据冗余。</p><p>RAID 有不同的级别</p><ul><li>RAID 0 - 无容错的条带化磁盘阵列</li><li>RAID 1 - 镜像和双工</li><li>RAID 2 - 内存式纠错码</li><li>RAID 3 - 比特交错奇偶校验</li><li>RAID 4 - 块交错奇偶校验</li><li>RAID 5 - 块交错分布式奇偶校验</li><li>RAID 6 - P + Q 冗余</li></ul><h4 id="磁盘格式化"><a href="#磁盘格式化" class="headerlink" title="磁盘格式化"></a>磁盘格式化</h4><p>磁盘由一堆铝的、合金或玻璃的盘片组成，磁盘刚被创建出来后，没有任何信息。磁盘在使用前必须经过<code>低级格式化(low-levvel format)</code>，下面是一个扇区的格式</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830611-1b106d56-fbdb-4e79-b2b5-e5bd2778a387.png#height=86&id=LU06a&originHeight=86&originWidth=638&originalType=binary%E2%88%B6=1&size=0&status=done&style=none&width=638"></p><p>前导码相当于是标示扇区的开始位置，通常以位模式开始，前导码还包括<code>柱面号</code>、<code>扇区号</code>等一些其他信息。紧随前导码后面的是数据区，数据部分的大小由低级格式化程序来确定。大部分磁盘使用 512 字节的扇区。数据区后面是 ECC，ECC 的全称是 <strong>error correction code</strong> ，<code>数据纠错码</code>，它与普通的错误检测不同，ECC 还可以用于恢复读错误。ECC 阶段的大小由不同的磁盘制造商实现。ECC 大小的设计标准取决于<strong>设计者愿意牺牲多少磁盘空间来提高可靠性</strong>，以及程序可以处理的 ECC 的复杂程度。通常情况下 ECC 是 16 位，除此之外，硬盘一般具有一定数量的备用扇区，用于替换制造缺陷的扇区。</p><h3 id="磁盘臂调度算法"><a href="#磁盘臂调度算法" class="headerlink" title="磁盘臂调度算法"></a>磁盘臂调度算法</h3><p>下面我们来探讨一下关于影响磁盘读写的算法，一般情况下，影响磁盘快读写的时间由下面几个因素决定</p><ul><li>寻道时间 - 寻道时间指的就是将磁盘臂移动到需要读取磁盘块上的时间</li><li>旋转延迟 - 等待合适的扇区旋转到磁头下所需的时间</li><li>实际数据的读取或者写入时间</li></ul><p>这三种时间参数也是磁盘寻道的过程。一般情况下，寻道时间对总时间的影响最大，所以，有效的降低寻道时间能够提高磁盘的读取速度。</p><p>如果磁盘驱动程序每次接收一个请求并按照接收顺序完成请求，这种处理方式也就是 <code>先来先服务(First-Come, First-served, FCFS)</code> ，这种方式很难优化寻道时间。因为每次都会按照顺序处理，不管顺序如何，有可能这次读完后需要等待一个磁盘旋转一周才能继续读取，而其他柱面能够马上进行读取，这种情况下每次请求也会排队。</p><p>通常情况下，磁盘在进行寻道时，其他进程会产生其他的磁盘请求。磁盘驱动程序会维护一张表，表中会记录着柱面号当作索引，每个柱面未完成的请求会形成链表，链表头存放在表的相应表项中。</p><p>一种对先来先服务的算法改良的方案是使用 <code>最短路径优先(SSF)</code> 算法，下面描述了这个算法。</p><p>假如我们在对磁道 6 号进行寻址时，同时发生了对 11 , 2 , 4, 14, 8, 15, 3 的请求，如果采用先来先服务的原则，如下图所示</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830646-2dfee703-9a35-47c9-880c-2c620d64464a.png#height=427&id=GIQle&originHeight=427&originWidth=762&originalType=binary%E2%88%B6=1&size=0&status=done&style=none&width=762"></p><p>我们可以计算一下磁盘臂所跨越的磁盘数量为 5 + 9 + 2 + 10 + 6 + 7 + 12 = 51，相当于是跨越了 51 次盘面，如果使用最短路径优先，我们来计算一下跨越的盘面</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830629-e3cda6d4-2317-438b-a377-9e5dc5a3a802.png#height=381&id=k9irp&originHeight=381&originWidth=709&originalType=binary%E2%88%B6=1&size=0&status=done&style=none&width=709"></p><p>跨越的磁盘数量为 4 + 1 + 1 + 4 + 3 + 3 + 1 = 17 ，相比 51 足足省了两倍的时间。</p><p>但是，最短路径优先的算法也不是完美无缺的，这种算法照样存在问题，那就是<code>优先级</code> 问题，</p><p>这里有一个原型可以参考就是我们日常生活中的电梯，电梯使用一种<code>电梯算法(elevator algorithm)</code> 来进行调度，从而满足协调效率和公平性这两个相互冲突的目标。电梯一般会保持向一个方向移动，直到在那个方向上没有请求为止，然后改变方向。</p><p>电梯算法需要维护一个<code>二进制位</code>，也就是当前的方向位：<code>UP(向上)</code>或者是 <code>DOWN(向下)</code>。当一个请求处理完成后，磁盘或电梯的驱动程序会检查该位，如果此位是 UP 位，磁盘臂或者电梯仓移到下一个更高跌未完成的请求。如果高位没有未完成的请求，则取相反方向。当方向位是 <code>DOWN</code> 时，同时存在一个低位的请求，磁盘臂会转向该点。如果不存在的话，那么它只是停止并等待。</p><p>我们举个例子来描述一下电梯算法，比如各个柱面得到服务的顺序是 4，7，10，14，9，6，3，1 ，那么它的流程图如下</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830648-6e8afe9c-f2fd-4c64-8db9-7f68930d0a27.png#height=425&id=qkkaP&originHeight=425&originWidth=710&originalType=binary%E2%88%B6=1&size=0&status=done&style=none&width=710"></p><p>所以电梯算法需要跨越的盘面数量是 3 + 3 + 4 + 5 + 3 + 3 + 1 = 22</p><p>电梯算法通常情况下不如 SSF 算法。</p><h3 id="错误处理-2"><a href="#错误处理-2" class="headerlink" title="错误处理"></a>错误处理</h3><p>一般坏块有两种处理办法，一种是在控制器中进行处理；一种是在操作系统层面进行处理。</p><p>这两种方法经常替换使用，比如一个具有 30 个数据扇区和两个备用扇区的磁盘，其中扇区 4 是有瑕疵的。</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830690-4489f1b3-d4a8-49d6-bd29-1becb143d418.png#height=367&id=j9QM3&originHeight=367&originWidth=423&originalType=binary%E2%88%B6=1&size=0&status=done&style=none&width=423"></p><p>控制器能做的事情就是将备用扇区之一重新映射。</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830735-2f51c8ae-a37f-4673-9781-a2519263c63f.png#height=464&id=BSem5&originHeight=464&originWidth=500&originalType=binary%E2%88%B6=1&size=0&status=done&style=none&width=500"></p><p>还有一种处理方式是将所有的扇区都向上移动一个扇区</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830717-1dc1be76-6eff-4891-8d89-843a7110e6a8.png#height=460&id=OZ9U3&originHeight=460&originWidth=497&originalType=binary%E2%88%B6=1&size=0&status=done&style=none&width=497"></p><p>上面这这两种情况下控制器都必须知道哪个扇区，可以通过内部的表来跟踪这一信息，或者通过重写前导码来给出重新映射的扇区号。如果是重写前导码，那么涉及移动的方式必须重写后面所有的前导码，但是最终会提供良好的性能。</p><h3 id="稳定存储器"><a href="#稳定存储器" class="headerlink" title="稳定存储器"></a>稳定存储器</h3><p>磁盘经常会出现错误，导致好的扇区会变成坏扇区，驱动程序也有可能挂掉。RAID 可以对扇区出错或者是驱动器崩溃提出保护，然而 RAID 却不能对坏数据中的写错误提供保护，也不能对写操作期间的崩溃提供保护，这样就会破坏原始数据。</p><p>我们期望磁盘能够准确无误的工作，但是事实情况是不可能的，但是我们能够知道的是，一个磁盘子系统具有如下特性：当一个写命令发给它时，磁盘要么正确地写数据，要么什么也不做，让现有的数据完整无误的保留。这样的系统称为 <code>稳定存储器(stable storage)</code>。 稳定存储器的目标就是不惜一切代价保证磁盘的一致性。</p><p>稳定存储器使用两个一对相同的磁盘，对应的块一同工作形成一个无差别的块。稳定存储器为了实现这个目的，定义了下面三种操作：</p><ul><li><code>稳定写(stable write)</code></li><li><code>稳定读(stable read)</code></li><li><code>崩溃恢复(crash recovery)</code></li></ul><h2 id="时钟"><a href="#时钟" class="headerlink" title="时钟"></a>时钟</h2><p><code>时钟(Clocks)</code> 也被称为<code>定时器(timers)</code>，时钟/定时器对任何程序系统来说都是必不可少的。时钟负责维护时间、防止一个进程长期占用 CPU 时间等其他功能。<code>时钟软件(clock software)</code> 也是一种设备驱动的方式。下面我们就来对时钟进行介绍，一般都是先讨论硬件再介绍软件，采用由下到上的方式，也是告诉你，底层是最重要的。</p><h3 id="时钟硬件"><a href="#时钟硬件" class="headerlink" title="时钟硬件"></a>时钟硬件</h3><p>在计算机中有两种类型的时钟，这些时钟与现实生活中使用的时钟完全不一样。</p><ul><li>比较简单的一种时钟被连接到 110 V 或 220 V 的电源线上，这样每个<code>电压周期</code>会产生一个中断，大概是 50 - 60 HZ。这些时钟过去一直占据支配地位。</li><li>另外的一种时钟由晶体振荡器、计数器和寄存器组成，示意图如下所示</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830741-6daaaf06-0552-44b1-bf19-85729fd25288.png#height=503&id=VUI1p&originHeight=503&originWidth=627&originalType=binary%E2%88%B6=1&size=0&status=done&style=none&width=627"></p><p>这种时钟称为<code>可编程时钟</code> ，可编程时钟有两种模式，一种是 <code>一键式(one-shot mode)</code>，当时钟启动时，会把存储器中的值复制到计数器中，然后，每次晶体的振荡器的脉冲都会使计数器 -1。当计数器变为 0 时，会产生一个中断，并停止工作，直到软件再一次显示启动。还有一种模式时 <code>方波(square-wave mode)</code> 模式，在这种模式下，当计数器变为 0 并产生中断后，存储寄存器的值会自动复制到计数器中，这种周期性的中断称为一个时钟周期。</p><h3 id="时钟软件"><a href="#时钟软件" class="headerlink" title="时钟软件"></a>时钟软件</h3><p>时钟硬件所做的工作只是根据已知的时间间隔产生中断，而其他的工作都是由<code>时钟软件</code>来完成，一般操作系统的不同，时钟软件的具体实现也不同，但是一般都会包括以下这几点</p><ul><li>维护一天的时间</li><li>阻止进程运行的时间超过其指定时间</li><li>统计 CPU 的使用情况</li><li>处理用户进程的警告系统调用</li><li>为系统各个部分提供看门狗定时器</li><li>完成概要剖析，监视和信息收集</li></ul><h3 id="软定时器"><a href="#软定时器" class="headerlink" title="软定时器"></a>软定时器</h3><p>时钟软件也被称为可编程时钟，可以设置它以程序需要的任何速率引发中断。时钟软件触发的中断是一种硬中断，但是某些应用程序对于硬中断来说是不可接受的。</p><p>这时候就需要一种<code>软定时器(soft timer)</code> 避免了中断，无论何时当内核因为某种原因呢在运行时，它返回用户态之前都会检查时钟来了解软定时器是否到期。如果软定时器到期，则执行被调度的事件也无需切换到内核态，因为本身已经处于内核态中。这种方式避免了频繁的内核态和用户态之前的切换，提高了程序运行效率。</p><p>软定时器因为不同的原因切换进入内核态的速率不同，原因主要有</p><ul><li>系统调用</li><li>TLB 未命中</li><li>缺页异常</li><li>I/O 中断</li><li>CPU 变得空闲</li></ul><p>死锁问题也是操作系统非常重要的一类问题</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830748-305133ff-5324-4e46-b119-74609aedd401.png#height=286&id=WK6xj&originHeight=286&originWidth=721&originalType=binary%E2%88%B6=1&size=0&status=done&style=none&width=721"></p><h2 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h2><p>大部分的死锁都和资源有关，在进程对设备、文件具有独占性（排他性）时会产生死锁。我们把这类需要排他性使用的对象称为<code>资源(resource)</code>。资源主要分为 <strong>可抢占资源和不可抢占资源</strong></p><h3 id="可抢占资源和不可抢占资源"><a href="#可抢占资源和不可抢占资源" class="headerlink" title="可抢占资源和不可抢占资源"></a>可抢占资源和不可抢占资源</h3><p>资源主要有可抢占资源和不可抢占资源。<code>可抢占资源(preemptable resource)</code> 可以从拥有它的进程中抢占而不会造成其他影响，内存就是一种可抢占性资源，任何进程都能够抢先获得内存的使用权。</p><p><code>不可抢占资源(nonpreemtable resource)</code> 指的是除非引起错误或者异常，否则进程无法抢占指定资源，这种不可抢占的资源比如有光盘，在进程执行调度的过程中，其他进程是不能得到该资源的。</p><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>如果要对死锁进行一个定义的话，下面的定义比较贴切</p><p><strong>如果一组进程中的每个进程都在等待一个事件，而这个事件只能由该组中的另一个进程触发，这种情况会导致死锁</strong>。</p><h3 id="资源死锁的条件"><a href="#资源死锁的条件" class="headerlink" title="资源死锁的条件"></a>资源死锁的条件</h3><p>针对我们上面的描述，资源死锁可能出现的情况主要有</p><ul><li>互斥条件：每个资源都被分配给了一个进程或者资源是可用的</li><li>保持和等待条件：已经获取资源的进程被认为能够获取新的资源</li><li>不可抢占条件：分配给一个进程的资源不能强制的从其他进程抢占资源，它只能由占有它的进程显示释放</li><li>循环等待：死锁发生时，系统中一定有两个或者两个以上的进程组成一个循环，循环中的每个进程都在等待下一个进程释放的资源。</li></ul><p>发生死锁时，上面的情况必须同时会发生。如果其中任意一个条件不会成立，死锁就不会发生。可以通过破坏其中任意一个条件来破坏死锁，下面这些破坏条件就是我们探讨的重点</p><h3 id="死锁模型"><a href="#死锁模型" class="headerlink" title="死锁模型"></a>死锁模型</h3><p>Holt 在 1972 年提出对死锁进行建模，建模的标准如下：</p><ul><li>圆形表示进程</li><li>方形表示资源</li></ul><p>从资源节点到进程节点表示资源已经被进程占用，如下图所示</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830760-e22f0a74-94ab-4be7-9b39-3f611c32823a.png#height=352&id=BjL47&originHeight=352&originWidth=331&originalType=binary%E2%88%B6=1&size=0&status=done&style=none&width=331"></p><p>在上图中表示当前资源 R 正在被 A 进程所占用</p><p>由进程节点到资源节点的有向图表示当前进程正在请求资源，并且该进程已经被阻塞，处于等待这个资源的状态</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830813-2b57251b-055b-4664-b040-89f60d1d43c4.png#height=363&id=u51ZN&originHeight=363&originWidth=345&originalType=binary%E2%88%B6=1&size=0&status=done&style=none&width=345"></p><p>在上图中，表示的含义是进程 B 正在请求资源 S 。Holt 认为，死锁的描述应该如下</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830811-a3afe75e-0c48-40b9-8fa4-e74d132d9b58.png#height=381&id=bhef4&originHeight=381&originWidth=485&originalType=binary%E2%88%B6=1&size=0&status=done&style=none&width=485"></p><p>这是一个死锁的过程，进程 C 等待资源 T 的释放，资源 T 却已经被进程 D 占用，进程 D 等待请求占用资源 U ，资源 U 却已经被线程 C 占用，从而形成环。</p><p>有四种处理死锁的策略：</p><ul><li>忽略死锁带来的影响（惊呆了）</li><li>检测死锁并回复死锁，死锁发生时对其进行检测，一旦发生死锁后，采取行动解决问题</li><li>通过仔细分配资源来避免死锁</li><li>通过破坏死锁产生的四个条件之一来避免死锁</li></ul><p>下面我们分别介绍一下这四种方法</p><h2 id="鸵鸟算法"><a href="#鸵鸟算法" class="headerlink" title="鸵鸟算法"></a>鸵鸟算法</h2><p>最简单的解决办法就是使用<code>鸵鸟算法(ostrich algorithm)</code>，把头埋在沙子里，假装问题根本没有发生。每个人看待这个问题的反应都不同。数学家认为死锁是不可接受的，必须通过有效的策略来防止死锁的产生。工程师想要知道问题发生的频次，系统因为其他原因崩溃的次数和死锁带来的严重后果。如果死锁发生的频次很低，而经常会由于硬件故障、编译器错误等其他操作系统问题导致系统崩溃，那么大多数工程师不会修复死锁。</p><h2 id="死锁检测和恢复"><a href="#死锁检测和恢复" class="headerlink" title="死锁检测和恢复"></a>死锁检测和恢复</h2><p>第二种技术是死锁的检测和恢复。这种解决方式不会尝试去阻止死锁的出现。相反，这种解决方案会希望死锁尽可能的出现，在监测到死锁出现后，对其进行恢复。下面我们就来探讨一下死锁的检测和恢复的几种方式</p><h3 id="每种类型一个资源的死锁检测方式"><a href="#每种类型一个资源的死锁检测方式" class="headerlink" title="每种类型一个资源的死锁检测方式"></a>每种类型一个资源的死锁检测方式</h3><p>每种资源类型都有一个资源是什么意思？我们经常提到的打印机就是这样的，资源只有打印机，但是设备都不会超过一个。</p><p>可以通过构造一张资源分配表来检测这种错误，比如我们上面提到的</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830848-f4bc59e7-89e2-4e78-909c-e8dcd1718ebe.png#height=381&id=TYPR7&originHeight=381&originWidth=475&originalType=binary%E2%88%B6=1&size=0&status=done&style=none&width=475"></p><p>如果这张图包含了一个或一个以上的环，那么死锁就存在，处于这个环中任意一个进程都是死锁的进程。</p><h3 id="每种类型多个资源的死锁检测方式"><a href="#每种类型多个资源的死锁检测方式" class="headerlink" title="每种类型多个资源的死锁检测方式"></a>每种类型多个资源的死锁检测方式</h3><p>如果有多种相同的资源存在，就需要采用另一种方法来检测死锁。可以通过构造一个矩阵来检测从 P1 -&gt; Pn 这 n 个进程中的死锁。</p><p>现在我们提供一种基于矩阵的算法来检测从 P1 到 Pn 这 n 个进程中的死锁。假设资源类型为 m，E1 代表资源类型 1，E2 表示资源类型 2 ，Ei 代表资源类型 i (1 &lt;= i &lt;= m)。E 表示的是 <code>现有资源向量(existing resource vector)</code>，代表每种已存在的资源总数。</p><p>现在我们就需要构造两个数组：C 表示的是<code>当前分配矩阵(current allocation matrix)</code> ，R 表示的是 <code>请求矩阵(request matrix)</code>。Ci 表示的是 Pi 持有每一种类型资源的资源数。所以，Cij 表示 Pi 持有资源 j 的数量。Rij 表示 Pi 所需要获得的资源 j 的数量</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830847-d4f0a077-7abd-4507-a720-337bc99b121e.png#height=302&id=JZ0fA&originHeight=302&originWidth=686&originalType=binary%E2%88%B6=1&size=0&status=done&style=none&width=686"></p><p>一般来说，已分配资源 j 的数量加起来再和所有可供使用的资源数相加 = 该类资源的总数。</p><p>死锁的检测就是基于向量的比较。每个进程起初都是没有被标记过的，算法会开始对进程做标记，进程被标记后说明进程被执行了，不会进入死锁，当算法结束时，任何没有被标记过的进程都会被判定为死锁进程。</p><p>上面我们探讨了两种检测死锁的方式，那么现在你知道怎么检测后，你何时去做死锁检测呢？一般来说，有两个考量标准：</p><ul><li>每当有资源请求时就去检测，这种方式会占用昂贵的 CPU 时间。</li><li>每隔 k 分钟检测一次，或者当 CPU 使用率降低到某个标准下去检测。考虑到 CPU 效率的原因，如果死锁进程达到一定数量，就没有多少进程可以运行，所以 CPU 会经常空闲。</li></ul><h3 id="从死锁中恢复"><a href="#从死锁中恢复" class="headerlink" title="从死锁中恢复"></a>从死锁中恢复</h3><p>上面我们探讨了如何检测进程死锁，我们最终的目的肯定是想让程序能够正常的运行下去，所以针对检测出来的死锁，我们要对其进行恢复，下面我们会探讨几种死锁的恢复方式</p><h4 id="通过抢占进行恢复"><a href="#通过抢占进行恢复" class="headerlink" title="通过抢占进行恢复"></a>通过抢占进行恢复</h4><p>在某些情况下，可能会临时将某个资源从它的持有者转移到另一个进程。比如在不通知原进程的情况下，将某个资源从进程中强制取走给其他进程使用，使用完后又送回。这种恢复方式一般比较困难而且有些简单粗暴，并不可取。</p><h4 id="通过回滚进行恢复"><a href="#通过回滚进行恢复" class="headerlink" title="通过回滚进行恢复"></a>通过回滚进行恢复</h4><p>如果系统设计者和机器操作员知道有可能发生死锁，那么就可以定期检查流程。进程的检测点意味着进程的状态可以被写入到文件以便后面进行恢复。检测点不仅包含<code>存储映像(memory image)</code>，还包含<code>资源状态(resource state)</code>。一种更有效的解决方式是不要覆盖原有的检测点，而是每出现一个检测点都要把它写入到文件中，这样当进程执行时，就会有一系列的检查点文件被累积起来。</p><p>为了进行恢复，要从上一个较早的检查点上开始，这样所需要资源的进程会回滚到上一个时间点，在这个时间点上，死锁进程还没有获取所需要的资源，可以在此时对其进行资源分配。</p><h4 id="杀死进程恢复"><a href="#杀死进程恢复" class="headerlink" title="杀死进程恢复"></a>杀死进程恢复</h4><p>最简单有效的解决方案是直接杀死一个死锁进程。但是杀死一个进程可能照样行不通，这时候就需要杀死别的资源进行恢复。</p><p>另外一种方式是选择一个环外的进程作为牺牲品来释放进程资源。</p><h2 id="死锁避免"><a href="#死锁避免" class="headerlink" title="死锁避免"></a>死锁避免</h2><p>我们上面讨论的是如何检测出现死锁和如何恢复死锁，下面我们探讨几种规避死锁的方式</p><h3 id="单个资源的银行家算法"><a href="#单个资源的银行家算法" class="headerlink" title="单个资源的银行家算法"></a>单个资源的银行家算法</h3><p>银行家算法是 Dijkstra 在 1965 年提出的一种调度算法，它本身是一种死锁的调度算法。它的模型是基于一个城镇中的银行家，银行家向城镇中的客户承诺了一定数量的贷款额度。算法要做的就是判断请求是否会进入一种不安全的状态。如果是，就拒绝请求，如果请求后系统是安全的，就接受该请求。</p><p>类似的，还有多个资源的银行家算法，读者可以自行了解。</p><h2 id="破坏死锁"><a href="#破坏死锁" class="headerlink" title="破坏死锁"></a>破坏死锁</h2><p>死锁本质上是无法避免的，因为它需要获得未知的资源和请求，但是死锁是满足四个条件后才出现的，它们分别是</p><ul><li>互斥</li><li>保持和等待</li><li>不可抢占</li><li>循环等待</li></ul><p>我们分别对这四个条件进行讨论，按理说破坏其中的任意一个条件就能够破坏死锁</p><h3 id="破坏互斥条件"><a href="#破坏互斥条件" class="headerlink" title="破坏互斥条件"></a>破坏互斥条件</h3><p>我们首先考虑的就是<strong>破坏互斥使用条件</strong>。如果资源不被一个进程独占，那么死锁肯定不会产生。如果两个打印机同时使用一个资源会造成混乱，打印机的解决方式是使用 <code>假脱机打印机(spooling printer)</code> ，这项技术可以允许多个进程同时产生输出，在这种模型中，实际请求打印机的唯一进程是打印机守护进程，也称为后台进程。后台进程不会请求其他资源。我们可以消除打印机的死锁。</p><p>后台进程通常被编写为能够输出完整的文件后才能打印，假如两个进程都占用了假脱机空间的一半，而这两个进程都没有完成全部的输出，就会导致死锁。</p><p>因此，尽量做到尽可能少的进程可以请求资源。</p><h3 id="破坏保持等待的条件"><a href="#破坏保持等待的条件" class="headerlink" title="破坏保持等待的条件"></a>破坏保持等待的条件</h3><p>第二种方式是如果我们能阻止持有资源的进程请求其他资源，我们就能够消除死锁。一种实现方式是让所有的进程开始执行前请求全部的资源。如果所需的资源可用，进程会完成资源的分配并运行到结束。如果有任何一个资源处于频繁分配的情况，那么没有分配到资源的进程就会等待。</p><p>很多进程<strong>无法在执行完成前就知道到底需要多少资源</strong>，如果知道的话，就可以使用银行家算法；还有一个问题是这样<strong>无法合理有效利用资源</strong>。</p><p>还有一种方式是进程在请求其他资源时，先释放所占用的资源，然后再尝试一次获取全部的资源。</p><h3 id="破坏不可抢占条件"><a href="#破坏不可抢占条件" class="headerlink" title="破坏不可抢占条件"></a>破坏不可抢占条件</h3><p>破坏不可抢占条件也是可以的。可以通过虚拟化的方式来避免这种情况。</p><h3 id="破坏循环等待条件"><a href="#破坏循环等待条件" class="headerlink" title="破坏循环等待条件"></a>破坏循环等待条件</h3><p>现在就剩最后一个条件了，循环等待条件可以通过多种方法来破坏。一种方式是制定一个标准，一个进程在任何时候只能使用一种资源。如果需要另外一种资源，必须释放当前资源。对于需要将大文件从磁带复制到打印机的过程，此限制是不可接受的。</p><p>另一种方式是将所有的资源统一编号，如下图所示</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830860-d72b0344-264f-4bfe-91f7-43d5b4121f58.png#height=268&id=Nm5h1&originHeight=268&originWidth=419&originalType=binary%E2%88%B6=1&size=0&status=done&style=none&width=419"></p><p>进程可以在任何时间提出请求，但是所有的请求都必须按照资源的顺序提出。如果按照此分配规则的话，那么资源分配之间不会出现环。</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830858-19d66189-e808-4999-879e-3e2e8d4273f0.png#height=281&id=xulHt&originHeight=281&originWidth=423&originalType=binary%E2%88%B6=1&size=0&status=done&style=none&width=423"></p><p>尽管通过这种方式来消除死锁，但是编号的顺序不可能让每个进程都会接受。</p><h2 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h2><p>下面我们来探讨一下其他问题，包括 <strong>通信死锁、活锁是什么、饥饿问题和两阶段加锁</strong></p><h3 id="两阶段加锁"><a href="#两阶段加锁" class="headerlink" title="两阶段加锁"></a>两阶段加锁</h3><p>虽然很多情况下死锁的避免和预防都能处理，但是效果并不好。随着时间的推移，提出了很多优秀的算法用来处理死锁。例如在数据库系统中，一个经常发生的操作是请求锁住一些记录，然后更新所有锁定的记录。当同时有多个进程运行时，就会有死锁的风险。</p><p>一种解决方式是使用 <code>两阶段提交(two-phase locking)</code>。顾名思义分为两个阶段，一阶段是进程尝试一次锁定它需要的所有记录。如果成功后，才会开始第二阶段，第二阶段是执行更新并释放锁。第一阶段并不做真正有意义的工作。</p><p>如果在第一阶段某个进程所需要的记录已经被加锁，那么该进程会释放所有锁定的记录并重新开始第一阶段。从某种意义上来说，这种方法类似于预先请求所有必需的资源或者是在进行一些不可逆的操作之前请求所有的资源。</p><p>不过在一般的应用场景中，两阶段加锁的策略并不通用。如果一个进程缺少资源就会半途中断并重新开始的方式是不可接受的。</p><h3 id="通信死锁"><a href="#通信死锁" class="headerlink" title="通信死锁"></a>通信死锁</h3><p>我们上面一直讨论的是资源死锁，资源死锁是一种死锁类型，但并不是唯一类型，还有通信死锁，也就是两个或多个进程在发送消息时出现的死锁。进程 A 给进程 B 发了一条消息，然后进程 A 阻塞直到进程 B 返回响应。假设请求消息丢失了，那么进程 A 在一直等着回复，进程 B 也会阻塞等待请求消息到来，这时候就产生<code>死锁</code>。</p><p>尽管会产生死锁，但是这并不是一个资源死锁，因为 A 并没有占据 B 的资源。事实上，通信死锁并没有完全可见的资源。根据死锁的定义来说：每个进程因为等待其他进程引起的事件而产生阻塞，这就是一种死锁。相较于最常见的通信死锁，我们把上面这种情况称为<code>通信死锁(communication deadlock)</code>。</p><p>通信死锁不能通过调度的方式来避免，但是可以使用通信中一个非常重要的概念来避免：<code>超时(timeout)</code>。在通信过程中，只要一个信息被发出后，发送者就会启动一个定时器，定时器会记录消息的超时时间，如果超时时间到了但是消息还没有返回，就会认为消息已经丢失并重新发送，通过这种方式，可以避免通信死锁。</p><p>但是并非所有网络通信发生的死锁都是通信死锁，也存在资源死锁，下面就是一个典型的资源死锁。</p><p>当一个数据包从主机进入路由器时，会被放入一个缓冲区，然后再传输到另外一个路由器，再到另一个，以此类推直到目的地。缓冲区都是资源并且数量有限。如下图所示，每个路由器都有 10 个缓冲区（实际上有很多）。</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609726830887-98d92f9c-72d1-4710-a487-1bd4dc953b7c.png#height=322&id=JN6QA&originHeight=322&originWidth=702&originalType=binary%E2%88%B6=1&size=0&status=done&style=none&width=702"></p><p>假如路由器 A 的所有数据需要发送到 B ，B 的所有数据包需要发送到 D，然后 D 的所有数据包需要发送到 A 。没有数据包可以移动，因为在另一端没有缓冲区可用，这就是一个典型的资源死锁。</p><h3 id="活锁"><a href="#活锁" class="headerlink" title="活锁"></a>活锁</h3><p>某些情况下，当进程意识到它不能获取所需要的下一个锁时，就会尝试礼貌的释放已经获得的锁，然后等待非常短的时间再次尝试获取。可以想像一下这个场景：当两个人在狭路相逢的时候，都想给对方让路，相同的步调会导致双方都无法前进。</p><p>现在假想有一对并行的进程用到了两个资源。它们分别尝试获取另一个锁失败后，两个进程都会释放自己持有的锁，再次进行尝试，这个过程会一直进行重复。很明显，这个过程中没有进程阻塞，但是进程仍然不会向下执行，这种状况我们称之为 <code>活锁(livelock)</code>。</p><h3 id="饥饿"><a href="#饥饿" class="headerlink" title="饥饿"></a>饥饿</h3><p>与死锁和活锁的一个非常相似的问题是 <code>饥饿(starvvation)</code>。想象一下你什么时候会饿？一段时间不吃东西是不是会饿？对于进程来讲，最重要的就是资源，如果一段时间没有获得资源，那么进程会产生饥饿，这些进程会永远得不到服务。</p><p>我们假设打印机的分配方案是每次都会分配给最小文件的进程，那么要打印大文件的进程会永远得不到服务，导致进程饥饿，进程会无限制的推后，虽然它没有阻塞。</p>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>常用软件快捷键/CMD/Linux命令及其他使用</title>
      <link href="/blog/nvlr2g/"/>
      <url>/blog/nvlr2g/</url>
      
        <content type="html"><![CDATA[<p>做个记录</p><h2 id="一、软件常用快捷键"><a href="#一、软件常用快捷键" class="headerlink" title="一、软件常用快捷键"></a>一、软件常用快捷键</h2><h3 id="Win10-快捷键"><a href="#Win10-快捷键" class="headerlink" title="Win10 快捷键"></a>Win10 快捷键</h3><blockquote><p><strong>HP 惠普笔记本</strong></p></blockquote><pre><code>Win+E                  打开文件管器Win+D                  显示桌面Win+L                  锁计算机Win+V：                                打开剪贴板Win+PgUp：                            在桌面选定左上角软件/文件Win+PgDown：                        在桌面选定右下角软件/文件Win+G                                    录频选项Win+alt+G                            直接录频alt+F4                关闭当前程序ctrl+shift+Esc/ctrl+alt+delete：任务管理器ctrl+F                文本或网页中查找（退出一般按ESC）ctrl+A                选中所有文本</code></pre><h3 id="Eclipse-快捷键"><a href="#Eclipse-快捷键" class="headerlink" title="Eclipse 快捷键"></a>Eclipse 快捷键</h3><blockquote><p>ctrl+shift+L：eclipse 所有快捷键<br><code>//</code>注释：<code>ctrl+shift+c</code>（添加和注释都是这样）或者<code>ctrl+/</code> &gt; <code>/**/</code>注释：添加<code>ctrl+shift+/</code>   取消<code>ctrl+shift+\</code></p></blockquote><pre><code>Alt+方向键：                    将当前行向上或者向下移动ctrl+m：                            编辑窗口最大化（反复两次按即取消）ctrl+.及ctrl+1：            下一个错误及快速修改Control+O:                         快速概要,迅速的跳到一个方法或者属性，只需要输入名字的头几个字母。shift+home/end：                选中一行ctrl+pgup/pgdn：                切换页面（浏览器打开的页面/编辑器的多窗口）</code></pre><h3 id="VScode-快捷键"><a href="#VScode-快捷键" class="headerlink" title="VScode 快捷键"></a>VScode 快捷键</h3><pre><code>ctrl+shift+c                直接进入博客根目录下的CMD模式</code></pre><h3 id="Pycharm-JetBrains-快捷键"><a href="#Pycharm-JetBrains-快捷键" class="headerlink" title="Pycharm/JetBrains 快捷键"></a>Pycharm/JetBrains 快捷键</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685666000-0fb595f1-51e4-4e71-8547-96aa0b938148.png#crop=0&crop=0&crop=1&crop=1&height=397&id=E0vxq&originHeight=397&originWidth=769&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=0&status=done&style=none&title=&width=769"></p><pre><code>Ctrl+F5（左上角）：（return &quot;project&quot;）重新debug该文件F9：（resume program）一个断点接着一个断点走，不按行走（eg：有循环会随着i一步一步走完）F8：（step over） 一行一行走代码F7：（step into） 进入函数内部Alt+shift+F7：（step into mycode）遇到自己函数  进去shift+F8：（step out）跳出，进入函数后，跳出来Alt+F10：（show execution point）指针显示当前断点旁边**Show Python Prompt**按键,交互式调试命令</code></pre><h2 id="二、CMD"><a href="#二、CMD" class="headerlink" title="二、CMD"></a>二、CMD</h2><h3 id="CMD-常用命令"><a href="#CMD-常用命令" class="headerlink" title="CMD 常用命令"></a>CMD 常用命令</h3><blockquote><ul><li>使用 help 命令，查看所有的 dos 命令</li><li>找到命令之后，使用 <code>命令+ /?</code>来查看该命令下的其他属性</li><li>DOS 不区分大小写</li></ul></blockquote><p><strong>磁盘/文件夹相关：</strong></p><ul><li><p><code>d:</code> <code>e:</code> 进入不同的盘</p></li><li><p><code>cd:</code> 进入指定文件夹。注意：只在<strong>该磁盘</strong>才有效</p></li><li><p><code>dir</code> 查看当前目录下的所有文件，使用 dir /?来查看其它用法</p></li><li><p>创建和删除目录</p><ul><li>md 目录名（文件夹） //创建目录</li><li>rd   目录名（文件夹） //删除目录</li></ul></li><li><p>cd .. 返回上一级文件夹</p></li><li><p>复制文件:把一个文件移动（就是剪切+复制）到另一个地方。甚至可以改后缀</p><blockquote><p>move 路径\文件名 路径\文件名</p></blockquote></li><li><p>删除文件</p><blockquote><p>这个是专门删除文件的，不能删除文件夹<br>del 文件名</p></blockquote></li><li><p>生成文件树</p><blockquote><p><code>tree /f &gt;tree.txt</code></p></blockquote></li></ul><p><strong>网络相关：</strong></p><ul><li><code>ipconfig</code> 查看本机 ip</li><li><code>cls</code> 清除屏幕</li><li><code>ping</code><blockquote><p>用来测试网络是否畅通<br>ping ip(主机名)</p></blockquote></li></ul><p><strong>其他：</strong></p><ul><li>在文件夹空白处按住 Shift，然后右键弹出快捷菜单，可以看到“在此处打开命令行窗口”</li><li>tab 补齐功能！！！</li><li>文件及目录名中不能包含下列任何字符：\ / : * ? “ &lt; &gt; |</li></ul><h3 id="CMD-默认非-utf-8-编码解决方案"><a href="#CMD-默认非-utf-8-编码解决方案" class="headerlink" title="CMD 默认非 utf-8 编码解决方案"></a>CMD 默认非 utf-8 编码解决方案</h3><p>报错：运行 java 程序时候，如果代码中有中文，会出现中文报错乱码情况/</p><ul><li>方法一：治标方法</li></ul><p><code>CMD</code> 中输入 <code>chcp 65001</code> 进入 utf-8 模式下的的控制台，再运行程序</p><ul><li>方法二：治本方法</li></ul><p>注意：自己已经再注册表中增加了一行 tuf-8 编码数据，以后要留意、<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685666566-625a520c-ff9d-4eea-8fba-3a8c4f8f696e.png#crop=0&crop=0&crop=1&crop=1&height=24&id=SsvdB&originHeight=24&originWidth=660&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=0&status=done&style=stroke&title=&width=660"><br>参考：</p><ul><li><a href="https://blog.csdn.net/gulang03/article/details/81771343">修改 cmd 控制台默认代码页编码的几种方法【GBK、UTF-8】</a></li><li><a href="https://blog.csdn.net/runAndRun/article/details/103072938">windows 控制台 cmd/PowerShell 中文显示乱码，解决方法</a></li></ul><h3 id="CMD-运行-JAVA-文件"><a href="#CMD-运行-JAVA-文件" class="headerlink" title="CMD 运行 JAVA 文件"></a>CMD 运行 JAVA 文件</h3><h4 id="CMD-运行-java-程序"><a href="#CMD-运行-java-程序" class="headerlink" title="CMD 运行 java 程序"></a>CMD 运行 java 程序</h4><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685666652-cb97d69b-664c-4506-a24f-1dc5b8220a02.png#crop=0&crop=0&crop=1&crop=1&height=940&id=B6IyR&originHeight=940&originWidth=902&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=0&status=done&style=stroke&title=&width=902"></p><h4 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h4><ul><li>main 主函数可以看成一个普通的方法，也可以传递实参来调用普通方法</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685666759-75d2a062-c52d-4c49-acce-7310a0280f24.png#crop=0&crop=0&crop=1&crop=1&height=91&id=T7PKm&originHeight=214&originWidth=1070&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=0&status=done&style=none&title=&width=455"></p><ul><li>向 main 方法传递字符串</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685666878-98ce351e-4485-4381-bcfe-4b9121226fc9.png#crop=0&crop=0&crop=1&crop=1&height=207&id=PYoCa&originHeight=778&originWidth=1098&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=0&status=done&style=stroke&title=&width=292"></p><h4 id="CMD-下运行-Java-中文乱码"><a href="#CMD-下运行-Java-中文乱码" class="headerlink" title="CMD 下运行 Java 中文乱码"></a>CMD 下运行 Java 中文乱码</h4><p><code>javac -encoding utf-8 test.java</code><br>还是上面的问题，DOS 默认使用的编码是 GBK,这里需要再编译的时候制定使用的编码</p><h2 id="三、Linux"><a href="#三、Linux" class="headerlink" title="三、Linux"></a>三、Linux</h2><h3 id="Linux-命令"><a href="#Linux-命令" class="headerlink" title="Linux 命令"></a>Linux 命令</h3><p>查看 CentOS 版本：</p><pre><code class="bash">cat /etc/redhat-release</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1643018844135-441f0c04-500b-4dd4-97a3-d11edc72cae3.png#clientId=u5a4bb18f-257d-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=49&id=Q1RIE&margin=%5Bobject%20Object%5D&name=image.png&originHeight=49&originWidth=366&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=3856&status=done&style=none&taskId=ud38f38bc-4014-4e2d-9fb2-cc7781375f3&title=&width=366" alt="image.png"><br>在此可以去学习 Linux 相关命令，如果只是用 xshell 不适用其他软件，那么 linux 的使用很重要</p><h3 id="Linux-yum-命令"><a href="#Linux-yum-命令" class="headerlink" title="Linux yum 命令"></a>Linux yum 命令</h3><p>Linux yum 命令参考：<a href="https://www.runoob.com/linux/linux-yum.html">https://www.runoob.com/linux/linux-yum.html</a></p><blockquote><p>是一个终端的前端软件包管理器</p></blockquote><p>更新 CentOS 版本：</p><pre><code class="bash">yum -y update</code></pre>]]></content>
      
      
      <categories>
          
          <category> 🔨环境工具 </category>
          
          <category> 工具使用 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Jupyter使用总结</title>
      <link href="/blog/ouipza/"/>
      <url>/blog/ouipza/</url>
      
        <content type="html"><![CDATA[<h2 id="一、Jupyter-环境的搭建"><a href="#一、Jupyter-环境的搭建" class="headerlink" title="一、Jupyter 环境的搭建"></a>一、Jupyter 环境的搭建</h2><ol><li>pip 下载</li><li>跟随 anaconda 下载</li></ol><h2 id="二、高效使用，安装扩展插件"><a href="#二、高效使用，安装扩展插件" class="headerlink" title="二、高效使用，安装扩展插件"></a>二、高效使用，安装扩展插件</h2><p>一般只需要下面两条命令，就可以重新打开就可看见新安装的插件环境。</p><p><code>pip install jupyter_contrib_nbextensions</code></p><p>或者</p><p><code>jupyter contrib nbextension install</code></p><p>但是 pip 下载完，会出现 jupyter_contrib_nbextension 扩展功能后不显示 Nbextensions 标签的 bug，在此记录下解决的方式。</p><h2 id="三、扩展插件不显示的解决方法"><a href="#三、扩展插件不显示的解决方法" class="headerlink" title="三、扩展插件不显示的解决方法"></a>三、扩展插件不显示的解决方法</h2><ol><li>如果之前已经用上述两条命令之一安装了上述包，且用 pip list 查看的确成功安装，则依次进行下面删除命令（选 y）:<br><code>pip uninstall jupyter_contrib_nbextensions</code><br><code>pip uninstall jupyter_nbextensions_configurator</code></li><li>打开 Anaconda Prompt 窗口，执行第一个命令，用于安装 nbextensions:<br><code>pip install jupyter_contrib_nbextensions</code></li><li>再执行第下面命令，用于安装 javascript and css files:<br><code>jupyter contrib nbextension install --user</code></li><li>最后执行，用于安装 configurator:<br><code>pip install jupyter_nbextensions_configurator</code></li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.jiqizhixin.com/articles/2018-12-20-12">五个常用插件 - 简书</a></li><li><a href="https://www.zhihu.com/question/59392251/answer/560977151">如何优雅地使用 Jupyter？ - 量子位的回答 - 知乎</a></li><li><a href="https://blog.csdn.net/xiaodongxiexie/article/details/54633183">jupyter 使用技巧</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 🔨环境工具 </category>
          
          <category> 工具使用 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>配置java开发环境</title>
      <link href="/blog/cwqx6l/"/>
      <url>/blog/cwqx6l/</url>
      
        <content type="html"><![CDATA[<h2 id="一、下载"><a href="#一、下载" class="headerlink" title="一、下载"></a>一、下载</h2><p><a href="https://www.oracle.com/cn/java/technologies/javase-downloads.html">https://www.oracle.com/cn/java/technologies/javase-downloads.html</a></p><h2 id="二、环境变量配置"><a href="#二、环境变量配置" class="headerlink" title="二、环境变量配置"></a>二、环境变量配置</h2><p><strong>在系统变量下</strong></p><h3 id="CLASSPATH"><a href="#CLASSPATH" class="headerlink" title="CLASSPATH"></a>CLASSPATH</h3><blockquote><p>.;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar;%CATALINA_HOME%\common\lib\servlet-api.jar;</p></blockquote><p>其中<code>%CATALINA_HOME%\common\lib\servlet-api.jar;</code>为 tomcat 的加包配置</p><h3 id="JAVA-HOME"><a href="#JAVA-HOME" class="headerlink" title="JAVA_HOME"></a>JAVA_HOME</h3><blockquote><p>C:\Program Files\Java\jdk1.8.0_181</p></blockquote><h3 id="path"><a href="#path" class="headerlink" title="path"></a>path</h3><blockquote><p>%JAVA_HOME%\bin<br>%JAVA_HOME%\jre\bin</p></blockquote><h2 id="三、测试"><a href="#三、测试" class="headerlink" title="三、测试"></a>三、测试</h2><p>CMD 下输入<code>java -version</code></p>]]></content>
      
      
      <categories>
          
          <category> 🔨环境工具 </category>
          
          <category> 环境搭建 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Pycharm,Anaconda,JetBrains系列app相关总结</title>
      <link href="/blog/mv7tir/"/>
      <url>/blog/mv7tir/</url>
      
        <content type="html"><![CDATA[<h2 id="一、Anaconda-和-Pycharm-下载与配置"><a href="#一、Anaconda-和-Pycharm-下载与配置" class="headerlink" title="一、Anaconda 和 Pycharm 下载与配置"></a>一、Anaconda 和 Pycharm 下载与配置</h2><h3 id="下载-Anaconda-且配置"><a href="#下载-Anaconda-且配置" class="headerlink" title="下载 Anaconda 且配置"></a>下载 Anaconda 且配置</h3><ul><li>（更新）下载了 anaconda 就不要单独下载 python，之前下的也删掉，以此避免路径冲突</li><li>方式一：<strong>迅雷下载</strong>（推荐）；方式二：提取链接<strong>网盘下载</strong>；方式三：清华镜像下载，下载完安装【直接 next 即可】</li><li><strong>测试</strong>：<code>win + R</code> 进入终端输入<code>conda</code>出现 conda 命令使用指南，即证明成功安装</li><li><strong>配置环境变量</strong>：在<strong>系统变量</strong>path 路径中加入下面配置（具体路径具体填写）</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1606634508207-8eb4dda2-6dbe-4162-b7eb-93cc5b35dc0e.png#height=107&id=oIosg&margin=%5Bobject%20Object%5D&name=image.png&originHeight=169&originWidth=467&originalType=binary%E2%88%B6=1&size=7789&status=done&style=shadow&width=296" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1606634439956-bfa830a0-ece9-4caa-9bf7-641b14dafd70.png#height=41&id=v6rw7&margin=%5Bobject%20Object%5D&name=image.png&originHeight=81&originWidth=645&originalType=binary%E2%88%B6=1&size=5266&status=done&style=shadow&width=322.5" alt="image.png"></p><h3 id="下载-Pycharm-且配置"><a href="#下载-Pycharm-且配置" class="headerlink" title="下载 Pycharm 且配置"></a>下载 Pycharm 且配置</h3><ul><li><p><strong>下载版本</strong><a href="https://www.jetbrains.com/pycharm/download/">社区/专业</a>：专业版本需要激活码，社区版本功能基本能应付日常使用</p><blockquote><p>（大学学生时期可以用学生邮箱申请使用 JetBrains 系列软件，我的方法是先认证 GitHub 学生认证，然后直接从 GitHub 那边认证 JetBrains 软件的使用权，当然也可以直接用学生邮箱去 JetBrains 官网认证）</p></blockquote></li><li><p>**❗ 补充：取消上面用学生邮箱去申请 JetBrains 系列软件使用方法。先去 GitHub 申请学生包，然后通过 GitHub 已认证的 GitHub 账号再去申请 JetBrains 系列软件较为方便 **<a href="https://www.jetbrains.com/zh-cn/community/education/?_ga=2.186354217.1063699871.1594345232-1379189663.1590592761#students"><strong>JetBrains 申请链接 🔗</strong></a></p></li><li><p>Pycharm 使用 Anaconda 的配置 （ <strong>❗ 补充：下面貌似是社区版本的添加方式，但是专业版本会自动识别</strong> ）：</p></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685306285-e6ca8228-9234-4c7f-97f3-9d7fc26e0728.png#height=266&id=yAxpP&originHeight=1077&originWidth=1843&originalType=binary%E2%88%B6=1&size=0&status=done&style=shadow&width=456"></p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685306347-9a79eaf2-93cf-4ed4-b008-9e49aa66ad7e.png#height=324&id=bePXH&originHeight=885&originWidth=1227&originalType=binary%E2%88%B6=1&size=0&status=done&style=shadow&width=449"></p><h2 id="二、Anaconda-环境管理"><a href="#二、Anaconda-环境管理" class="headerlink" title="二、Anaconda 环境管理"></a>二、Anaconda 环境管理</h2><h3 id="pip-conda-Miniconda-Anaconda"><a href="#pip-conda-Miniconda-Anaconda" class="headerlink" title="pip,conda,Miniconda,Anaconda"></a>pip,conda,Miniconda,Anaconda</h3><ul><li>pip 包管理工具，python 官方认证</li><li>conda 是一种通用包管理系统，旨在构建和管理任何语言和任何类型的软件。包管理与 pip 的使用类似，环境管理则允许用户方便地安装不同版本的 python 并可以快速切换。</li><li>Anaconda 则是一个打包的集合，里面预装好了 conda、某个版本的 python、众多 packages、科学计算工具等等，就是把很多常用的不常用的库都给你装好了。同时利用配置/工具/命令 conda 来进行 package 和<strong>environment</strong>的管理。</li><li>Miniconda，它只包含最基本的内容——python 与 conda，以及相关的必须依赖项，对于空间要求严格的用户，Miniconda 是一种选择。就只包含最基本的东西，其他的库得自己装。</li></ul><blockquote><p>pip 下载/管理经常 bug，用 conda 结合 anaconda/miniconda 方便使用</p></blockquote><h3 id="Python-相关包路径的查看"><a href="#Python-相关包路径的查看" class="headerlink" title="Python 相关包路径的查看"></a>Python 相关包路径的查看</h3><ul><li><code>win+R</code>   输入<code>cmd</code>   输入<code>python</code> 输入<code>import sys</code> 输入<code>sys.path</code></li><li>标准库：anaconda 文件夹下的 lib 文件夹</li><li>第三方库：下述代码中的文件夹 <code>C:\Users\wztli\Anaconda3\Lib\site-packages</code></li></ul><h3 id="Sklearn-包安装失败总结"><a href="#Sklearn-包安装失败总结" class="headerlink" title="Sklearn 包安装失败总结"></a>Sklearn 包安装失败总结</h3><p>安装 scikit-learn 包，导入 sklearn 的 Bug</p><pre><code class="powershell">ImportError: DLL load failed: 找不到指定的模块</code></pre><p><code>scikit-learn</code>的下载会对 numpy、scipy、joblib 三个库相应版本有所要求，总之如果用 anaconda 的话，全部更新为最新即可（<a href="https://www.lfd.uci.edu/~gohlke/pythonlibs/">参考 whl 版本</a>）</p><blockquote><ul><li><code>C:\Users\wztli\Anaconda3\pkgs\scikit-learn-0.21.3-py37h6288b17_0\Lib\site-packages\sklearn\datasets\data</code></li><li>数据集在电脑中的位置</li></ul></blockquote><h3 id="Scrapy-包安装失败总结"><a href="#Scrapy-包安装失败总结" class="headerlink" title="Scrapy 包安装失败总结"></a>Scrapy 包安装失败总结</h3><ul><li>pip 下载可能会失败</li><li>使用 conda（镜像）下载<code>conda install -c scrapinghub scrapy</code></li></ul><h2 id="三、JetBrains-系列软件的高效使用"><a href="#三、JetBrains-系列软件的高效使用" class="headerlink" title="三、JetBrains 系列软件的高效使用"></a>三、JetBrains 系列软件的高效使用</h2><h3 id="JetBrains-之初始配置"><a href="#JetBrains-之初始配置" class="headerlink" title="JetBrains 之初始配置"></a>JetBrains 之初始配置</h3><blockquote><p>界面字体大小、代码字体大小、主题默认（dark）、背景图片（看心情）</p></blockquote><ul><li>字体相关<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685306645-d747b801-f817-475d-93e7-a9357a6f810b.png#height=284&id=vCu8H&originHeight=886&originWidth=1227&originalType=binary%E2%88%B6=1&size=0&status=done&style=none&width=393"></li><li>主题相关<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685306383-6425ce01-32e1-4216-b62e-def25d1e9dc7.png#height=287&id=GQ6ez&originHeight=886&originWidth=1227&originalType=binary%E2%88%B6=1&size=0&status=done&style=none&width=398"></li></ul><h3 id="JetBrains-之-Debug-断点调试"><a href="#JetBrains-之-Debug-断点调试" class="headerlink" title="JetBrains 之 Debug 断点调试"></a>JetBrains 之 Debug 断点调试</h3><blockquote><p>断点调试是优于打印输出的一种调试程序的一种手段（Pycharm 编辑器，其他系列软件也一样）</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685306462-78e560c3-6150-4b08-b806-34919a36f0a2.png#height=283&id=D1jlp&originHeight=397&originWidth=769&originalType=binary%E2%88%B6=1&size=0&status=done&style=shadow&width=548"></p><blockquote><ul><li>Ctrl+F5（左上角）：（return “project”）重新 debug 该文件</li><li>F9：（resume program）一个断点接着一个断点走，不按行走（eg：有循环会随着 i 一步一步走完）</li><li>F8：（step over） 一行一行走代码</li><li>F7：（step into） 进入函数内部</li><li>Alt+shift+F7：（step into mycode）遇到自己函数   进去</li><li>shift+F8：（step out）跳出，进入函数后，跳出来</li><li>Alt+F10：（show execution point）指针显示当前断点旁边</li><li><strong>Show Python Prompt</strong>按键<br>交互式调试命令</li></ul></blockquote><h3 id="JetBrains-之-GitHub-使用"><a href="#JetBrains-之-GitHub-使用" class="headerlink" title="JetBrains 之 GitHub 使用"></a>JetBrains 之 GitHub 使用</h3><ol><li>配置 Git 和 GitHub（先连接本地 git，然后登录 GitHub）<br>页面   依次点击<code>File</code> <code>Setting</code> <code>Version Control</code> <code>GitHub</code>然后登录账户进行配置</li><li>将项目新建在 GitHub<br>菜单栏 依次点击 <code>VCS</code> <code>Import into Version Control</code> <code>Share Project on GitHub</code></li><li><strong>将项目克隆在本地</strong> <code>VCS</code> <code>Get from Version Control</code></li></ol><h3 id="JetBrains-之-TODO-使用"><a href="#JetBrains-之-TODO-使用" class="headerlink" title="JetBrains 之 TODO 使用"></a>JetBrains 之 TODO 使用</h3><p>便于编写大型代码，将注释加上前缀以便分类处理，以下图片展示<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685306509-efc968a4-bf76-44f3-8347-52cbb5a7cc73.png#height=689&id=ztWN4&originHeight=689&originWidth=1890&originalType=binary%E2%88%B6=1&size=0&status=done&style=none&width=1890"></p><p>参考：</p><ul><li><a href="https://www.jetbrains.com/help/pycharm/using-todo.html">TODO 的使用官方文档</a></li><li><a href="https://blog.csdn.net/weixin_34277853/article/details/94205060?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-5&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-5">TODO 的用法</a></li></ul><h3 id="JetBrains-之插件枚举"><a href="#JetBrains-之插件枚举" class="headerlink" title="JetBrains 之插件枚举"></a>JetBrains 之插件枚举</h3><ul><li>Waka Time：持续记录自己的 IDE 以及编程语言的使用时长</li><li>leetcode editor：leetcode 刷题插件</li></ul><h3 id="JetBrains-之初用警告"><a href="#JetBrains-之初用警告" class="headerlink" title="JetBrains 之初用警告"></a>JetBrains 之初用警告</h3><p>一般下载完开始使用，IDE 会报一个 <code>Windows安全中心</code> 的警告</p><pre><code>Windows Defender might be impacting your build performance. PyCharm checked the following directorie</code></pre><p>解决：<img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685306961-bcb04392-e8c2-4f3a-a7f0-d2d1516afe70.png#height=700&id=ReCbv&originHeight=700&originWidth=1184&originalType=binary%E2%88%B6=1&size=0&status=done&style=none&width=1184"><br>然后再进入排除项添加报错的文件夹即可</p><h3 id="JetBrains-之-IDEA-的-leetcode-插件"><a href="#JetBrains-之-IDEA-的-leetcode-插件" class="headerlink" title="JetBrains 之 IDEA 的 leetcode 插件"></a>JetBrains 之 IDEA 的 leetcode 插件</h3><blockquote><p>记录一些配置</p></blockquote><ul><li>勾选 Custom Template 和 Plugin Update</li><li>TempFilePath</li></ul><pre><code>D:\project-java\datastructure\src\com\wztlink1013\problems</code></pre><ul><li>CodeFileName</li></ul><pre><code>P$&#123;question.frontendQuestionId&#125;$!velocityTool.camelCaseName($&#123;question.titleSlug&#125;)</code></pre><ul><li>CodeTemplate</li></ul><pre><code>package com.wztlink1013.problems.leetcode.editor.cn;$&#123;question.content&#125;public class P$&#123;question.frontendQuestionId&#125;$!velocityTool.camelCaseName($&#123;question.titleSlug&#125;)&#123;    public static void main(String[] args) &#123;        Solution solution = new P$&#123;question.frontendQuestionId&#125;$!velocityTool.camelCaseName($&#123;question.titleSlug&#125;)().new Solution();    &#125;$&#123;question.code&#125;&#125;</code></pre><p>参考：<br><a href="https://blog.csdn.net/yxf19034516/article/details/106087994/">IDEA 的 LeetCode 力扣插件设置与使用</a><br><a href="https://hacpai.com/article/1575547715310">IDEA 的 LeetCode 刷题插件 leetcode editor</a></p>]]></content>
      
      
      <categories>
          
          <category> 🔨环境工具 </category>
          
          <category> 工具使用 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Git使用Token连接</title>
      <link href="/blog/lg6q7n/"/>
      <url>/blog/lg6q7n/</url>
      
        <content type="html"><![CDATA[<h2 id="一、应用"><a href="#一、应用" class="headerlink" title="一、应用"></a>一、应用</h2><p>多个终端使用，而且没必要配置 SSH 连接的情况，可以使用 GitHub Token 来连接使用。还有就是使用 GitHub Actions 时候用 Token 情况较 SSH 方便。</p><p>不同的托管平台使用语法会有差异，在此记录下 GitHub、Coding、Gitee 的使用</p><h2 id="二、GitHub"><a href="#二、GitHub" class="headerlink" title="二、GitHub"></a>二、GitHub</h2><p>GitHub 生成一个 Token：***</p><p>使用 SSH 情况：<code>git clone [https://github.com/wztlink1013/blog3.0.git](https://github.com/wztlink1013/blog3.0.git)</code></p><p>使用 Token 情况：<code>[https://x-access-token:**************@github.com/wztlink1013/blog3.0.git](https://x-access-token:**************@github.com/wztlink1013/blog3.0.git)</code></p><h2 id="三、Coding"><a href="#三、Coding" class="headerlink" title="三、Coding"></a>三、Coding</h2><p>在个人设置中设置一个访问令牌</p><ul><li>令牌用户名：####</li><li>令牌 Token：*</li></ul><p>使用 SSH 情况：<code>[https://e.coding.net/wztlink1013/project/repo.git](https://e.coding.net/wztlink1013/project/repo.git)</code><br>使用令牌情况：<code>[https://####:***********@e.coding.net/wztlink1013/project/repo.git](https://####:***********@e.coding.net/wztlink1013/project/repo.git)</code></p><h2 id="四、Gitee"><a href="#四、Gitee" class="headerlink" title="四、Gitee"></a>四、Gitee</h2><p>头像设置中申请私人令牌：**</p><p>使用 SSH 情况：<code>[https://gitee.com/user/repo.git](https://gitee.com/user/repo.git)</code></p><p>使用 Token 情况：<code>[https://oauth2:**********@gitee.com/user/repo.git](https://oauth2:**********@gitee.com/user/repo.git)</code></p><h2 id="五、GitHub-Actions-中的使用"><a href="#五、GitHub-Actions-中的使用" class="headerlink" title="五、GitHub Actions 中的使用"></a>五、GitHub Actions 中的使用</h2><pre><code class="bash">Github_Pages:  github.com/wztlink1013/wztlink1013.github.ioGithub_Token:  $&#123;&#123;  secrets.token_GithubAPI  &#125;&#125;git  push  --force  --quiet  &quot;https://$&#123;Github_Token&#125;@$&#123;Github_Pages&#125;&quot;</code></pre><pre><code class="bash">Coding_Pages:  e.coding.net/wztlink1013/wztlink1013.gitCoding_Token:  $&#123;&#123;  secrets.token_CodingAPI  &#125;&#125;Coding_Username:  $&#123;&#123;  secrets.Username_Coding  &#125;&#125;git  push  --force  --quiet  &quot;https://$&#123;Coding_Username&#125;:$&#123;Coding_Token&#125;@$&#123;Coding_Pages&#125;&quot;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> Git+GitHub </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Eclipse的使用总结</title>
      <link href="/blog/at014v/"/>
      <url>/blog/at014v/</url>
      
        <content type="html"><![CDATA[<h2 id="一、Eclipse-的下载与安装"><a href="#一、Eclipse-的下载与安装" class="headerlink" title="一、Eclipse 的下载与安装"></a>一、Eclipse 的下载与安装</h2><p><a href="https://www.eclipse.org/downloads/">下载地址</a><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685180944-7ec7ebc3-8c39-44a7-9bec-85fded021a40.png#align=left&display=inline&height=441&margin=%5Bobject%20Object%5D&originHeight=441&originWidth=1817&size=0&status=done&style=none&width=1817"></p><p><strong>注意不要下错版本，不然开发不了 web 环境</strong><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685180923-a106c8c7-aebe-4f0a-bc06-d166bfc8894d.png#align=left&display=inline&height=758&margin=%5Bobject%20Object%5D&originHeight=758&originWidth=731&size=0&status=done&style=none&width=731"><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685180948-16e05303-0d11-454e-8bbd-71a11d7a3ef7.png#align=left&display=inline&height=763&margin=%5Bobject%20Object%5D&originHeight=763&originWidth=741&size=0&status=done&style=none&width=741"><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685180925-0262b0ea-f7af-493b-85a5-d8e7cbd12751.png#align=left&display=inline&height=373&margin=%5Bobject%20Object%5D&originHeight=373&originWidth=762&size=0&status=done&style=none&width=762"></p><h2 id="二、插件"><a href="#二、插件" class="headerlink" title="二、插件"></a>二、插件</h2><blockquote><p>进入：<code>Help Eclipse</code> <code>MarketPlace</code></p></blockquote><ul><li>Plugin1：Waka Time</li></ul><h2 id="三、使用"><a href="#三、使用" class="headerlink" title="三、使用"></a>三、使用</h2><h3 id="样式"><a href="#样式" class="headerlink" title="样式"></a>样式</h3><ul><li>字体设置</li><li>行数显示</li><li>更改工作空间的默认编码</li><li>代码增强显示，在设置中的<code>java</code>中的<code>content Assistant</code>中，将<code>.</code>改为<code>.ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789</code></li></ul><h3 id="导入已存在的项目"><a href="#导入已存在的项目" class="headerlink" title="导入已存在的项目"></a>导入已存在的项目</h3>]]></content>
      
      
      <categories>
          
          <category> 🔨环境工具 </category>
          
          <category> 工具使用 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Eclipse下载使用以及配置Tomcat创建Servlet</title>
      <link href="/blog/ro0lgm/"/>
      <url>/blog/ro0lgm/</url>
      
        <content type="html"><![CDATA[<h2 id="一、Eclipse-的下载与安装与使用"><a href="#一、Eclipse-的下载与安装与使用" class="headerlink" title="一、Eclipse 的下载与安装与使用"></a>一、Eclipse 的下载与安装与使用</h2><p><a href="https://www.eclipse.org/downloads/">下载地址</a><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685043597-84e5ed4c-8ad9-496b-997d-fd84136d0a86.png#align=left&display=inline&height=441&margin=%5Bobject%20Object%5D&originHeight=441&originWidth=1817&size=0&status=done&style=none&width=1817"></p><p><strong>注意不要下错版本，不然开发不了 web 环境</strong><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685043623-2432fa56-57df-4b19-bbcf-d7f803db63d3.png#align=left&display=inline&height=758&margin=%5Bobject%20Object%5D&originHeight=758&originWidth=731&size=0&status=done&style=none&width=731"><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685043608-ed00c908-2eb3-4a07-bcd4-c93a58aed494.png#align=left&display=inline&height=763&margin=%5Bobject%20Object%5D&originHeight=763&originWidth=741&size=0&status=done&style=none&width=741"><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685043479-aac1b3ff-f51d-4dce-8313-4e10d2e78bbb.png#align=left&display=inline&height=373&margin=%5Bobject%20Object%5D&originHeight=373&originWidth=762&size=0&status=done&style=none&width=762"></p><h2 id="二、Tomcat-的下载与配置"><a href="#二、Tomcat-的下载与配置" class="headerlink" title="二、Tomcat 的下载与配置"></a>二、Tomcat 的下载与配置</h2><p><a href="https://tomcat.apache.org/download-90.cgi">下载地址</a><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685043712-245a08a5-48cd-4446-ae4b-2ac442f09a44.png#align=left&display=inline&height=729&margin=%5Bobject%20Object%5D&originHeight=729&originWidth=1829&size=0&status=done&style=none&width=1829"><br><strong>一直下一步即可</strong><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685043478-1e8b6460-5b48-424e-8f2d-db26d6bbce42.png#align=left&display=inline&height=485&margin=%5Bobject%20Object%5D&originHeight=485&originWidth=623&size=0&status=done&style=none&width=623"><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685043417-e391db44-2cd9-4c7c-8e6b-1f131ab95769.png#align=left&display=inline&height=283&margin=%5Bobject%20Object%5D&originHeight=283&originWidth=624&size=0&status=done&style=none&width=624"></p><p>打开浏览器 键入 <a href="http://localhost:8080/">http://localhost:8080</a> 进入页面则表示安装成功</p><p>添加环境变量，以下全在系统环境变量下配置<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685043418-feddef63-fcb3-45ce-ac5a-33dd94d77655.png#align=left&display=inline&height=450&margin=%5Bobject%20Object%5D&originHeight=450&originWidth=1089&size=0&status=done&style=none&width=1089"><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685043499-20fddab9-abfb-4d0d-9c6d-956933ee59be.png#align=left&display=inline&height=24&margin=%5Bobject%20Object%5D&originHeight=24&originWidth=704&size=0&status=done&style=none&width=704"></p><pre><code>TOMCAT_HOME：C:\Program Files\Apache Software Foundation\Tomcat 9.0CATALINA_BASE：C:\Program Files\Apache Software Foundation\Tomcat 9.0;CATALINA_HOME：C:\Program Files\Apache Software Foundation\Tomcat 9.0;在classpath当中加入%CATALINA_HOME%\common\lib\servlet-api.jar;在path中加入%CATALINA_HOME%\bin;</code></pre><p>打开浏览器 键入 <a href="http://localhost:8080/">http://localhost:8080</a> 进入页面则表示配置成功</p><h2 id="三、Eclipse-配置-Tomcat"><a href="#三、Eclipse-配置-Tomcat" class="headerlink" title="三、Eclipse 配置 Tomcat"></a>三、Eclipse 配置 Tomcat</h2><p><strong>让 Tomcat 服务器显示在控制台上，将 Web 应用部署到 Tomcat 中</strong></p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685043589-c8022021-1185-4c41-b114-630856e16984.png#align=left&display=inline&height=350&margin=%5Bobject%20Object%5D&originHeight=350&originWidth=1837&size=0&status=done&style=none&width=1837"><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685043661-236843dd-f3ea-433e-b23a-254cc0a41c9b.png#align=left&display=inline&height=958&margin=%5Bobject%20Object%5D&originHeight=958&originWidth=1217&size=0&status=done&style=none&width=1217"><br>点击<code>Window</code> → <code>Show View</code> → <code>Servers</code> 也可以在控制台点击<code>Servers</code><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685043514-556e9b3f-1003-40ff-9066-70349be51101.png#align=left&display=inline&height=790&margin=%5Bobject%20Object%5D&originHeight=790&originWidth=1600&size=0&status=done&style=none&width=1600"><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685043568-aa8984a7-e9e9-4206-a922-f3386127191d.png#align=left&display=inline&height=597&margin=%5Bobject%20Object%5D&originHeight=597&originWidth=597&size=0&status=done&style=none&width=597"><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685043484-23195297-3636-47d7-bf44-ee0151382f87.png#align=left&display=inline&height=766&margin=%5Bobject%20Object%5D&originHeight=766&originWidth=1478&size=0&status=done&style=none&width=1478"><br><strong>双击点击</strong><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685043403-e34d7544-8144-4516-bb7c-53adbabac167.png#align=left&display=inline&height=290&margin=%5Bobject%20Object%5D&originHeight=290&originWidth=1375&size=0&status=done&style=none&width=1375"></p><h2 id="四、Eclipse-使用-Servlet"><a href="#四、Eclipse-使用-Servlet" class="headerlink" title="四、Eclipse 使用 Servlet"></a>四、Eclipse 使用 Servlet</h2><h3 id="创建-web-工程"><a href="#创建-web-工程" class="headerlink" title="创建 web 工程"></a>创建 web 工程</h3><p><strong>创建过程中，要记得勾选生成 web.xml 文件选项</strong><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685043545-0429f9cf-3910-4401-85da-08dd0118e9b1.png#align=left&display=inline&height=277&margin=%5Bobject%20Object%5D&originHeight=277&originWidth=1838&size=0&status=done&style=none&width=1838"><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685043538-d98f2569-40d6-4c3a-8111-9c3d6702052a.png#align=left&display=inline&height=382&margin=%5Bobject%20Object%5D&originHeight=382&originWidth=820&size=0&status=done&style=none&width=820"></p><h3 id="添加相关文件"><a href="#添加相关文件" class="headerlink" title="添加相关文件"></a>添加相关文件</h3><p><strong>添加下面的四个文件</strong><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685043712-c178c180-3c3a-44a2-9518-671033558337.png#align=left&display=inline&height=1015&margin=%5Bobject%20Object%5D&originHeight=1015&originWidth=1831&size=0&status=done&style=none&width=1831"></p><blockquote><p>HelloWordServlet.java</p></blockquote><pre><code class="java">package cn.itcast.firstmyapp.servlet;import java.io.IOException;import java.io.PrintWriter;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;public class HelloWordServlet extends HttpServlet &#123;     protected void doGet(HttpServletRequest req, HttpServletResponse resp)                throws ServletException, IOException &#123;         System.out.println(&quot;接受了客户端的请求----------------------------------------------------&quot;);         // 设置响应类型:            resp.setContentType(&quot;text/html&quot;);            // 获取输出流:            PrintWriter pw = resp.getWriter();            // 写入响应:            pw.write(&quot;&lt;h1&gt;Hello, world!&lt;/h1&gt;&quot;);            // 最后不要忘记flush强制输出:            pw.flush();        &#125;&#125;</code></pre><blockquote><p>web.xml<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685043517-5459e979-8525-4be9-8dab-d38f0857ef56.png#align=left&display=inline&height=627&margin=%5Bobject%20Object%5D&originHeight=627&originWidth=1178&size=0&status=done&style=none&width=1178"></p></blockquote><h3 id="运行并查看结果"><a href="#运行并查看结果" class="headerlink" title="运行并查看结果"></a>运行并查看结果</h3><p><strong>运行</strong><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685043718-5d90186b-8040-4098-b1d4-bb1f67740382.png#align=left&display=inline&height=761&margin=%5Bobject%20Object%5D&originHeight=761&originWidth=1434&size=0&status=done&style=none&width=1434"><br>然后查看 console 部分<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685043524-efeaf228-713b-43e1-ba15-375060ef20d2.png#align=left&display=inline&height=300&margin=%5Bobject%20Object%5D&originHeight=300&originWidth=1449&size=0&status=done&style=none&width=1449"><br><strong>服务器响应情况</strong></p><blockquote><p>出现下图则说明成功<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685043360-fd5bb570-f56a-429a-ad0e-627646447132.png#align=left&display=inline&height=190&margin=%5Bobject%20Object%5D&originHeight=190&originWidth=1318&size=0&status=done&style=none&width=1318"></p></blockquote><blockquote><p>还可以回到控制台查看请求成功情况<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685043568-b62922c0-c458-4c71-bd9c-800f57b356de.png#align=left&display=inline&height=322&margin=%5Bobject%20Object%5D&originHeight=322&originWidth=1445&size=0&status=done&style=none&width=1445"></p></blockquote><h2 id="五、过程中出现的问题"><a href="#五、过程中出现的问题" class="headerlink" title="五、过程中出现的问题"></a>五、过程中出现的问题</h2><h3 id="IDEA-上的部署"><a href="#IDEA-上的部署" class="headerlink" title="IDEA 上的部署"></a>IDEA 上的部署</h3><p>一开始从 tomcat 部署是完成的，具体参考我的 csdn 一篇小文章<a href="https://blog.csdn.net/ZTlink1013/article/details/104815639">地址</a>。但是在后面使用 Servlet 的时候，不能成功部署，具体原因【图片内容来自<a href="https://blog.csdn.net/HughGilbert/article/details/56424137">链接</a>！！】<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598685043902-5708dbdc-79d7-4e16-9e6d-d5571c5de758.png#align=left&display=inline&height=921&margin=%5Bobject%20Object%5D&originHeight=921&originWidth=941&size=0&status=done&style=stroke&width=941"></p><blockquote><p>暂时分析：是和 idea 下的根目录下的某个配置文件的默认配置有关，需要更改相关内容，暂时不折腾了。先记录下，有空再折腾，先学习。还是 eclipse 好配置···</p></blockquote><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="https://blog.csdn.net/weixin_34026276/article/details/93834823?depth_1-utm_source=distribute.pc_relevant.none-task&utm_source=distribute.pc_relevant.none-task">https://blog.csdn.net/weixin_34026276/article/details/93834823?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task</a></li><li><a href="https://blog.csdn.net/qq_38190185/article/details/88198794?depth_1-utm_source=distribute.pc_relevant.none-task&utm_source=distribute.pc_relevant.none-task">https://blog.csdn.net/qq_38190185/article/details/88198794?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task</a></li><li><a href="https://www.yiibai.com/servlet/creating-servlet-in-eclipse-ide.html">直接创建 Servlet</a></li><li>快捷键：<a href="https://www.open-open.com/bbs/view/1320934157953">https://www.open-open.com/bbs/view/1320934157953</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 🔨环境工具 </category>
          
          <category> 环境搭建 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>GitHub Actions使用之不同仓库文件夹迁移</title>
      <link href="/blog/qp5kuu/"/>
      <url>/blog/qp5kuu/</url>
      
        <content type="html"><![CDATA[<div style="background: #FFF3F3;padding:10px;border: 1px solid #DEB8BE;border-radius:5px;margin-bottom:5px;">弃用：繁琐新思路：走CDN回源</div><h2 id="一、思路"><a href="#一、思路" class="headerlink" title="一、思路"></a>一、思路</h2><ul><li>仓库一：wztlink1013.github.io【master】</li><li>仓库二：test【gh-pages】</li></ul><p><del>将 test 仓库下 gh-pages 分支下的所有文件复制到文件夹 test，在 wztlink1013.github.io 仓库下 clone 到文件夹 wztlink1013.github.io 中，进入 wztlink1013.github.io 文件夹，然后通过命令将 test 文件夹复制到 wztlink1013 文件夹中，最后 push 到 wztlink1013.github.io 仓库中。</del></p><h2 id="二、编写脚本"><a href="#二、编写脚本" class="headerlink" title="二、编写脚本"></a>二、编写脚本</h2><pre><code class="bash">git config --global user.name &#39;wztlink1013&#39;git config --global user.email &#39;wztlink1013@163.com&#39;git clone https://github.com/wztlink1013/test.gitgit clone https://github.com/wztlink1013/wztlink1013.github.io.git</code></pre><pre><code class="shell">cd wztlink1013.github.iomkdir testcd ..xcopy .\test .\wztlink1013.github.io /e</code></pre><pre><code class="bash">cd wztlink1013.github.iogit statusgit add .git commit -m &quot;add gh-pages files&quot;git push &quot;https://$&#123;Github_Token&#125;@github.com/wztlink1013/wztlink1013.github.io&quot;  master:master</code></pre><h2 id="三、编写-GitHub-Actions"><a href="#三、编写-GitHub-Actions" class="headerlink" title="三、编写 GitHub Actions"></a>三、编写 GitHub Actions</h2><pre><code class="yaml">name: CI for wztlink1013.github.ioon: [push, watch]jobs:  build:    runs-on: ubuntu-latest    steps:      - uses: actions/checkout@v2      - name: 配置Git        run: |          git config --global user.name &#39;wztlink1013&#39;           git config --global user.email &#39;wztlink1013@163.com&#39;      - name: 在云端进行复制文件夹操作        env:          Github_Token: $&#123;&#123; secrets.TOKEN_GITHUBAPI &#125;&#125;        run: |          git clone https://github.com/wztlink1013/visualization visualization          git clone https://github.com/wztlink1013/wztlink1013.github.io .github_pages          cd visualization          rm -r .git          rm -r .github          cd ..          cd .github_pages          rm -r visualization          cd ..          mv visualization/ -f .github_pages/          cd .github_pages          git status          git add .          git commit -m &quot;add gh-pages files&quot;          git push --force --quiet &quot;https://$&#123;Github_Token&#125;@github.com/wztlink1013/wztlink1013.github.io&quot;  master:master</code></pre>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> Git+GitHub </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>VScode 插件及环境配置总结等</title>
      <link href="/blog/pm7mpk/"/>
      <url>/blog/pm7mpk/</url>
      
        <content type="html"><![CDATA[<p>前言：本来我也不是插件重度用户，写项目觉得太累赘，然后在公司前端工作之后，嗯，真香……本文总结 vscode 的使用，并记录配置相关信息以便更换设备迁移配置，具体内容有：</p><ul><li>常用插件</li><li>代码校验（ESLint）和代码格式化（Prettier）的插件配置</li><li>vscode 配置 C++运行环境</li></ul><h2 id="DELETE-彻底删除-vscode-软件"><a href="#DELETE-彻底删除-vscode-软件" class="headerlink" title="DELETE: 彻底删除 vscode 软件"></a>DELETE: 彻底删除 vscode 软件</h2><p><strong>本着要学会如何配置环境，首先要学会如何彻底删除软件的原则（曾经的 javaweb 懂得都懂……），先介绍一下如何在本地设备彻底删除 vscode 软件。</strong><br><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1640403466550-8a3fb5fa-9fe5-4ba0-8ea9-80e773fd43f5.jpeg#crop=0&crop=0&crop=1&crop=1&height=114&id=nq92q&originHeight=56&originWidth=52&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&title=&width=105.99074172973633"><br>因为：vscode 如果更换电脑配置混乱（比如 vue 相关，既有 vetur 也有 ESLint 和 Prettier 会进行选择等），就删除软件，重新下载然后配置插件：</p><ul><li><code>win + r</code> 打开运行</li><li><code>%appdata%</code> 回车</li><li>删除 Code 和 Visual Studio Code 文件夹</li><li>地址栏输入 <code>%userprofile%</code> 回车</li><li>删除 <code>.vscode</code> 文件夹</li></ul><h2 id="一、VScode-插件使用"><a href="#一、VScode-插件使用" class="headerlink" title="一、VScode 插件使用"></a>一、VScode 插件使用</h2><h3 id="常用插件"><a href="#常用插件" class="headerlink" title="常用插件"></a>常用插件</h3><ul><li><input checked="" disabled="" type="checkbox"> Chinese (simplified)Language pack for Visual Code</li></ul><p>vscode 中文化</p><ul><li><input checked="" disabled="" type="checkbox"> vscode-icons</li></ul><p>美化图标</p><ul><li><input checked="" disabled="" type="checkbox"> Waka Time</li></ul><p>记录软件编写各类语言时间分配</p><ul><li><input checked="" disabled="" type="checkbox"> Todo Highlight</li></ul><p>优化 TODO：高亮</p><ul><li><input checked="" disabled="" type="checkbox"> Live Server</li></ul><p>运行 HTML</p><ul><li><input checked="" disabled="" type="checkbox"> Auto Import</li></ul><p>自动导入包（组件）<br>第一次用到该组件（包）时是不会有自动导入提示的，在另一个文件第二次用时就会有自动导入提示了</p><ul><li><input checked="" disabled="" type="checkbox"> Color Highlight</li></ul><p>代码中有颜色的地方会高亮<br>文件中找到的 css/web 颜色，所以你无需打开页面就能看到它们是什么颜色。</p><ul><li><input checked="" disabled="" type="checkbox"> HTML CSS Support</li></ul><p>让 html 标签上写 class 智能提示当前项目所支持的样式</p><ul><li><input checked="" disabled="" type="checkbox"> IntelliSense for CSS class names in HTML</li><li><input checked="" disabled="" type="checkbox"> JavaScript (ES6) code snippets</li></ul><p>ES6 语法智能提示以及快速输入，除 js 外还支持.ts，.jsx，.tsx，.html，.vue，省去了配置其支持各种包含 js 代码文件的时间</p><ul><li><input checked="" disabled="" type="checkbox"> koroFileHeader</li></ul><p>生成文件头注释<br>配置参考：<a href="https://github.com/OBKoro1/koro1FileHeader">https://github.com/OBKoro1/koro1FileHeader</a></p><pre><code class="json">// 头部注释&quot;fileheader.customMade&quot;: &#123;  // 头部注释默认字段  &quot;Author&quot;: &quot;wztlink1013&quot;,  &quot;Date&quot;: &quot;Do not edit&quot;, // 设置后默认设置文件生成时间  &quot;LastEditTime&quot;: &quot;Do not edit&quot;, // 设置后，保存文件更改默认更新最后编辑时间  &quot;Description&quot;: &quot;&quot;&#125;,// 函数注释&quot;fileheader.cursorMode&quot;: &#123;  // 默认字段  &quot;description&quot;:&quot;&quot;,  &quot;param&quot;:&quot;&quot;,  &quot;return&quot;:&quot;&quot;&#125;,</code></pre><ul><li><input checked="" disabled="" type="checkbox"> Nuxt Typescript Snippets</li><li><input checked="" disabled="" type="checkbox"> Path Autocomplete</li></ul><p>会有路径提示</p><ul><li><input checked="" disabled="" type="checkbox"> Path Intellisense</li></ul><p>自动路径补全</p><ul><li><input checked="" disabled="" type="checkbox"> Reactjs code snippets</li><li><input checked="" disabled="" type="checkbox"> Vetur</li></ul><p>VSCode 里安装 Vetur 可以将“.vue”文件中的语法进行高亮显示，Vetur 不仅支持 Vue 中的 template 模板以外，还支持大多数主流的前端开发脚本和插件，比如 Sass、TypeScript、Jade 和 Less 等等。</p><ul><li><input checked="" disabled="" type="checkbox"> vue</li><li><input checked="" disabled="" type="checkbox"> Vue 3 Snippets</li><li><input checked="" disabled="" type="checkbox"> Vue VSCode Snippets</li><li><input checked="" disabled="" type="checkbox"> Auto Close Tag</li></ul><p>自动闭合 HTML/XML 标签</p><ul><li><input checked="" disabled="" type="checkbox"> Auto Rename Tag</li></ul><p>自动关闭 Html 标签，输入起始标签后会自动变换尾部标签。</p><ul><li><input checked="" disabled="" type="checkbox"> background</li></ul><p>背景图片的设置</p><ul><li><input disabled="" type="checkbox"> DotENV【添加 env 环境变量参数】</li></ul><p>参考：<a href="https://blog.csdn.net/hbiao68/article/details/105205112">https://blog.csdn.net/hbiao68/article/details/105205112</a></p><ul><li><input disabled="" type="checkbox"> CodeRunner【编写 C/C++】</li><li><input disabled="" type="checkbox"> C/C++【编写 C/C++】</li><li><input disabled="" type="checkbox"> Todo Tree【优化 TODO：侧边栏】</li><li><input disabled="" type="checkbox"> language-stylus【hexo 博客】</li><li><input disabled="" type="checkbox"> Markdown Preview Github Styling【Markdown】</li><li><input disabled="" type="checkbox"> Markdown All in One【Markdown】</li><li><input disabled="" type="checkbox"> GitLens 【显示当前行 commit 信息，管理 git】</li><li><input disabled="" type="checkbox"> Git History 【查看 commit 信息】</li><li><input disabled="" type="checkbox"> Bracket Pair Colorrizer 2 【优化大括号】</li></ul><p>vscode 可以自定义 markdown 预览样式，css 文件以外链的方式放上</p><h2 id="二、集成-ESLint-和-Prettier-代码校验格式化环境"><a href="#二、集成-ESLint-和-Prettier-代码校验格式化环境" class="headerlink" title="二、集成 ESLint 和 Prettier 代码校验格式化环境"></a>二、集成 ESLint 和 Prettier 代码校验格式化环境</h2><ul><li><input checked="" disabled="" type="checkbox"> Prettier - Code formatter</li></ul><p>代码格式化插件：按照所需配置直接格式化代码</p><ul><li><input checked="" disabled="" type="checkbox"> ESLint</li></ul><p>格式化检测工具：会给出警告抑或是报错，但不会修改</p><h3 id="eslint-plugin-html"><a href="#eslint-plugin-html" class="headerlink" title="eslint-plugin-html"></a>eslint-plugin-html</h3><p>目的是为了检测 html 文件中的 js 代码，全局下载，让设备非 node 项目也能使用</p><pre><code class="bash">npm install -g eslint-plugin-html</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1640400558364-b89c0585-1302-4515-b27a-bdb053cf8701.png#clientId=uf4909dba-f5dd-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=257&id=uc4ceedb9&margin=%5Bobject%20Object%5D&name=image.png&originHeight=514&originWidth=1656&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=70743&status=done&style=none&taskId=ue72c1dbf-e39a-418c-b15f-4b99cab5bf2&title=&width=828" alt="image.png"><br>每次打开 html，eslint 就会报错：</p><pre><code>&#39;plugins&#39; doesn&#39;t add plugins to configuration to load. Please use the &#39;overrideConfig.plugins&#39; option instead.</code></pre><p>官网 issues <a href="https://github.com/microsoft/vscode-eslint/issues/1376">https://github.com/microsoft/vscode-eslint/issues/1376</a> 中貌似也并未给出根治方法，暂时禁用：<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1640401735422-2e618454-6752-4b2e-9020-8788d0ad114d.png#clientId=uf4909dba-f5dd-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=167&id=u7b0c7db1&margin=%5Bobject%20Object%5D&name=image.png&originHeight=333&originWidth=730&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=26497&status=done&style=none&taskId=u9c36aabe-d5cf-47bf-b227-a36925ba99f&title=&width=365" alt="image.png"></p><h2 id="三、VScode-配置-C-C-环境"><a href="#三、VScode-配置-C-C-环境" class="headerlink" title="三、VScode 配置 C/C++环境"></a>三、VScode 配置 C/C++环境</h2><h3 id="下载编译器"><a href="#下载编译器" class="headerlink" title="下载编译器"></a>下载编译器</h3><blockquote><p>下载地址：<a href="https://sourceforge.net/projects/mingw-w64/files/">https://sourceforge.net/projects/mingw-w64/files/</a></p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1624949859317-61aab22e-74c9-4210-9c4b-f192c9af76ea.png#clientId=ua287ede7-a77a-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=145&id=u0f6c1ee7&margin=%5Bobject%20Object%5D&name=image.png&originHeight=290&originWidth=1911&originalType=binary%E2%88%B6=2&rotation=0&showTitle=false&size=36082&status=done&style=stroke&taskId=u6c7ef924-cb1d-47b3-b425-93a66e026c7&title=&width=955.5" alt="image.png"></p><blockquote><p>配置环境</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1624949943592-2695ea6b-4237-4a26-8d5b-c39a2c2ff920.png#clientId=ua287ede7-a77a-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=296&id=u901eeafb&margin=%5Bobject%20Object%5D&name=image.png&originHeight=592&originWidth=970&originalType=binary%E2%88%B6=2&rotation=0&showTitle=false&size=59404&status=done&style=none&taskId=u7e7db4ac-4910-46b9-8de3-5243c003915&title=&width=485" alt="image.png"><br>检查是否配置成功<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1624949993088-16f38896-e62c-4347-8e3e-d4ac0e5c4273.png#clientId=ua287ede7-a77a-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=360&id=u842c5c50&margin=%5Bobject%20Object%5D&name=image.png&originHeight=720&originWidth=1440&originalType=binary%E2%88%B6=2&rotation=0&showTitle=false&size=178894&status=done&style=none&taskId=uf6dc2199-051d-4307-90cb-b7cf37e1129&title=&width=720" alt="image.png"></p><h3 id="下载插件"><a href="#下载插件" class="headerlink" title="下载插件"></a>下载插件</h3><p>在 vscode 中下载如下两个插件</p><ul><li><input checked="" disabled="" type="checkbox"> CodeRunner</li><li><input checked="" disabled="" type="checkbox"> C/C++</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1624948996187-240d18a3-446f-4381-a685-e9a2a7af5d91.png#clientId=ua287ede7-a77a-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=173&id=ubffcb48a&margin=%5Bobject%20Object%5D&name=image.png&originHeight=345&originWidth=279&originalType=binary%E2%88%B6=2&rotation=0&showTitle=false&size=19757&status=done&style=none&taskId=u4925b98e-dacc-467a-9310-2d03d9b4e78&title=&width=139.5" alt="image.png"></p><h3 id="项目-vscode-配置"><a href="#项目-vscode-配置" class="headerlink" title="项目.vscode 配置"></a>项目.vscode 配置</h3><p>建立一个 <code>.vscode</code>  文件夹，然后在里面新建下面三个文件即可。</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1624949162500-fc5ebdeb-2c45-49d6-afb0-badec740d502.png#clientId=ua287ede7-a77a-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=168&id=ue1af6290&margin=%5Bobject%20Object%5D&name=image.png&originHeight=335&originWidth=334&originalType=binary%E2%88%B6=2&rotation=0&showTitle=false&size=22451&status=done&style=none&taskId=ud945aafd-c609-410f-a6ff-04c806979ea&title=&width=167" alt="image.png"></p><div style="background: #FFF3F3;padding:10px;border: 1px solid #DEB8BE;border-radius:5px;margin-bottom:5px;">注意：以后只有该配置文件夹的文件夹才能编写C/C++代码</div><h4 id="launch-json"><a href="#launch-json" class="headerlink" title="launch.json"></a>launch.json</h4><pre><code class="json">&#123;  &quot;version&quot;: &quot;0.2.0&quot;,  &quot;configurations&quot;: [    &#123;      &quot;name&quot;: &quot;(gdb) Launch&quot;,      &quot;type&quot;: &quot;cppdbg&quot;,      &quot;request&quot;: &quot;launch&quot;,      &quot;program&quot;: &quot;$&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;.exe&quot;,      &quot;args&quot;: [],      &quot;stopAtEntry&quot;: false,      &quot;cwd&quot;: &quot;$&#123;workspaceFolder&#125;&quot;,      &quot;environment&quot;: [],      &quot;externalConsole&quot;: true,      &quot;internalConsoleOptions&quot;: &quot;neverOpen&quot;,      &quot;MIMode&quot;: &quot;gdb&quot;,      &quot;miDebuggerPath&quot;: &quot;gdb.exe&quot;,      &quot;setupCommands&quot;: [        &#123;          &quot;description&quot;: &quot;Enable pretty-printing for gdb&quot;,          &quot;text&quot;: &quot;-enable-pretty-printing&quot;,          &quot;ignoreFailures&quot;: false        &#125;      ],      &quot;preLaunchTask&quot;: &quot;Compile&quot;    &#125;  ]&#125;</code></pre><h4 id="settings-json"><a href="#settings-json" class="headerlink" title="settings.json"></a>settings.json</h4><pre><code class="json">&#123;  &quot;files.defaultLanguage&quot;: &quot;c&quot;,  &quot;editor.formatOnType&quot;: true,  &quot;editor.suggest.snippetsPreventQuickSuggestions&quot;: false,  &quot;editor.acceptSuggestionOnEnter&quot;: &quot;off&quot;,  &quot;code-runner.runInTerminal&quot;: true,  &quot;code-runner.executorMap&quot;: &#123;    &quot;c&quot;: &quot;gcc &#39;$fileName&#39; -o &#39;$fileNameWithoutExt.exe&#39; -Wall -O2 -m64 -lm -static-libgcc -std=c11 -fexec-charset=GBK &amp;&amp; &amp;&#39;./$fileNameWithoutExt.exe&#39;&quot;,    &quot;cpp&quot;: &quot;g++ &#39;$fileName&#39; -o &#39;$fileNameWithoutExt.exe&#39; -Wall -O2 -m64 -static-libgcc -std=c++14 -fexec-charset=GBK &amp;&amp; &amp;&#39;./$fileNameWithoutExt.exe&#39;&quot;  &#125;,  &quot;code-runner.saveFileBeforeRun&quot;: true,  &quot;code-runner.preserveFocus&quot;: true,  &quot;code-runner.clearPreviousOutput&quot;: false,  &quot;code-runner.ignoreSelection&quot;: true,  &quot;code-runner.fileDirectoryAsCwd&quot;: true,  &quot;C_Cpp.clang_format_sortIncludes&quot;: true&#125;</code></pre><h4 id="tasks-json"><a href="#tasks-json" class="headerlink" title="tasks.json"></a>tasks.json</h4><pre><code class="json">&#123;  &quot;version&quot;: &quot;2.0.0&quot;,  &quot;tasks&quot;: [    &#123;      &quot;label&quot;: &quot;Compile&quot;,      &quot;command&quot;: &quot;gcc&quot;,      &quot;args&quot;: [        &quot;$&#123;file&#125;&quot;,        &quot;-o&quot;,        &quot;$&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;.exe&quot;,        &quot;-g&quot;,        &quot;-m64&quot;,        &quot;-Wall&quot;,        &quot;-static-libgcc&quot;,        &quot;-fexec-charset=GBK&quot;      ],      &quot;type&quot;: &quot;process&quot;,      &quot;group&quot;: &#123;        &quot;kind&quot;: &quot;build&quot;,        &quot;isDefault&quot;: true      &#125;,      &quot;presentation&quot;: &#123;        &quot;echo&quot;: true,        &quot;reveal&quot;: &quot;always&quot;,        &quot;focus&quot;: false,        &quot;panel&quot;: &quot;shared&quot;      &#125;,      &quot;problemMatcher&quot;: &quot;$gcc&quot;    &#125;  ]&#125;</code></pre><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="https://www.zhihu.com/question/30315894">Visual Studio Code 如何编写运行 C、C++ 程序？</a></li><li><a href="https://segmentfault.com/a/1190000006697219">vscode 插件推荐 - 献给所有前端工程师（2019.10.12 更新）</a></li><li><a href="https://blog.csdn.net/TriDiamond6/article/details/105604427?utm_source=app">VSCode 插件大全｜ VSCode 高级玩家之第二篇</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 🔨环境工具 </category>
          
          <category> 工具使用 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>电脑重装win10系统以及重装后的软件下载</title>
      <link href="/blog/qq1dno/"/>
      <url>/blog/qq1dno/</url>
      
        <content type="html"><![CDATA[<p>前言：个人重装系统的缘由有如下几个原因：</p><ul><li>环境配置混乱</li><li>网卡驱动出错（一次电脑莫名的出错）</li><li>电脑的空间太杂乱</li></ul><p>同时，重装系统能解决电脑带来的大部分问题，所以在此记录一下重装的各类方法、操作流程、以及重装之后的电脑所需要下载的软件总结。</p><h2 id="一、重装系统流程"><a href="#一、重装系统流程" class="headerlink" title="一、重装系统流程"></a>一、重装系统流程</h2><p>重装系统有很多种方法：传统的 U 盘下载镜像重装，win10 的重置电脑功能，三方软件的一键重装，但是个人而言，所有的方法都没有 U 盘方法“干净”，比如 win10 的重置功能会保留一些文件在重装后的电脑中，导致占内存，三方软件一般都会捆绑三方软件在你的重装之后电脑中，<strong>所以推荐使用 U 盘下载镜像的方法</strong>。</p><h3 id="镜像的下载与启动盘的制作"><a href="#镜像的下载与启动盘的制作" class="headerlink" title="镜像的下载与启动盘的制作"></a>镜像的下载与启动盘的制作</h3><ul><li><a href="https://msdn.itellyou.cn/">方法一：MSDN 下载镜像</a></li></ul><p>① 迅雷下载  ② 网盘下载。下载完镜像之后，再用 ULtralSO/ <a href="https://rufus.ie/zh_CN.html">rufus</a> 软件刻录在 U 盘（大于 4G 的 U 盘）</p><ul><li><a href="https://www.microsoft.com/zh-cn/software-download/windows10">方法二：微软官方下载镜像</a></li></ul><p>网速不能太慢，WiFi 较快的可以用这个，不过下载的电脑原装 Windows 版本，不追求专业版本的 Windows，最好还是下这个。</p><blockquote><p>坑 1：如果下载的镜像大于 4G 左右，ULtralSO 不能刻录。<br>亮 2：官方下载，可以匹配自己电脑本来的版本；可以直接刻录在 U 盘，唯一不足应该就是网速问题。<br>坑 3：U 盘如果“身患重伤”，下个相关优化 U 盘软件处理一下</p></blockquote><h3 id="正式重装步骤"><a href="#正式重装步骤" class="headerlink" title="正式重装步骤"></a>正式重装步骤</h3><p><strong>未配图，下次重装一定</strong><img src="https://cdn.nlark.com/yuque/0/2022/gif/1484158/1644205174244-93671f35-36d0-4aae-8318-780a20970f83.gif#crop=0&crop=0&crop=1&crop=1&id=GViLZ&originHeight=45&originWidth=45&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&status=done&style=none&title="></p><ul><li>进入 bios 界面</li></ul><p>如何进入 bios 界面：开机刚要出现<code>HP</code>字样，一直点<code>_esc_</code>键，然后再设置开机进入启动盘<br>（不同电脑，不同进入方式，网上搜一下就可以了）</p><ul><li>Next Wait 即可<br>格式化 C 盘 → 安装 → 等候 → 登录微软账号…</li></ul><h3 id="关于磁盘管理"><a href="#关于磁盘管理" class="headerlink" title="关于磁盘管理"></a>关于磁盘管理</h3><ul><li>重装系统的安装，一般是安装到 C 盘，也就是系统盘</li><li>重装完成之后，根据需求也可以人为将磁盘分区</li></ul><blockquote><p>相关问题 1：给 C 盘扩展时不能扩展？<br>磁盘只有相邻卷才能扩展卷：解决办法就是把右边的磁盘删除（状态为未分配空间），然后用左边的磁盘合并之（使用扩展卷）</p></blockquote><h3 id="关于破解"><a href="#关于破解" class="headerlink" title="关于破解"></a>关于破解</h3><ul><li>有条件购买支持正版，支持同行</li><li>下载自己笔记本出厂 Windows 版本，则不需要激活码，自带</li><li>最后使用：HWIDGen 激活工具 pojie 之</li></ul><h2 id="二、电脑备份相关工作"><a href="#二、电脑备份相关工作" class="headerlink" title="二、电脑备份相关工作"></a>二、电脑备份相关工作</h2><h3 id="上网与浏览器"><a href="#上网与浏览器" class="headerlink" title="上网与浏览器"></a>上网与浏览器</h3><ul><li><p><input checked="" disabled="" type="checkbox">  kxsw： <a href="https://console.bywa.art/aff.php?aff=3215">ByWave</a></p><blockquote><p>Clash for Windows</p></blockquote></li><li><p><input checked="" disabled="" type="checkbox">  谷歌浏览器：<a href="https://www.google.com/intl/zh-CN/chrome/">由 Google 打造的浏览器 适用于 Windows 11/10/8.1/8/7 64 位</a></p><blockquote><p>登录谷歌账号同步书签插件等设置</p></blockquote></li><li><p><a href="https://authy.com/download/">Authy Desktop（二重验证）</a></p></li><li><p><input disabled="" type="checkbox">  IDM 下载器</p></li></ul><h3 id="文件备份及恢复"><a href="#文件备份及恢复" class="headerlink" title="文件备份及恢复"></a>文件备份及恢复</h3><ul><li><p><input checked="" disabled="" type="checkbox">  百度网盘</p><blockquote><p>workspaces 同步文件夹</p></blockquote></li><li><p><input checked="" disabled="" type="checkbox">  阿里云盘</p></li><li><p><a href="https://github.com/wztlink1013">**GitHub **</a>同步开发项目代码</p></li></ul><h3 id="开发"><a href="#开发" class="headerlink" title="开发"></a>开发</h3><h4 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h4><ul><li><p><input checked="" disabled="" type="checkbox">  Git（全局用户）：<a href="https://www.wztlink1013.com/blog/fnsge3/">Git 常见使用+多账号同设备部署总结 | 尼采般地抒情</a></p></li><li><p><input checked="" disabled="" type="checkbox">  Nodejs：<a href="https://www.wztlink1013.com/blog/yo1xhz/">Hexo+GitHub Pages 搭建个人静态网站 | 尼采般地抒情</a></p><blockquote><p>使用 nvm 管理 Node.js 版本（<a href="https://www.yuque.com/wztlink1013/lyrics/orml31">https://www.yuque.com/wztlink1013/lyrics/orml31</a>）</p></blockquote></li><li><p><input checked="" disabled="" type="checkbox">  Java（jdkjdk1.8.0_181，jrejdk1.8.0_181）：<a href="https://www.wztlink1013.com/blog/cwqx6l/">配置 java 开发环境 | 尼采般地抒情</a></p></li><li><p><input checked="" disabled="" type="checkbox">  ffmpeg</p></li><li><p><input disabled="" type="checkbox">  MySQL</p></li><li><p><input disabled="" type="checkbox">  MongoDB</p></li><li><p><input disabled="" type="checkbox">  Unix：VMware15，Windows 子系统（开发三剑客）</p></li></ul><h4 id="开发工具"><a href="#开发工具" class="headerlink" title="开发工具"></a>开发工具</h4><ul><li><input checked="" disabled="" type="checkbox"> Web：<a href="https://code.visualstudio.com/download">vscode</a></li><li><input checked="" disabled="" type="checkbox"> C&amp;C++：<a href="https://www.wztlink1013.com/blog/pm7mpk/">VScode（搭配 C/C++开发插件使用）</a><del>、Clion、Codeblocks(次选)、VS2019(PC 空间大则优选)、VS2013</del></li><li><input disabled="" type="checkbox"> Python：Anaconda、Pycharm(<del>配置 nltk、tensorflow 等</del>)(<del>关于破解或</del> <strong>学生用户登录</strong>)</li><li><input disabled="" type="checkbox"> Java/JavaWeb：IDEA、IDEA/Eclipse(配置 Tomcat)</li><li><input disabled="" type="checkbox"> DataBase：<a href="https://www.microsoft.com/zh-cn/download/confirmation.aspx?id=30438"><del>SQL Server 2008</del></a>~~ 和 <del>[</del>安装教程<del>](<a href="https://zhuanlan.zhihu.com/p/65630194">https://zhuanlan.zhihu.com/p/65630194</a>)</del> ~~、 Navicat Premium 15</li><li><input disabled="" type="checkbox"> Android：Android Studio、HBuilder X、微信开发者工具</li><li><input disabled="" type="checkbox"> OS：CPU Simulator</li><li><input disabled="" type="checkbox"> Matlab</li><li><input disabled="" type="checkbox"> 研究-CAJViewer 7.3</li><li><input disabled="" type="checkbox"> 研究-AxMath</li><li><input disabled="" type="checkbox"> 研究-AxGlyph</li><li><input disabled="" type="checkbox"> 服务器</li><li><input disabled="" type="checkbox"> FinalShell</li><li><input disabled="" type="checkbox"> FileZilla Client（云服务器、云虚拟主机）</li><li><input checked="" disabled="" type="checkbox"> 前端</li><li><input checked="" disabled="" type="checkbox"> Postman</li><li><input checked="" disabled="" type="checkbox"> vscode</li><li><input checked="" disabled="" type="checkbox"> Charles（抓包工具）</li><li><input checked="" disabled="" type="checkbox"> 谷歌、火狐、PS</li></ul><h3 id="通用软件"><a href="#通用软件" class="headerlink" title="通用软件"></a>通用软件</h3><ul><li><input checked="" disabled="" type="checkbox"> Bandizip</li><li><input checked="" disabled="" type="checkbox"> Adobe Acrobat DC</li><li><input checked="" disabled="" type="checkbox"> Potplayer</li><li><input checked="" disabled="" type="checkbox"> QQ、微信、网易邮箱大师、网易云、酷狗</li><li><input checked="" disabled="" type="checkbox"> <a href="https://www.snipaste.com/download.html">Snipaste</a></li></ul><h4 id="后期制作"><a href="#后期制作" class="headerlink" title="后期制作"></a>后期制作</h4><ul><li><input disabled="" type="checkbox"> Ps</li><li><input disabled="" type="checkbox"> Pr、Ae</li><li><input disabled="" type="checkbox"> An、Au、EV 录频、Format factory 格式转换工厂</li></ul><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><ul><li><input disabled="" type="checkbox"> <a href="https://www.yuque.com/install/desktop">语雀桌面客户端</a></li><li><input disabled="" type="checkbox"> 火萤桌面视频</li><li><input disabled="" type="checkbox"> Rainmeter</li><li><input disabled="" type="checkbox"> <a href="https://github.com/Molunerfinn/PicGo">PicGo</a></li><li><input disabled="" type="checkbox"> steam</li><li><input disabled="" type="checkbox"> qq 飞车</li><li><input disabled="" type="checkbox"> Visio</li></ul>]]></content>
      
      
      <categories>
          
          <category> 🔨环境工具 </category>
          
          <category> 环境搭建 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>时间格式UTC、GMT、GST</title>
      <link href="/blog/delag2/"/>
      <url>/blog/delag2/</url>
      
        <content type="html"><![CDATA[<h2 id="一、三者区别与关系"><a href="#一、三者区别与关系" class="headerlink" title="一、三者区别与关系"></a>一、三者区别与关系</h2><h3 id="UTC：世界标准时间"><a href="#UTC：世界标准时间" class="headerlink" title="UTC：世界标准时间"></a><strong>UTC：世界标准时间</strong></h3><p>协调世界时（英：Coordinated Universal Time ，法：Temps Universel Coordonné），又称世界统一时间，世界标准时间，国际协调时间。英文（CUT）和法文（TUC）的缩写不同，作为妥协，简称 UTC。</p><h3 id="GMT：格林尼治时间"><a href="#GMT：格林尼治时间" class="headerlink" title="GMT：格林尼治时间"></a><strong>GMT：格林尼治时间</strong></h3><p>世界时 UT   即格林尼治时间，格林尼治所在地的标准时间。以地球自转为基础的时间计量系统。地球自转的角度可用地方子午线相对于地球上的基本参考点的运动来度量。为了测量地球自转，人们在地球上选取了两个基本参考点：春分点（见分至点）和平太阳，由此确定的时间分别称为恒星时和平太阳时。</p><h3 id="GST：北京时间"><a href="#GST：北京时间" class="headerlink" title="GST：北京时间"></a><strong>GST：北京时间</strong></h3><p>在数据库中存放，或者给用户看的时间都是 GST 时间</p><h3 id="UTC-和-GST"><a href="#UTC-和-GST" class="headerlink" title="UTC 和 GST"></a><strong>UTC 和 GST</strong></h3><p>中国北京市的时间比 UTC<strong>早</strong> 8 小时</p><h2 id="二、UTC-与-GST-之间的转换"><a href="#二、UTC-与-GST-之间的转换" class="headerlink" title="二、UTC 与 GST 之间的转换"></a><strong>二、UTC 与 GST 之间的转换</strong></h2><h3 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h3><blockquote><p>2020-05-23T01:12:19.602Z</p></blockquote><ul><li>T：他表示后面跟的时间</li><li>Z：表示 UTC 统一时间</li><li>602：表示毫秒，如果为 6020，最后得到的时间，秒会增加 1 秒。000Z 意思就是 0 毫秒  utc 统一时间</li></ul><h3 id="java-实现"><a href="#java-实现" class="headerlink" title="java 实现"></a>java 实现</h3><pre><code class="java">package website;import java.text.*;import java.util.Date;public class UTC_GST &#123;    public static void main(String[] args) throws ParseException &#123;        String date = &quot;2020-05-23T20:12:19.602Z&quot;;        date = date.replace(&quot;Z&quot;, &quot; UTC&quot;);        System.out.println(&quot;输入的UTC格式数据为：&quot;+date);        SimpleDateFormat format = new SimpleDateFormat(&quot;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSS Z&quot;);        Date d = format.parse(date);        System.out.println(&quot;输出的背景格式数据为：&quot;+d);    &#125;&#125;</code></pre><pre><code class="java">输入的UTC格式数据为：2020-05-23T20:12:19.602 UTC输出的背景格式数据为：Sun May 24 04:12:19 CST 2020</code></pre><pre><code class="java">package website;import java.text.SimpleDateFormat;import java.util.Date;public class Format &#123;    public static void main(String[] args) &#123;        Date ss = new Date();        System.out.println(&quot;一般日期输出：&quot; + ss);        System.out.println(&quot;toString日期输出：&quot; + ss.toString());        System.out.println(&quot;时间戳：&quot; + ss.getTime()+&quot;\n&quot;); // getTime返回的是1970年1月1号至今流逝的时间        //Date aw = Calendar.getInstance().getTime();//获得时间的另一种方式，测试效果一样        SimpleDateFormat format0 = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);        String time = format0.format(ss.getTime());//这个就是把时间戳经过处理得到期望格式的时间        System.out.println(&quot;格式化结果0：&quot; + time + &quot;\n&quot;);        SimpleDateFormat format1 = new SimpleDateFormat(&quot;yyyy年MM月dd日 HH时mm分ss秒&quot;);        time = format1.format(ss.getTime());        System.out.println(&quot;格式化结果1：&quot; + time + &quot;\n&quot;);    &#125;&#125;</code></pre><pre><code class="java">一般日期输出：Sat May 23 15:03:25 CST 2020toString日期输出：Sat May 23 15:03:25 CST 2020时间戳：1590217405777格式化结果0：2020-05-23 15:03:25格式化结果1：2020年05月23日 15时03分25秒</code></pre>]]></content>
      
      
      <categories>
          
          <category> ✨其他 </category>
          
          <category> 数据分析 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Pandas库使用——基础知识</title>
      <link href="/blog/li8bkt/"/>
      <url>/blog/li8bkt/</url>
      
        <content type="html"><![CDATA[<h2 id="一、Pandas-数据结构"><a href="#一、Pandas-数据结构" class="headerlink" title="一、Pandas 数据结构"></a>一、Pandas 数据结构</h2><pre><code class="python">import pandas as pd</code></pre><h3 id="Series"><a href="#Series" class="headerlink" title="Series"></a>Series</h3><blockquote><ol><li>通过 list 构建 Series</li></ol></blockquote><pre><code class="python">ser_obj = pd.Series(range(10, 20,2))print (type(ser_obj))print(ser_obj)</code></pre><pre><code>&lt;class &#39;pandas.core.series.Series&#39;&gt;0    101    122    143    164    18dtype: int64</code></pre><pre><code class="python"># 获取数据print (ser_obj.values)# 获取索引print (ser_obj.index)#范围索引数据类型# 预览数据print (ser_obj.head(3))#默认输出五行</code></pre><pre><code>[10 12 14 16 18]RangeIndex(start=0, stop=5, step=1)0    101    122    14dtype: int64</code></pre><blockquote><ol start="2"><li>通过 dict 构建 Series</li></ol></blockquote><pre><code class="python">year_data = &#123;2001: 17.8, 2002: 20.1, 2003: 16.5,2004:324,2423:243&#125;ser_obj2 = pd.Series(year_data)print (ser_obj2.head(2))print (ser_obj2.index)print(ser_obj2)</code></pre><pre><code>2001    17.82002    20.1dtype: float64Int64Index([2001, 2002, 2003, 2004, 2423], dtype=&#39;int64&#39;)2001     17.82002     20.12003     16.52004    324.02423    243.0dtype: float64</code></pre><pre><code class="python"># name属性【【【【【出问题了！！！】】】】】ser_obj2.name = &#39;钱&#39;ser_obj2.index.name = &#39;year&#39;print (ser_obj2.head())</code></pre><pre><code>year2001     17.82002     20.12003     16.52004    324.02423    243.0Name: 钱, dtype: float64</code></pre><h3 id="DataFrame"><a href="#DataFrame" class="headerlink" title="DataFrame"></a>DataFrame</h3><blockquote><ol><li>通过 ndarray 构建 DataFrame</li></ol></blockquote><pre><code class="python">import numpy as nparray = np.random.rand(5,4)print (array)df_obj = pd.DataFrame(array,columns=[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;])print (df_obj.head())print(df_obj.sort_values(by=&#39;a&#39;, ascending=False))</code></pre><pre><code>[[0.23496522 0.92258429 0.36447462 0.52634697] [0.73743514 0.88175941 0.48944212 0.4173522 ] [0.21214568 0.57148666 0.59496072 0.49490723] [0.7458542  0.74743907 0.70475157 0.28130394] [0.43805937 0.90300134 0.00730653 0.68203725]]          a         b         c         d0  0.234965  0.922584  0.364475  0.5263471  0.737435  0.881759  0.489442  0.4173522  0.212146  0.571487  0.594961  0.4949073  0.745854  0.747439  0.704752  0.2813044  0.438059  0.903001  0.007307  0.682037          a         b         c         d3  0.745854  0.747439  0.704752  0.2813041  0.737435  0.881759  0.489442  0.4173524  0.438059  0.903001  0.007307  0.6820370  0.234965  0.922584  0.364475  0.5263472  0.212146  0.571487  0.594961  0.494907</code></pre><blockquote><ol start="2"><li>通过 dict 构建 DataFrame</li></ol></blockquote><pre><code class="python">#一个键值对就相当于一列！！但是具体到字典里面的值所用到的一些函数还是不能很清楚dict_data = &#123;&#39;A&#39;: 1.,             &#39;B&#39;: pd.Timestamp(&#39;20161217&#39;),             &#39;C&#39;: pd.Series(1, index=list(range(4)),dtype=&#39;float32&#39;),             &#39;D&#39;: np.array([3] * 4,dtype=&#39;int32&#39;),             &#39;E&#39; : pd.Categorical([&quot;Python&quot;,&quot;Java&quot;,&quot;C++&quot;,&quot;C#&quot;]),             &#39;F&#39; : &#39;ChinaHadoop&#39; &#125;df_obj2 = pd.DataFrame(dict_data)print (df_obj2.head())</code></pre><pre><code>     A          B    C  D       E            F0  1.0 2016-12-17  1.0  3  Python  ChinaHadoop1  1.0 2016-12-17  1.0  3    Java  ChinaHadoop2  1.0 2016-12-17  1.0  3     C++  ChinaHadoop3  1.0 2016-12-17  1.0  3      C#  ChinaHadoop</code></pre><pre><code class="python"># 增加列df_obj2[&#39;G&#39;] = df_obj2[&#39;D&#39;] + 4print (df_obj2.head())xxx = pd.DataFrame(df_obj2,columns=[&#39;A&#39;,&#39;B&#39;,&#39;C&#39;,&#39;D&#39;,&#39;E&#39;,&#39;F&#39;,&#39;G&#39;,&#39;H&#39;],index=[0,1,2,3,4])print(xxx)</code></pre><pre><code>     A          B    C  D       E            F  G0  1.0 2016-12-17  1.0  3  Python  ChinaHadoop  71  1.0 2016-12-17  1.0  3    Java  ChinaHadoop  72  1.0 2016-12-17  1.0  3     C++  ChinaHadoop  73  1.0 2016-12-17  1.0  3      C#  ChinaHadoop  7     A          B    C    D       E            F    G   H0  1.0 2016-12-17  1.0  3.0  Python  ChinaHadoop  7.0 NaN1  1.0 2016-12-17  1.0  3.0    Java  ChinaHadoop  7.0 NaN2  1.0 2016-12-17  1.0  3.0     C++  ChinaHadoop  7.0 NaN3  1.0 2016-12-17  1.0  3.0      C#  ChinaHadoop  7.0 NaN4  NaN        NaT  NaN  NaN     NaN          NaN  NaN NaN</code></pre><h3 id="Index"><a href="#Index" class="headerlink" title="Index"></a>Index</h3><pre><code class="python">print (type(ser_obj.index))print (type(df_obj2.index))print (df_obj2.index)</code></pre><pre><code>&lt;class &#39;pandas.core.indexes.range.RangeIndex&#39;&gt;&lt;class &#39;pandas.core.indexes.numeric.Int64Index&#39;&gt;Int64Index([0, 1, 2, 3], dtype=&#39;int64&#39;)</code></pre><pre><code class="python"># 索引对象不可变df_obj2.index[0] = 2</code></pre><pre><code>---------------------------------------------------------------------------TypeError                                 Traceback (most recent call last)&lt;ipython-input-10-6367894e76d8&gt; in &lt;module&gt;      1 # 索引对象不可变----&gt; 2 df_obj2.index[0] = 2~\Anaconda3\lib\site-packages\pandas\core\indexes\base.py in __setitem__(self, key, value)   4258   4259     def __setitem__(self, key, value):-&gt; 4260         raise TypeError(&quot;Index does not support mutable operations&quot;)   4261   4262     def __getitem__(self, key):TypeError: Index does not support mutable operations</code></pre><h2 id="二、Pandas-数据操作"><a href="#二、Pandas-数据操作" class="headerlink" title="二、Pandas 数据操作"></a>二、Pandas 数据操作</h2><h3 id="常用函数总结"><a href="#常用函数总结" class="headerlink" title="常用函数总结"></a>常用函数总结</h3><blockquote><p>·shape   获取数据的尺寸</p></blockquote><pre><code> 获得df的size：df.shape 获得df中的行数：df.shape[0] 获得df中的列数： df.shape[1] 获得行索引信息：df.index 获得列索引信息：df.colomns</code></pre><blockquote><p>·values   获得 df 中的值===中文没用</p></blockquote><pre><code>df.values === 以列表的形式展现出来，去除了索引===dataframe类型数据转换成array类型</code></pre><blockquote><p>·setindex 和 resetindex</p></blockquote><pre><code>reset_index可以还原索引，从新变为默认的整型索引    DataFrame.reset_index(level=None, drop=False, inplace=False, col_level=0, col_fill=”)    level控制了具体要还原的那个等级的索引    drop为False则索引列会被还原为普通列，否则会丢失set_index方法，设置单索引和复合索引抑或是添加索引。    DataFrame.set_index(keys, drop=True, append=False, inplace=False, verify_integrity=False)    append添加新索引，drop为False，inplace为True时，索引将会还原为列</code></pre><blockquote><p>·iterrows（）遍历 DataFrame 中的数据</p></blockquote><pre><code>for index,row in df.iterrows():</code></pre><blockquote><p>·split(sep,n,expand=false)</p></blockquote><pre><code>sep表示用于分割的字符；n表格分割成多少列；expand表示是否展开为数据款，True输出Series，False输出Dataframe。字段拆分：是指按照固定的字符，拆分已有字符串</code></pre><pre><code class="python">import pandas as pdimport numpy as np</code></pre><h3 id="匿名函数应用"><a href="#匿名函数应用" class="headerlink" title="匿名函数应用"></a>匿名函数应用</h3><pre><code class="python"># Numpy ufunc 函数df = pd.DataFrame(np.random.randn(5,4) - 1)print (df)print (np.abs(df))</code></pre><pre><code>          0         1         2         30  0.624016 -2.695175 -1.211426 -0.3861511 -1.335385 -1.315232 -0.305902 -0.3613482 -0.349443 -2.032110  0.075995 -0.9667253 -1.631192 -1.051390 -1.767981 -0.3666634 -0.786178 -0.335846 -0.797992 -0.931216          0         1         2         30  0.624016  2.695175  1.211426  0.3861511  1.335385  1.315232  0.305902  0.3613482  0.349443  2.032110  0.075995  0.9667253  1.631192  1.051390  1.767981  0.3666634  0.786178  0.335846  0.797992  0.931216</code></pre><pre><code class="python"># 使用apply应用行或列数据f = lambda x : x.max()print (df.apply(f))</code></pre><pre><code>0    0.6240161   -0.3358462    0.0759953   -0.361348dtype: float64</code></pre><pre><code class="python"># 指定轴方向print (df.apply(f, axis=1))</code></pre><pre><code>0    0.6240161   -0.3059022    0.0759953   -0.3666634   -0.335846dtype: float64</code></pre><pre><code class="python"># 使用applymap应用到每个数据f2 = lambda x : &#39;%.2f&#39; % xprint (df.applymap(f2))</code></pre><pre><code>       0      1      2      30   0.62  -2.70  -1.21  -0.391  -1.34  -1.32  -0.31  -0.362  -0.35  -2.03   0.08  -0.973  -1.63  -1.05  -1.77  -0.374  -0.79  -0.34  -0.80  -0.93</code></pre><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><pre><code class="python">s4 = pd.Series(range(10, 15), index = np.random.randint(5, size=5))print (s4)</code></pre><pre><code>4    101    114    121    131    14dtype: int64</code></pre><blockquote><ol><li>索引排序</li></ol></blockquote><pre><code class="python">s4.sort_index()</code></pre><pre><code>1    111    131    144    104    12dtype: int64</code></pre><pre><code class="python">df4 = pd.DataFrame(np.random.randn(3, 4),                   index=np.random.randint(3, size=3),                   columns=np.random.randint(4, size=4))</code></pre><pre><code class="python">df4</code></pre><table><thead><tr><th></th><th>2</th><th>1</th><th>3</th><th>1</th></tr></thead><tbody><tr><td>0</td><td>0.007031</td><td>1.261990</td><td>-1.647929</td><td>0.176549</td></tr><tr><td>1</td><td>-2.510698</td><td>-0.207659</td><td>0.628221</td><td>0.441352</td></tr><tr><td>0</td><td>-0.367051</td><td>1.536606</td><td>0.167158</td><td>-0.236129</td></tr></tbody></table><pre><code class="python">#df4.sort_index(ascending=False)df4.sort_index(axis=1)</code></pre><table><thead><tr><th></th><th>1</th><th>1</th><th>2</th><th>3</th></tr></thead><tbody><tr><td>0</td><td>1.261990</td><td>0.176549</td><td>0.007031</td><td>-1.647929</td></tr><tr><td>1</td><td>-0.207659</td><td>0.441352</td><td>-2.510698</td><td>0.628221</td></tr><tr><td>0</td><td>1.536606</td><td>-0.236129</td><td>-0.367051</td><td>0.167158</td></tr></tbody></table><blockquote><ol start="2"><li>按值排序</li></ol></blockquote><pre><code class="python">#df.sortvalues(by=&#39;a&#39;, ascending=False) === 通过a的值#    作用是对选定的一列数值（&#39;a&#39;）数据从上往下从小到大进行排序（如果传值没成功===设置本体覆盖，传值覆盖）df4.sort_values(by=1)</code></pre><pre><code>---------------------------------------------------------------------------ValueError                                Traceback (most recent call last)&lt;ipython-input-22-36ffa8ddd07d&gt; in &lt;module&gt;      2 #df.sortvalues(by=&#39;a&#39;, ascending=False) === 通过a的值      3 #    作用是对选定的一列数值（&#39;a&#39;）数据从上往下从小到大进行排序（如果传值没成功===设置本体覆盖，传值覆盖）----&gt; 4 df4.sort_values(by=1)~\Anaconda3\lib\site-packages\pandas\core\frame.py in sort_values(self, by, axis, ascending, inplace, kind, na_position)   4991   4992             by = by[0]-&gt; 4993             k = self._get_label_or_level_values(by, axis=axis)   4994   4995             if isinstance(ascending, (tuple, list)):~\Anaconda3\lib\site-packages\pandas\core\generic.py in _get_label_or_level_values(self, key, axis)   1795                     key=key,   1796                     label_axis_name=label_axis_name,-&gt; 1797                     multi_message=multi_message,   1798                 )   1799             )ValueError: The column label &#39;1&#39; is not unique.</code></pre>]]></content>
      
      
      <categories>
          
          <category> ✨其他 </category>
          
          <category> 数据分析 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Pandas库使用——各种索引</title>
      <link href="/blog/nfqdqf/"/>
      <url>/blog/nfqdqf/</url>
      
        <content type="html"><![CDATA[<h2 id="一、基本索引"><a href="#一、基本索引" class="headerlink" title="一、基本索引"></a>一、基本索引</h2><pre><code class="python">import pandas as pdimport numpy as np</code></pre><h3 id="Series-索引"><a href="#Series-索引" class="headerlink" title="Series 索引"></a>Series 索引</h3><pre><code class="python">ser_obj1 = pd.Series(range(5), index = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;])print (ser_obj1.head())</code></pre><pre><code>a    0b    1c    2d    3e    4dtype: int64</code></pre><pre><code class="python">&#39;&#39;&#39;1. 行索引&#39;&#39;&#39;print(&#39;行索引====================================================================&#39;)print (ser_obj1[&#39;b&#39;])print (ser_obj1[0])print(&#39;切片索引====================================================================&#39;)&#39;&#39;&#39;2. 切片索引&#39;&#39;&#39;print (ser_obj1[1:3])print (ser_obj1[&#39;b&#39;:&#39;d&#39;])print(&#39;不连续索引索引====================================================================&#39;)#注意会不会包含尾巴。。&#39;&#39;&#39;3. 不连续索引&#39;&#39;&#39;print (ser_obj1[[0, 2, 4]])print (ser_obj1[[&#39;a&#39;, &#39;e&#39;]])print(&#39;布尔索引====================================================================&#39;)&#39;&#39;&#39;4. 布尔索引&#39;&#39;&#39;#是对里面的值进行判断，不是对索引ser_bool = ser_obj1 &gt; 2print (ser_bool)print (ser_obj1[ser_bool])#运用的方式print (ser_obj1[ser_obj1 &gt; 2])</code></pre><pre><code>行索引====================================================================10切片索引====================================================================b    1c    2dtype: int64b    1c    2d    3dtype: int64不连续索引索引====================================================================a    0c    2e    4dtype: int64a    0e    4dtype: int64布尔索引====================================================================a    Falseb    Falsec    Falsed     Truee     Truedtype: boold    3e    4dtype: int64d    3e    4dtype: int64</code></pre><h3 id="Dataframe-索引"><a href="#Dataframe-索引" class="headerlink" title="Dataframe 索引"></a>Dataframe 索引</h3><pre><code class="python">df_obj1 = pd.DataFrame(np.random.randn(5,4), columns = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;])print (df_obj1.head())</code></pre><pre><code>          a         b         c         d0 -0.720611 -0.002543 -0.084255 -0.5837191  0.174715  0.288090 -0.254462 -1.6696682 -1.872654 -0.466842 -0.481040 -1.7355583  1.147668  1.205686  0.625582 -2.1118634  1.177882  0.049581 -0.404098 -0.497125</code></pre><pre><code class="python">&#39;&#39;&#39;0. 转换成行索引的话===方式一：transpose或者T&#39;&#39;&#39;bb=df_obj1.transpose()print(df_obj1.T)print(bb)&#39;&#39;&#39;0. 转换成行索引的话===方式二：重构&#39;&#39;&#39;</code></pre><pre><code>          0         1         2         3         4a -0.720611  0.174715 -1.872654  1.147668  1.177882b -0.002543  0.288090 -0.466842  1.205686  0.049581c -0.084255 -0.254462 -0.481040  0.625582 -0.404098d -0.583719 -1.669668 -1.735558 -2.111863 -0.497125          0         1         2         3         4a -0.720611  0.174715 -1.872654  1.147668  1.177882b -0.002543  0.288090 -0.466842  1.205686  0.049581c -0.084255 -0.254462 -0.481040  0.625582 -0.404098d -0.583719 -1.669668 -1.735558 -2.111863 -0.497125&#39;0. 转换成行索引的话===方式二：重构/重塑===还没有完全明白&#39;</code></pre><pre><code class="python">&#39;&#39;&#39;1. 列索引=====默认为列索引来操作&#39;&#39;&#39;print (&#39;列索引&#39;)print(df_obj1.b)#当成属性来获取值print(&#39;===================&#39;)print (df_obj1[&#39;a&#39;]) # 返回Series类型print (type(df_obj1[&#39;a&#39;]))print (df_obj1[[&#39;a&#39;]]) # 返回DataFrame类型print (type(df_obj1[[&#39;a&#39;]]))&#39;&#39;&#39;2. 不连续索引&#39;&#39;&#39;print (&#39;不连续索引&#39;)print (df_obj1[[&#39;a&#39;,&#39;c&#39;]])print (df_obj1[[&#39;a&#39;,&#39;c&#39;]])</code></pre><pre><code>列索引0   -0.0025431    0.2880902   -0.4668423    1.2056864    0.049581Name: b, dtype: float64===================0   -0.7206111    0.1747152   -1.8726543    1.1476684    1.177882Name: a, dtype: float64&lt;class &#39;pandas.core.series.Series&#39;&gt;          a0 -0.7206111  0.1747152 -1.8726543  1.1476684  1.177882&lt;class &#39;pandas.core.frame.DataFrame&#39;&gt;不连续索引          a         c0 -0.720611 -0.0842551  0.174715 -0.2544622 -1.872654 -0.4810403  1.147668  0.6255824  1.177882 -0.404098          a         c0 -0.720611 -0.0842551  0.174715 -0.2544622 -1.872654 -0.4810403  1.147668  0.6255824  1.177882 -0.404098</code></pre><h3 id="三种索引方式"><a href="#三种索引方式" class="headerlink" title="三种索引方式"></a>三种索引方式</h3><pre><code class="python">print(ser_obj1)print(&#39;============================&#39;)print(df_obj1)</code></pre><pre><code>a    0b    1c    2d    3e    4dtype: int64============================          a         b         c         d0 -0.720611 -0.002543 -0.084255 -0.5837191  0.174715  0.288090 -0.254462 -1.6696682 -1.872654 -0.466842 -0.481040 -1.7355583  1.147668  1.205686  0.625582 -2.1118634  1.177882  0.049581 -0.404098 -0.497125</code></pre><pre><code class="python">&#39;&#39;&#39;1. 标签索引 loc===用的是index和column的值索引【标签索引】&#39;&#39;&#39;# Seriesprint (ser_obj1[&#39;b&#39;:&#39;d&#39;])print (ser_obj1.loc[&#39;b&#39;:&#39;d&#39;])# DataFrameprint (df_obj1[[&#39;a&#39;]])print (df_obj1.loc[0:2,&#39;a&#39;:&#39;c&#39;])</code></pre><pre><code>b    1c    2d    3dtype: int64b    1c    2d    3dtype: int64          a0 -0.7206111  0.1747152 -1.8726543  1.1476684  1.177882          a         b         c0 -0.720611 -0.002543 -0.0842551  0.174715  0.288090 -0.2544622 -1.872654 -0.466842 -0.481040</code></pre><pre><code class="python">&#39;&#39;&#39;2. 位置索引 iloc====用的是index和column的默认0，1，2，3···的值索引【位置索引】&#39;&#39;&#39;print (ser_obj1[1:3])print (ser_obj1.iloc[1:3])# DataFrameprint (df_obj1.iloc[0:2, 0:2])# 注意和df_obj.loc[0:2, &#39;a&#39;]的区别 = = = 行和列：都不包括尾巴</code></pre><pre><code>b    1c    2dtype: int64b    1c    2dtype: int64          a         b0 -0.720611 -0.0025431  0.174715  0.288090</code></pre><pre><code class="python">&#39;&#39;&#39;3. 混合索引 ix===先按标签索引loc尝试操作，然后再按位置索引iloc尝试操作&#39;&#39;&#39;print (ser_obj1.ix[1:3])print (ser_obj1.ix[&#39;b&#39;:&#39;c&#39;])# DataFrameprint (df_obj1.ix[0:2, 0:3])</code></pre><pre><code>b    1c    2dtype: int64b    1c    2dtype: int64          a         b         c0 -0.720611 -0.002543 -0.0842551  0.174715  0.288090 -0.2544622 -1.872654 -0.466842 -0.481040</code></pre><h2 id="二、Pandas-层级索引"><a href="#二、Pandas-层级索引" class="headerlink" title="二、Pandas 层级索引"></a>二、Pandas 层级索引</h2><h3 id="构造层级索引"><a href="#构造层级索引" class="headerlink" title="构造层级索引"></a>构造层级索引</h3><pre><code class="python">ser_obj = pd.Series(np.random.randn(12),                    index=[[&#39;a&#39;, &#39;a&#39;, &#39;a&#39;, &#39;b&#39;, &#39;b&#39;, &#39;b&#39;, &#39;c&#39;, &#39;c&#39;, &#39;c&#39;, &#39;d&#39;, &#39;d&#39;, &#39;d&#39;],                           [0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2]])#列表里面的列表print (ser_obj)</code></pre><pre><code>a  0   -0.373441   1    0.615976   2    0.959092b  0    1.743670   1   -0.791517   2   -0.774013c  0    1.271094   1   -0.723264   2    0.253038d  0   -0.767791   1    0.419253   2   -0.691644dtype: float64</code></pre><ul><li>MultiIndex 索引对象</li></ul><pre><code class="python">print (type(ser_obj.index))print (ser_obj.index)</code></pre><pre><code>&lt;class &#39;pandas.core.indexes.multi.MultiIndex&#39;&gt;MultiIndex([(&#39;a&#39;, 0),            (&#39;a&#39;, 1),            (&#39;a&#39;, 2),            (&#39;b&#39;, 0),            (&#39;b&#39;, 1),            (&#39;b&#39;, 2),            (&#39;c&#39;, 0),            (&#39;c&#39;, 1),            (&#39;c&#39;, 2),            (&#39;d&#39;, 0),            (&#39;d&#39;, 1),            (&#39;d&#39;, 2)],           )</code></pre><h3 id="选取子集"><a href="#选取子集" class="headerlink" title="选取子集"></a>选取子集</h3><pre><code class="python"># 外层选取print (ser_obj[&#39;c&#39;])</code></pre><pre><code>0    1.2710941   -0.7232642    0.253038dtype: float64</code></pre><pre><code class="python"># 内层选取print (ser_obj[:, 2])</code></pre><pre><code>a    0.959092b   -0.774013c    0.253038d   -0.691644dtype: float64</code></pre><h3 id="交换分层顺序"><a href="#交换分层顺序" class="headerlink" title="交换分层顺序"></a>交换分层顺序</h3><pre><code class="python">df_obj2 = pd.DataFrame(np.random.randn(6,4), columns = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;],index=[[&#39;a&#39;, &#39;a&#39;, &#39;a&#39;, &#39;b&#39;, &#39;b&#39;,&#39;b&#39;],[1, 2, 3, 1, 2,3]])#print (df_obj1.swaplevel())print (df_obj2)</code></pre><pre><code>            a         b         c         da 1  0.273776 -0.018659  1.512727 -0.088091  2 -0.410883 -1.488943  0.917268  1.179941  3 -0.237532 -0.823717  0.189495  1.060476b 1  0.727872  0.323352  0.443786  0.780510  2 -1.407645 -0.059689  1.439843 -1.700740  3 -0.377628 -0.137348 -0.739980  0.122528</code></pre><h3 id="交换并排序分层"><a href="#交换并排序分层" class="headerlink" title="交换并排序分层"></a>交换并排序分层</h3><pre><code class="python">print (df_obj2.swaplevel().sortvalues(by=&#39;a&#39;))#Series没有这个内置函数sortlevel===dataframe有</code></pre><h2 id="三、透视表和交叉表"><a href="#三、透视表和交叉表" class="headerlink" title="三、透视表和交叉表"></a>三、透视表和交叉表</h2><pre><code class="python">dataset_path = &#39;./data/starcraft.csv&#39;df_data = pd.read_csv(dataset_path, usecols=[&#39;LeagueIndex&#39;, &#39;Age&#39;, &#39;HoursPerWeek&#39;,                                             &#39;TotalHours&#39;, &#39;APM&#39;])print(df_data.head())</code></pre><pre><code>   LeagueIndex   Age  HoursPerWeek  TotalHours       APM0            5  27.0          10.0      3000.0  143.71801            5  23.0          10.0      5000.0  129.23222            4  30.0          10.0       200.0   69.96123            3  19.0          20.0       400.0  107.60164            3  32.0          10.0       500.0  122.8908</code></pre><h3 id="透视表"><a href="#透视表" class="headerlink" title="透视表"></a>透视表</h3><pre><code class="python">pd.pivot_table(df_data,               index=[&#39;Age&#39;],               columns=[&#39;LeagueIndex&#39;],               aggfunc=np.sum)</code></pre><p>|             | APM        | HoursPerWeek | TotalHours |<br>| ———– | ———- | ———— | ———- | ———- | ———– | ———- | ——— | —– | —– | —– | — | —— | —— | —– | —— | ——- | ——- | ——- | ——— | ——– | ——- |<br>| LeagueIndex | 1          | 2            | 3          | 4          | 5           | 6          | 7         | 1     | 2     | 3     | … | 5      | 6      | 7     | 1      | 2       | 3       | 4       | 5         | 6        | 7       |<br>| Age         |            |              |            |            |             |            |           |       |       |       |     |        |        |       |        |         |         |         |           |          |         |<br>| 16.0        | 1062.44754 | 2919.70434   | 4851.9222  | 5149.7310  | 7787.37780  | 9042.1722  | 386.7774  | 324.0 | 720.0 | 778.0 | … | 1220.0 | 1280.0 | 56.0  | 4307.0 | 13143.0 | 29211.0 | 23581.0 | 49233.0   | 51320.0  | 3000.0  |<br>| 17.0        | 655.67280  | 1661.01540   | 4181.8920  | 5525.3586  | 10052.72100 | 8310.0858  | 573.8286  | 184.0 | 378.0 | 664.0 | … | 1460.0 | 1116.0 | 104.0 | 2044.0 | 7423.0  | 16602.0 | 24005.0 | 53375.0   | 45421.0  | 12700.0 |<br>| 18.0        | 704.47680  | 3300.41040   | 4847.2152  | 8763.0783  | 10988.66100 | 9134.7240  | 618.5790  | 204.0 | 548.0 | 886.0 | … | 1644.0 | 1194.0 | 164.0 | 3570.0 | 11471.0 | 21037.0 | 46034.0 | 1056486.0 | 50378.0  | 3200.0  |<br>| 19.0        | 734.55600  | 2216.81880   | 5183.7888  | 8030.1960  | 9271.09260  | 11955.6030 | 696.7770  | 126.0 | 458.0 | 950.0 | … | 962.0  | 1642.0 | 168.0 | 2355.0 | 8467.0  | 31861.0 | 39705.0 | 44697.0   | 70331.0  | 4166.0  |<br>| 20.0        | 1624.89660 | 2147.23200   | 4211.5686  | 10596.2070 | 10871.65440 | 14291.8692 | NaN       | 328.0 | 288.0 | 654.0 | … | 1290.0 | 1816.0 | NaN   | 7212.0 | 6325.0  | 20174.0 | 55083.0 | 64170.0   | 105131.0 | NaN     |<br>| 21.0        | 780.67950  | 1578.02880   | 3949.3062  | 8689.8804  | 11954.91660 | 13165.7649 | 867.3474  | 162.0 | 270.0 | 580.0 | … | 1446.0 | 1858.0 | 62.0  | 3377.0 | 7673.0  | 19095.0 | 42296.0 | 68739.0   | 82061.0  | 3180.0  |<br>| 22.0        | 674.59860  | 2147.50980   | 4379.3424  | 7818.7302  | 10473.28380 | 10165.8672 | 493.1586  | 146.0 | 372.0 | 680.0 | … | 1304.0 | 1448.0 | 112.0 | 4225.0 | 10861.0 | 23030.0 | 57996.0 | 84330.0   | 67069.0  | 6950.0  |<br>| 23.0        | 359.65980  | 1575.06120   | 4602.7416  | 7616.9298  | 8292.86160  | 6131.1936  | 1799.6520 | 46.0  | 320.0 | 598.0 | … | 998.0  | 726.0  | 296.0 | 896.0  | 12350.0 | 23081.0 | 40025.0 | 56097.0   | 43176.0  | 14290.0 |<br>| 24.0        | 439.43040  | 1717.55340   | 2876.8572  | 5503.7736  | 7292.32740  | 7240.4076  | 428.6538  | 116.0 | 344.0 | 406.0 | … | 668.0  | 1048.0 | 36.0  | 2070.0 | 9543.0  | 25421.0 | 35384.0 | 36147.0   | 43114.0  | 2250.0  |<br>| 25.0        | 572.61420  | 1178.02440   | 2201.6388  | 4710.9924  | 6168.19260  | 2200.6362  | 361.4550  | 124.0 | 166.0 | 268.0 | … | 682.0  | 256.0  | 52.0  | 2440.0 | 5846.0  | 11270.0 | 26610.0 | 40681.0   | 14890.0  | 3300.0  |<br>| 26.0        | 418.70874  | 1165.96680   | 1794.1890  | 3139.2852  | 4016.67060  | 3301.8498  | 408.2202  | 96.0  | 148.0 | 272.0 | … | 418.0  | 354.0  | 60.0  | 1608.0 | 3417.0  | 10548.0 | 16839.0 | 20100.0   | 17663.0  | 2300.0  |<br>| 27.0        | 359.17320  | 1164.15960   | 1426.4550  | 2850.1320  | 3498.30300  | 2040.8454  | NaN       | 40.0  | 152.0 | 226.0 | … | 340.0  | 164.0  | NaN   | 1100.0 | 3615.0  | 7525.0  | 15935.0 | 19770.0   | 11796.0  | NaN     |<br>| 28.0        | 333.84240  | 479.34000    | 1152.5958  | 2205.8778  | 1992.60540  | 521.7666   | NaN       | 28.0  | 90.0  | 220.0 | … | 186.0  | 44.0   | NaN   | 466.0  | 1860.0  | 7901.0  | 15370.0 | 10872.0   | 2500.0   | NaN     |<br>| 29.0        | 236.74020  | 695.88480    | 568.2594   | 1447.5906  | 1398.78540  | 715.9404   | NaN       | 54.0  | 56.0  | 80.0  | … | 180.0  | 106.0  | NaN   | 2490.0 | 2000.0  | 3816.0  | 8220.0  | 10292.0   | 5950.0   | NaN     |<br>| 30.0        | 125.53740  | 441.14160    | 733.6416   | 743.4468   | 578.32020   | 123.3774   | NaN       | 14.0  | 54.0  | 76.0  | … | 90.0   | 28.0   | NaN   | 210.0  | 2440.0  | 4370.0  | 6310.0  | 3440.0    | 1500.0   | NaN     |<br>| 31.0        | 41.58600   | 314.92980    | 659.2626   | 1166.7606  | 315.53460   | 200.1708   | NaN       | 12.0  | 36.0  | 68.0  | … | 12.0   | 16.0   | NaN   | 200.0  | 1300.0  | 3500.0  | 8710.0  | 1050.0    | 1500.0   | NaN     |<br>| 32.0        | 179.14380  | 315.54180    | 457.5174   | 541.8996   | 66.19740    | NaN        | NaN       | 40.0  | 56.0  | 68.0  | … | 10.0   | NaN    | NaN   | 1600.0 | 860.0   | 2300.0  | 6040.0  | 800.0     | NaN      | NaN     |<br>| 33.0        | 198.77880  | 153.34680    | 284.8218   | 116.7516   | 245.45166   | NaN        | NaN       | 32.0  | 12.0  | 42.0  | … | 60.0   | NaN    | NaN   | 1200.0 | 220.0   | 2065.0  | 1130.0  | 2050.0    | NaN      | NaN     |<br>| 34.0        | 49.11360   | 276.88260    | 268.4100   | 340.7124   | 174.54540   | NaN        | NaN       | 12.0  | 56.0  | 28.0  | … | 14.0   | NaN    | NaN   | 150.0  | 3380.0  | 1150.0  | 2400.0  | 2764.0    | NaN      | NaN     |<br>| 35.0        | 229.31280  | 54.04680     | 170.4930   | 634.7688   | 115.06440   | NaN        | NaN       | 54.0  | 8.0   | 26.0  | … | 12.0   | NaN    | NaN   | 1350.0 | 500.0   | 1950.0  | 3800.0  | 800.0     | NaN      | NaN     |<br>| 36.0        | NaN        | 150.13140    | 333.6474   | 73.6980    | NaN         | NaN        | NaN       | NaN   | 16.0  | 40.0  | … | NaN    | NaN    | NaN   | NaN    | 500.0   | 1950.0  | 400.0   | NaN       | NaN      | NaN     |<br>| 37.0        | 22.05960   | 49.89600     | 44.9682    | NaN        | 451.13160   | NaN        | NaN       | 12.0  | 30.0  | 6.0   | … | 32.0   | NaN    | NaN   | 300.0  | 125.0   | 600.0   | NaN     | 1800.0    | NaN      | NaN     |<br>| 38.0        | 71.59500   | NaN          | 334.6878   | NaN        | NaN         | NaN        | NaN       | 16.0  | NaN   | 46.0  | … | NaN    | NaN    | NaN   | 300.0  | NaN     | 2280.0  | NaN     | NaN       | NaN      | NaN     |<br>| 39.0        | 29.87640   | NaN          | 53.7690    | 86.7246    | NaN         | NaN        | NaN       | 10.0  | NaN   | 12.0  | … | NaN    | NaN    | NaN   | 500.0  | NaN     | 450.0   | 500.0   | NaN       | NaN      | NaN     |<br>| 40.0        | 38.55900   | 51.83580     | 107.4684   | NaN        | NaN         | NaN        | NaN       | 12.0  | 14.0  | 26.0  | … | NaN    | NaN    | NaN   | 150.0  | 500.0   | 1080.0  | NaN     | NaN       | NaN      | NaN     |<br>| 41.0        | NaN        | 108.45720    | 77.6472    | NaN        | NaN         | NaN        | NaN       | NaN   | 12.0  | 14.0  | … | NaN    | NaN    | NaN   | NaN    | 450.0   | 800.0   | NaN     | NaN       | NaN      | NaN     |<br>| 43.0        | NaN        | 86.05860     | NaN        | NaN        | NaN         | NaN        | NaN       | NaN   | 10.0  | NaN   | … | NaN    | NaN    | NaN   | NaN    | 730.0   | NaN     | NaN     | NaN       | NaN      | NaN     |<br>| 44.0        | NaN        | NaN          | NaN        | 89.5266    | NaN         | NaN        | NaN       | NaN   | NaN   | NaN   | … | NaN    | NaN    | NaN   | NaN    | NaN     | NaN     | 500.0   | NaN       | NaN      | NaN     |</p><p>28 rows × 21 columns</p><pre><code class="python">pd.pivot_table(df_data,               index=[&#39;Age&#39;],               columns=[&#39;LeagueIndex&#39;],               aggfunc=np.sum,               fill_value=-100.)</code></pre><p>|             | APM        | HoursPerWeek | TotalHours |<br>| ———– | ———- | ———— | ———- | ———- | ———– | ———- | ——— | —- | —- | —- | — | —- | —- | —- | —- | —– | —– | —– | ——- | —— | —– |<br>| LeagueIndex | 1          | 2            | 3          | 4          | 5           | 6          | 7         | 1    | 2    | 3    | … | 5    | 6    | 7    | 1    | 2     | 3     | 4     | 5       | 6      | 7     |<br>| Age         |            |              |            |            |             |            |           |      |      |      |     |      |      |      |      |       |       |       |         |        |       |<br>| 16.0        | 1062.44754 | 2919.70434   | 4851.9222  | 5149.7310  | 7787.37780  | 9042.1722  | 386.7774  | 324  | 720  | 778  | … | 1220 | 1280 | 56   | 4307 | 13143 | 29211 | 23581 | 49233   | 51320  | 3000  |<br>| 17.0        | 655.67280  | 1661.01540   | 4181.8920  | 5525.3586  | 10052.72100 | 8310.0858  | 573.8286  | 184  | 378  | 664  | … | 1460 | 1116 | 104  | 2044 | 7423  | 16602 | 24005 | 53375   | 45421  | 12700 |<br>| 18.0        | 704.47680  | 3300.41040   | 4847.2152  | 8763.0783  | 10988.66100 | 9134.7240  | 618.5790  | 204  | 548  | 886  | … | 1644 | 1194 | 164  | 3570 | 11471 | 21037 | 46034 | 1056486 | 50378  | 3200  |<br>| 19.0        | 734.55600  | 2216.81880   | 5183.7888  | 8030.1960  | 9271.09260  | 11955.6030 | 696.7770  | 126  | 458  | 950  | … | 962  | 1642 | 168  | 2355 | 8467  | 31861 | 39705 | 44697   | 70331  | 4166  |<br>| 20.0        | 1624.89660 | 2147.23200   | 4211.5686  | 10596.2070 | 10871.65440 | 14291.8692 | -100.0000 | 328  | 288  | 654  | … | 1290 | 1816 | -100 | 7212 | 6325  | 20174 | 55083 | 64170   | 105131 | -100  |<br>| 21.0        | 780.67950  | 1578.02880   | 3949.3062  | 8689.8804  | 11954.91660 | 13165.7649 | 867.3474  | 162  | 270  | 580  | … | 1446 | 1858 | 62   | 3377 | 7673  | 19095 | 42296 | 68739   | 82061  | 3180  |<br>| 22.0        | 674.59860  | 2147.50980   | 4379.3424  | 7818.7302  | 10473.28380 | 10165.8672 | 493.1586  | 146  | 372  | 680  | … | 1304 | 1448 | 112  | 4225 | 10861 | 23030 | 57996 | 84330   | 67069  | 6950  |<br>| 23.0        | 359.65980  | 1575.06120   | 4602.7416  | 7616.9298  | 8292.86160  | 6131.1936  | 1799.6520 | 46   | 320  | 598  | … | 998  | 726  | 296  | 896  | 12350 | 23081 | 40025 | 56097   | 43176  | 14290 |<br>| 24.0        | 439.43040  | 1717.55340   | 2876.8572  | 5503.7736  | 7292.32740  | 7240.4076  | 428.6538  | 116  | 344  | 406  | … | 668  | 1048 | 36   | 2070 | 9543  | 25421 | 35384 | 36147   | 43114  | 2250  |<br>| 25.0        | 572.61420  | 1178.02440   | 2201.6388  | 4710.9924  | 6168.19260  | 2200.6362  | 361.4550  | 124  | 166  | 268  | … | 682  | 256  | 52   | 2440 | 5846  | 11270 | 26610 | 40681   | 14890  | 3300  |<br>| 26.0        | 418.70874  | 1165.96680   | 1794.1890  | 3139.2852  | 4016.67060  | 3301.8498  | 408.2202  | 96   | 148  | 272  | … | 418  | 354  | 60   | 1608 | 3417  | 10548 | 16839 | 20100   | 17663  | 2300  |<br>| 27.0        | 359.17320  | 1164.15960   | 1426.4550  | 2850.1320  | 3498.30300  | 2040.8454  | -100.0000 | 40   | 152  | 226  | … | 340  | 164  | -100 | 1100 | 3615  | 7525  | 15935 | 19770   | 11796  | -100  |<br>| 28.0        | 333.84240  | 479.34000    | 1152.5958  | 2205.8778  | 1992.60540  | 521.7666   | -100.0000 | 28   | 90   | 220  | … | 186  | 44   | -100 | 466  | 1860  | 7901  | 15370 | 10872   | 2500   | -100  |<br>| 29.0        | 236.74020  | 695.88480    | 568.2594   | 1447.5906  | 1398.78540  | 715.9404   | -100.0000 | 54   | 56   | 80   | … | 180  | 106  | -100 | 2490 | 2000  | 3816  | 8220  | 10292   | 5950   | -100  |<br>| 30.0        | 125.53740  | 441.14160    | 733.6416   | 743.4468   | 578.32020   | 123.3774   | -100.0000 | 14   | 54   | 76   | … | 90   | 28   | -100 | 210  | 2440  | 4370  | 6310  | 3440    | 1500   | -100  |<br>| 31.0        | 41.58600   | 314.92980    | 659.2626   | 1166.7606  | 315.53460   | 200.1708   | -100.0000 | 12   | 36   | 68   | … | 12   | 16   | -100 | 200  | 1300  | 3500  | 8710  | 1050    | 1500   | -100  |<br>| 32.0        | 179.14380  | 315.54180    | 457.5174   | 541.8996   | 66.19740    | -100.0000  | -100.0000 | 40   | 56   | 68   | … | 10   | -100 | -100 | 1600 | 860   | 2300  | 6040  | 800     | -100   | -100  |<br>| 33.0        | 198.77880  | 153.34680    | 284.8218   | 116.7516   | 245.45166   | -100.0000  | -100.0000 | 32   | 12   | 42   | … | 60   | -100 | -100 | 1200 | 220   | 2065  | 1130  | 2050    | -100   | -100  |<br>| 34.0        | 49.11360   | 276.88260    | 268.4100   | 340.7124   | 174.54540   | -100.0000  | -100.0000 | 12   | 56   | 28   | … | 14   | -100 | -100 | 150  | 3380  | 1150  | 2400  | 2764    | -100   | -100  |<br>| 35.0        | 229.31280  | 54.04680     | 170.4930   | 634.7688   | 115.06440   | -100.0000  | -100.0000 | 54   | 8    | 26   | … | 12   | -100 | -100 | 1350 | 500   | 1950  | 3800  | 800     | -100   | -100  |<br>| 36.0        | -100.00000 | 150.13140    | 333.6474   | 73.6980    | -100.00000  | -100.0000  | -100.0000 | -100 | 16   | 40   | … | -100 | -100 | -100 | -100 | 500   | 1950  | 400   | -100    | -100   | -100  |<br>| 37.0        | 22.05960   | 49.89600     | 44.9682    | -100.0000  | 451.13160   | -100.0000  | -100.0000 | 12   | 30   | 6    | … | 32   | -100 | -100 | 300  | 125   | 600   | -100  | 1800    | -100   | -100  |<br>| 38.0        | 71.59500   | -100.00000   | 334.6878   | -100.0000  | -100.00000  | -100.0000  | -100.0000 | 16   | -100 | 46   | … | -100 | -100 | -100 | 300  | -100  | 2280  | -100  | -100    | -100   | -100  |<br>| 39.0        | 29.87640   | -100.00000   | 53.7690    | 86.7246    | -100.00000  | -100.0000  | -100.0000 | 10   | -100 | 12   | … | -100 | -100 | -100 | 500  | -100  | 450   | 500   | -100    | -100   | -100  |<br>| 40.0        | 38.55900   | 51.83580     | 107.4684   | -100.0000  | -100.00000  | -100.0000  | -100.0000 | 12   | 14   | 26   | … | -100 | -100 | -100 | 150  | 500   | 1080  | -100  | -100    | -100   | -100  |<br>| 41.0        | -100.00000 | 108.45720    | 77.6472    | -100.0000  | -100.00000  | -100.0000  | -100.0000 | -100 | 12   | 14   | … | -100 | -100 | -100 | -100 | 450   | 800   | -100  | -100    | -100   | -100  |<br>| 43.0        | -100.00000 | 86.05860     | -100.0000  | -100.0000  | -100.00000  | -100.0000  | -100.0000 | -100 | 10   | -100 | … | -100 | -100 | -100 | -100 | 730   | -100  | -100  | -100    | -100   | -100  |<br>| 44.0        | -100.00000 | -100.00000   | -100.0000  | 89.5266    | -100.00000  | -100.0000  | -100.0000 | -100 | -100 | -100 | … | -100 | -100 | -100 | -100 | -100  | -100  | 500   | -100    | -100   | -100  |</p><p>28 rows × 21 columns</p><h3 id="交叉表"><a href="#交叉表" class="headerlink" title="交叉表"></a>交叉表</h3><pre><code class="python">pd.crosstab(df_data[&#39;LeagueIndex&#39;],            df_data[&#39;Age&#39;])</code></pre><table><thead><tr><th>Age</th><th>16.0</th><th>17.0</th><th>18.0</th><th>19.0</th><th>20.0</th><th>21.0</th><th>22.0</th><th>23.0</th><th>24.0</th><th>25.0</th><th>…</th><th>34.0</th><th>35.0</th><th>36.0</th><th>37.0</th><th>38.0</th><th>39.0</th><th>40.0</th><th>41.0</th><th>43.0</th><th>44.0</th></tr></thead><tbody><tr><td>LeagueIndex</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>1</td><td>18</td><td>9</td><td>13</td><td>12</td><td>22</td><td>12</td><td>12</td><td>6</td><td>9</td><td>11</td><td>…</td><td>1</td><td>5</td><td>0</td><td>1</td><td>1</td><td>1</td><td>1</td><td>0</td><td>0</td><td>0</td></tr><tr><td>2</td><td>38</td><td>22</td><td>38</td><td>32</td><td>25</td><td>23</td><td>28</td><td>24</td><td>24</td><td>18</td><td>…</td><td>5</td><td>1</td><td>2</td><td>1</td><td>0</td><td>0</td><td>1</td><td>2</td><td>1</td><td>0</td></tr><tr><td>3</td><td>48</td><td>43</td><td>56</td><td>53</td><td>47</td><td>44</td><td>47</td><td>47</td><td>32</td><td>26</td><td>…</td><td>3</td><td>3</td><td>5</td><td>1</td><td>4</td><td>1</td><td>2</td><td>1</td><td>0</td><td>0</td></tr><tr><td>4</td><td>45</td><td>49</td><td>78</td><td>71</td><td>97</td><td>81</td><td>75</td><td>72</td><td>52</td><td>45</td><td>…</td><td>4</td><td>7</td><td>1</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>1</td></tr><tr><td>5</td><td>55</td><td>71</td><td>81</td><td>68</td><td>80</td><td>96</td><td>81</td><td>59</td><td>58</td><td>51</td><td>…</td><td>2</td><td>1</td><td>0</td><td>2</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>6</td><td>50</td><td>51</td><td>56</td><td>73</td><td>86</td><td>83</td><td>68</td><td>42</td><td>48</td><td>15</td><td>…</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>7</td><td>2</td><td>3</td><td>3</td><td>4</td><td>0</td><td>5</td><td>3</td><td>9</td><td>2</td><td>2</td><td>…</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr></tbody></table><p>7 rows × 28 columns</p><pre><code class="python">pd.crosstab(df_data[&#39;LeagueIndex&#39;],            [df_data[&#39;Age&#39;], df_data[&#39;HoursPerWeek&#39;]])</code></pre><p>| Age          | 16.0 | … | 39.0 | 40.0 | 41.0 | 43.0 | 44.0 |<br>| ———— | —- | — | —- | —- | —- | —- | —- | —- | —- | —- | — | —- | —- | —- | —- | —- | — | — | —- | —- | — |<br>| HoursPerWeek | 0.0  | 2.0 | 4.0  | 6.0  | 8.0  | 10.0 | 12.0 | 14.0 | 16.0 | 20.0 | … | 12.0 | 10.0 | 12.0 | 14.0 | 16.0 | 4.0 | 8.0 | 14.0 | 10.0 | 6.0 |<br>| LeagueIndex  |      |     |      |      |      |      |      |      |      |      |     |      |      |      |      |      |     |     |      |      |     |<br>| 1            | 0    | 0   | 0    | 1    | 3    | 1    | 1    | 2    | 3    | 3    | … | 0    | 0    | 1    | 0    | 0    | 0   | 0   | 0    | 0    | 0   |<br>| 2            | 0    | 0   | 2    | 1    | 0    | 9    | 4    | 4    | 3    | 3    | … | 0    | 0    | 0    | 1    | 0    | 1   | 1   | 0    | 1    | 0   |<br>| 3            | 0    | 0   | 1    | 6    | 7    | 6    | 6    | 7    | 2    | 1    | … | 1    | 1    | 0    | 0    | 1    | 0   | 0   | 1    | 0    | 0   |<br>| 4            | 0    | 2   | 5    | 1    | 6    | 4    | 3    | 6    | 3    | 1    | … | 0    | 0    | 0    | 0    | 0    | 0   | 0   | 0    | 0    | 1   |<br>| 5            | 0    | 1   | 2    | 1    | 3    | 8    | 3    | 6    | 3    | 6    | … | 0    | 0    | 0    | 0    | 0    | 0   | 0   | 0    | 0    | 0   |<br>| 6            | 1    | 1   | 4    | 2    | 1    | 1    | 4    | 3    | 1    | 7    | … | 0    | 0    | 0    | 0    | 0    | 0   | 0   | 0    | 0    | 0   |<br>| 7            | 0    | 0   | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | … | 0    | 0    | 0    | 0    | 0    | 0   | 0   | 0    | 0    | 0   |</p><p>7 rows × 325 columns</p>]]></content>
      
      
      <categories>
          
          <category> ✨其他 </category>
          
          <category> 数据分析 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Pandas库使用——分组聚合</title>
      <link href="/blog/oq4xcx/"/>
      <url>/blog/oq4xcx/</url>
      
        <content type="html"><![CDATA[<h2 id="一、分组"><a href="#一、分组" class="headerlink" title="一、分组"></a>一、分组</h2><h3 id="GroupBy-对象"><a href="#GroupBy-对象" class="headerlink" title="GroupBy 对象"></a>GroupBy 对象</h3><blockquote><p>· groupedby 函数中的参数：</p></blockquote><pre><code>as_index的作用：控制聚合输出是否以组标签为索引值，默认为True，就是分层次的索引，若为False多加一列默认索引索引，相当于非其他数据排序好了。但是这两组标签索引值不同有什么作用呢？=== 作用就是，根据的一列是否为索引列。sort_values的作用：对选定的一列数值数据从上往下从小到大进行排序（如果传值没成功===设置本体覆盖，传值覆盖）</code></pre><pre><code class="python">import pandas as pdimport numpy as npimport matplotlib.pyplot as pltimport matplotlib.pyplot%matplotlib inline</code></pre><pre><code class="python">dict_obj = &#123;&#39;key1&#39; : [&#39;a&#39;, &#39;b&#39;, &#39;a&#39;, &#39;b&#39;,                      &#39;a&#39;, &#39;b&#39;, &#39;a&#39;, &#39;a&#39;],            &#39;key2&#39; : [&#39;one&#39;, &#39;one&#39;, &#39;two&#39;, &#39;three&#39;,                      &#39;two&#39;, &#39;two&#39;, &#39;one&#39;, &#39;three&#39;],            &#39;data1&#39;: np.random.randn(8),            &#39;data2&#39;: np.random.randn(8)&#125;df_obj = pd.DataFrame(dict_obj)print (df_obj)</code></pre><pre><code>  key1   key2     data1     data20    a    one -0.147612 -0.3480871    b    one -0.992986  0.9024582    a    two  0.547541 -0.3100403    b  three  0.458871 -1.8953924    a    two  1.224041  0.2201505    b    two -0.200124 -1.5622376    a    one  1.539144 -0.7587167    a  three  0.385845  0.074309</code></pre><pre><code class="python">&#39;&#39;&#39;1. dataframe根据key2进行分组&#39;&#39;&#39;print(df_obj.groupby(&#39;key2&#39;)[&#39;key1&#39;].count())print (type(df_obj.groupby(&#39;key1&#39;)))#没有可视化的输出</code></pre><pre><code>key2one      3three    2two      3Name: key1, dtype: int64&lt;class &#39;pandas.core.groupby.generic.DataFrameGroupBy&#39;&gt;</code></pre><pre><code class="python">&#39;&#39;&#39;2. 指定列根据key1进行分组&#39;&#39;&#39;print (type(df_obj[&#39;data1&#39;].groupby(df_obj[&#39;key1&#39;])))</code></pre><pre><code>&lt;class &#39;pandas.core.groupby.generic.SeriesGroupBy&#39;&gt;</code></pre><pre><code class="python"># 分组运算grouped1 = df_obj.groupby(&#39;key1&#39;,as_index=False)print (grouped1.mean())grouped2 = df_obj[&#39;data1&#39;].groupby(df_obj[&#39;key1&#39;])#指定某一列的数据在该索引下进行分组并且加以聚合print (grouped2.mean())</code></pre><pre><code>  key1     data1     data20    a  0.709792 -0.2244771    b -0.244746 -0.851723key1a    0.709792b   -0.244746Name: data1, dtype: float64</code></pre><pre><code class="python">&#39;&#39;&#39;3. 按自定义key分组，列表&#39;&#39;&#39;self_def_key = [1, 1, 2, 2, 2, 1, 1, 1]df_obj.groupby(self_def_key).mean()</code></pre><table><thead><tr><th></th><th>data1</th><th>data2</th></tr></thead><tbody><tr><td>1</td><td>0.116853</td><td>-0.338455</td></tr><tr><td>2</td><td>0.743484</td><td>-0.661761</td></tr></tbody></table><pre><code class="python">df_obj</code></pre><table><thead><tr><th></th><th>key1</th><th>key2</th><th>data1</th><th>data2</th></tr></thead><tbody><tr><td>0</td><td>a</td><td>one</td><td>-0.147612</td><td>-0.348087</td></tr><tr><td>1</td><td>b</td><td>one</td><td>-0.992986</td><td>0.902458</td></tr><tr><td>2</td><td>a</td><td>two</td><td>0.547541</td><td>-0.310040</td></tr><tr><td>3</td><td>b</td><td>three</td><td>0.458871</td><td>-1.895392</td></tr><tr><td>4</td><td>a</td><td>two</td><td>1.224041</td><td>0.220150</td></tr><tr><td>5</td><td>b</td><td>two</td><td>-0.200124</td><td>-1.562237</td></tr><tr><td>6</td><td>a</td><td>one</td><td>1.539144</td><td>-0.758716</td></tr><tr><td>7</td><td>a</td><td>three</td><td>0.385845</td><td>0.074309</td></tr></tbody></table><pre><code class="python">&#39;&#39;&#39;4. 按多个列多层分组 = = = 通过列表&#39;&#39;&#39;grouped2 = df_obj.groupby([&#39;key1&#39;, &#39;key2&#39;],as_index=False)print (grouped2.mean())print(&#39;--------比较asindex的差异-------&#39;)grouped2 = df_obj.groupby([&#39;key1&#39;, &#39;key2&#39;],as_index=True)print (grouped2.mean())</code></pre><pre><code>  key1   key2     data1     data20    a    one  0.695766 -0.5534011    a  three  0.385845  0.0743092    a    two  0.885791 -0.0449453    b    one -0.992986  0.9024584    b  three  0.458871 -1.8953925    b    two -0.200124 -1.562237--------比较asindex的差异-------               data1     data2key1 key2a    one    0.695766 -0.553401     three  0.385845  0.074309     two    0.885791 -0.044945b    one   -0.992986  0.902458     three  0.458871 -1.895392     two   -0.200124 -1.562237</code></pre><pre><code class="python"># 多层分组按key的顺序进行===和上面的asindex作用一样，把所选取的列数据当成索引，这才是区别之处grouped3 = df_obj.groupby([&#39;key2&#39;, &#39;key1&#39;])print (grouped3.mean())print (&#39;=============================================&#39;)&#39;&#39;&#39;PS：如果想按照列进行分组聚合运算 === unstack===也可以通过转置&#39;&#39;&#39;print (grouped3.mean().unstack())</code></pre><pre><code>               data1     data2key2  key1one   a     0.695766 -0.553401      b    -0.992986  0.902458three a     0.385845  0.074309      b     0.458871 -1.895392two   a     0.885791 -0.044945      b    -0.200124 -1.562237=============================================          data1               data2key1          a         b         a         bkey2one    0.695766 -0.992986 -0.553401  0.902458three  0.385845  0.458871  0.074309 -1.895392two    0.885791 -0.200124 -0.044945 -1.562237</code></pre><h3 id="GroupBy-对象遍历迭代"><a href="#GroupBy-对象遍历迭代" class="headerlink" title="GroupBy 对象遍历迭代"></a>GroupBy 对象遍历迭代</h3><pre><code class="python">grouped1</code></pre><pre><code>&lt;pandas.core.groupby.generic.DataFrameGroupBy object at 0x000001AF5B5F9088&gt;</code></pre><pre><code class="python"># 单层分组print(grouped1.head(5))print(&quot;------------------------------------分割线------------------------------------------&quot;)for group_name, group_data in grouped1:    print (group_name)    print (group_data[&#39;data1&#39;])</code></pre><pre><code>  key1   key2     data1     data20    a    one -0.147612 -0.3480871    b    one -0.992986  0.9024582    a    two  0.547541 -0.3100403    b  three  0.458871 -1.8953924    a    two  1.224041  0.2201505    b    two -0.200124 -1.5622376    a    one  1.539144 -0.7587167    a  three  0.385845  0.074309------------------------------------分割线------------------------------------------a0   -0.1476122    0.5475414    1.2240416    1.5391447    0.385845Name: data1, dtype: float64b1   -0.9929863    0.4588715   -0.200124Name: data1, dtype: float64</code></pre><pre><code class="python"># 多层分组for group_name, group_data in grouped2:    print (group_name)    print (group_data)</code></pre><pre><code>(&#39;a&#39;, &#39;one&#39;)  key1 key2     data1     data20    a  one -0.147612 -0.3480876    a  one  1.539144 -0.758716(&#39;a&#39;, &#39;three&#39;)  key1   key2     data1     data27    a  three  0.385845  0.074309(&#39;a&#39;, &#39;two&#39;)  key1 key2     data1    data22    a  two  0.547541 -0.310044    a  two  1.224041  0.22015(&#39;b&#39;, &#39;one&#39;)  key1 key2     data1     data21    b  one -0.992986  0.902458(&#39;b&#39;, &#39;three&#39;)  key1   key2     data1     data23    b  three  0.458871 -1.895392(&#39;b&#39;, &#39;two&#39;)  key1 key2     data1     data25    b  two -0.200124 -1.562237</code></pre><pre><code class="python"># GroupBy对象转换listprint(grouped1.mean())list(grouped1)</code></pre><pre><code>  key1     data1     data20    a  0.709792 -0.2244771    b -0.244746 -0.851723[(&#39;a&#39;,   key1   key2     data1     data2  0    a    one -0.147612 -0.348087  2    a    two  0.547541 -0.310040  4    a    two  1.224041  0.220150  6    a    one  1.539144 -0.758716  7    a  three  0.385845  0.074309), (&#39;b&#39;,   key1   key2     data1     data2  1    b    one -0.992986  0.902458  3    b  three  0.458871 -1.895392  5    b    two -0.200124 -1.562237)]</code></pre><pre><code class="python"># GroupBy对象转换dictdict(list(grouped1))</code></pre><pre><code>&#123;&#39;a&#39;:   key1   key2     data1     data2 0    a    one -0.147612 -0.348087 2    a    two  0.547541 -0.310040 4    a    two  1.224041  0.220150 6    a    one  1.539144 -0.758716 7    a  three  0.385845  0.074309, &#39;b&#39;:   key1   key2     data1     data2 1    b    one -0.992986  0.902458 3    b  three  0.458871 -1.895392 5    b    two -0.200124 -1.562237&#125;</code></pre><pre><code class="python"># 按列分组print (df_obj.dtypes)# 按数据类型分组df_obj.groupby(df_obj.dtypes, axis=1).size()df_obj.groupby(df_obj.dtypes, axis=1).sum()</code></pre><pre><code>key1      objectkey2      objectdata1    float64data2    float64dtype: object</code></pre><h3 id="其他分组方法"><a href="#其他分组方法" class="headerlink" title="其他分组方法"></a>其他分组方法</h3><ol><li>其实列表也是分组的一种方式<br>===用到列表时候，一般都是多层索引了</li></ol><pre><code class="python">df_obj2 = pd.DataFrame(np.random.randint(1, 10, (5,5)),                       columns=[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;],                       index=[&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;])df_obj2.ix[1, 1:4] = np.NaNdf_obj2</code></pre><pre><code>C:\Users\wztli\Anaconda3\lib\site-packages\ipykernel_launcher.py:4: FutureWarning:.ix is deprecated. Please use.loc for label based indexing or.iloc for positional indexingSee the documentation here:http://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#ix-indexer-is-deprecated  after removing the cwd from sys.path.</code></pre><table><thead><tr><th></th><th>a</th><th>b</th><th>c</th><th>d</th><th>e</th></tr></thead><tbody><tr><td>A</td><td>4</td><td>2.0</td><td>6.0</td><td>5.0</td><td>9</td></tr><tr><td>B</td><td>5</td><td>NaN</td><td>NaN</td><td>NaN</td><td>6</td></tr><tr><td>C</td><td>2</td><td>3.0</td><td>8.0</td><td>6.0</td><td>3</td></tr><tr><td>D</td><td>9</td><td>5.0</td><td>6.0</td><td>5.0</td><td>9</td></tr><tr><td>E</td><td>4</td><td>1.0</td><td>6.0</td><td>2.0</td><td>1</td></tr></tbody></table><ol><li>通过字典分组</li></ol><pre><code class="python"># 通过字典分组mapping_dict = &#123;&#39;A&#39;:&#39;python&#39;, &#39;B&#39;:&#39;python&#39;, &#39;C&#39;:&#39;java&#39;, &#39;D&#39;:&#39;C&#39;, &#39;E&#39;:&#39;java&#39;&#125;#df_obj2.groupby(mapping_dict, axis=1).size()#df_obj2.groupby(mapping_dict, axis=1).count() # 非NaN的个数print(df_obj2.groupby(mapping_dict, axis=0).sum())</code></pre><pre><code>        a    b     c    d   eC       9  5.0   6.0  5.0   9java    6  4.0  14.0  8.0   4python  9  2.0   6.0  5.0  15</code></pre><ol start="2"><li>通过函数分组</li></ol><pre><code class="python"># 通过函数分组df_obj3 = pd.DataFrame(np.random.randint(1, 10, (5,5)),                       columns=[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;],                       index=[&#39;AA&#39;, &#39;BBB&#39;, &#39;CC&#39;, &#39;D&#39;, &#39;EE&#39;])#df_obj3def group_key(idx):    &quot;&quot;&quot;        idx 为列索引或行索引    &quot;&quot;&quot;    #return idx    return len(idx)df_obj3.groupby(group_key).size()# 以上自定义函数等价于#df_obj3.groupby(len).size()</code></pre><pre><code>1    12    33    1dtype: int64</code></pre><ol start="3"><li>通过层级索引级别分组</li></ol><pre><code class="python"># 通过索引级别分组columns = pd.MultiIndex.from_arrays([[&#39;Python&#39;, &#39;Java&#39;, &#39;Python&#39;, &#39;Java&#39;, &#39;Python&#39;],                                     [&#39;A&#39;, &#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;B&#39;]], names=[&#39;language&#39;, &#39;index&#39;])df_obj4 = pd.DataFrame(np.random.randint(1, 10, (5, 5)), columns=columns)df_obj4</code></pre><table><thead><tr><th>language</th><th>Python</th><th>Java</th><th>Python</th><th>Java</th><th>Python</th></tr></thead><tbody><tr><td>index</td><td>A</td><td>A</td><td>B</td><td>C</td><td>B</td></tr><tr><td>0</td><td>4</td><td>6</td><td>8</td><td>8</td><td>4</td></tr><tr><td>1</td><td>1</td><td>3</td><td>2</td><td>3</td><td>5</td></tr><tr><td>2</td><td>3</td><td>1</td><td>1</td><td>5</td><td>6</td></tr><tr><td>3</td><td>2</td><td>9</td><td>3</td><td>1</td><td>9</td></tr><tr><td>4</td><td>4</td><td>1</td><td>5</td><td>6</td><td>6</td></tr></tbody></table><pre><code class="python"># 根据language进行分组df_obj4.groupby(level=&#39;language&#39;, axis=1).sum()df_obj4.groupby(level=&#39;index&#39;, axis=1).sum()</code></pre><table><thead><tr><th>index</th><th>A</th><th>B</th><th>C</th></tr></thead><tbody><tr><td>0</td><td>10</td><td>12</td><td>8</td></tr><tr><td>1</td><td>4</td><td>7</td><td>3</td></tr><tr><td>2</td><td>4</td><td>7</td><td>5</td></tr><tr><td>3</td><td>11</td><td>12</td><td>1</td></tr><tr><td>4</td><td>5</td><td>11</td><td>6</td></tr></tbody></table><h2 id="二、聚合"><a href="#二、聚合" class="headerlink" title="二、聚合"></a>二、聚合</h2><pre><code class="python">dict_obj = &#123;&#39;key1&#39; : [&#39;a&#39;, &#39;b&#39;, &#39;a&#39;, &#39;b&#39;,                      &#39;a&#39;, &#39;b&#39;, &#39;a&#39;, &#39;a&#39;],            &#39;key2&#39; : [&#39;one&#39;, &#39;one&#39;, &#39;two&#39;, &#39;three&#39;,                      &#39;two&#39;, &#39;two&#39;, &#39;one&#39;, &#39;three&#39;],            &#39;data1&#39;: np.random.randint(1,10, 8),            &#39;data2&#39;: np.random.randint(1,10, 8)&#125;df_obj5 = pd.DataFrame(dict_obj)print (df_obj5)</code></pre><pre><code>  key1   key2  data1  data20    a    one      9      41    b    one      6      72    a    two      9      43    b  three      9      64    a    two      6      25    b    two      3      36    a    one      1      17    a  three      2      6</code></pre><h3 id="内置的聚合函数"><a href="#内置的聚合函数" class="headerlink" title="内置的聚合函数"></a>内置的聚合函数</h3><pre><code class="python">df_obj5</code></pre><table><thead><tr><th></th><th>key1</th><th>key2</th><th>data1</th><th>data2</th></tr></thead><tbody><tr><td>0</td><td>a</td><td>one</td><td>9</td><td>4</td></tr><tr><td>1</td><td>b</td><td>one</td><td>6</td><td>7</td></tr><tr><td>2</td><td>a</td><td>two</td><td>9</td><td>4</td></tr><tr><td>3</td><td>b</td><td>three</td><td>9</td><td>6</td></tr><tr><td>4</td><td>a</td><td>two</td><td>6</td><td>2</td></tr><tr><td>5</td><td>b</td><td>two</td><td>3</td><td>3</td></tr><tr><td>6</td><td>a</td><td>one</td><td>1</td><td>1</td></tr><tr><td>7</td><td>a</td><td>three</td><td>2</td><td>6</td></tr></tbody></table><pre><code class="python"># 内置的聚合函数#print (df_obj5.groupby(&#39;key1&#39;).sum())#print (df_obj5.groupby(&#39;key1&#39;).max())#print (df_obj5.groupby(&#39;key1&#39;).min())print (df_obj5.groupby(&#39;key1&#39;).mean())#print (df_obj5.groupby(&#39;key1&#39;).size())#print (df_obj5.groupby(&#39;key1&#39;).count())#print (df_obj5.groupby(&#39;key1&#39;).describe())&#39;&#39;&#39;count：分组中非NA的值std：标准差var：方差median：非NA中的中位数mean：非NA的平均值25%||50%||75%是什么意思==不造？&#39;&#39;&#39;</code></pre><pre><code>      data1     data2key1a       5.4  3.400000b       6.0  5.333333&#39;\ncount：分组中非NA的值\nstd：标准差\nvar：方差\nmedian：非NA中的中位数\nmean：非NA的平均值\n25%||50%||75%是什么意思==不造？\n&#39;</code></pre><h3 id="自定义聚合函数"><a href="#自定义聚合函数" class="headerlink" title="自定义聚合函数"></a>自定义聚合函数</h3><pre><code class="python"># 自定义聚合函数def peak_range(df):    &quot;&quot;&quot;        返回数值范围    &quot;&quot;&quot;    #print type(df) #参数为索引所对应的记录    return df.max() - df.min()print (df_obj5.groupby(&#39;key1&#39;).agg(peak_range))#print df_obj.groupby(&#39;key1&#39;).agg(lambda df : df.max() - df.min())#默认列名就是函数名。</code></pre><pre><code>      data1  data2key1a         8      5b         6      4</code></pre><ol start="3"><li>同时应用多个聚合函数：agg</li></ol><pre><code class="python"># 同时应用多个聚合函数：aggprint (df_obj.groupby(&#39;key1&#39;).agg([&#39;mean&#39;, &#39;std&#39;, &#39;count&#39;]))</code></pre><pre><code>         data1                     data2          mean       std count      mean       std countkey1a     0.709792  0.674293     5 -0.224477  0.385674     5b    -0.244746  0.726957     3 -0.851723  1.528271     3</code></pre><pre><code class="python">print (df_obj.groupby(&#39;key1&#39;).agg([&#39;mean&#39;, &#39;std&#39;, &#39;count&#39;, (&#39;range&#39;, peak_range)])) # 通过元组提供新的列名</code></pre><pre><code>         data1                               data2          mean       std count     range      mean       std count     rangekey1a     0.709792  0.674293     5  1.686756 -0.224477  0.385674     5  0.978865b    -0.244746  0.726957     3  1.451857 -0.851723  1.528271     3  2.797850</code></pre><pre><code class="python"># 每列作用不同的聚合函数dict_mapping = &#123;&#39;data1&#39;:&#39;mean&#39;,                &#39;data2&#39;:&#39;sum&#39;&#125;print (df_obj.groupby(&#39;key1&#39;).agg(dict_mapping))</code></pre><pre><code>         data1     data2key1a     0.709792 -1.122384b    -0.244746 -2.555170</code></pre><pre><code class="python">dict_mapping = &#123;&#39;data1&#39;:[&#39;mean&#39;,&#39;max&#39;],                &#39;data2&#39;:&#39;sum&#39;&#125;print (df_obj.groupby(&#39;key1&#39;).agg(dict_mapping))</code></pre><pre><code>         data1               data2          mean       max       sumkey1a     0.709792  1.539144 -1.122384b    -0.244746  0.458871 -2.555170</code></pre><h2 id="三、分组运算"><a href="#三、分组运算" class="headerlink" title="三、分组运算"></a>三、分组运算</h2><pre><code class="python">import pandas as pdimport numpy as np</code></pre><h3 id="分组和对齐"><a href="#分组和对齐" class="headerlink" title="分组和对齐"></a>分组和对齐</h3><pre><code class="python">s1 = pd.Series(range(10, 20), index = range(10))s2 = pd.Series(range(20, 25), index = range(5))print (&#39;s1: &#39; )print (s1)print(&#39;===========================&#39;)print (&#39;s2: &#39;)print (s2)</code></pre><pre><code>s1:0    101    112    123    134    145    156    167    178    189    19dtype: int64===========================s2:0    201    212    223    234    24dtype: int64</code></pre><pre><code class="python"># Series 对齐运算s1 + s2print(s1+s2)</code></pre><pre><code>0    30.01    32.02    34.03    36.04    38.05     NaN6     NaN7     NaN8     NaN9     NaNdtype: float64</code></pre><pre><code class="python">df1 = pd.DataFrame(np.ones((2,2)), columns = [&#39;a&#39;, &#39;b&#39;])df2 = pd.DataFrame(np.ones((3,3)), columns = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;])print (&#39;df1: &#39;)print (df1)print (&#39;=================&#39;)print (&#39;df2: &#39;)print (df2)</code></pre><pre><code>df1:     a    b0  1.0  1.01  1.0  1.0=================df2:     a    b    c0  1.0  1.0  1.01  1.0  1.0  1.02  1.0  1.0  1.0</code></pre><pre><code class="python"># DataFrame对齐操作print(df1 + df2)</code></pre><pre><code>     a    b   c0  2.0  2.0 NaN1  2.0  2.0 NaN2  NaN  NaN NaN</code></pre><p>① 常用运算函数</p><pre><code class="python"># 填充未对齐的数据进行运算print(s1.add(s2, fill_value = -1))</code></pre><pre><code>0    30.01    32.02    34.03    36.04    38.05    14.06    15.07    16.08    17.09    18.0dtype: float64</code></pre><pre><code class="python">df1.sub(df2, fill_value = 2.)#sub函数</code></pre><table><thead><tr><th></th><th>a</th><th>b</th><th>c</th></tr></thead><tbody><tr><td>0</td><td>0.0</td><td>0.0</td><td>1.0</td></tr><tr><td>1</td><td>0.0</td><td>0.0</td><td>1.0</td></tr><tr><td>2</td><td>1.0</td><td>1.0</td><td>1.0</td></tr></tbody></table><pre><code class="python"># 填充NaNs3 = s1 + s2print (s3)</code></pre><pre><code>0    30.01    32.02    34.03    36.04    38.05     NaN6     NaN7     NaN8     NaN9     NaNdtype: float64</code></pre><pre><code class="python">s3_filled = s3.fillna(-1)print (s3)</code></pre><pre><code>0    30.01    32.02    34.03    36.04    38.05     NaN6     NaN7     NaN8     NaN9     NaNdtype: float64</code></pre><pre><code class="python">df3 = df1 + df2print (df3)</code></pre><pre><code>     a    b   c0  2.0  2.0 NaN1  2.0  2.0 NaN2  NaN  NaN NaN</code></pre><pre><code class="python">df3.fillna(100, inplace = True)print (df3)</code></pre><pre><code>       a      b      c0    2.0    2.0  100.01    2.0    2.0  100.02  100.0  100.0  100.0</code></pre><h3 id="统计计算-VS-聚合运算"><a href="#统计计算-VS-聚合运算" class="headerlink" title="统计计算 VS 聚合运算"></a>统计计算 VS 聚合运算</h3><pre><code class="python">df_obj1 = pd.DataFrame(np.random.randn(5,4), columns = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;])print(df_obj1)</code></pre><pre><code>          a         b         c         d0 -0.542708  0.201376  1.111431  1.7843241  0.583422  0.231096 -2.801967  0.5684972 -0.577329 -1.668581 -0.842126  1.8030803 -0.128431 -1.769619  2.089983  0.2097614  0.493981 -1.571405  0.690019 -0.215292</code></pre><pre><code class="python">print(df_obj1.sum(axis=1))print(&#39;=====================================&#39;)print(df_obj1.max())print(&#39;=====================================&#39;)print(df_obj1.min(axis=1))</code></pre><pre><code>0    2.5544231   -1.4189522   -1.2849563    0.4016944   -0.602698dtype: float64=====================================a    0.583422b    0.231096c    2.089983d    1.803080dtype: float64=====================================0   -0.5427081   -2.8019672   -1.6685813   -1.7696194   -1.571405dtype: float64</code></pre><h3 id="数据分组运算"><a href="#数据分组运算" class="headerlink" title="数据分组运算"></a>数据分组运算</h3><pre><code class="python"># 分组运算后保持shapedict_obj = &#123;&#39;key1&#39; : [&#39;a&#39;, &#39;b&#39;, &#39;a&#39;, &#39;b&#39;,                      &#39;a&#39;, &#39;b&#39;, &#39;a&#39;, &#39;a&#39;],            &#39;key2&#39; : [&#39;one&#39;, &#39;one&#39;, &#39;two&#39;, &#39;three&#39;,                      &#39;two&#39;, &#39;two&#39;, &#39;one&#39;, &#39;three&#39;],            &#39;data1&#39;: np.random.randint(1, 10, 8),            &#39;data2&#39;: np.random.randint(1, 10, 8)&#125;df_obj = pd.DataFrame(dict_obj)df_obj</code></pre><table><thead><tr><th></th><th>key1</th><th>key2</th><th>data1</th><th>data2</th></tr></thead><tbody><tr><td>0</td><td>a</td><td>one</td><td>4</td><td>3</td></tr><tr><td>1</td><td>b</td><td>one</td><td>4</td><td>4</td></tr><tr><td>2</td><td>a</td><td>two</td><td>9</td><td>6</td></tr><tr><td>3</td><td>b</td><td>three</td><td>8</td><td>2</td></tr><tr><td>4</td><td>a</td><td>two</td><td>3</td><td>3</td></tr><tr><td>5</td><td>b</td><td>two</td><td>6</td><td>2</td></tr><tr><td>6</td><td>a</td><td>one</td><td>4</td><td>1</td></tr><tr><td>7</td><td>a</td><td>three</td><td>2</td><td>2</td></tr></tbody></table><pre><code class="python"># 按key1分组后，计算data1，data2的统计信息======并附加到原始表格中k1_sum = df_obj.groupby(&#39;key1&#39;).sum().add_prefix(&#39;sum_&#39;)print(k1_sum)print(&#39;================================&#39;)print(df_obj)</code></pre><pre><code>      sum_data1  sum_data2key1a            22         15b            18          8================================  key1   key2  data1  data20    a    one      4      31    b    one      4      42    a    two      9      63    b  three      8      24    a    two      3      35    b    two      6      26    a    one      4      17    a  three      2      2</code></pre><ol><li>merge 方法</li></ol><pre><code class="python"># 方法1，使用mergepd.merge(df_obj, k1_sum, left_on=&#39;key1&#39;, right_index=True)</code></pre><table><thead><tr><th></th><th>key1</th><th>key2</th><th>data1</th><th>data2</th><th>sum_data1</th><th>sum_data2</th></tr></thead><tbody><tr><td>0</td><td>a</td><td>one</td><td>4</td><td>3</td><td>22</td><td>15</td></tr><tr><td>2</td><td>a</td><td>two</td><td>9</td><td>6</td><td>22</td><td>15</td></tr><tr><td>4</td><td>a</td><td>two</td><td>3</td><td>3</td><td>22</td><td>15</td></tr><tr><td>6</td><td>a</td><td>one</td><td>4</td><td>1</td><td>22</td><td>15</td></tr><tr><td>7</td><td>a</td><td>three</td><td>2</td><td>2</td><td>22</td><td>15</td></tr><tr><td>1</td><td>b</td><td>one</td><td>4</td><td>4</td><td>18</td><td>8</td></tr><tr><td>3</td><td>b</td><td>three</td><td>8</td><td>2</td><td>18</td><td>8</td></tr><tr><td>5</td><td>b</td><td>two</td><td>6</td><td>2</td><td>18</td><td>8</td></tr></tbody></table><ol start="2"><li>transform 方法</li></ol><pre><code class="python"># 方法2，使用transformk1_sum_tf = df_obj.groupby(&#39;key1&#39;).transform(np.sum).add_prefix(&#39;sum_&#39;)df_obj[k1_sum_tf.columns] = k1_sum_tfdf_obj</code></pre><table><thead><tr><th></th><th>key1</th><th>key2</th><th>data1</th><th>data2</th><th>sum_key2</th><th>sum_data1</th><th>sum_data2</th></tr></thead><tbody><tr><td>0</td><td>a</td><td>one</td><td>4</td><td>3</td><td>onetwotwoonethree</td><td>22</td><td>15</td></tr><tr><td>1</td><td>b</td><td>one</td><td>4</td><td>4</td><td>onethreetwo</td><td>18</td><td>8</td></tr><tr><td>2</td><td>a</td><td>two</td><td>9</td><td>6</td><td>onetwotwoonethree</td><td>22</td><td>15</td></tr><tr><td>3</td><td>b</td><td>three</td><td>8</td><td>2</td><td>onethreetwo</td><td>18</td><td>8</td></tr><tr><td>4</td><td>a</td><td>two</td><td>3</td><td>3</td><td>onetwotwoonethree</td><td>22</td><td>15</td></tr><tr><td>5</td><td>b</td><td>two</td><td>6</td><td>2</td><td>onethreetwo</td><td>18</td><td>8</td></tr><tr><td>6</td><td>a</td><td>one</td><td>4</td><td>1</td><td>onetwotwoonethree</td><td>22</td><td>15</td></tr><tr><td>7</td><td>a</td><td>three</td><td>2</td><td>2</td><td>onetwotwoonethree</td><td>22</td><td>15</td></tr></tbody></table><ol start="3"><li>自定义函数</li></ol><pre><code class="python"># 自定义函数传入transformdef diff_mean(s):    &quot;&quot;&quot;        返回数据与均值的差值    &quot;&quot;&quot;    return s - s.mean()df_obj.groupby(&#39;key1&#39;).transform(diff_mean)</code></pre><table><thead><tr><th></th><th>data1</th><th>data2</th><th>sum_data1</th><th>sum_data2</th></tr></thead><tbody><tr><td>0</td><td>-0.4</td><td>0.000000</td><td>0</td><td>0</td></tr><tr><td>1</td><td>-2.0</td><td>1.333333</td><td>0</td><td>0</td></tr><tr><td>2</td><td>4.6</td><td>3.000000</td><td>0</td><td>0</td></tr><tr><td>3</td><td>2.0</td><td>-0.666667</td><td>0</td><td>0</td></tr><tr><td>4</td><td>-1.4</td><td>0.000000</td><td>0</td><td>0</td></tr><tr><td>5</td><td>0.0</td><td>-0.666667</td><td>0</td><td>0</td></tr><tr><td>6</td><td>-0.4</td><td>-2.000000</td><td>0</td><td>0</td></tr><tr><td>7</td><td>-2.4</td><td>-1.000000</td><td>0</td><td>0</td></tr></tbody></table><pre><code class="python">dataset_path = &#39;./data/starcraft.csv&#39;df_data = pd.read_csv(dataset_path, usecols=[&#39;LeagueIndex&#39;, &#39;Age&#39;, &#39;HoursPerWeek&#39;,                                             &#39;TotalHours&#39;, &#39;APM&#39;])</code></pre><ul><li>apply</li></ul><pre><code class="python">def top_n(df, n=3, column=&#39;APM&#39;):    &quot;&quot;&quot;        返回每个分组按 column 的 top n 数据    &quot;&quot;&quot;    return df.sort_values(by=column, ascending=False)[:n]df_data.groupby(&#39;LeagueIndex&#39;).apply(top_n)</code></pre><table><thead><tr><th></th><th></th><th>LeagueIndex</th><th>Age</th><th>HoursPerWeek</th><th>TotalHours</th><th>APM</th></tr></thead><tbody><tr><td>LeagueIndex</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>1</td><td>2214</td><td>1</td><td>20.0</td><td>12.0</td><td>730.0</td><td>172.9530</td></tr><tr><td></td><td>2246</td><td>1</td><td>27.0</td><td>8.0</td><td>250.0</td><td>141.6282</td></tr><tr><td></td><td>1753</td><td>1</td><td>20.0</td><td>28.0</td><td>100.0</td><td>139.6362</td></tr><tr><td>2</td><td>3062</td><td>2</td><td>20.0</td><td>6.0</td><td>100.0</td><td>179.6250</td></tr><tr><td></td><td>3229</td><td>2</td><td>16.0</td><td>24.0</td><td>110.0</td><td>156.7380</td></tr><tr><td></td><td>1520</td><td>2</td><td>29.0</td><td>6.0</td><td>250.0</td><td>151.6470</td></tr><tr><td>3</td><td>1557</td><td>3</td><td>22.0</td><td>6.0</td><td>200.0</td><td>226.6554</td></tr><tr><td></td><td>484</td><td>3</td><td>19.0</td><td>42.0</td><td>450.0</td><td>220.0692</td></tr><tr><td></td><td>2883</td><td>3</td><td>16.0</td><td>8.0</td><td>800.0</td><td>208.9500</td></tr><tr><td>4</td><td>2688</td><td>4</td><td>26.0</td><td>24.0</td><td>990.0</td><td>249.0210</td></tr><tr><td></td><td>1759</td><td>4</td><td>16.0</td><td>6.0</td><td>75.0</td><td>229.9122</td></tr><tr><td></td><td>2637</td><td>4</td><td>23.0</td><td>24.0</td><td>650.0</td><td>227.2272</td></tr><tr><td>5</td><td>3277</td><td>5</td><td>18.0</td><td>16.0</td><td>950.0</td><td>372.6426</td></tr><tr><td></td><td>93</td><td>5</td><td>17.0</td><td>36.0</td><td>720.0</td><td>335.4990</td></tr><tr><td></td><td>202</td><td>5</td><td>37.0</td><td>14.0</td><td>800.0</td><td>327.7218</td></tr><tr><td>6</td><td>734</td><td>6</td><td>16.0</td><td>28.0</td><td>730.0</td><td>389.8314</td></tr><tr><td></td><td>2746</td><td>6</td><td>16.0</td><td>28.0</td><td>4000.0</td><td>350.4114</td></tr><tr><td></td><td>1810</td><td>6</td><td>21.0</td><td>14.0</td><td>730.0</td><td>323.2506</td></tr><tr><td>7</td><td>3127</td><td>7</td><td>23.0</td><td>42.0</td><td>2000.0</td><td>298.7952</td></tr><tr><td></td><td>104</td><td>7</td><td>21.0</td><td>24.0</td><td>1000.0</td><td>286.4538</td></tr><tr><td></td><td>1654</td><td>7</td><td>18.0</td><td>98.0</td><td>700.0</td><td>236.0316</td></tr><tr><td>8</td><td>3393</td><td>8</td><td>NaN</td><td>NaN</td><td>NaN</td><td>375.8664</td></tr><tr><td></td><td>3373</td><td>8</td><td>NaN</td><td>NaN</td><td>NaN</td><td>364.8504</td></tr><tr><td></td><td>3372</td><td>8</td><td>NaN</td><td>NaN</td><td>NaN</td><td>355.3518</td></tr></tbody></table><pre><code class="python"># apply函数接收的参数会传入自定义的函数中df_data.groupby(&#39;LeagueIndex&#39;).apply(top_n, n=2, column=&#39;Age&#39;)</code></pre><table><thead><tr><th></th><th></th><th>LeagueIndex</th><th>Age</th><th>HoursPerWeek</th><th>TotalHours</th><th>APM</th></tr></thead><tbody><tr><td>LeagueIndex</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>1</td><td>3146</td><td>1</td><td>40.0</td><td>12.0</td><td>150.0</td><td>38.5590</td></tr><tr><td></td><td>3040</td><td>1</td><td>39.0</td><td>10.0</td><td>500.0</td><td>29.8764</td></tr><tr><td>2</td><td>920</td><td>2</td><td>43.0</td><td>10.0</td><td>730.0</td><td>86.0586</td></tr><tr><td></td><td>2437</td><td>2</td><td>41.0</td><td>4.0</td><td>200.0</td><td>54.2166</td></tr><tr><td>3</td><td>1258</td><td>3</td><td>41.0</td><td>14.0</td><td>800.0</td><td>77.6472</td></tr><tr><td></td><td>2972</td><td>3</td><td>40.0</td><td>10.0</td><td>500.0</td><td>60.5970</td></tr><tr><td>4</td><td>1696</td><td>4</td><td>44.0</td><td>6.0</td><td>500.0</td><td>89.5266</td></tr><tr><td></td><td>1729</td><td>4</td><td>39.0</td><td>8.0</td><td>500.0</td><td>86.7246</td></tr><tr><td>5</td><td>202</td><td>5</td><td>37.0</td><td>14.0</td><td>800.0</td><td>327.7218</td></tr><tr><td></td><td>2745</td><td>5</td><td>37.0</td><td>18.0</td><td>1000.0</td><td>123.4098</td></tr><tr><td>6</td><td>3069</td><td>6</td><td>31.0</td><td>8.0</td><td>800.0</td><td>133.1790</td></tr><tr><td></td><td>2706</td><td>6</td><td>31.0</td><td>8.0</td><td>700.0</td><td>66.9918</td></tr><tr><td>7</td><td>2813</td><td>7</td><td>26.0</td><td>36.0</td><td>1300.0</td><td>188.5512</td></tr><tr><td></td><td>1992</td><td>7</td><td>26.0</td><td>24.0</td><td>1000.0</td><td>219.6690</td></tr><tr><td>8</td><td>3340</td><td>8</td><td>NaN</td><td>NaN</td><td>NaN</td><td>189.7404</td></tr><tr><td></td><td>3341</td><td>8</td><td>NaN</td><td>NaN</td><td>NaN</td><td>287.8128</td></tr></tbody></table><ul><li>禁止分组 group_keys=False</li></ul><pre><code class="python">df_data.groupby(&#39;LeagueIndex&#39;, group_keys=False).apply(top_n)</code></pre><table><thead><tr><th></th><th>LeagueIndex</th><th>Age</th><th>HoursPerWeek</th><th>TotalHours</th><th>APM</th></tr></thead><tbody><tr><td>2214</td><td>1</td><td>20.0</td><td>12.0</td><td>730.0</td><td>172.9530</td></tr><tr><td>2246</td><td>1</td><td>27.0</td><td>8.0</td><td>250.0</td><td>141.6282</td></tr><tr><td>1753</td><td>1</td><td>20.0</td><td>28.0</td><td>100.0</td><td>139.6362</td></tr><tr><td>3062</td><td>2</td><td>20.0</td><td>6.0</td><td>100.0</td><td>179.6250</td></tr><tr><td>3229</td><td>2</td><td>16.0</td><td>24.0</td><td>110.0</td><td>156.7380</td></tr><tr><td>1520</td><td>2</td><td>29.0</td><td>6.0</td><td>250.0</td><td>151.6470</td></tr><tr><td>1557</td><td>3</td><td>22.0</td><td>6.0</td><td>200.0</td><td>226.6554</td></tr><tr><td>484</td><td>3</td><td>19.0</td><td>42.0</td><td>450.0</td><td>220.0692</td></tr><tr><td>2883</td><td>3</td><td>16.0</td><td>8.0</td><td>800.0</td><td>208.9500</td></tr><tr><td>2688</td><td>4</td><td>26.0</td><td>24.0</td><td>990.0</td><td>249.0210</td></tr><tr><td>1759</td><td>4</td><td>16.0</td><td>6.0</td><td>75.0</td><td>229.9122</td></tr><tr><td>2637</td><td>4</td><td>23.0</td><td>24.0</td><td>650.0</td><td>227.2272</td></tr><tr><td>3277</td><td>5</td><td>18.0</td><td>16.0</td><td>950.0</td><td>372.6426</td></tr><tr><td>93</td><td>5</td><td>17.0</td><td>36.0</td><td>720.0</td><td>335.4990</td></tr><tr><td>202</td><td>5</td><td>37.0</td><td>14.0</td><td>800.0</td><td>327.7218</td></tr><tr><td>734</td><td>6</td><td>16.0</td><td>28.0</td><td>730.0</td><td>389.8314</td></tr><tr><td>2746</td><td>6</td><td>16.0</td><td>28.0</td><td>4000.0</td><td>350.4114</td></tr><tr><td>1810</td><td>6</td><td>21.0</td><td>14.0</td><td>730.0</td><td>323.2506</td></tr><tr><td>3127</td><td>7</td><td>23.0</td><td>42.0</td><td>2000.0</td><td>298.7952</td></tr><tr><td>104</td><td>7</td><td>21.0</td><td>24.0</td><td>1000.0</td><td>286.4538</td></tr><tr><td>1654</td><td>7</td><td>18.0</td><td>98.0</td><td>700.0</td><td>236.0316</td></tr><tr><td>3393</td><td>8</td><td>NaN</td><td>NaN</td><td>NaN</td><td>375.8664</td></tr><tr><td>3373</td><td>8</td><td>NaN</td><td>NaN</td><td>NaN</td><td>364.8504</td></tr><tr><td>3372</td><td>8</td><td>NaN</td><td>NaN</td><td>NaN</td><td>355.3518</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> ✨其他 </category>
          
          <category> 数据分析 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Numpy库使用</title>
      <link href="/blog/mk2z96/"/>
      <url>/blog/mk2z96/</url>
      
        <content type="html"><![CDATA[<h2 id="一、NumPy"><a href="#一、NumPy" class="headerlink" title="一、NumPy"></a>一、NumPy</h2><h3 id="ndarray-理解多维数组"><a href="#ndarray-理解多维数组" class="headerlink" title="ndarray 理解多维数组"></a>ndarray 理解多维数组</h3><pre><code class="python">import numpy as np# 生成指定维度的随机多维数据#数学建模应该用不到data = np.random.rand(2, 3)print (data)print (type(data))#type是显示数据类型；shape显示维度；ndim维度个数;type另外的作用</code></pre><pre><code>[[0.46686682 0.68844304 0.76663872] [0.70747721 0.47887587 0.25943412]]&lt;class &#39;numpy.ndarray&#39;&gt;</code></pre><blockquote><p>ndim, shape 和 dtype 属性</p></blockquote><pre><code class="python">print (&#39;维度个数&#39;, data.ndim)print (&#39;各维度大小: &#39;, data.shape)print (&#39;数据类型: &#39;, data.dtype)</code></pre><pre><code>维度个数 2各维度大小:  (2, 3)数据类型:  float64</code></pre><h3 id="创建-ndarray"><a href="#创建-ndarray" class="headerlink" title="创建 ndarray"></a>创建 ndarray</h3><pre><code class="python">&#39;&#39;&#39;1. array创建&#39;&#39;&#39;# list转换为 ndarrayl = range(10)data = np.array(l)print (data)print (data.shape)print (data.ndim)</code></pre><pre><code>[0 1 2 3 4 5 6 7 8 9](10,)1</code></pre><pre><code class="python"># 嵌套序列转换为ndarrayl2 = [range(10), range(10)]#就这样形成了一个数组data = np.array(l2)print (data)print (data.shape)</code></pre><pre><code>[[0 1 2 3 4 5 6 7 8 9] [0 1 2 3 4 5 6 7 8 9]](2, 10)</code></pre><pre><code class="python">&#39;&#39;&#39;2. zeros;ones;empty创建&#39;&#39;&#39;# np.zeroszeros_arr = np.zeros((3, 4))#注意元组，这里经常报错# np.onesones_arr = np.ones((2, 3))# np.empty[不全为零，而且是随机的一些数字]empty_arr = np.empty((3, 3))# np.empty 指定数据类型empty_int_arr = np.empty((3, 3), int)print (zeros_arr)print (&#39;-------------&#39;)print (ones_arr)print (&#39;-------------&#39;)print (empty_arr)print (&#39;-------------&#39;)print (empty_int_arr)</code></pre><pre><code>[[0. 0. 0. 0.] [0. 0. 0. 0.] [0. 0. 0. 0.]]-------------[[1. 1. 1.] [1. 1. 1.]]-------------[[0.000e+000 0.000e+000 0.000e+000] [0.000e+000 0.000e+000 2.174e-321] [0.000e+000 0.000e+000 0.000e+000]]-------------[[0 0 0] [0 0 0] [0 0 0]]</code></pre><pre><code class="python"># np.arange()#创建一系列连续的数算是numpy里面类似python里面range的功能print (np.arange(10))</code></pre><pre><code>[0 1 2 3 4 5 6 7 8 9]</code></pre><h2 id="二、操作-nddarray"><a href="#二、操作-nddarray" class="headerlink" title="二、操作 nddarray"></a>二、操作 nddarray</h2><h3 id="矢量化-vectorization"><a href="#矢量化-vectorization" class="headerlink" title="矢量化 (vectorization)"></a>矢量化 (vectorization)</h3><pre><code class="python"># 矢量与矢量运算arr = np.array([[1, 2, 3],                [4, 5, 6]])print (&quot;元素之间相乘：&quot;)#注意区分矩阵之间的运算。这里的矢量原酸相当于是广播式的运算print (arr * arr)print (&quot;矩阵相加：&quot;)print (arr + arr)</code></pre><pre><code>元素之间相乘：[[ 1  4  9] [16 25 36]]矩阵相加：[[ 2  4  6] [ 8 10 12]]</code></pre><pre><code class="python"># 矢量与标量运算print (1. / arr)print (2. * arr)</code></pre><pre><code>[[1.         0.5        0.33333333] [0.25       0.2        0.16666667]][[ 2.  4.  6.] [ 8. 10. 12.]]</code></pre><h3 id="索引与切片"><a href="#索引与切片" class="headerlink" title="索引与切片"></a>索引与切片</h3><pre><code class="python"># 一维数组arr1 = np.arange(10)print (arr1)print (arr1[2:5])</code></pre><pre><code>[0 1 2 3 4 5 6 7 8 9][2 3 4]</code></pre><pre><code class="python"># 多维数组arr2 = np.arange(12).reshape(3,4)#要学会定义多维数组，arange是形成12个随机数，之后的reshape是形成维数#多维数组的空间含义就是比如：3.4.5=长4宽5高3#还有点数就是应用函数print (arr2)</code></pre><pre><code>[[ 0  1  2  3] [ 4  5  6  7] [ 8  9 10 11]]</code></pre><pre><code class="python">print (arr2[1])print (arr2[0:2, 2:])print (arr2[:, 1:3])</code></pre><pre><code>[4 5 6 7][[2 3] [6 7]][[ 1  2] [ 5  6] [ 9 10]]</code></pre><pre><code class="python"># 条件索引# 找出 data_arr 中 2015年后的数据data_arr = np.random.rand(3,3)print (data_arr)year_arr = np.array([[2000, 2001, 2000],                     [2005, 2002, 2009],                     [2001, 2003, 2010]])is_year_after_2005 = year_arr &gt;= 2005#:他会扩展成同类型的数组print (is_year_after_2005, is_year_after_2005.dtype)filtered_arr = data_arr[is_year_after_2005]filtered_arr = data_arr[year_arr &gt;= 2005]print (filtered_arr)#中间的一些语句可以删除#最后生成得是一维数组，进行数据过滤的时候很有用</code></pre><pre><code>[[0.61482194 0.0249229  0.28525661] [0.05121173 0.37672803 0.86259463] [0.22648329 0.4581513  0.18620441]][[False False False] [ True False  True] [False False  True]] bool[0.05121173 0.86259463 0.18620441]</code></pre><pre><code class="python"># 多个条件&amp; |filtered_arr = data_arr[(year_arr &lt;= 2005) &amp; (year_arr % 2 == 0)]print (filtered_arr)</code></pre><pre><code>[0.61482194 0.28525661 0.37672803]</code></pre><h3 id="转置-transpose"><a href="#转置-transpose" class="headerlink" title="转置 === transpose"></a>转置 === transpose</h3><pre><code class="python">arr = np.random.rand(2,3)print (arr)print (arr.transpose())</code></pre><pre><code>[[0.01538974 0.47573964 0.90684253] [0.93683601 0.64306611 0.63846634]][[0.01538974 0.93683601] [0.47573964 0.64306611] [0.90684253 0.63846634]]</code></pre><pre><code class="python">#高维数组的转换(图像里面会用得到转换维度)arr3d = np.random.rand(2,3,4)print (arr3d)print (&#39;----------------------&#39;)print (arr3d.transpose((1,0,2))) # 多维数组的转置和定义不会</code></pre><pre><code>[[[0.18074837 0.64652003 0.80527972 0.67800268]  [0.95766577 0.2498768  0.00304503 0.7058178 ]  [0.12523549 0.18796252 0.72463798 0.15352211]] [[0.38808013 0.31075033 0.53082474 0.32254431]  [0.6861262  0.02999367 0.70980993 0.09099878]  [0.14987301 0.78237398 0.90159408 0.82897071]]]----------------------[[[0.18074837 0.64652003 0.80527972 0.67800268]  [0.38808013 0.31075033 0.53082474 0.32254431]] [[0.95766577 0.2498768  0.00304503 0.7058178 ]  [0.6861262  0.02999367 0.70980993 0.09099878]] [[0.12523549 0.18796252 0.72463798 0.15352211]  [0.14987301 0.78237398 0.90159408 0.82897071]]]</code></pre><h3 id="ndarray-数据类型转化-astype"><a href="#ndarray-数据类型转化-astype" class="headerlink" title="ndarray 数据类型转化 === astype"></a>ndarray 数据类型转化 === astype</h3><pre><code class="python">zeros_float_arr = np.zeros((3, 4), dtype=np.float64)print (zeros_float_arr)print (zeros_float_arr.dtype)# astype转换数据类型zeros_int_arr = zeros_float_arr.astype(np.int32)print (zeros_int_arr)print (zeros_int_arr.dtype)</code></pre><pre><code>[[0. 0. 0. 0.] [0. 0. 0. 0.] [0. 0. 0. 0.]]float64[[0 0 0 0] [0 0 0 0] [0 0 0 0]]int32</code></pre><h3 id="文本文件的读取"><a href="#文本文件的读取" class="headerlink" title="文本文件的读取"></a>文本文件的读取</h3><pre><code class="python"># loadtxtfilename = &#39;./presidential_polls.csv&#39;data_array = np.loadtxt(filename,      # 文件名                        delimiter=&#39;,&#39;, # 指定里面的元素分隔符                        dtype=str,     # 指定数据类型                        usecols=(0,2,3)) # 指定读取的列索引号print (data_array, data_array.shape)</code></pre><pre><code>[[&#39;cycle&#39; &#39;type&#39; &#39;matchup&#39;] [&#39;2016&#39; &#39;&quot;polls-plus&quot;&#39; &#39;&quot;Clinton vs. Trump vs. Johnson&quot;&#39;] [&#39;2016&#39; &#39;&quot;polls-plus&quot;&#39; &#39;&quot;Clinton vs. Trump vs. Johnson&quot;&#39;] ... [&#39;2016&#39; &#39;&quot;polls-only&quot;&#39; &#39;&quot;Clinton vs. Trump vs. Johnson&quot;&#39;] [&#39;2016&#39; &#39;&quot;polls-only&quot;&#39; &#39;&quot;Clinton vs. Trump vs. Johnson&quot;&#39;] [&#39;2016&#39; &#39;&quot;polls-only&quot;&#39; &#39;&quot;Clinton vs. Trump vs. Johnson&quot;&#39;]] (10237, 3)</code></pre><pre><code class="python"># loadtxt, 明确指定每列数据的类型filename = &#39;./presidential_polls.csv&#39;data_array = np.loadtxt(filename,      # 文件名                        delimiter=&#39;,&#39;, # 分隔符                        skiprows=1,                        dtype=&#123;&#39;names&#39;:(&#39;cycle&#39;, &#39;type&#39;, &#39;matchup&#39;),                               &#39;formats&#39;:(&#39;i4&#39;, &#39;S15&#39;, &#39;S50&#39;)&#125;,     # 数据类型                        usecols=(0,2,3)) # 指定读取的列索引号print (data_array, data_array.shape) # 读取的结果是一维的数组，每个元素是一个元组</code></pre><pre><code>[(2016, b&#39;&quot;polls-plus&quot;&#39;, b&#39;&quot;Clinton vs. Trump vs. Johnson&quot;&#39;) (2016, b&#39;&quot;polls-plus&quot;&#39;, b&#39;&quot;Clinton vs. Trump vs. Johnson&quot;&#39;) (2016, b&#39;&quot;polls-plus&quot;&#39;, b&#39;&quot;Clinton vs. Trump vs. Johnson&quot;&#39;) ... (2016, b&#39;&quot;polls-only&quot;&#39;, b&#39;&quot;Clinton vs. Trump vs. Johnson&quot;&#39;) (2016, b&#39;&quot;polls-only&quot;&#39;, b&#39;&quot;Clinton vs. Trump vs. Johnson&quot;&#39;) (2016, b&#39;&quot;polls-only&quot;&#39;, b&#39;&quot;Clinton vs. Trump vs. Johnson&quot;&#39;)] (10236,)</code></pre><h2 id="三、np-的常用函数"><a href="#三、np-的常用函数" class="headerlink" title="三、np 的常用函数"></a>三、np 的常用函数</h2><h3 id="转置-transpose-1"><a href="#转置-transpose-1" class="headerlink" title="转置 transpose"></a>转置 transpose</h3><pre><code class="python">import numpy as np</code></pre><pre><code class="python">arr = np.random.rand(2,3)print (arr)print (arr.transpose())</code></pre><pre><code>[[0.78485041 0.88817969 0.34809014] [0.32744286 0.97539301 0.94401872]][[0.78485041 0.32744286] [0.88817969 0.97539301] [0.34809014 0.94401872]]</code></pre><pre><code class="python">#高维数组的转换(图像里面会用得到转换维度)#不懂这里！！！arr3d = np.random.rand(2,3,4)print (arr3d)print (&#39;----------------------&#39;)print (arr3d.transpose((1,0,2))) # 多维数组的转置和定义不会</code></pre><pre><code>[[[0.28492549 0.60197236 0.45582367 0.21992479]  [0.1747163  0.69201365 0.85460359 0.65311699]  [0.62189644 0.25217555 0.16347156 0.29831219]] [[0.42826733 0.81396165 0.187138   0.560564  ]  [0.10162186 0.66419751 0.03261665 0.06969256]  [0.55461652 0.55020586 0.50693591 0.31741807]]]----------------------[[[0.28492549 0.60197236 0.45582367 0.21992479]  [0.42826733 0.81396165 0.187138   0.560564  ]] [[0.1747163  0.69201365 0.85460359 0.65311699]  [0.10162186 0.66419751 0.03261665 0.06969256]] [[0.62189644 0.25217555 0.16347156 0.29831219]  [0.55461652 0.55020586 0.50693591 0.31741807]]]</code></pre><h3 id="ceil-和-floor-和-rint-和-isnan"><a href="#ceil-和-floor-和-rint-和-isnan" class="headerlink" title="ceil 和 floor 和 rint 和 isnan"></a>ceil 和 floor 和 rint 和 isnan</h3><pre><code class="python">arr = np.random.randn(2,3)print (arr)print (np.ceil(arr))#向上最接近的整数print (np.floor(arr))#向下最接近的整数print (np.rint(arr))#四舍五入print (np.isnan(arr))#判断元素是否为NaN#笔记上还有其他的函数</code></pre><pre><code>[[ 0.262106   -1.33680008 -1.08562543] [ 0.3990978   0.1410074   0.64278274]][[ 1. -1. -1.] [ 1.  1.  1.]][[ 0. -2. -2.] [ 0.  0.  0.]][[ 0. -1. -1.] [ 0.  0.  1.]][[False False False] [False False False]]</code></pre><h3 id="where"><a href="#where" class="headerlink" title="where"></a>where</h3><pre><code class="python">arr = np.random.randn(3,4)print (arr)np.where(arr &gt; 0, 1, -1)#（条件，满足输出，不满足输出）</code></pre><pre><code>[[ 2.04688394  0.48063737  1.20876913 -0.93412937] [-0.43427472 -1.47755481  0.36882256 -0.08943138] [-0.2847686   0.96915893  0.32641235  0.28346922]]array([[ 1,  1,  1, -1],       [-1, -1,  1, -1],       [-1,  1,  1,  1]])</code></pre><h3 id="sum"><a href="#sum" class="headerlink" title="sum"></a>sum</h3><pre><code class="python">arr = np.arange(10).reshape(5,2)print (arr)print (np.sum(arr))print (np.sum(arr, axis=0))print (np.sum(arr, axis=1))</code></pre><pre><code>[[0 1] [2 3] [4 5] [6 7] [8 9]]45[20 25][ 1  5  9 13 17]</code></pre><h3 id="all-和-any"><a href="#all-和-any" class="headerlink" title="all 和 any"></a>all 和 any</h3><pre><code class="python">import numpy as nparr = np.random.randn(2,3)print (arr)print (np.any(arr &gt; 0))#有一个就对print (np.all(arr &gt; 0))#全部对才对&#39;&#39;&#39;·用处就是判断一组数据当中，是否===有点类似布尔类型的·这个也可以应用在pandas中的DataFrame中&#39;&#39;&#39;</code></pre><pre><code>[[-1.020184   -0.48466272 -0.8496271 ] [ 0.88815825 -0.81911857  0.64570539]]TrueFalse&#39;\n·用处就是判断一组数据当中，是否===有点类似布尔类型的\n·这个也可以应用在pandas中的DataFrame中\n&#39;</code></pre><h3 id="unique"><a href="#unique" class="headerlink" title="unique"></a>unique</h3><pre><code class="python">arr = np.array([[1, 2, 1], [2, 3, 4]])print (arr)print (np.unique(arr))</code></pre><pre><code>[[1 2 1] [2 3 4]][1 2 3 4]</code></pre>]]></content>
      
      
      <categories>
          
          <category> ✨其他 </category>
          
          <category> 数据分析 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数据可视化</title>
      <link href="/blog/kt0kvc/"/>
      <url>/blog/kt0kvc/</url>
      
        <content type="html"><![CDATA[<h2 id="一、GitHub-Juper-NoteBook-笔记"><a href="#一、GitHub-Juper-NoteBook-笔记" class="headerlink" title="一、GitHub Juper NoteBook 笔记"></a>一、GitHub Juper NoteBook 笔记</h2><ul><li><a href="https://github.com/wztlink1013/data-analysis-mining">https://github.com/wztlink1013/data-analysis-mining</a></li></ul><h2 id="二、零碎总结"><a href="#二、零碎总结" class="headerlink" title="二、零碎总结"></a>二、零碎总结</h2><h3 id="matplotlib-调整子图间距，调整整体空白"><a href="#matplotlib-调整子图间距，调整整体空白" class="headerlink" title="matplotlib 调整子图间距，调整整体空白"></a>matplotlib 调整子图间距，调整整体空白</h3><pre><code class="python">fig.tight_layout() #调整整体空白plt.subplots_adjust(wspace =0, hspace =0) #调整子图间距</code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://mp.weixin.qq.com/s/DaQL6bqr0wu5iYt-cVkz6g">Matplotlib 可视化最有价值的 50 个图表</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> ✨其他 </category>
          
          <category> 数据分析 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数据的清洗和规整（一）</title>
      <link href="/blog/gvi1hn/"/>
      <url>/blog/gvi1hn/</url>
      
        <content type="html"><![CDATA[<p>清洗数据：删除指定数据、处理缺失数据 etc</p><hr><h2 id="一、数据预览：tail（）、head（）"><a href="#一、数据预览：tail（）、head（）" class="headerlink" title="一、数据预览：tail（）、head（）"></a>一、数据预览：tail（）、head（）</h2><pre><code class="python">import numpy as npimport pandas as pddf_obj = pd.DataFrame(np.random.randn(5,4), columns = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;])print(df_obj.tail())# 数据预览尾巴print(df_obj.head())# 数据预览头部</code></pre><pre><code>          a         b         c         d0 -0.507788  0.213237  0.003150 -0.7773121 -0.896653 -2.188016 -0.114848  0.1670572 -1.131242 -0.142287 -1.027330  1.8618143  0.369608  0.823453  1.030830 -0.0417784 -0.647625  0.056791 -0.394078 -1.347718          a         b         c         d0 -0.507788  0.213237  0.003150 -0.7773121 -0.896653 -2.188016 -0.114848  0.1670572 -1.131242 -0.142287 -1.027330  1.8618143  0.369608  0.823453  1.030830 -0.0417784 -0.647625  0.056791 -0.394078 -1.347718</code></pre><h2 id="二、数据描述：shape、info"><a href="#二、数据描述：shape、info" class="headerlink" title="二、数据描述：shape、info()"></a>二、数据描述：shape、info()</h2><pre><code class="python">print (&#39;数据集有%i行，%i列&#39; %(df_obj.shape[0], df_obj.shape[1]))</code></pre><pre><code>数据集有5行，4列</code></pre><pre><code class="python">print(df_obj.info())</code></pre><pre><code>&lt;class &#39;pandas.core.frame.DataFrame&#39;&gt;RangeIndex: 5 entries, 0 to 4Data columns (total 4 columns):a    5 non-null float64b    5 non-null float64c    5 non-null float64d    5 non-null float64dtypes: float64(4)memory usage: 288.0 bytesNone</code></pre><h2 id="三、数据统计：describe"><a href="#三、数据统计：describe" class="headerlink" title="三、数据统计：describe()"></a>三、数据统计：describe()</h2><pre><code class="python">print(df_obj.describe())</code></pre><pre><code>              a         b         c         dcount  5.000000  5.000000  5.000000  5.000000mean  -0.562740 -0.247365 -0.100455 -0.027587std    0.573191  1.143294  0.747673  1.215808min   -1.131242 -2.188016 -1.027330 -1.34771825%   -0.896653 -0.142287 -0.394078 -0.77731250%   -0.647625  0.056791 -0.114848 -0.04177875%   -0.507788  0.213237  0.003150  0.167057max    0.369608  0.823453  1.030830  1.861814</code></pre><h2 id="四、pandas-不完全显示行列"><a href="#四、pandas-不完全显示行列" class="headerlink" title="四、pandas 不完全显示行列"></a>四、pandas 不完全显示行列</h2><pre><code>pd.set_option(&#39;display.max_rows&#39;, 100)        //显示的最大行数（避免只显示部分行数据）pd.set_option(&#39;display.max_columns&#39;, 1000)    //显示的最大列数（避免列显示不全）pd.set_option(&quot;display.max_colwidth&quot;, 1000)   //每一列最大的宽度（避免属性值或列名显示不全）pd.set_option(&#39;display.width&#39;, 1000)          //每一行的宽度（避免换行）</code></pre><h2 id="五、删除指定行列数据"><a href="#五、删除指定行列数据" class="headerlink" title="五、删除指定行列数据"></a>五、删除指定行列数据</h2><pre><code class="python">import pandas as pdimport numpy as np</code></pre><pre><code class="python">dict_data = &#123;&#39;A&#39;: 1.,             &#39;B&#39;: pd.Timestamp(&#39;20161217&#39;),             &#39;C&#39;: pd.Series(1, index=list(range(4)),dtype=&#39;float32&#39;),             &#39;D&#39;: np.array([3] * 4,dtype=&#39;int32&#39;),             &#39;E&#39; : pd.Categorical([&quot;Python&quot;,&quot;Java&quot;,&quot;C++&quot;,&quot;C#&quot;]),             &#39;F&#39; : &#39;ChinaHadoop&#39; &#125;df_obj2 = pd.DataFrame(dict_data)print(df_obj2)</code></pre><pre><code>     A          B    C  D       E            F0  1.0 2016-12-17  1.0  3  Python  ChinaHadoop1  1.0 2016-12-17  1.0  3    Java  ChinaHadoop2  1.0 2016-12-17  1.0  3     C++  ChinaHadoop3  1.0 2016-12-17  1.0  3      C#  ChinaHadoop</code></pre><h3 id="del"><a href="#del" class="headerlink" title="del"></a>del</h3><blockquote><p>删除列</p></blockquote><pre><code class="python">del df_obj2[&#39;A&#39;]print (df_obj2.head())</code></pre><pre><code>           B    C  D       E            F0 2016-12-17  1.0  3  Python  ChinaHadoop1 2016-12-17  1.0  3    Java  ChinaHadoop2 2016-12-17  1.0  3     C++  ChinaHadoop3 2016-12-17  1.0  3      C#  ChinaHadoop</code></pre><h3 id="drop"><a href="#drop" class="headerlink" title="drop"></a>drop</h3><blockquote><p>删除行/列数据</p></blockquote><pre><code class="python">dict_data = &#123;&#39;A&#39;: 1.,             &#39;B&#39;: pd.Timestamp(&#39;20161217&#39;),             &#39;C&#39;: pd.Series(1, index=list(range(4)),dtype=&#39;float32&#39;),             &#39;D&#39;: np.array([3] * 4,dtype=&#39;int32&#39;),             &#39;E&#39; : pd.Categorical([&quot;Python&quot;,&quot;Java&quot;,&quot;C++&quot;,&quot;C#&quot;]),             &#39;F&#39; : &#39;ChinaHadoop&#39; &#125;df_obj3 = pd.DataFrame(dict_data,index = [&#39;sfd&#39;,&#39;sdfd&#39;,&#39;wer&#39;,&#39;rwer&#39;])print (df_obj3.head(7))print(df_obj3.drop(&#39;wer&#39;))#删除行print(df_obj3.drop(&#39;F&#39;,axis=1))#删除列</code></pre><pre><code>        A          B   C  D       E            Fsfd   1.0 2016-12-17 NaN  3  Python  ChinaHadoopsdfd  1.0 2016-12-17 NaN  3    Java  ChinaHadoopwer   1.0 2016-12-17 NaN  3     C++  ChinaHadooprwer  1.0 2016-12-17 NaN  3      C#  ChinaHadoop        A          B   C  D       E            Fsfd   1.0 2016-12-17 NaN  3  Python  ChinaHadoopsdfd  1.0 2016-12-17 NaN  3    Java  ChinaHadooprwer  1.0 2016-12-17 NaN  3      C#  ChinaHadoop        A          B   C  D       Esfd   1.0 2016-12-17 NaN  3  Pythonsdfd  1.0 2016-12-17 NaN  3    Javawer   1.0 2016-12-17 NaN  3     C++rwer  1.0 2016-12-17 NaN  3      C#</code></pre><h2 id="六、处理缺失数据"><a href="#六、处理缺失数据" class="headerlink" title="六、处理缺失数据"></a>六、处理缺失数据</h2><pre><code class="python">df_data = pd.DataFrame([np.random.randn(3), [1., np.nan, np.nan],                       [4., np.nan, np.nan], [1., np.nan, 2.]])df_data.head()</code></pre><table><thead><tr><th></th><th>0</th><th>1</th><th>2</th></tr></thead><tbody><tr><td>0</td><td>-0.702713</td><td>-0.991383</td><td>-1.058464</td></tr><tr><td>1</td><td>1.000000</td><td>NaN</td><td>NaN</td></tr><tr><td>2</td><td>4.000000</td><td>NaN</td><td>NaN</td></tr><tr><td>3</td><td>1.000000</td><td>NaN</td><td>2.000000</td></tr></tbody></table><h3 id="判断是否存在缺失值"><a href="#判断是否存在缺失值" class="headerlink" title="判断是否存在缺失值"></a>判断是否存在缺失值</h3><pre><code class="python">df_data.isnull()</code></pre><table><thead><tr><th></th><th>0</th><th>1</th><th>2</th></tr></thead><tbody><tr><td>0</td><td>False</td><td>False</td><td>False</td></tr><tr><td>1</td><td>False</td><td>True</td><td>True</td></tr><tr><td>2</td><td>False</td><td>True</td><td>True</td></tr><tr><td>3</td><td>False</td><td>True</td><td>False</td></tr></tbody></table><h3 id="丢弃缺失数据"><a href="#丢弃缺失数据" class="headerlink" title="丢弃缺失数据"></a>丢弃缺失数据</h3><pre><code class="python">print(df_data.dropna(axis=0))#0是行；1是列</code></pre><pre><code>          0         1         20 -0.702713 -0.991383 -1.058464</code></pre><h3 id="填充缺失数据"><a href="#填充缺失数据" class="headerlink" title="填充缺失数据"></a>填充缺失数据</h3><pre><code class="python">df_data.fillna(-100.)</code></pre><table><thead><tr><th></th><th>0</th><th>1</th><th>2</th></tr></thead><tbody><tr><td>0</td><td>-0.702713</td><td>-0.991383</td><td>-1.058464</td></tr><tr><td>1</td><td>1.000000</td><td>-100.000000</td><td>-100.000000</td></tr><tr><td>2</td><td>4.000000</td><td>-100.000000</td><td>-100.000000</td></tr><tr><td>3</td><td>1.000000</td><td>-100.000000</td><td>2.000000</td></tr></tbody></table><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
      
      
      <categories>
          
          <category> ✨其他 </category>
          
          <category> 数据分析 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数据的清洗和规整（二）</title>
      <link href="/blog/dggm37/"/>
      <url>/blog/dggm37/</url>
      
        <content type="html"><![CDATA[<p>规整数据：连接、合并、重构、转换 etc</p><hr><h2 id="三、数据规整-连接-含索引"><a href="#三、数据规整-连接-含索引" class="headerlink" title="三、数据规整-连接-含索引"></a>三、数据规整-连接-含索引</h2><ul><li>数据连接 merge</li></ul><pre><code class="python">import pandas as pdimport numpy as np</code></pre><pre><code class="python">df_obj1 = pd.DataFrame(&#123;&#39;key&#39;: [&#39;b&#39;, &#39;b&#39;, &#39;a&#39;, &#39;c&#39;, &#39;a&#39;, &#39;a&#39;, &#39;b&#39;],                        &#39;data1&#39; : [&#39;sfd&#39;,&#39;fdsf&#39;,&#39;we&#39;,24,3253,234,23]&#125;)df_obj2 = pd.DataFrame(&#123;&#39;key&#39;: [&#39;a&#39;, &#39;b&#39;, &#39;d&#39;],                        &#39;data2&#39; : np.random.randint(0,10,3)&#125;)print (df_obj1)print (df_obj2)</code></pre><pre><code>  key data10   b   sfd1   b  fdsf2   a    we3   c    244   a  32535   a   2346   b    23  key  data20   a      01   b      62   d      6</code></pre><h3 id="merge-和-on"><a href="#merge-和-on" class="headerlink" title="merge 和 on"></a>merge 和 on</h3><blockquote><p>默认将重叠列的列名作为“外键”进行连接</p></blockquote><pre><code class="python">pd.merge(df_obj1, df_obj2)</code></pre><table><thead><tr><th></th><th>key</th><th>data1</th><th>data2</th></tr></thead><tbody><tr><td>0</td><td>b</td><td>sfd</td><td>6</td></tr><tr><td>1</td><td>b</td><td>fdsf</td><td>6</td></tr><tr><td>2</td><td>b</td><td>23</td><td>6</td></tr><tr><td>3</td><td>a</td><td>we</td><td>0</td></tr><tr><td>4</td><td>a</td><td>3253</td><td>0</td></tr><tr><td>5</td><td>a</td><td>234</td><td>0</td></tr></tbody></table><pre><code class="python"># on显示指定“外键”pd.merge(df_obj1, df_obj2, on=&#39;key&#39;)</code></pre><table><thead><tr><th></th><th>key</th><th>data1</th><th>data2</th></tr></thead><tbody><tr><td>0</td><td>b</td><td>sfd</td><td>6</td></tr><tr><td>1</td><td>b</td><td>fdsf</td><td>6</td></tr><tr><td>2</td><td>b</td><td>23</td><td>6</td></tr><tr><td>3</td><td>a</td><td>we</td><td>0</td></tr><tr><td>4</td><td>a</td><td>3253</td><td>0</td></tr><tr><td>5</td><td>a</td><td>234</td><td>0</td></tr></tbody></table><h3 id="left-on-和-right-on"><a href="#left-on-和-right-on" class="headerlink" title="left-on 和 right-on"></a>left-on 和 right-on</h3><pre><code class="python"># left_on，right_on分别指定左侧数据和右侧数据的“外键”# 更改列名df_obj1 = df_obj1.rename(columns=&#123;&#39;key&#39;:&#39;key1&#39;&#125;)df_obj2 = df_obj2.rename(columns=&#123;&#39;key&#39;:&#39;key2&#39;&#125;)</code></pre><pre><code class="python">print(df_obj1)print(df_obj2)</code></pre><pre><code>  key1 data10    b   sfd1    b  fdsf2    a    we3    c    244    a  32535    a   2346    b    23  key2  data20    a      01    b      62    d      6</code></pre><pre><code class="python">pd.merge(df_obj1, df_obj2, left_on=&#39;key1&#39;, right_on=&#39;key2&#39;)</code></pre><table><thead><tr><th></th><th>key1</th><th>data1</th><th>key2</th><th>data2</th></tr></thead><tbody><tr><td>0</td><td>b</td><td>sfd</td><td>b</td><td>6</td></tr><tr><td>1</td><td>b</td><td>fdsf</td><td>b</td><td>6</td></tr><tr><td>2</td><td>b</td><td>23</td><td>b</td><td>6</td></tr><tr><td>3</td><td>a</td><td>we</td><td>a</td><td>0</td></tr><tr><td>4</td><td>a</td><td>3253</td><td>a</td><td>0</td></tr><tr><td>5</td><td>a</td><td>234</td><td>a</td><td>0</td></tr></tbody></table><h3 id="how"><a href="#how" class="headerlink" title="how"></a>how</h3><pre><code class="python"># “外连接”pd.merge(df_obj1, df_obj2, left_on=&#39;key1&#39;, right_on=&#39;key2&#39;, how=&#39;outer&#39;)</code></pre><table><thead><tr><th></th><th>key1</th><th>data1</th><th>key2</th><th>data2</th></tr></thead><tbody><tr><td>0</td><td>b</td><td>sfd</td><td>b</td><td>6.0</td></tr><tr><td>1</td><td>b</td><td>fdsf</td><td>b</td><td>6.0</td></tr><tr><td>2</td><td>b</td><td>23</td><td>b</td><td>6.0</td></tr><tr><td>3</td><td>a</td><td>we</td><td>a</td><td>0.0</td></tr><tr><td>4</td><td>a</td><td>3253</td><td>a</td><td>0.0</td></tr><tr><td>5</td><td>a</td><td>234</td><td>a</td><td>0.0</td></tr><tr><td>6</td><td>c</td><td>24</td><td>NaN</td><td>NaN</td></tr><tr><td>7</td><td>NaN</td><td>NaN</td><td>d</td><td>6.0</td></tr></tbody></table><pre><code class="python"># 左连接pd.merge(df_obj1, df_obj2, left_on=&#39;key1&#39;, right_on=&#39;key2&#39;, how=&#39;left&#39;)</code></pre><table><thead><tr><th></th><th>key1</th><th>data1</th><th>key2</th><th>data2</th></tr></thead><tbody><tr><td>0</td><td>b</td><td>sfd</td><td>b</td><td>6.0</td></tr><tr><td>1</td><td>b</td><td>fdsf</td><td>b</td><td>6.0</td></tr><tr><td>2</td><td>a</td><td>we</td><td>a</td><td>0.0</td></tr><tr><td>3</td><td>c</td><td>24</td><td>NaN</td><td>NaN</td></tr><tr><td>4</td><td>a</td><td>3253</td><td>a</td><td>0.0</td></tr><tr><td>5</td><td>a</td><td>234</td><td>a</td><td>0.0</td></tr><tr><td>6</td><td>b</td><td>23</td><td>b</td><td>6.0</td></tr></tbody></table><pre><code class="python"># 右连接pd.merge(df_obj1, df_obj2, left_on=&#39;key1&#39;, right_on=&#39;key2&#39;, how=&#39;right&#39;)</code></pre><table><thead><tr><th></th><th>key1</th><th>data1</th><th>key2</th><th>data2</th></tr></thead><tbody><tr><td>0</td><td>b</td><td>sfd</td><td>b</td><td>6</td></tr><tr><td>1</td><td>b</td><td>fdsf</td><td>b</td><td>6</td></tr><tr><td>2</td><td>b</td><td>23</td><td>b</td><td>6</td></tr><tr><td>3</td><td>a</td><td>we</td><td>a</td><td>0</td></tr><tr><td>4</td><td>a</td><td>3253</td><td>a</td><td>0</td></tr><tr><td>5</td><td>a</td><td>234</td><td>a</td><td>0</td></tr><tr><td>6</td><td>NaN</td><td>NaN</td><td>d</td><td>6</td></tr></tbody></table><h3 id="处理重复列名-suffixes"><a href="#处理重复列名-suffixes" class="headerlink" title="处理重复列名 suffixes"></a>处理重复列名 suffixes</h3><pre><code class="python"># 处理重复列名df_obj1 = pd.DataFrame(&#123;&#39;key&#39;: [&#39;b&#39;, &#39;b&#39;, &#39;a&#39;, &#39;c&#39;, &#39;a&#39;, &#39;a&#39;, &#39;b&#39;],                        &#39;data&#39; : np.random.randint(0,10,7)&#125;)df_obj2 = pd.DataFrame(&#123;&#39;key&#39;: [&#39;a&#39;, &#39;b&#39;, &#39;d&#39;],                        &#39;data&#39; : np.random.randint(0,10,3)&#125;)pd.merge(df_obj1, df_obj2, on=&#39;key&#39;, suffixes=(&#39;_left&#39;, &#39;_right&#39;))</code></pre><table><thead><tr><th></th><th>key</th><th>data_left</th><th>data_right</th></tr></thead><tbody><tr><td>0</td><td>b</td><td>9</td><td>1</td></tr><tr><td>1</td><td>b</td><td>1</td><td>1</td></tr><tr><td>2</td><td>b</td><td>6</td><td>1</td></tr><tr><td>3</td><td>a</td><td>7</td><td>1</td></tr><tr><td>4</td><td>a</td><td>3</td><td>1</td></tr><tr><td>5</td><td>a</td><td>4</td><td>1</td></tr></tbody></table><pre><code class="python"># 按索引连接df_obj3 = pd.DataFrame(&#123;&#39;key&#39;: [&#39;b&#39;, &#39;b&#39;, &#39;a&#39;, &#39;c&#39;, &#39;a&#39;, &#39;a&#39;, &#39;b&#39;],                        &#39;data1&#39; : np.random.randint(0,10,7)&#125;)df_obj4 = pd.DataFrame(&#123;&#39;data2&#39; : np.random.randint(0,10,3)&#125;, index=[&#39;a&#39;, &#39;b&#39;, &#39;d&#39;])</code></pre><pre><code class="python">print(df_obj3)print(df_obj4)</code></pre><pre><code>  key  data10   b      71   b      42   a      13   c      94   a      25   a      96   b      7   data2a      9b      4d      0</code></pre><pre><code class="python">pd.merge(df_obj3, df_obj4, left_on=&#39;key&#39;, right_index=True)</code></pre><table><thead><tr><th></th><th>key</th><th>data1</th><th>data2</th></tr></thead><tbody><tr><td>0</td><td>b</td><td>7</td><td>4</td></tr><tr><td>1</td><td>b</td><td>4</td><td>4</td></tr><tr><td>6</td><td>b</td><td>7</td><td>4</td></tr><tr><td>2</td><td>a</td><td>1</td><td>9</td></tr><tr><td>4</td><td>a</td><td>2</td><td>9</td></tr><tr><td>5</td><td>a</td><td>9</td><td>9</td></tr></tbody></table><h3 id="按索引连接-right-index"><a href="#按索引连接-right-index" class="headerlink" title="按索引连接 right_index"></a>按索引连接 right_index</h3><pre><code class="python"># 按索引连接df_obj1 = pd.DataFrame(&#123;&#39;key&#39;: [&#39;b&#39;, &#39;b&#39;, &#39;a&#39;, &#39;c&#39;, &#39;a&#39;, &#39;a&#39;, &#39;b&#39;],                        &#39;data1&#39; : np.random.randint(0,10,7)&#125;)df_obj2 = pd.DataFrame(&#123;&#39;data2&#39; : np.random.randint(0,10,3)&#125;, index=[&#39;a&#39;, &#39;b&#39;, &#39;d&#39;])</code></pre><pre><code class="python">print(df_obj1)print(df_obj2)</code></pre><pre><code>  key  data10   b      01   b      22   a      73   c      34   a      15   a      16   b      6   data2a      2b      1d      1</code></pre><pre><code class="python">pd.merge(df_obj1, df_obj2, left_on=&#39;key&#39;, right_index=True)</code></pre><table><thead><tr><th></th><th>key</th><th>data1</th><th>data2</th></tr></thead><tbody><tr><td>0</td><td>b</td><td>0</td><td>1</td></tr><tr><td>1</td><td>b</td><td>2</td><td>1</td></tr><tr><td>6</td><td>b</td><td>6</td><td>1</td></tr><tr><td>2</td><td>a</td><td>7</td><td>2</td></tr><tr><td>4</td><td>a</td><td>1</td><td>2</td></tr><tr><td>5</td><td>a</td><td>1</td><td>2</td></tr></tbody></table><h2 id="四、数据合并"><a href="#四、数据合并" class="headerlink" title="四、数据合并"></a>四、数据合并</h2><ul><li>数据合并 concat</li><li>按索引连接===right_index</li></ul><pre><code class="python">import numpy as npimport pandas as pd</code></pre><h3 id="numpy-的-concat"><a href="#numpy-的-concat" class="headerlink" title="numpy 的 concat"></a>numpy 的 concat</h3><pre><code class="python">arr1 = np.random.randint(0, 10, (3, 4))arr2 = np.random.randint(0, 10, (3, 4))print (arr1)print (arr2)</code></pre><pre><code>[[6 0 3 2] [5 7 9 8] [5 8 0 3]][[6 5 7 9] [0 1 0 0] [1 1 1 7]]</code></pre><pre><code class="python">np.concatenate([arr1, arr2])</code></pre><pre><code>array([[6, 0, 3, 2],       [5, 7, 9, 8],       [5, 8, 0, 3],       [6, 5, 7, 9],       [0, 1, 0, 0],       [1, 1, 1, 7]])</code></pre><pre><code class="python">np.concatenate([arr1, arr2], axis=1)</code></pre><pre><code>array([[6, 0, 3, 2, 6, 5, 7, 9],       [5, 7, 9, 8, 0, 1, 0, 0],       [5, 8, 0, 3, 1, 1, 1, 7]])</code></pre><h3 id="series-上的-concat"><a href="#series-上的-concat" class="headerlink" title="series 上的 concat"></a>series 上的 concat</h3><pre><code class="python"># index 没有重复的情况ser_obj1 = pd.Series(np.random.randint(0, 10, 5), index=range(0,5))ser_obj2 = pd.Series(np.random.randint(0, 10, 4), index=range(5,9))ser_obj3 = pd.Series(np.random.randint(0, 10, 3), index=range(9,12))</code></pre><pre><code class="python">pd.concat([ser_obj1, ser_obj2, ser_obj3])</code></pre><pre><code>0     01     42     53     14     95     76     87     58     09     510    911    0dtype: int32</code></pre><pre><code class="python">pd.concat([ser_obj1, ser_obj2, ser_obj3], axis=1)</code></pre><table><thead><tr><th></th><th>0</th><th>1</th><th>2</th></tr></thead><tbody><tr><td>0</td><td>0.0</td><td>NaN</td><td>NaN</td></tr><tr><td>1</td><td>4.0</td><td>NaN</td><td>NaN</td></tr><tr><td>2</td><td>5.0</td><td>NaN</td><td>NaN</td></tr><tr><td>3</td><td>1.0</td><td>NaN</td><td>NaN</td></tr><tr><td>4</td><td>9.0</td><td>NaN</td><td>NaN</td></tr><tr><td>5</td><td>NaN</td><td>7.0</td><td>NaN</td></tr><tr><td>6</td><td>NaN</td><td>8.0</td><td>NaN</td></tr><tr><td>7</td><td>NaN</td><td>5.0</td><td>NaN</td></tr><tr><td>8</td><td>NaN</td><td>0.0</td><td>NaN</td></tr><tr><td>9</td><td>NaN</td><td>NaN</td><td>5.0</td></tr><tr><td>10</td><td>NaN</td><td>NaN</td><td>9.0</td></tr><tr><td>11</td><td>NaN</td><td>NaN</td><td>0.0</td></tr></tbody></table><pre><code class="python"># index 有重复的情况ser_obj1 = pd.Series(np.random.randint(0, 10, 5), index=range(5))ser_obj2 = pd.Series(np.random.randint(0, 10, 4), index=range(4))ser_obj3 = pd.Series(np.random.randint(0, 10, 3), index=range(3))print (ser_obj1)print (ser_obj2)print (ser_obj3)</code></pre><pre><code>0    51    32    03    84    3dtype: int320    51    32    23    1dtype: int320    51    82    6dtype: int32</code></pre><pre><code class="python">pd.concat([ser_obj1, ser_obj2, ser_obj3])</code></pre><pre><code>0    51    32    03    84    30    51    32    23    10    51    82    6dtype: int32</code></pre><pre><code class="python">pd.concat([ser_obj1, ser_obj2, ser_obj3], axis=1, join=&#39;inner&#39;)</code></pre><table><thead><tr><th></th><th>0</th><th>1</th><th>2</th></tr></thead><tbody><tr><td>0</td><td>5</td><td>5</td><td>5</td></tr><tr><td>1</td><td>3</td><td>3</td><td>8</td></tr><tr><td>2</td><td>0</td><td>2</td><td>6</td></tr></tbody></table><h3 id="dataframe-上的-concat"><a href="#dataframe-上的-concat" class="headerlink" title="dataframe 上的 concat"></a>dataframe 上的 concat</h3><pre><code class="python">df_obj1 = pd.DataFrame(np.random.randint(0, 10, (3, 2)), index=[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;],                       columns=[&#39;A&#39;, &#39;B&#39;])df_obj2 = pd.DataFrame(np.random.randint(0, 10, (2, 2)), index=[&#39;a&#39;, &#39;b&#39;],                       columns=[&#39;C&#39;, &#39;D&#39;])print (df_obj1)print (df_obj2)</code></pre><pre><code>   A  Ba  4  3b  8  1c  6  3   C  Da  1  3b  8  2</code></pre><pre><code class="python">pd.concat([df_obj1, df_obj2])</code></pre><pre><code>C:\Users\wztli\Anaconda3\lib\site-packages\ipykernel_launcher.py:1: FutureWarning: Sorting because non-concatenation axis is not aligned. A future versionof pandas will change to not sort by default.To accept the future behavior, pass &#39;sort=False&#39;.To retain the current behavior and silence the warning, pass &#39;sort=True&#39;.  &quot;&quot;&quot;Entry point for launching an IPython kernel.</code></pre><table><thead><tr><th></th><th>A</th><th>B</th><th>C</th><th>D</th></tr></thead><tbody><tr><td>a</td><td>4.0</td><td>3.0</td><td>NaN</td><td>NaN</td></tr><tr><td>b</td><td>8.0</td><td>1.0</td><td>NaN</td><td>NaN</td></tr><tr><td>c</td><td>6.0</td><td>3.0</td><td>NaN</td><td>NaN</td></tr><tr><td>a</td><td>NaN</td><td>NaN</td><td>1.0</td><td>3.0</td></tr><tr><td>b</td><td>NaN</td><td>NaN</td><td>8.0</td><td>2.0</td></tr></tbody></table><pre><code class="python">pd.concat([df_obj1, df_obj2], axis=1)</code></pre><pre><code>C:\Users\wztli\Anaconda3\lib\site-packages\ipykernel_launcher.py:1: FutureWarning: Sorting because non-concatenation axis is not aligned. A future versionof pandas will change to not sort by default.To accept the future behavior, pass &#39;sort=False&#39;.To retain the current behavior and silence the warning, pass &#39;sort=True&#39;.  &quot;&quot;&quot;Entry point for launching an IPython kernel.</code></pre><table><thead><tr><th></th><th>A</th><th>B</th><th>C</th><th>D</th></tr></thead><tbody><tr><td>a</td><td>4</td><td>3</td><td>1.0</td><td>3.0</td></tr><tr><td>b</td><td>8</td><td>1</td><td>8.0</td><td>2.0</td></tr><tr><td>c</td><td>6</td><td>3</td><td>NaN</td><td>NaN</td></tr></tbody></table><h2 id="五、数据重构"><a href="#五、数据重构" class="headerlink" title="五、数据重构"></a>五、数据重构</h2><pre><code class="python">import numpy as npimport pandas as pd</code></pre><h3 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h3><pre><code class="python">df_obj = pd.DataFrame(np.random.randint(0,10, (5,2)), columns=[&#39;data1&#39;, &#39;data2&#39;])df_obj</code></pre><table><thead><tr><th></th><th>data1</th><th>data2</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>4</td></tr><tr><td>1</td><td>6</td><td>2</td></tr><tr><td>2</td><td>9</td><td>8</td></tr><tr><td>3</td><td>7</td><td>0</td></tr><tr><td>4</td><td>3</td><td>1</td></tr></tbody></table><pre><code class="python">stacked = df_obj.stack()print (stacked)</code></pre><pre><code>0  data1    0   data2    41  data1    6   data2    22  data1    9   data2    83  data1    7   data2    04  data1    3   data2    1dtype: int32</code></pre><pre><code class="python">print (type(stacked))print (type(stacked.index))</code></pre><pre><code>&lt;class &#39;pandas.core.series.Series&#39;&gt;&lt;class &#39;pandas.core.indexes.multi.MultiIndex&#39;&gt;</code></pre><h3 id="unstack"><a href="#unstack" class="headerlink" title="unstack"></a>unstack</h3><pre><code class="python"># 默认操作内层索引stacked.unstack()</code></pre><table><thead><tr><th></th><th>data1</th><th>data2</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>4</td></tr><tr><td>1</td><td>6</td><td>2</td></tr><tr><td>2</td><td>9</td><td>8</td></tr><tr><td>3</td><td>7</td><td>0</td></tr><tr><td>4</td><td>3</td><td>1</td></tr></tbody></table><pre><code class="python"># 通过level指定操作索引的级别stacked.unstack(level=0)</code></pre><table><thead><tr><th></th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th></tr></thead><tbody><tr><td>data1</td><td>0</td><td>6</td><td>9</td><td>7</td><td>3</td></tr><tr><td>data2</td><td>4</td><td>2</td><td>8</td><td>0</td><td>1</td></tr></tbody></table><h2 id="六、数据转换"><a href="#六、数据转换" class="headerlink" title="六、数据转换"></a>六、数据转换</h2><pre><code class="python">import numpy as npimport pandas as pd</code></pre><h3 id="重复数据-duplicates-函数"><a href="#重复数据-duplicates-函数" class="headerlink" title="重复数据 duplicates 函数"></a>重复数据 duplicates 函数</h3><pre><code class="python">df_obj = pd.DataFrame(&#123;&#39;data1&#39; : [&#39;a&#39;] * 4 + [&#39;b&#39;] * 4,                       &#39;data2&#39; : np.random.randint(0, 4, 8)&#125;)df_obj</code></pre><table><thead><tr><th></th><th>data1</th><th>data2</th></tr></thead><tbody><tr><td>0</td><td>a</td><td>3</td></tr><tr><td>1</td><td>a</td><td>2</td></tr><tr><td>2</td><td>a</td><td>2</td></tr><tr><td>3</td><td>a</td><td>1</td></tr><tr><td>4</td><td>b</td><td>0</td></tr><tr><td>5</td><td>b</td><td>2</td></tr><tr><td>6</td><td>b</td><td>2</td></tr><tr><td>7</td><td>b</td><td>1</td></tr></tbody></table><pre><code class="python">df_obj.duplicated()</code></pre><pre><code>0    False1    False2     True3    False4    False5    False6     True7    Falsedtype: bool</code></pre><pre><code class="python">df_obj.drop_duplicates()</code></pre><table><thead><tr><th></th><th>data1</th><th>data2</th></tr></thead><tbody><tr><td>0</td><td>a</td><td>3</td></tr><tr><td>1</td><td>a</td><td>2</td></tr><tr><td>3</td><td>a</td><td>1</td></tr><tr><td>4</td><td>b</td><td>0</td></tr><tr><td>5</td><td>b</td><td>2</td></tr><tr><td>7</td><td>b</td><td>1</td></tr></tbody></table><pre><code class="python">df_obj.drop_duplicates(&#39;data2&#39;)</code></pre><table><thead><tr><th></th><th>data1</th><th>data2</th></tr></thead><tbody><tr><td>0</td><td>a</td><td>3</td></tr><tr><td>1</td><td>a</td><td>2</td></tr><tr><td>3</td><td>a</td><td>1</td></tr><tr><td>4</td><td>b</td><td>0</td></tr></tbody></table><h3 id="map-函数"><a href="#map-函数" class="headerlink" title="map 函数"></a>map 函数</h3><pre><code class="python">ser_obj = pd.Series(np.random.randint(0,10,10))ser_obj</code></pre><pre><code>0    11    92    13    24    75    26    47    58    49    6dtype: int32</code></pre><pre><code class="python">ser_obj.map(lambda x : x ** 2)</code></pre><pre><code>0     11    812     13     44    495     46    167    258    169    36dtype: int64</code></pre><h3 id="数据替换-repalce"><a href="#数据替换-repalce" class="headerlink" title="数据替换 repalce"></a>数据替换 repalce</h3><pre><code class="python"># 替换单个值ser_obj.replace(0, -100)</code></pre><pre><code>0    11    92    13    24    75    26    47    58    49    6dtype: int32</code></pre><pre><code class="python"># 替换多个值ser_obj.replace([0, 2], -100)</code></pre><pre><code>0      11      92      13   -1004      75   -1006      47      58      49      6dtype: int32</code></pre><pre><code class="python"># 替换多个值ser_obj.replace([0, 2], [-100, -200])</code></pre><pre><code>0      11      92      13   -2004      75   -2006      47      58      49      6dtype: int64</code></pre><pre><code class="python">ser_obj.map(lambda x : x ** 2)#### 3. 数据替换repalce# 替换单个值ser_obj.replace(0, -100)# 替换多个值ser_obj.replace([0, 2], -100)# 替换多个值ser_obj.replace([0, 2], [-100, -200])</code></pre><pre><code>0      11      92      13   -2004      75   -2006      47      58      49      6dtype: int64</code></pre>]]></content>
      
      
      <categories>
          
          <category> ✨其他 </category>
          
          <category> 数据分析 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Python的本地各类数据读取</title>
      <link href="/blog/lb8ugs/"/>
      <url>/blog/lb8ugs/</url>
      
        <content type="html"><![CDATA[<h2 id="一、TXT-文件操作"><a href="#一、TXT-文件操作" class="headerlink" title="一、TXT 文件操作"></a>一、TXT 文件操作</h2><h3 id="读取全部内容"><a href="#读取全部内容" class="headerlink" title="读取全部内容"></a>读取全部内容</h3><pre><code class="python">import numpy as npimport pandas as pd</code></pre><pre><code class="python">txt_filename = &#39;./files/python_wiki.txt&#39;# 打开文件file_obj = open(txt_filename,&#39;r&#39;)# 读取整个文件内容all_content = file_obj.read()# 关闭文件file_obj.close()print (all_content)</code></pre><pre><code>Python is a widely used high-level, general-purpose, interpreted, dynamic programming language.[24][25] Its design philosophy emphasizes code readability, and its syntax allows programmers to express concepts in fewer lines of code than possible in languages such as C++ or Java.[26][27] The language provides constructs intended to enable writing clear programs on both a small and large scale.[28]Python supports multiple programming paradigms, including object-oriented, imperative and functional programming or procedural styles. It features a dynamic type system and automatic memory management and has a large and comprehensive standard library.[29]Python interpreters are available for many operating systems, allowing Python code to run on a wide variety of systems. CPython, the reference implementation of Python, is open source software[30] and has a community-based development model, as do nearly all of its variant implementations. CPython is managed by the non-profit Python Software Foundation.</code></pre><h3 id="逐行读取"><a href="#逐行读取" class="headerlink" title="逐行读取"></a>逐行读取</h3><pre><code class="python">txt_filename = &#39;./files/python_wiki.txt&#39;# 打开文件file_obj = open(txt_filename, &#39;r&#39;)# 逐行读取line1 = file_obj.readline()print (line1)</code></pre><pre><code>Python is a widely used high-level, general-purpose, interpreted, dynamic programming language.[24][25] Its design philosophy emphasizes code readability, and its syntax allows programmers to express concepts in fewer lines of code than possible in languages such as C++ or Java.[26][27] The language provides constructs intended to enable writing clear programs on both a small and large scale.[28]</code></pre><pre><code class="python"># 继续读下一行【不会全部读完】line2 = file_obj.readline()print (line2)# 关闭文件file_obj.close()</code></pre><pre><code>Python supports multiple programming paradigms, including object-oriented, imperative and functional programming or procedural styles. It features a dynamic type system and automatic memory management and has a large and comprehensive standard library.[29]</code></pre><h3 id="读取全部内容，返回列表"><a href="#读取全部内容，返回列表" class="headerlink" title="读取全部内容，返回列表"></a>读取全部内容，返回列表</h3><pre><code class="python">txt_filename = &#39;./files/python_wiki.txt&#39;# 打开文件file_obj = open(txt_filename, &#39;r&#39;)lines = file_obj.readlines()for i, line in enumerate(lines):    print (&#39;%i: %s&#39; %(i, line))# 关闭文件file_obj.close()</code></pre><pre><code>0: Python is a widely used high-level, general-purpose, interpreted, dynamic programming language.[24][25] Its design philosophy emphasizes code readability, and its syntax allows programmers to express concepts in fewer lines of code than possible in languages such as C++ or Java.[26][27] The language provides constructs intended to enable writing clear programs on both a small and large scale.[28]1: Python supports multiple programming paradigms, including object-oriented, imperative and functional programming or procedural styles. It features a dynamic type system and automatic memory management and has a large and comprehensive standard library.[29]2: Python interpreters are available for many operating systems, allowing Python code to run on a wide variety of systems. CPython, the reference implementation of Python, is open source software[30] and has a community-based development model, as do nearly all of its variant implementations. CPython is managed by the non-profit Python Software Foundation.</code></pre><h3 id="写操作"><a href="#写操作" class="headerlink" title="写操作"></a>写操作</h3><pre><code class="python">txt_filename = &#39;./files/test_write.txt&#39;# 打开文件file_obj = open(txt_filename, &#39;w&#39;)# 写入全部内容file_obj.write(&quot;《Python数据分析》&quot;)file_obj.close()</code></pre><pre><code class="python">txt_filename = &#39;./files/test_write.txt&#39;# 打开文件file_obj = open(txt_filename, &#39;w&#39;)# 写入字符串列表lines = [&#39;这是第%i行\n&#39; %n for n in range(10)]file_obj.writelines(lines)file_obj.close()</code></pre><h3 id="with-语句"><a href="#with-语句" class="headerlink" title="with 语句"></a>with 语句</h3><pre><code class="python">txt_filename = &#39;./files/test_write.txt&#39;with open(txt_filename, &#39;r&#39;) as f_obj:    print (f_obj.read())</code></pre><pre><code>这是第0行这是第1行这是第2行这是第3行这是第4行这是第5行这是第6行这是第7行这是第8行这是第9行</code></pre><h2 id="二、CSV-文件操作"><a href="#二、CSV-文件操作" class="headerlink" title="二、CSV 文件操作"></a>二、CSV 文件操作</h2><h3 id="pandas-读-csv-文件"><a href="#pandas-读-csv-文件" class="headerlink" title="pandas 读 csv 文件"></a>pandas 读 csv 文件</h3><blockquote><p>根据路径导入数据以及指定的列</p></blockquote><pre><code class="python">import pandas as pdfilename = &#39;./files/presidential_polls.csv&#39;df = pd.read_csv(filename, usecols=[&#39;cycle&#39;, &#39;type&#39;, &#39;startdate&#39;])#导入指定列print (type(df))print (df.head())</code></pre><pre><code>&lt;class &#39;pandas.core.frame.DataFrame&#39;&gt;   cycle        type   startdate0   2016  polls-plus  10/25/20161   2016  polls-plus  10/27/20162   2016  polls-plus  10/27/20163   2016  polls-plus  10/20/20164   2016  polls-plus  10/20/2016</code></pre><blockquote><p>引用指定的列</p></blockquote><pre><code class="python">cycle_se = df[&#39;cycle&#39;]print (type(cycle_se))print (cycle_se.head())</code></pre><pre><code>&lt;class &#39;pandas.core.series.Series&#39;&gt;0    20161    20162    20163    20164    2016Name: cycle, dtype: int64</code></pre><blockquote><p>多层索引成 dataframe 类型</p></blockquote><pre><code class="python">filename = &#39;./files/presidential_polls.csv&#39;df1 = pd.read_csv(filename,usecols=[&#39;cycle&#39;, &#39;type&#39;, &#39;startdate&#39;,&#39;state&#39;,&#39;grade&#39;],index_col = [&#39;state&#39;,&#39;grade&#39;])print(df1.head())</code></pre><pre><code>                cycle        type   startdatestate    gradeU.S.     B       2016  polls-plus  10/25/2016         A+      2016  polls-plus  10/27/2016Virginia A+      2016  polls-plus  10/27/2016Florida  A       2016  polls-plus  10/20/2016U.S.     B+      2016  polls-plus  10/20/2016</code></pre><blockquote><p>跳过指定的行</p></blockquote><pre><code class="python">filename = &#39;./files/presidential_polls.csv&#39;df2 = pd.read_csv(filename,usecols=[&#39;cycle&#39;, &#39;type&#39;, &#39;startdate&#39;,&#39;state&#39;,&#39;grade&#39;],skiprows=[1, 2, 3])print(df2.head())</code></pre><pre><code>   cycle        type         state   startdate grade0   2016  polls-plus       Florida  10/20/2016     A1   2016  polls-plus          U.S.  10/20/2016    B+2   2016  polls-plus          U.S.  10/22/2016     A3   2016  polls-plus          U.S.  10/26/2016    A-4   2016  polls-plus  Pennsylvania  10/25/2016    B-</code></pre><h3 id="pandas-写-csv-文件"><a href="#pandas-写-csv-文件" class="headerlink" title="pandas 写 csv 文件"></a>pandas 写 csv 文件</h3><blockquote><p>·to_csv 里面的 index 参数作用？===可能是不要索引的意思。</p></blockquote><pre><code class="python">filename = &#39;./files/pandas_output.csv&#39;df.to_csv(filename, index=None)</code></pre><h2 id="三、JSON-文件操作"><a href="#三、JSON-文件操作" class="headerlink" title="三、JSON 文件操作"></a>三、JSON 文件操作</h2><h3 id="json-读操作"><a href="#json-读操作" class="headerlink" title="json 读操作"></a>json 读操作</h3><pre><code class="python">import jsonfilename = &#39;./files/global_temperature.json&#39;with open(filename, &#39;r&#39;) as f_obj:    json_data = json.load(f_obj)# 返回值是dict类型print (type(json_data))</code></pre><pre><code>&lt;class &#39;dict&#39;&gt;</code></pre><pre><code class="python">print (json_data.keys())</code></pre><pre><code>dict_keys([&#39;description&#39;, &#39;data&#39;])</code></pre><h3 id="json-转-CSV"><a href="#json-转-CSV" class="headerlink" title="json 转 CSV"></a>json 转 CSV</h3><pre><code class="python">#print json_data[&#39;data&#39;].keys()print (json_data[&#39;data&#39;].values())</code></pre><pre><code>dict_values([&#39;-0.1247&#39;, &#39;-0.0707&#39;, &#39;-0.0710&#39;, &#39;-0.1481&#39;, &#39;-0.2099&#39;, &#39;-0.2220&#39;, &#39;-0.2101&#39;, &#39;-0.2559&#39;, &#39;-0.1541&#39;, &#39;-0.1032&#39;, &#39;-0.3233&#39;, &#39;-0.2552&#39;, &#39;-0.3079&#39;, &#39;-0.3221&#39;, &#39;-0.2828&#39;, &#39;-0.2279&#39;, &#39;-0.0971&#39;, &#39;-0.1232&#39;, &#39;-0.2578&#39;, &#39;-0.1172&#39;, &#39;-0.0704&#39;, &#39;-0.1471&#39;, &#39;-0.2535&#39;, &#39;-0.3442&#39;, &#39;-0.4240&#39;, &#39;-0.2967&#39;, &#39;-0.2208&#39;, &#39;-0.3767&#39;, &#39;-0.4441&#39;, &#39;-0.4332&#39;, &#39;-0.3862&#39;, &#39;-0.4367&#39;, &#39;-0.3318&#39;, &#39;-0.3205&#39;, &#39;-0.1444&#39;, &#39;-0.0747&#39;, &#39;-0.2979&#39;, &#39;-0.3193&#39;, &#39;-0.2118&#39;, &#39;-0.2082&#39;, &#39;-0.2152&#39;, &#39;-0.1517&#39;, &#39;-0.2318&#39;, &#39;-0.2161&#39;, &#39;-0.2510&#39;, &#39;-0.1464&#39;, &#39;-0.0618&#39;, &#39;-0.1506&#39;, &#39;-0.1749&#39;, &#39;-0.2982&#39;, &#39;-0.1016&#39;, &#39;-0.0714&#39;, &#39;-0.1214&#39;, &#39;-0.2481&#39;, &#39;-0.1075&#39;, &#39;-0.1445&#39;, &#39;-0.1173&#39;, &#39;-0.0204&#39;, &#39;-0.0318&#39;, &#39;-0.0157&#39;, &#39;0.0927&#39;, &#39;0.1974&#39;, &#39;0.1549&#39;, &#39;0.1598&#39;, &#39;0.2948&#39;, &#39;0.1754&#39;, &#39;-0.0013&#39;, &#39;-0.0455&#39;, &#39;-0.0471&#39;, &#39;-0.0550&#39;, &#39;-0.1579&#39;, &#39;-0.0095&#39;, &#39;0.0288&#39;, &#39;0.0997&#39;, &#39;-0.1118&#39;, &#39;-0.1305&#39;, &#39;-0.1945&#39;, &#39;0.0538&#39;, &#39;0.1145&#39;, &#39;0.0640&#39;, &#39;0.0252&#39;, &#39;0.0818&#39;, &#39;0.0924&#39;, &#39;0.1100&#39;, &#39;-0.1461&#39;, &#39;-0.0752&#39;, &#39;-0.0204&#39;, &#39;-0.0112&#39;, &#39;-0.0282&#39;, &#39;0.0937&#39;, &#39;0.0383&#39;, &#39;-0.0775&#39;, &#39;0.0280&#39;, &#39;0.1654&#39;, &#39;-0.0698&#39;, &#39;0.0060&#39;, &#39;-0.0769&#39;, &#39;0.1996&#39;, &#39;0.1139&#39;, &#39;0.2288&#39;, &#39;0.2651&#39;, &#39;0.3024&#39;, &#39;0.1836&#39;, &#39;0.3429&#39;, &#39;0.1510&#39;, &#39;0.1357&#39;, &#39;0.2308&#39;, &#39;0.3710&#39;, &#39;0.3770&#39;, &#39;0.2982&#39;, &#39;0.4350&#39;, &#39;0.4079&#39;, &#39;0.2583&#39;, &#39;0.2857&#39;, &#39;0.3420&#39;, &#39;0.4593&#39;, &#39;0.3225&#39;, &#39;0.5185&#39;, &#39;0.6335&#39;, &#39;0.4427&#39;, &#39;0.4255&#39;, &#39;0.5455&#39;, &#39;0.6018&#39;, &#39;0.6145&#39;, &#39;0.5806&#39;, &#39;0.6583&#39;, &#39;0.6139&#39;, &#39;0.6113&#39;, &#39;0.5415&#39;, &#39;0.6354&#39;, &#39;0.7008&#39;, &#39;0.5759&#39;, &#39;0.6219&#39;, &#39;0.6687&#39;, &#39;0.7402&#39;, &#39;0.8990&#39;])</code></pre><pre><code class="python"># 转换keyyear_str_lst = json_data[&#39;data&#39;].keys()year_lst = [int(year_str) for year_str in year_str_lst]print (year_lst)</code></pre><pre><code>[1880, 1881, 1882, 1883, 1884, 1885, 1886, 1887, 1888, 1889, 1890, 1891, 1892, 1893, 1894, 1895, 1896, 1897, 1898, 1899, 1900, 1901, 1902, 1903, 1904, 1905, 1906, 1907, 1908, 1909, 1910, 1911, 1912, 1913, 1914, 1915, 1916, 1917, 1918, 1919, 1920, 1921, 1922, 1923, 1924, 1925, 1926, 1927, 1928, 1929, 1930, 1931, 1932, 1933, 1934, 1935, 1936, 1937, 1938, 1939, 1940, 1941, 1942, 1943, 1944, 1945, 1946, 1947, 1948, 1949, 1950, 1951, 1952, 1953, 1954, 1955, 1956, 1957, 1958, 1959, 1960, 1961, 1962, 1963, 1964, 1965, 1966, 1967, 1968, 1969, 1970, 1971, 1972, 1973, 1974, 1975, 1976, 1977, 1978, 1979, 1980, 1981, 1982, 1983, 1984, 1985, 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015]</code></pre><pre><code class="python"># 转换valuetemp_str_lst = json_data[&#39;data&#39;].values()temp_lst = [float(temp_str) for temp_str in temp_str_lst]print (temp_lst)</code></pre><pre><code>[-0.1247, -0.0707, -0.071, -0.1481, -0.2099, -0.222, -0.2101, -0.2559, -0.1541, -0.1032, -0.3233, -0.2552, -0.3079, -0.3221, -0.2828, -0.2279, -0.0971, -0.1232, -0.2578, -0.1172, -0.0704, -0.1471, -0.2535, -0.3442, -0.424, -0.2967, -0.2208, -0.3767, -0.4441, -0.4332, -0.3862, -0.4367, -0.3318, -0.3205, -0.1444, -0.0747, -0.2979, -0.3193, -0.2118, -0.2082, -0.2152, -0.1517, -0.2318, -0.2161, -0.251, -0.1464, -0.0618, -0.1506, -0.1749, -0.2982, -0.1016, -0.0714, -0.1214, -0.2481, -0.1075, -0.1445, -0.1173, -0.0204, -0.0318, -0.0157, 0.0927, 0.1974, 0.1549, 0.1598, 0.2948, 0.1754, -0.0013, -0.0455, -0.0471, -0.055, -0.1579, -0.0095, 0.0288, 0.0997, -0.1118, -0.1305, -0.1945, 0.0538, 0.1145, 0.064, 0.0252, 0.0818, 0.0924, 0.11, -0.1461, -0.0752, -0.0204, -0.0112, -0.0282, 0.0937, 0.0383, -0.0775, 0.028, 0.1654, -0.0698, 0.006, -0.0769, 0.1996, 0.1139, 0.2288, 0.2651, 0.3024, 0.1836, 0.3429, 0.151, 0.1357, 0.2308, 0.371, 0.377, 0.2982, 0.435, 0.4079, 0.2583, 0.2857, 0.342, 0.4593, 0.3225, 0.5185, 0.6335, 0.4427, 0.4255, 0.5455, 0.6018, 0.6145, 0.5806, 0.6583, 0.6139, 0.6113, 0.5415, 0.6354, 0.7008, 0.5759, 0.6219, 0.6687, 0.7402, 0.899]</code></pre><pre><code class="python">import pandas as pd# 构建 dataframeyear_se = pd.Series(year_lst, name = &#39;year&#39;)temp_se = pd.Series(temp_lst, name = &#39;temperature&#39;)result_df = pd.concat([year_se, temp_se], axis = 1)print (result_df.head())# 保存csvresult_df.to_csv(&#39;./files/json_to_csv.csv&#39;, index = None)</code></pre><pre><code>   year  temperature0  1880      -0.12471  1881      -0.07072  1882      -0.07103  1883      -0.14814  1884      -0.2099</code></pre><h3 id="写-json-操作"><a href="#写-json-操作" class="headerlink" title="写 json 操作"></a>写 json 操作</h3><pre><code class="python">book_dict = [&#123;&#39;书名&#39;:&#39;无声告白&#39;, &#39;作者&#39;:&#39;伍绮诗&#39;&#125;, &#123;&#39;书名&#39;:&#39;我不是潘金莲&#39;, &#39;作者&#39;:&#39;刘震云&#39;&#125;, &#123;&#39;书名&#39;:&#39;沉默的大多数 (王小波集)&#39;, &#39;作者&#39;:&#39;王小波&#39;&#125;]filename = &#39;./files/json_output.json&#39;with open(filename, &#39;w&#39;) as f_obj:    f_obj.write(json.dumps(book_dict, ensure_ascii=False))# 不需要加, encoding=&#39;utf-8&#39;参数</code></pre><h2 id="四、SQLite-基本操作"><a href="#四、SQLite-基本操作" class="headerlink" title="四、SQLite 基本操作"></a>四、SQLite 基本操作</h2><h3 id="连接数据库"><a href="#连接数据库" class="headerlink" title="连接数据库"></a>连接数据库</h3><pre><code class="python">import sqlite3db_path = &#39;./files/test.sqlite&#39;conn = sqlite3.connect(db_path)cur = conn.cursor()conn.text_factory = str  # 处理中文</code></pre><h3 id="获取基本信息"><a href="#获取基本信息" class="headerlink" title="获取基本信息"></a>获取基本信息</h3><pre><code class="python">cur.execute(&#39;SELECT SQLITE_VERSION()&#39;)print (&#39;SQLite版本：%s&#39; %str(cur.fetchone()[0]))</code></pre><pre><code>SQLite版本：3.30.0</code></pre><h3 id="逐条插入数据"><a href="#逐条插入数据" class="headerlink" title="逐条插入数据"></a>逐条插入数据</h3><pre><code class="python">cur.execute(&quot;DROP TABLE IF EXISTS book&quot;)cur.execute(&quot;CREATE TABLE book(id INT, name TEXT, price DOUBLE)&quot;)cur.execute(&quot;INSERT INTO book VALUES(1,&#39;肖秀荣考研书系列:肖秀荣(2017)考研政治命题人终极预测4套卷&#39;,14.40)&quot;)cur.execute(&quot;INSERT INTO book VALUES(2,&#39;法医秦明作品集:幸存者+清道夫+尸语者+无声的证词+第十一根手指(套装共5册) (两种封面随机发货)&#39;,100.00)&quot;)cur.execute(&quot;INSERT INTO book VALUES(3,&#39;活着本来单纯:丰子恺散文漫画精品集(收藏本)&#39;,30.90)&quot;)cur.execute(&quot;INSERT INTO book VALUES(4,&#39;自在独行:贾平凹的独行世界&#39;,26.80)&quot;)cur.execute(&quot;INSERT INTO book VALUES(5,&#39;当你的才华还撑不起你的梦想时&#39;,23.00)&quot;)cur.execute(&quot;INSERT INTO book VALUES(6,&#39;巨人的陨落(套装共3册)&#39;,84.90)&quot;)cur.execute(&quot;INSERT INTO book VALUES(7,&#39;孤独深处(收录雨果奖获奖作品《北京折叠》)&#39;,21.90)&quot;)cur.execute(&quot;INSERT INTO book VALUES(8,&#39;世界知名企业员工指定培训教材:所谓情商高,就是会说话&#39;,22.00)&quot;)</code></pre><pre><code>&lt;sqlite3.Cursor at 0x2d2d64e7c00&gt;</code></pre><h3 id="批量插入数据"><a href="#批量插入数据" class="headerlink" title="批量插入数据"></a>批量插入数据</h3><pre><code class="python">books = (    (9, &#39;人间草木&#39;, 30.00),    (10,&#39;你的善良必须有点锋芒&#39;, 20.50),    (11, &#39;这么慢,那么美&#39;, 24.80),    (12, &#39;考拉小巫的英语学习日记:写给为梦想而奋斗的人(全新修订版)&#39;, 23.90))cur.executemany(&quot;INSERT INTO book VALUES(?, ?, ?)&quot;, books)</code></pre><pre><code>&lt;sqlite3.Cursor at 0x2d2d64e7c00&gt;</code></pre><pre><code class="python">conn.commit()</code></pre><h3 id="查找数据"><a href="#查找数据" class="headerlink" title="查找数据"></a>查找数据</h3><pre><code class="python">cur.execute(&#39;SELECT * FROM book&#39;)rows = cur.fetchall()# 通过索引号访问for row in rows:    print (&#39;序号: %i, 书名: %s, 价格: %.2f&#39; %(row[0], row[1], row[2]))</code></pre><pre><code>序号: 1, 书名: 肖秀荣考研书系列:肖秀荣(2017)考研政治命题人终极预测4套卷, 价格: 14.40序号: 2, 书名: 法医秦明作品集:幸存者+清道夫+尸语者+无声的证词+第十一根手指(套装共5册) (两种封面随机发货), 价格: 100.00序号: 3, 书名: 活着本来单纯:丰子恺散文漫画精品集(收藏本), 价格: 30.90序号: 4, 书名: 自在独行:贾平凹的独行世界, 价格: 26.80序号: 5, 书名: 当你的才华还撑不起你的梦想时, 价格: 23.00序号: 6, 书名: 巨人的陨落(套装共3册), 价格: 84.90序号: 7, 书名: 孤独深处(收录雨果奖获奖作品《北京折叠》), 价格: 21.90序号: 8, 书名: 世界知名企业员工指定培训教材:所谓情商高,就是会说话, 价格: 22.00序号: 9, 书名: 人间草木, 价格: 30.00序号: 10, 书名: 你的善良必须有点锋芒, 价格: 20.50序号: 11, 书名: 这么慢,那么美, 价格: 24.80序号: 12, 书名: 考拉小巫的英语学习日记:写给为梦想而奋斗的人(全新修订版), 价格: 23.90</code></pre><pre><code class="python">conn.row_factory = sqlite3.Rowcur = conn.cursor()cur.execute(&#39;SELECT * FROM book&#39;)rows = cur.fetchall()# 通过列名访问for row in rows:    print (&#39;序号: %i, 书名: %s, 价格: %.2f&#39; %(row[&#39;id&#39;], row[&#39;name&#39;], row[&#39;price&#39;]))</code></pre><pre><code>序号: 1, 书名: 肖秀荣考研书系列:肖秀荣(2017)考研政治命题人终极预测4套卷, 价格: 14.40序号: 2, 书名: 法医秦明作品集:幸存者+清道夫+尸语者+无声的证词+第十一根手指(套装共5册) (两种封面随机发货), 价格: 100.00序号: 3, 书名: 活着本来单纯:丰子恺散文漫画精品集(收藏本), 价格: 30.90序号: 4, 书名: 自在独行:贾平凹的独行世界, 价格: 26.80序号: 5, 书名: 当你的才华还撑不起你的梦想时, 价格: 23.00序号: 6, 书名: 巨人的陨落(套装共3册), 价格: 84.90序号: 7, 书名: 孤独深处(收录雨果奖获奖作品《北京折叠》), 价格: 21.90序号: 8, 书名: 世界知名企业员工指定培训教材:所谓情商高,就是会说话, 价格: 22.00序号: 9, 书名: 人间草木, 价格: 30.00序号: 10, 书名: 你的善良必须有点锋芒, 价格: 20.50序号: 11, 书名: 这么慢,那么美, 价格: 24.80序号: 12, 书名: 考拉小巫的英语学习日记:写给为梦想而奋斗的人(全新修订版), 价格: 23.90</code></pre><pre><code class="python">conn.close()</code></pre><h2 id="五、SQLite-json-操作"><a href="#五、SQLite-json-操作" class="headerlink" title="五、SQLite_json 操作"></a>五、SQLite_json 操作</h2><pre><code class="python">import sqlite3db_path = &#39;./files/test_join.sqlite&#39;conn = sqlite3.connect(db_path)cur = conn.cursor()</code></pre><pre><code class="python"># 建 depaetment 表，并插入数据cur.execute(&quot;DROP TABLE IF EXISTS department&quot;)cur.execute(&quot;CREATE TABLE department(\                id INT PRIMARY KEY NOT NULL, \                dept CHAR(50) NOT NULL, \                emp_id INT NOT NULL)&quot;)depts = (        (1, &#39;IT Builing&#39;, 1),        (2, &#39;Engineerin&#39;, 2),        (3, &#39;Finance&#39;, 7))cur.executemany(&quot;INSERT INTO department VALUES(?, ?, ?)&quot;, depts)</code></pre><pre><code>&lt;sqlite3.Cursor at 0x2d2d64f70a0&gt;</code></pre><pre><code class="python">conn.commit()</code></pre><h3 id="CROSS-JOIN-交叉连接"><a href="#CROSS-JOIN-交叉连接" class="headerlink" title="CROSS JOIN 交叉连接"></a>CROSS JOIN 交叉连接</h3><pre><code class="python">cur.execute(&quot;SELECT emp_id, name, dept FROM company CROSS JOIN department;&quot;)rows = cur.fetchall()for row in rows:    print (row)</code></pre><pre><code class="python"># 建 company 表，并插入数据cur.execute(&quot;DROP TABLE IF EXISTS company&quot;)cur.execute(&quot;CREATE TABLE company(\                    id INT PRIMARY KEY NOT NULL, \                    name CHAR(50) NOT NULL, \                    age INT NOT NULL, \                    address CHAR(50) NOT NULL,\                    salary DOUBLE NOT NULL)&quot;)companies = (        (1, &#39;Paul&#39;, 32, &#39;California&#39;, 20000.0),        (2, &#39;Allen&#39;, 25, &#39;Texas&#39;, 15000.0),        (3, &#39;Teddy&#39;, 23, &#39;Norway&#39;, 20000.0),        (4, &#39;Mark&#39;, 25, &#39;Rich-Mond&#39;, 65000.0),        (5, &#39;David&#39;, 27, &#39;Texas&#39;, 85000.0),        (6, &#39;Kim&#39;, 22, &#39;South-Hall&#39;, 45000.0),        (7, &#39;James&#39;, 24, &#39;Houston&#39;, 10000.0))cur.executemany(&quot;INSERT INTO company VALUES (?, ?, ?, ?, ?)&quot;, companies)</code></pre><pre><code>&lt;sqlite3.Cursor at 0x2d2d64f70a0&gt;</code></pre><h3 id="INNER-JOIN-内连接"><a href="#INNER-JOIN-内连接" class="headerlink" title="INNER JOIN 内连接"></a>INNER JOIN 内连接</h3><pre><code class="python">cur.execute(&quot;SELECT emp_id, name, dept FROM company INNER JOIN department \            ON company.id = department.emp_id;&quot;)rows = cur.fetchall()for row in rows:    print (row)</code></pre><pre><code>(1, &#39;Paul&#39;, &#39;IT Builing&#39;)(2, &#39;Allen&#39;, &#39;Engineerin&#39;)(7, &#39;James&#39;, &#39;Finance&#39;)</code></pre><h3 id="OUTER-JOIN-外连接"><a href="#OUTER-JOIN-外连接" class="headerlink" title="OUTER JOIN 外连接"></a>OUTER JOIN 外连接</h3><pre><code class="python"># 左连接cur.execute(&quot;SELECT emp_id, name, dept FROM company LEFT OUTER JOIN department \            ON company.id = department.emp_id;&quot;)rows = cur.fetchall()for row in rows:    print (row)</code></pre><pre><code>(1, &#39;Paul&#39;, &#39;IT Builing&#39;)(2, &#39;Allen&#39;, &#39;Engineerin&#39;)(None, &#39;Teddy&#39;, None)(None, &#39;Mark&#39;, None)(None, &#39;David&#39;, None)(None, &#39;Kim&#39;, None)(7, &#39;James&#39;, &#39;Finance&#39;)</code></pre><pre><code class="python"># 右连接 （目前不支持）cur.execute(&quot;SELECT emp_id, name, dept FROM company RIGHT OUTER JOIN department \            ON company.id = department.emp_id;&quot;)rows = cur.fetchall()for row in rows:    print (row)</code></pre><pre><code>---------------------------------------------------------------------------OperationalError                          Traceback (most recent call last)&lt;ipython-input-41-ce0fc573748b&gt; in &lt;module&gt;      1 # 右连接 （目前不支持）      2 cur.execute(&quot;SELECT emp_id, name, dept FROM company RIGHT OUTER JOIN department \----&gt; 3             ON company.id = department.emp_id;&quot;)      4 rows = cur.fetchall()      5 for row in rows:OperationalError: RIGHT and FULL OUTER JOINs are not currently supported</code></pre><pre><code class="python"># 右连接，交换两张表cur.execute(&quot;SELECT emp_id, name, dept FROM department LEFT OUTER JOIN company \            ON company.id = department.emp_id;&quot;)rows = cur.fetchall()for row in rows:    print (row)</code></pre><pre><code>(1, &#39;Paul&#39;, &#39;IT Builing&#39;)(2, &#39;Allen&#39;, &#39;Engineerin&#39;)(7, &#39;James&#39;, &#39;Finance&#39;)</code></pre><pre><code class="python">sqlite&gt; SELECT EMP_ID, NAME, DEPT FROM COMPANY LEFT OUTER JOIN DEPARTMENT      ON COMPANY.ID = DEPARTMENT.EMP_ID;</code></pre><pre><code>  File &quot;&lt;ipython-input-43-a0833b733075&gt;&quot;, line 1    sqlite&gt; SELECT EMP_ID, NAME, DEPT FROM COMPANY LEFT OUTER JOIN DEPARTMENT                        ^SyntaxError: invalid syntax</code></pre><h2 id="六、Excel-文件操作"><a href="#六、Excel-文件操作" class="headerlink" title="六、Excel 文件操作"></a>六、Excel 文件操作</h2><p>pandas.read_excel(io, sheet_name=0, header=0, names=None, index_col=None, usecols=None, squeeze=False, dtype=None, engine=None, converters=None, true_values=None, false_values=None, skiprows=None, nrows=None, na_values=None, keep_default_na=True, verbose=False, parse_dates=False, date_parser=None, thousands=None, comment=None, skipfooter=0, convert_float=True, mangle_dupe_cols=True, **kwds)</p><p>df_fujian = pd.read_excel(“./datafiles/fujian.xlsx”,sheet_name=’日数据’)</p><h2 id="Jupyter-Notebook-的安装"><a href="#Jupyter-Notebook-的安装" class="headerlink" title="Jupyter Notebook 的安装"></a>Jupyter Notebook 的安装</h2><p>一般有两种方法，第一种是下载 Anaconda，自带 python 环境以及 Jupyter Notebook 环境，但这一般都是刚学机器学习那会的集成安装方式，<del>最主要的劝退原因是所占体积较大，所以这里介绍原生的安装方式，在纯 Python 环境下，使用自带的 pip 包管理工具下载，类似地像 Pandas、Numpy 等包也可以以此种方式安装</del>。</p><p>打脸 YYDS，收回上面画斜线的文字，因为自己以前的笔记里面，有许多其他库，一个一个安装太繁杂了，所以还是下载 Anaconda 集成环境吧。<br><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1640601860364-c314af96-93ca-44c7-a1f3-f56281bc0358.jpeg#id=JxlHZ&originHeight=56&originWidth=52&originalType=binary%E2%88%B6=1&status=done&style=none"><br>具体下载配置参考之前的文章：<a href="https://www.wztlink1013.com/blog/mv7tir/">Pycharm,Anaconda,JetBrains 系列 app 相关总结 | 尼采般地抒情</a></p><h3 id="安装-python"><a href="#安装-python" class="headerlink" title="安装 python"></a>安装 python</h3><p>地址：<a href="https://www.python.org/downloads/windows/">https://www.python.org/downloads/windows/</a><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1640599312775-072daad3-4d63-44a3-9d12-f01c4bbf8e94.png#clientId=u2292d7fa-9c27-4&from=paste&height=93&id=u9139fb50&margin=%5Bobject%20Object%5D&name=image.png&originHeight=185&originWidth=728&originalType=binary%E2%88%B6=1&size=15279&status=done&style=none&taskId=ud116e129-dab4-49ec-ae46-05cd10ddcc7&width=364" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1640599331716-24f74d29-d0d3-48d3-8ac8-98677a0a7f02.png#clientId=u2292d7fa-9c27-4&from=paste&height=219&id=u67f784d6&margin=%5Bobject%20Object%5D&name=image.png&originHeight=438&originWidth=1319&originalType=binary%E2%88%B6=1&size=90472&status=done&style=none&taskId=uea4c39b8-b55c-4d0d-b1cf-09fa248c859&width=659.5" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1640599684114-22e00be7-1d4d-4429-89a3-749721cc6dc9.png#clientId=u2292d7fa-9c27-4&from=paste&height=307&id=u77942fec&margin=%5Bobject%20Object%5D&name=image.png&originHeight=614&originWidth=997&originalType=binary%E2%88%B6=1&size=248551&status=done&style=none&taskId=ue6b5fb11-a944-49f2-938b-e72c4649102&width=498.5" alt="image.png"><br>安装完之后进入 cmd 查看<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1640599838509-509dc0d6-0ead-4d97-8c9a-c99b9ee2451d.png#clientId=u2292d7fa-9c27-4&from=paste&height=108&id=ubc4fd658&margin=%5Bobject%20Object%5D&name=image.png&originHeight=216&originWidth=1440&originalType=binary%E2%88%B6=1&size=31958&status=done&style=none&taskId=u8b40a744-5178-4de1-9707-7974ea413cd&width=720" alt="image.png"></p><h3 id="安装-jupyter"><a href="#安装-jupyter" class="headerlink" title="安装 jupyter"></a>安装 jupyter</h3><pre><code class="powershell">pip install jupyter</code></pre><p>安装成功之后，在项目文件夹下，打开 powershell 终端输入：jupyter notebook<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1640601099229-bf7d396d-3c7c-4971-9552-459fccf9b37a.png#clientId=u2292d7fa-9c27-4&from=paste&height=285&id=u525810b2&margin=%5Bobject%20Object%5D&name=image.png&originHeight=570&originWidth=1440&originalType=binary%E2%88%B6=1&size=114883&status=done&style=none&taskId=uea1c66bc-9a4b-4e35-845d-7c547bb3ed2&width=720" alt="image.png"></p><h2 id="报错"><a href="#报错" class="headerlink" title="报错"></a>报错</h2><h3 id="ValueError-check-hostname-requires-server-hostname"><a href="#ValueError-check-hostname-requires-server-hostname" class="headerlink" title="ValueError: check_hostname requires server_hostname"></a>ValueError: check_hostname requires server_hostname</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1640600263157-e7be09d6-1de3-4a8e-8387-5711d8c0814b.png#clientId=u2292d7fa-9c27-4&from=paste&height=132&id=ue7f0bb3a&margin=%5Bobject%20Object%5D&name=image.png&originHeight=264&originWidth=1894&originalType=binary%E2%88%B6=1&size=62307&status=done&style=none&taskId=ufc1db7b2-7bc4-4573-b3be-be50266e541&width=947" alt="image.png"><br>关掉 tizi</p><h3 id="ReadTimeoutError-HTTPSConnectionPool-host-’files-pythonhosted-org’-port-443-Read-timed-out"><a href="#ReadTimeoutError-HTTPSConnectionPool-host-’files-pythonhosted-org’-port-443-Read-timed-out" class="headerlink" title="ReadTimeoutError: HTTPSConnectionPool(host=’files.pythonhosted.org’, port=443): Read timed out."></a>ReadTimeoutError: HTTPSConnectionPool(host=’files.pythonhosted.org’, port=443): Read timed out.</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1640600450333-c5b616f4-6f9c-41d5-ac8b-ad6a3a0cd5ad.png#clientId=u2292d7fa-9c27-4&from=paste&height=75&id=u99c9113d&margin=%5Bobject%20Object%5D&name=image.png&originHeight=150&originWidth=1565&originalType=binary%E2%88%B6=1&size=40157&status=done&style=none&taskId=u500b3749-fe5f-4a95-9a08-14104078dfe&width=782.5" alt="image.png"><br>按照报错信息，更新 pip</p><h2 id="数据分析"><a href="#数据分析" class="headerlink" title="数据分析"></a>数据分析</h2><p>本地数据的读取</p>]]></content>
      
      
      <categories>
          
          <category> ✨其他 </category>
          
          <category> 数据分析 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>编程习惯</title>
      <link href="/blog/ml46ei/"/>
      <url>/blog/ml46ei/</url>
      
        <content type="html"><![CDATA[<h2 id="一、代码"><a href="#一、代码" class="headerlink" title="一、代码"></a>一、代码</h2><h3 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h3><ul><li>项目：小写字母 <code>datastructure</code></li><li>包：<code>com.公司名.项目名.模块名....</code>（其中模块名可以按照功能/逻辑来分）</li><li>类：全部首字母大写，一般驼峰式命名 <code>public class TestBan&#123;&#125;</code></li><li>常量：全部大写字母 <code>String RE_PRI = ‘wztlink’</code></li><li>变量：下划线方式  <code>int pri_const</code></li><li>方法：首字母小写，如果有多个单词，单词首字母大写 <code>public void toString()&#123;&#125;</code></li></ul><h3 id="注释规范"><a href="#注释规范" class="headerlink" title="注释规范"></a>注释规范</h3><div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">文件注释</div><pre><code class="java">  / *    * 文件名：[文件名]    * 作者：〈版权〉    * 描述：〈描述〉    * 修改人：Wu ZuTao    * 修改时间：2020-06-06    * 修改内容：新增X方法    * 修改人：Wu ZuTao    * 修改时间：2020-07-01    * 修改内容：修改B模块    * /</code></pre><div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">类和接口的注释：该注释放在class定义之前，using或package关键字之后。</div><pre><code class="java">package com.wztlink.xxx;/**  * 注释内容  */public class XxxManager</code></pre><pre><code class="java">/ *  * 〈一句话功能简述〉  * 〈功能详细描述〉  * @author [作者]  * @version [版本号, YYYY-MM-DD]  * @see [相关类/方法]  * @since [产品/模块版本]  * @deprecated  */</code></pre><div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">函数注释</div><pre><code class="java"> /**    * 类方法的详细使用说明    *    * @param 参数1 参数1的使用说明    * @return 返回结果的说明    * @throws 异常类型.错误代码 注明从此类方法中抛出异常的说明    */</code></pre><div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">方法内部、属性、必要语句</div><pre><code class="java">// 注释内容private String logType</code></pre><div style="background: #FFF3F3;padding:10px;border: 1px solid #DEB8BE;border-radius:5px;margin-bottom:5px;">注意事项</div><ul><li>边写代码边注释，修改代码同时修改相应的注释，以保证注释与代码的一致性。不再有用的注释要删除。</li><li>避免在注释中使用缩写，特别是不常用缩写。说明：在使用缩写时或之前，应对缩写进行必要的说明。 注释应该放在被注释的代码前面，分行展示，但中间不留空行。</li><li><a href="https://blog.csdn.net/vbirdbest/article/details/80296136">javadoc 使用规范</a></li></ul><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>主入口函数和其他功能函数分开，如果是功能性函数，全部放到一个 <code>Tools</code>  函数里面</p><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><p>不要在自己类下定义自己的对象</p><h2 id="二、项目"><a href="#二、项目" class="headerlink" title="二、项目"></a>二、项目</h2><h3 id="解决写不出代码的方法"><a href="#解决写不出代码的方法" class="headerlink" title="解决写不出代码的方法"></a>解决写不出代码的方法</h3><blockquote><p>参考：<a href="https://www.cnblogs.com/luchuangao/p/6821210.html">https://www.cnblogs.com/luchuangao/p/6821210.html</a></p></blockquote><blockquote><p>1、先分析实现的思路</p></blockquote><p>拿到作业，按照要实现的功能，先分析去实现的思路。<br>如果完全不知道该怎么去实现，一头雾水，最好先看看其他人事如何实现的，或者与老师或同学讨论。<br>重点是要找到解决问题的办法，理清实现的思路。<br>如果自己能想出几步来，那就先把这几步记录下来，然后重复上面的步骤。</p><blockquote><p>2、把实现的思路边分析边记录下来。</p></blockquote><p>在分析实现思路的时候，边分析，边写出来，使用中文写，写得详细点。<br>如果在编程工具里面写的话，直接写成注释，比如：<br>第一步是要干上面<br>第 1.1 要做什么<br>第 1.2 要做什么<br>第二步是要干上面<br>第 2.1 要做什么<br>第 2.2 要做什么<br>…以此类推<br>遇到写不下去的地方，先看看是没有思路还是前面的思路没有想清楚<br>如果是没有思路了，参见第一条处理。<br>如果是前面的思路没有想清楚，那就返回来重新思考，一定要考虑明白。<br>这其实也是这个方法一个额外的好处，那就是能强迫你思考，并进行细致考虑。</p><blockquote><p>3、写实现代码</p></blockquote><p>如果思路整理清楚了，实现思路的步骤也整理好了，这个时候再写代码，<br>几乎就是个翻译的过程，很容易实现。<br>如果只是几步思路清楚了，也没有关系，想清楚多少，就写多少代码，慢慢来。</p><blockquote><p>4、有思路但是写不出代码的解决方法</p></blockquote><p>这种情况常出现在初学者身上，主要是代码写少了。（这种情况需每日练习两百到三百行代码）<br>建议多看看别人怎么写的，积累代码的写法，这一次不会写不要紧。<br>见过一回，下次会写九可以了，积少成多，写得多了，自己能实现的也就多了。</p><blockquote><p>5、方法不一定照搬，可以变通使用</p></blockquote><p>比如边分析、边写思路然后就编写代码也是可以的，只要能有助你思考，都可以。</p><blockquote><p>6、写不出代码</p></blockquote><p>大多数人在写不出代码的时候，都不是完全写不出来，也不是一点都写不出来，请尽量把会的、能写出来的先写出来，多按照本文介绍的方法去练习，量变到质变，很快就能自己写出实现代码来。</p><h3 id="提高代码阅读能力"><a href="#提高代码阅读能力" class="headerlink" title="提高代码阅读能力"></a>提高代码阅读能力</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1602593438617-6e64c23d-0230-4104-b1b5-6ccd512ad999.png#align=left&display=inline&height=100&id=R0FDZ&margin=%5Bobject%20Object%5D&name=image.png&originHeight=199&originWidth=1017&size=53543&status=done&style=shadow&width=508.5" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1602593456351-275ca8e5-583b-499b-aca4-e4295b312c55.png#align=left&display=inline&height=157&id=T4RUm&margin=%5Bobject%20Object%5D&name=image.png&originHeight=313&originWidth=1008&size=102518&status=done&style=shadow&width=504" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1602593476552-c6a6f01f-1d45-40e7-93b5-be56bc08e0c7.png#align=left&display=inline&height=170&id=GkcIC&margin=%5Bobject%20Object%5D&name=image.png&originHeight=339&originWidth=1010&size=98037&status=done&style=shadow&width=505" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1602593492992-c4a224fc-10e7-478e-9424-c90da2b4805a.png#align=left&display=inline&height=88&id=IOPvY&margin=%5Bobject%20Object%5D&name=image.png&originHeight=176&originWidth=996&size=51461&status=done&style=shadow&width=498" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1602593510079-399972ba-bee4-4dbc-81c9-ae619486f7da.png#align=left&display=inline&height=202&id=NibYg&margin=%5Bobject%20Object%5D&name=image.png&originHeight=403&originWidth=996&size=126977&status=done&style=shadow&width=498" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1602593528314-e583f78d-6f87-46d1-826d-841629871530.png#align=left&display=inline&height=163&id=rKWh8&margin=%5Bobject%20Object%5D&name=image.png&originHeight=325&originWidth=1013&size=96139&status=done&style=shadow&width=506.5" alt="image.png"><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1602593547023-cbcc3eac-6350-4b92-856d-0cfd2a1ccf75.png#align=left&display=inline&height=98&id=z7WrI&margin=%5Bobject%20Object%5D&name=image.png&originHeight=196&originWidth=1011&size=52272&status=done&style=shadow&width=505.5" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 软件工程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>调试解决总结</title>
      <link href="/blog/mtigbx/"/>
      <url>/blog/mtigbx/</url>
      
        <content type="html"><![CDATA[<h2 id="一、关于-bug"><a href="#一、关于-bug" class="headerlink" title="一、关于 bug"></a>一、关于 bug</h2><p>在编写程序过程中，总会出现各种各样的 bug，按 bug 得类型来分的话</p><ul><li>程序的逻辑出错</li><li>程序语法出错编译器不能通过</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1656489641864-8b7034fc-63aa-437e-ad29-db2d35dcc3d1.png#clientId=ud76c9b60-0b11-4&crop=0&crop=0&crop=1&crop=1&from=drop&id=u5afa8d31&margin=%5Bobject%20Object%5D&name=f0066b5a4abb9270f6fe37ad30a920d0_533x400.png&originHeight=400&originWidth=533&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=54278&status=done&style=none&taskId=u62f885d1-e332-4578-8bc3-3260d8d3be9&title=" alt="f0066b5a4abb9270f6fe37ad30a920d0_533x400.png"><br>对待 bug，心态端正，不抵触不畏惧不怕麻烦，要想着解 bug 就是这个职业的要务之一，有耐心，积极主动的去解决问题。一步一步的解决问题，所有的技术都是熟能生巧、</p><h2 id="二、解决-bug-的一些方法"><a href="#二、解决-bug-的一些方法" class="headerlink" title="二、解决 bug 的一些方法"></a>二、解决 bug 的一些方法</h2><h3 id="报错信息-理论知识"><a href="#报错信息-理论知识" class="headerlink" title="报错信息+理论知识"></a>报错信息+理论知识</h3><p>当一个 bug 摆在面前，首先要做的就是要认真阅读展现出来的出错信息，这里面有几点需要注意</p><blockquote><p><strong>提高英语</strong></p></blockquote><p>专业词汇的积累、阅读能力等</p><blockquote><p><strong>运用底层知识</strong></p></blockquote><p>学会运行所学过的理论知识，比如在编程过程中，出现路径相关的错误，首先是根据报错可以直接在代码里面更改为正确可运行代码，然后可以利用所学过的操作系统相关文件管理知识等来进一步底层分析之，最后可以旁通自己之前搭建环境过程种总是要配的环境变量，一起思考一起分析，发散性思考，触类旁通所学知识，运用之</p><blockquote><p><strong>IDE 的 Debug 或 print 通法</strong></p></blockquote><p>熟悉各种开发环境的 debug</p><h3 id="搜索引擎"><a href="#搜索引擎" class="headerlink" title="搜索引擎"></a>搜索引擎</h3><blockquote><p><strong>一个原则</strong>：“遇事不决，大事谷歌，小事百度”</p></blockquote><ul><li>谷歌需要一些手段才能进行，总结下来就是<strong>搭建一个机场</strong>，方便，安全</li><li>百度解决一些小问题，抑或是 <strong>“烂大街的易错知识”</strong></li><li>相关编程论坛，比如 Stack Overflow、CSDN、博客园等（还是要用谷歌）</li></ul><blockquote><p><strong>结果择优原则</strong></p></blockquote><ul><li>环境统一：解决办法的环境需要和自己的 bug 的环境需要一致</li><li>非毁灭性原则：尽量不要做全局性的修改，比如用命令删除 git 的两个文件来改一个小 bug，属实挖坑</li></ul><blockquote><p><strong>擅用官方文档</strong></p></blockquote><p>如果说出现的 bug 抑或是，使用某个知识出错，是在官方文档中能查到的，优先选择官方文档</p><p>就比如在使用 python 数据分析的时候，许多时候，很多包（pandas、numpy、matplotlib 等）更新比较快，而网上找的一般都是旧版本的指导。同时<br>官方文档讲解更加全面，不过这过程中，要注意提高自身英语水平！</p><h3 id="复盘与重构"><a href="#复盘与重构" class="headerlink" title="复盘与重构"></a>复盘与重构</h3><blockquote><p><strong>复盘</strong></p></blockquote><p>去复现一个学习（复现代码）过程，<strong>复盘</strong>bug 之前的工作，来从中找出可能有哪些细节会导致出现该 bug。</p><blockquote><p><strong>重构</strong></p></blockquote><p>按照思路重写代码！再不行重装系统！</p><p>重构，让你的代码更优美和简洁~</p><p>重装，让你的世界焕然一新~</p><h2 id="三、多记录多总结多仔细"><a href="#三、多记录多总结多仔细" class="headerlink" title="三、多记录多总结多仔细"></a>三、多记录多总结多仔细</h2><blockquote><p>bug 遇见的多了，也就由“形同陌路”转变为“日久生情”了!<br>良好的编程习惯加快解决速度</p></blockquote><p>做事情还是粗心，百分之九十的 bug 都来源于粗心，</p><h2 id="四、持续补充"><a href="#四、持续补充" class="headerlink" title="四、持续补充"></a>四、持续补充</h2><ul><li>在利用搜索引擎找到解决办法时候，不要 <strong>吃着嘴里的，想着锅里的</strong> ，找到一个办法，先将其解决办法看懂看透彻，不要这个方法还没看透彻就看下一个答案。</li><li>学会提取关键词来搜索，能提高很大效率</li></ul>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 软件工程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>爬虫架构和Scrapy框架使用</title>
      <link href="/blog/zsvfxg/"/>
      <url>/blog/zsvfxg/</url>
      
        <content type="html"><![CDATA[<h2 id="一、爬虫基本架构"><a href="#一、爬虫基本架构" class="headerlink" title="一、爬虫基本架构"></a>一、爬虫基本架构</h2><h3 id="url-管理模块"><a href="#url-管理模块" class="headerlink" title="url 管理模块"></a>url 管理模块</h3><ul><li>就是管理自己爬取的的网页不要重复爬取，避免爬取进入死循环</li><li>使用 python 当中的 set 数据结构</li></ul><h3 id="网页下载模块"><a href="#网页下载模块" class="headerlink" title="网页下载模块"></a>网页下载模块</h3><blockquote><p>将对应的 url 模块下载到本地或者读入内存</p></blockquote><blockquote><p>实现方式</p></blockquote><ul><li>通过 url 下载</li></ul><pre><code class="python">from urllib.request import urlopentest_url = &quot;https://wztlink1013.github.io&quot;response = urlopen(test_url)print (response.getcode()) # 200 表示访问成功print (response.read())</code></pre><ul><li>通过 Request 访问</li><li>通过 cookie 访问</li></ul><h3 id="网页解析模块"><a href="#网页解析模块" class="headerlink" title="网页解析模块"></a>网页解析模块</h3><blockquote><p>从已经下载的网页中爬取数据，实现方式有：</p></blockquote><ol><li>正则表达式</li><li>html.parser</li><li><strong>BeautifulSoup：结构化解析网页</strong></li><li>lxml</li><li>结构化解析</li><li>DOM（Document Object Model），树形结构，就是 html 的基本骨架</li></ol><h2 id="二、BeautifulSoup-解析网页"><a href="#二、BeautifulSoup-解析网页" class="headerlink" title="二、BeautifulSoup 解析网页"></a>二、BeautifulSoup 解析网页</h2><h2 id="三、Scrapy"><a href="#三、Scrapy" class="headerlink" title="三、Scrapy"></a>三、Scrapy</h2><h3 id="Scrapy-基础"><a href="#Scrapy-基础" class="headerlink" title="Scrapy 基础"></a>Scrapy 基础</h3><ul><li>是一个爬虫框架，同时易扩展，可以添加新的模块达到自定义扩展</li><li>输出格式多样：json，csv，xml 等</li><li>自动处理编码</li></ul><h3 id="Scrapy-框架架构图"><a href="#Scrapy-框架架构图" class="headerlink" title="Scrapy 框架架构图"></a>Scrapy 框架架构图</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/webp/1484158/1598673193957-7a7456b0-3de1-4c77-b849-cc2572555ed5.webp#align=left&display=inline&height=281&margin=%5Bobject%20Object%5D&originHeight=541&originWidth=801&size=0&status=done&style=shadow&width=416"></p><blockquote><p>下载方法以及问题，在 anaconda 博客中</p></blockquote><h2 id="四、Scrapy-使用"><a href="#四、Scrapy-使用" class="headerlink" title="四、Scrapy 使用"></a>四、Scrapy 使用</h2><h3 id="使用-SOP"><a href="#使用-SOP" class="headerlink" title="使用 SOP"></a>使用 SOP</h3><ul><li>创建工程<ul><li>键入<code>cmd</code> <code>cd</code>到需要下载的目录下</li><li>输入<code>scrapy startproject tutorial</code>（最后是项目名字）</li><li><strong>!此后所有有关命令的操作，均在下一级文件夹下，也有是有 cfg 文件后缀的文件夹下</strong></li></ul></li><li>定义 Item，构造爬取的对象</li><li>编写 spider，爬虫主体<ul><li><code>scrapy genspider amazon_spider https://……</code></li></ul></li><li>pipelines，默认 return item</li><li>编写其他配置，其中 pipeline 用于处理爬取后所得到的结果</li><li>执行爬虫<ul><li><code>scrapy crawl amazon_spider</code></li></ul></li></ul><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>查看其官方文档</li><li><a href="https://www.jianshu.com/p/8023fccd7206">简书</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> ✨其他 </category>
          
          <category> 数据分析 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JavaWeb学习笔记</title>
      <link href="/blog/tb3der/"/>
      <url>/blog/tb3der/</url>
      
        <content type="html"><![CDATA[<div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">大二下学期上课笔记</div><h1 id="【第二章】JavaWeb-概述"><a href="#【第二章】JavaWeb-概述" class="headerlink" title="【第二章】JavaWeb 概述"></a>【第二章】JavaWeb 概述</h1><h2 id="一、XML"><a href="#一、XML" class="headerlink" title="一、XML"></a>一、XML</h2><p><code>XML</code>  是一种标记性语言，但是不同于 <code>HTML</code> ，目的其实就是用于传输数据，但是 <code>HTML</code>  的目的可以理解为展示</p><blockquote><p>网站建好之后，需要将自己的文章链接提交到百度/谷歌，通过部署生成的<code>baidusitemap.xml</code>和<code>sitemap.xml</code>文件，sitemap 提交方式提交以达到目的。</p></blockquote><h3 id="XML-语法"><a href="#XML-语法" class="headerlink" title="XML 语法"></a>XML 语法</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598670375381-0e3b13a8-6a22-47fb-8e8f-32c203fbf25d.png#align=left&display=inline&height=207&margin=%5Bobject%20Object%5D&originHeight=388&originWidth=866&size=0&status=done&style=shadow&width=461"></p><ul><li>文档声明：图中最上面一行</li><li>元素定义：形式相当于 <code>HTML</code>  当中的标签，但不是标签，有根元素（一般只有一个），空元素等之分</li><li>属性定义：其中值需要用双引号或者单引号括起来</li><li>注释：和 <code>HTML</code>  一样</li></ul><h3 id="DTD-和-Schema-约束"><a href="#DTD-和-Schema-约束" class="headerlink" title="DTD 和 Schema 约束"></a>DTD 和 Schema 约束</h3><p>有些时候文档内可能内容语义有歧义，所以需要对其 xml 文件内容尽可能的加以约束，DTD 和 Schema 两种方式</p><h2 id="二、HTTP-协议"><a href="#二、HTTP-协议" class="headerlink" title="二、HTTP 协议"></a>二、HTTP 协议</h2><blockquote><p>生成的 web 项目和服务器之间的传输协议</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598670375263-a1f1c0c1-0d94-4f9d-97ed-9d8e7e1d2495.png#align=left&display=inline&height=127&margin=%5Bobject%20Object%5D&originHeight=127&originWidth=305&size=0&status=done&style=shadow&width=305"></p><blockquote><p>其中 http1.1 版本比 1.0 版本优化的是对 http 请求可以同时进行多个请求和响应</p></blockquote><h3 id="HTTP-请求消息"><a href="#HTTP-请求消息" class="headerlink" title="HTTP 请求消息"></a>HTTP 请求消息</h3><blockquote><p>客户端（web 浏览器）向服务器发送请求，通常由请求行、请求头、实体内容三部分组成</p></blockquote><ul><li>请求行：请求方式，资源路径，http 协议版本三部分组成。请求方式又有 GET（所请求内容会在资源路径后面带上参数值，会有大小限制）和 POST（安全，无大小限制）等方式</li></ul><h3 id="HTTP-响应消息"><a href="#HTTP-响应消息" class="headerlink" title="HTTP 响应消息"></a>HTTP 响应消息</h3><blockquote><p>也由三部分组成，有资源状态行、响应消息头、实体内容</p></blockquote><ul><li>资源状态行：协议版本 状态码 状态描述三部分组成。其中状态码有多种，常见的 404 就是服务器找不到相应请求的的资源</li></ul><h2 id="三、Tomcat"><a href="#三、Tomcat" class="headerlink" title="三、Tomcat"></a>三、Tomcat</h2><h3 id="关于-Tomcat"><a href="#关于-Tomcat" class="headerlink" title="关于 Tomcat"></a>关于 Tomcat</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598670375411-c8675707-4396-48f4-b181-07310231b868.png#align=left&display=inline&height=174&margin=%5Bobject%20Object%5D&originHeight=250&originWidth=844&size=0&status=done&style=shadow&width=588"></p><h3 id="下载安装-Tomcat"><a href="#下载安装-Tomcat" class="headerlink" title="下载安装 Tomcat"></a>下载安装 Tomcat</h3><p>安装等方式参考博客</p><h2 id="四、Web-应用"><a href="#四、Web-应用" class="headerlink" title="四、Web 应用"></a>四、Web 应用</h2><h3 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h3><blockquote><p>web 应用，就是一项工程，在编写 web 项目过程中，对文件按照“合乎规矩”的方式放置</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598670375598-ac6ece9f-6982-4a1d-a7d8-bc3c8b4ce0f7.png#align=left&display=inline&height=352&margin=%5Bobject%20Object%5D&originHeight=614&originWidth=830&size=0&status=done&style=shadow&width=476"></p><h3 id="IDEA-配置-Tomcat"><a href="#IDEA-配置-Tomcat" class="headerlink" title="IDEA 配置 Tomcat"></a>IDEA 配置 Tomcat</h3><p>搭建 web 开发环境</p><p>资源的访问，点击请求的页面跳转设置<code>web.xml</code>中配置</p><blockquote><p>阮一峰的网站当中，有类似域名自动跳转，是否和域名解析有关呢？抑或是对 web.xml 进行了操作？</p></blockquote><p>对 idea 进行 web 开发 配置<a href="https://blog.csdn.net/ZTlink1013/article/details/104815639">https://blog.csdn.net/ZTlink1013/article/details/104815639</a></p><h1 id="【第三章】Servlet"><a href="#【第三章】Servlet" class="headerlink" title="【第三章】Servlet"></a>【第三章】Servlet</h1><h2 id="一、什么是-Servlet"><a href="#一、什么是-Servlet" class="headerlink" title="一、什么是 Servlet"></a>一、什么是 Servlet</h2><h3 id="什么是-Servlet"><a href="#什么是-Servlet" class="headerlink" title="什么是 Servlet"></a>什么是 Servlet</h3><blockquote><p>Servlet 就是在服务器端的 Java 接口或者说是类（叫法有狭义广义之分），处理客户端传来的请求并作出相应的响应这么一个网络模块。</p></blockquote><ul><li>请求：客户端传来的调用或是一系列行为，同时也包含了请求所需要的数据。</li><li>响应：服务器根据客户端传来的请求做出响应，实时的展示给客户端。这之中 Servlet 相当于 java 类当中的一个接口，以请求来的信息作为输入，然后进行分析，做出相应。</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598670486756-3febd732-e4ee-413d-8868-a406760f5a22.png#align=left&display=inline&height=134&margin=%5Bobject%20Object%5D&originHeight=222&originWidth=783&size=0&status=done&style=shadow&width=472"></p><h3 id="JSP-和-Servlet"><a href="#JSP-和-Servlet" class="headerlink" title="JSP 和 Servlet"></a>JSP 和 Servlet</h3><blockquote><p>servlet 是控制层，jsp 转换为 servlet，用 servlet 来实现 http 请求。</p></blockquote><p>【1】JSP 第一次运行的时候会编译成 Servlet，驻留在内存中以供调用。</p><p>【2】JSP 是 web 开发技术，Servlet 是服务器端运用的小程序，我们访问一个 JSP 页面时，服务器会将这个 JSP 页面转变成 Servlet 小程序运行得到结果后，反馈给用户端的浏览器。</p><p>【3】Servlet 相当于一个控制层再去调用相应的 JavaBean 处理数据,最后把结果返回给 JSP。</p><p>【4】Servlet 主要用于转向，将请求转向到相应的 JSP 页面。</p><p>【5】JSP 更多的是进行页面显示，Servlet 更多的是处理业务，即 JSP 是页面，Servlet 是实现 JSP 的方法。</p><p>【6】Servlet 可以实现 JSP 的所有功能，但由于美工使用 Servlet 做界面非常困难，后来开发了 JSP。</p><p>【7】JSP 技术开发网站的两种模式：JSP + JavaBean；JSP + Servlet + JavaBean（一般在多层应用中, JSP 主要用作表现层,而 Servlet 则用作控制层,因为在 JSP 中放太多的代码不利于维护，而把这留给 Servlet 来实现,而大量的重复代码写在 JavaBean 中）。</p><p>【8】二者之间的差别就是，开发界面是 JSP 直接可以编写。</p><p>比如在 JSP 中写 Table 标记：<code>&lt;table&gt;[数据]&lt;/table&gt;；</code></p><p>Servlet 需要加入：<code>out.println(“&lt;table&gt;[数据]&lt;/table&gt;”)。</code></p><p>JSP 文件在被应用服务器(例如：Tomcat、Resin、Weblogic 和 Websphere),调用过之后，就被编译成为了 Servlet 文件。也就是说在网页上显示的其实是 Servlet 文件。Tomcat 下面 JSP 文件编译之后生成的 Servlet 文件被放在了 work 文件夹下，JSP 中的 HTML 代码在 Servlet 都被 out 出来，而 JSP 代码按照标签的不同会放在不同的位置。</p><p>【9】JSP 中嵌入 JAVA 代码，而 Servlet 中嵌入 HTML 代码。</p><p>【10】在一个标准的 MVC 架构中，Servlet 作为 Controller 接受用户请求并转发给相应的 Action 处理，JSP 作为 View 主要用来产生动态页面，EJB 作为 Model 实现你的业务代码。</p><h2 id="二、Servlet-基础"><a href="#二、Servlet-基础" class="headerlink" title="二、Servlet 基础"></a>二、Servlet 基础</h2><h3 id="接口及其实现类"><a href="#接口及其实现类" class="headerlink" title="接口及其实现类"></a>接口及其实现类</h3><p>就是利用其类编写相关服务器端的相关运行代码</p><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p>分三个阶段：初始化阶段-&gt;运行阶段-&gt;销毁阶段</p><h3 id="HttpServlet-类"><a href="#HttpServlet-类" class="headerlink" title="HttpServlet 类"></a>HttpServlet 类</h3><p>一般客户端和服务器之间都回使用 <code>HTTP协议</code> ，所以 Servlet 接口中就提供了一个抽象类<code>javax.servlet.http.HttpServlet</code>，他是 <code>GernericServlet</code>  的一个子类，专门用来处理 <code>HTTP协议</code>  的 servlet；具体程序中就是用该类</p><blockquote><p>HelloWordServlet.java</p></blockquote><pre><code class="java">package cn.itcast.firstmyapp.servlet;import java.io.IOException;import java.io.PrintWriter;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;public class HelloWordServlet extends HttpServlet &#123;     protected void doGet(HttpServletRequest req, HttpServletResponse resp)                throws ServletException, IOException &#123;         System.out.println(&quot;接受了客户端的请求-----------------------------&quot;);         // 设置响应类型:            resp.setContentType(&quot;text/html&quot;);            // 获取输出流:            PrintWriter pw = resp.getWriter();            // 写入响应:            pw.write(&quot;&lt;h1&gt;Hello, world!&lt;/h1&gt;&quot;);            // 最后不要忘记flush强制输出:            pw.flush();        &#125;&#125;</code></pre><h2 id="三、Servlet-虚拟路径的映射"><a href="#三、Servlet-虚拟路径的映射" class="headerlink" title="三、Servlet 虚拟路径的映射"></a>三、Servlet 虚拟路径的映射</h2><h3 id="1-多重映射"><a href="#1-多重映射" class="headerlink" title="1. 多重映射"></a>1. 多重映射</h3><blockquote><p>就相当于多加几个自己指定的访问路径，在 web.xml 中</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598670486704-cb7b6356-6317-47d3-85c4-a27582c41121.png#align=left&display=inline&height=221&margin=%5Bobject%20Object%5D&originHeight=455&originWidth=1003&size=0&status=done&style=shadow&width=487"></p><h3 id="2-映射路径下使用通配符"><a href="#2-映射路径下使用通配符" class="headerlink" title="2. 映射路径下使用通配符"></a>2. 映射路径下使用通配符</h3><blockquote><p>在其中使用通配符，一个目录下的所有路径都可以访问，其中有完全目录匹配，目录匹配，扩展名匹配</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598670487060-fa223535-eabd-40c6-bf7e-088fc77c9c87.png#align=left&display=inline&height=92&margin=%5Bobject%20Object%5D&originHeight=106&originWidth=568&size=0&status=done&style=shadow&width=493"></p><h3 id="3-缺省"><a href="#3-缺省" class="headerlink" title="3. 缺省"></a>3. 缺省</h3><p>通常作用是解决请求的资源找不到的情况，（404：请求的资源找不到）</p><h2 id="四、-ServletConfig-和-ServletContext"><a href="#四、-ServletConfig-和-ServletContext" class="headerlink" title="四、 ServletConfig  和 ServletContext"></a>四、 <code>ServletConfig</code>  和 <code>ServletContext</code></h2><blockquote><p>ServletConfig 接口</p></blockquote><p>类比于 git 根文件夹<code>.ssh</code>下的 config 配置文件，它是 servlet 的配置对象，目的就是获取与 servlet 的初始化参数</p><blockquote><p>PS:会使用常用的接口方法</p></blockquote><h1 id="【第五章】会话技术"><a href="#【第五章】会话技术" class="headerlink" title="【第五章】会话技术"></a>【第五章】会话技术</h1><h2 id="一、会话技术"><a href="#一、会话技术" class="headerlink" title="一、会话技术"></a>一、会话技术</h2><p>相当于在客户端和服务器端之间，记录一些用户信息，但是不能用上一章节的，因为那只能保存暂时的信息。 <code>servlet</code>  还提供两个对象 <code>Cookie</code>  和 <code>Session</code>  可以更好地更好地保存会话数据。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598670565525-6a2b8b74-4105-447a-95ba-034020c747fe.png#align=left&display=inline&height=117&margin=%5Bobject%20Object%5D&originHeight=215&originWidth=1105&size=0&status=done&style=shadow&width=601"></p><h1 id="【第六章】JSP-技术"><a href="#【第六章】JSP-技术" class="headerlink" title="【第六章】JSP 技术"></a>【第六章】JSP 技术</h1><h2 id="一、JSP-概述"><a href="#一、JSP-概述" class="headerlink" title="一、JSP 概述"></a>一、JSP 概述</h2><p>一种新的编写动态网页的技术，虽然本质还是调用了 <code>servlet</code> ，但是相比前者要简单很多（前者向页面写数据麻烦，复杂），其组成可以简单理解为<br><code>jsp = html + java + jsp自身</code></p><p>调用 servlet 过程：<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598670585374-60fc5166-cb3c-433e-9794-bae3778a3cd8.png#align=left&display=inline&height=251&margin=%5Bobject%20Object%5D&originHeight=479&originWidth=910&size=0&status=done&style=shadow&width=477"></p><p>其中 jsp 生成 java 文件，编译成 class 文件所在目录（本来应该在 tomcat 的 work 路径下）：<code>D:\project-java\.metadata\.plugins\org.eclipse.wst.server.core\tmp0\work\Catalina\localhost\demo-jsp\org\apache\jsp</code><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598670585365-5f311403-0761-4643-aa17-931be713fc49.png#align=left&display=inline&height=71&margin=%5Bobject%20Object%5D&originHeight=71&originWidth=468&size=0&status=done&style=shadow&width=468"></p><p>打开 java 文件之后可以看到相关对 sevlet 的继承</p><h2 id="二、JSP-语法"><a href="#二、JSP-语法" class="headerlink" title="二、JSP 语法"></a>二、JSP 语法</h2><h3 id="jsp-脚本元素"><a href="#jsp-脚本元素" class="headerlink" title="jsp 脚本元素"></a>jsp 脚本元素</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598670585361-957371bf-bb37-407a-90e8-8f21175d6589.png#align=left&display=inline&height=169&margin=%5Bobject%20Object%5D&originHeight=295&originWidth=1117&size=0&status=done&style=shadow&width=639"></p><h3 id="jsp-注释"><a href="#jsp-注释" class="headerlink" title="jsp 注释"></a>jsp 注释</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598670585756-18f96e5c-8a74-4e14-8c16-55a9fd9124df.png#align=left&display=inline&height=118&margin=%5Bobject%20Object%5D&originHeight=118&originWidth=643&size=0&status=done&style=shadow&width=643"></p><h3 id="jsp-指令"><a href="#jsp-指令" class="headerlink" title="jsp 指令"></a>jsp 指令</h3><blockquote><p>page 指令</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598670585347-a182a404-b425-4f70-80d6-712122944623.png#align=left&display=inline&height=146&margin=%5Bobject%20Object%5D&originHeight=224&originWidth=1007&size=0&status=done&style=shadow&width=658"></p><blockquote><p>include 指令</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598670585378-bbe2df4b-013e-4531-bece-2836e4b8bde0.png#align=left&display=inline&height=142&margin=%5Bobject%20Object%5D&originHeight=185&originWidth=884&size=0&status=done&style=shadow&width=677"></p><blockquote><p>taglib 指令</p></blockquote><h3 id="jsp-隐式对象"><a href="#jsp-隐式对象" class="headerlink" title="jsp 隐式对象"></a>jsp 隐式对象</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598670585348-c41424d0-e688-4ae6-809e-bcc33afec5e3.png#align=left&display=inline&height=195&margin=%5Bobject%20Object%5D&originHeight=274&originWidth=912&size=0&status=done&style=shadow&width=650"></p><h1 id="【第九章】JDBC"><a href="#【第九章】JDBC" class="headerlink" title="【第九章】JDBC"></a>【第九章】JDBC</h1><h2 id="一、什么是-JDBC"><a href="#一、什么是-JDBC" class="headerlink" title="一、什么是 JDBC"></a>一、什么是 JDBC</h2><blockquote><p>使用数据库来存储和管理数据</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598670606448-7b5d3ec0-c6eb-4485-af84-34a1d99fa4a1.png#align=left&display=inline&height=338&margin=%5Bobject%20Object%5D&originHeight=778&originWidth=1159&size=0&status=done&style=shadow&width=503"><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598670606324-93a22794-21bb-42fc-9355-64c55411ea53.png#align=left&display=inline&height=99&margin=%5Bobject%20Object%5D&originHeight=200&originWidth=983&size=0&status=done&style=shadow&width=487"></p><h2 id="二、JDBC-常用的-API"><a href="#二、JDBC-常用的-API" class="headerlink" title="二、JDBC 常用的 API"></a>二、JDBC 常用的 API</h2><blockquote><p>五个接口一个类（唯一的类）</p></blockquote><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598670606334-40b58ccd-ef50-4048-a17a-819885cdcf87.png#align=left&display=inline&height=197&margin=%5Bobject%20Object%5D&originHeight=282&originWidth=931&size=0&status=done&style=shadow&width=649"><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598670606546-72057847-1b52-4b82-8f03-d2dcff6e0ed4.png#align=left&display=inline&height=249&margin=%5Bobject%20Object%5D&originHeight=392&originWidth=1001&size=0&status=done&style=shadow&width=635"><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598670606535-2996029c-eaf0-45ee-a778-614141ceea4f.png#align=left&display=inline&height=112&margin=%5Bobject%20Object%5D&originHeight=136&originWidth=755&size=0&status=done&style=shadow&width=624"></p><h1 id="【第十一章】JSP-开发模型"><a href="#【第十一章】JSP-开发模型" class="headerlink" title="【第十一章】JSP 开发模型"></a>【第十一章】JSP 开发模型</h1><h2 id="一、JSP-两种开发模式"><a href="#一、JSP-两种开发模式" class="headerlink" title="一、JSP 两种开发模式"></a>一、JSP 两种开发模式</h2><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598670623021-1406c5eb-f010-4d9f-a6fe-cd104b964450.png#align=left&display=inline&height=54&margin=%5Bobject%20Object%5D&originHeight=54&originWidth=998&size=0&status=done&style=shadow&width=998"></p><h3 id="JSP-Model1"><a href="#JSP-Model1" class="headerlink" title="JSP Model1"></a>JSP Model1</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598670623035-3dae1126-3986-4893-afbf-ce3aa250deb1.png#align=left&display=inline&height=178&margin=%5Bobject%20Object%5D&originHeight=178&originWidth=1220&size=0&status=done&style=shadow&width=1220"><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598670623082-df4cb3b4-1eb4-4590-a68f-f18a31a31816.png#align=left&display=inline&height=210&margin=%5Bobject%20Object%5D&originHeight=469&originWidth=1291&size=0&status=done&style=shadow&width=579"></p><h3 id="JSP-Model2"><a href="#JSP-Model2" class="headerlink" title="JSP Model2"></a>JSP Model2</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598670623814-f1853ddf-0ab6-443c-b90f-97147896aa3c.png#align=left&display=inline&height=242&margin=%5Bobject%20Object%5D&originHeight=242&originWidth=1045&size=0&status=done&style=shadow&width=1045"><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598670623035-37842a30-2e67-40d6-9b33-fc7a90a89037.png#align=left&display=inline&height=208&margin=%5Bobject%20Object%5D&originHeight=515&originWidth=1297&size=0&status=done&style=shadow&width=523"></p><h2 id="二、MVC-设计模式"><a href="#二、MVC-设计模式" class="headerlink" title="二、MVC 设计模式"></a>二、MVC 设计模式</h2><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598670623024-0fbab2bd-139b-4e8e-806a-a010e86e6159.png#align=left&display=inline&height=204&margin=%5Bobject%20Object%5D&originHeight=204&originWidth=1185&size=0&status=done&style=shadow&width=1185"><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598670623036-c1e95730-c04c-44ab-a07d-be7d3ce47970.png#align=left&display=inline&height=105&margin=%5Bobject%20Object%5D&originHeight=105&originWidth=1138&size=0&status=done&style=shadow&width=1138"></p><h2 id="三、JavaWeb-开发中的三层架构"><a href="#三、JavaWeb-开发中的三层架构" class="headerlink" title="三、JavaWeb 开发中的三层架构"></a>三、JavaWeb 开发中的三层架构</h2><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598670623143-02074466-5715-4efa-8b09-ee2a1489d94e.png#align=left&display=inline&height=153&margin=%5Bobject%20Object%5D&originHeight=153&originWidth=1077&size=0&status=done&style=shadow&width=1077"><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598670623075-f2b2b6ce-ebd7-4712-86f3-61ee087aafbb.png#align=left&display=inline&height=198&margin=%5Bobject%20Object%5D&originHeight=499&originWidth=1326&size=0&status=done&style=shadow&width=525"><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598670622943-c73fc987-bbd4-4204-9a82-6a93ea4ac8ed.png#align=left&display=inline&height=224&margin=%5Bobject%20Object%5D&originHeight=224&originWidth=1066&size=0&status=done&style=shadow&width=1066"></p>]]></content>
      
      
      <categories>
          
          <category> 👨‍💻Web开发 </category>
          
          <category> Web其他知识 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Git安装配置及常用命令总结</title>
      <link href="/blog/fnsge3/"/>
      <url>/blog/fnsge3/</url>
      
        <content type="html"><![CDATA[<h2 id="一、Git-安装和本地用户全局配置"><a href="#一、Git-安装和本地用户全局配置" class="headerlink" title="一、Git 安装和本地用户全局配置"></a>一、Git 安装和本地用户全局配置</h2><h3 id="【1】Git-的下载与安装"><a href="#【1】Git-的下载与安装" class="headerlink" title="【1】Git 的下载与安装"></a>【1】Git 的下载与安装</h3><ul><li>进官网下载 <a href="https://git-scm.com/download/win">https://git-scm.com/download/win</a> 并且安装</li><li>查看是否安装成功<code>win + R</code>进入 CMD 输入 git，出现 git 命令指南，则安装成功</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1624934078835-17bc30b2-2f33-49b2-9d41-5d38ae309d5b.png#crop=0&crop=0&crop=1&crop=1&height=113&id=acr1I&margin=%5Bobject%20Object%5D&name=image.png&originHeight=226&originWidth=1440&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=32665&status=done&style=none&title=&width=720" alt="image.png"></p><h3 id="【2】全局配置本地用户"><a href="#【2】全局配置本地用户" class="headerlink" title="【2】全局配置本地用户"></a>【2】全局配置本地用户</h3><p>在 git Bash 中进行下面配置，下面的账号名字和邮箱都是 github 的账号所使用的</p><pre><code class="bash">git config --global user.name &quot;wztlink1013&quot;git config --global user.email &quot;wztlink1013@163.com&quot;</code></pre><blockquote><p>其中：global 表示全局可用，如果要设置局部可用，则只需要删除 global 即可</p></blockquote><h3 id="【3】验证是否配置成功"><a href="#【3】验证是否配置成功" class="headerlink" title="【3】验证是否配置成功"></a>【3】验证是否配置成功</h3><pre><code class="bash">git config --global --list</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1624936078225-da481808-a48c-44d4-b462-8bd283f607b3.png#crop=0&crop=0&crop=1&crop=1&height=113&id=Ib8qE&margin=%5Bobject%20Object%5D&name=image.png&originHeight=225&originWidth=882&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=24839&status=done&style=none&title=&width=441" alt="image.png"></p><h2 id="二、利用-SSH-绑定-Git-和-GitHub"><a href="#二、利用-SSH-绑定-Git-和-GitHub" class="headerlink" title="二、利用 SSH 绑定 Git 和 GitHub"></a>二、利用 SSH 绑定 Git 和 GitHub</h2><h3 id="【1】生成-SSH-密钥"><a href="#【1】生成-SSH-密钥" class="headerlink" title="【1】生成 SSH 密钥"></a>【1】生成 SSH 密钥</h3><ol><li>输入<code>ssh-keygen -t rsa</code>，然后回车三下 <del>（有些时候要回车四下）</del></li><li>然后在用户管理员文件夹下生成两个文件夹 id_rsa 和<strong>id_rsa.pub</strong>，将<strong>后者文件内容</strong>添加到 GitHub 上即可</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1624936245745-59fb92ec-8f9d-4ad8-8986-d9b245d56ed4.png#crop=0&crop=0&crop=1&crop=1&height=111&id=uDYmq&margin=%5Bobject%20Object%5D&name=image.png&originHeight=221&originWidth=1180&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=26565&status=done&style=stroke&title=&width=590" alt="image.png"></p><h3 id="【2】GitHub-上添加生成的-SSH-密钥"><a href="#【2】GitHub-上添加生成的-SSH-密钥" class="headerlink" title="【2】GitHub 上添加生成的 SSH 密钥"></a>【2】GitHub 上添加生成的 SSH 密钥</h3><ul><li>在 github 上的 setting 上添加新的 ssh 即可</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1632592051527-75ccc8a5-88a5-486f-a305-1fa1bc7b86f0.png#clientId=ub53e72c5-209b-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=218&id=u0aff0997&margin=%5Bobject%20Object%5D&name=image.png&originHeight=435&originWidth=1281&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=48820&status=done&style=stroke&taskId=uecb092a8-285d-44a8-b046-053823c303e&title=&width=640.5" alt="image.png"></p><h3 id="【3】验证是否绑定成功"><a href="#【3】验证是否绑定成功" class="headerlink" title="【3】验证是否绑定成功"></a>【3】验证是否绑定成功</h3><pre><code class="bash">ssh -T git@github.com</code></pre><ul><li>响应如下内容则证明绑定成功</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1624936534567-668d781f-afc8-4753-85a0-09d7fabe3901.png#crop=0&crop=0&crop=1&crop=1&height=74&id=CHJEV&margin=%5Bobject%20Object%5D&name=image.png&originHeight=148&originWidth=882&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=15557&status=done&style=none&title=&width=441" alt="image.png"></p><div style="background: #FFF3F3;padding:10px;border: 1px solid #DEB8BE;border-radius:5px;margin-bottom:5px;">如果报错，则是因为少了一个文件，使用过程中直接点yes。具体参考：[解决原理](https://blog.csdn.net/qq_34446663/article/details/81106018)</div><h2 id="三、常用命令总结"><a href="#三、常用命令总结" class="headerlink" title="三、常用命令总结"></a>三、常用命令总结</h2><h3 id="git-clone"><a href="#git-clone" class="headerlink" title="git clone"></a>git clone</h3><p>本地没有 git 仓库，也没有 git init 操作，需要先从 GitHub 上 clone 下来-</p><pre><code class="bash">git clone https://github.com/wztlink1013/datastructure-algorithm.git</code></pre><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1624936843530-14b72928-d20f-489c-b84d-f5a5d414cc01.png#crop=0&crop=0&crop=1&crop=1&height=120&id=dbDXW&margin=%5Bobject%20Object%5D&name=image.png&originHeight=239&originWidth=882&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=36099&status=done&style=none&title=&width=441" alt="image.png"></p><p>对本地文件夹进行一系列更改之后，执行命令：</p><pre><code class="bash">#查看仓库命令状态git status#文件提交到文件缓冲区git add .#提交仓库并且添加提交信息git commmit -m &quot;描述本次修改信息&quot;#查看修改日志git log#再次查看git status# 首次推送git push -u origin master# 非首次推送git push origin master</code></pre><h3 id="git-clone-较大文件失败情况"><a href="#git-clone-较大文件失败情况" class="headerlink" title="git clone 较大文件失败情况"></a>git clone 较大文件失败情况</h3><p>有的 GitHub 仓库存在很久，有很多 commit 历史，特别是曾经的某一次提交带有较大文件的情况，会导致后续 clone 工程大的问题，解决方案：</p><ol><li><code>--depth 1</code></li></ol><p>depth n 参数代表克隆深度，不带该参数则克隆所有历史版本</p><ol start="2"><li>直接克隆某个分支下来</li></ol><pre><code class="bash">git clone -b backup git@github.com:wztlink1013/wztlink1013.github.io.git</code></pre><h3 id="git-pull"><a href="#git-pull" class="headerlink" title="git pull"></a>git pull</h3><p>这种情况是，本地有 git 仓库，指之前已经进行 git init 等一系列命令对该文件夹操作过。新建一个例子：</p><pre><code class="bash"># 初始化本地仓库git init# 关联远程仓库git remote add origin https://github.com/wztlink1013/wztlink1013.github.io.git# 同步远程仓库和本地仓库git pull origin master</code></pre><div style="background: #FFF3F3;padding:10px;border: 1px solid #DEB8BE;border-radius:5px;margin-bottom:5px;">**注意**：在进行本地仓库和远程仓库的文件交互时，一定要先pull再push，不然会出未知错误。</div><p>1、将远程指定分支 拉取到 本地指定分支上：</p><pre><code class="bash">git pull origin &lt;远程分支名&gt;:&lt;本地分支名&gt;</code></pre><p>2、将远程指定分支 拉取到 本地当前分支上：</p><pre><code class="bash">git pull origin &lt;远程分支名&gt;</code></pre><p>3、将与本地当前分支同名的远程分支 拉取到 本地当前分支上(需先关联远程分支，方法见<a href="#KBkAM">https://www.yuque.com/wztlink1013/blog/fnsge3#KBkAM</a>)</p><pre><code class="bash">git pull</code></pre><p>在克隆远程项目的时候，本地分支会自动与远程仓库建立追踪关系，可以使用默认的 origin 来替代远程仓库名，<br>所以，我常用的命令就是 git pull origin &lt;远程仓库名&gt;，操作简单，安全可控。<br>[</p><p>](<a href="https://blog.51cto.com/u_15262460/2883040">https://blog.51cto.com/u_15262460/2883040</a>)</p><h3 id="git-push"><a href="#git-push" class="headerlink" title="git push"></a>git push</h3><p>1、将本地当前分支 推送到 远程指定分支上（注意：pull 是远程在前本地在后，push 相反）：</p><pre><code class="bash">git push origin &lt;本地分支名&gt;:&lt;远程分支名&gt;</code></pre><p>2、将本地当前分支 推送到 与本地当前分支同名的远程分支上（注意：pull 是远程在前本地在后，push 相反）：</p><pre><code class="bash">git push origin &lt;本地分支名&gt;</code></pre><p>3、将本地当前分支 推送到 与本地当前分支同名的远程分支上(需先关联远程分支，方法见<a href="#KBkAM">https://www.yuque.com/wztlink1013/blog/fnsge3#KBkAM</a>)</p><pre><code class="bash">git push</code></pre><p>同样的，推荐使用第 2 种方式，git push origin &lt;远程同名分支名&gt;</p><h3 id="git-push-u"><a href="#git-push-u" class="headerlink" title="git push -u"></a>git push -u</h3><p>将本地分支与远程同名分支相关联</p><pre><code class="bash">git push --set-upstream origin &lt;本地分支名&gt;</code></pre><p>简写方式：</p><pre><code class="bash">git push -u origin &lt;本地分支名&gt;</code></pre><h3 id="git-push-f"><a href="#git-push-f" class="headerlink" title="git push -f"></a>git push -f</h3><div style="background: #FFF3F3;padding:10px;border: 1px solid #DEB8BE;border-radius:5px;margin-bottom:5px;">报错信息</div>```bash$ git push origin masterTo https://github.com/wztlink1013/website-source.git ! [rejected]        master -> master (fetch first)error: failed to push some refs to 'https://github.com/wztlink1013/website-source.git'hint: Updates were rejected because the remote contains work that you dohint: not have locally. This is usually caused by another repository pushinghint: to the same ref. You may want to first integrate the remote changeshint: (e.g., 'git pull ...') before pushing again.hint: See the 'Note about fast-forwards' in 'git push --help' for details.```分析并解决问题<div style="background: #edf9e8;padding:10px;border: 1px solid #c2d2b5;border-radius:5px;margin-bottom:5px;">强制性push</div>```bash$ git push -f origin master```<h3 id="branch-和-checkout"><a href="#branch-和-checkout" class="headerlink" title="branch 和 checkout"></a>branch 和 checkout</h3><pre><code class="bash"># 创建并切换新的分支git branch -b 分支名# 查看本地所有分支git branch# 切换到指定分支git checkout 指定分支名# 四部曲git statusgit add .git commit -m &quot;push description infomation&quot;git push origin 分支名</code></pre><h3 id="git-reset-–hard"><a href="#git-reset-–hard" class="headerlink" title="git reset –hard"></a>git reset –hard</h3><p>回退指定历史命令<br><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1639990649778-2e3ec7b1-e554-47af-b8ca-dbad93bf23a0.png#clientId=ua4bbb840-e1ba-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=247&id=u77bcd18c&margin=%5Bobject%20Object%5D&name=image.png&originHeight=493&originWidth=1863&originalType=binary%E2%88%B6=1&rotation=0&showTitle=false&size=64387&status=done&style=stroke&taskId=ud4da4271-446e-4e79-9157-e3236241d0b&title=&width=931.5" alt="image.png"></p><pre><code class="bash">git reset --hard 9fba643590aeb5889c84029585848b93c3e64e5d</code></pre><h3 id="文件夹相关命令"><a href="#文件夹相关命令" class="headerlink" title="文件夹相关命令"></a>文件夹相关命令</h3><ul><li>复制文件夹</li></ul><pre><code class="bash">cp  -r  ./js/  ./backup/</code></pre><ul><li>移动文件夹</li></ul><pre><code class="bash">mv  visualization/  -f  .github_pages/</code></pre><ul><li>删除文件夹</li></ul><pre><code class="bash">rm  -r  .git</code></pre>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> Git+GitHub </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>GitHub Actions代码汇总</title>
      <link href="/blog/uwpbn0/"/>
      <url>/blog/uwpbn0/</url>
      
        <content type="html"><![CDATA[<h2 id="仓库文件夹备份"><a href="#仓库文件夹备份" class="headerlink" title="仓库文件夹备份"></a>仓库文件夹备份</h2><pre><code class="yaml">name: CIon: [watch]jobs:  build:    runs-on: ubuntu-latest    steps:      - uses: actions/checkout@v2      - name: 配置Git        run: |          git config --global user.name &#39;wztlink1013&#39;           git config --global user.email &#39;2550374815@qq.com&#39;      - name: 在云端进行复制文件夹操作        env:          Github_Token: $&#123;&#123; secrets.TOKEN_GITHUBAPI &#125;&#125;        run: |          git clone https://$&#123;Github_Token&#125;@github.com/wztlink1013/website-source website-source          cd website-source          cp -r ./Secret文集/ ./backup/          git status          git add .          git commit -m &quot;backup&quot;          git push --force --quiet &quot;https://$&#123;Github_Token&#125;@github.com/wztlink1013/website-source&quot;  master:master</code></pre><h2 id="博客-CICD-腾讯云函数"><a href="#博客-CICD-腾讯云函数" class="headerlink" title="博客 CICD 腾讯云函数"></a>博客 CICD 腾讯云函数</h2><h3 id="Python2-7-执行环境"><a href="#Python2-7-执行环境" class="headerlink" title="Python2.7 执行环境"></a>Python2.7 执行环境</h3><pre><code class="python"># -*- coding: utf8 -*-import requestsdef main_handler(event, context):    r = requests.post(&quot;https://api.github.com/repos/wztlink1013/Blog3.0/dispatches&quot;,    json=&#123;&#39;event_type&#39;: &quot;run-it&quot;&#125;,    headers = &#123;&quot;User-Agent&quot;:&#39;curl/7.52.1&#39;,              &#39;Content-Type&#39;: &#39;application/json&#39;,              &#39;Accept&#39;: &#39;application/vnd.github.everest-preview+json&#39;,              &#39;Authorization&#39;: &#39;token **********&#39;&#125;)    if r.status_code == 204:        return &quot;This&#39;s OK!&quot;    else:        return r.status_code</code></pre><h3 id="触发器设置"><a href="#触发器设置" class="headerlink" title="触发器设置"></a>触发器设置</h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1594789179624-938bb8c2-ac15-4ece-a5f1-001563e4f08b.png?x-oss-process=image/resize,w_1210#align=left&display=inline&height=564&margin=%5Bobject%20Object%5D&originHeight=564&originWidth=1210&status=done&style=shadow&width=1210"></p><h2 id="博客-CICD-阿里云函数"><a href="#博客-CICD-阿里云函数" class="headerlink" title="博客 CICD 阿里云函数"></a>博客 CICD 阿里云函数</h2><h3 id="Python3-执行环境"><a href="#Python3-执行环境" class="headerlink" title="Python3 执行环境"></a>Python3 执行环境</h3><pre><code class="python"># -*- coding: utf-8 -*-import loggingimport requestsOK = b&#39;ok\n&#39;def handler(environ, start_response):    status = &#39;200 OK&#39;    response_headers = [(&#39;Content-type&#39;, &#39;text/plain&#39;)]    sync_yuque()    start_response(status, response_headers)    return [OK]def sync_yuque():    requests.post(&quot;https://api.github.com/repos/wztlink1013/Blog3.0/dispatches&quot;,    json=&#123;&#39;event_type&#39;: &quot;run-it&quot;&#125;,    headers=&#123;&quot;User-Agent&quot;:&#39;curl/7.52.1&#39;,              &#39;Content-Type&#39;: &#39;application/json&#39;,              &#39;Accept&#39;: &#39;application/vnd.github.everest-preview+json&#39;,              &#39;Authorization&#39;: &#39;token *********&#39;&#125;)</code></pre>]]></content>
      
      
      <categories>
          
          <category> ✨其他 </category>
          
          <category> 玩转博客 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JAVA数组学习笔记</title>
      <link href="/blog/3a4bb6f2744b1bed337d1f558ee3ec0e/"/>
      <url>/blog/3a4bb6f2744b1bed337d1f558ee3ec0e/</url>
      
        <content type="html"><![CDATA[<div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">JAVA课程中讲到数组这类数据结构的笔记，做此记录</div><h2 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h2><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><pre><code class="java">double [] array; // 声明数组方式一double array []; // 生命数组方式二</code></pre><p>创建好编译器会有初始值<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598686523691-98e6140a-a9e1-4218-9589-dc55ff35ed67.png#align=left&display=inline&height=79&margin=%5Bobject%20Object%5D&originHeight=240&originWidth=895&size=0&status=done&style=shadow&width=293"></p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><pre><code class="java">double [] array = new double[10]; // 生命数组并且初始化数组大小double [] array = &#123;1.9, 2.9, 3.4, 3.5&#125;; // 用值初始化数组</code></pre><h3 id="相关属性"><a href="#相关属性" class="headerlink" title="相关属性"></a>相关属性</h3><blockquote><p>是一个对象，有自己的属性自己的方法</p></blockquote><p>String 里面长度 length 有()，也就是 String 里面是方法，而数组没有括号()（写成 array.length），理解为成员变量/属性，而不是方法（封装好了许多功能，体现出语言优越性）</p><h3 id="相关操作"><a href="#相关操作" class="headerlink" title="相关操作"></a>相关操作</h3><ul><li><input checked="" disabled="" type="checkbox"> Initializing arrays with input values</li></ul><pre><code class="java">java.util.Scanner input = new java.util.Scanner(System.in);for (int i=0;i&lt;mylist.length;i++)    mylist[i] = input.nextDouble();</code></pre><ul><li><input checked="" disabled="" type="checkbox"> Initializing arrays with random values</li></ul><pre><code class="java">for (int i = 0; i &lt; myList.length; i++) &#123;  myList[i] = Math.random() * 100;&#125;</code></pre><ul><li><input checked="" disabled="" type="checkbox"> Printing arrays</li></ul><pre><code class="java">for (int i = 0; i &lt; myList.length; i++) &#123;  System.out.print(myList[i] + &quot; &quot;);&#125;</code></pre><ul><li><input checked="" disabled="" type="checkbox"> Summing all elements</li></ul><pre><code class="java">double total = 0;for (int i = 0; i &lt; myList.length; i++) &#123;  total += myList[i];&#125;</code></pre><ul><li><input checked="" disabled="" type="checkbox"> Finding the largest element</li></ul><pre><code class="java">double max = myList[0];for (int i = 1; i &lt; myList.length; i++) &#123;  if (myList[i] &gt; max) max = myList[i];&#125;</code></pre><ul><li><input disabled="" type="checkbox"> Finding the smallest index of the largest element</li><li><input checked="" disabled="" type="checkbox"> Random shuffling</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598686524154-f90809c6-aaae-46bf-b892-5e6f9ed63f50.png#align=left&display=inline&height=502&margin=%5Bobject%20Object%5D&originHeight=502&originWidth=1168&size=0&status=done&style=shadow&width=1168"></p><ul><li><input checked="" disabled="" type="checkbox"> Shifting elements</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598686523785-4984f380-9ca1-4e26-94c5-9c7de0a9c9a1.png#align=left&display=inline&height=470&margin=%5Bobject%20Object%5D&originHeight=470&originWidth=1164&size=0&status=done&style=shadow&width=1164"></p><h3 id="数组的值传递"><a href="#数组的值传递" class="headerlink" title="数组的值传递"></a>数组的值传递</h3><blockquote><p><strong>java 核心知识点之一</strong></p></blockquote><p>数组名（数组地址）作为函数参数</p><p>java 当中是<strong>值传递</strong>的，没有引用没有指针的概念，所以在做函数参数当中，一直都是值传递，python 也是。</p><h3 id="Array-类"><a href="#Array-类" class="headerlink" title="Array 类"></a>Array 类</h3><blockquote><p>import java.util.Arrays;</p></blockquote><ul><li><input checked="" disabled="" type="checkbox"> Array 类中常用的函数<blockquote><p>sort()、parallelSort()、fill()、toString()、binarySearch()（Binary Search 二分查找（事先得排好序））、equals()</p></blockquote></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598686524086-a8d0a2b1-81e5-4045-8cdf-21b40f26c53e.png#align=left&display=inline&height=224&margin=%5Bobject%20Object%5D&originHeight=488&originWidth=1225&size=0&status=done&style=shadow&width=562"><br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1598686524588-f9bcf764-f194-42b9-9c16-3e1676e8964e.png#align=left&display=inline&height=593&margin=%5Bobject%20Object%5D&originHeight=736&originWidth=662&size=0&status=done&style=shadow&width=533"></p><h2 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h2><h3 id="二维数组的创建、初始化"><a href="#二维数组的创建、初始化" class="headerlink" title="二维数组的创建、初始化"></a>二维数组的创建、初始化</h3><pre><code class="java">dataType[][] refVar = new dataType[10][10];int[][] array = &#123;  &#123;1, 2, 3&#125;,  &#123;4, 5, 6&#125;,  &#123;7, 8, 9&#125;,  &#123;10, 11, 12&#125;&#125;;</code></pre><blockquote><p>数组长度的计算</p></blockquote><pre><code>array.length = 4array[0].length = 3array[4].length ==&gt; ArrayIndexOutOfBoundsException</code></pre><h3 id="二维数组的相关操作"><a href="#二维数组的相关操作" class="headerlink" title="二维数组的相关操作"></a>二维数组的相关操作</h3><ul><li><input checked="" disabled="" type="checkbox"> Initializing arrays with input values</li></ul><pre><code class="java">java.util.Scanner input = new Scanner(System.in);System.out.println(&quot;Enter &quot; + matrix.length + &quot; rows and &quot; +  matrix[0].length + &quot; columns: &quot;);for (int row = 0; row &lt; matrix.length; row++) &#123;  for (int column = 0; column &lt; matrix[row].length; column++) &#123;    matrix[row][column] = input.nextInt();  &#125;&#125;</code></pre><ul><li><input checked="" disabled="" type="checkbox"> Initializing arrays with random values</li></ul><pre><code class="java">for (int row = 0; row &lt; matrix.length; row++) &#123;  for (int column = 0; column &lt; matrix[row].length; column++) &#123;    matrix[row][column] = (int)(Math.random() * 100);  &#125;&#125;</code></pre><ul><li><input checked="" disabled="" type="checkbox"> Printing arrays</li></ul><pre><code class="java">for (int row = 0; row &lt; matrix.length; row++) &#123;  for (int column = 0; column &lt; matrix[row].length; column++) &#123;    System.out.print(matrix[row][column] + &quot; &quot;);  &#125;  System.out.println();&#125;</code></pre><ul><li><input checked="" disabled="" type="checkbox"> Summing all elements</li></ul><pre><code class="java">int total = 0;for (int row = 0; row &lt; matrix.length; row++) &#123;  for (int column = 0; column &lt; matrix[row].length; column++) &#123;    total += matrix[row][column];  &#125;&#125;</code></pre><ul><li><input checked="" disabled="" type="checkbox"> Summing all elements by column</li></ul><pre><code class="java">for (int column = 0; column &lt; matrix[0].length; column++) &#123;  int total = 0;  for (int row = 0; row &lt; matrix.length; row++)    total += matrix[row][column];  System.out.println(&quot;Sum for column &quot; + column + &quot; is &quot;    + total);&#125;</code></pre><ul><li><input checked="" disabled="" type="checkbox"> Which row has the largest sum</li><li><input checked="" disabled="" type="checkbox"> Finding the smallest index of the largest element</li><li><input checked="" disabled="" type="checkbox"> Random shuffling</li></ul><pre><code class="java">for (int i = 0; i &lt; matrix.length; i++) &#123;  for (int j = 0; j &lt; matrix[i].length; j++) &#123;    int i1 = (int)(Math.random() * matrix.length);    int j1 = (int)(Math.random() * matrix[i].length);    // Swap matrix[i][j] with matrix[i1][j1]    int temp = matrix[i][j];    matrix[i][j] = matrix[i1][j1];    matrix[i1][j1] = temp;  &#125;&#125;</code></pre><h3 id="多维数组-1"><a href="#多维数组-1" class="headerlink" title="多维数组"></a>多维数组</h3><pre><code class="java">double[][][] scores = &#123;  &#123;&#123;7.5, 20.5&#125;, &#123;9.0, 22.5&#125;, &#123;15, 33.5&#125;, &#123;13, 21.5&#125;, &#123;15, 2.5&#125;&#125;,  &#123;&#123;4.5, 21.5&#125;, &#123;9.0, 22.5&#125;, &#123;15, 34.5&#125;, &#123;12, 20.5&#125;, &#123;14, 9.5&#125;&#125;,  &#123;&#123;6.5, 30.5&#125;, &#123;9.4, 10.5&#125;, &#123;11, 33.5&#125;, &#123;11, 23.5&#125;, &#123;10, 2.5&#125;&#125;,  &#123;&#123;6.5, 23.5&#125;, &#123;9.4, 32.5&#125;, &#123;13, 34.5&#125;, &#123;11, 20.5&#125;, &#123;16, 7.5&#125;&#125;,  &#123;&#123;8.5, 26.5&#125;, &#123;9.4, 52.5&#125;, &#123;13, 36.5&#125;, &#123;13, 24.5&#125;, &#123;16, 2.5&#125;&#125;,  &#123;&#123;9.5, 20.5&#125;, &#123;9.4, 42.5&#125;, &#123;13, 31.5&#125;, &#123;12, 20.5&#125;, &#123;16, 6.5&#125;&#125;&#125;;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 💪计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 📶线结构：字符串-数组-栈-队列 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>《世界上所有的夜晚》——那段难忘的谈吐</title>
      <link href="/essay/c47f3d9a749fd0229277f9e9604e69a2/"/>
      <url>/essay/c47f3d9a749fd0229277f9e9604e69a2/</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1622165460883-a7b33b3d-8426-46e7-ade7-e603c065322e.jpeg#height=199&id=uedac2836&margin=%5Bobject%20Object%5D&originHeight=397&originWidth=270&originalType=binary%E2%88%B6=1&status=done&style=stroke&width=135"></p><p>每本书，总会有那么一段让你记忆难忘。最难忘的是和蒋百嫂酒后那段谈吐，夜半作者打算回旅馆，却听见轰隆隆的响声，当看见冰柜里的那具尸体之后，仿佛像是探照灯照亮了一个人不愿流露的内心，悲凉，同情。每个人都有属于自己的夜晚，心灵寄居在此，有的看似洒脱却也痛苦无奈。</p><p>看完这本书，我才渐渐了解迟子建这个作家，不过非常尴尬，在此之前我一直以为迟子建是位男作家····作者真的是一个善于观察的生活记录者，很喜欢那样轻快的语言，迟子建是在我读书时期，让我喜欢上文学的人之一，高中那会，就喜欢蹲在书店的书架后面看他写的书，看完之后，心情甚是愉悦~～～回忆啊，那个下午放学到晚自习那段一个小时，总喜欢跑书店看一些神神叨叨的书</p><p>每个人都有属于自己的夜晚，每个人都有属于自己的回忆 :-）</p><hr><p>《世界上所有的夜晚》迟子建的一本比较短的小说，这部小说，也是在那期间第一本我一天之内看完的一本小说，很多时候，我总是想起煤矿镇的那个村庄的人，事实上，那都是我们身边的人，也是那本书我内心深深的感知，这世上有很多不幸的人，这世上不止一个夜晚，有无数个人人牵挂的夜晚，这世上又只有一个夜晚，那个独自存在的灵魂的夜晚……</p><hr><p>想想以前的一些悠闲经历， 上课偷偷式看小说 、备考期间，自我欺骗/麻痹式看小说 ，大学依旧是上课老喜欢在全班同学都认真听讲而我坐在后排靠窗角落看小说<img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1622165717851-7436873d-a34b-48b7-a8fa-d32e45eb7e4b.jpeg#height=50&id=HxzJ4&originHeight=50&originWidth=51&originalType=binary%E2%88%B6=1&status=done&style=none&width=51"></p><p>然而现在， 快节奏的日常似乎霸占生活的全部 ，身边有这么优秀的环境，我忘却了曾经的那一丝快感……</p><p>其实，生活本可以有一丝轻快，不用太过追求什么</p>]]></content>
      
      
      <categories>
          
          <category> 阅读 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CSS引入和特性</title>
      <link href="/blog/740ee349dcf540d24c44fd240dbbc87f/"/>
      <url>/blog/740ee349dcf540d24c44fd240dbbc87f/</url>
      
        <content type="html"><![CDATA[<div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">CSS(Cascading Style Sheets)  ，通常称为CSS样式表或层叠样式表（级联样式表）</div><h2 id="CSS-引入"><a href="#CSS-引入" class="headerlink" title="CSS 引入"></a>CSS 引入</h2><h3 id="行内式（内联样式）"><a href="#行内式（内联样式）" class="headerlink" title="行内式（内联样式）"></a>行内式（内联样式）</h3><pre><code class="html">&lt;div style=&quot;color: red; font-size: 12px;&quot;&gt;文字&lt;/div&gt;</code></pre><ul><li>style 其实就是标签的属性</li><li><strong>样式属性和值中间是<code>:</code></strong></li><li><strong>多组属性值之间用<code>;</code>隔开</strong></li></ul><h3 id="内部样式表（内嵌样式表）"><a href="#内部样式表（内嵌样式表）" class="headerlink" title="内部样式表（内嵌样式表）"></a>内部样式表（内嵌样式表）</h3><pre><code class="css">&lt;style&gt;     div &#123;         color: red;         font-size: 12px;     &#125;&lt;/style&gt;</code></pre><ul><li>style 标签一般位于 head 标签中，理论可以放在 HTML 文档的任何地方。</li><li>type=”text/css”   在 html5 中可以省略。</li><li>只能控制当前的页面</li></ul><h3 id="外部样式表（外链式）"><a href="#外部样式表（外链式）" class="headerlink" title="外部样式表（外链式）"></a>外部样式表（外链式）</h3><pre><code class="html">&lt;head&gt;  &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;css文件路径&quot; /&gt;&lt;/head&gt;</code></pre><ul><li>link 是个单标签</li><li>link 标签需要放在 head 头部标签中，并且指定 link 标签的三个属性<table><thead><tr><th>属性</th><th align="left">作用</th></tr></thead><tbody><tr><td>rel</td><td align="left">定义当前文档与被链接文档之间的关系，在这里需要指定为“stylesheet”，表示被链接的文档是一个样式表文件。</td></tr><tr><td>type</td><td align="left">定义所链接文档的类型，在这里需要指定为“text/CSS”，表示链接的外部文件为 CSS 样式表。我们都可以省略</td></tr><tr><td>href</td><td align="left">定义所链接外部样式表文件的 URL，可以是相对路径，也可以是绝对路径。</td></tr></tbody></table></li></ul><h2 id="CSS-三大特性"><a href="#CSS-三大特性" class="headerlink" title="CSS 三大特性"></a>CSS 三大特性</h2><h3 id="层叠性"><a href="#层叠性" class="headerlink" title="层叠性"></a>层叠性</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611551959470-031c2889-70e9-4982-96f9-9c144e5051b2.png#align=left&display=inline&height=262&margin=%5Bobject%20Object%5D&name=image.png&originHeight=523&originWidth=1206&size=99603&status=done&style=stroke&width=603" alt="image.png"></p><ul><li><p>概念：<br>所谓层叠性是指多种 CSS 样式的叠加。<br>是浏览器处理冲突的一个能力,如果一个属性通过两个相同选择器设置到同一个元素上，那么这个时候一个属性就会将另一个属性层叠掉</p></li><li><p>原则：</p><ul><li>样式冲突，遵循的原则是<strong>就近原则。</strong> 那个样式离着结构近，就执行那个样式。</li><li>样式不冲突，不会层叠</li></ul></li></ul><pre><code>CSS层叠性最后的执行口诀：  长江后浪推前浪，前浪死在沙滩上。</code></pre><h3 id="继承性"><a href="#继承性" class="headerlink" title="继承性"></a>继承性</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611551970799-56adba75-8847-4db1-a411-148ff22f57ac.png#align=left&display=inline&height=264&margin=%5Bobject%20Object%5D&name=image.png&originHeight=528&originWidth=1196&size=98408&status=done&style=stroke&width=598" alt="image.png"></p><ul><li>概念：<br>子标签会继承父标签的某些样式，如文本颜色和字号。<br>想要设置一个可继承的属性，只需将它应用于父元素即可。</li></ul><p>简单的理解就是：   子承父业。</p><ul><li><strong>注意</strong>：<ul><li>恰当地使用继承可以简化代码，降低 CSS 样式的复杂性。比如有很多子级孩子都需要某个样式，可以给父级指定一个，这些孩子继承过来就好了。</li><li>子元素可以继承父元素的样式（<strong>text-，font-，line-这些元素开头的可以继承，以及 color 属性</strong>）</li></ul></li></ul><h3 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h3><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611551983122-6a6e2212-c740-40f6-bfa1-3b66ae0a9c46.png#align=left&display=inline&height=246&margin=%5Bobject%20Object%5D&name=image.png&originHeight=491&originWidth=1198&size=91467&status=done&style=none&width=599" alt="image.png"></p><ul><li>概念：定义 CSS 样式时，经常出现两个或更多规则应用在同一元素上，此时，<ul><li>选择器相同，则执行层叠性</li><li>选择器不同，就会出现优先级的问题。<div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">权重计算公式</div>关于CSS权重，我们需要一套计算公式来去计算，这个就是 CSS Specificity（特殊性）</li></ul></li></ul><table><thead><tr><th>标签选择器</th><th>计算权重公式</th></tr></thead><tbody><tr><td>继承或者 *</td><td>0,0,0,0</td></tr><tr><td>每个元素（标签选择器）</td><td>0,0,0,1</td></tr><tr><td>每个类，伪类</td><td>0,0,1,0</td></tr><tr><td>每个 ID</td><td>0,1,0,0</td></tr><tr><td>每个行内样式 style=””</td><td>1,0,0,0</td></tr><tr><td>每个!important 重要的</td><td>∞ 无穷大</td></tr></tbody></table><ul><li><p>值从左到右，左面的最大，一级大于一级，数位之间没有进制，级别之间不可超越。</p></li><li><p>关于 CSS 权重，我们需要一套计算公式来去计算，这个就是 CSS Specificity（特殊性）</p></li><li><p>div {<br>color: pink!important;<br>}</p><div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">权重叠加</div>我们经常用交集选择器，后代选择器等，是有多个基础选择器组合而成，那么此时，就会出现权重叠加。就是一个简单的加法计算</li><li><p>div ul  li   ——&gt;      0,0,0,3</p></li><li><p>.nav ul li   ——&gt;      0,0,1,2</p></li><li><p>a:hover      —–—&gt;   0,0,1,1</p></li><li><p>.nav a       ——&gt;      0,0,1,1</p></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2021/jpg/1484158/1611549555499-d752a9dc-33fc-4649-95b6-58b25d08ef80.jpg#align=left&display=inline&height=31&margin=%5Bobject%20Object%5D&originHeight=31&originWidth=31&status=done&style=none&width=31"> 注意：</p><ol><li>数位之间没有进制 比如说： 0,0,0,5 + 0,0,0,5 =0,0,0,10 而不是 0,0, 1, 0， 所以不会存在 10 个 div 能赶上一个类选择器的情况。<div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">继承的权重是0</div>这个不难，但是忽略很容易绕晕。其实，我们修改样式，一定要看该标签有没有被选中。1） 如果选中了，那么以上面的公式来计权重。谁大听谁的。2） 如果没有选中，那么权重是0，因为继承的权重为0.</li></ol>]]></content>
      
      
      <categories>
          
          <category> 👨‍💻Web开发 </category>
          
          <category> HTML+CSS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>至暗之路</title>
      <link href="/essay/ew2l6r/"/>
      <url>/essay/ew2l6r/</url>
      
        <content type="html"><![CDATA[<p>一个人如若是他很强，一或者说在别人眼中看起来很强，那么他一定是有着他自己的一段至暗时光。</p><p>我们总是不喜欢往回看。往回看有两种情况，一种是你的过往是让你愉悦的，让你充满开心快乐，还有一种就是让你哽咽，不想多言，或是说，那段时光虽然让你收获很多，但是它并非是你很想经历的。至暗时光的确可以让自己变得更强，但是凡事你能得到就必然有舍弃，我觉得那段至暗时光让我舍弃的就是与他人的人情味。</p><p>我的确很恨，恨为什么是我经受那种环境，一个本不是第一环境的人，却也落得个第一环境的人，就像是内壁中有遗留下的异世界的人一样，很愤懑，却也不得抒情。我觉得这可能就是古时候的诗人那般抒情吧，失意，惆怅，但唯一与身边人不同的就是，不会迷茫，内心却是异常的笃定，于是乎他开始变得与周围的人都不太一样，他开始学会跳出内壁，内壁下的人们就仿佛是用来衬托这个本不该落下的内壁之外的人，但，就像是那片沙漠尽头的那般高墙一般，他的落下，是因为他在他那个文明下触及到他不应该触及的所谓的“法律”。</p><p>“什么都不舍弃，就什么改变不了”<br>——爱尔敏</p><p>于是乎，他开始讨厌内壁下的种种，他觉得，在他那个文明，这不应该是他应该所接触的。他觉得，他不是内壁下的人们，他应该回到他所觉得的那个高级文明。所以，他的那种与世人抵触，让他踏上至暗时光，在此有必要提醒一点，至暗，不一定是贬义词，更多的时候，它是一种中性词。</p><p>“错的不是我，而是这个世界”<br>——金木研</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>个人网站搭建方案</title>
      <link href="/blog/xx0b72/"/>
      <url>/blog/xx0b72/</url>
      
        <content type="html"><![CDATA[<p>这是加密文章！</p>]]></content>
      
      
      <categories>
          
          <category> ✨其他 </category>
          
          <category> 玩转博客 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>GitHub Actions+语雀+serverless云函数实现hexo自动化部署</title>
      <link href="/blog/vyeuk3/"/>
      <url>/blog/vyeuk3/</url>
      
        <content type="html"><![CDATA[<h2 id="一、整体思路"><a href="#一、整体思路" class="headerlink" title="一、整体思路"></a>一、整体思路</h2><p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1610002276789-6c7bf0a3-f39b-4a27-a493-01c2e579ec87.jpeg#align=left&display=inline&height=368&id=Rnqi1&margin=%5Bobject%20Object%5D&name=yuque_diagram.jpg&originHeight=368&originWidth=2062&size=71238&status=done&style=stroke&width=2062" alt="yuque_diagram.jpg"></p><ul><li>【1】利用<code>npm</code>插件<code>yuque-hexo-lyrics</code>将语雀云端的文章同步到博客源码<code>source/_posts</code>文件夹下。</li><li>【2】再利用<code>GitHub Actions</code>自动化部署将 GitHub 私有仓库（<code>website</code>）的博客源文件编译成静态博客文件并部署 push 到静态博客仓库（<code>wztlink1013.github.io</code>）下。</li></ul><div style="background: #FFF3F3;padding:10px;border: 1px solid #DEB8BE;border-radius:5px;margin-bottom:5px;">但是以上【1】【2】两种方式并不能解决语雀一发布文章就触发GitHub源码仓库的GitHub Actions</div><ul><li>【3】所以需要中间<code>TencentCloud</code>云函数/<code>Aliyun</code>云函数，云函数的作用就是，语雀文章一经正式发布就触发云函数，从而云函数再触发 GitHub 私有的源码仓库下的<code>GitHub Actions</code>达到编译静态博客的效果。</li></ul><h2 id="二、网站源文件配置"><a href="#二、网站源文件配置" class="headerlink" title="二、网站源文件配置"></a>二、网站源文件配置</h2><blockquote><p>插件 npm 地址【暂未 GitHub 开源】：<a href="https://www.npmjs.com/package/yuque-hexo-lyrics">https://www.npmjs.com/package/yuque-hexo-lyrics</a></p></blockquote><h3 id="yuque-hexo-lyrics-插件使用"><a href="#yuque-hexo-lyrics-插件使用" class="headerlink" title="yuque-hexo-lyrics 插件使用"></a>yuque-hexo-lyrics 插件使用</h3><div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">本人基于yuque-hexo项目修改的进阶插件</div><blockquote><p>【1】在开发环境当中下载插件（全局安装）</p></blockquote><pre><code class="bash">npm i -g yuque-hexo-lyrics</code></pre><blockquote><p>【2】相关 hexo 命令</p></blockquote><pre><code class="bash">yuque-hexo-lyrics clean # 清缓存删除yuque文件夹 删除yuque.json文件(更新之后的插件不删除yuque.json)yuque-hexo-lyrics sync # 从云端拉取到本地</code></pre><blockquote><p>【3】特别需要注意的是：开发环境语雀 Token 变量的传入</p></blockquote><p>语雀为了防止用户恶意多次拉取数据，出于对知识库安全性的调整，使用第三方 API 访问知识库，需要传入环境变量 <code>YUQUE_TOKEN</code>，如果是本地使用建议使用环境变量，也可以是终端的方式输入。<br><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1594788656022-fb5e7959-fa2a-4418-911b-773e3674afb8.png#align=left&display=inline&height=145&id=vrXpA&margin=%5Bobject%20Object%5D&name=image.png&originHeight=290&originWidth=968&size=24274&status=done&style=shadow&width=484" alt="image.png"><br>如果是在<code>GitHub Actions</code>里面的环境执行<code>yuque-hexo-lyrics sync</code>命令的时候，通过如下命令传入语雀的<code>token</code></p><pre><code class="yaml">YUQUE_TOKEN=$&#123;&#123; secrets.YUQUE_TOKEN &#125;&#125; yuque-hexo sync</code></pre><blockquote><p>【4】最后的配置样式（本插件可以同时下载多个知识库）</p></blockquote><pre><code class="json">  &quot;yuqueConfig_blog&quot;: &#123;    &quot;baseUrl&quot;: &quot;https://www.yuque.com/api/v2&quot;,    &quot;login&quot;: &quot;wztlink1013&quot;,    &quot;repo&quot;: &quot;blog&quot;,    &quot;postPath&quot;: &quot;source/_posts/blog&quot;,    &quot;cachePath&quot;: &quot;yuque_blog.json&quot;,    &quot;mdNameFormat&quot;: &quot;slug&quot;,    &quot;onlyPublished&quot;: false,    &quot;onlyPublic&quot;: false,    &quot;adapter&quot;: &quot;hexo&quot;,    &quot;timeout&quot;: &quot;150s&quot;  &#125;,  &quot;yuqueConfig_essay&quot;: &#123;    &quot;baseUrl&quot;: &quot;https://www.yuque.com/api/v2&quot;,    &quot;login&quot;: &quot;wztlink1013&quot;,    &quot;repo&quot;: &quot;essay&quot;,    &quot;postPath&quot;: &quot;source/_posts/essay&quot;,    &quot;cachePath&quot;: &quot;yuque_essay.json&quot;,    &quot;mdNameFormat&quot;: &quot;slug&quot;,    &quot;onlyPublished&quot;: false,    &quot;onlyPublic&quot;: false,    &quot;adapter&quot;: &quot;hexo&quot;,    &quot;timeout&quot;: &quot;150s&quot;  &#125;,  &quot;yuqueConfig_dsal&quot;: &#123;    &quot;baseUrl&quot;: &quot;https://www.yuque.com/api/v2&quot;,    &quot;login&quot;: &quot;wztlink1013&quot;,    &quot;repo&quot;: &quot;dsal&quot;,    &quot;postPath&quot;: &quot;source/_posts/blog&quot;,    &quot;cachePath&quot;: &quot;yuque_dsal.json&quot;,    &quot;mdNameFormat&quot;: &quot;slug&quot;,    &quot;onlyPublished&quot;: false,    &quot;onlyPublic&quot;: false,    &quot;adapter&quot;: &quot;hexo&quot;,    &quot;timeout&quot;: &quot;150s&quot;  &#125;,  &quot;yuqueConfig_javascript&quot;: &#123;    &quot;baseUrl&quot;: &quot;https://www.yuque.com/api/v2&quot;,    &quot;login&quot;: &quot;wztlink1013&quot;,    &quot;repo&quot;: &quot;javascript&quot;,    &quot;postPath&quot;: &quot;source/_posts/blog&quot;,    &quot;cachePath&quot;: &quot;yuqueConfig_javascript.json&quot;,    &quot;mdNameFormat&quot;: &quot;slug&quot;,    &quot;onlyPublished&quot;: false,    &quot;onlyPublic&quot;: false,    &quot;adapter&quot;: &quot;hexo&quot;,    &quot;timeout&quot;: &quot;150s&quot;  &#125;,  &quot;scripts&quot;: &#123;    &quot;build&quot;: &quot;hexo generate&quot;,    &quot;clean&quot;: &quot;hexo clean&quot;,    &quot;deploy&quot;: &quot;hexo deploy&quot;,    &quot;server&quot;: &quot;hexo server&quot;  &#125;</code></pre><p>更详细使用参考官方<a href="https://www.npmjs.com/package/yuque-hexo-lyrics">官方仓库</a>。</p><h3 id="GitHub-Actions-文件的配置"><a href="#GitHub-Actions-文件的配置" class="headerlink" title="GitHub Actions 文件的配置"></a>GitHub Actions 文件的配置</h3><p>在博客源文件夹下新建如下 GitHub Actions 文件<br><code>.github/workflows/main.yml</code></p><blockquote><p>文件内容配置如下</p></blockquote><pre><code class="yaml"># workflow namename: website to wztlink1013.github.io CI/CDon: [repository_dispatch, watch]jobs:  Deploy-Pages:    name: website to wztlink1013.github.io    runs-on: ubuntu-latest    steps:      # check it to your workflow can access it      # from: https://github.com/actions/checkout      - name: Checkout Repository master branch        uses: actions/checkout@main      # from: https://github.com/actions/setup-node      - name: Setup Node.js 10.x        uses: actions/setup-node@main        with:          node-version: &quot;10.x&quot;      - name: add Git infomations        run: |          git config --global user.name &#39;$&#123;&#123;secrets.GIT_NAME&#125;&#125;&#39;           git config --global user.email &#39;$&#123;&#123;secrets.GIT_EMAIL&#125;&#125;&#39;      - name: submit commit infomations        run: |          git log --pretty=format:&quot;%s from Github Actions at `date +&quot;%Y-%m-%d %H:%M:%S&quot;`&quot; --date=short -n 1  &gt; commit-message.log      - name: npm istall hexo-cli、yuque-hexo、*        env:          YUQUE_TOKEN: $&#123;&#123; secrets.YUQUE_TOKEN &#125;&#125;        run: |          npm install hexo-cli -g          npm install yuque-hexo-lyrics -g          npm install      - name: generate articles        run: |          hexo clean          yuque-hexo-lyrics clean          YUQUE_TOKEN=$&#123;&#123; secrets.YUQUE_TOKEN &#125;&#125; yuque-hexo-lyrics sync          hexo generate      - name: push wztlink1013.github.io repository        env:          Github_Pages: github.com/wztlink1013/wztlink1013.github.io          Github_Token: $&#123;&#123; secrets.token_GithubAPI &#125;&#125;        run: |          git clone https://$&#123;Github_Token&#125;@$&#123;Github_Pages&#125; .github_pages          mv .github_pages/.git/ ./public/          cd ./public/          git add .          git commit -F ../commit-message.log          git push --force --quiet &quot;https://$&#123;Github_Token&#125;@$&#123;Github_Pages&#125;&quot; master:master</code></pre><h2 id="三、Serverless-云函数配置"><a href="#三、Serverless-云函数配置" class="headerlink" title="三、Serverless 云函数配置"></a>三、Serverless 云函数配置</h2><h3 id="腾讯云-serverless"><a href="#腾讯云-serverless" class="headerlink" title="腾讯云 serverless"></a>腾讯云 serverless</h3><div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">python2.7的配置</div>```python# -*- coding: utf8 -*-import requests<p>def main_handler(event, context):<br>r = requests.post(“<a href="https://api.github.com/repos/wztlink1013/website/dispatches&quot;">https://api.github.com/repos/wztlink1013/website/dispatches&quot;</a>,<br>json={‘event_type’: “run-it”},<br>headers = {“User-Agent”:’curl/7.52.1’,<br>‘Content-Type’: ‘application/json’,<br>‘Accept’: ‘application/vnd.github.everest-preview+json’,<br>‘Authorization’: ‘token <strong><strong>***</strong></strong>‘})</p><pre><code>if r.status_code == 204:    return &quot;This&#39;s OK!&quot;else:    return r.status_code</code></pre><pre><code>&lt;div style=&quot;background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;&quot;&gt;触发器的设置&lt;/div&gt;![image.png](https://cdn.nlark.com/yuque/0/2020/png/1484158/1594789179624-938bb8c2-ac15-4ece-a5f1-001563e4f08b.png#align=left&amp;display=inline&amp;height=282&amp;id=zNnuw&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=583&amp;originWidth=1250&amp;size=50598&amp;status=done&amp;style=none&amp;width=605)### 阿里云serverless记录一下Hexo自动化部署过程中阿里云平台的原函数配置的python代码&lt;div style=&quot;background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;&quot;&gt;python2.7&lt;/div&gt;```python# -*- coding: utf-8 -*-import loggingimport requests# To enable the initializer feature (https://help.aliyun.com/document_detail/158208.html)# please implement the initializer function as below：# def initializer(context):#   logger = logging.getLogger()#   logger.info(&#39;initializing&#39;)def handler(event, context):#   logger = logging.getLogger()#   logger.info(&#39;hello world&#39;)#   return &#39;hello world&#39;    r = requests.post(&quot;https://api.github.com/repos/wztlink1013/blog-source/dispatches&quot;,    json=&#123;&#39;event_type&#39;: &quot;run-it&quot;&#125;,    headers = &#123;&quot;User-Agent&quot;:&#39;curl/7.52.1&#39;,              &#39;Content-Type&#39;: &#39;application/json&#39;,              &#39;Accept&#39;: &#39;application/vnd.github.everest-preview+json&#39;,              &#39;Authorization&#39;: &#39;token f43964836a33dce244385bc303c8c20adc1bd52194&#39;&#125;)    if r.status_code == 204:        return &quot;This&#39;s OK!&quot;    else:        return r.status_code# # -*- coding: utf8 -*-# import requests# def main_handler(event, context):#     r = requests.post(&quot;https://api.github.com/repos/wztlink1013/blog-source/dispatches&quot;,#     json=&#123;&#39;event_type&#39;: &quot;run-it&quot;&#125;,#     headers = &#123;&quot;User-Agent&quot;:&#39;curl/7.52.1&#39;,#               &#39;Content-Type&#39;: &#39;application/json&#39;,#               &#39;Accept&#39;: &#39;application/vnd.github.everest-preview+json&#39;,#               &#39;Authorization&#39;: &#39;token 144a87bd45e62ff1cf30dc18880787917bc7865417&#39;&#125;)#     if r.status_code == 204:#         return &quot;This&#39;s OK!&quot;#     else:#         return r.status_code</code></pre><div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">python3版本</div>```python# -*- coding: utf-8 -*-<p>import logging<br>import requests<br>OK = b’ok\n’</p><p>def handler(environ, start_response):<br>status = ‘200 OK’<br>response_headers = [(‘Content-type’, ‘text/plain’)]<br>sync_yuque()<br>start_response(status, response_headers)<br>return [OK]</p><p>def sync_yuque():<br>requests.post(“<a href="https://api.github.com/repos/wztlink1013/Blog3.0/dispatches&quot;">https://api.github.com/repos/wztlink1013/Blog3.0/dispatches&quot;</a>,<br>json={‘event_type’: “run-it”},<br>headers={“User-Agent”:’curl/7.52.1’,<br>‘Content-Type’: ‘application/json’,<br>‘Accept’: ‘application/vnd.github.everest-preview+json’,<br>‘Authorization’: ‘token f43964836a33dce415385bc303c8c20adc1bd52194’})</p><pre><code>&lt;div style=&quot;background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;&quot;&gt;- 触发器配置&lt;/div&gt;![image.png](https://cdn.nlark.com/yuque/0/2020/png/1484158/1608448464729-f5e542f2-0a6e-4817-bd93-b8cf6f67b8fa.png#align=left&amp;display=inline&amp;height=95&amp;id=V2THU&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=190&amp;originWidth=1547&amp;size=28534&amp;status=done&amp;style=stroke&amp;width=773.5)![image.png](https://cdn.nlark.com/yuque/0/2020/png/1484158/1608448488925-30baf354-0b23-490c-8b05-4b054ca1b868.png#align=left&amp;display=inline&amp;height=399&amp;id=vXRT1&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=798&amp;originWidth=1045&amp;size=52872&amp;status=done&amp;style=stroke&amp;width=522.5)### 【推荐】Vercel的serverless- [https://github.com/wztlink1013/yuque-github-api](https://github.com/wztlink1013/yuque-github-api)## 四、语雀云端的配置在所需要拉取的仓库中webhook中填入云函数所留下的那串网址，勾选所需要触发的选项即可。![image.png](https://cdn.nlark.com/yuque/0/2021/png/1484158/1624971959931-874c6c43-8c51-4c56-9b32-e952f8c87f6c.png#align=left&amp;display=inline&amp;height=317&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=633&amp;originWidth=1111&amp;size=46845&amp;status=done&amp;style=none&amp;width=555.5)## 参考- [yuque-hexo开发仓库](https://github.com/x-cold/yuque-hexo)- [Hexo：语雀云端写作，Github Actions持续集成](https://www.zhwei.cn/hexo-github-actions-yuque/)- [Hexo 博客终极玩法：云端写作，自动部署](https://segmentfault.com/a/1190000017797561)- [阿里云云函数使用用户](https://www.xiayinchang.top/post/b2362878.html)- [[原创]自动同步语雀文档到你的hexo博客](https://bbs.pediy.com/thread-260866.htm)- [https://github.com/Zfour/yuque_vercel_webhook_api](https://github.com/Zfour/yuque_vercel_webhook_api)</code></pre>]]></content>
      
      
      <categories>
          
          <category> ✨其他 </category>
          
          <category> 玩转博客 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>“什么都无法舍弃，什么也改变不了”</title>
      <link href="/essay/vattip/"/>
      <url>/essay/vattip/</url>
      
        <content type="html"><![CDATA[<div style="background: #E8F7FF;padding:10px;border: 1px solid #ABD2DA;border-radius:5px;margin-bottom:5px;">什么也无法舍弃的人，也无法改变任何事情吧。——爱尔敏·阿诺德</div><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1620265214393-3e90a086-8121-4c96-8f09-6d9bd1406fd2.png#height=216&id=BxjYe&margin=%5Bobject%20Object%5D&name=image.png&originHeight=432&originWidth=767&originalType=binary&size=630773&status=done&style=none&width=383.5" alt="image.png"></p><p><code>2021.04.28</code></p><p>突然对舍弃有了一个新的见解，</p><p>舍弃，很多时候，不仅仅是执行者主观的做法，还有一种就是，被动的舍弃…</p><p>因为你注定要成为什么样的人，所以注定你必须要舍弃某些东西，那么这个时候，对这样的选择该怎么办呢？<br><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1619589532108-e98a4fc8-907a-40c4-9e74-2eb76b34d311.jpeg#height=315&id=DNXMj&margin=%5Bobject%20Object%5D&name=62885377_p0.jpg&originHeight=905&originWidth=1280&originalType=binary&size=880880&status=done&style=none&width=445" alt="62885377_p0.jpg"></p><p><code>2021.04.29</code></p><p>什么是得到呢？</p><p>也许，现在的你没得到，不代表今后的你不会得到，不同的时段，我们所在乎的还会一样吗？</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>快节奏下的人们</title>
      <link href="/essay/gm1to9/"/>
      <url>/essay/gm1to9/</url>
      
        <content type="html"><![CDATA[<p>如今的抒情，早已不知道为何变得如此奢侈</p><p>我们更多的是用心感受远行，而不是，来到一个地方，拍个照，发朋友圈，嗯，我来过，而已……</p><p>什么时候，抒情也变得如此廉价</p><p>写东西更多的是一种抒发内心想法，简单且纯粹，就像是记录下来的，就是我的内心真实写照，</p><p>微商—自媒体—短视频，人们变得不仅是快节奏，更是一种焦虑，为什么会焦虑呢？因为这个社会太快了……</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Premiere</title>
      <link href="/blog/edproq/"/>
      <url>/blog/edproq/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文转载自：<a href="https://zhuanlan.zhihu.com/p/32130541">5 分钟学会 Premiere 视频剪辑全流程</a></p></blockquote><h2 id="第-1-步，打开软件，新建项目"><a href="#第-1-步，打开软件，新建项目" class="headerlink" title="第 1 步，打开软件，新建项目"></a>第 1 步，打开软件，新建项目</h2><p><strong>a.</strong> 填写项目名称；</p><p><strong>b.</strong> 选择项目保存位置，建议建一个用于存放视频项目的文件夹；</p><p><strong>c.</strong> 其他的可以不用改动，点击“确定”。</p><p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1609848527644-14d127eb-6145-4323-8d7e-dc1b813b7d17.jpeg#align=left&display=inline&height=719&margin=%5Bobject%20Object%5D&originHeight=719&originWidth=624&size=0&status=done&style=none&width=624"></p><p><strong>进入“面板”后</strong></p><p><strong>a.</strong> Ctrl+N 新建一个序列；</p><p><strong>b.</strong> 点击“设置”，编辑模式选择“自定义”；</p><p><strong>c.</strong> 帧速率我一般习惯用 23.976，也有的人喜欢用 24、25 或者是 30 帧；</p><p>（至于它们具体有什么区别，我在这里就不详细说了，你们可以自行百度一下）</p><p><strong>d.</strong> 帧大小也就是分辨率，我们通常设置为 1920*1080；</p><p><strong>e.</strong> 像素长宽比选择“方形像素”，场序选择“逐行”；</p><p><strong>f.</strong> 写上序列名称，其他的可以暂时先不研究。</p><p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1609848527668-82cc24b0-26f6-4cad-880e-b71650f5b9f4.jpeg#align=left&display=inline&height=797&margin=%5Bobject%20Object%5D&originHeight=797&originWidth=720&size=0&status=done&style=none&width=720"></p><h2 id="第-2-步，将素材导入-PR"><a href="#第-2-步，将素材导入-PR" class="headerlink" title="第 2 步，将素材导入 PR"></a>第 2 步，将素材导入 PR</h2><p>在“项目面板”内的空白处单击右键导入素材，或者直接将素材选中拖入“项目面板”，如果直接选择一个文件夹的话，直接拖入项目面板，它会生成一个素材箱；</p><p><img src="https://cdn.nlark.com/yuque/0/2021/gif/1484158/1609848527661-1f047b51-da0e-4a8d-af96-6cadf1a8ab75.gif#align=left&display=inline&height=376&margin=%5Bobject%20Object%5D&originHeight=376&originWidth=420&size=0&status=done&style=none&width=420"></p><p>也可以点击右下角的图标，新建一个素材箱，素材箱便于我们进行整理和归类。</p><p><img src="https://cdn.nlark.com/yuque/0/2021/gif/1484158/1609848527781-1f3c610b-49e4-45e0-a13b-96df9b2fb96b.gif#align=left&display=inline&height=355&margin=%5Bobject%20Object%5D&originHeight=355&originWidth=423&size=0&status=done&style=none&width=423"></p><p>除了视频和音频可以导入 PR 之外，图片和 GIF 都可以导入 PR 进行编辑。</p><h2 id="第-3-步，将素材拖入时间轴"><a href="#第-3-步，将素材拖入时间轴" class="headerlink" title="第 3 步，将素材拖入时间轴"></a>第 3 步，将素材拖入时间轴</h2><p><strong>剪辑工作需要在时间轴里面进行：</strong></p><p><strong>a.</strong> 先用鼠标点中素材不放，拖入时间轴的空白处松开就可以了；</p><p>（时间轴上的两个蓝条，上面的轨道是视频，下面的轨道是音频）</p><p><strong>b.</strong> 如果你觉得拖入整条素材太长，也可以先截选片段，鼠标按住视频画面不放，将截选的片段拖到时间轴上；</p><p><strong>c.</strong> 拖入时间轴后如果出现“剪辑不匹配警告”的提示，点击“保持现有设置”，然后右键点击素材，选择“缩放为帧大小”就可以了。</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1609848527688-a4109e9f-d436-4e57-9461-8945695f19c8.png#align=left&display=inline&height=228&margin=%5Bobject%20Object%5D&originHeight=228&originWidth=523&size=0&status=done&style=none&width=523"></p><h2 id="第-4-步：剪辑（精剪）"><a href="#第-4-步：剪辑（精剪）" class="headerlink" title="第 4 步：剪辑（精剪）"></a>第 4 步：剪辑（精剪）</h2><p><strong>剪辑工作</strong>包括对素材进行<strong>裁剪</strong>、<strong>拼接</strong>，<strong>调色</strong>，添加<strong>配乐</strong>、<strong>音效</strong>，还可以添加<strong>转场</strong>、<strong>特效</strong>等等，关于这些进阶内容我们后面会有专门的课程进行深入地解析，这里就不多说了。</p><p>完成整个视频的制作以后，我们就可以进行</p><h2 id="第-5-步：渲染输出"><a href="#第-5-步：渲染输出" class="headerlink" title="第 5 步：渲染输出"></a>第 5 步：渲染输出</h2><p><strong>a.</strong> 在“文件”中，点击“导出”，选择“媒体”，弹出渲染设置面板；</p><p><strong>b.</strong> 格式我一般选择 H.264，预设选择“匹配源—高比特率”；</p><p><strong>c.</strong> 设置文件保存位置和文件名。</p><p>其他的参数可以不用改动，对于一般的用户来说这样的设置就够用了，最后点击“导出”就完成了。</p><p>以上内容是我为大家总结整理的 PR 剪辑的基本流程，它不是最全面的，但如果你掌握了前面所说的这些内容，简单地剪辑一个视频几乎没有什么问题了。</p>]]></content>
      
      
      <categories>
          
          <category> ✨其他 </category>
          
          <category> 后期制作 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>《龙猫·剪辑》数字媒体后期制作大作业</title>
      <link href="/blog/bkthv9/"/>
      <url>/blog/bkthv9/</url>
      
        <content type="html"><![CDATA[<h2 id="后期制作大作业-B-站地址"><a href="#后期制作大作业-B-站地址" class="headerlink" title="后期制作大作业 B 站地址"></a>后期制作大作业 B 站地址</h2><blockquote><p><strong>菜的一逼</strong>……<img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1623289703745-08c74433-8721-408d-9970-e9ea9c43f794.jpeg#align=left&display=inline&height=50&id=cWhW9&margin=%5Bobject%20Object%5D&originHeight=50&originWidth=51&status=done&style=none&width=51"><br>地址：<a href="https://www.bilibili.com/video/BV1UA41187G1">https://www.bilibili.com/video/BV1UA41187G1</a></p></blockquote><iframe src="//player.bilibili.com/player.html?aid=327528419&bvid=BV1UA41187G1&cid=173889112&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><p><a href="https://player.bilibili.com/player.html?bvid=BV1UA41187G1">点击查看【bilibili】</a></p><h2 id="PS-上课笔记"><a href="#PS-上课笔记" class="headerlink" title="PS 上课笔记"></a>PS 上课笔记</h2><blockquote><p>认识 PS===有许多功能 eg：绘画等等<br>准备工作===了解菜单栏；工具栏；基本功能</p></blockquote><h3 id="图层面板的认识"><a href="#图层面板的认识" class="headerlink" title="图层面板的认识"></a>图层面板的认识</h3><p>图层顺序 上一层遮挡下一层 蒙版也是图层<br>混合模式 就是这层图层与下一层混合叠加的效果<br>@@滤色 就是消去黑色深色只显示白色亮色的部分 案例光晕 用黑背景绘画光晕的图案选择滤色混合样式<br>图层样式<br>不透明<br>创建 删除 解锁</p><h3 id="图片的裁切"><a href="#图片的裁切" class="headerlink" title="图片的裁切"></a>图片的裁切</h3><p>选框工具不行===无法确定像素 不能缩放要显示的区域<br>裁剪工具不行===能确定像素 但不能缩放要显示的区域只是同时裁剪图片和画布<br>图像===大小不行–只是压缩图片和画布而已  <br>画布大小（前提是图层不是背景层没有被锁定）<br>调整画布的大小+自由变换工具缩放+移动工具<br>我们想要的大小 调整图像等比例缩放 移动到我们要显示的区域</p><h3 id="蒙版作用"><a href="#蒙版作用" class="headerlink" title="蒙版作用"></a>蒙版作用</h3><p>蒙版只有白和黑 只是在通道建立一个白色的蒙版图层（默认全部显示；有选区时，选区是白色的非选区是黑色的）<br>黑透明，白不透明<br>画笔涂抹 透明度 流量<br>一般用来合成图片<br>对图像擦除的效果 但不影响原始图像的像素 便于后期修改<br>如果用橡皮擦会破坏原始素材</p><h3 id="正确校色"><a href="#正确校色" class="headerlink" title="正确校色"></a>正确校色</h3><p>图像-调整===对图像校色是不可逆的 不适合后期修改<br>创建新的填充和调整图层的按钮 添加带蒙版的调整图层<br>带蒙版的调整图层 是可逆的<br>如果想只对**一个图层作用 右击图层-创建剪切蒙版</p><h3 id="钢笔工具"><a href="#钢笔工具" class="headerlink" title="钢笔工具"></a>钢笔工具</h3><p>点击-点击===是直线<br>点击-点击不要松开手===拖动 就是曲线勒<br>alt+ 点击瞄点拖拉会产生操纵杆===并且把直线变成曲线<br>点击单个操纵杆会单独操纵一边的  <br>crtl+ 移动瞄点<br>属性栏【自动添加/删除】打勾时 点击线能添加点 点击点不拖动能删除点<br>描绘到一半的没闭合的图层 要闭合的话就要先 ctrl 点击最后一点 在点击初始点<br>抠出的区域转为选区 选中图层 点击路径面板-将路径转为选区<br>这时候的选区可以 建立蒙版把他抠出来单独单独显示 这种抠图是可逆的</p><h3 id="修片时用到的工具"><a href="#修片时用到的工具" class="headerlink" title="修片时用到的工具"></a>修片时用到的工具</h3><p>红眼 ===记得是整个眼睛<br>污点 ===可以吧污点附近的像素自动修改污点 但是对麻子脸没用<br>修复画笔 ===把目标的像素填充涂抹的地方 并且能自动融合边缘<br>修补工具 ===框选一个目标选区 填充涂抹的地方 并且能自动融合边缘</p><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
      
      
      <categories>
          
          <category> ✨其他 </category>
          
          <category> 后期制作 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/blog/helloworld/"/>
      <url>/blog/helloworld/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> ✨其他 </category>
          
          <category> 玩转博客 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
