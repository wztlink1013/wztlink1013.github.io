<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>CSS选择器中的:has()和:not()伪类</title>
      <link href="/blog/etxgze472uzh7t1i/"/>
      <url>/blog/etxgze472uzh7t1i/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="ub2dd044b" class="ne-p"><span class="ne-text">前言: 本文记录一下CSS3中逻辑选择器中的has和not, has相当于根据子代条件来选择父代, not类似过滤条件. </span><strong><span class="ne-text">使用前先检查代码运行的浏览器环境是否符合如下截图条件</span></strong></p><p id="u4debc8a1" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2023/png/1484158/1693729315664-7752ef04-8503-42b0-b271-a4adffed81ec.png" width="540.328125" id="u310bdcce" class="ne-image"></p><h3 id="C7n01"><span class="ne-text">not</span></h3><p id="u9b72f6e5" class="ne-p"><span class="ne-text">对当前节点的过滤筛选</span></p><pre><code><code>&lt;html&gt;  &lt;head&gt;    &lt;title&gt;css&lt;/title&gt;    &lt;style&gt;      div.parent:not(.not-parent) &#123;        border: 1px red solid;      &#125;    &lt;/style&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;div class=&quot;parent not-parent&quot;&gt;0000&lt;/div&gt;    &lt;div class=&quot;parent&quot;&gt;      &lt;div&gt;1111&lt;/div&gt;      &lt;div&gt;        &lt;div class=&quot;active&quot;&gt;2222&lt;/div&gt;      &lt;/div&gt;    &lt;/div&gt;    &lt;div class=&quot;parent&quot;&gt;      &lt;div&gt;3333&lt;/div&gt;      &lt;div&gt;4444&lt;/div&gt;    &lt;/div&gt;    &lt;p&gt;&lt;/p&gt;  &lt;/body&gt;&lt;/html&gt;</code></code></pre><p id="ubf0f5013" class="ne-p" style="text-align: left"><img src="https://cdn.nlark.com/yuque/0/2023/png/1484158/1693728187545-dc666922-bd28-4c9d-b63e-824c8b0476f0.png" width="257.03705519478797" id="u46b8367d" class="ne-image"></p><h3 id="bNc8z"><span class="ne-text">has</span></h3><p id="u11a3e0cd" class="ne-p"><span class="ne-text">has选择器: </span><strong><span class="ne-text">根据子是否符合条件来选择父级</span></strong></p><p id="uaf7bd836" class="ne-p"><span class="ne-text">设置子代中有active类的parent类名div的样式</span></p><pre><code><code>&lt;html&gt;  &lt;head&gt;    &lt;title&gt;css&lt;/title&gt;    &lt;style&gt;      div.parent:has(.active) &#123;        border: 1px red solid;      &#125;    &lt;/style&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;div class=&quot;parent&quot;&gt;      &lt;div&gt;1111&lt;/div&gt;      &lt;div&gt;        &lt;div class=&quot;active&quot;&gt;2222&lt;/div&gt;      &lt;/div&gt;    &lt;/div&gt;    &lt;div class=&quot;parent&quot;&gt;      &lt;div&gt;3333&lt;/div&gt;      &lt;div&gt;4444&lt;/div&gt;    &lt;/div&gt;    &lt;p&gt;&lt;/p&gt;  &lt;/body&gt;&lt;/html&gt;</code></code></pre><p id="u1eafcd36" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2023/png/1484158/1693726768953-ae1aa08f-87bd-45d1-ad03-bf4a73538bdc.png" width="257.03705519478797" id="u1ceb6584" class="ne-image"></p><p id="ued6d7945" class="ne-p"><span class="ne-text">如果将上面css改为, 边框则消失</span></p><pre><code><code>div.parent:has(&gt; .active) &#123;  border: 1px red solid;&#125;</code></code></pre><p id="u08a49d4c" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2023/png/1484158/1693727448672-f90d3002-6437-4d65-9b1b-ea889429bd06.png" width="257.03705519478797" id="udd9054cc" class="ne-image"></p><p id="u56d25e80" class="ne-p"><span class="ne-text">还可以表示兄弟跟随关系</span></p><pre><code><code>div.parent:has(+ p) &#123;  border: 1px red solid;&#125;</code></code></pre><p id="u3dc38aeb" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2023/png/1484158/1693727414288-eb1381c5-ce55-44b2-bea6-0e7dad844aba.png" width="257.03705519478797" id="u977486b6" class="ne-image"></p><p id="u3b65a87a" class="ne-p"><span class="ne-text">和not搭配使用, 如下表示不包含active后代的div.parent的标签</span></p><pre><code><code>div.parent:not(:has(.active)) &#123;  border: 1px red solid;&#125;</code></code></pre><p id="u12be46f2" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2023/png/1484158/1693727684199-12da436d-df79-4580-ad37-527bb3a9dc48.png" width="257.03705519478797" id="u860533e4" class="ne-image"></p><p id="u0872252b" class="ne-p"><span class="ne-text">上述not和has位置互换表示的意思不一样</span></p><pre><code><code>div.parent:has(:not(.active)) &#123;  border: 1px red solid;&#125;</code></code></pre><p id="u65f722ad" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2023/png/1484158/1693727825016-f0ae7f89-7fb6-4e74-9d40-32e2727079d5.png" width="257.03705519478797" id="u3f9eacb2" class="ne-image"></p><p id="u0f0fe764" class="ne-p"><span class="ne-text">和表单一些元素搭配使用</span></p><pre><code><code>&lt;html&gt;  &lt;head&gt;    &lt;title&gt;css&lt;/title&gt;    &lt;style&gt;      div:has(input:focus) &#123;        border: 1px red solid;      &#125;    &lt;/style&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;div&gt;      &lt;input type=&quot;text&quot; value=&quot;111&quot; /&gt;    &lt;/div&gt;    &lt;div&gt;      &lt;input type=&quot;text&quot; value=&quot;222&quot; /&gt;    &lt;/div&gt;  &lt;/body&gt;&lt;/html&gt;</code></code></pre><p id="uda31529e" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2023/png/1484158/1693728587821-b90111c9-a13f-4ecc-907e-d1c5d26f3a3d.png" width="257.03705519478797" id="u17090981" class="ne-image"></p><hr id="nIJig" class="ne-hr"><p id="u5dcb7170" class="ne-p" style="text-align: center"><span class="ne-text">一些常规使用CSS选择器可以参考另一篇文章:  </span><a href="https://www.wztlink1013.com/blog/01_html5css3_day01/" data-href="https://www.wztlink1013.com/blog/01_html5css3_day01/" class="ne-link"><span class="ne-text">CSS/CSS3选择器总结 | 尼采般地抒情</span></a></p></div>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
          <category> HTML+CSS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>『我的团长我的团』</title>
      <link href="/essay/wugt39mh6cgg3676/"/>
      <url>/essay/wugt39mh6cgg3676/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="uc38dc866" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2023/webp/1484158/1680703167469-355c8435-dec9-4430-819c-476f8994958d.webp" width="270" id="u416ba344" class="ne-image"></p><p id="u33f28100" class="ne-p"><span class="ne-text">前言：士兵突击的原班人马拍摄的一部电视剧，兰晓龙笔下的炮灰团和草原上的五班，将底层描绘的淋漓尽致，又将绝望中的希望演绎在文字或者影视中。</span></p><h3 id="fpTSn"><span class="ne-text">摘录</span></h3><p id="u7bafe72e" class="ne-p"><span class="ne-text">岂曰无衣，与子同袍。</span></p><p id="u2cb70538" class="ne-p"><span class="ne-text"></span></p><p id="u4c7c6da5" class="ne-p"><span class="ne-text">中国鬼死于听天由命和漫不经心。</span></p><p id="u175607de" class="ne-p"><span class="ne-text"></span></p><p id="u1f90b392" class="ne-p"><span class="ne-text">死都不怕，就怕安逸。</span></p><p id="u24fe66b2" class="ne-p"><span class="ne-text"></span></p><p id="u3425eb31" class="ne-p"><span class="ne-text">国难当头，忠字已经很掺水了，在孝字上就不能再打马虎眼了。</span></p><p id="u5dd9b714" class="ne-p"><span class="ne-text"></span></p><p id="u99525e99" class="ne-p"><span class="ne-text">人生在世，怎么可能像裁缝铺里做衣服，处处都按照你的身材。</span></p><p id="ubdbfaa19" class="ne-p"><span class="ne-text"></span></p><p id="u348f2c18" class="ne-p"><span class="ne-text">有个信着的东西，你是不知道活得有多舒服。</span></p><p id="ube9126c9" class="ne-p"><span class="ne-text"></span></p><p id="u65cb6657" class="ne-p"><span class="ne-text">覆巢之下，岂有完卵。</span></p><p id="u963aca0c" class="ne-p"><span class="ne-text"></span></p><p id="uceb12a81" class="ne-p"><span class="ne-text">你骗我们有了不该有的希望。</span></p><p id="ub3a2a576" class="ne-p"><span class="ne-text"></span></p><p id="ud1bd03f9" class="ne-p"><span class="ne-text">我是伤心而死的。</span></p><p id="uee3f72ec" class="ne-p"><span class="ne-text"></span></p><p id="u5d0787a7" class="ne-p"><span class="ne-text"></span></p></div>]]></content>
      
      
      <categories>
          
          <category> 影视 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2022年 | 平淡却又魔幻</title>
      <link href="/essay/lwozgzgirrhne6ro/"/>
      <url>/essay/lwozgzgirrhne6ro/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="u7c001e7f" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/1484158/1672578936177-3e40667b-6cc1-4140-865e-cf55bdcb2658.jpeg" width="3840" id="GE6Xs" class="ne-image"></p><p id="uf699b7c3" class="ne-p"><br></p><p id="ud04fa625" class="ne-p"><span class="ne-text">前言：2022年，平淡的生活中夹杂着一丝魔幻的经历。</span></p><h3 id="sq448"><span class="ne-text">最后的学生时代</span></h3><p id="u9f5f0f39" class="ne-p"><span class="ne-text">仿佛读了好久好久的书，久到我记忆中难忘的事都是夹杂在学业之中。</span></p><p id="ucc30dd02" class="ne-p"><span class="ne-text">去年的这个时候我结束了在外公司的实习之旅，转向学校，一切都像是被安排好的流程，校内实习、毕设、答辩、拍毕业照、毕业…相比起我的中学阶段，我的大学要平淡的多，可能是这易于伤感的年纪不再憧憬与彷徨。</span></p><h3 id="P02dA"><span class="ne-text">可那是兴趣爱好</span></h3><p id="u6f2cb3bc" class="ne-p"><span class="ne-text">我应该是一手好牌却打得不怎么样的一个学生。大三下我几乎就把学分修满，理论上我是有最多的时间去准备就业的那一批人，但是我错过秋招和春招，封校没有紧迫感是一方面，但是更多的是我的毕设，那是我的兴趣，我只想写好我所设计的代码，那种热爱的冲动不再让我去超过所有人竞争些什么，即便那是个好机会。</span></p><p id="ud41458a1" class="ne-p"><span class="ne-text">五月往后，连春招都过了，我才开始找工作，不过凭借技术老本也拿到一些offer，选择当中有更好的，但最后我还是选了一个和我毕设几乎一样的岗位。我想以后我可能会变得功利起来，但现在不是未来。比较讽刺的是，这一年人情景事都在变，唯独兴趣爱好一直在，从爱好到毕设再到工作，载体不同，但做的都一样。</span></p><h3 id="ZHY8Q"><span class="ne-text">厦门</span></h3><p id="ucead1e49" class="ne-p"><span class="ne-text">原本意向工作地点是深圳，因为一些原因，来到厦门工作了。在一个陌生的海滨城市也是一个不错的经历体验，上一次的海滨之行是在珠海。</span></p><h3 id="Yd3cg"><span class="ne-text">疫情下的颠沛流离</span></h3><p id="ua27c9de0" class="ne-p"><span class="ne-text">上半年学校解封之际伴随着成片的花海，我原以为那会是疫情这个故事的终章，年底，国家重新定义了新冠的所属类别为“乙类甲管”，政策变之后，朋友圈每天都会更新一批又一批的阳康转阴等字眼。我阳了的那一周，对象给我寄的药让我撑过那几天，不在身边却也胜似身边，虽然她很想过来，但出于担心还是没有让她过来。</span></p><p id="u9200df2d" class="ne-p"><span class="ne-text">其实那周，对象做的很多事情让我挺感动的…</span></p><h3 id="qrizm"><span class="ne-text">规则的成长</span></h3><p id="u7c422ca4" class="ne-p"><span class="ne-text">工作之后，看小说和追番没有在学校时候的那种氛围了，我觉得这可能就是成长带来的副作用吧，人们都以铺天盖地般地形式想要达成某种结果来取得某种成绩。技术上，不论是深度还是广度，都只是浅尝辄止，自己要做的、要总结的、要实践的还有很多很多，自己也要被迫地以最佳的状态在技术层面上提升一个层次。</span></p><p id="u470c3a4c" class="ne-p"><span class="ne-text">一千个人眼中有一千个哈姆雷特，而在我眼里，成长是虚无的，因为每个人总是以一种无形的规则成长，就像是竹林中的嫩竹子从一出生的小笋就笔直地向阳生长，不偏离之后的任何轨迹。</span></p><h3 id="az3a1"><span class="ne-text">2023</span></h3><p id="u40186f6b" class="ne-p"><span class="ne-text">对自己的2023年没有太多任务式的念想，唯独多读点书这一点多督促自己，在此对自己算是立下个flag吧，多读书多思考多记录。</span></p></div>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>《你的夏天还好吗》小记</title>
      <link href="/essay/wmsytg138tcz629a/"/>
      <url>/essay/wmsytg138tcz629a/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="ua9751299" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/1484158/1670483122786-7c51c1ab-5445-4adc-905b-4c5d407d25e0.jpeg" width="330" id="Igzgd" class="ne-image"></p><h2 id="O4mrv"><span class="ne-text">你的夏天还好吗？</span></h2><p id="u980df92f" class="ne-p"><span class="ne-text">青涩的喜欢和热烈的喜欢，或许在真心付出面前才能得出答案，你义无反顾去喜欢去爱去付出的人，可能在你意识到对方利用你的感情，那一瞬间让你突然想到多年前一个夏天护着你的那个人，普通且纯粹…以前有个问题：“一个你很喜欢的人和一个很喜欢你的人，你会选谁？”，成长可能就是一个人多多少少的经历而孕育出人潜意识选择的微妙变化。</span></p><h2 id="UGRKc"><span class="ne-text">虫子</span></h2><p id="uf08ebd89" class="ne-p"><span class="ne-text">一个男人对于一个女人有多爱，应该在女人怀有身孕的那个阶段，男人给予女人多少的照顾来衡量。</span></p><p id="u831af1b5" class="ne-p"><span class="ne-text">什么是照顾，可能就是半夜赶走妻子身边的蚊虫就是一种照顾…</span></p><h2 id="DgykL"><span class="ne-text">水中的歌利亚</span></h2><p id="ub455e1e9" class="ne-p"><span class="ne-text">不久前父亲的离去，再在一场大雨不断的天气下，母亲也糖尿休克了，一时间对于亲人的这般离去，作者只知道在洪水中把母亲的尸体绑在木板上作为小船拖去抢救，即便最后尸体也不知道飘向何处…作者最后在塔吊避雨，想起了父亲在工作时的焊接火花射到脸上，想起了父亲教作者游泳潜水，想起了将母亲缠绕在木板上的绿色胶带…</span></p><h2 id="CcIvf"><span class="ne-text">那里是夜，这里有歌</span></h2><p id="ud6ffdc42" class="ne-p"><span class="ne-text">龙大就像是『夏洛特烦恼』中的大傻春。</span></p><p id="u5a0352cf" class="ne-p"><span class="ne-text">“认识你很高兴”，我想这是明华对龙大寄托的另一种情感。</span></p><p id="ub0a131cf" class="ne-p"><span class="ne-text">这世界上总有一些简单纯粹的人活得那么用力。</span></p><h2 id="Uo58d"><span class="ne-text">一天的轴</span></h2><p id="u6ad2873d" class="ne-p"><span class="ne-text">机场是个很容易让人感伤的地方，无数来来往往的陌生面孔总会让你心里觉得平淡而又恍惚。琪玉女士只是个机场保洁工作的一名普通人，失去爱人，孩子也在退伍之际做出一些错事而入狱，想着儿子总想去国外进修…一天的轴或许就是念想里为了某个人总想去坚持做点什么的事。</span></p><p id="u3220ec89" class="ne-p"><span class="ne-text">机场和车站不一样，机场更多是让人感到感伤，而绿皮车和高铁给人以寄托。我还怀念每次回学校，下午四五点飞下机，夕阳洒满遥墙机场的每个角落，机场的边界是一些树，小森林一般，看着那些树，每次总让想起家乡的景色，安安静静的一个小城，安安静静的行人。求学的意义是什么呢？至今没有一个确切让我自己信服的借口，可能那也是我的轴罢了。</span></p><h2 id="X7XHC"><span class="ne-text">角质层</span></h2><p id="u229f9c29" class="ne-p"><span class="ne-text">受宠若惊般地小心翼翼，却也掩饰不了一个人的简单纯粹。</span></p><p id="u46db2972" class="ne-p"><span class="ne-text">可是谁又知道这样的小心翼翼，却是在一个在艰难环境下经历那个年纪本不该承受的经历换来的坚强。</span></p><h2 id="qOfeR"><span class="ne-text">尼克塔酒店</span></h2><p id="u96324f7f" class="ne-p"><span class="ne-text">一段旅行，从一开始就应该决定好同行的人，是否相处得来，否则很容易产生矛盾甚至中途散场，即便对方是曾经很要好的朋友或发小，随着时间的推移，人也是会变的。旅行和人生都是如此。</span></p><h2 id="hgsUN"><span class="ne-text">三十岁</span></h2><p id="ubb655d91" class="ne-p"><span class="ne-text">一个人的成长很多时候是这个世界上另一些生命的救赎，谁都应该努力地活着。</span></p></div>]]></content>
      
      
      <categories>
          
          <category> 阅读 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>一个梦——新学期</title>
      <link href="/essay/shdnxh6ya6pgbh1n/"/>
      <url>/essay/shdnxh6ya6pgbh1n/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="u3fe3baad" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/1484158/1669244059061-5269cc7d-fa21-4467-a750-5aa43184f583.jpeg" width="600" id="ZLXlO" class="ne-image"></p><p id="uc8d73b3a" class="ne-p"><span class="ne-text">下学期开学了，位置是我初中的那个学校，教室是最初的靠近大门的高排宿舍那里，那里本来是一排宿舍，不知怎么改为教室了。</span></p><p id="u76d5ec95" class="ne-p"><span class="ne-text">新学期开学，我还是一如既往去的很晚，教室里面坐满了人，我看着第三排还是第四排边上有个空位，就坐了过去，第一堂课是数学，具体讲的我忘了，不过记得讲的是一种新型运算，打破传统运算的那种…</span></p><p id="ucb3b5036" class="ne-p"><span class="ne-text">我的同桌告诉我待会可能按照成绩分位置，我一脸懵，不知道有什么成绩…</span></p><p id="u1912f2dc" class="ne-p"><span class="ne-text">然后快下课的前十分钟，班主任进来了，她说报一下上次数学考试排名，我记得我排第五还是第六，分数是我高考数学成绩，同学把我的试卷递给我。老师说这次新班级数学超过1xx的有十个，讲完，我便醒了（冻醒）……</span></p><p id="u8a72d38f" class="ne-p"><span class="ne-text">后记:</span></p><p id="u727b7420" class="ne-p"><span class="ne-text">那个位置不是靠窗的，可我上课还是喜欢看着外面，看那个一排排自行车的地方。</span></p><p id="u62d08c65" class="ne-p"><span class="ne-text">新学期的第一堂课，一如既往般地身边所有同学都很聚精会神，但我却很出神……</span></p><p id="u6a799471" class="ne-p"><span class="ne-text">其实我一直都不喜欢新学期，特别是大学之前的小学初中，一切都太新了，那种氛围感有点让人窒息抑郁…直到大学，我几乎只坐最后一排靠窗，我喜欢在上课的时候看小说，尤其是所有人都在认真听课的时候，记得大三有一个学期中的两个礼拜的所有离散数学课，我全都用来看《平凡的世界》了……</span></p><p id="u4fc2e318" class="ne-p"><span class="ne-text">梦醒的那一刻，一大堆记忆涌入脑海:上大学了…大学毕业了…工作上班了…我还在睡觉…待会起来上班……</span></p></div>]]></content>
      
      
      <categories>
          
          <category> 异世界 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CommonJS模块转ESM模块方法</title>
      <link href="/blog/fhxatr6exkaavb4k/"/>
      <url>/blog/fhxatr6exkaavb4k/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="ua2542a3a" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1668599149397-081cdc1f-3a12-445f-a1ee-077ecde12f33.png" width="240" id="ue9195258" class="ne-image"></p><p id="u22b00a16" class="ne-p"><span class="ne-text">前言：vite项目中，依赖包的加载都是基于esm模块加载的，有些依赖打包后不是esm而是CommonJS类型的，则需要由CommonJS转为esm类型。vite预构建可以默认将node_modules下的依赖包进行转换为esm类型并存放在node_modules文件夹下的.vite文件夹下，也可以自行添加路径来预构建（详见文档：</span><a href="https://cn.vitejs.dev/guide/dep-pre-bundling.html#customizing-the-behavior" data-href="https://cn.vitejs.dev/guide/dep-pre-bundling.html#customizing-the-behavior" target="_blank" class="ne-link"><span class="ne-text">https://cn.vitejs.dev/guide/dep-pre-bundling.html#customizing-the-behavior</span></a><span class="ne-text">）。</span></p><p id="ue3363f3f" class="ne-p"><span class="ne-text"></span></p><div data-type="info" class="ne-alert"><p id="ub42e1842" class="ne-p"><strong><span class="ne-text">前端模块化相关文章：</span></strong><a href="https://www.wztlink1013.com/blog/psazge/" data-href="https://www.wztlink1013.com/blog/psazge/" class="ne-link"><strong><span class="ne-text">前端代码模块及其工具化（Webpack,roolup.js）构建 | 尼采般地抒情</span></strong></a></p></div><p id="u4a983763" class="ne-p"><br></p><p id="ub9247581" class="ne-p"><span class="ne-text">对于一些老旧sdk，在vite项目中，利用pnpm link调试，就需要转包操作了。在此记录一下手动将CommonJS模块转为ESM模块的小demo。</span></p><p id="ua6dd2af8" class="ne-p"><span class="ne-text"></span></p><pre><code>&#123;  &quot;name&quot;: &quot;cjs_to_esm&quot;,  &quot;version&quot;: &quot;1.0.0&quot;,  &quot;description&quot;: &quot;&quot;,  &quot;type&quot;: &quot;module&quot;,  &quot;scripts&quot;: &#123;    &quot;build&quot;: &quot;rollup -c&quot;  &#125;,  &quot;keywords&quot;: [],  &quot;author&quot;: &quot;&quot;,  &quot;license&quot;: &quot;ISC&quot;,  &quot;devDependencies&quot;: &#123;    &quot;@rollup/plugin-commonjs&quot;: &quot;^23.0.2&quot;,    &quot;rollup&quot;: &quot;^3.2.5&quot;  &#125;&#125;<code>&#123;  &quot;name&quot;: &quot;cjs_to_esm&quot;,  &quot;version&quot;: &quot;1.0.0&quot;,  &quot;description&quot;: &quot;&quot;,  &quot;type&quot;: &quot;module&quot;,  &quot;scripts&quot;: &#123;    &quot;build&quot;: &quot;rollup -c&quot;  &#125;,  &quot;keywords&quot;: [],  &quot;author&quot;: &quot;&quot;,  &quot;license&quot;: &quot;ISC&quot;,  &quot;devDependencies&quot;: &#123;    &quot;@rollup/plugin-commonjs&quot;: &quot;^23.0.2&quot;,    &quot;rollup&quot;: &quot;^3.2.5&quot;  &#125;&#125;</code></code></pre><pre><code>import commonjs from '@rollup/plugin-commonjs';export default &#123;  input: 'src/test_cjs.js',  output: &#123;    file: 'output/test_esm.js',    format: 'es'  &#125;,  plugins: [commonjs()]&#125;;<code>import commonjs from '@rollup/plugin-commonjs';export default &#123;  input: 'src/test_cjs.js',  output: &#123;    file: 'output/test_esm.js',    format: 'es'  &#125;,  plugins: [commonjs()]&#125;;</code></code></pre></div>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
          <category> Node.js </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>一个梦——一个老人</title>
      <link href="/essay/gkc62n/"/>
      <url>/essay/gkc62n/</url>
      
        <content type="html"><![CDATA[<div class="yuque-hexo-lyrics-secret">这是加密文章！</div>]]></content>
      
      
      <categories>
          
          <category> 异世界 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Vue异步接口请求的几种使用方式</title>
      <link href="/blog/vdv6i5/"/>
      <url>/blog/vdv6i5/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="u2321b18b" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1665821781199-5e03f0f2-b6c3-405e-a5e9-6071e66be32d.png" width="1400" id="u884cd2d4" class="ne-image"></p><p id="u45cb7189" class="ne-p"><br></p><p id="u97cd96d5" class="ne-p"><span class="ne-text">前言：Vue请求接口多是异步操作数据，我们一般会用then、catch来进行链式获取接口数据，除此之外还可以使用Async、Await这个方式来执行异步代码，待接口数据请求完成，再进行下面的逻辑执行。但是上述情况一个是会陷入“回调地狱”，而且请求失败所获得的数据不好获取处理，这个时候使用Promise来封装返回的数据就很好用了，不仅如此，这种形式也有利于传递接口给SDK，具体代码如下：</span></p><p id="u8ecd33bf" class="ne-p"><span class="ne-text"></span></p><pre><code>async getData(id) &#123;  ···  return new Promise((resolve, reject) =&gt; &#123;    getInterfaceData(&#123; param: id &#125;)      .then((res) =&gt; &#123;        ···        resolve(res.data);      &#125;)      .catch((err) =&gt; &#123;        ···        reject(new Error(err));      &#125;);  &#125;);&#125;,<p>const data = getData(‘xxx’);<br></code></pre></p></div>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
          <category> Vue </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Axios实现重连机制</title>
      <link href="/blog/urrudl/"/>
      <url>/blog/urrudl/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="u719a7e4d" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1665819024337-8997802d-d9c9-4398-aa69-f7be2c45d02b.png" width="1347.499946455163" id="u1a5e26ad" class="ne-image"></p><p id="ub28fc1f7" class="ne-p"><span class="ne-text"></span></p><p id="uab8a1db5" class="ne-p"><span class="ne-text">前言：Vue项目中利用Axios封装接口的请求和响应过程中，请求的接口可能会出现本地网络情况抑或是服务端相关环境错误，如果需要接口配置重连机制，如下逻辑可以实现：</span></p><p id="u7c9e092e" class="ne-p"><br></p><pre><code>···service.interceptors.response.use(  (response) =&gt; &#123;    tryCloseLoading();    return response &amp;&amp; response.data;  &#125;,  (err) =&gt; &#123;    // 通用报错处理    if (err.response) &#123;      // 通用报错处理      ···      // 关闭加载中      tryCloseLoading();      // return Promise.reject(err.response.data);    &#125; else &#123;      const &#123; config &#125; = err;      if (!config || !config.retry) return Promise.reject(err);      config.retryCount = config.retryCount || 0;      // 检查是否已经达到重连总数      if (config.retryCount &gt;= config.retry) &#123;        message.error('当前网络异常');        tryCloseLoading();        return Promise.reject(err);      &#125;      config.retryCount += 1;      // 自动计算每次重试的延时，重试次数越多，延时越大      const retryDelay = (1 / 2) * (Math.pow(2, config.retryCount) - 1) * 1000;      // 创建新的 Promise 来发起请求      const backoff = new Promise((resolve) =&gt; &#123;        setTimeout(() =&gt; &#123;          resolve();        &#125;, retryDelay);      &#125;);      return backoff.then(() =&gt; &#123;        tryCloseLoading();        return service(config);      &#125;);    &#125;  &#125;,);···</code></pre></div>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
          <category> Vue </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>同站点防盗链图片和百度统计Referer不一致的解决方案</title>
      <link href="/blog/ugwagn/"/>
      <url>/blog/ugwagn/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="uac5762ec" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1665124978469-51dce474-28f7-4372-9549-d55a6fd48098.png" width="874.1666319304056" id="udf2cdd49" class="ne-image"></p><p id="ue8a744ec" class="ne-p"><span class="ne-text">前言：个人网站使用的语雀外链图片和百度统计两者之间的referrer不一致的解决方案</span></p><hr id="kUABX" class="ne-hr"><p id="u1cbd0778" class="ne-p"><span class="ne-text">问题描述：防盗链图片不在所指定的白名单内，是不被允许访问的，比如语雀图片不能在非自己网站上渲染使用。</span></p><p id="u91b79cc2" class="ne-p"><span class="ne-text"></span></p><p id="uccfeeba5" class="ne-p"><span class="ne-text">常规解决思路：通过设置页面</span><code class="ne-code"><span class="ne-text">meta</span></code><span class="ne-text">标签的</span><code class="ne-code"><span class="ne-text">referrer</span></code><span class="ne-text">属性值为</span><code class="ne-code"><span class="ne-text">no-referrer</span></code><span class="ne-text">可以进行访问（</span><a href="https://blog.csdn.net/qq_53225741/article/details/125239106" data-href="https://blog.csdn.net/qq_53225741/article/details/125239106" class="ne-link"><span class="ne-text">Referer和Referrer Policy以及图片防盗链</span></a><span class="ne-text">）</span></p><pre><code><code>&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot; /&gt;</code></code></pre><p id="uf17ac2f5" class="ne-p"><span class="ne-text">设置上述referrer，可以在其他网站使用防盗链的图片，但是会存在一些副作用，比如对百度统计代码失效，因为百度统计需要携带请求网站的referr等信息才能进一步进行数据统计分析，所以这种解决办法属于取舍功能的方式。</span></p><p id="uaa9559de" class="ne-p"><br></p><p id="u41eb776c" class="ne-p"><span class="ne-text">最终解决思路：利用网页的代码执行顺序，动态对网站的referrer进行更改，设置网站初始referrer为</span><code class="ne-code"><span class="ne-text">no-referrer</span></code><span class="ne-text">，待网站所有外链防盗图片加载完成，再动态修改referrer为</span><code class="ne-code"><span class="ne-text">strict-origin-when-cross-origin</span></code><span class="ne-text">，再进行百度统计逻辑代码的执行。核心代码如下：</span></p><pre><code><code>const lyrics = document.getElementById(&quot;lyrics&quot;);if (!lyrics) return;<p>Promise.all(<br>  Array.from(lyrics.querySelectorAll(&quot;img&quot;) || [])<br>  .filter((img) =&gt;<br>    /^(https://cdn.nlark.com/yuque)/.test(img.src || &quot;&quot;)<br>         )<br>  .map((node) =&gt; &#123;<br>    return new Promise((resolve, reject) =&gt; &#123;<br>      node.setAttribute(&quot;referrerpolicy&quot;, &quot;no-referrer&quot;);<br>      let loadImg = new Image();<br>      loadImg.src = node.src;<br>      loadImg.onload = () =&gt; &#123;<br>        resolve(node);<br>      &#125;;<br>    &#125;);<br>  &#125;)<br>)<br>  .then(() =&gt; &#123;<br>    console.log(&quot;[lyrics yuque] set meta referrer success.&quot;);<br>    document<br>      .querySelector(‘meta[name=&quot;referrer&quot;]’)<br>      .setAttribute(&quot;content&quot;, &quot;strict-origin-when-cross-origin&quot;);<br>    var hm = document.createElement(&quot;script&quot;);<br>    hm.src = &quot;<a href="https://hm.baidu.com/hm.js?xxxxxxxx">https://hm.baidu.com/hm.js?xxxxxxxx</a>&quot;;<br>    var s = document.getElementsByTagName(&quot;script&quot;)[0];<br>    s.parentNode.insertBefore(hm, s);<br>  &#125;)<br>  .catch(() =&gt; &#123;<br>    console.warn(&quot;[lyrics yuque] set meta referrer error.&quot;);<br>  &#125;);</code><br></code></pre></p></div>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
          <category> 玩转博客 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>站点添加雷姆live2d+看板模型</title>
      <link href="/blog/wrygmp/"/>
      <url>/blog/wrygmp/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="ubf72f4a0" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1665116739656-379177c2-ffa2-4cc4-b22c-38fb12c201e8.png" width="1599.1666031214952" id="u3f0332ae" class="ne-image"></p><p id="u2c3627c7" class="ne-p"><br></p><p id="u15698168" class="ne-p"><span class="ne-text">前言：为自己站点配置雷姆live2d，并在live2d模型的基础上附加添加看板功能。</span></p><h2 id="dTMUK"><span class="ne-text">安装hexo-helper-live2d</span></h2><ul class="ne-ul"><li id="ua238e076"><span class="ne-text">下载</span><code class="ne-code"><span class="ne-text">hexo-helper-live2d</span></code><span class="ne-text">（</span><a href="https://github.com/EYHN/hexo-helper-live2d" data-href="https://github.com/EYHN/hexo-helper-live2d" target="_blank" class="ne-link"><span class="ne-text">https://github.com/EYHN/hexo-helper-live2d</span></a><span class="ne-text">）</span></li></ul><pre><code>npm install --save hexo-helper-live2d</code></pre><h2 id="xTwII"><span class="ne-text">配置自定义蕾姆模型</span></h2><h3 id="LkS5r"><span class="ne-text">文件配置</span></h3><ul class="ne-ul"><li id="uba7ea8c6"><span class="ne-text">remu模型下载：</span><a href="https://onedrive.wztlink1013.com/zh-CN/live2d/" data-href="https://onedrive.wztlink1013.com/zh-CN/live2d/" target="_blank" class="ne-link"><span class="ne-text">https://onedrive.wztlink1013.com/zh-CN/live2d/</span></a><span class="ne-text"> 【密码：remu】</span></li><li id="u4c758308"><span class="ne-text">在hexo</span><strong><span class="ne-text">项目根目录</span></strong><span class="ne-text">新建</span><code class="ne-code"><span class="ne-text">live2d_models</span></code><span class="ne-text">文件夹，再将所下载的模型解压放入该文件夹</span></li></ul><p id="ub4f75940" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1665114888992-4037e056-a783-4827-9d0f-426fbc3e0107.png" width="548.3333115445251" id="u4879bd54" class="ne-image"></p><h3 id="RMXIc"><span class="ne-text">_config.yml配置</span></h3><ul class="ne-ul"><li id="ue2750c2f"><span class="ne-text">根目录_config.yml添加如下配置</span></li><li id="u1a142b41"><span class="ne-text">API文档：</span><a href="https://l2dwidget.js.org/docs/class/src/index.js~L2Dwidget.html#instance-method-init" data-href="https://l2dwidget.js.org/docs/class/src/index.js~L2Dwidget.html#instance-method-init" target="_blank" class="ne-link"><span class="ne-text">https://l2dwidget.js.org/docs/class/src/index.js~L2Dwidget.html#instance-method-init</span></a></li></ul><pre><code>## live2dlive2d:  enable: true # 是否开启live2d  scriptFrom: local # 脚本从本地引入  pluginRootPath: live2d/ # 插件在站点上的根目录(相对路径)  pluginJsPath: lib/ # 脚本文件相对与插件根目录路径  pluginModelPath: assets/ # 模型文件相对与插件根目录路径  tagMode: false # 标签模式, 是否仅替换 live2d tag标签而非插入到所有页面中  debug: false # 调试, 是否在控制台输出日志  model:    use: remu # 填写放进live2d_models文件夹中的模型文件夹名字    scale: 1 # canvas 模型与canvas的缩放  display:    width: 150 # 宽度    height: 300 # 高度    position: left # 显示位置    hOffset: 0 #水平偏移    vOffset: -12 #垂直偏移  mobile:    show: true # 手机端是否显示    scale: 1 # 移动设备上的缩放  react:    opacity: 1 # 透明度</code></pre><div data-type="info" class="ne-alert"><p id="u9c7aaaf6" class="ne-p"><span class="ne-text">PS：按需加载live2d标签</span></p><p id="u6dcae3e1" class="ne-p"><span class="ne-text">上述配置中</span><code class="ne-code"><span class="ne-text">tagMode: true</span></code><span class="ne-text">则代表需要在主题中单独给出需要显示的页面</span></p></div><h3 id="aCTih"><span class="ne-text">最终live2d效果</span></h3><p id="u79795e33" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1665115637123-4e5c7429-8a8e-4ae9-b38b-64fc9779a01f.png" width="1599.9999364217147" id="uf21a5c73" class="ne-image"></p><h2 id="dgYzR"><span class="ne-text">配置三方插件模型</span></h2><p id="ua70cfc9f" class="ne-p"><span class="ne-text">上述步骤是下载remu源文件然后自定义的remu模型，也可以下载社区封装好npm插件的模型，本文做自定义模型的说明，故不做该部分详述。相关参考如下：</span></p><ul class="ne-ul"><li id="ufdb404b2"><a href="https://github.com/xiazeyu/live2d-widget-models" data-href="https://github.com/xiazeyu/live2d-widget-models" target="_blank" class="ne-link"><span class="ne-text">https://github.com/xiazeyu/live2d-widget-models</span></a></li><li id="u4b8b184e"><a href="https://huaji8.top/post/live2d-plugin-2.0/" data-href="https://huaji8.top/post/live2d-plugin-2.0/" class="ne-link"><span class="ne-text">https://huaji8.top/post/live2d-plugin-2.0/</span></a></li></ul><h2 id="ayEhu"><span class="ne-text">附：给live2d添加看板功能</span></h2><p id="u85e2afa1" class="ne-p"><span class="ne-text">上述所有步骤完成live2d的安装配置，在此基础上还可以给live2d添加看板功能，就如本文第一张图片那种效果</span></p><h3 id="MW7kI"><span class="ne-text">添加看板样式</span></h3><p id="uc900e14f" class="ne-p"><span class="ne-text">添加静态样式即可：</span></p><details class="lake-collapse"><summary id="u319b4002"><span class="ne-text">_live2d/remu.styl</span></summary><pre><code>// 收缩之后的左下角的贴附样式#waifu-toggle &#123;  background-color: #3f51b5;  border-radius: 5px;  bottom: 66px;  color: #fff;  cursor: pointer;  font-size: 14px;  left: 5px;  margin-left: -90px;  padding: 5px 2px 5px 5px;  position: fixed;  transition: margin-left 1s;  width: 60px;  writing-mode: vertical-rl;&#125;<p>#waifu-toggle.waifu-toggle-active &#123;<br>  margin-left: -40px;<br>&#125;</p><p>#waifu-toggle.waifu-toggle-active:hover &#123;<br>  margin-left: -30px;<br>&#125;</p><p>// 容纳雷姆的盒子<br>#waifu &#123;<br>  bottom: -1000px;<br>  left: 0;<br>  line-height: 0;<br>  margin-bottom: -10px;<br>  position: fixed;<br>  transform: translateY(3px);<br>  transition: transform .3s ease-in-out, bottom 3s ease-in-out;<br>  z-index: 1;<br>&#125;</p><p>#waifu:hover &#123;<br>  transform: translateY(0);<br>&#125;</p><p>// 文字提示框<br>#waifu-tips &#123;<br>  animation: shake 50s ease-in-out 5s infinite;<br>  background-color: rgba(100,149,237, .5);<br>  border: 1px solid rgba(30,144,255, .62);<br>  border-radius: 12px;<br>  box-shadow: 0 3px 15px 2px rgba(191, 158, 118, .2);<br>  font-size: 14px;<br>  line-height: 24px;<br>  margin: -30px 20px;<br>  min-height: 70px;<br>  opacity: 0;<br>  overflow: hidden;<br>  padding: 5px 10px;<br>  position: absolute;<br>  text-overflow: ellipsis;<br>  transition: opacity 1s;<br>  width: 180px;<br>  word-break: break-all;<br>&#125;</p><p>#waifu-tips.waifu-tips-active &#123;<br>  opacity: 1;<br>  transition: opacity .2s;<br>&#125;</p><p>#waifu-tips span<br>color: rgba(0,0,255,.7); // 文字提示框中的重点字</p><p>// 容纳雷姆的外加小盒子<br>#waifu #live2d &#123;<br>  cursor: grab;<br>  height: 300px;<br>  position: relative;<br>  width: 200px;<br>&#125;</p><p>#waifu #live2d:active &#123;<br>  cursor: grabbing;<br>&#125;</p><p>// 小按钮组件<br>#waifu-tool &#123;<br>  color: #0684bd;<br>  opacity: 0.5;<br>  position: absolute;<br>  left: 5px<br>    top: 70px;<br>  transition: opacity 1s;<br>&#125;</p><p>#waifu:hover #waifu-tool &#123;<br>  opacity: 1;<br>&#125;</p><p>// 小按钮的span样式<br>#waifu-tool span &#123;<br>  color: #0684bd;<br>  cursor: pointer;<br>  display: block;<br>  line-height: 30px;<br>  text-align: center;<br>  transition: color .3s;<br>&#125;</p><p>#waifu-tool span:hover &#123;<br>  color: #0684bd; /* #34495e */<br>&#125;</p><p>@keyframes shake &#123;<br>  2% &#123;<br>    transform: translate(.5px, -1.5px) rotate(-.5deg);<br>  &#125;</p><p>  4% &#123;<br>    transform: translate(.5px, 1.5px) rotate(1.5deg);<br>  &#125;</p><p>  6% &#123;<br>    transform: translate(1.5px, 1.5px) rotate(1.5deg);<br>  &#125;</p><p>  8% &#123;<br>    transform: translate(2.5px, 1.5px) rotate(.5deg);<br>  &#125;</p><p>  10% &#123;<br>    transform: translate(.5px, 2.5px) rotate(.5deg);<br>  &#125;</p><p>  12% &#123;<br>    transform: translate(1.5px, 1.5px) rotate(.5deg);<br>  &#125;</p><p>  14% &#123;<br>    transform: translate(.5px, .5px) rotate(.5deg);<br>  &#125;</p><p>  16% &#123;<br>    transform: translate(-1.5px, -.5px) rotate(1.5deg);<br>  &#125;</p><p>  18% &#123;<br>    transform: translate(.5px, .5px) rotate(1.5deg);<br>  &#125;</p><p>  20% &#123;<br>    transform: translate(2.5px, 2.5px) rotate(1.5deg);<br>  &#125;</p><p>  22% &#123;<br>    transform: translate(.5px, -1.5px) rotate(1.5deg);<br>  &#125;</p><p>  24% &#123;<br>    transform: translate(-1.5px, 1.5px) rotate(-.5deg);<br>  &#125;</p><p>  26% &#123;<br>    transform: translate(1.5px, .5px) rotate(1.5deg);<br>  &#125;</p><p>  28% &#123;<br>    transform: translate(-.5px, -.5px) rotate(-.5deg);<br>  &#125;</p><p>  30% &#123;<br>    transform: translate(1.5px, -.5px) rotate(-.5deg);<br>  &#125;</p><p>  32% &#123;<br>    transform: translate(2.5px, -1.5px) rotate(1.5deg);<br>  &#125;</p><p>  34% &#123;<br>    transform: translate(2.5px, 2.5px) rotate(-.5deg);<br>  &#125;</p><p>  36% &#123;<br>    transform: translate(.5px, -1.5px) rotate(.5deg);<br>  &#125;</p><p>  38% &#123;<br>    transform: translate(2.5px, -.5px) rotate(-.5deg);<br>  &#125;</p><p>  40% &#123;<br>    transform: translate(-.5px, 2.5px) rotate(.5deg);<br>  &#125;</p><p>  42% &#123;<br>    transform: translate(-1.5px, 2.5px) rotate(.5deg);<br>  &#125;</p><p>  44% &#123;<br>    transform: translate(-1.5px, 1.5px) rotate(.5deg);<br>  &#125;</p><p>  46% &#123;<br>    transform: translate(1.5px, -.5px) rotate(-.5deg);<br>  &#125;</p><p>  48% &#123;<br>    transform: translate(2.5px, -.5px) rotate(.5deg);<br>  &#125;</p><p>  50% &#123;<br>    transform: translate(-1.5px, 1.5px) rotate(.5deg);<br>  &#125;</p><p>  52% &#123;<br>    transform: translate(-.5px, 1.5px) rotate(.5deg);<br>  &#125;</p><p>  54% &#123;<br>    transform: translate(-1.5px, 1.5px) rotate(.5deg);<br>  &#125;</p><p>  56% &#123;<br>    transform: translate(.5px, 2.5px) rotate(1.5deg);<br>  &#125;</p><p>  58% &#123;<br>    transform: translate(2.5px, 2.5px) rotate(.5deg);<br>  &#125;</p><p>  60% &#123;<br>    transform: translate(2.5px, -1.5px) rotate(1.5deg);<br>  &#125;</p><p>  62% &#123;<br>    transform: translate(-1.5px, .5px) rotate(1.5deg);<br>  &#125;</p><p>  64% &#123;<br>    transform: translate(-1.5px, 1.5px) rotate(1.5deg);<br>  &#125;</p><p>  66% &#123;<br>    transform: translate(.5px, 2.5px) rotate(1.5deg);<br>  &#125;</p><p>  68% &#123;<br>    transform: translate(2.5px, -1.5px) rotate(1.5deg);<br>  &#125;</p><p>  70% &#123;<br>    transform: translate(2.5px, 2.5px) rotate(.5deg);<br>  &#125;</p><p>  72% &#123;<br>    transform: translate(-.5px, -1.5px) rotate(1.5deg);<br>  &#125;</p><p>  74% &#123;<br>    transform: translate(-1.5px, 2.5px) rotate(1.5deg);<br>  &#125;</p><p>  76% &#123;<br>    transform: translate(-1.5px, 2.5px) rotate(1.5deg);<br>  &#125;</p><p>  78% &#123;<br>    transform: translate(-1.5px, 2.5px) rotate(.5deg);<br>  &#125;</p><p>  80% &#123;<br>    transform: translate(-1.5px, .5px) rotate(-.5deg);<br>  &#125;</p><p>  82% &#123;<br>    transform: translate(-1.5px, .5px) rotate(-.5deg);<br>  &#125;</p><p>  84% &#123;<br>    transform: translate(-.5px, .5px) rotate(1.5deg);<br>  &#125;</p><p>  86% &#123;<br>    transform: translate(2.5px, 1.5px) rotate(.5deg);<br>  &#125;</p><p>  88% &#123;<br>    transform: translate(-1.5px, .5px) rotate(1.5deg);<br>  &#125;</p><p>  90% &#123;<br>    transform: translate(-1.5px, -.5px) rotate(-.5deg);<br>  &#125;</p><p>  92% &#123;<br>    transform: translate(-1.5px, -1.5px) rotate(1.5deg);<br>  &#125;</p><p>  94% &#123;<br>    transform: translate(.5px, .5px) rotate(-.5deg);<br>  &#125;</p><p>  96% &#123;<br>    transform: translate(2.5px, -.5px) rotate(-.5deg);<br>  &#125;</p><p>  98% &#123;<br>    transform: translate(-1.5px, -1.5px) rotate(-.5deg);<br>  &#125;</p><p>  0%, 100% &#123;<br>    transform: translate(0, 0) rotate(0);<br>  &#125;<br>&#125;<br></code></pre></p></details><h3 id="ZDamL"><span class="ne-text">添加看板逻辑代码</span></h3><details class="lake-collapse"><summary id="ub489a590"><span class="ne-text">./part/live2d.js</span></summary><pre><code>function loadWidget(config) &#123;  let &#123; waifuPath, apiPath, cdnPath &#125; = config;  let useCDN = false, modelList;  if (typeof cdnPath === &quot;string&quot;) &#123;    useCDN = true;    if (!cdnPath.endsWith(&quot;/&quot;)) cdnPath += &quot;/&quot;;  &#125; else if (typeof apiPath === &quot;string&quot;) &#123;    if (!apiPath.endsWith(&quot;/&quot;)) apiPath += &quot;/&quot;;  &#125; else &#123;    console.error(&quot;Invalid initWidget argument!&quot;);    return;  &#125;  localStorage.removeItem(&quot;waifu-display&quot;);  sessionStorage.removeItem(&quot;waifu-text&quot;);  document.body.insertAdjacentHTML(&quot;beforeend&quot;, `&lt;div id=&quot;waifu&quot;&gt;                &lt;div id=&quot;waifu-tips&quot;&gt;&lt;/div&gt;                &lt;canvas id=&quot;live2d&quot;&gt;&lt;/canvas&gt;                &lt;div id=&quot;waifu-tool&quot;&gt;                    &lt;span class=&quot;fa fa-comments&quot;&gt;&lt;/span&gt;                    &lt;span class=&quot;fa fa-link&quot;&gt;&lt;/span&gt;                    &lt;span class=&quot;fa fa-compress&quot;&gt;&lt;/span&gt;                &lt;/div&gt;            &lt;/div&gt;`);  // https://stackoverflow.com/questions/24148403/trigger-css-transition-on-appended-element  setTimeout(() =&gt; &#123;    document.getElementById(&quot;waifu&quot;).style.bottom = 0;  &#125;, 0);<p>  function randomSelection(obj) &#123;<br>    return Array.isArray(obj) ? obj[Math.floor(Math.random() * obj.length)] : obj;<br>  &#125;<br>  // 检测用户活动状态，并在空闲时显示消息<br>  let userAction = false,<br>    userActionTimer,<br>    messageTimer,<br>    messageArray = [&quot;好久不见，日子过得好快呢……&quot;, &quot;嗨～欢迎访问该站点！&quot;, &quot;记得把小家加入 Adblock 白名单哦！&quot;];<br>  window.addEventListener(&quot;mousemove&quot;, () =&gt; userAction = true);<br>  window.addEventListener(&quot;keydown&quot;, () =&gt; userAction = true);<br>  setInterval(() =&gt; &#123;<br>    if (userAction) &#123;<br>      userAction = false;<br>      clearInterval(userActionTimer);<br>      userActionTimer = null;<br>    &#125; else if (!userActionTimer) &#123;<br>      userActionTimer = setInterval(() =&gt; &#123;<br>        showMessage(randomSelection(messageArray), 6000, 9);<br>      &#125;, 20000);<br>    &#125;<br>  &#125;, 1000);</p><p>  (function registerEventListener() &#123;<br>    // TODO: 第一个icon，说话<br>    document.querySelector(&quot;#waifu-tool .fa-comments&quot;).addEventListener(&quot;click&quot;, showHitokoto);<br>    // TODO: 第二个icon，貌似是什么游戏<br>    // document.querySelector(&quot;#waifu-tool .fa-paper-plane&quot;).addEventListener(&quot;click&quot;, () =&gt; &#123;<br>    //     if (window.Asteroids) &#123;<br>    //         if (!window.ASTEROIDSPLAYERS) window.ASTEROIDSPLAYERS = [];<br>    //         window.ASTEROIDSPLAYERS.push(new Asteroids());<br>    //     &#125; else &#123;<br>    //         const script = document.createElement(&quot;script&quot;);<br>    //         script.src = &quot;<a href="https://cdn.jsdelivr.net/gh/stevenjoezhang/asteroids/asteroids.js">https://cdn.jsdelivr.net/gh/stevenjoezhang/asteroids/asteroids.js</a>&quot;;<br>    //         document.head.appendChild(script);<br>    //     &#125;<br>    // &#125;);<br>    // TODO: 第三个icon，换人物<br>    // document.querySelector(&quot;#waifu-tool .fa-user-circle&quot;).addEventListener(&quot;click&quot;, loadOtherModel);<br>    // TODO: 第四个icon，应该是换装<br>    // document.querySelector(&quot;#waifu-tool .fa-street-view&quot;).addEventListener(&quot;click&quot;, loadRandModel);<br>    // TODO: 第五个icon，拍照<br>    // document.querySelector(&quot;#waifu-tool .fa-camera-retro&quot;).addEventListener(&quot;click&quot;, () =&gt; &#123;<br>    //     showMessage(&quot;照好了嘛，是不是很可爱呢？&quot;, 6000, 9);<br>    //     Live2D.captureName = &quot;photo.png&quot;;<br>    //     Live2D.captureFrame = true;<br>    // &#125;);<br>    // TODO: 第六个icon，原项目地址<br>    document.querySelector(&quot;#waifu-tool .fa-link&quot;).addEventListener(&quot;click&quot;, () =&gt; &#123;<br>      open(&quot;<a href="https://www.wztlink1013.com/about/">https://www.wztlink1013.com/about/</a>&quot;);<br>    &#125;);<br>    // TODO: 第七个icon，隐藏看板娘</p><pre><code>document.querySelector(&amp;quot;#waifu-tool .fa-compress&amp;quot;).addEventListener(&amp;quot;click&amp;quot;, () =&amp;gt; &#123;  localStorage.setItem(&amp;quot;waifu-display&amp;quot;, Date.now());  showMessage(&amp;quot;愿你有一天能与重要的人重逢。&amp;quot;, 2000, 11);  document.getElementById(&amp;quot;waifu&amp;quot;).style.bottom = &amp;quot;-500px&amp;quot;; // 隐藏大盒子  setTimeout(() =&amp;gt; &#123;    document.getElementById(&amp;quot;waifu&amp;quot;).style.display = &amp;quot;none&amp;quot;;    document.getElementById(&amp;quot;waifu-toggle&amp;quot;).classList.add(&amp;quot;waifu-toggle-active&amp;quot;);  &#125;, 3000);&#125;);window.addEventListener(&amp;quot;copy&amp;quot;, () =&amp;gt; &#123;  showMessage(&amp;quot;你都复制了些什么呀，转载要记得加上出处哦！&amp;quot;, 6000, 9);&#125;);window.addEventListener(&amp;quot;visibilitychange&amp;quot;, () =&amp;gt; &#123;  if (!document.hidden) showMessage(&amp;quot;哇，你终于回来了～&amp;quot;, 6000, 9);&#125;);</code></pre><p>  })();</p><p>  // 首页展示特定文字<br>  (function welcomeMessage() {<br>    let text;<br>    if (location.pathname === &quot;/&quot;) { // 如果是主页<br>      const now = new Date().getHours();<br>      if (now &gt; 5 &amp;&amp; now &lt;= 7) text = &quot;早上好！一日之计在于晨，美好的一天就要开始了。&quot;;<br>      else if (now &gt; 7 &amp;&amp; now &lt;= 11) text = &quot;上午好！工作顺利嘛，不要久坐，多起来走动走动哦！&quot;;<br>      else if (now &gt; 11 &amp;&amp; now &lt;= 13) text = &quot;中午了，工作了一个上午，现在是午餐时间！&quot;;<br>      else if (now &gt; 13 &amp;&amp; now &lt;= 17) text = &quot;午后很容易犯困呢，今天的运动目标完成了吗？&quot;;<br>      else if (now &gt; 17 &amp;&amp; now &lt;= 19) text = &quot;傍晚了！窗外夕阳的景色很美丽呢，最美不过夕阳红～&quot;;<br>      else if (now &gt; 19 &amp;&amp; now &lt;= 21) text = &quot;晚上好，今天过得怎么样？&quot;;<br>      else if (now &gt; 21 &amp;&amp; now &lt;= 23) text = [&quot;已经这么晚了呀，早点休息吧，晚安～&quot;, &quot;深夜时要爱护眼睛呀！&quot;];<br>      else text = &quot;你是夜猫子呀？这么晚还不睡觉，明天起的来嘛？&quot;;<br>    } else if (document.referrer !== &quot;&quot;) {<br>      const referrer = new URL(document.referrer),<br>        domain = referrer.hostname.split(&quot;.&quot;)[1];<br>      if (location.hostname === referrer.hostname) text = <code>欢迎阅读&amp;lt;span&amp;gt;「$&#123;document.title.split(&amp;quot; - &amp;quot;)[0]&#125;」&amp;lt;/span&amp;gt;</code>;<br>      else if (domain === &quot;baidu&quot;) text = <code>Hello！来自 百度搜索 的朋友&amp;lt;br&amp;gt;你是搜索 &amp;lt;span&amp;gt;$&#123;referrer.search.split(&amp;quot;&amp;amp;wd=&amp;quot;)[1].split(&amp;quot;&amp;amp;&amp;quot;)[0]&#125;&amp;lt;/span&amp;gt; 找到的我吗？</code>;<br>      else if (domain === &quot;so&quot;) text = <code>Hello！来自 360搜索 的朋友&amp;lt;br&amp;gt;你是搜索 &amp;lt;span&amp;gt;$&#123;referrer.search.split(&amp;quot;&amp;amp;q=&amp;quot;)[1].split(&amp;quot;&amp;amp;&amp;quot;)[0]&#125;&amp;lt;/span&amp;gt; 找到的我吗？</code>;<br>      else if (domain === &quot;google&quot;) text = <code>Hello！来自 谷歌搜索 的朋友&amp;lt;br&amp;gt;欢迎阅读&amp;lt;span&amp;gt;「$&#123;document.title.split(&amp;quot; - &amp;quot;)[0]&#125;」&amp;lt;/span&amp;gt;</code>;<br>      else text = <code>Hello！来自 &amp;lt;span&amp;gt;$&#123;referrer.hostname&#125;&amp;lt;/span&amp;gt; 的朋友</code>;<br>    } else {<br>      text = <code>欢迎阅读&amp;lt;span&amp;gt;「$&#123;document.title.split(&amp;quot; - &amp;quot;)[0]&#125;」&amp;lt;/span&amp;gt;</code>;<br>    }<br>    showMessage(text, 7000, 8);<br>  })();<br>  // TODO: 服务于第一个icon<br>  function showHitokoto() {<br>    // 增加 hitokoto.cn 的 API<br>    fetch(&quot;<a href="https://v1.hitokoto.cn/">https://v1.hitokoto.cn</a>&quot;)<br>      .then(response =&gt; response.json())<br>      .then(result =&gt; {<br>        const text = <code>这句一言来自 &amp;lt;span&amp;gt;「$&#123;result.from&#125;」&amp;lt;/span&amp;gt;，是 &amp;lt;span&amp;gt;$&#123;result.creator&#125;&amp;lt;/span&amp;gt; 在 hitokoto.cn 投稿的。</code>;<br>        showMessage(result.hitokoto, 6000, 9);<br>        setTimeout(() =&gt; {<br>          showMessage(text, 4000, 9);<br>        }, 6000);<br>      });<br>  }<br>  // 没有bug展示特定状态下的文字<br>  function showMessage(text, timeout, priority) {<br>    if (!text || (sessionStorage.getItem(&quot;waifu-text&quot;) &amp;&amp; sessionStorage.getItem(&quot;waifu-text&quot;) &gt; priority)) return;<br>    if (messageTimer) {<br>      clearTimeout(messageTimer);<br>      messageTimer = null;<br>    }<br>    text = randomSelection(text);<br>    sessionStorage.setItem(&quot;waifu-text&quot;, priority);<br>    const tips = document.getElementById(&quot;waifu-tips&quot;);<br>    tips.innerHTML = text;<br>    tips.classList.add(&quot;waifu-tips-active&quot;);<br>    messageTimer = setTimeout(() =&gt; {<br>      sessionStorage.removeItem(&quot;waifu-text&quot;);<br>      tips.classList.remove(&quot;waifu-tips-active&quot;);<br>    }, timeout);<br>  }</p><p>}<br>function initWidget(config, apiPath) {<br>  if (typeof config === &quot;string&quot;) config = { waifuPath: config, apiPath };<br>  document.body.insertAdjacentHTML(&quot;beforeend&quot;, <code>&amp;lt;div id=&amp;quot;waifu-toggle&amp;quot;&amp;gt;                 &amp;lt;span&amp;gt;雷姆&amp;lt;/span&amp;gt;             &amp;lt;/div&amp;gt;</code>);<br>  const toggle = document.getElementById(&quot;waifu-toggle&quot;);<br>  toggle.addEventListener(&quot;click&quot;, () =&gt; {<br>    toggle.classList.remove(&quot;waifu-toggle-active&quot;);<br>    if (toggle.getAttribute(&quot;first-time&quot;)) {<br>      loadWidget(config);<br>      toggle.removeAttribute(&quot;first-time&quot;);<br>    } else {<br>      localStorage.removeItem(&quot;waifu-display&quot;);<br>      document.getElementById(&quot;waifu&quot;).style.display = &quot;&quot;;<br>      setTimeout(() =&gt; {<br>        document.getElementById(&quot;waifu&quot;).style.bottom = 0;<br>      }, 0);<br>    }<br>    // TODO: 一开始判断是否隐藏雷姆代码</p><p>  });<br>  if (localStorage.getItem(&quot;waifu-display&quot;) &amp;&amp; Date.now() - localStorage.getItem(&quot;waifu-display&quot;) &lt;= 86400000) {<br>    toggle.setAttribute(&quot;first-time&quot;, true);<br>    setTimeout(() =&gt; {<br>      toggle.classList.add(&quot;waifu-toggle-active&quot;);<br>    }, 0);<br>  } else {<br>    loadWidget(config);<br>  }</p><p>}</p><p>export {<br>  initWidget, //导出对象<br>}</p><p></code></pre></p></details><p id="u09d47608" class="ne-p"><span class="ne-text">在base.js中初始化看板逻辑代码</span></p><pre><code>import &#123;initWidget&#125; from './part/live2d.js';<p>// live2d 初始化<br>initWidget(&#123;<br>  waifuPath: &quot;/data/remu.json&quot;,<br>  cdnPath: &quot;<a href="https://github.com/fghrsh/live2d_api/tree/1.0.1/">https://github.com/fghrsh/live2d_api/tree/1.0.1/</a>&quot;<br>&#125;);<br></code></pre></p><h3 id="kOl6b"><span class="ne-text">最终看板效果</span></h3><p id="u6ec1d33d" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1665116671351-7c3e9921-cb79-4902-822f-a09a3ce422ae.png" width="1599.9999364217147" id="u50ba46fe" class="ne-image"></p><h2 id="op5Lz"><span class="ne-text">参考</span></h2><ul class="ne-ul"><li id="u96f1ffee"><span class="ne-text">live2d API文档：</span><a href="https://l2dwidget.js.org/docs/class/src/index.js~L2Dwidget.html#instance-method-init" data-href="https://l2dwidget.js.org/docs/class/src/index.js~L2Dwidget.html#instance-method-init" target="_blank" class="ne-link"><span class="ne-text">https://l2dwidget.js.org/docs/class/src/index.js~L2Dwidget.html#instance-method-init</span></a></li><li id="uadc38fc5"><span class="ne-text">封装为npm插件模型：</span><a href="https://huaji8.top/post/live2d-plugin-2.0/" data-href="https://huaji8.top/post/live2d-plugin-2.0/" target="_blank" class="ne-link"><span class="ne-text">https://huaji8.top/post/live2d-plugin-2.0/</span></a></li><li id="0b0eccc822d2e4f83803798ba3120030"><span class="ne-text">自定义扩展模型：</span><a href="https://github.com/luanshizhimei/live2d_models_collect" data-href="https://github.com/luanshizhimei/live2d_models_collect" target="_blank" class="ne-link"><span class="ne-text">https://github.com/luanshizhimei/live2d_models_collect</span></a></li><li id="u845fdd61"><span class="ne-text">vscode live2d扩展：</span><a href="https://github.com/ezshine/vscode-rainbow-fart-waifu" data-href="https://github.com/ezshine/vscode-rainbow-fart-waifu" target="_blank" class="ne-link"><span class="ne-text">https://github.com/ezshine/vscode-rainbow-fart-waifu</span></a></li><li id="u1b0da9ef"><a href="https://github.com/fghrsh/live2d_api/tree/1.0.1/" data-href="https://github.com/fghrsh/live2d_api/tree/1.0.1/" target="_blank" class="ne-link"><span class="ne-text">https://github.com/fghrsh/live2d_api/tree/1.0.1/</span></a></li></ul><ul class="ne-tl"><li id="u57f3d399"><strong><span class="ne-text" style="background-color: #FADB14">TODO: </span></strong><span class="ne-text">优化资源加载方式，模型的静态资源使用外链的形式较为合理，以及插件每次在开发模式下都会编译文件，都会带来开发环境以及生产环境上的不便</span></li></ul></div>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
          <category> 玩转博客 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Vue3项目中ts报错总结</title>
      <link href="/blog/ngt02r/"/>
      <url>/blog/ngt02r/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="u987b4e22" class="ne-p"><br></p><h2 id="xQF2S"><span class="ne-text">TS7053: 元素隐式具有 &quot;any&quot; 类型，因为类型为 &quot;string&quot; 的表达式不能用于索引类型 &quot;{ doc_image: string; docx: string[]; }&quot;。ts(7053)</span></h2><pre><code>const MINE_TYPES = &#123;  doc_image: ['image/png', 'image/gif', 'image/jpeg', 'image/jpg', 'image/bmp'].join(','),  // 暂仅支持docx和xlsx  docx: [    // 'application/pdf',    // 'application/msword',    'application/vnd.openxmlformats-officedocument.wordprocessingml.document',    'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'  ]&#125;;</code></pre><p id="u6dd3159d" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1660816279493-28f705da-2d60-432f-bbd4-20cfef128611.png" width="982" id="TAU1s" class="ne-image"></p><ul class="ne-ul"><li id="ub4f24491"><span class="ne-text">ts对于传入的apiType，编译器只知道为字符串而不是具体的doc_image或者docx，所以需要自行使用断言以及显示声明传入的值与这些值一致。</span></li></ul><pre><code>const accept = MINE_TYPES[apiType as keyof typeof MINE_TYPES] || '*';</code></pre><h2 id="hMqm1"><span class="ne-text">TS2531: Type ‘HTMLElement | null‘ is not assignable to type ‘HTMLElement‘</span></h2><ul class="ne-ul"><li id="u4c1bc5d4"><span class="ne-text">查找DOM这块，很有可能是找不到该DOM元素的，如下：</span></li></ul><p id="u8774d23b" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1660617254293-3d7d5a6c-3512-4c0a-84e4-4af68868f2df.png" width="623" id="GNuC9" class="ne-image"></p><p id="ub7348ded" class="ne-p"><span class="ne-text">很确定dom层一渲染dom树，使用断言</span></p><pre><code>// 点击按钮，返回顶部const handleBackToTop = () =&gt; &#123;  let page_content: HTMLElement = document.getElementById('file-page-content') as HTMLElement;  if (page_content !== null) &#123;    page_content.scrollTop = 0;  &#125;&#125;;</code></pre><h2 id="Lqyep"><span class="ne-text">TS2345: Typescript 'string | 类型的参数null' 不能分配给“字符串”类型的参数.类型 'null' 不能分配给类型 'string'</span></h2><p id="u0af4acf7" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1660632598192-4b5203c9-b02e-4277-bdae-321bfb3bc173.png" width="1018" id="haE8A" class="ne-image"></p><pre><code>const authorInfo = localStorage.getItem('LOGIN_USER')  ? JSON.parse(localStorage.getItem('LOGIN_USER') as string)  : null;</code></pre><h2 id="Mf6k2"><span class="ne-text">TS2307: 【找不到模块】或【ts导入js文件】</span></h2><div class="ne-quote"><p id="u75fe1cc9" class="ne-p"><span class="ne-text">可以归为一类问题，都是导入非ts模块 而报错，而ts的编译是需要有声明类型的</span></p></div><p id="ua6da90e1" class="ne-p"><span class="ne-text">这类报错一般有如下两种情况：</span></p><ol class="ne-ol"><li id="ua5deb70d"><span class="ne-text">import导入依赖包，但是提示找不到该包</span></li><li id="u688ca3e4"><span class="ne-text">ts文件中导入js文件</span></li></ol><p id="u07a5d9a7" class="ne-p"><span class="ne-text">原因：</span></p><ol class="ne-ol"><li id="u13a96ef4"><span class="ne-text">依赖包没有做ts化，没有声明文件，或者说暴露出来的接口，import不支持</span></li><li id="ubdd854de"><span class="ne-text">ts不能导入js，除非做一些配置文件的相关配置（但是尽量不要在ts项目存在js项目）</span></li></ol><p id="u700e1cdb" class="ne-p"><span class="ne-text">解决：</span></p><ul class="ne-ul"><li id="uc836f6e5"><span class="ne-text">国际化网站下载下来的是js文件，但是vite项目不能使用require来导入外部文件</span></li></ul><p id="u32bdd5fb" class="ne-p"><a href="https://www.cnblogs.com/fqh123/p/15820329.html" data-href="https://www.cnblogs.com/fqh123/p/15820329.html" class="ne-link"><span class="ne-text" style="text-decoration: line-through">vite无法使用require的替代方案 - 古墩古墩 - 博客园</span></a><span class="ne-text" style="text-decoration: line-through">，api已废弃</span></p><ul class="ne-tl"><li checked="true" id="u2557d297"><span class="ne-text">解决方法1：（无伤解决方法）类似声明非ts项目依赖一样，单独声明再使用（</span><a href="https://www.cnblogs.com/Blod/p/16185788.html" data-href="https://www.cnblogs.com/Blod/p/16185788.html" class="ne-link"><span class="ne-text">在ts中怎么引入js文件 - 冰中焱 - 博客园</span></a><span class="ne-text">）</span></li></ul><p id="u4d870acd" class="ne-p"><span class="ne-text">en.d.ts中添加</span></p><pre><code>···declare module '@/i18n/lang/zh.js';declare module '@/i18n/lang/en.js';···</code></pre><p id="uf566735f" class="ne-p"><span class="ne-text">然后再ts文件中直接导入使用即可</span></p><pre><code>import zh from '@/i18n/lang/zh.js';import en from '@/i18n/lang/en.js';···</code></pre><ul class="ne-ul"><li id="ufc211982"><span class="ne-text">解决方法2：直接在tsconfig中配置可以使用js的配置项，但是需要单独添加ts编译后的js目录，改动较大</span></li></ul><div class="ne-quote"><ul class="ne-ul"><li id="u5e51fc86"><a href="https://segmentfault.com/q/1010000019980246" data-href="https://segmentfault.com/q/1010000019980246" class="ne-link"><span class="ne-text">tsconfig.json 报错 无法写错写入文件 ，因为他会覆盖输入文件是怎么回事？ - SegmentFault 思否</span></a></li><li id="u2c7f8371"><a href="https://juejin.cn/post/6844904127131025416" data-href="https://juejin.cn/post/6844904127131025416" class="ne-link"><span class="ne-text">ts引用js文件（node包/自己写的文件） - 掘金</span></a></li></ul></div><h2 id="tT4L5"><span class="ne-text" style="color: rgb(77, 77, 77); font-size: 16px">TS2339: </span><span class="ne-text">Property 'replaceAll' does not exist on type 'string'</span></h2><ul class="ne-ul"><li id="uc593baff"><span class="ne-text">ts不能使用js中String的内置API：replaceAll方法</span></li><li id="u5431a587"><span class="ne-text">使用其他字符串api来达到该目的，</span><a href="https://stackoverflow.com/questions/63616486/property-replaceall-does-not-exist-on-type-string" data-href="https://stackoverflow.com/questions/63616486/property-replaceall-does-not-exist-on-type-string" target="_blank" class="ne-link"><span class="ne-text">https://stackoverflow.com/questions/63616486/property-replaceall-does-not-exist-on-type-string</span></a><span class="ne-text">，不推荐使用该方法</span></li></ul><ul class="ne-tl"><li checked="true" id="u8475e55e"><span class="ne-text">解决方法：默认 TypeScript 不支持某些 es6 polyfill 函数，在tsconfig.json配置中进行配置新版本的js语法</span></li></ul><pre><code>&#123;  ...,  &quot;compilerOptions&quot;: &#123;    ...,  &quot;lib&quot;: [    ...,  &quot;ES2021.String&quot;  ]&#125;&#125;</code></pre><h2 id="A8Glh"><span class="ne-text">TS2589: Type instantiation is excessively deep and possibly infinite.</span></h2><ul class="ne-tl"><li id="ub9e33958"><strong><span class="ne-text" style="color: #E8323C"></span></strong><span class="ne-text">如果使用js文件导入，那么在ts文件中使用就会报ts 2589错误。</span></li></ul><pre><code>src/utils/fetch.ts:63:55 - error TS2589: Type instantiation is excessively deep and possibly infinite.<p>63       message<a href="i18n.global.t(msg)">response.config.warnType as NoticeType</a>;<br></code></pre></p><p id="ueab1ee74" class="ne-p"><span class="ne-text">使用如下方式导入js导出来的js和json数据</span></p><pre><code>import &#123; createI18n &#125; from 'vue-i18n';import config from './config.json';import zh from '@/i18n/lang/zh.js';import en from '@/i18n/lang/en.js';import &#123; ref &#125; from 'vue';<p>let zh_obj = &#123;&#125;;<br>zh_obj = zh;<br>let en_obj = &#123;&#125;;<br>en_obj = en;<br>export const lang = ref(‘zh_obj’);</p><p>export const languages = config;</p><p>const i18n = createI18n(&#123;<br>  locale: lang.value,<br>  fallbackLocale: lang.value,<br>  messages: &#123;<br>    zh_obj,<br>    en_obj<br>  &#125;<br>&#125;);</p><p>export default i18n;<br></code></pre></p></div>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
          <category> TypeScript </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>诺兰『蝙蝠侠』三部曲</title>
      <link href="/essay/lr2r4p/"/>
      <url>/essay/lr2r4p/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="ud0b8a1c9" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1659258590527-a4ac7156-1a4c-494f-8480-9609de27e2c6.png" width="1139.259339739435" id="uc1f00cef" class="ne-image"></p><h4 id="AZQqk"><span class="ne-text">恐惧继而愤怒</span></h4><p id="u8e0b4d48" class="ne-p"><span class="ne-text">害怕的事物终究成为自我救赎的武器</span></p><p id="u3c9b937f" class="ne-p"><span class="ne-text">害怕黑暗与黑暗中的蝙蝠，害怕所带来的恐惧与懦弱</span></p><p id="u833ac2f1" class="ne-p"><span class="ne-text">一个人越害怕一件事情，这件事情往往会再现自己的身边</span></p><p id="ua567b001" class="ne-p"><span class="ne-text">只不过对于布鲁斯·韦恩，这个失去的东西太沉重</span></p><p id="ua4be8f15" class="ne-p"><span class="ne-text">于是带着自责与愤怒逃离那个错误的城市···</span></p><p id="ua1b2d4ff" class="ne-p"><span class="ne-text"></span></p><h4 id="GwlsN"><span class="ne-text">愤怒但非犯罪</span></h4><p id="u9bf106bf" class="ne-p"><span class="ne-text">秉承着 惧怕驱使你行善或作恶的动力 信念的影武者联盟</span></p><p id="u045841c1" class="ne-p"><span class="ne-text">消除了内心的恐惧</span></p><p id="ub502277c" class="ne-p"><span class="ne-text">但是消除并不等于黑化</span></p><p id="uaa843634" class="ne-p"><span class="ne-text">于是误入歧途的前一刻坚守自己认为对的事情···</span></p><p id="u67bf7b28" class="ne-p"><span class="ne-text"></span></p><h4 id="vqGFP"><span class="ne-text">侠影与得失</span></h4><p id="uc99c173d" class="ne-p"><span class="ne-text">用一己之力纠正那些不对的事</span></p><p id="u3ff1b640" class="ne-p"><span class="ne-text">当认定要做一些常人难以做成的事情</span></p><p id="u913e6cd7" class="ne-p"><span class="ne-text">就势必会失去一些已有的事物，比如感情与名望···</span></p><p id="u0a14c2c5" class="ne-p"><span class="ne-text"></span></p><h4 id="RrHQ4"><span class="ne-text">原则</span></h4><p id="ud66d9e8b" class="ne-p"><span class="ne-text">世上所有的反派都不及一个精神病患者</span></p><p id="u783c4a39" class="ne-p"><span class="ne-text">人才辈出阿卡姆就有这么一个人才</span></p><p id="u0186c38b" class="ne-p"><span class="ne-text">什么都不想要，只想要毁灭，只仇视所谓正义的秩序者</span></p><p id="uc880c0d5" class="ne-p"><span class="ne-text">众所周知，疯子和天才只有一线之隔</span></p><p id="ua8d05fb3" class="ne-p"><span class="ne-text">小丑最擅长的就是拿捏人性，而且是每次都成功拿捏人性中的暗</span></p><p id="uf90a1a98" class="ne-p"><span class="ne-text">所以小丑所设计的几个犯罪案例都是结合人性的超高智商案例</span></p><p id="u0ff2b39e" class="ne-p"><span class="ne-text">小丑和蝙蝠侠都是同类人</span></p><p id="u1ca4d347" class="ne-p"><span class="ne-text">造成这个不同的结果就是小时候的教育···</span></p><p id="u57861ea6" class="ne-p"><span class="ne-text">所以与其说这是蝙蝠侠与小丑或是正义与邪恶之间的较量</span></p><p id="u7cfb9084" class="ne-p"><span class="ne-text">不如说是人性的光与暗之间的碰撞</span></p><p id="ue3e3804c" class="ne-p"><span class="ne-text"></span></p><h4 id="ARbHF"><span class="ne-text">黑暗骑士——无名</span></h4><p id="ue3faa0f9" class="ne-p"><span class="ne-text">最高光最封神的就是第二部中蝙蝠侠与戈登最后的对话</span></p><div class="ne-quote"><p id="u426a0640" class="ne-p"><span class="ne-text">要么舍生取义、流芳百世</span></p><p id="u11d91de1" class="ne-p"><span class="ne-text">要么苟活到目睹自己被逼成恶棍</span></p><p id="uba08d3ec" class="ne-p"><span class="ne-text">把这些事算到我头上</span></p><p id="ub8294670" class="ne-p"><span class="ne-text">因为我不是英雄 不像丹特</span></p><p id="ue45b20a3" class="ne-p"><span class="ne-text">我可以背负杀死他们的罪名</span></p><p id="ua99b18c2" class="ne-p"><span class="ne-text">哥谭需要我是什么样的 我就是什么样的</span></p></div><p id="u78c6401e" class="ne-p"><span class="ne-text">行走在黑暗中的骑士，从来都不需要流芳百世</span></p><p id="ub69ea752" class="ne-p"><span class="ne-text">背负诋毁与罪名，让人们生活在光明且充满希望的世界···</span></p><p id="uf8c20e54" class="ne-p"><span class="ne-text"></span></p><h4 id="T0wSf"><span class="ne-text">崛起</span></h4><p id="u185ccb90" class="ne-p"><span class="ne-text">蝙蝠侠崛起的不是布鲁斯·韦恩，而是蝙蝠侠这种侠影精神</span></p><p id="u6de2757b" class="ne-p"><span class="ne-text">最后的罗宾来到蝙蝠洞就证明这一点</span></p><p id="u1b3ec18e" class="ne-p"><span class="ne-text">英雄谢幕退场到原点，后来者继上···</span></p><p id="u6cf9a49d" class="ne-p"><span class="ne-text"></span></p><p id="ub842d2d1" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/1484158/1659258039316-a9a813e2-6189-439d-84f2-16980eabae9a.jpeg" width="2400" id="MrsZD" class="ne-image"></p><p id="uda87b3d3" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/1484158/1659258040513-acdc8cbd-0d02-441f-a5c5-e685e7b96a83.jpeg" width="2400" id="ovmsC" class="ne-image"></p><p id="uc410fc3e" class="ne-p"><br></p></div>]]></content>
      
      
      <categories>
          
          <category> 影视 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript实现并发控制且指定并发上限为concurrency</title>
      <link href="/blog/wboxcq/"/>
      <url>/blog/wboxcq/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="u5db88ede" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1658750399274-d7c6f4fd-a9ce-4f10-a771-b9567b84830d.png" width="255.5555736086509" id="u9eff5b76" class="ne-image"></p><p id="u336780ef" class="ne-p"><span class="ne-text">前言：使用Typescript编写如下函数功能 并发控制函数 要求控制任务执行的并发上限为concurrency</span></p><p id="ua4fed787" class="ne-p"><span class="ne-text"></span></p><pre><code>/* * @Author: wztlink1013 * @Date: 2022-07-25 19:57:09 * @LastEditTime: 2022-07-25 19:57:22 * @Description: */// Practice 1const test_1 = () =&gt; &#123;  return new Promise(resolve =&gt; &#123;    setTimeout(() =&gt; &#123;      console.log('2000')      let myDate = new Date()      console.log('---- ', myDate.toTimeString().substring(0, 8), ' ----')      resolve(2000)    &#125;, 2000)  &#125;)&#125;const test_2 = () =&gt; &#123;  return new Promise(resolve =&gt; &#123;    setTimeout(() =&gt; &#123;      console.log('3000')      let myDate = new Date()      console.log('---- ', myDate.toTimeString().substring(0, 8), ' ----')      resolve(3000)    &#125;, 3000)  &#125;)&#125;const test_3 = () =&gt; &#123;  return new Promise(resolve =&gt; &#123;    setTimeout(() =&gt; &#123;      console.log('4000')      let myDate = new Date()      console.log('---- ', myDate.toTimeString().substring(0, 8), ' ----')      resolve(4000)    &#125;, 4000)  &#125;)&#125;<p>let arr = [test_1, test_2, test_3]</p><p>async function parallel(<br>  tasks: (() =&gt; void)[],<br>  concurrency: number<br>): Promise&lt;void&gt; &#123;<br>  const ret: any[] = []<br>  const executing: any[] = []</p><p>  let myDate = new Date()<br>  console.log(‘—-start ‘, myDate.toTimeString().substring(0, 8), ‘ —-‘)</p><p>  for (const item of tasks) &#123;<br>    const p = Promise.resolve().then(item)<br>    ret.push(p)</p><pre><code>if (concurrency &amp;lt;= tasks.length) &#123;  const e: any = p.then(() =&amp;gt; executing.splice(executing.indexOf(e), 1))  executing.push(e)  if (executing.length &amp;gt;= concurrency) &#123;    await Promise.race(executing)  &#125;&#125;</code></pre><p>  }<br>  // return Promise.all(ret);<br>}<br>parallel(arr, 2)<br></code></pre></p><h2 id="lXmLO"><span class="ne-text">参考：</span></h2><ul class="ne-ul"><li id="u6fd14527"><a href="https://juejin.cn/post/6976028030770610213" data-href="https://juejin.cn/post/6976028030770610213" class="ne-link"><span class="ne-text">JavaScript 中如何实现并发控制？ - 掘金</span></a></li></ul></div>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
          <category> JavaScript </category>
          
          <category> ECMAScript </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>滚动穿透：抽屉层下的DOM跟随滚动</title>
      <link href="/blog/wwclae/"/>
      <url>/blog/wwclae/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="u10d9e989" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1665141885929-afd0c3cb-bdd4-4e82-95b3-8b6d2f7964b5.png" width="696.6666389836216" id="ubd08e735" class="ne-image"></p><p id="u46c516f8" class="ne-p"><span class="ne-text">前言：对网站做移动端适配，点击左上角弹出抽屉布局，其实现为fixed绝对定位，对其进行鼠标的上下滚动会造成抽屉层下面的dom元素也随之滚动，本文目的旨在解决该</span><strong><span class="ne-text">滚动穿透</span></strong><span class="ne-text">问题。</span></p><p id="u9432b897" class="ne-p"><span class="ne-text"></span></p><p id="u22e19627" class="ne-p"><span class="ne-text">思路</span></p><ul class="ne-ul"><li id="ub7820cc9"><span class="ne-text">网上思路较多，鼠标滚动也好，手指滑动也好，都属于Event事件，而后抽屉弹出禁用底部dom的默认事件思路，该思路可行，不过有点大材小用。</span></li></ul><ul class="ne-tl"><li checked="true" id="uf52d49e9"><span class="ne-text">只利用css解决该问题，当抽屉弹出，记录</span><code class="ne-code"><span class="ne-text">window.scrollY</span></code><span class="ne-text">的值，同时对底部dom进行绝对定位，当抽屉层关闭，底部dom清楚绝对定位及其相关属性，并且跳转刚刚记录的</span><code class="ne-code"><span class="ne-text">window.scrollY</span></code><span class="ne-text">值。部分代码如下：</span></li></ul><pre><code>let top = 0;// 点击左按钮btn_app_sider.click(function () &#123;  app_side_glass.css(&#123; display: &quot;block&quot; &#125;);  app_side_content.css(&#123; display: &quot;block&quot; &#125;);  // 阻止抽屉层下的滑动穿透  top = window.scrollY;  container.css(&#123; position: &quot;fixed&quot;, top: -top + &quot;px&quot; &#125;);&#125;);// 点击毛玻璃片app_side_glass.click(function () &#123;  app_side_glass.css(&#123; display: &quot;none&quot; &#125;);  app_side_content.css(&#123; display: &quot;none&quot; &#125;);  // 阻止抽屉层下的滑动穿透  container.css(&#123; position: &quot;&quot;, top: &quot;&quot; &#125;);  window.scrollTo(0, top);&#125;);</code></pre></div>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
          <category> HTML+CSS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Vue3重构Vue2项目知识总结</title>
      <link href="/blog/wg5n0g/"/>
      <url>/blog/wg5n0g/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="u5fc1e207" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1662219960321-86e09edc-e993-4ce0-88db-bebea0da263e.png" width="1507.4999400973343" id="u6d2cb89a" class="ne-image"></p><p id="u7483d19f" class="ne-p"><span class="ne-text"></span></p><p id="u3bbb6074" class="ne-p"><span class="ne-text">前言：使用Vue3（</span><a href="https://cn.vuejs.org/" data-href="https://cn.vuejs.org/" class="ne-link"><span class="ne-text">Vue.js - 渐进式 JavaScript 框架 | Vue.js</span></a><span class="ne-text">）的 </span><a href="https://cn.vuejs.org/guide/introduction.html#api-styles" data-href="https://cn.vuejs.org/guide/introduction.html#api-styles" target="_blank" class="ne-link"><span class="ne-text">组合式API</span></a><span class="ne-text"> 编程风格来进行基础转换。</span></p><p id="uf30994f1" class="ne-p"><br></p><p id="u11b5af03" class="ne-p"><span class="ne-text" style="color: rgb(36, 41, 47); font-size: 14px">基础变动：</span></p><ul class="ne-ul"><li id="u3d084571"><span class="ne-text" style="color: rgb(36, 41, 47); font-size: 14px">setup语法糖 Vue3.2之后才能放到script里面</span></li><li id="u89b82f0b"><span class="ne-text" style="color: rgb(36, 41, 47); font-size: 14px">data methods 都不再需要，也不再需要return出变量或是函数</span></li><li id="uec5a4d8c"><span class="ne-text" style="color: rgb(36, 41, 47); font-size: 14px">路由相关知识，只注意</span><span class="ne-text" style="color: rgb(36, 41, 47); font-size: 12px">useRoute()</span><span class="ne-text" style="color: rgb(36, 41, 47); font-size: 14px"> </span><span class="ne-text" style="color: rgb(36, 41, 47); font-size: 12px">useRouter()</span><span class="ne-text" style="color: rgb(36, 41, 47); font-size: 14px">其余的，和之前自己写的lyrics前端路由就够用了</span></li><li id="u5e17a00e"><span class="ne-text" style="color: rgb(36, 41, 47); font-size: 14px">Vue3 异步编程</span></li><li id="u46903163"><span class="ne-text" style="color: rgb(36, 41, 47); font-size: 14px">provide 和 inject</span></li><li id="u4a3c5f1e"><span class="ne-text" style="color: rgb(36, 41, 47); font-size: 14px">······</span></li></ul><p id="u642b3074" class="ne-p"><span class="ne-text">语法转换过程中，主要分几个大块：</span></p><ul class="ne-ul"><li id="u4a49a6cf"><span class="ne-text">语法：框架自行的一些语法迁移（官网里面的</span><strong><span class="ne-text">基础</span></strong><span class="ne-text">）</span></li><li id="u3fb0af83"><span class="ne-text">组件相关：尤其是组件之间的各类通信方式，以及封装组件的传参等，单独一篇文章总结。</span></li><li id="uca31ce98"><span class="ne-text">编程风格/封装相关</span></li><li id="u9590c6a0"><span class="ne-text">······</span></li></ul><h2 id="sXl99"><span class="ne-text">数据</span></h2><h3 id="opEG9"><span class="ne-text">普通数据</span></h3><pre><code>&lt;script setup lang=&quot;ts&quot;&gt;interface SpecialFunDataItem &#123;  title: string  description: string&#125;const apply_data: SpecialFunDataItem[] = [  &#123;    title: '知识库/项目文档/产品手册',    description: '适合',  &#125;,  &#123;    title: '帮助中心/FAQ/在线问答',    description: '适合。',  &#125;,]  &lt;/script&gt;</code></pre><h3 id="u5iUn"><span class="ne-text">响应数据</span></h3><h4 id="Mp2Px"><span class="ne-text">ref</span></h4><pre><code>&lt;template&gt;  &lt;a-modal    v-model:visible=&quot;visible&quot;、    ···    &gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot;&gt;import &#123;ref&#125; from 'vue'const visible = ref&lt;boolean&gt;(false)&lt;/script&gt;<p></code></pre></p><h4 id="Q3CuW"><span class="ne-text">reactive</span></h4><p id="u6466c8ca" class="ne-p"><span class="ne-text">reactive这个更多使用在对象和数组类型的响应式定义数据，因为在vue2中，对于数组和对象是不能够完美响应式的，需要watch来监听实现，而在vue3中，以此作为优化来定义响应式数据。</span></p><p id="u3a6d13e2" class="ne-p"><span class="ne-text">但是直接使用ref也可以定义响应式数组或对象数据</span></p><ul class="ne-tl"><li checked="true" id="u0e7fb17d"><span class="ne-text">reactive定义的数组不能实时渲染，用ref就完事了</span></li></ul><p id="uc2bb26ea" class="ne-p"><a href="https://blog.csdn.net/m0_46527751/article/details/124957269" data-href="https://blog.csdn.net/m0_46527751/article/details/124957269" class="ne-link"><span class="ne-text">Vue3异步请求获取数据在渲染时不显示的问题_s－010101的博客-CSDN博客_vue异步请求数据没渲染</span></a></p><p id="u1db3fe11" class="ne-p"><span class="ne-text">并不是生命周期的问题，而是数据定义的问题</span></p><p id="ubd0005f8" class="ne-p"><span class="ne-text">除了上述两种方式解决办法，还可以使用ts语法，接口，参照antdv中的表单相关实例代码</span></p><ul class="ne-tl"><li id="ua1955014"><span class="ne-text">reactive不能渲染，更新名称子组件不能渲染</span></li><li checked="true" id="u984ead1f"><span class="ne-text">FIXME: 重命名组件中，输入框值变化不能响应式</span></li></ul><p id="ua93986ed" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1661150516722-4068bc1d-d2e0-4f0c-ba9c-ee0970b4963c.png" width="265.9921875" id="lQR6v" class="ne-image"><span class="ne-text">同时对数据定义用ref不用reactive</span></p><ul class="ne-tl"><li id="ubbbdc775"><a href="https://segmentfault.com/q/1010000039940940" data-href="https://segmentfault.com/q/1010000039940940" target="_blank" class="ne-link"><span class="ne-text">vue3中的reactive对象赋值问题</span></a></li></ul><h3 id="w8Utk"><span class="ne-text">Vue2中的data</span></h3><h4 id="PtTx4"><span class="ne-text">如何在setup中使用data中的数据库？</span></h4><p id="ud3222ed5" class="ne-p"><span class="ne-text">按照以前vue2，直接使用this可以访问到data中定义的数据，但在vue3不行，因为setup()函数的执行要比created，oncrated函数都要早。</span></p><p id="u9da72a0e" class="ne-p"><span class="ne-text"></span></p><p id="u34d7ae55" class="ne-p"><span class="ne-text">具体使用以下小技巧可以访问到：</span></p><pre><code>&lt;div v-on:click=&quot;fun(testdata)&quot;&gt;&lt;/div&gt;<p>setup()&#123;<br>    const  fun=(i)=&gt;&#123;<br>      alert(i)<br>    &#125;<br>&#125;,<br>data()&#123;<br>    return&#123;<br>       testdata:1,<br>    &#125;<br>&#125;<br></code></pre></p><p id="u67e03fdc" class="ne-p"><span class="ne-text">也可以使用getCurrentInstance方法获取data内的数据</span><strong><span class="ne-text" style="color: #E8323C">（未验证）</span></strong></p><pre><code>&lt;script lang=&quot;ts&quot;&gt;import &#123; getCurrentInstance &#125; from &quot;vue&quot;;export default &#123;  data() &#123;    return &#123;      b: &quot;data数据&quot;,    &#125;;  &#125;,  setup() &#123;    const datab = getCurrentInstance();    async function getdata()&#123;        let dataa=datab.data.b;        console.log(dataa)    &#125;  &#125;,&#125;;&lt;/script&gt;</code></pre><p id="uf6f7e0e6" class="ne-p"><br></p><h2 id="u0Iol"><span class="ne-text">计算属性+方法+侦听器</span></h2><p id="u7dfc51e9" class="ne-p"><span class="ne-text">计算属性（computed）和方法（methods）的区别</span></p><ul class="ne-ul"><li id="u15ab7bec"><span class="ne-text">计算属性是基于他们的依赖来进行缓存的</span></li></ul><p id="u7ae90c12" class="ne-p"><span class="ne-text">“他们的依赖”指的是data数据域中的data数据，如果其变动，计算属性值才会变</span></p><ul class="ne-ul"><li id="u424a9f75"><span class="ne-text">方法不存在缓存</span></li></ul><p id="u9a1a5ffb" class="ne-p"><span class="ne-text">计算属性（computed）和侦听器（watch）的使用</span></p><ul class="ne-ul"><li id="u029e3984"><span class="ne-text">侦听器更用于异步或是开销较大的操作</span></li></ul><h3 id="b1d999af"><span class="ne-text">watch（侦听器）+computed（计算属性）+watchEffect</span></h3><ul class="ne-ul"><li id="u218599f2"><span class="ne-text">watchEffect：只要在该函数引用声明式变量，那么就会执行该函数</span></li></ul><div class="ne-quote"><p id="ub95ff445" class="ne-p"><span class="ne-text">为了根据响应式状态自动应用和重新应用副作用，我们可以使用 watchEffect 函数。它立即执行传入的一个函数，同时响应式追踪其依赖，并在其依赖变更时重新运行该函数。</span></p></div><ul class="ne-ul"><li id="u39565fb8"><span class="ne-text">watch：vue2中监听新值和旧值的一样使用（ref reactive 各有不同）</span></li><li id="uf22eca5e"><span class="ne-text">computed </span></li></ul><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="u4b2042e5"><span class="ne-text">注意Vue computed 的类型声明方式https://bytenote.net/article/121073339505573889 </span><a href="https://v3.cn.vuejs.org/api/computed-watch-api.html#computed" data-href="https://v3.cn.vuejs.org/api/computed-watch-api.html#computed" target="_blank" class="ne-link"><span class="ne-text">https://v3.cn.vuejs.org/api/computed-watch-api.html#computed</span></a></li><li id="u393ac6e2"><span class="ne-text">不确定暂时先用any</span></li></ul></ul><ul class="ne-ul"><li id="u9c90f99c"><span class="ne-text">动态监听数组，返回的新值打印出来都是数组元素逗号隔开，因为监听的是内部每一个数组元素</span></li></ul><details class="lake-collapse"><summary id="u0887aed0"></summary><pre><code>&lt;template&gt;  &lt;button type=&quot;button&quot; @click=&quot;count++&quot;&gt;[watch watchEffect]ref 定义的 count is: &#123;&#123; count &#125;&#125;&lt;/button&gt;&lt;hr/&gt;  &lt;button type=&quot;button&quot; @click=&quot;numbers[0]++&quot;&gt;[watch watchEffect]reactive 定义的 numbers is: &#123;&#123; numbers &#125;&#125;&lt;/button&gt;&lt;hr/&gt;  &lt;button type=&quot;button&quot; &gt;[computed]ref 定义的 person_ref is: &#123;&#123; person_ref &#125;&#125;&lt;/button&gt;&lt;hr/&gt;  &lt;button type=&quot;button&quot; &gt;[computed]reactive 定义的 person_reactive is: &#123;&#123; person_reactive &#125;&#125;&lt;/button&gt;&lt;hr/&gt;  &lt;span&gt;动态参数绑定：&lt;/span&gt;&lt;a :href=&quot;getHrefValue()&quot;&gt;&#123;&#123;getHrefValue()&#125;&#125;&lt;/a&gt;&lt;hr/&gt;<p>&lt;/template&gt;</p><p>&lt;script setup lang=&quot;ts&quot;&gt;<br>import &#123; ref, watchEffect, watch, reactive, computed, Ref &#125; from ‘vue’</p><p>const count = ref(0)<br>const numbers = reactive([1, 2, 3, 4])<br>let person_ref = ref(‘wuzutao’)<br>let person_reactive = reactive(&#123;firstName:’wu’, lastName:’zutao’, fullName: ‘wu-zutao’&#125;)</p><p>let getHrefValue = () =&gt; &#123;<br>    return ‘<a href="http://www.wztlink1013.com&/#39;">www.wztlink1013.com&#39;</a><br>&#125;</p><p>// [watchEffect ref reactive]<br>watchEffect(()=&gt;&#123;<br>  const x1 = count.value<br>  const x2 = numbers[0]<br>  console.log(‘因为watchEffect里面调用了count/numbers[0] 所以watchEffect所指定的回调执行了’, x1, x2)<br>&#125;)<br>// [watch ref]<br>watch(count, (count, prevCount) =&gt; &#123;<br>    console.log(‘新值’, count)<br>    console.log(‘旧值’, prevCount)<br>&#125;)<br>// [watch reactive]<br>watch(<br>  () =&gt; […numbers],<br>  (numbers, prevNumbers) =&gt; &#123;<br>    console.log(‘numbers新值’,numbers)<br>    console.log(‘numbers旧值’,prevNumbers)<br>  &#125;<br>)<br>// [computed ref]<br>// const computed_ref = computed(() =&gt; &#123; // 简单式<br>//     person_ref.value = person_ref.value + ‘+’<br>// &#125;)<br>const computed_ref = computed&lt;any&gt;(&#123; // 复合式<br>  get: () =&gt; &#123;<br>    console.log(‘[ref]使用(get)该变量,就会调用’)<br>  &#125;,<br>  set: (val) =&gt; &#123;<br>    console.log(‘[ref]改变(set)该变量,就会调用’)<br>    person_ref.value = val + ‘-内部处理值-原始值’ + person_ref.value<br>  &#125;<br>&#125;)<br>// console.log(computed_ref.value) // 会打印undefined因为上面的get没有传参<br>computed_ref.value = ‘修改的目的值’</p><p>// [computed reactive]<br>// person[‘firstName’] = computed(()=&gt;&#123;<br>//     return person.firstName + ‘-‘ + person.lastName<br>//     &#125;)<br> const computed_reactive= computed&lt;any&gt;(&#123; // 完整写法<br>    get()&#123;<br>        // return person_reactive.firstName + ‘-‘ + person_reactive.lastName<br>        console.log(‘[reactive]使用(get)该变量,就会调用’)<br>    &#125;,<br>    set(value)&#123;<br>        console.log(‘[reactive]改变(set)该变量,就会调用’)<br>        const nameArr = value.split(‘-‘)<br>        person_reactive.fullName = value<br>        person_reactive.firstName = nameArr[0]<br>        person_reactive.lastName = nameArr[1]<br>    &#125;<br>&#125;)<br>computed_reactive.value = ‘wu+-zutao+’<br>&lt;/script&gt;</p><p>&lt;style scoped&gt;<br>a &#123;<br>  color: #42b983;<br>&#125;</p><p>label &#123;<br>  margin: 0 0.5em;<br>  font-weight: bold;<br>&#125;</p><p>code &#123;<br>  background-color: #eee;<br>  padding: 2px 4px;<br>  border-radius: 4px;<br>  color: #304455;<br>&#125;<br>&lt;/style&gt;<br></code></pre></p></details><ul class="ne-tl"><li id="udfbfc9b8"><span class="ne-text">vue3的监听器报重载错误</span></li></ul><h3 id="KW8mQ"><span class="ne-text">Vue2中侦听器(watch)注意事项</span></h3><p id="uf59f37a1" class="ne-p"><span class="ne-text">实际开发过程中：</span></p><ul class="ne-ul"><li id="uacba8ec2"><strong><span class="ne-text">非的确必要，尽量不要使用watch监听，实际过程中，会造成许多问题，比如渲染顺序等，会给后续添加功能带来难以维护的问题</span></strong></li><li id="u4800cbab"><span class="ne-text">当监听的数据不是一个简单的基本类型，比如一个对象，一个数组，此时应该使用深度监听：deep:true；当想让监听器一启动就触发一次watch，应该使用： immediate: true。</span></li></ul><div class="ne-quote"><p id="ub31b8966" class="ne-p"><span class="ne-text">直接</span><code class="ne-code"><span class="ne-text">watch</span></code><span class="ne-text">监听对象内的是检测不到变化的，因为对象的指向并没有发生改变。Vue中的watch监听对象内属性的变动方案</span></p></div><h4 id="U7lp1"><span class="ne-text">使用deep属性</span></h4><pre><code>new Vue(&#123;  data: &#123;    count: 10，    blog:&#123;        title:'my-blog',        categories:[]    &#125;  &#125;,  watch: &#123;    blog:&#123;        handler(newVal,oldVal)&#123;            console.log(`new: $&#123;newVal&#125;, old: $&#123;oldVal&#125;`);        &#125;,    deep:true    &#125;  &#125;&#125;)</code></pre><p id="u22fd44d5" class="ne-p"><br></p><p id="uc92302d5" class="ne-p"><span class="ne-text">里面的</span><code class="ne-code"><span class="ne-text">deep</span></code><span class="ne-text">设为了</span><code class="ne-code"><span class="ne-text">true</span></code><span class="ne-text">，这样的话，如果修改了这个</span><code class="ne-code"><span class="ne-text">blog</span></code><span class="ne-text">中的任何一个属性，都会执行</span><code class="ne-code"><span class="ne-text">handler</span></code><span class="ne-text">这个方法。不过这样会造成更多的性能开销，尤其是对象里面属性过多，结构嵌套过深的时候。而且有时候我们就只想关心这个对象中的某个特定属性，这个时候可以这样</span></p><h4 id="F2YBm"><span class="ne-text">用字符串来表示对象的属性调用</span></h4><pre><code>new Vue(&#123;  data: &#123;    count: 10，    blog:&#123;        title:'my-blog',        categories:[]    &#125;  &#125;,  watch: &#123;    'blog.categories'(newVal, oldVal) &#123;        console.log(`new:$&#123;newVal&#125;, old:$&#123;oldVal&#125;`);    &#125;,   &#125;&#125;)</code></pre><h4 id="aAOEA"><span class="ne-text">使用计算属性(computed)</span></h4><pre><code>new Vue(&#123;  data: &#123;    count: 10，    blog:&#123;        title:'my-blog',        categories:[]    &#125;  &#125;,  computed: &#123;    categories() &#123;      return this.blog.categories;    &#125;  &#125;,  watch: &#123;    categories(newVal, oldVal) &#123;      console.log(`new:$&#123;newVal&#125;, old:$&#123;oldVal&#125;`);    &#125;,   &#125;,&#125;)</code></pre><p id="u7e9d13d4" class="ne-p"><span class="ne-text">参考：</span><a href="https://segmentfault.com/a/1190000018080301" data-href="https://segmentfault.com/a/1190000018080301" target="_blank" class="ne-link"><span class="ne-text">https://segmentfault.com/a/1190000018080301</span></a></p><h3 id="fad771df"></h3><h2 id="uWCZt"><span class="ne-text">生命周期</span></h2><ul class="ne-ul"><li id="ub3ef8ae4"><span class="ne-text">生命周期需要注意，没有created阶段了，直接在setup里面了，也就是setup阶段是没有挂载真实DOM的，如果需要操作真实dom需要在onMounetd里面进行相应逻辑</span></li></ul><pre><code>onMounted(() =&gt; &#123;  if ((document.getElementById('test') as HTMLElement) === null) &#123;    console.log('--------------');  &#125; else &#123;    console.log('+++++++++++++++++++++');  &#125;&#125;);</code></pre><ul class="ne-ul"><li id="uac6d1435"><a href="https://v3.cn.vuejs.org/guide/instance.html#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%9B%BE%E7%A4%BA" data-href="https://v3.cn.vuejs.org/guide/instance.html#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%9B%BE%E7%A4%BA" target="_blank" class="ne-link"><span class="ne-text">https://v3.cn.vuejs.org/guide/instance.html#生命周期图示</span></a></li><li id="ufc8d3456"><a href="https://juejin.cn/post/6942030120383168542" data-href="https://juejin.cn/post/6942030120383168542" target="_blank" class="ne-link"><span class="ne-text">https://juejin.cn/post/6942030120383168542</span></a></li><li id="ued2b84b0"><a href="https://segmentfault.com/a/1190000038426588" data-href="https://segmentfault.com/a/1190000038426588" target="_blank" class="ne-link"><span class="ne-text">https://segmentfault.com/a/1190000038426588</span></a></li><li id="u4c8420da"><a href="https://juejin.cn/post/7108206884867276831" data-href="https://juejin.cn/post/7108206884867276831" target="_blank" class="ne-link"><span class="ne-text">https://juejin.cn/post/7108206884867276831</span></a></li><li id="uf0950a9a"><a href="https://segmentfault.com/a/1190000039680245" data-href="https://segmentfault.com/a/1190000039680245" class="ne-link"><span class="ne-text">Vue 3 生命周期完整指南</span></a></li></ul><ul class="ne-tl"><li checked="true" id="u6f3bfb6f"><strong><span class="ne-text">bug：</span></strong><span class="ne-text">刚进入页面，下面的地方不会自动摊开宽度，获取dom的宽度失败</span></li></ul><p id="u6a058fb0" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1663310483216-ada7ca88-f2e2-4a4b-8447-c3c417c779c8.png" width="193" id="u937129c7" class="ne-image"></p><p id="u32c78c63" class="ne-p"><span class="ne-text">代码放到onMounted中即可</span></p><p id="u5b79d127" class="ne-p"><span class="ne-text"></span></p><p id="u7671054e" class="ne-p"><span class="ne-text">vue2当中：</span></p><ol class="ne-ol"><li id="u03072dc1"><span class="ne-text">beforeCreate：在实例初始化之后，数据观测和事件配置之前被调用</span></li><li id="u7f6830af"><span class="ne-text">created：在实例创建完成后被立即调用</span></li><li id="u363a87ca"><span class="ne-text">beforeMount：在挂载开始之前被调用</span></li><li id="u8c6e7b07"><span class="ne-text">mounted：el被新创建的vm.$el替换，并挂载到实例上去之后调用该钩子</span></li><li id="ub431174c"><span class="ne-text">beforeUpdate：数据更新时调用，发生在虚拟DOM打补丁之前</span></li><li id="ud4c52258"><span class="ne-text">updated：由于数据更改导致的虚拟DOM重新渲染和打补丁，在这之后会调用该钩子</span></li><li id="u5cb6441c"><span class="ne-text">beforeDestroy：实例销毁之前调用</span></li><li id="ue81310ec"><span class="ne-text">destroyed：实例销毁后调用</span></li></ol><p id="u2b15d174" class="ne-p"><span class="ne-text"></span></p><pre><code>&lt;script&gt;  setup() &#123;    console.log('----setup第一个执行----')    // vue3.x生命周期写在setup中    onBeforeMount(() =&gt; &#123;      console.log('------vue3中onBeforeMount-----')    &#125;)    onMounted(() =&gt; &#123;      console.log('------vue3中onMounted-----')    &#125;)    onRenderTriggered((event) =&gt; &#123;      console.log('------vue3中onRenderTriggered-----', event)    &#125;)  &#125;,  // vue2当中的  beforeCreate() &#123;    console.log('----vue2中beforeCreate第二个执行----')  &#125;,  // vue2当中的  created() &#123;    console.log('----vue2中created第三个执行----')  &#125;,&lt;/script&gt;</code></pre><p id="u20c2d491" class="ne-p"><span class="ne-text">执行结果如下：</span></p><p id="u9c80ce3d" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1644646841871-0aaeece1-c5dd-493e-bbfc-41f52925931a.png" width="792" id="ue1197c21" class="ne-image"></p><h2 id="amOyt"><span class="ne-text">具体使用</span></h2><h3 id="EL5JT"><span class="ne-text">router和route区别及使用</span></h3><p id="u7abd5330" class="ne-p"><span class="ne-text"> </span><a href="https://juejin.cn/post/7116720209502683172" data-href="https://juejin.cn/post/7116720209502683172" class="ne-link"><span class="ne-text">vue3中的useRoute（）和useRouter()； - 掘金</span></a></p><h3 id="OSYBy"><span class="ne-text">Vue3中使用Async Await</span></h3><ul class="ne-ul"><li id="ue00b3b0d"><span class="ne-text">vue3的setup本就是一个async</span><span class="ne-text" style="text-decoration: line-through">，所以可以直接使用await（不可以）</span></li><li id="u4e6107bb"><a href="https://www.cnblogs.com/shiazhen/p/14986454.html" data-href="https://www.cnblogs.com/shiazhen/p/14986454.html" class="ne-link"><span class="ne-text">vue3.0 中 如何在setup中使用async await - 阿臻 - 博客园</span></a></li></ul><pre><code>const handleLoginOut = async () =&gt; &#123;  emit('wsClosed');  const &#123; ret &#125; = await logout();  if (ret &gt; -1) &#123;    localStorage.clear();    onRedirect();  &#125;&#125;;</code></pre><h3 id="KYiG2"><span class="ne-text">emit使用</span></h3><ul class="ne-ul"><li id="ubc4be53c"><a href="https://segmentfault.com/a/1190000041054210" data-href="https://segmentfault.com/a/1190000041054210" class="ne-link"><span class="ne-text">vue3 setup使用emit</span></a></li></ul><p id="u52cd0197" class="ne-p" style="text-align: left"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1660633907664-aa2576f8-129c-45e4-a747-0f5ce9f765cf.png" width="329.99542236328125" id="u9e932c10" class="ne-image"></p><h3 id="XK1pV"><span class="ne-text">slot使用</span></h3><p id="u4b93f37b" class="ne-p"><span class="ne-text">vue2：</span></p><pre><code>&lt;template&gt;  &lt;template slot=&quot;content&quot;&gt;    ···  &lt;/template&gt;&lt;/template&gt;</code></pre><p id="u2d76544d" class="ne-p"><span class="ne-text">vue3：</span></p><pre><code>&lt;template&gt;  &lt;slot name=&quot;content&quot;&gt;    ···  &lt;/slot&gt;&lt;/template&gt;</code></pre><h3 id="ZQBWT"><span class="ne-text">ref获取元素节点</span></h3><ul class="ne-ul"><li id="ub4539e16"><a href="https://zhuanlan.zhihu.com/p/546041641" data-href="https://zhuanlan.zhihu.com/p/546041641" class="ne-link"><span class="ne-text">一文讲全Vue3中使用ref获取元素节点</span></a></li></ul><h3 id="wZVbK"><span class="ne-text">[取]函数式编程模式[弃]Mixin逻辑</span></h3><ul class="ne-ul"><li id="u737a443d"><span class="ne-text">cooperation的Mixin代码较难抽离出来</span></li></ul><p id="uc4c1ed40" class="ne-p"><span class="ne-text">使用到较多的cooperation文件代码，Mixin逻辑，不再像Home组件中的上传逻辑一样直接放到一块，改用引用函数的方式，因为变量不多。</span></p><p id="u7d540e78" class="ne-p"><strong><span class="ne-text">ylCooperationSdkInstance变量在组件中使用较少，但是如果直接引用ts文件中的变量，是否会存在不再响应的问题</span></strong><span class="ne-text">。使用vue3推荐的组合式函数编程方式：</span></p><p id="u3d96f510" class="ne-p"><a href="https://cn.vuejs.org/guide/reusability/composables.html" data-href="https://cn.vuejs.org/guide/reusability/composables.html" target="_blank" class="ne-link"><span class="ne-text">https://cn.vuejs.org/guide/reusability/composables.html</span></a></p><ul class="ne-ul"><li id="u4138f1c6"><span class="ne-text">上面的mixin文件代码全部放在ts文件中，然后在vue中导入ts文件，其仍然保留生命周期</span></li><li id="u58172690"><span class="ne-text">单独ts文件是用不了全局变量</span></li></ul><p id="u42054b22" class="ne-p"><span class="ne-text">直接导入router文件，使用根源API</span></p><p id="ua53deb11" class="ne-p"><a href="https://cn.vuejs.org/guide/reusability/composables.html#vs-mixins" data-href="https://cn.vuejs.org/guide/reusability/composables.html#vs-mixins" target="_blank" class="ne-link"><span class="ne-text">https://cn.vuejs.org/guide/reusability/composables.html#vs-mixins</span></a></p><ul class="ne-tl"><li id="ucfbac137"><span class="ne-text">将上传逻辑js代码转为ts代码，然后再全量导入Home/index.vue中</span></li><li id="u3d1d9606"><span class="ne-text">data数据迁移</span></li></ul><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="u6f267da4"><span class="ne-text">里面应该只有uploadedNum变量再vue组件中使用到了</span></li><li id="u7045ba9d"><span class="ne-text">iconType变量两者都有</span></li></ul></ul><hr id="XrhMr" class="ne-hr"><ul class="ne-tl"><li checked="true" id="uec0bdb16"><strong><span class="ne-text">uploadHandler.ts上传逻辑代码进行ts转换</span></strong><span class="ne-text">。并且将代码放到组件中</span></li></ul><p id="u138bcb53" class="ne-p"><span class="ne-text">在Home组件中，混合代码较多，其中，上传逻辑使用的是vue2.x的Minix混入方式，但是在vue3不再推荐该模式写代码，所以单独将上传逻辑js文件单独整理其逻辑，文件逻辑中，上传js代码和Home.vue组件两者相互又使用一些变量···</span></p><ul class="ne-ul"><li id="u121972f0"><span class="ne-text">上传js代码中有6处使用vue中的变量</span></li><li id="u94ae31fe"><span class="ne-text">vue中有2处使用js代码中变量</span></li></ul><div data-type="success" class="ne-alert"><p id="uccbb3b29" class="ne-p"><span class="ne-text">尝试方法1：因为两者多出混入变量使用，尝试将上传的ts代码全部放到Home组件中，虽然代码变长了，但是逻辑性提高了，先做出如下备份</span></p></div><h3 id="Dg53c"><span class="ne-text">vue3中不要命名冲突</span></h3><p id="u9e776dd7" class="ne-p"><span class="ne-text">会导致取值和预期取值不一样</span></p><p id="ub011d3d5" class="ne-p"><span class="ne-text">pagination对象类型，在首页的分页逻辑有误</span></p><p id="udba536aa" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1660899285052-ac9a2e6a-56f3-4a12-9b98-2d08b236aaf3.png" width="364" id="v8HpR" class="ne-image"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1660899292966-6f4b637e-1724-4691-9ea9-43073709682d.png" width="428" id="iFQc8" class="ne-image"></p><p id="u549774ab" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1661153296181-86029975-7753-4d85-b214-775ceba0d1cc.png" width="923" id="ude0118c7" class="ne-image"></p><p id="u8f10d885" class="ne-p"><br></p><h3 id="LqHwF"><span class="ne-text">vue3全局路由配置</span></h3><ul class="ne-ul"><li id="ua2ae1e5d"><span class="ne-text">vue3路由全局匹配</span></li></ul><p id="uf8affa74" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1661333780817-83937643-c4b9-43f0-ad47-6db7487230e6.png" width="536" id="f9d06" class="ne-image"></p><p id="uf09f5f1c" class="ne-p"><a href="https://blog.csdn.net/Boale_H/article/details/118526941" data-href="https://blog.csdn.net/Boale_H/article/details/118526941" class="ne-link"><span class="ne-text">vue3配置路由报错Catch all routes (“*“) must now be defined using a param with a custom regexp._Boale_H的博客-CSDN博客</span></a></p><h3 id="HSZos"><span class="ne-text">js/ts文件使用相应vue中函数</span></h3><ul class="ne-ul"><li id="u65257d16"><span class="ne-text">vue2：传递“this”：</span><a href="https://www.cnblogs.com/taohuaya/p/10765731.html" data-href="https://www.cnblogs.com/taohuaya/p/10765731.html" target="_blank" class="ne-link"><span class="ne-text">https://www.cnblogs.com/taohuaya/p/10765731.html</span></a></li><li id="u10603717"><span class="ne-text">但是vue3没有this，利用传参</span></li></ul><p id="u5d3f8e2c" class="ne-p"><br></p><h3 id="Dznst"><span class="ne-text">全局变量的使用</span></h3><p id="u7bad40cd" class="ne-p"><span class="ne-text">vue3注册全局变量失去响应性</span></p><ul class="ne-tl"><li checked="true" id="u30cdb9c2"><span class="ne-text">点击登录按钮，相应一个loading的状态，这个在之前项目中是利用全局注册的一个变量，vue3的全局注册变量方法</span></li></ul><ul class="ne-ul"><li id="u3074ce17"><a href="https://blog.csdn.net/weixin_43090018/article/details/117222606" data-href="https://blog.csdn.net/weixin_43090018/article/details/117222606" target="_blank" class="ne-link"><span class="ne-text">https://blog.csdn.net/weixin_43090018/article/details/117222606</span></a></li><li id="u585d358a"><a href="https://blog.csdn.net/XKFC1/article/details/123715354" data-href="https://blog.csdn.net/XKFC1/article/details/123715354" target="_blank" class="ne-link"><strong><span class="ne-text" style="text-decoration: underline">https://blog.csdn.net/XKFC1/article/details/123715354</span></strong></a></li><li id="u1c46c536"><a href="https://blog.csdn.net/Jkssns/article/details/117369556" data-href="https://blog.csdn.net/Jkssns/article/details/117369556" class="ne-link"><span class="ne-text">vue3 怎么创建全局的响应式对象 创建简单的vuex_最有才的河南大汉的博客-CSDN博客</span></a></li><li id="u696bccca"><strong><span class="ne-text">fetch文件中的axiosLoadingObj变量，在main.ts中注册为全局变量，Login.vue中使用，当fetch中axiosLoadingObj变量的值改变，Login.vue中使用该全局变量不会发生改变</span></strong><span class="ne-text">。</span></li></ul><ul class="ne-tl"><li checked="true" id="u88965f22"><strong><span class="ne-text">接口 - loading 的全局变量迁移</span></strong></li></ul><div class="ne-quote"><p id="u79d31fbe" class="ne-p"><span class="ne-text">不能使用v3全局变量api getCurrentInstance 不能响应式，同时打包情况下</span></p></div><p id="u07af8264" class="ne-p"><span class="ne-text">直接导入ts文件，在ts文件中做变量导出，</span></p><p id="udf2d3f0f" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1661412605610-41df1509-a29d-413c-b416-35df368c1ea1.png" width="299" id="CCoRo" class="ne-image"></p><h3 id="hGeeF"><span class="ne-text">v-if/else branches must use unique keys.vue(29)</span></h3><ul class="ne-ul"><li id="u461d521b"><span class="ne-text">官方解释：</span><a href="https://github.com/vuejs/core/issues/1712#issuecomment-665206103" data-href="https://github.com/vuejs/core/issues/1712#issuecomment-665206103" target="_blank" class="ne-link"><span class="ne-text">https://github.com/vuejs/core/issues/1712#issuecomment-665206103</span></a></li><li id="ub105d81b"><span class="ne-text">解决参考：</span><a href="https://blog.csdn.net/Fine_Cui/article/details/124906140" data-href="https://blog.csdn.net/Fine_Cui/article/details/124906140" target="_blank" class="ne-link"><span class="ne-text">https://blog.csdn.net/Fine_Cui/article/details/124906140</span></a></li></ul><pre><code>&lt;template v-for=&quot;(item, index) in fileList&quot;&gt;  &lt;a-menu-divider v-if=&quot;item.isDivider&quot; :key=&quot;index&quot; /&gt;  &lt;a-menu-item    v-else    :key=&quot;item.value&quot;    class=&quot;create-button-menu-item&quot;    @click=&quot;handleMenuClick(item.value)&quot;  &gt;</code></pre><p id="u083015aa" class="ne-p"><span class="ne-text">将第五行代码中的index换成item.value，一是因为index在这里并没有传值的实际作用，而是解决key值相同问题</span></p><h3 id="R4NI3"><span class="ne-text">具名插槽</span></h3><ul class="ne-ul"><li id="u256fd8ea"><span class="ne-text">vue3插槽使用方式和vue2不一样，不能使用template，而是slot标签，name属性</span></li><li id="u405399c1"><span class="ne-text">具名插槽在vue2和vue3两者使用有差别</span></li></ul><p id="u14e51d6f" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1661134037087-4a944237-fc24-4400-a575-94a6d16c45e9.png" width="362" id="u1dba96bd" class="ne-image"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1661134050262-d9d14d5e-0a75-4653-aada-bc4ed4ed049e.png" width="470" id="u57e5a561" class="ne-image"></p><h3 id="Dtowl"><span class="ne-text">注释导致页面不能渲染</span></h3><p id="ud619e2be" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1661131638426-cfc30116-2d9a-48bd-a012-4e35ba5e05b0.png" width="819" id="u65bae636" class="ne-image"></p><p id="u61297059" class="ne-p"><span class="ne-text">上述箭头所标注的地方不要有注释，有注释会渲染不出来</span></p><h3 id="lByqY"><span class="ne-text">样式只在当前页面有效</span></h3><p id="u9daaaa0e" class="ne-p"><span class="ne-text">组件中style标签后面加上</span><code class="ne-code"><span class="ne-text">scoped</span></code><span class="ne-text">就可以</span></p><pre><code>&lt;style lang=&quot;less&quot; scoped&gt;&lt;/style&gt;</code></pre><h3 id="NWJql"><span class="ne-text">vue2获取dom节点自定义属性值</span></h3><p id="u8c71347d" class="ne-p"><a href="https://blog.csdn.net/qq_41854017/article/details/79653096" data-href="https://blog.csdn.net/qq_41854017/article/details/79653096" class="ne-link"><span class="ne-text">vue如何获取自定义元素属性参数值_lotSeed_5的博客-CSDN博客_vue获取元素的属性值</span></a></p><h3 id="O8eIn"><span class="ne-text">根据dom属性来动态改变css</span></h3><p id="u10c84f23" class="ne-p"><span class="ne-text">当给dom添加自定义属性，vue2和vue3实际渲染出来的不一样（如果是标签自身属性，vue3和vue2是一样的）</span></p><ul class="ne-ul"><li id="uaf70c49a"><span class="ne-text">vue3</span></li></ul><pre><code>&lt;div :selected=&quot;true&quot;&gt;selected&lt;/div&gt;&lt;div :selected=&quot;false&quot;&gt;UnSlected&lt;/div&gt;</code></pre><p id="u188abf3d" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/webp/1484158/1662269390565-52d14982-b80a-441f-8c6c-db04807b1cf0.webp" width="301" id="u9cb11d77" class="ne-image"></p><ul class="ne-ul"><li id="ucd66fee6"><span class="ne-text">vue2</span></li></ul><pre><code>&lt;div :selected=&quot;true&quot;&gt;selected&lt;/div&gt;&lt;div :selected=&quot;false&quot;&gt;UnSlected&lt;/div&gt;</code></pre><p id="u74d0c552" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/webp/1484158/1662269414261-8fcbcd09-3ca9-4d1c-b4d1-9e04602285d3.webp" width="251" id="u7e5c48ec" class="ne-image"></p><ul class="ne-ul"><li id="u71487448"><span class="ne-text">根据以上不同，在css选择器使用有区别</span></li><li id="ua4cc1f9a"><span class="ne-text">vue3</span></li></ul><pre><code>//  vue3div[selected=true] &#123;  color: red;&#125;</code></pre><ul class="ne-ul"><li id="u0822b525"><span class="ne-text">vue2</span></li></ul><pre><code>// vue2div[selected] &#123;    color: red;&#125;</code></pre><h2 id="yT5Qx"><span class="ne-text">参考</span></h2><ul class="ne-ul"><li id="u9b3ec81f"><a href="https://segmentfault.com/a/1190000041849882" data-href="https://segmentfault.com/a/1190000041849882" target="_blank" class="ne-link"><span class="ne-text">Vue3.2 setup语法糖总结</span></a></li></ul></div>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
          <category> Vue </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Vue3实现一个类微信聊天界面</title>
      <link href="/blog/yx51zf/"/>
      <url>/blog/yx51zf/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><ul class="ne-ul"><li id="u2703b449"><span class="ne-text">编写一个类微信聊天界面要求除了常规功能外，顶部有一个系统状态栏，显示当前时间，精确到秒</span></li></ul><ul class="ne-ul"><li id="u8dda41c6"><span class="ne-text" style="color: rgb(36, 41, 47); font-size: 14px">其中icon使用了</span><a href="http://www.fontawesome.com.cn/get-started/" data-href="http://www.fontawesome.com.cn/get-started/" target="_blank" class="ne-link"><span class="ne-text">http://www.fontawesome.com.cn/get-started/</span></a><span class="ne-text" style="color: rgb(36, 41, 47); font-size: 14px"> UI库（下图未放icon）</span></li></ul><p id="u3dc031bb" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1658750105722-3d6a1954-d707-48bd-8fe4-377aefe9fba7.png" width="407.99310302734375" id="u144640ca" class="ne-image"></p><p id="u1119cc0b" class="ne-p"><span class="ne-text" style="color: rgb(36, 41, 47); font-size: 14px"></span></p><pre><code>&lt;template&gt;<pre><code>&amp;lt;div class=&amp;quot;box&amp;quot;&amp;gt;    &amp;lt;div class=&amp;quot;header&amp;quot;&amp;gt;        &amp;lt;div class=&amp;quot;status&amp;quot;&amp;gt;            &amp;lt;span&amp;gt;                &amp;lt;i class=&amp;quot;fa fa-wifi&amp;quot; aria-hidden=&amp;quot;true&amp;quot;&amp;gt;&amp;lt;/i&amp;gt;            &amp;lt;/span&amp;gt;            &amp;lt;span style=&amp;quot;float: right&amp;quot;&amp;gt;                &amp;lt;i class=&amp;quot;fa fa-battery-quarter&amp;quot; aria-hidden=&amp;quot;true&amp;quot;&amp;gt;&amp;lt;/i&amp;gt;                &#123;&#123;timer&#125;&#125;            &amp;lt;/span&amp;gt;        &amp;lt;/div&amp;gt;        &amp;lt;div class=&amp;quot;info&amp;quot;&amp;gt;            &amp;lt;span style=&amp;quot;float: left;margin-left: 5px;&amp;quot;&amp;gt;                &amp;lt;i class=&amp;quot;fa fa-chevron-left&amp;quot; aria-hidden=&amp;quot;true&amp;quot;&amp;gt;&amp;lt;/i&amp;gt;            &amp;lt;/span&amp;gt;            &amp;lt;span&amp;gt;群聊1&amp;lt;/span&amp;gt;            &amp;lt;span style=&amp;quot;float: right;margin-right: 5px;&amp;quot;&amp;gt;                &amp;lt;i class=&amp;quot;fa fa-ellipsis-h&amp;quot; aria-hidden=&amp;quot;true&amp;quot;&amp;gt;&amp;lt;/i&amp;gt;            &amp;lt;/span&amp;gt;        &amp;lt;/div&amp;gt;    &amp;lt;/div&amp;gt;    &amp;lt;div class=&amp;quot;content&amp;quot;&amp;gt;        &amp;lt;div v-for=&amp;quot;item, index in news_items&amp;quot; class=&amp;quot;new_box&amp;quot;&amp;gt;            &amp;lt;div v-if=&amp;quot;item.isMe === true&amp;quot; style=&amp;quot;width: 100%;text-align: right;&amp;quot;&amp;gt;                &amp;lt;div style=&amp;quot;display: inline-block;margin-left: 10px&amp;quot;&amp;gt;                    &amp;lt;div class=&amp;quot;new_box_detail&amp;quot;&amp;gt;&#123;&#123;item.content&#125;&#125;&amp;lt;/div&amp;gt;                &amp;lt;/div&amp;gt;                &amp;lt;img :src=&#39;item.avatar&#39; alt=&amp;quot;&amp;quot;&amp;gt;            &amp;lt;/div&amp;gt;            &amp;lt;div v-if=&amp;quot;item.isMe === false&amp;quot;&amp;gt;                &amp;lt;img :src=&#39;item.avatar&#39; alt=&amp;quot;&amp;quot;&amp;gt;                &amp;lt;div style=&amp;quot;display: inline-block;margin-left: 10px;&amp;quot;&amp;gt;                    &amp;lt;span&amp;gt;&#123;&#123;item.name&#125;&#125;&amp;lt;/span&amp;gt;                    &amp;lt;br&amp;gt;                    &amp;lt;div class=&amp;quot;new_box_detail&amp;quot;&amp;gt;&#123;&#123;item.content&#125;&#125;&amp;lt;/div&amp;gt;                &amp;lt;/div&amp;gt;            &amp;lt;/div&amp;gt;        &amp;lt;/div&amp;gt;    &amp;lt;/div&amp;gt;    &amp;lt;div class=&amp;quot;input_box&amp;quot;&amp;gt;        &amp;lt;i class=&amp;quot;fa fa-commenting fa-2x&amp;quot; aria-hidden=&amp;quot;true&amp;quot; style=&amp;quot;margin: 10px&amp;quot;&amp;gt;&amp;lt;/i&amp;gt;        &amp;lt;span&amp;gt;&amp;lt;input type=&amp;quot;text&amp;quot; name=&amp;quot;input_content&amp;quot; @keyup.enter=&amp;quot;enterKeyDown&amp;quot; v-model=&amp;quot;new_info&amp;quot;&amp;gt;&amp;lt;/span&amp;gt;        &amp;lt;i class=&amp;quot;fa fa-smile-o fa-2x&amp;quot; aria-hidden=&amp;quot;true&amp;quot; style=&amp;quot;margin-left: 10px&amp;quot;&amp;gt;&amp;lt;/i&amp;gt;        &amp;lt;i class=&amp;quot;fa fa-plus-circle fa-2x&amp;quot; aria-hidden=&amp;quot;true&amp;quot;  style=&amp;quot;margin-left: 10px&amp;quot;&amp;gt;&amp;lt;/i&amp;gt;    &amp;lt;/div&amp;gt;&amp;lt;/div&amp;gt;</code></pre><p>&lt;/template&gt;</p><p>&lt;script setup lang=&quot;ts&quot;&gt;<br>import { reactive, ref } from ‘vue’</p><p>interface NewsItemsInterface {<br>  id: number<br>  avatar: string<br>  isMe: boolean<br>  content: string<br>  name: string<br>}</p><p>let news_items: NewsItemsInterface[] = reactive([<br>  {<br>    id: 1,<br>    avatar: ‘<a href="https://npm.elemecdn.com/cdn-pictures@0.0.0/avatar/pic/MilkTea.png&#39;">https://npm.elemecdn.com/cdn-pictures@0.0.0/avatar/pic/MilkTea.png&#39;</a>,<br>    content: ‘用户1消息’,<br>    name: ‘小王’,<br>    isMe: false<br>  },<br>  {<br>    id: 2,<br>    avatar: ‘<a href="https://npm.elemecdn.com/cdn-pictures@0.0.0/avatar/pic/MilkTea.png&#39;">https://npm.elemecdn.com/cdn-pictures@0.0.0/avatar/pic/MilkTea.png&#39;</a>,<br>    content: ‘我的消息’,<br>    name: ‘小吴’,<br>    isMe: true<br>  },<br>  {<br>    id: 3,<br>    avatar: ‘<a href="https://npm.elemecdn.com/cdn-pictures@0.0.0/avatar/pic/MilkTea.png&#39;">https://npm.elemecdn.com/cdn-pictures@0.0.0/avatar/pic/MilkTea.png&#39;</a>,<br>    content: ‘用户2消息用户2消息用户2消息’,<br>    name: ‘小李’,<br>    isMe: false<br>  },<br>])</p><p>let timer = ref(‘’)<br>let new_info = ref(‘’)</p><p>const toDateYMDHMS = () =&gt; {<br>  const date = new Date()<br>  const h = date.getHours() &lt; 10 ? <code>0$&#123;date.getHours()&#125;:</code> : date.getHours() + ‘:’<br>  const m = date.getMinutes() &lt; 10 ? <code>0$&#123;date.getMinutes()&#125;:</code> : date.getMinutes() + ‘:’<br>  const s = date.getSeconds() &lt; 10 ? <code>0$&#123;date.getSeconds()&#125;</code> : date.getSeconds()</p><p>  return h + m + s<br>}</p><p>setInterval(() =&gt; {<br>    timer.value = toDateYMDHMS()<br>}, 1000)</p><p>const enterKeyDown = () =&gt; {<br>    news_items.push({<br>        id: 2,<br>        avatar: ‘<a href="https://npm.elemecdn.com/cdn-pictures@0.0.0/avatar/pic/MilkTea.png&#39;">https://npm.elemecdn.com/cdn-pictures@0.0.0/avatar/pic/MilkTea.png&#39;</a>,<br>        content: new_info.value,<br>        name: ‘小吴’,<br>        isMe: true<br>    })<br>    new_info.value = ‘’<br>}<br>&lt;/script&gt;</p><p>&lt;style scoped&gt;<br>.box {<br>    margin: 0 auto;<br>    height: 100%;<br>    width: 60vw;<br>    border: 1px rgb(0, 0, 0) solid;</p><p>}<br>/* ————————————————————————- <em>/<br>.header {<br>    height: 80px;<br>    /</em> border: 1px cyan solid; <em>/<br>    background-color: rgb(231, 231, 231);<br>}<br>.header .status {<br>    height: 30px;<br>    line-height: 30px;<br>    vertical-align: middle;<br>}<br>.header .info {<br>    height: 50px;<br>    line-height: 50px;<br>    text-align: center;<br>}<br>/</em> ————————————————————————- <em>/<br>.content {<br>    /</em> border: 1px red solid; <em>/<br>    background-color: rgb(164, 201, 201);<br>    height: 75vh<br>}<br>.content .new_box img {<br>    width: 30px;<br>}<br>.content .new_box_detail {<br>    background-color: rgb(255, 255, 255);<br>    padding: 5px;<br>}<br>/</em> ————————————————————————- <em>/<br>.input_box {<br>    /</em> border: 1px blueviolet solid; */<br>    height: 60px;<br>    line-height: 60px;<br>    background-color: rgb(231, 231, 231);<br>}<br>.input_box input {<br>    width: 70%;<br>    border: none;<br>    outline: none;<br>    height: 60%;<br>}<br>.input_box input:focus {<br>    outline: none;<br>}<br>&lt;/style&gt;</p><p></code></pre></p><p id="u02ce1c89" class="ne-p"><br></p></div>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
          <category> Vue </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Vue3实现一个ButtonGroup组件</title>
      <link href="/blog/he31vw/"/>
      <url>/blog/he31vw/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="u2eccf227" class="ne-p"><span class="ne-text">编写一个ButtonGroup组件要求支持 单选、多选</span></p><p id="ud689e7b4" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1658749703167-7b9db556-0f22-411b-8adb-8289b5725b76.png" width="607.4074503162137" id="u4982b92e" class="ne-image"></p><p id="u04fd3e7b" class="ne-p"><span class="ne-text"></span></p><pre><code>&lt;template&gt;&lt;div style=&quot;text-align: center&quot;&gt;  &lt;div&gt;    &lt;p&gt;选择butonGroup的单选/多选类型：&lt;/p&gt;    &lt;label&gt;单选&lt;input type=&quot;radio&quot; v-model=&quot;gender&quot; value=&quot;single&quot; @click=&quot;clickSingleMulti&quot;/&gt;&lt;/label&gt;    &lt;label&gt;多选&lt;input type=&quot;radio&quot; v-model=&quot;gender&quot; value=&quot;multi&quot; @click=&quot;clickSingleMulti&quot; /&gt;&lt;/label&gt;    &lt;p&gt;已选类型：&#123;&#123;gender === 'single' ? '单选' : gender === 'multi' ? '多选' : ''&#125;&#125;&lt;/p&gt;  &lt;/div&gt;  &lt;hr&gt;  &lt;div v-for=&quot;item, index in button_items&quot;&gt;    &lt;button @click=&quot;clickFun(item, $event)&quot; :selected='item.select' :disabled=&quot;gender === ''&quot;&gt;      &#123;&#123;item.title&#125;&#125;    &lt;/button&gt;  &lt;/div&gt;&lt;/div&gt;<p>&lt;/template&gt;</p><p>&lt;script setup lang=&quot;ts&quot;&gt;<br>import &#123; reactive, ref &#125; from ‘vue’</p><p>interface ButtonItemsInterface &#123;<br>  id: number<br>  title: string<br>  select: boolean<br>&#125;</p><p>let button_items: ButtonItemsInterface[] = reactive([<br>  &#123;<br>    id: 1,<br>    title: ‘选项1’,<br>    select: false<br>  &#125;,<br>  &#123;<br>    id: 2,<br>    title: ‘选项2’,<br>    select: false<br>  &#125;,<br>  &#123;<br>    id: 3,<br>    title: ‘选项3’,<br>    select: false<br>  &#125;,<br>])<br>let result: any[] = reactive([])<br>let gender = ref(‘’)<br>// 置空函数，当切换单选多选，置空result数组<br>const clickSingleMulti = () =&gt; &#123;<br>  result = []<br>&#125;<br>const clickFun = (item: any, e: any) =&gt; &#123;<br>  if (gender.value === ‘multi’) &#123;<br>    if (e.target.getAttribute(‘selected’) === ‘true’) &#123;<br>        // 被选中<br>        let index = result.indexOf(item.id)<br>        if (index &gt; -1) &#123;<br>            result.splice(index,1);<br>        &#125;<br>    &#125; else &#123;<br>        // 未被选中<br>        result.push(item.id)<br>    &#125;<br>    item.select = !item.select<br>    console.log(‘单选选择的结果：’, result)<br>  &#125; else &#123;<br>    result = []<br>    result.push(item.id)<br>    console.log(‘多选选择的结果：’, result)<br>  &#125;</p><p>&#125;<br>&lt;/script&gt;</p><p>&lt;style scoped&gt;<br>button[selected=true] &#123;<br>    color: red;<br>&#125;<br>&lt;/style&gt;<br></code></pre></p></div>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
          <category> Vue </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Nodejs三方模块使用汇总</title>
      <link href="/blog/gf5tiw/"/>
      <url>/blog/gf5tiw/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/1484158/1665070666704-a55506d2-ea9e-4b25-b3f9-ecf371d0d453.jpeg" id="rnRA9" style="display: block; width: 100%"><p id="ub4dba476" class="ne-p"><span class="ne-text"></span></p><p id="u4f377b7d" class="ne-p"><span class="ne-text">前言：第三方模块的两种存在形式</span></p><ol class="ne-ol"><li id="uea902046" data-lake-index-type="0"><span class="ne-text">以js文件的形式存在，提供实现项目具体功能的API接口。比如使用jQuery，html中引入CDN超链接即可使用。</span></li><li id="ued707d01" data-lake-index-type="0"><span class="ne-text">以命令行工具形式存在，辅助项目开发。</span></li></ol><p id="u7246d05b" class="ne-p"><span class="ne-text">比如VUE-CLI工具。</span></p><div class="ne-quote"><p id="u9fdfbea6" class="ne-p"><span class="ne-text">npm是用来管理模块的一个node工具，它会伴随着node的下载而一同下载。</span></p></div><p id="ufbcd196a" class="ne-p"><br></p><p id="u886c8835" class="ne-p"><span class="ne-text">node生态的繁荣多益于很多优秀的三方模块的存在，具体可以查看 </span><a href="https://nodersurvey.github.io/reporters/index.html" data-href="https://nodersurvey.github.io/reporters/index.html" target="_blank" class="ne-link"><span class="ne-text">NoderSurvey 2021 年度报告</span></a><span class="ne-text"> 的相关统计与调研。在此记录一下在学习以及实际开发过程中自己所学习到的三方模块，特别地，express三方模块是一个web应用框架，需要学习的点较多，单独拿出来详细学习。</span></p><h3 id="svJmx"><span class="ne-text">cnpm</span></h3><p id="u527ed771" class="ne-p"><span class="ne-text">因为npm是处于国外的服务器，下载模块有时候可能会较慢，特别是文件比较多的模块。</span></p><ol class="ne-ol"><li id="u0d1cf399" data-lake-index-type="0"><span class="ne-text">方法1: 临时使用淘宝镜像下载的命令。</span></li></ol><pre><code><code>npm install --registry https://registry.npm.taobao.org</code></code></pre><ol start="2" class="ne-ol"><li id="ua2dd3b59" data-lake-index-type="0"><span class="ne-text">方法2: 更改npm镜像下载源</span></li></ol><pre><code><code># 配置镜像源npm config set registry https://registry.npmmirror.com# 下载npm i<p>######################################################</p><h1 id="解除镜像源"><a href="#解除镜像源" class="headerlink" title="解除镜像源"></a>解除镜像源</h1><p>npm config set registry <a href="https://registry.npmjs.org/">https://registry.npmjs.org/</a></p><h1 id="其他包管理也是一样"><a href="#其他包管理也是一样" class="headerlink" title="其他包管理也是一样"></a>其他包管理也是一样</h1><p>npm config set registry <a href="https://registry.npmmirror.com/">https://registry.npmmirror.com</a><br>yarn config set registry <a href="https://registry.npmmirror.com/">https://registry.npmmirror.com</a><br>pnpm config set registry <a href="https://registry.npmmirror.com/">https://registry.npmmirror.com</a></code><br></code></pre></p><ol start="3" class="ne-ol"><li id="u2ac17d18" data-lake-index-type="0"><span class="ne-text">方法3: 如果不想改变npm镜像源，可以使用cnpm</span><span class="ne-text" style="color: #DF2A3F">（推荐）</span></li></ol><pre><code><code>// download cnpmnpm install -g cnpm --registry=https://registry.npm.taobao.org<p>cnpm install</code><br></code></pre></p><hr id="kT7dF" class="ne-hr"><p id="u7e1b43a6" class="ne-p"><span class="ne-text">查看镜像源</span></p><pre><code><code>npm config get registrypnpm config get registrycnpm config get registry</code></code></pre><p id="u5cb64146" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2023/png/1484158/1693721898134-21b4ba2b-4179-4cfb-9502-3b63cacd9902.png" width="374.81484129268796" id="u68a62934" class="ne-image"></p><h3 id="ezaPQ"><span class="ne-text">nodemon</span></h3><pre><code><code>cnpm install nodemon –g</code></code></pre><p id="77b64508eb62a74429490cc85bb3d580" class="ne-p"><span class="ne-text">作用：在开发过程中，修改了文件，控制台命令行就会根据文件的修改自动运行</span></p><p id="d7ebe048620778843516822109d90a9e" class="ne-p"><span class="ne-text">使用方法：将运行命令中的node换成nodemon</span></p><h3 id="TqQTy"><span class="ne-text">gulp</span></h3><p id="1ac1057d577258f93e05b60382bfbee0" class="ne-p"><span class="ne-text">基于node平台开发的前端构建工具，将机械化操作编写成任务，想要执行机械化操作时执行一个命令行命令任务就能自动执行了，用机器代替手工，提高开发效率。</span></p><p id="ude5bb27b" class="ne-p"><span class="ne-text">具体的还有webpack，后续继续学习。</span></p><p id="9710a896a46943e194f42cee882559a2" class="ne-p"><br></p><p id="5ce68255f05a334bfc100c5fc86e9095" class="ne-p"><span class="ne-text">作用：</span></p><ul class="ne-ul"><li id="b8c516f632c3ccb2822f0eade960b320" data-lake-index-type="0"><span class="ne-text">项目上线，HTML、CSS、JS文件压缩合并</span></li><li id="6729897eaa4fff1e51427e6ab63ebe1a" data-lake-index-type="0"><span class="ne-text">语法转换（es6、less ...）</span></li><li id="ce83ec1bfaf4a135a60a2037cb367500" data-lake-index-type="0"><span class="ne-text">公共文件抽离</span></li><li id="8eb5fa1547b0b864f5385548a15c90f2" data-lake-index-type="0"><span class="ne-text">修改文件浏览器自动刷新</span></li></ul><p id="058615d0670c54f7b034065dfebd2c95" class="ne-p"><br></p><p id="2227bf834848ccf297622d3c5527848c" class="ne-p"><span class="ne-text">glup本身提供的api函数很少，官网到目前更新只有下面几个，具体使用方法，使用的时候去查</span></p><ul class="ne-ul"><li id="53491b21545dab643185de554b201e55" data-lake-index-type="0"><a href="https://github.com/gulpjs/gulp" data-href="https://github.com/gulpjs/gulp" target="_blank" class="ne-link"><span class="ne-text">https://github.com/gulpjs/gulp</span></a></li><li id="dd1aff95a8401b1918ac05a8549b6a9a" data-lake-index-type="0"><a href="https://gulpjs.com/docs/en/getting-started/quick-start" data-href="https://gulpjs.com/docs/en/getting-started/quick-start" target="_blank" class="ne-link"><span class="ne-text">https://gulpjs.com/docs/en/getting-started/quick-start</span></a><span class="ne-text"></span></li></ul><p id="1c646168bbaefd2634c677af0e29a0ba" class="ne-p"><br></p><p id="7a8349872f1c8ff64f06aacdd754bbab" class="ne-p"><span class="ne-text">gulp生态也有很多插件，根据插件下载相应需要的功能插件</span></p><ul class="ne-ul"><li id="2b6d96e782679dd6a14e43de42a2efe2" data-lake-index-type="0"><span class="ne-text">gulp-htmlmin ：html文件压缩</span></li><li id="2fb6cabb8d39f31b4ec63f466092027f" data-lake-index-type="0"><span class="ne-text">gulp-csso ：压缩css</span></li><li id="2590af36e2d20fc8af4017d8c8423ed8" data-lake-index-type="0"><span class="ne-text">gulp-babel ：JavaScript语法转化</span></li><li id="75ace6bedd13bf4569184a59c9a86e72" data-lake-index-type="0"><span class="ne-text">gulp-less: less语法转化</span></li><li id="37aa37302d2cda9ca969b28e81fcbbed" data-lake-index-type="0"><span class="ne-text">gulp-uglify ：压缩混淆JavaScript</span></li><li id="44d0eb8f741da42560a8e881421cf825" data-lake-index-type="0"><span class="ne-text">gulp-file-include 公共文件包含</span></li><li id="11764dcc7c9f1857a65577cb328be98b" data-lake-index-type="0"><span class="ne-text">browsersync 浏览器实时同步</span></li></ul><h3 id="m5eli"><span class="ne-text">cross-env</span></h3><p id="u9e9a3659" class="ne-p"><span class="ne-text">windows不支持NODE_ENV=development的设置方式</span></p><p id="u447e7abf" class="ne-p"><span class="ne-text">所以使用该模块来进行跨平台地使用环境变量，兼容各平台使用</span></p><h3 id="lbsH2"><span class="ne-text">sharedb</span></h3><p id="u936c3000" class="ne-p"><span class="ne-text">ShareDB 是一个整合了前后端的 OT 框架，可以很方便地自行搭建服务端和客户端。框架基于 Node.JS 实现。</span></p><p id="uda193c76" class="ne-p"><br></p><div class="ne-quote"><p id="u3f3ccd7e" class="ne-p"><span class="ne-text">OT（Operational transformation）是一种支持高级协作软件系统中的一系列协作功能的技术。OT 最初是为了在纯文本文档的协作编辑中实现一致性维护和并发控制而发明的。它的功能已得到扩展，其应用程序已扩展至包括组撤消、锁定、冲突解决、操作通知和压缩、组感知、HTML/XML 和树状结构文档编辑、协作办公生产力工具、应用程序共享和协作计算机- 辅助媒体设计工具。[1] 2009 年，OT 被采用为Apache Wave协作功能背后的核心技术和谷歌文档。</span></p></div><h3 id="mjgBJ"><span class="ne-text">sharedb-mongo</span></h3><h3 id="g4QEg"><span class="ne-text">uuid</span></h3><p id="uda44248d" class="ne-p"><span class="ne-text">生成唯一的一个字符串</span></p><ul class="ne-ul"><li id="u017203c1" data-lake-index-type="0"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">v3：基于名字的 用相同的名字，会生成相同的uuid出来</span></li></ul><p id="ud4e0d654" class="ne-p"><a href="https://juejin.cn/post/6844903708799533064" data-href="https://juejin.cn/post/6844903708799533064" target="_blank" class="ne-link"><span class="ne-text">npm的node-uuid和uuid</span></a></p><ul class="ne-ul"><li id="u73a40e55" data-lake-index-type="0"><span class="ne-text">官网配置教程：</span><a href="https://editor.aomao.com/zh-CN/config/ot#%E5%8D%8F%E5%90%8C%E6%95%B0%E6%8D%AE" data-href="https://editor.aomao.com/zh-CN/config/ot#%E5%8D%8F%E5%90%8C%E6%95%B0%E6%8D%AE" target="_blank" class="ne-link"><span class="ne-text">https://editor.aomao.com/zh-CN/config/ot</span></a></li><li id="u2be25db8" data-lake-index-type="0"><span class="ne-text">运行方式：将</span><code class="ne-code"><span class="ne-text">ot-server</span></code><span class="ne-text">文件夹复制到项目根目录，将其处于运行状态，然后再运行主项目（localhost实质上就是指向127.0.0.1这个本地IP地址。）</span></li></ul><h3 id="sHnMR"><span class="ne-text">nanoid</span></h3><p id="u2972908b" class="ne-p"><span class="ne-text">因为uuid生成的字符串太长，不便于作为url路径使用，所以使用nanoid来作为随机url路径</span></p><ul class="ne-ul"><li id="ueb682cd3" data-lake-index-type="0"><a href="https://www.npmjs.com/package/nanoid" data-href="https://www.npmjs.com/package/nanoid" target="_blank" class="ne-link"><span class="ne-text">https://www.npmjs.com/package/nanoid</span></a></li><li id="u5b5164c2" data-lake-index-type="0"><a href="https://github.com/ai/nanoid/blob/HEAD/README.zh-CN.md" data-href="https://github.com/ai/nanoid/blob/HEAD/README.zh-CN.md" target="_blank" class="ne-link"><span class="ne-text">https://github.com/ai/nanoid/blob/HEAD/README.zh-CN.md</span></a></li></ul><h3 id="hccPV"><span class="ne-text">mkdirp</span></h3><ul class="ne-ul"><li id="u789c19b4" data-lake-index-type="0"><a href="https://www.npmjs.com/package/mkdirp" data-href="https://www.npmjs.com/package/mkdirp" class="ne-link"><span class="ne-text">mkdirp</span></a></li></ul><pre><code><code>const mkdirp = require('mkdirp') <p>// return value is a Promise resolving to the first directory created<br>mkdirp(‘/tmp/foo/bar/baz’).then(made =&gt;<br>  console.log(<code>made directories, starting with $&#123;made&#125;</code>))</code><br></code></pre></p><h3 id="rwQV9"><span class="ne-text">ws</span></h3><p id="u87a52cc2" class="ne-p"><span class="ne-text">详见： </span><a href="https://www.wztlink1013.com/blog/wwclae" data-href="https://www.wztlink1013.com/blog/wwclae" target="_blank" class="ne-link"><span class="ne-text">https://www.wztlink1013.com/blog/wwclae</span></a></p><h3 id="fssxg"><span class="ne-text">lodash</span></h3><pre><code><code>npm i @types/lodash</code></code></pre><h3 id="mBf2c"><span class="ne-text">clipboard</span></h3><ul class="ne-tl"><li checked="true" id="u68f99f23" data-lake-index-type="0"><a href="https://blog.csdn.net/weixin_44440116/article/details/115398717" data-href="https://blog.csdn.net/weixin_44440116/article/details/115398717" class="ne-link"><span class="ne-text">vue3使用clipboard进行复制_weixin_44440116的博客-CSDN博客</span></a></li></ul><h3 id="AdFwE"><span class="ne-text">vueuse</span></h3><pre><code><code>&lt;template&gt;  &lt;h3&gt;Mouse: &#123;&#123; x &#125;&#125; x &#123;&#123; y &#125;&#125;&lt;/h3&gt;&lt;/template&gt;<p>&lt;script lang=&quot;ts&quot;&gt;<br>  import &#123; defineComponent &#125; from ‘vue’;<br>  import &#123; useMouse &#125; from ‘@vueuse/core’;</p><p>  export default defineComponent(&#123;<br>    name: ‘VueUse’,<br>    setup() &#123;<br>      const &#123; x, y &#125; = useMouse();</p><pre><code>  return &#123;    x,    y  &#125;;&#125;</code></pre><p>  });<br>&lt;/script&gt;<br></code><br></code></pre></p><h3 id="sMDSa"><span class="ne-text">js-base64</span></h3><pre><code><code>pnpm install --save js-base64</code></code></pre><h3 id="KY5LM"><span class="ne-text">moment</span></h3><h3 id="KGuSf"><span class="ne-text">html2canvas</span></h3></div>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
          <category> Node.js </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>辣椒炒莲藕</title>
      <link href="/essay/fi4c0o/"/>
      <url>/essay/fi4c0o/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="uff4b105c" class="ne-p" style="text-align: center"><span class="ne-text">辣椒炒莲藕</span></p><p id="u4b0dd2cb" class="ne-p" style="text-align: center"><span class="ne-text"></span></p><p id="ubd73c524" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/1484158/1656819779743-aa355d3d-1fc6-454d-bebc-9f0178742cc7.jpeg" width="2736" id="ued5f21b8" class="ne-image"></p></div>]]></content>
      
      
      <categories>
          
          <category> 料理 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>辣椒炒平菇</title>
      <link href="/essay/cgp1qa/"/>
      <url>/essay/cgp1qa/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="ue9535782" class="ne-p" style="text-align: center"><span class="ne-text">辣椒炒平菇</span></p><p id="u45e432fb" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/1484158/1656819580848-fd5bd076-3c27-42ea-a245-7b61b3aaf83c.jpeg" width="2736" id="u739306bc" class="ne-image"></p></div>]]></content>
      
      
      <categories>
          
          <category> 料理 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>鸡蛋水煮面</title>
      <link href="/essay/zky9eg/"/>
      <url>/essay/zky9eg/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="u0fecea96" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/1484158/1656818758889-aaba7431-98fc-4cb0-b052-40ac338b3034.jpeg" width="431" id="QLQYX" class="ne-image"></p><p id="u9b997641" class="ne-p"><span class="ne-text">步骤：</span></p><ol class="ne-ol"><li id="u61a3cb19"><span class="ne-text">准备好配菜并切好：辣椒，葱，青菜</span></li><li id="ucfb13558"><span class="ne-text">烧水至开始沸腾，然后放入面条，然后把水单独倒掉，面条放入篮中</span></li><li id="ua55b3d2a"><span class="ne-text">锅里面放油烧一会，然后把配菜放进去，然后再舀点水进去，等烧一会再打个鸡蛋进去</span></li><li id="uf69d0f04"><span class="ne-text">将静置的面条下到锅中</span></li></ol><hr id="ifHkB" class="ne-hr"><p id="ucf63efa0" class="ne-p"><span class="ne-text">常规简单煮面做法：</span></p><ol class="ne-ol"><li id="uba305f7e"><span class="ne-text">烧水至开始沸腾</span></li><li id="u769deb35"><span class="ne-text">放入挂面，用筷子搅拌，以免面条结巴</span></li><li id="u8e051295"><span class="ne-text">待水重新沸腾后，加入料理搅拌均匀 </span></li></ol><div class="ne-quote"><p id="ua2fac9fa" class="ne-p"><span class="ne-text">青菜、盐等</span></p></div><ol start="4" class="ne-ol"><li id="ud46318df"><span class="ne-text">小火静置一会即可</span></li></ol><p id="u78b8f5c7" class="ne-p"><br></p></div>]]></content>
      
      
      <categories>
          
          <category> 料理 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>《山茶文具店》小记</title>
      <link href="/essay/tegfte/"/>
      <url>/essay/tegfte/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="u3a5582c3" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/1484158/1653571677209-7e72abde-e202-4913-b4fc-4e89285d0779.jpeg" width="270" id="u836fe5f8" class="ne-image"></p><p id="u063179c3" class="ne-p"><span class="ne-text">前言：书中的代笔文字还有文具店在四季所渲染的氛围，很能让人安静下来。另外很多场景都像是自己以前读书，独自的对生活感悟的别种形式的外露……</span></p><h2 id="d4b37c9f"><span class="ne-text">夏</span></h2><p id="u3dd36323" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/1484158/1653570370540-3d102396-6f1f-45ca-a7dd-5951a5c05a4d.jpeg" width="401.9907531738281" id="flM7L" class="ne-image"><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/1484158/1653570419276-697b6192-1806-4de2-9667-0743f020a122.jpeg" width="398.98614501953125" id="uf11d2c4e" class="ne-image"></p><p id="ua5387e97" class="ne-p"><span class="ne-text">真诚且坦诚……</span></p><p id="u6eea89c6" class="ne-p"><span class="ne-text"></span></p><div class="ne-quote"><p id="ufad10353" class="ne-p"><span class="ne-text">夏日的夕阳把门外的巷子染成一片橘色。</span></p></div><p id="u3065b135" class="ne-p"><span class="ne-text"></span></p><div class="ne-quote"><p id="u8cbd818a" class="ne-p"><span class="ne-text">夏蝉在白天聒噪地叫个不停，入夜后便安静下来，四周一片寂静，简直就像身处深山秘境，只不过仍然闷热不已。</span></p></div><p id="u4a900465" class="ne-p"><span class="ne-text"></span></p><div class="ne-quote"><p id="u043208f1" class="ne-p"><span class="ne-text">“因为我自己写的话，一下子就会看出是小孩子写的。我只要让老师知道我的心意就好。婆婆告诉我，这里的阿嬷可以帮人写很出色的信。”</span></p></div><p id="ud0ecec50" class="ne-p"><span class="ne-text"></span></p><div class="ne-quote"><p id="uf00df4c8" class="ne-p"><span class="ne-text">“她为我写了一封打动我老公的情书，所以我们才会结婚哦。”</span></p></div><p id="u571e3bcf" class="ne-p"><span class="ne-text">文字的浪漫……以至于我现在就想去二餐打印店买一纸山师信封，书写起浪漫情话……</span></p><p id="ucee381b6" class="ne-p"><span class="ne-text"></span></p><div class="ne-quote"><p id="uece9be26" class="ne-p"><span class="ne-text">我忍不住冷静思考，为什么在这么热的天气里，我还要刻苦练习这些自己根本不喜欢的书法？打从出生起便一直闷在内心的愤怒和疑问，就像岩浆般一口气喷了出来，就连我自己也无法阻止。</span></p></div><p id="ufe7f8245" class="ne-p"><br></p><p id="u8f507211" class="ne-p"><span class="ne-text">桀</span></p><div class="ne-quote"><p id="u404df461" class="ne-p"><span class="ne-text">敬致关爱我们的各位：夏阳高照的季节来临，镰仓的绿意也更加蓬勃。不知各位是否别来无恙？在鹤冈八幡宫举行婚礼至今，转眼已过十五载，不禁感叹时光流逝如此匆匆。能在各位的见证下，于樱花飘舞的庄严气氛中共结连理，堪称人生之大幸。平日，我们各自努力工作；假日，则常偕同前往海边或山野健行。生活虽然平淡，但夫妻共同享受了日常的平凡幸福，我们都希望能随着岁月的累积，加深彼此的理解和情感。虽然我们无缘得子，但也因此邂逅了爱犬汉娜，我们视她如己出，疼爱有加。回想起来，带着汉娜一起去冲绳旅行的时光，是我们一家人无可取代的美好回忆。此次提笔，是为了向各位报告一件遗憾的事：我们在七月底解除了夫妻关系，正式离婚。虽然我们花费很长时间沟通，摸索是否能找到继续相处的方法；也曾请亲密的友人提供协助，努力寻求最完善的方式，希望走向圆满的结局。但是，前妻希望能与新的伴侣共度未来的人生，无悔活出自我的意志也相当坚定。最后，我们决定分道扬镳，各奔前程。虽然我们无法携手相伴到白头，但仍将默默支持彼此的第二人生。因此，如蒙各位认为我们为了追求幸福的人生，做出富有勇气的决定，我们将深感万幸。各位温暖地守护我们夫妻，如今却辜负了各位的期待，为此着实深感痛苦。衷心感谢各位至今为止的亲切和关爱，有幸和各位结缘，带给我们莫大的鼓励和安慰。虽然我们决定迈向不同的人生，但仍希望能够维持与各位之间的缘分，这也是我们的共同心愿。希望有朝一日，能笑着谈论今天。满怀感恩之心。敬颂崇祺</span></p></div><p id="uda19d251" class="ne-p"><span class="ne-text"></span></p><h2 id="fdf31ff3"><span class="ne-text">秋</span></h2><div class="ne-quote"><p id="uc7781e82" class="ne-p"><span class="ne-text">最近的天空已经有了秋天的味道。山茶文具店也到了差不多该使用火炉的时候，否则太冷了。</span></p></div><p id="ue2c6964c" class="ne-p"><br></p><p id="uc97892b1" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/1484158/1653571236427-fb03c188-941e-4200-a318-c0bb40656720.jpeg" width="366" id="u6ce68298" class="ne-image"></p><p id="u3bd18e88" class="ne-p"><span class="ne-text">作为曾经许诺的对象，我想看到这的反应不是遗憾，反而是喜极而泣……</span></p><p id="u5420a3bc" class="ne-p"><br></p><div class="ne-quote"><p id="u6430457b" class="ne-p"><span class="ne-text">用几乎快超出信封的大字写得很有气势。</span></p></div><p id="uc42d71d4" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/1484158/1653571439352-fa11a7d7-e50a-4a87-b775-b5254b726155.jpeg" width="430" id="u95115f11" class="ne-image"></p><p id="u972f33e4" class="ne-p"><span class="ne-text">这个手写正楷字真的好看。</span></p><p id="ua3614e66" class="ne-p"><br></p><p id="u5b5ed240" class="ne-p"><span class="ne-text">读书期间，写字最好看的往往不是学习最好的，而学习极好的同学，反而写的字，不怎么样。。</span></p><div class="ne-quote"><p id="uad2e3e8d" class="ne-p"><span class="ne-text">我一直以为，字能够反映书写者的人品，但这种认识并不正确。有不少人像花莲小姐一样，即使下了苦功，仍然无法写出漂亮的字。如果认为因为心丑才会字丑，未免太武断了。</span></p></div><p id="uad196e47" class="ne-p"><span class="ne-text"></span></p><p id="u398430bf" class="ne-p"><span class="ne-text">代笔这个职业，突然让我想到日本很多影视里面神女这一角色，千恋万花</span></p><div class="ne-quote"><p id="u7ab224f9" class="ne-p"><span class="ne-text">接着用右手轻轻握住花莲小姐的右手，闭着眼睛，像深呼吸般在卡片上写字。</span></p><p id="u1c2fa90c" class="ne-p"><span class="ne-text">当我缓缓睁开眼睛时，发现卡片上的字很陌生，简直不像出自我的手。决定用圆珠笔写这张卡片是正确的决定，从这些文字中，可以感受到花莲小姐的恭谨有礼和纯洁。我把写好的卡片装进信封。</span></p><p id="ud5a18a74" class="ne-p"><span class="ne-text">晚上七点多，花莲小姐再度来到山茶文具店。看起来质料很好的深蓝色大衣和白色围巾在她身上很好看。</span></p><p id="uaf2136af" class="ne-p"><span class="ne-text">“我呈现了这样的感觉……”</span></p><p id="ub5723d0e" class="ne-p"><span class="ne-text">我战战兢兢地递上卡片。花莲小姐一看到卡片，立刻欢呼起来。</span></p><p id="u9bcc617e" class="ne-p"><span class="ne-text">“简直就像我自己写的！谢谢你！”</span></p><p id="u9c7d60e4" class="ne-p"><span class="ne-text">她像少女般兴奋不已。</span></p></div><p id="u115ee3ee" class="ne-p"><span class="ne-text"></span></p><p id="uf6346e17" class="ne-p"><span class="ne-text">这就是典型的“少女字体”了，我影响里面，初中我的后桌还有高中一同学写的字就是这类型的</span></p><div class="ne-quote"><p id="uc27297e0" class="ne-p"><span class="ne-text">“我一直想写这样的字。”</span></p></div><p id="ua2fcc069" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1653622953005-24a78b92-4ed4-477d-8d79-8ce1638244e6.png" width="329.7750244140625" id="u2e939874" class="ne-image"></p><h2 id="w6g2f"><span class="ne-text">冬</span></h2><p id="ua012243b" class="ne-p"><span class="ne-text"></span></p><p id="udb726e07" class="ne-p"><span class="ne-text">等到以后，我的小屋门外也要种一棵大树</span></p><p id="u5cb3a4cf" class="ne-p"><span class="ne-text"></span></p><div class="ne-quote"><p id="ud0e61f16" class="ne-p"><span class="ne-text">据说山茶文具店门口的那棵山茶树，是用由比若宫的山茶树树枝扦插而来的。不知道是上代还是上上代，把被台风吹断的树枝带回家，试着种在家门口，没想到它竟牢牢地扎了根、长成了大树。</span></p></div><p id="u64cfecf6" class="ne-p"><span class="ne-text"></span></p><p id="uc3b64e45" class="ne-p"><span class="ne-text">她深深地爱着她父亲，激动且神秘……</span></p><div class="ne-quote"><p id="u80343284" class="ne-p"><span class="ne-text">“所以她吵着要回去。看到她那样，我真的很难过，忍不住想象她总是背着年纪还小的我们去查看信箱的样子。我猜那是无法让我们姐弟看到的、秘密的爱。”</span></p></div><p id="ud98031d1" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1653626050743-85c10c68-abc6-4c21-9f53-bc5a8943e3a9.png" width="356.8125" id="VWBdz" class="ne-image"></p><p id="u3e327b4b" class="ne-p"><span class="ne-text">人会成长，所写出的字也会有所成长，虽然不好说这个成长是朝着好的还是邋遢的，但，总归是成长</span></p><div class="ne-quote"><p id="u3365484e" class="ne-p"><span class="ne-text">一个人写的字会随着年岁增长渐渐成熟。即便是同一个人，小学时写的字，和高中时写的字当然不一样；二十多岁时所写的字，和四十多岁时所写的字也不一样。到了七八十岁，差异就更大了。就算是十几岁时写字圆滚滚的少女，变成老太太之后，当然也不会再写那样的字。文字，也会随着年龄变化。</span></p></div><p id="u880ec97e" class="ne-p"><br></p><h2 id="MhZg1"><span class="ne-text">春</span></h2><p id="u8b33dafe" class="ne-p"><span class="ne-text"></span></p><p id="u9b3d697b" class="ne-p"><span class="ne-text">代笔</span></p><div class="ne-quote"><p id="ud8f8688c" class="ne-p"><span class="ne-text">但我内心很犹豫，觉得是否该拒绝这个委托。代笔工作是为了协助他人得到幸福，这是我身为代笔人的坚持。更何况，有必要写伤害对方的信吗？然而，工作就是工作。从另一个角度思考，代笔人这份工作并不是做义工，眼前这位匿名小姐是客人，只要她高兴，那又何妨呢？两种完全相反的想法在内心天人交战，发出咔嚓咔嚓的声音。</span></p></div><p id="u0fdcb288" class="ne-p"><span class="ne-text"></span></p><p id="ubd9d6186" class="ne-p"><span class="ne-text">失去的是妻子，后悔所说过的话，可是，庆幸的是女儿还在身旁，妻子已不再人世……</span></p><div class="ne-quote"><p id="udef19c2b" class="ne-p"><span class="ne-text">“与其苦苦追寻失去的东西，还不如好好珍惜自己眼前拥有的东西。”</span></p></div><p id="u5b75b5c3" class="ne-p"><span class="ne-text"></span></p><p id="u2b1cf01e" class="ne-p"><span class="ne-text">这个场景，和《世界上所有的夜晚》文末那个夜晚是同样的，夜景一样，思绪一样……</span></p><div class="ne-quote"><p id="ue38e9ff0" class="ne-p"><span class="ne-text">小小的亮光穿越黑暗。是萤火虫。没错，每年都有萤火虫在这条河边飞舞。许多人都站在小桥上看萤火虫。</span></p></div><p id="u943d789c" class="ne-p"><span class="ne-text"></span></p><p id="u90fb3804" class="ne-p"><span class="ne-text"></span></p></div>]]></content>
      
      
      <categories>
          
          <category> 阅读 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript事件循环和异步编程</title>
      <link href="/blog/lz7xgx/"/>
      <url>/blog/lz7xgx/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="u47c8e8b4" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1653573417541-44275572-06ee-41fc-ab54-6683e2510450.png" width="1960" id="ude4d9e36" class="ne-image"></p><h2 id="bAXj8"><span class="ne-text">一、JS代码执行机制</span></h2><h3 id="YbZ5l"><span class="ne-text">JavaScript的单线程</span></h3><p id="b785073ad0b4241b17542f923c68bd89" class="ne-p"><span class="ne-text">单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。如果前一个任务耗时很长，后一个任务就不得不一直等着。这样所导致的问题是： 如果 JS 执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞的感觉。</span></p><h3 id="IF7ut"><span class="ne-text">同步任务和异步任务</span></h3><p id="175d9c82a2892ec08ad8c92559dfbb4e" class="ne-p"><span class="ne-text">单线程导致的问题就是后面的任务等待前面任务完成，如果前面任务很耗时（比如读取网络数据），后面任务不得不一直等待！！</span></p><p id="7c83c84c2c296316bc3f3c1cf7756e53" class="ne-p"><span class="ne-text" style="color: #F5222D">为了解决这个问题，利用</span><strong><span class="ne-text" style="color: #F5222D">多核 CPU 的计算能力</span></strong><span class="ne-text" style="color: #F5222D">，HTML5 提出 Web Worker 标准，允许 JavaScript 脚本创建多个线程，但是子线程完全受主线程控制。于是，JS 中出现了</span><strong><span class="ne-text" style="color: #F5222D">同步任务</span></strong><span class="ne-text" style="color: #F5222D">和</span><strong><span class="ne-text" style="color: #F5222D">异步任务</span></strong><span class="ne-text" style="color: #F5222D">。</span></p><p id="117599905a41f3d8f10cacf311ff90ce" class="ne-p"><br></p><p id="u09384c3b" class="ne-p"><span class="ne-text">JS中所有任务可以分成两种，一种是同步任务（synchronous），另一种是异步任务（asynchronous）。</span></p><ul class="ne-ul"><li id="ub267d26f"><strong><span class="ne-text">【同步任务】</span></strong><span class="ne-text">指的是：在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务；</span></li><li id="u8624ac1a"><strong><span class="ne-text">【异步任务】</span></strong><span class="ne-text">指的是：不进入主线程、而进入</span><strong><span class="ne-text">“任务队列”</span></strong><span class="ne-text">的任务，当主线程中的任务运行完了，才会将异步任务相关的回调函数从”任务队列”取出异步任务放入主线程执行。</span></li></ul><p id="ud8b66a6f" class="ne-p"><span class="ne-text">异步任务又分为宏任务和微任务</span></p><p id="u058036d7" class="ne-p"><span class="ne-text">宏任务</span></p><ul class="ne-ul"><li id="ud688c363"><span class="ne-text">主代码块</span></li><li id="uc0b63834"><span class="ne-text">setTimeout</span></li><li id="u5966078e"><span class="ne-text">setInterval</span></li></ul><p id="ub77f1171" class="ne-p"><span class="ne-text">微任务</span></p><ul class="ne-ul"><li id="u335c6cec"><span class="ne-text">process.nextTick ()</span></li><li id="u4793fdc8"><span class="ne-text">Promise</span></li><li id="u178c2fe5"><span class="ne-text">Object.observe</span></li></ul><h3 id="tDUjC"><span class="ne-text">事件循环机制</span></h3><p id="ub559a1fb" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/webp/1484158/1657425246544-000fdb98-cba1-4b29-83eb-97efba576a6c.webp" width="1280" id="u7367241e" class="ne-image"></p><ol class="ne-ol"><li id="u4bb87b57"><span class="ne-text">碰到同步任务，就先执行执行栈中的同步任务</span></li></ol><div class="ne-quote"><p id="ucec7015d" class="ne-p"><span class="ne-text">遇到函数的嵌套调用就把函数压入栈内再依次“剥洋葱”</span></p></div><ol start="2" class="ne-ol"><li id="u7048d5b0"><span class="ne-text">碰到异步任务就压入任务队列（异步任务分为宏任务和微任务）</span></li><li id="u8ac10e88"><span class="ne-text">当前执行栈中的所有同步任务执行完毕，就将执行异步任务，异步任务执行原则“先微后宏”</span></li></ol><p id="u245b5a71" class="ne-p"><strong><span class="ne-text" style="color: #E8323C">由于主线程不断地重复获得任务、执行任务、再获取任务、再执行……，这种机制被称为事件循环（Event Loop）</span></strong></p><h3 id="CkHxP"><span class="ne-text">实例</span></h3><pre><code>const promise = new Promise((resolve, reject) =&gt; &#123;  // new 先行  console.log(1);  resolve(&quot;success&quot;);  console.log(2);&#125;);promise.then((data) =&gt; &#123;  // 微任务  console.log(data);  console.log(3);&#125;);console.log(4);</code></pre><pre><code>124success3</code></pre><pre><code>const promise1 = new Promise((resolve, reject) =&gt; &#123;  console.log(&quot;promise1&quot;);  resolve(&quot;resolve1&quot;);&#125;);const promise2 = promise1.then((res) =&gt; &#123;  console.log(res);&#125;);console.log(&quot;1&quot;, promise1);console.log(&quot;2&quot;, promise2);</code></pre><pre><code>promise11 Promise &#123; 'resolve1' &#125;2 Promise &#123; &lt;pending&gt; &#125;resolve1</code></pre><details class="lake-collapse"><summary id="u0950fa51"><span class="ne-text">测试代码</span></summary><pre><code>// setTimeout(()=&gt;&#123;//     console.log(1)//   &#125;,0)// new Promise((resolve) =&gt;&#123;//     console.log(2)//     resolve()//   &#125;).then(()=&gt;&#123; // 此时将then的内容放到微任务队列，然后执行同步代码 5//     console.log(3)//   &#125;).then(()=&gt;&#123;//     console.log(4)//   &#125;)//   console.log(5)<p>// setTimeout(() =&gt; &#123;<br>//     console.log(‘timer1’);<br>//     setTimeout(() =&gt; &#123;<br>//       console.log(‘timer3’)<br>//     &#125;, 0)<br>//   &#125;, 0)<br>// setTimeout(() =&gt; &#123;<br>//     console.log(‘timer2’)<br>//   &#125;, 0)<br>// console.log(‘start’)</p><p>// setTimeout(() =&gt; &#123;<br>//     console.log(‘timer1’);<br>//     Promise.resolve().then(() =&gt; &#123;<br>//       console.log(‘promise’)<br>//     &#125;)<br>//   &#125;, 0)<br>// setTimeout(() =&gt; &#123;<br>//     console.log(‘timer2’)<br>//   &#125;, 0)<br>// console.log(‘start’)</p><p>// const first = () =&gt; (new Promise((resolve, reject) =&gt; &#123;<br>//     console.log(3)</p><p>//     let p = new Promise((resolve, reject) =&gt; &#123;<br>//       console.log(7)<br>//       setTimeout(() =&gt; &#123;<br>//         console.log(5)<br>//         resolve(6) // 状态只会改变一次<br>//       &#125;, 0)<br>//       resolve(1)<br>//     &#125;)</p><p>//     resolve(2)<br>//     p.then((arg) =&gt; &#123;<br>//       console.log(arg)<br>//     &#125;)<br>//   &#125;))</p><p>// first().then((arg) =&gt; &#123;<br>//     console.log(arg)<br>//   &#125;)</p><p>// console.log(4) // 在1 2 之前执行，此时1 2都在微任务队列里面</p><p>// setTimeout(() =&gt; &#123;<br>//     console.log(&quot;0&quot;)<br>//   &#125;, 0)</p><p>// new Promise((resolve,reject)=&gt;&#123;<br>//     console.log(&quot;1&quot;)<br>//     resolve()<br>//   &#125;).then(()=&gt;&#123; // then碰到then，就将其全部放到微任务队列，再细致考虑<br>//     console.log(&quot;2&quot;)<br>//     new Promise((resolve,reject)=&gt;&#123;<br>//       console.log(&quot;3&quot;)<br>//       resolve()<br>//     &#125;).then(()=&gt;&#123;<br>//       console.log(&quot;4&quot;) // 先5后4 “队列”<br>//     &#125;).then(()=&gt;&#123;<br>//       console.log(&quot;5&quot;)<br>//     &#125;)<br>//   &#125;).then(()=&gt;&#123;<br>//     console.log(&quot;6&quot;)<br>//   &#125;)</p><p>// new Promise((resolve,reject)=&gt;&#123;<br>//     console.log(&quot;7&quot;)<br>//     resolve() //2<br>//   &#125;).then(()=&gt;&#123;<br>//     console.log(&quot;8&quot;)<br>//   &#125;)</p><p>// Promise.resolve().then(() =&gt; &#123;<br>//     console.log(‘promise1’);<br>//     const timer2 = setTimeout(() =&gt; &#123;<br>//       console.log(‘timer2’)<br>//     &#125;, 0)<br>//   &#125;);</p><p>// const timer1 = setTimeout(() =&gt; &#123;<br>//     console.log(‘timer1’)<br>//     Promise.resolve().then(() =&gt; &#123;<br>//       console.log(‘promise2’)<br>//     &#125;)<br>//   &#125;, 0)</p><p>// console.log(‘start’);</p><p>// const promise1 = new Promise((resolve, reject) =&gt; &#123;<br>//     setTimeout(() =&gt; &#123;<br>//       resolve(‘success’)<br>//     &#125;, 1000)<br>//   &#125;)<br>// const promise2 = promise1.then(() =&gt; &#123;<br>//     throw new Error(‘error!!!’)<br>//   &#125;)</p><p>// console.log(‘promise1’, promise1)<br>// console.log(‘promise2’, promise2)</p><p>// setTimeout(() =&gt; &#123;<br>//     console.log(‘promise1’, promise1)<br>//     console.log(‘promise2’, promise2)<br>// &#125;, 2000)<br></code></pre></p></details><h2 id="TmnIc"><span class="ne-text">异步编程</span></h2><ul class="ne-ul"><li id="ub668edc1"><span class="ne-text">参照这里面的题来测验：</span><a href="https://juejin.cn/post/7050637649123475487" data-href="https://juejin.cn/post/7050637649123475487" class="ne-link"><span class="ne-text">靠做题📝来掌握Promise/async/await</span></a></li><li id="u81ed278c"><span class="ne-text"></span><a href="https://www.zhihu.com/question/554682475/answer/2759371197" data-href="https://www.zhihu.com/question/554682475/answer/2759371197" class="ne-link"><span class="ne-text">请问为啥前端现在喜欢用await了？ - siki学院的回答 - 知乎</span></a></li></ul><h3 id="UtGum"><span class="ne-text">Promise</span></h3><ul class="ne-tl"><li checked="true" id="u91c55651"><span class="ne-text">理解并能准确判断代码执行时机</span></li></ul><details class="lake-collapse"><summary id="u97ab30cf"><span class="ne-text">测试代码</span></summary><pre><code>/** * Promise：resolve reject then catch finally */// let p1 = new Promise((resolve, reject) =&gt; &#123;//     setTimeout(() =&gt; &#123;//       resolve('success')//     &#125;,1000)//   &#125;)  <p>//   let p2 = new Promise((resolve, reject) =&gt; &#123;<br>//     setTimeout(() =&gt; &#123;<br>//       reject(‘failed’)<br>//     &#125;, 500)<br>//   &#125;)</p><p>//   Promise.race([p1, p2]).then((result) =&gt; &#123;<br>//     console.log(result)<br>//   &#125;).catch((error) =&gt; &#123;<br>//     console.log(error)  // 打开的是 ‘failed’<br>// &#125;)</p><p>// function test(resolve, reject) &#123;<br>//   let timeOut = Math.random() * 2;<br>//   console.log(‘set timeout to: ‘ + timeOut + ‘ seconds.’);<br>//   setTimeout(function () &#123;<br>//       if (timeOut &lt; 1) &#123;<br>//         console.log(‘call resolve()…’);<br>//         resolve(‘200 OK’);<br>//       &#125;<br>//       else &#123;<br>//         console.log(‘call reject()…’);<br>//         reject(‘timeout in ‘ + timeOut + ‘ seconds.’);<br>//       &#125;<br>//   &#125;, timeOut * 1000);<br>// &#125;</p><p>// let p1 = new Promise(test);<br>// let p2 = p1.then(function (result) &#123;<br>//     console.log(‘成功：’ + result);<br>// &#125;);<br>// let p3 = p2.catch(function (reason) &#123;<br>//     console.log(‘失败：’ + reason);<br>// &#125;);</p><p>// function test(resolve, reject) &#123;<br>//   let timeOut = Math.random() * 2;<br>//   console.log(‘set timeout to: ‘ + timeOut + ‘ seconds.’);<br>//   setTimeout(function () &#123;<br>//       if (timeOut &lt; 1) &#123;<br>//         console.log(‘call resolve()…’);<br>//         resolve(‘200 OK’);<br>//       &#125;<br>//       else &#123;<br>//         console.log(‘call reject()…’);<br>//         reject(‘timeout in ‘ + timeOut + ‘ seconds.’);<br>//       &#125;<br>//   &#125;, timeOut * 1000);<br>// &#125;</p><p>// new Promise(test)<br>// .then(function (result) &#123;<br>//   console.log(‘成功：’ + result);<br>// &#125;)<br>// .catch(function (reason) &#123;<br>//   console.log(‘失败：’ + reason);<br>// &#125;)</p><p>// const promise = new Promise((resolve, reject) =&gt; &#123;<br>//     reject(&quot;error&quot;);<br>//     resolve(&quot;success2&quot;); // 需要return才能传递结果<br>//   &#125;);<br>//   promise.then(res =&gt; &#123;<br>//       console.log(&quot;then1: &quot;, res); // 需要return才能往下传递结果<br>//   &#125;).then(res =&gt; &#123;<br>//       console.log(&quot;then2: &quot;, res);<br>//   &#125;).catch(err =&gt; &#123;<br>//       console.log(&quot;catch: &quot;, err);<br>//   &#125;).then(res =&gt; &#123;<br>//       console.log(&quot;then3: &quot;, res); // undefined catch也会返回promise对象<br>//   &#125;)</p><p>// Promise.resolve(1)<br>//   .then(res =&gt; &#123;<br>//     console.log(res);<br>//     return 2; // return 2会被包装成resolve(2)<br>//   &#125;)<br>//   .catch(err =&gt; &#123;<br>//     return 3;<br>//   &#125;)<br>//   .then(res =&gt; &#123;<br>//     console.log(res);<br>//   &#125;);</p><p>// const promise = new Promise((resolve, reject) =&gt; &#123;<br>//     setTimeout(() =&gt; &#123;<br>//       console.log(‘timer’)<br>//       resolve(‘success’)<br>//     &#125;, 1000)<br>//   &#125;)<br>//   const start = Date.now();<br>//   promise.then(res =&gt; &#123;<br>//     console.log(res, Date.now() - start)<br>//   &#125;)<br>//   promise.then(res =&gt; &#123;<br>//     console.log(res, Date.now() - start) // 两个字几乎一样，状态一旦改变，就不会在变动了<br>//   &#125;)</p><p>//   Promise.resolve().then(() =&gt; &#123;<br>//     return new Error(‘error!!!’) // 被包裹成了return Promise.resolve(new Error(‘error!!!’))<br>//   &#125;).then(res =&gt; &#123;<br>//     console.log(&quot;then: &quot;, res)<br>//   &#125;).catch(err =&gt; &#123;<br>//     console.log(&quot;catch: &quot;, err)<br>//   &#125;)</p><p></code></pre></p><p id="u3de07eae" class="ne-p"><br></p><pre><code>/** * then链式调用 */// function runAsync1()&#123;//   var p = new Promise(function(resolve, reject)&#123;//       //做一些异步操作//       setTimeout(function()&#123;//           console.log('异步任务1执行完成');//           resolve('随便什么数据1');//       &#125;, 2000);//   &#125;);//   return p;// &#125;// function runAsync2()&#123;//   var p = new Promise(function(resolve, reject)&#123;//       //做一些异步操作//       setTimeout(function()&#123;//           console.log('异步任务2执行完成');//           resolve('随便什么数据2');//       &#125;, 1000);//   &#125;);//   return p;// &#125;// function runAsync3()&#123;//   var p = new Promise(function(resolve, reject)&#123;//       //做一些异步操作//       setTimeout(function()&#123;//           console.log('异步任务3执行完成');//           resolve('随便什么数据3');//       &#125;, 1000);//   &#125;);//   return p;// &#125;<p>// runAsync1()<br>// .then(function(data)&#123;<br>//     console.log(data);<br>//     return runAsync2();<br>// &#125;)<br>// .then(function(data)&#123;<br>//     console.log(data);<br>//     return runAsync3();<br>// &#125;)<br>// .then(function(data)&#123;<br>//     console.log(data);<br>// &#125;);</p><p></code></pre></p><p id="uda568f1f" class="ne-p"><br></p><pre><code>/** * all: 所有异步任务完成执行then * race：执行快的直接跳出 *///  function runAsync (x) &#123;//     const p = new Promise(r =&gt; setTimeout(() =&gt; r(x, console.log(x)), 1000))//     return p// &#125;// Promise.all([runAsync(1), runAsync(2), runAsync(3)]) // 参数数组都是promise实例，如果不是强制包装//   .then(res =&gt; console.log(res))<p>//   function runAsync (x) &#123;<br>//     const p = new Promise(r =&gt; setTimeout(() =&gt; r(x, console.log(x)), 1000))<br>//     return p<br>//   &#125;<br>//   function runReject (x) &#123;<br>//     const p = new Promise((res, rej) =&gt; setTimeout(() =&gt; rej(<code>Error: $&#123;x&#125;</code>, console.log(x)), 1000 * x))<br>//     return p<br>//   }<br>//   Promise.all([runAsync(1), runReject(4), runAsync(3), runReject(2)])<br>//     .then(res =&gt; console.log(res))<br>//     .catch(err =&gt; console.log(err))</p><p>// let p1 = new Promise((resolve, reject) =&gt; {<br>//     setTimeout(() =&gt; {<br>//       resolve(‘success’)<br>//     },1000)<br>//   })</p><p>//   let p2 = new Promise((resolve, reject) =&gt; {<br>//     setTimeout(() =&gt; {<br>//       reject(‘failed’)<br>//     }, 3000)<br>//   })</p><p>//   Promise.race([p1, p2]).then((result) =&gt; {<br>//     console.log(result)<br>//   }).catch((error) =&gt; {<br>//     console.log(error)  // 打开的是 ‘success’<br>// })</p><p></code></pre></p></details><ul class="ne-tl"><li id="u390413e0"><span class="ne-text">手写Promise api</span></li></ul><h3 id="zCwWK"><span class="ne-text">Async、await</span></h3><p id="u7526ecaf" class="ne-p"><span class="ne-text">await可以看成是Promise的语法糖（实际上是Generate的语法糖），效果和Promise的回调地狱一样，只是代码看起来好看点。</span></p><details class="lake-collapse"><summary id="u7781ab15"><span class="ne-text">测试代码</span></summary><pre><code>/** * async await */<p>//  async function fn () &#123;<br>//     // return await 123<br>//     // 等同于<br>//     return 123<br>//   &#125;<br>//   fn().then(res =&gt; console.log(res))<br>//   console.log(fn)</p><p>// async function async1() &#123;<br>//     console.log(&quot;async1 start&quot;);<br>//     await async2();<br>//     console.log(&quot;async1 end&quot;);<br>//   &#125;<br>// async function async2() &#123;<br>//     console.log(&quot;async2&quot;);<br>//   &#125;<br>// async1();<br>// console.log(‘start’)</p><p>// async function async1() &#123;<br>//     console.log(&quot;async1 start&quot;);<br>//     await async2(); // 紧跟着await后面的语句相当于放到了new Promise中，下一行及之后的语句相当于放在Promise.then中<br>//     console.log(&quot;async1 end&quot;);<br>//   &#125;<br>// async function async2() &#123;<br>//     setTimeout(() =&gt; &#123;<br>//       console.log(‘timer’)<br>//     &#125;, 0)<br>//     console.log(&quot;async2&quot;);<br>//   &#125;<br>// async1();<br>// console.log(&quot;start&quot;</p><p>// async function async1() &#123;<br>//   console.log(&quot;async1 start&quot;);<br>//   await async2();<br>//   console.log(&quot;async1 end&quot;);<br>//   setTimeout(() =&gt; &#123;<br>//     console.log(‘timer1’)<br>//   &#125;, 0)<br>// &#125;</p><p>// async function async2() &#123;<br>//   setTimeout(() =&gt; &#123;<br>//     console.log(‘timer2’)<br>//   &#125;, 0)<br>//   console.log(&quot;async2&quot;);<br>// &#125;</p><p>// async1();</p><p>// setTimeout(() =&gt; &#123;<br>//   console.log(‘timer3’)<br>// &#125;, 0)</p><p>// console.log(&quot;start&quot;)</p><p></code></pre></p></details><h3 id="X8bdj"><span class="ne-text">综合</span></h3><pre><code>async function a1() &#123;  console.log('a1 start')  await a2()  console.log('a1 end')&#125;async function a2() &#123;  console.log('a2')&#125;<p>console.log(‘script start’)</p><p>setTimeout(() =&gt; &#123;<br>  console.log(‘setTimeout’)<br>&#125;, 0)</p><p>Promise.resolve().then(() =&gt; &#123;<br>  console.log(‘promise1’)<br>&#125;)</p><p>a1()</p><p>let promise2 = new Promise(resolve =&gt; &#123;<br>  resolve(‘promise2.then’)<br>  console.log(‘promise2’)<br>&#125;)</p><p>promise2.then(res =&gt; &#123;<br>  console.log(res)<br>  Promise.resolve().then(() =&gt; &#123;<br>    console.log(‘promise3’)<br>  &#125;)<br>&#125;)<br>console.log(‘script end’)</p><p>/** 第一次做错的结果<br>script start<br>a1 start<br>a2<br>promise1<br>a1 end<br>promise2<br>script end<br>promise2.then<br>promise3<br>setTimeout<br> */</p><p>/** 正确结果<br>script start<br>a1 start<br>a2<br>promise2<br>script end<br>promise1<br>a1 end<br>promise2.then<br>promise3<br>setTimeout<br> */<br></code></pre></p><h2 id="AaYEl"><span class="ne-text">参考</span></h2><ul class="ne-ul"><li id="ud7d904d0"><a href="https://juejin.cn/post/6844903832388894727" data-href="https://juejin.cn/post/6844903832388894727" target="_blank" class="ne-link"><span class="ne-text">理解JavaScript概念系列--异步任务</span></a></li><li id="uf13c38a9"><a href="https://juejin.cn/post/6844903760280420366" data-href="https://juejin.cn/post/6844903760280420366" target="_blank" class="ne-link"><span class="ne-text">JS 异步编程六种方案</span></a></li><li id="u6f67f941"><a href="https://juejin.cn/post/6962312899960242213" data-href="https://juejin.cn/post/6962312899960242213" class="ne-link"><span class="ne-text">微任务/宏任务和同步/异步之间的关系</span></a></li><li id="u8a1e4f3c"><a href="https://www.cnblogs.com/lvdabao/p/es6-promise-1.html" data-href="https://www.cnblogs.com/lvdabao/p/es6-promise-1.html" target="_blank" class="ne-link"><span class="ne-text">大白话讲解Promise（一）</span></a></li><li id="u4f9ab938"><a href="https://www.bilibili.com/video/BV1kf4y1U7Ln" data-href="https://www.bilibili.com/video/BV1kf4y1U7Ln" class="ne-link"><span class="ne-text">2分钟了解 JavaScript Event Loop | 面试必备</span></a></li><li id="u4c2350d7"><a href="https://juejin.cn/post/7050637649123475487" data-href="https://juejin.cn/post/7050637649123475487" class="ne-link"><span class="ne-text">靠做题📝来掌握Promise/async/await</span></a></li><li id="ufa03a3cb"><a href="https://www.cnblogs.com/nana-share/p/9187997.html" data-href="https://www.cnblogs.com/nana-share/p/9187997.html" class="ne-link"><span class="ne-text">javascript 异步操作，串形执行，并行执行 - 小苏打00 - 博客园</span></a></li></ul></div>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
          <category> JavaScript </category>
          
          <category> ECMAScript </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>客户端检测</title>
      <link href="/blog/gnyhrv/"/>
      <url>/blog/gnyhrv/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="u0da261e9" class="ne-p"><span class="ne-text">前言：用于客户端检测的工具函数记录</span></p><h3 id="XNybz"><span class="ne-text">是否为IOS设备</span></h3><pre><code>let isIos = () =&gt; &#123;  var u = navigator.userAgent  if (u.indexOf('Android') &gt; -1 || u.indexOf('Linux') &gt; -1) &#123;    //安卓手机    // return &quot;Android&quot;;    return false  &#125; else if (u.indexOf('iPhone') &gt; -1) &#123;    //苹果手机    // return &quot;iPhone&quot;;    return true  &#125; else if (u.indexOf('iPad') &gt; -1) &#123;    //iPad    // return &quot;iPad&quot;;    return false  &#125; else if (u.indexOf('Windows Phone') &gt; -1) &#123;    //winphone手机    // return &quot;Windows Phone&quot;;    return false  &#125; else &#123;    return false  &#125;&#125;</code></pre><h3 id="Tp09f"><span class="ne-text">是否为PC设备</span></h3><pre><code>let isPC = () =&gt; &#123;  //是否为PC端  var userAgentInfo = navigator.userAgent  var Agents = [    'Android',    'iPhone',    'SymbianOS',    'Windows Phone',    'iPad',    'iPod',  ]  var flag = true  for (var v = 0; v &lt; Agents.length; v++) &#123;    if (userAgentInfo.indexOf(Agents[v]) &gt; 0) &#123;      flag = false      break    &#125;  &#125;  return flag&#125;</code></pre><h3 id="wNkaL"><span class="ne-text">浏览器类型</span></h3><pre><code>let browserType = () =&gt; &#123;  var userAgent = navigator.userAgent //取得浏览器的userAgent字符串  var isOpera = userAgent.indexOf('Opera') &gt; -1 //判断是否Opera浏览器  var isIE =      userAgent.indexOf('compatible') &gt; -1 &amp;&amp;      userAgent.indexOf('MSIE') &gt; -1 &amp;&amp;      !isOpera //判断是否IE浏览器  var isIE11 =      userAgent.indexOf('Trident') &gt; -1 &amp;&amp; userAgent.indexOf('rv:11.0') &gt; -1  var isEdge = userAgent.indexOf('Edge') &gt; -1 &amp;&amp; !isIE //判断是否IE的Edge浏览器  var isFF = userAgent.indexOf('Firefox') &gt; -1 //判断是否Firefox浏览器  var isSafari =      userAgent.indexOf('Safari') &gt; -1 &amp;&amp; userAgent.indexOf('Chrome') == -1 //判断是否Safari浏览器  var isChrome =      userAgent.indexOf('Chrome') &gt; -1 &amp;&amp; userAgent.indexOf('Safari') &gt; -1 //判断Chrome浏览器<p>  if (isIE) &#123;<br>    var reIE = new RegExp(‘MSIE (\d+\.\d+);’)<br>    reIE.test(userAgent)<br>    var fIEVersion = parseFloat(RegExp[‘$1’])<br>    if (fIEVersion == 7) return ‘IE7’<br>    else if (fIEVersion == 8) return ‘IE8’<br>    else if (fIEVersion == 9) return ‘IE9’<br>    else if (fIEVersion == 10) return ‘IE10’<br>    else return ‘IE7以下’ //IE版本过低<br>  &#125;<br>  if (isIE11) return ‘IE11’<br>  if (isEdge) return ‘Edge’<br>  if (isFF) return ‘FF’<br>  if (isOpera) return ‘Opera’<br>  if (isSafari) return ‘Safari’<br>  if (isChrome) return ‘Chrome’<br>&#125;<br></code></pre></p><p id="u03ce0130" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1653026051837-a36a45e0-2b92-48d9-8b88-63c35e2babd2.png" width="369.99998529752156" id="ucbd2b3d7" class="ne-image"></p></div>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
          <category> JavaScript </category>
          
          <category> BOM </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>小满：故人叹物</title>
      <link href="/essay/avyy9v/"/>
      <url>/essay/avyy9v/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="u4b0d8d20" class="ne-p"><strong><span class="ne-text">物质</span></strong></p><p id="ua70271b8" class="ne-p"><span class="ne-text">我好像对物质没有太多的追求</span></p><p id="u21579c9c" class="ne-p"><span class="ne-text">努力一份好工作，也只是让自己不成为一个无能的人罢了</span></p><p id="u3718dd8b" class="ne-p"><span class="ne-text">在家人朋友想要的时候，无能会让人变得无比遗憾</span></p><p id="u6261cdee" class="ne-p"><span class="ne-text">我不想让所有的不利因素都归咎于无能之下</span></p><p id="ub7baf720" class="ne-p"><span class="ne-text">没有太多的物质追求，只求爱我我爱的人过的开心就好</span></p><p id="u1dc90ba2" class="ne-p"><span class="ne-text"></span></p><p id="u3d941a94" class="ne-p"><strong><span class="ne-text">相处</span></strong></p><p id="uadbd427d" class="ne-p"><span class="ne-text"> 用到理科的取反、就简、取极限原则</span></p><p id="u739267d4" class="ne-p"><span class="ne-text">与人相处也可以定义成如何和你讨厌的人相处</span></p><p id="u231730c4" class="ne-p"><span class="ne-text">懂得了这个</span></p><p id="uda2bd5bf" class="ne-p"><span class="ne-text">很多事情就变得明朗起来了</span></p><p id="u8b509d99" class="ne-p"><span class="ne-text"></span></p><p id="u93a72975" class="ne-p"><strong><span class="ne-text">成长</span></strong></p><p id="uaa460629" class="ne-p"><span class="ne-text">很多时候，如果不是因为一件大事</span></p><p id="u8d704de3" class="ne-p"><span class="ne-text">一个人的成长确实是根据时间、环境来决定的</span></p><p id="u8ab0b2d2" class="ne-p"><span class="ne-text">很多时候我就会想成长和成熟的区别</span></p><p id="ubc1131ce" class="ne-p"><span class="ne-text">我的答案是：没有区别</span></p><p id="ub4dc793f" class="ne-p"><span class="ne-text">也可以说成两者互为充要条件吧</span></p><p id="uf2e5220c" class="ne-p"><span class="ne-text"></span></p><p id="u4469a85d" class="ne-p"><strong><span class="ne-text">没有意义的事情</span></strong></p><p id="u3644fc4b" class="ne-p"><span class="ne-text">如果你所做的所有事情都是没有意义的。</span></p><p id="ucc2ecd3f" class="ne-p"><span class="ne-text">当你做了一些事情，到了一定时候</span></p><p id="u7c5ab5e2" class="ne-p"><span class="ne-text">你发现</span></p><p id="ufa655cb3" class="ne-p"><span class="ne-text">你曾经做过的所有事情</span></p><p id="u90a28096" class="ne-p"><span class="ne-text">都是没有意义的</span></p><p id="u1428405f" class="ne-p"><span class="ne-text">是多么的孤寂</span></p><p id="uf9dc6c53" class="ne-p"><span class="ne-text"></span></p></div>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript浅拷贝深拷贝实现</title>
      <link href="/blog/lwi9wr/"/>
      <url>/blog/lwi9wr/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h2 id="sEWoQ"><span class="ne-text">原始值和引用值</span></h2><p id="be789bab58359dda0d9df532eb85cd7a" class="ne-p"><span class="ne-text">这里面Java和JavaScript都是只有引用的概念，但是在C/C++里面，就有指针的概念</span></p><p id="185ad2ff8b1c9fccb24c3ec65e95156f" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1617868682681-90191ec3-c5b2-415f-9e38-df2706301e0c.png" width="465.5" id="dmTBK" class="ne-image"></p><ul class="ne-ul"><li id="u7ae02f1b"><span class="ne-text">原始值： </span><strong><span class="ne-text">存储在栈中的简单数据段</span></strong><span class="ne-text">，即他们的值直接存储在变量访问的位置。</span></li></ul><p id="u4c8c2b5b" class="ne-p"><span class="ne-text">包括：undefined、null、boolean、number、string、symbol</span></p><p id="u2f8d3de3" class="ne-p"><span class="ne-text"></span></p><ul class="ne-ul"><li id="u1cc91305"><span class="ne-text">引用值：</span><strong><span class="ne-text">存储在堆中的对象</span></strong><span class="ne-text">，即存储在变量处的值是一个指针，只想存储对象的内存处。</span></li></ul><p id="uc6a34d30" class="ne-p"><span class="ne-text">包括：object、array、function等</span></p><p id="u602c0ed7" class="ne-p"><span class="ne-text"></span></p><ul class="ne-ul"><li id="ud38b6f2e"><span class="ne-text">两者的区别：</span></li></ul><p id="u02a3d07c" class="ne-p"><span class="ne-text">原始变量及他们的值储存在栈中，当把一个原始变量传递给另一个原始变量时，是把一个栈房间的东西复制到另一个栈房间，且这两个原始变量互不影响。</span><strong><span class="ne-text">引用值是把引用变量的名称储存在栈中，但是把其实际对象储存在堆中</span></strong><span class="ne-text">，且存在一个指针由变量名指向储存在堆中的实际对象，当把引用对象传递给另一个变量时，复制的其实是指向实际对象的指针，此时两者指向的是同一个数据，若通过方法改变其中一个变量的值，则访问另一个变量时，其值也会随之加以改变；但若不是通过方法而是通过重新赋值，此时，相当于重新开了一个房间，该值的原指针改变，则另外一个值不会随他的改变而改变。</span></p><pre><code>let s = '基本类型'let s_test = ss_test = '改变之后不影响s'console.log(s)console.log(s_test)<p>let arr = [‘原始数组值’]<br>arr_test = arr<br>arr_test[0] = ‘改变值’<br>console.log(arr)<br>console.log(arr_test)</p><p>//基本类型<br>//改变之后不影响s<br>//[ ‘改变值’ ]<br>//[ ‘改变值’ ]<br></code></pre></p><ul class="ne-ul"><li id="570fd75c2e87aa222daa905fbf6ce98d"><span class="ne-text">参考：</span><a href="https://blog.csdn.net/u012443286/article/details/79496742" data-href="https://blog.csdn.net/u012443286/article/details/79496742" target="_blank" class="ne-link"><span class="ne-text">谈谈JavaScript中的变量、指针和引用</span></a></li></ul><h2 id="iEowI"><span class="ne-text">深拷贝与浅拷贝 </span></h2><h3 id="ZYo3B"><span class="ne-text">区分概念</span></h3><ul class="ne-ul"><li id="ube942d08"><span class="ne-text">浅拷贝：直接赋值，还是指向同一个堆</span></li><li id="u9305c0f0"><span class="ne-text">深拷贝：相当于重新创建一个对象，新开存储空间</span></li><li id="u1bfcb188"><span class="ne-text">参考：</span><a href="https://segmentfault.com/a/1190000016440069" data-href="https://segmentfault.com/a/1190000016440069" class="ne-link"><span class="ne-text">js浅拷贝与深拷贝方法</span></a></li></ul><p id="ud233259a" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1651305177480-c971984f-5aa2-48af-9d4b-3eee50afffee.png" width="291" id="u19a4acf0" class="ne-image"><span class="ne-text">、</span></p><h3 id="UY983"><span class="ne-text">浅拷贝实现</span></h3><ol class="ne-ol"><li id="u6df7d29e"><span class="ne-text">直接等号赋值</span></li></ol><pre><code>let obj = &#123;  ss: 'ss',  hh: 'hh',&#125;<p>let obj_qian = obj<br>obj_qian.ss = ‘sss’<br>obj_qian.hh = ‘hhh’<br>console.log(obj) //&#123; ss: ‘sss’, hh: ‘hhh’ &#125;<br>console.log(obj_qian) //&#123; ss: ‘sss’, hh: ‘hhh’ &#125;<br></code></pre></p><h3 id="qhGMP"><span class="ne-text">深拷贝实现</span></h3><ol class="ne-ol"><li id="ubad15add"><span class="ne-text">直接创建一个同类型的数据结构，然后将原值一个个复制过来（数组）</span></li><li id="ue460b0a1"><span class="ne-text">JSON方法（对象）</span></li></ol><pre><code>let obj = &#123;  ss: 'ss',  hh: 'hh',&#125;<p>let obj_shen_JSON = JSON.parse(JSON.stringify(obj))<br>obj_shen_JSON.ss = ‘sssss’<br>obj_shen_JSON.hh = ‘hhhhh’<br>console.log(obj) //&#123; ss: ‘ss’, hh: ‘hh’ &#125;<br>console.log(obj_shen_JSON) // &#123; ss: ‘sssss’, hh: ‘hhhhh’ &#125;<br></code></pre></p><h3 id="uFYnE"><span class="ne-text">手写深拷贝</span></h3><pre><code>let clone = target =&gt; &#123;  if (typeof target === 'object') &#123;    let cloneTarget = Array.isArray(target) ? [] : &#123;&#125;    for (const key in target) &#123;      cloneTarget[key] = clone(target[key])    &#125;    return cloneTarget  &#125; else &#123;    return target  &#125;&#125;<p>let obj_1 = &#123;<br>  c: ‘c’,<br>  d: &#123;<br>    d1: ‘d1’,<br>    d2: ‘d2’,<br>  &#125;,<br>&#125;<br>let obj_my = clone(obj_1)<br>obj_1.c = ‘ccccccc’<br>obj_1.d.d1 = ‘dsdddddddd’<br>console.log(obj_1)<br>console.log(obj_my)<br></code></pre></p><p id="u7d570bdc" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1652416167805-60ef8c07-9bba-4d43-a2e2-349b986c3c35.png" width="454.1666486197055" id="u1714696c" class="ne-image"></p><h3 id="zkjl4"><span class="ne-text">Object.assign({}, obj)</span></h3><ul class="ne-ul"><li id="u2318572f"><strong><span class="ne-text">assign既可以是深拷贝，也可以是浅拷贝</span></strong></li></ul><ul class="ne-ul"><li id="ud6dd0dff"><span class="ne-text">Object.assign() 方法用于将所有可枚举属性的值从一个或多个源对象分配到目标对象。它将返回目标对象。</span></li><li id="u7f8ba952"><span class="ne-text">对于Object.assign()而言，如果对象的属性值为简单类型（string，number），通过Object.assign({},srcobj);得到的新对象为深拷贝；如果属性值为对象或其他引用类型，那对于这个对象而言其实是浅拷贝的</span></li></ul><pre><code>let obj = &#123;  a: 'a',  b: 'b',&#125;<p>let obj_deep = Object.assign(&#123;&#125;, obj)<br>obj.a = ‘aa’<br>console.log(obj)<br>console.log(obj_deep)</p><p>console.log(‘——————————–’)<br>let obj_obj = &#123;<br>  c: ‘c’,<br>  d: &#123;<br>    d1: ‘d1’,<br>    d2: ‘d2’,<br>  &#125;,<br>&#125;</p><p>let obj_qian = Object.assign(&#123;&#125;, obj_obj)<br>obj_obj.c = ‘cc’<br>obj_obj.d.d1 = ‘d1111’<br>console.log(obj_obj)<br>console.log(obj_qian)<br></code></pre></p><p id="u3956ee6e" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1652415857368-38e9203a-1178-4fc4-b53d-a6059c212ad0.png" width="421.6666499111394" id="u6b2eae5b" class="ne-image"></p></div>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
          <category> JavaScript </category>
          
          <category> ECMAScript </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>442. 数组中重复的数据🔖数组🔖哈希表</title>
      <link href="/blog/cp993p/"/>
      <url>/blog/cp993p/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><ul class="ne-ul"><li id="u76be6687"><a href="https://leetcode-cn.com/problems/find-all-duplicates-in-an-array/" data-href="https://leetcode-cn.com/problems/find-all-duplicates-in-an-array/" target="_blank" class="ne-link"><span class="ne-text">https://leetcode-cn.com/problems/find-all-duplicates-in-an-array/</span></a></li></ul><p id="ud3fca973" class="ne-p"><span class="ne-text"></span></p><h3 id="Q81xz"><span class="ne-text">暴力解法</span></h3><pre><code>/** * @param &#123;number[]&#125; nums * @return &#123;number[]&#125; */var findDuplicates = function(nums) &#123;    let arr =[]    let result =[]    nums.forEach(data=&gt;&#123;        arr.includes(data) ? result.push(data) : arr.push(data)    &#125;)    return result&#125;;</code></pre><p id="u4d402b58" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1652015297299-44ac1ea9-f775-483d-b762-d57c71ff32c9.png" width="629.9999749660502" id="u730a2960" class="ne-image"></p><h3 id="BCCAk"><span class="ne-text">哈希表</span></h3><pre><code>/** * @param &#123;number[]&#125; nums * @return &#123;number[]&#125; */var findDuplicates = function(nums) &#123;  const map = new Map()  const arr = []<p>  for(let i = 0; i &lt; nums.length; i++) &#123;<br>    if (map.has(nums[i])) &#123;<br>      arr.push(nums[i])<br>      map.delete(nums[i])<br>    &#125; else &#123;<br>      map.set(nums[i])<br>    &#125;<br>  &#125;</p><p>  return arr<br>&#125;;<br></code></pre></p><p id="u93e02786" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1652015256459-e3d10aa5-79a4-4ea5-b8c2-edb2ffd6abe1.png" width="626.6666417651716" id="ue83dc54e" class="ne-image"></p></div>]]></content>
      
      
      <categories>
          
          <category> 计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 📶线结构：字符串-数组-栈-队列 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>人鬼如梦</title>
      <link href="/essay/otaot9/"/>
      <url>/essay/otaot9/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="u79092823" class="ne-p"><span class="ne-text">不知什么时候，我特别喜欢梦这个意象</span></p><p id="u3e51b264" class="ne-p"><span class="ne-text">人鬼殊途，却是美好的意境</span></p><p id="u74a9daeb" class="ne-p"><span class="ne-text">醒来一无所有</span></p><p id="u64ba1061" class="ne-p"><span class="ne-text">我宁愿生活一个小小梦里面，快乐纯真的守护</span></p><p id="u20fa5a6b" class="ne-p"><span class="ne-text">只守护，不求功与名</span></p><p id="u338e73c1" class="ne-p"><span class="ne-text">只愿守护所爱</span></p><p id="u7a03d462" class="ne-p"><span class="ne-text">人鬼殊途，却也美好梦一场</span></p><p id="u067baa19" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/1484158/1651989959347-a078aca1-56b2-4421-a8cd-8e10516c166f.jpeg" width="1950" id="uef1688dd" class="ne-image"></p><p id="u00743ca7" class="ne-p"><span class="ne-text"></span></p></div>]]></content>
      
      
      <categories>
          
          <category> 异世界 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>1823. 找出游戏的获胜者🔖递归</title>
      <link href="/blog/ucz0sz/"/>
      <url>/blog/ucz0sz/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><ul class="ne-ul"><li id="u2561afec"><a href="https://leetcode-cn.com/problems/find-the-winner-of-the-circular-game/" data-href="https://leetcode-cn.com/problems/find-the-winner-of-the-circular-game/" target="_blank" class="ne-link"><span class="ne-text">https://leetcode-cn.com/problems/find-the-winner-of-the-circular-game/</span></a></li></ul><p id="ua1522be6" class="ne-p"><span class="ne-text"></span></p><p id="uc655ed76" class="ne-p"><span class="ne-text">其中12行代码是根据数学找规律得出来的（滑稽</span></p><p id="uee099d02" class="ne-p"><span class="ne-text"></span></p><p id="ud70ea673" class="ne-p"><span class="ne-text">感觉这个题目还有用循环链表，队列啥的写，但是力扣我至今还不知道他有没有预设这些js不内置的数据结构，一直都是题目有啥用啥……</span></p><pre><code>/** * @param &#123;number&#125; n * @param &#123;number&#125; k * @return &#123;number&#125; */var findTheWinner = function(n, k) &#123;    let arr = []    for (let i = 0; i&lt;n; i++) arr.push(i+1)    let searchP = (arr, k, pre) =&gt; &#123;        if (arr.length &gt; 1) &#123;            pre = k + pre - 1            while (pre &gt; arr.length-1) pre = pre - arr.length            arr.splice(pre, 1)            searchP(arr, k, pre)        &#125;    &#125;    searchP(arr, k, 0)    return arr[0]&#125;;</code></pre><p id="ue12db441" class="ne-p"><span class="ne-text"></span></p><p id="u378010d0" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1651647527838-774b7fe0-fbba-44d7-8fa2-b7a1af828bdb.png" width="670.8333066768128" id="u874494ca" class="ne-image"></p></div>]]></content>
      
      
      <categories>
          
          <category> 计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 🌌递归算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>905. 按奇偶排序数组🔖数组</title>
      <link href="/blog/sp649k/"/>
      <url>/blog/sp649k/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><ul class="ne-ul"><li id="u0934bc91"><a href="https://leetcode-cn.com/problems/sort-array-by-parity/" data-href="https://leetcode-cn.com/problems/sort-array-by-parity/" target="_blank" class="ne-link"><span class="ne-text">https://leetcode-cn.com/problems/sort-array-by-parity/</span></a></li></ul><p id="u4bbd8d43" class="ne-p"><span class="ne-text"></span></p><p id="ue01bb5d1" class="ne-p"><span class="ne-text">暴力解法</span></p><pre><code>/** * @param &#123;number[]&#125; nums * @return &#123;number[]&#125; */var sortArrayByParity = function(nums) &#123;    let arr = []    nums.forEach(data =&gt; &#123;data % 2 === 0 ? arr.unshift(data) : arr.push(data)&#125;)    return arr&#125;;</code></pre><p id="uc66ff315" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1651567846491-0c978678-9a40-4ee4-b77b-22dc5284ef37.png" width="617.4999754627555" id="ubb08a31d" class="ne-image"></p><p id="uceba6cc9" class="ne-p"><br></p></div>]]></content>
      
      
      <categories>
          
          <category> 计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 📶线结构：字符串-数组-栈-队列 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>908. 最小差值 I🔖数组</title>
      <link href="/blog/vmdef7/"/>
      <url>/blog/vmdef7/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><ul class="ne-ul"><li id="ueaf52d85"><a href="https://leetcode-cn.com/problems/smallest-range-i/" data-href="https://leetcode-cn.com/problems/smallest-range-i/" target="_blank" class="ne-link"><span class="ne-text">https://leetcode-cn.com/problems/smallest-range-i/</span></a></li></ul><p id="ue34d2f17" class="ne-p"><span class="ne-text">主要分析出规律就好解了</span></p><ul class="ne-ul"><li id="ud251fd6e"><span class="ne-text">对第一个和最后一个元素进行相减比较</span></li><li id="u1817570f"><span class="ne-text">去重</span></li></ul><pre><code>/** * @param &#123;number[]&#125; nums * @param &#123;number&#125; k * @return &#123;number&#125; */var smallestRangeI = function(nums, k) &#123;    let arr = Array.from(new Set(nums.sort((a, b) =&gt; &#123;return a - b&#125;)))    if (arr.length === 1) return 0    return arr[arr.length - 1] - arr[0] - 2 * k &lt;= 0 ? 0 : arr[arr.length - 1] - arr[0] -2 * k&#125;;</code></pre><p id="u5d9cf971" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1652015419001-5fb4bfd2-befa-43a7-a309-2962b8d2fee1.png" width="624.9999751647323" id="u9619e698" class="ne-image"></p></div>]]></content>
      
      
      <categories>
          
          <category> 计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 📶线结构：字符串-数组-栈-队列 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>1305. 两棵二叉搜索树中的所有元素🔖DFS🔖数组</title>
      <link href="/blog/rxfz11/"/>
      <url>/blog/rxfz11/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><ul class="ne-ul"><li id="u46abc578"><a href="https://leetcode-cn.com/problems/all-elements-in-two-binary-search-trees/" data-href="https://leetcode-cn.com/problems/all-elements-in-two-binary-search-trees/" target="_blank" class="ne-link"><span class="ne-text">https://leetcode-cn.com/problems/all-elements-in-two-binary-search-trees/</span></a></li></ul><p id="u6f0ad162" class="ne-p"><span class="ne-text"></span></p><pre><code>/** * Definition for a binary tree node. * function TreeNode(val, left, right) &#123; *     this.val = (val===undefined ? 0 : val) *     this.left = (left===undefined ? null : left) *     this.right = (right===undefined ? null : right) * &#125; *//** * @param &#123;TreeNode&#125; root1 * @param &#123;TreeNode&#125; root2 * @return &#123;number[]&#125; */var getAllElements = function(root1, root2) &#123;    let arr_left = []    let arr_right = []    let dfs = (data, arr) =&gt; &#123;        if (data) &#123;            dfs(data.left, arr)            dfs(data.right, arr)            arr.push(data.val)        &#125;    &#125;    dfs(root1, arr_left)    dfs(root2, arr_right)    return arr_left.concat(arr_right).sort((a, b) =&gt; &#123;return a - b&#125;)&#125;;</code></pre><p id="u25b22db4" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1651564651594-33c9e8d9-889d-4560-858a-8d9f15021e99.png" width="635.8333080675877" id="u429a9901" class="ne-image"></p></div>]]></content>
      
      
      <categories>
          
          <category> 计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 🌲树结构：二叉树-哈夫曼树 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>3. 无重复字符的最长子串</title>
      <link href="/blog/sutafh/"/>
      <url>/blog/sutafh/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><ul class="ne-ul"><li id="u742c0868"><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/" data-href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/" target="_blank" class="ne-link"><span class="ne-text">https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/</span></a></li></ul><p id="ub473188b" class="ne-p"><span class="ne-text">暴力解法</span></p><pre><code>/** * @param &#123;string&#125; s * @return &#123;number&#125; */var lengthOfLongestSubstring = function(s) &#123;    let result = 1    if (s.length === 0) return 0    if (s.length === 1) return 1    for(let i=0;i&lt;s.length-1;i++)&#123;        for(let j=i+1;j&lt;s.length;j++)&#123;            let arr = s.substr(i,j-i+1).split('')            let set = new Set(arr)<pre><code>        if(arr.length !==[...set].length)&#123;            break        &#125; else &#123;            result = result &amp;gt;= arr.length ? result : arr.length        &#125;    &#125;&#125;return result</code></pre><p>};<br></code></pre></p><p id="u41603835" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1651544911564-558d66b8-bbf2-4a53-9afe-c3c92e0b8051.png" width="634.999974767368" id="uf5f7c443" class="ne-image"></p><p id="udf417444" class="ne-p"><span class="ne-text">这个结果太拉跨了……</span></p><p id="ue8529b0c" class="ne-p"><strong><span class="ne-text">todo：滑动窗口</span></strong></p></div>]]></content>
      
      
      <categories>
          
          <category> 计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 🥢KMP类算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>n级阶梯1步2步走问题</title>
      <link href="/blog/ik7g6a/"/>
      <url>/blog/ik7g6a/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="u07d0ee9b" class="ne-p"><span class="ne-text">题目：一个长阶梯有n级，可以一次走1级，一次走2级，一共有多少种走法？</span></p><p id="uba61458f" class="ne-p"><span class="ne-text"></span></p><p id="u0a864803" class="ne-p"><span class="ne-text">经典的动态规划问题，从结果来看：</span></p><ul class="ne-ul"><li id="ucab5f525"><span class="ne-text">到达第n层阶梯的方式只有两种，走一步然后结束，或者走两步然后结束。</span></li><li id="uae554292"><span class="ne-text">到达第n-1层阶梯的方式只有两种，走一步然后结束，或者走两步然后结束。</span></li><li id="u010a4305"><span class="ne-text">……</span></li></ul><p id="u28f22cd8" class="ne-p"><span class="ne-text"></span></p><p id="uc65816a0" class="ne-p"><span class="ne-text">抽离于动态规划模型，动态规划解题主要是解决两点（一般难题也就从这两个点来设置）</span></p><ol class="ne-ol"><li id="u69701fa9"><span class="ne-text">动态方程</span></li><li id="u2f7d9b2d"><span class="ne-text">边界条件</span></li></ol><p id="u8901ae16" class="ne-p"><span class="ne-text"></span></p><pre><code>let arr = new Array(n).fill(0)<p>// 边界条件<br>arr[0] = 1<br>arr[1] = 2</p><p>for (let i = 2; i&lt;arr.length; i++) &#123;<br>  // 动态方程<br>  arr[i] = arr[i-1] + arr[i-2]<br>&#125;</p><p>console.log(arr[n-1])<br></code></pre></p><p id="u72d9cfa6" class="ne-p"><br></p><p id="ud8d6c79c" class="ne-p"><span class="ne-text">还可以用递归（不建议用，复杂度太高指数级，但是因为和递归看起来有点像，所以写出来作为比较）</span></p><pre><code>let jie = n =&gt; &#123;  if(n === 1) return 1;  if(n === 2) return 2;  if(n &gt; 2)  return jie(n-1) + jie(n-2);&#125;</code></pre></div>]]></content>
      
      
      <categories>
          
          <category> 计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 🔢动态规划算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>todo：63. 不同路径 II🔖DP</title>
      <link href="/blog/hny8e9/"/>
      <url>/blog/hny8e9/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><ul class="ne-ul"><li id="ue13427c7"><a href="https://leetcode-cn.com/problems/unique-paths-ii/solution/" data-href="https://leetcode-cn.com/problems/unique-paths-ii/solution/" target="_blank" class="ne-link"><span class="ne-text">https://leetcode-cn.com/problems/unique-paths-ii/solution/</span></a></li></ul><p id="u236ad41b" class="ne-p"><span class="ne-text"></span></p><div data-type="danger" class="ne-alert"><p id="ue5200779" class="ne-p" style="text-align: center"><span class="ne-text">代码还没有完成</span></p><ul class="ne-tl"><li checked="true" id="u37341c24"><span class="ne-text">动态方程</span></li><li id="ub08bdea2"><span class="ne-text">边界情况：</span><strong><span class="ne-text">对于目标位置arr[m-1][n-1]的周围被围绕这个边界情况遗漏了</span></strong><span class="ne-text">。</span></li></ul></div><p id="ue75f2f7d" class="ne-p"><span class="ne-text"></span></p><pre><code>/** * @param &#123;number[][]&#125; obstacleGrid * @return &#123;number&#125; */var uniquePathsWithObstacles = function(obstacleGrid) &#123;    let m = obstacleGrid.length    let n = obstacleGrid[0].length    <pre><code>if (m === 1 &amp;amp;&amp;amp; n === 1) return obstacleGrid[0][0] === 0 ? 1 : 0if (m === 1) return obstacleGrid[0].includes(1) ? 0 : 1if (n === 1) &#123;    for (let i = 0; i&amp;lt;m; i++) &#123;        if (obstacleGrid[i][0] === 1) return 0    &#125;&#125;if (obstacleGrid[0][0] === 1 || obstacleGrid[m-1][n-1] === 1) return 0for (let i = 0; i&amp;lt;m; i++) obstacleGrid[i][0] = obstacleGrid[i][0] === 0 ? 1 : 0for (let i = 0; i&amp;lt;n; i++) obstacleGrid[0][i] = obstacleGrid[0][i] === 0 ? 1 : 0for (let i = 1; i&amp;lt;m; i++) &#123;    for (let j = 1; j&amp;lt;n; j++) &#123;        obstacleGrid[i][j] === 1             ? obstacleGrid[i][j] = 0            : obstacleGrid[i][j] = obstacleGrid[i-1][j] + obstacleGrid[i][j-1]    &#125;&#125;return obstacleGrid[m-1][n-1]</code></pre><p>};<br></code></pre></p></div>]]></content>
      
      
      <categories>
          
          <category> 计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 🔢动态规划算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>62. 不同路径🔖DP</title>
      <link href="/blog/lc1dfa/"/>
      <url>/blog/lc1dfa/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><ul class="ne-ul"><li id="ub6d0c2df"><a href="https://leetcode-cn.com/problems/unique-paths/" data-href="https://leetcode-cn.com/problems/unique-paths/" target="_blank" class="ne-link"><span class="ne-text">https://leetcode-cn.com/problems/unique-paths/</span></a></li></ul><p id="u087f2747" class="ne-p"><span class="ne-text"></span></p><p id="uefa1dac2" class="ne-p"><span class="ne-text">动态规划题目需要找到两点：</span></p><ul class="ne-ul"><li id="ua95065ea"><strong><span class="ne-text">动态方程：动态方程抽离问题的共同解决方程</span></strong></li><li id="u942a84e5"><strong><span class="ne-text">边界情况：相当于对于上述动态方程的特殊情况的枚举</span></strong></li></ul><p id="u30bca93f" class="ne-p"><br></p><pre><code>/** * @param &#123;number&#125; m * @param &#123;number&#125; n * @return &#123;number&#125; */var uniquePaths = function(m, n) &#123;    let arr = new Array(m).fill(0).map(() =&gt; new Array(n).fill(0))    // 边界情况    for (let i = 0; i&lt;m; i++) arr[i][0] = 1    for (let i = 0; i&lt;n; i++) arr[0][i] = 1    // 动态方程    for (let i = 1; i&lt;m; i++) &#123;        for (let j = 1; j&lt;n; j++) &#123;            arr[i][j] = arr[i-1][j] + arr[i][j-1]        &#125;    &#125;    return arr[m-1][n-1]&#125;;</code></pre><p id="u014e65a9" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1652015457078-4895e20f-7f29-463d-aaa7-97715d3dcd54.png" width="628.333308365611" id="u516534aa" class="ne-image"></p></div>]]></content>
      
      
      <categories>
          
          <category> 计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 🔢动态规划算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>112. 路径总和🔖DFS</title>
      <link href="/blog/alrzw2/"/>
      <url>/blog/alrzw2/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><ul class="ne-ul"><li id="ua36bd7a2"><a href="https://leetcode-cn.com/problems/path-sum/" data-href="https://leetcode-cn.com/problems/path-sum/" target="_blank" class="ne-link"><span class="ne-text">https://leetcode-cn.com/problems/path-sum/</span></a></li></ul><p id="u349f23d1" class="ne-p"><span class="ne-text"></span></p><pre><code>/** * Definition for a binary tree node. * function TreeNode(val, left, right) &#123; *     this.val = (val===undefined ? 0 : val) *     this.left = (left===undefined ? null : left) *     this.right = (right===undefined ? null : right) * &#125; *//** * @param &#123;TreeNode&#125; root * @param &#123;number&#125; targetSum * @return &#123;boolean&#125; */var hasPathSum = function(root, targetSum) &#123;    let result = false    let dfs = (data, presum, tar) =&gt; &#123;        if (data) &#123;            presum = data.val + presum            if (!data.left &amp;&amp; !data.right) &#123;                if (presum == tar) &#123;                    result = true                &#125;            &#125;            dfs(data.left, presum, tar)            dfs(data.right, presum, tar)        &#125;    &#125;    dfs(root, 0, targetSum)    return result&#125;;</code></pre><p id="ubb6e5da4" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1651412804694-76d5dacc-2cbe-4170-a04f-4af28bfa1d6f.png" width="719.9999713897716" id="ud5bb75fc" class="ne-image"></p></div>]]></content>
      
      
      <categories>
          
          <category> 计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 🌲树结构：二叉树-哈夫曼树 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>100. 相同的树🔖BFS🔖DFS</title>
      <link href="/blog/imt8ld/"/>
      <url>/blog/imt8ld/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><ul class="ne-ul"><li id="u4caaba6d"><a href="https://leetcode-cn.com/problems/same-tree/" data-href="https://leetcode-cn.com/problems/same-tree/" target="_blank" class="ne-link"><span class="ne-text">https://leetcode-cn.com/problems/same-tree/</span></a></li></ul><p id="u88c6e409" class="ne-p"><span class="ne-text"></span></p><h3 id="h4eM0"><span class="ne-text">BFS</span></h3><pre><code>/** * Definition for a binary tree node. * function TreeNode(val, left, right) &#123; *     this.val = (val===undefined ? 0 : val) *     this.left = (left===undefined ? null : left) *     this.right = (right===undefined ? null : right) * &#125; *//** * @param &#123;TreeNode&#125; p * @param &#123;TreeNode&#125; q * @return &#123;boolean&#125; */var isSameTree = function(p, q) &#123;    if (p === null &amp;&amp; q === null) return true    if (p === null || q === null) return false    <pre><code>let que_1 = [p]let que_2 = [q]while(que_1.length !== 0) &#123;    let que_1_size = que_1.length    let que_2_size = que_2.length    if (que_1_size !== que_2_size) return false    for (let i = 0; i&amp;lt;que_1_size; i++) &#123;        let mp1 = que_1.shift()        let mp2 = que_2.shift()        if (mp1.val !== mp2.val) return false        if (mp1.left &amp;amp;&amp;amp; mp2.left) &#123;            que_1.push(mp1.left)            que_2.push(mp2.left)        &#125; else if(!mp1.left &amp;amp;&amp;amp; !mp2.left)&#123;&#125; else &#123;            return false        &#125;        if (mp1.right &amp;amp;&amp;amp; mp2.right) &#123;            que_1.push(mp1.right)            que_2.push(mp2.right)        &#125; else if(!mp1.right &amp;amp;&amp;amp; !mp2.right)&#123;&#125; else &#123;            return false        &#125;    &#125;&#125;return true</code></pre><p>};<br></code></pre></p><p id="u2a1b40a8" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1652015502900-ce25f41b-27ba-42d1-aba5-574187e8e2b8.png" width="630.8333082662698" id="u588d5535" class="ne-image"></p><h3 id="fOcqM"><span class="ne-text">DFS</span></h3><p id="ud9083096" class="ne-p"><span class="ne-text">肝不动了，直接暴力run ok就行</span></p><pre><code>/** * Definition for a binary tree node. * function TreeNode(val, left, right) &#123; *     this.val = (val===undefined ? 0 : val) *     this.left = (left===undefined ? null : left) *     this.right = (right===undefined ? null : right) * &#125; *//** * @param &#123;TreeNode&#125; p * @param &#123;TreeNode&#125; q * @return &#123;boolean&#125; */var isSameTree = function(p, q) &#123;    let result = true    if (p === null &amp;&amp; q === null) return result    if (p === null || q === null) return !result    let arr_1 = []    let arr_2 = []    let dfs = (data, arr) =&gt; &#123;        if (data) &#123;            arr.push(data.val)            if (data.left) &#123;                dfs(data.left, arr)            &#125; else &#123;                arr.push(99999)            &#125;            if (data.right) &#123;                dfs(data.right, arr)            &#125; else &#123;                arr.push(99999)            &#125;            <pre><code>    &#125; &#125;dfs(p, arr_1)dfs(q, arr_2)if (arr_1.length !== arr_2.length) result = falsearr_1.forEach((data, index) =&amp;gt; &#123;    if (data !== arr_2[index]) &#123;        result = false    &#125;&#125;)return result</code></pre><p>};<br></code></pre></p><p id="ufa7f6e11" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1652015520028-ccb54006-a5de-4448-8501-d6570716c111.png" width="636.6666413678073" id="u4ffec31d" class="ne-image"></p></div>]]></content>
      
      
      <categories>
          
          <category> 计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 🌲树结构：二叉树-哈夫曼树 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>102. 二叉树的层序遍历🔖BFS</title>
      <link href="/blog/by7bg0/"/>
      <url>/blog/by7bg0/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><ul class="ne-ul"><li id="u33c6c359"><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/" data-href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/" target="_blank" class="ne-link"><span class="ne-text">https://leetcode-cn.com/problems/binary-tree-level-order-traversal/</span></a></li></ul><p id="uf4f66dda" class="ne-p"><span class="ne-text">广度优先搜索</span></p><p id="u901c812d" class="ne-p"><span class="ne-text"></span></p><pre><code>/** * Definition for a binary tree node. * function TreeNode(val, left, right) &#123; *     this.val = (val===undefined ? 0 : val) *     this.left = (left===undefined ? null : left) *     this.right = (right===undefined ? null : right) * &#125; *//** * @param &#123;TreeNode&#125; root * @return &#123;number[][]&#125; */var levelOrder = function(root) &#123;    if(!root) return []    let result = []    let que = []    que.push(root)    while(que.length !== 0) &#123;        let init_size = que.length        let temp = []        for (let i = 0; i&lt;init_size; i++) &#123;            let mp = que.shift()            if(mp.left) que.push(mp.left)            if(mp.right) que.push(mp.right)            temp.push(mp.val)        &#125;        result.push(temp)    &#125;<pre><code>return result</code></pre><p>};<br></code></pre></p><p id="u50a3c995" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1652015568860-91161da1-00e3-41d8-9024-9d860fa22e9c.png" width="630.8333082662698" id="ucd610f2e" class="ne-image"></p></div>]]></content>
      
      
      <categories>
          
          <category> 计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 🌲树结构：二叉树-哈夫曼树 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>129. 求根节点到叶节点数字之和🔖DFS</title>
      <link href="/blog/thy7mx/"/>
      <url>/blog/thy7mx/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><ul class="ne-ul"><li id="u6a1cce50"><a href="https://leetcode-cn.com/problems/sum-root-to-leaf-numbers/" data-href="https://leetcode-cn.com/problems/sum-root-to-leaf-numbers/" target="_blank" class="ne-link"><span class="ne-text">https://leetcode-cn.com/problems/sum-root-to-leaf-numbers/</span></a></li></ul><p id="ufc5039cc" class="ne-p"><span class="ne-text"></span></p><h3 id="dyUoI"><span class="ne-text">dfs</span></h3><pre><code>/** * Definition for a binary tree node. * function TreeNode(val, left, right) &#123; *     this.val = (val===undefined ? 0 : val) *     this.left = (left===undefined ? null : left) *     this.right = (right===undefined ? null : right) * &#125; *//** * @param &#123;TreeNode&#125; root * @return &#123;number&#125; */var sumNumbers = function(root) &#123;    if (!root) return root    let arr = []    let result = 0    let dfs = (data, presum) =&gt; &#123;        if (data) &#123;            presum = data.val + presum * 10            if (!data.left &amp;&amp; !data.right)                arr.push(presum)            else &#123;                dfs(data.left, presum)                dfs(data.right, presum)            &#125;        &#125;    &#125;    dfs(root, 0)    result = arr.reduce((a, b) =&gt; &#123;return a + b&#125;)    return result&#125;;</code></pre><p id="u6922ddff" class="ne-p"><span class="ne-text">优化一下得到：</span></p><pre><code>/** * Definition for a binary tree node. * function TreeNode(val, left, right) &#123; *     this.val = (val===undefined ? 0 : val) *     this.left = (left===undefined ? null : left) *     this.right = (right===undefined ? null : right) * &#125; *//** * @param &#123;TreeNode&#125; root * @return &#123;number&#125; */var sumNumbers = function(root) &#123;    let dfs = (data, presum) =&gt; &#123;        if (data === null) return 0        presum = data.val + presum * 10        if (!data.left &amp;&amp; !data.right) &#123;            return presum        &#125;        return dfs(data.left, presum) + dfs(data.right, presum)    &#125;    return dfs(root, 0)&#125;;</code></pre><p id="ub2e4a533" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1652015642635-9c156952-829a-4fe0-9659-13773d03152d.png" width="620.8333086636342" id="u5238ad6b" class="ne-image"></p></div>]]></content>
      
      
      <categories>
          
          <category> 计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 🌲树结构：二叉树-哈夫曼树 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>222. 完全二叉树的节点个数🔖DFS</title>
      <link href="/blog/ktp9xg/"/>
      <url>/blog/ktp9xg/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><ul class="ne-ul"><li id="u07a8ac51"><a href="https://leetcode-cn.com/problems/count-complete-tree-nodes/" data-href="https://leetcode-cn.com/problems/count-complete-tree-nodes/" target="_blank" class="ne-link"><span class="ne-text">https://leetcode-cn.com/problems/count-complete-tree-nodes/</span></a></li></ul><p id="ub8a1fd4e" class="ne-p"><span class="ne-text"></span></p><p id="ua0193dda" class="ne-p"><span class="ne-text">思路：</span></p><p id="ude5f7034" class="ne-p"><span class="ne-text">通法就是递归，其他方法暂不考虑</span></p><pre><code>/** * Definition for a binary tree node. * function TreeNode(val, left, right) &#123; *     this.val = (val===undefined ? 0 : val) *     this.left = (left===undefined ? null : left) *     this.right = (right===undefined ? null : right) * &#125; *//** * @param &#123;TreeNode&#125; root * @return &#123;number&#125; */var countNodes = function(root) &#123;    let result = 0    let nodes = data =&gt; &#123;        if (data) &#123;                        nodes(data.left)            nodes(data.right)            result++        &#125;    &#125;    nodes(root)    return result&#125;;</code></pre><p id="u665d3829" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1652015619370-5b367d0f-0a6d-4017-92cd-d370355d74bc.png" width="628.333308365611" id="ud7655360" class="ne-image"></p></div>]]></content>
      
      
      <categories>
          
          <category> 计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 🌲树结构：二叉树-哈夫曼树 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>922. 按奇偶排序数组 II🔖暴力</title>
      <link href="/blog/hfqwr9/"/>
      <url>/blog/hfqwr9/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><ul class="ne-ul"><li id="ud64ba08c"><a href="https://leetcode-cn.com/problems/sort-array-by-parity-ii/" data-href="https://leetcode-cn.com/problems/sort-array-by-parity-ii/" target="_blank" class="ne-link"><span class="ne-text">https://leetcode-cn.com/problems/sort-array-by-parity-ii/</span></a></li></ul><p id="u964fd2bb" class="ne-p"><br></p><p id="u9d6469a0" class="ne-p"><span class="ne-text">思路：我特喵的直接暴力解法</span></p><p id="u019aab45" class="ne-p"><span class="ne-text"></span></p><pre><code>/** * @param &#123;number[]&#125; nums * @return &#123;number[]&#125; */var sortArrayByParityII = function(nums) &#123;    let arr = []    let arr_ou = []    let arr_ji = []    nums.forEach(data =&gt; &#123;        data % 2 === 0 ? arr_ou.push(data) : arr_ji.push(data)    &#125;)    for (let i = 0; i&lt;arr_ji.length ;i++) &#123;        arr[i * 2] = arr_ou[i]        arr[i * 2 + 1] = arr_ji[i]    &#125;    return arr&#125;;</code></pre><p id="u3219963b" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1651392122716-c4681176-5009-40b5-958f-e5221988a605.png" width="664.1666402750556" id="u4d6b42ad" class="ne-image"></p></div>]]></content>
      
      
      <categories>
          
          <category> 计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 📊查找排序算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>164. 最大间距🔖排序🔖array.sort🔖冒泡排序</title>
      <link href="/blog/szmcwf/"/>
      <url>/blog/szmcwf/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><ul class="ne-ul"><li id="u3630a41a"><a href="https://leetcode-cn.com/problems/maximum-gap/" data-href="https://leetcode-cn.com/problems/maximum-gap/" target="_blank" class="ne-link"><span class="ne-text">https://leetcode-cn.com/problems/maximum-gap/</span></a></li></ul><p id="u740a0366" class="ne-p"><span class="ne-text"></span></p><h3 id="liEvF"><span class="ne-text">array.sort</span></h3><pre><code>/** * @param &#123;number[]&#125; nums * @return &#123;number&#125; */var maximumGap = function(nums) &#123;    let result = 0    if(nums.length &lt; 2) return result    nums.sort((a, b) =&gt; &#123;return a - b&#125;).forEach((data, index) =&gt; &#123;        if (index &lt; nums.length - 1) &#123;            result = result &gt; nums[index + 1] - data ? result : nums[index + 1] - data        &#125;    &#125;)    return result&#125;;</code></pre><p id="u579e3795" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1651388338749-eedd3c62-5fa2-47c1-b44d-76a007fe023f.png" width="624.1666418645127" id="u4ad07262" class="ne-image"></p><h3 id="hoahQ"><span class="ne-text">冒泡排序</span></h3><p id="u0d4555f0" class="ne-p"><span class="ne-text">也可以利用冒泡排序，在最后两项排完，比较差值然后与result对比</span></p></div>]]></content>
      
      
      <categories>
          
          <category> 计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 📊查找排序算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>148. 排序链表🔖链表🔖js初始化单链表</title>
      <link href="/blog/cput4h/"/>
      <url>/blog/cput4h/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h3 id="fsJ6t"><span class="ne-text">148. 排序链表</span></h3><ul class="ne-ul"><li id="u102e7213"><a href="https://leetcode-cn.com/problems/sort-list/" data-href="https://leetcode-cn.com/problems/sort-list/" target="_blank" class="ne-link"><span class="ne-text">https://leetcode-cn.com/problems/sort-list/</span></a></li></ul><pre><code>/** * Definition for singly-linked list. * function ListNode(val, next) &#123; *     this.val = (val===undefined ? 0 : val) *     this.next = (next===undefined ? null : next) * &#125; *//** * @param &#123;ListNode&#125; head * @return &#123;ListNode&#125; */var sortList = function(head) &#123;    if (head === null) return head    let arr = []    while (head !== null) &#123;        arr.push(head.val)        head = head.next    &#125;    let result = arr.sort((a, b) =&gt; &#123;return a - b&#125;)    let result_head = new ListNode(result[0], null)    let test = result_head    result.forEach((data, index) =&gt; &#123;        if (index !== 0) &#123;            let temp = new ListNode(data,null)            test.next = temp            test = temp        &#125;    &#125;)    return result_head&#125;;</code></pre><h3 id="YQj2X"><span class="ne-text">js初始化单链表</span></h3><pre><code>// 节点class Node &#123;  constructor(value) &#123;    this.val = value    this.next = null  &#125;&#125;<p>// 利用数组来初始化单链表<br>class NodeList &#123;<br>  constructor(arr) &#123;<br>    let head = new Node(arr.shift())<br>    let next = head<br>    arr.forEach(data =&gt; &#123;<br>      next.next = new Node(data)<br>      next = next.next<br>    &#125;)<br>    return head<br>  &#125;<br>&#125;</p><p>let test = new NodeList([1, 2, 3, 4])<br>while (test !== null) &#123;<br>  console.log(test.val)<br>  test = test.next<br>&#125;<br></code></pre></p></div>]]></content>
      
      
      <categories>
          
          <category> 计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 📎线结构：链表 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>VScode集成ESLint和Prettier和Editorconfig代码校验格式化环境</title>
      <link href="/blog/mkn98t/"/>
      <url>/blog/mkn98t/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="u42209bd7" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1658395016294-08433da7-eb86-4b66-a9bb-21ff5fc5e075.png" width="205" id="ue65dcde3" class="ne-image"></p><p id="u7b0e332e" class="ne-p"><span class="ne-text">前言：</span></p><ul class="ne-ul"><li id="u1319ddec"><span class="ne-text">前三个是根据项目格式化配置来格式化</span></li><li id="u29540e3a"><span class="ne-text">第四个是vue2高亮</span></li><li id="u4ff4ebf1"><span class="ne-text">最后一个（Vue3推荐的）对代码格式化器二选一冲突</span></li></ul><ul class="ne-ul"><li id="ue4aec3f0"><span class="ne-text">vscode插件：eslint、prettier、Editorconfig</span></li></ul><h2 id="sFMfa"><span class="ne-text">vscode插件</span></h2><h3 id="h0Bj3"><span class="ne-text">ESLint</span></h3><p id="u4c54dfd4" class="ne-p"><span class="ne-text">格式化检测工具：会给出警告抑或是报错，但不会修改</span></p><h3 id="qq5f8"><span class="ne-text">Prettier - Code formatter</span></h3><p id="u2bc455ee" class="ne-p"><span class="ne-text">代码格式化插件：按照所需配置直接格式化代码</span></p><h2 id="o9fJW"><span class="ne-text">eslint插件（解决冲突）</span></h2><h3 id="EHhwf"><span class="ne-text">eslint-plugin-html</span></h3><p id="u84ebd259" class="ne-p"><span class="ne-text">目的是为了检测html文件中的js代码，全局下载，让设备非node项目也能使用</span></p><pre><code>npm install -g eslint-plugin-html</code></pre><p id="u43b1986c" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1640400558364-b89c0585-1302-4515-b27a-bdb053cf8701.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_47%2Ctext_5bC86YeH6Iis5Zyw5oqS5oOF%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10" width="828" id="uc4ceedb9" class="ne-image"></p><p id="u8bca4c3c" class="ne-p"><span class="ne-text">每次打开html，eslint就会报错：</span></p><pre><code>'plugins' doesn't add plugins to configuration to load. Please use the 'overrideConfig.plugins' option instead.</code></pre><p id="u075e0d78" class="ne-p"><span class="ne-text">官网issues </span><a href="https://github.com/microsoft/vscode-eslint/issues/1376" data-href="https://github.com/microsoft/vscode-eslint/issues/1376" target="_blank" class="ne-link"><span class="ne-text">https://github.com/microsoft/vscode-eslint/issues/1376</span></a><span class="ne-text"> 中貌似也并未给出根治方法，暂时禁用：</span></p><p id="uad85479a" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1640401735422-2e618454-6752-4b2e-9020-8788d0ad114d.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_21%2Ctext_5bC86YeH6Iis5Zyw5oqS5oOF%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10" width="365" id="u7b0c7db1" class="ne-image"></p></div>]]></content>
      
      
      <categories>
          
          <category> 环境工具 </category>
          
          <category> 工具使用 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>维</title>
      <link href="/essay/hq3fcy/"/>
      <url>/essay/hq3fcy/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="u96c35fa4" class="ne-p"><span class="ne-text">意念是多维化的体现。</span></p><p id="uba8fa4b2" class="ne-p"><span class="ne-text"></span></p><p id="u2d275003" class="ne-p"><span class="ne-text">在宇宙的浩瀚星辰中，难以被人们所定义的是空间，空间的等价转化则是维度，换言之，维度是人类难以捕捉的而又不时出现在我们日常生活中。 </span></p><p id="u697a6245" class="ne-p"><span class="ne-text"></span></p><p id="ue16ebb28" class="ne-p"><span class="ne-text">冥想是即达多维空间目的地的不错选择，冥想让我们建立思维上的楼阁，看是虚无，实则通往多维空间。 </span></p><p id="u04a7864a" class="ne-p"><span class="ne-text"></span></p><p id="uc3a69b06" class="ne-p"><span class="ne-text">任何事物都需要沟通，人类文明创立以来，进制是创先河之例，打开了与计算机沟通的大门。其实此则不然，在永恒事物变相中，有一种沟通方式可以让万物联系——多维化零进制。</span></p><p id="u59bd2bab" class="ne-p"><span class="ne-text"></span></p><p id="u3189b74e" class="ne-p"><span class="ne-text">那是谁拾起探索的光辉？又是谁如先驱们般开始质疑身边的科学，一切的一切由维度引起——多维化平行宇宙空间……</span></p><p id="u7749951d" class="ne-p"><span class="ne-text"></span></p><p id="ude271eae" class="ne-p"><span class="ne-text"></span></p></div>]]></content>
      
      
      <categories>
          
          <category> 异世界 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>645. 错误的集合🔖数组</title>
      <link href="/blog/vvs5xy/"/>
      <url>/blog/vvs5xy/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><ul class="ne-ul"><li id="u8d9d555a"><a href="https://leetcode-cn.com/problems/set-mismatch/" data-href="https://leetcode-cn.com/problems/set-mismatch/" target="_blank" class="ne-link"><span class="ne-text">https://leetcode-cn.com/problems/set-mismatch/</span></a></li></ul><p id="uf83dc93a" class="ne-p"><span class="ne-text">想着中午写道简单题，喵的，丧失一天学习心情……</span></p><p id="u4e2b75ae" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1648964102729-2472a01f-8d16-416d-9f17-f8f9ff9acd52.png" width="268.015625" id="ufbf4071b" class="ne-image"></p><pre><code>function findErrorNums(nums: number[]): number[] &#123;    let result: any = []    nums.sort((a: number, b:number) =&gt; &#123; return a - b &#125;)    nums.forEach((data: number, index: number) =&gt; &#123;        // 重复的值        if (data === nums[index - 1]) &#123;            result.unshift(data)            nums.splice(index, 1)            nums.push(0)            // 丢失的值            for (let i: number = 0; i &lt; nums.length; i++) &#123;                if(i + 1 !== nums[i]) &#123;                    result.push(i + 1)                    break                &#125;            &#125;        &#125;    &#125;)    return result&#125;;</code></pre></div>]]></content>
      
      
      <categories>
          
          <category> 计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 📶线结构：字符串-数组-栈-队列 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>TODO: 30. 串联所有单词的子串🔖递归</title>
      <link href="/blog/lgg15d/"/>
      <url>/blog/lgg15d/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><ul class="ne-ul"><li id="u923bba18"><a href="https://leetcode-cn.com/problems/substring-with-concatenation-of-all-words/" data-href="https://leetcode-cn.com/problems/substring-with-concatenation-of-all-words/" target="_blank" class="ne-link"><span class="ne-text">https://leetcode-cn.com/problems/substring-with-concatenation-of-all-words/</span></a></li></ul><p id="uc4ca95dc" class="ne-p"><span class="ne-text"></span></p><h3 id="eY8Jl"><span class="ne-text">思路</span></h3></div>]]></content>
      
      
      <categories>
          
          <category> 计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 🌌递归算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>93. 复原 IP 地址🔖递归</title>
      <link href="/blog/aucxuf/"/>
      <url>/blog/aucxuf/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><ul class="ne-ul"><li id="u548cf5a7"><a href="https://leetcode-cn.com/problems/restore-ip-addresses/" data-href="https://leetcode-cn.com/problems/restore-ip-addresses/" target="_blank" class="ne-link"><span class="ne-text">https://leetcode-cn.com/problems/restore-ip-addresses/</span></a></li></ul><p id="u300a127c" class="ne-p"><span class="ne-text"></span></p><h3 id="Uh8J5"><span class="ne-text">思路</span></h3><ul class="ne-ul"><li id="u123f0828"><span class="ne-text">长度为12位：最小单元位3</span></li><li id="u999a712f"><span class="ne-text">长度为11位：最小单元位2</span></li><li id="u00b89315"><span class="ne-text">其他情况的最小单元位有可能是1</span></li></ul><p id="u07aa0710" class="ne-p"><span class="ne-text"></span></p><h3 id="P81a3"><span class="ne-text">ts代码</span></h3><pre><code>function restoreIpAddresses(s: string): string[] &#123;  // 保存所有符合条件的IP地址  let r: any[] = []  // 分四步递归处理ip分段  let search = (cur: any, sub: any) =&gt; &#123;    if (sub.length &gt; 12) return    <pre><code>// 边界条件if (cur.length === 4 &amp;amp;&amp;amp; cur.join(&#39;&#39;) === s) &#123;  r.push(cur.join(&#39;.&#39;))&#125; else &#123;  // 正常的处理过程  for (let i = 0, len = Math.min(3, sub.length), tmp; i &amp;lt; len; i++) &#123;    tmp = sub.substr(0, i + 1)    if (tmp - 256 &amp;lt; 0) &#123;      // 转换下数据类型，如 01为1（LeetCode测试用例）      search(cur.concat([tmp * 1]), sub.substr(i + 1))    &#125;  &#125;&#125;</code></pre><p>  }<br>  search([], s)<br>  return r<br>}</p><p>console.log(restoreIpAddresses(‘101023’))<br></code></pre></p></div>]]></content>
      
      
      <categories>
          
          <category> 计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 🌌递归算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>TODO: 10. 正则表达式匹配🔖正则</title>
      <link href="/blog/qg73ng/"/>
      <url>/blog/qg73ng/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><ul class="ne-ul"><li id="u3ed91f86"><a href="https://leetcode-cn.com/problems/regular-expression-matching/" data-href="https://leetcode-cn.com/problems/regular-expression-matching/" target="_blank" class="ne-link"><span class="ne-text">https://leetcode-cn.com/problems/regular-expression-matching/</span></a></li></ul></div>]]></content>
      
      
      <categories>
          
          <category> 计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 📶线结构：字符串-数组-栈-队列 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>459. 重复的子字符串🔖正则🔖字符串</title>
      <link href="/blog/rqcfeh/"/>
      <url>/blog/rqcfeh/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><ul class="ne-ul"><li id="u683cc527"><a href="https://leetcode-cn.com/problems/repeated-substring-pattern/" data-href="https://leetcode-cn.com/problems/repeated-substring-pattern/" target="_blank" class="ne-link"><span class="ne-text">https://leetcode-cn.com/problems/repeated-substring-pattern/</span></a></li></ul><p id="ubdc16351" class="ne-p"><span class="ne-text"></span></p><h3 id="QfRo2"><span class="ne-text">思路</span></h3><p id="u85e94159" class="ne-p"><span class="ne-text">基本正则模式匹配</span></p><h3 id="uDb1q"><span class="ne-text">ts代码</span></h3><pre><code>function repeatedSubstringPattern(s: string): boolean &#123;  let reg: RegExp = /^(\w+)\1+$/  return reg.test(s)&#125;<p>console.log(repeatedSubstringPattern(‘abcabcabcabc’))<br></code></pre></p></div>]]></content>
      
      
      <categories>
          
          <category> 计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 📶线结构：字符串-数组-栈-队列 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>682. 棒球比赛🔖栈</title>
      <link href="/blog/srz8lz/"/>
      <url>/blog/srz8lz/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><ul class="ne-ul"><li id="u898cb1c6"><a href="https://leetcode-cn.com/problems/baseball-game/" data-href="https://leetcode-cn.com/problems/baseball-game/" target="_blank" class="ne-link"><span class="ne-text">https://leetcode-cn.com/problems/baseball-game/</span></a></li></ul><p id="ua5f6f7e4" class="ne-p"><span class="ne-text"></span></p><h3 id="FFVha"><span class="ne-text">思路</span></h3><p id="u706c01da" class="ne-p"><span class="ne-text">没啥好说的——栈的最基本理解</span></p><p id="uff6e69a2" class="ne-p"><span class="ne-text">js的栈实现是利用Array的push和pop……</span></p><p id="udae4c03c" class="ne-p"><span class="ne-text"></span></p><pre><code>function calPoints(ops: string[]): number &#123;  let sta: Array&lt;number&gt; = []  ops.forEach((data: string) =&gt; &#123;    switch (data) &#123;      case '+':        sta.push(sta[sta.length - 1] + sta[sta.length - 2])        break      case 'D':        sta.push(sta[sta.length - 1] * 2)        break      case 'C':        sta.pop()        break      default:        sta.push(Number(data))    &#125;  &#125;)<p>  return sta.reduce((result: number, index: number) =&gt; &#123;<br>    return result + index<br>  &#125;)<br>&#125;</p><p>console.log(calPoints([‘5’, ‘-2’, ‘4’, ‘C’, ‘D’, ‘9’, ‘+’, ‘+’]))<br></code></pre></p></div>]]></content>
      
      
      <categories>
          
          <category> 计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 📶线结构：字符串-数组-栈-队列 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>11. 盛最多水的容器🔖数组🔖双指针</title>
      <link href="/blog/amgx01/"/>
      <url>/blog/amgx01/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><ul class="ne-ul"><li id="ub9ee704f"><a href="https://leetcode-cn.com/problems/container-with-most-water/" data-href="https://leetcode-cn.com/problems/container-with-most-water/" target="_blank" class="ne-link"><span class="ne-text">https://leetcode-cn.com/problems/container-with-most-water/</span></a></li></ul><p id="ub4ceec83" class="ne-p"><span class="ne-text"></span></p><h3 id="wvuOt"><span class="ne-text">思路</span></h3><h4 id="zm5Lb"><span class="ne-text">暴力循环解决</span></h4><ul class="ne-ul"><li id="u9e4d4ab9"><span class="ne-text">对数组各个元素进行第一遍遍历，在此之中</span><strong><span class="ne-text">以该元素为基准</span></strong><span class="ne-text">对</span><strong><span class="ne-text">该元素后面的所有元素进行遍历</span></strong><span class="ne-text">，进行</span><code class="ne-code"><span class="ne-text">两者最短高度 * （后面元素下标 - 该元素下标）</span></code><span class="ne-text">运算，遍历完成即可得到上述值的最大值result。</span></li><li id="ub9c5a2fb"><span class="ne-text">该元素后面的所有元素进行遍历：这个循环是指定开始索引的位置往后进行的遍历，使用传统for循环或是for in循环</span></li></ul><p id="ub507a9bd" class="ne-p"><span class="ne-text"></span></p><p id="u3d71db66" class="ne-p"><span class="ne-text">这种解法会超时，写的时候我就感觉到了数组的双循环八成是超时，即便我是第二个循环不找全部元素，但还是超时n^2逃不掉</span><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/1484158/1648709054571-cb914e0d-2a17-4e20-bdb3-d0f105bec0fe.jpeg" width="52" id="u4K1n" class="ne-image"></p><pre><code>function maxArea(height: number[]): number &#123;  let result: number = 0  height.forEach((data: number, index: number) =&gt; &#123;    if (index !== height.length - 1) &#123;      for (let i: number = index + 1; i &lt; height.length; i++) &#123;        let result_temp = Math.min(height[i], data) * (i - index)        result &gt; result_temp ? (result = result) : (result = result_temp)      &#125;    &#125;  &#125;)  return result<p></code></pre></p><p id="u903f225f" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1648707457045-2a083f7a-faab-4354-91bf-7a6b9e45c867.png" width="1300.8332816428629" id="uc882220e" class="ne-image"></p><h4 id="bpe3H"><span class="ne-text">两端双指针移动解决</span></h4><ul class="ne-ul"><li id="u7385276d"><span class="ne-text">探究解决办法的规律来解决问题，利用双指针在首末端往中间靠，每次移动arr[指针]小的，然后在此次与result相比较。</span></li><li id="u3f46a4a7"><span class="ne-text">这样只需要遍历一遍即可，时间复杂度为n</span></li></ul><p id="u80e14356" class="ne-p"><span class="ne-text"></span></p><pre><code>function maxArea(height: number[]): number &#123;  let head: number = 0  let back: number = height.length - 1  const result_fun = (head: number, back: number): number =&gt; &#123;    return Math.min(height[head], height[back]) * (back - head)  &#125;  let result = result_fun(head, back)<p>  while (head !== back) &#123;<br>    height[head] &lt; height[back] ? head++ : back–<br>    if(result &lt;= result_fun(head, back) ) result = result_fun(head, back)<br>  &#125;</p><p>  return result<br>&#125;<br></code></pre></p><p id="u36e90195" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1648710814761-4255d705-1462-47ed-8a96-ad66c4bf25a6.png" width="599.999976158143" id="u401ae785" class="ne-image"></p><p id="u7cc03987" class="ne-p"><span class="ne-text"></span></p><p id="ucf47e7f1" class="ne-p"><span class="ne-text"></span></p><p id="u45d2fc7b" class="ne-p"><span class="ne-text"></span></p><p id="u85afaab6" class="ne-p"><span class="ne-text"></span></p><p id="u31ad7968" class="ne-p"><span class="ne-text"></span></p><p id="u3ea57d64" class="ne-p"><span class="ne-text"></span></p><p id="ucbf45dc3" class="ne-p"><span class="ne-text"></span></p><p id="u0d5526ac" class="ne-p"><span class="ne-text"></span></p><p id="ua16ce551" class="ne-p"><span class="ne-text"></span></p><p id="u1a516ef3" class="ne-p"><span class="ne-text"></span></p></div>]]></content>
      
      
      <categories>
          
          <category> 计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 📶线结构：字符串-数组-栈-队列 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>疫情下的空城与花海</title>
      <link href="/essay/gvzzcs/"/>
      <url>/essay/gvzzcs/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="ud8bce089" class="ne-p"><span class="ne-text">我们总喜欢作为旁观者去看待未能触及到自身的悲景，而这个世界上最悲观的身旁之物我想应该就是死亡了。</span></p><p id="u8d57e81f" class="ne-p"><span class="ne-text"></span></p><p id="u973b2519" class="ne-p"><strong><span class="ne-text">空城</span></strong></p><p id="u7c61ba01" class="ne-p"><span class="ne-text"></span></p><p id="ufb565da6" class="ne-p"><span class="ne-text">到现在已有两年之久的心冠疫情，或许就是近些年来让我们体会到死亡的传使者，生命变得消亡，聚集场所变得暗淡，像是给我们笼罩一层未能看见的阴霾，我很讨厌这么一个微小生生物为生活所带来的暗色调。</span></p><p id="u8fbaffd3" class="ne-p"><span class="ne-text"></span></p><p id="u4ec1ac32" class="ne-p"><span class="ne-text">东方航空MU5735的坠毁。在学校和家里的来往，我常坐飞机这一交通形式，我体验过飞机通过强气流带来的机体剧烈晃动，飞机失事的情况，我想，那几分钟是很绝望的，你只能坐在自己座椅上，被飞机下坠的惯性将自己身体硬拽在靠椅上，窗边呼啸的气流声，让你面无神色。我很讨厌大自然偶尔的霸道无理的脾气。</span></p><p id="u4140cd6c" class="ne-p"><span class="ne-text"></span></p><p id="uf876e599" class="ne-p"><strong><span class="ne-text">花海</span></strong></p><p id="ue1302591" class="ne-p"><span class="ne-text"></span></p><p id="u8508c042" class="ne-p"><span class="ne-text">学校的三月是一个有花的季节，成片的花香与色彩遍布整个校园。</span></p><p id="u2d0758a0" class="ne-p"><span class="ne-text">成片的花海是我22年觉得最美的一件事物，她将周围的灰色染成五彩斑斓的景色。</span></p><p id="u7d66b47e" class="ne-p"><span class="ne-text"></span></p><p id="uf6e113a6" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/1484158/1648700562531-b0b2bf77-4d97-40e1-a7b0-880d8d188c60.jpeg" width="1216" id="rGCAP" class="ne-image"></p><p id="u89ecd93d" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/1484158/1648700589001-880ca871-1ae5-4ab0-8093-5b09c50f8f63.jpeg" width="1216" id="yMKAc" class="ne-image"></p><p id="u7631b671" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/1484158/1648700686067-283184da-ffb4-4ff7-84b3-465dbcdfa76b.jpeg" width="1216" id="dblVL" class="ne-image"></p><p id="uf5316d82" class="ne-p"><span class="ne-text"></span></p><p id="u0296b290" class="ne-p"><span class="ne-text">花会枯萎，树会凋零，一瞬的美好终会陨落</span></p><p id="ue354674b" class="ne-p"><span class="ne-text">一瞬美好存于此的的意义会是什么呢</span></p><p id="u2e9b7c93" class="ne-p"><span class="ne-text">我不曾知道，也未曾想过</span></p><p id="ue4180be1" class="ne-p"><span class="ne-text">可是这些一个月的美丽都不曾保留的美丽，让我些许顿悟</span></p><p id="u3c7db598" class="ne-p"><span class="ne-text">美好的意义或许就是美好本身，她不需要太多的形容</span></p><p id="u86939c2e" class="ne-p"><span class="ne-text">你会因为她的绽放感到开心、感到愉悦、感到这世上原来还有这么美好的事物</span></p><p id="u98e389c4" class="ne-p"><span class="ne-text"></span></p><p id="ub40bc1ea" class="ne-p"><span class="ne-text">任何事物的存在都必然伴随着其存在的意义</span></p><p id="u28a79194" class="ne-p"><br></p></div>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>从输入 URL 到页面加载完成，发生了什么？在此流程中做优化！</title>
      <link href="/blog/lvs755/"/>
      <url>/blog/lvs755/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="u2fc17575" class="ne-p"><span class="ne-text">前言：从输入 URL 到页面加载完成，发生了什么？</span></p><p id="uddb4c6a5" class="ne-p"><span class="ne-text"></span></p><p id="uc5de653e" class="ne-p"><span class="ne-text">输入URL，浏览器会先处理输入的信息是搜索信息还是URL请求连接，这个过程需要浏览器的URL解析操作；然后我们需要通过 DNS（域名解析系统）将 URL 解析为对应的 IP 地址，然后与这个 IP 地址确定的那台服务器建立起 TCP 网络连接，随后我们向服务端抛出我们的 HTTP 请求，服务端处理完我们的请求之后，把目标数据放在 HTTP 响应里返回给客户端，拿到响应数据的浏览器就可以开始走一个渲染的流程。渲染完毕，页面便呈现给了用户，并时刻等待响应用户的操作。</span></p><p id="uc80a875b" class="ne-p"><span class="ne-text"></span></p><p id="u561ad2be" class="ne-p"><span class="ne-text">具体大致过程如下：</span></p><ol class="ne-ol"><li id="u067f5cbc"><span class="ne-text">URL解析</span></li><li id="uc53e72f2"><span class="ne-text">DNS解析</span></li><li id="u2b6e56f3"><span class="ne-text">TCP连接</span></li><li id="uce68944d"><span class="ne-text">客户端发送请求</span></li><li id="u46165cd2"><span class="ne-text">服务端处理请求，响应请求</span></li><li id="uae7019d8"><span class="ne-text">客户端和服务端断开连接</span></li><li id="u1a074c0e"><span class="ne-text">浏览器拿到响应数据，解析响应内容，把解析的结果渲染展示给用户</span></li></ol><p id="ub70b78cb" class="ne-p"><span class="ne-text"></span></p><p id="u01bae1f7" class="ne-p"><span class="ne-text">而前端性能优化，就是把这 5 个过程滴水不漏地考虑到自己的性能优化方案内、反复权衡，从而打磨出用户满意的速度。</span></p><p id="u19e8d619" class="ne-p"><span class="ne-text"></span></p><div class="ne-quote"><p id="u3c39882e" class="ne-p"><span class="ne-text">文章参考以下两个文章，基于以下文章并做出部分自己的修改：</span></p><ul class="ne-ul"><li id="u14c64fe7"><a href="https://www.kancloud.cn/sllyli/performance/1242194" data-href="https://www.kancloud.cn/sllyli/performance/1242194" target="_blank" class="ne-link"><span class="ne-text">前端性能优化原理与实践</span></a></li><li id="u66e796d7"><a href="https://juejin.cn/post/6844904194801926157" data-href="https://juejin.cn/post/6844904194801926157" class="ne-link"><span class="ne-text">从输入URL到渲染全过程</span></a></li><li id="ue1c40704"><a href="https://segmentfault.com/a/1190000017184701" data-href="https://segmentfault.com/a/1190000017184701" target="_blank" class="ne-link"><span class="ne-text">从URL输入到页面展现到底发生什么？</span></a></li></ul></div><h2 id="fkLx5"><span class="ne-text">一、URL解析与缓存检查</span></h2><h3 id="sBzKf"><span class="ne-text">地址解析和编码</span></h3><p id="ub827738a" class="ne-p"><span class="ne-text">我们输入URL后，浏览器会解析输入的字符串，判断是URL还是搜索关键字，如果是URL就开始编码。<br /></span></p><p id="udef58a97" class="ne-p"><span class="ne-text">一般来说URL只能使用英文字母、阿拉伯数字和某些标点符号，不能使用其他文字和符号，所以，如果URL中有文字就必须编码后使用。但是URL编码很混乱，不同的操作系统、浏览器、网页字符集，会导致不同的编码结果。所以我们需要使用JavaScript先对URL编码，然后提交给服务器，不给浏览器插手的机会。我们通常会使用encodeURI()函数或者encodeURIComponent()函数来编码URL</span></p><h3 id="IMnj6"><span class="ne-text">HSTS</span></h3><p id="uc5ae8a65" class="ne-p"><span class="ne-text">HSTS(HTTP Strict TransportSecurity)是一种新的Web安全协议，HSTS的作用是强制客户端使用HTTPS与服务器创建连接。比如你在地址栏输入http://xxx/，浏览器会自动将http转写成https，然后直接向</span><span class="ne-text">https://xxx/</span><span class="ne-text"> 发送请求。</span></p><h3 id="h3tJI"><span class="ne-text">缓存检查</span></h3><p id="uff4993aa" class="ne-p"><span class="ne-text">浏览器在发送请求之前先检查有没有缓存，过程如下： </span><img src="https://cdn.nlark.com/yuque/0/2022/webp/1484158/1653193882930-3c261c9c-875f-4ee5-994b-e8fcf22272ee.webp" width="556" id="ue084b2ed" class="ne-image"></p><p id="u9a262410" class="ne-p"><span class="ne-text">浏览器会先去查看强缓存（Expires和cache-control）判断是否过期，如果强缓存生效，直接从缓存中读取资源；若不生效则进行协商缓存(Last-Modified / If-Modified-Since和Etag/If-None-Match)，协商缓存由服务器决定是否使用缓存，若协商缓存失效，那么代表该请求的缓存失效，返回200，并重新返回资源和缓存标识，再次存入浏览器缓存中；生效则返回304，并从缓存中读取资源。（协商缓存之前要经过DNS域名解析，之后建立TCP链接）</span></p><p id="u05f4739d" class="ne-p"><span class="ne-text"></span></p><p id="u40bf2323" class="ne-p"><span class="ne-text">那么浏览器缓存的位置在哪呢？</span></p><ul class="ne-ul"><li id="u2a691d56"><span class="ne-text">Service Worker：浏览器独立线程进行缓存</span></li><li id="ub192ead7"><span class="ne-text">Memory Cache：内存缓存</span></li><li id="ue8f5ead7"><span class="ne-text">Disk Cache：硬盘缓存</span></li><li id="u7ec40f81"><span class="ne-text">Push Cache：推送缓存（HTTP/2中的）</span></li></ul><p id="u702a4534" class="ne-p"><span class="ne-text"></span></p><p id="uca2781b8" class="ne-p"><strong><span class="ne-text">注意</span></strong><span class="ne-text">：输入网址之后，会查找内存缓存，没有再找硬盘，都没有就发生网络请求。 普通刷新（F5）：因为TAB没有关闭，所以内存缓存可用，如果匹配上会被优先使用，其次是磁盘缓存 强制刷新（Ctrl+F5）：浏览器不使用缓存，因此发送的请求头均带有Cache-control：no-cache,服务器直接返回200和最新内容。</span></p><h2 id="rq2lt"><span class="ne-text">二、DNS解析</span></h2><h3 id="Ods3i"><span class="ne-text">DNS</span></h3><ul class="ne-ul"><li id="u366d3502"><span class="ne-text">DNS：把域名和ip地址相互映射分布式数据库，让用户能更方便的访问互联网，DNS协议运行在UDP协议之上</span></li><li id="u6affd3cd"><span class="ne-text">DNS解析：通过域名最终得到对应ip地址的过程。</span></li><li id="u18654d17"><span class="ne-text">DNS缓存：浏览器，操作系统，路由器，本地DNS，根域名服务器都会对DNS结果作出一定的缓存</span></li></ul><h3 id="qAZgt"><span class="ne-text">DNS解析过程</span></h3><ol class="ne-ol"><li id="u2ecc5cd1"><span class="ne-text">首先搜索浏览器自身的DNS缓存，有缓存直接返回;</span></li><li id="ue9619d95"><span class="ne-text">浏览器自身DNS不存在，浏览器就会调用一个类似gethostbyname的库函数,此函数会先去检测本地hosts文件，查看是否有对应ip。</span></li><li id="ub5969738"><span class="ne-text">如果本地hosts文件不存在映射关系，就会查询路由缓存，路由缓存不存在就去查找本地DNS服务器（一般TCP/IP参数里会设首选DNS服务器，通常是8.8.8.8)(客户端到本地DNS服务器是递归过程）</span></li><li id="ue13d369c"><span class="ne-text">如果本地DNS服务器还没找到就会向根服务器发出请求。（DNS服务器之间是迭代过程）</span></li></ol><p id="u9c37fde4" class="ne-p"><br></p><p id="ub4d0dd01" class="ne-p"><span class="ne-text">具体过程：<br /></span></p><ul class="ne-ul"><li id="u63850f02"><span class="ne-text">本地DNS服务器代我们的浏览器发起迭代DNS解析请求，首先它会找根域的DNS的IP地址（全球13台哟，可惜中国没有！）。找到根域的DNS地址,就会向其发起请求（请问www.baidu.com这个域名的IP地址是多少呀？）；<br /></span></li><li id="uc68a7e80"><span class="ne-text">根域发现这是一个顶级域com域的一个域名，于是告诉本地DNS服务器我不知道这个域名的IP地址,但是我知道com域的IP地址，你去找它去吧；<br /></span></li><li id="ua40604c7"><span class="ne-text">于是本地DNS服务器就得到了com域的IP地址，又向com域的IP地址发起了请求（请问www.baidu.com这个域名的IP地址是多少呀?）,于是com域服务器告诉本地DNS服务器我不知道www.baidu.com这个域名的IP地址，但是我知道baidu.com这个域的DNS地址，你去找它去;<br /></span></li><li id="ufaa1d0a0"><span class="ne-text">于是本地DNS服务器又向baidu.com这个域名的DNS地址（这个一般就是由域名注册商提供的，像万网，新网等）发起请求（请问www.baidu.com这个域名的IP地址是多少？），这个时候baidu.com域的DNS服务器一查，呀！果真在我这耶，于是就把找到的结果发送给本地DNS服务器;<br /></span></li><li id="u8cf01fe8"><span class="ne-text">这个时候本地DNS服务器就拿到了www.baidu.com这个域名对应的IP地址。</span></li></ul><p id="u0fbd0b32" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1653195503382-8d0d2c0b-904d-4f6f-ab2a-a41fde109da2.png" width="732" id="u07bfc271" class="ne-image"></p><h3 id="lkiXv"><span class="ne-text">DNS优化</span></h3><p id="u91118b2b" class="ne-p"><span class="ne-text">DNS也是开销，通常浏览器查找一个给定域名的IP地址要花费20~120毫秒，在完成域名解析之前，浏览器不能从服务器加载到任何东西。那么如何减少域名解析时间，加快页面加载速度呢？</span></p><ul class="ne-ul"><li id="ua58ce1cb"><span class="ne-text">减少DNS请求次数</span></li><li id="ufc2a45bc"><span class="ne-text">DNS预获取,DOM还没开始，浏览器预解析地址，把解析好的地址放在本地缓存里面，DOM树生成完，要加载图片类的发现DNS已经解析好了，再发送请求。&lt;link rel='dns-prefetch'href='//dfns.tanx.com'&gt;<br /></span><span class="ne-text">（主要对图片资源）</span></li><li id="u41a1cadd"><span class="ne-text">DNS 查询的过程经历了很多的步骤，如果每次都如此，会耗费太多的时间、资源。所以我们应该尽早的返回真实的IP地址:（减少查询过程，也就是DNS缓存。浏览器获取到IP地址后，一般都会缓存到浏览器的缓存中，本地的DNS缓存服务器，也可以去记录。另外，每天几亿网名的访问需求，一秒钟几千万的请求域名服务器如何满足？就是DNS负载均衡。通常我们的网站应用各种云服务，或者各种服务商提供类似的服务，由他们去帮我们处理这些问题。 DNS系统根据每台机器的负载量，地理位置的限制（长距离的传输效率）等等，去提供高效快速的 DNS 解析服务。</span></li><li id="ub53fb360"><span class="ne-text">当客户端DNS缓存（浏览器和操作系统）缓存为空时，DNS查找的数量与要加载的Web页面中唯一主机名的数量相同，包括页面URL、脚本、样式表、图片、Flash对象等的主机名。减少主机名的数量就可以减少DNS查找的数量；</span></li><li id="u27ac4863"><span class="ne-text">减少唯一主机名的数量会潜在减少页面中并行下载的数量（HTTP1.1规范建议从每个主机名并行下载两个组件，但实际上可以多个）；但是减少主机名和并行下载的方案会产生矛盾，需要大家自己权衡。建议将组件放到至少两个但不多于4个主机名下，减少DNS查找的同时也允许高度并行下载。</span></li></ul><p id="u9b351d9d" class="ne-p"><strong><span class="ne-text">DNS解析后会把域名的解析权交给cname()指向的内容分发（CDN）专用的DNS服务器。CDN专用的DNS服务器把CDN的全局负载均衡设备的ip地址返回给用户</span></strong><span class="ne-text">。</span></p><h3 id="eX2Gt"><span class="ne-text">CDN</span></h3><p id="u43c690d3" class="ne-p"><span class="ne-text">举个例子：以前坐火车买票，都要到火车站买，所有人都去火车站买票，火车站售票厅的压力可想而知有多大。</span></p><p id="ufa4b6417" class="ne-p"><span class="ne-text">后来火车票代售点出现了，分布在各个城市，城镇，我们只需要去距离我们最近的火车票售卖点买票就可以了。 卖火车票的代理售票点（缓存服务器），为买票者提供了方便，帮助他们在最近的地方（最近的CDN节点）， 用最短的时间（最短的请求时间）买到票（拿到资源）。减轻了售票大厅的压力（起到分流作用，减轻服务器负载压力）</span></p><h4 id="UZbAn"><span class="ne-text">CDN缓存</span></h4><p id="uf2a937d7" class="ne-p"><span class="ne-text">在浏览器本地缓存失效后，浏览器会像CDN边缘节点发起请求，类似浏览器缓存，CDN边缘节点也存在一套缓存机制，</span></p><ul class="ne-ul"><li id="uef250afb"><span class="ne-text">CDN边缘节点缓存策略因服务商不同而不同，通过http响应头中的cache-control：max-age字段设置CDN边缘节点数据缓存时间。</span></li><li id="u701c37ab"><span class="ne-text">当浏览器向CDN节点请求数据时，CDN节点会判断缓存数据是否过期，若缓存数据过期，CDN会向服务器发出回源请求，从服务器拉取最新数据，更新本地缓存，并将最新数据返回给客户端，CDN服务商一般会提供基于文件后缀，目录多个维度来指定CDN缓存时间，为用户提供更精细化的缓存管理。</span></li></ul><h4 id="S0HlG"><span class="ne-text">CDN工作方式</span></h4><p id="u748269ee" class="ne-p"><span class="ne-text">（1）、当你点击网站页面的url时，经过本DNS解析，DNS解析后会把域名的解析权交给cname()指向的内容分发专用的DNS服务器。内容分发专用的DNS服务器把内容分发的全局负载均衡（GSLB）设备的ip地址返回给用户。<br /></span><span class="ne-text">（2）、当你向CDN的全局负载均衡设备的ip地址发起url访问请求，CDN的全局负载均衡设备会为你选择一台合适的缓存服务器提供服务。<br /></span></p><ul class="ne-ul"><li id="u62d633c9"><span class="ne-text">选择的依据：用户的ip地址，判断哪台服务器距离用户最近，根据用户请求的url中携带的内容名称判断哪台服务器上有用户要的数据，查询各个服务器当前负载情况，判断哪台服务器有服务能力。<br /></span></li><li id="u55721196"><span class="ne-text">分配：基于这些条件综合分析后，区域负载均衡设备会向全局负载均衡设备请求返回一台缓存服务器的IP地址。全局负载均衡设备返回服务器IP地址，用户向缓存服务器发起请求，缓存服务器响应用户请求，将用户所需内容传送到用户终端，如果这台缓存服务器没有用户想要的内容，而区域均衡设备依然将它分配给了用户，那么这台服务器就要向它的上一级缓存服务器请求内容，直至追溯到网站的源服务器将内容拉到本地。域名解析服务器根据用户ip地址，把域名解析成相应节点的缓存服务器ip地址，实现用户就近访问，使用CDN服务的网站，只要将其域名解析权交给CDN的全局负载均衡设备，将需要分发的内容注入到CDN就可以实现内容加速了。</span></li></ul><h4 id="zodWC"><span class="ne-text">CDN优势</span></h4><p id="uec018701" class="ne-p"><span class="ne-text">（1）、CDN节点解决了跨运营商和跨地域访问的问题，访问延时大大降低；<br /></span><span class="ne-text">（2）、大部分请求在CDN边缘节点完成，CDN起到分流作用，减轻了源服务器的负载。</span></p><h4 id="toj6z"><span class="ne-text">CDN劣势</span></h4><p id="u72ad3543" class="ne-p"><span class="ne-text">（1）、当网站更新时，如果CDN节点上数据没有及时更新，即便用户在浏览器使用 Ctrl +F5 的方式使浏览器端的缓存失效，也会因为CDN边缘节点没有同步最新数据而导致用户访问异常。<br /></span><span class="ne-text">（2）、CDN不同的缓存时间会对“回源率”产生直接的影响：</span></p><ul class="ne-ul"><li id="ud3847853"><span class="ne-text">如果缓存时间短，CDN边缘节点的内容经常失效，导致频繁回源。不仅增加服务器压力，也增加了用户访问时间。</span></li><li id="u8134ca1a"><span class="ne-text">如果缓存时间长，数据更新了，边缘节点的内容都还没更新，开发者对特定的任务做特定的数据缓存时间管理。</span></li></ul><h4 id="r5Rk6"><span class="ne-text">CDN刷新缓存</span></h4><p id="u417fd3e2" class="ne-p"><span class="ne-text">CDN边缘节点对开发者是透明的，相比于浏览器Ctrl+F5的强制刷新来使浏览器本地缓存失效，开发者可以通过CDN服务商提供的“刷新缓存”接口来达到清理CDN边缘节点缓存的目的。这样开发者在更新数据后，可以使用“刷新缓存”功能来强制CDN节点上的数据缓存过期，保证客户端在访问时，拉取到最新的数据。 |</span></p><h4 id="volWx"><span class="ne-text">CDN优化</span></h4><p id="u94a8c92b" class="ne-p"><span class="ne-text">（1）、前端需要被加速的文件大致包括：</span></p><p id="u68ee3330" class="ne-p"><span class="ne-text">js、css、图片、视频、和页面等文件。页面文件有动态和静态之分。这些文件和页面（比如html）最大的区别是：这些文件都是静态的，改动比较小，这类静态文件适合做CDN加速。我们把这些静态文件通过CDN分发到世界各地的节点，用户可以在距离最近的边缘节点拿到需要的内容，从而提升内容下载速度加快网页打开速度。页面分为动态页面和静态页面，动态页面不适合做CDN缓存，因为页面是动态的话，内容的有效期就比较活跃。边缘节点的数据经常失效要回源，造成源服务器压力。</span></p><p id="ue916f043" class="ne-p"><span class="ne-text">（2）、减少资源请求的等待时间</span></p><p id="uc64d549d" class="ne-p"><span class="ne-text">不同浏览器的并发数量不一样：IE11 、IE10 、chrome、Firefox 的并发连接数是 6个，IE9是10个。如果页面静态资源（图片等）过多（大于6个）会存在资源请求等待的情况。目前现实状况是大多用户带宽越来越大，但是我们的静态资源并非那么大，很多文件都是几k或者几十k，6个文件加起来都小于带宽。这样就导致了资源的浪费。</span></p><ul class="ne-ul"><li id="u2f5c8e34"><span class="ne-text">解决方案是：用多个不同IP的服务器来存储这些文件，并在页面中通过绝对路径的方式引用（要求同一IP的文件不超过6个）。这样就可以尽可能的减少资源请求等待的情况。</span></li></ul><p id="u09f49834" class="ne-p"><strong><span class="ne-text"></span></strong></p><p id="ub2704e18" class="ne-p"><strong><span class="ne-text">至此，你已经获取到缓存服务器的IP地址，并且准备向这个IP地址发送请求了。</span></strong></p><p id="u22b1278d" class="ne-p"><span class="ne-text"></span></p><h2 id="C0RQK"><span class="ne-text">三、TCP连接</span></h2><h3 id="hloA5"><span class="ne-text">TCP</span></h3><ul class="ne-ul"><li id="ua56b69d6"><span class="ne-text">TCP是一种面向连接的，可靠的，基于字节流的传输层通信协议。</span></li><li id="u8d6b838e"><span class="ne-text">建立TCP连接需要进行三次握手。过程如下：</span></li></ul><p id="ubcd3106f" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/webp/1484158/1653194429604-83b7eccb-7572-4c7b-826e-c9b9fe62c4b4.webp" width="465.99542236328125" id="u757bb214" class="ne-image"></p><p id="u42b8f525" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/webp/1484158/1653194443274-6c98150b-79e8-4075-adb5-9f05ca79decb.webp" width="434.99542236328125" id="u1fd5e20c" class="ne-image"></p><h3 id="kqyTN"><span class="ne-text">TCP握手过程</span></h3><ol class="ne-ol"><li id="u12e06ce3"><span class="ne-text">客户端发送带有SYN标识（SYN=1，seq=x）的请求报文段，然后进入SYN_SEND状态，等待服务端确认;</span></li><li id="u1b40cbc8"><span class="ne-text">服务端接收到客户端SYN报文段后，需要发送ACK信息对这个SYN进行确认，同时还要发送自己的SYN信息（SYN=1，ACK=1，seq=y，ack=x+1）服务端把这些信息放在一个报文段中（（SYN+ACK报文段），一并发给客户端，此时客户端进入SYN_RECV状态;</span></li><li id="u9b0cb1c5"><span class="ne-text">客户端接收到服务端的SYN+ACK报文段后会向服务端发送ACK（ACK=1，seq=x+，ack=y+1）确认报文段，这个报文段发送后，客户端和服务端都进入ESTABLISHED状态，完成三次握手。</span></li></ol><p id="u825b3e7a" class="ne-p"><span class="ne-text"></span></p><ul class="ne-ul"><li id="ufbd5f6d3"><span class="ne-text">第一次握手： 客户端向服务端携带有客户端数据通讯初始序列号的报文，并进入SYN-SENT状态，当客户端收到数据时证明服务端知道：客户端的发送能力、服务端的接受能力正常。</span></li><li id="u03131e7d"><span class="ne-text">第二次握手： 服务端将响应客户端数据通讯初始序列号和服务端数据通讯初始序列号放入报文中一起发送给客户端。发送结束后服务端进入SYN-RECEIVED状态。当客户端接受到数据证明在客户端的角度上知道：客户端和服务端的发送、接收能力是正常的。</span></li><li id="u58ae2ea7"><span class="ne-text">第三次握手： 客户端向服务端发送一个确认应答，并进入ESTABLISHED状态，服务端收到应答后也进入ESTABLISHED状态完成三次握手。这时候在服务端知道：服务端的发送能力、客户端的接收能力正常。</span></li></ul><p id="ufaa3bb3d" class="ne-p"><span class="ne-text"></span></p><h3 id="saWty"><span class="ne-text" style="color: rgb(51, 51, 51)">为什么TCP建立是三次握手？</span></h3><ul class="ne-ul"><li id="u4bdbc399"><span class="ne-text">双方要明确对方接收能力都是正常的，（客户端发之后，服务端可以确定客户端发送能力正常，服务端发送给客户端，客户端可以确定服务端的接收和发送能力正常，最后客户端发送确认，来确定客户端的接收能力。</span></li><li id="udd590ea5"><strong><span class="ne-text">为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误</span></strong><span class="ne-text">。</span></li><li id="ue1d939b1"><span class="ne-text">第三次握手除了让服务端知道，服务端发送能力和客户端的接收能力正常之外，还可以防止数据报延迟带来的不必要的资源消耗：当客户端发起tcp第一次握手的请求时，因为网络问题滞留在网络中，这时候客户端因为等待太久没有响应所以自动重发了握手请求并完成了所有数据请求关闭了与服务端的链接，这时候服务端才接收到第一次滞留在网络中的握手请求，服务端会向客户端发送第二次握手并处于等待第3次握手状态，客户端接收到第二次握手请求后发现是过期的请求就可以通过停止发送第三次握手，服务端一段时间没接到第三次握手请求会自动关闭请求监听。</span></li></ul><h3 id="qlDE4"><span class="ne-text">TLS（HTTPS）</span></h3><ul class="ne-ul"><li id="ufc9b5ca0"><strong><span class="ne-text">如果是HTTP连接，三次握手成功后，便建立起链接，如果是HTTPS连接，还需要传输层安全性协议（TLS）</span></strong></li></ul><p id="u9212e87f" class="ne-p"><strong><span class="ne-text"></span></strong></p><p id="ub8934ba0" class="ne-p"><span class="ne-text">TLS工作于传输层之上，应用层之下，默认作用于服务端的443端口,在TLS中可以分成两种加密技术：</span></p><ul class="ne-ul"><li id="u953bb96d"><strong><span class="ne-text">对称性加密</span></strong><span class="ne-text">：客户端和服务端拥有相同的密钥，通过密钥对密文解密。用于密文通讯</span></li><li id="u22948b5f"><strong><span class="ne-text">非对称性加密</span></strong><span class="ne-text">：在该模式下，密钥分为公钥和私钥，用公钥加密的数据必须用私钥解密，用私钥加密的数据需要用公钥解密，公钥可以通过服务端发送给各个客户端，私钥则只由服务端持有，所有该模式主要用于传递对称性密钥阶段。</span><span class="ne-text">加密流程如下图：</span></li></ul><p id="uef1141f4" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/webp/1484158/1653195667430-9725fd8f-69c1-4691-acae-9aea61ff7e4a.webp" width="371.99542236328125" id="u62e8caf3" class="ne-image"></p><p id="u1beab470" class="ne-p"><span class="ne-text">其中数字证书是由服务端生成的非对称加密公钥和数字签名组成加密形成，数字签名是服务器在第三方机构注册校验服务器身份的数据，当客户端接收到数字证书是可以通过比对第三方机构注册的信息从而判断该报文是否是从目标服务器中传出来，从而确定公钥是否被调包。如果比对成功，客户端会生成对称性加密的密钥通过服务端派发的公钥进行加密传输给服务端，之后的信息传递就通过这个密钥进行对称性加密传输。</span></p><p id="uffe13a3e" class="ne-p"><span class="ne-text"></span></p><h2 id="cQNOT"><span class="ne-text">四、客户端发送请求</span></h2><p id="u26855b84" class="ne-p"><span class="ne-text">TCP三次握手建立连接成功后，客户端按照</span><strong><span class="ne-text">指定的格式</span></strong><span class="ne-text">开始向服务端发送HTTP请求。</span></p><h3 id="hds73"><span class="ne-text">请求报文结构</span></h3><p id="ud1d43de5" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1653196268394-7d03589e-0451-42d8-a460-7165186625a6.png" width="616" id="ua22d4039" class="ne-image"></p><h4 id="NPCpT"><span class="ne-text" style="color: rgb(33, 37, 41)">请求报头</span></h4><p id="u6604c20f" class="ne-p"><span class="ne-text" style="color: rgb(33, 37, 41); font-size: 16px">请求报头允许客户端向服务器传递请求的附加信息和客户端自身的信息。<br /></span><span class="ne-text" style="color: rgb(33, 37, 41); font-size: 16px">PS: 客户端不一定特指浏览器，有时候也可使用Linux下的CURL命令以及HTTP客户端测试工具等。<br /></span><span class="ne-text" style="color: rgb(33, 37, 41); font-size: 16px">常见的请求报头有: Accept, Accept-Charset, Accept-Encoding, Accept-Language, Content-Type, Authorization, Cookie, User-Agent等。</span></p><p id="uda7247c5" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1653196015114-144aaadd-3f62-429d-a4ad-ba31e48a49dd.png" width="381.99542236328125" id="u41a7308a" class="ne-image"></p><p id="ua7a5e432" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1653196053367-789ac83b-4ea6-4f5c-ab5b-71064638eaca.png" width="380.99542236328125" id="u1d78f2c8" class="ne-image"></p><p id="u84000e8c" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1653196074822-50723931-5917-4a05-ab3b-cffa30bcdc1d.png" width="377.99542236328125" id="udc2cc044" class="ne-image"></p><p id="u2873aeb8" class="ne-p"><span class="ne-text" style="color: rgb(33, 37, 41); font-size: 16px">从图中可以看出，请求报头中使用了Accept, Accept-Encoding, Accept-Language, Cache-Control, Connection, Cookie等字段。Accept用于指定客户端用于接受哪些类型的信息，Accept-Encoding与Accept类似，它用于指定接受的编码方式。Connection设置为Keep-alive用于告诉客户端本次HTTP请求结束之后并不需要关闭TCP连接，这样可以使下次HTTP请求使用相同的TCP通道，节省TCP连接建立的时间。</span></p><h4 id="E8Sxo"><span class="ne-text" style="color: rgb(33, 37, 41)">请求正文</span></h4><p id="ufd1f0e54" class="ne-p"><span class="ne-text" style="color: rgb(33, 37, 41); font-size: 16px">当使用POST, PUT等方法时，通常需要客户端向服务器传递数据。这些数据就储存在请求正文中。在请求包头中有一些与请求正文相关的信息，例如: 现在的Web应用通常采用Rest架构，请求的数据格式一般为json。这时就需要设置Content-Type: application/json。</span></p><h3 id="DqH1p"><span class="ne-text">请求过程优化</span></h3><p id="uf0e4804e" class="ne-p"><span class="ne-text">减少HTTP请求次数和请求资源大小</span></p><ul class="ne-ul"><li id="u02134826"><span class="ne-text">资源合并压缩</span></li><li id="u886220e4"><span class="ne-text">字体图标（精灵图基本不是好的优化方式了，不好维护）</span></li><li id="u8b151eb8"><span class="ne-text">base64</span></li><li id="ua7b8b235"><span class="ne-text">Gzip（一般文件能压缩60%）</span></li><li id="u99c5abac"><span class="ne-text">图片懒加载</span></li><li id="uc970e0e4"><span class="ne-text">数据延迟分批加载</span></li><li id="ufd8dc50e"><span class="ne-text">CDN资源</span></li></ul><h2 id="onDoy"><span class="ne-text">五、服务端响应请求</span></h2><p id="u9add36bd" class="ne-p"><span class="ne-text">服务器端收到请求后由web服务器（准确说应该是http服务器）处理请求，诸如Apache、Ngnix、IIS等。web服务器解析用户请求，了解了要调度哪些资源文件，再通过响应的资源文件处理用户请求和参数，并调用数据库信息，最后将结果通过web服务器返回给浏览器客户端。</span></p><h4 id="LLf4p"><span class="ne-text">响应报文</span></h4><p id="u04a9f76d" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1653196402673-6ece40f2-645b-4af5-b395-a715c756cbfc.png" width="407" id="u5b68bb44" class="ne-image"></p><p id="ua856dee2" class="ne-p"><span class="ne-text" style="color: rgb(85, 85, 85); font-size: 14px">(1) 响应行包含：协议版本，状态码，状态码描述</span></p><p id="uab81c005" class="ne-p"><span class="ne-text" style="color: rgb(85, 85, 85); font-size: 14px">状态码规则如下：</span></p><ul class="ne-ul"><li id="u4c4449bb"><span class="ne-text" style="color: rgb(85, 85, 85); font-size: 14px">1xx：指示信息–表示请求已接收，继续处理。</span></li><li id="u852e2b6d"><span class="ne-text" style="color: rgb(85, 85, 85); font-size: 14px">2xx：成功–表示请求已被成功接收、理解、接受。</span></li><li id="u565492be"><span class="ne-text" style="color: rgb(85, 85, 85); font-size: 14px">3xx：重定向–要完成请求必须进行更进一步的操作。</span></li><li id="u953abe37"><span class="ne-text" style="color: rgb(85, 85, 85); font-size: 14px">4xx：客户端错误–请求有语法错误或请求无法实现。</span></li><li id="ua9b5aa59"><span class="ne-text" style="color: rgb(85, 85, 85); font-size: 14px">5xx：服务器端错误–服务器未能实现合法的请求。</span></li></ul><p id="uebc59aa3" class="ne-p"><span class="ne-text" style="color: rgb(85, 85, 85); font-size: 14px">(2) 响应头部包含响应报文的附加信息，由 名/值 对组成</span></p><p id="u40542035" class="ne-p"><span class="ne-text" style="color: rgb(85, 85, 85); font-size: 14px">(3) 响应主体包含回车符、换行符和响应返回数据，并不是所有响应报文都有响应数据</span></p><h2 id="NehWg"><span class="ne-text">六、断开连接</span></h2><p id="u9d963443" class="ne-p"><span class="ne-text">服务器响应完客户端请求之后，解除TCP连接，释放过程（四次挥手过程）如下：</span></p><p id="u5e730653" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/webp/1484158/1653194694500-6c0090b0-4c78-407c-83df-3355a71b80f2.webp" width="553" id="u85962d21" class="ne-image"></p><h3 id="jtmls"><span class="ne-text">四次挥手过程</span></h3><ul class="ne-ul"><li id="uc2d8a23c"><span class="ne-text">客户端发送标记为FIN=1（finished的缩写，表示接收完成，请求释放连接），同时生成一个Seq=u的序列号，之后进入FIN-WAIT-1半关闭阶段（此时客户端到服务端发送数据的通道已经关闭，但是仍然可以接收服务端发过来的数据）；</span></li><li id="u247f273a"><span class="ne-text">服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。</span></li><li id="ue1ad1b6a"><span class="ne-text">客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。</span></li><li id="u463cbbe2"><span class="ne-text">服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。</span></li><li id="u63903dcf"><span class="ne-text">客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。</span></li><li id="u05d367ba"><span class="ne-text">服务器只要收到了客户端发出的确认，立即进入CLOSED状态，就结束了这次的TCP连接。</span></li></ul><h3 id="PQWm7"><span class="ne-text">为什么是四次挥手？</span></h3><p id="u2d321eec" class="ne-p"><span class="ne-text">因为建立一旦连接，双方既是发送方，又是接收方，为了保证在最后断开的时候，客户端发送的最后一个ACK报文段能够被服务器接收到。如果客户端在收到服务器给它的断开连接的请求之后，回应完服务器就直接断开连接的话，服务器就会因为一直没得到客户端响应而一直等待，所以客户端要等待两个最长报文段寿命的时间，以便于服务器没有收到请求之后重新发送请求。</span></p><h2 id="PuVWe"><span class="ne-text">七、浏览器解析并渲染响应内容</span></h2><p id="u6b3bcdf2" class="ne-p"><span class="ne-text">在这之前我们先来补充一点基础知识：</span></p><h3 id="Y3sRj"><span class="ne-text">浏览器的渲染引擎组成（列举的是基本组成）</span></h3><ul class="ne-ul"><li id="u4f5545dd"><span class="ne-text">HTML解析器:将HTML解析成DOM树。</span></li><li id="udf4937dd"><span class="ne-text">CSS解析器: 为DOM中各个元素对象计算出样式信息，为布局提供基础设施。</span></li><li id="udf477ef9"><span class="ne-text">JavaScript引擎:解析并执行javascript代码。</span></li><li id="ue875f9b1"><span class="ne-text">布局layout模块:在DOM树创建后，webkit需要将其中的元素对象同样式信息结合起来，计算他们的大小位置等布局信息，形成一个能表达这所有信息的模型。 </span></li><li id="uc18ad7e3"><span class="ne-text">绘图模块:使用图形库将布局计算后的各个网页的节点绘制成图像的结果。</span></li></ul><h3 id="C9lpK"><span class="ne-text">渲染过程</span></h3><ol class="ne-ol"><li id="u6c4588f4"><span class="ne-text">浏览器拿到文件后（拿到的是一些字节码）通过编码方式（一般是utf-8）转换为对应的字符。</span></li><li id="ub2d2ec6f"><span class="ne-text">浏览器至上而下解析文档，遇见HTML标记，调用HTML解析器解析为对应的tocken，tocken就是标签文本的序列号，将tocken按词法解析解析成具体的标记结构，这个过程已经构建出一颗有标签，有层级，有结构的DOM树（就是一块内存，这块内存实际就是一个个Tocken构成的）；</span></li><li id="u639829da"><span class="ne-text">遇见style/link标记，调用CSS解析器处理CSS标记并构建CSSOM样式树；</span></li><li id="u07b96400"><span class="ne-text">遇见script标记，调用javascript解析器处理，绑定事件、修改DOM树/CSS树等；</span></li><li id="ue58b131b"><span class="ne-text">将DOM树和CSSOM树合并成一颗render树（渲染树）。</span></li><li id="u73abb46c"><span class="ne-text">根据渲染树来渲染，计算每个节点的几何信息（这一过程要依赖图形库）；</span></li><li id="ub992e54d"><span class="ne-text">将各个节点绘制到屏幕上。 如果用户操作页面，会触发第（6）或者第（7）步骤，也就是重排和重绘</span></li></ol><h3 id="n0mqK"><span class="ne-text">阻塞渲染</span></h3><p id="u2490e0f2" class="ne-p"><span class="ne-text">（1）style标签的样式：<br /></span></p><ul class="ne-ul"><li id="ub2f903aa"><span class="ne-text">由HTML解析器解析(异步解析）；</span></li><li id="u86069d2d"><span class="ne-text">不阻塞浏览器渲染（可能会出现闪屏（解析一点，显示一点现象）；</span></li><li id="u4b62c3fd"><span class="ne-text">不阻塞DOM解析。<br /><br /></span></li></ul><p id="ub27776db" class="ne-p"><span class="ne-text">（2）link引入的外部css样式（推荐使用）<br /></span></p><ul class="ne-ul"><li id="uc1f96d69"><span class="ne-text">由CSS解析器解析（同步解析）；</span></li><li id="u442b235d"><span class="ne-text">阻塞浏览器渲染（可以利用这种阻塞避免闪屏);</span></li><li id="u2fc09f64"><span class="ne-text">阻塞其后js语句的执行：<br /></span></li></ul><p id="u0ded7235" class="ne-p"><strong><span class="ne-text">原因</span></strong><span class="ne-text">：如果后面js的内容是获取元素的样式，例如宽高等属性,如果不等样式解析完毕，后面的js就获得了错误的信息,由于浏览器也不知道后续js的具体内容，所以只好等前面所有样式解析完毕，再执行js。例如：firefox在样式加载和解析过程，会禁止所有脚本。（webkit内核的浏览器只会在js尝试访问样式属性或者可能受到未加载的样式影响时才会禁止脚本。<br /></span></p><ul class="ne-ul"><li id="u98e3fdcf"><span class="ne-text">不阻塞DOM的解析：<br /></span></li></ul><p id="uf65ebb4c" class="ne-p"><strong><span class="ne-text">原因</span></strong><span class="ne-text">：DOM解析和CSS解析是两个并行的线程。<br /></span></p><p id="ub8e95fc3" class="ne-p"><span class="ne-text">（3）、优化核心概念：尽可能快的提高外部css加载速度。<br /></span></p><ul class="ne-ul"><li id="u9f885f50"><span class="ne-text">使用CDN节点进行外部资源打包；<br /></span></li><li id="u7ad07643"><span class="ne-text">对css进行压缩（利用打包工具，比如webpack，glup等；<br /></span></li><li id="u55539e7b"><span class="ne-text">减少对http请求数量，将多个css文件合并；<br /></span></li><li id="u0a4d8d88"><span class="ne-text">优化样式的代码。<br /></span></li></ul><p id="ue451fcf6" class="ne-p"><span class="ne-text">（4）js阻塞：<br /></span></p><ul class="ne-ul"><li id="u9b069c20"><span class="ne-text">阻塞DOM解析：<br /></span></li></ul><p id="u45b8cf6d" class="ne-p"><strong><span class="ne-text">原因</span></strong><span class="ne-text">：浏览器不知道后续脚本的内容，如果先去解析了下面的DOM，而随后js删除了后面的所有DOM，做了无用功。浏览器无法预估脚本具体做了什么操作，索性全部暂停，等脚本执行完，浏览器再继续向下解析。<br /></span></p><ul class="ne-ul"><li id="u5b8e0121"><span class="ne-text">阻塞页面的渲染：<br /></span></li></ul><p id="ufded32f2" class="ne-p"><strong><span class="ne-text">原因</span></strong><span class="ne-text">：js中也可以给DOM设置样式，浏览器同样等该脚本执行完再继续干活，避免做无用功。<br /></span></p><ul class="ne-ul"><li id="ufde261d3"><span class="ne-text">阻塞后续js的执行：<br /></span></li></ul><p id="ua9990fc1" class="ne-p"><strong><span class="ne-text">原因</span></strong><span class="ne-text">：维护依赖关系，例如：必须先引入jQuery再引入bootstrap。<br /></span></p><ul class="ne-ul"><li id="u817784ec"><span class="ne-text">如果script脚本加了defer：浏览器会发送请求加载js，但是不会阻塞DOM解析，等DOM解析完，再执行js。</span></li><li id="uc0787f7b"><span class="ne-text">如果script加了async：浏览器会发送请求加载js，不阻塞DOM解析，等js加载过来了，就先停止DOM解析，去执行js（谁先回来先执行谁），等js执行完，继续DOM解析。</span></li></ul><h3 id="V1IES"><span class="ne-text">渲染过程优化</span></h3><p id="u6ce002c5" class="ne-p"><span class="ne-text">（1）标签语义化（使用合适的标签，如果不是w3c规定的标签，Tocken令牌和词法解析语法得识别分析，是不是wc3规定的）<br /></span><span class="ne-text">（2）减少标签嵌套（生成结构树嵌套太多，就得递归（在DOM树构建时候快可以一点）<br /></span><span class="ne-text">（3）样式尽可能少的层级嵌套（使用与编译器的时候，层级嵌套要慎用。CSS选择器渲染从右到左，.box a{}会 比a{} 慢<br /></span><span class="ne-text">（4）尽早把CSS下载到客户端（充分利用HTTP多请求并发机制）<br /></span><span class="ne-text">（5）避免阻塞js放在底部<br /></span><span class="ne-text">（6）减少回流<br /></span></p><ul class="ne-ul"><li id="u97bf37ab"><span class="ne-text">放弃传统操作DOM时代，基于vue/react开始数据影响试图模式<br /></span></li><li id="u81ab9b58"><span class="ne-text">样式集中改变<br /></span></li><li id="u4559a3fe"><span class="ne-text">缓存布局信息，<br /></span></li><li id="u480222f8"><span class="ne-text">动画效果应用到position属性为absolute或fixed的元素上（脱离文档流）</span></li><li id="u371676b0"><span class="ne-text">CSS3硬件加速（比起考虑如何减少回流重绘，更期望不要回流重绘：transform、opacity、filters这些属性会触发硬件加速，不会引发回流重绘（过多使用占用大量内存，性能消耗严重<br /></span></li><li id="uefa5351d"><span class="ne-text">避免使用table布局和使用css的js表达式</span></li></ul><p id="u8b1b1567" class="ne-p"><span class="ne-text"></span></p></div>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
          <category> 前端性能优化 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[转]浏览器工作原理</title>
      <link href="/blog/vkgoaq/"/>
      <url>/blog/vkgoaq/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="uc476a18c" class="ne-p"><span class="ne-text">参考：</span></p><ul class="ne-ul"><li id="u94f3a8a8"><a href="https://www.yuque.com/handshell/kygzse" data-href="https://www.yuque.com/handshell/kygzse" target="_blank" class="ne-link"><span class="ne-text">https://www.yuque.com/handshell/kygzse</span></a></li></ul><p id="ue45fdca2" class="ne-p"><span class="ne-text"></span></p><h1 id="GNXt0"><span class="ne-text" style="color: rgb(51, 51, 51)">简介</span></h1><p id="u15ad5d23" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">网络浏览器很可能是使用最广的软件。在这篇入门文章中，我将会介绍它们的幕后工作原理。我们会了解到，从您在地址栏输入 google.com 直到您在浏览器屏幕上看到 Google 首页的整个过程中都发生了些什么。</span></p><h2 id="p8KMY"><span class="ne-text" style="color: rgb(51, 51, 51)">浏览器的主要功能</span></h2><p id="uc37e486b" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">浏览器的主要功能就是向服务器发出请求，在浏览器窗口中展示您选择的网络资源。这里所说的资源一般是指 HTML 文档，也可以是 PDF、图片或其他的类型。资源的位置由用户使用 URI（统一资源标示符）指定。</span></p><p id="u8834f380" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">浏览器解释并显示 HTML 文件的方式是在 HTML 和 CSS 规范中指定的。这些规范由网络标准化组织 W3C（万维网联盟）进行维护。</span></p><p id="uc3d5ef38" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">多年以来，各浏览器都没有完全遵从这些规范，同时还在开发自己独有的扩展程序，这给网络开发人员带来了严重的兼容性问题。如今，大多数的浏览器都是或多或少地遵从规范。</span></p><p id="u2cd4c280" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">浏览器的用户界面有很多彼此相同的元素，其中包括：</span></p><ul class="ne-ul"><li id="uc9ec74bf"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">用来输入 URI 的地址栏</span></li><li id="u1bb410a5"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">前进和后退按钮</span></li><li id="u6734b820"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">书签设置选项</span></li><li id="u00a223f7"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">用于刷新和停止加载当前文档的刷新和停止按钮</span></li><li id="u2e86b7d9"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">用于返回主页的主页按钮</span></li></ul><p id="ua33b564a" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">奇怪的是，浏览器的用户界面并没有任何正式的规范，这是多年来的最佳实践自然发展以及彼此之间相互模仿的结果。HTML5 也没有定义浏览器必须具有的用户界面元素，但列出了一些通用的元素，例如地址栏、状态栏和工具栏等。当然，各浏览器也可以有自己独特的功能，比如 Firefox 的下载管理器。</span></p><h2 id="J3Aw2"><span class="ne-text" style="color: rgb(51, 51, 51)">浏览器的高层结构</span></h2><p id="u14837635" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">浏览器的主要组件为</span></p><ol class="ne-ol"><li id="ue247f201"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">用户界面 - 包括地址栏、前进/后退按钮、书签菜单等。除了浏览器主窗口显示的您请求的页面外，其他显示的各个部分都属于用户界面。</span></li><li id="u9c5271b0"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">浏览器引擎 - 在用户界面和呈现引擎之间传送指令。</span></li><li id="u1c8351af"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">呈现引擎 - 负责显示请求的内容。如果请求的内容是 HTML，它就负责解析 HTML 和 CSS 内容，并将解析后的内容显示在屏幕上。</span></li><li id="u97a55487"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">网络 - 用于网络调用，比如 HTTP 请求。其接口与平台无关，并为所有平台提供底层实现。</span></li><li id="uc6227a35"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">用户界面后端 - 用于绘制基本的窗口小部件，比如组合框和窗口。其公开了与平台无关的通用接口，而在底层使用操作系统的用户界面方法。</span></li><li id="ub7edcbcf"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">JavaScript 解释器。用于解析和执行 JavaScript 代码。</span></li><li id="ufe548681"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">数据存储。这是持久层。浏览器需要在硬盘上保存各种数据，例如 Cookie。新的 HTML 规范 (HTML5) 定义了“网络数据库”，这是一个完整（但是轻便）的浏览器内数据库。</span></li></ol><p id="u60d23fd6" class="ne-p"><a href="https://blog.towavephone.com/static/2021-07-20-01-39-18-4d2efb6ba6e0c185fa557cbfdc53ca2c-28759.png" target="_blank" id="u221cabc3" class="ne-image-link" style="color: rgb(210, 54, 105); font-size: 16px"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1647955363695-c77ab531-56d2-4703-b760-10b2a357e13e.png" width="500" class="ne-image"></a></p><p id="udb1c4838" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">值得注意的是，和大多数浏览器不同，Chrome 浏览器的每个标签页都分别对应一个呈现引擎实例。每个标签页都是一个独立的进程。</span></p><h1 id="zlQIi"><span class="ne-text" style="color: rgb(51, 51, 51)">呈现引擎</span></h1><p id="u03c20d1f" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">呈现引擎的作用就是在浏览器的屏幕上显示请求的内容。</span></p><p id="u8b873811" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">默认情况下，呈现引擎可显示 HTML 和 XML 文档与图片。通过插件（或浏览器扩展程序），还可以显示其他类型的内容；例如，使用 PDF 查看器插件就能显示 PDF 文档。但是在本章中，我们将集中介绍其主要用途：显示使用 CSS 格式化的 HTML 内容和图片。</span></p><p id="u6833104e" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">本文所讨论的浏览器（Firefox、Chrome 浏览器和 Safari）是基于两种呈现引擎构建的。Firefox 使用的是 Gecko，这是 Mozilla 公司“自制”的呈现引擎。而 Safari 和 Chrome 浏览器使用的都是 WebKit。</span></p><p id="ud73dbeda" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">WebKit 是一种开放源代码呈现引擎，起初用于 Linux 平台，随后由 Apple 公司进行修改，从而支持苹果机和 Windows。</span></p><h2 id="nhQGa"><span class="ne-text" style="color: rgb(51, 51, 51)">主流程</span></h2><p id="u3fe8d72f" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">呈现引擎一开始会从网络层获取请求文档的内容，内容的大小一般限制在 8000 个块以内。</span></p><p id="u98e4588f" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">然后进行如下所示的基本流程：</span></p><p id="u0c26b84e" class="ne-p"><a href="https://blog.towavephone.com/static/2021-07-20-01-41-38-dba2da5da3c0b45fb5977e4418996051-81a6c.png" target="_blank" id="uaff40621" class="ne-image-link" style="color: rgb(210, 54, 105); font-size: 16px"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1647955363670-09c68a6a-43bf-4918-bcec-1b15f46e982d.png" width="600" class="ne-image"></a></p><p id="u9ef421fe" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">呈现引擎将开始解析 HTML 文档，并将各标记逐个转化成“内容树”上的 DOM 节点。同时也会解析外部 CSS 文件以及样式元素中的样式数据。HTML 中这些带有视觉指令的样式信息将用于创建另一个树结构：呈现树。</span></p><p id="ueb8436dd" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">呈现树包含多个带有视觉属性（如颜色和尺寸）的矩形。这些矩形的排列顺序就是它们将在屏幕上显示的顺序。</span></p><p id="u782d810b" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">呈现树构建完毕之后，进入“布局”处理阶段，也就是为每个节点分配一个应出现在屏幕上的确切坐标。下一个阶段是绘制 - 呈现引擎会遍历呈现树，由用户界面后端层将每个节点绘制出来。</span></p><p id="uc5bf0356" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">需要着重指出的是，这是一个渐进的过程。为达到更好的用户体验，呈现引擎会力求尽快将内容显示在屏幕上。它不必等到整个 HTML 文档解析完毕之后，就会开始构建呈现树和设置布局。在不断接收和处理来自网络的其余内容的同时，呈现引擎会将部分内容解析并显示出来。</span></p><h2 id="f1Vdv"><span class="ne-text" style="color: rgb(51, 51, 51)">主流程示例</span></h2><p id="u70693807" class="ne-p"><a href="https://blog.towavephone.com/static/2021-07-20-01-43-09-b2b81d9cf1c9a7547a05e02c3d96d537-37d31.png" target="_blank" id="u8697360d" class="ne-image-link" style="color: rgb(210, 54, 105); font-size: 16px"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1647955363669-1f06ef06-1aff-4c66-9d0c-8a80cc24a0d2.png" width="624" class="ne-image"></a></p><p id="u449dd883" class="ne-p"><a href="https://blog.towavephone.com/static/2021-07-20-01-43-20-b62fa3cb50eec54e4215a86e1ce83f85-37d31.png" target="_blank" id="u1c601d5c" class="ne-image-link" style="color: rgb(210, 54, 105); font-size: 16px"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1647955363715-948ad36b-e794-4de4-aabd-c2d6ffd71247.png" width="624" class="ne-image"></a></p><p id="u2198ee71" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">可以看出，虽然 WebKit 和 Gecko 使用的术语略有不同，但整体流程是基本相同的。</span></p><p id="u0f1e60f2" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">Gecko 将视觉格式化元素组成的树称为“框架树”。每个元素都是一个框架。WebKit 使用的术语是“呈现树”，它由“呈现对象”组成。对于元素的放置，WebKit 使用的术语是“布局”，而 Gecko 称之为“重排”。</span></p><p id="u529b6783" class="ne-p"><span class="ne-text" style="color: rgb(51, 51, 51); font-size: 16px">对于连接 DOM 节点和可视化信息从而创建呈现树的过程，WebKit 使用的术语是“附加”。有一个细微的非语义差别，就是 Gecko 在 HTML 与 DOM 树之间还有一个称为“内容槽”的层，用于生成 DOM 元素。我们会逐一论述流程中的每一部分：</span></p></div>]]></content>
      
      
      <categories>
          
          <category> 计算机素养 </category>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>水平/垂直居中总结</title>
      <link href="/blog/dubn5y/"/>
      <url>/blog/dubn5y/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h2 id="Q1iqa"><span class="ne-text">水平居中</span></h2><p id="u1757acd2" class="ne-p"><br></p><h2 id="SBJoD"><span class="ne-text">垂直居中</span></h2><ul class="ne-ul"><li id="u19dac5dd"><a href="https://juejin.cn/post/6844903550909153287" data-href="https://juejin.cn/post/6844903550909153287" class="ne-link"><span class="ne-text">CSS垂直居中的12种实现方式 - 掘金</span></a></li><li id="u9ef7efc0"><a href="https://blog.csdn.net/pan_junbiao/article/details/92804198" data-href="https://blog.csdn.net/pan_junbiao/article/details/92804198" class="ne-link"><span class="ne-text">CSS让DIV上下左右居中的方法_pan_junbiao的博客-CSDN博客</span></a></li></ul></div>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
          <category> HTML+CSS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CSS实现上下浮动动画</title>
      <link href="/blog/pu2dxs/"/>
      <url>/blog/pu2dxs/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="ue09c7540" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1648018096319-db408c92-c6e3-4678-b773-bf084efbdc41.png" width="546.015625" id="u0cee8aad" class="ne-image"></p><p id="u6119638d" class="ne-p"><span class="ne-text">lyrics项目里面自己设计首页需要当前视窗高度有一个箭头上下浮动的效果，按照如下方式实现：</span></p><pre><code>  .home-row-foward &#123;    animation: heart 0.5s ease-in-out 2.7s infinite alternate;    height: 30px;    font-size: 25px;    color: #1890ff;    text-align: center;    position: relative;    bottom: 25px;  &#125;  @keyframes heart &#123;    from &#123;      transform: translate(0, 0);    &#125;    to &#123;      transform: translate(0, 15px);    &#125;  &#125;</code></pre></div>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
          <category> HTML+CSS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>前端代码模块及其工具化（Webpack,roolup.js）构建</title>
      <link href="/blog/psazge/"/>
      <url>/blog/psazge/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="ucc55b2a2" class="ne-p"><span class="ne-text">前言：本文讲述前端代码模块化发展历程，再介绍构建工具对代码予以指定条件下的打包构建。</span></p><p id="ua273ed45" class="ne-p"><span class="ne-text"></span></p><h2 id="Mois5"><span class="ne-text">一、前端模块化历程</span></h2><p id="u5e631bc2" class="ne-p" style="text-align: center"><strong><span class="ne-text">无模块化（入口函数加载）→ AMD → CommonJS → UMD → ES Module</span></strong></p><p id="u3110707b" class="ne-p" style="text-align: center"><strong><span class="ne-text"></span></strong></p><ul class="ne-ul"><li id="ua2ef18af"><span class="ne-text">无模块化：通过入口函数即可加载</span></li><li id="uf30d1f53"><span class="ne-text">CommonJS：Node.js环境下的模块引入方式</span></li><li id="uf4d54197"><span class="ne-text">UMD：并不是一种全新的模块系统，而是整合了无模块化、AMD、CommonJS三种模块规范，其可以在任何环境下工作</span></li></ul><ul class="ne-ul"><li id="uac0b70f8"><span class="ne-text">ES Module：ECMAScript 2015引入的模块化规范，部分浏览器支持，不支持该特性的浏览器需要使用构建工具来提供支持</span></li></ul><h3 id="vxrce"><span class="ne-text">Commonjs</span></h3><h4 id="l5vSh"><span class="ne-text">nodejs不能使用es6的模块导入导出</span></h4><p id="u312d8bca" class="ne-p"><span class="ne-text">node.js 使用 commonjs 规范，es6 module 的推出和完善，node 从 v13开始原生支持 es6 module。</span></p><p id="u100f9b67" class="ne-p"><br></p><p id="ue9391cbd" class="ne-p"><span class="ne-text">在node环境下是不能使用es6语法中import export导入导出语法的，解决办法有babel转义，或者如下面的一种新方法（需要Node.js 版本 13.x.x 以上），个人推荐最好还是用babel配置babel配置文件在转义，因为可以自行一些配置。</span></p><ul class="ne-ul"><li id="u6443d0ea"><span class="ne-text">解决方案一：Node.js 版本 13.x.x 以上的版本，使用 </span><a href="https://nodejs.org/api/esm.html#esm_enabling" data-href="https://nodejs.org/api/esm.html#esm_enabling" target="_blank" class="ne-link"><span class="ne-text">官方推荐的方法</span></a><span class="ne-text"> 在 </span><code class="ne-code"><span class="ne-text">package.json</span></code><span class="ne-text"> 文件中设置 </span><code class="ne-code"><span class="ne-text">&quot;type&quot;: &quot;module&quot;</span></code><span class="ne-text">。</span></li></ul><pre><code>&#123;  &quot;type&quot;: &quot;module&quot;&#125;</code></pre><ul class="ne-ul"><li id="u319e4cb6"><span class="ne-text">解决方案二：使用 </span><a href="https://babeljs.io/" data-href="https://babeljs.io/" target="_blank" class="ne-link"><span class="ne-text">babeljs</span></a><span class="ne-text"> ，然后在项目中添加相关配置即可，具体可以查阅相关教程。</span></li></ul><h4 id="s89sl"><span class="ne-text">导入导出</span></h4><p id="u09c450b4" class="ne-p"><strong><span class="ne-text">导出</span></strong></p><div class="ne-quote"><p id="u04277304" class="ne-p"><span class="ne-text">【</span><span class="ne-text">第一种方式</span><span class="ne-text">】</span></p></div><ul class="ne-ul"><li id="u37472444"><span class="ne-text">就是在模块里面定义好变量/方法，然后利用 </span><code class="ne-code"><span class="ne-text">exports.let_1= let_1;</span></code><span class="ne-text"> </span><code class="ne-code"><span class="ne-text">exports.fun_1 = fun_1;</span></code><span class="ne-text">这种形式，一个个导出</span></li></ul><p id="udd99f2b8" class="ne-p"><br></p><p id="u821e17e2" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1618149585979-d1ff5498-d0e1-46ce-b115-ceeadf7f0df9.png" width="432.5" id="ViMAf" class="ne-image"></p><div class="ne-quote"><p id="u1786a9d8" class="ne-p"><span class="ne-text">【</span><span class="ne-text">第二种方式</span><span class="ne-text">】module.exports.version = version;</span></p></div><p id="uab94ef11" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1618149597438-9300a103-0fd7-42df-9307-06079ef423c0.png" width="422" id="NFJOH" class="ne-image"></p><p id="ub6ffc99d" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1618149609536-ea32c674-9e2d-48fb-92bc-d2c7bf0d294c.png" width="465.5" id="hnFZE" class="ne-image"></p><p id="udd681584" class="ne-p"><strong><span class="ne-text">导入</span></strong></p><p id="u1e5fcea0" class="ne-p"><span class="ne-text">const a = require('文件路径');</span></p><h4 id="tDrVM"><span class="ne-text">模块的查找规则</span></h4><p id="u18115508" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1618118075531-995293d3-ee92-4f22-a49c-cb5114639b20.png" width="432" id="i6QRC" class="ne-image"></p><p id="u86218b6c" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1618118082503-8414faae-297b-4cd7-a304-c80f7a635a35.png" width="384.5" id="J3M0F" class="ne-image"></p><h3 id="R2Rv5"><span class="ne-text">ES Module</span></h3><ul class="ne-ul"><li id="u6c153730"><a href="https://zhuanlan.zhihu.com/p/60374345" data-href="https://zhuanlan.zhihu.com/p/60374345" target="_blank" class="ne-link"><span class="ne-text">ES6专题—class与模块化（10）</span></a></li></ul><h4 id="ILTnS"><span class="ne-text">export</span></h4><pre><code>const checkStr = (str, type) =&gt; &#123;  // 等内容&#125;<p>module.exports = &#123;<br>  checkStr,<br>&#125;<br></code></pre></p><pre><code>export const updateInfo: any = (data: any) =&gt; &#123;  return fetch(&#123;    method: 'post',    url: `/*****************`,    data: data,  &#125;)&#125;</code></pre><h4 id="tBIUG"><span class="ne-text">import</span></h4><pre><code>import fetch from '../utils/fetch'</code></pre><h4 id="ytshL"><span class="ne-text">与class结合</span></h4><pre><code>class StorageFn &#123;  ls: Storage  ss: Storage  constructor() &#123;    this.ls = window.localStorage    this.ss = window.sessionStorage  &#125;  /*设置cookie*/  setCookie(name: any, value: any, day: any) &#123;&#125;  // 等内容&#125;<p>export default StorageFn<br></code></pre></p><h2 id="LCC3F"><span class="ne-text">二、模块化实现方式</span></h2><p id="u57e8119b" class="ne-p"><span class="ne-text">实现各种环境下都能使用模块化代码，需要使用打包工具来对一套代码进行打包，打包工具主流有：</span></p><ol class="ne-ol"><li id="ubd0fe9cd"><span class="ne-text">Webpack：适合应用类打包</span></li><li id="u098a1915"><span class="ne-text">roolup.js：适合工具类以及SDK打包</span></li></ol><p id="u5600a0ba" class="ne-p"><span class="ne-text"></span></p><p id="ubca969a8" class="ne-p"><span class="ne-text">打包目标：</span></p><ul class="ne-ul"><li id="uc96121f9"><span class="ne-text">编写ECMAScript 2015及其之后版本的新特性代码</span></li><li id="u5cf60fb6"><span class="ne-text">兼容各种浏览器和Node.js环境运行</span></li><li id="u1d7242df"><span class="ne-text">输出各类模块规范</span></li><li id="u4496a801"><span class="ne-text">可以按需加载</span></li></ul><h3 id="k633M"><span class="ne-text">roolup.js打包</span></h3><ul class="ne-ul"><li id="u34ab7d23"><span class="ne-text">sideEffects：实现按需加载</span></li></ul><pre><code>&#123;  ···  &quot;main&quot;: &quot;dist/index.js&quot;,  &quot;jsnext:main&quot;: &quot;dist/index.esm.js&quot;,  &quot;module&quot;: &quot;dist/index.esm.js&quot;,  &quot;sideEffects&quot;: false,  &quot;scripts&quot;: &#123;    &quot;build:self&quot;: &quot;rollup -c config/rollup.config.js&quot;,    &quot;build:esm&quot;: &quot;rollup -c config/rollup.config.esm.js&quot;,    &quot;build:aio&quot;: &quot;rollup -c config/rollup.config.aio.js&quot;,    &quot;build&quot;: &quot;npm run build:self &amp;&amp; npm run build:esm &amp;&amp; npm run build:aio&quot;,  &#125;,  &quot;devDependencies&quot;: &#123;    &quot;@babel/core&quot;: &quot;^7.1.2&quot;,    &quot;@babel/plugin-transform-runtime&quot;: &quot;^7.1.0&quot;,    &quot;@babel/preset-env&quot;: &quot;^7.1.0&quot;,    &quot;rollup&quot;: &quot;^0.57.1&quot;,    &quot;rollup-plugin-babel&quot;: &quot;^4.0.3&quot;,    &quot;rollup-plugin-commonjs&quot;: &quot;^8.3.0&quot;,    &quot;rollup-plugin-node-resolve&quot;: &quot;^3.0.3&quot;  &#125;,  &quot;dependencies&quot;: &#123;    &quot;@babel/runtime-corejs2&quot;: &quot;^7.12.5&quot;,    &quot;@babel/runtime-corejs3&quot;: &quot;^7.12.5&quot;,    &quot;core-js&quot;: &quot;^3.7.0&quot;  &#125;  ···&#125;<p></code></pre></p><ul class="ne-ul"><li id="ub50dbee3"><span class="ne-text">banner：打包后的公共头部注释</span></li><li id="u3f4dacac"><span class="ne-text">输入</span><code class="ne-code"><span class="ne-text">npx browserslist</span></code><span class="ne-text">可查看浏览器版本支持情况</span></li></ul><pre><code>var babel = require(&quot;rollup-plugin-babel&quot;);<p>var pkg = require(&quot;../package.json&quot;);</p><p>var version = pkg.version;</p><p>var banner = `/*!</p><ul><li>$&#123;pkg.name&#125; $&#123;version&#125;</li><li>Licensed under MIT</li><li>/<br>`;</li></ul><p>function getCompiler(opt) &#123;<br>  return babel(&#123;<br>    babelrc: false,<br>    presets: [<br>      [<br>        &quot;@babel/preset-env&quot;,<br>        &#123;<br>          targets: &#123;<br>            browsers:<br>              &quot;last 2 versions, &gt; 1%, ie &gt;= 8, Chrome &gt;= 45, safari &gt;= 10&quot;,<br>            node: &quot;0.12&quot;,<br>          &#125;,<br>          modules: false,<br>          loose: false,<br>        &#125;,<br>      ],<br>    ],<br>    plugins: [<br>      [<br>        &quot;@babel/plugin-transform-runtime&quot;,<br>        &#123;<br>          corejs: 2,<br>          helpers: false,<br>          regenerator: false,<br>        &#125;,<br>      ],<br>    ],<br>    runtimeHelpers: true,<br>    exclude: &quot;node_modules/**&quot;,<br>  &#125;);<br>&#125;</p><p>exports.name = &quot;clone&quot;;<br>exports.banner = banner;<br>exports.getCompiler = getCompiler;</p><p></code></pre></p><pre><code>// commonjsvar common = require(&quot;./rollup.js&quot;);module.exports = &#123;  input: &quot;src/index.js&quot;,  output: &#123;    file: &quot;dist/index.js&quot;,    format: &quot;cjs&quot;,    // When export and export default are not used at the same time, set legacy to true.    // legacy: true,    banner: common.banner,  &#125;,  plugins: [common.getCompiler()],&#125;;</code></pre><pre><code>// ES outputvar common = require(&quot;./rollup.js&quot;);module.exports = &#123;  input: &quot;src/index.js&quot;,  output: &#123;    file: &quot;dist/index.esm.js&quot;,    format: &quot;es&quot;,    // When export and export default are not used at the same time, set legacy to true.    // legacy: true,    banner: common.banner,  &#125;,  plugins: [common.getCompiler()],&#125;;</code></pre><ul class="ne-ul"><li id="uae60f3e1"><span class="ne-text">roolup打包CommonJS需要配合插件来执行</span></li></ul><pre><code>// umdvar nodeResolve = require(&quot;rollup-plugin-node-resolve&quot;);var commonjs = require(&quot;rollup-plugin-commonjs&quot;);<p>var common = require(&quot;./rollup.js&quot;);</p><p>module.exports = &#123;<br>  input: &quot;src/index.js&quot;,<br>  output: &#123;<br>    file: &quot;dist/index.aio.js&quot;,<br>    format: &quot;umd&quot;,<br>    // When export and export default are not used at the same time, set legacy to true.<br>    // legacy: true,<br>    name: common.name,<br>    banner: common.banner,<br>  &#125;,<br>  plugins: [<br>    nodeResolve(&#123;<br>      main: true,<br>      extensions: [&quot;.js&quot;],<br>    &#125;),<br>    commonjs(&#123;<br>      include: &quot;node_modules/**&quot;,<br>    &#125;),<br>    common.getCompiler(),<br>  ],<br>&#125;;</p><p></code></pre></p><h2 id="BDJQG"><span class="ne-text">三、参考</span></h2><p id="u75ca9f85" class="ne-p"><span class="ne-text">模块化理解</span></p><ul class="ne-ul"><li id="ua4a74059"><span class="ne-text">分析组件库以及构建产物：</span><a href="https://zhuanlan.zhihu.com/p/502956467" data-href="https://zhuanlan.zhihu.com/p/502956467" target="_blank" class="ne-link"><span class="ne-text">https://zhuanlan.zhihu.com/p/502956467</span></a></li><li id="ue3fab7be"><span class="ne-text">这一次，我要弄懂javascript的模块化 - 掘金：</span><a href="https://juejin.cn/post/6844903636108066830" data-href="https://juejin.cn/post/6844903636108066830" target="_blank" class="ne-link"><span class="ne-text">https://juejin.cn/post/6844903636108066830</span></a></li></ul><p id="ud41175ce" class="ne-p"><span class="ne-text">模块化打包</span></p><ul class="ne-ul"><li id="u5fb98569"><span class="ne-text">vite的项目，使用rollup打包的方法：</span><a href="https://juejin.cn/post/7036207262414667790" data-href="https://juejin.cn/post/7036207262414667790" target="_blank" class="ne-link"><span class="ne-text">https://juejin.cn/post/7036207262414667790</span></a></li><li id="u1c70db70"><a href="https://q.shanyue.tech/engineering/753.html#%E4%B8%80%E4%BA%9B%E5%A4%8D%E6%9D%82%E7%9A%84%E8%BD%AC%E5%8C%96" data-href="https://q.shanyue.tech/engineering/753.html#%E4%B8%80%E4%BA%9B%E5%A4%8D%E6%9D%82%E7%9A%84%E8%BD%AC%E5%8C%96" target="_blank" class="ne-link"><span class="ne-text">如何将 CommonJS 转化为 ESM | 前端工程化三十八讲 | 大厂面试题每日一题</span></a></li><li id="ua620a111"><a href="https://github.com/rollup/plugins/tree/master/packages/commonjs" data-href="https://github.com/rollup/plugins/tree/master/packages/commonjs" target="_blank" class="ne-link"><span class="ne-text">https://github.com/rollup/plugins/tree/master/packages/commonjs</span></a></li><li id="u8a89dc03"><a href="https://juejin.cn/post/6844904058394771470" data-href="https://juejin.cn/post/6844904058394771470" target="_blank" class="ne-link"><span class="ne-text">Rollup打包工具的使用（超详细，超基础，附代码截图超简单） - 掘金</span></a></li><li id="u1e26f222"><a href="https://juejin.cn/post/7145090564801691684" data-href="https://juejin.cn/post/7145090564801691684" target="_blank" class="ne-link"><span class="ne-text">【实战篇】最详细的Rollup打包项目教程 - 掘金</span></a></li><li id="u196fd378"><a href="https://juejin.cn/post/7137488289488961549" data-href="https://juejin.cn/post/7137488289488961549" target="_blank" class="ne-link"><span class="ne-text">rollup打包一个工具库并发布到npm - 掘金</span></a></li></ul><p id="u92ea30f6" class="ne-p"><span class="ne-text">ts的模块导入导出</span></p><ul class="ne-ul"><li id="u630258bc"><a href="https://blog.csdn.net/qq_43340929/article/details/107034432" data-href="https://blog.csdn.net/qq_43340929/article/details/107034432" target="_blank" class="ne-link"><span class="ne-text">TypeScript模块导入终极解决方案</span></a></li></ul><p id="u4846d97f" class="ne-p"><br></p></div>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
          <category> Node.js </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>696. 计数二进制子串🔖字符串</title>
      <link href="/blog/sueiwv/"/>
      <url>/blog/sueiwv/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="u62f590fc" class="ne-p"><span class="ne-text">题目链接：</span></p><ul class="ne-ul"><li id="u79899ad5"><a href="https://leetcode-cn.com/problems/count-binary-substrings/" data-href="https://leetcode-cn.com/problems/count-binary-substrings/" target="_blank" class="ne-link"><span class="ne-text">https://leetcode-cn.com/problems/count-binary-substrings/</span></a></li></ul><h3 id="gs1qv"><span class="ne-text">解决思路</span></h3><ul class="ne-ul"><li id="u80a880bd"><span class="ne-text">数学规律就是将字符串按照</span><strong><span class="ne-text">一整个0或1</span></strong><span class="ne-text">切割开来，将其放入数组arr，然后arr中相邻的元素（字符串）进行字符串长度比较大小，取小的，最后所有相邻的元素比较后的所有相加就是所需结果</span></li><li id="u86427819"><span class="ne-text">将字符串按照</span><strong><span class="ne-text">一整个0或1</span></strong><span class="ne-text">切割开来：先对字符串遍历，找到异元素，记录其下标，存为数组arr；然后利用splice方法＋arr数组进行切割为目标数组</span></li></ul><h3 id="KZHav"><span class="ne-text">代码实现</span></h3><p id="u1b748dff" class="ne-p"><span class="ne-text">将上述解决思路用代码实现如下：</span></p><pre><code>function countBinarySubstrings(s: string): number &#123;  let flag: string = s[0]  let arr: number[] = []  let arr_target: string[] = []  for (let i: number = 0; i &lt; s.length; i++) &#123;    if (s[i] !== flag) &#123;      arr.push(i)      flag = s[i]    &#125;  &#125;  arr.forEach((data: number, index: number) =&gt; &#123;    if (index === 0) &#123;      arr_target.push(String(s.slice(0, data)))      // 分割数组只有一个元素情况下      if (arr.length === 1) arr_target.push(String(s.slice(data, s.length)))    &#125; else if (index === arr.length - 1) &#123;      arr_target.push(String(s.slice(arr[index - 1], data)))      arr_target.push(String(s.slice(data, s.length)))    &#125; else &#123;      arr_target.push(String(s.slice(arr[index - 1], data)))    &#125;  &#125;)  let result: number = 0  arr_target.forEach((data: string, index: number) =&gt; &#123;    if (index &lt; arr_target.length - 1)      result += Math.min(        String(data).length,        String(arr_target[index + 1]).length      )  &#125;)  return result&#125;<p>console.log(countBinarySubstrings(‘1100’))</p><p></code></pre></p><ul class="ne-ul"><li id="u239fffbf"><strong><span class="ne-text" style="color: #E8323C">对上述逻辑的小优化</span></strong><span class="ne-text">：上面是利用arr还转换为原只含0、1的数组，但是可以利用arr直接进行求算结果</span></li></ul><pre><code>function countBinarySubstrings(s: string): number &#123;  let flag: string = s[0]  let arr: number[] = []  let result: number = 0  for (let i: number = 0; i &lt; s.length; i++) &#123;    if (s[i] !== flag) &#123;      arr.push(i)      flag = s[i]    &#125;  &#125;  arr.forEach((data: number, index: number) =&gt; &#123;    if (index === 0) &#123;      arr.length === 1        ? (result += Math.min(data, s.length - data))        : (result += Math.min(data, arr[index + 1] - data))    &#125; else if (index === arr.length - 1) &#123;      result += Math.min(data - arr[index - 1], s.length - data)    &#125; else &#123;      result += Math.min(arr[index + 1] - data, data - arr[index - 1])    &#125;  &#125;)  return result&#125;</code></pre><p id="u2dadfbee" class="ne-p"><span class="ne-text">最后优化效果如下</span></p><p id="ueb92bbd2" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1647944556161-5866cbd8-f97b-4fdc-9e84-9d3dc2ebc571.png" width="699.9999721845002" id="u40ceee23" class="ne-image"></p><h3 id="FNmDD"><span class="ne-text">优化方案</span></h3><p id="u6015cfa7" class="ne-p"><span class="ne-text">在官网解决方案中，看到其他的解决方案：</span></p><h4 id="bouKe"><span class="ne-text">利用正则表达式来切换原字符串</span></h4><pre><code>s.match(/([1]+)|([0]+)/g)</code></pre><p id="u3bc26102" class="ne-p"><span class="ne-text">上面的正则表达式就能实现如下效果…………</span></p><pre><code>[ '00', '11', '00', '11' ]</code></pre><p id="u581d3060" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/1484158/1647945287324-1f4f1d3f-6731-4794-a023-ba9ebb97397c.jpeg" width="75" id="BFxC7" class="ne-image"><span class="ne-text">正则表达式太重要了！！</span></p><p id="u3fa4a566" class="ne-p"><span class="ne-text">得到上述数组再进行数组内相邻元素比较元素字符串长度取小值，然后相加，类似上面方法即可。</span></p></div>]]></content>
      
      
      <categories>
          
          <category> 计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 📶线结构：字符串-数组-栈-队列 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ts使用及注意事项</title>
      <link href="/blog/xigb8k/"/>
      <url>/blog/xigb8k/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h2 id="Pexq9"><span class="ne-text">使用</span></h2><p id="udcfaf747" class="ne-p"><span class="ne-text">安装：</span><code class="ne-code"><span class="ne-text">npm install -g typescript</span></code></p><p id="ue89624dc" class="ne-p"><span class="ne-text">编译：</span><code class="ne-code"><span class="ne-text">tsc helloworld.ts</span></code></p><h3 id="fqI6Q"><span class="ne-text">报错：tsc : 无法加载文件···</span></h3><p id="udc41684a" class="ne-p"><span class="ne-text">如果报如下错：</span></p><pre><code>tsc : 无法加载文件 D:\Program Files\nodejs\tsc.ps1，因为在此系统上禁止运行脚本。有关详细信息，请参阅 https:/go.microsoft.com/fwlink</code></pre><ol class="ne-ol"><li id="u05bfe0c4"><span class="ne-text">管理员身份运行vs code</span></li><li id="uf085bbb7"><span class="ne-text">在终端执行：get-ExecutionPolicy，显示Restricted</span></li><li id="u6c8f7fe1"><span class="ne-text">在终端执行：set-ExecutionPolicy RemoteSigned</span></li><li id="u10b6b7b8"><span class="ne-text">在终端执行：get-ExecutionPolicy，显示RemoteSigned</span></li></ol><h2 id="Iz9Bb"><span class="ne-text" style="color: rgb(37, 41, 51)">nodemon运行ts文件</span></h2><ul class="ne-ul"><li id="u1144f406"><span class="ne-text">参考：</span><a href="https://juejin.cn/post/7035637086451400734" data-href="https://juejin.cn/post/7035637086451400734" target="_blank" class="ne-link"><span class="ne-text">https://juejin.cn/post/7035637086451400734</span></a></li></ul><h3 id="A9CTY"><span class="ne-text">tsconfig.json</span></h3><h2 id="imsep"><span class="ne-text">ts遍历对象</span></h2><p id="udbfd75c6" class="ne-p"><span class="ne-text">ts遍历对象不要使用</span><code class="ne-code"><span class="ne-text">for···in</span></code><span class="ne-text">，使用</span><code class="ne-code"><span class="ne-text">for···of</span></code></p><ul class="ne-ul"><li id="u33f536a9"><span class="ne-text">理由：</span><a href="https://stackoverflow.com/questions/65300784/declare-key-type-of-for-in-loop-in-typescript" data-href="https://stackoverflow.com/questions/65300784/declare-key-type-of-for-in-loop-in-typescript" target="_blank" class="ne-link"><span class="ne-text">https://stackoverflow.com/questions/65300784/declare-key-type-of-for-in-loop-in-typescript</span></a></li><li id="u6f5fa005"><span class="ne-text">遍历的其他方式参考：</span><a href="https://juejin.cn/post/6844904147146260488" data-href="https://juejin.cn/post/6844904147146260488" target="_blank" class="ne-link"><span class="ne-text">TypeScript小状况之遍历对象属性</span></a></li></ul><pre><code>const disabled = computed(() =&gt; &#123;  let flag = true  for (const [key, val] of Object.entries(formState)) &#123;    if (!val) &#123;      flag = true      break    &#125; else &#123;      flag = false    &#125;  &#125;  return flag&#125;)</code></pre><p id="u22d9647f" class="ne-p"><br></p><h2 id="OlnAT"><span class="ne-text">参考</span></h2><p id="u8eb1d75d" class="ne-p"><span class="ne-text">学习网站：</span></p><ul class="ne-ul"><li id="u071afcc4"><a href="https://www.tslang.cn/docs/home.html" data-href="https://www.tslang.cn/docs/home.html" class="ne-link"><span class="ne-text">文档简介 · TypeScript中文网 · TypeScript——JavaScript的超集</span></a></li><li id="u82f8a6d4"><a href="https://ts.xcatliu.com/introduction/what-is-typescript.html" data-href="https://ts.xcatliu.com/introduction/what-is-typescript.html" class="ne-link"><span class="ne-text">什么是 TypeScript · TypeScript 入门教程</span></a></li><li id="uf6abac79"><a href="https://segmentfault.com/a/1190000038959316" data-href="https://segmentfault.com/a/1190000038959316" class="ne-link"><span class="ne-text">推荐 7 个学习 TypeScript 的宝库，2021 学 TS 看这篇就够了！</span></a></li><li id="ue15f5395"><a href="https://juejin.cn/post/7018805943710253086" data-href="https://juejin.cn/post/7018805943710253086" class="ne-link"><span class="ne-text">2021 typescript史上最强学习入门文章(2w字) - 掘金</span></a></li></ul><p id="u36c62ed2" class="ne-p"><span class="ne-text">相关教程：</span></p><ul class="ne-ul"><li id="u23aa8793"><a href="https://www.cnblogs.com/wisewrong/p/13717287.html" data-href="https://www.cnblogs.com/wisewrong/p/13717287.html" target="_blank" class="ne-link"><span class="ne-text">Vue3.x 从零开始（一）—— Vue-cli or Vite 构建 TypeScript 项目</span></a></li><li id="u0a06663a"><a href="https://segmentfault.com/a/1190000019661168" data-href="https://segmentfault.com/a/1190000019661168" target="_blank" class="ne-link"><span class="ne-text">在Typescript项目中，如何优雅的使用ESLint和Prettier</span></a></li><li id="u23f477e7"><a href="https://segmentfault.com/a/1190000022809326" data-href="https://segmentfault.com/a/1190000022809326" target="_blank" class="ne-link"><span class="ne-text">了不起的 tsconfig.json 指南</span></a></li><li id="uce2288cc"><a href="https://cn.eslint.org/" data-href="https://cn.eslint.org/" target="_blank" class="ne-link"><span class="ne-text">官网：ESLint 可组装的JavaScript和JSX检查工具</span></a></li><li id="uaa4c7979"><a href="https://www.jianshu.com/p/ad1e46faaea2" data-href="https://www.jianshu.com/p/ad1e46faaea2" target="_blank" class="ne-link"><span class="ne-text">Eslint 超简单入门教程</span></a></li><li id="uf1a741f9"><a href="https://segmentfault.com/a/1190000020168436" data-href="https://segmentfault.com/a/1190000020168436" target="_blank" class="ne-link"><span class="ne-text">在Vue项目中使用Eslint+Prettier+Stylelint</span></a></li><li id="u408aada3"><a href="https://segmentfault.com/a/1190000019905650" data-href="https://segmentfault.com/a/1190000019905650" target="_blank" class="ne-link"><span class="ne-text">使用Vue-cli3搭建Vue+TypeScript项目</span></a></li><li id="u9f3ba0b3"><a href="https://www.cnblogs.com/suwanbin/p/13583717.html" data-href="https://www.cnblogs.com/suwanbin/p/13583717.html" target="_blank" class="ne-link"><span class="ne-text">prettier - vscode 保存代码自动格式化插件安装与配置项备注</span></a></li></ul></div>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
          <category> TypeScript </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Express框架及其使用</title>
      <link href="/blog/tdgoby/"/>
      <url>/blog/tdgoby/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h2 id="SZZM1"><span class="ne-text">express框架</span></h2><p id="u3d4ac39a" class="ne-p"><span class="ne-text">express框架相当于再http模块加上一个中间件合集。</span><strong><span class="ne-text">中间件</span></strong><span class="ne-text">的含义就相当于处理http请求的处理函数，而express相当于调用多个中间件，这么一个框架。</span></p><p id="u8f6b3063" class="ne-p"><br></p><p id="uda9de047" class="ne-p"><span class="ne-text">参考：</span></p><ul class="ne-ul"><li id="u84242c89"><a href="https://javascript.ruanyifeng.com/nodejs/express.html" data-href="https://javascript.ruanyifeng.com/nodejs/express.html" target="_blank" class="ne-link"><span class="ne-text">Express框架 来自《JavaScript 标准参考教程（alpha）》，by 阮一峰</span></a></li><li id="u29e2fce3"><a href="https://juejin.cn/post/6844904023380721678" data-href="https://juejin.cn/post/6844904023380721678" target="_blank" class="ne-link"><span class="ne-text">一杯茶的时间，上手 Express 框架开发</span></a></li></ul><p id="u3f1842ae" class="ne-p"><span class="ne-text"></span></p><p id="u39af97d3" class="ne-p"><span class="ne-text">相关文档：</span></p><ul class="ne-ul"><li id="u74927218"><a href="http://expressjs.jser.us/" data-href="http://expressjs.jser.us/" target="_blank" class="ne-link"><span class="ne-text">http://expressjs.jser.us/</span></a></li></ul><p id="u85187766" class="ne-p"><span class="ne-text"></span></p><p id="u79d28551" class="ne-p"><span class="ne-text">项目下载使用：</span></p><pre><code>cnpm install express --save</code></pre><h3 id="bvAQ0"><span class="ne-text">express路由结构化</span></h3><p id="u57d10c9d" class="ne-p"><a href="https://expressjs.com/zh-cn/guide/routing.html" data-href="https://expressjs.com/zh-cn/guide/routing.html" target="_blank" class="ne-link"><span class="ne-text">https://expressjs.com/zh-cn/guide/routing.html</span></a></p><h3 id="aGSGq"><span class="ne-text">express里http.createServer</span></h3><pre><code>const app = express()<p>app.use(bodyParser.json(&#123; limit: ‘10mb’ &#125;))<br>app.use(<br>  bodyParser.urlencoded(&#123;<br>    extended: false,<br>  &#125;)<br>)<br>const server = http.createServer(app)<br></code></pre></p><p id="uff13f501" class="ne-p"><span class="ne-text">第9行代码这样写好处有：</span></p><p id="u10abaaf7" class="ne-p"><span class="ne-text">用http封装不但可以使用express的属性和方法，而且还可以使用http的属性和方法</span></p><p id="u2c79cc69" class="ne-p"><span class="ne-text">具体可以参考这段讨论：</span><a href="https://cnodejs.org/topic/5396cd60c3ee0b5820f00e2a" data-href="https://cnodejs.org/topic/5396cd60c3ee0b5820f00e2a" target="_blank" class="ne-link"><span class="ne-text">express里http.createServer和app.listen有什么区别？</span></a></p><h3 id="maJie"><span class="ne-text">express 常用API</span></h3><h4 id="PFv2f"><span class="ne-text">use方法和中间件</span></h4><ul class="ne-ul"><li id="u3d50a3b4"><span class="ne-text">注册中间件，返回的是函数。注意第三个参数next，如果写</span><code class="ne-code"><span class="ne-text">next()</span></code><span class="ne-text">语句则执行完该中间件，前往下一个中间件执行下一个中间件，如果不写，则执行完该中间件，就停止运行中间件。</span></li><li id="u8f2e76c8"><span class="ne-text">中间件，如果注册了路由，则只显示路由内容，所以使用的时候，中间件的url不应该是具体路由，而是一层路由，其他的二层路由则是具体内容路由。</span></li></ul><pre><code>let express = require('express')let app = express()<p>// 路由<br>app.get(‘/‘, function (req, res) &#123;<br>  res.send(‘Hello world’)<br>&#125;)<br>app.get(‘/customer’, function (req, res) &#123;<br>  res.send(‘customer page’)<br>&#125;)<br>// app.get(‘/admin’, function (req, res) &#123;<br>//   console.log(‘—————————-‘)<br>//   res.send(‘admin page’)<br>// &#125;)</p><p>// 中间件<br>// 如果注册了路由，则只显示路由内容<br>app.use(‘/admin’, function (request, response, next) &#123;<br>  response.writeHead(200, &#123; ‘Content-Type’: ‘text/plain’ &#125;)<br>  response.end(‘Welcome to the admin page!\n’)<br>&#125;)</p><p>app.listen(3000)<br>console.log(‘to <a href="http://localhost:3000/&#39;">http://localhost:3000/&#39;</a>)<br></code></pre></p><h4 id="yJMJU"><span class="ne-text">get方法</span></h4><ul class="ne-ul"><li id="uc076919a"><span class="ne-text">注册路由，用于指定不同的访问路径所对应的回调函数。由于get方法没有next回调函数，所以按照执行顺序，当地一个get方法执行了（根据匹配成功参数路径），后续的都不会执行了</span></li></ul><div class="ne-quote"><p id="ue5d6d127" class="ne-p"><span class="ne-text">put()post()put()del()类似get()使用（delete是JavaScript保留字，所以改叫del）</span></p></div><p id="uc807da1e" class="ne-p"><span class="ne-text">对于第一个参数，也就是路径参数，有不同的匹配规则</span></p><pre><code>app.get('/customer/:who', function (req, res) &#123;  res.send('都能访问 /' + req.params.who + ' 该路径')&#125;)</code></pre><p id="udeb39565" class="ne-p"><span class="ne-text">访问 </span><a href="http://localhost:3000/customer/fa" data-href="http://localhost:3000/customer/fa" target="_blank" class="ne-link"><span class="ne-text">http://localhost:3000/customer/fa</span></a><span class="ne-text"> 返回 </span><code class="ne-code"><span class="ne-text">都能访问 /fa 该路径</span></code></p><p id="u5886c758" class="ne-p"><span class="ne-text">访问</span><a href="http://localhost:3000/customer/ad" data-href="http://localhost:3000/customer/ad" target="_blank" class="ne-link"><span class="ne-text">http://localhost:3000/customer/ad</span></a><span class="ne-text"> 返回 </span><code class="ne-code"><span class="ne-text">都能访问 /ad 该路径</span></code></p><p id="ud73bb228" class="ne-p"><span class="ne-text">不能访问</span><a href="http://localhost:3000/customer" data-href="http://localhost:3000/customer" target="_blank" class="ne-link"><span class="ne-text">http://localhost:3000/customer</span></a></p><p id="u8257ffd5" class="ne-p"><span class="ne-text">如果是:who? 则成为可选路径</span></p><h4 id="GoJ2E"><span class="ne-text">set方法</span></h4><ul class="ne-ul"><li id="ube09ff24"><span class="ne-text">指定变量的值</span></li></ul><pre><code>// 告诉express框架模板的位置app.set('views', path.join(__dirname, 'views'))// 告诉express框架模板的默认后缀是什么app.set('view engine', 'art');</code></pre><h4 id="tCcvQ"><span class="ne-text">response对象</span></h4><p id="uc267f8b7" class="ne-p"><span class="ne-text">response.redirect方法允许网址的重定向。</span></p><p id="uf70b4e36" class="ne-p"><span class="ne-text">response.sendFile方法用于发送文件。</span></p><p id="u2bffa3d7" class="ne-p"><span class="ne-text">response.render方法用于渲染网页模板。</span></p><h4 id="YSrGP"><span class="ne-text">request对象</span></h4><h4 id="KIPOO"><span class="ne-text">搭建HTTPS环境</span></h4><p id="udbceda63" class="ne-p"><span class="ne-text">上传crt和key文件</span></p><pre><code>var fs = require('fs');var options = &#123;  key: fs.readFileSync('E:/ssl/myserver.key'),  cert: fs.readFileSync('E:/ssl/myserver.crt'),  passphrase: '1234'&#125;;<p>var https = require(‘https’);<br>var express = require(‘express’);<br>var app = express();</p><p>app.get(‘/‘, function(req, res)&#123;<br>  res.send(‘Hello World Expressjs’);<br>&#125;);</p><p>var server = https.createServer(options, app);<br>server.listen(8084);<br>console.log(‘Server is running on port 8084’);<br></code></pre></p><h3 id="JlltX"><span class="ne-text">express写API接口</span></h3><h4 id="NEOTJ"><span class="ne-text">References</span></h4><ul class="ne-ul"><li id="u95bf99da"><a href="https://blog.csdn.net/m0_48375854/article/details/122447235" data-href="https://blog.csdn.net/m0_48375854/article/details/122447235" target="_blank" class="ne-link"><span class="ne-text">Node.js---使用Express写接口</span></a></li></ul><h4 id="ZRE1G"><span class="ne-text">response对象json方法写接口</span></h4><p id="u7bd04614" class="ne-p"><span class="ne-text">内置json响应的方式：</span></p><pre><code>/* * @Author: wztlink1013 * @Date: 2022-01-11 11:04:38 * @LastEditTime: 2022-01-11 11:21:17 * @Description: */let obj = &#123;  1: &#123;    id: 1234,    name: '张三',    college: '计算机科学与工程学院',    grade: 2018,    classes: 2,    age: 21,  &#125;,  2: &#123;    id: 5678,    name: '李四',    college: '计算机科学与工程学院',    grade: 2018,    classes: 2,    age: 21,  &#125;,&#125;<p>exports.index = function (req, res) &#123;<br>  res.status(200).json(obj)<br>&#125;<br></code></pre></p><pre><code>// 接口的使用let userinfo = require('./api/userinfo.js')app.get('/api/userinfo', userinfo.index)</code></pre><h4 id="zzaxG"><span class="ne-text">js使用接口的一些方法</span></h4><ul class="ne-ul"><li id="u43b7106d"><span class="ne-text">用之前总结的使用接口一些方法：</span><a href="https://github.com/wztlink1013/web-learn-notes/tree/gh-pages/learn-interface" data-href="https://github.com/wztlink1013/web-learn-notes/tree/gh-pages/learn-interface" target="_blank" class="ne-link"><span class="ne-text">https://github.com/wztlink1013/web-learn-notes/tree/gh-pages/learn-interface</span></a></li></ul><h4 id="mwKb2"><span class="ne-text">跨域问题的解决</span></h4><p id="uf6998da1" class="ne-p"><span class="ne-text">解法一：手写（但是有看到网上说会有设备（iPhone6）不兼容等问题）</span></p><pre><code>// 跨域设置app.all(&quot;*&quot;, function(req, res, next) &#123;    res.header(&quot;Access-Control-Allow-Credentials&quot;, true);    res.header(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;);    res.header(&quot;Access-Control-Allow-Headers&quot;, &quot;X-Requested-With&quot;);    res.header(&quot;Access-Control-Allow-Methods&quot;, &quot;PUT,POST,GET,DELETE,OPTIONS&quot;);    res.header(&quot;Content-Type&quot;, &quot;application/json;charset=utf-8&quot;);    next();&#125;);</code></pre><p id="u3807f4e8" class="ne-p"><span class="ne-text">解法二：直接使用npm里面的cors包</span></p><pre><code>&lt;!-- * @Descripttion: learn axios * @Date: 2021-12-21 09:40:36 * @LastEditTime: 2022-01-11 11:25:28--&gt;&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;  &lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot; /&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;    &lt;title&gt;Document&lt;/title&gt;    &lt;script src=&quot;https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js&quot;&gt;&lt;/script&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;script&gt;      // 配置公共的请求头      axios.defaults.baseURL = 'http://localhost:3000/'      // 配置 超时时间      axios.defaults.timeout = 2500      // 配置公共的请求头      // axios.defaults.headers.common[&quot;Authorization&quot;] =      //   &quot;token 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&quot;      // axios.defaults.headers.common[&quot;Accept&quot;] = &quot;application/vnd.github.v3+json&quot;      // 配置公共的 post 的 Content-Type      axios.defaults.headers.post['Content-Type'] = 'application/json'<pre><code>  // 请求/响应 拦截器的配置  axios.interceptors.request.use(    config =&amp;gt; &#123;      console.log(&#39;请求拦截器: &#39;)      config.headers.Accept = &#39;application/vnd.github.v3+json&#39;      config.headers.Authorization =        &#39;token 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&#39;      console.log(config)      return config    &#125;,    err =&amp;gt; &#123;      console.log(err)    &#125;  )  axios.interceptors.response.use(    data =&amp;gt; &#123;      console.log(&#39;响应拦截器: &#39;)      console.log(data.data)      return data.data    &#125;,    err =&amp;gt; &#123;      console.log(err)    &#125;  )  // 请求数据  axios.get(&#39;api/userinfo&#39;).then(data =&amp;gt; &#123;    console.log(data)  &#125;)&amp;lt;/script&amp;gt;</code></pre><p>  &lt;/body&gt;<br>&lt;/html&gt;</p><p></code></pre></p><p id="ub187bf50" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1641872349891-229b5dc9-c17f-4a3b-bbef-98611971015f.png" width="569.5" id="g5VY5" class="ne-image"></p><h4 id="RIBJU"><span class="ne-text">Postman 测试API工具</span></h4><p id="u76413f3c" class="ne-p"><span class="ne-text">如果是本地写的接口，也就是localhost类的，在web postman上是不能测试的，只能下载Postman PC应用来测试。</span></p><h3 id="HdYAo"><span class="ne-text">body-parser模块</span></h3><p id="u3898d1c9" class="ne-p"><span class="ne-text">body-parser为express框架的中间件，其作用就是对post请求的请求体进行解析。</span></p><p id="u0ca951ed" class="ne-p"><span class="ne-text">下载使用：</span></p><pre><code>cnpm install body-parser</code></pre><h4 id="JrfFg"><span class="ne-text">bodyParser.json( )与bodyParser.urlencoded( )</span></h4><ul class="ne-ul"><li id="u374ee14f"><span class="ne-text">limit参数（json）：控制请求体最大尺寸</span></li><li id="u160b544d"><span class="ne-text">extended参数（urlencoded）：</span></li></ul><p id="ub4779aaa" class="ne-p"><code class="ne-code"><span class="ne-text">extended: false</span></code><span class="ne-text">：表示使用系统模块querystring来处理，也是官方推荐的</span></p><p id="ub7c93c26" class="ne-p"><code class="ne-code"><span class="ne-text">extended: true</span></code><span class="ne-text">：表示使用第三方模块qs来处理</span></p><p id="u6b87a5c0" class="ne-p"><span class="ne-text">从功能性来讲，qs比querystring要更强大，所以这里可以根据项目的实际需求来考虑</span></p><p id="ub39513a2" class="ne-p"><span class="ne-text">详见：</span><a href="https://github.com/expressjs/body-parser/#extended" data-href="https://github.com/expressjs/body-parser/#extended" target="_blank" class="ne-link"><span class="ne-text">https://github.com/expressjs/body-parser/#extended</span></a></p><h4 id="RAcgG"><span class="ne-text">References</span></h4><ul class="ne-ul"><li id="u024103cd"><span class="ne-text"></span><a href="https://github.com/expressjs/body-parser/" data-href="https://github.com/expressjs/body-parser/" target="_blank" class="ne-link"><span class="ne-text">https://github.com/expressjs/body-parser/</span></a></li><li id="u4c67161c"><a href="https://www.cnblogs.com/chyingp/p/nodejs-learning-express-body-parser.html" data-href="https://www.cnblogs.com/chyingp/p/nodejs-learning-express-body-parser.html" target="_blank" class="ne-link"><span class="ne-text">Nodejs 进阶：Express 常用中间件 body-parser 实现解析 </span></a></li><li id="ue3e4885a"><a href="https://segmentfault.com/a/1190000004407008" data-href="https://segmentfault.com/a/1190000004407008" target="_blank" class="ne-link"><span class="ne-text">bodyParser中间件的研究</span></a></li></ul><h3 id="H76rt"><span class="ne-text">express-session模块</span></h3><p id="e5a83eec75d9703913b34f5a57c6c0e2" class="ne-p"><span class="ne-text">设置Cookie，</span><code class="ne-code"><span class="ne-text">app.use(session(&#123;secret: 'secret key'&#125;));</span></code></p><p id="668b82e8367ae7ff8268aa4fba2d1143" class="ne-p"><span class="ne-text">当参数为secret时候，通过设置的secret字符串，来计算hash值并放在cookie中，使产生的signedCookie防篡改</span></p><p id="96273afa9f3a7693cd6a47e0ad7ac5ae" class="ne-p"><br></p><p id="ec1e13fd45edd3c0f24876ef7e7914d6" class="ne-p"><span class="ne-text">还有其他的参数：</span></p><ul class="ne-ul"><li id="a790486bd5a810616c3cf007ec2ac6aa"><span class="ne-text">name: 设置cookie中，保存session的字段名称，默认为connect.sid</span></li><li id="872441e9f2d437c3d2c811e72cc7e213"><span class="ne-text">store: session的存储方式，默认为存放在内存中，我们可以自定义redis等</span></li><li id="a7b14914a20f582ee51f69406a07fd35"><span class="ne-text">genid: 生成一个新的session_id时，默认为使用uid2这个npm包</span></li><li id="b25a9619e55805dadbef4599663a29d3"><span class="ne-text">rolling: 每个请求都重新设置一个cookie，默认为false</span></li><li id="1fa877bdbea80baa1648088af27de7bf"><span class="ne-text">resave: 即使session没有被修改，也保存session值，默认为true</span></li><li id="bca8d2e03acc9f1b4960caaf7bb67ed4"><span class="ne-text">saveUninitialized：强制未初始化的session保存到数据库</span></li><li id="92596e74df5537944f8fc2acb7e8c36c"><span class="ne-text">secret: 通过设置的secret字符串，来计算hash值并放在cookie中，使产生的signedCookie防篡改</span></li><li id="d35772ab8f12660bf32fe38e9ad0d7e7"><span class="ne-text">cookie : 设置存放sessionid的cookie的相关选项</span></li></ul></div>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
          <category> Node.js </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>mongoose操作MongoDB数据库</title>
      <link href="/blog/xfn7hy/"/>
      <url>/blog/xfn7hy/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><ul class="ne-ul"><li id="ud43c3a98"><span class="ne-text">GitHub：</span><a href="https://github.com/Automattic/mongoose" data-href="https://github.com/Automattic/mongoose" target="_blank" class="ne-link"><span class="ne-text">https://github.com/Automattic/mongoose</span></a></li><li id="ud396ccb4"><span class="ne-text">英文文档：</span><a href="https://mongoosejs.com/docs/guide.html" data-href="https://mongoosejs.com/docs/guide.html" target="_blank" class="ne-link"><span class="ne-text">https://mongoosejs.com/docs/guide.html</span></a></li><li id="ucd4684f0"><span class="ne-text">中文文档：</span><a href="http://www.mongoosejs.net/docs/guide.html" data-href="http://www.mongoosejs.net/docs/guide.html" target="_blank" class="ne-link"><span class="ne-text">http://www.mongoosejs.net/docs/guide.html</span></a></li><li id="uea71dde7"><a href="https://zhuanlan.zhihu.com/p/56030432" data-href="https://zhuanlan.zhihu.com/p/56030432" target="_blank" class="ne-link"><span class="ne-text">如何使用nodejs写一个接口 - MySQL版</span></a></li></ul><p id="ue53bab1a" class="ne-p"><span class="ne-text"></span></p><p id="u2a1cce22" class="ne-p"><span class="ne-text">shardb-mongodb模块操作数据库不好去使用，比如查询，新建等，所以这个模块只用作ot服务那边；</span></p><p id="ue31486e0" class="ne-p"><span class="ne-text">另外使用mongoose去操作数据库方便写接口</span></p><ul class="ne-ul"><li id="ud603d93e"><a href="https://github.com/share/sharedb-mongo" data-href="https://github.com/share/sharedb-mongo" target="_blank" class="ne-link"><span class="ne-text">https://github.com/share/sharedb-mongo</span></a></li><li id="u387c569c"><a href="https://www.jianshu.com/p/46f06896c9cd" data-href="https://www.jianshu.com/p/46f06896c9cd" target="_blank" class="ne-link"><span class="ne-text">Mongoose 查询结果为空</span></a></li></ul><p id="u59f5e9b2" class="ne-p"><span class="ne-text">schema的相关配置为connection</span></p><ul class="ne-ul"><li id="uc952063f"><span class="ne-text">之前的增删改查笔记：</span><a href="https://github.com/wztlink1013/web-learn-notes/blob/gh-pages/learn-nodejs/express/model/connect.js" data-href="https://github.com/wztlink1013/web-learn-notes/blob/gh-pages/learn-nodejs/express/model/connect.js" target="_blank" class="ne-link"><span class="ne-text">https://github.com/wztlink1013/web-learn-notes/blob/gh-pages/learn-nodejs/express/model/connect.js</span></a></li><li id="u8ee35e52"><a href="https://segmentfault.com/a/1190000019201081" data-href="https://segmentfault.com/a/1190000019201081" target="_blank" class="ne-link"><span class="ne-text">mongoose踩坑笔记： Cannot overwrite `` model once compiled.</span></a></li></ul><h2 id="UocgJ"><span class="ne-text">安装</span></h2><h3 id="VZPAG"><span class="ne-text">MongoDB以及可视化工具Navicat</span></h3><p id="u9f7c554d" class="ne-p"><span class="ne-text">参考之前写的文章：</span><a href="https://www.yuque.com/wztlink1013/blog/nwt63v" data-href="https://www.yuque.com/wztlink1013/blog/nwt63v" target="_blank" class="ne-link"><span class="ne-text">MongoDB下载及使用+Navicat使用+服务器上的配置</span></a></p><h3 id="uwCTa"><span class="ne-text">安装mongoose</span></h3><pre><code>cnpm install mongoose -S</code></pre><h2 id="YR98P"><span class="ne-text">使用</span></h2><h3 id="CuLRf"><span class="ne-text">连接数据库语句</span></h3><pre><code>// 连接数据库mongoose  .connect('mongodb://127.0.0.1:27017/test-mongoose', &#123;    useNewUrlParser: true,    useUnifiedTopology: true,  &#125;)  .then(() =&gt; &#123;    console.log('数据库连接成功')  &#125;)  .catch(() =&gt; &#123;    console.log('数据库连接失败')  &#125;)</code></pre><p id="c9c95a662d6bdc8dfc56fe5b2a44cf39" class="ne-p"><span class="ne-text">然后再将这个js文件require到app.js里面使用</span></p><pre><code>// 数据库连接require('./model/connect')</code></pre><h3 id="q5hLU"><span class="ne-text">创建集合</span></h3><ul class="ne-ul"><li id="7d037472da9784ef7d33551a40fc00d8"><span class="ne-text">先利用函数mongoose的schema函数构建一个规则</span></li><li id="30e3a9d06838927e8d7b6185651b5f25"><span class="ne-text">然后利用model函数创建一个集合并且用上这个规则</span></li></ul><pre><code>// Schema：数据库集合的结构对象。// 创建一个集合(相当于sql里面的设定一个表)规则let TestSchema = new mongoose.Schema(&#123;  name: &#123; type: String &#125;,  age: &#123; type: Number, default: 0 &#125;,  email: &#123; type: String &#125;,  time: &#123; type: Date, default: Date.now &#125;,&#125;)<p>// Model ：由Schema构造而成，可操作数据库。<br>// 创建一个集合(并且应用上面的规则)<br>let TestModel = mongoose.model(‘schema’, TestSchema)<br></code></pre></p><h3 id="lC5j4"><span class="ne-text">增加文档</span></h3><ul class="ne-ul"><li id="c1ebd2524e4df9a8bc19d7366ca3792c"><span class="ne-text">第一个参数：create函数</span></li><li id="399e7ec053484186a0799b2639092da0"><span class="ne-text">第二个参数：可以打印相关信息（doc和err）</span></li></ul><pre><code>// 创建（创建完执行以便之后就注释掉，不然会一直重复创建）TestModel.create(  [    &#123; name: 'test-1', age: 8 &#125;,    &#123; name: 'test-2', age: 18 &#125;,    &#123; name: 'test-3', age: 28 &#125;,    &#123; name: 'test-4', age: 38 &#125;,    &#123; name: 'test-5', age: 48 &#125;,    &#123; name: 'test-6', age: 58, email: 'tttt@qq.com' &#125;,    &#123; name: 'test-7', age: 68, email: 'ssss@qq.com' &#125;,    &#123; name: 'test-8', age: 18 &#125;,    &#123; name: 'test-9', age: 18, email: 'rrrr@qq.com' &#125;,    &#123; name: 'test-10', age: 18 &#125;,  ],  (error, docs)&#123;    if (error) &#123;      console.log(error)    &#125; else &#123;      console.log('save ok')      console.log(docs)    &#125;  &#125;)</code></pre><ul class="ne-ul"><li id="a41addd210d7686d49f6ebcc93cf8e30"><span class="ne-text">也可以创建一个对象赋值给一个变量，然后该变量利用函数save即可保存到数据库</span></li></ul><div data-type="danger" class="ne-alert"><p id="u59cd1a38" class="ne-p"><span class="ne-text">创建完执行以便之后就注释掉，不然会一直重复创建</span></p></div><h3 id="vvKaw"><span class="ne-text">查询文档</span></h3><ul class="ne-ul"><li id="u47e0fb62"><span class="ne-text">查询函数</span><code class="ne-code"><span class="ne-text">findOne</span></code><span class="ne-text">：返回第一条数据</span></li><li id="u7c9bc1e0"><span class="ne-text">查询函数</span><code class="ne-code"><span class="ne-text">find</span></code><span class="ne-text">：查询所有包含条件的数据</span></li></ul><pre><code>// 查询TestModel.find(  // 28&lt;= age &lt;48  &#123; age: &#123; $gte: 28, $lt: 48 &#125; &#125;,  // 1为指定字段，0为排除字段  &#123; name: 1, age: 1, _id: 0 &#125;,  function (err, docs) &#123;    if (err) &#123;      console.log('查询出错: ' + err)    &#125; else &#123;      console.log('$gte,$lte查询结果为: ')      console.log(docs)    &#125;  &#125;)</code></pre><h3 id="xa1jM"><span class="ne-text">mongoose条件查询</span></h3><p id="u5d586ab7" class="ne-p"><span class="ne-text">键为变量时用</span></p><p id="u520d896c" class="ne-p"><span class="ne-text">中括号括起来就行了</span></p><pre><code>checkStr(data.type_id, 'email')    ? (type_str = 'email')    : (type_str = 'user_id')Model_user.find(&#123; [type_str]: data.type_id &#125;, &#123;&#125;, (err, docs) =&gt; &#123;&#125;</code></pre><p id="u847b6a58" class="ne-p"><span class="ne-text"></span></p><p id="ub924cbe9" class="ne-p"><span class="ne-text">逻辑查询</span></p><p id="uaded3def" class="ne-p"><span class="ne-text">参考：</span></p><ul class="ne-ul"><li id="u60000458"><span class="ne-text">文档：</span><a href="http://mongoosejs.net/docs/queries.html" data-href="http://mongoosejs.net/docs/queries.html" target="_blank" class="ne-link"><span class="ne-text">http://mongoosejs.net/docs/queries.html</span></a></li><li id="u8661ef16"><a href="https://segmentfault.com/a/1190000021010300" data-href="https://segmentfault.com/a/1190000021010300" target="_blank" class="ne-link"><span class="ne-text">mongoose 系列之一 find 查询</span></a></li></ul><pre><code>Model_user.find(  &#123; $or: [&#123; email: obj.email &#125;, &#123; user_id: obj.user_id &#125;] &#125;,  &#123;&#125;,  (err, docs) =&gt; &#123;&#125;)</code></pre><h3 id="lVQsg"><span class="ne-text">更新文档</span></h3><p id="ue3e09cc1" class="ne-p"><code class="ne-code"><span class="ne-text">User.updateOne(&#123;查询条件&#125;, &#123;要修改的值&#125;).then(result =&gt; console.log(result))</span></code></p><ul class="ne-ul"><li id="ua77d93c9"><span class="ne-text">updateOne：更新单个</span></li><li id="ua869ce75"><span class="ne-text">updateMany：更新多个</span></li></ul><pre><code>// 更新let conditions_1 = &#123; name: 'test-3' &#125;let update = &#123; $set: &#123; age: 11 &#125; &#125;TestModel.updateOne(conditions_1, update, function (error) &#123;  if (error) &#123;    console.log(error)  &#125; else &#123;    console.log('Update success!')    TestModel.find(      &#123; name: 'test-3' &#125;,      &#123; name: 1, age: 1, _id: 0 &#125;,      function (err, docs) &#123;        if (err) &#123;          console.log('查询出错: ' + err)        &#125; else &#123;          console.log('更新test-3后的查询结果为: ')          console.log(docs)        &#125;      &#125;    )  &#125;&#125;)</code></pre><h3 id="juiBb"><span class="ne-text">删除文档</span></h3><ul class="ne-ul"><li id="uf64adeb5"><span class="ne-text">删除单个：</span><code class="ne-code"><span class="ne-text">User.findOneAndDelete(&#123;&#125;)then(result =&gt; console.log(result))</span></code></li><li id="u3ecf60ad"><span class="ne-text">删除多个：</span><code class="ne-code"><span class="ne-text">User.deleteMany(&#123;&#125;).then(result =&gt; console.log(result))</span></code></li><li id="u2a8122d7"><span class="ne-text">deleteOne：删除单个</span></li></ul><pre><code>// 删除let conditions_2 = &#123; name: 'test-2' &#125;TestModel.deleteOne(conditions_2, function (error) &#123;  if (error) &#123;    console.log(error)  &#125; else &#123;    console.log('Delete success!')    TestModel.find(      &#123; name: 'test-2' &#125;,      &#123; name: 1, age: 1, _id: 0 &#125;,      function (err, docs) &#123;        if (err) &#123;          console.log('查询出错: ' + err)        &#125; else &#123;          console.log('删除test-2后的查询结果为: ')          console.log(docs)        &#125;      &#125;    )  &#125;&#125;)<p></code></pre></p><h3 id="NvcCP"><span class="ne-text">mongoose验证</span></h3><p id="6768b794faaf2f60036a6c1c2be309ab" class="ne-p"><br></p><p id="8ab6701f4a72f8e0af41382696760cfa" class="ne-p"><span class="ne-text">required: true 必传字段</span></p><p id="90378084bf4da9d8b82c9cd3712c60a5" class="ne-p"><span class="ne-text">minlength：3 字符串最小长度</span></p><p id="a97cb1cb66346a2d92bcd163175b37da" class="ne-p"><span class="ne-text">maxlength: 20 字符串最大长度</span></p><p id="8ec377a0a479a76429e2dd9201a85ac0" class="ne-p"><span class="ne-text">min: 2 数值最小为2</span></p><p id="7407fc8f50616d578f6683c6eca44f5a" class="ne-p"><span class="ne-text">max: 100 数值最大为100</span></p><p id="6a0c063a60a1416474477e1ef7fd4917" class="ne-p"><span class="ne-text">enum: ['html', 'css', 'javascript', 'node.js']</span></p><p id="dbdb49fa5f9fdc7cd81252f2533703c5" class="ne-p"><span class="ne-text">trim: true 去除字符串两边的空格</span></p><p id="4ad5cb8f78d2a95c5e3991b01f3519e6" class="ne-p"><span class="ne-text">validate: 自定义验证器</span></p><p id="fa2c27ed12d7ac7ad1b48f59c2f5a599" class="ne-p"><span class="ne-text">default: 默认值</span></p><p id="9ae5494a2609fbfaf10e59aa78fbd07a" class="ne-p"><br></p><p id="a018ee404ec903f0043c1b7fa65017d9" class="ne-p"><span class="ne-text">获取错误信息：error.errors['字段名称'].message</span></p><h3 id="Fa0Tc"><span class="ne-text">整体代码</span></h3><pre><code>/* * @Author: wztlink1013 * @Date: 2022-01-11 12:43:02 * @LastEditTime: 2022-01-11 16:44:13 * @Description: */const mongoose = require('mongoose')<p>// 连接数据库<br>mongoose<br>  .connect(‘mongodb://127.0.0.1:27017/test-mongoose’, &#123;<br>    useNewUrlParser: true,<br>    useUnifiedTopology: true,<br>  &#125;)<br>  .then(() =&gt; &#123;<br>    console.log(‘数据库连接成功’)<br>  &#125;)<br>  .catch(() =&gt; &#123;<br>    console.log(‘数据库连接失败’)<br>  &#125;)</p><p>// Schema：数据库集合的结构对象。<br>let TestSchema = new mongoose.Schema(&#123;<br>  name: &#123; type: String &#125;,<br>  age: &#123; type: Number, default: 0 &#125;,<br>  email: &#123; type: String &#125;,<br>  time: &#123; type: Date, default: Date.now &#125;,<br>&#125;)</p><p>// Model ：由Schema构造而成，可操作数据库。<br>let TestModel = mongoose.model(‘schema’, TestSchema)</p><p>// Entity：由Model创建的实体，可操作数据库。<br>// let TestEntity = new TestModel(&#123;<br>//   name: ‘helloworld’,<br>//   age: 28,<br>//   email: ‘<a href="mailto:&#x68;&#x65;&#x6c;&#x6c;&#111;&#119;&#111;&#x72;&#108;&#x64;&#x40;&#113;&#113;&#46;&#x63;&#111;&#109;">&#x68;&#x65;&#x6c;&#x6c;&#111;&#119;&#111;&#x72;&#108;&#x64;&#x40;&#113;&#113;&#46;&#x63;&#111;&#109;</a>‘,<br>// &#125;)<br>// console.log(TestEntity)</p><p>// 创建（创建完执行以便之后就注释掉，不然会一直重复创建）<br>// TestModel.create(<br>//   [<br>//     &#123; name: ‘test-1’, age: 8 &#125;,<br>//     &#123; name: ‘test-2’, age: 18 &#125;,<br>//     &#123; name: ‘test-3’, age: 28 &#125;,<br>//     &#123; name: ‘test-4’, age: 38 &#125;,<br>//     &#123; name: ‘test-5’, age: 48 &#125;,<br>//     &#123; name: ‘test-6’, age: 58, email: ‘<a href="mailto:&#x74;&#116;&#116;&#116;&#64;&#113;&#113;&#46;&#99;&#x6f;&#x6d;">&#x74;&#116;&#116;&#116;&#64;&#113;&#113;&#46;&#99;&#x6f;&#x6d;</a>‘ &#125;,<br>//     &#123; name: ‘test-7’, age: 68, email: ‘<a href="mailto:&#x73;&#x73;&#115;&#115;&#64;&#x71;&#113;&#46;&#99;&#111;&#x6d;">&#x73;&#x73;&#115;&#115;&#64;&#x71;&#113;&#46;&#99;&#111;&#x6d;</a>‘ &#125;,<br>//     &#123; name: ‘test-8’, age: 18 &#125;,<br>//     &#123; name: ‘test-9’, age: 18, email: ‘<a href="mailto:&#114;&#x72;&#x72;&#114;&#x40;&#113;&#x71;&#46;&#99;&#111;&#109;">&#114;&#x72;&#x72;&#114;&#x40;&#113;&#x71;&#46;&#99;&#111;&#109;</a>‘ &#125;,<br>//     &#123; name: ‘test-10’, age: 18 &#125;,<br>//   ],<br>//   function (error, docs) &#123;<br>//     if (error) &#123;<br>//       console.log(error)<br>//     &#125; else &#123;<br>//       // console.log(‘save ok’)<br>//       // console.log(docs)<br>//     &#125;<br>//   &#125;<br>// )</p><p>// 查询<br>TestModel.find(<br>  // 28&lt;= age &lt;48<br>  &#123; age: &#123; $gte: 28, $lt: 48 &#125; &#125;,<br>  // 1为指定字段，0为排除字段<br>  &#123; name: 1, age: 1, _id: 0 &#125;,<br>  function (err, docs) &#123;<br>    if (err) &#123;<br>      console.log(‘查询出错: ‘ + err)<br>    &#125; else &#123;<br>      console.log(‘$gte,$lte查询结果为: ‘)<br>      console.log(docs)<br>    &#125;<br>  &#125;<br>)<br>// 更新<br>let conditions_1 = &#123; name: ‘test-3’ &#125;<br>let update = &#123; $set: &#123; age: 11 &#125; &#125;<br>TestModel.updateOne(conditions_1, update, function (error) &#123;<br>  if (error) &#123;<br>    console.log(error)<br>  &#125; else &#123;<br>    console.log(‘Update success!’)<br>    TestModel.find(<br>      &#123; name: ‘test-3’ &#125;,<br>      &#123; name: 1, age: 1, _id: 0 &#125;,<br>      function (err, docs) &#123;<br>        if (err) &#123;<br>          console.log(‘查询出错: ‘ + err)<br>        &#125; else &#123;<br>          console.log(‘更新test-3后的查询结果为: ‘)<br>          console.log(docs)<br>        &#125;<br>      &#125;<br>    )<br>  &#125;<br>&#125;)<br>// 删除<br>let conditions_2 = &#123; name: ‘test-2’ &#125;<br>TestModel.deleteOne(conditions_2, function (error) &#123;<br>  if (error) &#123;<br>    console.log(error)<br>  &#125; else &#123;<br>    console.log(‘Delete success!’)<br>    TestModel.find(<br>      &#123; name: ‘test-2’ &#125;,<br>      &#123; name: 1, age: 1, _id: 0 &#125;,<br>      function (err, docs) &#123;<br>        if (err) &#123;<br>          console.log(‘查询出错: ‘ + err)<br>        &#125; else &#123;<br>          console.log(‘删除test-2后的查询结果为: ‘)<br>          console.log(docs)<br>        &#125;<br>      &#125;<br>    )<br>  &#125;<br>&#125;)<br></code></pre></p><p id="ube00435c" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1641879796743-f8670ed9-0562-4e6d-ab68-79418d34424f.png" width="373.49537658691406" id="ddiif" class="ne-image"></p><p id="ub82dbb10" class="ne-p"><br></p><p id="u29316754" class="ne-p"><br></p><p id="ud4ff2363" class="ne-p"><br></p><h3 id="Uz4XW"><span class="ne-text">其他</span></h3><ul class="ne-ul"><li id="u362fd903"><a href="https://blog.csdn.net/youhebuke225/article/details/106872122" data-href="https://blog.csdn.net/youhebuke225/article/details/106872122" target="_blank" class="ne-link"><span class="ne-text">mongoose查询到的对象无法读取问题</span></a></li></ul><h3 id="k5mRE"><span class="ne-text">mongodb创建集合</span></h3><p id="u50abd338" class="ne-p"><br></p></div>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
          <category> DataBase </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Springboot+Ajax全栈在线考试管理系统笔记</title>
      <link href="/blog/aeavli/"/>
      <url>/blog/aeavli/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="ub9d15cdc" class="ne-p"><span class="ne-text">校内实习笔记</span></p><h2 id="Zn9ho"><span class="ne-text">开发环境搭建</span></h2><h3 id="W6hhP"><span class="ne-text">MySQL下载安装</span></h3><ul class="ne-ul"><li id="ub2863bab"><span class="ne-text">下载地址：</span><a href="https://www.mysql.com/downloads/" data-href="https://www.mysql.com/downloads/" target="_blank" class="ne-link"><span class="ne-text">https://www.mysql.com/downloads/</span></a></li><li id="ub5f47daf"><span class="ne-text">安装下载教程：</span><a href="https://blog.csdn.net/Kindergarten_Sir/article/details/109274396" data-href="https://blog.csdn.net/Kindergarten_Sir/article/details/109274396" target="_blank" class="ne-link"><span class="ne-text">MySQL的下载与安装教程--超详细</span></a></li></ul><p id="u3d6edb70" class="ne-p"><span class="ne-text"></span></p><p id="u97153148" class="ne-p"><span class="ne-text">成功如下：</span></p><p id="u2f594951" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1645420397245-3062da09-70ef-47cb-94a0-1169ed942a1a.png" width="789.9999686082217" id="uf3cb7e10" class="ne-image"></p><p id="u8e210634" class="ne-p"><span class="ne-text">再配置环境变量（和java环境变量配置一样）</span></p><p id="u78a15551" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1645670861710-ec8aa52e-ae51-41d7-a008-03b385f5a189.png" width="576.666643751993" id="u53489e49" class="ne-image"></p><p id="u6d3eac2f" class="ne-p"><br></p><h3 id="eI3gv"><span class="ne-text">IDEA下载安装</span></h3><p id="ub40be899" class="ne-p"><span class="ne-text">IDEA下载：</span><a href="https://www.jetbrains.com.cn/idea/download/#section=windows" data-href="https://www.jetbrains.com.cn/idea/download/#section=windows" target="_blank" class="ne-link"><span class="ne-text">https://www.jetbrains.com.cn/idea/download/#section=windows</span></a></p><h3 id="cbjTa"><span class="ne-text">java下载安装</span></h3><p id="uea56c2b2" class="ne-p"><span class="ne-text">需要下载1.8版本的，之前版本删掉</span></p><p id="uaf99547c" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1645497764451-167842e2-5328-446e-bf72-a806cd4ba938.png" width="679.1666396790091" id="u7491a2a7" class="ne-image"></p><h3 id="SbzEb"><span class="ne-text">Maven下载安装</span></h3><p id="u15abe63a" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1645495772713-46fcc17d-68a0-4c2a-8901-87bc114cfe59.png" width="806.6666346126145" id="ua6d1ef1a" class="ne-image"></p><p id="uc0678083" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1645495819742-223ad090-3f07-4b04-95b2-e5262d74b394.png" width="822.4999673167878" id="ue1ef2b60" class="ne-image"></p><p id="u5d0ad3e5" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1645495723226-f5c72ffc-05cb-4b1c-99dc-cce4ec7667bf.png" width="813.3333010143717" id="u3a1d182d" class="ne-image"></p><h2 id="lcNBZ"><span class="ne-text">创建springboot应用程序</span></h2><h3 id="Gg6R5"><span class="ne-text">Maven模板快速创建项目</span></h3><p id="u93aa0b73" class="ne-p"><span class="ne-text">找到下面的选项快速创建</span></p><p id="ud8a8be20" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1645496306314-3c77ca31-a9e7-4e1e-96de-4e26ff1a98c6.png" width="1364.1666124595558" id="uceef7a43" class="ne-image"></p><p id="u54ceb27a" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1645496453507-1473a2e0-520a-4d7a-a0b6-cb2723f22ec5.png" width="1364.1666124595558" id="u6251fbd7" class="ne-image"></p><p id="u8c6b137c" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1645496663531-f043939a-6d4a-4c33-90cf-99ad93d71f0d.png" width="1364.1666124595558" id="u5fe0c9bc" class="ne-image"></p><h3 id="KDIfG"><span class="ne-text">配置Maven的settings文件</span></h3><p id="ufc3930b7" class="ne-p"><span class="ne-text">关于cong文件夹中的settings.xml文件（</span><code class="ne-code"><span class="ne-text">D:\maven\conf</span></code><span class="ne-text">）：</span></p><ul class="ne-ul"><li id="u5d834c39"><span class="ne-text">maven用来构建项目</span></li><li id="ubac99ee9"><span class="ne-text">java需要外部的jar包，外网的中央仓库，下载本地仓库</span></li></ul><ul class="ne-ul"><li id="ueb522d1d"><span class="ne-text">setting.xml文件里面的盘符注意</span></li></ul><pre><code>&lt;localRepository&gt;D:/lib_repo/repository&lt;/localRepository&gt;</code></pre><ul class="ne-ul"><li id="u6cc8534f"><span class="ne-text">用阿里的源站下载</span></li></ul><pre><code>  &lt;mirrors&gt;     &lt;!-- 这里使用的是阿里的远程maven镜像，目前国内大多数都使用它 --&gt;     &lt;mirror&gt;         &lt;id&gt;alimaven&lt;/id&gt;        &lt;name&gt;aliyun maven&lt;/name&gt;        &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt;        &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;    &lt;/mirror&gt;  &lt;/mirrors&gt;</code></pre><h3 id="mVcaE"><span class="ne-text">添加src/main/java目录</span></h3><p id="u721ad001" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1645498371242-a283bfdb-f00f-4c4a-8cce-548dc8f1245f.png" width="304.16665458016973" id="uUlRT" class="ne-image"></p><h3 id="VD278"><span class="ne-text">pom.xml添加项目依赖jar包</span></h3><p id="uc65a0fda" class="ne-p"><span class="ne-text">打开pom.xml文件，改配置文件，添加依赖项，具体修改为如下：</span></p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;parent&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;        &lt;version&gt;2.6.2&lt;/version&gt;        &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;    &lt;/parent&gt;    &lt;groupId&gt;com.cn.shicun&lt;/groupId&gt;    &lt;artifactId&gt;emis&lt;/artifactId&gt;    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;<pre><code>&amp;lt;name&amp;gt;emis&amp;lt;/name&amp;gt;&amp;lt;properties&amp;gt;    &amp;lt;project.build.sourceEncoding&amp;gt;UTF-8&amp;lt;/project.build.sourceEncoding&amp;gt;    &amp;lt;maven.compiler.source&amp;gt;1.8&amp;lt;/maven.compiler.source&amp;gt;    &amp;lt;maven.compiler.target&amp;gt;1.8&amp;lt;/maven.compiler.target&amp;gt;&amp;lt;/properties&amp;gt;&amp;lt;dependencies&amp;gt;    &amp;lt;dependency&amp;gt;        &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;        &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt;    &amp;lt;/dependency&amp;gt;&amp;lt;/dependencies&amp;gt;&amp;lt;build&amp;gt;&amp;lt;/build&amp;gt;</code></pre><p>&lt;/project&gt;<br></code></pre></p><p id="u1bdef055" class="ne-p"><span class="ne-text">点击右上角蓝色更新按钮</span></p><p id="uaa3e09a1" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1645757724190-8b4ba45a-8ac4-48c9-a306-b63d8936c87d.png" width="1216.666618320679" id="u0495e1bc" class="ne-image"></p><p id="ue8ab886d" class="ne-p"><span class="ne-text">然后idea会自动下载这些jar包（Maven优势之一，就是会自动下载jar包）</span></p><p id="u0671e5f1" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1645498601439-0aa7238f-2ea2-4158-8bb8-61e355c5bb1e.png" width="1599.9999364217147" id="ud93f9cb0" class="ne-image"></p><p id="u03769508" class="ne-p"><span class="ne-text">下载成功如下所示：</span></p><p id="uf55c1abd" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1645498687230-217fcf65-9ed3-4888-bc04-b1b08d423a92.png" width="179.671875" id="ub991bc27" class="ne-image"></p><h2 id="YNfUv"><span class="ne-text">运行springboot应用程序</span></h2><h3 id="QUxg1"><span class="ne-text">测试代码</span></h3><p id="u4992ca59" class="ne-p"><span class="ne-text">如下位置写入如下代码：</span></p><p id="u22d45b72" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1645511526582-4dd0440d-2caf-4137-b544-f487045eb46f.png" width="300.015625" id="u6e9df4ef" class="ne-image"></p><pre><code>package com.cn.shixun;<p>import org.springframework.boot.SpringApplication;<br>import org.springframework.boot.autoconfigure.SpringBootApplication;</p><p>@SpringBootApplication<br>public class App<br>&#123;<br>    public static void main( String[] args )<br>    &#123;<br>        SpringApplication.run(App.class);<br>    &#125;<br>&#125;<br></code></pre></p><h3 id="fzUO5"><span class="ne-text">静态资源</span></h3><p id="ufac7f9e4" class="ne-p"><span class="ne-text">然后在resources新建文件夹static，在其中写入index.html文件，然后运行App代码</span></p><p id="u48dab530" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1645513209905-d82808a5-87e0-4d1d-a44f-7bd84bf14e48.png" width="689.9999725818645" id="u08e7d5a8" class="ne-image"></p><p id="ubbaeef4f" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1645513163237-543a369b-f027-4a23-a54b-16d5396317e7.png" width="740.8333038952627" id="u649359b3" class="ne-image"></p><h3 id="R4FjW"><span class="ne-text">idea实时刷新前端代码设置</span></h3><p id="u75569296" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1645513254386-91ff5733-2ee8-4bba-a306-3e0ae0a82189.png" width="809.9999678134931" id="u857aff52" class="ne-image"></p><p id="u32ec23c5" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1645513246554-dda6481d-a454-497b-a90f-66700b3df752.png" width="811.6666344139323" id="u8bb3fd04" class="ne-image"></p><h2 id="b0Yyp"><span class="ne-text">前后端架构</span></h2><p id="u1dc3bbfa" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1645602574923-49da96c6-764f-4141-af8b-b6d8fe8bc584.png" width="840.8332999216199" id="u65920461" class="ne-image"></p><h2 id="UzUhw"><span class="ne-text">前端</span></h2><h3 id="LL54d"><span class="ne-text">jQuery的Ajax的使用</span></h3><p id="u6e7b9fc3" class="ne-p"><span class="ne-text">jQuery其他相关笔记之前已经学过，不做赘述，此文只做Ajax相关的笔记</span></p><p id="uf756364e" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1629125564200-d6272b27-ffcf-4f6d-b7f8-f1ccc7660b0c.png" width="609.4973754882812" id="pBacN" class="ne-image"></p><pre><code>//    Ajax ===============================================================let ajaxDemo = function()&#123;    $.ajax(&#123;        type : &quot;post&quot;,        url : &quot;https://127.0.0.1:8080/test/demo2&quot;,        data : &#123;            &quot;name&quot; : &quot;李四&quot;,            &quot;age&quot; : 14        &#125;,//        dataType : &quot;json&quot;,        success : function(data) &#123;// 后端的返回值            alert(data);        &#125;    &#125;);&#125;</code></pre><pre><code>&lt;input type=&quot;button&quot; value=&quot;ajax点击按钮&quot; onclick=&quot;ajaxDemo();&quot;&gt;</code></pre><p id="u0b442196" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1645600461044-6f9411a0-aaf9-4f27-bc88-9d590544a9de.png" width="578.3333103524324" id="KCZBi" class="ne-image"></p><h3 id="GmKZL"><span class="ne-text">原生JavaScript的Ajax使用</span></h3><p id="ueee0275d" class="ne-p"><br></p><pre><code>function ajax (options) &#123;    // 默认值    var defaults = &#123;        type: 'get',        url: '',        data: &#123;&#125;,        header: &#123;            'Content-Type': 'application/x-www-form-urlencoded'        &#125;,        success: function () &#123;&#125;,        error: function () &#123;&#125;    &#125;    // 使用用户传递的参数替换默认值参数    Object.assign(defaults, options);    // 创建ajax对象    var xhr = new XMLHttpRequest();    // 参数拼接变量    var params = '';    // 循环参数    for (var attr in defaults.data) &#123;        // 参数拼接        params += attr + '=' + defaults.data[attr] + '&amp;';        // 去掉参数中最后一个&amp;        params = params.substr(0, params.length-1)    &#125;    // 如果请求方式为get    if (defaults.type == 'get') &#123;        // 将参数拼接在url地址的后面        defaults.url += '?' + params;    &#125;<pre><code>// 配置ajax请求xhr.open(defaults.type, defaults.url);// 如果请求方式为postif (defaults.type == &#39;post&#39;) &#123;    // 设置请求头    xhr.setRequestHeader(&#39;Content-Type&#39;, defaults.header[&#39;Content-Type&#39;]);    // 如果想服务器端传递的参数类型为json    if (defaults.header[&#39;Content-Type&#39;] == &#39;application/json&#39;) &#123;        // 将json对象转换为json字符串        xhr.send(JSON.stringify(defaults.data))    &#125;else &#123;        // 发送请求        xhr.send(params);    &#125;&#125; else &#123;    xhr.send();&#125;// 请求加载完成xhr.onload = function () &#123;    // 获取服务器端返回数据的类型    var contentType = xhr.getResponseHeader(&#39;content-type&#39;);    // 获取服务器端返回的响应数据    var responseText = xhr.responseText;    // 如果服务器端返回的数据是json数据类型    if (contentType.includes(&#39;application/json&#39;)) &#123;        // 将json字符串转换为json对象        responseText = JSON.parse(responseText);    &#125;    // 如果请求成功    if (xhr.status == 200) &#123;        // 调用成功回调函数, 并且将服务器端返回的结果传递给成功回调函数        defaults.success(responseText, xhr);    &#125; else &#123;        // 调用失败回调函数并且将xhr对象传递给回调函数        defaults.error(responseText, xhr);    &#125; &#125;// 当网络中断时xhr.onerror = function () &#123;    // 调用失败回调函数并且将xhr对象传递给回调函数    defaults.error(xhr);&#125;</code></pre><p>}<br></code></pre></p><p id="u300e0036" class="ne-p"><br></p><h3 id="N5NMf"><span class="ne-text">AdminLTE框架</span></h3><p id="ueea8d4ed" class="ne-p"><span class="ne-text">文档：</span><a href="https://adminlte.io/" data-href="https://adminlte.io/" target="_blank" class="ne-link"><span class="ne-text">https://adminlte.io/</span></a></p><p id="ue40fc851" class="ne-p"><span class="ne-text">下载adminlte及其依赖放到静态文件夹</span></p><p id="uf0622b47" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1645520275251-6ba0c4e2-026d-4289-8519-2a67d7d0e2af.png" width="254.015625" id="vP941" class="ne-image"></p><p id="u409ab831" class="ne-p"><span class="ne-text">使用jsDelivr外链来构建</span></p><p id="u833a101c" class="ne-p"><a href="https://cdn.jsdelivr.net/npm/admin-lte@3.2/dist/css/adminlte.min.css" data-href="https://cdn.jsdelivr.net/npm/admin-lte@3.2/dist/css/adminlte.min.css" target="_blank" class="ne-link"><span class="ne-text">https://cdn.jsdelivr.net/npm/admin-lte@3.2/dist/css/adminlte.min.css</span></a></p><p id="u588423b2" class="ne-p"><a href="https://cdn.jsdelivr.net/npm/admin-lte@3.2/plugins/fontawesome-free/css/all.min.css" data-href="https://cdn.jsdelivr.net/npm/admin-lte@3.2/plugins/fontawesome-free/css/all.min.css" target="_blank" class="ne-link"><span class="ne-text">https://cdn.jsdelivr.net/npm/admin-lte@3.2/plugins/fontawesome-free/css/all.min.css</span></a></p><h3 id="SiaT0"><span class="ne-text">构建管理类系统的静态页模板</span></h3><p id="u0a4932c1" class="ne-p"><strong><span class="ne-text">利用AdminLTE UI模板搭建出项目所需的目的页面（在static里面写出想要的各种效果）</span></strong></p><p id="u20404070" class="ne-p"><span class="ne-text">管理类系统的页面类型大概有以下几类：</span></p><ol class="ne-ol"><li id="uac303bec"><span class="ne-text">登录页（大多数的管理类系统都没有注册页，需要通过用户管理模块增加用户）。</span></li></ol><p id="u174c34cd" class="ne-p"><a href="http://127.0.0.1:8080/pages/login.html" data-href="http://127.0.0.1:8080/pages/login.html" target="_blank" class="ne-link"><span class="ne-text">http://127.0.0.1:8080/pages/login.html</span></a></p><ol start="2" class="ne-ol"><li id="u69390ba2"><span class="ne-text">欢迎页，登录成功后进入的首页。</span></li></ol><p id="ub9e1b6bd" class="ne-p"><a href="http://127.0.0.1:8080/pages/index.html" data-href="http://127.0.0.1:8080/pages/index.html" target="_blank" class="ne-link"><span class="ne-text">http://127.0.0.1:8080/pages/index.html</span></a></p><ol start="3" class="ne-ol"><li id="ufe14e726"><span class="ne-text">列表页，展示数据集合的表格，一般带分页和查询功能，展示的每行数据的最后会有可以点击的“修改”和“删除”功能。</span></li><li id="u2d115db2"><span class="ne-text">新增/修改页，一个form表单，同一个的功能模块的新增/修改页的表单元素是一致的，只是修改页需要回填数据。</span></li><li id="u0eda6d8e"><span class="ne-text">其他特殊页，例如在线答题页、数据统计页、文件上传页等等，这些在管理类系统中的占比很小。</span></li></ol><h2 id="KEUvQ"><span class="ne-text">后端：Springboot 学习</span></h2><p id="ufa54678d" class="ne-p"><span class="ne-text">记录一下框架的API使用</span></p><h3 id="lbTOb"><span class="ne-text">参考资料</span></h3><ul class="ne-ul"><li id="u92531a69"><a href="https://www.springcloud.cc/spring-boot.html" data-href="https://www.springcloud.cc/spring-boot.html" target="_blank" class="ne-link"><span class="ne-text">Spring Boot参考指南</span></a></li><li id="ucf561286"><a href="http://c.biancheng.net/spring_boot/" data-href="http://c.biancheng.net/spring_boot/" target="_blank" class="ne-link"><span class="ne-text">Spring Boot框架入门教程（快速学习版）</span></a></li></ul><hr id="mk2s4" class="ne-hr"><p id="udb96359f" class="ne-p"><span class="ne-text">vscode运行springboot项目</span></p><ul class="ne-ul"><li id="u276e0432"><a href="https://juejin.cn/post/7036643751896285220" data-href="https://juejin.cn/post/7036643751896285220" target="_blank" class="ne-link"><span class="ne-text">demo5：如何优雅的在vscode里面跑springboot工程</span></a></li></ul><hr id="EJTKd" class="ne-hr"><p id="u5f30a343" class="ne-p"><span class="ne-text">SpringBoot编写接口</span></p><ul class="ne-ul"><li id="u0f65099a"><a href="https://blog.csdn.net/qq_28336351/article/details/79327357" data-href="https://blog.csdn.net/qq_28336351/article/details/79327357" target="_blank" class="ne-link"><span class="ne-text">用Spring Boot开发API接口</span></a></li></ul><hr id="GKXgn" class="ne-hr"><h3 id="k4e1H"><span class="ne-text">@SpringBootApplication</span></h3><p id="u3adda718" class="ne-p"><span class="ne-text">主要方法是通过调用run来委托Spring Boot的SpringApplication类。</span></p><p id="u35e4e33f" class="ne-p"><span class="ne-text">SpringApplication引导我们的应用程序，从Spring开始，然后启动自动配置的Tomcat Web服务器。</span></p><p id="u6a37736e" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1645749879910-2701fc28-b68f-446f-81e8-4dabe66e43e7.png" width="1599.9999364217147" id="u835cf579" class="ne-image"></p><p id="u62c67ac3" class="ne-p"><span class="ne-text">我们需要将Example.class作为参数传递给run方法，以告诉SpringApplication哪个是主要的Spring组件。</span></p><p id="u673dd8a7" class="ne-p"><span class="ne-text">还会传递args数组以公开任何命令行参数。</span></p><p id="u44cb04c0" class="ne-p"><span class="ne-text">springboot的启动类是有作用范围的</span></p><h3 id="Sutl6"><span class="ne-text">@Controller</span></h3><p id="u4a604ad2" class="ne-p"><span class="ne-text">所创建的类是一个web </span><code class="ne-code"><span class="ne-text">@Controller</span></code><span class="ne-text">，所以Spring</span><strong><span class="ne-text">在处理传入的Web请求时会考虑它</span></strong><span class="ne-text">。</span></p><h3 id="I634I"><span class="ne-text">@RequestMapping(&quot;test&quot;)</span></h3><p id="u88beba0f" class="ne-p"><span class="ne-text">@RequestMapping注释提供“路由”信息。它告诉Spring任何带有/test路径的HTTP请求都应该映射到所写的test方法。</span></p><h3 id="ZaabW"><span class="ne-text">@responseBody</span></h3><p id="u9066e349" class="ne-p"><span class="ne-text">@responseBody注解的作用是将controller的方法返回的对象通过适当的转换器转换为指定的格式之后，写入到response对象的body区，通常用来返回JSON数据回格式是text/json（或者是XML）数据，需要注意的呢，在使用此注解之后不会再走试图处理器，而是直接将数据写入到输入流中，他的效果等同于通过response对象输出指定格式的数据。</span></p><h3 id="hGDuj"><span class="ne-text">@RestController</span></h3><p id="ue2601dba" class="ne-p"><span class="ne-text">类上写上注解 @RestController，那么此Controller返回格式就都是text/json</span></p><p id="u8566e37a" class="ne-p"><br></p><h2 id="EMKFp"><span class="ne-text">后端：数据库学习</span></h2><h3 id="wFOt8"><span class="ne-text">表关系</span></h3><p id="uee74ef3a" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1645751601318-ffb24061-6e8d-4c67-a6e2-666bf0acd9d1.png" width="679.9999729792288" id="u5aec88ce" class="ne-image"></p><p id="ue90a0795" class="ne-p"><span class="ne-text"></span></p><p id="uf471721e" class="ne-p"><span class="ne-text">权限控制：</span></p><p id="u1368d99a" class="ne-p"><span class="ne-text">RBAC，role based access control，基于角色的访问控制</span></p><p id="u9e7d7ac2" class="ne-p"><span class="ne-text">用户，角色，功能（项目的粒度到二级菜单即可）</span></p><p id="ue4daa310" class="ne-p"><span class="ne-text"></span></p><p id="u18d3a9c8" class="ne-p"><span class="ne-text">user，user_role，role，role_menu，menu<br /></span><span class="ne-text">用户_角色组，角色则，角色组_角色</span></p><p id="u6491602a" class="ne-p"><br></p><h3 id="oXMNq"><span class="ne-text">数据表的初始化</span></h3><p id="u3d552a0f" class="ne-p"><span class="ne-text">连接本地数据库</span></p><p id="ubb96c3f1" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1645753130016-3d2056bc-ece0-43e8-b97a-f6ccfbc13587.png" width="306.33331298828125" id="uffe98a1a" class="ne-image"></p><p id="u49fdcae2" class="ne-p"><span class="ne-text">按照教程初始化各个数据库</span></p><p id="u16099470" class="ne-p"><span class="ne-text"></span></p><hr id="fjzNz" class="ne-hr"><p id="u647d8e29" class="ne-p"><span class="ne-text">构建实体类---如果手动构建，需要单独给每个表生成Getter Setter，所以使用下面讲的mybits逆向工程构建。</span></p><h2 id="DzvDK"><span class="ne-text">MyBatis逆向工程</span></h2><h3 id="NP9Pp"><span class="ne-text">添加数据库账户及授权</span></h3><p id="u3e6a3632" class="ne-p"><span class="ne-text">参考：</span><a href="https://blog.csdn.net/weixin_33400820/article/details/81976424" data-href="https://blog.csdn.net/weixin_33400820/article/details/81976424" target="_blank" class="ne-link"><span class="ne-text">navicat创建用户以及设置权限</span></a></p><p id="u7d231e21" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1645757383547-2e71e1ab-c656-4362-af9c-03055d1cdd04.png" width="415.015625" id="u067b447b" class="ne-image"></p><p id="u07d66762" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1645757505559-1082ac8d-ea6e-4462-bf75-dee340fbec59.png" width="345.015625" id="u2db9f02f" class="ne-image"></p><p id="u995fe687" class="ne-p"><span class="ne-text">账号密码都是：mybatis</span></p><p id="ufdf8e3c7" class="ne-p"><span class="ne-text">创建成功后如下：</span></p><p id="u45411967" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1645757562274-1c280235-ee05-4629-863f-aca7b76b5a4a.png" width="408.33331298828125" id="u4644ce1e" class="ne-image"></p><h3 id="iv1p7"><span class="ne-text">pom.xml添加依赖</span></h3><pre><code>    &lt;dependency&gt;      &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;      &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;      &lt;version&gt;2.2.1&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;mysql&lt;/groupId&gt;      &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;      &lt;scope&gt;runtime&lt;/scope&gt;      &lt;!--        1、如果你的数据库是mysql8，这段&lt;version&gt;5.1.32&lt;/version&gt;不用管        2、如果你的数据库是mysql5.x，放开&lt;version&gt;5.1.32&lt;/version&gt;这段注释        --&gt;      &lt;version&gt;5.1.32&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt;      &lt;artifactId&gt;mybatis-generator-core&lt;/artifactId&gt;      &lt;version&gt;1.4.0&lt;/version&gt;    &lt;/dependency&gt;</code></pre><h3 id="jLmYH"><span class="ne-text">编写逆向工程的配置文件generatorConfig.xml和Generator.java</span></h3><p id="u28931f65" class="ne-p"><span class="ne-text">运行Generator类的main方法生成实体类、mapper接口和mapper的xml文件</span></p><p id="ua7af06b3" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1645771323003-02719bd5-ad39-43c6-91f8-c9c3d58f68b5.png" width="209.6666259765625" id="u6276f1f8" class="ne-image"></p><p id="u98f8cbda" class="ne-p"><strong><span class="ne-text">每次生成逆向工程之前，要把之前生成的文件全部删除</span></strong><span class="ne-text">。</span></p><p id="ud61f556f" class="ne-p"><br></p><pre><code>&lt;dependency&gt;  &lt;groupId&gt;com.alibaba&lt;/groupId&gt;  &lt;artifactId&gt;fastjson&lt;/artifactId&gt;  &lt;version&gt;1.2.73&lt;/version&gt;&lt;/dependency&gt;</code></pre><p id="uce896a9a" class="ne-p"><br></p><h2 id="DgwiD"><span class="ne-text">报错</span></h2><h3 id="u7wxz"><span class="ne-text">SpringBoot启动报错Failed to configure a DataSource: ‘url’ attribute is not specified and no embedded datasource could be configured</span></h3><pre><code>Error starting ApplicationContext. To display the conditions report re-run your application with 'debug' enabled.2022-02-27 20:30:12.439 ERROR 12672 --- [           main] o.s.b.d.LoggingFailureAnalysisReporter   : <hr><p>APPLICATION FAILED TO START</p><hr><p>Description:</p><p>Failed to configure a DataSource: ‘url’ attribute is not specified and no embedded datasource could be configured.</p><p>Reason: Failed to determine a suitable driver class</p><p>Action:</p><p>Consider the following:<br>    If you want an embedded database (H2, HSQL or Derby), please put it on the classpath.<br>    If you have database settings to be loaded from a particular profile you may need to activate it (no profiles are currently active).</p><p>Process finished with exit code 1<br></code></pre></p><p id="u877d8a83" class="ne-p"><span class="ne-text">启动类添加如下：</span></p><pre><code>@SpringBootApplication(exclude = &#123;DataSourceAutoConfiguration.class&#125;)</code></pre><p id="uc454574c" class="ne-p"><span class="ne-text">参考：</span><a href="https://www.panziye.com/java/1873.html" data-href="https://www.panziye.com/java/1873.html" target="_blank" class="ne-link"><span class="ne-text">https://www.panziye.com/java/1873.html</span></a></p><h3 id="CCgIJ"><span class="ne-text">Consider defining a bean of type 'com.cn.shixun.mapper.UserMapper' in your configuration.</span></h3><p id="u161eed12" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1645965307851-1a6aeb4e-786d-453c-8f19-cf25c41156eb.png" width="788.3333020077824" id="u345021ed" class="ne-image"></p><p id="uc1c4402f" class="ne-p"><span class="ne-text">参考：</span><a href="https://blog.csdn.net/zzldm/article/details/116534419" data-href="https://blog.csdn.net/zzldm/article/details/116534419" target="_blank" class="ne-link"><span class="ne-text">https://blog.csdn.net/zzldm/article/details/116534419</span></a></p><p id="ue6c6492c" class="ne-p"><span class="ne-text"></span></p><h3 id="y7JI1"><span class="ne-text">nio-8080-exec-1</span></h3><p id="u6fbfe2d8" class="ne-p"><span class="ne-text">属于正常情况</span></p><pre><code>  .   ____          _            __ _ _ /\\ / ___'_ __ _ _(_)_ __  __ _ \ \ \ \( ( )\___ | '_ | '_| | '_ \/ _` | \ \ \ \ \\/  ___)| |_)| | | | | || (_| |  ) ) ) )  '  |____| .__|_| |_|_| |_\__, | / / / / =========|_|==============|___/=/_/_/_/ :: Spring Boot ::                (v2.6.2)<p>2022-02-27 20:46:14.796  INFO 9608 — [           main] com.App                                  : Starting App using Java 1.8.0_151 on DESKTOP-QTVR7IE with PID 9608 (D:\projects\emis\target\classes started by wztli in D:\projects\emis)<br>2022-02-27 20:46:14.799  INFO 9608 — [           main] com.App                                  : No active profile set, falling back to default profiles: default<br>2022-02-27 20:46:16.451  INFO 9608 — [           main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat initialized with port(s): 8080 (http)<br>2022-02-27 20:46:16.464  INFO 9608 — [           main] o.apache.catalina.core.StandardService   : Starting service [Tomcat]<br>2022-02-27 20:46:16.464  INFO 9608 — [           main] org.apache.catalina.core.StandardEngine  : Starting Servlet engine: [Apache Tomcat/9.0.56]<br>2022-02-27 20:46:16.582  INFO 9608 — [           main] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring embedded WebApplicationContext<br>2022-02-27 20:46:16.582  INFO 9608 — [           main] w.s.c.ServletWebServerApplicationContext : Root WebApplicationContext: initialization completed in 1721 ms<br>2022-02-27 20:46:16.996  INFO 9608 — [           main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat started on port(s): 8080 (http) with context path ‘’<br>2022-02-27 20:46:17.010  INFO 9608 — [           main] com.App                                  : Started App in 2.708 seconds (JVM running for 3.193)<br>2022-02-27 20:46:17.075  INFO 9608 — [nio-8080-exec-1] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring DispatcherServlet ‘dispatcherServlet’<br>2022-02-27 20:46:17.075  INFO 9608 — [nio-8080-exec-1] o.s.web.servlet.DispatcherServlet        : Initializing Servlet ‘dispatcherServlet’<br>2022-02-27 20:46:17.076  INFO 9608 — [nio-8080-exec-1] o.s.web.servlet.DispatcherServlet        : Completed initialization in 1 ms</p><p></code></pre></p></div>]]></content>
      
      
      <categories>
          
          <category> 环境工具 </category>
          
          <category> 环境搭建 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>WebSocket学习笔记</title>
      <link href="/blog/pp1d2p/"/>
      <url>/blog/pp1d2p/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h3 id="D4CnP"><span class="ne-text">一些链接</span></h3><ul class="ne-ul"><li id="u99cd15f2"><span class="ne-text">WebSocket在线调试：</span><a href="http://www.easyswoole.com/wstool.html" data-href="http://www.easyswoole.com/wstool.html" target="_blank" class="ne-link"><span class="ne-text">http://www.easyswoole.com/wstool.html</span></a></li><li id="u24e7cbb7"><span class="ne-text">express笔记：</span><a href="https://www.yuque.com/wztlink1013/projects/tdgoby" data-href="https://www.yuque.com/wztlink1013/projects/tdgoby" class="ne-link"><span class="ne-text">https://www.yuque.com/wztlink1013/projects/tdgoby</span></a></li><li id="uef57eea0"><span class="ne-text">相关文档：</span><a href="http://expressjs.jser.us/" data-href="http://expressjs.jser.us/" target="_blank" class="ne-link"><span class="ne-text">http://expressjs.jser.us/</span></a></li></ul><h3 id="Iw2Vp"><span class="ne-text">mongodb和sharedb-mongo</span></h3><ul class="ne-ul"><li id="u97fcf52f"><a href="https://rain120.github.io/sharedb-zh/sharedb/sharedb" data-href="https://rain120.github.io/sharedb-zh/sharedb/sharedb" target="_blank" class="ne-link"><span class="ne-text">ShareDB中文文档</span></a></li><li id="ud175fc61"><a href="https://rain120.github.io/sharedb-zh/sharedb-mongo/sharedb-mongo" data-href="https://rain120.github.io/sharedb-zh/sharedb-mongo/sharedb-mongo" target="_blank" class="ne-link"><span class="ne-text">sharedb-mongo文档</span></a></li></ul><h3 id="nD9eJ"><span class="ne-text">WebSocket长连接概念</span></h3><p id="ud2e71363" class="ne-p"><span class="ne-text">什么是WebSocket？</span></p><p id="ub718ef9c" class="ne-p"><span class="ne-text">参考：</span></p><ul class="ne-ul"><li id="u44927020"><a href="https://www.liaoxuefeng.com/wiki/1022910821149312/1103303693824096" data-href="https://www.liaoxuefeng.com/wiki/1022910821149312/1103303693824096" target="_blank" class="ne-link"><span class="ne-text">WebSocket 廖雪峰的官方网站</span></a></li><li id="u14123397"><a href="https://www.ruanyifeng.com/blog/2017/05/websocket.html" data-href="https://www.ruanyifeng.com/blog/2017/05/websocket.html" target="_blank" class="ne-link"><span class="ne-text">WebSocket 教程 作者： 阮一峰</span></a></li></ul><p id="u4d2f3080" class="ne-p"><span class="ne-text"></span></p><p id="u753b6170" class="ne-p"><span class="ne-text">为什么需要WebSocket呢？</span></p><p id="u5e0df92f" class="ne-p"><span class="ne-text">因为网络请求，有请求响应，浏览器的请求，还需要有服务端的响应，需要时刻进行数据通信，明显上述不行，因为上述强调一个“主动”，也就是客户端如果不发送请求，服务端就不会进行响应，对协同而言明显不行，比如说，a用户修改了一个部分，这个时候就需要服务端主动将修改后的内容推送到其他客户，这样才能实现实时协同。再比如多人聊天室。</span></p><p id="u052e2fa6" class="ne-p"><span class="ne-text">所以需要一个在浏览器和服务器之间建立一个不受限的双向通信的通道，比如说，服务器可以在任意时刻发送消息给浏览器。</span></p><p id="udcb34ff6" class="ne-p"><span class="ne-text"></span></p><p id="u0aab99b2" class="ne-p"><span class="ne-text">使用的时候还需要注意，只有浏览器支持WebSocket协议，才能够使用该协议，兼容的浏览器种类及版本如下：</span></p><pre><code>ChromeFirefoxIE &gt;= 10Sarafi &gt;= 6Android &gt;= 4.4iOS &gt;= 8</code></pre><p id="u4ddd2859" class="ne-p"><span class="ne-text"></span></p><p id="u6a07008b" class="ne-p"><span class="ne-text">Node.js中，使用最广泛的WebSocket模块是ws，以下学习笔记：</span></p><h3 id="ug2x1"><span class="ne-text">Node.js的WebSocket模块ws的使用</span></h3><p id="u7e3c0ddd" class="ne-p"><span class="ne-text">地址：</span><a href="https://github.com/websockets/ws" data-href="https://github.com/websockets/ws" target="_blank" class="ne-link"><span class="ne-text">https://github.com/websockets/ws</span></a></p><p id="ube1e9f07" class="ne-p"><span class="ne-text">下载</span></p><pre><code>cnpm i ws --save</code></pre><ul class="ne-ul"><li id="uab17cfd1"><span class="ne-text">connection：</span><a href="https://github.com/websockets/ws/blob/master/doc/ws.md#event-connection" data-href="https://github.com/websockets/ws/blob/master/doc/ws.md#event-connection" target="_blank" class="ne-link"><span class="ne-text">https://github.com/websockets/ws/blob/master/doc/ws.md#event-connection</span></a></li><li id="uc72b7f0d"><span class="ne-text">addEventListener：</span><a href="https://github.com/websockets/ws/blob/master/doc/ws.md#websocketaddeventlistenertype-listener-options" data-href="https://github.com/websockets/ws/blob/master/doc/ws.md#websocketaddeventlistenertype-listener-options" target="_blank" class="ne-link"><span class="ne-text">https://github.com/websockets/ws/blob/master/doc/ws.md#websocketaddeventlistenertype-listener-options</span></a></li></ul><h3 id="g8Imx"><span class="ne-text">@teamwork/websocket-json-stream</span></h3><p id="u0e87606a" class="ne-p"><a href="https://www.npmjs.com/package/@teamwork/websocket-json-stream" data-href="https://www.npmjs.com/package/@teamwork/websocket-json-stream" target="_blank" class="ne-link"><span class="ne-text">https://www.npmjs.com/package/@teamwork/websocket-json-stream</span></a></p><p id="u62af2ec5" class="ne-p"><span class="ne-text"></span></p><p id="u4d204ccf" class="ne-p"><span class="ne-text">用于 WebSocket 连接的 nodejs 流包装器。它也适用于浏览器 WebSockets。</span></p></div>]]></content>
      
      
      <categories>
          
          <category> 计算机素养 </category>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Nodejs基本使用和内置模块</title>
      <link href="/blog/gxh14f/"/>
      <url>/blog/gxh14f/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h2 id="jPu5t"><span class="ne-text">Node.js使用</span></h2><p id="ude9bec7a" class="ne-p"><span class="ne-text">Node.js环境说白了就和浏览器一样，用来运行js，node借助终端，浏览器借助app展示HTML文件来展示js功能。具体运行在js文件的所在文件目录下运行 </span><code class="ne-code"><span class="ne-text">node xx.js</span></code><span class="ne-text">即可。</span></p><p id="u651d3898" class="ne-p"><span class="ne-text">不过一般全局下载nodemon三方模块，其作用是当js文件被改动，终端会再次执行该js文件，后续模块处再讲。</span></p><p id="udfde50a5" class="ne-p"><span class="ne-text"></span></p><p id="u2579aadd" class="ne-p"><span class="ne-text">模块化开发分为两种：</span></p><ol class="ne-ol"><li id="u612c8573"><span class="ne-text">前端网页使用JavaScript外链</span></li><li id="ue5f5485d"><span class="ne-text">使用nodejs加载模块化开发构建</span></li></ol><p id="ud282aa20" class="ne-p"><span class="ne-text"></span></p><p id="uafd4d725" class="ne-p"><span class="ne-text">Node.js实际上是模块化开发，由以下两方面组成：</span></p><ol class="ne-ol"><li id="u17a2121f"><span class="ne-text">ECMAScript</span></li><li id="u186314d7"><span class="ne-text">Node的模块API（又分为内置模块和三方模块）</span></li></ol><h3 id="lfQzP"><span class="ne-text">node环境的一些特性</span></h3><p id="u38e53630" class="ne-p"><span class="ne-text">异步式I/O：提高效率，防止阻塞这种情况</span></p><p id="ubb6b1657" class="ne-p"><span class="ne-text">事件式编程：注意事件循环机制</span></p><h3 id="DktHv"><span class="ne-text">node模块化及其使用</span></h3><p id="ued3f4eb0" class="ne-p"><span class="ne-text">参考之前写的文章：</span><a href="https://www.yuque.com/wztlink1013/blog/psazge#FPo3f" data-href="https://www.yuque.com/wztlink1013/blog/psazge#FPo3f" target="_blank" class="ne-link"><span class="ne-text">https://www.yuque.com/wztlink1013/blog/psazge#FPo3f</span></a></p><h3 id="NtVpl" style="text-align: left"><span class="ne-text">process.env环境变量</span></h3><p id="u173ea7e9" class="ne-p"><span class="ne-text">nodejs的顶层对象process下的环境变量设置与使用</span></p><ul class="ne-ul"><li id="u080a734f"><span class="ne-text">参考：</span><a href="https://juejin.cn/post/6972466143445385223" data-href="https://juejin.cn/post/6972466143445385223" target="_blank" class="ne-link"><span class="ne-text">https://juejin.cn/post/6972466143445385223</span></a></li></ul><h3 id="sEPZO"><span class="ne-text">nodejs中的try...catch</span></h3><p id="u91e15a9b" class="ne-p"><span class="ne-text">写异常的捕获的时候，要时刻注意一些异步执行的代码，比如一种场景是try里面的代码是异步操作，那么再执行异步的时候，就已经执行了catch里面的报警语句了，学会查看捕获的目标代码是哪段。</span></p><p id="u74b6719d" class="ne-p"><span class="ne-text"></span></p><p id="u6f855426" class="ne-p"><span class="ne-text">具体参考：</span><a href="https://www.cnblogs.com/surfer/p/10291609.html" data-href="https://www.cnblogs.com/surfer/p/10291609.html" target="_blank" class="ne-link"><span class="ne-text">https://www.cnblogs.com/surfer/p/10291609.html</span></a></p><h2 id="gFFTO"><span class="ne-text">Node.js内置模块</span></h2><h3 id="XltiP"><span class="ne-text">全局对象global</span></h3><p id="07f0cf1cc1320a19ca5fd8c6bf9d1e1f" class="ne-p"><span class="ne-text">Node.js和之前学过的浏览器对象区分之就是，浏览器中全局对象是window，但是Node.js的全局对象是global（也可以不写、省略）。</span></p><p id="u7bcf8117" class="ne-p"><br></p><ul class="ne-ul"><li id="ufaa9c230"><span class="ne-text">process对象：关于进程的一个对象，也是global的属性之一，是一个和操作系统的简单接口。重点了解nextTick()函数，这个函数可以将事件循环设置一个任务，提高运行效率</span></li></ul><p id="5d524ac20f9f30a8882e3bfa05b35241" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1622768098753-4f933f75-ea23-41d9-80d3-c8dd46f2e123.png" width="457" id="jU6pu" class="ne-image"></p><ul class="ne-ul"><li id="u2a3558c1"><span class="ne-text">console对象：log在控制台中输出；error输出错误信息；trace输出错误信息调用栈（就是错在什么地方）</span></li></ul><ul class="ne-ul"><li id="6ec87b332d7805f01cc811abc4c3f120"><span class="ne-text">setTimeout()     设置超时</span><strong><span class="ne-text">定时器</span></strong></li><li id="26e9a03d59b9dc4f0cc709c7e08d1a91"><span class="ne-text">clearTimeout()  清除超时时定时器</span></li><li id="018d9cf8b1048488fc71c0182cb29f2c"><span class="ne-text">setInterval()      设置间歇</span><strong><span class="ne-text">定时器</span></strong></li><li id="e854f2fbf93acc3fea5490515cac7481"><span class="ne-text">clearInterval()   清除间歇定时器</span></li></ul><h3 id="Yi0DH"><span class="ne-text">http;fs;url;querystring;path模块</span></h3><p id="u7aeed8b6" class="ne-p"><span class="ne-text">参考：</span><a href="https://blog.guowenfh.com/2016/10/15/node-http" data-href="https://blog.guowenfh.com/2016/10/15/node-http" target="_blank" class="ne-link"><span class="ne-text">https://blog.guowenfh.com/2016/10/15/node-http</span></a></p><p id="u647c3ea8" class="ne-p"><span class="ne-text"></span></p><ul class="ne-ul"><li id="u2567b226"><span class="ne-text">http，原生创建web服务</span></li></ul><ul class="ne-ul"><li id="u6a740703"><span class="ne-text">url解析url，querystring处理url参数，搭配使用</span></li><li id="u6b4062f3"><span class="ne-text">fs模块用来读取文件、写入文件等</span></li><li id="u59e7e2df"><span class="ne-text">path路径操作，一般都是路径字符串拼接join，</span><code class="ne-code"><span class="ne-text">__dirname</span></code><span class="ne-text">当前目录名</span></li></ul><pre><code>/* * @Author: wztlink1013 * @Date: 2022-01-10 16:26:41 * @LastEditTime: 2022-01-10 19:49:43 * @Description: */let http = require('http')let url = require('url')let fs = require('fs')let queryString = require('querystring')<p>let server = http.createServer()<br>// 读取我们当前文件所在的目录下的 html 文件夹<br>let HtmlDir = __dirname + ‘/html/‘</p><p>server.on(‘request’, function (req, res) &#123;<br>  let urlObj = url.parse(req.url)<br>  console.log(‘【请求url信息】’, urlObj)<br>  let params = queryString.parse(urlObj.query)<br>  console.log(‘【url参数】’, JSON.stringify(params))</p><p>  switch (urlObj.pathname) &#123;<br>    case ‘/‘:<br>      //首页<br>      sendData(HtmlDir + ‘index.html’, req, res)<br>      break<br>    case ‘/user’:<br>      //用户首页<br>      sendData(HtmlDir + ‘user.html’, req, res)<br>      break<br>    default:<br>      //处理其他情况<br>      sendData(HtmlDir + ‘err.html’, req, res)<br>      break<br>  &#125;<br>&#125;)</p><p>/**</p><ul><li>读取html文件，响应数据，发送给浏览器</li><li>@param &#123;String&#125; file 文件路径</li><li>@param &#123;Object&#125; req request</li><li>@param &#123;Object&#125; res response 对象</li><li>/<br>function sendData(file, req, res) &#123;<br>fs.readFile(file, function (err, data) &#123;<br>  if (err) &#123;<pre><code>res.writeHead(404, &#123;  &#39;content-type&#39;: &#39;text/html;charset=utf-8&#39;,&#125;)res.end(&#39;&amp;lt;h1&amp;gt;你要找的页面不见了～&amp;lt;/h1&amp;gt;&#39;)</code></pre>  } else {<pre><code>res.writeHead(200, &#123;  &#39;content-type&#39;: &#39;text/html;charset=utf-8&#39;,&#125;)res.end(data)</code></pre>  }<br>})<br>}<br>server.listen(8888)<br>console.log(‘Server is running at <a href="http://127.0.0.1:8888/&#39;">http://127.0.0.1:8888/&#39;</a>)<br></code></pre><h3 id="oG39o"><span class="ne-text">util+chalk美化</span></h3><ul class="ne-tl"><li checked="true" id="7896925bf1161e320ccb9b5a02f94749"><span class="ne-text">util.inherits</span></li></ul><p id="52f3596b6ec4580aab2aa8e6b0170d3f" class="ne-p"><span class="ne-text">不过感觉这个已经没有多大必要了，这个是实现原型间继承的相关封装，但是现在ES6已经有了class的概念了（虽然底层还是之前那套），这个工具用的不多</span></p><ul class="ne-tl"><li checked="true" id="4614b24cd9ec95c3548092d2af20ed75"><span class="ne-text">util.inspect</span></li></ul><p id="3f8573b6edf04047f6d8ac2a9afe0d76" class="ne-p"><span class="ne-text">目的就是将对象转换为字符串，比如将错误信息更加美观的展示在控制台，就可以自定义，但是可以直接用chalk模块在实现这个美化控制台输出的工作。</span></p><pre><code>'use strict';</li></ul><p>const chalk = require(‘chalk’);</p><p>module.exports = &#123;<br>  info(…args) &#123;<br>    const prefix = chalk.green(‘[INFO]’);<br>    args.unshift(prefix);<br>    console.log.apply(console, args);<br>  &#125;,<br>  warn(…args) &#123;<br>    const prefix = chalk.yellow(‘[WARNING]’);<br>    args.unshift(prefix);<br>    console.log.apply(console, args);<br>  &#125;,<br>  error(…args) &#123;<br>    const prefix = chalk.red(‘[ERROR]’);<br>    args.unshift(prefix);<br>    console.log.apply(console, args);<br>  &#125;,<br>&#125;;<br></code></pre></p><pre><code>out.info(`Current yuque-hexo-lyrics version is $&#123;chalk.yellow(pkg.version)&#125;, and the latest version is $&#123;chalk.green(update.latest)&#125;. Please update!`);out.info('View more detail: https://github.com/wztlink1013/yuque-hexo-lyrics#changelog');</code></pre><h2 id="Hbxw1"><span class="ne-text">Node.js异步的解决策略</span></h2><p id="u5df15c0c" class="ne-p"><span class="ne-text">参考：</span></p><ul class="ne-ul"><li id="u1856099b"><a href="https://segmentfault.com/a/1190000019418510" data-href="https://segmentfault.com/a/1190000019418510" target="_blank" class="ne-link"><span class="ne-text">Node.js异步处理的各种写法</span></a></li></ul><ul class="ne-ul"><li id="u1b38d376"><span class="ne-text">传统的解决方案：async await等</span></li><li id="u4bc51a10"><span class="ne-text">嵌套使用</span></li></ul></div>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
          <category> Node.js </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Git Commit 的优化</title>
      <link href="/blog/dvkqhm/"/>
      <url>/blog/dvkqhm/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="u03591007" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1640570522971-b4d4a696-55c0-496b-a81d-deeb3e83a111.png" width="900" id="u4339158d" class="ne-image"></p><p id="u2d28a016" class="ne-p"><span class="ne-text"></span></p><p id="ubbfe2e60" class="ne-p"><span class="ne-text">前言：在使用git提交代码过程中，git commit的规范常不被大多数人注意，然而版本管理工具中，代码的提交规范对项目的后续维护有着很重要的作用。故本文从以下几个方面展开述说工程开发中git commit优化的几个工具：</span></p><ul class="ne-ul"><li id="ucc09ec77"><span class="ne-text">commitizen：简单的 commit 规范</span></li><li id="ufbab311b"><span class="ne-text">cz-conventional-changelog：执行会将项目npm发布新版本，并自动生成CHANGELOG.md文件</span></li><li id="u82705670"><span class="ne-text">commitlint：格式校验工具</span></li><li id="u419914ec"><span class="ne-text">husky：Git的钩子，在此作用为代码的提交规范和规范的校验</span></li><li id="u1fd40f0a"><span class="ne-text">standard-version：辅助 cz-conventional-changelog 打 version 等功能</span></li></ul><h3 id="Ttl7l"><span class="ne-text">commitizen和cz-conventional-changelog</span></h3><p id="u6c3b2139" class="ne-p"><span class="ne-text">下载cz-conventional-changelog commitizen</span></p><pre><code>cnpm i -D commitizen cz-conventional-changelog</code></pre><p id="u65da1f08" class="ne-p"><span class="ne-text">package.json添加配置信息</span></p><pre><code>&quot;scripts&quot;: &#123;  ...,    &quot;commit&quot;: &quot;git status &amp;&amp; git add . &amp;&amp; git-cz&quot;,  &#125;,,  &quot;config&quot;: &#123;    &quot;commitizen&quot;: &#123;      &quot;path&quot;: &quot;node_modules/cz-conventional-changelog&quot;    &#125;  &#125;</code></pre><p id="u37926c96" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1640510064091-ff75df38-e750-452f-8a16-6e6930f8505b.png" width="470.5" id="ua1b3c4e2" class="ne-image"></p><p id="u6b5ae494" class="ne-p"><span class="ne-text">成功提交之后</span></p><p id="u44e5300c" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1640510234956-c68282df-e059-4a8b-b118-0932250a7420.png" width="587" id="ue703c449" class="ne-image"></p><p id="uf283b9bd" class="ne-p"><br></p><h3 id="Ag1Il"><span class="ne-text">Commitlint及husky</span></h3><pre><code>cnpm i -D husky @commitlint/config-conventional @commitlint/cli</code></pre><p id="u14464e93" class="ne-p"><span class="ne-text">项目根目录新建commitlint.config.js</span></p><pre><code>module.exports = &#123;  extends: ['@commitlint/config-conventional']&#125;</code></pre><p id="u0d788f8b" class="ne-p"><span class="ne-text">package.json添加如下</span></p><pre><code># package.json<p>…,<br>&quot;husky&quot;: &#123;<br>    &quot;hooks&quot;: &#123;<br>      &quot;commit-msg&quot;: &quot;commitlint -E $HUSKY_GIT_PARAMS&quot;    &#125;<br>&#125;</p><p></code></pre></p><p id="u2563d439" class="ne-p"><span class="ne-text">执行命令 npm run commit</span></p><pre><code>1.Select the type of change that you're committing 选择改动类型 (&lt;type&gt;)<p>2.What is the scope of this change (e.g. component or file name)? 填写改动范围 (&lt;scope&gt;)</p><p>3.Write a short, imperative tense description of the change: 写一个精简的描述 (&lt;subject&gt;)</p><p>4.Provide a longer description of the change: (press enter to skip) 对于改动写一段长描述 (&lt;body&gt;)</p><p>5.Are there any breaking changes? (y/n) 是破坏性修改吗？默认n (&lt;footer&gt;)</p><p>6.Does this change affect any openreve issues? (y/n) 改动修复了哪个问题？默认n (&lt;footer&gt;)<br></code></pre></p><p id="u24586855" class="ne-p"><span class="ne-text">生成如下格式</span></p><pre><code>&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;&lt;BLANK LINE&gt;&lt;body&gt;&lt;BLANK LINE&gt;&lt;footer&gt;</code></pre><p id="uad666844" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1640515038577-11c2fbe0-0e7e-4ec4-8836-2c49553151c0.png" width="241.5" id="ub44884a1" class="ne-image"></p><p id="u915a5ef0" class="ne-p"><span class="ne-text">其中各自含义为</span></p><ul class="ne-ul"><li id="u6aada6e4"><span class="ne-text">scope 指 commit 的范围（哪些模块进行了修改）</span></li><li id="u54a150bc"><span class="ne-text">subject 指 commit 的简短描述</span></li><li id="u290da520"><span class="ne-text">body 指 commit 主体内容（长描述）</span></li><li id="u6a10d0a9"><span class="ne-text">footer 指 commit footer 信息</span></li><li id="ue4e2d962"><span class="ne-text">type 指当前 commit 类型，一般有下面几种可选类型：</span></li></ul><p id="u7e7f121a" class="ne-p"><br></p><pre><code># 主要typefeat:     增加新功能fix:      修复bug<h1 id="特殊type"><a href="#特殊type" class="headerlink" title="特殊type"></a>特殊type</h1><p>docs:     只改动了文档相关的内容<br>style:    不影响代码含义的改动，例如去掉空格、改变缩进、增删分号<br>build:    构造工具的或者外部依赖的改动，例如webpack，npm<br>refactor: 代码重构时使用<br>revert:   执行git revert打印的message</p><h1 id="暂不使用type"><a href="#暂不使用type" class="headerlink" title="暂不使用type"></a>暂不使用type</h1><p>test:     添加测试或者修改现有测试<br>perf:     提高性能的改动<br>ci:       与CI（持续集成服务）有关的改动<br>chore:    不修改src或者test的其余修改，例如构建过程或辅助工具的变动<br></code></pre></p><h3 id="yQnaq"><span class="ne-text">standard-version: 自动生成 CHANGELOG</span></h3><p id="u109f02e4" class="ne-p"><span class="ne-text">下载插件</span></p><pre><code>cnpm i --save-dev standard-version</code></pre><p id="u9bbba48e" class="ne-p"><span class="ne-text">package.json添加如下</span></p><pre><code>&#123;  &quot;scripts&quot;: &#123;    &quot;release&quot;: &quot;standard-version&quot;  &#125;&#125;</code></pre><p id="u453f6cbd" class="ne-p"><span class="ne-text">执行npm run release，在根目录会生成CHANGELOG.md文件</span></p><p id="u9255ba0b" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1640515612285-57b296de-7def-4ef9-b022-286ac9ef1ac2.png" width="554.5" id="u715cd9c7" class="ne-image"></p><h3 id="zi86S"><span class="ne-text">总package.json</span></h3><pre><code>&#123;  &quot;name&quot;: &quot;web-learn-notes&quot;,  &quot;version&quot;: &quot;1.1.0&quot;,  &quot;description&quot;: &quot;web学习笔记仓库&quot;,  &quot;main&quot;: &quot;index.js&quot;,  &quot;scripts&quot;: &#123;    &quot;commit&quot;: &quot;git status &amp;&amp; git add . &amp;&amp; git-cz&quot;,    &quot;release&quot;: &quot;standard-version&quot;,    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;  &#125;,  &quot;repository&quot;: &#123;    &quot;type&quot;: &quot;git&quot;,    &quot;url&quot;: &quot;git+https://github.com/wztlink1013/web-learn-notes.git&quot;  &#125;,  &quot;keywords&quot;: [    &quot;web&quot;,    &quot;学习&quot;,    &quot;笔记&quot;  ],  &quot;author&quot;: &quot;wztlink1013&quot;,  &quot;license&quot;: &quot;ISC&quot;,  &quot;bugs&quot;: &#123;    &quot;url&quot;: &quot;https://github.com/wztlink1013/web-learn-notes/issues&quot;  &#125;,  &quot;homepage&quot;: &quot;https://github.com/wztlink1013/web-learn-notes#readme&quot;,  &quot;devDependencies&quot;: &#123;    &quot;@commitlint/cli&quot;: &quot;^16.0.0&quot;,    &quot;@commitlint/config-conventional&quot;: &quot;^16.0.0&quot;,    &quot;commitizen&quot;: &quot;^4.2.4&quot;,    &quot;cz-conventional-changelog&quot;: &quot;^3.3.0&quot;,    &quot;husky&quot;: &quot;^7.0.4&quot;,    &quot;standard-version&quot;: &quot;^9.3.2&quot;  &#125;,  &quot;config&quot;: &#123;    &quot;commitizen&quot;: &#123;      &quot;path&quot;: &quot;node_modules/cz-conventional-changelog&quot;    &#125;  &#125;,  &quot;husky&quot;: &#123;    &quot;hooks&quot;: &#123;      &quot;commit-msg&quot;: &quot;commitlint -E $HUSKY_GIT_PARAMS&quot;    &#125;  &#125;&#125;</code></pre><p id="u6b0e1ffe" class="ne-p"><span class="ne-text"></span></p><ul class="ne-ul"><li id="u74ff70f8"><span class="ne-text">commitizen：自动化提示工具【git-cz】</span></li><li id="u0a52a6ab"><span class="ne-text">commitlint</span></li><li id="u91f3fde8"><span class="ne-text">commitlint-config-cz</span></li><li id="u4d8f7655"><span class="ne-text">commitlint-config-git-commit-emoji </span></li><li id="u50603afd"><span class="ne-text">conventional-changelog</span></li><li id="u1eace2ab"><span class="ne-text">conventional-changelog-cli</span></li><li id="ue7a39465"><span class="ne-text">cz-conventional-changelog</span></li><li id="uf78109fb"><span class="ne-text">cz-customizable</span></li><li id="u5c453180"><span class="ne-text">husky</span></li><li id="ucadc0dab"><span class="ne-text">lint-staged</span></li></ul></div>]]></content>
      
      
      <categories>
          
          <category> 计算机素养 </category>
          
          <category> Git+GitHub </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Vue-CLI搭建Vue3.x+TypeScript项目</title>
      <link href="/blog/blhxct/"/>
      <url>/blog/blhxct/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="u30ed37f0" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1640572147933-73df2b83-c74d-4391-a90c-c8006aba471e.png" width="900" id="u1d7f2957" class="ne-image"></p><p id="u19218eee" class="ne-p"><span class="ne-text"></span></p><p id="u661f3c9b" class="ne-p"><span class="ne-text">前言：前端工程化开发总结，使用Vue-CLI脚手架搭建Vue3.x + Typescript项目，整体项目的环境配置。</span></p><p id="uebe97bf6" class="ne-p"><br></p><h2 id="RxoB1"><span class="ne-text">下载安装Vue-CLI</span></h2><ul class="ne-ul"><li id="ucd9aee0e"><span class="ne-text">官方文档：</span><a href="https://cli.vuejs.org/zh/guide/" data-href="https://cli.vuejs.org/zh/guide/" target="_blank" class="ne-link"><span class="ne-text">Vue CLI 🛠️ Vue.js 开发的标准工具</span></a></li></ul><pre><code>npm install -g @vue/cli# oryarn global add @vue/cli# orcnpm install -g @vue/cli</code></pre><p id="uab298ae3" class="ne-p"><span class="ne-text">查看版本：</span><code class="ne-code"><span class="ne-text">vue --version</span></code></p><p id="ufc4cf0bc" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1640413980237-9582e32f-7515-40b8-80a7-f678456ac739.png" width="188.5" id="ua167aa8d" class="ne-image"></p><h2 id="CV67S"><span class="ne-text">创建项目</span></h2><p id="u343d2c0c" class="ne-p"><span class="ne-text">新建并初始化项目文件夹</span></p><pre><code>vue create vue3-cli-demo</code></pre><p id="uc0b5b0b6" class="ne-p"><span class="ne-text">选择最后一项自定义相关配置</span></p><p id="uf40af224" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1640414187756-6ebbf844-853d-4a66-b0d6-f401003c1fe8.png" width="234.5" id="ub11023b3" class="ne-image"></p><p id="u9158133b" class="ne-p"><span class="ne-text">全配置搭建测试</span></p><p id="ub5de8728" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1640414751376-5215b4c4-3e85-4be2-9ce8-6e304bd5b70f.png" width="403.5" id="ud9b0ef21" class="ne-image"></p><h2 id="ftrVD"><span class="ne-text">vue.config.js</span></h2><p id="u7f1cc1f4" class="ne-p"><span class="ne-text">Vue项目的配置文件（详查：</span><a href="https://cli.vuejs.org/zh/config/#vue-config-js" data-href="https://cli.vuejs.org/zh/config/#vue-config-js" target="_blank" class="ne-link"><span class="ne-text">https://cli.vuejs.org/zh/config/#vue-config-js</span></a><span class="ne-text">）</span></p><pre><code>module.exports = &#123;  // 打包的目录  outputDir: 'dist',   // 在保存时校验格式  lintOnSave: true,   // 生产环境是否生成 SourceMap  productionSourceMap: false,  devServer: &#123;    // 启动服务后是否打开浏览器    open: true,     // 错误信息展示到页面    overlay: &#123;       warnings: true,      errors: true    &#125;,    host: '0.0.0.0',    port: 8066, // 服务端口    https: false,    hotOnly: false,    // proxy: &#123; // 设置代理    //   '/api': &#123;    //     target: host,    //     changeOrigin: true,    //     pathRewrite: &#123;    //       '/api': '/',    //     &#125;    //   &#125;,    // &#125;,  &#125;,&#125;</code></pre><h2 id="iilBk"><span class="ne-text">[单元测试]Jest</span></h2><h3 id="esZbn"><span class="ne-text">Vue3.x+TypeScript项目下的jest单元测试</span></h3><p id="ue1eeafde" class="ne-p"><span class="ne-text">官网API：</span><a href="https://next.vue-test-utils.vuejs.org/api/" data-href="https://next.vue-test-utils.vuejs.org/api/" target="_blank" class="ne-link"><span class="ne-text">https://next.vue-test-utils.vuejs.org/api/</span></a></p><h4 id="ZD3XX"><span class="ne-text">jest.config.js</span></h4><p id="u4b92032a" class="ne-p"><span class="ne-text">项目搭建成功之后的默认配置如下：</span></p><pre><code>module.exports = &#123;  preset: '@vue/cli-plugin-unit-jest/presets/typescript-and-babel',  transform: &#123;    '^.+\\.vue$': 'vue-jest',  &#125;,&#125;</code></pre><p id="u53eadf7c" class="ne-p"><span class="ne-text">更改如下配置</span></p><pre><code>/* * @Author: wztlink1013 * @Date: 2021-12-25 14:49:37 * @LastEditTime: 2021-12-26 14:56:39 * @Description: */module.exports = &#123;  preset: '@vue/cli-plugin-unit-jest/presets/typescript-and-babel',  // 测试的文件类型  moduleFileExtensions: ['js', 'jsx', 'json', 'vue', 'ts', 'tsx'],  // 转化方式  transform: &#123;    '^.+\\.vue$': '&lt;rootDir&gt;/node_modules/vue-jest',    '.+\\.(css|styl|less|sass|scss|svg|png|jpg|ttf|woff|woff2)$':      '&lt;rootDir&gt;/node_modules/jest-transform-stub',    '^.+\\.jsx?$': '&lt;rootDir&gt;/node_modules/babel-jest',    '^.+\\.tsx?$': '&lt;rootDir&gt;/node_modules/ts-jest',  &#125;,  // 不进行匹配的目录  transformIgnorePatterns: ['&lt;rootDir&gt;/node_modules/'],  // 匹配哪些文件进行测试  testMatch: ['**/tests/unit/**/*.spec.[jt]s?(x)', '**/__tests__/*.[jt]s?(x)'],  // @符号 表示当前项目下的src  moduleNameMapper: &#123;    '^@/(.*)$': '&lt;rootDir&gt;/src/$1',  &#125;,  // 将保存的快照测试结果进行序列化，使得其更美观  snapshotSerializers: ['jest-serializer-vue'],&#125;</code></pre><h4 id="DMmo5"><span class="ne-text">单个文件的单元测试</span></h4><p id="u084e8f38" class="ne-p"><span class="ne-text">项目下运行单元测试命令 </span><code class="ne-code"><span class="ne-text">test:unit</span></code><span class="ne-text"> 默认测试所有测试文件，不能指定文件进行单元测试。</span></p><p id="u05bd7eb5" class="ne-p"><span class="ne-text"></span></p><p id="u2602c250" class="ne-p"><span class="ne-text">在本地下载全局jest然后指定命令去执行项目的单个文件单个测试</span></p><pre><code>cnpm install jest --global</code></pre><p id="uc0dae2b7" class="ne-p"><span class="ne-text">然后执行</span></p><pre><code>jest ./tests/unit/jestTest.spec.ts</code></pre><p id="u914c5b2e" class="ne-p"><span class="ne-text">或</span></p><pre><code>npx jest ./tests/unit/jestTest.spec.ts</code></pre><p id="u8f69b25c" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1640502745377-c5d57f26-13d6-4701-b7fd-aa1fb0b4312f.png" width="297.5" id="u261c3a42" class="ne-image"></p><h3 id="J5fSq"><span class="ne-text">空白项目下的jest单元测试</span></h3><h4 id="H1tup"><span class="ne-text">初始化npm插件项目</span></h4><pre><code>npm init -y</code></pre><h4 id="N2udI"><span class="ne-text">下载Jest和babel依赖</span></h4><pre><code>cnpm i @babel/core @babel/preset-env  jest@24.8.0 -D</code></pre><h4 id="hMIFh"><span class="ne-text">创建测试文件</span></h4><p id="u09ce622a" class="ne-p"><span class="ne-text">创建测试框架用的文件index.js和index.test.js两个文件</span></p><p id="ua1d89b6c" class="ne-p"><code class="ne-code"><span class="ne-text">index.js</span></code></p><pre><code>/* * @Descripttion: * @Date: 2021-12-07 20:08:15 * @LastEditTime: 2021-12-07 20:08:16 */export const add = (a, b) =&gt; &#123;  return a + b;&#125;;<p>export const reduce = (a, b) =&gt; &#123;<br>  return a - b;<br>&#125;;<br></code></pre></p><p id="ud972a05a" class="ne-p"><code class="ne-code"><span class="ne-text">index.test.js</span></code></p><pre><code>/* * @Descripttion: * @Date: 2021-12-07 20:08:31 * @LastEditTime: 2021-12-07 20:45:17 */import &#123; add, reduce &#125; from &quot;./index&quot;<p>// toBe 数字<br>test(&quot;测试add函数&quot;, () =&gt; &#123;<br>  expect(add(1, 2)).toBe(3)<br>&#125;)<br>test(&quot;测试add函数（函数功能出错===打印）&quot;, () =&gt; &#123;<br>  expect(add(1, 2)).toBe(4)<br>&#125;)<br>test(&quot;测试reduce函数&quot;, () =&gt; &#123;<br>  expect(reduce(3, 2)).toBe(1)<br>&#125;)</p><p></code></pre></p><p id="u5a934f21" class="ne-p"><span class="ne-text">不能运行是node环境不能直接使用es6语法，需要只用babel来转换</span></p><p id="uf28fecec" class="ne-p"><span class="ne-text">新建</span><code class="ne-code"><span class="ne-text">.babelrc</span></code><span class="ne-text">文件</span></p><pre><code>// .babelrc&#123;    &quot;presets&quot;: [            [&quot;@babel/preset-env&quot;, &#123;                &quot;targets&quot;: &quot;&gt; 5%&quot;            &#125;]    ]&#125;</code></pre><h4 id="uA7SI"><span class="ne-text">运行</span></h4><p id="u01cd9433" class="ne-p"><span class="ne-text">运行npm run test 就可以测试了</span></p><p id="u63633d80" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1638881167559-731c4af0-07c1-4d1b-b3d2-9273ab358fcb.png" width="826.5" id="Bt95b" class="ne-image"></p><h3 id="lociY"><span class="ne-text">Jest API及相关命令</span></h3><ul class="ne-ul"><li id="u70974d24"><span class="ne-text">官方文档：</span><a href="https://jestjs.io/zh-Hans/docs/getting-started" data-href="https://jestjs.io/zh-Hans/docs/getting-started" target="_blank" class="ne-link"><span class="ne-text">https://jestjs.io/zh-Hans/docs/getting-started</span></a></li></ul><p id="u645cac91" class="ne-p"><span class="ne-text">相关教程：</span></p><ul class="ne-ul"><li id="uab34ba30"><a href="https://juejin.cn/post/6844904114753634317" data-href="https://juejin.cn/post/6844904114753634317" target="_blank" class="ne-link"><span class="ne-text">Jest前端自动化测试入门</span></a></li><li id="u3fc45678"><a href="https://xie.infoq.cn/article/f743bf48dc9ea09e5cbd7285c" data-href="https://xie.infoq.cn/article/f743bf48dc9ea09e5cbd7285c" target="_blank" class="ne-link"><span class="ne-text">搭建基本 Jest 测试框架，解读覆盖率实现原理</span></a></li><li id="ud641ceff"><a href="https://juejin.cn/post/6844904082516377607" data-href="https://juejin.cn/post/6844904082516377607" target="_blank" class="ne-link"><span class="ne-text">vue项目搭建jest单元测试及采坑</span></a></li><li id="ua6daf3d6"><a href="https://cloud.tencent.com/developer/article/1602142" data-href="https://cloud.tencent.com/developer/article/1602142" target="_blank" class="ne-link"><span class="ne-text">Vue-Test-Utils + Jest 单元测试入门与实践</span></a></li><li id="ua2ad2660"><span class="ne-text">eslint就可以使用：</span><a href="https://www.npmjs.com/package/eslint-plugin-jest" data-href="https://www.npmjs.com/package/eslint-plugin-jest" target="_blank" class="ne-link"><span class="ne-text">eslint-plugin-jest</span></a></li></ul><h4 id="nASi3"><span class="ne-text">Jest API</span></h4><ul class="ne-ul"><li id="u64eb9bc4"><code class="ne-code"><span class="ne-text">test()</span></code><span class="ne-text">类似请求后端接口一样，请求成功或失败的判断</span></li><li id="u2e2cd57b"><code class="ne-code"><span class="ne-text">expect()</span></code><span class="ne-text">则是判断和预期的值是否一样，然后执行相应的操作</span></li><li id="ud2ddc9b0"><code class="ne-code"><span class="ne-text">toBe()</span></code><span class="ne-text">就是写入预期值来判断是否和自己写的代码值是否一样</span></li><li id="u3251118b"><code class="ne-code"><span class="ne-text">describe</span></code><span class="ne-text"> 描述, decribe会形成一个作用域</span></li><li id="u74302817"><code class="ne-code"><span class="ne-text">it</span></code><span class="ne-text"> 断言</span></li></ul><h4 id="nr2aO"><span class="ne-text">jest --coverage</span></h4><p id="u966bb14b" class="ne-p"><span class="ne-text">查看覆盖率命令</span></p><p id="uafec70e4" class="ne-p"><span class="ne-text">该命令可以可视化展示，也可以在浏览器打开可视化结果网页</span></p><p id="ub8b54fff" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1640503326529-c0e50682-a7d0-4e47-9be3-df6c5e71b8e3.png" width="581.5" id="u1305df8b" class="ne-image"></p><h2 id="RCTVi"><span class="ne-text">[单元测试]e2e-cypress</span></h2><p id="u7eaa1147" class="ne-p"><span class="ne-text">插眼：日后再深入了解</span></p><p id="u9c33b81a" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1640504518665-55a6bd16-bb69-411d-bc9b-de4b6e2db2cc.jpeg" width="79" id="nTdFS" class="ne-image"></p><p id="u6b49e626" class="ne-p"><span class="ne-text">Vue官方插件地址：</span></p><ul class="ne-ul"><li id="u89b7da36"><span class="ne-text"></span><a href="https://www.npmjs.com/package/@vue/cli-plugin-e2e-cypress" data-href="https://www.npmjs.com/package/@vue/cli-plugin-e2e-cypress" target="_blank" class="ne-link"><span class="ne-text">https://www.npmjs.com/package/@vue/cli-plugin-e2e-cypress</span></a></li></ul><p id="uc4e81d13" class="ne-p"><span class="ne-text">参考教程：</span></p><ul class="ne-ul"><li id="u06cfad14"><a href="https://www.jianshu.com/p/459612488233" data-href="https://www.jianshu.com/p/459612488233" target="_blank" class="ne-link"><span class="ne-text">Vue项目采用Cypress做e2e自动化测试，手把手一撸到底</span></a></li></ul><h2 id="wYveI"><span class="ne-text">Vue3+TypeScript项目搭建过程中报错 </span></h2><h3 id="pirTY"><span class="ne-text">VSCode插件ESLint+Prettier+vetur代码格式化冲突</span></h3><p id="ue95c4747" class="ne-p"><span class="ne-text">这三者是代码校验和格式化的插件，当vue3.x项目搭建成功之后</span></p><p id="u603aa0dd" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1640422446727-53aab258-0454-486d-b2e7-f4c181c7b404.png" width="285.5" id="W9mzl" class="ne-image"></p><p id="u799823b7" class="ne-p"><span class="ne-text">该行配置需要注释，不然代码保存之后，会经过Prettier和vetur两者之间的来回格式化顺序，导致不能正常格式化。</span></p><p id="u67f0d11d" class="ne-p"><span class="ne-text"></span></p><p id="u43374fc9" class="ne-p"><span class="ne-text">具体矛盾原因：</span></p><ul class="ne-ul"><li id="u13878e26"><a href="https://zhuanlan.zhihu.com/p/101241781" data-href="https://zhuanlan.zhihu.com/p/101241781" target="_blank" class="ne-link"><span class="ne-text">解决vscode eslint与prettier冲突</span></a></li><li id="u6d1958fd"><a href="https://zhuanlan.zhihu.com/p/347339865" data-href="https://zhuanlan.zhihu.com/p/347339865" target="_blank" class="ne-link"><span class="ne-text">VSCode中ESLint、Prettier 配置冲突问题原因及解决方案</span></a></li><li id="ue1e225a1"><a href="https://www.cnblogs.com/wangpenghui522/p/13727990.html" data-href="https://www.cnblogs.com/wangpenghui522/p/13727990.html" target="_blank" class="ne-link"><span class="ne-text">VSCode-Prettier和ESLint如何和睦共处? </span></a></li><li id="u43160271"><a href="https://cloud.tencent.com/developer/article/1802491" data-href="https://cloud.tencent.com/developer/article/1802491" target="_blank" class="ne-link"><span class="ne-text">Vue 基于VSCode结合Vetur+ESlint+Prettier统一Vue代码风格</span></a></li></ul><p id="u7face581" class="ne-p"><span class="ne-text"></span></p><ul class="ne-ul"><li id="u433654bc"><span class="ne-text">Prettier插件：一定要留，能保存所有文件，按照自己规则进行格式化</span></li><li id="u411ced4f"><span class="ne-text">ESLint插件</span></li><li id="u7d95cb10"><span class="ne-text">vetur插件</span></li><li id="u81822d9f"><span class="ne-text">Vue项目中的prettier插件</span></li><li id="u17721640"><span class="ne-text">Vue项目中的eslint插件</span></li><li id="u82fcf70a"><span class="ne-text">Vue项目中的eslint的各个子插件</span></li></ul><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="u277c5a88"><span class="ne-text">eslint-plugin-prettier：这个就是typescript项目中上述冲突的缘由</span></li><li id="u77b8d609"><span class="ne-text">eslint-config-prettier</span></li><li id="u48b7feb0"><span class="ne-text">……</span></li></ul></ul><h3 id="i6BcM"><span class="ne-text">Error: Cannot find module 'vue-loader-v16/package.json'</span></h3><p id="ub55684c9" class="ne-p"><span class="ne-text">在导入Vue3 + TypeScript的项目</span></p><ol class="ne-ol"><li id="u1a42696e"><span class="ne-text">升级npm</span></li></ol><p id="u83a95ccd" class="ne-p"><span class="ne-text">使用cnpm的也要升级一下cnpm</span></p><pre><code>cnpm i -g cnpm</code></pre><ol start="2" class="ne-ol"><li id="uc1f116bd"><span class="ne-text">重新安装node_modules依赖包</span></li></ol><pre><code>cnpm i // 重新安装</code></pre><ol start="3" class="ne-ol"><li id="u1e7e4d28"><span class="ne-text">重新下载</span></li></ol><pre><code>cnpm i -D vue-loader-v16</code></pre><h3 id="LwYwy"><span class="ne-text">[vue/no-multiple-template-root]The template root requires exactly one element.eslint-plugin-vue</span></h3><p id="u59224a56" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1640357960271-5a2b291c-9a75-45eb-90c7-181a081cd1b3.png" width="524" id="LDxro" class="ne-image"></p><h3 id="JDa5v"><span class="ne-text">找不到模块“&quot;@aomao/engine&quot;”或其相应的类型声明。ts(2307)</span></h3><div data-type="danger" class="ne-alert"><p id="ub4ceac5d" class="ne-p"><span class="ne-text">报错信息</span></p></div><pre><code>找不到模块“&quot;@aomao/engine&quot;”或其相应的类型声明。ts(2307)</code></pre><pre><code>模块“&quot;@aomao/engine&quot;”没有导出的成员“PluginEntry”。ts(2305)</code></pre><div data-type="success" class="ne-alert"><p id="uac4b1750" class="ne-p"><span class="ne-text">按照网上找的一些方法，都无法解决这个问题</span></p><p id="u1c0d7a79" class="ne-p"><span class="ne-text">重启可以解决，插件用的太多===太卡顿</span></p></div><h3 id="R8rjd"><span class="ne-text">'vue/comment-directive' — error in the end of public/index.html just after vue-cli installation</span></h3><p id="uc3e1dea7" class="ne-p"><span class="ne-text">public文件夹次啊的index.html文件末尾会有该报错，解决办法就是配置相关rule</span></p><p id="udac104c0" class="ne-p"><a href="https://github.com/vuejs/eslint-plugin-vue/issues/1355" data-href="https://github.com/vuejs/eslint-plugin-vue/issues/1355" target="_blank" class="ne-link"><span class="ne-text">https://github.com/vuejs/eslint-plugin-vue/issues/1355</span></a></p><h3 id="JvlUf"><span class="ne-text">Delete `␍`eslintprettier/prettier</span></h3><p id="u7ec44cd7" class="ne-p"><span class="ne-text">将代码push到GitHub仓库，新拉取下来，文件的每行代码会有此报错</span></p><p id="u10654bf9" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1644376958819-fecf2dc0-76f0-4a31-b2a8-269dd345223d.png" width="536" id="ua5af1e6f" class="ne-image"></p><p id="ua74cd873" class="ne-p"><span class="ne-text"></span></p><p id="u33be619f" class="ne-p"><span class="ne-text">报错原因：文本文件的换行符不一致</span></p><p id="uaf340915" class="ne-p"><span class="ne-text">具体参考：</span><a href="https://juejin.cn/post/6844904069304156168#heading-6" data-href="https://juejin.cn/post/6844904069304156168#heading-6" target="_blank" class="ne-link"><span class="ne-text">https://juejin.cn/post/6844904069304156168#heading-6</span></a></p><p id="ue63cf88e" class="ne-p"><span class="ne-text">解决办法：</span></p><ol class="ne-ol"><li id="u200bacee"><span class="ne-text">【治标】如果只有少个文件，将vscode右下角处改为LF即可</span></li></ol><p id="u56edc332" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1644377438548-8db15f94-e644-43ac-bad4-2f4ce86eb274.png" width="449" id="u08d40637" class="ne-image"></p><ol start="2" class="ne-ol"><li id="u841e15fc"><span class="ne-text">【治本】在windows环境下，全局关掉转换行</span></li></ol><pre><code>git config --global core.autocrlf false</code></pre><p id="u4f4aac5e" class="ne-p"><span class="ne-text">然后再将刚刚拉取到本地的项目删掉，重新从GitHub拉取到本地，就不会出现该报错了</span></p><ol start="3" class="ne-ol"><li id="uf14bc6be"><span class="ne-text">另外，在vscode设置中设置如下，可以达到新建文件就是LF转换行的效果了</span></li></ol><p id="u33b96b28" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1644377676559-12ee984b-e189-4dcf-8a72-59e37198b974.png" width="362" id="u84528446" class="ne-image"></p><p id="uc6e546f7" class="ne-p"><br></p><h2 id="S9yt5"><span class="ne-text">vue3 + vite + typescript脚手架的安装</span></h2><p id="u8b2c7bc4" class="ne-p"><span class="ne-text" style="color: rgb(36, 41, 47); font-size: 14px">参考：</span><a href="https://juejin.cn/post/7051565418460217375" data-href="https://juejin.cn/post/7051565418460217375" target="_blank" class="ne-link"><span class="ne-text">https://juejin.cn/post/7051565418460217375</span></a></p><ul class="ne-ul"><li id="uc7cc72c2"><span class="ne-text" style="color: rgb(36, 41, 47); font-size: 14px">官网：安装vue和vue-cli</span><span class="ne-text" style="color: rgb(36, 41, 47); font-size: 14px"> </span><a href="https://v3.cn.vuejs.org/guide/installation.html" data-href="https://v3.cn.vuejs.org/guide/installation.html" target="_blank" class="ne-link"><span class="ne-text">https://v3.cn.vuejs.org/guide/installation.html</span></a></li><li id="u0e36ba39"><span class="ne-text" style="color: rgb(36, 41, 47); font-size: 14px">Vite + Vue3 + TypeScript 简单的项目骨架搭建</span></li><li id="u343654f1"><span class="ne-text" style="color: rgb(36, 41, 47); font-size: 14px">使用Vite构建项目</span></li><li id="ue6bb56d8"><span class="ne-text" style="color: rgb(36, 41, 47); font-size: 14px">修改 Vite 配置文件：需要下载path包，以便于对@符号的使用</span></li><li id="u02e6a85b"><span class="ne-text" style="color: rgb(36, 41, 47); font-size: 14px">规范目录结构</span></li><li id="u66608672"><span class="ne-text" style="color: rgb(36, 41, 47); font-size: 14px">下载vue-router</span></li></ul></div>]]></content>
      
      
      <categories>
          
          <category> 环境工具 </category>
          
          <category> 环境搭建 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>炒青菜</title>
      <link href="/essay/cook_greens/"/>
      <url>/essay/cook_greens/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><ul class="ne-ul"><li id="u0f180e9e"><span class="ne-text">洗菜-切菜</span></li><li id="u75cb97e5"><span class="ne-text">倒如适量香油</span></li></ul><div class="ne-quote"><p id="uf3aacd3a" class="ne-p"><span class="ne-text">然后倒入部分猪油（可选）</span></p><p id="u832f287b" class="ne-p"><span class="ne-text">如果是做鱼之类的，就不要放入猪油了</span></p></div><ul class="ne-ul"><li id="u867e8c85"><span class="ne-text">待油烧入适量时刻，先将菜根先放入锅中，菜叶等菜根烧一会再放</span></li></ul><div class="ne-quote"><p id="u49432d79" class="ne-p"><span class="ne-text">炒的时候可以适量拍打菜根，以便融入配料等副菜</span></p></div><ul class="ne-ul"><li id="ua57e170b"><span class="ne-text">青菜炒至适量时刻，将盐等配料放入锅中</span></li><li id="u32e5e1aa"><span class="ne-text">不一会就可以将其乘入盘中</span></li></ul><p id="u42b5732a" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2021/gif/1484158/1639714281103-f3661a3d-07fa-4f5b-898f-992d9d9d45af.gif" width="48" id="hbB5J" class="ne-image"></p></div>]]></content>
      
      
      <categories>
          
          <category> 料理 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>炒鸡肉</title>
      <link href="/essay/cook_chicken/"/>
      <url>/essay/cook_chicken/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><ul class="ne-ul"><li id="u5bd9b07e"><span class="ne-text">切块，炒</span></li></ul><div class="ne-quote"><p id="u602b9986" class="ne-p"><span class="ne-text">目的就是把鸡肉身体里面的水分去掉</span></p></div><p id="ubbfbe04a" class="ne-p"><span class="ne-text">具体的操作步骤：</span></p><p id="u7e1f8b56" class="ne-p"><span class="ne-text">① 倒入香油，待香油表面的一层油花去掉，再将鸡肉导入</span></p><p id="u8051678a" class="ne-p"><span class="ne-text">② 炒到鸡肉大部分水分已经去掉了，放入生姜，小米椒，放盐……</span></p><p id="u60f18ddb" class="ne-p"><span class="ne-text">（此时放盐，只是以便待会炖好可以直接吃，也可以放在待会放的）</span></p><ul class="ne-ul"><li id="ua47473f0"><span class="ne-text">锅炖</span></li></ul><p id="u4042d85e" class="ne-p"><span class="ne-text">锅下面放入适量的水，不能过多，不然溢到鸡肉里面就不能吃了</span></p><p id="ucd693c30" class="ne-p"><span class="ne-text">同时还需要用个小盖子将鸡肉盖住，这样一面汽水浸入鸡肉里面，也不能吃</span></p><p id="ua7fc2bbb" class="ne-p"><span class="ne-text"></span></p><p id="ub4b0bb70" class="ne-p"><span class="ne-text">这个时候理论上是可以直接吃的，但是如果自己觉得荤味太重，也可以再拿出来，再放入一点点香油小炒小烩</span></p><p id="u92332ea5" class="ne-p"><br></p><p id="ufe3269cc" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1639711573828-ce9f3075-2dbc-465e-921f-121f56bb00e0.jpeg" width="60" id="YodIL" class="ne-image"></p></div>]]></content>
      
      
      <categories>
          
          <category> 料理 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>一个梦——害怕</title>
      <link href="/essay/ifuuic/"/>
      <url>/essay/ifuuic/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="u0c684b80" class="ne-p"><strong><span class="ne-text">被误会</span></strong></p><p id="u5259f535" class="ne-p"><span class="ne-text">两个同事和一个老人，那个老人迷迷糊糊 缓缓 进到我们房子里面，然后不知道一直在干嘛，最后是我的室友A不知道哪来的一把特别特别锋利的刀无意间割伤那位老人的大腿，导致大量失血，最终死了</span></p><p id="ua367cb5b" class="ne-p"><span class="ne-text">然后第二天，有班主任来追究这件事，我不知道怎么的，对质的时候，我正好不在，他们两个被叫去对质，听别人说，他们对质的时候说的答案不一样，反正最后，被误会成是我，我有理说不清，那个老人不是我杀的，但是我的内心又不想说是那个室友做的，于是一直耽搁，我的心里很矛盾，最终，他们统一和班主任说，看到我在那位老人面前用刀…我不知道怎么的，明明不是我，可我在逃避，我不知道在怕什么，可能是全世界都以为我是凶手，可我不是，我争辩不了，那种无力感，那种委屈，那种害怕…</span></p><p id="u9a1faadb" class="ne-p"><span class="ne-text"></span></p><p id="uc1511c19" class="ne-p"><strong><span class="ne-text">妈妈失忆</span></strong></p><p id="u187f7768" class="ne-p"><span class="ne-text">一切的落魄，我又回到那个房子里，又有一个老人走到我面前，那是我妈妈，我不知道妈妈怎么就突然瞬间变老了，样子还是一样，但是已经失忆了，我妈妈不记得我了…我哭，一直哭，我一直说，我是你儿子呀，可是我在我妈妈面前就是一个陌生人，我好伤心，一直哭，我妈妈还对房子外面的路过的街坊邻居说，你们看，这个孩子真懂事，而我呆呆地站在那，伤心到形神分离…</span></p><p id="ud91394e3" class="ne-p"><span class="ne-text"></span></p><p id="ua77c9a07" class="ne-p"><span class="ne-text"></span></p><p id="u6793d2ad" class="ne-p"><span class="ne-text">梦醒了，脚在抽搐，抽搐的那块被子特别冰凉，原来是没关窗户，十二月的冷风吹进来了……</span></p><p id="u387f48f1" class="ne-p"><span class="ne-text">2021.12.03  07:04</span></p><p id="u8eec700e" class="ne-p"><span class="ne-text"></span></p><p id="u6867dcf4" class="ne-p"><span class="ne-text"></span></p><p id="u83c1bde3" class="ne-p"><span class="ne-text">后记：</span></p><p id="u1c39052d" class="ne-p"><span class="ne-text">一个人最失意甚至死亡的时候，脑子里面浮现的，其实是亲人，在小的时候，有次和小伙伴去湖里面游泳，那是我第一次下水游泳，当时差点淹死，我至今都清楚地记得我倒在水里面的时候，一直呛水那会，脑子里面想的其实就是家里厨房，客厅，还有熟悉的我妈叫我吃饭那声音……</span></p><p id="u8e4196db" class="ne-p"><span class="ne-text"></span></p><p id="uff11e36a" class="ne-p"><span class="ne-text">很多人说我很冷，可我其实不是，相处之后，我觉得我还是比较重感情的，我挺感谢这个梦的…</span></p><p id="u17e1677c" class="ne-p"><span class="ne-text"></span></p><p id="ufe496009" class="ne-p"><span class="ne-text">人其实都有两面，一面是原本流露真情的自我，一面是这个世界这个周围环境甚至自身经历所塑造的自己，可能沉稳，冷静，等等这些都是他人所看到的，然而人的还有一面，就像迟子建笔下的杨二嫂一般，将丈夫的尸体锁在冰柜，深夜独自买醉，因为这可能就是对自我感情的一种救赎，因为到了白天，当周围不再是黑夜，人们不再抒情，用坚强的外壳去跻身于这个不好不坏，不完美却也没有大缺陷的世界中…</span></p><p id="ua3c54a2a" class="ne-p"><span class="ne-text"></span></p><p id="u6a31b4e8" class="ne-p"><span class="ne-text"></span></p><p id="ua2c293ac" class="ne-p"><span class="ne-text"></span></p><p id="u572d5056" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1638506128821-fd0914a3-839b-4cb9-9e0b-a79b4d557a1e.jpeg" width="1176" id="u8c4a114e" class="ne-image"></p></div>]]></content>
      
      
      <categories>
          
          <category> 异世界 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Nginx常用命令</title>
      <link href="/blog/kz2il6/"/>
      <url>/blog/kz2il6/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><pre><code>cd e:\Nginxcd nginx-1.16.1start nginxtasklist /fi &quot;imagename eq nginx.exe&quot;     //查看进程nginx -t -c ./conf/nginx.conf   //检查配置文件nginx -s reload  //重启服务nginx -s stop   //快速停止nginx -s quit   //完整有序的停止<p>server &#123;<br>  listen       80;<br>  server_name  tf.local.msshuo.cn;<br>  #server_name  kf.local.msshuo.cn;</p><p>  #charset koi8-r;</p><p>  #access_log  logs/host.access.log  main;</p><p>  location / &#123;<br>    root   E:\mly\ad_dist;<br>    #root   E:\mly\kf_dist;<br>    index  index.html index.htm;<br>  &#125;</p><p>  #error_page  404              /404.html;</p><h1 id="redirect-server-error-pages-to-the-static-page-50x-html"><a href="#redirect-server-error-pages-to-the-static-page-50x-html" class="headerlink" title="redirect server error pages to the static page /50x.html"></a>redirect server error pages to the static page /50x.html</h1><h1 id=""><a href="#" class="headerlink" title=""></a></h1><p>  error_page   500 502 503 504  /50x.html;<br>  location = /50x.html &#123;<br>    root   html;<br>  &#125;</p><p></code></pre></p></div>]]></content>
      
      
      <categories>
          
          <category> 环境工具 </category>
          
          <category> 环境搭建 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>14种设计模式</title>
      <link href="/blog/figfyg/"/>
      <url>/blog/figfyg/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h3 id="xAor6"><span class="ne-text">一、单例模式</span></h3><p id="u378e1e12" class="ne-p"><span class="ne-text">类只有一个实例，像BOM这个全局对象就是单例模式，还有单独创建一个对象字面量，也是单例模式，下面讲述单例模式的实现：</span></p><pre><code>class Aoteman &#123;  constructor(name, age) &#123;    this.name = name    this.age = age  &#125;  // 实现单例模式  static getInstance(name, age) &#123;    if (!this.instance) &#123;      this.instance = new Aoteman(name, age)    &#125;    return this.instance  &#125;<p>  Ability = data =&gt; &#123;<br>    console.log(this.name + ‘ can ‘ + data)<br>  &#125;<br>&#125;</p><p>const dijia = new Aoteman(‘dijia’, ‘2022’)<br>console.log(dijia.name)<br>dijia.Ability(‘X-ray’)</p><p>let tailuo = Aoteman.getInstance(‘tailuo’, ‘1990’)<br>console.log(tailuo.name)<br>tailuo.Ability(‘Y-ray’)<br>let aidi = Aoteman.getInstance(‘aidi’, ‘1990’)<br>console.log(aidi.name)<br>tailuo.Ability(‘Z-ray’)<br>console.log(‘———————‘)<br>console.log(dijia === tailuo)<br>console.log(tailuo === aidi)<br></code></pre></p><p id="ufa71f4fa" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1648729211906-1aa126ab-8ccc-4447-9037-1e1602122a19.png" width="380.8333182003769" id="u5e96591e" class="ne-image"></p><p id="u53d5a710" class="ne-p"><span class="ne-text">上面的方式实现，只能调用getInstance方法才能创建单例，如果用户再次使用new来创建实例，还是不可行，所以还需要对上述予以工厂模式封装：</span></p><pre><code>const singleFactory = (...rest) =&gt; &#123;  return Aoteman.getInstance(...rest)&#125;</code></pre><p id="u6bc8bfaf" class="ne-p"><span class="ne-text">使用场景：发布订阅场景，我们需要在一个地方进行订阅，在另一个地方进行发布，这样就需要保证在不同文件中访问到的是同一个实例。</span></p><pre><code>class PubSub &#123;  constructor() &#123;    this.listeners = &#123;&#125;  &#125;  publish(event, data) &#123;    if (!this.listeners[event]) &#123;      return;    &#125;    this.listeners[event].forEach(listener =&gt; &#123;      listener(data);    &#125;)  &#125;  subscribe(event, callback) &#123;    if (!this.listeners[event]) &#123;      this.listeners[event] = []    &#125;    this.listeners[event].push(callback);  &#125;&#125;export default new PubSub</code></pre><p id="u1b2d8d0d" class="ne-p"><span class="ne-text"></span></p><h3 id="VPoDB"><span class="ne-text">二、工厂模式</span></h3><ul class="ne-ul"><li id="ud8b852d2"><span class="ne-text" style="color: rgb(36, 41, 47); font-size: 14px">优点：一个工厂创建同一类对象，更好的归类创建</span></li><li id="u6a38822c"><span class="ne-text" style="color: rgb(36, 41, 47); font-size: 14px">抽象工厂模式的缺点就是，如果需要增加新的产品，比如要生产可乐周边玩偶，这就需要对原有的抽象工厂接口进行改造，不符合开闭原则。</span></li></ul><pre><code>function CreateElement(type) &#123;  switch (type) &#123;    case 'Input':      return new Input()      break;    case 'Div':      return new Div()      break;    default:      throw new Error('无当前产品')  &#125;&#125;<p>function Input() &#123;<br>  return document.createElement(‘input’)<br>&#125;</p><p>function Div() &#123;<br>  return document.createElement(‘div’)<br>&#125;</p><p>//test<br>const input = new CreateElement(‘Input’);<br>const div = new CreateElement(‘DIV’);<br>console.log(input)      // input<br>console.log(div)        // div<br></code></pre></p><pre><code>class User &#123;  constructor(name) &#123;    this.name = name  &#125;  SetRoleType(type) &#123;    switch (type) &#123;      case 'Admin':        return new UserAdmin()        break      case 'Member':        return new UserMember()        break      default:        throw new Error('Set Error!')    &#125;  &#125;  GetName = () =&gt; &#123;    console.log('this name is: ' + this.name)  &#125;&#125;class UserAdmin extends User &#123;  constructor(name) &#123;    super(name)    this.name = name  &#125;  RoleInfo = () =&gt; &#123;    console.log('Type is Admin ')  &#125;&#125;const zhangsan = new User('zhangsan')zhangsan.GetName()zhangsan.SetRoleType('Admin').RoleInfo()</code></pre><p id="u218de333" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1648731190936-4c3eb68a-b66b-486c-bd51-2d7137cb592b.png" width="245.8333235647947" id="u21180cde" class="ne-image"></p><h3 id="zP5cf"><span class="ne-text">建造者模式</span></h3><pre><code>/** * 建造者模式 */<p>/* 建造者 */<br>function ComputerBuilder(brand) &#123;<br>  this.brand = brand<br>&#125;</p><p>ComputerBuilder.prototype.buildCPU = function (type) &#123;<br>  switch (type) &#123;<br>    case ‘inter’:<br>      this.cpu = ‘inter处理器’<br>      break;<br>    case ‘AMD’:<br>      this.cpu = ‘AMD处理器’<br>      break;<br>  &#125;</p><p>  return this<br>&#125;</p><p>ComputerBuilder.prototype.buildMemory = function (mSize) &#123;<br>  thgis.mSize = ‘内存’ + mSize + ‘G’<br>  return this<br>&#125;</p><p>ComputerBuilder.prototype.buildDisk = function (dSize) &#123;<br>  this.dSize = ‘硬盘’ + dSize + ‘G’<br>  return this<br>&#125;</p><p>/* 厂家，负责组装 */<br>function computerDirector(brand, type, mSize, dSize) &#123;<br>  const _computer = new ComputerBuilder(brand)<br>  _computer.buildCPU(type)<br>    .buildMemory(mSize)<br>    .buildDisk(dSize)</p><p>  return _computer<br>&#125;</p><p>//test<br>const com = computerDirector(‘联想’, ‘inter’, 16, 500);<br>console.log(com); // ComputerBuilder &#123;brand: &quot;联想&quot;, cpu: &quot;inter 处理器&quot;, mSize: &quot;内存16G&quot;, dSize: &quot;硬盘500G&quot;&#125;<br></code></pre></p><p id="ue1c744d7" class="ne-p"><span class="ne-text"></span></p><h3 id="HQMCN"><span class="ne-text">代理模式</span></h3><pre><code>/** * 代理模式 */<p> /* 目标 */<br>function sendMsg(msg) &#123;<br>  console.log(msg)<br>&#125;</p><p>/* 代理 */<br>function ProxyMsg(msg) &#123;<br>  if (!msg) &#123;<br>    console.log(‘msg is empty’)<br>    return<br>  &#125;</p><p>  msg = ‘我要发送的数据是’ + msg<br>  sendMsg(msg)<br>&#125;</p><p>// test<br>ProxyMsg(‘您好!’)<br></code></pre></p><h3 id="PhIha"><span class="ne-text">享元模式</span></h3><pre><code>/** * 享元模式 */<p>/* 享元对象 */<br>function Shape(shape) &#123;<br>  this.shape = shape<br>&#125;</p><p>shape.prototype.draw = function () &#123;<br>  console.log(<code>画了一个$&#123;this.shape&#125;</code>)<br>}</p><p>/* 享元工厂 */<br>const ShapeFactory = (function () {<br>  const dataMap = {}<br>  return {<br>    getShapeContext(shape) {<br>      if (dataMap[shape]) return dataMap[shape]<br>      else {<br>        const instance = new Shape(shape)<br>        dataMap[shape] = instance<br>        return instance<br>      }<br>    }<br>  }<br>})()</p><p>// test<br>const rect = ShapeFactory.getShapeContext(‘rect’);<br>const circle = ShapeFactory.getShapeContext(‘circle’);</p><p>rect.draw();     // 画了一个 rect<br>circle.draw();   // 画了一个 circle<br></code></pre></p><h3 id="JKLzV"><span class="ne-text">适配器模式</span></h3><pre><code>/** * 适配器模式 */<p>const baiduMap = &#123;<br>  show: function () &#123;<br>    console.log(‘开始渲染百度地图’)<br>  &#125;<br>&#125;</p><p>const AMap = &#123;<br>  show: function () &#123;<br>    console.log(‘开始渲染高德地图’)<br>  &#125;<br>&#125;</p><p>/* 适配器 */<br>const baiduAdapter = &#123;<br>  render: function () &#123;<br>      return baiduMap.show()<br>  &#125;<br>&#125;</p><p>function renderMap(map) &#123;<br>  if (typeof map.render === ‘function’) &#123;<br>      map.render()<br>  &#125;<br>&#125;</p><p>// test<br>renderMap(AMap);            // 开始渲染高德地图<br>renderMap(baiduAdapter);    // 开始渲染百度地图<br></code></pre></p><h3 id="H22N6"><span class="ne-text">装饰器模式</span></h3><pre><code>/** * 装饰器模式 */<p>const btn = document.querySelector(‘#btn’)</p><p>// 原绑定事件<br>btn.onclick = function () &#123;<br>  console.log(‘按钮被点击了’)<br>&#125;</p><p>// 新增统计<br>function ajaxToServer() &#123;<br>  console.log(‘数据统计’)<br>&#125;</p><p>// 装饰器函数<br>function decorator(target, eventName, cb) &#123;<br>  const originFn = target[‘on’ + eventName]<br>  originFn &amp;&amp; originFn()<br>  cb &amp;&amp; cb ()<br>&#125;</p><p>// test<br>decorator(btn, ‘click’, ajaxToServer)<br></code></pre></p><h3 id="N1ZoP"><span class="ne-text">外观模式</span></h3><pre><code>/** * 外观模式  */<p>// 事件绑定<br>function addEvent(element, type, fn) &#123;<br>  if (element.addEventListener) &#123;<br>    element.addEventListener(type, fn, false)<br>  &#125; else if (element.attachEvent) &#123;<br>    element.attachEvent(‘on’ + type, fn)<br>  &#125; else &#123;<br>    element[‘on’ + type] = fn<br>  &#125;<br>&#125;</p><p>// 阻止事件冒泡<br>function cancelBubble(event) &#123;<br>  if (event.stopPropagation) &#123;<br>    event.stopPropagation()<br>  &#125; else &#123;<br>    event.cancelBubble = true<br>  &#125;<br>&#125;</p><p>// axios 中 getDefaultAdapter<br>function getDefaultAdapter() &#123;<br>  var baiduAdapter<br>  if (typeof process !== ‘undefined’ &amp;&amp; Object.prototype.toString.call(process) === ‘[object process]’) &#123;<br>    adapter = ‘a’<br>  &#125; else if (typeof XMLHttpRequest !== ‘undefined’) &#123;<br>    adapter =’b’<br>  &#125;</p><p>  return adapter<br>&#125;<br></code></pre></p><p id="u61e1541c" class="ne-p"><br></p><h3 id="n7oZA"><span class="ne-text">组合模式</span></h3><pre><code>/** * 组合模式 */<p>// 创建部门<br>function createApartment(name) &#123;<br>  return &#123;<br>    name,<br>    _children: [],<br>    add(target) &#123;<br>      this._children.push(target)<br>      return this<br>    &#125;,<br>    show(cb) &#123;<br>      this._children.forEach(function(child) &#123;<br>        child.show(cb)<br>      &#125;)<br>    &#125;<br>  &#125;<br>&#125;</p><p>// 创建员工<br>function createEmp(num, name) &#123;<br>  return &#123;<br>    num,<br>    name,<br>    show(cb) &#123;<br>      cb(this)<br>    &#125;<br>  &#125;<br>&#125;</p><p>// 创建部门<br>const techApartment = createApartment(‘技术部’)</p><p>// 创建子部门<br>const proApartment = createApartment(‘产品组’),<br>  devApartment = createApartment(‘开发组’)</p><p>techApartment.add(proApartment).add(devApartment)</p><p>proApartment.add(createEmp(100, ‘张三’))<br>  .add(createEmp(101, ‘李四’))</p><p>techApartment.add(createEmp(201, ‘小刘’))<br>  .add(createEmp(202, ‘小王’))<br>  .add(createEmp(203, ‘小陈’))<br>  .add(createEmp(204, ‘小亮’))</p><p>// 遍历<br>techApartment.show(function (item) &#123;<br>  console.log(<code>工号：$&#123;item.num&#125;，姓名：$&#123;item.name&#125;</code>)<br>})<br></code></pre></p><p id="ue0737db5" class="ne-p"><br></p><h3 id="jya6o"><span class="ne-text">桥接模式</span></h3><pre><code>/** * 桥接模式 */<p>// 桥接方法<br>function addEvent(ele, eventName, fn) &#123;<br>  document.querySelector(ele).addEventListener(eventName, fn, false)<br>&#125;</p><p>// 具体业务<br>addEvent(‘#btn’, ‘click’, function () &#123;<br>  console.log(‘hello world’)<br>&#125;)<br></code></pre></p><p id="ub2eaa9c6" class="ne-p"><span class="ne-text"></span></p><h3 id="usKNI"><span class="ne-text">发布-订阅模式</span></h3><pre><code>// 事件监听器const Emitter = (function () &#123;  const _events = &#123;&#125;  return &#123;    // 事件绑定    on(type, cb) &#123;      if (!_events[type]) &#123;        _events[type] = []      &#125;      if (typeof cb === 'function') &#123;        _events[type].push(cb)      &#125; else &#123;        throw new Error('参数类型必须为函数')      &#125;    &#125;,    // 事件解绑    off(type, cb) &#123;      if (!_events[type] || !_events[type].includes(cb)) return       // 移除事件监听      _events[type].map((fn, index) =&gt; &#123;        if (fn == cb) &#123;          _events[type].splice(index, 1)        &#125;      &#125;)    &#125;,    emit(type, ...args) &#123;      if (!_events[type]) return      _events[type].forEach(cb =&gt; cb(...args))    &#125;  &#125;&#125;)()<p>// 事件订阅<br>Emitter.on(‘change’, data =&gt; console.log(<code>我是第一条信息：$&#123;data&#125;</code>))<br>Emitter.on(‘change’, data =&gt; console.log(<code>我是第二条信息：$&#123;data&#125;</code>))</p><p>// 事件发布<br>Emitter.emit(‘change’, ‘参数’)</p><p></code></pre></p><p id="udce49d72" class="ne-p"><span class="ne-text">发布-订阅模式和观察者模式相近，具体区别有：</span></p><p id="u61bde39e" class="ne-p"><img src="https://camo.githubusercontent.com/7fd692610ddad0b886a45d4f74099593899efbb0262ea18df3dca75a9f44eb6c/687474703a2f2f7374617469632e7a7962756c756f2e636f6d2f677979696e2f376e356830306d757861346f7930336d657372716a666c782f696d6167655f31653071623666746331646f6431376e6375346f66673176346d392e706e67" width="835" id="ncdsN" class="ne-image"></p><p id="ub7eb1648" class="ne-p"><span class="ne-text"></span></p><h3 id="eY1bH"><span class="ne-text">策略模式</span></h3><pre><code>/** * 策略模式 */<p>// 校验规则<br>const strategyMap = &#123;<br>  // 校验手机号<br>  isMobile(mobile) &#123;<br>    return /^1\d&#123;10&#125;$/.test(mobile)<br>  &#125;,<br>  // 校验是否必填<br>  isRequired(str) &#123;<br>    return str.replace(/(^\s*)|(\s*$)/g, ‘’) !== ‘’<br>  &#125;<br>&#125;</p><p>// 校验方法<br>function validate(formData) &#123;<br>  let valid</p><p>  for (let key in formData) &#123;<br>    const val = formData[key]?.value<br>    const rules = formData[key]?.rules</p><pre><code>for (let i = 0; i &amp;lt; rules.length; i++) &#123;  const result = strategyMap[rules[i][&#39;rule&#39;].call(null,val)]  if (!result) &#123;    valid = &#123;      errField: key,      errValue: value,      errMsg: rules[i][&#39;message&#39;]    &#125;    break  &#125;&#125;if (valid) return valid</code></pre><p>  }</p><p>  return valid<br>}</p><p>// form 表单校验<br>const formData = {<br>  mobile: {<br>    value: ‘1380000000’,<br>    rules: [<br>      { rule: ‘isRequired’, message: ‘手机号码不能为空’ },<br>      { rule: ‘isMobile’, message: ‘手机号码格式不正确’ }<br>    ]<br>  }<br>}</p><p>// 获取校验结果<br>const valid = validate(formData)<br>if (!valid) {<br>  console.log(‘校验通过’)<br>} else {<br>  console.log(valid)<br>}<br></code></pre></p><p id="u5d03555e" class="ne-p"><span class="ne-text"></span></p><h3 id="JI6jF"><span class="ne-text">状态模式</span></h3><pre><code>/** * 状态模式 */<p>// 正常状态<br>function NormalState() &#123;<br>  this.handleChange = function (context) &#123;<br>    console.log(‘正常状态’)<br>    context.state = new ColorfulState()<br>  &#125;<br>&#125;</p><p>// 彩灯状态<br>function ColorfulState() &#123;<br>  this.handleChange = function (context) &#123;<br>    console.log(‘彩灯状态’)<br>    context.state = new CloseState()<br>  &#125;<br>&#125;</p><p>// 关闭状态<br>function CloseState() &#123;<br>  this.handleChange = function (context) &#123;<br>    console.log(‘关闭状态’)<br>    context.state = new NormalState()<br>  &#125;<br>&#125;</p><p>// 灯<br>function Light(state) &#123;<br>  this.state = state<br>  this.switch = function () &#123;<br>    this.state.handleChange(this)<br>  &#125;<br>&#125;</p><p>// 设置灯光初始为关闭<br>const light = new Light(new CloseState())</p><p>// 关闭状态–&gt;正常状态–&gt;彩灯状态–&gt;关闭状态…<br>setInterval(() =&gt; &#123;<br>  light.switch()<br>&#125;, 1000)<br></code></pre></p><p id="u141d76c8" class="ne-p"><span class="ne-text"></span></p><h3 id="tVMWA"><span class="ne-text">命令模式</span></h3><pre><code>/** * 命令模式 */<p>const Manager = (function () &#123;<br>  // 命令<br>  const commander = &#123;<br>    open: function () &#123;<br>      console.log(‘打开电视’)<br>    &#125;,<br>    close: function () &#123;<br>      console.log(‘关闭电视’)<br>    &#125;,<br>    change: function (channel) &#123;<br>      console.log(‘更换频道’ + channel)<br>    &#125;<br>  &#125;</p><p>  return &#123;<br>    // 执行命令<br>    exec: function (cmd) &#123;<br>      const args = [].splice.call(arguments, 1)<br>      commander[cmd] &amp;&amp; commander[cmd][args]<br>    &#125;<br>  &#125;<br>&#125;)</p><p>// test<br>Manager.exec(‘open’)        // 打开电视<br>Manager.exec(‘change’, 10)  // 更换频道 10<br>Manager.exec(‘close’)       // 关闭电视<br></code></pre></p><h3 id="chwSO"><span class="ne-text">参考</span></h3><ul class="ne-ul"><li id="u9c4f5769"><a href="https://github.com/yinguangyao/blog/issues/64" data-href="https://github.com/yinguangyao/blog/issues/64" target="_blank" class="ne-link"><span class="ne-text">https://github.com/yinguangyao/blog/issues/64</span></a></li></ul></div>]]></content>
      
      
      <categories>
          
          <category> 计算机素养 </category>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>axios发送请求报错：Cannot read property &#39;cancelToken&#39; of undefined</title>
      <link href="/blog/d75374fb-d238-4bcb-9146-e8b182b66752/"/>
      <url>/blog/d75374fb-d238-4bcb-9146-e8b182b66752/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="u4b1373b2" class="ne-p"><img src="https://img2020.cnblogs.com/blog/1269599/202005/1269599-20200520145553205-2092514210.png" width="955" id="qbL6v" class="ne-image"></p><p id="u2a5b580b" class="ne-p"><br></p><p id="u9ace7404" class="ne-p"><span class="ne-text">bug原因：在使用 axios 的拦截器时，没有添加返回值  return  config</span></p><p id="u0434ea32" class="ne-p"><span class="ne-text">解决方法：在请求拦截器中添加 return config，  （！！！注意响应拦截器中也要添加返回值）</span></p><p id="u273189db" class="ne-p"><br></p><p id="u89bc622e" class="ne-p"><img src="https://img2020.cnblogs.com/blog/1269599/202005/1269599-20200520145902689-569364923.png" width="738" id="kjLXK" class="ne-image"><span class="ne-text"></span></p></div>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
          <category> Bug </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>《华丽人生》原文摘录</title>
      <link href="/essay/algh82/"/>
      <url>/essay/algh82/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="ub1eee640" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1639824740044-5fc3d698-c9be-4993-ad8d-688ea9a6947d.png" width="1080" id="u8defc980" class="ne-image"></p><p id="u10b35ccf" class="ne-p"><span class="ne-text"></span></p><p id="uf0aec04d" class="ne-p"><span class="ne-text">我放弃抵抗人生。这世上有一股巨大的潮流，就算反抗那股潮流，终究还是会被推着走。如果能理解我们活着的背后有一股巨大的力量，那就没什么好怕的，也不需要逃避。就算我们自以为靠着自我压抑和选择过日子，其实也不过就是&quot;被迫活着&quot;而已，不是吗？” …… “是海洋啊。”黑泽耸耸肩说道，“人生是既没有路线也没有标志的茫茫大海啊。我们只是身在其中，紧紧抓住一条大鱼，委身于巨大的海流罢了</span></p></div>]]></content>
      
      
      <categories>
          
          <category> 阅读 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数组去重🔖JavaScript🔖数组</title>
      <link href="/blog/array-deduplication/"/>
      <url>/blog/array-deduplication/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="u5d074287" class="ne-p"><span class="ne-text">总结来看，去重分三种思路：</span></p><ul class="ne-ul"><li id="u17946e66"><span class="ne-text">es6的 Set 数据结构</span></li><li id="u6cded952"><span class="ne-text">Array的各类api</span></li><li id="u21d8c1a5"><span class="ne-text">利用对象的属性</span></li></ul><p id="u417f068d" class="ne-p"><span class="ne-text">文章参考：</span><a href="https://segmentfault.com/a/1190000016418021" data-href="https://segmentfault.com/a/1190000016418021" target="_blank" class="ne-link"><span class="ne-text">https://segmentfault.com/a/1190000016418021</span></a></p><h2 id="d03bbbd3"><span class="ne-text">一、利用 ES6 Set 去重（ES6 中最常用）</span></h2><p id="ud6962878" class="ne-p"><br></p><pre><code>arr_test = [0,0,999,999,'字符串','字符串',true,true,false,false,undefined,undefined,null,null,NaN,NaN,&#123;&#125;,&#123;&#125;,[],[],]<p>let unique_set = arr =&gt; &#123;<br>  return Array.from(new Set(arr))<br>&#125;</p><p>console.log(unique_set(arr_test))<br></code></pre></p><p id="u3bf4bff7" class="ne-p"><span class="ne-text">或者……</span></p><pre><code>console.log([...new Set(arr_test)])</code></pre><p id="u57699b53" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1651548685623-2a8e3fb9-2f10-4f98-bb4d-bede8276712f.png" width="232.49999076128043" id="u5b9461cf" class="ne-image"></p><div data-type="danger" class="ne-alert"><p id="u719146d8" class="ne-p"><span class="ne-text">去不掉</span></p><ul class="ne-ul"><li id="ua00300a4"><span class="ne-text">{}</span></li><li id="u8b5646db"><span class="ne-text">[]</span></li></ul></div><p id="u54caacdc" class="ne-p"><br></p><h2 id="d67f434e"><span class="ne-text">二、利用 for 嵌套 for，然后 splice 去重（ES5 中最常用）</span></h2><p id="u5aec723e" class="ne-p"><br></p><pre><code>arr_test = [0,0,999,999,'字符串','字符串',true,true,false,false,undefined,undefined,null,null,NaN,NaN,&#123;&#125;,&#123;&#125;,[],[],]<p>let unique_for_for_splice = arr =&gt; &#123;<br>  for (let i = 0; i &lt; arr.length; i++) &#123;<br>    for (let j = i + 1; j &lt; arr.length; j++) &#123;<br>      if (arr[i] === arr[j]) &#123;<br>        arr.splice(j, 1)<br>      &#125;<br>    &#125;<br>  &#125;<br>  return arr<br>&#125;<br>console.log(unique_for_for_splice(arr_test))<br></code></pre></p><p id="u9daeb974" class="ne-p"><br></p><p id="uc4605d05" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1651548810144-b36aa36d-87c9-4879-bd0a-12f3c4f55295.png" width="228.33332426018222" id="u8b1b4557" class="ne-image"></p><div data-type="danger" class="ne-alert"><p id="u250668ab" class="ne-p"><span class="ne-text">去不掉</span></p><ul class="ne-ul"><li id="uaf872f04"><span class="ne-text">NaN</span></li></ul><ul class="ne-ul"><li id="u2816b937"><span class="ne-text">{}</span></li><li id="u33792e49"><span class="ne-text">[]</span></li></ul></div><h2 id="f59a2b27"><span class="ne-text">三、利用 includes/indexOf 去重</span></h2><p id="ued10258d" class="ne-p"><br></p><pre><code>let unique_includes = arr =&gt; &#123;  let result = []  arr.forEach(data =&gt; &#123;    if (!result.includes(data)) result.push(data)  &#125;)  return result&#125;console.log(unique_includes(arr_test))</code></pre><pre><code>let unique_indexof = arr =&gt; &#123;  let result = []  arr.forEach(data =&gt; &#123;    if (result.indexOf(data) === -1) result.push(data)  &#125;)  return result&#125;console.log(unique_indexof(arr_test))</code></pre><p id="u0fa4d157" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1651549129756-b5675fd2-1851-4b74-923a-6bd90675fcd4.png" width="236.66665726237864" id="uda11904a" class="ne-image"></p><p id="ub4301d4e" class="ne-p"><br></p><h2 id="801e89a1"><span class="ne-text">四、利用 sort()</span></h2><p id="u7411e574" class="ne-p"><br></p><pre><code>let unique_sort = arr =&gt; &#123;  arr.sort().forEach((data, index) =&gt; &#123;    if (data === arr[index + 1] &amp;&amp; index &lt; arr.length - 1)      arr.splice(index + 1, 1)  &#125;)  return arr&#125;console.log(unique_indexof(arr_test))</code></pre><p id="u0fba8d32" class="ne-p"><br></p><p id="u7612ecf9" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1651549585258-df18b8b6-1a2f-4345-a7a2-db2635e84b13.png" width="284.1666553748983" id="u150d350e" class="ne-image"></p><h2 id="wP0wd"><span class="ne-text">五、利用 filter</span></h2><p id="u93c6e9db" class="ne-p"><br></p><pre><code>let unique_filter = arr =&gt; &#123;  return arr.filter((data, index, arr) =&gt; &#123;    return arr.indexOf(data, 0) === index;  &#125;)&#125;console.log(unique_filter(arr_test))</code></pre><p id="u1abe8c53" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1651550392520-a342d7c0-9102-49db-b672-3c70b887d258.png" width="296.66665487819296" id="nMX9A" class="ne-image"></p><h2 id="RfLwD"><span class="ne-text">六、利用 reduce</span></h2><p id="u587b9a1e" class="ne-p"><br></p><pre><code>let unique_reduce = arr =&gt; &#123;  return arr.reduce((a, b) =&gt; (a.includes(b) ? a : [...a, b]), [])&#125;console.log(unique_reduce(arr_test))</code></pre><p id="u918f047a" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1651550878738-7acdd3ef-54cd-4572-97e6-0e8c43b5719e.png" width="304.16665458016973" id="jhDy7" class="ne-image"></p><h2 id="f4fc8f4e"><span class="ne-text">利用对象的属性不能相同的特点进行去重（这种数组去重的方法有问题，不建议用，有待改进）</span></h2><p id="ua72da46c" class="ne-p"><br></p><pre><code>function unique(arr) &#123;    if (!Array.isArray(arr)) &#123;        console.log('type error!')        return    &#125;    var arrry= \[\];     var  obj = &#123;&#125;;    for (var i = 0; i &lt; arr.length; i++) &#123;        if (!obj\[arr\[i\]\]) &#123;            arrry.push(arr\[i\])            obj\[arr\[i\]\] = 1        &#125; else &#123;            obj\[arr\[i\]\]++        &#125;    &#125;    return arrry;&#125;    var arr = \[1,1,'true','true',true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,'NaN', 0, 0, 'a', 'a',&#123;&#125;,&#123;&#125;\];        console.log(unique(arr))//\[1, &quot;true&quot;, 15, false, undefined, null, NaN, 0, &quot;a&quot;, &#123;…&#125;\]    //两个true直接去掉了，NaN和&#123;&#125;去重</code></pre><p id="u2aa60d02" class="ne-p"><br></p><h2 id="65722c0d"><span class="ne-text">利用 hasOwnProperty</span></h2><p id="ufc660d37" class="ne-p"><br></p><pre><code>function unique(arr) &#123;    var obj = &#123;&#125;;    return arr.filter(function(item, index, arr)&#123;        return obj.hasOwnProperty(typeof item + item) ? false : (obj\[typeof item + item\] = true)    &#125;)&#125;    var arr = \[1,1,'true','true',true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,'NaN', 0, 0, 'a', 'a',&#123;&#125;,&#123;&#125;\];        console.log(unique(arr))//\[1, &quot;true&quot;, true, 15, false, undefined, null, NaN, &quot;NaN&quot;, 0, &quot;a&quot;, &#123;…&#125;\]   //所有的都去重了</code></pre><p id="u409ad723" class="ne-p"><br></p><p id="u5496097d" class="ne-p"><span class="ne-text">利用 hasOwnProperty 判断是否存在对象属性</span></p><p id="uf1ae4dc2" class="ne-p"><br></p><h2 id="37828459"></h2><h2 id="0d78e14f"><span class="ne-text">利用递归去重</span></h2><p id="u7ad84673" class="ne-p"><br></p><pre><code>function unique(arr) &#123;        var array\= arr;        var len = array.length;<pre><code>array.sort(function(a,b)&#123;   //排序后更加方便去重    return a - b;&#125;)function loop(index)&#123;    if(index &amp;gt;= 1)&#123;        if(array\[index\] === array\[index\-1\])&#123;            array.splice(index,1);        &#125;        loop(index - 1);    //递归loop，然后数组去重    &#125;&#125;loop(len\-1);return array;</code></pre><p>}<br> var arr = [1,1,’true’,’true’,true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,’NaN’, 0, 0, ‘a’, ‘a’,{},{}];<br>console.log(unique(arr))<br>//[1, &quot;a&quot;, &quot;true&quot;, true, 15, false, 1, {…}, null, NaN, NaN, &quot;NaN&quot;, 0, &quot;a&quot;, {…}, undefined]<br></code></pre></p><p id="uc875115e" class="ne-p"><br></p><h2 id="ad4d0c86"><span class="ne-text">利用 Map 数据结构去重</span></h2><p id="ud6cfc1de" class="ne-p"><br></p><pre><code>function arrayNonRepeatfy(arr) &#123;  let map = new Map();  let array = new Array();  // 数组用于返回结果  for (let i = 0; i &lt; arr.length; i++) &#123;    if(map .has(arr\[i\])) &#123;  // 如果有该key值      map .set(arr\[i\], true);     &#125; else &#123;       map .set(arr\[i\], false);   // 如果没有该key值      array .push(arr\[i\]);    &#125;  &#125;   return array ;&#125; var arr = \[1,1,'true','true',true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,'NaN', 0, 0, 'a', 'a',&#123;&#125;,&#123;&#125;\];    console.log(unique(arr))//\[1, &quot;a&quot;, &quot;true&quot;, true, 15, false, 1, &#123;…&#125;, null, NaN, NaN, &quot;NaN&quot;, 0, &quot;a&quot;, &#123;…&#125;, undefined\]</code></pre><p id="u698485f0" class="ne-p"><br></p><p id="ude7ca7ea" class="ne-p"><span class="ne-text">创建一个空 Map 数据结构，遍历需要去重的数组，把数组的每一个元素作为 key 存到 Map 中。由于 Map 中不会出现相同的 key 值，所以最终得到的就是去重后的结果。</span></p><p id="u3373844e" class="ne-p"><br></p><h2 id="b21c06bc"></h2><p id="ubcc0d98a" class="ne-p"><br></p><p id="ud9f30771" class="ne-p"><span class="ne-text">PS：有些文章提到了 foreach+indexOf 数组去重的方法，个人觉得都是大同小异，所以没有写上去。<br /></span></p></div>]]></content>
      
      
      <categories>
          
          <category> 计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 📶线结构：字符串-数组-栈-队列 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>跨域以及非跨域下载指定url图片方案</title>
      <link href="/blog/na8588/"/>
      <url>/blog/na8588/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h2 id="XXVKm"><span class="ne-text">非跨域url图片转base64</span></h2><ul class="ne-ul"><li id="u06aed2dc" data-lake-index-type="0"><span class="ne-text">条件：合法图片url、图片不存在跨域等限制</span></li><li id="u736fbb32" data-lake-index-type="0"><span class="ne-text">流程：转base64 -&gt; 在进行canvas绘制 -&gt; 模拟点击事件触发下载图片文件</span></li></ul><pre><code>downloadImg(imgsrc, name) &#123;  var image = new Image()  // 解决跨域 Canvas 污染问题  image.setAttribute('crossOrigin', 'anonymous')  image.onload = function() &#123;    var canvas = document.createElement('canvas')    canvas.width = image.width    canvas.height = image.height    var context = canvas.getContext('2d')    context.drawImage(image, 0, 0, image.width, image.height)    var url = canvas.toDataURL() //得到图片的base64编码数据    var a = document.createElement('a') // 生成一个a元素    var event = new MouseEvent('click') // 创建一个单击事件    a.download = name || 'photo' // 设置图片名称    a.href = url // 将生成的URL设置为a.href属性    a.dispatchEvent(event) // 触发a的单击事件  &#125;  image.src = imgsrc&#125;</code></pre><h2 id="ndbyD"><span class="ne-text">利用三方库superagent处理防盗链图片方法</span></h2><ul class="ne-ul"><li id="u24e24ead" data-lake-index-type="0"><span class="ne-text">条件：合法图片url、三方库</span><code class="ne-code"><a href="https://github.com/ladjs/superagent" data-href="https://github.com/ladjs/superagent" target="_blank" class="ne-link"><span class="ne-text">superagent</span></a></code></li><li id="u1075afdd" data-lake-index-type="0"><span class="ne-text">流程：请求图片url -&gt; 转buffer -&gt; 转图片文件</span></li></ul><pre><code>const superagent = require(&quot;superagent&quot;);const fs = require(&quot;fs&quot;);<p>/**</p><ul><li>将图片转成buffer</li><li></li><li>@param &#123;string&#125; imgUrl 图片url</li><li>@return &#123;Promise&lt;Buffer&gt;&#125; 文件buffer</li><li>/<br>async function imgUrlToBuffer(imgUrl) &#123;<br>const urlInfo = imgUrl.split(&quot;/&quot;);<br>const fileName = urlInfo[urlInfo.length - 1];<br>return await new Promise(async function (resolve) &#123;<br>  try &#123;<pre><code>await superagent  .get(imgUrl)  .set(&amp;quot;User-Agent&amp;quot;, &amp;quot;Mozilla/5.0&amp;quot;)  .buffer(true)  .parse((res) =&amp;gt; &#123;    const buffer = [];    res.on(&amp;quot;data&amp;quot;, (chunk) =&amp;gt; &#123;      buffer.push(chunk);    &#125;);    res.on(&amp;quot;end&amp;quot;, () =&amp;gt; &#123;      const data = Buffer.concat(buffer);      // buffer转为图片文件      fs.writeFile(`./dist/$&#123;fileName&#125;`, data, function (err) &#123;        if (err) &#123;          console.log(&amp;quot;buffer -&amp;gt; jpg error: &amp;quot;, err);        &#125;      &#125;);      resolve(data);    &#125;);  &#125;);</code></pre>  } catch (e) {<pre><code>console.log(`invalid img: $&#123;imgUrl&#125;`);resolve(null);</code></pre>  }<br>});<br>}<br></code></pre></div></li></ul>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
          <category> 前端业务解决方案 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Vue3对比Vue2几种组件通信方式总结</title>
      <link href="/blog/qwv5oz/"/>
      <url>/blog/qwv5oz/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><div data-type="info" class="ne-alert"><p id="ucc0fb243" class="ne-p" style="text-align: center"><span class="ne-text">本文转载自：</span><a href="https://juejin.cn/post/6844903887162310669" data-href="https://juejin.cn/post/6844903887162310669" class="ne-link"><span class="ne-text">vue中8种组件通信方式, 值得收藏! - 掘金</span></a></p><p id="uc7462431" class="ne-p" style="text-align: center"><span class="ne-text">（部分内容自行添加/修改）</span></p></div><p id="804b58e6d41ad7fb2480630c3092516e_p_3" class="ne-p"><br></p><p id="497144d8506882a2db679d679af2acea_p_4" class="ne-p"><span class="ne-text">vue 是数据驱动视图更新的框架, 所以对于 vue 来说组件间的数据通信非常重要，那么组件之间如何进行数据通信的呢？ 首先我们需要知道在 vue 中组件之间存在什么样的关系, 才更容易理解他们的通信方式, 就好像过年回家，坐着一屋子的陌生人，相互之间怎么称呼，这时就需要先知道自己和他们之间是什么样的关系。 vue 组件中关系说明:</span></p><p id="9b32206ce2e4698409fa9b6e702ab5dc_p_6" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2021/webp/1484158/1635399234264-ec4a46fa-6e27-4efb-922f-871b5ef8719c.webp" width="462" id="ubbf5437a" class="ne-image"></p><p id="e1b0979b54c1fb29acc1d92ad2159922_p_7" class="ne-p"><br></p><p id="277ac1b9a01a26e550f334d2d650a2af_p_8" class="ne-p"><span class="ne-text">如上图所示, A 与 B、A 与 C、B 与 D、C 与 E 组件之间是父子关系； B 与 C 之间是兄弟关系；A 与 D、A 与 E 之间是隔代关系； D 与 E 是堂兄关系（非直系亲属） 针对以上关系我们归类为：</span></p><p id="eadc4ec477465f1f239730d987d394b1_p_9" class="ne-p"><br></p><ul class="ne-ul"><li id="e921ea6da6315ea6a03b83b1fbdb45ce_li_0"><span class="ne-text">父子组件之间通信</span></li></ul><ul class="ne-ul"><li id="afaa832eef1dad88d3692c9ee7c0cb23_li_1"><span class="ne-text">非父子组件之间通信 (兄弟组件、隔代关系组件等)</span></li></ul><p id="042da541aac17f869693ba89ebd10d8e_p_10" class="ne-p"><br></p><p id="95350d3f636bad4a4fd5424d38f13bf2_p_11" class="ne-p"><span class="ne-text">本文会介绍组件间通信的 8 种方式如下图目录所示: 并介绍在不同的场景下如何选择有效方式实现的组件间通信方式，希望可以帮助小伙伴们更好理解组件间的通信。</span></p><p id="09a2b5671cf447a1a3529d71c89cf9e1_p_12" class="ne-p"><br></p><p id="2845b5316b00b43029a07a2ab35a1d57_p_13" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2021/webp/1484158/1635399242725-f019c2ac-ea0b-48d2-81c1-fa4f80211155.webp" width="499" id="u2d5076b9" class="ne-image"></p><p id="7cf79ceeaaf91ef14264b4c55c1c8c1d_p_14" class="ne-p"><br></p><h2 id="aokck"><span class="ne-text">一、</span><code class="ne-code"><span class="ne-text">props</span></code><span class="ne-text"> / </span><code class="ne-code"><span class="ne-text">$emit</span></code></h2><p id="c53070088aadb43ef468f61fca8ca22a_p_15" class="ne-p"><br></p><p id="aefd39de20827e7fa178830efd84d682_p_16" class="ne-p"><span class="ne-text">父组件通过</span><code class="ne-code"><span class="ne-text">props</span></code><span class="ne-text">的方式向子组件传递数据，而通过</span><code class="ne-code"><span class="ne-text">$emit</span></code><span class="ne-text"> 子组件可以向父组件通信。</span></p><h3 id="erDJy"><span class="ne-text">vue2</span></h3><h4 id="0695b088"><span class="ne-text">1. 父组件向子组件传值</span></h4><p id="3f8949dd5527f0c9624c3fd3faefb76f_p_18" class="ne-p"><br></p><p id="0a6e4fcd704856005fdf95a5090e6575_p_19" class="ne-p"><span class="ne-text">下面通过一个例子说明父组件如何向子组件传递数据：在子组件</span><code class="ne-code"><span class="ne-text">article.vue</span></code><span class="ne-text">中如何获取父组件</span><code class="ne-code"><span class="ne-text">section.vue</span></code><span class="ne-text">中的数据</span><code class="ne-code"><span class="ne-text">articles:['红楼梦', '西游记','三国演义']</span></code></p><p id="db841a6e995b001085603629a3ace379_p_20" class="ne-p"><br></p><pre><code>// section父组件&lt;template&gt;  &lt;div class=&quot;section&quot;&gt;    &lt;com-article :articles=&quot;articleList&quot;&gt;&lt;/com-article&gt;  &lt;/div&gt;&lt;/template&gt;<p>&lt;script&gt;<br>import comArticle from ‘./test/article.vue’<br>export default &#123;<br>  name: ‘HelloWorld’,<br>  components: &#123; comArticle &#125;,<br>  data() &#123;<br>    return &#123;<br>      articleList: [‘红楼梦’, ‘西游记’, ‘三国演义’]<br>    &#125;<br>  &#125;<br>&#125;<br>&lt;/script&gt;<br></code></pre></p><pre><code>// 子组件 article.vue&lt;template&gt;  &lt;div&gt;    &lt;span v-for=&quot;(item, index) in articles&quot; :key=&quot;index&quot;&gt;&#123;&#123;item&#125;&#125;&lt;/span&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  props: ['articles']&#125;&lt;/script&gt;</code></pre><p id="u3858a5f2" class="ne-p"><br></p><div class="ne-quote"><p id="85be3e4d88c775ffac9191a0916bdfa5_p_22" class="ne-p"><span class="ne-text">总结: prop 只可以从上一级组件传递到下一级组件（父子组件），即所谓的单向数据流。而且 prop 只读，不可被修改，所有修改都会失效并警告。</span></p></div><p id="4547a4b65fb57fca5301c6973643450c_p_23" class="ne-p"><br></p><h4 id="16b04c6a"><span class="ne-text">2. 子组件向父组件传值</span></h4><p id="1f3b4b4a4867a8b756c196b38558d0c4_p_24" class="ne-p"><br></p><p id="434c1d7d47824a48e59b3b09d32b26c5_p_25" class="ne-p"><span class="ne-text">对于</span><code class="ne-code"><span class="ne-text">$emit</span></code><span class="ne-text"> 我自己的理解是这样的: </span><code class="ne-code"><span class="ne-text">$emit</span></code><span class="ne-text">绑定一个自定义事件, 当这个语句被执行时, 就会将参数 arg 传递给父组件, 父组件通过 v-on 监听并接收参数。 通过一个例子，说明子组件如何向父组件传递数据。 在上个例子的基础上, 点击页面渲染出来的</span><code class="ne-code"><span class="ne-text">ariticle</span></code><span class="ne-text">的</span><code class="ne-code"><span class="ne-text">item</span></code><span class="ne-text">, 父组件中显示在数组中的下标</span></p><p id="b57de0a6a045efefe71d109094be9ddc_p_26" class="ne-p"><br></p><pre><code>// 父组件&lt;template&gt;  &lt;div class=&quot;section&quot;&gt;    &lt;com-article :articles=&quot;articleList&quot; @onEmitIndex=&quot;onEmitIndex&quot;&gt;&lt;/com-article&gt;    &lt;p&gt;&#123;&#123;currentIndex&#125;&#125;&lt;/p&gt;  &lt;/div&gt;&lt;/template&gt;<p>&lt;script&gt;<br>import comArticle from ‘./test/article.vue’<br>export default &#123;<br>  name: ‘HelloWorld’,<br>  components: &#123; comArticle &#125;,<br>  data() &#123;<br>    return &#123;<br>      currentIndex: -1,<br>      articleList: [‘红楼梦’, ‘西游记’, ‘三国演义’]<br>    &#125;<br>  &#125;,<br>  methods: &#123;<br>    onEmitIndex(idx) &#123;<br>      this.currentIndex = idx<br>    &#125;<br>  &#125;<br>&#125;<br>&lt;/script&gt;<br></code></pre></p><pre><code>// 子组件&lt;template&gt;  &lt;div&gt;    &lt;div v-for=&quot;(item, index) in articles&quot; :key=&quot;index&quot; @click=&quot;emitIndex(index)&quot;&gt;&#123;&#123;item&#125;&#125;&lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  props: ['articles'],  methods: &#123;    emitIndex(index) &#123;      this.$emit('onEmitIndex', index)    &#125;  &#125;&#125;&lt;/script&gt;</code></pre><h3 id="B7Xr9"><span class="ne-text">vue3</span></h3><h4 id="MIVx6"><span class="ne-text">父组件使用子组件方法</span></h4><p id="u5c98065f" class="ne-p"><span class="ne-text">子组件中：</span></p><p id="u77189cae" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1660894949430-ba1829bd-2001-4409-8c5a-d871feb4e07b.png" width="642" id="u0f0c93f6" class="ne-image"></p><p id="u8caa8f0f" class="ne-p"><span class="ne-text">父组件中：</span></p><p id="u8c24c3cc" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1660894970901-7604b713-71c3-453b-8744-245337da8e2b.png" width="742" id="u71458f7b" class="ne-image"></p><p id="uf4bd113e" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1660894987922-550b8a82-3f32-4b51-a760-ecadfc91bcbb.png" width="421" id="u7b9262a6" class="ne-image"></p><p id="u14c7a9dc" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1660895002286-18a4fb67-cb55-45c0-a3a5-f1f95f1a7d5c.png" width="648" id="ue776a999" class="ne-image"></p><h4 id="X50gB"><span class="ne-text">子组件使用父组件方法</span></h4><p id="u6f59878b" class="ne-p"><span class="ne-text">父组件</span></p><p id="ub5f76767" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1661149948014-41b17b1e-8c6c-46af-a9b1-a327ad4d2be6.png" width="733" id="u2915e955" class="ne-image"></p><p id="uc68de4ec" class="ne-p"><span class="ne-text">子组件</span></p><p id="u9acc0831" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1661149976565-2e690cd0-1303-465f-bc26-5361a080ba00.png" width="730" id="u35b6bd99" class="ne-image"></p><h4 id="rWS9U"><span class="ne-text">defineProps defineEmits defineExpose</span></h4><pre><code>&lt;template&gt;    &lt;h3&gt;父组件&lt;/h3&gt;    &lt;SonTemplate :father_variable='father_variable' @fatherToSonFun=&quot;fatherToSonFun&quot; ref=&quot;son&quot; /&gt;    &lt;span&gt;父组件 wait_son_value is : &#123;&#123;wait_son_value&#125;&#125;&lt;/span&gt;&lt;hr /&gt;    &lt;button @click=&quot;clickGetSonTemplateValue&quot;&gt;点击之后会获得子组件的son_val变量的值: &lt;/button&gt;&#123;&#123;value_form_son&#125;&#125;&lt;hr /&gt;&lt;/template&gt;<p>&lt;script setup lang=&quot;ts&quot;&gt;<br>import &#123;ref&#125; from ‘vue’<br>import SonTemplate from ‘./SonTemplate.vue’</p><p>// [defineProps]<br>const father_variable = ref(‘variable from father template!’)</p><p>// [defineEmits]<br>const wait_son_value=ref(‘父组件原本的值’)<br>const fatherToSonFun = (val: string) =&gt; &#123;<br>    wait_son_value.value = val<br>&#125;<br>// [ref defineExpose]<br>const son = ref()<br>const value_form_son = ref()<br>const clickGetSonTemplateValue = () =&gt; &#123;<br>    value_form_son.value = son.value.son_val<br>&#125;<br>&lt;/script&gt;<br></code></pre></p><pre><code>&lt;template&gt;    &lt;h3&gt;子组件&lt;/h3&gt;    &lt;span&gt;父组件传来的值：&lt;/span&gt;&#123;&#123;props.father_variable&#125;&#125;&lt;hr/&gt;    &lt;button @click=&quot;clickEvent&quot;&gt;点击之后会改变父组件里面的wait_son_value的值&lt;/button&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot;&gt;import &#123;ref&#125; from 'vue'// [defineProps]const props = defineProps(&#123;  father_variable: &#123;      type: String,      default: () =&gt; 'default_value'    &#125;&#125;) // [defineEmits]const son_val = ref('子组件传来的值')const emit = defineEmits(['fatherToSonFun'])const clickEvent = () =&gt; &#123;  emit('fatherToSonFun', son_val)&#125;// [ref defineExpose]defineExpose(&#123;  son_val&#125;)&lt;/script&gt;</code></pre><ul class="ne-ul"><li id="u77f134f8"><span class="ne-text">父传子组件的props里面的变量失去响应式，解决办法</span></li></ul><pre><code>&lt;script setup lang=&quot;ts&quot;&gt;  import &#123; watch &#125; from 'vue';  const props = defineProps(&#123;    menuList: &#123;      type: Array,      default: () =&gt; []    &#125;  &#125;);<p>  watch(<br>    () =&gt; […props.menuList],<br>    (numbers, prevNumbers) =&gt; &#123;<br>      // console.log(‘numbers新值’, numbers);<br>      // console.log(‘numbers旧值’, prevNumbers);<br>      console.log(‘____________’, props.menuList.length);<br>    &#125;<br>  );<br>&lt;/script&gt;<br></code></pre></p><h2 id="jjpSa"><span class="ne-text">二、 </span><code class="ne-code"><span class="ne-text">$children</span></code><span class="ne-text"> / </span><code class="ne-code"><span class="ne-text">$parent</span></code></h2><p id="d17d837b16c49a0e5c21edc18722e410_p_28" class="ne-p"><br></p><p id="cdd59d689a9a129b64c13b91ec6fb344_p_29" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/webp/1484158/1635399257895-523f1b19-b58a-42bf-9649-abebf7694ef2.webp" width="642" id="u4267112c" class="ne-image"></p><p id="d657ac1e4c3211af4f7dcea889518735_p_30" class="ne-p"><br></p><p id="a53b13677e55fdbc670902cf2d24e401_p_31" class="ne-p"><span class="ne-text">上面这张图片是</span><code class="ne-code"><span class="ne-text">vue</span></code><span class="ne-text">官方的解释，通过</span><code class="ne-code"><span class="ne-text">$parent</span></code><span class="ne-text">和</span><code class="ne-code"><span class="ne-text">$children</span></code><span class="ne-text">就可以访问组件的实例，拿到实例代表什么？代表可以访问此组件的所有方法和</span><code class="ne-code"><span class="ne-text">data</span></code><span class="ne-text">。接下来就是怎么实现拿到指定组件的实例。</span></p><p id="bb3e20f1faeaf6bf9497bffd7f381295_p_32" class="ne-p"><br></p><h4 id="ec09647d"><span class="ne-text">使用方法</span></h4><p id="73b74e66f7d869f94eb34b57d63eae3f_p_33" class="ne-p"><br></p><pre><code>// 父组件中&lt;template&gt;  &lt;div class=&quot;hello_world&quot;&gt;    &lt;div&gt;&#123;&#123;msg&#125;&#125;&lt;/div&gt;    &lt;com-a&gt;&lt;/com-a&gt;    &lt;button @click=&quot;changeA&quot;&gt;点击改变子组件值&lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;<p>&lt;script&gt;<br>import ComA from ‘./test/comA.vue’<br>export default &#123;<br>  name: ‘HelloWorld’,<br>  components: &#123; ComA &#125;,<br>  data() &#123;<br>    return &#123;<br>      msg: ‘Welcome’<br>    &#125;<br>  &#125;,</p><p>  methods: &#123;<br>    changeA() &#123;<br>      // 获取到子组件A<br>      this.$children[0].messageA = ‘this is new value’<br>    &#125;<br>  &#125;<br>&#125;<br>&lt;/script&gt;<br></code></pre></p><pre><code>// 子组件中&lt;template&gt;  &lt;div class=&quot;com_a&quot;&gt;    &lt;span&gt;&#123;&#123;messageA&#125;&#125;&lt;/span&gt;    &lt;p&gt;获取父组件的值为:  &#123;&#123;parentVal&#125;&#125;&lt;/p&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  data() &#123;    return &#123;      messageA: 'this is old'    &#125;  &#125;,  computed:&#123;    parentVal()&#123;      return this.$parent.msg;    &#125;  &#125;&#125;&lt;/script&gt;</code></pre><div class="ne-quote"><p id="baca8b35b9df69242628141ffca869a0_p_35" class="ne-p"><span class="ne-text">要注意边界情况，如在</span><code class="ne-code"><span class="ne-text">#app</span></code><span class="ne-text">上拿</span><code class="ne-code"><span class="ne-text">$parent</span></code><span class="ne-text">得到的是</span><code class="ne-code"><span class="ne-text">new Vue()</span></code><span class="ne-text">的实例，在这实例上再拿</span><code class="ne-code"><span class="ne-text">$parent</span></code><span class="ne-text">得到的是</span><code class="ne-code"><span class="ne-text">undefined</span></code><span class="ne-text">，而在最底层的子组件拿</span><code class="ne-code"><span class="ne-text">$children</span></code><span class="ne-text">是个空数组。也要注意得到</span><code class="ne-code"><span class="ne-text">$parent</span></code><span class="ne-text">和</span><code class="ne-code"><span class="ne-text">$children</span></code><span class="ne-text">的值不一样，</span><code class="ne-code"><span class="ne-text">$children</span></code><span class="ne-text"> 的值是数组，而</span><code class="ne-code"><span class="ne-text">$parent</span></code><span class="ne-text">是个对象</span></p></div><p id="6f8f966688575a1f666bafa122494f73_p_36" class="ne-p"><br></p><h4 id="25f9c7fa"><span class="ne-text">总结</span></h4><p id="ab57135091a86c42cc63ec67ac068a45_p_37" class="ne-p"><br></p><p id="c9f98fb68f54448a9f9adec409bc4cbe_p_38" class="ne-p"><span class="ne-text">上面两种方式用于父子组件之间的通信， 而使用 props 进行父子组件通信更加普遍; 二者皆不能用于非父子组件之间的通信。</span></p><p id="faade82d6cfe8ed09f505bc5d9204fda_p_39" class="ne-p"><br></p><h2 id="xvUaQ"><span class="ne-text">三、</span><code class="ne-code"><span class="ne-text">provide</span></code><span class="ne-text">/ </span><code class="ne-code"><span class="ne-text">inject</span></code></h2><p id="17b412f9fc3ec51ada5f566f0d09108c_p_40" class="ne-p"><br></p><h4 id="6213df69"><span class="ne-text">概念:</span></h4><p id="d9d31f80b21bee6005ee4bb0be1d9a6b_p_41" class="ne-p"><br></p><p id="1a0cc332e9c0eec97da9ef6fd3dc9b58_p_42" class="ne-p"><code class="ne-code"><span class="ne-text">provide</span></code><span class="ne-text">/ </span><code class="ne-code"><span class="ne-text">inject</span></code><span class="ne-text"> 是</span><code class="ne-code"><span class="ne-text">vue2.2.0</span></code><span class="ne-text">新增的 api, 简单来说就是父组件中通过</span><code class="ne-code"><span class="ne-text">provide</span></code><span class="ne-text">来提供变量, 然后再子组件中通过</span><code class="ne-code"><span class="ne-text">inject</span></code><span class="ne-text">来注入变量。</span></p><p id="4930f2b57b08d977b4a7a79433f23490_p_43" class="ne-p"><br></p><div class="ne-quote"><p id="6071f021259eae15a0d98d5f11dbac4b_p_44" class="ne-p"><span class="ne-text">注意: 这里不论子组件嵌套有多深, 只要调用了</span><code class="ne-code"><span class="ne-text">inject</span></code><span class="ne-text"> 那么就可以注入</span><code class="ne-code"><span class="ne-text">provide</span></code><span class="ne-text">中的数据，而不局限于只能从当前父组件的 props 属性中回去数据</span></p></div><p id="0e4b859961c17882302ca1144adad96d_p_45" class="ne-p"><br></p><h4 id="dcf3dc0b"><span class="ne-text">举例验证</span></h4><p id="e81b6efc8e2153cf8aa53e3b04d7f22c_p_46" class="ne-p"><br></p><p id="7c7f50d376751d2fe628d85ee09618ef_p_47" class="ne-p"><span class="ne-text">接下来就用一个例子来验证上面的描述: 假设有三个组件: A.vue、B.vue、C.vue 其中 C 是 B 的子组件，B 是 A 的子组件</span></p><p id="aa95668f5a65b03373d1b0b3f9f8d3a6_p_48" class="ne-p"><br></p><pre><code>// A.vue<p>&lt;template&gt;<br>  &lt;div&gt;<br>    &lt;comB&gt;&lt;/comB&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;</p><p>&lt;script&gt;<br>  import comB from ‘../components/test/comB.vue’<br>  export default &#123;<br>    name: &quot;A&quot;,<br>    provide: &#123;<br>      for: &quot;demo&quot;<br>    &#125;,<br>    components:&#123;<br>      comB<br>    &#125;<br>  &#125;<br>&lt;/script&gt;<br></code></pre></p><pre><code>// B.vue&lt;template&gt;  &lt;div&gt;    &#123;&#123;demo&#125;&#125;    &lt;comC&gt;&lt;/comC&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;  import comC from '../components/test/comC.vue'  export default &#123;    name: &quot;B&quot;,    inject: ['for'],    data() &#123;      return &#123;        demo: this.for      &#125;    &#125;,    components: &#123;      comC    &#125;  &#125;&lt;/script&gt;</code></pre><pre><code>// C.vue&lt;template&gt;  &lt;div&gt;    &#123;&#123;demo&#125;&#125;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;  export default &#123;    name: &quot;C&quot;,    inject: ['for'],    data() &#123;      return &#123;        demo: this.for      &#125;    &#125;  &#125;&lt;/script&gt;</code></pre><h2 id="ZNDHX"><span class="ne-text">四、</span><code class="ne-code"><span class="ne-text">ref</span></code><span class="ne-text"> / </span><code class="ne-code"><span class="ne-text">refs</span></code></h2><h4 id="YzKrJ"><span class="ne-text">基本使用</span></h4><p id="1072ea36c24eecae31028b57db98b711_p_51" class="ne-p"><code class="ne-code"><span class="ne-text">ref</span></code><span class="ne-text">：如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素；如果用在子组件上，引用就指向组件实例，可以通过实例直接调用组件的方法或访问数据， 我们看一个</span><code class="ne-code"><span class="ne-text">ref</span></code><span class="ne-text"> 来访问组件的例子:</span></p><pre><code>// 父组件 app.vue<p>&lt;template&gt;<br>  &lt;component-a ref=&quot;comA&quot;&gt;&lt;/component-a&gt;<br>&lt;/template&gt;<br>&lt;script&gt;<br>  export default &#123;<br>    mounted () &#123;<br>      const comA = this.$refs.comA;<br>      console.log(comA.name);  // Vue.js<br>      comA.sayHello();  // hello<br>    &#125;<br>  &#125;<br>&lt;/script&gt;<br></code></pre></p><p id="bc2359f7bb1e32241fa27f528e60a125_p_52" class="ne-p"><br></p><pre><code>// 子组件 A.vue<p>export default &#123;<br>  data () &#123;<br>    return &#123;<br>      name: ‘Vue.js’<br>    &#125;<br>  &#125;,<br>  methods: &#123;<br>    sayHello () &#123;<br>      console.log(‘hello’)<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></p><h4 id="Cz2f0"><span class="ne-text">和v-for共使用</span></h4><p id="u22aa1746" class="ne-p"><span class="ne-text">遇到过这个场景，在主组件里面需要多次渲染子组件</span></p><pre><code>      &lt;!-- 直播绑定 --&gt;      &lt;div slot=&quot;liveBind&quot;&gt;        &lt;AddLiveBindItem          v-for=&quot;(data, index) in datas&quot;          :key=&quot;data.id&quot;          :dataConfig=&quot;data.dataConfig&quot;          :isFirst=&quot;index === 0 ? true : false&quot;          :liveBindId=&quot;            index === 0              ? 1              : index === 1              ? 2              : index === 2              ? 3              : index === 3              ? 4              : index === 4              ? 5              : 6          &quot;          @toDeleteLiveBind=&quot;toDeleteLiveBind(index)&quot;          ref=&quot;addLiveBindRef&quot;        /&gt;      &lt;/div&gt;</code></pre><p id="uae784a6c" class="ne-p"><span class="ne-text">具体使用：下面第四行代码</span></p><pre><code>      this.datas.forEach((_it, index) =&gt; &#123;        // 当前表单的配置项遍历上传        liveRelationList.push(          this.$refs.addLiveBindRef[index].liveBindApiParams        )        // 上传sort参数        liveRelationList[liveRelationList.length - 1].sort = _it.id      &#125;)<p></code></pre></p><h4 id="zUA4Q"><span class="ne-text">其他理解</span></h4><ul class="ne-ul"><li id="u54e5a1b7"><span class="ne-text">v-for 用于元素或组件时,引用信息将是</span><strong><span class="ne-text">包含 DOM 节点或组件实例的数组，</span></strong><span class="ne-text">按照这个理解，可以直接利用$refs来获取dom元素</span></li></ul><pre><code>this.$refs.addAlert.style.display = &quot;block&quot;;</code></pre><p id="u209130bb" class="ne-p"><strong><span class="ne-text">$refs只会在组件渲染完成之后生效，并且它们不是响应式的。这仅作为一个用于直接操作子组件的“逃生舱”——你应该避免在模板或计算属性中访问$refs。这是官方说法，提倡props来操作，缺点就是非响应式的</span></strong></p><p id="ub56bb401" class="ne-p"><span class="ne-text"></span></p><p id="u567fd29b" class="ne-p"><strong><span class="ne-text">ref 本身是作为渲染结果被创建的，在初始渲染的时候你不能访问它们 - 它们还不存在！$refs 也不是响应式的，因此你不应该试图用它在模板中做数据绑定。</span></strong></p><h2 id="fSF87"><span class="ne-text">五、eventBus</span></h2><p id="e10b5c78ee7ba45f407740af88433fc9_p_54" class="ne-p"><br></p><p id="6a46758b0a566ff1d337ce36227f583e_p_55" class="ne-p"><code class="ne-code"><span class="ne-text">eventBus</span></code><span class="ne-text"> 又称为事件总线，在 vue 中可以使用它来作为沟通桥梁的概念, 就像是所有组件共用相同的事件中心，可以向该中心</span><strong><span class="ne-text">注册发送事件</span></strong><span class="ne-text">或</span><strong><span class="ne-text">接收事件</span></strong><span class="ne-text">， 所以</span><strong><span class="ne-text">组件都可以通知其他组件</span></strong><span class="ne-text">。</span></p><p id="a6e7204180aba568d27cc7b95d0717fd_p_56" class="ne-p"><br></p><div class="ne-quote"><p id="9973944624be5f0aade0adc966299174_p_57" class="ne-p"><span class="ne-text">eventBus 也有不方便之处, 当项目较大, 就容易造成难以维护的灾难</span></p></div><p id="e3c9bad72638009a374744280c63ecc6_p_58" class="ne-p"><br></p><p id="3085c6811d84ca25944e7aab016ae59b_p_59" class="ne-p"><span class="ne-text">在 Vue 的项目中怎么使用</span><code class="ne-code"><span class="ne-text">eventBus</span></code><span class="ne-text">来实现组件之间的数据通信呢? 具体通过下面几个步骤</span></p><p id="daa3e859dfee1b8825cb9c219dcb2526_p_60" class="ne-p"><br></p><h4 id="824f2b2d"><span class="ne-text">1. 初始化</span></h4><p id="d89d8c6a729313c0d25f9b1742c0d590_p_61" class="ne-p"><br></p><p id="ae2699b2afa224478e7e6cc93d0dda54_p_62" class="ne-p"><span class="ne-text">首先需要创建一个事件总线并将其导出, 以便其他模块可以使用或者监听它.</span></p><p id="87e34965e50e2c8e31ce44a85667e8dd_p_63" class="ne-p"><br></p><pre><code>// event-bus.js<p>import Vue from ‘vue’<br>export const EventBus = new Vue()<br></code></pre></p><p id="b3add770127d8c2a5064673aa8a9731f_p_64" class="ne-p"><br></p><p id="2a81d6eed31dfd1dc3c193bbdb75c1a1_p_65" class="ne-p"><br></p><p id="98de67513ec537a79ef3aa695ade51aa_p_66" class="ne-p"><span class="ne-text">假设你有两个组件: </span><code class="ne-code"><span class="ne-text">additionNum</span></code><span class="ne-text"> 和 </span><code class="ne-code"><span class="ne-text">showNum</span></code><span class="ne-text">, 这两个组件可以是兄弟组件也可以是父子组件；这里我们以兄弟组件为例:</span></p><p id="152302cc03cd3433e252fd8fbe4bade7_p_67" class="ne-p"><br></p><pre><code>&lt;template&gt;  &lt;div&gt;    &lt;show-num-com&gt;&lt;/show-num-com&gt;    &lt;addition-num-com&gt;&lt;/addition-num-com&gt;  &lt;/div&gt;&lt;/template&gt;<p>&lt;script&gt;<br>import showNumCom from ‘./showNum.vue’<br>import additionNumCom from ‘./additionNum.vue’<br>export default &#123;<br>  components: &#123; showNumCom, additionNumCom &#125;<br>&#125;<br>&lt;/script&gt;</p><p></code></pre></p><h4 id="gt0jW"><span class="ne-text">2. 发送事件</span></h4><pre><code>// addtionNum.vue 中发送事件<p>&lt;template&gt;<br>  &lt;div&gt;<br>    &lt;button @click=&quot;additionHandle&quot;&gt;+加法器&lt;/button&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;</p><p>&lt;script&gt;<br>import &#123;EventBus&#125; from ‘./event-bus.js’<br>console.log(EventBus)<br>export default &#123;<br>  data()&#123;<br>    return&#123;<br>      num:1<br>    &#125;<br>  &#125;,</p><p>  methods:&#123;<br>    additionHandle()&#123;<br>      EventBus.$emit(‘addition’, &#123;<br>        num:this.num++<br>      &#125;)<br>    &#125;<br>  &#125;<br>&#125;<br>&lt;/script&gt;<br></code></pre></p><h4 id="8ef9023b"><span class="ne-text">3. 接收事件</span></h4><p id="956e0d4312e941b77cd57ec35c294aff_p_69" class="ne-p"><br></p><pre><code>// showNum.vue 中接收事件<p>&lt;template&gt;<br>  &lt;div&gt;计算和: &#123;&#123;count&#125;&#125;&lt;/div&gt;<br>&lt;/template&gt;</p><p>&lt;script&gt;<br>import &#123; EventBus &#125; from ‘./event-bus.js’<br>export default &#123;<br>  data() &#123;<br>    return &#123;<br>      count: 0<br>    &#125;<br>  &#125;,</p><p>  mounted() &#123;<br>    EventBus.$on(‘addition’, param =&gt; &#123;<br>      this.count = this.count + param.num;<br>    &#125;)<br>  &#125;<br>&#125;<br>&lt;/script&gt;<br></code></pre></p><p id="67523e0fa28fe87849ce38cd391e3347_p_70" class="ne-p"><br></p><p id="854f22ccbc720f4f25f3f1e4fbae5cf0_p_71" class="ne-p"><span class="ne-text">这样就实现了在组件</span><code class="ne-code"><span class="ne-text">addtionNum.vue</span></code><span class="ne-text">中点击相加按钮, 在</span><code class="ne-code"><span class="ne-text">showNum.vue</span></code><span class="ne-text">中利用传递来的 </span><code class="ne-code"><span class="ne-text">num</span></code><span class="ne-text"> 展示求和的结果.</span></p><p id="200b796b4b1f5a36aa12caae6b6fa3d8_p_72" class="ne-p"><br></p><h4 id="964c73f0"><span class="ne-text">4. 移除事件监听者</span></h4><p id="7e9db6e1dddd1090f9cbf7742b89f0d6_p_73" class="ne-p"><br></p><p id="017aded1276858df53bbac28c927111b_p_74" class="ne-p"><span class="ne-text">如果想移除事件的监听, 可以像下面这样操作:</span></p><p id="cee026a6997be2fe2ca3b5d6e2ce2bf0_p_75" class="ne-p"><br></p><pre><code>import &#123; eventBus &#125; from 'event-bus.js'EventBus.$off('addition', &#123;&#125;)</code></pre><p id="391eee0f96cca26f6e7df243706d21bf_p_76" class="ne-p"><br></p><h2 id="FvhVC"><span class="ne-text">六、Vuex</span></h2><p id="9fc1a1e32cf7c324fef5888bc3009382_p_77" class="ne-p"><br></p><h4 id="0178c857"><span class="ne-text">1. Vuex 介绍</span></h4><p id="f585fed1cef9af7641b65ac1c4919258_p_78" class="ne-p"><br></p><p id="f31764caf4edb6337889991729dab76f_p_79" class="ne-p"><span class="ne-text">Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化. Vuex 解决了</span><code class="ne-code"><span class="ne-text">多个视图依赖于同一状态</span></code><span class="ne-text">和</span><code class="ne-code"><span class="ne-text">来自不同视图的行为需要变更同一状态</span></code><span class="ne-text">的问题，将开发者的精力聚焦于数据的更新而不是数据在组件之间的传递上</span></p><p id="cacc5e28cdefa24e262c83e0ab2a3ade_p_80" class="ne-p"><br></p><h4 id="6fb77009"><span class="ne-text">2. Vuex 各个模块</span></h4><p id="00780844004a7920ee455d8665291201_p_81" class="ne-p"><br></p><ol class="ne-ol"><li id="086fc566ad1f3e20b5c4075a7729ead3_li_2"><code class="ne-code"><span class="ne-text">state</span></code><span class="ne-text">：用于数据的存储，是 store 中的唯一数据源</span></li></ol><ol start="2" class="ne-ol"><li id="8f90ea99e20515a11d0d1c9f1f7e0553_li_3"><code class="ne-code"><span class="ne-text">getters</span></code><span class="ne-text">：如 vue 中的计算属性一样，基于 state 数据的二次包装，常用于数据的筛选和多个数据的相关性计算</span></li></ol><ol start="3" class="ne-ol"><li id="e6273b5a39a57288e5a1a89f2bc1fcfe_li_4"><code class="ne-code"><span class="ne-text">mutations</span></code><span class="ne-text">：类似函数，改变 state 数据的唯一途径，且不能用于处理异步事件</span></li></ol><ol start="4" class="ne-ol"><li id="a7a27b1b632925547190afbe9ad7fb4b_li_5"><code class="ne-code"><span class="ne-text">actions</span></code><span class="ne-text">：类似于</span><code class="ne-code"><span class="ne-text">mutation</span></code><span class="ne-text">，用于提交</span><code class="ne-code"><span class="ne-text">mutation</span></code><span class="ne-text">来改变状态，而不直接变更状态，可以包含任意异步操作</span></li></ol><ol start="5" class="ne-ol"><li id="d03ef67930c7afc0424138385fa658e8_li_6"><code class="ne-code"><span class="ne-text">modules</span></code><span class="ne-text">：类似于命名空间，用于项目中将各个模块的状态分开定义和操作，便于维护</span></li></ol><p id="ede07f6666baf1587414d7171c5dd877_p_82" class="ne-p"><br></p><h4 id="62a341a5"><span class="ne-text">3. Vuex 实例应用</span></h4><p id="187832c794b601f7094c1a9b20086a6b_p_83" class="ne-p"><br></p><pre><code>// 父组件<p>&lt;template&gt;<br>  &lt;div id=&quot;app&quot;&gt;<br>    &lt;ChildA/&gt;<br>    &lt;ChildB/&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;</p><p>&lt;script&gt;<br>  import ChildA from ‘./components/ChildA’ // 导入A组件<br>  import ChildB from ‘./components/ChildB’ // 导入B组件</p><p>  export default &#123;<br>    name: ‘App’,<br>    components: &#123;ChildA, ChildB&#125; // 注册A、B组件<br>  &#125;<br>&lt;/script&gt;<br></code></pre></p><pre><code>// 子组件childA&lt;template&gt;  &lt;div id=&quot;childA&quot;&gt;    &lt;h1&gt;我是A组件&lt;/h1&gt;    &lt;button @click=&quot;transform&quot;&gt;点我让B组件接收到数据&lt;/button&gt;    &lt;p&gt;因为你点了B，所以我的信息发生了变化：&#123;&#123;BMessage&#125;&#125;&lt;/p&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;  export default &#123;    data() &#123;      return &#123;        AMessage: 'Hello，B组件，我是A组件'      &#125;    &#125;,    computed: &#123;      BMessage() &#123;        // 这里存储从store里获取的B组件的数据        return this.$store.state.BMsg      &#125;    &#125;,    methods: &#123;      transform() &#123;        // 触发receiveAMsg，将A组件的数据存放到store里去        this.$store.commit('receiveAMsg', &#123;          AMsg: this.AMessage        &#125;)      &#125;    &#125;  &#125;&lt;/script&gt;</code></pre><pre><code>// 子组件 childB&lt;template&gt;  &lt;div id=&quot;childB&quot;&gt;    &lt;h1&gt;我是B组件&lt;/h1&gt;    &lt;button @click=&quot;transform&quot;&gt;点我让A组件接收到数据&lt;/button&gt;    &lt;p&gt;因为你点了A，所以我的信息发生了变化：&#123;&#123;AMessage&#125;&#125;&lt;/p&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;  export default &#123;    data() &#123;      return &#123;        BMessage: 'Hello，A组件，我是B组件'      &#125;    &#125;,    computed: &#123;      AMessage() &#123;        // 这里存储从store里获取的A组件的数据        return this.$store.state.AMsg      &#125;    &#125;,    methods: &#123;      transform() &#123;        // 触发receiveBMsg，将B组件的数据存放到store里去        this.$store.commit('receiveBMsg', &#123;          BMsg: this.BMessage        &#125;)      &#125;    &#125;  &#125;&lt;/script&gt;</code></pre><p id="d2ef17a7a18d8c7e67af8d1ea686174e_p_85" class="ne-p"><span class="ne-text">vuex 的</span><code class="ne-code"><span class="ne-text">store,js</span></code></p><p id="c07d4a2054239914d4a014d7d64fcf23_p_86" class="ne-p"><br></p><pre><code>import Vue from 'vue'import Vuex from 'vuex'Vue.use(Vuex)const state = &#123;  // 初始化A和B组件的数据，等待获取  AMsg: '',  BMsg: ''&#125;<p>const mutations = &#123;<br>  receiveAMsg(state, payload) &#123;<br>    // 将A组件的数据存放于state<br>    state.AMsg = payload.AMsg<br>  &#125;,<br>  receiveBMsg(state, payload) &#123;<br>    // 将B组件的数据存放于state<br>    state.BMsg = payload.BMsg<br>  &#125;<br>&#125;</p><p>export default new Vuex.Store(&#123;<br>  state,<br>  mutations<br>&#125;)<br></code></pre></p><p id="bd67236b6b40e1ddeba66aa4c905c5af_p_87" class="ne-p"><br></p><h2 id="PCidf"><span class="ne-text">七、</span><code class="ne-code"><span class="ne-text">localStorage</span></code><span class="ne-text"> / </span><code class="ne-code"><span class="ne-text">sessionStorage</span></code></h2><p id="ac4c0d2013d04adfac6d2e9459525ac0_p_88" class="ne-p"><br></p><p id="f283288775a2632e08501548c88fd4d5_p_89" class="ne-p"><span class="ne-text">这种通信比较简单, 缺点是数据和状态比较混乱, 不太容易维护。 通过</span><code class="ne-code"><span class="ne-text">window.localStorage.getItem(key)</span></code><span class="ne-text">获取数据 通过</span><code class="ne-code"><span class="ne-text">window.localStorage.setItem(key,value)</span></code><span class="ne-text">存储数据</span></p><p id="700ece5e21ebc17eb29d438c814531fe_p_90" class="ne-p"><br></p><div class="ne-quote"><p id="5f8a28e0e191bf5002124d4728a6494d_p_91" class="ne-p"><span class="ne-text">注意用</span><code class="ne-code"><span class="ne-text">JSON.parse()</span></code><span class="ne-text"> / </span><code class="ne-code"><span class="ne-text">JSON.stringify()</span></code><span class="ne-text"> 做数据格式转换（localStorage和sessionStorage只能存字符串，会自动调用对象的toString方法）</span></p><p id="udd314bb5" class="ne-p"><span class="ne-text"> </span><code class="ne-code"><span class="ne-text">localStorage</span></code><span class="ne-text"> / </span><code class="ne-code"><span class="ne-text">sessionStorage</span></code><span class="ne-text">可以结合</span><code class="ne-code"><span class="ne-text">vuex</span></code><span class="ne-text">, 实现数据的持久保存, 同时使用 </span><code class="ne-code"><span class="ne-text">vuex</span></code><span class="ne-text">解决数据和状态混乱问题.</span></p></div><p id="f82a35c2fca60d6b3bdc5c1000201985_p_92" class="ne-p"><br></p><pre><code>// 存取sessionStorage.setItem(  'sortColumn',  JSON.stringify(&#123; prop: column.prop, order: column.order &#125;))<p>// 使用<br>this.sortColumnSession = JSON.parse(<br>    sessionStorage.getItem(‘sortColumn’)<br>)<br></code></pre></p><h2 id="tVBCj"><span class="ne-text">八 </span><code class="ne-code"><span class="ne-text">$attrs</span></code><span class="ne-text">与 </span><code class="ne-code"><span class="ne-text">$listeners</span></code></h2><p id="92499751fabe053dd037c1574d6f4fb2_p_93" class="ne-p"><br></p><p id="5ee232d8069a64f0310d67c6cba2c264_p_94" class="ne-p"><span class="ne-text">现在我们来讨论一种情况， 我们一开始给出的组件关系图中 A 组件与 D 组件是隔代关系， 那它们之前进行通信有哪些方式呢？</span></p><p id="45f9c401f99c8bc813e223381c98f09b_p_95" class="ne-p"><br></p><ol class="ne-ol"><li id="83215d9ee7c1694d1bc3e76f305d7e9e_li_7"><span class="ne-text">使用</span><code class="ne-code"><span class="ne-text">props</span></code><span class="ne-text">绑定来进行一级一级的信息传递, 如果 D 组件中状态改变需要传递数据给 A, 使用事件系统一级级往上传递</span></li></ol><ol start="2" class="ne-ol"><li id="2c686f3d4e49b6f903a7a060cca635e2_li_8"><span class="ne-text">使用</span><code class="ne-code"><span class="ne-text">eventBus</span></code><span class="ne-text">, 这种情况下还是比较适合使用, 但是碰到多人合作开发时, 代码维护性较低, 可读性也低</span></li></ol><ol start="3" class="ne-ol"><li id="1adc8d2e29da201c9f819b96e079ce85_li_9"><span class="ne-text">使用 Vuex 来进行数据管理, 但是如果仅仅是传递数据, 而不做中间处理, 使用 Vuex 处理感觉有点大材小用了.</span></li></ol><p id="cd1514dfedaab485e5767b166731e116_p_96" class="ne-p"><br></p><p id="1660fc758c7e386ee6c1caa5c0ba61fd_p_97" class="ne-p"><span class="ne-text">在</span><code class="ne-code"><span class="ne-text">vue2.4</span></code><span class="ne-text">中，为了解决该需求，引入了</span><code class="ne-code"><span class="ne-text">$attrs</span></code><span class="ne-text"> 和</span><code class="ne-code"><span class="ne-text">$listeners</span></code><span class="ne-text"> ， 新增了</span><code class="ne-code"><span class="ne-text">inheritAttrs</span></code><span class="ne-text"> 选项。 在版本 2.4 以前，默认情况下, 父作用域中不作为 prop 被识别 (且获取) 的特性绑定 (class 和 style 除外)，将会 “回退” 且作为普通的 HTML 特性应用在子组件的根元素上。接下来看一个跨级通信的例子:</span></p><p id="545db91b827f87cc9afe81c0f08a1a88_p_98" class="ne-p"><br></p><pre><code>// app.vue// index.vue<p>&lt;template&gt;<br>  &lt;div&gt;<br>    &lt;child-com1<br>      :name=&quot;name&quot;<br>      :age=&quot;age&quot;<br>      :gender=&quot;gender&quot;<br>      :height=&quot;height&quot;<br>      title=&quot;程序员成长指北&quot;<br>    &gt;&lt;/child-com1&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br>&lt;script&gt;<br>const childCom1 = () =&gt; import(&quot;./childCom1.vue&quot;);<br>export default &#123;<br>  components: &#123; childCom1 &#125;,<br>  data() &#123;<br>    return &#123;<br>      name: &quot;zhang&quot;,<br>      age: &quot;18&quot;,<br>      gender: &quot;女&quot;,<br>      height: &quot;158&quot;<br>    &#125;;<br>  &#125;<br>&#125;;<br>&lt;/script&gt;<br></code></pre></p><pre><code>// childCom1.vue&lt;template class=&quot;border&quot;&gt;  &lt;div&gt;    &lt;p&gt;name: &#123;&#123; name&#125;&#125;&lt;/p&gt;    &lt;p&gt;childCom1的$attrs: &#123;&#123; $attrs &#125;&#125;&lt;/p&gt;    &lt;child-com2 v-bind=&quot;$attrs&quot;&gt;&lt;/child-com2&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;const childCom2 = () =&gt; import(&quot;./childCom2.vue&quot;);export default &#123;  components: &#123;    childCom2  &#125;,  inheritAttrs: false, // 可以关闭自动挂载到组件根元素上的没有在props声明的属性  props: &#123;    name: String // name作为props属性绑定  &#125;,  created() &#123;    console.log(this.$attrs);     // &#123; &quot;age&quot;: &quot;18&quot;, &quot;gender&quot;: &quot;女&quot;, &quot;height&quot;: &quot;158&quot;, &quot;title&quot;: &quot;程序员成长指北&quot; &#125;  &#125;&#125;;&lt;/script&gt;</code></pre><pre><code>// childCom2.vue&lt;template&gt;  &lt;div class=&quot;border&quot;&gt;    &lt;p&gt;age: &#123;&#123; age&#125;&#125;&lt;/p&gt;    &lt;p&gt;childCom2: &#123;&#123; $attrs &#125;&#125;&lt;/p&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  inheritAttrs: false,  props: &#123;    age: String  &#125;,  created() &#123;    console.log(this.$attrs);     // &#123; &quot;gender&quot;: &quot;女&quot;, &quot;height&quot;: &quot;158&quot;, &quot;title&quot;: &quot;程序员成长指北&quot; &#125;  &#125;&#125;;&lt;/script&gt;</code></pre><h2 id="d3gur"><span class="ne-text">总结</span></h2><p id="ec69cd8d8f73ee437722723e0adf1fa7_p_100" class="ne-p"><br></p><p id="d1dd1ab4b6c9dd3f0d10d775396b2c46_p_101" class="ne-p"><span class="ne-text">常见使用场景可以分为三类:</span></p><p id="a2c2ab33193f15adcdff2e08f718d7c2_p_102" class="ne-p"><br></p><ul class="ne-ul"><li id="38d84b7f285f00e4e99192b24cdc3891_li_10"><span class="ne-text">父子组件通信: </span><code class="ne-code"><span class="ne-text">props</span></code><span class="ne-text">; </span><code class="ne-code"><span class="ne-text">$parent</span></code><span class="ne-text"> / </span><code class="ne-code"><span class="ne-text">$children</span></code><span class="ne-text">; </span><code class="ne-code"><span class="ne-text">provide</span></code><span class="ne-text"> / </span><code class="ne-code"><span class="ne-text">inject</span></code><span class="ne-text"> ; </span><code class="ne-code"><span class="ne-text">ref</span></code><span class="ne-text"> ; </span><code class="ne-code"><span class="ne-text">$attrs</span></code><span class="ne-text"> / </span><code class="ne-code"><span class="ne-text">$listeners</span></code></li></ul><ul class="ne-ul"><li id="3e789b8578fdd7d181db9f576fa76889_li_11"><span class="ne-text">兄弟组件通信: </span><code class="ne-code"><span class="ne-text">eventBus</span></code><span class="ne-text"> ; vuex</span></li></ul><ul class="ne-ul"><li id="e10c2c9737bf8956c62733553c8b2e96_li_12"><span class="ne-text">跨级通信: </span><code class="ne-code"><span class="ne-text">eventBus</span></code><span class="ne-text">；Vuex；</span><code class="ne-code"><span class="ne-text">provide</span></code><span class="ne-text"> / </span><code class="ne-code"><span class="ne-text">inject</span></code><span class="ne-text"> 、</span><code class="ne-code"><span class="ne-text">$attrs</span></code><span class="ne-text"> / </span><code class="ne-code"><span class="ne-text">$listeners</span></code></li></ul><p id="1fde78b69ce88c86f4251c4f97a3b4b1_p_104" class="ne-p"><br></p><p id="de46638becbf26f6c7e35f22ece99363_p_108" class="ne-p"><span class="ne-text"><br /></span></p></div>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
          <category> Vue </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>国庆随笔：向死而生</title>
      <link href="/essay/gqoawl/"/>
      <url>/essay/gqoawl/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="ua3dca230" class="ne-p"><span class="ne-text">国庆小随笔</span></p><h2 id="SAZEt"><span class="ne-text">十月五号</span></h2><p id="u5399fbea" class="ne-p"><span class="ne-text">姐姐结婚，爱情是什么样的，我们谁都不得而知，我自认为自己最难懂的就是爱情，从爱情走向婚姻，我觉得是最幸福的事情。</span></p><p id="u49f2a180" class="ne-p"><br></p><h2 id="uJrCV"><span class="ne-text">十月六号</span></h2><p id="ue64801e2" class="ne-p"><br></p><h3 id="rS15r"><span class="ne-text">曾视为空城的那个鄱阳</span></h3><p id="u917356c4" class="ne-p"><span class="ne-text"></span></p><p id="u0d0a9142" class="ne-p"><span class="ne-text">和两个兄弟去了趟鄱阳，那个我曾经视为空城的一个小城，东湖大道那座小桥现已修建名为文正桥，桥是宽阔了许多，不过我还是些许留恋曾经两旁有参天大树的桥道。</span></p><p id="uf89817c9" class="ne-p"><br></p><p id="u268a3f3c" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1633875808473-8c8e729a-95e5-4cc1-9569-75ebeb9ec25e.jpeg" width="3648" id="ua8c982bd" class="ne-image"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1633875807952-96f55875-30da-431c-98dd-76ee3ae331e0.jpeg" width="3648" id="u77239b62" class="ne-image"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1633875809760-4dffcacf-688d-439e-9f71-a2a3245b26dd.jpeg" width="2736" id="ufe07eabd" class="ne-image"></p><p id="u3098a4ec" class="ne-p"><br></p><h3 id="xDvQq"><span class="ne-text">饶州古镇</span></h3><p id="u3a36902f" class="ne-p"><span class="ne-text"></span></p><p id="uc4d62a20" class="ne-p"><span class="ne-text">自家有这么一个古镇景点，还是很不错的</span></p><p id="u6018850f" class="ne-p"><span class="ne-text"></span></p><p id="u3fd40eba" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1633875997616-e683f592-bb92-4ca9-93d0-67a3712df0b5.jpeg" width="3648" id="u01295dec" class="ne-image"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1633875998381-311af713-f841-4c55-852c-8f92a72749bc.jpeg" width="3648" id="u05d7c963" class="ne-image"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1633875998279-4cdfbe6b-42b1-42bc-81a1-073a7b3830d8.jpeg" width="3840" id="uddde3c37" class="ne-image"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1633875997897-10bf7687-e99e-4f1a-b67d-c6614ece8bca.jpeg" width="3648" id="u7fb6ebc3" class="ne-image"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1633875998399-1534eab0-3711-47d1-886f-4a309f9d9273.jpeg" width="3648" id="ud64bd0a4" class="ne-image"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1633876002155-627bd9d7-39ea-41a4-a82a-4ad9992056c4.jpeg" width="3648" id="ufa00a8a2" class="ne-image"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1633876002241-35379903-c302-4e54-bb58-439786ff4470.jpeg" width="3648" id="u06167c90" class="ne-image"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1633876002731-e1bb0cc3-48c4-45e0-8895-9d435b1e04fe.jpeg" width="3648" id="u625ac0a3" class="ne-image"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1633876002769-34025c83-0fd7-4f24-8ea9-e32f86b94677.jpeg" width="3648" id="u08140798" class="ne-image"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1633876001841-3bfc9710-8031-4cc4-a930-6a60bcb456f7.jpeg" width="3648" id="u582a5e29" class="ne-image"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1633876005039-78bec731-e419-471b-b1d3-5078abd8f32f.jpeg" width="3648" id="uc786dce9" class="ne-image"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1633876005917-cc7d5d1f-8813-41c8-8392-24b446712922.jpeg" width="3648" id="u00e0504d" class="ne-image"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1633876006650-1cf3f393-472d-4af3-910a-454b98599755.jpeg" width="3648" id="u08504088" class="ne-image"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1633876006744-f7a8a89f-a970-4e04-a891-c257f9e67160.jpeg" width="3840" id="u00a090b1" class="ne-image"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1633876009430-86c16483-95dc-4fea-b6ef-5b6429e0a532.jpeg" width="3648" id="ue1f27166" class="ne-image"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1633876009245-da7f7e0a-bfdb-484c-aaac-3b1d666cc25b.jpeg" width="3648" id="u60e30b2c" class="ne-image"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1633876010297-9e5a9f09-53fd-4fe0-8cfd-26fd6a69c87a.jpeg" width="3648" id="u81b81119" class="ne-image"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1633876011269-cf89a74b-13f0-4381-8754-2be7b8cdcf23.jpeg" width="2736" id="u9acd5f62" class="ne-image"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1633876011280-e399e628-809e-4668-a49b-9241c6f3409a.jpeg" width="2736" id="uf29ce6cc" class="ne-image"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1633876013616-b2afe4f8-587b-44d7-871f-f508124584f5.jpeg" width="3648" id="ud0599d64" class="ne-image"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1633876014575-2e2702c5-4cf3-461d-a2b0-c4024a95ac8f.jpeg" width="3648" id="ua104b296" class="ne-image"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1633876014664-975619ee-cd95-44c4-bfd5-a6e32201fc89.jpeg" width="3648" id="u750f8321" class="ne-image"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1633876015648-67768ec5-5d69-40c5-b96a-464e6ba3d913.jpeg" width="2736" id="ud452a52b" class="ne-image"></p><p id="u78b81c6b" class="ne-p"><span class="ne-text"></span></p><p id="uf6357425" class="ne-p"><span class="ne-text"></span></p><h2 id="lHMbd"><span class="ne-text">十月七号</span></h2><p id="u498da28b" class="ne-p"><span class="ne-text">生活节奏太快，想了想，想停下来写写走走看看，于是七号在家中，八号再去公司</span></p><p id="ueebbc9ea" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/gif/1484158/1649041952673-600e4ad8-231b-491a-b1ba-ada6a2c0ee31.gif" width="218" id="nzi5z" class="ne-image"></p><p id="u4cadfe56" class="ne-p"><br></p><h2 id="jrF6C"><span class="ne-text">十月八号</span></h2><p id="ua18e6642" class="ne-p"><br></p><h3 id="iiGzJ"><span class="ne-text">珠海版“人在囧途”</span></h3><p id="u2400248c" class="ne-p"><span class="ne-text"></span></p><p id="u0cf50ffa" class="ne-p"><span class="ne-text">返珠海，上演一段真正的人在囧途，没有遇到</span></p><p id="u51ac14be" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1633876494701-40bf091b-6af2-41bc-b108-ce3580a8e3b1.jpeg" width="3648" id="uf020ab48" class="ne-image"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1633876495028-16dcd228-d572-4658-9626-6a4a169162a0.jpeg" width="3648" id="uc21583b3" class="ne-image"></p><p id="uafcc1f5e" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1633876843288-1bd256a2-fd14-49a3-b8b2-b21ac3f050af.jpeg" width="1176" id="uf549968e" class="ne-image"></p><p id="u0bcc6009" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1633876844529-f7c4bd92-d9b2-495c-9309-6a671a860134.jpeg" width="2736" id="QEJAx" class="ne-image"></p><p id="u7d40d1db" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1633877452207-23cc8796-b4a5-4675-a283-e520384354b8.jpeg" width="2736" id="u89faf5ba" class="ne-image"></p><p id="ucb84ab3e" class="ne-p"><span class="ne-text"></span></p><h2 id="Eae3s"><span class="ne-text">十月九号</span></h2><p id="ua7267adc" class="ne-p"><span class="ne-text">四点钟被叫醒，说是去赶车，我太难了，假期到现在，每天都在早起，每天都在出行的路上，你要说我现在渴望些什么，我只想吃点粥啥的暖暖胃，然后再好好睡上一觉～</span></p><p id="u527f4d47" class="ne-p"><span class="ne-text"></span></p><p id="uee7179be" class="ne-p"><span class="ne-text">生活或许就是有时该为了活着而活着，而在关键时刻又需要向死而生的一种魄力。</span></p></div>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>PC端hevc编码的MOV格式视频无法查看</title>
      <link href="/blog/akf33e/"/>
      <url>/blog/akf33e/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="u1b5b6b57" class="ne-p"><span class="ne-text">前言：需求中有这么一个问题，部分mov格式的视频在移动端可以播放，但在pc客户端无法显示，对比能播放和不能播放的mov格式视频，发现是hevc编码的mov视频不能播放，对此在做需求过程中，寻求并尝试了一些方法来解决这个问题，在本文做个记录。</span></p><p id="u39e05545" class="ne-p"><span class="ne-text"></span></p><div class="ne-quote"><ol class="ne-ol"><li id="u6ee0e089"><span class="ne-text">MOV合适视频是苹果手机拍摄的视频格式</span></li><li id="ucb6b1b39"><span class="ne-text">苹果拍照的视频和苹果利用api调用的拍照的视频，这两者拍的视频编码是有差异的</span></li></ol></div><h2 id="aCbsI"><span class="ne-text">一、两者视频元信息比较</span></h2><p id="u6cb5301e" class="ne-p"><span class="ne-text">所用例子：</span></p><ul class="ne-ul"><li id="uc9188c46"><a href="https://image.x7sy.com/oa_medias/65440114717__69E1A426-97B2-4832-95FC-7712D9D7A487-16327083586676.MOV" data-href="https://image.x7sy.com/oa_medias/65440114717__69E1A426-97B2-4832-95FC-7712D9D7A487-16327083586676.MOV" target="_blank" class="ne-link"><span class="ne-text">非hevc编码视频例子</span></a></li><li id="uee54ac6e"><a href="https://image.x7sy.com/oa_medias/IMG_0018-16327078428771.MOV" data-href="https://image.x7sy.com/oa_medias/IMG_0018-16327078428771.MOV" target="_blank" class="ne-link"><span class="ne-text">hevc编码视频例子</span></a></li></ul><p id="u35ea3340" class="ne-p"><br></p><p id="u9a3f6e9b" class="ne-p"><span class="ne-text">利用格式工厂查看两个视频的元信息：</span></p><p id="u26dd80de" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1636168657171-19788f71-f632-44cc-9e62-0e6d9f206379.png" width="825" id="u318798b8" class="ne-image"></p><p id="uefc9da5c" class="ne-p"><span class="ne-text">利用上面的信息以及实际的可播放效果得：</span></p><ul class="ne-ul"><li id="u66d4ca2a"><span class="ne-text">mobile：都能看（安卓和苹果）</span></li><li id="u37f0e1b2"><span class="ne-text">pc：不能看上传的，</span><strong><span class="ne-text">hevc编码的不能解码</span></strong><span class="ne-text">？移动端相较pc能处理hevc编码？</span></li></ul><h2 id="Mg1QX"><span class="ne-text">二、HEVC、H.265兼容性支持情况</span></h2><p id="uaa976dd2" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1632730222885-c5d08df9-afdf-4b78-85fa-9003cb6b47b2.png" width="568.5" id="u07c0c94a" class="ne-image"></p><p id="u19280f6a" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1632730253372-9f6e0c9d-03c5-4685-ada6-d68306266653.png" width="570.5" id="u940ac543" class="ne-image"></p><p id="uf59796a1" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1636168806126-ed5989be-ca1f-455c-a434-b0fbe89bca94.png" width="888.5" id="ue461184a" class="ne-image"></p><p id="u76eaa99a" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1632885246692-38ce1a86-66eb-4d5e-8e91-ff2c48a65f4e.png" width="529" id="u48fdcb25" class="ne-image"></p><p id="u351c1cbd" class="ne-p"><span class="ne-text">参考方案：</span></p><ul class="ne-ul"><li id="ue429d104"><a href="https://blog.csdn.net/yanrx76/article/details/116238315" data-href="https://blog.csdn.net/yanrx76/article/details/116238315" target="_blank" class="ne-link"><strong><span class="ne-text">如何在浏览器中支持H265/HEVC</span></strong></a></li><li id="uc784faa2"><a href="https://www.fdbtech.com/webfrontend/%E5%89%8D%E7%AB%AF%E5%A6%82%E4%BD%95%E6%92%AD%E6%94%BEhevch265%E7%BC%96%E7%A0%81%E7%9A%84mp4%E8%A7%86%E9%A2%91" data-href="https://www.fdbtech.com/webfrontend/%E5%89%8D%E7%AB%AF%E5%A6%82%E4%BD%95%E6%92%AD%E6%94%BEhevch265%E7%BC%96%E7%A0%81%E7%9A%84mp4%E8%A7%86%E9%A2%91" target="_blank" class="ne-link"><span class="ne-text">前端web如何播放HEVC(h265)编码的MP4视频</span></a></li></ul><ul class="ne-ul"><li id="u9a15c27a"><a href="https://segmentfault.com/a/1190000017187346" data-href="https://segmentfault.com/a/1190000017187346" target="_blank" class="ne-link"><span class="ne-text">H.265/HEVC在Web视频播放的实践</span></a></li><li id="u464cd360"><a href="https://segmentfault.com/q/1010000020081504" data-href="https://segmentfault.com/q/1010000020081504" target="_blank" class="ne-link"><span class="ne-text">video播放mov文件问题</span></a></li></ul><h2 id="nWppG"><span class="ne-text">三、解决方案</span></h2><p id="u520e30a3" class="ne-p"><span class="ne-text">下面几种方法是解决过程中所尝试的几种方法，前四种都测试未能解决该问题，最后一个方法取之。</span></p><h3 id="Fh8pH"><span class="ne-text">【弃】vue-h265-player插件使用</span></h3><ul class="ne-ul"><li id="ubd7a8f37"><a href="https://www.npmjs.com/package/vue-h265-player" data-href="https://www.npmjs.com/package/vue-h265-player" target="_blank" class="ne-link"><span class="ne-text">https://www.npmjs.com/package/vue-h265-player</span></a></li><li id="u4226c89f"><span class="ne-text"></span><a href="https://blog.csdn.net/Nie2014/article/details/114651376" data-href="https://blog.csdn.net/Nie2014/article/details/114651376" target="_blank" class="ne-link"><span class="ne-text">https://blog.csdn.net/Nie2014/article/details/114651376</span></a></li></ul><ul class="ne-ul"><li id="u3bbaae9f"><a href="https://blog.csdn.net/weixin_42274114/article/details/109490633" data-href="https://blog.csdn.net/weixin_42274114/article/details/109490633" target="_blank" class="ne-link"><span class="ne-text">https://blog.csdn.net/weixin_42274114/article/details/109490633</span></a></li></ul><p id="uba12ae57" class="ne-p"><span class="ne-text" style="text-decoration: line-through">判断是否为h.265，如果是就将其用新的播放器（插件）播放</span></p><p id="u01016027" class="ne-p"><a href="https://github.com/buzz/mediainfo.js" data-href="https://github.com/buzz/mediainfo.js" target="_blank" class="ne-link"><span class="ne-text" style="text-decoration: line-through">https://github.com/buzz/mediainfo.js</span></a></p><p id="ufb9ecf27" class="ne-p"><span class="ne-text" style="text-decoration: line-through">项目中添加该api的判断代码</span></p><ul class="ne-ul"><li id="u9cebd4db"><a href="https://blog.csdn.net/weixin_42274114/article/details/109490633" data-href="https://blog.csdn.net/weixin_42274114/article/details/109490633" target="_blank" class="ne-link"><span class="ne-text" style="text-decoration: line-through">https://blog.csdn.net/weixin_42274114/article/details/109490633</span></a></li><li id="uccca4d9e"><a href="https://segmentfault.com/a/1190000039753551" data-href="https://segmentfault.com/a/1190000039753551" target="_blank" class="ne-link"><span class="ne-text" style="text-decoration: line-through">https://segmentfault.com/a/1190000039753551</span></a></li></ul><ul class="ne-ul"><li id="u0bcbeeab"><a href="https://blog.csdn.net/Nie2014/article/details/114651376" data-href="https://blog.csdn.net/Nie2014/article/details/114651376" target="_blank" class="ne-link"><span class="ne-text" style="text-decoration: line-through">https://blog.csdn.net/Nie2014/article/details/114651376</span></a></li></ul><div data-type="danger" class="ne-alert"><p id="u0f44f1f5" class="ne-p"><span class="ne-text">插件源代码本身有问题</span></p></div><h3 id="gtJbk"><span class="ne-text">【弃】EasyPlayer.js插件使用</span></h3><ul class="ne-ul"><li id="u46e2d2e4"><a href="https://my.oschina.net/u/4383286/blog/4496965" data-href="https://my.oschina.net/u/4383286/blog/4496965" target="_blank" class="ne-link"><span class="ne-text">https://my.oschina.net/u/4383286/blog/4496965</span></a></li><li id="uf0143acd"><a href="https://github.com/tsingsee/EasyPlayer.js" data-href="https://github.com/tsingsee/EasyPlayer.js" target="_blank" class="ne-link"><span class="ne-text">https://github.com/tsingsee/EasyPlayer.js</span></a></li></ul><ul class="ne-ul"><li id="u3a8703ea"><a href="https://blog.csdn.net/a843334549/article/details/117323709" data-href="https://blog.csdn.net/a843334549/article/details/117323709" target="_blank" class="ne-link"><span class="ne-text">https://blog.csdn.net/a843334549/article/details/117323709</span></a></li><li id="ua7d9beb3"><a href="https://blog.csdn.net/u012848709/article/details/106291133" data-href="https://blog.csdn.net/u012848709/article/details/106291133" target="_blank" class="ne-link"><span class="ne-text">https://blog.csdn.net/u012848709/article/details/106291133</span></a></li></ul><ul class="ne-ul"><li id="uee6b716b"><a href="https://www.liveqing.com/docs/manuals/LivePlayer.html#%E5%9C%A8-vue-%E4%B8%AD%E4%BD%BF%E7%94%A8" data-href="https://www.liveqing.com/docs/manuals/LivePlayer.html#%E5%9C%A8-vue-%E4%B8%AD%E4%BD%BF%E7%94%A8" target="_blank" class="ne-link"><span class="ne-text">https://www.liveqing.com/docs/manuals/LivePlayer.html#%E5%9C%A8-vue-%E4%B8%AD%E4%BD%BF%E7%94%A8</span></a></li><li id="uba291925"><a href="https://gitee.com/livegbs/liveplayer-vc" data-href="https://gitee.com/livegbs/liveplayer-vc" target="_blank" class="ne-link"><span class="ne-text">https://gitee.com/livegbs/liveplayer-vc</span></a></li></ul><div data-type="danger" class="ne-alert"><p id="u01bd2388" class="ne-p"><span class="ne-text">未能播放那个苹果上传mov文件</span></p><p id="u7863f7a7" class="ne-p"><span class="ne-text">可能原因是苹果上传的mov文件(hevc)不属于该插件所解码的h.265的范围。</span></p></div><p id="u28130e96" class="ne-p"><br></p><p id="u26393f1a" class="ne-p"><strong><span class="ne-text" style="color: #F5222D">只要是hevc的格式，不管是视频还是声音，都无法播放</span></strong></p><ul class="ne-ul"><li id="u41d3a275"><span class="ne-text">EasyPlayer.js插件：</span><a href="https://github.com/tsingsee/EasyPlayer.js/issues/45" data-href="https://github.com/tsingsee/EasyPlayer.js/issues/45" target="_blank" class="ne-link"><span class="ne-text">https://github.com/tsingsee/EasyPlayer.js/issues/45</span></a></li><li id="uf12732b9"><span class="ne-text">原项目issues（vue-video-player插件）：</span><a href="https://github.com/surmon-china/vue-video-player/issues/232" data-href="https://github.com/surmon-china/vue-video-player/issues/232" target="_blank" class="ne-link"><span class="ne-text">https://github.com/surmon-china/vue-video-player/issues/232</span></a></li></ul><p id="ua4eaf41b" class="ne-p"><br></p><h3 id="ujwBQ"><span class="ne-text">【弃】libde265.JS解决办法</span></h3><ul class="ne-ul"><li id="u73274506"><span class="ne-text"></span><a href="https://github.com/strukturag/libde265" data-href="https://github.com/strukturag/libde265" target="_blank" class="ne-link"><span class="ne-text">https://github.com/strukturag/libde265</span></a></li></ul><ul class="ne-ul"><li id="u8280a4d8"><span class="ne-text"></span><a href="https://www.fdbtech.com/webfrontend/%E5%89%8D%E7%AB%AF%E5%A6%82%E4%BD%95%E6%92%AD%E6%94%BEhevch265%E7%BC%96%E7%A0%81%E7%9A%84mp4%E8%A7%86%E9%A2%91" data-href="https://www.fdbtech.com/webfrontend/%E5%89%8D%E7%AB%AF%E5%A6%82%E4%BD%95%E6%92%AD%E6%94%BEhevch265%E7%BC%96%E7%A0%81%E7%9A%84mp4%E8%A7%86%E9%A2%91" target="_blank" class="ne-link"><span class="ne-text">前端web如何播放HEVC(h265)编码的MP4视频</span></a></li><li id="u211af4cc"><a href="https://segmentfault.com/a/1190000017187346" data-href="https://segmentfault.com/a/1190000017187346" target="_blank" class="ne-link"><span class="ne-text">H.265/HEVC在Web视频播放的实践</span></a></li></ul><div data-type="danger" class="ne-alert"><p id="ud6c4dbc5" class="ne-p"><span class="ne-text">使用该js文件，能播放他自己提供的那个文件（改不改后缀都可以）</span></p><p id="u37c0c0dc" class="ne-p"><span class="ne-text">新上传的hevc编码的文件还是不能播放</span></p></div><h3 id="qhc2n"><span class="ne-text">【弃】easywasmplayer</span></h3><p id="ua907d3d3" class="ne-p"><span class="ne-text">测试地址：</span><a href="http://www.easydarwin.org/easywasmplayer/" data-href="http://www.easydarwin.org/easywasmplayer/" target="_blank" class="ne-link"><span class="ne-text">http://www.easydarwin.org/easywasmplayer/</span></a></p><div data-type="danger" class="ne-alert"><p id="ud3d554a5" class="ne-p"><span class="ne-text">不支持mov播放，mp4可以</span></p></div><h3 id="pDCNT"><span class="ne-text">【取】ffmpeg方法</span></h3><div data-type="success" class="ne-alert"><p id="u98bacc83" class="ne-p"><span class="ne-text">能否在后端利用ffmpeg将mov格式视频转换成mp4，转换之后的mp4格式是h.264编码的（目前只有部分mov格式视频是hevc编码的）</span></p></div><p id="ue3285a88" class="ne-p"><br></p><ul class="ne-ul"><li id="u01a2e3eb"><span class="ne-text"></span><a href="https://learnku.com/articles/50169" data-href="https://learnku.com/articles/50169" target="_blank" class="ne-link"><span class="ne-text">Web 端解码 H.265 视频可行性研究</span></a></li><li id="uda1c876b"><span class="ne-text"></span><a href="https://blog.csdn.net/qq_29931083/article/details/107758997" data-href="https://blog.csdn.net/qq_29931083/article/details/107758997" target="_blank" class="ne-link"><span class="ne-text">ffmpeg将mov格式的视频转换成mp4格式</span></a></li></ul><p id="u54631621" class="ne-p"><span class="ne-text"></span></p><p id="u5708f1f9" class="ne-p"><span class="ne-text">PS：ffmpeg安装方法：</span></p><p id="u6a3cb83b" class="ne-p"><a href="https://ffmpeg.org/download.html" data-href="https://ffmpeg.org/download.html" target="_blank" class="ne-link"><span class="ne-text">https://ffmpeg.org/download.html</span></a></p><p id="u22be7417" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1632896302501-77e97ee6-c0fa-444d-a9c2-a34bec0d7493.png" width="491" id="u1938d594" class="ne-image"></p><p id="u7a13ec78" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1632896323573-b3da95d2-dba7-42d0-b712-b2cfb5dbf82e.png" width="312.5" id="ud117ee8e" class="ne-image"></p><p id="uf4cb7c84" class="ne-p"><span class="ne-text">添加到环境变量</span></p><p id="uf41cab34" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1641181905373-20996222-6e15-43ee-9e2f-4ca7d62da401.png" width="355" id="ud78e85c0" class="ne-image"></p><p id="ue4c9d668" class="ne-p"><span class="ne-text">检测是否安装成功</span></p><p id="ubec3da53" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1632896355552-9604ce17-2ff5-44dc-931e-73ebc2efede8.png" width="373.5" id="ubed8d8a3" class="ne-image"></p><p id="u221b2367" class="ne-p"><span class="ne-text">安装成功</span></p><p id="u00bbe596" class="ne-p"><span class="ne-text"></span></p><p id="u4e6bed12" class="ne-p"><strong><span class="ne-text">【ffmpeg转mov为mp4-命令】</span></strong></p><pre><code>ffmpeg -i test.mov -vcodec libx264 -preset fast -crf 20 -y -acodec libmp3lame -ab 128k test.mp4</code></pre><p id="u7b747430" class="ne-p"><span class="ne-text"></span></p><p id="u36a66e9e" class="ne-p"><strong><span class="ne-text">【前端实现】</span></strong></p><p id="u4668101b" class="ne-p"><a href="https://download.csdn.net/download/weixin_42120997/19759493" data-href="https://download.csdn.net/download/weixin_42120997/19759493" target="_blank" class="ne-link"><span class="ne-text">https://download.csdn.net/download/weixin_42120997/19759493</span></a><span class="ne-text">【收费】</span></p><p id="u62303f43" class="ne-p"><a href="https://blog.csdn.net/dj513dj/article/details/60961970" data-href="https://blog.csdn.net/dj513dj/article/details/60961970" target="_blank" class="ne-link"><span class="ne-text">https://blog.csdn.net/dj513dj/article/details/60961970</span></a></p><p id="u8e862f0f" class="ne-p"><a href="https://juejin.cn/post/6844903961942556685" data-href="https://juejin.cn/post/6844903961942556685" target="_blank" class="ne-link"><span class="ne-text">https://juejin.cn/post/6844903961942556685</span></a></p><p id="u5100a420" class="ne-p"><a href="https://github.com/damianociarla/node-ffmpeg" data-href="https://github.com/damianociarla/node-ffmpeg" target="_blank" class="ne-link"><span class="ne-text">https://github.com/damianociarla/node-ffmpeg</span></a></p><p id="ubc1e5279" class="ne-p"><a href="https://blog.csdn.net/dj513dj/article/details/60961970" data-href="https://blog.csdn.net/dj513dj/article/details/60961970" target="_blank" class="ne-link"><span class="ne-text">https://blog.csdn.net/dj513dj/article/details/60961970</span></a></p><p id="u84fbaae2" class="ne-p"><span class="ne-text">还是需要电脑有ffmpeg环境</span></p><p id="uad061cd9" class="ne-p"><span class="ne-text"></span></p><p id="u70226f72" class="ne-p"><strong><span class="ne-text">【后端实现】</span></strong></p><p id="u34b02720" class="ne-p"><a href="https://blog.csdn.net/fareise/article/details/53188785" data-href="https://blog.csdn.net/fareise/article/details/53188785" target="_blank" class="ne-link"><span class="ne-text">NodeJS实现视频转码</span></a></p><p id="uf09e6507" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1632897980832-011bfd61-effc-47f9-a527-17b59644c4ae.png" width="695" id="lFosa" class="ne-image"></p><p id="u77922ea0" class="ne-p"><span class="ne-text">需要服务端有ffmpeg环境</span></p></div>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
          <category> 前端业务解决方案 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>师者对技术的态度</title>
      <link href="/essay/dqzalx/"/>
      <url>/essay/dqzalx/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="u5abe3c3a" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/1484158/1649042341317-573ef9f9-3528-4b7c-b838-21e47448200c.jpeg" width="333.015625" id="u0d8f20dd" class="ne-image"></p><p id="u3b4f5cba" class="ne-p"><span class="ne-text"></span></p><ul class="ne-ul"><li id="2302818483f14cd1baf9ad807e7aef7e"><span class="ne-text">C语言老师：</span><code class="ne-code"><span class="ne-text">像你们这个年龄，在古代那会儿，你们才刚刚进入仕途</span></code></li><li id="2d77dda4d9bf442a081548c366a79f42"><span class="ne-text">数据结构老师：</span><code class="ne-code"><span class="ne-text">将数据结构整本书上的所有算法自己实现一遍，那么代码水平就能够提升到一个不错的高度</span></code></li></ul><ul class="ne-ul"><li id="fbf26996f22e42c27a9397bfab3d4729"><span class="ne-text">JAVA老师：</span><code class="ne-code"><span class="ne-text">Ideas are cheap, show me the code</span></code></li><li id="4c8030857747fc21fdf2cf11f90e735d"><span class="ne-text">计算机网络老师：</span><code class="ne-code"><span class="ne-text">要用工程思维去设计一个系统</span></code></li><li id="3da6ea73090db79b1ffdb17b9ef49e48"><span class="ne-text">计算方法老师：</span><code class="ne-code"><span class="ne-text">计算机没有精确 只有精度</span></code></li></ul><p id="ubc03d941" class="ne-p"><br></p><p id="u6212a8de" class="ne-p"><span class="ne-text">第一个面试的HR：</span></p><p id="u7df30ff8" class="ne-p"><span class="ne-text">感受得到，她是一个资深的面试官，她问的各个问题不是很刁钻，但是很细，伴随着问答的交流，我也逐渐意识到我的不足之处（深度和广度），过程中她说了一句话，让我印象深刻：</span><code class="ne-code"><span class="ne-text">现在技术这条路，不是这么好走的</span></code></p></div>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>隐忍——能屈能伸</title>
      <link href="/essay/rng8r9/"/>
      <url>/essay/rng8r9/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="u6c6014ae" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1630644058664-8fca3267-fe2c-4890-868d-dd84180a80ce.png" width="960" id="u7bba36b2" class="ne-image"></p><p id="ub84eb308" class="ne-p"><em><span class="ne-text">风会长的隐忍，能屈能伸</span></em></p><p id="ue4ee2ab6" class="ne-p"><span class="ne-text"></span></p><p id="a20d224c568e48b9d67847a2c66a8c01_p_0" class="ne-p"><strong><span class="ne-text">『隐忍』</span></strong></p><p id="u2e676898" class="ne-p"><span class="ne-text"></span></p><p id="u7e6b5ac0" class="ne-p"><span class="ne-text">个人认为这个词有褒有贬，但有一个可以肯定的是，能隐忍的人，定在蓄势待发。</span></p><p id="u967c547f" class="ne-p"><span class="ne-text"></span></p><p id="u1e9063c5" class="ne-p"><span class="ne-text">蝇头小利也好，一时上头也好，我觉得对人而言，『克制』和『隐忍』是最需要磨练的一个品质，这不代表你放弃了洒脱，不再成为性情中人，而是这种品质会让你走得更远，情、事业、爱好等等。对隐忍这个代名词最经典的记忆之一是读《狼图腾》里的时候，里面写道狼群捕猎黄羊群，会静待最好的狩猎时机，不会为了眼前的零星几只羊而乱了阵脚，狩人掏狼崽，狼也能克制，因为它们很清楚自己与狩人的实力，即便是骨肉至亲……</span></p><p id="u309c976b" class="ne-p"><span class="ne-text"></span></p><p id="u4a361bd9" class="ne-p"><span class="ne-text">另一个就是《一人之下》的风正豪，将能屈能伸演绎的淋漓尽致，儿子风星潼被王并用自家的拘灵遣将打的重伤并羞辱，他选择的是马首是瞻，像极了越王勾践，枭雄之所以能成为枭雄，</span><strong><span class="ne-text">是因为他们能忍常人所不能接受的痛楚</span></strong><span class="ne-text">，因为在他们心里面，有一条更长的路在那里，只是在等待羽翼丰满之时。</span></p><p id="ubfab90a1" class="ne-p"><span class="ne-text"></span></p><p id="u09d507b4" class="ne-p"><span class="ne-text">最后，我之所以单方面觉得隐忍还有贬的意味，是我觉得，优秀、不卑不亢这些品质的确很重要，但真性情、简单、洒脱也是一个人不能忘却的，不然就成为了俞敏洪口中的老奸巨猾。</span><strong><span class="ne-text">懂得舍弃，学会用智慧去选择自己该做什么样的抉择</span></strong><span class="ne-text">，才是一个人最需要做的。</span></p></div>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>人生独行者</title>
      <link href="/essay/fb0yri/"/>
      <url>/essay/fb0yri/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="u3bda4409" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1630812970555-a8e776cc-9769-4729-b360-2eaeb8c95afd.jpeg" width="1920" id="u7c5aea52" class="ne-image"></p><p id="u2520bcd0" class="ne-p"><strong><span class="ne-text"></span></strong></p><p id="u6a1e5448" class="ne-p"><strong><span class="ne-text">无悔的独行者</span></strong></p><p id="ud15a128d" class="ne-p"><span class="ne-text"></span></p><p id="520f42f3293818f927861ebbd5b15da4_p_0" class="ne-p"><span class="ne-text">人生就是一个行者独自在一条大道上向前行走着，身边有许多美好，有许多遗憾，但是时间是单维度的，时间不会后退，你做过的事情，不会倒退，单一个体要对自己做过的事情无悔</span></p><p id="42b724d5778774d60e8ceb8c6aafe2fd" class="ne-p"><br></p><p id="30dd3a402fcd74138548305a9a1dc171" class="ne-p"><span class="ne-text">路上，你遇到很多人，你又和很多人说再见，你的前方无论什么时候都是那条看不到尽头的道路，</span></p><p id="234a06249234ea5e1e92b1c37696ede9" class="ne-p"><br></p><p id="619083d955cda6ae263322a8ebb6c4ba" class="ne-p"><span class="ne-text">不用去想人生的意义是什么，因为当死了的那一瞬间，了无遗憾，无悔般地笑着</span></p><p id="95cf672e8334071d2fab7f0b4b3d4a07" class="ne-p"><br></p><p id="udd7f0fcb" class="ne-p"><strong><span class="ne-text">造物主的内壁</span></strong></p><p id="u8d5ae5c3" class="ne-p"><br></p><p id="u31d69dda" class="ne-p"><span class="ne-text">人生的阶段就像是一个个内壁，就像是造物主让我们这么一个个生命体聚集在一起，他希望我们是规则的，所以在文明下，我们很多人都是规矩的，一样的……</span></p><p id="u716b142c" class="ne-p"><span class="ne-text"></span></p><p id="ud854a12d" class="ne-p"><span class="ne-text">文明框架下，每个人都是主角，每个人又好像都不是主角。</span></p><p id="ud68a5b91" class="ne-p"><span class="ne-text"></span></p><p id="ubde2b243" class="ne-p"><span class="ne-text"></span></p><p id="u4acf5d48" class="ne-p"><span class="ne-text">循环的单变量</span></p><p id="ua102cb94" class="ne-p"><span class="ne-text">读书===娶老婆===事业===生娃===读书</span></p><p id="b9c17e703a1bbbc593736caa61ef259d" class="ne-p"><br></p><p id="582d9b36ae645f59ac18545d9535ec31" class="ne-p"><span class="ne-text">这个文明带给我们的就像是这样的一段代码，然而，哪有这么容易呢？然而生活还会时不时给你制造bug，比如你学业上的困难，人总是不习惯于框架之外，但又沉溺于这个制度本身，讽刺的是，解决那些bug的人就是我们自己。</span></p><p id="7185a174c6bd5e198c0bcca841ff91fa" class="ne-p"><br></p><p id="4b6819242b47b931d3a1658713b96cfa" class="ne-p"><span class="ne-text">每个人就像是按照既定的规则去做事，不能有程序上的bug，</span></p><p id="d164fa8fc4acdbcc10e3b530cd7e9de0" class="ne-p"><br></p><p id="d8ce710037fe5edd48452a5c16b373d5" class="ne-p"><span class="ne-text">反过来说，要是我们不顺应这个文明制度，这就像是出bug了。</span></p><p id="de0cc843e56199257d01eb46a0eb9e67" class="ne-p"><br></p><p id="a566430fe2233f1d87599342268a3985" class="ne-p"><span class="ne-text">“某人读书期间，不好好读书，不务正业”造物主借由“环境”这么一个事物来影响这一个个体，让其不要破坏这个社会的制度，突然有一天，那个某人终于</span></p><p id="u400aa7ba" class="ne-p"><span class="ne-text"></span></p><p id="u2bbdfaa4" class="ne-p"><span class="ne-text">算法当中的贪心算法，其算法思想就是取局部最优</span></p><p id="u1d735217" class="ne-p"><span class="ne-text"></span></p><p id="u18ca4b97" class="ne-p"><strong><span class="ne-text">假如明天我死了</span></strong></p><p id="uc0e8c7f3" class="ne-p"><span class="ne-text"></span></p><p id="ua2dabb41" class="ne-p"><span class="ne-text">我的人生准则就是，假如我明天就死了，今天的我不会对我所做的任何事情感到后悔。</span></p><p id="b2dc5cb6d52f23fe6487d1760a025384" class="ne-p"><br></p><p id="d1ff7aabe7646884c71ea9990fadcd9b" class="ne-p"><span class="ne-text">我的行为准则很简单，但是并不代表我不懂，许多所谓的道理，我又何尝不懂，只是，我不害怕这个文明，不害怕这个文明所带来的种种。</span></p><p id="e277c3118e88ff9a64a6cb81c9eac6ed" class="ne-p"><br></p><p id="0cddda35c745c8a28a06dd4437db2736" class="ne-p"><span class="ne-text">我总是在坚守那些在其他人看来特别幼稚的事情，但是我却将其看得像珍宝一样珍贵</span></p><p id="d0439f7270971a59e10d3667c218eb94" class="ne-p"><br></p><p id="59473b30286f6680f96bf0d467a3a408" class="ne-p"><span class="ne-text">人如果没有信仰，没有坚守，那活着又有什么意义呢？</span></p><p id="uf2d17c7f" class="ne-p"><span class="ne-text"></span></p><p id="u59058a0c" class="ne-p"><strong><span class="ne-text">大学……</span></strong></p><p id="u7604627b" class="ne-p"><br></p><p id="u4019b73c" class="ne-p"><span class="ne-text">大学，只是我所经历的一站，我的前方依旧在那里，看起来很近，但是却也不近，大学快结束了，我想要的是近了还是远了……</span></p></div>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>配置GPG密钥来对GitHub做签名提交commit</title>
      <link href="/blog/go85d1/"/>
      <url>/blog/go85d1/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="42bd2d5ebf6401acbcfa2d5d5f734273" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1628854019765-b6022a63-5214-4d70-98b5-aec146cf1e6b.png" width="524" id="mqoXX" class="ne-image"></p><p id="4f10621b1ac85f0abd467b8356afb2ef" class="ne-p"><br></p><p id="1891e3f1aa952ffff092448715485f0c" class="ne-p"><span class="ne-text">前言：GitHub在提交代码的时候会出现是否验证的情况，如上图所示，出现这个机制的原因就是当利用name和email提交代码时，两个不同的人都可以提交（多人协同一个项目），为了代码更加的严密与可靠，就出现了GPG keys加重验证这一情况。</span></p><p id="0f41f994265f5f78f32a49bb7ba09225" class="ne-p"><span class="ne-text"></span></p><p id="762f0713131a16fd4cd18610c48d5d19" class="ne-p"><span class="ne-text">GPG密钥的具体逻辑应用到RSA算法，原理逻辑可参考之前写的一篇文章『</span><a href="https://www.wztlink1013.com/blog/ccd10c/" data-href="https://www.wztlink1013.com/blog/ccd10c/" target="_blank" class="ne-link"><span class="ne-text">RSA公钥密码算法 | 尼采般地抒情</span></a><span class="ne-text">』，该文也算是对该算法的一次应用。</span></p><hr id="krdEH" class="ne-hr"><h2 id="yF4YK"><span class="ne-text">一、创建gpg密钥</span></h2><p id="a05857b69218cdb73ac313e42c0d5441" class="ne-p"><span class="ne-text">在git Bash里面查看gpg版本</span></p><p id="e92b2e3f8a4a513b9a9def618c0df416" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1628854562240-df76109f-807c-46ec-93cc-eeb634181583.png" width="248" id="FSA2j" class="ne-image"></p><p id="uba621ea9" class="ne-p"><br></p><p id="4814b8f53b0b05e04def958672efc8d3" class="ne-p"><span class="ne-text">生成密钥</span></p><pre><code>gpg --full-generate-key</code></pre><p id="0c36ae9d901510b238ceab439e01bd73" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1628854642828-9298534e-2470-4440-a5d3-a0b4eebf9267.png" width="290" id="GLArL" class="ne-image"></p><p id="uf126e970" class="ne-p"><br></p><p id="1ad037c776638cabfd1c45964b01bbbc" class="ne-p"><span class="ne-text">列举已经创建好的密钥id</span></p><pre><code>gpg --list-secret-keys --keyid-format LONG</code></pre><p id="eadd38310d47c7777ee21a1d770ab12b" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1628854721166-1a7cf63a-8053-42aa-a365-9f4accc4cb40.png" width="246" id="fBUBe" class="ne-image"></p><p id="0edbc327c4a78841e4deab698907d237" class="ne-p"><br></p><div data-type="tips" class="ne-alert"><p id="8906efe46498590a79f058923b12f7fc" class="ne-p"><span class="ne-text" style="background-color: #FFF6B6">中途会弹出要设置密码，并且是两次弹出。</span></p></div><p id="u9962072f" class="ne-p"><br></p><p id="9237aa6bcdf488da490c35bbf9752d7f" class="ne-p"><span class="ne-text">查看密钥内容</span></p><pre><code>gpg --armor --export 10A9巴拉巴拉</code></pre><p id="16cd2775365117160f34038a1dd018ee" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1628854842847-28c1fb0a-ac3d-446b-b479-4c34a9d89d0d.png" width="235" id="jQgdw" class="ne-image"></p><h2 id="Divf6"><span class="ne-text">二、添加gpg密钥</span></h2><p id="022459be1af9049817901756d7835a0c" class="ne-p"><span class="ne-text">将上述控制台的密钥内容复制到GitHub的一下区域</span></p><p id="bb5883df540881786feeda6353e65ef0" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1628854955321-8c0648b4-2ed8-472a-b9a9-58638bf12b61.png" width="837.5" id="al61T" class="ne-image"></p><hr id="q1wax" class="ne-hr"><p id="40bdd7dea884ce83e2493fc8ad5f35d7" class="ne-p"><span class="ne-text">以下就是公钥和密钥内容</span></p><p id="dbf1ab26d8bb9591d6b1ca7a8562e7c1" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1628856682736-35e744c2-8f28-425f-8a4c-fe9236cd8616.png" width="586.5" id="naOHh" class="ne-image"></p><h2 id="BVLAu"><span class="ne-text">三、本地设置gpg密钥</span></h2><p id="107d83064cf0663d7f4ef54c584a98d0" class="ne-p"><span class="ne-text">将gpg密钥添加到本地设置中</span></p><pre><code>git config --global user.signingkey 10A9巴拉巴拉</code></pre><p id="2d87149a54b40e9f642314b53646b674" class="ne-p"><span class="ne-text">在所有项目中设置签名验证</span></p><pre><code>git config --global commit.gpgsign true</code></pre><h2 id="DS7c2"><span class="ne-text">四、使用</span></h2><p id="718c79b7e92e6d61c7c03e22b9fdd800" class="ne-p"><span class="ne-text">在提交代码的时候，会弹出该提示框，这就是在设置密码时候的密码（密钥）。</span></p><p id="96527d4a09b6fe6dfd4eb2d3de6846ed" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1628855341009-92cccb8c-0007-4361-8d42-778002d554e8.png" width="345.5" id="dLIY1" class="ne-image"></p><p id="50d998aabb61977a0236134dad953c61" class="ne-p"><br></p><h2 id="YU0Pr"><span class="ne-text">参考</span></h2><ul class="ne-ul"><li id="0284af9faa553fbbd031f2a0067408dc"><a href="https://www.ruanyifeng.com/blog/2013/07/gpg.html" data-href="https://www.ruanyifeng.com/blog/2013/07/gpg.html" class="ne-link"><span class="ne-text">GPG入门教程 作者： 阮一峰</span></a></li><li id="e2e39f1a038f5d13a6d69d6cabc56c0f"><a href="https://www.jianshu.com/p/195cac3a2b2c" data-href="https://www.jianshu.com/p/195cac3a2b2c" class="ne-link"><span class="ne-text">使用gpg密钥验证github提交</span></a></li></ul></div>]]></content>
      
      
      <categories>
          
          <category> 计算机素养 </category>
          
          <category> Git+GitHub </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/blog/helloworld/"/>
      <url>/blog/helloworld/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><hr id="a7SKe" class="ne-hr"><p id="ud33e8116" class="ne-p"><span class="ne-text">date: 2020-01-04 20:32:23</span></p><hr id="S8izF" class="ne-hr"><p id="u0debb705" class="ne-p"><br></p><p id="ue0e148d7" class="ne-p"><span class="ne-text">Welcome to </span><a href="https://hexo.io/" data-href="https://hexo.io/" target="_blank" class="ne-link"><span class="ne-text">Hexo</span></a><span class="ne-text">! This is your very first post. Check </span><a href="https://hexo.io/docs/" data-href="https://hexo.io/docs/" target="_blank" class="ne-link"><span class="ne-text">documentation</span></a><span class="ne-text"> for more info. If you get any problems when using Hexo, you can find the answer in </span><a href="https://hexo.io/docs/troubleshooting.html" data-href="https://hexo.io/docs/troubleshooting.html" target="_blank" class="ne-link"><span class="ne-text">troubleshooting</span></a><span class="ne-text"> or you can ask me on </span><a href="https://github.com/hexojs/hexo/issues" data-href="https://github.com/hexojs/hexo/issues" target="_blank" class="ne-link"><span class="ne-text">GitHub</span></a><span class="ne-text">.</span></p><h2 id="411eaaaa"><span class="ne-text">Quick Start</span></h2><p id="u697744a0" class="ne-p"><br></p><h3 id="ff46be02"><span class="ne-text">Create a new post</span></h3><p id="u505f5ff0" class="ne-p"><br></p><pre><code>$ hexo new &quot;My New Post&quot;</code></pre><p id="u0a0c001c" class="ne-p"><br></p><p id="u6f4f908f" class="ne-p"><span class="ne-text">More info: </span><a href="https://hexo.io/docs/writing.html" data-href="https://hexo.io/docs/writing.html" target="_blank" class="ne-link"><span class="ne-text">Writing</span></a></p><p id="u66c42358" class="ne-p"><br></p><h3 id="148bf910"><span class="ne-text">Run server</span></h3><p id="ub6078bd4" class="ne-p"><br></p><pre><code>$ hexo server</code></pre><p id="u07e4927e" class="ne-p"><br></p><p id="u48f410ea" class="ne-p"><span class="ne-text">More info: </span><a href="https://hexo.io/docs/server.html" data-href="https://hexo.io/docs/server.html" target="_blank" class="ne-link"><span class="ne-text">Server</span></a></p><p id="ubb8d507e" class="ne-p"><br></p><h3 id="25efabb0"><span class="ne-text">Generate static files</span></h3><p id="ueb4659ec" class="ne-p"><br></p><pre><code>$ hexo generate</code></pre><p id="ufc85958c" class="ne-p"><br></p><p id="u06260396" class="ne-p"><span class="ne-text">More info: </span><a href="https://hexo.io/docs/generating.html" data-href="https://hexo.io/docs/generating.html" target="_blank" class="ne-link"><span class="ne-text">Generating</span></a></p><p id="u1e01da08" class="ne-p"><br></p><h3 id="fb21a764"><span class="ne-text">Deploy to remote sites</span></h3><p id="uc2c13a6f" class="ne-p"><br></p><pre><code>$ hexo deploy</code></pre><p id="u54dc7717" class="ne-p"><br></p><p id="ued59f51e" class="ne-p"><span class="ne-text">More info: </span><a href="https://hexo.io/docs/one-command-deployment.html" data-href="https://hexo.io/docs/one-command-deployment.html" target="_blank" class="ne-link"><span class="ne-text">Deployment</span></a></p></div>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
          <category> 玩转博客 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>『花束般的恋爱』——“我认识了一个和我想法一样的人”</title>
      <link href="/essay/qraopm/"/>
      <url>/essay/qraopm/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="u22a66168" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1627879984472-b6f94d18-7055-4be5-9cb6-8a550e5342d3.png" width="1911" id="udf56b2ff" class="ne-image"></p><p id="u5f49ad95" class="ne-p"><br></p><p id="ucae40f69" class="ne-p"><span class="ne-text">看完之后的感受：</span><strong><span class="ne-text">始于心动，败于现实</span></strong><span class="ne-text">。</span></p><p id="uda3e74e7" class="ne-p"><br></p><p id="u50e01ea1" class="ne-p"><span class="ne-text">恋爱不是婚姻，因为中间有现实，但现实只是一个因素，在这个因素下，有的人忘却了曾经想要守护的，有的人想守住曾经，有的人幡然悔悟，有的人却早已失望并且走远……</span></p><p id="u6c6292df" class="ne-p"><br></p><p id="u739c65bc" class="ne-p"><span class="ne-text">这可能就是爱情和婚姻的不同吧。我也很幼稚，但是我想试试几年之后的我再看这篇文章会是什么感悟……</span></p><p id="u6e0614c2" class="ne-p"><br></p><hr id="G9wgh" class="ne-hr"><p id="u6dcd1e92" class="ne-p"><br></p><h2 id="v8t7Q"><span class="ne-text">“我认识了一个和我想法一样的人”</span></h2><p id="ud865d1f4" class="ne-p"><span class="ne-text">这就是相同的灵魂的碰撞，我相信巧合，真的相信。交谈有无数种，但是那种契合灵魂的交谈真的只有那个对的人才会有。</span></p><p id="u85bc468b" class="ne-p"><br></p><p id="u58d0633e" class="ne-p"><span class="ne-text">“我们好像，你就像是另一个世界的我一样”，就是那种你不用多言，也能感受到对方将要表达出来的感受。那绝对是亲身经历才能长存心间的事情。</span></p><p id="u0dea7a60" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1627880340235-0ee52649-ef7e-4a7b-94b4-81ca645fd24c.png" width="960" id="uc6f2af4b" class="ne-image"></p><p id="u3fc85688" class="ne-p"><br></p><p id="ua9f48cef" class="ne-p"><br></p><h2 id="W5xJs"><span class="ne-text">爱情中的智者？</span></h2><p id="uf0cfa697" class="ne-p"><span class="ne-text">生活中总会有人去告诉你一些道理，像是扮演者一个智者的角色。片中爱情博客博主芽衣就是这么一个角色。</span></p><p id="u46d8b5d9" class="ne-p"><br></p><div class="ne-quote"><p id="u2c01f862" class="ne-p"><span class="ne-text">相遇总是伴随着离别</span></p><p id="ue162fa9a" class="ne-p"><span class="ne-text">恋爱就像派对  总有一天会结束 </span></p><p id="ufee0c56b" class="ne-p"><span class="ne-text">所以恋爱的人</span></p><p id="u75f3644b" class="ne-p"><span class="ne-text">总是喜欢将迷恋的东西夹在书桌里</span></p><p id="u8c6749bb" class="ne-p"><span class="ne-text">再分享他们的爱情</span></p><p id="ud64f8980" class="ne-p"><span class="ne-text">因为他们只能享受这份悲伤</span></p><p id="u09069c2e" class="ne-p"><span class="ne-text">虽然爱情的存存活率极小</span></p><p id="u50fb7f96" class="ne-p"><span class="ne-text">但我的爱情会活下来</span></p></div><p id="uda2fa691" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1627881603601-6bb986d5-c12b-4710-8a56-cbefe8667501.png" width="960" id="u4405a4e6" class="ne-image"><span class="ne-text"> </span></p><p id="u40b0dc2e" class="ne-p"><br></p><div class="ne-quote"><p id="uc9f994e3" class="ne-p"><span class="ne-text">芽衣算是看到爱情的死亡吗？</span></p><p id="u3bfdacbd" class="ne-p"><span class="ne-text">她顺应了爱情的结束吗？</span></p><p id="u84a048e0" class="ne-p"><span class="ne-text">我只能去想象</span></p><p id="u2aaf8e51" class="ne-p"><span class="ne-text">而且也不打算  把它套用在自己的爱情上面</span></p><p id="u7a58441e" class="ne-p"><span class="ne-text">只是 我们的派对</span></p><p id="u2445e462" class="ne-p"><span class="ne-text">现在正在高潮部分</span></p></div><p id="uaf99aa6b" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1627881791016-85d417b3-119a-4c33-8e0f-927071017501.png" width="960" id="u9d16aabc" class="ne-image"></p><p id="u3ac5ff8d" class="ne-p"><br></p><h2 id="mQQbR"><span class="ne-text">现实会让你忘掉恋爱中最初的自己吗？</span></h2><p id="ue5fd01ad" class="ne-p"><span class="ne-text">我不知道，我没能看得见未来那个阶段的自己。</span></p><p id="ue5d791a6" class="ne-p"><br></p><p id="ue88fdd3d" class="ne-p"><span class="ne-text">女主工作初期的失意，以及男主工作中的起势和落魄，这可能就是常人说的现实把。现实让两个人褪去了太多色彩，但是一直坚守的是女主，同样是落魄，男主的陪伴和女主的陪伴换来的结果全然不样，没有好好珍惜把。</span></p><p id="u1a113d65" class="ne-p"><br></p><p id="u9865bfe1" class="ne-p"><span class="ne-text">人会变，也没有谁能够一直陪着谁。</span></p><p id="uedd5c011" class="ne-p"><br></p><p id="ua6f5a461" class="ne-p"><span class="ne-text">人都是个体……</span></p><p id="u613c674f" class="ne-p"><br></p><h2 id="Tq5qu"><span class="ne-text">感性 VS 理性</span></h2><p id="uc2bc6cc8" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1627883190252-ec419a89-4711-4126-aa45-5bf708930312.png" width="960" id="uca4b5a69" class="ne-image"></p><div data-type="info" class="ne-alert"><p id="uc51ad6c8" class="ne-p"><span class="ne-text">男主和女主最后的那段话，这段对话算是完完全全交代了两个人的终点。</span></p></div><p id="u03a88e41" class="ne-p"><br></p><div class="ne-quote"><p id="uff22c6b7" class="ne-p"><span class="ne-text">谢谢你</span></p></div><p id="ue0d3f9a7" class="ne-p"><br></p><div class="ne-quote"><p id="u37b5740a" class="ne-p"><span class="ne-text">小娟</span></p><p id="u96d4fd08" class="ne-p"><span class="ne-text">我不想分手</span></p><p id="ue0c63850" class="ne-p"><span class="ne-text">我觉得不用分手</span></p><p id="u7ef288cb" class="ne-p"><span class="ne-text">我们结婚吧</span></p><p id="u1f521711" class="ne-p"><span class="ne-text">结婚后</span></p><p id="ue75cc7e1" class="ne-p"><span class="ne-text">和以前一样</span></p><p id="u0efe5ecb" class="ne-p"><span class="ne-text">一起过日子吧</span></p><p id="udab251c8" class="ne-p"><span class="ne-text">没关系的</span></p></div><p id="ucb7d57b9" class="ne-p"><br></p><p id="u227cff08" class="ne-p"><br></p><div class="ne-quote"><p id="u25045beb" class="ne-p"><span class="ne-text">因为今天很开心所以你才会这么想</span></p><p id="u400965e1" class="ne-p"><span class="ne-text">我们又会回到以前那样</span></p></div><p id="u8d714314" class="ne-p"><br></p><div class="ne-quote"><p id="udd3ef590" class="ne-p"><span class="ne-text">我觉得没什么不好</span></p><p id="uc395de1a" class="ne-p"><span class="ne-text">这世上结婚的夫妻</span></p><p id="u1446fb87" class="ne-p"><span class="ne-text">大家不都是如此吗</span></p><p id="uc2a42996" class="ne-p"><span class="ne-text">都会慢慢忘记恋爱的感觉</span></p><p id="ud41c4240" class="ne-p"><span class="ne-text">不是也有结婚之后  继续这样过日子的人吗</span></p><p id="u98618816" class="ne-p"><span class="ne-text">就算感情变了</span></p><p id="u4efa80b2" class="ne-p"><span class="ne-text">不开心的事 就睁一只眼闭一只眼</span></p><p id="u1ea536a5" class="ne-p"><span class="ne-text">继续过日子  有这样的人的</span></p><p id="u81d8d840" class="ne-p"><span class="ne-text">我和你</span></p></div><p id="u52d5bbb4" class="ne-p"><br></p><div class="ne-quote"><p id="u3dff18a7" class="ne-p"><span class="ne-text">又要降低标准吗</span></p><p id="uebfd216d" class="ne-p"><span class="ne-text">降低标准</span></p><p id="u20106d10" class="ne-p"><span class="ne-text">然后想  就这样过吧</span></p><p id="ue58221d7" class="ne-p"><span class="ne-text">这样你就满意吗</span></p></div><p id="u4c953b14" class="ne-p"><br></p><div class="ne-quote"><p id="u11e5a2d5" class="ne-p"><span class="ne-text">满意</span></p><p id="u617feb85" class="ne-p"><span class="ne-text">不可能像以前一样喜欢啊</span></p><p id="u63df5a20" class="ne-p"><span class="ne-text">如果追求这种事就无法幸福了</span></p><p id="u69b1f3db" class="ne-p"><span class="ne-text">会不停地吵架</span></p><p id="uafb61969" class="ne-p"><span class="ne-text">不也是因为恋爱的感觉在捣乱吗</span></p><p id="u45882bbb" class="ne-p"><span class="ne-text">现在成为一家人的话</span></p><p id="u6c4cf163" class="ne-p"><span class="ne-text">我觉得能和你过好</span></p><p id="u1ab9ed12" class="ne-p"><span class="ne-text">生个孩子  孩子管我叫爸爸  管你叫妈妈</span></p><p id="u2e1fae82" class="ne-p"><span class="ne-text">我都能想象到那一幕</span></p><p id="u7a641f41" class="ne-p"><span class="ne-text">三个人或者四个人手牵着手一起去多摩川边散步吧</span></p><p id="u5ad2dbeb" class="ne-p"><span class="ne-text">推着婴儿车一起去逛高岛屋吧</span></p><p id="ubb95e8c0" class="ne-p"><span class="ne-text">买一辆车</span></p><p id="u417b59f8" class="ne-p"><span class="ne-text">去野营  去迪士尼乐园</span></p><p id="u907c89b3" class="ne-p"><span class="ne-text">花时间  一起过完这辈子</span></p><p id="u3d8694f0" class="ne-p"><span class="ne-text">他们俩虽然一起经历了很多事情</span></p><p id="ue334d411" class="ne-p"><span class="ne-text">但现在变成了一堆关系很好的夫妻</span></p><p id="u83c33db1" class="ne-p"><span class="ne-text">你中有我  我中有你</span></p><p id="ue53adf13" class="ne-p"><span class="ne-text">我们变成这样的关系吧</span></p><p id="u42130182" class="ne-p"><span class="ne-text">结婚吧  一起变幸福吧</span></p></div><p id="u15eff770" class="ne-p"><br></p><div class="ne-quote"><p id="u7c54de8f" class="ne-p"><span class="ne-text">你说的可能没错</span></p><p id="uc4b53c4e" class="ne-p"><span class="ne-text">是啊</span></p><p id="ud5023fe5" class="ne-p"><span class="ne-text">如果我们结婚了</span></p><p id="u37c9c63d" class="ne-p"><span class="ne-text">成为了家人</span></p></div><p id="u8b772e27" class="ne-p"><span class="ne-text">没有结局了……</span></p><p id="u091dfd5f" class="ne-p"><br></p><p id="u825d7cda" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1627883840887-418d2c4a-2209-4fec-b839-7f85c8bacb17.png" width="960" id="dQsNl" class="ne-image"></p><p id="udde4ec35" class="ne-p"><br></p><div data-type="info" class="ne-alert"><p id="u69f572ed" class="ne-p"><span class="ne-text">始于心动，败于现实，这是我所能想到的，两人的爱情被磨没了，而这之中，对现实的无能为力才是罪魁祸首……</span></p></div><p id="uc119e114" class="ne-p"><br></p><p id="u86cef349" class="ne-p"><br></p></div>]]></content>
      
      
      <categories>
          
          <category> 影视 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>『士兵突击』</title>
      <link href="/essay/qd0o6r/"/>
      <url>/essay/qd0o6r/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content-editor-core lake-engine lake-typography-classic" data-lake-element="root" data-selection-undefined="%7B%22path%22%3A%5B%5B7%2C0%2C51%5D%2C%5B7%2C0%2C51%5D%5D%2C%22active%22%3Atrue%7D"><p data-lake-id="ua79cadc0" id="ua79cadc0" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span data-card-type="inline" data-lake-card="image" id="udb87ee1e" class="lake-card-margin-top lake-card-margin-bottom"><img data-role="image" src="https://cdn.nlark.com/yuque/0/2021/webp/1484158/1627457976739-9801a315-02f3-4f5f-b590-6b2a532749a7.webp" data-raw-src="" class="image lake-drag-image" alt="image" title="image" data-height="360px" style="visibility: visible; width: 270px;"></span></p><p data-lake-id="uc43a5495" id="uc43a5495" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="u30e7b7e4" id="u30e7b7e4" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>前言：人生导师级别的一部军旅影视，看完电视剧变买了这本小说一边看完。</span></p><p data-lake-id="0f7a058a54a40e288f29b6dc5d143e5f" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span><br></span></p><h2 data-lake-id="a5133cb03312e62e22133bbbb3573172" id="77PfS" style="padding: 7px 0px; margin: 0px; font-weight: 700; font-size: 24px; line-height: 32px;">小说</h2><p data-lake-id="71b218d590149e15a2d338d72f124a87" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">第二章</p><p data-lake-id="d801c1cfdda58c4fcd0f62ed87cfc851" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="45e2571a5a7586e52903f99f47e11eeb" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">史今班长的温柔和同情，对他而言，像是看到曾经刚入部队的自己，以至于做出绝不可能而又做出的感性的选择……</p><p data-lake-id="f50e31ddeea8b86e4e841e631511c328" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="8971f4389904dd8a5ded34ddc6b8057a" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">以前在初中，是住校的，那时我班上也有一个和许三多一样的同学，我甚至还记得他叫什么，他叫程伊星，他就是看起来傻傻的，也比我们大一两岁，行为举动像是小孩子，也不谙世事，总是成为同学之间玩乐嬉戏的对象。</p><p data-lake-id="f0ecc1c9bdb7b8e86f763edf8f0b68fd" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="6d21a7ade99f2f57aaa4558d4ecc874e" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">记得有一次夏季的体育课，我回宿舍，看见他躺在床上整理被子（他是作息及其规律，内务极其规整的一个学生），那时我们聊了会天，我觉得我以前初中和谁都能说得出心里话的那种，当时好像是问他为什么不和我们一起玩，忘了他是怎么回答的，只记得他说了一番话，具体也记不清，但是说出的话就像是滑稽的哲理一般，就像是背诵了书里面的词句一样的人生态度。他收拾完之后，他就习惯性地坐在床上，跟我聊天，多的记不清了，我只知道他是一个读书人，但就像是尚未入世一样……</p><p data-lake-id="1e18f8d95c1e65a9b28fa95b0bb2ddf2" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="73e670e02c44652af26e79d1f34f71f8" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">如今在键盘上敲字的我苦笑，敲到<strong>入世</strong>两个字，我也看到了自己的些许狼狈，我不知道什么是成长，但我真的也从家乡那个小城走出来，过往的经历就像是坚毅面庞背后的幸酸，<strong>可这个社会制度下，这个文明框架下，不就是充斥着过多的悲哀么，而我们大多数人都是向着死而生</strong>。</p><div data-card-type="block" data-lake-card="hr"><hr style="background-color: rgb(232, 232, 232); border: 1px solid transparent; margin: 18px 0px;"></div><p data-lake-id="d5a588b42e08846c8000104fd2869127" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="u37a22136" id="u37a22136" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><h2 data-lake-id="41aed8a8db4b7d33bbde8fc90b8959c6" id="WhvVJ" style="padding: 7px 0px; margin: 0px; font-weight: 700; font-size: 24px; line-height: 32px;">影视</h2><div data-card-type="block" data-lake-card="hr" id="ErMZ7"><hr style="background-color: rgb(232, 232, 232); border: 1px solid transparent; margin: 18px 0px;"></div><p data-lake-id="146985790e8223b739b7528750295713" id="146985790e8223b739b7528750295713" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>10集</span></p><p data-lake-id="50c304a2049362301cf57da667c81b2d" id="50c304a2049362301cf57da667c81b2d" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="6e1c87ddcc5263b203a43da6731910ec" id="6e1c87ddcc5263b203a43da6731910ec" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>战友的帮助成就了一个兵，班长的“牺牲”造就了一个兵王。</span></p><p data-lake-id="fdcd11b21ed0576db495d025c8b6680a" id="fdcd11b21ed0576db495d025c8b6680a" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>这是部队里面才有的。</span></p><p data-lake-id="a31a46b66b5cf0bd692c6bbb96493b3a" id="a31a46b66b5cf0bd692c6bbb96493b3a" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="c329be5ed7ad045898f47b737e1c93a8" id="c329be5ed7ad045898f47b737e1c93a8" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>这就像是，重情义的往往是那些曾经成绩不好的后排生，但是会为了彼此扛刀的同学。</span></p><p data-lake-id="2b96f701b3efb2bb2fb3fb9239932ad6" id="2b96f701b3efb2bb2fb3fb9239932ad6" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>懂“不抛弃不放弃”远远比成为兵王更重要，真的。</span></p><p data-lake-id="47d7cb7cebab32d2d43decf756a61b64" id="47d7cb7cebab32d2d43decf756a61b64" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="df676c19a2090acc784ebd5f13b05297" id="df676c19a2090acc784ebd5f13b05297" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>成才最后被老A刷下的那般落魄，真的是曾经没有领悟那六个字所造成的结果。</span></p><p data-lake-id="f864a61177d3ec503436cc57c1f95fd0" id="f864a61177d3ec503436cc57c1f95fd0" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="e6df67c6365c71a8cedc414130aec622" id="e6df67c6365c71a8cedc414130aec622" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>人做事真的不要太急了，踏实，稳固，远比结果更重要，并且到最后，你还会发现，人如果走的踏实，结果都不会太差的。</span></p><p data-lake-id="e826a531d18d60c3b7c2c9cef5738d30" id="e826a531d18d60c3b7c2c9cef5738d30" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><div data-card-type="block" data-lake-card="hr" id="a6GJX"><hr style="background-color: rgb(232, 232, 232); border: 1px solid transparent; margin: 18px 0px;"></div><p data-lake-id="23b445e1c9906f7859bddec7691de2b5" id="23b445e1c9906f7859bddec7691de2b5" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>16集</span></p><p data-lake-id="529f488dd86e9d194962594be53d5265" id="529f488dd86e9d194962594be53d5265" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><blockquote style="margin-top: 5px; margin-bottom: 5px; padding-left: 1em; margin-left: 0px; border-left: 3px solid rgb(238, 238, 238); opacity: 0.6;"><p data-lake-id="03a257be0ea28267c0c1980f426d78ed" id="03a257be0ea28267c0c1980f426d78ed" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>早熟的人往往都很晚熟</span></p><p data-lake-id="baaff50bed78e7dad90baa150aec233e" id="baaff50bed78e7dad90baa150aec233e" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>骄傲的人又很急性</span></p></blockquote><div data-card-type="block" data-lake-card="hr" id="BDEqt"><hr style="background-color: rgb(232, 232, 232); border: 1px solid transparent; margin: 18px 0px;"></div><p data-lake-id="b40ccf37aed85ff9db7ee51fc0554d63" id="b40ccf37aed85ff9db7ee51fc0554d63" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>17集</span></p><p data-lake-id="1a56aa11c4b3887dae8f7f1cc7b2a2cc" id="1a56aa11c4b3887dae8f7f1cc7b2a2cc" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="6794a5bb79c3cf74d75d799c54290578" id="6794a5bb79c3cf74d75d799c54290578" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><strong><span>三多的士官和复员决定与否之路</span></strong></p><p data-lake-id="9e33345b8e01db2a145a02e7891d083d" id="9e33345b8e01db2a145a02e7891d083d" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="36bf33bac1ec8cd4961e750768e21995" id="36bf33bac1ec8cd4961e750768e21995" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>高城走了之后，七连只剩下许三多一个兵</span></p><p data-lake-id="20a112a7b3c72e88e62787996e7014c6" id="20a112a7b3c72e88e62787996e7014c6" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>一个兵守一个连……</span></p><p data-lake-id="c33dcabbeea89cfad3de368598c3b5d2" id="c33dcabbeea89cfad3de368598c3b5d2" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>就是这样，这种历练是何等的孤独，兵王就是兵王，耐得住寂寞。一个人唱战歌，一个人守住仪式，一个人过一整个夜晚，一个人面对整个连的回忆。</span></p><p data-lake-id="7b51e748560e33427fb5d73b84f5f568" id="7b51e748560e33427fb5d73b84f5f568" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="ee7af3bfacd13d18381b6f4a140655ff" id="ee7af3bfacd13d18381b6f4a140655ff" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>难，真的难。这种人真的厉害</span></p><p data-lake-id="2e28f429f41afa2f7f56197ceed239b0" id="2e28f429f41afa2f7f56197ceed239b0" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="878187c29c141527629bded4a2a7f485" id="878187c29c141527629bded4a2a7f485" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>一个月和别人说话不超过十句话，其他的都是自己和自己说话。</span></p><p data-lake-id="c5923e98320b7904677367a44b2d9282" id="c5923e98320b7904677367a44b2d9282" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="1c41f5b83bb2068da62dd4677e166b80" id="1c41f5b83bb2068da62dd4677e166b80" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>伍六一在这个时候其实是最担心三多的。</span></p><p data-lake-id="0467364aee8d5154a94e3f8f9dbb2d2b" id="0467364aee8d5154a94e3f8f9dbb2d2b" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><div data-card-type="block" data-lake-card="hr" id="OZGwh"><hr style="background-color: rgb(232, 232, 232); border: 1px solid transparent; margin: 18px 0px;"></div><p data-lake-id="u6efa79aa" id="u6efa79aa" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>18集</span></p><p data-lake-id="u35d7c6aa" id="u35d7c6aa" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="u161019ec" id="u161019ec" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>袁朗第一次去找许三多对他的评价：</span></p><blockquote style="margin-top: 5px; margin-bottom: 5px; padding-left: 1em; margin-left: 0px; border-left: 3px solid rgb(238, 238, 238); opacity: 0.6;"><p data-lake-id="253eff5fd34fac335ceb85813ea17c42" id="253eff5fd34fac335ceb85813ea17c42" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><strong><span>怎么样  一个人在这守了半年</span></strong></p><p data-lake-id="ud47bc571" id="ud47bc571" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><strong><span>不好不坏  不高不低的一个兵</span></strong></p><p data-lake-id="u5ebcf310" id="u5ebcf310" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><strong><span>一个很安分的兵</span></strong></p><p data-lake-id="ue16b3f84" id="ue16b3f84" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><strong><span>不太焦虑  耐得住寂寞</span></strong></p><p data-lake-id="u122edf3b" id="u122edf3b" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><strong><span>有很多人天天都在焦虑</span></strong></p><p data-lake-id="u37ab8c56" id="u37ab8c56" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><strong><span>怕没得到  怕寂寞</span></strong></p><p data-lake-id="u6deafebd" id="u6deafebd" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><strong><span>我喜欢不焦虑的人</span></strong></p></blockquote><p data-lake-id="udd308025" id="udd308025" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><blockquote style="margin-top: 5px; margin-bottom: 5px; padding-left: 1em; margin-left: 0px; border-left: 3px solid rgb(238, 238, 238); opacity: 0.6;"><p data-lake-id="ue85fad82" id="ue85fad82" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>我，其实我骨子里 骨子里可笨了</span></p><p data-lake-id="uc9b2d748" id="uc9b2d748" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>每一次换一次新的环境</span></p><p data-lake-id="u3bfb0767" id="u3bfb0767" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>我就跟死过一次似的</span></p><p data-lake-id="u1ee0f83d" id="u1ee0f83d" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>你一个人呆在这是怕鬼把？</span></p><p data-lake-id="u3a27cad8" id="u3a27cad8" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>这世界上根本就没有鬼</span></p><p data-lake-id="u6afaca77" id="u6afaca77" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>那就奇怪了</span></p><p data-lake-id="ud26d9397" id="ud26d9397" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><strong><span>鬼和你怕的事情不都是想出来的自己吓唬自己的吗</span></strong></p></blockquote><div data-card-type="block" data-lake-card="hr" id="IVc5Q"><hr style="background-color: rgb(232, 232, 232); border: 1px solid transparent; margin: 18px 0px;"></div><p data-lake-id="b79be21dbb5a04b02fb48de4e875900a" id="b79be21dbb5a04b02fb48de4e875900a" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>19集</span></p><p data-lake-id="a3cb9fcd1190e8e0580ff08485665074" id="a3cb9fcd1190e8e0580ff08485665074" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="9fa77668b13fd20191ce42c8845fefd7" id="9fa77668b13fd20191ce42c8845fefd7" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>参加老A集训，成才，伍六一，许三多，甘小宁……</span></p><p data-lake-id="b234f940a1d01283f36e6f4690914f4b" id="b234f940a1d01283f36e6f4690914f4b" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="6b250069e37dade86b19b60f9114d548" id="6b250069e37dade86b19b60f9114d548" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>伍六一里面对</span></p><div data-card-type="block" data-lake-card="hr" id="jAC5r"><hr style="background-color: rgb(232, 232, 232); border: 1px solid transparent; margin: 18px 0px;"></div><p data-lake-id="cf61a410b429cb718f20351bbcc318d8" id="cf61a410b429cb718f20351bbcc318d8" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>20集</span></p><p data-lake-id="d12002f45cda91a49af194b2679f5b6c" id="d12002f45cda91a49af194b2679f5b6c" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="dc1dd61a8715ff3b4f0870215cac83aa" id="dc1dd61a8715ff3b4f0870215cac83aa" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>人不是靠做出来的，而是靠活出来的</span></p><p data-lake-id="13c449eb41bae7b2b68218702028d377" id="13c449eb41bae7b2b68218702028d377" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>就像你，不仅守住了军营，还守住了你自己</span></p><p data-lake-id="732fc389631cd12faa31c84f28d9697e" id="732fc389631cd12faa31c84f28d9697e" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="0311ccc2d44f8b49723683e4886932de" id="0311ccc2d44f8b49723683e4886932de" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><div data-card-type="block" data-lake-card="hr" id="i59gR"><hr style="background-color: rgb(232, 232, 232); border: 1px solid transparent; margin: 18px 0px;"></div><p data-lake-id="ue155cd1e" id="ue155cd1e" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>五班</span></p><p data-lake-id="u044e262f" id="u044e262f" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="uf03a40bd" id="uf03a40bd" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>五班是许三多和成才都经历过的一个地方，这部剧里面有太多的亮点，但我印象最深最深的就是五班，一望无际的草原，有人觉得是束缚，又有人觉得是天堂，环境足以磨灭一个人的信仰，经得起磨练的人才真的是人才。</span></p><p data-lake-id="uf02b3188" id="uf02b3188" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="u5ab05f30" id="u5ab05f30" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>成才两次去过五班，第一次是部队整编自己去的五班，第二次是被老A打回五班</span></p><p data-lake-id="u48a39f70" id="u48a39f70" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="u4b6506d0" id="u4b6506d0" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span data-card-type="inline" data-lake-card="image" id="u4771e254" class="lake-card-margin-top lake-card-margin-bottom"><img data-role="image" src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1628321067461-42092030-1b62-4a01-9ca6-f36195ef3a22.png" data-raw-src="" class="image lake-drag-image" alt="image.png" title="image.png" data-height="381px" style="visibility: visible; width: 736.5px;"></span></p><p data-lake-id="u03c286ff" id="u03c286ff" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>最后的五班，是由成才炼好的！</span></p><p data-lake-id="u8376ce0d" id="u8376ce0d" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><div data-card-type="block" data-lake-card="hr" id="AYeDf"><hr style="background-color: rgb(232, 232, 232); border: 1px solid transparent; margin: 18px 0px;"></div><p data-lake-id="u24166b9c" id="u24166b9c" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>七连</span></p><p data-lake-id="uf939680e" id="uf939680e" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="u533571b7" id="u533571b7" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>在这里面真的学会很多，比技术和荣誉更重要的是——“不抛弃，不放弃”的人生信念。</span></p><p data-lake-id="u7c89579c" id="u7c89579c" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>其实你会发现在七连不是所有人都是厉害的，但是他们都是最“靠谱”的，最敢拼的，集体荣誉感极强。还没有成长的成才和许三多在这里面就是两个极端，一个能力极强，但功利心极强，一个能力太低，不谙世事。</span></p><p data-lake-id="u9e46a94d" id="u9e46a94d" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>就是两个这样的人最后都是兵王，能力强和弱的两个极端，在他们两个人成为一个人才的时间，我个人觉得是对那六个字的理解。</span></p><p data-lake-id="u6b485c98" id="u6b485c98" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p></div>]]></content>
      
      
      <categories>
          
          <category> 影视 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>菜鸡重学i++和++i</title>
      <link href="/blog/smpdcq/"/>
      <url>/blog/smpdcq/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="e0e5744708b55a241fcb228636fbcb4d" class="ne-p"><span class="ne-text">前言：for循环里面的i++和++i在平时使用感觉是几乎一样的，但是之前写代码，特别是数据结构课程学链表那会，经常需要做的就是一个节点的next指向什么才结束这样一种情况，当时总是不自觉地将i++调整为++i就能运行成功，这个点比较模糊，查资料才发现存在</span><strong><span class="ne-text">只有++i可以返回左值</span></strong><span class="ne-text">这一情况。</span></p><hr id="OUPno" class="ne-hr"><p id="5485f1bfe8a61ef5dd33e673b9622eaf" class="ne-p"><br></p><p id="44c7f74649c7bf9394e73fb54c8b8883" class="ne-p"><span class="ne-text">先来一段常规使用：</span></p><p id="f8ced571d1f25307cb8758c620911566" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1627270650151-857f8953-7e79-4055-a838-2b26b96aaf0a.png" width="522.5" id="sNaU2" class="ne-image"></p><p id="de2db062bf48f2e3a74c66707456022c" class="ne-p"><span class="ne-text">这个没有相关的差别</span></p><p id="015df9c2629edee9a1a1bb482a362ffd" class="ne-p"><br></p><p id="c6e17fcee2b794b85c65b56335443644" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1627271346217-4ae80a1d-979b-42cd-b6ff-8fdc271926ab.png" width="544.5" id="kmxHY" class="ne-image"></p><p id="83f75ad28b6011423f8f326d34c1529a" class="ne-p"><span class="ne-text">一个返回+之前的值一个返回+之后的值，也是字面理解。</span></p><p id="ecc2db8646a888e68a78823d1509e587" class="ne-p"><br></p><div class="ne-quote"><p id="a5c77516ff5f7b541316a3f42f4fb677" class="ne-p"><span class="ne-text">左值：在内存存储空间里面有确定的存储地址的值。</span></p><p id="02e5fffdefe3ea4c1c6f973091f7fcd0" class="ne-p"><span class="ne-text">判断是否为左值：看是否允许取地址&amp;运算符获得对应的内存地址。</span></p></div><p id="959f3baabc345c9cc324f27420f5d16f" class="ne-p"><strong><span class="ne-text">++i可以返回左值，i++不可以。</span></strong><span class="ne-text">（下面的截图对i++报错，对++i没有报错）</span></p><p id="21fafa6a5e8632dfc317f4ace858cc73" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1627437597153-a59bb261-e406-46f3-8bbb-34af9278b55d.png" width="761" id="Kc6Sg" class="ne-image"></p><p id="9d49f8f0301781a9f1e005e831f42923" class="ne-p"><br></p><p id="8cbc579eae24cf1243b7dc48adb8cbc3" class="ne-p"><span class="ne-text">i++和++i的实现：</span></p><pre><code>// 前缀形式：++iint&amp; int::operator++() //这里返回的是一个引用形式，就是说函数返回值也可以作为一个左值使用&#123;//函数本身无参，意味着是在自身空间内增加1的  *this += 1;  // 增加  return *this;  // 取回值&#125;<p>//后缀形式：i++<br>const int int::operator++(int) //函数返回值是一个非左值型的，与前缀形式的差别所在。<br>&#123;//函数带参，说明有另外的空间开辟<br>  int oldValue = *this;  // 取回值<br>  ++(*this);  // 增加<br>  return oldValue;  // 返回被取回的值<br>&#125;<br></code></pre></p><p id="0d749fc34ae2871acdb12a30ff18cfe8" class="ne-p"><br></p><p id="7cfeb712bf544e16fb19db3f76dc80b8" class="ne-p"><span class="ne-text">从这个代码也可以看出++i的效率是优于i++的，尽管很微弱。</span></p><p id="d0583fbb2c74ca0d23757cf453649629" class="ne-p"><br></p><div data-type="danger" class="ne-alert"><p id="aec6e38a293837eef420c2826726a984" class="ne-p"><span class="ne-text" style="background-color: #FFF3F3">大多数编译器已经对这两种使用方式封装，使其普通使用的效果几乎一致。</span></p></div><p id="72a9faf4dde1f00f9db035b59795ece1" class="ne-p"><br></p><div data-type="success" class="ne-alert"><p id="382e72f803d5cd997a84e8e93a54a152" class="ne-p"><span class="ne-text" style="background-color: #EDF9E8">今后尽量使用++i，特别是C++写题的时候。</span></p></div><p id="51a283f3fbec44890f013c37c17ad300" class="ne-p"><br></p><p id="2e5387db8d571168339d5e652d55fe73" class="ne-p"><br></p><p id="0567065769cacff436b96bc51ee97736" class="ne-p"><span class="ne-text">参考链接：</span></p><ul class="ne-ul"><li id="d3b4617aca6abc19bca98cfd9a2e763d"><a href="https://www.zhihu.com/question/19811087" data-href="https://www.zhihu.com/question/19811087" target="_blank" class="ne-link"><span class="ne-text">在程序开发中，++i 与 i++的区别在哪里？</span></a></li><li id="da0a72e0b6531880924eacfa377f5e26"><a href="https://blog.csdn.net/zlhy_/article/details/8349300" data-href="https://blog.csdn.net/zlhy_/article/details/8349300" target="_blank" class="ne-link"><span class="ne-text">为什么(i++)不能做左值，而(++i)可以</span></a></li></ul></div>]]></content>
      
      
      <categories>
          
          <category> 计算机素养 </category>
          
          <category> 非前端编程语言 </category>
          
          <category> CPlusPlus </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>终端环境配置</title>
      <link href="/blog/pa6aqc/"/>
      <url>/blog/pa6aqc/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="u07130102" class="ne-p"><span class="ne-text" style="color: #E8323C">命令相关教程：</span><a href="https://github.com/jlevy/the-art-of-command-line/blob/master/README-zh.md" data-href="https://github.com/jlevy/the-art-of-command-line/blob/master/README-zh.md" target="_blank" class="ne-link"><span class="ne-text" style="color: #E8323C">命令行的艺术</span></a><span class="ne-text">（the-art-of-command-line）</span></p><h2 id="Z3ER4"><span class="ne-text">scoop下载</span></h2><div class="ne-quote"><p id="u8477ab2a" class="ne-p"><span class="ne-text">Scoop是一款适用于Windows平台的命令行软件（包）管理工具，这里是Github介绍页。简单来说，就是可以通过命令行工具（PowerShell、CMD等）实现软件（包）的安装管理等需求，通过简单的一行代码实现软件的下载、安装、卸载、更新等操作。其灵感来源于macOS的Homebrew，Mac用户可以去了解了解。</span></p></div><ul class="ne-ul"><li id="uba66aecd"><span class="ne-text"></span><a href="https://scoop.sh/" data-href="https://scoop.sh/" target="_blank" class="ne-link"><span class="ne-text">https://scoop.sh/</span></a></li></ul><pre><code># 在 PowerShell 中输入下面内容，保证允许本地脚本的执行：set-executionpolicy remotesigned -scope currentuser</code></pre><pre><code># 然后执行下面的命令安装 Scoop：iex (new-object net.webclient).downloadstring('https://get.scoop.sh')</code></pre><pre><code># 静待脚本执行完成就可以了，安装成功后，让我们尝试一下：scoop help</code></pre><p id="ue576a6d8" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1639189556041-8c5d7b31-190e-463a-8ded-64ae19bc60d7.png" width="947" id="u42c137bf" class="ne-image"></p><h2 id="EIWO3"><span class="ne-text">lazygit</span></h2><p id="u1a9010b0" class="ne-p"><a href="https://github.com/jesseduffield/lazygit" data-href="https://github.com/jesseduffield/lazygit" target="_blank" class="ne-link"><span class="ne-text">https://github.com/jesseduffield/lazygit</span></a></p><p id="u0f9cf792" class="ne-p"><span class="ne-text"></span></p><p id="ud41786db" class="ne-p"><span class="ne-text">Add the extras bucket</span></p><pre><code>scoop bucket add extras</code></pre><p id="u2239e339" class="ne-p"><span class="ne-text">Install lazygit</span></p><pre><code>scoop install lazygit</code></pre><p id="udf3d5810" class="ne-p"><span class="ne-text">然后进入一个git文件夹用终端打开输入 </span><code class="ne-code"><span class="ne-text">lazygit</span></code><span class="ne-text"> 即可</span></p><h2 id="qlxSq"><span class="ne-text">Windows Terminal</span></h2><ul class="ne-ul"><li id="u7d927532"><span class="ne-text">官方教程：</span><a href="https://docs.microsoft.com/zh-cn/windows/terminal/" data-href="https://docs.microsoft.com/zh-cn/windows/terminal/" target="_blank" class="ne-link"><span class="ne-text">https://docs.microsoft.com/zh-cn/windows/terminal/</span></a></li></ul><p id="ue4d7ad55" class="ne-p"><span class="ne-text">按照此教程可以DIY如下：</span></p><p id="ueba0e8ce" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1639822798943-6d29922d-cfe5-4101-bac7-3f94650392f3.png" width="249" id="u86db2961" class="ne-image"></p><p id="u679c5799" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1639822897499-1230f2d1-791d-4e59-ac32-06c718f71ac6.png" width="352" id="u35f1ca4e" class="ne-image"></p><h2 id="I0Oax"><span class="ne-text">oh-my-posh</span></h2><p id="ua8cde725" class="ne-p"><a href="https://ohmyposh.dev/docs/windows" data-href="https://ohmyposh.dev/docs/windows" target="_blank" class="ne-link"><span class="ne-text">https://ohmyposh.dev/docs/windows</span></a></p><p id="u12d991e3" class="ne-p"><span class="ne-text">下载oh-my-posh</span></p><pre><code>Install-Module oh-my-posh -Scope AllUsers</code></pre><pre><code>Install-Module posh-git -Scope AllUsers</code></pre><p id="u7ab1c822" class="ne-p"><br></p><p id="uc6128dd6" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1639190934169-c1b6e5bc-e0f9-4b34-bdf6-113ba4c3c8f6.png" width="250.015625" id="u81c84ea1" class="ne-image"></p><p id="uca6a246f" class="ne-p"><br></p><p id="uafe7c940" class="ne-p"><span class="ne-text">参考：</span><a href="https://zhuanlan.zhihu.com/p/163007658" data-href="https://zhuanlan.zhihu.com/p/163007658" target="_blank" class="ne-link"><span class="ne-text">https://zhuanlan.zhihu.com/p/163007658</span></a></p><hr id="EoSao" class="ne-hr"><ul class="ne-ul"><li id="ud840c42f"><a href="https://zhuanlan.zhihu.com/p/354603010" data-href="https://zhuanlan.zhihu.com/p/354603010" class="ne-link"><span class="ne-text">Windows Terminal美化（oh-my-posh3）</span></a></li><li id="uea65c2d8"><a href="https://blog.walterlv.com/post/beautify-powershell-like-zsh.html" data-href="https://blog.walterlv.com/post/beautify-powershell-like-zsh.html" class="ne-link"><span class="ne-text">将美化进行到底，使用 Oh My Posh 把 PowerShell 做成 oh-my-zsh 的样子</span></a></li><li id="ua634fb84"><a href="https://www.jeremyjone.com/917/" data-href="https://www.jeremyjone.com/917/" class="ne-link"><span class="ne-text">美化 Windows Terminal（升级版） - 修身养性，知行合一</span></a></li><li id="u6eb180e7"><a href="https://yqc.im/windows-terminal-using-windows-terminal/" data-href="https://yqc.im/windows-terminal-using-windows-terminal/" class="ne-link"><span class="ne-text">Windows 11 下 Windows Terminal 使用及美化小结</span></a></li></ul></div>]]></content>
      
      
      <categories>
          
          <category> 环境工具 </category>
          
          <category> 环境搭建 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>『大老师+路哥+师傅+折棒』</title>
      <link href="/essay/mll6d7/"/>
      <url>/essay/mll6d7/</url>
      
        <content type="html"><![CDATA[<div class="yuque-hexo-lyrics-secret">这是加密文章！</div>]]></content>
      
      
      <categories>
          
          <category> 影视 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>《狼图腾》</title>
      <link href="/essay/gla4ug/"/>
      <url>/essay/gla4ug/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content-editor-core lake-engine lake-typography-classic" data-lake-element="root" data-selection-undefined="%7B%22path%22%3A%5B%5B0%5D%2C%5B0%5D%5D%2C%22active%22%3Atrue%7D"><p data-lake-id="u543fa103" id="u543fa103" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span data-card-type="inline" data-lake-card="image" id="uc7dc0cca" class="lake-card-margin-top lake-card-margin-bottom"><img data-role="image" src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1626253972954-cf013c98-7c95-4e4c-92d0-e58722469a3b.png" data-raw-src="" class="image lake-drag-image" alt="image.png" title="image.png" data-height="381px" style="visibility: visible; width: 260px;"></span></p><p data-lake-id="u9dac54c3" id="u9dac54c3" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="u6bff1602" id="u6bff1602" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>前言：在那蒙古草原上，有一种被崇敬的事物，那就是狼图腾。</span></p><p data-lake-id="udeff3fda" id="udeff3fda" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><div data-card-type="block" data-lake-card="hr" id="CmmUd"><hr style="background-color: rgb(232, 232, 232); border: 1px solid transparent; margin: 18px 0px;"></div><p data-lake-id="ue5a5925c" id="ue5a5925c" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>1</span></p><p data-lake-id="u1c60af3d" id="u1c60af3d" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="uca6277f6" id="uca6277f6" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>狼群是一个有组织的群体，进攻、放哨兵、撤退，都会按照既定的队形实施。</span></p><div data-card-type="block" data-lake-card="hr" id="6Sku3"><hr style="background-color: rgb(232, 232, 232); border: 1px solid transparent; margin: 18px 0px;"></div><p data-lake-id="uae7cad4c" id="uae7cad4c" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>2</span></p><p data-lake-id="uf31e0f26" id="uf31e0f26" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="u5ed098fb" id="u5ed098fb" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>黄羊和狼的互相存在就是草原上的生存法则</span></p><p data-lake-id="uda8314ad" id="uda8314ad" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><blockquote style="margin-top: 5px; margin-bottom: 5px; padding-left: 1em; margin-left: 0px; border-left: 3px solid rgb(238, 238, 238); opacity: 0.6;"><p data-lake-id="ua23268b3" id="ua23268b3" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>“老人说：我也打狼，可不能多打。要是把狼打绝了，草原就活不成。草原死了，人畜还能活吗？”</span></p></blockquote><p data-lake-id="u280faa97" id="u280faa97" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="ub93f42c2" id="ub93f42c2" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>“红卫兵”“知青”“学生”……</span></p><p data-lake-id="uf974bf1c" id="uf974bf1c" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>在那种蛮荒时代里，步入殷实温暖的蒙古包，其实倒也是不错的经历，简单纯粹。</span></p><p data-lake-id="ua6d05cdb" id="ua6d05cdb" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><blockquote style="margin-top: 5px; margin-bottom: 5px; padding-left: 1em; margin-left: 0px; border-left: 3px solid rgb(238, 238, 238); opacity: 0.6;"><p data-lake-id="udadbff77" id="udadbff77" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>“你们汉人胆子太小，像吃草的羊，我们蒙古人是吃肉的狼，你是该有点狼胆了。”</span></p></blockquote><p data-lake-id="u2a0e3bb1" id="u2a0e3bb1" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="u44901109" id="u44901109" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>狼是草原的守护神，腾格里（信奉的神）护着狼。</span></p><p data-lake-id="u969a5a5d" id="u969a5a5d" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>人的内心深处亦或者说人类最原始角色就有一种猎性，只是从一开始作为农耕民族，早已被“便捷”所“进化”地向绵羊一般，不再有猎性，不再是猎人……可能这就是一种我们常说的血性。</span></p><p data-lake-id="ub449121f" id="ub449121f" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><blockquote style="margin-top: 5px; margin-bottom: 5px; padding-left: 1em; margin-left: 0px; border-left: 3px solid rgb(238, 238, 238); opacity: 0.6;"><p data-lake-id="u029726ac" id="u029726ac" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>老人说：“光靠狼的狠劲还不行，还得靠狼的耐性”（智慧、耐性、组织性、纪律性）</span></p></blockquote><p data-lake-id="u999089a9" id="u999089a9" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="u0cc8398e" id="u0cc8398e" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>草原上的蒙古人更为精明，作为狼的徒弟，青出于蓝而胜于蓝。</span></p><div data-card-type="block" data-lake-card="hr" id="zPWCX"><hr style="background-color: rgb(232, 232, 232); border: 1px solid transparent; margin: 18px 0px;"></div><p data-lake-id="u2101a43d" id="u2101a43d" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>3</span></p><p data-lake-id="ua92eb9b6" id="ua92eb9b6" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="u5f16550f" id="u5f16550f" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>古老的草原逻辑解释了食肉名族和食草民族几千年来的争斗的根本</span></p><blockquote style="margin-top: 5px; margin-bottom: 5px; padding-left: 1em; margin-left: 0px; border-left: 3px solid rgb(238, 238, 238); opacity: 0.6;"><p data-lake-id="uc04ee30e" id="uc04ee30e" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>草原名族捍卫的是“大命”——草原和自然的命比人命更宝贵；</span></p><p data-lake-id="u4826bb5a" id="u4826bb5a" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>而农耕名族捍卫的是“小命”——天下最宝贵的是人命和活命。</span></p><p data-lake-id="ufd831779" id="ufd831779" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>可是大命没了小命全都没命。</span></p></blockquote><div data-card-type="block" data-lake-card="hr" id="wLRS9"><hr style="background-color: rgb(232, 232, 232); border: 1px solid transparent; margin: 18px 0px;"></div><p data-lake-id="u4b11bd2d" id="u4b11bd2d" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>4</span></p><p data-lake-id="u5431f816" id="u5431f816" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="ud53eb6dc" id="ud53eb6dc" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>对狼的敬畏</span></p><blockquote style="margin-top: 5px; margin-bottom: 5px; padding-left: 1em; margin-left: 0px; border-left: 3px solid rgb(238, 238, 238); opacity: 0.6;"><p data-lake-id="u2f59cd7b" id="u2f59cd7b" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>在草原不吃食物，就不能算是真正的草原蒙古人。</span></p></blockquote><p data-lake-id="u9ab7f897" id="u9ab7f897" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>狼死了，狼的灵魂也会飞回腾格里那儿去的。</span></p><p data-lake-id="uf34b5114" id="uf34b5114" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>什么才叫真正的崇敬，对于蒙古民族，崇敬狼图腾，在一个人生命的终点，将躯体当成裸露坦荡的祭祀供品，从而把自己解脱的如此彻底。</span></p><div data-card-type="block" data-lake-card="hr" id="lR2Ih"><hr style="background-color: rgb(232, 232, 232); border: 1px solid transparent; margin: 18px 0px;"></div><p data-lake-id="u66e4851e" id="u66e4851e" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>5</span></p><p data-lake-id="uf0531126" id="uf0531126" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="u58887fa8" id="u58887fa8" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>巴图带领上等军马出去被狼群袭击。</span></p><p data-lake-id="ubecf5114" id="ubecf5114" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>丧崽哭嚎的母狼加入狼群，会格外地疯狂残忍</span></p><p data-lake-id="ue7ac01c3" id="ue7ac01c3" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>疯狼不能打，越打越凶，越杀越疯，疯狼的报复心草原上无人不怕</span></p><p data-lake-id="u813968f1" id="u813968f1" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>对狼来说，狼牙就是狼命。狼没了牙，狼就没了天</span></p><blockquote style="margin-top: 5px; margin-bottom: 5px; padding-left: 1em; margin-left: 0px; border-left: 3px solid rgb(238, 238, 238); opacity: 0.6;"><p data-lake-id="ucd935f61" id="ucd935f61" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>狼的最凶狠锐利的武器就是它的上下四根狼牙，如果没有狼牙，狼所有的勇敢、强悍、狡猾、凶残、贪婪、狂妄、野心、雄心、耐性、机敏、警觉、体力、耐力、等等一切的品性、个性和物性，统统等于零。</span></p></blockquote><div data-card-type="block" data-lake-card="hr" id="SfpBT"><hr style="background-color: rgb(232, 232, 232); border: 1px solid transparent; margin: 18px 0px;"></div><p data-lake-id="u83e0eec1" id="u83e0eec1" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>6</span></p><p data-lake-id="u97953c5b" id="u97953c5b" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="uc94801ed" id="uc94801ed" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p></div>]]></content>
      
      
      <categories>
          
          <category> 阅读 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>各类查找算法汇总</title>
      <link href="/blog/umxpln/"/>
      <url>/blog/umxpln/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="8adac5ba86bd45e4adf373e42360d57c" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1625064864232-8fab0164-7210-430e-881a-cf4c938d7165.jpeg" width="1200" id="SHNRc" class="ne-image"></p><p id="944c0aa28a1c84bff877f90ebf514191" class="ne-p"><span class="ne-text"></span></p><div data-type="info" class="ne-alert"><p id="a20d224c568e48b9d67847a2c66a8c01_p_0" class="ne-p"><span class="ne-text">前言：查找算法在书上分为三种</span></p><p id="a597d1ad49b48d22508abbbbea3ec86e" class="ne-p"><span class="ne-text">第一种是比较常用且较为简单的线性表查找；</span></p><p id="897d027ea2ee01fd9a0aebe390fc3f0b" class="ne-p"><span class="ne-text">第二种数表查找；</span></p><p id="ce176108f62145efbfd3a24cb4d98a5b" class="ne-p"><span class="ne-text">最后一种是哈希表查找。</span></p></div><p id="67182dad42b62d5e8622c3c03bef6da0" class="ne-p"><br></p><h2 id="CyDdg"><span class="ne-text">线性表查找</span></h2><h3 id="FCWSB"><span class="ne-text">顺序查找</span></h3><p id="d4c59044944821a6484b17213ecdbd10" class="ne-p"><span class="ne-text">就是最为常用的，将关键字依次将给定序列中的各个元素依次比较</span></p><h3 id="cPCW8"><span class="ne-text">折半查找</span></h3><p id="3d01e8062e09006f7c20e7552fc3f74c" class="ne-p"><span class="ne-text">不知道是不是也可以叫做二分查找，局限条件为有序序列，然后每次折半，在折半的范围内查找</span></p><h3 id="DeKVL"><span class="ne-text">分块查找</span></h3><p id="b00e4c76ba73f41ca27458adca579419" class="ne-p"><span class="ne-text">书中给定的情景时，索引表的数据项是按照关键字有序排列的，但是关键字所对应的子块可能是无序的，所以按照这种情景可以对索引表进行折半查找/顺序查找，对子快只能进行顺序查找（因为每个子块都不是有序的）</span></p><p id="a30e11f1bfbf2faaabd0ae1dca63ef9b" class="ne-p"><br></p><h2 id="9d8D2"><span class="ne-text">数表查找</span></h2><h3 id="tjgDp"><span class="ne-text">二叉排序树</span></h3><p id="9fc58666f27422e02f8aeec494a1a71c" class="ne-p"><span class="ne-text">关键字的特点：“左&lt;根&lt;右”</span></p><p id="8e6fe69fea0896f38b3f59f6be3730d4" class="ne-p"><span class="ne-text">创建：由一个给定序列建立二叉排序树</span></p><p id="12db53eadb5aa3ea5e8b418d21b29e4f" class="ne-p"><span class="ne-text">查找：所以只要给定一个二叉排序树，按照中序递归输出即可得到排好序的序列</span></p><p id="5a7ae08ae3a5396b8ca3b18e86f034ad" class="ne-p"><br></p><h3 id="bRpmP"><span class="ne-text">平衡二叉树</span></h3><p id="3a8c0cd0856c6e6e742f45f2f63f55a0" class="ne-p"><span class="ne-text">这个是基于上面的二叉排序树的，但是这个提出了一个结点的平衡因子概念，要求每个结点的平衡因子的绝对值不能大于1</span></p><p id="9268e85de4b9959351ca063296488a35" class="ne-p"><span class="ne-text">创建：给定一个序列，一开始还是按照二叉排序树的形式构造，当出现结点的平衡因子“非法”对其进行“调整”，一般有四种“违法”情况：LL、RR、LR、RL</span></p><p id="9f543d1b419aed077783462fe6cb998a" class="ne-p"><span class="ne-text">查找：还是按照中序遍历即可，中序遍历输出的序列就是排好序的序列</span></p><p id="2c8c0aa7c5d4e466b7f3457acea9ee09" class="ne-p"><br></p><div data-type="tips" class="ne-alert"><p id="cf72d628c02cf8725b5e38911aa80a04" class="ne-p"><span class="ne-text">上面所有查找方法都是内查找法，就是在内存中进行的，下面的是用到磁盘存储的查找方式</span></p></div><h3 id="6A7WD"><span class="ne-text">TODO: B-树</span></h3><h3 id="On2mJ"><span class="ne-text">TODO: B+树</span></h3><h2 id="QNvCf"><span class="ne-text">TODO: 散列表查找</span></h2></div>]]></content>
      
      
      <categories>
          
          <category> 计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 📊查找排序算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数字电路总结</title>
      <link href="/blog/tn3fhp/"/>
      <url>/blog/tn3fhp/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="u1d56c84c" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1627439456204-1f0fe7c2-b603-476f-93ee-d3705839148c.png" width="354" id="u0286b041" class="ne-image"></p><p id="u4d9aedc3" class="ne-p"><br></p><div data-type="info" class="ne-alert"><p id="uf894e305" class="ne-p"><span class="ne-text">前言：利用猴博士视频总结的题型对整个数字电路做出复习。</span></p></div><p id="u8876d1ed" class="ne-p"><br></p><h2 id="ApQo3"><span class="ne-text">一、进制及其转换</span></h2><ul class="ne-ul"><li id="u16ac593a"><span class="ne-text">二进制：B</span></li><li id="ub646bb4b"><span class="ne-text">十进制：D</span></li></ul><ul start="3" class="ne-ul"><li id="u4ff7bfc0"><span class="ne-text">八进制：O</span></li><li id="u7751179c"><span class="ne-text">十六进制：H</span></li></ul><p id="u2eb26806" class="ne-p"><br></p><p id="u0dfe7ac0" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1624499655205-1611e06a-b4bf-49c1-9890-5fe12bbfc2bc.png" width="500.5" id="u30777ccf" class="ne-image"></p><p id="ubf37a27c" class="ne-p"><br></p><h2 id="vhLvf"><span class="ne-text">二、逻辑门电路</span></h2><h3 id="uardA"><span class="ne-text">给出逻辑图、输入，求输出</span></h3><p id="u7b154172" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1624458112503-bd20e917-0fbd-4ab0-9ff4-b4ccd9865fc4.png" width="554.5" id="u108d5323" class="ne-image"></p><h3 id="xID8V"><span class="ne-text">给出逻辑图，写表达式</span></h3><p id="uef96a2d9" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1624458199919-649be4e4-ce94-4902-9c69-5595aff00f9e.png" width="557" id="ude5115ed" class="ne-image"></p><h3 id="StyE1"><span class="ne-text">给出表达式，画逻辑图</span></h3><p id="u9221886b" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1624458182439-0e80d369-7d17-453d-b7e6-d30e6e046598.png" width="487.5" id="u34ba51a5" class="ne-image"></p><h2 id="xIN31"><span class="ne-text">三、化简逻辑函数表达式</span></h2><h3 id="vBQ14"><span class="ne-text">公式法化简</span></h3><p id="u31c7e7a0" class="ne-p"><span class="ne-text">拍照那个笔记</span></p><h3 id="RzjkG"><span class="ne-text">卡诺图法化简</span></h3><p id="u1980cb57" class="ne-p"><span class="ne-text">要求：</span></p><ol class="ne-ol"><li id="u2a3f7583"><span class="ne-text">卡诺图表示成逻辑函数表达式</span></li><li id="ud0f9b627"><span class="ne-text">逻辑函数表达式表示成卡诺图</span></li></ol><ol start="3" class="ne-ol"><li id="u2d26855b"><span class="ne-text">化简逻辑函数表达式</span></li></ol><ol ne-level="1" class="ne-ol"><li id="u281d3b6e"><span class="ne-text">没有约束</span></li><li id="u661820ea"><span class="ne-text">有约束</span></li></ol><p id="u29f02f24" class="ne-p"><br></p><p id="u2fc80979" class="ne-p"><span class="ne-text">注意以下几点：</span></p><ul class="ne-ul"><li id="u139f5c42"><span class="ne-text">能圈多的就圈多的</span></li><li id="u70fdd96c"><span class="ne-text">约束项*能用就用，用的时候就为1，不用的时候就为0，不需要一定将其应用，*只是服务于1的</span></li></ul><p id="ua5fd92db" class="ne-p"><span class="ne-text"></span></p><h3 id="JkWMO"><span class="ne-text">求反函数</span></h3><p id="u59dd4c77" class="ne-p"><span class="ne-text">根据逻辑函数表达式求反函数</span></p><div class="ne-quote"><ul class="ne-ul"><li id="ue5616d8c"><span class="ne-text">把所有的“与”“或”互换</span></li><li id="u9ecb2432"><span class="ne-text">把所有的0、1互换</span></li></ul><ul start="3" class="ne-ul"><li id="ua54dd42e"><span class="ne-text">原变量和反变量互换</span></li><li id="u037171f1"><span class="ne-text">多个变量的公共非不变</span></li></ul><ul start="5" class="ne-ul"><li id="u9c5a6d39"><span class="ne-text">原始运算的优先顺序不变</span></li></ul></div><p id="u8b98b20d" class="ne-p"><span class="ne-text">根据卡诺图求反函数</span></p><div class="ne-quote"><ul class="ne-ul"><li id="ud37850bd"><span class="ne-text">把图中的0、1互换</span></li><li id="u94d8571b"><span class="ne-text">信徒写出来即可</span></li></ul></div><h2 id="KgpZK"><span class="ne-text">四、组合逻辑电路的分析与设计</span></h2><h3 id="rEHT8"><span class="ne-text">给出逻辑电路图，分析逻辑功能</span></h3><ul class="ne-ul"><li id="uf9001601"><span class="ne-text">逻辑电路图写出函数表达式</span></li><li id="u2d929d38"><span class="ne-text">化简函数表达式（符合要求的）</span></li></ul><ul start="3" class="ne-ul"><li id="uab5cbf33"><span class="ne-text">列出所有情况</span></li><li id="u1d887648"><span class="ne-text">分析出功能</span></li></ul><div class="ne-quote"><p id="u2647044e" class="ne-p"><span class="ne-text">常见的功能有：不一致电路、一致电路、少数服从多数电路</span></p></div><h3 id="gBuKz"><span class="ne-text">给出逻辑功能，画出逻辑电路图</span></h3><p id="u121349e2" class="ne-p"><span class="ne-text">和上面的步骤差不多，</span></p><ul class="ne-ul"><li id="u820d8078"><span class="ne-text">确定输入个数，定义0、1</span></li><li id="u85c18170"><span class="ne-text">列真值表</span></li></ul><ul start="3" class="ne-ul"><li id="ucc3ed547"><span class="ne-text">写出逻辑函数表达式</span></li><li id="u169a605d"><span class="ne-text">化简</span></li></ul><ul start="5" class="ne-ul"><li id="udb6922d4"><span class="ne-text">画出电路图</span></li></ul><h2 id="K5XZx"><span class="ne-text">五、最小项</span></h2><h3 id="qQXKn"><span class="ne-text">卡诺图求最小项</span></h3><ul class="ne-ul"><li id="u048982d0"><span class="ne-text">把逻辑函数表达式转换为卡诺图</span></li><li id="u11706cfe"><span class="ne-text">卡诺图里面为1的就是该位置二进制存在的最小项</span></li></ul><p id="ue4f16148" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1624457764328-fc869be5-3d63-4499-9a9a-6e82ca2601fe.png" width="617" id="u2aba1ab9" class="ne-image"></p><h3 id="vkFyT"><span class="ne-text">公式法求最小项</span></h3><p id="uc8350073" class="ne-p"><span class="ne-text">就是通俗的化简，不过结果的每一项都必须包含每个字母，最后用二进制表示</span></p><p id="u56e8eff8" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1624457888889-57837834-3e20-4a68-93f2-94a5d9cf0482.png" width="374.5" id="u17d70b37" class="ne-image"></p><h3 id="Q1hdE"><span class="ne-text">最小项化成变量形式</span></h3><p id="u74fd1448" class="ne-p"><span class="ne-text">将其下标化成二进制，然后转换</span></p><p id="ufc02732c" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1624457989908-8eeaae47-38c1-440b-a1b6-aacda1358653.png" width="483" id="u744474eb" class="ne-image"></p><h3 id="PoVZa"><span class="ne-text">卡诺图化简有约束条件的</span></h3><p id="u9dd108d9" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1624458044603-7393051c-fa08-444d-8890-d510b20f259a.png" width="499.5" id="ud5764522" class="ne-image"></p><h2 id="mvA4U"><span class="ne-text">六、常用的集成器件</span></h2><h3 id="tFSzw"><span class="ne-text">译码器和门电路实现逻辑函数</span></h3><p id="uf2944355" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1624495725174-7d84b3db-0535-4e9c-8445-eca05056e43e.png" width="503.5" id="u6d89f5d1" class="ne-image"></p><h3 id="yp7Bb"><span class="ne-text">译码器接线图写出逻辑函数</span></h3><p id="u22797bfd" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1624495940765-119658e7-e960-4fc3-83a7-634fdc6dc8dd.png" width="491" id="u076f4229" class="ne-image"></p><h3 id="UlDQ9"><span class="ne-text">8选1数据选择器实现3输入逻辑函数</span></h3><p id="ud45570a7" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1624496141542-776d204b-0332-4dad-acc1-c75ac793c2b7.png" width="504.5" id="u3f7c15b1" class="ne-image"></p><p id="u81d0fd72" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1624496797353-52c90305-9a96-4b48-9e94-d4ef979229e1.png" width="500" id="u693c19a9" class="ne-image"></p><h3 id="a7mKV"><span class="ne-text">8选1数据选择器实现多输入逻辑函数</span></h3><p id="u4034e95a" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1624496656766-4a7aa12f-e321-4db0-a4ad-08b6fa88599e.png" width="507" id="u6828df9f" class="ne-image"></p><p id="u1178e1ca" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1624496990732-16fbfeea-0384-4da7-9a20-af26f3a367c3.png" width="507" id="ucd4d8900" class="ne-image"></p><h2 id="HDybP"><span class="ne-text">七、触发器</span></h2><h3 id="SEpD6"><span class="ne-text">同步RS触发器</span></h3><p id="u020023c3" class="ne-p"><br></p><h3 id="iWmbZ"><span class="ne-text">给出D触发器及输入，画出波形图</span></h3><p id="ubbb059eb" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1624537249474-e313d1d4-e54a-4f11-801a-7cb35477b1ab.png" width="504" id="ua213f1e1" class="ne-image"></p><h3 id="AC2Y7"><span class="ne-text">给出JK触发器及输入，画出波形图</span></h3><p id="uaaa0c047" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1624537215870-9c84a3f2-bc32-45fc-ad01-711ccedb1f2f.png" width="500" id="u906a2e93" class="ne-image"></p><p id="uf37039fa" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1624537294036-58b09d4c-ff3f-463b-a638-40a8d9aceb27.png" width="497" id="u4547f333" class="ne-image"></p><h3 id="wE0EQ"><span class="ne-text">多个触发器相连</span></h3><p id="ue5357d3d" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1624537373073-41ebf1b0-eefa-4780-bf91-d48419f01d2d.png" width="489" id="ub2a45094" class="ne-image"></p><h2 id="w0KLf"><span class="ne-text">问答题</span></h2><p id="u92521508" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1624539793127-eb24945d-a5b8-4b60-ad1b-52764290c914.png" width="427" id="u9205094c" class="ne-image"></p><p id="u57e9de9c" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1624539824281-1a7c5e6a-774d-41de-96c0-68525d81eb6c.png" width="256.5" id="u71ba7cb4" class="ne-image"></p><p id="u2570e8e3" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1624539813127-8f316639-a479-4cf2-89b6-7e8d2d6ac7e9.png" width="179" id="u41542c50" class="ne-image"></p><p id="u05bb5331" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1624539898752-fe3a106e-2e6d-4296-8ea7-bd2e434481a9.png" width="531" id="uc035f11a" class="ne-image"></p></div>]]></content>
      
      
      <categories>
          
          <category> 计算机素养 </category>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>《洒脱的人才“玩”得起人生》</title>
      <link href="/essay/mzd92z/"/>
      <url>/essay/mzd92z/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="u95c01ed3" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1624193059628-8f003b19-46ac-47e4-b4af-23593b54b32a.jpeg" width="261.0115966796875" id="u43723471" class="ne-image"></p><p id="u20aa99fc" class="ne-p"><br></p><p id="ufd378d88" class="ne-p"><span class="ne-text">前言：</span><strong><span class="ne-text">我喜欢洒脱的人生态度，洒脱的人，活得简单、快乐</span></strong><span class="ne-text">。</span></p><p id="ub654de52" class="ne-p"><br></p><p id="u1430b4f7" class="ne-p"><span class="ne-text">对蔡澜的认识是源于『舌尖上的中国』，只知道他是一位美食家，最近才知道，蔡先生是一位见识丰富，极具艺术气质的一个人，他不仅是一位美食家，还是作家，电影制片人。</span></p><p id="u2a45e7fb" class="ne-p"><br></p><p id="u99ab65da" class="ne-p"><span class="ne-text">看完蔡澜先生写的这本随笔，会有一种豁达随性之感，有一种“生活本该如此”的感觉。整本书就是作者的随笔合集，作者有记录生活的那些看似不起眼，却也能吐槽，放开心境的一系列事情。书中还记录作者所吃过的许许多多的美食随笔，看这本书有一种吃甜点的那种愉悦感。</span></p><p id="u5f3db708" class="ne-p"><br></p><hr id="RK0bl" class="ne-hr"><p id="u88c00c22" class="ne-p"><span class="ne-text">最喜欢书里面的一段话：</span></p><p id="uc15d2bc4" class="ne-p"><br></p><div class="ne-quote"><p id="ue27f8d2a" class="ne-p"><strong><span class="ne-text">人生的意义太过广泛，这个问题天下多少宗教家、哲学家都解答不了。吃得好一点，睡得好一点，多玩玩，不羡慕别人，不听管束，多储蓄人生经验，死而无憾。这就是最大的意义吧，一点儿也不复杂</span></strong><span class="ne-text">。</span></p></div><h2 id="JUsTC"><span class="ne-text">一、我承认我快乐</span></h2><p id="u0371e027" class="ne-p"><span class="ne-text">快乐</span></p><p id="uba408fb0" class="ne-p"><br></p><p id="u577551e3" class="ne-p"><span class="ne-text">一天过得比一天快乐，是人生欢乐可行之道。可以从不刻薄自己开始。努力之余，想要什么就放手去买、去做。旅行最好，多学一样东西也不错。（蔡澜语录）</span></p><hr id="79LLN" class="ne-hr"><p id="uc9890a3b" class="ne-p"><span class="ne-text">想做的事</span></p><p id="u58dbba98" class="ne-p"><br></p><p id="u3524ee17" class="ne-p"><span class="ne-text">等到我所有的欲望都消失了，像看到好吃的东西也不想吃，好看的女人也不想和她们睡觉时，我就会去雕刻佛像，我好像说过这件事，我在清迈有一块地，可以建筑一间工作室，到时天天刻佛像，刻后涂上五颜六色，佛像的脸，像你、像我，不一定是菩萨观音。（蔡澜语录）</span></p><p id="u4109acb9" class="ne-p"><br></p><p id="ue3c4f8d8" class="ne-p"><span class="ne-text">问：“那么多的兴趣，要等到什么时候才去做？是不是要等到退休？”</span></p><p id="udabdf07b" class="ne-p"><span class="ne-text">答：“我早已退休了，从很年轻开始已经学会退休。我一直觉得时间不够用，只能在某一段时期，做某件事，什么时候开始，什么时候终结，随缘吧。”</span></p><p id="ub75c7b6c" class="ne-p"><br></p><hr id="OuIYr" class="ne-hr"><p id="uc5810815" class="ne-p"><span class="ne-text">好玩之都</span></p><p id="u0c73a96f" class="ne-p"><br></p><p id="ud7390983" class="ne-p"><span class="ne-text">在这个充满丑闻的都市中，我们得到了无限的欢乐，只要一天不死，就有笑话看。是的，还是香港好。（蔡澜语录）</span></p><hr id="hz7EN" class="ne-hr"><p id="uf5edc47f" class="ne-p"><span class="ne-text">玩物丧志</span></p><p id="uecd93098" class="ne-p"><br></p><p id="u476108d2" class="ne-p"><span class="ne-text">谁说玩物丧志？玩物养志才对！（蔡澜语录）</span></p><p id="u5d8c99de" class="ne-p"><br></p><div data-type="info" class="ne-alert"><p id="ua3a3f445" class="ne-p"><span class="ne-text">玩物丧志吗？</span></p><p id="uf5be0e66" class="ne-p"><span class="ne-text">谁都知道，如果玩的是自己极其感兴趣的，会走出不一样的路，讽刺的是，世上绝大多数人都不敢这么做……</span></p></div><hr id="kAhk0" class="ne-hr"><p id="u20bc0403" class="ne-p"><span class="ne-text">偷笑</span></p><p id="u1ba32475" class="ne-p"><br></p><p id="u8fd3e8d3" class="ne-p"><span class="ne-text">庆幸的是我没有生儿育女的经验。看到别人的失落，我躲起来偷笑。想到自己结交的一些年轻女友都是人家的女儿，笑得更厉害了。（蔡澜语录）</span></p><p id="u9f2d9d40" class="ne-p"><br></p><p id="u7c1df666" class="ne-p"><span class="ne-text">（看这段的时候，笑死）</span></p><p id="ua0655bf9" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1624348364148-8176d785-505c-4979-873b-8dbdb4341941.png" width="96" id="gGEfk" class="ne-image"></p><hr id="4v0rs" class="ne-hr"><p id="u0b21b0ce" class="ne-p"><br></p><p id="ue2cba551" class="ne-p"><span class="ne-text">后悔</span></p><p id="u5cde919e" class="ne-p"><br></p><p id="u73b9e286" class="ne-p"><span class="ne-text">后悔，我们一定有过。烦恼出自我们的贪婪。两者兼得，就产生后悔和痛苦。a君或b君，要哪一个？烦恼即来。选其中一个，不后悔就是。一切灾殃化为尘，阿弥陀佛！（蔡澜语录）</span></p><hr id="5jhEJ" class="ne-hr"><p id="u278e085e" class="ne-p"><span class="ne-text">惊讶状</span></p><p id="ubb394a0e" class="ne-p"><br></p><p id="u1c7a301e" class="ne-p"><span class="ne-text">换一个新环境，就像交了个新情妇，晚上睡不着觉，一大早起床便往外跑，想发现每一个角落有什么不同的。这种心情是兴奋的、年轻的。这就是我爱旅行、爱住酒店的主要原因。（蔡澜语录）</span></p><p id="u5b398b06" class="ne-p"><br></p><div data-type="info" class="ne-alert"><p id="uad4b7af9" class="ne-p"><span class="ne-text">这段作者讲述的是在帮一个朋友宣传的时候，某社报的记者来访问的情形，这个记者每句话离不开一个“哟”……</span></p></div><hr id="ENUu5" class="ne-hr"><p id="u8d6d7b79" class="ne-p"><span class="ne-text">水准</span></p><p id="u72d9e938" class="ne-p"><br></p><p id="u3df047cf" class="ne-p"><span class="ne-text">日本有一个很出名的料理人，他教了很多徒弟，其中有一个他最喜欢，但是他不教很多花样，每天一早，就叫这个徒弟煮一碗面豉汤给他喝。徒弟做了三年，师父也喝了三年。每天喝完不称赞，也不批评。后来徒弟才知道，师父教他的是保持一贯的水准，这是最重要的，客人吃了吃了，就吃出瘾来，不光顾不可。</span></p><p id="ueb3a0243" class="ne-p"><br></p><div data-type="info" class="ne-alert"><p id="u02ca7c7c" class="ne-p"><span class="ne-text">很多时候，最本真的或许才是最好的。</span></p><p id="ufe1832c0" class="ne-p"><span class="ne-text">想起了在天津吃的那家网红烤肉店，虽然整个餐厅运营机制不方便，但是吃到原生的服务员做的烤肉那味道，那种感觉还是很美妙的。</span></p></div><hr id="oGcYG" class="ne-hr"><p id="u2e12c8bd" class="ne-p"><span class="ne-text">蓝莓园</span></p><p id="ub91af9f9" class="ne-p"><br></p><p id="ud9862cb0" class="ne-p"><span class="ne-text">从吃一顿饭，便能观察对方是怎样的一种人。拿筷子搬弄一番又不选一块来吃，好不了哪里。大刺刺地先吃最好的部分，而不留给朋友，非常自私。夹了一大堆食物而不去动，是个贪心损人不利己的。畅怀大嚼，属于豁达型，豪放又来得性感，无妨深交。（蔡澜语录）</span></p><p id="u8530c9c1" class="ne-p"><br></p><div data-type="info" class="ne-alert"><p id="u1e23ce95" class="ne-p"><span class="ne-text">哈哈哈，好像还真有道理……</span></p></div><p id="ue14cc5e5" class="ne-p"><br></p><p id="u098d1e17" class="ne-p"><span class="ne-text">对着一望无际的蓝莓，他说：“一粒粒采摘，吃不完做果酱，春天也会开漂亮的花。到了秋天，蓝莓树像枫叶一样满山变红。那边有几棵高大的栗子树，果实熟了掉下，一面看红叶一面烤来吃，我已经不能回到城市去了。”</span></p><p id="u037d7e68" class="ne-p"><br></p><div data-type="info" class="ne-alert"><p id="u67a3e566" class="ne-p"><span class="ne-text">“明知是一场意外，你要不要来”</span></p><p id="udf9a8c0f" class="ne-p"><span class="ne-text">此般愿景，去又何妨</span></p></div><p id="ub9ad0193" class="ne-p"><br></p><hr id="CwGZl" class="ne-hr"><p id="u4b451aa9" class="ne-p"><span class="ne-text">不胖</span></p><p id="ucd64d492" class="ne-p"><br></p><p id="ueb39a037" class="ne-p"><span class="ne-text">一切浅尝，当然肥不了，但还是装腔作势，回答说：“真正会吃的人，是不胖的。”（蔡澜语录）</span></p><p id="u7dca521b" class="ne-p"><br></p><hr id="1aG4i" class="ne-hr"><p id="ua8601943" class="ne-p"><span class="ne-text">演讲与拐杖</span></p><p id="u6450329a" class="ne-p"><br></p><p id="uff5989f5" class="ne-p"><span class="ne-text">能进步的人，都有自己独立的思想，听他们的谈吐，就知与众不同，感想和观点皆独特的，都是努力奋斗的人物。（蔡澜语录）</span></p><hr id="PpRAH" class="ne-hr"><p id="u8d6a8dc9" class="ne-p"><span class="ne-text">世界上的厕所</span></p><p id="u3fa0381c" class="ne-p"><br></p><p id="u07342951" class="ne-p"><span class="ne-text">如果你很想在一生中出一本书的话，也不必有太多的才华，将所闻所见以相机拍下，再加上几行说明文字即行。举个例子，世界上的街灯都不同，乘现在年轻看到了就记录拍下，也是一本好书。（蔡澜语录）</span></p><p id="u2b314737" class="ne-p"><br></p><div data-type="info" class="ne-alert"><p id="u8c52eb5d" class="ne-p"><span class="ne-text">生活是一切美好事物的源泉</span></p></div><hr id="ZCK72" class="ne-hr"><p id="u1f606d10" class="ne-p"><span class="ne-text">整容</span></p><p id="u2bcb442f" class="ne-p"><br></p><p id="u8b985084" class="ne-p"><span class="ne-text">韩国女人愈来愈会打扮，愈来愈会穿衣服，不过这一点儿用处也没有，给外国人的印象，她们的美还是整容的结果。这对她们一点儿也不公平，数十年前经济未起飞时，哪有钱做手术，美女还不是多过其他国家？（蔡澜语录）</span></p><hr id="avytb" class="ne-hr"><p id="u32083649" class="ne-p"><span class="ne-text">商机</span></p><p id="ude152817" class="ne-p"><br></p><p id="u9b018f8f" class="ne-p"><span class="ne-text">如果只为升值及价值而去收藏某物件，这是一种肤浅的行为，我不会刻意去收藏某种物件。买一件你喜欢的，因为可以用上一生一世。（蔡澜语录）</span></p><hr id="uhWkj" class="ne-hr"><p id="u3df64745" class="ne-p"><span class="ne-text">惊喜</span></p><p id="u3564d439" class="ne-p"><br></p><p id="ua1ecca0f" class="ne-p"><span class="ne-text">轮到了乐观派：“蔡先生的团总有惊喜，加了一个采苹果的节目，这次送给我们一次地震的经验。”（蔡澜语录）</span></p><p id="u2c4f6d0a" class="ne-p"><br></p><p id="u03eee7fb" class="ne-p"><span class="ne-text">另一位说：“</span><span class="ne-text" style="color: #F5222D">最大惊喜还是我老婆给我的。结婚十多年，这一次因为地震，她才紧紧抱住我。</span><span class="ne-text">”</span></p><p id="ua3763d25" class="ne-p"><br></p><div data-type="info" class="ne-alert"><p id="u9258cfdc" class="ne-p"><span class="ne-text">悲观者，和乐观者之间的差别，就在此了</span></p></div><p id="u6490f8de" class="ne-p"><br></p><p id="uee991034" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/gif/1484158/1624195248841-6bc739e9-a3ac-449f-8bd9-6afd3edc9fe5.gif" width="45" id="d9ReS" class="ne-image"></p><hr id="iPTg9" class="ne-hr"><p id="u4679e8be" class="ne-p"><span class="ne-text">白痴</span></p><p id="ubd58feca" class="ne-p"><br></p><p id="u0c553865" class="ne-p"><span class="ne-text">一个人一生中最需要储的，是说实话的本钱。年轻人还没有大本事，你面对同事上司，怎可能随便给人脸色看？明明碰上看不顺眼的人和事，你只有逆来顺受。要一点虚伪也要圆滑，等你建立了相当的自信和说服力后，便储了说实话的本钱。（蔡澜语录）</span></p><hr id="pMetU" class="ne-hr"><p id="ub64435c8" class="ne-p"><span class="ne-text">尊重<br /></span><span class="ne-text" style="color: #F5222D">　</span></p><p id="ua5cdc408" class="ne-p"><br></p><p id="u16124879" class="ne-p"><span class="ne-text">不觉得，我心中说，太操劳的事我已不会做。况且，第一团去过的地方第二团重访，店主即当我老爷拜。怪不得那位第一次参加的团友说：“最过瘾的是跟你去到那里，都得到人家的尊重。”（蔡澜语录）</span></p><p id="uf5abb4d0" class="ne-p"><br></p><div data-type="info" class="ne-alert"><p id="u7c8f86df" class="ne-p"><span class="ne-text">感受得到，做生意就是这样，诚恳，尊重他人，待人友善的这种做事风格</span></p></div><div data-type="info" class="ne-alert"><p id="u75963cb5" class="ne-p"><span class="ne-text">所有的快乐都是在自己生活中的点滴累计而成，生活啊，不要太难为自己~身边处处是一些美好的事物啊，难道不是吗？</span></p></div><p id="ue6518e22" class="ne-p"><br></p><h2 id="Yh9if"><span class="ne-text">二、今日的烦恼将成为明日的笑话</span></h2><p id="u6d06dbc1" class="ne-p"><br></p><p id="ud938f18d" class="ne-p"><span class="ne-text">专栏作家</span></p><p id="u9cf30ed4" class="ne-p"><br></p><p id="u28d89714" class="ne-p"><span class="ne-text">既然要写专栏，记得多看专栏，仔细研究其他作者的可读性因素何在。我开始时，先拜十三妹为师，她是专栏作家的老祖宗。本人未见，读遍她的文字，知道她除了谈论国际关系、文学音乐戏剧之外，也多涉及生活点滴，连看医生，向人借钱，也可以娓娓道来，这才能与读者融合在一起。（蔡澜语录）</span></p><p id="u5b344c61" class="ne-p"><br></p><p id="uad7098ac" class="ne-p"><span class="ne-text">作者需要不断地吸收，才能付出。需要不耻下问。旅行、交友、阅读、爱戏剧电影、绘画、音乐等等，是基本的条件。专栏作者和小说家完全是两码子事，后者可以把自己藏起来，编写出动人的故事，但是前者每天赤裸裸地把生活点滴奉献给读者。想过什么、做过什么，都在每天的专栏看得清清楚楚，是假装不出来的。</span></p><p id="ub4a88d73" class="ne-p"><br></p><p id="u7b4e3fee" class="ne-p"><span class="ne-text">我们这些写作人，多多少少都有发表欲，既然有了，不必要扮清高，迎合读者，不是大罪。</span></p><p id="u79358cd8" class="ne-p"><br></p><p id="u55a3832c" class="ne-p"><strong><span class="ne-text">真，是专栏作者的本钱，一假便被看穿，如果我们把真诚的感情放在文字上，读者也许不喜欢，可是一旦爱上，就是终生的了</span></strong><span class="ne-text">。</span></p><p id="ud8d43abc" class="ne-p"><br></p><p id="u5cd19cbc" class="ne-p"><span class="ne-text">既然要写专栏，记得多看专栏，仔细研究其他作者的可读性因素何在。我开始时，先拜十三妹为师，她是专栏作家的老祖宗。本人未见，读遍她的文字，知道她除了谈论国际关系、文学音乐戏剧之外，也多涉及生活点滴，连看医生，向人借钱，也可以娓娓道来，这才能与读者融合在一起。</span></p><p id="u6f5d6a81" class="ne-p"><br></p><div data-type="info" class="ne-alert"><p id="u531382dd" class="ne-p"><span class="ne-text">“真，是专栏作者得本钱！”受益这句话。</span></p></div><p id="ub9a5b83d" class="ne-p"><br></p><hr id="cFgK1" class="ne-hr"><p id="u0e0c8001" class="ne-p"><span class="ne-text">飞行等级</span></p><p id="u8593262e" class="ne-p"><br></p><p id="u3e1a197f" class="ne-p"><br></p><p id="u0ad696d7" class="ne-p"><span class="ne-text">生活质量的提高，商务舱已是抢手货，不管是否公费，大家一坐过之后，已不能退步去坐经济舱了，自掏腰包，也非商务不可，有些航线，已是一半商务一半经济了，更夸张的，是整架飞机，只有商务的趋势。</span></p><p id="uc55ae58d" class="ne-p"><span class="ne-text"><br /></span><span class="ne-text">人往高处，乘商务的，心中也一直想要坐头等，头等那么好吗？值得吗？<br /></span><span class="ne-text">可以把座椅当床平卧，是最大的特点，但这种服务，多数的商务舱已能做到。<br /></span><span class="ne-text">吃得好，喝得佳吗？也不是，所谓的香槟，皆非第一流的，鱼子酱更是咸得要死。坐欧洲的航空公司，头等还有一点头等味道，亚洲的，有钱人通街都是，不当你是贵客。头等，只能遇到一些不肯退休的空中服务员，反正不会被炒鱿鱼，也带狗眼看人低的眼光了。<br /></span><span class="ne-text">说什么，也是商务物有所值，但物有所值这句话，是昂贵的，当今的旅行费，绝不便宜。</span></p><p id="uc299d177" class="ne-p"><br></p><div data-type="info" class="ne-alert"><p id="u9836b93d" class="ne-p"><span class="ne-text">或许是不是所有事物都是物有所值把……</span></p></div><p id="u2d592bcb" class="ne-p"><br></p><h2 id="LPqqm"><span class="ne-text">三、只有自爱才心安理得</span></h2><p id="uf2a0221e" class="ne-p"><span class="ne-text">旅行伴侣</span></p><p id="u0b304dc2" class="ne-p"><span class="ne-text"><br /></span><span class="ne-text">看了电视剧而找原著来读的不乏其人，相反就寥寥无几。到底，电视剧给我们的是固定的形象，失去了看书的幻想力。（蔡澜语录）</span></p><p id="u395c48c8" class="ne-p"><br></p><div data-type="info" class="ne-alert"><p id="u4fddb723" class="ne-p"><span class="ne-text">还好吧，我觉得『士兵突击』这部电视剧和小说就不错。</span></p></div><p id="u17234d0e" class="ne-p"><br></p><hr id="kP6at" class="ne-hr"><p id="uda4ab8c6" class="ne-p"><span class="ne-text">交友</span></p><p id="ube810227" class="ne-p"><br></p><p id="ue2d8a17c" class="ne-p"><span class="ne-text">最重要的，是把自己最真实的一面表露出来。真面目示众又如何？相貌是父母赐予，不应为讨好别人而改变。如果不够自信，就努力看书，增加自己的内涵，多写精彩的文章，日子久了，就会有人欣赏。</span></p><p id="u8698e1e4" class="ne-p"><br></p><hr id="b4K8C" class="ne-hr"><p id="u7263fd8e" class="ne-p"><span class="ne-text">乐得拍掌</span></p><p id="u2b14386b" class="ne-p"><br></p><p id="ufecede8b" class="ne-p"><span class="ne-text">做人最好的就是醉生梦死。醉生，每天喝醉；梦死，在做梦的时候死去，多幸福！（蔡澜语录）</span></p><h2 id="HnFuJ"><span class="ne-text">四、豁得出去，又是另一片天空</span></h2><p id="u76bd7f0e" class="ne-p"><span class="ne-text">痴人说梦</span></p><p id="u2d495759" class="ne-p"><br></p><p id="u7062ceba" class="ne-p"><span class="ne-text">我一直做梦，梦见给人追杀。醒来，原来是一场梦，怎会不高兴？哈哈哈哈。（蔡澜语录）</span></p><hr id="g3Uxd" class="ne-hr"><p id="u1e463490" class="ne-p"><span class="ne-text">做人</span></p><p id="ucff3b11e" class="ne-p"><br></p><p id="u818cd5cb" class="ne-p"><span class="ne-text">从小，父母亲就要我好好地“做人”。做人就是努力别看他人脸色，做人，也不必要给别人脸色看。生了下来，大家都是平等的。人与人之间要有一份互相的尊敬。所以我不管对方是什么职业，是老是少，我都尊重。（蔡澜语录）</span></p><p id="u63f70902" class="ne-p"><br></p><p id="u90f3d33a" class="ne-p"><span class="ne-text">“你到底是什么身份？电影人？食家？茶商？开餐厅的？开杂货店的？做零食的？卖财柴米油盐酱的？你最想别人怎么看你？”朋友问。“我只想做一个人。”我回答。</span><span class="ne-text">　　从小，父母亲就要我好好地“做人”。做人还不容易吗？不。不容易。“什么叫会做人？”朋友说，“看人脸色不就是？”不，做人就是努力别看他人脸色，做人，也不必要给别人脸色看。</span></p><p id="u58fc3a0c" class="ne-p"><br></p><p id="uce132af8" class="ne-p"><span class="ne-text">生了下来，大家都是平等的。人与人之间要有一份互相的尊敬。所以我不管对方是什么职业，是老是少，我都尊重。</span></p><p id="ud1e2e64c" class="ne-p"><br></p><p id="ubea532f4" class="ne-p"><span class="ne-text">除了尊敬人，也要尊敬我们住的环境，这是一个基本条件。</span></p><p id="uc4807e65" class="ne-p"><br></p><hr id="qJ3m8" class="ne-hr"><h2 id="iOPBS"><span class="ne-text">五、你是为谁生存</span></h2><p id="uefce642b" class="ne-p"><span class="ne-text">最喜欢的</span></p><p id="uc9484557" class="ne-p"><br></p><p id="ue24ae12d" class="ne-p"><span class="ne-text">写文章不求留世，工作当消遣，有什么说什么，东西不好吃就说不好吃，这种讲真话的本钱，是我花了数十年储蓄回来的。从前有点违背良心的话，是看到女人，都叫她们为“靓女”。当今也花不了本钱，说：“聪明。”（蔡澜语录）</span></p><p id="u2863cd09" class="ne-p"><br></p><hr id="3G76q" class="ne-hr"><p id="ufb358f61" class="ne-p"><span class="ne-text">教坏</span></p><p id="u09d444b9" class="ne-p"><br></p><p id="ub76b5b4c" class="ne-p"><span class="ne-text">“现在的孩子，都太乖了。出到社会，不知怎么面对。由我来教坏，遇到什么骗子都不必怕。我有个电影界的泰国朋友秦子彬先生，他把好赌的儿子带到拉斯维加斯去，给他一百万美金去赌，一下子输光，输得那儿子脸都青掉，从此不赌了。这不是以坏易好吗？”</span></p></div>]]></content>
      
      
      <categories>
          
          <category> 阅读 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>对平侠谈个人成长的一些感悟</title>
      <link href="/essay/coeh8m/"/>
      <url>/essay/coeh8m/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="e2f3704cf6670b85e36817769e9f9fcc" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1624096824333-d7a7a173-78ce-487b-8924-11e04875f913.png" width="1920" id="SJV2T" class="ne-image"></p><p id="1d6668e634401f3fd4f9dfc67554752a" class="ne-p"><br></p><p id="8c8fcf8a5ef50fbf6fe1e0c573b7ada3" class="ne-p"><span class="ne-text">前言：近期看到平侠作者发布的一篇文章『</span><a href="https://www.yuque.com/zenany/up/be_independent" data-href="https://www.yuque.com/zenany/up/be_independent" target="_blank" class="ne-link"><span class="ne-text">从高效能人士的七个习惯谈成长</span></a><span class="ne-text">』，作者对个人成长精炼出来三个要素：心态、格局、魄力，对应《高效能人士的七个习惯》就是积极主动、以终为始、要事第一这三点。这三点算是对个人成长的比较好的概括了，总的来说，这篇文章对近期有些烦躁的自己算是重新点亮了一盏明灯。</span></p><p id="477e38fb7ac7d6641e783be87cf4ebca" class="ne-p"><br></p><hr id="k0k7a" class="ne-hr"><p id="5e9af7d3ec9c6ebae86d4c4582f97905" class="ne-p"><br></p><h2 id="myjBr"><span class="ne-text">积极主动的心态</span></h2><p id="u456d0e22" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1624097233676-35f38d3c-7383-430a-9ca3-19551b956320.png" width="618.0208740234375" id="u5b8ae4a2" class="ne-image"></p><p id="d7b59f63f98e752ea3f40804e35336c8" class="ne-p"><br></p><p id="5628a002f07c9ae7759fbafa91e48b1b" class="ne-p"><span class="ne-text">作者说的这句话“</span><strong><span class="ne-text">接受无法改变的，改变有可能改变的</span></strong><span class="ne-text">”，我想应该是和李开复前辈的理念一样——“</span><strong><span class="ne-text">有勇气改变可以改变的，有胸怀接受不可改变的事情</span></strong><span class="ne-text">”，李开复其实后面还说道，“</span><strong><span class="ne-text">用智慧区分两者的不同</span></strong><span class="ne-text">”。其实说白了，就是对所处之境，所遇之事永远抱有一个乐观豁达的心态。</span></p><p id="aa6e9f6c20beab3aea21bbcc7ce596c3" class="ne-p"><br></p><p id="abe8f23a88d6be6ef8c66be72e738764" class="ne-p"><span class="ne-text">近期或然有些许同感，很多所有人都懂的道理，对一些人而言，由于性格的缘故，总要比别人接受的晚，再深点讲其实是内心不想接受罢了，抵触，就像是一个孩子被家长训话，就有些桀骜不驯的孩子，知道是这样的，知道这样是不对的，但就是愿意被性格被情绪所控制，但一旦懂得了并接受了这个所有人都懂的道理，成长加速度就会提升甚至赶超同龄人了，这或许就是成长吧。</span></p><p id="3f43d8ba7488fbf04573aa80db45c44d" class="ne-p"><br></p><div class="ne-quote"><p id="1844216885dfa369244e6831facf1e2d" class="ne-p"><span class="ne-text">天下事，难易相成。在做事的过程中，有顺境，有逆境，难在始终保持积极主动的心态。</span></p><p id="c104e7903380dd4b90271ddc9f84d4b9" class="ne-p"><span class="ne-text">顺境：比较容易做到积极主动，但也容易产生懈怠，需要顺势而为，不可懈怠，快速扩大成果。</span></p><p id="acb2874914169116381f2cd04baea73e" class="ne-p"><span class="ne-text">逆境：往往正是考验积极主动的时候，需要摆正心态，重塑信心，主动寻找改变的契机。</span></p></div><p id="afa0e71d2085b7622d3e7eb7871a70be" class="ne-p"><br></p><p id="d2edaa1299549e71332f332e57380469" class="ne-p"><span class="ne-text">作者这段话我觉得很不错，特别是对逆境的态度——始终坚持积极主动的心态。</span></p><p id="53533a4a221cda7757728bce513e3a53" class="ne-p"><br></p><p id="bd4824fec9840873a1ed87b6bd356c1f" class="ne-p"><span class="ne-text">积极主动的心态其实每个人或多或少都会，但是一直坚持的人，很少，也很难，但也正因是难，才要坚持不是么？（算是把自己好好教育了一番的感觉</span></p><p id="4697c6d6a95c7c2b5f2d2a7582f1a746" class="ne-p"><br></p><p id="b99996f0abb4df529a9c2797d21f5c23" class="ne-p"><span class="ne-text">三分钟不开刀无痛苦的历练，在这个文明制度下，不存在。</span></p><p id="349836253584b571db6174dd736420bb" class="ne-p"><br></p><h2 id="g5Mb0"><span class="ne-text">以终为始的格局</span></h2><p id="8ff8e1818720134b02154d779bd39479" class="ne-p"><span class="ne-text">换一个本人一直贯彻的学习方法中的一句话就是“以结果为导向”，以结果为导向的这种思维，在计算机专业里面特别好使，简单说明就是对于同一个技术，一个大作业比课堂上课一学期好使（我可没说我不好好听课</span><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1624095112125-51056426-2c52-4bbf-9d7f-128cd1fac489.png" width="74" id="aZJCK" class="ne-image"><span class="ne-text">）</span></p><p id="75aa5337178370ae751b7b279d33799a" class="ne-p"><br></p><p id="44a2d3320b7f8fe320e66225e7acf2df" class="ne-p"><span class="ne-text">对于把这种思维转到职业规划与发展里面，亦是如此，划分阶段的话，就如作者的三步，确定终点——推演路径——制定计划。虽然我不太习惯制定这种人生抑或是职业计划，但不得不承认，这种方式是有效果的。</span></p><p id="711d17f71664dc08138c9add98a3828b" class="ne-p"><br></p><p id="51a44226886c03223f1e351388ea3492" class="ne-p"><span class="ne-text">作者所推荐的他的师傅 </span><a href="https://www.zhihu.com/people/wuduoyi" data-href="https://www.zhihu.com/people/wuduoyi" target="_blank" class="ne-link"><span class="ne-text">nwind</span></a><span class="ne-text"> 传授的 </span><a href="https://baike.baidu.com/item/%E9%A9%AC%E9%B9%A4%E5%87%8C/5566647" data-href="https://baike.baidu.com/item/%E9%A9%AC%E9%B9%A4%E5%87%8C/5566647" target="_blank" class="ne-link"><span class="ne-text">马鹤凌老先生</span></a><span class="ne-text"> 的总结：</span><a href="https://github.com/zenany/zenany.github.io/blob/master/_posts/about_time_and_knowledge_management.md" data-href="https://github.com/zenany/zenany.github.io/blob/master/_posts/about_time_and_knowledge_management.md" target="_blank" class="ne-link"><span class="ne-text">此生理想、近期计划、今日功课</span></a><span class="ne-text">。仔细看了看，感觉也在强调计划的操作必要性。此刻，突然想到了兵长内心打算跟随团长的心理独白</span></p><p id="2cb82c13de3211ee0b1451a879120a08" class="ne-p"><br></p><p id="111cd6add3af243a58ba3a8650fb1d58" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1624096040600-e72f1c6f-cd5e-4421-a75c-9e5e8ac3edb7.png" width="650.9954223632812" id="bwQJL" class="ne-image"></p><p id="0247bc121ea0177ccd949d754a6717a3" class="ne-p"><span class="ne-text">“</span><strong><span class="ne-text">好吧，我就跟着你好了，埃尔文·史密斯</span></strong><span class="ne-text">”</span></p><p id="615f8bf674c2a0fe183d11aaa3242e6d" class="ne-p"><br></p><h2 id="IUEKs"><span class="ne-text">要事第一的魄力</span></h2><p id="cc37ee7ca89a086292e040c6c27c0de7" class="ne-p"><span class="ne-text">作者想要表达的是“专注当下，取舍果断”。</span></p><p id="13916f0afd1defae5fc51ad9eca3d5ce" class="ne-p"><br></p><p id="9833b0b36c446b504276a5ace21c1e85" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1624096754794-70a837ba-bd73-4a01-a20d-712bfe4266fe.png" width="632" id="Di3jA" class="ne-image"></p><p id="86a36e1a9f8e2145291351c318bb8273" class="ne-p"><br></p><p id="d6aee56be157d9a088a4e825d04444de" class="ne-p"><span class="ne-text">舍弃的精神，我觉得我有，作者所描述的今后我可能会遇到的工作方面，也有对职业的持续发展道路方面的，作者的三个问题值得记录：</span></p><p id="c840d6f4a8d55bd4d5bda686adafeffd" class="ne-p"><br></p><div class="ne-quote"><p id="163361efe17827b92a21e09f009ecd5a" class="ne-p"><span class="ne-text">1、我能为团队和公司带来什么？</span></p><p id="202d81b7c74e26af8558c1a16fe762e9" class="ne-p"><span class="ne-text">2、我从身边的人身上可以学到什么？</span></p><p id="13b73d98b2b968a11b365408d0c70217" class="ne-p"><span class="ne-text">3、我真正想做的事是什么？</span></p></div><p id="ac397cfcec4f53a20c4f2d6b00a3032d" class="ne-p"><br></p><p id="142ea0bea3bd4cbeafcfc34e553d1c43" class="ne-p"><span class="ne-text">时时刻刻想着这三个问题，其实结果还是比较显而易见的……</span></p><p id="ufc082983" class="ne-p"><br></p><p id="3a50d5b23e35b3c04c28834eae9cef4a" class="ne-p"><br></p></div>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>所有的职业终点都是NPC</title>
      <link href="/essay/dpauku/"/>
      <url>/essay/dpauku/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="udee1398d" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1623929248579-c01331e1-d895-4f58-bf92-026465a16a65.png" width="960" id="u7e92ea60" class="ne-image"></p><p id="u474d71c2" class="ne-p"><br></p><div class="ne-quote"><p id="u7ca8a55d" class="ne-p"><span class="ne-text">非玩家角色或称非操控角色（英语：Non-Player Character，NPC），是指角色扮演游戏中非玩家控制的角色。</span></p><p id="ub60f8b1b" class="ne-p"><span class="ne-text"></span></p><p id="uda30fd66" class="ne-p"><span class="ne-text">NPC是游戏背景中，非主角（狭义上来说还要求非敌人）的陪衬人物。玩家借由他们与游戏互动。在桌上角色扮演游戏里，NPC是由游戏主持者操纵，而在电脑角色扮演游戏里，则是由程序默认的剧本来决定NPC的反应，由游戏的人工智能做出控制。部分NPC有时可变成可操控角色</span></p><p id="uc516030e" class="ne-p"><span class="ne-text"></span></p><p id="ufb570d7c" class="ne-p"><span class="ne-text">——维基百科</span></p></div><p id="u93524499" class="ne-p"><span class="ne-text"></span></p><p id="ua68fe989" class="ne-p"><span class="ne-text">如果将一个人人生的职业经历划分为两段，第一段就像是打怪升级的攻略者，而后一段我想就是NPC吧</span></p><p id="u1894db03" class="ne-p"><span class="ne-text"></span></p><p id="u703679ac" class="ne-p"><span class="ne-text">现在的我就像是一个攻略者，利用对这个文明框架的种种，去攻略眼前的所有困难，但是，我似乎也看到了今后处在NPC角色的我……</span></p><p id="u5cb8c53d" class="ne-p"><span class="ne-text"></span></p><p id="uae26803d" class="ne-p"><span class="ne-text">如果把人生喻成一场游戏，那么我觉得人生的意义则是，</span><strong><span class="ne-text">用一颗勇敢的心，去攻略眼前的一个个困难</span></strong><span class="ne-text">。</span></p><p id="u9523df15" class="ne-p"><span class="ne-text"></span></p><p id="u300a354b" class="ne-p"><span class="ne-text"></span></p></div>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>文明框架下美好的事物是什么样的？</title>
      <link href="/essay/logfxx/"/>
      <url>/essay/logfxx/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="traditional"><p id="u193f4654" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1623724816738-638c68c5-a58d-4855-a83f-8040d78aba26.jpeg" width="1440" id="AqhVV" class="ne-image"></p><p id="u79885ccd" class="ne-p"><span class="ne-text">图：梁同学</span></p><p id="u96c6a069" class="ne-p"><br></p><hr id="pdIMd" class="ne-hr"><p id="u44d3f512" class="ne-p"><br></p><p id="udb0e38f5" class="ne-p"><br></p><p id="u231dca46" class="ne-p"><span class="ne-text">文明，历史的长久以往，让我们这个文明慢慢趋于一种某一方面而言的制度体系，或许对大多数人而言，这是一种常态，但对我而言，文明是框架。我并没有用束缚这个较为偏激的字眼去形容，而是用的框架。</span></p><p id="u4796a1d5" class="ne-p"><br></p><p id="u938f3c46" class="ne-p"><span class="ne-text">我们所喜欢的事物，至少我喜欢的事物，拆开了讲，许许多多都是都是被框架所限定，生活、思维、情感、甚至是内心，那为什么框架要限定出我们所定义出来的幸福呢？我脑海中浮现的答案是文明，是制度……</span></p><p id="u67bd9d81" class="ne-p"><br></p><p id="u43b784a3" class="ne-p"><span class="ne-text">地球最初的生命，或许只是造物主偷偷在一个水球中放下了能进行光合作用的一些小生物，进而演化成了我们此般文明景象罢了，我们都是进化而来的生物，而生物遵循了生物法则，长久以往的人们制定了无数有益于生存下去的制度、规则，而在这样的大环境下生活着，有一种奇妙的事物叫做快乐抑或是幸福。</span></p><p id="udc021f14" class="ne-p"><br></p><p id="u4b86ec93" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1623724819065-43292e39-1cfe-4dd4-b4a9-9cbf05167e4a.jpeg" width="1440" id="jClko" class="ne-image"></p><p id="u1a4a498a" class="ne-p"><br></p><p id="u45b23adb" class="ne-p"><span class="ne-text">人生的终极目标是什么？我又在一直追寻着什么啊？</span></p><p id="ue436ddde" class="ne-p"><br></p><p id="u10af1db1" class="ne-p"><span class="ne-text">我对自己问了一个特别大的问题，甚至有些幼稚的问题，或许我的潜意识里面想过这问题，但是又像是模模糊糊，如果用此刻大脑中的思绪来回答，我应该会回答：文明框架下的快乐和幸福。这个回答看起来是那么的简单易懂，却又有一些伤感与妥协，我站的太低了，我将自己死死地按在一个没有实体的框架下面，多么的悲怆，似乎就像是一台机器去做那些连幸福都定义好了的事情，</span></p><p id="ud45a6ea1" class="ne-p"><br></p><p id="ud771c32e" class="ne-p"><span class="ne-text">突然想到了一些人，无间道里面的刘建明和人间失格里面的叶藏，描述这两个人最好的状态就是无间，无间地狱，真的是艺术，描述的彻彻底底，佛教的思想：轮回、开悟、涅槃，而那两个人，无止境的在无间地狱轮回……想想这个文明制度下的种种，细思极恐</span></p><p id="u0acaf8a2" class="ne-p"><br></p><p id="ue3cfd092" class="ne-p"><br></p><p id="ue03791a5" class="ne-p"><span class="ne-text">人活着就是为了生活更快乐，更幸福，而幸福的生活要自己努力争取来的。</span></p><p id="u2d2d69a9" class="ne-p"><span class="ne-text"></span></p><p id="u26e92b81" class="ne-p"><span class="ne-text">我总是又在想，温柔的人为什么也会被</span></p><p id="u53aa6881" class="ne-p"><br></p><p id="u85586d79" class="ne-p"><br></p><hr id="Qp6B4" class="ne-hr"><p id="ua1d19015" class="ne-p"><br></p><p id="ud2fc7838" class="ne-p"><span class="ne-text">2021.06.16</span></p><p id="u792e40bb" class="ne-p"><span class="ne-text"></span></p><p id="u6b85ac87" class="ne-p"><span class="ne-text">“</span><strong><span class="ne-text">我不喜欢那些正确的人，那些从没堕落过、从没犯过错的人。生活的美未曾在他们面前展开过。</span></strong><span class="ne-text">”一个文学家在所沉浸的文学世界中的独白。</span></p><p id="u7a2eeda1" class="ne-p"><span class="ne-text"></span></p><p id="u39dd6c9a" class="ne-p"><span class="ne-text">真正的文学家总让人感觉是一个怪人，而我却独爱这般不被束缚的精神因子。</span></p><p id="u59b8f4c7" class="ne-p"><br></p><p id="u2fb77813" class="ne-p"><br></p><p id="u276fe678" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1626942905634-3fe3cc98-bedf-46bf-ac8e-20162a512b91.jpeg" width="1176" id="u233ed369" class="ne-image"></p><p id="u0baf1a43" class="ne-p"><br></p></div>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>各类排序算法汇总</title>
      <link href="/blog/garbxb/"/>
      <url>/blog/garbxb/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="598fe76c79cf4220ab7c32e59463c547" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1625064781047-2f12af3a-ce5c-4280-b387-38a40f307b45.jpeg" width="4961" id="yeGww" class="ne-image"></p><p id="f4799e2e37bd6cff1a774b72530e172e" class="ne-p"><br></p><p id="a4c64971ad367882801c73ec3d3dc979" class="ne-p"><span class="ne-text">前言：排序按照所占用的计算机内部存储设备，可以分为：</span><strong><span class="ne-text">内部排序</span></strong><span class="ne-text">和</span><strong><span class="ne-text">外部排序</span></strong></p><ul class="ne-ul"><li id="4b0aba3fe82521f2629e180cf11c0c74"><strong><span class="ne-text">内部排序：</span></strong><span class="ne-text">占用的是内存，待排序序列全部放在内存加以排序处理</span></li><li id="ce7426ba9e5f35c43ed4f0e90104c7b8"><strong><span class="ne-text">外部排序：</span></strong><span class="ne-text">占用的是外存，数据量比较大，内存空间不足以一次性全部容纳数据的情况</span></li></ul><p id="7f749a6f10609a76ec5fd0b57e19dd42" class="ne-p"><br></p><p id="8a996d904321b45f997b52fd816b00df" class="ne-p"><span class="ne-text">本文章 通过</span><a href="https://leetcode.cn/problems/sort-an-array/" data-href="https://leetcode.cn/problems/sort-an-array/" class="ne-link"><span class="ne-text">912. 排序数组</span></a><span class="ne-text"> 题目，以此来总结内部排序的各种排序算法。</span></p><p id="c9527610c382b4e6629792750a2166da" class="ne-p"><br></p><p id="7da58a290fd9cd6f0c506cf3e1747b3d" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1623667337022-44c54af8-5961-43d6-8fa4-46ef3f6ec71f.png" width="746" id="zJx4v" class="ne-image"></p><h2 id="qzpnY"><span class="ne-text">一、插入类排序</span></h2><p id="1c913d93d2cc9eff048644211658bd5c" class="ne-p"><span class="ne-text">将无序的子序列插入到有序序列中</span></p><h3 id="etEGl"><span class="ne-text">✅直接插入</span></h3><p id="f1f5744d5e0ed7b62a44cfdc3abd8e30" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/gif/1484158/1625014050650-261f0307-6356-440f-b06a-12e264344572.gif" width="813" id="pZjWF" class="ne-image"></p><p id="d5d5ac06f356ce66f8e428f2f3582506" class="ne-p"><span class="ne-text">将元素序列走一遍，走到某个元素时，将其插入到已走过的已排序序列中，这样可以保证走完所有元素，然后所有的元素都是排序好的。</span></p><p id="94537a784913cd4dce7e158543975878" class="ne-p"><span class="ne-text">数据结构选用的时顺序表</span></p><pre><code>/*** @param &#123;number[]&#125; nums* @return &#123;number[]&#125;*/var sortArray = function(nums) &#123;  for (let i = 0; i&lt;nums.length; i++) &#123;    let flag = i    for(let j = flag-1;j&gt;=0;j--) &#123;      if (nums[flag] &lt; nums[j]) &#123;        let temp = nums[j]        nums[j] = nums[flag]        nums[flag] = temp        flag--      &#125;     &#125;  &#125;  return nums&#125;;</code></pre><p id="uf9efec9a" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1653228341393-1bd78b67-0797-4bec-add7-be5d8295ac35.png" width="567.4074474905118" id="uecb8136f" class="ne-image"></p><h3 id="thpnK"><span class="ne-text">优化：折半插入</span></h3><p id="c3ffa5c0de2325e5e10b036617fee982" class="ne-p"><span class="ne-text">在直接插入的过程中，找到一个元素，然后再需要从后往前依次查找“该在”的位置，对其查找进行了折半优化</span></p><pre><code>/* 折半插入排序 */void BinsertSort(SqList &amp;S) &#123;    for (int i = 2; i &lt;= S.length;i++) &#123;        S.data[0] = S.data[i];        int low = 1;        int high = i - 1;        while (low &lt;= high) &#123;            int m = (low + high) / 2;            if (S.data[0]&lt;S.data[m]) high = m - 1;            else low = m + 1;        &#125;        int j;        for (j = i - 1; j &gt;= high + 1;--j)            S.data[j + 1] = S.data[j];        S.data[high + 1] = S.data[0];    &#125;&#125;</code></pre><h3 id="gP6SY"><span class="ne-text">优化：希尔排序</span></h3><p id="29eea55fa2a785edf01487c47c16eabc" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/gif/1484158/1625015190376-d54ed111-aa4a-41cf-9dde-6593a6aaf4e0.gif" width="665" id="KmYb4" class="ne-image"></p><pre><code>/* 希尔排序 */void ShellInsert (SqList &amp;L, int dk) &#123;    for (int i = dk + 1; i &lt;= L.length;++i) &#123;        if (L.data[i]&lt;L.data[i-dk]) &#123;            L.data[0] = L.data[i];            int j;            for (j = i - dk; j &gt; 0 &amp;&amp; L.data[0] &lt; L.data[j]; j -= dk)                L.data[j + dk] = L.data[j];            L.data[j + dk] = L.data[0];        &#125;    &#125;&#125;void ShellSort (SqList &amp;L, int dt[],int t) &#123;    for (int k = 0; k &lt; t;++k) &#123;        ShellInsert(L, dt[k]);    &#125;&#125;</code></pre><h2 id="B3KXE"><span class="ne-text">二、交换类排序</span></h2><h3 id="qHXfT"><span class="ne-text">✅冒泡排序</span></h3><p id="38bd96910e0a0454a5262c26035fe738" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/gif/1484158/1625013969954-b7310256-1c0a-4b3c-b45b-a7b33eca8e5c.gif" width="813" id="bVJVg" class="ne-image"></p><p id="u33c1f2b6" class="ne-p"><span class="ne-text"></span></p><pre><code>/** * @param &#123;number[]&#125; nums * @return &#123;number[]&#125; */var sortArray = function(nums) &#123;    for (let i = nums.length - 1; i&gt;0; i--) &#123;        for (let j = 0; j&lt;i; j++) &#123;            if (nums[j] &gt; nums[j+1]) &#123;                let temp = nums[j]                nums[j] = nums[j+1]                nums[j+1] = temp            &#125;        &#125;    &#125;    return nums&#125;;</code></pre><p id="u5d20c9a5" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1653213078608-86011f32-d058-4393-902d-33f97f21578b.png" width="578.5185593865401" id="u8a10d142" class="ne-image"></p><h3 id="tjRbu"><span class="ne-text">快速排序</span></h3><p id="2abcad580b30aa89bbac80e2f52ce1d6" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/gif/1484158/1625017709918-661c5cd4-fd2a-49a0-be80-bb59b791ed8f.gif" width="811" id="jCV3S" class="ne-image"></p><pre><code>/* 快速排序 */int Partition (SqList &amp;L, int low, int high) &#123;    L.data[0] = L.data[low];    int pivotkey = L.data[low];    while (low &lt; high) &#123;        while (low&lt;high &amp;&amp; L.data[high]&gt;=pivotkey)            --high;        L.data[low] = L.data[high];        while (low&lt;high &amp;&amp; L.data[low]&lt;=pivotkey)            ++low;        L.data[high] = L.data[low];    &#125;    L.data[low] = L.data[0];    return low;&#125;void Qsort(SqList &amp;L, int low, int high) &#123;    if (low&lt;high)&#123;        int pivoloc = Partition(L, low, high);        Qsort(L, low, pivoloc - 1);        Qsort(L, pivoloc + 1, high);    &#125;&#125;void QuickSort(SqList &amp;L) &#123;    Qsort(L, 1, L.length);&#125;</code></pre><h2 id="vqepg"><span class="ne-text">三、选择类排序</span></h2><p id="3aebb659010899dbfd5c16c892662a01" class="ne-p"><a href="http://data.biancheng.net/view/72.html" data-href="http://data.biancheng.net/view/72.html" target="_blank" class="ne-link"><span class="ne-text">参考：ata.biancheng.net/view/72.html</span></a></p><h3 id="Vrp7T"><span class="ne-text">✅简单选择排序</span></h3><p id="d5b876da9ea6683382d3772e8c2ad53a" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/gif/1484158/1625014017576-1b58bc2d-d46b-48e8-a307-6fc6f4ee8f0a.gif" width="813" id="FeuYg" class="ne-image"></p><pre><code>/** * @param &#123;number[]&#125; nums * @return &#123;number[]&#125; */var sortArray = function(nums) &#123;    for (let i = 0; i&lt;nums.length-1; i++) &#123;        for (let j = i+1; j&lt;nums.length; j++) &#123;            if (nums[i] &gt; nums[j]) &#123;                let temp = nums[i]                nums[i] = nums[j]                nums[j] = temp            &#125;        &#125;    &#125;    return nums&#125;;</code></pre><p id="u43567c96" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1653226950636-0e2a6743-01fe-4195-8d7e-a0c59a37891e.png" width="568.1481882835803" id="u6b1a3b2d" class="ne-image"></p><h3 id="8Zesn"><span class="ne-text">树形选择排序</span></h3><p id="96b4ae1229b083e76e8eb148c07e0084" class="ne-p"><br></p><h3 id="Ry3ha"><span class="ne-text">堆排序</span></h3><p id="27bd8e77d511f4282b5bf855ef57d576" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/gif/1484158/1625021691601-c1572503-c54d-4d12-8d3e-97da2ae0aa38.gif" width="547" id="b5jeQ" class="ne-image"></p><h2 id="wYfdM"><span class="ne-text">四、归并排序</span></h2><h3 id="NMBwV"><span class="ne-text">2-路归并排序</span></h3><p id="ea33608f775147ff8f17087962c9765e" class="ne-p"><span class="ne-text">给定一个序列，从左往右两两子序列进行归并</span></p><p id="6c0a75ff9d8bbfc8288fa678954e5fc6" class="ne-p"><br></p><p id="b8819e93c9172046b1309ff544c4fe6f" class="ne-p"><span class="ne-text">子序列归并的算法：加入有两个靠着的a、b序列，由上面可知，a、b各自都是有序序列，现在就是将这两个合并为一个有序序列k，将a和b序列的各个元素进行比较，小的依次放入k序列，当a、b两个中有一个序列为空了，就将那个不为空的序列直接加入到k序列即可，最后k序列就是目的序列。</span></p><p id="557d9af01136329dd59b2fa7244f3275" class="ne-p"><br></p><p id="461f6d5fc01208d120906ab21346aa22" class="ne-p"><br></p><h2 id="FZipi"><span class="ne-text">五、分配类排序</span></h2><h3 id="Qx2Q5"><span class="ne-text">基数排序</span></h3><p id="353887e2cdc59884fedc11e96e262efc" class="ne-p"><span class="ne-text">TODO: 扑克牌的花色排序</span></p><h2 id="HtSzO"><span class="ne-text">六、外部排序</span></h2><h3 id="CTOql"><span class="ne-text">基本方法</span></h3><h3 id="69w00"><span class="ne-text">多路平衡归并</span></h3><p id="862b47dd7bfc84c631f63adff5eb7698" class="ne-p"><span class="ne-text">基本思想是内部排序中的2-路归并排序</span></p><h3 id="MbQii"><span class="ne-text">置换-选择排序</span></h3><h3 id="AFobc"><span class="ne-text">最佳归并树</span></h3><h2 id="lRFoT"><span class="ne-text">参考</span></h2><p id="7bb6c59cbacbf8c147d2f3a63ef6f7cb" class="ne-p"><span class="ne-text">文章的动画演示</span></p><ul class="ne-ul"><li id="1e3a39bc9ae64cef928baee74add8602"><a href="https://blog.csdn.net/Hk_john/article/details/79888992" data-href="https://blog.csdn.net/Hk_john/article/details/79888992" target="_blank" class="ne-link"><span class="ne-text">https://blog.csdn.net/Hk_john/article/details/79888992</span></a><span class="ne-text">（js）</span></li><li id="daec35f35e8ed9e9f2186b3bd8c5ad29"><a href="https://www.itrhx.com/2020/10/23/A91-sorting-algorithm/" data-href="https://www.itrhx.com/2020/10/23/A91-sorting-algorithm/" target="_blank" class="ne-link"><span class="ne-text">https://www.itrhx.com/2020/10/23/A91-sorting-algorithm/</span></a><span class="ne-text">（python）</span></li></ul></div>]]></content>
      
      
      <categories>
          
          <category> 计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 📊查找排序算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>一个梦——梦中姑娘</title>
      <link href="/essay/di14o2/"/>
      <url>/essay/di14o2/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><div data-type="info" class="ne-alert"><p id="33be681ccc83e4979d2e8754a2873dd2" class="ne-p"><span class="ne-text">空调+风扇睡觉-&gt;易着凉-&gt;易做梦</span></p><p id="4424c713d130cfb637c4d73b8b7cf267" class="ne-p"><span class="ne-text">因着凉而做的梦大多不是自然醒，此般</span><span class="ne-text">崩坏醒……</span></p></div><p id="5f784f94c5ab374ea88f0635ecabbbf2" class="ne-p"><br></p><p id="446e5edef9cc3c53f6ad238d4f5a2aad" class="ne-p"><br></p><p id="a20d224c568e48b9d67847a2c66a8c01_p_0" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1623127396847-7144e32c-9f84-4c90-ad75-307f781827a5.png" width="1080" id="IChRS" class="ne-image"></p><p id="f08c18d7c72c51cd6ec1f17f6bd61327" class="ne-p"><br></p><p id="3429bc03398d7bba3a9aed2305d1497f" class="ne-p"><br></p><hr id="KyTjg" class="ne-hr"><p id="918755d555b381178962fd033ea8dff5" class="ne-p"><br></p></div>]]></content>
      
      
      <categories>
          
          <category> 异世界 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>《人间失格》——“纯真无垢的信任算是罪过吗？”</title>
      <link href="/essay/am0q19/"/>
      <url>/essay/am0q19/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="ue5633382" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1622964551715-a700f7e7-b3e8-45c5-9d80-787cbb0c66f3.png" width="400" id="u8cf446b6" class="ne-image"></p><p id="u797500bd" class="ne-p"><br></p><div data-type="info" class="ne-alert"><p id="u224179b9" class="ne-p"><span class="ne-text">“纯真无垢的信任算是罪过吗？”</span></p></div><p id="ue7be8be3" class="ne-p"><br></p><p id="u7bbd9143" class="ne-p"><span class="ne-text">经历了小时候的“看脸色行事”、中学寄读、与家庭隔绝任何关系……</span></p><p id="u2913a434" class="ne-p"><br></p><p id="ua6524f03" class="ne-p"><span class="ne-text">回归抑郁惆怅的那会日常状态，常去的那家酒馆，将自己灌得烂醉，突然有一天，遇见的不懂何为污秽的童贞的由子润湿了生来敏感的叶藏……</span></p><p id="u1ab3498b" class="ne-p"><br></p><div data-type="info" class="ne-alert"><p id="u41d70760" class="ne-p"><span class="ne-text">“即便因为这样日后遭逢再大的悲哀也无所谓，我一定要放纵地享受眼前这极度的欢乐，哪怕这一生仅有这一次。”</span></p></div><p id="ue99521cc" class="ne-p"><br></p><p id="u59bd13fc" class="ne-p"><span class="ne-text">还记得『无间道』里面说的「八大地狱之最，称为无间地狱，为无间断遭受大苦大意，故有此名」</span></p><p id="ucd0f2fd4" class="ne-p"><br></p><p id="u0571b508" class="ne-p"><span class="ne-text">人会变吗？不知道，但我知道敏感的人不易变……</span></p><p id="uc20bcc88" class="ne-p"><br></p><div data-type="info" class="ne-alert"><p id="u1092398f" class="ne-p"><span class="ne-text">四周的气氛蓦地变得异样紧张。两个人从楼顶天台走到二楼,再从二楼往底楼我的屋子走去。在楼梯上堀木停住了脚步,用手指着前面小声说道:“你看!”我家那间屋子上方的小窗户正敞开着,从那儿可以看到里面的光景。</span></p><p id="ue51c3d03" class="ne-p"><br></p><p id="uf3ebdd88" class="ne-p"><span class="ne-text">只见屋子里亮着电灯,有两只动物正在干着什么。我顿时觉得头晕目眩、呼吸急促,但同时心里却在暗自低语—这也算是一出人间粉戏吧,这也算是人类的本性吧,没什么好大惊小怪的—我甚至忘记了出手去解救由子,只是久久地呆立在楼梯中间。</span></p></div><p id="u576d2e7e" class="ne-p"><br></p><p id="u4644d1e8" class="ne-p"><span class="ne-text">“解救”这个一词我不是很理解，我看了两遍，不知道由子是被迫的还是自愿的，但是根据后文的由子对叶藏的眼神躲避的情节，我感觉是自愿的……</span></p><p id="u6f523a3a" class="ne-p"><span class="ne-text"></span></p><div data-type="danger" class="ne-alert"><p id="u0c1cf9c9" class="ne-p"><span class="ne-text">每当我唤她时，她总是身体冷不丁一哆嗦，视线也不知道该投向哪里好。无论我再怎么装痴装疯胡言乱语以逗她一笑，她都一副茫然不知所措、坐立不安、战战兢兢的样子，和我说话时还心不在焉地乱用敬语。</span></p></div><p id="u5a3e9711" class="ne-p"><span class="ne-text"></span></p><hr id="sYclb" class="ne-hr"><p id="ue3f4938f" class="ne-p"><span class="ne-text">原文里面的天台上的叶藏心理……</span></p><p id="u0f9a860f" class="ne-p"><span class="ne-text"></span></p><div data-type="info" class="ne-alert"><p id="ucd4215fb" class="ne-p"><span class="ne-text">我则像逃命似的一个人又冲回到天台，躺在地上，仰望含满雨气的夏日夜空。此时，袭遍我全身的情感不是愤怒，也不是厌恶，更不是悲伤，而是极度的恐惧。那不是面对墓地中诸多幽灵时的恐惧，倒更像是在神社的杉树林间，撞见身着白衣的神明时的那种来自太古的、凶暴恶戾的、令人噤默失语般的恐惧。从那晚起，我开始少年白头，我越发对世间所有的一切失去信心，越发对人产生无止境的怀疑，从此诀别了对人世生活所抱有的全部期待、喜悦、共鸣。事实上，这也是我整个人生中起到决定性作用的一个事件，仿佛被人迎面一刀砍中眉间，日后无论我与任何人接触，那伤口便会隐隐作痛。</span></p></div><p id="u6dd35c42" class="ne-p"><span class="ne-text"></span></p><p id="ue0a7c670" class="ne-p"><span class="ne-text">丧，十分丧……这一段，以前看的极度压抑，现在看的十分同情，敏感的叶藏遇到这种事情，真的是上天的无间地狱的惩罚吗？那现在这个时代的人呢？</span></p><p id="ud66000a9" class="ne-p"><br></p><hr id="j9z3P" class="ne-hr"><p id="ud76c5d75" class="ne-p"><br></p><p id="u276fcea0" class="ne-p"><br></p><div data-type="info" class="ne-alert"><p id="u9d3c5d73" class="ne-p"><span class="ne-text">“纯真无垢的信任算是罪过吗？”</span></p><p id="ufb4eec64" class="ne-p"><span class="ne-text">“纯真无垢的信任之心，难道真是罪恶之源吗？！”</span></p></div><p id="u07af0976" class="ne-p"><br></p><p id="ub16ae777" class="ne-p"><span class="ne-text">作者说着两次，好像文中还有相似强调的话语，对于一个敏感的人的内心最信任人而言，则算是一种无言的崩溃把，堕入人间地狱……</span></p><p id="ua766c76c" class="ne-p"><br></p><p id="ud9d06c63" class="ne-p"><span class="ne-text">作者不解……</span></p><p id="ub9f2e79b" class="ne-p"><br></p><p id="u2b5c6aea" class="ne-p"><span class="ne-text">第一次看这本书对此我是感到抑郁，全程压抑，但是现在看来，感受到的是一个敏感的人对周围的无奈与妥协，到最后那纯真无垢的信任之心也已死……</span></p><p id="u154db264" class="ne-p"><br></p><p id="ubc724026" class="ne-p"><span class="ne-text">这样的人生是何等的失望……</span></p><p id="ue4923726" class="ne-p"><br></p></div>]]></content>
      
      
      <categories>
          
          <category> 阅读 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>《人生》之高加林的爱情我也曾有过……</title>
      <link href="/essay/mh44ds/"/>
      <url>/essay/mh44ds/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="ef6e5d9aa1a590615f8473d394d5f526" class="ne-p"><br></p><p id="5c5d199bb38661ac8f23fe4a363d512d" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1622168235721-f78e67ae-65fa-4208-bdf6-1bbad23a55a8.png" width="291.7477111816406" id="u836e58b6" class="ne-image"></p><p id="c38fbf887b9cc1272fec9e63ebf01020" class="ne-p"><span class="ne-text">以前看的，今天突然有一些很深的感悟</span></p><p id="89427396d2c5d1daa888afbdebb672d3" class="ne-p"><br></p><p id="ae9f2b2b925c6c5b0b5413909a302f3d" class="ne-p"><span class="ne-text">高加林把纯情美丽、聪慧贤淑的刘巧珍这块“金子”丢了，突然想到相似的自己、想到了守恒、想到了辗转反侧却也难忘的心思……</span></p><p id="5c9949954b1ac835a28fec5c7dd7e7d5" class="ne-p"><br></p><p id="b06f185f80c24604db0e907c7e6bf5b3" class="ne-p"><span class="ne-text">守恒律，总觉得这世界上任何东西</span></p><p id="48416172029192e65ab79e808f6bf6a9" class="ne-p"><span class="ne-text">这世界上的事情，总是守恒的，人和人之间的情感，爱情、人情味、亲情</span></p><p id="9010c8e3989fd7b1a3132f85c9688435" class="ne-p"><br></p><p id="039264b44bbe6a4d695c6ce3c31bd2e9" class="ne-p"><span class="ne-text">还记得路遥的《人生》最后说，加林失去了自己人生中最重要的金子，我觉得这也是守恒的，从一开始，高加林就获得了自己的“金子”，然而呢，没珍惜……一开始高加林的教师职位被强拉下来，这的确是人生的不公，但是这也迎来了上天送给他的巧珍这颗金子，而后呢，他又放弃了巧珍这颗金子，追寻另外的一个女人，到最后，这个金子也没了</span></p><p id="92b4ac2768507d2d16d76794d2e49bd0" class="ne-p"><br></p><p id="da45cca86e95857c8894ad872f2ab8d3" class="ne-p"><strong><span class="ne-text">现实是如此的相似，我曾经也失去过金子，她非常漂亮，些许单纯，些许霸道，还喜欢看言情小说……我们和书里面的主人公一摸一样，真就一模一样，原因无他，在当时看来，在当时周围整个世界看来，读书谈啥恋爱……那时的我，很懵懂···后来我就进高中了，她好像是去一个技术学院还是直接工作，我忘了，有一次我上QQ了，那会应该是高一，她真好也在，便和她聊起天，那会她好朋友也在，我们三个是朋友，那会我们一起聊天，突然她朋友来一句“你啥时候和我家XXX表白呢”……</span></strong></p><p id="265828558d5bc033a25f2506ec93a7ae" class="ne-p"><strong><span class="ne-text">是的，那会，又是在读书……我不记得我当时是怎么回应的了，我只知道我当时挺想看看她的……</span></strong></p><p id="36d339b8b1c63384d8c9a9091b4c37d8" class="ne-p"><br></p><p id="0366ac1c457a937be376892979616201" class="ne-p"><strong><span class="ne-text">我大学期间，她生娃了，很漂亮但不帅……</span></strong></p><p id="49c0faf53cf3bfda53a218397a5e2280" class="ne-p"><br></p><p id="ae02a52dc2f537a826f2421d1570c094" class="ne-p"><strong><span class="ne-text">我苦笑、却又辗转反侧……</span></strong></p><p id="bd8f1f817d61e9f33d0b886a53487a1d" class="ne-p"><br></p></div>]]></content>
      
      
      <categories>
          
          <category> 阅读 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>微信屏蔽的不只有网易云的『性格主导色』</title>
      <link href="/essay/qgtwsr/"/>
      <url>/essay/qgtwsr/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="d2b61f151acbde582282a6b2f646f8ce" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1622096165024-de751f5a-0c8f-4d21-8fe9-da41dbf459bf.jpeg" width="541" id="gsk95" class="ne-image"></p><p id="e82f5b43d584b8e8acc2faf69fe90ce4" class="ne-p"><span class="ne-text"></span></p><p id="u0d1d720a" class="ne-p"><span class="ne-text">前言：网易云『性格主导色』活动页面遭微信屏蔽，在微信软件中点击活动页面会出现以下警告内容。我倒是见怪不怪，因为被屏蔽的不只有网易云的『性格主导色』，还有许许多多默不作声的外链，细想之，我个人的看法是与其说这是一种为了维护绿色上网环境，倒不如说是对当下自媒体崛起的一种流量上的恐慌……</span></p><p id="d268c05fe4a227ded7bb1b61b084825d" class="ne-p"><br></p><p id="e934efc031950b4679c0209454f48a45" class="ne-p"><br></p><p id="616a3140048db0ff66dfb99d760786a4" class="ne-p"><span class="ne-text">现如今自媒体的崛起，广告的投放不单单是微信，短视频平台，某站平台等这些更加吸引广大用户的娱乐平台的崛起，说白了，自媒体的崛起给腾讯造成了流量上的恐慌，倘若在B站动漫里面推广一些产品，不比下面这种每天都看的心烦的广告好得多</span><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1622097105798-a36f91ad-5589-4393-8a28-1d152e214c18.jpeg" width="52" id="y9K8r" class="ne-image"><span class="ne-text">……</span></p><p id="367d4467982c910dd749f19c3ba15c70" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1622095673079-588276fc-6d38-4886-8d9c-be90b62f0f63.png" width="282" id="C71oi" class="ne-image"></p><p id="a4d23d825e04d4190e7e9fe9b45dccbf" class="ne-p"><span class="ne-text">但是作为腾讯的这种机制是说为了维护用户体验，保留用户的权益……就我个人而言，我所知道的不仅仅是这个事件被屏蔽，还有之前的语雀链接在微信也不能打开，另外近期，在QQ里面我打开自己的网站，也是无效的，会提示非官方网站，许多博客站点都被屏蔽了</span><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1622097255080-95d8e27c-375d-4629-b118-4f74c1273e9c.jpeg" width="62" id="XPRrb" class="ne-image"><span class="ne-text">，总的来说，像上面那种广告是不会被屏蔽的，但是像一些外链现在十有八九是会被屏蔽的，不管这外链是低质量内容还是有不错内容的站点。</span></p><p id="u120f98ee" class="ne-p"><br></p><hr id="MvSBf" class="ne-hr"><hr id="LyYCu" class="ne-hr"><p id="ub4ad397f" class="ne-p"><span class="ne-text">给自己测了下这个主导色，除了蓝色是对的，</span><strong><span class="ne-text">其他的都扯淡</span></strong><span class="ne-text">……</span><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1622098043031-f48fc2c7-e8d9-416f-acd6-925a9528af2e.jpeg" width="48" id="ohPur" class="ne-image"></p><p id="u33cd71f0" class="ne-p"><br></p><p id="ud7df80cd" class="ne-p"><br></p><p id="u3a52bc90" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1622097912666-9ca03aa8-58f6-4f2e-a5e0-02145b87cb74.jpeg" width="648" id="u0e97d042" class="ne-image"></p><p id="423180e1a9062261b09a97f824672c75" class="ne-p"><br></p><p id="e6809a4e992ace86e9ac676452459e73" class="ne-p"><br></p><p id="c8779dfb53d51b04df5d60283ef7b7e3" class="ne-p"><br></p></div>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>《活着》</title>
      <link href="/essay/rcexdl/"/>
      <url>/essay/rcexdl/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><div data-type="info" class="ne-alert"><p id="05795b68a4e1044120001f014cc351bb" class="ne-p"><span class="ne-text">今天突然打开电脑里面的OneNote，发现以前还真写过不少东西……记得当时看这本书的时候，是在一个下午，一个最深的场景主人公他儿子死了，那个清晨黎明两三点，富贵从医院背着儿子往家走的时候，那个场景，针对心酸……有些许微风，夹杂着些许露水……阵阵凉意~</span></p></div><p id="904cf7b39d4a7de52ca0664eae909127" class="ne-p"><br></p><p id="a20d224c568e48b9d67847a2c66a8c01_p_0" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1622032573540-7113b1ee-f2f6-419f-a75b-577f79de0a27.png" width="671.5" id="KlBtd" class="ne-image"></p><p id="1311f4bca42db95a08151cd53b683752" class="ne-p"><br></p><div data-type="info" class="ne-alert"><p id="bbb2ca74705fa037f6e4f73396f16d23" class="ne-p"><span class="ne-text">18年写的</span></p></div><p id="171d6cef71fd7d7c7a9a2a2dacd57b63" class="ne-p"><br></p><p id="b4ffda1cada83f72d344cbe02557cfd4" class="ne-p"><span class="ne-text">《活着》有感</span></p><p id="9880b967dd3394db8ac8db6a334286ef" class="ne-p"><br></p><p id="936315e433bcc154cf6a1fad055282a3" class="ne-p"><span class="ne-text">每个人的人生都不一样，但是我们都活着。</span></p><p id="dcabc343faf3c64f389ec41ef6b86675" class="ne-p"><br></p><p id="f8a32de698dd65c12ce295163b752662" class="ne-p"><span class="ne-text">——有感</span></p><p id="d2c04cb2afbd09a07bb82778cfc4d416" class="ne-p"><br></p><p id="878691c5f4e27bdc24ee4ac599a8ef2c" class="ne-p"><span class="ne-text">“我知道黄昏正在准瞬即逝，黑夜从天而降了。我看到广阔的土地袒露着结实的胸膛，那是召唤的姿态，就像女人召唤者她们的儿女，土地召唤着黑夜来临。”活着是一种姿态，一种哲学，主人公福贵的人生是不幸的，在那个时代生活的艰辛，身边的人都离他而去，他几乎失去了一切，但是他活着，活得无奈，活得平庸，活的平凡，但活出了活着的意义。每个人对于活着都会有不同的人生感悟，我们的人生都不一样，因为我们都活着。</span></p><p id="c7736f8bcbdc3edda2aa593a85016dfc" class="ne-p"><br></p><p id="0eb1dbe42aea2a8226dac1cea3c8b33c" class="ne-p"><span class="ne-text">一个人的人生会因为一个人的一次行为而改变，而改变正是一个人活着意义所在。赌博让福贵的家庭从家财万贯到穷困潦倒，我一直觉得一个有故事的人一定会是曾经经历了什么。这次赔债过程中，福贵的爹爹也去世了，再混的子女遇见这等事谁不会心里塌了一片天，可能一切对于当时的他来讲很沉重，但是已经发生了。紧接着的又是妻子家珍被她爹带回家。这里我最感触深的是单纯，天真无邪的凤霞。送给龙二钱的时候，被国民党强制性的拉去充炮兵，就这样又和妻子孩子失去联系，在每天的炮火里，唯一的牵挂也只有老婆孩子了，对啊，人只有在最失意的时候才会想起身边的人，才会珍惜所拥有的，曾经对妻子的漠不关心现在会有牵挂，</span></p><p id="bcd9e16522a95621c96c4311e012bc54" class="ne-p"><br></p><p id="bd8887e5a69427fbcdbb8d51aac4e659" class="ne-p"><span class="ne-text">在人民公社之后，百姓的日子日益变得破败不堪，我没有过也没有见过那时代的人，但是我长辈见过。小说有一个片段我觉得挺真实，凤霞用锄头挖到一个地瓜，但是却被村里其他人抢去，可能许多读者看到这不会有太多感触，但我是农村人，我对于此有些许的感触。在决定把凤霞送给别人家的时候，那真的真的是走到尽头了，</span></p><p id="a8f203ad7b6dbb596774ecdf0719b8ed" class="ne-p"><span class="ne-text">感触最深的就是，凤霞一天晚上偷偷跑回家，当福贵打开家门，凤霞望着自己的爹娘，说不出话，也听不见别人的话，当福贵决定送凤霞到城里人家时，他说了一句话“就是全家都饿死，也不送凤霞回去”，那一刻，我觉得很温暖，我相信，那是真正的父爱。活着为了什么，我觉得就是为了那些生活中的感动，一个人来到这个世界上，一定都是不容易的，有爱自己的父母，这些一切的一切都是会使得情大于现实。</span></p><p id="a4a582f626b93c8a827d0645c6b31254" class="ne-p"><br></p><p id="7b2058902899511b2306330250150b5c" class="ne-p"><span class="ne-text">原本已经不错的日子最后还是发生了不幸，儿子有庆离开了人世…那天晚上的福贵抱着有庆在回家的路上走走停停，停停走走，不是得停下坐在田埂看看自己的儿子，摸着儿子的脸庞，那时间我的眼眶真的湿了。不知道为什么，看到那时候我想起了我的父母…</span></p><p id="3f6fbce2dda36f7efe9069d15ac0c8ee" class="ne-p"><br></p><p id="34b59079f71c74ffc834901bdd49d0df" class="ne-p"><span class="ne-text">原本凤霞和二喜的婚姻可以让这个不幸的家庭融入点暖和的血液，只是老天还是无情，凤霞的接生让小的来到这个世上，而大的永远离开了。读到这，我的内心真的很难让我往下看了，因为在父母而言，自己的子女都早于自己离开人世，白发人送黑发人，这是怎样的一种伤感，谁能接受这样的现实呢？只是活着终究要活着。之后的生活家珍走了，走的坦然，走之前的家珍说过一句“下辈子还做你的女人，下辈子还和你过”，让我觉得，这是历经苦难之后真正的爱情。爱情是两情相悦，是无言的天长地久，我敬重他们的真爱。福贵晚年也离不开现实的摧残，二喜、苦根也都离开人世了，苦根还那么小，那么的天真，再往后，就是福贵的和老牛的余生了。</span></p><p id="049dae438737fc21e34b80696466b6fc" class="ne-p"><br></p><p id="ed7d0dde53b7d53e8028786d4b9a034e" class="ne-p"><span class="ne-text">远处的池塘边，有一头老牛在池边喝水，一位老人慢慢的走去。</span></p><p id="fceb970a55838b8744a4f4cff519a96d" class="ne-p"><br></p><p id="bb1388307b90b3ee0aa3fa86bbf70f80" class="ne-p"><span class="ne-text">尽管《活着》不是一部老师所要求的自传，但我恰恰觉得这是这个世界里许多平凡的人的自传，是那些这个社会中底层人民的生活真实写照，是那些渺小的生命，却能活出活着的意义。</span></p><p id="c2481fe8be7567940164ce7f5cf5038d" class="ne-p"><br></p><p id="b7da4d66ffd8383cca955fbb6dfba0ef" class="ne-p"><br></p><p id="829298cdfced754b6c6566f9cbac2fc3" class="ne-p"><span class="ne-text">福贵，福贵的牛，福贵的爹，龙二，家丁长根，老全，春生，家珍，凤霞，有庆，二喜，苦根</span></p><p id="7fe1e951d728d6503b99cb7c8b6b0c0b" class="ne-p"><span class="ne-text">和龙二赌博输了家底导致生活破败，爹爹去世了，家珍被她爹带回家</span></p><p id="9f6e2657353a2bec2ee18add05680803" class="ne-p"><span class="ne-text">被国名党拉去充炮兵，结识老全，春生，战败之际，投降回到家里见到老婆孩子</span></p><p id="7d9acd8b2ddde6e3755d97c9ff5f0ef4" class="ne-p"><span class="ne-text">人民公社的成立以及之后的潦倒生活，文革</span></p><p id="91ef678e8518e3dac8437d7307b82975" class="ne-p"><span class="ne-text">把凤霞送给别人家，最后还是情大于现实，留下凤霞一家人生活着</span></p><p id="0602788741f7fa9102b3c48a610b6c41" class="ne-p"><span class="ne-text">有庆献血离去，凤霞接生出血离去，家珍身子体弱离去，二喜工作事故离去，苦根吃豆子死去</span></p><p id="8a8c1dcc710561a2021aebdd665eda6a" class="ne-p"><br></p><p id="906faa5ee7c65f846679dba0cc041575" class="ne-p"><span class="ne-text">反过来我们也可以说，</span><strong><span class="ne-text">因为我们都活着，从而我们的人生可以选择得不一样</span></strong><span class="ne-text">。</span></p><p id="8f06410e555a21cb23ee58c612b9ff45" class="ne-p"><br></p><p id="c7d31ee818e418b7302309ec9b606c1f" class="ne-p"><span class="ne-text">作者是以第一人称来塑造富贵这个人物形象，最后的最后只有富贵和他的老牛，不幸的人生，却告诉我们一个人生哲学：活着本身的意义就是活着。</span></p><p id="0731a5b59c027f3439682eb1fd845b60" class="ne-p"><br></p></div>]]></content>
      
      
      <categories>
          
          <category> 阅读 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>『境界的彼方』</title>
      <link href="/essay/wvwrcu/"/>
      <url>/essay/wvwrcu/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="traditional"><p id="u435b3838" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/jpg/1484158/1623940888474-c6aa4c62-7d9d-44df-b0ab-bd198c263434.jpg" width="2003" id="T2Yxz" class="ne-image"></p><p id="6246a9bb1cda408c977bad04d75c2888" class="ne-p"><br></p><p id="uceda34d7" class="ne-p"><span class="ne-text">两个特殊身份的角色在一起发生的战斗纯爱番……栗山未来是有着“被诅咒血脉”的异界士少女，神原秋人是有着寄居在体内强大妖梦的半妖（最大的反派竟是主角自己</span><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1623926928373-713cb502-b0c8-43a3-ae20-e45a5b4d6828.jpeg" width="79" id="hqw9a" class="ne-image"></p><p id="u1a52d698" class="ne-p"><br></p><hr id="8gtz1" class="ne-hr"><p id="ud713ec65" class="ne-p"><br></p><p id="u6a479a0b" class="ne-p"><span class="ne-text">虚幻之影一战</span></p><p id="ue4cd9e2f" class="ne-p"><span class="ne-text">这算是秋人解开未来心结的剧情了，男主</span></p><p id="u10b370b4" class="ne-p"><br></p><p id="u0ec14f65" class="ne-p"><br></p><p id="u95718d68" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1623927006789-0efec99a-7362-4b1f-8118-0f139cb451a3.jpeg" width="1024" id="jD2t5" class="ne-image"></p><p id="udcc70e87" class="ne-p"><br></p><p id="ud285752b" class="ne-p"><br></p><p id="ubbfc4030" class="ne-p"><span class="ne-text">当一个纯爱的人突然有一天闯进缺爱的人世界，这个人就不再孤独，他的余生也注定会因此而改变……</span></p><p id="ue6f5448e" class="ne-p"><br></p><p id="u902ad01f" class="ne-p"><br></p><p id="u2e457d3d" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1623927008770-1000842b-b921-4257-9ffe-3698a435f1ef.png" width="1920" id="EBka9" class="ne-image"></p><p id="u71452075" class="ne-p"><br></p><p id="ucfe46fd0" class="ne-p"><span class="ne-text">受过爱的缺爱的人做出的抉择往往不会像常人一样……</span></p><p id="uef31c1e8" class="ne-p"><br></p><p id="u07e89aec" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1623927010160-66e09e34-7c86-4ac5-af4d-0097251e4f26.png" width="1920" id="WSDbg" class="ne-image"></p><p id="uc2681876" class="ne-p"><br></p><p id="u87d127d5" class="ne-p"><br></p><p id="uf52bea41" class="ne-p"><br></p><p id="ub6f752f2" class="ne-p"><br></p><p id="u349cf580" class="ne-p"><span class="ne-text">这个是真的呆萌……</span></p><p id="uad20e3cf" class="ne-p"><br></p><p id="uf68c7505" class="ne-p"><br></p><p id="u9bba37de" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1623927004531-2156628e-e34f-415b-9ff1-a2b53d98f167.jpeg" width="1024" id="KMadh" class="ne-image"></p></div>]]></content>
      
      
      <categories>
          
          <category> 影视 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>最短路径算法（Dijkstra+Floyd）</title>
      <link href="/blog/rxx0ab/"/>
      <url>/blog/rxx0ab/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h2 id="zNIHZ"><span class="ne-text">问题描述</span></h2><p id="62dc1f6eeaf4d085770a4b431580e59f" class="ne-p"><strong><span class="ne-text">校园最短路径实验</span></strong></p><p id="a73d6fe9137a449283e7e6174b9a8672" class="ne-p"><span class="ne-text">1、给出校园中常用的几个点，如教室550、文宗楼、三个食堂、大操场、宿舍楼（自定）、校门口、体育场；</span></p><p id="e872dd787b0659b0ba4e065a8d1304e5" class="ne-p"><span class="ne-text">2、画图并给出其邻接矩阵（请合作完成）；</span></p><p id="8dfdd4331fdd61b2225d6ae6be60e67c" class="ne-p"><span class="ne-text">3、用floyd算法求每对顶点间的最短路。</span></p><p id="695d4175097ade1b18ab44f07893e3d0" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1622701735560-677cf8e1-e3f6-4c6a-9288-500eefaae6d4.png" width="545.5" id="VrPJt" class="ne-image"></p><hr id="RYp3i" class="ne-hr"><p id="f5896a514532e26e9ab4f424db11e700" class="ne-p"><br></p><div data-type="tips" class="ne-alert"><p id="a20d224c568e48b9d67847a2c66a8c01_p_0" class="ne-p"><span class="ne-text">迪杰斯特拉（Dijkstra）算法</span></p></div><p id="f5df7e9bae3edc596f0249ded448a799" class="ne-p"><br></p><p id="c0ace7f4bd10e006e360cc545ad23796" class="ne-p"><span class="ne-text">Dijkstra算法是经典的单源最短路径算法，用于计算源点到其它所有顶点的最短路径。在图 G=(V,E) 中，假设每条边 E[i] 的权值距离为 w[i]，找到由源点 v0 到其余各点的最短路径。</span></p><p id="c4eda4769b9382558e617e1d98192a33" class="ne-p"><span class="ne-text">适用：不含负权重的图</span></p><p id="f8c761d9834b36277f84b1f6b36ba85f" class="ne-p"><br></p><p id="660b2e6d53de278be77090da3cdff5f4" class="ne-p"><span class="ne-text">算法当中，对图的遍历方式为BFS（广度优先遍历）</span></p><h2 id="GgRFy"><span class="ne-text">代码</span></h2><p id="48d84c4d0710621d0f26ff9b37fc918b" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1622703321484-ea1fa3e2-34db-4827-8048-cd68231125cb.png" width="280.5" id="MRDfH" class="ne-image"></p><pre><code>/** * C++: Floyd算法获取最短路径(邻接矩阵) * */<p>#include &lt;iomanip&gt;<br>#include &lt;iostream&gt;<br>#include &lt;vector&gt;<br>#include &lt;bits/stdc++.h&gt;<br>using namespace std;</p><p>// 边的结构体<br>class EData<br>&#123;<br>    public:<br>        char start; // 边的起点<br>        char end;   // 边的终点<br>        int weight; // 边的权重</p><pre><code>public:    EData()&#123;&#125;    EData(char s, char e, int w):start(s),end(e),weight(w)&#123;&#125;</code></pre><p>};</p><p>class MatrixUDG {<br>    #define MAX    100<br>    #define INF    (~(0x1&lt;&lt;31))        // 无穷大(即0X7FFFFFFF)<br>    private:<br>        char mVexs[MAX];    // 顶点集合<br>        int mVexNum;             // 顶点数<br>        int mEdgNum;             // 边数<br>        int mMatrix[MAX][MAX];   // 邻接矩阵</p><pre><code>public:    // 创建图(自己输入数据)    MatrixUDG();    // 创建图(用已提供的矩阵)    //MatrixUDG(char vexs[], int vlen, char edges[][2], int elen);    MatrixUDG(char vexs[], int vlen, int matrix[][9]);    ~MatrixUDG();    // 深度优先搜索遍历图    void DFS();    // 广度优先搜索（类似于树的层次遍历）    void BFS();    // prim最小生成树(从start开始生成最小生成树)    void prim(int start);    // 克鲁斯卡尔（Kruskal)最小生成树    void kruskal();    // Dijkstra最短路径    void dijkstra(int vs, int vexs[], int dist[]);    // Floyd最短路径    void floyd(int path[][MAX], int dist[][MAX]);    // 打印矩阵队列图    void print();private:    // 读取一个输入字符    char readChar();    // 返回ch在mMatrix矩阵中的位置    int getPosition(char ch);    // 返回顶点v的第一个邻接顶点的索引，失败则返回-1    int firstVertex(int v);    // 返回顶点v相对于w的下一个邻接顶点的索引，失败则返回-1    int nextVertex(int v, int w);    // 深度优先搜索遍历图的递归实现    void DFS(int i, int *visited);    // 获取图中的边    EData* getEdges();    // 对边按照权值大小进行排序(由小到大)    void sortEdges(EData* edges, int elen);    // 获取i的终点    int getEnd(int vends[], int i);</code></pre><p>};</p><p>/* </p><ul><li><p>创建图(自己输入数据)</p></li><li><p>/<br>MatrixUDG::MatrixUDG()<br>{<br>  char c1, c2;<br>  int i, j, weight, p1, p2;</p><p>  // 输入&quot;顶点数&quot;和&quot;边数&quot;<br>  cout &lt;&lt; &quot;input vertex number: &quot;;<br>  cin &gt;&gt; mVexNum;<br>  cout &lt;&lt; &quot;input edge number: &quot;;<br>  cin &gt;&gt; mEdgNum;<br>  if ( mVexNum &lt; 1 || mEdgNum &lt; 1 || (mEdgNum &gt; (mVexNum * (mVexNum-1))))<br>  {</p><pre><code>  cout &amp;lt;&amp;lt; &amp;quot;input error: invalid parameters!&amp;quot; &amp;lt;&amp;lt; endl;  return ;</code></pre><p>  }</p><p>  // 初始化&quot;顶点&quot;<br>  for (i = 0; i &lt; mVexNum; i++)<br>  {</p><pre><code>  cout &amp;lt;&amp;lt; &amp;quot;vertex(&amp;quot; &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &amp;quot;): &amp;quot;;  mVexs[i] = readChar();</code></pre><p>  }</p><p>  // 1. 初始化&quot;边&quot;的权值<br>  for (i = 0; i &lt; mVexNum; i++)<br>  {</p><pre><code>  for (j = 0; j &amp;lt; mVexNum; j++)  &#123;      if (i==j)          mMatrix[i][j] = 0;      else          mMatrix[i][j] = INF;  &#125;</code></pre><p>  }<br>  // 2. 初始化&quot;边&quot;的权值: 根据用户的输入进行初始化<br>  for (i = 0; i &lt; mEdgNum; i++)<br>  {</p><pre><code>  // 读取边的起始顶点，结束顶点，权值  cout &amp;lt;&amp;lt; &amp;quot;edge(&amp;quot; &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &amp;quot;): &amp;quot;;  c1 = readChar();  c2 = readChar();  cin &amp;gt;&amp;gt; weight;  p1 = getPosition(c1);  p2 = getPosition(c2);  if (p1==-1 || p2==-1)  &#123;      cout &amp;lt;&amp;lt; &amp;quot;input error: invalid edge!&amp;quot; &amp;lt;&amp;lt; endl;      return ;  &#125;  mMatrix[p1][p2] = weight;  mMatrix[p2][p1] = weight;</code></pre><p>  }<br>}</p></li></ul><p>/*</p><ul><li><p>创建图(用已提供的矩阵)</p></li><li></li><li><p>参数说明：</p></li><li><pre><code>vexs  -- 顶点数组</code></pre></li><li><pre><code>vlen  -- 顶点数组的长度</code></pre></li><li><pre><code>matrix-- 矩阵(数据)</code></pre></li><li><p>/<br>MatrixUDG::MatrixUDG(char vexs[], int vlen, int matrix[][9])<br>{<br>  int i, j;</p><p>  // 初始化&quot;顶点数&quot;和&quot;边数&quot;<br>  mVexNum = vlen;<br>  // 初始化&quot;顶点&quot;<br>  for (i = 0; i &lt; mVexNum; i++)</p><pre><code>  mVexs[i] = vexs[i];</code></pre><p>  // 初始化&quot;边&quot;<br>  for (i = 0; i &lt; mVexNum; i++)</p><pre><code>  for (j = 0; j &amp;lt; mVexNum; j++)      mMatrix[i][j] = matrix[i][j];</code></pre><p>  // 统计边的数目<br>  for (i = 0; i &lt; mVexNum; i++)</p><pre><code>  for (j = 0; j &amp;lt; mVexNum; j++)      if (i!=j &amp;amp;&amp;amp; mMatrix[i][j]!=INF)          mEdgNum++;</code></pre><p>  mEdgNum /= 2;<br>}</p></li></ul><p>/* </p><ul><li>析构函数</li><li>/<br>MatrixUDG::~MatrixUDG()<br>{<br>}</li></ul><p>/*</p><ul><li>返回ch在mMatrix矩阵中的位置</li><li>/<br>int MatrixUDG::getPosition(char ch)<br>{<br>  int i;<br>  for(i=0; i&lt;mVexNum; i++)<pre><code>  if(mVexs[i]==ch)      return i;</code></pre>  return -1;<br>}</li></ul><p>/*</p><ul><li><p>读取一个输入字符</p></li><li><p>/<br>char MatrixUDG::readChar()<br>{<br>  char ch;</p><p>  do {</p><pre><code>  cin &amp;gt;&amp;gt; ch;</code></pre><p>  } while(!((ch&gt;=’a’&amp;&amp;ch&lt;=’z’) || (ch&gt;=’A’&amp;&amp;ch&lt;=’Z’)));</p><p>  return ch;<br>}</p></li></ul><p>/*</p><ul><li><p>返回顶点v的第一个邻接顶点的索引，失败则返回-1</p></li><li><p>/<br>int MatrixUDG::firstVertex(int v)<br>{<br>  int i;</p><p>  if (v&lt;0 || v&gt;(mVexNum-1))</p><pre><code>  return -1;</code></pre><p>  for (i = 0; i &lt; mVexNum; i++)</p><pre><code>  if (mMatrix[v][i]!=0 &amp;amp;&amp;amp; mMatrix[v][i]!=INF)      return i;</code></pre><p>  return -1;<br>}</p></li></ul><p>/*</p><ul><li><p>返回顶点v相对于w的下一个邻接顶点的索引，失败则返回-1</p></li><li><p>/<br>int MatrixUDG::nextVertex(int v, int w)<br>{<br>  int i;</p><p>  if (v&lt;0 || v&gt;(mVexNum-1) || w&lt;0 || w&gt;(mVexNum-1))</p><pre><code>  return -1;</code></pre><p>  for (i = w + 1; i &lt; mVexNum; i++)</p><pre><code>  if (mMatrix[v][i]!=0 &amp;amp;&amp;amp; mMatrix[v][i]!=INF)      return i;</code></pre><p>  return -1;<br>}</p></li></ul><p>/*</p><ul><li><p>深度优先搜索遍历图的递归实现</p></li><li><p>/<br>void MatrixUDG::DFS(int i, int *visited)<br>{<br>  int w;</p><p>  visited[i] = 1;<br>  cout &lt;&lt; mVexs[i] &lt;&lt; &quot; &quot;;<br>  // 遍历该顶点的所有邻接顶点。若是没有访问过，那么继续往下走<br>  for (w = firstVertex(i); w &gt;= 0; w = nextVertex(i, w))<br>  {</p><pre><code>  if (!visited[w])      DFS(w, visited);</code></pre><p>  }</p></li></ul><p>}</p><p>/*</p><ul><li><p>深度优先搜索遍历图</p></li><li><p>/<br>void MatrixUDG::DFS()<br>{<br>  int i;<br>  int visited[MAX];       // 顶点访问标记</p><p>  // 初始化所有顶点都没有被访问<br>  for (i = 0; i &lt; mVexNum; i++)</p><pre><code>  visited[i] = 0;</code></pre><p>  cout &lt;&lt; &quot;DFS: &quot;;<br>  for (i = 0; i &lt; mVexNum; i++)<br>  {</p><pre><code>  //printf(&amp;quot;\n== LOOP(%d)\n&amp;quot;, i);  if (!visited[i])      DFS(i, visited);</code></pre><p>  }<br>  cout &lt;&lt; endl;<br>}</p></li></ul><p>/*</p><ul><li><p>广度优先搜索（类似于树的层次遍历）</p></li><li><p>/<br>void MatrixUDG::BFS()<br>{<br>  int head = 0;<br>  int rear = 0;<br>  int queue[MAX];     // 辅组队列<br>  int visited[MAX];   // 顶点访问标记<br>  int i, j, k;</p><p>  for (i = 0; i &lt; mVexNum; i++)</p><pre><code>  visited[i] = 0;</code></pre><p>  cout &lt;&lt; &quot;BFS: &quot;;<br>  for (i = 0; i &lt; mVexNum; i++)<br>  {</p><pre><code>  if (!visited[i])  &#123;      visited[i] = 1;      cout &amp;lt;&amp;lt; mVexs[i] &amp;lt;&amp;lt; &amp;quot; &amp;quot;;      queue[rear++] = i;  // 入队列  &#125;  while (head != rear)   &#123;      j = queue[head++];  // 出队列      for (k = firstVertex(j); k &amp;gt;= 0; k = nextVertex(j, k)) //k是为访问的邻接顶点      &#123;          if (!visited[k])          &#123;              visited[k] = 1;              cout &amp;lt;&amp;lt; mVexs[k] &amp;lt;&amp;lt; &amp;quot; &amp;quot;;              queue[rear++] = k;          &#125;      &#125;  &#125;</code></pre><p>  }<br>  cout &lt;&lt; endl;<br>}</p></li></ul><p>/*</p><ul><li><p>打印矩阵队列图</p></li><li><p>/<br>void MatrixUDG::print()<br>{<br>  int i,j;</p><p>  cout &lt;&lt; &quot;Martix Graph:&quot; &lt;&lt; endl;<br>  for (i = 0; i &lt; mVexNum; i++)<br>  {</p><pre><code>  for (j = 0; j &amp;lt; mVexNum; j++)      cout &amp;lt;&amp;lt; setw(10) &amp;lt;&amp;lt; mMatrix[i][j] &amp;lt;&amp;lt; &amp;quot; &amp;quot;;  cout &amp;lt;&amp;lt; endl;</code></pre><p>  }<br>}</p></li></ul><p>/*</p><ul><li><p>prim最小生成树</p></li><li></li><li><p>参数说明：</p></li><li><p>  start – 从图中的第start个元素开始，生成最小树</p></li><li><p>/<br>void MatrixUDG::prim(int start)<br>{<br>  int min,i,j,k,m,n,sum;<br>  int index=0;         // prim最小树的索引，即prims数组的索引<br>  char prims[MAX];     // prim最小树的结果数组<br>  int weights[MAX];    // 顶点间边的权值</p><p>  // prim最小生成树中第一个数是&quot;图中第start个顶点&quot;，因为是从start开始的。<br>  prims[index++] = mVexs[start];</p><p>  // 初始化&quot;顶点的权值数组&quot;，<br>  // 将每个顶点的权值初始化为&quot;第start个顶点&quot;到&quot;该顶点&quot;的权值。<br>  for (i = 0; i &lt; mVexNum; i++ )</p><pre><code>  weights[i] = mMatrix[start][i];</code></pre><p>  // 将第start个顶点的权值初始化为0。<br>  // 可以理解为&quot;第start个顶点到它自身的距离为0&quot;。<br>  weights[start] = 0;</p><p>  for (i = 0; i &lt; mVexNum; i++)<br>  {</p><pre><code>  // 由于从start开始的，因此不需要再对第start个顶点进行处理。  if(start == i)      continue;  j = 0;  k = 0;  min = INF;  // 在未被加入到最小生成树的顶点中，找出权值最小的顶点。  while (j &amp;lt; mVexNum)  &#123;      // 若weights[j]=0，意味着&amp;quot;第j个节点已经被排序过&amp;quot;(或者说已经加入了最小生成树中)。      if (weights[j] != 0 &amp;amp;&amp;amp; weights[j] &amp;lt; min)      &#123;          min = weights[j];          k = j;      &#125;      j++;  &#125;  // 经过上面的处理后，在未被加入到最小生成树的顶点中，权值最小的顶点是第k个顶点。  // 将第k个顶点加入到最小生成树的结果数组中  prims[index++] = mVexs[k];  // 将&amp;quot;第k个顶点的权值&amp;quot;标记为0，意味着第k个顶点已经排序过了(或者说已经加入了最小树结果中)。  weights[k] = 0;  // 当第k个顶点被加入到最小生成树的结果数组中之后，更新其它顶点的权值。  for (j = 0 ; j &amp;lt; mVexNum; j++)  &#123;      // 当第j个节点没有被处理，并且需要更新时才被更新。      if (weights[j] != 0 &amp;amp;&amp;amp; mMatrix[k][j] &amp;lt; weights[j])          weights[j] = mMatrix[k][j];  &#125;</code></pre><p>  }</p><p>  // 计算最小生成树的权值<br>  sum = 0;<br>  for (i = 1; i &lt; index; i++)<br>  {</p><pre><code>  min = INF;  // 获取prims[i]在mMatrix中的位置  n = getPosition(prims[i]);  // 在vexs[0...i]中，找出到j的权值最小的顶点。  for (j = 0; j &amp;lt; i; j++)  &#123;      m = getPosition(prims[j]);      if (mMatrix[m][n]&amp;lt;min)          min = mMatrix[m][n];  &#125;  sum += min;</code></pre><p>  }<br>  // 打印最小生成树<br>  cout &lt;&lt; &quot;PRIM(&quot; &lt;&lt; mVexs[start] &lt;&lt; &quot;)=&quot; &lt;&lt; sum &lt;&lt; &quot;: &quot;;<br>  for (i = 0; i &lt; index; i++)</p><pre><code>  cout &amp;lt;&amp;lt; prims[i] &amp;lt;&amp;lt; &amp;quot; &amp;quot;;</code></pre><p>  cout &lt;&lt; endl;<br>}</p></li></ul><p>/* </p><ul><li><p>获取图中的边</p></li><li><p>/<br>EData* MatrixUDG::getEdges()<br>{<br>  int i,j;<br>  int index=0;<br>  EData *edges;</p><p>  edges = new EData[mEdgNum];<br>  for (i=0; i &lt; mVexNum; i++)<br>  {</p><pre><code>  for (j=i+1; j &amp;lt; mVexNum; j++)  &#123;      if (mMatrix[i][j]!=INF)      &#123;          edges[index].start  = mVexs[i];          edges[index].end    = mVexs[j];          edges[index].weight = mMatrix[i][j];          index++;      &#125;  &#125;</code></pre><p>  }</p><p>  return edges;<br>}</p></li></ul><p>/* </p><ul><li><p>对边按照权值大小进行排序(由小到大)</p></li><li><p>/<br>void MatrixUDG::sortEdges(EData* edges, int elen)<br>{<br>  int i,j;</p><p>  for (i=0; i&lt;elen; i++)<br>  {</p><pre><code>  for (j=i+1; j&amp;lt;elen; j++)  &#123;      if (edges[i].weight &amp;gt; edges[j].weight)      &#123;          // 交换&amp;quot;边i&amp;quot;和&amp;quot;边j&amp;quot;          swap(edges[i], edges[j]);      &#125;  &#125;</code></pre><p>  }<br>}</p></li></ul><p>/*</p><ul><li>获取i的终点</li><li>/<br>int MatrixUDG::getEnd(int vends[], int i)<br>{<br>  while (vends[i] != 0)<pre><code>  i = vends[i];</code></pre>  return i;<br>}</li></ul><p>/*</p><ul><li><p>克鲁斯卡尔（Kruskal)最小生成树</p></li><li><p>/<br>void MatrixUDG::kruskal()<br>{<br>  int i,m,n,p1,p2;<br>  int length;<br>  int index = 0;          // rets数组的索引<br>  int vends[MAX]={0};     // 用于保存&quot;已有最小生成树&quot;中每个顶点在该最小树中的终点。<br>  EData rets[MAX];        // 结果数组，保存kruskal最小生成树的边<br>  EData *edges;           // 图对应的所有边</p><p>  // 获取&quot;图中所有的边&quot;<br>  edges = getEdges();<br>  // 将边按照&quot;权&quot;的大小进行排序(从小到大)<br>  sortEdges(edges, mEdgNum);</p><p>  for (i=0; i&lt;mEdgNum; i++)<br>  {</p><pre><code>  p1 = getPosition(edges[i].start);      // 获取第i条边的&amp;quot;起点&amp;quot;的序号  p2 = getPosition(edges[i].end);        // 获取第i条边的&amp;quot;终点&amp;quot;的序号  m = getEnd(vends, p1);                 // 获取p1在&amp;quot;已有的最小生成树&amp;quot;中的终点  n = getEnd(vends, p2);                 // 获取p2在&amp;quot;已有的最小生成树&amp;quot;中的终点  // 如果m!=n，意味着&amp;quot;边i&amp;quot;与&amp;quot;已经添加到最小生成树中的顶点&amp;quot;没有形成环路  if (m != n)  &#123;      vends[m] = n;                       // 设置m在&amp;quot;已有的最小生成树&amp;quot;中的终点为n      rets[index++] = edges[i];           // 保存结果  &#125;</code></pre><p>  }<br>  delete[] edges;</p><p>  // 统计并打印&quot;kruskal最小生成树&quot;的信息<br>  length = 0;<br>  for (i = 0; i &lt; index; i++)</p><pre><code>  length += rets[i].weight;</code></pre><p>  cout &lt;&lt; &quot;Kruskal=&quot; &lt;&lt; length &lt;&lt; &quot;: &quot;;<br>  for (i = 0; i &lt; index; i++)</p><pre><code>  cout &amp;lt;&amp;lt; &amp;quot;(&amp;quot; &amp;lt;&amp;lt; rets[i].start &amp;lt;&amp;lt; &amp;quot;,&amp;quot; &amp;lt;&amp;lt; rets[i].end &amp;lt;&amp;lt; &amp;quot;) &amp;quot;;</code></pre><p>  cout &lt;&lt; endl;<br>}</p></li></ul><p>/*</p><ul><li><p>Dijkstra最短路径。</p></li><li><p>即，统计图中&quot;顶点vs&quot;到其它各个顶点的最短路径。</p></li><li></li><li><p>参数说明：</p></li><li><pre><code>  vs -- 起始顶点(start vertex)。即计算&amp;quot;顶点vs&amp;quot;到其它顶点的最短路径。</code></pre></li><li><pre><code>prev -- 前驱顶点数组。即，prev[i]的值是&amp;quot;顶点vs&amp;quot;到&amp;quot;顶点i&amp;quot;的最短路径所经历的全部顶点中，位于&amp;quot;顶点i&amp;quot;之前的那个顶点。</code></pre></li><li><pre><code>dist -- 长度数组。即，dist[i]是&amp;quot;顶点vs&amp;quot;到&amp;quot;顶点i&amp;quot;的最短路径的长度。</code></pre></li><li><p>/<br>void MatrixUDG::dijkstra(int vs, int prev[], int dist[])<br>{<br>  int i,j,k;<br>  int min;<br>  int tmp;<br>  int flag[MAX];      // flag[i]=1表示&quot;顶点vs&quot;到&quot;顶点i&quot;的最短路径已成功获取。</p><p>  // 初始化<br>  for (i = 0; i &lt; mVexNum; i++)<br>  {</p><pre><code>  flag[i] = 0;              // 顶点i的最短路径还没获取到。  prev[i] = 0;              // 顶点i的前驱顶点为0。  dist[i] = mMatrix[vs][i]; // 顶点i的最短路径为&amp;quot;顶点vs&amp;quot;到&amp;quot;顶点i&amp;quot;的权。</code></pre><p>  }</p><p>  // 对&quot;顶点vs&quot;自身进行初始化<br>  flag[vs] = 1;<br>  dist[vs] = 0;</p><p>  // 遍历mVexNum-1次；每次找出一个顶点的最短路径。<br>  for (i = 1; i &lt; mVexNum; i++)<br>  {</p><pre><code>  // 寻找当前最小的路径；  // 即，在未获取最短路径的顶点中，找到离vs最近的顶点(k)。  min = INF;  for (j = 0; j &amp;lt; mVexNum; j++)  &#123;      if (flag[j]==0 &amp;amp;&amp;amp; dist[j]&amp;lt;min)      &#123;          min = dist[j];          k = j;      &#125;  &#125;  // 标记&amp;quot;顶点k&amp;quot;为已经获取到最短路径  flag[k] = 1;  // 修正当前最短路径和前驱顶点  // 即，当已经&amp;quot;顶点k的最短路径&amp;quot;之后，更新&amp;quot;未获取最短路径的顶点的最短路径和前驱顶点&amp;quot;。  for (j = 0; j &amp;lt; mVexNum; j++)  &#123;      tmp = (mMatrix[k][j]==INF ? INF : (min + mMatrix[k][j]));      if (flag[j] == 0 &amp;amp;&amp;amp; (tmp  &amp;lt; dist[j]) )      &#123;          dist[j] = tmp;          prev[j] = k;      &#125;  &#125;</code></pre><p>  }</p><p>  // 打印dijkstra最短路径的结果<br>  cout &lt;&lt; &quot;dijkstra(&quot; &lt;&lt; mVexs[vs] &lt;&lt; &quot;): &quot; &lt;&lt; endl;<br>  for (i = 0; i &lt; mVexNum; i++)</p><pre><code>  cout &amp;lt;&amp;lt; &amp;quot;  shortest(&amp;quot; &amp;lt;&amp;lt; mVexs[vs] &amp;lt;&amp;lt; &amp;quot;, &amp;quot; &amp;lt;&amp;lt; mVexs[i] &amp;lt;&amp;lt; &amp;quot;)=&amp;quot; &amp;lt;&amp;lt; dist[i] &amp;lt;&amp;lt; endl;</code></pre><p>}</p></li></ul><p>/*</p><ul><li><p>floyd最短路径。</p></li><li><p>即，统计图中各个顶点间的最短路径。</p></li><li></li><li><p>参数说明：</p></li><li><pre><code>path -- 路径。path[i][j]=k表示，&amp;quot;顶点i&amp;quot;到&amp;quot;顶点j&amp;quot;的最短路径会经过顶点k。</code></pre></li><li><pre><code>dist -- 长度数组。即，dist[i][j]=sum表示，&amp;quot;顶点i&amp;quot;到&amp;quot;顶点j&amp;quot;的最短路径的长度是sum。</code></pre></li><li><p>/<br>void MatrixUDG::floyd(int path[][MAX], int dist[][MAX])<br>{<br>  int i,j,k;<br>  int tmp;</p><p>  // 初始化<br>  for (i = 0; i &lt; mVexNum; i++)<br>  {</p><pre><code>  for (j = 0; j &amp;lt; mVexNum; j++)  &#123;      dist[i][j] = mMatrix[i][j];    // &amp;quot;顶点i&amp;quot;到&amp;quot;顶点j&amp;quot;的路径长度为&amp;quot;i到j的权值&amp;quot;。      path[i][j] = j;                // &amp;quot;顶点i&amp;quot;到&amp;quot;顶点j&amp;quot;的最短路径是经过顶点j。  &#125;</code></pre><p>  }</p><p>  // 计算最短路径<br>  for (k = 0; k &lt; mVexNum; k++)<br>  {</p><pre><code>  for (i = 0; i &amp;lt; mVexNum; i++)  &#123;      for (j = 0; j &amp;lt; mVexNum; j++)      &#123;          // 如果经过下标为k顶点路径比原两点间路径更短，则更新dist[i][j]和path[i][j]          tmp = (dist[i][k]==INF || dist[k][j]==INF) ? INF : (dist[i][k] + dist[k][j]);          if (dist[i][j] &amp;gt; tmp)          &#123;              // &amp;quot;i到j最短路径&amp;quot;对应的值设，为更小的一个(即经过k)              dist[i][j] = tmp;              // &amp;quot;i到j最短路径&amp;quot;对应的路径，经过k              path[i][j] = path[i][k];          &#125;      &#125;  &#125;</code></pre><p>  }<br>  char dot[] = {‘A’, ‘B’, ‘C’, ‘D’, ‘E’, ‘F’, ‘G’, ‘H’, ‘I’};<br>  // 打印floyd最短路径的结果<br>  cout &lt;&lt; &quot;floyd各个地点的最短路径矩阵如下: &quot; &lt;&lt; endl;<br>  cout &lt;&lt; &quot;    &quot;;<br>  for (int k = 0;k&lt;9;k++){</p><pre><code>  cout &amp;lt;&amp;lt; dot[k] &amp;lt;&amp;lt; &amp;quot;    &amp;quot;;</code></pre><p>  }<br>  cout &lt;&lt; &quot;\n&quot;;<br>  for (i = 0; i &lt; mVexNum; i++){</p><pre><code>  cout &amp;lt;&amp;lt; dot[i] &amp;lt;&amp;lt; &amp;quot;: &amp;quot;;  for (j = 0; j &amp;lt; mVexNum; j++)      cout &amp;lt;&amp;lt; setw(2) &amp;lt;&amp;lt; dist[i][j] &amp;lt;&amp;lt; &amp;quot;  &amp;quot;;  cout &amp;lt;&amp;lt; endl;</code></pre><p>  }<br>}</p></li></ul><p>int main()<br>{<br>    int prev[MAX] = {0};<br>    int dist[MAX] = {0};<br>    int path[MAX][MAX] = {0};    // 用于保存floyd路径<br>    int floy[MAX][MAX] = {0};    // 用于保存floyd长度<br>    char vexs[] = {‘A’, ‘B’, ‘C’, ‘D’, ‘E’, ‘F’, ‘G’, ‘H’, ‘I’};<br>    int matrix[][9] = {<br>                      /<em>A</em>//<em>B</em>//<em>C</em>//<em>D</em>//<em>E</em>//<em>F</em>//<em>G</em>//<em>H</em>//<em>I</em>/<br>      /<em>A西门</em>/     {   0,  615, 435, 210, 790,  INF,  INF, INF, INF},<br>      /<em>B550教室</em>/  { 615,   0,  144, 620, 380,   822, INF, INF, INF},<br>      /<em>C文宗楼</em>/   { 435,  144,   0,   INF,   265,   INF, INF, INF, INF},<br>      /<em>D二餐</em>/     { 210, 620,   INF,   0,   480, INF, INF, INF, 170},<br>      /<em>E图书馆</em>/   { 790, 380,   265,   480,   0,   620,   735, 310, 700},<br>      /<em>F北门</em>/     { INF, 822,   INF,   INF,   620,   0,   500, INF, INF},<br>      /<em>G体育馆</em>/   { INF, INF,   INF,   INF,   735,   500,   0, 556, INF},<br>      /<em>H一餐</em>/     {  INF,   INF,   INF, INF,   310,   INF,   556, 0, 420},<br>      /<em>I16号楼</em>/   {  INF, INF, INF, 170,   700,   INF,   INF, 420, 0}};<br>    int vlen = sizeof(vexs)/sizeof(vexs[0]);<br>    MatrixUDG* pG;</p><pre><code>// 自定义&amp;quot;图&amp;quot;(输入矩阵队列)//pG = new MatrixUDG();// 采用已有的&amp;quot;图&amp;quot;pG = new MatrixUDG(vexs, vlen, matrix);//pG-&amp;gt;print();   // 打印图//pG-&amp;gt;DFS();     // 深度优先遍历//pG-&amp;gt;BFS();     // 广度优先遍历//pG-&amp;gt;prim(0);   // prim算法生成最小生成树//pG-&amp;gt;kruskal(); // Kruskal算法生成最小生成树// dijkstra算法获取&amp;quot;第4个顶点&amp;quot;到其它各个顶点的最短距离//pG-&amp;gt;dijkstra(3, prev, dist);// floyd算法获取各个顶点之间的最短距离pG-&amp;gt;floyd(path, floy);return 0;</code></pre><p>}<br></code></pre></p><p id="890d57e51a7141565ace3003b56e24c7" class="ne-p"><br></p><h2 id="UcdRQ"><span class="ne-text">参考</span></h2><ul class="ne-ul"><li id="5086d9c56dadd125ba405e10f6379b06"><a href="https://houbb.github.io/2020/01/23/data-struct-learn-03-graph-dijkstra" data-href="https://houbb.github.io/2020/01/23/data-struct-learn-03-graph-dijkstra" target="_blank" class="ne-link"><span class="ne-text">图最短路径算法之迪杰斯特拉算法（Dijkstra）</span></a></li><li id="97fadfb9fac663e518e85ca92e948634"><a href="https://www.cnblogs.com/skywang12345/p/3711526.html" data-href="https://www.cnblogs.com/skywang12345/p/3711526.html" target="_blank" class="ne-link"><span class="ne-text">Floyd算法(二)之 C++详解</span></a></li></ul></div>]]></content>
      
      
      <categories>
          
          <category> 计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 贪心算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>图的遍历——DFS（深度优先）、BFS（广度优先）</title>
      <link href="/blog/ztiag3/"/>
      <url>/blog/ztiag3/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="c4377b9c5907fc32e4dd3a3ec889224d" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1621307069176-74d6900b-6edd-4e7a-b761-789df7a17cfe.png" width="563" id="W9sKH" class="ne-image"></p><p id="aeba3ae9fd44225e4bcdfd6b1387df74" class="ne-p"><br></p><div data-type="info" class="ne-alert"><p id="8602641d8bcd30fd83b83906a84c1786" class="ne-p"><span class="ne-text">前言：用邻接矩阵和邻接表两种图的存储形式实现DFS、BFS算法，并附例子实现。</span></p><p id="a2a30595325972cce3bffd75dcc31f68" class="ne-p"><span class="ne-text">总的来说，邻接矩阵比较好处理，没有邻接表处理那么复杂，但是数组永远不能规避的一个缺点就是内存的占用较邻接表高。</span></p></div><p id="905ea7f782ba98d5a209da0f35f5c203" class="ne-p"><br></p><h2 id="QOJfe"><span class="ne-text">一、深度优先搜索算法（Depth-First-Search）</span></h2><h3 id="MZ0vA"><span class="ne-text">算法说明</span></h3><p id="4e097c10f9608f768b643efb77ddac9f" class="ne-p"><strong><span class="ne-text">访问步骤：</span></strong></p><div class="ne-quote"><ul class="ne-ul"><li id="7a87afee8efc50a1215b2c73dee1007c"><span class="ne-text">访问顶点v；</span></li><li id="75fd425f477a5edfe8e8f42d7362ada1"><span class="ne-text">依次从v的未被访问的邻接点出发，对图进行深度优先遍历；直至图中和v有路径相通的顶点都被访问；</span></li><li id="fd5afc9bef88cbee4ece89b7a4b042f5"><span class="ne-text">若此时图中尚有顶点未被访问，则从一个未被访问的顶点出发，重新进行深度优先遍历，直到图中所有顶点均被访问过为止。</span></li></ul></div><p id="ba6b093d11719b506938b7131380d8ac" class="ne-p"><br></p><p id="0aab1d1b162418f9bf49863d35a32fda" class="ne-p"><strong><span class="ne-text">核心代码就是利用递归，以及标志数组的设定，每次访问数组元素的那一行，对那行链表进行遍历，每遍历一个链表结点，就将“其”所在的那个数组元素“点亮”。如果标志数组里面的所有元素都被访问了，说明遍历完了</span></strong></p><p id="b12a3d4a70976459fc1d9bcab1a7ff25" class="ne-p" style="text-indent: 2em"><br></p><p id="ccdd034b8bc976b98a833b1b3a4480f7" class="ne-p"><strong><span class="ne-text">深度优先搜索类似于树里面遍历算法当中的先序遍历。</span></strong></p><h3 id="ZU5Ew"><span class="ne-text">邻接矩阵的DFS代码</span></h3><p id="0c7fc91bebbf033661b0d2f0e2755bb3" class="ne-p"><span class="ne-text">以这个无向图为例</span></p><p id="e91496d0133f08a7c583147a966ce5cb" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1621329549870-b2fd8a63-a532-4860-8e46-a79cc52a7e0f.png" width="197" id="Xvwlk" class="ne-image"></p><p id="f5a357efd0ac30dc1a34889c7258c8c8" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1621329584016-32d023fe-dc14-4c0d-90e1-7afe6fcc9cd2.png" width="227.5" id="XY5Cd" class="ne-image"></p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;<p>#define MVNum 100<br>#define MaxInt 32767</p><p>typedef char VerTexType;<br>typedef int ArcType;</p><p>/**</p><ul><li>邻接矩阵存储形式</li><li>/<br>typedef struct &#123;<br>  /* data */<br>  VerTexType vexs[MVNum]; //顶点表<br>  ArcType arcs[MVNum][MVNum]; //邻接矩阵<br>  int vexnum, arcnum; //图的当前顶点和边数<br>&#125;AMGraph;</li></ul><p>/**</p><ul><li>确定v在G中的位置，即顶点数组的下标</li><li>/<br>int LocateVex(AMGraph &amp;G, char v) &#123;<br>  for (int i = 0; i &lt; G.vexnum;i++) &#123;<pre><code>  if (v == G.vexs[i])&#123;      return i;  &#125;</code></pre>  }<br>}</li></ul><p>/**</p><ul><li>如果创建无向图   </li><li>/<br>void CreateUDN(AMGraph &amp;G) {<br>  // 采用邻接矩阵表示法，创建无向图G<br>  cout &lt;&lt; &quot;请输入顶点数和边数：&quot; &lt;&lt; endl;<br>  cin &gt;&gt; G.vexnum &gt;&gt; G.arcnum; //输入顶点数和边数<br>  // 初始化顶点<br>  for (int i = 0; i &lt; G.vexnum;i++){<pre><code>  cout &amp;lt;&amp;lt; &amp;quot;请输入第&amp;quot; &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &amp;quot;个顶点值&amp;quot; &amp;lt;&amp;lt; endl;  cin &amp;gt;&amp;gt; G.vexs[i];</code></pre>  }<br>  // 初始化邻接矩阵的边的权值为最大值<br>  for (int i = 0; i &lt; G.vexnum;i++) {<pre><code>  for (int j = 0; j &amp;lt; G.vexnum;j++) &#123;      G.arcs[i][j] = 0;  &#125;</code></pre>  }<br>  // 构造邻接矩阵<br>  for (int k = 0; k &lt; G.arcnum;k++) {<pre><code>  cout &amp;lt;&amp;lt; &amp;quot;请输入每条边所依附的顶点：&amp;quot; &amp;lt;&amp;lt; endl;  char v1, v2;  int w = 1; //一条边所依附的顶点和权值  cin &amp;gt;&amp;gt; v1 &amp;gt;&amp;gt; v2;  int i = LocateVex(G, v1);  int j = LocateVex(G, v2);  G.arcs[i][j] = w;  G.arcs[j][i] = w;</code></pre>  }<br>}</li></ul><p>/**</p><ul><li>打印输出图</li><li>/<br>void Display(AMGraph &amp;G) {<br>  for (int i = 0; i &lt; G.vexnum;i++) {<pre><code>  for (int j = 0; j &amp;lt; G.vexnum;j++) &#123;      cout &amp;lt;&amp;lt; G.arcs[i][j] &amp;lt;&amp;lt; &amp;quot; &amp;quot;;  &#125;  cout &amp;lt;&amp;lt; endl;</code></pre>  }<br>}</li></ul><p>//—-邻接矩阵的DFS遍历—-</p><p>//访问标志数组，其初值为false<br>bool visited[MVNum]; </p><p>/**</p><ul><li>图G为邻接矩阵类型，从第v个顶点出发深度优先搜索遍历图G</li><li>/<br>void DFS_AM(AMGraph &amp;G, int v) {<br>  //访问第v个顶点，并置访问标志数组相应分量值为true<br>  cout&lt;&lt;v;<br>  visited[v] = true;<br>  //依次检查邻接矩阵v所在的行<br>  for(int w = 0; w &lt; G.vexnum; w++)  <pre><code>  //G.arcs[v][w] != 0表示w是v的邻接点，!visited[w]表示未访问到  if((G.arcs[v][w] != 0) &amp;amp;&amp;amp; (!visited[w]))        DFS_AM(G, w);    //递归调用DFS_AM</code></pre>}</li></ul><p>/**</p><ul><li>图G的储存类型任意，对非连通图G做深度优先遍历</li><li>/<br>void DFSTraverse(AMGraph &amp;G) {<br>  //访问标志数组初始化<br>  for(int v = 0; v &lt; G.vexnum; v++)  <pre><code>  visited[v] = false;</code></pre>  //循环调用DFS<br>  for(int v = 0; v &lt; G.vexnum; v++)  <pre><code>  if(!visited[v])      DFS_AM(G, v); //对尚未访问的顶点调用DFS</code></pre>}</li></ul><p>int main() {<br>    AMGraph test;<br>    CreateUDN(test);<br>    Display(test);<br>    DFSTraverse(test);<br>    return 0;<br>}</p><p></code></pre></p><h3 id="yoSIg"><span class="ne-text">邻接表的DFS代码</span></h3><p id="0185257cc5891b4779bd509a36e4bf08" class="ne-p"><span class="ne-text">举之前上课的一张PPT例子（元素插入为后插法）</span></p><p id="8f0f1b106f7dee1d8b9124d39e708517" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1621333199678-46b6841b-415b-46e8-b0f6-0d0407284b15.png" width="554" id="HmOsr" class="ne-image"></p><p id="7d9b1ab0ddea1a0b1cc6919a63753b20" class="ne-p"><span class="ne-text">结果</span></p><p id="87a60371c70d6ef42ae0b5733953742a" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1621333246481-117ec0ea-ab95-43be-ac13-75712fdf1e2b.png" width="222" id="KjOYY" class="ne-image"></p><pre><code>#include &lt;bits/stdc++.h&gt;using namespace std;<p>#define MVNum 100<br>#define MaxInt 32767</p><p>typedef char VerTexType;<br>typedef int OtherInfo;</p><p>/**</p><ul><li>邻接表存储</li><li>/</li></ul><p>/**</p><ul><li>存储结构</li><li>/<br>typedef struct ArcNode &#123;  //边结点<br>  int adjvex;  //该边所指向的结点的位置<br>  struct ArcNode *nextarc; //指向下一条边的指针<br>  OtherInfo info;   //和边相关的其他信息<br>&#125;ArcNode;</li></ul><p>typedef struct VNode &#123;   //顶点信息<br>    VerTexType data;  //数据域，存放顶点vi的名称或其他有关信息<br>    ArcNode *firstarc;  //指向第一条依附该顶点的边的指针<br>&#125;VNode, AdjList[MVNum]; //AdjList表示邻接表的类型</p><p>typedef struct &#123;<br>    AdjList vertices;<br>    int vexnum, arcnum; //图当前的顶点数和边数<br>&#125;ALGragh; //邻接表（Adjacency List）</p><p>/**</p><ul><li>找到v顶点在图的顶点数组中的位置</li><li>/<br>int LocateVex(ALGragh &amp;G, char v) &#123;<br>  for (int i = 0; i &lt; G.vexnum;i++) &#123;<pre><code>  if (v == G.vertices[i].data) &#123;      return i;  &#125;</code></pre>  }<br>}</li></ul><p>/**</p><ul><li>邻接表创建无向图</li><li>/<br>void CreateUDG(ALGragh &amp;G) {<br>  cout &lt;&lt; &quot;请输入顶点数和边数：&quot; &lt;&lt; endl;<br>  cin &gt;&gt; G.vexnum &gt;&gt; G.arcnum; // 邻接表的顶点数和边数<br>  // 初始化顶点数组<br>  for (int i = 0; i &lt; G.vexnum;i++) {<pre><code>  cin &amp;gt;&amp;gt; G.vertices[i].data; // 初始化顶点数组里面的结点data  G.vertices[i].firstarc = NULL; // 初始化顶点数组里面的结点next域</code></pre>  }<br>  // 初始化所有的边<br>  for (int k = 0; k &lt; G.arcnum;k++) {<pre><code>  char v1, v2;  cout &amp;lt;&amp;lt; &amp;quot;请输入每条边所依附的顶点：&amp;quot; &amp;lt;&amp;lt; endl;  cin &amp;gt;&amp;gt; v1 &amp;gt;&amp;gt; v2;  int i = LocateVex(G, v1); // 找到v1在顶点数组的下标  int j = LocateVex(G, v2); // 找到v2在顶点数组的下标  // 下面建立p1和p2是因为无向图，如果是有向图就没必要了只需要p1  // 前插  ArcNode *p1 = new ArcNode;  p1-&amp;gt;adjvex = j;  p1-&amp;gt;nextarc = G.vertices[i].firstarc;  G.vertices[i].firstarc = p1;  ArcNode *p2 = new ArcNode;  p2-&amp;gt;adjvex = i;  p2-&amp;gt;nextarc = G.vertices[j].firstarc;  G.vertices[j].firstarc = p2;</code></pre>  }<br>}</li></ul><p>/**</p><ul><li>打印输出图</li><li>/<br>void Display(ALGragh &amp;G) {<br>  for (int i = 0; i &lt; G.vexnum;i++) {<pre><code>  cout &amp;lt;&amp;lt; &amp;quot;结点&amp;quot; &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &amp;quot;：&amp;quot;;  // 复制选中的节点数组中的结点  VNode p;  p = G.vertices[i];  if (p.firstarc != NULL)&#123;      ArcNode *temp;      temp = G.vertices[i].firstarc;      while (temp != NULL) &#123;          cout &amp;lt;&amp;lt; temp-&amp;gt;adjvex&amp;lt;&amp;lt;&amp;quot; &amp;quot;;          temp = temp-&amp;gt;nextarc;      &#125;      cout &amp;lt;&amp;lt; &amp;quot;\n&amp;quot;;  &#125;</code></pre>  }<br>}</li></ul><p>//—-邻接表的DFS遍历—-<br>bool visited[MVNum];                                                    //访问标志数组，其初值为false</p><p>void DFS_AL(ALGragh G, int v)<br>{//图G为邻接表类型，从从第v个顶点出发深度优先搜索遍历图G<br>    cout&lt;&lt;v;                                                            //访问第v个顶点，并置访问标志数组相应分量值为true<br>    visited[v] = true;<br>    ArcNode *p;<br>    p = G.vertices[v].firstarc;                                         //p指向v的边链表的第一个边结点<br>    while(p != NULL)<br>    {<br>       int w = p-&gt;adjvex;                                               //w是v的邻接点<br>        if(!visited[w])                                                 //如果w未访问<br>            DFS_AL(G, w);                                               //递归调用DFS_AL<br>        p = p-&gt;nextarc;                                                 //p指向下一个结点<br>    }<br>}</p><p>void DFSTraverse(ALGragh G)<br>{//图G的储存类型任意，对非连通图G做深度优先遍历<br>    for(int v = 0; v &lt; G.vexnum; v++)                                   //访问标志数组初始化<br>        visited[v] = false;<br>    for(int v = 0; v &lt; G.vexnum; v++)                                   //循环调用DFS<br>        if(!visited[v])<br>            DFS_AL(G, v);                                                  //对尚未访问的顶点调用DFS<br>}</p><p>int main() {<br>    ALGragh test;<br>    CreateUDG(test);<br>    // Display(test);<br>    DFSTraverse(test);<br>}<br></code></pre></p><h2 id="QXnap"><span class="ne-text">二、广度优先搜索算法（Breadth-First-Search）</span></h2><h3 id="G0xbz"><span class="ne-text">算法说明</span></h3><p id="94b96fd18f6299a92edb0bbb0104497e" class="ne-p"><span class="ne-text">从某个顶点V0出发，并在访问此顶点之后依次访问V0的所有未被访问过的邻接点，之后按这些顶点被访问的先后次序依次访问它们的邻接点，直至图中所有和V0有路径相通的顶点都被访问到。</span></p><p id="79c6bc4660da95e5eb3a4d3b82f0c95d" class="ne-p"><span class="ne-text"></span></p><p id="7d0dd6f76b33ab2e7809089c7833daa9" class="ne-p"><span class="ne-text">若此时图中尚有顶点未被访问，则另选图中一个未曾被访问的顶点作起始点，重复上述过程，直至图中所有顶点都被访问到为止。</span></p><p id="c994dac6d6ea729bf4c53d5e56f6b638" class="ne-p"><br></p><p id="5603100122d38ec5f9e050b858b65d40" class="ne-p"><strong><span class="ne-text">在树遍历中类似层次遍历。</span></strong></p><p id="cec298b23684b1046e1e7ced82785774" class="ne-p"><strong><span class="ne-text"></span></strong></p><h3 id="tX0WF"><span class="ne-text">邻接矩阵的BFS代码</span></h3><p id="2c79fedd6fba3d1dc3fa877ec630c8b4" class="ne-p"><span class="ne-text">还是这个例子</span></p><p id="4182bef26913ccb9daaf8020669dfc2f" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1621329549870-b2fd8a63-a532-4860-8e46-a79cc52a7e0f.png" width="197" id="bbWIn" class="ne-image"></p><p id="aee9ada2779b6772f70229266531e473" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1621338913834-3f2453f3-c56d-4401-9e26-2de805587a04.png" width="228.5" id="hRiOt" class="ne-image"></p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;<p>#define MVNum 100<br>#define MaxInt 32767</p><p>typedef char VerTexType;<br>typedef int ArcType;</p><p>/**</p><ul><li>邻接矩阵的bfs代码</li><li>/<br>typedef struct &#123;<br>  /* data */<br>  VerTexType vexs[MVNum]; //顶点表<br>  ArcType arcs[MVNum][MVNum]; //邻接矩阵<br>  int vexnum, arcnum; //图的当前顶点和边数<br>&#125;AMGraph;</li></ul><p>/**</p><ul><li>确定v在G中的位置，即顶点数组的下标</li><li>/<br>int LocateVex(AMGraph &amp;G, char v) &#123;<br>  for (int i = 0; i &lt; G.vexnum;i++) &#123;<pre><code>  if (v == G.vexs[i])&#123;      return i;  &#125;</code></pre>  }<br>}</li></ul><p>/**</p><ul><li>创建无向网</li><li>如果创建无向图   </li><li>/<br>void CreateUDN(AMGraph &amp;G) {<br>  // 采用邻接矩阵表示法，创建无向图G<br>  cout &lt;&lt; &quot;请输入顶点数和边数：&quot; &lt;&lt; endl;<br>  cin &gt;&gt; G.vexnum &gt;&gt; G.arcnum; //输入顶点数和边数<br>  // 初始化顶点<br>  for (int i = 0; i &lt; G.vexnum;i++){<pre><code>  cout &amp;lt;&amp;lt; &amp;quot;请输入第&amp;quot; &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &amp;quot;个顶点值&amp;quot; &amp;lt;&amp;lt; endl;  cin &amp;gt;&amp;gt; G.vexs[i];</code></pre>  }<br>  // 初始化邻接矩阵的边的权值为最大值<br>  for (int i = 0; i &lt; G.vexnum;i++) {<pre><code>  for (int j = 0; j &amp;lt; G.vexnum;j++) &#123;      G.arcs[i][j] = 0;  &#125;</code></pre>  }<br>  // 构造邻接矩阵<br>  for (int k = 0; k &lt; G.arcnum;k++) {<pre><code>  cout &amp;lt;&amp;lt; &amp;quot;请输入每条边所依附的顶点：&amp;quot; &amp;lt;&amp;lt; endl;  char v1, v2;  int w = 1; //一条边所依附的顶点和权值  cin &amp;gt;&amp;gt; v1 &amp;gt;&amp;gt; v2;  int i = LocateVex(G, v1);  int j = LocateVex(G, v2);  G.arcs[i][j] = w;  G.arcs[j][i] = w;</code></pre>  }<br>}</li></ul><p>/**</p><ul><li>打印输出图</li><li>/<br>void Display(AMGraph &amp;G) {<br>  for (int i = 0; i &lt; G.vexnum;i++) {<pre><code>  for (int j = 0; j &amp;lt; G.vexnum;j++) &#123;      cout &amp;lt;&amp;lt; G.arcs[i][j] &amp;lt;&amp;lt; &amp;quot; &amp;quot;;  &#125;  cout &amp;lt;&amp;lt; endl;</code></pre>  }<br>}</li></ul><p>//—-邻接矩阵的BFS遍历—-</p><p>bool visited[MVNum]; </p><p>void BFS_AM(AMGraph G, int v)<br>{//按广度优先非递归遍历连通图G<br>    cout&lt;&lt;v;<br>    visited[v] = true; //访问第v个顶点，并置访问标志数组相应分量值为true<br>    queue&lt;int&gt; Q;<br>    Q.push(v);<br>    while(!Q.empty())<br>    {<br>        int u = Q.front(); //队头元素出队并置为u<br>        Q.pop();<br>        for(int w = 0; w &lt; G.vexnum; w++)<br>            if((G.arcs[u][w] != 0) &amp;&amp; (!visited[w])) //G.arcs[v][w] != 0表示w是v的邻接点，!visited[w]表示未访问到                                            //w为u的尚未访问的邻接顶点<br>            {<br>                cout&lt;&lt;w;<br>                visited[w] = true; //访问w，并置访问标志数组相应分量值为true<br>                Q.push(w); //w进队<br>            }<br>    }<br>}</p><p>void BFSTraverse(AMGraph &amp;G) {<br>    //访问标志数组初始化<br>    for(int v = 0; v &lt; G.vexnum; v++)<br>        visited[v] = false;<br>    //循环调用BFS<br>    for(int v = 0; v &lt; G.vexnum; v++)<br>        if(!visited[v])<br>            BFS_AM(G, v); //对尚未访问的顶点调用BFS<br>}</p><p>int main() {<br>    AMGraph test;<br>    CreateUDN(test);<br>    Display(test);<br>    // DFSTraverse(test);<br>    BFSTraverse(test);<br>    return 0;<br>}</p><p></code></pre></p><h3 id="1RjxQ"><span class="ne-text">邻接表的BFS代码</span></h3><p id="19d60bf6aae1fc1f2364707c8a4a32c7" class="ne-p"><span class="ne-text">还用和DFS一样的例子</span></p><p id="2f63b2855bb2a7ced47b120060177ab5" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1621339344717-55530db9-253b-451d-af57-b591ff17353e.png" width="417" id="I73u9" class="ne-image"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1621390194148-da12a2e4-1f85-491b-9e53-3848ac4e4a4c.png" width="167" id="iul50" class="ne-image"></p><p id="5b8a5022ed1fcec1eef4bd087d6293fa" class="ne-p"><br></p><p id="44e1f9ec1603ae99eb545fd108578a1c" class="ne-p"><br></p><pre><code>#include &lt;bits/stdc++.h&gt;using namespace std;<p>#define MVNum 100<br>#define MaxInt 32767</p><p>typedef char VerTexType;<br>typedef int OtherInfo;</p><p>/**</p><ul><li>邻接表的bfs代码</li><li>/</li></ul><p>/**</p><ul><li>存储结构</li><li>/<br>typedef struct ArcNode &#123;  //边结点<br>  int adjvex;  //该边所指向的结点的位置<br>  struct ArcNode *nextarc; //指向下一条边的指针<br>  OtherInfo info;   //和边相关的其他信息<br>&#125;ArcNode;</li></ul><p>typedef struct VNode &#123;   //顶点信息<br>    VerTexType data;  //数据域，存放顶点vi的名称或其他有关信息<br>    ArcNode *firstarc;  //指向第一条依附该顶点的边的指针<br>&#125;VNode, AdjList[MVNum]; //AdjList表示邻接表的类型</p><p>typedef struct &#123;<br>    AdjList vertices;<br>    int vexnum, arcnum; //图当前的顶点数和边数<br>&#125;ALGraph; //邻接表（Adjacency List）</p><p>/**</p><ul><li>找到v顶点在图的顶点数组中的位置</li><li>/<br>int LocateVex(ALGraph &amp;G, char v) &#123;<br>  for (int i = 0; i &lt; G.vexnum;i++) &#123;<pre><code>  if (v == G.vertices[i].data) &#123;      return i;  &#125;</code></pre>  }<br>}</li></ul><p>/**</p><ul><li>邻接表创建无向图</li><li>/<br>void CreateUDG(ALGraph &amp;G) {<br>  cout &lt;&lt; &quot;请输入顶点数和边数：&quot; &lt;&lt; endl;<br>  cin &gt;&gt; G.vexnum &gt;&gt; G.arcnum; // 邻接表的顶点数和边数<br>  // 初始化顶点数组<br>  for (int i = 0; i &lt; G.vexnum;i++) {<pre><code>  cin &amp;gt;&amp;gt; G.vertices[i].data; // 初始化顶点数组里面的结点data  G.vertices[i].firstarc = NULL; // 初始化顶点数组里面的结点next域</code></pre>  }<br>  // 初始化所有的边<br>  for (int k = 0; k &lt; G.arcnum;k++) {<pre><code>  char v1, v2;  cout &amp;lt;&amp;lt; &amp;quot;请输入每条边所依附的顶点：&amp;quot; &amp;lt;&amp;lt; endl;  cin &amp;gt;&amp;gt; v1 &amp;gt;&amp;gt; v2;  int i = LocateVex(G, v1); // 找到v1在顶点数组的下标  int j = LocateVex(G, v2); // 找到v2在顶点数组的下标  // 下面建立p1和p2是因为无向图，如果是有向图就没必要了只需要p1  // 前插  ArcNode *p1 = new ArcNode;  p1-&amp;gt;adjvex = j;  p1-&amp;gt;nextarc = G.vertices[i].firstarc;  G.vertices[i].firstarc = p1;  ArcNode *p2 = new ArcNode;  p2-&amp;gt;adjvex = i;  p2-&amp;gt;nextarc = G.vertices[j].firstarc;  G.vertices[j].firstarc = p2;</code></pre>  }<br>}</li></ul><p>/**</p><ul><li>打印输出图</li><li>/<br>void Display(ALGraph &amp;G) {<br>  for (int i = 0; i &lt; G.vexnum;i++) {<pre><code>  cout &amp;lt;&amp;lt; &amp;quot;结点&amp;quot; &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &amp;quot;：&amp;quot;;  // 复制选中的节点数组中的结点  VNode p;  p = G.vertices[i];  if (p.firstarc != NULL)&#123;      ArcNode *temp;      temp = G.vertices[i].firstarc;      while (temp != NULL) &#123;          cout &amp;lt;&amp;lt; temp-&amp;gt;adjvex&amp;lt;&amp;lt;&amp;quot; &amp;quot;;          temp = temp-&amp;gt;nextarc;      &#125;      cout &amp;lt;&amp;lt; &amp;quot;\n&amp;quot;;  &#125;</code></pre>  }<br>}</li></ul><p>//—-邻接表的BFS遍历—-</p><p>bool visited[MVNum];</p><p>int FirstAdjvex(ALGraph&amp; G, int u)<br>{<br>    int w = G.vertices[u].firstarc-&gt;adjvex;<br>    return w;<br>}<br>int NextAdjVex(ALGraph&amp; G, int u, int w)<br>{<br>    ArcNode *temp = G.vertices[u].firstarc;<br>    while (temp-&gt;adjvex != w)<br>    {<br>        temp = temp-&gt;nextarc;<br>    }<br>    if (temp-&gt;nextarc)<br>        return temp-&gt;nextarc-&gt;adjvex;<br>    else<br>        return -1;<br>    delete temp;<br>}<br>void BFS_AL(ALGraph&amp; G, int v){<br>    cout &lt;&lt; v;<br>    visited[v] = true;<br>    queue&lt;int&gt; Q;<br>    Q.push(v);<br>    int u = v;<br>    while (!Q.empty()){<br>        u = Q.front();<br>        Q.pop();<br>        for (int w = FirstAdjvex(G, u); w &gt;= 0; w = NextAdjVex(G, u, w)){<br>            if (!visited[w]){<br>                cout &lt;&lt;w;<br>                visited[w] = true;<br>                Q.push(w);<br>            }<br>        }<br>    }<br>}</p><p>void BFSTraverse(ALGraph &amp;G) {<br>    //访问标志数组初始化<br>    for(int v = 0; v &lt; G.vexnum; v++)<br>        visited[v] = false;<br>    //循环调用BFS<br>    for(int v = 0; v &lt; G.vexnum; v++)<br>        if(!visited[v])<br>            BFS_AL(G, v); //对尚未访问的顶点调用BFS<br>}</p><p>int main() {<br>    ALGraph test;<br>    CreateUDG(test);<br>    Display(test);<br>    BFSTraverse(test);<br>}<br></code></pre></p><p id="c606f86cc011bbd8daff4fdf8fde78ee" class="ne-p"><span class="ne-text"></span></p><div data-type="danger" class="ne-alert"><p id="0ef6670727161ceae2b2fd7611579ede" class="ne-p"><span class="ne-text">【插眼】为啥我写的一个函数不需要队列也可以？？？直接将顶点数组的一个元素后面接的链表遍历不就好了，然后再遍历标志数组元素值部位true的不就好了。。。为啥要压队列呀？</span></p><p id="40e16d77d4f0ef5fa0dd607f4ef45ee1" class="ne-p"><span class="ne-text">莫不是哪里有隐藏的bug，插个眼！！！</span></p></div><p id="e6f8995f72a0e332e6921816bb8d07b0" class="ne-p"><span class="ne-text"></span></p><p id="410e780ff2dc9b2b7265d7357bed6936" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/gif/1484158/1621340205400-d534997e-4b20-4f0e-8db6-4a91e39c68b6.gif" width="218" id="Ivn4n" class="ne-image"></p><p id="87461184d6165e71f83ee3ca2c47cee8" class="ne-p"><span class="ne-text"></span></p><div data-type="success" class="ne-alert"><p id="4555a876fb667c46816df66773c5e6e1" class="ne-p"><span class="ne-text">【拔眼】这样是一种特殊情况，只适合图的各个结点是按照层次标号的，并且放入标志数组也是按照顺序放入的……</span></p></div><p id="1cf117f18c823349567e5d7b36a5ff7b" class="ne-p"><br></p><p id="0f6e52a1f536ea9359c2494c19ca0529" class="ne-p"><span class="ne-text">插眼代码如下：</span></p><pre><code>void BFS_AL(ALGraph &amp;G, int v)&#123;//按广度优先非递归遍历连通图G    cout&lt;&lt;v;    visited[v] = true;    //访问第v个顶点，并置访问标志数组相应分量值为true    ArcNode *p;    p = G.vertices[v].firstarc;    if (p != NULL) &#123;        while(p != NULL) &#123;            if (!visited[p-&gt;adjvex])&#123;                cout &lt;&lt; p-&gt;adjvex;            &#125;            visited[p-&gt;adjvex] = true;            p = p-&gt;nextarc;        &#125;    &#125;&#125;</code></pre><p id="ae0f5d621f99ca5480d74bece56a5520" class="ne-p"><span class="ne-text"></span></p></div>]]></content>
      
      
      <categories>
          
          <category> 计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 📉图结构：无向图-有向图 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>图的术语、存储、应用综述</title>
      <link href="/blog/gqpli5/"/>
      <url>/blog/gqpli5/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="a20d224c568e48b9d67847a2c66a8c01_p_0" class="ne-p"><span class="ne-text">前言：</span><strong><span class="ne-text">数据结构一般就四种关系：集合、线性、树、图</span></strong><span class="ne-text">。这篇文章打算对图这类数据结构做一个概览。先介绍图的一些术语（复制粘贴：））；然后讲解一下图的各种存储形式；最后把图的应用记录一下，具体应用算法放在算法分类里面。</span></p><p id="u15a4556b" class="ne-p"><span class="ne-text"></span></p><h2 id="Xftp7"><span class="ne-text">一、图的一些术语</span></h2><p id="u7b8fcc5d" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1621256644397-9e2a9a9a-c3f9-4bfe-af9d-d3eec44c16b2.png" width="499" id="ue0b15b96" class="ne-image"></p><p id="u054df83b" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1621256670453-caccc927-2510-4119-9452-a588b6f590e5.png" width="476" id="u1e1a40e2" class="ne-image"></p><p id="u5c8e2bbc" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1621256694543-32b41537-3bc7-4515-b8e9-eb56b026d2a7.png" width="470" id="uee62fe0a" class="ne-image"></p><h2 id="YcmB4"><span class="ne-text">二、图存储</span></h2><h3 id="bKChi"><span class="ne-text">邻接矩阵</span></h3><div data-type="info" class="ne-alert"><p id="04fc687e04e1d5533771232c89922a29" class="ne-p"><span class="ne-text">创建无向网</span></p></div><p id="u7562b828" class="ne-p"><br></p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;<p>#define MVNum 100<br>#define MaxInt 32767</p><p>typedef char VerTexType;<br>typedef int ArcType;</p><p>/**</p><ul><li>邻接矩阵存储形式</li><li>/<br>typedef struct &#123;<br>  /* data */<br>  VerTexType vexs[MVNum]; //顶点表<br>  ArcType arcs[MVNum][MVNum]; //邻接矩阵<br>  int vexnum, arcnum; //图的当前顶点和边数<br>&#125;AMGraph;</li></ul><p>/**</p><ul><li>确定v在G中的位置，即顶点数组的下标</li><li>/<br>int LocateVex(AMGraph &amp;G, char v) &#123;<br>  for (int i = 0; i &lt; G.vexnum;i++) &#123;<pre><code>  if (v == G.vexs[i])&#123;      return i;  &#125;</code></pre>  }<br>}</li></ul><p>/**</p><ul><li>创建无向网</li><li>如果创建无向图   </li><li>/<br>void CreateUDN(AMGraph &amp;G) {<br>  // 采用邻接矩阵表示法，创建无向图G<br>  cout &lt;&lt; &quot;请输入顶点数和边数：&quot; &lt;&lt; endl;<br>  cin &gt;&gt; G.vexnum &gt;&gt; G.arcnum; //输入顶点数和边数<br>  // 初始化顶点<br>  for (int i = 0; i &lt; G.vexnum;i++){<pre><code>  cout &amp;lt;&amp;lt; &amp;quot;请输入第&amp;quot; &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &amp;quot;个顶点值&amp;quot; &amp;lt;&amp;lt; endl;  cin &amp;gt;&amp;gt; G.vexs[i];</code></pre>  }<br>  // 初始化邻接矩阵的边的权值为最大值<br>  for (int i = 0; i &lt; G.vexnum;i++) {<pre><code>  for (int j = 0; j &amp;lt; G.vexnum;j++) &#123;      G.arcs[i][j] = MaxInt;  &#125;</code></pre>  }<br>  // 构造邻接矩阵<br>  for (int k = 0; k &lt; G.arcnum;k++) {<pre><code>  cout &amp;lt;&amp;lt; &amp;quot;请输入每条边所依附的顶点和权值：&amp;quot; &amp;lt;&amp;lt; endl;  char v1, v2;  int w; //一条边所依附的顶点和权值  cin &amp;gt;&amp;gt; v1 &amp;gt;&amp;gt; v2 &amp;gt;&amp;gt; w;  int i = LocateVex(G, v1);  int j = LocateVex(G, v2);  G.arcs[i][j] = w;  G.arcs[j][i] = w;</code></pre>  }<br>}</li></ul><p>void Display(AMGraph &amp;G) {<br>    for (int i = 0; i &lt; G.vexnum;i++) {<br>        for (int j = 0; j &lt; G.vexnum;j++) {<br>            cout &lt;&lt; G.arcs[i][j] &lt;&lt; &quot; &quot;;<br>        }<br>        cout &lt;&lt; endl;<br>    }<br>}</p><p>int main() {<br>    AMGraph test;<br>    // CreateUDN(test);<br>    Display(test);<br>}<br></code></pre></p><p id="u449d1a79" class="ne-p"><br></p><div data-type="tips" class="ne-alert"><p id="ubfd95f3b" class="ne-p"><span class="ne-text">创建无向图</span></p></div><p id="ue2d1f836" class="ne-p"><span class="ne-text">对</span><code class="ne-code"><span class="ne-text">CreateUDN</span></code><span class="ne-text"> 进行处理：</span></p><ul class="ne-ul"><li id="u86393495"><span class="ne-text">G.arcs[i][j] = MaxInt;改为G.arcs[i][j] = 0;</span></li><li id="uf0d4b0c7"><span class="ne-text">将w改为常量1即可  </span></li></ul><p id="ubf2f1771" class="ne-p"><br></p><div data-type="tips" class="ne-alert"><p id="ud4631bb3" class="ne-p"><span class="ne-text">创建有向网</span></p></div><p id="u6d3051a6" class="ne-p"><span class="ne-text">对</span><code class="ne-code"><span class="ne-text">CreateUDN</span></code><span class="ne-text"> 进行处理：</span></p><ul class="ne-ul"><li id="ua516c49e"><span class="ne-text">删除G.arcs[j][i] = w;</span></li></ul><p id="u46ec0f2b" class="ne-p"><br></p><div data-type="tips" class="ne-alert"><p id="ub07dff75" class="ne-p"><span class="ne-text">创建有向图</span></p></div><p id="ua2fdba0d" class="ne-p"><span class="ne-text">对</span><code class="ne-code"><span class="ne-text">CreateUDN</span></code><span class="ne-text"> 进行处理：</span></p><ul class="ne-ul"><li id="u13aeacb4"><span class="ne-text">删除G.arcs[j][i] = w;</span></li></ul><h3 id="Au8am"><span class="ne-text">邻接表</span></h3><pre><code>#include &lt;bits/stdc++.h&gt;using namespace std;<p>#define MVNum 100<br>#define MaxInt 32767</p><p>typedef char VerTexType;<br>typedef int OtherInfo;</p><p>/**</p><ul><li>邻接表存储</li><li>/</li></ul><p>/**</p><ul><li>存储结构</li><li>/<br>typedef struct ArcNode &#123;                      //边结点<br>  int adjvex;                             //该边所指向的结点的位置<br>  struct ArcNode *nextarc;                //指向下一条边的指针<br>  OtherInfo info;                         //和边相关的其他信息<br>&#125;ArcNode;</li></ul><p>typedef struct VNode &#123;                        //顶点信息<br>    VerTexType data;                        //数据域，存放顶点vi的名称或其他有关信息<br>    ArcNode *firstarc;                      //指向第一条依附该顶点的边的指针<br>&#125;VNode, AdjList[MVNum];                     //AdjList表示邻接表的类型</p><p>typedef struct &#123;<br>    AdjList vertices;<br>    int vexnum, arcnum;                     //图当前的顶点数和边数<br>&#125;ALGragh;                                   //邻接表（Adjacency List）</p><p>/**</p><ul><li>找到v顶点在图中的位置</li><li>/<br>int LocateVex(ALGragh &amp;G, char v) &#123;<br>  for (int i = 0; i &lt; G.vexnum;i++) &#123;<pre><code>  if (v == G.vertices[i].data) &#123;      return i;  &#125;</code></pre>  }<br>}</li></ul><p>/**</p><ul><li>邻接表创建无向图</li><li>/<br>void CreateUDG(ALGragh &amp;G) {<br>  cin &gt;&gt; G.vexnum &gt;&gt; G.arcnum; // 邻接表的顶点数和边数<br>  for (int i = 0; i &lt; G.vexnum;i++) {<pre><code>  cin &amp;gt;&amp;gt; G.vertices[i].data;  G.vertices[i].firstarc = NULL;</code></pre>  }  for (int k = 0; k &lt; G.arcnum;k++) {<pre><code>  char v1, v2;  cin &amp;gt;&amp;gt; v1 &amp;gt;&amp;gt; v2;  int i = LocateVex(G, v1);  int j = LocateVex(G, v2);  ArcNode *p1 = new ArcNode;  p1-&amp;gt;adjvex = j;  p1-&amp;gt;nextarc = G.vertices[i].firstarc;  G.vertices[i].firstarc = p1;  ArcNode *p2 = new ArcNode;  p2-&amp;gt;adjvex = i;  p2-&amp;gt;nextarc = G.vertices[j].firstarc;  G.vertices[j].firstarc = p1;</code></pre>  }<br>}<br></code></pre><h3 id="leRQZ"><span class="ne-text">有向图：十字链表存储</span></h3><pre><code>#include &lt;bits/stdc++.h&gt;using namespace std;typedef int Status;#define OK 1;</li></ul><p>//—-有向图的十字链表储存表示—-<br>#define MAX_VERTEX_NUM 20<br>typedef char VerTexType;<br>typedef int InfoType;<br>typedef struct ArcBox<br>&#123;<br>    int tailvex, headvex;                   //该弧的头尾和头顶点的位置<br>    struct ArcBox *hlink, *tlink;            //分别为弧头相同和弧尾相同的链域<br>    InfoType *info;                         //该弧相关信息的指针<br>&#125;ArcBox;</p><p>typedef struct VexNode<br>&#123;<br>    VerTexType data;<br>    ArcBox *firstin, *firstout;             //分别指向该顶点的第一项入弧和出弧<br>&#125;VexNode;</p><p>typedef struct<br>&#123;<br>    VexNode xlist[MAX_VERTEX_NUM];          //表头向量<br>    int vexnum, arcnum;                     //有向图的当前顶点数和弧数<br>&#125;OLGraph;                                   //十字链表（Orthogonal List）</p><p></code></pre></p><h3 id="vsryl"><span class="ne-text">无向图：邻接多重表存储</span></h3><pre><code>#include &lt;bits/stdc++.h&gt;using namespace std;typedef int Status;#define OK 1;<p>//—-无向图的邻接多重表储存表示—-<br>#define MAX_VERTEX_NUM 20<br>typedef char VerTexType;<br>typedef int InfoType;</p><p>typedef enum<br>&#123;<br>    unvisited, visited                     //枚举unvisited是0，visited是1，注意没有分号<br>&#125;VisitIf;</p><p>typedef struct EBox<br>&#123;<br>    VisitIf mark;                           //访问标记<br>    int ivex, jvex;                         //该边依附的两个顶点的位置<br>    struct EBox *ilink, *jlink;             //分别指向依附这两个顶点的下一条边<br>    InfoType *info;                         //该边的信息指针<br>&#125;EBox;</p><p>typedef struct VexBox<br>&#123;<br>    VerTexType data;<br>    EBox *firstedge;                        //指向第一条依附该顶点的边<br>&#125;VexBox;</p><p>typedef struct<br>&#123;<br>    VexBox adjmulist[MAX_VERTEX_NUM];<br>    int vexnum, arcnum;                     //无向图当前的顶点数和边数<br>&#125;AMLGraph;                                  //邻接多重表(Adjacency Multilist)<br></code></pre></p><h3 id="yIN8s"><span class="ne-text">其他：边集数组</span></h3><p id="f7caa591865821073c01be60256a98d5" class="ne-p"><br></p><h3 id="EYiXl"><span class="ne-text">其他：链式前向星</span></h3><p id="37b365ee016545bff4ec27eb3f6afd50" class="ne-p"><br></p><h2 id="GJZzj"><span class="ne-text">三、图的应用</span></h2><ul class="ne-ul"><li id="1853f2f02796d7f84065b7f0802239d1"><span class="ne-text">最小生成树</span></li><li id="3d0e7c3bba57f2e22cb08454d8351cf9"><span class="ne-text">最短路径</span></li><li id="974b0e776d1250a371152cff90420be4"><span class="ne-text">环路</span></li><li id="ebe95ecfd4e0f08b0581a7cfdf5fd876"><span class="ne-text">关键路径</span></li></ul><p id="9d3c089ab3cd581998d3b22fa4c644db" class="ne-p"><br></p><p id="827d80a13d6f97ce4d10e4dcf0ed2b9a" class="ne-p"><span class="ne-text">具体这几类问题都是算法中的贪心算法所属，故将其放到算法分类里面了。</span></p><p id="88bb9f458aac1f0aa89a861c39b131f6" class="ne-p"><br></p><p id="26dd6339706b64d9f617cf5e571ec4bf" class="ne-p"><br></p><p id="4dccc396ba4ee721ad76b490e08c8486" class="ne-p"><br></p><p id="2722e61c51c854135f8ad27e4594a933" class="ne-p"><br></p><p id="a4f7ffd8a89771e03642e1dd3e60709e" class="ne-p"><br></p></div>]]></content>
      
      
      <categories>
          
          <category> 计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 📉图结构：无向图-有向图 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>『灵笼』——灵魂的牢笼</title>
      <link href="/essay/pnapfw/"/>
      <url>/essay/pnapfw/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="87ae0048a72f1bee29ddbcc5e0202b3b" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1621244428291-8f947575-4da5-4938-a3fa-09f21bed0925.png" width="1920" id="ijJPU" class="ne-image"></p><p id="af9e6b14f89909a2ad76a80c8b99faee" class="ne-p"><br></p><p id="a20d224c568e48b9d67847a2c66a8c01_p_0" class="ne-p"><span class="ne-text">看了五集，觉得剧情设定方面有浓浓的进击的巨人和Darling in the franxx这两部番那味了（去论坛看了看，果然有吐槽的…不过都在说巨人，我更加觉得和国家队的世界观很像）…但不管怎么说，</span><strong><span class="ne-text">剧情设定和画质方面在国漫里面也是可圈可点，并且，我个人认为，这部番是这么多年国漫里面最用心最花成本的一部</span></strong><span class="ne-text">～</span></p><p id="936a42ff936d7c1a50bf89c9b89d16da" class="ne-p"><br></p><p id="374184666c63eb0a7c54d62122377acf" class="ne-p"><span class="ne-text">灵笼，灵魂的牢笼，就像是巨壁</span></p><p id="u452a7683" class="ne-p"><span class="ne-text">重立体，立体机动装置（就不能叫个重装甲啥的，害</span><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1621243721740-de5b6182-0bb1-4971-95bf-1309c0fdfb1d.jpeg" width="79" id="rboSG" class="ne-image"></p><p id="udcc19708" class="ne-p"><span class="ne-text">猎荒者，调查兵团</span></p><p id="ub245810e" class="ne-p"><span class="ne-text">荷光者，宪兵团</span></p><p id="c7a73cad76fd1527d918edc112252883" class="ne-p"><span class="ne-text">……</span></p><p id="e78c7f6ff1c79e75b6edd496476b3456" class="ne-p"><br></p><p id="5f41b43f70ab381b3abcf9ff01ffd036" class="ne-p"><span class="ne-text">我之前对darling里面的是『心』这个人物，我当时的感受是整部番的点睛之笔，在世界观的角度上，拉伸高度，在灵笼这里被设定为佩妮这个角色……</span></p><p id="728fce5b4089cc37c61f73c1aac677ed" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1621244183522-a0ab8144-4141-4887-895b-a5b3e6230613.png" width="1920" id="VgAwl" class="ne-image"></p><p id="5fb20c568753e1230fc1d6e5797cc35e" class="ne-p"><br></p><p id="b2b0e7e0c4539f2d0197a340b959221c" class="ne-p"><span class="ne-text">这些说实话，感受的挺多了，用这部番里面的一个词就是——躯壳。希望后面的剧情能挖掘出作品的闪光之处～</span></p><p id="2eca8e0a0ec8ea3176a08ef390d6d713" class="ne-p"><br></p><hr id="cUmMX" class="ne-hr"><p id="400943748f0c11a5e083e3ec212e589e" class="ne-p"><span class="ne-text">EP6</span></p><p id="48776f2534cdb298e8192f61cd81f10c" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/jpg/1484158/1621262671765-0831d8b9-f8eb-4a16-acc0-1b8d622ff5b8.jpg" width="1975" id="OlIMX" class="ne-image"></p><p id="8df7dc13a99fcdda8256b823298f09ee" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/jpg/1484158/1621262686893-e61922ea-e1b5-4fa8-82ac-cabc2ef60391.jpg" width="1349" id="fQ07I" class="ne-image"></p><p id="189f2a7b38aac1e37c3c1a33380ca524" class="ne-p"><span class="ne-text">不管这个世界再怎么变，人性永远在那，就像爱情……</span></p><p id="befbd46b4767a3843e589d6e1805da04" class="ne-p"><br></p><p id="27fc0931913efab3517f903ee0a636c0" class="ne-p"><span class="ne-text">或许我在想，即便这个世界颠倒了，文明是一个全新的面貌，人性或许是那诸多不变的点之一。</span></p><p id="e0ddfdfcbc11e27cbaddd761616191e4" class="ne-p"><br></p><hr id="9yNge" class="ne-hr"><p id="43cfb880aec7af6b4d5b99387187dae2" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/jpg/1484158/1621472984542-d6010263-d430-4ab7-ac8d-4f911c4d4bf3.jpg" width="2083" id="mKa4W" class="ne-image"></p><p id="55d077335426a9183d75f8137608dde2" class="ne-p"><span class="ne-text">万万没想到系列，冉冰居然凉凉～</span></p><hr id="JHHXc" class="ne-hr"><p id="78b38bbb609e7489da4763bbac776424" class="ne-p"><span class="ne-text">终章+特别篇</span></p><p id="f9676a9ce027e8eb4f0f6f8ac9f534a5" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/jpg/1484158/1621473001235-cb79d2e3-6a7e-4556-92b4-33ea9d442010.jpg" width="1996" id="gBT7O" class="ne-image"></p><p id="b4c13366a067784ca2275dc78f63bc2a" class="ne-p"><br></p><p id="9eb8b13ef41bc89ffb62a78d2d5fca91" class="ne-p" style="text-indent: 2em"><span class="ne-text">这波用灯塔来反衬地面幸存者的存在的意义，都知道噬极兽会以人类的情感来孕育，灯塔是颁布三大法令来限制灯塔上的人的情感，以此来让灯塔幸存于这乱世，地面幸存者则是相反，情感不但不能舍弃，反而要坚守</span></p><p id="7822c0b6e9292530c1203301f4b9559a" class="ne-p"><br></p><p id="c8f38feb7a41905e44c624908c3b6642" class="ne-p" style="text-indent: 2em"><span class="ne-text">至于白月魁，直接将这部番提升到修仙境界了</span><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1622037065067-007f3642-a1e3-4f60-862b-af2e1013c8ec.jpeg" width="77" id="MR71l" class="ne-image"><span class="ne-text">，就是人类中靠修炼而成的外挂，和阿克曼一族利威尔兵长是一类人，人类最强。</span></p><p id="b5766f96b10e63a8f42dde3c5f7e6e90" class="ne-p"><br></p><p id="312a046a99097258c6a8ea393340ac79" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/jpg/1484158/1621473476256-6440f355-2230-47d7-9a2d-cc3a92afa850.jpg" width="2400" id="TxJXz" class="ne-image"></p><p id="9c1614cb08b3160c581649ba8b86aa00" class="ne-p"><br></p><p id="b54a74b17960bed47ccfa51e84751b7b" class="ne-p"><br></p><p id="2756fb0549ca456400a599e1f6287693" class="ne-p"><br></p><p id="f637daffca44c515b3cd4e2e1d12b591" class="ne-p"><br></p><p id="52495223c959fec8eafe0d63e412feb8" class="ne-p"><br></p><p id="6f4edc684874a8e74dc2fb283776fedd" class="ne-p"><br></p><p id="4d9958565eaea1c075296feb05ee05f9" class="ne-p"><br></p><p id="cd0243f05e57869e3766d3b2a6a0b44a" class="ne-p"><br></p><p id="b19d4dde4f88ee6fb0fc5ed772107461" class="ne-p"><br></p><p id="d6f84594942f8d96354473ed3b7f5450" class="ne-p"><br></p><p id="5447c9d736c76beff2cf33f6ae3f3956" class="ne-p"><br></p><p id="7e8b0f2d040e7447cc79790df266eccf" class="ne-p"><br></p><p id="cfd4f14294417abe856a51737d9fd334" class="ne-p"><br></p></div>]]></content>
      
      
      <categories>
          
          <category> 影视 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[转]竞赛常用STL容器详解</title>
      <link href="/blog/porzdi/"/>
      <url>/blog/porzdi/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><div class="ne-quote"><p id="b174f416224bd7d428d5952653d786f8" class="ne-p"><span class="ne-text">大部分文字内容转载自：</span><a href="https://blog.csdn.net/weixin_43844677/article/details/104902417" data-href="https://blog.csdn.net/weixin_43844677/article/details/104902417" target="_blank" class="ne-link"><span class="ne-text">竞赛常用STL容器详解</span></a></p><p id="u869b6a94" class="ne-p"><span class="ne-text">部分内容个人修改补充。</span></p></div><p id="e5c401f15f8c481887594e6e60a99c11" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1626175209711-5b013be3-5942-4a0a-b9ce-529a73668d94.jpeg" width="360" id="rFa1j" class="ne-image"></p><h2 id="FsIvq"><span class="ne-text">一、 概述</span></h2><p id="9325e5cb1f074bb346e4d4351260b24c" class="ne-p"><span class="ne-text">在算法竞赛中，使用C++语言的占很大比例，而几乎没有人使用C语言，其中核心的原因就是C++包含STL容器库，能够极大地减少选手在赛场上为了一些基础数据结构而浪费的时间。诚然，花一两分钟实现一个stack、queue甚至priority_queue都不是什么大问题，但如果需要实现BBST（Balanced Binary Search Tree）的情况呢？如果可以的话，我们总是希望不要手写红黑树、动态数组的。那么STL容器库的出现就像雪中送炭一样了。它们覆盖了竞赛中最基础的需要（张昆玮树、主席树这种东西肯定不会包含的），让你在面对非数据结构题的时候能够不因数据结构部分的代码而分心。</span></p><p id="46bd6ff3ccf301afd671dccb15832982" class="ne-p"><span class="ne-text"></span></p><p id="97da7fcd9472789cd12c279999442d4a" class="ne-p"><span class="ne-text">关于STL容器的相关问题非常细，经常成为面试中的考题，这里我们仅讨论一些必须的内容，然后只谈论在竞赛中的具体使用。</span></p><p id="551c7c831a7c03907effea19f85d8815" class="ne-p"><span class="ne-text"></span></p><p id="748f546e2cfa7dea162504441128383a" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1621221298404-a6bf5daf-fd5b-4504-a4d0-f80b17dc5899.png" width="1778" id="Rv9rY" class="ne-image"></p><p id="bc9da56b08501be44ab80c74871f3bcd" class="ne-p"><span class="ne-text">首先给出一张表格（来自cppreference）：</span></p><p id="b909ffb1c2645000a3fadf53bc7da1d2" class="ne-p"><span class="ne-text"></span></p><p id="89ffba3ee54d7d59bf99a47309fdc95d" class="ne-p"><span class="ne-text">这张表格中给出了各种容器支持的成员函数，在大多数停留在C++14和C++11版本的测试平台中，只有紫色、绿色部分是可用的。</span></p><p id="44ccc4a9adf75f8e0042b43b33fd83de" class="ne-p"><span class="ne-text"></span></p><p id="f29d38316edbbf61104ff268d8cf1503" class="ne-p"><span class="ne-text">在考察具体的容器的时候，出于竞赛中的需要，我们不会涵盖以上的全部，而是着重关注以下几点：</span></p><ol class="ne-ol"><li id="e3a45c83635d297ccda38ddb9d6dd721"><strong><span class="ne-text">随机访问</span></strong></li><li id="69bfa84b70d960e6323b085550f2cea4"><strong><span class="ne-text">插入和删除</span></strong></li><li id="59ba20d870115f04dc50335bc7c94948"><strong><span class="ne-text">端点访问</span></strong></li><li id="336e884d20f34f99decfeadc5641e490"><strong><span class="ne-text">迭代器类型（总结以上几点）</span></strong></li><li id="c498b0f5613aba11c9e457ae6c842ffd"><strong><span class="ne-text">时间复杂度</span></strong></li></ol><p id="99b0d09fab938a21cb2754647d420082" class="ne-p"><strong><span class="ne-text"></span></strong></p><p id="a3e5165a16b1bae8fdf91219d525dd61" class="ne-p"><span class="ne-text">事实上，综合以上几点，就可以得出一个容器的作用。容器的作用是由它支持的操作及其时间复杂度决定的，并不是说，容器的名字叫做set我就一定把它当作集合来用。从ADT的角度来说，</span><strong><span class="ne-text">数据结构=接口+接口的复杂度</span></strong><span class="ne-text">。而从另一个角度来看，容器内部支持的逻辑操作决定了它能够使用的迭代器类型，而这决定了外部可能存在哪些接口，因此也可以说</span><strong><span class="ne-text">数据结构=内部存储+迭代器</span></strong><span class="ne-text">。这样两种观点，能够在使用的层面加强我们对于STL容器的理解。</span></p><p id="2991cf1395bfdc1d38f67bdc19b84e7d" class="ne-p"><span class="ne-text"></span></p><p id="cf86b02f332a87d38750352809652a2f" class="ne-p"><span class="ne-text">方便起见，这里先列出一个汇总的表格，包含了竞赛中常用的几种数据结构：</span></p><p id="fc2f072711b55b1880c821933e0952cb" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1621221298080-23300f65-22c0-48b6-895a-324e3793fed5.png" width="857" id="PnAJG" class="ne-image"></p><p id="ef4077071ca1b74312af73b195c64fe0" class="ne-p"><span class="ne-text"></span></p><p id="17aab6c9586e8902c6fd2078e0858e61" class="ne-p"><span class="ne-text">这里的表格只给出了很简单的内容，本文末尾会给出两个总结性的表格，给出具体操作的函数名和时间复杂度。</span></p><p id="e40afaabd6286f809dee5c382de4cf66" class="ne-p"><span class="ne-text"></span></p><h2 id="Xuzkh"><span class="ne-text">二、 迭代器</span></h2><h3 id="xshvx"><span class="ne-text">迭代器与遍历</span></h3><p id="074397d1269d9d82ce8b72aee49ddc7b" class="ne-p"><span class="ne-text">操作一个容器，无法脱离它提供的工具——</span><strong><span class="ne-text">迭代器</span></strong><span class="ne-text">。即使没有使用过容器，我们也一定使用过最基本的方式遍历一个数组：</span></p><pre><code>for (int i = 0; i &lt;n;i++)    //......</code></pre><p id="bef551f9c032825e8f863bf429c15fd2" class="ne-p"><span class="ne-text"></span></p><p id="351c9dc6e6e7f8e8f6940e80a257906a" class="ne-p"><span class="ne-text">不严格地说，这里的”i”就可以视作一个最原始的迭代器。事实上，对于藉由它，我们可以访问一个容器内的全部内容——这就是我们所说的“遍历”，这能够让我们对内部数据进行基于元素的操作。</span></p><p id="e3d177960f3a9710f3f6e20420be6ddc" class="ne-p"><span class="ne-text"></span></p><p id="88a1bf253f2267bb88accb386ed229d7" class="ne-p"><span class="ne-text">事实上，一个真正的迭代器需要符合很多要求。STL容器所配备的迭代器都属于C++迭代器库规定的六种之一，它们是：</span></p><ol class="ne-ol"><li id="a0a508f956a7f7422c0ead00ef730792"><strong><span class="ne-text">遗留输入迭代器</span></strong></li><li id="9f854f20bfdb6d2e1286977be28fe7a4"><strong><span class="ne-text">遗留向前迭代器</span></strong></li><li id="0a72a21e2d5642f1eff31bb9d583ba50"><strong><span class="ne-text">遗留双向迭代器</span></strong></li><li id="3c95bdede059dce4c441b09a86225a2a"><strong><span class="ne-text">遗留随机访问迭代器</span></strong></li><li id="ed66347e7daafc2a005be826efaa4cfe"><strong><span class="ne-text">遗留输出迭代器</span></strong></li><li id="c5d7514d16d7b3c2dc4b549670e87ddb"><strong><span class="ne-text">遗留连续迭代器</span></strong></li></ol><p id="e20cdf4f8c8c6e24ed84a0a4f496f6c2" class="ne-p"><span class="ne-text">这些名字看起来很唬人，让我们来一点一点解释。</span></p><p id="10f96e2fae647322cc53935b4ded4772" class="ne-p"><span class="ne-text">首先，它们都是“</span><strong><span class="ne-text">遗留迭代器</span></strong><span class="ne-text">”，这意味着它们都：（以下假设i是迭代器）</span></p><ul class="ne-ul"><li id="b3a4a9484fce4dba2ca346bf763aabb9"><span class="ne-text">可</span><strong><span class="ne-text">解引用</span></strong><span class="ne-text">（*i得到元素）</span></li><li id="77ffa0ff535587adbc30033b9e4bfc29"><span class="ne-text">可</span><strong><span class="ne-text">前自增</span></strong><span class="ne-text">（++i得到下一位置）</span></li></ul><p id="6287f35ce511723066defafead41e55d" class="ne-p"><span class="ne-text">这也就是为何我们能藉由迭代器来完成遍历容器内元素的操作。</span></p><p id="bd99dd12ea8e1576f52b59606c2761d1" class="ne-p"><span class="ne-text">下面给出上文提到的六种迭代器的实际含义，虽然大多数情况下竞赛中用不到这些原理，但偶尔会有基于手动遍历的技巧性操作，这时候也许需要你对迭代器有一定的认知：</span></p><p id="97f18ee5233fecadc9d2c10b132ade08" class="ne-p"><strong><span class="ne-text">遗留输入迭代器：</span></strong></p><p id="3ecf3a7b5df6db5f69c312daffa5ce32" class="ne-p"><span class="ne-text">在</span><strong><span class="ne-text">遗留迭代器</span></strong><span class="ne-text">的基础上，</span></p><ul class="ne-ul"><li id="04a52d75fbd1399b41b2a89b1046b15e"><span class="ne-text">可</span><strong><span class="ne-text">不等比较</span></strong><span class="ne-text">（i!=j有定义）</span></li><li id="003b47a543740051e9a5b4afe8408af3"><span class="ne-text">可</span><strong><span class="ne-text">后自增</span></strong><span class="ne-text">（i++有定义）</span></li></ul><p id="ef8ef9ebbdec97b920d878dc57c1fcdc" class="ne-p"><span class="ne-text">但：**自增后，先前值可能失效。**也就是说，当你访问第1个元素时，可能无法通过这个迭代器的拷贝访问第0个元素。</span></p><p id="2c669df7fb5c7ea71f8d787d0626292c" class="ne-p"><strong><span class="ne-text">遗留向前迭代器：</span></strong></p><p id="549b249d7366005f6663910166b92d71" class="ne-p"><span class="ne-text">在</span><strong><span class="ne-text">遗留输入迭代器</span></strong><span class="ne-text">的基础上，</span></p><ul class="ne-ul"><li id="2148cf7e33ed970a529e0971a7fa763a"><strong><span class="ne-text">自增后保证先前值不失效。</span></strong></li></ul><p id="a7efa65b859d944ac6cfb118f9a01a0c" class="ne-p"><strong><span class="ne-text">遗留双向迭代器：</span></strong></p><p id="27fa68639706c4eef6b49d6cf96de5ef" class="ne-p"><span class="ne-text">在</span><strong><span class="ne-text">遗留向前迭代器</span></strong><span class="ne-text">的基础上，</span></p><ul class="ne-ul"><li id="3062dfba061363d314e7404df219a293"><span class="ne-text">可</span><strong><span class="ne-text">前自减</span></strong><span class="ne-text">（–i有定义）</span></li><li id="4407856a0ce5d1429e52ef999251e8e2"><span class="ne-text">可</span><strong><span class="ne-text">后自减</span></strong><span class="ne-text">（i–有定义）</span></li></ul><p id="f981fa9738a21332add68b7616f568af" class="ne-p"><strong><span class="ne-text">遗留随机访问迭代器：</span></strong></p><p id="6d11fae78ee405d0e50b53a45c33579e" class="ne-p"><span class="ne-text">在</span><strong><span class="ne-text">遗留双向迭代器</span></strong><span class="ne-text">的基础上，</span></p><ul class="ne-ul"><li id="60fd749ae9531b0f615604e6af9edf5b"><span class="ne-text">有</span><strong><span class="ne-text">下标</span></strong><span class="ne-text">运算符（i[n]有定义）</span></li><li id="7189f291e63823ee6538353ceaa4d920"><span class="ne-text">有</span><strong><span class="ne-text">比较</span></strong><span class="ne-text">运算符（&gt;、&lt;、&gt;=、&lt;=有定义）</span></li><li id="a86c22e9b5a39cbca0f00050bd5d264a"><span class="ne-text">可按</span><strong><span class="ne-text">增量移动</span></strong><span class="ne-text">（+、-、+=、-=有定义）</span></li></ul><p id="00031be3672384a249e470a5a5805156" class="ne-p"><span class="ne-text">且：</span><strong><span class="ne-text">迭代器移动只耗费常数时间。</span></strong></p><p id="b1c9abdd70ae2a110b1dab135c960e37" class="ne-p"><em><span class="ne-text">若以上迭代器满足</span></em><strong><em><span class="ne-text">遗留输出迭代器</span></em></strong><em><span class="ne-text">的标准，那么称它们是“可变迭代器”。</span></em></p><p id="ad9fae9b279b18048b52b3558422d6ae" class="ne-p"><strong><span class="ne-text">遗留输出迭代器：</span></strong></p><p id="220355b273fa9687e963738aab9533ca" class="ne-p"><span class="ne-text">在</span><strong><span class="ne-text">遗留迭代器</span></strong><span class="ne-text">的基础上：</span></p><ul class="ne-ul"><li id="e95b5efedf1430da2c01bcbcc61a83ca"><span class="ne-text">可</span><strong><span class="ne-text">赋值</span></strong><span class="ne-text">（*i=something有定义）</span></li><li id="82be7c34f1fafff53248888851e35de9"><span class="ne-text">可</span><strong><span class="ne-text">后自增</span></strong></li></ul><p id="7b6ba705789cd5611d237dab96a66335" class="ne-p"><em><span class="ne-text">若以上迭代器满足</span></em><strong><em><span class="ne-text">遗留连续迭代器</span></em></strong><em><span class="ne-text">的标准，那么称它们是“连续迭代器”。</span></em></p><p id="f6407a21d18d62bfede55dbdce19796b" class="ne-p"><strong><span class="ne-text">遗留连续迭代器：</span></strong></p><p id="966927bf45388048f32c753c5dc97e02" class="ne-p"><span class="ne-text">在</span><strong><span class="ne-text">遗留迭代器</span></strong><span class="ne-text">的基础上：</span></p><ul class="ne-ul"><li id="295aa1c5a2c7abf01d1c8a89fd4a2a34"><span class="ne-text">逻辑相邻元素在内存中也相邻，</span></li><li id="5505a0d35f145ed1be5b9704e1c4021d"><span class="ne-text">即：</span><code class="ne-code"><span class="ne-text">*(i + n)</span></code><span class="ne-text"> 等价于 </span><code class="ne-code"><span class="ne-text">*(std::addressof(*i) + n)</span></code></li></ul><p id="582a156458fbccb1ec63aa622e34b058" class="ne-p"><span class="ne-text">以上涉及的运算，不仅需要定义，并且需要符合功能要求。同时，部分操作有特例存在。例如，即使迭代器可解引用，也无法对尾后迭代器或孤立迭代器解引用。</span></p><p id="e99c167444924f0b4082b4bb007fd382" class="ne-p"><span class="ne-text">那么，如果知道某个容器的迭代器类型，对比一下它们支持的操作，你就能知道自己的一些奇思妙想能否实现了。例如：两头向中间访问、一次跳过多个元素、多个迭代器同时访问……</span></p><p id="7aeb1f2b98528f9ea4648524c956fa92" class="ne-p"><span class="ne-text">那么，在复杂的环境下，例如访问的同时涉及插入和删除，这些操作还能按照我的意图运行吗？这就是我们要讨论的下一个问题了。如果说以上内容更偏向于实务开发，那么这个问题在竞赛中就更加常见了，它就是“迭代器失效”问题。</span></p><h3 id="UeT7t"><span class="ne-text">迭代器失效</span></h3><p id="47f4069d0f6796748f6ff291a6db7aa7" class="ne-p"><span class="ne-text">容器的一些操作会使得先前声明的迭代器失去它应有的作用，这种限制来自于容器底层的实现。例如在vector中，即使在尾部插入一个新元素也可能因为导致空间达到临界值而使得数据全部被移动到新空间，从而使全部迭代器失效。</span></p><p id="495c9d23522fa234f80177a2bacdeeac" class="ne-p"><span class="ne-text"></span></p><p id="90bb6dd65a4b4938a8261adeb97d1a18" class="ne-p"><span class="ne-text">大体来说，删除总会使得迭代器失效，而插入有些情况会使其失效。具体的情形见下表：（同样来自cppreference）</span></p><p id="e337efacc6b6c67eddb05a168c1b18d4" class="ne-p"><span class="ne-text"></span></p><p id="e489e1368915645afa8777bf8467f447" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1621221298154-92c7bf87-74b3-4fd5-9f62-d7ab6e5aa25b.png" width="982" id="N6O99" class="ne-image"></p><p id="d205f6a916045701debe1e97841744d1" class="ne-p"><span class="ne-text"></span></p><p id="6cd9b94d46196c0f14adc7af20025543" class="ne-p"><span class="ne-text">除此之外，尾后迭代器有一些特殊情形需要考虑，例如vector的尾后迭代器总是会被非法化、除了删除首元素外的修改操作都会非法化deque的尾后迭代器，等等。</span></p><h3 id="xSEPM"><span class="ne-text">尾后迭代器</span></h3><p id="f647c83d4c6e493b67419f5f8160b665" class="ne-p"><span class="ne-text">另一个要注意的点是，一般来说一个容器的begin()返回的是指向容器内首个元素的迭代器，而end()指向的却不是尾部元素，而是</span><strong><span class="ne-text">尾后</span></strong><span class="ne-text">——一个不存在的元素，我们也常常把这种位置称为“哨兵”。这一点好像恰好和其他参数为一个区间的函数，如sort(), substr()等，对应了起来——似乎编程中所有涉及区间的操作，都是使用左开右闭区间来表示的——也就是说，end()表示尾后。这是为什么呢？</span></p><p id="3e39e9ba14e44104b73621d2592b67c5" class="ne-p"><span class="ne-text">考虑对一个具有</span><strong><span class="ne-text">普通遗留迭代器</span></strong><span class="ne-text">的容器进行迭代，应当怎么写呢？似乎很简单：</span></p><pre><code>for (auto i = x.begin(); i != x.end(); i++)</code></pre><p id="f50449d8125daae28412eb40bda2df91" class="ne-p"><span class="ne-text">看到这里，你应当已经明白了：大多数容器不具有遗留连续迭代器的性质，那就不存在像</span><code class="ne-code"><span class="ne-text">i &lt; x.end()</span></code><span class="ne-text">这种操作，因此无法像迭代一个数组一样以一个偏序比较作为条件，那么就必须有一个哨兵作为实际可以访问到的截止位，这个哨兵就是end()。</span></p><h3 id="T5IXM"><span class="ne-text">其他补充</span></h3><p id="3e5bcbf022fee73947a9cebc6bbbd284" class="ne-p"><span class="ne-text">在自写模板的时候，需要加上关键字</span><code class="ne-code"><span class="ne-text">typename</span></code></p><pre><code>typename list&lt;T&gt;::iterator p;</code></pre><h2 id="5nJdZ"><span class="ne-text">三、容器</span></h2><h3 id="EIqvD"><span class="ne-text">Vector</span></h3><h4 id="FLeAQ"><span class="ne-text">总览</span></h4><p id="8da9b17972578457ab1b8ac68711eab1" class="ne-p"><span class="ne-text">那么，我们就开始讲每个具体的容器了。在各节中，我们会依次介绍每个容器的用途、迭代器类型、插查删操作及其复杂度，有必要的时候，我们还会介绍一些其他的小trick。</span></p><p id="90864959b211b66ce9b82c10490b466a" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1621221298034-6e429607-ece3-4c15-bd6a-e02efaf4d4f6.png" width="669" id="STppH" class="ne-image"></p><p id="bd5baafee5b7d487116c4d04df613fe2" class="ne-p"><span class="ne-text">我们看到，Vector与其他STL容器最大的区别就在于，只要元素不为bool类型（bool类型因内存对齐而不连续），它是唯一使用</span><strong><span class="ne-text">连续迭代器</span></strong><span class="ne-text">的，即使对于全部情况，它也符合遗留随机访问迭代器，从而支持以常数复杂度通过下标运算符随机访问。这使得我们可以直接将其作为升级版的数组使用——数组的功能全部被它继承，而它又自带了其他一些便捷的函数——因此vector又被称为 </span><strong><span class="ne-text">“动态数组”</span></strong><span class="ne-text"> 。</span></p><p id="68ba6e696a07e5feb42e1f9197e58ee8" class="ne-p"><span class="ne-text">它底层的数据结构使用的是静态数组，实现动态扩容的奥秘在于，它在每一次容量占用达到阈值时就进行一次翻倍扩容，从而保证了均摊 O ( 1 ) O(1) </span><span class="ne-text">O</span><span class="ne-text">(</span><span class="ne-text">1</span><span class="ne-text">)</span><span class="ne-text">的时间复杂度，而又能节省空间。</span></p><h4 id="1nRvr"><span class="ne-text">常见用法</span></h4><p id="40d49aa8a2ae98495eef68ae7a560d8b" class="ne-p"><span class="ne-text">在C++11中，在具有begin()和end()的范围上进行迭代，有一种简便写法，那就是</span></p><pre><code>for (auto&amp; v : container)</code></pre><p id="8f3f53ff952f027921f5bd7bc5c5d305" class="ne-p"><span class="ne-text">它等价于</span></p><pre><code>for (auto&amp; v = container.begin(); v != container.end(); v++)</code></pre><p id="f99b96a4b658ddef8216895c2cb93089" class="ne-p"><span class="ne-text">这里的auto利用了C++11的另一个特性——类型推导，这只是一个语法糖，它使我们不必写上container::iterator这一串复杂的类型，而在程序运行中与完整键入的并无区别。而auto后面加的&amp;代表v是一个左值引用，那么我们就可以通过v来修改容器中的元素。而如果我们想避免这种修改，可以去掉&amp;，这时v就是一个右值拷贝。</span></p><p id="5ea6aa09545d180fe8500bb40dc1e3f8" class="ne-p"><span class="ne-text">以一个int类型动态数组为例，我们可以这样输出：</span></p><pre><code>vector&lt;int&gt; arr;for (auto v : arr)    cout&lt;&lt;v;</code></pre><p id="4e7db535eb1db00d7da248ffd0162de4" class="ne-p"><span class="ne-text">而读入可以这样写：</span></p><pre><code>for (int i = 1; i &lt;= n; i++)&#123;    <pre><code>cin&amp;gt;&amp;gt;temp;arr.push_back(temp);</code></pre><p>}<br></code></pre></p><p id="666266c9dbc2b7a3d18471334ffb3fbf" class="ne-p"><span class="ne-text">当然，同程序员们默认的一样，它的下标是从0开始的。</span></p><p id="c8f2191dc38184e07be9cbf4e62fd167" class="ne-p"><span class="ne-text">vector是否可以写高维数组呢？如果你经常在Leetcode上刷题，应当见过二维数组的这种写法：</span><code class="ne-code"><span class="ne-text">vector&lt;vector&lt;int&gt;&gt;</span></code><span class="ne-text">。高维数组以此类推即可。在访问上，这种写法与</span><code class="ne-code"><span class="ne-text">int arr[][]</span></code><span class="ne-text">没有任何区别。</span></p><h3 id="DGKQN"><span class="ne-text">List</span></h3><p id="1acbcecc2af052496c684194e713ae79" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1621221298094-bbd53e64-b82a-4b51-aa3a-f354b3bd7023.png" width="669" id="D1lAx" class="ne-image"></p><p id="d63f691f3f345af2bf77c6e3f79f136d" class="ne-p"><span class="ne-text">可以看到，list实际上就是一个</span><strong><span class="ne-text">双向链表</span></strong><span class="ne-text">，因此对于插入和删除的操作具有优秀的时间表现。当然也很容易想到，list是无法实现常数时间随机访问的，insert和erase看起来时间复杂度为 O ( 1 ) O(1) </span><span class="ne-text">O</span><span class="ne-text">(</span><span class="ne-text">1</span><span class="ne-text">)</span><span class="ne-text">，但在实际应用中，找到插入位置往往就需要 O ( n ) O(n) </span><span class="ne-text">O</span><span class="ne-text">(</span><span class="ne-text">n</span><span class="ne-text">)</span><span class="ne-text">的时间。</span></p><p id="d32940f3fd463a51dc7ea65729be9260" class="ne-p"><span class="ne-text">与list相似的，STL中还存在一个单向链表forward_list。由于不需要反向链，它的空间占用有所减小，不过这一点在竞赛中不怎么需要，所以那种结构了解即可。</span></p><h3 id="rolg4"><span class="ne-text">Stack</span></h3><h4 id="kAXMV"><span class="ne-text">总览</span></h4><p id="3ef016234adc4e2ac63f435d07edfb7f" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1621221298067-e4b7c1aa-ec7e-4535-a505-59440ac713db.png" width="669" id="Sfmf5" class="ne-image"></p><p id="876d6e559924ae58ddc7a67716f7c38c" class="ne-p"><span class="ne-text">相比于精心构造的数据结构，stack似乎更应当被称为一种“包装器”，它在底层实现的基础上屏蔽掉了一些功能，从而使自身表现得更像一个物理栈。对于它和queue，我们不需要多费口舌，也许这是仅有的两种我们可以自己实现而不会使代码冗长的数据结构了。但无论怎么说，有一个构造好的容器使用总是好的，它可以防止我们在底层的操作上犯一些愚蠢的错误。</span></p><h4 id="PHE4D"><span class="ne-text">常见用法</span></h4><p id="2db55f94404cd8b7f985357ba12bf50a" class="ne-p"><span class="ne-text">那么，这里就实际给出使用stack完成DFS的过程，以下是一段代码片段：</span></p><pre><code>vector&lt;int&gt; edges[N];    stack&lt;int&gt; dfs;    /*............*/    dfs.push(v0);    vis[v0] = true;    while (!dfs.empty())    &#123;    <pre><code>    bool tag = false;    int now = dfs.top();    prt.push_back(now);    for (auto v : edges[now])        if (!vis[v])        &#123;            dfs.push(v);            vis[v] = true;            tag = true;            break;        &#125;    if (!tag)        dfs.pop();&#125;</code></pre><p></code></pre></p><h3 id="55tfW"><span class="ne-text">Deque及其延伸</span></h3><h4 id="nzjq9"><span class="ne-text">Deque</span></h4><p id="2bbed1a65109b74243d276980a437a1b" class="ne-p"><span class="ne-text">虽然实际使用时很少见，但deque是很多STL容器的基础，stack和queue都由它封装而来，它也支持相当多的操作，详见下表：</span></p><p id="7c1538f25f54b9cb6eef0f1277000c7a" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1621221298045-e627f316-cc63-4992-817c-f8025c1474df.png" width="669" id="yw0ii" class="ne-image"></p><p id="e4c286b966d21b0cde6e4afb055e06d5" class="ne-p"><span class="ne-text">值得注意的是，该容器的迭代器非法化情形比较有趣，其原理也是面试题常考的内容，建议结合STL源码深入分析。</span></p><p id="50074c6f4b501f0f0b3d31f55a9f4d92" class="ne-p"><span class="ne-text">结合上表，发现它与List的区别主要在于，它能够实现常数时间随机访问，但内部插入、删除却需要线性时间，这也符合他们底层实现：链表和数组的区别，也正是这一点使得它们的迭代器一个是双向而另一个是随机访问。多进行这种思考，由</span><strong><span class="ne-text">底层实现——容器——迭代器——操作</span></strong><span class="ne-text">转为</span><strong><span class="ne-text">底层实现——迭代器——操作</span></strong><span class="ne-text">，是一名程序员获得抽象思维的重要方式。</span></p><h4 id="6rbAT"><span class="ne-text">Queue</span></h4><p id="3909376590ae0222a94ca9c7692afde7" class="ne-p"><span class="ne-text">总览</span></p><p id="cdee1d85330f92001b29a84a305488fe" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1621221298045-979ccd1c-9d0c-4971-8323-beeb278dfecb.png" width="669" id="LTTqa" class="ne-image"></p><p id="ec3bf6075f1a314469dd41c85550556d" class="ne-p"><span class="ne-text">queue就是我们常说的</span><strong><span class="ne-text">队列</span></strong><span class="ne-text">了。同stack一样，它是很常见而且简单的数据结构，同样由deque封装得来。当然，由于deque和list都满足它的底层实现的要求，因此你可以指明换用list作为你的queue的底层实现：</span></p><pre><code>queue&lt;int, list&lt;int&gt;&gt; myQue;</code></pre><p id="b3e401d6e594a0ed43953b2bf0cee848" class="ne-p"><span class="ne-text">由于STL容器都使用模板类，因此在实际开发中，你完全可以将所有容器的分配器、底层容器自主实现。</span></p><p id="2b75de0ad67e1676f0db8df3cdadd680" class="ne-p"><span class="ne-text">6.2.2.常见用法</span></p><p id="7d2eb183e468080fbbedee2f802bb948" class="ne-p"><span class="ne-text">queue用来实现BFS应该是最常见的用法了，以下和stack一样给出一个代码片段：</span></p><pre><code>queue&lt;int&gt; que;    while (!que.empty())    &#123;    <pre><code>    int now = que.front();    que.pop();    if (success(pos[now]))        return true;    for (int i = 0; i &amp;lt; n; i++)        if (!vis[i] &amp;amp;&amp;amp; dis[now][i] &amp;lt;= limit)        &#123;            que.push(i);            vis[i] = true;        &#125;&#125;</code></pre><p></code></pre></p><h4 id="nq54Y"><span class="ne-text">Priority_Queue</span></h4><p id="f8bba081079bb648ee52b2800fa424d1" class="ne-p"><span class="ne-text">6.3.1.总览</span></p><p id="73c8082ad9bcb477ced5371c8f482918" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1621221298072-4aa3333f-4fe3-4f4e-8f10-212345e22947.png" width="669" id="Qei4g" class="ne-image"></p><p id="b1a64cf544310cf445ace3e2c776c0b2" class="ne-p"><span class="ne-text">priority_queue实现了优先队列这一ADT，也就是我们常说的 </span><strong><span class="ne-text">“堆”</span></strong><span class="ne-text"> 。但要明晰的是，优先队列是一种ADT，而堆是它的一种具体实现。在默认状态下，priority_queue实现的是大根堆，但你可以通过模板特化从而实现小根堆，甚至是自己定义的规则。</span></p><p id="18bee2c7c8a3ef343a4a01fb476dc32f" class="ne-p"><span class="ne-text"></span></p><p id="2625d01610d99818430568d7dc76a179" class="ne-p"><span class="ne-text">6.3.2.常见用法</span></p><p id="fc64dc42e1cfe0f73f54117301683f43" class="ne-p"><span class="ne-text">实现小根堆的方式很简单:</span></p><pre><code>priority_queue&lt;int, vector&lt;int&gt;, std::greater&lt;int&gt;&gt; myHeap;</code></pre><p id="b33ef558e9c550cef931703739fb90fd" class="ne-p"><span class="ne-text">其中第一个参数为元素类型，第二个类型为底层实现，默认为vector，但STL库中的deque也符合要求。第三个参数为你的比较类型。priority_queue会按照这一比较偏序将</span><strong><span class="ne-text">最末序</span></strong><span class="ne-text">的元素作为“最大元素”。</span></p><p id="4417a73f75ce3889eaf3285c2868f150" class="ne-p"><span class="ne-text">在sort函数中自己构造函数对象以指定排序方式的写法非常基础，但其实在优先队列中指定排序方式的写法也并不困难。在sort中，我们传入一个函数指针，sort函数调用这个函数，获得它的返回值，从而得到元素之间的偏序。而在模板类中，由于</span><strong><span class="ne-text">需要在编译期就特化类</span></strong><span class="ne-text">，所以我们无法传入一个函数，而必须传入一个</span><strong><span class="ne-text">类</span></strong><span class="ne-text">。堆在排序时会</span><strong><span class="ne-text">调用其构造函数</span></strong><span class="ne-text">，获得构造函数的返回值，这整体上与我们给sort传参无异。</span></p><p id="165ef316ded3d73eba745a367532c747" class="ne-p"><span class="ne-text">大多数情况下，我们可以使用STL提供的编译器函数库中的比较运算，例如小于是less，大于等于是greater_equal，等等。上面用于实现小根堆的greater源码如下：</span></p><pre><code>template&lt;typename _Tp&gt;    struct greater : public binary_function&lt;_Tp, _Tp, bool&gt;    &#123;    <pre><code>    bool    operator()(const _Tp&amp;amp; __x, const _Tp&amp;amp; __y) const    &#123; return __x &amp;gt; __y; &#125;&#125;;</code></pre><p></code></pre></p><p id="a78f9ba03c7b071ed994cf16d4234a6d" class="ne-p"><span class="ne-text">然而观察这一函数，它最终还是要调用具体类型的比较运算。那么如果我们给容器的类不具有偏序，或者我们需要特别指定偏序怎么办呢？下面给出一个实例。</span></p><p id="e8d6aadcbc80e9b16463d5e5cb8f57a8" class="ne-p"><span class="ne-text">例如，在图的搜索中我们需要存储点和它到源点的距离，那么我们的元素可能是这样的：</span></p><pre><code>typename int Vertex;typename int Distance;typename pair&lt;Vertex, Distance&gt; Dest;</code></pre><p id="fdac6754ddac46a7c32775d34f405a56" class="ne-p"><span class="ne-text">在Dijkstra算法中，用堆优化时我们需要建立边权的小根堆，那么就可以这样自建比较类型（我们知道自己要使用的类型，就不需要写成模板类了）：</span></p><pre><code>struct myGreater : public binary_function&lt;Dest, Dest, bool&gt;&#123;    <pre><code>bool operator() (const Dest &amp;amp;lhs, const Dest &amp;amp;rhs) const&#123; return lhs.second &amp;gt; rhs.second; &#125;</code></pre><p>}<br></code></pre></p><p id="abcbbae7b6f64f631f2ef577d5b39fea" class="ne-p"><span class="ne-text">于是就可以这样建立基于边权的小根堆：</span></p><pre><code>priority_queue&lt;Dest, vector&lt;Dest&gt;, myGreater&gt; myHeap;</code></pre><h3 id="UVR8t"><span class="ne-text">Set及Multiset</span></h3><h4 id="0ldEU"><span class="ne-text">总览</span></h4><p id="37cd991762e49138a54b07d2185a183a" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1621221298126-cd7b73e2-055e-4325-8270-dadc26949011.png" width="669" id="fntg7" class="ne-image"></p><p id="460933e07cace91c2d79850aa732d841" class="ne-p"><span class="ne-text">set对应的ADT是</span><strong><span class="ne-text">集合</span></strong><span class="ne-text">：它支持元素的存储和查找，同时符合抽象意义上的集合要求——</span><strong><span class="ne-text">不允许出现重复元素</span></strong><span class="ne-text">。</span></p><h4 id="eJ0my"><span class="ne-text">常见用法</span></h4><p id="608b3b42ab2d86d2318893fb566ca7a6" class="ne-p"><span class="ne-text">set的一个重要用途就是</span><strong><span class="ne-text">排序同时去重</span></strong><span class="ne-text">。在BST家族中，理论表现最好的是Fibonacci-heap，但由于常数过大，实际表现最好的数据结构其实是set所采用的底层结构红黑树。如果说排序去重可以通过使用一个sort函数加手工来完成，那么需要</span><strong><span class="ne-text">支持插入和查找</span></strong><span class="ne-text">的题目呢？莫非我们要手写RBT吗？这时候，一个深受考验的set无疑是广大竞赛选手的福音。</span></p><p id="67486a4a9e1734a9fe7de395f24fbb50" class="ne-p"><span class="ne-text">当然，在更多的情况下，我们需要</span><strong><span class="ne-text">允许数据中出现重复</span></strong><span class="ne-text">的元素，那么</span><strong><span class="ne-text">可以使用multiset</span></strong><span class="ne-text">这种数据结构，它在其他地方与set无异，唯一的区别在于它允许重复元素的出现。</span></p><p id="6328a682fa5e63b882187edf744a94b1" class="ne-p"><span class="ne-text">在容器中，find函数在找不到对象的时候一般会返回end，那么查找可以写作：</span></p><pre><code>if (c.find(x) != c.end())    //do something...</code></pre><h3 id="KnVnr"><span class="ne-text">Map</span></h3><h4 id="fGies"><span class="ne-text">总览</span></h4><p id="11714e03628efdbd418962483353ea3c" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1621221298068-5d1c0d5a-095f-44a8-92cd-fa4bc119ab01.png" width="669" id="dyk1Y" class="ne-image"></p><h4 id="Brk2P"><span class="ne-text">常见用法</span></h4><p id="6b7f1567e7734cb156957c66f7742e78" class="ne-p"><span class="ne-text">map和set非常类似，只不过它的数据是</span><strong><span class="ne-text">键值对</span></strong><span class="ne-text">而非一个单独的键，而</span><strong><span class="ne-text">键是唯一的</span></strong><span class="ne-text">。如果给它的用途举个例子，可以是存储源点到所有可达点的访问记录。</span></p><p id="8512a19455a672ebcd5cffe914270d06" class="ne-p"><span class="ne-text">当然，同map一样，它也有允许键不唯一的版本，那就是</span><strong><span class="ne-text">multimap</span></strong><span class="ne-text">。本质上，</span><code class="ne-code"><span class="ne-text">multimap&lt;Key, T&gt;</span></code><span class="ne-text">等价于</span><code class="ne-code"><span class="ne-text">multiset&lt;pair&lt;Key, T&gt;, Comp&lt;pair&lt;Key, T&gt;&gt;, std::allocator&lt;std::pair&lt;Key, T&gt;&gt;&gt;</span></code><span class="ne-text">，其中Comp是自主实现的依据Key的比较类型。</span></p><p id="54a78d612f66c46942d22fae55ef4be8" class="ne-p"><span class="ne-text">也就是说，map和set和priority_queue一样，支持特化比较类型，特化的方式也是一样的。只不过实际使用的时候，不要忘记最后一个模板参数，那是用于生成元素空间的分配器。</span></p><h2 id="MeMEn"><span class="ne-text">四、算法</span></h2><p id="6901abc61810e97f08b225965a3331a0" class="ne-p"><span class="ne-text">STL里面有一些常用的函数模板，可以在平常使用。</span></p><p id="4343e03862a3774dcea7257894b11748" class="ne-p"><span class="ne-text"></span></p><div class="ne-quote"><p id="24ddbcb123cfa0ba4c14afd8e23a1491" class="ne-p"><span class="ne-text">参考这个链接：</span><a href="https://segmentfault.com/a/1190000021581714" data-href="https://segmentfault.com/a/1190000021581714" target="_blank" class="ne-link"><span class="ne-text">https://segmentfault.com/a/1190000021581714</span></a></p></div><h2 id="Muzfm"><span class="ne-text">五、总结</span></h2><p id="56eba145a4c02cfa4a011954a67d1c6d" class="ne-p"><span class="ne-text">本文最后，给出一个表格以供检索，相比于cppreference的总结，这里只列出了竞赛中常用的一些操作及其复杂度。begin()和end()虽然较为常用，不过由于是全体容器必备的，所以不再列出。</span></p><p id="156aed03e46ea7de2b27acae470d0b92" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1621221298131-b854f40d-40b6-42fb-a901-467032ef3583.png" width="1321" id="Pt0mu" class="ne-image"></p><p id="9e767f6fca48577ae56528e10dd311e8" class="ne-p"><span class="ne-text">这样，这篇文章也就基本结束了。可以看到，为了照顾特定的使用需求，本文对容器具体的实现未做过多探讨，反而对通常不太重视的迭代器部分做了一定的讲解。在竞赛中掌握这些内容，已经能够满足几乎全部的需求了。但在实际应用中，掌握这些内容甚至不足以通过一个大厂的面试。例如，deque的若是对容器原理有兴趣，可以找市面上评价较好的STL源码解读类书籍学习。</span></p><p id="51b6ea6eb3ea297d2531b1a174409218" class="ne-p"><span class="ne-text"></span></p><div data-type="tips" class="ne-alert"><p id="0c4773046d8106f57ad18705b5021e76" class="ne-p"><span class="ne-text">补充：头文件#include&lt;bits/stdc.h&gt;（最常用，特别是OJ刷题）的内容如下</span></p></div><p id="83b015f0947ebeaea02152032cc3da8d" class="ne-p"><br></p><pre><code>// C++ includes used for precompiling -*- C++ -*- <p>// Copyright (C) 2003-2013 Free Software Foundation, Inc.<br>//<br>// This file is part of the GNU ISO C++ Library.  This library is free<br>// software; you can redistribute it and/or modify it under the<br>// terms of the GNU General Public License as published by the<br>// Free Software Foundation; either version 3, or (at your option)<br>// any later version.</p><p>// This library is distributed in the hope that it will be useful,<br>// but WITHOUT ANY WARRANTY; without even the implied warranty of<br>// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the<br>// GNU General Public License for more details.</p><p>// Under Section 7 of GPL version 3, you are granted additional<br>// permissions described in the GCC Runtime Library Exception, version<br>// 3.1, as published by the Free Software Foundation.</p><p>// You should have received a copy of the GNU General Public License and<br>// a copy of the GCC Runtime Library Exception along with this program;<br>// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see<br>// &lt;Licenses - GNU Project - Free Software Foundation&gt;.</p><p>/** @file stdc++.h</p><ul><li> This is an implementation file for a precompiled header.</li><li>/</li></ul><p>// 17.4.1.2 Headers</p><p>// C<br>#ifndef _GLIBCXX_NO_ASSERT<br>#include &lt;cassert&gt;<br>#endif<br>#include &lt;cctype&gt;<br>#include &lt;cerrno&gt;<br>#include &lt;cfloat&gt;<br>#include &lt;ciso646&gt;<br>#include &lt;climits&gt;<br>#include &lt;clocale&gt;<br>#include &lt;cmath&gt;<br>#include &lt;csetjmp&gt;<br>#include &lt;csignal&gt;<br>#include &lt;cstdarg&gt;<br>#include &lt;cstddef&gt;<br>#include &lt;cstdio&gt;<br>#include &lt;cstdlib&gt;<br>#include &lt;cstring&gt;<br>#include &lt;ctime&gt;</p><p>#if __cplusplus &gt;= 201103L<br>#include &lt;ccomplex&gt;<br>#include &lt;cfenv&gt;<br>#include &lt;cinttypes&gt;<br>#include &lt;cstdalign&gt;<br>#include &lt;cstdbool&gt;<br>#include &lt;cstdint&gt;<br>#include &lt;ctgmath&gt;<br>#include &lt;cwchar&gt;<br>#include &lt;cwctype&gt;<br>#endif</p><p>// C++<br>#include &lt;algorithm&gt;<br>#include &lt;bitset&gt;<br>#include &lt;complex&gt;<br>#include &lt;deque&gt;<br>#include &lt;exception&gt;<br>#include &lt;fstream&gt;<br>#include &lt;functional&gt;<br>#include &lt;iomanip&gt;<br>#include &lt;ios&gt;<br>#include &lt;iosfwd&gt;<br>#include &lt;iostream&gt;<br>#include &lt;istream&gt;<br>#include &lt;iterator&gt;<br>#include &lt;limits&gt;<br>#include &lt;list&gt;<br>#include &lt;locale&gt;<br>#include &lt;map&gt;<br>#include &lt;memory&gt;<br>#include &lt;new&gt;<br>#include &lt;numeric&gt;<br>#include &lt;ostream&gt;<br>#include &lt;queue&gt;<br>#include &lt;set&gt;<br>#include &lt;sstream&gt;<br>#include &lt;stack&gt;<br>#include &lt;stdexcept&gt;<br>#include &lt;streambuf&gt;<br>#include &lt;string&gt;<br>#include &lt;typeinfo&gt;<br>#include &lt;utility&gt;<br>#include &lt;valarray&gt;<br>#include &lt;vector&gt;</p><p>#if __cplusplus &gt;= 201103L<br>#include &lt;array&gt;<br>#include &lt;atomic&gt;<br>#include &lt;chrono&gt;<br>#include &lt;condition_variable&gt;<br>#include &lt;forward_list&gt;<br>#include &lt;future&gt;<br>#include &lt;initializer_list&gt;<br>#include &lt;mutex&gt;<br>#include &lt;random&gt;<br>#include &lt;ratio&gt;<br>#include &lt;regex&gt;<br>#include &lt;scoped_allocator&gt;<br>#include &lt;system_error&gt;<br>#include &lt;thread&gt;<br>#include &lt;tuple&gt;<br>#include &lt;typeindex&gt;<br>#include &lt;type_traits&gt;<br>#include &lt;unordered_map&gt;<br>#include &lt;unordered_set&gt;<br>#endif<br></code></pre></p></div>]]></content>
      
      
      <categories>
          
          <category> 计算机素养 </category>
          
          <category> 非前端编程语言 </category>
          
          <category> CPlusPlus </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>视频的无伤切割</title>
      <link href="/blog/wr3hmo/"/>
      <url>/blog/wr3hmo/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="ud132d32d" class="ne-p"><span class="ne-text">前言：对于一个很大的视频，不方便和其他用户使用软件传输，需要将其切割成数个小容量视频，两种方法，一种是利用其他软件来进行切割，比如pr；另一种是利用万能的ffmpeg，这个需求采用后者方法。</span></p><p id="uf011c49d" class="ne-p"><span class="ne-text">需求视频为8G多，总时长01：51：00，QQ在线传输一次最多4G，所以需要将目标视频切成三段，需要的命令如下：</span></p><pre><code>ffmpeg -ss 00:00:00 -i target.mp4 -c copy -t 00:45:00 target-part1.mp4 #Start～00:45:00ffmpeg -ss 00:45:00 -i target.mp4 -c copy -t 00:45:00 target-part2.mp4 #00:45:00~01:30:00ffmpeg -ss 01:30:00 -i target.mp4 -c copy -t 00:21:00 target-part3.mp4 #01:30:00～End</code></pre><p id="u86567bc1" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1643942474386-cacbcb25-dd05-48fa-b575-7cf6e13eb635.png" width="675" id="u9fb04278" class="ne-image"></p></div>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
          <category> 前端业务解决方案 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>多一些沉稳，少一点浮躁</title>
      <link href="/essay/wrlggf/"/>
      <url>/essay/wrlggf/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="u426878f6" class="ne-p"><br></p><div data-type="info" class="ne-alert"><p id="ue7f3a63c" class="ne-p"><span class="ne-text">在自己、同学身上学到的一些关于沉稳和浮躁的相关感悟。</span></p></div><p id="u76cc7f70" class="ne-p"><br></p><p id="u334205ae" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1621129502175-8304c744-6269-4ca9-a89f-7180dbd6911c.png" width="1920" id="ue9157375" class="ne-image"></p><p id="ua4bfe073" class="ne-p"><br></p><p id="uea4e4ec2" class="ne-p"><strong><span class="ne-text">多一些沉稳，少一些浮躁</span></strong></p><p id="u163a699d" class="ne-p"><br></p><p id="ufa440c5c" class="ne-p" style="text-indent: 2em"><span class="ne-text">真正的技术人是不断去学习技术的，抑或是精进自己已有的技术，而不是像一个井底之蛙，不踏踏实实做技术，只想着一步登云，对技术而言，哪来的精进可言</span></p><p id="u3e091225" class="ne-p"><br></p><p id="uaa7e917f" class="ne-p" style="text-indent: 2em"><span class="ne-text">这个节奏下面，很多人很多时候被生活牵着走，不再是我们过生活，而是生活过着我们，少了一些风情雅致，多了一些功利与欲望，就像是越肤浅的人，越浮躁，一新急于求成，功利心太重。越是有实力，能将生活活出自我的人越是沉稳安静，不急不躁，踏实努力，以梦为马，执笔为声！</span></p><p id="u6053d842" class="ne-p"><br></p><p id="u82921bff" class="ne-p" style="text-indent: 2em"><span class="ne-text">上面说到功利了，于是乎想到了我父母做生意的那路历程，做生意不可能一直起势，有起就有落，可在一些人眼中，他们所看到的，永远只有起势和高光……大学三年之下，A同学想着年薪百万，B同学想着开公司，我觉得这都是可以的，我相信年轻的资本在人生历程中是占比很足的，但是现在细想，那些话的字体行间透露着些许的浮躁，我暂且用野心来代替那些话，我相信野心这个词，但这三年在学校的生活与对社会的前驱认知告诉我，野心是基于沉稳之上的，野心是基于踏实之上，野心更是对理想而拆解成一系列目标并予以实施的基础上的，多一些沉稳，少一些浮躁……</span></p></div>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>哈夫曼树</title>
      <link href="/blog/fyhtb2/"/>
      <url>/blog/fyhtb2/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h2 id="6aTqg"><span class="ne-text">实验内容</span></h2><p id="7d4494118179e44e0f3ed8839f84ffb0" class="ne-p"><span class="ne-text">已知某系统在通信联络中只可能出现n种字符，其概率从键盘输入。试创建哈夫曼树。</span></p><p id="u14631b82" class="ne-p"><span class="ne-text"></span></p><h2 id="cozPM"><span class="ne-text">实验要求</span></h2><p id="2e4df6f34b851d957d20a58176fee7ae" class="ne-p"><span class="ne-text"> 1、从键盘输入n, 以及n个字符的概率。</span></p><p id="53159717888700928d3025e77865f9a9" class="ne-p"><span class="ne-text">例如：已知某系统在通信联络中只可能出现n种字符，其概率分别为   0.05, 0.29, 0.07, 0.08, 0.14, 0.23, 0.03, 0.11，试设计哈夫曼编码创建哈夫曼树。</span></p><p id="3f08e9ba77eae8c4d6729c3d06a2c7de" class="ne-p"><span class="ne-text">2、用顺序存储。</span></p><p id="8fa3ffb8da8d9047bbe0fcf4b26a8146" class="ne-p"><span class="ne-text">3、输出结果如下</span></p><p id="8ca76d9eebc14783ea80967a6eede7f6" class="ne-p"><span class="ne-text"> </span><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1620964210279-ee3848d0-d031-4dc0-a850-3ae179b7a317.png" width="312" id="lteAK" class="ne-image"></p><p id="0c54abe86060ef65be0dc82c893a755c" class="ne-p"><span class="ne-text">交作业时间：下次上机前</span></p><h2 id="z4tNS"><span class="ne-text">实验代码</span></h2><pre><code>#include &lt;bits/stdc++.h&gt;using namespace std;<p>int n, m, s1, s2;<br>typedef struct HTNode<br>&#123;<br>    int weight, parent, lchild, rchild, pos;<br>    bool operator&lt;(const HTNode &amp;a)const<br>   &#123;<br>       return a.weight &lt; weight;<br>   &#125;<br>&#125;HTNode, *HuffmanTree;</p><p>priority_queue&lt;HTNode&gt;P;</p><p>void Select(HuffmanTree &amp;HT, int ii, int &amp;s1, int &amp;s2)<br>&#123;<br>    HTNode t = P.top();<br>    s1 = t.pos;<br>    P.pop();<br>    t = P.top();<br>    s2 = t.pos;<br>    P.pop();<br>&#125;</p><p>void CreateHuffmantree(HuffmanTree &amp;HT, int n)<br>&#123;<br>    if(n &lt;= 1)<br>        return;<br>    m = 2 * n - 1;<br>    HT = new HTNode[m + 1];<br>    for(int i = 1; i &lt;= m; i++)<br>    &#123;<br>        HT[i].parent = 0;<br>        HT[i].lchild = 0;<br>        HT[i].rchild = 0;<br>    &#125;<br>    for(int i = 1; i &lt;= n; ++i)<br>    &#123;<br>        cin &gt;&gt; HT[i].weight;<br>        HT[i].pos = i;<br>        P.push(HT[i]);<br>    &#125;<br>    for(int i = n + 1; i &lt;= m; i++)<br>    &#123;<br>        Select(HT, i - 1, s1, s2);<br>        HT[s1].parent = i;<br>        HT[s2].parent = i;<br>        HT[i].lchild = s1;<br>        HT[i].rchild = s2;<br>        HT[i].weight = HT[s1].weight + HT[s2].weight;<br>        HT[i].pos = i ;<br>        P.push(HT[i]);<br>    &#125;<br>&#125;</p><p>int main()<br>&#123;<br>    HuffmanTree HT;<br>    cout &lt;&lt; &quot;请输入哈夫曼树的叶子结点个数：&quot;;<br>    cin &gt;&gt; n;<br>    cout &lt;&lt; &quot;请输入每个叶子结点的权值：&quot; &lt;&lt; ‘\n’;<br>    CreateHuffmantree(HT, n);<br>    for(int i = 1; i &lt;= 2 * n - 1; ++i)<br>    &#123;<br>        cout &lt;&lt; &quot;结点序号 &quot; &lt;&lt; i &lt;&lt; &quot; 权重 &quot; &lt;&lt; HT[i].weight<br>        &lt;&lt; &quot; parent &quot; &lt;&lt; HT[i].parent &lt;&lt; &quot; lchild &quot; &lt;&lt; HT[i].lchild<br>        &lt;&lt; &quot; rchild &quot; &lt;&lt; HT[i].rchild &lt;&lt; ‘\n’;<br>    &#125;<br>&#125;</p><p></code></pre></p><h2 id="Oq4eC"><span class="ne-text">实验结果</span></h2><p id="a17e3b9f9fa59ed14ab816423bd5d336" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1621215937466-2f1ef720-c7ae-4103-bf0b-0f75855059ff.png" width="369" id="mQROC" class="ne-image"></p></div>]]></content>
      
      
      <categories>
          
          <category> 计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 🌲树结构：二叉树-哈夫曼树 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>树的基本知识</title>
      <link href="/blog/tyyaq0/"/>
      <url>/blog/tyyaq0/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h2 id="wUWWX"><span class="ne-text">基本概念</span></h2><p id="ud11c2854" class="ne-p"><br></p><p id="d59840dd0f24290c76b104f04af4576f" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1625137853863-648e9e16-dded-4a47-81c4-4dc759a29e05.png" width="435.5" id="krxvv" class="ne-image"><span class="ne-text">  </span></p><p id="2b08cadb4fc1c56acd4a172087e12859" class="ne-p"><span class="ne-text"></span></p><p id="499128c4757efa545c7b3aae17ab1c85" class="ne-p"><span class="ne-text"></span></p><p id="0db3ada666899d52bef676216cc77384" class="ne-p"><span class="ne-text"></span></p></div>]]></content>
      
      
      <categories>
          
          <category> 计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 🌲树结构：二叉树-哈夫曼树 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>blob格式视频链接的下载</title>
      <link href="/blog/bhnvxw/"/>
      <url>/blog/bhnvxw/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h3 id="my40N"><span class="ne-text">场景</span></h3><p id="ub57bf056" class="ne-p"><span class="ne-text">有些网页的视频链接（html中）如下格式会下载不了，也没有视频的url可供访问</span></p><ul class="ne-ul"><li id="ua5adde30"><span class="ne-text">具体网页：</span><code class="ne-code"><a href="https://5kb.co/vodplay/33666-2-1.html" data-href="https://5kb.co/vodplay/33666-2-1.html" target="_blank" class="ne-link"><span class="ne-text">https://5kb.co/vodplay/33666-2-1.html</span></a></code></li><li id="ub002c8b1"><span class="ne-text">网页中的blob视频格式</span></li></ul><pre><code>&lt;img src: &quot;blob:https://5kb.co/a504161c-cf27-4979-a1c3-86a0ce4f6556&quot;&gt;</code></pre><ul class="ne-ul"><li id="ud27b560d"><span class="ne-text">控制台查看后缀为m3u8的接口访问网络请求</span></li></ul><p id="ud04248ff" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1641182194610-2c7ff9b7-6445-45b3-b2d9-fcbe164705b4.png" width="820" id="u616d033a" class="ne-image"></p><h3 id="cC4PX"><span class="ne-text">解决思路</span></h3><p id="u03a76a85" class="ne-p"><span class="ne-text">思路：安装ffmpeg环境，利用转换命令将其转换为MP4资源</span></p><ul class="ne-ul"><li id="uce246083"><span class="ne-text">ffmpeg环境的安装：</span><a href="https://www.yuque.com/wztlink1013/blog/akf33e#pDCNT" data-href="https://www.yuque.com/wztlink1013/blog/akf33e#pDCNT" target="_blank" class="ne-link"><span class="ne-text">https://www.yuque.com/wztlink1013/blog/akf33e#pDCNT</span></a></li><li id="u02d12fdd"><span class="ne-text">转换命令：</span></li></ul><pre><code>ffmpeg -i https://v3.dious.cc/20210520/8sKShH2U/index.m3u8 target.mp4</code></pre><h3 id="BtAhT"><span class="ne-text">关于blob视频加密相关知识</span></h3><p id="u4cafee64" class="ne-p"><span class="ne-text">blob视频加密就相当于将原视频url进行隐藏，然后切片访问播放。</span></p><p id="uc4c9fa2e" class="ne-p"><span class="ne-text">那么网页如何成功加载该视频呢？服务器会返回一个m3u8的响应文件，这个文件的作用就是正确找到所有的切片，然后拼接播放。</span></p><p id="u873a2172" class="ne-p"><span class="ne-text"></span></p><p id="ub09557a7" class="ne-p"><span class="ne-text">在使用ffmpeg将其拼接ts文件称mp4文件过程中，如下：</span></p><p id="u06afdfb4" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1641183335922-952b5616-e47f-44fa-89b6-4f6abaf78157.png" width="1402" id="u8b056dae" class="ne-image"></p><p id="u4f49849a" class="ne-p"><span class="ne-text">那么ts文件又是什么用的呢？</span></p><p id="u6093b0a7" class="ne-p"><span class="ne-text">百度百科的定义：</span></p><div class="ne-quote"><p id="u9945b40f" class="ne-p"><span class="ne-text">ts是日本高清摄像机拍摄下进行的封装格式，全称为MPEG2-TS。ts即&quot;Transport Stream&quot;的缩写。MPEG2-TS格式的特点就是要求从视频流的任一片段开始都是可以独立解码的。</span></p></div><p id="u7ab401c8" class="ne-p"><span class="ne-text"></span></p></div>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
          <category> 前端业务解决方案 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>二叉树的创建与遍历🔖DFS🔖先序🔖中序🔖后序</title>
      <link href="/blog/ggimdr/"/>
      <url>/blog/ggimdr/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h2 id="4Epl1"><span class="ne-text">实验报告</span></h2><div data-type="color1" class="ne-alert"><p id="a20d224c568e48b9d67847a2c66a8c01_p_0" class="ne-p"><span class="ne-text">编写一个程序，实现二叉树的各种运算，并在此基础上设计一个程序完成如下功能：</span></p></div><p id="4d03c6b09b984aef043ed5b518c363c7" class="ne-p"><br></p><div class="ne-quote"><p id="38598db323ff50acdf71c84be93d56d2" class="ne-p"><span class="ne-text">（1）创建一棵二叉树（用键盘按照</span><strong><span class="ne-text">先序遍历</span></strong><span class="ne-text">序列输入一个字符串生成二叉树）；</span></p><p id="6d6611128e131f3a0d3a0f0d853687c8" class="ne-p"><span class="ne-text">（2）输出前序、中序、后序遍历的遍历序列；  </span></p><p id="d3bc67e9954efda55a647c26d988e214" class="ne-p"><span class="ne-text">（3）统计并输出二叉树的的结点个数；</span></p><p id="2b559b492f686815878cb75ac83b3b42" class="ne-p"><span class="ne-text">（4）输出二叉树的叶子结点的个数；(选做)</span></p></div><p id="c05a274226f7be751442f3c2688a5e1f" class="ne-p"><br></p><div data-type="color1" class="ne-alert"><p id="3d301d5e79f0b9519c224c1db62d626b" class="ne-p"><span class="ne-text">实验要求：  </span></p></div><p id="9a21f7d2dbdf87c8a1d6951d6090b939" class="ne-p"><br></p><div class="ne-quote"><p id="29367bb74625a503f401e74a67a84591" class="ne-p"><span class="ne-text">用键盘输入一个字符串，按照</span><strong><span class="ne-text">满二叉树的特点</span></strong><span class="ne-text">生成一棵二叉树。</span></p></div><p id="663a7b36b101c7fddf398dd7f4151ef9" class="ne-p"><br></p><div data-type="color1" class="ne-alert"><p id="31e43c4890b63675efb128313a69f5e6" class="ne-p"><span class="ne-text">测试用例要求：</span></p></div><p id="8508e775c2dd3f3338c305eec70bcfd5" class="ne-p"><br></p><div class="ne-quote"><p id="5b4622339600d057a077198d9246b236" class="ne-p"><span class="ne-text">如下二叉树的输入字符串为：ABD###C#E##</span></p><p id="70373932282643f63ec142623dc8c357" class="ne-p"><span class="ne-text">书写方法：碰到#说明该二叉树是一棵空树，注意分配（下面缺两个左右补两个#，缺一个左/右子树，补一个#）</span></p></div><p id="1e4fa4b6d686ada91a2726874baf4778" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1620295747111-4774a4a6-b617-4f26-a0c3-f9f1bdb386cc.png" width="235" id="Fl1gC" class="ne-image"></p><div data-type="color1" class="ne-alert"><p id="33e9672dfd9a5ed7c83baa6580c2cfdb" class="ne-p"><span class="ne-text">二叉链表的结点类型（C++）：</span></p></div><p id="203045dd2c8c14b360c1d2de82cbf109" class="ne-p"><br></p><pre><code>Typedef structure  tnode&#123;    int   data;    structure  tnode   *lchild, *rchild;&#125;bitree,*bitlink ;</code></pre><h2 id="iDiJK"><span class="ne-text">实验代码</span></h2><p id="4e4255e3159bf6d3a0d0ac2d29c6a6aa" class="ne-p"><span class="ne-text">用上面的二叉树作为例子：</span></p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;typedef int Status;typedef char TElemType;#define OVERFLOW -1#define ERROR 0#define OK 1char ch;<p>/**</p><ul><li>采用二叉链表的存储形式</li><li>/<br>typedef struct BiTNode<br>&#123;<br>  TElemType data;<br>  struct BiTNode *lchild, *rchild;<br>&#125;BiTNode, *BiTree;</li></ul><p>/**</p><ul><li>创建一棵二叉树</li><li>/<br>void CreateBiTree(BiTree &amp;T) &#123;<br>  //按先序次序输入二叉树中结点的值，创建二叉链表表示的二叉树T<br>  TElemType ch;<br>  cin&gt;&gt;ch;<br>  if(ch == ‘#’)&#123;//递归结束，建空树<pre><code>  T = NULL;</code></pre>  } else {<pre><code>  T = new BiTNode;  T-&amp;gt;data = ch;  CreateBiTree(T-&amp;gt;lchild);  CreateBiTree(T-&amp;gt;rchild);</code></pre>  }     </li></ul><p>}</p><p>/**</p><ul><li>先序遍历</li><li>/<br>void PreOrderTraverse(BiTree &amp;T)<br>{//先序遍历二叉树T的递归算法<br>  if(T)                               //若二叉树非空<br>  {<pre><code>  cout &amp;lt;&amp;lt; T-&amp;gt;data &amp;lt;&amp;lt; &amp;quot; &amp;quot;;                  //访问根结点   PreOrderTraverse(T-&amp;gt;lchild);     //中序遍历左子树   PreOrderTraverse(T-&amp;gt;rchild);     //中序遍历右子树</code></pre>  }<br>}</li></ul><p>/**</p><ul><li>中序遍历</li><li>/<br>void InOrderTraverse(BiTree &amp;T) {<br>  if (T) {<pre><code>  InOrderTraverse(T-&amp;gt;lchild);  cout &amp;lt;&amp;lt; T-&amp;gt;data &amp;lt;&amp;lt; &amp;quot; &amp;quot;;  InOrderTraverse(T-&amp;gt;rchild);</code></pre>  }<br>}</li></ul><p>/**</p><ul><li>后序遍历</li><li>/<br>void PostOrderTraverse(BiTree &amp;T)<br>{//后序遍历二叉树T的递归算法<br>  if(T)                               //若二叉树非空<br>  {<pre><code>  PostOrderTraverse(T-&amp;gt;lchild);   //中序遍历左子树   PostOrderTraverse(T-&amp;gt;rchild);   //中序遍历右子树  cout &amp;lt;&amp;lt; T-&amp;gt;data &amp;lt;&amp;lt; &amp;quot; &amp;quot;;                 //访问根结点 </code></pre>  }<br>}</li></ul><p>/**</p><ul><li>统计二叉树中节点个数</li><li>/<br>int NodeCount (BiTree &amp;T) {<br>  if (T == NULL) {<pre><code>  return 0;</code></pre>  } else {<pre><code>  return NodeCount(T-&amp;gt;lchild) + NodeCount(T-&amp;gt;rchild) + 1;</code></pre>  }<br>}</li></ul><p>/**</p><ul><li>二叉树中叶结点个数</li><li>/<br>int LeavesCount (BiTree &amp;T) {<br>  if (T == NULL) {<pre><code>  return 0;</code></pre>  } else if (T-&gt;lchild == NULL &amp;&amp; T-&gt;rchild == NULL) {<pre><code>  return LeavesCount(T-&amp;gt;lchild) + LeavesCount(T-&amp;gt;rchild) + 1;</code></pre>  }<br>  else {<pre><code>  return LeavesCount(T-&amp;gt;lchild) + LeavesCount(T-&amp;gt;rchild);</code></pre>  }<br>}</li></ul><p>int main() {<br>    BiTree test = new BiTNode;<br>    cout &lt;&lt; &quot;请输入一个字符串以生成二叉树：&quot;;<br>    CreateBiTree(test);<br>    cout &lt;&lt;&quot;\n&quot;&lt;&lt; &quot;先序遍历结果：&quot;;<br>    PreOrderTraverse(test);<br>    cout &lt;&lt;&quot;\n&quot;&lt;&lt; &quot;中序遍历结果：&quot;;<br>    InOrderTraverse(test);<br>    cout &lt;&lt;&quot;\n&quot;&lt;&lt; &quot;后序遍历结果：&quot;;<br>    PostOrderTraverse(test);<br>    cout &lt;&lt;&quot;\n&quot;&lt;&lt; &quot;二叉树结点个数：&quot;&lt;&lt;NodeCount(test);<br>    cout &lt;&lt;&quot;\n&quot;&lt;&lt; &quot;二叉树叶结点个数：&quot;&lt;&lt;LeavesCount(test);<br>}<br></code></pre></p><p id="f7b064b46c7f5e5145d73cd94574a05e" class="ne-p" style="text-align: left"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1620302765118-f27235d1-7167-40ae-ab80-dc23494d55cc.png" width="512.5" id="fbgNz" class="ne-image"></p><h2 id="sowJA"><span class="ne-text">DFS遍历算法</span></h2><p id="u4362d8eb" class="ne-p" style="text-align: center"><strong><span class="ne-text" style="color: #E8323C">DFS遍历分三种情况：先序、中序、后序</span></strong></p><div data-type="info" class="ne-alert"><p id="u95df2ce2" class="ne-p"><span class="ne-text" style="background-color: #E8F7FF">把一颗树遍历完，有下面三种方法：</span></p><ul class="ne-ul"><li id="uc9ff0cc0"><strong><span class="ne-text" style="background-color: #E8F7FF">波兰</span></strong><span class="ne-text" style="background-color: #E8F7FF">表达式 -&gt; </span><strong><span class="ne-text" style="background-color: #E8F7FF"> 先序</span></strong><span class="ne-text" style="background-color: #E8F7FF">遍历二叉树</span></li><li id="uc43055cb"><strong><span class="ne-text" style="background-color: #E8F7FF">中缀</span></strong><span class="ne-text" style="background-color: #E8F7FF">表达式 -&gt; </span><strong><span class="ne-text" style="background-color: #E8F7FF">中序</span></strong><span class="ne-text" style="background-color: #E8F7FF">遍历二叉树</span></li><li id="udba25db2"><strong><span class="ne-text" style="background-color: #E8F7FF">逆波兰</span></strong><span class="ne-text" style="background-color: #E8F7FF">表达式 -&gt;</span><strong><span class="ne-text" style="background-color: #E8F7FF"> 后序</span></strong><span class="ne-text" style="background-color: #E8F7FF">遍历二叉树</span></li></ul></div><p id="u92cfd7ea" class="ne-p"><br></p><p id="u22ea8840" class="ne-p" style="text-align: left"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1620298049502-63346474-7a61-45cf-88a8-56c66954d894.png" width="385.5" id="WLPKa" class="ne-image"></p><h3 id="Huygi"><span class="ne-text">手写例子</span></h3><p id="u4849dcc2" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1620298098593-6760a592-4907-4662-a4be-404dde35d246.png" width="295" id="zsvnG" class="ne-image"></p><p id="ueab83a04" class="ne-p" style="text-align: left"><br></p><p id="ue7256163" class="ne-p" style="text-align: left"><span class="ne-text">各种遍历结果</span></p><ul class="ne-ul"><li id="ua1c0307d" style="text-align: left"><span class="ne-text">先序：-+a*b-cd/ef</span></li><li id="uf0007730" style="text-align: left"><span class="ne-text">中序：a+b*c-d-e/f</span></li><li id="u16808acb" style="text-align: left"><span class="ne-text">后序：abcd-*+ef/-</span></li></ul><p id="6a565f3d23b6283c08540b7cf1afa97e" class="ne-p" style="text-align: left"><br></p><h3 id="ZLoiv"><span class="ne-text">前序遍历</span></h3><ul class="ne-ul"><li id="u945a3d19"><a href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/" data-href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/" class="ne-link"><span class="ne-text">144. 二叉树的前序遍历</span></a></li></ul><pre><code>/** * Definition for a binary tree node. * function TreeNode(val, left, right) &#123; *     this.val = (val===undefined ? 0 : val) *     this.left = (left===undefined ? null : left) *     this.right = (right===undefined ? null : right) * &#125; *//** * @param &#123;TreeNode&#125; root * @return &#123;number[]&#125; */var preorderTraversal = function(root) &#123;    let result = []    let preorder = data =&gt; &#123;        if (data) &#123;            result.push(data.val)            preorder(data.left)            preorder(data.right)        &#125;    &#125;    preorder(root)    return result&#125;;</code></pre><h3 id="v6dYp"><span class="ne-text">中序遍历</span></h3><ul class="ne-ul"><li id="ua597b26d"><a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/" data-href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/" class="ne-link"><span class="ne-text">94. 二叉树的中序遍历</span></a></li></ul><pre><code>/** * Definition for a binary tree node. * function TreeNode(val, left, right) &#123; *     this.val = (val===undefined ? 0 : val) *     this.left = (left===undefined ? null : left) *     this.right = (right===undefined ? null : right) * &#125; *//** * @param &#123;TreeNode&#125; root * @return &#123;number[]&#125; */var inorderTraversal = function(root) &#123;    let result = []    let inorder = data =&gt; &#123;        if (data) &#123;            inorder(data.left)            result.push(data.val)            inorder(data.right)        &#125;    &#125;    inorder(root)    return result&#125;;</code></pre><h3 id="o6HJu"><span class="ne-text">后序遍历</span></h3><ul class="ne-ul"><li id="u9bf35e9b"><a href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/" data-href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/" class="ne-link"><span class="ne-text">145. 二叉树的后序遍历</span></a></li></ul><pre><code>/** * Definition for a binary tree node. * function TreeNode(val, left, right) &#123; *     this.val = (val===undefined ? 0 : val) *     this.left = (left===undefined ? null : left) *     this.right = (right===undefined ? null : right) * &#125; *//** * @param &#123;TreeNode&#125; root * @return &#123;number[]&#125; */var postorderTraversal = function(root) &#123;    let result = []    let postorder = data =&gt; &#123;        if (data) &#123;            postorder(data.left)            postorder(data.right)            result.push(data.val)        &#125;    &#125;    postorder(root)    return result&#125;;</code></pre></div>]]></content>
      
      
      <categories>
          
          <category> 计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 🌲树结构：二叉树-哈夫曼树 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>实验5——波兰/逆波兰表达式求值🔖栈</title>
      <link href="/blog/iyb7wi/"/>
      <url>/blog/iyb7wi/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="9e860144325b87da71afc87eefe2d77a" class="ne-p"><br></p><h2 id="9vFrj"><span class="ne-text">实验报告</span></h2><p id="f79ae7dddc05f05b1fe9f31553cdf695" class="ne-p"><span class="ne-text">实验五：实现用波兰表达式（先序）和逆波兰表达式（后序）求算术表达式的值</span></p><p id="4a9b70f09095db07a51166c993864aa5" class="ne-p"><span class="ne-text">要求：仅用一个栈实现（并且用原生单链表实现）</span></p><p id="0073cffd2d82424ee08e442fde183209" class="ne-p"><span class="ne-text">测试用例：4+2*3-10/5</span></p><p id="1015932deb14ce9808f762815a09e7c9" class="ne-p"><span class="ne-text">交作业时间：5月14日</span></p><h2 id="95f63ce98656d59fcee6f1cad6c4ae42"><span class="ne-text">思路</span></h2><p id="03a71edb0ce041bb880fac7483d51a8d" class="ne-p"><span class="ne-text">两个步骤：</span></p><ol class="ne-ol"><li id="127832819ea0b8b0383119803531e321"><strong><span class="ne-text">将给定的表达式转换为波兰表达式/逆波兰表达式</span></strong></li><li id="bbeddc496c9bbaa01590501e70c3593d"><strong><span class="ne-text">对转换后的式子进行计算</span></strong></li></ol><p id="75aa0ca11c1c45c1e80b31c018656ccc" class="ne-p"><br></p><p id="544e05aece3b557af8c08d44fe4340cf" class="ne-p"><span class="ne-text">学习遍历二叉树，利用前序/中序/后序表达式的时候，经常有一个问题就是：</span></p><p id="9fda6508e74029858e9a77d75c366090" class="ne-p"><br></p><ul class="ne-tl"><li checked="true" id="dff42916b2274e13af7620f3be09f8f4"><span class="ne-text">给出中缀表达式，【写出&amp;&amp;编程出】</span><span class="ne-text">后序（逆波兰）表达式</span></li></ul><p id="1cc028e11883abbffc825eedbee0a6d1" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1620306330357-a83abeff-56a3-44f1-b837-82051f46e3b5.png" width="237" id="ZAX5A" class="ne-image"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1620306352380-f6eef790-b72d-4e1d-9da1-6597ec5ae11d.png" width="294" id="zESCQ" class="ne-image"></p><p id="4ac0025b3ca7f49b653537cf8d999dca" class="ne-p"><span class="ne-text">上面的是课堂上在纸上的书写，那么如何将其用编程语言实现呢？思路应该是这样的：</span></p><ul class="ne-ul"><li id="f3e9b0538142d63fb0dddee70782998a"><span class="ne-text">遍历表达式：对遍历的元素进行判断</span></li><li id="16cdfca79195b1e48ee8fb8da2f93a3f"><span class="ne-text">是运算符？操作数？还是括号呢？对其相应的判断</span></li></ul><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="536967d5477dce93aae2af4844744c6a"><span class="ne-text">操作数</span></li><li id="f742c335bbfeceb701f45f6da5359fda"><span class="ne-text">运算符：+-*/</span></li><li id="37bf504cf25ab5a1e31c553ebfe1f88e"><span class="ne-text">括号</span></li></ul></ul><ul class="ne-tl"><li checked="true" id="5a8cbdcf9cfe9df1a63ee1b6026b78d7"><span class="ne-text">个位数/双位数……的字符处理</span></li></ul><p id="59a438bb0fbcce4204dcef4b54e34c97" class="ne-p"><br></p><ul class="ne-tl"><li checked="true" id="03c0087d691f6334d867ef61684852de"><span class="ne-text">给出中缀表达式，【</span><span class="ne-text">写出&amp;&amp;编程出】</span><span class="ne-text">前序（波兰）表达式</span></li></ul><p id="0f94194b7fb7b6193beba54f8228ffa2" class="ne-p"><span class="ne-text">如果写出了逆波兰表达式，转换为波兰表达式只需要将</span><code class="ne-code"><span class="ne-text">（</span></code><span class="ne-text">变为</span><code class="ne-code"><span class="ne-text">）</span></code><span class="ne-text">，同时遍历从后往前遍历即可</span></p><p id="fb58b92c1fc00f9bcd46cc62d1ec7c6e" class="ne-p"><br></p><p id="7eb7f2863604df250b519a0432fe9e65" class="ne-p"><span class="ne-text">最后的结果逆置</span></p><ul class="ne-tl"><li checked="true" id="cb3454de2df57954ef838a0995e12ebc"><span class="ne-text">最后的计算，波兰和逆波兰不能写成一个函数，因为减数和被减数，除数和被除数的缘故</span></li></ul><h2 id="IjDi9"><span class="ne-text">实验代码</span></h2><p id="394b25ed4cb75f5498127a399da3cfeb" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1620979662957-690a9050-8a82-4170-816b-ffcff99f38d7.png" width="500" id="Kzxk3" class="ne-image"></p><p id="0e973006837549c019ba002da970c410" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1620979669021-d90e4ff6-feb6-4df9-9f6a-d7176b25d258.png" width="446" id="XDVSW" class="ne-image"></p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;<p>/**</p><ul><li>波兰表达式/逆波兰表达式求解运算表达式</li><li></li><li>/</li></ul><p>/**</p><ul><li>单链表的存储结构</li><li>/<br>typedef struct LNode &#123;<br>  string data; //数据域<br>  struct LNode *next; //指针域<br>&#125;Lnode, *LinkList; //LinkList为指向结构体LNode的指针类型</li></ul><p>/* 初始化链表 */<br>void InitList(LinkList &amp;L) &#123;<br>    L = new LNode;<br>    L-&gt;next = NULL;<br>&#125;</p><p>/* 打印 */<br>void TraverseList(LinkList &amp; L)&#123;<br>        LNode *p = new LNode;<br>        p = L-&gt;next;<br>        // cout &lt;&lt; &quot;此中缀表达式链表打印的结果为：&quot;;<br>        while (p != NULL)<br>        &#123;<br>            cout &lt;&lt; p-&gt;data;<br>            p = p-&gt;next;<br>        &#125;<br>        cout &lt;&lt; &quot;\n&quot;;<br>&#125;</p><p>/* 逆置 */<br>void ReverseList(LinkList &amp;L) &#123;<br>    LNode *p = L-&gt;next;<br>    L-&gt;next = NULL;<br>    while(p)<br>    &#123;<br>        LNode *q = p-&gt;next;<br>        p-&gt;next = L-&gt;next;<br>        L-&gt;next = p;<br>        p = q;<br>    &#125;<br>&#125;</p><p>/**</p><ul><li>初始化用户输入的链表</li><li>/<br>void Center(LinkList &amp;L,string s) &#123;<br>  InitList(L);<br>  LinkList p = L;<br>  string temp = &quot;&quot;;<br>  for (int i = 0; i &lt; s.length();i++)&#123;<pre><code>  // 处理双位数字情况  if (isdigit(s[i])) &#123;      // 该字符为数字      temp = temp + s[i];      if (!isdigit(s[i+1])) &#123;          // 下一个不是数字，而是字符，将temp后插          LinkList node = new LNode;          node-&amp;gt;data = temp;          node-&amp;gt;next = NULL;          p-&amp;gt;next = node;          p = node;          // 将temp重置          temp = &amp;quot;&amp;quot;;          continue;      &#125;      continue;  &#125;  // 后插到L尾巴上  LinkList node = new LNode;  node-&amp;gt;data = s[i];  node-&amp;gt;next = NULL;  p-&amp;gt;next = node;  p = node;</code></pre>  }<br>}</li></ul><p>/**</p><ul><li><p>将表达式转换为波兰表达式/逆波兰表达式</p></li><li><p>第二个参数对逆波兰而言是左括号，第三个参数对逆波兰而言是右括号</p></li><li><p>对波兰而言反过来</p></li><li><p>/<br>void Transition(LinkList &amp;L, string l, string r){<br>  // 定义一个栈用来处理<br>  stack&lt;string&gt; stack;<br>  LinkList p = L-&gt;next;<br>  LinkList result = new LNode;<br>  InitList(result);<br>  LinkList result_a = result;</p><p>  while(p != NULL) {</p><pre><code>  if (p-&amp;gt;data == l) &#123;      stack.push(p-&amp;gt;data);  &#125; else if(p-&amp;gt;data == r) &#123;      while(stack.top() != l)&#123;          LinkList temp = new LNode;          temp-&amp;gt;data = stack.top();          temp-&amp;gt;next = NULL;          result_a-&amp;gt;next = temp;          result_a = temp;          stack.pop();      &#125;      if (stack.top() == l)&#123;          stack.pop();      &#125;  &#125; else if(p-&amp;gt;data == &amp;quot;+&amp;quot; || p-&amp;gt;data == &amp;quot;-&amp;quot;) &#123;      if (stack.size() != 0) &#123;          if (stack.top() == &amp;quot;*&amp;quot; || stack.top() == &amp;quot;/&amp;quot;)&#123;              for (int i = 0; i &amp;lt; stack.size();i++) &#123;                  if (stack.top() == l) &#123;                      break;                  &#125;                  LinkList temp = new LNode;                  temp-&amp;gt;data = stack.top();                  temp-&amp;gt;next = NULL;                  result_a-&amp;gt;next = temp;                  result_a = temp;                  stack.pop();              &#125;          &#125;      &#125;      stack.push(p-&amp;gt;data);  &#125; else if(p-&amp;gt;data == &amp;quot;*&amp;quot; || p-&amp;gt;data == &amp;quot;/&amp;quot;) &#123;      stack.push(p-&amp;gt;data);  &#125; else &#123;      LinkList temp = new LNode;      temp-&amp;gt;data = p-&amp;gt;data;      temp-&amp;gt;next = NULL;      result_a-&amp;gt;next = temp;      result_a = temp;  &#125;  p = p-&amp;gt;next;</code></pre><p>  }<br>  // TraverseList(result);<br>  for (int i = 0; i &lt; stack.size();i++) {</p><pre><code>  LinkList temp = new LNode;  temp-&amp;gt;data = stack.top();  temp-&amp;gt;next = NULL;  result_a-&amp;gt;next = temp;  result_a = temp;  stack.pop();</code></pre><p>  }<br>  // 上一个操作总是不能清空栈的最后一个元素<br>  LinkList temp = new LNode;<br>  temp-&gt;data = stack.top();<br>  temp-&gt;next = NULL;<br>  result_a-&gt;next = temp;<br>  result_a = temp;<br>  stack.pop();</p><p>  L = result;<br>}</p></li></ul><p>/**</p><ul><li>计算</li><li>/</li></ul><p>void EvaulTree(LinkList &amp;L) {<br>    // 定义一个栈用来处理<br>    stack&lt;string&gt; stack;<br>    LinkList p = L-&gt;next;<br>    while(p != NULL) {<br>        if (p-&gt;data == &quot;+&quot;){<br>            int x = stoi(stack.top());<br>            stack.pop();<br>            int y = stoi(stack.top());<br>            stack.pop();<br>            stack.push(to_string(y + x));<br>        } else if(p-&gt;data == &quot;-&quot;) {<br>            int x = stoi(stack.top());<br>            stack.pop();<br>            int y = stoi(stack.top());<br>            stack.pop();<br>            stack.push(to_string(y - x));<br>        } else if(p-&gt;data == &quot;*&quot;) {<br>            int x = stoi(stack.top());<br>            stack.pop();<br>            int y = stoi(stack.top());<br>            stack.pop();<br>            stack.push(to_string(y * x));<br>        } else if(p-&gt;data == &quot;/&quot;) {<br>            int x = stoi(stack.top());<br>            stack.pop();<br>            int y = stoi(stack.top());<br>            stack.pop();<br>            stack.push(to_string(y / x));<br>        } else {<br>            stack.push(p-&gt;data);<br>        }<br>        p = p-&gt;next;<br>    }<br>    while (!stack.empty()){<br>        cout &lt;&lt; stoi(stack.top());<br>        stack.pop();<br>    }<br>}</p><p>void EvaulTree_polish(LinkList &amp;L) {<br>    // 定义一个栈用来处理<br>    stack&lt;string&gt; stack;<br>    LinkList p = L-&gt;next;<br>    while(p != NULL) {<br>        if (p-&gt;data == &quot;+&quot;){<br>            int x = stoi(stack.top());<br>            stack.pop();<br>            int y = stoi(stack.top());<br>            stack.pop();<br>            stack.push(to_string(x + y));<br>        } else if(p-&gt;data == &quot;-&quot;) {<br>            int x = stoi(stack.top());<br>            stack.pop();<br>            int y = stoi(stack.top());<br>            stack.pop();<br>            stack.push(to_string(x - y));<br>        } else if(p-&gt;data == &quot;*&quot;) {<br>            int x = stoi(stack.top());<br>            stack.pop();<br>            int y = stoi(stack.top());<br>            stack.pop();<br>            stack.push(to_string(x * y));<br>        } else if(p-&gt;data == &quot;/&quot;) {<br>            int x = stoi(stack.top());<br>            stack.pop();<br>            int y = stoi(stack.top());<br>            stack.pop();<br>            stack.push(to_string(x / y));<br>        } else {<br>            stack.push(p-&gt;data);<br>        }<br>        p = p-&gt;next;<br>    }<br>    while (!stack.empty()){<br>        cout &lt;&lt; stoi(stack.top());<br>        stack.pop();<br>    }<br>}</p><p>int main () {<br>    cout &lt;&lt; &quot;————————————&quot;&lt;&lt;&quot;\n&quot;;<br>    string s;<br>    cout &lt;&lt; &quot;请输入运算表达式：&quot;&lt;&lt;&quot;\n&quot;;<br>    cin &gt;&gt; s;<br>    LinkList test_reversepolish = new LNode;<br>    InitList(test_reversepolish);<br>    LinkList test_polish = new LNode;<br>    InitList(test_polish);</p><pre><code>Center(test_reversepolish, s);Center(test_polish, s);cout &amp;lt;&amp;lt; &amp;quot;------------------------------------&amp;quot;&amp;lt;&amp;lt;&amp;quot;\n&amp;quot;;// 波兰表达式ReverseList(test_polish);Transition(test_polish, &amp;quot;)&amp;quot;, &amp;quot;(&amp;quot;);cout &amp;lt;&amp;lt; &amp;quot;波兰表达式为：&amp;quot;;ReverseList(test_polish);TraverseList(test_polish);cout &amp;lt;&amp;lt; &amp;quot;波兰表达式计算结果为：&amp;quot;;ReverseList(test_polish);EvaulTree_polish(test_polish);cout &amp;lt;&amp;lt; &amp;quot;\n&amp;quot;&amp;lt;&amp;lt;&amp;quot;------------------------------------&amp;quot;&amp;lt;&amp;lt;&amp;quot;\n&amp;quot;;// 逆波兰表达式Transition(test_reversepolish, &amp;quot;(&amp;quot;, &amp;quot;)&amp;quot;);cout &amp;lt;&amp;lt; &amp;quot;逆波兰表达式为：&amp;quot;;TraverseList(test_reversepolish);cout &amp;lt;&amp;lt; &amp;quot;逆波兰表达式计算结果为：&amp;quot;;EvaulTree(test_reversepolish);cout &amp;lt;&amp;lt; &amp;quot;\n&amp;quot;&amp;lt;&amp;lt;&amp;quot;------------------------------------&amp;quot;&amp;lt;&amp;lt;&amp;quot;\n&amp;quot;;</code></pre><p>}<br></code></pre></p></div>]]></content>
      
      
      <categories>
          
          <category> 计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> Problems </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>BF和KMP模式匹配算法</title>
      <link href="/blog/ah7arw/"/>
      <url>/blog/ah7arw/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="bbef41e6cf359255bbde71a85dc43898" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1620290726560-b77d1aa1-b7ed-4561-95b4-0e8f7e643ca9.png" width="361.5" id="Q9tj2" class="ne-image"></p><p id="c907579b64684dfce48f3205154333a3" class="ne-p"><br></p><div data-type="info" class="ne-alert"><p id="2d18b8a0f458f4ecf10e7bd1f860780f" class="ne-p"><span class="ne-text" style="background-color: #E8F7FF">在进行字符串匹配的相关程序中，看一个子串是否在一个主串里面，有著名的Brute-Force和基于此改进的KMP算法，具体学习记录如下：</span></p></div><h2 id="Ffqh8"><span class="ne-text">Brute-Force</span></h2><div class="ne-quote"><p id="8ad2578b424968bc6bd4f2ed0e0f65af" class="ne-p"><span class="ne-text">给出一个主串和一个子串</span></p><p id="8a36746aaf9610184b750791b5965c6b" class="ne-p"><span class="ne-text">主串：s = ababc</span><strong><span class="ne-text">abcac</span></strong><span class="ne-text">bab</span></p><p id="9d4d068fe6d44771c021c63e175b098e" class="ne-p"><span class="ne-text" style="background-color: transparent">子串：t = abcac</span></p></div><p id="b2dd074081afd9c9b47ccd7b9143e880" class="ne-p"><span class="ne-text">①BF算法算是一种暴力算法，首先是查看t的第一字母a和上面s的第一个字母比较相同，所以接着比较比到各自的第三个字符也就是，aba、abc发现不同，</span></p><p id="e35adca9e0bc3093c9d5f32e26b61bed" class="ne-p"><br></p><p id="131d9605c2eda9766ec9f323ff2dc55c" class="ne-p"><span class="ne-text">②再递推比较，t回到第一个字母a，这时s回到第二个字符（因为第一个字符已经比过了）相当于</span><span class="ne-text">babcabcacbab和abcac两个字符串进行比较，很明显第一个字符就不一样，</span></p><p id="edbbad2ce92acabab926dfe05a89c053" class="ne-p"><br></p><p id="d9d2e440fb580c81dfee4ebb1d516d52" class="ne-p"><span class="ne-text">③再递推比较……</span></p><p id="70fa395bcedb3156c06b512ee7064afb" class="ne-p"><br></p><p id="c94c3d9622e6711a795a02dd95dfbed1" class="ne-p"><span class="ne-text">按常理来思考，这样总能得出结果，但是在此基础上，可以有进一步的优化操作，怎么说？</span><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1617677082076-945e1a85-4b75-40ad-a413-46f7e514b7f4.jpeg" width="55" id="xbp9q" class="ne-image"></p><p id="0f257d56637c7793a108f18b7ed01bc8" class="ne-p"><span class="ne-text">在上面的第②步里面，我们总是一步一步递推，那我们能不能一次性推好几步呢？就根据已经匹配了的那串字母。</span></p><p id="ed3b2f764966d419e64c220dd62e5cc9" class="ne-p"><br></p><p id="d90f5843ceba354fcb6794586b242373" class="ne-p"><span class="ne-text">具体表现为：①已经发现是第三个字符不同，那我们就根据前面两个相同的字符（ab）推出第②步推两步，为什么根据相同的ab，第②个步骤就可以一次性走两步？</span></p><h2 id="oEgiu"><span class="ne-text">KMP算法</span></h2><h3 id="wGOpN"><span class="ne-text">算法详述</span></h3><p id="bbd5d8a2fc71893bd94dc1ffb47a3523" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1617677082076-945e1a85-4b75-40ad-a413-46f7e514b7f4.jpeg" width="55" id="tAJ2v" class="ne-image"><span class="ne-text">先学会用，理论日后再补…… 🕊</span></p><p id="8b014eafa0ce22db1682a80cc7459e40" class="ne-p"><span class="ne-text"></span></p><p id="05966fbe8ad009c95ad9f1520ce6f98c" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1620286656388-6b7c4ae0-8c01-4ae5-9451-9d17c63a23bb.png" width="362.5" id="t1z49" class="ne-image"></p><h3 id="3gIJ6"><span class="ne-text">计算next函数值</span></h3><div class="ne-quote"><p id="c45f9f063f5d4748f12a7b453abb0aa1" class="ne-p"><span class="ne-text">（3）串“ababaaababaa”的next数组为（  ）。</span></p><p id="e026a63024d856bb636b5dc3e91145c8" class="ne-p"><span class="ne-text">A．012345678999   B．012121111212   C．011234223456    D．0123012322345</span></p><p id="05cb2f2e114ba30bf170a09d1f5ab3d6" class="ne-p"><span class="ne-text">答案：C</span></p></div><p id="28778f634e9aa96ca56b29417b3a5d2a" class="ne-p"><br></p><table id="WQyby" class="ne-table" style="width: 623px"><tbody><tr style="height: 33px"><td width="75"><p id="9be41bd898970beaef453015a11fc209_p_0" class="ne-p"><span class="ne-text">j</span></p></td><td width="41"><p id="f5288918051daac58a0cdf74b1d666a8_p_0" class="ne-p"><span class="ne-text">1</span></p></td><td width="47"><p id="2437cac6ad8f03448ae403be9a3af9ed_p_0" class="ne-p"><span class="ne-text">2</span></p></td><td width="41"><p id="51d6cd746c79a513e0ce3a75ec25e3f9_p_0" class="ne-p"><span class="ne-text">3</span></p></td><td width="47"><p id="c5dca1e0e58592b0de68a15917b9aac6_p_0" class="ne-p"><span class="ne-text">4</span></p></td><td width="48"><p id="e93c6396b478003add85a5ab1354e564_p_0" class="ne-p"><span class="ne-text">5</span></p></td><td width="44"><p id="4e0a00f0fff2d08f625bcf3627cf94db_p_0" class="ne-p"><span class="ne-text">6</span></p></td><td width="50"><p id="ae427e384184b1214e0bf3f7df0a833e_p_0" class="ne-p"><span class="ne-text">7</span></p></td><td width="50"><p id="2a7b14533ca92e6ddd576c36969708ce_p_0" class="ne-p"><span class="ne-text">8</span></p></td><td width="45"><p id="af98e36da6caf2103235814d586bea93_p_0" class="ne-p"><span class="ne-text">9</span></p></td><td width="45" style="background-color: #FFFFFF"><p id="a20d224c568e48b9d67847a2c66a8c01_p_0" class="ne-p"><span class="ne-text">10</span></p></td><td width="45" style="background-color: #FFFFFF"><p id="u19987c0e" class="ne-p"><span class="ne-text">11</span></p></td><td width="45" style="background-color: #FFFFFF"><p id="ube4b3363" class="ne-p"><span class="ne-text">12</span></p></td></tr><tr style="height: 33px"><td width="75"><p id="a542bd2757409de9dfb7727ebcaf31c5_p_0" class="ne-p"><span class="ne-text">t</span></p></td><td width="41"><p id="08ca20eb36284487001463292f6550f4_p_0" class="ne-p"><span class="ne-text">a</span></p></td><td width="47"><p id="8d5efedb4fdbe061cc194fc98f15df26_p_0" class="ne-p"><span class="ne-text">b</span></p></td><td width="41"><p id="u4ba171c0" class="ne-p"><span class="ne-text">a</span></p></td><td width="47"><p id="uad8517ea" class="ne-p"><span class="ne-text">b</span></p></td><td width="48"><p id="u4fc6d17a" class="ne-p"><span class="ne-text">a</span></p></td><td width="44"><p id="u3a396665" class="ne-p"><span class="ne-text">a</span></p></td><td width="50"><p id="uea5ab139" class="ne-p"><span class="ne-text">a</span></p></td><td width="50"><p id="uf43da0d5" class="ne-p"><span class="ne-text">b</span></p></td><td width="45"><p id="u15a07baf" class="ne-p"><span class="ne-text">a</span></p></td><td width="45" style="background-color: #FFFFFF"><p id="ue0fede51" class="ne-p"><span class="ne-text">b</span></p></td><td width="45" style="background-color: #FFFFFF"><p id="u925438c3" class="ne-p"><span class="ne-text">a</span></p></td><td width="45" style="background-color: #FFFFFF"><p id="u3bc3bb00" class="ne-p"><span class="ne-text">a</span></p></td></tr><tr style="height: 33px"><td width="75"><p id="fc06ea377ed3bb2f227b8d21f4771bce_p_0" class="ne-p"><span class="ne-text">next(j)</span></p></td><td width="41"><p id="515141c761d1a2676477bcc490f86bc4_p_0" class="ne-p"><span class="ne-text">0</span></p></td><td width="47"><p id="uf33c1bad" class="ne-p"><span class="ne-text">1</span></p></td><td width="41"><p id="u6cc7fec3" class="ne-p"><span class="ne-text">1</span></p></td><td width="47"><p id="u906cf0a9" class="ne-p"><span class="ne-text">2</span></p></td><td width="48"><p id="ud7d51835" class="ne-p"><span class="ne-text">3</span></p></td><td width="44"><p id="u1ac6d524" class="ne-p"><span class="ne-text">4</span></p></td><td width="50"><p id="uf064b958" class="ne-p"><span class="ne-text">2</span></p></td><td width="50"><p id="u20960527" class="ne-p"><span class="ne-text">2</span></p></td><td width="45"><p id="u82b4e795" class="ne-p"><span class="ne-text">3</span></p></td><td width="45" style="background-color: #FFFFFF"><p id="udb52cb3c" class="ne-p"><span class="ne-text">4</span></p></td><td width="45" style="background-color: #FFFFFF"><p id="u5ec269a0" class="ne-p"><span class="ne-text">5</span></p></td><td width="45" style="background-color: #FFFFFF"><p id="u85d1d3ab" class="ne-p"><span class="ne-text">6</span></p></td></tr></tbody></table><p id="ede4828120a719212ee5f1d7947d6c20" class="ne-p"><br></p><p id="4de55acebb3d510651128eca5999d7f1" class="ne-p"><span class="ne-text">方法：</span></p><p id="ab27975aadd906abf25ea1dbd2125eb0" class="ne-p"><span class="ne-text">①next数组第一位永远是0，1；</span></p><p id="cfb93f39fdd200be46ebfeada7a0a690" class="ne-p"><span class="ne-text">②next(j) = 前序列相同元素个数 + 1；</span></p><p id="6df74f3284fc578a55db44c9c9f9d254" class="ne-p"><br></p><p id="fa5ee3ccca7aac454647436aa6cf105d" class="ne-p"><span class="ne-text">eg：当t = 6：</span></p><p id="9864edcb5890059cbb029dbc654018de" class="ne-p"><span class="ne-text">前面的序列为ababa，可以看出相同的子序列为aba，相同元素个数为3，所以next(6) = 3 + 1 = 4</span></p><p id="cf8a5f56ac58875441ad5b78ef1d2b3b" class="ne-p"><br></p><p id="c47cb9d84cbe7f19c89783788434f82b" class="ne-p"><span class="ne-text">注意：不能“全覆盖”，比如当j = 2时候，前面的a不能看成a = a序列，这样就变成next(2) = 2了；</span></p><h3 id="Lal6X"><span class="ne-text">计算next函数修正值</span></h3><div class="ne-quote"><p id="82c60e34e8efe5d73792a25711b26d07" class="ne-p"><span class="ne-text">（4）串“ababaabab”的nextval为（  ）。</span></p><p id="0d1e20f00ec873da884183137c074223" class="ne-p"><span class="ne-text">A．010104101      B．010102101      C．010100011       D．010101011  </span></p><p id="86fd109cdad34ea14d6272183b3be0c5" class="ne-p"><span class="ne-text">答案：A</span></p></div><p id="32422b3ed1271a846e5e6fb91bfc5c8c" class="ne-p"><br></p><table id="iFRJu" class="ne-table" style="width: 685px"><tbody><tr style="height: 33px"><td width="91"><p id="u0503555c" class="ne-p"><span class="ne-text">j</span></p></td><td width="58"><p id="uaffdd452" class="ne-p"><span class="ne-text">1</span></p></td><td width="67"><p id="u948458ea" class="ne-p"><span class="ne-text">2</span></p></td><td width="67"><p id="ua15993c3" class="ne-p"><span class="ne-text">3</span></p></td><td width="67"><p id="u6fe61ea3" class="ne-p"><span class="ne-text">4</span></p></td><td width="67"><p id="ubb150015" class="ne-p"><span class="ne-text">5</span></p></td><td width="67"><p id="u4fe2041a" class="ne-p"><span class="ne-text">6</span></p></td><td width="67"><p id="u22de8214" class="ne-p"><span class="ne-text">7</span></p></td><td width="67"><p id="ue55b58a5" class="ne-p"><span class="ne-text">8</span></p></td><td width="67"><p id="ua381e01f" class="ne-p"><span class="ne-text">9</span></p></td></tr><tr style="height: 33px"><td width="91"><p id="ue40b085e" class="ne-p"><span class="ne-text">t</span></p></td><td width="58"><p id="ub14b7f38" class="ne-p"><span class="ne-text">a</span></p></td><td width="67"><p id="uf8d77d0a" class="ne-p"><span class="ne-text">b</span></p></td><td width="67"><p id="u5d6d9d21" class="ne-p"><span class="ne-text">a</span></p></td><td width="67"><p id="u8f3c9d6c" class="ne-p"><span class="ne-text">b</span></p></td><td width="67"><p id="ub23d82fe" class="ne-p"><span class="ne-text">a</span></p></td><td width="67"><p id="u84ef0982" class="ne-p"><span class="ne-text">a</span></p></td><td width="67"><p id="u71711152" class="ne-p"><span class="ne-text">b</span></p></td><td width="67"><p id="uabbd99d3" class="ne-p"><span class="ne-text">a</span></p></td><td width="67"><p id="ufdaa6f7c" class="ne-p"><span class="ne-text">b</span></p></td></tr><tr style="height: 33px"><td width="91"><p id="ue4f46a92" class="ne-p"><span class="ne-text">next(j)</span></p></td><td width="58"><p id="u0d72915c" class="ne-p"><span class="ne-text">0</span></p></td><td width="67"><p id="ua6e5fb83" class="ne-p"><span class="ne-text">1</span></p></td><td width="67"><p id="ub71e39c2" class="ne-p"><span class="ne-text">1</span></p></td><td width="67"><p id="u18bd8601" class="ne-p"><span class="ne-text">2</span></p></td><td width="67"><p id="uf56335fe" class="ne-p"><span class="ne-text">3</span></p></td><td width="67"><p id="u6c9e9845" class="ne-p"><span class="ne-text">4</span></p></td><td width="67"><p id="u84ac07b9" class="ne-p"><span class="ne-text">2</span></p></td><td width="67"><p id="u197bad17" class="ne-p"><span class="ne-text">3</span></p></td><td width="67"><p id="u3050e6c5" class="ne-p"><span class="ne-text">4</span></p></td></tr><tr style="height: 33px"><td width="91"><p id="ud1bcfa0a" class="ne-p"><span class="ne-text">nextval(j)</span></p></td><td width="58"><p id="u2935a6d0" class="ne-p"><span class="ne-text">0</span></p></td><td width="67"><p id="uca5f7fff" class="ne-p"><span class="ne-text">1</span></p></td><td width="67"><p id="u8033274d" class="ne-p"><span class="ne-text">0</span></p></td><td width="67"><p id="u4018b298" class="ne-p"><span class="ne-text">1</span></p></td><td width="67"><p id="ufda5b86c" class="ne-p"><span class="ne-text">0</span></p></td><td width="67"><p id="u623694a6" class="ne-p"><span class="ne-text">4</span></p></td><td width="67"><p id="u07718737" class="ne-p"><span class="ne-text">1</span></p></td><td width="67"><p id="u24391151" class="ne-p"><span class="ne-text">0</span></p></td><td width="67"><p id="u320bd3a3" class="ne-p"><span class="ne-text">1</span></p></td></tr></tbody></table><p id="43418445725a8b1c9da02be97acc6eb0" class="ne-p"><br></p><p id="3e55a0781e7099dd7009a0f7d481b0c6" class="ne-p"><span class="ne-text">方法：</span></p><p id="2faf3d9586a9b0d8c5486e592d62e0f1" class="ne-p"><span class="ne-text">①先列举出next(j)，求nextval(j)是基于</span><span class="ne-text">next(j)的；</span></p><p id="ab7e86d247d92acbbf32773beaab474e" class="ne-p"><span class="ne-text">②</span><span class="ne-text">求nextval(j)，先看</span><span class="ne-text">求next(j)的值，记这个值为x；</span></p><p id="165ea6e5343f9d430222164c5bcf2f5f" class="ne-p"><span class="ne-text">③在表格中找出j = x的那一列，如果这一列的t值和②步骤中的t值相同，则结果为j = x这一列的</span><span class="ne-text">nextval(j)值，如果不相同，则结果为所要求的那一列的</span><span class="ne-text">next(j)值；</span></p><p id="3a0744062e0dcb3e16e2d6e3ca799b61" class="ne-p"><br></p><p id="7b1836d799fc31c6d255b45fcd52987d" class="ne-p"><span class="ne-text">eg：当j = 5时：</span></p><p id="5454822d50705ef65ed7c54c9e0d0234" class="ne-p"><span class="ne-text">此时next(j) = 3，就去j = 3那一列看到t = a，和j = 5一列的t值a相同，所以结果为j = 3一列的</span><span class="ne-text">nextval值0</span></p><p id="f88b11c1f0df00493a4fef31c0d174ab" class="ne-p"><br></p><p id="2e9d752cb16fedaf515563cf05ee8149" class="ne-p"><span class="ne-text">eg：当j = 6时：</span></p><p id="18e8aa25864872faa5c446d1bf786d16" class="ne-p"><span class="ne-text">此时next(j) = 4，就去j = 4那一列看到t = b，和j = 6一列的t值不相同，所以结果为j = 6一列的</span><span class="ne-text">next值4</span></p><h3 id="Vn5VN"><span class="ne-text">具体匹配情况</span></h3><div class="ne-quote"><p id="2bb2aa0c380cb029f331136f0bf95666" class="ne-p"><span class="ne-text">（2）设目标为t=“abcaabbabcabaacbacba”,模式为p=“abcabaa”</span></p><p id="93f6259891d767ae845e04e48379f217" class="ne-p"><span class="ne-text">① 计算模式p的naxtval函数值；</span></p><p id="52096b14ec8bfa95f285bd5cb9477dc3" class="ne-p"><span class="ne-text">② 不写出算法,只画出利用KMP算法进行模式匹配时每一趟的匹配过程。</span></p></div><p id="3e8c22d46292fd2da5b00fbae2e47a63" class="ne-p"><span class="ne-text">答案：</span></p><p id="004848556f2fb83956150623bee8d144" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1620290726560-b77d1aa1-b7ed-4561-95b4-0e8f7e643ca9.png" width="361.5" id="cwWr7" class="ne-image"></p><h3 id="LGp3i"><span class="ne-text">代码</span></h3><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;typedef int Status;typedef int ElemType;#define OVERFLOW -1#define ERROR 0#define OK 1<p>//——串的顺序存储结构—–<br>#define MAXLEN 225<br>typedef struct<br>&#123;<br>    char ch[MAXLEN + 1];    //存储串的一维数组，从下标为1的数组分量开始存储的，下标为0的分量闲置不用<br>    int length;             //串的当前长度<br>&#125;SString;</p><p>//——串的堆式顺序存储结构—–<br>typedef struct<br>&#123;<br>    char *ch;       //若是非空串，则按串长分配存储区，否则ch为NULL<br>    int length;     //串的当前长度<br>&#125;HString;</p><p>HString S, T;</p><p>//—–串的链式存储结构—–<br>#define CHUNKSIZE 80<br>typedef struct Chunk<br>&#123;<br>    char ch[CHUNKSIZE];<br>    struct Chunk *next;<br>&#125;Chunk;<br>typedef struct<br>&#123;<br>    Chunk *head, *tail;     //串的头指针和尾指针<br>    int length;             //串的当前长度<br>&#125;LString;</p><p>// //1、生成串<br>// StrAssign(&amp;T, chars)</p><p>// //2、复制<br>// StrCopy(&amp;T, S)</p><p>// //3、判空<br>// StrEmpty(S)</p><p>// //4、比较<br>// StrCompare(S, T)</p><p>// //5、长度<br>// StrLength(S)</p><p>// //6、清空<br>// ClearString(&amp;S)</p><p>// //7、联接<br>// Concat(&amp;T, S1, S2)</p><p>// //8、子串<br>// SubString(&amp;Sub, S, pos, len)</p><p>//9、串的模式匹配_BF算法 O(n * m)<br>int Index_BF(HString S, HString T, int pos)<br>&#123;//返回模式T在主串s中第pos个字符开始第一次出现的位置。若不存在，则返回值为0<br> //其中，T非空，1&lt;=pos&lt;=S.length<br>    int i = pos, j = 1;                     //初始化<br>    while(i &lt;= S.length &amp;&amp; j &lt;= T.length)   //两串均未比较到串尾<br>    &#123;<br>        if(S.ch[i] == T.ch[j])              //继续比较后继字符<br>        &#123;<br>            i++;<br>            j++;<br>        &#125;<br>        else                                //指针后退重新开始匹配<br>        &#123;<br>            i = i - j + 2;                  //i=i-j+1回到i的起点，+2到下一个字符<br>            j = 1;<br>        &#125;<br>    &#125;<br>    if(j &gt; T.length)<br>            return i - T.length;            //匹配成功，返回T在S中第一次出现的位置<br>        else<br>            return 0;<br>&#125;</p><p>//9、串的模式匹配_KMP算法求next数组<br>void get_next(HString, int next[])<br>&#123;//求模式串T的next函数值并存入数组next<br>    int j = 1, t = 0;<br>    next[1] = 0;<br>    while(j &lt; T.length)<br>    &#123;<br>        if(t == 0 || T.ch[j] == T.ch[t])<br>        &#123;<br>            t++;<br>            j++;<br>            next[j] = t;<br>        &#125;<br>        else<br>            t = next[t];<br>    &#125;<br>&#125;</p><p>//9、串的模式匹配_KMP算法求nextval数组<br>void get_nextval(HString T, int nextval[])<br>&#123;//求模式串T的next函数修正值并存入数组nextval<br>    int j = 1, t = 0;<br>    nextval[1] = 0;<br>    while(j &lt; T.length)<br>    &#123;<br>        if(t == 0 || T.ch[j] == T.ch[t])<br>        &#123;<br>            t++;<br>            j++;<br>            if(T.ch[j] != T.ch[t])<br>                nextval[j] = t;<br>            else<br>                nextval[j] = nextval[t];<br>        &#125;<br>        else<br>            t = nextval[t];<br>    &#125;<br>&#125;</p><p>//9、串的模式匹配_KMP算法 O(n + m)<br>int Index_KMP(HString S, HString T, int pos, int next[])<br>&#123;//利用模式串T的next函数求T在主串S中第pos个字符之后的位置<br> //其中，T非空，1&lt;=pos&lt;=S.length<br>    int i = pos, j = 1;<br>    while(i &lt;= S.length &amp;&amp; j &lt;= S.length)   //两个串均未比较到串尾<br>    &#123;<br>        if(j == 0 || S.ch[i] == T.ch[i])    //继续比较后继字符<br>        &#123;<br>            i++;<br>            j++;<br>        &#125;<br>        else<br>            j = next[j];                    //模式串向右移动<br>        if(j &gt; T.length)                    //匹配成功<br>            return i - T.length;<br>        else<br>            return 0;<br>    &#125;<br>&#125;</p><p>// //10、插入<br>// Strlnsert(&amp;S, pos, T) </p><p>// //11、删除<br>// StrDelete(&amp;S, pos, len)</p><p>// //12、销毁<br>// DestroyString(&amp;S)</p><p></code></pre></p><p id="da6d9a983e14a866be04369afc52bbe6" class="ne-p"><br></p><p id="4e65f666b11f7a7d080ef5f05ae814ff" class="ne-p"><br></p><p id="5bba2de59a85e9d920e75a24bd65b86e" class="ne-p"><br></p></div>]]></content>
      
      
      <categories>
          
          <category> 计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 🥢KMP类算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>《文城》——我也曾是林详福</title>
      <link href="/essay/ll4lrz/"/>
      <url>/essay/ll4lrz/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="traditional"><div class="ne-quote"><p id="efd2f302b81a26e601cfbd82b34ad478" class="ne-p" style="text-align: left"><span class="ne-text">文城（《活着》作者余华时隔8年，全新长篇重磅归来。关于一个人和他一生的寻找，以及一群人和一个汹涌的年代。他原本不属于这里，但许多人的牵挂和眼泪都留在了他身上） (余华)</span></p></div><p id="a4685e7df874bb285abef683fb9c9c66" class="ne-p" style="text-align: left"><br></p><p id="a20d224c568e48b9d67847a2c66a8c01_p_0" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2021/webp/1484158/1620263368423-1137b0d5-338f-4b67-8710-05113a05e2cf.webp" width="245" id="q1Cav" class="ne-image"></p><p id="u05a7e443" class="ne-p" style="text-align: center"><br></p><div class="ne-quote"><p id="ud1c9376b" class="ne-p"><span class="ne-text">七月三号阅读小记</span></p></div><p id="bd63ffd0b27f153328c726f955c75da8" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1625267396039-fd9ba6e0-3e18-4d2d-abf1-ac129db4ec64.png" width="1128" id="wN6zS" class="ne-image"></p><p id="da68bafe473eff9e0ca481a9669ed16e" class="ne-p"><br></p><p id="1d75b4248ebc31ca1eea816b9feb0063" class="ne-p"><br></p><p id="ua9b8fb9e" class="ne-p"><span class="ne-text"></span></p><p id="u4fea5143" class="ne-p"><span class="ne-text">- 您在位置 #275-277的标注 | 添加于 2021年4月28日星期三 下午2:27:12</span></p><p id="u5cc60fd1" class="ne-p"><br></p><div data-type="info" class="ne-alert"><p id="u53d58b19" class="ne-p"><span class="ne-text">她一边说一边笑，她的眼睛闪闪发亮，这是林祥福第一次见到小美这样的神态。一个在屋子里走动时只有木屐声响的女子，一个不会笑出声音而是将笑意含在嘴角的女子，此刻容光焕发了。</span></p></div><p id="u6596fcd9" class="ne-p"><span class="ne-text"></span></p><p id="u1ae7424c" class="ne-p"><span class="ne-text">- 您在位置 #289-289的标注 | 添加于 2021年4月28日星期三 下午2:29:19</span></p><p id="uf23a8556" class="ne-p"><br></p><div data-type="info" class="ne-alert"><p id="u74e7c20f" class="ne-p"><span class="ne-text">刚才屋顶被砸出的洞口纷纷落下来碗大的雨雹，砸到地上后犹如花开花谢。</span></p></div><p id="u31225aa6" class="ne-p"><span class="ne-text"></span></p><p id="u9ec716d1" class="ne-p"><span class="ne-text">- 您在位置 #330-330的标注 | 添加于 2021年4月28日星期三 下午2:33:05</span></p><p id="uaf1384c9" class="ne-p"><br></p><div data-type="info" class="ne-alert"><p id="u8d6dc744" class="ne-p"><span class="ne-text">“天下棺材七尺三。”</span></p></div><p id="ub564b13f" class="ne-p"><span class="ne-text"></span></p><p id="u0be77ed2" class="ne-p"><span class="ne-text">- 您在位置 #474-476的标注 | 添加于 2021年4月28日星期三 下午2:46:24</span></p><p id="uc419e439" class="ne-p"><br></p><div data-type="info" class="ne-alert"><p id="u636878f8" class="ne-p"><span class="ne-text">人生在世祸福难测，有一门技艺在身能够逢凶化吉，技艺是怎么也不会败落的。林祥福觉得自己的木工技艺应该更上一层楼，应该继续去拜师学艺。</span></p></div><p id="u6b786f38" class="ne-p"><span class="ne-text"></span></p><p id="ude3dae47" class="ne-p"><span class="ne-text">- 您在位置 #818-819的标注 | 添加于 2021年4月28日星期三 下午3:09:19</span></p><p id="u156cb9c7" class="ne-p"><br></p><div data-type="info" class="ne-alert"><p id="ucafa1f0a" class="ne-p"><span class="ne-text">晚霞在明净的天空里燃烧般通红，岸上的田地里传来耕牛回家的哞哞叫声，炊烟正在袅袅升起。</span></p></div><p id="u91bbd27f" class="ne-p"><br></p></div>]]></content>
      
      
      <categories>
          
          <category> 阅读 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>『无间道』有感</title>
      <link href="/essay/ebd5c2/"/>
      <url>/essay/ebd5c2/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="traditional"><p id="d4cd9e0b7643b178590e5bd43190a698" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1663487070433-15da28ac-1613-48b1-bd45-0cb19c946655.png" width="640" id="u2305c69a" class="ne-image"></p><p id="bca677546c40af316ec70d00c4f1f9aa" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1663487102892-a9dcfb0b-d3b5-4a73-928b-1fba8e9612b5.png" width="640" id="u49a4e274" class="ne-image"></p><p id="c79d5e3f0a39dd702d986bafe1be8a08" class="ne-p"><br></p><p id="a20d224c568e48b9d67847a2c66a8c01_p_0" class="ne-p"><span class="ne-text">上个礼拜看的，我觉得这无间道三部曲算是港片的鼻祖地位的，因为传神……</span></p><p id="8d300c677e4a9086d7e65ebf9d38463f" class="ne-p"><br></p><p id="9ecc208c16440d622ef7f65e4f3526b4" class="ne-p"><span class="ne-text">对刘建明和阿仁，我只想说，</span><strong><span class="ne-text">有的人死去，人已经解脱了，有的人，看似风生水起，实则，已堕入无间地狱</span></strong><span class="ne-text">。</span></p><p id="16c080f51d5704ddb6a9b798aba0c519" class="ne-p"><span class="ne-text"></span></p><p id="9b8f43669e12798d79692411f0d6bccb" class="ne-p"><span class="ne-text">还有一句“我只想做个好人”，初听之下就像是步入正途之下的光明大道，实则细想实在是</span><strong><span class="ne-text">鬼魅</span></strong><span class="ne-text">。</span></p><p id="d52ffb5a5b0c766efccd5acbc29d2768" class="ne-p"><br></p><p id="c4f8147964b709abdb4fd363215884b1" class="ne-p"><br></p><p id="d52ca9bbaa3f79d34d3480ea1173d8ce" class="ne-p"><span class="ne-text">这里面还有很多关于佛教的一些摘录，感觉很值得揣摩，在此摘录一番</span></p><p id="3608c9450d75ee1469f27cdb481746ca" class="ne-p"><br></p><div data-type="tips" class="ne-alert"><p id="079ef868ca01f016b633a9ece7c10a0f" class="ne-p"><span class="ne-text">《涅槃经》第十九卷</span></p><p id="be0431b93590460a95a42c30827e15ca" class="ne-p"><span class="ne-text">「八大地狱之最，称为无间地狱，为无间断遭受大苦大意，故有此名。」</span></p></div><p id="701037c1e65ccdb7be47ca7bb8536938" class="ne-p"><br></p><div data-type="tips" class="ne-alert"><p id="a6b2b87526764897fbe9410ec967ac06" class="ne-p"><span class="ne-text">「无间有三，时无间，空无间，受业无间。犯忤逆罪这永堕此界，尽受终极之无间。」</span></p></div><p id="72803a2d8e43b08ce33939c809250346" class="ne-p"><br></p><div data-type="tips" class="ne-alert"><p id="5d43979d9efd07864562fad132f591fc" class="ne-p"><span class="ne-text">地藏菩萨本愿经卷上：</span></p><p id="3db11f1ff4abe3f5955ba94113b85e13" class="ne-p"><span class="ne-text">「如是本辈，当堕无间地狱，千万亿劫，以此连绵，求出无期。」</span></p></div><p id="924afdb50df8e8613eb2e3d4133903fa" class="ne-p"><br></p><p id="f54e3ce4ddf35bc041c2c155126a2caf" class="ne-p"><br></p><p id="80e985baec561216ea9f5d5da324cf8c" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1663487117998-91c8dc3a-5b25-4c30-9ed2-1077c7aeb862.png" width="640" id="u724895c8" class="ne-image"></p></div>]]></content>
      
      
      <categories>
          
          <category> 影视 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>『DARLING in the FRANXX』</title>
      <link href="/essay/lwgmc6/"/>
      <url>/essay/lwgmc6/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content-editor-core lake-engine lake-typography-classic" data-lake-element="root" data-selection-undefined="%7B%22path%22%3A%5B%5D%2C%22active%22%3Atrue%7D"><blockquote class="lake-alert lake-alert-info" style="margin: 0px; padding: 10px; border: 1px solid rgb(171, 210, 218); opacity: 1; border-radius: 3px; color: rgb(38, 38, 38); background-color: rgb(232, 247, 255);"><p data-lake-id="eb20118c0862988d4b58e2f199067c2c" id="eb20118c0862988d4b58e2f199067c2c" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>Darling in the FranXX （比翼之吻）</span></p></blockquote><p data-lake-id="5eff8955e6a6de7fb185315726afb2ce" id="5eff8955e6a6de7fb185315726afb2ce" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="u1a39d7f3" id="u1a39d7f3" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="u7ed4fe23" id="u7ed4fe23" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>这部番我觉得从世界观的角度来说构思很新奇，贯穿全篇则为——人性。</span></p><p data-lake-id="uaf01d3d1" id="uaf01d3d1" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="u1ee6b533" id="u1ee6b533" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>世界观颠覆了以往的人类美的一面，将人类的人格寄存于“爸爸”的手掌之下，欲望促使人类的人形暴露，但同时人性的一些闪光点，也在悄然萌发。</span></p><p data-lake-id="u12f8e672" id="u12f8e672" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="u5969b72c" id="u5969b72c" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>zero two和广的爱情，就像是我之前写的『缺爱』一篇，zero two的缺爱的极端时刻，被广的光辉所拯救了，成年之际，广的失意落魄被zero two口中的darling所拯救；</span></p><p data-lake-id="ue7fba2c8" id="ue7fba2c8" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="ufb130638" id="ufb130638" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>还有心的圣母形象，忘了对满的感情和生育的知识，这是我觉得这部番里面特别重要的一个点睛之笔。</span></p><p data-lake-id="uf464e2e7" id="uf464e2e7" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="ud4dbf13a" id="ud4dbf13a" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>我们很难去理性的分析这些人物角色，但是贯穿这些的我想就是人性最为光辉的各个闪光点吧……</span></p><p data-lake-id="uc768b23e" id="uc768b23e" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="u109f29d8" id="u109f29d8" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span>转载一篇文章，片中几个机体的命名——对应的都是植物</span></p><blockquote style="margin-top: 5px; margin-bottom: 5px; padding-left: 1em; margin-left: 0px; border-left: 3px solid rgb(238, 238, 238); opacity: 0.6;"><p data-lake-id="u3cf346f2" id="u3cf346f2" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><a href="https://movie.douban.com/review/9225938/" target="_blank"><span>片中几个机体的命名——对应的都是植物</span></a></p></blockquote><p data-lake-id="ue098f2ad" id="ue098f2ad" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="ub2673e7b" id="ub2673e7b" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span data-card-type="inline" data-lake-card="image" id="u4f75054a" class="lake-card-margin-top lake-card-margin-bottom"><img data-role="image" src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1619577542480-78f1ab01-405e-411c-ae14-537958ecf49e.jpeg" data-raw-src="" class="image lake-drag-image" alt="image" title="image" data-height="540px" style="visibility: visible; width: 960px;"></span></p><p data-lake-id="u417634c2" id="u417634c2" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="e2c837ea6885adf42094dfcc56db1347" id="e2c837ea6885adf42094dfcc56db1347" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span data-card-type="inline" data-lake-card="image" id="QP1th" class="lake-card-margin-top lake-card-margin-bottom"><img data-role="image" src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1619485267464-dd9642d5-df67-4a97-8419-8e5fc3a709a9.png" data-raw-src="" class="image lake-drag-image" alt="85308871_p0.png" title="85308871_p0.png" data-height="1200px" style="visibility: visible; width: 1600px;"></span></p><p data-lake-id="2afb306203f11e865bca119dc4559b91" id="2afb306203f11e865bca119dc4559b91" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span data-card-type="inline" data-lake-card="image" id="U6MD4" class="lake-card-margin-top lake-card-margin-bottom"><img data-role="image" src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1619485230506-60d08215-4e79-42cb-9ba0-d3b5681edec4.png" data-raw-src="" class="image lake-drag-image" alt="87980648_p0.png" title="87980648_p0.png" data-height="1261px" style="visibility: visible; width: 2000px;"></span></p><p data-lake-id="8cf5c9ef0277f37b37cd611a58909e65" id="8cf5c9ef0277f37b37cd611a58909e65" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span data-card-type="inline" data-lake-card="image" id="LdgD5" class="lake-card-margin-top lake-card-margin-bottom"><img data-role="image" src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1619485170602-d19ab096-b1e2-4001-a419-4e1cc1c5a8ba.jpeg" data-raw-src="" class="image lake-drag-image" alt="87883532_p0.jpg" title="87883532_p0.jpg" data-height="1040px" style="visibility: visible; width: 700px;"></span></p><p data-lake-id="f30b58723d2340e5ff523deac5fc5904" id="f30b58723d2340e5ff523deac5fc5904" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span data-card-type="inline" data-lake-card="image" id="Y2Du1" class="lake-card-margin-top lake-card-margin-bottom"><img data-role="image" src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1619485191278-d20ca434-1141-41f5-a73e-db7b54f34d4e.png?x-oss-process=image%2Fresize%2Cw_2000" data-raw-src="" class="image lake-drag-image" alt="87324495_p0.png" title="87324495_p0.png" data-height="5000px" style="visibility: visible; width: 3000px;"></span></p></div>]]></content>
      
      
      <categories>
          
          <category> 影视 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>《平凡的世界》有感</title>
      <link href="/essay/hhd57l/"/>
      <url>/essay/hhd57l/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="863f517155e0cf66b43d8d543437e9a1" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1622032253532-9007acd3-e5c9-4e15-9839-7412bf52d680.jpeg" width="350" id="gdmS8" class="ne-image"></p><p id="u9ec3384d" class="ne-p" style="text-align: left"><span class="ne-text">平凡的世界（路遥著长篇小说）</span></p><hr id="jWCqK" class="ne-hr"><p id="ueda912e9" class="ne-p"><span class="ne-text">21.06.12</span></p><p id="ua1a33424" class="ne-p"><span class="ne-text"></span></p><p id="uc053d937" class="ne-p"><span class="ne-text">经历了一件事，心碎。</span></p><p id="udcaa575c" class="ne-p"><span class="ne-text">今天的我懂得到什么叫成长，就像最后的少平那样，笔直地走向那条铁路，坚毅，成长……</span></p><p id="u98966ebf" class="ne-p"><span class="ne-text"></span></p><p id="u91c377bd" class="ne-p"><span class="ne-text">“少平，你要记得，你与其他人不一样，你是一个有另外世界的人，你的心不应该只在这，而是在远方，那个充满光的地方”</span></p><p id="u0fd6aeb5" class="ne-p"><span class="ne-text"></span></p><p id="u3204451d" class="ne-p"><span class="ne-text">这话湿了眼眶……</span></p><p id="u4f212593" class="ne-p" style="text-align: left"><br></p><hr id="nqvgI" class="ne-hr"><p id="ue48eb825" class="ne-p" style="text-align: left"><span class="ne-text">21.02.21号整理家里书架时候写的</span></p><p id="593a8a6d23a9a70a8856487c01c855c3" class="ne-p"><br></p><p id="a20d224c568e48b9d67847a2c66a8c01_p_0" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1619483066100-b7e6b34c-9232-4dda-859f-02f28ceec07c.jpeg" width="1125" id="fX4yb" class="ne-image"></p></div>]]></content>
      
      
      <categories>
          
          <category> 阅读 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>我变了吗？</title>
      <link href="/essay/ogyb5h/"/>
      <url>/essay/ogyb5h/</url>
      
        <content type="html"><![CDATA[<div class="yuque-hexo-lyrics-secret">这是加密文章！</div>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>应用层及网络应用万维网的HTTP协议</title>
      <link href="/blog/re05fo/"/>
      <url>/blog/re05fo/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h2 id="eglYS"><span class="ne-text">为什么需要应用层呢？</span></h2><p id="d5104f7caada438423b3717ef9b93288" class="ne-p"><span class="ne-text">应用层的上一层，也就是传输层其实就已经搭建好了传输信息的框架，但是为什么还需要应用层这一层，因为</span><strong><span class="ne-text">传输层传的太简单，只实现我给你传过去，不全面有不足之处，用课上老师的话说，各层的宗旨就是尽力而为，举一些传输层心有余而力不足的地方：</span></strong></p><ul class="ne-ul"><li id="0acc0f7570b3c0e5417a75fdeb9e6983"><span class="ne-text">客户端发送的是什么数据类型的文件</span></li><li id="581acc4506fb6a8a75f799fbb1dcd879"><span class="ne-text">数据的长度，传输一次的数据长度为多长，一次是否传得完？什么时候传完？（TCP的流量控制）</span></li><li id="3129068ecf6d9fd8d743db5437703910"><span class="ne-text">数据的压缩方式，服务端如何知道客户端对数据是否压缩抑或是压缩算法是什么？</span></li></ul><p id="a3ae40530a1423eca58fa2142460cd8c" class="ne-p"><br></p><p id="303a98500a5374d068fe268e5fa1a103" class="ne-p"><span class="ne-text">而对于上述三个问题，在应用层给出相应的解决方案：</span></p><p id="a085c8e41d589ed87ec5c51ef626824e" class="ne-p"><br></p><ul class="ne-ul"><li id="8d28769a5e009a3b99805b3c8b1a2ffa"><span class="ne-text">数据的类型，HTTP Header： Content-Type</span></li><li id="5dd888b6b68aaa859ca36dc9b7f38b0a"><span class="ne-text">数据的长度，HTTP Header： Content-Length</span></li><li id="f463ad19d58db7e42f4d3e370230935e"><span class="ne-text">数据的压缩方式，HTTP Header： Accept-Encoding</span></li></ul><h2 id="0LSKV"><span class="ne-text">搞清互联网和万维网主次</span></h2><p id="848f8e181e1e1eae9e4e449f6653ce70" class="ne-p"><span class="ne-text">之前上课的时候，这里一直被忽视了，有一个主次概念需要搞清楚，</span><strong><span class="ne-text">万维网（WWW）是一个网络应用，万维网应用是一种基于客户/服务器体系结构的网络应用</span></strong><span class="ne-text">『应用层的协议都是基于客户服务器方式的，即便是P2P对等通信方式，实质上也是一种特殊的客户服务器方式』</span><strong><span class="ne-text">，它是一个网络应用</span></strong><span class="ne-text">，相应地，在互联网里面，还有</span><span class="ne-text">文件传输（FTP)、电子邮件E-mail、远程登录（Telnet）等这些应用。</span><span class="ne-text">所以引用对互联网还可以说成：</span><strong><span class="ne-text">是线路、协议以及通过TCP/IP协议实现数据电子传输的硬件和软件的集合体</span></strong><span class="ne-text">。</span></p><p id="3531571023b1a92a57dce45c234d1255" class="ne-p"><br></p><p id="476b67a110c81401bc82687c6403de7c" class="ne-p"><span class="ne-text">万维网这个应用还包括一些部件：万维网浏览器，万维网服务器，玩万维网文档的格式标准，以及一个应用层协议等等，这样就将HTTP的来源就串起来了。</span></p><p id="ee7d7d54ab30969e56b58a92dba75cd4" class="ne-p"><br></p><p id="dbf21727037776ed88af3faca6d22fa1" class="ne-p"><span class="ne-text">理解了主次，再从“主”依次理解“次”</span></p><ul class="ne-ul"><li id="95736441e5fb2ac7a2376f56c0fd96c8"><span class="ne-text">先理解许多应用协议都要使用的</span><strong><span class="ne-text">域名系统（DNS）</span></strong><span class="ne-text">，这是基础中的基础</span></li><li id="29c5e23d4350feeebdbf9855ddb1fc82"><span class="ne-text">文件传送协议：具体应用就是云主机的使用吧</span></li></ul><p id="38be84c954a2fc5689252b2c4789bac5" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1618625750527-7aa85753-4d61-4400-8e86-f8f2c6ae0c41.png" width="109.5" id="YCaOz" class="ne-image"></p><ul class="ne-ul"><li id="46d301d7daca1ec195ae686bc312aebf"><span class="ne-text">远程登录协议：书上只讲了TELNET，具体应用XSHELL的SSH也是</span></li></ul><p id="e842d4a8b93c9e9a6d104ddab2d12ed8" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1618625847438-b61068f8-a3d5-43b0-8cd3-eefb3aeac42d.png" width="100" id="koiBy" class="ne-image"></p><ul class="ne-ul"><li id="0b6e902c07b0f45cfb86072d27c2b6c9"><strong><span class="ne-text">万维网及其主要协议</span></strong></li><li id="cd7e73deb034be478e6f4cfe0e1b93aa"><span class="ne-text">电子邮件</span></li></ul><p id="325eec7049007d74b9561c42a059b958" class="ne-p"><br></p><h2 id="w9vSY"><span class="ne-text">万维网是什么？有什么用？</span></h2><div class="ne-quote"><p id="12b962bab78cc1e96e78ac77f5f8e1c8" class="ne-p"><span class="ne-text">用课本的概念：万维网用链接的方式能非常方便地从互联网上的一个站点访问另一个站点（也就是所谓的“链接到另一个站点”），从而主动地按需获取丰富的信息。</span></p></div><p id="7c40e2993f984315240eabd2e49c851f" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1618626263044-e610396b-b7b5-4f11-a8f5-1499f0f7f5d8.png" width="477.5" id="BPTJ3" class="ne-image"></p><p id="c08afff16b15c0cce9ba8d6d667dddb0" class="ne-p"><span class="ne-text">要达到这样的构想，架构这样的系统需要解决哪些问题呢？</span></p><p id="06bc65dea7d96591f5d96b2b8c2805e2" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1618626404243-cf649c67-a499-46a3-a163-aad61a17c9b7.png" width="566" id="Gmaxj" class="ne-image"></p><ol class="ne-ol"><li id="13007b271ad66e84aed1f7a3b4236cc4"><span class="ne-text">利用URL</span></li><li id="46cfaf4c592f52c7ad765c16131ed883"><span class="ne-text">HTTP协议（基于TCP）</span></li><li id="6fb27a72523914ff0a353ce10907758a"><span class="ne-text">HTML：就是超文本标记语言，这里不再赘述</span></li><li id="252dfb874897ae120ce37fd620e81382"><span class="ne-text">搜索工具：搜索引擎工具，谷歌、百度……</span></li></ol><h2 id="to7JS"><span class="ne-text">HTTP协议</span></h2><h3 id="8aJXI"><span class="ne-text">HTTP的报文结构</span></h3><p id="2fb36cdb73dc4719227c4f15a619568b" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1618626839900-2a58c82a-1c27-427e-a902-6b21e3458b12.png" width="429" id="V2nrj" class="ne-image"></p><h3 id="L5msE"><span class="ne-text">请求报文实例</span></h3><p id="0c0b60cf6a71a91b10300cbbe9fe07ac" class="ne-p"><span class="ne-text">请求行中的方法，就是对所请求对象进行的操作，具体有以下一些方法：</span></p><p id="5a338f15ca4935a54a9d36cdc6df0fe7" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1618627091156-cd978f06-4e39-41ea-9652-0ceddab98bb7.png" width="341" id="zSrHY" class="ne-image"></p><p id="1543b18fe99a0e5f4f64804fcdcd28b3" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1618627123440-4ed5d351-96a7-4228-a9fe-aaff7e5bb9e2.png" width="474.5" id="crkmI" class="ne-image"></p><p id="e14d60dd756dc70e202c5479b323a164" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1618627710005-1577f282-ff85-4fd2-a6ae-51187928044e.png" width="442.5" id="sW7Mj" class="ne-image"></p><p id="123d8d70ed726a26db301addb5a6c6af" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1618627722921-07c819d7-b873-4644-8cb0-844ff27450d0.png" width="414" id="w3y6P" class="ne-image"></p><p id="12b86c7270c3e6472753afa85275a373" class="ne-p"><span class="ne-text">具体在浏览器的显示为：</span></p><p id="e054b5c596e564117ba8aedd01f6ed3e" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1618627622010-49ba1876-a555-41a6-85b6-f23bc458ac82.png" width="624" id="mlIDO" class="ne-image"></p><p id="6f64df2c40ae71196368903404adfb29" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1618627640727-1204203a-4f3e-4fff-a388-fa47224fd7a0.png" width="618.5" id="DJDi5" class="ne-image"></p><h3 id="4nTpJ"><span class="ne-text">本地存储和Cookie</span></h3><p id="95a70d5098ff005a5099ad0291933f6b" class="ne-p"><span class="ne-text">自己搭建个人网站的时候，有这么一个功能，</span></p><p id="842ad0d38510d250834aed05aab39b3e" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1618627885598-f7d86695-ab4b-47b1-84de-1f7131daf095.png" width="960" id="LcLA1" class="ne-image"></p><p id="9a8e21d715e2818bbe49ce1861e221d1" class="ne-p"><span class="ne-text">对用户在本地浏览器里面点击这个伸缩布局按钮，下一次再打开网站，浏览器会记住这个布局，我是使用的localSession这个对象方法，因为是静态网站，这样实现还是比较友好的</span><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1618628002219-e1725906-d456-4930-bba7-cc800938c02f.png" width="960" id="sVhQJ" class="ne-image"></p><p id="370b9b001740e9c98903fa9bfb647684" class="ne-p"><span class="ne-text">这是静态站点使用的友好方式，比较灵活的还有Cookie方式，特别是在动态网站的搭建过程中。</span></p><p id="00cabe344e8430db30acf5ec4a56db79" class="ne-p"><span class="ne-text">在Node.js框架Express里面利用“</span><span class="ne-text">express-session</span><span class="ne-text">”插件来使用Cookie。</span></p><p id="95cf757c966b97a1bb048ed21b7ca9c9" class="ne-p"><br></p><ul class="ne-ul"><li id="61cf0bad5bbc5b0da962c4418ac4e03b"><span class="ne-text">Cookie会记录客户端和服务端之间的信息</span></li><li id="d01cdf4dafe2204a182ecc1eed464ff5"><span class="ne-text">每次请求都会默认携带Cookie</span></li><li id="a6254f43bc5f5055478aea9d23a90bfc"><span class="ne-text">会被加密，安全</span></li></ul><p id="dd068003f7ac215177018bb30fd03783" class="ne-p"><span class="ne-text">关于安全问题，课本上的表述是这样的：</span></p><p id="4a2c4cec13e5c675a3beac303246bb7b" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1618628510004-3df5120d-f238-4a6c-9dc8-e9c803283163.png" width="465.5" id="hPBY6" class="ne-image"></p><p id="491b384fb9c7fc0225367cde0910181a" class="ne-p"><br></p><h2 id="59BBL"><span class="ne-text">参考</span></h2><ul class="ne-ul"><li id="fb3d200ff22f63429e8f4ddfe04cddff"><span class="ne-text">《计算机网络》第7版——谢希仁</span></li><li id="6679e4b30fd24962320d3ace093d7526"><a href="https://www.html.cn/qa/other/21226.html" data-href="https://www.html.cn/qa/other/21226.html" target="_blank" class="ne-link"><span class="ne-text">万维网和互联网的区别是什么？</span></a></li><li id="c5f068bcea7d8b66f2fd8474f1248623"><a href="https://www.zhihu.com/question/368324676/answer/988997873" data-href="https://www.zhihu.com/question/368324676/answer/988997873" target="_blank" class="ne-link"><span class="ne-text">为什么需要，以及如何设计应用层协议？</span></a></li><li id="fd5da6f3aeb1a5557fc24e6d3c75a7a4"><a href="https://blog.csdn.net/u010076558/article/details/17620719" data-href="https://blog.csdn.net/u010076558/article/details/17620719" target="_blank" class="ne-link"><span class="ne-text">几种远程控制协议</span></a></li></ul></div>]]></content>
      
      
      <categories>
          
          <category> 计算机素养 </category>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>实验4——超市排队机🔖队列</title>
      <link href="/blog/zgiaxv/"/>
      <url>/blog/zgiaxv/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h2 id="20T4y"><span class="ne-text">实验任务</span></h2><p id="9f9b98eac38d19e538b42d7746c04a9f" class="ne-p"><span class="ne-text">    实验4：队列的链式表示和实现</span></p><p id="7f5ef7b6fb7c14232a9d0715d945ae8e" class="ne-p"><span class="ne-text">    要求：某小超市有两个排队机，构建2个用带头结点的单链表队列QA和QB, 实现下列操作</span></p><p id="61513287fe3e2922bdd79107f0ef3355" class="ne-p"><span class="ne-text">        1、初始化队列(清空)；</span></p><p id="e318417a78d41bdc35b2fb51fea54408" class="ne-p"><span class="ne-text">        2、入队；</span></p><p id="66ab82335f33a8cb72f8a7d37f44777b" class="ne-p"><span class="ne-text">        3、出队;</span></p><p id="c16c943dd4288a72dd6b295bfa0377bf" class="ne-p"><span class="ne-text">        4、求队列长度；</span></p><p id="10fe96031b21a32c13c6097ae020e25f" class="ne-p"><span class="ne-text">        5、判断队列是否为空；</span></p><p id="ae0a391b09cffe7a9126f70818e56eda" class="ne-p"><span class="ne-text">        6、判断队列是否为满；</span></p><p id="9e5d1dae28859a8abeca1d0471446006" class="ne-p"><span class="ne-text">        7、对于队列QA和QB，如果其中一个队列的售货员下班，则自动甩到另一个队列后面。</span></p><p id="5e9cc15a80111b6a597cc9e255190af3" class="ne-p"><span class="ne-text">截止日期：4月22日</span></p><p id="u7db2feae" class="ne-p"><span class="ne-text"></span></p><h2 id="14MhD"><span class="ne-text">实验讨论</span></h2><p id="2e010ce1f965a4edb43b07e76023f987" class="ne-p"><br></p><div data-type="info" class="ne-alert"><p id="87dfb2648de3a04b1bf58824421fe863" class="ne-p"><span class="ne-text">觉得问题里面有bug</span></p></div><p id="06843150f7061a5692c3cab91b34abaf" class="ne-p"><br></p><p id="d94608e0b1b127fba7a074eb3c24a11b" class="ne-p"><span class="ne-text">对问题判满的疑惑与解决，第六个问题对链对判满是否有意义，如果是链式存储，数据结构本身判断满没有意义，但是考虑到是小型超市，超市空间不大，所以对其进行一开始的用户自己输入两个队列的最大长度。</span></p><p id="b46ce36306c0795c661082ae93333276" class="ne-p"><br></p><p id="d1dc74f717ac959b4fe6f310f217fb61" class="ne-p"><span class="ne-text">但是这样又有一个问题，在问题7中，如果一个队列的售货员下班了，这个队列的所有人排到另一个队列中，那如果新队列的长度超出用户输入的队列最大长度呢？考虑到实际问题，这个问题不打算解决了，让他们挤挤……</span></p><h2 id="yLU1H"><span class="ne-text">代码代码</span></h2><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;<p>typedef int Status;<br>typedef int QElemType;</p><p>#define OVERFLOW -1<br>#define ERROR 0<br>#define OK 1</p><p>/**<br>    实验4：队列的链式表示和实现<br>    要求：某小超市有两个排队机，构建2个用带头结点的单链表队列QA和QB, 实现下列操作<br>        1、初始化队列(清空)；<br>        2、入队；<br>        3、出队;<br>        4、求队列长度；<br>        5、判断队列是否为空；<br>        6、判断队列是否为满；<br>        7、对于队列QA和QB，如果其中一个队列的售货员下班，则自动甩到另一个队列后面。</p><p> */</p><p>/* 存储形式 */<br>typedef struct QNode&#123; //链队用的结点<br>    QElemType data;<br>    struct QNode *next;<br>&#125;QNode,*QueuePtr;</p><p>typedef struct &#123;<br>    QueuePtr front;<br>    QueuePtr rear;<br>&#125;LinkQueue;</p><p>/* 初始化 */<br>Status InitQueue(LinkQueue &amp;queue) &#123;<br>    queue.front = queue.rear = new QNode;<br>    queue.front-&gt;next = NULL;<br>    return OK;<br>&#125;</p><p>/* 求队列长度 */<br>Status QueueLength(LinkQueue &amp;queue) &#123;<br>    int count = 0;<br>    if (queue.rear == queue.front) &#123;<br>        return count;<br>    &#125;<br>    QueuePtr temp = queue.front;<br>    while (temp != queue.rear) &#123;<br>        count++;<br>        temp = temp-&gt;next;<br>    &#125;<br>    return count;<br>&#125;</p><p>/* 入队 */<br>Status EnQueue(LinkQueue &amp;queue, QElemType e, int length) &#123;<br>    if (QueueLength(queue) &lt;length) &#123;<br>        QueuePtr temp = new QNode;<br>        temp-&gt;data = e;<br>        temp-&gt;next = NULL;<br>        queue.rear-&gt;next = temp;<br>        queue.rear = temp;<br>        return OK;<br>    &#125; else &#123;<br>        cout &lt;&lt; &quot;队已经满了，不能再入元素了&quot;&lt;&lt; &quot;\n&quot;;<br>        return ERROR;<br>    &#125;<br>&#125;</p><p>/* 出队 */<br>Status DeQueue(LinkQueue &amp;queue) &#123;<br>    if (queue.front == queue.rear) &#123;<br>        return OVERFLOW;<br>    &#125;<br>    // 有必要定义一个p，不然头结点会掉<br>    QueuePtr p = queue.front-&gt;next;<br>    QElemType e = p-&gt;data;<br>    queue.front-&gt;next = p-&gt;next;<br>    // 考虑最后一个元素被删，队尾指针指向头结点<br>    if (queue.rear == p) &#123;<br>        queue.rear = queue.front;<br>    &#125;<br>    return e;<br>&#125;</p><p>/* 取队头元素 */<br>// Status GetHead(LinkQueue &amp;queue) &#123;<br>//     if (queue.front != queue.rear)&#123;<br>//         return queue.front-&gt;next-&gt;data;<br>//     &#125;<br>// &#125;</p><p>/* 判断队列是否为空 */<br>bool QueueIsEmpty(LinkQueue &amp;queue) &#123;<br>    if (queue.rear == queue.front) &#123;<br>        return true;<br>    &#125; else &#123;<br>        return false;<br>    &#125;<br>&#125;</p><p>/**</p><ul><li>判断队列是否为满</li><li>不是很理解为什么链队需要判断是否为满呢？</li><li>采用输入链队长度，利用链队函数来判断</li><li>那么入队的代码需要输入length参数来判断是否还能让元素入队</li><li>/<br>bool QueueIsFull(LinkQueue &amp;queue, int length) &#123;<br>  if (QueueLength(queue) == length) &#123;<pre><code>  return true;</code></pre>  } else {<pre><code>  return false;</code></pre>  }<br>}</li></ul><p>/* 一个队列甩到另一个队列 */<br>Status QueueMove(LinkQueue &amp;queue_delete,LinkQueue &amp;queue_add) {<br>    queue_add.rear-&gt;next = queue_delete.front-&gt;next;<br>    queue_add.rear = queue_delete.rear;<br>    return OK;<br>}</p><p>/* 遍历查看队列元素 */<br>Status DisplayQueue(LinkQueue &amp;queue) {<br>    LinkQueue L = queue;<br>    while (L.front-&gt;next != NULL) {<br>        cout &lt;&lt; L.front-&gt;next-&gt;data &lt;&lt; &quot; &quot;;<br>        L.front = L.front-&gt;next;<br>    }<br>    cout &lt;&lt; &quot;\n&quot;;<br>    return OK;<br>}</p><p>int main() {</p><pre><code>cout&amp;lt;&amp;lt;&amp;quot;------------------------链队菜单----------------------&amp;quot;&amp;lt;&amp;lt;&#39;\n&#39;;cout&amp;lt;&amp;lt;&amp;quot;操作0：退出程序&amp;quot;&amp;lt;&amp;lt;&#39;\n&#39;;cout&amp;lt;&amp;lt;&amp;quot;操作1：初始化两队列&amp;quot;&amp;lt;&amp;lt;&#39;\n&#39;;cout&amp;lt;&amp;lt;&amp;quot;操作2：入队操作&amp;quot;&amp;lt;&amp;lt;&#39;\n&#39;;cout&amp;lt;&amp;lt;&amp;quot;操作3：出队操作&amp;quot;&amp;lt;&amp;lt;&#39;\n&#39;;cout&amp;lt;&amp;lt;&amp;quot;操作4：判断判断链队是否为空&amp;quot;&amp;lt;&amp;lt;&#39;\n&#39;;cout&amp;lt;&amp;lt;&amp;quot;操作5：判断判断链队是否为满&amp;quot;&amp;lt;&amp;lt;&#39;\n&#39;;cout&amp;lt;&amp;lt;&amp;quot;操作6：售货员偷懒选项&amp;quot;&amp;lt;&amp;lt;&#39;\n&#39;;cout&amp;lt;&amp;lt;&amp;quot;操作7：查看队列&amp;quot;&amp;lt;&amp;lt;&#39;\n&#39;;cout&amp;lt;&amp;lt;&amp;quot;操作8：求队列长度&amp;quot;&amp;lt;&amp;lt;&#39;\n&#39;;cout&amp;lt;&amp;lt;&amp;quot;--------------------------------------------------------&amp;quot;&amp;lt;&amp;lt;&#39;\n&#39;;int a, length,flag = 1;cout &amp;lt;&amp;lt; &amp;quot;请输入你希望排队机最多能排的人数：&amp;quot;&amp;lt;&amp;lt;&amp;quot;\n&amp;quot;&amp;lt;&amp;lt;&amp;quot;\n&amp;quot;;cin &amp;gt;&amp;gt; length;LinkQueue QA,QB;while(flag)&#123;    cout&amp;lt;&amp;lt;&#39;\n&#39;&amp;lt;&amp;lt;&amp;quot;请选择要执行的操作：&amp;quot;;    while(cin&amp;gt;&amp;gt;a)    &#123;        if(a &amp;lt; 0 || a &amp;gt; 8)            cout&amp;lt;&amp;lt;&amp;quot;请选择正确操作编号：&amp;quot;;        else            break;    &#125;    switch(a)    &#123;        case 0:        &#123;            cout&amp;lt;&amp;lt;&amp;quot;正在退出程序中……&amp;quot;&amp;lt;&amp;lt;&#39;\n&#39;;            flag = 0;            break;        &#125;        case 1:        &#123;            cout&amp;lt;&amp;lt;&amp;quot;初始化QA、QB队列中……&amp;quot;&amp;lt;&amp;lt;&#39;\n&#39;;            InitQueue(QA);            InitQueue(QB);            break;        &#125;        case 2:        &#123;            cout&amp;lt;&amp;lt;&amp;quot;请输入入队的队列（QA输入1，QB输入2）&amp;quot;&amp;lt;&amp;lt;&#39;\n&#39;;            int select_queue;            cin &amp;gt;&amp;gt; select_queue;            if (select_queue == 1) &#123;                cout&amp;lt;&amp;lt;&amp;quot;请输入入QA队的队列的元素&amp;quot;&amp;lt;&amp;lt;&#39;\n&#39;;                int select_queue_A;                cin &amp;gt;&amp;gt; select_queue_A;                EnQueue(QA, select_queue_A, length);            &#125; else if (select_queue == 2) &#123;                cout&amp;lt;&amp;lt;&amp;quot;请输入入QB队的队列的元素&amp;quot;&amp;lt;&amp;lt;&#39;\n&#39;;                int select_queue_B;                cin &amp;gt;&amp;gt; select_queue_B;                EnQueue(QB, select_queue_B, length);            &#125; else &#123;                cout &amp;lt;&amp;lt; &amp;quot;输入有误！&amp;quot;&amp;lt;&amp;lt; &amp;quot;\n&amp;quot;;            &#125;            break;        &#125;        case 3:        &#123;            cout&amp;lt;&amp;lt;&amp;quot;请输入需要出队的队列（QA输入1，QB输入2）&amp;quot;&amp;lt;&amp;lt;&#39;\n&#39;;            int select_queue;            cin &amp;gt;&amp;gt; select_queue;            if (select_queue == 1) &#123;                DeQueue(QA);            &#125; else if (select_queue == 2) &#123;                DeQueue(QB);            &#125; else &#123;                cout &amp;lt;&amp;lt; &amp;quot;输入有误！&amp;quot;&amp;lt;&amp;lt; &amp;quot;\n&amp;quot;;            &#125;            break;        &#125;        case 4:        &#123;            cout&amp;lt;&amp;lt;&amp;quot;请输入需要判空的队列（QA输入1，QB输入2）&amp;quot;&amp;lt;&amp;lt;&#39;\n&#39;;            int select_queue;            cin &amp;gt;&amp;gt; select_queue;            if (select_queue == 1) &#123;                cout &amp;lt;&amp;lt; &amp;quot;QA队列为空吗？&amp;quot;&amp;lt;&amp;lt; boolalpha &amp;lt;&amp;lt; QueueIsEmpty(QA) &amp;lt;&amp;lt; &amp;quot;\n&amp;quot;;            &#125; else if (select_queue == 2) &#123;                cout &amp;lt;&amp;lt; &amp;quot;QB队列为空吗？&amp;quot;&amp;lt;&amp;lt; boolalpha &amp;lt;&amp;lt; QueueIsEmpty(QB) &amp;lt;&amp;lt; &amp;quot;\n&amp;quot;;            &#125; else &#123;                cout &amp;lt;&amp;lt; &amp;quot;输入有误！&amp;quot;&amp;lt;&amp;lt; &amp;quot;\n&amp;quot;;            &#125;            break;        &#125;        case 5:        &#123;            cout&amp;lt;&amp;lt;&amp;quot;请输入需要判满的队列（QA输入1，QB输入2）&amp;quot;&amp;lt;&amp;lt;&#39;\n&#39;;            int select_queue;            cin &amp;gt;&amp;gt; select_queue;            if (select_queue == 1) &#123;                cout &amp;lt;&amp;lt; &amp;quot;QA队列为满吗？&amp;quot;&amp;lt;&amp;lt; boolalpha &amp;lt;&amp;lt; QueueIsFull(QA,length) &amp;lt;&amp;lt; &amp;quot;\n&amp;quot;;            &#125; else if (select_queue == 2) &#123;                cout &amp;lt;&amp;lt; &amp;quot;QB队列为满吗？&amp;quot;&amp;lt;&amp;lt; boolalpha &amp;lt;&amp;lt; QueueIsFull(QB,length) &amp;lt;&amp;lt; &amp;quot;\n&amp;quot;;            &#125; else &#123;                cout &amp;lt;&amp;lt; &amp;quot;输入有误！&amp;quot;&amp;lt;&amp;lt; &amp;quot;\n&amp;quot;;            &#125;            break;        &#125;        case 6:        &#123;            cout&amp;lt;&amp;lt;&amp;quot;请输入下班的售货员（QA输入1，QB输入2）&amp;quot;&amp;lt;&amp;lt;&#39;\n&#39;;            int select_queue;            cin &amp;gt;&amp;gt; select_queue;            if (select_queue == 1) &#123;                QueueMove(QA, QB);            &#125; else if (select_queue == 2) &#123;                QueueMove(QB, QA);            &#125; else &#123;                cout &amp;lt;&amp;lt; &amp;quot;输入有误！&amp;quot;&amp;lt;&amp;lt; &amp;quot;\n&amp;quot;;            &#125;            break;        &#125;        case 7:        &#123;            cout&amp;lt;&amp;lt;&amp;quot;请输入要查看的队列（QA输入1，QB输入2）&amp;quot;&amp;lt;&amp;lt;&#39;\n&#39;;            int select_queue;            cin &amp;gt;&amp;gt; select_queue;            if (select_queue == 1) &#123;                DisplayQueue(QA);            &#125; else if (select_queue == 2) &#123;                DisplayQueue(QB);            &#125; else &#123;                cout &amp;lt;&amp;lt; &amp;quot;输入有误！&amp;quot;&amp;lt;&amp;lt; &amp;quot;\n&amp;quot;;            &#125;            break;        &#125;        case 8:        &#123;            cout&amp;lt;&amp;lt;&amp;quot;请输入要查看的队列的长度（QA输入1，QB输入2）&amp;quot;&amp;lt;&amp;lt;&#39;\n&#39;;            int select_queue;            cin &amp;gt;&amp;gt; select_queue;            if (select_queue == 1) &#123;                cout&amp;lt;&amp;lt;QueueLength(QA)&amp;lt;&amp;lt; &amp;quot;\n&amp;quot;;            &#125; else if (select_queue == 2) &#123;                cout&amp;lt;&amp;lt;QueueLength(QB)&amp;lt;&amp;lt; &amp;quot;\n&amp;quot;;            &#125; else &#123;                cout &amp;lt;&amp;lt; &amp;quot;输入有误！&amp;quot;&amp;lt;&amp;lt; &amp;quot;\n&amp;quot;;            &#125;            break;        &#125;    &#125;&#125;</code></pre><p>}<br></code></pre></p></div>]]></content>
      
      
      <categories>
          
          <category> 计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> Problems </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++队列顺序和链式实现及操作</title>
      <link href="/blog/fbfgft/"/>
      <url>/blog/fbfgft/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h2 id="noBws"><span class="ne-text">顺序循环队列</span></h2><p id="u38c4a437" class="ne-p"><br></p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;<p>typedef int Status;<br>typedef int QElemType;</p><p>#define OVERFLOW -1<br>#define ERROR 0<br>#define OK 1<br>#define MAXSIZE 100</p><p>/**</p><ul><li>循环队列——队列的顺序表示和实现</li><li></li><li>操作：初始化、队列长度、入队、出队、取队头元素</li><li>/</li></ul><p>/* 存储形式 */<br>typedef struct &#123;<br>    QElemType *base;<br>    int front;<br>    int rear;<br>&#125; SqQueue;</p><p>/* 初始化 */<br>Status InitQueue(SqQueue &amp;queue) &#123;<br>    // 初始化这个base地址为一个有最大容量的数组初地址<br>    queue.base = new int[MAXSIZE];<br>    if (!queue.base) &#123;<br>        return OVERFLOW;<br>    &#125;<br>    queue.front = queue.rear = 0;<br>    return OK;<br>&#125;</p><p>/* 求队列长度 */<br>Status QueueLength(SqQueue &amp;queue) &#123;<br>    return (queue.rear - queue.front + MAXSIZE) % MAXSIZE;<br>&#125;</p><p>/* 入队 */<br>Status EnQueue(SqQueue &amp;queue, QElemType e) &#123;<br>    if ((queue.rear+1)%MAXSIZE == queue.front) &#123;<br>        return OVERFLOW;<br>    &#125;<br>    queue.base[queue.rear] = e;<br>    queue.rear = (queue.rear + 1) % MAXSIZE;<br>    return OK;<br>&#125;</p><p>/* 出队 */<br>Status DeQueue(SqQueue &amp;queue) &#123;<br>    if ((queue.rear+1)%MAXSIZE == queue.front) &#123;<br>        return OVERFLOW;<br>    &#125;<br>    QElemType e = queue.base[queue.front];<br>    queue.front = (queue.front + 1) % MAXSIZE; //队头指针+1<br>    return e;<br>&#125;</p><p>/* 取队头元素 */<br>Status GetHead(SqQueue &amp;queue) &#123;<br>    if (queue.front != queue.rear) &#123;<br>        return queue.base[queue.front];<br>    &#125;<br>&#125;</p><p>int main() &#123;<br>    SqQueue test;<br>    InitQueue(test);<br>    EnQueue(test, 10);<br>    EnQueue(test, 15);<br>    EnQueue(test, 20);<br>    cout &lt;&lt; &quot;队列长度为：&quot; &lt;&lt; QueueLength(test) &lt;&lt; &quot;\n&quot;;<br>    cout &lt;&lt; GetHead(test)&lt;&lt;&quot; &quot;&lt;&lt; GetHead(test)&lt;&lt;&quot; &quot;&lt;&lt; GetHead(test)&lt;&lt;&quot; &quot;&lt;&lt;&quot;\n&quot;;<br>    cout &lt;&lt; DeQueue(test)&lt;&lt;&quot; &quot;&lt;&lt; DeQueue(test)&lt;&lt;&quot; &quot;&lt;&lt; DeQueue(test)&lt;&lt;&quot; &quot;&lt;&lt;&quot;\n&quot;;<br>&#125;<br></code></pre></p><h2 id="ntYcn"><span class="ne-text">链队</span></h2><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;<p>typedef int Status;<br>typedef int QElemType;</p><p>#define OVERFLOW -1<br>#define ERROR 0<br>#define OK 1<br>#define MAXSIZE 100</p><p>/**</p><ul><li>链队——队列的链式表示和实现</li><li></li><li>操作：初始化、入队、出队、取队头元素</li><li>/</li></ul><p>/* 存储形式 */<br>typedef struct QNode&#123; //链队用的结点<br>    QElemType data;<br>    struct QNode *next;<br>&#125;QNode,*QueuePtr;</p><p>typedef struct &#123;<br>    QueuePtr front;<br>    QueuePtr rear;<br>&#125;LinkQueue;</p><p>/* 初始化 */<br>Status InitQueue(LinkQueue &amp;queue) &#123;<br>    queue.front = queue.rear = new QNode;<br>    queue.front-&gt;next = NULL;<br>    return OK;<br>&#125;</p><p>/* 入队 */<br>Status EnQueue(LinkQueue &amp;queue, QElemType e) &#123;<br>    QueuePtr temp = new QNode;<br>    temp-&gt;data = e;<br>    temp-&gt;next = NULL;<br>    queue.rear-&gt;next = temp;<br>    queue.rear = temp;<br>    return OK;<br>&#125;</p><p>/* 出队 */<br>Status DeQueue(LinkQueue &amp;queue) &#123;<br>    if (queue.front == queue.rear) &#123;<br>        return OVERFLOW;<br>    &#125;<br>    QElemType e = queue.front-&gt;next-&gt;data;<br>    queue.front-&gt;next = queue.front-&gt;next-&gt;next;<br>    // 考虑最后一个元素被删，队尾指针指向头结点<br>    if (queue.rear == queue.front) &#123;<br>        queue.front = queue.rear;<br>    &#125;<br>    return e;<br>&#125;</p><p>/* 取队头元素 */<br>Status GetHead(LinkQueue &amp;queue) &#123;<br>    if (queue.front != queue.rear)&#123;<br>        return queue.front-&gt;next-&gt;data;<br>    &#125;<br>&#125;</p><p>int main() &#123;<br>    LinkQueue test;<br>    InitQueue(test);<br>    EnQueue(test, 10);<br>    EnQueue(test, 15);<br>    EnQueue(test, 20);<br>    // cout &lt;&lt; &quot;队列长度为：&quot; &lt;&lt; QueueLength(test) &lt;&lt; &quot;\n&quot;;<br>    cout &lt;&lt; GetHead(test)&lt;&lt;&quot; &quot;&lt;&lt; GetHead(test)&lt;&lt;&quot; &quot;&lt;&lt; GetHead(test)&lt;&lt;&quot; &quot;&lt;&lt;&quot;\n&quot;;<br>    cout &lt;&lt; DeQueue(test)&lt;&lt;&quot; &quot;&lt;&lt; DeQueue(test)&lt;&lt;&quot; &quot;&lt;&lt; DeQueue(test)&lt;&lt;&quot; &quot;&lt;&lt;&quot;\n&quot;;<br>&#125;<br></code></pre></p></div>]]></content>
      
      
      <categories>
          
          <category> 计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 📶线结构：字符串-数组-栈-队列 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++栈顺序和链式实现及操作</title>
      <link href="/blog/tlzqah/"/>
      <url>/blog/tlzqah/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="a20d224c568e48b9d67847a2c66a8c01_p_0" class="ne-p"><br></p><div data-type="info" class="ne-alert"><p id="179d6501b149bd3789fe38d726e29887" class="ne-p"><span class="ne-text">存储形式以及操作和顺序表和链表差不多，需要的操作也少，学栈和队列，感觉只是抽离出来这两种便于在应用层面使用</span></p></div><h2 id="GFKJm"><span class="ne-text">顺序栈</span></h2><pre><code>#include&lt;bits/stdc++.h&gt;typedef int Status;typedef int SElemType;#define OVERFLOW -1#define ERROR 0#define OK 1#define MAXSIZE 100<p>using namespace std;<br>/**</p><ul><li>顺序栈</li><li></li><li>顺序栈的基本操作：初始化、入栈、出栈、取栈顶元素</li><li>/</li></ul><p>/* 顺序栈的存储形式 */<br>typedef struct &#123;<br>    SElemType *base;<br>    SElemType *top;<br>    int stacksize;<br>&#125; SqStack;</p><p>/* 初始化 */<br>Status InitSqStack(SqStack &amp;stack) &#123;<br>    // 为栈分配容量<br>    stack.base = new int[MAXSIZE];<br>    // 分配失败返回失败值<br>    if (!stack.base) &#123;<br>        return OVERFLOW;<br>    &#125;<br>    // 让栈顶地址初始为栈底地址<br>    stack.top = stack.base;<br>    // 初始化容量<br>    stack.stacksize = MAXSIZE;<br>    return OK;<br>&#125;</p><p>/* 入栈 */<br>Status Push(SqStack &amp;stack, SElemType e) &#123;<br>    if (stack.top - stack.base == stack.stacksize) &#123;<br>        return OVERFLOW;<br>    &#125;<br>    *stack.top = e; // 先在top位置赋值<br>    stack.top++; // 将top地址++<br>    return OK;<br>&#125;</p><p>/* 出栈 */<br>Status Pop(SqStack &amp;stack) &#123;<br>    // 空栈返回异常<br>    if (stack.top == stack.base) &#123;<br>        return OVERFLOW;<br>    &#125;<br>    stack.top–; // 栈顶地址减1<br>    return *stack.top; // 返回此时“栈顶”元素<br>&#125;</p><p>/* 取栈顶元素 */<br>Status GetTop (SqStack &amp;stack) &#123;<br>    // 空栈返回异常<br>    if (stack.top == stack.base) &#123;<br>        return OVERFLOW;<br>    &#125;<br>    // stack.top–; // 栈顶地址减1，这是和出栈的区别<br>    return *(stack.top-1); // 返回此时“栈顶”元素<br>&#125;</p><p>int main() &#123;<br>    SqStack test;<br>    InitSqStack(test);<br>    Push(test, 10);<br>    Push(test, 15);<br>    Push(test, 20);<br>    cout &lt;&lt; GetTop(test)&lt;&lt;&quot; &quot;&lt;&lt; GetTop(test)&lt;&lt;&quot; &quot;&lt;&lt; GetTop(test)&lt;&lt;&quot; &quot;&lt;&lt;&quot;\n&quot;;<br>    cout &lt;&lt; Pop(test)&lt;&lt;&quot; &quot;&lt;&lt; Pop(test)&lt;&lt;&quot; &quot;&lt;&lt; Pop(test)&lt;&lt;&quot; &quot;&lt;&lt;&quot;\n&quot;;<br>&#125;<br></code></pre></p><h2 id="aheiA"><span class="ne-text">链栈</span></h2><pre><code>#include&lt;bits/stdc++.h&gt;typedef int Status;typedef int SElemType;#define OVERFLOW -1#define ERROR 0#define OK 1#define MAXSIZE 100<p>using namespace std;<br>/**</p><ul><li>链栈</li><li></li><li>链栈的基本操作：初始化、入栈、出栈、取栈顶元素</li><li>/</li></ul><p>/* 链栈的存储形式 */<br>typedef struct StackNode&#123;<br>    SElemType data;<br>    struct StackNode *next;<br>&#125; StackNode, *LinkStack;</p><p>/**</p><ul><li>初始化</li><li>不设头结点</li><li>/<br>Status InitLinkStack(LinkStack &amp;stack) &#123;<br>  stack = NULL; // 栈顶元素置空<br>  return OK;<br>&#125;</li></ul><p>/* 入栈 */<br>Status Push(LinkStack &amp;stack, SElemType e) &#123;<br>    // 不能用LinkStack这样声明结点变量，需要new一个内存空间<br>    LinkStack temp = new StackNode;<br>    temp-&gt;data = e;<br>    temp-&gt;next = stack;<br>    stack = temp;<br>    return OK;<br>&#125;</p><p>/* 出栈 */<br>Status Pop (LinkStack &amp;stack) &#123;<br>    SElemType i = stack-&gt;data;<br>    stack = stack-&gt;next;<br>    return i;<br>&#125;</p><p>/* 取栈顶元素 */<br>Status GetTop (LinkStack &amp;stack) &#123;<br>    return stack-&gt;data;<br>&#125;</p><p>int main() &#123;<br>    LinkStack test;<br>    InitLinkStack(test);<br>    Push(test, 10);<br>    Push(test, 15);<br>    Push(test, 20);<br>    cout &lt;&lt; GetTop(test)&lt;&lt;&quot; &quot;&lt;&lt; GetTop(test)&lt;&lt;&quot; &quot;&lt;&lt; GetTop(test)&lt;&lt;&quot; &quot;&lt;&lt;&quot;\n&quot;;<br>    cout &lt;&lt; Pop(test)&lt;&lt;&quot; &quot;&lt;&lt; Pop(test)&lt;&lt;&quot; &quot;&lt;&lt; Pop(test)&lt;&lt;&quot; &quot;&lt;&lt;&quot;\n&quot;;<br>&#125;<br></code></pre></p></div>]]></content>
      
      
      <categories>
          
          <category> 计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 📶线结构：字符串-数组-栈-队列 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>缺爱</title>
      <link href="/essay/xikynq/"/>
      <url>/essay/xikynq/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="ue38d18f1" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1620269016472-0205bffa-da28-4411-9950-1b94025de0f7.jpeg" width="550" id="THQSB" class="ne-image"></p><p id="u78948a78" class="ne-p" style="text-align: left"><br></p><p id="ub66f1859" class="ne-p" style="text-align: left"><span class="ne-text">前言：观《刀剑神域》《东京食尸鬼》《进击的巨人》等一些番，对“缺爱”这个词的一些感悟……</span></p><p id="u9c68e113" class="ne-p" style="text-align: left"><br></p><hr id="srTUH" class="ne-hr"><p id="u6563aa42" class="ne-p"><br></p><p id="uf2eaf996" class="ne-p" style="text-align: center"><br></p><p id="a20d224c568e48b9d67847a2c66a8c01_p_0" class="ne-p"><span class="ne-text">缺爱的人，内心总有一些渴望，渴望被关爱，渴望被呵护，渴望对方是自己心里想要的模样……这种渴望是一种游走在刀尖上的隐式力量，甚至，会让一个人人格变化，变成一个我们都不在认识的人……</span></p><p id="c4117653d51cd868e6dc22310070e8fa" class="ne-p"><br></p><p id="4a6b24cfa2b15d79fe14e63a02c3f76a" class="ne-p"><span class="ne-text">尤吉欧缺的是从小的青梅竹马爱丽丝的爱，在面对最高祭司的亲昵……当然，尤吉欧的强大就强大在，他无条件相信挚友桐人，即便是那般情形，他也从刀尖上走向了正确的道路。金木研缺少的是母爱，的佣人，缺少的是家主的关爱</span></p><p id="a478fc563129e4f079b6953e4d61345a" class="ne-p"><br></p><p id="3270eb285d36ab65041306778a361ad5" class="ne-p"><span class="ne-text">兵长利威尔，就更不用说了，人类中外挂，绝对的强者，他缺少的不仅是亲人的爱，更是这个世界的压抑与社会的动荡，地下生活，从小就仰头看不见天空，低头被人唾弃，这缺的简直是一个世界啊，他心里也是多么珍视自己的爱和他人的爱，最初的两个小伙伴，再到利威尔整个班，还有……佩特拉……</span></p><p id="dd1259eb009d4739a1200ca7aa563b64" class="ne-p"><br></p><p id="43a38f1ccb147a4287059cf525aad5d3" class="ne-p"><span class="ne-text">如果说这个世界真有一种至暗力量，缺爱或许也是其一呢~这个世界谁都没错，错的是这个世界，那么    我又为何一直低头呢？这就是缺爱的至暗力量……</span></p><p id="d4e2f3b848139d4c6309dc4c86de9199" class="ne-p"><br></p><p id="aec01b16fedb1f190c42998dd0bfc12c" class="ne-p"><span class="ne-text">生活中，也有很多啊，跟班，小时候的孩子，经常有跟班一说，如果你是和别人相爱的人，那么你可以给对方更多一点的爱，如果你是为人父母，你可以更加爱自己的子女，爱，从来都不嫌多，两个人之间的爱情也是一样</span></p><p id="b1748f97ad8674bc38ef2a38857c60fe" class="ne-p"><br></p><p id="1613204624cab5463d85d87e2a4ab215" class="ne-p"><span class="ne-text">人与人之间，不要让对方、让彼此缺爱……</span></p><p id="1cbf858f5b06b20c52478e7f5a6b349a" class="ne-p"><br></p><p id="e691ca557d793a55550ea296fc706439" class="ne-p"><span class="ne-text">你仔细看看，缺爱的人好多，小什造，又何尝不是，</span></p><p id="578e731111732a7970a40d89ac702f6c" class="ne-p"><br></p><p id="90606eeec48d383f2365da3b94729cbb" class="ne-p"><br></p><p id="217aafd31c5bb15e59f0194e07211d32" class="ne-p"><span class="ne-text">这部剧好就好在，没有没有对错，没有哪一方是绝对的正确，贯穿全剧的就是一句话——“错的不是我，而是这个世界”</span></p><p id="6db1b2b17b72e9d4157a23637f2b828f" class="ne-p"><br></p><p id="uff60666a" class="ne-p"><br></p><p id="9add66c2f6176132dfe12b6382c5f6b5" class="ne-p"><span class="ne-text">写着写着，简直我就要黑化一般</span><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1618565453724-89af8f91-a000-4be3-bddd-cb1708cc5065.jpeg" width="52" id="fQUdE" class="ne-image"></p><p id="8ad1a4088531ca01eb309d6471ed829b" class="ne-p"><br></p><p id="ba3a0f736f53b26b9b6438df3ed2196e" class="ne-p"><code class="ne-code"><span class="ne-text">2021.05.06</span></code></p><p id="854af4395650d0eaf1e60c9604aa723e" class="ne-p"><br></p><p id="309036480d8044a52008b70a3f57daf7" class="ne-p"><span class="ne-text">上网搜了一下，缺爱还是有相应的词条的：</span><a href="https://baike.baidu.com/item/%E7%BC%BA%E7%88%B1/4544029" data-href="https://baike.baidu.com/item/%E7%BC%BA%E7%88%B1/4544029" target="_blank" class="ne-link"><span class="ne-text">缺爱·百度百科</span></a></p><p id="be6c6541496ec8a5c8f7af6c39009eb4" class="ne-p"><br></p><div class="ne-quote"><p id="6126e973de9910dd6b637453ae721b5c" class="ne-p"><span class="ne-text">缺爱：一般指缺少关爱的孩子的一种心情表现形式，着调于凄凉寂寞的非乐观主义。缺爱的孩子性格往往和普通孩子不一样，思想也成熟的早一点，但是较容易走极端。</span></p><p id="539c7177e3d4a0b69efe564377e2b866" class="ne-p"><span class="ne-text">——百度百科</span></p></div><p id="848ed0e6c1e965a5de024aa5242f0881" class="ne-p"><br></p><div class="ne-quote"><p id="d779548761360bf116198c8257ec7729" class="ne-p"><span class="ne-text">表现：缺爱的孩子性格往往和普通孩子不一样，思想也成熟的早一点，但是容易走极端，比较叛逆，一般能力较强，事业心强，但在内心里缺乏安全感，不论拥有再多，始终担忧如果有一天失去了怎么办。</span></p><p id="2945629b7787335af10a6fdcc5e8cde7" class="ne-p"><span class="ne-text">缺爱的孩子比较喜欢自己一个人不声不响的做事，性格比较孤僻，一般让人看上去会形容他“感觉这个人有很多心事”。</span></p></div><div class="ne-quote"><p id="bd3304777067eacab18ed6a98a3c989c" class="ne-p"><span class="ne-text">对于爱情，缺爱的孩子比较“慢热”，心里有恐惧感，害怕如果我投入了结果会怎样…… 但是一旦投入了，就会比较偏激的把自己认为好的全部给对方。不管这爱是亲情，友情，爱情，他都是全方位的去考虑去付出。因为他缺少爱，他全身心的付出内心里也是希望对方能像他一样全身心付出的对他好。如果没有得到期望中的回报或者被人所不屑，心中必然是由爱生恨，他们的爱恨往往比较极端。</span></p></div><div class="ne-quote"><p id="814a4210db2d23ca47878a7b60457bbc" class="ne-p"><span class="ne-text">单亲家庭的孩子、孤儿、重男轻女家庭的女儿、重小轻大家庭的大孩一般都会存在缺爱的现象，这是一个比较普遍的现象。</span></p></div><div class="ne-quote"><p id="e4c825fa0ab7b1e7c1360c4454dcf174" class="ne-p"><span class="ne-text">缺爱的孩子需要社会的关心，不然容易变坏，社会上这样的例子很多。</span></p><p id="8c622d0019853599e7fe8675b11dd46c" class="ne-p"><span class="ne-text">——百度百科</span></p></div></div>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>实验3——求LA和LB(用单链表表示)的并和交集🔖链表</title>
      <link href="/blog/tw2cvt/"/>
      <url>/blog/tw2cvt/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h2 id="kfwKY"><span class="ne-text">实验要求</span></h2><p id="fc77a305509589eb8e57f5dfb40b0283" class="ne-p"><span class="ne-text" style="font-size: 16px">求两个集合</span><span class="ne-text" style="font-size: 16px">LA</span><span class="ne-text" style="font-size: 16px">和</span><span class="ne-text" style="font-size: 16px">LB(</span><span class="ne-text" style="font-size: 16px">用单链表表示</span><span class="ne-text" style="font-size: 16px">)</span><span class="ne-text" style="font-size: 16px">的并和交集</span></p><p id="97cde14d07d55927cbe8c267732498e8" class="ne-p"><span class="ne-text" style="font-size: 16px">要求：在实验二的基础上，使用单链表表示集合。编写两个算法（求交算法和求并算法），并输出最终的结果。</span></p><p id="ead1e8e70488c4fe4831812a1ca80cd6" class="ne-p"><span class="ne-text" style="font-size: 16px">测试用例：集合</span><span class="ne-text" style="font-size: 16px">A</span><span class="ne-text" style="font-size: 16px">为</span><span class="ne-text" style="font-size: 16px">{3</span><span class="ne-text" style="font-size: 16px">，</span><span class="ne-text" style="font-size: 16px">4</span><span class="ne-text" style="font-size: 16px">，</span><span class="ne-text" style="font-size: 16px">1</span><span class="ne-text" style="font-size: 16px">，</span><span class="ne-text" style="font-size: 16px">6}</span><span class="ne-text" style="font-size: 16px">，集合</span><span class="ne-text" style="font-size: 16px">A</span><span class="ne-text" style="font-size: 16px">为</span><span class="ne-text" style="font-size: 16px">{2</span><span class="ne-text" style="font-size: 16px">，</span><span class="ne-text" style="font-size: 16px">3</span><span class="ne-text" style="font-size: 16px">，</span><span class="ne-text" style="font-size: 16px">6</span><span class="ne-text" style="font-size: 16px">，</span><span class="ne-text" style="font-size: 16px">7}</span><span class="ne-text" style="font-size: 16px">，</span></p><p id="bb2a51a2d8dae453e9cee5530fc5cf09" class="ne-p"><span class="ne-text" style="font-size: 16px">           </span><span class="ne-text" style="font-size: 16px">交集为</span><span class="ne-text" style="font-size: 16px">{3</span><span class="ne-text" style="font-size: 16px">，</span><span class="ne-text" style="font-size: 16px">6}</span></p><p id="16107b01f015db18e9dad1c123c47f6f" class="ne-p"><span class="ne-text" style="font-size: 16px">           </span><span class="ne-text" style="font-size: 16px">并集为</span><span class="ne-text" style="font-size: 16px">{1</span><span class="ne-text" style="font-size: 16px">，</span><span class="ne-text" style="font-size: 16px">2</span><span class="ne-text" style="font-size: 16px">，</span><span class="ne-text" style="font-size: 16px">3</span><span class="ne-text" style="font-size: 16px">，</span><span class="ne-text" style="font-size: 16px">4</span><span class="ne-text" style="font-size: 16px">，</span><span class="ne-text" style="font-size: 16px">6</span><span class="ne-text" style="font-size: 16px">，</span><span class="ne-text" style="font-size: 16px">7}</span></p><p id="a985b06473d654b3af94e60d4faaecb5" class="ne-p"><span class="ne-text" style="font-size: 16px">交作业时间：4月16日</span></p><h2 id="bRCZx"><span class="ne-text">实验代码</span></h2><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;<p>/**</p><ul><li>求两个集合LA和LB(用单链表表示)的并和交集</li><li>/</li></ul><p>/* 单链表的存储结构 */<br>typedef struct LNode &#123;<br>    int data; //数据域<br>    struct LNode *next; //指针域<br>&#125;Lnode, *LinkList; //LinkList为指向结构体LNode的指针类型</p><p>/* 初始化链表 */<br>void InitList(LinkList &amp;L) &#123;<br>    L = new LNode;<br>    L-&gt;next = NULL;<br>&#125;</p><p>/* 创建：后插 */<br>void CreateList_R(LinkList &amp;L, int n) &#123;<br>    cout &lt;&lt; &quot;请输入&quot; &lt;&lt; n &lt;&lt; &quot;个数字&quot;&lt;&lt; &quot;\n&quot;;<br>    InitList(L);<br>    // 定义一个在下面循环用来一直操作所加元素的结点p来指向头结点L<br>    LinkList p = L;<br>    for (int i = 0; i &lt; n;i++) &#123;<br>        LinkList q = new Lnode;<br>        q-&gt;next = NULL;<br>        cin &gt;&gt; q-&gt;data;<br>        p-&gt;next = q;<br>        p = q; //为了下一次<br>    &#125;<br>&#125;</p><p>/* 打印 */<br>void TraverseList(LinkList &amp; L)&#123;<br>        LinkList p = new LNode;<br>        p = L-&gt;next;<br>        cout &lt;&lt; &quot;此链表打印的结果为：&quot;&lt;&lt; &quot;\n&quot;;<br>        while (p != NULL)<br>        &#123;<br>            cout &lt;&lt; p-&gt;data &lt;&lt; &quot; &quot;;<br>            p = p-&gt;next;<br>        &#125;<br>        cout &lt;&lt; &quot;\n&quot;;<br>&#125;</p><p>/* 排序单链表 */<br>void sort(LinkList &amp;L) &#123;</p><p>&#125;</p><p>/* jiao算法 */<br>void jiao(LinkList &amp;A,LinkList &amp;B) &#123;<br>    // 用双循环得出共有的元素并输出<br>    LinkList p;<br>    InitList(p);<br>    A = A-&gt;next;<br>    B = B-&gt;next;<br>    while (A != NULL ) &#123;<br>        LinkList copy_b = B;<br>        while(copy_b != NULL) &#123;<br>            if (A-&gt;data == copy_b-&gt;data) &#123;<br>                LinkList temp = new Lnode;<br>                temp-&gt;data = copy_b-&gt;data;<br>                temp-&gt;next = p-&gt;next;<br>                p-&gt;next = temp;<br>                break;<br>            &#125; else &#123;<br>                copy_b = copy_b-&gt;next;<br>            &#125;<br>        &#125;<br>        A = A-&gt;next;<br>    &#125;</p><pre><code>while(p-&amp;gt;next != NULL) &#123;    cout &amp;lt;&amp;lt; p-&amp;gt;next-&amp;gt;data &amp;lt;&amp;lt; &amp;quot; &amp;quot;;    p = p-&amp;gt;next;&#125;</code></pre><p>}</p><p>/* bing算法 */<br>void bing(LinkList &amp;A,LinkList &amp;B) {<br>    LinkList p = A;<br>    LinkList s = B;</p><pre><code>A = A-&amp;gt;next;B = B-&amp;gt;next;while (A != NULL ) &#123;    LinkList copy_b = B;    while(copy_b != NULL) &#123;        if (A-&amp;gt;data == copy_b-&amp;gt;data) &#123;            // cout &amp;lt;&amp;lt; A-&amp;gt;data &amp;lt;&amp;lt; &amp;quot;\n&amp;quot;;            // 在p链里面删除A-&amp;gt;data值            LinkList q = p;            while(q-&amp;gt;next != NULL) &#123;                if (q-&amp;gt;next-&amp;gt;data == A-&amp;gt;data) &#123;                    q-&amp;gt;next = q-&amp;gt;next-&amp;gt;next;                    break;                &#125; else &#123;                    q = q-&amp;gt;next;                &#125;            &#125;            break;        &#125; else &#123;            copy_b = copy_b-&amp;gt;next;        &#125;    &#125;    A = A-&amp;gt;next;&#125;// 将p链表连接到s链表上LinkList result = p;while (p != NULL) &#123;    if (p-&amp;gt;next == NULL) &#123;        p-&amp;gt;next = s-&amp;gt;next;        break;    &#125;    p = p-&amp;gt;next;&#125;while(result-&amp;gt;next != NULL) &#123;    cout &amp;lt;&amp;lt; result-&amp;gt;next-&amp;gt;data &amp;lt;&amp;lt; &amp;quot; &amp;quot;;    result = result-&amp;gt;next;&#125;</code></pre><p>}</p><p>int main() {<br>    LinkList list_A;<br>    LinkList list_B;<br>    InitList(list_A);<br>    InitList(list_B);<br>    CreateList_R(list_A, 6);<br>    CreateList_R(list_B, 6);<br>    LinkList list_C = list_A;<br>    LinkList list_D = list_B;<br>    cout &lt;&lt;&quot;A、B交集的值为：&quot;;<br>    jiao(list_A, list_B);<br>    cout &lt;&lt;&quot;\n&quot;&lt;&lt;&quot;A、B并集的值为：&quot;;<br>    bing(list_C, list_D);<br>}<br></code></pre></p></div>]]></content>
      
      
      <categories>
          
          <category> 计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> Problems </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>“错的不是我，是这个世界”</title>
      <link href="/essay/lu9dks/"/>
      <url>/essay/lu9dks/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="9d6d26b32c5407fa409e22cc09422383" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1619799998545-a5718c40-08b7-4571-84a2-c79b4396d498.jpeg" width="2154" id="WX9p5" class="ne-image"></p><p id="u96b61946" class="ne-p"><br></p><p id="u3e997bfe" class="ne-p"><span class="ne-text">既不是喰种也不是人类，与既是喰种又是人类，怎么选呢？</span></p><p id="u2e8b020d" class="ne-p"><span class="ne-text">不谙世事所带来的就是单纯与洁白</span></p><p id="u6768765b" class="ne-p"><span class="ne-text"></span></p><p id="u6027b438" class="ne-p"><span class="ne-text">英对好友金木敏锐的反应真的是关心与从小而来的感情之深。</span></p><p id="uf33262fa" class="ne-p"><br></p><div class="ne-quote"><p id="uc691bd7b" class="ne-p"><span class="ne-text">咖啡的味道会随着人们花费于其中的精力而变</span></p><p id="uaf790a20" class="ne-p"><span class="ne-text">人做事也是如此，你不用太着急</span></p></div><p id="u67365225" class="ne-p"><span class="ne-text">所有人都认为是对的事情，不一定是对的，而有些错误的事情，的确掌握在少数人手上</span></p><p id="ubc53c7bf" class="ne-p"><span class="ne-text"></span></p><p id="u27fb74dd" class="ne-p"><span class="ne-text">呗先生说的一句话：“金木没有恋人吗  比起同龄的女性  更喜欢被年长的姐姐疼爱把”，这也的确点明金木从小缺爱的身世。</span></p><p id="u7df1d4ec" class="ne-p"><br></p><p id="ub0375c15" class="ne-p"><span class="ne-text">稚实和董香应该都是内心非常可爱的女孩子把，从小经历生死颠簸坎坷的生活与环境，能保持这么一点可爱的童心真的很不容易。</span></p><p id="ucf45e830" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1642409420043-064162ee-0226-4957-bb9e-2d0b8050ec57.png" width="1920" id="ub936c96a" class="ne-image"></p><p id="u27a23963" class="ne-p"><br></p><h3 id="kdQTp"><span class="ne-text">致终章</span></h3><div class="ne-quote"><p id="u1208d7d3" class="ne-p"><span class="ne-text">不……不是我的错</span></p><p id="ueb12282f" class="ne-p"><span class="ne-text">不对  都是我  都是我的错</span></p></div><p id="u1a9e88c4" class="ne-p"><br></p><div class="ne-quote"><p id="u9b3ef655" class="ne-p"><span class="ne-text">事到如今  你还在说这么显而易见的事实</span></p><p id="u08514cc6" class="ne-p"><span class="ne-text">你就像这样责备自己  不断地责备自己</span></p></div><p id="u246dd462" class="ne-p"><br></p><div class="ne-quote"><p id="uf0a4fa9b" class="ne-p"><span class="ne-text">只是一味地责备自己  结果一点也没有改变</span></p><p id="u204c6fa1" class="ne-p"><span class="ne-text">变成这样到底是谁的错</span></p><p id="u3e87d74f" class="ne-p"><span class="ne-text">偶然  事故  运气</span></p><p id="uaa0b7fc8" class="ne-p"><strong><span class="ne-text">运气是不存在的  那只是情况和情况的不同组合</span></strong></p><p id="u19d69df4" class="ne-p"><span class="ne-text">那又是谁制造了这种情况  是谁呢？</span></p><p id="u7c5af00f" class="ne-p"><span class="ne-text">就是你啊</span></p><p id="u990aab69" class="ne-p"><strong><span class="ne-text">世界上所有的不利因素都是因为当事人的能力不足</span></strong></p></div><p id="ua98c32e0" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1618470547319-c45591d3-8c94-4a78-8e1d-83174784522b.png" width="960" id="u3e621b1a" class="ne-image"></p><p id="uf2bd473c" class="ne-p"><br></p><div class="ne-quote"><p id="ud1eb8702" class="ne-p"><span class="ne-text">事实如此</span></p><p id="ud1bfe9b8" class="ne-p"><span class="ne-text">话说回来  一切的开端</span></p><p id="uc7feaa6c" class="ne-p"><strong><span class="ne-text">也就是因为你是一个不谙世事的笨蛋啊</span></strong></p><p id="u700a4ca5" class="ne-p"><span class="ne-text">因为你是笨蛋  然后被我欺骗</span></p><p id="u28786c7d" class="ne-p"><span class="ne-text">还被医生动了手脚</span></p><p id="u8193f59a" class="ne-p"><span class="ne-text">所以变成了怪物</span></p></div><p id="u41d38080" class="ne-p"><br></p><div class="ne-quote"><p id="u14d42fe1" class="ne-p"><span class="ne-text">全部都是你的错</span></p><p id="u73565b64" class="ne-p"><span class="ne-text">于其伤害他人  不如成为被伤害的那一方</span></p><p id="uef9eba06" class="ne-p"><span class="ne-text">所以你遇到这种事</span></p><p id="udd24419e" class="ne-p"><span class="ne-text">如果你足够强到能够杀死壁虎的话</span></p><p id="uc3b27f60" class="ne-p"><span class="ne-text">那两人就能得救了哦</span></p><p id="ub5b0621e" class="ne-p"><span class="ne-text">或者如果你选择了男人的话  那个女人就可能得救了</span></p><p id="u7ad4f9f7" class="ne-p"><span class="ne-text">那个时候也是如此</span></p><p id="u7e162a96" class="ne-p"><strong><span class="ne-text">如果你有足够实力的话</span></strong></p></div><p id="u1f9eb97c" class="ne-p"><br></p><p id="u4e68e398" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1618470834142-4bea4e83-48a2-41fd-9246-e1f0b27c04e5.png" width="960" id="u8e685db7" class="ne-image"></p><p id="u0ae4fd4a" class="ne-p"><br></p><div class="ne-quote"><p id="u12ce4896" class="ne-p"><span class="ne-text">从今往后也一样</span></p><p id="u7b3fb88b" class="ne-p"><span class="ne-text">董香  雏实  英  </span></p><p id="uf2880180" class="ne-p"><span class="ne-text">你所珍视的人</span></p></div><p id="u902d8b8b" class="ne-p"><br></p><div class="ne-quote"><p id="u31cf0e26" class="ne-p"><span class="ne-text">明白了吗</span></p><p id="u424f8eed" class="ne-p"><span class="ne-text">这就是你所选择的生活方式</span></p><p id="u2791fd54" class="ne-p"><span class="ne-text">你所选择的未来啊</span></p><p id="u405d9cc8" class="ne-p"><span class="ne-text">为什么要哭泣呢  为什么要呐喊呢</span></p><p id="u34e8514d" class="ne-p"><span class="ne-text">与其伤害他人  你选择成为被伤害的那一方不是吗</span></p><p id="ue2a9d257" class="ne-p"><span class="ne-text">既温柔又美好</span></p><p id="uac21108b" class="ne-p"><span class="ne-text">看似你两者都选择了</span></p><p id="udbc70cee" class="ne-p"><span class="ne-text">但实际上你两者都失去了</span></p><p id="u36f705f0" class="ne-p"><span class="ne-text">你的母亲也是如此</span></p></div><p id="u2fe0846b" class="ne-p"><br></p><div class="ne-quote"><p id="u436173b3" class="ne-p"><span class="ne-text">你其实也希望她这么做吧</span></p><p id="u28728406" class="ne-p"><span class="ne-text">请你……不要再说了</span></p></div><p id="u0ef17453" class="ne-p"><br></p><div class="ne-quote"><p id="ua534ce78" class="ne-p"><span class="ne-text">为什么</span></p><p id="u66a48a5a" class="ne-p"><span class="ne-text">为什么留下我一个人</span></p><p id="ub3cc6355" class="ne-p"><span class="ne-text">我不要孤单一人</span></p><p id="ub51c3e6c" class="ne-p"><span class="ne-text">我好希望你能够选择我啊</span></p></div><p id="u05930376" class="ne-p"><br></p><div class="ne-quote"><p id="uf49eacd3" class="ne-p"><span class="ne-text">没错  金木</span></p><p id="u6dfde17f" class="ne-p"><strong><span class="ne-text">『每个人都有必须舍弃某一边才能保护重要事物的时刻』</span></strong></p></div><p id="u70555b21" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1618471315132-4f0b9cc2-ba10-4c59-8c6f-73475002e472.png" width="960" id="u5f1533bb" class="ne-image"></p><p id="u33115feb" class="ne-p"><br></p><div class="ne-quote"><p id="u41c7c5a0" class="ne-p"><strong><span class="ne-text">没做到这一点  只是软弱罢了</span></strong></p><p id="u75ef3085" class="ne-p"><strong><span class="ne-text">没有舍弃的坚强  缺乏深刻的觉悟</span></strong></p><p id="u9857e086" class="ne-p"><span class="ne-text">你还能继续做被伤害的那一方吗</span></p><p id="u102bc79c" class="ne-p"><span class="ne-text">你还能原谅壁虎这种人吗</span></p></div><p id="u27678e24" class="ne-p"><br></p><div class="ne-quote"><p id="ud726279d" class="ne-p"><span class="ne-text">无法……无法原谅</span></p></div><p id="u2a11cbc4" class="ne-p"><br></p><div class="ne-quote"><p id="u97512d74" class="ne-p"><span class="ne-text">你最重要的英  还有安定区的同伴们</span></p><p id="u079c5634" class="ne-p"><span class="ne-text">都有可能遇到那种事</span></p></div><p id="u3907bb53" class="ne-p"><br></p><p id="ub5752ca7" class="ne-p"><br></p><div class="ne-quote"><p id="ufd611f74" class="ne-p"><strong><span class="ne-text">你拥有做到这些的力量吗</span></strong></p><p id="u23c23957" class="ne-p"><strong><span class="ne-text">我有…</span></strong></p><p id="u3680cb80" class="ne-p"><strong><span class="ne-text">那也就是你要接受我的意思吗</span></strong></p><p id="u8796a7ba" class="ne-p"><strong><span class="ne-text">不对</span></strong></p><p id="ud18a180c" class="ne-p"><strong><span class="ne-text">并不是这样</span></strong></p><p id="u9bce2c3b" class="ne-p"><strong><span class="ne-text">我只要超越你就好了</span></strong></p><p id="u3c07236f" class="ne-p"><strong><span class="ne-text">即使这是错误的选择也没关系吗</span></strong></p><p id="u8eca6478" class="ne-p"><strong><span class="ne-text" style="color: #F5222D">『错的人不是我   错误的是…这个世界』</span></strong></p></div><p id="u78887dd7" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1618471631139-459ab7b1-8de4-439a-ba90-47ec64a973db.png" width="960" id="u359998a2" class="ne-image"></p><p id="ud33c5f4e" class="ne-p"><br></p><p id="u52478afc" class="ne-p"><br></p><p id="ud1a2ce0b" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1618471714779-46f493f2-f76d-4ae8-8016-82a8acc51e66.png" width="960" id="u0b809119" class="ne-image"></p><p id="u786832fe" class="ne-p"><br></p><p id="u98d514cc" class="ne-p"><br></p><p id="uf4dec34a" class="ne-p"><br></p><div id="iBfRz" class="ne-thirdparty"><a href="https://music.163.com/outchain/player?type=2&amp;id=29017078&amp;auto=0&amp;height=66">https://music.163.com/outchain/player?type=2&amp;id=29017078&amp;auto=0&amp;height=66</a></div><p id="ub2437acf" class="ne-p"><br></p><p id="uf1d37ecd" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1618472037932-fcffb7e6-0ca2-4f68-9c3d-52d865fd05ca.png" width="960" id="u82016ac2" class="ne-image"></p><p id="u45031f57" class="ne-p"><br></p><pre><code>教えて 教えてよその仕組みを僕の中に誰がいるの？壊れた 壊れたよこの世界で君が笑う何も見えずに壊れた僕なんてさ息を止めてほどけない もう ほどけないよ真実さえ freeze壊せる 壊せない狂える 狂えないあなたを見つけて 揺れた歪んだ世界にだんだん僕は透き通って見えなくなって見つけないで 僕のことを見つめないで誰かが描いた世界の中であなたを傷つけたくはないよ覚えていて 僕のことを鮮やかなまま無限に広がる孤独が絡まる無邪気に笑った記憶が刺さって動けない 動けない動けない 動けない動けない 動けないよUnravelling the world変わってしまった 変えられなかった2つが絡まる 2人が滅びる壊せる 壊せない狂える 狂えないあなたを汚せないよ 揺れた歪んだ世界にだんだん僕は透き通って見えなくなって見つけないで 僕のことを見つめないで誰かが仕組んだ孤独な罠に未来がほどけてしまう前に思い出して 僕のことを鮮やかなまま忘れないで 忘れないで忘れないで 忘れないで変わってしまったことに paralyze変えられないことだらけの paradise覚えていて 僕のことを教えて教えて僕の中に誰がいるの？</code></pre></div>]]></content>
      
      
      <categories>
          
          <category> 影视 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>art-template模板</title>
      <link href="/blog/qhgult/"/>
      <url>/blog/qhgult/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content-editor-core lake-engine lake-typography-classic" data-lake-element="root" data-selection-undefined="%7B%22path%22%3A%5B%5B2%2C0%2C1%2C0%2C17%5D%2C%5B2%2C0%2C1%2C0%2C17%5D%5D%2C%22active%22%3Atrue%7D"><h2 data-lake-id="61b71090e71a42cd9513389859fdaf25" id="b2N2J" style="padding: 7px 0px; margin: 0px; font-weight: 700; font-size: 24px; line-height: 32px;">art-template和express-art-template</h2><blockquote class="lake-alert lake-alert-info" style="background-color: rgb(232, 247, 255); margin: 0px; padding: 10px; border: 1px solid rgb(171, 210, 218); opacity: 1; border-radius: 3px; color: rgb(38, 38, 38);"><p data-lake-id="e81fb9afc377a89ff77e62472fe6888f" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">为了是art-template模板引擎能够更好地和Express框架配合，模板引擎官方在源art-template模板引擎的基础上封装了express-art-template，所以在使用Espress框架时候，这两个模块都要下载。</p></blockquote><ul data-lake-id="d11b77d0fb802a8689d4d183e4a0866d" lake-indent="0" style="list-style-type: disc; margin: 0px; padding-left: 23px; font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word;"><li data-lake-id="3adfd7ff7ffa142abbd0994e6cd1fdc2">art-template官网：<a href="https://aui.github.io/art-template/zh-cn/docs/" target="_blank">https://aui.github.io/art-template/zh-cn/docs/</a></li><li data-lake-id="f3aa99eabfbe9ef89236ea72110834cc">关于模板引擎：<a href="https://segmentfault.com/a/1190000020478061" target="_blank">6个常见JS模板引擎</a></li></ul><h3 data-lake-id="5337312138fc9083ee298b8ca1b92d85" id="F4gaD" style="padding: 7px 0px; margin: 0px; font-weight: 700; font-size: 20px; line-height: 28px;">使用模板渲染情况下声明</h3><div data-card-type="block" data-lake-card="codeblock" id="bmkAD" class="lake-card-margin" data-language="javascript"><div class="lake-codeblock-content" style="border: 1px solid rgb(232, 232, 232); max-width: 750px; color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: rgb(249, 249, 249);"><div class="CodeMirror-sizer" style="color: rgb(89, 89, 89); margin: 0px; padding: 16px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"><pre class="cm-s-default" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"><span class="lake-preview-line" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"><span class="lake-preview-line-number lake-lm-pad-level-0" style="color: rgb(191, 191, 191); margin: 0px 8px 0px 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"></span><span class="lake-preview-codeblock-content" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"><span class="cm-comment" style="color: rgb(106, 115, 125); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">// 渲染后缀为art的模板时，所使用的模板引擎是什么</span></span></span><span class="lake-preview-line" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"><span class="lake-preview-line-number lake-lm-pad-level-0" style="color: rgb(191, 191, 191); margin: 0px 8px 0px 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"></span><span class="lake-preview-codeblock-content" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"><span class="cm-variable" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">app</span>.<span class="cm-property" style="color: rgb(0, 92, 197); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">engine</span>(<span class="cm-string" style="color: rgb(102, 153, 0); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">'art'</span>, <span class="cm-variable" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">require</span>(<span class="cm-string" style="color: rgb(102, 153, 0); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">'express-art-template'</span>));</span></span><span class="lake-preview-line" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"><span class="lake-preview-line-number lake-lm-pad-level-0" style="color: rgb(191, 191, 191); margin: 0px 8px 0px 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"></span><span class="lake-preview-codeblock-content" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"><span class="cm-comment" style="color: rgb(106, 115, 125); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">// 告诉express框架模板的位置</span></span></span><span class="lake-preview-line" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"><span class="lake-preview-line-number lake-lm-pad-level-0" style="color: rgb(191, 191, 191); margin: 0px 8px 0px 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"></span><span class="lake-preview-codeblock-content" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"><span class="cm-variable" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">app</span>.<span class="cm-property" style="color: rgb(0, 92, 197); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">set</span>(<span class="cm-string" style="color: rgb(102, 153, 0); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">'views'</span>, <span class="cm-variable" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">path</span>.<span class="cm-property" style="color: rgb(0, 92, 197); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">join</span>(<span class="cm-variable" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">__dirname</span>, <span class="cm-string" style="color: rgb(102, 153, 0); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">'views'</span>))</span></span><span class="lake-preview-line" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"><span class="lake-preview-line-number lake-lm-pad-level-0" style="color: rgb(191, 191, 191); margin: 0px 8px 0px 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"></span><span class="lake-preview-codeblock-content" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"><span class="cm-comment" style="color: rgb(106, 115, 125); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">// 告诉express框架模板的默认后缀是什么</span></span></span><span class="lake-preview-line" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"><span class="lake-preview-line-number lake-lm-pad-level-0" style="color: rgb(191, 191, 191); margin: 0px 8px 0px 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"></span><span class="lake-preview-codeblock-content" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);"><span class="cm-variable" style="color: rgb(89, 89, 89); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">app</span>.<span class="cm-property" style="color: rgb(0, 92, 197); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">set</span>(<span class="cm-string" style="color: rgb(102, 153, 0); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">'view engine'</span>, <span class="cm-string" style="color: rgb(102, 153, 0); margin: 0px; padding: 0px; background: none 0% 0% / auto repeat scroll padding-box border-box rgba(0, 0, 0, 0);">'art'</span>);</span></span></pre></div></div></div><h3 data-lake-id="c0f2b06f951eab51f4b60847af75cc8b" id="eTsmx" style="padding: 7px 0px; margin: 0px; font-weight: 700; font-size: 20px; line-height: 28px;">关于绝对/相对路径的引用</h3><p data-lake-id="ee887858624d1b0690c72bd8607b9490" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><strong><span>模板资源里面引用静态资源的路径要用绝对路径</span></strong><span>。怎么使用绝对路径呢，类似hexo静态博客一样，前面加一个“/”即可是根目录路径下，再进行根目录路径下路径写法</span></p></div>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
          <category> Node.js </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>应用层下的域名系统DNS</title>
      <link href="/blog/lz0ywx/"/>
      <url>/blog/lz0ywx/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content-editor-core lake-engine lake-typography-classic" data-lake-element="root" data-selection-undefined="%7B%22path%22%3A%5B%5B0%2C0%2C0%5D%2C%5B0%2C0%2C0%5D%5D%2C%22active%22%3Atrue%7D"><p data-lake-id="e851aae42d65745b0d683eb5c9f38726" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">域名系统DNS的作用就是域名解析为IP地址，因为在网络中传输的是字节，从之前学过的报文结构就可以得知，但是为何不直接在报文中直接传输域名呢？因为IP地址长度是固定的32位（如果是IPV6就是固定的128位），而域名长度不是固定长度的，及其处理比较困难。所以将域名解析成IP地址这个任务就交给了域名服务器了。</p><p data-lake-id="6be2ebd7d69e4dda7aab539619d76c3b" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><h2 data-lake-id="2b20760eff31b899c1219d589dfaeb38" id="4WKcd" style="padding: 7px 0px; margin: 0px; font-weight: 700; font-size: 24px; line-height: 32px;">理解什么是域名服务器？</h2><p data-lake-id="1cc5df2045c13e41c651fe6812d3b2b4" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">域名服务器构成了DNS中的分布式网络系统，其功能主要是为内外主机提供域名与IP地址的互相解析映射服务。域名服务器分布在互联网的各子网中，每个域名服务器负责管理连接到本子网的所有主机，并为其提供服务。</p><p data-lake-id="93b03fc108af5fac7292ba6ab353e54c" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="b89c451d28c2ebb7a55f664cf8147253" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="a9fca39e81541c5c9665eecfa5e909ee" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span data-card-type="inline" data-lake-card="image" class="lake-card-margin-top lake-card-margin-bottom"><img data-role="image" src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1618645215420-4ee27962-12d4-467b-81e6-f932e4c82a2a.png" data-raw-src="" class="image lake-drag-image" alt="image.png" title="image.png" data-height="226px" style="visibility: visible; width: 545px;"></span></p><p data-lake-id="f9d06677dbad14dff6fdf4e0744cfd33" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">域名服务器分为上面所表示的根域名服务器、顶级域名服务器、权限域名服务器、还有本地域名服务器（在本地电脑里面）</p><h3 data-lake-id="7e0a561a8c3968a46230625423fff0c1" id="a1FJu" style="padding: 7px 0px; margin: 0px; font-weight: 700; font-size: 20px; line-height: 28px;">关于本地域名服务器</h3><p data-lake-id="83ac8606dda70819aa90179b895d0785" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">本地电脑就有</p><p data-lake-id="5d071c8c1f140fd228aa2dcbfd45eae5" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span data-card-type="inline" data-lake-card="image" class="lake-card-margin-top lake-card-margin-bottom"><img data-role="image" src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1618647707183-7e8f7af0-a3ab-455b-b702-18f82644471b.png" data-raw-src="" class="image lake-drag-image" alt="image.png" title="image.png" data-height="398px" style="visibility: visible; width: 331px;"></span></p><h3 data-lake-id="cc532d2ef47892e3d60a6128246a56c8" id="UGxo5" style="padding: 7px 0px; margin: 0px; font-weight: 700; font-size: 20px; line-height: 28px;">关于根域名服务器</h3><blockquote style="padding-left: 1em; margin-top: 5px; margin-bottom: 5px; margin-left: 0px; border-left: 3px solid rgb(238, 238, 238); opacity: 0.6;"><p data-lake-id="64679f4246c6f2c8f8f18602cb31f390" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">关于根域名服务器，这里面有个有趣的话题，参考这篇文章：</p><p data-lake-id="66ff46e7fac8c1d721a2f1026281a27b" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><a href="https://segmentfault.com/a/1190000023696737" target="_blank">美国如果把根域名服务器封了，中国会从网络上消失？</a></p></blockquote><h2 data-lake-id="dc9f03115bf131a979cc8f96aa024b51" id="4B7Ww" style="padding: 7px 0px; margin: 0px; font-weight: 700; font-size: 24px; line-height: 32px;">理解什么是域名注册商？</h2><blockquote style="padding-left: 1em; margin-top: 5px; margin-bottom: 5px; margin-left: 0px; border-left: 3px solid rgb(238, 238, 238); opacity: 0.6;"><p data-lake-id="adfedbee81dfb532339a7cf2ce133800" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">域名服务器之所以能知道域名与 IP 地址的映射信息，是因为我们在域名服务商那里提交了域名记录。购买了一个域名之后，我们需要在域名服务商那里设置域名解析的记录，域名服务商把这些记录推送到权威域名服务器，这样我们的域名才能正式生效。</p><p data-lake-id="f5c2d8e7621afe29f08a554fc85b5eb1" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">常见的域名服务商有阿里云、腾讯云等等……</p></blockquote><p data-lake-id="ed2d627e039df479e28204f746a09736" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><h3 data-lake-id="0b6a493bd3b95a64eee229ed099d4e48" id="SSnav" style="padding: 7px 0px; margin: 0px; font-weight: 700; font-size: 20px; line-height: 28px;">注册域名注册商</h3><p data-lake-id="76f57c7e99c0dc75a6e571d973945d3c" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">要成为域名注册商需要提权，具体参考：<a href="https://baike.baidu.com/item/%E5%9F%9F%E5%90%8D%E6%B3%A8%E5%86%8C%E5%95%86" target="_blank">https://baike.baidu.com/item/%E5%9F%9F%E5%90%8D%E6%B3%A8%E5%86%8C%E5%95%86</a></p><p data-lake-id="06be4f72f91ac2dde73f73b3bbf46051" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span data-card-type="inline" data-lake-card="image" class="lake-card-margin-top lake-card-margin-bottom"><img data-role="image" src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1618646601711-fca612d8-b2cd-4c22-8417-5938c415c7ce.png" data-raw-src="" class="image lake-drag-image" alt="image.png" title="image.png" data-height="85px" style="visibility: visible; width: 532px;"></span></p><h3 data-lake-id="004bc62474ceb180c59870df62f03064" id="KiHSB" style="padding: 7px 0px; margin: 0px; font-weight: 700; font-size: 20px; line-height: 28px;">ICANN</h3><p data-lake-id="4c9ca4772d8e63100012dc5fb1a91a45" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">『互联网名称与数字地址分配机构』</p><p data-lake-id="24609c832d6f348497c178acd6cf2dab" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">可以看看发展历程</p><p data-lake-id="97b91b88d06c1a605a293875fbecabf3" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span data-card-type="inline" data-lake-card="image" class="lake-card-margin-top lake-card-margin-bottom"><img data-role="image" src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1618646847974-89e834aa-7e05-4788-aebb-ac3a084362e4.png" data-raw-src="" class="image lake-drag-image" alt="image.png" title="image.png" data-height="382px" style="visibility: visible; width: 553.5px;"></span></p><p data-lake-id="e4f1cda3459a5b5b0c247267f85eac42" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">不仅如此，包含全球的域名相关信息的ICANN的数据库管控方式也是极为严格，</p><p data-lake-id="9e7f3f82f476a2f40719f5e0af18eef8" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span data-card-type="inline" data-lake-card="image" class="lake-card-margin-top lake-card-margin-bottom"><img data-role="image" src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1618646929122-b3d35ad5-9a28-4fd2-a56f-1b7164cd51ff.png" data-raw-src="" class="image lake-drag-image" alt="image.png" title="image.png" data-height="242px" style="visibility: visible; width: 555.5px;"></span></p><p data-lake-id="9056b8917ea83736ad7c0873a0fc9b8e" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">像极了电影里面的情节<span data-card-type="inline" data-lake-card="image" class="lake-card-margin-top lake-card-margin-bottom"><img data-role="image" src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1618646983840-652fc715-3b53-427d-9722-86890ccbe07a.jpeg" data-raw-src="" class="image lake-drag-image" alt="huaji1558a846ddf2e12b.jpeg" title="huaji1558a846ddf2e12b.jpeg" data-height="59px" style="visibility: visible; width: 55px;"></span></p><p data-lake-id="98c8450eeafbd5e497108e18580d79b8" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">具体参考：<a href="https://baike.baidu.com/item/%E4%BA%92%E8%81%94%E7%BD%91%E5%90%8D%E7%A7%B0%E4%B8%8E%E6%95%B0%E5%AD%97%E5%9C%B0%E5%9D%80%E5%88%86%E9%85%8D%E6%9C%BA%E6%9E%84/2775450?fromtitle=ICANN&amp;fromid=6807198" target="_blank">https://baike.baidu.com/item/%E4%BA%92%E8%81%94%E7%BD%91%E5%90%8D%E7%A7%B0%E4%B8%8E%E6%95%B0%E5%AD%97%E5%9C%B0%E5%9D%80%E5%88%86%E9%85%8D%E6%9C%BA%E6%9E%84/2775450?fromtitle=ICANN&amp;fromid=6807198</a></p><p data-lake-id="3634e4e1e97dbc2d2c0264d33ab6e04d" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><h2 data-lake-id="4abf672446cb6fe5eaf462baa4f8bcc3" id="59xby" style="padding: 7px 0px; margin: 0px; font-weight: 700; font-size: 24px; line-height: 32px;">域名解析过程</h2><p data-lake-id="71a80dbdbfd5889f40353a3a80b66a3c" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><blockquote class="lake-alert lake-alert-info" style="background-color: rgb(232, 247, 255); margin: 0px; padding: 10px; border: 1px solid rgb(171, 210, 218); opacity: 1; border-radius: 3px; color: rgb(38, 38, 38);"><p data-lake-id="f19f6e4e3c9b012ea32ed4cc472712d7" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">了解了上面一些DNS宏观的设计方式，再来到域名解析就比较好理解了，域名解析就是将域名解析为IP地址，它怎么解析呢？利用在域名服务器里面查找有没有相关的解析记录。</p></blockquote><p data-lake-id="3a46bb7b8be5f903df7b243a4f66381f" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="10fc7258fdc590421f837ccdd5f460e9" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span data-card-type="inline" data-lake-card="image" class="lake-card-margin-top lake-card-margin-bottom"><img data-role="image" src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1618647354829-7da7d070-ba2e-404d-937d-45dcfb2faf25.png" data-raw-src="" class="image lake-drag-image" alt="image.png" title="image.png" data-height="329px" style="visibility: visible; width: 646.5px;"></span></p><p data-lake-id="f0d402c626b6a0792e62b7d6ea8d8f7a" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span data-card-type="inline" data-lake-card="image" class="lake-card-margin-top lake-card-margin-bottom"><img data-role="image" src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1618647396384-6ec5030a-0fdf-46c5-9ebb-1d257d92f2c9.png" data-raw-src="" class="image lake-drag-image" alt="image.png" title="image.png" data-height="333px" style="visibility: visible; width: 471.5px;"></span></p><h2 data-lake-id="66a563b6690fbe174ae4beb11e40739d" id="7Elhd" style="padding: 7px 0px; margin: 0px; font-weight: 700; font-size: 24px; line-height: 32px;">使用工具查看DNS查询过程</h2><h3 data-lake-id="d25b2b925de1038ee94bcc037a16cf1d" id="fuhq6" style="padding: 7px 0px; margin: 0px; font-weight: 700; font-size: 20px; line-height: 28px;">Linux下的dig命令</h3><p data-lake-id="3a937ee6b6bc4b2c91ddb33518ce531b" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span data-card-type="inline" data-lake-card="image" class="lake-card-margin-top lake-card-margin-bottom"><img data-role="image" src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1618649698238-46345e66-fccd-4ad5-b99c-76db7072c62f.png" data-raw-src="" class="image lake-drag-image" alt="image.png" title="image.png" data-height="360px" style="visibility: visible; width: 720px;"></span></p><h3 data-lake-id="ef503ad3f8edfe300c6f97d22ab47f3a" id="VGQRU" style="padding: 7px 0px; margin: 0px; font-weight: 700; font-size: 20px; line-height: 28px;">Windows下的trance命令</h3><p data-lake-id="984c3f3cbc5a4292ba60871d988d97e8" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><span data-card-type="inline" data-lake-card="image" class="lake-card-margin-top lake-card-margin-bottom"><img data-role="image" src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1618649719833-b58925d7-4a25-4bdc-897b-e7bb281efed5.png" data-raw-src="" class="image lake-drag-image" alt="image.png" title="image.png" data-height="360px" style="visibility: visible; width: 720px;"></span></p><p data-lake-id="5e639c59243b33bb22120546f13a53c4" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><h2 data-lake-id="2ccbd3230b7ec01b60999276b4935e05" id="zlv4P" style="padding: 7px 0px; margin: 0px; font-weight: 700; font-size: 24px; line-height: 32px;">参考</h2><ul data-lake-id="9506c2ac3a1f5e61b993e4a5211b1929" lake-indent="0" style="list-style-type: disc; margin: 0px; padding-left: 23px; font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word;"><li data-lake-id="88c500237bd998872be26826ce7e62c7"><a href="https://github.com/ruanyf/articles/blob/master/2016/2016-06-15-dns.md" target="_blank">DNS 原理入门 - 阮一峰的网络日志</a></li><li data-lake-id="1473e4390fa9183575fc62148041d58b"><a href="https://segmentfault.com/a/1190000023696737" target="_blank">https://segmentfault.com/a/1190000023696737</a></li><li data-lake-id="fbafc64d00d65323ec9d045a47070dd8"><a href="https://baike.baidu.com/item/%E5%9F%9F%E5%90%8D%E6%B3%A8%E5%86%8C%E5%95%86" target="_blank">https://baike.baidu.com/item/%E5%9F%9F%E5%90%8D%E6%B3%A8%E5%86%8C%E5%95%86</a></li><li data-lake-id="146e25f3e8343119b2922eb9d154a4c9"><a href="https://baike.baidu.com/item/%E4%BA%92%E8%81%94%E7%BD%91%E5%90%8D%E7%A7%B0%E4%B8%8E%E6%95%B0%E5%AD%97%E5%9C%B0%E5%9D%80%E5%88%86%E9%85%8D%E6%9C%BA%E6%9E%84/2775450?fromtitle=ICANN&amp;fromid=6807198" target="_blank">https://baike.baidu.com/item/%E4%BA%92%E8%81%94%E7%BD%91%E5%90%8D%E7%A7%B0%E4%B8%8E%E6%95%B0%E5%AD%97%E5%9C%B0%E5%9D%80%E5%88%86%E9%85%8D%E6%9C%BA%E6%9E%84/2775450?fromtitle=ICANN&amp;fromid=6807198</a></li></ul></div>]]></content>
      
      
      <categories>
          
          <category> 计算机素养 </category>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>客户端存储</title>
      <link href="/blog/bzdwkx/"/>
      <url>/blog/bzdwkx/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h3 id="bt5VO"><span class="ne-text">本地存储特性</span></h3><ul class="ne-ul"><li id="fe1e67d146dcba84053c3ed73416e503"><span class="ne-text">数据存储在用户浏览器中</span></li><li id="694d4c336287d21891a48c1585df9167"><span class="ne-text">设置、读取方便、甚至页面刷新不丢失数据</span></li><li id="9e0c681e5ab26d20e35a98ee55ab923e"><span class="ne-text">容量较大，</span><code class="ne-code"><span class="ne-text">sessionStorage</span></code><span class="ne-text">约</span><code class="ne-code"><span class="ne-text">5M</span></code><span class="ne-text">、</span><code class="ne-code"><span class="ne-text">localStorage</span></code><span class="ne-text">约</span><code class="ne-code"><span class="ne-text">20M</span></code></li><li id="b4c20b4d476feaa8701afb77bc733fd2"><span class="ne-text">只能存储字符串，可以将对象</span><code class="ne-code"><span class="ne-text">JSON.stringify()</span></code><span class="ne-text">编码后存储，然后使用的使用</span><code class="ne-code"><span class="ne-text">JSON.parse()</span></code><span class="ne-text">转换回对象</span></li></ul><h3 id="0VYws"><span class="ne-text">window.sessionStorage</span></h3><p id="4fbc447b4ea9f2038b2724db70d01ac3" class="ne-p"><span class="ne-text">1、生命周期为关闭浏览器窗口</span></p><p id="ccbbbcff305024a4dcdaaba7a6fafb46" class="ne-p"><span class="ne-text">2、在同一个窗口(页面)下数据可以共享</span></p><p id="a89a782ba947bdd860fc28e00b0ec836" class="ne-p"><span class="ne-text">3、以键值对的形式存储使用</span></p><p id="0d5a24edd5013b2b523b7556c60b3a03" class="ne-p"><span class="ne-text">存储数据：</span></p><pre><code>sessionStorage.setItem(key, value)</code></pre><p id="378124830a6c00a1292d88c4290e2e3a" class="ne-p"><span class="ne-text">获取数据：</span></p><pre><code>sessionStorage.getItem(key)</code></pre><p id="de29b3a1eac52596c4d6ad3477a15da7" class="ne-p"><span class="ne-text">删除数据：</span></p><pre><code>sessionStorage.removeItem(key)</code></pre><p id="1e38450b9673a6b54d83ef06310d138d" class="ne-p"><span class="ne-text">清空数据：(所有都清除掉)</span></p><pre><code>sessionStorage.clear()</code></pre><h3 id="W0req"><span class="ne-text">window.localStorage</span></h3><p id="a007e6a71e5ca794e958969ddef8bdba" class="ne-p"><span class="ne-text">1、声明周期永久生效，除非手动删除 否则关闭页面也会存在</span></p><p id="6a425f93f4e0f02acb3258b01229e6ab" class="ne-p"><span class="ne-text">2、可以多窗口（页面）共享（同一浏览器可以共享）</span></p><p id="a518a54105653ec1d50b49829412919b" class="ne-p"><span class="ne-text">3.  以键值对的形式存储使用</span></p><p id="1484f30a6a428ec7aa94550ad64b0dfe" class="ne-p"><span class="ne-text">存储数据：</span></p><pre><code>localStorage.setItem(key, value)</code></pre><p id="ca6e3b4987fe148e2ca3e237353b2b91" class="ne-p"><span class="ne-text">获取数据：</span></p><pre><code>localStorage.getItem(key)</code></pre><p id="e9492b2f395dc29922c93f6fa0ecb2bb" class="ne-p"><span class="ne-text">删除数据：</span></p><pre><code>localStorage.removeItem(key)</code></pre><p id="81471323871e63783885b77b2ca4387e" class="ne-p"><span class="ne-text">清空数据：(所有都清除掉)</span></p><pre><code>localStorage.clear()</code></pre><h3 id="swXya"><span class="ne-text">工具函数的封装</span></h3><pre><code>class StorageFn &#123;    constructor () &#123;        this.ls = window.localStorage;        this.ss = window.sessionStorage;    &#125;<pre><code>/*-----------------cookie---------------------*//*设置cookie*/setCookie (name, value, day) &#123;    var setting = arguments[0];    if (Object.prototype.toString.call(setting).slice(8, -1) === &#39;Object&#39;)&#123;        for (var i in setting) &#123;            var oDate = new Date();            oDate.setDate(oDate.getDate() + day);            document.cookie = i + &#39;=&#39; + setting[i] + &#39;;expires=&#39; + oDate;        &#125;    &#125;else&#123;        var oDate = new Date();        oDate.setDate(oDate.getDate() + day);        document.cookie = name + &#39;=&#39; + value + &#39;;expires=&#39; + oDate;    &#125;    &#125;/*获取cookie*/getCookie (name) &#123;    var arr = document.cookie.split(&#39;; &#39;);    for (var i = 0; i &amp;lt; arr.length; i++) &#123;        var arr2 = arr[i].split(&#39;=&#39;);        if (arr2[0] == name) &#123;            return arr2[1];        &#125;    &#125;    return &#39;&#39;;&#125;/*删除cookie*/removeCookie (name) &#123;    this.setCookie(name, 1, -1);&#125;/*-----------------localStorage---------------------*//*设置localStorage*/setLocal(key, val) &#123;    var setting = arguments[0];    if (Object.prototype.toString.call(setting).slice(8, -1) === &#39;Object&#39;)&#123;        for(var i in setting)&#123;            this.ls.setItem(i, JSON.stringify(setting[i]))        &#125;    &#125;else&#123;        this.ls.setItem(key, JSON.stringify(val))    &#125;    &#125;/*获取localStorage*/getLocal(key) &#123;    if (key) return JSON.parse(this.ls.getItem(key))    return null;    &#125;/*移除localStorage*/removeLocal(key) &#123;    this.ls.removeItem(key)&#125;/*移除所有localStorage*/clearLocal() &#123;    this.ls.clear()&#125;/*-----------------sessionStorage---------------------*//*设置sessionStorage*/setSession(key, val) &#123;    var setting = arguments[0];    if (Object.prototype.toString.call(setting).slice(8, -1) === &#39;Object&#39;)&#123;        for(var i in setting)&#123;            this.ss.setItem(i, JSON.stringify(setting[i]))        &#125;    &#125;else&#123;        this.ss.setItem(key, JSON.stringify(val))    &#125;    &#125;/*获取sessionStorage*/getSession(key) &#123;    if (key) return JSON.parse(this.ss.getItem(key))    return null;    &#125;/*移除sessionStorage*/removeSession(key) &#123;    this.ss.removeItem(key)&#125;/*移除所有sessionStorage*/clearSession() &#123;    this.ss.clear()&#125;</code></pre><p>}<br></code></pre></p></div>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
          <category> JavaScript </category>
          
          <category> BOM </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>综合实验2——约瑟夫环🔖链表</title>
      <link href="/blog/itu2g5/"/>
      <url>/blog/itu2g5/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h2 id="FMVQA"><span class="ne-text">问题描述</span></h2><p id="76743e7f4199f7efee4a22b25121b5e5" class="ne-p" style="text-align: left"><span class="ne-text" style="font-size: 16px">设有</span><span class="ne-text" style="font-size: 16px">n</span><span class="ne-text" style="font-size: 16px">个人围坐在圆桌周围，现从某个位置</span><span class="ne-text" style="font-size: 16px">m(1</span><span class="ne-text" style="font-size: 16px">≤</span><span class="ne-text" style="font-size: 16px">m</span><span class="ne-text" style="font-size: 16px">≤</span><span class="ne-text" style="font-size: 16px">n)</span><span class="ne-text" style="font-size: 16px">上的人开始报数，报数到</span><span class="ne-text" style="font-size: 16px">k</span><span class="ne-text" style="font-size: 16px">的人就站出来。下一个人，即原来的第</span><span class="ne-text" style="font-size: 16px">k+1</span><span class="ne-text" style="font-size: 16px">个位置上的人，又从</span><span class="ne-text" style="font-size: 16px">1</span><span class="ne-text" style="font-size: 16px">开始报数，再报数到</span><span class="ne-text" style="font-size: 16px">k</span><span class="ne-text" style="font-size: 16px">的人站出来。依次重复下去，直到全部的人都站出来为止。试设计一个程序求出这</span><span class="ne-text" style="font-size: 16px">n</span><span class="ne-text" style="font-size: 16px">个人的</span><strong><span class="ne-text" style="font-size: 16px">出列顺序</span></strong><span class="ne-text" style="font-size: 16px">。</span></p><h2 id="TthUA"><span class="ne-text">问题要求</span></h2><ol class="ne-ol"><li id="f7ffa65606c3c5ce4f0945ee28b9389d"><span class="ne-text" style="font-size: 16px">构造一个具有</span><span class="ne-text" style="font-size: 16px">n</span><span class="ne-text" style="font-size: 16px">个结点的循环单链表，用于存储圆桌周围的人的编号，链表结点的</span><span class="ne-text" style="font-size: 16px">data</span><span class="ne-text" style="font-size: 16px">域存放桌子周围的人的编号。</span></li><li id="7474e399364ccbe7fb2f5a2a999027b9"><span class="ne-text" style="font-size: 16px">为保持程序的通用性</span><span class="ne-text" style="font-size: 16px">,</span><span class="ne-text" style="font-size: 16px">问题中的</span><span class="ne-text" style="font-size: 16px">n</span><span class="ne-text" style="font-size: 16px">、</span><span class="ne-text" style="font-size: 16px">m</span><span class="ne-text" style="font-size: 16px">、</span><span class="ne-text" style="font-size: 16px">k</span><span class="ne-text" style="font-size: 16px">可由用户从键盘输入</span><span class="ne-text" style="font-size: 16px">.</span></li><li id="234247c54de30c2b78b470b84bd03335"><span class="ne-text" style="font-size: 16px">要求编写函数模拟约瑟夫问题的实现过程</span><span class="ne-text" style="font-size: 16px">,</span><span class="ne-text" style="font-size: 16px">并输出</span><span class="ne-text" style="font-size: 16px">n</span><span class="ne-text" style="font-size: 16px">个人的出列顺序。</span></li></ol><h2 id="4I3Ah"><span class="ne-text">问题分析</span></h2><p id="5a6ecfa618166afd045d0a0791b14f3b" class="ne-p" style="text-align: left"><span class="ne-text" style="font-size: 16px">这个问题和综合实验一的思路一样，都是利用循环单链表（所以理论上之前的狐狸逮兔子应该用顺序表，而我用了链表</span><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1617761762269-2745323d-e497-4442-984b-fe31e817f25a.jpeg" width="62" id="stiqD" class="ne-image" style="font-size: 16px"><span class="ne-text" style="font-size: 16px">）。</span></p><h2 id="E798Q"><span class="ne-text">代码</span></h2><p id="3dccd7bfd415ad54cdb2e26974c2bf5b" class="ne-p"><span class="ne-text">写代码过程中，题目没看清楚，一开始以为是被选中的人还呆在环里面，就导致我的指针指了一下午的寂寞……</span><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1617799608465-1b5ed521-81ea-4434-a2bb-3d104e6ea038.jpeg" width="52" id="gg81l" class="ne-image"><span class="ne-text">，不说了，交实验报告去了……</span></p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;<p>/**</p><ul><li>定义一个单链表</li><li>/<br>typedef struct LNode &#123;<br>  int data;<br>  struct LNode *next;<br>&#125;Lnode, *LinkList;</li></ul><p>/**</p><ul><li>初始化单链表</li><li>/<br>void InitList(LinkList &amp;L) &#123;<br>  L = new LNode;<br>  L-&gt;next = NULL;<br>  L-&gt;data = 1;<br>&#125;</li></ul><p>/* 初始化循环链表的初始值 */<br>void init_add(LinkList &amp;L, int n) &#123;<br>    InitList(L);<br>    LinkList p = L;<br>    for (int i = 2; i &lt;= n;i++) &#123;<br>        LinkList p_temp = new Lnode;<br>        p_temp-&gt;data = i;<br>        if (i == n) &#123;<br>            p_temp-&gt;next = L;<br>            p-&gt;next = p_temp;<br>        &#125; else &#123;<br>            p_temp-&gt;next = p-&gt;next;<br>            p-&gt;next = p_temp;<br>            p = p-&gt;next;<br>        &#125;<br>    &#125;<br>&#125;</p><p>void joseph_ring(LinkList &amp;L, int n, int m, int k) &#123;<br>    init_add(L, n);<br>    LinkList p = L;<br>    for (int i = 0; i&lt; m; i++) &#123;<br>        p = p-&gt;next;<br>    &#125;<br>    while(p-&gt;next != p) &#123;<br>        for (int j = 1; j&lt; k; j++) &#123;<br>            if (j == k-1) &#123;<br>                cout&lt;&lt;p-&gt;next-&gt;data&lt;&lt;&quot;号出来&quot;&lt;&lt;&quot;\n&quot;;<br>                p-&gt;next = p-&gt;next-&gt;next;<br>                p = p-&gt;next;<br>            &#125; else &#123;<br>                p = p-&gt;next;<br>            &#125;<br>        &#125;<br>    &#125;<br>    cout&lt;&lt; p-&gt;data&lt;&lt;&quot;号出来&quot;&lt;&lt;&quot;\n&quot;;</p><p>&#125;</p><p>int main()<br>&#123;<br>    cout &lt;&lt; &quot;请依次输入人数n、报数位置m、报到指定值就站起来的k值&quot; &lt;&lt; &quot;\n&quot;;<br>    int n, m, k;<br>    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;<br>    LinkList p;<br>    joseph_ring(p, n, m, k);<br>&#125;<br></code></pre></p><p id="77d3f4a34fbc0db46b044a8d3113eb4f" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1618305848004-50b702f4-e85f-410e-8310-bbd0c16ecac2.png" width="466.5" id="Mzbfg" class="ne-image"></p></div>]]></content>
      
      
      <categories>
          
          <category> 计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> Problems </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>综合实验1——狐狸逮兔子🔖链表</title>
      <link href="/blog/bexxoi/"/>
      <url>/blog/bexxoi/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h2 id="PyYRh"><span class="ne-text">问题描述</span></h2><p id="68664ae3a87302ca7bffb18e27450a37" class="ne-p" style="text-align: left"><span class="ne-text" style="font-size: 16px">围绕着山顶有</span><span class="ne-text" style="font-size: 16px">10</span><span class="ne-text" style="font-size: 16px">个圆形排列的洞</span><span class="ne-text" style="font-size: 16px">,狐狸</span><span class="ne-text" style="font-size: 16px">要吃兔子</span><span class="ne-text" style="font-size: 16px">,</span><span class="ne-text" style="font-size: 16px">兔子说</span><span class="ne-text" style="font-size: 16px">:”</span><span class="ne-text" style="font-size: 16px">可以</span><span class="ne-text" style="font-size: 16px">,</span><span class="ne-text" style="font-size: 16px">但必须找到我</span><span class="ne-text" style="font-size: 16px">,</span><span class="ne-text" style="font-size: 16px">我就藏于这</span><span class="ne-text" style="font-size: 16px">10</span><span class="ne-text" style="font-size: 16px">个洞中</span><span class="ne-text" style="font-size: 16px">,</span><span class="ne-text" style="font-size: 16px">你先到</span><span class="ne-text" style="font-size: 16px">1</span><span class="ne-text" style="font-size: 16px">号洞找</span><span class="ne-text" style="font-size: 16px">,</span><span class="ne-text" style="font-size: 16px">第二次隔</span><span class="ne-text" style="font-size: 16px">1</span><span class="ne-text" style="font-size: 16px">个洞</span><span class="ne-text" style="font-size: 16px">(</span><span class="ne-text" style="font-size: 16px">即</span><span class="ne-text" style="font-size: 16px">3</span><span class="ne-text" style="font-size: 16px">号洞</span><span class="ne-text" style="font-size: 16px">)</span><span class="ne-text" style="font-size: 16px">找</span><span class="ne-text" style="font-size: 16px">,</span><span class="ne-text" style="font-size: 16px">第二次隔</span><span class="ne-text" style="font-size: 16px">2</span><span class="ne-text" style="font-size: 16px">个洞</span><span class="ne-text" style="font-size: 16px">(</span><span class="ne-text" style="font-size: 16px">即</span><span class="ne-text" style="font-size: 16px">6</span><span class="ne-text" style="font-size: 16px">号洞</span><span class="ne-text" style="font-size: 16px">)</span><span class="ne-text" style="font-size: 16px">找</span><span class="ne-text" style="font-size: 16px">,</span><span class="ne-text" style="font-size: 16px">以后如此类推</span><span class="ne-text" style="font-size: 16px">,</span><span class="ne-text" style="font-size: 16px">次数不限</span><span class="ne-text" style="font-size: 16px">.”</span><span class="ne-text" style="font-size: 16px">但狐狸从早到晚进进出出了</span><span class="ne-text" style="font-size: 16px">1000</span><span class="ne-text" style="font-size: 16px">次</span><span class="ne-text" style="font-size: 16px">,</span><span class="ne-text" style="font-size: 16px">仍没有找到兔子</span><span class="ne-text" style="font-size: 16px">.</span><span class="ne-text" style="font-size: 16px">问</span><span class="ne-text" style="font-size: 16px">:</span><span class="ne-text" style="font-size: 16px">兔子究竟藏在那个洞里</span><span class="ne-text" style="font-size: 16px">?</span></p><p id="u97a0e4c8" class="ne-p" style="text-align: left"><span class="ne-text" style="font-size: 16px"></span></p><h2 id="5AMn1"><span class="ne-text">问题要求</span></h2><ol class="ne-ol"><li id="5faf33621f969d6114ccd33d665e60dd"><span class="ne-text" style="font-size: 16px">设计一种存储方式用于存储山洞</span><span class="ne-text" style="font-size: 16px">,</span><span class="ne-text" style="font-size: 16px">元素的下标表示山洞的编号</span><span class="ne-text" style="font-size: 16px">,</span><span class="ne-text" style="font-size: 16px">元素的值为</span><span class="ne-text" style="font-size: 16px">1</span><span class="ne-text" style="font-size: 16px">表示狐狸没有进过山洞</span><span class="ne-text" style="font-size: 16px">,</span><span class="ne-text" style="font-size: 16px">为</span><span class="ne-text" style="font-size: 16px">0</span><span class="ne-text" style="font-size: 16px">表示狐狸进过该山洞</span><span class="ne-text" style="font-size: 16px">.</span></li><li id="f878e49a39c71c179a009fc33c471445"><span class="ne-text" style="font-size: 16px">为保持程序的通用性</span><span class="ne-text" style="font-size: 16px">,</span><span class="ne-text" style="font-size: 16px">山洞的数目和狐狸进出山洞的次数不一定为题设的</span><span class="ne-text" style="font-size: 16px">10</span><span class="ne-text" style="font-size: 16px">和</span><span class="ne-text" style="font-size: 16px">1000,</span><span class="ne-text" style="font-size: 16px">可由用户从键盘输入</span><span class="ne-text" style="font-size: 16px">.</span></li><li id="80dac89e32893d84daf589e4340ebd9b"><span class="ne-text" style="font-size: 16px">要求编写函数模拟狐狸逮兔子的过程</span><span class="ne-text" style="font-size: 16px">,</span><span class="ne-text" style="font-size: 16px">并输出兔子可能的藏身之处</span><span class="ne-text" style="font-size: 16px">.</span></li></ol><p id="8b49c149e23f9100f3206f3d7eb62b55" class="ne-p"><span class="ne-text" style="font-size: 16px">注：实验报告中要求说明采用了什么存储结构。</span></p><h2 id="RU5tb"><span class="ne-text">问题分析</span></h2><p id="85384a1ced148c62d966da4e772571c1" class="ne-p" style="text-align: left"><span class="ne-text" style="font-size: 16px">这实际上是一个反复查找线性表的过程</span><span class="ne-text" style="font-size: 16px">.</span></p><p id="94ce9c55919fd04eb253ed8b75d78535" class="ne-p" style="text-align: left"><span class="ne-text" style="text-decoration: line-through; font-size: 16px">定义一个顺序表</span><span class="ne-text" style="text-decoration: line-through; font-size: 16px">,</span><span class="ne-text" style="text-decoration: line-through; font-size: 16px">用具有</span><span class="ne-text" style="text-decoration: line-through; font-size: 16px">10</span><span class="ne-text" style="text-decoration: line-through; font-size: 16px">个元素的顺序表来表示这</span><span class="ne-text" style="text-decoration: line-through; font-size: 16px">10</span><span class="ne-text" style="text-decoration: line-through; font-size: 16px">个洞</span><span class="ne-text" style="text-decoration: line-through; font-size: 16px">.</span><span class="ne-text" style="text-decoration: line-through; font-size: 16px">每个元素表示围绕山顶的一个洞</span><span class="ne-text" style="text-decoration: line-through; font-size: 16px">,</span><span class="ne-text" style="text-decoration: line-through; font-size: 16px">下标为洞的编号</span><span class="ne-text" style="text-decoration: line-through; font-size: 16px">.</span><span class="ne-text" style="text-decoration: line-through; font-size: 16px">对所有洞设置初始标志为</span><span class="ne-text" style="text-decoration: line-through; font-size: 16px">1,</span><span class="ne-text" style="text-decoration: line-through; font-size: 16px">然后通过</span><span class="ne-text" style="text-decoration: line-through; font-size: 16px">1000</span><span class="ne-text" style="text-decoration: line-through; font-size: 16px">次循环</span><span class="ne-text" style="text-decoration: line-through; font-size: 16px">,</span><span class="ne-text" style="text-decoration: line-through; font-size: 16px">对每次所进之洞修改标志为</span><span class="ne-text" style="text-decoration: line-through; font-size: 16px">0,</span><span class="ne-text" style="text-decoration: line-through; font-size: 16px">最后输出标志为</span><span class="ne-text" style="text-decoration: line-through; font-size: 16px">1</span><span class="ne-text" style="text-decoration: line-through; font-size: 16px">的洞</span><span class="ne-text" style="text-decoration: line-through; font-size: 16px">,</span><span class="ne-text" style="text-decoration: line-through; font-size: 16px">即兔子藏身的洞</span><span class="ne-text" style="font-size: 16px">.</span></p><p id="19a5619b15d3f1fec17d3e9d6ebc376b" class="ne-p" style="text-align: left"><span class="ne-text" style="font-size: 16px">定义了一个单链表，将其转换为循环链表，利用循环链表来解决了这个问题。</span></p><h2 id="EbCn3"><span class="ne-text">代码</span></h2><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;<p>typedef struct LNode &#123;<br>    int data;<br>    int flag;<br>    struct LNode *next;<br>&#125;Lnode, *LinkList;</p><p>int main() &#123;<br>    LinkList L;<br>    L = new LNode;<br>    L-&gt;data = 1;<br>    L-&gt;flag = 1;<br>    L-&gt;next = NULL;<br>    for (int i = 1; i &lt; 10;i++) &#123;<br>        LinkList p;<br>        p = new LNode;<br>        p-&gt;data = 11-i;<br>        p-&gt;flag = 1;<br>        p-&gt;next = L-&gt;next;<br>        L-&gt;next = p;<br>        if (i == 1)&#123;<br>            p-&gt;next = L;<br>        &#125;<br>    &#125;</p><pre><code>LinkList s;s = new LNode;s = L;for (int i = 0; i &amp;lt; 1000;i++) &#123;    s-&amp;gt;flag = 0;    for (int j = 0; j &amp;lt; i+2;j++) &#123;        s = s-&amp;gt;next;    &#125;&#125;cout &amp;lt;&amp;lt; &amp;quot;最终结果：&amp;quot;&amp;lt;&amp;lt; &amp;quot;\n&amp;quot;;for (int i = 0; i &amp;lt; 10;i++)&#123;    cout &amp;lt;&amp;lt; L-&amp;gt;data &amp;lt;&amp;lt;&amp;quot;洞&amp;quot;&amp;lt;&amp;lt; &amp;quot; &amp;quot; &amp;lt;&amp;lt; L-&amp;gt;flag &amp;lt;&amp;lt; &amp;quot;\n&amp;quot;;    L = L-&amp;gt;next;&#125;</code></pre><p>}<br></code></pre></p><p id="08bfc357d12d7c800475ed13e89e31fb" class="ne-p"><span class="ne-text" style="font-size: 16px"></span></p><p id="308c8b412ea8db17fbec5f4d9585c80d" class="ne-p"><span class="ne-text" style="font-size: 16px"> </span></p><p id="1cd3c1d9b37ab8d19bc96a09ccc7e035" class="ne-p"><span class="ne-text" style="font-size: 16px"> </span></p><p id="75d6038d714c56f1524323be1470baf8" class="ne-p"><span class="ne-text" style="font-size: 16px"></span></p></div>]]></content>
      
      
      <categories>
          
          <category> 计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> Problems </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[加密文章]Write Code Summary</title>
      <link href="/blog/fit037/"/>
      <url>/blog/fit037/</url>
      
        <content type="html"><![CDATA[<div class="yuque-hexo-lyrics-secret">这是加密文章！</div>]]></content>
      
      
      <categories>
          
          <category> 计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++串</title>
      <link href="/blog/hcwio0/"/>
      <url>/blog/hcwio0/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content-editor-core lake-engine lake-typography-classic" data-lake-element="root" data-selection-undefined="%7B%22path%22%3A%5B%5B12%2C0%2C14%5D%2C%5B12%2C0%2C14%5D%5D%2C%22active%22%3Atrue%7D"><h2 data-lake-id="f265812fd0ea136fc0cb08637c13c905" id="v6aeX" style="padding: 7px 0px; margin: 0px; font-weight: 700; font-size: 24px; line-height: 32px;">课后一些问题</h2><p data-lake-id="31dcf9c599f0a38ce7dfec130ed9a175" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">（1）串是一种特殊的线性表，其特殊性体现在（ &nbsp;）。</p><p data-lake-id="b696679a3f8e3e7ff083b2b85ece3497" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"> &nbsp;A．可以顺序存储 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <strong>&nbsp; B．数据元素是一个字符 &nbsp; </strong>&nbsp; &nbsp;</p><p data-lake-id="d6c3841d7e341e214200b07f4fd282d4" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">C．可以链式存储 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; D．数据元素可以是多个字符若 &nbsp;</p><p data-lake-id="a3939fa8d1e2259268cc78b5ee563022" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">答案：B</p><p data-lake-id="d6d0eddef652ccc89742e2efd7da81a2" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="b3c9440a7cdecd4ce0dd0bdfdc03fcde" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">（2）串下面关于串的的叙述中，（ &nbsp;）是不正确的？ &nbsp;</p><p data-lake-id="ed64bcc84722f575ba3518bd135bc206" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">A．串是字符的有限序列 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<strong>B．空串是由空格构成的串</strong></p><p data-lake-id="6bf941378f090c901f73f1246d2f8732" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">C．模式匹配是串的一种重要运算 &nbsp;D．串既可以采用顺序存储，也可以采用链式存储</p><p data-lake-id="6f341985e3ea3d674cdd927cae6796a2" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">答案：B</p><p data-lake-id="d878bd0a038c640896dd8f04a309a8bf" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">解释：空格常常是串的字符集合中的一个元素，有一个或多个空格组成的串成为空格串，零个字符的串成为空串，其长度为零。 &nbsp;</p><p data-lake-id="8673313376125a3b137f76bd69946003" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="c6a8a28c382e562ac2d4da16640d1068" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">（5）串的长度是指（ &nbsp;）。</p><p data-lake-id="25636c2447e4fa8a95d61194f1a57570" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">A．串中所含不同字母的个数 &nbsp; &nbsp;<strong> &nbsp; B．串中所含字符的个数</strong></p><p data-lake-id="3821edffbc48826fa70d1af55d056424" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">C．串中所含不同字符的个数 &nbsp; &nbsp; &nbsp; D．串中所含非空格字符的个数</p><p data-lake-id="145dc10f528d8704b69109679379ddc7" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">答案：B</p><p data-lake-id="00bb229b2b0660bdbd3bb980d0e2a44d" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">解释：串中字符的数目称为串的长度。</p></div>]]></content>
      
      
      <categories>
          
          <category> 计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 📶线结构：字符串-数组-栈-队列 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>今年的清明有点不一样</title>
      <link href="/essay/nyh946/"/>
      <url>/essay/nyh946/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="traditional"><p class="ne-p"><span class="ne-text">还是在昨天，济南这边下了一场不小的雨，图书馆外的风甚是喧嚣，今天却又是格外晴朗…</span></p><p class="ne-p"><br></p><p class="ne-p"><span class="ne-text">和三月份回学校那天一样，南昌下着大雨，在去昌北机场大巴的车上，鹏鹏打电话和我说华哥死了的时候，那会儿我是很突然的，还没反应过来，人就懵了…车窗外的雨下的愈来愈大</span></p><p class="ne-p"><br></p><p class="ne-p"><span class="ne-text">以前，亲戚长辈们总和我们后辈说，不要学华哥，说是没出息，那会我不懂，我不懂的是什么叫出息，更不懂人们眼中的出息叫什么，我只知道他是我哥，我很喜欢和他玩。</span></p><p class="ne-p"><br></p><p class="ne-p"><span class="ne-text">小时候某年过节那会，亲戚朋友们都聚在一起，大人们都在那谈论电动摩特车，我在一旁听着，想跃跃欲试，我和身旁的华哥说，借他车去路上试试，华哥二话不说把我带到路上把车子开动，我凭着刚才他们大人们的三言两句，三下五除二车子就被我骑的老远，然后手不由自主地加速，车子越来越快，那一瞬间我突然想起来我忘了问刹车在哪…那一瞬间我实实在在感受到了相对速度的感念，车子走了，我屁股着地了～事后华哥笑着和我爸妈说，没多大事…</span></p><p class="ne-p"><br></p><p class="ne-p"><span class="ne-text">这个世界上，我一直相信人不止一面，在人们面前展示的一面，或许是普通的一面，可能一个人的表面是不被人所喜爱的，有几分不羁放纵，也可以是洒脱，当然也有那种特别讨别人喜的那种性格，但我也说了，人是复杂的，有的人在别人看来很没出息，没有大作为，可是，人心很好，当亲朋好友有困难，他会第一时间帮忙，和长辈说话，他会很认真倾听…当人类文明被创建那会，就注定会有框架来定义某些事情的标准。</span></p><p class="ne-p"><br></p><p class="ne-p"><span class="ne-text">我一直对自己说，平生这辈不做一个庸俗之人，尽管身处这个文明有很多的框架…</span></p><p class="ne-p"><br></p><p class="ne-p"><span class="ne-text">已故之人，定当缅怀之，下飞机已经是傍晚六点那会，夕阳洒在那诺大的跑道上，那般场景太容易调动情感，</span></p><p class="ne-p"><br></p><p class="ne-p"><span class="ne-text">在飞机上的一个半小时，我应该是离华哥最近的吧…</span></p><p class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1617606456340-0908688d-ae97-4581-9cdd-53c767da919d.jpeg" width="354"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1617606104878-d295f451-12db-4207-b53a-9bfa1b250017.jpeg" width="354"></p><p class="ne-p"><br></p><p class="ne-p"><br></p></div>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>轮子哥……</title>
      <link href="/essay/las4ft/"/>
      <url>/essay/las4ft/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content-editor-core lake-engine lake-typography-classic" data-lake-element="root" data-selection-undefined="%7B%22path%22%3A%5B%5B0%2C0%2C20%5D%2C%5B0%2C0%2C20%5D%5D%2C%22active%22%3Atrue%7D"><p data-lake-id="a20d224c568e48b9d67847a2c66a8c01_p_0" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">一时造轮子一时爽，一直造轮子，一直爽……</p></div>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>jQuery使用笔记</title>
      <link href="/blog/aa9fsh/"/>
      <url>/blog/aa9fsh/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="a20d224c568e48b9d67847a2c66a8c01_p_0" class="ne-p"><code class="ne-code"><span class="ne-text">jQuery</span></code><span class="ne-text">只是对原生的</span><code class="ne-code"><span class="ne-text">JavaScript</span></code><span class="ne-text">进行封装，说白了就是封装成伪数组，所以记住它的一些调用方法就可以了</span></p><p id="de43568ce566d742cc4dc43bfcbceb53" class="ne-p"><br></p><h2 id="12cNO"><span class="ne-text">参考资料</span></h2><ul class="ne-ul"><li id="e01bddf6d0184ec895f76c099bc08a32"><a href="https://jquery.cuishifeng.cn/" data-href="https://jquery.cuishifeng.cn/" target="_blank" class="ne-link"><span class="ne-text">jQuery API 速查表  --作者：Shifone</span></a></li><li id="b6410930dad07c76852da1de0d43b439"><a href="https://www.processon.com/view/link/5b7d6458e4b0534c9bb76ad9#map" data-href="https://www.processon.com/view/link/5b7d6458e4b0534c9bb76ad9#map" target="_blank" class="ne-link"><span class="ne-text">jQuery思维导图</span></a></li></ul><h2 id="Yy6G8"><span class="ne-text">一些特性</span></h2><ul class="ne-ul"><li id="9ab2320fab604f7cb9f2ff9bc93f2eb5"><code class="ne-code"><span class="ne-text">$</span></code><span class="ne-text">符号：jq里面的顶级对象</span></li><li id="1b1742fcc89d53c4a71949d43b13db7e"><span class="ne-text">入口函数：在DOM里面的</span><span class="ne-text">DOMContentLoaded，在$里面直接赋予入口函数即可</span></li></ul><ul start="3" class="ne-ul"><li id="58420a26243878b1c5e6d82615ed8d58"><span class="ne-text">jq对象和DOM对象：</span></li></ul><p id="c9ac62a6c03b2a1d9e5cdc1f4373bb0f" class="ne-p"><span class="ne-text">两者之间的函数调用不能互换（因为是被封装成了伪数组）</span></p><p id="225f10b8aabd791d71f18ae75ab43ceb" class="ne-p"><span class="ne-text">jq转换为DOM：加数组下标即可</span><span class="ne-text">（因为是被封装成了伪数组，利用索引即可）</span></p><p id="1c8e7ce06b6018fd90c9f08141073c26" class="ne-p"><span class="ne-text">DOM转换为jq：使用$符号即可（括号不加引号），或者是get(索引值)</span></p><h2 id="KS0GD"><span class="ne-text">常用API</span></h2><h3 id="UPgrG"><span class="ne-text">选择器操作</span></h3><ul class="ne-ul"><li id="2a41e99fc1b06afd4748a517f675fc1d"><span class="ne-text">元素获取：之前的CSS选择器（基础选择器、复合选择器）怎么写，这里直接就放到$里面即可</span></li></ul><p id="7650925720f490de73ba59e8322a9e01" class="ne-p"><span class="ne-text">筛选选择器</span></p><p id="4e27c9c09861b54c98d5eb1f8cdd285a" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1617359781992-e02802ae-f357-4987-a8a0-46cc0c5be69a.png" width="524" id="yL3dG" class="ne-image"></p><ul class="ne-ul"><li id="1a27dd3a03c64a9534739d7c6c8eed3c"><span class="ne-text">隐式迭代：如果获取的元素是一个数组，那么对其赋予的新操作，会隐式遍历</span></li><li id="2bee8e4ae71361c3d944e799fec950de"><span class="ne-text">元素属性操作：css(&quot;属性&quot;,&quot;值&quot;)函数</span></li></ul><ul start="3" class="ne-ul"><li id="0cb05668563d2d2ffd3493767266c90e"><span class="ne-text">元素节点操作</span></li></ul><p id="a3c41e2d8826c81dfb91873977ed1e8a" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1617359820567-38b9fad2-deb7-429f-9d21-8f9676563426.png" width="541" id="G7Yck" class="ne-image"></p><p id="672e6e51a8475d895774bfb5d481d768" class="ne-p"><br></p><ul class="ne-ul"><li id="dc7922e3952089ef17dde809f5e8358b"><span class="ne-text">事件：.mouseover()、.click()</span></li><li id="aa872635f671ab45ac240ab897e92ba7"><span class="ne-text">.show()、.hide()：元素显示和隐藏</span></li></ul><ul start="3" class="ne-ul"><li id="6082de1ba1336d659e31b3059aaeb319"><span class="ne-text">$(this)当前这个对象</span></li></ul><h3 id="aSnP5"><span class="ne-text">样式操作</span></h3><p id="3e8f10016e271373aa72a4bd04f84379" class="ne-p"><span class="ne-text">样式的操作还是和之前的DOM一样，有两种，一种是逐个设置该元素的属性和值，另一种就是改变其类，jq里面也是这个大题思路，不过有不同</span></p><p id="7514a4dc78af37e41d943b07a4abad78" class="ne-p"><br></p><ul class="ne-ul"><li id="86e64d0eebee88b5b095f6d8adb70e46"><span class="ne-text">单一设置：.css()函数，一个参数的时候，返回该参数的值，两个参数的时候，即赋予该属性及值</span></li><li id="5866e3069dc9461ede811a32ce07fd0a"><span class="ne-text">clsss设置</span></li></ul><p id="fb354fca6afe944be652058c065de7ae" class="ne-p"><span class="ne-text">.addClass(&quot;类名&quot;)：如果该元素没有该类，则加上</span></p><p id="64fcddc76d48e8ff6dc608c8f2e52961" class="ne-p"><span class="ne-text">.removeClass()：移除指定类名</span></p><p id="cf1d33cf1d1b4b3a1048701bce77140b" class="ne-p"><span class="ne-text">.toggle()：如果该元素有该类则删除，如果没有该类则加上</span></p><p id="65aa808d270c7ca0376eead229fa3896" class="ne-p"><br></p><ul class="ne-ul"><li id="a95103df535ead96a7e6a61b3f1a86b9"><span class="ne-text">class设置和DOM里面className区别是前者不会删除原本的类，后者会</span></li></ul><h3 id="dgpQs"><span class="ne-text">效果操作</span></h3><p id="557caec8d8090bdde7526a69d5e81253" class="ne-p"><span class="ne-text">jq封装了很多的效果，具体可以详查相关文档    </span></p><p id="2c91295911a02a1636db646b11a14181" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1617361907950-d1d89194-401d-46aa-9471-34139e3e00df.png" width="351.5" id="SD9oO" class="ne-image"></p><h3 id="DzFX6"><span class="ne-text">属性操作</span></h3><ul class="ne-ul"><li id="b0312590ad1d416a46c7047cad1eb51b"><span class="ne-text">prop()：得到/设置元素固有的属性及值</span></li><li id="75381246b6dd4f80808426d191caaed3"><span class="ne-text">attr()：得到/设置元素自定义的属性及值</span></li></ul><ul start="3" class="ne-ul"><li id="08ec800bbbd7ebb550101047a6132655"><span class="ne-text">data()：数据缓存</span></li></ul><h3 id="NlpzM"><span class="ne-text">内容文本值操作</span></h3><ul class="ne-ul"><li id="c00ce586c548052b1357d7c2694caa2b"><span class="ne-text">html()：相当于innerHTML</span></li><li id="5fbfcc177fc81d3d1525e69bdd7a8a7e"><span class="ne-text">text()：相当于innerText</span></li></ul><ul start="3" class="ne-ul"><li id="660d54b547338a92c6432042fc1ba3f5"><span class="ne-text">val()：操作表单的值（没有参数是获取值，有一个参数是设置）</span></li></ul><h3 id="u4L4A"><span class="ne-text">元素操作</span></h3><div data-type="info" class="ne-alert"><p id="11ee78e97c938aa98b1789a93790ae7d" class="ne-p"><span class="ne-text">遍历</span></p></div><p id="b38098c59a399b93fbd23ce5cfd3dafe" class="ne-p"><br></p><div class="ne-quote"><p id="ebf89f25145d952c93719ecf6617b416" class="ne-p"><span class="ne-text">第一种表达：</span></p></div><ul class="ne-ul"><li id="7d6908137833a84be94dd8d3cfd9e7d5"><span class="ne-text">$(&quot;div&quot;).each(function(index,ele){XXXX})</span></li><li id="fbe71cf944eb5882519c695fa0dd7fda"><span class="ne-text">其中index是索引号，ele得到的是DOM对象</span></li></ul><div class="ne-quote"><p id="913f07908bcd64c5b98d83210315403e" class="ne-p"><span class="ne-text">第二种表达</span></p></div><ul class="ne-ul"><li id="e3a19e3266a3e2865533169928321c51"><span class="ne-text">$.each(Object,function(index,ele){XXXXX})</span></li><li id="0b81bcf5981aed6fb50411f4efaadb69"><span class="ne-text">主要用于数据处理</span></li></ul><p id="a2d0d6a9ac0f09ebbecede19eaad70c4" class="ne-p"><br></p><div data-type="info" class="ne-alert"><p id="c9f786a0f9ceeaebe548220fcb9d3b5c" class="ne-p"><span class="ne-text">创建</span></p></div><p id="6b1de1e66547f3f16c00e328bd4b2c64" class="ne-p"><br></p><p id="879ad0498c5d00cd026bb5274af07224" class="ne-p"><span class="ne-text">直接在$里面双引号加上需要创建的标签</span></p><p id="767d6cc22830a26393b135d2b498fa5f" class="ne-p"><br></p><div data-type="info" class="ne-alert"><p id="07059a0b2eb61dece09fa91041fdfaa1" class="ne-p"><span class="ne-text">添加</span></p></div><p id="74c01037713daae461bc3a957cb243df" class="ne-p"><br></p><div class="ne-quote"><p id="6621fe80cdd7269d49fe030309384dbc" class="ne-p"><span class="ne-text">第一种关系：添加生成父子关系</span></p></div><ul class="ne-ul"><li id="f26a63599bf94c55db5a88177d751562"><span class="ne-text">append(&quot;&quot;)</span></li><li id="9f981d6a7e1147114329ddb689987e73"><span class="ne-text">prepend(&quot;&quot;)</span></li></ul><div class="ne-quote"><p id="b25d1ded663bd9079177df2b138ff027" class="ne-p"><span class="ne-text">第二种关系：添加生成兄弟关系</span></p></div><ul class="ne-ul"><li id="249a0d56e52df01b48ae3bc34803d308"><span class="ne-text">after(&quot;&quot;)</span></li><li id="726de4b46f61bc29d99d49a834d71915"><span class="ne-text">before(&quot;&quot;)</span></li></ul><p id="8301a769f76c2e93d6a36819800b8c27" class="ne-p"><br></p><div data-type="info" class="ne-alert"><p id="fa6120f2c42f9084290d26a8ede55362" class="ne-p"><span class="ne-text">删除</span></p></div><p id="0959176024c4622f309e59c6b05f725e" class="ne-p"><br></p><ul class="ne-ul"><li id="fb13b9f3c00152f3324b5267d5b0ba09"><span class="ne-text">remove()：移除选定节点</span></li><li id="dde65bd8b804b2d36f327e1e69c3aaa8"><span class="ne-text">empty()：清空所选节点的左右子节点</span></li></ul><ul start="3" class="ne-ul"><li id="cddf9dd16267a7e1c4ea57b238b1c47a"><span class="ne-text">html(&quot;&quot;)：将所选节点的html内容制空（相当于删除节点了）</span></li></ul><h3 id="L7wkW"><span class="ne-text">尺寸、位置操作</span></h3><p id="1d0b003757b8a2f0553a50faafbafbc0" class="ne-p"><br></p><div data-type="info" class="ne-alert"><p id="0979ce8391a1cfe51e177c149311b3aa" class="ne-p"><span class="ne-text">尺寸操作</span></p></div><p id="52250d8638cb68a364d9e07b0365361a" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1617364626783-b5a50ec5-eeb2-4447-bc15-c7c209ae1d08.png" width="583" id="AIKMv" class="ne-image"></p><p id="9e29cca939c5b3efe1921d23336187ad" class="ne-p"><span class="ne-text">参数为空：返回值</span></p><p id="51f292fb19da19a6d477efaa569c14b5" class="ne-p"><span class="ne-text">参数为一个值：设置</span></p><p id="a71f7e5719b083e1f628ba7db4d96b7e" class="ne-p"><br></p><p id="7dd7dfadb8ba312a97ed97496c00accc" class="ne-p"><br></p><div data-type="info" class="ne-alert"><p id="72d806ea8edd33836b4e32011f80d4c4" class="ne-p"><span class="ne-text">位置操作</span></p></div><p id="2c59051aaaf55f39c36349f349594db0" class="ne-p"><br></p><p id="00bd1e37a2b8faa0c0b8200e083310ac" class="ne-p"><br></p><p id="c02db588425c095fc03a80a0c06b42a1" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1617364679986-4ff0b4c0-8622-4111-9c4b-c6571bd278db.png" width="623" id="SdHbS" class="ne-image"></p><p id="3a60bc8a5c64f4ac264dd4f8d0f2e22f" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1617364688980-2d85f32d-a51c-48ae-85a9-fc9f613536e5.png" width="589.5" id="AO6QL" class="ne-image"></p><p id="3c40b3114fa2320a1bec36ed192b4677" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1617364699038-74aa84bc-20ec-4427-9485-311ebaf9d066.png" width="523.5" id="jllHI" class="ne-image"></p><p id="e74be622e43f0843137ec567dbb4ec59" class="ne-p"><br></p></div>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
          <category> jQuery </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CSS预处理器</title>
      <link href="/blog/zsiw5e/"/>
      <url>/blog/zsiw5e/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="traditional"><h2 id="u2Coo"><span class="ne-text">stylus</span></h2><p id="452a67e8416e5886cf217588873f2947" class="ne-p"><span class="ne-text">CSS预处理器优化CSS的开发</span></p><p id="ccdcf278ecc82a6e13e74521cdb4a20d" class="ne-p"><br></p><div data-type="info" class="ne-alert"><p id="3225668e3c05a454496713f58c85b9cd" class="ne-p"><span class="ne-text">CSS 的预处理器，给 CSS 添加了可编程的特性，也就是说，在 stylus 中可以使用变量、函数、判断、循环一系列 CSS 没有的东西来编写样式文件，这个文件可编译成 CSS 文件</span></p></div><p id="d98fa72ca4a4d2c7bf4de368a59b5a4e" class="ne-p"><br></p><h3 id="UxRVE"><span class="ne-text">note</span></h3><ul class="ne-ul"><li id="378c5b362d5f14d4ca2667b8e5ae15f5"><span class="ne-text">“[]”：中括号内容，是定义属性的方式</span></li></ul><p id="ebd134e9428d26b9f70409563356beff" class="ne-p"><br></p><h3 id="B9Svy"><span class="ne-text">参考</span></h3><ul class="ne-ul"><li id="cdb195997112ae2a308d8333150363d7"><a href="https://www.zhangxinxu.com/jq/stylus/" data-href="https://www.zhangxinxu.com/jq/stylus/" target="_blank" class="ne-link"><span class="ne-text">stylus中文版参考文档之综述——张鑫旭</span></a></li><li id="67056520763e5b1fe08cb786414c73dc"><a href="https://stylus.bootcss.com/" data-href="https://stylus.bootcss.com/" target="_blank" class="ne-link"><span class="ne-text">富于表现力、动态的、健壮的 CSS</span></a></li></ul><p id="ua8003f55" class="ne-p"><span class="ne-text"></span></p><h2 id="lmd5c"><span class="ne-text">less</span></h2><p id="u9b2914bf" class="ne-p"><span class="ne-text">参考：</span><a href="https://less.bootcss.com/" data-href="https://less.bootcss.com/" target="_blank" class="ne-link"><span class="ne-text">https://less.bootcss.com/</span></a></p></div>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
          <category> HTML+CSS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CSS的媒体查询</title>
      <link href="/blog/mio9h2/"/>
      <url>/blog/mio9h2/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="traditional"><h3 id="23ZNi"><span class="ne-text">媒体查询（CSS3）</span></h3><div data-type="info" class="ne-alert"><p id="5ac086b799bc33aa7a9cd2e7ece989b3" class="ne-p"><span class="ne-text" style="background-color: #E8F7FF">@media：注意@符号</span></p></div><pre><code>@media mediatype and|not|only (media feature) &#123;    CSS-Code;&#125;</code></pre><h3 id="Jdwqy"><span class="ne-text">mediatype 查询类型</span></h3><div data-type="info" class="ne-alert"><p id="d6f925662956c9dbc2e4c88433bc166c" class="ne-p"><span class="ne-text" style="background-color: #E8F7FF">将不同的终端设备划分成不同的类型，称为媒体类型</span></p></div><p id="27435027d74589dafd7000d4c2de0b1f" class="ne-p"><br></p><p id="070a16a857a6e87adc3e6f53ff2127fd" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/jpg/1484158/1615360325196-c449a080-4612-4814-b5da-5a61b1da1c0b.jpg" width="915" id="jLd4P" class="ne-image"></p><h3 id="91mxe"><span class="ne-text">关键字</span></h3><div data-type="info" class="ne-alert"><p id="7918a9dbda126ecad8bab3207f970fef" class="ne-p"><span class="ne-text" style="background-color: #E8F7FF">关键字将媒体类型或多个媒体特性连接到一起做为媒体查询的条件。</span></p></div><p id="3498795937d447cc9cc04d33c3aebe52" class="ne-p"><br></p><ul class="ne-ul"><li id="e089796360e0009d3b14ec2aff4a6242"><span class="ne-text">and：可以将多个媒体特性连接到一起，相当于“且”的意思。</span></li><li id="9eb946d76e571bb6dd5f8ce52754a1f4"><span class="ne-text">not：排除某个媒体类型，相当于“非”的意思，可以省略。</span></li><li id="5d3fd7da92fe2ac73f1d56c81c8e424f"><span class="ne-text">only：指定某个特定的媒体类型，可以省略。</span></li></ul><h3 id="LOgiW"><span class="ne-text">媒体特性</span></h3><div data-type="info" class="ne-alert"><p id="9015da3e9feb95758fe3dbe563cab402" class="ne-p"><span class="ne-text" style="background-color: #E8F7FF">每种媒体类型都具体各自不同的特性，根据不同媒体类型的媒体特性设置不同的展示风格。我们暂且了解三个。</span></p></div><p id="89e55b400cd384cf5d5c5494d812f35a" class="ne-p"><br></p><p id="ad00b8c6f4e31428409176ace3ccc883" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/jpg/1484158/1615360325364-d6cd0d1a-1ec7-4bd1-a67e-3fadde7c4381.jpg" width="918" id="yj8Yz" class="ne-image"></p><h3 id="8eYMp"><span class="ne-text">媒体查询书写规则</span></h3><div data-type="danger" class="ne-alert"><p id="49409e3a9b274523127921a2233d650d" class="ne-p"><span class="ne-text" style="background-color: #FFF3F3">为了防止混乱，媒体查询我们要按照从小到大或者从大到小的顺序来写,但是我们最喜欢的还是从小到大来写，这样代码更简洁</span></p></div><p id="0cf8bb4f1f7175bd98658821fcbd9a40" class="ne-p"><br></p></div>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
          <category> HTML+CSS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>GitHub基于Issue的软件项目管理</title>
      <link href="/blog/hgbehz/"/>
      <url>/blog/hgbehz/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="u22cd1647" class="ne-p"><br></p><div data-type="color1" class="ne-alert"><p id="011a5357f7205dddf9b1506eaad76bb4" class="ne-p"><span class="ne-text">在进行GitHub项目开发过程中，途中会有一些新想法，遇见的新bug等问题，提出的一些新灵感等等都可以利用GitHub每个项目自带的issues（议题）来进行管理、跟踪并且加以解决。</span></p><p id="ec94d49f4ca5d591db0708d31278dec0" class="ne-p"><span class="ne-text">传统的软件项目管理还有Milestones（里程碑）、Projects（画板）来一并进行项目的开发，GitHub在2020年还新增加了Discussion（讨论区）模块，进一步提高软件项目的管理工作。</span></p></div><p id="42d01dbfc9c0385189d6ccd13dd47397" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616655875686-d8387a58-3c42-4442-b6b5-1cd2b0c68a5f.png" width="946.5" id="vUGI2" class="ne-image"></p><p id="3710271f5e1a3824aa072f559ead2b3b" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616656006240-dd9c58bd-6675-487e-aab0-58878e9fcb29.png" width="947.5" id="PmAcn" class="ne-image"></p><h2 id="uwbhj"><span class="ne-text">Issue标签类型总结</span></h2><h3 id="URZo7"><span class="ne-text">GitHub默认标签</span></h3><table id="NznVX" class="ne-table" style="width: 893px"><tbody><tr style="height: 33px"><td width="150"><p id="u12a869c5" class="ne-p" style="text-align: center"><strong><span class="ne-text">Label</span></strong></p></td><td width="212"><p id="u896c770b" class="ne-p" style="text-align: center"><strong><span class="ne-text">explanation</span></strong></p></td><td width="531"><p id="udd4e1716" class="ne-p" style="text-align: center"><strong><span class="ne-text">Description</span></strong></p></td></tr><tr style="height: 33px"><td width="150"><p id="u0619f6a9" class="ne-p" style="text-align: center"><span class="ne-text">bug</span></p></td><td width="212"><p id="u38e16eb8" class="ne-p" style="text-align: center"><span class="ne-text">提出一个bug</span></p></td><td width="531"><p id="u48ef1bcc" class="ne-p" style="text-align: center"><span class="ne-text">Indicates an unexpected problem or unintended behavior</span></p></td></tr><tr style="height: 33px"><td width="150"><p id="ua98df8d6" class="ne-p" style="text-align: center"><span class="ne-text">documentation</span></p></td><td width="212"><p id="ue0ed9c1a" class="ne-p" style="text-align: center"><span class="ne-text">添加/改进/详查文档</span></p></td><td width="531"><p id="uee246b2c" class="ne-p" style="text-align: center"><span class="ne-text">Indicates a need for improvements or additions to documentation</span></p></td></tr><tr style="height: 33px"><td width="150"><p id="u05d518b4" class="ne-p" style="text-align: center"><span class="ne-text">duplicate</span></p></td><td width="212"><p id="uee784ab9" class="ne-p" style="text-align: center"><span class="ne-text">重复的问题/requests/讨论</span></p></td><td width="531"><p id="u3a3eccf8" class="ne-p" style="text-align: center"><span class="ne-text">Indicates similar issues, pull requests, or discussions</span></p></td></tr><tr style="height: 33px"><td width="150"><p id="u6e0e3cb7" class="ne-p" style="text-align: center"><span class="ne-text">enhancement</span></p></td><td width="212" style="background-color: #FFFFFF"><p id="u529c40d1" class="ne-p" style="text-align: center"><span class="ne-text">增强/新增功能</span></p></td><td width="531"><p id="u7abcf037" class="ne-p" style="text-align: center"><span class="ne-text">Indicates new feature requests</span></p></td></tr><tr style="height: 33px"><td width="150"><p id="u947dbd10" class="ne-p" style="text-align: center"><span class="ne-text">good first issue</span></p></td><td width="212" style="background-color: #FFFFFF"><p id="ufe96cb4b" class="ne-p" style="text-align: center"><span class="ne-text">好的想法/灵感</span></p></td><td width="531"><p id="u01874ec4" class="ne-p" style="text-align: center"><span class="ne-text">Indicates a good issue for first-time contributors</span></p></td></tr><tr style="height: 33px"><td width="150"><p id="u883f26fd" class="ne-p" style="text-align: center"><span class="ne-text">help wanted</span></p></td><td width="212" style="background-color: #FFFFFF"><p id="u2c12ec31" class="ne-p" style="text-align: center"><span class="ne-text">过程中需要帮助</span></p></td><td width="531"><p id="uf1f58498" class="ne-p" style="text-align: center"><span class="ne-text">Indicates that a maintainer wants help on an issue or pull request</span></p></td></tr><tr style="height: 33px"><td width="150"><p id="ud2a85c2c" class="ne-p" style="text-align: center"><span class="ne-text">invalid</span></p></td><td width="212" style="background-color: #FFFFFF"><p id="ue144fca0" class="ne-p" style="text-align: center"><span class="ne-text">没有意义，不再讨论</span></p></td><td width="531"><p id="uc0aa83ca" class="ne-p" style="text-align: center"><span class="ne-text">Indicates that an issue, pull request, or discussion is no longer relevant</span></p></td></tr><tr style="height: 33px"><td width="150"><p id="u4d0ff9e6" class="ne-p" style="text-align: center"><span class="ne-text">question</span></p></td><td width="212" style="background-color: #FFFFFF"><p id="uf3471de4" class="ne-p" style="text-align: center"><span class="ne-text">请提供进一步资料</span></p></td><td width="531"><p id="ue29f0928" class="ne-p" style="text-align: center"><span class="ne-text">Indicates that an issue, pull request, or discussion needs more information</span></p></td></tr><tr style="height: 33px"><td width="150"><p id="ucbbf8a6d" class="ne-p" style="text-align: center"><span class="ne-text">wontfix</span></p></td><td width="212" style="background-color: #FFFFFF"><p id="uc1630edc" class="ne-p" style="text-align: center"><span class="ne-text">不做处理</span></p></td><td width="531"><p id="u6a6ff953" class="ne-p" style="text-align: center"><span class="ne-text">Indicates that work won't continue on an issue, pull request, or discussion</span></p></td></tr></tbody></table><h3 id="AbJiS"><span class="ne-text">自需添加</span></h3><table id="bLXb2" class="ne-table" style="width: 479px"><tbody><tr style="height: 33px"><td width="239"><p id="a24c7d0b6d9283518f91f4c0317a7bae" class="ne-p"><span class="ne-text">debugging</span></p></td><td width="240"><p id="5394a8ea5a0306ce3ac1e6aa18b98826_p_0" class="ne-p"><span class="ne-text">正在调试</span></p></td></tr><tr style="height: 33px"><td width="239"><p id="920315d99b965a5644fee80c3835ad1e" class="ne-p"><span class="ne-text">fixed</span></p></td><td width="240"><p id="7093202f29ebdfb9d282758af8be662d_p_0" class="ne-p"><span class="ne-text">已被修复</span></p></td></tr></tbody></table><h2 id="AUORQ"><span class="ne-text">Discussion的新革新</span></h2><p id="92b019e096e018cf9ddfc50063e5d71a" class="ne-p"><span class="ne-text">传统的流程是提出issues之后，根据不同的issue来跟进画板（Project）的内容。</span></p><p id="092ba84ad78c26f4415b771106bd6690" class="ne-p"><br></p><p id="36bf279ab58f49ff5d9a08ff59e8542f" class="ne-p"><span class="ne-text">上面的做法其实有一个思维上的bug，一些灵感之类的不好放上去，使用Discussion之后，可以在</span><span class="ne-text">Discussion里面放上想法、灵感等，实际开发从这里面的一个的一个具体的评论转换到实际的issue里面</span></p><h2 id="tbZ3q"><span class="ne-text">参考</span></h2><ul class="ne-ul"><li id="1acc1b1e05ed6bb38cba9e4b9107e0f3"><a href="http://www.ruanyifeng.com/blog/2017/08/issue.html" data-href="http://www.ruanyifeng.com/blog/2017/08/issue.html" target="_blank" class="ne-link"><span class="ne-text">http://www.ruanyifeng.com/blog/2017/08/issue.html</span></a></li><li id="9ad438665f32035d34baf7a5fab9c8d8"><a href="https://github.com/volantis-x/hexo-theme-volantis/" data-href="https://github.com/volantis-x/hexo-theme-volantis/" target="_blank" class="ne-link"><span class="ne-text">https://github.com/volantis-x/hexo-theme-volantis/</span></a></li></ul></div>]]></content>
      
      
      <categories>
          
          <category> 计算机素养 </category>
          
          <category> Git+GitHub </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Git push出(10054)/(port 443：time out)错</title>
      <link href="/blog/tttk33/"/>
      <url>/blog/tttk33/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="uc53e90c4" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1624951739057-ebfc3755-1e5a-426b-a7b3-a7841ead1b1f.png" width="441" id="yDPwn" class="ne-image"></p><p id="ub196f5cb" class="ne-p"><span class="ne-text"></span></p><p id="ud8f0faf3" class="ne-p"><strong><span class="ne-text">前言：今年GitHub的各种操作被屏蔽的挺迷的，一开始我只是以为偶尔报个连接失败的port443的错误，但是后来经常性的出现本地push不上GitHub的情况，在此情况记录一下各种情况（clone、pull、push……）连接不上的解决办法。</span></strong></p><p id="uacec6dbf" class="ne-p"><br></p><h2 id="vMQmQ"><span class="ne-text">一、报错信息与原因分析</span></h2><h3 id="mOgXN"><span class="ne-text">报错信息</span></h3><pre><code>Git push出(10054)/(port 443：time out)错<p>git push error: RPC failed; curl 56 OpenSSL SSL_read: SSL_ERROR_SYSCALL, errno 10054<br></code></pre></p><p id="u2aee6d65" class="ne-p"><br></p><h3 id="Kpmuy"><span class="ne-text">原因分析</span></h3><ol class="ne-ol"><li id="u18980f1a"><span class="ne-text">由于Http协议错误，当 pull 或者 clone 的时候，或者是 github 某个CDN被qiang屏蔽所致。</span></li><li id="u5ee232b6"><span class="ne-text">用了kexueshangwang工具之后，由于更改代理服务器连接端口，导致本地push偶尔失败（但是以前有用）。</span></li></ol><h2 id="nOi29"><span class="ne-text">二、常规解决方案</span></h2><div data-type="success" class="ne-alert"><p id="uab283dd3" class="ne-p"><span class="ne-text">2021.06.29更新解决方法：【针对clone失败】https的连接不行，那就用ssh的连接。</span></p><p id="u63139dec" class="ne-p"><span class="ne-text">2021.07.13更新解决方案：【针对pull、push失败】ssh连接push连接不行，那就用token来push。</span></p></div><p id="ua5aa3a5b" class="ne-p"><span class="ne-text"></span></p><div data-type="success" class="ne-alert"><p id="u97b70ea5" class="ne-p"><span class="ne-text">常规解决方法：</span></p><p id="u4479d0d3" class="ne-p"><span class="ne-text">第一种方法是下面的三条命令，另外如果用了该三条命令还不行，那就ctrl + c ，再进行输入命令，以此往复，总会出现GitHub的登录框的……；</span></p><p id="u2848c832" class="ne-p"><span class="ne-text">第二种方法就是在本地对host进行更改，让其可以访问github网站的相关ip；</span></p></div><p id="ua79015bf" class="ne-p"><span class="ne-text"></span></p><h3 id="UOJ1D"><span class="ne-text">常规解决方案1：改代理</span></h3><div class="ne-quote"><p id="u18fba66e" class="ne-p"><span class="ne-text">10054的bug复制下面的</span></p></div><pre><code>git config http.postBuffer 524288000</code></pre><div class="ne-quote"><p id="ufc3918f6" class="ne-p"><span class="ne-text">443的bug复制下面的</span></p></div><pre><code># 设置ssgit config --global http.proxy 'socks5://127.0.0.1:10080'git config --global https.proxy 'socks5://127.0.0.1:10080'# 设置代理git config --global https.proxy http://127.0.0.1:10080git config --global https.proxy https://127.0.0.1:10080# 取消代理git config --global --unset http.proxygit config --global --unset https.proxy</code></pre><h3 id="SCsCl"><span class="ne-text">常规解决方案2：改变本地hosts文件</span></h3><p id="78ed051236d072ca01dcfb356337895e" class="ne-p"><span class="ne-text">在</span><a href="https://www.ipaddress.com/" data-href="https://www.ipaddress.com/" target="_blank" class="ne-link"><span class="ne-text">https://www.ipaddress.com/</span></a><span class="ne-text">里面查找下面三个域名的ip地址</span></p><ul class="ne-ul"><li id="19bb41ac716d33bfc9eefbb90abc83cd"><span class="ne-text">github.com</span></li><li id="7070d7115839d2f0108e4458654d3ca7"><span class="ne-text">github.global.ssl.fastly.net</span></li></ul><ul start="3" class="ne-ul"><li id="61629bb945eb3ea6add4933918a8fc03"><span class="ne-text">codeload.github.com</span></li></ul><p id="ec5a0662d9c737b31b6470c66b3659e4" class="ne-p"><span class="ne-text">将其添加到本电脑hosts文件当中</span></p><p id="e389f74b35a35de6376e3f8f9d1a3179" class="ne-p"><code class="ne-code"><span class="ne-text">C:\Windows\System32\drivers\etc\hosts</span></code><span class="ne-text"> </span></p><p id="ub3851647" class="ne-p"><span class="ne-text">类似下面：</span></p><p id="3c99eb4bc70690f460649a291643b991" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1615339105733-afb66a55-d96e-4dba-9650-a9d3cb8324fa.png" width="245" id="EhSLV" class="ne-image"></p><p id="d1c2a5c3a0027563e1787158147c15f3" class="ne-p"><span class="ne-text">CMD窗口刷新DNS缓存</span></p><pre><code>ipconfig /flushdns</code></pre><h2 id="daQUa"><span class="ne-text">三、针对性解决方案</span></h2><p id="u5f814d65" class="ne-p"><span class="ne-text">上面两种方案理论上解决了问题，但是奇葩的问题年年有，上述两种方案都不能解决，就用如下方案：</span></p><h3 id="GIgvQ"><span class="ne-text">针对clone失败</span></h3><p id="u5d77397b" class="ne-p"><span class="ne-text">如果https连接失败，使用ssh链连接（前提是电脑端配置了ssh），如果ssh连接也不行，那就下面的针对pull、push失败的方案。</span></p><p id="u7e654cd7" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1624953268520-f8c7c56d-6588-4991-b63c-11adc5cdd0ae.png" width="441" id="KCLWc" class="ne-image"></p><h3 id="ZkQc2"><span class="ne-text">针对pull、push失败</span></h3><p id="uefd8d8a0" class="ne-p"><span class="ne-text">ssh连接不行，那就使用token来连接</span></p><pre><code>git push https://一串token@github.com/wztlink1013/datastructure-algorithm</code></pre><h2 id="boevI"><span class="ne-text">参考</span></h2><ul class="ne-ul"><li id="9a0c30a27e5684596a4353039851aa5e"><a href="https://www.cnblogs.com/mmzs/p/12039888.html" data-href="https://www.cnblogs.com/mmzs/p/12039888.html" target="_blank" class="ne-link"><span class="ne-text">https://www.cnblogs.com/mmzs/p/12039888.html</span></a></li><li id="uf80e0f59"><a href="https://www.jianshu.com/p/f98ed938f91a" data-href="https://www.jianshu.com/p/f98ed938f91a" target="_blank" class="ne-link"><span class="ne-text">使用Personal access tokens以避免Windows下每次git push都需要输入账号密码</span></a></li></ul><ul start="3" class="ne-ul"><li id="u696c7627"><a href="https://segmentfault.com/q/1010000039738438" data-href="https://segmentfault.com/q/1010000039738438" target="_blank" class="ne-link"><span class="ne-text">2021年为什么最近github能访问不能push代码了</span></a></li></ul><p id="uef725edc" class="ne-p"><br></p></div>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
          <category> Bug </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++链表(单、循环、双向)设计及操作</title>
      <link href="/blog/gu92gu/"/>
      <url>/blog/gu92gu/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><div data-type="info" class="ne-alert"><p id="c88ce5764357a091522741724378b1dd" class="ne-p"><span class="ne-text">前言：这篇文章，打算详细记录下链表的相关知识，毕竟是基础中的基础。首先是先记录下在一开始学习过程中的些许疑惑/C的遗忘，然后记录各种代码（实验报告代码，单链表各种操作代码总结，循环链表代码，双向链表代码）</span></p></div><h2 id="fWwcE"><span class="ne-text">实验要求</span></h2><div class="ne-quote"><p id="0a190c74909083860b0ea4ec77a7f8e0" class="ne-p"><span class="ne-text">1、创建一个带头结点的单链表（头指针为head），且遍历此链表（输出链表中各结点的值）；</span></p><p id="39f29f4dc50744c5a850b3f5d4694202" class="ne-p"><span class="ne-text">2、查找单链表中的第i个结点，并输出结点元素的值；</span></p></div><div class="ne-quote"><p id="49447049dc631801c0d0cf98ab90b493" class="ne-p"><span class="ne-text">3、在单链表中的第i个结点前插入一个结点值为e的正整数(从外部输入);</span></p></div><div class="ne-quote"><p id="43c77222ef93623b95e886aeacbe2ddc" class="ne-p"><span class="ne-text">4、删除单链表中的第j个结点；</span></p></div><div class="ne-quote"><p id="e25375651bc08487d6880bc6695fce1d" class="ne-p"><span class="ne-text">*5、将单链表中的各结点就地逆序（不允许另建一个链表）；</span></p></div><h2 id="eP7sU"><span class="ne-text">概念理解</span></h2><h3 id="AEx9L"><span class="ne-text">链表数据结构</span></h3><p id="57e1ef23e935c9b21e2cfea98c4cb69f" class="ne-p" style="text-indent: 2em"><span class="ne-text">链表是一种数据结构，和</span><strong><span class="ne-text">数组同级</span></strong><span class="ne-text">。之前JAVA里面的ArrayList数据结构，其实现原理是数组，而JAVA的LinkedList的实现原理就是链表了。链表在进行循环遍历时效率不高，但是插入和删除时优势明显，其实C/C++抑或是JAVA这些数据结构都一样——地址……引用……</span></p><p id="8c7be3dc4c48c18392ebe9a3a21f453d" class="ne-p"><br></p><p id="58ae00dffdc23c957024b218a4fe2a7f" class="ne-p" style="text-indent: 2em"><span class="ne-text">单向链表是一种线性表，实际上是由</span><strong><span class="ne-text">节点（Node）</span></strong><span class="ne-text">组成的，一个链表拥有不定数量的节点。其数据在</span><strong><span class="ne-text">内存中存储是不连续的</span></strong><span class="ne-text">，它存储的数据分散在内存中，每个结点只能也只有它能知道下一个结点的存储位置。由N各节点（Node）组成单向链表，每一个Node记录本Node的数据及下一个Node。向外暴露的只有一个头节点（Head），</span><strong><span class="ne-text" style="text-decoration: underline">我们对链表的所有操作，都是直接或者间接地通过其头节点来进行的。</span></strong></p><p id="0486b484d9c64e85ae8df6456202c9d8" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1603194076184-195f3044-1083-4244-9eeb-d86c96a37e6f.png" width="491" id="y2G05" class="ne-image"></p><p id="287ed5b5812f8c5dc5acab531ab80a88" class="ne-p" style="text-align: left; text-indent: 2em"><span class="ne-text">上图中最左边的节点即为头结点（Head），但是添加节点的顺序是从右向左的，添加的新节点会被作为新节点。最先添加的节点对下一节点的引用可以为空。引用是引用下一个节点而非下一个节点的对象。因为有着不断的引用，所以</span><strong><span class="ne-text">头节点就可以操作所有节点</span></strong><span class="ne-text">了。</span></p><p id="37a5d5b22afe684dd87bdb37f699fdbc" class="ne-p" style="text-align: left; text-indent: 2em"><br></p><p id="9497ce3266be94b1f9295a37ec97730e" class="ne-p" style="text-indent: 2em"><span class="ne-text">下图描述了单向链表存储情况。存储是分散的，每一个节点只要记录下一节点，就把所有数据串了起来，形成了一个单向链表。</span></p><p id="1cb7d03553cc0fa59abb313b8c76e605" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1603194105521-d31f8e78-7f2a-4c60-8838-57e15707e27b.png" width="195" id="grJMc" class="ne-image"></p><p id="2b230249e0620a7b7bac08dc0c49afbd" class="ne-p" style="text-indent: 2em"><span class="ne-text">节点（Node）是由一个需要储存的对象及对下一个节点的引用组成的。也就是说，节点拥有两个成员：储存的对象、对下一个节点的引用。下面图是具体的说明：</span></p><p id="55b372445df1ebd0fc079c95a7cdeb52" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1603194124335-fc6fc00c-35fb-44e1-a01c-de4b8b5531af.png" width="370" id="MPcIA" class="ne-image"></p><p id="3da71b933dc4ba0ab559566e0a5a7a96" class="ne-p"><br></p><h3 id="Aq3FT"><span class="ne-text">关于链表的指向</span></h3><div class="ne-quote"><p id="b9a522a52b21f6716cf72dde48ffebd2" class="ne-p"><span class="ne-text">【1】何为指向？</span></p></div><p id="3fccb63f4a6337e5f88fb28b45873a5a" class="ne-p"><span class="ne-text">个人觉得链表的相关问题及操作就是理解链表的</span><strong><span class="ne-text">“指向”</span></strong><span class="ne-text">这么个概念，先明确以下几点</span></p><ul class="ne-ul"><li id="2cc71630bb88cfed92846d7a93cca40a"><span class="ne-text">每个节点的</span><strong><span class="ne-text">next</span></strong><span class="ne-text">用来存放</span><strong><span class="ne-text">下一个节点的“地址”</span></strong></li><li id="65cf0414c2481a13c6c9a21ef0be7dbf"><strong><span class="ne-text">每个节点的自身就是地址</span></strong><span class="ne-text">，相当于C语言中数组的数组名就是本数组的地址</span></li></ul><p id="bd5c4f3fd8cef0f7caad73699ea58d9d" class="ne-p"><br></p><div class="ne-quote"><p id="66f673c4f6f0bc17dce2567f2e5064b0" class="ne-p"><span class="ne-text">【2】谁指向谁？</span></p></div><p id="c3111db0cf2ee8b8d4fb2a84131fbd4d" class="ne-p"><strong><span class="ne-text">总结：做题用下面总结的方法，绝对好使</span></strong></p><p id="e99ba7156e434dbd6bc32bd816a6f035" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1616501415627-ee5d1008-a07d-4acb-821b-e227b5cb7ad8.jpeg" width="55" id="BIrmM" class="ne-image"></p><ul class="ne-ul"><li id="c169699238a96a22f348421cb8d23eb3"><strong><span class="ne-text">读的时候：从左往右读，一般左边是某某的next域，右边是具体的结点</span></strong></li><li id="c217a55e6fabfd14cbcce9084eedf109"><strong><span class="ne-text">画的时候：在图中表示为等号左边指向等号右边</span></strong></li></ul><p id="4c686c860538d538bd106f5ac64721f7" class="ne-p"><strong><span class="ne-text"></span></strong></p><p id="e25c398d084c2af531afd302dc939259" class="ne-p"><span class="ne-text">例子：</span></p><p id="55421008445ce977395cfde0ec899cd4" class="ne-p"><span class="ne-text">① </span><code class="ne-code"><span class="ne-text">node.next = prev.next;</span></code></p><p id="c56914d506733f4e7f46b2105d9a08f7" class="ne-p"><span class="ne-text">② </span><code class="ne-code"><span class="ne-text">prev.next = node</span></code></p><p id="2af80e2b9ed35166f790a4a320b7269f" class="ne-p"><span class="ne-text">读法：</span></p><p id="19a7191dca062c4c3a1d9d89c2d086a1" class="ne-p"><span class="ne-text">①“node的next指向prev的下一个结点”</span></p><p id="327d3249675c1750699f5acc083802a6" class="ne-p"><span class="ne-text">（用指针的概念通俗地说，其实就是prev的下一个结点的地址由prev的指针域里面赋值给了node的next指针域里面）</span></p><p id="4f79632f5aecaae5f550faaea0237f6a" class="ne-p"><span class="ne-text">②“prev的next指向node这个结点”</span></p><p id="a92a2aac44c6403f602575bc1f3b116a" class="ne-p"><span class="ne-text">（还可以这么说：将node赋值给prev的next，也就是说prev的下一个结点是node）</span></p><p id="3f0e90b501bed8fa69c01c2bdf014acc" class="ne-p"><strong><span class="ne-text"></span></strong></p><p id="56d8b5f2c7ac7c9b9e18f93387a7c499" class="ne-p"><br></p><p id="c6a1d4a8cbe7b36a97ddb92a4eab18d0" class="ne-p" style="text-align: left"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1599309003706-ad779a14-1678-4d0c-86f2-b147752bd252.png" width="328" id="xCmIZ" class="ne-image"></p><p id="378d2212f658d52c8fecd6a063078f6f" class="ne-p" style="text-align: left"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1599309003751-ffeee4d8-9662-416e-8f46-5cf5edf03114.png" width="324" id="SUwQZ" class="ne-image"></p><p id="f33d58f9c2135015e50cd632ee29f224" class="ne-p" style="text-align: left"><img src="https://cdn.nlark.com/yuque/0/2020/png/1484158/1599309003658-46b3e7db-e6dc-4d13-baea-e7e44075e8bc.png" width="344" id="knAnJ" class="ne-image"></p><p id="65d1058f0d85fbe900ec755111ed2582" class="ne-p"><br></p><div class="ne-quote"><p id="0b73013ce5e35f1fc49270bd59ede650" class="ne-p"><span class="ne-text">【3】指向错位？</span></p></div><p id="9652a1886ad8458f39492fcf396b361a" class="ne-p"><strong><span class="ne-text">关注第一个元素节点是不是head，因为有的链表不声明头节点（head），直接就是第一个结点就是元素结点</span></strong></p><h3 id="wCCZi"><span class="ne-text">关于p=L的理解</span></h3><p id="b5903ee1ed44d08989b2aaf858ba1a47" class="ne-p"><span class="ne-text">写代码的时候，还经常遇到下面的情况</span></p><p id="22e2a41b379b545011d6dba722e6440c" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616501697301-b63e6312-d8f9-4130-8d25-2d3becd75038.png" width="233" id="sQQqv" class="ne-image"></p><p id="90e4c31faebbcdf8ad4edd95189d5cd0" class="ne-p"><span class="ne-text">p、L就是指向结点的指针类型，将L的值赋给p，也就是p、L指向同一个结点。具体理解可以用下面一个例子来说明：</span></p><p id="e77fbf67f75189f49760964c7edbbb44" class="ne-p"><span class="ne-text">下面图片这个函数就是在一个单链表中，功能就是指定i位置插入e值。下图箭头处如果TraverseList返回的是p那么得出的链表结果就是从插入的那个元素往后这样一个部分链表，返回的是L就是想要的结果，p的功能有点类似在L的中间做了手脚……</span></p><p id="ea6d7ac80e26cac99036b09285d023d1" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616501856348-955542eb-258d-473f-b003-c53881275937.png" width="370" id="IhEAo" class="ne-image"></p><h2 id="j3WQa"><span class="ne-text">各种代码</span></h2><h3 id="6qnQd"><span class="ne-text">实验报告代码</span></h3><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;<p>typedef struct LNode &#123;<br>    int data;<br>    struct LNode *next;<br>&#125;Lnode, *LinkList;</p><p>LinkList L;</p><p>void InitList(LinkList &amp;L) &#123;<br>    L = new LNode;<br>    L-&gt;next = NULL;<br>&#125;</p><p>void CreateList_H(LinkList &amp;L) &#123;<br>    InitList(L);<br>    int n;<br>    cout &lt;&lt; &quot;请输入要使用前插法插入的元素个数：&quot;;<br>    cin &gt;&gt; n;<br>    for (int i = 0; i &lt; n; i++)&#123;<br>        LNode *p = new LNode;<br>        cin &gt;&gt; p-&gt;data;<br>        p-&gt;next = L-&gt;next;<br>        L-&gt;next = p;<br>    &#125;<br>&#125;<br>void TraverseList(LinkList &amp;L)&#123;<br>    LNode *p = new LNode;<br>    p = L-&gt;next;<br>    cout &lt;&lt; &quot;此链表打印的结果为：&quot;&lt;&lt;&quot;\n&quot;;<br>    while (p != NULL)&#123;<br>        cout &lt;&lt; p-&gt;data &lt;&lt; &quot; &quot;;<br>        p = p-&gt;next;<br>    &#125;<br>    cout &lt;&lt; &quot;\n&quot;;<br>&#125;<br>void GetElem(LinkList &amp;L) &#123;<br>    int n;<br>    cout &lt;&lt; &quot;请输入要查询的链表中第i个数：&quot;;<br>    cin &gt;&gt; n;<br>    LNode *p = new LNode;<br>    p = L;<br>    for (int i = 0; i &lt; n;i++)&#123;<br>        p = p-&gt;next;<br>    &#125;<br>    cout &lt;&lt; &quot;查询的结果为：&quot; &lt;&lt; p-&gt;data&lt;&lt;&quot;\n&quot;;<br>&#125;<br>void ListInsert(LinkList &amp;L)&#123;<br>    LNode *p = new LNode;<br>    p = L;<br>    int n;<br>    int e;<br>    cout &lt;&lt; &quot;请分别输入要在第n个位置插入的e值：&quot;;<br>    cin &gt;&gt; n&gt;&gt; e ;<br>    for (int i = 0; i &lt; n;i++) &#123;<br>        if (n == i+1)&#123;<br>            LNode *temp = new LNode;<br>            temp-&gt;data = e;<br>            temp-&gt;next = p-&gt;next;<br>            p-&gt;next = temp;<br>            break;<br>        &#125;<br>        p = p-&gt;next;<br>    &#125;<br>    TraverseList(L); // 直接返回L就可以了，之前返回p是不可以的！！！唉，大意了~<br>&#125;<br>void ListDelete(LinkList &amp;L)&#123;<br>    cout &lt;&lt; &quot;请输入要删除的第j个位置的j值：&quot;;<br>    LNode *p = new LNode;<br>    p = L;<br>    int j;<br>    cin &gt;&gt; j;<br>    for (int i = 0; i &lt; j;i++) &#123;<br>        if (j == i+1) &#123;<br>            p-&gt;next = p-&gt;next-&gt;next;<br>            break;<br>        &#125;<br>        p = p-&gt;next;<br>    &#125;<br>    TraverseList(L);<br>&#125;<br>void ReverseList(LinkList &amp;L) &#123;<br>    LNode *p = L-&gt;next;<br>    L-&gt;next = NULL;<br>    while(p)<br>    &#123;<br>        LNode *q = p-&gt;next;<br>        p-&gt;next = L-&gt;next;<br>        L-&gt;next = p;<br>        p = q;<br>    &#125;<br>    cout &lt;&lt; &quot;通过逆置之后……&quot;;<br>    TraverseList(L);<br>&#125;</p><p>int main() &#123;<br>    LNode *test = new LNode;<br>    CreateList_H(test);//1<br>    TraverseList(test);//1<br>    GetElem(test);//2<br>    ListInsert(test);//3<br>    ListDelete(test);//4<br>    ReverseList(test);//5<br>&#125;<br></code></pre></p><p id="6924a6f6a888785632ceae0b56ec2c76" class="ne-p"><br></p><h3 id="vUcQ1"><span class="ne-text">单链表各种操作代码总结</span></h3><ul class="ne-tl"><li checked="true" id="d8f54fbe28dd447b243ee72253190acc"><span class="ne-text">单链表存储形式</span></li></ul><pre><code>typedef struct LNode &#123;    int data; //数据域    struct LNode *next; //指针域&#125;Lnode, *LinkList; //LinkList为指向结构体LNode的指针类型</code></pre><ul class="ne-tl"><li checked="true" id="027dcb64e4c7da81c1dce8344a65d6fc"><span class="ne-text">初始化</span></li><li checked="true" id="0c0d3140097f699146d288977fa442b9"><span class="ne-text">创建：前插法</span></li><li checked="true" id="c7a314b61d17dd1aa7915287ece885a1"><span class="ne-text">创建：后插法</span></li><li checked="true" id="dc521ab52463696309916d7834adee61"><span class="ne-text">取值</span></li><li checked="true" id="0040cab7104e6ad31c114f5380f60ead"><span class="ne-text">插值</span></li><li checked="true" id="8eeed69d6492556fbea91c72881e50e7"><span class="ne-text">删除</span></li><li checked="true" id="fd5154d1130614337170b6352b00cc10"><span class="ne-text">打印</span></li><li checked="true" id="9c3c22c01869ff0d25e899ab92ffe053"><strong><span class="ne-text">逆置</span></strong></li></ul><p id="efde38cb18c702fbc13b193fd111d4a5" class="ne-p"><span class="ne-text">逆置多用前插的思想</span></p><pre><code>void ReverseList(LinkList &amp;L) &#123;    LNode *p = L-&gt;next;                 L-&gt;next = NULL;                    while(p) &#123;        LinkList q = p-&gt;next;                 p-&gt;next = L-&gt;next;                  L-&gt;next = p;                        p = q;                          &#125;&#125;</code></pre><p id="85d0a02ed4a1f5c0e36e8c9878c2b016" class="ne-p"><span class="ne-text">所有操作如下</span></p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;<p>/**</p><ul><li>单链表</li><li></li><li>链表的基本操作：初始化、创建（前插、后插）、取值、查找、插值、删除、打印、逆置</li><li>/</li></ul><p>/* 单链表的存储结构 */<br>typedef struct LNode &#123;<br>    int data; //数据域<br>    struct LNode *next; //指针域<br>&#125;Lnode, *LinkList; //LinkList为指向结构体LNode的指针类型</p><p>/* 初始化链表 */<br>void InitList(LinkList &amp;L) &#123;<br>    L = new LNode;<br>    L-&gt;next = NULL;<br>&#125;</p><p>/* 创建：前插 */<br>void CreateList_H(LinkList &amp;L, int n) &#123;<br>    InitList(L);<br>    for (int i = 0; i &lt; n; i++)&#123;<br>        LNode *p = new LNode;<br>        cin &gt;&gt; p-&gt;data;<br>        p-&gt;next = L-&gt;next;<br>        L-&gt;next = p;<br>    &#125;<br>&#125;</p><p>/* 创建：后插 */<br>void CreateList_R(LinkList &amp;L, int n) &#123;<br>    cout &lt;&lt; &quot;请输入&quot; &lt;&lt; n &lt;&lt; &quot;个数字&quot;&lt;&lt; &quot;\n&quot;;<br>    InitList(L);<br>    // 定义一个在下面循环用来一直操作所加元素的结点p来指向头结点L<br>    LinkList p = L;<br>    for (int i = 0; i &lt; n;i++) &#123;<br>        LinkList q = new Lnode;<br>        q-&gt;next = NULL;<br>        cin &gt;&gt; q-&gt;data;<br>        p-&gt;next = q;<br>        p = q; //为了下一次<br>    &#125;<br>&#125;</p><p>/* 取值 */<br>void GetElem(LinkList &amp;L, int n) &#123;<br>    LinkList p = L;<br>    for (int i = 0; i &lt; n;i++)&#123;<br>        p = p-&gt;next;<br>    &#125;<br>    cout &lt;&lt;n&lt;&lt;&quot;的值为：&quot; &lt;&lt; p-&gt;data&lt;&lt;&quot;\n&quot;&lt;&lt;&quot;\n&quot;;<br>&#125;</p><p>/* 查找 */<br>void SearchElem(LinkList &amp;L, int ele) &#123;<br>    LinkList p = L;<br>    int count = 0;<br>    while (p-&gt;data != ele) &#123;<br>        p = p-&gt;next;<br>        count++;<br>    &#125;<br>    cout &lt;&lt;ele&lt;&lt;&quot;这个值的索引位置是：&quot;&lt;&lt; count&lt;&lt;&quot;\n&quot;;<br>&#125;</p><p>/* 插值：在第n个位置插入ele值*/<br>void ListInsert(LinkList &amp;L, int n, int ele)&#123;<br>    LinkList p = L;<br>    for (int i = 0; i &lt; n;i++) &#123;<br>        if (n == i+1)&#123;<br>            LinkList temp = new LNode;<br>            temp-&gt;data = ele;<br>            temp-&gt;next = p-&gt;next;<br>            p-&gt;next = temp;<br>            break;<br>        &#125;<br>        p = p-&gt;next;<br>    &#125;<br>    TraverseList(L);<br>&#125;</p><p>/* 删除：删除第j个位置的值 */<br>void ListDelete(LinkList &amp;L, int j)&#123;<br>    LinkList p = L;<br>    for (int i = 0; i &lt; j;i++) &#123;<br>        if (j == i+1) &#123;<br>            p-&gt;next = p-&gt;next-&gt;next;<br>            break;<br>        &#125;<br>        p = p-&gt;next;<br>    &#125;<br>    TraverseList(L);<br>&#125;</p><p>/* 打印 */<br>void TraverseList(LinkList &amp; L)&#123;<br>        LNode <em>p = new LNode;<br>        p = L-&gt;next;<br>        cout &lt;&lt; &quot;此链表打印的结果为：&quot;<br>             &lt;&lt; &quot;\n&quot;;<br>        while (p != NULL)<br>        &#123;<br>            cout &lt;&lt; p-&gt;data &lt;&lt; &quot; &quot;;<br>            p = p-&gt;next;<br>        &#125;<br>        cout &lt;&lt; &quot;\n&quot;;<br>&#125;<br>/</em> 逆置 */<br>void ReverseList(LinkList &amp;L) &#123;<br>    LNode *p = L-&gt;next;<br>    L-&gt;next = NULL;<br>    while(p)<br>    &#123;<br>        LNode *q = p-&gt;next;<br>        p-&gt;next = L-&gt;next;<br>        L-&gt;next = p;<br>        p = q;<br>    &#125;<br>    cout &lt;&lt; &quot;通过逆置之后……&quot;;<br>    TraverseList(L);<br>&#125;</p><p>int main() &#123;<br>    // LNode *test = new LNode;<br>    LinkList test;<br>    // struct LNode *test;<br>    CreateList_R(test,4);<br>    SearchElem(test, 3);<br>    // cout &lt;&lt; GetEle(test, 2);<br>    // TraverseList(test);<br>    // GetElem(test,2);<br>    // ListInsert(test);<br>    // ListDelete(test);<br>    // ReverseList(test);<br>&#125;<br></code></pre></p><h3 id="9cNHm"><span class="ne-text">循环链表代码</span></h3><p id="549db6ef0c251cb77027ad7d5eaff608" class="ne-p"><span class="ne-text"> * 循环链表其实只需要注意最后一个结点所指向的下一个结点为头结点L就好了</span></p><p id="da588e22a9aeca27b818a25ed2e924a5" class="ne-p"><span class="ne-text"> * 还要注意头结点存不存元素</span></p><p id="e50f21c2f1c86db9888257f67c4fc1a7" class="ne-p"><span class="ne-text"> * 还有判断的时候条件不是单链表那样判断是否为空了，而是是否为头结点的值了</span></p><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;<p>/**</p><ul><li>循环链表</li><li></li><li>循环链表其实只需要注意最后一个结点所指向的下一个结点为头结点L就好了</li><li>还要注意头结点存不存元素</li><li>还有判断的时候条件不是单链表那样判断是否为空了，而是是否为头结点的值了</li><li>/</li></ul><p>/* 定义一个单链表 */<br>typedef struct LNode &#123;<br>    int data;<br>    struct LNode *next;<br>&#125;Lnode, *LinkList;</p><p>/**</p><ul><li>初始化单链表</li><li>/<br>void InitList(LinkList &amp;L) &#123;<br>  L = new LNode;<br>  L-&gt;next = NULL;<br>&#125;</li></ul><p>/**</p><ul><li>初始化单链表并将其变成循环链表</li><li>/</li></ul><p>void CircleList(LinkList &amp;L, int n) &#123;<br>    InitList(L);<br>    // 初始化第一个结点的值<br>    L-&gt;data = 1;<br>    LinkList p = L;<br>    for (int i = 2; i &lt;= n; i++) &#123;<br>        LinkList temp = new Lnode;<br>        temp-&gt;data = i;<br>        if (i == n) &#123;<br>            temp-&gt;next = L;<br>            p-&gt;next = temp;<br>            break;<br>        &#125;<br>        temp-&gt;next = NULL;<br>        p-&gt;next = temp;<br>        p = p-&gt;next;<br>    &#125;<br>&#125;</p><p>/**</p><ul><li>打印输出用来测试是否为循环链表</li><li>/<br>void PrintList(LinkList &amp;L, int n) &#123;<br>  LinkList p = L;<br>  for (int i = 0; i &lt; n;i++) &#123;<pre><code>  cout &amp;lt;&amp;lt; p-&amp;gt;data &amp;lt;&amp;lt; &amp;quot; &amp;quot;;  p = p-&amp;gt;next;</code></pre>  }<br>}</li></ul><p>int main() {<br>    LinkList test;<br>    CircleList(test,5);<br>    PrintList(test, 12);<br>}<br></code></pre></p><p id="ff79e6e706f18ea894d0ae5a945a8faa" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1618307254729-8f60bc5d-be41-47fe-a2ad-466715cc740e.png" width="298" id="w18Z2" class="ne-image"></p><h3 id="oJUke"><span class="ne-text">双向链表代码</span></h3><ul class="ne-ul"><li id="7af3cafdf043e6e1bf6359aa4e769148"><span class="ne-text">双向链表从某种意义上来说，更加简单了，因为可操作的“指向更多了”，但正因为这样，所以每次指向操作之后，检查一下有没有“落单的指向”</span></li><li id="86ad4ef024a48d73c326810ae865c10b"><span class="ne-text">删除某个结点的时候，一定要记得删除哪个结点，就操作哪个结点</span></li></ul><pre><code>#include&lt;bits/stdc++.h&gt;using namespace std;<p>/**</p><ul><li>双向链表</li><li>/</li></ul><p>/* 双向链表的存储结构 */<br>typedef struct DuLNode &#123;<br>    int data;<br>    struct DuLNode *prior;<br>    struct DuLNode *next;<br>&#125;DuLnode, *DuLinkList; </p><p>/* 双向链表的初始化 */<br>void InitDuLinkList(DuLinkList &amp;L) &#123;<br>    L = new DuLNode;<br>    L-&gt;prior = NULL;<br>    L-&gt;next = NULL;<br>&#125;</p><p>int main() &#123;<br>    DuLinkList L;<br>    InitDuLinkList(L);<br>    // 初始化初始节点值为100<br>    L-&gt;data = 100;<br>    // 在L结点前面插值50<br>    DuLinkList L_prior;<br>    L_prior-&gt;data = 50;<br>    L_prior-&gt;next = L;<br>    L-&gt;prior = NULL;<br>    L-&gt;prior = L_prior;<br>    // 在L结点后面插值150<br>    DuLinkList L_next;<br>    L_next-&gt;data = 150;<br>    L_next-&gt;prior = L;<br>    L_next-&gt;next = NULL;<br>    L-&gt;next = L_next;<br>    cout &lt;&lt; L_prior-&gt;data &lt;&lt; &quot; &quot; &lt;&lt; L_prior-&gt;next-&gt;data &lt;&lt; &quot; &quot; &lt;&lt; L_prior-&gt;next-&gt;next-&gt;data&lt;&lt;&quot;\n&quot;;<br>    // 在50和100之间插值75（只操作L结点）<br>    DuLinkList L_prior_L;<br>    L_prior_L-&gt;data = 75;<br>    L_prior_L-&gt;prior = L-&gt;prior;<br>    L-&gt;prior-&gt;next = L_prior_L;<br>    L_prior_L-&gt;next = L;<br>    L-&gt;prior = L_prior_L;<br>    cout &lt;&lt; L-&gt;prior-&gt;prior-&gt;data &lt;&lt; &quot; &quot; &lt;&lt; L-&gt;prior-&gt;data &lt;&lt; &quot; &quot; &lt;&lt; L-&gt;data &lt;&lt;&quot; &quot;&lt;&lt; L-&gt;next-&gt;data&lt;&lt;&quot;\n&quot;;<br>    // 删除75这个值的结点(记住一点，删除哪个结点就操作哪个结点)<br>    L_prior_L-&gt;next-&gt;prior = L_prior_L-&gt;prior;<br>    L_prior_L-&gt;prior-&gt;next = L_prior_L-&gt;next;<br>    cout &lt;&lt; L-&gt;prior-&gt;data &lt;&lt; &quot; &quot; &lt;&lt; L-&gt;data &lt;&lt; &quot; &quot; &lt;&lt; L-&gt;next-&gt;data &lt;&lt; &quot;\n&quot;;<br>&#125;<br></code></pre></p><p id="f11573736063c8fe96bf5ee924812cba" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1618309282126-1ad3d5c4-1d3e-425f-b474-27f33261ead6.png" width="263" id="cIkbQ" class="ne-image"></p><h2 id="fi44g"><span class="ne-text">参考</span></h2><ul class="ne-ul"><li id="62da17fbdf777d52c0d1361001a230c1"><a href="http://shangdixinxi.com/detail-1507915.html" data-href="http://shangdixinxi.com/detail-1507915.html" target="_blank" class="ne-link"><span class="ne-text">链表p-&gt;next=q-&gt;next,q-&gt;next=p,q=p;的一些解释</span></a></li><li id="fc4623d0caae8ec3ef1caecb202218cf"><a href="https://blog.csdn.net/weixin_44135282/article/details/90348885" data-href="https://blog.csdn.net/weixin_44135282/article/details/90348885" target="_blank" class="ne-link"><span class="ne-text">p-&gt;next=q与q=p-&gt;next区分</span></a></li><li id="47c085a3d88531803ecee1fec885d77d"><a href="https://www.jianshu.com/p/73d56c3d228c" data-href="https://www.jianshu.com/p/73d56c3d228c" target="_blank" class="ne-link"><span class="ne-text">数据结构：链表</span></a></li></ul><p id="0f9e0d8be38732af40953d37ead05312" class="ne-p"><br></p></div>]]></content>
      
      
      <categories>
          
          <category> 计算机素养 </category>
          
          <category> 数据结构与算法 </category>
          
          <category> 📶线结构：字符串-数组-栈-队列 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript函数及this不同场景下的指向</title>
      <link href="/blog/egols2d1kxs2/"/>
      <url>/blog/egols2d1kxs2/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="ueac13956" class="ne-p"><span class="ne-text">前言：基本上和之前学过的语言一样，return语句、continue语句、break语句、函数的传参用法基本都一样，记录一下js的特征用法</span></p><h1 id="EEH6p"><span class="ne-text">一、函数</span></h1><h2 id="X8waC"><span class="ne-text">函数定义及使用</span></h2><p id="72f9191dd6c40f9c957d08a6a4fb5fa6" class="ne-p"><span class="ne-text">不像之前的C++、JAVA那样需要一个返回值来声明，JavaScript里面直接一个关键字就搞定了，如果里面有return就返回return的值，没有则返回undefined。下面记录一下js里面的三种函数声明方式和不同情况下的使用场景。</span></p><h3 id="C0pXG"><span class="ne-text">function关键字</span></h3><div class="ne-quote"><p id="cac310a57f721c495201fd8f43fd717a" class="ne-p"><span class="ne-text">自定义函数方式(命名函数)利用函数关键字 function 自定义函数方式</span></p></div><pre><code>// 声明定义方式function fn() &#123;...&#125;// 调用  fn();</code></pre><ul class="ne-ul"><li id="f79542d89be6709192b07b467ab1226b"><span class="ne-text">调用函数的代码既可以放到声明函数的前面，也可以放在声明函数的后面</span></li></ul><h3 id="LMsru"><span class="ne-text">匿名函数表达式</span></h3><p id="uf48c7914" class="ne-p"><span class="ne-text">函数表达式方式(匿名函数）</span></p><div class="ne-quote"><p id="d040539e6b580f6af5b43432e1718261" class="ne-p"><span class="ne-text">【C++11里面也有匿名函数的用法，基本上就是</span><strong><span class="ne-text">匿名函数表达式</span></strong><span class="ne-text">】</span></p></div><pre><code>// 这是函数表达式写法，匿名函数后面跟分号结束var fn = function()&#123;...&#125;;// 调用的方式，函数调用必须写到函数体下面fn();</code></pre><ul class="ne-ul"><li id="d283d6025aa0cb9c95c9e5d6432ca365"><span class="ne-text">这个fn 里面存储的是一个函数</span></li><li id="5426ae5b14dc2793b18c9f79bb1cf86b"><span class="ne-text">函数表达式方式原理跟声明变量方式是一致的</span></li><li id="80bea0e7c9c366bf13aed839abfac9c2"><span class="ne-text">函数调用的代码必须写到函数体后面</span></li></ul><h3 id="RafLV"><span class="ne-text">构造函数</span></h3><ul class="ne-ul"><li id="aeb9c9b1aab71e3be3ce5b0910474db7"><span class="ne-text">所有函数都是Function的对象，函数也是对象</span></li></ul><pre><code>var f = new Function('a', 'b', 'console.log(a + b)');f(1, 2);var fn = new Function('参数1','参数2'..., '函数体')</code></pre><p id="u336b8edc" class="ne-p"><br></p><h2 id="xa3mE"><span class="ne-text">函数参数</span></h2><h3 id="zek5T"><span class="ne-text">arguments</span></h3><p id="f311e77fa167c8ab1de5f667408fff32" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1617851666624-a963acb7-8a97-43bc-9998-35738a1a1a7f.png" width="467.5" id="OVrKI" class="ne-image"></p><p id="d6a5429b661f0a926663653c08d5a96f" class="ne-p"><strong><span class="ne-text">当不确定有多少个参数传递的时候，可以用 arguments 来获取</span></strong><span class="ne-text">。JavaScript 中，arguments实际上它是当前函数的一个内置对象。所有函数都内置了一个 arguments 对象，arguments 对象中存储了传递的所有实参。arguments展示形式是一个伪数组，因此可以进行遍历。伪数组具有以下特点：</span></p><ul class="ne-ul"><li id="8843827210f3e42e9156792599a0c118"><span class="ne-text">具有 length 属性</span></li><li id="b11e149419c70d416f470742d52ad2ea"><span class="ne-text">按索引方式储存数据</span></li><li id="af2df2e4345f47f3086f4e9675aa2d5e"><span class="ne-text">不具有数组的 push , pop 等方法<br /></span><span class="ne-text">注意：在函数内部使用该对象，用此对象获取函数调用时传的实参。</span></li></ul><h3 id="tJe43"><span class="ne-text">箭头函数中arguments不可用</span></h3><p id="d00f8bade49b871e8239cf73671daa98" class="ne-p"><span class="ne-text">es6的箭头函数用起来很方便，但是一个不方便的就是在这里面</span><span class="ne-text">arguments 不能用了</span></p><p id="a1d8c49b30b7ae2677e321044c51a114" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1617852137156-ea361bcf-a64d-40e7-9ad4-de9ad5a2789d.png" width="464" id="FOFeI" class="ne-image"></p><p id="46c2b14c2b66de8578ce1092cd594b13" class="ne-p"><span class="ne-text">如果非要用的化，将这个箭头函数放在一个普通函数里面，让箭头函数接受这个普通函数的参数</span></p><p id="494bcad7a1c0a199d65391a31a8e438e" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1617852218090-65cab2f5-0088-41e5-95fa-0845a253fcbd.png" width="377" id="kFJpX" class="ne-image"></p><h3 id="YcdT5"><span class="ne-text">关于值传递</span></h3><p id="828ba1738a54a70ab3e620409dd3bde3" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1617852230127-5b2394d1-82c0-48a4-8bbb-385f5d27760b.png" width="406.5" id="Iq2ke" class="ne-image"></p><h2 id="iPHty"><span class="ne-text">简单/复杂数据类型传参</span></h2><ul class="ne-ul"><li id="u7e7dc6da"><span class="ne-text"></span><strong><span class="ne-text">简单类型</span></strong><span class="ne-text">（</span><strong><span class="ne-text">基本数据类型</span></strong><span class="ne-text">、</span><strong><span class="ne-text">值类型</span></strong><span class="ne-text">）：在存储时变量中存储的是值本身，包括string ，number，boolean，undefined，null</span></li><li id="u1e4d266a"><span class="ne-text"></span><strong><span class="ne-text">复杂数据类型（引用类型）</span></strong><span class="ne-text">：在存储时变量中存储的仅仅是地址（引用），通过 new 关键字创建的对象（系统对象、自定义对象），如 Object、Array、Date等；</span></li></ul><h3 id="NyCmw"><span class="ne-text">堆栈存储区别</span></h3><p id="uac14d1ad" class="ne-p"><span class="ne-text">堆栈空间分配区别：</span></p><p id="u0d4c51a5" class="ne-p"><span class="ne-text">1、栈（操作系统）：由操作系统自动分配释放存放函数的参数值、局部变量的值等。其操作方式类似于数据结构中的栈；</span></p><p id="ud59709bd" class="ne-p"><span class="ne-text">简单数据类型存放到栈里面</span></p><p id="ufb2855d4" class="ne-p"><span class="ne-text">2、堆（操作系统）：存储复杂类型(对象)，一般由程序员分配释放，若程序员不释放，由垃圾回收机制回收。</span></p><p id="ue7c0d4a8" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611885075555-12234777-10f8-4df1-8a9f-e61078298520.png" width="238" id="OjtFR" class="ne-image"></p><p id="ub0f3ed76" class="ne-p"><span class="ne-text">简单数据类型的存储方式：值类型变量的数据直接存放在变量（栈空间）中</span></p><p id="ucd1e1316" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611885085102-7ebb3c36-ffc2-4a5b-af50-c8e377f92cef.png" width="394.5" id="IeCaI" class="ne-image"></p><p id="uddc1f7fd" class="ne-p"><span class="ne-text">复杂数据类型的存储方式：引用类型变量（栈空间）里存放的是地址，真正的对象实例存放在堆空间中</span></p><p id="uc55c772d" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1611885116525-3f8ac293-e955-40f9-bbff-1aa589b53efa.png" width="279" id="jlWv9" class="ne-image"></p><h3 id="ABgTS"><span class="ne-text">简单类型传参</span></h3><p id="u90c5491d" class="ne-p"><span class="ne-text">函数的形参也可以看做是一个变量，当我们把一个</span><strong><span class="ne-text">值类型变量</span></strong><span class="ne-text">作为参数传给函数的形参时，其实是把变量在栈空间里的值</span><strong><span class="ne-text">复制了一份给形参</span></strong><span class="ne-text">，那么在方法内部对形参做任何修改，都不会影响到的外部变量。</span></p><pre><code>let some = 111;const change = (o) =&gt; &#123;  o = 222;&#125;;console.log(some); // 111change(some);console.log(some); // 111</code></pre><h3 id="LhYgy"><span class="ne-text">复杂数据类型传参</span></h3><p id="ud7624fb8" class="ne-p"><span class="ne-text">函数的形参也可以看做是一个变量，当我们把引用类型变量传给形参时，其实是把变量在栈空间里保存的堆地址复制给了形参，形参和实参其实保存的是同一个堆地址，所以操作的是同一个对象。</span></p><pre><code>const obj = &#123;  x: 111,&#125;;const change = (o) =&gt; &#123;  o.x = 222;&#125;;console.log(obj.x); // 111change(obj);console.log(obj.x); // 222</code></pre><h1 id="t0M8K"><span class="ne-text">二、this</span></h1><h2 id="uG7dX"><span class="ne-text">几个常用this指向</span></h2><ul class="ne-ul"><li id="b12db0c1b44a96c0860ec712b67838a8"><span class="ne-text">全局作用域或者普通函数中this指向全局对象window（定时器里面的this指向window）</span></li></ul><pre><code>function fn() &#123;  console.log(this); // Window&#125;window.fn();window.setTimeout(function () &#123;  console.log(this); // Window&#125;, 1000);</code></pre><ul class="ne-ul"><li id="d940230ffea7da43e23a70b95c5abe22"><span class="ne-text">方法调用中谁调用this指向谁</span></li></ul><pre><code>var o = &#123;  sayHi: function () &#123;    console.log(this); // this指向的是 o 这个对象  &#125;,&#125;;o.sayHi();</code></pre><p id="u83d3980c" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1668946804214-60fa4a1f-3e55-4376-b6e0-9edfe81b9acd.png" width="129.6" id="udc71e238" class="ne-image"></p><pre><code>var btn = document.querySelector(&quot;button&quot;);btn.addEventListener(&quot;click&quot;, function () &#123;  console.log(this); // 事件处理函数中的this指向的是btn这个按钮对象&#125;);</code></pre><p id="u49a7f530" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1668946866999-00e9175c-7986-4596-83ed-9c420904b214.png" width="167.2" id="uebc3722c" class="ne-image"></p><ul class="ne-ul"><li id="3d0a596a8316330855355f25214d49d7"><span class="ne-text">构造函数中this指向构造函数的实例</span></li></ul><pre><code>function Fun() &#123;  console.log(this); // this 指向的是fun 实例对象&#125;var fun = new Fun();</code></pre><p id="ub91c4c50" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2022/png/1484158/1668946751737-3b11c194-1db4-4353-9d1a-f17f78355fa8.png" width="159.2" id="u05e77006" class="ne-image"></p><h2 id="sUQvc"><span class="ne-text">改变函数内部this指向</span></h2><p id="uf7ff9938" class="ne-p"><span class="ne-text">这些 this 的指向，是当我们调用函数的时候确定的。调用方式的不同决定了this 的指向不同</span></p><p id="u3a0b5eb4" class="ne-p"><span class="ne-text">一般指向我们的调用者.</span></p><h3 id="oTowG"><span class="ne-text">call方法</span></h3><p id="80cca7746d6e3f6ddfbe0d0a13db64e5" class="ne-p"><span class="ne-text">call()方法调用一个对象。简单理解为调用函数的方式，但是它可以改变函数的 this 指向</span></p><p id="7d682c1147cd95a30b2a202e05e6d44a" class="ne-p"><span class="ne-text">应用场景:  经常做继承.</span></p><pre><code>var o = &#123;    name: 'andy'&#125; function fn(a, b) &#123;      console.log(this);      console.log(a+b)&#125;;fn(1,2)// 此时的this指向的是window 运行结果为3fn.call(o,1,2)//此时的this指向的是对象o,参数使用逗号隔开,运行结果为3</code></pre><h3 id="SYKcd"><span class="ne-text">apply方法</span></h3><p id="73b1a29ae377fe1ddecf267dd75876bc" class="ne-p"><span class="ne-text">apply() 方法调用一个函数。简单理解为调用函数的方式，但是它可以改变函数的 this 指向。</span></p><p id="dd98af2b8f1c5e1042c608d46e2719dc" class="ne-p"><span class="ne-text">应用场景:  经常跟数组有关系</span></p><pre><code>var o = &#123;    name: 'andy'&#125; function fn(a, b) &#123;      console.log(this);      console.log(a+b)&#125;;fn(1, 2)// 此时的this指向的是window 运行结果为3fn.apply(o,[1,2])//此时的this指向的是对象o,参数使用数组传递 运行结果为3</code></pre><h3 id="qVFN0"><span class="ne-text">bind方法</span></h3><p id="8f2d73d4ff5434244e4816d57d2cb70f" class="ne-p"><span class="ne-text">bind() 方法不会调用函数,但是能改变函数内部this 指向,返回的是原函数改变this之后产生的新函数</span></p><p id="ba3ad094ba0a2a1de54306a05a4b328d" class="ne-p"><span class="ne-text">如果只是想改变 this 指向，并且不想调用这个函数的时候，可以使用bind</span></p><p id="8b4f288bfc20dcaa6db7eb9f1f5a02c5" class="ne-p"><span class="ne-text">应用场景:不调用函数,但是还想改变this指向</span></p><pre><code>var o = &#123; name: 'andy' &#125;;function fn(a, b) &#123;    console.log(this);    console.log(a + b);&#125;;var f = fn.bind(o, 1, 2); //此处的f是bind返回的新函数f();//调用新函数  this指向的是对象o 参数使用逗号隔开</code></pre><h3 id="c1uzr"><span class="ne-text">call、apply、bind三者的异同</span></h3><ul class="ne-ul"><li id="837bea232f7b27b17dfc1aad61300dca"><span class="ne-text">共同点 : 都可以改变this指向</span></li><li id="a9e715db538e1cdabc5c18c1fa0b36bc"><span class="ne-text">不同点:</span></li></ul><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="19a7e4c1e6fc48212336c8fef1dac5ad"><span class="ne-text">call 和 apply  会调用函数, 并且改变函数内部this指向.</span></li><li id="466f286b25babfe9a43ac9c4a313764e"><span class="ne-text">call 和 apply传递的参数不一样,call传递参数使用逗号隔开,apply使用数组传递</span></li><li id="06600e50bdef14fb975e1c3fa12d4f53"><strong><span class="ne-text">bind  不会调用函数</span></strong><span class="ne-text">, 可以改变函数内部this指向.</span></li></ul></ul><ul class="ne-ul"><li id="6da2dd93023b14ff4a91066c042741e8"><span class="ne-text">应用场景</span></li></ul><ol class="ne-list-wrap"><ol ne-level="1" class="ne-ol"><li id="8b224e2fbc010eec2cfde9212337b809"><span class="ne-text">call 经常做继承.</span></li><li id="40e7f61a43b0d91c0459283a016ca67d"><span class="ne-text">apply经常跟数组有关系.  比如借助于数学对象实现数组最大值最小值</span></li><li id="83fdbccdc3765ef1b5c93004952744e1"><span class="ne-text">bind  不调用函数,但是还想改变this指向. 比如改变定时器内部的this指向.</span></li></ol></ol><h2 id="oALIH"><span class="ne-text">setTimeout和setInterval中的this</span></h2><p id="ud51af3d9" class="ne-p" style="text-align: justify"><span class="ne-text" style="color: rgb(77, 77, 77); font-size: 16px">在setTimeOut()或setInterval()这样的方法中，如果传入的函数包含this, 那么，默认情况下，函数中的this会指向window对象。这是由于setTimeout()调用的代码运行在与所在函数完全分离的执行环境上。这会导致这些代码中包含的 this 关键字会指向 window (或全局)对象。有以下几种方式可以正确this指向：</span></p><h3 id="NshPR"><span class="ne-text" style="color: rgb(79, 79, 79)">方法1：将目标对象的this存为一个变量</span></h3><p id="ufc8a20a2" class="ne-p"><span class="ne-text" style="color: rgb(77, 77, 77); font-size: 16px">定时器内部的函数来访问到这个变量，此时的this，就指向了当前对象</span></p><pre><code>function doClick()&#123;  var that = this;  setInterval(function() &#123;    console.log(that.msg);  &#125;, 1000);&#125;</code></pre><h3 id="YqOau"><span class="ne-text" style="color: rgb(79, 79, 79)">方法2：利用bind()方法</span></h3><pre><code>function doClick()&#123;  setInterval(function() &#123;    console.log(this.msg);  &#125;.bind(this), 1000);  //利用bind()将this绑定到这个函数上&#125;</code></pre><h3 id="sOgXx"><span class="ne-text" style="color: rgb(79, 79, 79)">方法3：ES6的箭头函数</span></h3><p id="u9d5a1d2a" class="ne-p"><span class="ne-text" style="color: rgb(77, 77, 77); font-size: 16px">ES6中的箭头函数, this总是指向词法作用域，也就是外层调用者obj，因此利用箭头函数就可以轻松解决这个问题</span></p><pre><code>function doClick()&#123;  setInterval(() =&gt; &#123;    console.log(this.msg);  &#125;, 100);&#125;,</code></pre><h2 id="g0WFc"><span class="ne-text" style="color: rgb(77, 77, 77)">如何准确判断 this 指向的是什么？</span></h2><ol class="ne-ol"><li id="u52767a52"><span class="ne-text" style="color: rgb(77, 77, 77); font-size: 16px">函数是否在 new 中调用 (new 绑定)，如果是，那么 this 绑定的是新创建的对象。</span></li><li id="u7d785062"><span class="ne-text" style="color: rgb(77, 77, 77); font-size: 16px">函数是否通过 call,apply 调用，或者使用了 bind(即硬绑定)，如果是，那么 this 绑定的就是指定的对象。</span></li><li id="u2b7ef61a"><span class="ne-text" style="color: rgb(77, 77, 77); font-size: 16px">函数是否在某个上下文对象中调用 (隐式绑定)，如果是的话，this 绑定的是那个上下文对象。一般是 obj.foo()。</span></li><li id="ua0127edc"><span class="ne-text" style="color: rgb(77, 77, 77); font-size: 16px">如果以上都不是，那么使用默认绑定。如果在严格模式下，则绑定到 undefined，否则绑定到全局对象。</span></li><li id="ub6cad697"><span class="ne-text" style="color: rgb(77, 77, 77); font-size: 16px">如果把 Null 或者 undefined 作为 this 的绑定对象传入 call、apply 或者 bind，这些值在调用时会被忽略，实际应用的是默认绑定规则。</span></li><li id="ud7f7dca0"><span class="ne-text" style="color: rgb(77, 77, 77); font-size: 16px">如果是箭头函数，箭头函数的 this 继承的是外层代码块的 this。</span></li></ol><h1 id="LeD6H"><span class="ne-text">三、闭包</span></h1><p id="76c889831aab9d05eb52cec950336aca" class="ne-p"><span class="ne-text">闭包（closure）指有权访问另一个函数作用域中变量的函数。简单理解就是 ，一个作用域可以访问另外一个函数内部的局部变量。</span></p><h2 id="xs7BF"><span class="ne-text">闭包的作用</span></h2><p id="63e908510a6aff59e9327379faa2435c" class="ne-p"><span class="ne-text">作用：延伸变量的作用范围。</span></p><pre><code>function fn() &#123;  var num = 10;  function fun() &#123;    console.log(num);  &#125;  return fun;&#125;var f = fn();f();</code></pre><h2 id="vzrZP"><span class="ne-text">闭包的案例</span></h2><ol class="ne-ol"><li id="a3a8e47a2abddf99014bff26562b3108"><span class="ne-text">利用闭包的方式得到当前li 的索引号</span></li></ol><pre><code>for (var i = 0; i &lt; lis.length; i++) &#123;// 利用for循环创建了4个立即执行函数// 立即执行函数也成为小闭包因为立即执行函数里面的任何一个函数都可以使用它的i这变量(function(i) &#123;    lis[i].onclick = function() &#123;      console.log(i);    &#125; &#125;)(i);&#125;</code></pre><ol start="2" class="ne-ol"><li id="e23058120f4f4379a7b8c6e3ee120611"><span class="ne-text">闭包应用-3秒钟之后,打印所有li元素的内容</span></li></ol><pre><code>for (var i = 0; i &lt; lis.length; i++) &#123;   (function(i) &#123;     setTimeout(function() &#123;     console.log(lis[i].innerHTML);     &#125;, 3000)   &#125;)(i);&#125;</code></pre><ol start="3" class="ne-ol"><li id="9ada127ae1595d7d5d1f035287cb5726"><span class="ne-text">闭包应用-计算打车价格</span></li></ol><pre><code>/*需求分析打车起步价13(3公里内),  之后每多一公里增加 5块钱.  用户输入公里数就可以计算打车价格如果有拥堵情况,总价格多收取10块钱拥堵费*/ var car = (function() &#123;     var start = 13; // 起步价  局部变量     var total = 0; // 总价  局部变量     return &#123;       // 正常的总价       price: function(n) &#123;         if (n &lt;= 3) &#123;           total = start;         &#125; else &#123;           total = start + (n - 3) * 5         &#125;         return total;       &#125;,       // 拥堵之后的费用       yd: function(flag) &#123;         return flag ? total + 10 : total;       &#125;    &#125; &#125;)();console.log(car.price(5)); // 23console.log(car.yd(true)); // 33</code></pre><p id="98b2a169a1398d289874189535e94975" class="ne-p"><br></p><pre><code>var name = &quot;The Window&quot;;   var object = &#123;     name: &quot;My Object&quot;,     getNameFunc: function() &#123;     return function() &#123;     return this.name;     &#125;;   &#125; &#125;;console.log(object.getNameFunc()())-----------------------------------------------------------------------------------var name = &quot;The Window&quot;;　　  var object = &#123;　　　　    name: &quot;My Object&quot;,    getNameFunc: function() &#123;    var that = this;    return function() &#123;    return that.name;    &#125;;  &#125;&#125;;console.log(object.getNameFunc()())</code></pre><p id="9d3b3410f572bb95a27cf75f4bc16f5d" class="ne-p"><br></p><h1 id="WkFNQ"><span class="ne-text">四、特殊功能性函数</span></h1><h2 id="NODez"><span class="ne-text">立即调用函数</span></h2><p id="u1fbd0b13" class="ne-p"><span class="ne-text">两种表达方式</span></p><ul class="ne-ul"><li id="ub635b41c"><span class="ne-text"> (function(){})()  </span></li><li id="u5533ec3b"><span class="ne-text"> (function(){}())</span></li></ul><p id="u1c9222f1" class="ne-p"><span class="ne-text">与立即执行函数相关的知识还有在函数前面加上一些符号（！、~、+……）会对函数的返回值进行相应的操作，其中加上~的意思是对返回值进行按位取反的操作，具体参考下面的参考资料</span></p><p id="ua9a270d6" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1617956106484-c021320c-100a-49b5-a668-99928bf3a720.png" width="472.98846435546875" id="uWasL" class="ne-image"></p><p id="u1fd169bb" class="ne-p"><span class="ne-text">参考：</span><span class="ne-text">https://blog.csdn.net/hot_cool/article/details/77567166</span></p><h2 id="drews"><span class="ne-text">生成器函数</span></h2><p id="uc723bf0c" class="ne-p"><span class="ne-text">类似于nodejs的express框架的中间件</span></p><p id="uce53102b" class="ne-p"><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/function*" data-href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/function*" target="_blank" class="ne-link"><span class="ne-text">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/function*</span></a></p><h2 id="aT35S"><span class="ne-text">方法函数</span></h2><h3 id="R0omn"><span class="ne-text">方法定义语法</span></h3><pre><code>const obj = &#123;  a: 'dd',  foo() &#123;    return 'bar';  &#125;,  some: () =&gt; &#123;    return 'something.'  &#125;&#125;;<p>console.log(obj.a, obj.foo(), obj.some()); // &quot;dd&quot; &quot;bar&quot; &quot;something.&quot;<br></code></pre></p><h3 id="mHlff"><span class="ne-text">get set函数</span></h3><p id="uc1cacfad" class="ne-p"><span class="ne-text">对象中可以定义get和set函数来完成更好的访问和修改对象属性值逻辑。</span></p><ul class="ne-ul"><li id="uc7d87134"><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/get" data-href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/get" target="_blank" class="ne-link"><span class="ne-text">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/get</span></a></li><li id="udf868282"><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/set" data-href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/set" target="_blank" class="ne-link"><span class="ne-text">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/set</span></a></li></ul><p id="ua14098b9" class="ne-p"><br></p><p id="ue7a71f74" class="ne-p"><br></p><p id="u6453869a" class="ne-p"><br></p><p id="u6dbb4a60" class="ne-p"><br></p><p id="ub6631d00" class="ne-p"><br></p><p id="u99c07e79" class="ne-p"><br></p><p id="u90a29703" class="ne-p"><br></p><p id="u095cadeb" class="ne-p"><br></p><p id="uf6aa086f" class="ne-p"><br></p><p id="u7b48dc95" class="ne-p"><br></p><p id="u1ff70eff" class="ne-p"><br></p><p id="u68ac64c5" class="ne-p"><br></p><p id="ue5cfbb9b" class="ne-p"><br></p><p id="uae970d7a" class="ne-p"><br></p><p id="uc7452431" class="ne-p"><br></p><p id="ubec4ec7f" class="ne-p"><br></p><p id="u8ef53ac6" class="ne-p"><br></p><p id="u9bb83e57" class="ne-p"><br></p><p id="ubddc1f17" class="ne-p"><br></p><p id="uec007e87" class="ne-p"><br></p><p id="u9fbc16a3" class="ne-p"><br></p><p id="u83da4ff8" class="ne-p"><br></p><p id="ufc0c584e" class="ne-p"><br></p><p id="u2ee70ca3" class="ne-p"><br></p><p id="u65dada90" class="ne-p"><br></p><p id="u08888f00" class="ne-p"><br></p><p id="u8356d7a5" class="ne-p"><br></p><p id="u791a5818" class="ne-p"><br></p><p id="u6973b2cf" class="ne-p"><br></p><p id="u74f7646b" class="ne-p"><br></p><p id="u68cd48ba" class="ne-p"><br></p><p id="ua51cf1a3" class="ne-p"><br></p><p id="u6bf640f1" class="ne-p"><br></p></div>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
          <category> JavaScript </category>
          
          <category> ECMAScript </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>DOM事件</title>
      <link href="/blog/wgzidzz85o76/"/>
      <url>/blog/wgzidzz85o76/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><h2 id="QPRCY"><span class="ne-text">事件（低阶）</span></h2><div class="ne-quote"><p id="ba969457d3d481f4f58736bd6c36d828" class="ne-p"><span class="ne-text">事件三要素</span></p></div><ul class="ne-ul"><li id="5e185517246fffbef0739fa305e1a269"><span class="ne-text" style="background-color: #FADB14">Who(</span><span class="ne-text">事件源)：触发事件的元素</span></li><li id="896a369ca82ab809872eecb47593fe13"><span class="ne-text" style="background-color: #FADB14">What(</span><span class="ne-text">事件类型)： eg绑定click点击事件</span></li><li id="185614550c2f6249c6397a554774211d"><span class="ne-text" style="background-color: #FADB14">How(</span><span class="ne-text">事件处理程序)：事件触发后要执行的代码(函数赋值形式)，事件处理函数</span><strong><span class="ne-text"></span></strong></li></ul><p id="5b2cd1a827b3b52e697f8f9935da47fd" class="ne-p"><br></p><h3 id="QFfkk"><span class="ne-text">常见鼠标事件</span></h3><p id="3e300ab9705fb9183b85eece5ca6ad37" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518355975-babb3ede-4626-4ccd-9507-eb4c35c58439.png" width="714" id="lEgEZ" class="ne-image"></p><p id="952b40b9aa1db2e537818188929e4df5" class="ne-p"><br></p><h3 id="ATUpr"><span class="ne-text">addEventListener()</span></h3><div class="ne-quote"><p id="0d6e9dee2f34c5c515d1092ee25274a5" class="ne-p"><span class="ne-text">事件监听（IE9以后支持）</span></p></div><p id="73fd37530a6735c2e2dcaa5f9cc34d55" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518360715-05c708e0-db51-4791-b3cc-14ca89b6d9bc.png" width="707" id="ioKxV" class="ne-image"></p><p id="eea6d93e364e9871dd6af834731635c1" class="ne-p"><span class="ne-text">eventTarget.addEventListener()方法将指定的监听器注册到 eventTarget（目标对象）上，当该对象触发指定的事件时，就会执行事件处理函数。</span></p><ul class="ne-ul"><li id="a00280620bc4a8d0742c710aafb1252f"><span class="ne-text">type：监听事件类型click……（不要加on，要记得加引号）</span></li><li id="250ea7b30c98112381216e44c2987bb9"><span class="ne-text">listener：监听函数（触发之后进行什么样的行为（函数））</span></li><li id="b55cfb7798c0b34c00b574f86e6cde65"><span class="ne-text">useCapture：默认false</span></li></ul><pre><code>var class_down = document.getElementsByClassName('entry-thumb');var over_img_back_index = class_down[0].getElementsByTagName('img');over_img_back_index[0].addEventListener('mouseover',function()&#123;    alert('鼠标经过左侧图片，触发至即将跳转到首页');    location.href = 'https://www.wztlink1013.com';&#125;)</code></pre><h3 id="pAK2G"><span class="ne-text">attachEvent()</span></h3><div class="ne-quote"><p id="168bdd41b35757469d9dd7d566cacdda" class="ne-p"><span class="ne-text">事件监听（IE678支持）</span></p></div><p id="u93000583" class="ne-p"><span class="ne-text"></span></p><p id="56c0ebbd489fba897b85e1086fa6c3e8" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518360822-32bdd41a-9d13-4b76-93db-3f503b39bba7.png" width="696" id="azBrz" class="ne-image"></p><ul class="ne-ul"><li id="a2aa1adbfb03ca99b8a253c85e02926a"><span class="ne-text">和addEventListener()功能一样，不过这是老版本只带两个参数，而且第一个参数要加on</span></li></ul><h3 id="w1NHT"><span class="ne-text">兼容性解决注册事件</span></h3><p id="1fbe85f60da132b1ec60b147994d8381" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518360652-874303ea-a903-4f8c-93a0-a90c193c661b.png" width="867" id="mEfG9" class="ne-image"></p><p id="dd0475da28d2a7081f17bd64d0f74b23" class="ne-p"><span class="ne-text">封装一个函数，函数中判断浏览器的类型：</span></p><p id="f4837a32f19fbc68970b1d134989a6c5" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518360935-9054e419-704a-402e-969c-a572f0f322e0.png" width="643" id="jojyL" class="ne-image"></p><h3 id="3zq4i"><span class="ne-text">解绑事件</span></h3><p id="16781f9f62f480e76938fbb67d0bffc2" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518360992-53947cad-916b-4b2a-baf9-0587c30a33d9.png" width="737" id="ZW5u1" class="ne-image"></p><pre><code>&lt;div&gt;1&lt;/div&gt;&lt;div&gt;2&lt;/div&gt;&lt;div&gt;3&lt;/div&gt;&lt;script&gt;  var divs = document.querySelectorAll('div');  divs[0].onclick = function() &#123;    alert(11);    // 1. 传统方式删除事件    divs[0].onclick = null;  &#125;  // 2. removeEventListener 删除事件  divs[1].addEventListener('click', fn) // 里面的fn 不需要调用加小括号  function fn() &#123;    alert(22);    divs[1].removeEventListener('click', fn);  &#125;  // 3. detachEvent  divs[2].attachEvent('onclick', fn1);  function fn1() &#123;    alert(33);    divs[2].detachEvent('onclick', fn1);  &#125;&lt;/script&gt;</code></pre><div class="ne-quote"><p id="2ff54bd1d4bd426868a23a25308db2a6" class="ne-p"><strong><span class="ne-text">删除事件兼容性解决方案 </span></strong></p></div><p id="40666cbe6d5320d4846b4bbe5e2ff46b" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518361056-6ce22708-00af-43e8-943d-466fe8fcb053.png" width="713" id="hJ2YZ" class="ne-image"></p><h2 id="r3xe0"><span class="ne-text">常用鼠标事件</span></h2><p id="002c7cabdc9a78deb3d591b99f27e8d6" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518361860-3dea106f-9140-4836-8e7d-2f160b94435b.png" width="683" id="TkrRA" class="ne-image"></p><h3 id="QuEUR"><span class="ne-text">Demo：禁止选中文字和禁止右键菜单</span></h3><div class="ne-quote"><p id="f79c18b0892e2b84000032b48fe1e47b" class="ne-p"><span class="ne-text">【1】禁止鼠标选中</span></p></div><ul class="ne-ul"><li id="7125b6c7239ac18b49da8bb1898ca4f2"><span class="ne-text">selectstart开始选中</span></li></ul><pre><code>document.addEventListener('selectstart', function(e) &#123;  e.preventDefault();&#125;)</code></pre><div class="ne-quote"><p id="fc494d880867d15513a5bffa1c8f808d" class="ne-p"><span class="ne-text">【2】禁止鼠标右键菜单</span></p></div><ul class="ne-ul"><li id="8eb5f8e6b193f716efeae0d29de53e3b"><span class="ne-text">contextmenu主要控制应该合适显示上下文菜单，主要用于程序员取消默认的上下文菜单</span></li></ul><pre><code>document.addEventListener('contextmenu', function(e) &#123;    e.preventDefault();&#125;)</code></pre><h3 id="YIozD"><span class="ne-text">鼠标事件对象</span></h3><p id="4c842015ad6ac6e4f69e5e72c2cae205" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518361978-034f2af6-14fa-4ddb-bd8b-2eabe289eb59.png" width="703" id="GXMNi" class="ne-image"></p><h3 id="kM6Ej"><span class="ne-text">Demo：获取鼠标在页面的坐标</span></h3><pre><code>&lt;script&gt;  // 鼠标事件对象 MouseEvent  document.addEventListener('click', function(e) &#123;    console.log('client 鼠标在可视区的x和y坐标');    console.log(e.clientX);    console.log(e.clientY);    console.log('---------------------');    console.log('page 鼠标在页面文档的x和y坐标');    console.log(e.pageX);    console.log(e.pageY);    console.log('---------------------');    console.log('screen 鼠标在电脑屏幕的x和y坐标');    console.log(e.screenX);    console.log(e.screenY);  &#125;)&lt;/script&gt;</code></pre><h3 id="No1zU"><span class="ne-text">Demo：跟随鼠标的天使</span></h3><p id="e5107b269c65ccd796700aad3cc81a1e" class="ne-p"><br></p><pre><code>&lt;img src=&quot;images/angel.gif&quot; alt=&quot;&quot;&gt;    &lt;script&gt;        var pic = document.querySelector('img');        document.addEventListener('mousemove', function(e) &#123;            // 1. mousemove只要我们鼠标移动1px 就会触发这个事件            // 2.核心原理： 每次鼠标移动，我们都会获得最新的鼠标坐标，             // 把这个x和y坐标做为图片的top和left 值就可以移动图片            var x = e.pageX;            var y = e.pageY;            console.log('x坐标是' + x, 'y坐标是' + y);            //3 . 千万不要忘记给left 和top 添加px 单位            pic.style.left = x - 50 + 'px';            pic.style.top = y - 40 + 'px';        &#125;);    &lt;/script&gt;</code></pre><h3 id="cDws0"><span class="ne-text">mouseenter 和mouseover的区别</span></h3><ul class="ne-ul"><li id="88c115b01a2b6c236f234cf08ef5d7d4"><span class="ne-text">当鼠标移动到元素上时就会触发mouseenter 事件</span></li><li id="f8f15a01a6862e22ba659b724cfd8ce0"><span class="ne-text">类似 mouseover，它们两者之间的差别是</span></li><li id="773ac692fd2f9810e9ed2196af203c10"><span class="ne-text">mouseover 鼠标经过自身盒子会触发，经过子盒子还会触发。mouseenter  只会经过自身盒子触发</span></li><li id="9e4be62c339051eaa945e719c5ba2524"><span class="ne-text">之所以这样，就是因为mouseenter不会冒泡</span></li><li id="696b59f226bc1326eb53ca8b7fa62a5a"><span class="ne-text">跟mouseenter搭配鼠标离开 mouseleave  同样不会冒泡</span></li></ul><h2 id="ct83k"><span class="ne-text">常用键盘事件</span></h2><p id="326f5221d3d3f4d8a6981a19890f683d" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518362322-f21797ca-1e8e-4702-a243-4e76a8458b7e.png" width="701" id="vLAKo" class="ne-image"></p><ul class="ne-ul"><li id="bd4e3c484424ef8f908369b4086c14b5"><span class="ne-text">三个事件执行的顺序是：keydown-&gt;keypress-&gt;keyup</span></li></ul><pre><code>&lt;script&gt;        // 常用的键盘事件        //1. keyup 按键弹起的时候触发         document.addEventListener('keyup', function() &#123;            console.log('我弹起了');        &#125;)        //3. keypress 按键按下的时候触发  不能识别功能键 比如 ctrl shift 左右箭头啊        document.addEventListener('keypress', function() &#123;                console.log('我按下了press');        &#125;)        //2. keydown 按键按下的时候触发  能识别功能键 比如 ctrl shift 左右箭头啊        document.addEventListener('keydown', function() &#123;                console.log('我按下了down');        &#125;)        // 4. 三个事件的执行顺序  keydown -- keypress -- keyup    &lt;/script&gt;</code></pre><h3 id="Gb0Dv"><span class="ne-text">键盘事件对象</span></h3><p id="8945a6b3aa40369f48ed4e09c58901ba" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518362443-95c05d9c-6850-4cc3-a35e-c972b1723658.png" width="700" id="rFUEV" class="ne-image"></p><ul class="ne-ul"><li id="7d80cbe4fe5226cfa7abf4481adc48cd"><span class="ne-text">onkeydown和onkeyup不区分字母大小写，onkeypress区分字母大小写（使用更多的前面两个，能够识别所有键，包括功能键）</span></li><li id="f3ee963cc37dc5d79e3bd27018a9b9c6"><span class="ne-text">keypress不识别功能键，但是keyCode属性能够区分大小写，返回不同的ASCII值</span></li></ul><div class="ne-quote"><p id="cadf8aec7e3856d6ce4b3258b5538441" class="ne-p"><strong><span class="ne-text">使用keyCode属性判断用户按下哪个键</span></strong></p></div><pre><code>&lt;script&gt;        // 键盘事件对象中的keyCode属性可以得到相应键的ASCII码值        document.addEventListener('keyup', function(e) &#123;            console.log('up:' + e.keyCode);            // 我们可以利用keycode返回的ASCII码值来判断用户按下了那个键            if (e.keyCode === 65) &#123;                alert('您按下的a键');            &#125; else &#123;                alert('您没有按下a键')            &#125;        &#125;)        document.addEventListener('keypress', function(e) &#123;            // console.log(e);            console.log('press:' + e.keyCode);        &#125;)    &lt;/script&gt;</code></pre><h3 id="qworo"><span class="ne-text">Demo：模拟京东按键输入内容</span></h3><ul class="ne-ul"><li id="7565f06c60c84c01f09d86ad4c9c2972"><span class="ne-text">当我们按下 s 键， 光标就定位到搜索框（文本框获得焦点）。</span></li><li id="c3d8fb836327ccbbbae84a01cba915de"><span class="ne-text">注意：触发获得焦点事件，可以使用 元素对象.focus()</span></li></ul><p id="8c611ea4d1f59d20b33b39115f4fbe00" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1616211826182-452dfe9b-0c03-4fe3-845c-afc16697e3ee.png" width="960" id="Zx9kR" class="ne-image"></p><h3 id="ZG4dd"><span class="ne-text">Demo：模拟京东快递单号查询</span></h3><p id="84fd26f435a94167f2954643790cdfe9" class="ne-p"><span class="ne-text">要求：当我们在文本框中输入内容时，文本框上面自动显示大字号的内容。</span></p><p id="9429f4798d18e4859b4475998d830317" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518362646-5b0c1da3-32dd-40b4-8b42-1bbb3065c01c.png" width="551" id="GMhtr" class="ne-image"></p><p id="ea68715abcd7776b25fa92976ecbb098" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518362734-9740cabb-bd4d-48ce-824d-001b5913b804.png" width="751" id="wAggT" class="ne-image"></p><pre><code>&lt;div class=&quot;search&quot;&gt;        &lt;div class=&quot;con&quot;&gt;123&lt;/div&gt;        &lt;input type=&quot;text&quot; placeholder=&quot;请输入您的快递单号&quot; class=&quot;jd&quot;&gt;    &lt;/div&gt;    &lt;script&gt;        // 获取要操作的元素        var con = document.querySelector('.con');        var jd_input = document.querySelector('.jd');        // 给输入框注册keyup事件        jd_input.addEventListener('keyup', function() &#123;                // 判断输入框内容是否为空                if (this.value == '') &#123;                    // 为空，隐藏放大提示盒子                    con.style.display = 'none';                &#125; else &#123;                    // 不为空，显示放大提示盒子，设置盒子的内容                    con.style.display = 'block';                    con.innerText = this.value;                &#125;            &#125;)        // 给输入框注册失去焦点事件，隐藏放大提示盒子        jd_input.addEventListener('blur', function() &#123;                con.style.display = 'none';            &#125;)        // 给输入框注册获得焦点事件        jd_input.addEventListener('focus', function() &#123;            // 判断输入框内容是否为空            if (this.value !== '') &#123;                // 不为空则显示提示盒子                con.style.display = 'block';            &#125;        &#125;)    &lt;/script&gt;</code></pre><p id="44e5295e1f2fa53a5af88709aa057e45" class="ne-p"><br></p><h2 id="P79Nv"><span class="ne-text">事件（高阶）</span></h2><h3 id="Rd1zx"><span class="ne-text">DOM事件流</span></h3><pre><code>html中的标签都是相互嵌套的，我们可以将元素想象成一个盒子装一个盒子，document是最外面的大盒子。当你单击一个div时，同时你也单击了div的父元素，甚至整个页面。那么是先执行父元素的单击事件，还是先执行div的单击事件 ？？？</code></pre><p id="c14f201d94d44c81abb8f2c3000bdd67" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518361114-2ab6ad14-e27a-4626-88bd-abbc2badfc0b.png" width="696" id="lErXc" class="ne-image"></p><div class="ne-quote"><p id="78868800be8bc613f36c3edb4b3a1dde" class="ne-p"><span class="ne-text">比如：我们给页面中的一个div注册了单击事件，当你单击了div时，也就单击了body，单击了html，单击了document。</span></p></div><p id="5d4b75ae4678e48d6af7075109db522e" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518361173-9a6bf5d3-a273-4294-b849-0ebaf79da603.png" width="268" id="GVG7z" class="ne-image"></p><p id="37d68242d49f8b52b1a9676369660126" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518361248-0ea0959b-c350-4780-9437-8561fe69f36d.png" width="751" id="EjVGr" class="ne-image"></p><pre><code>当时的2大浏览器霸主谁也不服谁！IE 提出从目标元素开始，然后一层一层向外接收事件并响应，也就是冒泡型事件流。Netscape（网景公司）提出从最外层开始，然后一层一层向内接收事件并响应，也就是捕获型事件流。江湖纷争，武林盟主也脑壳疼！！！最终，w3c 采用折中的方式，平息了战火，制定了统一的标准 —--— 先捕获再冒泡。现代浏览器都遵循了此标准，所以当事件发生时，会经历3个阶段。</code></pre><p id="f556229822e9ba88ea4d1e2850397e9d" class="ne-p"><span class="ne-text">DOM 事件流会经历3个阶段：</span></p><ol class="ne-ol"><li id="12de94fb204e535c5f84f321af9a2479"><span class="ne-text">捕获阶段</span></li><li id="a84b5336e39d35584955ba8353f5e62c"><span class="ne-text">当前目标阶段</span></li><li id="6fadf0984110fb347a97a8f370d60813"><span class="ne-text">冒泡阶段</span></li></ol><p id="f5859b14e6dc68e0781c994a5ca99f01" class="ne-p"><span class="ne-text">    我们向水里面扔一块石头，首先它会有一个下降的过程，这个过程就可以理解为从最顶层向事件发生的最具体元素（目标点）的捕获过程；之后会产生泡泡，会在最低点（ 最具体元素）之后漂浮到水面上，这个过程相当于事件冒泡。</span></p><p id="98adf75e5ed2e0490abafd540d7c00e1" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518361302-fa0b37f5-a8ec-4898-82b6-e136cd291951.png" width="498" id="pnFlw" class="ne-image"></p><p id="efd402678c9324978a2ea7a626841bff" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518361362-b8b1f065-da6a-40c5-8782-b265699cdd49.png" width="757" id="BMWF3" class="ne-image"></p><p id="fa8756cfd13405402d6ac6e0570e8f84" class="ne-p"><strong><span class="ne-text">事件冒泡</span></strong></p><pre><code>&lt;div class=&quot;father&quot;&gt;        &lt;div class=&quot;son&quot;&gt;son盒子&lt;/div&gt;    &lt;/div&gt;    &lt;script&gt;        // onclick 和 attachEvent（ie） 在冒泡阶段触发        // 冒泡阶段 如果addEventListener 第三个参数是 false 或者 省略         // son -&gt; father -&gt;body -&gt; html -&gt; document        var son = document.querySelector('.son');        // 给son注册单击事件        son.addEventListener('click', function() &#123;            alert('son');        &#125;, false);        // 给father注册单击事件        var father = document.querySelector('.father');        father.addEventListener('click', function() &#123;            alert('father');        &#125;, false);        // 给document注册单击事件，省略第3个参数        document.addEventListener('click', function() &#123;            alert('document');        &#125;)    &lt;/script&gt;</code></pre><p id="b7914d45fc380407e7f6dfae0f319192" class="ne-p"><strong><span class="ne-text">事件捕获</span></strong></p><pre><code>&lt;div class=&quot;father&quot;&gt;        &lt;div class=&quot;son&quot;&gt;son盒子&lt;/div&gt;    &lt;/div&gt;    &lt;script&gt;        // 如果addEventListener() 第三个参数是 true 那么在捕获阶段触发        // document -&gt; html -&gt; body -&gt; father -&gt; son         var son = document.querySelector('.son');        // 给son注册单击事件，第3个参数为true         son.addEventListener('click', function() &#123;             alert('son');         &#125;, true);         var father = document.querySelector('.father');        // 给father注册单击事件，第3个参数为true         father.addEventListener('click', function() &#123;             alert('father');         &#125;, true);        // 给document注册单击事件，第3个参数为true        document.addEventListener('click', function() &#123;            alert('document');        &#125;, true)    &lt;/script&gt;</code></pre><h3 id="uscVy"><span class="ne-text">事件对象</span></h3><h4 id="lh6g5"><span class="ne-text">什么是事件对象</span></h4><p id="54b33c7d311826ffec4520d2734a16d0" class="ne-p"><span class="ne-text">事件发生后，跟事件相关的一系列信息数据的集合都放到这个对象里面，这个对象就是事件对象。</span></p><p id="04803a183bddb874739ed06a3f25dc7b" class="ne-p"><span class="ne-text">比如：</span></p><ol class="ne-ol"><li id="e83b68cae6c31114de58901c5fe78d12"><span class="ne-text">谁绑定了这个事件。</span></li><li id="d8251054a60591581beece42e0f44464"><span class="ne-text">鼠标触发事件的话，会得到鼠标的相关信息，如鼠标位置。</span></li><li id="87d5ad226aa335770e51d4b3bef54267"><span class="ne-text">键盘触发事件的话，会得到键盘的相关信息，如按了哪个键。</span></li></ol><h4 id="YD8EB"><span class="ne-text">事件对象的使用</span></h4><p id="fdbd2d9f46988811915af195be4083ee" class="ne-p"><span class="ne-text">事件触发发生时就会产生事件对象，并且系统会以实参的形式传给事件处理函数。</span></p><p id="ee813f86056fc9f048d9aef2064de077" class="ne-p"><span class="ne-text">所以，在事件处理函数中声明1个形参用来接收事件对象。</span></p><p id="6bfa54243984b387569aceda77c3cb0a" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518361420-28ca3202-57b2-48ab-83cb-620191320123.png" width="681" id="yTBu7" class="ne-image"></p><h4 id="MfnbO"><span class="ne-text">事件对象的兼容性处理</span></h4><p id="9761c13e5f19594c776f0c7edfb9a87c" class="ne-p"><span class="ne-text">事件对象本身的获取存在兼容问题：</span></p><ol class="ne-ol"><li id="081e0ad76de02446ef57aff577d7244a"><span class="ne-text">标准浏览器中是浏览器给方法传递的参数，只需要定义形参 e 就可以获取到。</span></li><li id="b61f1d8104467023001dfc0ef676be65"><span class="ne-text">在 IE6~8 中，浏览器不会给方法传递参数，如果需要的话，需要到 window.event 中获取查找。</span></li></ol><p id="caa7a88343b34d34f785c9d7f093d9f7" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518361484-fb99b58d-4733-4716-b625-a14e1cd02938.png" width="660" id="AKYdD" class="ne-image"></p><pre><code>只要“||”前面为false, 不管“||”后面是true 还是 false，都返回 “||” 后面的值。只要“||”前面为true, 不管“||”后面是true 还是 false，都返回 “||” 前面的值。</code></pre><pre><code>&lt;div&gt;123&lt;/div&gt;    &lt;script&gt;        var div = document.querySelector('div');        div.onclick = function(e) &#123;                // 事件对象                e = e || window.event;                console.log(e);        &#125;    &lt;/script&gt;</code></pre><h4 id="v3WbX"><span class="ne-text">事件对象的属性和方法</span></h4><p id="c04df420165c82c6e3649132e76633bd" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518361541-14665361-d721-4083-8cb2-d2088c6dc0cc.png" width="698" id="xkt42" class="ne-image"></p><h4 id="XwqEo"><span class="ne-text">e.target 和 this 的区别</span></h4><ul class="ne-ul"><li id="255fb1cb53b39afbcb0dfdfe62a7354c"><span class="ne-text">this 是事件绑定的元素（绑定这个事件处理函数的元素） 。</span></li><li id="0eefb6af1c1df629f64df9faa64e79f6"><span class="ne-text">e.target 是事件触发的元素。</span></li></ul><pre><code>常情况下terget 和 this是一致的，但有一种情况不同，那就是在事件冒泡时（父子元素有相同事件，单击子元素，父元素的事件处理函数也会被触发执行），    这时候this指向的是父元素，因为它是绑定事件的元素对象，    而target指向的是子元素，因为他是触发事件的那个具体元素对象。</code></pre><pre><code>&lt;div&gt;123&lt;/div&gt;    &lt;script&gt;        var div = document.querySelector('div');        div.addEventListener('click', function(e) &#123;            // e.target 和 this指向的都是div            console.log(e.target);            console.log(this);        &#125;);    &lt;/script&gt;</code></pre><p id="7b5afcc4c8774f913e33749bc991a729" class="ne-p"><span class="ne-text">事件冒泡下的e.target和this</span></p><pre><code>&lt;ul&gt;        &lt;li&gt;abc&lt;/li&gt;        &lt;li&gt;abc&lt;/li&gt;        &lt;li&gt;abc&lt;/li&gt;    &lt;/ul&gt;    &lt;script&gt;        var ul = document.querySelector('ul');        ul.addEventListener('click', function(e) &#123;              // 我们给ul 绑定了事件  那么this 就指向ul                console.log(this); // ul              // e.target 触发了事件的对象 我们点击的是li e.target 指向的就是li              console.log(e.target); // li        &#125;);    &lt;/script&gt;</code></pre><h3 id="cyiXy"><span class="ne-text">阻止默认行为</span></h3><div class="ne-quote"><p id="854c1e3cd2ac3599dc97c6c7e7826ac9" class="ne-p"><span class="ne-text">html中一些标签有默认行为，例如a标签被单击后，默认会进行页面跳转。</span></p></div><pre><code>&lt;a href=&quot;http://www.baidu.com&quot;&gt;百度&lt;/a&gt;    &lt;script&gt;        // 2. 阻止默认行为 让链接不跳转         var a = document.querySelector('a');        a.addEventListener('click', function(e) &#123;             e.preventDefault(); //  dom 标准写法        &#125;);        // 3. 传统的注册方式        a.onclick = function(e) &#123;            // 普通浏览器 e.preventDefault();  方法            e.preventDefault();            // 低版本浏览器 ie678  returnValue  属性            e.returnValue = false;            // 我们可以利用return false 也能阻止默认行为 没有兼容性问题            return false;        &#125;    &lt;/script&gt;</code></pre><h3 id="EzK38"><span class="ne-text">阻止事件冒泡</span></h3><p id="fbc94145f6de007c1d2edc039decc605" class="ne-p"><span class="ne-text">事件冒泡本身的特性，会带来的坏处，也会带来的好处。</span></p><p id="58c12cf373e0565c0759fea7ff3ef9a2" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518361625-d482ad01-1332-4d91-b951-664b337c86f3.png" width="667" id="UdMeX" class="ne-image"></p><pre><code>&lt;div class=&quot;father&quot;&gt;        &lt;div class=&quot;son&quot;&gt;son儿子&lt;/div&gt;    &lt;/div&gt;    &lt;script&gt;        var son = document.querySelector('.son');        // 给son注册单击事件        son.addEventListener('click', function(e) &#123;            alert('son');            e.stopPropagation(); // stop 停止  Propagation 传播            window.event.cancelBubble = true; // 非标准 cancel 取消 bubble 泡泡        &#125;, false);        var father = document.querySelector('.father');        // 给father注册单击事件        father.addEventListener('click', function() &#123;            alert('father');        &#125;, false);        // 给document注册单击事件        document.addEventListener('click', function() &#123;            alert('document');        &#125;)    &lt;/script&gt;</code></pre><p id="3b98a675e82a8647f534b60d88d4aa26" class="ne-p"><strong><span class="ne-text">阻止事件冒泡的兼容性处理</span></strong></p><p id="14666baa432bef3397a3db8126ff71a5" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518361680-f20195f2-69b6-4d72-a6d5-6a5d08646b73.png" width="685" id="Ts107" class="ne-image"></p><h3 id="imMYA"><span class="ne-text">事件委托</span></h3><p id="e7c48210ad41e1d44e7a2e556b53463b" class="ne-p"><span class="ne-text">事件冒泡本身的特性，会带来的坏处，也会带来的好处。</span></p><h4 id="8IDAK"><span class="ne-text">什么是事件委托</span></h4><pre><code>把事情委托给别人，代为处理。</code></pre><p id="4fa8f0acc6d4268beeb196dbc27fff66" class="ne-p"><span class="ne-text">事件委托也称为事件代理，在 jQuery 里面称为事件委派。</span></p><div class="ne-quote"><p id="faf13b4a845244b53c7160acfc1914c9" class="ne-p"><span class="ne-text">说白了就是，不给子元素注册事件，给父元素注册事件，把处理代码在父元素的事件中执行。</span></p></div><p id="d4f77f6cf7cb9a7fb89c1b075582970c" class="ne-p"><strong><span class="ne-text">生活中的代理：</span></strong></p><p id="e4654954748ae19eecb4a109b529d50b" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518361736-9861e13e-f31a-4425-b062-883b21374fce.png" width="689" id="Pr1hq" class="ne-image"></p><p id="196dd6988d488b7c8b788af95edeb655" class="ne-p"><strong><span class="ne-text">js事件中的代理：</span></strong></p><p id="9cce8ee5a723fde233923710d585fd31" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1612518361805-81024b8b-f5e4-488a-91fa-d8ffa16d04fa.png" width="698" id="bFULB" class="ne-image"></p><h4 id="r9vbn"><span class="ne-text">事件委托的原理</span></h4><p id="229515cbd20f9d988912c01d1a7f9f59" class="ne-p"><span class="ne-text">    给父元素注册事件，利用事件冒泡，当子元素的事件触发，会冒泡到父元素，然后去控制相应的子元素。</span></p><h4 id="m9u6H"><span class="ne-text">事件委托的作用</span></h4><ul class="ne-ul"><li id="d3be9d93cb120dca88eb33e7c306e918"><span class="ne-text">我们只操作了一次 DOM ，提高了程序的性能。</span></li><li id="0600d3d420712c5a7ef129876158ca7f"><span class="ne-text">动态新创建的子元素，也拥有事件。</span></li></ul><pre><code>&lt;ul&gt;        &lt;li&gt;知否知否，点我应有弹框在手！&lt;/li&gt;        &lt;li&gt;知否知否，点我应有弹框在手！&lt;/li&gt;        &lt;li&gt;知否知否，点我应有弹框在手！&lt;/li&gt;        &lt;li&gt;知否知否，点我应有弹框在手！&lt;/li&gt;        &lt;li&gt;知否知否，点我应有弹框在手！&lt;/li&gt;    &lt;/ul&gt;    &lt;script&gt;        // 事件委托的核心原理：给父节点添加侦听器， 利用事件冒泡影响每一个子节点        var ul = document.querySelector('ul');        ul.addEventListener('click', function(e) &#123;            // e.target 这个可以得到我们点击的对象            e.target.style.backgroundColor = 'pink';        &#125;)    &lt;/script&gt;</code></pre></div>]]></content>
      
      
      <categories>
          
          <category> Web开发 </category>
          
          <category> JavaScript </category>
          
          <category> DOM </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>『Re：从零开始的异世界生活』</title>
      <link href="/essay/ghnpqy/"/>
      <url>/essay/ghnpqy/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content-editor-core lake-engine lake-typography-traditional" data-lake-element="root" data-selection-undefined="%7B%22path%22%3A%5B%5B9%2C0%2C0%2C0%5D%2C%5B9%2C0%2C0%2C0%5D%5D%2C%22active%22%3Atrue%7D"><blockquote class="lake-alert lake-alert-info" style="margin: 0px; padding: 10px; border: 1px solid rgb(171, 210, 218); opacity: 1; border-radius: 3px; color: rgb(38, 38, 38); background-color: rgb(232, 247, 255);"><p data-lake-id="f82967bdc4f33d74704b90cc17462368" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">“我可是经历过死亡的人！”</p></blockquote><p data-lake-id="9582e6df9c987b482d5ae48d02c1207a" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">第一次听到486说这句话的时候，我是有很大的感触的，甚至是共鸣，因为，见过地狱的人啊……被历史所记载下来的人，总有异于常人的行为准则。</p><p data-lake-id="93f88d7b67a29f6e5043166a785be1a7" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="748c5d0ccf51ff03bb7ffb8ae680b705" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">希特勒，大三寒假在家那会在家看了郭伟强作者译作的《希特勒》一书，以前，我觉得我或多或少了解那个恶魔，因为二战，我觉得这人应该是人们脑海中残酷战争的人形代表吧。或在少年时期，一个人的精神和心智都是极其可变的……</p><p data-lake-id="ea13745d49ec3d0d175d5512c05a82d1" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="623c379379a9be6c5b0afa3cafaede57" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">如果把思维换一下来思考，如果，我明天就死了，那么现在的我会做出什么样的行为呢？因为懂得地狱的可怕，那可怕来自心里面的恐惧、来自亲人爱人的离去、来自一切想要去守护的人的离去……</p><p data-lake-id="3f708d4e7760af998e9917ebb5f534fb" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="4a036f0e7c834ee8e8133f7fb45ddfb5" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">见过地狱的人啊。</p><p data-lake-id="28bca212f0929138b04e3bb7b9562f15" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><blockquote class="lake-alert lake-alert-info" style="margin: 0px; padding: 10px; border: 1px solid rgb(171, 210, 218); opacity: 1; border-radius: 3px; color: rgb(38, 38, 38); background-color: rgb(232, 247, 255);"><p data-lake-id="2ad95152849478bfedeb874ea2d3c77e" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">如果真爱有颜色，那么一定是蓝色</p></blockquote><p data-lake-id="9ed6dea072e29351ce02dd1b1a0799b5" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p></div>]]></content>
      
      
      <categories>
          
          <category> 影视 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>『进击的巨人』是信仰</title>
      <link href="/essay/ebg1s8/"/>
      <url>/essay/ebg1s8/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="u16d69534" class="ne-p"><br></p><p id="839fa5a74076a91fd8a9efafff6083df" class="ne-p"><span class="ne-text">21.05更</span></p><p id="5097b817a0f098f248b241986ed021cd" class="ne-p"><br></p><p id="b602fce0790b25ea19dfb9d2b3dc357a" class="ne-p"><span class="ne-text" style="text-decoration: line-through">海的那边，是自由。</span></p><p id="ea8283829c3eb468b290fd73e112a5ff" class="ne-p"><br></p><p id="899f17bd9c2b0a163e7903c1fb2a3ae1" class="ne-p" style="text-align: center"><span class="ne-text">海的那边，是杀千刀的jsc</span><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1623928492929-ffc048a0-5a85-4f9c-81d6-c71ceda450b5.jpeg" width="75" id="uLVJZ" class="ne-image"></p><p id="u0e3d2f1f" class="ne-p"><br></p><p id="ua85c884d" class="ne-p"><br></p><p id="u4fee72c6" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1623928497065-1e541eba-d224-4125-acee-eb249a83bb3b.jpeg" width="50" id="oqhQI" class="ne-image"></p><p id="1c0798c40473c4568795382dab34c1b6" class="ne-p"><br></p><p id="u5bebfd35" class="ne-p"><br></p><p id="a20d224c568e48b9d67847a2c66a8c01_p_0" class="ne-p"><span class="ne-text">兵长永远是最强的……</span></p><div data-type="info" class="ne-alert"><p id="a7f15d06ca2c0995d66a7da1b165d31d" class="ne-p"><span class="ne-text">你刚才玩的挺开心啊~ </span></p></div><p id="9289e6820487cb3409cda6b787257264" class="ne-p"><br></p><p id="u0a7b4f25" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1619319047360-440f4560-ea7d-4751-822c-0451f0fa40f0.jpeg" width="1100" id="u0d61af7a" class="ne-image"></p><p id="u4b9307cc" class="ne-p"><br></p><p id="27142e226e7527b83e8ddfcece1c2609" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1619482927278-c7d820d9-9797-45ff-89a6-3fc5b4a10304.png" width="1920" id="GvVBt" class="ne-image"></p><p id="fd087ac5a1d6d2d8ba543b8f88885c02" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1619482904818-7bc6ef93-00d8-4fc1-ac3b-75338fb25a41.png" width="1920" id="LStyO" class="ne-image"></p><p id="2a043388ce9bc1b8ca2fc03e7a60384f" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1619482905865-3e7b798f-1888-4ecc-86fd-8200bc78b73b.png" width="1920" id="ExxI6" class="ne-image"></p><p id="udff024df" class="ne-p"><br></p><p id="d19b4a6ad39c6f287df567df62781f89" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1619482909799-aec5bedb-ce37-4f2c-959a-b15c3bd34e8f.png" width="1920" id="W3TmY" class="ne-image"></p><p id="u3c1697cb" class="ne-p"><br></p><p id="u07da6580" class="ne-p"><br></p><p id="ucbeaa1fe" class="ne-p"><br></p><p id="7d22db10ae09c5cbd7d4f68c1097bab9" class="ne-p"><br></p></div>]]></content>
      
      
      <categories>
          
          <category> 影视 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[转]低谷</title>
      <link href="/essay/vpzzbr/"/>
      <url>/essay/vpzzbr/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><blockquote class="ne-quote"><p class="ne-p" style="text-align: left"><span class="ne-text">不要害怕低谷，这是上天给你的升级时间</span></p><p class="ne-p" style="text-align: left"><span class="ne-text">有个好玩的现象，我这里的畅销书，绝大多数是在作者低谷的时候写出来的。比如创业失败、被公司裁员、或者身体不好在家休息等等。</span></p><p class="ne-p" style="text-align: left"><span class="ne-text"></span></p><p class="ne-p" style="text-align: left"><span class="ne-text">为什么呢？因为事业上升时，人被事情推着走，每天忙忙碌碌，没有一块时间思考和复盘。</span></p><p class="ne-p" style="text-align: left"><span class="ne-text">进入低谷后，时间充足，可以好好整理思想了，把以前的经验体系化，于是一本畅销书横空出世。更重要的是，这本书已成为他的视野催化剂，走向人生的第二巅峰。</span></p><p class="ne-p" style="text-align: left"><span class="ne-text"></span></p><p class="ne-p" style="text-align: left"><span class="ne-text">低谷不可怕，可怕的是一蹶不振啊。</span></p><p class="ne-p" style="text-align: left"><span class="ne-text"></span></p><p class="ne-p" style="text-align: left"><strong><span class="ne-text">转载自：写书哥（同微博）</span></strong></p></blockquote></div>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>《围城》有感</title>
      <link href="/essay/obs0vr/"/>
      <url>/essay/obs0vr/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content-editor-core lake-engine lake-typography-classic" data-lake-element="root" data-selection-undefined="%7B%22path%22%3A%5B%5B16%2C2%2C4%5D%2C%5B16%2C2%2C4%5D%5D%2C%22active%22%3Atrue%7D"><p data-lake-id="b789d1efa36e0abe5cbc7219e396bb93" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">持续记录读这本书的所思所感所悟</p><p data-lake-id="e6d3db6f4a85e94337bad3b88d22725f" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><blockquote class="lake-alert lake-alert-info" style="margin: 0px; padding: 10px; border: 1px solid rgb(171, 210, 218); opacity: 1; border-radius: 3px; color: rgb(38, 38, 38); background-color: rgb(232, 247, 255);"><p data-lake-id="a20d224c568e48b9d67847a2c66a8c01_p_0" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">“城外的人想进来，城内的人想出去”</p></blockquote><p data-lake-id="d2d63d2879ad44fc90806f08c5559399" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><blockquote class="lake-alert lake-alert-success" style="margin: 0px; padding: 10px; border: 1px solid rgb(194, 210, 181); opacity: 1; border-radius: 3px; color: rgb(38, 38, 38); background-color: rgb(237, 249, 232);"><p data-lake-id="475e81f65b57fe0952d55508c9f5e73a" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">这真的是一种人生态度，每次用这句话对一系列问题进行思考的时候，我总喜欢在后面加上一句“活在当下，知足常乐”。</p></blockquote><p data-lake-id="c3431d7780d27281483e678fe0f92a0e" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="896e462daba6f696bec087a38b0461d1" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">还是坐在教室里面的一些遐想…</p><p data-lake-id="68e89188f89f7353eb813d5240c982a7" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="c673b7452f6cb01ec12f8001f9a6f195" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">我很难去想象一个没有选择权利的人会怎么样度过这么一生。这是一个极端，也是一个愿以安于现状的人的一种解脱，</p><p data-lake-id="23fd8e2c160a48ce0e49c66115936356" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="e4032a9a58f27c8b7bb6fe8242c556ba" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="ad977d0940dfcd72ed2bc5ac3344b050" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">还没看完，下次再写吧</p><p data-lake-id="553d4176d279bdd2a9d9181e9021915a" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><div data-card-type="block" data-lake-card="hr"><hr style="background-color: rgb(232, 232, 232); border: 1px solid transparent; margin: 18px 0px;"></div><p data-lake-id="dc6f25a0946b8911145587b844fd196d" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">最大的围城，或许就是知识分子之间的吧，就像是一个圈子，这个圈子吧所谓的知识分子划分出来，而这个圈子里面的人或许又如井底的青蛙一样，甚至也不想出去呢~</p><p data-lake-id="c68c97a423a94c11987939de4db0c582" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="50fe0a7ca3a1acae3a25df290ab1f143" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">滑稽的人呀，一切都貌似在追求一些虚无缥缈般地事物一样，易碎​<code style="font-family: monospace; font-size: inherit; background-color: rgba(0, 0, 0, 0.06); padding: 0px 2px; border: 1px solid rgba(0, 0, 0, 0.08); border-radius: 2px; line-height: inherit; overflow-wrap: break-word; text-indent: 0px;">fragile</code>​ ……</p></div>]]></content>
      
      
      <categories>
          
          <category> 阅读 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>计算方法课小记</title>
      <link href="/essay/sdzqr3/"/>
      <url>/essay/sdzqr3/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="traditional"><p id="d9e332cce85f1f3ef7298d122d15d531" class="ne-p"><span class="ne-text">上计算方法课的那个老师，我严重怀疑他有山东口音，他讲话，一开始简直听不清，可能是我还不习惯山东话的缘故吧~可就是在那样的课堂里面，在那些个周里面，我真的是潜移默化般地学到了许多到许多……</span></p><p id="d73afa25b0d28b77dfdf79ec77f2dc0e" class="ne-p"><br></p><p id="a20d224c568e48b9d67847a2c66a8c01_p_0" class="ne-p"><span class="ne-text">大三上学期选了一门计算方法这门课，当时选的人不太多，四十几个吧，当时都是说这门课太难了，需要用到许多之前学习的高数、线代、概率统计等知识，我选这门课，一是自己比较喜欢数学，想着今后应该不做科研了，与数学不出意外应该是不会再相见了，还想再最后学习一下自己最喜欢的科目，也算是一种情怀吧~哈哈，在一个原因就是，这门课四个学分，四个学分！！</span></p><p id="02e23851902c918bbdaca021544d8345" class="ne-p"><br></p><p id="7e97f63a8153e16390c1108753032f9c" class="ne-p"><span class="ne-text">老师经常和我们说，算法就是解决实际问题，以前我们学的理科当中，结果就是是与不是，但是这门课里面，没有对错，他经常让我们看到一个问题，不要立马去看书上的解答，他说书很局限思维，起初我不以为意，渐渐地，我发现了这位老师说的的确对，我记得有一次课是讲求积分，我一直觉得我高数学的还行，老师让我们尽自己所想，想出所有的解决方案，来解决求一个正态分布表这么个简单的问题，老师一再强调让我们不要有正确答案的想法，有解决方案即可，那次我记得那个问题同学们给出的解决方案有许许多多，插值、拟合、泰勒多项式展开、幂级数展开、求面积，多点函数值……</span></p><p id="9b0bb4b85f2dec12205f63aaabae9573" class="ne-p"><br></p><p id="092d046e3d698127add0c41ce2a3402f" class="ne-p"><span class="ne-text">其实从那个时候，我对算法这个事物有了进一步的认识，就像这位常年带学校ACM队的老师所说，算法就是解决实际问题，没有什么对错，只有精度，优化，算法亦是如此，其实那个时候，我对算法设计与分析那门课程里面谈及的各种算法问题，各种算法思想，也有了更加一步的上帝视角来观望。</span></p><p id="05929eda00ae5919fd815a662cd85fa9" class="ne-p"><br></p><p id="9253fa293a725c65c3d84a578fabd5d7" class="ne-p"><span class="ne-text">算法就是解决实际问题，手上敲的代码亦是如此。</span></p><p id="0cf6fc779ba8f66fde6e7988564ec396" class="ne-p"><br></p><p id="20752f0dd67268309d23274c50751265" class="ne-p"><span class="ne-text">他和我们说，我们现在在学校里面学的这些知识出去是用不到的，那为什么还学呢？</span></p><p id="8c49eea7ba0e2a94e20d5aa7979e7ac7" class="ne-p"><br></p><p id="c99f3d7c69c95bae89f8e779587cb237" class="ne-p"><span class="ne-text">能力。他的这个回答，和我的回答一样，身处在这个技术迭代极快的情况下，更何况是计算机行业，我们要学的实在太多了，但是又如老师所言，那些底层的知识，那些思想，是我们这些学习者要学习的，我想老师想表达的更是一种万变不离其中的意味吧。</span></p></div>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>博客与前端历程</title>
      <link href="/essay/sgyoz3/"/>
      <url>/essay/sgyoz3/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content-editor-core lake-engine lake-typography-traditional" data-lake-element="root" data-selection-undefined="%7B%22path%22%3A%5B%5B20%2C0%2C19%5D%2C%5B20%2C0%2C19%5D%5D%2C%22active%22%3Atrue%7D"><blockquote class="lake-alert lake-alert-info" style="margin: 0px; padding: 10px; border: 1px solid rgb(171, 210, 218); opacity: 1; border-radius: 3px; color: rgb(38, 38, 38); background-color: rgb(232, 247, 255);"><p data-lake-id="cba2c4e2b71701941bfa0c1b20ed801e" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">大三上学期，学习计算机网络的应用层那里，我才知道我常写的原来叫博客……</p></blockquote><h2 data-lake-id="92adbbfe4a5aa6608e7cd089ecbd6deb" id="ibOL9" style="padding: 7px 0px; margin: 0px; font-weight: 700; font-size: 24px; line-height: 32px;">学习就要做笔记</h2><p data-lake-id="a14d6fdcaceee344552fd9572dd3fb7a" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">大二上学期期末那会，当时复习操作系统那会在想，为什么我现在想不起来我大一的C语言的一些知识呢？学过的知识过了许久没有记录，没有可以供自己想起的那般线索，还有什么意义呢？于是，那时我就想着在网上弄一个电子笔记吧。</p><p data-lake-id="dedaa9ddca9d558738bd76d7dd060118" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="502c32f5f32c55fee52806f91995cf56" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">于是，我认识了Onenote，Onenote很灵活，以至于太过灵活，不太适合发布文章，用了一段时间，想了想我还是想以发布文章的角色来做笔记</p><p data-lake-id="a9712a7039eaf3d3c9344da5a5317081" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="1bc7ac352eda9f3034b820e0fdf38b84" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">于是期末那段时间我就平时在网上搜适合我做电子笔记的平台，当时改不知道什么是博客，但是看<span style="text-decoration: line-through;">很多人 </span>程序员都有自己的网站写点东西，于是就对其感兴趣了</p><p data-lake-id="39f8636cb14afd1e7e0a872601061e6d" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">再后来就发现很多人都拥有自己的个人网站，而且建立也很简单，一个GitHub就可以了，那会就一直玩GitHub，利用GitHub Pages搭建了一个静态网站</p><p data-lake-id="79016ef87fa507d74e85fa61668ccc5e" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="80be56b949cb5a9ce3c51bbead1b3625" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">疫情期间正好有一门选修课是JavaWeb，那会我就接触了CS架构模型</p><p data-lake-id="3067b5d791ed4700b4958eb0dd40ea66" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="46df8df78309cc710af16c686a0e6142" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">疫情期间，在家发现网上有好多的博客大神。突然有那么一刹那，我突然意识到，我想写的不是笔记，也不是零零碎碎的小想法，我要写的是一篇篇博客，一篇篇文章呀！</p><p data-lake-id="31b804584570c696e8ea320e26e9f4ea" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="c7934e2b02b6d40ffcfbde4bcba20775" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">从那之后，对前端就慢慢了解，前端很难，水很深，需要的自学能力甚至赶超其他行业。</p><p data-lake-id="c49606feb4bd6cb226e0fe51aa7fc1d6" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><h2 data-lake-id="1c8870608f4926bf4e6e23cfef6bcaf8" id="gQsCw" style="padding: 7px 0px; margin: 0px; font-weight: 700; font-size: 24px; line-height: 32px;">前端</h2><p data-lake-id="f60be6a15b71990dff19e58b6f34ad0e" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">其实一直喜欢数据，大一那会，人工智能，机器学习啥的，都特别火，那会我也就学了python，然后数据分析，那会我就挺喜欢数据分析挖掘的，将一堆杂乱的数据经过处理之后，就可以变成各种自己需要的各种数据，还能出图，matplotlib包，我就特别喜欢用这个画各种图</p><p data-lake-id="aceaa9d3d29394e66d88620d6e36a72f" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="4b60ced739e8b0da55379b397af86b5a" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="5e55e088ebeb13830aaac1b8427f3380" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">2021.04.26更</p><p data-lake-id="392a4c5cea7f24baee6ecf587f5f9134" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">好的，已入前端坑🙃，两个字——鬼魅～</p><p data-lake-id="890d5c1fa7a973f0e8769f32ea9db104" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="03c80d4816d1d81b111bd3892cc02b5b" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="afa02f3a67e1c46339d8fe127ba9845c" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="8a929880cea610aceb818399ccb02f75" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="9e5eec44a57eff2d2cbe60014751b27e" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p></div>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>万物守恒</title>
      <link href="/essay/ipgq2m/"/>
      <url>/essay/ipgq2m/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content-editor-core lake-engine lake-typography-classic" data-lake-element="root" data-selection-undefined="%7B%22path%22%3A%5B%5B0%2C0%2C26%5D%2C%5B0%2C0%2C26%5D%5D%2C%22active%22%3Atrue%7D"><p data-lake-id="a20d224c568e48b9d67847a2c66a8c01_p_0" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">什么都是守恒的，我一直觉得这世界上很多事物都是守恒的</p><ul data-lake-id="f41dc6a0380592dbd79392c93c9b4e96" lake-indent="0" style="list-style-type: disc; margin: 0px; padding-left: 23px; font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word;"><li data-lake-id="71604d4a068f0609c501f81d38b46f42">有过很顺的时候，也有过身处逆境</li><li data-lake-id="6d0e9b7b5bf941b8fd15550646b8ffc7">有过巅峰，也有过没落</li><li data-lake-id="10e305127541295efba8bb61559d7ce6">有些时候，你帮助陌生人，到某个时候，你也会被他人帮助</li><li data-lake-id="db95885c159ac2953e4cdc373eca749d">盛极一时的罗马，最后也败于自己</li><li data-lake-id="32e25861b77c470f3e9b1906cce703ed">秦的大一统，也终将没落</li></ul></div>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>一个梦——一切都太迟了</title>
      <link href="/essay/gx3g8t/"/>
      <url>/essay/gx3g8t/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="traditional"><p class="ne-p"><span class="ne-text">那天早上，老康起得很早，五点就起床了，说是要坐车去考教资，然后我突然迷迷糊糊被他起床的动静吵醒了，那天早上，我终于想起了什么…原来，黑魔法是存在的！！！</span></p><p class="ne-p"><br></p><p class="ne-p"><strong><span class="ne-text">和一批人上山</span></strong></p><p class="ne-p"><span class="ne-text">有好几伙人，同时登上山顶，像是被什么所指引那般，都像是阻止什么，又好像是为了得到什么……</span></p><p class="ne-p"><br></p><p class="ne-p"><br></p><p class="ne-p"><strong><span class="ne-text">我的境遇</span></strong></p><p class="ne-p"><span class="ne-text">山顶那个小栈好像是取某个物品，</span></p><p class="ne-p"><br></p><p class="ne-p"><span class="ne-text">夜晚某个时辰，周围突然陷入黑暗，所有人都匆匆忙忙跑下山，那个客栈里面，大量的黑烟逐渐弥漫开来，我们都内心里面清楚，太迟了，我们都太迟了！</span></p><p class="ne-p"><br></p><p class="ne-p"><span class="ne-text">我赶紧跑下山，摔到了一个村庄，然后一直跑，跑到我那个伙伴的家里，我看到了我那副眼镜，然后一直跑，跑回我自己的地方了</span></p></div>]]></content>
      
      
      <categories>
          
          <category> 异世界 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>周围的喧嚣</title>
      <link href="/essay/nqm77s/"/>
      <url>/essay/nqm77s/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="traditional"><p id="d9a1b748e9d5bf4c733df9798ece4464" class="ne-p"><span class="ne-text">现在的文章，喧嚣</span></p><p id="udd66b3fc" class="ne-p"><br></p><p id="u4baa13e0" class="ne-p"><span class="ne-text">动不动一篇文章出来个广告</span></p><p id="ue0a96af3" class="ne-p"><br></p><p id="u2015d2bc" class="ne-p"><span class="ne-text">目的性太强</span></p><p id="u91c22381" class="ne-p"><br></p><p id="u204225f2" class="ne-p"><span class="ne-text">为了写而写，就像是，文字什么时候变得这么苍白</span></p><p id="ee6aed8d571b29cca6f68bd19bd71169" class="ne-p"><br></p></div>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>《许三观卖血记》</title>
      <link href="/essay/ghwn6o/"/>
      <url>/essay/ghwn6o/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content-editor-core lake-engine lake-typography-classic" data-lake-element="root" data-selection-undefined="%7B%22path%22%3A%5B%5B11%2C0%2C33%5D%2C%5B11%2C0%2C33%5D%5D%2C%22active%22%3Atrue%7D"><p data-lake-id="d4cea9740a69221dffc5f2ba9e3f7db3" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">===有一个场景我记得很清楚，当许玉兰被批斗的时候，许三观送饭，在饭下面藏着几块肉，那样的场景，温情脉脉</p><p data-lake-id="602e0d465d59f9fad75c23b850601196" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">还有在家里的时候，玉兰说出自己曾经的种种不堪的事情的时候，许三观为了在几个儿子面前维护玉兰，也同等说出自己的许多不堪的事</p><p data-lake-id="099db7dbd436f79364b4e901ac4c41ff" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">我觉得，这种关系，才像是一起经历过苦难的夫妻作为，那个家庭场景，老实说，我感到很有温度</p><p data-lake-id="c77249fb93f55829de65225e0a08320e" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="8f8ff8415a08cea2870450099f3b7f18" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="60c44371af314bbc5d8e0b0bf4f4732b" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">===小说最后，让我有点痛心的就是三个儿子对许三观说出的一番话。</p><p data-lake-id="90eca51690bc80a509b2c071009e504b" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">子女永远不知道自己父母付出的有多少</p><p data-lake-id="51af3b00918ea9ababfabf97a0ea1618" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">好在身边一直有的是玉兰。</p><p data-lake-id="05202ccf59cd392160058e84b14fb836" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="110d2cf60e2d3d58c9c7b87d2daa4645" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="e73f342f845d00a5ef9992ee105dde8f" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">===突然又想到《活着》，突然又想到富贵的人生似乎更为惨淡，一生下来，经历种种苦楚，最后的人生和一头老牛在田野远远望去</p><p data-lake-id="f93769d5a9c011b9344ab9683729bcdb" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">家珍，还有一个女儿，一个儿子…说实话，他们的结局，也是挺悲惨的……</p></div>]]></content>
      
      
      <categories>
          
          <category> 阅读 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>『斩·赤红之瞳』</title>
      <link href="/essay/vbkkpv/"/>
      <url>/essay/vbkkpv/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="4d5347df929630415d1eaa23d5a8f0b4" class="ne-p"><span class="ne-text">赤瞳的“葬送！”永远无敌，威尔的乡巴佬（贵族）战车甚是让人怀念！</span></p><p id="u02c38766" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1620268429108-34b6b7b4-9e0e-44f5-aec6-6ea523773328.jpeg" width="60" id="tBuFQ" class="ne-image"></p><p id="u011e84f1" class="ne-p"><br></p><p id="uab433b80" class="ne-p"><span class="ne-text">最喜欢威尔这个角色，有自己的信仰，却又不被信仰所蒙蔽双眼！</span></p><p id="u2b652480" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1620268376141-97fd7be2-f256-442b-970d-1ab2b6b29214.png" width="960" id="u9c94a2b1" class="ne-image"></p><p id="u39838fd4" class="ne-p"><br></p><p id="uac513801" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1619317355425-0fe5d175-5fc4-4e3c-b6e0-ecef02d26cf6.png" width="1920" id="uf72f0f30" class="ne-image"></p><p id="2d98ab074f3c7042e488f2cbe8a8fc8b" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1619403236436-3b1f1084-70d1-470c-8033-8da759333d26.png" width="1378" id="KgBwl" class="ne-image"></p><p id="7dc62483859c13d4e812cef7cd35d93a" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1619403320717-174bfe62-fc0d-4470-ade4-dfaec764e1a8.jpeg" width="1920" id="OBENY" class="ne-image"></p><p id="c724b4145e0046b3240614788eaa0dfc" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1619403335035-06379a53-3aa1-4ed1-8194-864aa0423edf.png" width="1920" id="BZQXf" class="ne-image"></p><p id="635826ac418eda5a93f130567610a042" class="ne-p"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1619403340923-d3a0d8f3-2a53-4f2d-ae07-18c5a4d10d3b.jpeg" width="1920" id="poIeY" class="ne-image"></p></div>]]></content>
      
      
      <categories>
          
          <category> 影视 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>榕树下的男孩和女孩</title>
      <link href="/essay/rqlvig/"/>
      <url>/essay/rqlvig/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="1d7566e2ce91837757f63ad4c71dc461" class="ne-p"><span class="ne-text">趁着伙伴们都还在睡觉那天还未入夜，他朝着桥的那头跑去，那天月亮高高挂起，像是蒙娜丽莎的那般深邃眼眸观望着他，突然，他像是被什么东西拍打了一下，男孩往后望去，是个小女孩，那女孩头发短短的，头发末梢还有些卷卷的，就像是柳树下的枝柳发梢一般，凌乱有致，最重要的是男孩被那饱含星辰大海的眼眸所吸引，还有那唇……小男孩突然一愣，回应道：“你是谁？”女孩说：“我练完了，想去桥的那头玩玩！”男孩惊讶之，连忙回应：“我也是”，榕树那边的风景亦是观之，却不能让我陶醉，说罢，小男孩帮那个小女孩整理一番身边的杂草，他想牵起哪个女孩的手，但是他并没有，他在害怕吗？不知道。我想可能是他没有这般前期过别人的手吧。</span></p><p id="4441b864f887e27f7ccf204b29aaccb7" class="ne-p"><br></p><p id="3190081a6e59df3c1441b07abc83880c" class="ne-p"><span class="ne-text">桥的那头好漂亮，哪里有些许的繁华，还有些唱作，同时传来了一阵阵的童谣响起，那个女孩心里一颤，她说，如熟悉的唱作，和我家乡一般，她说她听到了她儿时的童谣，男孩向她的眼眸观去，他像是看到了星辰，他瞬间感受到一种温度，是的！他喜欢上她了。</span></p><p id="a5c0557a57bacf31ec6fad3c7a9a026b" class="ne-p"><br></p><p id="a56aad4aa282c86bfa6016bb8246d630" class="ne-p"><span class="ne-text">榕树下的人们，是有着各自的命运的，男孩和女孩，男孩子要往前走，因为这里的人们是不能停滞的。因为它们本该如此。</span></p><p id="cd07cb19ab0d9b7ed28b6e7e57891e2a" class="ne-p"><br></p><p id="7d0db8c5f650bd4d67fac45439107db1" class="ne-p"><span class="ne-text">男孩终于忍不住了，他对女孩说：“你喜欢这个童谣吗？”女孩说：“好感动，能在这个地方听到这个童谣”，女孩有一个动作，她用手指收起了她的眼泪，男孩心里想着，桥是禁忌，按照他们的文明，那是他们不能逾越的禁忌。</span></p><p id="2d5b2b73089d8c223e2e84e4ab37cd00" class="ne-p"><br></p><p id="750dcb31634e19f9342bc273a591bf68" class="ne-p"><span class="ne-text">旁边的蛐蛐们开始了，仿佛开始为那童谣奏乐了，周围很喧闹，但是他的内心足够安静的，一切都是那般静，那一瞬间，那个男孩就像静静地享受着这般安静与温暖，就像是圆月下的海面，波光涟漪却也有着阵阵波澜。</span></p><p id="e81d44610904b1fb7a710f1c62c7d174" class="ne-p"><br></p><p id="8fa5f2a123c69946518c38feb8be5d17" class="ne-p"><span class="ne-text">桥就像是时间的奴隶，夜深了，桥头的那根锁链开始叮叮叮~的响起，像是提醒着失足的孩子们该回去了，男孩和女孩的时间不读了，往日，男孩会跑着回桥的那头榕树下，来日再来看看这繁华的都市，然后回到榕树下面，因为本该如此，他比谁都清楚榕树下的他背负着怎么样的命运。</span></p><p id="bf773ddc8ebbc413d245ca9a9ce98de2" class="ne-p"><br></p><p id="5e65cf931f30609108468b0a568faa49" class="ne-p"><span class="ne-text">黑夜里，男孩再也看不见女孩的脸，月光很圆，周围的灯也是明亮着的，但男孩却觉得周围一切都是暗淡的，因为他再也看不见那深邃的眼眸。</span></p><p id="bf7c1ce617753b73746228c3656ff276" class="ne-p"><br></p><p id="701110b2feba53e25a78ee149c96e9db" class="ne-p"><span class="ne-text">女孩对男孩说：“谢谢你帮我越过那座桥，我才有了这般幸运，在这榕树下的文明之外还能听到这般旋律，谢谢你！”</span></p><p id="17b374ef3671a31ce0cfc933e636ac65" class="ne-p"><br></p><p id="63d690780371f847b501d7fa5d01a446" class="ne-p"><span class="ne-text">但是男孩心里想要的不是这句谢谢，是她眼神之下的温暖的星辰大海，因为他一直往前走，修炼。</span></p><p id="e6373480df5c8b13e5682bb37b355adb" class="ne-p"><br></p><p id="bf86e966e4fced747e73743c61952f9e" class="ne-p"><span class="ne-text">他想要在榕树下成为一个真正的男人，特立独行，无惧生死，因为他觉得，他本该如此！可今天，他似乎被他的脸庞融化了。</span></p><p id="a4ef5a86c0d7e8da0acc15641c1a2fb9" class="ne-p"><br></p><p id="8226b772c42542e024ff90eccad992c4" class="ne-p"><span class="ne-text">一路上，男孩和女孩说着话，他从来没有这般欣喜，来到榕树下面，这个新生的文明之下，可是，女孩的话却在变少。</span></p><p id="1b64e79979726d07de770d8d9d1af857" class="ne-p"><br></p><p id="09826dd0ccd0dcb374010907d7edf95b" class="ne-p"><span class="ne-text">回到榕树下，隧道已经慢慢如期开启，男孩和女孩要走了，男孩心里清楚着，他不会再见她了，他心里忧伤，却也无奈，因为，在此之下的文明，亦是如此，就像是之前所述的“内壁”那般文明、国度。或者还可以说，文明之间，男孩和女孩是不合适的，因为她走的和他走的路从一开始就是相反的道路，但在榕树下的男孩确实一直以来有着思想的精灵，他有些忍不住了，在女孩走向隧道那扇门之前那么一瞬，男孩大声说：“喂，你，你的眼睛很好看，虽然夜太黑，但我心里还记得，我喜欢你，喜欢你喜欢的童谣，喜欢你眼睛中的星辰大海！我从没有想过，在榕树下的文明，还能遇见此般的你。还有，我很喜欢你的微笑。”女孩说：“嗯。”</span></p><p id="f0977dd3725c4a2381780c8afffe3662" class="ne-p"><br></p><p id="65bfb4e9a768829c0f3c1419f9950934" class="ne-p" style="text-align: right"><span class="ne-text">2020.10.12 文渊楼C区255 划水ing</span></p><p id="d86240bf1f2f2d9aad38e7931f8cd558" class="ne-p"><br></p><p id="93bac6acd442264a945de2d3261188be" class="ne-p"><br></p></div>]]></content>
      
      
      <categories>
          
          <category> 异世界 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>鸟儿飞走了</title>
      <link href="/essay/pyxkf8/"/>
      <url>/essay/pyxkf8/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p class="ne-p"><span class="ne-text">学校又要建楼了，地点是图书馆靠西边的那片树林。</span></p><p class="ne-p"><br></p><p class="ne-p"><span class="ne-text">去二餐的靠建筑工地的那条沿路上，总是听到叽叽喳喳的小鸟叫声，定睛一看，原来是因建筑而没有去路的小鸟，它们就在那片矮秃秃的草丛里面，就像是饿了的稚鸟在窝里面叽叽喳喳等它们母亲回来一般。</span></p><p class="ne-p"><br></p><p class="ne-p"><span class="ne-text">“济南一建”的速度真是快，短短一个月不到，那栋楼就建成有二、三层高楼那般模样，可我却不太喜欢它们这么快速度，因为那样，就会挡住我在E区各个楼道往学校南边观去的视线，正好挡住学校后面的双龙山，学校的小鸟也会少了，估计它们会生气般地往山上飞去，不再飞回来了。</span></p><p class="ne-p"><br></p><p class="ne-p"><span class="ne-text">为什么我会有些许的伤感……</span></p><p class="ne-p"><br></p><p class="ne-p"><br></p></div>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对待问题要静心处理</title>
      <link href="/essay/wgtfly/"/>
      <url>/essay/wgtfly/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content-editor-core lake-engine lake-typography-traditional" data-lake-element="root" data-selection-undefined="%7B%22path%22%3A%5B%5B4%2C0%2C28%5D%2C%5B4%2C0%2C28%5D%5D%2C%22active%22%3Atrue%7D"><p data-lake-id="a20d224c568e48b9d67847a2c66a8c01_p_0" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">在配置安卓环境的时候，遇到sdk漏下载的情况，中间有几次心态爆炸，遇到问题发现自己还是不能很好的解决</p><p data-lake-id="c789ee93d870002ab938c2a1eaa2945c" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="8a79987fff927dee2a879f619b9d093d" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">这过程中，S同学说到他配置环境用到了三天，最后成功了，而且，他的环境远劣于我，突然让我想到一句话，<strong>谁都会遇到问题，甚至遇到的问题都一样</strong>。但是不同的人会有不同的处理方式以及对待问题的态度，我的心真的还不够静，甚至可以说，依旧那么浮躁…</p><p data-lake-id="cce84e6685db6643aa7e727e2610a2da" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="dd4591e6ca22fb5dbaba5cfa73b9180c" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">遇到困难，要静下心来，纸上得来终觉浅，绝知此事要躬行啊～</p></div>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>《世界上所有的夜晚》——那段难忘的谈吐</title>
      <link href="/essay/c47f3d9a749fd0229277f9e9604e69a2/"/>
      <url>/essay/c47f3d9a749fd0229277f9e9604e69a2/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><p id="ud8b3f1df" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1622165460883-a7b33b3d-8426-46e7-ade7-e603c065322e.jpeg" width="135" id="uedac2836" class="ne-image"></p><p id="ubc8be0f2" class="ne-p" style="text-align: center"><br></p><p id="u30d31720" class="ne-p" style="text-align: left"><span class="ne-text" style="color: #111111; font-size: 14px">每本书，总会有那么一段让你记忆难忘。最难忘的是和蒋百嫂酒后那段谈吐，夜半作者打算回旅馆，却听见轰隆隆的响声，当看见冰柜里的那具尸体之后，仿佛像是探照灯照亮了一个人不愿流露的内心，悲凉，同情。每个人都有属于自己的夜晚，心灵寄居在此，有的看似洒脱却也痛苦无奈。</span></p><p id="u9fd7c745" class="ne-p" style="text-align: left"><span class="ne-text" style="color: #111111; font-size: 14px"></span></p><p id="u3760b15d" class="ne-p" style="text-align: left"><span class="ne-text" style="color: #111111; font-size: 14px">看完这本书，我才渐渐了解迟子建这个作家，不过非常尴尬，在此之前我一直以为迟子建是位男作家····作者真的是一个善于观察的生活记录者，很喜欢那样轻快的语言，迟子建是在我读书时期，让我喜欢上文学的人之一，高中那会，就喜欢蹲在书店的书架后面看他写的书，看完之后，心情甚是愉悦~～～回忆啊，那个下午放学到晚自习那段一个小时，总喜欢跑书店看一些神神叨叨的书</span></p><p id="ubf6a34bc" class="ne-p" style="text-align: left"><span class="ne-text" style="color: #111111; font-size: 14px"></span></p><p id="u0c2db998" class="ne-p"><span class="ne-text" style="color: #111111; font-size: 14px">每个人都有属于自己的夜晚，每个人都有属于自己的回忆 :-）</span></p><p id="u94367c57" class="ne-p"><br></p><hr id="zWNXp" class="ne-hr"><p id="u910ad56d" class="ne-p"><br></p><p id="u29e8bd35" class="ne-p"><span class="ne-text">《世界上所有的夜晚》迟子建的一本比较短的小说，这部小说，也是在那期间第一本我一天之内看完的一本小说，很多时候，我总是想起煤矿镇的那个村庄的人，事实上，那都是我们身边的人，也是那本书我内心深深的感知，这世上有很多不幸的人，这世上不止一个夜晚，有无数个人人牵挂的夜晚，这世上又只有一个夜晚，那个独自存在的灵魂的夜晚……</span></p><p id="uf4a332de" class="ne-p"><br></p><p id="u96555e86" class="ne-p"><br></p><hr id="WObKJ" class="ne-hr"><p id="u6b2bc270" class="ne-p"><br></p><p id="u506a2f5e" class="ne-p"><span class="ne-text">想想以前的一些悠闲经历， 上课偷偷式看小说 、备考期间，自我欺骗/麻痹式看小说 ，大学依旧是上课老喜欢在全班同学都认真听讲而我坐在后排靠窗角落看小说</span><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1622165717851-7436873d-a34b-48b7-a8fa-d32e45eb7e4b.jpeg" width="51" id="HxzJ4" class="ne-image"></p><p id="uf8a684f2" class="ne-p"><br></p><p id="uc20af8ee" class="ne-p"><br></p><p id="uc58eea44" class="ne-p"><span class="ne-text">然而现在， 快节奏的日常似乎霸占生活的全部 ，身边有这么优秀的环境，我忘却了曾经的那一丝快感……</span></p><p id="u5a4c0257" class="ne-p"><br></p><p id="ude9c354b" class="ne-p"><span class="ne-text">其实，生活本可以有一丝轻快，不用太过追求什么</span></p><p id="u33098461" class="ne-p"><br></p></div>]]></content>
      
      
      <categories>
          
          <category> 阅读 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>至暗之路</title>
      <link href="/essay/ew2l6r/"/>
      <url>/essay/ew2l6r/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content-editor-core lake-engine lake-typography-classic" data-lake-element="root" data-selection-undefined="%7B%22path%22%3A%5B%5B12%2C0%2C5%5D%2C%5B12%2C0%2C5%5D%5D%2C%22active%22%3Atrue%7D"><p data-lake-id="84fca8abe9d50557666319033f6713e2" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">一个人如若是他很强，一或者说在别人眼中看起来很强，那么他一定是有着他自己的一段至暗时光。</p><p data-lake-id="7c5ac138d2b9271acb9a6c4afb002989" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="c70128d04575f817fb31a00f159f4aaa" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">我们总是不喜欢往回看。往回看有两种情况，一种是你的过往是让你愉悦的，让你充满开心快乐，还有一种就是让你哽咽，不想多言，或是说，那段时光虽然让你收获很多，但是它并非是你很想经历的。至暗时光的确可以让自己变得更强，但是凡事你能得到就必然有舍弃，我觉得那段至暗时光让我舍弃的就是与他人的人情味。</p><p data-lake-id="c8a095e88296ed380c3d65eef501fb34" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="3294b573ac4ae1e75c99048de5494474" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">我的确很恨，恨为什么是我经受那种环境，一个本不是第一环境的人，却也落得个第一环境的人，就像是内壁中有遗留下的异世界的人一样，很愤懑，却也不得抒情。我觉得这可能就是古时候的诗人那般抒情吧，失意，惆怅，但唯一与身边人不同的就是，不会迷茫，内心却是异常的笃定，于是乎他开始变得与周围的人都不太一样，他开始学会跳出内壁，内壁下的人们就仿佛是用来衬托这个本不该落下的内壁之外的人，但，就像是那片沙漠尽头的那般高墙一般，他的落下，是因为他在他那个文明下触及到他不应该触及的所谓的“法律”。</p><p data-lake-id="89c53d091225673f5fafb8b50d54b47a" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="62c89cf900593957f41bf1b2d0c90bbc" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">“什么都不舍弃，就什么改变不了”</p><p data-lake-id="6b2f189f9ea9fbc97e7de0629176b65c" style="text-align: right; font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">——爱尔敏</p><p data-lake-id="6a7344e9eec3e23cd6843f8ba2c48055" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="8222eafcb027ff2688393174fc37470b" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">于是乎，他开始讨厌内壁下的种种，他觉得，在他那个文明，这不应该是他应该所接触的。他觉得，他不是内壁下的人们，他应该回到他所觉得的那个高级文明。所以，他的那种与世人抵触，让他踏上至暗时光，在此有必要提醒一点，至暗，不一定是贬义词，更多的时候，它是一种中性词。</p><p data-lake-id="351d69dfa1ae7a1aed67e18407434dbf" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="71a2b2a09b2d030f9a9cb466ef309776" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">“错的不是我，而是这个世界”</p><p data-lake-id="89dd753afe5dfd31fbb1dca994e19223" style="text-align: right; font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">——金木研</p><p data-lake-id="79a4b4832f341c7cde8a392400d93bbb" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="a68844bf16b3d944665ccdc664b4159f" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="3c75f8b7ba1c11af2289ca086bee2f9e" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p></div>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>“什么都无法舍弃，什么也改变不了”</title>
      <link href="/essay/vattip/"/>
      <url>/essay/vattip/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content" typography="classic"><div data-type="info" class="ne-alert"><p id="a20d224c568e48b9d67847a2c66a8c01_p_0" class="ne-p"><span class="ne-text">什么也无法舍弃的人，也无法改变任何事情吧。</span></p><p id="29a52ba517268eadd4813c6ebff54c6c" class="ne-p"><span class="ne-text">——爱尔敏·阿诺德</span></p></div><p id="d8173a1c126e93f28da1959621eed651" class="ne-p"><br></p><p id="9f4295c4b66502d1fae7ef9d51f62576" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2021/png/1484158/1620265214393-3e90a086-8121-4c96-8f09-6d9bd1406fd2.png" width="383.5" id="BxjYe" class="ne-image"></p><p id="5d9e8927bebce7d9f5ad1a0dac642b07" class="ne-p"><br></p><p id="c56d928fb271c2369e13ae507d602a01" class="ne-p"><code class="ne-code"><span class="ne-text">2021.04.28</span></code></p><p id="aeaec709b701125022bda16ec8b4428c" class="ne-p"><br></p><p id="b5e559fe6cc245e8780f5a4432c58b76" class="ne-p"><span class="ne-text">突然对舍弃有了一个新的见解，</span></p><p id="8a905f65ebde8c676cf8312b5f85038e" class="ne-p"><br></p><p id="d8101d0c005c5cab6da40da0df6e0666" class="ne-p"><span class="ne-text">舍弃，很多时候，不仅仅是执行者主观的做法，还有一种就是，被动的舍弃…</span></p><p id="68c1cfe69c29b6de58143967ad2628b5" class="ne-p"><br></p><p id="a1e6c7c422926c790fbcaeff4611a3e6" class="ne-p"><span class="ne-text">因为你注定要成为什么样的人，所以注定你必须要舍弃某些东西，那么这个时候，对这样的选择该怎么办呢？</span></p><p id="5c6b0d6963f3f0c1940d56ca3e0858bc" class="ne-p" style="text-align: center"><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1484158/1619589532108-e98a4fc8-907a-40c4-9e74-2eb76b34d311.jpeg" width="445" id="DNXMj" class="ne-image"></p><p id="6237e4d182036c59b12714c30fcdadb8" class="ne-p"><br></p><p id="8fc562f12f84f5e8d2983e5b525d27e3" class="ne-p"><code class="ne-code"><span class="ne-text">2021.04.29</span></code></p><p id="8e756937e73d9cf506f8c247ed4cc255" class="ne-p"><br></p><p id="f1a04263255875626989fd71a314597d" class="ne-p"><span class="ne-text">什么是得到呢？</span></p><p id="c4ba1f02d7262e7df9384295477b9619" class="ne-p"><br></p><p id="23f5049c28de938bba48c0cf22595779" class="ne-p"><span class="ne-text">也许，现在的你没得到，不代表今后的你不会得到，不同的时段，我们所在乎的还会一样吗？</span></p><p id="c861251c6ef0f076f314625f0ccdfb60" class="ne-p"><br></p></div>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>快节奏下的人们</title>
      <link href="/essay/gm1to9/"/>
      <url>/essay/gm1to9/</url>
      
        <content type="html"><![CDATA[<!doctype html><div class="lake-content-editor-core lake-engine lake-typography-classic" data-lake-element="root" data-selection-undefined="%7B%22path%22%3A%5B%5B10%2C0%2C48%5D%2C%5B10%2C0%2C48%5D%5D%2C%22active%22%3Atrue%7D"><p data-lake-id="a20d224c568e48b9d67847a2c66a8c01_p_0" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">如今的抒情，早已不知道为何变得如此奢侈</p><p data-lake-id="79eeea539b9d202e36b6faf150f4260b" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="58b2d7fe339545ff61bc6a7d7b962732" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">我们更多的是用心感受远行，而不是，来到一个地方，拍个照，发朋友圈，嗯，我来过，而已……</p><p data-lake-id="f5ca9b0380dd34579466b6f61bd45b0a" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="916cf591785d0dfa3c5b8380c7c10eba" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">什么时候，抒情也变得如此廉价</p><p data-lake-id="ce2a01aa01573a17990818ee709b9b12" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="bf7454c7494d1e86d5cd8bab0db34087" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="1526ef00699787ea894a90b00912c7a7" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">写东西更多的是一种抒发内心想法，简单且纯粹，就像是记录下来的，就是我的内心真实写照，</p><p data-lake-id="fbf163a1dd38817a952f15095e27ce62" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="f2f87ec4aed0ccc740746755a184ed94" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;"><br></p><p data-lake-id="97b22bf37303cadfc2842d6d0c242554" style="font-size: 14px; color: rgb(38, 38, 38); line-height: 1.74; letter-spacing: 0.05em; outline-style: none; overflow-wrap: break-word; margin: 0px;">微商—自媒体—短视频，人们变得不仅是快节奏，更是一种焦虑，为什么会焦虑呢？因为这个社会太快了……</p></div>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
